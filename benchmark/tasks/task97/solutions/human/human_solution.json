[
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n  while(1){\n    int w,h,mp[20][20]={},dp[20][20] ={};\n    cin >> w >> h;\n    if(w==0 && h==0) break;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++) cin >> mp[i][j];\n   \n\n    int ans=0;   \n    for(int i=0;i<w;i++) {\n      if(mp[0][i]==0) dp[0][i] = 1;\n      if(i >=h-1)ans+=dp[0][i];\n    }\n    for(int i=0;i<h-1;i++)\n      for(int j=0;j<w;j++) \n\tfor(int k=-1;k<=1;k++){\n\t  int nx=j+k,ny=i+1;\n\t  if(nx<0||nx>=w || mp[i][j] !=0) continue;\n\t  if(k==0)while(mp[ny][nx]==2) ny+=2;\n\t  if(mp[ny][nx]!=0) continue;\n\t  dp[ny][nx]+= dp[i][j];\n\t  if(ny >= h-1) ans+=dp[i][j];\n\t}\n\n      cout << endl;\n      for(int i=0;i<h+3;i++){\n      for(int j=0;j<w;j++)cout << dp[i][j] <<\" \";\n      cout << endl;\n      }\n\n    cout << ans <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//03\n#include<iostream>\n\nusing namespace std;\n\nint main(){\n  for(int x,y;cin>>x>>y,x|y;){\n    int g[17][16]={};\n    for(int i=1;i<=x;i++){\n      for(int j=1;j<=y;j++){\n\tcin>>g[i][j];\n      }\n    }\n    int a[17][16]={};\n    for(int i=1;i<=x;i++){\n      a[1][i]=g[1][i]==0;\n    }\n    for(int i=1;i<=y-1;i++){\n      for(int j=1;j<=x;j++){\n\tif(g[i][j]==0){\n\t  for(int k=-1;k<=1;k++){\n\t    if(1<=j+k&&j+k<=x){\n\t      if(g[i+1][j+k]==0){\n\t\ta[i+1][j+k]+=a[i][j];\n\t      }else if(k==0&&g[i+1][j]==2){\n\t\ta[i+1][j]+=a[i][j];\n\t      }\n\t    }\n\t  }\n\t}else if(g[i][j]==2){\n\t  if(g[i+2][j]!=1){\n\t    a[i+2][j]+=a[i][j];\n\t  }\n\t}\n      }\n    }\n    int ans=0;\n    for(int i=1;i<=x;i++){\n      ans+=a[y][i]+a[y+1][i];\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <complex>\n#include <ctime>\n#include <cstdlib>\n\nusing namespace std;\n\ninline int to_int(string s) {int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string to_str(T x) {ostringstream sout; sout << x; return sout.str();}\n\ntypedef long long ll;\n\nint wide, tall, field[16][16], memo[16][16];\n\nint skiing(int x, int y, bool ok)\n{\n\tif( x < 0 || x >= wide || field[y][x] == 1 || field[y][x] == 2 && ok == true )\n\t{\n\t\treturn 0;\n\t}\n\telse if( y >= tall - 1 )\n\t{\n\t\treturn 1;\n\t}\n\n\tif( memo[y][x] != -1 )\n\t{\n\t\treturn memo[y][x];\n\t}\n\n\tif( field[y][x] == 2 )\n\t{\n\t\treturn memo[y][x] = skiing(x, y+2, false);\n\t}\n\telse\n\t{\n\t\treturn memo[y][x] = skiing(x-1, y+1, true) + skiing(x, y+1, false) + skiing(x+1, y+1, true);\n\t}\n}\n\nint main()\n{\n\tint cnt;\n\twhile( cin >> wide >> tall )\n\t{\n\t\tif( wide == 0 && tall == 0 )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tmemset(memo, -1, sizeof(memo));\n\n\t\tfor(int i = 0; i < tall; i++)\n\t\t{\n\t\t\tfor(int j = 0; j < wide; j++)\n\t\t\t{\n\t\t\t\tcin >> field[i][j];\n\t\t\t}\n\t\t}\n\t\tcnt = 0;\n\t\tfor(int i = 0; i < wide; i++)\n\t\t{\n\t\t\tcnt += skiing(i, 0, false);\n\t\t}\n\n\t\tcout << cnt << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\nint a[16][16];\nint count = 0;\nint n,m;\n\nvoid dfs(int y,int x)\n{\n\tif(y > m-1)\n\t{\n\t\treturn;\n\t}\n\n\tif(a[y][x] == 0)\n\t{\n\t\tif(y == m-1)\n\t\t{\n\t\t\tcount++;\n\t\t\treturn;\n\t\t}\n\t\tif(x-1 >= 0 && y+1 < m)\n\t\t{\n\t\t\tif(a[y+1][x-1] != 2)\n\t\t\t{\n\t\t\t\tdfs(y+1,x-1);\n\t\t\t}\n\t\t}\n\t\tif(y+1 < m)\n\t\t{\n\t\t\tdfs(y+1,x);\n\t\t}\n\t\tif(x+1 < n && y+1 < m)\n\t\t{\n\t\t\tif(a[y+1][x+1] != 2)\n\t\t\t{\n\t\t\t\tdfs(y+1,x+1);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\telse if(a[y][x] == 1)\n\t{\n\t\treturn;\n\t}\n\telse if(a[y][x] == 2)\n\t{\n\t\tif(y == m-2 || y == m-1)\n\t\t{\n\t\t\tcount++;\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdfs(y+2,x);\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile(cin >> n >> m)\n\t{\n\t\tif(n == 0 && m == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tmemset(a,0,sizeof(a));\n\t\trep(i,n)\n\t\t{\n\t\t\trep(j,m)\n\t\t\t{\n\t\t\t\tcin >> a[i][j];\n\t\t\t}\n\t\t}\n\t\tcount = 0;\n\t\trep(i,n) dfs(0,i);\n\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main()\n{\n    while(1)\n    {\n        int x,y;\n        long long ans=0;\n        long long dp[16][16]={0};\n        int course[15][15]={0};\n        cin>>x>>y;if(!x)return 0;\n        for(int j=0;j<y;++j){\n            for(int i=0;i<x;++i){\n            \tcin>>course[i][j];\n            \tif(!course[i][0])dp[i][0]=1;\n            }\n        }\n        for(int j=0;j<y-1;++j){\n            for(int i=0;i<x;++i){\n                if(!course[i][j]){\n                    if(course[i][j+1]!=1)dp[i][j+1]+=dp[i][j];\n                    if(i){\n                        if(!course[i-1][j+1])dp[i-1][j+1]+=dp[i][j];\n                    }\n                    if(i<x){\n                        if(!course[i+1][j+1])dp[i+1][j+1]+=dp[i][j];\n                    }\n                }\n                if(course[i][j]==2){\n                    if(course[i][j]!=1)dp[i][j+2]+=dp[i][j];\n                }\n            }\n        }\n        for(int j=y-1;j<y+1;++j){\n            for(int i=0;i<x;++i){\n                ans+=dp[i][j];\n            }\n        }\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint X,Y;\nint dp[20][20];\nchar maps[20][20];\nint bun(int x,int y);\nint dx[3]={-1,0,1};\nmain(){\n  while(1){\n    cin>>X>>Y;\n    if(X==0&&Y==0){\n      break;\n    }\n    for(int i=1;i<=Y;i++){\n      for(int j=1;j<=X;j++){\n\tcin>>maps[i][j];\n\tdp[i][j]=0;\n      }\n    }\n    int ans=0;\n    for(int i=1;i<=X;i++){\n      if(maps[1][i]!='1'){\n\tans+=bun(1,i);\n      }\n    }\n    cout<<ans<<endl;\n  }\n}\nint bun(int y,int x){\n  if(y>=Y){\n    return 1;\n  }\n  else if(dp[y][x]!=0){\n    return dp[y][x];\n  }\n  else if(maps[y][x]=='2'&&maps[y+2][x]!='1'){\n    return bun(y+2,x);\n  }\n  else if(maps[y][x]=='1'){\n    return 0;\n  }\n  else{\n    int anss=0;\n    for(int i=0;i<3;i++){\n      int nx=x+dx[i];\n      if(i!=1){\n\tif(nx>0&&nx<=X&&maps[y+1][nx]=='0'){\n\t  anss+=bun(y+1,nx);\n\t}\n      }\n      else{\n\tif(maps[y+1][nx]!='1'){\n\t  anss+=bun(y+1,nx);\n\t}\n      }\n    }\n    return dp[y][x]=anss;\n  }\t  \t  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint main() {\n\tint map[15][15];\n\tint dp[16][15];\n\tint X, Y;\n\tint dx[] = { -1, 0, 1 };\n\n\twhile (cin >> X >> Y, X||Y) {\n\t\tmemset(dp, 0, sizeof(dp));\n\n\t\tfor (int i=0; i<Y; i++)\n\t\tfor (int j=0; j<X; j++)\n\t\t\tcin >> map[i][j];\n\n\t\tfor (int i=0; i<X; i++) { \n\t\t\tdp[0][i] = (map[0][i]==1) ? 0 : 1;\n\t\t\tdp[Y][i] = 0;\n\t\t}\n\n\t\tfor (int y=0; y<Y-1; y++)\n\t\tfor (int x=0; x<X; x++) {\n\t\t\tint p;\n\t\t\tswitch (map[y][x]) {\n\t\t\t\tcase 0:\n\t\t\t\t\tfor (int i=0; i<3; i++) {\n\t\t\t\t\t\tp = x + dx[i];\n\t\t\t\t\t\tif (p<0 || p>=X) continue;\n\t\t\t\t\t\tif (map[y+1][p]==1 || (map[y+1][p]==2 && i!=1)) continue;\n\t\t\t\t\t\tdp[y+1][p] += dp[y][x];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tif (map[y+2][x]!=1) dp[y+2][x] += dp[y][x];\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tfor (int i=0; i<X; i++)\n\t\t\tans += dp[Y-1][i] + dp[Y][i];\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <functional>\n#include <numeric>\n#define fi first\n#define se second\nusing namespace std;\nbool value(int y,int x,int R,int C){return 0<=y&&y<R&&0<=x&&x<C;}\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<long long > vll;\ntypedef vector< vi > vvi;\ndouble pie=acos(-1);\nint INF=10000009;\nint dx[4] = { 0,-1,0,1 };\nint dy[4] = { -1,0,1,0 };\nint c[20][20];\nlong long int dp[20][20];\nint main() {\n\tint X,Y;\n\twhile(true){\n\t\tlong long int ans=0;\n\t\tcin>>X>>Y;\n\t\tif(X+Y==0) break;\n\t\tfor(int i=1;i<=Y;i++){\n\t\t\tfor(int j=1;j<=X;j++){\n\t\t\t\tcin>>c[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=X;i++){\n\t\t\tif(c[1][i]==1){\n\t\t\t\tdp[1][i]=0;\n\t\t\t}\n\t\t\tif(c[1][i]==0){\n\t\t\t\tdp[1][i]=1;\n\t\t\t}\n\t\t\tif(c[1][i]==2){\n\t\t\t\tdp[1][i]=1;\n\t\t\t\tdp[3][i]=1;\n\t\t\t}\n\t\t}\n\t\tfor(int i=2;i<=Y;i++){\n\t\t\tfor(int j=1;j<=X;j++){\n\t\t\t\tif(c[i][j]==1) dp[i][j]=0;\n\t\t\t\telse if(c[i][j]==0){\n\t\t\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\t\t\tif(c[i-1][j-1+k]!=2){\n\t\t\t\t\t\t\tdp[i][j]+=dp[i-1][j-1+k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(c[i-1][j]!=2){\n\t\t\t\t\t\tdp[i][j]+=dp[i-1][j];\n\t\t\t\t\t}\n\t\t\t\t\tdp[i+2][j]+=dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=Y;i<=Y+2;i++){\n\t\t\tfor(int j=1;j<=X;j++){\n\t\t\t\tans+=dp[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=Y+2;i++){\n\t\t\tfor(int j=1;j<=X;j++){\n\t\t\t\tdp[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#include<algorithm>\nusing namespace std;\nint vx[3]={-1,0,1};\nint main(){\n  int x,y;\n  while(cin>>y>>x,x+y!=0){\n    int Map[y+3][x+3]={0};\n    int cnt=0;\n    for(int i=1;i<=y;i++)\n      for(int j=1;j<=x;j++)\n\tcin>>Map[i][j];\n    queue<pair<int,int> >qii;\n    for(int i=1;i<=x;i++){\n      if(Map[1][i]!=1)\n\tqii.push(make_pair(1,i));\n    }\n    while(!(qii.empty())){\n      pair<int,int>now = qii.front();\n      qii.pop();\n     \n      switch(Map[now.first][now.second]){\n      case 0:\n\tfor(int i=0;i<3;i++){\n\t  if(Map[now.first+1][now.second+vx[i]]==0){ \n\t    if(now.second<1||now.second>x)\n\t      continue;\n\t    if(now.first > y-1){\n\t      cnt++;\n\t      continue;\n\t    }\n\t    qii.push(make_pair(now.first+1,now.second+vx[i]));\n\t  }\n\t}\n\tif(Map[now.first+1][now.second]==2){\n\t  if(now.first > y-1){\n\t    cnt++;\n\t    continue;\n\t  }\n\t  qii.push(make_pair(now.first+1,now.second));\n\t}\n\tbreak;\n      case 2:\n\tif(Map[now.first+2][now.second]!=1){\n\t  if(now.first > y-1){\n\t    cnt++;\n\tcontinue;\n\t  }\n\t  qii.push(make_pair(now.first+2,now.second));\n\t}\n\tbreak;\n      }\n    }\n    cout<<cnt<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define N 15\nusing namespace std;\nvoid func(int,int);\nint jump(int,int);\nint X,Y,data[N][N],memo[N][N];\nint main(){\n  while(1){\n    cin >> X >> Y;\n    if(X==0&&Y==0) break;\n    for(int i=0;i<Y;i++)\n      for(int j=0;j<X;j++)memo[i][j]=0;\n    for(int i=0;i<Y;i++)\n      for(int j=0;j<X;j++) cin >> data[i][j];\n    for(int i=0;i<X;i++)\n      if(data[0][i]==0) func(0,i);\n    int cnt=0;\n    for(int i=0;i<X;i++) cnt+=memo[0][i];\n    cout << cnt << endl;\n  }\n  return 0;\n}\nvoid func(int y,int x){\n  if(y==Y-1){\n    memo[Y-1][x]=1;\n    return ;\n  }\n  if(0<=x-1&&data[y+1][x-1]==0){\n    if(memo[y+1][x-1]==0) func(y+1,x-1);\n    memo[y][x]+=memo[y+1][x-1];\n  }\n  if(x+1<X&&data[y+1][x+1]==0){\n    if(memo[y+1][x+1]==0) func(y+1,x+1);\n    memo[y][x]+=memo[y+1][x+1];\n  }\n  if(data[y+1][x]==0){\n    if(memo[y+1][x]==0) func(y+1,x);\n    memo[y][x]+=memo[y+1][x];\n  }\n  if(data[y+1][x]==2){\n    int r=jump(y+1,x);\n    if(r==-2) memo[y][x]+=1;\n    else if(r!=-1){\n      if(memo[r][x]==0) func(r,x);\n      memo[y][x]+=memo[r][x];\n    }\n  }\n  if(memo[y][x]==0) data[y][x]=1;\n}\nint jump(int y,int x){\n  while(1){\n    y+=2;\n    if(data[y][x]==1) break;\n    if(y>=Y-1) return -2;\n    if(data[y][x]==0) return y;\n  }\n  return -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\nint x,y,M[50][50],D[50][50],i,j,r;\nmain(){\n        for(;;){\n                scanf(\"%d%d\",&x,&y);\n                if(x==0)exit(0);\n                for(i=0;i<289;i++) {M[i%17][i/17]=1;D[i%17][i/17]=0;}\n                for(i=0;i<y;i++)\n                        for(j=0;j<x;j++)\n                                scanf(\"%d\",&M[j+1][i]);\n                for(j=1;j<=x;j++){if(M[j][y-1]!=1)D[j][y-1]=1;D[j][y]=1;}\n                for(j=y-2;j>=0;j--){\n                        for(i=1;i<=x;i++){\n                                if(M[i][j]==0) {\n                                        D[i][j]=D[i][j+1];\n                                        if(M[i+1][j+1]!=2) D[i][j]+=D[i+1][j+1];\n                                        if(M[i-1][j+1]!=2) D[i][j]+=D[i-1][j+1];\n                                }\n                                if(M[i][j]==2) D[i][j]=D[i][j+2];\n                        }\n                }\n                r=0;\n                for(i=1;i<=x;i++){\n                        r+=D[i][0];\n                }\n                printf(\"%d\\n\",r);\n        }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nconst int MAX = 15;\nconst int dx[] = {-1, 0, 1};\nint X, Y;\nint c[MAX + 2][MAX + 2], dp[MAX + 2][MAX + 2];\n\nint main()\n{\n    while(cin >> X >> Y && X) {\n        for(int i = 1; i <= Y; i++)\n            for(int j = 1; j <= X; j++)\n                cin >> c[i][j];\n\n        memset(dp, 0, sizeof(dp));\n        for(int j = 1; j <= X; j++) \n            dp[1][j] = (c[1][j] == 0) ? 1 : 0;\n        \n        for(int i = 2; i <= Y; i++) {\n            for(int j = 1; j <= X; j++) {\n                if(c[i][j] == 0) {\n                    for(int k = 0; k < 3; k++)\n                        if(c[i - 1][j + dx[k]] == 0)\n                            dp[i][j] += dp[i - 1][j + dx[k]];\n                } else if(c[i][j] == 1) {\n                    dp[i][j] = 0;\n                } else {\n                    if(dp[i][j] == 0) \n                        dp[i][j] = dp[i - 1][j];\n                    dp[i + 2][j] = dp[i][j];\n                }\n            }\n        }\n        \n        int ans = 0;\n        for(int j = 1; j <= X; j++) \n            if(dp[Y + 1][j] > 0)\n                ans += dp[Y + 1][j];\n            else \n                ans += dp[Y][j];\n\n        cout << ans << endl;\n        \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nint a[16][16];\nlong long dp[18][16];\nint main()\n{\n    while (true) {\n        int h, w;\n        scanf(\"%d%d\", &w, &h);\n        if (!(w | h)) break;\n        for (int i = 0; i < 16; ++i) for (int j = 0; j < 16; ++j)\n            dp[i][j] = 0;\n        for (int i = 0; i < h; ++i) for (int j = 0; j < w; ++j)\n            scanf(\"%d\", &a[i][j]);\n\n        for (int j = 0; j < w; ++j)\n            if (a[0][j] == 0) dp[0][j] = 1;\n        for (int i = 1; i < h; ++i) for (int j = 0; j < w; ++j) {\n            if (a[i][j] == 1) continue;\n            if (a[i-1][j] != 2) dp[i][j] = dp[i-1][j];\n            if (a[i][j] == 0) {\n                if (j > 0 && a[i-1][j-1] == 0) dp[i][j] += dp[i-1][j-1];\n                if (j < w-1 && a[i-1][j+1] == 0) dp [i][j] += dp[i-1][j+1];\n            }\n            if (i > 1 && a[i-2][j] == 2) dp[i][j] += dp[i-2][j];\n        }\n        for (int j = 0; j < w; ++j) {\n            dp[h][j] = dp[h-1][j];\n            if (h > 1 && a[h-2][j] == 2) dp[h][j] += dp[h-2][j];\n        }\n        int res = 0;\n        for (int j = 0; j < w; ++j) res += dp[h][j];\n        printf(\"%d\\n\", res);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <sstream>\n#include <cmath>\n#include <queue>\n\nusing namespace std;\n\nbool is_inside(int x, int y, int X, int Y){\n\tif(x < 0 || y < 0 || x >= X || y >= Y){\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nint main(){\n\t\n\tint X, Y;\n\t\n\tint course[20][20];\n\tint sum[20][20];\n\t\n\twhile(true){\n\t\tcin >> X >> Y;\n\t\t\n\t\tif(X == 0 && Y == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < Y; i++){\n\t\t\tfor(int j = 0; j < X; j++){\n\t\t\t\tcin >> course[j][i];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i <= Y; i++){\n\t\t\tfor(int j = 0; j < X; j++){\n\t\t\t\tsum[j][i] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < X; i++){\n\t\t\tif(course[i][0] == 1){\n\t\t\t\tsum[i][0] = 0;\n\t\t\t}else{\n\t\t\t\tsum[i][0] = 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int y = 0; y < Y; y++){\n\t\t\tfor(int x = 0; x < X; x++){\n\t\t\t\tif(course[x][y] == 0){\n\t\t\t\t\tfor(int dx = -1; dx <= 1; dx++){\n\t\t\t\t\t\tif(is_inside(x + dx, y + 1, X, Y)){\n\t\t\t\t\t\t\tif(course[x + dx][y + 1] != 2 || dx == 0){\n\t\t\t\t\t\t\t\tsum[x + dx][y + 1] += sum[x][y];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else if(course[x][y] == 2){\n\t\t\t\t\tif(is_inside(x, y + 2, X, Y)){\n\t\t\t\t\t\tsum[x][y + 2] += sum[x][y];\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tsum[x][y] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\t\n\t\tfor(int i = 0; i < X; i++){\n\t\t\tif(course[i][Y - 1] == 0){\n\t\t\t\tans += sum[i][Y - 1];\n\t\t\t}\n\t\t\tif(Y >= 2 && course[i][Y - 2] == 2){\n\t\t\t\tans += sum[i][Y - 2];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int MAX = 1000001;\n\nint main() {\n    int X, Y;\n    while(cin >> X >> Y, X) {\n        vector<vector<int>> c(Y+1, vector<int>(X));\n        for(int i=0; i<Y; ++i) {\n            for(int j=0; j<X; ++j) {\n                cin >> c[i][j];\n            }\n        }\n        vector<vector<int>> dp(Y+1, vector<int>(X));\n        for(int i=0; i<X; ++i) {\n            dp[0][i] = c[0][i] == 0;\n        }\n        for(int i=0; i<Y-1; ++i) {\n            for(int j=0; j<X; ++j) {\n                if(c[i][j] == 1) {\n                    continue;\n                } else if(c[i][j] == 2) {\n                    dp[i+2][j] += dp[i][j];\n                } else {\n                    int dx[3] = {-1, 0, 1};\n                    for(int k=0; k<3; ++k) {\n                        int nx = j + dx[k];\n                        if(nx < 0 || X <= nx || dx[k] != 0 && c[i+1][nx] == 2) {\n                            continue;\n                        }\n                        dp[i+1][nx] += dp[i][j];\n                    }\n                }\n            }\n        }\n        int res = 0;\n        for(int i=0; i<2; ++i) {\n            for(int j=0; j<X; ++j) {\n                if(c[Y-1+i][j] != 1) {\n                    res += dp[Y-1+i][j];\n                }\n            }\n        }\n        cout << res << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\nusing namespace std;\nint course[16][17][2];\nint main()\n{\n  for(;;){\n    int H,W;\n    cin >> W >> H;\n    if(H==0||W==0) break;\n    memset(course,0,sizeof(course));\n    for(int h=1; h<=H; h++){\n      for(int w=1; w<=W; w++){\n        cin >> course[h][w][0];\n      }\n    }\n    for(int w=1; w<=W; w++){\n      if(course[1][w][0] == 1) course[1][w][1] = 0;\n      else course[1][w][1] = 1;\n    }\n    for(int h=2; h<=H; h++){\n      for(int w=1; w<=W; w++){\n        if(course[h][w][0] == 1){\n          course[h][w][1] = 0;\n        }else if(course[h][w][0] == 2){\n          if(course[h-1][w][0] != 2){\n            course[h][w][1] = course[h-1][w][1];\n          }\n          if(course[h-2][w][0] == 2){\n            course[h][w][1] += course[h-2][w][1];\n          }\n        }else {\n          for(int i=-1; i<=1; i++){\n            if(course[h-1][w+i][0] != 2){\n              course[h][w][1] += course[h-1][w+i][1];\n            }\n          }\n          if(course[h-2][w][0] == 2){\n            course[h][w][1] += course[h-2][w][1];\n          }\n        }\n      }\n    }\n    long long sum = 0;\n    for(int w=1; w<=W; w++){\n      sum += course[H][w][1];\n      if(course[H-1][w][0] == 2){\n        sum += course[H-1][w][1];\n      }\n    }\n    cout << sum << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 10000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,string> P;\n\nstatic const double eps = 1e-8;\n\nconst int moveTo[][2] = {{-1,1},{0,1},{1,1}};\n\nint stage[17][17];\nint sum=0;\n\nvoid dfs(int sx,int sy,int w,int h){\n\t//space:0 tree:1 jump:2\n\n\tint now = stage[sy][sx];\n\tif(now == 1) return;\n\n\tif(sy>=h-1){\n\t\tsum++;\n\t\treturn;\n\t}\n\n\tif(now == -1) return;\n\n\tif(now == 2){\n\t\tint dx = sx;\n\t\tint dy = sy + 2;\n\t\tif(!(dx < 0 || dx >= w || dy < 0)){\n\t\t\tif(!(stage[dy][dx] == 1)){\n\t\t\t\tdfs(dx,dy,w,h);\n\t\t\t}\n\t\t}\n\n\t}\n\n\telse{\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint dx = sx + moveTo[i][0];\n\t\t\tint dy = sy + moveTo[i][1];\n\t\t\tif(dx < 0 || dx >= w || dy < 0) continue;\n\t\t\tif(stage[dy][dx] == 2 && dx != sx) continue;\n\t\t\tif(stage[dy][dx] == 1) continue;\n\n\t\t\tdfs(dx,dy,w,h);\n\t\t}\n\t}\n}\n\nint main(){\n\tint w,h;\n\twhile(~scanf(\"%d %d\",&w,&h)){\n\t\tif(w==h && h==0) break;\n\t\tmemset(stage,-1,sizeof(stage));\n\t\tfor(int y=0;y<h;y++){\n\t\t\tfor(int x=0;x<w;x++){\n\t\t\t\tscanf(\"%d\",&stage[y][x]);\n\t\t\t}\n\t\t}\n\n\t\tint res = 0;\n\t\tfor(int sx=0;sx<w;sx++){\n\t\t\tdfs(sx,0,w,h);\n\t\t}\n\n\t\tprintf(\"%d\\n\",sum);\n\t\tsum = 0;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(long long i=(a);i<(b);i++)\n#define REP(i,N) for(long long i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define fi first\n#define se second\n\n#define PI acos(-1.0)\n#define INF 1000000007\n#define EPS 1e-10\n#define MAX_N 20000\n#define MAX_M 16\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<double, double> PD;\ntypedef pair<string, ll> PS;\ntypedef vector<ll> V;\ntypedef pair<P, char> PC;\n\nint x, y;\nint field[16][16];\nint dp[16][16];\n\nint main(){\n\twhile (cin >> x >> y&&x + y){\n\t\tREP(i, 16){\n\t\t\tREP(j, 16){\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tfield[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tREP(i, y)REP(j, x)cin >> field[i][j];\n\t\tREP(j, x){\n\t\t\tif (field[0][j] == 0)dp[0][j] = 1;\n\t\t}\n\t\tREP(i, y-1){\n\t\t\tREP(j, x){\n\t\t\t\tif (field[i][j] == 0){\n\t\t\t\t\tif (field[i + 1][j] != 1)dp[i + 1][j] += dp[i][j];\n\t\t\t\t\tif (j - 1 >= 0 && field[i + 1][j - 1] == 0){\n\t\t\t\t\t\tdp[i + 1][j - 1] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tif (j + 1 < x&&field[i + 1][j + 1] == 0){\n\t\t\t\t\t\tdp[i + 1][j + 1] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (field[i][j] == 2){\n\t\t\t\t\tif (i <= y - 3 && dp[i + 2][j] != 1){\n\t\t\t\t\t\tdp[i + 2][j] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t\telse if (i == y - 2){\n\t\t\t\t\t\tdp[i + 1][j] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t\tREP(i, y + 1){\n\t\t\tREP(j, x){\n\t\t\t\tcout << dp[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tint ans = 0;\n\t\tREP(j, x)ans += dp[y-1][j];\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n#include<algorithm>\nusing namespace std;\nint dx[] = {-1,0,1},dy[] = {-1,-1,-1};\nint main(){\n\tint x,y;\n\twhile(cin >> x >> y,x,y){\n\t\tint dp[20][20] = {{0}};\n\t\tint field[20][20] = {{0}};\n\t\tfor(int i = 1; i <= y; i++){\n\t\t\tfor(int j = 1; j <= x; j++){\n\t\t\t\tcin >> field[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1; i <= y+2; i++){\n\t\t\tfor(int j = 1; j <= x; j++){\n\t\t\t\tif(i == 1 && field[i][j] == 0){\n\t\t\t\t\tdp[i][j] = 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(i <= y){\n\t\t\t\t\tfor(int k = 0; k < 3; k++){\n\t\t\t\t\t\tint px = j+dx[k],py = i+dy[k];\n\t\t\t\t\t\tif(field[i][j] == 0){\n\t\t\t\t\t\t\tif(field[py][px] == 0)dp[i][j] += dp[py][px];\n\t\t\t\t\t\t\telse if(field[py][px] == 2)continue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(field[i][j] == 2){\n\t\t\t\t\t\t\tif(k == 1)dp[i][j] += dp[py][px];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(field[i][j] == 1)continue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(i > 3){\n\t\t\t\t\tint px = j,py = i - 2;\n\t\t\t\t\tif(field[py][px] == 2){\n\t\t\t\t\t\tdp[i][j] += dp[py][px];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint sum = 0;\n\t\tfor(int i = 1; i <= x; i++){\n\t\t\tsum += dp[y][i];\n\t\t\tsum += dp[y+1][i];\n\t\t\tsum += dp[y+2][i];\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nclass point {\npublic:\n\tlong long num;\n\tint block;\n\tpoint() :num(0), block(1) {}\n};\nint main() {\n\tint X, Y;\n\twhile (cin >> X >> Y&&X != 0) {\n\t\tvector<vector<point> > map(X + 2, vector<point>(Y + 2));\n\t\tfor (int y = 1; y <= Y; ++y) {\n\t\t\tfor (int x = 1; x <= X; ++x) {\n\t\t\t\tcin >> map[x][y].block;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= X; ++i) {\n\t\t\tmap[i][1].num = 1;\n\t\t}\n\t\tfor (int y = 1; y < Y; ++y) {\n\t\t\tfor (int x = 1; x <= X; ++x) {\n\t\t\t\tif (map[x][y].block == 0) {\n\t\t\t\t\tfor (int k = -1; k <= 1; ++k) {\n\t\t\t\t\t\tif (map[x + k][y + 1].block == 0 || (map[x + k][y + 1].block == 2 && k == 0) ) {\n\t\t\t\t\t\t\tmap[x + k][y + 1].num += map[x][y].num;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (map[x][y].block == 2) {\n\t\t\t\t\tif (y + 2 > Y)map[x][Y].num += map[x][y].num;\n\t\t\t\t\telse if (map[x][y + 2].block != 1) {\n\t\t\t\t\t\tmap[x][y + 2].num += map[x][y].num;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong long ans = 0;\n\t\tfor (int i = 1; i <= X; ++i) {\n\t\t\tans += map[i][Y].num;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main()\n{\n\tint n, m;\n\twhile (true){\n\t\tcin >> n >> m;\n\t\tif (n == 0 && m == 0){\n\t\t\tbreak;\n\t\t}\n\t\tint map[100][100] = { 0 };\n\t\tint dp[100][100] = { 0 };\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int i2 = 0; i2 < m; i2++){\n\t\t\t\tcin >> map[i][i2];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tif (map[0][i] == 0){\n\t\t\t\tdp[0][i] = 1;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tfor (int i2 = 0; i2 < n; i2++){\n\t\t\t\tif (map[i][i2] == 0){\n\t\t\t\t\tfor (int i3 = -1; i3 <= 1; i3++){\n\t\t\t\t\t\tif (i2 + i3 >= 0 && i2 + i3 < n && (map[i + 1][i2 + i3] == 0 || i3 == 0 && map[i + 1][i2 + i3] == 2)&&(i<m-1||i3==0)){\n\t\t\t\t\t\t\tdp[i + 1][i2+i3]  += dp[i][i2];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t\telse if (map[i][i2] == 2){\n\t\t\t\t\t\t\tdp[i + 2][i2] += dp[i][i2];\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tans += dp[m][i];\n\t\t\tans += dp[m+1][i];\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 0203\n#include<iostream>\n#include<cstring>\n\nint X, Y;\nint field[17][15];\nint dp[15][15];\n\nint main()\n{\n\twhile( std::cin >> X >> Y, X | Y )\n\t{\n\t\tmemset( field, 0, sizeof( field ) );\n\t\tmemset( dp, 0, sizeof( dp ) );\n\n\t\tfor( int i = 0; i != Y; ++i )\n\t\t\tfor( int j = 0; j != X; ++j )\n\t\t\t\tstd::cin >> field[i][j];\n\n\t\tfor( int i = 0; i != X; ++i )\n\t\t\tdp[0][i] = field[0][i] != 1;\n\t\t\n\t\tint ans = 0;\n\t\tfor( int i = 1; i <= Y + 1; ++i )\n\t\t{\n\t\t\tfor( int j = 0; j != X; ++j )\n\t\t\t{\n\t\t\t\tif( i < Y && field[i][j] != 1 )\n\t\t\t\t{\n\t\t\t\t\tfor( int k = -1; k <= 1; ++k )\n\t\t\t\t\t{\n\t\t\t\t\t\tif( field[i][j] == 2 && k != 0 )\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif( j + k >= 0 && j + k < X && !field[i-1][j+k] )\n\t\t\t\t\t\t\tdp[i][j] += dp[i-1][j+k];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif( i - 2 > 0 && field[i-2][j] == 2 )\n\t\t\t\t\tdp[i][j] += dp[i-2][j];\n\t\t\t\n\t\t\t\tif( i >= Y - 1 )\n\t\t\t\t\tans += dp[i][j];\n\t\t\t}\n\t\t}\n\n\t\tstd::cout << ans << std::endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reg(i,a,b) for(int i=(a);i<=(b);i++)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n\nint dat[30][30];\nint dp[30][30];\nint main(void){\n\tint x,y;\n\tfor(;;){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif(x==0)break;\n\t\trep(j,y)rep(i,x){\n\t\t\tscanf(\"%d\",&dat[i][j]);\n\t\t}\n\t\tmemset(dp,0,sizeof(dp));\n\t\tmemset(dat,0,sizeof(dat));\n\t\trep(i,x)if(dat[i][0]==0)dp[i][0]=1;\n\t\trep(j,y)rep(i,x){\n\t\t\tif(dat[i][j]==1)continue;\n\t\t\tif(dat[i][j]==2){\n\t\t\t\tif(dat[i][j+2]!=1)dp[i][j+2]+=dp[i][j];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(j!=y-1){\n\t\t\t\tif(i>0 && dat[i-1][j+1]==0){\n\t\t\t\t\tdp[i-1][j+1]+=dp[i][j];\n\t\t\t\t}\n\t\t\t\tif(i<x-1 && dat[i+1][j+1]==0){\n\t\t\t\t\tdp[i+1][j+1]+=dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dat[i][j+1]!=1)dp[i][j+1]+=dp[i][j];\n\t\t}\n\t\tlli ans=0;\n\t\t/*\n\t\tprintf(\"\\n\");\n\t\trep(j,y){\n\t\t\trep(i,x){\n\t\t\t\t//printf(\"(%2d %2d)\",dat[i][j],dp[i][j]);\n\t\t\t\tprintf(\"%2d\",dp[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\treg(j,y,y+1){\n\t\t\t//printf(\"\\n\");\n\t\t\trep(i,x){\n\t\t\t\t//printf(\"%2d \",dp[i][j]);\n\t\t\t\tans+=dp[i][j];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n#define int long long\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\nint vv[20][20];\nint table[20][20];\n/*\n1 1 1 1 1 \n1 1 1 1 1 \n1 1 3 1 1 \n0 3 3 0 1 \n4 3 3 1 0 \n4 0 0 0 0 \n*/\n/*\n5 5\n0 0 0 0 1\n2 1 0 2 0\n1 0 0 1 1\n0 2 1 2 0\n0 1 0 0 0\n*/\nvoid mainmain(){\n\tint w,h;\n\twhile(cin>>w>>h,w||h){\n\t\trep(i,20){\n\t\t\trep(j,20){\n\t\t\t\tvv[i][j]=0;\n\t\t\t}\n\t\t}\n\t\trep(i,20){\n\t\t\trep(j,20){\n\t\t\t\ttable[i][j]=0;\n\t\t\t}\n\t\t}\n\t\treep(i,1,w+1){\n\t\t\tvv[0][i]=1;\n\t\t}\n\t\trep(i,h){\n\t\t\trep(j,w){\n\t\t\t\tcin>>table[i+1][j+1];\n\t\t\t}\n\t\t}\n\t\trep(i,h){\n\t\t\treep(j,1,w+1){\n\t\t\t\tif(table[i][j]==2){\n\t\t\t\t\tvv[i+2][j]+=vv[i][j];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(table[i][j]==1) continue;\n\t\t\t\tvv[i+1][j]+=vv[i][j];\n\t\t\t\tif(i&&j-1>0&&table[i+1][j-1]==0){\n\t\t\t\t\tvv[i+1][j-1]+=vv[i][j];\n\t\t\t\t}\n\t\t\t\tif(i&&j+1<=w&&table[i+1][j+1]==0){\n\t\t\t\t\tvv[i+1][j+1]+=vv[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t\treep(i,h,h+2){\n\t\t\treep(j,1,w+1){\n\t\t\t\tans+=vv[i][j];\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint X, Y;\nint MapData[15][15];\nint DpCount[16][15];\n\nvoid solve() {\n\tint col, sum;\n\tint dx[] = { -1,0,1 };\n\n\tmemset(DpCount, 0, sizeof(DpCount));\n\tfor (int j = 0; j < X; ++j) {\n\t\tif (MapData[Y - 1][j] == 1) {\n\t\t\tcontinue;\n\t\t}\n\t\tDpCount[Y - 1][j] = 1;\n\t}\n\n\tfor (int i = Y - 2; i >= 0; --i) {\n\t\tfor (int j = 0; j < X; ++j) {\n\t\t\tif (MapData[i][j] == 1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (MapData[i][j] == 2) {\n\t\t\t\tif (i == Y - 2) {\n\t\t\t\t\tDpCount[i][j] = 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tDpCount[i][j] = DpCount[i + 2][j];\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tsum = 0;\n\t\t\tfor (int k = 0; k < 3; ++k) {\n\t\t\t\tcol = j + dx[k];\n\t\t\t\tif (col < 0 || col > X - 1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (k != 1 && MapData[i + 1][col] == 2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tsum += DpCount[i + 1][col];\n\t\t\t}\n\t\t\tDpCount[i][j] = sum;\n\t\t}\n\t}\n\n\tsum = 0;\n\tfor (int j = 0; j < X; ++j) {\n\t\tsum += DpCount[0][j];\n\t}\n\tcout << sum << endl;\n}\n\nint main() {\n\n\twhile (cin >> X >> Y, X) {\n\t\tfor (int i = 0; i < Y; ++i) {\n\t\t\tfor (int j = 0; j < X; ++j) {\n\t\t\t\tcin >> MapData[i][j];\n\t\t\t}\n\t\t}\n\t\tsolve();\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define N 15\nusing namespace std;\nint data[N][N];\nvoid func(int,int);\nint Cnt(int,int);\nint X,Y,cnt,memo[N][N];\nint main(){\n  while(1){\n    cin >> X >> Y;\n    if(X==0&&Y==0) break;\n    for(int i=0;i<Y;i++)\n      for(int j=0;j<X;j++)\n\tcin >> data[i][j];\n    cnt=0;\n    for(int i=0;i<Y;i++)\n      for(int j=0;j<X;j++)\n\tmemo[i][j]=-1;\n    for(int i=0;i<X;i++){\n      if(data[0][i]==0) func(0,i);\n    }\n    cout << cnt << endl;\n  }\n  return 0;\n}\nvoid func(int y,int x){\n  if(y>=Y-1){\n    cnt++;\n    memo[Y-1][x]=1;\n    return;\n  }else memo[Y-1][x]=0;\n  if(y+1<Y&&x+1<X&&data[y+1][x+1]==0) func(y+1,x+1);\n  if(y+1<Y&&x-1>=0&&data[y+1][x-1]==0) func(y+1,x-1);\n  if(y+1<Y&&data[y+1][x]==2){\n    int r=Cnt(y,x);\n    if(r!=-1){\n      if(memo[y+1][x]!=-1) memo[y][x]+=memo[y+1][x];\n      func(r,x);\n      if(memo[y+1][x]!=-1) memo[y][x]+=memo[y+1][x];\n    }\n    else return ;\n  }\n  if(y+1<Y&&data[y+1][x]==0) func(y+1,x);\n\n}\nint Cnt(int y,int x){\n  y+=3;\n  while(1){\n    if(y>=Y-1){\n      if(y>Y-1) cnt++;\n      else if(y==Y-1&&data[y][x]!=1) cnt++;\n      break;\n    }\n    if(data[y][x]==1) break;\n    if(data[y][x]==2) y+=2;\n    if(data[y][x]==0) return y;\n  }\n  return -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<queue>\n#include<functional>\n#include<cstring>\n#include<vector>\n#include<climits>\n#include<map>\nusing namespace std;\n#define FOR(i,n) for(int i=0;i<(int)n;i++)\n#define FORI(i,k,n) for(int i=k;i<(int)n;i++)\n#define ALL(x) (x).begin(),(x).end()\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define int long long\n\nmain()\n{\n\twhile(1)\n\t{\n\t\tint a[20][20];\n\t\tint dp[20][20]={};\n\t\tint x,y;\n\t\t\n\t\tcin>>x>>y;if(!x)break;\n\t\tFOR(i,20)FOR(j,20)a[i][j]=1;\n\t\tFORI(i,1,y+1)\n\t\t{\n\t\t\tFORI(j,1,x+1)\n\t\t\t{\n\t\t\t\tcin>>a[i][j];\n\t\t\t}\n\t\t}\n\t\tFORI(i,1,x+1)\n\t\t{\n\t\t\tdp[1][i]=1;\n\t\t\ta[y+1][i]=0;\n\t\t}\n\t\tFORI(i,1,y)\n\t\t{\n\t\t\tFORI(j,1,x+1)\n\t\t\t{\n\t\t\t\tif(a[i][j]==2&&a[i+2][j]!=1)\n\t\t\t\t{\n\t\t\t\t\tdp[i+2][j]+=dp[i][j];\n\t\t\t\t}\n\t\t\t\telse if(a[i][j]==1)\n\t\t\t\t{\n\t\t\t\t\tdp[i][j]=0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfor(int k=-1;k<=1;k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(a[i+1][j+k]==0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdp[i+1][j+k]+=dp[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(a[i+1][j]==2)dp[i+1][j]+=dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans=0;\n\t\tFORI(i,1,x+1)ans+=dp[y][i]+dp[y+1][i];\n\t\tcout<<ans<<endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 25\n\nint main()\n{\n    int H, W;\n    while (cin >> W >> H, W) {\n        vector<vector<int>> a(H, vector<int>(W));\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                cin >> a[i][j];\n            }\n        }\n        int dp[MAX][MAX] = {{}};\n        for (int i = 0; i < W; i++) {\n            dp[0][i] = (a[0][i] == 0);\n        }\n\n        for (int i = 0; i < H - 1; i++) {\n            for (int j = 0; j < W; j++) {\n                if (dp[i][j] <= 0 || a[i][j] == 1) continue;\n                if (a[i][j] == 2) {\n                    int ni = min(i + 2, H - 1);\n                    if (i + 2 < H && a[i+2][j] == 1) continue;\n                    dp[ni][j] += dp[i][j];\n                } else {\n                    for (int k = -1; k <= 1; k++) {\n                        int ni = i + 1;\n                        int nj = j + k;\n                        if (nj < 0 || nj >= W) continue;\n                        if (a[ni][nj] == 1) continue;\n                        if (a[ni][nj] == 2 && j != nj) continue;\n                        dp[ni][nj] += dp[i][j];\n                    }\n                }\n            }\n        }\n        int res = 0;\n        for (int i = 0; i < W; i++) {\n            res += dp[H-1][i];\n        }\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<string>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<cctype>\nusing namespace std;\n#define rep(i, j) for(int i = 0; i < j; i++)\n#define f(i, k, j) for(int i = k; i < j; i++)\n#define P pair<int, int>\nconst int INF = (1 << 26);\nconst int MAX_XY = 16;\n\nvoid solve();\n\nint x, y, f[MAX_XY][MAX_XY], dp[MAX_XY][MAX_XY];\n\nint main(){\n    cin >>x >>y;\n    rep(i, MAX_XY) rep(j, MAX_XY) f[i][j] = 1;\n    rep(i, y) rep(j, x) cin >>f[i][j];\n    memset(dp, 0, sizeof(dp));\n\n    solve();\n\n    int ans = 0;\n    rep(i, x) ans += dp[y][i];\n    cout <<ans <<endl;\n    return 0;\n}\n\nvoid solve(){\n    rep(i, x){\n        if(f[0][i] == 0) dp[0][i] = 1;\n    }\n\n    rep(i, y - 1){\n        rep(j, x){\n            if(f[i + 1][j] == 1){\n                dp[i + 1][j] = 0;\n                continue;\n            } else if(f[i + 1][j] == 0){\n                f(k, -1, 2){\n                    if(j + k < x && j + k >= 0) dp[i + 1][j] += dp[i][j + k];\n                }\n            } else{\n                dp[i + 1][j] += dp[i][j];\n                if(i + 3 >= y) dp[y][j] += dp[i + 1][j];\n                else dp[i + 3][j] += dp[i + 1][j];\n                dp[i + 1][j] = 0;\n            }\n        }\n    }\n    rep(i, x) dp[y][i] += dp[y - 1][i];\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nint grid[30][30];\n\ninline bool isAtObstacle(int x, int y) {\n  return grid[y][x] == 1;\n}\n\ninline bool isAtSkiJump(int x, int y) {\n  return grid[y][x] == 2;\n}\n\nint main() {\n  int n, m;\n  \n  while(cin >> n >> m && n) {\n    fill(grid[0], grid[0]+900, 0);\n    for(int i=0; i<n; i++) {\n      for(int j=0; j<m; j++) {\n\tcin >> grid[i][j];\n      }\n    }\n    \n    int dp[30][30][2] = {{{}}};\n    \n    for(int j=0; j<m; j++) {\n      if(grid[0][j]==0) { dp[0][j][0] = 1; }\n    }\n    \n    int extra = 0;\n    for(int i=0; i<n-1; i++) {\n      for(int j=0; j<m; j++) {\n\t\n\t// there is no case such that skier is at obstacle.\n\tif(isAtObstacle(j, i)) {\n\t  dp[i][j][0] = dp[i][j][1] = 0;\n\t  continue;\n\t}\n\t\n\t// A skier is at a ski jump.\n\tif(isAtSkiJump(j, i)) {\n\t  if(i+2 > n-1) extra += dp[i][j][0];\n\t  else {\n\t    if(isAtObstacle(j, i+2)) continue;\n\t    dp[i+2][j][0] += dp[i][j][0];\n\t  }\n\t}\n\t\n\t// skiing without jump.\n\telse {\n\t  // from the upper left\n\t  if( j-1 >= 0\n\t      && !isAtObstacle(j-1, i+1)\n\t      && !isAtSkiJump (j-1, i+1) ) {\n\t    dp[i+1][j-1][1] += dp[i][j][0] + dp[i][j][1];\n\t  }\n\t  \n\t  // from the above\n\t  if( !isAtObstacle(j, i+1) ) {\n\t    dp[i+1][j][0] += dp[i][j][0] + dp[i][j][1];\n\t  }\n\t  \n\t  // from the upper right\n\t  if( j+1 < m\n\t      && !isAtObstacle(j+1, i+1)\n\t      && !isAtSkiJump (j+1, i+1) ) {\n\t    dp[i+1][j+1][1] += dp[i][j][0] + dp[i][j][1];\n\t  }\n\t}\n\t\n      }\n    }\n    \n    for(int i=0; i<m; i++) {\n      if(isAtObstacle(i, n-1)) {\n\tdp[n-1][i][0] = dp[n-1][i][1] = 0;\n      }\n    }\n    \n    int ans = 0;\n    for(int i=0; i<m; i++) {\n      ans += dp[n-1][i][0] + dp[n-1][i][1];\n    }\n    \n    cout << ans + extra << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint DP[17][17];\nint field[17][17];\nint x,y;\n\nint main(){\n\twhile(true){\n\t\tcin >> x >> y;\n\t\tif(!x && !y)\n\t\t\treturn 0;\n\t\t\n\t\tfor(int i=1; i<=y; i++)\n\t\t\tfor(int k=1; k<=x; k++)\n\t\t\t\tcin >> field[i][k];\n\t\tfor(int i=1; i<=x; i++)\n\t\t\tfield[y+1][i] = 0;\n\t\t\n\t\tfor(int i=1; i<=y+1; i++)\n\t\t\tfor(int k=0; k<=x+1; k++){\n\t\t\t\tDP[i][k]=0;\n\t\t\t\tif(i==1 && k>0 && k<=x)\n\t\t\t\t\tif(field[i][k] == 0)\n\t\t\t\t\t\tDP[i][k] = 1;\n\t\t\t}\n\t\t\n\t\tfor(int i=2; i<=y; i++){\n\t\t\tfor(int k=1; k<=x; k++){\n\t\t\t\tif(field[i][k] == 0)\n\t\t\t\t\tDP[i][k] += DP[i-1][k-1] + DP[i-1][k] + DP[i-1][k+1];\n\t\t\t\telse if(field[i][k] == 2)\n\t\t\t\t\tint n = i+2;\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\tif(field[n][k] == 0){\n\t\t\t\t\t\t\tDP[n][k] += DP[i-1][k];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else if(field[n][k] == 1)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tn+=2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans=0;\n\t\tfor(int i=y; i<=y+1; i++)\n\t\t\tfor(int k=1; k<=x; k++)\n\t\t\t\tans += DP[i][k];\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n\nint X, Y;\nint field[15][15];\nint dp[16][15];\n\nint main()\n{\n\twhile( std::cin >> X >> Y, X | Y )\n\t{\n\t\tmemset( field, 0, sizeof( field ) );\n\t\tmemset( dp, 0, sizeof( dp ) );\n\n\t\tfor( int i = 0; i != Y; ++i )\n\t\t\tfor( int j = 0; j != X; ++j )\n\t\t\t\tstd::cin >> field[i][j];\n\n\t\tfor( int i = 0; i != X; ++i )\n\t\t\tdp[0][i] = field[0][i] != 1;\n\t\t\n\t\tint ans = 0;\n\t\tfor( int i = 1; i <= Y; ++i )\n\t\t{\n\t\t\tfor( int j = 0; j != X; ++j )\n\t\t\t{\n\t\t\t\tif( i < Y && field[i][j] != 1 )\n\t\t\t\t{\n\t\t\t\t\tfor( int k = -1; k <= 1; ++k )\n\t\t\t\t\t{\n\t\t\t\t\t\tif( field[i][j] == 2 && k != 0 )\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif( j + k >= 0 && j + k < X && !field[i-1][j+k] )\n\t\t\t\t\t\t\tdp[i][j] += dp[i-1][j+k];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif( i - 2 > 0 && field[i-2][j] == 2 )\n\t\t\t\t\tdp[i][j] += dp[i-2][j];\n\t\t\t\n\t\t\t\tif( i >= Y - 1 )\n\t\t\t\t\tans += dp[i][j];\n\t\t\t}\n\t\t}\n\n\t\tstd::cout << ans << std::endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//配るDP\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint X,Y;\nint c[15][15];\nint dp[15][15];\nint main(){\n\twhile(cin>>X>>Y,X|Y){\n\t\tint ans=0;\n\t\tfor(int i=0;i<Y;i++)\n\t\t\tfor(int j=0;j<X;j++)\n\t\t\t\tcin>>c[i][j];\n\t\tfill_n((int*)dp,15*15,0);\n\t\tfor(int j=0;j<X;j++){\n\t\t\tif(c[0][j]!=1)dp[0][j]=1;\n\t\t}\n\t\tfor(int i=0;i<Y;i++){\n\t\t\tfor(int j=0;j<X;j++){\n\t\t\t\tif(dp[i][j]==0)continue;\n\t\t\t\tif(Y-1==i || c[i][j]==2 && Y-2==i){\n\t\t\t\t\tans += dp[i][j];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int dx=-1;dx<=1;dx++){\n\t\t\t\t\tif(j+dx<0 || X<=j+dx)continue;\n\t\t\t\t\tif(c[i][j]==2){\n\t\t\t\t\t\tif(dx==0 && c[i+2][j]!=1){\n\t\t\t\t\t\t\tdp[i+2][j] += dp[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(c[i+1][j+dx]==0)dp[i+1][j+dx] += dp[i][j];\n\t\t\t\t\t\telse if(c[i+1][j+dx]==2 && dx==0)dp[i+1][j] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define ck(a,b) (0<=a&&a<b)\nusing namespace std;\nint main(){\n\tint X,Y,c[15][15],land[15][15],ans;\n\twhile(cin>>X>>Y,X){\n\t\trep(i,Y)rep(j,X)cin>>land[i][j],c[i][j]=i==0&&land[i][j]!=1;\n\t\trep(i,Y-1)rep(j,X)if(land[i+1][j]!=1){\n\t\t\tif(land[i+1][j]==2)c[i+1][j]+=land[i][j]==0?c[i][j]:0;\n\t\t\telse rep(d,3)if(ck(j+d-1,X)&&land[i][j+d-1]==0)\n\t\t\tc[i+1][j]+=c[i][j+d-1];\n\t\t\tif(i>0&&land[i-1][j]==2)c[i+1][j]+=c[i-1][j];\n\t\t}\n\t\tans=0;\n\t\trep(i,X)ans+=c[Y-1][i]+(Y>1&&land[Y-2][i]==2?c[Y-2][i]:0);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nint grid[20][20];\n\ninline bool isAtObstacle(int x, int y) {\n  return grid[y][x] == 1;\n}\n\ninline bool isAtSkiJump(int x, int y) {\n  return grid[y][x] == 2;\n}\n\nint main() {\n  int n, m;\n  \n  while(cin >> n >> m && n) {\n    fill(grid[0], grid[0]+400, 0);\n    for(int i=0; i<n; i++) {\n      for(int j=0; j<m; j++) {\n\tcin >> grid[i][j];\n      }\n    }\n    \n    long long dp[20][20][2] = {};\n    \n    for(int j=0; j<m; j++) {\n      if(grid[0][j]==0) { dp[0][j][0] = 1; }\n    }\n    \n    for(int i=0; i<n-1; i++) {\n      for(int j=0; j<m; j++) {\n\t\n\t// there is no case such that skier is at obstacle.\n\tif(isAtObstacle(j, i)) continue;\n\t\n\t// A skier is at a ski jump.\n\tif(isAtSkiJump(j, i)) {\n\t  if(i+2>n-1) dp[n-1][j][0] += dp[i][j][0];\n\t  else {\n\t    if(!isAtObstacle(j, i+2)) {\n\t      dp[i+2][j][0] += dp[i][j][0];\n\t    }\n\t  }\n\t}\n\t\n\t// skiing without jump.\n\telse {\n\t  // from the upper left\n\t  if( j-1 >= 0\n\t      && !isAtObstacle(j-1, i+1)\n\t      && !isAtSkiJump (j-1, i+1) ) {\n\t    dp[i+1][j-1][1] += dp[i][j][0] + dp[i][j][1];\n\t  }\n\t  \n\t  // from the above\n\t  if( !isAtObstacle(j, i+1) ) {\n\t    dp[i+1][j][0] += dp[i][j][0] + dp[i][j][1];\n\t  }\n\t  \n\t  // from the upper right\n\t  if( j+1 < m\n\t      && !isAtObstacle(j+1, i+1)\n\t      && !isAtSkiJump (j+1, i+1) ) {\n\t    dp[i+1][j+1][1] += dp[i][j][0] + dp[i][j][1];\n\t  }\n\t}\n\t\n      }\n    }\n    \n    int ans = 0;\n    for(int i=0; i<m; i++) {\n      ans += dp[n-1][i][0] + dp[n-1][i][1];\n    }\n    \n    cout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 16\n\nint main()\n{\n    int H, W;\n    while (cin >> W >> H, W) {\n        vector<vector<int>> a(H, vector<int>(W));\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                cin >> a[i][j];\n            }\n        }\n        int dp[MAX][MAX] = {{}};\n        for (int i = 0; i < W; i++) {\n            dp[0][i] = (a[0][i] == 0);\n        }\n\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (dp[i][j] == 0 || a[i][j] == 1) continue;\n                if (a[i][j] == 2) {\n                    int ni = min(i + 2, H - 1);\n                    if (i + 2 < H && a[i+2][j] == 1) continue;\n                    dp[ni][j] += dp[i][j];\n                } else {\n                    if (i + 1 == H) continue;\n                    for (int k = -1; k <= 1; k++) {\n                        int ni = i + 1;\n                        int nj = j + k;\n                        if (nj < 0 || nj >= W) continue;\n                        if (a[ni][nj] == 1) continue;\n                        if (a[ni][nj] == 2 && j != nj) continue;\n                        dp[ni][nj] += dp[i][j];\n                    }\n                }\n            }\n        }\n        int res = 0;\n        for (int i = 0; i < W; i++) {\n            res += dp[H-1][i];\n        }\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint maps[20][20];\nint course[20][20];\nint X, Y;\n\nint way(int y, int x){\n  if(y >= Y) return 1;\n  else if(course[y][x] > 0) return course[y][x];\n  else if(maps[y][x] == 1) return 0;\n  else if(maps[y][x] == 2) return course[y][x] = way(y + 2, x);\n  else{\n    int SUM = 0;\n    for(int i = 0; i < 3; i++){\n      int ny = y + 1;\n      int nx = x - 1 + i;\n      if(maps[ny][nx] != 1 && 1 <= nx && nx <= X){\n\tint flug = 1;\n\tif(i != 1 && maps[ny][nx] == 2) flug = 0;\n\tif(flug) SUM += way(ny, nx);\n      }\n    }\n    return course[y][x] = SUM;\n  }\n} \n\nint main(){\n  while(1){\n    cin >> X >> Y;\n    if(X == 0 && Y == 0) break;\n    for(int i = 1; i <= Y; i++){\n      for(int j = 1; j <= X; j++){\n\tcin >> maps[i][j];\n\tcourse[i][j] = 0;\n      }\n    }\n    int cnt = 0;\n    for(int i = 1; i <= X; i++){\n      if(maps[0][i] != 1) cnt += way(1, i);\n    }\n    cout << cnt << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main()\n{\n\tint n, m;\n\twhile (true){\n\t\tcin >> n >> m;\n\t\tif (n == 0 && m == 0){\n\t\t\tbreak;\n\t\t}\n\t\tint map[100][100] = { 0 };\n\t\tint dp[100][100] = { 0 };\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int i2 = 0; i2 < m; i2++){\n\t\t\t\tcin >> map[i][i2];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tif (map[0][i] == 0){\n\t\t\t\tdp[0][i] = 1;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < m-1; i++){\n\t\t\tfor (int i2 = 0; i2 < n; i2++){\n\t\t\t\tif (map[i][i2] == 0){\n\t\t\t\t\tif (map[i + 1][i2] == 0 || map[i + 1][i2] == 2){\n\t\t\t\t\t\tdp[i + 1][i2] += dp[i][i2];\n\t\t\t\t\t}\n\t\t\t\t\tif (i2+1<m&&map[i + 1][i2 + 1] == 0){\n\t\t\t\t\t\tdp[i + 1][i2 + 1] += dp[i][i2];\n\t\t\t\t\t}\n\t\t\t\t\tif (i2 - 1 >= 0 && map[i + 1][i2 - 1] == 0){\n\t\t\t\t\t\tdp[i + 1][i2 - 1] += dp[i][i2];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (map[i][i2] == 2){\n\t\t\t\t\tif (map[i + 2][i2] == 0 || map[i + 2][i2] == 2){\n\t\t\t\t\t\tdp[i + 2][i2] += dp[i][i2];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tif (map[m - 1][i]==2){\n\t\t\t\tdp[m + 1][i] += dp[m - 1][i];\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tans += dp[m - 1][i];\n\t\t\tans += dp[m][i];\n\t\t\tans += dp[m + 1][i];\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<string>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<cctype>\nusing namespace std;\n#define rep(i, j) for(int i = 0; i < j; i++)\n#define f(i, k, j) for(int i = k; i < j; i++)\n#define P pair<int, int>\nconst int INF = (1 << 26);\nconst int MAX_XY = 15;\n\nvoid solve();\n\nint x, y, f[MAX_XY + 1][MAX_XY], dp[MAX_XY + 1][MAX_XY];\n\nint main(){\n    while(cin >>x >>y && x && y){\n        rep(i, MAX_XY + 1) rep(j, MAX_XY) f[i][j] = 1;\n        rep(i, y) rep(j, x) cin >>f[i][j];\n        memset(dp, 0, sizeof(dp));\n\n        solve();\n\n        int ans = 0;\n        rep(i, x) ans += dp[y][i];\n        cout <<ans <<endl;\n    }\n    return 0;\n}\n\nvoid solve(){\n    rep(i, x) if(f[0][i] == 0) dp[0][i] = 1;\n\n    rep(i, y - 1){\n        rep(j, x){\n            if(f[i + 1][j] == 1){\n                dp[i + 1][j] = 0;\n                continue;\n            } else if(f[i + 1][j] == 0){\n                f(k, -1, 2){\n                    if(j + k < x && j + k >= 0) dp[i + 1][j] += dp[i][j + k];\n                }\n            } else{\n                dp[i + 1][j] += dp[i][j];\n                if(i + 3 >= y) dp[y][j] += dp[i + 1][j];\n                else dp[i + 3][j] += dp[i + 1][j];\n                dp[i + 1][j] = 0;\n            }\n        }\n    }\n    rep(i, x) dp[y][i] += dp[y - 1][i];\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n#include<map>\n#include<queue>\n#include<set>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define reps(i,n) for(int i=1;i<=n;i++)\n\nint main(){\n\twhile(1){\n\t\tint w,h;\n\t\tcin>>w>>h;\n\t\tif(w==0)break;\n\t\t\n\t\tint dp[22][22]={0};\n\t\tint masu[22][22]={0};\n\t\t\n\t\treps(i,h){\n\t\t\treps(j,w){\n\t\t\t\tcin>>masu[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\treps(j,w){\n\t\t\tif(masu[1][j]!=0)continue;\n\t\t\tdp[1][j]=1;\n\t\t}\n\t\t\n\t\treps(i,h-1){\n\t\t\treps(j,w){\n\t\t\t\tif(masu[i][j]==0){\n\t\t\t\t\tif(masu[i+1][j]!=1) dp[i+1][j]+=dp[i][j];\n\t\t\t\t\tif(masu[i+1][j-1]==0) dp[i+1][j-1]+=dp[i][j];\n\t\t\t\t\tif(masu[i+1][j+1]==0) dp[i+1][j+1]+=dp[i][j];\n\t\t\t\t}\n\t\t\t\tif(masu[i][j]==1){\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(masu[i][j]==2){\n\t\t\t\t\tif(masu[i+2][j]!=1)dp[i+2][j]+=dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*\n\t\trep(i,h+3){\n\t\t\trep(j,w+2){\n\t\t\t\tprintf(\"%d \",dp[i][j]);\n\t\t\t}puts(\"\");\n\t\t}*/\n\t\t\n\t\tint ans=0;\n\t\trep(i,2){\n\t\t\treps(j,w){\n\t\t\t\tans += dp[h+i][j];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class t>\nusing table = vector<vector<t>>;\nconst ld eps=1e-9;\n\n//// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\"\n\nint main() {\n\twhile (1) {\n\t\tint H, W; cin >> W >> H;\n\t\tif (!H)break;\n\t\tvector<vector<int>>field(H + 3, vector<int>(W + 2,1));\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tcin >> field[i][j+1];\n\t\t\t}\n\t\t}\n\t\tfor (int i = H; i < H + 3; ++i) {\n\t\t\tfor (int j = 1; j <= W; ++j) {\n\t\t\t\tfield[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tvector<vector<long long int>>nums(H + 3, vector<long long int>(W + 2, 0));\n\t\tfor (int j = 0; j < W + 2; ++j) {\n\t\t\tif (!field[0][j])nums[0][j] = 1;\n\t\t}\n\t\tlong long int ans = 0;\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tfor (int j = 1; j < W + 1; ++j) {\n\t\t\t\tfor (int dx = -1; dx <= 1;++dx) {\n\t\t\t\t\tconst int nextx = j + dx;\n\t\t\t\t\tint nexty = i + 1;\n\t\t\t\t\t\n\t\t\t\t\tif (field[nexty][nextx] == 1) {\n\n\t\t\t\t\t}\n\t\t\t\t\telse if (field[nexty][nextx] == 2) {\n\t\t\t\t\t\tif (!dx) {\n\t\t\t\t\t\t\twhile (1) {\n\t\t\t\t\t\t\t\tnexty += 2;\n\t\t\t\t\t\t\t\tif (nexty >= H - 1 && field[nexty][nextx] != 1) {\n\t\t\t\t\t\t\t\t\tans += nums[i][j];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tif (field[nexty][nextx] == 1) {\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse if (field[nexty][nextx] == 0) {\n\n\t\t\t\t\t\t\t\t\t\tnums[nexty][nextx] += nums[i][j];\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (nexty >= H - 1)ans += nums[i][j];\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tnums[nexty][nextx] += nums[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nint a[16][16];\nlong long dp[18][16];\nint main()\n{\n    while (true) {\n        int h, w;\n        scanf(\"%d%d\", &w, &h);\n        if (!(w | h)) break;\n        for (int i = 0; i < 16; ++i) for (int j = 0; j < 16; ++j)\n            dp[i][j] = 0;\n        for (int i = 0; i < h; ++i) for (int j = 0; j < w; ++j)\n            scanf(\"%d\", &a[i][j]);\n\n        for (int j = 0; j < w; ++j)\n            if (a[0][j] == 0) dp[0][j] = 1;\n        for (int i = 1; i < h; ++i) for (int j = 0; j < w; ++j) {\n            if (a[i][j] == 1) continue;\n            if (a[i-1][j] != 2) dp[i][j] = dp[i-1][j];\n            if (a[i][j] == 0) {\n                if (j > 0 && a[i-1][j-1] == 0) dp[i][j] += dp[i-1][j-1];\n                if (j < w-1 && a[i-1][j+1] == 0) dp [i][j] += dp[i-1][j+1];\n            }\n            if (i > 1 && a[i-2][j] == 2) dp[i][j] += dp[i-2][j];\n        }\n        for (int i = h; i < h+2; ++i) for (int j = 0; j < w; ++j) {\n            dp[i][j] = dp[i-1][j];\n            if (i > 1 && a[i-2][j] == 2) dp[i][j] += dp[i-2][j];\n        }\n        int res = 0;\n        for (int j = 0; j < w; ++j) res += dp[h+1][j];\n        printf(\"%d\\n\", res);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <cstring>\n#include <fstream>\n#include <numeric>\n#include <algorithm>\n\nusing namespace std;\n\nint main(int argc, char **argv) {\n  int x, y, field[15 * 15], route[15 * 15], rsum;\n\n  while (true) {\n    cin >> x >> y;\n    if (x == 0 && y == 0)\n      break;\n    rsum = 0;\n    memset(route, 0, sizeof(int) * x * y);\n    for (int i = 0; i < y; i++)\n      for (int j = 0; j < x; j++)\n        cin >> field[i * y + j];\n    for (int i = 0; i < x; i++) {\n      int f = field[i];\n      if (!f)\n        route[i] = 1;\n    }\n\n    for (int i = 1; i < y; i++)\n      for (int j = 0; j < x; j++) {\n        int f = field[i * y + j];\n        if (f == 0) {\n          for (int k = -1; k <= 1; k++)\n            if ((j + k >= 0 && j + k < x) &&\n                ((k == 0 && field[(i-1) * y + j+k] == 2) ||\n                 (field[(i-1) * y + j+k] != 2)))\n              route[i * y + j] += route[(i-1) * y + j+k];\n        } else if (f == 1) {\n          route[i * y + j] = 0;\n        } else if (f == 2 && i + 2 < y && field[(i+2) * y + j] != 1) {\n          route[(i+2) * y + j] = route[(i-1) * y + j];\n        } else if (f == 2) {\n          rsum += route[(i-1) * y + j];\n        }\n      }\n    for (int i = 0; i < x; i++)\n      rsum += route[(y-1) * y + i];\n\n    cout << rsum << endl;\n    /* FOR DEBUG                                                                                                                                                                                            \n    for (int i = 0; i < y; i++) {                                                                                                                                                                           \n      for (int j = 0; j < x; j++) {                                                                                                                                                                         \n        cout << route[i * y + j];                                                                                                                                                                           \n        cout << ' ';                                                                                                                                                                                        \n      }                                                                                                                                                                                                     \n      cout << endl;                                                                                                                                                                                         \n      }*/\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define F first\n#define S second\n#define INF 1 << 30\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint main(){\n  int X, Y;\n  while(scanf(\"%d%d\", &X, &Y) && X+Y){\n    int board[15][15], dp[17][15] = {};\n    rep(i, Y) rep(j, X) if(scanf(\"%d\", &board[i][j])  && board[i][j] == 1) dp[i][j] = -1;\n\n    rep(i, X) if(!dp[0][i]) dp[0][i] = 1;\n\n    rep(i, Y-1) rep(j, X){\n      if(board[i][j] == 1) continue;\n      else if(board[i][j] == 2) dp[i+2][j] += dp[i][j];\n      else{\n\tfor(int k = -1; k < 2; k++){\n\t  if(j+k < 0 || j+k >= X) continue;\n\t  if(dp[i+1][j+k] == -1) continue;\n\t  if(board[i+1][j+k] == 2){\n\t    if(k != 0) continue;\n\t    dp[i+1][j+k] += dp[i][j];\n\t  }else{\n\t    dp[i+1][j+k] += dp[i][j];\n\t  }\n\t}\n      }\n    }\n\n    ll res = 0;\n    REP(i, Y-1, Y+1)\n      rep(j, X)\n      if(dp[i][j] != -1)\n\tres += dp[i][j];\n  \n    /*    rep(i, 17){ \n      rep(j, 15) printf(\"%d \", dp[i][j]);\n      puts(\"\");\n      }*/\n\n    printf(\"%lld\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <sstream>\n#include <cmath>\n#include <queue>\n\nusing namespace std;\n\nbool is_inside(int x, int y, int X, int Y){\n\tif(x < 0 || y < 0 || x >= X || y >= Y){\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nint main(){\n\t\n\tint X, Y;\n\t\n\tint course[20][20];\n\tlong long int sum[20][20];\n\t\n\twhile(true){\n\t\tcin >> X >> Y;\n\t\t\n\t\tif(X == 0 && Y == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < Y; i++){\n\t\t\tfor(int j = 0; j < X; j++){\n\t\t\t\tcin >> course[j][i];\n\t\t\t\tsum[j][i] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < X; i++){\n\t\t\tsum[i][0] = 1;\n\t\t}\n\t\t\n\t\tfor(int y = 0; y < Y; y++){\n\t\t\tfor(int x = 0; x < X; x++){\n\t\t\t\tif(course[x][y] == 0){\n\t\t\t\t\tfor(int dx = -1; dx <= 1; dx++){\n\t\t\t\t\t\tif(is_inside(x + dx, y + 1, X, Y)){\n\t\t\t\t\t\t\tif(course[x + dx][y + 1] != 2 || dx == 0){\n\t\t\t\t\t\t\t\tsum[x + dx][y + 1] += sum[x][y];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else if(course[x][y] == 2){\n\t\t\t\t\tif(is_inside(x, y + 2, X, Y)){\n\t\t\t\t\t\tsum[x][y + 2] += sum[x][y];\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tsum[x][y] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong long int ans = 0;\n\t\t\n\t\tfor(int i = 0; i < X; i++){\n\t\t\tif(course[i][Y - 1] == 0){\n\t\t\t\tans += sum[i][Y - 1];\n\t\t\t}\n\t\t\tif(Y >= 2 && course[i][Y - 2] == 2){\n\t\t\t\tans += sum[i][Y - 2];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint X,Y;\nint dp[20][20];\nchar maps[20][20];\nint bun(int x,int y);\nint dx[3]={-1,0,1};\nmain(){\n  while(1){\n    cin>>X>>Y;\n    if(X==0&&Y==0){\n      break;\n    }\n    for(int i=1;i<=Y;i++){\n      for(int j=1;j<=X;j++){\n    cin>>maps[i][j];\n    dp[i][j]=0;\n      }\n    }\n    int ans=0;\n    for(int i=1;i<=X;i++){\n      if(maps[1][i]!='1'){\n    ans+=bun(1,i);\n      }\n    }\n    cout<<ans<<endl;\n  }\n}\nint bun(int y,int x){\n  if(y>=Y){\n    return 1;\n  }\n  else if(dp[y][x]!=0){\n    return dp[y][x];\n  }\n  else if(maps[y][x]=='2'){\n    if(maps[y+2][x]!='1'){\n      return dp[y][x]=bun(y+2,x);\n    }\n    else{\n      return 0;\n    }\n  }\n  else if(maps[y][x]=='1'){\n    return 0;\n  }\n  else{\n    int anss=0;\n    for(int i=0;i<3;i++){\n      int nx=x+dx[i];\n      if(i!=1){\n    if(nx>0&&nx<=X&&maps[y+1][nx]=='0'){\n      anss+=bun(y+1,nx);\n    }\n      }\n      else{\n    if(maps[y+1][nx]!='1'){\n      anss+=bun(y+1,nx);\n    }\n      }\n    }\n    return dp[y][x]=anss;\n  }       \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint w,h;\nint mp[20][20];\nint memo[20][20];\nint dx[] = {-1,0,1},dy[] = {1,1,1};\nvoid saiki(int x,int y) {\n  if(y >= h-1) memo[y][x]++;\n  else if(mp[y][x] != 1) {\n    for(int i=0;i<3;i++) {\n      int nx = dx[i]+x, ny = dy[i]+y;\n      if(nx <0|| nx >= w || memo[ny][nx] == -1||mp[ny][nx] == 1) continue;\n      \n      if(memo[ny][nx] > 0 && mp[ny][nx] == 0) memo[y][x] += memo[ny][nx];\n      else if(mp[ny][nx] == 0){\n\tsaiki(nx,ny);\n\tif(memo[ny][nx] > 0) memo[y][x] += memo[ny][nx];\n      }\n      else if(nx==x && mp[ny][nx] == 2){\n\tint ty = ny;\n\twhile(mp[ty][nx] == 2) ty+=2;\n\tif(mp[ty][nx] == 0 && memo[ty][nx] == 0){\n\t  saiki(nx,ty);\n\t  if(memo[ty][nx] > 0) memo[y][x] += memo[ty][nx];\n\t}\n\telse if(mp[ty][nx] == 0 && memo[ty][nx] > 0) memo[y][x] += memo[ty][nx];\n      }\n    }\n    if(memo[y][x] == 0) mp[y][x] = -1;\n  }\n}\n \n \nint main() {\n   while(1) {\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n    for(int i=0;i<=19;i++)\n      for(int j=0;j<=19;j++)memo[i][j] = mp[i][j] = 0;\n    \n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)cin >> mp[i][j];\n \n    for(int i=0;i<w;i++) \n      if(mp[0][i] !=1) saiki(i,0);\n    \n    int cnt = 0;\n    for(int i=0;i<w;i++)\n      if(memo[0][i] > 0) cnt+=memo[0][i];\n    cout <<cnt<<endl;\n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<math.h>\nint main(void)\n{\n\tint a,s,d[20][20],f,j,i,k;\n\tlong long int g,h[20][20];\n\twhile(1){\n\t\tscanf(\"%d %d\",&a,&s);\n\t\tif(a==0&&s==0) break;\n\t\tfor(i=0;i<s;i++) h[0][i]=1;\n\t\tfor(i=0;i<a;i++){\n\t\t\tfor(j=0;j<s;j++) scanf(\"%d\",&d[i][j]);\n\t\t}\n\t\tfor(i=0;i<s;i++){\n\t\t\tif(d[0][i]==1) h[0][i]=0;\n\t\t}\n\t\tfor(i=1;i<a;i++){\n\t\t\tfor(j=0;j<s;j++) h[i][j]=0;\n\t\t}\n\t\tfor(i=0;i<a;i++){\n\t\t\tfor(j=0;j<s;j++){\n\t\t\t\tif(i!=0&&d[i+1][j]==1&&d[i][j]==2) h[i+1][j]+=h[i][j];\n\t\t\t\tif(h[i][j]!=0){\n\t\t\t\t\tif(d[i][j]==0) if(j!=0) if(d[i+1][j-1]==0) h[i+1][j-1]+=h[i][j];\n\t\t\t\t\tif(j!=s){\n\t\t\t\t\t\tif(d[i][j]==0) if(d[i+1][j+1]==0) h[i+1][j+1]+=h[i][j];\n\t\t\t\t\t\tif(d[i+1][j]==0||d[i+1][j]==2) h[i+1][j]+=h[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tg=0;\n\t\tfor(j=0;j<s;j++) g+=h[a-1][j];\n\t\t/*printf(\"\\n\\n\");\n\t\tfor(i=0;i<a;i++){\n\t\t\tfor(j=0;j<s;j++) printf(\"%d \",h[i][j]);\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\tprintf(\"%d\\n\",g);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 基本テンプレート\n \n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\nusing namespace std;\n \n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {1, 1, 1};\nint dy[] = {-1, 0, 1};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nint board[20][20], dp[30][30];\n \nsigned main() {\n    int W, H;\n    while(cin >> W >> H, W || H) {\n        memset(board, 0, sizeof(board));\n        for(int i=0; i<H; i++) {\n            for(int j=0; j<W; j++) {\n                cin >> board[i][j];\n            }\n        }\n\n        memset(dp, 0, sizeof(dp));\n        for(int i=0; i<W; i++) if(board[0][i] == 0) dp[0][i] = 1;\n\n        int ans = 0;\n        for(int i=0; i<H - 1; i++) {\n            for(int j=0; j<W; j++) {\n                if(board[i][j] == 1) continue;\n                for(int k=0; k<3; k++) {\n                    if(board[i][j] == 2 and k != 1) continue;\n                    int dbl = (board[i][j] == 2 ? 2 : 1);\n\n                    int ni = i + dx[k] * dbl, nj = j + dy[k];\n                    if(ni < 0 or nj < 0 or nj >= W) continue;\n                    if(board[ni][nj] == 1) continue;\n                    if(board[ni][nj] == 2 and k != 1) continue;\n\n                    if(ni < H - 1) {\n                        dp[ni][nj] += dp[i][j];\n                    }\n                    else {\n                        ans += dp[i][j];\n                    }\n                }\n            }\n        }\n\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// AOJ 0203\n#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nint main(void)\n{\n\tint x, y;\n\twhile (cin >> x >> y, x || y){\n\t\tint field[32][32] = {};\n\t\tfor (int i = 1; i <= y; i++){\n\t\t\tfor (int j = 1; j <= x; j++){\n\t\t\t\tcin >> field[i][j];\n\t\t\t}\n\t\t}\n\t\tint dp[32][32];\n\t\tmemset(dp, 0, sizeof(dp));\n\n\t\tfor (int j = 1; j <= x; j++){\n\t\t\tif (field[1][j] == 0){\n\t\t\t\tdp[1][j] = 1;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= y; i++){\n\t\t\tfor (int j = 1; j <= x; j++){\n\t\t\t\tif (field[i][j] == 1){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (field[i][j] == 2){\n\t\t\t\t\tdp[i + 2][j] += dp[i][j];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (field[i + 1][j - 1] == 0){\n\t\t\t\t\tdp[i + 1][j - 1] += dp[i][j];\n\t\t\t\t}\n\t\t\t\tif (field[i + 1][j] != 1){\n\t\t\t\t\tdp[i + 1][j] += dp[i][j];\n\t\t\t\t}\n\t\t\t\tif (field[i + 1][j + 1] == 0){\n\t\t\t\t\tdp[i + 1][j + 1] += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ret = 0;\n\t\tfor (int i = y - 1; i <= y; i++){\n\t\t\tfor (int j = 1; j <= x; j++){\n\t\t\t\tif (i == y - 1){\n\t\t\t\t\tif (field[i][j] == 2) ret += dp[i][j];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tret += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ret << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\ntypedef long long ll;\nint x, y;\nll dp[15][15];\nint mp[15][15];\nint main() {\n  while (scanf(\"%d%d\",&x,&y)) {\n    if (!x&&!y) break;\n    memset(dp, 0, sizeof(dp));\n    memset(mp, 0, sizeof(mp));\n    for (int i=0; i<y; i++) {\n      for (int j=0; j<x; j++) scanf(\"%d\",&mp[i][j]);\n    }\n    for (int i=0; i<x; i++) if (mp[0][i]!=1) dp[0][i]=1;\n    ll res = 0;\n    for (int i=0; i<y-1; i++) {\n      for (int j=0; j<x; j++) {\n        if (mp[i][j]==2) {\n          if (i+2>=y) res+=dp[i][j];\n          else dp[i+2][j]+=dp[i][j];\n        } else {\n          if (j!=0&&mp[i+1][j-1]==0) dp[i+1][j-1]+=dp[i][j];\n          if (mp[i+1][j]!=1) dp[i+1][j]+=dp[i][j];\n          if (j!=x-1&&mp[i+1][j+1]==0) dp[i+1][j+1]+=dp[i][j];\n        }\n      }\n    }\n    for (int i=0; i<x; i++) res+=dp[y-1][i];\n    printf(\"%lld\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint X,Y,m[15][17],dp[15][17];\n\nint main(){\n\twhile(cin>>X>>Y&&X){\n\t\trep(i,Y)fill(dp[i],dp[i]+17,0);\n\t\trep(i,Y)rep(j,X){\n\t\t\tcin>>m[i][j+1];\n\t\t\tif(!i&&!m[i][j+1])dp[i][j+1]=1;\n\t\t}\n\t\tfor(int i=1;i<Y;i++)for(int j=1;j<=X;j++){\n\t\t\tif(m[i][j]==0){\n\t\t\t\tfor(int k=-1;k<2;k++)if(m[i-1][j+k]==0)dp[i][j]+=dp[i-1][j+k];\n\t\t\t\tif(i>1&&m[i-2][j]==2)dp[i][j]+=dp[i-2][j];\n\t\t\t\tif(i==Y-1&&m[i-1][j]==2)dp[i][j]+=dp[i-1][j];\n\t\t\t}\n\t\t\tif(m[i][j]==1&&i==Y-1&&m[i-1][j]==2)dp[i][j]+=dp[i-1][j];\n\t\t\tif(m[i][j]==2){\n\t\t\t\tif(m[i-1][j]==0)dp[i][j]=dp[i-1][j];\n\t\t\t\tif(i>1&&m[i-2][j]==2)dp[i][j]+=dp[i-2][j];\n\t\t\t\tif(i==Y-1&&m[i-1][j]==2)dp[i][j]+=dp[i-1][j];\n\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t\trep(i,X)ans+=dp[Y-1][i+1];\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint maps[20][20];\nint course[20][20];\nint X, Y;\n\nint way(int y, int x){\n  if(course[y][x] > 0) return course[y][x];\n  else if(maps[y][x] == 1) return 0;\n  else if(y >= Y) return 1;\n  else if(maps[y][x] == 2 && maps[y + 2][x] != 1) return course[y][x] = way(y + 2, x);\n  else{\n    int SUM = 0;\n    for(int i = 0; i < 3; i++){\n      int ny = y + 1;\n      int nx = x - 1 + i;\n      if(maps[ny][nx] != 1 && 1 <= nx && nx <= X){\n\tint flug = 1;\n\tif(i != 1 && maps[ny][nx] == 2) flug = 0;\n\tif(flug) SUM += way(ny, nx);\n      }\n    }\n    return course[y][x] = SUM;\n  }\n} \n\nint main(){\n  while(1){\n    cin >> X >> Y;\n    if(X == 0 && Y == 0) break;\n    for(int i = 1; i <= Y; i++){\n      for(int j = 1; j <= X; j++){\n\tcin >> maps[i][j];\n\tcourse[i][j] = 0;\n      }\n    }\n    int cnt = 0;\n    for(int i = 1; i <= X; i++){\n      if(maps[0][i] != 1) cnt += way(1, i);\n    }\n    cout << cnt << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint x,y,a[17][17],s,i,j;\nvoid dfs(int y1,int x1){\n  if(a[y1][x1]==1)return;\n  if(x1<1||x1>x)return;\n  if(y1>=y){s++;return;}\n  if(a[y1][x1]==2)dfs(y1+2,x1);\n  else {if(a[y1+1][x1]!=1)dfs(y1+1,x1);\n  if(a[y1+1][x1+1]==0)dfs(y1+1,x1+1);\n  if(a[y1+1][x1-1]==0)dfs(y1+1,x1-1);}\n  return;\n}\nint main(){\n  while(cin>>x>>y,x){\n    for(s=0,i=0;i<17;i++)for(j=0;j<17;j++)a[i][j]=0;    \n    for(s=0,i=1;i<=y;i++)for(j=1;j<=x;j++)cin>>a[i][j];\n    for(i=1;i<=x;i++){if(a[1][i]==0)dfs(1,i);}\n    cout<<s<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint X,Y;\nint dp[20][20];\nchar maps[20][20];\nint bun(int x,int y);\nint dx[3]={-1,0,1};\nmain(){\n  while(1){\n    cin>>X>>Y;\n    if(X==0&&Y==0){\n      break;\n    }\n    for(int i=1;i<=Y;i++){\n      for(int j=1;j<=X;j++){\n\tcin>>maps[i][j];\n\tdp[i][j]=0;\n      }\n    }\n    int ans=0;\n    for(int i=1;i<=X;i++){\n      if(maps[1][i]!='1'){\n\tans+=bun(1,i);\n      }\n    }\n    cout<<ans<<endl;\n  }\n}\nint bun(int y,int x){\n  if(y>=Y){\n    return 1;\n  }\n  else if(dp[y][x]!=0){\n    return dp[y][x];\n  }\n  else if(maps[y][x]=='2'){\n    if(maps[y+2][x]!='1'){\n      return dp[y][x]=bun(y+2,x);\n    }\n    else{\n      return 0;\n    }\n  }\n  else if(maps[y][x]=='1'){\n    return 0;\n  }\n  else{\n    int anss=0;\n    for(int i=0;i<3;i++){\n      int nx=x+dx[i];\n      if(i!=1){\n\tif(nx>0&&nx<=X&&maps[y+1][nx]=='0'){\n\t  anss+=bun(y+1,nx);\n\t}\n      }\n      else{\n\tif(maps[y+1][nx]!='1'){\n\t  anss+=bun(y+1,nx);\n\t}\n      }\n    }\n    return dp[y][x]=anss;\n  }\t  \t  \n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstdio>\n#include<string.h>\n#include<cstring>\n#include<algorithm>\n#include<functional>\n#include<math.h>\n#include<queue>\n#include<ctype.h>\n#define MAX  1000000000\n#define MIN -1000000000\nusing namespace std;\nint i,j;\nint x,y;\nlong long int dp[1000][1000];\nint map[1000][1000];\nint main(void){\n\tscanf(\"%d %d\",&x,&y);\n\twhile(x!=0 && y!=0){\n\t\tfor(i=1;i<=17;i++){\n\t\t\tfor(j=1;j<=15;j++){\n\t\t\t\tdp[i][j]=0;\n\t\t\t\tmap[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=y;i++){\n\t\t\tfor(j=1;j<=x;j++){\n\t\t\t\tscanf(\"%d\",&map[i][j]);\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=x;i++){\n\t\t\tif(map[1][i]!=1){\n\t\t\t\tdp[1][i]=1;\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<y;i++){\n\t\t\tfor(j=1;j<=x;j++){\n\t\t\t\tif(dp[i][j]>0 && map[i][j]!=2){\n\t\t\t\t\tif(map[i+1][j-1]==0){\n\t\t\t\t\t\tif(j-1<0);\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tdp[i+1][j-1]+=dp[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(map[i+1][j]!=1 ){\n\t\t\t\t\t\tif(map[i+1][j]==0){\n\t\t\t\t\t\t\tdp[i+1][j]+=dp[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tint temp;\n\t\t\t\t\t\t\ttemp=i+1;\n\t\t\t\t\t\t\twhile(map[temp][j]==2){\n\t\t\t\t\t\t\t\ttemp+=2;\n\t\t\t\t\t\t\t\tdp[temp][j]+=dp[i][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(map[i+1][j+1]==0){\n\t\t\t\t\t\tif(j+1>x);\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tdp[i+1][j+1]+=dp[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n/*\t\tfor(i=1;i<=y+2;i++){\n\t\t\tprintf(\"%d=\",i);\n\t\t\tfor(j=1;j<=x;j++){\n\t\t\t\tprintf(\"%d \",dp[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\tint cnt=0;\n\t\tfor(i=0;i<=2;i++){\n\t\t\tfor(j=1;j<=x;j++){\n\t\t\t\tcnt+=dp[y+i][j];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",cnt);\n\t\tscanf(\"%d %d\",&x,&y);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n\tint n,m;\n\tint masu[17][17];\n\tint ura[17][17];\n\twhile(1){\n\t\tscanf(\"%d%d\",&m,&n);\n\t\tif(n==0 && m==0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i=0;i<17;i++){\n\t\t\tfor(int j=0;j<17;j++){\n\t\t\t\tmasu[i][j]=0;\n\t\t\t\tura[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=1;j<=m;j++){\n\t\t\t\tscanf(\"%d\",&ura[i][j]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tswitch(ura[1][i]){\n\t\t\t\tcase 0:masu[1][i]+=1;break;\n\t\t\t\tcase 1:masu[1][i]+=0;break;\n\t\t\t\tcase 2:masu[1][i]+=1;break;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfor(int j=1;j<=m;j++){\n\t\t\t\tif(ura[i][j]==0){\n\t\t\t\t\tif(ura[i+1][j-1]==0){\n\t\t\t\t\t\tmasu[i+1][j-1]+=masu[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tif(ura[i+1][j]!=1){\n\t\t\t\t\t\tmasu[i+1][j]+=masu[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tif(ura[i+1][j+1]==0){\n\t\t\t\t\t\tmasu[i+1][j+1]+=masu[i][j];\n\t\t\t\t\t}\n\t\t\t\t}else if(ura[i][j]==2){\n\t\t\t\t\tif(ura[i+2][j]!=1){\n\t\t\t\t\t\tmasu[i+2][j]+=masu[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cont=0;\n\t\tfor(int i=n;i<=n+1;i++){\n\t\t\tfor(int j=1;j<=m;j++){\n\t\t\t\tcont+=masu[i][j];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",cont);\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main()\n{\n  int X, Y;\n  while (cin >> X >> Y) {\n    if ((X|Y) == 0)\n      break;\n\n    vector<vector<int> > cource(Y, vector<int>(X));\n    for (int i = 0; i < Y; ++i) {\n      for (int j = 0; j < X; ++j)\n\tcin >> cource[i][j];\n    }\n\n    vector<vector<int> > dp(Y, vector<int>(X, 0));\n    for (int i = 0; i < X; ++i) {\n      if (cource[0][i] == 0)\n\tdp[0][i] = 1;\n    }\n\n    int out = 0;\n    for (int i = 0; i < Y-1; ++i) {\n      for (int j = 0; j < X; ++j) {\n\tif (cource[i][j] == 0) {\n\t  dp[i+1][j] += dp[i][j];\n\t  if (j > 0 && cource[i+1][j-1] == 0)\n\t    dp[i+1][j-1] += dp[i][j];\n\t  if (j < X-1 && cource[i+1][j+1] == 0)\n\t    dp[i+1][j+1]+= dp[i][j];\n\n\t} else if (cource[i][j] == 2) {\n\t  if (i+2 < Y)\n\t    dp[i+2][j] += dp[i][j];\n\t  else\n\t    out += dp[i][j];\n\t}\n      }\n    }\n\n    int ans = 0;\n    for (int i = 0; i < X; ++i) {\n      if (cource[Y-1][i] == 0)\n\tans += dp[Y-1][i];\n    }\n    cout << ans+out << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef struct {\n    int y;\n    int x;\n    int x_temp;\n    int end;\n    int ans;\n} Ski_data; \n\nint ski_resort[16][17];\n\nSki_data* ski_ans(Ski_data* ski_data_ptr) \n{\n    bool retire_flag = false;\n\n    while (ski_data_ptr->y <= (ski_data_ptr->end + 1) && !retire_flag) {\n        std::cout << \"(y, x) : \"  << ski_data_ptr->y << \" \" << ski_data_ptr->x << std::endl;\n\n        switch (ski_resort[ski_data_ptr->y][ski_data_ptr->x]) {\n            \n            case 0:\n                ski_data_ptr->y += 1;\n                for (int i = -1; i <= 1; ++i) {\n                    int temp_x = ski_data_ptr->x;\n                    int temp_y = ski_data_ptr->y;\n                    ski_data_ptr->x += i;\n\n                    ski_ans(ski_data_ptr);\n\n                    if ( i <= 0) {\n                        ski_data_ptr->x = temp_x;\n                        ski_data_ptr->y = temp_y;\n                    } else {\n                        retire_flag = true;\n                    }\n                }\n                \n                break;\n            case 1:\n                retire_flag = true;\n                break;\n            case 2:\n                if (ski_data_ptr-> y <= ski_data_ptr->end)\n                ski_data_ptr->y += 2;\n                break;\n            case 3:\n                ski_data_ptr->ans += 1;\n                //std::cout << \"ski_data_ptr->ans : \" << ski_data_ptr->ans << std::endl;\n                retire_flag = true;\n                break;\n            default:\n                break;\n        }\n    }\n    return ski_data_ptr;\n}\n\nint main(void)\n{\n    int ski_height, ski_width;\n    bool half_flag = false;\n    \n    while (std::cin >> ski_width >> ski_height) {\n        if (!ski_width && !ski_height) {\n            break;\n        }\n\n        for (int y = 0; y < ski_height; ++y) {\n            for (int x = 1; x < ski_width + 1; ++x) {\n                std::cin >> ski_resort[y][x];\n                if (ski_resort[y][x] != 0) {\n                    half_flag = true;\n                }\n            }\n        }\n\n        for (int y = 0; y < ski_height; ++y){\n            ski_resort[y][0] = ski_resort[y][ski_width + 1] = 1;\n        }\n\n        for (int x = 1; x < ski_width + 1; ++x) {\n            if (ski_resort[ski_height - 1][x] != 1){\n                ski_resort[ski_height - 1][x] = 3;\n            }\n        }\n\n        for (int x = 0; x < ski_width + 2; ++x) {\n            if (x == 0 || x == ski_width + 1) {\n                ski_resort[ski_height][x] = 1;\n            } else {\n                ski_resort[ski_height][x] = 3;\n            }\n        }\n\n        int ans = 0;\n        \n        for (int x = 1; x < ski_width + 1; ++x) {\n            Ski_data ski_data = {0, x, 0, ski_height - 1, 0};\n\n            ans += ski_ans(&ski_data)->ans;\n            \n            /*std::cout << \"ski_data->ans : \" << ski_data.ans \n                      << \" ans : \" << ans << std::endl;\n            */\n        }\n\n        std::cout << ans / (half_flag ? 2 : 1) << std::endl;\n\n        /*\n        for (int y = 0; y < ski_height + 1; ++y) {\n            for (int x = 0; x < ski_width + 2; ++x) {\n                std::cout << ski_resort[y][x];\n            }\n            std::cout << std::endl;\n        }\n        */\n    }\n    \n    return 0;\n}\n        \n        "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\ntypedef long long ll;\nint x, y;\nll dp[20][20];\nint mp[20][20];\nint main() {\n  while (scanf(\"%d%d\",&x,&y)) {\n    if (!x&&!y) break;\n    memset(dp, 0, sizeof(dp));\n    memset(mp, 0, sizeof(mp));\n    for (int i=0; i<y; i++) {\n      for (int j=0; j<x; j++) scanf(\"%d\",&mp[i][j]);\n    }\n    for (int i=0; i<x; i++) if (mp[0][i]!=1) dp[0][i]=1;\n    ll res = 0;\n    for (int i=0; i<y-1; i++) {\n      for (int j=0; j<x; j++) {\n        if (mp[i][j]==2&&mp[i+2][j]!=1) {\n          dp[i+2][j]+=dp[i][j];\n        } else if (mp[i][j]==0) {\n          if (j-1>=0&&mp[i+1][j-1]==0) dp[i+1][j-1]+=dp[i][j];\n          if (mp[i+1][j]!=1) dp[i+1][j]+=dp[i][j];\n          if (j+1<x&&mp[i+1][j+1]==0) dp[i+1][j+1]+=dp[i][j];\n        }\n      }\n    }\n    for (int i=0; i<x; i++) res+=dp[y][i]+dp[y-1][i];\n    printf(\"%lld\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int W, H, mas[16][16];\n  while( cin >> W >> H, W){\n    for(int i = 0; i < H; i++){\n      for(int j = 0; j < W; j++){\n        cin >> mas[i][j];\n      }\n    }\n    vector< vector< int > > dp( H + 1, vector< int >(W, 0));\n    for(int i = 0; i < W; i++){\n      if(mas[0][i] != 1) dp[0][i] = 1;\n    }\n    for(int i = 0; i < H; i++){\n      for(int j = 0; j < W; j++){\n        if(dp[i][j] == 0) continue;\n        if(mas[i][j] == 0){\n          for(int k = -1; k <= 1; k++){\n            if(j + k < 0 || j + k >= W) continue;\n            if((i == H - 1 && k == 0) || (i != H - 1 && k == 0 && mas[i + 1][j + k] == 2) || (i != H - 1 && mas[i + 1][j + k] == 0)){\n              dp[i + 1][j + k] += dp[i][j];\n            }\n          }\n        } else if(mas[i][j] == 2){\n          if(i >= H - 2 || mas[i + 2][j] != 1){\n            dp[min(H, i + 2)][j] += dp[i][j];\n          }\n        }\n      }\n    }\n\n    int ret = 0;\n    for(int i = 0; i < W; i++){\n      ret += dp[H][i];\n    }\n    cout << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint solve(int x,int y);\nint ax,ay;\nint mas[200][200];\nint memo[200][200];\nint main(){\n  while(1){\n    for(int i=0;i<200;i++){\n      for(int j=0;j<200;j++){\n\tmemo[i][j]=0;\n      }\n    }\n    int ans=0;\n    cin>>ax>>ay;\n    if(ax==0 && ay==0) break;\n    \n    for(int i=0;i<ay;i++){\n      for(int j=0;j<ax;j++){\n\tcin>>mas[i][j];\n      }\n    }\n    \n    for(int i=0;i<ax;i++){\n      if(mas[0][i]!=1){\n\tans+=solve(i,0);\n      }\n    }\n    cout<<ans<<endl;\n  }\n}\nint solve(int x,int y){\n  if(memo[y][x]!=0){\n    return memo[y][x];\n  }\n  else if(y==ay){\n    return 1;\n  }else if(mas[y][x]==1){\n    return 0;\n  }else if(mas[y][x]==2){\n    return solve(x,y+2);\n  } \n  else{\n    int anss=0; \n    if(mas[y+1][x]!=1){\n      anss+=solve(x,y+1);\n    }\n    if(x+1<ax && mas[y+1][x+1]==0 && y+1!=ay){\n      anss+=solve(x+1,y+1);\n    }\n    if(0<=x-1 && mas[y+1][x-1]==0 && y+1!=ay){\n      anss+=solve(x-1,y+1);\n    }\n    return memo[y][x]=anss;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n\nusing namespace std;\n\nint main(){\n\n\tint width,height,map[17][17],table[17][17],sum;\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&width,&height);\n\t\tif(width == 0 && height == 0)break;\n\n\t\tfor(int i = 0; i < 17; i++){\n\t\t\tfor(int k = 0; k < 17; k++){\n\t\t\t\ttable[i][k] = 0;\n\t\t\t\tmap[i][k] = 2;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 1; i <= height; i++){\n\t\t\tfor(int k = 1; k <= width; k++){\n\t\t\t\tscanf(\"%d\",&map[i][k]);\n\t\t\t\tif(map[i][k] == 0){\n\t\t\t\t\tif(i == 1){\n\t\t\t\t\t\ttable[i][k] = 1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(map[i-1][k-1] != 2){\n\t\t\t\t\t\t\ttable[i][k] += table[i-1][k-1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(map[i-1][k] != 2){\n\t\t\t\t\t\t\ttable[i][k] += table[i-1][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(map[i-1][k+1] != 2){\n\t\t\t\t\t\t\ttable[i][k] += table[i-1][k+1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(map[i-2][k] == 2){\n\t\t\t\t\t\t\ttable[i][k] += table[i-2][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else if(map[i][k] == 1){\n\t\t\t\t\ttable[i][k] = 0;\n\t\t\t\t}else{\n\t\t\t\t\tif(map[i-1][k] != 2){\n\t\t\t\t\t\ttable[i][k] += table[i-1][k];\n\t\t\t\t\t}\n\t\t\t\t\tif(map[i-2][k] == 2){\n\t\t\t\t\t\ttable[i][k] += table[i-2][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsum = 0;\n\n\t\tfor(int k = 1; k <= width; k++){\n\t\t\tsum += table[height][k];\n\t\t\tif(map[height-1][k] == 2){\n\t\t\t\tsum += table[height-1][k];\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",sum);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<math.h>\nint main(void)\n{\n\tint a,s,d[20][20],f,j,i,k;\n\tlong long int g,h[20][20];\n\twhile(1){\n\t\tscanf(\"%d %d\",&a,&s);\n\t\tif(a==0&&s==0) break;\n\t\tfor(i=0;i<s;i++) h[0][i]=1;\n\t\tfor(i=0;i<a;i++){\n\t\t\tfor(j=0;j<s;j++) scanf(\"%d\",&d[i][j]);\n\t\t}\n\t\tfor(i=0;i<s;i++){\n\t\t\tif(d[0][i]==1) h[0][i]=0;\n\t\t}\n\t\tfor(i=1;i<a;i++){\n\t\t\tfor(j=0;j<s;j++) h[i][j]=0;\n\t\t}\n\t\tfor(i=0;i<a;i++){\n\t\t\tfor(j=0;j<s;j++){\n\t\t\t\tif(i!=0&&d[i+1][j]==1&&d[i][j]==2){\n\t\t\t\t\tif(i+2<a) h[i+2][j]+=h[i][j];\n\t\t\t\t\telse h[i+1][j]+=h[i][j];\n\t\t\t\t}\n\t\t\t\tif(h[i][j]!=0){\n\t\t\t\t\tif(d[i][j]==0) if(j!=0) if(d[i+1][j-1]==0) h[i+1][j-1]+=h[i][j];\n\t\t\t\t\tif(j!=s){\n\t\t\t\t\t\tif(d[i][j]==0) if(d[i+1][j+1]==0) h[i+1][j+1]+=h[i][j];\n\t\t\t\t\t\tif(d[i+1][j]==0||d[i+1][j]==2) h[i+1][j]+=h[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tg=0;\n\t\tfor(j=0;j<s;j++) g+=h[a-1][j];\n\t\t/*printf(\"\\n\\n\");\n\t\tfor(i=0;i<a;i++){\n\t\t\tfor(j=0;j<s;j++) printf(\"%d \",h[i][j]);\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\tprintf(\"%d\\n\",g);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint field[20][20];\nint dp[20][20];\n\nint n, m;\n\nbool isIn(int x, int y){\n    return 0 <= x && x < n && 0 <= y && y < m;\n}\n\nint main(){\n    while(cin >> n >> m, n+m){\n        for(int i=0; i < n; i++) for(int j=0; j< m; j++){cin >> field[i][j];}\n        for(int i=0; i< 20; i++) for(int j=0; j< 20; j++) dp[i][j] = 0;\n        for(int i=0; i < m; i++) dp[0][i] = 1;\n        for(int i=0; i < n-1; i++){\n            for(int j=0; j < m; j++){\n                if(field[i][j] == 0){\n                    for(int k=-1; k <= 1; k++){\n                        if(isIn(i+1, j+k) && !(k != 0 && field[i+1][j+k] == 2)){\n                            dp[i+1][j+k] += dp[i][j];\n                        }\n                    }\n                }\n                else if(field[i][j] == 2) dp[i+2][j] += dp[i][j];\n            }\n        }\n        for(int i=0; i< m; i++) if(field[n-1][i] != 1)dp[n][i] += dp[n-1][i];\n        long long count = 0;\n        for(int i=0; i< m; i++) count += dp[n][i];\n        cout << count << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#define N 16\nusing namespace std;\nvoid func(int,int);\nint jump(int,int);\nint X,Y,data[N][N],memo[N+2][N];\nint main(){\n  while(1){\n    cin >> X >> Y;\n    if(X==0&&Y==0) break;\n    for(int i=0;i<Y;i++)\n      for(int j=0;j<X;j++) cin >> data[i][j];\n    for(int i=0;i<Y+2;i++)\n      for(int j=0;j<X;j++) memo[i][j]=0;\n    for(int i=0;i<X;i++)\n      if(data[0][i]!=1)\tfunc(0,i);\n    int cnt=0;\n    for(int i=0;i<X;i++) cnt+=memo[0][i];\n    cout << cnt << endl;\n  }\n  return 0;\n}\nvoid func(int y,int x){\n  if(y>=Y-1){\n    memo[Y][x]=memo[Y-1][x]=1;\n    return ;\n  }\n  if(0<=x-1&&data[y+1][x-1]==0){\n    if(memo[y+1][x-1]!=0) memo[y][x]+=memo[y+1][x-1];\n    else{\n      func(y+1,x-1),memo[y][x]+=memo[y+1][x-1];\n    }\n  }\n  if(x+1<X&&data[y+1][x+1]==0){\n    if(memo[y+1][x+1]!=0) memo[y][x]+=memo[y+1][x+1];\n    else{\n      func(y+1,x+1),memo[y][x]+=memo[y+1][x+1];\n    }\n  }\n  if(data[y+1][x]==0){\n    if(memo[y+1][x]!=0) memo[y][x]+=memo[y+1][x];\n    else{\n      func(y+1,x),memo[y][x]+=memo[y+1][x];\n    }\n  }\n  if(data[y+1][x]==2){\n    int r=jump(y+1,x);\n    if(r!=-1){\n      if(memo[r][x]!=0) memo[y][x]+=memo[r][x];\n      else{\n\tfunc(r,x),memo[y][x]+=memo[r][x];\n      }\n    }\n  }\n  if(memo[y][x]==0) data[y][x]=1;\n}\nint jump(int y,int x){\n  y+=2;\n  while(1){\n    if(data[y][x]==1) break;\n    if(data[y][x]==0) return y;\n    if(y>=Y-1) return y;\n    y+=2;\n  }\n  return -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 25\n\nint main()\n{\n    int H, W;\n    while (cin >> W >> H, W) {\n        vector<vector<int>> a(H, vector<int>(W));\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                cin >> a[i][j];\n            }\n        }\n        int dp[MAX][MAX] = {{}};\n        for (int i = 0; i < W; i++) {\n            dp[0][i] = (a[0][i] == 0);\n        }\n\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (dp[i][j] <= 0 || a[i][j] == 1) continue;\n                if (a[i][j] == 2) {\n                    int ni = min(i + 2, H - 1);\n                    if (i + 2 < H && a[i+2][j] == 1) continue;\n                    dp[ni][j] += dp[i][j];\n                } else {\n                    for (int k = -1; k <= 1; k++) {\n                        int ni = i + 1;\n                        int nj = j + k;\n                        if (nj < 0 || nj >= W || ni >= H) continue;\n                        if (a[ni][nj] == 1) continue;\n                        if (a[ni][nj] == 2 && j != nj) continue;\n                        dp[ni][nj] += dp[i][j];\n                    }\n                }\n            }\n        }\n        int res = 0;\n        for (int i = 0; i < W; i++) {\n            res += dp[H-1][i];\n        }\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\nint a[16][16];\nint count = 0;\nint n,m;\n\nvoid dfs(int y,int x)\n{\n\tif(y > m-1)\n\t{\n\t\treturn;\n\t}\n\n\tif(a[y][x] == 0)\n\t{\n\t\tif(y == m-1)\n\t\t{\n\t\t\tcount++;\n\t\t\treturn;\n\t\t}\n\t\tif(x-1 >= 0 && y+1 < m)\n\t\t{\n\t\t\tif(a[y+1][x-1] != 2)\n\t\t\t{\n\t\t\t\tdfs(y+1,x-1);\n\t\t\t}\n\t\t}\n\t\tif(y+1 < m)\n\t\t{\n\t\t\tdfs(y+1,x);\n\t\t}\n\t\tif(x+1 < n && y+1 < m)\n\t\t{\n\t\t\tif(a[y+1][x+1] != 2)\n\t\t\t{\n\t\t\t\tdfs(y+1,x+1);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\telse if(a[y][x] == 1)\n\t{\n\t\treturn;\n\t}\n\telse if(a[y][x] == 2)\n\t{\n\t\tif(y == m-2)\n\t\t{\n\t\t\tcount++;\n\t\t\treturn;\n\t\t}\n\t\telse if(y == m-1)\n\t\t{\n\t\t\tcount++;\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdfs(y+2,x);\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile(cin >> n >> m)\n\t{\n\t\tif(n == 0 && m == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tmemset(a,0,sizeof(a));\n\t\trep(i,n)\n\t\t{\n\t\t\trep(j,m)\n\t\t\t{\n\t\t\t\tcin >> a[i][j];\n\t\t\t}\n\t\t}\n\t\tcount = 0;\n\t\trep(i,n) dfs(0,i);\n\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define loop(i,a,b) for(int i=a; i<b; i++)\n#define rep(i,b) loop(i,0,b)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\n\nint main(){\n    int w,h;\n    while(cin>>w>>h, w||h){\n        int G[100][100]={};\n        int dp[100][100]={};\n\n        rep(i,h)rep(j,w) cin>> G[i][j];\n        rep(i,w) dp[0][i] = G[0][i]==0;\n\n        rep(i,h-1) rep(j,w){\n            if( G[i][j]==1){\n                dp[i][j]=0;\n            } else if(G[i][j]==2 && G[i+2][j]!=1){\n                dp[i+2][j]+=dp[i][j];\n            } else {\n                if(G[i+1][j]==2) dp[i+1][j]+=dp[i][j];\n                loop(k,-1,2){\n                    if(0<=j+k && j+k<w && G[i+1][j+k]==0){\n                        dp[i+1][j+k]+=dp[i][j];\n                    }\n                }\n            }\n        }\n\n        ull res=0;\n        for(int i: {h-1,h}) rep(j,w){\n            res+=dp[i][j];\n        }\n\n        cout<<res<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 0203\n#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nint main(void)\n{\n\tint x, y;\n\twhile (cin >> x >> y, x || y){\n\t\tint field[32][32];\n\t\tswap(x, y);\n\t\tfor (int i = 1; i <= y; i++){\n\t\t\tfor (int j = 1; j <= x; j++){\n\t\t\t\tcin >> field[i][j];\n\t\t\t}\n\t\t}\n\t\tint dp[32][32];\n\t\tmemset(dp, 0, sizeof(dp));\n\n\t\tfor (int j = 1; j <= x; j++){\n\t\t\tif (field[1][j] == 0){\n\t\t\t\tdp[1][j] = 1;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= y; i++){\n\t\t\tfor (int j = 1; j <= x; j++){\n\t\t\t\tif (field[i][j] == 1){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (field[i][j] == 2){\n\t\t\t\t\tdp[i + 2][j] += dp[i][j];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (field[i + 1][j - 1] == 0){\n\t\t\t\t\tdp[i + 1][j - 1] += dp[i][j];\n\t\t\t\t}\n\t\t\t\tif (field[i + 1][j] != 1){\n\t\t\t\t\tdp[i + 1][j] += dp[i][j];\n\t\t\t\t}\n\t\t\t\tif (field[i + 1][j + 1] == 0){\n\t\t\t\t\tdp[i + 1][j + 1] += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ret = 0;\n\t\tfor (int i = y - 1; i <= y; i++){\n\t\t\tfor (int j = 1; j <= x; j++){\n\t\t\t\tif (i == y - 1){\n\t\t\t\t\tif (field[i][j] == 2) ret += dp[i][j];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tret += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ret << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define ck(a,b) (0<=a&&a<b)\nusing namespace std;\nint dx[]={-1,0,1};\nint main(){\n\tint X,Y,c[15][15],land[15][15],ans;\n\twhile(cin>>X>>Y,X){\n\t\trep(i,Y)rep(j,X)cin>>land[i][j],c[i][j]=i==0&&land[i][j]!=1;\n\t\trep(i,Y){\n\t\t\trep(j,X)cout<<c[i][j]<<\" \"; cout<<endl;\n\t\t}\n\t\trep(i,Y-1)rep(j,X)if(land[i+1][j]!=1){\n\t\t\tif(land[i+1][j]==2)c[i+1][j]+=c[i][j];\n\t\t\telse rep(d,3)if(ck(j+dx[d],X)&&land[i][j+dx[d]]==0)\n\t\t\tc[i+1][j]+=c[i][j+dx[d]];\n\t\t\tif(i>0&&land[i-1][j]==2)c[i+1][j]+=c[i-1][j];\n\t\t}\n\t\tans=0;\n\t\trep(i,X){\n\t\t\tans+=c[Y-1][i];\n\t\t\tif(Y>1&&land[Y-2][i]==2)ans+=c[Y-2][i];\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint w,h;\nint mp[20][20],memo[20][20];\nint saiki(int x,int y){\n  if(y >= h-1) return 1;\n  for(int i=-1;i<=1;i++) {\n    int nx = x+i, ny = y+1;\n    if(nx==x && mp[ny][nx] == 2)while(mp[ny][nx] == 2) ny+=2;\n    if(nx <0|| nx >= w ||mp[ny][nx] != 0) continue;\n    if(memo[ny][nx]==0) memo[y][x]+=saiki(nx,ny);\n    else memo[y][x] += memo[ny][nx];\n  }\n  mp[y][x] = 1;\n  return memo[y][x];\n}\nint main() {\n  while(1) {\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n    for(int i=0;i<=19;i++)\n      for(int j=0;j<=19;j++)memo[i][j] = mp[i][j] = 0;\n    \n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)cin >> mp[i][j];\n   \n    int cnt = 0;  \n    for(int i=0;i<w;i++)\n      if(mp[0][i] !=1)cnt+=saiki(i,0);\n    cout << cnt <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint w,h;\nint mp[20][20],memo[20][20];\nint dx[] = {-1,0,1};\nvoid saiki(int x,int y) {\n  if(y >= h-1) memo[y][x]++;\n  else if(mp[y][x] != 1) {\n    for(int i=0;i<3;i++) {\n      int nx = x+dx[i], ny = y+1;\n      if(nx==x && mp[ny][nx] == 2)while(mp[ny][nx] == 2) ny+=2;\n      if(nx <0|| nx >= w ||mp[ny][nx] == 1) continue;\n\n      if(memo[ny][nx]>0&&mp[ny][nx]==0) memo[y][x] += memo[ny][nx];\n      else if(mp[ny][nx] == 0){\n\tsaiki(nx,ny);\n\tmemo[y][x] += memo[ny][nx];\n      }\n    }\n    if(memo[y][x] == 0) mp[y][x] = 1;\n  }\n}\nint main() {\n  while(1) {\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n    for(int i=0;i<=19;i++)\n      for(int j=0;j<=19;j++)memo[i][j] = mp[i][j] = 0;\n     \n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)cin >> mp[i][j];\n  \n    for(int i=0;i<w;i++)\n      if(mp[0][i] !=1) saiki(i,0);\n     \n    int cnt = 0;\n    for(int i=0;i<w;i++)cnt+=memo[0][i];\n    cout <<cnt<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint main(){\n\tint w,h,x,y;\n\tchar map[15][15];\n\tint dp[15][15];\n\tint ans;\n\t\n\twhile(cin>>w>>h,w!=0){\n\t\tfor(y=0;y<h;y++){\n\t\tfor(x=0;x<w;x++){\n\t\t\tcin>>map[x][y];\n\t\t\tdp[x][y]=0;\n\t\t}\n\t\t}\n\n\t\tfor(x=0;x<w;x++) if(map[x][0]!='1') dp[x][0]=1;\n\n\t\tfor(y=0;y<h-1;y++){\n\t\tfor(x=0;x<w;x++){\n\t\t\tif(map[x][y]=='0'){\n\t\t\t\tif(map[x][y+1]!='1') dp[x][y+1]+=dp[x][y];\n\t\t\t\tif(0<x && map[x-1][y+1]=='0') dp[x-1][y+1]+=dp[x][y];\n\t\t\t\tif(x<w-1 && map[x+1][y+1]=='0') dp[x+1][y+1]+=dp[x][y];\n\t\t\t}else if(map[x][y]=='2'){\n\t\t\t\tif(y<h-2 && map[x][y+2]!='1') dp[x][y+2]+=dp[x][y];\n\t\t\t}\n\t\t}\n\t\t}\n\t\t\n\t\tans=0;for(x=0;x<w;x++){\n\t\t\tif(map[x][h-2]=='2') ans+=dp[x][h-2];\n\t\t\tans+=dp[x][h-1];\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nint main()\n{\n\tfor(;;){\n\t\tint x, y;\n\t\tint map[100][100];\n\t\tint dp[100][100];\n\t\t\n\t\tcin >> x;\n\t\tcin >> y;\n\t\tif(x == 0 && y == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < y; i++){\n\t\t\tfor(int j = 0; j < x; j++){\n\t\t\t\tcin >> map[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\t//ツ鳴催渉可づ可暗ェツ氾板湘」ツづ個療アツづ個づつィツづィツ青板づーツ個按津ィ\n\t\t//0:ツ暗堋督ョツ嘉つ能\n\t\t//1:ツ湘。ツ害ツ閉ィ\n\t\t//2:ツジツδδδ督プツ妥、\n\t\t\n\t\tfor(int i = 0; i < x; i++){\n\t\t\tif(map[0][i] == 0){\n\t\t\t\tdp[0][i] = 1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdp[0][i] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1; i < y; i++){\n\t\t\tfor(int j = 0; j < x; j++){\n\t\t\t\t//ツ配ツ療アツ外ツアツクツセツスツづーツづ「ツづ淞づヲツつ、\n\t\t\t\tif(j == 0){\n\t\t\t\t\tif(map[i][j] == 1){\n\t\t\t\t\t\tdp[i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse if(map[i][j] == 0){\n\t\t\t\t\t\tif(map[i-1][j] == 2 ||map[i-1][j+1] == 2){\n\t\t\t\t\t\t\tif(map[i-1][j] == 2 || map[i-1][j-1] == 2 || map[i-1][j+1] == 2){\n\t\t\t\t\t\t\t\tif(map[i-1][j] == 2){\n\t\t\t\t\t\t\t\t\tdp[i][j] = dp[i-1][j+1];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(map[i-1][j+1] == 2){\n\t\t\t\t\t\t\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(map[i-1][j] == 2 && map[i-1][j+1] == 2){\n\t\t\t\t\t\t\t\t\tdp[i][j] = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tdp[i][j] = dp[i-1][j] + dp[i-1][j+1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(map[i-2][j] == 2){\n\t\t\t\t\t\t\tdp[i][j] += dp[i-2][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t} \n\t\t\t\t\telse if(map[i][j] == 2){\n\t\t\t\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//ツつサツづェツ暗按外\n\t\t\t\telse{\n\t\t\t\t\tif(map[i][j] == 0){\n\t\t\t\t\t\tif(map[i-1][j] == 2 || map[i-1][j-1] == 2 || map[i-1][j+1] == 2){\n\t\t\t\t\t\t\tif(map[i-1][j] == 2){\n\t\t\t\t\t\t\t\tdp[i][j] = dp[i-1][j+1] + dp[i-1][j-1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(map[i-1][j-1] == 2){\n\t\t\t\t\t\t\t\tdp[i][j] = dp[i-1][j] + dp[i-1][j+1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(map[i-1][j+1] == 2){\n\t\t\t\t\t\t\t\tdp[i][j] = dp[i-1][j] + dp[i-1][j-1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(map[i-1][j] == 2 && map[i-1][j+1] == 2){\n\t\t\t\t\t\t\t\tdp[i][j] = dp[i-1][j-1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(map[i-1][j] == 2 && map[i-1][j-1] == 2){\n\t\t\t\t\t\t\t\tdp[i][j] = dp[i-1][j+1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(map[i-1][j+1] == 2 && map[i-1][j-1] == 2){\n\t\t\t\t\t\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(map[i-1][j+1] == 2 && map[i-1][j] == 2 && map[i-1][j-1] == 2){\n\t\t\t\t\t\t\t\tdp[i][j] = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tdp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j+1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(map[i-2][j] == 2){\n\t\t\t\t\t\t\tdp[i][j] += dp[i-2][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(map[i][j] == 1){\n\t\t\t\t\t\tdp[i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse if(map[i][j] == 2){\n\t\t\t\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\t\t\t\tif(map[i-2][j] == 2){\n\t\t\t\t\t\t\tdp[i][j] += dp[i-2][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\t\n\t\tfor(int i = 0; i < x; i++){\n\t\t\tans += dp[y-1][i];\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < x; i++){\n\t\t\tif(map[y-2][i] == 2){\n\t\t\t\tans+= dp[y-2][i];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\nint main(){\n\tint x,y;\n\twhile(cin >> x >> y, x|y){\n\t\tvvi field(y,vi(x));\n\t\tREP(i,y){\n\t\t\tREP(j,x){\n\t\t\t\tcin >> field[i][j];\n\t\t\t}\n\t\t}\n\t\tvvi dp(y,vi(x,0));\n\t\tREP(i,y){\n\t\t\tREP(j,x){\n\t\t\t\tif(i==0&&field[i][j]==0){\n\t\t\t\t\tdp[i][j]=1;\n\t\t\t\t}\n\t\t\t\tif(i<y-1&&field[i][j]==0){\n\t\t\t\t\tif(j>0&&field[i+1][j-1]==0){\n\t\t\t\t\t\tdp[i+1][j-1]+=dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tif(j<x-1&&field[i+1][j+1]==0){\n\t\t\t\t\t\tdp[i+1][j+1]+=dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tif(field[i+1][j]!=1){\n\t\t\t\t\t\tdp[i+1][j]+=dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(i<y-2&&field[i][j]==2){\n\t\t\t\t\tif(field[i+2][j]!=1){\n\t\t\t\t\t\tdp[i+2][j]+=dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint result=0;\n\t\tREP(i,x){\n\t\t\tresult+=dp[y-1][i];\n\t\t\tif(field[y-2][i]==2){\n\t\t\t\tresult+=dp[y-2][i];\n\t\t\t}\n\t\t}\n\t\tcout << result << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1; } return 0; }\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, pll> pip;\nconst ll INF = 1ll<<29;\nconst ll MOD = 1000000007;\nconst double EPS  = 1e-9;\n\nint H, W;\nint maps[15][15];\nll dp[15][15];\n\nint dx[3] = {1,0,-1}, dy[3] = {1,1,1};\n\nint main() {\n\twhile (cin >> W >> H, H || W) {\n\t\tREP(i, H) REP(j, W) scanf(\"%d\", &maps[i][j]);\n\t\t\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tREP(j, W) dp[0][j] = maps[0][j] != 1;\n\t\t\n\t\tREP(i, H) REP(j, W) if (dp[i][j]) {\n\t\t\t\n\t\t\tif (maps[i][j] == 2) { // jump\n\t\t\t\tif (i + 2 < H && maps[i + 2][j] == 1) continue;\n\t\t\t\tdp[min(i + 2, H - 1)][j] += dp[i][j];\n\t\t\t}\n\t\t\telse { // normal\n\t\t\t\tREP(k, 3) {\n\t\t\t\t\tint yy = i + dy[k], xx = j + dx[k];\n\t\t\t\t\tif (!(yy >= 0 && yy < H && xx >= 0 && xx < W)) continue;\n\t\t\t\t\tif (maps[yy][xx] == 1 || (k != 1 && maps[yy][xx] == 2)) continue;\n\t\t\t\t\tdp[yy][xx] += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tll ans = 0;\n\t\tREP(j, W) ans += dp[H - 1][j];\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\nint a[16][16];\nint count = 0;\nint n,m;\n\nvoid dfs(int y,int x)\n{\n\tcout << \"y:\" << y << \" x:\" << x << endl;\n\tif(a[y][x] == 0)\n\t{\n\t\tif(y == m-1)\n\t\t{\n\t\t\tcount++;\n\t\t\treturn;\n\t\t}\n\t\tif(x-1 >= 0 && y+1 < m)\n\t\t{\n\t\t\tif(a[y+1][x-1] != 2)\n\t\t\t{\n\t\t\t\tdfs(y+1,x-1);\n\t\t\t}\n\t\t}\n\t\tif(y+1 < m)\n\t\t{\n\t\t\tdfs(y+1,x);\n\t\t}\n\t\tif(x+1 < n && y+1 < m)\n\t\t{\n\t\t\tif(a[y+1][x+1] != 2)\n\t\t\t{\n\t\t\t\tdfs(y+1,x+1);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\telse if(a[y][x] == 1)\n\t{\n\t\treturn;\n\t}\n\telse if(a[y][x] == 2)\n\t{\n\t\tif(y == m-2 || y == m-1)\n\t\t{\n\t\t\tcount++;\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdfs(y+2,x);\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile(cin >> n >> m)\n\t{\n\t\tif(n == 0 && m == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tmemset(a,0,sizeof(a));\n\t\trep(i,n)\n\t\t{\n\t\t\trep(j,m)\n\t\t\t{\n\t\t\t\tcin >> a[i][j];\n\t\t\t}\n\t\t}\n\t\tcount = 0;\n\t\trep(i,m) dfs(0,i);\n\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint w,h;\nint map[16][16];\nint dp[16][16][4][2];\n\nint rec(int x,int y,int state,bool str){\n    if(state == 1 || x < 0 || x >= w) return 0;\n    if(state == 2 && !str) return 0;\n    if(y >= h-1) return 1;\n    if(dp[y][x][state][str] != -1) return dp[y][x][state][str];\n    int res;\n    if(state == 2) res = rec(x,y+2,map[y+2][x],true);\n    else res = (rec(x-1,y+1,map[y+1][x-1],false) + rec(x,y+1,map[y+1][x],true) + rec(x+1,y+1,map[y+1][x+1],false));\n    return dp[y][x][state][str] = res;\n}\n\nint main(){\n    while(cin >> w >> h,w||h){\n        memset(dp,-1,sizeof(dp));\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++) cin >> map[i][j];\n        }\n        int d = 0;\n        for(int i=0;i<w;i++) d += rec(i,0,map[0][i],true);\n        cout << d << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\nusing namespace std;\n\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint W, H;\n\twhile(cin >> W >> H, W) {\n\t\tint b[15][20] = { 0 };\n\t\tfor(int i = 0; i < H; i++) {\n\t\t\tfor(int j = 0; j < W; j++) {\n\t\t\t\tcin >> b[i][j];\n\t\t\t}\n\t\t}\n\n\t\tint dp[15][20] = { 0 };\n\t\tfor(int i = 0; i < W; i++) {\n\t\t\tif(b[0][i] != 1)\n\t\t\t\tdp[0][i] = 1;\n\t\t}\n\n\t\tfor(int i = 0; i < H - 1; i++) {\n\t\t\tfor(int j = 0; j < W; j++) {\n\t\t\t\tif(b[i][j] == 0) {\n\t\t\t\t\tfor(int d = -1; d <= 1; d++) {\n\t\t\t\t\t\tif(j + d < 0 || W <= j + d) continue;\n\t\t\t\t\t\tif(b[i + 1][j + d] == 0 || b[i + 1][j + d] == 2 && d == 0)\n\t\t\t\t\t\t\tdp[i + 1][j + d] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(b[i][j] == 2) {\n\t\t\t\t\tdp[i + 2][j] += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor(int i = H - 1; i <= H; i++) {\n\t\t\tfor(int j = 0; j < W; j++) {\n\t\t\t\tif(b[i][j] != 1)\n\t\t\t\t\tans += dp[i][j];\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#define N 15\nusing namespace std;\nvoid func(int,int);\nint jump(int,int);\nint X,Y,data[N][N],memo[N+2][N];\nint main(){\n  while(1){\n    cin >> X >> Y;\n    if(X==0&&Y==0) break;\n    for(int i=0;i<Y+2;i++)\n      for(int j=0;j<X;j++) data[i][j]=0,memo[i][j]=0;\n    for(int i=0;i<Y;i++)\n      for(int j=0;j<X;j++) cin >> data[i][j];\n    for(int i=0;i<X;i++)\n      if(data[0][i]!=1)\tfunc(0,i);\n    int cnt=0;\n    for(int i=0;i<X;i++) cnt+=memo[0][i];\n    cout << cnt << endl;\n  }\n  return 0;\n}\nvoid func(int y,int x){\n  if(y>=Y-1){\n    memo[Y+1][x]=memo[Y][x]=memo[Y-1][x]=1;\n    return ;\n  }\n  if(0<=x-1&&data[y+1][x-1]==0){\n    if(memo[y+1][x-1]==0) func(y+1,x-1);\n    memo[y][x]+=memo[y+1][x-1];\n  }\n  if(x+1<X&&data[y+1][x+1]==0){\n    if(memo[y+1][x+1]==0) func(y+1,x+1);\n    memo[y][x]+=memo[y+1][x+1];\n  }\n  if(data[y+1][x]==0){\n    if(memo[y+1][x]==0) func(y+1,x);\n    memo[y][x]+=memo[y+1][x];\n  }\n  if(data[y+1][x]==2){\n    int r=jump(y+1,x);\n    if(r!=-1){\n      if(memo[r][x]==0) func(r,x);\n      memo[y][x]+=memo[r][x];\n    }else data[y+1][x]=1;\n  }\n  if(memo[y][x]==0) data[y][x]=1;\n}\nint jump(int y,int x){\n  while(1){\n    y+=2;\n    if(data[y][x]==1) break;\n    if(data[y][x]==0||y>=Y-1) return y;\n  }\n  return -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) (r).begin(),(r).end()\n#define gsort(st,en) sort((st),(en),greater<int>())\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing dict = map<string,int>;\nusing pii = pair<int,int> ;\n\nconst int mod = 1000000007;\nconstexpr int imax = ((1<<30)-1)*2+1 ;\nconstexpr int inf = 100000000;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {1,1,1,1};\nconst int dx[] = {-1,0,1,0};\n\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\n\ntemplate<typename T>\nvoid Unique(vector<T> &v){\n  sort(all(v));\n  v.erase(unique(all(v)),v.end());\n}\n\ntemplate<typename T>\nT ston(string& str, T n){\n  istringstream sin(str) ;\n  T num ;\n  sin >> num ;\n  return num ;\n}\n\nvoid Ans(bool f){\n  if(f) cout << \"YES\"<<endl;\n  else cout << \"NO\"<<endl;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int x,y;\n  while(cin >> x >> y&&x&&y){\n    vector<vector<ll>> grid(x+1,vector<ll>(y+1,0));\n    vector<vector<ll>> dp(x+3,vector<ll>(y+3,0));\n    rep(i,y){\n      rep(j,x){\n        cin >> grid[j][i];\n      }\n    }\n    rep(i,x){\n      dp[i][0] = grid[i][0] == 0;\n    }\n    rep(i,y){\n      rep(j,x){\n        if(grid[j][i] == 0){\n          rep(k,3){\n            int nx = j+dx[k],ny = i+dy[k];\n            if(value(j+dx[k],i+dy[k],x,y)){\n              if(grid[nx][ny] == 0){\n                dp[nx][ny] += dp[j][i];\n              }\n              else if(grid[nx][ny] == 2 && k == 1){\n                dp[nx][ny] += dp[j][i];\n              }\n            }\n          }\n        }\n        else if(grid[j][i] == 2){\n          dp[j][i+2] += dp[j][i];\n        }\n      }\n    }\n    ll ans = 0;\n    rep(i,x){\n      ans += dp[i][y]+dp[i][y-1];\n    }\n//     cout << endl;\n//     rep(j,y+1){\n//       rep(i,x){\n// //         ans += dp[i][y];\n//         cout << dp[i][j]<< \" \";\n//       }\n//       cout << endl;\n//     }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint field[20][20];\nint dp[20][20];\n\nint n, m;\n\nbool isIn(int x, int y){\n    return 0 <= x && x < n && 0 <= y && y < m;\n}\n\nint main(){\n    while(cin >> m >> n, n+m){\n        for(int i=0; i < n; i++) for(int j=0; j< m; j++){cin >> field[i][j];}\n        for(int i=0; i< 20; i++) for(int j=0; j< 20; j++) dp[i][j] = 0;\n        for(int i=0; i < m; i++) dp[0][i] = 1;\n        for(int i=0; i < n-1; i++){\n            for(int j=0; j < m; j++){\n                if(field[i][j] == 0){\n                    for(int k=-1; k <= 1; k++){\n                        if(isIn(i+1, j+k) && !(k != 0 && field[i+1][j+k] == 2)){\n                            dp[i+1][j+k] += dp[i][j];\n                        }\n                    }\n                }\n                else if(field[i][j] == 2) dp[i+2][j] += dp[i][j];\n            }\n        }\n        for(int i=0; i< m; i++) if(field[n-1][i] != 1)dp[n][i] += dp[n-1][i];\n        long long count = 0;\n        for(int i=0; i< m; i++) count += dp[n][i];\n        cout << count << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint dp[18][18];\nint kosu[16][16];\nint ans;\n\nint main(){\n  int x,y;\n  \n  while(1){\n    cin>>x>>y;\n    if(x==0 && y==0) break;\n    \n    fill(dp[0],dp[18],0);\n    ans=0;\n    \n    for(int i=0;i<y;i++){\n      for(int l=0;l<x;l++){\n        cin>>kosu[i][l];\n      }\n    }\n    for(int i=0;i<x;i++)\n      if(kosu[0][i]==0) dp[0][i]=1;\n    \n    for(int i=1;i<y;i++){\n      for(int l=0;l<x;l++){\n        \n        if(kosu[i][l]==2){\n          dp[i+2][l]+=dp[i-1][l]+dp[i][l];\n          dp[i][l]=0;\n        }\n        else if(kosu[i][l]==0)\n          dp[i][l]+=dp[i-1][l-1]+dp[i-1][l]+dp[i-1][l+1];\n      }\n    }\n    for(int i=y-1;i<y+2;i++){\n      for(int l=0;l<x;l++){\n        ans+=dp[i][l];\n      }\n    }\n    \n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint main(){\n   int x,y;\n   while(cin>>x>>y,x||y){\n        int field[50][50];\n        for(int i=1;i<=y;i++)\n            for(int j=1;j<=x;j++)\n                cin>>field[i][j];\n\n        int dp[50][50]={{0}};\n        for(int i=1;i<=x;i++)dp[1][i]=1;\n        for(int i=1;i<=y;i++){\n            for(int j=1;j<=x;j++){\n                if(field[i][j]==1){\n                    dp[i][j]=0;\n                    continue;\n                }\n                if(i==y)continue;\n                if(field[i][j]==2){\n                    int to=i+2;\n                    dp[to][j]+=dp[i][j];\n                    continue;\n                }\n                if(field[i+1][j+1]!=2)dp[i+1][j+1]+=dp[i][j];\n                if(field[i+1][j-1]!=2)dp[i+1][j-1]+=dp[i][j];\n                dp[i+1][j]+=dp[i][j];\n            }\n        }\n        int sum=0;\n        for(int i=1;i<=x;i++)sum+=dp[y][i]+dp[y+1][i];\n        cout<<sum<<endl;\n\n   }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define N 15\nusing namespace std;\nvoid func(int,int);\nint jump(int,int);\nint X,Y,data[N][N],memo[N][N];\nint main(){\n  while(1){\n    cin >> X >> Y;\n    if(X==0&&Y==0) break;\n    for(int i=0;i<Y;i++)\n      for(int j=0;j<X;j++) cin >> data[i][j],memo[i][j]=0;\n    for(int i=0;i<X;i++)\n      if(data[0][i]==0) func(0,i);\n    int cnt=0;\n    for(int i=0;i<X;i++) cnt+=memo[0][i];\n    cout << cnt << endl;\n  }\n  return 0;\n}\nvoid func(int y,int x){\n  if(y==Y-1){\n    memo[Y-1][x]=1;\n    return ;\n  }\n  if(0<=x-1&&data[y+1][x-1]==0){\n    if(memo[y+1][x-1]==0) func(y+1,x-1);\n    memo[y][x]+=memo[y+1][x-1];\n  }\n  if(x+1<X&&data[y+1][x+1]==0){\n    if(memo[y+1][x+1]==0) func(y+1,x+1);\n    memo[y][x]+=memo[y+1][x+1];\n  }\n  if(data[y+1][x]==0){\n    if(memo[y+1][x]==0) func(y+1,x);\n    memo[y][x]+=memo[y+1][x];\n  }\n  if(data[y+1][x]==2){\n    int r=jump(y+1,x);\n    if(r==-2) memo[y][x]+=1;\n    else if(r!=-1){\n      if(memo[r][x]==0) func(r,x);\n      memo[y][x]+=memo[r][x];\n    }\n  }\n  if(memo[y][x]==0) data[y][x]=1;\n}\nint jump(int y,int x){\n  while(1){\n    y+=2;\n    if(y<=Y-1&&data[y][x]==1) break;\n    if(y>=Y-1) return -2;\n    if(data[y][x]==0) return y;\n  }\n  return -1;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\n\nusing namespace std;\n\n\n\tint n,m;\n\tint masu[17][17];\n\tint ura[17][17];\n\t\nint motom(){\n\t\tfor(int i=0;i<17;i++){\n\t\t\tfor(int j=0;j<17;j++){\n\t\t\t\tmasu[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tswitch(ura[1][i]){\n\t\t\t\tcase 0:masu[1][i]+=1;break;\n\t\t\t\tcase 1:masu[1][i]+=0;break;\n\t\t\t\tcase 2:masu[1][i]+=1;break;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfor(int j=1;j<=m;j++){\n\t\t\t\tif(ura[i][j]==0){\n\t\t\t\t\tif(ura[i+1][j-1]==0){\n\t\t\t\t\t\tmasu[i+1][j-1]+=masu[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tif(ura[i+1][j]!=1){\n\t\t\t\t\t\tmasu[i+1][j]+=masu[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tif(ura[i+1][j+1]==0){\n\t\t\t\t\t\tmasu[i+1][j+1]+=masu[i][j];\n\t\t\t\t\t}\n\t\t\t\t}else if(ura[i][j]==2){\n\t\t\t\t\tif(ura[i+2][j]!=1){\n\t\t\t\t\t\tmasu[i+2][j]+=masu[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cont=0;\n\t\tfor(int i=n;i<=n+1;i++){\n\t\t\tfor(int j=1;j<=m;j++){\n\t\t\t\tcont+=masu[i][j];\n\t\t\t}\n\t\t}\n\t\treturn cont;\n}\nint contt;\nvoid saiki(int x,int y){\n\tif(y<1||y>m){\n\t\treturn;\n\t}\n\t\n\t\tmasu[x][y]++;\n\tif(x>n-1){\n\t\tcontt++;\n\t\treturn;\n\t}\n\tif(ura[x][y]==0){\n\t\tif(ura[x+1][y-1]==0){\n\t\t\tsaiki(x+1,y-1);\n\t\t}\n\t\tif(ura[x+1][y]!=1){\n\t\t\tsaiki(x+1,y);\n\t\t}\n\t\tif(ura[x+1][y+1]==0){\n\t\t\tsaiki(x+1,y+1);\n\t\t}\n\t}\n\tif(ura[x][y]==2){\n\t\tif(ura[x+2][y]!=1){\n\t\t\tsaiki(x+2,y);\n\t\t}\n\t}\n}\nint simu(){\n\t\tfor(int i=0;i<17;i++){\n\t\t\tfor(int j=0;j<17;j++){\n\t\t\t\tmasu[i][j]=0;\n\t\t\t}\n\t\t}\n\tcontt=0;\n\tfor(int i=1;i<=m;i++){\n\t\tif(ura[1][i]!=1){\n\t\t\tsaiki(1,i);\n\t\t}\n\t}\n\t/*\n\tputs(\"\");\n\tfor(int i=1;i<=n+1;i++){\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tprintf(\"%d \",masu[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}*/\n\treturn contt;\n}\n\nint main(){\n\tsrand(time(NULL));\n\tint cc=0;\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0 && m==0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i=0;i<17;i++){\n\t\t\tfor(int j=0;j<17;j++){\n\t\t\t\tmasu[i][j]=0;\n\t\t\t\tura[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=1;j<=m;j++){\n\t\t\t\tscanf(\"%d\",&ura[i][j]);\n\t\t\t}\n\t\t}\n\t\tint aa=motom();\n\t\t\n\t\tprintf(\"%d\\n\",aa);\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint w,h;\nint mp[20][20];\nint memo[20][20];\nint ans;\nint count;\n\nint saiki(int x,int y) {\n  count++;\n  // cout << x <<\" \"<<y <<endl;\n  int dx[3] = {-1,0,1};\n  int dy[3] = {1,1,1};\n  \n  if((y >= h-1 && mp[y][x] != 1)) ans++,memo[y][x]++;//,cout <<\"ok\"<<endl;  \n  else if(mp[y][x] != 1) {\n    for(int i=0;i<3;i++) {\n      int nx = dx[i]+x;\n      int ny = dy[i]+y;\n      if(nx <0|| nx >= w || memo[ny][nx] == -1) continue;\n      \n      if(memo[ny][nx] > 0) {\n\tans+= memo[ny][nx];\n\tmemo[y][x] += memo[ny][nx];\n      }  \n      else if(mp[ny][nx] == 0){\n\tsaiki(nx,ny);\n\tif(memo[ny][nx] > 0) memo[y][x] += memo[ny][nx];\n      } \n      else if(nx==x && mp[ny][nx] == 2){\n\tint ty = ny;\n\twhile(mp[ty][nx] == 2) ty+=2;\n\tsaiki(nx,ty);\n\tif(memo[ty][nx] > 0) memo[y][x] += memo[ty][nx];\n      } \n    }\n    if(memo[y][x] == 0) memo[y][x] = -1;\n  }\n}\n\n\nint main() {\n\n  while(1) {\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n\n    for(int i=0;i<=19;i++) \n      for(int j=0;j<=19;j++){ \n\tmemo[i][j] = 0;\n\tmp[i][j] = 0;\n      }\n    \n    for(int i=0;i<h;i++) \n      for(int j=0;j<w;j++) \n\tcin >> mp[i][j];\n\n    /*\n      for(int i=0;i<h;i++) {\n      for(int j=0;j<w;j++) \n      cout << mp[i][j];\n      cout << endl;\n      }\n    */\n\n    ans = 0;\n    count = 0;\n    for(int i=0;i<w;i++) {\n      if(mp[0][i] !=1) saiki(i,0);\n    }\n\n    int ans2 = 0;\n    for(int i=0;i<w;i++) \n      if(memo[0][i] > 0) ans2+=memo[0][i];\n\n    cout << ans << endl;\n    //    cout << ans2 << endl;\n    //cout << count << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstdio>\n#include<string.h>\n#include<cstring>\n#include<algorithm>\n#include<functional>\n#include<math.h>\n#include<queue>\n#include<ctype.h>\n#define MAX  1000000000\n#define MIN -1000000000\nusing namespace std;\nint i,j;\nint x,y;\nlong long int dp[1000][1000];\nint map[1000][1000];\nint main(void){\n\tscanf(\"%d %d\",&x,&y);\n\twhile(x!=0 && y!=0){\n\t\tfor(i=1;i<=17;i++){\n\t\t\tfor(j=1;j<=15;j++){\n\t\t\t\tdp[i][j]=0;\n\t\t\t\tmap[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=y;i++){\n\t\t\tfor(j=1;j<=x;j++){\n\t\t\t\tscanf(\"%d \",&map[i][j]);\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=x;i++){\n\t\t\tif(map[1][i]!=1){\n\t\t\t\tdp[1][i]=1;\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<y;i++){\n\t\t\tfor(j=1;j<=x;j++){\n\t\t\t\tif(dp[i][j]>0 && map[i][j]!=2){\n\t\t\t\t\tif(map[i+1][j-1]==0){\n\t\t\t\t\t\tif(j-1<0);\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tdp[i+1][j-1]+=dp[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(map[i+1][j]!=1 ){\n\t\t\t\t\t\tif(map[i+1][j]==0){\n\t\t\t\t\t\t\tdp[i+1][j]+=dp[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tint temp;\n\t\t\t\t\t\t\ttemp=i+1;\n\t\t\t\t\t\t\twhile(map[temp][j]==2){\n\t\t\t\t\t\t\t\ttemp+=2;\n\t\t\t\t\t\t\t\tdp[temp][j]+=dp[i][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(map[i+1][j+1]==0){\n\t\t\t\t\t\tif(j+1>x);\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tdp[i+1][j+1]+=dp[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*for(i=1;i<=y+1;i++){\n\t\t\tprintf(\"%d=\",i);\n\t\t\tfor(j=1;j<=x;j++){\n\t\t\t\tprintf(\"%d \",dp[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\tint cnt=0;\n\t\tfor(i=0;i<=2;i++){\n\t\t\tfor(j=1;j<=x;j++){\n\t\t\t\tcnt+=dp[y+i][j];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",cnt);\n\t\tscanf(\"%d %d\",&x,&y);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n\nusing namespace std;\n\nint main(){\n  int x, y, course[50][50], route[52][52], i, j, sum;\n  while(cin >> x >> y, x+y){\n    sum = 0;\n    for(i=0; i<52; i++){\n      for(j=0; j<52; j++){\n        route[i][j] = 0;\n      }\n    }\n    for(i=0; i<y; i++){\n      for(j=0; j<x; j++){\n        cin >> course[i][j];\n      }\n    }\n    for(i=0; i<y; i++){\n      for(j=0; j<x; j++){\n\tif(i==0){\n          if(course[i][j]==0){\n            route[i][j] = 1;\n          }else{\n\t    route[i][j] = 0;\n          }\n        }else{\n          if(j==0){\n            if(course[i][j]==0){\n              if(course[i-1][j]==0){\n                route[i][j] += route[i-1][j];\n              }\n              if(course[i-1][j+1]==0){\n                route[i][j] += route[i-1][j+1];\n              }\n\t    }else if(course[i][j]==1){\n              route[i][j] = 0;\n            }else{\n              if(course[i-1][j]==0){\n\t        route[i][j] = route[i-1][j];\n                route[i+2][j] += route[i][j];\n              }\n            }\n          }else if(j==x-1){\n            if(course[i][j]==0){\n              if(course[i-1][j]==0){\n                route[i][j] += route[i-1][j];\n              }\n              if(course[i-1][j-1]==0){\n                route[i][j] += route[i-1][j-1];\n              }\n\t    }else if(course[i][j]==1){\n              route[i][j] = 0;\n            }else{\n              if(course[i-1][j]==0){\n\t        route[i][j] = route[i-1][j];\n                route[i+2][j] += route[i][j];\n              }\n            }\n          }else{\n            if(course[i][j]==0){\n              if(course[i-1][j]==0){\n                route[i][j] += route[i-1][j];\n              }\n              if(course[i-1][j-1]==0){\n                route[i][j] += route[i-1][j-1];\n              }\n              if(course[i-1][j+1]==0){\n                route[i][j] += route[i-1][j+1];\n              }\n\t    }else if(course[i][j]==1){\n              route[i][j] = 0;\n            }else{\n              if(course[i-1][j]==0){\n                route[i][j] = route[i-1][j];\n                route[i+2][j] += route[i][j];\n              }\n              if(course[i-2][j]==2){\n                route[i][j] = route[i-2][j];\n                route[i+2][j] += route[i][j];\n              }\n            }\n          }\n        }\n      }\n    }\n    for(i=0; i<x; i++){\n      if(course[y-1][i]==0){\n\troute[y][i] += route[y-1][i];\n      }\n    }\n\n    for(i=y; i<y+2; i++){\n      for(j=0; j<x; j++){\n        sum+=route[i][j];\n      }\n    }\n    cout << sum << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<math.h>\nint main(void)\n{\n\tint a,s,d[20][20],f,j,i,k;\n\tlong long int g,h[20][20];\n\twhile(1){\n\t\tscanf(\"%d %d\",&a,&s);\n\t\tif(a==0&&s==0) break;\n\t\tfor(i=0;i<s;i++) h[0][i]=1;\n\t\tfor(i=0;i<a;i++){\n\t\t\tfor(j=0;j<s;j++) scanf(\"%d\",&d[i][j]);\n\t\t}\n\t\tfor(i=0;i<s;i++){\n\t\t\tif(d[0][i]==1) h[0][i]=0;\n\t\t}\n\t\tfor(i=1;i<a;i++){\n\t\t\tfor(j=0;j<s;j++) h[i][j]=0;\n\t\t}\n\t\tfor(i=0;i<a;i++){\n\t\t\tfor(j=0;j<s;j++){\n\t\t\t\tif(i!=0&&d[i][j]==2){\n\t\t\t\t\tif(i+2<a) h[i+2][j]+=h[i][j];\n\t\t\t\t\telse h[i+1][j]+=h[i][j];\n\t\t\t\t}\n\t\t\t\tif(d[i][j]==0){\n\t\t\t\t\tif(j!=0) if(d[i+1][j-1]==0) h[i+1][j-1]+=h[i][j];\n\t\t\t\t\tif(j!=s){\n\t\t\t\t\t\tif(d[i+1][j+1]==0) h[i+1][j+1]+=h[i][j];\n\t\t\t\t\t\tif(d[i+1][j]==0||d[i+1][j]==2) h[i+1][j]+=h[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tg=0;\n\t\tfor(j=0;j<s;j++) g+=h[a-1][j];\n\t\t/*printf(\"\\n\\n\");\n\t\tfor(i=0;i<a;i++){\n\t\t\tfor(j=0;j<s;j++) printf(\"%d \",h[i][j]);\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\tprintf(\"%d\\n\",g);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main()\n{\n\tint n, m;\n\twhile (true){\n\t\tcin >> n >> m;\n\t\tif (n == 0 && m == 0){\n\t\t\tbreak;\n\t\t}\n\t\tint map[100][100] = { 0 };\n\t\tint dp[100][100] = { 0 };\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tfor (int i2 = 0; i2 < n; i2++){\n\t\t\t\tcin >> map[i][i2];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tif (map[0][i] == 0){\n\t\t\t\tdp[0][i] = 1;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tfor (int i2 = 0; i2 < n; i2++){\n\t\t\t\tif (map[i][i2] == 0){\n\t\t\t\t\tfor (int i3 = -1; i3 <= 1; i3++){\n\t\t\t\t\t\tif (i2 + i3 >= 0 && i2 + i3 < n && (map[i + 1][i2 + i3] == 0 || i3 == 0 && map[i + 1][i2 + i3] == 2)&&(i<m-1||i3==0)){\n\t\t\t\t\t\t\tdp[i + 1][i2+i3]  += dp[i][i2];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t\telse if (map[i][i2] == 2){\n\t\t\t\t\t\t\tdp[i + 2][i2] += dp[i][i2];\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tans += dp[m][i];\n\t\t\tans += dp[m+1][i];\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<cstring>\n#include<string>\nusing namespace std;\nint X,Y;\nint fie[20][20];\nint dp[20][20];\nint dx[]={-1,0,1};\nint solve(int x,int y){\n  if(dp[x][y]!=-1) return dp[x][y];\n  if(y>=Y-1) return dp[x][y]=1;\n  if(fie[x][y]==2){\n    if(fie[x][y+2]!=1)\n      return dp[x][y]=solve(x,y+2);\n    return dp[x][y]=0;\n  }\n  int ret=0;\n  for(int i=0;i<3;i++){\n    int nx=x+dx[i];\n    if(nx < 0 || nx >= X) continue;\n    if(fie[nx][y+1]==1) continue;\t \n    if(i==1){\n      ret += solve(nx,y+1);\n    }else{\n      if(fie[nx][y+1]==2) continue;\n      ret += solve(nx,y+1);\n    }\n  }\n  return dp[x][y]=ret;\n}\nmain(){\n  while(1){\n    cin >> X >> Y;\n    if(X==0 && Y==0) break;\n    memset(fie,0,sizeof(fie));\n    for(int i=0;i<Y;i++)\n      for(int j=0;j<X;j++) cin >> fie[j][i];\n    memset(dp,-1,sizeof(dp));\n    int res=0;\n    for(int i=0;i<X;i++){\n      if(fie[i][0]==0)\n\tres += solve(i,0);\n    }\n    cout << res << endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,a,n) for(int i=a;i<n;i++)\n#define repb(i,a,b) for(int i=a;i>=b;i--)\n#define all(a) a.begin(),a.end()\n#define o(a) cout<<a<<endl\n#define int long long\n#define fi first\n#define se second\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n\n\nsigned main() {\n\tint y, x;\n\twhile (1) {\n\t\tcin >> y >> x;\n\t\tif (y + x == 0) break;\n\t\tint d[20][20] = { 0 };\n\t\trep(i, 0, y) {\n\t\t\trep(j, 0, x) {\n\t\t\t\tcin >> d[i][j];\n\t\t\t}\n\t\t}\n\t\tint dp[20][20] = { 0 };\n\t\trep(i, 0, x) {\n\t\t\tif (d[0][i] == 0) dp[0][i] = 1;\n\t\t}\n\t\trep(i, 0, y) {\n\t\t\trep(j, 0, x) {\n\t\t\t\tif (d[i][j] == 1) continue;\n\t\t\t\tif (d[i][j] == 2 && d[i + 2][j] != 1) {\n\t\t\t\t\tdp[i + 2][j] += dp[i][j];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\trep(k, -1, 2) {\n\t\t\t\t\tif (j + k < 0 || j + k >= x || d[i + 1][j + k] != 0) continue;\n\t\t\t\t\tdp[i + 1][j + k] += dp[i][j];\n\t\t\t\t}\n\t\t\t\tif (d[i + 1][j] == 2) {\n\t\t\t\t\tdp[i + 1][j] += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*cout << endl;\n\t\trep(i, 0, y + 2) {\n\t\t\trep(j, 0, x) {\n\t\t\t\tcout << dp[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t\tint ans = 0;\n\t\trep(i, 0, x) {\n\t\t\tans += dp[y - 1][i];\n\t\t\tif (d[y - 2][i] == 2) {\n\t\t\t\tans += dp[y - 2][i];\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<queue>\n\n#define N 15\n\nusing namespace std;\n\n\nint map[N][N];\nint paturn[N][N];\nqueue<int> que;\n\nvoid printarray(int X,int Y){\n  for(int i=0;i<Y;i++){\n    for(int j=0;j<X;j++){\n      cout << map[i][j];\n    }\n    cout << endl;\n  }\n  return;\n}\n\n\nlong long int bfs(int X,int Y){\n  int cost[N][N];\n  long long int cnt=0;\n  int dx[3]={-1,0,1};\n  int nx;\n\n  for(int i=0;i<Y;i++){//初期化\n    for(int j=0;j<X;j++){\n      cost[i][j]=0;\n    }\n  }\n  for(int i=0;i<Y;i++){//コスト初期値設定\n    for(int j=0;j<X;j++){\n      if(map[0][j]==0){\n        cost[0][j]=1;\n      }\n    }\n  }\n\n\n  for(int i=1;i<Y;i++){\n    for(int j=0;j<X;j++){\n\n      if(map[i][j]==2){//この列にジャンプ台あれば\n        cost[i][j]=cost[i-1][j];\n      }\n\n      for(int k=0;k<3;k++){\n        nx=j+dx[k];\n        if((0<=nx)&&(nx<X)){//範囲外参照防止\n\n          if(map[i][j]==0){//マップのでいう今の位置に障害物なければ\n            if(map[i-1][nx]==0){//一つ上の列各列に何もない\n              cost[i][j]=cost[i][j]+cost[i-1][nx];\n            }\n          }\n        }\n      }\n\n      if(i>=3){//深さ３以上で\n        if(map[i-2][j]==2){//２マス上の位置にジャンプ台あれば\n          cost[i][j]=cost[i][j]+cost[i-2][j];\n        }\n      }\n      /*\n      if(map[i][j]==2){\n        if((i>=3)&&(map[i-2][j]==2)){\n          cost[i][j]=cost[i][j]+cost[i-2][j];\n        }\n\n      }\n\n    */\n    }\n  }\n\n  printf(\"\\n\");\n  for(int i=0;i<Y;i++){\n    for(int j=0;j<X;j++){\n      printf(\"%d \", cost[i][j]);\n    }\n    printf(\"\\n\");\n  }\n\n  for(int i=0;i<X;i++){//一番下の列を加算\n    cnt=cnt+cost[Y-1][i];\n    if(map[Y-2][i]==2){\n      cnt=cnt+cost[Y-2][i];\n    }\n  }\n\n  return cnt;\n}\n\nint main(){\n\n  int x,y;\n  long long int ans;\n\n  cin >> x >> y;\n\n  while((x!=0)&&(y!=0)){\n\n    for(int i=0;i<y;i++){//データセット取得.動作正常\n      for(int j=0;j<x;j++){\n        cin >> map[i][j];//データセット入力\n        paturn[i][j]=0;//paturn配列に初期値設定\n      }\n    }\n\n    ans=bfs(x,y);\n\n    cout << ans << endl;\n\n    for(int i=0;i<y;i++){//mapの初期化.動作正常\n      for(int j=0;j<x;j++){\n        map[i][j]=0;\n      }\n    }\n\n    ans=0;\n\n    cin >> x >> y;//次のｘ、ｙの取得\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    enum { TREE = 1, JUMP = 2 };\n    int x, y;\n    while (cin >> x >> y, x) {\n        vector<vector<int>> field(y, vector<int>(x));\n        for (auto &v: field) for (int &vi: v) cin >> vi;\n        vector<vector<int>> dp(y + 1, vector<int>(x, 0));\n        for (int j = 0; j < x; j++) dp[0][j] = field[0][j] == 0;\n        for (int i = 0; i < y - 1; i++) for (int j = 0; j < x; j++) {\n            for (int k: {-1, 0, 1}) if (j + k >= 0 && j + k < x) {\n                int ni = i + 1, nj = j + k;\n                if (k == 0) {\n                    if (field[i][j] == JUMP) ni++;\n                } else {\n                    if (field[i][j] == JUMP || field[ni][nj] == JUMP) continue;\n                }\n                if (ni < y && field[ni][nj] == TREE) continue;\n                dp[ni][nj] += dp[i][j];\n            }\n        }\n        int ans = 0;\n        for (int j = 0; j < x; j++) ans += dp[y - 1][j] + dp[y][j];\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nint main(void){\n\tint X,Y;\n\t\n\twhile(scanf(\"%d%d\", &X, &Y) && X && Y){\n\t\tint masu[32][32]={0};\n\t\tint co[32][32]={0};\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < Y; i++){\n\t\t\tfor(int j = 0; j < X; j++){\n\t\t\t\tscanf(\"%d\", &masu[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < X; i++){\n\t\t\tif(!masu[0][i])co[0][i] = 1;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < Y-1; i++){\n\t\t\tfor(int j = 0; j < X; j++){\n\t\t\t\tif(masu[i][j] == 0){\n\t\t\t\t\tif(masu[i+1][j] != 1)co[i+1][j] += co[i][j];\n\t\t\t\t\tif(masu[i+1][j+1] == 0)co[i+1][j+1] += co[i][j];\n\t\t\t\t\tif(masu[i+1][j-1] == 0 && j-1 > -1)co[i+1][j-1] += co[i][j];\n\t\t\t\t}else if(masu[i][j] != 1){\n\t\t\t\t\tco[i+2][j] += co[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < X; i++){\n\t\t\tans += co[Y-1][i];\n\t\t}\n\t\tfor(int i = 0; i < X; i++){\n\t\t\tans += co[Y][i];\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n \nusing namespace std;\n \nconst int MAX = 17;\nshort in[MAX][MAX];\nint  X,Y,data[MAX][MAX],ans;\nint dx[4] = {-1,0,1};\n \n \nvoid init(){\n  memset(data,0,sizeof(data));\n  ans = 0;\n}\n \n \nvoid solve(){\n  for(int i = 1; i <= Y; i++)\n    for(int j = 1; j <= X; j++){\n      for(int k = 0; k < 3; k++)\n\tif(in[i][j] == 2){\n\t  if(in[i+2][j] != 1) data[i+2][j] += data[i][j];\n\t  break;\n\t}else if(in[i][j] == 0){\n\t  int nex = j+dx[k];\n\t  if(nex < 1 || nex > X) continue;\n\n\t  if(in[i+1][nex] == 2 && dx[k] == 0) data[i+1][nex] += data[i][j];\n\t  if(in[i+1][nex] == 0) data[i+1][nex] += data[i][j];\n\n\t}\n    }\n  \n  for(int j = 1; j <= X; j++){\n    if(Y-1 > 0 && in[Y-1][j] == 2) ans+=data[Y-1][j];\n    ans+=data[Y][j];\n  }\n  cout << ans << endl;\n}\n \nvoid print(){\n  for(int i = 1; i <= Y; i++){\n    for(int j = 1; j <= X; j++)\n      cout << data[i][j]<< \" \";\n    cout << endl;\n  }\n}\nint main(){\n  while(cin >> X >> Y && X+Y){\n    init();\n    for(int i = 1; i <= Y; i++)\n      for(int j = 1; j <= X; j++)\n    cin >> in[i][j];\n     \n    for(int i = 1; i <= X; i++)\n      if(in[1][i] == 0) data[1][i] = 1;\n \n    solve();\n    //print();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,a,n) for(int i=a;i<n;i++)\n#define repb(i,a,b) for(int i=a;i>=b;i--)\n#define all(a) a.begin(),a.end()\n#define o(a) cout<<a<<endl\n#define int long long\n#define fi first\n#define se second\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n\n\nsigned main() {\n\tint y, x;\n\twhile (1) {\n\t\tcin >> y >> x;\n\t\tif (y + x == 0) break;\n\t\tint d[20][20] = { -1 };\n\t\trep(i, 0, y) {\n\t\t\trep(j, 0, x) {\n\t\t\t\tcin >> d[i][j];\n\t\t\t}\n\t\t}\n\t\tint dp[20][20] = { 0 };\n\t\trep(i, 0, x) {\n\t\t\tif (d[0][i] == 0) dp[0][i] = 1;\n\t\t}\n\t\trep(i, 0, y) {\n\t\t\trep(j, 0, x) {\n\t\t\t\tif (d[i][j] == 1) continue;\n\t\t\t\tif (d[i][j] == 2) {\n\t\t\t\t\tdp[i + 2][j] += dp[i][j];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\trep(k, -1, 2) {\n\t\t\t\t\tif (j + k < 0 || j + k >= x || d[i + 1][j + k] != 0) continue;\n\t\t\t\t\tdp[i + 1][j + k] += dp[i][j];\n\t\t\t\t}\n\t\t\t\tif (d[i + 1][j] == 2) {\n\t\t\t\t\tdp[i + 1][j] += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*cout << endl;\n\t\trep(i, 0, y + 2) {\n\t\t\trep(j, 0, x) {\n\t\t\t\tcout << dp[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t\tint ans = 0;\n\t\trep(i, 0, x) {\n\t\t\tans += dp[y - 1][i];\n\t\t\t/*if (d[y - 2][i] == 2) {\n\t\t\t\tans += dp[y - 2][i];\n\t\t\t}*/\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint w,h;\nint mp[20][20],memo[20][20];\nvoid saiki(int x,int y){\n  if(y >= h-1) memo[y][x]++;\n  else \n    for(int i=-1;i<=1;i++) {\n      int nx = x+i, ny = y+1;\n      if(nx==x && mp[ny][nx] == 2)while(mp[ny][nx] == 2) ny+=2;\n      if(nx <0|| nx >= w ||mp[ny][nx] != 0) continue;\n      if(memo[ny][nx]==0) saiki(nx,ny);\n      memo[y][x] += memo[ny][nx];\n    }\n  if(memo[y][x] == 0) mp[y][x] = 1;\n}\nint main() {\n  while(1) {\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n    for(int i=0;i<=19;i++)\n      for(int j=0;j<=19;j++)memo[i][j] = mp[i][j] = 0;\n     \n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)cin >> mp[i][j];\n  \n    for(int i=0;i<w;i++)\n      if(mp[0][i] !=1) saiki(i,0);\n     \n    int cnt = 0;\n    for(int i=0;i<w;i++)cnt+=memo[0][i];\n    cout <<cnt<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<math.h>\nint main(void)\n{\n\tint a,s,d[20][20],f,j,i,k;\n\tlong long int g,h[20][20];\n\twhile(1){\n\t\tscanf(\"%d %d\",&a,&s);\n\t\tif(a==0&&s==0) break;\n\t\tfor(i=0;i<s;i++) h[0][i]=1;\n\t\tfor(i=0;i<a;i++){\n\t\t\tfor(j=0;j<s;j++) scanf(\"%d\",&d[i][j]);\n\t\t}\n\t\tfor(i=0;i<s;i++){\n\t\t\tif(d[0][i]==1) h[0][i]=0;\n\t\t}\n\t\tfor(i=1;i<a;i++){\n\t\t\tfor(j=0;j<s;j++) h[i][j]=0;\n\t\t}\n\t\tfor(i=0;i<a-1;i++){\n\t\t\tfor(j=0;j<s;j++){\n\t\t\t\tif(i!=0&&d[i][j]==2){\n\t\t\t\t\tif(i+2<a){\n\t\t\t\t\t\tif(d[i+2][j]!=1) h[i+2][j]+=h[i][j];\n\t\t\t\t\t}\n\t\t\t\t\telse h[i+1][j]+=h[i][j];\n\t\t\t\t}\n\t\t\t\tif(d[i][j]==0){\n\t\t\t\t\tif(j!=0) if(d[i+1][j-1]==0) h[i+1][j-1]+=h[i][j];\n\t\t\t\t\tif(j!=s){\n\t\t\t\t\t\tif(d[i+1][j+1]==0) h[i+1][j+1]+=h[i][j];\n\t\t\t\t\t\tif(d[i+1][j]==0||d[i+1][j]==2) h[i+1][j]+=h[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tg=0;\n\t\tfor(j=0;j<s;j++) g+=h[a-1][j];\n\t\t/*printf(\"\\n\\n\");\n\t\tfor(i=0;i<a;i++){\n\t\t\tfor(j=0;j<s;j++) printf(\"%7d \",h[i][j]);\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\tprintf(\"%d\\n\",g);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\ntypedef long long ll;\nint H,W;\nint t[20][20];\nll u[20][20],ans;\n\nbool inField(int x){\n  if(1<=x&&x<=W)return true;\n  return false;\n}\n\nint main(){\n  while(cin>>W>>H){\n    if(H==0&&W==0)break;\n    for(int i=0;i<20;i++)for(int j=0;j<20;j++)u[i][j]=0;\n    for(int i=1;i<=H;i++)for(int j=1;j<=W;j++)cin>>t[i][j];\n\n    for(int i=0;i<20;i++)u[1][i]=(t[1][i]==1?0:1);\n\n    for(int i=1;i<H;i++){\n      for(int j=1;j<=W;j++){\n\tif(t[i][j]==1)u[i][j]=0;\n\tif(u[i][j]==0)continue;\n\tif(t[i][j]==2){\n\t  u[i+2][j]+=u[i][j];\n\t  continue;\n\t}\n\tfor(int k=-1;k<=1;k++){\n\t  if(!inField(j+k))continue;\n\t  if(t[i+1][j+k]==0){\n\t    u[i+1][j+k]+=u[i][j];\n\t  }else if(t[i+1][j+k]==2&&k==0){\n\t    u[i+1][j+k]+=u[i][j];\n\t  }\n\t}\n      }//j\n    }//i\n    ans=0;\n    for(int i=H;i<20;i++){\n      for(int j=1;j<=W;j++){\n\tif(t[i][j]==1)continue;\n\tans+=u[i][j];\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nconst int MAX_Y = 100;\nconst int MAX_X = 100;\nint mx, my, c[MAX_Y][MAX_X], dp[MAX_Y][MAX_X];\n\nconst int dx[3] = {-1, 0, 1};\nconst int dy[3] = {1, 1, 1};\n\nint dfs(int y, int x) {  \n  int res = 0;\n  if (dp[y][x] >= 0) return dp[y][x];\n  \n  if (y == my - 1) return 1;\n  \n  if (c[y][x] == 2) {\n    if (y+2 >= my - 1) return 1;\n    res += dfs(y+2, x);\n    return dp[y][x] = res;\n  }\n  \n  rep(z,3) {\n    int tx = x + dx[z], ty = y + dy[z];\n    if (tx < 0 || ty < 0 || tx >= mx || ty >= my) continue;\n    if (c[ty][tx] == 1) continue;\n    if (c[ty][tx] == 2 && tx != x) continue;\n    res += dfs(ty, tx);\n  }\n\n  return dp[y][x] = res;\n}\n\nvoid solve() {\n  memset(dp, -1, sizeof dp);\n  rep(i,my) rep(j,mx) cin>>c[i][j];\n\n  int res = 0;\n  rep(i,mx) {\n    if (c[0][i] == 1) continue;\n    res += dfs(0, i);\n  }\n  cout<<res<<endl;\n}\n\nint main (int argc, char const* argv[]) {\n  while (cin>>mx>>my, mx||my) {\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class t>\nusing table = vector<vector<t>>;\nconst ld eps=1e-9;\n\n//// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\"\n\nint main() {\n\twhile (1) {\n\t\tint H, W; cin >> H >> W;\n\t\tif (!H)break;\n\t\tvector<vector<int>>field(H + 3, vector<int>(W + 2,1));\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tcin >> field[i][j+1];\n\t\t\t}\n\t\t}\n\t\tfor (int i = H; i < H + 3; ++i) {\n\t\t\tfor (int j = 1; j <= W; ++j) {\n\t\t\t\tfield[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tvector<vector<long long int>>nums(H + 3, vector<long long int>(W + 2, 0));\n\t\tfor (int j = 0; j < W + 2; ++j) {\n\t\t\tif (!field[0][j])nums[0][j] = 1;\n\t\t}\n\t\tlong long int ans = 0;\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tfor (int j = 1; j < W + 1; ++j) {\n\t\t\t\tfor (int dx = -1; dx <= 1;++dx) {\n\t\t\t\t\tconst int nextx = j + dx;\n\t\t\t\t\tint nexty = i + 1;\n\t\t\t\t\t\n\t\t\t\t\tif (field[nexty][nextx] == 1) {\n\n\t\t\t\t\t}\n\t\t\t\t\telse if (field[nexty][nextx] == 2) {\n\t\t\t\t\t\tif (!dx) {\n\t\t\t\t\t\t\twhile (1) {\n\t\t\t\t\t\t\t\tnexty += 2;\n\t\t\t\t\t\t\t\tif (nexty >= H - 1 && field[nexty][nextx] != 1) {\n\t\t\t\t\t\t\t\t\tans += nums[i][j];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tif (field[nexty][nextx] == 1) {\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse if (field[nexty][nextx] == 0) {\n\n\t\t\t\t\t\t\t\t\t\tnums[nexty][nextx] += nums[i][j];\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (nexty >= H - 1)ans += nums[i][j];\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tnums[nexty][nextx] += nums[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nint main() {\n\tint x, y;\n\twhile (cin >> x >> y, x * y) {//\n\t\tint skimap[15][15] = {};//x = j y = i\n\t\tint dp[15][15] = {};//x = j y = i\n\t\tint flyover = 0;//??´????£??????????????????????\n\t\tfor (int i = 0; i < y; i++) {\n\t\t\tfor (int j = 0; j < x; j++) {\n\t\t\t\tcin >> skimap[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < x; i++){\n\t\t\tif (skimap[0][i] == 0)dp[0][i] = 1;\n\t\t}\n\t\tfor (int i = 0; i < y - 1; i++) {\n\t\t\tfor (int j = 0; j < x; j++) {\n\t\t\t\tif (skimap[i][j] == 0) {\n\t\t\t\t\tif (j - 1 >= 0) {\n\t\t\t\t\t\tif (skimap[i + 1][j - 1] == 0) {\n\t\t\t\t\t\t\tdp[i + 1][j - 1] += dp[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (skimap[i + 1][j] != 1)dp[i + 1][j] += dp[i][j];\n\t\t\t\t\tif (j + 1 < x) {\n\t\t\t\t\t\tif (skimap[i + 1][j + 1] == 0) {\n\t\t\t\t\t\t\tdp[i + 1][j + 1] += dp[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (skimap[i][j] == 1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}else {\n\t\t\t\t\tif (i + 2 < y) {\n\t\t\t\t\t\tif (skimap[i + 2][j] != 1)dp[i + 2][j] = dp[i][j];\n\t\t\t\t\t}else {\n\t\t\t\t\t\tflyover += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint sum = flyover;\n\t\tfor (int i = 0; i < x; i++) {\n\t\t\tsum += dp[y - 1][i];\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nint masu[17][17];\n\nint count;\n\tint n,m;\nvoid saiki(int x,int y){\n\t\n\tif(y<1 || y>n){\n\t\treturn;\n\t}\n\tprintf(\"make %d %d\\n\",x,y);\n\tif(x>=m){\n\t\tprintf(\"ans %d %d\\n\",x,y);\n\t\tcount++;\n\t\treturn;\n\t}\n\t\n\tif(masu[x][y]==0){\n\t\tif(masu[x+1][y-1]==0 && x<=m-2){\n\t\t\tsaiki(x+1,y-1);\n\t\t}\n\t\tif(masu[x+1][y]==0){\n\t\t\tsaiki(x+1,y);\n\t\t}\n\t\tif(masu[x+1][y]==2){\n\t\t\tsaiki(x+1,y);\n\t\t}\n\t\tif(masu[x+1][y+1]==0&& x<=m-2){\n\t\t\tsaiki(x+1,y+1);\n\t\t}\n\t}\n\tif(masu[x][y]==1){\n\t}\n\tif(masu[x][y]==2){\n\t\tif(masu[x+2][y]!=1){\n\t\t\tsaiki(x+2,y);\n\t\t}\n\t}\n\t\n\tprintf(\"--- %d %d\\n\",x,y);\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<17;i++){\n\t\tfor(int j=0;j<17;j++){\n\t\t\tmasu[i][j]=0;\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tcin>>masu[i][j];\n\t\t}\n\t}\n\t\n\tcount=0;\n\t\n\tfor(int i=1;i<=n;i++){\n\t\tsaiki(0,i);\n\t}\n\t\n\tprintf(\"%d\\n\",count);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main(){\n\tint w,h;\n\n\twhile( cin >> w >> h , w||h ){\n\t\tint f[20][20] = {0};\n\t\tfor(int y=1 ; y <= h ; y++ ){\n\t\t\tfor(int x=1 ; x <= w ; x++ ){\n\t\t\t\tcin >> f[y][x];\n\t\t\t}\n\t\t}\n\n\t\tint dp[20][20] = {0};\n\t\tfor(int x=1 ; x <= w ; x++ )\n\t\t\tdp[1][x] = 1;\n\t\tfor(int y=2 ; y <= h ; y++ ){\n\t\t\tfor(int x=1 ; x <= w ; x++ ){\n\t\t\t\tif( f[y][x] == 0 ){\n\t\t\t\t\tif( f[y-1][x-1] == 0 ) dp[y][x] += dp[y-1][x-1];\n\t\t\t\t\tif( f[y-1][x]   == 0 ) dp[y][x] += dp[y-1][x];\n\t\t\t\t\tif( f[y-1][x+1] == 0 ) dp[y][x] += dp[y-1][x+1];\n\t\t\t\t\tif( f[y-2][x]   == 2 ) dp[y][x] += dp[y-2][x];\n\t\t\t\t}else if( f[y][x] == 2 ){\n\t\t\t\t\tif( f[y-1][x] == 0 ) dp[y][x] += dp[y-1][x];\n\t\t\t\t\tif( f[y-2][x] == 2 ) dp[y][x] += dp[y-2][x];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int x=1 ; x <= w ; x++ ){\n\t\t\tans += dp[h][x];\n\t\t\tif( f[h-1][x] == 2 ){\n\t\t\t\tans += dp[h-1][x];\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define N 15\nusing namespace std;\nvoid func(int,int);\nint jump(int,int);\nint X,Y,data[N][N],memo[N][N];\nint main(){\n  while(1){\n    cin >> X >> Y;\n    if(X==0&&Y==0) break;\n    for(int i=0;i<Y;i++)\n      for(int j=0;j<X;j++) cin >> data[i][j],memo[i][j]=0;\n    for(int i=0;i<X;i++)\n      if(data[0][i]==0) func(0,i);\n    int cnt=0;\n    for(int i=0;i<X;i++) cnt+=memo[0][i];\n    cout << cnt << endl;\n  }\n  return 0;\n}\nvoid func(int y,int x){\n  if(y==Y-1){\n    memo[Y-1][x]=1;\n    return ;\n  }\n  if(0<=x-1&&data[y+1][x-1]==0){\n    if(memo[y+1][x-1]==0) func(y+1,x-1);\n    memo[y][x]+=memo[y+1][x-1];\n  }\n  if(x+1<X&&data[y+1][x+1]==0){\n    if(memo[y+1][x+1]==0) func(y+1,x+1);\n    memo[y][x]+=memo[y+1][x+1];\n  }\n  if(data[y+1][x]==0){\n    if(memo[y+1][x]==0) func(y+1,x);\n    memo[y][x]+=memo[y+1][x];\n  }\n  if(data[y+1][x]==2){\n    int r=jump(y+1,x);\n    if(r==-2) memo[y][x]+=1;\n    else if(r!=-1){\n      if(memo[r][x]==0) func(r,x);\n      memo[y][x]+=memo[r][x];\n    }\n  }\n  if(memo[y][x]==0) data[y][x]=1;\n}\nint jump(int y,int x){\n  while(1){\n    y+=2;\n    if(data[y][x]==1) break;\n    if(y>=Y-1) return -2;\n    if(data[y][x]==0) return y;\n  }\n  return -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#define pf p.first\n#define ps p.second\nusing namespace std;\ntypedef pair<int,int>P;\nint h,w,mas[20][20],memo[20][20],ans,tmp[]={-1,0,1};\nint dfs(P);\nint main(){\n  while(cin >> w >> h && w||h){\n    ans = 0;\n    for(int i=0;i<20;i++) for(int j=0;j<20;j++) memo[i][j] = -1;\n    for(int i=0;i<h;i++) for(int j=0;j<w;j++) cin >> mas[i][j];\n    for(int i=0;i<w;i++) ans += dfs(P(0,i));\n    cout << ans << endl;\n  }\n}\nint dfs(P p){\n  if(memo[pf][ps] != -1) return memo[pf][ps];\n  if(mas[pf][ps] == 1) return 0;\n  if(pf >= h - 1) return 1;\n  if(mas[pf][ps] == 2) return (memo[pf][ps] = dfs(P(pf+2,ps)));\n  else{\n    int cnt = 0;\n    for(int i=0;i<3;i++){\n      int nx = pf + 1,ny = ps + tmp[i];\n      if(ny>=0&&ny<w&&((mas[nx][ny]==0)||(mas[nx][ny]==2&&i==1))){\n\t  cnt += dfs(P(pf+1,ps+tmp[i]));\n\t}\n    }\n    return (memo[pf][ps] = cnt);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<numeric>\nusing namespace std;\n\nint main() {\n\tint x, y;\n\twhile (cin >> x >> y ,x,y) {\n\t\tvector<vector<int>> course(y + 2, vector<int>(x + 2, 0));\n\t\tfor (int i = 1; i <= y; i++) {\n\t\t\tfor (int j = 1; j <= x; j++) {\n\t\t\t\tcin >> course[i][j];\n\t\t\t}\n\t\t}\n\n\t\tvector<vector<int>> path(y + 2, vector<int>(x + 2, 0));\n\t\t//?????????????????????????????????1????????????\n\t\tfor (int i = 1; i <= x; i++) {\n\t\t\tif (course[1][i] != 1) path[1][i] = 1;\n\t\t}\n\n\t\tfor (int i = 1; i <= y; i++) {\n\t\t\tfor (int j = 1; j <= x; j++) {\n\t\t\t\t//????????????????????´????????????????????´??????????????????????????????????????????\n\t\t\t\t//?????????????§????????????????????????´?????????????????????????????£????????°?????´????????????????????????\n\t\t\t\tif (course[i][j] == 0) {\n\t\t\t\t\tif (course[i + 1][j + 1] == 0) path[i + 1][j + 1] += path[i][j];\n\t\t\t\t\tif (course[i + 1][j] != 1) path[i + 1][j] += path[i][j];\n\t\t\t\t\tif (course[i + 1][j - 1] == 0) path[i + 1][j - 1] += path[i][j];\n\t\t\t\t}\n\t\t\t\t//?¬???????????????´???????????£????????°????????????????????????????????????\n\t\t\t\t//?????????????????£????????§??´??????????????´???????????????(?????£?????????????????????????????´???????????????)\n\t\t\t\tif (course[i][j] == 2) {\n\t\t\t\t\tif (i + 2 > y) path[y][j] += path[i][j];\n\t\t\t\t\telse path[i + 2][j] += path[i][j];\n\t\t\t\t}\n\t\t\t\t//???????????´???????????????????????????????????????\n\t\t\t\tif (course[i][j] == 1) {/*do anything*/ }\n\t\t\t}\n\t\t}\n\n\t\tcout << accumulate(path[y].begin() + 1, path[y].end() - 1, 0) << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 0203\n#include <iostream>\n\nusing namespace std;\n\nint main(void)\n{\n\tint x, y;\n\twhile (cin >> x >> y, x || y){\n\t\tint field[20][20];\n\t\tfor (int i = 1; i <= y; i++){\n\t\t\tfor (int j = 1; j <= x; j++){\n\t\t\t\tcin >> field[i][j];\n\t\t\t}\n\t\t}\n\t\tint dp[20][20];\n\t\tfor (int i = 0; i < 20; i++) {\n\t\t\tfor (int j = 0; j < 20; j++){\n\t\t\t\tdp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int j = 1; j <= x; j++){\n\t\t\tif (field[1][j] == 0){\n\t\t\t\tdp[1][j] = 1;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= y; i++){\n\t\t\tfor (int j = 1; j <= x; j++){\n\t\t\t\tif (field[i][j] == 1){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (field[i][j] == 2){\n\t\t\t\t\tdp[i + 2][j] += dp[i][j];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (field[i + 1][j - 1] == 0){\n\t\t\t\t\tdp[i + 1][j - 1] += dp[i][j];\n\t\t\t\t}\n\t\t\t\tif (field[i + 1][j] != 1){\n\t\t\t\t\tdp[i + 1][j] += dp[i][j];\n\t\t\t\t}\n\t\t\t\tif (field[i + 1][j + 1] == 0){\n\t\t\t\t\tdp[i + 1][j + 1] += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// for (int i = 1; i <= y; i++){\n\t\t// \tfor (int j = 1; j <= x; j++){\n\t\t// \t\tcout << dp[i][j] << \" \";\n\t\t// \t}\n\t\t// \tputs(\"\");\n\t\t// }\n\n\t\tint ret = 0;\n\t\tfor (int i = y - 1; i <= y; i++){\n\t\t\tfor (int j = 1; j <= x; j++){\n\t\t\t\tif (i == y - 1){\n\t\t\t\t\tif (field[i][j] == 2) ret += dp[i][j];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tret += dp[i][j];\n\t\t\t\t\t// cout << i << \" \" << j << endl;\n\t\t\t\t\t// cout << ret << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ret << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nconst int MAX_Y = 15;\nconst int MAX_X = 15;\nint mx, my, c[MAX_Y][MAX_X], dp[MAX_Y][MAX_X];\n\nconst int dx[3] = {-1, 0, 1};\nconst int dy[3] = {1, 1, 1};\n\nint dfs(int y, int x) {  \n  int res = 0;\n  if (dp[y][x] >= 0) return dp[y][x];\n  \n  if (y >= my - 1) return 1;\n  \n  if (c[y][x] == 2) {\n    res += dfs(y+2, x);\n    return dp[y][x] = res;\n  }\n  \n  rep(z,3) {\n    int tx = x + dx[z], ty = y + dy[z];\n    if (tx < 0 || ty < 0 || tx >= mx || ty >= my) continue;\n    if (c[ty][tx] == 1) continue;\n    if (c[ty][tx] == 2 && tx != x) continue;\n    res += dfs(ty, tx);\n  }\n\n  return dp[y][x] = res;\n}\n\nvoid solve() {\n  memset(dp, -1, sizeof dp);\n  rep(i,my) rep(j,mx) cin>>c[i][j];\n\n  int res = 0;\n  rep(i,mx) {\n    if (c[0][i] == 1) continue;\n    res += dfs(0, i);\n  }\n  cout<<res<<endl;\n}\n\nint main (int argc, char const* argv[]) {\n  while (cin>>mx>>my, mx||my) {\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nint main()\n{\n\tint i,j;\n\tint map[20][20];\n\tint smap[20][20]={0};\n\tint mx,my;\n\tint next[3]={-1,0,1};\n\t\n\tfor(;;)\n\t{\n\t\tint ans=0;\n\t\t\n\t\tcin >> mx >> my ;\n\t\t\n\t\tif(mx==0 && my==0)\n\t\t\tbreak;\n\t\t\n\t\tfor(i=0;i<20;i++)\n\t\t\tfor(j=0;j<20;j++)\n\t\t\t{\n\t\t\t\tsmap[i][j]=0;\n\t\t\t\tmap[i][j]=0;\n\t\t\t}\n\t\t\n\t\tfor(i=0;i<my;i++)\n\t\t{\n\t\t\tfor(j=0;j<mx;j++)\n\t\t\t{\n\t\t\t\tcin >> map[i][j] ;\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<mx;i++)\n\t\t{\n\t\t\tif(map[0][i]!=1)\n\t\t\t\tsmap[0][i]=1;\n\t\t}\n\t\tfor(i=0;i<my-1;i++)\n\t\t{\n\t\t\tfor(j=0;j<mx;j++)\n\t\t\t{\n\t\t\t\tif(map[i][j]==2)\n\t\t\t\t{\n\t\t\t\t\tif(map[i+2][j]!=1)\n\t\t\t\t\t\tsmap[i+2][j]+=smap[i][j];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfor(int k=0;k<3;k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(j+next[k]>=0 && j+next[k]<mx)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(map[i+1][j+next[k]]==1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tsmap[i+1][j+next[k]]=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(map[i+1][j+next[k]]==0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tsmap[i+1][j+next[k]]+=smap[i][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(map[i+1][j+next[k]]==2 && j==j+next[k])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tsmap[i+1][j+next[k]]+=smap[i][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(i=my-1;i<my+1;i++)\n\t\t{\n\t\t\tfor(j=0;j<mx;j++)\n\t\t\t\tans+=smap[i][j];\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nlong calc(int X, int Y, int** ski);\n\nint main(void){\n  int X,Y;\n  while(true){\n    cin>>X>>Y;\n    if(X==0 and Y==0){break;}\n    int** ski=(int**)malloc(sizeof(int*)*Y);\n    for(int i=0;i<Y;i++){\n      ski[i]=(int*)malloc(sizeof(int)*X);\n      for(int j=0;j<X;j++){\n        cin>>ski[i][j];\n      }\n    }\n    cout<<calc(X,Y,ski)<<endl;\n    for(int i=0;i<Y;i++){\n      free(ski[i]);\n    }\n    free(ski);\n  }\n  return 0;\n}\n\nlong calc(int X, int Y, int** ski){\n  long** pattern=(long**)malloc(sizeof(long*)*Y);\n  for(int i=0;i<Y;i++){\n    pattern[i]=(long*)malloc(sizeof(long)*X);\n    for(int j=0;j<X;j++){\n      pattern[i][j]=0;\n    }\n  }\n\n  for(int j=0;j<X;j++){\n    if(ski[0][j]==0){\n      pattern[0][j]=1;\n    }\n    else{\n      pattern[0][j]=0;\n    }\n  }\n  for(int i=1;i<Y;i++){\n    for(int j=0;j<X;j++){\n      if(ski[i][j]==1){\n        pattern[i][j]=0;\n      }\n      else if(ski[i][j]==2){\n        pattern[i][j]=0;\n        if(ski[i-1][j]==0){\n          pattern[i][j]+=pattern[i-1][j];\n        }\n        if(i>=2 and ski[i-2][j]==2){\n          pattern[i][j]+=pattern[i-2][j];\n        }\n      }\n      else{//ski[i][j]=0\n        pattern[i][j]=0;\n        if(j>0 and ski[i-1][j-1]==0){\n          pattern[i][j]+=pattern[i-1][j-1];\n        }\n        if(ski[i-1][j]==0){\n          pattern[i][j]+=pattern[i-1][j];\n        }\n        if(j<X-1 and ski[i-1][j+1]==0){\n          pattern[i][j]+=pattern[i-1][j+1];\n        }\n        if(i>=2 and ski[i-2][j]==2){\n          pattern[i][j]+=pattern[i-2][j];\n        }\n      }\n    }\n  }\n\n  long retval=0;\n  for(int j=0;j<X;j++){\n    retval+=pattern[Y-1][j];\n    if(Y>=2 and ski[Y-2][j]==2){\n      retval+=pattern[Y-2][j];\n    }\n  }\n  return retval;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define N 15\nusing namespace std;\nvoid func(int,int);\nint jump(int,int);\nint X,Y,data[N][N],memo[N][N];\nint main(){\n  while(1){\n    cin >> X >> Y;\n    if(X==0&&Y==0) break;\n    for(int i=0;i<Y;i++)\n      for(int j=0;j<X;j++) cin >> data[i][j],memo[i][j]=0;\n    for(int i=0;i<X;i++)\n      if(data[0][i]==0) func(0,i);\n    int cnt=0;\n    for(int i=0;i<X;i++) cnt+=memo[0][i];\n    cout << cnt << endl;\n  }\n  return 0;\n}\nvoid func(int y,int x){\n  if(y==Y-1){\n    memo[Y-1][x]=1;\n    return ;\n  }\n  if(0<=x-1&&data[y+1][x-1]==0){\n    if(memo[y+1][x-1]==0) func(y+1,x-1);\n    memo[y][x]+=memo[y+1][x-1];\n  }\n  if(x+1<X&&data[y+1][x+1]==0){\n    if(memo[y+1][x+1]==0) func(y+1,x+1);\n    memo[y][x]+=memo[y+1][x+1];\n  }\n  if(data[y+1][x]==0){\n    if(memo[y+1][x]==0) func(y+1,x);\n    memo[y][x]+=memo[y+1][x];\n  }\n  if(data[y+1][x]==2){\n    int r=jump(y+1,x);\n    if(r==-2) memo[y][x]+=1;\n    else if(r!=-1){\n      if(memo[r][x]==0) func(r,x);\n      memo[y][x]+=memo[r][x];\n    }\n  }\n  if(memo[y][x]==0) data[y][x]=1;\n}\nint jump(int y,int x){\n  while(1){\n    y+=2;\n    if(y>Y-1) return -2;\n    if(data[y][x]==1) break;\n    if(y==Y-1) return -2;\n    if(data[y][x]==0) return y;\n  }\n  return -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#define int long long\nusing namespace std;\n\nsigned main() {\n\tint a, b;\n\twhile (cin >> a >> b, a | b) {\n\t\tvector<vector<int>>masu(b + 1, vector<int>(a));\n\t\tvector<vector<int>>suberikata(b + 1, vector<int>(a));\n\t\tfor (int c = 0; c < b; c++) {\n\t\t\tfor (int d = 0; d < a; d++) {\n\t\t\t\tcin >> masu[c][d];\n\t\t\t}\n\t\t}\n\t\tfor (int e = 0; e < b; e++) {\n\t\t\tif (masu[0][e] ==0)suberikata[0][e]++;\n\t\t}\n\t\tfor (int f = 0; f < b-1; f++) {\n\t\t\tfor (int g = 0; g < a; g++) {\n\t\t\t\tswitch (masu[f][g]) {\n\t\t\t\tcase 0:\n\t\t\t\t\tsuberikata[f + 1][g] += suberikata[f][g];\n\t\t\t\t\tif (g > 0&&masu[f+1][g-1]!=2)suberikata[f + 1][g - 1] += suberikata[f][g];\n\t\t\t\t\tif (g < a - 1 && masu[f + 1][g + 1] != 2)suberikata[f + 1][g + 1] += suberikata[f][g];\n\t\t\t\t\tbreak;     \n\t\t\t\tcase 2:suberikata[f + 2][g] += suberikata[f][g]; break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint s = 0;\n\t\tfor (int x = 0; x < a; x++) {\n\t\t\tif (masu[b - 1][x] != 1) { s += suberikata[b - 1][x]; }\n\t\t}\n\t\tfor (int x = 0; x < a; x++) {\n\t\t\ts += suberikata[b][x]; \n\t\t}\n\t\tcout << s << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint DP[17][17];\nint field[17][17];\nint x,y;\n\nint main(){\n\twhile(true){\n\t\tcin >> x >> y;\n\t\tif(!x && !y)\n\t\t\treturn 0;\n\t\t\n\t\tfor(int i=1; i<=y; i++)\n\t\t\tfor(int k=1; k<=x; k++)\n\t\t\t\tcin >> field[i][k];\n\t\tfor(int i=1; i<=x; i++)\n\t\t\tfield[y+1][i] = 0;\n\t\t\n\t\tfor(int i=1; i<=y+1; i++)\n\t\t\tfor(int k=0; k<=x+1; k++){\n\t\t\t\tDP[i][k]=0;\n\t\t\t\tif(i==1 && k>0 && k<=x)\n\t\t\t\t\tif(field[i][k] == 0)\n\t\t\t\t\t\tDP[i][k] = 1;\n\t\t\t}\n\t\t\n\t\tfor(int i=2; i<=y; i++){\n\t\t\tfor(int k=1; k<=x; k++){\n\t\t\t\tif(field[i][k] == 0)\n\t\t\t\t\tDP[i][k] += DP[i-1][k-1] + DP[i-1][k] + DP[i-1][k+1];\n\t\t\t\telse if(field[i][k] == 2)\n\t\t\t\t\tint n = i+2;\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\tif(field[n][k] == 0){\n\t\t\t\t\t\t\tDP[n][k] += DP[i-1][k];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else if(field[n][k] == 1)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tn+=2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans=0;\n\t\tfor(int i=y; i<=y+1; i++)\n\t\t\tfor(int k=1; k<=x; k++)\n\t\t\t\tans += DP[i][k];\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n\nusing namespace std;\n\nint x, y;\nint c[17][17];\n\nint dp[17][17];\n\nbool input() {\n  int i, j;\n  scanf(\"%d %d\", &x, &y);\n  if (!x && !y) return false;\n  fill(c[0], c[0] + 17 * 17, 1);\n  for (i = 1; i <= y; i++) {\n    for (j = 1; j <= x; j++) {\n      scanf(\"%d\", &c[i][j]);\n    }\n  }\n  /*\n  printf(\"\\n\");\n\n  for (i = 0; i < 17; i++) {\n    for (j = 0; j < 17; j++) {\n      printf(\"%d \", c[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n  */\n  return true;\n}\n\nvoid manage() {\n  int i, j, output = 0;\n\n  fill(dp[0], dp[0] + 17 * 17, 0);\n  for (i = 1; i <= x; i++) {\n    if (c[y][i] != 1) dp[y][i] = 1;\n  }\n  for (i = 1; i <= x; i++) {\n    if (c[y - 1][i] == 2) dp[y - 1][i] = 1;\n  }\n  \n  for (i = y; i > 0; i--) {\n    for (j = x; j > 0; j--) {\n      if (dp[i][j]) {\n        if (c[i][j] == 0) {\n          if (c[i - 1][j - 1] == 0) dp[i - 1][j - 1] += dp[i][j];\n          if (c[i - 1][j    ] == 0) dp[i - 1][j    ] += dp[i][j];\n          if (c[i - 1][j + 1] == 0) dp[i - 1][j + 1] += dp[i][j];\n          if (c[i - 2][j    ] == 2) dp[i - 2][j    ] += dp[i][j];\n        } else if (c[i][j] == 2) {\n          if (c[i - 1][j] == 0) dp[i - 1][j] += dp[i][j];\n          if (c[i - 2][j] == 2) dp[i - 2][j] += dp[i][j];\n        }\n      }\n    }\n  }\n  \n  /*\n  for (i = 0; i < 17; i++) {\n    for (j = 0; j < 17; j++) {\n      printf(\"%d \", dp[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n  */\n\n  for (i = 1; i <= x; i++) {\n    output += dp[1][i];\n  }\n  printf(\"%d\\n\", output);\n}\n\n\nint main() {\n\n  while(input()) {\n    manage();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint w,h;\nint mp[20][20],memo[20][20];\nint dx[] = {-1,0,1};\nvoid saiki(int x,int y) {\n  if(y >= h-1) memo[y][x]++;\n  else if(mp[y][x] != 1) {\n    for(int i=0;i<3;i++) {\n      int nx = x+dx[i], ny = y+1;\n      if(nx==x && mp[ny][nx] == 2)while(mp[ny][nx] == 2) ny+=2;\n      if(nx <0|| nx >= w ||mp[ny][nx] == 1) continue;\n\n      if(mp[ny][nx] == 0)saiki(nx,ny);\n      memo[y][x] += memo[ny][nx];\n    }\n    if(memo[y][x] == 0) mp[y][x] = 1;\n  }\n}\nint main() {\n  while(1) {\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n    for(int i=0;i<=19;i++)\n      for(int j=0;j<=19;j++)memo[i][j] = mp[i][j] = 0;\n     \n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)cin >> mp[i][j];\n  \n    for(int i=0;i<w;i++)\n      if(mp[0][i] !=1) saiki(i,0);\n     \n    int cnt = 0;\n    for(int i=0;i<w;i++)\n      if(memo[0][i] > 0) cnt+=memo[0][i];\n    cout <<cnt<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//03\n#include<iostream>\n\nusing namespace std;\n\nint main(){\n  for(int x,y;cin>>x>>y,x|y;){\n    int g[17][16]={};\n    for(int i=1;i<=y;i++){\n      for(int j=1;j<=x;j++){\n\tcin>>g[i][j];\n      }\n    }\n    int a[17][16]={};\n    for(int i=1;i<=x;i++){\n      a[1][i]=g[1][i]==0;\n    }\n    for(int i=1;i<=y-1;i++){\n      for(int j=1;j<=x;j++){\n\tif(g[i][j]==0){\n\t  for(int k=-1;k<=1;k++){\n\t    if(1<=j+k&&j+k<=x){\n\t      if(g[i+1][j+k]==0){\n\t\ta[i+1][j+k]+=a[i][j];\n\t      }else if(k==0&&g[i+1][j]==2){\n\t\ta[i+1][j]+=a[i][j];\n\t      }\n\t    }\n\t  }\n\t}else if(g[i][j]==2){\n\t  if(g[i+2][j]!=1){\n\t    a[i+2][j]+=a[i][j];\n\t  }\n\t}\n      }\n    }\n    int ans=0;\n    for(int i=1;i<=x;i++){\n      ans+=a[y][i]+a[y+1][i];\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n\nint main(){\n\tint map[20][20];\n\tint ans_map[20][20];\n\tint x,y;\n\twhile(cin>>x>>y,(x!=0)&&(y!=0)){\n\t\tlong int ans=0;\n\t\tfor(int i=0;i<y;i++){\n\t\t\tfor(int j=0;j<x;j++){\n\t\t\t\tcin>>map[i][j];\n\t\t\t\tans_map[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<x;i++){\n\t\t\tans_map[y][i]=0;\n\t\t}\n\t\tfor(int i=0;i<x;i++){\n\t\t\tif(map[0][i]==0){\n\t\t\t\tans_map[0][i]=1;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i+1<y;i++){\n\t\t\tfor(int j=0;j<x;j++){\n\t\t\t\tif(map[i][j]==2){\n\t\t\t\t\tans_map[i+2][j]+=ans_map[i][j];\n\t\t\t\t\tans_map[i][j]=0;\n\t\t\t\t}else if(map[i][j]==1){\n\t\t\t\t\tans_map[i][j]=0;\n\t\t\t\t}else{ \n\t\t\t\t\tfor(int k=-1;k<2;k++){\n\t\t\t\t\t\tif((j+k<0)||(j+k>x-1)){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(map[i+1][j+k]==0){\n\t\t\t\t\t\t\t\tans_map[i+1][j+k]+=ans_map[i][j];\n\t\t\t\t\t\t\t}else if((k==0)&&(map[i+1][j+k]==2)){\n\t\t\t\t\t\t\t\tans_map[i+1][j+k]+=ans_map[i][j];\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<x;i++){\n\t\t\tans_map[y][i]+=ans_map[y-1][i];\n\t\t}\n\t\tfor(int i=0;i<x;i++){\n\t\t\tans+=ans_map[y][i];\n\t\t}\n\t\tcout<<ans<<endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define loop(i,a,b) for(int i=a; i<b; i++)\n#define rep(i,b) loop(i,0,b)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\n\nint main(){\n    int w,h;\n    while(cin>>w>>h, w||h){\n        int G[100][100];\n        int dp[100][100]={};\n        rep(i,h)rep(j,w) cin>> G[i][j];\n\n        rep(i,w) dp[0][i] = G[0][i]==0;\n\n        rep(i,h-1) rep(j,w){\n            if( G[i][j]==1){\n                dp[i][j]=0;\n            } else if(G[i][j]==2 && G[i+2][j]!=1){\n                dp[i+2][j]+=dp[i][j];\n            } else {\n                if(G[i+1][j]==2) dp[i+1][j]+=dp[i][j];\n                loop(k,-1,2){\n                    if(0<=j+k && j+k<w && G[i+1][j+k]==0){\n                        dp[i+1][j+k]+=dp[i][j];\n                    }\n                }\n            }\n        }\n\n        ull res=0;\n        loop(i,h-1,h+1)rep(j,w){\n            res+=dp[i][j];\n        }\n\n        cout<<res<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n\nint map[15][15],table[15][15],X,Y;\n\nint main(){\nwhile(1){\n\nscanf(\"%d%d\",&X,&Y);\nif(X==0&&Y==0) return 0;\nmemset(map,-1,sizeof(map));\nmemset(table,0,sizeof(table));\nfor(int i=0;i<Y;i++){\nfor(int j=0;j<X;j++){\nscanf(\"%d\",&map[i][j]);\nif(i==0&&map[i][j]==0) table[i][j]=1;\nelse if(i!=0&&map[i][j]!=1){\nif(j>0&&map[i-1][j-1]==0) table[i][j]+=table[i-1][j-1];\nif(j<X-1&&map[i-1][j+1]==0) table[i][j]+=table[i-1][j+1];\nif(map[i-1][j]==0)table[i][j]+=table[i-1][j];\nif(i>2&&map[i-2][j]==2) table[i][j]+=table[i-2][j]; \n} \n}\n}\nint sum=0;\nfor(int i=0;i<X;i++){\nsum+=map[Y-1][i];\n}\nprintf(\"%d\\n\",sum);\n\n\n\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double ESP=1e-10;\nusing namespace std;\nint main(){\n  int n,m;\n  while(cin>>m>>n,n||m){\n    int in[15][15]={0};\n    int out[15][15]={0};\n    rep(i,m){\n      cin>>in[0][i];\n      if(in[0][i]==0)out[0][i]=1;\n    }\n    loop(i,1,n){\n      rep(j,m){\n\tcin>>in[i][j];\n\tif(in[i][j]==0){\n\t  if(j-1>=0&&in[i-1][j-1]!=2)out[i][j]+=out[i-1][j-1];\n\t  if(in[i-1][j]!=2)out[i][j]+=out[i-1][j];\n\t  if(j+1<m&&in[i-1][j+1]!=2)out[i][j]+=out[i-1][j+1];\n\t  if(i-2>=0&&in[i-2][j]==2)out[i][j]+=out[i-2][j];\n\t}else if(in[i][j]==2){\n\t  out[i][j]+=out[i-1][j];\n\t  if(i-2>=0&&in[i-2][j]==2)out[i][j]+=out[i-2][j];\n\t}\n      }\n    }\n    int ans=0;\n    rep(i,m){\n      ans+=out[n-1][i];\n      if(in[n-2][i]==2)ans+=out[n-2][i];\n    }\n    cout<<ans<<endl;\n    //cout<<endl;\n    //rep(i,n){rep(j,m)cout<<\" \"<<out[i][j];cout<<endl;}\n    //cout<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n \nusing namespace std;\n \n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define rep(i,n) REP(i, 0, n)\n#define pb push_back\n#define mp make_pair\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<double, int> pdi;\ntypedef pair<ll, ll> pll;\n \n\n \nconst int INF = 1000000;\nconst double EPS = 1e-8;\nconst int mod = 1e9 + 7;\nconst ll LINF = 1e18;\nconst double PI = acos(-1);\n\nstruct Input\n{\n\tint n;\n\tchar c;\n\tchar str[1024];\n\tstring s;\n\tll l;\n\tint nextInt(){\n\t\tscanf(\"%d\", &n);\n\t\treturn n;\n\t}\n\tll nextLong(){\n\t\tscanf(\"%lld\", &l);\n\t\treturn l;\n\t}\n\tchar nextChar(){\n\t\tscanf(\"%c\", &c);\n\t\treturn c;\n\t}\n\tstring next(){\n\t\tscanf(\"%s\", str);\n\t\treturn string(str);\n\t}\n\tstring nextLine(){\n\t\tgetline(cin, s);\n\t\treturn s;\n\t}\n};\nInput in;\n\nint dx[]={-1, 0, 1};\nint dy[]={1,1,1};\n\nint d[30][30];\nint w, h;\nll dp[30][30];\n\nbool isOutOfRange(int x){\n\tif(x < 0 || x >= w) return true;\n\treturn false; \n}\n\nint main(){\n\twhile(1){\n\t\tw = in.nextInt();\n\t\th = in.nextInt();\n\t\tif(w == 0 && h == 0) break;\n\t\trep(i, 30) rep(j, 30) d[i][j] = 0, dp[i][j] = 0LL;\n\t\trep(i, h) rep(j, w){\n\t\t\td[i][j] = in.nextInt();\n\t\t}\n\t\trep(i, w) if(d[0][i]!=1) dp[0][i] = 1;\n\t\tfor(int i = 0; i < h-1; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tif(d[i][j]==0){\n\t\t\t\t\tfor(int k = 0; k < 3; k++){\n\t\t\t\t\t\tint nx = j + dx[k], ny = i + dy[k];\n\t\t\t\t\t\tif(d[ny][nx]==0){\n\t\t\t\t\t\t\tdp[ny][nx] += dp[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(d[i + 1][j] == 2){\n\t\t\t\t\t\tdp[i + 3][j] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(d[i][j]==2){\n\t\t\t\t\tdp[i+2][j] += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// for(int i = 0; i < h; i++){\n\t\t// \tfor(int j = 0; j < w; j++){\n\t\t// \t\tcout<<\" \"<<d[i][j];\n\t\t// \t}\n\t\t// \tcout<<endl;\n\t\t// }\n\t\t// cout<<endl;\n\t\t// for(int i = 0; i < h + 1; i++){\n\t\t// \tfor(int j = 0; j < w; j++){\n\t\t// \t\tcout<<\" \"<<dp[i][j];\n\t\t// \t}\n\t\t// \tcout<<endl;\n\t\t// }\n\t\tll ans = 0LL;\n\t\tfor(int i = 0; i < w; i++){\n\t\t\tans += dp[h][i];\n\t\t\tans += dp[h-1][i];\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\t#include <iostream>\n\t#define rep2(x,from,to) for(int x=(from);(x)<(to);(x)++)\n\t#define rep(x,to) rep2(x,0,to)\n\tusing namespace std;\n\tint main(){\n\t\tint x, y;\n\t\twhile(cin >> x >> y && (x||y) ) {\n\t\t\tint b[15][15] = {};\n\t\t\trep(i,y) {\n\t\t\t\trep(j,x) {\n\t\t\t\t\tcin >> b[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ret[20][20] = {};\n\t\t\trep(i,x) {\n\t\t\t\tif(b[0][i] == 0) {\n\t\t\t\t\tret[0][i+1] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep2(i,1,y) {\n\t\t\t\trep(j,x) {\n\t\t\t\t\tif(b[i][j] == 0) {\n\t\t\t\t\t\tret[i][j+1] += ret[i-1][j] + ret[i-1][j+1] + ret[i-1][j+2];\n\t\t\t\t\t\trep2(k,-1,2) {\n\t\t\t\t\t\t\tif(b[i-1][j+k] == 2) ret[i][j+1] -= ret[i-1][j+k+1];\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(b[i][j] == 2) {\n\t\t\t\t\t\tif(y <= i+2 || b[i+2][j] != 1) {\n\t\t\t\t\t\t\tif(b[i-1][j] != 2) ret[i][j+1] += ret[i-1][j+1];\n\t\t\t\t\t\t\tret[i+2][j+1] += ret[i][j+1];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = 0;\n\t\t\trep2(i,y-1,y+2) {\n\t\t\t\trep(j,x) {\n\t\t\t\t\tans += ret[i][j+1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << ans << endl;\n\t\t}\n\t}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define N 15\nusing namespace std;\nint data[N][N];\nvoid func(int,int);\nint Cnt(int,int);\nint X,Y,cnt;\nint main(){\n  while(1){\n    cin >> X >> Y;\n    if(X==0&&Y==0) break;\n    for(int i=0;i<Y;i++)\n      for(int j=0;j<X;j++)\n\tcin >> data[i][j];\n    cnt=0;\n    for(int i=0;i<X;i++){\n      if(data[0][i]==0) func(0,i);\n    }\n    cout << cnt << endl;\n  }\n  return 0;\n}\nvoid func(int y,int x){\n  if(y>=Y-1){\n    cnt++;\n    return;\n  }\n  if(y+1<Y&&x+1<X&&data[y+1][x+1]==0) func(y+1,x+1);\n  if(y+1<Y&&x-1>=0&&data[y+1][x-1]==0) func(y+1,x-1);\n  if(y+1<Y&&data[y+1][x]==2){\n    int r=Cnt(y,x);\n    if(r!=-1) func(r,x);\n    else return ;\n  }\n  if(y+1<Y&&data[y+1][x]==0) func(y+1,x);\n}\nint Cnt(int y,int x){\n  y+=3;\n  while(1){\n    if(y>=Y-1){\n      if(y>Y-1) cnt++;\n      else if(y==Y-1&&data[y][x]!=1) cnt++;\n      break;\n    }\n    if(data[y][x]==1) break;\n    if(data[y][x]==2) y+=2;\n    if(data[y][x]==0) return y;\n  }\n  return -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n\n#define SIZE 15+5\n\nusing namespace std;\n \nint main(){\n    std::ios_base::sync_with_stdio(false);\n\n\tint X,Y;\n\tint course[SIZE+1][SIZE];\n\tint dp[SIZE+1][SIZE];\n\tint ans;\n\n\twhile(1){\n\t\tcin>>X>>Y;\n\t\tif(X==0&&Y==0) break;\n\n\t\tfor(int i=0;i<Y*X;i++) cin>>course[i/X][i%X];\n\t\tfor(int i=0;i<X;i++) course[Y+1][i]=0;\n\t\tfor(int i=0;i<(Y+1)*(X);i++) dp[i/X][i%X]=(i/X==0&&course[i/X][i%X]==0)?1:0;\n\n\t\tfor(int i=0;i<(Y-1)*X;i++){\n\t\t\tif(dp[i/X][i%X]>0){\n\t\t\t\tif(course[i/X][i%X]==0){\n\t\t\t\t\tif(i%X!=0){\n\t\t\t\t\t\tif(course[i/X+1][i%X-1]==0) dp[i/X+1][i%X-1]+=dp[i/X][i%X];\n\t\t\t\t\t}\n\t\t\t\t\t\tif(course[i/X+1][i%X]!=1) dp[i/X+1][i%X]+=dp[i/X][i%X];\n\t\t\t\t\t\tif(i%X!=X-1){\n\t\t\t\t\t\t\tif(course[i/X+1][i%X+1]==0) dp[i/X+1][i%X+1]+=dp[i/X][i%X];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(course[i/X][i%X]==2){\n\t\t\t\t\t\tif(course[i/X+2][i%X]!=1) dp[i/X+2][i%X]+=dp[i/X][i%X];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\tans=0;\n\t\tfor(int i=(Y-1)*X;i<(Y+1)*X;i++){\n\t\t\tans+=dp[i/X][i%X];\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n \n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint w, h;\nvector< vector< int > > field, cnt;\n\nint rec(int y, int x, int px){\n\tif(x < 0 || x > w - 1) return 0;\n\tif(y >= h) return 1;\n\tif(cnt[y][x] != -1) {\n\t\tif(field[y][x] == 2 && px != x) return 0;\n\t\treturn cnt[y][x];\n\t}\n\t\n\tif(field[y][x] == 1) return cnt[y][x] = 0;\n\telse if(field[y][x] == 0) return cnt[y][x] = rec(y + 1, x - 1, x) + rec(y + 1, x, x) + rec(y + 1, x + 1, x);\n\telse{\n\t\tcnt[y][x] = rec(y + 2, x, x);\n\t\t\n\t\tif(px == x) return cnt[y][x];\n\t\telse return 0;\n\t}\n}\n\nint main(){\n\t\n\twhile(cin >> w >> h, w){\n\t\tfield.resize(h);\n\t\tcnt.resize(h);\n\t\tfor(int i = 0; i < h; ++i){\n\t\t\tfield[i].resize(w);\n\t\t\tcnt[i].resize(w);\n\t\t\tfor(int j = 0; j < w; ++j){\n\t\t\t\tcin >> field[i][j];\n\t\t\t\tcnt[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < w; ++i){\n\t\t\tcnt[h - 1][i] = (field[h - 1][i] == 1 ? 0 : 1);\n\t\t}\n\t\t\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < w; ++i){\n\t\t\tsum += rec(0, i, i);\n\t\t}\n\t\t\n\t\tcout << sum << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint dfs(int x,int y);\nint mas[20][20];\nint X,Y;\n\nint main(){\n\twhile(1){\n\t\tcin >> X >> Y;\n\t\tif(X == 0 && Y == 0) break;\n\t\tfor(int i=0;i<Y;i++){\n\t\t\tfor(int j=0;j<X;j++){\n\t\t\t\tcin >> mas[i][j];\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i=0;i<X;i++){\n\t\t\tif(mas[0][i] == 0){\n\t\t\t\tans += dfs(i,0);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\nint dfs(int x,int y){\n\tif(mas[y][x] == 1) return 0;\n\tif(y>=Y-1) return 1;\n\tif(mas[y][x] == 2) return dfs(x,y+2);\n\telse{\n\t\tint cou = 0;\n\t\tfor(int i=-1;i<2;i++){\n\t\t\tint nx = x + i;\n\t\t\tint ny = y + 1;\n\t\t\tif(nx >= 0 && nx < X && ((i == 0 && mas[ny][nx] == 2) || (mas[ny][nx] == 0))){\n\t\t\t\tcou += dfs(nx,ny);\n\t\t\t}\n\t\t}\n\t\treturn cou;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<algorithm>\n\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint x,y;\nint c[20][20];\nint dp[20][20];\n\nvoid solve() {\n\trep(i,20) rep(j,20) c[i][j]=1;\n\trep(i,20) rep(j,20) dp[i][j]=0;\n\n\trep(i,y) rep(j,x) cin>>c[i][j];\n\n\trep(i,x) if(c[0][i]!=1) dp[0][i]=1;\n\t\n\tfor(int i=0;i<y;i++) {\n\t\tfor(int j=0;j<x;j++) {\n\t\t\tif(c[i][j]==2) {\n\t\t\t\tdp[i+2][j] += dp[i][j];\n\t\t\t}\n\t\t\telse if(c[i][j]==0) {\n\t\t\t\tif(c[i+1][j]!=1) {\n\t\t\t\t\tdp[i+1][j] += dp[i][j];\n\t\t\t\t}\n\t\t\t\tif(0<=j-1 && c[i+1][j-1]==0) {\n\t\t\t\t\tdp[i+1][j-1] += dp[i][j];\n\t\t\t\t}\n\t\t\t\tif(j+1 < x && c[i+1][j+1]==0) {\n\t\t\t\t\tdp[i+1][j+1] += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tint ans=0;\n\trep(i,x) if(c[y-1][i]!=1) ans+=dp[y-1][i];\n\trep(i,x) ans+=dp[y][i];\n\n\tcout<<ans<<endl;\n\n}\n\nint main() {\n\twhile(cin>>x>>y) {\n\t\tif(x+y==0) return 0;\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint X, Y;\nint field[17][17];\nint dp[18][17];\n\nvoid solve() {\n\tfill(dp[0], dp[17], 0);\n\tfor (int x = 1; x <= X; x++)\n\t\tif (field[1][x] == 0) dp[1][x] = 1;\n\tfor(int y = 1; y < Y; y++)\n\t\tfor (int x = 1; x <= X; x++) {\n\t\t\tswitch (field[y][x]) {\n\t\t\tcase 0:\n\t\t\t\tif(field[y+1][x-1] == 0) dp[y + 1][x - 1] += dp[y][x];\n\t\t\t\tdp[y + 1][x] += dp[y][x];\n\t\t\t\tif(field[y+1][x+1] == 0) dp[y + 1][x + 1] += dp[y][x];\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tdp[y + 2][x] += dp[y][x];\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\tint sum = 0;\n\tfor(int y = Y; y <= Y+1; y++)\n\t\tfor (int x = 1; x <= X; x++) \n\t\t\tif (field[y][x] != 1) sum += dp[y][x];\n\tcout << sum << endl;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile (cin >> X >> Y, X, Y) {\n\t\tfill(field[0], field[17], 0);\n\t\tfor (int y = 1; y <= Y; y++)\n\t\t\tfor (int x = 1; x <= X; x++)\n\t\t\t\tcin >> field[y][x];\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint solve(int f[20][20] ,int w ,int h ){\n\tint dp[20][20] = {0};\n\tfor(int x=1 ; x <= w ; x++ ){\n\t\tdp[1][x] = 1;\n\t}\n\n\tfor(int y=1 ; y <= h-1 ; y++ ){\n\t\tfor(int x=1 ; x <= w ; x++ ){\n\t\t\tif( f[y][x] == 0 ){\n\t\t\t\tif( f[y+1][x-1] == 0 ) dp[y+1][x-1] += dp[y][x];\n\t\t\t\tif( f[y+1][x]   == 0 ) dp[y+1][x]   += dp[y][x];\n\t\t\t\tif( f[y+1][x+1] == 0 ) dp[y+1][x+1] += dp[y][x];\n\t\t\t\tif( f[y+1][x]   == 2 ) dp[y+1][x]   += dp[y][x];\n\t\t\t}else if( f[y][x] == 2 ){\n\t\t\t\tif( f[y+2][x] == 0 || f[y+2][x] == 2 ){\n\t\t\t\t\tdp[y+2][x] += dp[y][x];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int x=1 ; x <= w ; x++ ){\n\t\tans += dp[h][x] + dp[h+1][x];\n\t}\n\treturn ans;\n}\n\nint main(){\n\tint w,h;\n\n\twhile( cin >> w >> h , w||h ){\n\t\tint f[20][20] = {0};\n\t\tfor(int y=1 ; y <= h ; y++ ){\n\t\t\tfor(int x=1 ; x <= w ; x++ ){\n\t\t\t\tcin >> f[y][x];\n\t\t\t}\n\t\t}\n\n\t\tint ans = solve( f , w , h );\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint w,h;\nint mp[20][20];\nint memo[20][20];\nint ans;\nint count;\n\nint saiki(int x,int y) {\n  count++;\n  // cout << x <<\" \"<<y <<endl;\n  int dx[3] = {-1,0,1};\n  int dy[3] = {1,1,1};\n  \n  if(y >= h-1) ans++,memo[y][x]++;\n  \n  else if(mp[y][x] != 1) {\n    for(int i=0;i<3;i++) {\n      int nx = dx[i]+x;\n      int ny = dy[i]+y;\n      if(nx <0|| nx >= w || memo[ny][nx] == -1||mp[ny][nx] == 1) continue;\n      \n      if(memo[ny][nx] > 0 && mp[ny][nx] == 0) {\n\tans += memo[ny][nx];\n\tmemo[y][x] += memo[ny][nx];\n      }  \n      else if(x == nx && mp[ny][nx] == 2 && memo[ny][nx] > 0) {\n\tans += memo[ny][nx];\n\tmemo[y][x] += memo[ny][nx];\n      }\n      else if(mp[ny][nx] == 0){\n\tsaiki(nx,ny);\n\tif(memo[ny][nx] > 0) memo[y][x] += memo[ny][nx];\n      } \n      else if(nx==x && mp[ny][nx] == 2){\n\tint ty = ny;\n\twhile(mp[ty][nx] == 2) ty+=2;\n\tif(mp[ty][nx] == 0)saiki(nx,ty);\n\tif(memo[ty][nx] > 0) memo[y][x] += memo[ty][nx];\n      }\n    }\n    if(memo[y][x] == 0) memo[y][x] = -1;\n  }\n}\n\n\nint main() {\n\n  while(1) {\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n\n    for(int i=0;i<=19;i++) \n      for(int j=0;j<=19;j++){ \n\tmemo[i][j] = 0;\n\tmp[i][j] = 0;\n      }\n    \n    for(int i=0;i<h;i++) \n      for(int j=0;j<w;j++) \n\tcin >> mp[i][j];\n\n\n    ans = 0;\n    count = 0;\n    for(int i=0;i<w;i++) {\n      if(mp[0][i] !=1) saiki(i,0);\n    }\n    \n    /*\n    for(int i=0;i<h;i++) {\n    for(int j=0;j<w;j++) \n      cout << memo[i][j]<<\" \";\n    cout << endl;\n    } \n    */\n  \n    int ans2 = 0;\n    for(int i=0;i<w;i++) \n      if(memo[0][i] > 0) ans2+=memo[0][i];\n    \n    cout << ans << endl;\n    //    cout << ans2 << endl;\n    //cout << count << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<climits>\n#include<map>\n#include<string>\nusing namespace std;\n\nint X, Y, Fld[17][15], memo[14][15];\n\nint DFS(int y, int x){\n\tif(y >= Y-1) return 1;\n\tif(Fld[y][x] == 2) return DFS(y+2, x);\n\tif(memo[y][x] != -1) return memo[y][x];\n\tmemo[y][x] = 0;\n\n\tfor(int i = -1; i <= 1; i++){\n\t\tint ny = y+1, nx = x + i;\n\t\tif( nx < 0 || X <= nx || Fld[ny][nx] == 1 || (Fld[ny][nx] == 2 && i != 0) )\n\t\t\tcontinue;\n\t\tmemo[y][x] += DFS(ny, nx);\n\t}\n\n\treturn memo[y][x];\n}\n\nint main(){\n\twhile(cin >> X >> Y, X || Y){\n\t\tfill_n( (int*)Fld, 17*15, 0 );\n\t\tfor(int i = 0; i < Y; i++){\n\t\t\tfor(int j = 0; j < X; j++){\n\t\t\t\tcin >> Fld[i][j];\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tfill_n( (int*)memo, 14*15, -1 );\n\t\tfor(int i = 0; i < X; i++) if(Fld[0][i] == 0) ans += DFS(0, i);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint vis[15][15];\n\nint bfs(int a[15][15], int n, int m, int s, int t)\n{\n  int c = 0;\n  if(s+1 == n){\n    vis[s][t] = 1;\n    return 1;\n  }\n\n  if(vis[s][t] > 0){\n    return vis[s][t];\n  }\n\n  if(a[s][t] == 2){\n    if(s+2 >= n){\n      vis[s][t] = 1;\n      return 1;\n    }\n    c = bfs(a, n, m, s+2, t);\n  } else {\n\n    if(t-1 >= 0){\n      if(a[s+1][t-1] == 0){\n\tc += bfs(a, n, m, s+1, t-1);\n      }\n    }\n    if(a[s+1][t] != 1){\n      c += bfs(a, n, m, s+1, t);\n    }\n    \n    if(t+1 < m){\n      if(a[s+1][t+1] == 0){\n      c += bfs(a, n, m, s+1, t+1);\n      }\n    }\n  }\n  vis[s][t] = c;\n\n  return c;\n}\n\nint main()\n{\n  int n, m, c;\n  int a[15][15];\n\n  while(1){\n    cin >> m >> n;\n    if(n == 0 && m == 0){\n      break;\n    }\n\n    fill(&vis[0][0], &vis[14][14], -1);\n\n    for(int i = 0; i < n; i++){\n      for(int j = 0; j < m; j++){\n\tcin >> a[i][j];\n      }\n    }\n    c = 0;\n    for(int i = 0; i < m; i++){\n      if(a[0][i] != 1){\n\tc += bfs(a, n, m, 0, i);\n      }\n    }\n\n    cout << c << endl;\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint X,Y;\nint fields[20][20];\nint dp[20][20];\nint counter=0;\nint Max(int x,int y){\n        return x>y?x:y;\n}\nint Min(int x,int y){\n        return x>y?y:x;\n}\nint recursion(int y,int x){\n        int res=0;\n        if(dp[y][x]!=-1)\n                return dp[y][x];\n        else if(fields[y][x]==3)\n                res=0;\n        else if(fields[y][x]==2){\n                if(fields[y+2][x]==1)\n                        return 0;\n                res+=recursion(y+2,x);\n        }\n        else{\n                if(fields[y+1][x]!=1){\n                        res+=recursion(y+1,x);\n                }\n                if(fields[y+1][x-1]==0){\n                        res+=recursion(y+1,x-1);\n                }\n                if(fields[y+1][x+1]==0){\n                        res+=recursion(y+1,x+1);\n                }\n        }\n        return dp[y][x]=res;\n}\nint main(){\n        while(true){\n                for(int i=0 ; i<20 ; i++ )\n                        for(int j=0 ; j<20 ; j++ )\n                                dp[i][j]=-1;\n                cin >> X >> Y;\n                counter=0;\n                if(X+Y==0)\n                        break;\n                for(int i=0 ; i<=X ; i++ ){\n                        fields[0][i]=3;\n                        fields[Y+1][i]=3;\n                }\n                for(int i=0 ; i<=Y ; i++ ){\n                        fields[i][0]=3;\n                        fields[i][X+1]=3;\n                }\n                for(int i=1 ; i<=Y ; i++ )\n                        for(int j=1 ; j<=X ; j++ )\n                                cin >> fields[i][j];\n                int ans=0;\n                for(int i=1 ; i<=X ; i++ ){\n                        if(fields[1][i]==1)\n                                continue;\n                        ans+=recursion(1,i);\n                }\n                cout << ans << endl;\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint vis[15][15];\n\nint bfs(int a[15][15], int n, int m, int s, int t)\n{\n  int c = 0;\n  if(s+1 == n){\n    vis[s][t] = 1;\n    return 1;\n  }\n\n  if(vis[s][t] > 0){\n    return vis[s][t];\n  }\n\n  if(a[s][t] == 2){\n    if(s+2 >= n){\n      vis[s][t] = 1;\n      return 1;\n    }\n    c = bfs(a, n, m, s+2, t);\n  } else {\n\n    if(t-1 >= 0){\n      if(a[s+1][t-1] == 0){\n\tc += bfs(a, n, m, s+1, t-1);\n      }\n    }\n    if(a[s+1][t] != 1){\n      c += bfs(a, n, m, s+1, t);\n    }\n    \n    if(t+1 < m){\n      if(a[s+1][t+1] == 0){\n      c += bfs(a, n, m, s+1, t+1);\n      }\n    }\n  }\n  vis[s][t] = c;\n\n  return c;\n}\n\nint main()\n{\n  int n, m, c;\n  int a[15][15];\n\n  while(1){\n    cin >> m >> n;\n    if(n == 0 && m == 0){\n      break;\n    }\n\n    fill(&vis[0][0], &vis[14][14], -1);\n\n    for(int i = 0; i < n; i++){\n      for(int j = 0; j < m; j++){\n\tcin >> a[i][j];\n      }\n    }\n    c = 0;\n    for(int i = 0; i < m; i++){\n      if(a[0][i] != 1){\n\tc += bfs(a, n, m, 0, i);\n      }\n    }\n    for(int i = 0; i < n; i++){\n      for(int j = 0; j < m; j++){\n\tprintf(\"%2d \", vis[i][j]);\n      }\n      cout << endl;\n    }\n\n    cout << c << endl;\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nint main(void){\n\tint x,y,i,j;\n\twhile(scanf(\"%d%d\",&x,&y),x,y){\n\t\tint masu[20][20]={ 0 };\n\t\tint dp[20][20]={0};\n\t\tint ans=0;\n\t\tfor(i=1;i<=y;i++){\n\t\t\tfor(j=1;j<=x;j++){\n\t\t\t\tscanf(\"%d\",&masu[i][j]);\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<=y;i++)masu[i][0]=1;\n\t\tfor(j=0;j<=x;j++)masu[0][j]=1;\n\t\t\n\t\tfor(j=1;j<=x;j++){\n\t\t\tif(masu[1][j]==0)dp[1][j]=1;\n\t\t}\n\t\tfor(i=2;i<=y;i++){\n\t\t\tfor(j=1;j<=x;j++){\n\t\t\t\tif(masu[i][j]==0){\n\t\t\t\t\tif(masu[i-1][j-1]!=2)dp[i][j]+=dp[i-1][j-1];\n\t\t\t\t\tif(masu[i-1][j]!=2)\t dp[i][j]+=dp[i-1][j];\n\t\t\t\t\tif(masu[i-1][j+1]!=2)dp[i][j]+=dp[i-1][j+1];\n\t\t\t\t\tif(masu[i-2][j]==2){\n\t\t\t\t\t\tdp[i][j]+=dp[i-2][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(masu[i][j]==1){\n\t\t\t\t\tdp[i][j]=0;\n\t\t\t\t}\n\t\t\t\tif(masu[i][j]==2){\n\t\t\t\t\tdp[i][j]=dp[i-1][j];\n\t\t\t\t\tif(masu[i-2][j]==2)dp[i][j]+=dp[i-2][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=x;i++){\n\t\t\tans+=dp[y][i];\n\t\t\tif(masu[y-1][i]==2)ans+=dp[y-1][i];\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nint field[20][20];\nlong long dp[20][20];\n\nint main()\n{\n  int c1, c2;\n  while (scanf(\" %d %d \", &c1, &c2) == 2) {\n    if (c1 == 0 && c2 == 0) {break;}\n    for (int i = 0; i < 20; i++) {\n      fill(field[i], &field[i][20], 1);\n      fill(dp[i], &dp[i][20], 0);\n    }\n    for (int i = 1; i <= c1; i++) {\n      for (int j = 1; j <= c2; j++) {\n\tscanf(\" %d \", &field[i][j]);\n      }\n    }\n    /*for (int i = 0; i < 20; i++) {\n      for (int j = 0; j < 20; j++) {\n\tprintf(\"%d\", field[i][j]);\n      }\n      printf(\"\\n\");\n      }*/\n    \n    for (int i = 1; i <= c2; i++) {\n      dp[1][i] = 1;\n    }\n    for (int i = 1; i < c1; i++) {\n      for (int j = 1; j <= c2; j++) {\n\tif (field[i][j] == 0) {\n\t  if (field[i + 1][j - 1] != 2) {dp[i + 1][j - 1] += dp[i][j];}\n\t  dp[i + 1][j] += dp[i][j];\n\t  if (field[i + 1][j + 1] != 2) {dp[i + 1][j + 1] += dp[i][j];}\n\t} else if (field[i][j] == 2) {\n\t  dp[i + 2][j] += dp[i][j];\n\t} \n      }\n    }\n    long long sum = 0;\n    for (int i = 0; i <= 1; i++) {\n      for (int j = 1; j <= c2; j++) {\n\tif (i != 0 || field[c1 + i][j] != 1) {\n\t  sum += dp[c1 + i][j];\n\t}\n      }\n    }\n    /*for (int i = 1; i <= c1; i++) {\n      for (int j = 1; j <= c2; j++) {\n\tprintf(\"%d\", dp[i][j]);\n      }\n      printf(\"\\n\");\n      }*/\n    \n    printf(\"%d\\n\", sum);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<numeric>\nint main()\n{\n\tint x,y,i,j;\n\twhile(scanf(\"%d%d\",&x,&y),x)\n\t{\n\t\tint m[15][17];\n\t\tfor(i=0;i<15;++i)for(j=0;j<17;++j) m[i][j]=-1;\n\t\tfor(i=0;i<y;++i)for(j=0;j<x;++j) scanf(\"%d\",&m[i][1+j]);\n\n\t\tint a[16][17]={0};\n\t\tfor(j=1;j<=x;++j)a[0][j]=(m[0][j]-1?1:0);\n\t\tfor(i=0;i<y-1;++i)\n\t\t\tfor(j=1;j<=x;++j)\n\t\t\t{\n\t\t\t\tif(m[i][j]==0)\n\t\t\t\t{\n\t\t\t\t\tif(m[i+1][j-1]==0) a[i+1][j-1]+=a[i][j];\n\t\t\t\t\tif(m[i+1][j+1]==0) a[i+1][j+1]+=a[i][j];\n\t\t\t\t\tif(m[i+1][j]==0 || m[i+1][j]==2) a[i+1][j]+=a[i][j];\n\t\t\t\t}\n\t\t\t\telse if(m[i][j]==2)\n\t\t\t\t{\n\t\t\t\t\ta[i+2][j] += (m[i+2][j]!=1?a[i][j]:0);\n\t\t\t\t}\n\t\t\t}\n\t\tfor(i=1;i<=x;++i) a[y][i] += a[y-1][i];\n\t\tprintf(\"%d\\n\", std::accumulate(&a[y][1],&a[y][x+1],0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<math.h>\nint main(void)\n{\n\tint a,s,d[20][20],f,j,i,k;\n\tlong long int g,h[20][20];\n\twhile(1){\n\t\tscanf(\"%d %d\",&a,&s);\n\t\tif(a==0&&s==0) break;\n\t\tfor(i=0;i<s;i++) h[0][i]=1;\n\t\tfor(i=0;i<a;i++){\n\t\t\tfor(j=0;j<s;j++) scanf(\"%d\",&d[i][j]);\n\t\t}\n\t\tfor(i=0;i<s;i++){\n\t\t\tif(d[0][i]==1) h[0][i]=0;\n\t\t}\n\t\tfor(i=1;i<a;i++){\n\t\t\tfor(j=0;j<s;j++) h[i][j]=0;\n\t\t}\n\t\tfor(i=0;i<a;i++){\n\t\t\tfor(j=0;j<s;j++){\n\t\t\t\tif(i!=0&&d[i+1][j]==1&&d[i][j]==2) h[i+1][j]+=h[i][j];\n\t\t\t\tif(h[i][j]!=0){\n\t\t\t\t\tif(d[i][j]==0) if(j!=0) if(d[i+1][j-1]==0) h[i+1][j-1]+=h[i][j];\n\t\t\t\t\tif(j!=s){\n\t\t\t\t\t\tif(d[i][j]==0) if(d[i+1][j+1]==0) h[i+1][j+1]+=h[i][j];\n\t\t\t\t\t\tif(d[i+1][j]==0||d[i+1][j]==2) h[i+1][j]+=h[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tg=0;\n\t\tfor(j=0;j<s;j++) g+=h[a-1][j];\n\t\t/*printf(\"\\n\\n\");\n\t\tfor(i=0;i<a;i++){\n\t\t\tfor(j=0;j<s;j++) printf(\"%d \",h[i][j]);\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\tprintf(\"%d\\n\",g);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#define N 15\nusing namespace std;\nvoid func(int,int);\nint jump(int,int);\nint X,Y,data[N][N],memo[N+2][N];\nint main(){\n  while(1){\n    cin >> X >> Y;\n    if(X==0&&Y==0) break;\n    for(int i=0;i<Y;i++)\n      for(int j=0;j<X;j++)\n\tcin >> data[i][j];\n    for(int i=0;i<Y+2;i++)\n      for(int j=0;j<X;j++)\n\tmemo[i][j]=0;\n    for(int i=0;i<X;i++)\n      if(data[0][i]!=1)\n\tfunc(0,i);\n    int cnt=0;\n    for(int i=0;i<X;i++)\n      cnt+=memo[0][i];\n    cout << cnt << endl;\n  }\n  return 0;\n}\nvoid func(int y,int x){\n  if(y>=Y-1){\n    memo[Y][x]=memo[Y-1][x]=1;\n    return ;\n  }\n  if(0<=x-1&&data[y+1][x-1]==0){\n    if(memo[y+1][x-1]!=0) memo[y][x]+=memo[y+1][x-1];\n    else{\n      func(y+1,x-1),memo[y][x]+=memo[y+1][x-1];\n    }\n  }\n  if(x+1<X&&data[y+1][x+1]==0){\n    if(memo[y+1][x+1]!=0) memo[y][x]+=memo[y+1][x+1];\n    else{\n      func(y+1,x+1),memo[y][x]+=memo[y+1][x+1];\n    }\n  }\n  if(data[y+1][x]==0){\n    if(memo[y+1][x]!=0) memo[y][x]+=memo[y+1][x];\n    else{\n      func(y+1,x),memo[y][x]+=memo[y+1][x];\n    }\n  }\n  if(data[y+1][x]==2){\n    int r=jump(y+1,x);\n    if(r!=-1){\n      if(memo[r][x]!=0) memo[y][x]+=memo[r][x];\n      else{\n\tfunc(r,x),memo[y][x]+=memo[r][x];\n      }\n    }\n  }\n  if(memo[y][x]==0) data[y][x]=1;\n}\nint jump(int y,int x){\n  y+=2;\n  while(1){\n    if(y>=Y-1) return y;\n    if(data[y][x]==1) break;\n    if(data[y][x]==0) return y;\n    if(data[y][x]==2) y+=2;\n  }\n  return -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<queue>\n#include<string>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define reps(i,n) for(int i=1;i<=int(n);i++)\n#define sint(i) scanf(\"%d\",&i);\n#define sintt(i,j) scanf(\"%d%d\",&i,&j);\n#define sinttt(i,j,k) scanf(\"%d%d%d\",&i,&j,&k);\n#define sintttt(i,j,k,m) scanf(\"%d%d%d%d\",&i,&j,&k,&m);\n\n#define INF 1010000000\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\n\n\nint main(){\n\twhile(1){\n\t\tint n,m;\n\t\tsintt(n,m);\n\t\tif(n==0)break;\n\t\tint masu[17][17];\n\t\tint dp[17][17];\n\t\t\n\t\trep(i,17)rep(j,17)masu[i][j]=dp[i][j]=0;\n\t\t\n\t\trep(i,m)rep(j,n){\n\t\t\tsint(masu[j+1][i]);\n\t\t}\n\t\t\n\t\treps(j,n){\n\t\t\tif(masu[j][0]!=1){\n\t\t\t\tdp[j][0]=1;\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(i,m-1){\n\t\t\treps(j,n){\n\t\t\t\tif(masu[j][i]==2){\n\t\t\t\t\tif(masu[j][i+2]!=1){\n\t\t\t\t\t\tdp[j][i+2]+=dp[j][i];\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(masu[j][i]==0){\n\t\t\t\t\tif(masu[j-1][i+1]==0){\n\t\t\t\t\t\tdp[j-1][i+1]+=dp[j][i];\n\t\t\t\t\t}\n\t\t\t\t\tif(masu[j+1][i+1]==0){\n\t\t\t\t\t\tdp[j+1][i+1]+=dp[j][i];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(masu[j][i+1]!=1){\n\t\t\t\t\t\tdp[j][i+1]+=dp[j][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans=0;\n\t\tfor(int i=m-1;i<=m;i++){\n\t\t\treps(j,n){\n\t\t\t\tans+=dp[j][i];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t\t/*\n\t\trep(i,m+2){\n\t\t\trep(j,n+2){\n\t\t\t\tprintf(\"%d \",dp[j][i]);\n\t\t\t}puts(\"\");\n\t\t}*/\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#define int long long\nusing namespace std;\n\nsigned main() {\n\tint a, b;\n\twhile (cin >> a >> b, a | b) {\n\t\tvector<vector<int>>masu(b + 1, vector<int>(a));\n\t\tvector<vector<int>>suberikata(b + 1, vector<int>(a));\n\t\tfor (int c = 0; c < b; c++) {\n\t\t\tfor (int d = 0; d < a; d++) {\n\t\t\t\tcin >> masu[c][d];\n\t\t\t}\n\t\t}\n\t\tfor (int e = 0; e < a; e++) {\n\t\t\tif (masu[0][e] ==0)suberikata[0][e]++;\n\t\t}\n\t\tfor (int f = 0; f < b-1; f++) {\n\t\t\tfor (int g = 0; g < a; g++) {\n\t\t\t\tswitch (masu[f][g]) {\n\t\t\t\tcase 0:\n\t\t\t\t\tsuberikata[f + 1][g] += suberikata[f][g];\n\t\t\t\t\tif (g > 0&&masu[f+1][g-1]!=2)suberikata[f + 1][g - 1] += suberikata[f][g];\n\t\t\t\t\tif (g < a - 1 && masu[f + 1][g + 1] != 2)suberikata[f + 1][g + 1] += suberikata[f][g];\n\t\t\t\t\tbreak;     \n\t\t\t\tcase 2:suberikata[f + 2][g] += suberikata[f][g]; break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint s = 0;\n\t\tfor (int x = 0; x < a; x++) {\n\t\t\tif (masu[b - 1][x] != 1) { s += suberikata[b - 1][x]; }\n\t\t}\n\t\tfor (int x = 0; x < a; x++) {\n\t\t\ts += suberikata[b][x]; \n\t\t}\n\t\tcout << s << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<30;\n\nint X, Y;\nint ba[15][15];\n\nint const dx[] = {-1,0,1};\nint solve(int x, int y) {\n  if (y >= Y-1) return 1;\n  int res = 0;\n  REP(i,3) {\n    int xx = x + dx[i];\n    int yy = y+1;\n    \n    if (xx < 0 || X <= xx) continue;\n    if (i == 1) {\n      while (yy < Y && ba[xx][yy] == 2) {\n        yy+=2;\n      }\n      if (yy >= Y || ba[xx][yy] == 0)\n        res += solve(xx, yy);\n    } else if (ba[xx][yy] == 0) {\n      res += solve(xx, yy);\n    }\n  }\n  return res;\n}\n\nint main() {\n  while(cin >> X >> Y, X||Y) {\n    REP(y,Y) {\n      REP(x,X) {\n        cin >> ba[x][y];\n      }\n    }\n    int ans = 0;\n    REP(x,X) {\n      ans += solve(x, 0);\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<string.h>\nusing namespace std;\n\nint course[15][15];\nint pattern[16][16];\n\nint main() {\n\n  int X,Y,t,in;\n  while(cin>>X>>Y, X|Y) {\n    memset(course, 0, sizeof(course));\n    memset(pattern, 0, sizeof(pattern));\n    for(int i=0; i<Y; ++i) {\n      for(int j=0; j<X; ++j) {\n\tcin>>in;\n\tcourse[i][j] = in;\n      }\n    }\n\n    for(int i=Y-1; i>=0; --i) {\n      for(int j=X-1; j>=0; --j) {\n\tif(i==Y-1) {\n\t  if(course[i][j] == 0 || course[i][j] == 2)\n\t    pattern[i][j] = 1;\n\t} else if(i == Y-2 && course[i][j] == 2){\n\t  pattern[i][j] = 1;\n\t} else {\n\t  if(course[i][j] == 0) {\n\t    pattern[i][j] = pattern[i+1][j];\n\t    if(j > 0 && course[i+1][j-1] == 0)\n\t      pattern[i][j] += pattern[i+1][j-1];\n\t    if(j < X-1 && course[i+1][j+1] == 0)\n\t      pattern[i][j] += pattern[i+1][j+1];\n\t  }\n\t  if(course[i][j] == 2 && course[i+2][j] != 1) {\n\t    pattern[i][j] = pattern[i+2][j];\n\t  }\n\t}\n      }\n    }\n\n    /*\n    cout<<endl;\n    for(int i=0; i<Y; ++i) {\n      for(int j=0; j<X; ++j) {\n\tcout<<pattern[i][j]<<\" \";\n      }\n      cout<<endl;\n    }\n    cout<<endl;\n    */\n    int sum = 0;\n    for(int i=0; i<X; ++i) {\n      //cout<<pattern[0][i]<<\" \";\n      sum += pattern[0][i];\n    }\n    //cout<<endl;\n    cout<<sum<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n\ntypedef long long LL;\ntemplate<typename T> using V = std::vector<T>;\ntemplate<typename T> using VV = std::vector<std::vector<T>>;\ntemplate<typename T> using VVV = std::vector<std::vector<std::vector<T>>>;\n\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline void print_vec(const std::vector<T> &v) { for (int i = 0; i < v.size(); ++i) {  if (i != 0) {std::cout << \" \";} std::cout << v[i];} std::cout << \"\\n\"; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\ntemplate<class T> inline double euclidean_distance(T y1, T x1, T y2, T x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\ntemplate<class T> inline double manhattan_distance(T y1, T x1, T y2, T x2) { return abs(x1 - x2) + abs(y1 - y2); }\n\nconst int INF = 1L << 30;\nconst double EPS = 1e-9;\nconst std::string YES = \"YES\", Yes = \"Yes\", NO = \"NO\", No = \"No\";\nconst std::vector<int> dy4 = { 0, 1, 0, -1 }, dx4 = { 1, 0, -1, 0 };    // 4近傍（右, 下, 左, 上）\nconst std::vector<int> dy8 = { 0, -1, 0, 1, 1, -1, -1, 1 }, dx8 = { 1, 0, -1, 0, 1, 1, -1, -1 };\n\nusing namespace std;\n\n\nint main() {\n    cin.tie(0);\n\tios::sync_with_stdio(false);\n\n    while (true) {\n        int X, Y;\n        cin >> X >> Y;\n        if (X == 0 or Y == 0) {\n            break;\n        }\n\n        vector<vector<int>> f(Y, vector<int>(X));\n        FOR(y, 0, Y) {\n            FOR(x, 0, X) {\n                cin >> f[y][x];\n            }\n        }\n\n        vector<vector<int>> dp(Y, vector<int>(X));\n        FOR(x, 0, X) {\n            if (f[0][x] == 0) {\n                dp[0][x] = 1;\n            }\n        }\n\n        FOR(y, 0, Y - 1) {\n            FOR(x, 0, X) {\n                if (f[y][x] == 0) {\n                    if (x - 1 >= 0 and f[y + 1][x - 1] != 1 and f[y + 1][x - 1] != 2) {\n                        dp[y + 1][x - 1] += dp[y][x];\n                    }\n                    if (f[y + 1][x] != 1) {\n                        dp[y + 1][x] += dp[y][x];\n                    }\n                    if (x + 1 < f[0].size() and f[y + 1][x + 1] != 1 and f[y + 1][x + 1] != 2) {\n                        dp[y + 1][x + 1] += dp[y][x];\n                    }\n                }\n                else if (f[y][x] == 1) {\n\n                }\n                else if (f[y][x] == 2) {\n                    if (y + 2 < f.size()) {\n                        dp[y + 2][x] += dp[y][x];\n                    }\n                    else {\n                        dp[y + 1][x] += dp[y][x];\n                    }\n                }\n            }\n        }\n\n        LL ans = 0;\n        FOR(x, 0, X) {\n            ans += dp[Y - 1][x];\n        }\n        print(ans);\n    }\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\n\nusing namespace std;\n\n\n\tint n,m;\n\tint masu[17][17];\n\tint ura[17][17];\n\t\nint motom(){\n\t\tfor(int i=0;i<17;i++){\n\t\t\tfor(int j=0;j<17;j++){\n\t\t\t\tmasu[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tswitch(ura[1][i]){\n\t\t\t\tcase 0:masu[1][i]+=1;break;\n\t\t\t\tcase 1:masu[1][i]+=0;break;\n\t\t\t\tcase 2:masu[1][i]+=1;break;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfor(int j=1;j<=m;j++){\n\t\t\t\tif(ura[i][j]==0){\n\t\t\t\t\tif(ura[i+1][j-1]==0){\n\t\t\t\t\t\tmasu[i+1][j-1]+=masu[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tif(ura[i+1][j]!=1){\n\t\t\t\t\t\tmasu[i+1][j]+=masu[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tif(ura[i+1][j+1]==0){\n\t\t\t\t\t\tmasu[i+1][j+1]+=masu[i][j];\n\t\t\t\t\t}\n\t\t\t\t}else if(ura[i][j]==2){\n\t\t\t\t\tif(ura[i+2][j]!=1){\n\t\t\t\t\t\tmasu[i+2][j]+=masu[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cont=0;\n\t\tfor(int i=n;i<=n+1;i++){\n\t\t\tfor(int j=1;j<=m;j++){\n\t\t\t\tcont+=masu[i][j];\n\t\t\t}\n\t\t}\n\t\treturn cont;\n}\n\nint main(){\n\tsrand(time(NULL));\n\tint cc=0;\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0 && m==0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i=0;i<17;i++){\n\t\t\tfor(int j=0;j<17;j++){\n\t\t\t\tmasu[i][j]=0;\n\t\t\t\tura[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=1;j<=m;j++){\n\t\t\t\tscanf(\"%d\",&ura[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",motom());\n\t}\n\t\n}#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\n\nusing namespace std;\n\n\n\tint n,m;\n\tint masu[17][17];\n\tint ura[17][17];\n\t\nint motom(){\n\t\tfor(int i=0;i<17;i++){\n\t\t\tfor(int j=0;j<17;j++){\n\t\t\t\tmasu[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tswitch(ura[1][i]){\n\t\t\t\tcase 0:masu[1][i]+=1;break;\n\t\t\t\tcase 1:masu[1][i]+=0;break;\n\t\t\t\tcase 2:masu[1][i]+=1;break;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfor(int j=1;j<=m;j++){\n\t\t\t\tif(ura[i][j]==0){\n\t\t\t\t\tif(ura[i+1][j-1]==0){\n\t\t\t\t\t\tmasu[i+1][j-1]+=masu[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tif(ura[i+1][j]!=1){\n\t\t\t\t\t\tmasu[i+1][j]+=masu[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tif(ura[i+1][j+1]==0){\n\t\t\t\t\t\tmasu[i+1][j+1]+=masu[i][j];\n\t\t\t\t\t}\n\t\t\t\t}else if(ura[i][j]==2){\n\t\t\t\t\tif(ura[i+2][j]!=1){\n\t\t\t\t\t\tmasu[i+2][j]+=masu[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cont=0;\n\t\tfor(int i=n;i<=n+1;i++){\n\t\t\tfor(int j=1;j<=m;j++){\n\t\t\t\tcont+=masu[i][j];\n\t\t\t}\n\t\t}\n\t\treturn cont;\n}\nint contt;\nvoid saiki(int x,int y){\n\tif(y<1||y>m){\n\t\treturn;\n\t}\n\t\n\t\tmasu[x][y]++;\n\tif(x>n-1){\n\t\tcontt++;\n\t\treturn;\n\t}\n\tif(ura[x][y]==0){\n\t\tif(ura[x+1][y-1]==0){\n\t\t\tsaiki(x+1,y-1);\n\t\t}\n\t\tif(ura[x+1][y]!=1){\n\t\t\tsaiki(x+1,y);\n\t\t}\n\t\tif(ura[x+1][y+1]==0){\n\t\t\tsaiki(x+1,y+1);\n\t\t}\n\t}\n\tif(ura[x][y]==2){\n\t\tif(ura[x+2][y]!=1){\n\t\t\tsaiki(x+2,y);\n\t\t}\n\t}\n}\nint simu(){\n\t\tfor(int i=0;i<17;i++){\n\t\t\tfor(int j=0;j<17;j++){\n\t\t\t\tmasu[i][j]=0;\n\t\t\t}\n\t\t}\n\tcontt=0;\n\tfor(int i=1;i<=m;i++){\n\t\tif(ura[1][i]!=1){\n\t\t\tsaiki(1,i);\n\t\t}\n\t}\n\t/*\n\tputs(\"\");\n\tfor(int i=1;i<=n+1;i++){\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tprintf(\"%d \",masu[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}*/\n\treturn contt;\n}\n\nint main(){\n\tsrand(time(NULL));\n\tint cc=0;\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0 && m==0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i=0;i<17;i++){\n\t\t\tfor(int j=0;j<17;j++){\n\t\t\t\tmasu[i][j]=0;\n\t\t\t\tura[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=1;j<=m;j++){\n\t\t\t\tscanf(\"%d\",&ura[i][j]);\n\t\t\t}\n\t\t}\n\t\tint aa=motom();\n\t\t\n\t\tprintf(\"%d\\n\",aa);\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n\tint x, y;\n\twhile(cin >> x >> y) {\n\t\tif (x == 0 && y == 0) {\n\t\t\tbreak;\n\t\t}\n\tvector< vector<int> > data(y+1, vector<int>(x, 0));\n\tvector< vector<long long int> > cc(y+1, vector<long long int>(x, 0));\n\tfor (int i = 0; i < y; i++) {\n\t\tfor (int j = 0; j < x; j++) {\n\t\t\tcin >> data[i][j];\n\t\t\tif (i == 0 && data[i][j] != 1) {\n\t\t\t\tcc[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tlong long int ccc = 0;\n\tfor (int i = 0; i < y-1; i++) {\n\t\tfor (int j = 0; j < x; j++) {\n\t\t\tif (data[i][j] == 0) {\n\t\t\t\tif (i+1 < y+1) {\n\t\t\t\t\tif (j-1 >= 0) {\n\t\t\t\t\t\tif (data[i+1][j-1] == 0) {\n\t\t\t\t\t\t\tcc[i+1][j-1] += cc[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t} \n\t\t\t\t\tif (j+1 < x) {\n\t\t\t\t\t\tif (data[i+1][j+1] == 0) {\n\t\t\t\t\t\t\tcc[i+1][j+1] += cc[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (data[i+1][j] != 1) {\n\t\t\t\t\t\tcc[i+1][j] += cc[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (data[i][j] == 2) {\n\t\t\t\tif (i+2 < y+1) {\n\t\t\t\t\tif (data[i+2][j] != 1) {\n\t\t\t\t\t\tcc[i+2][j] += cc[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << i << ' ' << j << endl;\n\t\t}\n\t}\n\t//cout << 'a' << endl;\n\t/*\n\tcout << endl;\n\tfor (int i = 0; i < y+2; i++) {\n\t\tfor (int j = 0; j < x; j++) {\n\t\t\tcout << cc[i][j] << ' ';\n\t\t}\n\t\tcout << endl;\n\t}*/\n\tfor (int i = 0; i < x; i++) {\n\t\tccc += cc[y][i]+cc[y-1][i];\n\t}\n\tcout << ccc << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) (r).begin(),(r).end()\n#define gsort(st,en) sort((st),(en),greater<int>())\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing dict = map<string,int>;\nusing pii = pair<int,int> ;\n\nconst int mod = 1000000007;\nconstexpr int imax = ((1<<30)-1)*2+1 ;\nconstexpr int inf = 100000000;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {1,1,1,1};\nconst int dx[] = {-1,0,1,0};\n\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\n\ntemplate<typename T>\nvoid Unique(vector<T> &v){\n  sort(all(v));\n  v.erase(unique(all(v)),v.end());\n}\n\ntemplate<typename T>\nT ston(string& str, T n){\n  istringstream sin(str) ;\n  T num ;\n  sin >> num ;\n  return num ;\n}\n\nvoid Ans(bool f){\n  if(f) cout << \"YES\"<<endl;\n  else cout << \"NO\"<<endl;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int x,y;\n  while(cin >> x >> y&&x&&y){\n    vector<vector<ll>> grid(x+1,vector<ll>(y+1,0));\n    vector<vector<ll>> dp(x+3,vector<ll>(y+3,0));\n    rep(i,y){\n      rep(j,x){\n        cin >> grid[j][i];\n      }\n    }\n    rep(i,x){\n      dp[i][0] = grid[i][0] == 0;\n    }\n    rep(i,y){\n      rep(j,x){\n        if(grid[j][i] == 0){\n          rep(k,3){\n            int nx = j+dx[k],ny = i+dy[k];\n            if(value(j+dx[k],i+dy[k],x,y)){\n              if(grid[nx][ny] == 0){\n                dp[nx][ny] += dp[j][i];\n              }\n              else if(grid[nx][ny] == 2 && k == 1){\n                dp[nx][ny] += dp[j][i];\n              }\n            }\n          }\n        }\n        else if(grid[j][i] == 2 && grid[j][i+2] != 1){\n          dp[j][i+2] += dp[j][i];\n        }\n      }\n    }\n    ll ans = 0;\n    rep(i,x){\n      ans += dp[i][y]+dp[i][y-1];\n    }\n//     cout << endl;\n//     rep(j,y+1){\n//       rep(i,x){\n// //         ans += dp[i][y];\n//         cout << dp[i][j]<< \" \";\n//       }\n//       cout << endl;\n//     }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n\tint n,m;\n\tint masu[17][17];\n\tint ura[17][17];\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0 && m==0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i=0;i<17;i++){\n\t\t\tfor(int j=0;j<17;j++){\n\t\t\t\tmasu[i][j]=0;\n\t\t\t\tura[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=1;j<=m;j++){\n\t\t\t\tscanf(\"%d\",&ura[i][j]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tswitch(ura[1][i]){\n\t\t\t\tcase 0:masu[1][i]+=1;break;\n\t\t\t\tcase 1:masu[1][i]+=0;break;\n\t\t\t\tcase 2:if(ura[3][i]==0){masu[3][i]+=1;}break;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfor(int j=1;j<=m;j++){\n\t\t\t\tif(ura[i][j]==0){\n\t\t\t\t\tif(ura[i+1][j-1]==0){\n\t\t\t\t\t\tmasu[i+1][j-1]+=masu[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tif(ura[i+1][j]!=1){\n\t\t\t\t\t\tmasu[i+1][j]+=masu[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tif(ura[i+1][j+1]==0){\n\t\t\t\t\t\tmasu[i+1][j+1]+=masu[i][j];\n\t\t\t\t\t}\n\t\t\t\t}else if(ura[i][j]==2){\n\t\t\t\t\tif(ura[i+2][j]!=1){\n\t\t\t\t\t\tmasu[i+2][j]+=masu[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cont=0;\n\t\tfor(int i=n;i<=n+1;i++){\n\t\t\tfor(int j=1;j<=m;j++){\n\t\t\t\tcont+=masu[i][j];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",cont);\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n  while(1){\n    int w,h,mp[20][20]={},dp[20][20] ={};\n    cin >> w >> h;\n    if(w==0 && h==0) break;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++) cin >> mp[i][j];\n    for(int i=0;i<w;i++) dp[0][i] = 1;\n\n    int ans=0;    \n    for(int i=0;i<h-1;i++)\n      for(int j=0;j<w;j++) {\n\tif(mp[i][j] !=0) break;\n\tfor(int k=-1;k<=1;k++){\n\t  int nx=j+k,ny=i+1;\n\t  if(nx<0||nx>=w) continue;\n\t  while(k==0 && mp[ny][nx]==2) ny+=2;\n\t  if(mp[ny][nx]!=0) continue;\n\t  dp[ny][nx]+= dp[i][j];\n\t}\n      }\n    for(int i=h-1;i<=19;i++)\n      for(int j=0;j<w;j++) ans+=dp[i][j];\n    cout << ans <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint dmap[15][15];\nint dpmap[15][15];\nint dfs(int, int, int);\nint dx[]={-1, 0, 1};\nint h, w;\n\nint main(){\n  while(1){\n    cin >> w >> h;\n    if(w==0 && h==0) break;\n\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin >> dmap[i][j];\n      }\n    }\n\n\n    int ans=0;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tdpmap[i][j]=-1;\n      }\n    }\n    for(int i=0;i<w;i++){\n      if(dmap[0][i]==0){\n\tint tmp=dfs(0,i,1);\n\tif(tmp>0) ans+=tmp;\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n\nint dfs(int y, int x, int d){\n  int sum=0;\n  if(y>=h){\n    return 1;\n  }\n  else if(dmap[y][x]==1){\n    dpmap[y][x]=0;\n    return 0;\n  }\n  else if(dmap[y][x]==2){\n    if(d==1){\n      if(y==h-2){\n\tdpmap[y][x]=1;\n\treturn 1;\n      }\n      if(dpmap[y+2][x]!=-1){\n\tsum+=dpmap[y+2][x];\n\tdpmap[y][x]=sum;\n\treturn sum;\n      }\n      else{\n\tsum+=dfs(y+2, x, 1);\n\tdpmap[y][x]=sum;\n\treturn sum;\n      }\n    }\n    else{\n      return 0;\n    }\n  }\nelse if(y==h-1){\n    sum+=dfs(y+1, x, 1);\n    dpmap[y][x]=sum;\n    return sum;\n  }\n else{\n    for(int i=0;i<3;i++){\n      int tx=x+dx[i];\n      int ty=y+1;\n      if(tx<0 || tx>=w) continue;\n      if(dmap[ty][tx]==1) continue;\n      if(dmap[ty][tx]==2 && i!=1) continue;\n      if(dpmap[ty][tx]!=-1){\n\tsum+=dpmap[ty][tx];\n      }\n      else sum+=dfs(ty, tx, i);\n    }\n  }\n  dpmap[y][x]=sum;\n  return sum;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<math.h>\nint main(void)\n{\n\tint a,s,d[20][20],f,j,i,k;\n\tlong long int g,h[20][20];\n\twhile(1){\n\t\tscanf(\"%d %d\",&a,&s);\n\t\tif(a==0&&s==0) break;\n\t\tfor(i=0;i<s;i++) h[0][i]=1;\n\t\tfor(i=0;i<a;i++){\n\t\t\tfor(j=0;j<s;j++) scanf(\"%d\",&d[i][j]);\n\t\t}\n\t\tfor(i=0;i<s;i++){\n\t\t\tif(d[0][i]==1) h[0][i]=0;\n\t\t}\n\t\tfor(i=1;i<a;i++){\n\t\t\tfor(j=0;j<s;j++) h[i][j]=0;\n\t\t}\n\t\tfor(i=0;i<a;i++){\n\t\t\tfor(j=0;j<s;j++){\n\t\t\t\tif(i!=0&&d[i+1][j]==1&&d[i][j]==2){\n\t\t\t\t\tif(i+2<a) h[i+2][j]+=h[i][j];\n\t\t\t\t\telse h[i+1][j]+=h[i][j];\n\t\t\t\t}\n\t\t\t\tif(h[i][j]!=0){\n\t\t\t\t\tif(d[i][j]==0) if(j!=0) if(d[i+1][j-1]==0) h[i+1][j-1]+=h[i][j];\n\t\t\t\t\tif(j!=s){\n\t\t\t\t\t\tif(d[i][j]==0) if(d[i+1][j+1]==0) h[i+1][j+1]+=h[i][j];\n\t\t\t\t\t\tif(d[i+1][j]==0||d[i+1][j]==2) h[i+1][j]+=h[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tg=0;\n\t\tfor(j=0;j<s;j++) g+=h[a-1][j];\n\t\t/*printf(\"\\n\\n\");\n\t\tfor(i=0;i<a;i++){\n\t\t\tfor(j=0;j<s;j++) printf(\"%d \",h[i][j]);\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\tprintf(\"%d\\n\",g);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int X, Y;\n    while (cin >> X >> Y, (X || Y)) {\n        vector<vector<int>> sketch(Y, vector<int>(X, 0));\n        for (int i=0; i<Y; ++i) {\n            for (int j=0; j<X; ++j) {\n                cin >> sketch[i][j];\n            }\n        }\n        int dp[15][15] = {};\n        int pattern = 0;\n        for (int i=0; i<Y; ++i) {\n            for (int j=0; j<X; ++j) {\n                if (i == 0 && sketch[i][j] == 0) {\n                    dp[i][j] = 1;\n                }\n                if (sketch[i][j] == 0) {\n                    if (Y <= i+1) {\n                        pattern += dp[i][j];\n                        continue;\n                    }\n                    if (0 <= j-1 && sketch[i+1][j-1] == 0) {\n                        dp[i+1][j-1] += dp[i][j];\n                    }\n                    if (sketch[i+1][j] == 0 || sketch[i+1][j] == 2) {\n                        dp[i+1][j] += dp[i][j];\n                    }\n                    if (j+1 < X && sketch[i+1][j+1] == 0) {\n                        dp[i+1][j+1] += dp[i][j];\n                    }\n                } else if (sketch[i][j] == 2) {\n                    if (Y <= i+2) {\n                        pattern += dp[i][j];\n                        continue;\n                    }\n                    if (sketch[i+2][j] == 0 || sketch[i+2][j] == 2) {\n                        dp[i+2][j] += dp[i][j];\n                    }\n                }\n            }\n        }\n        cout << pattern << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 基本テンプレート\n \n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\nusing namespace std;\n \n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {1, 1, 1};\nint dy[] = {-1, 0, 1};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nint board[20][20], dp[30][30];\n \nsigned main() {\n    int W, H;\n    while(cin >> W >> H, W || H) {\n        for(int i=0; i<H; i++) {\n            for(int j=0; j<W; j++) {\n                cin >> board[i][j];\n            }\n        }\n\n        memset(dp, 0, sizeof(dp));\n        for(int i=0; i<W; i++) if(board[0][i] == 0) dp[0][i] = 1;\n\n        int ans = 0;\n        for(int i=0; i<H-1; i++) {\n            for(int j=0; j<W; j++) {\n                for(int k=0; k<3; k++) {\n                    if(board[i][j] == 2 and k != 1) continue;\n                    int dbl = (board[i][j] == 2 ? 2 : 1);\n\n                    int ni = i + dx[k] * dbl, nj = j + dy[k];\n                    if(ni < 0 or nj < 0 or nj >= W) continue;\n                    if(board[ni][nj] == 1) continue;\n                    if(board[ni][nj] == 2 and k != 1) continue;\n\n                    if(ni < H - 1) {\n                        dp[ni][nj] += dp[i][j];\n                    }\n                    else {\n                        ans += dp[i][j];\n                    }\n                }\n            }\n        }\n\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n\nint X, Y;\nint field[16][15];\nint dp[16][15];\n\nint main()\n{\n\twhile( std::cin >> X >> Y, X | Y )\n\t{\n\t\tmemset( field, 0, sizeof( field ) );\n\t\tmemset( dp, 0, sizeof( dp ) );\n\n\t\tfor( int i = 0; i != Y; ++i )\n\t\t\tfor( int j = 0; j != X; ++j )\n\t\t\t\tstd::cin >> field[i][j];\n\n\t\tfor( int i = 0; i != X; ++i )\n\t\t\tdp[0][i] = field[0][i] != 1;\n\t\t\n\t\tint ans = 0;\n\t\tfor( int i = 1; i <= Y; ++i )\n\t\t{\n\t\t\tfor( int j = 0; j != X; ++j )\n\t\t\t{\n\t\t\t\tif( i < Y && field[i][j] != 1 )\n\t\t\t\t{\n\t\t\t\t\tfor( int k = -1; k <= 1; ++k )\n\t\t\t\t\t{\n\t\t\t\t\t\tif( field[i][j] == 2 && k != 0 )\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif( j + k >= 0 && j + k < X && !field[i-1][j+k] )\n\t\t\t\t\t\t\tdp[i][j] += dp[i-1][j+k];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif( i - 2 > 0 && field[i-2][j] == 2 )\n\t\t\t\t\tdp[i][j] += dp[i-2][j];\n\t\t\t\n\t\t\t\tif( i >= Y - 1 )\n\t\t\t\t\tans += dp[i][j];\n\t\t\t}\n\t\t}\n\n\t\tstd::cout << ans << std::endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\n#define MAX_XY 16\n\nint X, Y;\nint field[MAX_XY][MAX_XY];\nint way[MAX_XY][MAX_XY];\n\nint main() {\n\twhile (cin >> X >> Y, X || Y) {\n\t\tmemset(field, 0, sizeof(field));\n\t\tmemset(way, 0, sizeof(way));\n\t\tfor (int i = 0; i < X; i++) {\n\t\t\tcin >> field[0][i];\n\t\t\tif (field[0][i] == 1) {\n\t\t\t\tway[0][i] = 0;\n\t\t\t} else {\n\t\t\t\tway[0][i] = 1;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 1; i < Y; i++) {\n\t\t\tfor (int j = 0; j < X; j++) {\n\t\t\t\tcin >> field[i][j];\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < Y-1; i++) {\n\t\t\tfor (int j = 0; j < X; j++) {\n\t\t\t\tif (field[i][j] == 2) {\n\t\t\t\t   \tif (field[i+2][j] != 1) {\n\t\t\t\t\t\tway[i+2][j] += way[i][j];\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (1 <= j && field[i+1][j-1] == 0) {\n\t\t\t\t\t\tway[i+1][j-1] += way[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tif (j < X-1 && field[i+1][j+1] == 0) {\n\t\t\t\t\t\tway[i+1][j+1] += way[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tif (field[i+1][j] != 1) {\n\t\t\t\t\t\tway[i+1][j] += way[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n//\t\tfor (int i = 0; i < Y; i++) {\n//\t\t\tfor (int j = 0; j < X; j++) {\n//\t\t\t\tcout << way[i][j] << ' ';\n//\t\t\t}\n//\t\t\tcout << endl;\n//\t\t}\n\n\t\tint cnt = 0;\n\t\tfor (int i = 0; i < X; i++) {\n\t\t\tcnt += way[Y-1][i];\n\t\t}\n\t\tfor (int i = 0; i < X; i++) {\n\t\t\tif (field[Y-2][i] == 2) cnt += way[Y-2][i];\n\t\t}\n\n\t\tcout << cnt << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nint dw[3] = {-1,0,1};\n\nint main(){\n    int w,h;\n\n    while(cin >> w >> h){\n        if(!(w|h)) break;\n        int field[h+2][w+2];\n        int dp[h+2][w+2];\n        int kind;\n        long long ret=0;\n        fill((int *)field, (int *)field+(h+2)*(w+2), 1);\n        fill((int *)dp, (int *)dp+(h+2)*(w+2), 0);\n\n        for(int i=1;i<=h;i++){\n            for(int j=1;j<=w;j++){\n                cin >> field[i][j];\n            }\n        }\n\n        for(int i=1;i<=w;i++){\n            if(field[1][i] == 0) dp[1][i] = 1;\n        }\n        for(int i=1;i<=h;i++){\n            for(int j=1;j<=w;j++){\n                kind = field[i][j];\n                if(kind == 0){\n                    for(int k=0;k<3;k++){\n                        if(field[i+1][j+dw[k]] == 0 || \n                           (field[i+1][j+dw[k]] == 2 && k == 1)){\n                            dp[i+1][j+dw[k]] += dp[i][j];\n                        }\n                    }\n                }else if(kind == 2){\n                    if(i != h-1){\n                        dp[i+2][j] += dp[i][j];\n                    }else{\n                        ret += dp[i][j];\n                    }\n                }\n            }\n        }\n\n        for(int i=1;i<=w;i++){\n            ret += dp[h][i];\n        }\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint x,y,a[17][17],s,i,j;\nvoid dfs(int y1,int x1){\n  if(x1<1||x1>x)return;\n  if(y1>=y){s++;return;}\n  if(a[y1][x1]==2)dfs(y1+2,x1);\n  else {if(a[y1+1][x1]!=1)dfs(y1+1,x1);\n  if(a[y1+1][x1+1]==0)dfs(y1+1,x1+1);\n  if(a[y1+1][x1-1]==0)dfs(y1+1,x1-1);}\n  return;\n}\nint main(){\n  while(cin>>x>>y,x){\n    for(s=0,i=0;i<17;i++)for(j=0;j<17;j++)a[i][j]=0;    \n    for(s=0,i=1;i<=y;i++)for(j=1;j<=x;j++)cin>>a[i][j];\n    for(i=1;i<=x;i++){if(a[1][i]==0)dfs(1,i);}\n    cout<<s<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint maps[20][20];\nint course[20][20];\nint X, Y;\n\nint way(int y, int x){\n  if(y >= Y) return 1;\n  else if(course[y][x] > 0) return course[y][x];\n  else if(maps[y][x] == 1) return 0;\n  else if(maps[y][x] == 2 && maps[y + 2][x] != 1) return course[y][x] = way(y + 2, x);\n  else{\n    int SUM = 0;\n    for(int i = 0; i < 3; i++){\n      int ny = y + 1;\n      int nx = x - 1 + i;\n      if(maps[ny][nx] != 1 && 1 <= nx && nx <= X){\n\tint flug = 1;\n\tif(i != 1 && maps[ny][nx] == 2) flug = 0;\n\tif(flug) SUM += way(ny, nx);\n      }\n    }\n    return course[y][x] = SUM;\n  }\n} \n\nint main(){\n  while(1){\n    cin >> X >> Y;\n    if(X == 0 && Y == 0) break;\n    for(int i = 1; i <= Y; i++){\n      for(int j = 1; j <= X; j++){\n\tcin >> maps[i][j];\n\tcourse[i][j] = 0;\n      }\n    }\n    int cnt = 0;\n    for(int i = 1; i <= X; i++){\n      if(maps[0][i] != 1) cnt += way(1, i);\n    }\n    cout << cnt << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n\nusing namespace std;\n\n\nint main() {\n\twhile(1) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tif(x==0 && y==0) break;\n\t\tint field[x][y];\n\t\tfor(int i=0; i<x; i++) {\n\t\t\tfor(int j=0; j<y; j++) {\n\t\t\t\tcin >> field[i][j];\n\t\t\t}\n\t\t}\n\t\tint dp[x+1][y];\n\t\tfor(int i=0; i<x+1; i++) {\n\t\t\tfor(int j=0; j<y; j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<x; i++) {\n\t\t\tfor(int j=0; j<y; j++) {\n\t\t\t\tif(i==0 && field[i][j] == 0) dp[i][j] = 1;\n\t\t\t\telse {\n\t\t\t\t\tif(field[i][j] == 0) {\n\t\t\t\t\t\tif(0<j && field[i-1][j-1] == 0) dp[i][j] += dp[i-1][j-1];\n\t\t\t\t\t\tif(field[i-1][j] == 0) dp[i][j] += dp[i-1][j];\n\t\t\t\t\t\tif(j<y-1 && field[i-1][j+1] == 0) dp[i][j] += dp[i-1][j+1];\n\t\t\t\t\t}\n\t\t\t\t\tif(field[i][j] == 2) {\n\t\t\t\t\t\tdp[i][j] += dp[i-1][j];\n\t\t\t\t\t\tdp[i+2][j] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<y; i++) dp[x][i] += dp[x-1][i];\n\t\tint sum=0;\n\t\tfor(int i=0; i<y; i++) sum += dp[x][i];\n\t\tcout << sum << endl;\n\n//\t\tfor(int i=0; i<x+1; i++) {\n//\t\t\tfor(int j=0; j<y; j++) {\n//\t\t\t\tcout << dp[i][j] << ' ';\n//\t\t\t}\n//\t\t\tcout << endl;\n//\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint n,m;\nint i,j;\nint c[15][15],d[15][15];\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d %d\",&m,&n);\n\t\tif(n==0&&m==0)return 0;\n\t\tint ans=0;\n\t\tfor(i=0;i<n;i++)for(j=0;j<m;j++)scanf(\"%d\",&c[i][j]);\n\t\tfor(i=0;i<n;i++)for(j=0;j<m;j++){\n\t\t\td[i][j]=0;\n\t\t}\n\t\tfor(i=0;i<m;i++)if(c[0][i]!=1)d[0][i]=1;\n\t\tfor(i=0;i<n;i++)for(j=0;j<m;j++){\n\t\t\tif(c[i][j]==0){\n\t\t\t\tif(j-1>=0&&j-1<m&&i+1<n&&c[i+1][j-1]==0)d[i+1][j-1]+=d[i][j];\n\t\t\t\tif(j+1>=0&&j+1<m&&i+1<n&&c[i+1][j+1]==0)d[i+1][j+1]+=d[i][j];\n\t\t\t\tif(i+1<n&&c[i+1][j]!=1)d[i+1][j]+=d[i][j];\n\t\t\t}\n\t\t\tif(c[i][j]==2){\n\t\t\t\tif(i+2<n&&c[i+2][j]!=1)d[i+2][j]+=d[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<n;i++)if(c[n-2][i]==2)ans+=d[n-2][i];\n\t\tfor(i=0;i<n;i++)if(c[n-1][i]!=1)ans+=d[n-1][i];\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}\n\t\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\n#define MAX_XY 16\n\nint X, Y;\nint field[MAX_XY][MAX_XY];\nint way[MAX_XY][MAX_XY];\n\nint main() {\n\twhile (cin >> X >> Y, X || Y) {\n\t\tmemset(field, 0, sizeof(field));\n\t\tmemset(way, 0, sizeof(way));\n\t\tfor (int i = 0; i < X; i++) {\n\t\t\tcin >> field[0][i];\n\t\t\tif (field[0][i] == 1) {\n\t\t\t\tway[0][i] = 0;\n\t\t\t} else {\n\t\t\t\tway[0][i] = 1;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 1; i < Y; i++) {\n\t\t\tfor (int j = 0; j < X; j++) {\n\t\t\t\tcin >> field[i][j];\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < Y-1; i++) {\n\t\t\tfor (int j = 0; j < X; j++) {\n\t\t\t\tif (field[i][j] == 2 && field[i+2][j] != 1) {\n\t\t\t\t\tway[i+2][j] += way[i][j];\n\t\t\t\t} else {\n\t\t\t\t\tif (1 <= j && field[i+1][j-1] == 0) {\n\t\t\t\t\t\tway[i+1][j-1] += way[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tif (j < X-1 && field[i+1][j+1] == 0) {\n\t\t\t\t\t\tway[i+1][j+1] += way[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tif (field[i+1][j] != 1) {\n\t\t\t\t\t\tway[i+1][j] += way[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n//\t\tfor (int i = 0; i < Y; i++) {\n//\t\t\tfor (int j = 0; j < X; j++) {\n//\t\t\t\tcout << way[i][j] << ' ';\n//\t\t\t}\n//\t\t\tcout << endl;\n//\t\t}\n\n\t\tint cnt = 0;\n\t\tfor (int i = 0; i < X; i++) {\n\t\t\tcnt += way[Y-1][i];\n\t\t}\n\t\tfor (int i = 0; i < X; i++) {\n\t\t\tif (field[Y-2][i] == 2) cnt += way[Y-2][i];\n\t\t}\n\n\t\tcout << cnt << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <set>\n#include <map>\n#include <list>\n#include <iterator>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <string>\n#include <cmath>\n#include <complex>\n#include <functional>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n#include <cstdlib>\n#include <cctype>\n#include <bitset>\n\n#define REP(i,m,n) for(int i=m;i<(int)n;i++)\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define rrep(i,n) for(int i = 1; i <= n; i++)\n#define drep(i,n) for(int i = n; i >= 0; i--)\n#define rp(i,c) rep(i,(int)c.size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define mp make_pair\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define v_delete(a,b) (a).erase(remove((a).begin(), (a).end(), b), (a).end())\n#define v_unique(a) (a).erase(unique((a).begin(), (a).end()), (a).end())\n#define VV(T) vector<vector< T > >\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\nconst int inf=1<<28;\nconst double INF=1e10,EPS=1e-9;\n\n\ntemplate<class T>int SIZE(T a){return a.size();}\ntemplate<class T>string IntToString(T num){string res;stringstream ss;ss<<num;return ss.str();}\ntemplate<class T>T StringToInt(string str){T res=0;for(int i=0;i<SIZE(str);i++)res=(res*10+str[i]-'0');return res;}\ntemplate<class T>T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate<class T>T lcm(T a,T b){return a/gcd(a,b)*b;}\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nint chmax(int& a,int b){\n\tif(b > a){\n\t\ta=b;\n\t}\n\treturn a;\n}\nint chmin(int& a,int b){\n\tif(b < a){\n\t\ta=b;\n\t}\n\treturn a;\n}\n\nint X,Y;\nint m[18][18];\nint dp[20][20];\n\n\nint main(int argc, char const *argv[])\n{\n\twhile(cin >> X >> Y, X){\n\t\tmemset(m, -1 ,sizeof(m));\n\t\tmemset(dp, 0 ,sizeof(m));\n\t\trep(i,Y){\n\t\t\trep(j,X){\n\t\t\t\tcin >> m[i+1][j+1];\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=X;i++){\n\t\t\tif(m[1][i]==1)\n\t\t\t\tdp[1][i]=0;\n\t\t\telse\n\t\t\t\tdp[1][i]=1;\n\t\t}\n\t\tfor(int i=2;i<=Y;i++){\n\t\t\tfor(int j=1;j<=X;j++){\n\t\t\t\tif(m[i][j]==1){\n\t\t\t\t\tdp[i][j]=0;\n\t\t\t\t}else if(m[i][j]== 2){\n\t\t\t\t\tif(m[i-1][j]==0)\n\t\t\t\t\t\tdp[i][j] += dp[i-1][j];\n\t\t\t\t\tif(m[i-2][j]==2)\n\t\t\t\t\t\tdp[i][j] += dp[i-2][j];\n\t\t\t\t}else{\n\t\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\t\tif(m[i-1][j+k]==0){\n\t\t\t\t\t\t\tdp[i][j] += dp[i-1][j+k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(m[i-2][j]==2)\n\t\t\t\t\t\tdp[i][j] += dp[i-2][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t//\tfor(int i=1;i<=Y;i++){\n\t//\t\tfor(int j=1;j<=X;j++){\n\t//\t\t\tcout << dp[i][j] << \" \";\n\t//\t\t}\n\t//\t\tcout << endl;\n\t//\t}\n\n\t\tfor(int i=1;i<=X;i++){\n\t\t\tif(m[Y][i]==0 || m[Y][i]==2 ){\n\t\t\t\tans += dp[Y][i];\n\t\t\t}\n\t\t\tif(m[Y-1][i]==2){\n\t\t\t\tans += dp[Y-1][i];\n\t\t\t}\n\t\t}\n\t\tcout  << ans << endl;\n\n\t}\n\n\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint solve(int x,int y);\nint ax,ay;\nint mas[20][20];\nint memo[20][20];\nint main(){\n  while(1){\n    int ans=0;\n    for(int i=0;i<20;i++){\n      for(int j=0;j<20;j++){\n\tmemo[i][j]=0;\n      }\n    }\n    cin>>ax>>ay;\n    if(ax==0 && ay==0){\n      break;\n    }\n    for(int i=0;i<ay;i++){\n      for(int j=0;j<ax;j++){\n\tcin>>mas[i][j];\n      }\n    }\n    for(int i=0;i<ax;i++){\n      if(mas[0][i]!=1){\n\tans+=solve(i,0);\n      }\n    }\n    cout<<ans<<endl;\n  }\n}\nint solve(int x,int y){\n  if(memo[y][x]!=0){\n    return memo[y][x];\n  }\n  else if(y==ay){\n    return 1;\n  }else if(mas[y][x]==1){\n    return 0;\n  }else if(mas[y][x]==2){\n    return solve(x,y+2);\n  } \n  else{\n    int anss=0; \n    if(mas[y+1][x]!=1){\n      memo[y+1][x]=solve(x,y+1);\n      anss+=memo[y+1][x];\n    }\n    if(x+1<ax && mas[y+1][x+1]==0 && y+1!=ay){\n      memo[y+1][x+1]=solve(x+1,y+1);\n      anss+=memo[y+1][x+1];\n    }\n    if(0<=x-1 && mas[y+1][x-1]==0 && y+1!=ay){\n      memo[y+1][x-1]=solve(x-1,y+1);\n      anss+=memo[y+1][x-1];\n    }\n    return anss;\n  }\n}  "
  },
  {
    "language": "C++",
    "code": "\n//============================================================================\n// Problem     : AOJ0203\n// Title       : A New Plan of Aizu Ski Resort (会津山スキー場の新企画)\n// Author      : mizo0203\n// Status      : Accepted\n// Date        : Wed May 30 15:25:20\n// Copyright   : Your copyright free\n// Description : 動的計画法\n//============================================================================\n\n#include <stdio.h>\n#include <algorithm>\n\nusing namespace std;\n\nint x, y;\nint c[17][17];  // 最大15+2\n\nint dp[17][17]; // 動的計画法の計算用\n\nbool input() {\n  int i, j;\n  scanf(\"%d %d\", &x, &y);\n  if (!x && !y) return false; // x = 0 かつ y = 0 なら終了\n  fill(c[0], c[0] + 17 * 17, 1); // 配列cを1(木)で初期化\n  for (i = 1; i <= y; i++) {\n    for (j = 1; j <= x; j++) {\n      scanf(\"%d\", &c[i][j]);\n    }\n  }\n\n  return true;\n}\n\nvoid manage() {\n  int i, j, output = 0;\n\n  fill(dp[0], dp[0] + 17 * 17, 0); // 計算用配列を初期化\n  for (i = 1; i <= x; i++) {\n    if (c[1][i] != 1) dp[1][i] = 1;\n  }\n\n  for (i = 2; i <= y; i++) {\n    for (j = 1; j <= x; j++) {\n        if (c[i][j] == 0) {\n          if (c[i - 1][j - 1] == 0) dp[i][j] += dp[i - 1][j - 1];\n          if (c[i - 1][j    ] == 0) dp[i][j] += dp[i - 1][j    ];\n          if (c[i - 1][j + 1] == 0) dp[i][j] += dp[i - 1][j + 1];\n          if (c[i - 2][j    ] == 2) dp[i][j] += dp[i - 2][j    ];\n        } else if (c[i][j] == 2) {\n          if (c[i - 1][j] == 0) dp[i][j] += dp[i - 1][j];\n          if (c[i - 2][j] == 2) dp[i][j] += dp[i - 2][j];\n        }\n    }\n  }\n  \n  printf(\"\\n\");\n  for (i = 0; i < 17; i++) {\n    for (j = 0; j < 17; j++) {\n      printf(\"%d \", dp[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n  \n  for (i = 1; i <= x; i++) {\n    if (c[y - 1][i] == 2) output += dp[y - 1][i];\n    output += dp[y][i];\n  }\n  printf(\"%d\\n\", output);\n}\n\n\nint main() {\n\n  while(input()) {\n    manage();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint dfs(int x,int y);\nint mas[20][20];\nint memo[20][20];\nint X,Y;\n\nint main(){\n\twhile(1){\n\t\tcin >> X >> Y;\n\t\tif(X == 0 && Y == 0) break;\n\t\tfor(int i=0;i<20;i++){\n\t\t\tfor(int j=0;j<20;j++){\n\t\t\t\tmemo[20][20] = -1;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<Y;i++){\n\t\t\tfor(int j=0;j<X;j++){\n\t\t\t\tcin >> mas[i][j];\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i=0;i<X;i++){\n\t\t\tif(mas[0][i] == 0){\n\t\t\t\tans += dfs(i,0);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\nint dfs(int x,int y){\n\tif(memo[y][x] == -1) return memo[y][x];\n\tif(mas[y][x] == 1) return 0;\n\tif(y>=Y-1) return 1;\n\tif(mas[y][x] == 2) return (memo[y][x] = dfs(x,y+2));\n\telse{\n\t\tint cou = 0;\n\t\tfor(int i=-1;i<2;i++){\n\t\t\tint nx = x + i;\n\t\t\tint ny = y + 1;\n\t\t\tif(nx >= 0 && nx < X && ((i == 0 && mas[ny][nx] == 2) || (mas[ny][nx] == 0))){\n\t\t\t\tcou += dfs(nx,ny);\n\t\t\t}\n\t\t}\n\t\treturn (memo[y][x] = cou);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\n#define MAX 20\n\nint W,H;\nint arr[MAX][MAX];\nint dp[MAX][MAX];\nconst int dx[] = {-1,0,1};\nconst int dy[] = {1,1,1};\n\nbool inField(int y,int x){\n  return 0 <= y && y < H && 0 <= x && x < W;\n}\n\nint solve(int y,int x){\n  if(y == H-1){\n    if(arr[y][x] == 0){\n      return 1;\n    }else{\n      return 0;\n    }\n  }\n  if(dp[y][x] != -1) return dp[y][x];\n\n  int res = 0;\n  if(arr[y][x] != 2){\n    for(int i = 0 ; i < 3 ; i++){\n      int nx = x + dx[i];\n      int ny = y + dy[i];\n      if(!inField(ny,nx)) continue;\n      if(arr[ny][nx] == 1) continue;\n      if(arr[ny][nx] == 0){\n        res += solve(ny,nx);\n      }else{\n        if(x == nx){\n          res += solve(ny,nx);\n        }\n      }\n    }\n  }else{\n    int nx = x, ny = y + 2;\n    if(!inField(ny,nx)) return 1;\n    res += solve(ny,nx);\n  }\n  return dp[y][x] = res;\n}\n\nint main(){\n  while(cin >> W >> H, (W | H)){\n    for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n        cin >> arr[i][j];\n        dp[i][j] = -1;\n      }\n    }\n    int res = 0;\n    for(int i = 0 ; i < W ; i++){\n      if(arr[0][i] == 0){\n        res += solve(0,i);\n      }\n    }\n    cout << res << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#include <string.h>\n\nusing namespace std;\n\nconst int FIELD_MAX =15;\n\nint X, Y;\nint field[FIELD_MAX][FIELD_MAX];\nint table[FIELD_MAX+1][FIELD_MAX];\nint cnt = 0;\n\ntypedef pair<int, int> point;\n\nvoid solve()\n{\n\t//solve as a dynamic program problem\n\t\n\t//initialize table\n\tmemset(&table[0][0], 0, sizeof(int) * 15 * 15);\n\tfor(int x=0; x<X; x++)\n\t{\n\t\ttable[Y][x] = 1;\n\t}\n\t\n\t//you can go (x ,y) when\n\t//(1) p(x, y-2) == 2\n\t//(2) p(x-1, y-1) ==0 || p(x, y-1)==0 || p(x+1, y-1)==0\n\tfor(int y=Y; y>=1; y--)\n\t{\t\n\t\tfor(int x=0; x<X; x++){\n\t\t\tint a = 0;\n\t\t\tif(y>=2){\n\t\t\t\tif(field[y-2][x]==2) table[y-2][x]+=table[y][x];\n\t\t\t}\n\t\t\tif(x>=1 && y!=Y && field[y][x] != 2){\n\t\t\t\tif(field[y-1][x-1]==0) table[y-1][x-1]+=table[y][x];\n\t\t\t}\n\t\t\tif(field[y-1][x]==0) table[y-1][x]+=table[y][x];\n\t\t\tif(x<X-1 && y!=Y && field[y][x] != 2){\n\t\t\t\tif(field[y-1][x+1]==0) table[y-1][x+1]+=table[y][x];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcnt = 0;\n\tfor(int x=0; x<X; x++){\n\t\tcnt += table[0][x];\n\t}\n}\n\nint main()\n{\n\twhile( 1 )\n\t{\n\t\tcin >> X >> Y;\n\t\tif(X==0 && Y==0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor(int y=0; y<Y; y++)\n\t\t{\n\t\t\tfor(int x=0; x<X; x++)\n\t\t\t{\n\t\t\t\tcin >> field[y][x];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcnt = 0;\n\t\tsolve();\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nmain(){for(int X,Y,f[15][15],d[15][15],i,j;std::cin>>X>>Y,X;printf(\"%d\\n\",Y)){for(i=0;i<Y;i++)for(j=0;j<X;d[i][j++]=i==0)std::cin>>f[i][j];for(i=1;i<Y;i++)for(j=0;j<X;j++){!f[i-1][j]&&(d[i][j]+=d[i-1][j]);if(f[i][j]-2){j+1<X&!f[i-1][j+1]&&(d[i][j]+=d[i-1][j+1]);j>0&!f[i-1][j-1]&&(d[i][j]+=d[i-1][j-1]);}i>1&f[i-2][j]==2&&(d[i][j]+=d[i-2][j]);}for(Y=j=0;j<X;j++){f[i-1][j]-1&&(Y+=d[i-1][j]);i>1&f[i-2][j]==2&&(Y+=d[i-2][j]);}}}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint dp[20][20];\nint dat[20][20];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<b;i++)\n\t\t\tfor(int j=0;j<a;j++)\n\t\t\t\tscanf(\"%d\",&dat[i][j]);\n\t\tfor(int i=0;i<20;i++)\n\t\t\tfor(int j=0;j<20;j++)dp[i][j]=0;\n\t\tfor(int i=0;i<a;i++)dp[0][i]=1;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(dat[i][j]==0){\n\t\t\t\t\tif(i<b-1&&j&&dat[i+1][j-1]==0)dp[i+1][j-1]+=dp[i][j];\n\t\t\t\t\tif(i<b-1&&j<a-1&&dat[i+1][j+1]==0)dp[i+1][j+1]+=dp[i][j];\n\t\t\t\t\tif(dat[i+1][j]!=1)dp[i+1][j]+=dp[i][j];\n\t\t\t\t}\n\t\t\t\tif(dat[i][j]==2){\n\t\t\t\t\tif(dat[i+2][j]!=1)dp[i+2][j]+=dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=0;\n\t\tfor(int i=b;i<20;i++)\n\t\t\tfor(int j=0;j<a;j++)\n\t\t\t\tret+=dp[i][j];\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint dp[20][20][2];\nint x[20][20];\nint H, W;\nvoid A(int a, int b, int c, int d) {\n\tif (x[a][b] == 2) {\n\t\tif (d != 0) { return; }\n\t\tif (c == 1) { return; }\n\t\tif (c == 0) {\n\t\t\tdp[a + 2][b][0] += dp[a][b][c];\n\t\t\treturn;\n\t\t}\n\t}\n\tif (x[a + 1][b + d] == 1) { return; }\n\tif (x[a + 1][b + d] == 2 && d != 0) { return; }\n\tif (x[a][b] == 0) {\n\t\tif (d == 0) {\n\t\t\tdp[a + 1][b + d][0] += dp[a][b][c];\n\t\t}\n\t\telse {\n\t\t\tdp[a + 1][b + d][1] += dp[a][b][c];\n\t\t}\n\t}\n}\nint main() {\n\twhile (true) {\n\t\tcin >> H >> W;\n\t\tif (H == 0 && W == 0) { break; }\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\tcin >> x[i][j];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 20; i++) {\n\t\t\tfor (int j = 0; j < 20; j++) {\n\t\t\t\tdp[i][j][0] = 0;\n\t\t\t\tdp[i][j][1] = 0;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= W; i++) {\n\t\t\tif (x[1][i] == 0) {\n\t\t\t\tdp[1][i][0] = 1;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= H - 1; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\tA(i, j, 0, -1);\n\t\t\t\tA(i, j, 0, 0);\n\t\t\t\tA(i, j, 0, 1);\n\t\t\t\tA(i, j, 1, -1);\n\t\t\t\tA(i, j, 1, 0);\n\t\t\t\tA(i, j, 1, 1);\n\t\t\t}\n\t\t}\n\t\tint sum = 0;\n\t\tfor (int j = H; j < 20; j++) {\n\t\t\tfor (int i = 1; i <= W; i++) {\n\t\t\t\tsum += dp[j][i][0] + dp[j][i][1];\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nint main()\n{\n\tfor(int w,h;cin>>w>>h,w|h;){\n\t\tvvi field(h+1,vi(w));\n\t\trep(i,h) rep(j,w)\n\t\t\tcin>>field[i][j];\n\t\t\n\t\tvvi dp(h+1,vi(w));\n\t\trep(i,w)\n\t\t\tif(field[0][i]!=1)\n\t\t\t\tdp[0][i]=1;\n\t\trep(i,h-1){\n\t\t\trep(j,w){\n\t\t\t\tif(field[i][j]==1){\n\t\t\t\t\tdp[i][j]=0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(field[i][j]==2 && field[i+2][j]!=1){\n\t\t\t\t\tdp[i+2][j]+=dp[i][j];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(field[i+1][j]==2)\n\t\t\t\t\tdp[i+1][j]+=dp[i][j];\n\t\t\t\tfor(int k=-1;k<=1;k++)\n\t\t\t\t\tif(0<=j+k && j+k<w && field[i+1][j+k]==0)\n\t\t\t\t\t\tdp[i+1][j+k]+=dp[i][j];\n\t\t\t}\n\t\t}\n\t\tll res=0;\n\t\trepi(i,h-1,h+1) rep(j,w)\n\t\t\tif(field[i][j]!='1')\n\t\t\t\tres+=dp[i][j];\n\t\tcout<<res<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nint main(){\n\tint n,m;\n\tint masu[17][17];\n\tint ura[17][17];\n\tcin>>n>>m;\n\tfor(int i=0;i<17;i++){\n\t\tfor(int j=0;j<17;j++){\n\t\t\tmasu[i][j]=ura[i][j]=0;\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tcin>>masu[i][j];\n\t\t}\n\t}\n\t\n\tfor(int j=1;j<=m;j++){\n\t\tif(masu[i][j]!=1){\n\t\tura[0][j]=1;\n\t\t}\n\t}\n\t\n\t\n\tfor(int i=0;i<n-1;i++){\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tif(masu[i][j]==0){\n\t\t\t\tif(masu[i+1][j-1]==0){\n\t\t\t\t\tura[i+1][j-1]+=ura[i][j];\n\t\t\t\t}\n\t\t\t\tif(masu[i+1][j]!=1){\n\t\t\t\t\tura[i+1][j]+=ura[i][j];\n\t\t\t\t}\n\t\t\t\tif(masu[i+1][j+1]==0){\n\t\t\t\t\tura[i+1][j+1]+=ura[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(masu[i][j]==2){\n\t\t\t\tif(masu[i+2][j]!=1){\n\t\t\t\t\tura[i+2][j]+=ura[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint cont=0;\n\tfor(int i=1;i<=m;i++){\n\t\tcont+=ura[n][i]+ura[n-1][i];\n\t}\n\t\n\t/*\n\t\n\tfor(int i=0;i<17;i++){\n\t\tfor(int j=0;j<17;j++){\n\t\t\tprintf(\"%2d \",ura[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}*/\n\tprintf(\"%d\\n\",cont);\n\t\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <functional>\n#include <numeric>\n#define fi first\n#define se second\nusing namespace std;\nbool value(int y,int x,int R,int C){return 0<=y&&y<R&&0<=x&&x<C;}\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<long long > vll;\ntypedef vector< vi > vvi;\ndouble pie=acos(-1);\nint INF=10000009;\nint dx[4] = { 0,-1,0,1 };\nint dy[4] = { -1,0,1,0 };\nint c[20][20];\nlong long int dp[20][20];\nint main() {\n    int X,Y;\n    while(true){\n        long long int ans=0;\n        cin>>X>>Y;\n        if(X+Y==0) break;\n        for(int i=1;i<=Y;i++){\n            for(int j=1;j<=X;j++){\n                cin>>c[i][j];\n            }\n        }\n        for(int i=1;i<=X;i++){\n            if(c[1][i]==1){\n                dp[1][i]=0;\n            }\n            if(c[1][i]==0){\n                dp[1][i]=1;\n            }\n            if(c[1][i]==2){\n                dp[1][i]=1;\n                dp[3][i]=1;\n            }\n        }\n        for(int i=2;i<=Y;i++){\n            for(int j=1;j<=X;j++){\n                if(c[i][j]==1) dp[i][j]=0;\n                else if(c[i][j]==0){\n                    for(int k=0;k<3;k++){\n                        if(c[i-1][j-1+k]==0){\n                            dp[i][j]+=dp[i-1][j-1+k];\n                        }\n                    }\n                }\n                else{\n                    if(c[i-1][j]==0){\n                        dp[i][j]+=dp[i-1][j];\n                    }\n                    dp[i+2][j]+=dp[i][j];\n                }\n            }\n        }\n        for(int i=Y;i<=Y+2;i++){\n            for(int j=1;j<=X;j++){\n                ans+=dp[i][j];\n            }\n        }\n        for(int i=1;i<=Y+1;i++){\n            for(int j=1;j<=X;j++){\n                dp[i][j]=0;\n            }\n        }\n        printf(\"%lld\\n\",ans );\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define F first\n#define S second\n#define INF 1 << 30\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint main(){\n  int X, Y;\n  while(scanf(\"%d%d\", &X, &Y) && X+Y){\n    int board[15][15], dp[17][15] = {};\n    rep(i, Y) rep(j, X) if(scanf(\"%d\", &board[i][j])  && board[i][j] == 1) dp[i][j] = -1;\n\n    rep(i, X) if(!dp[0][i]) dp[0][i] = 1;\n\n    rep(i, Y-1) rep(j, X){\n      if(board[i][j] == 1) continue;\n      else if(board[i][j] == 2 && board[i+2][j] != 1) dp[i+2][j] += dp[i][j];\n      else if(board[i][j] == 0){\n\tfor(int k = -1; k < 2; k++){\n\t  if(j+k < 0 || j+k >= X) continue;\n\t  if(dp[i+1][j+k] == -1) continue;\n\t  if(board[i+1][j+k] == 2){\n\t    if(k != 0) continue;\n\t    dp[i+1][j+k] += dp[i][j];\n\t  }else{\n\t    dp[i+1][j+k] += dp[i][j];\n\t  }\n\t}\n      }\n    }\n\n    ll res = 0;\n    REP(i, Y-1, Y+2)\n      rep(j, X)\n      if(dp[i][j] != -1)\n\tres += dp[i][j];\n  \n    /*    rep(i, 17){ \n      rep(j, 15) printf(\"%d \", dp[i][j]);\n      puts(\"\");\n      }*/\n\n    printf(\"%lld\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint w,h;\nint mp[18][18];\nint memo[18][18];\nint ans;\nint count;\n\nint saiki(int x,int y) {\n  count++;\n  // cout << x <<\" \"<<y <<endl;\n  int dx[3] = {-1,0,1};\n  int dy[3] = {1,1,1};\n  \n  if((y >= h-1 && mp[y][x] != 1)) ans++,memo[y][x]++;//,cout <<\"ok\"<<endl;  \n  else if(mp[y][x] != 1) {\n    for(int i=0;i<3;i++) {\n      int nx = dx[i]+x;\n      int ny = dy[i]+y;\n      if(nx <0||ny <0||nx >= w|| ny>=h || memo[ny][nx] == -1) continue;\n      \n      if(memo[ny][nx] > 0) {\n\tans+= memo[ny][nx];\n\tmemo[y][x] += memo[ny][nx];\n      }  \n      else if(mp[ny][nx] == 0){\n\tsaiki(nx,ny);\n\tif(memo[ny][nx] > 0) memo[y][x] += memo[ny][nx];\n      } \n      else if(nx==x && mp[ny][nx] == 2){\n\tint ty = ny;\n\twhile(mp[ty][nx] == 2) ty+=2;\n\tsaiki(nx,ty);\n\tif(memo[ty][nx] > 0) memo[y][x] += memo[ty][nx];\n      } \n    }\n    if(memo[y][x] == 0) memo[y][x] = -1;\n  }\n}\n\n\nint main() {\n\n  while(1) {\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n\n    for(int i=0;i<h;i++) \n      for(int j=0;j<w;j++) \n\tcin >> mp[i][j];\n\n\n    for(int i=0;i<=15;i++) \n      for(int j=0;j<=15;j++) \n\tmemo[i][j] = 0;\n    /*\n      for(int i=0;i<h;i++) {\n      for(int j=0;j<w;j++) \n      cout << mp[i][j];\n      cout << endl;\n      }\n    */\n\n    ans = 0;\n    count = 0;\n    for(int i=0;i<w;i++) {\n      if(mp[0][i] !=1) saiki(i,0);\n    }\n\n    int ans2 = 0;\n    for(int i=0;i<w;i++) \n      if(memo[0][i] > 0) ans2+=memo[0][i];\n\n    cout << ans << endl;\n    //cout << ans2 << endl;\n    //cout << count << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint X, Y;\nint map[20][20], dp[20][20][20];\n\nint rec(int x, int y, int prevx){\n\n  if(x < 0 || x > X-1) return 0;\n  if(map[y][x] == 1) return 0;\n  if(y >= Y-1) return 1;\n  if(dp[y][x][prevx]) return dp[y][x][prevx];\n\n  int ret = 0;\n  if(map[y][x] == 0){\n    ret = rec(x-1, y+1, x) + rec(x, y+1, x) + rec(x+1, y+1, x);\n  }\n  if(map[y][x] == 2 && prevx == x){\n    ret = rec(x, y+2, x);\n  }\n\n  return dp[y][x][prevx] = ret;\n\n}\n\nint main(){\n\n  while(cin >> X >> Y, X||Y){\n\n    memset(dp, 0, sizeof(dp));\n    for(int i = 0; i < Y; i++){\n      for(int j = 0; j < X; j++) cin >> map[i][j];\n    }\n\n    int ans = 0;\n    for(int i = 0; i < X; i++)\n      ans += rec(i, 0, i);\n\n    cout << ans << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n\nusing namespace std;\n\n\nint main() {\n\twhile(1) {\n\t\tint x, y;\n\t\tcin >> y >> x;\n\t\tif(x==0 && y==0) break;\n\t\tint field[x][y];\n\t\tfor(int i=0; i<x; i++) {\n\t\t\tfor(int j=0; j<y; j++) {\n\t\t\t\tcin >> field[i][j];\n\t\t\t}\n\t\t}\n\t\tint dp[x+1][y];\n\t\tfor(int i=0; i<x+1; i++) {\n\t\t\tfor(int j=0; j<y; j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<x; i++) {\n\t\t\tfor(int j=0; j<y; j++) {\n\t\t\t\tif(i==0 && field[i][j] == 0) dp[i][j] = 1;\n\t\t\t\telse {\n\t\t\t\t\tif(field[i][j] == 0) {\n\t\t\t\t\t\tif(0<j && field[i-1][j-1] == 0) dp[i][j] += dp[i-1][j-1];\n\t\t\t\t\t\tif(field[i-1][j] == 0) dp[i][j] += dp[i-1][j];\n\t\t\t\t\t\tif(j<y-1 && field[i-1][j+1] == 0) dp[i][j] += dp[i-1][j+1];\n\t\t\t\t\t}\n\t\t\t\t\tif(field[i][j] == 2) {\n\t\t\t\t\t\tdp[i][j] += dp[i-1][j];\n\t\t\t\t\t\tdp[i+2][j] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<y; i++) dp[x][i] += dp[x-1][i];\n\t\tint sum=0;\n\t\tfor(int i=0; i<y; i++) sum += dp[x][i];\n\t\tcout << sum << endl;\n\n\t\t//for(int i=0; i<x+1; i++) {\n\t\t\t//for(int j=0; j<y; j++) {\n\t\t\t\t//cout << dp[i][j] << ' ';\n\t\t\t//}\n\t\t\t//cout << endl;\n\t\t//}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint X,Y;\nint c[15][15];\nint dp[15][15];\nint main(){\n\twhile(cin>>X>>Y,X|Y){\n\t\tint ans=0;\n\t\tfor(int i=0;i<Y;i++)\n\t\t\tfor(int j=0;j<X;j++)\n\t\t\t\tcin>>c[i][j];\n\t\tfill_n((int*)dp,15*15,0);\n\t\tfor(int j=0;j<X;j++){\n\t\t\tif(c[0][j]!=1)dp[0][j]=1;\n\t\t}cout<<endl;\n\t\tfor(int i=0;i<Y;i++){\n\t\t\tfor(int j=0;j<X;j++){\n\t\t\t\tif(dp[i][j]==0)continue;\n\t\t\t\tif(Y-1==i || c[i][j]==2 && Y-2==i){\n\t\t\t\t\tans += dp[i][j];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int dx=-1;dx<=1;dx++){\n\t\t\t\t\tif(j+dx<0 || X<=j+dx)continue;\n\t\t\t\t\tif(c[i][j]==2){\n\t\t\t\t\t\tif(dx==0 && c[i+2][j]!=1){\n\t\t\t\t\t\t\tdp[i+2][j] += dp[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(c[i+1][j+dx]==0)dp[i+1][j+dx] += dp[i][j];\n\t\t\t\t\t\telse if(c[i+1][j+dx]==2 && dx==0)dp[i+1][j] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst int MAX_SIZE = 15;\nchar field[MAX_SIZE+1][MAX_SIZE+3];\nint dp[MAX_SIZE+1][MAX_SIZE+3];\nint w, h;\n\nbool judge(int i, int j){\n\tif(j > 0 && j <= w && field[j][i] == '0' && j <= h)\n\t\treturn true;\n\treturn false;\n}\n\nint main(){\n\twhile(cin >> w >> h){\n\t\tif(w == 0 && h == 0) break;\n\t\tfor(int i = 1; i <= h; i++){\n\t\t\tfor(int j = 1; j <= w; j++)\n\t\t\t\tcin >> field[j][i];\n\t\t}\n\t\tint pattern = 0;\n\t\tfor(int i = 0; i < MAX_SIZE+1; i++){\n\t\t\tfor(int j = 0; j < MAX_SIZE+3; j++){\n\t\t\t\tdp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1; i <= w; i++){\n\t\t\tdp[i][1] = 1;\n\t\t}\n\t\tfor(int i = 1; i < h; i++){\n\t\t\tfor(int j = 1; j <= w; j++){\n\t\t\t\tif(field[j][i] == '2')\n\t\t\t\t\tdp[j][i+2] += dp[j][i];\n\t\t\t\tif(field[j][i] == '0'){\n\t\t\t\t\tdp[j][i+1] += dp[j][i];\n\t\t\t\t\tif(judge(i+1, j-1)) dp[j-1][i+1] += dp[j][i];\n\t\t\t\t\tif(judge(i+1, j+1)) dp[j+1][i+1] += dp[j][i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint count = 0;\n\t\tfor(int i = h; i <= h+1; i++){\n\t\t\tfor(int j = 1; j <= w; j++){\n\t\t\t\tcount += dp[j][i];\n\t\t\t}\n\t\t}\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nint dx[3] = {-1, 0, 1};\nint dy[3] = {1, 1, 1};\n\nint main(void)\n{\n\tint **map, f1, f2, f3, **temp, x, y, sum, px, py;\n\t\n\twhile(scanf(\"%d %d\", &x, &y) && y > 0)\n\t{\n\t\tmap = new int *[y];\n\t\ttemp = new int *[y];\n\t\tsum = 0;\n\n\t\t//マップ土地&動的計画作成\n\t\tfor(f1 = 0; f1 < y; f1++)\n\t\t{\n\t\t\tmap[f1] = new int [x];\n\t\t\ttemp[f1] = new int [x];\n\t\t}\n\t\t//マップ構成入力&初期化\n\t\tfor(f1 = 0; f1 < y; f1++)\n\t\t{\n\t\t\tfor(f2 = 0; f2 < x; f2++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\",&map[f1][f2]);\n\t\t\t\ttemp[f1][f2] = 0;\n\t\t\t}\n\t\t}\n\t\t//最上のスタート地点設定\n\t\tfor(f1 = 0; f1 < x; f1++)\n\t\t{\n\t\t\tif(map[0][f1] != 1)\n\t\t\t{\n\t\t\t\ttemp[0][f1] = 1;\n\t\t\t\tsum++;\n\t\t\t}\n\t\t}\n\t\t//探索\n\t\tif(y >= 2)\n\t\t{\n\t\t\tsum = 0;\n\t\t\tfor(f1 = 0; f1 < y - 1; f1++)\n\t\t\t{\n\t\t\t\tfor(f2 = 0; f2 < x; f2++)\n\t\t\t\t{\n\t\t\t\t\tif(map[f1][f2] == 0 && temp[f1][f2] > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(f3 = 0; f3 < 3; f3++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//移動\n\t\t\t\t\t\t\tpx = f2 + dx[f3];\n\t\t\t\t\t\t\tpy = f1 + dy[f3];\n\t\t\t\t\t\t\t//範囲内か\n\t\t\t\t\t\t\tif(px >= 0 && px < x)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t//同じｘ座標からのジャンプ台\n\t\t\t\t\t\t\t\tif(f3 == 1 && py <= y - 1){\n\t\t\t\t\t\t\t\t\t//ｙ軸2つ先へ\n\t\t\t\t\t\t\t\t\twhile(py < y - 1 && map[py][px] == 2)\n\t\t\t\t\t\t\t\t\t\tpy += 2;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t//着地した場所がゴール地点のｙ座標と同じで障害物にぶつかってないか\n\t\t\t\t\t\t\t\t//ゴール地点のｙ座標を超えたか\n\t\t\t\t\t\t\t\tif(py > y - 1 || py == y - 1 && map[py][px] != 1)\n\t\t\t\t\t\t\t\t\tsum += temp[f1][f2];\n\t\t\t\t\t\t\t\t//超えてないが、障害物がない地点に着地したか\n\t\t\t\t\t\t\t\telse if(map[py][px] == 0)\n\t\t\t\t\t\t\t\t\ttemp[py][px] += temp[f1][f2];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//出力\n\t\tprintf(\"%d\\n\",sum);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define rep(i,s,e) for ( int i = s; i <= e; i++)\n#define MAX 15\n#define TREE 1\n#define JUMP 2\n#define SNOW 0\nint X, Y;\nint G[MAX+2][MAX+2];\n\nint compute(){\n    int T[MAX+2][MAX+2];\n    rep(y,0,Y+1) rep(x,0,X+1) T[y][x] = 0;\n\n    rep(x,1,X){\n\tif ( G[0][x] == TREE || G[0][x] == JUMP ) continue;\n\tint s = -1, t = 1;\n\tif ( 0 == Y-1 ) s = t = 0;\n\trep(dx,s,t){ // G[0][x] == SNOW\n\t    if ( G[1][x+dx] == SNOW ) T[1][x+dx]++;\n\t    if ( G[1][x+dx] == JUMP && dx == 0 ) T[1][x+dx]++;\n\t}\n    }\n\n    rep(y,1,Y-1) rep(x,1,X){\n\tif ( G[y][x] == SNOW ){\n\t    int s = -1, t = 1;\n\t    if ( y == Y-1 ) s = t = 0;\n\t    rep(dx,s,t){\n\t\tif ( G[y+1][x+dx] == SNOW ) T[y+1][x+dx] += T[y][x];\n\t\tif ( G[y+1][x+dx] == JUMP && dx == 0 ) T[y+1][x+dx] += T[y][x];\n\t    }\n\t} else if ( G[y][x] == JUMP ){\n\t    if ( G[y+2][x] != TREE ) T[y+2][x] += T[y][x];\n\t}\n    }\n\n    int sum = 0;\n    rep(y,Y,Y+1) rep(x,1,X) sum += T[y][x];\n    return sum;\n}\n\nmain(){\n    while( cin >> X >> Y && X && Y ){\n\trep(y,0,Y-1) rep(x,0,X+1) G[y][x] = TREE;\n\trep(y,Y,Y+1) rep(x,0,X+1) G[y][x] = SNOW;\n\trep(y,0,Y-1) rep(x,1,X) cin >> G[y][x];\n\tcout << compute() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <functional>\n#include <numeric>\n#define fi first\n#define se second\nusing namespace std;\nbool value(int y,int x,int R,int C){return 0<=y&&y<R&&0<=x&&x<C;}\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<long long > vll;\ntypedef vector< vi > vvi;\ndouble pie=acos(-1);\nint INF=10000009;\nint dx[4] = { 0,-1,0,1 };\nint dy[4] = { -1,0,1,0 };\nint c[20][20];\nlong long int dp[20][20];\nint main() {\n\tint X,Y;\n\twhile(true){\n\t\tlong long int ans=0;\n\t\tcin>>X>>Y;\n\t\tif(X+Y==0) break;\n\t\tfor(int i=1;i<=Y;i++){\n\t\t\tfor(int j=1;j<=X;j++){\n\t\t\t\tcin>>c[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=X;i++){\n\t\t\tif(c[1][i]==1){\n\t\t\t\tdp[1][i]=0;\n\t\t\t}\n\t\t\tif(c[1][i]==0){\n\t\t\t\tdp[1][i]=1;\n\t\t\t}\n\t\t\tif(c[1][i]==2){\n\t\t\t\tdp[1][i]=1;\n\t\t\t\tdp[3][i]=1;\n\t\t\t}\n\t\t}\n\t\tfor(int i=2;i<=Y;i++){\n\t\t\tfor(int j=1;j<=X;j++){\n\t\t\t\tif(c[i][j]==1) dp[i][j]=0;\n\t\t\t\telse if(c[i][j]==0){\n\t\t\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\t\t\tif(c[i-1][j-1+k]!=2){\n\t\t\t\t\t\t\tdp[i][j]+=dp[i-1][j-1+k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(c[i-1][j]!=2){\n\t\t\t\t\t\tdp[i][j]+=dp[i-1][j];\n\t\t\t\t\t}\n\t\t\t\t\tdp[i+2][j]+=dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=Y;i<=Y+2;i++){\n\t\t\tfor(int j=1;j<=X;j++){\n\t\t\t\tans+=dp[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=Y+1;i++){\n\t\t\tfor(int j=1;j<=X;j++){\n\t\t\t\tdp[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ans );\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint dp[18][18];\nint kosu[18][18];\nint ans;\n\nint main(){\n  int x,y;\n  \n  while(1){\n    cin>>x>>y;\n    if(x==0 && y==0) break;\n    \n    fill(dp[0],dp[18],0);\n    fill(kosu[0],kosu[18],0);\n    ans=0;\n    \n    for(int i=0;i<y;i++){\n      for(int l=0;l<x;l++){\n        cin>>kosu[i][l];\n      }\n    }\n    for(int i=0;i<x;i++)\n      if(kosu[0][i]==0) dp[0][i]=1;\n    \n    for(int i=1;i<y;i++){\n      for(int l=0;l<x;l++){\n        \n        if(kosu[i][l]==2 && kosu[i+2][l]!=1){\n          dp[i+2][l]+=dp[i-1][l]+dp[i][l];\n          dp[i][l]=0;\n        }\n        else if(kosu[i][l]==0)\n          dp[i][l]+=dp[i-1][l-1]+dp[i-1][l]+dp[i-1][l+1];\n      }\n    }\n    for(int i=y-1;i<y+2;i++){\n      for(int l=0;l<x;l++){\n        ans+=dp[i][l];\n      }\n    }\n    \n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n\n#define reep(i,n,m) for(int i=(n);i<(m);i++)\n#define rep(i,n) reep(i,0,n)\n\nusing namespace std;\n\nint main(){\n    int X,Y;\n    while(cin >> X >> Y,X+Y){\n        int fld[20][20] = {0};\n        rep(y,Y){\n            rep(x,X){\n                cin >> fld[y][x];\n            }\n        }\n\n        int dp[20][20] = {0};\n        rep(x,X){\n            if(fld[0][x] == 0)\n                dp[0][x] = 1;\n        }\n\n        rep(y,Y-1){\n            rep(x,X){\n                int val = dp[y][x];\n                if(fld[y][x] == 0){\n                    if(x>0 && fld[y+1][x-1] == 0){\n                        dp[y+1][x-1] += val;\n                    }\n                    if(fld[y+1][x+1] == 0){\n                        dp[y+1][x+1] += val;\n                    }\n                    dp[y+1][x] += val;\n                }else if(fld[y][x] == 2){\n                    dp[y+2][x] += val;\n                }\n            }\n        }\n\n        int ans = 0;\n        rep(i,2){\n            rep(x,X){\n                if(fld[Y+i-1][x] != 1)\n                    ans += dp[Y+i-1][x];\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint H,W,ans;\nint t[20][20];\nint u[20][20];\n\nbool inField(int x){\n  if(1<=x&&x<=W)return true;\n  return false;\n}\n\nint main(){\n  while(cin>>W>>H){\n    if(H==0&&W==0)break;\n    for(int i=0;i<20;i++)for(int j=0;j<20;j++)u[i][j]=0;\n    for(int i=1;i<=H;i++)for(int j=1;j<=W;j++)cin>>t[i][j];\n\n    for(int i=0;i<20;i++)u[1][i]=(t[1][i]==1?0:1);\n\n    ans=0;\n    for(int i=1;i<H;i++){\n      for(int j=1;j<=W;j++){\n\tif(t[i][j]==1)u[i][j]=0;\n\tif(u[i][j]==0)continue;\n\tif(t[i][j]==2){\n\t  u[i+2][j]+=u[i][j];\n\t  if(i+2>=H&&t[i+2][j]!=1)ans+=u[i][j];\n\t  continue;\n\t}\n\tfor(int k=-1;k<=1;k++){\n\t  if(!inField(j+k))continue;\n\t  if(t[i+1][j+k]==0){\n\t    u[i+1][j+k]+=u[i][j];\n\t    if(i+1>=H&&t[i+1][j+k]!=1)ans+=u[i][j];\n\t  }else if(t[i+1][j+k]==2&&k==0){\n\t    u[i+1][j+k]+=u[i][j];\n\t    if(i+1>=H&&t[i+1][j+k]!=1)ans+=u[i][j];\n\t  }\n\t}\n      }//j\n    }//i\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nclass point {\npublic:\n\tlong long num;\n\tint block;\n\tpoint() :num(0), block(1) {}\n};\nint main() {\n\tint X, Y;\n\twhile (cin >> X >> Y&&X != 0) {\n\t\tvector<vector<point> > map(X + 2, vector<point>(Y + 2));\n\t\tfor (int y = 1; y <= Y; ++y) {\n\t\t\tfor (int x = 1; x <= X; ++x) {\n\t\t\t\tcin >> map[x][y].block;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= X; ++i) {\n\t\t\tmap[i][1].num = 1;\n\t\t}\n\t\tfor (int y = 1; y < Y; ++y) {\n\t\t\tfor (int x = 1; x <= X; ++x) {\n\t\t\t\tif (map[x][y].block == 0) {\n\t\t\t\t\tfor (int k = -1; k <= 1; ++k) {\n\t\t\t\t\t\tif (map[x + k][y + 1].block == 0 || (map[x + k][y + 1].block == 2 && k == 0) ) {\n\t\t\t\t\t\t\tmap[x + k][y + 1].num += map[x][y].num;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (map[x][y].block == 2) {\n\t\t\t\t\tif (y + 2 > Y)map[x][Y].num += map[x][y].num;\n\t\t\t\t\telse if (map[x][y + 2].block == 0) {\n\t\t\t\t\t\tmap[x][y + 2].num += map[x][y].num;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong long ans = 0;\n\t\tfor (int i = 1; i <= X; ++i) {\n\t\t\tans += map[i][Y].num;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint DP[18][17];\nint field[17][17];\nint x,y;\n\nint main(){\n\twhile(true){\n\t\tcin >> x >> y;\n\t\tif(!x && !y)\n\t\t\treturn 0;\n\t\t\n\t\tfor(int i=1; i<=y; i++)\n\t\t\tfor(int k=1; k<=x; k++)\n\t\t\t\tcin >> field[i][k];\n\t\tfor(int i=1; i<=x; i++)\n\t\t\tfield[y+1][i] = 0;\n\t\t\n\t\tfor(int i=1; i<=y+2; i++)\n\t\t\tfor(int k=0; k<=x+1; k++){\n\t\t\t\tDP[i][k]=0;\n\t\t\t\tif(i==1 && k>0 && k<=x)\n\t\t\t\t\tif(field[i][k] == 0)\n\t\t\t\t\t\tDP[i][k] = 1;\n\t\t\t}\n\t\t\n\t\tfor(int i=2; i<=y; i++){\n\t\t\tfor(int k=1; k<=x; k++){\n\t\t\t\tif(field[i][k] == 0)\n\t\t\t\t\tDP[i][k] += DP[i-1][k-1] + DP[i-1][k] + DP[i-1][k+1];\n\t\t\t\telse if(field[i][k] == 2){\n\t\t\t\t\tint n = i+2;\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\tif(field[n][k] == 0){\n\t\t\t\t\t\t\tDP[n][k] += DP[i-1][k];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else if(field[n][k] == 1)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tn+=2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans=0;\n\t\tfor(int i=y; i<=y+2; i++)\n\t\t\tfor(int k=1; k<=x; k++)\n\t\t\t\tans += DP[i][k];\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reg(i,a,b) for(int i=(a);i<=(b);i++)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n\nint dat[30][30];\nint dp[30][30];\nint main(void){\n\tint x,y;\n\tfor(;;){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif(x==0)break;\n\t\trep(j,y)rep(i,x){\n\t\t\tscanf(\"%d\",&dat[i][j]);\n\t\t}\n\t\tmemset(dp,0,sizeof(dp));\n\t\trep(i,x)if(dat[i][0]==0)dp[i][0]=1;\n\t\trep(j,y)rep(i,x){\n\t\t\tif(dat[i][j]==1)continue;\n\t\t\tif(dat[i][j]==2){\n\t\t\t\tif(dat[i][j+2]!=1)dp[i][j+2]+=dp[i][j];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(j!=y-1){\n\t\t\t\tif(i>0 && dat[i-1][j+1]==0){\n\t\t\t\t\tdp[i-1][j+1]+=dp[i][j];\n\t\t\t\t}\n\t\t\t\tif(i<x-1 && dat[i+1][j+1]==0){\n\t\t\t\t\tdp[i+1][j+1]+=dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dat[i][j+1]!=1)dp[i][j+1]+=dp[i][j];\n\t\t}\n\t\tlli ans=0;\n\t\t/*\n\t\tprintf(\"\\n\");\n\t\trep(j,y){\n\t\t\trep(i,x){\n\t\t\t\t//printf(\"(%2d %2d)\",dat[i][j],dp[i][j]);\n\t\t\t\tprintf(\"%2d\",dp[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\treg(j,y,y+1){\n\t\t\t//printf(\"\\n\");\n\t\t\trep(i,x){\n\t\t\t\t//printf(\"%2d \",dp[i][j]);\n\t\t\t\tans+=dp[i][j];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\nint w,h;\nint f[22][22];\nint dp[22][22];\nint dx[] = {-1,0,1};\nint solve(int x,int y){\n  if(f[x][y] == 1) return 0;\n  if(y >= h)return 1;\n  if(f[x][y] == 1) return 0;\n  if(dp[x][y] >= 0) return dp[x][y];\n  if(f[x][y] == 2)return dp[x][y] = solve(x,y + 2);\n\n  int ret = 0;\n  for(int i = 0; i < 3; i++){\n    int nx = x + dx[i];\n    if(!f[nx][y+1] || (!dx[i] && f[nx][y+1] == 2)){\n      ret += solve(nx,y+1);\n    }\n  }\n  return dp[x][y] = ret;\n}\nint main(void){\n  while(1){\n    scanf(\"%d%d\",&w,&h); if(!w) break;\n    memset(f,-1,sizeof(f));\n    memset(dp,-1,sizeof(dp));\n    for(int i = 1; i <= h; i++){\n      for(int j = 1; j <= w; j++){\n\tscanf(\"%d\",&f[j][i]);\n      }\n    }\n    int ans = 0;\n    for(int j = 1; j <= w; j++){\n      ans += solve(j,1);\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n\n  int x,y;\n  int a[100][100];\n  int w[100][100];\n\n  while(true){\n    cin >> x >> y;\n    if(!x && !y) break;\n\n    memset(w,0,sizeof(w));\n    int ans = 0;\n\n    for(int i=0;i<y;i++){\n      for(int j=0;j<x;j++) cin >> a[i][j];\n    }\n\n    for(int i=0;i<x;i++){\n      if(a[0][i] == 0) w[0][i] = 1;\n    }\n\n    for(int i=1;i<y;i++){\n      for(int j=0;j<x;j++){\n\n\tif(a[i][j] == 1) w[i][j] += 0;\n\n\telse if(a[i][j] == 2 && a[i+2][j] != 1)  w[i+2][j] += w[i-1][j];\n\n\telse if(a[i][j] == 0){\n\t  if(i-3 > 0 && (a[i-3][j+1] == 2 || a[i-3][j-1] == 2)) w[i][j] += w[i-1][j];\n\t  else if(j-1 < 0) w[i][j] += w[i-1][j] + w[i-1][j+1];\n\t  else if(j+1 == y) w[i][j] += w[i-1][j-1] + w[i-1][j];\n\t  else w[i][j] += w[i-1][j-1] + w[i-1][j] + w[i-1][j+1];\n\t}\n\n\n      }\n\n    }\n\n    for(int i=0;i<x;i++) ans += w[y-1][i] + w[y][i] + w[y+1][i];\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\nusing namespace std;\n\nint main(){\n  int i,j,x,y,a[16][15],n[15][15],k,ans;\n  while(1){\n    cin >> x >> y;\n    if(x == 0 && y == 0) break;\n    for(i=0;i<y;i++){\n      for(j=0;j<x;j++){\n\tcin >> n[i][j];\n      }\n    }\n\n    for(j=0;j<x;j++){\n      for(i=0;i<=y;i++) a[i][j] = 0;\n      if(n[0][j] == 0) a[0][j] = 1;\n    }\n\n    for(i=0;i<y;i++){\n      for(j=0;j<x;j++){\n\tif(n[i][j] == 1) continue;\n\tif(i == y-1) a[i+1][j] += a[i][j];\n\telse if(n[i][j] == 0){\n\t  for(k=-1;k<=1;k++){\n\t    if(j == 0 && k == -1 || j == x-1 && k == 1) continue;\n\t    if(n[i+1][j+k] == 0) a[i+1][j+k] += a[i][j];\n\t  }\n\t  if(n[i+1][j] == 2) a[i+1][j] += a[i][j];\n\t}\n\telse if(n[i][j] == 2){\n\t  if(n[i+2][j] != 1) a[i+2][j] += a[i][j];\n\t}\n      }\n    }\n\n    ans = 0;\n    for(j=0;j<x;j++) ans += a[y][j];\n    cout << ans << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <deque>\n#include <ctime>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define mp make_pair\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n#define println(X) cout<<X<<endl;\n#define DBG(X) cout<<#X<<\" : \"<<X<<endl;\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\nconst double PI = acos(-1);\n\nint dx[]={-1, 0, 1};\n\nint d[21][21];\nll dp[21][21];\nint w, h;\n\nbool isOutofRange(int x, int y){\n\tif(x < 0 || x >= w || y < 0) return true;\n\treturn false;\n}\n\nint main(){\n\twhile(cin>>w>>h && w && h){\n\t\trep(i, 21) rep(j, 21) dp[i][j] = 0LL, d[i][j]=0;;\n\t\trep(i, h) rep(j, w) cin>>d[i][j];\n\t\tfor(int i = 0; i < w; i++){\n\t\t\tif(d[0][i] != 1) dp[0][i] = 1LL;\n\t\t}\n\n\t\tfor(int i = 0; i < h-1; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tif(d[i][j]!=0) continue;\n\t\t\t\tfor(int k = 0; k < 3; k++){\n\t\t\t\t\tint nx = j + dx[k], ny = i+1;\n\t\t\t\t\tif(isOutofRange(nx, ny)) continue;\n\t\t\t\t\tif(d[ny][nx] == 0) {\n\t\t\t\t\t\tdp[ny][nx] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(d[i+1][j]==2) dp[i+2][j]+=dp[i][j];\n\t\t\t}\n\t\t}\n\t\tll ans = 0ll;\n\t\trep(i, w){\n\t\t\tans += dp[h-1][i];\n\t\t\tans += dp[h][i];\n\t\t}\n\t\tcout<<ans<<endl;\n\t\t// rep(i, h) {\n\t\t// \trep(j, w){\n\t\t// \t\tcout<<dp[i][j]<<\" \";\n\t\t// \t}\n\t\t// \tcout<<endl;\n\t\t// }\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint solve(int x,int y);\nint ax,ay;\nint mas[20][20];\nint memo[20][20];\nint main(){\n  while(1){\n    int ans=0;\n    cin>>ax>>ay;\n    if(ax==0 && ay==0) break;\n    for(int i=1;i<=ay;i++){\n      for(int j=1;j<=ax;j++){\n\tcin>>mas[i][j];\n\tmemo[i][j]=0;\n      }\n    }\n    for(int i=1;i<=ax;i++){\n      if(mas[1][i]!=1){\n\tans+=solve(i,1);\n      }\n    }\n    cout<<ans<<endl;\n  }\n}\nint solve(int x,int y){\n  if(y>=ay){\n    return 1;\n  }else if(memo[y][x]!=0){\n    return memo[y][x];\n  }else if(mas[y][x]==2){\n    if(mas[y+2][x]!=1){\n      return memo[y][x]=solve(x,y+2);\n    } \n    else{\n      return 0;\n    }\n  }\n  else if(mas[y][x]==1){\n    return 0;\n  }\n  else{\n    int anss=0; \n    if(mas[y+1][x]!=1){\n      anss+=solve(x,y+1);\n    }\n    if(x+1<=ax && 0<x+1 && mas[y+1][x+1]==0){\n      anss+=solve(x+1,y+1);\n    }\n    if(0<x-1 && x-1<=ax && mas[y+1][x-1]==0){\n      anss+=solve(x-1,y+1);\n    }\n    return memo[y][x]=anss;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n \nint main(){\n        int x,y;\n        while(cin>>x>>y,x){\n                int D[16][16],P[16][16],ans=0;\n                for(int i=0;i<256;i++)P[i/16][i%16]=0;\n                for(int i=0;i<y;i++)for(int j=0;j<x;j++)cin>>D[i][j];\n                for(int i=0;i<x;i++)if(!D[0][i])P[0][i]=1;\n                for(int i=0;i<y-1;i++){\n                        for(int j=0;j<x;j++){\n                                if(!D[i][j]){\n                                        P[i+1][j]+=P[i][j];\n                                        if(j>0 && D[i + 1][j - 1] != 2)P[i+1][j-1]+=P[i][j];\n                                        if(j<x-1 && D[i + 1][j + 1] != 2)P[i+1][j+1]+=P[i][j];\n                                }\n                                if(D[i][j]==2){\n//                                        if(i+2>y-1)P[i+1][j]+=P[i][j];\n                                        P[i+2][j]+=P[i][j];\n                                }\n                        }\n                }\n                for(int i=0;i<x;i++)ans+=P[y-1][i];\n                cout<<ans<<endl;\n        }\n}\n "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nconst int MAX_Y = 50;\nconst int MAX_X = 50;\nint mx, my, c[MAX_Y][MAX_X], dp[MAX_Y][MAX_X];\n\nconst int dx[3] = {-1, 0, 1};\nconst int dy[3] = {1, 1, 1};\n\nint dfs(int y, int x) {  \n  int res = 0;\n  if (dp[y][x] >= 0) return dp[y][x];\n  \n  if (y >= my - 1) res = 1;\n  \n  if (c[y][x] == 2 && c[y+2][x] != 1) {\n    if (y + 2 >= my - 1) {\n      res = 1;\n    } else {\n      if (c[y+2][x] != 1) res += dfs(y+2, x);\n    }\n  }\n  \n  if (res != 0) return dp[y][x] = res;\n  \n  rep(z,3) {\n    int tx = x + dx[z], ty = y + dy[z];\n    if (tx < 0 || ty < 0 || tx >= mx || ty >= my) continue;\n    if (c[ty][tx] == 1) continue;\n    if (c[ty][tx] == 2 && tx != x) continue;\n    res += dfs(ty, tx);\n  }\n\n  return dp[y][x] = res;\n}\n\nvoid solve() {\n  memset(dp, -1, sizeof dp);\n  rep(i,my) rep(j,mx) cin>>c[i][j];\n\n  int res = 0;\n  rep(i,mx) {\n    if (c[0][i] == 1) continue;\n    res += dfs(0, i);\n  }\n  /*\n  rep(i,my) {\n    rep(j,mx) printf(\"%8d\",dp[i][j]);\n    cout<<endl;\n  }*/\n  cout<<res<<endl;\n}\n\nint main (int argc, char const* argv[]) {\n  while (cin>>mx>>my, mx||my) {\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\n#include <iomanip>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nint main()\n{\n\tint x, y;\n\twhile(cin >> x >> y && x)\n\t{\n\t\tvector<vint> field(y + 1, vint(x, 0)), dp(y + 1, vint(x, 0));\n\t\trep(i, y) rep(j, x)\n\t\t\tcin >> field[i][j];\n\n\n\t\tfill(ALL(dp[0]), 1);\n\t\trep(i, y) rep(j, x)\n\t\t{\n\t\t\tif(field[i][j] == 1) continue;\n\n\t\t\tif(field[i][j])\n\t\t\t\tdp[min(y, i + 2)][j] += dp[i][j];\n\n\t\t\telse\n\t\t\t{\n\t\t\t\tint dx[] = {-1, 0, 1};\n\t\t\t\trep(k, 3)\n\t\t\t\t{\n\t\t\t\t\tint nx = j + dx[k];\n\t\t\t\t\tif(0 <= nx && nx < x)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(field[i + 1][nx] != 2)\n\t\t\t\t\t\t\tdp[i + 1][nx] += dp[i][j];\n\t\t\t\t\t\telse if(!dx[k])\n\t\t\t\t\t\t\tdp[i + 1][nx] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint res = 0;\n\t\trep(i, x)\n\t\t\tif(dp[y - 1][i] != 1)\n\t\t\t\tres += dp[y - 1][i];\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class t>\nusing table = vector<vector<t>>;\nconst ld eps=1e-9;\n\n//// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\"\n\nint main() {\n\twhile (1) {\n\t\tint H, W; cin >> W >> H;\n\t\tif (!H)break;\n\t\tvector<vector<int>>field(H + 3, vector<int>(W + 2,1));\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tcin >> field[i][j+1];\n\t\t\t}\n\t\t}\n\t\tfor (int i = H; i < H + 3; ++i) {\n\t\t\tfor (int j = 1; j <= W; ++j) {\n\t\t\t\tfield[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tvector<vector<long long int>>nums(H + 3, vector<long long int>(W + 2, 0));\n\t\tfor (int j = 0; j < W + 2; ++j) {\n\t\t\tif (!field[0][j])nums[0][j] = 1;\n\t\t}\n\t\tlong long int ans = 0;\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tfor (int j = 1; j < W + 1; ++j) {\n\t\t\t\tfor (int dx = -1; dx <= 1;++dx) {\n\t\t\t\t\tconst int nextx = j + dx;\n\t\t\t\t\tint nexty = i + 1;\n\t\t\t\t\t\n\t\t\t\t\tif (field[nexty][nextx] == 1) {\n\n\t\t\t\t\t}\n\t\t\t\t\telse if (field[nexty][nextx] == 2) {\n\t\t\t\t\t\tif (!dx) {\n\t\t\t\t\t\t\twhile (1) {\n\t\t\t\t\t\t\t\tnexty += 2;\n\t\t\t\t\t\t\t\tif (nexty >= H - 1 && field[nexty][nextx] != 1) {\n\t\t\t\t\t\t\t\t\tans += nums[i][j];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tif (field[nexty][nextx] == 1) {\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse if (field[nexty][nextx] == 0) {\n\n\t\t\t\t\t\t\t\t\t\tnums[nexty][nextx] += nums[i][j];\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (nexty >= H - 1)ans += nums[i][j];\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tnums[nexty][nextx] += nums[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nint dw[3] = {-1,0,1};\n\nint main(){\n    int w,h;\n\n    while(cin >> w >> h){\n        if(!(w|h)) break;\n        int field[h+2][w+2];\n        int dp[h+2][w+2];\n        int kind;\n        long long ret=0;\n        fill((int *)field, (int *)field+(h+2)*(w+2), 1);\n        fill((int *)dp, (int *)dp+(h+2)*(w+2), 0);\n\n        for(int i=1;i<=h;i++){\n            for(int j=1;j<=w;j++){\n                cin >> field[i][j];\n            }\n        }\n\n        for(int i=1;i<=w;i++){\n            if(field[1][i] == 0) dp[1][i] = 1;\n        }\n        for(int i=1;i<=h;i++){\n            for(int j=1;j<=w;j++){\n                kind = field[i][j];\n                if(kind == 0){\n                    for(int k=0;k<3;k++){\n                        if(field[i+1][j+dw[k]] == 0 || \n                           (field[i+1][j+dw[k]] == 2 && k == 1)){\n                            dp[i+1][j+dw[k]] += dp[i][j];\n                        }\n                    }\n                }else if(kind == 2){\n                    if(i != h-1){\n                        if(field[i+2][j] != 1){\n                            dp[i+2][j] += dp[i][j];\n                        }\n                    }else{\n                        ret += dp[i][j];\n                    }\n                }\n            }\n        }\n\n        for(int i=1;i<=w;i++){\n            ret += dp[h][i];\n        }\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nint main() {\n\tint x, y;\n\twhile (cin >> x >> y, x * y) {//\n\t\tint skimap[15][15] = {};//x = j y = i\n\t\tint dp[15][15] = {};//x = j y = i\n\t\tint flyover = 0;//??´????£??????????????????????\n\t\tfor (int i = 0; i < y; i++) {\n\t\t\tfor (int j = 0; j < x; j++) {\n\t\t\t\tcin >> skimap[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < x; i++){\n\t\t\tif (skimap[0][i] == 0)dp[0][i] = 1;\n\t\t}\n\t\tfor (int i = 0; i < y - 1; i++) {\n\t\t\tfor (int j = 0; j < x; j++) {\n\t\t\t\tif (skimap[i][j] == 0) {\n\t\t\t\t\tif (j - 1 >= 0) {\n\t\t\t\t\t\tif (skimap[i + 1][j - 1] == 0) {\n\t\t\t\t\t\t\tdp[i + 1][j - 1] += dp[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (skimap[i + 1][j] != 1)dp[i + 1][j] += dp[i][j];\n\t\t\t\t\tif (j + 1 < x) {\n\t\t\t\t\t\tif (skimap[i + 1][j + 1] == 0) {\n\t\t\t\t\t\t\tdp[i + 1][j + 1] += dp[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (skimap[i][j] == 1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}else {\n\t\t\t\t\tif (i + 2 < y) {\n\t\t\t\t\t\tdp[i + 2][j] = dp[i][j];\n\t\t\t\t\t}else {\n\t\t\t\t\t\tflyover += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint sum = flyover;\n\t\tfor (int i = 0; i < x; i++) {\n\t\t\tsum += dp[y - 1][i];\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n\nusing namespace std;\n\nint x,y;\nint fie[20][20];\nlong long int dp[20][20];\nlong long int ans=0;\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif(x==0 && y==0)break;\n\t\tmemset(fie,0,sizeof(fie));\n\t\tmemset(dp,0,sizeof(dp));\n\t\tans=0;\n\n\t\tfor(int i=0;i<y;i++){\n\t\t\tfor(int j=0;j<x;j++){\n\t\t\t\tscanf(\"%d\",&fie[j][i]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<x;i++){\n\t\t\tif(fie[i][0]==0)dp[i][0]=1;\n\t\t\tif(fie[i][0]==2)dp[i][2]=1;\n\t\t}\n\t\tfor(int i=0;i<y;i++){\n\t\t\tfor(int j=0;j<x;j++){\n\t\t\t\tif(fie[j][i]==0){\n\t\t\t\t\tfor(int k=j-1;k<=j+1;k++){\n\t\t\t\t\t\tif(k>=0 && k<x){\n\t\t\t\t\t\t\tif(fie[k][i+1]==0){\n\t\t\t\t\t\t\t\tdp[k][i+1]+=dp[j][i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(fie[k][i+1]==2 && k==j){\n\t\t\t\t\t\t\t\tdp[k][i+1]+=dp[j][i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(fie[j][i]==2){\n\t\t\t\t\tdp[j][i+2]+=dp[j][i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<y;i++){\n\t\t\t\tfor(int j=0;j<x;j++){\n\t\t\t\t\tif(i>=y-2 && fie[j][i]==2)ans+=dp[j][i];\n\t\t\t\t\tif(i==y-1 && fie[j][i]==0)ans+=dp[j][i];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nint m[500][500];\nint dp[500][500];\n\nint dx[]={-1,0,1};\n\nint solve(int r,int c){\n  rep(i,r+2)rep(j,c)dp[i][j]=0;\n  rep(j,c)if(m[0][j] == 0)dp[0][j]=1;\n\n  rep(i,r){\n    rep(j,c){\n      if (m[i][j] == 0 && i != r-1){\n\trep(k,3){\n\t  int nex = j+dx[k];\n\t  if (nex<0||nex>=c)continue;\n\t  if (m[i+1][nex] == 0)dp[i+1][nex]+=dp[i][j];\n\t  else if (m[i+1][nex] == 2 && k == 1)dp[i+1][nex]+=dp[i][j];\n\t}\n      }else if (m[i][j] == 2 && m[i+2][j] != 1){\n\tdp[i+2][j]+=dp[i][j];\n      }\n    }\n  }\n  \n  int ans = 0;\n  rep(j,c)ans+=dp[r][j]+dp[r-1][j];//+dp[r+1][j];\n  return ans;\n}\n\nmain(){\n  int c,r;\n  while(cin>>c>>r && r){\n    rep(i,r)rep(j,c)cin>>m[i][j];\n    rep(j,c)if (m[r-1][j] == 2){\n      assert(false);\n    }\n    rep(j,c)m[r][j]=m[r+1][j]=0;\n    cout << solve(r,c) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\nint x, y;\nint dp[15][15];\nint mp[15][15];\nint main() {\n  while (scanf(\"%d%d\",&x,&y)) {\n    if (!x&&!y) break;\n    memset(dp, 0, sizeof(dp));\n    memset(mp, 0, sizeof(mp));\n    for (int i=0; i<y; i++) {\n      for (int j=0; j<x; j++) scanf(\"%d\",&mp[i][j]);\n    }\n    for (int i=0; i<x; i++) if (mp[0][i]!=1) dp[0][i]=1;\n    int res = 0;\n    for (int i=0; i<y-1; i++) {\n      for (int j=0; j<x; j++) {\n        if (mp[i][j]==1) continue;\n        if (mp[i][j]==2) {\n          if (i+2>=y) res+=dp[i][j];\n          else dp[i+2][j]+=dp[i][j];\n        } else {\n          if (j!=0&&mp[i+1][j-1]==0) dp[i+1][j-1]+=dp[i][j];\n          if (mp[i+1][j]!=1) dp[i+1][j]+=dp[i][j];\n          if (j!=x-1&&mp[i+1][j+1]==0) dp[i+1][j+1]+=dp[i][j];\n        }\n      }\n    }\n    for (int i=0; i<x; i++) res+=dp[y-1][i];\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#define N 15\nusing namespace std;\nvoid func(int,int);\nint jump(int,int);\nint X,Y,data[N][N],memo[N+2][N];\nint main(){\n  while(1){\n    cin >> X >> Y;\n    if(X==0&&Y==0) break;\n    for(int i=0;i<Y;i++)\n      for(int j=0;j<X;j++)\n\tcin >> data[i][j];\n    for(int i=0;i<Y+2;i++)\n      for(int j=0;j<X;j++)\n\tmemo[i][j]=0;\n    for(int i=0;i<X;i++)\n      if(data[0][i]!=1)\n\tfunc(0,i);\n    int cnt=0;\n    for(int i=0;i<X;i++)\n      cnt+=memo[0][i];\n    cout << cnt << endl;\n  }\n  return 0;\n}\nvoid func(int y,int x){\n  if(y>=Y-1){\n    memo[Y][x]=memo[Y-1][x]=1;\n    return ;\n  }\n  if(0<=x-1&&data[y+1][x-1]==0){\n    if(memo[y+1][x-1]!=0) memo[y][x]+=memo[y+1][x-1];\n    else{\n      func(y+1,x-1),memo[y][x]+=memo[y+1][x-1];\n    }\n  }\n  if(x+1<X&&data[y+1][x+1]==0){\n    if(memo[y+1][x+1]!=0) memo[y][x]+=memo[y+1][x+1];\n    else{\n      func(y+1,x+1),memo[y][x]+=memo[y+1][x+1];\n    }\n  }\n  if(data[y+1][x]==0){\n    if(memo[y+1][x]!=0) memo[y][x]+=memo[y+1][x];\n    else{\n      func(y+1,x),memo[y][x]+=memo[y+1][x];\n    }\n  }\n  if(data[y+1][x]==2){\n    int r=jump(y+1,x);\n    if(r==-2) memo[y][x]+=1,memo[y+1][x]=1;\n    else if(r!=-1){\n      if(memo[r][x]!=0) memo[y][x]+=memo[r][x];\n      else{\n\tfunc(r,x),memo[y][x]+=memo[r][x];\n      }\n    }\n  }\n  if(memo[y][x]==0) data[y][x]=1;\n}\nint jump(int y,int x){\n  y+=2;\n  while(1){\n    if(y>=Y-1) return -2;\n    if(data[y][x]==1) break;\n    if(data[y][x]==0) return y;\n    if(data[y][x]==2) y+=2;\n  }\n  return -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint dp[32][15]; // dp[Y][X]\nint field[32][16];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    while(true) {\n        int X, Y;\n        cin >> X >> Y;\n        if(!X && !Y) break;\n\n        // Initialize\n        for(int i = 0; i < Y; ++i) {\n            for(int j = 0; j < X; ++j) {\n                cin >> field[i][j];\n                dp[i][j] = 0;\n            }\n        }\n        for(int j = 0; j < X; ++j) {\n            dp[Y][j] = 0;\n        }\n\n        // Base case\n        for(int i = 0; i < X; ++i) {\n            if(field[0][i] == 0) dp[0][i] = 1;\n            else dp[0][i] = 0;\n        }\n        for(int i = 0; i < Y-1; ++i) {\n            for(int j = 0; j < X; ++j) {\n                if(field[i][j] == 0) {\n                    // Move\n                    for(int dx = -1; dx <= 1; ++dx) {\n                        const int nx = j + dx;\n                        if(nx < 0 || nx >= X) continue;\n                        if(field[i+1][nx] == 0) dp[i+1][nx] += dp[i][j];\n                        else if(dx == 0 && field[i+1][nx] == 2) dp[i+1][nx] += dp[i][j];\n                    }\n                } else if(field[i][j] == 2) {\n                    // Jump\n                    if(field[i+2][j] != 1) dp[i+2][j] += dp[i][j];\n                }\n            }\n        }\n        int ans = 0;\n        for(int i = 0; i < 2; ++i) {\n            for(int j = 0; j < X; ++j) {\n                ans += dp[Y-1+i][j];\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\n\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nint x, y, c[50][50], dp[50][50];\nconst int dx[3] = {-1, 0, 1};\n\nvoid solve() {\n  memset(dp, 0, sizeof dp);\n  \n  rep(i,y) rep(j,x) cin>>c[i][j];\n  \n  rep(i,x) if (c[0][i] == 0) dp[0][i] = 1;\n  \n  rep(i,y-1) rep(j,x) {\n    if (c[i][j] == 0) {\n      rep(z,3) {\n        int ti = i + 1, tj = j + dx[z];\n        if (tj < 0 || tj >= x) continue;\n        //if (c[ti][tj] == 1) continue;\n        //if (c[ti][tj] == 2 && z != 1) continue;\n        //dp[ti][tj] += dp[i][j];\n        if (c[ti][tj] == 0) dp[ti][tj] += dp[i][j];\n        else if (c[ti][tj] == 2 && z == 1) dp[ti][tj] += dp[i][j];\n      }\n    } else if (c[i][j] == 2 && c[i+2][j] != 1) {\n      dp[i+2][j] += dp[i][j];\n    }\n  }\n  /*\n  rep(i,y+1) {\n    rep(j,x) printf(\"%8d\",dp[i][j]);\n    cout<<endl;\n  }*/\n  \n  int res = 0;\n  rep(j,x) res += dp[y][j] + dp[y-1][j];\n  cout<<res<<endl;\n}\n\nint main (int argc, char const* argv[]) {\n  while (cin>>x>>y, x||y) {\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nint main() {\n\tint x, y;\n\twhile (cin >> x >> y, x * y) {//\n\t\tint skimap[15][15] = {};//x = j y = i\n\t\tint dp[15][15] = {};//x = j y = i\n\t\tint flyover = 0;\n\t\tfor (int i = 0; i < y; i++) {\n\t\t\tfor (int j = 0; j < x; j++) {\n\t\t\t\tcin >> skimap[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < x;i++){\n\t\t\tif (skimap[0][i] == 0)dp[0][i] = 1;\n\t\t}\n\t\tfor (int i = 0; i < y - 1; i++) {\n\t\t\tfor (int j = 0; j < x; j++) {\n\t\t\t\tif (skimap[i][j] == 0) {\n\t\t\t\t\tif (j - 1 >= 0) {\n\t\t\t\t\t\tif (skimap[i + 1][j - 1] == 0) {\n\t\t\t\t\t\t\tdp[i + 1][j - 1] += dp[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (skimap[i + 1][j] != 1)dp[i + 1][j] += dp[i][j];\n\t\t\t\t\tif (j + 1 < x) {\n\t\t\t\t\t\tif (skimap[i + 1][j + 1] == 0) {\n\t\t\t\t\t\t\tdp[i + 1][j + 1] += dp[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (skimap[i][j] == 1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}else {\n\t\t\t\t\tif (i + 2 < y) {\n\t\t\t\t\t\tdp[i + 2][j] = dp[i][j];\n\t\t\t\t\t}else {\n\t\t\t\t\t\tflyover += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint sum = flyover;\n\t\tfor (int i = 0; i < x; i++) {\n\t\t\tsum += dp[y - 1][i];\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n\nint map[15][15],table[15][15],X,Y;\n\nint main(){\nwhile(1){\n\nscanf(\"%d%d\",&X,&Y);\nif(X==0&&Y==0) return 0;\nmemset(map,-1,sizeof(map));\nmemset(table,0,sizeof(table));\nfor(int i=0;i<Y;i++){\nfor(int j=0;j<X;j++){\nscanf(\"%d\",&map[i][j]);\nif(i==0&&map[i][j]==0) table[i][j]=1;\nelse if(i!=0&&map[i][j]==0){\nif(j>0&&map[i-1][j-1]==0) table[i][j]+=table[i-1][j-1];\nif(j<X-1&&map[i-1][j+1]==0) table[i][j]+=table[i-1][j+1];\nif(map[i-1][j]==0)table[i][j]+=table[i-1][j];\nif(i>2&&map[i-2][j]==2) table[i][j]+=table[i-2][j]; \n} \n}\n}\nint sum=0;\nfor(int i=0;i<X;i++){\nsum+=map[Y-1][i];\n}\nprintf(\"%d\\n\",sum);\n\n\n\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#define N 15\nusing namespace std;\nvoid func(int,int);\nint jump(int,int);\nint X,Y,data[N][N],memo[N+2][N];\nint main(){\n  while(1){\n    cin >> X >> Y;\n    if(X==0&&Y==0) break;\n    for(int i=0;i<N+2;i++){\n      for(int j=0;j<N+2;j++){\n\tdata[i][j]=0;\n      }\n    }\n    for(int i=0;i<Y;i++)\n      for(int j=0;j<X;j++) cin >> data[i][j];\n    for(int i=0;i<Y+2;i++)\n      for(int j=0;j<X;j++) memo[i][j]=0;\n    for(int i=0;i<X;i++)\n      if(data[0][i]!=1)\tfunc(0,i);\n    int cnt=0;\n    for(int i=0;i<X;i++) cnt+=memo[0][i];\n    cout << cnt << endl;\n  }\n  return 0;\n}\nvoid func(int y,int x){\n  if(y>=Y-1){\n    memo[Y][x]=memo[Y-1][x]=1;\n    return ;\n  }\n  if(y+1<Y&&0<=x-1&&data[y+1][x-1]==0){\n    if(memo[y+1][x-1]!=0) memo[y][x]+=memo[y+1][x-1];\n    else{\n      func(y+1,x-1),memo[y][x]+=memo[y+1][x-1];\n    }\n  }\n  if(y+1<Y&&x+1<X&&data[y+1][x+1]==0){\n    if(memo[y+1][x+1]!=0) memo[y][x]+=memo[y+1][x+1];\n    else{\n      func(y+1,x+1),memo[y][x]+=memo[y+1][x+1];\n    }\n  }\n  if(data[y+1][x]==0){\n    if(memo[y+1][x]!=0) memo[y][x]+=memo[y+1][x];\n    else{\n      func(y+1,x),memo[y][x]+=memo[y+1][x];\n    }\n  }\n  if(data[y+1][x]==2){\n    int r=jump(y+1,x);\n    if(r!=-1){\n      if(memo[r][x]!=0) memo[y][x]+=memo[r][x];\n      else func(r,x),memo[y][x]+=memo[r][x];\n    }\n  }\n  if(memo[y][x]==0) data[y][x]=1;\n}\nint jump(int y,int x){\n  y+=2;\n  while(1){\n    if(data[y][x]==1) break;\n    if(data[y][x]==0) return y;\n    if(y>=Y-1) return y;\n    y+=2;\n  }\n  return -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n  int x, y;\n  while (cin >> x >> y, x){\n    int map[32][32];\n    for (int i = 1; i <= y; i++){\n      for (int j = 1; j <= x; j++){\n        cin >> map[i][j];\n      }\n    }\n\n    int dp[32][32] = {0};\n    for (int j = 1; j <= x; j++) dp[1][j] = 1;\n    for (int i = 1; i <= y; i++){\n      for (int j = 1; j <= x; j++){\n        if (map[i][j] == 1) continue;\n        if (map[i][j] == 2){\n          dp[i + 2][j] = dp[i][j];\n          continue;\n        }\n\n        for (int k = -1; k < 2; k++){\n          if (map[i + 1][j + k] == 2 && k) continue;\n          dp[i + 1][j + k] += dp[i][j];\n        }\n      }\n    }\n\n    int ans = 0;\n    for (int j = 1; j <= x; j++){\n      ans += dp[y][j];\n    }\n\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint main()\n{\n    for(;;){\n        int w, h;\n        cin >> w >> h;\n        if(w == 0)\n            return 0;\n\n        vector<vector<int> > grid(h+1, vector<int>(w+2, 0));\n        for(int i=0; i<h+1; ++i)\n            grid[i][0] = grid[i][w+1] = 1;\n        for(int i=0; i<h; ++i){\n            for(int j=1; j<=w; ++j){\n                cin >> grid[i][j];\n            }\n        }\n\n        vector<vector<int> > num(h+1, vector<int>(w+2, 0));\n        for(int i=1; i<=w; ++i){\n            if(grid[0][i] == 0)\n                num[0][i] = 1;\n        }\n\n        for(int y=0; y<h-1; ++y){\n            for(int x=1; x<=w; ++x){\n                if(grid[y][x] == 2){\n                    if(grid[y+2][x] != 1)\n                        num[y+2][x] += num[y][x];\n                }else{\n                    for(int dx=-1; dx<=1; ++dx){\n                        if(grid[y+1][x+dx] == 1 || (grid[y+1][x+dx] == 2 && dx != 0))\n                            continue;\n                        num[y+1][x+dx] += num[y][x];\n                    }\n                }\n            }\n        }\n\n        int ret = accumulate(num[h-1].begin(), num[h-1].end(), 0);\n        ret += accumulate(num[h].begin(), num[h].end(), 0);\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define MAX 15\n\nint memo[MAX][MAX];\nint X, Y;\nint data[MAX][MAX];\n\nint rec(int x, int y) {\n  static int d[3][2] = {{-1,1},{0,1},{1,1}};\n\n  if(memo[y][x] == -1) {\n    memo[y][x] = 0;\n    if(y == Y-1) {\n      memo[y][x] += 1;\n    } else if(data[y][x] == 2) {\n      int nx = x;\n      int ny = y+2;\n      if(ny >= Y) {\n\tmemo[y][x] += 1;\n      } else {\n\tif(data[ny][nx] != 1)\n\t  memo[y][x] += rec(nx, ny);\n      }\n    } else {\n      for(int i = 0; i < 3; i++) {\n\tint nx = x + d[i][0];\n\tint ny = y + d[i][1];\n\tif(nx < 0 || nx >= X) continue;\n\tif(data[ny][nx] == 1) continue;\n\tif(i != 1 && data[ny][nx] == 2) continue;\n\tmemo[y][x] += rec(nx, ny);\n      }\n    }\n  }\n  return memo[y][x];\n}\n\nmain() {\n  while(1) {\n    cin >> X >> Y;\n    if(X == 0 && Y == 0) break;\n    for(int i = 0; i < Y; i++) {\n      for(int j = 0; j < X; j++) {\n\tcin >> data[i][j];\n\tmemo[i][j] = -1;\n      }\n    }\n    \n    int cnt = 0;\n    for(int j = 0; j < X; j++) {\n      if(data[0][j] == 0) \n\tcnt += rec(j, 0);\n    }\n    /*for(int i = 0; i < Y; i++) {\n      for(int j = 0; j < X; j++) {\n\tcout << memo[i][j] << ' ';\n      }\n      cout << endl;\n      }\n      cout << endl;*/\n    cout << cnt << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main()\n{\n\tint n, m;\n\twhile (true){\n\t\tcin >> n >> m;\n\t\tif (n == 0 && m == 0){\n\t\t\tbreak;\n\t\t}\n\t\tint map[100][100] = { 0 };\n\t\tint dp[100][100] = { 0 };\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tfor (int i2 = 0; i2 < n; i2++){\n\t\t\t\tcin >> map[i][i2];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tif (map[0][i] == 0){\n\t\t\t\tdp[0][i] = 1;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < m-1; i++){\n\t\t\tfor (int i2 = 0; i2 < n; i2++){\n\t\t\t\tif (map[i][i2] == 0){\n\t\t\t\t\tif (map[i + 1][i2] == 0 || map[i + 1][i2] == 2){\n\t\t\t\t\t\tdp[i + 1][i2] += dp[i][i2];\n\t\t\t\t\t}\n\t\t\t\t\tif (i2+1<m&&map[i + 1][i2 + 1] == 0){\n\t\t\t\t\t\tdp[i + 1][i2 + 1] += dp[i][i2];\n\t\t\t\t\t}\n\t\t\t\t\tif (i2 - 1 >= 0 && map[i + 1][i2 - 1] == 0){\n\t\t\t\t\t\tdp[i + 1][i2 - 1] += dp[i][i2];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (map[i][i2] == 2){\n\t\t\t\t\tif (map[i + 2][i2] == 0 || map[i + 2][i2] == 2){\n\t\t\t\t\t\tdp[i + 2][i2] += dp[i][i2];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tans += dp[m - 1][i];\n\t\t\tans += dp[m][i];\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint dy[] = { 1, 1, 1};\nint dx[] = { -1, 0, 1 };\n\nint main() {\n    while (1) {\n        int dp[17][15] = { 0 };\n        int field[15][15] = { 0 };\n        int h, w;\n\n        cin >> w >> h;\n        if (w == 0) {\n            break;\n        }\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                cin >> field[i][j];\n            }\n        }\n        \n        for (int j = 0; j < w; j++) {\n            if (field[0][j] == 0) {\n            dp[0][j] = 1;\n            }\n        }\n        \n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                if (dp[i][j] > 0) {\n                    if (i == h - 1) {\n                        dp[i + 1][j] += dp[i][j];\n                        continue;\n                    }\n                    if (field[i][j] == 2) {\n                        if (field[i + 2][j] == 0 || field[i + 2][j] == 2) {\n                            dp[i + 2][j] += dp[i][j];\n                        }\n                        continue;\n                    }\n                    for (int k = 0; k < 3; k++) {\n                        int nx = j + dx[k];\n                        int ny = i + dy[k];\n                        if (nx < 0 || nx >= w) {\n                            continue;\n                        }\n                        if (field[ny][nx] == 0 || (field[ny][nx] == 2 && k == 1)) {\n                            dp[ny][nx] += dp[i][j];\n                        }\n                    }\n                }\n            }\n        }\n        \n        int ans = 0;\n        for (int j = 0; j < w; j++) {\n            ans += dp[h][j];\n        }\n        cout << ans << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n \nint main(){\n        int x,y;\n        while(cin>>x>>y,x){\n                int D[16][16],P[16][16],ans=0;\n                for(int i=0;i<256;i++)P[i/16][i%16]=0;\n                for(int i=0;i<y;i++)for(int j=0;j<x;j++)cin>>D[i][j];\n                for(int i=0;i<x;i++)if(!D[0][i])P[0][i]=1;\n                for(int i=0;i<y-1;i++){\n                        for(int j=0;j<x;j++){\n                                if(!D[i][j]){\n                                        P[i+1][j]+=P[i][j];\n                                        if(j>0&&!D[i+1][j-1])P[i+1][j-1]+=P[i][j];\n                                        if(j<x-1&&!D[i+1][j+1])P[i+1][j+1]+=P[i][j];\n                                }\n                                if(D[i][j]==2){\n                                        if(i==y-2) ans += P[i][j];\n                                        else P[i+2][j]+=P[i][j];\n                                }\n                        }\n                }\n                for(int i=0;i<x;i++){\n                        if (D[y - 1][i] != 1)ans+=P[y-1][i];\n                }\n                cout<<ans<<endl;\n        }\n}\n "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF 1001000100010001000\n#define MOD 1000000007\n#define EPS 1e-10\n#define int long long\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define Rep(i, N) for (int i = 1; i < N; i++)\n#define For(i, a, b) for (int i = (a); i < (b); i++)\n#define pb push_back\n#define eb emplece_back\n#define mp make_pair\n#define i_i pair<int, int>\n#define vi vector<int>\n#define vvi vector<vi >\n#define vb vector<bool>\n#define vvb vector<vb >\n#define vp vector< i_i >\n#define Edge pair< i_i, int>\n#define all(a) (a).begin(), (a).end()\n#define Int(x) int x; scanf(\"%lld\", &x);\n#define int2(x, y) int x, y; scanf(\"%lld %lld\", &x, &y);\n#define fir first\n#define sec second\n#define ffir first.first\n#define fsec first.second\n#define sfir second.first\n#define ssec second.second\n \n//int dxy[5] = {0, 1, 0, -1, 0};\n// assign\n \nsigned main()\n{\n    int2(a, b);\n    while (a) {\n        vvi data(a, vi(b));\n        rep(i, a) {\n            rep(j, b) {\n                cin >> data[i][j];\n            }\n        }\n        \n       // cout << \"=======\" << endl;\n        vvi dp(a+1, vi(b, 0));\n        rep(i, b) {\n            if (!data[0][i]) {\n                dp[0][i] = 1;\n            }\n        }\n        \n\n        rep(i, a-1) {\n            rep(j, b) {\n                if (!data[i][j]) {\n                    for (int k = -1; k < 2; k++) {\n                        if (data[i+1][j+k] == 2) {\n                            if (!k) {\n                                dp[i+1][j] += dp[i][j];\n                            }\n                        } else if (!data[i+1][j+k]) {\n                            dp[i+1][j+k] += dp[i][j];\n                        }\n                    }\n                } else if (data[i][j] == 2) {\n                    dp[i+2][j] += dp[i][j];\n                }\n            }\n        }\n/*\n        rep(i, a+1) {\n            rep(j, b) {\n                cout << dp[i][j] << \" \";\n            }cout << endl;\n        }*/\n\n        int ans = 0;\n        rep(i, b) {\n            ans += dp[a][i] + dp[a-1][i];\n            /*\n            if (data[a-1][i] == 1) {\n                //cout << dp[a][i] << \" \";\n                ans += dp[a][i];\n            } else {\n                //cout << dp[a-1][i] << \" \";\n                ans += dp[a-1][i];\n            }\n            */\n        }\n        cout << ans << endl;\n        cin >> a >> b;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n\nint main() {\n    int field[16][17], pattern[17][17];\n    int X, Y, i, j, k;\n\n    while ((cin >> X >> Y) && X) {\n        for (i = 1; i <= Y; i++) {\n            field[i][0] = field[i][X+1] = 0;\n            for (j = 1; j <= X; j++) {\n                cin >> field[i][j];\n            }\n        }\n\n        for (i = 2; i <= Y+1; i++) {\n            for (j = 0; j <= X + 1; j++) {\n                pattern[i][j] = 0;\n            }\n        }\n        for (j = 1; j <= X; j++) {\n            pattern[1][j] = field[1][j] == 0;\n        }\n\n        for (i = 1; i < Y; i++) {\n            for (j = 1; j <= X; j++) {\n                switch (field[i][j]) {\n                    case 0:\n                    for (k = -1; k <= 1; k++) {\n                        switch (field[i+1][j+k]) {\n                            case 0:\n                            pattern[i+1][j+k] += pattern[i][j];\n                            break;\n                            case 2:\n                            if (k == 0) {\n                                pattern[i+1][j+k] += pattern[i][j];\n                            }\n                            break;\n                            default: break;\n                        }\n                    }\n                    break;\n                    case 2:\n                    pattern[i+2][j] += pattern[i][j];\n                    break;\n                    default: break;\n                }\n            }\n        }\n        /*\n        for (i = 1; i <= Y; i++) {\n            for (j = 1; j <= X; j++) {\n                cout << \" \" << pattern[i][j];\n            }\n            cout << endl;\n        }\n        cout << endl;\n        */\n        int sum = 0;\n        for (i = Y; i <= Y + 1; i++) {\n            for (j = 1; j <= X; j++) {\n                sum += pattern[i][j];\n            }\n        }\n        cout << sum << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\n#define MAX 20\n\nint W,H;\nint arr[MAX][MAX];\nint dp[MAX][MAX];\nconst int dx[] = {-1,0,1};\nconst int dy[] = {1,1,1};\n\nbool inField(int y,int x){\n  return 0 <= y && y < H && 0 <= x && x < W;\n}\n\nint solve(int y,int x){\n  if(y == H-1){\n    if(arr[y][x] == 0 || arr[y][x] == 2){\n      return 1;\n    }else{\n      return 0;\n    }\n  }\n  if(dp[y][x] != -1) return dp[y][x];\n\n  int res = 0;\n  if(arr[y][x] != 2){\n    for(int i = 0 ; i < 3 ; i++){\n      int nx = x + dx[i];\n      int ny = y + dy[i];\n      if(!inField(ny,nx)) continue;\n      if(arr[ny][nx] == 1) continue;\n      if(arr[ny][nx] == 0){\n        res += solve(ny,nx);\n      }else{\n        if(x == nx){\n          res += solve(ny,nx);\n        }\n      }\n    }\n  }else{\n    int nx = x, ny = y + 2;\n    if(!inField(ny,nx)) return 1;\n    res += solve(ny,nx);\n  }\n  return dp[y][x] = res;\n}\n\nint main(){\n  while(cin >> W >> H, (W | H)){\n    for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n        cin >> arr[i][j];\n        dp[i][j] = -1;\n      }\n    }\n    int res = 0;\n    for(int i = 0 ; i < W ; i++){\n      if(arr[0][i] == 0){\n        res += solve(0,i);\n      }\n    }\n    cout << res << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint w,h;\nint mp[20][20],memo[20][20];\nvoid saiki(int x,int y){\n  if(y >= h-1) memo[y][x]++;\n  else \n    for(int i=-1;i<=1;i++) {\n      int nx = x+i, ny = y+1;\n      if(nx==x && mp[ny][nx] == 2)while(mp[ny][nx] == 2) ny+=2;\n      if(nx <0|| nx >= w ||mp[ny][nx] != 0) continue;\n      if(memo[ny][nx]==0) saiki(nx,ny);\n      memo[y][x] += memo[ny][nx];\n    }\n  if(memo[y][x] == 0) mp[y][x] = 1;\n}\nint main() {\n  while(1) {\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n    for(int i=0;i<=19;i++)\n      for(int j=0;j<=19;j++)memo[i][j] = mp[i][j] = 0;\n     \n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)cin >> mp[i][j];\n  \n    for(int i=0;i<w;i++)\n      if(mp[0][i] !=1) saiki(i,0);\n     \n    int cnt = 0;\n    for(int i=0;i<w;i++)cnt+=memo[0][i];\n    cout <<cnt<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n\nusing namespace std;\n\n\nint main() {\n\twhile(1) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tif(x==0 && y==0) break;\n\t\tint field[x][y];\n\t\tfor(int i=0; i<x; i++) {\n\t\t\tfor(int j=0; j<y; j++) {\n\t\t\t\tcin >> field[i][j];\n\t\t\t}\n\t\t}\n\t\tint dp[x+1][y];\n\t\tfor(int i=0; i<x+1; i++) {\n\t\t\tfor(int j=0; j<y; j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<x; i++) {\n\t\t\tfor(int j=0; j<y; j++) {\n\t\t\t\tif(i==0) dp[i][j] = 1;\n\t\t\t\telse {\n\t\t\t\t\tif(field[i][j] == 0) {\n\t\t\t\t\t\tif(0<j && field[i-1][j-1] == 0) dp[i][j] += dp[i-1][j-1];\n\t\t\t\t\t\tif(field[i-1][j] == 0) dp[i][j] += dp[i-1][j];\n\t\t\t\t\t\tif(j<y-1 && field[i-1][j+1] == 0) dp[i][j] += dp[i-1][j+1];\n\t\t\t\t\t}\n\t\t\t\t\tif(field[i][j] == 2) {\n\t\t\t\t\t\tdp[i][j] += dp[i-1][j];\n\t\t\t\t\t\tdp[i+2][j] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<y; i++) dp[x][i] += dp[x-1][i];\n\t\tint sum=0;\n\t\tfor(int i=0; i<y; i++) sum += dp[x][i];\n\t\tcout << sum;\n\n//\t\tfor(int i=0; i<x+1; i++) {\n//\t\t\tfor(int j=0; j<y; j++) {\n//\t\t\t\tcout << dp[i][j] << ' ';\n//\t\t\t}\n//\t\t\tcout << endl;\n//\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#define N 16\nusing namespace std;\nvoid func(int,int);\nint jump(int,int);\nint X,Y,data[N][N],memo[N+2][N];\nint main(){\n  while(1){\n    cin >> X >> Y;\n    if(X==0&&Y==0) break;\n    for(int i=0;i<Y;i++)\n      for(int j=0;j<X;j++) cin >> data[i][j];\n    for(int i=0;i<Y+2;i++)\n      for(int j=0;j<X;j++) memo[i][j]=0;\n    for(int i=0;i<X;i++)\n      if(data[0][i]!=1)\tfunc(0,i);\n    int cnt=0;\n    for(int i=0;i<X;i++) cnt+=memo[0][i];\n    cout << cnt << endl;\n  }\n  return 0;\n}\nvoid func(int y,int x){\n  if(y>=Y-1){\n    memo[Y][x]=memo[Y-1][x]=1;\n    return ;\n  }\n  if(0<=x-1&&data[y+1][x-1]==0){\n    if(memo[y+1][x-1]!=0) memo[y][x]+=memo[y+1][x-1];\n    else{\n      func(y+1,x-1),memo[y][x]+=memo[y+1][x-1];\n    }\n  }\n  if(x+1<X&&data[y+1][x+1]==0){\n    if(memo[y+1][x+1]!=0) memo[y][x]+=memo[y+1][x+1];\n    else{\n      func(y+1,x+1),memo[y][x]+=memo[y+1][x+1];\n    }\n  }\n  if(data[y+1][x]==0){\n    if(memo[y+1][x]!=0) memo[y][x]+=memo[y+1][x];\n    else{\n      func(y+1,x),memo[y][x]+=memo[y+1][x];\n    }\n  }\n  if(data[y+1][x]==2){\n    int r=jump(y+1,x);\n    if(r!=-1){\n      if(memo[r][x]!=0) memo[y][x]+=memo[r][x];\n      else{\n\tfunc(r,x),memo[y][x]+=memo[r][x];\n      }\n    }\n  }\n  if(memo[y][x]==0) data[y][x]=1;\n}\nint jump(int y,int x){\n  y+=2;\n  while(1){\n    if(data[y][x]==1) break;\n    if(y>=Y-1) return y;\n        if(data[y][x]==0) return y;\n    y+=2;\n  }\n  return -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint solve(int x,int y);\nint ax,ay;\nint mas[20][20];\nint memo[20][20];\nint main(){\n  while(1){\n    int ans=0;\n    for(int i=0;i<20;i++){\n      for(int j=0;j<20;j++){\n\tmemo[i][j]=0;\n      }\n    }\n    cin>>ax>>ay;\n    if(ax==0 && ay==0){\n      break;\n    }\n    for(int i=0;i<ay;i++){\n      for(int j=0;j<ax;j++){\n\tcin>>mas[i][j];\n      }\n    }\n    for(int i=0;i<ax;i++){\n      if(mas[0][i]!=1){\n\tans+=solve(i,0);\n      }\n    }\n    cout<<ans<<endl;\n  }\n}\nint solve(int x,int y){\n  if(memo[y][x]!=0){\n    return memo[y][x];\n  }\n  else if(y==ay){\n    return 1;\n  }else if(mas[y][x]==1){\n    return 0;\n  }else if(mas[y][x]==2){\n    return solve(x,y+2);\n  } \n  else{\n    int anss=0; \n    if(mas[y+1][x]!=1){\n      anss+=solve(x,y+1);\n    }\n    if(x+1<ax && mas[y+1][x+1]==0 && y+1!=ay){\n      anss+=solve(x+1,y+1);\n    }\n    if(0<=x-1 && mas[y+1][x-1]==0 && y+1!=ay){\n      anss+=solve(x-1,y+1);\n    }\n    return memo[y][x]=anss;\n  }\n}  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nconst int MAX_Y = 15;\nconst int MAX_X = 15;\nint mx, my, c[MAX_Y][MAX_X], dp[MAX_Y][MAX_X];\n\nconst int dx[3] = {-1, 0, 1};\nconst int dy[3] = {1, 1, 1};\n\nint dfs(int y, int x) {  \n  int res = 0;\n  if (dp[y][x] >= 0) return dp[y][x];\n  \n  if (y >= my - 1) res = 1;\n  \n  if (c[y][x] == 2) {\n    if (y + 2 >= my - 1) {\n      res = 1;\n    } else {\n      res += dfs(y+2, x);\n    }\n  }\n  \n  if (res != 0) return dp[y][x] = res;\n  \n  rep(z,3) {\n    int tx = x + dx[z], ty = y + dy[z];\n    if (tx < 0 || ty < 0 || tx >= mx || ty >= my) continue;\n    if (c[ty][tx] == 1) continue;\n    if (c[ty][tx] == 2 && tx != x) continue;\n    res += dfs(ty, tx);\n  }\n\n  return dp[y][x] = res;\n}\n\nvoid solve() {\n  memset(dp, -1, sizeof dp);\n  rep(i,my) rep(j,mx) cin>>c[i][j];\n\n  int res = 0;\n  rep(i,mx) {\n    if (c[0][i] == 1) continue;\n    res += dfs(0, i);\n  }\n  cout<<res<<endl;\n}\n\nint main (int argc, char const* argv[]) {\n  while (cin>>mx>>my, mx||my) {\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\nint w,h;\nint f[22][22];\nint dp[22][22];\nint dx[] = {-1,0,1};\nint solve(int x,int y){\n  //printf(\"(%d,%d)\\n\",x,y);\n  if(y >= h) return 1;\n  if(f[x][y] == 1) return 0;\n  if(dp[x][y] >= 0) return dp[x][y];\n  if(f[x][y] == 2) return dp[x][y] = solve(x,y + 2);\n\n  int ret = 0;\n  for(int i = 0; i < 3; i++){\n    int nx = x + dx[i];\n    if(!f[nx][y+1] || (!dx[i] && f[nx][y+1] == 2)){\n      ret += solve(nx,y+1);\n    }\n  }\n  return dp[x][y] = ret;\n}\nint main(void){\n  while(1){\n    scanf(\"%d%d\",&w,&h); if(!w) break;\n    memset(f,-1,sizeof(f));\n    memset(dp,-1,sizeof(dp));\n    for(int i = 1; i <= h; i++){\n      for(int j = 1; j <= w; j++){\n\tscanf(\"%d\",&f[j][i]);\n      }\n    }\n    int ans = 0;\n    for(int j = 1; j <= w; j++){\n      ans += solve(j,1);\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<numeric>\nusing namespace std;\n\nint main() {\n\tint x, y;\n\twhile (cin >> x >> y, x, y) {\n\t\tvector<vector<int>> course(y + 2, vector<int>(x + 2, 0));\n\t\tfor (int i = 1; i <= y; i++) {\n\t\t\tfor (int j = 1; j <= x; j++) {\n\t\t\t\tcin >> course[i][j];\n\t\t\t}\n\t\t}\n\n\t\tvector<vector<int>> path(y + 2, vector<int>(x + 2, 0));\n\t\t//?????????????????????????????????1????????????\n\t\tfor (int i = 1; i <= x; i++) {\n\t\t\tif (course[1][i] != 1) path[1][i] = 1;\n\t\t}\n\n\t\tfor (int i = 1; i <= y; i++) {\n\t\t\tfor (int j = 1; j <= x; j++) {\n\t\t\t\t//????????????????????´????????????????????´??????????????????????????????????????????\n\t\t\t\t//?????????????§????????????????????????´?????????????????????????????£????????°?????´????????????????????????\n\t\t\t\tif (course[i][j] == 0) {\n\t\t\t\t\tif (course[i + 1][j + 1] == 0) path[i + 1][j + 1] += path[i][j];\n\t\t\t\t\tif (course[i + 1][  j  ] != 1) path[i + 1][  j  ] += path[i][j];\n\t\t\t\t\tif (course[i + 1][j - 1] == 0) path[i + 1][j - 1] += path[i][j];\n\t\t\t\t}\n\t\t\t\t//?¬???????????????´???????????£????????°????????????????????????????????????\n\t\t\t\t//?????????????????£????????§??´??????????????´???????????????(?????£?????????????????????????????´???????????????)\n\t\t\t\tif (course[i][j] == 2 && course[i+2][j] != 1) {\n\t\t\t\t\tpath[i + 2][j] += path[i][j];\n\t\t\t\t\tif(i + 2 > y && i != y) path[y][j] += path[i][j];\n\t\t\t\t}\n\t\t\t\t//???????????´???????????????????????????????????????\n\t\t\t\tif(course[i][j] == 1){/*do anything*/}\n\t\t\t}\n\t\t}\n\n\t\tcout << accumulate(path[y].begin()+1, path[y].end()-1, 0) << endl;\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\nint X,Y,imap[20][20];\nconst int dx[3] = {-1,0,1};\nconst int dy[3] = {1,1,1};\nint sam,dp[20][20];\n\nint solve(){\n  \n  int ans = 0;\n  for(int i=0;i<=Y;i++)for(int j=0;j<=X;j++)dp[i][j] = (i==0 && imap[i][j] != 1)?1:0; \n\n  for(int i=0;i<Y-1;i++){\n    for(int j=0;j<X;j++){\n      if(dp[i][j] == 0 || imap[i][j] == 1)continue;\n      if(imap[i][j] == 0){\n\tfor(int k=0;k<3;k++){\n\t  int nx = j+dx[k],ny = i+dy[k];\n\t  if(0<= nx && nx<X && 0<= ny && ny < Y && imap[ny][nx] != 1){\n\t      if((k == 0 || k == 2) && imap[ny][nx] == 2)continue;\n\t      dp[ny][nx]+=dp[i][j];\n\t  }\n\t}\n      }\n      else if(imap[i][j] == 2){\n\tif(i+2 <Y && imap[i+2][j] != 1){\n\t  dp[i+2][j]+=dp[i][j];\n\t}\n\telse if(i+2 >= Y){\n\t  if(imap[Y-1][j] != 1)dp[Y-1][j]+=dp[i][j];\n\t}\n      }\n    }\n  }\n  /*\n  cout << endl;\n    for(int i=0;i<Y;i++){\n      for(int j=0;j<X;j++)cout << dp[i][j] << \" \";\n\tcout << endl;\n    }\n  */\n    for(int i=0;i<X;i++)ans += dp[Y-1][i];\n    return ans;\n}\n\n\n\nbool Init(){\n  cin >> X >> Y;\n  if(X+Y == 0)return false;\n  for(int i=0;i<Y;i++){\n    for(int j=0;j<X;j++){\n      cin >> imap[i][j];\n    }\n  }\n  sam = 0;\n  return true;\n}\n\n\nint main(){\n  while(true){\n    if(!Init())break;\n    cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nint main(void)\n{\n\tint field[20][20], dis[20][20];\n\tint i, j;\n\tint x, y;\n\tint ans;\n\t\n\twhile (1){\n\t\t\n\t\tscanf(\"%d %d\", &x, &y);\n\t\t\n\t\tif (x == 0 && y == 0) break;\n\t\t\n\t\tfor (i = 0; i < y; i++){\n\t\t\tfor (j = 0; j < x; j++){\n\t\t\t\tscanf(\"%d\", &field[i][j]);\n\t\t\t\tdis[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (i = 0; i < x; i++){\n\t\t\tif (field[0][i] == 0) dis[0][i] = 1;\n\t\t}\n\t\tfor (i = 0; i < x; i++) dis[y][i] = 0;\n\t\t\n\t\tfor (i = 0; i < y - 1; i++){\n\t\t\tfor (j = 0; j < x; j++){\n\t\t\t\t\n\t\t\t\tif (field[i][j] == 2 && field[i + 2][j] != 1){\n\t\t\t\t\tdis[i + 2][j] = dis[i][j];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif (field[i + 1][j] != 1){\n\t\t\t\t\t\tdis[i + 1][j] += dis[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tif (j != x - 1 && field[i + 1][j + 1] == 0){\n\t\t\t\t\t\tdis[i + 1][ j + 1] += dis[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tif (j != 0 && field[i + 1][j - 1] == 0){\n\t\t\t\t\t\tdis[i + 1][ j - 1] += dis[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = 0;\n\t\t\n\t\tfor (i = 0; i < x; i++){\n\t\t\tans += dis[y - 1][i];\n\t\t\tans += dis[y][i];\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#define N 15\nusing namespace std;\nvoid func(int,int);\nint jump(int,int);\nint X,Y,data[N][N],memo[N+2][N];\nint main(){\n  while(1){\n    cin >> X >> Y;\n    if(X==0&&Y==0) break;\n    for(int i=0;i<N+2;i++)\n      for(int j=0;j<N;j++) data[i][j]=0,memo[i][j]=0;\n    for(int i=0;i<Y;i++)\n      for(int j=0;j<X;j++) cin >> data[i][j];\n    for(int i=0;i<X;i++)\n      if(data[0][i]!=1)\tfunc(0,i);\n    int cnt=0;\n    for(int i=0;i<X;i++) cnt+=memo[0][i];\n    cout << cnt << endl;\n  }\n  return 0;\n}\nvoid func(int y,int x){\n  if(y>=Y-1){\n    memo[y][x]=memo[Y][x]=memo[Y-1][x]=1;\n    return ;\n  }\n  if(y+1<Y&&0<=x-1&&data[y+1][x-1]==0){\n    if(memo[y+1][x-1]!=0) memo[y][x]+=memo[y+1][x-1];\n    else func(y+1,x-1),memo[y][x]+=memo[y+1][x-1];\n  }\n  if(y+1<Y&&x+1<X&&data[y+1][x+1]==0){\n    if(memo[y+1][x+1]!=0) memo[y][x]+=memo[y+1][x+1];\n    else func(y+1,x+1),memo[y][x]+=memo[y+1][x+1];\n  }\n  if(data[y+1][x]==0){\n    if(memo[y+1][x]!=0) memo[y][x]+=memo[y+1][x];\n    else func(y+1,x),memo[y][x]+=memo[y+1][x];\n  }\n  if(data[y+1][x]==2){\n    int r=jump(y+1,x);\n    if(r!=-1){\n      if(memo[r][x]!=0) memo[y][x]+=memo[r][x];\n      else func(r,x),memo[y][x]+=memo[r][x];\n    }\n  }\n  if(memo[y][x]==0) data[y][x]=1;\n}\nint jump(int y,int x){\n  while(1){\n    y+=2;\n    if(data[y][x]==1) break;\n    if(data[y][x]==0||y>=Y-1) return y;\n  }\n  return -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n\tint n,m;\n\tint masu[17][17];\n\tint ura[17][17];\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0 && m==0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i=0;i<17;i++){\n\t\t\tfor(int j=0;j<17;j++){\n\t\t\t\tmasu[i][j]=0;\n\t\t\t\tura[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=1;j<=m;j++){\n\t\t\t\tscanf(\"%d\",&ura[i][j]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tswitch(ura[1][i]){\n\t\t\t\tcase 0:masu[1][i]+=1;break;\n\t\t\t\tcase 1:masu[1][i]+=0;break;\n\t\t\t\tcase 2:masu[2][i]+=1;break;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfor(int j=1;j<=m;j++){\n\t\t\t\tif(ura[i][j]==0){\n\t\t\t\t\tif(ura[i+1][j-1]==0){\n\t\t\t\t\t\tmasu[i+1][j-1]+=masu[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tif(ura[i+1][j]!=1){\n\t\t\t\t\t\tmasu[i+1][j]+=masu[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tif(ura[i+1][j+1]==0){\n\t\t\t\t\t\tmasu[i+1][j+1]+=masu[i][j];\n\t\t\t\t\t}\n\t\t\t\t}else if(ura[i][j]==2){\n\t\t\t\t\tif(ura[i+2][j]!=1){\n\t\t\t\t\t\tmasu[i+2][j]+=masu[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cont=0;\n\t\tfor(int i=n;i<=n+1;i++){\n\t\t\tfor(int j=1;j<=m;j++){\n\t\t\t\tcont+=masu[i][j];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",cont);\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint DP[16][17];\nint field[17][16];\nint x,y;\n\nint main(){\n\twhile(true){\n\t\tcin >> x >> y;\n\t\tif(!x && !y)\n\t\t\treturn 0;\n\t\t\n\t\tfor(int i=1; i<=y; i++)\n\t\t\tfor(int k=1; k<=x; k++)\n\t\t\t\tcin >> field[i][k];\n\t\tfor(int i=1; i<=x; i++)\n\t\t\tfield[y+1][i] = 0;\n\t\t\n\t\tfor(int i=0; i<=y+1; i++)\n\t\t\tfor(int k=0; k<=x+1; k++){\n\t\t\t\tDP[i][k]=0;\n\t\t\t\tif(i==1 && k>0 && k<=x){\n\t\t\t\t\tif(field[i][k] == 0)\n\t\t\t\t\t\tDP[i][k] = 1;\n\t\t\t\t\telse if(field[i][k] == 2){\n\t\t\t\t\t\tDP[i][k] = 0;\n\t\t\t\t\t\tint n = i+2;\n\t\t\t\t\t\twhile(true){\n\t\t\t\t\t\t\tif(field[n][k] == 0){\n\t\t\t\t\t\t\t\tDP[n][k] = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(field[n][k] == 1)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tn+=2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\tfor(int i=2; i<=y; i++){\n\t\t\tfor(int k=1; k<=x; k++){\n\t\t\t\tif(field[i][k] == 0)\n\t\t\t\t\tDP[i][k] += DP[i-1][k-1] + DP[i-1][k] + DP[i-1][k+1];\n\t\t\t\telse if(field[i][k] == 1)\n\t\t\t\t\tDP[i][k] = 0;\n\t\t\t\telse{\n\t\t\t\t\tDP[i][k] = 0;\n\t\t\t\t\tint n = i+2;\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\tif(field[n][k] == 0){\n\t\t\t\t\t\t\tDP[n][k] += DP[i-1][k];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else if(field[n][k] == 1)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tn+=2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans=0;\n\t\tfor(int i=y; i<=y+1; i++)\n\t\t\tfor(int k=1; k<=x; k++)\n\t\t\t\tans += DP[i][k];\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<queue>\n#include<functional>\n#include<cstring>\n#include<vector>\n#include<climits>\n#include<map>\nusing namespace std;\n#define FOR(i,n) for(int i=0;i<(int)n;i++)\n#define FORI(i,k,n) for(int i=k;i<(int)n;i++)\n#define ALL(x) (x).begin(),(x).end()\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\n\nint main()\n{\n\twhile(1)\n\t{\n\t\tint a[20][20];\n\t\tint dp[20][20]={};\n\t\tint x,y;\n\t\t\n\t\tcin>>x>>y;if(!x)break;\n\t\tFOR(i,20)FOR(j,20)a[i][j]=1;\n\t\tFORI(i,1,y+1)\n\t\t{\n\t\t\tFORI(j,1,x+1)\n\t\t\t{\n\t\t\t\tcin>>a[i][j];\n\t\t\t}\n\t\t}\n\t\tFORI(i,1,x+1)\n\t\t{\n\t\t\tdp[1][i]=1;\n\t\t\ta[y+1][i]=0;\n\t\t}\n\t\tFORI(i,1,y)\n\t\t{\n\t\t\tFORI(j,1,x+1)\n\t\t\t{\n\t\t\t\tif(a[i][j]==2&&a[i+2][j]!=1)\n\t\t\t\t{\n\t\t\t\t\tdp[i+2][j]+=dp[i][j];\n\t\t\t\t}\n\t\t\t\telse if(a[i][j]==1)\n\t\t\t\t{\n\t\t\t\t\tdp[i][j]=0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfor(int k=-1;k<=1;k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(a[i+1][j+k]==0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdp[i+1][j+k]+=dp[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(a[i+1][j]==2)dp[i+1][j]+=dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans=0;\n\t\tFORI(i,1,x+1)ans+=dp[y][i]+dp[y+1][i];\n\t\tcout<<ans<<endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n\nusing namespace std;\n\nint main(int argc, char const* argv[])\n{\n\tint x,y;\n\tint stage[17][17][2];\n\n\twhile( cin >> x >> y && x != 0 && y != 0 ){\n\t\tfor( int i = 0;i < 17;i++ ){\n\t\t\tfor( int j = 0;j < 17;j++ ){\n\t\t\t\tstage[i][j][0] = stage[i][j][1] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor( int i = 0;i < 17;i++ ) if(stage[i][1][0] != 1 ) stage[i][1][1] = 1;\n\t\t\n\t\tfor( int i = 1;i <= y;i++ ){\n\t\t\tfor( int j = 1;j <= x;j++ ){\n\t\t\t\tcin >> stage[j][i][0];\n\t\t\t}\n\t\t}\n\n\t\tfor( int j = 1;j <= y;j++ ){\n\t\t\tfor( int i = 1;i <= x;i++ ){\n\t\t\t\tif( stage[i][j][0] == 1 ) continue;\n\t\t\t\tif( stage[i][j][0] == 0 ){\n\t\t\t\t\tstage[i][j + 1][1] += stage[i][j][1];\n\t\t\t\t\t\n\t\t\t\t\tif( stage[i + 1][j + 1][0] == 0 && j != y ) stage[i + 1][j + 1][1] += stage[i][j][1];\n\t\t\t\t\tif( stage[i - 1][j + 1][0] == 0 && j != y ) stage[i - 1][j + 1][1] += stage[i][j][1];\n\n\t\t\t\t}\n\t\t\t\tif( stage[i][j][0] == 2 ){\n\t\t\t\t\tstage[i][j + 2][1] += stage[i][j][1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint count = 0;\n\t\tfor( int i = 1;i <= x;i++ ){\n\t\t\tcount += stage[i][y+1][1];\n\t\t}\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint main(int argc, char const* argv[])\n{\n\tint x,y;\n\tint stage[17][17][2];\n\n\twhile( cin >> x >> y && x != 0 && y != 0 ){\n\t\tfor( int i = 0;i < 17;i++ ){\n\t\t\tfor( int j = 0;j < 17;j++ ){\n\t\t\t\tstage[i][j][0] = stage[i][j][1] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tfor( int i = 1;i <= y;i++ ){\n\t\t\tfor( int j = 1;j <= x;j++ ){\n\t\t\t\tcin >> stage[j][i][0];\n\t\t\t}\n\t\t}\n\n\t\tfor( int i = 0;i < 17;i++ ) if(stage[i][1][0] != 1 ) stage[i][1][1] = 1;\n\n\t\tfor( int j = 1;j < y;j++ ){\n\t\t\tfor( int i = 1;i <= x;i++ ){\n\t\t\t\tif( stage[i][j][0] == 1 ) continue;\n\t\t\t\tif( stage[i][j][0] == 0 ){\n\t\t\t\t\tif( stage[i][j + 1][0] != 1 ) stage[i][j + 1][1] += stage[i][j][1];\n\t\t\t\t\t\n\t\t\t\t\tif( stage[i + 1][j + 1][0] == 0 && ( i + 1 ) <= x ) stage[i + 1][j + 1][1] += stage[i][j][1];\n\t\t\t\t\tif( stage[i - 1][j + 1][0] == 0 && ( i - 1 ) >= 1 ) stage[i - 1][j + 1][1] += stage[i][j][1];\n\n\t\t\t\t}\n\t\t\t\tif( stage[i][j][0] == 2 ){\n\t\t\t\t\tstage[i][j + 2][1] += stage[i][j][1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint count = 0;\n\t\tfor( int i = 1;i <= x;i++ ){\n\t\t\tcount += stage[i][y+1][1] + stage[i][y][1];\n\t\t}\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <list>\n#include <map>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n\nint main(){\n\twhile(true){\n\t\tint maxX,maxY;\n\t\tcin >> maxX >> maxY;\t\t\tif(!maxX&&!maxY) return 0;\n\n\t\tint tizu[maxX+2][maxY+2];\n\t\tFOR(y,0,maxY+2){\n\t\t\tFOR(x,0,maxX+2){\n\t\t\t\tif(x==0||x==maxX+1||y==0||y==maxY+1){tizu[x][y]=1;continue;};\n\t\t\t\tcin >> tizu[x][y];\n\t\t\t}\n\t\t}\n\n\t\tint dp[maxX+2][maxY+2];\n\t\tFOR(y,0,maxY+2){\n\t\t\tFOR(x,0,maxY+2){\n\t\t\t\tdp[x][y]=0;\n\t\t\t\tif(x==0||x==maxX+1){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(y==0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(y==1){\n\t\t\t\t\tif(tizu[x][y]==0) dp[x][y]+=1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(y==maxY+1){\n\t\t\t\t\tif(tizu[x][y-1]==0) dp[x][y]+=dp[x][y-1];\n\t\t\t\t\tif(tizu[x][y-1]==2) dp[x][y]+=dp[x][y-1];\n\t\t\t\t\tif(tizu[x][y-2]==2) dp[x][y]+=dp[x][y-2];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(tizu[x][y]==0){\n\t\t\t\t\tif(tizu[x-1][y-1]==0) dp[x][y]+=dp[x-1][y-1];\n\t\t\t\t\tif(tizu[x][y-1]==0)   dp[x][y]+=dp[x][y-1];\n\t\t\t\t\tif(tizu[x+1][y-1]==0) dp[x][y]+=dp[x+1][y-1];\n\t\t\t\t\tif(tizu[x][y-2]==2)   dp[x][y]+=dp[x][y-2];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(tizu[x][y]==1){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(tizu[x][y]==2){\n\t\t\t\t\tif(tizu[x][y-1]==0) dp[x][y]+=dp[x][y-1];\n\t\t\t\t\tif(tizu[x][y-2]==2) dp[x][y]+=dp[x][y-2];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tint res = 0;\n\t\tFOR(x,1,maxX+1){ res += dp[x][maxY+1];};\n\t\tcout << res << endl;\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n\n  int x,y;\n  int a[100][100];\n  int w[100][100];\n\n  while(true){\n    cin >> x >> y;\n    if(!x && !y) break;\n\n    memset(w,0,sizeof(w));\n    int ans = 0;\n\n    for(int i=0;i<y;i++){\n      for(int j=0;j<x;j++) cin >> a[i][j];\n    }\n\n    for(int i=0;i<x;i++){\n      if(a[0][i] == 0) w[0][i] = 1;\n    }\n\n    for(int i=1;i<y;i++){\n      for(int j=0;j<x;j++){\n\n\tif(a[i][j] == 1) w[i][j] += 0;\n\n\telse if(a[i][j] == 2){\n\t  w[i][j] += 0;\n\t  w[i+2][j] += w[i-1][j];\n\t}\n\n\telse if(a[i][j] == 0){\n\t  if(i-3 > 0 && (a[i-3][j+1] == 2 || a[i-3][j-1] == 2)) w[i][j] += w[i-1][j];\n\t  else if(j-1 < 0) w[i][j] += w[i-1][j] + w[i-1][j+1];\n\t  else if(j+1 == y) w[i][j] += w[i-1][j-1] + w[i-1][j];\n\t  else w[i][j] += w[i-1][j-1] + w[i-1][j] + w[i-1][j+1];\n\t}\n\n\n      }\n\n    }\n\n    for(int i=0;i<x;i++) ans += w[y-1][i] + w[y][i] + w[y+1][i];\n    cout << ans << endl;\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define N 15\nusing namespace std;\nvoid func(int,int);\nint jump(int,int);\nint X,Y,data[N][N],memo[N][N];\nint main(){\n  while(1){\n    cin >> X >> Y;\n    if(X==0&&Y==0) break;\n    for(int i=0;i<Y;i++)\n      for(int j=0;j<X;j++) cin >> data[i][j],memo[i][j]=0;\n    for(int i=0;i<X;i++)\n      if(data[0][i]==0) func(0,i);\n    int cnt=0;\n    for(int i=0;i<X;i++) cnt+=memo[0][i];\n    cout << cnt << endl;\n  }\n  return 0;\n}\nvoid func(int y,int x){\n  if(y==Y-1){\n    memo[Y-1][x]=1;\n    return ;\n  }\n  if(0<=x-1&&data[y+1][x-1]==0){\n    if(memo[y+1][x-1]==0) func(y+1,x-1);\n    memo[y][x]+=memo[y+1][x-1];\n  }\n  if(x+1<X&&data[y+1][x+1]==0){\n    if(memo[y+1][x+1]==0) func(y+1,x+1);\n    memo[y][x]+=memo[y+1][x+1];\n  }\n  if(data[y+1][x]==0){\n    if(memo[y+1][x]==0) func(y+1,x);\n    memo[y][x]+=memo[y+1][x];\n  }\n  if(data[y+1][x]==2){\n    int r=jump(y+1,x);\n    if(r==-2) memo[y][x]+=1;\n    else if(r!=-1){\n      if(memo[r][x]==0) func(r,x);\n      memo[y][x]+=memo[r][x];\n    }\n  }\n  if(memo[y][x]==0) data[y][x]=1;\n}\nint jump(int y,int x){\n  while(1){\n    y+=2;\n    //    if(y>Y-1) return -2;\n    if(y<=Y-1&&data[y][x]==1) break;\n    if(y>=Y-1) return -2;\n    if(data[y][x]==0) return y;\n  }\n  return -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string.h>\nusing namespace std;\n\nint  X,Y,dx[]={-1,0,1},dy[]={1,1,1};\nlong long ans;\nint field[15][15];\n\nvoid dfs(int x,int y){\n    if(y >= Y-1){\n        if(field[y][x]!=1){\n            ans++;\n            return;\n        }\n    }\n    if(field[y][x] == 2){\n        dfs(x,y+2);\n        return ;\n    }\n    if(field[y][x] == 1){\n        return ;\n    }\n    \n    for(int i=0;i<3;i++){\n        int nx = x+dx[i],ny = y+dy[i];\n        if(nx>=0 && nx<X && ny>=0 && ny<Y && field[ny][nx] != 1 && !(i != 1 && field[ny][nx] == 2)){\n            if(field[ny][nx] == 2)dfs(nx,ny+2);\n            else dfs(nx,ny);\n        }\n    }\n}\n\nvoid solve(){\n    for(int x=0;x<X;x++){\n        if(field[0][x] == 0)dfs(x,0);\n    }\n}\n\nint main() {\n\twhile(1){\n     memset(field,0,sizeof(field));\n     ans=0;\n     cin>>X>>Y;   \n     if(!X&&!Y)break;\n     \n     for(int i=0;i<Y;i++){\n         for(int j=0;j<X;j++){\n             cin>>field[i][j];\n         }\n     }\n     \n     solve();\n     \n     cout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main()\n{\n    while(1)\n    {\n        int x,y,ans=0;\n        int dp[17][17]={0};\n        int course[17][17]={0};\n        cin>>x>>y;if(!x)return 0;\n        for(int j=0;j<y;++j){\n            for(int i=0;i<x;++i){\n            \tcin>>course[i][j];\n            \tif(!course[i][0])dp[i][0]=1;\n            }\n        }\n        for(int j=0;j<y-1;++j){\n            for(int i=0;i<x;++i){\n                if(!course[i][j]){\n                    if(course[i][j+1]!=1)dp[i][j+1]+=dp[i][j];\n                    if(i){\n                        if(!course[i-1][j+1])dp[i-1][j+1]+=dp[i][j];\n                    }\n                    if(i<x){\n                        if(!course[i+1][j+1])dp[i+1][j+1]+=dp[i][j];\n                    }\n                }\n                if(course[i][j]==2){\n                    if(course[i][j]!=1)dp[i][j+2]+=dp[i][j];\n                }\n            }\n        }\n        for(int j=y-1;j<y+2;++j){\n            for(int i=0;i<x;++i){\n                ans+=dp[i][j];\n            }\n        }\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main()\n{\n    while(1)\n    {\n        int x,y,ans=0;\n        int dp[17][17]={0};\n        int course[15][15]={0};\n        cin>>x>>y;if(!x)return 0;\n        for(int j=0;j<y;++j){\n            for(int i=0;i<x;++i){\n            \tcin>>course[i][j];\n            \tif(!course[i][0])dp[i][0]=1;\n            }\n        }\n        for(int j=0;j<y-1;++j){\n            for(int i=0;i<x;++i){\n                if(!course[i][j]){\n                    if(course[i][j+1]!=1)dp[i][j+1]+=dp[i][j];\n                    if(i){\n                        if(!course[i-1][j+1])dp[i-1][j+1]+=dp[i][j];\n                    }\n                    if(i<x){\n                        if(!course[i+1][j+1])dp[i+1][j+1]+=dp[i][j];\n                    }\n                }\n                if(course[i][j]==2){\n                    if(course[i][j]!=1)dp[i][j+2]+=dp[i][j];\n                }\n            }\n        }\n        for(int j=y-1;j<y+2;++j){\n            for(int i=0;i<x;++i){\n                ans+=dp[i][j];\n            }\n        }\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "// 基本テンプレート\n \n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\nusing namespace std;\n \n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {1, 1, 1};\nint dy[] = {-1, 0, 1};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nint board[20][20], dp[30][30];\n \nsigned main() {\n    int W, H;\n    while(cin >> W >> H, W || H) {\n        for(int i=0; i<H; i++) {\n            for(int j=0; j<W; j++) {\n                cin >> board[i][j];\n            }\n        }\n\n        memset(dp, 0, sizeof(dp));\n        for(int i=0; i<W; i++) if(board[0][i] == 0) dp[0][i] = 1;\n\n        int ans = 0;\n        for(int i=0; i<H; i++) {\n            for(int j=0; j<W; j++) {\n                for(int k=0; k<3; k++) {\n                    if(board[i][j] == 2 and k != 1) continue;\n                    int dbl = (board[i][j] == 2 ? 2 : 1);\n\n                    int ni = i + dx[k] * dbl, nj = j + dy[k];\n                    if(ni < 0 or nj < 0 or nj >= W) continue;\n                    if(board[ni][nj] == 1) continue;\n                    if(board[ni][nj] == 2 and k != 1) continue;\n\n                    if(ni < H - 1) {\n                        dp[ni][nj] += dp[i][j];\n                    }\n                    else {\n                        ans += dp[i][j];\n                    }\n                }\n            }\n        }\n\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n\nusing namespace std;\nint main(){\n  int x, y, course[50][50], route[52][52], i, j, sum;\n  while(cin >> x >> y, x+y){\n    sum = 0;\n    for(i=0; i<52; i++){\n      for(j=0; j<52; j++){\n        route[i][j] = 0;\n      }\n    }\n    for(i=0; i<y; i++){\n      for(j=0; j<x; j++){\n\tcin >> course[i][j];\n      }\n    }\n    for(i=0; i<y; i++){\n      for(j=0; j<x; j++){\n        if(i==0){\n\t  if(course[i][j]==0){\n            route[i][j] = 1;\n          }else{\n            route[i][j] = 0;\n          }\n        }else{\n          if(j==0){\n            if(course[i][j]==0){\n              if(course[i-1][j]==0){\n\t        route[i][j] += route[i-1][j];\n              }\n              if(course[i-1][j+1]==0){\n                route[i][j] += route[i-1][j+1];\n              }\n            }else if(course[i][j]==1){\n\t      route[i][j] = 0;\n            }else{\n              if(course[i-1][j]==0){\n                route[i][j] = route[i-1][j];\n                route[i+2][j] += route[i][j];\n              }\n            }\n          }else if(j==x-1){\n            if(course[i][j]==0){\n              if(course[i-1][j]==0){\n                route[i][j] += route[i-1][j];\n              }\n              if(course[i-1][j-1]==0){\n                route[i][j] += route[i-1][j-1];\n              }\n            }else if(course[i][j]==1){\n              route[i][j] = 0;\n            }else{\n              if(course[i-1][j]==0){\n                route[i][j] = route[i-1][j];\n                route[i+2][j] += route[i][j];\n              }\n            }\n          }else{\n            if(course[i][j]==0){\n              if(course[i-1][j]==0){\n                route[i][j] += route[i-1][j];\n              }\n              if(course[i-1][j-1]==0){\n                route[i][j] += route[i-1][j-1];\n              }\n              if(course[i-1][j+1]==0){\n                route[i][j] += route[i-1][j+1];\n              }\n            }else if(course[i][j]==1){\n              route[i][j] = 0;\n            }else{\n              if(course[i-1][j]==0){\n                route[i][j] = route[i-1][j];\n                route[i+2][j] += route[i][j];\n              }\n              if(course[i-2][j]==2){\n                route[i][j] = route[i-2][j];\n                route[i+2][j] += route[i][j];\n              }\n            }\n          }\n        }\n      }\n    }\n    for(i=y-1; i<y+2; i++){\n      for(j=0; j<x; j++){\n        sum+=route[i][j];\n      }\n    }\n    cout << sum << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\nint main()\n{\n\tint map[100][100];\n\tint dp[100][100];\n\t\n\tint X, Y;\n\twhile (scanf(\"%d %d\", &X, &Y), X + Y){\n\t\tfor (int i = 0; i < 100; i++){\n\t\t\tdp[0][i] = 1;\n\t\t\tfor (int j = 1; j < 100; j++){\n\t\t\t\tdp[j][i] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < Y; i++){\n\t\t\tfor (int j = 0; j < X; j++){\n\t\t\t\tscanf(\"%d\", &map[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < Y; i++){\n\t\t\tfor (int j = 0; j < X; j++){\n\t\t\t\tif (map[i][j] == 0){\n\t\t\t\t\tfor (int k = -1; k <= 1; k++){\n\t\t\t\t\t\tif (j + k >= 0 && j + k < X && (map[i + 1][j + k] == 0 || (k == 0 && map[i + 1][j + k] == 2)) && (i < Y - 1 || k == 0)){\n\t\t\t\t\t\t\tdp[i + 1][j + k] += dp[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (map[i][j] == 2){\n\t\t\t\t\tdp[i + 2][j] += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < X; i++){\n//\t\t\tprintf(\"%d \", dp[Y][i]);\n\t\t\tsum += dp[Y][i];\n\t\t\tsum += dp[Y + 1][i];\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", sum);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<string.h>\nusing namespace std;\n\nint course[15][15];\nint pattern[16][16];\n\nint main() {\n\n  int X,Y,t,in;\n  while(cin>>X>>Y, X|Y) {\n    memset(course, 0, sizeof(course));\n    memset(pattern, 0, sizeof(pattern));\n    for(int i=0; i<Y; ++i) {\n      for(int j=0; j<X; ++j) {\n\tcin>>in;\n\tcourse[i][j] = in;\n      }\n    }\n\n    for(int i=Y-1; i>=0; --i) {\n      for(int j=X-1; j>=0; --j) {\n\tif(i==Y-1) {\n\t  if(course[i][j] == 0)\n\t    pattern[i][j] = 1;\n\t} else if(i == Y-2 && course[i][j] == 2){\n\t  pattern[i][j] = 1;\n\t} else {\n\t  if(course[i][j] == 0) {\n\t    pattern[i][j] = pattern[i+1][j];\n\t    if(j > 0 && course[i+1][j-1] == 0)\n\t      pattern[i][j] += pattern[i+1][j-1];\n\t    if(j < X && course[i+1][j+1] == 0)\n\t      pattern[i][j] += pattern[i+1][j+1];\n\t  }\n\t  if(course[i][j] == 2 && course[i+2][j] != 1) {\n\t    pattern[i][j] = pattern[i+2][j];\n\t  }\n\t}\n      }\n    }\n\n    /*\n    cout<<endl;\n    for(int i=0; i<Y; ++i) {\n      for(int j=0; j<X; ++j) {\n\tcout<<pattern[i][j]<<\" \";\n      }\n      cout<<endl;\n    }\n    cout<<endl;\n    */\n    int sum = 0;\n    for(int i=0; i<X; ++i) {\n      //cout<<pattern[0][i]<<\" \";\n      sum += pattern[0][i];\n    }\n    //cout<<endl;\n    cout<<sum<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#define int long long\nusing namespace std;\n\nsigned main() {\n\tint a, b;\n\twhile (cin >> a >> b, a | b) {\n\t\tvector<vector<int>>masu(b + 1, vector<int>(a));\n\t\tvector<vector<int>>suberikata(b + 1, vector<int>(a));\n\t\tfor (int c = 0; c < b; c++) {\n\t\t\tfor (int d = 0; d < a; d++) {\n\t\t\t\tcin >> masu[c][d];\n\t\t\t}\n\t\t}\n\t\tfor (int e = 0; e < b; e++) {\n\t\t\tif (masu[0][e] ==0)suberikata[0][e]++;\n\t\t}\n\t\tfor (int f = 0; f < b-1; f++) {\n\t\t\tfor (int g = 0; g < a; g++) {\n\t\t\t\tswitch (masu[f][g]) {\n\t\t\t\tcase 0:\n\t\t\t\t\tsuberikata[f + 1][g] += suberikata[f][g];\n\t\t\t\t\tif (g > 0&&masu[f+1][g-1]!=2)suberikata[f + 1][g - 1] += suberikata[f][g];\n\t\t\t\t\tif (g < a - 1 && masu[f + 1][g + 1] != 2)suberikata[f + 1][g + 1] += suberikata[f][g];\n\t\t\t\t\tbreak;     \n\t\t\t\tcase 2:suberikata[f + 2][g] += suberikata[f][g]; break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint s = 0;\n\t\tfor (int x = 0; x < a; x++) {\n\t\t\tif (masu[b-1][x] != 1)s += suberikata[b-1][x];\n\t\t}\n\t\tfor (int j : suberikata[b]) {\n\t\t\ts += j;\n\t\t}\n\t\tcout << s << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst int MAX_SIZE = 15;\nchar field[MAX_SIZE+1][MAX_SIZE+3];\nint dp[MAX_SIZE+1][MAX_SIZE+3];\nint w, h;\n\nbool judge(int i, int j){\n\tif(j > 0 && j <= w && field[j][i] == '0')\n\t\treturn true;\n\treturn false;\n}\n\nint main(){\n\twhile(cin >> w >> h){\n\t\tif(w == 0 && h == 0) break;\n\t\tfor(int i = 1; i <= h; i++){\n\t\t\tfor(int j = 1; j <= w; j++)\n\t\t\t\tcin >> field[j][i];\n\t\t}\n\t\tint pattern = 0;\n\t\tfor(int i = 0; i < MAX_SIZE+1; i++){\n\t\t\tfor(int j = 0; j < MAX_SIZE+3; j++){\n\t\t\t\tdp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1; i <= w; i++){\n\t\t\tdp[i][1] = 1;\n\t\t}\n\t\tfor(int i = 1; i <= h; i++){\n\t\t\tfor(int j = 1; j <= w; j++){\n\t\t\t\tif(field[j][i] == '2')\n\t\t\t\t\tdp[j][i+2] += dp[j][i];\n\t\t\t\tif(field[j][i] == '0'){\n\t\t\t\t\tdp[j][i+1] += dp[j][i];\n\t\t\t\t\tif(judge(i+1, j-1)) dp[j-1][i+1] += dp[j][i];\n\t\t\t\t\tif(judge(i+1, j+1)) dp[j+1][i+1] += dp[j][i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint count = 0;\n\t\tfor(int i = h+1; i <= h+2; i++){\n\t\t\tfor(int j = 1; j <= w; j++){\n\t\t\t\tcount += dp[j][i];\n\t\t\t}\n\t\t}\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int INF = INT_MAX/10;\n\nint dx[] = {-1, 0, 1};\n\nint main() {\n\tint X, Y;\n\twhile(cin >> X >> Y, X) {\n\t\tvvi field(Y+1, vi(X));\n\t\tREP(i, Y) {\n\t\t\tREP(j, X) {\n\t\t\t\tcin >> field[i][j];\n\t\t\t}\n\t\t}\n\n\t\tvvi dp(Y+1, vi(X, 0));\n\t\tREP(j, X) {\n\t\t\tdp[0][j] = 1;\n\t\t}\n\n\t\tREP(i, Y) {\n\t\t\tREP(j, X) {\n\t\t\t\tif(i == Y-1) {\n\t\t\t\t\tswitch(field[i][j]) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tdp[i+1][j] += dp[i][j];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tswitch(field[i][j]) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tREP(d, 3) {\n\t\t\t\t\t\t\tint ny = i+1;\n\t\t\t\t\t\t\tint nx = j+dx[d];\n\t\t\t\t\t\t\tif(0 <= nx && nx < X) {\n\t\t\t\t\t\t\t\tswitch(field[ny][nx]) {\n\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\tdp[ny][nx] += dp[i][j];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\tif(d == 1) {\n\t\t\t\t\t\t\t\t\t\tdp[ny][nx] += dp[i][j];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tint ny = min(i+2, Y);\n\t\t\t\t\t\tif(field[ny][j] != 1) {\n\t\t\t\t\t\t\tdp[ny][j] += dp[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tREP(i, X) {\n\t\t\tans += dp[Y][i];\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nint main()\n{\n\tfor(;;){\n\t\tint x, y;\n\t\tint map[100][100];\n\t\tint dp[100][100];\n\t\t\n\t\tcin >> x;\n\t\tcin >> y;\n\t\tif(x == 0 && y == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < y; i++){\n\t\t\tfor(int j = 0; j < x; j++){\n\t\t\t\tcin >> map[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\t//ツ鳴催渉可づ可暗ェツ氾板湘」ツづ個療アツづ個づつィツづィツ青板づーツ個按津ィ\n\t\t//0:ツ暗堋督ョツ嘉つ能\n\t\t//1:ツ湘。ツ害ツ閉ィ\n\t\t//2:ツジツδδδ督プツ妥、\n\t\t\n\t\tfor(int i = 0; i < x; i++){\n\t\t\tdp[0][i] = map[0][i] == 0;\n\t\t}\n\t\t\n\t\tconst int dx[] = {-1,0,1};\n\t\t\n\t\tfor(int i = 1; i < y; i++){\n\t\t\tfor(int j = 0; j < x; j++){\n\t\t\t\tif(map[i][j] == 0 || map[i][j] == 2){\n\t\t\t\t\tdp[i][j] = 0;\n\t\t\t\t\tfor(int k = 0; k < 3; k++){\n\t\t\t\t\t\tint px = j+dx[k];\n\t\t\t\t\t\tif(px < 0 || x <= px || map[i-1][px] == 2 || (map[i][j] == 2 && dx[k] != 0)){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp[i][j] += dp[i-1][px];\n\t\t\t\t\t}\n\t\t\t\t\tif(i-2 >= 0 && map[i-2][j] == 2){\n\t\t\t\t\t\tdp[i][j] += dp[i-2][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdp[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\t/*\n\t\tfor(int i = 0; i < y; i++){\n\t\t\tfor(int j = 0; j < x; j++){\n\t\t\t\tcout<<dp[i][j] << \" \" << flush;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\t\tfor(int i = 0; i < x; i++){\n\t\t\tans += dp[y-1][i];\n\t\t\tif(y-2 >= 0 && map[y-2][i] == 2){\n\t\t\t\tans+= dp[y-2][i];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n\nusing namespace std;\n\nconst int MAX = 17;\nint in[MAX][MAX], X,Y,data[MAX][MAX],ans;\nint dx[3] = {-1,0,1};\n\nvoid init(){\n  memset(data,0,sizeof(data));\n  memset(in,-1,sizeof(in));\n  ans = 0;\n}\n\n\nvoid solve(){\n  for(int i = 1; i <= Y; i++)\n    for(int j = 1; j <= X; j++){\n      for(int k = 0; k < 3; k++)\n\tif(in[i][j] == 0){\n\t  int f = j+dx[k];\n\t  if(i-1 > 0 && 0 < f && f <= X){\n\t    if(in[i-1][f] != 2) data[i][j] += data[i-1][f];\n\t  }\n\n\t}else if(in[i][j] == 2){\n\t  if(i-1 > 0) data[i][j] += data[i-1][j];\n\t  if(i+2 <= Y && in[i+2][j] != 1) data[i+2][j] += data[i][j];\n\t  break;\n\t}\n    }\n\n  for(int j = 1; j <= X; j++){\n    if(Y-1 > 0 && in[Y-1][j] == 2) ans+=data[Y-1][j];\n    ans+=data[Y][j];\n  }\n  cout << ans << endl;\n}\n\nint main(){\n  while(cin >> X >> Y && X+Y){\n    init();\n    for(int i = 1; i <= Y; i++)\n      for(int j = 1; j <= X; j++)\n\tcin >> in[i][j];\n    \n    for(int i = 1; i <= X; i++)\n      if(in[1][i] == 0) data[1][i] = 1;\n\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n  while(1){\n    int w,h,mp[20][20]={},dp[20][20] ={};\n    cin >> w >> h;\n    if(w==0 && h==0) break;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++) cin >> mp[i][j];\n    for(int i=0;i<w;i++) dp[0][i] = 1;\n    int ans=0;    \n    for(int i=0;i<h-1;i++)\n      for(int j=0;j<w;j++) \n\tfor(int k=-1;k<=1;k++){\n\t  int nx=j+k,ny=i+1;\n\t  if(nx<0||nx>=w || mp[i][j] != 0) continue;\n\t  while(k==0 && mp[ny][nx]==2) ny+=2;\n\t  if(mp[ny][nx]==0)dp[ny][nx]+= dp[i][j];\n\t  if(ny >= h-1) ans+=dp[i][j];\n\t}\n    cout << ans <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#define NORMAL 0\n#define TREE 1\n#define JUMP 2\n#define DR_NUM 3 // 方向数\n\nusing namespace std;\n\nconst int dy[DR_NUM] = {1,1,1}, dx[DR_NUM] = {-1,0,1};\n\nint main(void){\n\tint x, y, course[15][15], dp[17][15], i, j, k, l, ans;\n\twhile(1){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif(x == 0 && y == 0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(i = 0;i < y;i++){\n\t\t\tfor(j = 0;j < x;j++){\n\t\t\t\tscanf(\"%d\",&course[i][j]);\n\t\t\t}\n\t\t}\n\t\tmemset(dp,0,sizeof(dp));\n\t\tfor(i = 0;i < x;i++){\n\t\t\tif(course[0][i] != TREE)\n\t\t\t\tdp[0][i] = 1;\n\t\t}\n\t\tfor(j = 0;j < y;j++){\n\t\t\tfor(k = 0;k < x;k++){\n\t\t\t\tif(course[j + 2][k] != TREE && (course[j][k] == JUMP || j == y - 1)){\n\t\t\t\t\tdp[j + 2][k] += dp[j][k];\n\t\t\t\t}else if(course[j][k] == NORMAL){\n\t\t\t\t\tfor(l = 0;l < DR_NUM;l++){\n\t\t\t\t\t\tif(k + dx[l] >= 0 && k + dx[l] < x && course[j + dy[l]][k + dx[l]] != TREE && !(l != 1 && course[j + dy[l]][k + dx[l]] == JUMP)){\n\t\t\t\t\t\t\tdp[j + dy[l]][k + dx[l]] += dp[j][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = 0;\n\t\tfor(i = 0;i < x;i++){\n\t\t\tans += dp[y][i] + dp[y + 1][i];\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nint grid[20][20];\n\ninline bool isAtObstacle(int x, int y) {\n  return grid[y][x] == 1;\n}\n\ninline bool isAtSkiJump(int x, int y) {\n  return grid[y][x] == 2;\n}\n\nint main() {\n  int n, m;\n  \n  while(cin >> n >> m && n) {\n    for(int i=0; i<n; i++) {\n      for(int j=0; j<m; j++) {\n\tcin >> grid[i][j];\n      }\n    }\n    \n    long long dp[20][20][2] = {};\n    \n    for(int j=0; j<m; j++) {\n      if(grid[0][j]==0) { dp[0][j][0] = 1; }\n    }\n    \n    for(int i=0; i<n-1; i++) {\n      for(int j=0; j<m; j++) {\n\t\n\tif(isAtObstacle(j, i)) continue;\n\t\n\tif(isAtSkiJump(j, i)) {\n\t  // assert(dp[i][j][1]==0);\n\t  if(i+2>=n) dp[n-1][j][0] += dp[i][j][0];\n\t  else dp[i+2][j][0] += dp[i][j][0];\n\t}\n\t\n\t// from the upper left\n\tif(j-1>=0) {\n\t  if(   !isAtObstacle(j-1, i+1)\n\t     && !isAtSkiJump (j-1, i+1)\n\t     && !isAtSkiJump (j, i) ) {\n\t    dp[i+1][j-1][1] += dp[i][j][0] + dp[i][j][1];\n\t  }\n\t}\n\t\n\t// from the above\n\tif(!isAtObstacle(j, i+1) && !isAtSkiJump(j, i)) {\n\t  dp[i+1][j][0] += dp[i][j][0] + dp[i][j][1];\n\t}\n\t\n\t// from the upper right\n\tif(j+1 <m) {\n\t  if(   !isAtObstacle(j+1, i+1)\n\t     && !isAtSkiJump (j+1, i+1)\n\t     && !isAtSkiJump (j, i) ) {\n\t    dp[i+1][j+1][1] += dp[i][j][0] + dp[i][j][1];\n\t  }\n\t}\n\t\n      }\n    }\n    \n    int ans = 0;\n    for(int i=0; i<m; i++) {\n      ans += dp[n-1][i][0] + dp[n-1][i][1];\n    }\n    \n    cout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint dp[18][18];\nint kosu[18][18];\nint ans;\n\nint main(){\n  int x,y;\n  \n  while(1){\n    cin>>x>>y;\n    if(x==0 && y==0) break;\n    \n    fill(dp[0],dp[18],0);\n    fill(kosu[0],kosu[18],0);\n    ans=0;\n    \n    for(int i=0;i<y;i++){\n      for(int l=0;l<x;l++){\n        cin>>kosu[i][l];\n      }\n    }\n    for(int i=0;i<x;i++)\n      if(kosu[0][i]==0) dp[0][i]=1;\n    \n    for(int i=0;i<y;i++){\n      for(int l=0;l<x;l++){\n        \n        if(kosu[i][l]==2 && kosu[i+2][l]!=1){\n          dp[i+2][l]+=dp[i][l];\n          //dp[i][l]=0;\n        }\n        if(kosu[i][l]==0 && i < y - 1)\n          for(int z=-1;z<2;z++)\n            if(l+z >= 0 && l+z < x && (z==0 || kosu[i+1][l+z]==0)) \n            \tdp[i+1][l+z]+=dp[i][l];\n        if(kosu[i][l]==0 && i == y - 1) dp[y][l] += dp[y-1][l];\n      }\n    }\n    for(int i=y;i<y+2;i++){\n      for(int l=0;l<x;l++){\n        ans+=dp[i][l];\n      }\n    }\n    \n    /*for(int i=0;i<y+2;i++){\n\tfor(int j=0;j<x;j++) cout << dp[i][j] << ' ';\n\tcout << endl;\n    }*/\n    \n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n#include<map>\n#include<queue>\n#include<set>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define reps(i,n) for(int i=1;i<=n;i++)\n\nint main(){\n\twhile(1){\n\t\tint w,h;\n\t\tcin>>w>>h;\n\t\tif(w==0)break;\n\t\t\n\t\tint dp[22][22]={0};\n\t\tint masu[22][22]={0};\n\t\t\n\t\treps(i,h){\n\t\t\treps(j,w){\n\t\t\t\tcin>>masu[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\treps(j,w){\n\t\t\tdp[1][j]=1;\n\t\t}\n\t\t\n\t\treps(i,h-1){\n\t\t\treps(j,w){\n\t\t\t\tif(masu[i][j]==0){\n\t\t\t\t\tif(masu[i+1][j]!=1) dp[i+1][j]+=dp[i][j];\n\t\t\t\t\tif(masu[i+1][j-1]==0) dp[i+1][j-1]+=dp[i][j];\n\t\t\t\t\tif(masu[i+1][j+1]==0) dp[i+1][j+1]+=dp[i][j];\n\t\t\t\t}\n\t\t\t\tif(masu[i][j]==1){\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(masu[i][j]==2){\n\t\t\t\t\tif(masu[i+2][j]!=1)dp[i+2][j]+=dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t\trep(i,2){\n\t\t\treps(j,w){\n\t\t\t\tans += dp[h+i][j];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint main(){\n  int x,y;\n  int grid[16][15];\n  int c[16][15];\n  int dx[] = {-1,0,1};\n\n  for(;;){\n    cin >> x >> y;\n    if(!x && !y)break;\n\n    for(int i=0;i<y;i++)\n      for(int j=0;j<x;j++)cin >> grid[i][j];\n    for(int j=0;j<x;j++)grid[y][j] = 0;\n\n    for(int i=0;i<y+1;i++)\n      for(int j=0;j<x;j++)c[i][j] = 0;\n\n    for(int i=0;i<x;i++)\n      if(!grid[0][i])c[0][i] = 1;\n\n    for(int i=0;i<y-1;i++){\n      for(int j=0;j<x;j++){\n\tif(!grid[i][j]){\n\t  for(int k=0;k<3;k++){\n\t    int sx = j+dx[k];\n\t    if(sx<0 || x<=sx)continue;\n\t    if(!grid[i+1][sx] || (grid[i+1][sx]==2 && k==1))c[i+1][sx] += c[i][j];\n\t  }\n\t}\n\tif(grid[i][j] == 2){\n\t  if(grid[i+2][j]!=1)c[i+2][j] += c[i][j];\n\t}\n      }\n    }\n\n    int ans = 0;\n    for(int i=0;i<x;i++){\n      ans += c[y-1][i];\n      ans += c[y][i];\n    }\n    /*\n    for(int i=0;i<y+2;i++){\n      for(int j=0;j<x;j++)cout << c[i][j] << \" \";\n      cout << endl;\n    }\n    */\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count etc.\n#include <cstdlib>\t// require abs\n#include <cstdio>\t// require printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t// require tolower, toupper\n#include <fstream>\t// require freopen\n\nusing namespace std;\n// 0 :Ú®Â\\Å é\n// 1 :áQ¨ª é\n// 2 :Wväª é\nint field[15+1][15];\nint memo[15+1][15];\nint main()\n{\n\tconst int dir[][2] = {  { 1, -1 }, { 1, 0 }, { 1, 1 } };\n//\tcut here before submit \n//\tfreopen (\"testcase.new_plan\", \"r\", stdin );\n\tint X, Y;\n\n\twhile (cin >> X >> Y && X && Y ){\n\t\tmemset (field, 0, sizeof (field ) );\n\t\tmemset (memo, 0, sizeof (memo) );\n\n\t\tfor (int i = 0; i < Y; ++i ){\n\t\t\tfor (int j = 0; j < X; ++j ){\n\t\t\t\tcin >> field[i][j];\n\t\t\t} // end for\n\t\t} // end for\n\t\t\n\t\tfor (int j = 0; j < X; ++j ){ \n\t\t\tfield[Y][j] = 0;\n\t\t\tmemo[Y][j] = 1;\n\t\t} // end for\n\n\t\tfor (int j = 0; j < X; ++j ){\n\t\t\tif (field[Y-1][j] == 0 || field[Y-1][j] == 2 ){\n\t\t\t\tmemo[Y-1][j] = 1;\n\t\t\t} // end if\n\t\t} // end for\n\t\t\n\t\tfor (int i = Y - 2; i >= 0 ; --i ){\n\t\t\tfor (int j = 0; j < X; ++j ){\n\t\t\t\tif (field[i][j] == 1 ){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else\n\t\t\t\tif (field[i][j] == 0 ){\n\t\t\t\t\tfor (int k = 0; k < 3; ++k ){\n\t\t\t\t\t\tint ny = i + dir[k][0];\n\t\t\t\t\t\tint nx = j + dir[k][1];\n\t\t\t\t\t\tif (nx < 0 || nx >= X ){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t} // end if\n\t\t\t\t\t\tif (field[ny][nx] == 1 ){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t} // end if\n\t\t\t\t\t\tif ((k == 0 || k == 2) && field[ny][nx] == 2 ){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t} // end if\n\t\t\t\t\t\tif (field[ny][nx] == 2 && field[ny+2][nx] == 1 ){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t} // end if\n\t\t\t\t\t\tmemo[i][j] += memo[ny][nx];\n\t\t\t\t\t} // end for\n\t\t\t\t}else{ // if (field[i][j] == 2 )\n\t\t\t\t\tif (field[i+2][j] != 1 ){\n\t\t\t\t\t\tmemo[i][j] += memo[i+2][j];\n\t\t\t\t\t} // end for\n\t\t\t\t} // end if\n\t\t\t} // end for\n\t\t} // end for\n\t\t\n\t\tint res = 0;\n\t\tfor (int j = 0; j < X; ++j ){\n\t\t\tres += memo[0][j];\n\t\t} // end for\n\t\tcout << res << endl;\n\t} // end loop\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint main(){\n\tint x,y;\n\twhile(cin>>x>>y,x){\n\t\tint D[16][16],P[16][16],ans=0;\n\t\tfor(int i=0;i<256;i++)P[i/16][i%16]=0;\n\t\tfor(int i=0;i<y;i++)for(int j=0;j<x;j++)cin>>D[i][j];\n\t\tfor(int i=0;i<x;i++)if(!D[0][i])P[0][i]=1;\n\t\tfor(int i=0;i<y-1;i++){\n\t\t\tfor(int j=0;j<x;j++){\n\t\t\t\tif(!D[i][j]){\n\t\t\t\t\tP[i+1][j]+=P[i][j];\n\t\t\t\t\tif(j>0&&D[i+1][j-1]!=2)P[i+1][j-1]+=P[i][j];\n\t\t\t\t\tif(j<x-1&&D[i+1][j+1]!=2)P[i+1][j+1]+=P[i][j];\n\t\t\t\t}\n\t\t\t\tif(D[i][j]==2){\n\t\t\t\t\tif(i+2>y-1)ans+=P[i][j];\n\t\t\t\t\telse P[i+2][j]+=P[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<x;i++){\n\t\t\tif(D[y-1][i]!=1)ans+=P[y-1][i];\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint w,h;\nint mp[20][20];\nint memo[20][20];\nint ans;\nint count;\n\nint saiki(int x,int y) {\n  count++;\n  // cout << x <<\" \"<<y <<endl;\n  int dx[3] = {-1,0,1};\n  int dy[3] = {1,1,1};\n  \n  if(y >= h-1) ans++,memo[y][x]++;\n  \n  else if(mp[y][x] != 1) {\n    for(int i=0;i<3;i++) {\n      int nx = dx[i]+x;\n      int ny = dy[i]+y;\n      if(nx <0|| nx >= w || memo[ny][nx] == -1||mp[ny][nx] == 1) continue;\n      \n      if(memo[ny][nx] > 0 && mp[ny][nx] == 0) {\n\tans += memo[ny][nx];\n\tmemo[y][x] += memo[ny][nx];\n      }  \n      else if(mp[ny][nx] == 0){\n\tsaiki(nx,ny);\n\tif(memo[ny][nx] > 0) memo[y][x] += memo[ny][nx];\n      } \n      else if(nx==x && mp[ny][nx] == 2){\n\tint ty = ny;\n\twhile(mp[ty][nx] == 2) ty+=2;\n\tif(mp[ty][nx] == 0 && memo[ty][nx] == 0){\n\t  saiki(nx,ty);\n\t  if(memo[ty][nx] > 0) memo[y][x] += memo[ty][nx];\n\t}\n\telse if(mp[ty][nx] == 0 && memo[ty][nx] > 0){\n\t  memo[y][x] += memo[ty][nx];\n\t  ans+= memo[ty][nx];\n\t}\n      }\n    }\n    if(memo[y][x] == 0) memo[y][x] = -1;\n  }\n}\n\n\nint main() {\n\n  while(1) {\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n\n    for(int i=0;i<=19;i++) \n      for(int j=0;j<=19;j++){ \n\tmemo[i][j] = 0;\n\tmp[i][j] = 0;\n      }\n    \n    for(int i=0;i<h;i++) \n      for(int j=0;j<w;j++) \n\tcin >> mp[i][j];\n\n\n    ans = 0;\n    count = 0;\n    for(int i=0;i<w;i++) {\n      if(mp[0][i] !=1) saiki(i,0);\n    }\n    \n    /*\n    for(int i=0;i<h;i++) {\n    for(int j=0;j<w;j++) \n      cout << memo[i][j]<<\" \";\n    cout << endl;\n    } \n    */\n  \n    int ans2 = 0;\n    for(int i=0;i<w;i++) \n      if(memo[0][i] > 0) ans2+=memo[0][i];\n    \n    cout << ans << endl;\n    //   cout << ans2 << endl;\n    //cout << count << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#define NORMAL 0\n#define TREE 1\n#define JUMP 2\n#define DR_NUM 3 // 方向数\n\nusing namespace std;\n\nconst int dy[DR_NUM] = {1,1,1}, dx[DR_NUM] = {-1,0,1};\n\nint main(void){\n\tint x, y, course[15][15], dp[15][15], i, j, k, l, ans;\n\twhile(1){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif(x == 0 && y == 0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(i = 0;i < y;i++){\n\t\t\tfor(j = 0;j < x;j++){\n\t\t\t\tscanf(\"%d\",&course[i][j]);\n\t\t\t}\n\t\t}\n\t\tmemset(dp,0,sizeof(dp));\n\t\tfor(i = 0;i < x;i++){\n\t\t\tif(course[0][i] != TREE)\n\t\t\t\tdp[0][i] = 1;\n\t\t}\n\t\tfor(j = 0;j < y - 1;j++){\n\t\t\tfor(k = 0;k < x;k++){\n\t\t\t\tif(course[j + 2][k] != TREE && (course[j][k] == JUMP || j == y - 1)){\n\t\t\t\t\tif(j + 2 < y){\n\t\t\t\t\t\tdp[j + 2][k] += dp[j][k];\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdp[y - 1][k] += dp[j][k];\n\t\t\t\t\t}\n\t\t\t\t}else if(course[j][k] == NORMAL){\n\t\t\t\t\tfor(l = 0;l < DR_NUM;l++){\n\t\t\t\t\t\tif(k + dx[l] >= 0 && k + dx[l] < x && course[j + dy[l]][k + dx[l]] != TREE && !(l != 1 && course[j + dy[l]][k + dx[l]] == JUMP)){\n\t\t\t\t\t\t\tdp[j + dy[l]][k + dx[l]] += dp[j][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = 0;\n\t\tfor(i = 0;i < x;i++){\n\t\t\tans += dp[y - 1][i];\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define rep2(x,from,to) for(int x=(from);(x)<(to);(x)++)\n#define rep(x,to) rep2(x,0,to)\nusing namespace std;\nint main(){\n\tint x, y;\n\twhile(cin >> x >> y && (x||y) ) {\n\t\tint b[15][15] = {};\n\t\trep(i,y) {\n\t\t\trep(j,x) {\n\t\t\t\tcin >> b[i][j];\n\t\t\t}\n\t\t}\n\t\tint ret[20][20] = {};\n\t\trep(i,x) {\n\t\t\tif(b[0][i] == 0) {\n\t\t\t\tret[0][i+1] = 1;\n\t\t\t}\n\t\t}\n\t\trep2(i,1,y) {\n\t\t\trep(j,x) {\n\t\t\t\tif(b[i][j] == 0) {\n\t\t\t\t\tret[i][j+1] += ret[i-1][j] + ret[i-1][j+1] + ret[i-1][j+2];\n\t\t\t\t\trep2(k,-1,2) {\n\t\t\t\t\t\tif(b[i-1][j+k] == 2) ret[i][j+1] -= ret[i-1][j+k+1];\n\t\t\t\t\t}\n\t\t\t\t} else if(b[i][j] == 2) {\n\t\t\t\t\tif(y <= i+2 || b[i+2][j] != 1) ret[i+2][j+1] += ret[i-1][j+1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\trep2(i,y-1,y+2) {\n\t\t\trep(j,x) {\n\t\t\t\tans += ret[i][j+1];\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nint memo[20][20];\nint x, y;\n\nint calc(std::vector<std::vector<int> > &v, int x, int y){\n\n\tint res = 0;\n\tif (memo[x][y] != -1)return memo[x][y];\n\tif ((x > v.size() - 1) || (x == v.size() - 1 && v[x][y] != 1))return 1;\n\n\tif (v[x][y] == 2)res += calc(v, x + 2, y);\n\n\tif (v[x][y] == 0){\n\t\tif (v[x + 1][y] == 0 || v[x + 1][y] == 2)res += calc(v, x + 1, y);\n\n\t\tif (y < v[x].size() - 1 && v[x + 1][y + 1] == 0)res += calc(v, x + 1, y + 1);\n\n\t\tif (y > 0 && v[x + 1][y - 1] == 0)res += calc(v, x + 1, y - 1);\n\t}\n\n\treturn memo[x][y] = res;\n}\n\n\nint main(){\n\n\twhile (std::cin >> x >> y){\n\n\t\tif (x == 0 && y == 0)break;\n\n\t\tint res = 0;\n\t\tstd::vector<std::vector<int> >v(y, std::vector<int>(x));\n\n\t\tfor (int i = 0; i < 20; i++){\n\t\t\tfor (int j = 0; j < 20; j++){\n\t\t\t\tmemo[i][j] = -1;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < y; i++){\n\t\t\tfor (int j = 0; j < x; j++){\n\t\t\t\tstd::cin >> v[i][j];\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < v[0].size(); i++)res += calc(v, 0, i);\n\n\t\tstd::cout << res << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    while (1) {\n        int dp[17][17] = { 0 };\n        int field[17][17] = { 0 };\n        int h, w;\n\n        cin >> w >> h;\n        if (w == 0) {\n            break;\n        }\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                cin >> field[i][j];\n            }\n        }\n        for (int j = 0; j < w; j++) {\n            if (field[0][j] != 1) {\n                dp[0][j] = 1;\n            }\n        }\n        \n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                if (dp[i][j] > 0) {\n                    if (field[i][j] == 0) {\n                        if (i != h - 1 && j != 0 && field[i + 1][j - 1] == 0) {\n                            dp[i + 1][j - 1] += dp[i][j];\n                        }\n                        if (field[i + 1][j] != 1) {\n                            dp[i + 1][j] += dp[i][j];\n                        }\n                        if (i != h - 1 && j != w - 1 && field[i + 1][j + 1] == 0) {\n                            dp[i + 1][j + 1] += dp[i][j];\n                        }\n                    }\n                    else if (field[i][j] == 2) {\n                        if (i == h - 1) {\n                            dp[i + 1][j] += dp[i][j];\n                        }\n                        else if (field[i + 2][j] != 1){\n                            dp[i + 2][j] += dp[i][j];\n                        }\n                    }\n                }\n            }\n        }\n        \n        int ans = 0;\n        for (int j = 0; j < w; j++) {\n            ans += dp[h][j];\n        }\n        cout << ans << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nconst int MAPSIZE = 20;\n\nusing namespace std;\n\nvoid p(int (*a)[MAPSIZE], int size = MAPSIZE){\n\tfor(int i = 0; i < size; i++){\n\t\tfor(int j = 0; j < size; j++){\n\t\t\tcout << a[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nint main(){\n\tint mapdata[MAPSIZE][MAPSIZE];\n\tint route[MAPSIZE][MAPSIZE];\n\n\tint x, y;\n\twhile(true){\n\t\tcin >> x >> y;\n\t\tif(!x && !y) break;\n\n\t\tfill((int*)mapdata, (int*)(mapdata + sizeof(mapdata)/sizeof(*(mapdata))), 1);\n\n\t\tfor(int i = 1; i <= y; i++){\n\t\t\tfor(int j = 1; j <= x; j++){\n\t\t\t\tcin >> mapdata[i][j];\n\t\t\t}\n\t\t}\n\n\t\tfill((int*)route, (int*)(route + sizeof(route)/sizeof(*(route))), 0);\n\n\t\t// 下からルート数を入れていく\n\t\tfor(int i = y; i >= 0; i--){\n\t\t\tfor(int j = 1; j <= x; j++){\n\t\t\t\tswitch(mapdata[i][j]){\n\t\t\t\tcase 0: // 移動可能 => ( x-1 , y+1 )、 ( x , y+1 )、 ( x+1 , y+1 ) の経路数値合計（斜めは移動可能マスのみ加算）\n\t\t\t\t\t// 但し、i == yの時は1\n\t\t\t\t\tif(i == y){\n\t\t\t\t\t\troute[i][j] = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\troute[i][j] = route[i+1][j-1]*(!mapdata[i+1][j-1]) + route[i+1][j] + route[i+1][j+1]*(!mapdata[i+1][j+1]);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:// 障害物 => 0\n\t\t\t\t\troute[i][j] = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:// ジャンプ台=> (x,y+2) の経路数\n\t\t\t\t\t// 但し、i+1 >= y のときは1\n\t\t\t\t\tif(i+1 >= y){\n\t\t\t\t\t\troute[i][j] = 1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\troute[i][j] = route[i+2][j];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tp(route, x+3);\n\t\tint sum = 0;\n\t\tfor(int i = 1; i <= x; i++){\n\t\t\tsum += route[1][i];\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF 1001000100010001000\n#define MOD 1000000007\n#define EPS 1e-10\n#define int long long\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define Rep(i, N) for (int i = 1; i < N; i++)\n#define For(i, a, b) for (int i = (a); i < (b); i++)\n#define pb push_back\n#define eb emplece_back\n#define mp make_pair\n#define i_i pair<int, int>\n#define vi vector<int>\n#define vvi vector<vi >\n#define vb vector<bool>\n#define vvb vector<vb >\n#define vp vector< i_i >\n#define Edge pair< i_i, int>\n#define all(a) (a).begin(), (a).end()\n#define Int(x) int x; scanf(\"%lld\", &x);\n#define int2(x, y) int x, y; scanf(\"%lld %lld\", &x, &y);\n#define fir first\n#define sec second\n#define ffir first.first\n#define fsec first.second\n#define sfir second.first\n#define ssec second.second\n \n//int dxy[5] = {0, 1, 0, -1, 0};\n// assign\n \nsigned main()\n{\n    int2(b, a);\n    while (a) {\n        vvi data(a, vi(b));\n        rep(i, a) {\n            rep(j, b) {\n                cin >> data[i][j];\n            }\n        }\n        \n       // cout << \"=======\" << endl;\n        vvi dp(a+1, vi(b, 0));\n        rep(i, b) {\n            if (!data[0][i]) {\n                dp[0][i] = 1;\n            }\n        }\n        \n\n        rep(i, a-1) {\n            rep(j, b) {\n                if (!data[i][j]) {\n                    for (int k = -1; k < 2; k++) {\n                        if (data[i+1][j+k] == 2) {\n                            if (!k) {\n                                dp[i+1][j] += dp[i][j];\n                            }\n                        } else if (!data[i+1][j+k]) {\n                            dp[i+1][j+k] += dp[i][j];\n                        }\n                    }\n                } else if (data[i][j] == 2) {\n                    dp[i+2][j] += dp[i][j];\n                }\n            }\n        }\n/*\n        rep(i, a+1) {\n            rep(j, b) {\n                cout << dp[i][j] << \" \";\n            }cout << endl;\n        }*/\n\n        int ans = 0;\n        rep(i, b) {\n            if (data[a-1][i] != 1) {\n                ans += dp[a][i] + dp[a-1][i];\n            } else {\n                ans += dp[a][i];\n            }\n            /*\n            if (data[a-1][i] == 1) {\n                //cout << dp[a][i] << \" \";\n                ans += dp[a][i];\n            } else {\n                //cout << dp[a-1][i] << \" \";\n                ans += dp[a-1][i];\n            }\n            */\n        }\n        cout << ans << endl;\n        cin >> b >> a;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nconst int X=20;\nconst int Y=20;\nint main(){\n    int n,m,dp[X][Y],s[X][Y],k,ans;\n    while(true){\n        scanf(\"%d%d\",&n,&m);\n        if(n==0&&m==0)return 0;\n        ans=0;\n        for(int i=0;i<n+2;i++)for(int j=0;j<m;j++)dp[i][j]=s[i][j]=0;\n        for(int i=0;i<m;i++)dp[0][i]=1;\n        for(int i=0;i<n;i++)for(int j=0;j<m;j++){\n            scanf(\"%d\",&k);\n            if(k==0){\n                dp[i][j]+=s[i][j];\n                if(i==n-1)continue;\n                dp[i+1][j]+=dp[i][j];\n                if(j!=0)s[i+1][j-1]+=dp[i][j];\n                if(j!=n-1)s[i+1][j+1]+=dp[i][j];\n            }\n            else if(k==2){\n                s[i][j]=0;\n                if(i==n-1)continue;\n                dp[i+2][j]+=dp[i][j];\n            }\n            else dp[i][j]=s[i][j]=0;\n        }\n        for(int i=0;i<m;i++)ans+=dp[n][i]+dp[n-1][i];\n        \n        printf(\"%d\\n\",ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nint main()\n{\n\tfor(;;){\n\t\tint x, y;\n\t\tint map[100][100];\n\t\tint dp[100][100];\n\t\t\n\t\tcin >> x;\n\t\tcin >> y;\n\t\tif(x == 0 && y == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < y; i++){\n\t\t\tfor(int j = 0; j < x; j++){\n\t\t\t\tcin >> map[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\t//ツ鳴催渉可づ可暗ェツ氾板湘」ツづ個療アツづ個づつィツづィツ青板づーツ個按津ィ\n\t\t//0:ツ暗堋督ョツ嘉つ能\n\t\t//1:ツ湘。ツ害ツ閉ィ\n\t\t//2:ツジツδδδ督プツ妥、\n\t\t\n\t\tfor(int i = 0; i < x; i++){\n\t\t\tif(map[0][i] == 0){\n\t\t\t\tdp[0][i] = 1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdp[0][i] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1; i < y; i++){\n\t\t\tfor(int j = 0; j < x; j++){\n\t\t\t\t//ツ配ツ療アツ外ツアツクツセツスツづーツづ「ツづ淞づヲツつ、\n\t\t\t\tif(j == 0){\n\t\t\t\t\tif(map[i][j] == 1){\n\t\t\t\t\t\tdp[i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse if(map[i][j] == 0){\n\t\t\t\t\t\tif(map[i-1][j] == 2 ||map[i-1][j+1] == 2){\n\t\t\t\t\t\t\tif(map[i-1][j] == 2 || map[i-1][j+1] == 2){\n\t\t\t\t\t\t\t\tif(map[i-1][j] == 2){\n\t\t\t\t\t\t\t\t\tdp[i][j] = dp[i-1][j+1];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(map[i-1][j+1] == 2){\n\t\t\t\t\t\t\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(map[i-1][j] == 2 && map[i-1][j+1] == 2){\n\t\t\t\t\t\t\t\t\tdp[i][j] = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tdp[i][j] = dp[i-1][j] + dp[i-1][j+1];\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(map[i-2][j] == 2){\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tdp[i][j] += dp[i-2][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t} \n\t\t\t\t\telse if(map[i][j] == 2){\n\t\t\t\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(map[i-2][j] == 2){\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tdp[i][j] += dp[i-2][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//ツつサツづェツ暗按外\n\t\t\t\telse{\n\t\t\t\t\tif(map[i][j] == 0){\n\t\t\t\t\t\tif(map[i-1][j] == 2 || map[i-1][j-1] == 2 || map[i-1][j+1] == 2){\n\t\t\t\t\t\t\tif(map[i-1][j] == 2){\n\t\t\t\t\t\t\t\tdp[i][j] = dp[i-1][j+1] + dp[i-1][j-1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(map[i-1][j-1] == 2){\n\t\t\t\t\t\t\t\tdp[i][j] = dp[i-1][j] + dp[i-1][j+1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(map[i-1][j+1] == 2){\n\t\t\t\t\t\t\t\tdp[i][j] = dp[i-1][j] + dp[i-1][j-1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(map[i-1][j] == 2 && map[i-1][j+1] == 2){\n\t\t\t\t\t\t\t\tdp[i][j] = dp[i-1][j-1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(map[i-1][j] == 2 && map[i-1][j-1] == 2){\n\t\t\t\t\t\t\t\tdp[i][j] = dp[i-1][j+1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(map[i-1][j+1] == 2 && map[i-1][j-1] == 2){\n\t\t\t\t\t\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(map[i-1][j+1] == 2 && map[i-1][j] == 2 && map[i-1][j-1] == 2){\n\t\t\t\t\t\t\t\tdp[i][j] = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tdp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j+1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(map[i-2][j] == 2){\n\t\t\t\t\t\t\tdp[i][j] += dp[i-2][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(map[i][j] == 1){\n\t\t\t\t\t\tdp[i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse if(map[i][j] == 2){\n\t\t\t\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\t\t\t\tif(map[i-2][j] == 2){\n\t\t\t\t\t\t\tdp[i][j] += dp[i-2][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\t/*\n\t\tfor(int i = 0; i < y; i++){\n\t\t\tfor(int j = 0; j < x; j++){\n\t\t\t\tcout<<dp[i][j] << \" \" << flush;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\t\t\n\t\tfor(int i = 0; i < x; i++){\n\t\t\tans += dp[y-1][i];\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < x; i++){\n\t\t\tif(map[y-2][i] == 2){\n\t\t\t\tans+= dp[y-2][i];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,num) for(int i=0;i<(num);++i)\n#define LOOP(i) while(i--)\n#define ALL(c) c.begin(),c.end()\n#define PRINTALL(c) for(auto pitr=c.begin();pitr!=c.end();++pitr){cout<<*pitr;if(next(pitr,1)!=c.end())cout<<' ';}cout<<endl;\n#define PAIRCOMP(c,comp) [](const pair<ll,ll>& lhs,const pair<ll,ll>& rhs){return lhs.c comp rhs.c;}\n\nusing namespace std;\nusing ll = long long;\n\nconstexpr ll atcoder_mod = 1e9+7;\n\ntemplate<typename T=int>\nT in(){T x; cin >> x; return (x);}\ntemplate<typename T=int,typename C=vector<T>>\nC vecin(int N){C x(N);REP(i,N){x[i]=in<T>();}return move(x);}\n\nvoid vout(){cout << endl;}\ntemplate<typename Head,typename... Tail>\nvoid vout(Head&& h,Tail&&... t){cout << ' ' << h;vout(forward<Tail>(t)...);}\nvoid out(){cout << endl;}\ntemplate<typename Head,typename... Tail>\nvoid out(Head&& h,Tail&&... t){cout << h;vout(forward<Tail>(t)...);}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout<<fixed<<setprecision(10);\n\n\twhile(true){\n\t\tint X=in(),Y=in();\n\t\tif(!X && !Y) break;\n\t\tvector<vector<int>> V(Y,vector<int>(X)),dp(Y,vector<int>(X,0));\n\t\tREP(i,Y){\n\t\t\tREP(j,X){\n\t\t\t\tV[i][j]=in();\n\t\t\t}\n\t\t}\n\t\tREP(i,X){\n\t\t\tif(V[0][i]==0) dp[0][i]=1;\n\t\t}\n\t\tREP(i,Y-1){\n\t\t\tREP(j,X){\n\t\t\t\tif(V[i][j]==0){\n\t\t\t\t\tif(j>0 && V[i+1][j-1]==0) dp[i+1][j-1]+=dp[i][j];\n\t\t\t\t\tif(V[i+1][j]!=1) dp[i+1][j]+=dp[i][j];\n\t\t\t\t\tif(j<X-1 && V[i+1][j+1]==0) dp[i+1][j+1]+=dp[i][j];\n\t\t\t\t}\n\t\t\t\telse if(V[i][j]==2){\n\t\t\t\t\tif(i+2<Y){\n\t\t\t\t\t\tif(V[i+2][j]!=1) dp[i+2][j]+=dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t\telse dp[Y-1][j]+=dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout(accumulate(ALL(dp[Y-1]),0));\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/* {{{ Shinobu kawaii */\n/*\n  ______   __        _                  __                 \n.' ____ \\ [  |      (_)                [  |                \n| (___ \\_| | |--.   __   _ .--.   .--.  | |.--.   __   _   \n _.____`.  | .-. | [  | [ `.-. |/ .'`\\ \\| '/'`\\ \\[  | | |  \n| \\____) | | | | |  | |  | | | || \\__. ||  \\__/ | | \\_/ |, \n \\______.'[___]|__][___][___||__]'.__.'[__;.__.'  '.__.'_/ \n\n*/\n// clang-format off\n/* }}} */\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n// #define int long long\nstruct Fast {Fast(){std::cin.tie(0);ios::sync_with_stdio(false);}} fast;\n\n/* cpp template {{{ */\n\n/* short */\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define Fi first\n#define Se second\n#define ALL(v) begin(v), end(v)\n#define RALL(v) rbegin(v), rend(v)\n#define X real()\n#define Y imag()\n\n/* REPmacro */\n#define REPS(i, a, n) for (ll i = (a); i < (ll)(n); ++i)\n#define REP(i, n) REPS(i, 0, n)\n#define RREP(i, n) REPS(i, 1, n + 1)\n#define DEPS(i, a, n) for (ll i = (a); i >= (ll)(n); --i)\n#define DEP(i, n) DEPS(i, n, 0)\n\n/* debug */\n#define debug(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n';\n\n/* alias */\nusing ll = long long;\nusing ull = unsigned long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nusing pii = pair<int, int>;\nusing D = double;\nusing P = complex<D>;\nusing vs = vector<string>;\ntemplate <typename T> using PQ = priority_queue<T>;\ntemplate <typename T> using minPQ = priority_queue<T, vector<T>, greater<T>>;\n\n/* const */\nconst int INF = 1001001001;\nconst ll LINF = 1001001001001001001ll;\nconst int MOD = 1e9 + 7;\nconst D EPS = 1e-9;\nconst int dx[] = {0, 1, 0, -1, 1, -1, 1, -1}, dy[] = {1, 0, -1, 0, 1, -1, -1, 1};\n\n/* func */\ninline bool inside(int y, int x, int H, int W) {return y >= 0 && x >= 0 && y < H && x < W;}\ninline int in() {int x; cin >> x; return x;}\ninline ll IN() {ll x; cin >> x; return x;}\ninline vs split(const string& t, char c) {vs v; stringstream s(t); string b; while(getline(s, b, c)) v.eb(b); return v;}\ntemplate <typename T> inline bool chmin(T& a, const T& b) {if (a > b) a = b; return a > b;}\ntemplate <typename T> inline bool chmax(T& a, const T& b) {if (a < b) a = b; return a < b;}\ntemplate <typename T> inline void print(const T& x) {cout << x << '\\n';}\ntemplate <typename T, typename S> inline void print(const vector<pair<T, S>>& v) {for (auto&& p : v) print(p);}\ntemplate <typename T> inline void print(const vector<T>& v, string s = \" \") {REP(i, v.size()) cout << v[i] << (i != (ll)v.size() - 1 ? s : \"\\n\");}\n// clang-format on\n/* }}} */\n\nint w, h;\nint field[20][20];\n\nll dfs(int y, int x, int yy = -1, int xx = -1) {\n  if (!inside(y, x, h + 1, w)) return 0;\n  if (field[y][x] == 1) return 0;\n  if (y >= h - 1) return 1;\n  if (field[y][x] == 2 && x != xx) return 0;\n\n  ll res;\n  if (field[y][x] == 2) {\n    res = dfs(y + 2, x, y, x);\n  } else {\n    res = dfs(y + 1, x, y, x) + dfs(y + 1, x + 1, y, x) + dfs(y + 1, x - 1, y, x);\n  }\n\n  return res;\n}\n\nsigned main() {\n  while (cin >> w >> h, w || h) {\n    memset(field, -1, sizeof(field));\n    REP(i, h) REP(j, w) field[i][j] = in();\n    ll ans = 0;\n    REP(i, w) {\n      ans += dfs(0, i);\n    }\n    print(ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nstruct Skier {\n\tint naname{ 0 }, straight{ 1 }, fling{ 0 };\n\tint land() const { return naname + straight; }\n};\nclass Field {\n\tenum class State : char {\n\t\tPlane, Tree, Jump\n\t};\npublic:\n\tField(const int &ah, const int &aw) :h{ ah }, w{ aw }, map(ah, std::vector<State>(aw)) {\n\t\tint a;\n\t\tfor (auto &line : map) {\n\t\t\tfor (auto &cell : line) {\n\t\t\t\tstd::cin >> a;\n\t\t\t\tswitch (a) {\n\t\t\t\tcase 0: cell = State::Plane; break;\n\t\t\t\tcase 1: cell = State::Tree; break;\n\t\t\t\tcase 2: cell = State::Jump; break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint cul_route() const;\nprivate:\n\tstd::vector<std::vector<State>> map;\n\tint h, w;\n};\nint Field::cul_route() const {\n\tstd::vector<std::vector<Skier>> temp_route(h, std::vector<Skier>(w + 2));\n\tfor (auto y = 0; y < temp_route.size() - 1; ++y) {\n\t\tfor (auto x = 1; x <= w; ++x) {\n\t\t\tswitch(map[y][x - 1]) {\n\t\t\tcase State::Plane:\n\t\t\t\ttemp_route[y + 1][x - 1].naname += temp_route[y][x].land();\n\t\t\t\ttemp_route[y + 1][x + 1].naname += temp_route[y][x].land();\n\t\t\t\ttemp_route[y + 1][x].straight = temp_route[y][x].land() + temp_route[y][x].fling;\n\t\t\t\tbreak;\n\t\t\tcase State::Jump:\n\t\t\t\ttemp_route[y + 1][x].fling = temp_route[y][x].straight;\n\t\t\tcase State::Tree:\n\t\t\t\ttemp_route[y + 1][x].straight = temp_route[y][x].fling;\n\t\t\t}\n\t\t}\n\t}\n\tint sum = 0;\n\tfor (auto x = 1; x <= w; ++x) {\n\t\tswitch (map[h - 1][x - 1]) {\n\t\tcase State::Plane:\n\t\t\tsum += temp_route[h - 1][x].naname;\n\t\tcase State::Jump:\n\t\t\tsum += temp_route[h - 1][x].straight;\n\t\tcase  State::Tree:\n\t\t\tsum += temp_route[h - 1][x].fling;\n\t\t}\n\t}\n\treturn sum;\n}\nint main() {\n\tint h, w;\n\twhile (std::cin >> h >> w && h != 0 && w != 0) {\n\t\tField field(h, w);\n\t\tstd::cout << field.cul_route() << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n\nusing namespace std;\n\nint X, Y;\nint status[17][18];\t//status[x][y]\nint memo[17][18];\nint i, j;\nint count;\n\nint check(int x, int y);\n\nint main(){\n\n\twhile(1){\n\n\t\tcount = 0;\n\n\t\tcin >> X >> Y;\n\n\t\tif(X == 0 && Y == 0){break;}\n\n\t\telse{\n\n\t\t\t//フィールドの入力\n\t\t\t//i行目について( 1 <= i <= Y+2 )\n\t\t\tfor(i = 1; i <= Y+2; i++){\n\t\t\t\t//j文字目について( 0 <= j <= X+1)\n\t\t\t\tfor(j = 0; j <= X+1; j++){\n\n\t\t\t\t\t//Y+1, Y+2列目に移動できるようにする。\n\t\t\t\t\tif(i > Y){\n\t\t\t\t\t\tstatus[j][i] = 0;\n\t\t\t\t\t}\n\t\t\t\t\t//両サイドには障害物を敷き詰める。\n\t\t\t\t\telse if(j == 0 || j == X+1){\n\t\t\t\t\t\tstatus[j][i] = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tcin >> status[j][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n/*//フィールド出力\n\t\t\tfor(i = 1; i <= Y+2; i++){\n\t\t\t\tfor(j = 0; j <= X+1; j++){\n\t\t\t\t\tcout << status[j][i];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n*/\n\n\t\t\tfor(i = 1; i <= X; i++){\n\t\t\t\tmemset(memo, 0, sizeof(memo));\n\t\t\t\tcount += check(i, 1);\n\t\t\t}\n\n\t\t\tcout << count << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\nint  check(int x, int y){\n\n//\tcout << \"x:\" << x << \"y:\" << y << \" : \"<< status[x][y] << endl;\n\n\t//関数のメモが残っているならメモを返す\n\tif(memo[x][y] > 0){return memo[x][y];}\n\n\t//status[x][y]の次でゴール\n\tif(status[x][y] == 1){return 0;}\n\tif(status[x][y] == 0 && y == Y){return 1;}\n\tif(status[x][y] == 2 && (y == Y-1 || y == Y)){return 1;}\n\n\t//それ以外\n\telse{\n\t\t//ジャンプ台\n\t\tif(status[x][y] == 2){\n\t\t\tmemo[x][y] += check(x, y+2);\n\t\t}\n\t\t//平地\n\t\telse{\n\t\t\tif(status[x-1][y+1] == 0){\n\t\t\t\tmemo[x][y] += check(x-1, y+1);\n\t\t\t}\n\t\t\tif(status[x][y+1] == 0 || status[x][y+1] == 2){\n\t\t\t\tmemo[x][y] += check(x, y+1);\n\t\t\t}\n\t\t\tif(status[x+1][y+1] == 0){\n\t\t\t\tmemo[x][y] += check(x+1, y+1);\n\t\t\t}\n\t\t}\n\n\t\treturn memo[x][y];\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <math.h>\n#include <utility>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\n\nint main(){\n\twhile(true) {\n\t\tint x;\n\t\tint y;\n\t\tcin >> x >> y;\n\t\tif ( x == 0 ) break;\n\t\tint a[15][15] = {0};\n\t\tfor ( int i = 0; i < y ; i++ ) {\n\t\t\tfor ( int j = 0; j < x ; j++ ) {\n\t\t\t\tcin >> a[j][i];\n\t\t\t}\n\t\t}\n\t\tint b[15][15] = {0};\n\t\tfor ( int j = 0; j < x ; j++ ) {\n\t\t\tb[j][y-1] = 1;\n\t\t}\n\t\tif ( y > 1 ) {\n\t\t\tfor ( int j = 0; j < x ; j++ ) {\n\t\t\t\tif ( a[j][y-2] == 2) b[j][y-2] = 1;\n\t\t\t}\n\t\t}\n\t\tfor ( int i = y - 1; i > 0; i-- ) {\n\t\t\tfor ( int j = 0; j < x ; j++ ) {\n\t\t\t\tif ( a[j][i] == 0 ) {\n\t\t\t\t\tfor ( int k = j - 1; k < j + 2; k++ ) {\n\t\t\t\t\t\tif ( k < 0 || k >= x ) continue;\n\t\t\t\t\t\tif ( a[k][i-1] == 0 ) {\n\t\t\t\t\t\t\tb[k][i-1] += b[j][i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( i > 1 ) {\n\t\t\t\t\t\tif ( a[j][i-2] == 2 ) b[j][i-2] += b[j][i];\n\t\t\t\t\t}\n\t\t\t\t}else if ( a[j][i] == 2 ) {\n\t\t\t\t\tif ( a[j][i-1] == 0 ) b[j][i-1] += b[j][i];\n\t\t\t\t\tif ( i > 1 ) {\n\t\t\t\t\t\tif ( a[j][i-2] == 2 ) b[j][i-2] += b[j][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint s = 0;\n\t\tfor ( int j = 0; j < x ; j++ ) {\n\t\t\ts += b[j][0];\n\t\t}\n\t\tcout << s << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n  while(1){\n    int w,h,mp[20][20]={},dp[20][20] ={};\n    cin >> w >> h;\n    if(w==0 && h==0) break;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++) cin >> mp[i][j];\n    for(int i=0;i<w;i++) if(mp[0][i]==0) dp[0][i] = 1;\n\n    int ans=0;    \n    for(int i=0;i<h-1;i++)\n      for(int j=0;j<w;j++) \n\tfor(int k=-1;k<=1;k++){\n\t  if(mp[i][j] !=0) break;\n\t  int nx=j+k,ny=i+1;\n\t  if(nx<0||nx>=w) continue;\n\t  while(k==0&&mp[ny][nx]==2) ny+=2;\n\t  if(mp[ny][nx]!=0) continue;\n\t  if(dp[i][j]>0)dp[ny][nx]+= dp[i][j];\n\t  if(i >= h-1) ans+=dp[i][j];\n\t}\n    cout << ans <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nenum class State {\n\tEmpty, Tree, Jump\n};\nclass Ski_run {\npublic:\n\tSki_run(const int &x, const int &y) :width(x), height(y), state(y, std::vector<State>(x, State::Empty)), route(y + 1, std::vector<long long int>(x, 0)), null(0), res(-1) {\n\t\tfor (auto &line : state) {\n\t\t\tfor (auto &c : line) {\n\t\t\t\tint a;\n\t\t\t\tstd::cin >> a;\n\t\t\t\tc = static_cast<State>(a);\n\t\t\t}\n\t\t}\n\t\tstate.push_back(std::vector<State>(width, State::Empty));\n\t\tstate.push_back(std::vector<State>(width, State::Empty));\n\t\troute.at(height) = std::vector<long long int>(x, 1);\n\t\troute.at(height - 1) = std::vector<long long int>(x, 1);\n\t}\n\tvoid show() const {\n\t\tfor (const auto &l : route) {\n\t\t\tfor (const auto &c : l) {\n\t\t\t\tstd::cout << c;\n\t\t\t}\n\t\t\tstd::cout << '\\n';\n\t\t}\n\t}\n\tlong long int solve() {\n\t\tif (res >= 0) {\n\t\t\treturn res;\n\t\t}\n\t\telse {\n\t\t\tfor (auto y = height - 2; y >= 0; --y) {\n\t\t\t\tfor (auto x = 0; x < width; ++x) {\n\t\t\t\t\tswitch (state.at(y).at(x)) {\n\t\t\t\t\tcase State::Empty:\n\t\t\t\t\t\tif (at(x - 1, y + 1) == State::Empty) {\n\t\t\t\t\t\t\troute.at(y).at(x) += route.at(y + 1).at(x - 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (at(x + 1, y + 1) == State::Empty) {\n\t\t\t\t\t\t\troute.at(y).at(x) += route.at(y + 1).at(x + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!(at(x, y + 1) == State::Tree)) { \n\t\t\t\t\t\t\troute.at(y).at(x) += route.at(y + 1).at(x);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase State::Jump:\n\t\t\t\t\t\tif (!(at(x, y + 2) == State::Tree)) {\n\t\t\t\t\t\t\troute.at(y).at(x) += route.at(y + 2).at(x);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = 0;\n\t\t\tfor (const auto &l : route.at(0)) {\n\t\t\t\tres += l;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t}\nprivate:\n\tState at(const int &x, const int &y) {\n\t\tif (x >= 0 && width > x) {\n\t\t\treturn state.at(y).at(x);\n\t\t}\n\t\telse {\n\t\t\treturn State::Tree;\n\t\t}\n\t}\n\tint width, height;\n\tstd::vector<std::vector<long long int>> route;\n\tstd::vector<std::vector<State>> state;\n\tint null, res;\n};\nint main() {\n\tint x, y;\n\tstd::cin >> x >> y;\n\twhile (x != 0 || y != 0) {\n\t\tSki_run state(x, y);\n\t\tstd::cout << state.solve() << std::endl;\n\t\tstd::cin >> x >> y;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<complex>\n#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<functional>\n#include<utility>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<map>\n \nusing namespace std;\nconst int dx[] = {1,0,-1,0},dy[] = {0,1,0,-1};\n#define INF 1e+9\n#define EPS 1e-9\n#define rep(i,j) for(int i = 0; i < (j); i++)\n#define reps(i,j,k) for(int i = j; i < (k); i++)\ntypedef long long ll;\nint main(){\n    int w,h;\n    while(scanf(\"%d%d\",&w,&h),w|h){\n        int stage[32][32]={{0}};\n        int    dp[32][32]={{0}};\n        rep(i,h)rep(j,w)scanf(\"%d\",&stage[i+1][j+1]);\n\n        reps(i,1,w+1)if(stage[1][i] == 0)dp[1][i] = 1;\n\n        reps(i,2,h+1){\n            reps(j,1,w+1){\n                if(stage[i][j] == 2){\n                    dp[i+2][j] += dp[i-1][j] + dp[i][j];\n                    dp[i][j] = 0;\n                }\n                else if(stage[i][j] == 1){\n                    dp[i][j] = 0;\n                }\n                else if(stage[i][j] == 0){\n                    dp[i][j] += dp[i-1][j-1] + dp[i-1][j] + dp[i-1][j+1];\n                }\n            }\n        }\n\n        int ans = 0;\n        rep(i,w+1){\n            ans += dp[h][i] + dp[h+1][i] + dp[h+2][i];\n        }\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<30;\n\nint main() {\n  \n  int X, Y;\n  int const dx[] = {0,-1,1};\n  \n  while(cin >> X >> Y, X||Y) {\n    int ba[X][Y];\n    REP(y,Y) {\n      REP(x,X) {\n        cin >> ba[x][y];\n      }\n    }\n    int dp[X][Y];\n    memset(dp,0,sizeof(dp));\n    REP(i,X)\n      if (ba[i][0] == 0)\n        dp[i][0] = 1;\n    REP(y, Y-1) {\n      REP(x,X) {\n        if (ba[x][y] == 0) {\n          REP(i,3) {\n            int xx = x + dx[i];\n            int yy = y + 1;\n            if (xx < 0 || X <= xx) continue;\n            \n            if (ba[xx][yy] == 0 || ba[xx][yy] == 2 && i == 0) {\n              dp[xx][yy] += dp[x][y];\n            }\n          }\n        } else if (ba[x][y] == 2) {\n          if (y+2 < Y && ba[x][y+2] != 1)\n            dp[x][y+2] = dp[x][y];\n        }\n      }\n    }\n    // REP(y,Y) {\n    //   REP(x,X) {\n    //     cout << dp[x][y] << \" \";\n    //   }\n    //   cout << endl;\n    // }\n  \n    int ans = 0;\n    REP(x,X) {\n      ans += dp[x][Y-1];\n      if (ba[x][Y-2] == 2)\n        ans += dp[x][Y-2];\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <bitset>\n#include <set>\n#include <map>\n#include <stack>\n#include <list>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define SORT(c) sort((c).begin(),(c).end())\n#define DESCSORT(c) sort(c.begin(), c.end(), greater<int>())\n\nconst float PI = 3.1415926;\nstatic const int INFTY = (1<<30);\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\nint X, Y, c[16][16], mem[20][20];\n\n// tate 1, migi 2, hidari 3\nint solve(int x, int y, int tate) {\n  if(x < 0 || x >= X) return 0;\n  if(y >= Y) {\n    if(tate == 1)\n      return 1;\n    else\n      return 0;\n  }\n  if(c[y][x] == 1) return 0;\n  if(tate == 1 && c[y][x] == 2) {\n    return solve(x, y+2, 1);\n  }\n  if(c[y][x] == 2) return 0;\n  if(mem[y][x] != -1) return mem[y][x];\n  int tmp = solve(x-1, y+1, 2) + solve(x+1, y+1, 3) + solve(x, y+1, 1);\n  mem[y][x] = tmp;\n  return tmp;\n}\n  \n\nint main() {\n  while(cin >> X >> Y, X) {\n    int res = 0;\n    \n    rep(i, Y) {\n      rep(j, X) {\n        cin >> c[i][j];\n        mem[i][j] = -1;\n      }\n    }\n    \n    rep(i, X) {\n      res += solve(i, 0, 1);\n    }\n    \n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\n  int x, y;\n  while( cin >> x >> y, x+y ) {\n    int field[16][16];\n    int dp[16][16]={{0}};\n    for(int i=0; i<y; i++) {\n      for(int j=0; j<x; j++) {\n\tcin >> field[i][j];\n      }\n    }\n\n    for(int i=0; i<x; i++) {\n      if( field[0][i] != 1 ) dp[0][i] = 1;\n    }\n\n\n    for(int i=0; i<y-1; i++) {\n      for(int j=0; j<x; j++) {\n\tif( field[i][j] == 1 ) continue;\n\n\telse if( field[i][j] == 2 ) {\n\t  if( field[i+2][j] != 1 ) {\n\t    dp[min(y-1, i+2)][j] += dp[i][j];\n\t  }\n\t}\n\n\telse {\n\t  if( j ) {\n\t    if( field[i+1][j-1] == 0 ) dp[i+1][j-1] += dp[i][j];\n\t  }\n\t  if( j < x-1 ) {\n\t    if( field[i+1][j+1] == 0 ) dp[i+1][j+1] += dp[i][j];\n\t  }\n\t  if( field[i+1][j] != 1 ) dp[i+1][j] += dp[i][j];\n\t}\n      }\n    }\n\n    int sum = 0;\n    for(int i=0; i<x; i++) {\n      sum += dp[y-1][i];\n    }\n\n    cout << sum << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 10000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,string> P;\n\nstatic const double eps = 1e-8;\n\nconst int moveTo[][2] = {{-1,1},{0,1},{1,1}};\n\nint stage[17][17];\nint dp[17][17];\n\nint main(){\n\tint w,h;\n\twhile(~scanf(\"%d %d\",&w,&h)){\n\t\tif(w==h && h==0) break;\n\t\tmemset(stage,-1,sizeof(stage));\n\t\tmemset(dp,0,sizeof(dp));\n\t\tfor(int y=0;y<h;y++){\n\t\t\tfor(int x=0;x<w;x++){\n\t\t\t\tscanf(\"%d\",&stage[y][x]);\n\t\t\t}\n\t\t}\n\n\t\t//space:0 tree:1 jump:2\n\t\tfor(int x=0;x<w;x++){\n\t\t\tif(stage[0][x]!=1) dp[0][x] = 1;\n\t\t}\n\n\t\tfor(int dy=1;dy<=h;dy++){\n\t\t\tfor(int dx=0;dx<w;dx++){\n\t\t\t\tif(stage[dy][dx] != 1){\t\t\t\n\t\t\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\t\t\tint sx = dx - moveTo[j][0];\n\t\t\t\t\t\tint sy = dy - moveTo[j][1];\n\t\t\t\t\t\tif(sx < 0 || sx >= w || sy < 0 || sy >= h-1) continue;\n\n\t\t\t\t\t\t//space:0 tree:1 jump:2\n\t\t\t\t\t\tif(stage[sy][sx]!=0) continue;\n\t\t\t\t\t\tif(stage[dy][dx]==2 && dx != sx) continue;\n\n\t\t\t\t\t\tdp[dy][dx] += dp[sy][sx];\n\t\t\t\t\t}\n\n\t\t\t\t\tint sx = dx;\n\t\t\t\t\tint sy = dy-2;\n\t\t\t\t\tif(sx >=0 && sx < w && sy >= 0 && sy < h-1){\n\t\t\t\t\t\t//space:0 tree:1 jump:2\n\t\t\t\t\t\tif(stage[sy][sx] == 2){\n\t\t\t\t\t\t\tdp[dy][dx] += dp[sy][sx];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint res=0;\n\t\tfor(int y=h-1;y<=h;y++){\n\t\t\tfor(int x=0;x<w;x++){\n\t\t\t\tres += dp[y][x];\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",res);\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<30;\n\nint main() {\n  \n  int X, Y;\n  int const dx[] = {0,-1,1};\n  \n  while(cin >> X >> Y, X||Y) {\n    int ba[15][17] = {0};\n    REP(y,Y) {\n      REP(x,X) {\n        cin >> ba[x][y];\n      }\n    }\n    int dp[X][Y+2];\n    memset(dp,0,sizeof(dp));\n    REP(i,X) dp[i][0] = 1;\n    for(int y=1; y<Y+2; ++y) {\n      REP(x,X) {\n        if (ba[x][y] == 0) {\n          REP(i,((y<Y)?3:1)) {\n            int xx = x + dx[i];\n            int yy = y - 1;\n    \n            if (xx < 0 || X <= xx) continue;\n            if (i == 0) {\n              while (yy > 0 && ba[xx][yy-1] == 2) {\n                yy-=2;\n              }\n              if (ba[xx][yy] == 0)\n                dp[x][y] = dp[xx][yy]; \n            } else if (ba[xx][yy] == 0) {\n              dp[x][y] += dp[xx][yy];\n            }\n          }\n        }\n      }\n    }\n    int ans = 0;\n    REP(x,X)\n      ans += dp[x][Y+1];\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n\nint map[15][15],table[15][15],X,Y;\n\nint main(){\nwhile(1){\n\nscanf(\"%d%d\",&X,&Y);\nif(X==0&&Y==0) return 0;\nmemset(map,-1,sizeof(map));\nmemset(table,0,sizeof(table));\nfor(int i=0;i<Y;i++){\nfor(int j=0;j<X;j++){\nscanf(\"%d\",&map[i][j]);\nif(i==0&&map[i][j]==0) table[i][j]=1;\nelse if(i!=0&&map[i][j]==0){\nif(j>0&&map[i-1][j-1]==0) table[i][j]+=table[i-1][j-1];\nif(j<X-1&&map[i-1][j+1]==0) table[i][j]+=table[i-1][j+1];\nif(map[i-1][j]==0)table[i][j]+=table[i-1][j];\nif(i>2&&map[i-2][j]==2) table[i][j]+=table[i-2][j]; \n} \n}\nint sum=0;\nfor(int i=0;i<X;i++){\nsum+=map[Y-1][i];\n}\nprintf(\"%d\\n\",sum);\n\n}\n\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define N 15\nusing namespace std;\nvoid func(int,int);\nint jump(int,int);\nint X,Y,data[N][N],memo[N][N];\nint main(){\n  while(1){\n    cin >> X >> Y;\n    if(X==0&&Y==0) break;\n    for(int i=0;i<Y;i++)\n      for(int j=0;j<X;j++) cin >> data[i][j],memo[i][j]=0;\n    for(int i=0;i<X;i++)\n      if(data[0][i]==0) func(0,i);\n    int cnt=0;\n    for(int i=0;i<X;i++) cnt+=memo[0][i];\n    cout << cnt << endl;\n  }\n  return 0;\n}\nvoid func(int y,int x){\n  if(y==Y-1){\n    memo[Y-1][x]=1;\n    return ;\n  }\n  if(0<=x-1&&data[y+1][x-1]==0){\n    if(memo[y+1][x-1]==0) func(y+1,x-1);\n    memo[y][x]+=memo[y+1][x-1];\n  }\n  if(x+1<X&&data[y+1][x+1]==0){\n    if(memo[y+1][x+1]==0) func(y+1,x+1);\n    memo[y][x]+=memo[y+1][x+1];\n  }\n  if(data[y+1][x]==0){\n    if(memo[y+1][x]==0) func(y+1,x);\n    memo[y][x]+=memo[y+1][x];\n  }\n  if(data[y+1][x]==2){\n    int r=jump(y+1,x);\n    if(r==-2) memo[y][x]+=1;\n    else if(r!=-1){\n      if(memo[r][x]==0) func(r,x);\n      memo[y][x]+=memo[r][x];\n    }\n  }\n  //  if(memo[y][x]==0) data[y][x]=1;\n}\nint jump(int y,int x){\n  while(1){\n    y+=2;\n    if(data[y][x]==1) break;\n    if(y>=Y-1) return -2;\n    if(data[y][x]==0) return y;\n  }\n  return -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nint field[20][20];\nlong long dp[20][20];\n\nint main()\n{\n  int c1, c2;\n  while (scanf(\" %d %d \", &c1, &c2) == 2) {\n    if (c1 == 0 && c2 == 0) {break;}\n    for (int i = 0; i < 20; i++) {\n      fill(field[i], &field[i][20], -1);\n      fill(dp[i], &dp[i][20], 0);\n    }\n    for (int i = 1; i <= c1; i++) {\n      for (int j = 1; j <= c2; j++) {\n\tscanf(\" %d \", &field[i][j]);\n      }\n    }\n    /*for (int i = 0; i < 20; i++) {\n      for (int j = 0; j < 20; j++) {\n\tprintf(\"%d\", field[i][j]);\n      }\n      printf(\"\\n\");\n      }*/\n    \n    for (int i = 1; i <= c2; i++) {\n      dp[1][i] = 1;\n    }\n    for (int i = 1; i < c1; i++) {\n      for (int j = 1; j <= c2; j++) {\n\tif (field[i][j] == 0) {\n\t  if (field[i + 1][j - 1] != 2) {dp[i + 1][j - 1] += dp[i][j];}\n\t  dp[i + 1][j] += dp[i][j];\n\t  if (field[i + 1][j + 1] != 2) {dp[i + 1][j + 1] += dp[i][j];}\n\t} else if (field[i][j] == 2) {\n\t  dp[i + 2][j] += dp[i][j];\n\t} \n      }\n    }\n    long long sum = 0;\n    for (int i = 0; i <= 1; i++) {\n      for (int j = 1; j <= c2; j++) {\n\tif (field[c1 + i][j] != 1) {sum += dp[c1 + i][j];}\n      }\n    }\n    /*for (int i = 1; i <= c1; i++) {\n      for (int j = 1; j <= c2; j++) {\n\tprintf(\"%d\", dp[i][j]);\n      }\n      printf(\"\\n\");\n      }*/\n    \n    printf(\"%d\\n\", sum);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint field[16][15];\nint dp[16][15];\n\nint n, m;\n\nbool isIn(int x, int y){\n    return 0 <= x && x < n && 0 <= y && y < m;\n}\n\nint main(){\n    while(cin >> n >> m, n+m){\n        for(int i=0; i < n; i++) for(int j=0; j< m; j++)cin >> field[i][j];\n        for(int i=0; i < 16; i++) for(int j=0; j < 15; j++) dp[i][j] = 0;\n        for(int i=0; i < m; i++) dp[0][i] = 1;\n        for(int i=0; i < n; i++){\n            for(int j=0; j < m; j++){\n                if(field[i][j] == 0){\n                    for(int k=-1; k <= 1; k++){\n                        if(isIn(i+1, j+k) && !(k != 0 && field[i+1][j+k] == 2)){\n                            dp[i+1][j+k] += dp[i][j];\n                        }\n                    }\n                }\n                else if(field[i][j] == 1) dp[i][j] = 0;\n                else if(field[i][j] == 2){\n                    if(isIn(i+1, j))dp[i+2][j] += dp[i][j];\n                    else dp[i+1][j] += dp[i][j];\n                }\n            }\n        }\n        for(int i=0; i< m; i++) if(field[n-1][i] != 1) dp[n][i] += dp[n-1][i];\n        int count = 0;\n        for(int i=0; i< m; i++) count += dp[n][i];\n        cout << count << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nconst int MAX_Y = 15;\nconst int MAX_X = 15;\nint mx, my, c[MAX_Y][MAX_X], dp[MAX_Y][MAX_X];\n\nconst int dx[3] = {-1, 0, 1};\nconst int dy[3] = {1, 1, 1};\n\nint dfs(int y, int x) {  \n  int res = 0;\n  if (dp[y][x] >= 0) return dp[y][x];\n  \n  if (y >= my - 1) res = 1;\n  \n  if (c[y][x] == 2) {\n    if (y + 2 >= my - 1) {\n      res = 1;\n    } else {\n      if (c[y+2][x] != 1) res += dfs(y+2, x);\n    }\n  }\n  \n  if (res != 0) return dp[y][x] = res;\n  \n  rep(z,3) {\n    int tx = x + dx[z], ty = y + dy[z];\n    if (tx < 0 || ty < 0 || tx >= mx || ty >= my) continue;\n    if (c[ty][tx] == 1) continue;\n    if (c[ty][tx] == 2 && tx != x) continue;\n    res += dfs(ty, tx);\n  }\n\n  return dp[y][x] = res;\n}\n\nvoid solve() {\n  memset(dp, -1, sizeof dp);\n  rep(i,my) rep(j,mx) cin>>c[i][j];\n\n  int res = 0;\n  rep(i,mx) {\n    if (c[0][i] == 1) continue;\n    res += dfs(0, i);\n  }\n  cout<<res<<endl;\n}\n\nint main (int argc, char const* argv[]) {\n  while (cin>>mx>>my, mx||my) {\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<numeric>\nusing namespace std;\n\nint main() {\n\tint x, y;\n\twhile (cin >> x >> y, x, y) {\n\t\tvector<vector<int>> course(y + 2, vector<int>(x + 2, 0));\n\t\tfor (int i = 1; i <= y; i++) {\n\t\t\tfor (int j = 1; j <= x; j++) {\n\t\t\t\tcin >> course[i][j];\n\t\t\t}\n\t\t}\n\n\t\tvector<vector<int>> path(y + 2, vector<int>(x + 2, 0));\n\t\t//?????????????????????????????????1????????????\n\t\tfor (int i = 1; i <= x; i++) {\n\t\t\tif (course[1][i] != 1) path[1][i] = 1;\n\t\t}\n\n\t\tfor (int i = 1; i <= y; i++) {\n\t\t\tfor (int j = 1; j <= x; j++) {\n\t\t\t\t//????????????????????´????????????????????´??????????????????????????????????????????\n\t\t\t\t//?????????????§????????????????????????´?????????????????????????????£????????°?????´????????????????????????\n\t\t\t\tif (course[i][j] == 0) {\n\t\t\t\t\tif (course[i + 1][j + 1] == 0) path[i + 1][j + 1] += path[i][j];\n\t\t\t\t\tif (course[i + 1][j] != 1) path[i + 1][j] += path[i][j];\n\t\t\t\t\tif (course[i + 1][j - 1] == 0) path[i + 1][j - 1] += path[i][j];\n\t\t\t\t}\n\t\t\t\t//?¬???????????????´???????????£????????°????????????????????????????????????\n\t\t\t\t//?????????????????£????????§??´??????????????´???????????????(?????£?????????????????????????????´???????????????)\n\t\t\t\tif (course[i][j] == 2 && course[i + 2][j] != 1) {\n\t\t\t\t\tpath[i + 2][j] += path[i][j];\n\t\t\t\t\tif (i + 2 > y && i != y) path[y][j] += path[i][j];\n\t\t\t\t}\n\t\t\t\t//???????????´???????????????????????????????????????\n\t\t\t\tif (course[i][j] == 1) {/*do anything*/ }\n\t\t\t}\n\t\t}\n\n\t\tcout << accumulate(path[y].begin() + 1, path[y].end() - 1, 0) << endl;\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n\nint map[15][15],table[15][15],X,Y;\n\nint main(){\nwhile(1){\n\nscanf(\"%d%d\",&X,&Y);\nif(X==0&&Y==0) return 0;\nmemset(map,-1,sizeof(map));\nmemset(table,0,sizeof(table));\nfor(int i=0;i<Y;i++){\nfor(int j=0;j<X;j++){\nscanf(\"%d\",&map[i][j]);\nif(i==0&&map[i][j]==0) table[i][j]=1;\nelse if(i!=0&&map[i][j]!=1){\nif(j>0&&map[i-1][j-1]==0) table[i][j]+=table[i-1][j-1];\nif(j<X-1&&map[i-1][j+1]==0) table[i][j]+=table[i-1][j+1];\nif(map[i-1][j]==0)table[i][j]+=table[i-1][j];\nif(i>2&&map[i-2][j]==2) table[i][j]+=table[i-2][j]; \n} \n}\n}\nint sum=0;\nfor(int i=0;i<X;i++){\nsum+=table[Y-1][i];\nif(map[Y-2][i]==2) sum+=table[Y-2][i];\n}\nprintf(\"%d\\n\",sum);\n\n\n\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,a,n) for(int i=a;i<n;i++)\n#define repb(i,a,b) for(int i=a;i>=b;i--)\n#define all(a) a.begin(),a.end()\n#define o(a) cout<<a<<endl\n#define int long long\n#define fi first\n#define se second\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n\n\nsigned main() {\n\tint y, x;\n\twhile (1) {\n\t\tcin >> y >> x;\n\t\tif (y + x == 0) break;\n\t\tint d[20][20] = { -1 };\n\t\trep(i, 0, y) {\n\t\t\trep(j, 0, x) {\n\t\t\t\tcin >> d[i][j];\n\t\t\t}\n\t\t}\n\t\tint dp[20][20] = { 0 };\n\t\trep(i, 0, x) {\n\t\t\tif (d[0][i] == 0) dp[0][i] = 1;\n\t\t}\n\t\trep(i, 0, y) {\n\t\t\trep(j, 0, x) {\n\t\t\t\tif (d[i][j] == 1) continue;\n\t\t\t\tif (d[i][j] == 2) {\n\t\t\t\t\tdp[i + 2][j] += dp[i][j];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\trep(k, -1, 2) {\n\t\t\t\t\tif (j + k < 0 || j + k >= x || d[i + 1][j + k] != 0) continue;\n\t\t\t\t\tdp[i + 1][j + k] += dp[i][j];\n\t\t\t\t}\n\t\t\t\tif (d[i + 1][j] == 2) {\n\t\t\t\t\tdp[i + 1][j] += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*cout << endl;\n\t\trep(i, 0, y + 2) {\n\t\t\trep(j, 0, x) {\n\t\t\t\tcout << dp[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t\tint ans = 0;\n\t\trep(i, 0, x) {\n\t\t\tans += dp[y - 1][i];\n\t\t\tif (d[y - 2][i] == 2) {\n\t\t\t\tans += dp[y - 2][i];\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nint grid[20][20];\n\ninline bool isAtObstacle(int x, int y) {\n  return grid[y][x] == 1;\n}\n\ninline bool isAtSkiJump(int x, int y) {\n  return grid[y][x] == 2;\n}\n\nint main() {\n  int n, m;\n  \n  while(cin >> n >> m && n) {\n    for(int i=0; i<n; i++) {\n      for(int j=0; j<m; j++) {\n\tcin >> grid[i][j];\n      }\n    }\n    \n    long long dp[20][20][2] = {};\n    \n    for(int j=0; j<m; j++) {\n      if(grid[0][j]==0) { dp[0][j][0] = 1; }\n    }\n    \n    for(int i=0; i<n-1; i++) {\n      for(int j=0; j<m; j++) {\n\t\n\t// there is no case such that skier is at obstacle.\n\tif(isAtObstacle(j, i)) continue;\n\t\n\t// A skier is at a ski jump.\n\tif(isAtSkiJump(j, i)) {\n\t  if(i+2>=n) dp[n-1][j][0] += dp[i][j][0];\n\t  else dp[i+2][j][0] += dp[i][j][0];\n\t}\n\t// skiing without jump.\n\telse {\n\t  // from the upper left\n\t  if(j-1>=0) {\n\t    if(   !isAtObstacle(j-1, i+1)\n\t\t  && !isAtSkiJump (j-1, i+1) ) {\n\t      dp[i+1][j-1][1] += dp[i][j][0] + dp[i][j][1];\n\t    }\n\t  }\n\t  \n\t  // from the above\n\t  if(   !isAtObstacle(j, i+1) ) {\n\t    dp[i+1][j][0] += dp[i][j][0] + dp[i][j][1];\n\t  }\n\t  \n\t  // from the upper right\n\t  if(j+1 <m) {\n\t    if(   !isAtObstacle(j+1, i+1)\n\t\t  && !isAtSkiJump (j+1, i+1) ) {\n\t      dp[i+1][j+1][1] += dp[i][j][0] + dp[i][j][1];\n\t    }\n\t  }\n\t}\n\t\n      }\n    }\n    \n    int ans = 0;\n    for(int i=0; i<m; i++) {\n      ans += dp[n-1][i][0] + dp[n-1][i][1];\n    }\n    \n    cout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\nint X, Y;\nint c[17][17];\nint dp[17][17];\nint solve(int x, int y, int bx);\nint main(){\n  long long int ans;\n  while(1){\n    ans = 0;\n    cin >> X >> Y;\n    if(X == 0 && Y == 0) break;\n    memset(dp, 0, sizeof(dp));\n    for(int i = 0; i < Y; i++){\n      for(int j = 0; j < X; j++){\n\tcin >> c[i][j];\n      }\n    }\n    for(int i = 0; i < X; i++){\n      ans += solve(i, 0, i); \n    }\n    cout << ans << endl;\n  }\n}\n\nint solve(int x, int y, int bx){\n  if(x < 0 || x >= X || c[y][x] == 1 || c[y][x] == 2 && x != bx) return 0;\n  if(y >= Y - 1) return 1;\n  if(dp[y][x] > 0) return dp[y][x];\n  if(bx == x && c[y][x] == 2) return solve(x, y + 2, x);\n  else if(c[y][x] == 0) return dp[y][x] = solve(x - 1, y + 1, x) + solve(x, y + 1, x) + solve(x + 1, y + 1, x);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\n\nint dp[17][17];\nint map[17][17];\nint y,x;\n\nlong long int check(int i,int j)\n{\n  if(j>=x||j<0)\n    return 0;\n  if(j>=y)\n    return 0;\n\n  if(map[i][j]==1)\n    return 0;\n\n  if(dp[i][j]!=-1)\n    return dp[i][j];\n\n  long long int sum=0; \n  if(i>=x-1)\n    sum=1;\n  else if(map[i][j]==2)\n    sum=check(i+2,j);\n  else\n    {\n      if(j-1>=0 && map[i+1][j-1]==0)\n\tsum+=check(i+1,j-1);\n      sum+=check(i+1,j);\n      if(j+1<x && map[i+1][j+1]==0)\n\tsum+=check(i+1,j+1);\n    }\n    \n\n  //  cout<<i<<\" \"<<j<<\" \" <<sum<<endl;\n  dp[i][j]=sum;\n  return sum;\n}\n\nint main()\n{\n  for(;cin>>x>>y,x;)\n    {\n      memset(dp,-1,sizeof(dp));\n      memset(map,0,sizeof(map));\n      for(int i=0;i<y;i++)\n\tfor(int j=0;j<x;j++)\n\t  {\n\t    cin>>map[i][j];\n\t  }\n      long long int ans=0;\n      for(int i=0;i<y;i++)\n\tans+=check(0,i);\n      cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nint dx[3] = {-1, 0, 1};\nint dy[3] = {1, 1, 1};\n\nint main(void)\n{\n\tint **map, f1, f2, f3, **temp, x, y, sum, px, py;\n\t\n\twhile(scanf(\"%d %d\", &x, &y) && y > 0)\n\t{\n\t\tmap = new int *[y];\n\t\ttemp = new int *[y];\n\t\tsum = 0;\n\n\t\t//マップ土地&動的計画作成\n\t\tfor(f1 = 0; f1 < y; f1++)\n\t\t{\n\t\t\tmap[f1] = new int [x];\n\t\t\ttemp[f1] = new int [x];\n\t\t}\n\t\t//マップ構成入力&初期化\n\t\tfor(f1 = 0; f1 < y; f1++)\n\t\t{\n\t\t\tfor(f2 = 0; f2 < x; f2++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\",&map[f1][f2]);\n\t\t\t\ttemp[f1][f2] = 0;\n\t\t\t}\n\t\t}\n\t\t//最上のスタート地点設定\n\t\tfor(f1 = 0; f1 < x; f1++)\n\t\t{\n\t\t\tif(map[0][f1] != 1)\n\t\t\t{\n\t\t\t\ttemp[0][f1] = 1;\n\t\t\t\tsum++;\n\t\t\t}\n\t\t}\n\t\t//探索\n\t\tif(y >= 2)\n\t\t{\n\t\t\tsum = 0;\n\t\t\tfor(f1 = 0; f1 < y - 1; f1++)\n\t\t\t{\n\t\t\t\tfor(f2 = 0; f2 < x; f2++)\n\t\t\t\t{\n\t\t\t\t\tif(map[f1][f2] == 0 && temp[f1][f2] > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(f3 = 0; f3 < 3; f3++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//移動\n\t\t\t\t\t\t\tpx = f2 + dx[f3];\n\t\t\t\t\t\t\tpy = f1 + dy[f3];\n\t\t\t\t\t\t\t//範囲内か\n\t\t\t\t\t\t\tif(px >= 0 && px < x)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t//同じｘ座標からのジャンプ台\n\t\t\t\t\t\t\t\tif(f3 == 1 && py < y - 1){\n\t\t\t\t\t\t\t\t\t//ｙ軸2つ先へ\n\t\t\t\t\t\t\t\t\twhile(py < y - 1 && map[py][px] == 2)\n\t\t\t\t\t\t\t\t\t\tpy += 2;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t//着地した場所がゴール地点のｙ座標と同じで障害物にぶつかってないか\n\t\t\t\t\t\t\t\t//ゴール地点のｙ座標を超えたか\n\t\t\t\t\t\t\t\tif(py > y - 1 || py == y - 1 && map[py][px] != 1)\n\t\t\t\t\t\t\t\t\tsum += temp[f1][f2];\n\t\t\t\t\t\t\t\t//超えてないが、障害物がない地点に着地したか\n\t\t\t\t\t\t\t\telse if(map[py][px] == 0)\n\t\t\t\t\t\t\t\t\ttemp[py][px] += temp[f1][f2];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//出力\n\t\tprintf(\"%d\\n\",sum);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n  while(1){\n    int w,h,mp[20][20]={},dp[20][20] ={};\n    cin >> w >> h;\n    if(w==0 && h==0) break;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++) cin >> mp[i][j];\n    for(int i=0;i<w;i++) if(mp[0][i]==0)dp[0][i] = 1;\n\n    int ans=0;    \n    for(int i=0;i<h-1;i++)\n      for(int j=0;j<w;j++) {\n\tif(mp[i][j] !=0) break;\n\tfor(int k=-1;k<=1;k++){\n\t  int nx=j+k,ny=i+1;\n\t  if(nx<0||nx>=w) continue;\n\t  while(k==0 && mp[ny][nx]==2) ny+=2;\n\t  if(mp[ny][nx]!=0) continue;\n\t  dp[ny][nx]+= dp[i][j];\n\t  if(i >= h-1) ans+=dp[i][j];\n\t}\n      }\n    cout << ans <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <iostream>\nusing namespace std;\nconst int MAX_W = 15;\nconst int MAX_H = 15;\n\nint w, h;\nint field[MAX_H + 1][MAX_W + 2];\nint dp[MAX_H + 1][MAX_W + 2];\n\nvoid printfield() {\n\tfor (int i = 0; i < h + 1; i++) {\n\t\tfor (int j = 0; j <= w + 1; j++) {\n\t\t\tcout << '\\t' << dp[i][j] << '(' << field[i][j] << ')';\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nint main () {\n\twhile (cin >> w >> h, w || h) {\n\t\tmemset(field, 0, sizeof(field));\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tfor (int i = 0; i < h + 1; i++) {\n\t\t\tfield[i][0] = 1;\n\t\t\tdp[i][0] = 0;\n\t\t\tfield[i][w + 1] = 1;\n\t\t\tdp[i][w + 1] = 0;\n\t\t}\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\tcin >> field[i][j];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= w; i++) {\n\t\t\tif (field[0][i] == 0) dp[0][i] = 1;\n\t\t}\n\t\tfor (int i = 0; i < h - 1; i++) {\n\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\tif (field[i][j] == 0) {\n\t\t\t\t\tdp[i + 1][j] += dp[i][j];\n\t\t\t\t\tif (field[i + 1][j + 1] != 2) dp[i + 1][j + 1] += dp[i][j];\n\t\t\t\t\tif (field[i + 1][j - 1] != 2) dp[i + 1][j - 1] += dp[i][j];\n\t\t\t\t}\n\t\t\t\telse if (field[i][j] == 2) {\n\t\t\t\t\tdp[i + 2][j] += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tprintfield();\n\t\tint sum = 0;\n\t\tfor (int i = h - 1; i < h + 1; i++) {\n\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\tif (field[i][j] != 1) {\n\t\t\t\t\tsum += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# define _CRT_SECURE_NO_WARNINGS 1\n# define _USE_MATH_DEFINES\n# include <iostream>\n# include <numeric>\n# include <string>\n# include <bitset>\n# include <vector>\n# include <algorithm>\n# include <cstdlib>\n# include <cstdio>\n# include <cstring>\n# include <cstdlib>\n# include <iomanip>\n# include <queue>\n# include <sstream>\n# include <climits>\n# include <complex>\n# include <cmath>\n# include <list>\n# include <functional>\n# include <string>\n# include <ctime>\n# include <set>\n# include <forward_list>\n# include <map>\n# include <stack>\nusing namespace std;\n# define INF ((int)(1<<25))\n# define REP(i,n) for(int i=0;i<(int)n;i++)\n# define FOR(i,n) REP(i,n)\n# define FORI(i,k,n) for(int i=k;i<(int)n;i++)\n# define TORAD 2.0*M_PI/360.0\n# define INT(x) int x;cin>>x;\n# define ALL(x) begin(x),end(x)\n# define RALL(x) (x).rbegin(),(x).rend()\n# define DEBUG(x) cout<<#x<<\":\"<<x<<endl;\n# define EPS 1e-12\n#ifdef _MSC_VER\n#include <intrin.h>\n#define __builtin_popcount __popcnt\n#endif\ntypedef long long lint;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;\nconst int dx[4] = { 0, 1, 0, -1 }, dy[4] = { -1, 0, 1, 0 };\ntemplate<class T> void debug(T a) { for (auto i : a)cout << i << endl; }\n\nint main()\n{\n\tconst int M = 20;\n\twhile (true)\n\t{\n\t\tint x, y;\n\t\tint a[M][M];\n\n\t\tcin >> x >> y;\n\t\tif (!x&&!y)break;\n\n\t\tFOR(i, M)FOR(j, M)\n\t\t{\n\t\t\ta[i][j] = 1;\n\t\t}\n\n\t\tFORI(i, 1, y + 1)FORI(j, 1, x + 1)\n\t\t{\n\t\t\tcin >> a[i][j];\n\t\t}\n\t\tFORI(i, 1, x + 1)\n\t\t{\n\t\t\ta[y + 1][i] = 0;\n\t\t}\n\t\tint ans[M][M] = {};\n\t\tFORI(i, 1, x + 1)\n\t\t{\n\t\t\tif (a[1][i] == 0)ans[1][i] = 1;\n\t\t}\n\t\t\t\n\t\tFORI(i, 1, y)\n\t\t{\n\t\t\tFORI(j, 1, x + 1)\n\t\t\t{\n\t\t\t\tswitch (a[i][j])\n\t\t\t\t{\n\t\t\t\tcase 0:\n\t\t\t\t\tFORI(k, -1, 1 + 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (a[i+1][j + k] == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tans[i+1][j + k] += ans[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (a[i + 1][j] == 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tans[i + 1][j] += ans[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tans[i][j] = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tif (a[i + 2][j] != 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tans[i + 2][j] += ans[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ANS = 0;\n\t\tFORI(i, 1, x + 1)\n\t\t{\n\t\t\tANS += ans[y][i]+ans[y+1][i];\n\t\t}\n\t\tcout << ANS << endl;\n\n\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint w,h;\nint mp[20][20];\nint memo[20][20];\nint ans;\nint count;\n\nint saiki(int x,int y) {\n  count++;\n  // cout << x <<\" \"<<y <<endl;\n  int dx[3] = {-1,0,1};\n  int dy[3] = {1,1,1};\n  \n  if(y >= h-1) ans++,memo[y][x]++;\n  \n  else if(mp[y][x] != 1) {\n    for(int i=0;i<3;i++) {\n      int nx = dx[i]+x;\n      int ny = dy[i]+y;\n      if(nx <0|| nx >= w || memo[ny][nx] == -1||mp[ny][nx] == 1) continue;\n      \n      if(memo[ny][nx] > 0 && mp[ny][nx] == 0) {\n\tans += memo[ny][nx];\n\tmemo[y][x] += memo[ny][nx];\n      }  \n      else if(x == nx && memo[ny][nx] == 2 && memo[ny][nx] > 0) {\n\tans += memo[ny][nx];\n\tmemo[y][x] += memo[ny][nx];\n      }\n      else if(mp[ny][nx] == 0){\n\tsaiki(nx,ny);\n\tif(memo[ny][nx] > 0) memo[y][x] += memo[ny][nx];\n      } \n      else if(nx==x && mp[ny][nx] == 2){\n\tint ty = ny;\n\twhile(mp[ty][nx] == 2) ty+=2;\n\tif(mp[ty][nx] == 0)saiki(nx,ty);\n\tif(memo[ty][nx] > 0) memo[y][x] += memo[ty][nx];\n      }\n    }\n    if(memo[y][x] == 0) memo[y][x] = -1;\n  }\n}\n\n\nint main() {\n\n  while(1) {\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n\n    for(int i=0;i<=19;i++) \n      for(int j=0;j<=19;j++){ \n\tmemo[i][j] = 0;\n\tmp[i][j] = 0;\n      }\n    \n    for(int i=0;i<h;i++) \n      for(int j=0;j<w;j++) \n\tcin >> mp[i][j];\n\n\n    ans = 0;\n    count = 0;\n    for(int i=0;i<w;i++) {\n      if(mp[0][i] !=1) saiki(i,0);\n    }\n    \n    /*    for(int i=0;i<h;i++) {\n    for(int j=0;j<w;j++) \n      cout << memo[i][j]<<\" \";\n    cout << endl;\n    } */\n    \n  \n    int ans2 = 0;\n    for(int i=0;i<w;i++) \n      if(memo[0][i] > 0) ans2+=memo[0][i];\n    \n    cout << ans << endl;\n    //    cout << ans2 << endl;\n    //cout << count << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nint grid[30][30];\n\ninline bool isAtObstacle(int x, int y) {\n  return grid[y][x] == 1;\n}\n\ninline bool isAtSkiJump(int x, int y) {\n  return grid[y][x] == 2;\n}\n\nint main() {\n  int n, m;\n  \n  while(cin >> n >> m && n) {\n    fill(grid[0], grid[0]+900, 0);\n    for(int i=0; i<n; i++) {\n      for(int j=0; j<m; j++) {\n\tcin >> grid[i][j];\n      }\n    }\n    \n    long long dp[30][30][2] = {};\n    \n    for(int j=0; j<m; j++) {\n      if(grid[0][j]==0) { dp[0][j][0] = 1; }\n    }\n    \n    int extra = 0;\n    for(int i=0; i<n-1; i++) {\n      for(int j=0; j<m; j++) {\n\t\n\t// there is no case such that skier is at obstacle.\n\tif(isAtObstacle(j, i)) {\n\t  dp[i][j][0] = dp[i][j][1] = 0;\n\t  continue;\n\t}\n\t\n\t// A skier is at a ski jump.\n\tif(isAtSkiJump(j, i)) {\n\t  if(i+2 > n-1) extra += dp[i][j][0];\n\t  else {\n\t    if(isAtObstacle(j, i+2)) continue;\n\t    dp[i+2][j][0] += dp[i][j][0];\n\t  }\n\t}\n\t\n\t// skiing without jump.\n\telse {\n\t  // from the upper left\n\t  if( j-1 >= 0\n\t      && !isAtObstacle(j-1, i+1)\n\t      && !isAtSkiJump (j-1, i+1) ) {\n\t    dp[i+1][j-1][1] += dp[i][j][0] + dp[i][j][1];\n\t  }\n\t  \n\t  // from the above\n\t  if( !isAtObstacle(j, i+1) ) {\n\t    dp[i+1][j][0] += dp[i][j][0] + dp[i][j][1];\n\t  }\n\t  \n\t  // from the upper right\n\t  if( j+1 < m\n\t      && !isAtObstacle(j+1, i+1)\n\t      && !isAtSkiJump (j+1, i+1) ) {\n\t    dp[i+1][j+1][1] += dp[i][j][0] + dp[i][j][1];\n\t  }\n\t}\n\t\n      }\n    }\n    \n    for(int i=0; i<m; i++) {\n      if(isAtObstacle(i, n-1)) {\n\tdp[n-1][i][0] = dp[n-1][i][1] = 0;\n      }\n    }\n    \n    int ans = 0;\n    for(int i=0; i<m; i++) {\n      ans += dp[n-1][i][0] + dp[n-1][i][1];\n    }\n    \n    cout << ans + extra << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define N 20\nusing namespace std;\nvoid func(int,int);\nint jump(int,int);\nint X,Y,data[N][N],memo[N][N];\nint main(){\n  while(1){\n    cin >> X >> Y;\n    if(X==0&&Y==0) break;\n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++) data[i][j] = memo[i][j] = 0;\n\n    for(int i=0;i<Y;i++)\n      for(int j=0;j<X;j++) cin >> data[i][j];\n\n    for(int i=0;i<X;i++)\n      if(data[0][i]!=1) func(0,i);\n\n    int cnt=0;\n    for(int i=0;i<X;i++) cnt+=memo[0][i];\n    cout << cnt << endl;\n  }\n  return 0;\n}\nvoid func(int y,int x){\n  if(y>=Y-1){\n    memo[y][x]++;\n    return ;\n  }\n  if(0<=x-1 && data[y+1][x-1]==0){\n    if(memo[y+1][x-1]==0) func(y+1,x-1);\n    memo[y][x]+=memo[y+1][x-1];\n  }\n  if(x+1< X &&data[y+1][x+1]==0){\n    if(memo[y+1][x+1]==0) func(y+1,x+1);\n    memo[y][x]+=memo[y+1][x+1];\n  }\n  if(data[y+1][x]==0){\n    if(memo[y+1][x]==0) func(y+1,x);\n    memo[y][x]+=memo[y+1][x];\n  }\n  if(data[y+1][x]==2){\n    int r=jump(y+1,x);\n    if(r!=-1){\n      if(memo[r][x]==0) func(r,x);\n      memo[y][x]+=memo[r][x];\n    }\n  }\n  if(memo[y][x]==0) data[y][x]=1;\n}\nint jump(int y,int x){\n  while(data[y][x]==2)y+=2;\n  if(data[y][x] == 0 && (data[y][x]==0||y>=Y-1)) return y;\n  return -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint dy[] = { 1, 1, 1};\nint dx[] = { -1, 0, 1 };\n\nint main() {\n    while (1) {\n        int dp[17][15] = { 0 };\n        int field[15][15] = { 0 };\n        int h, w;\n\n        cin >> w >> h;\n        if (w == 0) {\n            break;\n        }\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                cin >> field[i][j];\n            }\n        }\n        \n        for (int j = 0; j < w; j++) {\n            if (field[0][j] == 0) {\n            dp[0][j] = 1;\n            }\n        }\n        \n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                if (dp[i][j] > 0) {\n                    if (i == h - 1) {\n                        dp[i + 1][j] += dp[i][j];\n                        continue;\n                    }\n                    if (field[i][j] == 2) {\n                        if (field[i + 2][j] == 0 || field[i + 2][j] == 2) {\n                            dp[i + 2][j] += dp[i][j];\n                        }\n                        continue;\n                    }\n                    for (int k = 0; k < 3; k++) {\n                        int nx = j + dx[k];\n                        int ny = i + dy[k];\n                        if (nx < 0 || nx >= w) {\n                            continue;\n                        }\n                        if (field[ny][nx] == 0 || (field[ny][nx] == 2 && k == 1)) {\n                            dp[ny][nx] += dp[i][j];\n                        }\n                    }\n                }\n            }\n        }\n        \n        int ans = 0;\n        for (int i = h; i <= h + 1; i++) {\n            for (int j = 0; j < w; j++) {\n                ans += dp[i][j];\n            }\n        }\n        cout << ans << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main()\n{\n    while(1)\n    {\n        int x,y,ans=0;\n        int dp[16][16]={0};\n        int course[15][15]={0};\n        cin>>x>>y;if(!x)return 0;\n        for(int j=0;j<y;++j){\n            for(int i=0;i<x;++i){\n            \tcin>>course[i][j];\n            \tif(!course[i][0])dp[i][0]=1;\n            }\n        }\n        for(int j=0;j<y-1;++j){\n            for(int i=0;i<x;++i){\n                if(!course[i][j]){\n                    if(course[i][j+1]!=1)dp[i][j+1]+=dp[i][j];\n                    if(i){\n                        if(!course[i-1][j+1])dp[i-1][j+1]+=dp[i][j];\n                    }\n                    if(i<x){\n                        if(!course[i+1][j+1])dp[i+1][j+1]+=dp[i][j];\n                    }\n                }\n                if(course[i][j]==2){\n                    if(course[i][j]!=1)dp[i][j+2]+=dp[i][j];\n                }\n            }\n        }\n        for(int j=y-1;j<y+1;++j){\n            for(int i=0;i<x;++i){\n                ans+=dp[i][j];\n            }\n        }\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n\nint w,h,i,j,m[16][16],d[16][16];\n\nint f(int x,int y){\n\tif(~d[y][x])return d[y][x];\n\tif(m[y][x]==1)return 0;\n\tif(y>=h)return 1;\n\t\n\tint r=0;\n\tif(!m[y][x]){for(int i=-1;i<2;i++)r+=x+i>0&&x+i<=w&&!(m[y+1][x+i]==2&&i!=0)?f(x+i,y+1):0;return d[y][x]=r;}\n\treturn d[y][x]=f(x,y+2);\n}\n\nint main(){\n\twhile(std::cin>>w>>h,w){\n\t\tfor(i=17;--i;)for(j=17;--j;)d[i][j] = -1;\n\t\tfor(;i++<h;)for(j=w;j;j--)std::cin >> m[i][j];\n\t\tfor(int i=w;i;i--)j+=f(i, 1);\n\t\tstd::cout<<j<<'\\n';\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\nint main()\n{\n\tint map[100][100];\n\tint dp[100][100];\n\t\n\tint X, Y;\n\twhile (scanf(\"%d %d\", &X, &Y), X + Y){\n\t\tfor (int i = 0; i < 100; i++){\n\t\t\tdp[0][i] = 1;\n\t\t\tfor (int j = 1; j < 100; j++){\n\t\t\t\tdp[j][i] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < Y; i++){\n\t\t\tfor (int j = 0; j < X; j++){\n\t\t\t\tscanf(\"%d\", &map[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < Y; i++){\n\t\t\tfor (int j = 0; j < X; j++){\n\t\t\t\tif (map[i][j] == 0){\n\t\t\t\t\tfor (int k = -1; k <= 1; k++){\n\t\t\t\t\t\tif (j + k >= 0 && j + k < X && (map[i + 1][j + k] == 0 || (k == 0 && map[i + 1][j + k] == 2)) && (i < Y - 1 || k == 0)){\n\t\t\t\t\t\t\tdp[i + 1][j + k] += dp[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (map[i][j] == 2){\n\t\t\t\t\tdp[i + 2][j] += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < X; i++){\n//\t\t\tprintf(\"%d \", dp[Y][i]);\n\t\t\tsum += dp[Y][i];\n\t\t\tsum += dp[Y + 1][i];\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", sum);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n\nusing namespace std;\n\nint main(int argc, char const* argv[])\n{\n\tint x,y;\n\tint stage[17][17][2];\n\n\twhile( cin >> x >> y && x != 0 && y != 0 ){\n\t\tfor( int i = 0;i < 17;i++ ){\n\t\t\tfor( int j = 0;j < 17;j++ ){\n\t\t\t\tstage[i][j][0] = stage[i][j][1] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor( int i = 0;i < 17;i++ ) stage[i][1][1] = 1;\n\t\t\n\t\tfor( int i = 1;i <= y;i++ ){\n\t\t\tfor( int j = 1;j <= x;j++ ){\n\t\t\t\tcin >> stage[j][i][0];\n\t\t\t}\n\t\t}\n\n\t\tfor( int j = 1;j <= y;j++ ){\n\t\t\tfor( int i = 1;i <= x;i++ ){\n\t\t\t\tif( stage[i][j][0] == 1 ) continue;\n\t\t\t\tif( stage[i][j][0] == 0 ){\n\t\t\t\t\tstage[i][j + 1][1] += stage[i][j][1];\n\t\t\t\t\t\n\t\t\t\t\tif( stage[i + 1][j + 1][0] == 0 && j != y ) stage[i + 1][j + 1][1] += stage[i][j][1];\n\t\t\t\t\tif( stage[i - 1][j + 1][0] == 0 && j != y ) stage[i - 1][j + 1][1] += stage[i][j][1];\n\n\t\t\t\t}\n\t\t\t\tif( stage[i][j][0] == 2 ){\n\t\t\t\t\tstage[i][j + 2][1] += stage[i][j][1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint count = 0;\n\t\tfor( int i = 1;i <= x;i++ ){\n\t\t\tcount += stage[i][y+1][1];\n\t\t}\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nint main(void){\n\tint X,Y;\n\t\n\twhile(scanf(\"%d%d\", &X, &Y) && X && Y){\n\t\tint masu[32][32]={0};\n\t\tint co[32][32]={0};\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < Y; i++){\n\t\t\tfor(int j = 0; j < X; j++){\n\t\t\t\tscanf(\"%d\", &masu[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < X; i++){\n\t\t\tif(!masu[0][i])co[0][i] = 1;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < Y-1; i++){\n\t\t\tfor(int j = 0; j < X; j++){\n\t\t\t\tif(masu[i][j] == 0){\n\t\t\t\t\tif(masu[i+1][j] != 1)co[i+1][j] += co[i][j];\n\t\t\t\t\tif(masu[i+1][j+1] == 0)co[i+1][j+1] += co[i][j];\n\t\t\t\t\tif(masu[i+1][j-1] == 0 && j-1 > -1)co[i+1][j-1] += co[i][j];\n\t\t\t\t}else if(masu[i][j] != 1){\n\t\t\t\t\tco[i+2][j] += co[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < X; i++){\n\t\t\tans += co[Y-1][i];\n\t\t}\n\t\tfor(int i = 0; i < X; i++){\n\t\t\tans += co[Y][i];\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint gole, X, Y;\nint map[15][15];\n\nbool check(int x, int y, int flag) { // flag: ツ陳シツ進ツつオツづつォツつスツつゥ\n\tif (x < 0 || x >= X) return false;\n\tif (y >= Y) { gole += flag; return false; }\n\tif (map[y][x] == 1) return false;\n\tif (!flag && map[y][x] == 2) return false;\n\treturn true;\n}\n\nint main() {\n\twhile (cin >> X >> Y, X || Y) {\n\t\tint pattern[15][15] = {0};\n\t\tgole = 0;\n\t\tfor (int y = 0; y < Y; ++y)\n\t\t\tfor (int x = 0; x < X; ++x)\n\t\t\t\tcin >> map[y][x];\n\n\t\tfor (int x = 0; x < X; ++x)\n\t\t\tif (map[0][x] == 0)\n\t\t\t\tpattern[0][x] = 1;\n\n\t\tfor (int y = 1; y < Y; ++y)\n\t\t\tfor (int x = 0; x < X; ++x) {\n\t\t\t\tif (map[y-1][x] == 0) {\n\t\t\t\t\tif (check(x-1, y, false)) pattern[y][x-1] += pattern[y-1][x];\n\t\t\t\t\tif (check(x,   y, true))  pattern[y][x]   += pattern[y-1][x];\n\t\t\t\t\tif (check(x+1, y, false)) pattern[y][x+1] += pattern[y-1][x];\n\t\t\t\t}\n\t\t\t\telse if (map[y-1][x] == 1) continue;\n\t\t\t\telse if (check(x, y+1, pattern[y-1][x])) pattern[y+1][x] += pattern[y-1][x];\n\t\t\t};\n\n\t\tfor (int x = 0; x < X; ++x) gole += pattern[Y-1][x];\n\n\t\tcout << gole << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nint w, h;\nint map[16][15], memo[16][15];\n\nint rec(int x, int y){\n\tif(memo[y][x] >= 0){\n\t\treturn memo[y][x];\n\t}\n\n\tif(map[y][x] == 1){\n\t\treturn 0;\n\t}\n\n\tif(y >= h-1){\n\t\treturn 1;\n\t}\n\n\tint res = 0;\n\tif(map[y][x] == 0){\n\t\tfor(int i=-1;i<2;i++){\n\t\t\tif(x+i >= 0 && x+i < w && !(map[y+1][x+i] == 2 && i != 0)){\n\t\t\t\tres += rec(x+i, y+1);\n\t\t\t}\n\t\t}\n\t\treturn memo[y][x] = res;\n\t}else if(map[y][x] == 2){\n\t\treturn memo[y][x] = rec(x, y+2);\n\t}\n}\n\nint main(){\n\twhile(std::cin >> w >> h, w){\n\n\t\tfor(int i=0;i<16;i++){\n\t\t\tfor(int j=0;j<15;j++){\n\t\t\t\tmemo[i][j] = -1;\n\t\t\t\tmap[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tstd::cin >> map[i][j];\n\t\t\t}\n\t\t}\n\n\t\tint res = 0;\n\t\tfor(int i=0;i<w;i++){\n\t\t\tres += rec(i, 0);\n\t\t}\n\n\t\tstd::cout << res << std::endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define loop(i,a,b) for(int i=a; i<b; i++)\n#define rep(i,b) loop(i,0,b)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\n\nint main(){\n    int w,h;\n    while(cin>>w>>h, w||h){\n        int G[100][100];\n        int dp[100][100]={};\n        rep(i,h)rep(j,w) cin>> G[i][j];\n\n        rep(i,w) dp[0][i] = G[0][i]==0;\n\n        rep(i,h-1) rep(j,w){\n            if( G[i][j]==1){\n                dp[i][j]=0;\n            } else if(G[i][j]==2 && G[i+2][j]!=1){\n                dp[i+2][j]+=dp[i][j];\n            } else {\n                if(G[i+1][j]==2) dp[i+1][j]+=dp[i][j];\n                loop(k,-1,2){\n                    if(0<=j+k && j+k<w && G[i+1][j+k]==0){\n                        dp[i+1][j+k]+=dp[i][j];\n                    }\n                }\n            }\n        }\n\n        ull res=0;\n        loop(i,h-1,h+1)rep(j,w){\n            if(G[i][j]!=1)res+=dp[i][j];\n        }\n\n        cout<<res<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nint main()\n{\n\tfor(int w,h;cin>>w>>h,w|h;){\n\t\tvvi field(h+1,vi(w));\n\t\trep(i,h) rep(j,w)\n\t\t\tcin>>field[i][j];\n\t\t\n\t\tvvi dp(h+1,vi(w));\n\t\trep(i,w)\n\t\t\tif(field[0][i]==0)\n\t\t\t\tdp[0][i]=1;\n\t\trep(i,h-1) rep(j,w){\n\t\t\tif(field[i][j]==1)\n\t\t\t\tdp[i][j]=0;\n\t\t\telse if(field[i][j]==2){\n\t\t\t\tif(field[i+2][j]!=1)\n\t\t\t\t\tdp[i+2][j]+=dp[i][j];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(field[i+1][j]==2)\n\t\t\t\t\tdp[i+1][j]+=dp[i][j];\n\t\t\t\tfor(int k=-1;k<=1;k++)\n\t\t\t\t\tif(0<=j+k && j+k<w && field[i+1][j+k]==0)\n\t\t\t\t\t\tdp[i+1][j+k]+=dp[i][j];\n\t\t\t}\n\t\t}\n\t\tll res=0;\n\t\trepi(i,h-1,h+1) rep(j,w)\n\t\t\tif(field[i][j]!='1')\n\t\t\t\tres+=dp[i][j];\n\t\tcout<<res<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<queue>\n#include<string>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define reps(i,n) for(int i=1;i<=int(n);i++)\n#define sint(i) scanf(\"%d\",&i);\n#define sintt(i,j) scanf(\"%d%d\",&i,&j);\n#define sinttt(i,j,k) scanf(\"%d%d%d\",&i,&j,&k);\n#define sintttt(i,j,k,m) scanf(\"%d%d%d%d\",&i,&j,&k,&m);\n\n#define INF 1010000000\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\n\n\nint main(){\n\twhile(1){\n\t\tint n,m;\n\t\tsintt(n,m);\n\t\tif(n==0)break;\n\t\tint masu[17][17];\n\t\tint dp[17][17];\n\t\t\n\t\trep(i,17)rep(j,17)masu[i][j]=dp[i][j]=0;\n\t\t\n\t\trep(i,m)rep(j,n){\n\t\t\tsint(masu[j+1][i]);\n\t\t}\n\t\t\n\t\treps(j,n){\n\t\t\tif(masu[j][0]!=1){\n\t\t\t\tdp[j][0]=1;\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(i,m-1){\n\t\t\treps(j,n){\n\t\t\t\tif(masu[j][i]==1){\n\t\t\t\t\tdp[i][j]=0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(masu[j][i]==2){\n\t\t\t\t\tif(masu[j][i+2]!=1){\n\t\t\t\t\t\tdp[j][i+2]+=dp[j][i];\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(masu[j][i]==0){\n\t\t\t\t\tif(masu[j-1][i+1]==0){\n\t\t\t\t\t\tdp[j-1][i+1]+=dp[j][i];\n\t\t\t\t\t}\n\t\t\t\t\tif(masu[j+1][i+1]==0){\n\t\t\t\t\t\tdp[j+1][i+1]+=dp[j][i];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(masu[j][i+1]!=1){\n\t\t\t\t\t\tdp[j][i+1]+=dp[j][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans=0;\n\t\tfor(int i=m-1;i<=m;i++){\n\t\t\treps(j,n){\n\t\t\t\tans+=dp[j][i];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t\t\n\t\trep(i,m+2){\n\t\t\trep(j,n+2){\n\t\t\t\tprintf(\"%d \",dp[j][i]);\n\t\t\t}puts(\"\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint solve(int x,int y);\nint ax,ay;\nint mas[200][200];\nlong long memo[200][200];\nint main(){\n  while(1){\n    for(int i=0;i<200;i++){\n      for(int j=0;j<200;j++){\n\tmemo[i][j]=0;\n      }\n    }\n    long long ans=0;\n    cin>>ax>>ay;\n    if(ax==0 && ay==0) break;\n    \n    for(int i=0;i<ay;i++){\n      for(int j=0;j<ax;j++){\n\tcin>>mas[i][j];\n      }\n    }\n    \n    for(int i=0;i<ax;i++){\n      if(mas[0][i]!=1){\n\tans+=solve(i,0);\n      }\n    }\n    cout<<ans<<endl;\n  }\n}\nint solve(int x,int y){\n  if(memo[y][x]!=0){\n    return memo[y][x];\n  }\n  else if(y==ay){\n    return 1;\n  }else if(mas[y][x]==1){\n    return 0;\n  }else if(mas[y][x]==2){\n    return solve(x,y+2);\n  } \n  else{\n    long long anss=0; \n    if(mas[y+1][x]!=1){\n      anss+=solve(x,y+1);\n    }\n    if(x+1<ax && mas[y+1][x+1]==0 && y+1!=ay){\n      anss+=solve(x+1,y+1);\n    }\n    if(0<=x-1 && mas[y+1][x-1]==0 && y+1!=ay){\n      anss+=solve(x-1,y+1);\n    }\n    return memo[y][x]=anss;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define rep2(x,from,to) for(int x=(from);(x)<(to);(x)++)\n#define rep(x,to) rep2(x,0,to)\nusing namespace std;\nint main(){\n\tint x, y;\n\twhile(cin >> x >> y && (x||y) ) {\n\t\tint b[15][15] = {};\n\t\trep(i,y) {\n\t\t\trep(j,x) {\n\t\t\t\tcin >> b[i][j];\n\t\t\t}\n\t\t}\n\t\tint ret[20][20] = {};\n\t\trep(i,x) {\n\t\t\tif(b[0][i] == 0) {\n\t\t\t\tret[0][i+1] = 1;\n\t\t\t}\n\t\t}\n\t\trep2(i,1,y) {\n\t\t\trep(j,x) {\n\t\t\t\tif(b[i][j] == 0) {\n\t\t\t\t\tret[i][j+1] += ret[i-1][j] + ret[i-1][j+1] + ret[i-1][j+2];\n\t\t\t\t\trep2(k,-1,1) {\n\t\t\t\t\t\tif(b[i-1][j+k] == 2) ret[i][j+1] -= ret[i-1][j+k+1];\n\t\t\t\t\t}\n\t\t\t\t} else if(b[i][j] == 2) {\n\t\t\t\t\tif(b[i+2][j] != 1) ret[i+2][j+1] += ret[i-1][j+1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\trep2(i,y-1,y+2) {\n\t\t\trep(j,x) {\n\t\t\t\tans += ret[i][j+1];\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tint s,i,j,x,y,c[15][15],d[17][15];\n\twhile(cin >> x >> y) {\n\t\tif (x+y==0) break;\n\t\tfor (i=0;i<y;i++) for (j=0;j<x;j++) cin >> c[i][j];\n\t\tfor (i=0;i<y+2;i++) for (j=0;j<x;j++) d[i][j]=(i==0);\n\t\tfor (i=0;i<y-1;i++) for (j=0;j<x;j++) {\n\t\t\ts=d[i][j];\n\t\t\tif (c[i][j]==0) { \n\t\t\t\tif (j>0) if (c[i+1][j-1]==0) d[i+1][j-1]+=s;\n\t\t\t\tif (j<x-1) if (c[i+1][j+1]==0) d[i+1][j+1]+=s;\n\t\t\t\tif (c[i+1][j]!=1) d[i+1][j]+=s;\n\t\t\t}\n\t\t\tif (c[i][j]==2 && c[i+2][j]!=1) d[i+2][j]+=s;\n\t\t}\n\t\ts=0;\n\t\tfor (i=y-1;i<=y;i++) for (j=0;j<x;j++) s+=d[i][j];\n\t\tif (y==1) s=0;\n\t\tcout << s << endl; \n\t }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//03\n#include<iostream>\n\nusing namespace std;\n\nint main(){\n  for(int x,y;cin>>x>>y,x|y;){\n    int g[17][16]={};\n    for(int i=1;i<=x;i++){\n      for(int j=1;j<=y;j++){\n\tcin>>g[i][j];\n      }\n    }\n    int a[17][16]={};\n    for(int i=1;i<=x;i++){\n      a[1][i]=1;\n    }\n    for(int i=1;i<=y-1;i++){\n      for(int j=1;j<=x;j++){\n\tif(g[i][j]==0){\n\t  for(int k=-1;k<=1;k++){\n\t    if(1<=j+k&&j+k<=x){\n\t      if(g[i+1][j+k]==0){\n\t\ta[i+1][j+k]+=a[i][j];\n\t      }else if(k==0&&g[i+1][j]==2){\n\t\ta[i+1][j]+=a[i][j];\n\t      }\n\t    }\n\t  }\n\t}else if(g[i][j]==2){\n\t  if(g[i+2][j]!=1){\n\t    a[i+2][j]+=a[i][j];\n\t  }\n\t}\n      }\n    }\n    int ans=0;\n    for(int i=1;i<=x;i++){\n      ans+=a[y][i]+a[y+1][i];\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nint m[500][500];\nint dp[500][500];\n\nint dx[]={-1,0,1};\n\nint solve(int r,int c){\n  rep(i,r+2)rep(j,c)dp[i][j]=0;\n  rep(j,c)if(m[0][j] == 0)dp[0][j]=1;\n\n  rep(i,r){\n    rep(j,c){\n      if (m[i][j] == 0 && i != r-1){\n\trep(k,3){\n\t  int nex = j+dx[k];\n\t  if (nex<0||nex>=c)continue;\n\t  if (m[i+1][nex] == 0)dp[i+1][nex]+=dp[i][j];\n\t  else if (m[i+1][nex] == 2 && k == 1)dp[i+1][nex]+=dp[i][j];\n\t}\n      }else if (m[i][j] == 2){\n\tdp[i+2][j]+=dp[i][j];\n      }\n    }\n  }\n  \n  int ans = 0;\n  rep(j,c)ans+=dp[r][j]+dp[r-1][j]+dp[r+1][j];\n  return ans;\n}\n\nmain(){\n  int c,r;\n  while(cin>>r>>c && r){\n    rep(i,r)rep(j,c)cin>>m[i][j];\n    rep(j,c)m[r][j]=m[r+1][j]=0;\n    cout << solve(r,c) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\n\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nint x, y, c[16][16], dp[30][30];\nconst int dx[3] = {-1, 0, 1};\n\nvoid solve() {\n  memset(dp, 0, sizeof dp);\n  \n  rep(i,y) rep(j,x) cin>>c[i][j];\n  \n  rep(i,x) if (c[0][i] == 0) dp[0][i] = 1;\n  \n  rep(i,y) rep(j,x) {\n    if (c[i][j] == 0) {\n      rep(z,3) {\n        int ti = i + 1, tj = j + dx[z];\n        if (ti < 0 || tj < 0 || ti >= y || tj >= x) continue;\n        if (c[ti][tj] == 1) continue;\n        if (c[ti][tj] == 2 && z != 1) continue;\n        dp[ti][tj] += dp[i][j];\n      }\n    } else if (c[i][j] == 2) {\n      dp[i+2][j] += dp[i][j];\n    }\n  }\n  /*\n  rep(i,y+1) {\n    rep(j,x) printf(\"%8d\",dp[i][j]);\n    cout<<endl;\n  }*/\n  \n  int res = 0;\n  REP(i,y-1,y+1) rep(j,x) res += dp[i][j];\n  cout<<res<<endl;\n}\n\nint main (int argc, char const* argv[]) {\n  while (cin>>x>>y, x||y) {\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 2011/10/07 Tazoe\n\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n\twhile(true){\n\t\tint X, Y;\n\t\tcin >> X >> Y;\n\t\tif(X==0&&Y==0)\n\t\t\tbreak;\n\n\t\tint C[18][17];\n\t\tfor(int i=0; i<=Y+2; i++)\n\t\t\tfor(int j=0; j<=X+1; j++)\n\t\t\t\tC[i][j] = 1;\n\n\t\tfor(int i=1; i<=Y; i++)\n\t\t\tfor(int j=1; j<=X; j++)\n\t\t\t\tcin >> C[i][j];\n\n\t\tfor(int i=Y+1; i<=Y+2; i++)\n\t\t\tfor(int j=1; j<=X; j++)\n\t\t\t\tC[i][j] = 0;\n\n\t\tint DP[18][17];\n\t\tfor(int i=0; i<=Y+2; i++)\n\t\t\tfor(int j=0; j<=X+1; j++)\n\t\t\t\tDP[i][j] = 0;\n\n\t\t\tfor(int j=1; j<=X; j++)\n\t\t\t\tif(C[1][j]==0)\n\t\t\t\t\tDP[1][j] = 1;\n\n\t\tfor(int i=2; i<=Y; i++)\n\t\t\tfor(int j=1; j<=X; j++)\n\t\t\t\tif(C[i][j]==0){\n\t\t\t\t\tDP[i][j] += (DP[i-1][j-1]+DP[i-1][j]+DP[i-1][j+1]);\n\t\t\t\t}\n\t\t\t\telse if(C[i][j]==1){\n\t\t\t\t\tDP[i][j] = 0;\n\t\t\t\t}\n\t\t\t\telse if(C[i][j]==2){\n\t\t\t\t\tDP[i+2][j] += (DP[i-1][j]+DP[i][j]);\n\t\t\t\t\tDP[i][j] = 0;\n\t\t\t\t}\n\n\t\tint sum = 0;\n\t\tfor(int i=Y; i<=Y+2; i++)\n\t\t\tfor(int j=1; j<=X; j++)\n\t\t\t\tsum += DP[i][j];\n\n\t\tcout << sum <<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <functional>\n#include <numeric>\n#define fi first\n#define se second\nusing namespace std;\nbool value(int y,int x,int R,int C){return 0<=y&&y<R&&0<=x&&x<C;}\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<long long > vll;\ntypedef vector< vi > vvi;\ndouble pie=acos(-1);\nint INF=10000009;\nint dx[4] = { 0,-1,0,1 };\nint dy[4] = { -1,0,1,0 };\nint c[20][20];\nlong long int dp[20][20];\nint main() {\n\tint X,Y;\n\twhile(true){\n\t\tlong long int ans=0;\n\t\tcin>>X>>Y;\n\t\tif(X+Y==0) break;\n\t\tfor(int i=1;i<=Y;i++){\n\t\t\tfor(int j=1;j<=X;j++){\n\t\t\t\tcin>>c[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=X;i++){\n\t\t\tif(c[1][i]==1){\n\t\t\t\tdp[1][i]=0;\n\t\t\t}\n\t\t\tif(c[1][i]==0){\n\t\t\t\tdp[1][i]=1;\n\t\t\t}\n\t\t\tif(c[1][i]==2){\n\t\t\t\tdp[1][i]=1;\n\t\t\t\tdp[3][i]=1;\n\t\t\t}\n\t\t}\n\t\tfor(int i=2;i<=Y;i++){\n\t\t\tfor(int j=1;j<=X;j++){\n\t\t\t\tif(c[i][j]==1) dp[i][j]=0;\n\t\t\t\telse if(c[i][j]==0){\n\t\t\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\t\t\tif(c[i-1][j-1+k]!=2){\n\t\t\t\t\t\t\tdp[i][j]+=dp[i-1][j-1+k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(c[i-1][j]!=2){\n\t\t\t\t\t\tdp[i][j]+=dp[i-1][j];\n\t\t\t\t\t\tdp[i+2][j]+=dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tdp[i][j]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=Y;i<=Y+2;i++){\n\t\t\tfor(int j=1;j<=X;j++){\n\t\t\t\tans+=dp[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=Y+2;i++){\n\t\t\tfor(int j=1;j<=X;j++){\n\t\t\t\tdp[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\n\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nint x, y, c[50][50], dp[50][50];\nconst int dx[3] = {-1, 0, 1};\n\nvoid solve() {\n  memset(dp, 0, sizeof dp);\n  \n  rep(i,y) rep(j,x) cin>>c[i][j];\n  \n  rep(i,x) if (c[0][i] == 0) dp[0][i] = 1;\n  \n  rep(i,y-1) rep(j,x) {\n    if (c[i][j] == 0) {\n      rep(z,3) {\n        int ti = i + 1, tj = j + dx[z];\n        if (tj < 0 || tj >= x) continue;\n        if (c[ti][tj] == 1) continue;\n        if (c[ti][tj] == 2 && z != 1) continue;\n        dp[ti][tj] += dp[i][j];\n      }\n    } else if (c[i][j] == 2) {\n      dp[i+2][j] += dp[i][j];\n    }\n  }\n  /*\n  rep(i,y+1) {\n    rep(j,x) printf(\"%8d\",dp[i][j]);\n    cout<<endl;\n  }*/\n  \n  int res = 0;\n  rep(j,x) res += dp[y][j] + dp[y-1][j];\n  cout<<res<<endl;\n}\n\nint main (int argc, char const* argv[]) {\n  while (cin>>x>>y, x||y) {\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nconst int X=20;\nconst int Y=20;\nint main(){\n    int n,m,k;\nlong long int dp[X][Y],s[X][Y],ans;\n    while(true){\n        scanf(\"%d%d\",&n,&m);\n        if(n==0&&m==0)return 0;\n        ans=0;\n        for(int i=0;i<n+2;i++)for(int j=0;j<m;j++)dp[i][j]=s[i][j]=0;\n        for(int i=0;i<m;i++)dp[0][i]=1;\n        for(int i=0;i<n;i++)for(int j=0;j<m;j++){\n            scanf(\"%d\",&k);\n            if(k==0){\n                dp[i][j]+=s[i][j];\n                if(i==n-1)continue;\n                dp[i+1][j]+=dp[i][j];\n                if(j!=0)s[i+1][j-1]+=dp[i][j];\n                if(j!=m-1)s[i+1][j+1]+=dp[i][j];\n            }\n            else if(k==2){\n                s[i][j]=0;\n                dp[i+2][j]+=dp[i][j];\n            }\n            else dp[i][j]=0;\n        }\n        for(int i=0;i<m;i++)ans+=dp[n][i]+dp[n-1][i];\n        printf(\"%lld\\n\",ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n\nusing namespace std;\n\nconst int MAX = 17;\nint in[MAX][MAX], X,Y,data[MAX][MAX],ans;\nint dx[4] = {-1,0,1};\n\n\nvoid init(){\n  memset(data,0,sizeof(data));\n  ans = 0;\n}\n\n\nvoid solve(){\n  for(int i = 1; i <= Y; i++)\n    for(int j = 1; j <= X; j++){\n      for(int k = 0; k < 3; k++)\n\tif(i-1 > 0 && j + dx[k] > 0 && j+dx[k] <= X && in[i][j] != 1 && in[i-1][j+dx[k]] != 2){\n\t  if(in[i][j] == 2) data[i][j] = data[i-1][j];\n\t  else data[i][j] += data[i-1][j+dx[k]];\n\t}\n      if(i-2 > 0 && in[i-2][j] == 2 && in[i][j] != 1) data[i][j] += data[i-2][j];\n    }\n\n  for(int j = 1; j <= X; j++){\n    if(Y-1 > 0 && in[Y-1][j] == 2) ans+=data[Y-1][j];\n    ans+=data[Y][j];\n  }\n  cout << ans << endl;\n}\n\nvoid print(){\n  for(int i = 1; i <= Y; i++){\n    for(int j = 1; j <= X; j++)\n      cout << data[i][j]<< \" \";\n    cout << endl;\n  }\n}\nint main(){\n  while(cin >> X >> Y && X+Y){\n    init();\n    for(int i = 1; i <= Y; i++)\n      for(int j = 1; j <= X; j++)\n\tcin >> in[i][j];\n    \n    for(int i = 1; i <= X; i++)\n      if(in[1][i] == 0) data[1][i] = 1;\n\n    solve();\n    // print();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n\nint main(){\n\tint kosu[2][20][20],x,y,c,i,j;\n\t\n\twhile(~scanf(\"%d%d\",&x,&y)){\n\t\tif(x==0&&y==0)break;\n\t\tmemset(kosu,0,sizeof(kosu));\n\t\tfor(i=1;i<=y;i++){\n\t\t\tfor(j=1;j<=x;j++){\n\t\t\t\tscanf(\"%d\",&c);\n\t\t\t\tkosu[1][i][j]=c;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(i=1;i<=x;i++){\n\t\t\tif(kosu[1][1][i]==0)kosu[0][1][i]=1;\n\t\t}\n\t\t\n\t\tfor(i=2;i<y;i++){\n\t\t\tfor(j=1;j<=x;j++){\n\t\t\t\tif(kosu[1][i][j]==1)continue;\n\t\t\t\tif(kosu[1][i-2][j]==2)kosu[0][i][j]+=kosu[0][i-2][j];\n\t\t\t\tif(kosu[1][i][j]==2){\n\t\t\t\t\tkosu[0][i][j]+=kosu[0][i-1][j];\n\t\t\t\t}else{\n\t\t\t\t\tkosu[0][i][j]+=((kosu[1][i-1][j-1]==2?0:kosu[0][i-1][j-1])+(kosu[1][i-1][j]==2?0:kosu[0][i-1][j])+(kosu[1][i-1][j+1]==2?0:kosu[0][i-1][j+1]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(y==1){\n\t\t\tj=0;\n\t\t\tfor(i=1;i<=x;i++){\n\t\t\t\tj+=kosu[0][y][i];\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",j);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tfor(j=1;j<=x;j++){\n\t\t\tif(kosu[1][y-1][j]==2)kosu[0][y][j]+=kosu[0][y-1][j];\n\t\t\tif(kosu[1][y][j]!=1 && kosu[1][y-2][j]==2)kosu[0][y][j]+=kosu[0][y-2][j];\n\t\t\tif(kosu[1][y][j]==1)continue;\n\t\t\tif(kosu[1][y][j]==2){\n\t\t\t\tkosu[0][y][j]+=kosu[0][y-1][j];\n\t\t\t}else{\n\t\t\t\tkosu[0][y][j]+=((kosu[1][y-1][j-1]==2?0:kosu[0][y-1][j-1])+(kosu[1][y-1][j]==2?0:kosu[0][y-1][j])+(kosu[1][y-1][j+1]==2?0:kosu[0][y-1][j+1]));\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tj=0;\n\t\tfor(i=1;i<=x;i++){\n\t\t\tj+=kosu[0][y][i];\n\t\t}\n\t\tprintf(\"%d\\n\",j);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint main(){\n    int x, y;\n    while(1){\n        cin >> x >> y;\n        if(x == 0 && y == 0)    break;\n    \n        int dp[y+2][x];\n        char mat[y+2][x];\n        for(int i = 0; i < y+2; i++){\n            for(int j = 0; j < x; j++){\n                dp[i][j] = 0;\n                mat[i][j] = '0';\n            }\n        }\n\n        for(int i = 0; i < y; i++){\n            for(int j = 0; j < x; j++){\n                cin >> mat[i][j];\n            }\n        }\n\n        for(int j = 0; j < x; j++){\n            if(mat[0][j] == '0')    dp[0][j] = 1;\n        }\n\n        for(int i = 0; i < y-1; i++){\n            for(int j = 0; j < x; j++){\n                if(mat[i][j] == '0'){\n                    if(j != 0 && mat[i+1][j-1] == '0')      dp[i+1][j-1] += dp[i][j];\n                    if(mat[i+1][j] != '1')                  dp[i+1][j] += dp[i][j];\n                    if(j != x-1 && mat[i+1][j+1] == '0')    dp[i+1][j+1] += dp[i][j];\n                }else if(mat[i][j] == '1'){\n                    // do nothing.\n                }else if(mat[i][j] == '2'){\n                    dp[i+2][j] += dp[i][j];\n                }\n            }\n        }\n\n        int accum = 0;\n        for(int j = 0; j < x; j++)  if(mat[y-1][j] != '1')  accum += dp[y-1][j];\n        for(int j = 0; j < x; j++)  accum += dp[y][j];\n        cout << accum << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// 0203\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main(){\n\twhile(1){\n\t\tint X, Y, c;\n\t\tvector<vector<int> > grid, count;\n\t\n\t\tcin>>X>>Y;\n\t\tif((X == 0) && (Y == 0))\n\t\t\tbreak;\n\n\t\tgrid.resize(X+2);\n\t\tfor(int i=0;i<X+2;i++)\n\t\t\tgrid[i].resize(Y+2);\n\n\t\tfor(int j=0;j<Y+2;j++){\n\t\t\tfor(int i=0;i<X+2;i++){\n\t\t\t\tif((i == 0) || (i == X+1) || (j == 0) || (j == Y+1)){\n\t\t\t\t\tgrid[i][j] = 1;\n\t\t\t\t}else{\n\t\t\t\t\tcin>>c;\n\t\t\t\t\tgrid[i][j] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcount.resize(X+2);\n\t\tfor(int i=0;i<X+2;i++)\n\t\t\tcount[i].resize(Y+2);\n\n\t\tfor(int i=0;i<X+2;i++)\n\t\t\tfor(int j=0;j<Y+2;j++)\n\t\t\t\tcount[i][j] = 0;\n\n\t\tfor(int i=1;i<=X;i++)\n\t\t\tif(grid[i][1] == 0)\n\t\t\t\tcount[i][1]++;\n\n\t\tfor(int j=2;j<=Y;j++){\n\t\t\tfor(int i=1;i<=X;i++){\n\t\t\t\tif(grid[i][j] == 1){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(grid[i][j] == 2){\n\t\t\t\t\tcount[i][j] += count[i][j-1];\n\t\t\t\t\tif(grid[i][j-2] == 2)\n\t\t\t\t\t\tcount[i][j] += count[i][j-2];\n\t\t\t\t}else{\n\t\t\t\t\tfor(int k=-1;k<=1;k++)\n\t\t\t\t\t\tif(grid[i+k][j-1] != 2)\n\t\t\t\t\t\t\tcount[i][j] += count[i+k][j-1];\n\t\t\t\t\tif(grid[i][j-2] == 2)\n\t\t\t\t\t\tcount[i][j] += count[i][j-2];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor(int i=1;i<=X;i++){\n\t\t\tans += count[i][Y];\n\t\t\tif(grid[i][Y-1] == 2)\n\t\t\t\tans += count[i][Y-1];\n\t\t}\n\t\t\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint maps[20][20];\nint course[20][20];\nint X, Y;\n\nvoid out();\nint way(int y, int x){\n  if(y >= Y) return 1;\n  else if(course[y][x] > 0) return course[y][x];\n  else if(maps[y][x] == 1) return 0;\n  else if(maps[y][x] == 2 && maps[y + 2][x] != 1) return course[y][x] = way(y + 2, x);\n  else{\n    int SUM = 0;\n    for(int i = 0; i < 3; i++){\n      int ny = y + 1;\n      int nx = x - 1 + i;\n      if(maps[ny][nx] != 1 && 1 <= nx && nx <= X){\n\tint flug = 1;\n\tif(i != 1 && maps[ny][nx] == 2) flug = 0;\n\tif(flug) SUM += way(ny, nx);\n      }\n    }\n    return course[y][x] = SUM;\n  }\n} \n\nint main(){\n  while(1){\n    cin >> X >> Y;\n    if(X == 0 && Y == 0) break;\n    for(int i = 1; i <= Y; i++){\n      for(int j = 1; j <= X; j++){\n\tcin >> maps[i][j];\n\tcourse[i][j] = 0;\n      }\n    }\n    int cnt = 0;\n    for(int i = 1; i <= X; i++){\n      if(maps[0][i] != 1) cnt += way(1, i);\n    }\n    //out();\n    cout << cnt << endl;\n  }\n}\n\nvoid out(){\n  for(int i = 1; i <= Y; i++){\n    for(int j = 1; j <= X; j++){\n      cout << course[i][j] << \" \";\n    }\n    cout << endl;\n  }\n  return;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#define N 15\nusing namespace std;\nvoid func(int,int);\nint jump(int,int);\nint X,Y,data[N][N],memo[N+2][N];\nint main(){\n  while(1){\n    cin >> X >> Y;\n    if(X==0&&Y==0) break;\n    for(int i=0;i<Y+2;i++)\n      for(int j=0;j<X;j++) data[i][j]=0,memo[i][j]=0;\n    for(int i=0;i<Y;i++)\n      for(int j=0;j<X;j++) cin >> data[i][j];\n    for(int i=0;i<X;i++)\n      if(data[0][i]!=1)\tfunc(0,i);\n    int cnt=0;\n    for(int i=0;i<X;i++) cnt+=memo[0][i];\n    cout << cnt << endl;\n  }\n  return 0;\n}\nvoid func(int y,int x){\n  if(y>=Y-1){\n    memo[y][x]=memo[Y][x]=memo[Y-1][x]=1;\n    return ;\n  }\n  if(0<=x-1&&data[y+1][x-1]==0){\n    if(memo[y+1][x-1]==0) func(y+1,x-1);\n    memo[y][x]+=memo[y+1][x-1];\n  }\n  if(x+1<X&&data[y+1][x+1]==0){\n    if(memo[y+1][x+1]==0) func(y+1,x+1);\n    memo[y][x]+=memo[y+1][x+1];\n  }\n  if(data[y+1][x]==0){\n    if(memo[y+1][x]==0) func(y+1,x);\n    memo[y][x]+=memo[y+1][x];\n  }\n  if(data[y+1][x]==2){\n    int r=jump(y+1,x);\n    if(r!=-1){\n      if(memo[r][x]==0) func(r,x);\n      memo[y][x]+=memo[r][x];\n    }else data[y+1][x]=1;\n  }\n  if(memo[y][x]==0) data[y][x]=1;\n}\nint jump(int y,int x){\n  while(1){\n    y+=2;\n    if(data[y][x]==1) break;\n    if(data[y][x]==0||y>=Y-1) return y;\n  }\n  return -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n \nint main(){\n        int x,y;\n        while(cin>>x>>y,x){\n                int D[16][16],P[16][16],ans=0;\n                for(int i=0;i<256;i++)P[i/16][i%16]=0;\n                for(int i=0;i<y;i++)for(int j=0;j<x;j++)cin>>D[i][j];\n                for(int i=0;i<x;i++)if(!D[0][i])P[0][i]=1;\n                for(int i=0;i<y-1;i++){\n                        for(int j=0;j<x;j++){\n                                if(!D[i][j]){\n                                        if (D[i + 1][j] != 1) P[i+1][j]+=P[i][j];\n                                        if(j>0 && !D[i + 1][j - 1])P[i+1][j-1]+=P[i][j];\n                                        if(j<x-1 && !D[i + 1][j + 1])P[i+1][j+1]+=P[i][j];\n                                }\n                                if(D[i][j]==2){\n                                        if(i+2>y-1)P[i+1][j]+=P[i][j];\n                                        else P[i+2][j]+=P[i][j];\n                                }\n                        }\n                }\n                for(int i=0;i<x;i++)ans+=P[y-1][i];\n                cout<<ans<<endl;\n        }\n}\n "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\n#define MAX 20\n\nint W,H;\nint arr[MAX][MAX];\nint dp[MAX][MAX];\nconst int dx[] = {-1,0,1};\nconst int dy[] = {1,1,1};\n\nbool inField(int y,int x){\n  return 0 <= y && y < H && 0 <= x && x < W;\n}\n\nint solve(int y,int x){\n  if(y == H-1){\n    if(arr[y][x] == 0 || arr[y][x] == 2){\n      return 1;\n    }else{\n      return 0;\n    }\n  }\n  if(dp[y][x] != -1) return dp[y][x];\n\n  int res = 0;\n  if(arr[y][x] != 2){\n    for(int i = 0 ; i < 3 ; i++){\n      int nx = x + dx[i];\n      int ny = y + dy[i];\n      if(!inField(ny,nx)) continue;\n      if(arr[ny][nx] == 1) continue;\n      if(arr[ny][nx] == 0){\n        res += solve(ny,nx);\n      }else{\n        if(x == nx){\n          res += solve(ny,nx);\n        }\n      }\n    }\n  }else{\n    int nx = x, ny = y + 2;\n    if(!inField(ny,nx)) return 1;\n    if(arr[ny][nx] == 1) return 0;\n    res += solve(ny,nx);\n  }\n  return dp[y][x] = res;\n}\n\nint main(){\n  while(cin >> W >> H, (W | H)){\n    for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n        cin >> arr[i][j];\n        dp[i][j] = -1;\n      }\n    }\n    int res = 0;\n    for(int i = 0 ; i < W ; i++){\n      if(arr[0][i] == 0){\n        res += solve(0,i);\n      }\n    }\n    cout << res << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\n#define MAX 17\n#define f first\n#define s second\ntypedef pair<int, int> P;\n\nunsigned long long ans;\nint X, Y;\nint field[MAX][MAX];\nint dp[MAX][MAX];\n\nint solve(){\n  for(int i = 0 ; i < Y ; i++){\n    for(int j = 0 ; j <= X ; j++){\n      if(field[i][j] == 0){\n\tfor(int dx = -1 ; dx <= 1 ; dx++){\n\t  int ny = i+1, nx = j+dx;\n\t  if(nx < 0 || nx > X) continue;\n\t  if(field[ny][nx] == 1) continue;\n\t  if(field[ny][nx] == 2 && field[ny+2][nx] == 1) continue;\n\t  if(field[ny][nx] == 2 && dx != 0) continue;\n\t  dp[ny][nx] += dp[i][j];\n\t}\n      }\n      else if(field[i][j] == 2 && field[i-2][j] != 2) dp[i][j] = dp[i-1][j];\n      if(field[i][j] == 2 && field[i+2][j] != 1){\n\tdp[i+2][j] += dp[i][j];\n      }\n    }\n  }\n  \n  int res = 0;\n  for(int i = 0 ; i <= X ; i++){\n    res += dp[Y][i] + dp[Y+1][i];\n  }\n  return res;\n}\n\nvoid init(){\n  memset(dp, 0, sizeof(dp));\n  for(int i = 0 ; i <= X ; i++){\n    if(field[0][i] == 0) dp[0][i] = 1;\n  }\n}\n\nint main(){\n  while(cin >> X >> Y, X && Y) {\n    X--, Y--;\n    for(int i = 0 ; i <= Y ; i++) {\n      for(int j = 0 ; j <= X ; j++) {\n\tcin >> field[i][j];\n      }\n    }\n    \n    init();\n    cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 16\n\nint main()\n{\n    int H, W;\n    while (cin >> W >> H, W) {\n        vector<vector<int>> a(H, vector<int>(W));\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                cin >> a[i][j];\n            }\n        }\n        int dp[MAX][MAX] = {{}};\n        for (int i = 0; i < W; i++) {\n            dp[0][i] = (a[0][i] == 0);\n        }\n\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (dp[i][j] == 0 || a[i][j] == 1) continue;\n                if (a[i][j] == 2) {\n                    int ni = min(i + 2, H);\n                    if (ni < H && a[ni][j] == 1) continue;\n                    dp[ni][j] += dp[i][j];\n                } else {\n                    if (i + 1 == H) continue;\n                    for (int k = -1; k <= 1; k++) {\n                        int ni = i + 1;\n                        int nj = j + k;\n                        if (nj < 0 || nj >= W) continue;\n                        if (a[ni][nj] == 1) continue;\n                        if (a[ni][nj] == 2 && j != nj) continue;\n                        dp[ni][nj] += dp[i][j];\n                    }\n                }\n            }\n        }\n        int res = 0;\n        for (int i = 0; i < W; i++) {\n            res += dp[H-1][i] + dp[H][i];\n        }\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint main() {\n\tint width, height, m[15][15];\n\twhile (cin >> width >> height, width || height) {\n\t\tfor (int y = 0; y < height; ++y)\n\t\t\tfor (int x = 0; x < width; ++x)\n\t\t\t\tcin >> m[y][x];\n\n\t\tint sum = 0, pattern[15][15] = {0};\n\t\tfor (int x = 0; x < width; ++x)\n\t\t\tpattern[0][x] = 1;\n\n\t\tfor (int y = 0; y < height-1; ++y)\n\t\t\tfor (int x = 0; x < width; ++x)\n\t\t\t\tif (m[y][x] == 0) {\n\t\t\t\t\tif (x - 1 >= 0) { if (m[y+1][x-1] == 0) pattern[y+1][x-1] += pattern[y][x]; }\n\t\t\t\t\tif (x + 1 < width) { if (m[y+1][x+1] == 0) pattern[y+1][x+1] += pattern[y][x]; }\n\t\t\t\t\tif (m[y+1][x] != 1) pattern[y+1][x] += pattern[y][x];\n\t\t\t\t}\n\t\t\t\telse if (m[y][x] == 2) {\n\t\t\t\t\tif (y + 2 == height) sum += pattern[y][x];\n\t\t\t\t\telse if (m[y+2][x] != 1) pattern[y+2][x] += pattern[y][x];\n\t\t\t\t};\n\n\t\tfor (int x = 0; x < width; ++x)\n\t\t\tsum += pattern[width-1][x];\n\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint field[16][16];\n// y,xÌ}X©çènßÄÅ«é·×èûÌ\nint dp[16][16];\n\nconst int dy[]={1,1,1};\nconst int dx[]={-1,0,1};\nint w,h;\n\nint search(int sx,int sy){\n\tif(field[sy][sx]==2){\n\t\tif(sy>=h-2){\n\t\t\treturn 1;\n\t\t}\n\t\telse if(field[sy+2][sx]==1)\n\t\t\treturn 0;\n\t\telse{\n\t\t\treturn search(sx,sy+2);\n\t\t}\n\t}\n\tif(dp[sy][sx]!=-1){\n\t\treturn dp[sy][sx];\n\t}\n\tint cnt=0;\n\n\tif(sy!=h-1){\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tint nx=sx+dx[i];\n\t\t\tint ny=sy+dy[i];\n\t\t\tif(nx>=0&&nx<w){\n\t\t\t\tif(ny>h-1){\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t\telse if(ny==h-1&&field[ny][nx]==0){\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t\telse if(field[ny][nx]==2&&dx[i]==0){\n\t\t\t\t\tcnt+=search(nx,ny);\n\t\t\t\t}\n\t\t\t\telse if(field[ny][nx]==0){\n\t\t\t\t\tcnt+=search(nx,ny);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse{\n\t\tif(field[sy][sx]==0)\n\t\t\tcnt++;\n\t}\n\n\tdp[sy][sx]=cnt;\n\treturn dp[sy][sx];\n}\n\n\nint main(){\n\n\twhile(cin>>w>>h&&!(w==0&&h==0)){\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tdp[i][j]=-1;\n\t\t\t}\n\t\t}\n\t\tint sum=0;\n\t\tfor(int i = 0; i < w; i++){\n\t\t\tif(field[0][i]==0)\n\t\t\t\tsum+=search(i,0);\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<queue>\n#include<functional>\n#include<cstring>\n#include<vector>\n#include<climits>\n#include<map>\nusing namespace std;\n#define FOR(i,n) for(int i=0;i<(int)n;i++)\n#define FORI(i,k,n) for(int i=k;i<(int)n;i++)\n#define ALL(x) (x).begin(),(x).end()\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define int long long\n\nmain()\n{\n\twhile(1)\n\t{\n\t\tint a[20][20];\n\t\tint dp[20][20]={};\n\t\tint x,y;\n\t\t\n\t\tcin>>x>>y;if(!x)break;\n\t\tFOR(i,20)FOR(j,20)a[i][j]=1;\n\t\tFORI(i,1,y+1)\n\t\t{\n\t\t\tFORI(j,1,x+1)\n\t\t\t{\n\t\t\t\tcin>>a[i][j];\n\t\t\t}\n\t\t}\n\t\tFORI(i,1,x+1)\n\t\t{\n\t\t\tif(a[1][i]==0)dp[1][i]=1;\n\t\t\ta[y+1][i]=0;\n\t\t}\n\t\tFORI(i,1,y)\n\t\t{\n\t\t\tFORI(j,1,x+1)\n\t\t\t{\n\t\t\t\tif(a[i][j]==2&&a[i+2][j]!=1)\n\t\t\t\t{\n\t\t\t\t\tdp[i+2][j]+=dp[i][j];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfor(int k=-1;k<=1;k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(a[i+1][j+k]==0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdp[i+1][j+k]+=dp[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(a[i+1][j]==2)dp[i+1][j]+=dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans=0;\n\t\tFORI(i,1,x+1)ans+=dp[y][i]+dp[y+1][i];\n\t\tcout<<ans<<endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\n\nint dp[17][17];\nint map[17][17];\nint y,x;\n\nlong long int check(int i,int j)\n{\n  if(j>=x||j<0)\n    return 0;\n  if(i>=y)\n    return 1;\n\n  if(map[i][j]==1)\n    return 0;\n\n  if(dp[i][j]!=-1)\n    return dp[i][j];\n\n  long long int sum=0; \n  if(i>=y-1)\n    sum=1;\n  else if(map[i][j]==2)\n    sum=check(i+2,j);\n  else\n    {\n      if(j-1>=0 && map[i+1][j-1]==0)\n\tsum+=check(i+1,j-1);\n      sum+=check(i+1,j);\n      if(j+1<x && map[i+1][j+1]==0)\n\tsum+=check(i+1,j+1);\n    }\n    \n\n  // cout<<i<<\" \"<<j<<\" \" <<sum<<endl;\n  dp[i][j]=sum;\n  return sum;\n}\n\nint main()\n{\n  for(;cin>>x>>y,x;)\n    {\n      memset(dp,-1,sizeof(dp));\n      memset(map,0,sizeof(map));\n      for(int i=0;i<y;i++)\n\tfor(int j=0;j<x;j++)\n\t  {\n\t    cin>>map[i][j];\n\t  }\n      long long int ans=0;\n      for(int i=0;i<x;i++)\n\tans+=check(0,i);\n      cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint w,h,xd[]={1,0,-1},p,u[20][20],d[20][20];\nint ret(int x,int y){\n\tint s=x,sum=0;\n\tif(h-1<=y){\n\t\treturn 1;\n\t}\n\tif(d[y][x]>=1)\n\treturn d[y][x];\n\telse if(u[y][x]==2)\n\t\treturn d[y][x]=ret(x,y+2);\n\telse if(u[y][x]==0){\n\t\ty++;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tx=s+xd[i];\n\t\t\tif(x>=0&&x<=w-1){\n\t\t\t\tif(u[y][x]==2&&i==1)\n\t\t\t\t\tsum+=d[y-1][s]=ret(x,y+2);\n\t\t\t\telse if(u[y][x]==0)\n\t\t\t\t\tsum+=d[y-1][s]=ret(x,y);\n\t\t\t}\n\t\t}\n\t\treturn d[y-1][s]=sum;\n\t}\n\treturn d[y][s]=-1;\n}\nint main(){\n\tint x,y;\n\twhile(cin>>w>>h,w||h){\n\t\tp=0;\n\t\tfor(int i=0;i<h;i++)\n\t\tfor(int j=0;j<w;j++){\n\t\t\tcin>>u[i][j];\n\t\t\td[i][j]=0;\n\t\t}\n\t\tfor(int i=0;i<w;i++){\n\t\t\tif(u[0][i]==0){\n\t\t\t\tx=i;\n\t\t\t\ty=0;\n\t\t\t\tp+=ret(x,y);\n\t\t\t}\n\t\t\telse if(u[0][i]==2){\n\t\t\t\tx=i;\n\t\t\t\ty=2;\n\t\t\t\tp+=ret(x,y);\n\t\t\t}\n\t\t}\n\t\tcout<<p<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <functional>\n#include <numeric>\n#define fi first\n#define se second\nusing namespace std;\nbool value(int y,int x,int R,int C){return 0<=y&&y<R&&0<=x&&x<C;}\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<long long > vll;\ntypedef vector< vi > vvi;\ndouble pie=acos(-1);\nint INF=10000009;\nint dx[4] = { 0,-1,0,1 };\nint dy[4] = { -1,0,1,0 };\nint c[20][20];\nlong long int dp[20][20];\nint main() {\n\tint X,Y;\n\twhile(true){\n\t\tlong long int ans=0;\n\t\tcin>>X>>Y;\n\t\tif(X+Y==0) break;\n\t\tfor(int i=1;i<=Y;i++){\n\t\t\tfor(int j=1;j<=X;j++){\n\t\t\t\tcin>>c[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=X;i++){\n\t\t\tif(c[1][i]==1){\n\t\t\t\tdp[1][i]=0;\n\t\t\t}\n\t\t\tif(c[1][i]==0){\n\t\t\t\tdp[1][i]=1;\n\t\t\t}\n\t\t\tif(c[1][i]==2){\n\t\t\t\tdp[1][i]=1;\n\t\t\t\tdp[3][i]=1;\n\t\t\t}\n\t\t}\n\t\tfor(int i=2;i<=Y;i++){\n\t\t\tfor(int j=1;j<=X;j++){\n\t\t\t\tif(c[i][j]==1) dp[i][j]=0;\n\t\t\t\telse if(c[i][j]==0){\n\t\t\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\t\t\tif(c[i-1][j-1+k]!=2){\n\t\t\t\t\t\t\tdp[i][j]+=dp[i-1][j-1+k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(c[i-1][j]!=2){\n\t\t\t\t\t\tdp[i][j]+=dp[i-1][j];\n\t\t\t\t\t}\n\t\t\t\t\tdp[i+2][j]+=dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=Y;i<=Y+2;i++){\n\t\t\tfor(int j=1;j<=X;j++){\n\t\t\t\tans+=dp[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=Y+1;i++){\n\t\t\tfor(int j=1;j<=X;j++){\n\t\t\t\tdp[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\n\nusing namespace std;\n\n\n\tint n,m;\n\tint masu[17][17];\n\tint ura[17][17];\n\t\nint motom(){\n\t\tfor(int i=0;i<17;i++){\n\t\t\tfor(int j=0;j<17;j++){\n\t\t\t\tmasu[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tswitch(ura[1][i]){\n\t\t\t\tcase 0:masu[1][i]+=1;break;\n\t\t\t\tcase 1:masu[1][i]+=0;break;\n\t\t\t\tcase 2:masu[1][i]+=1;break;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfor(int j=1;j<=m;j++){\n\t\t\t\tif(ura[i][j]==0){\n\t\t\t\t\tif(ura[i+1][j-1]==0){\n\t\t\t\t\t\tmasu[i+1][j-1]+=masu[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tif(ura[i+1][j]!=1){\n\t\t\t\t\t\tmasu[i+1][j]+=masu[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tif(ura[i+1][j+1]==0){\n\t\t\t\t\t\tmasu[i+1][j+1]+=masu[i][j];\n\t\t\t\t\t}\n\t\t\t\t}else if(ura[i][j]==2){\n\t\t\t\t\tif(ura[i+2][j]!=1){\n\t\t\t\t\t\tmasu[i+2][j]+=masu[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cont=0;\n\t\tfor(int i=n;i<=n+1;i++){\n\t\t\tfor(int j=1;j<=m;j++){\n\t\t\t\tcont+=masu[i][j];\n\t\t\t}\n\t\t}\n\t\treturn cont;\n}\n\nint main(){\n\tsrand(time(NULL));\n\tint cc=0;\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0 && m==0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i=0;i<17;i++){\n\t\t\tfor(int j=0;j<17;j++){\n\t\t\t\tmasu[i][j]=0;\n\t\t\t\tura[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=1;j<=m;j++){\n\t\t\t\tscanf(\"%d\",&ura[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",motom());\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint fld[17][17];\nint cnt[17][17];\n\nint main()\n{\n\tint X,Y,S;\n\twhile(cin >> X >> Y, (X||Y))\n\t{\n\t\tfor(int y=0; y<17; y++)\n\t\tfor(int x=0; x<17; x++)\n\t\t{\n\t\t\tfld[y][x] = 3;\n\t\t\tcnt[y][x] = 0;\n\t\t}\n\n\t\tfor(int y=0; y< Y; y++)\n\t\tfor(int x=1; x<=X; x++)\n\t\t{\n\t\t\tcin >> fld[y][x];\n\t\t\tcnt[y][x] = ((y==0&&fld[y][x]==0)?1:0);\n\t\t}\n\n\t\tfor(int y=0; y< Y-1; y++)\n\t\tfor(int x=1; x<=X  ; x++)\n\t\t{\n\t\t\tif(fld[y][x]==0)\n\t\t\t{\n\t\t\t\tif(fld[y+1][x+1]==0) cnt[y+1][x+1]+=cnt[y][x];\n\t\t\t\tif(fld[y+1][x-1]==0) cnt[y+1][x-1]+=cnt[y][x];\n\t\t\t\tif(fld[y+1][x  ]!=1) cnt[y+1][x  ]+=cnt[y][x]; \n\t\t\t}\n\t\t\tif(fld[y][x]==2&&fld[y+2][x]!=1)\n\t\t\t{\n\t\t\t\tcnt[y+2][x]+=cnt[y][x];\n\t\t\t}\n\t\t}\n\n\t\tS=0;\n\t\tfor(int y=Y-1; y< Y+2; y++)\n\t\tfor(int x=1  ; x<=X  ; x++)\n\t\t{\n\t\t\tS+=cnt[y][x];\n\t\t}\n\n\t\tcout << S << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MP make_pair\n#define PB push_back\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define REP(i,n) for (int i=0;i<(n);i++)\nint X,Y;\nint fld[15][15];\nint dp[15][15];\nint main() {\n\twhile(cin>>X>>Y&&X&&Y){\n\t\tfor(int i=0;i<Y;i++)for(int j=0;j<X;j++)cin>>fld[j][i];\n\t\tint ans=0;\n\t\tfor(int i=0;i<X;i++)if(fld[i][Y-1]!=1)dp[i][Y-1]=1;\n\t\tfor(int y=Y-2;y>=0;y--){\n\t\t\tfor(int x=0;x<X;x++){\n\t\t\t\tif(fld[x][y]==0){\n\t\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\t\tint nx=x+k;\n\t\t\t\t\t\tif(nx<0||nx>=X)continue;\n\t\t\t\t\t\tif(nx==x&&fld[nx][y+1]!=1)dp[x][y]+=dp[nx][y+1];\n\t\t\t\t\t\telse if(fld[nx][y+1]==0)dp[x][y]+=dp[nx][y+1];\n\t\t\t\t\t}\n\t\t\t\t}else if(fld[x][y]==2){\n\t\t\t\t\tif(y+2>=Y)dp[x][y]=1;\n\t\t\t\t\telse dp[x][y]=dp[x][y+2];\n\t\t\t\t}\n\t\t\t\tif(y==0)ans+=dp[x][y];\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\nint a[16][16];\nint count = 0;\nint n,m;\n\nvoid dfs(int y,int x)\n{\n\tif(a[y][x] == 0)\n\t{\n\n\t\tif(y == m-1)\n\t\t{\n\t\t\tcount++;\n\t\t\treturn;\n\t\t}\n\t\tif(x-1 >= 0 && y+1 < m)\n\t\t{\n\t\t\tif(a[y+1][x-1] != 2)\n\t\t\t{\n\t\t\t\tdfs(y+1,x-1);\n\t\t\t}\n\t\t}\n\t\tif(y+1 < m)\n\t\t{\n\t\t\tdfs(y+1,x);\n\t\t}\n\t\tif(x+1 < n && y+1 < m)\n\t\t{\n\t\t\tif(a[y+1][x+1] != 2)\n\t\t\t{\n\t\t\t\tdfs(y+1,x+1);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\telse if(a[y][x] == 1)\n\t{\n\t\treturn;\n\t}\n\telse if(a[y][x] == 2)\n\t{\n\t\tif(y == m-2 || y == m-1)\n\t\t{\n\t\t\tcount++;\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdfs(y+2,x);\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile(cin >> n >> m)\n\t{\n\t\tif(n == 0 && m == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tmemset(a,0,sizeof(a));\n\t\trep(i,m)\n\t\t{\n\t\t\trep(j,n)\n\t\t\t{\n\t\t\t\tcin >> a[i][j];\n\t\t\t}\n\t\t}\n\t\tcount = 0;\n\t\trep(i,n) dfs(0,i);\n\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\nusing namespace std;\n\nint main(){\n\tint x,y;\n\twhile(1){\n\t\tcin>>x>>y;\n\t\tif(!(x||y))break;\n\t\tint status[y][x],dp[y][x];\n\t\trep(i,y){\n\t\t\trep(j,x){\n\t\t\t\tcin>>status[i][j];\n\t\t\t}\n\t\t}\n\t\tint sum=0;\n\t\trep(i,y){\n\t\t\trep(j,x){\n\t\t\t\tif(i==0 && status[i][j]!=1)dp[i][j]=1;\n\t\t\t\telse dp[i][j]=0;\n\t\t\t}\n\t\t}\n\t\trep(i,y){\n\t\t\trep(j,x){\n\t\t\t\tif(status[i][j]==1)continue;\n\t\t\t\tif(status[i][j]==2){\n\t\t\t\t\tif(i>=y-2)sum+=dp[i][j];\n\t\t\t\t\telse dp[i+2][j]+=dp[i][j];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(i==y-1)sum+=dp[i][j];\n\t\t\t\telse{\n\t\t\t\t\tif(j==0){\n\t\t\t\t\t\tif(status[i+1][j]!=1)dp[i+1][j]+=dp[i][j];\n\t\t\t\t\t\tif(status[i+1][j+1]==0)dp[i+1][j+1]+=dp[i][j];\n\t\t\t\t\t}else if(j==x-1){\n\t\t\t\t\t\tif(status[i+1][j]!=1)dp[i+1][j]+=dp[i][j];\n\t\t\t\t\t\tif(status[i+1][j-1]==0)dp[i+1][j-1]+=dp[i][j];\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(status[i+1][j]!=1)dp[i+1][j]+=dp[i][j];\n\t\t\t\t\t\tif(status[i+1][j+1]==0)dp[i+1][j+1]+=dp[i][j];\n\t\t\t\t\t\tif(status[i+1][j-1]==0)dp[i+1][j-1]+=dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint dp[18][18];\nint kosu[16][16];\nint ans;\n\nint main(){\n  int x,y;\n  \n  while(1){\n    cin>>x>>y;\n    if(x==0 && y==0) break;\n    \n    fill(dp[0],dp[18],0);\n    ans=0;\n    \n    for(int i=0;i<y;i++){\n      for(int l=0;l<x;l++){\n        cin>>kosu[i][l];\n      }\n    }\n    for(int i=0;i<x;i++)\n      if(kosu[0][i]==0) dp[0][i]=1;\n    \n    for(int i=1;i<y;i++){\n      for(int l=0;l<x;l++){\n        \n        if(kosu[i][l]==2){\n          dp[i+2][l]=dp[i-1][l]+dp[i-2][l]+dp[i][l];\n          dp[i][l]=0;\n        }\n        else if(kosu[i][l]==0)\n          dp[i][l]+=dp[i-1][l-1]+dp[i-1][l]+dp[i-1][l+1];\n      }\n    }\n    \n    for(int i=y;i<y+2;i++){\n      for(int l=0;l<x;l++){\n        dp[i][l]+=dp[i-1][l];\n      }\n    }\n    for(int i=0;i<x;i++)\n      ans+=dp[y+1][i];\n    \n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint X,Y;\nint dp[20][20];\nchar maps[20][20];\nint bun(int x,int y);\nint dx[3]={-1,0,1};\nmain(){\n  while(1){\n    cin>>X>>Y;\n    if(X==0&&Y==0){\n      break;\n    }\n    for(int i=1;i<=Y;i++){\n      for(int j=1;j<=X;j++){\n\tcin>>maps[i][j];\n\tdp[i][j]=0;\n      }\n    }\n    int ans=0;\n    for(int i=1;i<=X;i++){\n      if(maps[1][i]!='1'){\n\tans+=bun(1,i);\n      }\n    }\n    cout<<ans<<endl;\n  }\n}\nint bun(int y,int x){\n  if(y>=Y+1){\n    return 1;\n  }\n  else if(dp[y][x]!=0){\n    return dp[y][x];\n  }\n  else if(maps[y][x]=='2'&&(y+2>=Y+1||maps[y+2][x]!='1')){\n    return bun(y+2,x);\n  }\n  else if(maps[y][x]=='1'){\n    return 0;\n  }\n  else{\n    int anss=0;\n    for(int i=0;i<3;i++){\n      int nx=x+dx[i];\n      if(i!=1){\n\tif(nx>0&&nx<=X&&maps[y+1][nx]=='0'){\n\t  anss+=bun(y+1,nx);\n\t}\n      }\n      else{\n\tif(maps[y+1][nx]!='1'){\n\t  anss+=bun(y+1,nx);\n\t}\n      }\n    }\n    return dp[y][x]=anss;\n  }\t  \t  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <iomanip>\nusing namespace std;\nint main(){\n\tint x,y;\n\twhile(1){\n\t\tcin >> x >> y;\n\t\tif(x+y==0) break;\n\t\tint a[x][y];\n\t\tfor(int j=0;j<y;j++) for(int i=0;i<x;i++) cin >> a[i][j];\n\t\tint d[x][y];\n\t\tfor(int i=0;i<x;i++) d[i][0] = 1 - a[i][0];\n\t\tfor(int j=1;j<y;j++){\n\t\t\tfor(int i=0;i<x;i++){\n\t\t\t\tif(a[i][j]==1) d[i][j] = 0;\n\t\t\t\telse if(a[i][j]==0){\n\t\t\t\t\tif(a[i][j-1]!=2) d[i][j] = d[i][j-1];\n\t\t\t\t\tif(i>0 and a[i-1][j-1]!=2) d[i][j] += d[i-1][j-1];\n\t\t\t\t\tif(i<x-1 and a[i+1][j-1]!=2) d[i][j] += d[i+1][j-1];\n\t\t\t\t\tif(j>1 and a[i][j-2]==2) d[i][j] += d[i][j-2];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\td[i][j] = d[i][j-1];\n\t\t\t\t\tif(j>1 and a[i][j-2]==2) d[i][j] += d[i][j-2];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint s = 0;\n\t\tfor(int i=0;i<x;i++){\n\t\t\tif(y>2 and a[i][y-2]==2) s += d[i][y-2];\n\t\t\ts += d[i][y-1];\n\t\t}\n\t\tcout << s << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1; } return 0; }\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, pll> pip;\nconst ll INF = 1ll<<29;\nconst ll MOD = 1000000007;\nconst double EPS  = 1e-9;\n\nint H, W;\nint maps[15][15];\nll dp[15][15];\n\nint dx[3] = {1,0,-1}, dy[3] = {1,1,1};\n\nint main() {\n\twhile (cin >> W >> H, H || W) {\n\t\tREP(i, H) REP(j, W) scanf(\"%d\", &maps[i][j]);\n\t\t\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tREP(j, W) dp[0][j] = maps[0][j] != 1;\n\t\t\n\t\tREP(i, H - 1) REP(j, W) if (dp[i][j]) {\n\t\t\t\n\t\t\tif (maps[i][j] == 2) { // jump\n\t\t\t\tif (i + 2 < H && maps[i + 2][j] == 1) continue;\n\t\t\t\tdp[min(i + 2, H - 1)][j] += dp[i][j];\n\t\t\t}\n\t\t\telse { // normal\n\t\t\t\tREP(k, 3) {\n\t\t\t\t\tint yy = i + dy[k], xx = j + dx[k];\n\t\t\t\t\tif (!(yy >= 0 && yy < H && xx >= 0 && xx < W)) continue;\n\t\t\t\t\tif (maps[yy][xx] == 1 || (k != 1 && maps[yy][xx] == 2)) continue;\n\t\t\t\t\tdp[yy][xx] += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tll ans = 0;\n\t\tREP(j, W) ans += dp[H - 1][j];\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint w,h;\nint mp[20][20],memo[20][20];\nvoid saiki(int x,int y){\n  if(y >= h-1) memo[y][x]++;\n  else {\n    for(int i=-1;i<=1;i++) {\n      int nx = x+i, ny = y+1;\n      if(nx==x && mp[ny][nx] == 2)while(mp[ny][nx] == 2) ny+=2;\n      if(nx <0|| nx >= w ||mp[ny][nx] == 1) continue;\n\n      if(memo[ny][nx]>0) memo[y][x] += memo[ny][nx];\n      else saiki(nx,ny),memo[y][x] += memo[ny][nx];\n\n    }\n    if(memo[y][x] == 0) mp[y][x] = 1;\n  }\n}\nint main() {\n  while(1) {\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n    for(int i=0;i<=19;i++)\n      for(int j=0;j<=19;j++)memo[i][j] = mp[i][j] = 0;\n     \n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)cin >> mp[i][j];\n  \n    for(int i=0;i<w;i++)\n      if(mp[0][i] !=1) saiki(i,0);\n     \n    int cnt = 0;\n    for(int i=0;i<w;i++)cnt+=memo[0][i];\n    cout <<cnt<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\nusing namespace std;\n\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint W, H;\n\twhile(cin >> W >> H, W) {\n\t\tint b[15][20] = { 0 };\n\t\tfor(int i = 0; i < H; i++) {\n\t\t\tfor(int j = 0; j < W; j++) {\n\t\t\t\tcin >> b[i][j];\n\t\t\t}\n\t\t}\n\n\t\tint dp[15][20] = { 0 };\n\t\tfor(int i = 0; i < W; i++) {\n\t\t\tif(b[0][i] != 1)\n\t\t\t\tdp[0][i] = 1;\n\t\t}\n\n\t\tfor(int i = 0; i < H - 1; i++) {\n\t\t\tfor(int j = 0; j < W; j++) {\n\t\t\t\tif(b[i][j] == 0) {\n\t\t\t\t\tfor(int d = -1; d <= 1; d++) {\n\t\t\t\t\t\tif(j + d < 0 || W <= j + d) continue;\n\t\t\t\t\t\tif(b[i + 1][j + d] == 0 || b[i + 1][j + d] == 2 && d == 0)\n\t\t\t\t\t\t\tdp[i + 1][j + d] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(b[i][j] == 2) {\n\t\t\t\t\tdp[i + 2][j] += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor(int i = H - 1; i <= H; i++) {\n\t\t\tfor(int j = 0; j < W; j++) {\n\t\t\t\tif(b[i][j] == 0)\n\t\t\t\t\tans += dp[i][j];\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define N 15\nusing namespace std;\nvoid func(int,int);\nint jump(int,int);\nint X,Y,data[N][N],memo[N][N];\nint main(){\n  while(1){\n    cin >> X >> Y;\n    if(X==0&&Y==0) break;\n    for(int i=0;i<Y;i++)\n      for(int j=0;j<X;j++) cin >> data[i][j],memo[i][j]=0;\n    for(int i=0;i<X;i++)\n      if(data[0][i]==0) func(0,i);\n    int cnt=0;\n    for(int i=0;i<X;i++) cnt+=memo[0][i];\n    cout << cnt << endl;\n  }\n  return 0;\n}\nvoid func(int y,int x){\n  if(y==Y-1){\n    memo[Y-1][x]=1;\n    return ;\n  }\n  if(0<=x-1&&data[y+1][x-1]==0){\n    if(memo[y+1][x-1]==0) func(y+1,x-1);\n    memo[y][x]+=memo[y+1][x-1];\n  }\n  if(x+1<X&&data[y+1][x+1]==0){\n    if(memo[y+1][x+1]==0) func(y+1,x+1);\n    memo[y][x]+=memo[y+1][x+1];\n  }\n  if(data[y+1][x]==0){\n    if(memo[y+1][x]==0) func(y+1,x);\n    memo[y][x]+=memo[y+1][x];\n  }\n  if(data[y+1][x]==2){\n    int r=jump(y+1,x);\n    if(r==-2) memo[y][x]+=1;\n    else if(r!=-1){\n      if(memo[r][x]==0) func(r,x);\n      memo[y][x]+=memo[r][x];\n    }\n  }\n  if(memo[y][x]==0) data[y][x]=1;\n}\nint jump(int y,int x){\n  while(1){\n    y+=2;\n    if(y<=Y-1&&data[y][x]==1) break;\n    if(y>=Y-1) return -2;\n    if(data[y][x]==0) return y;\n  }\n  return -1;\n}"
  },
  {
    "language": "C++",
    "code": "/* {{{ Shinobu kawaii */\n/*\n  ______   __        _                  __                 \n.' ____ \\ [  |      (_)                [  |                \n| (___ \\_| | |--.   __   _ .--.   .--.  | |.--.   __   _   \n _.____`.  | .-. | [  | [ `.-. |/ .'`\\ \\| '/'`\\ \\[  | | |  \n| \\____) | | | | |  | |  | | | || \\__. ||  \\__/ | | \\_/ |, \n \\______.'[___]|__][___][___||__]'.__.'[__;.__.'  '.__.'_/ \n\n*/\n// clang-format off\n/* }}} */\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n// #define int long long\nstruct Fast {Fast(){std::cin.tie(0);ios::sync_with_stdio(false);}} fast;\n\n/* cpp template {{{ */\n\n/* short */\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define Fi first\n#define Se second\n#define ALL(v) begin(v), end(v)\n#define RALL(v) rbegin(v), rend(v)\n#define X real()\n#define Y imag()\n\n/* REPmacro */\n#define REPS(i, a, n) for (ll i = (a); i < (ll)(n); ++i)\n#define REP(i, n) REPS(i, 0, n)\n#define RREP(i, n) REPS(i, 1, n + 1)\n#define DEPS(i, a, n) for (ll i = (a); i >= (ll)(n); --i)\n#define DEP(i, n) DEPS(i, n, 0)\n\n/* debug */\n#define debug(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n';\n\n/* alias */\nusing ll = long long;\nusing ull = unsigned long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nusing pii = pair<int, int>;\nusing D = double;\nusing P = complex<D>;\nusing vs = vector<string>;\ntemplate <typename T> using PQ = priority_queue<T>;\ntemplate <typename T> using minPQ = priority_queue<T, vector<T>, greater<T>>;\n\n/* const */\nconst int INF = 1001001001;\nconst ll LINF = 1001001001001001001ll;\nconst int MOD = 1e9 + 7;\nconst D EPS = 1e-9;\nconst int dx[] = {0, 1, 0, -1, 1, -1, 1, -1}, dy[] = {1, 0, -1, 0, 1, -1, -1, 1};\n\n/* func */\ninline bool inside(int y, int x, int H, int W) {return y >= 0 && x >= 0 && y < H && x < W;}\ninline int in() {int x; cin >> x; return x;}\ninline ll IN() {ll x; cin >> x; return x;}\ninline vs split(const string& t, char c) {vs v; stringstream s(t); string b; while(getline(s, b, c)) v.eb(b); return v;}\ntemplate <typename T> inline bool chmin(T& a, const T& b) {if (a > b) a = b; return a > b;}\ntemplate <typename T> inline bool chmax(T& a, const T& b) {if (a < b) a = b; return a < b;}\ntemplate <typename T> inline void print(const T& x) {cout << x << '\\n';}\ntemplate <typename T, typename S> inline void print(const vector<pair<T, S>>& v) {for (auto&& p : v) print(p);}\ntemplate <typename T> inline void print(const vector<T>& v, string s = \" \") {REP(i, v.size()) cout << v[i] << (i != (ll)v.size() - 1 ? s : \"\\n\");}\n// clang-format on\n/* }}} */\n\nint w, h;\nint field[20][20];\n\nll dfs(int y, int x, int yy = -1, int xx = -1) {\n  if (!inside(y, x, h + 1, w)) return 0;\n  if (field[y][x] == 1) return 0;\n  if (y >= h - 1) return 1;\n  if (field[y][x] == 2 && x != xx) return 0;\n\n  ll res;\n  if (field[y][x] == 2) {\n    res = dfs(y + 2, x, y, x);\n  } else {\n    res = dfs(y + 1, x, y, x) + dfs(y + 1, x + 1, y, x) + dfs(y + 1, x - 1, y, x);\n  }\n\n  return res;\n}\n\nsigned main() {\n  while (cin >> w >> h, w || h) {\n    REP(i, h) REP(j, w) field[i][j] = in();\n    ll ans = 0;\n    REP(i, w) {\n      ans += dfs(0, i);\n    }\n    print(ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <complex>\n#include <cstdlib>\n#include <cstring>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define repi(i,a,b) for(int i = (a); i < (b); i++)\n\nusing namespace std;\n\ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n\nconst int INF=1<<29;\nconst double EPS=1e-9;\n\nconst int dx[]={-1,0,1};\nint X,Y;\nint board[20][20];\nint cnt;\nvoid dfs(int y,int x){\n\twhile(board[y][x]==2){\n\t\ty+=2;\n\t\tif(board[y][x]==1){\n\t\t\treturn;\n\t\t}\n\n\t}\n\tif(board[y][x]==1)return;\n\tif(y>=Y){\n\t\tcnt++;\n\t\t//printf(\"(y,x) =(%d,%d)\\n\",y,x);\n\t\treturn;\n\t}\n\t\n\t//cout <<\"y = \"<<y <<\" x = \"<<x<<endl;\n\tfor(int i =0; i<3;i++){\n\t\tint nx =x +dx[i];\n\t\tint ny =y +1;\n\t\tif(nx <1||nx>X)continue;\n\t\tif(i!=1&&board[ny][nx]==2)continue;\n\t\tif(board[ny][nx]==1)continue;\n\t\tif(board[ny][nx]==0||board[ny][nx]==2){\n\t\t\tdfs(ny,nx);\n\t\t}\n\t}\n\treturn;\n}\n\nint main(){\n\twhile(cin>>X>>Y,X||Y){\n\t\tcnt =0;\n\t\trep(i,20)rep(j,20)board[i][j]=0;\n\t\tfor(int i=1;i <=Y;i++){\n\t\t\tfor(int j =1;j <=X;j++){\n\t\t\t\tcin>>board[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i =1;i <=X;i++){\n\t\t\tif(board[1][i]==0){\n\t\t\t\tdfs(1,i);\n\t\t\t}\n\t\t\t//cout <<endl;\n\t\t}\n\t\tcout <<cnt<<endl;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint main(){\n  int i,j;\n  int a[17][16],b[17][16],w,h;\n  int sm;\n  while(cin>>w>>h&&w+h){\n    memset(a,-1,sizeof(a));\n    for(i=0;i<h;i++){\n      for(j=1;j<w+1;j++){\n\tcin>>a[j][i];\n\ta[j][i]*=-1;\n      }\n    }\n    for(i=1;i<w+1;i++)\n      a[i][h]=0;\n    memset(b,0,sizeof(b));\n    for(i=1;i<w+1;i++){\n      if(a[i][0]==0)\n\tb[i][0]=1;\n    }\n    for(i=0;i<h-1;i++){\n      for(j=1;j<w+1;j++){\n\tif(b[j][i]){\n\t  if(a[j][i]){\n\t    if(a[j][i+2]==0||a[j][i+2]==-2)\n\t      b[j][i+2]+=b[j][i];\n\t  }else{\n\t    if(a[j-1][i+1]==0)\n\t      b[j-1][i+1]+=b[j][i];\n\t    if(a[j+1][i+1]==0)\n\t      b[j+1][i+1]+=b[j][i];\n\t    if(a[j][i+1]==0||a[j][i+1]==-2)\n\t      b[j][i+1]+=b[j][i];\n\t  }\n\t}\n      }\n    }\n    sm=0;\n    for(i=1;i<w+1;i++)\n      sm+=b[i][h-1]+b[i][h];\n    cout<<sm<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class t>\nusing table = vector<vector<t>>;\nconst ld eps=1e-9;\n\n//// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\"\n\nint main() {\n\twhile (1) {\n\t\tint H, W; cin >> W >> H;\n\t\tif (!H)break;\n\t\tvector<vector<int>>field(H + 3, vector<int>(W + 2,1));\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tcin >> field[i][j+1];\n\t\t\t}\n\t\t}\n\t\tfor (int i = H; i < H + 3; ++i) {\n\t\t\tfor (int j = 1; j <= W; ++j) {\n\t\t\t\tfield[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tvector<vector<long long int>>nums(H + 3, vector<long long int>(W + 2, 0));\n\t\tfor (int j = 0; j < W + 2; ++j) {\n\t\t\tif (!field[0][j])nums[0][j] = 1;\n\t\t}\n\t\tlong long int ans = 0;\n\t\tfor (int i = 0; i < H-1; ++i) {\n\t\t\tfor (int j = 1; j < W + 1; ++j) {\n\t\t\t\tfor (int dx = -1; dx <= 1;++dx) {\n\t\t\t\t\tconst int nextx = j + dx;\n\t\t\t\t\tint nexty = i + 1;\n\t\t\t\t\t\n\t\t\t\t\tif (field[nexty][nextx] == 1) {\n\n\t\t\t\t\t}\n\t\t\t\t\telse if (field[nexty][nextx] == 2) {\n\t\t\t\t\t\tif (!dx) {\n\t\t\t\t\t\t\twhile (1) {\n\t\t\t\t\t\t\t\tnexty += 2;\n\t\t\t\t\t\t\t\tif (nexty >= H - 1 && field[nexty][nextx] != 1) {\n\t\t\t\t\t\t\t\t\tans += nums[i][j];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tif (field[nexty][nextx] == 1) {\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse if (field[nexty][nextx] == 0) {\n\n\t\t\t\t\t\t\t\t\t\tnums[nexty][nextx] += nums[i][j];\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (nexty >= H - 1)ans += nums[i][j];\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tnums[nexty][nextx] += nums[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<numeric>\nusing namespace std;\n\nint main() {\n\tint x, y;\n\twhile (cin >> x >> y ,x,y) {\n\t\tvector<vector<int>> course(y + 2, vector<int>(x + 2, 0));\n\t\tfor (int i = 1; i <= y; i++) {\n\t\t\tfor (int j = 1; j <= x; j++) {\n\t\t\t\tcin >> course[i][j];\n\t\t\t}\n\t\t}\n\n\t\tvector<vector<int>> path(y + 2, vector<int>(x + 2, 0));\n\t\t//?????????????????????????????????1????????????\n\t\tfor (int i = 1; i <= x; i++) {\n\t\t\tif (course[1][i] != 1) path[1][i] = 1;\n\t\t}\n\n\t\tfor (int i = 1; i <= y; i++) {\n\t\t\tfor (int j = 1; j <= x; j++) {\n\t\t\t\t//????????????????????´????????????????????´??????????????????????????????????????????\n\t\t\t\t//?????????????§????????????????????????´?????????????????????????????£????????°?????´????????????????????????\n\t\t\t\tif (course[i][j] == 0) {\n\t\t\t\t\tif (course[i + 1][j + 1] == 0) path[i + 1][j + 1] += path[i][j];\n\t\t\t\t\tif (course[i + 1][j] != 1) path[i + 1][j] += path[i][j];\n\t\t\t\t\tif (course[i + 1][j - 1] == 0) path[i + 1][j - 1] += path[i][j];\n\t\t\t\t}\n\t\t\t\t//?¬???????????????´???????????£????????°????????????????????????????????????\n\t\t\t\t//?????????????????£????????§??´??????????????´???????????????(?????£?????????????????????????????´???????????????)\n\t\t\t\tif (course[i][j] == 2) {\n\t\t\t\t\tif (i + 2 > y) path[y][j] += path[i][j];\n\t\t\t\t\telse path[i + 2][j] += path[i][j];\n\t\t\t\t}\n\t\t\t\t//???????????´???????????????????????????????????????\n\t\t\t\tif (course[i][j] == 1) {/*do anything*/ }\n\t\t\t}\n\t\t}\n\n\t\tcout << accumulate(path[y].begin() + 1, path[y].end() - 1, 0) << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <functional>\n#include <numeric>\n#define fi first\n#define se second\nusing namespace std;\nbool value(int y,int x,int R,int C){return 0<=y&&y<R&&0<=x&&x<C;}\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<long long > vll;\ntypedef vector< vi > vvi;\ndouble pie=acos(-1);\nint INF=10000009;\nint dx[4] = { 0,-1,0,1 };\nint dy[4] = { -1,0,1,0 };\nint c[20][20];\nlong long int dp[20][20];\nint main() {\n\tint X,Y;\n\twhile(true){\n\t\tlong long int ans=0;\n\t\tcin>>X>>Y;\n\t\tif(X+Y==0) break;\n\t\tfor(int i=1;i<=Y;i++){\n\t\t\tfor(int j=1;j<=X;j++){\n\t\t\t\tcin>>c[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=X;i++){\n\t\t\tif(c[1][i]==1){\n\t\t\t\tdp[1][i]=0;\n\t\t\t}\n\t\t\tif(c[1][i]==0){\n\t\t\t\tdp[1][i]=1;\n\t\t\t}\n\t\t\tif(c[1][i]==2){\n\t\t\t\tdp[1][i]=1;\n\t\t\t\tdp[3][i]=1;\n\t\t\t}\n\t\t}\n\t\tfor(int i=2;i<=Y;i++){\n\t\t\tfor(int j=1;j<=X;j++){\n\t\t\t\tif(c[i][j]==1) dp[i][j]=0;\n\t\t\t\telse if(c[i][j]==0){\n\t\t\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\t\t\tif(c[i-1][j-1+k]!=2){\n\t\t\t\t\t\t\tdp[i][j]+=dp[i-1][j-1+k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(c[i-1][j]!=2){\n\t\t\t\t\t\tdp[i][j]+=dp[i-1][j];\n\t\t\t\t\t\tdp[i+2][j]+=dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tdp[i][j]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=Y;i<=Y+2;i++){\n\t\t\tfor(int j=1;j<=X;j++){\n\t\t\t\tans+=dp[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=Y+2;i++){\n\t\t\tfor(int j=1;j<=X;j++){\n\t\t\t\tdp[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(long long i=(a);i<(b);i++)\n#define REP(i,N) for(long long i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define fi first\n#define se second\n\n#define PI acos(-1.0)\n#define INF 1000000007\n#define EPS 1e-10\n#define MAX_N 20000\n#define MAX_M 16\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<double, double> PD;\ntypedef pair<string, ll> PS;\ntypedef vector<ll> V;\ntypedef pair<P, char> PC;\n\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(long long i=(a);i<(b);i++)\n#define REP(i,N) for(long long i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define fi first\n#define se second\n\n#define PI acos(-1.0)\n#define INF 1000000007\n#define EPS 1e-10\n#define MAX_N 20000\n#define MAX_M 16\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<double, double> PD;\ntypedef pair<string, ll> PS;\ntypedef vector<ll> V;\ntypedef pair<P, char> PC;\n\nint x, y;\nint field[16][16];\nint dp[16][16];\n\nint main(){\n\twhile (cin >> x >> y&&x + y){\n\t\tREP(i, 16){\n\t\t\tREP(j, 16){\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tfield[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tREP(i, y)REP(j, x)cin >> field[i][j];\n\t\tREP(j, x){\n\t\t\tif (field[0][j] == 0)dp[0][j] = 1;\n\t\t}\n\t\tREP(i, y - 1){\n\t\t\tREP(j, x){\n\t\t\t\tif (field[i][j] == 0){\n\t\t\t\t\tif (field[i + 1][j] != 1)dp[i + 1][j] += dp[i][j];\n\t\t\t\t\tif (j - 1 >= 0 && field[i + 1][j - 1] == 0){\n\t\t\t\t\t\tdp[i + 1][j - 1] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tif (j + 1 < x&&field[i + 1][j + 1] == 0){\n\t\t\t\t\t\tdp[i + 1][j + 1] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (field[i][j] == 2){\n\t\t\t\t\tif (i + 2 <= y - 1 && dp[i + 2][j] != 1){\n\t\t\t\t\t\tdp[i + 2][j] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tdp[i + 1][j] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tREP(j, x)ans += dp[y - 1][j];\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nclass point {\npublic:\n\tint num;\n\tint block;\n\tpoint() :num(0), block(2) {}\n};\nint main() {\n\tint X, Y;\n\twhile (cin >> X >> Y&&X != 0) {\n\t\tvector<vector<point> > map(X + 2, vector<point>(Y + 2));\n\t\tfor (int y = 1; y <= Y; ++y) {\n\t\t\tfor (int x = 1; x <= X; ++x) {\n\t\t\t\tcin >> map[x][y].block;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= X; ++i) {\n\t\t\tif (map[i][1].block == 0) {\n\t\t\t\tmap[i][1].num = 1;\n\t\t\t}\n\t\t}\n\t\tfor (int y = 1; y <= Y; ++y) {\n\t\t\tfor (int x = 1; x <= X; ++x) {\n\t\t\t\tif (map[x][y].block == 2) {\n\t\t\t\t\tint dy = min(Y + 1, y + 2);\n\t\t\t\t\tif (map[x][dy].block != 1) {\n\t\t\t\t\t\tmap[x][dy].num += map[x][y].num;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (map[x][y].block == 0) {\n\t\t\t\t\tfor (int k = -1; k <= 1; ++k) {\n\t\t\t\t\t\tint dx = x + k;\n\t\t\t\t\t\tint dy = y + 1;\n\t\t\t\t\t\tif (map[dx][dy].block == 0) {\n\t\t\t\t\t\t\tmap[dx][dy].num += map[x][y].num;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (map[dx][dy].block == 2 && k == 0) {\n\t\t\t\t\t\t\tmap[dx][dy].num += map[x][y].num;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int x = 1; x <= X; ++x) {\n\t\t\tans += map[x][Y + 1].num;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\nint vv[20][20];\nint table[20][20];\n/*\n1 1 1 1 1 \n1 1 1 1 1 \n1 1 3 1 1 \n0 3 3 0 1 \n4 3 3 1 0 \n4 0 0 0 0 \n*/\n/*\n5 5\n0 0 0 0 1\n2 1 0 2 0\n1 0 0 1 1\n0 2 1 2 0\n0 1 0 0 0\n*/\nvoid mainmain(){\n\tint w,h;\n\twhile(cin>>w>>h,w||h){\n\t\trep(i,20){\n\t\t\trep(j,20){\n\t\t\t\tvv[i][j]=0;\n\t\t\t}\n\t\t}\n\t\trep(i,20){\n\t\t\trep(j,20){\n\t\t\t\ttable[i][j]=0;\n\t\t\t}\n\t\t}\n\t\treep(i,1,w+1){\n\t\t\tvv[0][i]=1;\n\t\t}\n\t\trep(i,h){\n\t\t\trep(j,w){\n\t\t\t\tcin>>table[i+1][j+1];\n\t\t\t}\n\t\t}\n\t\trep(i,h){\n\t\t\treep(j,1,w+1){\n\t\t\t\tif(table[i][j]==2){\n\t\t\t\t\tvv[i+2][j]+=vv[i][j];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(table[i][j]==1) continue;\n\t\t\t\tvv[i+1][j]+=vv[i][j];\n\t\t\t\tif(i&&j-1>0&&table[i+1][j-1]==0){\n\t\t\t\t\tvv[i+1][j-1]+=vv[i][j];\n\t\t\t\t}\n\t\t\t\tif(i&&j+1<=w&&table[i+1][j+1]==0){\n\t\t\t\t\tvv[i+1][j+1]+=vv[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t\treep(i,h,h+2){\n\t\t\treep(j,1,w+1){\n\t\t\t\tans+=vv[i][j];\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\n\nusing namespace std;\n\n\n\tint n,m;\n\tint masu[17][17];\n\tint ura[17][17];\n\t\nint motom(){\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tswitch(ura[1][i]){\n\t\t\t\tcase 0:masu[1][i]+=1;break;\n\t\t\t\tcase 1:masu[1][i]+=0;break;\n\t\t\t\tcase 2:masu[1][i]+=1;break;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfor(int j=1;j<=m;j++){\n\t\t\t\tif(ura[i][j]==0){\n\t\t\t\t\tif(ura[i+1][j-1]==0){\n\t\t\t\t\t\tmasu[i+1][j-1]+=masu[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tif(ura[i+1][j]!=1){\n\t\t\t\t\t\tmasu[i+1][j]+=masu[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tif(ura[i+1][j+1]==0){\n\t\t\t\t\t\tmasu[i+1][j+1]+=masu[i][j];\n\t\t\t\t\t}\n\t\t\t\t}else if(ura[i][j]==2){\n\t\t\t\t\tif(ura[i+2][j]!=1){\n\t\t\t\t\t\tmasu[i+2][j]+=masu[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cont=0;\n\t\tfor(int i=n;i<=n+1;i++){\n\t\t\tfor(int j=1;j<=m;j++){\n\t\t\t\tcont+=masu[i][j];\n\t\t\t}\n\t\t}\n\t\treturn cont;\n}\nint contt;\nvoid saiki(int x,int y){\n\tif(y<1||y>m){\n\t\treturn;\n\t}\n\t\n\t\tmasu[x][y]++;\n\tif(x>n-1){\n\t\tcontt++;\n\t\treturn;\n\t}\n\tif(ura[x][y]==0){\n\t\tif(ura[x+1][y-1]==0){\n\t\t\tsaiki(x+1,y-1);\n\t\t}\n\t\tif(ura[x+1][y]!=1){\n\t\t\tsaiki(x+1,y);\n\t\t}\n\t\tif(ura[x+1][y+1]==0){\n\t\t\tsaiki(x+1,y+1);\n\t\t}\n\t}\n\tif(ura[x][y]==2){\n\t\tsaiki(x+2,y);\n\t}\n}\nint simu(){\n\tcontt=0;\n\tfor(int i=1;i<=m;i++){\n\t\tif(ura[1][i]!=1){\n\t\t\tsaiki(1,i);\n\t\t}\n\t}\n\t/*\n\tputs(\"\");\n\tfor(int i=1;i<=n+1;i++){\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tprintf(\"%d \",masu[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}*/\n\treturn contt;\n}\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0 && m==0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i=0;i<17;i++){\n\t\t\tfor(int j=0;j<17;j++){\n\t\t\t\tmasu[i][j]=0;\n\t\t\t\tura[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=1;j<=m;j++){\n\t\t\t\tscanf(\"%d\",&ura[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",simu());\n\t\t\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main(){\n  while(true){\n    int xsize,ysize;\n    cin>>xsize>>ysize;\n    if(!xsize&&!ysize)break;\n    int course[xsize+2][ysize];\n    for(int y=0;y<ysize;y++){\n      for(int x=0;x<xsize;x++){\n\tcin>>course[x+1][y];\n      }\n    }\n    int pattern[xsize+2][ysize+1];\n    for(int y=0;y<ysize;y++){\n      for(int x=0;x<xsize+2;x++){\n\tif(y) pattern[x][y] = 0;\n\telse if(course[x][y]) pattern[x][y] = 0;\t    \n\telse pattern[x][y] = 1;\n      }\n    }\n    pattern[0][0] = 0;\n    pattern[xsize+1][0] = 0;\n    int count = 0;\n    for(int y=0;y<ysize;y++){\n      for(int x=1;x<xsize+1;x++){\n\tcout<<pattern[x][y];\n\tif(course[x][y]==0){\n\t  if(y==ysize-1) count+=pattern[x][y];\n\t  else{\n\t    if(course[x-1][y+1]==0)\n\t      pattern[x-1][y+1] += pattern[x][y];\n\t    if(course[x][y+1]!=1)\n\t      pattern[x][y+1] += pattern[x][y];\n\t    if(course[x+1][y+1]==0)\n\t      pattern[x+1][y+1] += pattern[x][y];\n\t  }\n\t}\n\tif(course[x][y]==2){\n\t  if(y==ysize-2) count+= pattern[x][y];\n\t  else if(y==ysize-1) count+= pattern[x][y];\n\t  else pattern[x][y+2] += pattern[x][y];\n\t}\n      }\n      cout<<endl;\n    }\n    cout<<count<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n\nusing namespace std;\n\n\nint main() {\n\twhile(1) {\n\t\tint x, y;\n\t\tcin >> y >> x;\n\t\tif(x==0 && y==0) break;\n\t\tint field[x][y];\n\t\tfor(int i=0; i<x; i++) {\n\t\t\tfor(int j=0; j<y; j++) {\n\t\t\t\tcin >> field[i][j];\n\t\t\t}\n\t\t}\n\t\tint dp[x+1][y];\n\t\tfor(int i=0; i<x+1; i++) {\n\t\t\tfor(int j=0; j<y; j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<x; i++) {\n\t\t\tfor(int j=0; j<y; j++) {\n\t\t\t\tif(i==0 && field[i][j] == 0) dp[i][j] = 1;\n\t\t\t\telse {\n\t\t\t\t\tif(field[i][j] == 0) {\n\t\t\t\t\t\tif(0<j && field[i-1][j-1] == 0) dp[i][j] += dp[i-1][j-1];\n\t\t\t\t\t\tif(field[i-1][j] == 0) dp[i][j] += dp[i-1][j];\n\t\t\t\t\t\tif(j<y-1 && field[i-1][j+1] == 0) dp[i][j] += dp[i-1][j+1];\n\t\t\t\t\t}\n\t\t\t\t\tif(field[i][j] == 2) {\n\t\t\t\t\t\tdp[i][j] += dp[i-1][j];\n\t\t\t\t\t\tdp[i+2][j] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<y; i++) dp[x][i] += dp[x-1][i];\n\t\t//int sum=0;\n\t\t//for(int i=0; i<y; i++) sum += dp[x][i];\n\t\t//cout << sum << endl;\n\n\t\tfor(int i=0; i<x+1; i++) {\n\t\t\tfor(int j=0; j<y; j++) {\n\t\t\t\tcout << dp[i][j] << ' ';\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nint memo[16][16];\nint x, y;\n\nint calc(std::vector<std::vector<int> > &v, int x, int y){\n\n\tif (memo[x][y] != -1)return memo[x][y];\n\tint res = 0;\n\tif (x >= v.size() - 1)return 1;\n\n\tif (v[x][y] == 2)res += calc(v, x + 2, y);\n\n\tif (v[x][y] == 0){\n\t\tif (v[x + 1][y] == 0 || v[x + 1][y] == 2)res += calc(v, x + 1, y);\n\n\t\tif (y < v[x].size() - 1 && v[x + 1][y + 1] == 0)res += calc(v, x + 1, y + 1);\n\n\t\tif (y > 0 && v[x + 1][y - 1] == 0)res += calc(v, x + 1, y - 1);\n\t}\n\n\treturn memo[x][y] = res;\n}\n\n\nint main(){\n\n\twhile (std::cin >> x >> y){\n\n\t\tif (x == 0 && y == 0)break;\n\n\t\tint res = 0;\n\t\tstd::vector<std::vector<int> >v(y, std::vector<int>(x));\n\n\t\tfor (int i = 0; i < 16; i++){\n\t\t\tfor (int j = 0; j < 16; j++){\n\t\t\t\tmemo[i][j] = -1;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < y; i++){\n\t\t\tfor (int j = 0; j < x; j++){\n\t\t\t\tstd::cin >> v[i][j];\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < v[0].size(); i++)res += calc(v, 0, i);\n\n\t\tstd::cout << res << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "5 5\n0 0 0 0 1\n2 1 0 2 0\n1 0 0 1 1\n0 2 1 2 0\n0 1 0 0 0\n5 5\n0 0 1 0 0\n2 1 0 2 0\n1 0 0 1 1\n0 2 1 2 0\n0 1 0 0 0\n15 15\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 08\n6\n52694573\n\nbash-4.3(luke):~/syoribu/AOJ/PCK\n512:{ei1629}$ cat AOJ203.cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    int W, H;\n\n\n    while ( cin >> W >> H, W || H ) {\n        int dp[22][22] = {};\n        int mas[22][22] = {};\n\n        for ( int i = 0; i < H; i++ ) {\n            for ( int j = 0; j < W; j++ ) {\n                cin >> mas[i][j];\n            }\n        }\n\n        for ( int i = 0; i < W; i++ ) {\n            if ( mas[0][i] == 0 ) {\n                dp[0][i] = 1;\n            }\n        }\n\n        for ( int i = 0; i < H - 1; i++ ) {\n            for ( int j = 0; j < W; j++ ) {\n                if ( mas[i][j] == 2 ) {\n                    if ( mas[i + 2][j] != 1 ) {\n                        dp[i + 2][j] += dp[i][j];\n                    }\n                } else {\n                    for ( int k = -1; k <= 1; k++ ) {\n                        if ( 0 <= j + k && j + k < W ) {\n                            if ( mas[i + 1][j + k] == 0 ) {\n                                dp[i + 1][j + k] += dp[i][j];\n                            } else if ( k == 0 && mas[i + 1][j] == 2 ) {\n                                dp[i + 1][j] += dp[i][j];\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        int sum = 0;\n        for ( int i = 0; i < W; i++ ) {\n            sum += dp[H - 1][i] + dp[H][i];\n        }\n\n        cout << sum << endl;\n    }\n    return ( 0 );\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\ntypedef long long Int;\n\nint a[20][20];\nint dp[20][20];\n\nint main() {\n  for (;;) {\n      memset(dp, 0, sizeof(dp));\n      memset(a, 0, sizeof(a));\n      int C, R; cin >> C >> R;\n      if ((C | R) == 0) break;\n      REP(r, R) REP(c, C) cin >> a[r][c];\n\n      REP(c, C) if (a[0][c] == 0) dp[0][c] = 1;\n      REP(r, R - 1) {\n          REP(c, C) if (a[r][c] == 0) {\n              if (c - 1 >= 0) dp[r + 1][c - 1] += dp[r][c];\n              if (c + 1 <  C) dp[r + 1][c + 1] += dp[r][c];\n\n              int d = 1;\n              while (a[r + d][c] == 2) d += 2;\n              dp[r + d][c] += dp[r][c];\n          }\n      }\n\n      Int ans = 0;\n      REP(c, C) {\n          if (a[R - 1][c] == 0) ans += dp[R - 1][c];\n          ans += dp[R][c];\n          ans += dp[R + 1][c];\n      }\n\n      cout << ans << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint dmap[15][15];\nint dpmap[15][15];\nint dfs(int, int, int);\nint dx[]={-1, 0, 1};\nint h, w;\n\nint main(){\n  while(1){\n    cin >> w >> h;\n    if(w==0 && h==0) break;\n\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin >> dmap[i][j];\n      }\n    }\n\n\n    int ans=0;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tdpmap[i][j]=-1;\n      }\n    }\n    for(int i=0;i<w;i++){\n      if(dmap[0][i]==0){\n\tint tmp=dfs(0,i,1);\n\tif(tmp!=0) ans+=tmp;\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n\nint dfs(int y, int x, int d){\n  int sum=0;\n  if(y>=h){\n    return 1;\n  }\n  else if(dmap[y][x]==1){\n    dpmap[y][x]=0;\n    return 0;\n  }\n  else if(dmap[y][x]==2){\n    if(d==1){\n      if(y==h-2){\n\tdpmap[y][x]=1;\n\treturn 1;\n      }\n      if(dpmap[y+2][x]!=-1){\n\tsum+=dpmap[y+2][x];\n\tdpmap[y][x]=sum;\n\treturn sum;\n      }\n      else{\n\tsum+=dfs(y+2, x, 1);\n\tdpmap[y][x]=sum;\n\treturn sum;\n      }\n    }\n    else{\n      return 0;\n    }\n  }\nelse if(y==h-1){\n    sum+=dfs(y+1, x, 1);\n    dpmap[y][x]=sum;\n    return sum;\n  }\n else{\n    for(int i=0;i<3;i++){\n      int tx=x+dx[i];\n      int ty=y+1;\n      if(tx<0 || tx>=w) continue;\n      if(dmap[ty][tx]==1) continue;\n      if(dmap[ty][tx]==2 && i!=1) continue;\n      if(dpmap[ty][tx]!=-1){\n\tsum+=dpmap[ty][tx];\n      }\n      else sum+=dfs(ty, tx, i);\n    }\n  }\n  dpmap[y][x]=sum;\n  return sum;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define loop(i,a,b) for(int i=a; i<b; i++)\n#define rep(i,b) loop(i,0,b)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\n\nint main(){\n    int w,h;\n    while(cin>>w>>h, w||h){\n        int G[100][100]={};\n        int dp[100][100]={};\n\n        rep(i,h)rep(j,w) cin>> G[i][j];\n        rep(i,w) dp[0][i] = G[0][i]==0;\n\n        rep(i,h-1) rep(j,w){\n            if( G[i][j]==1){\n                dp[i][j]=0;\n            } else if(G[i][j]==2){\n                if(G[i+2][j]!=1){\n                    dp[i+2][j]+=dp[i][j];\n                }\n            } else {\n                if(G[i+1][j]==2) dp[i+1][j]+=dp[i][j];\n                loop(k,-1,2){\n                    if(0<=j+k && j+k<w && G[i+1][j+k]==0){\n                        dp[i+1][j+k]+=dp[i][j];\n                    }\n                }\n            }\n        }\n\n        ull res=0;\n        for(int i: {h-1,h}) rep(j,w){\n            res+=dp[i][j];\n        }\n\n        cout<<res<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 25\n\nint main()\n{\n    int H, W;\n    while (cin >> W >> H, W) {\n        vector<vector<int>> a(H, vector<int>(W));\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                cin >> a[i][j];\n            }\n        }\n        int dp[MAX][MAX] = {{}};\n        for (int i = 0; i < W; i++) {\n            dp[0][i] = (a[0][i] == 0);\n        }\n\n        for (int i = 0; i < H - 1; i++) {\n            for (int j = 0; j < W; j++) {\n                if (dp[i][j] <= 0 || a[i][j] == 1) continue;\n                if (a[i][j] == 2) {\n                    int ni = min(i + 2, H - 1);\n                    if (i + 2 < H && a[i+2][j] == 1) continue;\n                    dp[ni][j] += dp[i][j];\n                } else {\n                    for (int k = -1; k <= 1; k++) {\n                        int ni = i + 1;\n                        int nj = j + k;\n                        if (nj < 0 || nj >= W || ni >= H) continue;\n                        if (a[ni][nj] == 1) continue;\n                        if (a[ni][nj] == 2 && j != nj) continue;\n                        dp[ni][nj] += dp[i][j];\n                    }\n                }\n            }\n        }\n        int res = 0;\n        for (int i = 0; i < W; i++) {\n            res += dp[H-1][i];\n        }\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n\nusing namespace std;\n\nint main(){\n  int x, y, course[15][15], route[20][20], i, j, sum;\n  while(cin >> x >> y, x+y){\n    sum = 0;\n    for(i=0; i<20; i++){\n      for(j=0; j<20; j++){\n        route[i][j] = 0;\n      }\n    }\n    for(i=0; i<y; i++){\n      for(j=0; j<x; j++){\n        cin >> course[i][j];\n      }\n    }\n    for(i=0; i<y; i++){\n      for(j=0; j<x; j++){\n        if(i==0){\n          if(course[i][j]==0){\n            route[i][j] = 1;\n\t  }else{\n            route[i][j] = 0;\n          }\n        }else{\n          if(j==0){\n            if(course[i][j]==0){\n              if(course[i-1][j]==0){\n                route[i][j] += route[i-1][j];\n              }\n              if(course[i-1][j+1]==0){\n                route[i][j] += route[i-1][j+1];\n              }\n            }else if(course[i][j]==1){\n              route[i][j] = 0;\n            }else{\n              if(course[i-1][j]==0){\n                route[i][j] += route[i-1][j];\n              }\n              route[i+2][j] += route[i][j];\n            }\n          }else if(j==x-1){\n            if(course[i][j]==0){\n              if(course[i-1][j]==0){\n                route[i][j] += route[i-1][j];\n              }\n              if(course[i-1][j-1]==0){\n                route[i][j] += route[i-1][j-1];\n              }\n            }else if(course[i][j]==1){\n              route[i][j] = 0;\n            }else{\n              if(course[i-1][j]==0){\n                route[i][j] += route[i-1][j];\n              }\n              route[i+2][j] += route[i][j];\n            }\n          }else{\n            if(course[i][j]==0){\n              if(course[i-1][j]==0){\n                route[i][j] += route[i-1][j];\n              }\n              if(course[i-1][j-1]==0){\n                route[i][j] += route[i-1][j-1];\n              }\n              if(course[i-1][j+1]==0){\n                route[i][j] += route[i-1][j+1];\n              }\n            }else if(course[i][j]==1){\n              route[i][j] = 0;\n            }else{\n              if(course[i-1][j]==0){\n                route[i][j] += route[i-1][j];\n              }\n              route[i+2][j] += route[i][j];\n            }\n          }\n        }\n      }\n    }\n    for(i=y-1; i<y+1; i++){\n      for(j=0; j<x; j++){\n        sum+=route[i][j];\n      }\n    }\n    cout << sum << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint solve(int x,int y);\nint ax,ay;\nint mas[20][20];\nint memo[20][20];\nint main(){\n  while(1){\n    int ans=0;\n    cin>>ax>>ay;\n    if(ax==0 && ay==0) break;\n    for(int i=0;i<ay;i++){\n      for(int j=0;j<ax;j++){\n\tcin>>mas[i][j];\n\tmemo[i][j]=0;\n      }\n    }\n    \n    for(int i=0;i<ax;i++){\n      if(mas[0][i]!=1){\n\tans+=solve(i,0);\n      }\n    }\n    cout<<ans<<endl;\n  }\n}\nint solve(int x,int y){\n  if(y>=ay){\n    return 1;\n  }else if(memo[y][x]!=0){\n    return memo[y][x];\n  }else if(mas[y][x]==2){\n    if(mas[y+2][x]!=1){\n      return memo[y][x]=solve(x,y+2);\n    } \n    else{\n      return 0;\n    }\n  }\n  else if(mas[y][x]==1){\n    return 0;\n  }\n  else{\n    int anss=0; \n    if(mas[y+1][x]!=1){\n      anss+=solve(x,y+1);\n    }\n    if(x+1<ax && 0<=x+1 && mas[y+1][x+1]==0 && y+1!=ay){\n      anss+=solve(x+1,y+1);\n    }\n    if(0<=x-1 && x-1<ax && mas[y+1][x-1]==0 && y+1!=ay){\n      anss+=solve(x-1,y+1);\n    }\n    return memo[y][x]=anss;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nint main(){\n\tint n,m;\n\tint masu[17][17];\n\tint ura[17][17];\n\tcin>>n>>m;\n\tfor(int i=0;i<17;i++){\n\t\tfor(int j=0;j<17;j++){\n\t\t\tmasu[i][j]=ura[i][j]=0;\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tcin>>masu[i][j];\n\t\t}\n\t}\n\t\n\tfor(int j=1;j<=m;j++){\n\t\tif(masu[0][j]!=1){\n\t\tura[0][j]=1;\n\t\t}\n\t}\n\t\n\t\n\tfor(int i=0;i<n-1;i++){\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tif(masu[i][j]==0){\n\t\t\t\tif(masu[i+1][j-1]==0){\n\t\t\t\t\tura[i+1][j-1]+=ura[i][j];\n\t\t\t\t}\n\t\t\t\tif(masu[i+1][j]!=1){\n\t\t\t\t\tura[i+1][j]+=ura[i][j];\n\t\t\t\t}\n\t\t\t\tif(masu[i+1][j+1]==0){\n\t\t\t\t\tura[i+1][j+1]+=ura[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(masu[i][j]==2){\n\t\t\t\tif(masu[i+2][j]!=1){\n\t\t\t\t\tura[i+2][j]+=ura[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint cont=0;\n\tfor(int i=1;i<=m;i++){\n\t\tcont+=ura[n][i]+ura[n-1][i];\n\t}\n\t\n\t/*\n\t\n\tfor(int i=0;i<17;i++){\n\t\tfor(int j=0;j<17;j++){\n\t\t\tprintf(\"%2d \",ura[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}*/\n\tprintf(\"%d\\n\",cont);\n\t\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nint masu[17][17];\n\nint count;\n\tint n,m;\nvoid saiki(int x,int y){\n\t\n\tif(y<1 || y>n){\n\t\treturn;\n\t}\n\tif(x>=m){\n\t\tcount++;\n\t\treturn;\n\t}\n\t\n\tif(masu[x][y]==0){\n\t\tif(masu[x+1][y-1]==0 && x<=m-2){\n\t\t\tsaiki(x+1,y-1);\n\t\t}\n\t\tif(masu[x+1][y]==0){\n\t\t\tsaiki(x+1,y);\n\t\t}\n\t\tif(masu[x+1][y]==2){\n\t\t\tsaiki(x+1,y);\n\t\t}\n\t\tif(masu[x+1][y+1]==0&& x<=m-2){\n\t\t\tsaiki(x+1,y+1);\n\t\t}\n\t}\n\tif(masu[x][y]==1){\n\t}\n\tif(masu[x][y]==2){\n\t\tif(masu[x+2][y]!=1){\n\t\t\tsaiki(x+2,y);\n\t\t}\n\t}\n\t\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<17;i++){\n\t\tfor(int j=0;j<17;j++){\n\t\t\tmasu[i][j]=0;\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tcin>>masu[i][j];\n\t\t}\n\t}\n\t\n\tcount=0;\n\t\n\tfor(int i=1;i<=m;i++){\n\t\tsaiki(0,i);\n\t}\n\t\n\tprintf(\"%d\\n\",count);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint dx[]={-1,0,1};\n\nint main()\n{\n\tint X,Y;\n\twhile(cin >> X >> Y, (X||Y))\n\t{\n\t\tint f[15][17]={0}, dp[15][17]={0};\n\t\tfor(int i=0; i<Y; i++)\n\t\tfor(int j=0; j<X; j++)\n\t\t\tcin >> f[j][i];\n\t\t\t\n\t\tfor(int i=0; i<X; i++)\n\t\t\tif(f[i][0]==0) dp[i][0]=1;\n\t\t\t\n\t\tfor(int i=0; i<Y-1; i++)\n\t\tfor(int j=0; j<X; j++)\n\t\t{\n\t\t\tif(dp[j][i]==0) continue;\n\t\t\tif(f[j][i]==2)\n\t\t\t{\n\t\t\t\tint ty=i+2;\n\t\t\t\tif(f[j][ty]!=1)\n\t\t\t\t\tdp[j][ty]+=dp[j][i];\n\t\t\t\t\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int k=0; k<3; k++)\n\t\t\t{\n\t\t\t\tint tx=j+dx[k];\n\t\t\t\tif(tx<0||tx>=X) continue;\n\t\t\t\tif(f[tx][i+1]==1) continue;\n\t\t\t\tif(k!=1&&f[tx][i+1]==2) continue;\n\t\t\t\t\n\t\t\t\tdp[tx][i+1]+=dp[j][i];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans=0;\n\t\tfor(int j=-1; j<2; j++)\n\t\tfor(int i=0; i<X; i++)\n\t\t\tans+=dp[i][Y+j];\n\t\t\t\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main(){\n\n    int w,h;\n    while(cin>>w>>h){\n        int data[16][16]={{0}},dp[17][17]={{0}};\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                cin>>data[i][j];\n                if(i==0&&data[i][j]!=1)dp[i][j]=1;\n            }\n        }\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                if(dp[i][j]!=0){\n                    if(data[i][j]==0){\n                        if(i!=h-1&&j!=0&&data[i+1][j-1]==0)dp[i+1][j-1]+=dp[i][j];\n                        if(data[i+1][j]!=1)dp[i+1][j]+=dp[i][j];\n                        if(i!=h-1&&j!=w-1&&data[i+1][j+1]==0)dp[i+1][j+1]+=dp[i][j];\n                    }\n                    else if(data[i][j]==2){\n                        if(i==h-1)dp[i+1][j]+=dp[i][j];\n                        else if(data[i+2][j]!=1)dp[i+2][j]+=dp[i][j];\n                    }\n                }\n            }\n        }\n        /*\n        cout<<endl;\n        for(int i=0;i<=h;i++){\n            cout<<i<<\":\";\n            for(int j=0;j<w;j++){\n                cout<<dp[i][j]<<\" \";\n            }\n            cout<<endl;\n        }*/\n        int ans=0;\n        for(int j=0;j<w;j++)ans+=dp[h][j];\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint solve(int x,int y);\nint ax,ay;\nint mas[200][200];\nlong long memo[200][200];\nint main(){\n  while(1){\n    for(int i=0;i<200;i++){\n      for(int j=0;j<200;j++){\n\tmemo[i][j]=0;\n      }\n    }\n    long long ans=0;\n    cin>>ax>>ay;\n    if(ax==0 && ay==0) break;\n    \n    for(int i=0;i<ay;i++){\n      for(int j=0;j<ax;j++){\n\tcin>>mas[i][j];\n      }\n    }\n    \n    for(int i=0;i<ax;i++){\n      if(mas[0][i]!=1){\n\tans+=solve(i,0);\n      }\n    }\n    cout<<ans<<endl;\n  }\n}\nint solve(int x,int y){\n  if(memo[y][x]!=0){\n    return memo[y][x];\n  }\n  else if(y>=ay){\n    return 1;\n  }else if(mas[y][x]==1){\n    return 0;\n  }else if(mas[y][x]==2){\n    return solve(x,y+2);\n  } \n  else{\n    long long anss=0; \n    if(mas[y+1][x]!=1){\n      anss+=solve(x,y+1);\n    }\n    if(x+1<ax && mas[y+1][x+1]==0 && y+1!=ay){\n      anss+=solve(x+1,y+1);\n    }\n    if(0<=x-1 && mas[y+1][x-1]==0 && y+1!=ay){\n      anss+=solve(x-1,y+1);\n    }\n    return memo[y][x]=anss;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nint main()\n{\n\tfor(;;){\n\t\tint x, y;\n\t\tint map[100][100];\n\t\tint dp[100][100];\n\t\t\n\t\tcin >> x;\n\t\tcin >> y;\n\t\tif(x == 0 && y == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < y; i++){\n\t\t\tfor(int j = 0; j < x; j++){\n\t\t\t\tcin >> map[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\t//ツ鳴催渉可づ可暗ェツ氾板湘」ツづ個療アツづ個づつィツづィツ青板づーツ個按津ィ\n\t\t//0:ツ暗堋督ョツ嘉つ能\n\t\t//1:ツ湘。ツ害ツ閉ィ\n\t\t//2:ツジツδδδ督プツ妥、\n\t\t\n\t\tfor(int i = 0; i < x; i++){\n\t\t\tif(map[0][i] == 0){\n\t\t\t\tdp[0][i] = 1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdp[0][i] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1; i < y; i++){\n\t\t\tfor(int j = 0; j < x; j++){\n\t\t\t\t//ツ配ツ療アツ外ツアツクツセツスツづーツづ「ツづ淞づヲツつ、\n\t\t\t\tif(j == 0){\n\t\t\t\t\tif(map[i][j] == 1){\n\t\t\t\t\t\tdp[i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse if(map[i][j] == 0){\n\t\t\t\t\t\tif(map[i-1][j] == 2 ||map[i-1][j+1] == 2){\n\t\t\t\t\t\t\tif(map[i-1][j] == 2 || map[i-1][j-1] == 2 || map[i-1][j+1] == 2){\n\t\t\t\t\t\t\t\tif(map[i-1][j] == 2){\n\t\t\t\t\t\t\t\t\tdp[i][j] = dp[i-1][j+1];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(map[i-1][j+1] == 2){\n\t\t\t\t\t\t\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tdp[i][j] = dp[i-1][j] + dp[i-1][j+1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(map[i-2][j] == 2){\n\t\t\t\t\t\t\tdp[i][j] += dp[i-2][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t} \n\t\t\t\t\telse if(map[i][j] == 2){\n\t\t\t\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//ツつサツづェツ暗按外\n\t\t\t\telse{\n\t\t\t\t\tif(map[i][j] == 0){\n\t\t\t\t\t\tif(map[i-1][j] == 2 || map[i-1][j-1] == 2 || map[i-1][j+1] == 2){\n\t\t\t\t\t\t\tif(map[i-1][j] == 2){\n\t\t\t\t\t\t\t\tdp[i][j] = dp[i-1][j+1] + dp[i-1][j-1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(map[i-1][j-1] == 2){\n\t\t\t\t\t\t\t\tdp[i][j] = dp[i-1][j] + dp[i-1][j+1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(map[i-1][j+1] == 2){\n\t\t\t\t\t\t\t\tdp[i][j] = dp[i-1][j] + dp[i-1][j-1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(map[i-1][j] == 2 && map[i-1][j+1] == 2){\n\t\t\t\t\t\t\t\tdp[i][j] = dp[i-1][j-1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(map[i-1][j] == 2 && map[i-1][j-1] == 2){\n\t\t\t\t\t\t\t\tdp[i][j] = dp[i-1][j+1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(map[i-1][j+1] == 2 && map[i-1][j-1] == 2){\n\t\t\t\t\t\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(map[i-1][j+1] == 2 && map[i-1][j] == 2 && map[i-1][j-1] == 2){\n\t\t\t\t\t\t\t\tdp[i][j] = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tdp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j+1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(map[i-2][j] == 2){\n\t\t\t\t\t\t\tdp[i][j] += dp[i-2][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(map[i][j] == 1){\n\t\t\t\t\t\tdp[i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse if(map[i][j] == 2){\n\t\t\t\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\t\t\t\tif(map[i-2][j] == 2){\n\t\t\t\t\t\t\tdp[i][j] += dp[i-2][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\t\n\t\tfor(int i = 0; i < x; i++){\n\t\t\tans += dp[y-1][i];\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < x; i++){\n\t\t\tif(map[y-2][i] == 2){\n\t\t\t\tans+= dp[y-2][i];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint H, W, c[15][15], dp[15][15];\nint main() {\n\twhile(scanf(\"%d%d\", &W, &H), H) {\n\t\tmemset(c, 0, sizeof(c));\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tfor(int i = 0; i < H; i++) {\n\t\t\tfor(int j = 0; j < W; j++) scanf(\"%d\", &c[i][j]);\n\t\t}\n\t\tfor(int i = 0; i < W; i++) {\n\t\t\tif(c[0][i] == 0) dp[0][i] = 1;\n\t\t}\n\t\tfor(int i = 1; i < H; i++) {\n\t\t\tfor(int j = 0; j < W; j++) {\n\t\t\t\tif(c[i][j] == 1) continue;\n\t\t\t\tif(i != H && c[i - 1][j] == 0) dp[i][j] = dp[i - 1][j];\n\t\t\t\tif(i != H && c[i][j] == 0 && j != 0 && c[i - 1][j - 1] == 0) dp[i][j] += dp[i - 1][j - 1];\n\t\t\t\tif(i != H && c[i][j] == 0 && j + 1 != W && c[i - 1][j + 1] == 0) dp[i][j] += dp[i - 1][j + 1];\n\t\t\t\tif(i > 1 && c[i - 2][j] == 2) dp[i][j] += dp[i - 2][j];\n\t\t\t}\n\t\t}\n\t\tint ret = 0;\n\t\tfor(int i = 0; i < W; i++) {\n\t\t\tret += dp[H - 1][i];\n\t\t\tif(c[H - 2][i] == 2) ret += dp[H - 2][i];\n\t\t}\n\t\tprintf(\"%d\\n\", ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<cstring>\n#include<string>\nusing namespace std;\nint X,Y;\nchar fie[20][20];\nint dp[20][20];\nint dx[]={-1,0,1};\nint solve(int x,int y){\n  if(dp[x][y]!=-1) return dp[x][y];\n  if(y>=Y-1) return dp[x][y]=1;\n  if(fie[x][y]=='2' && fie[x][y+2]!='1'){\n    return dp[x][y]=solve(x,y+2);\n  }\n  int ret=0;\n  for(int i=0;i<3;i++){\n    int nx=x+dx[i];\n    if(nx < 0 || nx >= X) continue;\n    if(fie[nx][y+1]=='1') continue;\t \n    if(i==1){\n      ret += solve(nx,y+1);\n    }else{\n      if(fie[nx][y+1]=='2') continue;\n      ret += solve(nx,y+1);\n    }\n  }\n  return dp[x][y]=ret;\n}\nmain(){\n  while(1){\n    cin >> X >> Y;\n    if(X==0 && Y==0) break;\n    memset(fie,0,sizeof(fie));\n    for(int i=0;i<Y;i++)\n      for(int j=0;j<X;j++) cin >> fie[j][i];\n    memset(dp,-1,sizeof(dp));\n    int res=0;\n    for(int i=0;i<X;i++){\n      if(fie[i][0]=='0')\n\tres += solve(i,0);\n      //      cout << solve(i,0) << \" \" << i << endl;\n    }/*\n    for(int i=0;i<Y+1;i++){\n      for(int j=0;j<X;j++)\n\tcout << dp[j][i];\n      cout << endl;\n      }*/\n    cout << res << endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\nusing namespace std;\n\nint x, y, f[15][15];\nlong dp[15][15]; //座標\n\nlong rec(int a, int b){\n\tif(dp[a][b]>=0) return dp[a][b];\n\n\tlong ret=0;\n\t//printf(\" %d %d\\n\", a, b);\n\t\n\tif(b>=y-1) ret=1;\n\telse if(f[b][a]==0){\n\t\tfor(int i=-1; i<=1; ++i){\n\t\t\tint na=a+i;\n\t\t\tif(na<0 || x<=na) continue;\n\t\t\t\n\t\t\tif(i==0){\n\t\t\t\tif(f[b+1][na]==1) ret+=0;\n\t\t\t\telse ret+=rec(na, b+1);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(f[b+1][na]==0) ret+=rec(na, b+1);\n\t\t\t\telse ret+=0;\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\telse if(f[b][a]==1) ret=0;\t\n\telse if(f[b][a]==2) ret+=rec(a, b+2);\n\n\t//printf(\" %d %d ret=%ld\\n\", a, b, ret);\n\treturn dp[a][b]=ret;\t\n}\n\nint main(){\n\twhile(1){\n\t\tscanf(\" %d %d\", &x, &y);\n\t\tif(x==0) break;\t\n\t\tfor(int i=0; i<y; ++i)\n\t\tfor(int j=0; j<x; ++j)\n\t\tscanf(\" %d\", &f[i][j]);\t\t\n\t\n\t\tmemset(dp, -1, sizeof(dp));\n\t\tlong ans=0;\n\t\tfor(int i=0; i<x; ++i){\n\t\t\tif(f[0][i]==0) ans+=rec(i, 0);\n\t\t\t//printf(\" ans=%ld\\n\", ans);\t\n\t\t}\n\t\t\n\t\tprintf(\"%ld\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define MAX 15\n#define BLANK 0\n#define BARRIER 1\n#define JUMP 2\nint main()\n{\n  int X,Y,field[MAX][MAX],dp[MAX][MAX],i,j,sum;\n  while(cin>>X>>Y,X|Y){\n    for(i=0;i<Y;i++)for(j=0;j<X;j++){cin>>field[i][j];dp[i][j]=(i==0);}\n    for(i=1;i<Y;i++){\n      for(j=0;j<X;j++){\n\tif(field[i][j]==BARRIER)continue;\n\tif(field[i-1][j]==BLANK)dp[i][j]+=dp[i-1][j];\n\tif(j+1<X && field[i-1][j+1]==BLANK && field[i][j]!=JUMP)dp[i][j]+=dp[i-1][j+1];\n\tif(j-1>=0 && field[i-1][j-1]==BLANK && field[i][j]!=JUMP)dp[i][j]+=dp[i-1][j-1];\n\tif(i-2>=0 && field[i-2][j]==JUMP)dp[i][j]+=dp[i-2][j];\n      }\n    }\n    sum=0;\n    for(j=0;j<X;j++){\n      if(field[Y-1][j]==BLANK||field[Y-1][j]==JUMP)sum+=dp[Y-1][j];\n      if(Y-2>=0 && field[Y-2][j]==JUMP)sum+=dp[Y-2][j];\n    }\n    cout<<sum<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint w,h;\nint mp[20][20];\nint memo[20][20];\nint ans;\nint count;\n \nint saiki(int x,int y) {\n  count++;\n  int dx[3] = {-1,0,1};\n  int dy[3] = {1,1,1};\n   \n  if(y >= h-1) ans++,memo[y][x]++;\n  else if(mp[y][x] != 1) {\n    for(int i=0;i<3;i++) {\n      int nx = dx[i]+x;\n      int ny = dy[i]+y;\n      if(nx <0|| nx >= w || memo[ny][nx] == -1||mp[ny][nx] == 1) continue;\n       \n      if(memo[ny][nx] > 0 && mp[ny][nx] == 0) {\n\tans += memo[ny][nx];\n\tmemo[y][x] += memo[ny][nx];\n      } \n      else if(mp[ny][nx] == 0){\n\tsaiki(nx,ny);\n\tif(memo[ny][nx] > 0) memo[y][x] += memo[ny][nx];\n      }\n      else if(nx==x && mp[ny][nx] == 2){\n\tint ty = ny;\n\twhile(mp[ty][nx] == 2) ty+=2;\n\tif(mp[ty][nx] == 0 && memo[ty][nx] == 0){\n\t  saiki(nx,ty);\n\t  if(memo[ty][nx] > 0) memo[y][x] += memo[ty][nx];\n\t}\n\telse if(mp[ty][nx] == 0 && memo[ty][nx] > 0){\n\t  memo[y][x] += memo[ty][nx];\n\t  ans+= memo[ty][nx];\n\t}\n      }\n    }\n    if(memo[y][x] == 0) memo[y][x] = -1;\n  }\n}\n \n \nint main() {\n \n  while(1) {\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n \n    for(int i=0;i<=19;i++)\n      for(int j=0;j<=19;j++){\n\tmemo[i][j] = 0;\n\tmp[i][j] = 0;\n      }\n     \n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tcin >> mp[i][j];\n \n \n    ans = 0;\n    count = 0;\n    for(int i=0;i<w;i++) {\n      if(mp[0][i] !=1) saiki(i,0);\n    }\n    int ans2 = 0;\n    for(int i=0;i<w;i++)\n      if(memo[0][i] > 0) ans2+=memo[0][i];\n     \n    //cout << ans << endl;\n       cout << ans2 << endl;\n    //cout << count << endl;\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reg(i,a,b) for(int i=(a);i<=(b);i++)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n\nint dat[30][30];\nint dp[30][30];\nint main(void){\n\tint x,y;\n\tfor(;;){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif(x==0)break;\n\t\tmemset(dp,0,sizeof(dp));\n\t\tmemset(dat,0,sizeof(dat));\n\t\trep(j,y)rep(i,x){\n\t\t\tscanf(\"%d\",&dat[i][j]);\n\t\t}\n\t\trep(i,x)if(dat[i][0]==0)dp[i][0]=1;\n\t\trep(j,y)rep(i,x){\n\t\t\tif(dat[i][j]==1)continue;\n\t\t\tif(dat[i][j]==2){\n\t\t\t\tif(dat[i][j+2]!=1)dp[i][j+2]+=dp[i][j];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(j!=y-1){\n\t\t\t\tif(i>0 && dat[i-1][j+1]==0){\n\t\t\t\t\tdp[i-1][j+1]+=dp[i][j];\n\t\t\t\t}\n\t\t\t\tif(i<x-1 && dat[i+1][j+1]==0){\n\t\t\t\t\tdp[i+1][j+1]+=dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dat[i][j+1]!=1)dp[i][j+1]+=dp[i][j];\n\t\t}\n\t\tlli ans=0;\n\t\t/*\n\t\tprintf(\"\\n\");\n\t\trep(j,y){\n\t\t\trep(i,x){\n\t\t\t\t//printf(\"(%2d %2d)\",dat[i][j],dp[i][j]);\n\t\t\t\tprintf(\"%2d\",dp[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\treg(j,y,y+1){\n\t\t\t//printf(\"\\n\");\n\t\t\trep(i,x){\n\t\t\t\t//printf(\"%2d \",dp[i][j]);\n\t\t\t\tans+=dp[i][j];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <cstring>\n#include <fstream>\n#include <numeric>\n#include <algorithm>\n\nusing namespace std;\n\nint main(int argc, char **argv) {\n  int x, y, **field, **route, rsum;\n\n  while (true) {\n    cin >> x >> y;\n    if (x == 0 && y == 0)\n      break;\n    rsum = 0;\n    field = new int*[y];\n    route = new int*[y];\n    for (int i = 0; i < x; i++) {\n      field[i] = new int[x];\n      route[i] = new int[x];\n      memset(route[i], 0, sizeof(int) * x);\n    }\n    for (int i = 0; i < y; i++)\n      for (int j = 0; j < x; j++)\n        cin >> field[i][j];\n    for (int i = 0; i < x; i++) {\n      int f = field[0][i];\n      if (!f)\n        route[0][i] = 1;\n    }\n\n    for (int i = 1; i < y; i++)\n      for (int j = 0; j < x; j++) {\n        int f = field[i][j];\n        if (f == 0) {\n          for (int k = -1; k <= 1; k++)\n            if ((j + k >= 0 && j + k < x) &&\n                ((k == 0 && field[i-1][j+k] == 2) ||\n                 (field[i-1][j+k] != 2)))\n              route[i][j] += route[i-1][j+k];\n        } else if (f == 1) {\n          route[i][j] = 0;\n        } else if (i + 2 < y) {\n          route[i+2][j] = route[i-1][j];\n        } else if (i + 2 >= y) {\n          rsum += route[i-1][j];\n        }\n      }\n    for (int i = 0; i < x; i++)\n      rsum += route[y-1][i];\n\n    cout << rsum << endl;\n    /* for DEBUG */\n    for (int i = 0; i < y; i++) {\n      for (int j = 0; j < x; j++) {\n        cout << route[i][j];\n        cout << ' ';\n      }\n      cout << endl;\n    }\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nint main(void){\n  int x,y;\n  int m[20][20];\n  for( ; ; ){\n    cin >> x >> y;\n    if(!x && !y) break;\n\n    memset(m,0,sizeof(m));\n\n    for(int i = 0;i < y; i++)\n      for(int j = 0;j < x; j++) cin >> m[i][j];\n\n    long long dp[20][20] = {0};\n    long long ans = 0;\n\n    for(int i = 0;i < y; i++){\n      for(int j = 0;j < x; j++){\n\tif(i == 0){\n\t  if(m[i][j] == 0) dp[i][j] = 1;\n\t}\n\tif(m[i][j] == 2 && m[i+2][j] != 1) dp[i+2][j] += dp[i][j];\n\telse if(!m[i][j] && !j){\n\t  dp[i+1][j] += dp[i][j];\n\t  if(!m[i+1][j+1]) dp[i+1][j+1] += dp[i][j];\n\t}\n\telse if(!m[i][j] && j == x-1){\n\t  dp[i+1][j] += dp[i][j];\n\t  if(!m[i+1][j-1]) dp[i+1][j-1] += dp[i][j];\n\t}\n\telse if(!m[i][j]){\n\t  if(!m[i+1][j-1]) dp[i+1][j-1] += dp[i][j];\n\t  dp[i+1][j] += dp[i][j];\n\t  if(!m[i+1][j+1]) dp[i+1][j+1] += dp[i][j];\n\t}\n      }\n    }\n\n    for(int i = 0;i < x; i++){\n      if(m[y-2][i] == 2) ans += dp[y-2][i];\n      if(m[y-1][i] != 1) ans += dp[y-1][i];\n    }\n\n    cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tint s,i,j,x,y,c[15][15],d[17][15];\n\twhile(cin >> x >> y) {\n\t\tif (x+y==0) break;\n\t\tfor (i=0;i<y;i++) for (j=0;j<x;j++) cin >> c[i][j];\n\t\tfor (i=1;i<y+2;i++) for (j=0;j<x;j++) d[i][j]=0;\n\t\tfor (j=0;j<x;j++) d[0][j]=1;\n\t\tfor (i=0;i<y-1;i++) for (j=0;j<x;j++) {\n\t\t\ts=d[i][j];\n\t\t\tif (c[i][j]==0) { \n\t\t\t\tif (j>0) if (c[i+1][j-1]==0) d[i+1][j-1]+=s;\n\t\t\t\tif (j<x-1) if (c[i+1][j+1]==0) d[i+1][j+1]+=s;\n\t\t\t\tif (c[i+1][j]!=1) d[i+1][j]+=s;\n\t\t\t}\n\t\t\tif (c[i][j]==2 && c[i+2][j]!=1) d[i+2][j]+=s;\n\t\t}\n\t\ts=0;\n\t\tfor (i=y-1;i<=y;i++) for (j=0;j<x;j++) s+=d[i][j];\n\t\tcout << s << endl; \n\t }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n\tint n,m;\n\tint masu[17][17];\n\tint ura[17][17];\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0 && m==0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i=0;i<17;i++){\n\t\t\tfor(int j=0;j<17;j++){\n\t\t\t\tmasu[i][j]=0;\n\t\t\t\tura[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=1;j<=m;j++){\n\t\t\t\tscanf(\"%d\",&ura[i][j]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tswitch(ura[1][i]){\n\t\t\t\tcase 0:masu[1][i]+=1;break;\n\t\t\t\tcase 1:masu[1][i]+=0;break;\n\t\t\t\tcase 2:masu[1][i]+=1;break;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfor(int j=1;j<=m;j++){\n\t\t\t\tif(ura[i][j]==0){\n\t\t\t\t\tif(ura[i+1][j-1]==0){\n\t\t\t\t\t\tmasu[i+1][j-1]+=masu[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tif(ura[i+1][j]!=1){\n\t\t\t\t\t\tmasu[i+1][j]+=masu[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tif(ura[i+1][j+1]==0){\n\t\t\t\t\t\tmasu[i+1][j+1]+=masu[i][j];\n\t\t\t\t\t}\n\t\t\t\t}else if(ura[i][j]==2){\n\t\t\t\t\tif(ura[i+2][j]!=1){\n\t\t\t\t\t\tmasu[i+2][j]+=masu[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cont=0;\n\t\tfor(int i=n;i<=n+1;i++){\n\t\t\tfor(int j=1;j<=m;j++){\n\t\t\t\tcont+=masu[i][j];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",cont);\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  \n  int X, Y;\n  while (cin >> X >> Y, X) {\n    int c[20][20];\n    int dp[20][20] = {};\n    for (int i = 0; i < Y; i++) {\n      for (int j = 0; j < X; j++) {\n        cin >> c[i][j];\n      }\n    }\n    for (int i = 0; i < X; i++) {\n      if (c[0][i] == 0) dp[0][i] = 1;\n    }\n    for (int i = 0; i < Y - 1; i++) {\n      for (int j = 0; j < X; j++) {\n        if (c[i][j] == 0) {\n          if (j > 0 && c[i + 1][j - 1] == 0) dp[i + 1][j - 1] += dp[i][j];\n          if (c[i + 1][j] != 1) dp[i + 1][j] += dp[i][j];\n          if (j + 1 < X && c[i + 1][j + 1] == 0) dp[i + 1][j + 1] += dp[i][j];\n        } else if (c[i][j] == 2 && i + 2 < Y) {\n          if (c[i + 2][j] != 1) dp[i + 2][j] += dp[i][j];\n        }\n      }\n    }\n    int ans = 0;\n    for (int i = 0; i < X; i++) {\n      if (c[Y - 2][i] == 2) ans += dp[Y - 2][i];\n      ans += dp[Y - 1][i];\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\nusing namespace std;\n\nint main() {\n\tint a, b;\n\twhile (cin >> a >> b, a | b) {\n\t\tvector<vector<int>>masu(b + 1, vector<int>(a));\n\t\tvector<vector<int>>suberikata(b + 1, vector<int>(a));\n\t\tfor (int c = 0; c < b; c++) {\n\t\t\tfor (int d = 0; d < a; d++) {\n\t\t\t\tcin >> masu[c][d];\n\t\t\t}\n\t\t}\n\t\tfor (int e = 0; e < b; e++) {\n\t\t\tif (masu[0][e] ==0)suberikata[0][e]++;\n\t\t}\n\t\tfor (int f = 0; f < b-1; f++) {\n\t\t\tfor (int g = 0; g < a; g++) {\n\t\t\t\tswitch (masu[f][g]) {\n\t\t\t\tcase 0:\n\t\t\t\t\tsuberikata[f + 1][g] += suberikata[f][g];\n\t\t\t\t\tif (g > 0&&masu[f+1][g-1]!=2)suberikata[f + 1][g - 1] += suberikata[f][g];\n\t\t\t\t\tif (g < a - 1 && masu[f + 1][g + 1] != 2)suberikata[f + 1][g + 1] += suberikata[f][g];\n\t\t\t\t\tbreak;     \n\t\t\t\tcase 1:break;\n\t\t\t\tcase 2:suberikata[f + 2][g] += suberikata[f][g]; break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint s = 0;\n\t\tfor (int j : suberikata[suberikata.size() - 2]) {\n\t\t\ts += j;\n\t\t}\n\t\tcout << s << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<climits>\n#include<map>\n#include<string>\nusing namespace std;\n\nint X, Y, Fld[17][15], memo[14][15];\n\nint DFS(int y, int x){\n\tif(Fld[y][x] == 1) return 0;\n\tif(y >= Y-1) return 1;\n\tif(Fld[y][x] == 2) return DFS(y+2, x);\n\tif(memo[y][x] != -1) return memo[y][x];\n\tmemo[y][x] = 0;\n\n\tfor(int i = -1; i <= 1; i++){\n\t\tint ny = y+1, nx = x + i;\n\t\tif( nx < 0 || X <= nx || Fld[ny][nx] == 1 || (Fld[ny][nx] == 2 && i != 0) )\n\t\t\tcontinue;\n\t\tmemo[y][x] += DFS(ny, nx);\n\t}\n\n\treturn memo[y][x];\n}\n\nint main(){\n\twhile(cin >> X >> Y, X || Y){\n\t\tfill_n( (int*)Fld, 17*15, 0 );\n\t\tfor(int i = 0; i < Y; i++){\n\t\t\tfor(int j = 0; j < X; j++){\n\t\t\t\tcin >> Fld[i][j];\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tfill_n( (int*)memo, 14*15, -1 );\n\t\tfor(int i = 0; i < X; i++) if(Fld[0][i] == 0) ans += DFS(0, i);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define all(a)  (a).begin(),(a).end()\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define pb push_back\n#define range(i,a,b) for(int (i)=(a);(i)<(b);++(i))\n#define rep(i,n)  range(i,0,n)\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef long long ll;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nint w,h;\nint course[20][20];\nll dp[20][20];\n\nint main(void){\n\twhile(cin >> w >> h,w|h){\n\t\tclr(dp,0);\n\t\trep(i,h)rep(j,w) cin >> course[i][j];\n\t\trep(i,w) if(course[0][i]==0) dp[0][i]=1LL;\n\t\trep(i,h-1)rep(j,w){\n\t\t\tif(course[i][j]==2&&course[i+2][j]!=1) dp[i+2][j]+=dp[i][j];\n\t\t\tif(course[i][j]) continue;\n\t\t\tfor(int nj=j-1;nj<=j+1;++nj){\n\t\t\t\tif(nj<0||w<=nj) continue;\n\t\t\t\tif(course[i+1][nj]==1) continue;\n\t\t\t\tif(j!=nj&&course[i+1][nj]==2) continue;\n\t\t\t\tdp[i+1][nj]+=dp[i][j];\n\t\t\t}\n\t\t}\n\t\t/*\n\t\trep(i,h+1){\n\t\t\trep(j,w) cerr << dp[i][j] << \" \";\n\t\t\tcerr << endl;\n\t\t}*/\n\t\tll ans=0LL;\n\t\trange(i,h-1,h+1)rep(j,w) ans+=dp[i][j];\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<numeric>\nusing namespace std;\n\nint main() {\n\tint x, y;\n\twhile (cin >> x >> y, x, y) {\n\t\tvector<vector<int>> course(y + 2, vector<int>(x + 2, 0));\n\t\tfor (int i = 1; i <= y; i++) {\n\t\t\tfor (int j = 1; j <= x; j++) {\n\t\t\t\tcin >> course[i][j];\n\t\t\t}\n\t\t}\n\n\t\tvector<vector<int>> path(y + 2, vector<int>(x + 2, 0));\n\t\t//?????????????????????????????????1????????????\n\t\tfor (int i = 1; i <= x; i++) {\n\t\t\tif (course[1][i] != 1) path[1][i] = 1;\n\t\t}\n\n\t\tfor (int i = 1; i <= y; i++) {\n\t\t\tfor (int j = 1; j <= x; j++) {\n\t\t\t\t//????????????????????´????????????????????´??????????????????????????????????????????\n\t\t\t\t//?????????????§????????????????????????´?????????????????????????????£????????°?????´????????????????????????\n\t\t\t\tif (course[i][j] == 0) {\n\t\t\t\t\tif (course[i + 1][j + 1] == 0) path[i + 1][j + 1] += path[i][j];\n\t\t\t\t\tif (course[i + 1][  j  ] != 1) path[i + 1][  j  ] += path[i][j];\n\t\t\t\t\tif (course[i + 1][j - 1] == 0) path[i + 1][j - 1] += path[i][j];\n\t\t\t\t}\n\t\t\t\t//?¬???????????????´???????????£????????°????????????????????????????????????\n\t\t\t\t//?????????????????£????????§??´??????????????´???????????????(?????£?????????????????????????????´???????????????)\n\t\t\t\tif (course[i][j] == 2 && course[i+2][j] != 1) {\n\t\t\t\t\tpath[i + 2][j] += path[i][j];\n\t\t\t\t\tif(i + 2 > y && i != y) path[y][j] += path[i][j];\n\t\t\t\t}\n\t\t\t\t//???????????´???????????????????????????????????????\n\t\t\t\tif(course[i][j] == 1){/*do anything*/}\n\t\t\t}\n\t\t}\n\n\t\tcout << accumulate(path[y].begin()+1, path[y].end()-1, 0) << endl;\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n \nint main(){\n        int x,y;\n        while(cin>>x>>y,x){\n                int D[16][16],P[16][16],ans=0;\n                for(int i=0;i<256;i++)P[i/16][i%16]=0;\n                for(int i=0;i<y;i++)for(int j=0;j<x;j++)cin>>D[i][j];\n                for(int i=0;i<x;i++)if(!D[0][i])P[0][i]=1;\n                for(int i=0;i<y-1;i++){\n                        for(int j=0;j<x;j++){\n                                if(!D[i][j]){\n                                        P[i+1][j]+=P[i][j];\n                                        if(j>0 && !D[i + 1][j - 1])P[i+1][j-1]+=P[i][j];\n                                        if(j<x-1 && !D[i + 1][j + 1])P[i+1][j+1]+=P[i][j];\n                                }\n                                if(D[i][j]==2){\n//                                        if(i+2>y-1)P[i+1][j]+=P[i][j];\n                                        P[i+2][j]+=P[i][j];\n                                }\n                        }\n                }\n                for(int i=0;i<x;i++){\n                    if (D[y - 1][i] != 1) ans+=P[y-1][i];\n                    if (y >= 2 && D[y - 2][i] == 2) ans += P[y - 2][i];\n                }\n                cout<<ans<<endl;\n        }\n}\n "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n\nint main(){\n\tint map[20][20];\n\tint ans_map[20][20];\n\tint x,y;\n\twhile(cin>>x>>y,(x!=0)&&(y!=0)){\n\t\tlong int ans=0;\n\t\tfor(int i=0;i<y;i++){\n\t\t\tfor(int j=0;j<x;j++){\n\t\t\t\tcin>>map[i][j];\n\t\t\t\tans_map[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<x;i++){\n\t\t\tans_map[y][i]=0;\n\t\t}\n\t\tfor(int i=0;i<x;i++){\n\t\t\tif(map[0][i]==0){\n\t\t\t\tans_map[0][i]=1;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i+1<y;i++){\n\t\t\tfor(int j=0;j<x;j++){\n\t\t\t\tif(map[i][j]==2){\n\t\t\t\t\tif(i+2<y){\n\t\t\t\t\t\tans_map[i+2][j]+=ans_map[i][j];\n\t\t\t\t\t}else{\n\t\t\t\t\t\tans_map[y][j]+=ans_map[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tans_map[i][j]=0;\n\t\t\t\t}else if(map[i][j]==1){\n\t\t\t\t\tans_map[i][j]=0;\n\t\t\t\t}else{ \n\t\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\t\tif((j+k<0)||(j+k>x-1)){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(map[i+1][j+k]==0){\n\t\t\t\t\t\t\t\tans_map[i+1][j+k]+=ans_map[i][j];\n\t\t\t\t\t\t\t}else if((k==0)&&(map[i+1][j+k]==2)){\n\t\t\t\t\t\t\t\tans_map[i+1][j+k]+=ans_map[i][j];\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<x;i++){\n\t\t\tans_map[y][i]+=ans_map[y-1][i];\n\t\t}\n\t\tfor(int i=0;i<x;i++){\n\t\t\tans+=ans_map[y][i];\n\t\t}\n\t\tcout<<ans<<endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\nint w,h;\nint s[40][40];\nint dp[40][40];\nint dx[]={-1,0,1};\nint ret(int y,int x){\n\tif(y>=h-1){\n\t\tif(h-1==y&&s[y][x]==1)\n\t\treturn 0;\n\t\treturn 1;\n\t}\n\tif(dp[y][x]!=-1)\n\treturn dp[y][x];\n\tif(s[y][x]==1)\n\t\treturn dp[y][x]=0;\n\tif(s[y][x]==2){\n\t\treturn dp[y][x]=ret(y+2,x);\n\t}\n\tint ans=0;\n\tfor(int i=0;i<3;i++){\n\t\tint nx=dx[i]+x;\n\t\tif(nx>=w||nx<0)\n\t\t\tcontinue;\n\t\t\n\t\tif(s[y+1][nx]==0){\n\t\t\tans+=ret(y+1,nx);\n\t\t}else if(s[y+1][nx]==2){\n\t\t\tif(i!=1)\n\t\t\t\tcontinue;\n\t\t\tans+=ret(y+1,nx);\n\t\t}\n\t}\n\treturn dp[y][x]=ans;\n}\nint main(){\n\twhile(cin>>w>>h,w||h){\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tfor(int i=0;i<h;i++)\n\t\tfor(int j=0;j<w;j++)\n\t\tcin>>s[i][j];\n\t\tint ans=0;\n\t\tfor(int i=0;i<w;i++){\n\t\t\t//if(s[0][i]==0)\n\t\t\t\tans+=ret(0,i);\n\t\t}\n\t\tcout<<dp[3][0]<<endl;\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nint width,height;\nvector< vector<int> > m;\nvector< vector<int> > mm;\n\nint Get(int y,int x);\n\nint main(){\n\tint self;\n\twhile(scanf(\"%d\",&width) != EOF){\n\t\tscanf(\"%d\",&height);\n\t\tif(width == 0 && height == 0){\n\t\t\tbreak;\n\t\t}\n\t\t//printf(\"%d:%d\\n\",width,height);\n\t\tm.clear();\n\t\tmm.clear();\n\t\t\n\t\tfor(int j=0;j<height;j++){\n\t\t\tvector<int> v;\n\t\t\tfor(int i=0;i<width;i++){\n\t\t\t\tscanf(\"%d\",&self);\n\t\t\t\tv.push_back(self);\n\t\t\t}\n\t\t\tm.push_back(v);\n\t\t}\n\t\tfor(int j=0;j<=height;j++){\n\t\t\tvector<int> vv;\n\t\t\tfor(int i=0;i<width;i++){\n\t\t\t\tvv.push_back(0);\n\t\t\t}\n\t\t\tmm.push_back(vv);\n\t\t}\n\t\t\n\t\t/*\n\t\tfor(int j=0;j<height;j++){\n\t\t\tfor(int i=0;i<width;i++){\n\t\t\t\tprintf(\"%d \",m[j][i]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\t*/\n\t\t\n\t\tint xx,yy;\n\n\t\tfor(int y = 0; y <= height; y ++){\n\t\t\tfor(int x = 0; x < width; x ++){\n\t\t\t\txx = x;\n\t\t\t\tyy = y - 1;\n\t\t\t\tif(y == height){\n\t\t\t\t\tmm[y][x] += mm[yy][xx];\n\t\t\t\t\tyy = y - 2;\n\t\t\t\t\tif(yy >= 0){\n\t\t\t\t\t\tif(m[yy][xx] == 2){\n\t\t\t\t\t\t\tmm[y][x] += mm[yy][xx];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tswitch(m[y][x]){\n\t\t\t\t\t\tcase 0: //ó\n\t\t\t\t\t\t\tif(yy == -1){\n\t\t\t\t\t\t\t\tmm[y][x] = 1;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tmm[y][x] += Get(yy,xx-1) + Get(yy,xx) + Get(yy,xx+1);\n\t\t\t\t\t\t\t\tyy = y - 2;\n\t\t\t\t\t\t\t\tif(yy >= 0){\n\t\t\t\t\t\t\t\t\tif(m[yy][xx] == 2){\n\t\t\t\t\t\t\t\t\t\tmm[y][x] += mm[yy][xx];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1: //áQ¨\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2: //Wvä\n\t\t\t\t\t\t\tmm[y][x] += Get(yy,xx);\n\t\t\t\t\t\t\tyy = y - 2;\n\t\t\t\t\t\t\tif(yy >= 0){\n\t\t\t\t\t\t\t\tif(m[yy][xx] == 2){\n\t\t\t\t\t\t\t\t\tmm[y][x] += mm[yy][xx];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\t/*\n\t\tfor(int j=0;j<=height;j++){\n\t\t\tfor(int i=0;i<width;i++){\n\t\t\t\tprintf(\"%d\t\",mm[j][i]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\t*/\n\t\tint ans = 0;\n\t\tfor(int i=0;i<width;i++){\n\t\t\tans += mm[height][i];\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}\n\nint Get(int y,int x){\n\tif(y >= height){ return 0; }\n\tif(x >= width){ return 0; }\n\tif(y < 0){ return 0; }\n\tif(x < 0){ return 0; }\n\tif(m[y][x] == 2){ return 0; }\n\treturn mm[y][x];\n}"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Problem     : AOJ0203\n// Title       : A New Plan of Aizu Ski Resort (会津山スキー場の新企画)\n// Author      : mizo0203\n// Status      : Accepted\n// Date        : Wed May 30 15:25:20\n// Copyright   : Your copyright free\n// Description : 動的計画法\n//============================================================================\n\n#include <stdio.h>\n#include <algorithm>\n\nusing namespace std;\n\nint x, y;\nint c[17][17];  // 最大15+2\n\nint dp[17][17]; // 動的計画法の計算用\n\nbool input() {\n  int i, j;\n  scanf(\"%d %d\", &x, &y);\n  if (!x && !y) return false; // x = 0 かつ y = 0 なら終了\n  fill(c[0], c[0] + 17 * 17, 1); // 配列cを1(木)で初期化\n  for (i = 1; i <= y; i++) {\n    for (j = 1; j <= x; j++) {\n      scanf(\"%d\", &c[i][j]);\n    }\n  }\n\n  return true;\n}\n\nvoid manage() {\n  int i, j, output = 0;\n\n  fill(dp[0], dp[0] + 17 * 17, 0); // 計算用配列を初期化\n  for (i = 1; i <= x; i++) {\n    if (c[1][i] != 1) dp[1][i] = 1;\n  }\n\n  for (i = 1; i < y; i++) {\n    for (j = 1; j <= x; j++) {\n      if (dp[i][j]) {\n        if (c[i][j] == 0) {\n          if (c[i + 1][j - 1] == 0) dp[i + 1][j - 1] += dp[i][j];\n          if (c[i + 1][j    ] == 0) dp[i + 1][j    ] += dp[i][j];\n          if (c[i + 1][j + 1] == 0) dp[i + 1][j + 1] += dp[i][j];\n          if (c[i + 1][j    ] == 2) dp[i + 1][j    ] += dp[i][j];\n        } else if (c[i][j] == 2) {\n          if (c[i + 2][j] == 0) dp[i + 2][j] += dp[i][j];\n          if (c[i + 2][j] == 2) dp[i + 2][j] += dp[i][j];\n        }\n      }\n    }\n  }\n  /*\n  printf(\"\\n\");\n  for (i = 0; i < 17; i++) {\n    for (j = 0; j < 17; j++) {\n      printf(\"%d \", dp[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n  */\n  for (i = 1; i <= x; i++) {\n    if (c[y - 1][i] == 2) output += dp[y - 1][i];\n    output += dp[y][i];\n  }\n  printf(\"%d\\n\", output);\n}\n\n\nint main() {\n\n  while(input()) {\n    manage();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\nint X,Y,imap[20][20];\nconst int dx[3] = {-1,0,1};\nconst int dy[3] = {1,1,1};\nint sam,dp[20][20];\n\nint solve(){\n  \n  int ans = 0;\n  for(int i=0;i<=Y;i++)for(int j=0;j<=X;j++)dp[i][j] = (i==0 && imap[i][j] != 1)?1:0; \n\n  for(int i=0;i<Y-1;i++){\n    for(int j=0;j<X;j++){\n      if(dp[i][j] == 0 || imap[i][j] == 1)continue;\n      if(imap[i][j] == 0){\n\tfor(int k=0;k<3;k++){\n\t  int nx = j+dx[k],ny = i+dy[k];\n\t  if(0<= nx && nx<X && 0<= ny && ny < Y && imap[ny][nx] != 1){\n\t      if((k == 0 || k == 2) && imap[ny][nx] == 2)continue;\n\t      dp[ny][nx]+=dp[i][j];\n\t  }\n\t}\n      }\n      else if(imap[i][j] == 2){\n\tif(i+2 < Y && imap[i+2][j] != 1){\n\t  dp[i+2][j]+=dp[i][j];\n\t}\n\telse if(i+2 >= Y){\n\t  //if(imap[Y-1][j] != 1)\n\t    dp[Y-1][j]+=dp[i][j];\n\t}\n      }\n    }\n  }\n  /*\n  cout << endl;\n    for(int i=0;i<Y;i++){\n      for(int j=0;j<X;j++)cout << dp[i][j] << \" \";\n\tcout << endl;\n    }\n  */\n    for(int i=0;i<X;i++)ans += dp[Y-1][i];\n    return ans;\n}\n\n\n\nbool Init(){\n  cin >> X >> Y;\n  if(X+Y == 0)return false;\n  for(int i=0;i<Y;i++){\n    for(int j=0;j<X;j++){\n      cin >> imap[i][j];\n    }\n  }\n  sam = 0;\n  return true;\n}\n\n\n\nint main(){\n  while(true){\n    if(!Init())break;\n    cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint DP[17][17];\nint field[17][17];\nint x,y;\n\nint main(){\n\twhile(true){\n\t\tcin >> x >> y;\n\t\tif(!x && !y)\n\t\t\treturn 0;\n\t\t\n\t\tfor(int i=1; i<=y; i++)\n\t\t\tfor(int k=1; k<=x; k++)\n\t\t\t\tcin >> field[i][k];\n\t\tfor(int i=1; i<=x; i++)\n\t\t\tfield[y+1][i] = 0;\n\t\t\n\t\tfor(int i=1; i<=y+1; i++)\n\t\t\tfor(int k=0; k<=x+1; k++){\n\t\t\t\tDP[i][k]=0;\n\t\t\t\tif(i==1 && k>0 && k<=x)\n\t\t\t\t\tif(field[i][k] == 0)\n\t\t\t\t\t\tDP[i][k] = 1;\n\t\t\t}\n\t\t\n\t\tfor(int i=2; i<=y; i++){\n\t\t\tfor(int k=1; k<=x; k++){\n\t\t\t\tif(field[i][k] == 0)\n\t\t\t\t\tDP[i][k] += DP[i-1][k-1] + DP[i-1][k] + DP[i-1][k+1];\n\t\t\t\telse if(field[i][k] == 2)\n\t\t\t\t\tint n = i+2;\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\tif(field[n][k] == 0){\n\t\t\t\t\t\t\tDP[n][k] += DP[i-1][k];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else if(field[n][k] == 1)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tn+=2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans=0;\n\t\tfor(int i=y; i<=y+1; i++)\n\t\t\tfor(int k=1; k<=x; k++)\n\t\t\t\tans += DP[i][k];\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<math.h>\nint main(void)\n{\n\tint a,s,d[20][20],f,j,i,k;\n\tlong long int g,h[20][20];\n\twhile(1){\n\t\tscanf(\"%d %d\",&a,&s);\n\t\tif(a==0&&s==0) break;\n\t\tfor(i=0;i<s;i++) h[0][i]=1;\n\t\tfor(i=0;i<a;i++){\n\t\t\tfor(j=0;j<s;j++) scanf(\"%d\",&d[i][j]);\n\t\t}\n\t\tfor(i=0;i<s;i++){\n\t\t\tif(d[0][i]==1) h[0][i]=0;\n\t\t}\n\t\tfor(i=1;i<a;i++){\n\t\t\tfor(j=0;j<s;j++) h[i][j]=0;\n\t\t}\n\t\tfor(i=0;i<a;i++){\n\t\t\tfor(j=0;j<s;j++){\n\t\t\t\tif(i!=0&&d[i][j]==2){\n\t\t\t\t\tif(i+2<a){\n\t\t\t\t\t\tif(d[i+2][j]!=1) h[i+2][j]+=h[i][j];\n\t\t\t\t\t}\n\t\t\t\t\telse h[i+1][j]+=h[i][j];\n\t\t\t\t}\n\t\t\t\tif(d[i][j]==0){\n\t\t\t\t\tif(j!=0) if(d[i+1][j-1]==0) h[i+1][j-1]+=h[i][j];\n\t\t\t\t\tif(j!=s){\n\t\t\t\t\t\tif(d[i+1][j+1]==0) h[i+1][j+1]+=h[i][j];\n\t\t\t\t\t\tif(d[i+1][j]==0||d[i+1][j]==2) h[i+1][j]+=h[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tg=0;\n\t\tfor(j=0;j<s;j++) g+=h[a-1][j];\n\t\t/*printf(\"\\n\\n\");\n\t\tfor(i=0;i<a;i++){\n\t\t\tfor(j=0;j<s;j++) printf(\"%d \",h[i][j]);\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\tprintf(\"%d\\n\",g);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n\nint X, Y;\nint field[15][15];\nint dp[15][15];\n\nint main()\n{\n\twhile( std::cin >> X >> Y, X | Y )\n\t{\n\t\tmemset( field, -1, sizeof( field ) );\n\t\tmemset( dp, 0, sizeof( dp ) );\n\n\t\tfor( int i = 0; i != Y; ++i )\n\t\t\tfor( int j = 0; j != X; ++j )\n\t\t\t\tstd::cin >> field[i][j];\n\n\t\tfor( int i = 0; i != X; ++i )\n\t\t\tif( field[0][i] != 1 )\n\t\t\t\tdp[0][i] = 1;\n\t\t\n\t\tfor( int i = 1; i != Y; ++i )\n\t\t{\n\t\t\tfor( int j = 0; j != X; ++j )\n\t\t\t{\n\t\t\t\tif( i < Y && field[i][j] != 1 )\n\t\t\t\t{\n\t\t\t\t\tfor( int k = -1; k <= 1; ++k )\n\t\t\t\t\t{\t\n\t\t\t\t\t\tif( field[i][j] == 2 && k )\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tif( j + k >= 0 && j + k < X && !field[i-1][j+k] )\n\t\t\t\t\t\t\tdp[i][j] += dp[i-1][j+k];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif( i - 2 >= 0 && field[i][j] != 1 && field[i-2][j] == 2 )\n\t\t\t\t\tdp[i][j] += dp[i-2][j];\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tint ans = 0;\n\t\tfor( int j = 0; j != X; ++j )\n\t\t{\n\t\t\tans += dp[Y-1][j];\n\n\t\t\tif( Y >= 2 && field[Y-2][j] == 2 )\n\t\t\t\tans += dp[Y-2][j];\n\t\t}\n\n\t\tstd::cout << ans << std::endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define MAX 15\n\nusing namespace std;\n\nint a,b,cnt,ans;\nint ski[MAX + 1][MAX];\n\nint compute(int y,int x){\n\n  if( a - 1 <= y ) return ++cnt;\n\n  if( ski[y][x] == 2 ) compute( y + 2 , x );\n  else if( ski[y + 1][x] == 2 ) compute( y + 3 , x );\n  if( ski[y][x] != 2 ){\n    if( !ski[y + 1][x - 1] && ( 0 <= x - 1 && x - 1 < b ) ) compute( y + 1 , x - 1 );\n    if( !ski[y + 1][x + 1] && ( 0 <= x + 1 && x + 1 < b ) ) compute( y + 1 , x + 1 );\n    if( !ski[y + 1][x] ) compute( y + 1 , x );\n  }\n  \n  return cnt;\n}\n\n\n\nint main(void){\n\n  while( cin >> a >> b , a || b ){\n\n    for( int i = 0 ; i < a ; i++ )\n      for( int j = 0 ; j < b ; j++ )\n\tcin >> ski[i][j];\n\n    ans = 0;\n    for( int i = 0 ; i < b ; i++ ){\n      cnt = 0;\n      if( !ski[0][i] ){\n\tint c = compute( 0 , i );\n\t//\tcout << c << endl;\n\tans += c;\n      }\n    }\n    cout << ans << endl;\n\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nint main(void){\n\tint X,Y;\n\t\n\twhile(scanf(\"%d%d\", &X, &Y) && X && Y){\n\t\tint masu[32][32]={0};\n\t\tint co[32][32]={0};\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < Y; i++){\n\t\t\tfor(int j = 0; j < X; j++){\n\t\t\t\tscanf(\"%d\", &masu[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < X; i++){\n\t\t\tco[0][i] = 1;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < Y-1; i++){\n\t\t\tfor(int j = 0; j < X; j++){\n\t\t\t\tif(masu[i][j] == 0){\n\t\t\t\t\tif(masu[i+1][j] != 1)co[i+1][j] += co[i][j];\n\t\t\t\t\tif(masu[i+1][j+1] == 0)co[i+1][j+1] += co[i][j];\n\t\t\t\t\tif(masu[i+1][j-1] == 0 && j-1 > -1)co[i+1][j-1] += co[i][j];\n\t\t\t\t}else if(masu[i][j] == 2){\n\t\t\t\t\tco[i+2][j] += co[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < X; i++){\n\t\t\tco[Y][i] += co[Y-1][i];\n\t\t}\n\t\t\n\t\t\n\t\tfor(int i = 0; i < X; i++){\n\t\t\tans += co[Y][i];\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstdio>\n#include<string.h>\n#include<cstring>\n#include<algorithm>\n#include<functional>\n#include<math.h>\n#include<queue>\n#include<ctype.h>\n#define MAX  1000000000\n#define MIN -1000000000\nusing namespace std;\nint i,j;\nint x,y;\nlong long int dp[1000][1000];\nint map[1000][1000];\nint main(void){\n\tscanf(\"%d %d\",&x,&y);\n\twhile(x!=0 && y!=0){\n\t\tfor(i=1;i<=17;i++){\n\t\t\tfor(j=1;j<=15;j++){\n\t\t\t\tdp[i][j]=0;\n\t\t\t\tmap[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=y;i++){\n\t\t\tfor(j=1;j<=x;j++){\n\t\t\t\tscanf(\"%d \",&map[i][j]);\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=x;i++){\n\t\t\tif(map[1][i]!=1){\n\t\t\t\tdp[1][i]=1;\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<y;i++){\n\t\t\tfor(j=1;j<=x;j++){\n\t\t\t\tif(dp[i][j]>0 && map[i][j]!=2){\n\t\t\t\t\tif(map[i+1][j-1]==0){\n\t\t\t\t\t\tif(j-1<0);\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tdp[i+1][j-1]+=dp[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(map[i+1][j]!=1 ){\n\t\t\t\t\t\tif(map[i+1][j]==0){\n\t\t\t\t\t\t\tdp[i+1][j]+=dp[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tint temp;\n\t\t\t\t\t\t\ttemp=i+1;\n\t\t\t\t\t\t\twhile(map[temp][j]==2){\n\t\t\t\t\t\t\t\ttemp+=2;\n\t\t\t\t\t\t\t\tdp[temp][j]+=dp[i][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(map[i+1][j+1]==0){\n\t\t\t\t\t\tif(j+1>x);\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tdp[i+1][j+1]+=dp[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*for(i=1;i<=y+1;i++){\n\t\t\tprintf(\"%d=\",i);\n\t\t\tfor(j=1;j<=x;j++){\n\t\t\t\tprintf(\"%d \",dp[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\tint cnt=0;\n\t\tfor(i=0;i<=1;i++){\n\t\t\tfor(j=1;j<=x;j++){\n\t\t\t\tcnt+=dp[y+i][j];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",cnt);\n\t\tscanf(\"%d %d\",&x,&y);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint dp[20][20];\nint dat[20][20];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<20;i++)\n\t\t\tfor(int j=0;j<20;j++)dp[i][j]=dat[i][j]=0;\n\t\tfor(int i=0;i<b;i++)\n\t\t\tfor(int j=0;j<a;j++)\n\t\t\t\tscanf(\"%d\",&dat[i][j]);\n\t\tfor(int i=0;i<a;i++)if(dat[0][i]!=1)dp[0][i]=1;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(dat[i][j]==0){\n\t\t\t\t\tif(i<b-1&&j&&dat[i+1][j-1]==0)dp[i+1][j-1]+=dp[i][j];\n\t\t\t\t\tif(i<b-1&&j<a-1&&dat[i+1][j+1]==0)dp[i+1][j+1]+=dp[i][j];\n\t\t\t\t\tif(dat[i+1][j]!=1)dp[i+1][j]+=dp[i][j];\n\t\t\t\t}\n\t\t\t\tif(dat[i][j]==2){\n\t\t\t\t\tif(dat[i+2][j]!=1)dp[i+2][j]+=dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=0;\n\t\tfor(int i=b;i<20;i++)\n\t\t\tfor(int j=0;j<a;j++)\n\t\t\t\tret+=dp[i][j];\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main(){\n\tint X,Y;\n\tint d[16][16],p[16][16];\n\tint sum;\n\t\n\twhile(cin>>X>>Y,X){\n\t\tsum=0;\n\t\tfor(int i=1;i<=Y;i++){\n\t\t\tfor(int j=1;j<=X;j++){\n\t\t\t\tcin>>d[j][i];\n\t\t\t\tif(i==1 && d[j][i]==0)p[j][i]=1;\n\t\t\t\telse p[j][i]=0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=1;i<=Y-1;i++){\n\t\t\tfor(int j=1;j<=X;j++){\n\t\t\t\tif(d[j][i]==0){\n\t\t\t\t\tif(j>1)if(d[j-1][i+1]==0)p[j-1][i+1]+=p[j][i];\n\t\t\t\t\tif(j<X)if(d[j+1][i+1]==0)p[j+1][i+1]+=p[j][i];\n\t\t\t\t\tif(d[j][i+1]!=1)p[j][i+1]+=p[j][i];\n\t\t\t\t}\n\t\t\t\telse if(d[j][i]==2){\n\t\t\t\t\tif(i==Y-1 || i==Y){\n\t\t\t\t\t\tsum+=p[j][i];\n\t\t\t\t\t}\n\t\t\t\t\telse if(d[j][i+2]!=1)p[j][i+2]+=p[j][i];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t\tfor(int i=1;i<=X;i++)sum+=p[i][Y];\n\t\tcout<<sum<<endl;\n\t\t\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Header {{{\n// includes {{{\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <unistd.h>\n#include <vector>\n// }}}\nusing namespace std;\n// consts {{{\nstatic const int INF = 1e9;\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n// }}}\n// typedefs {{{\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef pair<int, int> PII;\ntypedef complex<int> P;\n// }}}\n// macros & inline functions {{{\n// syntax sugars {{{\n#define FOR(i, b, e) for (typeof(e) i = (b); i < (e); ++i)\n#define FORI(i, b, e) for (typeof(e) i = (b); i <= (e); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define REPI(i, n) FORI(i, 0, n)\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n// }}}\n// conversion {{{\ninline int toInt(string s) { int v; istringstream sin(s); sin>>v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout<<x; return sout.str(); }\n// }}}\n// array and STL {{{\n#define ARRSIZE(a) ( sizeof(a) / sizeof(a[0]) )\n#define ZERO(a, v) ( assert(v == 0 || v == -1), memset(a, v, sizeof(a)) )\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n#define SIZE(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c, it) for(typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n// }}}\n// bit manipulation {{{\n// singed integers are not for bitwise operations, specifically arithmetic shifts ('>>', and maybe not good for '<<' too)\n#define IS_UNSIGNED(n) (!numeric_limits<typeof(n)>::is_signed)\n#define BIT(n) (assert(IS_UNSIGNED(n)), assert(n < 64), (1ULL << (n)))\n#define BITOF(n, m) (assert(IS_UNSIGNED(n)), assert(m < 64), ((ULL)(n) >> (m) & 1))\ninline int make_mask(ULL upper, ULL lower) { assert(lower < 64 && upper < 64 && lower <= upper); return (BIT(upper) - 1) ^ (BIT(lower) - 1); }\ninline int onbits_count(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int bits_count(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c; }\n// }}}\n// for readable code {{{\n#define EVEN(n) (n % 2 == 0)\n#define ODD(n) (!EVEN(n))\n// }}}\n// debug {{{\n#define dprt(fmt, ...) if (opt_debug) fprintf(stderr, fmt, ##__VA_ARGS__)\n#define darr(a) if (opt_debug) copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n#define darr_range(a, f, t) if (opt_debug) copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n#define dvec(v) if (opt_debug) copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n#define darr2(a, n, m) if (opt_debug) FOR(__i, 0, (n)){ darr_range( (a)[__i], 0, (m) ); }\n#define dvec2(v) if (opt_debug) FOR(__i, 0, v.size()){ dvec( (v)[__i] ); }\n#define WAIT() if (opt_debug) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n#define dump(x) if (opt_debug) cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl;\n#define dumpf() if (opt_debug) cerr << __PRETTY_FUNCTION__ << endl;\n#define dumpv(x) if (opt_debug) cerr << \" [L:\" << __LINE__ << \"] \" << #x << \" = \"; REP(q, (x).size()) cerr << (x)[q] << \" \"; cerr << endl;\n#define where() if (opt_debug) cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl;\n#define show_bits(b, s) if(opt_debug) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n// }}}\n// }}}\n// time {{{\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\n// }}}\n// string manipulation {{{\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\n// }}}\n// geometry {{{\n#define Y real()\n#define X imag()\n// }}}\n// 2 dimentional array {{{\nP dydx4[4] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1) };\nP dydx8[8] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1), P(-1, 1), P(1, 1), P(1, -1), P(-1, -1) };\nint g_height, g_width;\nbool in_field(P p) {\n\treturn (0 <= p.Y && p.Y < g_height) && (0 <= p.X && p.X < g_width);\n}\n// }}}\n// }}}\nbool opt_debug = false;\n\nenum CELL {\n\tNONE,\n\tBLOCK,\n\tJUMP\n};\n\nbool can_go(VVI &course, int y1, int x1, int y2, int x2) {\n\tint width = course[0].size();\n\tint height = course.size();\n\tif (!(0 <= x2 && x2 < width)) {\n\t\treturn false;\n\t}\n\tif (!(0 <= y2 && y2 < height)) {\n\t\treturn false;\n\t}\n\tif (course[y2][x2] == NONE) {\n\t\treturn true;\n\t} else if (course[y2][x2] == BLOCK) {\n\t\treturn false;\n\t} else if (course[y2][x2] == JUMP) {\n\t\tif (x1 == x2) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n}\n\nint main(int argc, char** argv) {\n\tstd::ios_base::sync_with_stdio(false);\n\t// set options {{{\n\tint __c;\n\twhile ( (__c = getopt(argc, argv, \"d\")) != -1 ) {\n\t\tswitch (__c) {\n\t\t\tcase 'd':\n\t\t\t\topt_debug = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tabort();\n\t\t}\n\t}\n\t// }}}\n\n\tint x, y;\n\twhile (cin >> x >> y, x || y) {\n\t\tVVI course(y, VI(x, 0));\n\t\tREP (i, y) {\n\t\t\tREP (j, x) {\n\t\t\t\tcin >> course[i][j];\n\t\t\t}\n\t\t}\n\t\tVVLL combination(y, VLL(x, 0));\n\t\tREP (i, x) {\n\t\t\tif (course[0][i] == NONE) {\n\t\t\t\tcombination[0][i]++;\n\t\t\t}\n\t\t}\n\n\t\tint dx[] = {-1, 0, 1};\n\t\tREP (i, y-1) {\n\t\t\tREP (j, x) {\n\t\t\t\tif (course[i][j] == JUMP) {\n\t\t\t\t\tif (can_go(course, i, j, i+2, j)) {\n\t\t\t\t\t\tcombination[i+2][j] += combination[i][j];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (i == y-2) {\n\t\t\t\t\t\t\tcombination[i+1][j] += combination[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (course[i][j] == NONE) {\n\t\t\t\t\tREP (d, 3) {\n\t\t\t\t\t\tif (can_go(course, i, j, i+1, j+dx[d])) {\n\t\t\t\t\t\t\tcombination[i+1][j+dx[d]] += combination[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// WAIT();\n\t\t\t// dvec2(combination);\n\t\t}\n\n\t\tLL ans = accumulate(combination[y-1].begin(), combination[y-1].end(), 0);\n\t\tcout << ans << endl;\n\t}\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <iomanip>\nusing namespace std;\nint main(){\n\tint x,y;\n\twhile(1){\n\t\tcin >> x >> y;\n\t\tif(x+y==0) break;\n\t\tint a[x][y];\n\t\tfor(int j=0;j<y;j++) for(int i=0;i<x;i++) cin >> a[i][j];\n\t\tlong long d[x][y];\n\t\tfor(int i=0;i<x;i++) d[i][0] = 1 - a[i][0];\n\t\tfor(int j=1;j<y;j++){\n\t\t\tfor(int i=0;i<x;i++){\n\t\t\t\tif(a[i][j]==1) d[i][j] = 0;\n\t\t\t\telse if(a[i][j]==0){\n\t\t\t\t\tif(a[i][j-1]!=2) d[i][j] = d[i][j-1];\n\t\t\t\t\tif(i>0 and a[i-1][j-1]!=2) d[i][j] += d[i-1][j-1];\n\t\t\t\t\tif(i<x-1 and a[i+1][j-1]!=2) d[i][j] += d[i+1][j-1];\n\t\t\t\t\tif(j>1 and a[i][j-2]==2) d[i][j] += d[i][j-2];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\td[i][j] = d[i][j-1];\n\t\t\t\t\tif(j>1 and a[i][j-2]==2) d[i][j] += d[i][j-2];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong long s = 0;\n\t\tfor(int i=0;i<x;i++){\n\t\t\tif(y>2 and a[i][y-2]==2) s += d[i][y-2];\n\t\t\ts += d[i][y-1];\n\t\t}\n\t\tcout << s << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define loop(v, f, l) for(int v = (f), v##_ = (l); v < v##_; ++v)\n\nusing namespace std;\n\ntypedef long long int lint;\nstatic inline int in(){ int x; scanf(\"%d\", &x); return (x); }\nstatic inline lint inl(){ lint x; scanf(\"%lld\", &x); return (x); }\n\nint field[15][15];\nint dp[15][15];\nint x, y;\n\nint calc_pattern()\n{\n\tint pattern = 0;\n\n\tloop(i, 0, x)\n\t{\n\t\tif( field[0][i] != 1 )\n\t\t{\n\t\t\tdp[0][i] = 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdp[0][i] = 0;\n\t\t}\n\t}\n\n\tloop(i, 0, y - 1)\n\t{\n\t\tloop(j, 0, x)\n\t\t{\n\t\t\tif( field[i][j] == 0 )\n\t\t\t{\n\t\t\t\tif( j >= 1 && j < x - 1 )\n\t\t\t\t{\n\t\t\t\t\tdp[i + 1][j - 1] += field[i + 1][j - 1] == 0 ? dp[i][j] : 0;\n\t\t\t\t\tdp[i + 1][j    ] += field[i + 1][j    ] != 1 ? dp[i][j] : 0;\n\t\t\t\t\tdp[i + 1][j + 1] += field[i + 1][j + 1] == 0 ? dp[i][j] : 0;\n\t\t\t\t}\n\t\t\t\telse if( j == 0 )\n\t\t\t\t{\n\t\t\t\t\tdp[i + 1][j    ] += field[i + 1][j    ] != 1 ? dp[i][j] : 0;\n\t\t\t\t\tdp[i + 1][j + 1] += field[i + 1][j + 1] == 0 ? dp[i][j] : 0;\n\t\t\t\t}\n\t\t\t\telse if( j == x - 1 )\n\t\t\t\t{\n\t\t\t\t\tdp[i + 1][j - 1] += field[i + 1][j - 1] == 0 ? dp[i][j] : 0;\n\t\t\t\t\tdp[i + 1][j    ] += field[i + 1][j    ] != 1 ? dp[i][j] : 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if( field[i][j] == 1 )\n\t\t\t{\n\t\t\t\tdp[i][j] = 0;\n\t\t\t}\n\t\t\telse if( field[i][j] == 2 )\n\t\t\t{\n\t\t\t\tif( i != y - 2 )\n\t\t\t\t{\n\t\t\t\t\tdp[i + 2][j] += field[i + 2][j] != 1 ? dp[i][j] : 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpattern += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tloop(i, 0, x)\n\t{\n\t\tpattern += dp[y - 1][i];\n\t}\n\n\treturn pattern;\n}\n\nint main()\n{\n\tint pattern;\n\twhile( 1 )\n\t{\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tif( x == 0 && y == 0 )break;\n\t\t\n\t\tloop(i, 0, 15)\n\t\t{\n\t\t\tloop(j, 0, 15)\n\t\t\t{\n\t\t\t\tfield[i][j] = 0;\n\t\t\t\tdp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tloop(i, 0, y)\n\t\t{\n\t\t\tloop(j, 0, x)\n\t\t\t{\n\t\t\t\tfield[i][j] = in();\n\t\t\t}\n\t\t}\n\n\t\tpattern = calc_pattern();\n\t\tprintf(\"%d\\n\", pattern);\n\t}\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint DP[17][17];\nint field[17][17];\nint x,y;\n\nint main(){\n\twhile(true){\n\t\tcin >> x >> y;\n\t\tif(!x && !y)\n\t\t\treturn 0;\n\t\t\n\t\tfor(int i=1; i<=y; i++)\n\t\t\tfor(int k=1; k<=x; k++)\n\t\t\t\tcin >> field[i][k];\n\t\tfor(int i=1; i<=x; i++)\n\t\t\tfield[y+1][i] = 0;\n\t\t\n\t\tfor(int i=1; i<=y+1; i++)\n\t\t\tfor(int k=0; k<=x+1; k++){\n\t\t\t\tDP[i][k]=0;\n\t\t\t\tif(i==1 && k>0 && k<=x){\n\t\t\t\t\tif(field[i][k] == 0)\n\t\t\t\t\t\tDP[i][k] = 1;\n\t\t\t\t\telse if(field[i][k] == 2){\n\t\t\t\t\t\tDP[i][k] = 0;\n\t\t\t\t\t\tint n = i+2;\n\t\t\t\t\t\twhile(true){\n\t\t\t\t\t\t\tif(field[n][k] == 0){\n\t\t\t\t\t\t\t\tDP[n][k] = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(field[n][k] == 1)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tn+=2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\tfor(int i=2; i<=y; i++){\n\t\t\tfor(int k=1; k<=x; k++){\n\t\t\t\tif(field[i][k] == 0)\n\t\t\t\t\tDP[i][k] += DP[i-1][k-1] + DP[i-1][k] + DP[i-1][k+1];\n\t\t\t\telse if(field[i][k] == 1)\n\t\t\t\t\tDP[i][k] = 0;\n\t\t\t\telse{\n\t\t\t\t\tDP[i][k] = 0;\n\t\t\t\t\tint n = i+2;\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\tif(field[n][k] == 0){\n\t\t\t\t\t\t\tDP[n][k] += DP[i-1][k];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else if(field[n][k] == 1)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tn+=2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans=0;\n\t\tfor(int i=y; i<=y+1; i++)\n\t\t\tfor(int k=1; k<=x; k++)\n\t\t\t\tans += DP[i][k];\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nint grid[30][30];\n\ninline bool isAtObstacle(int x, int y) {\n  return grid[y][x] == 1;\n}\n\ninline bool isAtSkiJump(int x, int y) {\n  return grid[y][x] == 2;\n}\n\nint main() {\n  int n, m;\n  \n  while(cin >> n >> m && n) {\n    fill(grid[0], grid[0]+900, 0);\n    for(int i=0; i<n; i++) {\n      for(int j=0; j<m; j++) {\n\tcin >> grid[i][j];\n      }\n    }\n    \n    long long dp[30][30][2] = {};\n    \n    for(int j=0; j<m; j++) {\n      if(grid[0][j]==0) { dp[0][j][0] = 1; }\n    }\n    \n    for(int i=0; i<n-1; i++) {\n      for(int j=0; j<m; j++) {\n\t\n\t// there is no case such that skier is at obstacle.\n\tif(isAtObstacle(j, i)) continue;\n\t\n\t// A skier is at a ski jump.\n\tif(isAtSkiJump(j, i)) {\n\t  if(i+2>n-1) dp[n-1][j][0] += dp[i][j][0];\n\t  else {\n\t    if(!isAtObstacle(j, i+2)) {\n\t      dp[i+2][j][0] += dp[i][j][0];\n\t    }\n\t  }\n\t}\n\t\n\t// skiing without jump.\n\telse {\n\t  // from the upper left\n\t  if( j-1 >= 0\n\t      && !isAtObstacle(j-1, i+1)\n\t      && !isAtSkiJump (j-1, i+1) ) {\n\t    dp[i+1][j-1][1] += dp[i][j][0] + dp[i][j][1];\n\t  }\n\t  \n\t  // from the above\n\t  if( !isAtObstacle(j, i+1) ) {\n\t    dp[i+1][j][0] += dp[i][j][0] + dp[i][j][1];\n\t  }\n\t  \n\t  // from the upper right\n\t  if( j+1 < m\n\t      && !isAtObstacle(j+1, i+1)\n\t      && !isAtSkiJump (j+1, i+1) ) {\n\t    dp[i+1][j+1][1] += dp[i][j][0] + dp[i][j][1];\n\t  }\n\t}\n\t\n      }\n    }\n    \n    int ans = 0;\n    for(int i=0; i<m; i++) {\n      ans += dp[n-1][i][0] + dp[n-1][i][1];\n    }\n    \n    cout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<list>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint f(int a[][15],int b[][15],int x,int y,int e,int n){\n  int z=0;\n  if(y>e-1)\n    return 1;\n  if(a[x][y]==-1)\n    return 0;\n  if(a[x][y]==-2){\n    if(n)\n      return 0;\n  }\n  if(y==e-1){\n    if(a[x][y]==0)\n      return 1;\n    if(a[x][y]==-2){\n      if(n==0)\n\treturn 1;\n    }\n  }\n  if(b[x][y]!=-1)\n    return b[x][y];\n  if(a[x][y]==-2)\n    z+=f(a,b,x,y+2,e,0);\n  else{\n    z+=f(a,b,x-1,y+1,e,1);\n    z+=f(a,b,x,y+1,e,0);\n    z+=f(a,b,x+1,y+1,e,1);\n  }\n  b[x][y]=z;\n  return z;\n}\nint main(){\n  int i,j;\n  int a[17][15],b[17][15],x,y,z;\n  memset(a,-1,sizeof(a));\n  while(cin>>x>>y&&x&&y){\n    for(i=0;i<y;i++){\n      for(j=0;j<x;j++){\n\tcin>>a[j+1][i];\n\ta[j+1][i]*=-1;\n      }\n    }\n    memset(b,-1,sizeof(b));\n    z=0;\n    for(i=0;i<x;i++){\n      if(a[i+1][0]!=-1)\n\tz+=f(a,b,i+1,0,y,0);\n    }\n    cout<<z<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n#define MAX 15\n#define BLANK 0\n#define TREE 1\n#define JUMP 2\n\nint main(){\n int field[MAX+2][MAX+2],pass[MAX+2][MAX+2];\n int X,Y,i,j,n;\n for(i=0;i<MAX+2;i++){\n   field[i][0]=TREE;\n   field[i][1]=TREE;\n   field[0][i]=TREE;\n   field[MAX+1][i]=TREE;\n }\n while(cin>>X>>Y,X|Y){\n  for(j=2;j<Y+2;j++)for(i=1;i<X+1;i++)cin>>field[i][j];\n  for(j=2;j<Y+2;j++)for(i=1;i<X+1;i++)pass[i][j]=0;\n  for(j=0;j<Y+2;j++)field[X+1][j]=TREE;\n  for(i=0;i<X+2;i++)pass[i][2]=1;\n  for(j=2;j<Y+2;j++){\n   for(i=1;i<X+1;i++){\n    if(field[i][j]==TREE)continue;\n    if(field[i][j]==JUMP){\n     if(field[i][j-1]==BLANK)pass[i][j]+=pass[i][j-1];\n     if(field[i][j-2]==JUMP)pass[i][j]+=pass[i][j-2];\n     continue;\n    }\n    if(field[i-1][j-1]==BLANK)pass[i][j]+=pass[i-1][j-1];\n    if(field[i][j-1]==BLANK)pass[i][j]+=pass[i][j-1];\n    if(field[i+1][j-1]==BLANK)pass[i][j]+=pass[i+1][j-1];\n    if(field[i][j-2]==JUMP)pass[i][j]+=pass[i][j-2];\n   }\n  }\n  n=0;\n  for(i=1;i<X+1;i++){\n   if(field[i][Y]==JUMP)n+=pass[i][Y];\n   n+=pass[i][Y+1];\n  }\n/*\nfor(j=2;j<Y+2;j++){\nfor(i=1;i<X+1;i++)\n{\ncout<<pass[i][j]<<\" \";\n}\ncout<<endl;\n}\n*/\n  cout<<n<<endl;\n }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nint main() {\n\tint x, y;\n\twhile (cin >> x >> y, x * y) {//\n\t\tint skimap[15][15] = {};//x = j y = i\n\t\tint dp[15][15] = {};//x = j y = i\n\t\tint flyover = 0;//??´????£??????????????????????\n\t\tfor (int i = 0; i < y; i++) {\n\t\t\tfor (int j = 0; j < x; j++) {\n\t\t\t\tcin >> skimap[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < x; i++){\n\t\t\tif (skimap[0][i] == 0)dp[0][i] = 1;\n\t\t}\n\t\tfor (int i = 0; i < y - 1; i++) {\n\t\t\tfor (int j = 0; j < x; j++) {\n\t\t\t\tif (skimap[i][j] == 0) {\n\t\t\t\t\tif (j - 1 >= 0) {\n\t\t\t\t\t\tif (skimap[i + 1][j - 1] == 0) {\n\t\t\t\t\t\t\tdp[i + 1][j - 1] += dp[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (skimap[i + 1][j] != 1)dp[i + 1][j] += dp[i][j];\n\t\t\t\t\tif (j + 1 < x) {\n\t\t\t\t\t\tif (skimap[i + 1][j + 1] == 0) {\n\t\t\t\t\t\t\tdp[i + 1][j + 1] += dp[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (skimap[i][j] == 1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}else {\n\t\t\t\t\tif (i + 2 < y && skimap[i + 2][j] != 1) {\n\t\t\t\t\t\tdp[i + 2][j] = dp[i][j];\n\t\t\t\t\t}else {\n\t\t\t\t\t\tflyover += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint sum = flyover;\n\t\tfor (int i = 0; i < x; i++) {\n\t\t\tsum += dp[y - 1][i];\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <list>\n#include <iostream>\n#include <sstream>\n#include <climits>\n#include <cfloat>\n#include <complex>\n\nusing namespace std;\n\nint main()\n{\n\tint x, y;\n\twhile (scanf(\"%d %d\", &x, &y), x | y)\n\t{\n\t\tint topo[15 + 1][15 + 2];\n\t\tmemset(topo, 0, sizeof(topo));\n\t\tfor (int i = 0; i < y; ++i)\n\t\t\tfor (int j = 1; j <= x; ++j)\n\t\t\t\tscanf(\"%d\", &topo[i][j]);\n\n\t\tint dp[15 + 1][15 + 2];\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tfor (int i = 1; i <= x; ++i)\n\t\t\tif (topo[0][i] != 1)\n\t\t\t\tdp[0][i] = 1;\n\n\t\tfor (int i = 0; i < y-1; ++i)\n\t\t{\n\t\t\tfor (int j = 1; j <= x; ++j)\n\t\t\t{\n\t\t\t\tif (topo[i][j] == 0)\n\t\t\t\t{\n\t\t\t\t\tfor (int k = -1; k <= 1; ++k)\n\t\t\t\t\t\tif (topo[i+1][j+k] != 1 && (topo[i+1][j+k] == 0 || k == 0))\n\t\t\t\t\t\t\tdp[i+1][j+k] += dp[i][j];\n\t\t\t\t}\n\t\t\t\telse if (topo[i][j] == 2 && topo[i+2][j] != 1)\n\t\t\t\t\tdp[i+2][j] += dp[i][j];\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 1; i <= x; ++i)\n\t\t\tans += dp[y-1][i] + dp[y][i];\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdlib>\n#include <cstdio>\nusing namespace std;\n\n#define NONE 0\n#define TREE 1\n#define JUMP 2\n\nint dp[17][17];\nint area_state[17][17];\nint h,w;\n\nint solve(int y, int x){\n\n\tif (dp[y][x] != -1)\n\t\treturn dp[y][x];\n\tif (x == 0 || x == w+1){\n\t\tdp[y][x] = 0;\n\t\treturn 0;\n\t}\t\n\tif (y == h || y == h+1){\n\t\tdp[y][x] = 1;\n\t\treturn 1;\n\t}\n\n\tif (area_state[y][x] == TREE){\n\t\treturn 0;\n\n\t}else if (area_state[y][x] == JUMP){\n\t\tdp[y][x] = (solve(y+2, x));\n\t\treturn dp[y][x];\n\n\t}else if (area_state[y][x] == NONE){\n\t\tif(y == h-1){\n\t\t\tdp[y][x] = 1;\n\t\t\treturn 1;\n\t\t}\n\t\tint left = 0;\n\t\tint right = 0;\n\n\t\tif(area_state[y+1][x-1] != JUMP){\n\t\t\tleft = solve(y+1,x-1);\n\t\t}\n\t\tif(area_state[y+1][x+1] != JUMP){\n\t\t\tright =  solve(y+1,x+1);\n\t\t}\n\t\tdp[y][x] =  left + solve(y+1,x) + right;\n\t\treturn dp[y][x];\n\t}\n}\n\n\nint main() {\n\twhile (cin >> w >> h && w&&h ){ \n\t\tfill( dp[0], dp[17], -1);\n\t\tfill( area_state[0], area_state[17], 0);\n\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tint zone;\n\t\t\t\tcin >> zone;\n\t\t\t\tarea_state[i][j+1] = zone;\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor(int i = 1; i < w+1; i++){\n\t\t\tans += solve(0,i);\n\t\t}\n\n\t\t// cout << endl;\n\n\t\t// for(int i = 0; i < h+2; i++){\n\t\t// \tfor(int j = 0; j < w+2; j++){\n\t\t// \t\tprintf(\"%4d\",area_state[i][j]);\n\t\t// \t}\n\t\t// \tcout << endl;\n\t\t// }\n\t\t// cout << endl;\n\n\t\t// for(int i = 0; i < h+2; i++){\n\t\t// \tfor(int j = 0; j < w+2; j++){\n\t\t// \t\tprintf(\"%4d\",dp[i][j]);\n\t\t// \t}\n\t\t// \tcout << endl;\n\t\t// }\n\t\t\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 2011/07/31 Tazoe\n\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n\twhile(true){\n\t\tint X, Y;\n\t\tcin >> X >> Y;\n\t\tif(X==0&&Y==0)\n\t\t\tbreak;\n\n\t\tint C[18][17];\n\t\tfor(int i=0; i<=Y+2; i++)\n\t\t\tfor(int j=0; j<=X+1; j++)\n\t\t\t\tC[i][j] = 1;\n\n\t\tfor(int i=1; i<=Y; i++)\n\t\t\tfor(int j=1; j<=X; j++)\n\t\t\t\tcin >> C[i][j];\n\n\t\tfor(int i=Y+1; i<=Y+2; i++)\n\t\t\tfor(int j=1; j<=X; j++)\n\t\t\t\tC[i][j] = 0;\n\n\t\tint DP[18][17];\n\t\tfor(int i=0; i<=Y+2; i++)\n\t\t\tfor(int j=0; j<=X+1; j++)\n\t\t\t\tDP[i][j] = 0;\n\n\t\t\tfor(int j=1; j<=X; j++)\n\t\t\t\tif(C[1][j]==0)\n\t\t\t\t\tDP[1][j] = 1;\n\n\t\tfor(int i=1; i<=Y-1; i++)\n\t\t\tfor(int j=1; j<=X; j++)\n\t\t\t\tif(C[i][j]==0){\n\t\t\t\t\tfor(int k=j-1; k<=j+1; k++)\n\t\t\t\t\t\tif(C[i+1][k]==0){\n\t\t\t\t\t\t\tDP[i+1][k] += DP[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(C[i+1][k]==1){\n\t\t\t\t\t\t\tDP[i+1][k] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(C[i+1][k]==2){\n\t\t\t\t\t\t\tif(k==j)\n\t\t\t\t\t\t\t\tDP[i+1][k] += DP[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(C[i][j]==1){\n\t\t\t\t\tDP[i][j] = 0;\n\t\t\t\t}\n\t\t\t\telse if(C[i][j]==2){\n\t\t\t\t\tif(C[i+2][j]==1)\n\t\t\t\t\t\tDP[i+2][j] = 0;\n\t\t\t\t\telse\n\t\t\t\t\t\tDP[i+2][j] += DP[i][j];\n\t\t\t\t}\n\n\t\t\tfor(int j=1; j<=X; j++)\n\t\t\t\tif(C[Y][j]==1){\n\t\t\t\t\tDP[Y][j] = 0;\n\t\t\t\t}\n\n\t\tint sum = 0;\n\t\tfor(int i=Y; i<=Y+1; i++)\n\t\t\tfor(int j=1; j<=X; j++)\n\t\t\t\tsum += DP[i][j];\n\n\t\tcout << sum <<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint solve(int x,int y);\nint ax,ay;\nint mas[16][16];\nint memo[16][16];\nint main(){\n  while(1){\n    int ans=0;\n    for(int i=0;i<16;i++){\n      for(int j=0;j<16;j++){\n\tmemo[i][j]=0;\n      }\n    }\n    cin>>ax>>ay;\n    if(ax==0 && ay==0){\n      break;\n    }\n    for(int i=0;i<ay;i++){\n      for(int j=0;j<ax;j++){\n\tcin>>mas[i][j];\n      }\n    }\n    for(int i=0;i<ax;i++){\n      if(mas[0][i]!=1){\n\tans+=solve(i,0);\n      }\n    }\n    cout<<ans<<endl;\n  }\n}\nint solve(int x,int y){\n  if(memo[y][x]!=0){\n    return memo[y][x];\n  }\n  else if(y==ay){\n    return 1;\n  }else if(mas[y][x]==1){\n    return 0;\n  }else if(mas[y][x]==2){\n    return solve(x,y+2);\n  } \n  else{\n    int anss=0; \n    if(mas[y+1][x]!=1){\n      anss+=solve(x,y+1);\n    }\n    if(x+1<ax && mas[y+1][x+1]==0 && y+1!=ay){\n      anss+=solve(x+1,y+1);\n    }\n    if(0<=x-1 && mas[y+1][x-1]==0 && y+1!=ay){\n      anss+=solve(x-1,y+1);\n    }\n    return memo[y][x]=anss;\n  }\n}  "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define reep(i,f,t) for(int i=f ; i<int(t) ; ++i)\n#define rep(i,n) reep(i, 0, n) \n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nint main()\n{\n\tint w, h;\n\twhile(scanf(\"%d%d\", &w, &h), w){\n\t\tvvi field(h+1, vi(w, 0));\n\t\trep(i, h) rep(j, w)\n\t\t\tscanf(\"%d\", &field[i][j]);\n\t\t\n\t\tvvi dp(h+1, vi(w));\n\t\trep(i, w)\n\t\t\tdp[0][i] = field[0][i] == 0;\n\t\t\n\t\treep(i, 1, h+1){\n\t\t\trep(j, w){\n\t\t\t\tif(field[i][j] == 1){\n\t\t\t\t\tdp[i][j] = 0;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(i<h){\n\t\t\t\t\t\tconst int dx[] = {-1, 0, 1};\n\t\t\t\t\t\trep(k, 3){\n\t\t\t\t\t\t\tint px = j + dx[k];\n\t\t\t\t\t\t\tif(px<0 || w<=px || field[i-1][px] != 0 || (field[i][j]==2 && dx[k]!=0))\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tdp[i][j] += dp[i-1][px];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(i>=2 && field[i-2][j] == 2)\n\t\t\t\t\t\tdp[i][j] += dp[i-2][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint sum = 0;\n\t\trep(i, 2) rep(j, w)\n\t\t\tsum += dp[h-i][j];\n\t\tprintf(\"%d\\n\", sum);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint w,h;\nint mp[20][20];\nint memo[20][20];\nint ans;\nint count;\n\nint saiki(int x,int y) {\n  count++;\n  // cout << x <<\" \"<<y <<endl;\n  int dx[3] = {-1,0,1};\n  int dy[3] = {1,1,1};\n  \n  if(y >= h-1) ans++,memo[y][x]++;//,cout <<\"ok\"<<endl;  \n  else if(mp[y][x] != 1) {\n    for(int i=0;i<3;i++) {\n      int nx = dx[i]+x;\n      int ny = dy[i]+y;\n      if(nx <0|| nx >= w || memo[ny][nx] == -1) continue;\n      \n      if(memo[ny][nx] > 0 && mp[ny][nx] == 0) {\n\tans += memo[ny][nx];\n\tmemo[y][x] += memo[ny][nx];\n      }  \n      else if(x == nx && memo[ny][nx] == 2 && memo[ny][nx] > 0) {\n\tans += memo[ny][nx];\n\tmemo[y][x] += memo[ny][nx];\n      }\n      else if(mp[ny][nx] == 0){\n\tsaiki(nx,ny);\n\tif(memo[ny][nx] > 0) memo[y][x] += memo[ny][nx];\n      } \n      else if(nx==x && mp[ny][nx] == 2){\n\tint ty = ny;\n\twhile(mp[ty][nx] == 2) ty+=2;\n\tif(mp[ny][nx] == 0)saiki(nx,ty);\n\tif(memo[ty][nx] > 0) memo[y][x] += memo[ty][nx];\n      } \n    }\n    if(memo[y][x] == 0) memo[y][x] = -1;\n  }\n}\n\n\nint main() {\n\n  while(1) {\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n\n    for(int i=0;i<=19;i++) \n      for(int j=0;j<=19;j++){ \n\tmemo[i][j] = 0;\n\tmp[i][j] = 0;\n      }\n    \n    for(int i=0;i<h;i++) \n      for(int j=0;j<w;j++) \n\tcin >> mp[i][j];\n\n    /*\n      for(int i=0;i<h;i++) {\n      for(int j=0;j<w;j++) \n      cout << mp[i][j];\n      cout << endl;\n      }\n    */\n\n    ans = 0;\n    count = 0;\n    for(int i=0;i<w;i++) {\n      if(mp[0][i] !=1) saiki(i,0);\n    }\n\n    int ans2 = 0;\n    for(int i=0;i<w;i++) \n      if(memo[0][i] > 0) ans2+=memo[0][i];\n\n    cout << ans << endl;\n    //    cout << ans2 << endl;\n    //cout << count << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nint main() {\n  while (true) {\n    int x, y;\n    cin >> x >> y;\n    if (x == 0 && y == 0) break;\n    int c[20][20];\n    rep (i, y) rep (j, x) cin >> c[i][j];\n    long long dp[20][20][3] = {};\n    rep (i, x) if (c[0][i] == 0) dp[0][i][1] = 1;\n    rep (i, y - 1) rep (j, x) {\n      if (c[i][j] == 0) {\n\tlong long sum = dp[i][j][0] + dp[i][j][1] + dp[i][j][2];\n\tif (j > 0 && c[i + 1][j - 1] != 2) dp[i + 1][j - 1][0] += sum;\n\tdp[i + 1][j][1] += sum;\n\tif (c[i + 1][j + 1] != 2) dp[i + 1][j + 1][2] += sum;\n      } else if (c[i][j] == 2) {\n\tdp[i + 2][j][1] += dp[i][j][1];\n      }\n    }\n    long long res = 0;\n    rep (i, x) if (c[y - 1][i] != 1) rep (k, 3) res += dp[y - 1][i][k];\n    rep (i, x) res += dp[y][i][1];\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<cstring>\n#include<string>\nusing namespace std;\nint X,Y;\nint fie[20][20];\nint dp[20][20];\nint dx[]={-1,0,1};\nint solve(int x,int y){\n  if(dp[x][y]!=-1) return dp[x][y];\n  if(y>=Y-1) return dp[x][y]=1;\n  if(fie[x][y]==2 && fie[x][y+2]!=1){\n    return dp[x][y]=solve(x,y+2);\n  }\n  int ret=0;\n  for(int i=0;i<3;i++){\n    int nx=x+dx[i];\n    if(nx < 0 || nx >= X) continue;\n    if(fie[nx][y+1]==1) continue;\t \n    if(i==1){\n      ret += solve(nx,y+1);\n    }else{\n      if(fie[nx][y+1]==2) continue;\n      ret += solve(nx,y+1);\n    }\n  }\n  return dp[x][y]=ret;\n}\nmain(){\n  while(1){\n    cin >> X >> Y;\n    if(X==0 && Y==0) break;\n    memset(fie,0,sizeof(fie));\n    for(int i=0;i<Y;i++)\n      for(int j=0;j<X;j++) cin >> fie[j][i];\n    memset(dp,-1,sizeof(dp));\n    int res=0;\n    for(int i=0;i<X;i++){\n      if(fie[i][0]==0)\n\tres += solve(i,0);\n    }\n    cout << res << endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint X, Y, c[20][20], dp[20][20];\nint dx[3] = {-1, 0, 1};\n\nint main()\n{\n  while (cin >> X >> Y && (X && Y)) {\n    \n    for (int i = 1; i <= Y; i++)\n      for (int j = 1; j <= X; j++)\n        cin >> c[i][j];\n    \n    for (int x = 1; x <= X; x++) {\n      dp[Y + 1][x] = dp[Y + 2][x] = 1;\n      if (c[Y][x] == 1) {\n        dp[Y][x] = 0;\n      } else {\n        dp[Y][x] = 1;\n      }\n    }\n    \n    for (int y = Y - 1; y >= 1; y--) {\n      for (int x = 1; x <= X; x++) {\n        dp[y][x] = 0;\n        if (c[y][x] == 2) {\n          dp[y][x] += dp[y + 2][x];\n        } else if (c[y][x] == 0) {\n          for (int k = 0; k < 3; k++) {\n            int nx = x + dx[k];\n            if (nx >= 1 && nx <= X) {\n              if (nx != x) {\n                if (c[y + 1][nx] == 0) {\n                  dp[y][x] += dp[y + 1][nx];\n                }\n              } else {\n                if (c[y + 1][nx] != 1) {\n                  dp[y][x] += dp[y + 1][nx];\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    int res = 0;\n    for (int x = 1; x <= X; x++) \n      res += dp[1][x];\n\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,a,n) for(int i=a;i<n;i++)\n#define repb(i,a,b) for(int i=a;i>=b;i--)\n#define all(a) a.begin(),a.end()\n#define o(a) cout<<a<<endl\n#define int long long\n#define fi first\n#define se second\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n\n\nsigned main() {\n\tint y, x;\n\twhile (1) {\n\t\tcin >> y >> x;\n\t\tif (y + x == 0) break;\n\t\tint d[20][20] = { 1 };\n\t\trep(i, 0, y) {\n\t\t\trep(j, 0, x) {\n\t\t\t\tcin >> d[i][j];\n\t\t\t}\n\t\t}\n\t\tint dp[20][20] = { 0 };\n\t\trep(i, 0, x) {\n\t\t\tif (d[0][i] == 0) dp[0][i] = 1;\n\t\t}\n\t\trep(i, 0, y) {\n\t\t\trep(j, 0, x) {\n\t\t\t\tif (d[i][j] == 1) continue;\n\t\t\t\tif (d[i][j] == 2 && d[i + 2][j] != 1) {\n\t\t\t\t\tdp[i + 2][j] += dp[i][j];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\trep(k, -1, 2) {\n\t\t\t\t\tif (0 <= j + k&& j + k < x && d[i + 1][j + k] == 0) {\n\t\t\t\t\t\tdp[i + 1][j + k] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (d[i + 1][j] == 2) {\n\t\t\t\t\tdp[i + 1][j] += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*cout << endl;\n\t\trep(i, 0, y + 2) {\n\t\t\trep(j, 0, x) {\n\t\t\t\tcout << dp[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t\tint ans = 0;\n\t\trep(i, 0, x) {\n\t\t\tans += dp[y - 1][i];\n\t\t\tif (d[y - 2][i] == 2) {\n\t\t\t\tans += dp[y - 2][i];\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nint m[500][500];\nint dp[500][500];\n\nint dx[]={-1,0,1};\n\nint solve(int r,int c){\n  rep(i,r+1)rep(j,c)dp[i][j]=0;\n  rep(j,c)if(m[0][j] == 0)dp[0][j]=1;\n\n  rep(i,r-1){\n    rep(j,c){\n      if (m[i][j] == 0){\n\trep(k,3){\n\t  int nex = j+dx[k];\n\t  if (nex<0||nex>=c)continue;\n\t  if (m[i+1][nex] == 0)dp[i+1][nex]+=dp[i][j];\n\t  else if (m[i+1][nex] == 2 && k == 1)dp[i+1][nex]+=dp[i][j];\n\t}\n      }else if (m[i][j] == 2){\n\tdp[i+2][j]+=dp[i][j];\n      }\n    }\n  }\n  \n  int ans = 0;\n  rep(j,c)ans+=dp[r][j]+dp[r-1][j];\n  return ans;\n}\n\nmain(){\n  int c,r;\n  while(cin>>c>>r && r){\n    rep(i,r)rep(j,c)cin>>m[i][j];\n    rep(j,c)m[r][j]=0;\n    cout << solve(r,c) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MP make_pair\n#define PB push_back\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define REP(i,n) for (int i=0;i<(n);i++)\nint X,Y;\nint fld[15][15];\nlong long dp[15][15];\nint main() {\n\twhile(cin>>X>>Y&&X&&Y){\n\t\tfor(int i=0;i<Y;i++)for(int j=0;j<X;j++)cin>>fld[j][i];\n\t\tlong long ans=0;\n\t\tfor(int i=0;i<X;i++)for(int j=0;j<Y;j++)dp[i][j]=0;\n\t\tfor(int i=0;i<X;i++)if(fld[i][Y-1]!=1)dp[i][Y-1]=1;\n\t\tfor(int y=Y-2;y>=0;y--){\n\t\t\tfor(int x=0;x<X;x++){\n\t\t\t\tif(fld[x][y]==0){\n\t\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\t\tint nx=x+k;\n\t\t\t\t\t\tif(nx<0||nx>=X)continue;\n\t\t\t\t\t\tif(nx==x&&fld[nx][y+1]!=1)dp[x][y]+=dp[nx][y+1];\n\t\t\t\t\t\telse if(fld[nx][y+1]==0)dp[x][y]+=dp[nx][y+1];\n\t\t\t\t\t}\n\t\t\t\t}else if(fld[x][y]==2){\n\t\t\t\t\tif(y+2>=Y)dp[x][y]=1;\n\t\t\t\t\telse dp[x][y]=dp[x][y+2];\n\t\t\t\t}\n\t\t\t\tif(y==0)ans+=dp[x][y];\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nint map[15][15];\n\nint count[15][15];\n\nint main () {\n\n\twhile(true) {\n\t\tint w, h;\n\t\tcin >> w >> h;\n\n\t\tif ( w == 0 )\n\t\t\tbreak;\n\t\n\t\tfor ( int i=0; i<h; i++ ) {\n\t\t\tfor ( int j=0; j<w; j++ ) {\n\t\t\t\tcin >> map[i][j];\n\t\t\t}\n\t\t}\n\n\t\tfor ( int i=1; i<h; i++ ) {\n\t\t\tfor ( int j=0; j<w; j++ ) {\n\t\t\t\tcount[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor ( int i=0; i<w; i++ ) {\n\t\t\tif ( map[0][i] != 1 )\n\t\t\t\tcount[0][i] = 1;\n\t\t}\n\n\t\tfor ( int i=1; i<h; i++ ) {\n\t\t\tfor ( int j=0; j<w; j++ ) {\n\t\t\t\tif ( map[i][j] != 1 ) {\n\t\t\t\t\tif ( map[i][j] != 2 ) {\n\t\t\t\t\t\tif ( j-1 >= 0 ) {\n\t\t\t\t\t\t\tif ( map[i-1][j-1] == 0 ) {\n\t\t\t\t\t\t\t\tcount[i][j] += count[i-1][j-1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( j+1 < w ) {\n\t\t\t\t\t\t\tif ( map[i-1][j+1] == 0 ) {\n\t\t\t\t\t\t\t\tcount[i][j] += count[i-1][j+1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( map[i-1][j] == 0 ) {\n\t\t\t\t\t\tcount[i][j] += count[i-1][j];\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( i-2 >= 0 ) {\n\t\t\t\t\t\tif ( map[i-2][j] == 2 ) {\n\t\t\t\t\t\t\tcount[i][j] += count[i-2][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tfor ( int i=0; i<h; i++ ) {\n\t\t\tfor ( int j=0; j<w; j++ ) {\n\t\t\t\tcout << count[i][j] << \"\\t\";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;\n\t\t\n\t\tint sum = 0;\n\n\t\tfor ( int i=0; i<w; i++ ) {\n\t\t\tsum += count[h-1][i];\n\t\t}\n\n\t\tfor ( int i=0; i<w; i++ ) {\n\t\t\tif ( map[h-2][i] == 2 )\n\t\t\t\tsum += count[h-2][i];\n\t\t}\n\n\t\tcout << sum << endl;\n\t}\n}\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint dp[20][20];\nint dat[20][20];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<b;i++)\n\t\t\tfor(int j=0;j<a;j++)\n\t\t\t\tscanf(\"%d\",&dat[i][j]);\n\t\tfor(int i=0;i<20;i++)\n\t\t\tfor(int j=0;j<20;j++)dp[i][j]=dat[i][j]=0;\n\t\tfor(int i=0;i<a;i++)if(dat[0][i]!=1)dp[0][i]=1;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(dat[i][j]==0){\n\t\t\t\t\tif(i<b-1&&j&&dat[i+1][j-1]==0)dp[i+1][j-1]+=dp[i][j];\n\t\t\t\t\tif(i<b-1&&j<a-1&&dat[i+1][j+1]==0)dp[i+1][j+1]+=dp[i][j];\n\t\t\t\t\tif(dat[i+1][j]!=1)dp[i+1][j]+=dp[i][j];\n\t\t\t\t}\n\t\t\t\tif(dat[i][j]==2){\n\t\t\t\t\tif(dat[i+2][j]!=1)dp[i+2][j]+=dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=0;\n\t\tfor(int i=b;i<20;i++)\n\t\t\tfor(int j=0;j<a;j++)\n\t\t\t\tret+=dp[i][j];\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#define INF 1<<20\nusing namespace std;\n\nint w, h;\nint data[22][22];\nint memo[22][22];\n\nint solve(int x, int y){\n\n  if(x < 0 || x == w || data[y][x]&1) return 0;\n  if(y > h-2) return 1;\n  if(memo[y][x]) return memo[y][x];\n\n  int ret = 0;\n  if(data[y][x] == 2) ret += solve(x, y+2);\n  else{\n    if(x && !data[y+1][x-1]) ret += solve(x-1, y+1);\n    if(!data[y+1][x+1]) ret += solve(x+1, y+1);\n    ret += solve(x, y+1);\n  }\n  \n  return memo[y][x] = ret;\n}\n\nint main(){\n\n  while(cin >> w >> h, w+h){\n\n    for(int i=0;i<h;i++) for(int j=0;j<w;j++) cin >> data[i][j];\n\n    int ans = 0;\n    for(int i=0;i<w;i++){\n      memset(memo, 0, sizeof(memo));\n      ans += solve(i, 0);\n    }\n\n    cout << ans << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint maps[20][20];\nint course[20][20];\nint X, Y;\n\nvoid out();\nint way(int y, int x){\n  if(course[y][x] > 0) return course[y][x];\n  else if(maps[y][x] == 1) return 0;\n  else if(y >= Y) return 1;\n  else if(maps[y][x] == 2 && maps[y + 2][x] != 1) return course[y][x] = way(y + 2, x);\n  else{\n    int SUM = 0;\n    for(int i = 0; i < 3; i++){\n      int ny = y + 1;\n      int nx = x - 1 + i;\n      if(maps[ny][nx] != 1 && 1 <= nx && nx <= X){\n\tint flug = 1;\n\tif(i != 1 && maps[ny][nx] == 2) flug = 0;\n\tif(flug) SUM += way(ny, nx);\n      }\n    }\n    return course[y][x] = SUM;\n  }\n} \n\nint main(){\n  while(1){\n    cin >> X >> Y;\n    if(X == 0 && Y == 0) break;\n    for(int i = 1; i <= Y; i++){\n      for(int j = 1; j <= X; j++){\n\tcin >> maps[i][j];\n\tcourse[i][j] = 0;\n      }\n    }\n    int cnt = 0;\n    for(int i = 1; i <= X; i++){\n      if(maps[0][i] != 1) cnt += way(1, i);\n    }\n    cout << cnt << endl;\n  }\n}\n\nvoid out(){\n  for(int i = 1; i <= Y; i++){\n    for(int j = 1; j <= X; j++){\n      cout << course[i][j] << \" \";\n    }\n    cout << endl;\n  }\n  return;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint solve(int x,int y);\nint ax,ay;\nint mas[200][200];\nlong long memo[200][200];\nint main(){\n  while(1){\n    for(int i=0;i<200;i++){\n      for(int j=0;j<200;j++){\n\tmemo[i][j]=0;\n      }\n    }\n    long long ans=0;\n    cin>>ax>>ay;\n    if(ax==0 && ay==0) break;\n    \n    for(int i=0;i<ay;i++){\n      for(int j=0;j<ax;j++){\n\tcin>>mas[i][j];\n      }\n    }\n    \n    for(int i=0;i<ax;i++){\n      if(mas[0][i]!=1){\n\tans+=solve(i,0);\n      }\n    }\n    cout<<ans<<endl;\n  }\n}\nint solve(int x,int y){\n  if(y>=ay){\n    return 1;\n  }else if(memo[y][x]!=0){\n    return memo[y][x];\n  }else if(mas[y][x]==1){\n    return 0;\n  }else if(mas[y][x]==2){\n    return solve(x,y+2);\n  } \n  else{\n    long long anss=0; \n    if(mas[y+1][x]!=1){\n      anss+=solve(x,y+1);\n    }\n    if(x+1<ax && mas[y+1][x+1]==0 && y+1!=ay){\n      anss+=solve(x+1,y+1);\n    }\n    if(0<=x-1 && mas[y+1][x-1]==0 && y+1!=ay){\n      anss+=solve(x-1,y+1);\n    }\n    return memo[y][x]=anss;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\nusing namespace std;\n\nint maps[20][20];\nint course[20][20];\nint X, Y;\n\nint way(int y, int x){\n  if(course[y][x] > 0) return course[y][x];\n  else if(maps[y][x] == 1) return 0;\n  else if(y >= Y) return 1;\n  else if(maps[y][x] == 2 && maps[y + 2][x] != 1) return course[y][x] = way(y + 2, x);\n  else{\n    int SUM = 0;\n    for(int i = 0; i < 3; i++){\n      int ny = y + 1;\n      int nx = x - 1 + i;\n      if(maps[ny][nx] != 1 && 1 <= nx && nx <= X){\n\tint flug = 1;\n\tif(i != 1 && maps[ny][nx] == 2) flug = 0;\n\tif(flug) SUM += way(ny, nx);\n      }\n    }\n    return course[y][x] = SUM;\n  }\n} \n\nint main(){\n  while(1){\n    cin >> X >> Y;\n    if(X == 0 && Y == 0) break;\n    for(int i = 1; i <= Y; i++){\n      for(int j = 1; j <= X; j++){\n\tcin >> maps[i][j];\n\tcourse[i][j] = 0;\n      }\n    }\n    int cnt = 0;\n    for(int i = 1; i <= X; i++){\n      if(maps[0][i] != 1) cnt += way(1, i);\n    }\n    cout << cnt << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nint dx[3] = {-1, 0, 1};\nint dy[3] = {1, 1, 1};\n\nint main(void)\n{\n\tint **map, f1, f2, f3, **temp, x, y, sum, px, py;\n\t\n\twhile(scanf(\"%d %d\", &x, &y) && y > 0)\n\t{\n\t\tmap = new int *[y];\n\t\ttemp = new int *[y];\n\t\tsum = 0;\n\n\t\t//マップ土地&動的計画作成\n\t\tfor(f1 = 0; f1 < y; f1++)\n\t\t{\n\t\t\tmap[f1] = new int [x];\n\t\t\ttemp[f1] = new int [x];\n\t\t}\n\t\t//マップ構成入力&初期化\n\t\tfor(f1 = 0; f1 < y; f1++)\n\t\t{\n\t\t\tfor(f2 = 0; f2 < x; f2++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\",&map[f1][f2]);\n\t\t\t\ttemp[f1][f2] = 0;\n\t\t\t}\n\t\t}\n\t\t//最上のスタート地点設定\n\t\tfor(f1 = 0; f1 < x; f1++)\n\t\t{\n\t\t\tif(map[0][f1] != 1)\n\t\t\t{\n\t\t\t\ttemp[0][f1] = 1;\n\t\t\t\tsum++;\n\t\t\t}\n\t\t}\n\t\t//探索\n\t\tif(y >= 2)\n\t\t{\n\t\t\tsum = 0;\n\t\t\tfor(f1 = 0; f1 < y - 1; f1++)\n\t\t\t{\n\t\t\t\tfor(f2 = 0; f2 < x; f2++)\n\t\t\t\t{\n\t\t\t\t\tif(map[f1][f2] == 0 && temp[f1][f2] > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(f3 = 0; f3 < 3; f3++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//移動\n\t\t\t\t\t\t\tpx = f2 + dx[f3];\n\t\t\t\t\t\t\tpy = f1 + dy[f3];\n\t\t\t\t\t\t\t//範囲内か\n\t\t\t\t\t\t\tif(px >= 0 && px < x)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t//同じｘ座標からのジャンプ台\n\t\t\t\t\t\t\t\tif(f3 == 1 && py < y - 1){\n\t\t\t\t\t\t\t\t\t//ｙ軸2つ先へ\n\t\t\t\t\t\t\t\t\twhile(py <= y - 1 && map[py][px] == 2)\n\t\t\t\t\t\t\t\t\t\tpy += 2;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t//着地した場所がゴール地点のｙ座標と同じで障害物にぶつかってないか\n\t\t\t\t\t\t\t\t//ゴール地点のｙ座標を超えたか\n\t\t\t\t\t\t\t\tif(py > y - 1 || py == y - 1 &&(f3 != 1 && map[py][px] == 0 || f3 == 1 && map[py][px] != 1))\n\t\t\t\t\t\t\t\t\tsum += temp[f1][f2];\n\t\t\t\t\t\t\t\t//超えてないが、障害物がない地点に着地したか\n\t\t\t\t\t\t\t\telse if(map[py][px] == 0)\n\t\t\t\t\t\t\t\t\ttemp[py][px] += temp[f1][f2];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//出力\n\t\tprintf(\"%d\\n\",sum);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#include <string.h>\n\nusing namespace std;\n\nconst int FIELD_MAX =15;\n\nint X, Y;\nint field[FIELD_MAX][FIELD_MAX];\nint table[FIELD_MAX+1][FIELD_MAX];\nint cnt = 0;\n\ntypedef pair<int, int> point;\n\nvoid solve()\n{\n\tmemset(&table[0][0], 0, sizeof(int) * 15 * 16);\n\tfor(int x=0; x<X; x++)\n\t{\n\t\ttable[Y][x] = 1;\n\t}\n\t\n\tfor(int y=Y; y>=1; y--)\n\t{\t\n\t\tfor(int x=0; x<X; x++){\n\t\t\tint a = 0;\n\t\t\tif(y>=2){\n\t\t\t\tif(field[y-2][x]==2) table[y-2][x]+=table[y][x];\n\t\t\t}\n\t\t\tif(x>=1 && y!=Y && field[y][x] != 2){\n\t\t\t\tif(field[y-1][x-1]==0) table[y-1][x-1]+=table[y][x];\n\t\t\t}\n\t\t\tif(field[y-1][x]==0) table[y-1][x]+=table[y][x];\n\t\t\tif(x<X-1 && y!=Y && field[y][x] != 2){\n\t\t\t\tif(field[y-1][x+1]==0) table[y-1][x+1]+=table[y][x];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcnt = 0;\n\tfor(int x=0; x<X; x++){\n\t\tcnt += table[0][x];\n\t}\n}\n\nint main()\n{\n\twhile( 1 )\n\t{\n\t\tcin >> X >> Y;\n\t\tif(X==0 && Y==0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor(int y=0; y<Y; y++)\n\t\t{\n\t\t\tfor(int x=0; x<X; x++)\n\t\t\t{\n\t\t\t\tcin >> field[y][x];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcnt = 0;\n\t\tsolve();\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint w,h;\nint mp[16][16];\nint ans;\nint count;\n\nint saiki(int x,int y) {\n  count++;\n  // cout << x <<\" \"<<y <<endl;\n  int dx[3] = {-1,0,1};\n  int dy[3] = {1,1,1};\n  if(mp[y][x] == 2) y++;\n  \n  if((y >= h)||(y==h-1 && mp[y][x] != 1)) ans++;//,cout <<\"ok\"<<endl;  \n  else if(mp[y][x] != 1) {\n    for(int i=0;i<3;i++) {\n      int nx = dx[i]+x;\n      int ny = dy[i]+y;\n      if(nx <0||ny <0||nx >= w|| ny>=h) continue;\n      if(mp[ny][nx] == 0){\n      saiki(nx,ny);\n      }\n      else if(nx==x && mp[ny][nx] == 2 ){\n\tsaiki(nx,ny+2);\n      }\n    } \n  }\n}\n\nint main() {\n\n  while(1) {\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n\n    for(int i=0;i<h;i++) \n      for(int j=0;j<w;j++) \n\tcin >> mp[i][j];\n    /*\n    for(int i=0;i<h;i++) {\n      for(int j=0;j<w;j++) \n\tcout << mp[i][j];\n\t  cout << endl;\n    }\n    */\n\n    ans = 0;\n    count = 0;\n    for(int i=0;i<w;i++) {\n      if(mp[0][i] !=1) saiki(i,0);\n    }\n    cout << ans << endl;\n    //cout << count << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\nint w,h;\nint f[22][22];\nint dp[22][22];\nint dx[] = {-1,0,1};\nint solve(int x,int y){\n  //printf(\"(%d,%d) = %d\\n\",x,y,f[x][y]);\n  if(f[x][y] == 1) return 0;\n  if(y >= h){\n    //puts(\"OK ... 1\");\n    return 1;\n  }\n  if(f[x][y] == 1) return 0;\n  if(dp[x][y] >= 0){\n    //printf(\"OK ... %d\\n\",dp[x][y]);\n    return dp[x][y];\n  }\n  if(f[x][y] == 2){\n    //puts(\"Jump\");\n    return dp[x][y] = solve(x,y + 2);\n  }\n\n  int ret = 0;\n  for(int i = 0; i < 3; i++){\n    int nx = x + dx[i];\n    if(!f[nx][y+1] || (!dx[i] && f[nx][y+1] == 2)){\n      ret += solve(nx,y+1);\n    }\n  }\n  return dp[x][y] = ret;\n}\nint main(void){\n  while(1){\n    scanf(\"%d%d\",&w,&h); if(!w) break;\n    memset(f,-1,sizeof(f));\n    memset(dp,-1,sizeof(dp));\n    for(int i = 1; i <= h; i++){\n      for(int j = 1; j <= w; j++){\n\tscanf(\"%d\",&f[j][i]);\n      }\n    }\n    int ans = 0;\n    for(int j = 1; j <= w; j++){\n      ans += solve(j,1);\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nint tt[20][20];\nint dp[20][20][20];\nint W,H;\n\nint rec(int x,int y,int px){\n\tif( x < 0 || x >= W ) return 0;\n\tif( tt[y][x] == 1 ) return 0;\n\tif( y >= H-1 ) return 1;\n\t\n\tif( tt[y][x] == 2 && x != px ) return 0;\n\tif( dp[x][y][px] != -1 ) return dp[x][y][px];\n\tint ans = 0;\n\tif( tt[y][x] == 2 ){\n\t\tans += rec(x,y+2,x);\n\t}else{\n\t\tans += rec(x,y+1,x);\n\t\tans += rec(x+1,y+1,x);\n\t\tans += rec(x-1,y+1,x);\n\t}\n\treturn dp[x][y][px] = ans;\n}\n\nint main(){\n\twhile(cin >> W >> H&&(W||H)){\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tfor(int i = 0 ; i < H ; i++){\n\t\t\tfor(int j = 0 ; j < W ; j++)\n\t\t\t\tcin >> tt[i][j];\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = 0 ; i < W ; i++){\n\t\t\tans += rec(i,0,0);\n\t\t}\n\t\tcout << ans << endl;\n\t\t//return 0;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define ck(a,b) (0<=a&&a<b)\nusing namespace std;\nint dx[]={-1,0,1};\nint main(){\n\tint X,Y,c[15][15],land[15][15],ans;\n\twhile(cin>>X>>Y,X){\n\t\trep(i,Y)rep(j,X)cin>>land[i][j],c[i][j]=i==0&&land[i][j]!=1;\n\t\trep(i,Y-1)rep(j,X)if(land[i+1][j]!=1){\n\t\t\tif(land[i+1][j]==2)c[i+1][j]+=c[i][j];\n\t\t\telse rep(d,3)if(ck(j+dx[d],X)&&land[i][j+dx[d]]==0)\n\t\t\tc[i+1][j]+=c[i][j+dx[d]];\n\t\t\tif(i>0&&land[i-1][j]==2)c[i+1][j]+=c[i-1][j];\n\t\t}\n\t\tans=0;\n\t\trep(i,X){\n\t\t\tans+=c[Y-1][i];\n\t\t\tif(Y>1&&land[Y-2][i]==2)ans+=c[Y-2][i];\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<numeric>\nusing namespace std;\n\nint main() {\n\tint x, y;\n\twhile (cin >> x >> y && (x != 0 && y != 0)) {\n\t\tvector<vector<int>> course(y + 2, vector<int>(x + 2, 0));\n\t\tfor (int i = 1; i <= y; i++) {\n\t\t\tfor (int j = 1; j <= x; j++) {\n\t\t\t\tcin >> course[i][j];\n\t\t\t}\n\t\t}\n\n\t\tvector<vector<int>> path(y + 2, vector<int>(x + 2, 0));\n\t\t//?????????????????????????????????1????????????\n\t\tfor (int i = 1; i <= x; i++) {\n\t\t\tif (course[1][i] != 1) path[1][i] = 1;\n\t\t}\n\n\t\tfor (int i = 1; i <= y; i++) {\n\t\t\tfor (int j = 1; j <= x; j++) {\n\t\t\t\t//????????????????????´????????????????????´??????????????????????????????????????????\n\t\t\t\t//?????????????§????????????????????????´?????????????????????????????£????????°?????´????????????????????????\n\t\t\t\tif (course[i][j] == 0) {\n\t\t\t\t\tif (course[i + 1][j + 1] == 0) path[i + 1][j + 1] += path[i][j];\n\t\t\t\t\tif (course[i + 1][j] != 1) path[i + 1][j] += path[i][j];\n\t\t\t\t\tif (course[i + 1][j - 1] == 0) path[i + 1][j - 1] += path[i][j];\n\t\t\t\t}\n\t\t\t\t//?¬???????????????´???????????£????????°????????????????????????????????????\n\t\t\t\t//?????????????????£????????§??´??????????????´???????????????(?????£?????????????????????????????´???????????????)\n\t\t\t\tif (course[i][j] == 2 && course[i + 2][j] != 1) {\n\t\t\t\t\tpath[i + 2][j] += path[i][j];\n\t\t\t\t\tif (i + 2 > y && i != y) path[y][j] += path[i][j];\n\t\t\t\t}\n\t\t\t\t//???????????´???????????????????????????????????????\n\t\t\t\tif (course[i][j] == 1) {/*do anything*/ }\n\t\t\t}\n\t\t}\n\n\t\tcout << accumulate(path[y].begin() + 1, path[y].end() - 1, 0) << endl;\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <list>\n#include <map>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n\nint main(){\n\twhile(true){\n\t\tint maxX,maxY;\n\t\tcin >> maxX >> maxY;\t\t\tif(!maxX&&!maxY) return 0;\n\n\t\tint tizu[maxX+2][maxY+2];\n\t\tFOR(y,0,maxY+2){\n\t\t\tFOR(x,0,maxX+2){\n\t\t\t\tif(x==0||x==maxX+1||y==0||y==maxY+1){tizu[x][y]=1;continue;};\n\t\t\t\tcin >> tizu[x][y];\n\t\t\t}\n\t\t}\n\n\t\tint dp[maxX+2][maxY+2];\n\t\tFOR(y,0,maxY+2){\n\t\t\tFOR(x,0,maxY+2){\n\t\t\t\tdp[x][y]=0;\n\t\t\t\tif(x==0||x==maxX+1){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(y==0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(y==1){\n\t\t\t\t\tif(tizu[x][y]==0) dp[x][y]+=1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(y==maxY+1){\n\t\t\t\t\tif(tizu[x][y-1]==0) dp[x][y]+=dp[x][y-1];\n\t\t\t\t\tif(tizu[x][y-1]==2) dp[x][y]+=dp[x][y-1];\n\t\t\t\t\tif(tizu[x][y-2]==2) dp[x][y]+=dp[x][y-2];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(tizu[x][y]==0){\n\t\t\t\t\tif(tizu[x-1][y-1]==0) dp[x][y]+=dp[x-1][y-1];\n\t\t\t\t\tif(tizu[x][y-1]==0)   dp[x][y]+=dp[x][y-1];\n\t\t\t\t\tif(tizu[x+1][y-1]==0) dp[x][y]+=dp[x+1][y-1];\n\t\t\t\t\tif(tizu[x][y-2]==2)   dp[x][y]+=dp[x][y-2];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(tizu[x][y]==1){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(tizu[x][y]==2){\n\t\t\t\t\tif(tizu[x][y-1]==0) dp[x][y]+=dp[x][y-1];\n\t\t\t\t\tif(tizu[x][y-2]==2) dp[x][y]+=dp[x][y-2];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n/*\n\t\tFOR(y,0,maxY+2){\n\t\t\tFOR(x,0,maxY+2){\n\t\t\t\tcout << dp[x][y];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n*/\n\n\n\t\tint res = 0;\n\t\tFOR(x,1,maxX+1){ res += dp[x][maxY+1];};\n\t\tcout << res << endl;\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int W, H, mas[16][16];\n  while( cin >> W >> H, W){\n    for(int i = 0; i < H; i++){\n      for(int j = 0; j < W; j++){\n        cin >> mas[i][j];\n      }\n    }\n    vector< vector< int > > dp( H + 1, vector< int >(W, 0));\n    for(int i = 0; i < W; i++){\n      if(mas[0][i] != 1) dp[0][i] = 1;\n    }\n    for(int i = 0; i < H; i++){\n      for(int j = 0; j < W; j++){\n        if(dp[i][j] == 0) continue;\n        if(mas[i][j] == 0){\n          for(int k = -1; k <= 1; k++){\n            if(j + k < 0 || j + k >= W) continue;\n            if((i == H - 1 && k == 0) || (k == 0 && mas[i + 1][j + k] == 2) || (i != H - 1 && mas[i + 1][j + k] == 0)){\n              dp[i + 1][j + k] += dp[i][j];\n            }\n          }\n        } else if(mas[i][j] == 2){\n          if(i >= H - 2 || mas[i + 2][j] != 1){\n            dp[max(H, i + 2)][j] += dp[i][j];\n          }\n        }\n      }\n    }\n\n    int ret = 0;\n    for(int i = 0; i < W; i++){\n      ret += dp[H][i];\n    }\n    cout << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define MAX_XY 15\n\nint x, y;\nint map[MAX_XY + 1][MAX_XY + 1], dp[MAX_XY + 1][MAX_XY + 1];\n\nvoid resetStr();\nvoid makeDp();\nvoid dispAns();\n\nint main(){\n    while(cin >>x >>y){\n        if(x == 0 && y == 0) break;\n        resetStr();\n        for(int i = 0; i < y; i++){\n            for(int j = 0; j < x; j++){\n                cin >>map[i][j];\n            }\n        }\n        makeDp();\n        dispAns();\n    }\n}\n\nvoid resetStr(){\n    for(int i = 0; i <= MAX_XY; i++){\n        for(int j = 0; j <= MAX_XY; j++){\n            map[i][j] = -1;\n            dp[i][j] = 0;\n        }\n    }\n}\n\nvoid makeDp(){\n    int xm[] = {-1, 0, 1}, ym[] = {-1, -1, -1};\n    for(int i = 0; i < x; i++){\n        if(map[0][i] == 0) dp[0][i]++;\n    }\n    for(int i = 1; i < y; i++){\n        for(int j = 0; j < x; j++){\n            if(map[i][j] == 2){\n                dp[i][j] += dp[i - 1][j];\n                int xn = j, yn = i + 2;\n                if(xn >= 0 && yn >= 0 && xn < x && yn < y) dp[yn][xn] = dp[i][j];\n                else dp[y - 1][xn] = dp[i][j];\n            } else if(map[i][j] == 0){\n                for(int k = 0; k < 3; k++){\n                    int xn = j + xm[k], yn = i + ym[k];\n                    if(xn >= 0 && yn >= 0 && xn < x && yn < y && map[yn][xn] == 0) dp[i][j] += dp[yn][xn];\n                }\n            }\n        }\n    }\n}\n\nvoid dispAns(){\n    int ans = 0;\n    for(int i = 0; i < x; i++){\n        ans += dp[y - 1][i];\n    }\n    cout <<ans <<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n\tint n,m;\n\tint masu[17][17];\n\tint ura[17][17];\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0 && m==0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i=0;i<17;i++){\n\t\t\tfor(int j=0;j<17;j++){\n\t\t\t\tmasu[i][j]=0;\n\t\t\t\tura[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=1;j<=m;j++){\n\t\t\t\tscanf(\"%d\",&ura[i][j]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tswitch(ura[1][i]){\n\t\t\t\tcase 0:masu[1][i]+=1;break;\n\t\t\t\tcase 1:masu[1][i]+=0;break;\n\t\t\t\tcase 2:if(ura[3][i]!=1){masu[3][i]+=1;}break;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfor(int j=1;j<=m;j++){\n\t\t\t\tif(ura[i][j]==0){\n\t\t\t\t\tif(ura[i+1][j-1]==0){\n\t\t\t\t\t\tmasu[i+1][j-1]+=masu[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tif(ura[i+1][j]!=1){\n\t\t\t\t\t\tmasu[i+1][j]+=masu[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tif(ura[i+1][j+1]==0){\n\t\t\t\t\t\tmasu[i+1][j+1]+=masu[i][j];\n\t\t\t\t\t}\n\t\t\t\t}else if(ura[i][j]==2){\n\t\t\t\t\tif(ura[i+2][j]!=1){\n\t\t\t\t\t\tmasu[i+2][j]+=masu[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cont=0;\n\t\tfor(int i=n;i<=n+1;i++){\n\t\t\tfor(int j=1;j<=m;j++){\n\t\t\t\tcont+=masu[i][j];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",cont);\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n \nusing namespace std;\n \nconst int MAX = 20;\nint in[MAX][MAX], X,Y,data[MAX][MAX],ans;\nint dx[4] = {-1,0,1};\n \n \nvoid init(){\n  memset(data,0,sizeof(data));\n  ans = 0;\n}\n \n \nvoid solve(){\n  for(int i = 1; i <= Y; i++)\n    for(int j = 1; j <= X; j++){\n      for(int k = 0; k < 3; k++)\n\tif(in[i][j] == 2){\n\t  if(in[i+2][j] != 1) data[i+2][j] += data[i][j];\n\t  break;\n\t}else if(in[i][j] == 0){\n\t  int nex = j+dx[k];\n\t  if(nex < 1 || nex > X) continue;\n\n\t  if(in[i+1][nex] == 2 && dx[k] == 0) data[i+1][nex] += data[i][j];\n\t  if(in[i+1][nex] == 0) data[i+1][nex] += data[i][j];\n\n\t}\n    }\n  \n  for(int j = 1; j <= X; j++){\n    if(Y-1 > 0 && in[Y-1][j] == 2) ans+=data[Y-1][j];\n    ans+=data[Y][j];\n  }\n  cout << ans << endl;\n}\n \nvoid print(){\n  for(int i = 1; i <= Y; i++){\n    for(int j = 1; j <= X; j++)\n      cout << data[i][j]<< \" \";\n    cout << endl;\n  }\n}\nint main(){\n  while(cin >> X >> Y && X+Y){\n    init();\n    for(int i = 1; i <= Y; i++)\n      for(int j = 1; j <= X; j++)\n    cin >> in[i][j];\n     \n    for(int i = 1; i <= X; i++)\n      if(in[1][i] == 0) data[1][i] = 1;\n \n    solve();\n    //print();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <cstring>\n#include <fstream>\n#include <numeric>\n#include <algorithm>\n\nusing namespace std;\n\nint main(int argc, char **argv) {\n  int x, y, field[15 * 15], route[15 * 15], rsum;\n\n  while (true) {\n    cin >> x >> y;\n    if (x == 0 && y == 0)\n      break;\n    rsum = 0;\n    memset(route, 0, sizeof(int) * x * y);\n    for (int i = 0; i < y; i++)\n      for (int j = 0; j < x; j++)\n        cin >> field[i * y + j];\n    for (int i = 0; i < x; i++) {\n      int f = field[i];\n      if (!f)\n        route[i] = 1;\n    }\n\n    for (int i = 1; i < y; i++)\n      for (int j = 0; j < x; j++) {\n        int f = field[i * y + j];\n        if (f == 0) {\n          for (int k = -1; k <= 1; k++)\n            if ((j + k >= 0 && j + k < x) &&\n                ((k == 0 && field[(i-1) * y + j+k] == 2) ||\n                 (field[(i-1) * y + j+k] != 2)))\n              route[i * y + j] += route[(i-1) * y + j+k];\n        } else if (f == 1) {\n          route[i * y + j] = 0;\n        } else if (f == 2 && i + 2 < y && field[(i+2) * y + j] != 1) {\n          route[(i+2) * y + j] = route[(i-1) * y + j];\n        } else if (f == 2 && i + 2 >= y) {\n          rsum += route[(i-1) * y + j];\n        }\n      }\n    for (int i = 0; i < x; i++)\n      rsum += route[(y-1) * y + i];\n\n    cout << rsum << endl;\n    /* FOR DEBUG                                                                                                                                                                                            \n    for (int i = 0; i < y; i++) {                                                                                                                                                                           \n      for (int j = 0; j < x; j++) {                                                                                                                                                                         \n        cout << route[i * y + j];                                                                                                                                                                           \n        cout << ' ';                                                                                                                                                                                        \n      }                                                                                                                                                                                                     \n      cout << endl;                                                                                                                                                                                         \n      }*/\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint main()\n{\n    for(;;){\n        int w, h;\n        cin >> w >> h;\n        if(w == 0)\n            return 0;\n\n        vector<vector<int> > grid(h+1, vector<int>(w+2, 0));\n        for(int i=0; i<h+1; ++i)\n            grid[i][0] = grid[i][w+1] = 1;\n        for(int i=0; i<h; ++i){\n            for(int j=1; j<=w; ++j){\n                cin >> grid[i][j];\n            }\n        }\n\n        vector<vector<int> > num(h+1, vector<int>(w+2, 0));\n        for(int i=1; i<=w; ++i){\n            if(grid[0][i] != 1)\n                num[0][i] = 1;\n        }\n\n        for(int y=0; y<h-1; ++y){\n            for(int x=1; x<=w; ++x){\n                if(grid[y][x] == 2){\n                    num[y+2][x] += num[y][x];\n                }else{\n                    for(int dx=-1; dx<=1; ++dx){\n                        if(grid[y+1][x+dx] == 1 || (grid[y+1][x+dx] == 2 && dx != 0))\n                            continue;\n                        num[y+1][x+dx] += num[y][x];\n                    }\n                }\n            }\n        }\n\n        int ret = accumulate(num[h-1].begin(), num[h-1].end(), 0);\n        ret += accumulate(num[h].begin(), num[h].end(), 0);\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\nint main(){\n\tint x,y;\n\twhile(cin >> x >> y, x|y){\n\t\tvvi field(y,vi(x));\n\t\tREP(i,y){\n\t\t\tREP(j,x){\n\t\t\t\tcin >> field[i][j];\n\t\t\t}\n\t\t}\n\t\tvvi dp(y,vi(x,0));\n\t\tREP(i,y){\n\t\t\tREP(j,x){\n\t\t\t\tif(i==0&&field[i][j]==0){\n\t\t\t\t\tdp[i][j]=1;\n\t\t\t\t}\n\t\t\t\tif(i<y-1&&field[i][j]==0){\n\t\t\t\t\tif(j>0&&field[i+1][j-1]==0){\n\t\t\t\t\t\tdp[i+1][j-1]+=dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tif(j<x-1&&field[i+1][j+1]==0){\n\t\t\t\t\t\tdp[i+1][j+1]+=dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tif(field[i+1][j]!=1){\n\t\t\t\t\t\tdp[i+1][j]+=dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(i<y-2&&field[i][j]==2){\n\t\t\t\t\tif(field[i+2][j]!=1){\n\t\t\t\t\t\tdp[i+2][j]+=dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint result=0;\n\t\tREP(i,x){\n\t\t\tresult+=dp[y-1][i];\n\t\t\tif(field[y-2][i]==2){\n\t\t\t\tresult+=dp[y-2][i];\n\t\t\t}\n\t\t}\n\t\tcout << result << endl;\n\t}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\n#include <iomanip>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nint main()\n{\n\tint X, Y;\n\twhile(cin >> X >> Y && X)\n\t{\n\t\tvector<vint> field(Y, vint(X, 0)), dp(Y, vint(X, 0));\n\t\trep(y, Y) rep(x, X)\n\t\t\tcin >> field[y][x];\n\n\t\trep(x, X)\n\t\t\tdp[0][x] = !field[0][x];\n\n\t\tREP(y, 1, Y) rep(x, X)\n\t\t{\n\t\t\tif(field[y][x] == 1) continue;\n\n\t\t\tif(1 < y && field[y - 2][x] == 2) dp[y][x] = dp[y - 2][x];\n\n\t\t\tif(field[y][x] == 0)\n\t\t\t{\n\t\t\t\tint dx[] = {-1, 0, 1};\n\t\t\t\trep(i, 3)\n\t\t\t\t{\n\t\t\t\t\tint nx = x + dx[i];\n\t\t\t\t\tif(0 <= nx && nx < X && field[y - 1][nx] != 2)\n\t\t\t\t\t\tdp[y][x] += dp[y - 1][nx];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdp[y][x] += dp[y - 1][x];\n\t\t\t}\n\t\t}\n\n\t\tint res = accumulate(ALL(dp[Y-1]), 0);\n\t\t\n\t\tif(1 < Y)rep(x, X)\n\t\t\tres += field[Y-2][x] == 2 ? dp[Y-2][x] : 0;\n\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint w,h;\nint s[40][40];\nint dp[40][40];\nint dx[]={-1,0,1};\nint ret(int y,int x){\n\tif(y>=h-1){\n\t\tif(h-1==y&&s[y][x]==1)\n\t\treturn 0;\n\t\treturn 1;\n\t}\n\tif(dp[y][x]!=-1)\n\treturn dp[y][x];\n\tif(s[y][x]==1)\n\t\treturn dp[y][x]=0;\n\tif(s[y][x]==2){\n\t\treturn dp[y][x]=ret(y+2,x);\n\t}\n\tint ans=0;\n\tfor(int i=0;i<3;i++){\n\t\tint nx=dx[i]+x;\n\t\tif(nx>=w||nx<0)\n\t\t\tcontinue;\n\t\t\n\t\tif(s[y+1][nx]==0){\n\t\t\tans+=ret(y+1,nx);\n\t\t}else if(s[y+1][nx]==2){\n\t\t\tif(i!=1)\n\t\t\t\tcontinue;\n\t\t\tans+=ret(y+1,nx);\n\t\t}\n\t}\n\treturn dp[y][x]=ans;\n}\nint main(){\n\twhile(cin>>w>>h,w||h){\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tfor(int i=0;i<h;i++)\n\t\tfor(int j=0;j<w;j++)\n\t\tcin>>s[i][j];\n\t\tint ans=0;\n\t\tfor(int i=0;i<w;i++){\n\t\t\t//if(s[0][i]==0)\n\t\t\t\tans+=ret(0,i);\n\t\t}\n\t\tcout<<dp[3][0]<<endl;\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nint field[20][20];\nint dp[20][20];\n\nint main()\n{\n  int c1, c2;\n  while (scanf(\" %d %d \", &c1, &c2) == 2) {\n    if (c1 == 0 && c2 == 0) {break;}\n    for (int i = 0; i < 20; i++) {\n      fill(field[i], &field[i][20], 1);\n      fill(dp[i], &dp[i][20], 0);\n    }\n    for (int i = 1; i <= c1; i++) {\n      for (int j = 1; j <= c2; j++) {\n\tscanf(\" %d \", &field[i][j]);\n      }\n    }\n    /*for (int i = 0; i < 20; i++) {\n      for (int j = 0; j < 20; j++) {\n\tprintf(\"%d\", field[i][j]);\n      }\n      printf(\"\\n\");\n      }*/\n    \n    for (int i = 1; i <= c2; i++) {\n      dp[1][i] = 1;\n    }\n    for (int i = 1; i < c1; i++) {\n      for (int j = 1; j <= c2; j++) {\n\tif (field[i][j] == 0) {\n\t  if (field[i + 1][j - 1] != 2) {dp[i + 1][j - 1] += dp[i][j];}\n\t  dp[i + 1][j] += dp[i][j];\n\t  if (field[i + 1][j + 1] != 2) {dp[i + 1][j + 1] += dp[i][j];}\n\t} else if (field[i][j] == 2) {\n\t  dp[i + 2][j] += dp[i][j];\n\t} \n      }\n    }\n    int sum = 0;\n    for (int i = 0; i <= 1; i++) {\n      for (int j = 1; j <= c2; j++) {\n\tif (i != 0 || field[c1 + i][j] != 1) {\n\t  sum += dp[c1 + i][j];\n\t}\n      }\n    }\n    \n    printf(\"%d\\n\", sum);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint w,h;\nint mp[20][20],memo[20][20];\nint dx[] = {-1,0,1};\n\nvoid saiki(int x,int y) {\n  if(y >= h-1) memo[y][x]++;\n  else if(mp[y][x] != 1) {\n    for(int i=0;i<3;i++) {\n      int nx = dx[i]+x, ny = y+1;\n      if(nx <0|| nx >= w ||mp[ny][nx] == 1) continue;\n      if(memo[ny][nx] > 0 && mp[ny][nx] == 0) memo[y][x] += memo[ny][nx];\n      else if(mp[ny][nx] == 0){\n\tsaiki(nx,ny);\n\tmemo[y][x] += memo[ny][nx];\n      }\n      else if(nx==x && mp[ny][nx] == 2){\n\tint ty = ny;\n\twhile(mp[ty][nx] == 2) ty+=2;\n\tif(mp[ty][nx] == 0 && memo[ty][nx] == 0){\n\t  saiki(nx,ty);\n\t  memo[y][x] += memo[ty][nx];\n\t}\n\telse if(mp[ty][nx] == 0 && memo[ty][nx] > 0) memo[y][x] += memo[ty][nx];\n      }\n    }\n    if(memo[y][x] == 0) mp[y][x] = 1;\n  }\n}\n  \nint main() {\n  while(1) {\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n    for(int i=0;i<=19;i++)\n      for(int j=0;j<=19;j++)memo[i][j] = mp[i][j] = 0;\n    \n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)cin >> mp[i][j];\n \n    for(int i=0;i<w;i++) \n      if(mp[0][i] !=1) saiki(i,0);\n    \n    int cnt = 0;\n    for(int i=0;i<w;i++)\n      if(memo[0][i] > 0) cnt+=memo[0][i];\n    cout <<cnt<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <functional>\n#include <numeric>\n#define fi first\n#define se second\nusing namespace std;\nbool value(int y,int x,int R,int C){return 0<=y&&y<R&&0<=x&&x<C;}\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<long long > vll;\ntypedef vector< vi > vvi;\ndouble pie=acos(-1);\nint INF=10000009;\nint dx[4] = { 0,-1,0,1 };\nint dy[4] = { -1,0,1,0 };\nint c[20][20];\nlong long int dp[20][20];\nint main() {\n    int X,Y;\n    while(true){\n        long long int ans=0;\n        cin>>X>>Y;\n        if(X+Y==0) break;\n        for(int i=1;i<=Y;i++){\n            for(int j=1;j<=X;j++){\n                cin>>c[i][j];\n            }\n        }\n        for(int i=1;i<=X;i++){\n            if(c[1][i]==1){\n                dp[1][i]=0;\n            }\n            if(c[1][i]==0){\n                dp[1][i]=1;\n            }\n            if(c[1][i]==2){\n                dp[1][i]=1;\n                dp[3][i]=1;\n            }\n        }\n        for(int i=2;i<=Y;i++){\n            for(int j=1;j<=X;j++){\n                if(c[i][j]==1) dp[i][j]=0;\n                else if(c[i][j]==0){\n                    for(int k=0;k<3;k++){\n                        if(c[i-1][j-1+k]==0){\n                            dp[i][j]+=dp[i-1][j-1+k];\n                        }\n                    }\n                }\n                else{\n                    if(c[i-1][j]==0){\n                        dp[i][j]+=dp[i-1][j];\n                    }\n                    dp[i+2][j]+=dp[i][j];\n                }\n            }\n        }\n        for(int i=Y;i<=Y;i++){\n            for(int j=1;j<=X;j++){\n                ans+=dp[Y][j];\n\t\t\t\tif (c[Y - 1][j] == 2) ans += dp[Y - 1][j];\n            }\n        }\n        for(int i=1;i<=Y+1;i++){\n            for(int j=1;j<=X;j++){\n                dp[i][j]=0;\n            }\n        }\n        printf(\"%lld\\n\",ans );\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nint main(){\n\twhile(true){\n\t\tint X, Y;\n\t\tscanf(\"%d%d\", &X, &Y);\n\t\tif(X == 0 || Y == 0){ break; }\n\t\tint field[16][17] = { { 0 } };\n\t\tfor(int y = 1; y <= Y; y++){\n\t\t\tfor(int x = 1; x <= X; x++){\n\t\t\t\tscanf(\"%d\", &(field[y][x]));\n\t\t\t}\n\t\t}\n\t\tint dp[16][17] = { { 0 } };\n\t\tfor(int x = 1; x <= X; x++){\n\t\t\tif(field[1][x] != 1){ dp[1][x] = 1; }\n\t\t}\n\t\tfor(int y = 2; y <= Y; y++){\n\t\t\tfor(int x = 1; x <= X; x++){\n\t\t\t\tif(field[y][x] == 1){ continue; }\n\t\t\t\tint sum = 0;\n\t\t\t\tif(field[y][x] == 0){\n\t\t\t\t\tif(field[y - 1][x - 1] == 0){ sum += dp[y - 1][x - 1]; }\n\t\t\t\t\tif(field[y - 1][x + 1] == 0){ sum += dp[y - 1][x + 1]; }\n\t\t\t\t}\n\t\t\t\tif(field[y - 1][x] == 0){ sum += dp[y - 1][x]; }\n\t\t\t\tif(field[y - 2][x] == 2){ sum += dp[y - 2][x]; }\n\t\t\t\tdp[y][x] = sum;\n\t\t\t}\n\t\t}\n\t\tint answer = 0;\n\t\tfor(int x = 1; x <= X; x++){\n\t\t\tif(field[Y - 1][x] == 2){ answer += dp[Y - 1][x]; }\n\t\t\tanswer += dp[Y][x];\n\t\t}\n\t\tprintf(\"%d\\n\", answer);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nint w, h, i, j, m[16][16], d[16][16];\nint f(int x,int y){\n\tif(~d[y][x])return d[y][x];\n\tif(m[y][x]==1)return 0;\n\tif(y>=h)return 1;\n\t\n\tint r=0;\n\tif(!m[y][x]){for(int i=-1;i<2;i++)r+=(x+i>0&&x+i<=w&&!(m[y+1][x+i]==2&&i!=0))*f(x+i,y+1);return d[y][x]=r;}\n\treturn d[y][x]=f(x,y+2);\n}\nint main(){\n\twhile(std::cin>>w>>h,w){\n\t\tfor(i=17;--i;)for(j=17;--j;)d[i][j] = -1;\n\t\tfor(;i++<h;)for(j=w;j;j--)std::cin >> m[i][j];\n\t\tfor(int i=w;i;i--)j+=f(i, 1);\n\t\tstd::cout<<j<<'\\n';\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,a,n) for(int i=a;i<n;i++)\n#define repb(i,a,b) for(int i=a;i>=b;i--)\n#define all(a) a.begin(),a.end()\n#define o(a) cout<<a<<endl\n#define int long long\n#define fi first\n#define se second\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n\n\nsigned main() {\n\tint y, x;\n\twhile (1) {\n\t\tcin >> y >> x;\n\t\tif (y + x == 0) break;\n\t\tint d[20][20] = { 0 };\n\t\trep(i, 0, y) {\n\t\t\trep(j, 0, x) {\n\t\t\t\tcin >> d[i][j];\n\t\t\t}\n\t\t}\n\t\tint dp[20][20] = { 0 };\n\t\trep(i, 0, x) {\n\t\t\tif (d[0][i] == 0) dp[0][i] = 1;\n\t\t}\n\t\trep(i, 0, y) {\n\t\t\trep(j, 0, x) {\n\t\t\t\tif (d[i][j] == 1) continue;\n\t\t\t\tif (d[i][j] == 2 && d[i + 2][j] != 1) {\n\t\t\t\t\tdp[i + 2][j] += dp[i][j];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\trep(k, -1, 2) {\n\t\t\t\t\tif (0 <= j + k&& j + k < x && d[i + 1][j + k] == 0) {\n\t\t\t\t\t\tdp[i + 1][j + k] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (d[i + 1][j] == 2) {\n\t\t\t\t\tdp[i + 1][j] += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*cout << endl;\n\t\trep(i, 0, y + 2) {\n\t\t\trep(j, 0, x) {\n\t\t\t\tcout << dp[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t\tint ans = 0;\n\t\trep(i, 0, x) {\n\t\t\tans += dp[y - 1][i];\n\t\t\tif (d[y - 2][i] == 2) {\n\t\t\t\tans += dp[y - 2][i];\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n\n#define reep(i,n,m) for(int i=(n);i<(m);i++)\n#define rep(i,n) reep(i,0,n)\n\nusing namespace std;\n\nint main(){\n    int X,Y;\n    while(cin >> X >> Y,X+Y){\n        int fld[20][20] = {0};\n        rep(y,Y){\n            rep(x,X){\n                cin >> fld[y][x];\n            }\n        }\n\n        int dp[20][20] = {0};\n        rep(x,X){\n            if(fld[0][x] == 0)\n                dp[0][x] = 1;\n        }\n\n        rep(y,Y-1){\n            rep(x,X){\n                int val = dp[y][x];\n                if(fld[y][x] == 0){\n                    if(x>0 && fld[y+1][x-1] != 2){\n                        dp[y+1][x-1] += val;\n                    }\n                    if(fld[y+1][x+1] != 2){\n                        dp[y+1][x+1] += val;\n                    }\n                    dp[y+1][x] += val;\n                }else if(fld[y][x] == 2){\n                    dp[y+2][x] += val;\n                }\n            }\n        }\n\n        int ans = 0;\n        rep(i,2){\n            rep(x,X){\n                if(fld[Y+i-1][x] == 0)\n                    ans += dp[Y+i-1][x];\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\nusing namespace std;\n\nint run[15][15],w,h;\nint memo[15][15];\n\nint ski(int x,int y,bool s)\n{\n\tif(y>=h)\t\t\treturn 1;\n\tif(memo[y][x]!=-1)\treturn memo[y][x];\n\tif(run[y][x]==1)\treturn memo[y][x]=0;\n\tif(run[y][x]==2)\treturn s?ski(x,y+2,true):0;\n\n\tif(y==h-1)\treturn memo[y][x]=1;\n\n\tint cnt=0;\n\tfor(int dx=-1;dx<=1;dx++){\n\t\tint xx=x+dx;\n\t\tif(0<=xx && xx<w)\tcnt+=ski(xx,y+1,!dx);\n\t}\n\treturn memo[y][x]=cnt;\n}\n\nint main()\n{\n\tfor(;scanf(\"%d%d\",&w,&h),w;){\n\t\tfor(int y=0;y<h;y++)\n\t\t\tfor(int x=0;x<w;x++)\n\t\t\t\tscanf(\"%d\",run[y]+x),memo[y][x]=-1;\n\n\t\tint cnt=0;\n\t\tfor(int x=0;x<w;x++)\tcnt+=ski(x,0,true);\n\t\tprintf(\"%d\\n\",cnt);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint w, h, c[15][15];\nint res;\n\nvoid dfs(int x, int y) {\n\tif (y <= h-1 && c[y][x] == 1) return;\n\tif (y >= h-1) {\n\t\t++res;\n\t\treturn;\n\t}\n\tif (c[y][x] == 0) {\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\tint nx = x + i - 1, ny = y + 1;\n\t\t\tif (0 <= nx && nx < w && ((x == nx && c[ny][nx] == 2) || c[ny][nx] == 0)) dfs(nx, ny);\n\t\t}\n\t}\n\tif (c[y][x] == 2) dfs(x, y+2);\n\treturn;\n}\n\nint main(void) {\n\twhile (cin >> w >> h, w && h) {\n\t\tfor (int i = 0; i < h; ++i) {\n\t\t\tfor (int j = 0; j < w; ++j) cin >> c[i][j];\n\t\t}\n\t\tres = 0;\n\t\tfor (int i = 0; i < w; ++i) {\n\t\t\tif (c[0][i] == 0) dfs(i, 0);\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MP make_pair\n#define PB push_back\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define REP(i,n) for (int i=0;i<(n);i++)\nint X,Y;\nint fld[15][15];\nint dp[15][15];\nint main() {\n\twhile(cin>>X>>Y&&X&&Y){\n\t\tfor(int i=0;i<Y;i++)for(int j=0;j<X;j++)cin>>fld[j][i];\n\t\tint ans=0;\n\t\tfor(int i=0;i<X;i++)for(int j=0;j<Y;j++)dp[i][j]=0;\n\t\tfor(int i=0;i<X;i++)if(fld[i][Y-1]!=1)dp[i][Y-1]=1;\n\t\tfor(int y=Y-2;y>=0;y--){\n\t\t\tfor(int x=0;x<X;x++){\n\t\t\t\tif(fld[x][y]==0){\n\t\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\t\tint nx=x+k;\n\t\t\t\t\t\tif(nx<0||nx>=X)continue;\n\t\t\t\t\t\tif(nx==x&&fld[nx][y+1]!=1)dp[x][y]+=dp[nx][y+1];\n\t\t\t\t\t\telse if(fld[nx][y+1]==0)dp[x][y]+=dp[nx][y+1];\n\t\t\t\t\t}\n\t\t\t\t}else if(fld[x][y]==2){\n\t\t\t\t\tif(y+2>=Y)dp[x][y]=1;\n\t\t\t\t\telse dp[x][y]=dp[x][y+2];\n\t\t\t\t}\n\t\t\t\tif(y==0)ans+=dp[x][y];\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint w,h;\nint mp[20][20],memo[20][20];\nint dx[] = {-1,0,1};\n\nvoid saiki(int x,int y) {\n  if(y >= h-1) memo[y][x]++;\n  else if(mp[y][x] != 1) {\n    for(int i=0;i<3;i++) {\n      int nx = x+dx[i], ny = y+1;\n      if(nx==x && mp[ny][nx] == 2)while(mp[ny][nx] == 2) ny+=2;\n      if(nx <0|| nx >= w ||mp[ny][nx] == 1) continue;\n\n      if(mp[ny][nx] == 0){\n\tsaiki(nx,ny);\n\tmemo[y][x] += memo[ny][nx];\n      }\n    }\n    if(memo[y][x] == 0) mp[y][x] = 1;\n  }\n}\n  \nint main() {\n  while(1) {\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n    for(int i=0;i<=19;i++)\n      for(int j=0;j<=19;j++)memo[i][j] = mp[i][j] = 0;\n    \n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)cin >> mp[i][j];\n \n    for(int i=0;i<w;i++) \n      if(mp[0][i] !=1) saiki(i,0);\n    \n    int cnt = 0;\n    for(int i=0;i<w;i++)\n      if(memo[0][i] > 0) cnt+=memo[0][i];\n    cout <<cnt<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main()\n{\n\tint n, m;\n\twhile (true){\n\t\tcin >> n >> m;\n\t\tif (n == 0 && m == 0){\n\t\t\tbreak;\n\t\t}\n\t\tint map[100][100] = { 0 };\n\t\tint dp[100][100] = { 0 };\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int i2 = 0; i2 < m; i2++){\n\t\t\t\tcin >> map[i][i2];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tif (map[0][i] == 0){\n\t\t\t\tdp[0][i] = 1;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n - 1; i++){\n\t\t\tfor (int i2 = 0; i2 < m; i2++){\n\t\t\t\tif (map[i][i2] == 0){\n\t\t\t\t\tif (map[i + 1][i2] == 0 || map[i + 1][i2] == 2){\n\t\t\t\t\t\tdp[i + 1][i2] += dp[i][i2];\n\t\t\t\t\t}\n\t\t\t\t\tif (map[i + 1][i2 + 1] == 0){\n\t\t\t\t\t\tdp[i + 1][i2 + 1] += dp[i][i2];\n\t\t\t\t\t}\n\t\t\t\t\tif (i2 - 1 >= 0 && map[i + 1][i2 - 1] == 0){\n\t\t\t\t\t\tdp[i + 1][i2 - 1] += dp[i][i2];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (map[i][i2] == 2){\n\t\t\t\t\tif (map[i + 2][i2] == 0 || map[i + 2][i2] == 2){\n\t\t\t\t\t\tdp[i + 2][i2] += dp[i][i2];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tans += dp[m - 1][i];\n\t\t\tans += dp[m][i];\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<algorithm>\n\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint x,y;\nint c[20][20];\nint dp[20][20];\n\nvoid solve() {\n\trep(i,20) rep(j,20) c[i][j]=1;\n\trep(i,20) rep(j,20) dp[i][j]=0;\n\n\trep(i,y) rep(j,x) cin>>c[i][j];\n\n\trep(i,20) if(c[0][i]!=1) dp[0][i]=1;\n\t\n\tfor(int i=0;i<y;i++) {\n\t\tfor(int j=0;j<x;j++) {\n\t\t\tif(c[i][j]==2) {\n\t\t\t\tdp[i+2][j] += dp[i][j];\n\t\t\t}\n\t\t\telse if(c[i][j]==0) {\n\t\t\t\tif(c[i+1][j]!=1) {\n\t\t\t\t\tdp[i+1][j] += dp[i][j];\n\t\t\t\t}\n\t\t\t\tif(0<=j-1 && c[i+1][j-1]==0) {\n\t\t\t\t\tdp[i+1][j-1] += dp[i][j];\n\t\t\t\t}\n\t\t\t\tif(j+1 < x && c[i+1][j+1]==0) {\n\t\t\t\t\tdp[i+1][j+1] += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\n\tint ans=0;\n\trep(i,x) ans+=dp[y-1][i];\n\trep(i,x) ans+=dp[y][i];\n\n\tcout<<ans<<endl;\n\n}\n\nint main() {\n\twhile(cin>>x>>y) {\n\t\tif(x+y==0) return 0;\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nint map[15][15];\n\nint count[15][15];\n\nint main () {\n\n\twhile(true) {\n\t\tint w, h;\n\t\tcin >> w >> h;\n\n\t\tif ( w == 0 )\n\t\t\tbreak;\n\t\n\t\tfor ( int i=0; i<h; i++ ) {\n\t\t\tfor ( int j=0; j<w; j++ ) {\n\t\t\t\tcin >> map[i][j];\n\t\t\t}\n\t\t}\n\n\t\tfor ( int i=1; i<h; i++ ) {\n\t\t\tfor ( int j=0; j<w; j++ ) {\n\t\t\t\tcount[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor ( int i=0; i<w; i++ ) {\n\t\t\tif ( map[0][i] == 0 )\n\t\t\t\tcount[0][i] = 1;\n\t\t}\n\n\t\tfor ( int i=1; i<h; i++ ) {\n\t\t\tfor ( int j=0; j<w; j++ ) {\n\t\t\t\tif ( map[i][j] != 1 ) {\n\t\t\t\t\tif ( map[i][j] != 2 ) {\n\t\t\t\t\t\tif ( j-1 >= 0 ) {\n\t\t\t\t\t\t\tif ( map[i-1][j-1] == 0 ) {\n\t\t\t\t\t\t\t\tcount[i][j] += count[i-1][j-1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( j+1 < w ) {\n\t\t\t\t\t\t\tif ( map[i-1][j+1] == 0 ) {\n\t\t\t\t\t\t\t\tcount[i][j] += count[i-1][j+1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( map[i-1][j] == 0 ) {\n\t\t\t\t\t\tcount[i][j] += count[i-1][j];\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( i-2 >= 0 ) {\n\t\t\t\t\t\tif ( map[i-2][j] == 2 ) {\n\t\t\t\t\t\t\tcount[i][j] += count[i-2][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\tfor ( int i=0; i<h; i++ ) {\n\t\t\tfor ( int j=0; j<w; j++ ) {\n\t\t\t\tcout << count[i][j] << \"\\t\";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;\n\t\t*/\n\t\tint sum = 0;\n\n\t\tfor ( int i=0; i<w; i++ ) {\n\t\t\tsum += count[h-1][i];\n\t\t}\n\n\t\tfor ( int i=0; i<w; i++ ) {\n\t\t\tif ( map[h-2][i] == 2 )\n\t\t\t\tsum += count[h-2][i];\n\t\t}\n\n\t\tcout << sum << endl;\n\t}\n}\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <list>\n#include <map>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n\nint main(){\n\twhile(true){\n\t\tint maxX,maxY;\n\t\tcin >> maxX >> maxY;\t\t\tif(!maxX&&!maxY) return 0;\n\n\t\tint tizu[maxX+2][maxY+2];\n\t\tFOR(y,0,maxY+2){\n\t\t\tFOR(x,0,maxX+2){\n\t\t\t\tif(x==0||x==maxX+1||y==0||y==maxY+1){tizu[x][y]=1;continue;};\n\t\t\t\tcin >> tizu[x][y];\n\t\t\t}\n\t\t}\n\n\t\tint dp[maxX+2][maxY+2];\n\t\tFOR(y,0,maxY+2){\n\t\t\tFOR(x,0,maxX+2){\n\t\t\t\tdp[x][y]=0;\n\t\t\t\tif(x==0||x==maxX+1){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(y==0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(y==1){\n\t\t\t\t\tif(tizu[x][y]==0) dp[x][y]+=1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(y==maxY+1){\n\t\t\t\t\tif(tizu[x][y-1]==0) dp[x][y]+=dp[x][y-1];\n\t\t\t\t\tif(tizu[x][y-1]==2) dp[x][y]+=dp[x][y-1];\n\t\t\t\t\tif(tizu[x][y-2]==2) dp[x][y]+=dp[x][y-2];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(tizu[x][y]==0){\n\t\t\t\t\tif(tizu[x-1][y-1]==0) dp[x][y]+=dp[x-1][y-1];\n\t\t\t\t\tif(tizu[x][y-1]==0)   dp[x][y]+=dp[x][y-1];\n\t\t\t\t\tif(tizu[x+1][y-1]==0) dp[x][y]+=dp[x+1][y-1];\n\t\t\t\t\tif(tizu[x][y-2]==2)   dp[x][y]+=dp[x][y-2];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(tizu[x][y]==1){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(tizu[x][y]==2){\n\t\t\t\t\tif(tizu[x][y-1]==0) dp[x][y]+=dp[x][y-1];\n\t\t\t\t\tif(tizu[x][y-2]==2) dp[x][y]+=dp[x][y-2];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n/*\n\t\tFOR(y,0,maxY+2){\n\t\t\tFOR(x,0,maxY+2){\n\t\t\t\tcout << dp[x][y];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n*/\n\n\n\t\tint res = 0;\n\t\tFOR(x,1,maxX+1){ res += dp[x][maxY+1];};\n\t\tcout << res << endl;\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nint field[20][20];\nlong long dp[20][20];\n\nint main()\n{\n  int c1, c2;\n  while (scanf(\" %d %d \", &c1, &c2) == 2) {\n    if (c1 == 0 && c2 == 0) {break;}\n    for (int i = 0; i < 20; i++) {\n      fill(field[i], &field[i][20], 1);\n      fill(dp[i], &dp[i][20], 0);\n    }\n    for (int i = 1; i <= c1; i++) {\n      for (int j = 1; j <= c2; j++) {\n\tscanf(\" %d \", &field[i][j]);\n      }\n    }\n    /*for (int i = 0; i < 20; i++) {\n      for (int j = 0; j < 20; j++) {\n\tprintf(\"%d\", field[i][j]);\n      }\n      printf(\"\\n\");\n      }*/\n    \n    for (int i = 1; i <= c2; i++) {\n      dp[1][i] = 1;\n    }\n    for (int i = 1; i < c1; i++) {\n      for (int j = 1; j <= c2; j++) {\n\tif (field[i][j] == 0) {\n\t  if (field[i + 1][j - 1] != 2) {dp[i + 1][j - 1] += dp[i][j];}\n\t  dp[i + 1][j] += dp[i][j];\n\t  if (field[i + 1][j + 1] != 2) {dp[i + 1][j + 1] += dp[i][j];}\n\t} else if (field[i][j] == 2) {\n\t  dp[i + 2][j] += dp[i][j];\n\t} \n      }\n    }\n    long long sum = 0;\n    for (int i = 0; i <= 2; i++) {\n      for (int j = 1; j <= c2; j++) {\n\tif ((i != 0 || field[c1 + i][j] != 1) && (i != 0 || field[c1 + i][j] != 2)) {\n\t  sum += dp[c1 + i][j];\n\t}\n      }\n    }\n    \n    printf(\"%d\\n\", sum);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define MAX 1000\n#include<cstring>\nusing namespace std;\nint s[MAX][MAX],dp[MAX][MAX],d[]={1,0,-1},ans;\nint w,h;\nint func(int y,int x){\n\tif(y>=h-1)\n\treturn 1;\n\tif(dp[y][x]!=-1)\n\treturn dp[y][x];\n\tint sum=0;\n\tif(s[y][x]==2&&s[y+2][x]!=1)\n\t\tsum+=func(y+2,x);\n\telse{\n\tfor(int i=0;i<3;i++){\n\t\tif(x+d[i]>=0&&x+d[i]<w){\n\t\t\tif(s[y+1][x+d[i]]==0)\n\t\t\tsum+=func(y+1,x+d[i]);\n\t\t\telse if(s[y+1][x+d[i]]==2&&i==1)\n\t\t\tsum+=func(y+1,x+d[i]);\n\t\t}\n\t}\n\t}\n\treturn dp[y][x]=sum;\n}\nint main(){\n\twhile(cin>>w>>h,w||h){\n\t\tfor(int i=0;i<h;i++)\n\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\tcin>>s[i][j];\n\t\tfor(int i=h;i<h+2;i++)\n\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\ts[i][j]=0;\n\t\tans=0;\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tfor(int i=0;i<w;i++)\n\t\tif(s[0][i]!=1)\n\t\t\tans+=func(0,i);\n\t\tcout<<ans<<endl;\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstdio>\n#include<string.h>\n#include<cstring>\n#include<algorithm>\n#include<functional>\n#include<math.h>\n#include<queue>\n#include<ctype.h>\n#define MAX  1000000000\n#define MIN -1000000000\nusing namespace std;\nint i,j;\nint x,y;\nlong long int dp[1000][1000];\nint map[1000][1000];\nint main(void){\n\tscanf(\"%d %d\",&x,&y);\n\twhile(x!=0 && y!=0){\n\t\tfor(i=1;i<=17;i++){\n\t\t\tfor(j=1;j<=15;j++){\n\t\t\t\tdp[i][j]=0;\n\t\t\t\tmap[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=y;i++){\n\t\t\tfor(j=1;j<=x;j++){\n\t\t\t\tscanf(\"%d \",&map[i][j]);\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=x;i++){\n\t\t\tif(map[1][i]!=1){\n\t\t\t\tdp[1][i]=1;\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<y;i++){\n\t\t\tfor(j=1;j<=x;j++){\n\t\t\t\tif(dp[i][j]>0 && map[i][j]!=2){\n\t\t\t\t\tif(map[i+1][j-1]==0){\n\t\t\t\t\t\tif(j-1<0);\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tdp[i+1][j-1]+=dp[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(map[i+1][j]!=1 ){\n\t\t\t\t\t\tif(map[i+1][j]==0){\n\t\t\t\t\t\t\tdp[i+1][j]+=dp[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tint temp;\n\t\t\t\t\t\t\ttemp=i+1;\n\t\t\t\t\t\t\twhile(map[temp][j]==2){\n\t\t\t\t\t\t\t\ttemp+=2;\n\t\t\t\t\t\t\t\tdp[temp][j]+=dp[i][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(map[i+1][j+1]==0){\n\t\t\t\t\t\tif(j+1>x);\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tdp[i+1][j+1]+=dp[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n/*\t\tfor(i=1;i<=y+2;i++){\n\t\t\tprintf(\"%d=\",i);\n\t\t\tfor(j=1;j<=x;j++){\n\t\t\t\tprintf(\"%d \",dp[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\tint cnt=0;\n\t\tfor(i=0;i<=2;i++){\n\t\t\tfor(j=1;j<=x;j++){\n\t\t\t\tcnt+=dp[y+i][j];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",cnt);\n\t\tscanf(\"%d %d\",&x,&y);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nint m[500][500];\nint dp[500][500];\n\nint dx[]={-1,0,1};\n\nint solve(int r,int c){\n  rep(i,r+2)rep(j,c)dp[i][j]=0;\n  rep(j,c)if(m[0][j] == 0)dp[0][j]=1;\n\n  rep(i,r-1){\n    rep(j,c){\n      if (m[i][j] == 0 ){\n\trep(k,3){\n\t  int nex = j+dx[k];\n\t  if (nex<0||nex>=c)continue;\n\t  if (m[i+1][nex] == 0)dp[i+1][nex]+=dp[i][j];\n\t  else if (m[i+1][nex] == 2 && k == 1)dp[i+1][nex]+=dp[i][j];\n\t}\n      }else if (m[i][j] == 2 && m[i+2][j] != 1){\n\tdp[i+2][j]+=dp[i][j];\n      }\n    }\n  }\n  \n  int ans = 0;\n  rep(j,c)ans+=dp[r][j]+dp[r-1][j];\n  for( int i = 0;i <= c;i++ ){\n\t  for( int j = 0;j < r;j++ ){\n\t\t  cout << dp[i][j];\n\t  }\n\t  cout << endl;\n  }\n  return ans;\n}\n\nmain(){\n  int c,r;\n  while(cin>>c>>r && r){\n    rep(i,r)rep(j,c)cin>>m[i][j];\n    rep(j,c)m[r][j]=0;\n    cout << solve(r,c) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint C[15][15], dp[15][17];\n\nint main() {\n  for (;;) {\n    int X, Y;\n    cin >> X >> Y;\n    if (!X && !Y) return 0;\n    for (int y = 0; y < Y; y++)\n      for (int x = 0; x < X+2; x++) {\n        C[y][x] = 1;\n        dp[y][x] = 0;\n      }\n    for (int y = 0; y < Y; y++)\n      for (int x = 1; x <= X; x++)\n        cin >> C[y][x];\n    for (int x = 1; x <= X; x++)\n      if (!C[0][x])\n        dp[0][x] = 1;\n    for (int y = 1; y < Y; y++)\n      for (int x = 1; x <= X; x++) {\n        switch (C[y][x]) {\n        case 1:\n          break;\n        case 0:\n          dp[y][x] += (C[y-1][x-1] ? 0 : dp[y-1][x-1]) +\n                      (C[y-1][x+1] ? 0 : dp[y-1][x+1]);\n        case 2:\n          if (y >= 2 && C[y-2][x] == 2)\n            dp[y][x] += dp[y-2][x];\n          dp[y][x] += C[y-1][x] ? 0 : dp[y-1][x];\n          break;\n        default:\n          break;\n        }\n      }\n    int s = 0;\n    for (int x = 1; x <= X; x++)\n      s += dp[Y-1][x];\n    if (Y >= 2)\n      for (int x = 1; x <= X; x++)\n        if (C[Y-2][x] == 2)\n          s += dp[Y-2][x];\n    cout << s << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n\nusing namespace std;\n\nint main(int argc, char const* argv[])\n{\n\tint x,y;\n\tint stage[17][17][2];\n\n\twhile( cin >> x >> y && x != 0 && y != 0 ){\n\t\tfor( int i = 0;i < 17;i++ ){\n\t\t\tfor( int j = 0;j < 17;j++ ){\n\t\t\t\tstage[i][j][0] = stage[i][j][1] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tfor( int i = 1;i <= y;i++ ){\n\t\t\tfor( int j = 1;j <= x;j++ ){\n\t\t\t\tcin >> stage[j][i][0];\n\t\t\t}\n\t\t}\n\n\t\tfor( int i = 0;i < 17;i++ ) if(stage[i][1][0] != 1 ) stage[i][1][1] = 1;\n\n\t\tfor( int j = 1;j < y;j++ ){\n\t\t\tfor( int i = 1;i <= x;i++ ){\n\t\t\t\tif( stage[i][j][0] == 1 ) continue;\n\t\t\t\tif( stage[i][j][0] == 0 ){\n\t\t\t\t\tif( stage[i][j + 1][0] != 1 ) stage[i][j + 1][1] += stage[i][j][1];\n\t\t\t\t\t\n\t\t\t\t\tif( stage[i + 1][j + 1][0] == 0 ) stage[i + 1][j + 1][1] += stage[i][j][1];\n\t\t\t\t\tif( stage[i - 1][j + 1][0] == 0 ) stage[i - 1][j + 1][1] += stage[i][j][1];\n\n\t\t\t\t}\n\t\t\t\tif( stage[i][j][0] == 2 ){\n\t\t\t\t\tstage[i][j + 2][1] = stage[i][j][1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint count = 0;\n\t\tfor( int i = 1;i <= x;i++ ){\n\t\t\tcount += stage[i][y+1][1] + stage[i][y][1];\n\t\t}\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* {{{ Shinobu kawaii */\n/*\n  ______   __        _                  __                 \n.' ____ \\ [  |      (_)                [  |                \n| (___ \\_| | |--.   __   _ .--.   .--.  | |.--.   __   _   \n _.____`.  | .-. | [  | [ `.-. |/ .'`\\ \\| '/'`\\ \\[  | | |  \n| \\____) | | | | |  | |  | | | || \\__. ||  \\__/ | | \\_/ |, \n \\______.'[___]|__][___][___||__]'.__.'[__;.__.'  '.__.'_/ \n\n*/\n// clang-format off\n/* }}} */\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n// #define int long long\nstruct Fast {Fast(){std::cin.tie(0);ios::sync_with_stdio(false);}} fast;\n\n/* cpp template {{{ */\n\n/* short */\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define Fi first\n#define Se second\n#define ALL(v) begin(v), end(v)\n#define RALL(v) rbegin(v), rend(v)\n#define X real()\n#define Y imag()\n\n/* REPmacro */\n#define REPS(i, a, n) for (ll i = (a); i < (ll)(n); ++i)\n#define REP(i, n) REPS(i, 0, n)\n#define RREP(i, n) REPS(i, 1, n + 1)\n#define DEPS(i, a, n) for (ll i = (a); i >= (ll)(n); --i)\n#define DEP(i, n) DEPS(i, n, 0)\n\n/* debug */\n#define debug(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n';\n\n/* alias */\nusing ll = long long;\nusing ull = unsigned long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nusing pii = pair<int, int>;\nusing D = double;\nusing P = complex<D>;\nusing vs = vector<string>;\ntemplate <typename T> using PQ = priority_queue<T>;\ntemplate <typename T> using minPQ = priority_queue<T, vector<T>, greater<T>>;\n\n/* const */\nconst int INF = 1001001001;\nconst ll LINF = 1001001001001001001ll;\nconst int MOD = 1e9 + 7;\nconst D EPS = 1e-9;\nconst int dx[] = {0, 1, 0, -1, 1, -1, 1, -1}, dy[] = {1, 0, -1, 0, 1, -1, -1, 1};\n\n/* func */\ninline bool inside(int y, int x, int H, int W) {return y >= 0 && x >= 0 && y < H && x < W;}\ninline int in() {int x; cin >> x; return x;}\ninline ll IN() {ll x; cin >> x; return x;}\ninline vs split(const string& t, char c) {vs v; stringstream s(t); string b; while(getline(s, b, c)) v.eb(b); return v;}\ntemplate <typename T> inline bool chmin(T& a, const T& b) {if (a > b) a = b; return a > b;}\ntemplate <typename T> inline bool chmax(T& a, const T& b) {if (a < b) a = b; return a < b;}\ntemplate <typename T> inline void print(const T& x) {cout << x << '\\n';}\ntemplate <typename T, typename S> inline void print(const vector<pair<T, S>>& v) {for (auto&& p : v) print(p);}\ntemplate <typename T> inline void print(const vector<T>& v, string s = \" \") {REP(i, v.size()) cout << v[i] << (i != (ll)v.size() - 1 ? s : \"\\n\");}\n// clang-format on\n/* }}} */\n\nint w, h;\nint field[20][20];\nint memo[20][20];\n\nll dfs(int y, int x, int yy = -1, int xx = -1) {\n  if (!inside(y, x, INF, w)) return 0;\n  if (field[y][x] == 1) return 0;\n  if (y >= h - 1) return 1;\n  if (y == h - 1 && field[y][x] == 0) return 1;\n  if (field[y][x] == 2 && x != xx) return 0;\n\n  if (memo[y][x] != -1) return memo[y][x];\n\n  ll res;\n  if (field[y][x] == 2) {\n    res = dfs(y + 2, x, y, x);\n  } else {\n    res = dfs(y + 1, x, y, x) + dfs(y + 1, x + 1, y, x) + dfs(y + 1, x - 1, y, x);\n  }\n\n  return memo[y][x] = res;\n}\n\nsigned main() {\n  while (cin >> w >> h, w || h) {\n    memset(field, -1, sizeof(field));\n    memset(memo, -1, sizeof(memo));\n    REP(i, h) REP(j, w) field[i][j] = in();\n    ll ans = 0;\n    REP(i, w) {\n      ans += dfs(0, i);\n    }\n    print(ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint field[19][17];\nint DP[19][17];\nint main()\n{\n\tint w,h;\n\twhile(cin >> w >> h){\n\t\tif(!w && !h)\n\t\t\tbreak;\n\t\tfor(int i=0;i<19;i++){\n\t\t\tfor(int j=0;j<17;j++){\n\t\t\t\tfield[i][j] = 0;\n\t\t\t\tDP[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=h;i++){\n\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\tcin >> field[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int j=1;j<=w;j++){\n\t\t\tif(field[1][j] == 1)\n\t\t\t\tDP[1][j] = 0;\n\t\t\telse if(field[1][j] == 0)\n\t\t\t\tDP[1][j] = 1;\n\t\t}\n\t\t\n\t\tfor(int i=2;i<=h;i++){\n\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\tif(field[i][j] == 1)\n\t\t\t\t\tDP[i][j] = 0;\n\t\t\t\telse if(field[i][j] == 0)\n\t\t\t\t\tDP[i][j] += DP[i-1][j-1] + DP[i-1][j] + DP[i-1][j+1];\n\t\t\t\telse if(field[i][j] == 2){\n\t\t\t\t\tDP[i][j] = 0;\n\t\t\t\t\tint dy = 0;\n\t\t\t\t\twhile(field[i+dy][j] == 2){\n\t\t\t\t\t\tDP[i+dy][j] = 0;\n\t\t\t\t\t\tdy+=2;\n\t\t\t\t\t}\n\t\t\t\t\tDP[i+dy][j] += DP[i-1][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint sum = 0;\n\t\tfor(int i=h;i<=h+2;i++){\n\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\tsum += DP[i][j];\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\t\t\n\t\t/*\n\t\tfor(int i=0;i<18;i++){\n\t\t\tfor(int j=0;j<17;j++){\n\t\t\t\tcout << DP[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <cstring>\n#include <fstream>\n#include <numeric>\n#include <algorithm>\n\nusing namespace std;\n\nint main(int argc, char **argv) {\n  int x, y, field[15 * 15], route[15 * 15], rsum;\n\n  while (true) {\n    cin >> x >> y;\n    if (x == 0 && y == 0)\n      break;\n    rsum = 0;\n    memset(route, 0, sizeof(int) * x * y);\n    for (int i = 0; i < y; i++)\n      for (int j = 0; j < x; j++)\n        cin >> field[i * y + j];\n    for (int i = 0; i < x; i++) {\n      int f = field[i];\n      if (!f)\n        route[i] = 1;\n    }\n\n    for (int i = 1; i < y; i++)\n      for (int j = 0; j < x; j++) {\n        int f = field[i * y + j];\n        if (f == 0) {\n          for (int k = -1; k <= 1; k++)\n            if ((j + k >= 0 && j + k < x) &&\n                ((k == 0 && field[(i-1) * y + j+k] == 2) ||\n                 (field[(i-1) * y + j+k] != 2)))\n              route[i * y + j] += route[(i-1) * y + j+k];\n        } else if (f == 1) {\n          route[i * y + j] = 0;\n        } else if (f == 2 && i + 2 < y) {\n          route[(i+2) * y + j] = route[(i-1) * y + j];\n        } else if (f == 2) {\n          rsum += route[(i-1) * y + j];\n        }\n      }\n    for (int i = 0; i < x; i++)\n      rsum += route[(y-1) * y + i];\n\n    cout << rsum << endl;\n    /* FOR DEBUG                                                                                                                                                                                                                                               \n    for (int i = 0; i < y; i++) {                                                                                                                                                                                                                              \n      for (int j = 0; j < x; j++) {                                                                                                                                                                                                                            \n        cout << route[i * y + j];                                                                                                                                                                                                                              \n        cout << ' ';                                                                                                                                                                                                                                           \n      }                                                                                                                                                                                                                                                        \n      cout << endl;                                                                                                                                                                                                                                            \n    }                                                                                                                                                                                                                                                          \n    */\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>  \n\nusing namespace std;\n\n#define FOR(i, j, k) for(int i = j; i < k; ++i)\n#define rep(i, j) FOR(i, 0, j)\n#define repr(i, j) for(int i = j; i >= 0; --i)\n#define INF (1 << 30)\n#define MOD 1e9 + 7\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\n\nint X, Y;\nint field[20][20];\nint dp[20][20];\n\nint main() {\n\twhile(scanf(\"%d %d\", &X, &Y), X || Y) {\n\t\trep(i, Y) rep(j, X) scanf(\"%d\", &field[i][j]);\n\t\tmemset(dp, 0, sizeof(dp));\n\t\trep(j, X) dp[0][j] = (field[0][j] == 0);\n\t\tFOR(i, 1, Y) rep(j, X) {\n\t\t\tif(field[i][j] == 0) {\n\t\t\t\tFOR(k, -1, 2) dp[i][j] += dp[i - 1][j + k];\n\t\t\t}\n\t\t\telse if(field[i][j] == 2) {\n\t\t\t\tif(i == Y - 1) {\n\t\t\t\t\tdp[i][j] += dp[i - 1][j];\n\t\t\t\t}\n\t\t\t\telse if(field[i + 2][j] != 1){\n\t\t\t\t\tdp[i + 2][j] += dp[i][j] + dp[i - 1][j];\n\t\t\t\t\tdp[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i, X) dp[Y][i] += dp[Y - 1][i];\n\t\t/*rep(i, Y) {\n\t\t\trep(j, X) printf(\"%2d\", dp[i][j]);\n\t\t\tputs(\"\");\n\t\t}\n\t\trep(i, X) printf(\"%2d\", dp[Y][i]);\n\t\t*/\n\t\tint res = 0;\n\t\trep(i, X) res += dp[Y][i];\n\t\tprintf(\"%d\\n\", res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint fld[17][17];\nint cnt[17][17];\n\nint main()\n{\n\tint X,Y,S;\n\twhile(cin >> X >> Y, (X||Y))\n\t{\n\t\tfor(int y=0; y<17; y++)\n\t\tfor(int x=0; x<17; x++)\n\t\t{\n\t\t\tfld[y][x] = 1;\n\t\t\tcnt[y][x] = 0;\n\t\t}\n\n\t\tfor(int y=0; y< Y; y++)\n\t\tfor(int x=1; x<=X; x++)\n\t\t{\n\t\t\tcin >> fld[y][x];\n\t\t\tcnt[y][x] = ((y==0&&fld[y][x]==0)?1:0);\n\t\t}\n\n\t\tfor(int y=0; y< Y-1; y++)\n\t\tfor(int x=1; x<=X  ; x++)\n\t\t{\n\t\t\tif(fld[y][x]==0)\n\t\t\t{\n\t\t\t\tif(fld[y+1][x+1]==0) cnt[y+1][x+1]+=cnt[y][x];\n\t\t\t\tif(fld[y+1][x-1]==0) cnt[y+1][x-1]+=cnt[y][x];\n\t\t\t\tif(fld[y+1][x  ]!=1) cnt[y+1][x  ]+=cnt[y][x]; \n\t\t\t}\n\t\t\tif(fld[y][x]==2)\n\t\t\t{\n\t\t\t\tcnt[y+2][x]+=cnt[y][x];\n\t\t\t}\n\t\t\tcnt[y][x] = 0;\n\t\t}\n\n\t\tS=0;\n\t\tfor(int y=Y-1; y< Y+2; y++)\n\t\tfor(int x=1  ; x<=X  ; x++)\n\t\t{\n\t\t\tS+=cnt[y][x];\n\t\t}\n\n\t\tcout << S << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <iomanip>\nusing namespace std;\nint main(){\n\tint x,y;\n\twhile(1){\n\t\tcin >> x >> y;\n\t\tif(x+y==0) break;\n\t\tint a[x][y];\n\t\tfor(int j=0;j<y;j++) for(int i=0;i<x;i++) cin >> a[i][j];\n\t\tlong long d[x][y];\n\t\tfor(int i=0;i<x;i++) d[i][0] = 1 - a[i][0];\n\t\tfor(int j=1;j<y;j++){\n\t\t\tfor(int i=0;i<x;i++){\n\t\t\t\tif(a[i][j]==1) d[i][j] = 0;\n\t\t\t\telse if(a[i][j]==0){\n\t\t\t\t\tif(a[i][j-1]!=2) d[i][j] = d[i][j-1];\n\t\t\t\t\tif(i>0 and a[i-1][j-1]!=2) d[i][j] += d[i-1][j-1];\n\t\t\t\t\tif(i<x-1 and a[i+1][j-1]!=2) d[i][j] += d[i+1][j-1];\n\t\t\t\t\tif(j>1 and a[i][j-2]==2) d[i][j] += d[i][j-2];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\td[i][j] = d[i][j-1];\n\t\t\t\t\tif(j>1 and a[i][j-2]==2) d[i][j] += d[i][j-2];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint s = 0;\n\t\tfor(int i=0;i<x;i++){\n\t\t\tif(y>2 and a[i][y-2]==2) s += d[i][y-2];\n\t\t\ts += d[i][y-1];\n\t\t}\n\t\tcout << s << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint dfs(int x,int y);\nint mas[20][20];\nint X,Y;\n\nint main(){\n\twhile(1){\n\t\tcin >> X >> Y;\n\t\tif(X == 0 && Y == 0) break;\n\t\tfor(int i=0;i<Y;i++){\n\t\t\tfor(int j=0;j<X;j++){\n\t\t\t\tcin >> mas[i][j];\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i=0;i<X;i++){\n\t\t\tif(mas[0][i] == 0){\n\t\t\t\tans += dfs(i,0);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\nint dfs(int x,int y){\n\tint cou = 0;\n\tif(y>=Y-1) return 1;\n\tfor(int i=-1;i<2;i++){\n\t\tint nx = x + i;\n\t\tint ny = y + 1;\n\t\tif(nx >= 0 && nx < X){\n\t\t\tif(i == 0 && mas[ny][nx] == 2){\n\t\t\t\twhile(mas[ny][nx] == 2){\n\t\t\t\t\tny += 2;\n\t\t\t\t}\n\t\t\t\tcou += dfs(nx,ny);\n\t\t\t}\n\t\t\telse if(mas[ny][nx] == 0){\n\t\t\t\tcou += dfs(nx,ny);\n\t\t\t}\n\t\t}\n\t}\n\treturn cou;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n  while(1){\n    int w,h,mp[20][20]={},dp[20][20] ={};\n    cin >> w >> h;\n    if(w==0 && h==0) break;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++) cin >> mp[i][j];\n    for(int i=0;i<w;i++) dp[0][i] = 1;\n\n    int ans=0;    \n    for(int i=0;i<h-1;i++)\n      for(int j=0;j<w;j++) {\n\tif(mp[i][j] !=0) continue;\n\tfor(int k=-1;k<=1;k++){\n\t  int nx=j+k,ny=i+1;\n\t  if(nx<0||nx>=w) continue;\n\t  while(k==0 && mp[ny][nx]==2) ny+=2;\n\t  if(mp[ny][nx]!=0) continue;\n\t  dp[ny][nx]+= dp[i][j];\n\t  if(ny >= h-1) ans+=dp[i][j];\n\t}\n      }\n    cout << ans <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nlong long solve(int x,int y);\nint ax,ay;\nint mas[200][200];\nlong long memo[200][200];\nint main(){\n  while(1){\n    for(int i=0;i<200;i++){\n      for(int j=0;j<200;j++){\n\tmemo[i][j]=0;\n      }\n    }\n    long long ans=0;\n    cin>>ax>>ay;\n    if(ax==0 && ay==0) break;\n    \n    for(int i=0;i<ay;i++){\n      for(int j=0;j<ax;j++){\n\tcin>>mas[i][j];\n      }\n    }\n    \n    for(int i=0;i<ax;i++){\n      if(mas[0][i]!=1){\n\tans+=solve(i,0);\n      }\n    }\n    cout<<ans<<endl;\n  }\n}\nlong long solve(int x,int y){\n  if(y>=ay){\n    return 1;\n  }else if(memo[y][x]!=0){\n    return memo[y][x];\n  }else if(mas[y][x]==1){\n    return 0;\n  }else if(mas[y][x]==2){\n    return solve(x,y+2);\n  } \n  else{\n    long long anss=0; \n    if(mas[y+1][x]!=1){\n      anss+=solve(x,y+1);\n    }\n    if(x+1<ax && mas[y+1][x+1]==0 && y+1!=ay){\n      anss+=solve(x+1,y+1);\n    }\n    if(0<=x-1 && mas[y+1][x-1]==0 && y+1!=ay){\n      anss+=solve(x-1,y+1);\n    }\n    return memo[y][x]=anss;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n  while(1){\n    int w,h,mp[20][20]={},dp[20][20] ={};\n    cin >> w >> h;\n    if(w==0 && h==0) break;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++) cin >> mp[i][j];\n   \n\n    int ans=0;   \n    for(int i=0;i<w;i++) {\n      if(mp[0][i]==0) dp[0][i] = 1;\n      if(0 >=h-1)ans+=dp[0][i];\n    }\n    for(int i=0;i<h-1;i++)\n      for(int j=0;j<w;j++) \n\tfor(int k=-1;k<=1;k++){\n\t  int nx=j+k,ny=i+1;\n\t  if(nx<0||nx>=w || mp[i][j] !=0) continue;\n\t  while(k==0&&mp[ny][nx]==2) ny+=2;\n\t  if(mp[ny][nx]!=0) continue;\n\t  dp[ny][nx]+= dp[i][j];\n\t  if(ny >= h-1) ans+=dp[i][j];\n\t}\n    cout << ans <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main()\n{\n\tint n, m;\n\twhile (true){\n\t\tcin >> n >> m;\n\t\tif (n == 0 && m == 0){\n\t\t\tbreak;\n\t\t}\n\t\tint map[100][100] = { 0 };\n\t\tint dp[100][100] = { 0 };\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tfor (int i2 = 0; i2 < n; i2++){\n\t\t\t\tcin >> map[i][i2];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tif (map[0][i] == 0){\n\t\t\t\tdp[0][i] = 1;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tfor (int i2 = 0; i2 < n; i2++){\n\t\t\t\tif (map[i][i2] == 0){\n\t\t\t\t\tif (map[i + 1][i2] == 0 || map[i + 1][i2] == 2){\n\t\t\t\t\t\tdp[i + 1][i2] += dp[i][i2];\n\t\t\t\t\t}\n\t\t\t\t\tif (i2+1<m&&map[i + 1][i2 + 1] == 0&&i<m-1){\n\t\t\t\t\t\tdp[i + 1][i2 + 1] += dp[i][i2];\n\t\t\t\t\t}\n\t\t\t\t\tif (i2 - 1 >= 0 && map[i + 1][i2 - 1] == 0&&i<m - 1){\n\t\t\t\t\t\tdp[i + 1][i2 - 1] += dp[i][i2];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (map[i][i2] == 2){\n\t\t\t\t\tif (map[i + 2][i2] == 0 || map[i + 2][i2] == 2){\n\t\t\t\t\t\tdp[i + 2][i2] += dp[i][i2];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tans += dp[m][i];\n\t\t\tans += dp[m + 1][i];\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nvoid solve(int f[20][20] , w , h ){\n    int dp[20][20] = {0};\n    for(int x=1 ; x <= w ; x++ ){\n        dp[1][x] = 1;\n    }\n\n    for(int y=1 ; y <= h-1 ; y++ ){\n        for(int x=1 ; x <= w ; x++ ){\n            if( f[y][x] == 0 ){\n                if( f[y+1][x-1] == 0 ) dp[y+1][x-1] += dp[y][x];\n                if( f[y+1][x]   == 0 ) dp[y+1][x]   += dp[y][x];\n                if( f[y+1][x+1] == 0 ) dp[y+1][x+1] += dp[y][x];\n                if( f[y+1][x]   == 2 ) dp[y+1][x]   += dp[y][x];\n            }else if( f[y][x] == 2 ){\n                if( f[y+2][x] == 0 || f[y+2][x] == 2 ){\n                    dp[y+2][x] += dp[y][x];\n                }\n            }\n        }\n    }\n    int ans = 0;\n    for(int x=1 ; x <= w ; x++ ){\n        ans += dp[h][x] + dp[h+1][x];\n    }\n    return ans;\n}\n\nint main(){\n    int w,h;\n\n    while( cin >> w >> h , w||h ){\n        int f[20][20] = {0};\n        for(int y=1 ; y <= h ; y++ ){\n            for(int x=1 ; x <= w ; x++ ){\n                cin >> f[y][x];\n            }\n        }\n\n        int ans = solve( f , w , h );\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n\nint map[15][15],table[15][15],X,Y;\n\nint main(){\nwhile(1){\n\nscanf(\"%d%d\",&X,&Y);\nif(X==0&&Y==0) return 0;\nmemset(map,-1,sizeof(map));\nmemset(table,0,sizeof(table));\nfor(int i=0;i<Y;i++){\nfor(int j=0;j<X;j++){\nscanf(\"%d\",&map[i][j]);\nif(i==0&&map[i][j]==0) table[i][j]=1;\nelse if(i!=0&&map[i][j]!=1){\nif(j>0&&map[i-1][j-1]==0&&map[i][j]==0) table[i][j]+=table[i-1][j-1];\nif(j<X-1&&map[i-1][j+1]==0&&map[i][j]==0) table[i][j]+=table[i-1][j+1];\nif(map[i-1][j]==0)table[i][j]+=table[i-1][j];\nif(i>2&&map[i-2][j]==2) table[i][j]+=table[i-2][j]; \n} \n}\n}\nint sum=0;\nfor(int i=0;i<X;i++){\nsum+=table[Y-1][i];\nif(map[Y-2][i]==2) sum+=table[Y-2][i];\n}\nprintf(\"%d\\n\",sum);\n\n\n\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nint main()\n{\n    int x, y;\n    int dx[3] = {-1, 0, 1};\n    \n    while (std::cin >> x >> y, x, y) {\n        int field[20][20] = {{0}}, dp[20][20] = {{0}};\n        \n        for (int i = 0; i < 20; ++i) {\n            for (int j = 0; j < 20; ++j) {\n                field[i][j] = 1;\n            }\n        }\n        \n        for (int i = 1; i <= y; ++i) {\n            for (int j = 1; j <= x; ++j) {\n                std::cin >> field[i][j];\n            }\n        }\n\n        for (int i = 1; i <= x; ++i) {\n            if (field[1][i] == 0) dp[1][i] = 1;\n        }\n        \n        //calc\n        int ans = 0;\n\n        for (int i = 1; i <= y; ++i) {\n            for (int j = 1; j <= x; ++j) {\n                \n                switch (field[i][j]) {\n                    case 0:\n                        for (int k = 0; k < 3; ++k) {\n                            int px = j + dx[k], py = i + 1;\n                            \n                            if (field[py][px] == 2 && k == 1 || field[py][px] == 0) {\n                                dp[py][px] += dp[i][j];\n                            }\n                        }\n                        break;\n                    case 2:\n                        //y-1\n                        if (i == y -1) ans += dp[i][j];\n                        if (dp[i + 2][j] != 1) dp[i + 2][j] += dp[i][j];\n                        break;\n                    default:\n                        break;\n                }\n            }\n        }\n\n        for (int i = 1; i <= x; ++i) {\n            ans += dp[y][i];\n        }\n\n        std::cout << ans << std::endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <deque>\n#include <ctime>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define mp make_pair\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n#define println(X) cout<<X<<endl;\n#define DBG(X) cout<<#X<<\" : \"<<X<<endl;\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\nconst double PI = acos(-1);\n\nint dx[]={-1, 0, 1};\n\nint d[21][21];\nll dp[21][21];\nint w, h;\n\nbool isOutofRange(int x, int y){\n\tif(x < 0 || x >= 0 || y < 0) return true;\n\treturn false;\n}\n\nint main(){\n\twhile(cin>>w>>h && w && h){\n\t\trep(i, h) rep(j, w) cin>>d[i][j];\n\t\trep(i, 21) rep(j, 21) dp[i][j] = 0LL;\n\t\tfor(int i = 0; i < w; i++){\n\t\t\tif(d[0][i] != 1) dp[0][i] = 1LL;\n\t\t}\n\n\t\tfor(int i = 0; i < h-1; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tif(d[i][j]!=0) continue;\n\t\t\t\tfor(int k = 0; k < 3; k++){\n\t\t\t\t\tint nx = j + dx[k], ny = i+1;\n\t\t\t\t\tif(isOutofRange(nx, ny)) continue;\n\t\t\t\t\tif(d[ny][nx] == 0) {\n\t\t\t\t\t\tdp[ny][nx] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(d[i+1][j]==2) dp[i+2][j]+=dp[i][j];\n\t\t\t}\n\t\t}\n\t\tll ans = 0ll;\n\t\trep(i, w){\n\t\t\tans += dp[h-1][i];\n\t\t\tans += dp[h][i];\n\t\t}\n\t\tcout<<ans<<endl;\n\t\t// rep(i, h) {\n\t\t// \trep(j, w){\n\t\t// \t\tcout<<dp[i][j]<<\" \";\n\t\t// \t}\n\t\t// \tcout<<endl;\n\t\t// }\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#define N 15\nusing namespace std;\nvoid func(int,int);\nint jump(int,int);\nint X,Y,data[N][N],memo[N+2][N];\nint main(){\n  while(1){\n    cin >> X >> Y;\n    if(X==0&&Y==0) break;\n    for(int i=0;i<Y;i++)\n      for(int j=0;j<X;j++)\n\tcin >> data[i][j];\n    for(int i=0;i<Y+2;i++)\n      for(int j=0;j<X;j++)\n\tmemo[i][j]=0;\n    for(int i=0;i<X;i++)\n      if(data[0][i]!=1)\n\tfunc(0,i);\n    int cnt=0;\n    for(int i=0;i<X;i++)\n      cnt+=memo[0][i];\n    cout << cnt << endl;\n  }\n  return 0;\n}\nvoid func(int y,int x){\n  if(y>=Y-1){\n    memo[Y-1][x]=1;\n    return ;\n  }\n  if(0<=x-1&&data[y+1][x-1]==0){\n    if(memo[y+1][x-1]!=0) memo[y][x]+=memo[y+1][x-1];\n    else{\n      func(y+1,x-1),memo[y][x]+=memo[y+1][x-1];\n    }\n  }\n  if(x+1<=X-1&&data[y+1][x+1]==0){\n    if(memo[y+1][x+1]!=0) memo[y][x]+=memo[y+1][x+1];\n    else{\n      func(y+1,x+1),memo[y][x]+=memo[y+1][x+1];\n    }\n  }\n  if(data[y+1][x]==0){\n    if(memo[y+1][x]!=0) memo[y][x]+=memo[y+1][x];\n    else{\n      func(y+1,x),memo[y][x]+=memo[y+1][x];\n    }\n  }\n  if(data[y+1][x]==2){\n    int r=jump(y+1,x);\n    if(r==-2) memo[y][x]+=1;\n    else if(r!=-1){\n      if(memo[r][x]!=0) memo[y][x]+=memo[r][x];\n      else{\n\tfunc(r,x),memo[y][x]+=memo[r][x];\n      }\n    }\n  }\n  if(memo[y][x]==0) data[y][x]=1;\n}\nint jump(int y,int x){\n  y+=2;\n  while(1){\n    if(y>=Y-1) return -2;\n    if(data[y][x]==1) break;\n    if(data[y][x]==0) return y;\n    if(data[y][x]==2) y+=2;\n  }\n  return -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n \nint fld[17][17];\nint cnt[17][17];\n \nint main(){\n\n    int X,Y,S;\n    while(cin >> X >> Y, X || Y ) {\n\n      for(int y = 0 ; y< 17 ; y++)\n        for(int x = 0 ; x< 17 ; x++){\n            fld[y][x] = 3;\n            cnt[y][x] = 0;\n        }\n \n        for(int y = 0 ; y < Y ; y++)\n\t  for(int x= 1 ; x <= X ; x++){\n            cin >> fld[y][x];\n            cnt[y][x] = ( (y == 0 && fld[y][x] == 0 )? 1 : 0 );\n\t  }\n \n        for(int y = 0 ; y < Y - 1 ; y++ )\n\t  for(int x = 1 ; x <= X  ; x++ ){\n            if(fld[y][x] == 0){\n\t      if(fld[y + 1][x + 1] == 0) cnt[y + 1][x + 1] += cnt[y][x];\n\t      if(fld[y + 1][x - 1] == 0) cnt[y + 1][x - 1] += cnt[y][x];\n\t      if(fld[y + 1][x] != 1) cnt[y + 1][x] += cnt[y][x]; \n            }\n            if( fld[y][x] == 2 && fld[y + 2][x] != 1 ){\n\t      cnt[y + 2][x] += cnt[y][x];\n            }\n\t  }\n \n        S = 0;\n        for(int y=Y-1; y< Y+2; y++)\n\t  for(int x=1  ; x<=X  ; x++)\n            S+=cnt[y][x];\n \n \n        cout << S << endl;\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint dp[18][18];\nint kosu[16][16];\nint ans;\n\nint main(){\n  int x,y;\n  \n  while(1){\n    cin>>x>>y;\n    if(x==0 && y==0) break;\n    \n    fill(dp[0],dp[18],0);\n    ans=0;\n    \n    for(int i=0;i<y;i++){\n      for(int l=0;l<x;l++){\n        cin>>kosu[i][l];\n      }\n    }\n    for(int i=0;i<x;i++)\n      if(kosu[0][i]==0) dp[0][i]=1;\n    \n    for(int i=1;i<y;i++){\n      for(int l=0;l<x;l++){\n        \n        if(kosu[i][l]==2){\n          dp[i+2][l]=dp[i-1][l]+dp[i-2][l]+dp[i][l];\n          dp[i][l]=0;\n        }\n        else if(kosu[i][l]==0)\n          dp[i][l]+=dp[i-1][l-1]+dp[i-1][l]+dp[i-1][l+1];\n      }\n    }\n    \n    for(int i=0;i<x;i++)\n      if(kosu[y-1][i]==2) ans+=dp[y-2][i];\n    for(int i=0;i<x;i++)\n      if(kosu[y-1][i]!=1) ans+=dp[y-1][i];\n    \n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main()\n{\n\tint n, m;\n\twhile (true){\n\t\tcin >> n >> m;\n\t\tif (n == 0 && m == 0){\n\t\t\tbreak;\n\t\t}\n\t\tint map[100][100] = { 0 };\n\t\tint dp[100][100] = { 0 };\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int i2 = 0; i2 < m; i2++){\n\t\t\t\tcin >> map[i][i2];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tif (map[0][i] == 0){\n\t\t\t\tdp[0][i] = 1;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tfor (int i2 = 0; i2 < n; i2++){\n\t\t\t\tif (map[i][i2] == 0){\n\t\t\t\t\tfor (int i3 = -1; i3 <= 1; i3++){\n\t\t\t\t\t\tif (i2 + i3 >= 0 && i2 + i3 < n && (map[i + 1][i2 + i3] == 0 || i3 == 0 && map[i + 1][i2 + i3] == 2)&&(i<m-1||i3==0)){\n\t\t\t\t\t\t\tdp[i + 1][i2+i3]  += dp[i][i2];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t\telse if (map[i][i2] == 2){\n\t\t\t\t\t\t\tdp[i + 2][i2] += dp[i][i2];\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tans += dp[m][i];\n\t\t\tans += dp[m+1][i];\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class t>\nusing table = vector<vector<t>>;\nconst ld eps=1e-9;\n\n//// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\"\n\nint main() {\n\twhile (1) {\n\t\tint H, W; cin >> W >> H;\n\t\tif (!H)break;\n\t\tvector<vector<int>>field(H + 3, vector<int>(W + 2,1));\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tcin >> field[i][j+1];\n\t\t\t}\n\t\t}\n\t\tfor (int i = H; i < H + 3; ++i) {\n\t\t\tfor (int j = 1; j <= W; ++j) {\n\t\t\t\tfield[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tvector<vector<long long int>>nums(H + 3, vector<long long int>(W + 2, 0));\n\t\tfor (int j = 0; j < W + 2; ++j) {\n\t\t\tif (!field[0][j])nums[0][j] = 1;\n\t\t}\n\t\tlong long int ans = 0;\n\t\tif (H==1) {\n\t\t\tcout << accumulate(nums[0].begin(), nums[0].end(), 0) << endl;\n\t\t}\n\t\telse {\n\t\t\tfor (int i = 0; i < H - 1; ++i) {\n\t\t\t\tfor (int j = 1; j < W + 1; ++j) {\n\t\t\t\t\tfor (int dx = -1; dx <= 1; ++dx) {\n\t\t\t\t\t\tconst int nextx = j + dx;\n\t\t\t\t\t\tint nexty = i + 1;\n\n\t\t\t\t\t\tif (field[nexty][nextx] == 1) {\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (field[nexty][nextx] == 2) {\n\t\t\t\t\t\t\tif (!dx) {\n\t\t\t\t\t\t\t\twhile (1) {\n\t\t\t\t\t\t\t\t\tnexty += 2;\n\t\t\t\t\t\t\t\t\tif (nexty >= H - 1 && field[nexty][nextx] != 1) {\n\t\t\t\t\t\t\t\t\t\tans += nums[i][j];\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\tif (field[nexty][nextx] == 1) {\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse if (field[nexty][nextx] == 0) {\n\n\t\t\t\t\t\t\t\t\t\t\tnums[nexty][nextx] += nums[i][j];\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (nexty >= H - 1)ans += nums[i][j];\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tnums[nexty][nextx] += nums[i][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << ans << endl;\n\t\t}\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n\n  int x,y;\n  int a[100][100];\n  int w[100][100];\n\n  while(true){\n    cin >> x >> y;\n    if(!x && !y) break;\n\n    memset(w,0,sizeof(w));\n    int ans = 0;\n\n    for(int i=0;i<y;i++){\n      for(int j=0;j<x;j++) cin >> a[i][j];\n    }\n\n    for(int i=0;i<x;i++){\n      if(a[0][i] == 0) w[0][i] = 1;\n    }\n\n    for(int i=1;i<y;i++){\n      for(int j=0;j<x;j++){\n\n\tif(a[i][j] == 1) w[i][j] += 0;\n\n\telse if(a[i][j] == 2 && a[i+2][j] != 1) w[i+2][j] += w[i-1][j];\n\n\telse if(a[i][j] == 0){\n\t  if(i-3 > 0 && a[i-3][j+1] == 2 && a[i-3][j-1] == 2) w[i][j] += w[i-1][j];\n\t  else if(i-3 > 0 && a[i-3][j+1] == 2) w[i][j] += w[i-1][j-1] + w[i-1][j];\n\t  else if(i-3 > 0 && a[i-3][j-1] == 2) w[i][j] += w[i-1][j] + w[i-1][j+1];\n\t  else if(j-1 < 0) w[i][j] += w[i-1][j] + w[i-1][j+1];\n\t  else if(j+1 == y) w[i][j] += w[i-1][j-1] + w[i-1][j];\n\t  else w[i][j] += w[i-1][j-1] + w[i-1][j] + w[i-1][j+1];\n\t}\n\n\n      }\n    }\n\n    for(int i=0;i<x;i++) ans += w[y-1][i] + w[y][i] + w[y+1][i];\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint dp[17][15];\nint h,w;\nint map[15][15];\nmain()\n{\n\twhile(cin>>w>>h,w)\n\t{\n\t\tfor(int i=0;i<h;i++)\n\t\t{\n\t\t\tfor(int j=0;j<w;j++)\n\t\t\t{\n\t\t\t\tcin>>map[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=h+1;i++)for(int j=0;j<w;j++)dp[i][j]=0;\n\t\tfor(int i=0;i<w;i++)dp[0][i]=map[0][i]==0;\n\t\tfor(int i=0;i<h;i++)\n\t\t{\n\t\t\tfor(int j=0;j<w;j++)\n\t\t\t{\n\t\t\t\tif(dp[i][j]==0||map[i][j]==1)continue;\n\t\t\t\tif(map[i][j]==2)\n\t\t\t\t{\n\t\t\t\t\tdp[i+2][j]+=dp[i][j];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(i<h-1&&j>0)\n\t\t\t\t{\n\t\t\t\t\tif(map[i+1][j-1]==0)dp[i+1][j-1]+=dp[i][j];\n\t\t\t\t}\n\t\t\t\tif(i<h-1&&j<w-1)\n\t\t\t\t{\n\t\t\t\t\tif(map[i+1][j+1]==0)dp[i+1][j+1]+=dp[i][j];\n\t\t\t\t}\n\t\t\t\tif(map[i+1][j]!=1)dp[i+1][j]+=dp[i][j];\n\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t\tfor(int j=0;j<w;j++)ans+=dp[h][j]+dp[h+1][j];\n\t\tcout<<ans<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main( void )\n{\n\tint X, Y;\n\twhile ( cin >> X >> Y && X && Y )\n\t{\n\t\tvector < vector <int> > map( Y, vector <int>(X, 0) );\n\t\tvector < vector <int> > dp( Y, vector <int>(X, 0) );\n\t\tfor ( int i = 0; i < Y; i++ )\n\t\t{\n\t\t\tfor ( int j = 0; j < X; j++ )\n\t\t\t{\n\t\t\t\tcin >> map[i][j];\n\t\t\t}\n\t\t}\n\n\t\tfor ( int i = 0; i < X; i++ )\n\t\t{\n\t\t\tif ( map[0][i] == 0 )\n\t\t\t\tdp[0][i] = 1;\n\t\t}\n\n\t\tfor ( int i = 0; i < Y-1; i++ )\n\t\t{\n\t\t\tfor ( int j = 0; j < X; j++ )\n\t\t\t{\n\t\t\t\tif ( map[i][j] == 2 )\n\t\t\t\t{\n\t\t\t\t\tif ( i+2 < Y )\n\t\t\t\t\t{\n\t\t\t\t\t\tif ( map[i+2][j] != 1 )\n\t\t\t\t\t\t\tdp[i+2][j] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[Y-1][j] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( map[i][j] == 0 )\n\t\t\t\t{\n\t\t\t\t\tif ( i+1 < Y )\n\t\t\t\t\t{\n\t\t\t\t\t\tif ( map[i+1][j] == 2 )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdp[i+1][j] += dp[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor ( int k = -1; k < 2; k++ )\n\t\t\t\t{\n\t\t\t\t\tif ( j+k<0 || j+k>=X )\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif ( map[i][j] == 0 && map[i+1][j+k] == 0 )\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i+1][j+k] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint answer = 0;\n\t\tfor ( int i = 0; i < X; i++ )\n\t\t{\n\t\t\tanswer += dp[Y-1][i];\n\t\t}\n\n\t\tcout << answer << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nconst int MAX_Y = 30;\nconst int MAX_X = 30;\nint mx, my, c[MAX_Y][MAX_X], dp[MAX_Y][MAX_X];\n\nconst int dx[3] = {-1, 0, 1};\nconst int dy[3] = {1, 1, 1};\n\nint dfs(int y, int x) {  \n  int res = 0;\n  if (dp[y][x] >= 0) return dp[y][x];\n  \n  if (y == my - 1) return 1;\n  \n  if (c[y][x] == 2) {\n    if (y+2 >= my - 1) return 1;\n    res += dfs(y+2, x);\n    return res;\n  }\n  \n  rep(z,3) {\n    int tx = x + dx[z], ty = y + dy[z];\n    if (tx < 0 || ty < 0 || tx >= mx || ty >= my) continue;\n    if (c[ty][tx] == 1) continue;\n    if (c[ty][tx] == 2 && tx != x) continue;\n    res += dfs(ty, tx);\n  }\n\n  return dp[y][x] = res;\n}\n\nvoid solve() {\n  memset(dp, -1, sizeof dp);\n  rep(i,my) rep(j,mx) cin>>c[i][j];\n\n  int res = 0;\n  rep(i,mx) {\n    if (c[0][i] == 1) continue;\n    res += dfs(0, i);\n  }\n  cout<<res<<endl;\n}\n\nint main (int argc, char const* argv[]) {\n  while (cin>>mx>>my, mx||my) {\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <functional>\n#include <numeric>\n#define fi first\n#define se second\nusing namespace std;\nbool value(int y,int x,int R,int C){return 0<=y&&y<R&&0<=x&&x<C;}\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<long long > vll;\ntypedef vector< vi > vvi;\ndouble pie=acos(-1);\nint INF=10000009;\nint dx[4] = { 0,-1,0,1 };\nint dy[4] = { -1,0,1,0 };\nint c[20][20];\nlong long int dp[20][20];\nint main() {\n\tint X,Y;\n\twhile(true){\n\t\tlong long int ans=0;\n\t\tcin>>X>>Y;\n\t\tfor(int i=1;i<=Y+2;i++){\n\t\t\tfor(int j=1;j<=X;j++){\n\t\t\t\tdp[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tif(X+Y==0) break;\n\t\tfor(int i=1;i<=Y;i++){\n\t\t\tfor(int j=1;j<=X;j++){\n\t\t\t\tcin>>c[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=X;i++){\n\t\t\tif(c[1][i]==1){\n\t\t\t\tdp[1][i]=0;\n\t\t\t}\n\t\t\tif(c[1][i]==0){\n\t\t\t\tdp[1][i]=1;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=Y;i++){\n\t\t\tfor(int j=1;j<=X;j++){\n\t\t\t\tif(c[i][j]==0){\n\t\t\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\t\t\tif(c[i+1][j+k-1]==0) dp[i+1][j+k-1]+=dp[i][j];\n\t\t\t\t\t\telse if(k==1&&c[i+1][j+k-1]==2) dp[i+1][j+k-1]+=dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(c[i][j]==2){\n\t\t\t\t\tif(c[i+2][j]!=1) dp[i+2][j]+=dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=X;i++){\n\t\t\tif(c[Y-1][i]==2){\n\t\t\t\tans+=dp[Y-1][i];\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=X;i++){\n\t\t\tans+=dp[Y][i];\n\t\t}\n\t\tprintf(\"%lld\\n\",ans );\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>  \n\nusing namespace std;\n\n#define FOR(i, j, k) for(int i = j; i < k; ++i)\n#define rep(i, j) FOR(i, 0, j)\n#define repr(i, j) for(int i = j; i >= 0; --i)\n#define INF (1 << 30)\n#define MOD 1e9 + 7\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\n\nint X, Y;\nint field[20][20];\nint dp[20][20];\n\nint main() {\n\twhile(scanf(\"%d %d\", &X, &Y), X || Y) {\n\t\trep(i, Y) rep(j, X) scanf(\"%d\", &field[i][j]);\n\t\tmemset(dp, 0, sizeof(dp));\n\t\trep(j, X) dp[0][j] = (field[0][j] == 0);\n\t\tFOR(i, 1, Y) rep(j, X) {\n\t\t\tif(field[i][j] == 0) {\n\t\t\t\tFOR(k, -1, 2) dp[i][j] += dp[i - 1][j + k];\n\t\t\t}\n\t\t\telse if(field[i][j] == 2) {\n\t\t\t\tdp[i + 2][j] += dp[i - 1][j] + dp[i][j];\n\t\t\t\tdp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\trep(i, X) dp[Y][i] += dp[Y - 1][i];\n\t\t/*rep(i, Y) {\n\t\t\trep(j, X) printf(\"%2d\", dp[i][j]);\n\t\t\tputs(\"\");\n\t\t}\n\t\trep(i, X) printf(\"%2d\", dp[Y][i]);\n\t\t*/\n\t\tint res = 0;\n\t\trep(i, X) res += dp[Y][i];\n\t\tprintf(\"%d\\n\", res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\n\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nint x, y, c[50][50], dp[50][50];\nconst int dx[3] = {-1, 0, 1};\n\nvoid solve() {\n  memset(dp, 0, sizeof dp);\n  \n  rep(i,y) rep(j,x) cin>>c[i][j];\n  \n  rep(i,x) if (c[0][i] == 0) dp[0][i] = 1;\n  \n  rep(i,y-1) rep(j,x) {\n    if (c[i][j] == 0) {\n      rep(z,3) {\n        int ti = i + 1, tj = j + dx[z];\n        if (ti < 0 || tj < 0 || ti >= y || tj >= x) continue;\n        if (c[ti][tj] == 1) continue;\n        if (c[ti][tj] == 2 && z != 1) continue;\n        dp[ti][tj] += dp[i][j];\n      }\n    } else if (c[i][j] == 2) {\n      dp[i+2][j] += dp[i][j];\n    }\n  }\n  /*\n  rep(i,y+1) {\n    rep(j,x) printf(\"%8d\",dp[i][j]);\n    cout<<endl;\n  }*/\n  \n  int res = 0;\n  rep(j,x) res += dp[y][j] + dp[y-1][j];\n  cout<<res<<endl;\n}\n\nint main (int argc, char const* argv[]) {\n  while (cin>>x>>y, x||y) {\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <deque>\n#include <string>\nusing namespace std;\n\nint main() {\n\t// your code goes here\n\tint X,Y;\n\t\n\twhile(cin >> X >> Y && X){\n\tint maps[20][20]={};\n\tint DP[20][20]={};\n\tfor(int j=1;j<=X;j++)\n\t\tDP[1][j]=1;\n\tfor(int i=1;i<=Y;i++)\n\t\tfor(int j=1;j<=X;j++)\n\t\t\tcin >> maps[i][j];\n\tfor(int i=1;i<=Y-1;i++)\n\t\tfor(int j=1;j<=X;j++)\n\t\t\tif(maps[i][j]==0){\n\t\t\t\tfor(int k=-1;k<=1;k++)\n\t\t\t\t\tif(maps[i+1][j+k]!=2 || k==0)\n\t\t\t\t\tDP[i+1][j+k]+=DP[i][j];\n\t\t\t}\n\t\t\telse if(maps[i][j]==2)\n\t\t\t\t\tDP[i+2][j]+=DP[i][j];\n\tint sum=0;\n\t\n\tfor(int i=Y;i<Y+2;i++)\n\t\tfor(int j=1;j<=X;j++)\n\t\t\tif(maps[i][j]!=1)\n\t\t\t\tsum+=DP[i][j];\n\tcout << sum << endl;\n}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nint m[500][500];\nint dp[500][500];\n\nint dx[]={-1,0,1};\n\nint solve(int r,int c){\n  rep(i,r+2)rep(j,c)dp[i][j]=0;\n  rep(j,c)if(m[0][j] == 0)dp[0][j]=1;\n\n  rep(i,r){\n    rep(j,c){\n      if (m[i][j] == 0 && i != r-1){\n\trep(k,3){\n\t  int nex = j+dx[k];\n\t  if (nex<0||nex>=c)continue;\n\t  if (m[i+1][nex] == 0)dp[i+1][nex]+=dp[i][j];\n\t  else if (m[i+1][nex] == 2 && k == 1)dp[i+1][nex]+=dp[i][j];\n\t}\n      }else if (m[i][j] == 2 && m[i+2][j] != 1){\n\tdp[i+2][j]+=dp[i][j];\n      }\n    }\n  }\n  \n  int ans = 0;\n  rep(j,c)ans+=dp[r][j]+dp[r-1][j]+dp[r+1][j];\n  return ans;\n}\n\nmain(){\n  int c,r;\n  while(cin>>c>>r && r){\n    rep(i,r)rep(j,c)cin>>m[i][j];\n    rep(j,c)m[r][j]=m[r+1][j]=0;\n    cout << solve(r,c) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,a,n) for(int i=a;i<n;i++)\n#define repb(i,a,b) for(int i=a;i>=b;i--)\n#define all(a) a.begin(),a.end()\n#define o(a) cout<<a<<endl\n#define int long long\n#define fi first\n#define se second\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n\n\nsigned main() {\n\tint y, x;\n\twhile (1) {\n\t\tcin >> x >> y;\n\t\tif (y + x == 0) break;\n\t\tint d[20][20];\n\t\trep(i, 0, 20) rep(j, 0, 20) d[i][j] = 1;\n\t\trep(i, 0, y) {\n\t\t\trep(j, 0, x) {\n\t\t\t\tcin >> d[i][j];\n\t\t\t}\n\t\t}\n\t\tint dp[20][20] = { 0 };\n\t\trep(i, 0, x) {\n\t\t\tif (d[0][i] == 0) dp[0][i] = 1;\n\t\t}\n\t\trep(i, 0, y) {\n\t\t\trep(j, 0, x) {\n\t\t\t\tif (d[i][j] == 2 && d[i + 2][j] != 1) {\n\t\t\t\t\tdp[i + 2][j] += dp[i][j];\n\t\t\t\t}\n\t\t\t\telse if (d[i][j] == 0) {\n\t\t\t\t\trep(k, -1, 2) {\n\t\t\t\t\t\tif (0 <= j + k && j + k < x && d[i + 1][j + k] == 0) {\n\t\t\t\t\t\t\tdp[i + 1][j + k] += dp[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (d[i + 1][j] == 2) {\n\t\t\t\t\t\tdp[i + 1][j] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*cout << endl;\n\t\trep(i, 0, y + 2) {\n\t\t\trep(j, 0, x) {\n\t\t\t\tcout << dp[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t\tint ans = 0;\n\t\trep(i, 0, x) {\n\t\t\tans += dp[y - 1][i];\n\t\t\tif (d[y - 2][i] == 2) {\n\t\t\t\tans += dp[y - 2][i];\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint w,h;\nint mp[20][20],memo[20][20];\nint dx[] = {-1,0,1};\n\nvoid saiki(int x,int y) {\n  if(y >= h-1) memo[y][x]++;\n  else if(mp[y][x] != 1) {\n    for(int i=0;i<3;i++) {\n      int nx = x+dx[i], ny = y+1;\n      if(nx==x && mp[ny][nx] == 2)while(mp[ny][nx] == 2) ny+=2;\n\n      if(nx <0|| nx >= w ||mp[ny][nx] == 1) continue;\n      if(memo[ny][nx] > 0 && mp[ny][nx] == 0) memo[y][x] += memo[ny][nx];\n      else if(mp[ny][nx] == 0){\n\tsaiki(nx,ny);\n\tmemo[y][x] += memo[ny][nx];\n      }\n    }\n    if(memo[y][x] == 0) mp[y][x] = 1;\n  }\n}\n  \nint main() {\n  while(1) {\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n    for(int i=0;i<=19;i++)\n      for(int j=0;j<=19;j++)memo[i][j] = mp[i][j] = 0;\n    \n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)cin >> mp[i][j];\n \n    for(int i=0;i<w;i++) \n      if(mp[0][i] !=1) saiki(i,0);\n    \n    int cnt = 0;\n    for(int i=0;i<w;i++)\n      if(memo[0][i] > 0) cnt+=memo[0][i];\n    cout <<cnt<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<numeric>\nusing namespace std;\n\nint main() {\n\tint x, y;\n\twhile (cin >> x >> y ,x,y) {\n\t\tvector<vector<int>> course(y + 2, vector<int>(x + 2, 0));\n\t\tfor (int i = 1; i <= y; i++) {\n\t\t\tfor (int j = 1; j <= x; j++) {\n\t\t\t\tcin >> course[i][j];\n\t\t\t}\n\t\t}\n\n\t\tvector<vector<int>> path(y + 2, vector<int>(x + 2, 0));\n\t\t//?????????????????????????????????1????????????\n\t\tfor (int i = 1; i <= x; i++) {\n\t\t\tif (course[1][i] != 1) path[1][i] = 1;\n\t\t}\n\n\t\tfor (int i = 1; i <= y; i++) {\n\t\t\tfor (int j = 1; j <= x; j++) {\n\t\t\t\t//????????????????????´????????????????????´??????????????????????????????????????????\n\t\t\t\t//?????????????§????????????????????????´?????????????????????????????£????????°?????´????????????????????????\n\t\t\t\tif (course[i][j] == 0) {\n\t\t\t\t\tif (course[i + 1][j + 1] == 0) path[i + 1][j + 1] += path[i][j];\n\t\t\t\t\tif (course[i + 1][j] != 1) path[i + 1][j] += path[i][j];\n\t\t\t\t\tif (course[i + 1][j - 1] == 0) path[i + 1][j - 1] += path[i][j];\n\t\t\t\t}\n\t\t\t\t//?¬???????????????´???????????£????????°????????????????????????????????????\n\t\t\t\t//?????????????????£????????§??´??????????????´???????????????(?????£?????????????????????????????´???????????????)\n\t\t\t\tif (course[i][j] == 2 && course[i + 2][j] != 1) {\n\t\t\t\t\tif (i + 2 > y) path[y][j] += path[i][j];\n\t\t\t\t\telse path[i + 2][j] += path[i][j];\n\t\t\t\t}\n\t\t\t\t//???????????´???????????????????????????????????????\n\t\t\t\tif (course[i][j] == 1) {/*do anything*/ }\n\t\t\t}\n\t\t}\n\n\t\tcout << accumulate(path[y].begin() + 1, path[y].end() - 1, 0) << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\nusing namespace std;\n\nint main()\n{\n\tint map[100][100];\n\tint dp[100][100];\n\t\n\tint X, Y;\n\twhile (scanf(\"%d %d\", &X, &Y), X + Y){\n\t\tfor (int i = 0; i < 100; i++){\n\t\t\tdp[0][i] = 1;\n\t\t\tfor (int j = 1; j < 100; j++){\n\t\t\t\tdp[j][i] = 0;\n\t\t\t}\n\t\t}\n\t\tmemset(map, 0, sizeof(map));\n\t\t\n\t\tfor (int i = 0; i < Y; i++){\n\t\t\tfor (int j = 0; j < X; j++){\n\t\t\t\tscanf(\"%d\", &map[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < Y; i++){\n\t\t\tfor (int j = 0; j < X; j++){\n\t\t\t\tif (map[i][j] == 0){\n\t\t\t\t\tfor (int k = -1; k <= 1; k++){\n\t\t\t\t\t\tif (j + k >= 0 && j + k < X && (map[i + 1][j + k] == 0 || (k == 0 && map[i + 1][j + k] == 2)) && (i < Y - 1 || k == 0)){\n\t\t\t\t\t\t\tdp[i + 1][j + k] += dp[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (map[i][j] == 2){\n\t\t\t\t\tdp[i + 2][j] += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < X; i++){\n//\t\t\tprintf(\"%d \", dp[Y][i]);\n\t\t\tsum += dp[Y][i];\n\t\t\tsum += dp[Y + 1][i];\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", sum);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nint main()\n{\n    int X, Y;\n\n    while (cin >> X >> Y, X || Y) {\n        int grid[Y + 2][X + 2];\n\n        // 0: 移動可能 1: 障害物がある 2: ジャンプ台がある\n        for (int i = 0; i <= Y + 1; ++i) {\n            for (int j = 0; j <= X + 1; ++j) {\n                if (i == 0 || j == 0 || j == X + 1)\n                    grid[i][j] = 1;\n                else if (i == Y + 1)\n                    grid[i][j] = 0;\n                else\n                    cin >> grid[i][j];\n            }\n        }\n\n        int cnt[Y + 2][X + 2];\n\n        memset(cnt, 0, sizeof(cnt));\n        for (int i = 1; i <= X; ++i)\n            if (grid[1][i] != 1)\n                cnt[1][i] = 1;\n\n        for (int i = 1; i < Y; ++i) {\n            for (int j = 1; j <= X; ++j) {\n                if (grid[i][j] == 0) {\n                    for (int k = -1; k <= 1; ++k)\n                        if (grid[i + 1][j + k] == 0 || (k == 0 && grid[i + 1][j + k] == 2))\n                            cnt[i + 1][j + k] += cnt[i][j];\n                }\n                else if (grid[i][j] == 2 && grid[i + 2][j] != 1)\n                    cnt[i + 2][j] += cnt[i][j];\n            }\n        }\n\n        int ans = 0;\n        for (int i = 1; i <= X; ++i)\n            ans += cnt[Y][i] + cnt[Y + 1][i];\n\n        cout << ans << endl;\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define reep(i,f,t) for(int i=f ; i<int(t) ; ++i)\n#define rep(i,n) reep(i, 0, n) \n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nint w, h;\nvvi field;\nvvi memo;\n\nint solve(int y, int x)\n{\n\tif(memo[y][x] != -1)\n\t\treturn memo[y][x];\n\t\n\tmemo[y][x] = 0;\n\tif(field[y][x] == 1)\n\t\treturn 0;\n\tif(y == 0)\n\t\treturn memo[y][x] = 1;\n\t\n\tconst int dx[] = {-1, 0, 1};\n\trep(i, 3){\n\t\tint px = x + dx[i];\n\t\tif(px<0 || w<=px || field[y-1][px]!=0 || (field[y][x]==2 && dx[i]!=0))\n\t\t\tcontinue;\n\t\tmemo[y][x] += solve(y-1, px);\n\t}\n\t\n\tif(y>=2 && field[y-2][x] == 2)\n\t\tmemo[y][x] += solve(y-2, x);\n\treturn memo[y][x];\n}\n\nint main()\n{\n\twhile(scanf(\"%d%d\", &w, &h), w){\n\t\tfield.assign(h, vi(w));\n\t\tmemo.assign(h, vi(w, -1));\n\t\trep(i, h) rep(j, w)\n\t\t\tscanf(\"%d\", &field[i][j]);\n\n\t\tint sum = 0;\n\t\trep(i, w){\n\t\t\tsum += solve(h-1, i);\n\t\t\tif(h>=2 && field[h-2][i] == 2)\n\t\t\t\tsum += solve(h-2, i);\n\t\t}\n\t\tprintf(\"%d\\n\", sum);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define N 15\nusing namespace std;\nvoid func(int,int);\nint jump(int,int);\nint X,Y,data[N][N],memo[N][N];\nint main(){\n  while(1){\n    cin >> X >> Y;\n    if(X==0&&Y==0) break;\n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++)memo[i][j]=0;\n    for(int i=0;i<Y;i++)\n      for(int j=0;j<X;j++) cin >> data[i][j];\n    for(int i=0;i<X;i++)\n      if(data[0][i]==0) func(0,i);\n    int cnt=0;\n    for(int i=0;i<X;i++) cnt+=memo[0][i];\n    cout << cnt << endl;\n  }\n  return 0;\n}\nvoid func(int y,int x){\n  if(y==Y-1){\n    memo[Y-1][x]=1;\n    return ;\n  }\n  if(0<=x-1&&data[y+1][x-1]==0){\n    if(memo[y+1][x-1]==0) func(y+1,x-1);\n    memo[y][x]+=memo[y+1][x-1];\n  }\n  if(x+1<X&&data[y+1][x+1]==0){\n    if(memo[y+1][x+1]==0) func(y+1,x+1);\n    memo[y][x]+=memo[y+1][x+1];\n  }\n  if(data[y+1][x]==0){\n    if(memo[y+1][x]==0) func(y+1,x);\n    memo[y][x]+=memo[y+1][x];\n  }\n  if(data[y+1][x]==2){\n    int r=jump(y+1,x);\n    if(r==-2) memo[y][x]+=1;\n    else if(r!=-1){\n      if(memo[r][x]==0) func(r,x);\n      memo[y][x]+=memo[r][x];\n    }\n  }\n  if(memo[y][x]==0) data[y][x]=1;\n}\nint jump(int y,int x){\n  while(1){\n    y+=2;\n    if(data[y][x]==1) break;\n    if(y>=Y-1) return -2;\n    if(data[y][x]==0) return y;\n  }\n  return -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define N 20\nusing namespace std;\nvoid func(int,int);\nint jump(int,int);\nint X,Y,data[N][N],memo[N][N];\nint main(){\n  while(1){\n    cin >> X >> Y;\n    if(X==0&&Y==0) break;\n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++) data[i][j]=0,memo[i][j]=0;\n\n    for(int i=0;i<Y;i++)\n      for(int j=0;j<X;j++) cin >> data[i][j];\n\n    for(int i=0;i<X;i++)\n      if(data[0][i]!=1) func(0,i);\n\n    int cnt=0;\n    for(int i=0;i<X;i++) cnt+=memo[0][i];\n    cout << cnt << endl;\n  }\n  return 0;\n}\nvoid func(int y,int x){\n  if(y>=Y-1){\n    memo[y][x]=memo[Y][x]=++memo[Y-1][x];\n    return ;\n  }\n  if(0<=x-1&&data[y+1][x-1]==0){\n    if(memo[y+1][x-1]==0) func(y+1,x-1);\n    memo[y][x]+=memo[y+1][x-1];\n  }\n  if(x+1<X&&data[y+1][x+1]==0){\n    if(memo[y+1][x+1]==0) func(y+1,x+1);\n    memo[y][x]+=memo[y+1][x+1];\n  }\n  if(data[y+1][x]==0){\n    if(memo[y+1][x]==0) func(y+1,x);\n    memo[y][x]+=memo[y+1][x];\n  }\n  if(data[y+1][x]==2){\n    int r=jump(y+1,x);\n    if(r!=-1){\n      if(memo[r][x]==0) func(r,x);\n      memo[y][x]+=memo[r][x];\n    }else data[y+1][x]=1;\n  }\n  if(memo[y][x]==0) data[y][x]=1;\n}\nint jump(int y,int x){\n  while(data[y][x]==2)y+=2;\n  if(data[y][x]==0||y>=Y-1) return y;\n  return -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint dx[3] = {-1,0,+1};\n\nint main(){\n\tint w, h, s[20][20];\n\twhile( cin >> w >> h, w || h ){\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\t\tcin >> s[y][x];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint dp[20][20] = {0};\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tif( s[0][x] == 0 ) dp[0][x] = 1;\n\t\t}\n\t\tfor(int y=0 ; y < h-1 ; y++ ){\n\t\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\t\tif( s[y][x] == 0 ){\n\t\t\t\t\tfor(int i=0 ; i < 3 ; i++ ){\n\t\t\t\t\t\tint mx = x + dx[i];\n\t\t\t\t\t\tint my = y + 1;\n\t\t\t\t\t\tif( mx < 0 || mx >= w ) continue;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif( s[my][mx] == 0 ){\n\t\t\t\t\t\t\tdp[my][mx] += dp[y][x];\n\t\t\t\t\t\t}else if( i == 1 && s[my][mx] == 2 ){\n\t\t\t\t\t\t\tdp[my][mx] += dp[y][x];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else if( s[y][x] == 2 ){\n\t\t\t\t\tint mx = x;\n\t\t\t\t\tint my = y + 2;\n\t\t\t\t\tif( s[my][mx] != 1 ){\n\t\t\t\t\t\tdp[my][mx] += dp[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans=0;\n\t\tfor(int x = 0 ; x < w ; x++ ){\n\t\t\tans += dp[h-1][x] + dp[h][x];\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint main() {\n\tint width, height, m[15][15];\n\twhile (cin >> width >> height, width && height) {\n\t\tfor (int y = 0; y < height; ++y)\n\t\t\tfor (int x = 0; x < width; ++x)\n\t\t\t\tcin >> m[y][x];\n\n\t\tint sum = 0, pattern[15][15] = {0};\n\t\tfor (int x = 0; x < width; ++x)\n\t\t\tpattern[0][x] = 1;\n\n\t\tfor (int y = 0; y < height-1; ++y)\n\t\t\tfor (int x = 0; x < width; ++x)\n\t\t\t\tif (m[y][x] == 0) {\n\t\t\t\t\tif (x - 1 >= 0 && m[y+1][x-1] == 0) pattern[y+1][x-1] += pattern[y][x];\n\t\t\t\t\tif (x + 1 < width && m[y+1][x+1] == 0) pattern[y+1][x+1] += pattern[y][x];\n\t\t\t\t\tif (m[y+1][x] != 1) pattern[y+1][x] += pattern[y][x];\n\t\t\t\t}\n\t\t\t\telse if (m[y][x] == 2) {\n\t\t\t\t\tif (y + 2 == height) sum += pattern[y][x];\n\t\t\t\t\telse if (m[y+2][x] != 1) pattern[y+2][x] += pattern[y][x];\n\t\t\t\t}\n\n\n\t\tfor (int x = 0; x < width; ++x)\n\t\t\tif (m[height-1][x] != 1) sum += pattern[height-1][x];\n\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint W, H;\nint C[20][20];\nlong long dp[20][20];\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  while (cin >> W >> H) {\n    if (W == 0 && H == 0) break;\n    rep(i, H) rep(j, W) cin >> C[j][i];\n\n    rep(x, W+1) rep(y, H+1) dp[x][y] = 0;\n    rep(x, W) {\n      if (C[x][0] == 1) continue;\n      dp[x][0] = 1;\n    }\n    long long s = 0;\n    rep(y, H) {\n      rep(x, W) {\n        for (int d=-1; d<=1; d++) {\n          int nx = x+d, ny = y+1;\n          if (C[x][y] == 2) {\n            if (d != 0) continue;\n            ny = y+2;\n          }\n          if (nx < 0 || nx >= W || C[nx][ny] == 1) continue;\n          if (C[nx][ny] == 2 && d != 0) continue;\n\n          if (ny >= H) {\n            if (d == 0) s += dp[x][y];\n          }\n          else dp[nx][ny] += dp[x][y];\n        }\n      }\n    }\n    cout << s << \"\\n\";\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<numeric>\nusing namespace std;\n\nint main() {\n\tint x, y;\n\twhile (cin >> x >> y ,x,y) {\n\t\tvector<vector<int>> course(y + 2, vector<int>(x + 2, 0));\n\t\tfor (int i = 1; i <= y; i++) {\n\t\t\tfor (int j = 1; j <= x; j++) {\n\t\t\t\tcin >> course[i][j];\n\t\t\t}\n\t\t}\n\n\t\tvector<vector<int>> path(y + 2, vector<int>(x + 2, 0));\n\t\t//?????????????????????????????????1????????????\n\t\tfor (int i = 1; i <= x; i++) {\n\t\t\tif (course[1][i] != 1) path[1][i] = 1;\n\t\t}\n\n\t\tfor (int i = 1; i <= y; i++) {\n\t\t\tfor (int j = 1; j <= x; j++) {\n\t\t\t\t//????????????????????´????????????????????´??????????????????????????????????????????\n\t\t\t\t//?????????????§????????????????????????´?????????????????????????????£????????°?????´????????????????????????\n\t\t\t\tif (course[i][j] == 0) {\n\t\t\t\t\tif (course[i + 1][j + 1] == 0) path[i + 1][j + 1] += path[i][j];\n\t\t\t\t\tif (course[i + 1][j] != 1) path[i + 1][j] += path[i][j];\n\t\t\t\t\tif (course[i + 1][j - 1] == 0) path[i + 1][j - 1] += path[i][j];\n\t\t\t\t}\n\t\t\t\t//?¬???????????????´???????????£????????°????????????????????????????????????\n\t\t\t\t//?????????????????£????????§??´??????????????´???????????????(?????£?????????????????????????????´???????????????)\n\t\t\t\tif (course[i][j] == 2 && course[i + 2][j] != 1) {\n\t\t\t\t\tif (i + 2 > y) path[y][j] += path[i][j];\n\t\t\t\t\telse path[i + 2][j] += path[i][j];\n\t\t\t\t}\n\t\t\t\t//???????????´???????????????????????????????????????\n\t\t\t\tif (course[i][j] == 1) {/*do anything*/ }\n\t\t\t}\n\t\t}\n\n\t\tcout << accumulate(path[y].begin() + 1, path[y].end() - 1, 0) << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define N 15\nusing namespace std;\nvoid func(int,int);\nint jump(int,int);\nint X,Y,data[N][N],memo[N][N];\nint main(){\n  while(1){\n    cin >> X >> Y;\n    if(X==0&&Y==0) break;\n    for(int i=0;i<Y;i++)\n      for(int j=0;j<X;j++) cin >> data[i][j],memo[i][j]=0;\n    for(int i=0;i<X;i++)\n      if(data[0][i]==0) func(0,i);\n    /*    cout << endl;\n    for(int i=0;i<Y;i++){\n      for(int j=0;j<X;j++){\n\tcout << memo[i][j] << ' ';\n      }\n      cout << endl;\n    }\n    cout << endl;*/\n    int cnt=0;\n    for(int i=0;i<X;i++) cnt+=memo[0][i];\n    cout << cnt << endl;\n  }\n  return 0;\n}\nvoid func(int y,int x){\n  if(y==Y-1){\n    memo[Y-1][x]=1;\n    return ;\n  }\n  if(0<=x-1&&data[y+1][x-1]==0){\n    if(memo[y+1][x-1]==0) func(y+1,x-1);\n    memo[y][x]+=memo[y+1][x-1];\n  }\n  if(x+1<X&&data[y+1][x+1]==0){\n    if(memo[y+1][x+1]==0) func(y+1,x+1);\n    memo[y][x]+=memo[y+1][x+1];\n  }\n  if(data[y+1][x]==0){\n    if(memo[y+1][x]==0) func(y+1,x);\n    memo[y][x]+=memo[y+1][x];\n  }\n  if(data[y+1][x]==2){\n    int r=jump(y+1,x);\n    if(r==-2) memo[y][x]+=1;\n    else if(r!=-1){\n      func(r,x);\n      memo[y][x]+=memo[r][x];\n    }\n  }\n  if(memo[y][x]==0) data[y][x]=1;\n}\nint jump(int y,int x){\n  while(1){\n    y+=2;\n    if(data[y][x]==1) break;\n    if(y>=Y-1) return -2;\n    if(data[y][x]==0) return y;\n  }\n  return -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    int W, H;\n\n\n    while ( cin >> W >> H, W || H ) {\n        int dp[22][22] = {};\n        int mas[22][22] = {};\n\n        for ( int i = 0; i < H; i++ ) {\n            for ( int j = 0; j < W; j++ ) {\n                cin >> mas[i][j];\n            }\n        }\n\n        for ( int i = 0; i < W; i++ ) {\n            if ( mas[0][i] == 0 ) {\n                dp[0][i] = 1;\n            }\n        }\n\n        for ( int i = 0; i < H - 1; i++ ) {\n            for ( int j = 0; j < W; j++ ) {\n                if ( mas[i][j] == 2 ) {\n                    if ( mas[i + 2][j] != 1 ) {\n                        dp[i + 2][j] += dp[i][j];\n                    }\n                } else {\n                    for ( int k = -1; k <= 1; k++ ) {\n                        if ( 0 <= j + k && j + k < W ) {\n                            if ( mas[i + 1][j + k] == 0 ) {\n                                dp[i + 1][j + k] += dp[i][j];\n                            } else if ( k == 0 && mas[i + 1][j] == 2 ) {\n                                dp[i + 1][j] += dp[i][j];\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        int sum = 0;\n        for ( int i = 0; i < W; i++ ) {\n            sum += dp[H - 1][i] + dp[H][i];\n        }\n\n        cout << sum << endl;\n    }\n    return ( 0 );\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(long long i=(a);i<(b);i++)\n#define REP(i,N) for(long long i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define fi first\n#define se second\n\n#define PI acos(-1.0)\n#define INF 1000000007\n#define EPS 1e-10\n#define MAX_N 20000\n#define MAX_M 16\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<double, double> PD;\ntypedef pair<string, ll> PS;\ntypedef vector<ll> V;\ntypedef pair<P, char> PC;\n\nint x, y;\nint field[20][20];\nint dp[20][20];\n\nint main(){\n\twhile (cin >> x >> y&&x + y){\n\t\tREP(i, 16){\n\t\t\tREP(j, 16){\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tfield[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tREP(i, y)REP(j, x)cin >> field[i][j];\n\t\tREP(j, x){\n\t\t\tif (field[0][j] == 0)dp[0][j] = 1;\n\t\t}\n\t\tREP(i, y - 1){\n\t\t\tREP(j, x){\n\t\t\t\tif (field[i][j] == 0){\n\t\t\t\t\tif (field[i + 1][j] != 1)dp[i + 1][j] += dp[i][j];\n\t\t\t\t\tif (j - 1 >= 0 && field[i + 1][j - 1] == 0){\n\t\t\t\t\t\tdp[i + 1][j - 1] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tif (j + 1 < x&&field[i + 1][j + 1] == 0){\n\t\t\t\t\t\tdp[i + 1][j + 1] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (field[i][j] == 2){\n\t\t\t\t\tif (field[i + 2][j] != 1){\n\t\t\t\t\t\tdp[i + 2][j] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\t//cout << endl;\n\t\t//REP(i, y + 1){\n\t\t//\tREP(j, x){\n\t\t//\t\tcout << dp[i][j] << \" \";\n\t\t//\t}\n\t\t//\tcout << endl;\n\t\t//}\n\t\tREP(j, x)ans += dp[y - 1][j] + dp[y][j];\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n  while(1){\n    int w,h,mp[20][20]={},dp[20][20] ={};\n    cin >> w >> h;\n    if(w==0 && h==0) break;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++) cin >> mp[i][j];\n    for(int i=0;i<w;i++) if(dp[0][i]==0)dp[0][i] = 1;\n\n    int ans=0;    \n    for(int i=0;i<h-1;i++)\n      for(int j=0;j<w;j++) {\n\tif(mp[i][j] !=0) break;\n\tfor(int k=-1;k<=1;k++){\n\t  int nx=j+k,ny=i+1;\n\t  if(nx<0||nx>=w) continue;\n\t  while(k==0 && mp[ny][nx]==2) ny+=2;\n\t  if(mp[ny][nx]!=0) continue;\n\t  dp[ny][nx]+= dp[i][j];\n\t  if(i >= h-1) ans+=dp[i][j];\n\t}\n      }\n    cout << ans <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n\nint field[15][15];\nint w,h;\nint dfs(int x0,int y0);\n\nint main()\n{\n\twhile(1)\n\t{\n\t\tstd::cin>>w>>h;\n\t\tif(w==0&&h==0)break;\n\t\tfor(int y=0;y<h;y++)\n\t\t{\n\t\t\tfor(int x=0;x<w;x++)\n\t\t\t{\n\t\t\t\tstd::cin>>field[x][y];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint count=0;\n\t\tfor(int x=0;x<w;x++)\n\t\t{\n\t\t\tif(field[x][0]==0)\n\t\t\t{\n\t\t\t\tcount+=dfs(x,0);\n\t\t\t}\n\t\t}\n\t\tstd::cout<<count<<std::endl;\n\t}\n\treturn 0;\n}\n\nint dfs(int x0,int y0)\n{\n\tstd::stack<std::pair<int,int> > stk;\n\tint count=0;\n\tstk.push(std::pair<int,int>(x0,y0));\n\twhile(!stk.empty())\n\t{\n\t\tint x=stk.top().first,y=stk.top().second;\n\t\t\n\t\tstk.pop();\n\t\t\n\t\tif(y>=h-1)\n\t\t{\n\t\t\tcount++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(field[x][y]==2)\n\t\t\t{\n\t\t\t\tstk.push(std::pair<int,int>(x,y+2));\n\t\t\t}\n\t\t\telse if(field[x][y]==0)\n\t\t\t{\n\t\t\t\tif(x>0&&field[x-1][y+1]==0){stk.push(std::pair<int,int>(x-1,y+1));}\n\t\t\t\tif(x<w-1&&field[x+1][y+1]==0){stk.push(std::pair<int,int>(x+1,y+1));}\n\t\t\t\tif(field[x][y+1]!=1){stk.push(std::pair<int,int>(x,y+1));}\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF 999999999\n\n\nint main(){\n    int w,h;\n    while(cin>>w>>h){\n        if(w==0&&h==0)break;\n        int data[20][20];\n        rep(i,h){\n            rep(j,w){\n                cin>>data[i][j];\n            }\n        }\n        int dp[20][20];\n        rep(i,20)rep(j,20)dp[i][j]=0;\n        rep(i,w){\n            if(data[0][i]==0){\n                dp[0][i]=1;\n            }\n        }\n        \n        for(int i=0;i<h-1;i++){\n            for(int j=0;j<w;j++){\n                if(j-1>=0 && data[i+1][j-1]==0)dp[i+1][j-1]+=dp[i][j];\n                if(data[i+1][j]==0)dp[i+1][j]+=dp[i][j];\n                if(data[i+1][j]==2){\n                    int c=1;\n                    while(data[i+1+2*c][j]==2)c++;\n                    if(i+1+c*2<=h-1&&data[i+1+c*2][j]==0){\n                        dp[i+1+c*2][j]+=dp[i][j];\n                    }\n                    else if(i+1+c*2>h-1){\n                        dp[h-1][j]+=dp[i][j];\n                    }\n                }\n                if(j+1<w && data[i+1][j+1]==0)dp[i+1][j+1]+=dp[i][j];\n            }\n        }\n        int ans=0;\n        rep(i,w){\n            ans+=dp[h-1][i];\n        }\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<queue>\n#include<functional>\n#include<cstring>\n#include<vector>\n#include<climits>\n#include<map>\nusing namespace std;\n#define FOR(i,n) for(int i=0;i<(int)n;i++)\n#define FORI(i,k,n) for(int i=k;i<(int)n;i++)\n#define ALL(x) (x).begin(),(x).end()\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define int long long\n\nmain()\n{\n\twhile(1)\n\t{\n\t\tint a[20][20];\n\t\tint dp[20][20]={};\n\t\tint x,y;\n\t\t\n\t\tcin>>x>>y;if(x==0&&y==0)break;\n\t\tFOR(i,20)FOR(j,20)a[i][j]=1;\n\t\tFORI(i,1,y+1)\n\t\t{\n\t\t\tFORI(j,1,x+1)\n\t\t\t{\n\t\t\t\tcin>>a[i][j];\n\t\t\t}\n\t\t}\n\t\tFORI(i,1,x+1)\n\t\t{\n\t\t\tif(a[1][i]==0)dp[1][i]=1;\n\t\t\ta[y+1][i]=0;\n\t\t}\n\t\tFORI(i,1,y)\n\t\t{\n\t\t\tFORI(j,1,x+1)\n\t\t\t{\n\t\t\t\tif(a[i][j]==2&&a[i+2][j]!=1)\n\t\t\t\t{\n\t\t\t\t\tdp[i+2][j]+=dp[i][j];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfor(int k=-1;k<=1;k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(a[i+1][j+k]==0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdp[i+1][j+k]+=dp[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(a[i+1][j]==2)dp[i+1][j]+=dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans=0;\n\t\tFORI(i,1,x+1)ans+=dp[y][i]+dp[y+1][i];\n\t\tcout<<ans<<endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint w,h;\nint mp[20][20],memo[20][20];\nvoid saiki(int x,int y){\n  if(y >= h-1) memo[y][x]++;\n  else {\n    for(int i=-1;i<=1;i++) {\n      int nx = x+i, ny = y+1;\n      if(nx==x && mp[ny][nx] == 2)while(mp[ny][nx] == 2) ny+=2;\n      if(nx <0|| nx >= w ||mp[ny][nx] == 1) continue;\n\n      if(memo[ny][nx]>0&&mp[ny][nx]==0) memo[y][x] += memo[ny][nx];\n      else if(mp[ny][nx] == 0)saiki(nx,ny),memo[y][x] += memo[ny][nx];\n\n    }\n    if(memo[y][x] == 0) mp[y][x] = 1;\n  }\n}\nint main() {\n  while(1) {\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n    for(int i=0;i<=19;i++)\n      for(int j=0;j<=19;j++)memo[i][j] = mp[i][j] = 0;\n     \n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)cin >> mp[i][j];\n  \n    for(int i=0;i<w;i++)\n      if(mp[0][i] !=1) saiki(i,0);\n     \n    int cnt = 0;\n    for(int i=0;i<w;i++)cnt+=memo[0][i];\n    cout <<cnt<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\n#define reep(i,f,t) for(int i=f ; i<int(t) ; ++i)\n#define rep(i,n) reep(i, 0, n) \n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n\nint main()\n{\n\tint w, h;\n\twhile(scanf(\"%d%d\", &w, &h), w){\n\t\tvvi field(h+1, vi(w, 0));\n\t\trep(i, h) rep(j, w)\n\t\t\tscanf(\"%d\", &field[i][j]);\n\t\t\n\t\tvvi dp(h+1, vi(w, 0));\n\t\trep(i, w)\n\t\t\tdp[0][i] = field[0][i] == 0;\n\t\t\n\t\trep(i, h-1){\n\t\t\trep(j, w){\n\t\t\t\tif(field[i][j] == 0){\n\t\t\t\t\tconst int dx[] = {-1, 0, 1};\n\t\t\t\t\trep(k, 3){\n\t\t\t\t\t\tint px = j + dx[k];\n\t\t\t\t\t\tif(px<0 || w<=px || field[i+1][px] == 1 || (dx[k]!=0 && field[i+1][px]==2))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tdp[i+1][px] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(field[i][j] == 2){\n\t\t\t\t\tif(i+1<h && field[i+2][j] != 1)\n\t\t\t\t\t\tdp[i+2][j] += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint sum = 0;\n\t\trep(i, 2) rep(j, w)\n\t\t\tsum += dp[h-i][j];\n\t\tprintf(\"%d\\n\", sum);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nconst int X=20;\nconst int Y=20;\nint main(){\n    int n,m,dp[X][Y],s[X][Y],k,ans;\n    while(true){\n        scanf(\"%d%d\",&m,&n);\n        if(n==0&&m==0)return 0;\n        ans=0;\n        for(int i=0;i<n+2;i++)for(int j=0;j<m;j++)dp[i][j]=s[i][j]=0;\n        for(int i=0;i<m;i++)dp[0][i]=1;\n        for(int i=0;i<n;i++)for(int j=0;j<m;j++){\n            scanf(\"%d\",&k);\n            if(k==0){\n                dp[i][j]+=s[i][j];\n                if(i==n-1)continue;\n                dp[i+1][j]+=dp[i][j];\n                if(j!=0)s[i+1][j-1]+=dp[i][j];\n                if(j!=m-1)s[i+1][j+1]+=dp[i][j];\n            }\n            else if(k==2){\n                s[i][j]=0;\n                dp[i+2][j]+=dp[i][j];\n            }\n            else dp[i][j]=0;\n        }\n        for(int i=0;i<m;i++)ans+=dp[n][i]+dp[n-1][i];\n        printf(\"%d\\n\",ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint w,h;\nint mp[18][18];\nint memo[18][18];\nint ans;\nint count;\n\nint saiki(int x,int y) {\n  count++;\n  // cout << x <<\" \"<<y <<endl;\n  int dx[3] = {-1,0,1};\n  int dy[3] = {1,1,1};\n  \n  if((y >= h-1 && mp[y][x] != 1)) ans++,memo[y][x]++;//,cout <<\"ok\"<<endl;  \n  else if(mp[y][x] != 1) {\n    for(int i=0;i<3;i++) {\n      int nx = dx[i]+x;\n      int ny = dy[i]+y;\n      if(nx <0||ny <0||nx >= w|| ny>=h || memo[ny][nx] == -1) continue;\n      \n      if(memo[ny][nx] > 0) {\n\tans+= memo[ny][nx];\n\tmemo[y][x] += memo[ny][nx];\n      }  \n      else if(mp[ny][nx] == 0){\n\tsaiki(nx,ny);\n\tif(memo[ny][nx] > 0) memo[y][x] += memo[ny][nx];\n      } \n      else if(nx==x && mp[ny][nx] == 2){\n\tint ty = ny;\n\twhile(mp[ty][nx] == 2) ty+=2;\n\tsaiki(nx,ty);\n\tif(memo[ty][nx] > 0) memo[y][x] += memo[ty][nx];\n      } \n    }\n    if(memo[y][x] == 0) memo[y][x] = -1;\n  }\n}\n\n\nint main() {\n\n  while(1) {\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n\n    for(int i=0;i<h;i++) \n      for(int j=0;j<w;j++) \n\tcin >> mp[i][j];\n\n\n    for(int i=0;i<=15;i++) \n      for(int j=0;j<=15;j++) \n\tmemo[i][j] = 0;\n    /*\n      for(int i=0;i<h;i++) {\n      for(int j=0;j<w;j++) \n      cout << mp[i][j];\n      cout << endl;\n      }\n    */\n\n    ans = 0;\n    count = 0;\n    for(int i=0;i<w;i++) {\n      if(mp[0][i] !=1) saiki(i,0);\n    }\n\n    int ans2 = 0;\n    for(int i=0;i<w;i++) \n      if(memo[0][i] > 0) ans2+=memo[0][i];\n\n    //cout << ans << endl;\n    cout << ans2 << endl;\n    //cout << count << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 基本テンプレート\n \n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\nusing namespace std;\n \n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {1, 1, 1};\nint dy[] = {-1, 0, 1};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nint board[20][20], dp[30][30];\n \nsigned main() {\n    int W, H;\n    while(cin >> W >> H, W || H) {\n        memset(board, 0, sizeof(board));\n        for(int i=0; i<H; i++) {\n            for(int j=0; j<W; j++) {\n                cin >> board[i][j];\n            }\n        }\n\n        memset(dp, 0, sizeof(dp));\n        for(int i=0; i<W; i++) if(board[0][i] == 0) dp[0][i] = 1;\n\n        for(int i=0; i<H - 1; i++) {\n            for(int j=0; j<W; j++) {\n                if(board[i][j] == 1) continue;\n                for(int k=0; k<3; k++) {\n                    if(board[i][j] == 2 and k != 1) continue;\n                    int dbl = (board[i][j] == 2 ? 2 : 1);\n\n                    int ni = i + dx[k] * dbl, nj = j + dy[k];\n                    if(ni < 0 or nj < 0 or nj >= W) continue;\n                    if(board[ni][nj] == 1) continue;\n                    if(board[ni][nj] == 2 and k != 1) continue;\n                    dp[ni][nj] += dp[i][j];\n                }\n            }\n        }\n\n        int ans = 0;\n        for(int i=H-1; i<H+5; i++) {\n            for(int j=0; j<W; j++) {\n                ans += dp[i][j];\n            }\n        }\n\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nint grid[20][20];\n\ninline bool isAtObstacle(int x, int y) {\n  return grid[y][x] == 1;\n}\n\ninline bool isAtSkiJump(int x, int y) {\n  return grid[y][x] == 2;\n}\n\nint main() {\n  int n, m;\n  \n  while(cin >> n >> m && n) {\n    fill(grid[0], grid[0]+400, 0);\n    for(int i=0; i<n; i++) {\n      for(int j=0; j<m; j++) {\n\tcin >> grid[i][j];\n      }\n    }\n    \n    long long dp[20][20][2] = {};\n    \n    for(int j=0; j<m; j++) {\n      if(grid[0][j]==0) { dp[0][j][0] = 1; }\n    }\n    \n    for(int i=0; i<n-1; i++) {\n      for(int j=0; j<m; j++) {\n\t\n\t// there is no case such that skier is at obstacle.\n\tif(isAtObstacle(j, i)) continue;\n\t\n\t// A skier is at a ski jump.\n\tif(isAtSkiJump(j, i)) {\n\t  if(i+2>n-1) dp[n-1][j][0] += dp[i][j][0];\n\t  else dp[i+2][j][0] += dp[i][j][0];\n\t}\n\t\n\t// skiing without jump.\n\telse {\n\t  // from the upper left\n\t  if( j-1 >= 0\n\t      && !isAtObstacle(j-1, i+1)\n\t      && !isAtSkiJump (j-1, i+1) ) {\n\t    dp[i+1][j-1][1] += dp[i][j][0] + dp[i][j][1];\n\t  }\n\t  \n\t  // from the above\n\t  if( !isAtObstacle(j, i+1) ) {\n\t    dp[i+1][j][0] += dp[i][j][0] + dp[i][j][1];\n\t  }\n\t  \n\t  // from the upper right\n\t  if( j+1 < m\n\t      && !isAtObstacle(j+1, i+1)\n\t      && !isAtSkiJump (j+1, i+1) ) {\n\t    dp[i+1][j+1][1] += dp[i][j][0] + dp[i][j][1];\n\t  }\n\t}\n\t\n      }\n    }\n    \n    int ans = 0;\n    for(int i=0; i<m; i++) {\n      ans += dp[n-1][i][0] + dp[n-1][i][1];\n    }\n    \n    cout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint dp[18][18];\nint kosu[16][16];\nint ans;\n\nint main(){\n  int x,y;\n  \n  while(1){\n    cin>>x>>y;\n    if(x==0 && y==0) break;\n    \n    fill(dp[0],dp[18],0);\n    ans=0;\n    \n    for(int i=0;i<y;i++){\n      for(int l=0;l<x;l++){\n        cin>>kosu[i][l];\n      }\n    }\n    for(int i=0;i<x;i++)\n      if(kosu[0][i]==0) dp[0][i]=1;\n    \n    for(int i=1;i<y;i++){\n      for(int l=0;l<x;l++){\n        \n        if(kosu[i][l]==2){\n          dp[i+2][l]=dp[i-1][l]+dp[i-2][l]+dp[i][l];\n          dp[i][l]=0;\n        }\n        else if(kosu[i][l]==0)\n          dp[i][l]+=dp[i-1][l-1]+dp[i-1][l]+dp[i-1][l+1];\n      }\n    }\n    \n    for(int i=y;i<y+2;i++){\n      for(int l=0;l<x;l++){\n        dp[i][l]+=dp[i-1][l];\n      }\n    }\n    for(int i=0;i<x;i++)\n      ans+=dp[y][i];\n    \n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint field[16][16];\n// y,xÌ}X©çènßÄÅ«é·×èûÌ\nint dp[16][16];\n\nconst int dy[]={1,1,1};\nconst int dx[]={-1,0,1};\nint w,h;\n\nint search(int sx,int sy){\n\tif(field[sy][sx]==2){\n\t\tif(sy>=h-2){\n\t\t\treturn 1;\n\t\t}\n\t\telse if(field[sy+2][sx]==1)\n\t\t\treturn 0;\n\t\telse{\n\t\t\treturn search(sx,sy+2);\n\t\t}\n\t}\n\tif(dp[sy][sx]!=-1){\n\t\treturn dp[sy][sx];\n\t}\n\tint cnt=0;\n\tfor(int i = 0; i < 3; i++){\n\t\tint nx=sx+dx[i];\n\t\tint ny=sy+dy[i];\n\t\tif(nx>=0&&nx<w&&field[ny][nx]!=1){\n\t\t\tif(ny>h-1){\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\telse if(ny==h-1&&field[ny][nx]==0){\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\telse if(field[ny][nx]==2&&dx[i]==0){\n\t\t\t\tcnt+=search(nx,ny);\n\t\t\t}\n\t\t\telse if(field[ny][nx]==0){\n\t\t\t\tcnt+=search(nx,ny);\n\t\t\t}\n\t\t}\n\t}\n\n\tdp[sy][sx]=cnt;\n\treturn dp[sy][sx];\n}\n\n\nint main(){\n\n\twhile(cin>>w>>h&&!(w==0&&h==0)){\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tdp[i][j]=-1;\n\t\t\t}\n\t\t}\n\t\tint sum=0;\n\t\tfor(int i = 0; i < w; i++){\n\t\t\tif(field[0][i]==0)\n\t\t\t\tsum+=search(i,0);\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint DP[18][17];\nint field[18][17];\nint x,y;\n\nint main(){\n\twhile(true){\n\t\tcin >> x >> y;\n\t\tif(!x && !y)\n\t\t\treturn 0;\n\t\t\n\t\tfor(int i=1; i<=y; i++)\n\t\t\tfor(int k=1; k<=x; k++)\n\t\t\t\tcin >> field[i][k];\n\t\tfor(int i=1; i<=x; i++){\n\t\t\tfield[y+1][i] = 0;\n\t\t\tfield[y+2][i] = 0;\n\t\t}\n\t\t\n\t\tfor(int i=1; i<=y+2; i++)\n\t\t\tfor(int k=0; k<=x+1; k++){\n\t\t\t\tDP[i][k]=0;\n\t\t\t\tif(i==1 && k>0 && k<=x)\n\t\t\t\t\tif(field[i][k] == 0)\n\t\t\t\t\t\tDP[i][k] = 1;\n\t\t\t}\n\t\t\n\t\tfor(int i=2; i<=y; i++){\n\t\t\tfor(int k=1; k<=x; k++){\n\t\t\t\tif(field[i][k] == 0)\n\t\t\t\t\tDP[i][k] += DP[i-1][k-1] + DP[i-1][k] + DP[i-1][k+1];\n\t\t\t\telse if(field[i][k] == 2){\n\t\t\t\t\tint n = i+2;\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\tif(field[n][k] == 0){\n\t\t\t\t\t\t\tDP[n][k] += DP[i-1][k];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else if(field[n][k] == 1)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tn+=2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans=0;\n\t\tfor(int i=y; i<=y+2; i++)\n\t\t\tfor(int k=1; k<=x; k++)\n\t\t\t\tans += DP[i][k];\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint solve(int x,int y);\nint ax,ay;\nint mas[20][20];\nint memo[20][20];\nint main(){\n  while(1){\n    int ans=0;\n    for(int i=0;i<20;i++){\n      for(int j=0;j<20;j++){\n\tmemo[i][j]=0;\n      }\n    }\n    cin>>ax>>ay;\n    if(ax==0 && ay==0){\n      break;\n    }\n    for(int i=0;i<ay;i++){\n      for(int j=0;j<ax;j++){\n\tcin>>mas[i][j];\n      }\n    }\n    for(int i=0;i<ax;i++){\n      if(mas[0][i]!=1){\n\tans+=solve(i,0);\n      }\n    }\n    cout<<ans<<endl;\n  }\n}\nint solve(int x,int y){\n  if(memo[y][x]!=0){\n    return memo[y][x];\n  }\n  else if(y==ay){\n    return 1;\n  }else if(mas[y][x]==1){\n    return 0;\n  }else if(mas[y][x]==2){\n    return solve(x,y+2);\n  } \n  else{\n    int anss=0; \n    if(mas[y+1][x]!=1){\n      memo[y+1][x]=solve(x,y+1);\n      anss+=memo[y+1][x];\n    }\n    if(x+1<ax && mas[y+1][x+1]==0 && y+1!=ay){\n      memo[y+1][x+1]=solve(x+1,y+1);\n      anss+=memo[y+1][x+1];\n    }\n    if(0<=x-1 && mas[y+1][x-1]==0 && y+1!=ay){\n      memo[y+1][x-1]=solve(x-1,y+1);\n      anss+=memo[y+1][x-1];\n    }\n    return anss;\n  }\n}  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint X,Y;\nint c[15][15];\nint dp[15][15];\nint main(){\n\twhile(cin>>X>>Y,X|Y){\n\t\tint ans=0;\n\t\tfor(int i=0;i<Y;i++)\n\t\t\tfor(int j=0;j<X;j++)\n\t\t\t\tcin>>c[i][j];\n\t\tfill_n((int*)dp,15*15,0);\n\t\tfor(int j=0;j<X;j++){\n\t\t\tif(c[0][j]!=1)dp[0][j]=1;\n\t\t}cout<<endl;\n\t\tfor(int i=0;i<Y;i++){\n\t\t\tfor(int j=0;j<X;j++){\n\t\t\t\tif(dp[i][j]==0)continue;\n\t\t\t\tfor(int dx=-1;dx<=1;dx++){\n\t\t\t\t\tif(j+dx<0 || X<=j+dx)continue;\n\t\t\t\t\tif(c[i][j]==2){\n\t\t\t\t\t\tif(dx==0){\n\t\t\t\t\t\t\tif(i+2<Y)dp[i+2][j] += dp[i][j];\n\t\t\t\t\t\t\telse ans += dp[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(i+1<Y){\n\t\t\t\t\t\t\tif(c[i+1][j+dx]==0)dp[i+1][j+dx] += dp[i][j];\n\t\t\t\t\t\t\telse if(c[i+1][j+dx]==2 && dx==0)dp[i+1][j] += dp[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(dx==0)ans += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main(){\n\tint x,y;\n\twhile(1){\n\t\tcin >> x >> y;\n\t\tif(!x) break;\n\t\tint dp[17][15] = {},field[17][15] = {};\n\t\tfor(int i = 1;i <= y;i++){\n\t\t\tfor(int j = 0;j < x;j++) cin >> field[i][j];\n\t\t}\n\t\tfor(int i = 0;i < x;i++) dp[0][i] = 1;\n\t\tfor(int i = 0;i <= y;i++){\n\t\t\tfor(int j = 0;j < x;j++){\n\t\t\t\tif(field[i][j] == 1) continue;\n\t\t\t\tif(i == 0){\n\t\t\t\t\tif(field[i + 1][j] != 1) dp[i + 1][j] = dp[i][j];\n\t\t\t\t}\n\t\t\t\telse if(field[i][j] == 0){\n\t\t\t\t\tif(i != y){\n\t\t\t\t\t\tif(j >= 1 && field[i + 1][j - 1] == 0) dp[i + 1][j - 1] += dp[i][j];\n\t\t\t\t\t\tif(j <= x - 2 && field[i + 1][j + 1] == 0) dp[i + 1][j + 1] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tif(field[i + 1][j] != 1) dp[i + 1][j] += dp[i][j];\n\t\t\t\t}else{\n\t\t\t\t\tif(field[min(i + 2,y + 1)][j] != 1) dp[min(i + 2,y + 1)][j] += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint cnt = 0;\n\t\tfor(int i = 0;i < x;i++) cnt += dp[y + 1][i];\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nint main()\n{\n    int x, y;\n    int dx[3] = {-1, 0, 1};\n    \n    while (std::cin >> x >> y, x, y) {\n        int field[20][20] = {{0}}, dp[20][20] = {{0}};\n        \n        for (int i = 0; i < 20; ++i) {\n            for (int j = 0; j < 20; ++j) {\n                field[i][j] = 1;\n            }\n        }\n        \n        for (int i = 1; i <= y; ++i) {\n            for (int j = 1; j <= x; ++j) {\n                std::cin >> field[i][j];\n            }\n        }\n\n        for (int i = 1; i <= x; ++i) {\n            if (field[1][i] == 0) dp[1][i] = 1;\n        }\n        \n        //calc\n        int ans = 0;\n\n        for (int i = 1; i <= y; ++i) {\n            for (int j = 1; j <= x; ++j) {\n                \n                switch (field[i][j]) {\n                    case 0:\n                        for (int k = 0; k < 3; ++k) {\n                            int px = j + dx[k], py = i + 1;\n                            \n                            if ((field[py][px] == 2 && k == 1) || field[py][px] == 0) {\n                                dp[py][px] += dp[i][j];\n                            }\n                        }\n                        break;\n                    case 2:\n                        //y-1\n                        if (i == y -1) ans += dp[i][j];\n                        if (dp[i + 2][j] != 1) dp[i + 2][j] += dp[i][j];\n                        break;\n                    default:\n                        break;\n                }\n            }\n        }\n\n        for (int i = 1; i <= x; ++i) {\n            ans += dp[y][i];\n        }\n\n        std::cout << ans << std::endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nint field[20][20];\nlong long dp[20][20];\n\nint main()\n{\n  int c1, c2;\n  while (scanf(\" %d %d \", &c1, &c2) == 2) {\n    if (c1 == 0 && c2 == 0) {break;}\n    for (int i = 0; i < 20; i++) {\n      fill(field[i], &field[i][20], 1);\n      fill(dp[i], &dp[i][20], 0);\n    }\n    for (int i = 1; i <= c1; i++) {\n      for (int j = 1; j <= c2; j++) {\n\tscanf(\" %d \", &field[i][j]);\n      }\n    }\n    /*for (int i = 0; i < 20; i++) {\n      for (int j = 0; j < 20; j++) {\n\tprintf(\"%d\", field[i][j]);\n      }\n      printf(\"\\n\");\n      }*/\n    \n    for (int i = 1; i <= c2; i++) {\n      dp[1][i] = 1;\n    }\n    for (int i = 1; i < c1; i++) {\n      for (int j = 1; j <= c2; j++) {\n\tif (field[i][j] == 0) {\n\t  if (field[i + 1][j - 1] != 2) {dp[i + 1][j - 1] += dp[i][j];}\n\t  dp[i + 1][j] += dp[i][j];\n\t  if (field[i + 1][j + 1] != 2) {dp[i + 1][j + 1] += dp[i][j];}\n\t} else if (field[i][j] == 2) {\n\t  dp[i + 2][j] += dp[i][j];\n\t} \n      }\n    }\n    long long sum = 0;\n    for (int i = 0; i <= 2; i++) {\n      for (int j = 1; j <= c2; j++) {\n\tif (i != 0 || field[c1 + i][j] != 1) {\n\t  sum += dp[c1 + i][j];\n\t}\n      }\n    }\n    \n    printf(\"%d\\n\", sum);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nint m[500][500];\nint dp[500][500];\n\nint dx[]={-1,0,1};\n\nint solve(int r,int c){\n  rep(i,r+2)rep(j,c)dp[i][j]=0;\n  rep(j,c)if(m[0][j] == 0)dp[0][j]=1;\n\n  rep(i,r-1){\n    rep(j,c){\n      if (m[i][j] == 0 ){\n\trep(k,3){\n\t  int nex = j+dx[k];\n\t  if (nex<0||nex>=c)continue;\n\t  if (m[i+1][nex] == 0)dp[i+1][nex]+=dp[i][j];\n\t  else if (m[i+1][nex] == 2 && k == 1)dp[i+1][nex]+=dp[i][j];\n\t}\n      }else if (m[i][j] == 2 && m[i+2][j] != 1){\n\tdp[i+2][j]+=dp[i][j];\n      }\n    }\n  }\n  \n  int ans = 0;\n  rep(j,c)ans+=dp[r][j]+dp[r-1][j];\n  return ans;\n}\n\nmain(){\n  int c,r;\n  while(cin>>c>>r && r){\n    rep(i,r)rep(j,c)cin>>m[i][j];\n    rep(j,c)m[r][j]=0;\n    cout << solve(r,c) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n\n#define SIZE 15\n\nusing namespace std;\n \nint main(){\n    std::ios_base::sync_with_stdio(false);\n\n\tint X,Y;\n\tint course[SIZE][SIZE+1];\n\tint dp[SIZE][SIZE+1];\n\tint ans;\n\n\twhile(1){\n\t\tcin>>X>>Y;\n\t\tif(X==0&&Y==0) break;\n\n\t\tfor(int i=0;i<Y*X;i++) cin>>course[i/X][i%X];\n\t\tfor(int i=0;i<X;i++) course[Y+1][i]=0;\n\t\tfor(int i=0;i<Y*(X+1);i++) dp[i/X][i%X]=(i/X==0&&course[i/X][i%X]==0)?1:0;\n\n\t\tfor(int i=0;i<(Y-1)*X;i++){\n\t\t\tif(dp[i/X][i%X]>0){\n\t\t\t\tif(course[i/X][i%X]==0){\n\t\t\t\t\tif(i%X!=0){\n\t\t\t\t\t\tif(course[i/X+1][i%X-1]==0) dp[i/X+1][i%X-1]+=dp[i/X][i%X];\n\t\t\t\t\t}\n\t\t\t\t\t\tif(course[i/X+1][i%X]!=1) dp[i/X+1][i%X]+=dp[i/X][i%X];\n\t\t\t\t\t\tif(i%X!=X-1){\n\t\t\t\t\t\t\tif(course[i/X+1][i%X+1]==0) dp[i/X+1][i%X+1]+=dp[i/X][i%X];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(course[i/X][i%X]==2){\n\t\t\t\t\t\tif(course[i/X+2][i%X]!=1) dp[i/X+2][i%X]+=dp[i/X][i%X];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\tans=0;\n\t\tfor(int i=(Y-1)*X;i<(Y+1)*X;i++){\n\t\t\tans+=dp[i/X][i%X];\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n \n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint gole, X, Y;\nint map[15][15];\n\nbool check(int x, int y, int flag) { // flag: ツ陳シツ進ツつオツづつォツつスツつゥ\n\tif (x < 0 || x >= X) return false;\n\tif (y >= Y) { gole += flag; return false; }\n\tif (map[y][x] == 1) return false;\n\tif (!flag && map[y][x] == 2) return false;\n\treturn true;\n}\n\nint main() {\n\twhile (cin >> X >> Y, X || Y) {\n\t\tint pattern[15][15] = {0};\n\t\tgole = 0;\n\t\tfor (int y = 0; y < Y; ++y)\n\t\t\tfor (int x = 0; x < X; ++x)\n\t\t\t\tcin >> map[y][x];\n\n\t\tfor (int x = 0; x < X; ++x)\n\t\t\tif (map[0][x] == 0)\n\t\t\t\tpattern[0][x] = 1;\n\n\t\tfor (int y = 1; y < Y; ++y)\n\t\t\tfor (int x = 0; x < X; ++x) {\n\t\t\t\tif (map[y-1][x] == 0) {\n\t\t\t\t\tif (check(x-1, y, false)) pattern[y][x-1] += pattern[y-1][x];\n\t\t\t\t\tif (check(x,   y, true))  pattern[y][x]   += pattern[y-1][x];\n\t\t\t\t\tif (check(x+1, y, false)) pattern[y][x+1] += pattern[y-1][x];\n\t\t\t\t}\n\t\t\t\telse if (map[y-1][x] == 1) continue;\n\t\t\t\telse if (check(x, y+1, pattern[y-1][x])) pattern[y+1][x] += pattern[y-1][x];\n\t\t\t};\n\n\t\tcout << gole << endl;\n\n\t\tfor (int x = 0; x < X; ++x) gole += pattern[Y-1][x];\n\n\t\tcout << gole << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst int MAX_SIZE = 15;\nchar field[MAX_SIZE+1][MAX_SIZE+3];\nint dp[MAX_SIZE+1][MAX_SIZE+3];\nint w, h;\n\nbool judge(int i, int j){\n\tif(j > 0 && j <= w && field[j][i] == '0' && j <= h)\n\t\treturn true;\n\treturn false;\n}\n\nint main(){\n\twhile(cin >> w >> h){\n\t\tif(w == 0 && h == 0) break;\n\t\tfor(int i = 1; i <= h; i++){\n\t\t\tfor(int j = 1; j <= w; j++)\n\t\t\t\tcin >> field[j][i];\n\t\t}\n\t\tint pattern = 0;\n\t\tfor(int i = 0; i < MAX_SIZE+1; i++){\n\t\t\tfor(int j = 0; j < MAX_SIZE+3; j++){\n\t\t\t\tdp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1; i <= w; i++){\n\t\t\tif(field[i][1] == '0')\n\t\t\t\tdp[i][1] = 1;\n\t\t}\n\t\tfor(int i = 1; i < h; i++){\n\t\t\tfor(int j = 1; j <= w; j++){\n\t\t\t\tif(field[j][i] == '2')\n\t\t\t\t\tdp[j][i+2] += dp[j][i];\n\t\t\t\tif(field[j][i] == '0'){\n\t\t\t\t\tdp[j][i+1] += dp[j][i];\n\t\t\t\t\tif(judge(i+1, j-1)) dp[j-1][i+1] += dp[j][i];\n\t\t\t\t\tif(judge(i+1, j+1)) dp[j+1][i+1] += dp[j][i];\n\t\t\t\t}\n\t\t\t\tif(field[j][i] == '1')\n\t\t\t\t\tdp[j][i] = 0;\n\t\t\t}\n\t\t}\n\t\tint count = 0;\n\t\tfor(int i = h; i <= h+1; i++){\n\t\t\tfor(int j = 1; j <= w; j++){\n\t\t\t\tcount += dp[j][i];\n\t\t\t}\n\t\t}\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int W, H, mas[16][16];\n  while( cin >> W >> H, W){\n    for(int i = 0; i < H; i++){\n      for(int j = 0; j < W; j++){\n        cin >> mas[i][j];\n      }\n    }\n    vector< vector< int > > dp( H + 1, vector< int >(W, 0));\n    for(int i = 0; i < W; i++){\n      if(mas[0][i] != 1) dp[0][i] = 1;\n    }\n    for(int i = 0; i < H; i++){\n      for(int j = 0; j < W; j++){\n        if(dp[i][j] == 0) continue;\n        if(mas[i][j] == 0){\n          for(int k = -1; k <= 1; k++){\n            if(j + k < 0 || j + k >= W) continue;\n            if((i == H - 1 && k == 0) || (i != H - 1 && k == 0 && mas[i + 1][j + k] == 2) || (i != H - 1 && mas[i + 1][j + k] == 0)){\n              dp[i + 1][j + k] += dp[i][j];\n            }\n          }\n        } else if(mas[i][j] == 2){\n          if(i >= H - 2 || mas[i + 2][j] != 1){\n            dp[max(H, i + 2)][j] += dp[i][j];\n          }\n        }\n      }\n    }\n\n    int ret = 0;\n    for(int i = 0; i < W; i++){\n      ret += dp[H][i];\n    }\n    cout << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst int MAX_SIZE = 15;\nchar field[MAX_SIZE+1][MAX_SIZE+3];\nint dp[MAX_SIZE+1][MAX_SIZE+3];\nint w, h;\n\nbool judge(int i, int j){\n\tif(j > 0 && j <= w && field[j][i] == '0')\n\t\treturn true;\n\treturn false;\n}\n\nint main(){\n\twhile(cin >> w >> h){\n\t\tif(w == 0 && h == 0) break;\n\t\tfor(int i = 1; i <= h; i++){\n\t\t\tfor(int j = 1; j <= w; j++)\n\t\t\t\tcin >> field[j][i];\n\t\t}\n\t\tint pattern = 0;\n\t\tfor(int i = 0; i < MAX_SIZE+1; i++){\n\t\t\tfor(int j = 0; j < MAX_SIZE+3; j++){\n\t\t\t\tdp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1; i <= w; i++){\n\t\t\tdp[i][1] = 1;\n\t\t}\n\t\tfor(int i = 1; i <= h; i++){\n\t\t\tfor(int j = 1; j <= w; j++){\n\t\t\t\tif(field[j][i] == '2')\n\t\t\t\t\tdp[j][i+2] += dp[j][i];\n\t\t\t\tif(field[j][i] == '0'){\n\t\t\t\t\tdp[j][i+1] += dp[j][i];\n\t\t\t\t\tif(judge(i+1, j-1)) dp[j-1][i+1] += dp[j][i];\n\t\t\t\t\tif(judge(i+1, j+1)) dp[j+1][i+1] += dp[j][i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint count = 0;\n\t\tfor(int i = h+1; i <= h+2; i++){\n\t\t\tfor(int j = 1; j <= w; j++){\n\t\t\t\tcount += dp[j][i];\n\t\t\t}\n\t\t}\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nint main(void){\n\tint x,y,i,j;\n\twhile(scanf(\"%d%d\",&x,&y),x,y){\n\t\tint masu[20][20]={ 0 };\n\t\tint dp[20][20]={0};\n\t\tint ans=0;\n\t\tfor(i=1;i<=y;i++){\n\t\t\tfor(j=1;j<=x;j++){\n\t\t\t\tscanf(\"%d\",&masu[i][j]);\n\t\t\t}\n\t\t}\n\t\tfor(j=1;j<=x;j++){\n\t\t\tif(masu[1][j]==0)dp[1][j]=1;\n\t\t}\n\t\tfor(i=2;i<=y;i++){\n\t\t\tfor(j=1;j<=x;j++){\n\t\t\t\tif(masu[i][j]==0){\n\t\t\t\t\tif(masu[i-1][j-1]!=2)dp[i][j]+=dp[i-1][j-1];\n\t\t\t\t\tif(masu[i-1][j]!=2)\t dp[i][j]+=dp[i-1][j];\n\t\t\t\t\tif(masu[i-1][j+1]!=2)dp[i][j]+=dp[i-1][j+1];\n\t\t\t\t\tif(masu[i-2][j]==2){\n\t\t\t\t\t\tdp[i][j]+=dp[i-2][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(masu[i][j]==1){\n\t\t\t\t\tdp[i][j]=0;\n\t\t\t\t}\n\t\t\t\tif(masu[i][j]==2){\n\t\t\t\t\tdp[i][j]=dp[i-1][j];\n\t\t\t\t\tif(masu[i-2][j]==2)dp[i][j]+=dp[i-2][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=x;i++){\n\t\t\tans+=dp[y][i];\n\t\t\tif(masu[y-1][i]==2)ans+=dp[y-1][i];\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 0203\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main(){\n\twhile(1){\n\t\tint X, Y, c;\n\t\tvector<vector<int> > grid, count;\n\t\n\t\tcin>>X>>Y;\n\t\tif((X == 0) && (Y == 0))\n\t\t\tbreak;\n\n\t\tgrid.resize(X+2);\n\t\tfor(int i=0;i<X+2;i++)\n\t\t\tgrid[i].resize(Y+2);\n\n\t\tfor(int j=0;j<Y+2;j++){\n\t\t\tfor(int i=0;i<X+2;i++){\n\t\t\t\tif((i == 0) || (i == X+1) || (j == 0) || (j == Y+1)){\n\t\t\t\t\tgrid[i][j] = 1;\n\t\t\t\t}else{\n\t\t\t\t\tcin>>c;\n\t\t\t\t\tgrid[i][j] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcount.resize(X+2);\n\t\tfor(int i=0;i<X+2;i++)\n\t\t\tcount[i].resize(Y+2);\n\n\t\tfor(int i=0;i<X+2;i++)\n\t\t\tfor(int j=0;j<Y+2;j++)\n\t\t\t\tcount[i][j] = 0;\n\n\t\tfor(int i=1;i<=X;i++)\n\t\t\tif(grid[i][1] == 0)\n\t\t\t\tcount[i][1]++;\n\n\t\tfor(int j=2;j<=Y;j++){\n\t\t\tfor(int i=1;i<=X;i++){\n\t\t\t\tif(grid[i][j] == 1){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(grid[i][j] == 2){\n\t\t\t\t\tif(grid[i][j-1] != 2)\n\t\t\t\t\t\tcount[i][j] += count[i][j-1];\n\t\t\t\t\tif(grid[i][j-2] == 2)\n\t\t\t\t\t\tcount[i][j] += count[i][j-2];\n\t\t\t\t}else{\n\t\t\t\t\tfor(int k=-1;k<=1;k++)\n\t\t\t\t\t\tif(grid[i+k][j-1] != 2)\n\t\t\t\t\t\t\tcount[i][j] += count[i+k][j-1];\n\t\t\t\t\tif(grid[i][j-2] == 2)\n\t\t\t\t\t\tcount[i][j] += count[i][j-2];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor(int i=1;i<=X;i++){\n\t\t\tans += count[i][Y];\n\t\t\tif(grid[i][Y-1] == 2)\n\t\t\t\tans += count[i][Y-1];\n\t\t}\n\t\t\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\n\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nint x, y, c[50][50], dp[50][50];\nconst int dx[3] = {-1, 0, 1};\n\nvoid solve() {\n  memset(dp, 0, sizeof dp);\n  \n  rep(i,y) rep(j,x) cin>>c[i][j];\n  \n  rep(i,x) if (c[0][i] == 0) dp[0][i] = 1;\n  \n  rep(i,y-1) rep(j,x) {\n    if (c[i][j] == 0) {\n      rep(z,3) {\n        int ti = i + 1, tj = j + dx[z];\n        if (tj < 0 || tj >= x) continue;\n        if (c[ti][tj] == 1) continue;\n        if (c[ti][tj] == 2 && z != 1) continue;\n        dp[ti][tj] += dp[i][j];\n      }\n    } else if (c[i][j] == 2 && c[i+2][j] != 1) {\n      dp[i+2][j] += dp[i][j];\n    }\n  }\n  /*\n  rep(i,y+1) {\n    rep(j,x) printf(\"%8d\",dp[i][j]);\n    cout<<endl;\n  }*/\n  \n  int res = 0;\n  rep(j,x) res += dp[y][j] + dp[y-1][j];\n  cout<<res<<endl;\n}\n\nint main (int argc, char const* argv[]) {\n  while (cin>>x>>y, x||y) {\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint vis[15][15];\n\nint bfs(int a[15][15], int n, int m, int s, int t)\n{\n  int c = 0;\n  if(s+1 == n){\n    vis[s][t] = 1;\n    return 1;\n  }\n\n  if(vis[s][t] > 0){\n    return vis[s][t];\n  }\n\n  if(a[s][t] == 2){\n    if(s+2 >= n){\n      vis[s][t] = 1;\n      return 1;\n    }\n    if(a[s+2][t] != 1){\n      c = bfs(a, n, m, s+2, t);\n    }\n  } else {\n\n    if(t-1 >= 0){\n      if(a[s+1][t-1] == 0){\n\tc += bfs(a, n, m, s+1, t-1);\n      }\n    }\n    if(a[s+1][t] != 1){\n      c += bfs(a, n, m, s+1, t);\n    }\n    \n    if(t+1 < m){\n      if(a[s+1][t+1] == 0){\n      c += bfs(a, n, m, s+1, t+1);\n      }\n    }\n  }\n  vis[s][t] = c;\n\n  return c;\n}\n\nint main()\n{\n  int n, m, c;\n  int a[15][15];\n\n  while(1){\n    cin >> m >> n;\n    if(n == 0 && m == 0){\n      break;\n    }\n\n    fill(&vis[0][0], &vis[14][14], -1);\n\n    for(int i = 0; i < n; i++){\n      for(int j = 0; j < m; j++){\n\tcin >> a[i][j];\n      }\n    }\n    c = 0;\n    for(int i = 0; i < m; i++){\n      if(a[0][i] != 1){\n\tc += bfs(a, n, m, 0, i);\n      }\n    }\n\n    cout << c << endl;\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint field[16][16];\n// y,xÌ}X©çènßÄÅ«é·×èûÌ\nint dp[16][16];\n\nconst int dy[]={1,1,1};\nconst int dx[]={-1,0,1};\nint w,h;\n\nint search(int sx,int sy){\n\tif(field[sy][sx]==2){\n\t\tif(sy>=h-2){\n\t\t\treturn 1;\n\t\t}\n\t\telse if(field[sy+2][sx]==1)\n\t\t\treturn 0;\n\t\telse{\n\t\t\treturn search(sx,sy+2);\n\t\t}\n\t}\n\tif(dp[sy][sx]!=-1){\n\t\treturn dp[sy][sx];\n\t}\n\tint cnt=0;\n\tfor(int i = 0; i < 3; i++){\n\t\tint nx=sx+dx[i];\n\t\tint ny=sy+dy[i];\n\t\tif(nx>=0&&nx<w){\n\t\t\tif(ny>h-1){\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\telse if(ny==h-1&&field[ny][nx]==0){\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\telse if(field[ny][nx]==2&&dx[i]==0){\n\t\t\t\tcnt+=search(nx,ny);\n\t\t\t}\n\t\t\telse if(field[ny][nx]==0){\n\t\t\t\tcnt+=search(nx,ny);\n\t\t\t}\n\t\t}\n\t}\n\n\tdp[sy][sx]=cnt;\n\treturn dp[sy][sx];\n}\n\n\nint main(){\n\n\twhile(cin>>w>>h&&!(w==0&&h==0)){\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tdp[i][j]=-1;\n\t\t\t}\n\t\t}\n\t\tint sum=0;\n\t\tfor(int i = 0; i < w; i++){\n\t\t\tif(field[0][i]==0)\n\t\t\t\tsum+=search(i,0);\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nint X, Y;\nint status[17][18];\t//status[x][y]\nint i, j;\nint count;\n\nvoid check(int x, int y);\n\nint main(){\n\n\twhile(1){\n\n\t\tcount = 0;\n\n\t\tcin >> X >> Y;\n\n\t\tif(X == 0 && Y == 0){break;}\n\n\t\telse{\n\n\t\t\t//フィールドの入力\n\t\t\t//i行目について( 1 <= i <= Y+2 )\n\t\t\tfor(i = 1; i <= Y+2; i++){\n\t\t\t\t//j文字目について( 0 <= j <= X+1)\n\t\t\t\tfor(j = 0; j <= X+1; j++){\n\n\t\t\t\t\t//Y+1, Y+2列目に移動できるようにする。\n\t\t\t\t\tif(i > Y){\n\t\t\t\t\t\tstatus[j][i] = 0;\n\t\t\t\t\t}\n\t\t\t\t\t//両サイドには障害物を敷き詰める。\n\t\t\t\t\telse if(j == 0 || j == X+1){\n\t\t\t\t\t\tstatus[j][i] = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tcin >> status[j][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(i = 1; i <= X; i++){\n\t\t\t\tcheck(i, 1);\n\t\t\t}\n\n\t\t\tcout << count << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\nvoid check(int x, int y){\n\n\tif(status[x][y] == 0 && y >= Y){\n\t\tcount++;\n\t}\n\telse if(status[x][y] == 1){}\n\telse if(status[x][y] == 2){\n\t\tcheck(x, y+2);\n\t}\n\telse{\n\t\tif(status[x-1][y+1] == 0){\n\t\t\tcheck(x-1, y+1);\n\t\t}\n\t\tif(status[x][y+1] == 0 || status[x][y+1] == 2){\n\t\t\tcheck(x, y+1);\n\t\t}\n\t\tif(status[x+1][y+1] == 0){\n\t\t\tcheck(x+1, y+1);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i, s, n) for(int i = s; i < (int)n; i++)\n#define per(i, n) for(int i = n; i >= 0; i--)\n#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)\n#define FORIT(i, A) for (auto i : A)\n#define PRINT(x) cout << (x) << \"\\n\"\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define MP make_pair\n#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)\n#define SZ(a) int((a).size())\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define NCLR(a) memset((a), -1 ,sizeof(a))\n#define dump(x) cout << #x << \" = \" << (x) << \"\\n\";\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << \"\\n\";\n#define sq(n) (n) * (n)\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef priority_queue<int> maxpq;\ntypedef priority_queue< int, vector<int>, greater<int> > minpq;\nstatic const double EPS = 1e-10;\nstatic const double PI = acos( -1.0 );\nstatic const int mod = 1000000007;\nstatic const int INF = 1 << 30;\nstatic const LL LL_INF = 1152921504606846976;\nstatic const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };\nstatic const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };\n\nint n, m;\nint dp[ 16 ][ 16 ];\nVVI _array;\nVI can_start;\n\nint solve( int now, int x ) {\n\tif ( now >= m ) {\n\t\treturn 1;\n\t}\n\tif ( _array[ now ][ x ] == 1 ) {\n\t\treturn 0;\n\t}\n\tif ( now >= m - 1 ) {\n\t\treturn 1;\n\t}\n\tif ( dp[ now ][ x ] >= 0 ) {\n\t\treturn dp[ now ][ x ];\n\t}\n\tint res = 0;\n\tif ( _array[ now ][ x ] == 2 ) {\n\t\tres += solve( now + 2, x );\n\t}\n\telse {\n\t\tfor ( int i = 0; i < 3; i++ ) {\n\t\t\tif ( x + dx[ i ] < 0 || x + dx[ i ] >= n || ( now + 1 != m && _array[ now + 1 ][ x + dx[ i ] ] == 2 && dx[ i ] != 0 ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tres += solve( now + 1, x + dx[ i ] );\n\t\t}\n\t}\n\treturn dp[ now ][ x ] = res;\n}\n\nint main() {\n\twhile ( ~scanf( \"%d %d\", &n, &m ) && n && m ) {\n\t\t_array.resize( m, VI( n ) );\n\t\tfor ( int i = 0; i < m; i++ ) {\n\t\t\tfor ( int j = 0; j < n; j++ ) {\n\t\t\t\tscanf( \"%d\", &_array[ i ][ j ] );\n\t\t\t\tif ( i == 0 && _array[ i ][ j ] == 0 ) {\n\t\t\t\t\tcan_start.push_back( j );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tNCLR( dp );\n\t\tint ans = 0;\n\t\tfor ( int i = 0; i < can_start.size(); i++ ) {\n\t\t\tans += solve( 0, can_start[ i ] );\n\t\t}\n\t\tprintf( \"%d\\n\", ans );\n\t\tcan_start.clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<algorithm>\n\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint x,y;\nint c[20][20];\nint dp[20][20];\n\nvoid solve() {\n\trep(i,20) rep(j,20) c[i][j]=1;\n\trep(i,20) rep(j,20) dp[i][j]=0;\n\n\trep(i,x) rep(j,y) cin>>c[i][j];\n\n\trep(i,20) if(c[0][i]!=1) dp[0][i]=1;\n\t\n\tfor(int i=0;i<y;i++) {\n\t\tfor(int j=0;j<x;j++) {\n\t\t\tif(c[i][j]==2) {\n\t\t\t\tdp[i+2][j] += dp[i][j];\n\t\t\t}\n\t\t\telse if(c[i][j]==0) {\n\t\t\t\tif(c[i+1][j]!=1) {\n\t\t\t\t\tdp[i+1][j] += dp[i][j];\n\t\t\t\t}\n\t\t\t\tif(0<=j-1 && c[i+1][j-1]==0) {\n\t\t\t\t\tdp[i+1][j-1] += dp[i][j];\n\t\t\t\t}\n\t\t\t\tif(j+1 < x && c[i+1][j+1]==0) {\n\t\t\t\t\tdp[i+1][j+1] += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\n\tint ans=0;\n\trep(i,x) ans+=dp[y-1][i];\n\trep(i,x) ans+=dp[y][i];\n\n\tcout<<ans<<endl;\n\n}\n\nint main() {\n\twhile(cin>>x>>y) {\n\t\tif(x+y==0) return 0;\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#define N 15\nusing namespace std;\nvoid func(int,int);\nint jump(int,int);\nint X,Y,data[N][N],memo[N+2][N];\nint main(){\n  while(1){\n    cin >> X >> Y;\n    if(X==0&&Y==0) break;\n    for(int i=0;i<Y;i++)\n      for(int j=0;j<X;j++)\n\tcin >> data[i][j];\n    for(int i=0;i<Y+2;i++)\n      for(int j=0;j<X;j++)\n\tmemo[i][j]=0;\n    for(int i=0;i<X;i++)\n      if(data[0][i]!=1)\n\tfunc(0,i);\n    int cnt=0;\n    for(int i=0;i<X;i++)\n      cnt+=memo[0][i];\n    cout << cnt << endl;\n  }\n  return 0;\n}\nvoid func(int y,int x){\n  if(y>=Y-1){\n    memo[Y][x]=memo[Y-1][x]=1;\n    return ;\n  }\n  if(0<=x-1&&data[y+1][x-1]==0){\n    if(memo[y+1][x-1]!=0) memo[y][x]+=memo[y+1][x-1];\n    else{\n      func(y+1,x-1),memo[y][x]+=memo[y+1][x-1];\n    }\n  }\n  if(x+1<=X-1&&data[y+1][x+1]==0){\n    if(memo[y+1][x+1]!=0) memo[y][x]+=memo[y+1][x+1];\n    else{\n      func(y+1,x+1),memo[y][x]+=memo[y+1][x+1];\n    }\n  }\n  if(data[y+1][x]==0){\n    if(memo[y+1][x]!=0) memo[y][x]+=memo[y+1][x];\n    else{\n      func(y+1,x),memo[y][x]+=memo[y+1][x];\n    }\n  }\n  if(data[y+1][x]==2){\n    int r=jump(y+1,x);\n    if(r==-2) memo[y][x]+=1;\n    else if(r!=-1){\n      if(memo[r][x]!=0) memo[y][x]+=memo[r][x];\n      else{\n\tfunc(r,x),memo[y][x]+=memo[r][x];\n      }\n    }\n  }\n  if(memo[y][x]==0) data[y][x]=1;\n}\nint jump(int y,int x){\n  y+=2;\n  while(1){\n    if(y>=Y-1) return -2;\n    if(data[y][x]==1) break;\n    if(data[y][x]==0) return y;\n    if(data[y][x]==2) y+=2;\n  }\n  return -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint n,m;\nint i,j;\nint c[15][15],d[15][15];\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d %d\",&m,&n);\n\t\tif(n==0&&m==0)return 0;\n\t\tint ans=0;\n\t\tfor(i=0;i<n;i++)for(j=0;j<m;j++)scanf(\"%d\",&c[i][j]);\n\t\tfor(i=0;i<n;i++)for(j=0;j<m;j++){\n\t\t\td[i][j]=0;\n\t\t}\n\t\tfor(i=0;i<m;i++)if(c[0][i]!=1)d[0][i]=1;\n\t\tfor(i=0;i<n;i++)for(j=0;j<m;j++){\n\t\t\tif(c[i][j]==0){\n\t\t\t\tif(j-1>=0&&j-1<m&&i+1<n&&c[i+1][j-1]==0)d[i+1][j-1]+=d[i][j];\n\t\t\t\tif(j+1>=0&&j+1<m&&i+1<n&&c[i+1][j+1]==0)d[i+1][j+1]+=d[i][j];\n\t\t\t\tif(i+1<n&&c[i+1][j]!=1)d[i+1][j]+=d[i][j];\n\t\t\t}\n\t\t\tif(c[i][j]==2){\n\t\t\t\tif(i+2<n&&c[i+2][j]!=1)d[i+2][j]+=d[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<m;i++)if(c[n-2][i]==2)ans+=d[n-2][i];\n\t\tfor(i=0;i<m;i++)if(c[n-1][i]!=1)ans+=d[n-1][i];\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}\n\t\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n\nint X, Y;\nint field[15][15];\nint dp[16][15];\n\nint main()\n{\n\twhile( std::cin >> X >> Y, X | Y )\n\t{\n\t\tmemset( field, 0, sizeof( field ) );\n\t\tmemset( dp, 0, sizeof( dp ) );\n\n\t\tfor( int i = 0; i != Y; ++i )\n\t\t\tfor( int j = 0; j != X; ++j )\n\t\t\t\tstd::cin >> field[i][j];\n\n\t\tfor( int i = 0; i != X; ++i )\n\t\t\tdp[0][i] = field[0][i] != 1;\n\t\t\n\t\tint ans = 0;\n\t\tfor( int i = 1; i <= Y; ++i )\n\t\t{\n\t\t\tfor( int j = 0; j != X; ++j )\n\t\t\t{\n\t\t\t\tif( i < Y && field[i][j] != 1 )\n\t\t\t\t{\n\t\t\t\t\tfor( int k = -1; k <= 1; ++k )\n\t\t\t\t\t{\t\n\t\t\t\t\t\tif( field[i][j] == 2 && k )\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tif( j + k >= 0 && j + k < X && !field[i-1][j+k] )\n\t\t\t\t\t\t\tdp[i][j] += dp[i-1][j+k];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif( i - 2 > 0 && field[i][j] != 1 && field[i-2][j] == 2 )\n\t\t\t\t\tdp[i][j] += dp[i-2][j];\n\n\t\t\t\tif( i >= Y - 1 )\n\t\t\t\t\tans += dp[i][j];\n\t\t\t}\n\t\t}\n\n\t\tstd::cout << ans << std::endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#define INF 1<<20\nusing namespace std;\n\nint w, h;\nint data[22][22];\nint memo[22][22];\n\nint solve(int x, int y){\n\n  if(x < 0 || x == w || data[y][x]&1) return 0;\n  if(y > h-2) return 1;\n  if(memo[y][x]) return memo[y][x];\n\n  int ret = 0;\n  if(data[y][x] == 2) ret += solve(x, y+2);\n  else{\n    if(!data[y+1][x-1]) ret += solve(x-1, y+1);\n    if(!data[y+1][x+1]) ret += solve(x+1, y+1);\n    ret += solve(x, y+1);\n  }\n  \n  return memo[y][x] = ret;\n}\n\nint main(){\n\n  while(cin >> w >> h, w+h){\n\n    for(int i=0;i<h;i++) for(int j=0;j<w;j++) cin >> data[i][j];\n\n    memset(memo, 0, sizeof(memo));\n    int ans = 0;\n    for(int i=0;i<w;i++) ans += solve(i, 0);\n\n    cout << ans << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n\nusing namespace std;\n\n\nint main() {\n\twhile(1) {\n\t\tint x, y;\n\t\tcin >> y >> x;\n\t\tif(x==0 && y==0) break;\n\t\tint field[x][y];\n\t\tfor(int i=0; i<x; i++) {\n\t\t\tfor(int j=0; j<y; j++) {\n\t\t\t\tcin >> field[i][j];\n\t\t\t}\n\t\t}\n\t\tint dp[x+1][y];\n\t\tfor(int i=0; i<x+1; i++) {\n\t\t\tfor(int j=0; j<y; j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<x; i++) {\n\t\t\tfor(int j=0; j<y; j++) {\n\t\t\t\tif(i==0 && field[i][j] == 0) dp[i][j] = 1;\n\t\t\t\telse {\n\t\t\t\t\tif(field[i][j] == 0) {\n\t\t\t\t\t\tif(0<j && field[i-1][j-1] == 0) dp[i][j] += dp[i-1][j-1];\n\t\t\t\t\t\tif(field[i-1][j] == 0) dp[i][j] += dp[i-1][j];\n\t\t\t\t\t\tif(j<y-1 && field[i-1][j+1] == 0) dp[i][j] += dp[i-1][j+1];\n\t\t\t\t\t}\n\t\t\t\t\tif(field[i][j] == 2) {\n\t\t\t\t\t\tif(field[i-1][j] == 0) dp[i][j] += dp[i-1][j];\n\t\t\t\t\t\tdp[i+2][j] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<y; i++) dp[x][i] += dp[x-1][i];\n\n\t\tint sum=0;\n\t\tfor(int i=0; i<y; i++) sum += dp[x][i];\n\t\tcout << sum << endl;\n\n\t\t//cout << endl;\n\t\t//for(int i=0; i<x+1; i++) {\n\t\t\t//for(int j=0; j<y; j++) {\n\t\t\t\t//cout << dp[i][j] << ' ';\n\t\t\t//}\n\t\t\t//cout << endl;\n\t\t//}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define LL long long\n#define VI vector<int>\n#define VVI vector<vector<int>>\n#define VVVI vector<vector<vector<int>>>\n#define VL vector<LL>\n#define VVL vector<vector<LL>>\n#define VVVL vector<vector<vector<LL>>>\n#define VB vector<bool>\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n#define EPS 1e-14\n\ntemplate<class T> T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> void print(T x) { std::cout << x << std::endl; }\n\nconst std::string YES = \"YES\", Yes = \"Yes\", NO = \"NO\", No = \"No\";\nconst std::vector<int> dy = { 0, -1, 0, 1 }, dx = { 1, 0, -1, 0 };    // 4近傍（右, 下, 左, 上）\n\nusing namespace std;\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (true) {\n        int X, Y;\n        cin >> X >> Y;\n        if (X == 0 and Y == 0) { break; }\n\n        VVI field(Y, VI(X, 0));\n        FOR(y, 0, Y) {\n            FOR(x, 0, X) {\n                int c;\n                cin >> c;\n                field[y][x] = c;\n            }\n        }\n\n        VVI dp(Y, VI(X, 0));\n        FOR(x, 0, X) {\n            dp[0][x] = (field[0][x] == 0 ? 1 : 0);\n        }\n\n        FOR(y, 0, Y - 1) {\n            FOR(x, 0, X) {\n                // 移動可能なマス\n                if (field[y][x] == 0) {\n                    if (0 <= x - 1 and field[y + 1][x - 1] == 0) {\n                        dp[y + 1][x - 1] += dp[y][x];\n                    }\n                    if (field[y + 1][x] != 1) {\n                        dp[y + 1][x] += dp[y][x];\n                    }\n                    if (x + 1 < X and field[y + 1][x + 1] == 0) {\n                        dp[y + 1][x + 1] += dp[y][x];\n                    }\n                // ジャンプ台\n                } else if (field[y][x] == 2) {\n                    if (y + 2 >= Y) {\n                        dp[Y -1][x] += dp[y][x];\n                    }\n                    else if (y + 2 < Y and field[y + 2][x] != 1) {\n                        dp[y + 2][x] += dp[y][x];\n                    }\n                }\n            }\n        }\n        print(SUM(dp[Y - 1]));\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#define MAX_N 15\n\nusing namespace std;\n\nint map[MAX_N+1][MAX_N+1];\nint dp[MAX_N+2][MAX_N+2];\nint X, Y;\nint ans;\n\nvoid solve();\n\nint main()\n{\n\twhile (cin>>X>>Y, X != 0 && Y != 0) {\n\t\tfor (int i = 1; i <= Y; i++) {\n\t\t\tfor (int j = 1; j <= X; j++) {\n\t\t\t\tcin>>map[j][i];\n\t\t\t\tdp[j][i] = 0;\n\t\t\t}\n\t\t}\n\t\tsolve();\n\t}\n\t\n}\n\nvoid solve()\n{\n\tfor (int i = 1; i <= Y ; i++) {\n\t\tfor (int  j = 1; j <= X; j++) {\n\t\t\tif (i == 1) {\n\t\t\t\tmap[j][i] == 1 ? dp[j][i] = 0 : dp[j][i] = 1;\n\t\t\t} else {\n\t\t\t\tswitch (map[j][i]) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tif (map[j-1][i-1] != 2) {\n\t\t\t\t\t\t\tdp[j][i] += dp[j-1][i-1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (map[j][i-1] != 2) {\n\t\t\t\t\t\t\tdp[j][i] += dp[j][i-1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (map[j+1][i-1] != 2) {\n\t\t\t\t\t\t\tdp[j][i] += dp[j+1][i-1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (map[j][i-2] == 2) {\n\t\t\t\t\t\t\tdp[j][i] += dp[j][i-2];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tdp[j][i] = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tif (map[j][i-1] != 2) {\n\t\t\t\t\t\t\tdp[j][i] += dp[j][i-1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (map[j][i-2] == 2) {\n\t\t\t\t\t\t\tdp[j][i] += dp[j][i-2];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 1; i <= X; i++) {\n\t\tans += dp[i][Y];\n\t\tif (map[i][Y-1] == 2) ans += dp[i][Y-1];\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint c[17][15];\nint p[17][15];\n\nint main() {\n    int w, h;\n    while (cin >> w >> h, w|h) {\n        for (int y = 0; y < h; y++) {\n            for (int x = 0; x < w; x++) {\n                int ci;\n                cin >> ci;\n                c[y][x] = ci;\n            }\n        }\n        for (int x = 0; x < w; x++) {\n            c[h][x] = c[h+1][x] = 2;\n        }\n        memset(p, 0, sizeof(p));\n        for (int y = 0; y < h+2; y++) {\n            for (int x = 0; x < w; x++) {\n                if (c[y][x] == 1) {\n                    continue;\n                }\n                if (y == 0) {\n                    p[y][x] = 1;\n                    continue;\n                }\n                if (c[y][x] == 0) {\n                    if (x > 0 && c[y-1][x-1] == 0) {\n                        p[y][x] += p[y-1][x-1];\n                    }\n                    if (x+1 < w && c[y-1][x+1] == 0) {\n                        p[y][x] += p[y-1][x+1];\n                    }\n                }\n                if (c[y-1][x] == 0) {\n                    p[y][x] += p[y-1][x];\n                }\n                if (y >= 2 && c[y-2][x] == 2) {\n                    p[y][x] += p[y-2][x];\n                }\n            }\n        }\n        int ans = 0;\n        for (int y = h; y < h+2; y++) {\n            for (int x = 0; x < w; x++) {\n                ans += p[y][x];\n            }\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nint main()\n{\n\tfor(int w,h;cin>>w>>h,w|h;){\n\t\tvvi field(h+1,vi(w));\n\t\trep(i,h) rep(j,w)\n\t\t\tcin>>field[i][j];\n\t\t\n\t\tvvi dp(h+1,vi(w));\n\t\trep(i,w)\n\t\t\tif(field[0][i]!=1)\n\t\t\t\tdp[0][i]=1;\n\t\trep(i,h-1){\n\t\t\trep(j,w){\n\t\t\t\tif(field[i][j]==1){\n\t\t\t\t\tdp[i][j]=0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(field[i][j]==2){\n\t\t\t\t\tdp[i+2][j]+=dp[i][j];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(field[i+1][j]==2)\n\t\t\t\t\tdp[i+1][j]+=dp[i][j];\n\t\t\t\tfor(int k=-1;k<=1;k++)\n\t\t\t\t\tif(0<=j+k && j+k<w && field[i+1][j+k]==0)\n\t\t\t\t\t\tdp[i+1][j+k]+=dp[i][j];\n\t\t\t}\n\t\t}\n\t\tll res=0;\n\t\trepi(i,h-1,h+1) rep(j,w)\n\t\t\tif(field[i][j]!='1')\n\t\t\t\tres+=dp[i][j];\n\t\tcout<<res<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main(){\n  while(true){\n    int xsize,ysize;\n    cin>>xsize>>ysize;\n    if(!xsize&&!ysize)break;\n    int course[xsize+2][ysize];\n    for(int y=0;y<ysize;y++){\n      for(int x=0;x<xsize;x++){\n\tcin>>course[x+1][y];\n      }\n    }\n    int pattern[xsize+2][ysize+1];\n    for(int y=0;y<ysize;y++){\n      for(int x=0;x<xsize+2;x++){\n\tif(y) pattern[x][y] = 0;\n\telse if(course[x][y]) pattern[x][y] = 0;\t    \n\telse pattern[x][y] = 1;\n      }\n    }\n    pattern[0][0] = 0;\n    pattern[xsize+1][0] = 0;\n    int count = 0;\n    for(int y=0;y<ysize;y++){\n      for(int x=1;x<xsize+1;x++){\n\tif(course[x][y]==0){\n\t  if(y==ysize-1) count+=pattern[x][y];\n\t  else{\n\t    if(course[x-1][y+1]==0)\n\t      pattern[x-1][y+1] += pattern[x][y];\n\t    if(course[x][y+1]!=1)\n\t      pattern[x][y+1] += pattern[x][y];\n\t    if(course[x+1][y+1]==0)\n\t      pattern[x+1][y+1] += pattern[x][y];\n\t  }\n\t}\n\tif(course[x][y]==2){\n\t  if(y==ysize-2) count+= pattern[x][y];\n\t  else if(y==ysize-1) count+= pattern[x][y];\n\t  else pattern[x][y+2] += pattern[x][y];\n\t}\n      }\n    }\n    cout<<count<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nint map[16][16];\nint x,y;\nint ans;\nint goalmap[16][16];\nint s_map[16][16];\n\nvoid serch(int nowx,int nowy)\n{\n\tint next[3]={-1,0,1};\n/*\n\ts_map[nowy][nowx]=1;\n\t\n\tgetchar();\n\t\n\tsystem(\"cls\");\n\tcout << \"x:\" << nowx << \" y:\" << nowy << endl;\n\tcout << \"ans:\" << ans << endl;\n\tfor(int i=0;i<y;i++)\n\t{\n\t\tfor(int j=0;j<x;j++)\n\t\t{\n\t\t\tcout << s_map[i][j] << \" \" ;\n\t\t}\n\t\tcout << endl;\n\t}\n//*/\n\tif(goalmap[nowy][nowx]==-1)\n\t{\n//\t\tcout << \"ツ湘。ツ害ツ閉ィツづ按つ、\" << endl;\n\t\ts_map[nowy][nowx]=0;\n\t\treturn ;\n\t}\n\t\n\tif(map[nowy][nowx]==2)\n\t{\n//\t\tcout << \"jump\" << endl;\n\t\t\n\t\tif(nowy+2>=y-1)\n\t\t{\n//\t\t\tcout << \"goalup_jump\" << endl;\n\t\t\tans++;\n\t\t\ts_map[nowy][nowx]=0;\n\t\t\treturn ;\n\t\t}\n\t\t\n\t\tserch(nowx,nowy+2);\n\t}\n\telse\n\t{\n\t\tfor(int i=0;i<3;i++)\n\t\t{\n\t\t\tif(nowx+next[i]>=0 && nowx+next[i]<x)\n\t\t\t{\n\t\t\t\tif(map[nowy+1][nowx+next[i]]!=-1)\n\t\t\t\t{\n\t\t\t\t\tif(nowy+1>=y)\n\t\t\t\t\t{\n//\t\t\t\t\t\tcout << \"goalup\" << endl;\n\t\t\t\t\t\tans++;\n\t\t\t\t\t\ts_map[nowy][nowx]=0;\n\t\t\t\t\t\treturn ;\n\t\t\t\t\t}\n//\t\t\t\t\tcout << \"next 2\" << endl;\n\t\t\t\t\tif(map[nowy+1][nowx+next[i]]!=2)\n\t\t\t\t\t\tserch(nowx+next[i],nowy+1);\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif(nowx+next[i]==nowx)\n\t\t\t\t\t\t\tserch(nowx+next[i],nowy+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\ts_map[nowy][nowx]=0;\n\treturn ;\n}\n\nint main()\n{\n\tint i,j;\n\t\n\tfor(;;)\n\t{\n\t\tcin >> x >> y ;\n\t\tif(x==0 && y==0)\n\t\t\tbreak;\n\t\t\n\t\tfor(i=0;i<y;i++)\n\t\t{\n\t\t\tfor(j=0;j<x;j++)\n\t\t\t{\n\t\t\t\tcin >> map[i][j] ;\n\t\t\t}\n\t\t}\n\t\t\n\t\tans=0;\n\t\t\n\t\tfor(i=0;i<y;i++)\n\t\t\tfor(j=0;j<x;j++)\n\t\t\t{\n\t\t\t\tif(map[i][j]==1)\n\t\t\t\t\tgoalmap[i][j]=-1;\n\t\t\t\telse\n\t\t\t\t\tgoalmap[i][j]=0;\n\t\t\t\ts_map[i][j]=0;\n\t\t\t}\n\t\t\n\t\tfor(i=0;i<x;i++)\n\t\t{\n\t\t\tserch(i,0);\n\t\t}\n\t\t\n/*\n\t\tfor(i=0;i<x;i++)\n\t\t{\n\t\t\tcout << goalmap[0][i] << endl;\n\t\t\tif(goalmap[0][i]!=-1)\n\t\t\t\tans+=goalmap[0][i];\n\t\t}\n\t\t\n\n\t\tfor(i=0;i<y;i++)\n\t\t{\n\t\t\tfor(j=0;j<x;j++)\n\t\t\t{\n\t\t\t\tcout << goalmap[i][j] << \" \" ;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n//*/\n\t\t\n\t\tcout << ans << endl;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nint main()\n{\n\tint prev[3]={-1,0,1};\n\tint x,y,i,j;\n\t\n\tfor(;;)\n\t{\n\t\tcin >> x >> y ;\n\t\tif(x==0 && y==0)\n\t\t\tbreak;\n\t\tint map[20][20]={0};\n\t\tint ansmap[20][20]={0};\n\t\tint ans=0;\n\t\tfor(i=0;i<y;i++)\n\t\t{\n\t\t\tfor(j=0;j<x;j++)\n\t\t\t{\n\t\t\t\tcin >> map[i][j] ;\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<x;i++)\n\t\t{\n\t\t\tansmap[0][i]=1;\n\t\t}\n\t\tfor(i=0;i<y;i++)\n\t\t{\n\t\t\tfor(j=0;j<x;j++)\n\t\t\t{\n\t\t\t\tif(map[i][j]==0 && i<y-1)\n\t\t\t\t{\n\t\t\t\t\tfor(int k=0;k<3;k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(j+prev[k]>=0 && j+prev[k]<x)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(map[i+1][j+prev[k]]==0)\n\t\t\t\t\t\t\t\tansmap[i+1][j+prev[k]]+=ansmap[i][j];\n\t\t\t\t\t\t\telse if(map[i+1][j+prev[k]]==2 && prev[k]==0)\n\t\t\t\t\t\t\t\tansmap[i+1][j+prev[k]]+=ansmap[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(map[i][j]==2)\n\t\t\t\t{\n\t\t\t\t\tansmap[i+2][j]+=ansmap[i][j];\n\t\t\t\t}\n\t\t\t\telse if(map[i][j]==1)\n\t\t\t\t\tansmap[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(i=-1;i<1;i++)\n\t\t{\n\t\t\tfor(j=0;j<x;j++)\n\t\t\t{\n\t\t\t\tans+=ansmap[x+i][j];\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nint masu[17][17];\n\nint count;\n\tint n,m;\nvoid saiki(int x,int y){\n\t\n\tif(y<1 || y>n){\n\t\treturn;\n\t}\n\t//printf(\"make %d %d\\n\",x,y);\n\tif(x>=m){\n\t\t//printf(\"ans %d %d\\n\",x,y);\n\t\tcount++;\n\t\treturn;\n\t}\n\t\n\tif(masu[x][y]==0){\n\t\tif(masu[x+1][y-1]==0 && x<=m-2){\n\t\t\tsaiki(x+1,y-1);\n\t\t}\n\t\tif(masu[x+1][y]==0){\n\t\t\tsaiki(x+1,y);\n\t\t}\n\t\tif(masu[x+1][y]==2){\n\t\t\tsaiki(x+1,y);\n\t\t}\n\t\tif(masu[x+1][y+1]==0&& x<=m-2){\n\t\t\tsaiki(x+1,y+1);\n\t\t}\n\t}\n\tif(masu[x][y]==1){\n\t}\n\tif(masu[x][y]==2){\n\t\tif(masu[x+2][y]!=1){\n\t\t\tsaiki(x+2,y);\n\t\t}\n\t}\n\t\n\t//printf(\"--- %d %d\\n\",x,y);\n}\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0 && m==0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i=0;i<17;i++){\n\t\t\tfor(int j=0;j<17;j++){\n\t\t\t\tmasu[i][j]=0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=1;j<=m;j++){\n\t\t\t\tcin>>masu[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcount=0;\n\t\t\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tsaiki(0,i);\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",count);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nint m[500][500];\nint dp[500][500];\n\nint dx[]={-1,0,1};\n\nint solve(int r,int c){\n  rep(i,r+2)rep(j,c)dp[i][j]=0;\n  rep(j,c)if(m[0][j] == 0)dp[0][j]=1;\n\n  rep(i,r){\n    rep(j,c){\n      if (m[i][j] == 0 && i != r-1){\n\trep(k,3){\n\t  int nex = j+dx[k];\n\t  if (nex<0||nex>=c)continue;\n\t  if (m[i+1][nex] == 0)dp[i+1][nex]+=dp[i][j];\n\t  else if (m[i+1][nex] == 2 && k == 1)dp[i+1][nex]+=dp[i][j];\n\t}\n      }else if (m[i][j] == 2 && m[i+2][j] != 1){\n\tdp[i+2][j]+=dp[i][j];\n      }\n    }\n  }\n  \n  int ans = 0;\n  rep(j,c)ans+=dp[r][j]+dp[r-1][j];//+dp[r+1][j];\n  return ans;\n}\n\nmain(){\n  int c,r;\n  while(cin>>c>>r && r){\n    rep(i,r)rep(j,c)cin>>m[i][j];\n    rep(j,c)m[r][j]=m[r+1][j]=0;\n    cout << solve(r,c) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\nusing namespace std;\n\nenum FState { PLAIN, TREE, JUMP };\nenum PState { LAND, AIR };\n\nint field[17][16];\nint dp[17][16][2];\n\nint main() {\n  int x, y;\n  while (cin >> x >> y, x) {\n    for (int yi = 1; yi <= y; yi++) {\n      for (int xi = 1; xi <= x; xi++) {\n        cin >> field[xi][yi];\n      }\n      field[0][yi] = field[x + 1][yi] = TREE;\n    }\n\n    for (int xi = 1; xi <= x; xi++) {\n      dp[xi][1][LAND] = field[xi][1] == TREE ? 0 : 1;\n      dp[xi][1][AIR] = 0;\n    }\n    for (int yi = 2; yi <= y; yi++) {\n      for (int xi = 1; xi <= x; xi++) {\n        // AIR\n        dp[xi][yi][AIR] = field[xi][yi - 1] == JUMP ? dp[xi][yi - 1][LAND] : 0;\n        // LAND\n        auto& ldp = dp[xi][yi][LAND];\n        switch (field[xi][yi]) {\n        case PLAIN:\n          ldp = dp[xi][yi - 1][AIR];\n          for (int offset : {-1, 0, 1}) {\n            if (field[xi + offset][yi - 1] == PLAIN) ldp += dp[xi + offset][yi - 1][LAND];\n          }\n          break;\n        case TREE:\n          ldp = 0;\n          break;\n        case JUMP:\n          ldp = dp[xi][yi - 1][AIR];\n          if (field[xi][yi - 1] == PLAIN) ldp += dp[xi][yi - 1][LAND];\n          break;\n        }\n      }\n    }\n    \n    int r = 0;\n    for (int xi = 1; xi <= x; xi++) {\n      r += dp[xi][y][LAND] + dp[xi][y][AIR];\n    }\n    cout << r << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#define NORMAL 0\n#define TREE 1\n#define JUMP 2\n#define DR_NUM 3 // 方向数\n\nusing namespace std;\n\nconst int dy[DR_NUM] = {1,1,1}, dx[DR_NUM] = {-1,0,1};\n\nint main(void){\n\tint x, y, course[15][15], dp[17][15], i, j, k, l, ans;\n\twhile(1){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif(x == 0 && y == 0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(i = 0;i < y;i++){\n\t\t\tfor(j = 0;j < x;j++){\n\t\t\t\tscanf(\"%d\",&course[i][j]);\n\t\t\t}\n\t\t}\n\t\tmemset(dp,0,sizeof(dp));\n\t\tfor(i = 0;i < x;i++){\n\t\t\tdp[0][i] = 1;\n\t\t}\n\t\tfor(j = 0;j < y;j++){\n\t\t\tfor(k = 0;k < x;k++){\n\t\t\t\tif(course[j + 2][k] != TREE && (course[j][k] == JUMP || j == y - 1)){\n\t\t\t\t\tdp[j + 2][k] += dp[j][k];\n\t\t\t\t}else if(course[j][k] == NORMAL){\n\t\t\t\t\tfor(l = 0;l < DR_NUM;l++){\n\t\t\t\t\t\tif(k + dx[l] >= 0 && k + dx[l] < x && course[j + dy[l]][k + dx[l]] != TREE && !(l != 1 && course[j + dy[l]][k + dx[l]] == JUMP)){\n\t\t\t\t\t\t\tdp[j + dy[l]][k + dx[l]] += dp[j][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = 0;\n\t\tfor(i = 0;i < x;i++){\n\t\t\tans += dp[y][i] + dp[y + 1][i];\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint field[15][15];\nint dp[17][15];\n\nint n, m;\n\nbool isIn(int x, int y){\n    return 0 <= x && x < n && 0 <= y && y < m;\n}\n\nint main(){\n    while(cin >> n >> m, n+m){\n        for(int i=0; i < n; i++) for(int j=0; j< m; j++){cin >> field[i][j];}\n        for(int i=0; i< 16; i++) for(int j=0; j< 15; j++) dp[i][j] = 0;\n        for(int i=0; i < m; i++) dp[0][i] = 1;\n        for(int i=0; i < n-1; i++){\n            for(int j=0; j < m; j++){\n                if(field[i][j] == 0){\n                    for(int k=-1; k <= 1; k++){\n                        if(isIn(i+1, j+k) && !(k != 0 && field[i+1][j+k] == 2)){\n                            dp[i+1][j+k] += dp[i][j];\n                        }\n                    }\n                }\n                else if(field[i][j] == 1) dp[i][j] = 0;\n                else if(field[i][j] == 2) dp[i+2][j] += dp[i][j];\n            }\n        }\n        for(int i=0; i< m; i++) if(field[n-1][i] != 1)dp[n][i] += dp[n-1][i];\n        int count = 0;\n        for(int i=0; i< m; i++) count += dp[n][i];\n        cout << count << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n\nusing namespace std;\n\n\nint main() {\n\twhile(1) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tif(x==0 && y==0) break;\n\t\tint field[x][y];\n\t\tfor(int i=0; i<x; i++) {\n\t\t\tfor(int j=0; j<y; j++) {\n\t\t\t\tcin >> field[i][j];\n\t\t\t}\n\t\t}\n\t\tint dp[x+1][y];\n\t\tfor(int i=0; i<x+1; i++) {\n\t\t\tfor(int j=0; j<y; j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<x; i++) {\n\t\t\tfor(int j=0; j<y; j++) {\n\t\t\t\tif(i==0 && field[i][j] == 0) dp[i][j] = 1;\n\t\t\t\telse {\n\t\t\t\t\tif(field[i][j] == 0) {\n\t\t\t\t\t\tif(0<j && field[i-1][j-1] == 0) dp[i][j] += dp[i-1][j-1];\n\t\t\t\t\t\tif(field[i-1][j] == 0) dp[i][j] += dp[i-1][j];\n\t\t\t\t\t\tif(j<y-1 && field[i-1][j+1] == 0) dp[i][j] += dp[i-1][j+1];\n\t\t\t\t\t}\n\t\t\t\t\tif(field[i][j] == 2) {\n\t\t\t\t\t\tdp[i][j] += dp[i-1][j];\n\t\t\t\t\t\tdp[i+2][j] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<y; i++) dp[x][i] += dp[x-1][i];\n\t\tint sum=0;\n\t\tfor(int i=0; i<y; i++) sum += dp[x][i];\n\t\tcout << sum;\n\n//\t\tfor(int i=0; i<x+1; i++) {\n//\t\t\tfor(int j=0; j<y; j++) {\n//\t\t\t\tcout << dp[i][j] << ' ';\n//\t\t\t}\n//\t\t\tcout << endl;\n//\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint w,h;\nint mp[16][16];\nint ans;\nint count;\n\nint saiki(int x,int y) {\n  count++;\n  // cout << x <<\" \"<<y <<endl;\n  int dx[3] = {-1,0,1};\n  int dy[3] = {1,1,1};\n  if(mp[y][x] == 2) y++;\n  \n  if((y >= h)||(y==h-1 && mp[y][x] != 1)) ans++;//,cout <<\"ok\"<<endl;  \n  else if(mp[y][x] != 1) {\n    for(int i=0;i<3;i++) {\n      int nx = dx[i]+x;\n      int ny = dy[i]+y;\n      if(nx <0||ny <0||nx >= w|| ny>=h) continue;\n      if(mp[ny][nx] == 0){\n      saiki(nx,ny);\n      }\n      else if(nx==x && mp[ny][nx] == 2 ){\n\tsaiki(nx,ny+2);\n      }\n    } \n  }\n}\n\nint main() {\n\n  while(1) {\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n\n    for(int i=0;i<h;i++) \n      for(int j=0;j<w;j++) \n\tcin >> mp[i][j];\n    /*\n    for(int i=0;i<h;i++) {\n      for(int j=0;j<w;j++) \n\tcout << mp[i][j];\n\t  cout << endl;\n    }\n    */\n\n    ans = 0;\n    count = 0;\n    for(int i=0;i<w;i++) {\n      if(mp[0][i] !=1) saiki(i,0);\n    }\n    cout << ans << endl;\n    //cout << count << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define MAX_XY 15\n\nint x, y;\nint map[MAX_XY + 1][MAX_XY + 1], dp[MAX_XY + 1][MAX_XY + 1];\n\nvoid resetStr();\nvoid makeDp();\nvoid dispAns();\nvoid disp();\n\nint main(){\n    while(cin >>x >>y){\n        if(x == 0 && y == 0) break;\n        resetStr();\n        for(int i = 0; i < y; i++){\n            for(int j = 0; j < x; j++){\n                cin >>map[i][j];\n            }\n        }\n        makeDp();\n        dispAns();\n    }\n}\n\nvoid resetStr(){\n    for(int i = 0; i <= MAX_XY; i++){\n        for(int j = 0; j <= MAX_XY; j++){\n            map[i][j] = -1;\n            dp[i][j] = 0;\n        }\n    }\n}\n\nvoid makeDp(){\n    int xm[] = {-1, 0, 1}, ym[] = {-1, -1, -1};\n    for(int i = 0; i < x; i++){\n        if(map[0][i] == 0) dp[0][i]++;\n    }\n    for(int i = 1; i < y; i++){\n        for(int j = 0; j < x; j++){\n            if(map[i][j] == 2){\n                dp[i][j] += dp[i - 1][j];\n                int xn = j, yn = i + 2;\n                if(i != y - 1){\n                    if(yn >= 0 && yn < y) dp[yn][xn] += dp[i][j];\n                    else dp[y - 1][xn] += dp[i][j];\n                }\n            } else if(map[i][j] == 0){\n                for(int k = 0; k < 3; k++){\n                    int xn = j + xm[k], yn = i + ym[k];\n                    if(xn >= 0 && yn >= 0 && xn < x && yn < y && map[yn][xn] == 0) dp[i][j] += dp[yn][xn];\n                }\n            }\n//            disp();\n        }\n    }\n}\n\nvoid dispAns(){\n    int ans = 0;\n    for(int i = 0; i < x; i++){\n        ans += dp[y - 1][i];\n    }\n    cout <<ans <<endl;\n}\n\nvoid disp(){\n    cout <<endl;\n    for(int i = 0; i < y; i++){\n        for(int j = 0; j < x; j++){\n            cout <<dp[i][j] <<\" \";\n        }\n        cout <<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint dp[18][18];\nint kosu[16][16];\nint ans;\n\nint main(){\n  int x,y;\n  \n  while(1){\n    cin>>x>>y;\n    if(x==0 && y==0) break;\n    \n    fill(dp[0],dp[18],0);\n    ans=0;\n    \n    for(int i=0;i<y;i++){\n      for(int l=0;l<x;l++){\n        cin>>kosu[i][l];\n      }\n    }\n    for(int i=0;i<x;i++)\n      if(kosu[0][i]==0) dp[0][i]=1;\n    \n    for(int i=1;i<y;i++){\n      for(int l=0;l<x;l++){\n        \n        if(kosu[i][l]==2){\n          dp[i+2][l]=dp[i-1][l]+dp[i-2][l]+dp[i][l];\n          dp[i][l]=0;\n        }\n        else if(kosu[i][l]==0)\n          dp[i][l]+=dp[i-1][l-1]+dp[i-1][l]+dp[i-1][l+1];\n      }\n    }\n    \n    for(int i=y;i<y+2;i++){\n      for(int l=0;l<x;l++){\n        dp[i][l]+=dp[i-1][l];\n      }\n    }\n    for(int i=0;i<x;i++)\n      ans+=dp[y][i];\n    \n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define rep2(x,from,to) for(int x=(from);(x)<(to);(x)++)\n#define rep(x,to) rep2(x,0,to)\nusing namespace std;\nint main(){\n\tint x, y;\n\twhile(cin >> x >> y && (x||y) ) {\n\t\tint b[15][15] = {};\n\t\trep(i,y) {\n\t\t\trep(j,x) {\n\t\t\t\tcin >> b[i][j];\n\t\t\t}\n\t\t}\n\t\tint ret[20][20] = {};\n\t\trep(i,x) {\n\t\t\tif(b[0][i] == 0) {\n\t\t\t\tret[0][i+1] = 1;\n\t\t\t}\n\t\t}\n\t\trep2(i,1,y) {\n\t\t\trep(j,x) {\n\t\t\t\tif(b[i][j] == 0) {\n\t\t\t\t\tret[i][j+1] += ret[i-1][j] + ret[i-1][j+1] + ret[i-1][j+2];\n\t\t\t\t\trep2(k,-1,1) {\n\t\t\t\t\t\tif(b[i-1][j+k] == 2) ret[i][j+1] -= ret[i-1][j+k+1];\n\t\t\t\t\t}\n\t\t\t\t} else if(b[i][j] == 2) {\n\t\t\t\t\tret[i+2][j+1] += ret[i-1][j+1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\trep2(i,y-1,y+2) {\n\t\t\trep(j,x) {\n\t\t\t\tans += ret[i][j+1];\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\nusing namespace std;\nint a[20][20],dp[20][20];\nint main(){\n\tint h,w;\n\twhile(cin>>w>>h&&h+w){\n\t\tlol(i,h)lol(j,w)cin>>a[i][j];\n\t\tlol(i,h)lol(j,w){\n\t\t\tdp[i][j]=0;\n\t\t\tif(a[i][j]==1)continue;\n\t\t\tif(i){\n\t\t\t\tif(a[i-1][j]==0)dp[i][j]=dp[i-1][j];\n\t\t\t\tif(i>1)if(a[i-2][j]==2)dp[i][j]+=dp[i-2][j];\n\t\t\t\tif(a[i][j]==0){\n\t\t\t\t\tif(j>0)if(a[i-1][j-1]==0)dp[i][j]+=dp[i-1][j-1];\n\t\t\t\t\tif(j<w-1)if(a[i-1][j+1]==0)dp[i][j]+=dp[i-1][j+1];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse dp[i][j]=1;\n\t\t}\n\t\tint ans=0;\n\t\tlol(j,w){\n\t\t\tans+=dp[h-1][j];\n\t\t\tif(h>=2)if(a[h-2][j]==2)ans+=dp[h-2][j];\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint X,Y;\nint fields[20][20];\nint dp[20][20];\nint counter=0;\nint Max(int x,int y){\n        return x>y?x:y;\n}\nint Min(int x,int y){\n        return x>y?y:x;\n}\nint recursion(int y,int x){\n        int res=0;\n        if(dp[y][x]!=-1)\n                return dp[y][x];\n        if(y>=Y){\n                res=1;\n        }\n        else if(fields[y][x]==3)\n                res=0;\n        else if(fields[y][x]==2){\n                if(fields[y+2][x]==1)\n                        return 0;\n                res+=recursion(y+2,x);\n        }\n        else{\n                if(fields[y+1][x]!=1){\n                        res+=recursion(y+1,x);\n                }\n                if(fields[y+1][x-1]==0){\n                        res+=recursion(y+1,x-1);\n                }\n                if(fields[y+1][x+1]==0){\n                        res+=recursion(y+1,x+1);\n                }\n        }\n        return dp[y][x]=res;\n}\nint main(){\n        while(true){\n                for(int i=0 ; i<20 ; i++ )\n                        for(int j=0 ; j<20 ; j++ )\n                                dp[i][j]=-1;\n                cin >> X >> Y;\n                counter=0;\n                if(X+Y==0)\n                        break;\n                for(int i=0 ; i<=X ; i++ ){\n                        fields[0][i]=3;\n                        fields[Y+1][i]=3;\n                }\n                for(int i=0 ; i<=Y ; i++ ){\n                        fields[i][0]=3;\n                        fields[i][X+1]=3;\n                }\n                for(int i=1 ; i<=Y ; i++ )\n                        for(int j=1 ; j<=X ; j++ )\n                                cin >> fields[i][j];\n                int ans=0;\n                for(int i=1 ; i<=X ; i++ ){\n                        if(fields[1][i]==1)\n                                continue;\n                        ans+=recursion(1,i);\n                }\n                cout << ans << endl;\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define N 15\nusing namespace std;\nvoid func(int,int);\nint jump(int,int);\nint X,Y,data[N][N],memo[N][N];\nint main(){\n  while(1){\n    cin >> X >> Y;\n    if(X==0&&Y==0) break;\n    for(int i=0;i<Y;i++)\n      for(int j=0;j<X;j++) cin >> data[i][j],memo[i][j]=0;\n    for(int i=0;i<X;i++)\n      if(data[0][i]==0) func(0,i);\n    int cnt=0;\n    for(int i=0;i<X;i++) cnt+=memo[0][i];\n    cout << cnt << endl;\n  }\n  return 0;\n}\nvoid func(int y,int x){\n  if(y>=Y-1){\n    memo[Y-1][x]=1;\n    return ;\n  }\n  if(y+1<Y&&0<=x-1&&data[y+1][x-1]==0){\n    if(memo[y+1][x-1]==0) func(y+1,x-1);\n    memo[y][x]+=memo[y+1][x-1];\n  }\n  if(y+1<Y&&x+1<X&&data[y+1][x+1]==0){\n    if(memo[y+1][x+1]==0) func(y+1,x+1);\n    memo[y][x]+=memo[y+1][x+1];\n  }\n  if(y+1<Y&&data[y+1][x]==0){\n    if(memo[y+1][x]==0) func(y+1,x);\n    memo[y][x]+=memo[y+1][x];\n  }\n  if(y+1<Y&&data[y+1][x]==2){\n    int r=jump(y+1,x);\n    if(r==-2) memo[y][x]+=1;\n    else if(r!=-1){\n      func(r,x);\n      memo[y][x]+=memo[r][x];\n    }\n  }\n  if(memo[y][x]==0) data[y][x]=1;\n}\nint jump(int y,int x){\n  while(1){\n    y+=2;\n    if(data[y][x]==1) break;\n    if(y>=Y-1) return -2;\n    if(data[y][x]==0) return y;\n  }\n  return -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nint main(){\n\twhile(true){\n\t\tint X, Y;\n\t\tscanf(\"%d%d\", &X, &Y);\n\t\tint field[16][17] = { { 0 } };\n\t\tfor(int y = 1; y <= Y; y++){\n\t\t\tfor(int x = 1; x <= X; x++){\n\t\t\t\tscanf(\"%d\", &(field[y][x]));\n\t\t\t}\n\t\t}\n\t\tint dp[16][17] = { { 0 } };\n\t\tfor(int x = 1; x <= X; x++){\n\t\t\tif(field[1][x] != 1){ dp[1][x] = 1; }\n\t\t}\n\t\tfor(int y = 2; y <= Y; y++){\n\t\t\tfor(int x = 1; x <= X; x++){\n\t\t\t\tif(field[y][x] == 1){ continue; }\n\t\t\t\tint sum = 0;\n\t\t\t\tif(field[y][x] == 0){\n\t\t\t\t\tif(field[y - 1][x - 1] == 0){ sum += dp[y - 1][x - 1]; }\n\t\t\t\t\tif(field[y - 1][x + 1] == 0){ sum += dp[y - 1][x + 1]; }\n\t\t\t\t}\n\t\t\t\tif(field[y - 1][x] == 0){ sum += dp[y - 1][x]; }\n\t\t\t\tif(field[y - 2][x] == 2){ sum += dp[y - 2][x]; }\n\t\t\t\tdp[y][x] = sum;\n\t\t\t}\n\t\t}\n\t\tint answer = 0;\n\t\tfor(int x = 1; x <= X; x++){\n\t\t\tif(field[Y - 1][x] == 2){ answer += dp[Y - 1][x]; }\n\t\t\tanswer += dp[Y][x];\n\t\t}\n\t\tprintf(\"%d\\n\", answer);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint maps[20][20];\nint course[20][20];\nint X, Y;\n\nvoid out();\nint way(int y, int x){\n  else if(course[y][x] > 0) return course[y][x];\n  else if(maps[y][x] == 1) return 0;\n  else if(y >= Y) return 1;\n  else if(maps[y][x] == 2 && maps[y + 2][x] != 1) return course[y][x] = way(y + 2, x);\n  else{\n    int SUM = 0;\n    for(int i = 0; i < 3; i++){\n      int ny = y + 1;\n      int nx = x - 1 + i;\n      if(maps[ny][nx] != 1 && 1 <= nx && nx <= X){\n\tint flug = 1;\n\tif(i != 1 && maps[ny][nx] == 2) flug = 0;\n\tif(flug) SUM += way(ny, nx);\n      }\n    }\n    return course[y][x] = SUM;\n  }\n} \n\nint main(){\n  while(1){\n    cin >> X >> Y;\n    if(X == 0 && Y == 0) break;\n    for(int i = 1; i <= Y; i++){\n      for(int j = 1; j <= X; j++){\n\tcin >> maps[i][j];\n\tcourse[i][j] = 0;\n      }\n    }\n    int cnt = 0;\n    for(int i = 1; i <= X; i++){\n      if(maps[0][i] != 1) cnt += way(1, i);\n    }\n    cout << cnt << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\n#include <iomanip>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nint main()\n{\n\tint X, Y;\n\twhile(cin >> X >> Y && X)\n\t{\n\t\tvector<vint> field(Y + 1, vint(X, 0)), dp(Y + 1, vint(X, 0));\n\t\trep(y, Y) rep(x, X)\n\t\t\tcin >> field[y][x];\n\n\t\tfill(ALL(dp[0]), 1);\n\t\trep(y, Y) rep(x, X)\n\t\t{\n\t\t\t// y, x ツつゥツづァツづ個配ツづゥDP\n\t\t\tif(field[y][x] == 1) continue;\n\n\t\t\tif(field[y][x] == 2 || y + 1 == Y)\n\t\t\t{\n\t\t\t\tdp[min(y + 2, Y)][x] += dp[y][x];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint dx[] = {-1, 1};\n\n\t\t\t\tdp[y + 1][x] += dp[y][x];\n\t\t\t\trep(i, 2)\n\t\t\t\t{\n\t\t\t\t\tint nx = x + dx[i];\n\t\t\t\t\tif(0 <= nx && nx < X && field[y + 1][nx] != 2)\n\t\t\t\t\t\tdp[y + 1][nx] += dp[y][x];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << accumulate(ALL(dp[Y]), 0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst int MAX_SIZE = 15;\nchar field[MAX_SIZE+1][MAX_SIZE+3];\nint dp[MAX_SIZE+1][MAX_SIZE+3];\nint w, h;\n\nbool judge(int i, int j){\n\tif(j > 0 && j <= w && field[j][i] == '0' && j <= h)\n\t\treturn true;\n\treturn false;\n}\n\nint main(){\n\twhile(cin >> w >> h){\n\t\tif(w == 0 && h == 0) break;\n\t\tfor(int i = 1; i <= h; i++){\n\t\t\tfor(int j = 1; j <= w; j++)\n\t\t\t\tcin >> field[j][i];\n\t\t}\n\t\tint pattern = 0;\n\t\tfor(int i = 0; i < MAX_SIZE+1; i++){\n\t\t\tfor(int j = 0; j < MAX_SIZE+3; j++){\n\t\t\t\tdp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1; i <= w; i++){\n\t\t\tif(field[i][1] == '0')\n\t\t\t\tdp[i][1] = 1;\n\t\t}\n\t\tfor(int i = 1; i < h; i++){\n\t\t\tfor(int j = 1; j <= w; j++){\n\t\t\t\tif(field[j][i] == '2' && field[j][i+2] != '1'){\n\t\t\t\t\tdp[j][i+2] += dp[j][i];\n\t\t\t\t}else if(field[j][i] == '0'){\n\t\t\t\t\tif(field[j][i+1] != '1') dp[j][i+1] += dp[j][i];\n\t\t\t\t\tif(judge(i+1, j-1)) dp[j-1][i+1] += dp[j][i];\n\t\t\t\t\tif(judge(i+1, j+1)) dp[j+1][i+1] += dp[j][i];\n\t\t\t\t}else{\n\t\t\t\t\tdp[j][i] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tint count = 0;\n\t\tfor(int i = h; i <= h+1; i++){\n\t\t\tfor(int j = 1; j <= w; j++){\n\t\t\t\tcount += dp[j][i];\n\t\t\t}\n\t\t}\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\n\nusing namespace std;\n\n\n\tint n,m;\n\tint masu[17][17];\n\tint ura[17][17];\n\t\nint motom(){\n\t\tfor(int i=0;i<17;i++){\n\t\t\tfor(int j=0;j<17;j++){\n\t\t\t\tmasu[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tswitch(ura[1][i]){\n\t\t\t\tcase 0:masu[1][i]+=1;break;\n\t\t\t\tcase 1:masu[1][i]+=0;break;\n\t\t\t\tcase 2:masu[1][i]+=1;break;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfor(int j=1;j<=m;j++){\n\t\t\t\tif(ura[i][j]==0){\n\t\t\t\t\tif(ura[i+1][j-1]==0){\n\t\t\t\t\t\tmasu[i+1][j-1]+=masu[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tif(ura[i+1][j]!=1){\n\t\t\t\t\t\tmasu[i+1][j]+=masu[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tif(ura[i+1][j+1]==0){\n\t\t\t\t\t\tmasu[i+1][j+1]+=masu[i][j];\n\t\t\t\t\t}\n\t\t\t\t}else if(ura[i][j]==2){\n\t\t\t\t\tif(ura[i+2][j]!=1){\n\t\t\t\t\t\tmasu[i+2][j]+=masu[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cont=0;\n\t\tfor(int i=n;i<=n+1;i++){\n\t\t\tfor(int j=1;j<=m;j++){\n\t\t\t\tcont+=masu[i][j];\n\t\t\t}\n\t\t}\n\t\treturn cont;\n}\nint contt;\nvoid saiki(int x,int y){\n\tif(y<1||y>m){\n\t\treturn;\n\t}\n\t\n\t\tmasu[x][y]++;\n\tif(x>n-1){\n\t\tcontt++;\n\t\treturn;\n\t}\n\tif(ura[x][y]==0){\n\t\tif(ura[x+1][y-1]==0){\n\t\t\tsaiki(x+1,y-1);\n\t\t}\n\t\tif(ura[x+1][y]!=1){\n\t\t\tsaiki(x+1,y);\n\t\t}\n\t\tif(ura[x+1][y+1]==0){\n\t\t\tsaiki(x+1,y+1);\n\t\t}\n\t}\n\tif(ura[x][y]==2){\n\t\tif(ura[x+2][y]!=1){\n\t\t\tsaiki(x+2,y);\n\t\t}\n\t}\n}\nint simu(){\n\t\tfor(int i=0;i<17;i++){\n\t\t\tfor(int j=0;j<17;j++){\n\t\t\t\tmasu[i][j]=0;\n\t\t\t}\n\t\t}\n\tcontt=0;\n\tfor(int i=1;i<=m;i++){\n\t\tif(ura[1][i]!=1){\n\t\t\tsaiki(1,i);\n\t\t}\n\t}\n\t/*\n\tputs(\"\");\n\tfor(int i=1;i<=n+1;i++){\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tprintf(\"%d \",masu[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}*/\n\treturn contt;\n}\n\nint main(){\n\tsrand(time(NULL));\n\tint cc=0;\n\twhile(1){\n\t\tscanf(\"%d%d\",&m,&n);\n\t\tif(n==0 && m==0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i=0;i<17;i++){\n\t\t\tfor(int j=0;j<17;j++){\n\t\t\t\tmasu[i][j]=0;\n\t\t\t\tura[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=1;j<=m;j++){\n\t\t\t\tscanf(\"%d\",&ura[i][j]);\n\t\t\t}\n\t\t}\n\t\tint aa=motom();\n\t\t\n\t\tprintf(\"%d\\n\",aa);\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\ntypedef long long Int;\n\nint a[20][20];\nint dp[20][20];\n\nint main() {\n  for (;;) {\n      memset(dp, 0, sizeof(dp));\n      memset(a, 0, sizeof(a));\n      int C, R; cin >> C >> R;\n      if ((C | R) == 0) break;\n      REP(r, R) REP(c, C) cin >> a[r][c];\n\n\n      REP(c, C) if (a[0][c] == 0) dp[0][c] = 1;\n      REP(r, R - 1) {\n          REP(c, C) if (a[r][c] == 0) {\n              if (c - 1 >= 0) dp[r + 1][c - 1] += dp[r][c];\n              if (c + 1 <  C) dp[r + 1][c + 1] += dp[r][c];\n              if (a[r + 1][c] == 2) {\n                  int d = 1;\n                  while (a[r + d][c] == 2) d += 2;\n                  dp[r + d][c] += dp[r][c];\n              }\n              else\n                  dp[r + 1][c] += dp[r][c];\n          }\n      }\n\n      Int ans = 0;\n      REP(c, C) {\n          if (a[R - 1][c] == 0) ans += dp[R - 1][c];\n          if (a[R][c] == 0) ans += dp[R][c];\n      }\n\n      cout << ans << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\n\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nint x, y, c[16][16], dp[30][30];\nconst int dx[3] = {-1, 0, 1};\n\nvoid solve() {\n  memset(dp, 0, sizeof dp);\n  \n  rep(i,y) rep(j,x) cin>>c[i][j];\n  \n  rep(i,x) if (c[0][i] == 0) dp[0][i] = 1;\n  \n  rep(i,y-1) rep(j,x) {\n    if (c[i][j] == 0) {\n      rep(z,3) {\n        int ti = i + 1, tj = j + dx[z];\n        if (ti < 0 || tj < 0 || ti >= y || tj >= x) continue;\n        if (c[ti][tj] == 1) continue;\n        if (c[ti][tj] == 2 && z != 1) continue;\n        dp[ti][tj] += dp[i][j];\n      }\n    } else if (c[i][j] == 2) {\n      dp[i+2][j] += dp[i][j];\n    }\n  }\n  /*\n  rep(i,y+1) {\n    rep(j,x) printf(\"%8d\",dp[i][j]);\n    cout<<endl;\n  }*/\n  \n  int res = 0;\n  REP(i,y-1,y+1) rep(j,x) res += dp[i][j];\n  cout<<res<<endl;\n}\n\nint main (int argc, char const* argv[]) {\n  while (cin>>x>>y, x||y) {\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<numeric>\nusing namespace std;\n\nint main() {\n\tint x, y;\n\twhile (cin >> x >> y ,x,y) {\n\t\tvector<vector<int>> course(y + 2, vector<int>(x + 2, 0));\n\t\tfor (int i = 1; i <= y; i++) {\n\t\t\tfor (int j = 1; j <= x; j++) {\n\t\t\t\tcin >> course[i][j];\n\t\t\t}\n\t\t}\n\n\t\tvector<vector<int>> path(y + 2, vector<int>(x + 2, 0));\n\t\t//?????????????????????????????????1????????????\n\t\tfor (int i = 1; i <= x; i++) {\n\t\t\tif (course[1][i] != 1) path[1][i] = 1;\n\t\t}\n\n\t\tfor (int i = 1; i <= y; i++) {\n\t\t\tfor (int j = 1; j <= x; j++) {\n\t\t\t\t//????????????????????´????????????????????´??????????????????????????????????????????\n\t\t\t\t//?????????????§????????????????????????´?????????????????????????????£????????°?????´????????????????????????\n\t\t\t\tif (course[i][j] == 0) {\n\t\t\t\t\tif (course[i + 1][j + 1] == 0) path[i + 1][j + 1] += path[i][j];\n\t\t\t\t\tif (course[i + 1][j] != 1) path[i + 1][j] += path[i][j];\n\t\t\t\t\tif (course[i + 1][j - 1] == 0) path[i + 1][j - 1] += path[i][j];\n\t\t\t\t}\n\t\t\t\t//?¬???????????????´???????????£????????°????????????????????????????????????\n\t\t\t\t//?????????????????£????????§??´??????????????´???????????????(?????£?????????????????????????????´???????????????)\n\t\t\t\tif (course[i][j] == 2 && course[i + 2][j] != 1) {\n\t\t\t\t\tpath[i + 2][j] += path[i][j];\n\t\t\t\t\tif (i + 2 > y && i != y) path[y][j] += path[i][j];\n\t\t\t\t}\n\t\t\t\t//???????????´???????????????????????????????????????\n\t\t\t\tif (course[i][j] == 1) {/*do anything*/ }\n\t\t\t}\n\t\t}\n\n\t\tcout << accumulate(path[y].begin() + 1, path[y].end() - 1, 0) << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n \nint main(){\n        int x,y;\n        while(cin>>x>>y,x){\n                int D[16][16],P[16][16],ans=0;\n                for(int i=0;i<256;i++)P[i/16][i%16]=0;\n                for(int i=0;i<y;i++)for(int j=0;j<x;j++)cin>>D[i][j];\n                for(int i=0;i<x;i++)if(!D[0][i])P[0][i]=1;\n                for(int i=0;i<y-1;i++){\n                        for(int j=0;j<x;j++){\n                                if(!D[i][j]){\n                                        if (D[i + 1][j] != 1) P[i+1][j]+=P[i][j];\n                                        if(j>0 && D[i + 1][j - 1] != 2)P[i+1][j-1]+=P[i][j];\n                                        if(j<x-1 && !D[i + 1][j + 1] != 2)P[i+1][j+1]+=P[i][j];\n                                }\n                                if(D[i][j]==2){\n//                                        if(i+2>y-1)P[i+1][j]+=P[i][j];\n                                        P[i+2][j]+=P[i][j];\n                                }\n                        }\n                }\n                for(int i=0;i<x;i++)ans+=P[y-1][i];\n                cout<<ans<<endl;\n        }\n}\n "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#define int long long\nusing namespace std;\n\nsigned main() {\n\tint a, b;\n\twhile (cin >> a >> b, a | b) {\n\t\tvector<vector<int>>masu(b + 1, vector<int>(a));\n\t\tvector<vector<int>>suberikata(b + 1, vector<int>(a));\n\t\tfor (int c = 0; c < b; c++) {\n\t\t\tfor (int d = 0; d < a; d++) {\n\t\t\t\tcin >> masu[c][d];\n\t\t\t}\n\t\t}\n\t\tfor (int e = 0; e < b; e++) {\n\t\t\tif (masu[0][e] ==0)suberikata[0][e]++;\n\t\t}\n\t\tfor (int f = 0; f < b-1; f++) {\n\t\t\tfor (int g = 0; g < a; g++) {\n\t\t\t\tswitch (masu[f][g]) {\n\t\t\t\tcase 0:\n\t\t\t\t\tsuberikata[f + 1][g] += suberikata[f][g];\n\t\t\t\t\tif (g > 0&&masu[f+1][g-1]!=2)suberikata[f + 1][g - 1] += suberikata[f][g];\n\t\t\t\t\tif (g < a - 1 && masu[f + 1][g + 1] != 2)suberikata[f + 1][g + 1] += suberikata[f][g];\n\t\t\t\t\tbreak;     \n\t\t\t\tcase 1:break;\n\t\t\t\tcase 2:suberikata[f + 2][g] += suberikata[f][g]; break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t\tfor (auto j : suberikata) {\n\t\t\tfor (int i : j)cout << i << \" \";\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;\n\t}\n}\n/*int s = 0;\n\t\tfor (int j : suberikata[suberikata.size() - 2]) {\n\t\t\ts += j;\n\t\t}\n\t\tcout << s << endl;*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define N 15\nusing namespace std;\nint jump(int,int);\nint X,Y,data[N][N],dp[N][N];\nint main(){\n  bool q[N][N];\n  while(1){\n    cin >> X >> Y;\n    if(X==0&&Y==0) break;\n    for(int i=0;i<Y;i++)\n      for(int j=0;j<X;j++) cin >> data[i][j],q[i][j]=false,dp[i][j]=0;\n    for(int i=0;i<X;i++)\n      if(data[0][i]==0) q[0][i]=true,dp[0][i]=1;\n    for(int i=0;i<Y-1;i++){\n      for(int j=0;j<X;j++){\n\tif(q[i][j]==true){\n\t  if(0<=j-1&&data[i+1][j-1]==0) dp[i+1][j-1]+=dp[i][j],q[i+1][j-1]=true;\n\t  if(j+1<X&&data[i+1][j+1]==0) dp[i+1][j+1]+=dp[i][j],q[i+1][j+1]=true;\n\t  if(data[i+1][j]==0) dp[i+1][j]+=dp[i][j],q[i+1][j]=true;\n\t  else if(data[i+1][j]==2){\n\t    int r=jump(i+1,j);\n\t    if(r==-1) dp[Y-1][j]+=dp[i][j];\n\t    else if(r!=-2) dp[r][j]+=dp[i][j],q[r][j]=true;\n\t  }\n\t}\n      }\n    }\n    /*    cout << endl;\n    for(int i=0;i<Y;i++){\n      for(int j=0;j<X;j++){\n\tcout << q[i][j] << ' ';\n      }\n      cout << endl;\n    }\n    cout << endl;\n    for(int i=0;i<Y;i++){\n      for(int j=0;j<X;j++){\n\tcout << dp[i][j] << ' ';\n      }\n      cout << endl;\n      }*/\n    int cnt=0;\n    for(int i=0;i<X;i++) cnt+=dp[Y-1][i];\n    cout << cnt << endl;\n  }\n  return 0;\n}\nint jump(int y,int x){\n  while(1){\n    y+=2;\n    if(y<Y&&data[y][x]==1) break;\n    if(y>=Y-1) return -1;\n    if(data[y][x]==0) return y;\n  }\n  return -2;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#define pf p.first\n#define ps p.second\nusing namespace std;\ntypedef pair<int,int>P;\nint h,w,mas[20][20],memo[20][20],ans,tmp[]={-1,0,1};\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\nint dfs(P);\nint main(){\n  while(cin >> w >> h && w||h){\n    ans = 0;\n    for(int i=0;i<20;i++) for(int j=0;j<20;j++) memo[i][j] = -1;\n    for(int i=0;i<h;i++) for(int j=0;j<w;j++) cin >> mas[i][j];\n    for(int i=0;i<w;i++) ans += dfs(P(0,i));\n    cout << ans << endl;\n  }\n}\nint dfs(P p){\n  if(memo[pf][ps] != -1) return memo[pf][ps];\n  if(pf >= h - 1) return 1;//OK\n  if(mas[pf][ps] == 1) return 0;//NO\n  else if(mas[pf][ps] == 2) return (memo[pf][ps] = dfs(P(pf+2,ps)));\n  else{\n    int cnt = 0;\n    for(int i=0;i<3;i++){\n      int nx = pf + 1,ny = ps + tmp[i];\n      if(ny>=0&&ny<w&&((mas[nx][ny]==0)||(mas[nx][ny]==2&&i==1))){\n\t  cnt += dfs(P(pf+1,ps+tmp[i]));\n\t}\n    }\n    return (memo[pf][ps] = cnt);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n\nusing namespace std;\n\nint main(){\n  int x, y, course[50][50], route[52][52], i, j, sum;\n  while(cin >> x >> y, x+y){\n    sum = 0;\n    for(i=0; i<52; i++){\n      for(j=0; j<52; j++){\n        route[i][j] = 0;\n      }\n    }\n    for(i=0; i<y; i++){\n      for(j=0; j<x; j++){\n        cin >> course[i][j];\n      }\n    }\n    for(i=0; i<y; i++){\n      for(j=0; j<x; j++){\n\tif(i==0){\n          if(course[i][j]==0){\n            route[i][j] = 1;\n          }else{\n\t    route[i][j] = 0;\n          }\n        }else{\n          if(j==0){\n            if(course[i][j]==0){\n              if(course[i-1][j]==0){\n                route[i][j] += route[i-1][j];\n              }\n              if(course[i-1][j+1]==0){\n                route[i][j] += route[i-1][j+1];\n              }\n\t    }else if(course[i][j]==1){\n              route[i][j] = 0;\n            }else{\n              if(course[i-1][j]==0){\n\t        route[i][j] = route[i-1][j];\n                route[i+2][j] += route[i][j];\n              }\n            }\n          }else if(j==x-1){\n            if(course[i][j]==0){\n              if(course[i-1][j]==0){\n                route[i][j] += route[i-1][j];\n              }\n              if(course[i-1][j-1]==0){\n                route[i][j] += route[i-1][j-1];\n              }\n\t    }else if(course[i][j]==1){\n              route[i][j] = 0;\n            }else{\n              if(course[i-1][j]==0){\n\t        route[i][j] = route[i-1][j];\n                route[i+2][j] += route[i][j];\n              }\n            }\n          }else{\n            if(course[i][j]==0){\n              if(course[i-1][j]==0){\n                route[i][j] += route[i-1][j];\n              }\n              if(course[i-1][j-1]==0){\n                route[i][j] += route[i-1][j-1];\n              }\n              if(course[i-1][j+1]==0){\n                route[i][j] += route[i-1][j+1];\n              }\n\t    }else if(course[i][j]==1){\n              route[i][j] = 0;\n            }else{\n              if(course[i-1][j]==0){\n                route[i][j] = route[i-1][j];\n                route[i+2][j] += route[i][j];\n              }\n              if(course[i-2][j]==2){\n                route[i][j] = route[i-2][j];\n                route[i+2][j] += route[i][j];\n              }\n            }\n          }\n        }\n      }\n    }\n\n    for(i=y; i<y+1; i++){\n      for(j=0; j<x; j++){\n        sum+=route[i][j];\n      }\n    }\n    cout << sum << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n#define MAX 15\n#define BLANK 0\n#define BARRIER 1\n#define JUMP 2\nint main()\n{\n  int X,Y,field[MAX][MAX],dp[MAX][MAX],i,j,sum;\n  while(cin>>X>>Y,X|Y){\n    for(i=0;i<Y;i++)for(j=0;j<X;j++){cin>>field[i][j];dp[i][j]=(i==0);}\n    for(i=1;i<Y;i++){\n      for(j=0;j<X;j++){\n\tif(field[i][j]==BARRIER)continue;\n\tif(field[i-1][j]==BLANK)dp[i][j]+=dp[i-1][j];\n\tif(j+1<X && field[i-1][j+1]==BLANK && field[i][j]!=JUMP)dp[i][j]+=dp[i-1][j+1];\n\tif(j-1>=0 && field[i-1][j-1]==BLANK && field[i][j]!=JUMP)dp[i][j]+=dp[i-1][j-1];\n\tif(i-2>=0 && field[i-2][j]==JUMP)dp[i][j]+=dp[i-2][j];\n      }\n    }\n    sum=0;\n    for(j=0;j<X;j++){\n      if(field[Y-1][j]==BLANK)sum+=dp[Y-1][j];\n      if(Y-2>=0 && field[Y-2][j]==JUMP)sum+=dp[Y-2][j];\n    }\n    cout<<sum<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n\nint main(){\n\tint map[20][20];\n\tint ans_map[20][20];\n\tint x,y;\n\twhile(cin>>x>>y,x){\n\t\tlong int ans=0;\n\t\tfor(int i=0;i<y;i++){\n\t\t\tfor(int j=0;j<x;j++){\n\t\t\t\tcin>>map[i][j];\n\t\t\t\tans_map[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<x;i++){\n\t\t\tans_map[y][i]=0;\n\t\t}\n\t\tfor(int i=0;i<x;i++){\n\t\t\tif(map[0][i]==0){\n\t\t\t\tans_map[0][i]=1;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i+1<y;i++){\n\t\t\tfor(int j=0;j<x;j++){\n\t\t\t\tif(map[i][j]==2){\n\t\t\t\t\tans_map[i+2][j]+=ans_map[i][j];\n\t\t\t\t\tans_map[i][j]=0;\n\t\t\t\t}else if(map[i][j]==1){\n\t\t\t\t\tans_map[i][j]=0;\n\t\t\t\t}else{ \n\t\t\t\t\tfor(int k=-1;k<2;k++){\n\t\t\t\t\t\tif((j+k<0)||(j+k>x-1)){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(map[i+1][j+k]==0){\n\t\t\t\t\t\t\t\tans_map[i+1][j+k]+=ans_map[i][j];\n\t\t\t\t\t\t\t}else if((k==0)&&(map[i+1][j+k]==2)){\n\t\t\t\t\t\t\t\tans_map[i+1][j+k]+=ans_map[i][j];\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<x;i++){\n\t\t\tans_map[y][i]+=ans_map[y-1][i];\n\t\t}\n\t\tfor(int i=0;i<x;i++){\n\t\t\tans+=ans_map[y][i];\n\t\t}\n\t\tcout<<ans<<endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\n#define MAX 17\n#define f first\n#define s second\ntypedef pair<int, int> P;\n\nint X, Y;\nint field[MAX][MAX];\nint dp[MAX][MAX];\n\nint solve(){\n  for(int i = 0 ; i < Y ; i++){\n    for(int j = 0 ; j <= X ; j++){\n      if(field[i][j] == 0){\n\tfor(int dx = -1 ; dx <= 1 ; dx++){\n\t  if(field[i+1][j+dx] != 1 && (field[i+1][j+dx] == 0 || dx == 0)){\n\t    dp[i+1][j+dx] += dp[i][j];\n\t  }\n\t}\n      }\n      else if(field[i][j] == 2 && field[i+2][j] != 1){\n\tdp[i+2][j] += dp[i][j];\n      }\n    }\n  }\n\n  int res = 0;\n  for(int i = 0 ; i <= X ; i++){\n    res += dp[Y][i] + dp[Y+1][i];\n  }\n  return res;\n}\n\nvoid init(){\n  memset(dp, 0, sizeof(dp));\n  for(int i = 0 ; i <= X ; i++){\n    if(field[0][i] == 0) dp[0][i] = 1;\n  }\n}\n\nint main(){\n  while(cin >> X >> Y, X && Y) {\n    X--, Y--;\n    for(int i = 0 ; i <= Y ; i++) {\n      for(int j = 0 ; j <= X ; j++) {\n\tcin >> field[i][j];\n      }\n    }\n    \n    init();\n    cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * src.cpp\n *\n *  Created on: 2016/08/01\n *      Author: joi\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\n\nconst int MAX_X=15,MAX_Y=15;\n\nint X,Y;\nint c[MAX_Y][MAX_X];\n\nint memo[MAX_Y][MAX_X];\n\nint dfs(int x,int y){\n\tif (y<Y && c[y][x]==1){\n\t\treturn 0;\n\t}\n\tif (y>=Y-1){\n\t\treturn 1;\n\t}\n\tif (memo[y][x]!=-1){\n\t\treturn memo[y][x];\n\t}\n\tif (c[y][x]==2){\n\t\treturn dfs(x,y+2);\n\t}\n\tint res=0;\n\tif (x>0 && c[y+1][x-1]==0){\n\t\tres+=dfs(x-1,y+1);\n\t}\n\tif (x<X-1 && c[y+1][x+1]==0){\n\t\tres+=dfs(x+1,y+1);\n\t}\n\tres+=dfs(x,y+1);\n\treturn memo[y][x]=res;\n}\n\nint main(){\n\tdo{\n\t\tscanf(\"%d %d\",&X,&Y);\n\t\tif (X || Y){\n\t\t\tREP(i,Y){\n\t\t\t\tREP(j,X){\n\t\t\t\t\tscanf(\"%d\",&c[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemset(memo,-1,sizeof(memo));\n\t\t\tint ans=0;\n\t\t\tREP(i,X){\n\t\t\t\tans+=dfs(i,0);\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",ans);\n\t\t}\n\t}while (X || Y);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#define NORMAL 0\n#define TREE 1\n#define JUMP 2\n#define DR_NUM 3 // 方向数\n\nusing namespace std;\n\nconst int dy[DR_NUM] = {1,1,1}, dx[DR_NUM] = {-1,0,1};\n\nint main(void){\n\tint x, y, course[15][15], dp[17][15], i, j, k, l, ans;\n\twhile(1){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif(x == 0 && y == 0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(i = 0;i < y;i++){\n\t\t\tfor(j = 0;j < x;j++){\n\t\t\t\tscanf(\"%d\",&course[i][j]);\n\t\t\t}\n\t\t}\n\t\tans = 0;\n\t\tmemset(dp,0,sizeof(dp));\n\t\tfor(i = 0;i < x;i++){\n\t\t\tdp[0][i] = 1;\n\t\t}\n\t\tfor(j = 0;j < y - 1;j++){\n\t\t\tfor(k = 0;k < x;k++){\n\t\t\t\tif(course[j][k] == NORMAL){\n\t\t\t\t\tfor(l = 0;l < DR_NUM;l++){\n\t\t\t\t\t\tif(k + dx[l] >= 0 && k + dx[l] < x && course[j + dy[l]][k + dx[l]] != TREE && !(l != 1 && course[j + dy[l]][k + dx[l]] == JUMP)){\n\t\t\t\t\t\t\tdp[j + dy[l]][k + dx[l]] += dp[j][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else if(course[j][k] == JUMP && course[j + 2][k] != TREE){\n\t\t\t\t\tdp[j + 2][k] += dp[j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i = 0;i < x;i++){\n\t\t\tans += dp[y - 1][i] + dp[y][i] + dp[y + 1][i];\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<cstring>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(n) rep(i,n)\n#define all(n) n.begin(),n.end()\n\nconst int MAXW = 16, W = 0, O = 1, J = 2;\n\nint tile[MAXW][MAXW+ 5];\nint dp[MAXW][MAXW];\nint dx[3] = {0, -1, 1};\n\nint main()\n{\n    int x, y;\n    while(cin >> x >> y && x)\n    {\n        memset(dp, 0, sizeof(dp));\n        memset(tile, W, sizeof(tile));\n        rep(j,y)rep(i,x) cin >> tile[i][j];\n        rep(i,x){ if(tile[i][0] == W) dp[i][0] = 1; }\n\n        rep(i,x)\n            if(tile[i][1] == W)\n            {rep(k,3)if(i+dx[k]>=0 && i+dx[k]<x && tile[i+dx[k]][0] == W)dp[i][1] += dp[i + dx[k]][0];}\n            else if(tile[i][1] == J && tile[i][0] == W) dp[i][1] += dp[i][0];\n        for(int j=2;j<y;j++)rep(i,x)\n        {\n\n            if(tile[i][j] == O){ continue;}\n            if(tile[i][j] == J)\n            {\n                if(tile[i][j-1] == W) dp[i][j] += dp[i][j-1];\n                if(tile[i][j-2] == J) dp[i][j] += dp[i][j-2];\n                continue;\n            }\n            rep(k,3)if((i+dx[k]>=0 && i+dx[k]< x)&& tile[i+dx[k]][j-1] == W)\n                dp[i][j] += dp[i+dx[k]][j-1];\n            if(tile[i][j-2] == J) dp[i][j] += dp[i][j-2];\n\n        }\n        //rep(j,y) { rep(i,x) cout << dp[i][j] << \"\\t\"; cout << endl;}\n\n        int ans = 0;\n        REP(x){ ans += dp[i][y-1] ; if(tile[i][y-2] ==J) ans+= dp[i][y-2];}\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<numeric>\nusing namespace std;\n\nint main() {\n\tint x, y;\n\twhile (cin >> x >> y && (x != 0 && y != 0)) {\n\t\tvector<vector<int>> course(y + 2, vector<int>(x + 2, 0));\n\t\tfor (int i = 1; i <= y; i++) {\n\t\t\tfor (int j = 1; j <= x; j++) {\n\t\t\t\tcin >> course[i][j];\n\t\t\t}\n\t\t}\n\n\t\tvector<vector<int>> path(y + 2, vector<int>(x + 2, 0));\n\t\t//?????????????????????????????????1????????????\n\t\tfor (int i = 1; i <= x; i++) {\n\t\t\tif (course[1][i] != 1) path[1][i] = 1;\n\t\t}\n\n\t\tfor (int i = 1; i <= y; i++) {\n\t\t\tfor (int j = 1; j <= x; j++) {\n\t\t\t\t//????????????????????´????????????????????´??????????????????????????????????????????\n\t\t\t\t//?????????????§????????????????????????´?????????????????????????????£????????°?????´????????????????????????\n\t\t\t\tif (course[i][j] == 0) {\n\t\t\t\t\tif (course[i + 1][j + 1] == 0) path[i + 1][j + 1] += path[i][j];\n\t\t\t\t\tif (course[i + 1][j] != 1) path[i + 1][j] += path[i][j];\n\t\t\t\t\tif (course[i + 1][j - 1] == 0) path[i + 1][j - 1] += path[i][j];\n\t\t\t\t}\n\t\t\t\t//?¬???????????????´???????????£????????°????????????????????????????????????\n\t\t\t\t//?????????????????£????????§??´??????????????´???????????????(?????£?????????????????????????????´???????????????)\n\t\t\t\tif (course[i][j] == 2 && course[i + 2][j] != 1) {\n\t\t\t\t\tpath[i + 2][j] += path[i][j];\n\t\t\t\t\tif (i + 2 > y && i != y) path[y][j] += path[i][j];\n\t\t\t\t}\n\t\t\t\t//???????????´???????????????????????????????????????\n\t\t\t\tif (course[i][j] == 1) {/*do anything*/ }\n\t\t\t}\n\t\t}\n\n\t\tcout << accumulate(path[y].begin() + 1, path[y].end() - 1, 0) << endl;\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MP make_pair\n#define PB push_back\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define REP(i,n) for (int i=0;i<(n);i++)\nint X,Y;\nint fld[20][20];\nlong long dp[20][20];\nint main() {\n\twhile(cin>>X>>Y&&X&&Y){\n\t\tfor(int i=0;i<Y;i++)for(int j=0;j<X;j++)cin>>fld[j][i];\n\t\tlong long ans=0;\n\t\tfor(int i=0;i<20;i++)for(int j=0;j<20;j++)dp[i][j]=0;\n\t\tfor(int i=0;i<X;i++)if(fld[i][Y-1]!=1)dp[i][Y-1]=1;\n\t\tfor(int y=Y-2;y>=0;y--){\n\t\t\tfor(int x=0;x<X;x++){\n\t\t\t\tif(fld[x][y]==0){\n\t\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\t\tint nx=x+k;\n\t\t\t\t\t\tif(nx<0||nx>=X)continue;\n\t\t\t\t\t\tif(nx==x&&fld[nx][y+1]!=1)dp[x][y]+=dp[nx][y+1];\n\t\t\t\t\t\telse if(fld[nx][y+1]==0)dp[x][y]+=dp[nx][y+1];\n\t\t\t\t\t}\n\t\t\t\t}else if(fld[x][y]==2){\n\t\t\t\t\tif(y+2>=Y)dp[x][y]=1;\n\t\t\t\t\telse dp[x][y]=dp[x][y+2];\n\t\t\t\t}\n\t\t\t\tif(y==0)ans+=dp[x][y];\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\n\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nint x, y, c[16][16], dp[30][30];\nconst int dx[3] = {-1, 0, 1};\n\nvoid solve() {\n  memset(dp, 0, sizeof dp);\n  \n  rep(i,y) rep(j,x) cin>>c[i][j];\n  \n  rep(i,x) if (c[0][i] == 0) dp[0][i] = 1;\n  \n  rep(i,y) rep(j,x) {\n    if (c[i][j] == 1) {\n      continue;\n    } else if (c[i][j] == 0) {\n      rep(z,3) {\n        int ti = i + 1, tj = j + dx[z];\n        if (ti < 0 || tj < 0 || ti >= y || tj >= x) continue;\n        if (c[ti][tj] == 1) continue;\n        if (c[ti][tj] == 2 && tj != j) continue;\n        dp[ti][tj] += dp[i][j];\n      }\n    } else if (c[i][j] == 2) {\n      dp[i+2][j] += dp[i][j];\n    }\n  }\n  /*\n  rep(i,y+1) {\n    rep(j,x) printf(\"%8d\",dp[i][j]);\n    cout<<endl;\n  }*/\n  \n  int res = 0;\n  REP(i,y-1,y+1) rep(j,x) res += dp[i][j];\n  cout<<res<<endl;\n}\n\nint main (int argc, char const* argv[]) {\n  while (cin>>x>>y, x||y) {\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n#define int long long\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\nint vv[20][20];\nint table[20][20];\nvoid mainmain(){\n\tint w,h;\n\twhile(cin>>w>>h,w||h){\n\t\trep(i,20){\n\t\t\trep(j,20){\n\t\t\t\tvv[i][j]=0;\n\t\t\t}\n\t\t}\n\t\trep(i,20){\n\t\t\trep(j,20){\n\t\t\t\ttable[i][j]=0;\n\t\t\t}\n\t\t}\n\t\treep(i,1,w+1){\n\t\t\tvv[0][i]=1;\n\t\t}\n\t\trep(i,h){\n\t\t\trep(j,w){\n\t\t\t\tcin>>table[i+1][j+1];\n\t\t\t}\n\t\t}\n\t\trep(i,h){\n\t\t\treep(j,1,w+1){\n\t\t\t\tif(table[i][j]==2){\n\t\t\t\t\tvv[i+2][j]+=vv[i][j];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(table[i][j]==1) continue;\n\t\t\t\tvv[i+1][j]+=vv[i][j];\n\t\t\t\tif(i&&j-1>0&&table[i+1][j-1]==0){\n\t\t\t\t\tvv[i+1][j-1]+=vv[i][j];\n\t\t\t\t}\n\t\t\t\tif(i&&j+1<=w&&table[i+1][j+1]==0){\n\t\t\t\t\tvv[i+1][j+1]+=vv[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t\treep(i,h,h+2){\n\t\t\treep(j,1,w+1){\n\t\t\t\tif(table[i][j]!=1) ans+=vv[i][j];\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<utility>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<complex>\n#define INF 2147483647\n#define llINF 9223372036854775807\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\n\nusing namespace std;\nint main(){\n  int x,y;\n  while(cin>>x>>y,x+y){\n    int Map[y+10][x+10]={};\n    int Map2[y+10][x+10]={};\n    for(int i=0;i<y;i++)\n      for(int j=0;j<x;j++){\n\tcin>>Map2[i][j];\n\tif(i==0&&Map2[i][j]==0)\n\t  Map[i][j]=1;\n      }\n    for(int i=0;i<y-1;i++){\n      for(int j=0;j<x;j++){\n\tif(Map2[i][j]==0){\n\t  if(Map2[i+1][j+1]==0)\n\t    Map[i+1][j+1]+=Map[i][j];\n\t  if(Map2[i+1][j]!=1)\n\t    Map[i+1][j]+=Map[i][j];\n\t  if(j-1>=0&&Map2[i+1][j-1]==0)\n\t    Map[i+1][j-1]+=Map[i][j];\n\t}else if(Map2[i][j]==2){\n\t  if(Map2[i+2][j]!=1)\n\t    Map[i+2][j]+=Map[i][j];\n\t}\n      }\n    }\n    ll ans=0;\n    for(int i=y-1;i<=y;i++)\n      for(int j=0;j<x;j++)\n\tans+=Map[i][j];\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(i,n,a) for(int i=a;i<n;i++)\nint main(){\n\tint X,Y;\n\tint mp[23][23];\n\tint obj[22][22];\n\tint sum = 0;\n\twhile(cin >> X >> Y && X && Y){\n\t\trep(i,22)rep(j,22)mp[i][j]=0;\n\t\trep(i,22)rep(j,22)obj[i][j]=1;\n\t\tREP(i,X+1,1)mp[1][i]=1;\n\t\t\n\t\trep(i,Y)rep(j,X){\n\t\t\tcin >> obj[1+i][1+j];\n\t\t}\n\t\t\n\t\tREP(i,Y+1,1\t)REP(j,X+1,1){\n\t\t\tif(obj[i][j]==1){\n\t\t\t\tmp[i][j]=0;\n\t\t\t}else if(obj[i][j]==2){\n\t\t\t\tif(obj[i-1][ j ]==0)mp[i][j] =mp[i-1][ j ];\n\t\t\t\tif(obj[i-2][ j ]==2)mp[i][j]+=mp[i-2][ j ];\n\t\t\t}else{\n\t\t\t\tif(obj[i-1][j-1]==0)mp[i][j]+=mp[i-1][j-1];\n\t\t\t\tif(obj[i-1][ j ]==0)mp[i][j]+=mp[i-1][ j ];\n\t\t\t\tif(obj[i-1][j+1]==0)mp[i][j]+=mp[i-1][j+1];\n\t\t\t\tif(obj[i-2][ j ]==2)mp[i][j]+=mp[i-2][ j ];\n\t\t\t}\n\t\t}\n\t\t\n\t\tsum = 0;\n\t\tfor(int i=1;i<=X;i++){\n\t\t\tsum += mp[Y][i];\n\t\t\tif(obj[Y-1][i]==2)sum+=mp[Y-1][i];\n\t\t}\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nint memo[16][16];\n\nint calc(std::vector<std::vector<int> > &v, int x, int y){\n\n\tif (memo[x][y] != -1)return memo[x][y];\n\tint res = 0;\n\tif (x >= v[y].size() - 1)return 1;\n\n\tif (v[x][y] == 2)res += calc(v, x + 2, y);\n\n\tif (v[x][y] == 0){\n\t\tif (v[x + 1][y] == 0)res += calc(v, x + 1, y);\n\t\telse if (v[x + 1][y] == 2)res += calc(v, x + 1, y);\n\n\t\tif (y < v.size()-1 && v[x + 1][y + 1] == 0)res += calc(v, x + 1, y + 1);\n\n\t\tif (y > 0 && v[x + 1][y - 1] == 0)res += calc(v, x + 1, y - 1);\n\t}\n\n\treturn memo[x][y]=res;\n}\n\n\nint main(){\n\n\tint x, y;\n\twhile (std::cin >> x >> y){\n\n\t\tif (x == 0 && y == 0)break;\n\n\t\tint res = 0;\n\t\tstd::vector<std::vector<int> >v(x, std::vector<int>(y));\n\n\t\tfor (int i = 0; i < 16; i++){\n\t\t\tfor (int j = 0; j < 16; j++){\n\t\t\t\tmemo[i][j] = -1;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < x; i++){\n\t\t\tfor (int j = 0; j < y; j++){\n\t\t\t\tstd::cin >> v[i][j];\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < v.size(); i++)res += calc(v, 0, i);\n\n\t\tstd::cout << res << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint solve(int x,int y);\nint ax,ay;\nint mas[20][20];\nint main(){\n  while(1){\n    int ans=0;\n    cin>>ax>>ay;\n    if(ax==0 && ay==0){\n      break;\n    }\n    for(int i=0;i<ay;i++){\n      for(int j=0;j<ax;j++){\n\tcin>>mas[i][j];\n      }\n    }\n    for(int i=0;i<ax;i++){\n      if(mas[0][i]!=1){\n\tans+=solve(i,0);\n      }\n    }\n    cout<<ans<<endl;\n  }\n}\nint solve(int x,int y){\n  if(y==ay){\n    return 1;\n  }else if(mas[y][x]==1){\n    return 0;\n  }else if(mas[y][x]==2){\n    return solve(x,y+2);\n  } \n  else{\n    int anss=0; \n    if(mas[y+1][x]!=1){\n      anss+=solve(x,y+1);\n    }\n    if(x+1<ax && mas[y+1][x+1]==0 && y+1!=ay){\n      anss+=solve(x+1,y+1);\n    }\n    if(0<=x-1 && mas[y+1][x-1]==0 && y+1!=ay){\n      anss+=solve(x-1,y+1);\n    }\n    return anss;\n  }\n}  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nconst int MAX_Y = 30;\nconst int MAX_X = 30;\nint mx, my, c[MAX_Y][MAX_X], dp[MAX_Y][MAX_X];\n\nconst int dx[3] = {-1, 0, 1};\nconst int dy[3] = {1, 1, 1};\n\nint dfs(int y, int x) {  \n  int res = 0;\n  if (dp[y][x] >= 0) return dp[y][x];\n  \n  if (y == my - 1) return 1;\n  \n  if (c[y][x] == 2) {\n    if (y+2 >= my - 1) return 1;\n    res += dfs(y+2, x);\n    return dp[y][x] = res;\n  }\n  \n  rep(z,3) {\n    int tx = x + dx[z], ty = y + dy[z];\n    if (tx < 0 || ty < 0 || tx >= mx || ty >= my) continue;\n    if (c[ty][tx] == 1) continue;\n    if (c[ty][tx] == 2 && tx != x) continue;\n    res += dfs(ty, tx);\n  }\n\n  return dp[y][x] = res;\n}\n\nvoid solve() {\n  memset(dp, -1, sizeof dp);\n  rep(i,my) rep(j,mx) cin>>c[i][j];\n\n  int res = 0;\n  rep(i,mx) {\n    if (c[0][i] == 1) continue;\n    res += dfs(0, i);\n  }\n  cout<<res<<endl;\n}\n\nint main (int argc, char const* argv[]) {\n  while (cin>>mx>>my, mx||my) {\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nint main(){\n  int w,h;\n  while(cin>>w>>h, w+h){\n    int f[h][w];\n    long long ans[h+2][w];\n    memset(ans, 0, sizeof(ans));\n    REP(i,h) REP(j,w) cin>>f[i][j];\n    REP(i,w) if(f[0][i] == 0) ans[0][i] = 1;\n    REP(i,h) REP(j,w){\n      if(ans[i][j] != 0){\n        int y = i + (f[i][j]==2?2:1);\n        REP(k,3){\n          if((f[i][j]==2 || i == h - 1) && k!=1) continue;\n          int x = j + k - 1;\n          if(x < 0 || x >= w) continue;\n          if(y >= h || f[y][x] == 0)\n            ans[y][x] += ans[i][j];\n          else if(k == 1 && f[y][x] == 2)\n            ans[y][x] += ans[i][j];\n        }\n      }\n    }\n    //REP(i,h+2){REP(j,w)printf(\"%lld \",ans[i][j]); puts(\"\");}\n    long long sum = 0;\n    REP(i,2) REP(j,w) sum += ans[h+i][j];\n    cout << sum << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\ntypedef long long ll;\nint x, y;\nll dp[20][20];\nint mp[20][20];\nint main() {\n  while (scanf(\"%d%d\",&x,&y)) {\n    if (!x&&!y) break;\n    memset(dp, 0, sizeof(dp));\n    memset(mp, 0, sizeof(mp));\n    for (int i=0; i<y; i++) {\n      for (int j=0; j<x; j++) scanf(\"%d\",&mp[i][j]);\n    }\n    for (int i=0; i<x; i++) if (mp[0][i]!=1) dp[0][i]=1;\n    ll res = 0;\n    for (int i=0; i<y-1; i++) {\n      for (int j=0; j<x; j++) {\n        if (mp[i][j]==2) {\n          dp[i+2][j]+=dp[i][j];\n        } else {\n          if (j!=0&&mp[i+1][j-1]==0) dp[i+1][j-1]+=dp[i][j];\n          if (mp[i+1][j]!=1) dp[i+1][j]+=dp[i][j];\n          if (j!=x-1&&mp[i+1][j+1]==0) dp[i+1][j+1]+=dp[i][j];\n        }\n      }\n    }\n    for (int i=0; i<x; i++) res+=dp[y][i]+dp[y-1][i];\n    printf(\"%lld\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint dy[] = { 1, 1, 1};\nint dx[] = { -1, 0, 1 };\n\nint main() {\n    while (1) {\n        int dp[17][15] = { 0 };\n        int field[15][15] = { 0 };\n        int h, w;\n\n        cin >> w >> h;\n        if (w == 0) {\n            break;\n        }\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                cin >> field[i][j];\n            }\n        }\n        \n        for (int j = 0; j < w; j++) {\n            if (field[0][j] != 1) {\n                dp[0][j] = 1;\n            }\n        }\n        \n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                if (dp[i][j] > 0) {\n                    if (i == h - 1) {\n                        dp[i + 1][j] = dp[i][j];\n                        continue;\n                    }\n                    if (field[i][j] == 2) {\n                        if (field[i + 2][j] != 1) {\n                            dp[i + 2][j] += dp[i][j];\n                        }\n                        continue;\n                    }\n                    for (int k = 0; k < 3; k++) {\n                        int nx = j + dx[k];\n                        int ny = i + dy[k];\n                        if (nx < 0 || nx >= w) {\n                            continue;\n                        }\n                        if (field[ny][nx] == 0 || (field[ny][nx] == 2 && k == 1)) {\n                            dp[ny][nx] += dp[i][j];\n                        }\n                    }\n                }\n            }\n        }\n        \n        int ans = 0;\n        //for (int i = h; i <= h + 1; i++) {\n            for (int j = 0; j < w; j++) {\n                ans += dp[h][j];\n            }\n            //}\n        cout << ans << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ツ堕スツ閉ェDPツつキツづェツづ篠余ツ裕ツつセツつェツ・ツ・ツ・\n\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<30;\n\nint X, Y;\nint ba[15][15];\nmap<pair<int,int>, int> mp;\n\nint const dx[] = {-1,0,1};\nint solve(int x, int y) {\n  if (y >= Y-1) return 1;\n  if (mp[make_pair(x,y)])\n    return mp[make_pair(x,y)];\n  int res = 0;\n  REP(i,3) {\n    int xx = x + dx[i];\n    int yy = y+1;\n    \n    if (xx < 0 || X <= xx) continue;\n    if (i == 1) {\n      while (yy < Y && ba[xx][yy] == 2) {\n        yy+=2;\n      }\n      if (yy >= Y || ba[xx][yy] == 0)\n        res += solve(xx, yy);\n    } else if (ba[xx][yy] == 0) {\n      res += solve(xx, yy);\n    }\n  }\n  return mp[make_pair(x,y)] = res;\n}\n\nint main() {\n  while(cin >> X >> Y, X||Y) {\n    mp.clear();\n    REP(y,Y) {\n      REP(x,X) {\n        cin >> ba[x][y];\n      }\n    }\n    int ans = 0;\n    REP(x,X) {\n      ans += solve(x, 0);\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <cctype>\n#include <vector>\nusing namespace std;\n\n#ifdef __linux\n#define _U(s) s##_unlocked\n#else\n#define _U(s) _##s##_nolock\n#define _CRT_DISABLE_PERFCRIT_LOCKS\n#endif\n#define gcu _U(getchar)\n#define pcu _U(putchar)\n#define _DEF(r, n, ...) inline r n(__VA_ARGS__) noexcept\n#define _T template <typename T>\n#define _HT template <typename H,typename... T>\n#define _OP(t) inline operator t()\nstruct _in {\n#ifdef _GLIBCXX_STRING\n\t_OP(string){string s;for(char c;c=gcu(),c!=' '&&c!='\\n'&&c!=EOF;)s+=c;return s;}\n#define _S\n#endif\n\t_OP(char){char c=gcu();gcu();return c;}\n\t_OP(double){double d; scanf(\"%lf\",&d); gcu();return d;}\n\t_T _OP(T){T n{},m{1},c;while(isspace(c = gcu()));if(c=='-')m=-1,c=gcu();do{n=10*n+(c-'0'),c=gcu();}while(c>='0'&&c<='9');return m*n;}\n} in;\n#define _SCAN(...) _DEF(bool,scan,__VA_ARGS__)\n#ifdef _S\n_SCAN(string &o) {int c{gcu()};if(c==EOF)return false;else{ungetc(c,stdin);string t=move(in);o=t;return true;}}\n#endif\n_T _SCAN(T &o) {int c{gcu()};return c==EOF?false:(ungetc(c,stdin),o=in,true);}\n_HT _SCAN(H &h,T&&... t){return scan(h)&&scan(t...);}\n#define _OUT(...) _DEF(void,out,__VA_ARGS__)\n#define _OUTL(...) _DEF(void,outl,__VA_ARGS__)\n_OUT(bool b){pcu('0'+b);}\n_OUT(const char *s){while(*s)pcu(*s++);}\n_OUT(char c){pcu(c);}\n#ifdef _S\n_OUT(string &s){for(char c:s)pcu(c);}\n#endif\n_T _OUT(T n){static char b[20];char *p=b;T m=n<0?pcu('-'),-1:1;\n\tif(!n)*p++='0';else while(n)*p++=(char)(n%10*m+'0'),n/=10;while(p!=b)pcu(*--p);}\n_OUTL(){out('\\n');}\n#ifdef _GLIBCXX_VECTOR\n\t_T _OUT(vector<T> &v){for(T &x:v)out(&x == &v[0]?\"\":\" \"),out(x);}\n#endif\n\t_HT _OUT(H &&h, T... t){out(h);out(t...);}\n\ttemplate <typename... T> _OUTL(T... t){out(t...);outl();}\n\tstruct range{\n\t\tint e,b=0,s=1;range(int _b,int _e,int _s):e(_e),b(_b),s(_s){} range(int _b,int _e): e(_e), b(_b){} range(int _e):e(_e){}\n\t\tstruct it{int v,s; it(int _v,int _s):v(_v),s(_s){} operator int()const{return v;} operator int&(){return v;}int operator*()const{return v;}\n\t\t\tit& operator++(){v+=s;return *this;} }; it begin(){return {b,s};} it end(){return {e,s};}};\n#define times(i,n) for(int i=n;i;i--)\n\nint main() {\n\tfor (int X, Y; X = in, Y = in;) {\n\t\tvector<vector<int>> m(Y + 1, vector<int>(X + 2)), d = m;\n\t\tfor (int i: range(Y))\n\t\t\tfor (int j: range(1, X + 1))\n\t\t\t\tm[i][j] = in;\n\t\tfor (int i: range(1, X + 1))\n\t\t\tif (!m[0][i])\n\t\t\t\td[0][i] = 1;\n\t\tfor (int i: range(Y - 1))\n\t\t\tfor (int j: range(1, X + 1)) {\n\t\t\t\tif (m[i][j] == 2 && m[i + 2][j] != 1)\n\t\t\t\t\td[i + 2][j] += d[i][j];\n\t\t\t\telse if (m[i][j] == 0) {\n\t\t\t\t\tif (m[i + 1][j] != 1)\n\t\t\t\t\t\td[i + 1][j] += d[i][j];\n\t\t\t\t\tif (m[i + 1][j - 1] == 0)\n\t\t\t\t\t\td[i + 1][j - 1] += d[i][j];\n\t\t\t\t\tif (m[i + 1][j + 1] == 0)\n\t\t\t\t\t\td[i + 1][j + 1] += d[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\tint r {};\n\t\tfor (int i: range(1, X + 1))\n\t\t\tr += d[Y - 1][i] + d[Y][i];\n\t\toutl(r);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define MAX 15\n\nusing namespace std;\n\nint a,b,cnt,ans;\nint ski[MAX][MAX];\n\nint compute(int y,int x){\n\n  if( ski[y][x] == 1 ) return cnt;\n  if( b - 1 <= y ) return ++cnt;\n\n  if( ski[y][x] == 2 ) compute( y + 2 , x );\n\n  if( ski[y][x] != 2 ){\n    if( ski[y + 1][x] == 2 ) compute( y + 3 , x );  \n    if( !ski[y + 1][x - 1] && ( 0 <= x - 1 && x - 1 < a ) ) compute( y + 1 , x - 1 );\n    if( !ski[y + 1][x + 1] && ( 0 <= x + 1 && x + 1 < a ) ) compute( y + 1 , x + 1 );\n    if( !ski[y + 1][x] ) compute( y + 1 , x );\n  }\n\n  \n  return cnt;\n}\n\n\n\nint main(void){\n\n  while( cin >> a >> b , a || b ){\n\n    for( int i = 0 ; i < b ; i++ )\n      for( int j = 0 ; j < a ; j++ )\n\tcin >> ski[i][j];\n\n    ans = 0;\n    for( int i = 0 ; i < a ; i++ ){\n      if( ski[0][i] == 0 ){\n\tcnt = 0;\n\tint c = compute( 0 , i );\n\t// cout << ski[0][i] << endl;\n\tans += c;\n      }\n    }\n    cout << ans << endl;\n\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nint main(){\n\tint n,m;\n\tint masu[17][17];\n\tint ura[17][17];\n\tcin>>n>>m;\n\tfor(int i=0;i<17;i++){\n\t\tfor(int j=0;j<17;j++){\n\t\t\tmasu[i][j]=ura[i][j]=0;\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tcin>>masu[i][j];\n\t\t}\n\t}\n\t\n\tfor(int j=1;j<=m;j++){\n\t\tura[0][j]=1;\n\t}\n\t\n\t\n\tfor(int i=0;i<n-1;i++){\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tif(masu[i][j]==0){\n\t\t\t\tif(masu[i+1][j-1]==0){\n\t\t\t\t\tura[i+1][j-1]+=ura[i][j];\n\t\t\t\t}\n\t\t\t\tif(masu[i+1][j]!=1){\n\t\t\t\t\tura[i+1][j]+=ura[i][j];\n\t\t\t\t}\n\t\t\t\tif(masu[i+1][j+1]==0){\n\t\t\t\t\tura[i+1][j+1]+=ura[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(masu[i][j]==2){\n\t\t\t\tif(masu[i+2][j]!=1){\n\t\t\t\t\tura[i+2][j]+=ura[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint cont=0;\n\tfor(int i=1;i<=m;i++){\n\t\tcont+=ura[n][i]+ura[n-1][i];\n\t}\n\t\n\t/*\n\t\n\tfor(int i=0;i<17;i++){\n\t\tfor(int j=0;j<17;j++){\n\t\t\tprintf(\"%2d \",ura[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}*/\n\tprintf(\"%d\\n\",cont);\n\t\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tint X, Y;\n\tconst int M = 2;\n\twhile(cin >> X >> Y, X || Y) {\n\t\tlong long table[128][128];\n\t\tint m[128][128];\n\t\tfor(int i = 0; i < 128; i++) {\n\t\t\tfor(int j = 0; j < 128; j++) {\n\t\t\t\ttable[i][j] = 0;\n\t\t\t\tm[i][j] = 1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = M; i < Y + M; i++) {\n\t\t\tfor(int j = M; j < X + M; j++) {\n\t\t\t\tint tmp;\n\t\t\t\tcin >> tmp;\n\t\t\t\tm[i][j] = tmp;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = M; i < X + M; i++) {\n\t\t\tm[M-1][i] = 0;\n\t\t\tm[M+Y][i] = 0;\n\t\t\tm[M+Y+1][i] = 0;\n\t\t\tif(m[M][i] != 1)\n\t\t\t\ttable[M][i] = 1;\n\t\t}\n\n\t\tfor(int i = M; i < Y + M; i++) {\n\t\t\tfor(int j = M; j < X + M; j++) {\n\t\t\t\tint dx[] = {-1, 0, 1};\n\t\t\t\tfor(int k = 0; k < 3; k++) {\n\t\t\t\t\tif(m[i][j] == 2 && dx[k] == 0) {\n\t\t\t\t\t\tif((m[i + 2][j] == 2) || (m[i + 2][j] == 0))\n\t\t\t\t\t\t\ttable[i + 2][j] += table[i][j];\n\t\t\t\t\t}\n\t\t\t\t\telse if(m[i][j] == 0) {\n\t\t\t\t\t\tif(((m[i + 1][j + dx[k]] == 2 && dx[k] == 0) || (m[i + 1][j + dx[k]] == 0)) && (i != Y + M - 1 || dx[k] == 0))\n\t\t\t\t\t\t\ttable[i + 1][j + dx[k]] += table[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\tfor(int i = 0; i < Y + 2*M + 2; i++) {\n\t\t\tfor(int j = 0; j < X + M*2; j++) {\n\t\t\t\tcout << table[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\n\t\tlong long ans = 0;\n\t\tfor(int i = M; i < X + M; i++) {\n\t\t\tans += table[Y+M][i];\n\t\t\tans += table[Y+M+1][i];\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\nconst int INF=1e9;\nint dp[15][16];\nint fld[15][15];\nint main(){\n      int x,y;\n      while(cin>>x>>y&&(x||y)){\n            REP(i,y)REP(j,x)cin>>fld[j][i];\n            memset(dp,0,sizeof(dp));\n            REP(i,x)if(fld[i][0]==0)dp[i][0]=1;\n            REP(i,y-1){\n                  REP(j,x){\n                        if(fld[j][i]==0){\n                              for(int k=-1;k<=1;k++){\n                                    if(j+k<0||j+k>=x)continue;\n                                    //cout<<j+k<<\" \"<<i+1<<\" \"<<j<<\" \"<<i<<endl;\n                                    if(fld[j+k][i+1]==0){\n                                          //cout<<j+k<<\" \"<<i+1<<\" \"<<j<<\" \"<<i<<endl;\n                                          dp[j+k][i+1]+=dp[j][i];\n                                    }\n                                    else if(fld[j+k][i+1]==2&&k==0)dp[j+k][i+1]+=dp[j][i];\n                              }\n                        }else if(fld[j][i]==2){\n                              int to=min(y,i+2);\n                              if(to==y||fld[j][to]!=1)dp[j][to]+=dp[j][i];\n                        }\n                  }\n                  //REP(k,x)cout<<dp[k][i+1]<<\" \";cout<<endl;\n            }\n            //REP(i,y+1)REP(j,x)printf(\"%2d%c\",dp[j][i],j==x-1?'\\n':' ');\n            int ans=0;\n            REP(i,2)REP(j,x)ans+=dp[j][y-i];\n            cout<<ans<<endl;\n      }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nint main(void){\n\tint x,y,i,j;\n\twhile(scanf(\"%d%d\",&x,&y),x,y){\n\t\tint masu[20][20]={ 0 };\n\t\tint dp[20][20]={0};\n\t\tint ans=0;\n\t\tfor(i=1;i<=y;i++){\n\t\t\tfor(j=1;j<=x;j++){\n\t\t\t\tscanf(\"%d\",&masu[i][j]);\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<=y;i++)masu[i][0]=1;\n\t\tfor(j=0;j<=x;j++)masu[0][j]=1;\n\t\t\n\t\tfor(j=1;j<=x;j++){\n\t\t\tif(masu[1][j]==0)dp[1][j]=1;\n\t\t}\n\t\tfor(i=2;i<=y;i++){\n\t\t\tfor(j=1;j<=x;j++){\n\t\t\t\tif(masu[i][j]==0){\n\t\t\t\t\tif(masu[i-1][j-1]==0)dp[i][j]+=dp[i-1][j-1];\n\t\t\t\t\tif(masu[i-1][j]==0)\t dp[i][j]+=dp[i-1][j];\n\t\t\t\t\tif(masu[i-1][j+1]==0)dp[i][j]+=dp[i-1][j+1];\n\t\t\t\t\tif(masu[i-2][j]==2){\n\t\t\t\t\t\tdp[i][j]+=dp[i-2][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(masu[i][j]==1){\n\t\t\t\t\tdp[i][j]=0;\n\t\t\t\t}\n\t\t\t\tif(masu[i][j]==2){\n\t\t\t\t\tif(dp[i-1][j]==0)dp[i][j]=dp[i-1][j];\n\t\t\t\t\tif(masu[i-2][j]==2)dp[i][j]+=dp[i-2][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=x;i++){\n\t\t\tans+=dp[y][i];\n\t\t\tif(masu[y-1][i]==2)ans+=dp[y-1][i];\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nint X, Y;\nint field[15 + 2][15 + 2];\nint dp[15 + 2][15 + 2];\n\nvoid solve() {\n\tfor (int i = 1; i <= X; i++) {\n\t\tif (field[0][i] == 0) {\n\t\t\tdp[0][i] = 1;\n\t\t}\n\t}\n\tfor (int y = 0; y < Y; y++) {\n\t\tfor (int x = 1; x <= X; x++) {\n\t\t\tif (field[y][x] == 2) {\n\t\t\t\tif (field[y + 2][x] != 1) {\n\t\t\t\t\tdp[y + 2][x] += dp[y][x];\n\t\t\t\t}\n\t\t\t} else if (field[y][x] == 0) {\n\t\t\t\tif (field[y + 1][x - 1] == 0) {\n\t\t\t\t\tdp[y + 1][x - 1] += dp[y][x];\n\t\t\t\t}\n\t\t\t\tif (field[y + 1][x] != 1) {\n\t\t\t\t\tdp[y + 1][x] += dp[y][x];\n\t\t\t\t}\n\t\t\t\tif (field[y + 1][x + 1] == 0) {\n\t\t\t\t\tdp[y + 1][x + 1] += dp[y][x];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint sum = 0;\n\tfor (int y = Y; y <= Y + 1; y++) {\n\t\tfor (int x = 1; x <= X; x++) {\n\t\t\tsum += dp[y][x];\n\t\t}\n\t}\n\tprintf(\"%d\\n\", sum);\n}\n\nint main() {\n\twhile (scanf(\"%d %d \", &X, &Y) == 2) {\n\t\tif (X == 0 && Y == 0) {return 0;}\n\n\t\tfill(dp[0], &dp[15 + 2 - 1][15 + 2], 0);\n\t\tfill(field[0], &field[15 + 2 - 1][15 + 2], 1);\n\t\tfor (int y = Y; y <= Y + 1; y++) {\n\t\t\tfor (int x = 1; x <= X; x++) {\n\t\t\t\tfield[y][x] = 2;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < Y; i++) {\n\t\t\tfor (int j = 1; j <= X; j++) {\n\t\t\t\tscanf(\"%d \", &field[i][j]);\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tfor (int i = 0; i < Y + 2; i++) {\n\t\t\tfor (int j = 0; j < X + 2; j++) {\n\t\t\t\tprintf(\"%d \", field[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\t*/\n\t\tsolve();\n\t\t/*\n\t\tfor (int i = 0; i < Y + 2; i++) {\n\t\t\tfor (int j = 0; j < X + 2; j++) {\n\t\t\t\tprintf(\"%2d \", dp[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\t*/\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define N 15\nusing namespace std;\nvoid func(int,int);\nint jump(int,int);\nint X,Y,data[N][N],memo[N][N];\nint main(){\n  while(1){\n    cin >> X >> Y;\n    if(X==0&&Y==0) break;\n    for(int i=0;i<Y;i++)\n      for(int j=0;j<X;j++) cin >> data[i][j],memo[i][j]=0;\n    for(int i=0;i<X;i++)\n      if(data[0][i]==0) func(0,i);\n    int cnt=0;\n    for(int i=0;i<X;i++) cnt+=memo[0][i];\n    cout << cnt << endl;\n  }\n  return 0;\n}\nvoid func(int y,int x){\n  if(y==Y-1){\n    memo[Y-1][x]=1;\n    return ;\n  }\n  if(0<=x-1&&data[y+1][x-1]==0){\n    if(memo[y+1][x-1]==0) func(y+1,x-1);\n    memo[y][x]+=memo[y+1][x-1];\n  }\n  if(x+1<X&&data[y+1][x+1]==0){\n    if(memo[y+1][x+1]==0) func(y+1,x+1);\n    memo[y][x]+=memo[y+1][x+1];\n  }\n  if(data[y+1][x]==0){\n    if(memo[y+1][x]==0) func(y+1,x);\n    memo[y][x]+=memo[y+1][x];\n  }\n  if(data[y+1][x]==2){\n    int r=jump(y+1,x);\n    if(r==-2) memo[y][x]+=1;\n    else if(r!=-1){\n      if(memo[r][x]==0) func(r,x);\n      memo[y][x]+=memo[r][x];\n    }\n  }\n  if(memo[y][x]==0) data[y][x]=1;\n}\nint jump(int y,int x){\n  while(1){\n    y+=2;\n    if(y<=Y-1&&data[y][x]==1) break;\n    if(y>=Y-1) return -2;\n    if(data[y][x]==0) return y;\n  }\n  return -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n\nint main(){\n\tint kosu[2][20][20],x,y,c,i,j;\n\t\n\twhile(~scanf(\"%d%d\",&x,&y)){\n\t\tif(x==0&&y==0)break;\n\t\tmemset(kosu,0,sizeof(kosu));\n\t\tfor(i=1;i<=y;i++){\n\t\t\tfor(j=1;j<=x;j++){\n\t\t\t\tscanf(\"%d\",&c);\n\t\t\t\tkosu[1][i][j]=c;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(i=1;i<=x;i++){\n\t\t\tif(kosu[1][1][i]==0)kosu[0][1][i]=1;\n\t\t}\n\t\t\n\t\tfor(i=2;i<y;i++){\n\t\t\tfor(j=1;j<=x;j++){\n\t\t\t\tif(kosu[1][i][j]==1)continue;\n\t\t\t\tif(kosu[1][i-2][j]==2)kosu[0][i][j]+=kosu[0][i-2][j];\n\t\t\t\tif(kosu[1][i][j]==2){\n\t\t\t\t\tkosu[0][i][j]+=(kosu[1][i-1][j]==2?0:kosu[0][i-1][j]);\n\t\t\t\t}else{\n\t\t\t\t\tkosu[0][i][j]+=((kosu[1][i-1][j-1]==2?0:kosu[0][i-1][j-1])+(kosu[1][i-1][j]==2?0:kosu[0][i-1][j])+(kosu[1][i-1][j+1]==2?0:kosu[0][i-1][j+1]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(y==1){\n\t\t\tj=0;\n\t\t\tfor(i=1;i<=x;i++){\n\t\t\t\tj+=kosu[0][y][i];\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",j);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tfor(j=1;j<=x;j++){\n\t\t\tif(kosu[1][y-1][j]==2)kosu[0][y][j]+=kosu[0][y-1][j];\n\t\t\tif(kosu[1][y][j]!=1 && kosu[1][y-2][j]==2)kosu[0][y][j]+=kosu[0][y-2][j];\n\t\t\tif(kosu[1][y][j]==1)continue;\n\t\t\tif(kosu[1][y][j]==2){\n\t\t\t\tkosu[0][y][j]+=(kosu[1][y-1][j]==2?0:kosu[0][y-1][j]);\n\t\t\t}else{\n\t\t\t\tkosu[0][y][j]+=((kosu[1][y-1][j-1]==2?0:kosu[0][y-1][j-1])+(kosu[1][y-1][j]==2?0:kosu[0][y-1][j])+(kosu[1][y-1][j+1]==2?0:kosu[0][y-1][j+1]));\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tj=0;\n\t\tfor(i=1;i<=x;i++){\n\t\t\tj+=kosu[0][y][i];\n\t\t}\n\t\tprintf(\"%d\\n\",j);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main()\n{\n\tint n, m;\n\twhile (true){\n\t\tcin >> n >> m;\n\t\tif (n == 0 && m == 0){\n\t\t\tbreak;\n\t\t}\n\t\tint map[100][100] = { 0 };\n\t\tint dp[100][100] = { 0 };\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int i2 = 0; i2 < m; i2++){\n\t\t\t\tcin >> map[i][i2];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tif (map[0][i] == 0){\n\t\t\t\tdp[0][i] = 1;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < m - 1; i++){\n\t\t\tfor (int i2 = 0; i2 < n; i2++){\n\t\t\t\tif (map[i][i2] == 0){\n\t\t\t\t\tif (map[i + 1][i2] == 0 || map[i + 1][i2] == 2){\n\t\t\t\t\t\tdp[i + 1][i2] += dp[i][i2];\n\t\t\t\t\t}\n\t\t\t\t\tif (i2+1<m&&map[i + 1][i2 + 1] == 0){\n\t\t\t\t\t\tdp[i + 1][i2 + 1] += dp[i][i2];\n\t\t\t\t\t}\n\t\t\t\t\tif (i2 - 1 >= 0 && map[i + 1][i2 - 1] == 0){\n\t\t\t\t\t\tdp[i + 1][i2 - 1] += dp[i][i2];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (map[i][i2] == 2){\n\t\t\t\t\tif (map[i + 2][i2] == 0 || map[i + 2][i2] == 2){\n\t\t\t\t\t\tdp[i + 2][i2] += dp[i][i2];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tans += dp[m - 1][i];\n\t\t\tans += dp[m][i];\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n\tint n,m;\n\tint masu[17][17];\n\tint ura[17][17];\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0 && m==0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i=0;i<17;i++){\n\t\t\tfor(int j=0;j<17;j++){\n\t\t\t\tmasu[i][j]=0;\n\t\t\t\tura[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=1;j<=m;j++){\n\t\t\t\tscanf(\"%d\",&ura[i][j]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tswitch(ura[1][i]){\n\t\t\t\tcase 0:masu[1][i]+=1;break;\n\t\t\t\tcase 1:masu[1][i]+=0;break;\n\t\t\t\tcase 2:if(ura[2][i]==0){masu[2][i]+=1};break;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfor(int j=1;j<=m;j++){\n\t\t\t\tif(ura[i][j]==0){\n\t\t\t\t\tif(ura[i+1][j-1]==0){\n\t\t\t\t\t\tmasu[i+1][j-1]+=masu[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tif(ura[i+1][j]!=1){\n\t\t\t\t\t\tmasu[i+1][j]+=masu[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tif(ura[i+1][j+1]==0){\n\t\t\t\t\t\tmasu[i+1][j+1]+=masu[i][j];\n\t\t\t\t\t}\n\t\t\t\t}else if(ura[i][j]==2){\n\t\t\t\t\tif(ura[i+2][j]!=1){\n\t\t\t\t\t\tmasu[i+2][j]+=masu[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cont=0;\n\t\tfor(int i=n;i<=n+1;i++){\n\t\t\tfor(int j=1;j<=m;j++){\n\t\t\t\tcont+=masu[i][j];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",cont);\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 0203\n#include <iostream>\n#include <cstring>\n\nusing namespace std;\n \nint main(void)\n{\n    int w, h;\n    while (cin >> w >> h, w){\n        int field[32][32] = {};\n        for (int y = 1; y <= h; y++){\n            for (int x = 1; x <= w; x++){\n                cin >> field[y][x];\n            }\n        }\n        int dp[32][32];\n        memset(dp, 0, sizeof(dp));\n\n        for (int x = 1; x <= w; x++){\n            if (field[1][x] == 0){\n                dp[1][x] = 1;\n            }\n        }\n        for (int y = 1; y <= h; y++){\n            for (int x = 1; x <= w; x++){\n                if (field[y][x] == 1){\n                    continue;\n                }\n                if (field[y][x] == 2){\n                    dp[y + 2][x] += dp[y][x];\n                    continue;\n                }\n                if (field[y + 1][x - 1] == 0){\n                    dp[y + 1][x - 1] += dp[y][x];\n                }\n                if (field[y + 1][x] != 1){\n                    dp[y + 1][x] += dp[y][x];\n                }\n                if (field[y + 1][x + 1] == 0){\n                    dp[y + 1][x + 1] += dp[y][x];\n                }\n            }\n        }\n \n        int ret = 0;\n        for (int y = h - 1; y <= h; y++){\n            for (int x = 1; x <= w; x++){\n                if (y == h - 1){\n                    if (field[y][x] == 2) ret += dp[y][x];\n                    continue;\n                }\n                else {\n                    ret += dp[y][x];\n                }\n            }\n        }\n        cout << ret << endl;\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n  while(1){\n    int w,h,mp[20][20]={},dp[20][20] ={};\n    cin >> w >> h;\n    if(w==0 && h==0) break;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++) cin >> mp[i][j];\n    for(int i=0;i<w;i++) if(mp[0][i]==0) dp[0][i] = 1;\n\n    int ans=0;    \n    for(int i=0;i<h-1;i++)\n      for(int j=0;j<w;j++) \n\tfor(int k=-1;k<=1;k++){\n\t  if(mp[i][j] !=0) break;\n\t  int nx=j+k,ny=i+1;\n\t  if(nx<0||nx>=w) continue;\n\t  while(k==0 && mp[ny][nx]==2) ny+=2;\n\t  if(mp[ny][nx]!=0) continue;\n\t  dp[ny][nx]+= dp[i][j];\n\t  if(i >= h-1) ans+=dp[i][j];\n\t}\n    cout << ans <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n\nusing namespace std;\n\nconst int MAX = 17;\nint in[MAX][MAX], X,Y,data[MAX][MAX],ans;\nint dx[4] = {-1,0,1};\n\n\nvoid init(){\n  memset(data,0,sizeof(data));\n  memset(in,-1,sizeof(in));\n  ans = 0;\n}\n\n\nvoid solve(){\n  for(int i = 1; i <= Y; i++)\n    for(int j = 1; j <= X; j++){\n      for(int k = 0; k < 3; k++)\n\tif(in[i][j] == 0){\n\t  int f = j+dx[k];\n\t  if(i-1 > 0 && 0 < f && f <= X){\n\t    if(in[i-1][f] != 2) data[i][j] += data[i-1][f];\n\t    // if(i-2 > 0 && in[i-1][f] == 2) data[i][j] += data[i-2][f];\n\t  }\n\n\t}else if(in[i][j] == 2){\n\t  if(i-1 > 0) data[i][j] += data[i-1][j];\n\t  if(i+2 <= Y) data[i+2][j] += data[i][j];\n\t  break;\n\t}\n\t/*\n\tif(i-1 > 0 && j+dx[k] > 0 && j+dx[k] <= X && in[i][j] != 1 && in[i-1][j+dx[k]] != 2){\n\t  if(in[i][j] == 2) data[i][j] = data[i-1][j];\n\t  else data[i][j] += data[i-1][j+dx[k]];\n\t}\n      if(i-2 > 0 && in[i-2][j] == 2 && in[i][j] != 1) data[i][j] += data[i-2][j];\n\t*/\n    }\n\n  for(int j = 1; j <= X; j++){\n    if(Y-1 > 0 && in[Y-1][j] == 2) ans+=data[Y-1][j];\n    ans+=data[Y][j];\n  }\n  cout << ans << endl;\n}\n\nvoid print(){\n  for(int i = 1; i <= Y; i++){\n    for(int j = 1; j <= X; j++)\n      cout << data[i][j]<< \" \";\n    cout << endl;\n  }\n}\nint main(){\n  while(cin >> X >> Y && X+Y){\n    init();\n    for(int i = 1; i <= Y; i++)\n      for(int j = 1; j <= X; j++)\n\tcin >> in[i][j];\n    \n    for(int i = 1; i <= X; i++)\n      if(in[1][i] == 0) data[1][i] = 1;\n\n    solve();\n    //print();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\nusing namespace std;\n\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint W, H;\n\twhile(cin >> W >> H, W) {\n\t\tint b[15][20] = { 0 };\n\t\tfor(int i = 0; i < H; i++) {\n\t\t\tfor(int j = 0; j < W; j++) {\n\t\t\t\tcin >> b[i][j];\n\t\t\t}\n\t\t}\n\n\t\tint dp[15][20] = { 0 };\n\t\tfor(int i = 0; i < W; i++) {\n\t\t\tif(b[0][i] != 1)\n\t\t\t\tdp[0][i] = 1;\n\t\t}\n\n\t\tfor(int i = 0; i < H - 1; i++) {\n\t\t\tfor(int j = 0; j < W; j++) {\n\t\t\t\tif(b[i][j] == 0) {\n\t\t\t\t\tfor(int d = -1; d <= 1; d++) {\n\t\t\t\t\t\tif(j + d < 0 || W <= j + d) continue;\n\t\t\t\t\t\tif(b[i + 1][j + d] == 0 || b[i + 1][j + d] == 2 && d == 0)\n\t\t\t\t\t\t\tdp[i + 1][j + d] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(b[i][j] == 2) {\n\t\t\t\t\tdp[i + 2][j] += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor(int i = H - 1; i <= H; i++) {\n\t\t\tfor(int j = 0; j < W; j++) {\n\t\t\t\tif(b[i][j] != 1)\n\t\t\t\t\tans += dp[i][j];\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string.h>\n\nusing namespace std;\n\nchar field[18][18];\nint dp[18][18][18];\nint X, Y;\n\nint DFS(int x, int y, int prex)\n{\n\tif ((x < 0 || x >= X) || field[y][x] == '1' || (field[y][x] == '2' && x != prex))\n\t{\n\t\treturn(0);\n\t}\n\tif (y >= Y - 1)\n\t{\n\t\treturn(1);\n\t}\n\tif (dp[x][y][prex] != -1)\n\t{\n\t\treturn(dp[x][y][prex]);\n\t}\n\tint ans = 0;\n\tif (field[y][x] == '2')\n\t{\n\t\tans += DFS(x, y + 2, x);\n\t}\n\telse\n\t{\n\t\tans += DFS(x - 1, y + 1, x);\n\t\tans += DFS(x, y + 1, x);\n\t\tans += DFS(x + 1, y + 1, x);\n\t}\n\treturn(dp[x][y][prex] = ans);\n}\n\nvoid solve()\n{\n\twhile (cin >> X >> Y, X || Y)\n\t{\n\t\tfor (int i = 0; i < Y; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < X; ++j)\n\t\t\t{\n\t\t\t\tcin >> field[i][j];\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tmemset(dp, -1, sizeof(dp));\n\t\tfor (int i = 0; i < X; ++i)\n\t\t{\n\t\t\tans += DFS(i, 0, 0);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define N 15\nusing namespace std;\nvoid func(int,int);\nint jump(int,int);\nint X,Y,data[N][N],memo[N][N];\nint main(){\n  while(1){\n    cin >> X >> Y;\n    if(X==0&&Y==0) break;\n    for(int i=0;i<Y;i++)\n      for(int j=0;j<X;j++) cin >> data[i][j],memo[i][j]=0;\n    for(int i=0;i<X;i++)\n      if(data[0][i]==0) func(0,i);\n    int cnt=0;\n    for(int i=0;i<X;i++) cnt+=memo[0][i];\n    cout << cnt << endl;\n  }\n  return 0;\n}\nvoid func(int y,int x){\n  if(y==Y-1){\n    memo[Y-1][x]=1;\n    return ;\n  }\n  if(0<=x-1&&data[y+1][x-1]==0){\n    if(memo[y+1][x-1]==0) func(y+1,x-1);\n    memo[y][x]+=memo[y+1][x-1];\n  }\n  if(x+1<X&&data[y+1][x+1]==0){\n    if(memo[y+1][x+1]==0) func(y+1,x+1);\n    memo[y][x]+=memo[y+1][x+1];\n  }\n  if(data[y+1][x]==0){\n    if(memo[y+1][x]==0) func(y+1,x);\n    memo[y][x]+=memo[y+1][x];\n  }\n  if(data[y+1][x]==2){\n    int r=jump(y+1,x);\n    if(r==-2) memo[y][x]+=1;\n    else if(r!=-1){\n      if(memo[r][x]==0) func(r,x);\n      memo[y][x]+=memo[r][x];\n    }\n  }\n  if(memo[y][x]==0) data[y][x]=1;\n}\nint jump(int y,int x){\n  while(1){\n    y+=2;\n    if(y<=Y-1&&data[y][x]==1) break;\n    if(y>=Y-1) return -2;\n    if(data[y][x]==0) return y;\n  }\n  return -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint main() {\n\tint width, height, m[15][15];\n\twhile (cin >> width >> height, width && height) {\n\t\tfor (int y = 0; y < height; ++y)\n\t\t\tfor (int x = 0; x < width; ++x)\n\t\t\t\tcin >> m[y][x];\n\n\t\tint sum = 0, pattern[15][15] = {0};\n\t\tfor (int x = 0; x < width; ++x)\n\t\t\tpattern[0][x] = 1;\n\n\t\tfor (int y = 0; y < height-1; ++y)\n\t\t\tfor (int x = 0; x < width; ++x)\n\t\t\t\tif (m[y][x] == 0) {\n\t\t\t\t\tif (x - 1 >= 0 && m[y+1][x-1] == 0) pattern[y+1][x-1] += pattern[y][x];\n\t\t\t\t\tif (x + 1 < width && m[y+1][x+1] == 0) pattern[y+1][x+1] += pattern[y][x];\n\t\t\t\t\tif (m[y+1][x] != 1) pattern[y+1][x] += pattern[y][x];\n\t\t\t\t}\n\t\t\t\telse if (m[y][x] == 2) {\n\t\t\t\t\tif (y + 2 == height) sum += pattern[y][x];\n\t\t\t\t\telse if (m[y+2][x] != 1) pattern[y+2][x] += pattern[y][x];\n\t\t\t\t}\n\n\t\tfor (int x = 0; x < width; ++x)\n\t\t\tsum += pattern[width-1][x];\n\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define F first\n#define S second\n#define INF 1 << 30\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint main(){\n  int X, Y;\n  while(scanf(\"%d%d\", &X, &Y) && X+Y){\n    int board[15][15], dp[17][15] = {};\n    rep(i, Y) rep(j, X) if(scanf(\"%d\", &board[i][j])  && board[i][j] == 1) dp[i][j] = -1;\n\n    rep(i, X) if(!dp[0][i]) dp[0][i] = 1;\n\n    rep(i, Y-1) rep(j, X){\n      if(board[i][j] == 1) continue;\n      else if(board[i][j] == 2) dp[i+2][j] += dp[i][j];\n      else{\n\tfor(int k = -1; k < 2; k++){\n\t  if(j+k < 0 || j+k >= X) continue;\n\t  if(dp[i+1][j+k] == -1) continue;\n\t  if(board[i+1][j+k] == 2){\n\t    if(k != 0) continue;\n\t    dp[i+1][j+k] += dp[i][j];\n\t  }else{\n\t    dp[i+1][j+k] += dp[i][j];\n\t  }\n\t}\n      }\n    }\n\n    int res = 0;\n    REP(i, Y-1, Y+1)\n      rep(j, X)\n      if(dp[i][j] != -1)\n\tres += dp[i][j];\n  \n    rep(i, 17){ \n      rep(j, 15) printf(\"%d \", dp[i][j]);\n      puts(\"\");\n    }\n\n    printf(\"%d\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\ntypedef complex<double> P;\nstatic const double EPS = 1e-8;\nstatic const int INF = (int)1e8;\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) for (int i=0; i<(int)(n); ++i)\n#define FOREQ(i,k,n) for (int i=(k); i<=(int)(n); ++i)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define FIND(m,w) ((m).find(w)!=(m).end())\nint w,h;\nint grid[15][15];\nint memo[15][15];\nint dfs(int x,int y){\n  if(x<0||x>=w) return 0;\n  if(y<0||y>=h) return 0;\n  if(grid[y][x]==1) return memo[y][x] = 0;\n  if(y==0) return memo[y][x] = 1;\n  if(memo[y][x]>=0){\n    return memo[y][x];\n  }\n  int ret = 0;\n  if(grid[y-1][x]!=2)ret += dfs(x,y-1);\n  if(grid[y][x]!=2&&x-1>=0&&grid[y-1][x-1]!=2)ret += dfs(x-1,y-1);\n  if(grid[y][x]!=2&&x+1<w&&grid[y-1][x+1]!=2)ret += dfs(x+1,y-1);\n  if(y>=2&&grid[y-2][x]==2) ret += dfs(x,y-2);\n  return memo[y][x] = ret;\n}\n\nint main(void){\n  while(cin>>w>>h,w){\n    memset(memo,-1,sizeof(memo));\n    REP(y,h)REP(x,w){\n      cin>>grid[y][x];\n    }\n    int ans = 0;\n    REP(x,w){\n      ans += dfs(x,h-1);\n      if(grid[h-2][x]==2) ans += dfs(x,h-2);\n    }\n    \n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main()\n{\n\tint n, m;\n\twhile (true){\n\t\tcin >> n >> m;\n\t\tif (n == 0 && m == 0){\n\t\t\tbreak;\n\t\t}\n\t\tint map[100][100] = { 0 };\n\t\tint dp[100][100] = { 0 };\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tfor (int i2 = 0; i2 < n; i2++){\n\t\t\t\tcin >> map[i][i2];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tif (map[0][i] == 0){\n\t\t\t\tdp[0][i] = 1;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tfor (int i2 = 0; i2 < n; i2++){\n\t\t\t\tif (map[i][i2] == 0){\n\t\t\t\t\tif ((map[i + 1][i2] == 0 || map[i + 1][i2] == 2)){\n\t\t\t\t\t\tdp[i + 1][i2] += dp[i][i2];\n\t\t\t\t\t}\n\t\t\t\t\tif (i2+1<n &&map[i + 1][i2 + 1] == 0&&i<m-1){\n\t\t\t\t\t\tdp[i + 1][i2 + 1] += dp[i][i2];\n\t\t\t\t\t}\n\t\t\t\t\tif (i2 - 1 >= 0 && map[i + 1][i2 - 1] == 0&&i<m - 1){\n\t\t\t\t\t\tdp[i + 1][i2 - 1] += dp[i][i2];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (map[i][i2] == 2){\n\t\t\t\t\tif (map[i + 2][i2] == 0 || map[i + 2][i2] == 2){\n\t\t\t\t\t\tdp[i + 2][i2] += dp[i][i2];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tans += dp[m][i];\n\t\t\tans += dp[m + 1][i];\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint field[16][15];\nint dp[16][15];\n\nint n, m;\n\nbool isIn(int x, int y){\n    return 0 <= x && x < n && 0 <= y && y < m;\n}\n\nint main(){\n    while(cin >> n >> m, n+m){\n        for(int i=0; i < n; i++) for(int j=0; j< m; j++)cin >> field[i][j];\n        for(int i=0; i < 16; i++) for(int j=0; j < 15; j++) dp[i][j] = 0;\n        for(int i=0; i < m; i++) dp[0][i] = 1;\n        for(int i=0; i < n; i++){\n            for(int j=0; j < m; j++){\n                if(field[i][j] == 0){\n                    for(int k=-1; k <= 1; k++){\n                        if(isIn(i+1, j+k) && !(k != 0 && field[i+1][j+k] == 2)){\n                            dp[i+1][j+k] += dp[i][j];\n                        }\n                    }\n                }\n                else if(field[i][j] == 1) dp[i][j] = 0;\n                else if(field[i][j] == 2) dp[i+2][j] += dp[i][j];\n            }\n        }\n        for(int i=0; i< m; i++) if(field[n-1][i] != 1) dp[n][i] += dp[n-1][i];\n        int count = 0;\n        for(int i=0; i< m; i++) count += dp[n][i];\n        cout << count << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint dy[] = { 1, 1, 1};\nint dx[] = { -1, 0, 1 };\n\nint main() {\n    while (1) {\n        int dp[17][15] = { 0 };\n        int field[15][15] = { 0 };\n        int h, w;\n\n        cin >> w >> h;\n        if (w == 0) {\n            break;\n        }\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                cin >> field[i][j];\n            }\n        }\n        \n        for (int j = 0; j < w; j++) {\n            if (field[0][j] != 1) {\n                dp[0][j] = 1;\n            }\n        }\n        \n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                if (dp[i][j] > 0) {\n                    if (field[i][j] == 2) {\n                        if (field[i + 2][j] != 1) {\n                            dp[i + 2][j] += dp[i][j];\n                        }\n                        continue;\n                    }\n                    if (i == h - 1) {\n                        dp[i + 1][j] = dp[i][j];\n                        continue;\n                    }\n                    for (int k = 0; k < 3; k++) {\n                        int nx = j + dx[k];\n                        int ny = i + dy[k];\n                        if (nx < 0 || nx >= w) {\n                            continue;\n                        }\n                        if (field[ny][nx] == 0 || (field[ny][nx] == 2 && k == 1)) {\n                            dp[ny][nx] += dp[i][j];\n                        }\n                    }\n                }\n            }\n        }\n        \n        int ans = 0;\n        for (int i = h; i <= h + 1; i++) {\n            for (int j = 0; j < w; j++) {\n                ans += dp[h][j];\n            }\n        }\n        cout << ans << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\nint w,h;\nint s[40][40];\nint dp[40][40];\nint dx[]={-1,0,1};\nint ret(int y,int x){\n\tif(y>=h-1){\n\t\tif(h-1==y&&s[y][x]==1)\n\t\treturn 0;\n\t\treturn 1;\n\t}\n\tif(dp[y][x]!=-1)\n\treturn dp[y][x];\n\tif(s[y][x]==1)\n\t\treturn dp[y][x]=0;\n\tif(s[y][x]==2){\n\t\treturn dp[y][x]=ret(y+2,x);\n\t}\n\tint ans=0;\n\tfor(int i=0;i<3;i++){\n\t\tint nx=dx[i]+x;\n\t\tif(nx>=w||nx<0)\n\t\t\tcontinue;\n\t\t\n\t\tif(s[y+1][nx]==0){\n\t\t\tans+=ret(y+1,nx);\n\t\t}else if(s[y+1][nx]==2){\n\t\t\tif(i!=1)\n\t\t\t\tcontinue;\n\t\t\tans+=ret(y+1,nx);\n\t\t}\n\t}\n\treturn dp[y][x]=ans;\n}\nint main(){\n\twhile(cin>>w>>h,w||h){\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tfor(int i=0;i<h;i++)\n\t\tfor(int j=0;j<w;j++)\n\t\tcin>>s[i][j];\n\t\tint ans=0;\n\t\tfor(int i=0;i<w;i++){\n\t\t\t//if(s[0][i]==0)\n\t\t\t\tans+=ret(0,i);\n\t\t}\n\t\t\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint dp[20][20][2];\nint x[20][20];\nint H, W;\nvoid A(int a, int b, int c, int d) {\n\tif (x[a][b] == 2) {\n\t\tif (d != 0) { return; }\n\t\tif (c == 1) { return; }\n\t\tif (c == 0) {\n\t\t\tdp[a + 2][b][0] += dp[a][b][c];\n\t\t\treturn;\n\t\t}\n\t}\n\tif (x[a + 1][b + d] == 1) { return; }\n\tif (x[a + 1][b + d] == 2 && d != 0) { return; }\n\tif (x[a][b] == 0) {\n\t\tif (d == 0) {\n\t\t\tdp[a + 1][b + d][0] += dp[a][b][c];\n\t\t}\n\t\telse {\n\t\t\tdp[a + 1][b + d][1] += dp[a][b][c];\n\t\t}\n\t}\n}\nint main() {\n\twhile (true) {\n\t\tcin >> H >> W;\n\t\tif (H == 0 && W == 0) { break; }\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\tcin >> x[i][j];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 20; i++) {\n\t\t\tfor (int j = 0; j < 20; j++) {\n\t\t\t\tdp[i][j][0] = 0;\n\t\t\t\tdp[i][j][1] = 0;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= W; i++) {\n\t\t\tif (x[1][i] == 0) {\n\t\t\t\tdp[1][i][0] = 1;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= H - 1; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\tA(i, j, 0, -1);\n\t\t\t\tA(i, j, 0, 0);\n\t\t\t\tA(i, j, 0, 1);\n\t\t\t\tA(i, j, 1, -1);\n\t\t\t\tA(i, j, 1, 0);\n\t\t\t\tA(i, j, 1, 1);\n\t\t\t}\n\t\t}\n\t\tint sum = 0;\n\t\tfor (int j = H; j < 20; j++) {\n\t\t\tfor (int i = 1; i <= W; i++) {\n\t\t\t\tsum += dp[j][i][0] + dp[j][i][1];\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint main(){\n  int x,y;\n  int grid[17][15];\n  int c[17][15];\n  int dx[] = {-1,0,1};\n\n  for(;;){\n    cin >> x >> y;\n    if(!x && !y)break;\n\n    for(int i=0;i<y;i++)\n      for(int j=0;j<x;j++)cin >> grid[i][j];\n    for(int i=0;i<x;i++){\n      grid[y][i] = 0;\n      grid[y+1][i] = 0;\n    }\n\n    for(int i=0;i<y+2;i++)\n      for(int j=0;j<x;j++)c[i][j] = 0;\n\n    for(int i=0;i<x;i++)\n      if(!grid[0][i])c[0][i] = 1;\n\n    for(int i=0;i<y;i++){\n      for(int j=0;j<x;j++){\n\tif(!grid[i][j] && i!=y-1){\n\t  for(int k=0;k<3;k++){\n\t    int sx = j+dx[k];\n\t    if(sx<0 || x<=sx)continue;\n\t    if(!grid[i+1][sx] || (grid[i+1][sx]==2 && k==1))c[i+1][sx] += c[i][j];\n\t  }\n\t}\n\tif(grid[i][j] == 2){\n\t  if(grid[i+2][j]!=1)c[i+2][j] += c[i][j];\n\t}\n      }\n    }\n\n    int ans = 0;\n    for(int i=0;i<x;i++){\n      ans += c[y-1][i];\n      ans += c[y][i];\n      ans += c[y+1][i];\n    }\n    /*\n    for(int i=0;i<y+2;i++){\n      for(int j=0;j<x;j++)cout << c[i][j] << \" \";\n      cout << endl;\n    }\n    */\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define rep2(x,from,to) for(int x=(from);(x)<(to);(x)++)\n#define rep(x,to) rep2(x,0,to)\nusing namespace std;\nint main(){\n\tint x, y;\n\twhile(cin >> x >> y && (x||y) ) {\n\t\tint b[15][15] = {};\n\t\trep(i,y) {\n\t\t\trep(j,x) {\n\t\t\t\tcin >> b[i][j];\n\t\t\t}\n\t\t}\n\t\tint ret[20][20] = {};\n\t\trep(i,x) {\n\t\t\tif(b[0][i] == 0) {\n\t\t\t\tret[0][i+1] = 1;\n\t\t\t}\n\t\t}\n\t\trep2(i,1,y) {\n\t\t\trep(j,x) {\n\t\t\t\tif(b[i][j] == 0) {\n\t\t\t\t\tret[i][j+1] += ret[i-1][j] + ret[i-1][j+1] + ret[i-1][j+2];\n\t\t\t\t\trep2(k,-1,1) {\n\t\t\t\t\t\tif(b[i-1][j+k] == 2) ret[i][j+1] -= ret[i-1][j+k+1];\n\t\t\t\t\t}\n\t\t\t\t} else if(b[i][j] == 2) {\n\t\t\t\t\tret[i+2][j+1] += ret[i-1][j+1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// debug\n\t\trep(i,y+2) {\n\t\t\trep(j,x) {\n\t\t\t\tcout << ret[i][j+1] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\n\t\tint ans = 0;\n\t\trep2(i,y-1,y+2) {\n\t\t\trep(j,x) {\n\t\t\t\tans += ret[i][j+1];\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nint m[500][500];\nint dp[500][500];\n\nint dx[]={-1,0,1};\n\nint solve(int r,int c){\n  rep(i,r+2)rep(j,c)dp[i][j]=0;\n  rep(j,c)if(m[0][j] == 0)dp[0][j]=1;\n\n  rep(i,r-1){\n    rep(j,c){\n      if (m[i][j] == 0 ){\n\t      rep(k,3){\n\t        int nex = j+dx[k];\n\t          if (nex<0||nex>=c)continue;\n\t  if (m[i+1][nex] == 0)dp[i+1][nex]+=dp[i][j];\n\t  else if (m[i+1][nex] == 2 && k == 1)dp[i+1][nex]+=dp[i][j];\n\t}\n      }else if (m[i][j] == 2 && m[i+2][j] != 1){\n\tdp[i+2][j]+=dp[i][j];\n      }\n    }\n  }\n  \n  /*\n  rep(i,r+1) {\n    rep(j,c) printf(\"%8d\",dp[i][j]);\n    cout<<endl;\n  }*/\n  \n  int ans = 0;\n  rep(j,c)ans+=dp[r][j]+dp[r-1][j];\n  return ans;\n}\n\nmain(){\n  int c,r;\n  while(cin>>c>>r && r){\n    rep(i,r)rep(j,c)cin>>m[i][j];\n    rep(j,c)m[r][j]=0;\n    cout << solve(r,c) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF 999999999\n#define int long long int\n\nsigned main(){\n    int w,h;\n    while(cin>>w>>h){\n        if(w==0&&h==0)break;\n        int data[20][20];\n        rep(i,h){\n            rep(j,w){\n                cin>>data[i][j];\n            }\n        }\n        int dp[20][20];\n        rep(i,20)rep(j,20)dp[i][j]=0;\n        rep(i,w){\n            if(data[0][i]==0){\n                dp[0][i]=1;\n            }\n        }\n        \n        for(int i=0;i<h-1;i++){\n            for(int j=0;j<w;j++){\n                if(j-1>=0 && data[i+1][j-1]==0)dp[i+1][j-1]+=dp[i][j];\n                if(data[i+1][j]==0)dp[i+1][j]+=dp[i][j];\n                if(data[i+1][j]==2){\n                    int c=1;\n                    while(data[i+1+2*c][j]==2)c++;\n                    dp[min(h-1,i+1+c*2)][j]+=dp[i][j];\n                }\n                if(j+1<w && data[i+1][j+1]==0)dp[i+1][j+1]+=dp[i][j];\n            }\n        }\n        int ans=0;\n        rep(i,w){\n            ans+=dp[h-1][i];\n        }\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\nint X, Y, c[15][15], dp[15][15];\n\nint main(){\n\twhile (scanf(\"%d%d\", &X, &Y), X != 0) {\n\t\tfor (int i = 0; i < Y; i++) {\n\t\t\tfor (int j = 0; j < X; j++) {\n\t\t\t\tscanf(\"%d\", &c[i][j]);\n\t\t\t\tdp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < Y; i++) {\n\t\t\tfor (int j = 0; j < X; j++) {\n\t\t\t\tif (i == 0 && c[i][j] != 1) {\n\t\t\t\t\tdp[i][j] = 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (c[i][j] == 1) {\n\t\t\t\t\t\tif (i > 0 && c[i - 1][j] == 2) {\n\t\t\t\t\t\t\tdp[i][j] = dp[i - 1][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tdp[i][j] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (c[i][j] == 2) {\n\t\t\t\t\t\tdp[i][j] = dp[i - 1][j];\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[i][j] = dp[i - 1][j];\n\t\t\t\t\t\tif (j > 0 && c[i-1][j-1] == 0) {\n\t\t\t\t\t\t\tdp[i][j] += dp[i - 1][j - 1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j < X - 1 && c[i-1][j+1] == 0) {\n\t\t\t\t\t\t\tdp[i][j] += dp[i - 1][j + 1];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < X; i++) {\n\t\t\tsum += dp[Y - 1][i];\n\t\t}\n\t\tprintf(\"%d\\n\", sum);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <functional>\n#include <numeric>\n#define fi first\n#define se second\nusing namespace std;\nbool value(int y,int x,int R,int C){return 0<=y&&y<R&&0<=x&&x<C;}\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<long long > vll;\ntypedef vector< vi > vvi;\ndouble pie=acos(-1);\nint INF=10000009;\nint dx[4] = { 0,-1,0,1 };\nint dy[4] = { -1,0,1,0 };\nint c[20][20];\nlong long int dp[20][20];\nint main() {\n\tint X,Y;\n\twhile(true){\n\t\tlong long int ans=0;\n\t\tcin>>X>>Y;\n\t\tfor(int i=1;i<=Y+2;i++){\n\t\t\tfor(int j=1;j<=X;j++){\n\t\t\t\tdp[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tif(X+Y==0) break;\n\t\tfor(int i=1;i<=Y;i++){\n\t\t\tfor(int j=1;j<=X;j++){\n\t\t\t\tcin>>c[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=X;i++){\n\t\t\tif(c[1][i]==1){\n\t\t\t\tdp[1][i]=0;\n\t\t\t}\n\t\t\tif(c[1][i]==0){\n\t\t\t\tdp[1][i]=1;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=Y;i++){\n\t\t\tfor(int j=1;j<=X;j++){\n\t\t\t\tif(c[i][j]==0){\n\t\t\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\t\t\tif(c[i+1][j+k-1]==0) dp[i+1][j+k-1]+=dp[i][j];\n\t\t\t\t\t\telse if(k==1&&c[i+1][j+k-1]==2) dp[i+1][j+k-1]+=dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(c[i][j]==2){\n\t\t\t\t\tdp[i+2][j]+=dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=X;i++){\n\t\t\tif(c[Y-1][i]==2){\n\t\t\t\tans+=dp[Y-1][i];\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=X;i++){\n\t\t\tans+=dp[Y][i];\n\t\t}\n\t\tprintf(\"%lld\\n\",ans );\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n\nint main() {\n    int field[16][17], pattern[17][17];\n    int X, Y, i, j, k;\n\n    while ((cin >> X >> Y) && X) {\n        for (i = 1; i <= Y; i++) {\n            field[i][0] = field[i][X+1] = 0;\n            for (j = 1; j <= X; j++) {\n                cin >> field[i][j];\n            }\n        }\n\n        for (i = 2; i <= Y+1; i++) {\n            for (j = 0; j <= X + 1; j++) {\n                pattern[i][j] = 0;\n            }\n        }\n        for (j = 1; j <= X; j++) {\n            pattern[1][j] = field[1][j] == 0;\n        }\n\n        for (i = 1; i < Y; i++) {\n            for (j = 1; j <= X; j++) {\n                switch (field[i][j]) {\n                    case 0:\n                    for (k = -1; k <= 1; k++) {\n                        switch (field[i+1][j+k]) {\n                            case 0:\n                            pattern[i+1][j+k] += pattern[i][j];\n                            break;\n                            case 2:\n                            if (k == 0) {\n                                pattern[i+1][j+k] += pattern[i][j];\n                            }\n                            break;\n                            default: break;\n                        }\n                    }\n                    break;\n                    case 2:\n                    if (field[i+2][j] != 1) {\n                        pattern[i+2][j] += pattern[i][j];\n                    }\n                    break;\n                    default: break;\n                }\n            }\n        }\n        /* \n        for (i = 1; i <= Y; i++) {\n            for (j = 1; j <= X; j++) {\n                cout << \" \" << pattern[i][j];\n            }\n            cout << endl;\n        }\n        cout << endl;\n        */\n        int sum = 0;\n        for (i = Y; i <= Y + 1; i++) {\n            for (j = 1; j <= X; j++) {\n                sum += pattern[i][j];\n            }\n        }\n        cout << sum << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\ninline bool isinside(int j, int X){ return 0<=j&&j<X; }\nint main()\n{\n  while(true){\n    int X,Y;\n    cin >> X >> Y;\n    if( X == 0 && Y == 0 ) break;\n    int M[Y][X];\n    long long int ans[Y+2][X];\n    for(int i = 0; i < Y; ++i){\n      for(int j = 0; j < X; ++j){\n\tint c;\n\tcin >> c;\n\tM[i][j]=c;\n\tans[i][j]=0;\n      }\n    }\n    for(int i = 0; i < X; ++i){\n      ans[Y][i] = ans[Y+1][i] = 1;\n    }\n    const int dx[]={-1,0,1};\n    for(int i = Y-1; i >= 0; --i){\n      for(int j = 0; j < X; ++j){\n\tif( M[i][j] == 1 ){\n\t  ans[i][j] = 0;\n\t}\n\tif( M[i][j] == 0 ){\n\t  for(int k = 0; k < sizeof(dx)/sizeof(*dx); ++k){\n\t    if( isinside( j + dx[k], X ) ){\n\t      //if( ans[i][j] == 0 ){\n\t      //ans[i][j] = ans[i+1][j+dx[k]];\n\t      //}else{\n\t      if( M[i+1][j+dx[k]] == 2 && dx[k]!=0 )continue;\n\t\tans[i][j] += ans[i+1][j+dx[k]];\n\t\t//}\n\t    }\n\t  }\n\t}\n\tif( M[i][j] == 2 ){\n\t  ans[i][j] = ans[i+2][j];\n\t}\n\tif( i == Y-1 && ans[i][j] > 0 )ans[i][j] = 1;\n\t//cout << ans[i][j] << ' ';\n      }\n      //cout << endl;\n    }\n    long long int Answer = 0;\n    for(int i = 0; i < X; ++i){\n      Answer += ans[0][i];\n    }\n    cout << Answer << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<algorithm>\n\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint x,y;\nint c[20][20];\nint dp[20][20];\n\nvoid solve() {\n\trep(i,20) rep(j,20) c[i][j]=1;\n\trep(i,20) rep(j,20) dp[i][j]=0;\n\n\trep(i,y) rep(j,x) cin>>c[i][j];\n\n\trep(i,x) if(c[0][i]!=1) dp[0][i]=1;\n\t\n\tfor(int i=0;i<y;i++) {\n\t\tfor(int j=0;j<x;j++) {\n\t\t\tif(c[i][j]==2) {\n\t\t\t\tdp[i+2][j] += dp[i][j];\n\t\t\t}\n\t\t\telse if(c[i][j]==0) {\n\t\t\t\tif(c[i+1][j]!=1) {\n\t\t\t\t\tdp[i+1][j] += dp[i][j];\n\t\t\t\t}\n\t\t\t\tif(0<=j-1 && c[i+1][j-1]==0) {\n\t\t\t\t\tdp[i+1][j-1] += dp[i][j];\n\t\t\t\t}\n\t\t\t\tif(j+1 < x && c[i+1][j+1]==0) {\n\t\t\t\t\tdp[i+1][j+1] += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tint ans=0;\n\trep(i,x) if(c[y-1][i]==0) ans+=dp[y-1][i];\n\trep(i,x) if(c[y-2][i]==2) ans+=dp[y][i];\n\n\tcout<<ans<<endl;\n\n}\n\nint main() {\n\twhile(cin>>x>>y) {\n\t\tif(x+y==0) return 0;\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <array>\n\nusing namespace std;\n\nint main()\n{\n\n    int height, width;\n\n    while (cin >> width >> height) {\n        if (height == 0 && width == 0) break;\n\n        vector<vector<int>> field(height + 1, vector<int>(width + 2));\n\n        // input\n        for (int y = 0; y < height; ++y) {\n            for (int x = 1; x < width + 1; ++x) {\n                cin >> field.at(y).at(x);\n            }\n        }\n\n        vector<vector<int>> dp(height + 1, vector<int>(width + 2));\n\n        for (int x = 1; x < width + 1; ++x) {\n            if (field.at(0).at(x) != 1) {\n                dp.at(0).at(x) = 1;\n            }\n        }\n\n        // dp\n        array<int, 3> dx = {-1, 0, 1};\n\n\n        for (int y = 0; y < height - 1; ++y) {\n            for (int x = 1; x < width + 1; ++x) {\n                switch (field.at(y).at(x)) {\n                    case 0:\n                        for (int i = 0; i < 3; ++i) {\n                            // ?????????1??§???????????¨????????????\n                            // ?¬???????2????????????????????????????????????\n                            if (field.at(y + 1).at(x + dx.at(i)) != 1) {\n                                switch (i) {\n                                    case 1:\n                                        dp.at(y + 1).at(x + dx.at(i)) += dp.at(y).at(x);\n                                        break;\n                                    default:\n                                        if (field.at(y + 1).at(x + dx.at(i)) != 2) {\n                                            dp.at(y + 1).at(x + dx.at(i)) += dp.at(y).at(x);\n                                        }\n                                        break;\n                                }\n                            }\n                        }\n                        break;\n                    case 1:\n                        break;\n                    case 2:\n                        // y = height - 2??§2????????£?????´????????????\n                        if ( y + 2 >= height) {\n                            dp.at(y + 1).at(x) += dp.at(y).at(x);\n                        }\n                        else {\n                            dp.at(y + 2).at(x) += dp.at(y).at(x);\n                        }\n                        break;\n                }\n            }\n        }\n\n        int ans = 0;\n\n        for (int x = 1; x < width + 1; ++x) {\n            ans += dp.at(height - 1).at(x);\n        }\n\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint mp[16][16];\nint dp[16][16];\nint main() {\n\tint x, y;\n\twhile (cin >> x >> y, x) {\n\t\tmemset(dp, 0, sizeof(dp));\n\t\trep(i, y)rep(j, x)cin >> mp[i][j];\n\t\trep(i, x)if (!mp[0][i])dp[0][i] = 1;\n\t\trep(i, y - 1)rep(j, x) {\n\t\t\tif (mp[i][j] == 0) {\n\t\t\t\tif (j > 0 && !mp[i + 1][j - 1])dp[i + 1][j - 1] += dp[i][j];\n\t\t\t\tif (mp[i + 1][j] != 1)dp[i + 1][j] += dp[i][j];\n\t\t\t\tif (j + 1 < x && !mp[i + 1][j + 1])dp[i + 1][j + 1] += dp[i][j];\n\t\t\t}\n\t\t\tif (mp[i][j] == 2 && i + 2 < y&&mp[i + 2][j] != 1)\n\t\t\t\tdp[i + 2][j] += dp[i][j];\n\t\t}\n\t\tint sum = 0;\n\t\trep(i, x) {\n\t\t\tif (mp[y - 2][i] == 2)sum += dp[y - 2][i];\n\t\t\tsum += dp[y - 1][i];\n\t\t}\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\n#define reep(i,f,n) for(int i=f; i<int(n); ++i)\n#define rep(i,n) reep(i,0,n)\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\n\nint main()\n{\n\tint w, h;\n\twhile(scanf(\"%d%d\", &w, &h), w){\n\t\tvvi field(h, vi(w));\n\t\trep(i, h){\n\t\t\trep(j, w){\n\t\t\t\tscanf(\"%d\", &field[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvvi dp(h, vi(w, 0));\n\t\trep(i, w){\n\t\t\tdp[0][i] = !field[0][i];\n\t\t}\n\t\t\n\t\treep(i, 1, h){\n\t\t\trep(j, w){\n\t\t\t\tif(field[i][j] == 1)\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tif(i >= 2){\n\t\t\t\t\tdp[i][j] += field[i-2][j] == 2 ? dp[i-2][j] : 0;\n\t\t\t\t}\n\t\t\t\treep(k, field[i][j] == 0 ? -1 : 0, field[i][j] == 0 ? 2 : 1){\n\t\t\t\t\tint px = j + k;\n\t\t\t\t\tif(px < 0 || w <= px)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(field[i-1][px] != 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tdp[i][j] += dp[i-1][px];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint sum = 0;\n\t\trep(i, w){\n\t\t\tsum += dp[h-1][i];\n\t\t\tif(h > 1)\n\t\t\t\tsum += field[h-2][i] == 2 ? dp[h-2][i] : 0;\n\t\t}\n\t\tprintf(\"%d\\n\", sum);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint H,W,ans;\nint t[20][20];\nint u[20][20];\n\nbool inField(int x){\n  if(1<=x&&x<=W)return true;\n  return false;\n}\n\nint main(){\n  while(cin>>W>>H){\n    if(H==0&&W==0)break;\n    for(int i=0;i<20;i++)for(int j=0;j<20;j++)u[i][j]=0;\n    for(int i=1;i<=H;i++)for(int j=1;j<=W;j++)cin>>t[i][j];\n\n    for(int i=0;i<20;i++)u[1][i]=(t[1][i]==1?0:1);\n\n    ans=0;\n    for(int i=1;i<H;i++){\n      for(int j=1;j<=W;j++){\n\tif(t[i][j]==1)u[i][j]=0;\n\tif(u[i][j]==0)continue;\n\tif(t[i][j]==2){\n\t  u[i+2][j]+=u[i][j];\n\t  if(i+2>=H)ans+=u[i][j];\n\t  continue;\n\t}\n\tfor(int k=-1;k<=1;k++){\n\t  if(!inField(j+k))continue;\n\t  if(t[i+1][j+k]==0){\n\t    u[i+1][j+k]+=u[i][j];\n\t    if(i+1>=H)ans+=u[i][j];\n\t  }else if(t[i+1][j+k]==2&&k==0){\n\t    u[i+1][j+k]+=u[i][j];\n\t    if(i+1>=H)ans+=u[i][j];\n\t  }\n\t}\n      }//j\n    }//i\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint x,y,a[17][17],s,i,j;\nvoid dfs(int y1,int x1){\n  if(x1<1||x1>x)return;\n  if(y1>=y){s++;return;}\n  if(a[y1][x1]==2)dfs(y1+2,x1);\n  else {if(a[y1+1][x1]!=1)dfs(y1+1,x1);\n  if(a[y1+1][x1+1]==0)dfs(y1+1,x1+1);\n  if(a[y1+1][x1-1]==0)dfs(y1+1,x1-1);}\n  return;\n}\nint main(){\n  while(cin>>x>>y,x){\n    for(s=0,i=0;i<17;i++)for(j=0;j<17;j++)a[i][j]=0;    \n    for(s=0,i=1;i<=y;i++)for(j=1;j<=x;j++)cin>>a[i][j];\n    for(i=1;i<=x;i++){if(a[1][i]!=1)dfs(1,i);}\n    cout<<s<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\n\nint w,h;\nint data[20][20]; //y,x\nint memo[20][20]; //y,x\n\nint solve(int y, int x){\n\n  if(x < 0 || y < 0 || x == w || y == h) return 0;\n  if(memo[y][x] > 0) return memo[y][x];\n  if(data[y][x] == 1) return 0;\n  if(data[y][x] == 0 && y == h-1) return 1;\n  if(data[y][x] == 2 && (y == h-2 || y == h-1)) return 1;\n\n  if(data[y][x] == 2) return memo[y][x] = solve(y+2,x);\n\n  if(x > 0 && !data[y+1][x-1] && !data[y+1][x+1])\n    return memo[y][x] = solve(y+1,x-1) + solve(y+1,x) + solve(y+1,x+1);\n\n  else if(x > 0 && !data[y+1][x-1])\n    return memo[y][x] = solve(y+1,x-1) + solve(y+1,x);\n\n  else if(!data[y+1][x+1])\n    return memo[y][x] = solve(y+1,x) + solve(y+1,x+1);\n\n  else return memo[y][x] = solve(y+1,x);\n}\n\nint main(){\n\n  while(true){\n    cin >> w >> h;\n    if(!w && !h) break;\n\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++) cin >> data[i][j]; //y,x\n    }\n\n    int ans = 0;\n    for(int i=0;i<w;i++){\n      memset(memo,0,sizeof(memo));\n      ans += solve(0,i); //y,x\n    }\n\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <iostream>\nusing namespace std;\nconst int MAX_W = 15;\nconst int MAX_H = 15;\n\nint w, h;\nint field[MAX_H + 1][MAX_W];\nint dp[MAX_H + 1][MAX_W];\n\nvoid printfield() {\n\tfor (int i = 0; i <= h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tcout << '\\t' << dp[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nint main () {\n\twhile (cin >> w >> h, w || h) {\n\t\tmemset(field, 0, sizeof(field));\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tfor (int i = 1; i <= h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> field[i][j];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < w; i++) {\n\t\t\tif (field[1][i] == 0) dp[1][i] = 1;\n\t\t}\n\t\t\n\t\tfor (int i = 2; i <= h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (field[i - 2][j] == 2 && field[i][j] != 1) {\n\t\t\t\t\tdp[i][j] += dp[i - 2][j];\n\t\t\t\t}\n\t\t\t\tif (field[i][j] == 0) {\n\t\t\t\t\tfor (int dx = -1; dx <= 1; dx++) {\n\t\t\t\t\t\tint fx = j + dx;\n\t\t\t\t\t\tif (fx < 0 || w <= fx) continue;\n\t\t\t\t\t\tint fy = i - 1;\n\t\t\t\t\t\tif (field[fy][fx] != 0) continue;\n\t\t\t\t\t\tdp[i][j] += dp[fy][fx];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (field[i][j] == 2) {\n\t\t\t\t\tdp[i][j] += dp[i - 1][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < w; i++) {\n\t\t\tsum += dp[h][i];\n\t\t\tif (field[h - 1][i] == 2) sum += dp[h - 1][i];\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n\nint main(){\n\tint map[20][20];\n\tint ans_map[20][20];\n\tint x,y;\n\twhile(cin>>x>>y,(x!=0)&&(y!=0)){\n\t\tlong int ans=0;\n\t\tfor(int i=0;i<y;i++){\n\t\t\tfor(int j=0;j<x;j++){\n\t\t\t\tcin>>map[i][j];\n\t\t\t\tans_map[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<x;i++){\n\t\t\tans_map[y][i]=0;\n\t\t}\n\t\tfor(int i=0;i<x;i++){\n\t\t\tif(map[0][i]==0){\n\t\t\t\tans_map[0][i]=1;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i+1<y;i++){\n\t\t\tfor(int j=0;j<x;j++){\n\t\t\t\tif(map[i][j]==2){\n\t\t\t\t\tif(i+2<y){\n\t\t\t\t\t\tans_map[i+2][j]+=ans_map[i][j];\n\t\t\t\t\t}else{\n\t\t\t\t\t\tans_map[y][j]+=ans_map[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tans_map[i][j]=0;\n\t\t\t\t}else if(map[i][j]==1){\n\t\t\t\t\tans_map[i][j]=0;\n\t\t\t\t}else{ \n\t\t\t\t\tfor(int k=-1;k<2;k++){\n\t\t\t\t\t\tif((j+k<0)||(j+k>x-1)){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(map[i+1][j+k]==0){\n\t\t\t\t\t\t\t\tans_map[i+1][j+k]+=ans_map[i][j];\n\t\t\t\t\t\t\t}else if((k==0)&&(map[i+1][j+k]==2)){\n\t\t\t\t\t\t\t\tans_map[i+1][j+k]+=ans_map[i][j];\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<x;i++){\n\t\t\tans_map[y][i]+=ans_map[y-1][i];\n\t\t}\n\t\tfor(int i=0;i<x;i++){\n\t\t\tans+=ans_map[y][i];\n\t\t}\n\t\tcout<<ans<<endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint dfs(int x,int y);\nint mas[20][20];\nint memo[20][20];\nint X,Y;\n\nint main(){\n\twhile(1){\n\t\tcin >> X >> Y;\n\t\tif(X == 0 && Y == 0) break;\n\t\tfor(int i=0;i<20;i++){\n\t\t\tfor(int j=0;j<20;j++){\n\t\t\t\tmemo[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<Y;i++){\n\t\t\tfor(int j=0;j<X;j++){\n\t\t\t\tcin >> mas[i][j];\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i=0;i<X;i++){\n\t\t\tif(mas[0][i] == 0){\n\t\t\t\tans += dfs(i,0);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\nint dfs(int x,int y){\n\tif(memo[y][x] != -1) return memo[y][x];\n\tif(mas[y][x] == 1) return 0;\n\tif(y>=Y-1) return 1;\n\tif(mas[y][x] == 2) return (memo[y][x] = dfs(x,y+2));\n\telse{\n\t\tint cou = 0;\n\t\tfor(int i=-1;i<2;i++){\n\t\t\tint nx = x + i;\n\t\t\tint ny = y + 1;\n\t\t\tif(nx >= 0 && nx < X && ((i == 0 && mas[ny][nx] == 2) || (mas[ny][nx] == 0))){\n\t\t\t\tcou += dfs(nx,ny);\n\t\t\t}\n\t\t}\n\t\treturn (memo[y][x] = cou);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,a,n) for(int i=a;i<n;i++)\n#define repb(i,a,b) for(int i=a;i>=b;i--)\n#define all(a) a.begin(),a.end()\n#define o(a) cout<<a<<endl\n#define int long long\n#define fi first\n#define se second\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n\n\nsigned main() {\n\tint y, x;\n\twhile (1) {\n\t\tcin >> y >> x;\n\t\tif (y + x == 0) break;\n\t\tint d[20][20] = { 0 };\n\t\trep(i, 0, y) {\n\t\t\trep(j, 0, x) {\n\t\t\t\tcin >> d[i][j];\n\t\t\t}\n\t\t}\n\t\tint dp[20][20] = { 0 };\n\t\trep(i, 0, x) {\n\t\t\tif (d[0][i] == 0) dp[0][i] = 1;\n\t\t}\n\t\trep(i, 0, y) {\n\t\t\trep(j, 0, x) {\n\t\t\t\tif (d[i][j] == 1) continue;\n\t\t\t\tif (d[i][j] == 2) {\n\t\t\t\t\tdp[i + 2][j] += dp[i][j];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\trep(k, -1, 2) {\n\t\t\t\t\tif (j + k < 0 || j + k >= x || d[i + 1][j + k] != 0) continue;\n\t\t\t\t\tdp[i + 1][j + k] += dp[i][j];\n\t\t\t\t}\n\t\t\t\tif (d[i + 1][j] == 2) {\n\t\t\t\t\tdp[i + 1][j] += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*cout << endl;\n\t\trep(i, 0, y + 2) {\n\t\t\trep(j, 0, x) {\n\t\t\t\tcout << dp[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t\tint ans = 0;\n\t\trep(i, 0, x) {\n\t\t\tans += dp[y - 1][i];\n\t\t\tif (d[y - 2][i] == 2) {\n\t\t\t\tans += dp[y - 2][i];\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n\n#define PB push_back\n#define INF INT_MAX/3\n#define ALL(a) (a).begin(),(a).end()\n#define CLR(a) memset(a,0,sizeof(a))\n\ntypedef long long int ll;\n\nusing namespace std;\nint dp[20][20];\n\nint saiki(vector< vector<int> > &m,int x,int y){\n    if(dp[y][x] >= 0) return dp[y][x];\n    if(y >= m.size()) return dp[y][x] = 1;\n    if(m[y][x] == 1) return dp[y][x] = 0;\n    int ret = 0;\n    if(m[y][x] == 2) y++;\n    else{\n\tif(x>0 && y+1<m.size() && m[y+1][x-1] == 0) ret += saiki(m , x-1,y+1);\n\tif(x+1<m[0].size() && y+1<m.size() && m[y+1][x+1] == 0) ret += saiki(m,x+1,y+1);\n    }\n    ret += saiki(m,x,y+1);\n    return dp[y][x] = ret;\n} \n\nint main(){\n    while(true){\n\tint x,y;\n\tcin >> x >> y;\n\tif(x == 0 && y== 0) break;\n\tvector< vector<int> > m(y,vector<int>(x,0));\n\tmemset(dp,-1,sizeof(dp));\n\tREP(i,y)REP(j,x)cin >> m[i][j];\n\tint ans = 0;\n\tREP(i,x){\n\t    ans += saiki(m,i,0);\n\t}\n\tcout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n  int X, Y, c[15][15], dp[15][16];\n\n  while(cin >> X >> Y, X) {\n    fill_n( *dp, 15 * 16, 0);\n    for(int i = 0; i < X; i++) {\n      dp[0][i] = 1;\n    }\n\n\n    for(int i = 0; i < Y; i++) {\n      for(int j = 0; j < X; j++) {\n        cin >> c[i][j];\n      }\n    }\n    int ret = 0;\n    for(int i = 0; i < Y; i++) {\n      for(int j = 0; j < X; j++) {\n        if(c[i][j] == 0) {\n          for(int k = -1; k <= 1; k++) {\n            if(j + k < 0 || j + k >= X) continue;\n            if(i + 1 >= Y) {\n              if(k == 0) ret += dp[i][j];\n            } else {\n              if(c[i + 1][j + k] == 2 && k != 0) continue;\n              dp[i + 1][j + k] += dp[i][j];\n            }\n          }\n        } else if(c[i][j] == 1) {\n          continue;\n        } else {\n          if(i + 2 >= Y) ret += dp[i][j];\n          else dp[i + 2][j] += dp[i][j];\n        }\n      }\n    }\n    cout << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint w,h,xd[]={1,0,-1},p,u[20][20],d[20][20];\nint ret(int x,int y){\n\tint s=x,sum=0;\n\tif(h-1<=y){\n\t\treturn 1;\n\t}\n\tif(d[y][x]>=1)\n\treturn d[y][x];\n\telse if(u[y][x]==2)\n\t\treturn d[y][x]=ret(x,y+2);\n\telse if(u[y][x]==0){\n\t\ty++;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tx=s+xd[i];\n\t\t\tif(x>=0&&x<=w-1){\n\t\t\t\tif(u[y][x]==2&&i==1)\n\t\t\t\t\tsum+=d[y-1][s]=ret(x,y+2);\n\t\t\t\telse if(u[y][x]==0)\n\t\t\t\t\tsum+=d[y-1][s]=ret(x,y);\n\t\t\t}\n\t\t}\n\t\treturn d[y-1][s]=sum;\n\t}\n\treturn d[y][s]=-1;\n}\nint main(){\n\tint x,y;\n\twhile(cin>>w>>h,w||h){\n\t\tp=0;\n\t\tfor(int i=0;i<h;i++)\n\t\tfor(int j=0;j<w;j++){\n\t\t\tcin>>u[i][j];\n\t\t\td[i][j]=0;\n\t\t}\n\t\tfor(int i=0;i<w;i++){\n\t\t\tif(u[0][i]==0){\n\t\t\t\tx=i;\n\t\t\t\ty=0;\n\t\t\t\tp+=ret(x,y);\n\t\t\t}\n\t\t\telse if(u[0][i]==2){\n\t\t\t\tx=i;\n\t\t\t\ty=2;\n\t\t\t\tp+=ret(x,y);\n\t\t\t}\n\t\t}\n\t\tcout<<p<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 0203\n#include <iostream>\n\nusing namespace std;\n\nint main(void)\n{\n\tint x, y;\n\twhile (cin >> x >> y, x || y){\n\t\tint field[20][20];\n\t\tfor (int i = 1; i <= y; i++){\n\t\t\tfor (int j = 1; j <= x; j++){\n\t\t\t\tcin >> field[i][j];\n\t\t\t}\n\t\t}\n\t\tint dp[20][20] = {{0}};\n\t\tfor (int j = 1; j <= x; j++){\n\t\t\tif (field[1][j] == 0){\n\t\t\t\tdp[1][j] = 1;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= y; i++){\n\t\t\tfor (int j = 1; j <= x; j++){\n\t\t\t\tif (field[i][j] == 1){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (field[i][j] == 2){\n\t\t\t\t\tdp[i + 2][j] += dp[i][j];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (field[i + 1][j - 1] == 0){\n\t\t\t\t\tdp[i + 1][j - 1] += dp[i][j];\n\t\t\t\t}\n\t\t\t\tif (field[i + 1][j] != 1){\n\t\t\t\t\tdp[i + 1][j] += dp[i][j];\n\t\t\t\t}\n\t\t\t\tif (field[i + 1][j + 1] == 0){\n\t\t\t\t\tdp[i + 1][j + 1] += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// for (int i = 0; i <= y; i++){\n\t\t// \tfor (int j = 0; j <= x; j++){\n\t\t// \t\tcout << dp[i][j] << \" \";\n\t\t// \t}\n\t\t// \tputs(\"\");\n\t\t// }\n\n\t\tint ret = 0;\n\t\tfor (int i = y - 1; i <= y; i++){\n\t\t\tfor (int j = 1; j <= x; j++){\n\t\t\t\tif (i == y - 1){\n\t\t\t\t\tif (field[i][j] == 2) ret += dp[i][j];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tret += dp[i][j];\n\t\t\t\t\t// cout << i << \" \" << j << endl;\n\t\t\t\t\t// cout << ret << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ret << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 0203\n#include <iostream>\n#include <cstring>\n\nusing namespace std;\n \nint main(void)\n{\n    int w, h;\n    while (cin >> w >> h, w){\n        int field[32][32];\n        for (int y = 1; y <= h; y++){\n            for (int x = 1; x <= w; x++){\n                cin >> field[y][x];\n            }\n        }\n        int dp[32][32];\n        memset(dp, 0, sizeof(dp));\n\n        for (int x = 1; x <= w; x++){\n            if (field[1][x] == 0){\n                dp[1][x] = 1;\n            }\n        }\n        for (int y = 1; y <= h; y++){\n            for (int x = 1; x <= w; x++){\n                if (field[y][x] == 1){\n                    continue;\n                }\n                if (field[y][x] == 2){\n                    dp[y + 2][x] += dp[y][x];\n                    continue;\n                }\n                if (field[y + 1][x - 1] == 0){\n                    dp[y + 1][x - 1] += dp[y][x];\n                }\n                if (field[y + 1][x] != 1){\n                    dp[y + 1][x] += dp[y][x];\n                }\n                if (field[y + 1][x + 1] == 0){\n                    dp[y + 1][x + 1] += dp[y][x];\n                }\n            }\n        }\n \n        int ret = 0;\n        for (int y = h - 1; y <= h; y++){\n            for (int x = 1; x <= w; x++){\n                if (y == h - 1){\n                    if (field[y][x] == 2) ret += dp[y][x];\n                    continue;\n                }\n                else {\n                    ret += dp[y][x];\n                }\n            }\n        }\n        cout << ret << endl;\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <list>\n#include <iostream>\n#include <sstream>\n#include <climits>\n#include <cfloat>\n#include <complex>\n\nusing namespace std;\n\nint main()\n{\n\tint x, y;\n\twhile (scanf(\"%d %d\", &x, &y), x | y)\n\t{\n\t\tint topo[16][15 + 2];\n\t\tmemset(topo, 0, sizeof(topo));\n\t\tfor (int i = 0; i < y; ++i)\n\t\t\tfor (int j = 1; j <= x; ++j)\n\t\t\t\tscanf(\"%d\", &topo[i][j]);\n\n\t\tint dp[16][15 + 2];\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tfor (int i = 1; i <= x; ++i)\n\t\t\tdp[0][i] = 1;\n\n\t\tfor (int i = 0; i < y-1; ++i)\n\t\t{\n\t\t\tfor (int j = 1; j <= x; ++j)\n\t\t\t{\n\t\t\t\tif (topo[i][j] == 0 && i < y-1)\n\t\t\t\t{\n\t\t\t\t\tfor (int k = -1; k <= 1; ++k)\n\t\t\t\t\t\tif (topo[i+1][j+k] != 1 && (topo[i+1][j+k] == 0 || k == 0))\n\t\t\t\t\t\t\tdp[i+1][j+k] += dp[i][j];\n\t\t\t\t}\n\t\t\t\telse if (topo[i][j] == 2 && topo[i+2][j] != 1)\n\t\t\t\t\tdp[i+2][j] += dp[i][j];\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = y-1; i <= y; ++i)\n\t\t\tfor (int j = 1; j <= x; ++j)\n\t\t\t\tans += dp[i][j];\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint X, Y;\nint a[15][15];\nint b[16][15];\n\nbool input() {\n  cin >> X >> Y;\n  if (!X && !Y) {\n    return false;\n  }\n  for (int y = 0; y < Y; ++y) {\n    for (int x = 0; x < X; ++x) {\n      cin >> a[y][x];\n    }\n  }\n  return true;\n}\n\nvoid solve() {\n  for (int y = 0; y <= Y; ++y) {\n    for (int x = 0; x < X; ++x) {\n      b[y][x] = 0;\n    }\n  }\n  for (int x = 0; x < X; ++x) {\n    if (a[0][x] != 1) {\n      b[0][x] = 1;\n    }\n  }\n\n  for (int y = 0; y < Y - 1; ++y) {\n    for (int x = 0; x < X; ++x) {\n      if (!a[y][x]) {\n        for (int dx = -1; dx <= 1; ++dx) {\n          int nx = x + dx;\n          if (nx >= 0 && nx < X && !a[y + 1][nx]) {\n            b[y + 1][nx] += b[y][x];\n          }\n        }\n        if (a[y + 1][x] == 2) {\n          b[y + 1][x] += b[y][x];\n        }\n      } else if (a[y][x] == 2) {\n        if (a[y + 2][x] != 1) {\n          b[y + 2][x] += b[y][x];\n        }\n      }\n    }\n  }\n\n  int ans = 0;\n  for (int y = Y - 1; y <= Y; ++y) {\n    for (int x = 0; x < X; ++x) {\n      ans += b[y][x];\n    }\n  }\n  cout << ans << endl;\n}\n\nint main() {\n  while (input()) {\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define N 15\nusing namespace std;\nvoid func(int,int);\nint jump(int,int);\nint X,Y,data[N][N],memo[N][N];\nint main(){\n  while(1){\n    cin >> X >> Y;\n    if(X==0&&Y==0) break;\n    for(int i=0;i<Y;i++)\n      for(int j=0;j<X;j++) cin >> data[i][j],memo[i][j]=0;\n    for(int i=0;i<X;i++)\n      if(data[0][i]==0) func(0,i);\n    cout << endl;\n    for(int i=0;i<Y;i++){\n      for(int j=0;j<X;j++){\n\tcout << memo[i][j] << ' ';\n      }\n      cout << endl;\n    }\n    cout << endl;\n    int cnt=0;\n    for(int i=0;i<X;i++) cnt+=memo[0][i];\n    cout << cnt << endl;\n  }\n  return 0;\n}\nvoid func(int y,int x){\n  if(y==Y-1){\n    memo[Y-1][x]=1;\n    return ;\n  }\n  if(y+1<Y&&0<=x-1&&data[y+1][x-1]==0){\n    if(memo[y+1][x-1]==0) func(y+1,x-1);\n    memo[y][x]+=memo[y+1][x-1];\n  }\n  if(y+1<Y&&x+1<X&&data[y+1][x+1]==0){\n    if(memo[y+1][x+1]==0) func(y+1,x+1);\n    memo[y][x]+=memo[y+1][x+1];\n  }\n  if(y+1<Y&&data[y+1][x]==0){\n    if(memo[y+1][x]==0) func(y+1,x);\n    memo[y][x]+=memo[y+1][x];\n  }\n  if(y+1<Y&&data[y+1][x]==2){\n    int r=jump(y+1,x);\n    if(r==-2) memo[y][x]+=1;\n    else if(r!=-1){\n      func(r,x);\n      memo[y][x]+=memo[r][x];\n    }\n  }\n  //if(memo[y][x]==0) data[y][x]=1;\n}\nint jump(int y,int x){\n  while(1){\n    y+=2;\n    if(data[y][x]==1) break;\n    if(y>=Y-1) return -2;\n    if(data[y][x]==0) return y;\n  }\n  return -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint field[16][15];\nint dp[15][15];\n\nint n, m;\n\nbool isIn(int x, int y){\n    return 0 <= x && x < n && 0 <= y && y < m;\n}\n\nint main(){\n    while(cin >> n >> m, n+m){\n        for(int i=0; i < n; i++) for(int j=0; j< m; j++){cin >> field[i][j]; dp[i][j] = 0;}\n        for(int i=0; i < m; i++) dp[0][i] = 1;\n        for(int i=0; i < n-1; i++){\n            for(int j=0; j < m; j++){\n                if(field[i][j] == 0){\n                    for(int k=-1; k <= 1; k++){\n                        if(isIn(i+1, j+k) && !(k != 0 && field[i+1][j+k] == 2)){\n                            dp[i+1][j+k] += dp[i][j];\n                        }\n                    }\n                }\n                else if(field[i][j] == 1) dp[i][j] = 0;\n                else if(field[i][j] == 2) dp[i+2][j] += dp[i][j];\n            }\n        }\n        int count = 0;\n        for(int i=0; i< m; i++) count += dp[n-1][i];\n        cout << count << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "// 2011/08/02 Tazoe\n\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n\twhile(true){\n\t\tint X, Y;\n\t\tcin >> X >> Y;\n\t\tif(X==0&&Y==0)\n\t\t\tbreak;\n\n\t\tint C[17][17];\n\t\tfor(int i=0; i<=Y+1; i++)\n\t\t\tfor(int j=0; j<=X+1; j++)\n\t\t\t\tC[i][j] = 1;\n\n\t\tfor(int i=1; i<=Y; i++)\n\t\t\tfor(int j=1; j<=X; j++)\n\t\t\t\tcin >> C[i][j];\n\n\t\tfor(int j=1; j<=X; j++)\n\t\t\tC[Y+1][j] = 0;\n\n\t\tint DP[17][17];\n\t\tfor(int i=0; i<=Y+1; i++)\n\t\t\tfor(int j=0; j<=X+1; j++)\n\t\t\t\tDP[i][j] = 0;\n\n\t\tfor(int j=1; j<=X; j++)\n\t\t\tif(C[1][j]==0)\n\t\t\t\tDP[1][j] = 1;\n\n\t\tfor(int i=1; i<=Y-1; i++)\n\t\t\tfor(int j=1; j<=X; j++)\n\t\t\t\tif(C[i][j]==0){\n\t\t\t\t\tfor(int k=j-1; k<=j+1; k++)\n\t\t\t\t\t\tif(C[i+1][k]==0){\n\t\t\t\t\t\t\tDP[i+1][k] += DP[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(C[i+1][k]==1){\n\t\t\t\t\t\t\tDP[i+1][k] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(C[i+1][k]==2){\n\t\t\t\t\t\t\tif(k==j)\n\t\t\t\t\t\t\t\tDP[i+1][k] += DP[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(C[i][j]==1){\n\t\t\t\t\tDP[i][j] = 0;\n\t\t\t\t}\n\t\t\t\telse if(C[i][j]==2){\n\t\t\t\t\tif(C[i+2][j]==1)\n\t\t\t\t\t\tDP[i+2][j] = 0;\n\t\t\t\t\telse\n\t\t\t\t\t\tDP[i+2][j] += DP[i][j];\n\t\t\t\t}\n\n\t\tfor(int j=1; j<=X; j++)\n\t\t\tif(C[Y][j]==1){\n\t\t\t\tDP[Y][j] = 0;\n\t\t\t}\n\n\t\tint sum = 0;\n\t\tfor(int i=Y; i<=Y+1; i++)\n\t\t\tfor(int j=1; j<=X; j++)\n\t\t\t\tsum += DP[i][j];\n\n\t\tcout << sum <<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tint W, H;\n\twhile(cin >> W >> H, W) {\n\t\tint b[20][15] = { 0 };\n\t\tfor(int i = 0; i < H; i++) {\n\t\t\tfor(int j = 0; j < W; j++) {\n\t\t\t\tcin >> b[i][j];\n\t\t\t}\n\t\t}\n\n\t\tint dp[20][15] = { 0 };\n\t\tfor(int i = 0; i < W; i++) {\n\t\t\tif(b[0][i] != 1) dp[0][i] = 1;\n\t\t}\n\n\t\tfor(int i = 0; i < H - 1; i++) {\n\t\t\tfor(int j = 0; j < W; j++) {\n\t\t\t\tif(b[i][j] == 0) {\n\t\t\t\t\tfor(int d = -1; d <= 1; d++) {\n\t\t\t\t\t\tif(0 <= j + d &&  j + d < W && (b[i + 1][j + d] == 0) || (b[i + 1][j + d] == 2 && d == 0))\n\t\t\t\t\t\t\tdp[i + 1][j + d] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(b[i][j] == 2) {\n\t\t\t\t\tdp[i + 2][j] += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor(int i = H - 1; i <= H; i++) {\n\t\t\tfor(int j = 0; j < W; j++) {\n\t\t\t\tif(b[i][j] != 1)\n\t\t\t\t\tans += dp[i][j];\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 0203\n#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nint main(void)\n{\n\tint x, y;\n\twhile (cin >> x >> y, x || y){\n\t\tint field[32][32] = {};\n\t\tfor (int i = 1; i <= y; i++){\n\t\t\tfor (int j = 1; j <= x; j++){\n\t\t\t\tcin >> field[i][j];\n\t\t\t}\n\t\t}\n\t\tint dp[32][32];\n\t\tmemset(dp, 0, sizeof(dp));\n\n\t\tfor (int j = 1; j <= x; j++){\n\t\t\tif (field[1][j] == 0){\n\t\t\t\tdp[1][j] = 1;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= y; i++){\n\t\t\tfor (int j = 1; j <= x; j++){\n\t\t\t\tif (field[i][j] == 1){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (field[i][j] == 2){\n\t\t\t\t\tdp[i + 2][j] += dp[i][j];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (field[i + 1][j - 1] == 0){\n\t\t\t\t\tdp[i + 1][j - 1] += dp[i][j];\n\t\t\t\t}\n\t\t\t\tif (field[i + 1][j] != 1){\n\t\t\t\t\tdp[i + 1][j] += dp[i][j];\n\t\t\t\t}\n\t\t\t\tif (field[i + 1][j + 1] == 0){\n\t\t\t\t\tdp[i + 1][j + 1] += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ret = 0;\n\t\tfor (int i = y - 1; i <= y; i++){\n\t\t\tfor (int j = 1; j <= x; j++){\n\t\t\t\tif (i == y - 1){\n\t\t\t\t\tif (field[i][j] == 2) ret += dp[i][j];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if (field[i][j] != 1){\n\t\t\t\t\tret += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ret << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n\nusing namespace std;\n\nint main(int argc, char const* argv[])\n{\n\tint x,y;\n\tint stage[17][17][2];\n\n\twhile( cin >> x >> y && x != 0 && y != 0 ){\n\t\tfor( int i = 0;i < 17;i++ ){\n\t\t\tfor( int j = 0;j < 17;j++ ){\n\t\t\t\tstage[i][j][0] = stage[i][j][1] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tfor( int i = 1;i <= y;i++ ){\n\t\t\tfor( int j = 1;j <= x;j++ ){\n\t\t\t\tcin >> stage[j][i][0];\n\t\t\t}\n\t\t}\n\n\t\tfor( int i = 0;i < 17;i++ ) if(stage[i][1][0] != 1 ) stage[i][1][1] = 1;\n\n\t\tfor( int j = 1;j < y;j++ ){\n\t\t\tfor( int i = 1;i <= x;i++ ){\n\t\t\t\tif( stage[i][j][0] == 1 ) continue;\n\t\t\t\tif( stage[i][j][0] == 0 ){\n\t\t\t\t\tstage[i][j + 1][1] += stage[i][j][1];\n\t\t\t\t\t\n\t\t\t\t\tif( stage[i + 1][j + 1][0] == 0 ) stage[i + 1][j + 1][1] += stage[i][j][1];\n\t\t\t\t\tif( stage[i - 1][j + 1][0] == 0 ) stage[i - 1][j + 1][1] += stage[i][j][1];\n\n\t\t\t\t}\n\t\t\t\tif( stage[i][j][0] == 2 ){\n\t\t\t\t\tstage[i][j + 2][1] = stage[i][j][1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint count = 0;\n\t\tfor( int i = 1;i <= x;i++ ){\n\t\t\tcount += stage[i][y+1][1] + stage[i][y][1];\n\t\t}\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#define N 15\nusing namespace std;\nvoid func(int,int);\nint jump(int,int);\nint X,Y,data[N][N],memo[N+2][N];\nint main(){\n  while(1){\n    cin >> X >> Y;\n    if(X==0&&Y==0) break;\n    for(int i=0;i<N+2;i++){\n      for(int j=0;j<N;j++){\n\tdata[i][j]=0;\n      }\n    }\n    for(int i=0;i<Y;i++)\n      for(int j=0;j<X;j++) cin >> data[i][j];\n    for(int i=0;i<Y+2;i++)\n      for(int j=0;j<X;j++) memo[i][j]=0;\n    for(int i=0;i<X;i++)\n      if(data[0][i]!=1)\tfunc(0,i);\n    int cnt=0;\n    for(int i=0;i<X;i++) cnt+=memo[0][i];\n    cout << cnt << endl;\n  }\n  return 0;\n}\nvoid func(int y,int x){\n  if(y>=Y-1){\n    memo[Y][x]=memo[Y-1][x]=1;\n    return ;\n  }\n  if(y+1<Y&&0<=x-1&&data[y+1][x-1]==0){\n    if(memo[y+1][x-1]!=0) memo[y][x]+=memo[y+1][x-1];\n    else{\n      func(y+1,x-1),memo[y][x]+=memo[y+1][x-1];\n    }\n  }\n  if(y+1<Y&&x+1<X&&data[y+1][x+1]==0){\n    if(memo[y+1][x+1]!=0) memo[y][x]+=memo[y+1][x+1];\n    else{\n      func(y+1,x+1),memo[y][x]+=memo[y+1][x+1];\n    }\n  }\n  if(data[y+1][x]==0){\n    if(memo[y+1][x]!=0) memo[y][x]+=memo[y+1][x];\n    else{\n      func(y+1,x),memo[y][x]+=memo[y+1][x];\n    }\n  }\n  if(data[y+1][x]==2){\n    int r=jump(y+1,x);\n    if(r!=-1){\n      if(memo[r][x]!=0) memo[y][x]+=memo[r][x];\n      else func(r,x),memo[y][x]+=memo[r][x];\n    }\n  }\n  if(memo[y][x]==0) data[y][x]=1;\n}\nint jump(int y,int x){\n  y+=2;\n  while(1){\n    if(data[y][x]==1) break;\n    if(data[y][x]==0) return y;\n    if(y>=Y-1) return y;\n    y+=2;\n  }\n  return -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nconst int EMPTY = -1;\nconst int MOVE = 0;\nconst int BARRIIER = 1;\nconst int JUMP = 2;\n\nint course[15][15];\nint sizeX, sizeY;\nint answer = 0;\n\nvoid initCourse() {\n  for (int i = 0; i < 15; i++) {\n    for (int j = 0; j < 15; j++) {\n      course[i][j] = EMPTY;\n    }\n  }\n}\n\nvoid inputCourse() {\n  for (int i = 0; i < sizeY; i++) {\n    for (int j = 0; j < sizeX; j++) {\n      cin >> course[i][j];\n    }\n  }\n}\n\nvoid move(int x, int y) {\n  if (course[y][x] == BARRIIER) {\n    return;\n  }\n  if (y >= sizeY - 1) {\n    answer++;\n    return;\n  }\n  if (course[y][x] == JUMP) {\n    move(x, y + 2);\n  }\n  if (course[y][x] == MOVE) {\n    if ((x - 1) >= 0) {\n      if (course[y + 1][x - 1] == MOVE) {\n        move(x - 1, y + 1);\n      }\n    }\n    if (course[y + 1][x] == MOVE || course[y + 1][x] == JUMP) {\n      move(x, y + 1);\n    }\n    if ((x + 1) < sizeX) {\n      if (course[y + 1][x + 1] == MOVE) {\n        move(x + 1, y + 1);\n      }\n    }\n  }\n}\n\nint main(int argc, char* argv[]) {\n  while (cin >> sizeX >> sizeY, sizeX) {\n    initCourse();\n    inputCourse();\n    answer = 0;\n    for (int i = 0; i < sizeX; i++) {\n      if (course[0][i] == MOVE) {\n        move(i, 0);\n      }\n    }\n    cout << answer << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define rep2(x,from,to) for(int x=(from);(x)<(to);(x)++)\n#define rep(x,to) rep2(x,0,to)\nusing namespace std;\nint main(){\n\tint x, y;\n\twhile(cin >> x >> y && (x||y) ) {\n\t\tint b[15][15] = {};\n\t\trep(i,y) {\n\t\t\trep(j,x) {\n\t\t\t\tcin >> b[i][j];\n\t\t\t}\n\t\t}\n\t\tint ret[20][20] = {};\n\t\trep(i,x) {\n\t\t\tif(b[0][i] == 0) {\n\t\t\t\tret[0][i+1] = 1;\n\t\t\t}\n\t\t}\n\t\trep2(i,1,y) {\n\t\t\trep(j,x) {\n\t\t\t\tif(b[i][j] == 0) {\n\t\t\t\t\tret[i][j+1] += ret[i-1][j] + ret[i-1][j+1] + ret[i-1][j+2];\n\t\t\t\t\trep2(k,-1,1) {\n\t\t\t\t\t\tif(b[i-1][j+k] == 2) ret[i][j+1] -= ret[i-1][j+k+1];\n\t\t\t\t\t}\n\t\t\t\t} else if(b[i][j] == 2) {\n\t\t\t\t\tif(y <= i+2 || b[i+2][j] != 1) ret[i+2][j+1] += ret[i-1][j+1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\trep2(i,y-1,y+2) {\n\t\t\trep(j,x) {\n\t\t\t\tans += ret[i][j+1];\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint w,h;\nint mp[20][20];\nint memo[20][20];\nint ans;\nint count;\n\nint saiki(int x,int y) {\n  count++;\n  // cout << x <<\" \"<<y <<endl;\n  int dx[3] = {-1,0,1};\n  int dy[3] = {1,1,1};\n  \n  if(y >= h-1) ans++,memo[y][x]++;//,cout <<\"ok\"<<endl;  \n  else if(mp[y][x] != 1) {\n    for(int i=0;i<3;i++) {\n      int nx = dx[i]+x;\n      int ny = dy[i]+y;\n      if(nx <0|| nx >= w || memo[ny][nx] == -1) continue;\n      \n      if(memo[ny][nx] > 0 && mp[ny][nx] == 0) {\n\tans += memo[ny][nx];\n\tmemo[y][x] += memo[ny][nx];\n      }  \n      else if(x == nx && memo[ny][nx] == 2 && memo[ny][nx] > 0) {\n\tans += memo[ny][nx];\n\tmemo[y][x] += memo[ny][nx];\n      }\n      else if(mp[ny][nx] == 0){\n\tsaiki(nx,ny);\n\tif(memo[ny][nx] > 0) memo[y][x] += memo[ny][nx];\n      } \n      else if(nx==x && mp[ny][nx] == 2){\n\tint ty = ny;\n\twhile(mp[ty][nx] == 2) ty+=2;\n\tsaiki(nx,ty);\n\tif(memo[ty][nx] > 0) memo[y][x] += memo[ty][nx];\n      } \n    }\n    if(memo[y][x] == 0) memo[y][x] = -1;\n  }\n}\n\n\nint main() {\n\n  while(1) {\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n\n    for(int i=0;i<=19;i++) \n      for(int j=0;j<=19;j++){ \n\tmemo[i][j] = 0;\n\tmp[i][j] = 0;\n      }\n    \n    for(int i=0;i<h;i++) \n      for(int j=0;j<w;j++) \n\tcin >> mp[i][j];\n\n    /*\n      for(int i=0;i<h;i++) {\n      for(int j=0;j<w;j++) \n      cout << mp[i][j];\n      cout << endl;\n      }\n    */\n\n    ans = 0;\n    count = 0;\n    for(int i=0;i<w;i++) {\n      if(mp[0][i] !=1) saiki(i,0);\n    }\n\n    int ans2 = 0;\n    for(int i=0;i<w;i++) \n      if(memo[0][i] > 0) ans2+=memo[0][i];\n\n    cout << ans << endl;\n    //    cout << ans2 << endl;\n    //cout << count << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double ESP=1e-10;\nusing namespace std;\nint main(){\n  int n,m;\n  while(cin>>m>>n,n||m){\n    vector<vector<int> >in(n,vector<int>(m));\n    vector<vector<int> >dp(n+1,vector<int>(m));\n    rep(i,n)rep(j,m)cin>>in[i][j];\n    rep(i,m)dp[0][i]=1;\n    loop(i,1,n+1){\n      rep(j,m){\n\tif(i<n&&in[i][j]==1)continue;\n\telse if(i!=n){\n\t  if(j!=0&&in[i-1][j-1]==0&&in[i][j]!=2)dp[i][j]+=dp[i-1][j-1];\n\t  if(in[i-1][j]==0)dp[i][j]+=dp[i-1][j];\n\t  if(j!=m&&in[i-1][j+1]==0&&in[i][j]!=2)dp[i][j]+=dp[i-1][j+1];\n\t  if(i!=1&&in[i-2][j]==2)dp[i][j]+=dp[i-2][j];\n\t}else if(i-2>=0&&in[i-2][j]==2)dp[i][j]+=dp[i-2][j];\n      }      \n    }\n    int sum=0;\n    //rep(i,n+1){rep(j,m)printf(\" %2d\",dp[i][j]);puts(\"\");}\n    loop(i,n-1,n+1)rep(j,m)sum+=dp[i][j];\n    cout<<sum<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main(){\n\n    int w,h;\n    while(cin>>w>>h){\n        if(w==0)break;\n        int data[16][16]={{0}},dp[17][17]={{0}};\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                cin>>data[i][j];\n                if(i==0&&data[i][j]!=1)dp[i][j]=1;\n            }\n        }\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                if(dp[i][j]!=0){\n                    if(data[i][j]==0){\n                        if(i!=h-1&&j!=0&&data[i+1][j-1]==0)dp[i+1][j-1]+=dp[i][j];\n                        if(data[i+1][j]!=1)dp[i+1][j]+=dp[i][j];\n                        if(i!=h-1&&j!=w-1&&data[i+1][j+1]==0)dp[i+1][j+1]+=dp[i][j];\n                    }\n                    else if(data[i][j]==2){\n                        if(i==h-1)dp[i+1][j]+=dp[i][j];\n                        else if(data[i+2][j]!=1)dp[i+2][j]+=dp[i][j];\n                    }\n                }\n            }\n        }\n        /*\n        cout<<endl;\n        for(int i=0;i<=h;i++){\n            cout<<i<<\":\";\n            for(int j=0;j<w;j++){\n                cout<<dp[i][j]<<\" \";\n            }\n            cout<<endl;\n        }*/\n        int ans=0;\n        for(int j=0;j<w;j++)ans+=dp[h][j];\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nint m[500][500];\nint dp[500][500];\n\nint dx[]={-1,0,1};\n\nint solve(int r,int c){\n  rep(i,r+2)rep(j,c)dp[i][j]=0;\n  rep(j,c)if(m[0][j] == 2 || m[0][j] == 0)dp[0][j]=1;\n\n  rep(i,r){\n    rep(j,c){\n      if (m[i][j] == 0 && i != r-1){\n\trep(k,3){\n\t  int nex = j+dx[k];\n\t  if (nex<0||nex>=c)continue;\n\t  if (m[i+1][nex] == 0)dp[i+1][nex]+=dp[i][j];\n\t  else if (m[i+1][nex] == 2 && k == 1)dp[i+1][nex]+=dp[i][j];\n\t}\n      }else if (m[i][j] == 2 ){\n\tdp[i+2][j]+=dp[i][j];\n      }\n    }\n  }\n  \n  int ans = 0;\n  rep(j,c)ans+=dp[r][j]+dp[r-1][j]+dp[r+1][j];\n  return ans;\n}\n\nmain(){\n  int c,r;\n  while(cin>>c>>r && r){\n    rep(i,r)rep(j,c)cin>>m[i][j];\n    rep(j,c)m[r][j]=m[r+1][j]=0;\n    cout << solve(r,c) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <set>\n#include <map>\n#include <list>\n#include <iterator>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <string>\n#include <cmath>\n#include <complex>\n#include <functional>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n#include <cstdlib>\n#include <cctype>\n#include <bitset>\n\n#define REP(i,m,n) for(int i=m;i<(int)n;i++)\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define rrep(i,n) for(int i = 1; i <= n; i++)\n#define drep(i,n) for(int i = n; i >= 0; i--)\n#define rp(i,c) rep(i,(int)c.size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define mp make_pair\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define v_delete(a,b) (a).erase(remove((a).begin(), (a).end(), b), (a).end())\n#define v_unique(a) (a).erase(unique((a).begin(), (a).end()), (a).end())\n#define VV(T) vector<vector< T > >\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\nconst int inf=1<<28;\nconst double INF=1e10,EPS=1e-9;\n\n\ntemplate<class T>int SIZE(T a){return a.size();}\ntemplate<class T>string IntToString(T num){string res;stringstream ss;ss<<num;return ss.str();}\ntemplate<class T>T StringToInt(string str){T res=0;for(int i=0;i<SIZE(str);i++)res=(res*10+str[i]-'0');return res;}\ntemplate<class T>T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate<class T>T lcm(T a,T b){return a/gcd(a,b)*b;}\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nint chmax(int& a,int b){\n\tif(b > a){\n\t\ta=b;\n\t}\n\treturn a;\n}\nint chmin(int& a,int b){\n\tif(b < a){\n\t\ta=b;\n\t}\n\treturn a;\n}\n\nint X,Y;\nint m[18][18];\nint dp[20][20];\n\n\nint main(int argc, char const *argv[])\n{\n\twhile(cin >> X >> Y, X){\n\t\tmemset(m, -1 ,sizeof(m));\n\t\tmemset(dp, 0 ,sizeof(m));\n\t\trep(i,Y){\n\t\t\trep(j,X){\n\t\t\t\tcin >> m[i+1][j+1];\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=X;i++){\n\t\t\tif(m[1][i])\n\t\t\t\tdp[1][i]=0;\n\t\t\telse\n\t\t\t\tdp[1][i]=1;\n\t\t}\n\t\tfor(int i=2;i<=Y;i++){\n\t\t\tfor(int j=1;j<=X;j++){\n\t\t\t\tif(m[i][j]==1){\n\t\t\t\t\tdp[i][j]=0;\n\t\t\t\t}else if(m[i][j]== 2){\n\t\t\t\t\tif(m[i-1][j]==0)\n\t\t\t\t\t\tdp[i][j] += dp[i-1][j];\n\t\t\t\t\tif(m[i-2][j]==2)\n\t\t\t\t\t\tdp[i][j] += dp[i-2][j];\n\t\t\t\t}else{\n\t\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\t\tif(m[i-1][j+k]==0){\n\t\t\t\t\t\t\tdp[i][j] += dp[i-1][j+k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(m[i-2][j]==2)\n\t\t\t\t\t\tdp[i][j] += dp[i-2][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t//\tfor(int i=1;i<=Y;i++){\n\t//\t\tfor(int j=1;j<=X;j++){\n\t//\t\t\tcout << dp[i][j] << \" \";\n\t//\t\t}\n\t//\t\tcout << endl;\n\t//\t}\n\n\t\tfor(int i=1;i<=X;i++){\n\t\t\tif(m[Y][i]==0){\n\t\t\t\tans += dp[Y][i];\n\t\t\t}\n\t\t\tif(m[Y-1][i]==2){\n\t\t\t\tans += dp[Y-1][i];\n\t\t\t}\n\t\t}\n\t\tcout  << ans << endl;\n\n\t}\n\n\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint dy[] = { 1, 1, 1};\nint dx[] = { -1, 0, 1 };\n\nint main() {\n    while (1) {\n        int dp[17][15] = { 0 };\n        int field[15][15] = { 0 };\n        int h, w;\n\n        cin >> w >> h;\n        if (w == 0) {\n            break;\n        }\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                cin >> field[i][j];\n            }\n        }\n        \n        for (int j = 0; j < w; j++) {\n            if (field[0][j] != 1) {\n                dp[0][j] = 1;\n            }\n        }\n        \n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                if (dp[i][j] > 0) {\n                    if (i == h - 1) {\n                        dp[i + 1][j] = dp[i][j];\n                        continue;\n                    }\n                    if (field[i][j] == 2) {\n                        if (field[i + 2][j] != 1) {\n                            dp[i + 2][j] += dp[i][j];\n                        }\n                        continue;\n                    }\n                    for (int k = 0; k < 3; k++) {\n                        int nx = j + dx[k];\n                        int ny = i + dy[k];\n                        if (nx < 0 || nx >= w) {\n                            continue;\n                        }\n                        if (field[ny][nx] == 0 || (field[ny][nx] == 2 && k == 1)) {\n                            dp[ny][nx] += dp[i][j];\n                        }\n                    }\n                }\n            }\n        }\n        \n        int ans = 0;\n        for (int i = h; i <= h + 1; i++) {\n            for (int j = 0; j < w; j++) {\n                ans += dp[i][j];\n            }\n        }\n        cout << ans << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\nint a[16][16];\nint count = 0;\nint n,m;\n\nvoid dfs(int y,int x)\n{\n\tif(a[y][x] == 0)\n\t{\n\t\tif(y == m-1)\n\t\t{\n\t\t\tcount++;\n\t\t\treturn;\n\t\t}\n\t\tif(x-1 >= 0 && y+1 < m)\n\t\t{\n\t\t\tif(a[y+1][x-1] != 2)\n\t\t\t{\n\t\t\t\tdfs(y+1,x-1);\n\t\t\t}\n\t\t}\n\t\tif(y+1 < m)\n\t\t{\n\t\t\tdfs(y+1,x);\n\t\t}\n\t\tif(x+1 < n && y+1 < m)\n\t\t{\n\t\t\tif(a[y+1][x+1] != 2)\n\t\t\t{\n\t\t\t\tdfs(y+1,x+1);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\telse if(a[y][x] == 1)\n\t{\n\t\treturn;\n\t}\n\telse if(a[y][x] == 2)\n\t{\n\t\tif(y == m-2 || y == m-1)\n\t\t{\n\t\t\tcount++;\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdfs(y+2,x);\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile(cin >> n >> m)\n\t{\n\t\tif(n == 0 && m == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tmemset(a,0,sizeof(a));\n\t\trep(i,n)\n\t\t{\n\t\t\trep(j,m)\n\t\t\t{\n\t\t\t\tcin >> a[i][j];\n\t\t\t}\n\t\t}\n\t\tcount = 0;\n\t\trep(i,m) dfs(0,i);\n\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n \n#define rep(i,n) for(int i = 1; i <= n; i++)\n \n#define MS   (15)\n#define CM   (0)\n#define TREE (1)\n#define JUMP (2)\n \nusing namespace std;\n \nint x, y;\nint map[MS+1][MS+1];\nint dp[MS+1][MS+1];\n \nvoid check()\n{\n        rep(i,y-1) rep(j,x){\n                if(map[i][j] == CM){\n                        if(map[i+1][j] != TREE)  { dp[i+1][j]  +=dp[i][j]; }\n                        if((j+1)<=x){\n                                if(map[i+1][j+1]==CM){ dp[i+1][j+1]+=dp[i][j]; }\n                        }\n                        if((j-1)>=1){\n                                if(map[i+1][j-1]==CM){ dp[i+1][j-1]+=dp[i][j]; }\n                        }\n                }\n                if(map[i][j] == JUMP){\n                        if(i+2 > y){\n                                dp[y][j] += dp[i][j];\n                        }\n                        else if(map[i+2][j] != TREE){\n                                dp[i+2][j]+=dp[i][j];\n                        }\n                }\n        }\n \n}\n \nint main(void)\n{\n \n        while(cin >> x >> y && x){\n                rep(i,y) rep(j,x){\n                        cin >> map[i][j];\n                }\n \n                memset(dp, 0, sizeof(dp));\n                \n                rep(i,x)\n                        if(map[1][i] != TREE){ dp[1][i]++; }\n                \n                check();\n                \n                int sum=0;\n                \n                rep(i,x){ sum += dp[y][i]; }\n                \n                cout << sum << endl;\n                \n        }\n \n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nenum class State {\n\tEmpty, Tree, Jump\n};\nclass Ski_run {\npublic:\n\tSki_run(const int &x, const int &y) :width(x), height(y), state(y, std::vector<State>(x, State::Empty)), route(y + 1, std::vector<int>(x, 0)), null(0), res(-1) {\n\t\tfor (auto &line : state) {\n\t\t\tfor (auto &c : line) {\n\t\t\t\tint a;\n\t\t\t\tstd::cin >> a;\n\t\t\t\tc = static_cast<State>(a);\n\t\t\t}\n\t\t}\n\t\tstate.push_back(std::vector<State>(width, State::Empty));\n\t\tstate.push_back(std::vector<State>(width, State::Empty));\n\t\troute.at(height) = std::vector<int>(x, 1);\n\t\troute.at(height - 1) = std::vector<int>(x, 1);\n\t}\n\tvoid show() const {\n\t\tfor (const auto &l : route) {\n\t\t\tfor (const auto &c : l) {\n\t\t\t\tstd::cout << c;\n\t\t\t}\n\t\t\tstd::cout << '\\n';\n\t\t}\n\t}\n\tint solve() {\n\t\tif (res >= 0) {\n\t\t\treturn res;\n\t\t}\n\t\telse {\n\t\t\tfor (auto y = height - 2; y >= 0; --y) {\n\t\t\t\tfor (auto x = 0; x < width; ++x) {\n\t\t\t\t\tswitch (state.at(y).at(x)) {\n\t\t\t\t\tcase State::Empty:\n\t\t\t\t\t\tif (at(x - 1, y + 1) == State::Empty) {\n\t\t\t\t\t\t\troute.at(y).at(x) += route.at(y + 1).at(x - 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (at(x + 1, y + 1) == State::Empty) {\n\t\t\t\t\t\t\troute.at(y).at(x) += route.at(y + 1).at(x + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!(at(x, y + 1) == State::Tree)) { \n\t\t\t\t\t\t\troute.at(y).at(x) += route.at(y + 1).at(x);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase State::Jump:\n\t\t\t\t\t\tif (!(at(x, y + 2) == State::Tree)) {\n\t\t\t\t\t\t\troute.at(y).at(x) += route.at(y + 2).at(x);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = 0;\n\t\t\tfor (const auto &l : route.at(0)) {\n\t\t\t\tres += l;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t}\nprivate:\n\tState at(const int &x, const int &y) {\n\t\tif (x >= 0 && width > x) {\n\t\t\treturn state.at(y).at(x);\n\t\t}\n\t\telse {\n\t\t\treturn State::Tree;\n\t\t}\n\t}\n\tint width, height;\n\tstd::vector<std::vector<int>> route;\n\tstd::vector<std::vector<State>> state;\n\tint null, res;\n};\nint main() {\n\tint x, y;\n\tstd::cin >> x >> y;\n\twhile (x != 0 || y != 0) {\n\t\tSki_run state(x, y);\n\t\tstd::cout << state.solve() << std::endl;\n\t\tstd::cin >> x >> y;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n//#include\nusing namespace std;\n\nstruct P{\n\tint way;\n\tint stt;\n};\n\n//グローバルは土俵F、と配列ans\n\nP F[17][17];\n//はじめにF.wayを-1で初期化 端っこ.sttを1で初期化\n\nlong ans[1000]={0};\nint counter=0,flag=0;\n\nint solve(int x,int y);\n\nint jump(int x,int y){\n\tif(F[x][y-2].stt==2)\n\t\treturn (F[x][y-2].way==-1) ? solve(x,y-2) : F[x][y-2].way;\n\telse return 0;\n}\n\nint left(int x,int y){\n\tif(F[x-1][y-1].stt==0) \n\t\treturn (F[x-1][y-1].way==-1) ? solve(x-1,y-1) : F[x-1][y-1].way;\n\telse return 0;\n}\n\nint right(int x,int y){\n\tif(F[x+1][y-1].stt==0) \n\t\treturn (F[x+1][y-1].way==-1) ? solve(x+1,y-1) : F[x+1][y-1].way;\n\telse return 0;\n}\n\nint samex(int x,int y){\n\tif(F[x][y-1].stt==0) \n\t\treturn (F[x][y-1].way==-1) ? solve(x,y-1) : F[x][y-1].way;\n\telse return 0;\n}\n\nint solve(int x,int y){//入力した座標までのコース数を返す 0は普通 1は障害物 2はジャンプ台\n\tif (y==1) return 1;\n\tif (F[x][y].stt==0)\n\treturn jump(x,y)+left(x,y)+right(x,y)+samex(x,y);\n\tif (F[x][y].stt==2)\n\treturn jump(x,y)+samex(x,y);\n\tif (F[x][y].stt==1)\n\treturn 0;\n\treturn 0;\n}\n\n//int solve_ex(int x,int y){//最後JUMP通過のとき jumpをそのまま使う\n\n\nvoid solver(){\n\tint X,Y;\n\tcin >> X >> Y;\n\tif(X==0) {flag=1;return;}\n\t\n\t\n\tfor(int i=0;i<17;i++){\n\t\tfor(int j=0;j<17;j++){\n\t\t\tF[i][j].way=-1;\n\t\t\tF[i][j].stt=1;\n\t\t}\n\t}\n\t\n\tfor(int i=1;i<=Y;i++){\n\t\tfor(int j=1;j<=X;j++){\n\t\t\tcin >> F[j][i].stt;\n\t\t}\n\t}\n\t\n\tfor(int x=1;x<=X;x++){\n\t\tans[counter]+=(solve(x,Y)+jump(x,Y+1));\n\t}\n\tcounter++;\n}\n\nint main(){\n\twhile(flag==0){\n\t\tsolver();\n\t}\n\t\n\tfor(int i=0;i<counter;i++){\n\t\tcout << ans[i]<<\"\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\n#include <iomanip>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nint main()\n{\n\tint X, Y;\n\twhile(cin >> X >> Y && X)\n\t{\n\t\tvector<vint> field(Y, vint(X, 0)), dp(Y, vint(X, 0));\n\t\trep(y, Y) rep(x, X)\n\t\t\tcin >> field[y][x];\n\n\t\trep(x, X)\n\t\t\tdp[0][x] = !field[0][x];\n\n\t\tREP(y, 1, Y) rep(x, X)\n\t\t{\n\t\t\tif(field[y][x] == 1) continue;\n\n\t\t\tif(1 < y && field[y - 2][x] == 2) dp[y][x] = dp[y - 2][x];\n\n\t\t\tif(field[y][x] == 0)\n\t\t\t{\n\t\t\t\tint dx[] = {-1, 0, 1};\n\t\t\t\trep(i, 3)\n\t\t\t\t{\n\t\t\t\t\tint nx = x + dx[i];\n\t\t\t\t\tif(0 <= nx && nx < X && field[y - 1][nx] != 2)\n\t\t\t\t\t\tdp[y][x] += dp[y - 1][nx];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdp[y][x] += dp[y - 1][x];\n\t\t\t}\n\t\t}\n\n\t\tint res = accumulate(ALL(dp[Y-1]), 0);\n\t\trep(x, X)\n\t\t\tres += field[Y-2][x] == 2 ? dp[Y-2][x] : 0;\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint X,Y;\nint dp[20][20];\nchar maps[20][20];\nint bun(int x,int y);\nint dx[3]={-1,0,1};\nmain(){\n  while(1){\n    cin>>X>>Y;\n    if(X==0&&Y==0){\n      break;\n    }\n    for(int i=1;i<=Y;i++){\n      for(int j=1;j<=X;j++){\n\tcin>>maps[i][j];\n\tdp[i][j]=0;\n      }\n    }\n    int ans=0;\n    for(int i=1;i<=X;i++){\n      if(maps[1][i]!='1'){\n\tans+=bun(1,i);\n      }\n    }\n    cout<<ans<<endl;\n  }\n}\nint bun(int y,int x){\n  if(y>=Y+1){\n    return 1;\n  }\n  else if(dp[y][x]!=0){\n    return dp[y][x];\n  }\n  else if(maps[y][x]=='2'&&(y+2>=Y+1||maps[y+2][x]!='1')){\n    return bun(y+2,x);\n  }\n  else{\n    int anss=0;\n    for(int i=0;i<3;i++){\n      int nx=x+dx[i];\n      if(i!=1){\n\tif(nx>0&&nx<=X&&maps[y+1][nx]=='0'){\n\t  anss+=bun(y+1,nx);\n\t}\n      }\n      else{\n\tif(maps[y][nx]=='2'&&(y+2>=Y+1||maps[y+2][nx]!='1')){\n\t  anss+=bun(y+2,nx);\n\t}\n\telse if(maps[y+1][nx]!='1'){\n\t  anss+=bun(y+1,nx);\n\t}\n      }\n    }\n    return dp[y][x]=anss;\n  }\t  \t  \n}"
  },
  {
    "language": "C++",
    "code": "5 5\n0 0 0 0 1\n2 1 0 2 0\n1 0 0 1 1\n0 2 1 2 0\n0 1 0 0 0\n5 5\n0 0 1 0 0\n2 1 0 2 0\n1 0 0 1 1\n0 2 1 2 0\n0 1 0 0 0\n15 15\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\nint main(){\n\tint x,y;\n\twhile(cin >> x >> y, x|y){\n\t\tvvi field(y,vi(x));\n\t\tREP(i,y){\n\t\t\tREP(j,x){\n\t\t\t\tcin >> field[i][j];\n\t\t\t}\n\t\t}\n\t\tvvi dp(y,vi(x,0));\n\t\tREP(i,y){\n\t\t\tREP(j,x){\n\t\t\t\tif(i==0&&field[i][j]==0){\n\t\t\t\t\tdp[i][j]=1;\n\t\t\t\t}\n\t\t\t\tif(i<y-1&&field[i][j]==0){\n\t\t\t\t\tif(j>0&&field[i+1][j-1]==0){\n\t\t\t\t\t\tdp[i+1][j-1]+=dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tif(j<x-1&&field[i+1][j+1]==0){\n\t\t\t\t\t\tdp[i+1][j+1]+=dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tif(field[i+1][j]!=1){\n\t\t\t\t\t\tdp[i+1][j]+=dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(i<y-2&&field[i][j]==2){\n\t\t\t\t\tif(field[i+2][j]!=1){\n\t\t\t\t\t\tdp[i+2][j]+=dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint result=0;\n\t\tREP(i,x){\n\t\t\tresult+=dp[y-1][i];\n\t\t\tif(y>=2&&field[y-2][i]==2){\n\t\t\t\tresult+=dp[y-2][i];\n\t\t\t}\n\t\t}\n\t\tcout << result << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main(){\n\tint w,h;\n\n\twhile( cin >> w >> h , w||h ){\n\t\tint f[20][20] = {0};\n\t\tfor(int y=1 ; y <= h ; y++ ){\n\t\t\tfor(int x=1 ; x <= w ; x++ ){\n\t\t\t\tcin >> f[y][x];\n\t\t\t}\n\t\t}\n\n\t\tint dp[20][20] = {0};\n\t\tfor(int x=1 ; x <= w ; x++ )\n\t\t\tdp[1][x] = 1;\n\t\tfor(int y=1 ; y <= h-1 ; y++ ){\n\t\t\tfor(int x=1 ; x <= w ; x++ ){\n\t\t\t\tif( f[y][x] == 0 ){\n\t\t\t\t\tif( f[y+1][x-1] == 0 ) dp[y+1][x-1] += dp[y][x];\n\t\t\t\t\tif( f[y+1][x]   == 0 ) dp[y+1][x]   += dp[y][x];\n\t\t\t\t\tif( f[y+1][x+1] == 0 ) dp[y+1][x+1] += dp[y][x];\n\t\t\t\t\tif( f[y+1][x]   == 2 ) dp[y+1][x]   += dp[y][x];\n\t\t\t\t}else if( f[y][x] == 2 ){\n\t\t\t\t\tif( f[y+2][x] == 0 ) dp[y+2][x] += dp[y][x];\n\t\t\t\t\tif( f[y+2][x] == 2 ) dp[y+2][x] += dp[y][x];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int x=1 ; x <= w ; x++ ){\n\t\t\tans += dp[h][x] + dp[h+1][x];\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define N 20\nusing namespace std;\nvoid func(int,int);\nint jump(int,int);\nint X,Y,data[N][N],memo[N][N];\nint main(){\n  while(1){\n    cin >> X >> Y;\n    if(X==0&&Y==0) break;\n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++) data[i][j]=0,memo[i][j]=0;\n    for(int i=0;i<Y;i++)\n      for(int j=0;j<X;j++) cin >> data[i][j];\n    for(int i=0;i<X;i++)\n      if(data[0][i]!=1) func(0,i);\n    int cnt=0;\n    for(int i=0;i<X;i++) cnt+=memo[0][i];\n    cout << cnt << endl;\n  }\n  return 0;\n}\nvoid func(int y,int x){\n  if(y>=Y-1){\n    memo[y][x]=memo[Y][x]=memo[Y-1][x]=1;\n    return ;\n  }\n  if(0<=x-1&&data[y+1][x-1]==0){\n    if(memo[y+1][x-1]==0) func(y+1,x-1);\n    memo[y][x]+=memo[y+1][x-1];\n  }\n  if(x+1<X&&data[y+1][x+1]==0){\n    if(memo[y+1][x+1]==0) func(y+1,x+1);\n    memo[y][x]+=memo[y+1][x+1];\n  }\n  if(data[y+1][x]==0){\n    if(memo[y+1][x]==0) func(y+1,x);\n    memo[y][x]+=memo[y+1][x];\n  }\n  if(data[y+1][x]==2){\n    int r=jump(y+1,x);\n    if(r!=-1){\n      if(memo[r][x]==0) func(r,x);\n      memo[y][x]+=memo[r][x];\n    }else data[y+1][x]=1;\n  }\n  if(memo[y][x]==0) data[y][x]=1;\n}\nint jump(int y,int x){\n  while(1){\n    y+=2;\n    if(data[y][x]==1) break;\n    if(data[y][x]==0||y>=Y-1) return y;\n  }\n  return -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n\nint main(){\n\tint map[15][15];\n\tint ans_map[15][15];\n\t\n\tint x,y;\n\twhile(cin>>x>>y,x){\n\t\tlong int ans=0;\n\t\tfor(int i=0;i<y;i++){\n\t\t\tfor(int j=0;j<x;j++){\n\t\t\t\tcin>>map[i][j];\n\t\t\t\tans_map[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<x;i++){\n\t\t\tans_map[y][i]=0;\n\t\t}\n\t\tfor(int i=0;i<x;i++){\n\t\t\tif(map[0][i]==0){\n\t\t\t\tans_map[0][i]=1;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i+1<y;i++){\n\t\t\tfor(int j=0;j<x;j++){\n\t\t\t\tif(map[i][j]==2){\n\t\t\t\t\tans_map[i+2][j]+=ans_map[i][j];\n\t\t\t\t\tans_map[i][j]=0;\n\t\t\t\t}else if(map[i][j]==1){\n\t\t\t\t\tans_map[i][j]=0;\n\t\t\t\t}else{ \n\t\t\t\t\tfor(int k=-1;k<2;k++){\n\t\t\t\t\t\tif((j+k<0)||(j+k>x-1)){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(map[i+1][j+k]==0){\n\t\t\t\t\t\t\t\tans_map[i+1][j+k]+=ans_map[i][j];\n\t\t\t\t\t\t\t}else if((k==0)&&(map[i+1][j+k]==2)){\n\t\t\t\t\t\t\t\tans_map[i+1][j+k]+=ans_map[i][j];\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<x;i++){\n\t\t\tans_map[y][i]+=ans_map[y-1][i];\n\t\t}\n\t\t\n\t\tfor(int i=0;i<x;i++){\n\t\t\tans+=ans_map[y][i];\n\t\t}\n\t\tcout<<ans<<endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nclass point {\npublic:\n\tlong long num;\n\tint block;\n\tpoint() :num(0), block(1) {}\n};\nint main() {\n\tint X, Y;\n\twhile (cin >> X >> Y&&X != 0) {\n\t\tvector<vector<point> > map(X + 2, vector<point>(Y + 2));\n\t\tfor (int y = 1; y <= Y; ++y) {\n\t\t\tfor (int x = 1; x <= X; ++x) {\n\t\t\t\tcin >> map[x][y].block;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= X; ++i) {\n\t\t\tmap[i][1].num = 1;\n\t\t}\n\t\tfor (int y = 1; y < Y; ++y) {\n\t\t\tfor (int x = 1; x <= X; ++x) {\n\t\t\t\tif (map[x][y].block == 0) {\n\t\t\t\t\tfor (int k = -1; k <= 1; ++k) {\n\t\t\t\t\t\tif (map[x + k][y + 1].block == 0 || (map[x + k][y + 1].block == 2 && k == 0) ) {\n\t\t\t\t\t\t\tmap[x + k][y + 1].num += map[x][y].num;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (map[x][y].block == 2) {\n\t\t\t\t\tmap[x][min(Y, y + 2)].num += map[x][y].num;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong long ans = 0;\n\t\tfor (int i = 1; i <= X; ++i) {\n\t\t\tans += map[i][Y].num;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<numeric>\nusing namespace std;\n\nint main() {\n\tint x, y;\n\twhile (cin >> x >> y ,x,y) {\n\t\tvector<vector<int>> course(y + 2, vector<int>(x + 2, 0));\n\t\tfor (int i = 1; i <= y; i++) {\n\t\t\tfor (int j = 1; j <= x; j++) {\n\t\t\t\tcin >> course[i][j];\n\t\t\t}\n\t\t}\n\n\t\tvector<vector<int>> path(y + 2, vector<int>(x + 2, 0));\n\t\t//?????????????????????????????????1????????????\n\t\tfor (int i = 1; i <= x; i++) {\n\t\t\tif (course[1][i] != 1) path[1][i] = 1;\n\t\t}\n\n\t\tfor (int i = 1; i <= y; i++) {\n\t\t\tfor (int j = 1; j <= x; j++) {\n\t\t\t\t//????????????????????´????????????????????´??????????????????????????????????????????\n\t\t\t\t//?????????????§????????????????????????´?????????????????????????????£????????°?????´????????????????????????\n\t\t\t\tif (course[i][j] == 0) {\n\t\t\t\t\tif (course[i + 1][j + 1] == 0) path[i + 1][j + 1] += path[i][j];\n\t\t\t\t\tif (course[i + 1][j] != 1) path[i + 1][j] += path[i][j];\n\t\t\t\t\tif (course[i + 1][j - 1] == 0) path[i + 1][j - 1] += path[i][j];\n\t\t\t\t}\n\t\t\t\t//?¬???????????????´???????????£????????°????????????????????????????????????\n\t\t\t\t//?????????????????£????????§??´??????????????´???????????????(?????£?????????????????????????????´???????????????)\n\t\t\t\tif (course[i][j] == 2 && course[i + 2][j] != 1) {\n\t\t\t\t\tpath[i + 2][j] += path[i][j];\n\t\t\t\t\tif (i + 2 > y && i != y) path[y][j] += path[i][j];\n\t\t\t\t}\n\t\t\t\t//???????????´???????????????????????????????????????\n\t\t\t\tif (course[i][j] == 1) {/*do anything*/ }\n\t\t\t}\n\t\t}\n\n\t\tcout << accumulate(path[y].begin() + 1, path[y].end() - 1, 0) << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n\n#define reep(i,n,m) for(int i=(n);i<(m);i++)\n#define rep(i,n) reep(i,0,n)\n\nusing namespace std;\n\nint main(){\n    int X,Y;\n    while(cin >> X >> Y,X+Y){\n        int fld[20][20] = {0};\n        rep(y,Y){\n            rep(x,X){\n                cin >> fld[y][x];\n            }\n        }\n\n        int dp[20][20] = {0};\n        rep(x,X){\n            dp[0][x] = 1;\n        }\n\n        rep(y,Y){\n            rep(x,X){\n                int val = dp[y][x];\n                if(fld[y][x] == 0){\n                    if(y==Y-1)\n                        continue;\n                    if(x>0 && fld[y+1][x-1] != 2){\n                        dp[y+1][x-1] += val;\n                    }\n                    if(fld[y+1][x+1] != 2){\n                        dp[y+1][x+1] += val;\n                    }\n                    dp[y+1][x] += val;\n                }else if(fld[y][x] == 2){\n                    dp[y+2][x] += val;\n                }\n            }\n        }\n\n        int ans = 0;\n        rep(i,2){\n            rep(x,X){\n                if(fld[Y+i-1][x] == 0)\n                    ans += dp[Y+i-1][x];\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nint main() {\n    int h, w;\n    while(cin >> w >> h, w){\n        vector<vector<int>> G(h+2, vector<int>(w+2, 1));\n        for (int i = 0; i < h; ++i) {\n            for (int j = 0; j < w; ++j) {\n                cin >> G[i+1][j+1];\n            }\n        }\n        vector<vector<int>> dp(h+2, vector<int>(w+2, 0));\n        for (int i = 0; i < w; ++i) {\n            if(G[1][i+1] != 1) dp[1][i+1] = 1;\n        }\n        int ans = 0;\n        for (int i = 1; i <= h; ++i) {\n            for (int j = 1; j <= w; ++j) {\n                if(i == h) ans += dp[i][j];\n                else if(G[i][j] == 0){\n                    for (int k = -1; k <= 1; ++k) {\n                        if(G[i+1][j+k] == 0) dp[i+1][j+k] += dp[i][j];\n                        else if(G[i+1][j+k] == 2 && !k) dp[i+1][j] += dp[i][j];\n                    }\n                }else if(G[i][j] == 2){\n                    if(i >= h-1) ans += dp[i][j];\n                    else if(G[i+2][j] != 1) dp[i+2][j] += dp[i][j];\n                }\n            }\n        }\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nconst int MAX = 15;\nconst int dx[] = {-1, 0, 1};\nint X, Y;\nint c[MAX + 2][MAX + 2], dp[MAX + 2][MAX + 2];\n\nint main()\n{\n    while(cin >> X >> Y && X) {\n        for(int i = 1; i <= Y; i++)\n            for(int j = 1; j <= X; j++)\n                cin >> c[i][j];\n\n        memset(dp, 0, sizeof(dp));\n        for(int j = 1; j <= X; j++) \n            dp[1][j] = (c[1][j] == 0) ? 1 : 0;\n        \n        for(int i = 2; i <= Y; i++) {\n            for(int j = 1; j <= X; j++) {\n                if(c[i][j] == 0) {\n                    for(int k = 0; k < 3; k++)\n                        if(c[i - 1][j + dx[k]] == 0)\n                            dp[i][j] += dp[i - 1][j + dx[k]];\n                } else if(c[i][j] == 1) {\n                    dp[i][j] = 0;\n                } else {\n                    dp[i][j] += dp[i - 1][j];\n                    dp[i + 2][j] = dp[i][j];\n                }\n            }\n        }\n        \n        int ans = 0;\n        for(int j = 1; j <= X; j++) \n            ans += dp[Y + 1][j] + dp[Y][j];\n\n        cout << ans << endl;\n        \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint main() {\n\tint width, height, m[15][15];\n\twhile (cin >> width >> height, width && height) {\n\t\tfor (int y = 0; y < height; ++y)\n\t\t\tfor (int x = 0; x < width; ++x)\n\t\t\t\tcin >> m[y][x];\n\n\t\tint sum = 0, pattern[15][15] = {0};\n\t\tfor (int x = 0; x < width; ++x)\n\t\t\tpattern[0][x] = 1;\n\n\t\tfor (int y = 0; y < height-1; ++y)\n\t\t\tfor (int x = 0; x < width; ++x)\n\t\t\t\tif (m[y][x] == 0) {\n\t\t\t\t\tif (x - 1 >= 0 && m[y+1][x-1] == 0) pattern[y+1][x-1] += pattern[y][x];\n\t\t\t\t\tif (x + 1 < width && m[y+1][x+1] == 0) pattern[y+1][x+1] += pattern[y][x];\n\t\t\t\t\tif (m[y+1][x] != 1) pattern[y+1][x] += pattern[y][x];\n\t\t\t\t}\n\t\t\t\telse if (m[y][x] == 2) {\n\t\t\t\t\tif (y + 2 == height) sum += pattern[y][x];\n\t\t\t\t\telse if (m[y+2][x] != 1) pattern[y+2][x] += pattern[y][x];\n\t\t\t\t}\n\n\t\tfor (int x = 0; x < width; ++x)\n\t\t\tsum += pattern[width-1][x];\n\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n\nint map[15][15],table[15][15],X,Y;\n\nint main(){\nwhile(1){\n\nscanf(\"%d%d\",&X,&Y);\nif(X==0&&Y==0) return 0;\nmemset(map,-1,sizeof(map));\nmemset(table,0,sizeof(table));\nfor(int i=0;i<Y;i++){\nfor(int j=0;j<X;j++){\nscanf(\"%d\",&map[i][j]);\nif(i==0&&map[i][j]==0) table[i][j]=1;\nelse if(i!=0&&map[i][j]!=1){\nif(j>0&&map[i-1][j-1]==0) table[i][j]+=table[i-1][j-1];\nif(j<X-1&&map[i-1][j+1]==0) table[i][j]+=table[i-1][j+1];\nif(map[i-1][j]==0)table[i][j]+=table[i-1][j];\nif(i>2&&map[i-2][j]==2) table[i][j]+=table[i-2][j]; \n} \n}\n}\nint sum=0;\nfor(int i=0;i<X;i++){\nsum+=table[Y-1][i];\n}\nprintf(\"%d\\n\",sum);\n\n\n\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,a,n) for(int i=a;i<n;i++)\n#define repb(i,a,b) for(int i=a;i>=b;i--)\n#define all(a) a.begin(),a.end()\n#define o(a) cout<<a<<endl\n#define int long long\n#define fi first\n#define se second\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n\n\nsigned main() {\n\tint y, x;\n\twhile (1) {\n\t\tcin >> y >> x;\n\t\tif (y + x == 0) break;\n\t\tint d[20][20];\n\t\trep(i, 0, 20) rep(j, 0, 20) d[i][j] = 1;\n\t\trep(i, 0, y) {\n\t\t\trep(j, 0, x) {\n\t\t\t\tcin >> d[i][j];\n\t\t\t}\n\t\t}\n\t\tint dp[20][20] = { 0 };\n\t\trep(i, 0, x) {\n\t\t\tif (d[0][i] == 0) dp[0][i] = 1;\n\t\t}\n\t\trep(i, 0, y) {\n\t\t\trep(j, 0, x) {\n\t\t\t\tif (d[i][j] == 2 && d[i + 2][j] != 1) {\n\t\t\t\t\tdp[i + 2][j] += dp[i][j];\n\t\t\t\t}\n\t\t\t\telse if (d[i][j] == 0) {\n\t\t\t\t\trep(k, -1, 2) {\n\t\t\t\t\t\tif (0 <= j + k && j + k < x && d[i + 1][j + k] == 0) {\n\t\t\t\t\t\t\tdp[i + 1][j + k] += dp[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (d[i + 1][j] == 2) {\n\t\t\t\t\t\tdp[i + 1][j] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*cout << endl;\n\t\trep(i, 0, y + 2) {\n\t\t\trep(j, 0, x) {\n\t\t\t\tcout << dp[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t\tint ans = 0;\n\t\trep(i, 0, x) {\n\t\t\tans += dp[y - 1][i];\n\t\t\tif (d[y - 2][i] == 2) {\n\t\t\t\tans += dp[y - 2][i];\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <math.h>\n#include <utility>\n#include <stack>\n#include <string.h>\nusing namespace std;\ntypedef pair<int,int> P;\nconst int INF = ~(1<<31) / 2;\n\nint field[15][15];\nint dp[15][15];\n\nint main(){\n    while(1){\n        int X,Y;\n        scanf(\"%d %d\",&X,&Y);\n        if(X==0)break;\n        for(int i=0;i<Y;i++){\n            for(int j=0;j<X;j++){\n                scanf(\"%d\",&field[i][j]);\n            }\n        }\n\n        for(int j=0;j<X;j++){\n            dp[Y-1][j] = field[Y-1][j] == 1 ? 0 : 1;\n        }\n\n        for(int i=Y-2;i>=0;i--){\n            for(int j=0;j<X;j++){\n                if(field[i][j]==1){\n                    dp[i][j] = 0;\n                }else if(field[i][j]==2){\n                    dp[i][j] = i+2<Y ? dp[i+2][j] : 1;\n                }else{\n                    dp[i][j] = 0;\n                    if(j-1>=0 && field[i+1][j-1]==0){\n                        dp[i][j] += dp[i+1][j-1];\n                    }\n                    if(j+1<X && field[i+1][j+1]==0){\n                        dp[i][j] += dp[i+1][j+1];\n                    }\n                    if(field[i+1][j]!=1){\n                        dp[i][j] += dp[i+1][j];\n                    }\n                }\n            }\n        }\n        int ans = 0;\n        for(int j=0;j<X;j++){\n            ans += dp[0][j];\n        }\n        printf(\"%d\\n\",ans);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <functional>\n#include <numeric>\n#define fi first\n#define se second\nusing namespace std;\nbool value(int y,int x,int R,int C){return 0<=y&&y<R&&0<=x&&x<C;}\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<long long > vll;\ntypedef vector< vi > vvi;\ndouble pie=acos(-1);\nint INF=10000009;\nint dx[4] = { 0,-1,0,1 };\nint dy[4] = { -1,0,1,0 };\nint c[20][20];\nlong long int dp[20][20];\nint main() {\n\tint X,Y;\n\twhile(true){\n\t\tlong long int ans=0;\n\t\tcin>>X>>Y;\n\t\tif(X+Y==0) break;\n\t\tfor(int i=1;i<=Y;i++){\n\t\t\tfor(int j=1;j<=X;j++){\n\t\t\t\tcin>>c[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=X;i++){\n\t\t\tif(c[1][i]==1){\n\t\t\t\tdp[1][i]=0;\n\t\t\t}\n\t\t\tif(c[1][i]==0){\n\t\t\t\tdp[1][i]=1;\n\t\t\t}\n\t\t\tif(c[1][i]==2){\n\t\t\t\tdp[1][i]=1;\n\t\t\t\tdp[3][i]=1;\n\t\t\t}\n\t\t}\n\t\tfor(int i=2;i<=Y;i++){\n\t\t\tfor(int j=1;j<=X;j++){\n\t\t\t\tif(c[i][j]==1) dp[i][j]=0;\n\t\t\t\telse if(c[i][j]==0){\n\t\t\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\t\t\tif(c[i-1][j-1+k]!=2){\n\t\t\t\t\t\t\tdp[i][j]+=dp[i-1][j-1+k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(c[i-1][j]!=2){\n\t\t\t\t\t\tdp[i][j]+=dp[i-1][j];\n\t\t\t\t\t}\n\t\t\t\t\tdp[i+2][j]+=dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=Y;i<=Y+2;i++){\n\t\t\tfor(int j=1;j<=X;j++){\n\t\t\t\tans+=dp[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=Y+2;i++){\n\t\t\tfor(int j=1;j<=X;j++){\n\t\t\t\tdp[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>  \n\nusing namespace std;\n\n#define FOR(i, j, k) for(int i = j; i < k; ++i)\n#define rep(i, j) FOR(i, 0, j)\n#define repr(i, j) for(int i = j; i >= 0; --i)\n#define INF (1 << 30)\n#define MOD 1e9 + 7\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\n\nint X, Y;\nint field[20][20];\nint dp[20][20];\n\nint main() {\n\twhile(scanf(\"%d %d\", &X, &Y), X || Y) {\n\t\trep(i, Y) rep(j, X) field[i][j] = 1;\n\t\trep(i, Y) rep(j, X) scanf(\"%d\", &field[i][j]);\n\t\tmemset(dp, 0, sizeof(dp));\n\t\trep(j, X) dp[0][j] = (field[0][j] == 0);\n\t\trep(i, Y - 1) rep(j, X) {\n\t\t\tif(field[i][j] == 0) {\n\t\t\t\tif(field[i + 1][j] != 1) dp[i + 1][j] += dp[i][j];\n\t\t\t\tif(j - 1 >= 0 && field[i + 1][j - 1] == 0) dp[i + 1][j - 1] += dp[i][j];\n\t\t\t\tif(j + 1 < X && field[i + 1][j + 1] == 0) dp[i + 1][j + 1] += dp[i][j];\n\t\t\t}\n\t\t\telse if(field[i][j] == 2) {\n\t\t\t\tdp[i + 2][j] += dp[i][j];\n\t\t\t}\n\t\t}\n\t\t/*rep(i, Y) {\n\t\t\trep(j, X) printf(\"%2d\", dp[i][j]);\n\t\t\tputs(\"\");\n\t\t}\n\t\trep(i, X) printf(\"%2d\", dp[Y][i]);\n\t\t*/\n\t\tint res = 0;\n\t\trep(i, X) if(field[Y - 1][i] != 1) res += dp[Y - 1][i];\n\t\trep(i, X) res += dp[Y][i];\n\t\tprintf(\"%d\\n\", res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint H,W,ans;\nint t[20][20];\nint u[20][20];\n\nbool inField(int x){\n  if(1<=x&&x<=W)return true;\n  return false;\n}\n\nint main(){\n  while(cin>>W>>H){\n    if(H==0&&W==0)break;\n    for(int i=0;i<20;i++)for(int j=0;j<20;j++)u[i][j]=0;\n    for(int i=1;i<=H;i++)for(int j=1;j<=W;j++)cin>>t[i][j];\n\n    for(int i=0;i<20;i++)u[1][i]=(t[1][i]==1?0:1);\n\n    for(int i=1;i<H;i++){\n      for(int j=1;j<=W;j++){\n\tif(t[i][j]==1)u[i][j]=0;\n\tif(u[i][j]==0)continue;\n\tif(t[i][j]==2){\n\t  u[i+2][j]+=u[i][j];\n\t  continue;\n\t}\n\tfor(int k=-1;k<=1;k++){\n\t  if(!inField(j+k))continue;\n\t  if(t[i+1][j+k]==0)u[i+1][j+k]+=u[i][j];\n\t  else if(t[i+1][j+k]==2&&k==0)u[i+1][j+k]+=u[i][j];\n\t}\n      }//j\n    }//i\n    ans=0;\n    for(int j=0;j<=W+1;j++){\n      ans+=u[H][j];\n      ans+=u[H+1][j];\n    }\n    \n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nint main(){\n\tint n,m;\n\tint masu[17][17];\n\tint ura[17][17];\n\t\n\twhile( cin>>m>>n, n != 0 && m != 0 ){\n\t\tfor(int i=0;i<17;i++){\n\t\t\tfor(int j=0;j<17;j++){\n\t\t\t\tmasu[i][j]=ura[i][j]=0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=1;j<=m;j++){\n\t\t\t\tcin>>masu[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tif(masu[0][j]!=1){\n\t\t\t\tura[0][j]=1;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tfor(int i=0;i<n-1;i++){\n\t\t\tfor(int j=1;j<=m;j++){\n\t\t\t\tif(masu[i][j]==0){\n\t\t\t\t\tif(masu[i+1][j-1]==0){\n\t\t\t\t\t\tura[i+1][j-1]+=ura[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tif(masu[i+1][j]!=1){\n\t\t\t\t\t\tura[i+1][j]+=ura[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tif(masu[i+1][j+1]==0){\n\t\t\t\t\t\tura[i+1][j+1]+=ura[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(masu[i][j]==2){\n\t\t\t\t\tif(masu[i+2][j]!=1){\n\t\t\t\t\t\tura[i+2][j]+=ura[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint cont=0;\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tcont+=ura[n][i]+ura[n-1][i];\n\t\t}\n\t\t\n\t\t/*\n\t\t\n\t\tfor(int i=0;i<17;i++){\n\t\t\tfor(int j=0;j<17;j++){\n\t\t\t\tprintf(\"%2d \",ura[i][j]);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}*/\n\t\tprintf(\"%d\\n\",cont);\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 10000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,string> P;\n\nstatic const double eps = 1e-8;\n\nconst int moveTo[][2] = {{-1,1},{0,1},{1,1}};\n\nint stage[17][17];\nint dp[17][17];\n\nint main(){\n\tint w,h;\n\twhile(~scanf(\"%d %d\",&w,&h)){\n\t\tif(w==h && h==0) break;\n\t\tmemset(stage,-1,sizeof(stage));\n\t\tmemset(dp,0,sizeof(dp));\n\t\tfor(int y=0;y<h;y++){\n\t\t\tfor(int x=0;x<w;x++){\n\t\t\t\tscanf(\"%d\",&stage[y][x]);\n\t\t\t}\n\t\t}\n\n\t\t//space:0 tree:1 jump:2\n\t\tfor(int x=0;x<w;x++){\n\t\t\tif(stage[0][x]!=1) dp[0][x] = 1;\n\t\t}\n\n\t\tfor(int dy=1;dy<=h;dy++){\n\t\t\tfor(int dx=0;dx<w;dx++){\n\t\t\t\tif(stage[dy][dx] != 1){\t\t\t\n\t\t\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\t\t\tint sx = dx - moveTo[j][0];\n\t\t\t\t\t\tint sy = dy - moveTo[j][1];\n\t\t\t\t\t\tif(sx < 0 || sx >= w || sy < 0 || sy >= h-1) continue;\n\n\t\t\t\t\t\t//space:0 tree:1 jump:2\n\t\t\t\t\t\tif(stage[sy][sx]!=0) continue;\n\t\t\t\t\t\tif(stage[dy][dx]==2 && dx != sx) continue;\n\n\t\t\t\t\t\tdp[dy][dx] += dp[sy][sx];\n\t\t\t\t\t}\n\n\t\t\t\t\tint sx = dx;\n\t\t\t\t\tint sy = dy-2;\n\t\t\t\t\tif(sx >=0 && sx < w && sy >= 0 && sy < h-1){\n\t\t\t\t\t\t//space:0 tree:1 jump:2\n\t\t\t\t\t\tif(stage[sy][sx] == 2){\n\t\t\t\t\t\t\tdp[dy][dx] += dp[sy][sx];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint res=0;\n\t\tfor(int y=h-1;y<=h;y++){\n\t\t\tfor(int x=0;x<w;x++){\n\t\t\t\tres += dp[y][x];\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",res);\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <math.h>\n#include <utility>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\n\nint main(){\n\twhile(true) {\n\t\tint x;\n\t\tint y;\n\t\tcin >> x >> y;\n\t\tif ( x == 0 ) break;\n\t\tint a[15][15] = {0};\n\t\tfor ( int i = 0; i < y ; i++ ) {\n\t\t\tfor ( int j = 0; j < x ; j++ ) {\n\t\t\t\tcin >> a[j][i];\n\t\t\t}\n\t\t}\n\t\tint b[15][15] = {0};\n\t\tfor ( int j = 0; j < x ; j++ ) {\n\t\t\tif ( a[j][y-1] != 1) b[j][y-1] = 1;\n\t\t}\n\t\tif ( y > 1 ) {\n\t\t\tfor ( int j = 0; j < x ; j++ ) {\n\t\t\t\tif ( a[j][y-2] == 2) b[j][y-2] = 1;\n\t\t\t}\n\t\t}\n\t\tfor ( int i = y - 1; i > 0; i-- ) {\n\t\t\tfor ( int j = 0; j < x ; j++ ) {\n\t\t\t\tif ( a[j][i] == 0 ) {\n\t\t\t\t\tfor ( int k = j - 1; k < j + 2; k++ ) {\n\t\t\t\t\t\tif ( k < 0 || k >= x ) continue;\n\t\t\t\t\t\tif ( a[k][i-1] == 0 ) {\n\t\t\t\t\t\t\tb[k][i-1] += b[j][i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( i > 1 ) {\n\t\t\t\t\t\tif ( a[j][i-2] == 2 ) b[j][i-2] += b[j][i];\n\t\t\t\t\t}\n\t\t\t\t}else if ( a[j][i] == 2 ) {\n\t\t\t\t\tif ( a[j][i-1] == 0 ) b[j][i-1] += b[j][i];\n\t\t\t\t\tif ( i > 1 ) {\n\t\t\t\t\t\tif ( a[j][i-2] == 2 ) b[j][i-2] += b[j][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint s = 0;\n\t\tfor ( int j = 0; j < x ; j++ ) {\n\t\t\ts += b[j][0];\n\t\t}\n\t\tcout << s << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint DP[17][17];\nint field[17][17];\nint x,y;\n\nint main(){\n\twhile(true){\n\t\tcin >> x >> y;\n\t\tif(!x && !y)\n\t\t\treturn 0;\n\t\t\n\t\tfor(int i=1; i<=y; i++)\n\t\t\tfor(int k=1; k<=x; k++)\n\t\t\t\tcin >> field[i][k];\n\t\tfor(int i=1; i<=x; i++)\n\t\t\tfield[y+1][i] = 0;\n\t\t\n\t\tfor(int i=1; i<=y+1; i++)\n\t\t\tfor(int k=0; k<=x+1; k++){\n\t\t\t\tDP[i][k]=0;\n\t\t\t\tif(i==1 && k>0 && k<=x)\n\t\t\t\t\tif(field[i][k] == 0)\n\t\t\t\t\t\tDP[i][k] = 1;\n\t\t\t}\n\t\t\n\t\tfor(int i=2; i<=y; i++){\n\t\t\tfor(int k=1; k<=x; k++){\n\t\t\t\tif(field[i][k] == 0)\n\t\t\t\t\tDP[i][k] += DP[i-1][k-1] + DP[i-1][k] + DP[i-1][k+1];\n\t\t\t\telse if(field[i][k] == 1)\n\t\t\t\t\tDP[i][k] = 0;\n\t\t\t\telse{\n\t\t\t\t\tDP[i][k] = 0;\n\t\t\t\t\tint n = i+2;\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\tif(field[n][k] == 0){\n\t\t\t\t\t\t\tDP[n][k] += DP[i-1][k];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else if(field[n][k] == 1)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tn+=2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans=0;\n\t\tfor(int i=y; i<=y+1; i++)\n\t\t\tfor(int k=1; k<=x; k++)\n\t\t\t\tans += DP[i][k];\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nint tt[20][20];\nint dp[20][20][20];\nint W,H;\n\nint rec(int x,int y,int px){\n\tif( x < 0 || x >= W ) return 0;\n\tif( tt[y][x] == 1 ) return 0;\n\tif( tt[y][x] == 2 && x != px ) return 0;\n\t\n\tif( y >= H-1 ) return 1;\n\t\n\t\n\tif( dp[x][y][px] != -1 ) return dp[x][y][px];\n\tint ans = 0;\n\tif( tt[y][x] == 2 ){\n\t\tans += rec(x,y+2,x);\n\t}else{\n\t\tans += rec(x,y+1,x);\n\t\tans += rec(x+1,y+1,x);\n\t\tans += rec(x-1,y+1,x);\n\t}\n\treturn dp[x][y][px] = ans;\n}\n\nint main(){\n\twhile(cin >> W >> H&&(W||H)){\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tfor(int i = 0 ; i < H ; i++){\n\t\t\tfor(int j = 0 ; j < W ; j++)\n\t\t\t\tcin >> tt[i][j];\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = 0 ; i < W ; i++){\n\t\t\tans += rec(i,0,0);\n\t\t}\n\t\tcout << ans << endl;\n\t\t//return 0;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint main(){\n\tint w,h,x,y;\n\tchar map[15][15];\n\tint dp[15][15];\n\tint ans;\n\t\n\twhile(cin>>w>>h,w!=0){\n\t\tfor(y=0;y<h;y++){\n\t\tfor(x=0;x<w;x++){\n\t\t\tcin>>map[x][y];\n\t\t\tdp[x][y]=0;\n\t\t}\n\t\t}\n\n\t\tfor(x=0;x<w;x++) if(map[x][0]!='1') dp[x][0]=1;\n\n\t\tfor(y=0;y<h-1;y++){\n\t\tfor(x=0;x<w;x++){\n\t\t\tif(map[x][y]=='0'){\n\t\t\t\tif(map[x][y+1]!='1') dp[x][y+1]+=dp[x][y];\n\t\t\t\tif(0<x && map[x-1][y+1]=='0') dp[x-1][y+1]+=dp[x][y];\n\t\t\t\tif(x<h-1 && map[x+1][y+1]=='0') dp[x+1][y+1]+=dp[x][y];\n\t\t\t}else if(map[x][y]=='2'){\n\t\t\t\tif(y<h-2 && map[x][y+2]!='1') dp[x][y+2]+=dp[x][y];\n\t\t\t}\n\t\t}\n\t\t}\n\t\t\n\t\tans=0;for(x=0;x<w;x++){\n\t\t\tif(map[x][h-2]=='2') ans+=dp[x][h-2];\n\t\t\tans+=dp[x][h-1];\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 0203\n#include<iostream>\n#include<cstring>\n\nint X, Y;\nint field[16][15];\nint dp[16][15];\n\nint main()\n{\n\twhile( std::cin >> X >> Y, X | Y )\n\t{\n\t\tmemset( field, 0, sizeof( field ) );\n\t\tmemset( dp, 0, sizeof( dp ) );\n\n\t\tfor( int i = 0; i != Y; ++i )\n\t\t\tfor( int j = 0; j != X; ++j )\n\t\t\t\tstd::cin >> field[i][j];\n\n\t\tfor( int i = 0; i != X; ++i )\n\t\t\tif( field[0][i] != 1 )\n\t\t\t\tdp[0][i] = 1;\n\t\t\n\t\tint ans = 0;\n\t\tfor( int i = 1; i <= Y; ++i )\n\t\t{\n\t\t\tfor( int j = 0; j != X; ++j )\n\t\t\t{\n\t\t\t\tif( i < Y && field[i][j] != 1 )\n\t\t\t\t{\n\t\t\t\t\tfor( int k = -1; k <= 1; ++k )\n\t\t\t\t\t{\t\n\t\t\t\t\t\tif( field[i][j] == 2 && k )\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tif( j + k >= 0 && j + k < X && !field[i-1][j+k] )\n\t\t\t\t\t\t\tdp[i][j] += dp[i-1][j+k];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif( i - 2 >= 0 && field[i][j] != 1 && field[i-2][j] == 2 )\n\t\t\t\t\tdp[i][j] += dp[i-2][j];\n\n\t\t\t\tif( i >= Y - 1 )\n\t\t\t\t\tans += dp[i][j];\n\t\t\t}\n\t\t}\n\n\t\tstd::cout << ans << std::endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main()\n{\n    while(1)\n    {\n        int x,y,ans=0;\n        int dp[17][17]={0};\n        int course[17][17]={0};\n        cin>>x>>y;if(!x)return 0;\n        for(int j=0;j<y;++j){\n            for(int i=0;i<x;++i){\n            \tcin>>course[i][j];\n            \tif(!course[i][0])dp[i][0]=1;\n            }\n        }\n        for(int j=0;j<y-1;++j){\n            for(int i=0;i<x;++i){\n                if(!course[i][j]){\n                    if(course[i][j+1]!=1)dp[i][j+1]+=dp[i][j];\n                    if(i){\n                        if(!course[i-1][j+1])dp[i-1][j+1]+=dp[i][j];\n                    }\n                    if(i<x){\n                        if(!course[i+1][j+1])dp[i+1][j+1]+=dp[i][j];\n                    }\n                }\n                if(course[i][j]==2){\n                    if(course[i][j+2]!=1)dp[i][j+2]+=dp[i][j];\n                }\n            }\n        }\n        for(int j=y-1;j<y+2;++j){\n            for(int i=0;i<x;++i){\n                ans+=dp[i][j];\n            }\n        }\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define F first\n#define S second\n#define INF 1 << 30\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint main(){\n  int X, Y;\n  while(scanf(\"%d%d\", &X, &Y) && X+Y){\n    int board[15][15], dp[17][15] = {};\n    rep(i, Y) rep(j, X) if(scanf(\"%d\", &board[i][j])  && board[i][j] == 1) dp[i][j] = -1;\n\n    rep(i, X) if(!dp[0][i]) dp[0][i] = 1;\n\n    rep(i, Y-1) rep(j, X){\n      if(board[i][j] == 1) continue;\n      else if(board[i][j] == 2) dp[i+2][j] += dp[i][j];\n      else{\n\tfor(int k = -1; k < 2; k++){\n\t  if(j+k < 0 || j+k >= X) continue;\n\t  if(dp[i+1][j+k] == -1) continue;\n\t  if(board[i+1][j+k] == 2){\n\t    if(k != 0) continue;\n\t    dp[i+1][j+k] += dp[i][j];\n\t  }else{\n\t    dp[i+1][j+k] += dp[i][j];\n\t  }\n\t}\n      }\n    }\n\n    ll res = 0;\n    REP(i, Y-1, Y+2)\n      rep(j, X)\n      if(dp[i][j] != -1)\n\tres += dp[i][j];\n  \n    /*    rep(i, 17){ \n      rep(j, 15) printf(\"%d \", dp[i][j]);\n      puts(\"\");\n      }*/\n\n    printf(\"%lld\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main()\n{\n\twhile(true){\n\t\tint X,Y;\n\t\tscanf(\"%d%d\",&X,&Y);\n\t\tif(X==0&&Y==0)return 0;\n\t\tint grid[17][16];\n\t\tint DP1[17][16];\n\t\tint DP2[17][16];\n\t\tfor(int i=0;i<17;i++){\n\t\t\tfor(int j=0;j<16;j++){\n\t\t\t\tgrid[i][j]=0;DP1[i][j]=0;DP2[i][j]=0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<Y;i++){\n\t\t\tfor(int j=0;j<X;j++){\n\t\t\t\tscanf(\"%d\",&grid[i][j]);\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<X;j++){\n\t\t\tif(grid[0][j]==0)DP1[0][j]=1;\n\t\t\telse DP1[0][j]=0;\n\t\t}\n\t\tfor(int i=0;i<Y;i++){\n\t\t\tfor(int j=0;j<X;j++){\n\t\t\t\tif(grid[i][j]==0){\n\t\t\t\t\tif(j-1>=0&&grid[i+1][j-1]!=1)DP2[i+1][j-1]+=(DP1[i][j]+DP2[i][j]);\n\t\t\t\t\tif(grid[i+1][j]!=1)DP1[i+1][j]+=(DP1[i][j]+DP2[i][j]);\n\t\t\t\t\tif(j+1<X&&grid[i+1][j+1]!=1)DP2[i+1][j+1]+=(DP1[i][j]+DP2[i][j]);\n\t\t\t\t}\n\t\t\t\telse if(grid[i][j]==2){\n\t\t\t\t\tif(grid[i+2][j]!=1)DP1[i+2][j]+=DP1[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tprintf(\"\\n\");\n\t\tfor(int i=0;i<Y+2;i++){\n\t\t\tfor(int j=0;j<X;j++){\n\t\t\t\tprintf(\"%d \",DP1[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tprintf(\"\\n\");\n\t\tfor(int i=0;i<Y+2;i++){\n\t\t\tfor(int j=0;j<X;j++){\n\t\t\t\tprintf(\"%d \",DP2[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\tint ans=0;\n\t\tfor(int i=Y;i<Y+2;i++){\n\t\t\tfor(int j=0;j<X;j++){\n\t\t\t\tans+=DP1[i][j];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i, s, n) for(int i = s; i < (int)n; i++)\n#define per(i, n) for(int i = n; i >= 0; i--)\n#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)\n#define FORIT(i, A) for (auto i : A)\n#define PRINT(x) cout << (x) << \"\\n\"\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define MP make_pair\n#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)\n#define SZ(a) int((a).size())\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define NCLR(a) memset((a), -1 ,sizeof(a))\n#define dump(x) cout << #x << \" = \" << (x) << \"\\n\";\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << \"\\n\";\n#define sq(n) (n) * (n)\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef priority_queue<int> maxpq;\ntypedef priority_queue< int, vector<int>, greater<int> > minpq;\nstatic const double EPS = 1e-10;\nstatic const double PI = acos( -1.0 );\nstatic const int mod = 1000000007;\nstatic const int INF = 1 << 30;\nstatic const LL LL_INF = 1152921504606846976;\nstatic const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };\nstatic const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };\n\nint n, m;\nint dp[ 16 ][ 16 ];\nint _array[ 16 ][ 16 ];\nVI can_start;\n\nint solve( int now, int x ) {\n\tif ( now >= m ) {\n\t\treturn 1;\n\t}\n\tif ( _array[ now ][ x ] == 1 ) {\n\t\treturn 0;\n\t}\n\tif ( now >= m - 1 ) {\n\t\treturn 1;\n\t}\n\tif ( dp[ now ][ x ] >= 0 ) {\n\t\treturn dp[ now ][ x ];\n\t}\n\tint res = 0;\n\tif ( _array[ now ][ x ] == 2 ) {\n\t\tres += solve( now + 2, x );\n\t}\n\telse {\n\t\tfor ( int i = 0; i < 3; i++ ) {\n\t\t\tif ( x + dx[ i ] < 0 || x + dx[ i ] >= n || ( now + 1 != m && _array[ now + 1 ][ x + dx[ i ] ] == 2 && dx[ i ] != 0 ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tres += solve( now + 1, x + dx[ i ] );\n\t\t}\n\t}\n\treturn dp[ now ][ x ] = res;\n}\n\nint main() {\n\twhile ( ~scanf( \"%d %d\", &n, &m ) && n != 0 && m != 0 ) {\n\t\tfor ( int i = 0; i < m; i++ ) {\n\t\t\tfor ( int j = 0; j < n; j++ ) {\n\t\t\t\tscanf( \"%d\", &_array[ i ][ j ] );\n\t\t\t\tif ( i == 0 && _array[ i ][ j ] == 0 ) {\n\t\t\t\t\tcan_start.push_back( j );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tNCLR( dp );\n\t\tint ans = 0;\n\t\tfor ( int i = 0; i < can_start.size(); i++ ) {\n\t\t\tans += solve( 0, can_start[ i ] );\n\t\t}\n\t\tprintf( \"%d\\n\", ans );\n\t\tcan_start.clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n\nusing namespace std;\n\n\nint main() {\n\twhile(1) {\n\t\tint x, y;\n\t\tcin >> y >> x;\n\t\tif(x==0 && y==0) break;\n\t\tint field[x][y];\n\t\tfor(int i=0; i<x; i++) {\n\t\t\tfor(int j=0; j<y; j++) {\n\t\t\t\tcin >> field[i][j];\n\t\t\t}\n\t\t}\n\t\tint dp[x+1][y];\n\t\tfor(int i=0; i<x+1; i++) {\n\t\t\tfor(int j=0; j<y; j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<x; i++) {\n\t\t\tfor(int j=0; j<y; j++) {\n\t\t\t\tif(i==0 && field[i][j] == 0) dp[i][j] = 1;\n\t\t\t\telse {\n\t\t\t\t\tif(field[i][j] == 0) {\n\t\t\t\t\t\tif(0<j && field[i-1][j-1] == 0) dp[i][j] += dp[i-1][j-1];\n\t\t\t\t\t\tif(field[i-1][j] == 0) dp[i][j] += dp[i-1][j];\n\t\t\t\t\t\tif(j<y-1 && field[i-1][j+1] == 0) dp[i][j] += dp[i-1][j+1];\n\t\t\t\t\t}\n\t\t\t\t\tif(field[i][j] == 2) {\n\t\t\t\t\t\tif(field[i-1][j] == 0) dp[i][j] += dp[i-1][j];\n\t\t\t\t\t\tif(field[i+2][j] != 1) dp[i+2][j] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<y; i++) dp[x][i] += dp[x-1][i];\n\n\t\tint sum=0;\n\t\tfor(int i=0; i<y; i++) sum += dp[x][i];\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define N 15\nusing namespace std;\nint jump(int,int);\nint X,Y,data[N][N],dp[N][N];\nint main(){\n  bool q[N][N];\n  while(1){\n    cin >> X >> Y;\n    if(X==0&&Y==0) break;\n    for(int i=0;i<Y;i++)\n      for(int j=0;j<X;j++) cin >> data[i][j],q[i][j]=false,dp[i][j]=0;\n    for(int i=0;i<X;i++)\n      if(data[0][i]==0) q[0][i]=true,dp[0][i]=1;\n    for(int i=0;i<Y-1;i++){\n      for(int j=0;j<X;j++){\n\tif(q[i][j]==true){\n\t  if(0<=j-1&&data[i+1][j-1]==0) dp[i+1][j-1]+=dp[i][j],q[i+1][j-1]=true;\n\t  if(j+1<X&&data[i+1][j+1]==0) dp[i+1][j+1]+=dp[i][j],q[i+1][j+1]=true;\n\t  if(data[i+1][j]==0) dp[i+1][j]+=dp[i][j],q[i+1][j]=true;\n\t  else if(data[i+1][j]==2){\n\t    int r=jump(i+1,j);\n\t    if(r==-1) dp[Y-1][j]+=dp[i][j];\n\t    else if(r!=-2) dp[r][j]+=dp[i][j],q[r][j]=true;\n\t  }\n\t}\n      }\n    }\n    int cnt=0;\n    for(int i=0;i<X;i++) cnt+=dp[Y-1][i];\n    cout << cnt << endl;\n  }\n  return 0;\n}\nint jump(int y,int x){\n  while(1){\n    y+=2;\n    if(y<Y&&data[y][x]==1) break;\n    if(y>=Y-1) return -1;\n    if(data[y][x]==0) return y;\n  }\n  return -2;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <math.h>\n#include <utility>\n#include <stack>\n#include <string.h>\nusing namespace std;\ntypedef pair<int,int> P;\nconst int INF = ~(1<<31) / 2;\n\nint field[15][15];\nint dp[15][15];\n\nint main(){\n    while(1){\n        int X,Y;\n        scanf(\"%d %d\",&X,&Y);\n        if(X==0)break;\n        for(int i=0;i<Y;i++){\n            for(int j=0;j<X;j++){\n                scanf(\"%d\",&field[i][j]);\n            }\n        }\n\n        for(int j=0;j<X;j++){\n            dp[Y-1][j] = field[Y-1][j] == 1 ? 0 : 1;\n        }\n\n        for(int i=Y-2;i>=0;i--){\n            for(int j=0;j<X;j++){\n                if(field[i][j]==1){\n                    dp[i][j] = 0;\n                }else if(field[i][j]==2){\n                    dp[i][j] = i+2<Y ? dp[i+2][j] : 1;\n                }else{\n                    dp[i][j] = 0;\n                    if(j-1>=0 && field[i+1][j-1]==0){\n                        dp[i][j] += dp[i+1][j-1];\n                    }\n                    if(j+1<X && field[i+1][j+1]==0){\n                        dp[i][j] += dp[i+1][j+1];\n                    }\n                    if(field[i+1][j]!=1){\n                        dp[i][j] += dp[i+1][j];\n                    }\n                }\n            }\n        }\n        int ans = 0;\n        for(int j=0;j<X;j++){\n            ans += dp[0][j];\n        }\n        printf(\"%d\\n\",ans);\n    }\n\n    return 0;\n}\n#include <iostream>\n#include <stdio.h>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <math.h>\n#include <utility>\n#include <stack>\n#include <string.h>\nusing namespace std;\ntypedef pair<int,int> P;\nconst int INF = ~(1<<31) / 2;\n\nint field[15][15];\nint dp[15][15];\n\nint main(){\n    while(1){\n        int X,Y;\n        scanf(\"%d %d\",&X,&Y);\n        if(X==0)break;\n        for(int i=0;i<Y;i++){\n            for(int j=0;j<X;j++){\n                scanf(\"%d\",&field[i][j]);\n            }\n        }\n\n        for(int j=0;j<X;j++){\n            dp[Y-1][j] = field[Y-1][j] == 1 ? 0 : 1;\n        }\n\n        for(int i=Y-2;i>=0;i--){\n            for(int j=0;j<X;j++){\n                if(field[i][j]==1){\n                    dp[i][j] = 0;\n                }else if(field[i][j]==2){\n                    dp[i][j] = i+2<Y ? dp[i+2][j] : 1;\n                }else{\n                    dp[i][j] = 0;\n                    if(j-1>=0 && field[i+1][j-1]==0){\n                        dp[i][j] += dp[i+1][j-1];\n                    }\n                    if(j+1<X && field[i+1][j+1]==0){\n                        dp[i][j] += dp[i+1][j+1];\n                    }\n                    if(field[i+1][j]!=1){\n                        dp[i][j] += dp[i+1][j];\n                    }\n                }\n            }\n        }\n        int ans = 0;\n        for(int j=0;j<X;j++){\n            ans += dp[0][j];\n        }\n        printf(\"%d\\n\",ans);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint solve(int x,int y);\nint ax,ay;\nint mas[16][16];\nint memo[16][16];\nint main(){\n  while(1){\n    int ans=0;\n    for(int i=0;i<16;i++){\n      for(int j=0;j<16;j++){\n\tmemo[i][j]=0;\n      }\n    }\n    cin>>ax>>ay;\n    if(ax==0 && ay==0){\n      break;\n    }\n    for(int i=0;i<ay;i++){\n      for(int j=0;j<ax;j++){\n\tcin>>mas[i][j];\n      }\n    }\n    for(int i=0;i<ax;i++){\n      if(mas[0][i]!=1){\n\tans+=solve(i,0);\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}\nint solve(int x,int y){\n  if(memo[y][x]!=0){\n    return memo[y][x];\n  }\n  else if(y==ay){\n    return 1;\n  }else if(mas[y][x]==1){\n    return 0;\n  }else if(mas[y][x]==2){\n    return solve(x,y+2);\n  } \n  else{\n    int anss=0; \n    if(mas[y+1][x]!=1){\n      anss+=solve(x,y+1);\n    }\n    if(x+1<ax && mas[y+1][x+1]==0 && y+1!=ay){\n      anss+=solve(x+1,y+1);\n    }\n    if(0<=x-1 && mas[y+1][x-1]==0 && y+1!=ay){\n      anss+=solve(x-1,y+1);\n    }\n    return memo[y][x]=anss;\n  }\n}  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint solve(int x,int y);\nint ax,ay;\nint mas[50][50];\nint memo[50][50];\nint main(){\n  while(1){\n    int ans=0;\n    for(int i=0;i<16;i++){\n      for(int j=0;j<16;j++){\n\tmemo[i][j]=0;\n      }\n    }\n    cin>>ax>>ay;\n    if(ax==0 && ay==0){\n      break;\n    }\n    for(int i=0;i<ay;i++){\n      for(int j=0;j<ax;j++){\n\tcin>>mas[i][j];\n      }\n    }\n    for(int i=0;i<ax;i++){\n      if(mas[0][i]!=1){\n\tans+=solve(i,0);\n      }\n    }\n    cout<<ans<<endl;\n  }\n}\nint solve(int x,int y){\n  if(memo[y][x]!=0){\n    return memo[y][x];\n  }\n  else if(y==ay){\n    return 1;\n  }else if(mas[y][x]==1){\n    return 0;\n  }else if(mas[y][x]==2){\n    return solve(x,y+2);\n  } \n  else{\n    int anss=0; \n    if(mas[y+1][x]!=1){\n      anss+=solve(x,y+1);\n    }\n    if(x+1<ax && mas[y+1][x+1]==0 && y+1!=ay){\n      anss+=solve(x+1,y+1);\n    }\n    if(0<=x-1 && mas[y+1][x-1]==0 && y+1!=ay){\n      anss+=solve(x-1,y+1);\n    }\n    return memo[y][x]=anss;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n\tint n,m;\n\tint masu[17][17];\n\tint ura[17][17];\n\twhile(1){\n\t\tscanf(\"%d%d\",&m,&n);\n\t\tif(n==0 && m==0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i=0;i<17;i++){\n\t\t\tfor(int j=0;j<17;j++){\n\t\t\t\tmasu[i][j]=0;\n\t\t\t\tura[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=1;j<=m;j++){\n\t\t\t\tscanf(\"%d\",&ura[i][j]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tswitch(ura[1][i]){\n\t\t\t\tcase 0:masu[1][i]+=1;break;\n\t\t\t\tcase 1:masu[1][i]+=0;break;\n\t\t\t\tcase 2:if(ura[3][i]!=1){masu[3][i]+=1;}break;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfor(int j=1;j<=m;j++){\n\t\t\t\tif(ura[i][j]==0){\n\t\t\t\t\tif(ura[i+1][j-1]==0){\n\t\t\t\t\t\tmasu[i+1][j-1]+=masu[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tif(ura[i+1][j]!=1){\n\t\t\t\t\t\tmasu[i+1][j]+=masu[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tif(ura[i+1][j+1]==0){\n\t\t\t\t\t\tmasu[i+1][j+1]+=masu[i][j];\n\t\t\t\t\t}\n\t\t\t\t}else if(ura[i][j]==2){\n\t\t\t\t\tif(ura[i+2][j]!=1){\n\t\t\t\t\t\tmasu[i+2][j]+=masu[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cont=0;\n\t\tfor(int i=n;i<=n+1;i++){\n\t\t\tfor(int j=1;j<=m;j++){\n\t\t\t\tcont+=masu[i][j];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",cont);\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nint main() {\n  while (true) {\n    int x, y;\n    cin >> x >> y;\n    if (x == 0 && y == 0) break;\n    int c[20][20];\n    rep (i, y) rep (j, x) cin >> c[i][j];\n    long long dp[20][20][3] = {};\n    rep (i, x) if (c[0][i] == 0) dp[0][i][1] = 1;\n    rep (i, y - 1) rep (j, x) {\n      if (c[i][j] == 0) {\n\tlong long sum = dp[i][j][0] + dp[i][j][1] + dp[i][j][2];\n\tif (j > 0) dp[i + 1][j - 1][0] += sum;\n\tdp[i + 1][j][1] += sum;\n\tdp[i + 1][j + 1][2] += sum;\n      } else if (c[i][j] == 2) {\n\tdp[i + 2][j][1] += dp[i][j][1];\n      }\n    }\n    long long res = 0;\n    rep (i, x) if (c[y - 1][i] != 1) rep (k, 3) res += dp[y - 1][i][k];\n    rep (i, x) res += dp[y][i][1];\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n//#include\nusing namespace std;\n\nstruct P{\n\tint way;\n\tint stt;\n};\n\n//グローバルは土俵F、と配列ans\n\nP F[17][17];\n//はじめにF.wayを-1で初期化 端っこ.sttを1で初期化\n\nint ans[1000]={0};\nint counter=0,flag=0;\n\nint solve(int x,int y);\n\nint jump(int x,int y){\n\tif(F[x][y-2].stt==2)\n\t\treturn (F[x][y-2].way==-1) ? solve(x,y-2) : F[x][y-2].way;\n\telse return 0;\n}\n\nint left(int x,int y){\n\tif(F[x-1][y-1].stt==0) \n\t\treturn (F[x-1][y-1].way==-1) ? solve(x-1,y-1) : F[x-1][y-1].way;\n\telse return 0;\n}\n\nint right(int x,int y){\n\tif(F[x+1][y-1].stt==0) \n\t\treturn (F[x+1][y-1].way==-1) ? solve(x+1,y-1) : F[x+1][y-1].way;\n\telse return 0;\n}\n\nint samex(int x,int y){\n\tif(F[x][y-1].stt==0) \n\t\treturn (F[x][y-1].way==-1) ? solve(x,y-1) : F[x][y-1].way;\n\telse return 0;\n}\n\nint solve(int x,int y){//入力した座標までのコース数を返す 0は普通 1は障害物 2はジャンプ台\n\tif (y==1) return 1;\n\tif (F[x][y].stt==0)\n\treturn jump(x,y)+left(x,y)+right(x,y)+samex(x,y);\n\tif (F[x][y].stt==2)\n\treturn jump(x,y)+samex(x,y);\n\tif (F[x][y].stt==1)\n\treturn 0;\n\treturn 0;\n}\n\n//int solve_ex(int x,int y){//最後JUMP通過のとき jumpをそのまま使う\n\n\nvoid solver(){\n\tint X,Y;\n\tcin >> X >> Y;\n\tif(X==0) {flag=1;return;}\n\t\n\t\n\tfor(int i=0;i<17;i++){\n\t\tfor(int j=0;j<17;j++){\n\t\t\tF[i][j].way=-1;\n\t\t\tF[i][j].stt=1;\n\t\t}\n\t}\n\t\n\tfor(int i=1;i<=Y;i++){\n\t\tfor(int j=1;j<=X;j++){\n\t\t\tcin >> F[j][i].stt;\n\t\t}\n\t}\n\t\n\tfor(int x=1;x<=X;x++){\n\t\tans[counter]+=(solve(x,Y)+jump(x,Y+1));\n\t}\n\tcounter++;\n}\n\nint main(){\n\twhile(flag==0){\n\t\tsolver();\n\t}\n\t\n\tfor(int i=0;i<counter;i++){\n\t\tcout << ans[i]<<\"\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main()\n{\n\tint X, Y;\n\n\twhile( cin >> X >> Y && ( X || Y ) ){\n\t\tvector< vector< int > > map( Y + 1, vector< int >( X + 2, 0 ) );\n\t\tvector< vector< int > > memo = map;\n\t\tfor( int i = 1; i < Y + 1; ++i ){\n\t\t\tfor( int j = 1; j < X + 1; ++j ){\n\t\t\t\tcin >> map[ i ][ j ];\n\t\t\t}\n\t\t}\n\t\tfor( int i = 1; i < X + 1; ++i ){\n\t\t\tif( map[ 1 ][ i ] == 0 ){\n\t\t\t\tmemo[ 1 ][ i ] = 1;\n\t\t\t}\n\t\t}\n\t\tfor( int i = 2; i < Y + 1; ++i ){\n\t\t\tfor( int j = 1; j < X + 1; ++j ){\n\t\t\t\tif( map[ i ][ j ] == 1 ) continue;\n\t\t\t\tif( map[ i ][ j ] == 2 ){\n\t\t\t\t\tif( map[ i - 1 ][ j ] == 0 ){\n\t\t\t\t\t\tmemo[ i ][ j ] = memo[ i - 1 ][ j ];\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tfor( int k = -1; k < 2; ++k ){\n\t\t\t\t\t\tif( map[ i - 1 ][ j + k ] == 0 ){\n\t\t\t\t\t\t\tmemo[ i ][ j ] += memo[ i - 1 ][ j + k ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( map[ i - 2 ][ j ] == 2 ){\n\t\t\t\t\tmemo[ i ][ j ] += memo[  i - 2 ][ j ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor( int i = 1; i < X + 1; ++i ){\n\t\t\tans += memo[ Y ][ i ];\n\t\t\tif( map[ Y - 1 ][ i ] == 2 ){\n\t\t\t\tans += memo[ Y - 1 ][ i ];\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main(){\n\n    int w,h;\n    while(cin>>w>>h){\n        int data[16][16]={{0}},dp[17][17]={{0}};\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                cin>>data[i][j];\n                if(i==0&&data[i][j]!=1)dp[i][j]=1;\n            }\n        }\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                if(dp[i][j]!=0){\n                    if(data[i][j]==0){\n                        if(j!=0&&data[i+1][j-1]==0)dp[i+1][j-1]+=dp[i][j];\n                        if(data[i+1][j]!=1)dp[i+1][j]+=dp[i][j];\n                        if(j!=w-1&&data[i+1][j+1]==0)dp[i+1][j+1]+=dp[i][j];\n                    }\n                    else if(data[i][j]==2){\n                        if(i+2>=h)dp[i+1][j]+=dp[i][j];\n                        if(data[i+2][j]!=1)dp[i+2][j]+=dp[i][j];\n                    }\n                }\n            }\n        }\n        int ans=0;\n        for(int j=0;j<w;j++)ans+=dp[h-1][j];\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n  while(1){\n    int w,h,mp[20][20]={},dp[20][20] ={};\n    cin >> w >> h;\n    if(w==0 && h==0) break;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++) cin >> mp[i][j];\n   \n\n    int ans=0;   \n    for(int i=0;i<w;i++) {\n      if(mp[0][i]==0) dp[0][i] = 1;\n      if(i >=h-1) ans++;\n    }\n    for(int i=0;i<h-1;i++)\n      for(int j=0;j<w;j++) \n\tfor(int k=-1;k<=1;k++){\n\t  int nx=j+k,ny=i+1;\n\t  if(nx<0||nx>=w || mp[i][j] !=0) continue;\n\t  if(k==0)while(mp[ny][nx]==2) ny+=2;\n\t  if(mp[ny][nx]!=0) continue;\n\t  dp[ny][nx]+= dp[i][j];\n\t  if(ny >= h-1) ans+=dp[i][j];\n\t}\n\n      cout << endl;\n      for(int i=0;i<h+3;i++){\n      for(int j=0;j<w;j++)cout << dp[i][j] <<\" \";\n      cout << endl;\n      }\n\n    cout << ans <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<string>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<cctype>\nusing namespace std;\n#define rep(i, j) for(int i = 0; i < j; i++)\n#define f(i, k, j) for(int i = k; i < j; i++)\n#define P pair<int, int>\nconst int INF = (1 << 26);\nconst int MAX_XY = 16;\n\nvoid solve();\n\nint x, y, f[MAX_XY][MAX_XY], dp[MAX_XY][MAX_XY];\n\nint main(){\n    cin >>x >>y;\n    rep(i, MAX_XY) rep(j, MAX_XY) f[i][j] = 1;\n    rep(i, y) rep(j, x) cin >>f[i][j];\n    memset(dp, 0, sizeof(dp));\n\n    solve();\n\n    int ans = 0;\n    rep(i, x) ans += dp[y][i];\n    cout <<ans <<endl;\n    return 0;\n}\n\nvoid solve(){\n    rep(i, x){\n        if(f[0][i] != 1) dp[0][i] = 1;\n    }\n\n    rep(i, y - 1){\n        rep(j, x){\n            if(f[i + 1][j] == 1){\n                dp[i + 1][j] = 0;\n                continue;\n            } else if(f[i + 1][j] == 0){\n                f(k, -1, 2){\n                    if(j + k < x && j + k >= 0) dp[i + 1][j] += dp[i][j + k];\n                }\n            } else{\n                dp[i + 1][j] += dp[i][j];\n                if(i + 3 >= y) dp[y][j] += dp[i + 1][j];\n                else dp[i + 3][j] += dp[i + 1][j];\n                dp[i + 1][j] = 0;\n            }\n        }\n    }\n    rep(i, x) dp[y][i] += dp[y - 1][i];\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\nint X,Y;\nint f[20][20];\nint dp[20][20];\nint d[3]={1,0,-1};\nint main()\n{\n\twhile(1)\n\t{\n\t\tint ans=0;\n\t\tmemset(dp,0,sizeof(dp));\n\t\tmemset(f,0,sizeof(f));\n\t\tscanf(\"%d %d\",&Y,&X);\n\t\tif(X==0&&Y==0)break;\n\t\tfor(int i=0;i<X;i++)\n\t\t{\n\t\t\tfor(int j=0;j<Y;j++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\",&f[i][j]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<Y;i++)\n\t\t{\n\t\t\tif(f[0][i]==0)dp[0][i]=1;\n\t\t\telse dp[0][i]=0;\n\t\t}\n\t\tfor(int i=0;i<X-1;i++)\n\t\t{\n\t\t\tfor(int j=0;j<Y;j++)\n\t\t\t{\n\t\t\t\tif(f[i][j]==0)\n\t\t\t\t{\n\t\t\t\t\tfor(int k=0;k<3;k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(j+d[k]<0||j+d[k]>=Y)continue;\n\t\t\t\t\t\tif(f[i+1][j+d[k]]==2&&d[k]!=0)continue;\n\t\t\t\t\t\t//if(j==Y-1&&d[k]!=0)continue;\n\t\t\t\t\t\tdp[i+1][j+d[k]]+=dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(f[i][j]==2)\n\t\t\t\t{\n\t\t\t\t\tdp[i+2][j]+=dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*cout << endl;\n\t\tfor(int i=0;i<=X+1;i++)\n\t\t{\n\t\t\tfor(int j=0;j<Y;j++)\n\t\t\t{\n\t\t\t\tcout << dp[i][j] << ' ';\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t\tfor(int i=X-1;i<=X;i++)\n\t\t{\n\t\t\tfor(int j=0;j<Y;j++)if(f[i][j]!=1)\n\t\t\t{\n\t\t\t\tans+=dp[i][j];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n  while(1){\n    int w,h,mp[20][20]={},dp[20][20] ={};\n    cin >> w >> h;\n    if(w==0 && h==0) break;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++) cin >> mp[i][j];\n    for(int i=0;i<w;i++) dp[0][i] = 1;\n\n    int ans=0;    \n    for(int i=0;i<h-1;i++)\n      for(int j=0;j<w;j++) {\n\tif(mp[i][j] !=0) break;\n\tfor(int k=-1;k<=1;k++){\n\t  int nx=j+k,ny=i+1;\n\t  if(nx<0||nx>=w) continue;\n\t  while(k==0 && mp[ny][nx]==2) ny+=2;\n\t  if(mp[ny][nx]!=0) continue;\n\t  dp[ny][nx]+= dp[i][j];\n\t  if(ny >= h-1) ans+=dp[i][j];\n\t}\n      }\n    cout << ans <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nint X, Y;\nint status[17][18];\t//status[x][y]\nint memo[17][18];\nint i, j;\nint count;\n\nint check(int x, int y);\n\nint main(){\n\n\twhile(1){\n\n\t\tcount = 0;\n\n\t\tcin >> X >> Y;\n\n\t\tif(X == 0 && Y == 0){break;}\n\n\t\telse{\n\n\t\t\t//フィールドの入力\n\t\t\t//i行目について( 1 <= i <= Y+2 )\n\t\t\tfor(i = 1; i <= Y+2; i++){\n\t\t\t\t//j文字目について( 0 <= j <= X+1)\n\t\t\t\tfor(j = 0; j <= X+1; j++){\n\n\t\t\t\t\t//Y+1, Y+2列目に移動できるようにする。\n\t\t\t\t\tif(i > Y){\n\t\t\t\t\t\tstatus[j][i] = 0;\n\t\t\t\t\t}\n\t\t\t\t\t//両サイドには障害物を敷き詰める。\n\t\t\t\t\telse if(j == 0 || j == X+1){\n\t\t\t\t\t\tstatus[j][i] = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tcin >> status[j][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n/*//フィールド出力\n\t\t\tfor(i = 1; i <= Y+2; i++){\n\t\t\t\tfor(j = 0; j <= X+1; j++){\n\t\t\t\t\tcout << status[j][i];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n*/\n\n\t\t\tfor(i = 1; i <= X; i++){\n\t\t\t\tmemset(memo, 0, sizeof(memo));\n\t\t\t\tcount += check(i, 1);\n\t\t\t}\n\n\t\t\tcout << count << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\nint  check(int x, int y){\n\n//\tcout << \"x:\" << x << \"y:\" << y << \" : \"<< status[x][y] << endl;\n\n\t//関数のメモが残っているならメモを返す\n\tif(memo[x][y] > 0){return memo[x][y];}\n\n\t//status[x][y]の次でゴール\n\tif(status[x][y] == 1){return 0;}\n\tif(status[x][y] == 0 && y == Y){return 1;}\n\tif(status[x][y] == 2 && (y == Y-1 || y == Y)){return 1;}\n\n\t//それ以外\n\telse{\n\t\t//ジャンプ台\n\t\tif(status[x][y] == 2){\n\t\t\tmemo[x][y] += check(x, y+2);\n\t\t}\n\t\t//平地\n\t\telse{\n\t\t\tif(status[x-1][y+1] == 0){\n\t\t\t\tmemo[x][y] += check(x-1, y+1);\n\t\t\t}\n\t\t\tif(status[x][y+1] == 0 || status[x][y+1] == 2){\n\t\t\t\tmemo[x][y] += check(x, y+1);\n\t\t\t}\n\t\t\tif(status[x+1][y+1] == 0){\n\t\t\t\tmemo[x][y] += check(x+1, y+1);\n\t\t\t}\n\t\t}\n\n\t\treturn memo[x][y];\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define rep2(x,from,to) for(int x=(from);(x)<(to);(x)++)\n#define rep(x,to) rep2(x,0,to)\nusing namespace std;\nint main(){\n\tint x, y;\n\twhile(cin >> x >> y && (x||y) ) {\n\t\tint b[15][15] = {};\n\t\trep(i,y) {\n\t\t\trep(j,x) {\n\t\t\t\tcin >> b[i][j];\n\t\t\t}\n\t\t}\n\t\tint ret[20][20] = {};\n\t\trep(i,x) {\n\t\t\tif(b[0][i] == 0) {\n\t\t\t\tret[0][i+1] = 1;\n\t\t\t}\n\t\t}\n\t\trep2(i,1,y) {\n\t\t\trep(j,x) {\n\t\t\t\tif(b[i][j] == 0) {\n\t\t\t\t\tret[i][j+1] += ret[i-1][j] + ret[i-1][j+1] + ret[i-1][j+2];\n\t\t\t\t\trep2(k,-1,2) {\n\t\t\t\t\t\tif(b[i-1][j+k] == 2) ret[i][j+1] -= ret[i-1][j+k+1];\n\t\t\t\t\t}\n\t\t\t\t} else if(b[i][j] == 2) {\n\t\t\t\t\tif(y <= i+2 || b[i+2][j] != 1) {\n\t\t\t\t\t\tret[i][j+1] += ret[i-1][j+1];\n\t\t\t\t\t\tret[i+2][j+1] += ret[i][j+1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\trep2(i,y-1,y+2) {\n\t\t\trep(j,x) {\n\t\t\t\tans += ret[i][j+1];\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint w,h;\nint map[16][16];\nint dp[16][16][4][2];\n\nint rec(int x,int y,int state,bool str){\n    if(state == 1 || x < 0 || x >= w) return 0;\n    if(state == 2 && !str) return 0;\n    if(y >= h-1) return 1;\n    if(dp[y][x][state][str] != -1) return dp[y][x][state][str];\n    int res;\n    if(state == 2) res = rec(x,y+2,map[y+2][x],true);\n    else res = (rec(x-1,y+1,map[y+1][x-1],false) + rec(x,y+1,map[y+1][x],true) + rec(x+1,y+1,map[y+1][x+1],false));\n    return dp[y][x][state][str] = res;\n}\n\nint main(){\n    while(cin >> w >> h,w||h){\n        memset(dp,-1,sizeof(dp));\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++) cin >> map[i][j];\n        }\n        int d = 0;\n        for(int i=0;i<w;i++) d += rec(i,0,map[0][i],true);\n        cout << d << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\ntypedef long long ll;\nint H,W;\nint t[20][20];\nll u[20][20],ans;\n\nbool inField(int x){\n  if(1<=x&&x<=W)return true;\n  return false;\n}\n\nint main(){\n  while(cin>>W>>H){\n    if(H==0&&W==0)break;\n    for(int i=0;i<20;i++)for(int j=0;j<20;j++)u[i][j]=0;\n    for(int i=1;i<=H;i++)for(int j=1;j<=W;j++)cin>>t[i][j];\n\n    for(int i=0;i<20;i++)u[1][i]=(t[1][i]==1?0:1);\n\n    for(int i=1;i<H;i++){\n      for(int j=1;j<=W;j++){\n\tif(t[i][j]==1)u[i][j]=0;\n\tif(u[i][j]==0)continue;\n\tif(t[i][j]==2){\n\t  u[i+2][j]+=u[i][j];\n\t  continue;\n\t}\n\tfor(int k=-1;k<=1;k++){\n\t  if(!inField(j+k))continue;\n\t  if(t[i+1][j+k]==0){\n\t    u[i+1][j+k]+=u[i][j];\n\t  }else if(t[i+1][j+k]==2&&k==0){\n\t    u[i+1][j+k]+=u[i][j];\n\t  }\n\t}\n      }//j\n    }//i\n    ans=0;\n    for(int i=H;i<20;i++){\n      for(int j=1;j<=W;j++){\n\tans+=u[i][j];\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst int MAX_SIZE = 15;\nchar field[MAX_SIZE+1][MAX_SIZE+3];\nint dp[MAX_SIZE+1][MAX_SIZE+3];\nint w, h;\n\nbool judge(int i, int j){\n\tif(j > 0 && j <= w && field[j][i] == '0' && j <= h)\n\t\treturn true;\n\treturn false;\n}\n\nint main(){\n\twhile(cin >> w >> h){\n\t\tif(w == 0 && h == 0) break;\n\t\tfor(int i = 1; i <= h; i++){\n\t\t\tfor(int j = 1; j <= w; j++)\n\t\t\t\tcin >> field[j][i];\n\t\t}\n\t\tint pattern = 0;\n\t\tfor(int i = 0; i < MAX_SIZE+1; i++){\n\t\t\tfor(int j = 0; j < MAX_SIZE+3; j++){\n\t\t\t\tdp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1; i <= w; i++){\n\t\t\tif(field[i][1] == '0')\n\t\t\t\tdp[i][1] = 1;\n\t\t}\n\t\tfor(int i = 1; i < h; i++){\n\t\t\tfor(int j = 1; j <= w; j++){\n\t\t\t\tif(field[j][i] == '2'){\n\t\t\t\t\tdp[j][i+2] += dp[j][i];\n\t\t\t\t}else if(field[j][i] == '0'){\n\t\t\t\t\tif(field[j][i+1] != '1') dp[j][i+1] += dp[j][i];\n\t\t\t\t\tif(judge(i+1, j-1)) dp[j-1][i+1] += dp[j][i];\n\t\t\t\t\tif(judge(i+1, j+1)) dp[j+1][i+1] += dp[j][i];\n\t\t\t\t}else{\n\t\t\t\t\tdp[j][i] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tint count = 0;\n\t\tfor(int i = h; i <= h+1; i++){\n\t\t\tfor(int j = 1; j <= w; j++){\n\t\t\t\tcount += dp[j][i];\n\t\t\t}\n\t\t}\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint main()\n{\n    for(;;){\n        int w, h;\n        cin >> w >> h;\n        if(w == 0)\n            return 0;\n\n        vector<vector<int> > grid(h+1, vector<int>(w+2, 0));\n        for(int i=0; i<h+1; ++i)\n            grid[i][0] = grid[i][w+1] = 1;\n        for(int i=0; i<h; ++i){\n            for(int j=1; j<=w; ++j){\n                cin >> grid[i][j];\n            }\n        }\n\n        vector<vector<int> > num(h+1, vector<int>(w+2, 0));\n        for(int i=1; i<=w; ++i){\n            if(grid[0][i] == 0)\n                num[0][i] = 1;\n        }\n\n        for(int y=0; y<h-1; ++y){\n            for(int x=1; x<=w; ++x){\n                if(grid[y][x] == 2){\n                    num[y+2][x] += num[y][x];\n                }else{\n                    for(int dx=-1; dx<=1; ++dx){\n                        if(grid[y+1][x+dx] == 1 || (grid[y+1][x+dx] == 2 && dx != 0))\n                            continue;\n                        num[y+1][x+dx] += num[y][x];\n                    }\n                }\n            }\n        }\n\n        int ret = accumulate(num[h-1].begin(), num[h-1].end(), 0);\n        ret += accumulate(num[h].begin(), num[h].end(), 0);\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <functional>\n#include <numeric>\n#define fi first\n#define se second\nusing namespace std;\nbool value(int y,int x,int R,int C){return 0<=y&&y<R&&0<=x&&x<C;}\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<long long > vll;\ntypedef vector< vi > vvi;\ndouble pie=acos(-1);\nint INF=10000009;\nint dx[4] = { 0,-1,0,1 };\nint dy[4] = { -1,0,1,0 };\nint c[20][20];\nlong long int dp[20][20];\nint main() {\n\tint X,Y;\n\twhile(true){\n\t\tlong long int ans=0;\n\t\tcin>>X>>Y;\n\t\tif(X+Y==0) break;\n\t\tfor(int i=1;i<=Y;i++){\n\t\t\tfor(int j=1;j<=X;j++){\n\t\t\t\tcin>>c[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=X;i++){\n\t\t\tif(c[1][i]==1){\n\t\t\t\tdp[1][i]=0;\n\t\t\t}\n\t\t\tif(c[1][i]==0){\n\t\t\t\tdp[1][i]=1;\n\t\t\t}\n\t\t\tif(c[1][i]==2){\n\t\t\t\tdp[1][i]=1;\n\t\t\t\tdp[3][i]=1;\n\t\t\t}\n\t\t}\n\t\tfor(int i=2;i<=Y;i++){\n\t\t\tfor(int j=1;j<=X;j++){\n\t\t\t\tif(c[i][j]==1) dp[i][j]=0;\n\t\t\t\telse if(c[i][j]==0){\n\t\t\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\t\t\tif(c[i-1][j-1+k]!=2){\n\t\t\t\t\t\t\tdp[i][j]+=dp[i-1][j-1+k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(c[i-1][j]!=2){\n\t\t\t\t\t\tdp[i][j]+=dp[i-1][j];\n\t\t\t\t\t}\n\t\t\t\t\tdp[i+2][j]+=dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=Y;i<=Y+2;i++){\n\t\t\tfor(int j=1;j<=X;j++){\n\t\t\t\tans+=dp[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=Y+2;i++){\n\t\t\tfor(int j=1;j<=X;j++){\n\t\t\t\tdp[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst int MAX_SIZE = 15;\nchar field[MAX_SIZE+1][MAX_SIZE+3];\nint dp[MAX_SIZE+1][MAX_SIZE+3];\nint w, h;\n\nbool judge(int i, int j){\n\tif(j > 0 && j <= w && field[j][i] == '0' && j <= h)\n\t\treturn true;\n\treturn false;\n}\n\nint main(){\n\twhile(cin >> w >> h){\n\t\tif(w == 0 && h == 0) break;\n\t\tfor(int i = 1; i <= h; i++){\n\t\t\tfor(int j = 1; j <= w; j++)\n\t\t\t\tcin >> field[j][i];\n\t\t}\n\t\tint pattern = 0;\n\t\tfor(int i = 0; i < MAX_SIZE+1; i++){\n\t\t\tfor(int j = 0; j < MAX_SIZE+3; j++){\n\t\t\t\tdp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1; i <= w; i++){\n\t\t\tdp[i][1] = 1;\n\t\t}\n\t\tfor(int i = 1; i <= h; i++){\n\t\t\tfor(int j = 1; j <= w; j++){\n\t\t\t\tif(field[j][i] == '2')\n\t\t\t\t\tdp[j][i+2] += dp[j][i];\n\t\t\t\tif(field[j][i] == '0'){\n\t\t\t\t\tdp[j][i+1] += dp[j][i];\n\t\t\t\t\tif(judge(i+1, j-1)) dp[j-1][i+1] += dp[j][i];\n\t\t\t\t\tif(judge(i+1, j+1)) dp[j+1][i+1] += dp[j][i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint count = 0;\n\t\tfor(int i = h+1; i <= h+2; i++){\n\t\t\tfor(int j = 1; j <= w; j++){\n\t\t\t\tcount += dp[j][i];\n\t\t\t}\n\t\t}\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint w,h,mp[20][20],memo[20][20];\nint dx[] = {-1,0,1};\n\nvoid saiki(int x,int y) {\n  if(y >= h-1) memo[y][x]++;\n  else if(mp[y][x] != 1) {\n    for(int i=0;i<3;i++) {\n      int nx = x+dx[i], ny = y+1;\n      if(nx==x && mp[ny][nx] == 2)while(mp[ny][nx] == 2) ny+=2;\n      if(nx <0|| nx >= w ||mp[ny][nx] == 1) continue;\n      if(memo[ny][nx] ==0) saiki(nx,ny);\n      memo[y][x] += memo[ny][nx];\n    }\n  }\n  if(memo[y][x] == 0) mp[y][x] = 1;\n}\n   \nint main() {\n  while(1) {\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n    for(int i=0;i<=19;i++)\n      for(int j=0;j<=19;j++)memo[i][j] = mp[i][j] = 0;\n     \n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)cin >> mp[i][j];\n  \n    for(int i=0;i<w;i++)\n      if(mp[0][i] !=1) saiki(i,0);\n     \n    int cnt = 0;\n    for(int i=0;i<w;i++)\n      if(memo[0][i] > 0) cnt+=memo[0][i];\n    cout <<cnt<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nint main(){\n\tint n,m;\n\tint masu[17][17];\n\tint ura[17][17];\n\t\n\twhile( cin>>n>>m, n != 0 && m != 0 ){\n\t\tfor(int i=0;i<17;i++){\n\t\t\tfor(int j=0;j<17;j++){\n\t\t\t\tmasu[i][j]=ura[i][j]=0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=1;j<=m;j++){\n\t\t\t\tcin>>masu[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tif(masu[0][j]!=1){\n\t\t\t\tura[0][j]=1;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tfor(int i=0;i<n-1;i++){\n\t\t\tfor(int j=1;j<=m;j++){\n\t\t\t\tif(masu[i][j]==0){\n\t\t\t\t\tif(masu[i+1][j-1]==0){\n\t\t\t\t\t\tura[i+1][j-1]+=ura[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tif(masu[i+1][j]!=1){\n\t\t\t\t\t\tura[i+1][j]+=ura[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tif(masu[i+1][j+1]==0){\n\t\t\t\t\t\tura[i+1][j+1]+=ura[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(masu[i][j]==2){\n\t\t\t\t\tif(masu[i+2][j]!=1){\n\t\t\t\t\t\tura[i+2][j]+=ura[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint cont=0;\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tcont+=ura[n][i]+ura[n-1][i];\n\t\t}\n\t\t\n\t\t/*\n\t\t\n\t\tfor(int i=0;i<17;i++){\n\t\t\tfor(int j=0;j<17;j++){\n\t\t\t\tprintf(\"%2d \",ura[i][j]);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}*/\n\t\tprintf(\"%d\\n\",cont);\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint W, H;\nint C[20][20];\nlong long dp[20][20];\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  while (cin >> W >> H) {\n    if (W == 0 && H == 0) break;\n    rep(x, 20) rep(y, 20) C[x][y] = dp[x][y] = 0;\n    rep(i, H) rep(j, W) cin >> C[j][i];\n\n    rep(x, W) {\n      if (C[x][0] == 1) continue;\n      dp[x][0] = 1;\n    }\n    long long s = 0;\n    rep(y, H) {\n      rep(x, W) {\n        for (int d=-1; d<=1; d++) {\n          int nx = x+d, ny = y+1;\n          if (C[x][y] == 2) {\n            if (d != 0) continue;\n            ny = y+2;\n          }\n          if (nx < 0 || nx >= W || C[nx][ny] == 1) continue;\n          if (C[nx][ny] == 2 && d != 0) continue;\n\n          if (ny >= H) {\n            if (d == 0) s += dp[x][y];\n          }\n          else dp[nx][ny] += dp[x][y];\n        }\n      }\n    }\n    cout << s << \"\\n\";\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint dx[] = {-1,0,1};\n\nint main(){\n\tint w,h;\n\n\twhile( cin >> w >> h , w||h ){\n\t\tint f[20][20] = {0};\n\t\tfor(int y=1 ; y <= h ; y++ ){\n\t\t\tfor(int x=1 ; x <= w ; x++ ){\n\t\t\t\tcin >> f[y][x];\n\t\t\t}\n\t\t}\n\n\t\tint dp[20][20] = {0};\n\t\tfor(int x=1 ; x <= w ; x++ )\n\t\t\tdp[1][x] = 1;\n\t\tfor(int y=1 ; y <= h-1 ; y++ ){\n\t\t\tfor(int x=1 ; x <= w ; x++ ){\n\t\t\t\tif( f[y][x] == 0 ){\n\t\t\t\t\tfor(int i=0 ; i < 3 ; i++ ){\n\t\t\t\t\t\tint mx = x + dx[i];\n\t\t\t\t\t\tint my = y + 1;\n\t\t\t\t\t\tif( mx < 1 || mx > w || my < 1 || my > h ) continue;\n\t\t\t\t\t\tif( f[my][mx] == 0 ) \n\t\t\t\t\t\t\tdp[my][mx] += dp[y][x];\n\t\t\t\t\t\tif( dx[i] == 0 && f[my][mx] == 2 ) \n\t\t\t\t\t\t\tdp[my][mx] += dp[y][x];\n\t\t\t\t\t}\n\t\t\t\t\t/*if( f[y+1][x-1] == 0 ) dp[y+1][x-1] += dp[y][x];\n\t\t\t\t\tif( f[y+1][x]   == 0 ) dp[y+1][x]   += dp[y][x];\n\t\t\t\t\tif( f[y+1][x+1] == 0 ) dp[y+1][x+1] += dp[y][x];\n\t\t\t\t\tif( f[y+1][x]   == 2 ) dp[y+1][x]   += dp[y][x];*/\n\t\t\t\t}else if( f[y][x] == 2 && f[y+2][x] != 1 ){\n\t\t\t\t\tdp[y+2][x] += dp[y][x];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int x=1 ; x <= w ; x++ ){\n\t\t\tans += dp[h][x] + dp[h+1][x];\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main()\n{\n\tint X, Y;\n\n\twhile( cin >> X >> Y && ( X || Y ) ){\n\t\tvector< vector< int > > map( Y + 1, vector< int >( X + 2, 0 ) );\n\t\tvector< vector< int > > memo = map;\n\t\tfor( int i = 1; i < Y + 1; ++i ){\n\t\t\tfor( int j = 1; j < X + 1; ++j ){\n\t\t\t\tcin >> map[ i ][ j ];\n\t\t\t}\n\t\t}\n\t\tfor( int i = 1; i < X + 1; ++i ){\n\t\t\tif( map[ 1 ][ i ] == 0 ){\n\t\t\t\tmemo[ 1 ][ i ] = 1;\n\t\t\t}\n\t\t}\n\t\tfor( int i = 2; i < Y + 1; ++i ){\n\t\t\tfor( int j = 1; j < X + 1; ++j ){\n\t\t\t\tif( map[ i ][ j ] == 1 ) continue;\n\t\t\t\tif( map[ i ][ j ] == 2 ){\n\t\t\t\t\tmemo[ i ][ j ] = memo[ i - 1 ][ j ];\n\t\t\t\t}else{\n\t\t\t\t\tfor( int k = -1; k < 2; ++k ){\n\t\t\t\t\t\tif( map[ i - 1 ][ j + k ] == 0 ){\n\t\t\t\t\t\t\tmemo[ i ][ j ] += memo[ i - 1 ][ j + k ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( map[ i - 2 ][ j ] == 2 ){\n\t\t\t\t\tmemo[ i ][ j ] += memo[  i - 2 ][ j ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor( int i = 1; i < X + 1; ++i ){\n\t\t\tans += memo[ Y ][ i ];\n\t\t\tif( map[ Y - 1 ][ i ] == 2 ){\n\t\t\t\tans += memo[ Y - 1 ][ i ];\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint solve(int x,int y);\nint ax,ay;\nint mas[200][200];\nint memo[200][200];\nint main(){\n  while(1){\n    for(int i=0;i<200;i++){\n      for(int j=0;j<200;j++){\n\tmemo[i][j]=0;\n      }\n    }\n    int ans=0;\n    cin>>ax>>ay;\n    if(ax==0 && ay==0) break;\n    \n    for(int i=0;i<ay;i++){\n      for(int j=0;j<ax;j++){\n\tcin>>mas[i][j];\n      }\n    }\n    \n    for(int i=0;i<ax;i++){\n      if(mas[0][i]!=1){\n\tans+=solve(i,0);\n      }\n    }\n    cout<<ans<<endl;\n  }\n}\nint solve(int x,int y){\n  if(memo[y][x]!=0){\n    return memo[y][x];\n  }\n  else if(y>=ay){\n    return 1;\n  }else if(mas[y][x]==1){\n    return 0;\n  }else if(mas[y][x]==2){\n    return solve(x,y+2);\n  } \n  else{\n    int anss=0; \n    if(mas[y+1][x]!=1){\n      anss+=solve(x,y+1);\n    }\n    if(x+1<ax && mas[y+1][x+1]==0 && y+1!=ay){\n      anss+=solve(x+1,y+1);\n    }\n    if(0<=x-1 && mas[y+1][x-1]==0 && y+1!=ay){\n      anss+=solve(x-1,y+1);\n    }\n    return memo[y][x]=anss;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint main() {\n\tint width, height, m[15][15];\n\twhile (cin >> width >> height, width && height) {\n\t\tfor (int y = 0; y < height; ++y)\n\t\t\tfor (int x = 0; x < width; ++x)\n\t\t\t\tcin >> m[y][x];\n\n\t\tint sum = 0, pattern[15][15] = {0};\n\t\tfor (int x = 0; x < width; ++x)\n\t\t\tpattern[0][x] = 1;\n\n\t\tfor (int y = 0; y < height-1; ++y)\n\t\t\tfor (int x = 0; x < width; ++x)\n\t\t\t\tif (m[y][x] == 0) {\n\t\t\t\t\tif (x - 1 >= 0 && m[y+1][x-1] == 0) pattern[y+1][x-1] += pattern[y][x];\n\t\t\t\t\tif (x + 1 < width && m[y+1][x+1] == 0) pattern[y+1][x+1] += pattern[y][x];\n\t\t\t\t\tif (m[y+1][x] != 1) pattern[y+1][x] += pattern[y][x];\n\t\t\t\t}\n\t\t\t\telse if (m[y][x] == 2) {\n\t\t\t\t\tif (y + 2 == height) sum += pattern[y][x];\n\t\t\t\t\telse if (m[y+2][x] != 1) pattern[y+2][x] += pattern[y][x];\n\t\t\t\t}\n\n\t\tfor (int x = 0; x < width; ++x)\n\t\t\tsum += pattern[width-1][x];\n\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#include<algorithm>\nusing namespace std;\nint vx[3]={-1,0,1};\nint main(){\n  int x,y;\n  while(cin>>y>>x,x+y!=0){\n    int Map[y+5][x+5]={0};\n    int cnt=0;\n    for(int i=1;i<=y;i++)\n      for(int j=1;j<=x;j++)\n\tcin>>Map[i][j];\n    queue<pair<int,int> >qii;\n    for(int i=1;i<=x;i++){\n      if(Map[1][i]!=1)\n\tqii.push(make_pair(1,i));\n    }\n    while(!(qii.empty())){\n      pair<int,int>now = qii.front();\n      qii.pop();\n      \n      if(now.second<1||now.second>x)\n\tcontinue;\n      if(now.first > y-1){\n\tcnt++;\n\tcontinue;\n      }\n      switch(Map[now.first][now.second]){\n      case 0:\n\tfor(int i=0;i<3;i++){\n\t  if(Map[now.first+1][now.second+vx[i]]==0)\n\t    qii.push(make_pair(now.first+1,now.second+vx[i]));\n\t}\n\tif(Map[now.first+1][now.second]==2)\n\t  qii.push(make_pair(now.first+1,now.second));\n\t  break;\n\tcase 2:\n\t  if(Map[now.first+2][now.second]!=1)\n\t    qii.push(make_pair(now.first+2,now.second));\n\t  break;\n      }\n    }\n    cout<<cnt<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define N 15\nusing namespace std;\nvoid func(int,int);\nint jump(int,int);\nint X,Y,data[N][N],memo[N][N];\nint main(){\n  while(1){\n    cin >> X >> Y;\n    if(X==0&&Y==0) break;\n    for(int i=0;i<Y;i++)\n      for(int j=0;j<X;j++) cin >> data[i][j],memo[i][j]=0;\n    for(int i=0;i<X;i++)\n      if(data[0][i]==0) func(0,i);\n    int cnt=0;\n    for(int i=0;i<X;i++) cnt+=memo[0][i];\n    cout << cnt << endl;\n  }\n  return 0;\n}\nvoid func(int y,int x){\n  if(y==Y-1){\n    memo[Y-1][x]=1;\n    return ;\n  }\n  if(0<=x-1&&data[y+1][x-1]==0){\n    if(memo[y+1][x-1]==0) func(y+1,x-1);\n    memo[y][x]+=memo[y+1][x-1];\n  }\n  if(x+1<X&&data[y+1][x+1]==0){\n    if(memo[y+1][x+1]==0) func(y+1,x+1);\n    memo[y][x]+=memo[y+1][x+1];\n  }\n  if(data[y+1][x]==0){\n    if(memo[y+1][x]==0) func(y+1,x);\n    memo[y][x]+=memo[y+1][x];\n  }\n  if(data[y+1][x]==2){\n    int r=jump(y+1,x);\n    if(r==-2) memo[y][x]+=1;\n    else if(r!=-1){\n      if(memo[r][x]==0) func(r,x);\n      memo[y][x]+=memo[r][x];\n    }\n  }\n  if(memo[y][x]==0) data[y][x]=1;\n}\nint jump(int y,int x){\n  while(1){\n    y+=2;\n    //    if(y>Y-1) return -2;\n    if(data[y][x]==1) break;\n    if(y>=Y-1) return -2;\n    if(data[y][x]==0) return y;\n  }\n  return -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n\nusing namespace std;\n\n\nint main() {\n\twhile(1) {\n\t\tint x, y;\n\t\tcin >> y >> x;\n\t\tif(x==0 && y==0) break;\n\t\tint field[x][y];\n\t\tfor(int i=0; i<x; i++) {\n\t\t\tfor(int j=0; j<y; j++) {\n\t\t\t\tcin >> field[i][j];\n\t\t\t}\n\t\t}\n\t\tint dp[x+1][y];\n\t\tfor(int i=0; i<x+1; i++) {\n\t\t\tfor(int j=0; j<y; j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<x; i++) {\n\t\t\tfor(int j=0; j<y; j++) {\n\t\t\t\tif(i==0 && field[i][j] == 0) dp[i][j] = 1;\n\t\t\t\telse {\n\t\t\t\t\tif(field[i][j] == 0) {\n\t\t\t\t\t\tif(0<j && field[i-1][j-1] == 0) dp[i][j] += dp[i-1][j-1];\n\t\t\t\t\t\tif(field[i-1][j] == 0) dp[i][j] += dp[i-1][j];\n\t\t\t\t\t\tif(j<y-1 && field[i-1][j+1] == 0) dp[i][j] += dp[i-1][j+1];\n\t\t\t\t\t}\n\t\t\t\t\tif(field[i][j] == 2) {\n\t\t\t\t\t\tdp[i][j] += dp[i-1][j];\n\t\t\t\t\t\tdp[i+2][j] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<y; i++) dp[x][i] += dp[x-1][i];\n\n\t\tint sum=0;\n\t\tfor(int i=0; i<y; i++) sum += dp[x][i];\n\t\tcout << sum << endl;\n\n\t\t//cout << endl;\n\t\t//for(int i=0; i<x+1; i++) {\n\t\t\t//for(int j=0; j<y; j++) {\n\t\t\t\t//cout << dp[i][j] << ' ';\n\t\t\t//}\n\t\t\t//cout << endl;\n\t\t//}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint fld[17][17];\nint cnt[17][17];\n\nint main()\n{\n\tint X,Y,S;\n\twhile(cin >> X >> Y, (X||Y))\n\t{\n\t\tfor(int y=0; y<17; y++)\n\t\tfor(int x=0; x<17; x++)\n\t\t{\n\t\t\tfld[y][x] = 1;\n\t\t\tcnt[y][x] = 0;\n\t\t}\n\n\t\tfor(int y=0; y< Y; y++)\n\t\tfor(int x=1; x<=X; x++)\n\t\t{\n\t\t\tcin >> fld[y][x];\n\t\t\tcnt[y][x] = ((y==0&&fld[y][x]==0)?1:0);\n\t\t}\n\n\t\tfor(int y=0; y< Y-1; y++)\n\t\tfor(int x=1; x<=X  ; x++)\n\t\t{\n\t\t\tif(fld[y][x]==0)\n\t\t\t{\n\t\t\t\tif(fld[y+1][x+1]==0) cnt[y+1][x+1]+=cnt[y][x];\n\t\t\t\tif(fld[y+1][x-1]==0) cnt[y+1][x-1]+=cnt[y][x];\n\t\t\t\tif(fld[y+1][x  ]!=1) cnt[y+1][x  ]+=cnt[y][x]; \n\t\t\t}\n\t\t\tif(fld[y][x]==2)\n\t\t\t{\n\t\t\t\tcnt[y+2][x]+=cnt[y][x];\n\t\t\t}\n\t\t}\n\n\t\tS=0;\n\t\tfor(int y=Y-1; y< Y+2; y++)\n\t\tfor(int x=1  ; x<=X  ; x++)\n\t\t{\n\t\t\tS+=cnt[y][x];\n\t\t}\n\n\t\tcout << S << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nint main(void){\n\tint X,Y;\n\t\n\twhile(scanf(\"%d%d\", &X, &Y) && X && Y){\n\t\tint masu[32][32]={0};\n\t\tint co[32][32]={0};\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < Y; i++){\n\t\t\tfor(int j = 0; j < X; j++){\n\t\t\t\tscanf(\"%d\", &masu[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < X; i++){\n\t\t\tif(!masu[0][i])co[0][i] = 1;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < Y-1; i++){\n\t\t\tfor(int j = 0; j < X; j++){\n\t\t\t\tif(masu[i][j] == 0){\n\t\t\t\t\tif(masu[i+1][j] != 1)co[i+1][j] += co[i][j];\n\t\t\t\t\tif(masu[i+1][j+1] == 0)co[i+1][j+1] += co[i][j];\n\t\t\t\t\tif(masu[i+1][j-1] == 0 && j-1 > -1)co[i+1][j-1] += co[i][j];\n\t\t\t\t}else if(masu[i][j] != 1){\n\t\t\t\t\tco[i+2][j] += co[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < X; i++){\n\t\t\tans += co[Y-1][i];\n\t\t}\n\t\tfor(int i = 0; i < X; i++){\n\t\t\tans += co[Y][i];\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//define\n#define int long long\n#define UNIQUE(v) v.erase(unique(all(v)), v.end());\n#define ZIP(v) sort(all(v)),UNIQUE(v)\n#define ADD(a, b) a = (a + b) % mod\n#define SUB(a, b) a = (a+mod-b)%mod\n#define MUL(a, b) a = (a * b) % mod\n#define repi(i,m,n) for(int i = m;i < n;i++)\n#define drep(i,n,m) for(int i = n;i >= m;i--)\n#define rep(i,n) repi(i,0,n)\n#define rrep(i,n) repi(i,1,n+1)\n#define chmin(x,y) x = min(x,y)\n#define chmax(x,y) x = max(x,y)\n#define all(v) v.begin(),v.end()\n#define rall(v) v.rbegin(), v.rend()\n#define dmp(x,y) make_pair(x,y)\n#define pb(x) push_back(x)\n#define fi first\n#define se second\n//template\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, const pair<T, U> &p){\n  os << p.first << \" \" << p.second;return os;\n}\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &v){\n  for (auto it = v.begin();it != v.end();++it){\n    if (it != v.begin())os << \" \";os << *it;\n  }return os;\n}\ntemplate<typename T, int SIZE>\nint array_length(const T (&)[SIZE]){return SIZE;}\ntemplate<typename T, int N>\nvoid print(const T (&a)[N], int s = N, int t = -1, bool f = true){\n\tif(t == -1){rep(i,s){if(i)cout << \" \";cout << a[i];}}\n\telse repi(i,s,t){if(i!=s)cout << \" \";cout << a[i];}\n\tif(f)cout << \"\\n\";\n}\ntemplate<typename T, int N1, int N2>\nvoid print(const T (&a)[N1][N2], int h = N1, int w = N2){\n\trep(i,h){rep(j,w){cout << a[i][j] << \" \\n\"[j==w-1];}}\n}\n//typedef\ntypedef pair<int,int> P;\ntypedef pair<int, P> PP;\ntypedef pair<P, int> Pi;\ntypedef vector<int> vi;\ntypedef deque<int> dq;\nconst int inf = 1e9+7;\nconst int INF = 1e18+7;\n\n\n\n\nint a[20][20], dp[20][20];\nint dy[] = {1, 1, 1}, dx[] = {-1, 0, 1};\nvoid init(){\n\trep(i,20)rep(j,20)dp[i][j] = 0;\n}\n\nsigned main(){\n\twhile(1){\n\t\tint h, w;\n\t\tcin >> w >> h;\n\t\tif(w == 0 and h == 0)break;\n\t\trep(i,h)rep(j,w)cin >> a[i][j];\n\t\tinit();\n\t\trep(i,w)if(a[0][i] == 0)dp[0][i] = 1;\n\t\trep(i,h){\n\t\t\trep(j,w){\n\t\t\t\tif(a[i][j] >= 1)continue;\n\t\t\t\tif(i == h-1){\n\t\t\t\t\tdp[i+1][j] += dp[i][j];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\trep(k,3){\n\t\t\t\t\tint yy = i+dy[k], xx = j+dx[k];\n\t\t\t\t\tif(xx < 0 or w <= xx)continue;\n\t\t\t\t\twhile(k == 1 and a[yy][xx] == 2)yy += 2;\n\t\t\t\t\tif(a[yy][xx] == 2)continue;\n\t\t\t\t\tdp[yy][xx] += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\trepi(i,h,20)rep(j,w)ans += dp[i][j];\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <list>\n\nusing namespace std;\n\nlong long int INF = 1e18;\nlong long int MOD = 1e9 + 7;\n\ntypedef pair<long long int, long long int> P;\n\nint main(){\n\t\n\twhile(true){\n\t\tint W, H;\n\t\tcin >> W >> H;\n\t\tif(W == 0){\n\t\t\tbreak;\n\t\t}\n\t\tint F[20][20];\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tfor(int j = 1; j <= W; j++){\n\t\t\t\tcin >> F[i][j];\n\t\t\t}\n\t\t}\n\t\tlong long int DP[20][20] = {};\n\t\tfor(int i = 1; i <= W; i++){\n\t\t\tDP[0][i] = 1;\n\t\t}\n\t\tfor(int i = 0; i < H - 1; i++){\n\t\t\tfor(int j = 1; j <= W; j++){\n\t\t\t\tif(F[i][j] == 0){\n\t\t\t\t\tif(F[i + 1][j - 1] == 0){\n\t\t\t\t\t\tDP[i + 1][j - 1] += DP[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tif(F[i + 1][j + 1] == 0){\n\t\t\t\t\t\tDP[i + 1][j + 1] += DP[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tDP[i + 1][j] += DP[i][j];\n\t\t\t\t}else if(F[i][j] == 2){\n\t\t\t\t\tDP[i + 2][j] += DP[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong long int ans = 0;\n\t\tfor(int i = 1; i <= W; i++){\n\t\t\tif(F[H - 1][i] != 1){\n\t\t\t\tans += DP[H - 1][i];\n\t\t\t}\n\t\t\tans += DP[H][i];\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nint main(){\n\tint n,m;\n\tint masu[17][17];\n\tint ura[17][17];\n\tcin>>n>>m;\n\tfor(int i=0;i<17;i++){\n\t\tfor(int j=0;j<17;j++){\n\t\t\tmasu[i][j]=ura[i][j]=0;\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tcin>>masu[i][j];\n\t\t}\n\t}\n\t\n\tfor(int j=1;j<=m;j++){\n\t\tura[0][j]=1;\n\t}\n\t\n\t\n\tfor(int i=0;i<n-1;i++){\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tif(masu[i][j]==0){\n\t\t\t\tif(masu[i+1][j-1]==0){\n\t\t\t\t\tura[i+1][j-1]+=ura[i][j];\n\t\t\t\t}\n\t\t\t\tif(masu[i+1][j]!=1){\n\t\t\t\t\tura[i+1][j]+=ura[i][j];\n\t\t\t\t}\n\t\t\t\tif(masu[i+1][j+1]==0){\n\t\t\t\t\tura[i+1][j+1]+=ura[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(masu[i][j]==2){\n\t\t\t\tif(masu[i+2][j]!=1){\n\t\t\t\t\tura[i+2][j]+=ura[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint cont=0;\n\tfor(int i=1;i<=n;i++){\n\t\tcont+=ura[n][i]+ura[n-1][i];\n\t}\n\t\n\t\n\t/*\n\tfor(int i=0;i<17;i++){\n\t\tfor(int j=0;j<17;j++){\n\t\t\tprintf(\"%2d \",ura[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}*/\n\tprintf(\"%d\\n\",cont);\n\t\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint dp[16][15];\nint h,w;\nint map[16][15];\nmain()\n{\n\twhile(cin>>w>>h,w)\n\t{\n\t    for(int i=0;i<=h;i++)for(int j=0;j<w;j++)map[i][j]=0;\n\t\tfor(int i=0;i<h;i++)\n\t\t{\n\t\t\tfor(int j=0;j<w;j++)\n\t\t\t{\n\t\t\t\tcin>>map[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=h;i++)for(int j=0;j<w;j++)dp[i][j]=0;\n\t\tfor(int i=0;i<w;i++)dp[0][i]=map[0][i]==0;\n\t\tfor(int i=0;i<h;i++)\n\t\t{\n\t\t\tfor(int j=0;j<w;j++)\n\t\t\t{\n\t\t\t\tif(dp[i][j]==0||map[i][j]==1)continue;\n\t\t\t\tif(map[i][j]==2)\n\t\t\t\t{\n\t\t\t\t\tdp[i+2<=h?i+2:h][j]+=dp[i][j];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(i<h-1&&j>0)\n\t\t\t\t{\n\t\t\t\t\tif(map[i+1][j-1]==0)dp[i+1][j-1]+=dp[i][j];\n\t\t\t\t}\n\t\t\t\tif(i<h-1&&j<w-1)\n\t\t\t\t{\n\t\t\t\t\tif(map[i+1][j+1]==0)dp[i+1][j+1]+=dp[i][j];\n\t\t\t\t}\n\t\t\t\tif(map[i+1][j]!=1)dp[i+1][j]+=dp[i][j];\n\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t\tfor(int j=0;j<w;j++)ans+=dp[h][j];\n\t\tcout<<ans<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\nusing namespace std;\n\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint W, H;\n\twhile(cin >> W >> H, W) {\n\t\tint b[20][15] = { 0 };\n\t\tfor(int i = 0; i < H; i++) {\n\t\t\tfor(int j = 0; j < W; j++) {\n\t\t\t\tcin >> b[i][j];\n\t\t\t}\n\t\t}\n\n\t\tint dp[20][15] = { 0 };\n\t\tfor(int i = 0; i < W; i++) {\n\t\t\tif(b[0][i] != 1)\n\t\t\t\tdp[0][i] = 1;\n\t\t}\n\n\t\tfor(int i = 0; i < H - 1; i++) {\n\t\t\tfor(int j = 0; j < W; j++) {\n\t\t\t\tif(b[i][j] == 0) {\n\t\t\t\t\tfor(int d = -1; d <= 1; d++) {\n\t\t\t\t\t\tif(j + d < 0 || W <= j + d) continue;\n\t\t\t\t\t\tif(b[i + 1][j + d] == 0 || b[i + 1][j + d] == 2 && d == 0)\n\t\t\t\t\t\t\tdp[i + 1][j + d] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(b[i][j] == 2) {\n\t\t\t\t\tdp[i + 2][j] += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor(int i = H - 1; i <= H; i++) {\n\t\t\tfor(int j = 0; j < W; j++) {\n\t\t\t\tif(b[i][j] != 1)\n\t\t\t\t\tans += dp[i][j];\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint w,h;\nint mp[20][20],memo[20][20];\nint dx[] = {-1,0,1};\n\nvoid saiki(int x,int y) {\n  if(y >= h-1) memo[y][x]++;\n  else if(mp[y][x] != 1) {\n    for(int i=0;i<3;i++) {\n      int nx = dx[i]+x, ny = y+1;\n      if(nx <0|| nx >= w ||mp[ny][nx] == 1) continue;\n      if(memo[ny][nx] > 0 && mp[ny][nx] == 0) memo[y][x] += memo[ny][nx];\n      else if(mp[ny][nx] == 0){\n\tsaiki(nx,ny);\n\tmemo[y][x] += memo[ny][nx];\n      }\n      else if(nx==x && mp[ny][nx] == 2){\n\tint ty = ny;\n\twhile(mp[ty][nx] == 2) ty+=2;\n\tif(mp[ty][nx] == 0 && memo[ty][nx] == 0){\n\t  saiki(nx,ty);\n\t  memo[y][x] += memo[ty][nx];\n\t}\n\telse if(mp[ty][nx] == 0 && memo[ty][nx] > 0) memo[y][x] += memo[ty][nx];\n      }\n    }\n    if(memo[y][x] == 0) mp[y][x] = -1;\n  }\n}\n  \nint main() {\n  while(1) {\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n    for(int i=0;i<=19;i++)\n      for(int j=0;j<=19;j++)memo[i][j] = mp[i][j] = 0;\n    \n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)cin >> mp[i][j];\n \n    for(int i=0;i<w;i++) \n      if(mp[0][i] !=1) saiki(i,0);\n    \n    int cnt = 0;\n    for(int i=0;i<w;i++)\n      if(memo[0][i] > 0) cnt+=memo[0][i];\n    cout <<cnt<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\n\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nint x, y, c[50][50], dp[50][50];\nconst int dx[3] = {-1, 0, 1};\n\nvoid solve() {\n  memset(dp, 0, sizeof dp);\n  \n  rep(i,y) rep(j,x) cin>>c[i][j];\n  \n  rep(i,x) if (c[0][i] == 0) dp[0][i] = 1;\n  \n  rep(i,y-1) rep(j,x) {\n    if (c[i][j] == 0) {\n      rep(z,3) {\n        int ti = i + 1, tj = j + dx[z];\n        if (tj < 0 || tj >= x) continue;\n        if (c[ti][tj] == 1) continue;\n        if (c[ti][tj] == 2 && z != 1) continue;\n        dp[ti][tj] += dp[i][j];\n      }\n    } else if (c[i][j] == 2 /*&& c[i+2][j] != 1*/) {\n      dp[i+2][j] += dp[i][j];\n    }\n  }\n  /*\n  rep(i,y+1) {\n    rep(j,x) printf(\"%8d\",dp[i][j]);\n    cout<<endl;\n  }*/\n  \n  int res = 0;\n  rep(j,x) res += dp[y][j] + dp[y-1][j];\n  cout<<res<<endl;\n}\n\nint main (int argc, char const* argv[]) {\n  while (cin>>x>>y, x||y) {\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nconst int MAX_Y = 30;\nconst int MAX_X = 30;\nint mx, my, c[MAX_Y][MAX_X], dp[MAX_Y][MAX_X];\n\nconst int dx[3] = {-1, 0, 1};\nconst int dy[3] = {1, 1, 1};\n\nint dfs(int y, int x) {  \n  int res = 0;\n  if (y == my - 1) return 1;\n  \n  if (c[y][x] == 2) {\n    if (y+2 >= my - 1) return 1;\n    res += dfs(y+2, x);\n    return res;\n  }\n  \n  rep(z,3) {\n    int tx = x + dx[z], ty = y + dy[z];\n    if (tx < 0 || ty < 0 || tx >= mx || ty >= my) continue;\n    if (c[ty][tx] == 1) continue;\n    if (c[ty][tx] == 2 && tx != x) continue;\n    res += dfs(ty, tx);\n  }\n\n  return res;\n}\n\nvoid solve() {\n  memset(dp, -1, sizeof dp);\n  rep(i,my) rep(j,mx) cin>>c[i][j];\n\n  int res = 0;\n  rep(i,mx) {\n    if (c[0][i] == 1) continue;\n    res += dfs(0, i);\n  }\n  cout<<res<<endl;\n}\n\nint main (int argc, char const* argv[]) {\n  while (cin>>mx>>my, mx||my) {\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\t#include <iostream>\n\t#define rep2(x,from,to) for(int x=(from);(x)<(to);(x)++)\n\t#define rep(x,to) rep2(x,0,to)\n\tusing namespace std;\n\tint main(){\n\t\tint x, y;\n\t\twhile(cin >> x >> y && (x||y) ) {\n\t\t\tint b[15][15] = {};\n\t\t\trep(i,y) {\n\t\t\t\trep(j,x) {\n\t\t\t\t\tcin >> b[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ret[20][20] = {};\n\t\t\trep(i,x) {\n\t\t\t\tif(b[0][i] == 0) {\n\t\t\t\t\tret[0][i+1] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep2(i,1,y) {\n\t\t\t\trep(j,x) {\n\t\t\t\t\tif(b[i][j] == 0) {\n\t\t\t\t\t\tret[i][j+1] += ret[i-1][j] + ret[i-1][j+1] + ret[i-1][j+2];\n\t\t\t\t\t\trep2(k,-1,2) {\n\t\t\t\t\t\t\tif(b[i-1][j+k] == 2) ret[i][j+1] -= ret[i-1][j+k+1];\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(b[i][j] == 2) {\t\n\t\t\t\t\t\tif(b[i-1][j] == 0) ret[i][j+1] += ret[i-1][j+1];\n\t\t\t\t\t\tif(y <= i+2 || b[i+2][j] != 1) ret[i+2][j+1] += ret[i][j+1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = 0;\n\t\t\trep2(i,y-1,y+2) {\n\t\t\t\trep(j,x) {\n\t\t\t\t\tif(y <= i || b[i][j] != 2) ans += ret[i][j+1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << ans << endl;\n\t\t}\n\t}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nint grid[30][30];\n\ninline bool isAtObstacle(int x, int y) {\n  return grid[y][x] == 1;\n}\n\ninline bool isAtSkiJump(int x, int y) {\n  return grid[y][x] == 2;\n}\n\nint main() {\n  int n, m;\n  \n  while(cin >> m >> n && n) {\n    fill(grid[0], grid[0]+900, 0);\n    for(int i=0; i<n; i++) {\n      for(int j=0; j<m; j++) {\n\tcin >> grid[i][j];\n      }\n    }\n    \n    int dp[30][30][2] = {{{}}};\n    \n    for(int j=0; j<m; j++) {\n      if(grid[0][j]==0) { dp[0][j][0] = 1; }\n    }\n    \n    int extra = 0;\n    for(int i=0; i<n-1; i++) {\n      for(int j=0; j<m; j++) {\n\t\n\t// there is no case such that skier is at obstacle.\n\tif(isAtObstacle(j, i)) continue;\n\t\n\t// A skier is at a ski jump.\n\tif(isAtSkiJump(j, i)) {\n\t  if(i+2 > n-1) extra += dp[i][j][0];\n\t  else {\n\t    if(isAtObstacle(j, i+2)) continue;\n\t    dp[i+2][j][0] += dp[i][j][0];\n\t  }\n\t}\n\t\n\t// skiing without jump.\n\telse {\n\t  // from the upper left\n\t  if( j-1 >= 0\n\t      && !isAtObstacle(j-1, i+1)\n\t      && !isAtSkiJump (j-1, i+1) ) {\n\t    dp[i+1][j-1][1] += dp[i][j][0] + dp[i][j][1];\n\t  }\n\t  \n\t  // from the above\n\t  if( !isAtObstacle(j, i+1) ) {\n\t    dp[i+1][j][0] += dp[i][j][0] + dp[i][j][1];\n\t  }\n\t  \n\t  // from the upper right\n\t  if( j+1 < m\n\t      && !isAtObstacle(j+1, i+1)\n\t      && !isAtSkiJump (j+1, i+1) ) {\n\t    dp[i+1][j+1][1] += dp[i][j][0] + dp[i][j][1];\n\t  }\n\t}\n\t\n      }\n    }\n    \n    int ans = 0;\n    for(int i=0; i<m; i++) {\n      ans += dp[n-1][i][0] + dp[n-1][i][1];\n    }\n    \n    cout << ans + extra << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define N 15\nusing namespace std;\nvoid func(int,int);\nint jump(int,int);\nint X,Y,data[N][N],memo[N][N];\nint main(){\n  while(1){\n    cin >> X >> Y;\n    if(X==0&&Y==0) break;\n    for(int i=0;i<N;i++){\n      for(int j=0;j<N;j++){\n\tdata[i][j]=0;\n      }\n    }\n    for(int i=0;i<Y;i++)\n      for(int j=0;j<X;j++) cin >> data[i][j],memo[i][j]=0;\n    for(int i=0;i<X;i++)\n      if(data[0][i]==0) func(0,i);\n    int cnt=0;\n    for(int i=0;i<X;i++) cnt+=memo[0][i];\n    cout << cnt << endl;\n  }\n  return 0;\n}\nvoid func(int y,int x){\n  if(y==Y-1){\n    memo[Y-1][x]=1;\n    return ;\n  }\n  if(0<=x-1&&data[y+1][x-1]==0){\n    if(memo[y+1][x-1]==0) func(y+1,x-1);\n    memo[y][x]+=memo[y+1][x-1];\n  }\n  if(x+1<X&&data[y+1][x+1]==0){\n    if(memo[y+1][x+1]==0) func(y+1,x+1);\n    memo[y][x]+=memo[y+1][x+1];\n  }\n  if(data[y+1][x]==0){\n    if(memo[y+1][x]==0) func(y+1,x);\n    memo[y][x]+=memo[y+1][x];\n  }\n  if(data[y+1][x]==2){\n    int r=jump(y+1,x);\n    if(r==-2) memo[y][x]+=1;\n    else if(r!=-1){\n      if(memo[r][x]==0) func(r,x);\n      memo[y][x]+=memo[r][x];\n    }\n  }\n  if(memo[y][x]==0) data[y][x]=1;\n}\nint jump(int y,int x){\n  while(1){\n    y+=2;\n    if(data[y][x]==1) break;\n    if(y>=Y-1) return -2;\n    if(data[y][x]==0) return y;\n  }\n  return -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nint X, Y;\nint field[15 + 2][15 + 2];\nint dp[15 + 2][15 + 2];\n\nvoid solve() {\n\tfor (int i = 1; i <= X; i++) {\n\t\tif (field[0][i] == 0) {\n\t\t\tdp[0][i] = 1;\n\t\t}\n\t}\n\tfor (int y = 0; y < Y - 1; y++) {\n\t\tfor (int x = 1; x <= X; x++) {\n\t\t\tif (field[y][x] == 2) {\n\t\t\t\tif (field[y + 2][x] != 1) {\n\t\t\t\t\tdp[y + 2][x] += dp[y][x];\n\t\t\t\t}\n\t\t\t} else if (field[y][x] == 0) {\n\t\t\t\tif (field[y + 1][x - 1] == 0) {\n\t\t\t\t\tdp[y + 1][x - 1] += dp[y][x];\n\t\t\t\t}\n\t\t\t\tif (field[y + 1][x] != 1) {\n\t\t\t\t\tdp[y + 1][x] += dp[y][x];\n\t\t\t\t}\n\t\t\t\tif (field[y + 1][x + 1] == 0) {\n\t\t\t\t\tdp[y + 1][x + 1] += dp[y][x];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint sum = 0;\n\tfor (int y = Y - 1; y <= Y; y++) {\n\t\tfor (int x = 1; x <= X; x++) {\n\t\t\tsum += dp[y][x];\n\t\t}\n\t}\n\tprintf(\"%d\\n\", sum);\n}\n\nint main() {\n\twhile (scanf(\"%d %d \", &X, &Y) == 2) {\n\t\tif (X == 0 && Y == 0) {return 0;}\n\n\t\tfill(dp[0], &dp[15 + 2 - 1][15 + 2], 0);\n\t\tfill(field[0], &field[15 + 2 - 1][15 + 2], 1);\n\t\tfor (int y = Y; y <= Y + 1; y++) {\n\t\t\tfor (int x = 1; x <= X; x++) {\n\t\t\t\tfield[y][x] = 2;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < Y; i++) {\n\t\t\tfor (int j = 1; j <= X; j++) {\n\t\t\t\tscanf(\"%d \", &field[i][j]);\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tfor (int i = 0; i < Y + 2; i++) {\n\t\t\tfor (int j = 0; j < X + 2; j++) {\n\t\t\t\tprintf(\"%d \", field[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\t*/\n\t\tsolve();\n\t\t/*\n\t\tfor (int i = 0; i < Y + 2; i++) {\n\t\t\tfor (int j = 0; j < X + 2; j++) {\n\t\t\t\tprintf(\"%2d \", dp[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\t*/\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <sstream>\n#include <cmath>\n#include <queue>\n\nusing namespace std;\n\nint X, Y;\n\nbool is_inside(int x, int y){\n\tif(x < 0 || y < 0 || x >= X || y >= Y){\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nint main(){\n\t\n\tint course[20][20];\n\tlong long int sum[20][20];\n\t\n\twhile(true){\n\t\tcin >> X >> Y;\n\t\t\n\t\tif(X == 0 && Y == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < Y; i++){\n\t\t\tfor(int j = 0; j < X; j++){\n\t\t\t\tcin >> course[j][i];\n\t\t\t\tsum[j][i] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < X; i++){\n\t\t\tsum[i][0] = 1;\n\t\t}\n\t\t\n\t\tfor(int y = 0; y < Y; y++){\n\t\t\tfor(int x = 0; x < X; x++){\n\t\t\t\tif(course[x][y] == 0){\n\t\t\t\t\tfor(int dx = -1; dx <= 1; dx++){\n\t\t\t\t\t\tif(is_inside(x + dx, y + 1)){\n\t\t\t\t\t\t\tif((course[x + dx][y + 1] != 2 || dx == 0) && y != 0){\n\t\t\t\t\t\t\t\tsum[x + dx][y + 1] += sum[x][y];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else if(course[x][y] == 2){\n\t\t\t\t\tif(is_inside(x, y + 2)){\n\t\t\t\t\t\tsum[x][y + 2] += sum[x][y];\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tsum[x][y] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong long int ans = 0;\n\t\t\n\t\tfor(int i = 0; i < X; i++){\n\t\t\tif(course[i][Y - 1] == 0){\n\t\t\t\tans += sum[i][Y - 1];\n\t\t\t}\n\t\t\tif(Y >= 2 && course[i][Y - 2] == 2){\n\t\t\t\tans += sum[i][Y - 2];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nint grid[30][30];\n\ninline bool isAtObstacle(int x, int y) {\n  return grid[y][x] == 1;\n}\n\ninline bool isAtSkiJump(int x, int y) {\n  return grid[y][x] == 2;\n}\n\nint main() {\n  int n, m;\n  \n  while(cin >> n >> m && n) {\n    fill(grid[0], grid[0]+900, 0);\n    for(int i=0; i<n; i++) {\n      for(int j=0; j<m; j++) {\n\tcin >> grid[i][j];\n      }\n    }\n    \n    long long dp[30][30][2] = {};\n    \n    for(int j=0; j<m; j++) {\n      if(grid[0][j]==0) { dp[0][j][0] = 1; }\n    }\n    \n    for(int i=0; i<n-1; i++) {\n      for(int j=0; j<m; j++) {\n\t\n\t// there is no case such that skier is at obstacle.\n\tif(isAtObstacle(j, i)) {\n\t  dp[i][j][0] = dp[i][j][1] = 0;\n\t  continue;\n\t}\n\t\n\t// A skier is at a ski jump.\n\tif(isAtSkiJump(j, i)) {\n\t  if(i+2 > n-1) dp[n-1][j][0] += dp[i][j][0];\n\t  else {\n\t    if(isAtObstacle(j, i+2)) continue;\n\t    dp[i+2][j][0] += dp[i][j][0];\n\t  }\n\t}\n\t\n\t// skiing without jump.\n\telse {\n\t  // from the upper left\n\t  if( j-1 >= 0\n\t      && !isAtObstacle(j-1, i+1)\n\t      && !isAtSkiJump (j-1, i+1) ) {\n\t    dp[i+1][j-1][1] += dp[i][j][0] + dp[i][j][1];\n\t  }\n\t  \n\t  // from the above\n\t  if( !isAtObstacle(j, i+1) ) {\n\t    dp[i+1][j][0] += dp[i][j][0] + dp[i][j][1];\n\t  }\n\t  \n\t  // from the upper right\n\t  if( j+1 < m\n\t      && !isAtObstacle(j+1, i+1)\n\t      && !isAtSkiJump (j+1, i+1) ) {\n\t    dp[i+1][j+1][1] += dp[i][j][0] + dp[i][j][1];\n\t  }\n\t}\n\t\n      }\n    }\n    \n    int ans = 0;\n    for(int i=0; i<m; i++) {\n      ans += dp[n-1][i][0] + dp[n-1][i][1];\n    }\n    \n    cout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\ntypedef long long int ll;\n//typedef int ll;\nll w,h,xd[]={1,0,-1},p,u[20][20],d[20][20];\nll ret(ll x,ll y){\n\tll s=x,sum=0;\n\tif(h-1<=y){\n\t\treturn 1;\n\t}\n\tif(d[y][x]>=1)\n\t\treturn d[y][x];\n\telse if(u[y][x]==2)\n\t\treturn d[y][x]=ret(x,y+2);\n\telse if(u[y][x]==0){\n\t\ty++;\n\t\tfor(ll i=0;i<3;i++){\n\t\t\tx=s+xd[i];\n\t\t\tif(x>=0&&x<=w-1){\n    \t\t\tif(u[y][x]==2&&i==1)\n \t     \t\t\tsum+=d[y-1][s]=ret(x,y+2);\n\t\t\t\telse if(u[y][x]==0)\n\t\t\t\t\tsum+=d[y-1][s]=ret(x,y);\n\t\t\t}\n\t\t}\n\t\treturn d[y-1][s]=sum;\n\t}\n\treturn d[y][s]=-1;\n}\nint main(){\n\tll x,y;\n\twhile(cin>>w>>h,w||h){\n\t\tp=0;\n\t\tfor(ll i=0;i<h;i++)\n\t\tfor(ll j=0;j<w;j++){\n\t\t\tcin>>u[i][j];\n\t\t\td[i][j]=0;\n\t\t}\n\t\tfor(ll i=0;i<w;i++)\n\t\t\tu[h][i]=0;\n\t\tfor(ll i=0;i<w;i++){\n\t\t\tif(u[0][i]==0){\n\t\t\t\tx=i;\n\t\t\t\ty=0;\n\t\t\t\tp+=ret(x,y);\n\t\t\t}\n\t\t\telse if(u[0][i]==2){\n\t\t\t\tx=i;\n\t\t\t\ty=2;\n\t\t\t\tp+=ret(x,y);\n\t\t\t}\n\t\t}\n\t\tcout<<p<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(long long i=(a);i<(b);i++)\n#define REP(i,N) for(long long i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define fi first\n#define se second\n\n#define PI acos(-1.0)\n#define INF 1000000007\n#define EPS 1e-10\n#define MAX_N 20000\n#define MAX_M 16\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<double, double> PD;\ntypedef pair<string, ll> PS;\ntypedef vector<ll> V;\ntypedef pair<P, char> PC;\n\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(long long i=(a);i<(b);i++)\n#define REP(i,N) for(long long i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define fi first\n#define se second\n\n#define PI acos(-1.0)\n#define INF 1000000007\n#define EPS 1e-10\n#define MAX_N 20000\n#define MAX_M 16\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<double, double> PD;\ntypedef pair<string, ll> PS;\ntypedef vector<ll> V;\ntypedef pair<P, char> PC;\n\nint x, y;\nint field[16][16];\nint dp[16][16];\n\nint main(){\n\twhile (cin >> x >> y&&x + y){\n\t\tREP(i, 16){\n\t\t\tREP(j, 16){\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tfield[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tREP(i, y)REP(j, x)cin >> field[i][j];\n\t\tREP(j, x){\n\t\t\tif (field[0][j] == 0)dp[0][j] = 1;\n\t\t}\n\t\tREP(i, y - 1){\n\t\t\tREP(j, x){\n\t\t\t\tif (field[i][j] == 0){\n\t\t\t\t\tif (field[i + 1][j] != 1)dp[i + 1][j] += dp[i][j];\n\t\t\t\t\tif (j - 1 >= 0 && field[i + 1][j - 1] == 0){\n\t\t\t\t\t\tdp[i + 1][j - 1] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tif (j + 1 < x&&field[i + 1][j + 1] == 0){\n\t\t\t\t\t\tdp[i + 1][j + 1] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (field[i][j] == 2){\n\t\t\t\t\tif (i + 2 <= y - 1 && dp[i + 2][j] != 1){\n\t\t\t\t\t\tdp[i + 2][j] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tdp[i + 1][j] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//cout << endl;\n\t\t//REP(i, y){\n\t\t//\tREP(j, x){\n\t\t//\t\tcout << dp[i][j] << \" \";\n\t\t//\t}\n\t\t//\tcout << endl;\n\t\t//}\n\t\tint ans = 0;\n\t\tREP(j, x)ans += dp[y - 1][j];\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tint s,i,j,x,y,c[15][15],d[17][15];\n\twhile(cin >> x >> y) {\n\t\tif (x+y==0) break;\n\t\tfor (i=0;i<y;i++) for (j=0;j<x;j++) cin >> c[i][j];\n\t\tfor (i=0;i<y+2;i++) for (j=0;j<x;j++) d[i][j]=(i==0);\n\t\tfor (i=0;i<y-1;i++) for (j=0;j<x;j++) {\n\t\t\ts=d[i][j];\n\t\t\tif (c[i][j]==0) { \n\t\t\t\tif (j>0) if (c[i+1][j-1]==0) d[i+1][j-1]+=s;\n\t\t\t\tif (j<x-1) if (c[i+1][j+1]==0) d[i+1][j+1]+=s;\n\t\t\t\tif (c[i+1][j]!=1) d[i+1][j]+=s;\n\t\t\t}\n\t\t\tif (c[i][j]==2 && c[i+2][j]!=1) d[i+2][j]+=s;\n\t\t}\n\t\ts=0;\n\t\tfor (i=y-1;i<=y;i++) for (j=0;j<x;j++) s+=d[i][j];\n\t\tif (y==1) { s=0; for (i=0;i<x;i++) s+=(c[0][i]==0);}\n\t\tcout << s << endl; \n\t }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <set>\n#include <map>\n#include <list>\n#include <iterator>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <string>\n#include <cmath>\n#include <complex>\n#include <functional>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n#include <cstdlib>\n#include <cctype>\n#include <bitset>\n\n#define REP(i,m,n) for(int i=m;i<(int)n;i++)\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define rrep(i,n) for(int i = 1; i <= n; i++)\n#define drep(i,n) for(int i = n; i >= 0; i--)\n#define rp(i,c) rep(i,(int)c.size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define mp make_pair\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define v_delete(a,b) (a).erase(remove((a).begin(), (a).end(), b), (a).end())\n#define v_unique(a) (a).erase(unique((a).begin(), (a).end()), (a).end())\n#define VV(T) vector<vector< T > >\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\nconst int inf=1<<28;\nconst double INF=1e10,EPS=1e-9;\n\n\ntemplate<class T>int SIZE(T a){return a.size();}\ntemplate<class T>string IntToString(T num){string res;stringstream ss;ss<<num;return ss.str();}\ntemplate<class T>T StringToInt(string str){T res=0;for(int i=0;i<SIZE(str);i++)res=(res*10+str[i]-'0');return res;}\ntemplate<class T>T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate<class T>T lcm(T a,T b){return a/gcd(a,b)*b;}\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nint chmax(int& a,int b){\n\tif(b > a){\n\t\ta=b;\n\t}\n\treturn a;\n}\nint chmin(int& a,int b){\n\tif(b < a){\n\t\ta=b;\n\t}\n\treturn a;\n}\n\nint X,Y;\nint m[18][18];\nint dp[20][20];\n\n\nint main(int argc, char const *argv[])\n{\n\twhile(cin >> X >> Y, X){\n\t\tmemset(m, -1 ,sizeof(m));\n\t\tmemset(dp, 0 ,sizeof(m));\n\t\trep(i,Y){\n\t\t\trep(j,X){\n\t\t\t\tcin >> m[i+1][j+1];\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=X;i++){\n\t\t\tif(m[1][i]==1)\n\t\t\t\tdp[1][i]=0;\n\t\t\telse\n\t\t\t\tdp[1][i]=1;\n\t\t}\n\t\tfor(int i=2;i<=Y;i++){\n\t\t\tfor(int j=1;j<=X;j++){\n\t\t\t\tif(m[i][j]==1){\n\t\t\t\t\tdp[i][j]=0;\n\t\t\t\t}else if(m[i][j]== 2){\n\t\t\t\t\tif(m[i-1][j]==0)\n\t\t\t\t\t\tdp[i][j] += dp[i-1][j];\n\t\t\t\t\tif(m[i-2][j]==2)\n\t\t\t\t\t\tdp[i][j] += dp[i-2][j];\n\t\t\t\t}else{\n\t\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\t\tif(m[i-1][j+k]==0){\n\t\t\t\t\t\t\tdp[i][j] += dp[i-1][j+k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(m[i-2][j]==2)\n\t\t\t\t\t\tdp[i][j] += dp[i-2][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t//\tfor(int i=1;i<=Y;i++){\n\t//\t\tfor(int j=1;j<=X;j++){\n\t//\t\t\tcout << dp[i][j] << \" \";\n\t//\t\t}\n\t//\t\tcout << endl;\n\t//\t}\n\n\t\tfor(int i=1;i<=X;i++){\n\t\t\tif(m[Y][i]==0){\n\t\t\t\tans += dp[Y][i];\n\t\t\t}\n\t\t\tif(m[Y-1][i]==2){\n\t\t\t\tans += dp[Y-1][i];\n\t\t\t}\n\t\t}\n\t\tcout  << ans << endl;\n\n\t}\n\n\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint mx,my;\nint count;\nint field[17][17];//field[y][x];\n\nvoid init()\n{\n\tfor(int i=0;i<17;i++){\n\t\tfor(int j=0;j<17;j++){\n\t\t\tfield[i][j] = 0;\n\t\t}\n\t}\n}\n\nvoid DFS(int x,int y)\n{\n\tif(y >= my-1){\n\t\tcount++;\n\t\treturn;\n\t}\n\tint dx,dy;\n\tdx = x-1;dy = y+1;\n\tif(0<=dx && dx < mx && field[dy][dx] == 0)\n\t\tDFS(dx,dy);\n\tdx = x;dy = y+1;\n\tif(0<=dx && dx < mx && field[dy][dx] != 1){\n\t\tif(field[dy][dx]==2){\n\t\t\twhile(field[dy][dx]==2){\n\t\t\t\tdy+=2;\n\t\t\t}\n\t\t}\n\t\tDFS(dx,dy);\n\t}\n\tdx = x+1;dy = y+1;\n\tif(0<=dx && dx < mx && field[dy][dx] == 0)\n\t\tDFS(dx,dy);\n\treturn;\n}\n\nint main()\n{\n\twhile(cin >> mx >> my){\n\t\tif(mx == 0 && my == 0)\n\t\t\tbreak;\n\t\tfor(int i=0;i<my;i++){\n\t\t\tfor(int j=0;j<mx;j++){\n\t\t\t\tcin >> field[i][j];\n\t\t\t}\n\t\t}\n\t\tcount = 0;\n\t\tfor(int i=0;i<mx;i++){\n\t\t\tif(field[0][i] == 0){\n\t\t\t\tDFS(i,0);\n\t\t\t}\n\t\t}\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\n\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nint x, y, c[16][16], dp[30][30];\nconst int dx[3] = {-1, 0, 1};\n\nvoid solve() {\n  memset(dp, 0, sizeof dp);\n  \n  rep(i,y) rep(j,x) cin>>c[i][j];\n  \n  rep(i,x) if (c[0][i] == 0) dp[0][i] = 1;\n  \n  rep(i,y-1) rep(j,x) {\n    if (c[i][j] == 0) {\n      rep(z,3) {\n        int ti = i + 1, tj = j + dx[z];\n        if (ti < 0 || tj < 0 || ti >= y || tj >= x) continue;\n        if (c[ti][tj] == 1) continue;\n        if (c[ti][tj] == 2 && z != 1) continue;\n        dp[ti][tj] += dp[i][j];\n      }\n    } else if (c[i][j] == 2) {\n      dp[i+2][j] += dp[i][j];\n    }\n  }\n  /*\n  rep(i,y+1) {\n    rep(j,x) printf(\"%8d\",dp[i][j]);\n    cout<<endl;\n  }*/\n  \n  int res = 0;\n  rep(j,x) res += dp[y][j] + dp[y-1][j];\n  cout<<res<<endl;\n}\n\nint main (int argc, char const* argv[]) {\n  while (cin>>x>>y, x||y) {\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint main() {\n\tint width, height, m[15][15];\n\twhile (cin >> width >> height, width && height) {\n\t\tfor (int y = 0; y < height; ++y)\n\t\t\tfor (int x = 0; x < width; ++x)\n\t\t\t\tcin >> m[y][x];\n\n\t\tint sum = 0, pattern[15][15] = {0};\n\t\tfor (int x = 0; x < width; ++x)\n\t\t\tpattern[0][x] = 1;\n\n\t\tfor (int y = 0; y < height-1; ++y)\n\t\t\tfor (int x = 0; x < width; ++x)\n\t\t\t\tif (m[y][x] == 0) {\n\t\t\t\t\tif (x - 1 >= 0 && m[y+1][x-1] == 0) pattern[y+1][x-1] += pattern[y][x];\n\t\t\t\t\tif (x + 1 < width && m[y+1][x+1] == 0) pattern[y+1][x+1] += pattern[y][x];\n\t\t\t\t\tif (m[y+1][x] != 1) pattern[y+1][x] += pattern[y][x];\n\t\t\t\t}\n\t\t\t\telse if (m[y][x] == 2) {\n\t\t\t\t\tif (y + 2 == height) sum += pattern[y][x];\n\t\t\t\t\telse if (m[y+2][x] != 1) pattern[y+2][x] += pattern[y][x];\n\t\t\t\t}\n\n\t\tfor (int x = 0; x < width; ++x)\n\t\t\tsum += pattern[height-1][x];\n\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <functional>\n#include <numeric>\n#define fi first\n#define se second\nusing namespace std;\nbool value(int y,int x,int R,int C){return 0<=y&&y<R&&0<=x&&x<C;}\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<long long > vll;\ntypedef vector< vi > vvi;\ndouble pie=acos(-1);\nint INF=10000009;\nint dx[4] = { 0,-1,0,1 };\nint dy[4] = { -1,0,1,0 };\nint c[20][20];\nlong long int dp[20][20];\nint main() {\n\tint X,Y;\n\twhile(true){\n\t\tlong long int ans=0;\n\t\tcin>>X>>Y;\n\t\tif(X+Y==0) break;\n\t\tfor(int i=1;i<=Y;i++){\n\t\t\tfor(int j=1;j<=X;j++){\n\t\t\t\tcin>>c[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=X;i++){\n\t\t\tif(c[1][i]==1){\n\t\t\t\tdp[1][i]=0;\n\t\t\t}\n\t\t\tif(c[1][i]==0){\n\t\t\t\tdp[1][i]=1;\n\t\t\t}\n\t\t\tif(c[1][i]==2){\n\t\t\t\tdp[1][i]=1;\n\t\t\t\tdp[3][i]=1;\n\t\t\t}\n\t\t}\n\t\tfor(int i=2;i<=Y;i++){\n\t\t\tfor(int j=1;j<=X;j++){\n\t\t\t\tif(c[i][j]==1) dp[i][j]=0;\n\t\t\t\telse if(c[i][j]==0){\n\t\t\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\t\t\tif(c[i-1][j-1+k]!=2){\n\t\t\t\t\t\t\tdp[i][j]+=dp[i-1][j-1+k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(c[i-1][j]!=2){\n\t\t\t\t\t\tdp[i][j]+=dp[i-1][j];\n\t\t\t\t\t}\n\t\t\t\t\tdp[i+2][j]+=dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=Y;i<=Y+2;i++){\n\t\t\tfor(int j=1;j<=X;j++){\n\t\t\t\tans+=dp[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=Y+1;i++){\n\t\t\tfor(int j=1;j<=X;j++){\n\t\t\t\tdp[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// 2011/10/07 Tazoe\n\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n\twhile(true){\n\t\tint X, Y;\n\t\tcin >> X >> Y;\n\t\tif(X==0&&Y==0)\n\t\t\tbreak;\n\n\t\tint C[18][17];\n\t\tfor(int i=0; i<=Y+2; i++)\n\t\t\tfor(int j=0; j<=X+1; j++)\n\t\t\t\tC[i][j] = 1;\n\n\t\tfor(int i=1; i<=Y; i++)\n\t\t\tfor(int j=1; j<=X; j++)\n\t\t\t\tcin >> C[i][j];\n\n\t\tfor(int i=Y+1; i<=Y+2; i++)\n\t\t\tfor(int j=1; j<=X; j++)\n\t\t\t\tC[i][j] = 0;\n\n\t\tint DP[18][17];\n\t\tfor(int i=0; i<=Y+2; i++)\n\t\t\tfor(int j=0; j<=X+1; j++)\n\t\t\t\tDP[i][j] = 0;\n\n\t\t\tfor(int j=1; j<=X; j++)\n\t\t\t\tif(C[1][j]==0)\n\t\t\t\t\tDP[1][j] = 1;\n\n\t\tfor(int i=2; i<=Y; i++)\n\t\t\tfor(int j=1; j<=X; j++)\n\t\t\t\tif(C[i][j]==0)\n\t\t\t\t\tDP[i][j] += (DP[i-1][j-1]+DP[i-1][j]+DP[i-1][j+1]);\n\t\t\t\telse if(C[i][j]==1)\n\t\t\t\t\tDP[i][j] = 0;\n\t\t\t\telse if(C[i][j]==2){\n\t\t\t\t\tif(C[i+2][j]==1)\n\t\t\t\t\t\tDP[i+2][j] = 0;\n\t\t\t\t\telse{\n\t\t\t\t\t\tDP[i+2][j] += (DP[i-1][j]+DP[i][j]);\n\t\t\t\t\t\tDP[i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\tint sum = 0;\n\t\tfor(int i=Y; i<=Y+2; i++)\n\t\t\tfor(int j=1; j<=X; j++)\n\t\t\t\tsum += DP[i][j];\n\n\t\tcout << sum <<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    while (true) {\n        int X, Y;\n        cin >> X >> Y;\n        \n        if (X==0 && Y==0) {\n            break;\n        }\n        \n        int c[Y][X];\n        \n        for (int i=0; i<Y; i++) {\n            for (int j=0; j<X; j++) {\n                cin >> c[i][j];\n            }\n        }\n\n        int dp[Y][X];\n        \n        for (int i=0; i<Y; i++) {\n            for (int j=0; j<X; j++) {\n                dp[i][j] = 0;\n            }\n        }\n        \n        for (int i=0; i<X; i++) {\n            if (c[0][i]==0) {\n                dp[0][i] = 1;\n            }\n        }\n        \n        for (int i=0; i<Y-1; i++) {\n            for (int j=0; j<X; j++) {\n                if (c[i][j]==0) {\n                    if (c[i+1][j]==0 || c[i+1][j]==2) {\n                        dp[i+1][j] += dp[i][j];\n                    }\n                \n                    if (j-1>=0) {\n                        if (c[i+1][j-1]==0) {\n                            dp[i+1][j-1] += dp[i][j];\n                        }\n                    }\n                \n                    if (j+1<X) {\n                        if (c[i+1][j+1]==0) {\n                            dp[i+1][j+1] += dp[i][j];\n                        }\n                    }\n                }\n                else if (i<Y-2 && c[i][j]==2) {\n                    if (c[i+2][j]!=1) {\n                        dp[i+2][j] += dp[i][j];\n                    }\n                }\n            }\n        }\n        \n        int ans = 0;\n        \n        for (int i=0; i<X; i++) {\n            if (c[Y-2][i]==2) {\n                ans += dp[Y-2][i];\n            }\n        }\n        \n        for (int i=0; i<X; i++) {\n            ans += dp[Y-1][i];\n        }\n        \n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n\nusing namespace std;\n\nint main(int argc, char const* argv[])\n{\n\tint x,y;\n\tint stage[17][17][2];\n\n\twhile( cin >> x >> y && x != 0 && y != 0 ){\n\t\tfor( int i = 0;i < 17;i++ ){\n\t\t\tfor( int j = 0;j < 17;j++ ){\n\t\t\t\tstage[i][j][0] = stage[i][j][1] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor( int i = 0;i < 17;i++ ) stage[i][1][1] = 1;\n\t\t\n\t\tfor( int i = 1;i <= y;i++ ){\n\t\t\tfor( int j = 1;j <= x;j++ ){\n\t\t\t\tcin >> stage[j][i][0];\n\t\t\t}\n\t\t}\n\n\t\tfor( int j = 1;j <= y;j++ ){\n\t\t\tfor( int i = 1;i <= x;i++ ){\n\t\t\t\tif( stage[i][j][0] == 1 ) continue;\n\t\t\t\tif( stage[i][j][0] == 0 ){\n\t\t\t\t\tstage[i][j + 1][1] += stage[i][j][1];\n\t\t\t\t\t\n\t\t\t\t\tif( stage[i + 1][j + 1][0] == 0 && j != y ) stage[i + 1][j + 1][1] += stage[i][j][1];\n\t\t\t\t\tif( stage[i - 1][j + 1][0] == 0 && j != y ) stage[i - 1][j + 1][1] += stage[i][j][1];\n\n\t\t\t\t}\n\t\t\t\tif( stage[i][j][0] == 2 ){\n\t\t\t\t\tstage[i][j + 2][1] += stage[i][j][1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint count = 0;\n\t\tfor( int i = 0;i <= x+1;i++ ) count += stage[i][y+1][1];\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\ntypedef long long ll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n\nint main()\n{\n\t\n\twhile(1)\n\t{\n\t\tint w,h; cin >> w >> h;\n\t\tif(w == 0) return 0;\n\t\tint f[20][20]={};\n\t\tfor(int i=1;i<=h;i++)\n\t\t{\n\t\t\tfor(int j=1;j<=w;j++)\n\t\t\t{\n\t\t\t\tcin >> f[i][j];\n\t\t\t}\n\t\t}\n\t\tll dp[20][20]={};\n\t\tfor(int i=1;i<=w;i++) if(f[1][i] != 1) dp[1][i] = 1LL;\n\t\tfor(int i=1;i<=h;i++)\n\t\t{\n\t\t\tfor(int j=1;j<=w;j++)\n\t\t\t{\n\t\t\t\tif(!dp[i][j]) continue;\n\t\t\t\tif(f[i][j] == 0)\n\t\t\t\t{\n\t\t\t\t\tif(j != 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(f[i+1][j-1] == 0 && i+1 <= h) dp[i+1][j-1] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tif(f[i+1][j] != 1 && i+1 <= h) dp[i+1][j] += dp[i][j];\n\t\t\t\t\tif(j != w)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(f[i+1][j+1] == 0 && i+1 <= h) dp[i+1][j+1] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(f[i][j] == 2)\n\t\t\t\t{\n\t\t\t\t\tif(f[i+2][j] != 1 && i+2 <= h) dp[i+2][j] += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll res = 0;\n\t\tfor(int i=1;i<=w;i++) if(f[h-1][i] == 2) res += dp[h-1][i];\n\t\tfor(int i=1;i<=w;i++) res += dp[h][i];\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint X,Y;\nint dp[20][20];\nchar maps[20][20];\nint bun(int x,int y);\nint dx[3]={-1,0,1};\nmain(){\n  while(1){\n    cin>>X>>Y;\n    if(X==0&&Y==0){\n      break;\n    }\n    for(int i=1;i<=Y;i++){\n      for(int j=1;j<=X;j++){\n\tcin>>maps[i][j];\n\tdp[i][j]=0;\n      }\n    }\n    int ans=0;\n    for(int i=1;i<=X;i++){\n      if(maps[1][i]!='1'){\n\tans+=bun(1,i);\n      }\n    }\n    cout<<ans<<endl;\n  }\n}\nint bun(int y,int x){\n  if(y>=Y){\n    return 1;\n  }\n  else if(dp[y][x]!=0){\n    return dp[y][x];\n  }\n  else if(maps[y][x]=='2'&&(y+2>=Y+1||maps[y+2][x]!='1')){\n    return bun(y+2,x);\n  }\n  else if(maps[y][x]=='1'){\n    return 0;\n  }\n  else{\n    int anss=0;\n    for(int i=0;i<3;i++){\n      int nx=x+dx[i];\n      if(i!=1){\n\tif(nx>0&&nx<=X&&maps[y+1][nx]=='0'){\n\t  anss+=bun(y+1,nx);\n\t}\n      }\n      else{\n\tif(maps[y+1][nx]!='1'){\n\t  anss+=bun(y+1,nx);\n\t}\n      }\n    }\n    return dp[y][x]=anss;\n  }\t  \t  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nint main()\n{\n    int x, y;\n    int dx[3] = {-1, 0, 1};\n    \n    while (std::cin >> x >> y) {\n\n        if (x == 0 && y == 0) break;\n\n        int field[20][20] = {{0}}, dp[20][20] = {{0}};\n        \n        for (int i = 0; i < 20; ++i) {\n            for (int j = 0; j < 20; ++j) {\n                field[i][j] = 1;\n            }\n        }\n        \n        for (int i = 1; i <= y; ++i) {\n            for (int j = 1; j <= x; ++j) {\n                std::cin >> field[i][j];\n            }\n        }\n\n        for (int i = 1; i <= x; ++i) {\n            if (field[1][i] == 0) dp[1][i] = 1;\n        }\n        \n        //calc\n        int ans = 0;\n\n        for (int i = 1; i <= y; ++i) {\n            for (int j = 1; j <= x; ++j) {\n                \n                switch (field[i][j]) {\n                    case 0:\n                        for (int k = 0; k < 3; ++k) {\n                            int px = j + dx[k], py = i + 1;\n                            \n                            if ((field[py][px] == 2 && k == 1) || field[py][px] == 0) {\n                                dp[py][px] += dp[i][j];\n                            }\n                        }\n                        break;\n                    case 2:\n                        //y-1\n                        if (i == y -1) ans += dp[i][j];\n                        if (dp[i + 2][j] != 1) dp[i + 2][j] += dp[i][j];\n                        break;\n                    default:\n                        break;\n                }\n            }\n        }\n\n        for (int i = 1; i <= x; ++i) {\n            ans += dp[y][i];\n        }\n\n        std::cout << ans << std::endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nint main()\n{\n    int x, y;\n    int dx[3] = {-1, 0, 1};\n    \n    while (std::cin >> x >> y) {\n\n        if (x == 0 && y == 0) break;\n\n        int field[20][20] = {{0}}, dp[20][20] = {{0}};\n        \n        for (int i = 0; i < 20; ++i) {\n            for (int j = 0; j < 20; ++j) {\n                field[i][j] = 1;\n            }\n        }\n        \n        for (int i = 1; i <= y; ++i) {\n            for (int j = 1; j <= x; ++j) {\n                std::cin >> field[i][j];\n            }\n        }\n\n        for (int i = 1; i <= x; ++i) {\n            if (field[1][i] == 0) dp[1][i] = 1;\n        }\n        \n        //calc\n        int ans = 0;\n\n        for (int i = 1; i <= y; ++i) {\n            for (int j = 1; j <= x; ++j) {\n                \n                switch (field[i][j]) {\n                    case 0:\n                        for (int k = 0; k < 3; ++k) {\n                            int px = j + dx[k], py = i + 1;\n                            \n                            if ((field[py][px] == 2 && k == 1) || field[py][px] == 0) {\n                                dp[py][px] += dp[i][j];\n                            }\n                        }\n                        break;\n                    case 2:\n                        //y-1\n                        if (i == y -1) ans += dp[i][j];\n                        if (dp[i + 2][j] != 1) dp[i + 2][j] += dp[i][j];\n                        break;\n                    default:\n                        break;\n                }\n            }\n        }\n\n        for (int i = 1; i <= x; ++i) {\n            ans += dp[y][i];\n        }\n\n        std::cout << ans << std::endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#include <string.h>\n\nusing namespace std;\n\nconst int FIELD_MAX =15;\n\nint X, Y;\nint field[FIELD_MAX][FIELD_MAX];\nint table[FIELD_MAX+1][FIELD_MAX];\nint cnt = 0;\n\ntypedef pair<int, int> point;\n\nvoid solve()\n{\n\tmemset(&table[0][0], 0, sizeof(int) * 15 * 16);\n\tfor(int x=0; x<X; x++)\n\t{\n\t\ttable[Y][x] = 1;\n\t}\n\t\n\tfor(int y=Y; y>=1; y--)\n\t{\t\n\t\tfor(int x=0; x<X; x++){\n\t\t\tif(field[y][x] ==1)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(y>=2){\n\t\t\t\tif(field[y-2][x]==2) table[y-2][x]+=table[y][x];\n\t\t\t}\n\t\t\tif(x>=1 && y!=Y && field[y][x] != 2){\n\t\t\t\tif(field[y-1][x-1]==0) table[y-1][x-1]+=table[y][x];\n\t\t\t}\n\t\t\tif(field[y-1][x]==0) table[y-1][x]+=table[y][x];\n\t\t\tif(x<X-1 && y!=Y && field[y][x] != 2){\n\t\t\t\tif(field[y-1][x+1]==0) table[y-1][x+1]+=table[y][x];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcnt = 0;\n\tfor(int x=0; x<X; x++){\n\t\tcnt += table[0][x];\n\t}\n}\n\nint main()\n{\n\twhile( 1 )\n\t{\n\t\tcin >> X >> Y;\n\t\tif(X==0 && Y==0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor(int y=0; y<Y; y++)\n\t\t{\n\t\t\tfor(int x=0; x<X; x++)\n\t\t\t{\n\t\t\t\tcin >> field[y][x];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcnt = 0;\n\t\tsolve();\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#define N 16\nusing namespace std;\nvoid func(int,int);\nint jump(int,int);\nint X,Y,data[N][N],memo[N+2][N];\nint main(){\n  while(1){\n    cin >> X >> Y;\n    if(X==0&&Y==0) break;\n    for(int i=0;i<Y;i++)\n      for(int j=0;j<X;j++) cin >> data[i][j];\n    for(int i=0;i<Y+2;i++)\n      for(int j=0;j<X;j++) memo[i][j]=0;\n    for(int i=0;i<X;i++)\n      if(data[0][i]!=1)\tfunc(0,i);\n    int cnt=0;\n    for(int i=0;i<X;i++) cnt+=memo[0][i];\n    cout << cnt << endl;\n  }\n  return 0;\n}\nvoid func(int y,int x){\n  if(y>=Y-1){\n    memo[Y][x]=memo[Y-1][x]=1;\n    return ;\n  }\n  if(0<=x-1&&data[y+1][x-1]==0){\n    if(memo[y+1][x-1]!=0) memo[y][x]+=memo[y+1][x-1];\n    else{\n      func(y+1,x-1),memo[y][x]+=memo[y+1][x-1];\n    }\n  }\n  if(x+1<X&&data[y+1][x+1]==0){\n    if(memo[y+1][x+1]!=0) memo[y][x]+=memo[y+1][x+1];\n    else{\n      func(y+1,x+1),memo[y][x]+=memo[y+1][x+1];\n    }\n  }\n  if(data[y+1][x]==0){\n    if(memo[y+1][x]!=0) memo[y][x]+=memo[y+1][x];\n    else{\n      func(y+1,x),memo[y][x]+=memo[y+1][x];\n    }\n  }\n  if(data[y+1][x]==2){\n    int r=jump(y+1,x);\n    if(r!=-1){\n      if(memo[r][x]!=0) memo[y][x]+=memo[r][x];\n      else{\n\tfunc(r,x),memo[y][x]+=memo[r][x];\n      }\n    }\n  }\n  if(memo[y][x]==0) data[y][x]=1;\n}\nint jump(int y,int x){\n  y+=2;\n  while(1){\n    if(y>=Y-1) return y;\n    if(data[y][x]==1) break;\n    if(data[y][x]==0) return y;\n    y+=2;\n  }\n  return -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF 999999999\n\nint main(){\n    int w,h;\n    while(cin>>w>>h){\n        if(w==0&&h==0)break;\n        int data[20][20];\n        rep(i,h){\n            rep(j,w){\n                cin>>data[i][j];\n            }\n        }\n        int dp[20][20];\n        rep(i,20)rep(j,20)dp[i][j]=0;\n        rep(i,w){\n            if(data[0][i]==0){\n                dp[0][i]=1;\n            }\n        }\n        \n        for(int i=0;i<h-1;i++){\n            for(int j=0;j<w;j++){\n                if(j-1>=0 && data[i+1][j-1]==0)dp[i+1][j-1]+=dp[i][j];\n                if(data[i+1][j]==0)dp[i+1][j]+=dp[i][j];\n                if(data[i+1][j]==2){\n                    int c=1;\n                    while(data[i+1+2*c][j]==2)c++;\n                    dp[min(h-1,i+1+c*2)][j]+=dp[i][j];\n                }\n                if(j+1<w && data[i+1][j+1]==0)dp[i+1][j+1]+=dp[i][j];\n            }\n        }\n        int ans=0;\n        rep(i,w){\n            ans+=dp[h-1][i];\n        }\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint main(int argc, char const* argv[])\n{\n\tint x,y;\n\tint stage[17][17][2];\n\n\twhile( cin >> x >> y && x != 0 && y != 0 ){\n\t\tfor( int i = 0;i < 17;i++ ){\n\t\t\tfor( int j = 0;j < 17;j++ ){\n\t\t\t\tstage[i][j][0] = stage[i][j][1] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tfor( int i = 1;i <= y;i++ ){\n\t\t\tfor( int j = 1;j <= x;j++ ){\n\t\t\t\tcin >> stage[j][i][0];\n\t\t\t}\n\t\t}\n\n\t\tfor( int i = 0;i < 17;i++ ) if(stage[i][1][0] != 1 ) stage[i][1][1] = 1;\n\n\t\tfor( int j = 1;j < y;j++ ){\n\t\t\tfor( int i = 1;i <= x;i++ ){\n\t\t\t\tif( stage[i][j][0] == 1 ) continue;\n\t\t\t\tif( stage[i][j][0] == 0 ){\n\t\t\t\t\tif( stage[i][j + 1][0] != 1 ) stage[i][j + 1][1] += stage[i][j][1];\n\t\t\t\t\t\n\t\t\t\t\tif( stage[i + 1][j + 1][0] == 0 && ( i + 1 ) <= x ) stage[i + 1][j + 1][1] += stage[i][j][1];\n\t\t\t\t\tif( stage[i - 1][j + 1][0] == 0 && ( i - 1 ) >= 1 ) stage[i - 1][j + 1][1] += stage[i][j][1];\n\n\t\t\t\t}\n\t\t\t\tif( stage[i][j][0] == 2 ){\n\t\t\t\t\tif( stage[i][j + 2][0] != 1 ) stage[i][j + 2][1] += stage[i][j][1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint count = 0;\n\t\tfor( int i = 1;i <= x;i++ ){\n\t\t\tcount += stage[i][y+1][1];\n\t\t\tif( stage[i][y][0] != 1 ) count += stage[i][y][1];\n\t\t}\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nconst int X=20;\nconst int Y=20;\nint main(){\n    int n,m,dp[X][Y],s[X][Y],k,ans;\n    while(true){\n        scanf(\"%d%d\",&n,&m);\n        if(n==0&&m==0)return 0;\n        ans=0;\n        for(int i=0;i<n+2;i++)for(int j=0;j<m;j++)dp[i][j]=s[i][j]=0;\n        for(int i=0;i<m;i++)dp[0][i]=1;\n        for(int i=0;i<n;i++)for(int j=0;j<m;j++){\n            scanf(\"%d\",&k);\n            if(k==0){\n                dp[i][j]+=s[i][j];\n                if(i==n-1)continue;\n                dp[i+1][j]+=dp[i][j];\n                if(j!=0)s[i+1][j-1]+=dp[i][j];\n                if(j!=m-1)s[i+1][j+1]+=dp[i][j];\n            }\n            else if(k==2){\n                s[i][j]=0;\n                dp[i+2][j]+=dp[i][j];\n            }\n            else dp[i][j]=0;\n        }\n        for(int i=0;i<m;i++)ans+=dp[n][i]+dp[n-1][i];\n        \n        printf(\"%d\\n\",ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nint main() {\n    int x, y, c[20][20]{};\n    ll dp[20][20];\n    while(cin >> x >> y, x){\n        for(int i=0;i<y;i++){\n            for(int j=0;j<x;j++){\n                cin >> c[i][j];\n            }\n        }\n        for(int i=1;i<y+2;i++) fill(dp[i], dp[i]+x, 0LL);\n        fill(dp[0], dp[0]+x, 1);\n        for(int i=0;i<y-1;i++){\n            for(int j=0;j<x;j++){\n                if(c[i][j]==1) continue;\n                if(c[i][j]==2) dp[i+2][j] += dp[i][j];\n                else{\n                    if(j-1>=0 && c[i+1][j-1]==0) dp[i+1][j-1] += dp[i][j];\n                    if(j+1<x && c[i+1][j+1]==0) dp[i+1][j+1] += dp[i][j];\n                    if(c[i+1][j] != 1) dp[i+1][j] += dp[i][j];\n                }\n            }\n        }\n        int ans = 0;\n        for(int i=y-1;i<=y+1;i++){\n            for(int j=0;j<x;j++){\n                if(c[i][j] != 1) ans += dp[i][j];\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <complex>\n\n#define EPS\t1.0e-10\n#define rep(idx, max)\tfor(int idx = 0, idx##Max = max; idx < idx##Max; idx ++)\n#define rrep(idx, min, max)\tfor(int idx = min, idx##Max = max; idx < idx##Max; idx ++)\n#define erep(idx, min, max)\tfor(int idx = min, idx##Max = max; idx <= idx##Max; idx ++)\n\n#define rev(idx, max)\tfor(int idx = max - 1; idx >= 0; idx --)\n\ntypedef unsigned int UINT;\ntypedef std::vector<int>\tVEC;\ntypedef struct _POINT\n{\n\tint x, y;\n\t_POINT(){}\n\t_POINT(int _x, int _y): x(_x), y(_y){}\n} POINT;\n\nenum\n{\n\tJMP = 2,\n\tBLK = 1,\n\tFLOOR = 0, \n};\n\n#define MAX_N\t32\n\nint g_width, g_height;\nint g_map[MAX_N][MAX_N];\nint g_cache[MAX_N][MAX_N];\n\nvoid\tPrintCache()\n{\n\trep(y, g_height + 2)\n\t{\trep(x, g_width + 2)\t{\t::printf(\"%2d|\", g_cache[y][x]);\t}\t::puts(\"\");\t}\n\t::puts(\"\");\n}\n\nint\tSolve()\n{\n\terep(y, 1, g_height) erep(x, 1, g_width)\n\t{\n\t//\t::PrintCache();\n\t\tswitch (g_map[y][x])\n\t\t{\n\t\tcase BLK:\tbreak;\n\t\tcase FLOOR:\n\t\t\terep(dx, -1, +1)\n\t\t\t{\n\t\t\t\tint &fieldn = g_map[y + 1][x + dx];\n\t\t\t\tif (fieldn == BLK || (fieldn == JMP && dx != 0)) { continue; }\n\t\t\t\tg_cache[y + 1][x + dx] += g_cache[y][x];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JMP:\n\t\t\tif (g_map[y + 2][x] != BLK) { g_cache[y + 2][x] += g_cache[y][x]; }\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tint count = 0;\n\terep(x, 1, g_width)\n\t{\n\t\tcount += g_cache[g_height + 1][x] + g_cache[g_height][x];\n\t}\n\treturn(count);\n}\n\nvoid\tPrintMap()\n{\n\trep(y, MAX_N)\n\t{\trep(x, MAX_N)\t{\t::printf(\"%2d|\", g_map[y][x]);\t}\t::puts(\"\");\t}\n\t::puts(\"\");\n}\n\nvoid\tInitMap()\n{\n//\t::memset(g_map, BLK, sizeof(g_map));\n\trep(y, MAX_N) rep(x, MAX_N) { g_map[y][x] = BLK; }\n\terep(y, 1, g_height) erep(x, 1, g_width)\t{\tstd::cin >> g_map[y][x];\t}\n}\n\nvoid\tInitCache()\n{\n\t::memset(g_cache, 0, sizeof(g_cache));\n//\trep(y, MAX_N) rep(x, MAX_N) { g_cache[y][x] = -1; }\n\terep(x, 1, g_width) { g_cache[1][x] = 1; }\n}\n\nint main(int nArgs, char **lplpszArgs)\n{\n\twhile (std::cin >> g_width >> g_height, g_width)\n\t{\n\t\tInitMap();\n\t\tInitCache();\n\t//\tPrintMap();\n\t\t::printf(\"%d\\n\", ::Solve());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint field[15][15];\nint dp[16][15];\n\nint n, m;\n\nbool isIn(int x, int y){\n    return 0 <= x && x < n && 0 <= y && y < m;\n}\n\nint main(){\n    while(cin >> n >> m, n+m){\n        for(int i=0; i < n; i++) for(int j=0; j< m; j++){cin >> field[i][j];}\n        for(int i=0; i< 16; i++) for(int j=0; j< 15; j++) dp[i][j] = 0;\n        for(int i=0; i < m; i++) dp[0][i] = 1;\n        for(int i=0; i < n-1; i++){\n            for(int j=0; j < m; j++){\n                if(field[i][j] == 0){\n                    for(int k=-1; k <= 1; k++){\n                        if(isIn(i+1, j+k) && !(k != 0 && field[i+1][j+k] == 2)){\n                            dp[i+1][j+k] += dp[i][j];\n                        }\n                    }\n                }\n                else if(field[i][j] == 1) dp[i][j] = 0;\n                else if(field[i][j] == 2) dp[i+2][j] += dp[i][j];\n            }\n        }\n        for(int i=0; i< m; i++) if(field[n-1][i] != 1)dp[n][i] += dp[n-1][i];\n        int count = 0;\n        for(int i=0; i< m; i++) count += dp[n][i];\n        cout << count << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint dp[16][15];\nint h,w;\nint map[16][15];\nmain()\n{\n\twhile(cin>>w>>h,w)\n\t{\n\t\tfor(int i=0;i<h;i++)\n\t\t{\n\t\t\tfor(int j=0;j<w;j++)\n\t\t\t{\n\t\t\t\tcin>>map[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=h;i++)for(int j=0;j<w;j++)dp[i][j]=0;\n\t\tfor(int i=0;i<w;i++)dp[0][i]=map[0][i]==0;\n\t\tfor(int i=0;i<h;i++)\n\t\t{\n\t\t\tfor(int j=0;j<w;j++)\n\t\t\t{\n\t\t\t\tif(dp[i][j]==0||map[i][j]==1)continue;\n\t\t\t\tif(map[i][j]==2)\n\t\t\t\t{\n\t\t\t\t\tdp[i+2<=h?i+2:h][j]+=dp[i][j];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(i<h-1&&j>0)\n\t\t\t\t{\n\t\t\t\t\tif(map[i+1][j-1]==0)dp[i+1][j-1]+=dp[i][j];\n\t\t\t\t}\n\t\t\t\tif(i<h-1&&j<w-1)\n\t\t\t\t{\n\t\t\t\t\tif(map[i+1][j+1]==0)dp[i+1][j+1]+=dp[i][j];\n\t\t\t\t}\n\t\t\t\tif(map[i+1][j]!=1)dp[i+1][j]+=dp[i][j];\n\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t\tfor(int j=0;j<w;j++)ans+=dp[h][j];\n\t\tcout<<ans<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint x,y,a[17][17],i,j;\nlong long s;\nvoid dfs(int y1,int x1){\n  if(x1<1||x1>x)return;\n  if(y1>=y){s++;return;}\n  if(a[y1][x1]==2)dfs(y1+2,x1);\n  else {if(a[y1+1][x1]!=1)dfs(y1+1,x1);\n  if(a[y1+1][x1+1]==0)dfs(y1+1,x1+1);\n  if(a[y1+1][x1-1]==0)dfs(y1+1,x1-1);}\n  return;\n}\nint main(){\n  while(cin>>x>>y,x){\n    for(s=0,i=0;i<17;i++)for(j=0;j<17;j++)a[i][j]=0;    \n    for(s=0,i=1;i<=y;i++)for(j=1;j<=x;j++)cin>>a[i][j];\n    for(i=1;i<=x;i++){if(a[1][i]!=1)dfs(1,i);}\n    cout<<s<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n\tint n,m;\n\tint masu[17][17];\n\tint ura[17][17];\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0 && m==0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i=0;i<17;i++){\n\t\t\tfor(int j=0;j<17;j++){\n\t\t\t\tmasu[i][j]=0;\n\t\t\t\tura[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=1;j<=m;j++){\n\t\t\t\tscanf(\"%d\",&ura[i][j]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tswitch(ura[1][i]){\n\t\t\t\tcase 0:masu[1][i]+=1;break;\n\t\t\t\tcase 1:masu[1][i]+=0;break;\n\t\t\t\tcase 2:if(ura[2][i]==0){masu[2][i]+=1;}break;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfor(int j=1;j<=m;j++){\n\t\t\t\tif(ura[i][j]==0){\n\t\t\t\t\tif(ura[i+1][j-1]==0){\n\t\t\t\t\t\tmasu[i+1][j-1]+=masu[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tif(ura[i+1][j]!=1){\n\t\t\t\t\t\tmasu[i+1][j]+=masu[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tif(ura[i+1][j+1]==0){\n\t\t\t\t\t\tmasu[i+1][j+1]+=masu[i][j];\n\t\t\t\t\t}\n\t\t\t\t}else if(ura[i][j]==2){\n\t\t\t\t\tif(ura[i+2][j]!=1){\n\t\t\t\t\t\tmasu[i+2][j]+=masu[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cont=0;\n\t\tfor(int i=n;i<=n+1;i++){\n\t\t\tfor(int j=1;j<=m;j++){\n\t\t\t\tcont+=masu[i][j];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",cont);\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n  int x, y;\n  while (cin >> x >> y, x){\n    int map[32][32];\n    for (int i = 1; i <= y; i++){\n      for (int j = 1; j <= x; j++){\n        cin >> map[i][j];\n      }\n    }\n\n    int dp[32][32] = {0};\n    for (int j = 1; j <= x; j++) dp[1][j] = (map[1][j] == 1 ? 0 : 1);\n    for (int i = 1; i < y; i++){\n      for (int j = 1; j <= x; j++){\n        if (map[i][j] == 1) continue;\n        if (map[i][j] == 2){\n          dp[i + 2][j] = dp[i][j];\n          continue;\n        }\n        \n        for (int k = -1; k < 2; k++){\n          if (map[i + 1][j + k] == 2 && k) continue;\n          if (map[i + 1][j + k] == 1) continue;\n          dp[i + 1][j + k] += dp[i][j];\n        }\n      }\n    }\n\n    int ans = 0;\n    for (int j = 1; j <= x; j++){\n      ans += dp[y][j] + dp[y + 1][j];\n    }\n\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nint dx[] = {-1,0,1},dy[] = {1,1,1};\nint main(){\n\tint x,y;\n\twhile(cin >> x >> y,x,y){\n\t\tint field[20][20] = {{0}};\n\t\tint dp[20][20] = {{0}};\n\t\tfor(int i = 0; i < 20; i++)for(int j = 0; j < 20; j++)field[i][j] = 1;\n\t\tfor(int i = 1; i <= y; i++){\n\t\t\tfor(int j = 1; j <= x; j++){\n\t\t\t\tcin >> field[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1; i <= x; i++){\n\t\t\tif(field[1][i] == 0)dp[1][i] = 1;\n\t\t}\n\t\tint sum = 0;\n\t\tfor(int i = 1; i <= y; i++){\n\t\t\tfor(int j = 1; j <= x; j++){\n\t\t\t\tif(field[i][j] == 0){\n\t\t\t\t\tfor(int k = 0; k < 3; k++){\n\t\t\t\t\t\tint px = j + dx[k],py = i + dy[k];\n\t\t\t\t\t\tif((field[py][px] == 2 && k == 1) || field[py][px] == 0){\n\t\t\t\t\t\t\tdp[py][px] += dp[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(field[i][j] == 2){\n\t\t\t\t\tif(i == y-1)sum += dp[i][j];\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(field[i+2][j] != 1)dp[i+2][j] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1; i <= x; i++){\n\t\t\tsum += dp[y][i];\n\t\t}\n\t\tprintf(\"%d\\n\",sum);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nint m[500][500];\nint dp[500][500];\n\nint dx[]={-1,0,1};\n\nint solve(int r,int c){\n  rep(i,r+2)rep(j,c)dp[i][j]=0;\n  rep(j,c)if(m[0][j] == 0)dp[0][j]=1;\n\n  rep(i,r){\n    rep(j,c){\n      if (m[i][j] == 0 && i != r-1){\n\trep(k,3){\n\t  int nex = j+dx[k];\n\t  if (nex<0||nex>=c)continue;\n\t  if (m[i+1][nex] == 0)dp[i+1][nex]+=dp[i][j];\n\t  else if (m[i+1][nex] == 2 && k == 1)dp[i+1][nex]+=dp[i][j];\n\t}\n      }else if (m[i][j] == 2 ){\n\tdp[i+2][j]+=dp[i][j];\n      }\n    }\n  }\n  \n  int ans = 0;\n  rep(j,c)ans+=dp[r][j]+dp[r-1][j]+dp[r+1][j];\n  return ans;\n}\n\nmain(){\n  int c,r;\n  while(cin>>c>>r && r){\n    rep(i,r)rep(j,c)cin>>m[i][j];\n    rep(j,c)m[r][j]=m[r+1][j]=0;\n    cout << solve(r,c) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<queue>\n#include<string>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define reps(i,n) for(int i=1;i<=int(n);i++)\n#define sint(i) scanf(\"%d\",&i);\n#define sintt(i,j) scanf(\"%d%d\",&i,&j);\n#define sinttt(i,j,k) scanf(\"%d%d%d\",&i,&j,&k);\n#define sintttt(i,j,k,m) scanf(\"%d%d%d%d\",&i,&j,&k,&m);\n\n#define INF 1010000000\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\n\n\nint main(){\n\twhile(1){\n\t\tint n,m;\n\t\tsintt(n,m);\n\t\tif(n==0)break;\n\t\tint masu[17][17];\n\t\tint dp[17][17];\n\t\t\n\t\trep(i,17)rep(j,17)masu[i][j]=dp[i][j]=0;\n\t\t\n\t\trep(i,m)rep(j,n){\n\t\t\tsint(masu[j+1][i]);\n\t\t}\n\t\t\n\t\treps(j,n){\n\t\t\tif(masu[j][0]!=1){\n\t\t\t\tdp[j][0]=1;\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(i,m-1){\n\t\t\treps(j,n){\n\t\t\t\tif(masu[j][i]==1){\n\t\t\t\t\tdp[i][j]=0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(masu[j][i]==2){\n\t\t\t\t\tif(masu[j][i+2]!=1){\n\t\t\t\t\t\tdp[j][i+2]+=dp[j][i];\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(masu[j][i]==0){\n\t\t\t\t\tif(masu[j-1][i+1]==0){\n\t\t\t\t\t\tdp[j-1][i+1]+=dp[j][i];\n\t\t\t\t\t}\n\t\t\t\t\tif(masu[j+1][i+1]==0){\n\t\t\t\t\t\tdp[j+1][i+1]+=dp[j][i];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(masu[j][i+1]!=1){\n\t\t\t\t\t\tdp[j][i+1]+=dp[j][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans=0;\n\t\tfor(int i=m-1;i<=m;i++){\n\t\t\treps(j,n){\n\t\t\t\tans+=dp[j][i];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t\t\n\t\trep(i,m+2){\n\t\t\trep(j,n+2){\n\t\t\t\tprintf(\"%d \",dp[j][i]);\n\t\t\t}puts(\"\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint w,h;\nint mp[20][20];\nint memo[20][20];\nint ans;\nint count;\n\nint saiki(int x,int y) {\n  count++;\n  // cout << x <<\" \"<<y <<endl;\n  int dx[3] = {-1,0,1};\n  int dy[3] = {1,1,1};\n  \n  if((y >= h-1 && mp[y][x] != 1)) ans++,memo[y][x]++;//,cout <<\"ok\"<<endl;  \n  else if(mp[y][x] != 1) {\n    for(int i=0;i<3;i++) {\n      int nx = dx[i]+x;\n      int ny = dy[i]+y;\n      if(nx <0|| nx >= w || memo[ny][nx] == -1) continue;\n      \n      if(memo[ny][nx] > 0 && mp[ny][nx] == 0) {\n\tans += memo[ny][nx];\n\tmemo[y][x] += memo[ny][nx];\n      }  \n      else if(x == nx && memo[ny][nx] == 2 && memo[ny][nx] > 0) {\n\tans += memo[ny][nx];\n\tmemo[y][x] += memo[ny][nx];\n      }\n      else if(mp[ny][nx] == 0){\n\tsaiki(nx,ny);\n\tif(memo[ny][nx] > 0) memo[y][x] += memo[ny][nx];\n      } \n      else if(nx==x && mp[ny][nx] == 2){\n\tint ty = ny;\n\twhile(mp[ty][nx] == 2) ty+=2;\n\tsaiki(nx,ty);\n\tif(memo[ty][nx] > 0) memo[y][x] += memo[ty][nx];\n      } \n    }\n    if(memo[y][x] == 0) memo[y][x] = -1;\n  }\n}\n\n\nint main() {\n\n  while(1) {\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n\n    for(int i=0;i<=19;i++) \n      for(int j=0;j<=19;j++){ \n\tmemo[i][j] = 0;\n\tmp[i][j] = 0;\n      }\n    \n    for(int i=0;i<h;i++) \n      for(int j=0;j<w;j++) \n\tcin >> mp[i][j];\n\n    /*\n      for(int i=0;i<h;i++) {\n      for(int j=0;j<w;j++) \n      cout << mp[i][j];\n      cout << endl;\n      }\n    */\n\n    ans = 0;\n    count = 0;\n    for(int i=0;i<w;i++) {\n      if(mp[0][i] !=1) saiki(i,0);\n    }\n\n    int ans2 = 0;\n    for(int i=0;i<w;i++) \n      if(memo[0][i] > 0) ans2+=memo[0][i];\n\n    cout << ans << endl;\n    //    cout << ans2 << endl;\n    //cout << count << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint w, h, c[15][15];\nint res;\n\nvoid dfs(int x, int y) {\n\tif (y >= h-1) {\n\t\t++res;\n\t\treturn;\n\t}\n\tif (c[y][x] == 1) return;\n\tif (c[y][x] == 0) {\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\tint nx = x + i - 1, ny = y + 1;\n\t\t\tif (0 <= nx && nx < w && ((x == nx && c[ny][nx] == 2) || c[ny][nx] == 0)) dfs(nx, ny);\n\t\t}\n\t}\n\tif (c[y][x] == 2) dfs(x, y+2);\n\treturn;\n}\n\nint main(void) {\n\twhile (cin >> w >> h, w && h) {\n\t\tfor (int i = 0; i < h; ++i) {\n\t\t\tfor (int j = 0; j < w; ++j) cin >> c[i][j];\n\t\t}\n\t\tres = 0;\n\t\tfor (int i = 0; i < w; ++i) {\n\t\t\tif (c[0][i] == 0) dfs(i, 0);\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <deque>\n#include <ctime>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define mp make_pair\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n#define println(X) cout<<X<<endl;\n#define DBG(X) cout<<#X<<\" : \"<<X<<endl;\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\nconst double PI = acos(-1);\n\nint dx[]={-1, 0, 1};\n\nint d[21][21];\nll dp[21][21];\nint w, h;\n\nbool isOutofRange(int x, int y){\n\tif(x < 0 || x >= w || y < 0) return true;\n\treturn false;\n}\n\nint main(){\n\twhile(cin>>w>>h && w && h){\n\t\trep(i, h) rep(j, w) cin>>d[i][j];\n\t\trep(i, 21) rep(j, 21) dp[i][j] = 0LL;\n\t\tfor(int i = 0; i < w; i++){\n\t\t\tif(d[0][i] != 1) dp[0][i] = 1LL;\n\t\t}\n\n\t\tfor(int i = 0; i < h-1; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tif(d[i][j]!=0) continue;\n\t\t\t\tfor(int k = 0; k < 3; k++){\n\t\t\t\t\tint nx = j + dx[k], ny = i+1;\n\t\t\t\t\tif(isOutofRange(nx, ny)) continue;\n\t\t\t\t\tif(d[ny][nx] == 0) {\n\t\t\t\t\t\tdp[ny][nx] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(d[i+1][j]==2) dp[i+2][j]+=dp[i][j];\n\t\t\t}\n\t\t}\n\t\tll ans = 0ll;\n\t\trep(i, w){\n\t\t\tans += dp[h-1][i];\n\t\t\tans += dp[h][i];\n\t\t}\n\t\tcout<<ans<<endl;\n\t\t// rep(i, h) {\n\t\t// \trep(j, w){\n\t\t// \t\tcout<<dp[i][j]<<\" \";\n\t\t// \t}\n\t\t// \tcout<<endl;\n\t\t// }\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n \nusing namespace std;\n \n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define rep(i,n) REP(i, 0, n)\n#define pb push_back\n#define mp make_pair\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<double, int> pdi;\ntypedef pair<ll, ll> pll;\n \n\n \nconst int INF = 1000000;\nconst double EPS = 1e-8;\nconst int mod = 1e9 + 7;\nconst ll LINF = 1e18;\nconst double PI = acos(-1);\n\nstruct Input\n{\n\tint n;\n\tchar c;\n\tchar str[1024];\n\tstring s;\n\tll l;\n\tint nextInt(){\n\t\tscanf(\"%d\", &n);\n\t\treturn n;\n\t}\n\tll nextLong(){\n\t\tscanf(\"%lld\", &l);\n\t\treturn l;\n\t}\n\tchar nextChar(){\n\t\tscanf(\"%c\", &c);\n\t\treturn c;\n\t}\n\tstring next(){\n\t\tscanf(\"%s\", str);\n\t\treturn string(str);\n\t}\n\tstring nextLine(){\n\t\tgetline(cin, s);\n\t\treturn s;\n\t}\n};\nInput in;\n\nint dx[]={-1, 0, 1};\nint dy[]={1,1,1};\n\nint d[30][30];\nint w, h;\nll dp[30][30];\n\nbool isOutOfRange(int x){\n\tif(x < 0 || x >= w) return true;\n\treturn false; \n}\n\nint main(){\n\twhile(1){\n\t\tw = in.nextInt();\n\t\th = in.nextInt();\n\t\tif(w == 0 && h == 0) break;\n\t\trep(i, 30) rep(j, 30) d[i][j] = 0, dp[i][j] = 0LL;\n\t\trep(i, h) rep(j, w){\n\t\t\td[i][j] = in.nextInt();\n\t\t}\n\t\trep(i, w) if(d[0][i]!=1) dp[0][i] = 1;\n\t\tfor(int i = 0; i < h-1; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tif(d[i][j]==0){\n\t\t\t\t\tfor(int k = 0; k < 3; k++){\n\t\t\t\t\t\tint nx = j + dx[k], ny = i + dy[k];\n\t\t\t\t\t\tif(d[ny][nx]==0){\n\t\t\t\t\t\t\tdp[ny][nx] += dp[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(d[i + 1][j] == 2){\n\t\t\t\t\t\tdp[i + 3][j] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(d[i][j]==2){\n\t\t\t\t\tdp[i+2][j] += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// for(int i = 0; i < h; i++){\n\t\t// \tfor(int j = 0; j < w; j++){\n\t\t// \t\tcout<<\" \"<<d[i][j];\n\t\t// \t}\n\t\t// \tcout<<endl;\n\t\t// }\n\t\t// cout<<endl;\n\t\t// for(int i = 0; i < h + 1; i++){\n\t\t// \tfor(int j = 0; j < w; j++){\n\t\t// \t\tcout<<\" \"<<dp[i][j];\n\t\t// \t}\n\t\t// \tcout<<endl;\n\t\t// }\n\t\tll ans = 0LL;\n\t\tfor(int i = 0; i < w; i++){\n\t\t\tans += dp[h][i];\n\t\t\tans += dp[h-1][i];\n\t\t\tans += dp[h+1][i];\n\t\t\tans += dp[h+2][i];\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n\nusing namespace std;\n\nint x,y;\nint map[15][15];\nint dp[15][15];\n\nint solve(int i,int j,bool naname){\n  //cout<<\"a\"<<i<<\"\\t\"<<j<<endl;\n  if(j < 0 ||j >= x) return 0;\n  if(i >= y) return 1;\n  if(naname)\n    if(map[i][j] == 2)\n      return 0;\n  if(dp[i][j] >= 0) return dp[i][j];\n \n  int ret;\n\n  //cout<<i<<\"\\t\"<<j<<endl;\n  switch(map[i][j]){\n  case 0:\n    ret = solve(i+1,j-1,true) + solve(i+1,j,false)+solve(i+1,j+1,true);\n    break;\n  case 2:\n    ret = solve(i+2,j,false);\n    break;\n  }\n\n  return dp[i][j] = ret;\n}\n\n\nint main(){\n  while(cin>>x>>y){\n    if(x == 0 && y==0)\n      return 0;\n    memset(dp,-1,sizeof(dp));\n    for(int i = 0;i<y;i++){\n      for(int j = 0;j<x;j++){\n\tcin>>map[i][j];\n\tif(map[i][j] == 1)\n\t  dp[i][j] = 0;\n      }\n    }\n    int ans = 0;\n    for(int j = 0;j<x;j++){\n      if(map[y-1][j] != 1)\n\tdp[y-1][j] = 1;\n    }\n    for(int j = 0;j<x;j++){\n      ans += solve(0,j,false);\n      // cout<<\"ans:\"<<ans<<endl;\n    }\n    cout<<ans<<endl;\n    \n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <complex>\n#include <cstdlib>\n#include <cstring>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define repi(i,a,b) for(int i = (a); i < (b); i++)\n\nusing namespace std;\n\ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n\nconst int INF=1<<29;\nconst double EPS=1e-9;\n\nint X,Y;\nint board[20][20];\nint cnt;\nint memo[20][20];\nint solve(int x,int y,int dir){\n\tif(x <1||x >X||board[y][x]==1||(board[y][x]==2&&dir !=0)){\n\t\treturn 0;\n\t}else if(y >=Y){\n\t\treturn 1;\n\t}\n\tif(memo[y][x]!=-1){\n\t\treturn memo[y][x];\n\t}\n\tif(board[y][x]==2){\n\t\treturn memo[y][x]=solve(x,y+2,0);\n\t}else {\n\t\treturn memo[y][x] =solve(x-1,y+1,-1)+solve(x,y+1,0)+solve(x+1,y+1,1);\n\t}\n}\n\nint main(){\n\twhile(cin>>X>>Y,X||Y){\n\t\tcnt =0;\n\t\trep(i,20){\n\t\t\trep(j,20){\n\t\t\t\tboard[i][j]=0;\n\t\t\t\tmemo[i][j] =-1;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i <=Y;i++){\n\t\t\tfor(int j =1;j <=X;j++){\n\t\t\t\tcin>>board[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i =1;i <=X;i++){\n\t\t\tif(board[1][i]==0){\n\t\t\t\tcnt+=solve(i,1,0);\n\t\t\t}\n\t\t\t//cout <<endl;\n\t\t}\n\t\tcout <<cnt<<endl;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 0203\n#include <iostream>\n\nusing namespace std;\n\nint main(void)\n{\n\tint x, y;\n\twhile (cin >> x >> y, x || y){\n\t\tint field[32][32];\n\t\tfor (int i = 1; i <= y; i++){\n\t\t\tfor (int j = 1; j <= x; j++){\n\t\t\t\tcin >> field[i][j];\n\t\t\t}\n\t\t}\n\t\tint dp[32][32];\n\t\tfor (int i = 0; i < 32; i++) {\n\t\t\tfor (int j = 0; j < 32; j++){\n\t\t\t\tdp[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor (int j = 1; j <= x; j++){\n\t\t\tif (field[1][j] == 0){\n\t\t\t\tdp[1][j] = 1;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= y; i++){\n\t\t\tfor (int j = 1; j <= x; j++){\n\t\t\t\tif (field[i][j] == 1){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (field[i][j] == 2){\n\t\t\t\t\tdp[i + 2][j] += dp[i][j];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (field[i + 1][j - 1] == 0){\n\t\t\t\t\tdp[i + 1][j - 1] += dp[i][j];\n\t\t\t\t}\n\t\t\t\tif (field[i + 1][j] != 1){\n\t\t\t\t\tdp[i + 1][j] += dp[i][j];\n\t\t\t\t}\n\t\t\t\tif (field[i + 1][j + 1] == 0){\n\t\t\t\t\tdp[i + 1][j + 1] += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// for (int i = 1; i <= y; i++){\n\t\t// \tfor (int j = 1; j <= x; j++){\n\t\t// \t\tcout << dp[i][j] << \" \";\n\t\t// \t}\n\t\t// \tputs(\"\");\n\t\t// }\n\n\t\tint ret = 0;\n\t\tfor (int i = y - 1; i <= y; i++){\n\t\t\tfor (int j = 1; j <= x; j++){\n\t\t\t\tif (i == y - 1){\n\t\t\t\t\tif (field[i][j] == 2) ret += dp[i][j];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tret += dp[i][j];\n\t\t\t\t\t// cout << i << \" \" << j << endl;\n\t\t\t\t\t// cout << ret << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ret << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\nint x,y;\nint c[20][20];\nint dp[20][20];\n\nvoid solve() {\n    rep(i,20) rep(j,20) c[i][j]=1;\n    rep(i,20) rep(j,20) dp[i][j]=0;\n    rep(i,y) rep(j,x) cin>>c[i][j];\n    rep(i,x) if(c[0][i]!=1) dp[0][i]=1;//????????????????????????????????£??????DP???????????????????¨?????????????\n    for(int i=0;i<y;i++) {\n        for(int j=0;j<x;j++) {\n            if(c[i][j]==2) {\n                dp[i+2][j] += dp[i][j];\n            }\n            else if(c[i][j]==0) {\n                if(c[i+1][j]!=1) {\n                    dp[i+1][j] += dp[i][j];\n                }\n                if(0<=j-1 && c[i+1][j-1]==0) {\n                    dp[i+1][j-1] += dp[i][j];\n                }\n                if(j+1 < x && c[i+1][j+1]==0) {\n                    dp[i+1][j+1] += dp[i][j];\n                }\n            }\n        }\n    }\n    int ans=0;\n    rep(i,x) if(c[y-1][i]!=1) ans+=dp[y-1][i];\n    rep(i,x) ans+=dp[y][i];\n    cout<<ans<<endl;\n}\nint main() {\n    while(cin>>x>>y) {\n        if(x+y==0) return 0;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(long long i=(a);i<(b);i++)\n#define REP(i,N) for(long long i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define fi first\n#define se second\n\n#define PI acos(-1.0)\n#define INF 1000000007\n#define EPS 1e-10\n#define MAX_N 20000\n#define MAX_M 16\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<double, double> PD;\ntypedef pair<string, ll> PS;\ntypedef vector<ll> V;\ntypedef pair<P, char> PC;\n\nint x, y;\nint field[16][16];\nint dp[16][16];\n\nint main(){\n\twhile (cin >> x >> y&&x + y){\n\t\tREP(i, 16){\n\t\t\tREP(j, 16){\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tfield[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tREP(i, y)REP(j, x)cin >> field[i][j];\n\t\tREP(j, x){\n\t\t\tif (field[0][j] == 0)dp[0][j] = 1;\n\t\t}\n\t\tREP(i, y-1){\n\t\t\tREP(j, x){\n\t\t\t\tif (field[i][j] == 0){\n\t\t\t\t\tif (field[i + 1][j] != 1)dp[i + 1][j] += dp[i][j];\n\t\t\t\t\tif (j - 1 >= 0 && field[i + 1][j - 1] == 0){\n\t\t\t\t\t\tdp[i + 1][j - 1] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tif (j + 1 < x&&field[i + 1][j + 1] == 0){\n\t\t\t\t\t\tdp[i + 1][j + 1] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (field[i][j] == 2){\n\t\t\t\t\tif (i <= y - 3 && dp[i + 2][j] != 1){\n\t\t\t\t\t\tdp[i + 2][j] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t\telse if (i == y - 2){\n\t\t\t\t\t\tdp[i + 1][j] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//cout << endl;\n\t\t//REP(i, y + 1){\n\t\t//\tREP(j, x){\n\t\t//\t\tcout << dp[i][j] << \" \";\n\t\t//\t}\n\t\t//\tcout << endl;\n\t\t//}\n\t\tint ans = 0;\n\t\tREP(j, x)ans += dp[y-1][j];\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint w,h;\nint mp[20][20],memo[20][20];\nint saiki(int x,int y){\n  if(y >= h-1) return 1;\n  for(int i=-1;i<=1;i++) {\n    int nx = x+i, ny = y+1;\n    if(nx==x && mp[ny][nx] == 2)while(mp[ny][nx] == 2) ny+=2;\n    if(nx <0|| nx >= w ||mp[ny][nx] != 0) continue;\n    if(memo[ny][nx]==0) memo[y][x]+=saiki(nx,ny);\n    else memo[y][x] += memo[ny][nx];\n  }\n  if(memo[y][x]==0) mp[y][x] = 1;\n  return memo[y][x];\n}\nint main() {\n  while(1) {\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n    for(int i=0;i<=19;i++)\n      for(int j=0;j<=19;j++)memo[i][j] = mp[i][j] = 0;\n    \n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)cin >> mp[i][j];\n   \n    int cnt = 0;  \n    for(int i=0;i<w;i++)\n      if(mp[0][i] !=1)cnt+=saiki(i,0);\n    cout << cnt <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* {{{ Shinobu kawaii */\n/*\n  ______   __        _                  __                 \n.' ____ \\ [  |      (_)                [  |                \n| (___ \\_| | |--.   __   _ .--.   .--.  | |.--.   __   _   \n _.____`.  | .-. | [  | [ `.-. |/ .'`\\ \\| '/'`\\ \\[  | | |  \n| \\____) | | | | |  | |  | | | || \\__. ||  \\__/ | | \\_/ |, \n \\______.'[___]|__][___][___||__]'.__.'[__;.__.'  '.__.'_/ \n\n*/\n// clang-format off\n/* }}} */\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n// #define int long long\nstruct Fast {Fast(){std::cin.tie(0);ios::sync_with_stdio(false);}} fast;\n\n/* cpp template {{{ */\n\n/* short */\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define Fi first\n#define Se second\n#define ALL(v) begin(v), end(v)\n#define RALL(v) rbegin(v), rend(v)\n#define X real()\n#define Y imag()\n\n/* REPmacro */\n#define REPS(i, a, n) for (ll i = (a); i < (ll)(n); ++i)\n#define REP(i, n) REPS(i, 0, n)\n#define RREP(i, n) REPS(i, 1, n + 1)\n#define DEPS(i, a, n) for (ll i = (a); i >= (ll)(n); --i)\n#define DEP(i, n) DEPS(i, n, 0)\n\n/* debug */\n#define debug(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n';\n\n/* alias */\nusing ll = long long;\nusing ull = unsigned long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nusing pii = pair<int, int>;\nusing D = double;\nusing P = complex<D>;\nusing vs = vector<string>;\ntemplate <typename T> using PQ = priority_queue<T>;\ntemplate <typename T> using minPQ = priority_queue<T, vector<T>, greater<T>>;\n\n/* const */\nconst int INF = 1001001001;\nconst ll LINF = 1001001001001001001ll;\nconst int MOD = 1e9 + 7;\nconst D EPS = 1e-9;\nconst int dx[] = {0, 1, 0, -1, 1, -1, 1, -1}, dy[] = {1, 0, -1, 0, 1, -1, -1, 1};\n\n/* func */\ninline bool inside(int y, int x, int H, int W) {return y >= 0 && x >= 0 && y < H && x < W;}\ninline int in() {int x; cin >> x; return x;}\ninline ll IN() {ll x; cin >> x; return x;}\ninline vs split(const string& t, char c) {vs v; stringstream s(t); string b; while(getline(s, b, c)) v.eb(b); return v;}\ntemplate <typename T> inline bool chmin(T& a, const T& b) {if (a > b) a = b; return a > b;}\ntemplate <typename T> inline bool chmax(T& a, const T& b) {if (a < b) a = b; return a < b;}\ntemplate <typename T> inline void print(const T& x) {cout << x << '\\n';}\ntemplate <typename T, typename S> inline void print(const vector<pair<T, S>>& v) {for (auto&& p : v) print(p);}\ntemplate <typename T> inline void print(const vector<T>& v, string s = \" \") {REP(i, v.size()) cout << v[i] << (i != (ll)v.size() - 1 ? s : \"\\n\");}\n// clang-format on\n/* }}} */\n\nint w, h;\nint field[20][20];\nint memo[20][20];\n\nll dfs(int y, int x, int yy = -1, int xx = -1) {\n  if (!inside(y, x, INF, w)) return 0;\n  if (field[y][x] == 1) return 0;\n  if (y > h - 1) return 1;\n  if (y == h - 1 && field[y][x] == 0) return 1;\n  if (field[y][x] == 2 && x != xx) return 0;\n\n  if (memo[y][x] != -1) return memo[y][x];\n\n  ll res;\n  if (field[y][x] == 2) {\n    res = dfs(y + 2, x, y, x);\n  } else {\n    res = dfs(y + 1, x, y, x) + dfs(y + 1, x + 1, y, x) + dfs(y + 1, x - 1, y, x);\n  }\n\n  return memo[y][x] = res;\n}\n\nsigned main() {\n  while (cin >> w >> h, w || h) {\n    memset(field, -1, sizeof(field));\n    memset(memo, -1, sizeof(memo));\n    REP(i, h) REP(j, w) field[i][j] = in();\n    ll ans = 0;\n    REP(i, w) {\n      ans += dfs(0, i);\n    }\n    print(ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main(){\n\tint w,h;\n\n\twhile( cin >> w >> h , w||h ){\n\t\tint f[200][200] = {0};\n\t\tfor(int y=1 ; y <= h ; y++ ){\n\t\t\tfor(int x=1 ; x <= w ; x++ ){\n\t\t\t\tcin >> f[y][x];\n\t\t\t}\n\t\t}\n\n\t\tint dp[200][200] = {0};\n\t\tfor(int x=1 ; x <= w ; x++ )\n\t\t\tdp[1][x] = 1;\n\t\tfor(int y=1 ; y <= h-1 ; y++ ){\n\t\t\tfor(int x=1 ; x <= w ; x++ ){\n\t\t\t\tif( f[y][x] == 0 ){\n\t\t\t\t\tif( f[y+1][x-1] == 0 ) dp[y+1][x-1] += dp[y][x];\n\t\t\t\t\tif( f[y+1][x]   == 0 ) dp[y+1][x]   += dp[y][x];\n\t\t\t\t\tif( f[y+1][x+1] == 0 ) dp[y+1][x+1] += dp[y][x];\n\t\t\t\t\tif( f[y+1][x]   == 2 ) dp[y+1][x]   += dp[y][x];\n\t\t\t\t}else if( f[y][x] == 2 ){\n\t\t\t\t\tif( f[y+2][x] == 0 ) dp[y+2][x] += dp[y][x];\n\t\t\t\t\tif( f[y+2][x] == 2 ) dp[y+2][x] += dp[y][x];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int x=1 ; x <= w ; x++ ){\n\t\t\tans += dp[h][x] + dp[h+1][x];\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\t#include <iostream>\n\t#define rep2(x,from,to) for(int x=(from);(x)<(to);(x)++)\n\t#define rep(x,to) rep2(x,0,to)\n\tusing namespace std;\n\tint main(){\n\t\tint x, y;\n\t\twhile(cin >> x >> y && (x||y) ) {\n\t\t\tint b[15][15] = {};\n\t\t\trep(i,y) {\n\t\t\t\trep(j,x) {\n\t\t\t\t\tcin >> b[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ret[20][20] = {};\n\t\t\trep(i,x) {\n\t\t\t\tif(b[0][i] == 0) {\n\t\t\t\t\tret[0][i+1] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep2(i,1,y) {\n\t\t\t\trep(j,x) {\n\t\t\t\t\tif(b[i][j] == 0) {\n\t\t\t\t\t\tret[i][j+1] += ret[i-1][j] + ret[i-1][j+1] + ret[i-1][j+2];\n\t\t\t\t\t\trep2(k,-1,2) {\n\t\t\t\t\t\t\tif(b[i-1][j+k] == 2) ret[i][j+1] -= ret[i-1][j+k+1];\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(b[i][j] == 2) {\t\n\t\t\t\t\t\tif(b[i-1][j] == 0) ret[i][j+1] += ret[i-1][j+1];\n\t\t\t\t\t\tif(y <= i+2 || b[i+2][j] != 1) ret[i+2][j+1] += ret[i][j+1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = 0;\n\t\t\trep2(i,y-1,y+2) {\n\t\t\t\trep(j,x) {\n\t\t\t\t\tans += ret[i][j+1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << ans << endl;\n\t\t}\n\t}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint X,Y;\nint dp[20][20];\nchar maps[20][20];\nint bun(int x,int y);\nint dx[3]={-1,0,1};\nmain(){\n  while(1){\n    cin>>X>>Y;\n    if(X==0&&Y==0){\n      break;\n    }\n    for(int i=1;i<=Y;i++){\n      for(int j=1;j<=X;j++){\n\tcin>>maps[i][j];\n\tdp[i][j]=0;\n      }\n    }\n    int ans=0;\n    for(int i=1;i<=X;i++){\n      if(maps[1][i]!='1'){\n\tans+=bun(1,i);\n      }\n    }\n    cout<<ans<<endl;\n  }\n}\nint bun(int y,int x){\n  if(y>=Y+1){\n    return 1;\n  }\n  else if(dp[y][x]!=0){\n    return dp[y][x];\n  }\n  else if(maps[y][x]=='2'&&(y+2>=Y+1||maps[y+2][x]!='1')){\n    return bun(y+2,x);\n  }\n  else if(maps[y][x]=='1'){\n    return 0;\n  }\n  else{\n    int anss=0;\n    for(int i=0;i<3;i++){\n      int nx=x+dx[i];\n      if(i!=1){\n\tif(nx>0&&nx<=X&&maps[y+1][nx]=='0'){\n\t  anss+=bun(y+1,nx);\n\t}\n      }\n      else{\n\tif(maps[y+1][nx]=='2'&&(y+3>=Y+1||maps[y+3][nx]!='1')){\n\t  anss+=bun(y+3,nx);\n\t}\n\telse if(maps[y+1][nx]!='1'){\n\t  anss+=bun(y+1,nx);\n\t}\n      }\n    }\n    return dp[y][x]=anss;\n  }\t  \t  \n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <complex>\n#include <cstdlib>\n#include <cstring>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define repi(i,a,b) for(int i = (a); i < (b); i++)\n\nusing namespace std;\n\ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n\nconst int INF=1<<29;\nconst double EPS=1e-9;\n\nconst int dx[]={-1,0,1};\nint X,Y;\nint board[20][20];\nint cnt;\nvoid dfs(int y,int x){\n\twhile(board[y][x]==2){\n\t\ty+=2;\n\t}\n\tif(y>=Y){\n\t\tcnt++;\n\t\t//printf(\"(y,x) =(%d,%d)\\n\",y,x);\n\t\treturn;\n\t}\n\t\n\t//cout <<\"y = \"<<y <<\" x = \"<<x<<endl;\n\tfor(int i =0; i<3;i++){\n\t\tint nx =x +dx[i];\n\t\tint ny =y +1;\n\t\tif(nx <1||nx>X)continue;\n\t\tif(i!=1&&board[ny][nx]==2)continue;\n\t\tif(board[ny][nx]==1)continue;\n\t\tif(board[ny][nx]==0||board[ny][nx]==2){\n\t\t\tdfs(ny,nx);\n\t\t}\n\t}\n\treturn;\n}\n\nint main(){\n\twhile(cin>>X>>Y,X||Y){\n\t\tcnt =0;\n\t\trep(i,20)rep(j,20)board[i][j]=0;\n\t\tfor(int i=1;i <=Y;i++){\n\t\t\tfor(int j =1;j <=X;j++){\n\t\t\t\tcin>>board[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i =1;i <=X;i++){\n\t\t\tif(board[1][i]==0){\n\t\t\t\tdfs(1,i);\n\t\t\t}\n\t\t\t//cout <<endl;\n\t\t}\n\t\tcout <<cnt<<endl;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n\nusing namespace std;\n\nconst int MAX = 17;\nint in[MAX][MAX], X,Y,data[MAX][MAX],ans;\nint dx[4] = {-1,0,1};\n\n\nvoid init(){\n  memset(data,0,sizeof(data));\n  ans = 0;\n}\n\n\nvoid solve(){\n  for(int i = 1; i <= Y; i++)\n    for(int j = 1; j <= X; j++){\n      for(int k = 0; k < 3; k++)\n\tif(in[i][j] == 0){\n\t  int f = j+dx[k];\n\t  if(i-1 > 0 && 0 < f && f <= X){\n\t    if(in[i-1][f] != 2) data[i][j] += data[i-1][f];\n\t    // if(i-2 > 0 && in[i-1][f] == 2) data[i][j] += data[i-2][f];\n\t  }\n\n\t}else if(in[i][j] == 2){\n\t  if(i-1 > 0) data[i][j] += data[i-1][j];\n\t  if(i+2 <= Y) data[i+2][j] += data[i][j];\n\t  break;\n\t}\n\t/*\n\tif(i-1 > 0 && j+dx[k] > 0 && j+dx[k] <= X && in[i][j] != 1 && in[i-1][j+dx[k]] != 2){\n\t  if(in[i][j] == 2) data[i][j] = data[i-1][j];\n\t  else data[i][j] += data[i-1][j+dx[k]];\n\t}\n      if(i-2 > 0 && in[i-2][j] == 2 && in[i][j] != 1) data[i][j] += data[i-2][j];\n\t*/\n    }\n\n  for(int j = 1; j <= X; j++){\n    if(Y-1 > 0 && in[Y-1][j] == 2) ans+=data[Y-1][j];\n    ans+=data[Y][j];\n  }\n  cout << ans << endl;\n}\n\nvoid print(){\n  for(int i = 1; i <= Y; i++){\n    for(int j = 1; j <= X; j++)\n      cout << data[i][j]<< \" \";\n    cout << endl;\n  }\n}\nint main(){\n  while(cin >> X >> Y && X+Y){\n    init();\n    for(int i = 1; i <= Y; i++)\n      for(int j = 1; j <= X; j++)\n\tcin >> in[i][j];\n    \n    for(int i = 1; i <= X; i++)\n      if(in[1][i] == 0) data[1][i] = 1;\n\n    solve();\n    //print();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n\nusing namespace std;\n\n\nint main() {\n\twhile(1) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tif(x==0 && y==0) break;\n\t\tint field[x][y];\n\t\tint dp[x][y];\n\t\tfor(int i=0; i<x; i++) {\n\t\t\tfor(int j=0; j<y; j++) {\n\t\t\t\tcin >> field[i][j];\n\t\t\t\tdp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<x; i++) {\n\t\t\tfor(int j=0; j<y; j++) {\n\t\t\t\tif(i==0) dp[i][j] = 1;\n\t\t\t\telse {\n\t\t\t\t\tif(field[i][j] == 0) {\n\t\t\t\t\t\tif(0<j && field[i-1][j-1] == 0) dp[i][j] += dp[i-1][j-1];\n\t\t\t\t\t\tif(field[i-1][j] == 0) dp[i][j] += dp[i-1][j];\n\t\t\t\t\t\tif(j<y-1 && field[i-1][j+1] == 0) dp[i][j] += dp[i-1][j+1];\n\t\t\t\t\t}\n\t\t\t\t\tif(field[i][j] == 2) {\n\t\t\t\t\t\tdp[i][j] += dp[i-1][j];\n\t\t\t\t\t\tif(j+1 < x) dp[i+1][j] += dp[i][j];\n\t\t\t\t\t\tif(j+2 < x) dp[i+2][j] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint sum=0;\n\t\tfor(int i=0; i<y; i++) sum += dp[x-1][i];\n\t\tcout << sum;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nint main(void){\n\tint x,y,i,j;\n\twhile(scanf(\"%d%d\",&x,&y),x,y){\n\t\tint masu[20][20]={ 0 };\n\t\tint dp[20][20]={0};\n\t\tint ans=0;\n\t\tfor(i=1;i<=y;i++){\n\t\t\tfor(j=1;j<=x;j++){\n\t\t\t\tscanf(\"%d\",&masu[i][j]);\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<=y;i++)masu[i][0]=1;\n\t\tfor(j=0;j<=x;j++)masu[0][j]=1;\n\t\t\n\t\tfor(j=1;j<=x;j++){\n\t\t\tif(masu[1][j]==0)dp[1][j]=1;\n\t\t}\n\t\tfor(i=2;i<=y;i++){\n\t\t\tfor(j=1;j<=x;j++){\n\t\t\t\tif(masu[i][j]==0){\n\t\t\t\t\tif(masu[i-1][j-1]==0)dp[i][j]+=dp[i-1][j-1];\n\t\t\t\t\tif(masu[i-1][j]==0)\t dp[i][j]+=dp[i-1][j];\n\t\t\t\t\tif(masu[i-1][j+1]==0)dp[i][j]+=dp[i-1][j+1];\n\t\t\t\t\tif(masu[i-2][j]==2){\n\t\t\t\t\t\tdp[i][j]+=dp[i-2][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(masu[i][j]==1){\n\t\t\t\t\tdp[i][j]=0;\n\t\t\t\t}\n\t\t\t\tif(masu[i][j]==2){\n\t\t\t\t\tif(masu[i-1][j]==0)dp[i][j]=dp[i-1][j];\n\t\t\t\t\tif(masu[i-2][j]==2)dp[i][j]+=dp[i-2][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tfor(i=1;i<=y;i++){\n\t\t\tfor(j=1;j<=x;j++){\n\t\t\t\tprintf(\"%d\",dp[i][j]);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}\n\t\t*/\n\t\tfor(i=1;i<=x;i++){\n\t\t\tans+=dp[y][i];\n\t\t\tif(masu[y-1][i]==2)ans+=dp[y-1][i];\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst int MAX_SIZE = 15;\nchar field[MAX_SIZE+1][MAX_SIZE+3];\nint dp[MAX_SIZE+1][MAX_SIZE+3];\nint w, h;\n\nbool judge(int i, int j){\n\tif(j > 0 && j <= w && field[j][i] == '0' && i <= h)\n\t\treturn true;\n\treturn false;\n}\n\nint main(){\n\twhile(cin >> w >> h){\n\t\tif(w == 0 && h == 0) break;\n\t\tfor(int i = 1; i <= h; i++){\n\t\t\tfor(int j = 1; j <= w; j++)\n\t\t\t\tcin >> field[j][i];\n\t\t}\n\t\tfor(int i = h+1; i <= h+2; i++){\n\t\t\tfor(int j = 1; j <= w; j++){\n\t\t\t\tfield[j][i] = '0';\n\t\t\t}\n\t\t}\n\t\tint pattern = 0;\n\t\tfor(int i = 0; i < MAX_SIZE+1; i++){\n\t\t\tfor(int j = 0; j < MAX_SIZE+3; j++){\n\t\t\t\tdp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1; i <= w; i++){\n\t\t\tif(field[i][1] == '0')\n\t\t\t\tdp[i][1] = 1;\n\t\t}\n\t\tfor(int i = 1; i < h; i++){\n\t\t\tfor(int j = 1; j <= w; j++){\n\t\t\t\tif(field[j][i] == '2' && field[j][i+2] != '1'){\n\t\t\t\t\tdp[j][i+2] += dp[j][i];\n\t\t\t\t}else if(field[j][i] == '0'){\n\t\t\t\t\tif(field[j][i+1] != '1') dp[j][i+1] += dp[j][i];\n\t\t\t\t\tif(judge(i+1, j-1)) dp[j-1][i+1] += dp[j][i];\n\t\t\t\t\tif(judge(i+1, j+1)) dp[j+1][i+1] += dp[j][i];\n\t\t\t\t}else{\n\t\t\t\t\tdp[j][i] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tint count = 0;\n\t\tfor(int i = h; i <= h+1; i++){\n\t\t\tfor(int j = 1; j <= w; j++){\n\t\t\t\tcount += dp[j][i];\n\t\t\t}\n\t\t}\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define N 20\nusing namespace std;\nvoid func(int,int);\nint jump(int,int);\nint X,Y,data[N][N],memo[N][N];\nint main(){\n  while(1){\n    cin >> X >> Y;\n    if(X==0&&Y==0) break;\n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++) data[i][j]=0,memo[i][j]=0;\n\n    for(int i=0;i<Y;i++)\n      for(int j=0;j<X;j++) cin >> data[i][j];\n\n    for(int i=0;i<X;i++)\n      if(data[0][i]!=1) func(0,i);\n\n    int cnt=0;\n    for(int i=0;i<X;i++) cnt+=memo[0][i];\n    cout << cnt << endl;\n  }\n  return 0;\n}\nvoid func(int y,int x){\n  if(y>=Y-1){\n    memo[y][x]++;\n    return ;\n  }\n  if(0<=x-1 && data[y+1][x-1]==0){\n    if(memo[y+1][x-1]==0) func(y+1,x-1);\n    memo[y][x]+=memo[y+1][x-1];\n  }\n  if(x+1< X &&data[y+1][x+1]==0){\n    if(memo[y+1][x+1]==0) func(y+1,x+1);\n    memo[y][x]+=memo[y+1][x+1];\n  }\n  if(data[y+1][x]==0){\n    if(memo[y+1][x]==0) func(y+1,x);\n    memo[y][x]+=memo[y+1][x];\n  }\n  if(data[y+1][x]==2){\n    int r=jump(y+1,x);\n    if(r!=-1){\n      if(memo[r][x]==0) func(r,x);\n      memo[y][x]+=memo[r][x];\n    }\n  }\n  if(memo[y][x]==0) data[y][x]=1;\n}\nint jump(int y,int x){\n  while(data[y][x]==2)y+=2;\n  if(data[y][x]==0||y>=Y-1) return y;\n  return -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint w,h;\nint mp[16][16];\nint ans;\nint count;\n\nint saiki(int x,int y) {\n  count++;\n  // cout << x <<\" \"<<y <<endl;\n  int dx[3] = {-1,0,1};\n  int dy[3] = {1,1,1};\n  if(mp[y][x] == 2) y+=2;\n  \n  if((y >= h)||(y==h-1 && mp[y][x] != 1)) ans++;//,cout <<\"ok\"<<endl;  \n  else if(mp[y][x] != 1) {\n    for(int i=0;i<3;i++) {\n      int nx = dx[i]+x;\n      int ny = dy[i]+y;\n      if(nx <0||ny <0||nx >= w|| ny>=h) continue;\n      if(mp[ny][nx] == 0){\n      saiki(nx,ny);\n      }\n      else if(nx==x && mp[ny][nx] == 2 ){\n\tsaiki(nx,ny+2);\n      }\n    } \n  }\n}\n\nint main() {\n\n  while(1) {\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n\n    for(int i=0;i<h;i++) \n      for(int j=0;j<w;j++) \n\tcin >> mp[i][j];\n    /*\n    for(int i=0;i<h;i++) {\n      for(int j=0;j<w;j++) \n\tcout << mp[i][j];\n\t  cout << endl;\n    }\n    */\n\n    ans = 0;\n    count = 0;\n    for(int i=0;i<w;i++) {\n      if(mp[0][i] !=1) saiki(i,0);\n    }\n    cout << ans << endl;\n    //cout << count << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main()\n{\n  int X, Y;\n  while (cin >> X >> Y) {\n    if ((X|Y) == 0)\n      break;\n\n    vector<vector<int> > cource(Y+1, vector<int>(X, 0));\n    for (int i = 0; i < Y; ++i) {\n      for (int j = 0; j < X; ++j)\n\tcin >> cource[i][j];\n    }\n\n    vector<vector<int> > dp(Y+1, vector<int>(X, 0));\n    for (int i = 0; i < X; ++i) {\n      if (cource[0][i] == 0)\n\tdp[0][i] = 1;\n    }\n\n    for (int i = 0; i < Y-1; ++i) {\n      for (int j = 0; j < X; ++j) {\n\tif (cource[i][j] == 0) {\n\t  if (cource[i+1][j] != 1)\n\t    dp[i+1][j] += dp[i][j];\n\t  if (j-1 >= 0 && cource[i+1][j-1] == 0)\n\t    dp[i+1][j-1] += dp[i][j];\n\t  if (j+1 < X && cource[i+1][j+1] == 0)\n\t    dp[i+1][j+1]+= dp[i][j];\n\t} else if (cource[i][j] == 2 && cource[i+2][j] != 1) {\n\t    dp[i+2][j] += dp[i][j];\n\t}\n      }\n    }\n\n    int ans = 0;\n    for (int i = 0; i < X; ++i) {\n\tans += dp[Y-1][i];\n\tans += dp[Y][i];\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint maps[20][20];\nint course[20][20];\nint X, Y;\n\nvoid out();\nint way(int y, int x){\n  if(course[y][x] > 0) return course[y][x];\n  else if(maps[y][x] == 1) return 0;\n  else if(y >= Y) return 1;\n  else if(maps[y][x] == 2 && maps[y + 2][x] != 1) return course[y][x] = way(y + 2, x);\n  else{\n    int SUM = 0;\n    for(int i = 0; i < 3; i++){\n      int ny = y + 1;\n      int nx = x - 1 + i;\n      if(maps[ny][nx] != 1 && 1 <= nx && nx <= X){\n\tint flug = 1;\n\tif(i != 1 && maps[ny][nx] == 2) flug = 0;\n\tif(flug) SUM += way(ny, nx);\n      }\n    }\n    return course[y][x] = SUM;\n  }\n} \n\nint main(){\n  while(1){\n    cin >> X >> Y;\n    if(X == 0 && Y == 0) break;\n    for(int i = 1; i <= Y; i++){\n      for(int j = 1; j <= X; j++){\n\tcin >> maps[i][j];\n\tcourse[i][j] = 0;\n      }\n    }\n    int cnt = 0;\n    for(int i = 1; i <= X; i++){\n      if(maps[0][i] != 1) cnt += way(1, i);\n    }\n    cout << cnt << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nlong long solve(int x,int y);\nint ax,ay;\nint mas[200][200];\nlong long memo[200][200];\nint main(){\n  while(1){\n    for(int i=0;i<200;i++){\n      for(int j=0;j<200;j++){\n\tmemo[i][j]=0;\n      }\n    }\n    long long ans=0;\n    cin>>ax>>ay;\n    if(ax==0 && ay==0) break;\n    \n    for(int i=0;i<ay;i++){\n      for(int j=0;j<ax;j++){\n\tcin>>mas[i][j];\n      }\n    }\n    \n    for(int i=0;i<ax;i++){\n      if(mas[0][i]!=1){\n\tans+=solve(i,0);\n      }\n    }\n    cout<<ans<<endl;\n  }\n}\nlong long solve(int x,int y){\n  if(y>=ay){\n    return 1;\n  }else if(memo[y][x]!=0){\n    return memo[y][x];\n  }else if(mas[y][x]==2){\n    if(mas[y+2][x]!=1){\n      return memo[y][x]=solve(x,y+2);\n    } \n    else{\n      return 0;\n    }\n  }\n  else if(mas[y][x]==1){\n    return 0;\n  }\n  else{\n    long long anss=0; \n    if(mas[y+1][x]!=1){\n      anss+=solve(x,y+1);\n    }\n    if(x+1<ax && mas[y+1][x+1]==0 && y+1!=ay){\n      anss+=solve(x+1,y+1);\n    }\n    if(0<=x-1 && mas[y+1][x-1]==0 && y+1!=ay){\n      anss+=solve(x-1,y+1);\n    }\n    return memo[y][x]=anss;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint main() {\n\tint width, height, m[15][15];\n\twhile (cin >> width >> height, width && height) {\n\t\tfor (int y = 0; y < height; ++y)\n\t\t\tfor (int x = 0; x < width; ++x)\n\t\t\t\tcin >> m[y][x];\n\n\t\tint sum = 0, pattern[15][15] = {0};\n\t\tfor (int x = 0; x < width; ++x)\n\t\t\tpattern[0][x] = 1;\n\n\t\tfor (int y = 0; y < height-1; ++y)\n\t\t\tfor (int x = 0; x < width; ++x)\n\t\t\t\tif (m[y][x] == 0) {\n\t\t\t\t\tif (x - 1 >= 0 && m[y+1][x-1] == 0) pattern[y+1][x-1] += pattern[y][x];\n\t\t\t\t\tif (x + 1 < width && m[y+1][x+1] == 0) pattern[y+1][x+1] += pattern[y][x];\n\t\t\t\t\tif (m[y+1][x] != 1) pattern[y+1][x] += pattern[y][x];\n\t\t\t\t}\n\t\t\t\telse if (m[y][x] == 2) {\n\t\t\t\t\tif (y + 2 == height) sum += pattern[y][x];\n\t\t\t\t\telse if (m[y+2][x] != 1) pattern[y+2][x] += pattern[y][x];\n\t\t\t\t}\n\n\t\tfor (int x = 0; x < width; ++x)\n\t\t\tsum += pattern[width-1][x];\n\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n//#include\nusing namespace std;\n\nstruct P{\n\tint way;\n\tint stt;\n};\n\n//グローバルは土俵F、と配列ans\n\nP F[17][17];\n//はじめにF.wayを-1で初期化 端っこ.sttを1で初期化\n\nlong ans[1000]={0};\nint counter=0,flag=0;\n\nlong solve(int x,int y);\n\nlong jump(int x,int y){\n\tif(F[x][y-2].stt==2)\n\t\treturn (F[x][y-2].way==-1) ? solve(x,y-2) : F[x][y-2].way;\n\telse return 0;\n}\n\nlong left(int x,int y){\n\tif(F[x-1][y-1].stt==0) \n\t\treturn (F[x-1][y-1].way==-1) ? solve(x-1,y-1) : F[x-1][y-1].way;\n\telse return 0;\n}\n\nlong right(int x,int y){\n\tif(F[x+1][y-1].stt==0) \n\t\treturn (F[x+1][y-1].way==-1) ? solve(x+1,y-1) : F[x+1][y-1].way;\n\telse return 0;\n}\n\nlong samex(int x,int y){\n\tif(F[x][y-1].stt==0) \n\t\treturn (F[x][y-1].way==-1) ? solve(x,y-1) : F[x][y-1].way;\n\telse return 0;\n}\n\nlong solve(int x,int y){//入力した座標までのコース数を返す 0は普通 1は障害物 2はジャンプ台\n\tif (y==1) return 1;\n\tif (F[x][y].stt==0)\n\treturn jump(x,y)+left(x,y)+right(x,y)+samex(x,y);\n\tif (F[x][y].stt==2)\n\treturn jump(x,y)+samex(x,y);\n\tif (F[x][y].stt==1)\n\treturn 0;\n\treturn 0;\n}\n\n//int solve_ex(int x,int y){//最後JUMP通過のとき jumpをそのまま使う\n\n\nvoid solver(){\n\tint X,Y;\n\tcin >> X >> Y;\n\tif(X==0) {flag=1;return;}\n\t\n\t\n\tfor(int i=0;i<17;i++){\n\t\tfor(int j=0;j<17;j++){\n\t\t\tF[i][j].way=-1;\n\t\t\tF[i][j].stt=1;\n\t\t}\n\t}\n\t\n\tfor(int i=1;i<=Y;i++){\n\t\tfor(int j=1;j<=X;j++){\n\t\t\tcin >> F[j][i].stt;\n\t\t}\n\t}\n\t\n\tfor(int x=1;x<=X;x++){\n\t\tans[counter]+=(solve(x,Y)+jump(x,Y+1));\n\t}\n\tcounter++;\n}\n\nint main(){\n\twhile(flag==0){\n\t\tsolver();\n\t}\n\t\n\tfor(int i=0;i<counter;i++){\n\t\tcout << ans[i]<<\"\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n  while(1){\n    int w,h,mp[20][20]={},dp[20][20] ={};\n    cin >> w >> h;\n    if(w==0 && h==0) break;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++) cin >> mp[i][j];\n\n    for(int i=0;i<w;i++) if(mp[0][i]==0) dp[0][i] = 1;\n\n    int ans=0;    \n    for(int i=0;i<h-1;i++)\n      for(int j=0;j<w;j++) \n\tfor(int k=-1;k<=1;k++){\n\t  int nx=j+k,ny=i+1;\n\t  if(nx<0||nx>=w || mp[i][j] !=0) continue;\n\t  if(k==0)while(mp[ny][nx]==2) ny+=2;\n\t  if(mp[ny][nx]!=0) continue;\n\t  dp[ny][nx]+= dp[i][j];\n\t  if(ny >= h-1) ans+=dp[i][j];\n\t}\n    cout << ans <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\nusing namespace std;\n\nint run[15][15],w,h;\n\nint ski(int x,int y,bool s)\t// s : go straight in previous step?\n{\n\tif(y>=h)\t\t\treturn 1;\n\tif(run[y][x]==1)\treturn 0;\n\tif(run[y][x]==2){\n\t\tif(s)\treturn ski(x,y+2,true);\n\t\telse\treturn 0;\n\t}\n\n\t// plane slope (run[y][x]==0)\n\tif(y==h-1)\treturn 1;\n\n\tint cnt=0;\n\tfor(int dx=-1;dx<=1;dx++){\n\t\tint xx=x+dx;\n\t\tif(0<=xx && xx<w)\tcnt+=ski(xx,y+1,!dx);\n\t}\n\treturn cnt;\n}\n\nint main()\n{\n\tfor(;scanf(\"%d%d\",&w,&h),w;){\n\t\tfor(int y=0;y<h;y++)\n\t\t\tfor(int x=0;x<w;x++)\n\t\t\t\tscanf(\"%d\",run[y]+x);\n\n\t\tint cnt=0;\n\t\tfor(int x=0;x<w;x++)\tcnt+=ski(x,0,true);\n\t\tprintf(\"%d\\n\",cnt);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\nusing namespace std;\n \nint main(){\n  int i,j,x,y,a[16][15],n[15][15],k,ans;\n  while(1){\n    cin >> x >> y;\n    if(x == 0 && y == 0) break;\n    for(i=0;i<y;i++){\n      for(j=0;j<x;j++){\n    cin >> n[i][j];\n      }\n    }\n \n    for(j=0;j<x;j++){\n      for(i=0;i<=y;i++) a[i][j] = 0;\n      if(n[0][j] == 0) a[0][j] = 1;\n    }\n \n    for(i=0;i<y;i++){\n      for(j=0;j<x;j++){\n    if(n[i][j] == 1) continue;\n    if(i == y-1) a[i+1][j] += a[i][j];\n    else if(n[i][j] == 0){\n      for(k=-1;k<=1;k++){\n        if(j == 0 && k == -1 || j == x-1 && k == 1) continue;\n        if(n[i+1][j+k] == 0) a[i+1][j+k] += a[i][j];\n      }\n      if(n[i+1][j] == 2) a[i+1][j] += a[i][j];\n    }\n    else if(n[i][j] == 2){\n      if(n[i+2][j] != 1) a[i+2][j] += a[i][j];\n    }\n      }\n    }\n \n    ans = 0;\n    for(j=0;j<x;j++) ans += a[y][j];\n    cout << ans << endl;\n \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\n\nint main(){\n\n  int x,y;\n  int a[100][100];\n  int w[100][100];\n\n  while(true){\n    cin >> x >> y;\n    if(!x && !y) break;\n\n    memset(w,0,sizeof(w));\n    int ans = 0;\n\n    for(int i=0;i<y;i++){\n      for(int j=0;j<x;j++) cin >> a[i][j];\n    }\n\n    for(int i=0;i<x;i++){\n      if(a[0][i] == 0) w[0][i] = 1;\n    }\n\n    for(int i=1;i<y;i++){\n      for(int j=0;j<x;j++){\n\n\tif(i-2 >= 0 && a[i-2][j] == 2) w[i][j] += w[i-2][j];\n\n\tif(j-1 >= 0 && !a[i-1][j-1] && !a[i][j]) w[i][j] += w[i-1][j-1];\n\tif(j+1 < x && !a[i-1][j+1] && !a[i][j]) w[i][j] += w[i-1][j+1];\n\n\tif(a[i][j] != 1 && a[i-1][j] != 2) w[i][j] += w[i-1][j];\n\n\tif(a[i][j] == 1) w[i][j] = 0;\n      }\n    }\n\n    for(int i=0;i<x;i++){\n      if(a[y-2][i] == 2) ans += w[y-2][i];\n      if(a[y-1][i] == 2) ans += w[y-1][i];\n    }\n\n    for(int i=0;i<x;i++){\n      if(a[y-1][i] == 0) ans += w[y-1][i];\n    }\n\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint dp[20][20][2];\nint x[20][20];\nint H, W;\nvoid A(int a, int b, int c, int d) {\n\tif (x[a][b] == 2) {\n\t\tif (d != 0) { return; }\n\t\tif (c == 1) { return; }\n\t\tif (c == 0) {\n\t\t\tif (x[a + 2][b] == 1) { return; }\n\t\t\tdp[a + 2][b][0] += dp[a][b][c];\n\t\t\treturn;\n\t\t}\n\t}\n\tif (x[a + 1][b + d] == 1) { return; }\n\tif (x[a + 1][b + d] == 2 && d != 0) { return; }\n\tif (x[a][b] == 0) {\n\t\tif (d == 0) {\n\t\t\tdp[a + 1][b + d][0] += dp[a][b][c];\n\t\t}\n\t\telse {\n\t\t\tdp[a + 1][b + d][1] += dp[a][b][c];\n\t\t}\n\t}\n}\nint main() {\n\twhile (true) {\n\t\tcin >> W >> H;\n\t\tif (H == 0 && W == 0) { break; }\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\tcin >> x[i][j];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 20; i++) {\n\t\t\tfor (int j = 0; j < 20; j++) {\n\t\t\t\tdp[i][j][0] = 0;\n\t\t\t\tdp[i][j][1] = 0;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= W; i++) {\n\t\t\tif (x[1][i] == 0) {\n\t\t\t\tdp[1][i][0] = 1;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= H - 1; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\tA(i, j, 0, -1);\n\t\t\t\tA(i, j, 0, 0);\n\t\t\t\tA(i, j, 0, 1);\n\t\t\t\tA(i, j, 1, -1);\n\t\t\t\tA(i, j, 1, 0);\n\t\t\t\tA(i, j, 1, 1);\n\t\t\t}\n\t\t}\n\t\tint sum = 0;\n\t\tfor (int j = H; j < 20; j++) {\n\t\t\tfor (int i = 1; i <= W; i++) {\n\t\t\t\tsum += dp[j][i][0] + dp[j][i][1];\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nint dx[3] = {-1, 0, 1};\nint dy[3] = {1, 1, 1};\n\nint main(void)\n{\n\tint **map, f1, f2, f3, **temp, x, y, sum, px, py;\n\t\n\twhile(scanf(\"%d %d\", &x, &y) && y > 0)\n\t{\n\t\tmap = new int *[y];\n\t\ttemp = new int *[y];\n\t\tsum = 0;\n\n\t\t//マップ土地&動的計画作成\n\t\tfor(f1 = 0; f1 < y; f1++)\n\t\t{\n\t\t\tmap[f1] = new int [x];\n\t\t\ttemp[f1] = new int [x];\n\t\t}\n\t\t//マップ構成入力&初期化\n\t\tfor(f1 = 0; f1 < y; f1++)\n\t\t{\n\t\t\tfor(f2 = 0; f2 < x; f2++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\",&map[f1][f2]);\n\t\t\t\ttemp[f1][f2] = 0;\n\t\t\t}\n\t\t}\n\t\t//最上のスタート地点設定\n\t\tfor(f1 = 0; f1 < x; f1++)\n\t\t{\n\t\t\tif(map[0][f1] != 1)\n\t\t\t{\n\t\t\t\ttemp[0][f1] = 1;\n\t\t\t\tsum++;\n\t\t\t}\n\t\t}\n\t\t//探索\n\t\tif(y >= 2)\n\t\t{\n\t\t\tsum = 0;\n\t\t\tfor(f1 = 0; f1 < y - 1; f1++)\n\t\t\t{\n\t\t\t\tfor(f2 = 0; f2 < x; f2++)\n\t\t\t\t{\n\t\t\t\t\tif(map[f1][f2] == 0 && temp[f1][f2] > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(f3 = 0; f3 < 3; f3++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//移動\n\t\t\t\t\t\t\tpx = f2 + dx[f3];\n\t\t\t\t\t\t\tpy = f1 + dy[f3];\n\t\t\t\t\t\t\t//範囲内か\n\t\t\t\t\t\t\tif(px >= 0 && px < x)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t//同じｘ座標からのジャンプ台\n\t\t\t\t\t\t\t\tif(f3 == 1 && py < y - 1){\n\t\t\t\t\t\t\t\t\t//ｙ軸2つ先へ\n\t\t\t\t\t\t\t\t\twhile(py < y - 1 && map[py][px] == 2)\n\t\t\t\t\t\t\t\t\t\tpy += 2;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t//着地した場所がゴール地点のｙ座標と同じで障害物にぶつかってないか\n\t\t\t\t\t\t\t\t//ゴール地点のｙ座標を超えたか\n\t\t\t\t\t\t\t\tif(py > y - 1 || py == y - 1 && map[py][px] != 1)\n\t\t\t\t\t\t\t\t\tsum += temp[f1][f2];\n\t\t\t\t\t\t\t\t//超えてないが、障害物がない地点に着地したか\n\t\t\t\t\t\t\t\telse if(map[py][px] == 0)\n\t\t\t\t\t\t\t\t\ttemp[py][px] += temp[f1][f2];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//出力\n\t\tprintf(\"%d\\n\",sum);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\nint main()\n{\n\tint map[100][100];\n\tint dp[100][100];\n\t\n\tint X, Y;\n\twhile (scanf(\"%d %d\", &X, &Y), X + Y){\n\t\tfor (int i = 0; i < 100; i++){\n\t\t\tdp[0][i] = 1;\n\t\t\tfor (int j = 1; j < 100; j++){\n\t\t\t\tdp[j][i] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < Y; i++){\n\t\t\tfor (int j = 0; j < X; j++){\n\t\t\t\tscanf(\"%d\", &map[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < Y; i++){\n\t\t\tfor (int j = 0; j < X; j++){\n\t\t\t\tif (map[i][j] == 0){\n\t\t\t\t\tfor (int k = -1; k <= 1; k++){\n\t\t\t\t\t\tif (j + k >= 0 && j + k < X && (map[i + 1][j + k] == 0 || (k == 0 && map[i + 1][j + k] == 2)) && (i < Y - 1 || k == 0)){\n\t\t\t\t\t\t\tdp[i + 1][j + k] += dp[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (map[i][j] == 2){\n\t\t\t\t\tdp[i + 2][j] += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < X; i++){\n//\t\t\tprintf(\"%d \", dp[Y][i]);\n\t\t\tsum += dp[Y][i];\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", sum);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(long long i=(a);i<(b);i++)\n#define REP(i,N) for(long long i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define fi first\n#define se second\n\n#define PI acos(-1.0)\n#define INF 1000000007\n#define EPS 1e-10\n#define MAX_N 20000\n#define MAX_M 16\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<double, double> PD;\ntypedef pair<string, ll> PS;\ntypedef vector<ll> V;\ntypedef pair<P, char> PC;\n\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(long long i=(a);i<(b);i++)\n#define REP(i,N) for(long long i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define fi first\n#define se second\n\n#define PI acos(-1.0)\n#define INF 1000000007\n#define EPS 1e-10\n#define MAX_N 20000\n#define MAX_M 16\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<double, double> PD;\ntypedef pair<string, ll> PS;\ntypedef vector<ll> V;\ntypedef pair<P, char> PC;\n\nint x, y;\nint field[16][16];\nint dp[16][16];\n\nint main(){\n\twhile (cin >> x >> y&&x + y){\n\t\tREP(i, 16){\n\t\t\tREP(j, 16){\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tfield[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tREP(i, y)REP(j, x)cin >> field[i][j];\n\t\tREP(j, x){\n\t\t\tif (field[0][j] == 0)dp[0][j] = 1;\n\t\t}\n\t\tREP(i, y - 1){\n\t\t\tREP(j, x){\n\t\t\t\tif (field[i][j] == 0){\n\t\t\t\t\tif (field[i + 1][j] != 1)dp[i + 1][j] += dp[i][j];\n\t\t\t\t\tif (j - 1 >= 0 && field[i + 1][j - 1] == 0){\n\t\t\t\t\t\tdp[i + 1][j - 1] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tif (j + 1 < x&&field[i + 1][j + 1] == 0){\n\t\t\t\t\t\tdp[i + 1][j + 1] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (field[i][j] == 2){\n\t\t\t\t\tif (i + 2 <= y - 1 && field[i + 2][j] != 1){\n\t\t\t\t\t\tdp[i + 2][j] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tdp[i + 1][j] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tREP(j, x)ans += dp[y - 1][j];\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<queue>\n#include<string>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define reps(i,n) for(int i=1;i<=int(n);i++)\n#define sint(i) scanf(\"%d\",&i);\n#define sintt(i,j) scanf(\"%d%d\",&i,&j);\n#define sinttt(i,j,k) scanf(\"%d%d%d\",&i,&j,&k);\n#define sintttt(i,j,k,m) scanf(\"%d%d%d%d\",&i,&j,&k,&m);\n\n#define INF 1010000000\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\n\n\nint main(){\n\twhile(1){\n\t\tint n,m;\n\t\tsintt(n,m);\n\t\tif(n==0)break;\n\t\tint masu[17][17];\n\t\tint dp[17][17];\n\t\t\n\t\trep(i,17)rep(j,17)masu[i][j]=dp[i][j]=0;\n\t\t\n\t\trep(i,m)rep(j,n){\n\t\t\tsint(masu[j+1][i]);\n\t\t}\n\t\t\n\t\treps(j,n){\n\t\t\tif(masu[j][0]==0){\n\t\t\t\tdp[j][0]=1;\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(i,m-1){\n\t\t\treps(j,n){\n\t\t\t\tif(masu[j][i]==1){\n\t\t\t\t\tdp[i][j]=0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(masu[j][i]==2){\n\t\t\t\t\tif(masu[j][i+2]!=1){\n\t\t\t\t\t\tdp[j][i+2]+=dp[j][i];\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(masu[j][i]==0){\n\t\t\t\t\tif(masu[j-1][i+1]==0){\n\t\t\t\t\t\tdp[j-1][i+1]+=dp[j][i];\n\t\t\t\t\t}\n\t\t\t\t\tif(masu[j+1][i+1]==0){\n\t\t\t\t\t\tdp[j+1][i+1]+=dp[j][i];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(masu[j][i+1]!=1){\n\t\t\t\t\t\tdp[j][i+1]+=dp[j][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans=0;\n\t\tfor(int i=m-1;i<=m;i++){\n\t\t\treps(j,n){\n\t\t\t\tans+=dp[j][i];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double ESP=1e-10;\nusing namespace std;\nint main(){\n  int n,m;\n  while(cin>>m>>n,n||m){\n    vector<vector<int> >in(n,vector<int>(m));\n    vector<vector<int> >dp(n+1,vector<int>(m));\n    rep(i,n)rep(j,m)cin>>in[i][j];\n    rep(i,m)if(in[0][i]==0)dp[0][i]=1;\n    loop(i,1,n+1){\n      rep(j,m){\n\tif(i<n&&in[i][j]==1)continue;\n\telse if(i!=n){\n\t  if(j!=0&&in[i-1][j-1]==0&&in[i][j]!=2)dp[i][j]+=dp[i-1][j-1];\n\t  if(in[i-1][j]==0)dp[i][j]+=dp[i-1][j];\n\t  if(j!=m&&in[i-1][j+1]==0&&in[i][j]!=2)dp[i][j]+=dp[i-1][j+1];\n\t  if(i!=1&&in[i-2][j]==2)dp[i][j]+=dp[i-2][j];\n\t}else if(i-2>=0&&in[i-2][j]==2)dp[i][j]+=dp[i-2][j];\n      }      \n    }\n    int sum=0;\n    //rep(i,n+1){rep(j,m)printf(\" %2d\",dp[i][j]);puts(\"\");}\n    loop(i,n-1,n+1)rep(j,m)sum+=dp[i][j];\n    cout<<sum<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<string> vstring;\n\nstruct Edge{int to,from,cost;};\n\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep0(i,n) for(i=0;i<(n);++i)\n#define repn(i,m,n) for(int i=(m);i<=(n);++i)\n#define all(n) n.begin(),n.end()\n#define sz(n) ((int)(n).size())\n#define mp make_pair\n#define PUTLINE cout<<\"LINE:\"<<__LINE__<<endl;\n\nconst int INF = 2147483647;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nconst int dx[]={1,-1,0,0,1,1,-1,-1,0};\nconst int dy[]={0,0,1,-1,1,-1,1,-1,0};\n\nint c[20][20];\nint r[20][20];\n\nint main() {\n\tint x,y;\n\tfor(;;){\n\t\tcin>>x>>y;\n\t\tif(x==0&&y==0)break;\n\t\tmemset(c,0,sizeof(c));\n\t\tmemset(r,0,sizeof(r));\n\t\trep(i,y)rep(j,x)c[i][j+1]=in();\n\t\trep(i,x)if(c[0][i+1]==0)r[0][i+1]=1;\n\t\trepn(i,1,y-1)repn(j,1,x){\n\t\t\tif(c[i][j]==0){\n\t\t\t\tif(c[i-1][j-1]==0)r[i][j]+=r[i-1][j-1];\n\t\t\t\tif(c[i-1][j]==0)r[i][j]+=r[i-1][j];\n\t\t\t\tif(c[i-1][j+1]==0)r[i][j]+=r[i-1][j+1];\n\t\t\t\tif(i>1&&c[i-2][j]==2)r[i][j]+=r[i-2][j];\n\t\t\t}\n\t\t\tif(c[i][j]==2){\n\t\t\t\tif(c[i-1][j]==0)r[i][j]+=r[i-1][j];\n\t\t\t\tif(i>1&&c[i-2][j]==2)r[i][j]+=r[i-2][j];\n\t\t\t}\n\t\t}\n\t\tint result=0;\n\t\trepn(i,1,x)result+=r[y-1][i];\n\t\trepn(i,1,x)if(c[y-2][i]==2)result+=r[y-2][i];\n//rep(i,y){\n//rep(j,x)cout<<\" \"<<r[i][j+1];\n//cout<<endl;\n//}\n\t\tcout<<result<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,a,n) for(int i=a;i<n;i++)\n#define repb(i,a,b) for(int i=a;i>=b;i--)\n#define all(a) a.begin(),a.end()\n#define o(a) cout<<a<<endl\n#define int long long\n#define fi first\n#define se second\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n\n\nsigned main() {\n\tint y, x;\n\twhile (1) {\n\t\tcin >> y >> x;\n\t\tif (y + x == 0) break;\n\t\tint d[20][20];\n\t\trep(i, 0, y) {\n\t\t\trep(j, 0, x) {\n\t\t\t\tcin >> d[i][j];\n\t\t\t}\n\t\t}\n\t\tint dp[20][20] = { 0 };\n\t\trep(i, 0, x) {\n\t\t\tif (d[0][i] == 0) dp[0][i] = 1;\n\t\t}\n\t\trep(i, 0, y) {\n\t\t\trep(j, 0, x) {\n\t\t\t\tif (d[i][j] == 1) continue;\n\t\t\t\tif (d[i][j] == 2) {\n\t\t\t\t\tdp[i + 2][j] += dp[i][j];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\trep(k, -1, 2) {\n\t\t\t\t\tif (j + k < 0 || j + k >= x || d[i + 1][j + k] != 0) continue;\n\t\t\t\t\tdp[i + 1][j + k] += dp[i][j];\n\t\t\t\t}\n\t\t\t\tif (d[i + 1][j] == 2) {\n\t\t\t\t\tdp[i + 1][j] += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*cout << endl;\n\t\trep(i, 0, y + 2) {\n\t\t\trep(j, 0, x) {\n\t\t\t\tcout << dp[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t\tint ans = 0;\n\t\trep(i, 0, x) {\n\t\t\tans += dp[y - 1][i] + dp[y][i] + dp[y + 1][i];\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<queue>\n#include<string>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define reps(i,n) for(int i=1;i<=int(n);i++)\n#define sint(i) scanf(\"%d\",&i);\n#define sintt(i,j) scanf(\"%d%d\",&i,&j);\n#define sinttt(i,j,k) scanf(\"%d%d%d\",&i,&j,&k);\n#define sintttt(i,j,k,m) scanf(\"%d%d%d%d\",&i,&j,&k,&m);\n\n#define INF 1010000000\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\n\n\nint main(){\n\twhile(1){\n\t\tint n,m;\n\t\tsintt(n,m);\n\t\tif(n==0)break;\n\t\tint masu[17][17];\n\t\tint dp[17][17];\n\t\t\n\t\trep(i,17)rep(j,17)masu[i][j]=dp[i][j]=0;\n\t\t\n\t\trep(i,m)rep(j,n){\n\t\t\tsint(masu[j+1][i]);\n\t\t}\n\t\t\n\t\treps(j,n){\n\t\t\tif(masu[j][0]!=1){\n\t\t\t\tdp[j][0]=1;\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(i,m-1){\n\t\t\treps(j,n){\n\t\t\t\tif(masu[j][i]==2){\n\t\t\t\t\tif(masu[j][i+2]!=1){\n\t\t\t\t\t\tdp[j][i+2]+=dp[j][i];\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(masu[j][i]==0){\n\t\t\t\t\tif(masu[j-1][i+1]==0){\n\t\t\t\t\t\tdp[j-1][i+1]+=dp[j][i];\n\t\t\t\t\t}\n\t\t\t\t\tif(masu[j+1][i+1]==0){\n\t\t\t\t\t\tdp[j+1][i+1]+=dp[j][i];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(masu[j][i+1]!=1){\n\t\t\t\t\t\tdp[j][i+1]+=dp[j][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans=0;\n\t\tfor(int i=m-1;i<=m;i++){\n\t\t\treps(j,n){\n\t\t\t\tans+=dp[j][i];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t\t\n\t\trep(i,m+2){\n\t\t\trep(j,n+2){\n\t\t\t\tprintf(\"%d \",dp[j][i]);\n\t\t\t}puts(\"\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint dp[20][20][2];\nint x[20][20];\nint H, W;\nvoid A(int a, int b, int c, int d) {\n\tif (x[a][b] == 2) {\n\t\tif (d != 0) { return; }\n\t\tif (c == 1) { return; }\n\t\tif (c == 0) {\n\t\t\tdp[a + 2][b][0] += dp[a][b][c];\n\t\t\treturn;\n\t\t}\n\t}\n\tif (x[a + 1][b + d] == 1) { return; }\n\tif (x[a + 1][b + d] == 2 && d != 0) { return; }\n\tif (x[a][b] == 0) {\n\t\tif (d == 0) {\n\t\t\tdp[a + 1][b + d][0] += dp[a][b][c];\n\t\t}\n\t\telse {\n\t\t\tdp[a + 1][b + d][1] += dp[a][b][c];\n\t\t}\n\t}\n}\nint main() {\n\twhile (true) {\n\t\tcin >> W >> H;\n\t\tif (H == 0 && W == 0) { break; }\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\tcin >> x[i][j];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 20; i++) {\n\t\t\tfor (int j = 0; j < 20; j++) {\n\t\t\t\tdp[i][j][0] = 0;\n\t\t\t\tdp[i][j][1] = 0;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= W; i++) {\n\t\t\tif (x[1][i] == 0) {\n\t\t\t\tdp[1][i][0] = 1;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= H - 1; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\tA(i, j, 0, -1);\n\t\t\t\tA(i, j, 0, 0);\n\t\t\t\tA(i, j, 0, 1);\n\t\t\t\tA(i, j, 1, -1);\n\t\t\t\tA(i, j, 1, 0);\n\t\t\t\tA(i, j, 1, 1);\n\t\t\t}\n\t\t}\n\t\tint sum = 0;\n\t\tfor (int j = H; j < 20; j++) {\n\t\t\tfor (int i = 1; i <= W; i++) {\n\t\t\t\tsum += dp[j][i][0] + dp[j][i][1];\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n\nusing namespace std;\n\nint x,y;\nint fie[20][20];\nlong long int dp[20][20];\nlong long int ans=0;\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif(x==0 && y==0)break;\n\t\tmemset(fie,0,sizeof(fie));\n\t\tmemset(dp,0,sizeof(dp));\n\t\tans=0;\n\n\t\tfor(int i=0;i<y;i++){\n\t\t\tfor(int j=0;j<x;j++){\n\t\t\t\tscanf(\"%d\",&fie[j][i]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<x;i++){\n\t\t\tif(fie[i][0]==0)dp[i][0]=1;\n\t\t\tif(fie[i][0]==2)dp[i][2]=1;\n\t\t}\n\t\tfor(int i=0;i<y;i++){\n\t\t\tfor(int j=0;j<x;j++){\n\t\t\t\tif(fie[j][i]==0){\n\t\t\t\t\tfor(int k=j-1;k<=j+1;k++){\n\t\t\t\t\t\tif(k>=0 && k<x){\n\t\t\t\t\t\t\tif(fie[k][i+1]==0){\n\t\t\t\t\t\t\t\tdp[k][i+1]+=dp[j][i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(fie[k][i+1]==2 && k==j){\n\t\t\t\t\t\t\t\tdp[k][i+1]+=dp[j][i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(fie[j][i]==2){\n\t\t\t\t\tdp[j][i+2]+=dp[j][i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<y;i++){\n\t\t\t\tfor(int j=0;j<x;j++){\n\t\t\t\t\tif(i>=y-2 && fie[j][i]==2)ans+=dp[j][i];\n\t\t\t\t\tif(i==y-1 && fie[j][i]==0)ans+=dp[j][i];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nint main()\n{\n\tint next[3]={-1,0,1};\n\tint x,y,i,j;\n\t\n\tfor(;;)\n\t{\n\t\tcin >> x >> y ;\n\t\tif(x==0 && y==0)\n\t\t\tbreak;\n\t\tint map[20][20]={0};\n\t\tint ansmap[20][20]={0};\n\t\tint ans=0;\n\t\tfor(i=0;i<y;i++)\n\t\t{\n\t\t\tfor(j=0;j<x;j++)\n\t\t\t{\n\t\t\t\tcin >> map[i][j] ;\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<x;i++)\n\t\t{\n\t\t\tansmap[0][i]=1;\n\t\t}\n\t\tfor(i=0;i<y;i++)\n\t\t{\n\t\t\tfor(j=0;j<x;j++)\n\t\t\t{\n\t\t\t\tif(i==0)\n\t\t\t\t{\n\t\t\t\t\tif(map[i][j]==1)\n\t\t\t\t\t{\n\t\t\t\t\t\tansmap[i][j]=0;\n\t\t\t\t\t}\n\t\t\t\t\telse if(map[i][j]==2)\n\t\t\t\t\t{\n\t\t\t\t\t\tansmap[i+2][j]+=ansmap[i][j];\n\t\t\t\t\t}\n\t\t\t\t\telse if(map[i][j]==0 && i<y-1)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(int k=0;k<3;k++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(j+next[k]>=0 && j+next[k]<x)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif(map[i+1][j+next[k]]==0)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tansmap[i+1][j+next[k]]+=ansmap[i][j];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if(map[i+1][j+next[k]]==2 && next[k]==0)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tansmap[i+1][j]+=ansmap[i][j];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(map[i][j]==1)\n\t\t\t\t\t{\n\t\t\t\t\t\tansmap[i][j]=0;\n\t\t\t\t\t}\n\t\t\t\t\telse if(map[i][j]==2)\n\t\t\t\t\t{\n\t\t\t\t\t\tansmap[i+2][j]+=ansmap[i][j];\n\t\t\t\t\t}\n\t\t\t\t\telse if(map[i][j]==0 && i<y-1)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(int k=0;k<3;k++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(j+next[k]>=0 && j+next[k]<x)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif(map[i+1][j+next[k]]==0)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tansmap[i+1][j+next[k]]+=ansmap[i][j];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if(map[i+1][j+next[k]]==2 && next[k]==0)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tansmap[i+1][j+next[k]]+=ansmap[i][j];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=-1;i<1;i++)\n\t\t{\n\t\t\tfor(j=0;j<x;j++)\n\t\t\t{\n\t\t\t\tans+=ansmap[y+i][j];\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n??\nusing namespace std;\n??\nint main() {\n????????int x, y;\n????????int skimap[15][15] = {};//x = j y = i\n????????int dp[15][15] = {};//x = j y = i\n????????while (cin >> x >> y, x * y) {//\n????????????????int flyover = 0;\n????????????????for (int i = 0; i < y; i++) {\n????????????????????????for (int j = 0; j < x; j++) {\n????????????????????????????????cin >> skimap[i][j];\n????????????????????????}\n????????????????}\n????????????????for(int i = 0; i < x;i++){\n????????????????????????if (skimap[0][i] == 0)dp[0][i] = 1;\n????????????????}\n????????????????for (int i = 0; i < y - 1; i++) {\n????????????????????????for (int j = 0; j < x; j++) {\n????????????????????????????????if (skimap[i][j] == 0) {\n????????????????????????????????????????if (j - 1 >= 0) {\n????????????????????????????????????????????????if (skimap[i + 1][j - 1] == 0) {\n????????????????????????????????????????????????????????dp[i + 1][j - 1] += dp[i][j];\n????????????????????????????????????????????????}\n????????????????????????????????????????}\n????????????????????????????????????????if (skimap[i + 1][j] != 1)dp[i + 1][j] += dp[i][j];\n????????????????????????????????????????if (j + 1 < x) {\n????????????????????????????????????????????????if (skimap[i + 1][j + 1] == 0) {\n????????????????????????????????????????????????????????dp[i + 1][j + 1] += dp[i][j];\n????????????????????????????????????????????????}\n????????????????????????????????????????}\n????????????????????????????????}\n????????????????????????????????else if (skimap[i][j] == 1) {\n????????????????????????????????????????continue;\n????????????????????????????????}else {\n????????????????????????????????????????if (i + 2 < y) {\n????????????????????????????????????????????????dp[i + 2][j] = dp[i][j];\n????????????????????????????????????????}else {\n????????????????????????????????????????????????flyover += dp[i][j];\n????????????????????????????????????????}\n????????????????????????????????}\n????????????????????????}\n????????????????}\n????????????????int sum = flyover;\n????????????????for (int i = 0; i < x; i++) {\n????????????????????????sum += dp[y - 1][i];\n????????????????}\n????????????????cout << sum << endl;\n        for (int i = 0; i < y; i++){\n            for(int j = 0; j < x; j++){\n                dp[i][j] = 0;\n                skimap[i][j] = 0;\n            }\n        } \n????????}\n????????return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<math.h>\nint main(void)\n{\n\tint a,s,d[20][20],f,j,i,k;\n\tlong long int g,h[20][20];\n\twhile(1){\n\t\tscanf(\"%d %d\",&a,&s);\n\t\tif(a==0&&s==0) break;\n\t\tfor(i=0;i<s;i++) h[0][i]=1;\n\t\tfor(i=0;i<a;i++){\n\t\t\tfor(j=0;j<s;j++) scanf(\"%d\",&d[i][j]);\n\t\t}\n\t\tfor(i=0;i<s;i++){\n\t\t\tif(d[0][i]==1) h[0][i]=0;\n\t\t}\n\t\tfor(i=1;i<a;i++){\n\t\t\tfor(j=0;j<s;j++) h[i][j]=0;\n\t\t}\n\t\tfor(i=0;i<a-1;i++){\n\t\t\tfor(j=0;j<s;j++){\n\t\t\t\tif(i!=0&&d[i][j]==2){\n\t\t\t\t\tif(i+2<a){\n\t\t\t\t\t\tif(d[i+2][j]!=1) h[i+2][j]+=h[i][j];\n\t\t\t\t\t}\n\t\t\t\t\telse h[i+1][j]+=h[i][j];\n\t\t\t\t}\n\t\t\t\tif(d[i][j]==0){\n\t\t\t\t\tif(j!=0) if(d[i+1][j-1]==0) h[i+1][j-1]+=h[i][j];\n\t\t\t\t\tif(j!=s){\n\t\t\t\t\t\tif(d[i+1][j+1]==0) h[i+1][j+1]+=h[i][j];\n\t\t\t\t\t\tif(d[i+1][j]==0||d[i+1][j]==2) h[i+1][j]+=h[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tg=0;\n\t\tfor(j=0;j<s;j++) g+=h[a-1][j];\n\t\tprintf(\"\\n\\n\");\n\t\tfor(i=0;i<a;i++){\n\t\t\tfor(j=0;j<s;j++) printf(\"%7d \",h[i][j]);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tprintf(\"%d\\n\",g);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint dfs(int x,int y);\nint mas[20][20];\nint X,Y;\n\nint main(){\n\twhile(1){\n\t\tcin >> X >> Y;\n\t\tif(X == 0 && Y == 0) break;\n\t\tfor(int i=0;i<Y;i++){\n\t\t\tfor(int j=0;j<X;j++){\n\t\t\t\tcin >> mas[i][j];\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i=0;i<X;i++){\n\t\t\tif(mas[0][i] == 0){\n\t\t\t\tans += dfs(i,0);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\nint dfs(int x,int y){\n\tint cou = 0;\n\t//if(mas[y][x] == 1) return 0;\n\tif(y>=Y-1) return 1;\n\tif(mas[y][x] == 2) return dfs(x,y+2);\n\tfor(int i=-1;i<2;i++){\n\t\tint nx = x + i;\n\t\tint ny = y + 1;\n\t\tif(nx >= 0 && nx < X){\n\t\t\tif(i == 0 && mas[ny][nx] == 2){\n\t\t\t\tcou += dfs(nx,ny);\n\t\t\t}\n\t\t\telse if(mas[ny][nx] == 0){\n\t\t\t\tcou += dfs(nx,ny);\n\t\t\t}\n\t\t}\n\t}\n\treturn cou;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n\nint field[15][15];\nint w,h;\nint dfs(int x0,int y0);\n\nint main()\n{\n\twhile(1)\n\t{\n\t\tstd::cin>>w>>h;\n\t\tif(w==0&&h==0)break;\n\t\tfor(int y=0;y<h;y++)\n\t\t{\n\t\t\tfor(int x=0;x<w;x++)\n\t\t\t{\n\t\t\t\tstd::cin>>field[x][y];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint count=0;\n\t\tfor(int x=0;x<w;x++)\n\t\t{\n\t\t\tif(field[x][0]==0)\n\t\t\t{\n\t\t\t\tcount+=dfs(x,0);\n\t\t\t}\n\t\t}\n\t\tstd::cout<<count<<std::endl;\n\t}\n\treturn 0;\n}\n\nint dfs(int x0,int y0)\n{\n\tstd::stack<std::pair<int,int> > stk;\n\tint count=0;\n\tstk.push(std::pair<int,int>(x0,y0));\n\twhile(!stk.empty())\n\t{\n\t\tint x=stk.top().first,y=stk.top().second;\n\t\t\n\t\tstk.pop();\n\t\t\n\t\tif(y>=h-1&&field[x][y]!=1)\n\t\t{\n\t\t\tcount++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(field[x][y]==2)\n\t\t\t{\n\t\t\t\tstk.push(std::pair<int,int>(x,y+2));\n\t\t\t}\n\t\t\telse if(field[x][y]==0)\n\t\t\t{\n\t\t\t\tif(x>0&&field[x-1][y+1]==0){stk.push(std::pair<int,int>(x-1,y+1));}\n\t\t\t\tif(x<w-1&&field[x+1][y+1]==0){stk.push(std::pair<int,int>(x+1,y+1));}\n\t\t\t\tif(field[x][y+1]!=1){stk.push(std::pair<int,int>(x,y+1));}\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint field[20][20];\nint dp[20][20];\n\nint n, m;\n\nbool isIn(int x, int y){\n    return 0 <= x && x < n && 0 <= y && y < m;\n}\n\nint main(){\n    while(cin >> n >> m, n+m){\n        for(int i=0; i < n; i++) for(int j=0; j< m; j++){cin >> field[i][j];}\n        for(int i=0; i< 20; i++) for(int j=0; j< 20; j++) dp[i][j] = 0;\n        for(int i=0; i < m; i++) dp[0][i] = 1;\n        for(int i=0; i < n-1; i++){\n            for(int j=0; j < m; j++){\n                if(field[i][j] == 0){\n                    for(int k=-1; k <= 1; k++){\n                        if(isIn(i+1, j+k) && !(k != 0 && field[i+1][j+k] == 2)){\n                            dp[i+1][j+k] += dp[i][j];\n                        }\n                    }\n                }\n                else if(field[i][j] == 1) dp[i][j] = 0;\n                else if(field[i][j] == 2) dp[i+2][j] += dp[i][j];\n            }\n        }\n        for(int i=0; i< m; i++) if(field[n-1][i] != 1)dp[n][i] += dp[n-1][i];\n        int count = 0;\n        for(int i=0; i< m; i++) count += dp[n][i];\n        cout << count << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n  while(1){\n    int w,h,mp[20][20]={},dp[20][20] ={};\n    cin >> w >> h;\n    if(w==0 && h==0) break;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++) cin >> mp[i][j];\n    for(int i=0;i<w;i++) if(mp[0][i]==0) dp[0][i] = 1;\n    int ans=0;    \n    for(int i=0;i<h-1;i++)\n      for(int j=0;j<w;j++) \n\tfor(int k=-1;k<=1;k++){\n\t  int nx=j+k,ny=i+1;\n\t  if(nx<0||nx>=w || mp[i][j] !=0) continue;\n\t  while(k==0&&mp[ny][nx]==2) ny+=2;\n\t  if(mp[ny][nx]!=0) continue;\n\t  dp[ny][nx]+= dp[i][j];\n\t  if(ny >= h-1) ans+=dp[i][j];\n\t}\n    /*\n      cout << endl;\n      for(int i=0;i<h+3;i++){\n      for(int j=0;j<w;j++)cout << dp[i][j] <<\" \";\n      cout << endl;\n      }\n    */\n    cout << ans <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MOVE = 0;\nconst int BARRIIER = 1;\nconst int JUMP = 2;\n\nint course[15][15];\nint prog[15][15];\nint sizeX, sizeY;\nint answer = 0;\n\nvoid init() {\n  for (int i = 0; i < 15; i++) {\n    for (int j = 0; j < 15; j++) {\n      prog[i][j] = 0;\n      course[i][j] = -1;\n    }\n  }\n}\n\nvoid inputCourse() {\n  for (int i = 0; i < sizeY; i++) {\n    for (int j = 0; j < sizeX; j++) {\n      cin >> course[i][j];\n    }\n  }\n}\n\nint main(int argc, char* argv[]) {\n  while (cin >> sizeX >> sizeY, sizeX) {\n    init();\n    inputCourse();\n    answer = 0;\n    for (int x = 0; x < sizeX; x++) {\n      if (course[0][x] == MOVE) {\n        prog[0][x] = 1;\n      }\n    }\n    for (int y = 0; y < sizeY; y++) {\n      for (int x = 0; x < sizeX; x++) {\n        if (course[y][x] == MOVE) {\n          if (y + 1 >= sizeY) {\n            answer += prog[y][x];\n          } else {\n            if (course[y + 1][x] == MOVE || course[y + 1][x] == JUMP) {\n              prog[y + 1][x] += prog[y][x];\n            }\n            if (x - 1 >= 0 && course[y + 1][x - 1] == MOVE) {\n              prog[y + 1][x - 1] += prog[y][x];\n            }\n            if (x + 1 < sizeX && course[y + 1][x + 1] == MOVE) {\n              prog[y + 1][x + 1] += prog[y][x];\n            }\n          }\n        }\n        if (course[y][x] == JUMP) {\n          if (y + 2 >= sizeY) {\n            answer += prog[y][x];\n          } else {\n            prog[y + 2][x] += prog[y][x];\n          }\n        }\n      }\n    }\n    cout << answer << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\nint a[16][16];\nint count = 0;\nint n,m;\n\nvoid dfs(int y,int x)\n{\n\tif(a[y][x] == 0)\n\t{\n\t\tif(y == m-1)\n\t\t{\n\t\t\tcount++;\n\t\t\treturn;\n\t\t}\n\t\tif(x-1 >= 0 && y+1 < m)\n\t\t{\n\t\t\tif(a[y+1][x-1] != 2)\n\t\t\t{\n\t\t\t\tdfs(y+1,x-1);\n\t\t\t}\n\t\t}\n\t\tif(y+1 < m)\n\t\t{\n\t\t\tdfs(y+1,x);\n\t\t}\n\t\tif(x+1 < n && y+1 < m)\n\t\t{\n\t\t\tif(a[y+1][x+1] != 2)\n\t\t\t{\n\t\t\t\tdfs(y+1,x+1);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\telse if(a[y][x] == 1)\n\t{\n\t\treturn;\n\t}\n\telse if(a[y][x] == 2)\n\t{\n\t\tif(y == m-2 || y == m-1)\n\t\t{\n\t\t\tcount++;\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdfs(y+2,x);\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile(cin >> n >> m)\n\t{\n\t\tif(n == 0 && m == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tmemset(a,0,sizeof(a));\n\t\trep(i,n)\n\t\t{\n\t\t\trep(j,m)\n\t\t\t{\n\t\t\t\tcin >> a[i][j];\n\t\t\t}\n\t\t}\n\t\tcount = 0;\n\t\trep(i,n) dfs(0,i);\n\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define N 20\nusing namespace std;\nvoid func(int,int);\nint jump(int,int);\nint X,Y,data[N][N],memo[N][N];\nint main(){\n  while(1){\n    cin >> X >> Y;\n    if(X==0&&Y==0) break;\n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++) data[i][j]=0,memo[i][j]=0;\n\n    for(int i=0;i<Y;i++)\n      for(int j=0;j<X;j++) cin >> data[i][j];\n\n    for(int i=0;i<X;i++)\n      if(data[0][i]!=1) func(0,i);\n\n    int cnt=0;\n    for(int i=0;i<X;i++) cnt+=memo[0][i];\n    cout << cnt << endl;\n  }\n  return 0;\n}\nvoid func(int y,int x){\n  if(y>=Y-1){\n    memo[y][x]=memo[Y][x]=memo[Y-1][x]=1;\n    return ;\n  }\n  if(0<=x-1&&data[y+1][x-1]==0){\n    if(memo[y+1][x-1]==0) func(y+1,x-1);\n    memo[y][x]+=memo[y+1][x-1];\n  }\n  if(x+1<X&&data[y+1][x+1]==0){\n    if(memo[y+1][x+1]==0) func(y+1,x+1);\n    memo[y][x]+=memo[y+1][x+1];\n  }\n  if(data[y+1][x]==0){\n    if(memo[y+1][x]==0) func(y+1,x);\n    memo[y][x]+=memo[y+1][x];\n  }\n  if(data[y+1][x]==2){\n    int r=jump(y+1,x);\n    if(r!=-1){\n      if(memo[r][x]==0) func(r,x);\n      memo[y][x]+=memo[r][x];\n    }else data[y+1][x]=1;\n  }\n  if(memo[y][x]==0) data[y][x]=1;\n}\nint jump(int y,int x){\n  while(data[y][x]==2)y+=2;\n  if(data[y][x]==0||y>=Y-1) return y;\n  return -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\nusing namespace std;\nint course[16][17][2];\nint main()\n{\n  for(;;){\n    int H,W;\n    cin >> W >> H;\n    if(H==0||W==0) break;\n    memset(course,0,sizeof(course));\n    for(int h=1; h<=H; h++){\n      for(int w=1; w<=W; w++){\n        cin >> course[h][w][0];\n      }\n    }\n    for(int w=1; w<=W; w++){\n      if(course[1][w][0] == 1) course[1][w][1] = 0;\n      else course[1][w][1] = 1;\n    }\n    for(int h=2; h<=H; h++){\n      for(int w=1; w<=W; w++){\n        if(course[h][w][0] == 1){\n          course[h][w][1] = 0;\n        }else if(course[h][w][0] == 2){\n          course[h][w][1] = course[h-1][w][1];\n          if(course[h-2][w][0] == 2){\n            course[h][w][1] += course[h-2][w][1];\n          }\n        }else {\n          for(int i=-1; i<=1; i++){\n            if(course[h-1][w+i][0] != 2){\n              course[h][w][1] += course[h-1][w+i][1];\n            }\n          }\n          if(course[h-2][w][0] == 2){\n            course[h][w][1] += course[h-2][w][1];\n          }\n        }\n      }\n    }\n    long long sum = 0;\n    for(int w=1; w<=W; w++){\n      sum += course[H][w][1];\n      if(course[H-1][w][0] == 2){\n        sum += course[H-1][w][1];\n      }\n    }\n    cout << sum << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\nint X,Y,imap[20][20];\nconst int dx[3] = {-1,0,1};\nconst int dy[3] = {1,1,1};\nint sam,dp[20][20];\n\nint solve(){\n  \n  int ans = 0;\n  for(int i=0;i<=Y;i++)for(int j=0;j<=X;j++)dp[i][j] = (i==0 && imap[i][j] != 1)?1:0; \n\n  for(int i=0;i<Y-1;i++){\n    for(int j=0;j<X;j++){\n      if(dp[i][j] == 0)continue;\n      if(imap[i][j] == 0){\n\tfor(int k=0;k<3;k++){\n\t  int nx = j+dx[k],ny = i+dy[k];\n\t  if(0<= nx && nx<X && 0<= ny && ny < Y && imap[ny][nx] != 1){\n\t      if((k == 0 || k == 2) && imap[ny][nx] == 2)continue;\n\t      dp[ny][nx]+=dp[i][j];\n\t  }\n\t}\n      }\n      else if(imap[i][j] == 2){\n\tif(i+2 <Y){\n\t  dp[i+2][j]+=dp[i][j];\n\t}\n\telse{\n\t  dp[Y-1][j]+=dp[i][j];\n\t}\n      }\n    }\n  }\n    \n    for(int i=0;i<X;i++)ans += dp[Y-1][i];\n    return ans;\n}\n\n\n\nbool Init(){\n  cin >> X >> Y;\n  if(X+Y == 0)return false;\n  for(int i=0;i<Y;i++){\n    for(int j=0;j<X;j++){\n      cin >> imap[i][j];\n    }\n  }\n  sam = 0;\n  return true;\n}\n\nint main(){\n  while(true){\n    if(!Init())break;\n    cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\n\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nint x, y, c[16][16], dp[30][30];\nconst int dx[3] = {-1, 0, 1};\n\nvoid solve() {\n  memset(dp, 0, sizeof dp);\n  \n  rep(i,y) rep(j,x) cin>>c[i][j];\n  \n  rep(i,x) if (c[0][i] == 0) dp[0][i] = 1;\n  \n  rep(i,y) rep(j,x) {\n    if (c[i][j] == 1) {\n      continue;\n    } else if (c[i][j] == 0) {\n      rep(z,3) {\n        int ti = i + 1, tj = j + dx[z];\n        if (ti < 0 || tj < 0 || ti >= y || tj >= x) continue;\n        if (c[ti][tj] == 1) continue;\n        if (c[ti][tj] == 2 && tj != j) continue;\n        dp[ti][tj] += dp[i][j];\n      }\n    } else if (c[i][j] == 2) {\n      dp[i+2][j] = dp[i][j];\n    }\n  }\n  /*\n  rep(i,y+1) {\n    rep(j,x) printf(\"%8d\",dp[i][j]);\n    cout<<endl;\n  }*/\n  \n  int res = 0;\n  REP(i,y-1,y+1) rep(j,x) res += dp[i][j];\n  cout<<res<<endl;\n}\n\nint main (int argc, char const* argv[]) {\n  while (cin>>x>>y, x||y) {\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nint grid[30][30];\n\ninline bool isAtObstacle(int x, int y) {\n  return grid[y][x] == 1;\n}\n\ninline bool isAtSkiJump(int x, int y) {\n  return grid[y][x] == 2;\n}\n\nint main() {\n  int n, m;\n  \n  while(cin >> n >> m && n) {\n    fill(grid[0], grid[0]+900, 0);\n    for(int i=0; i<n; i++) {\n      for(int j=0; j<m; j++) {\n\tcin >> grid[i][j];\n      }\n    }\n    \n    long long dp[30][30][2] = {};\n    \n    for(int j=0; j<m; j++) {\n      if(grid[0][j]==0) { dp[0][j][0] = 1; }\n    }\n    \n    int extra = 0;\n    for(int i=0; i<n-1; i++) {\n      for(int j=0; j<m; j++) {\n\t\n\t// there is no case such that skier is at obstacle.\n\tif(isAtObstacle(j, i)) {\n\t  dp[i][j][0] = dp[i][j][1] = 0;\n\t  continue;\n\t}\n\t\n\t// A skier is at a ski jump.\n\tif(isAtSkiJump(j, i)) {\n\t  if(i+2 > n-1) extra += dp[i][j][0];\n\t  else {\n\t    if(isAtObstacle(j, i+2)) continue;\n\t    dp[i+2][j][0] += dp[i][j][0];\n\t  }\n\t}\n\t\n\t// skiing without jump.\n\telse {\n\t  // from the upper left\n\t  if( j-1 >= 0\n\t      && !isAtObstacle(j-1, i+1)\n\t      && !isAtSkiJump (j-1, i+1) ) {\n\t    dp[i+1][j-1][1] += dp[i][j][0] + dp[i][j][1];\n\t  }\n\t  \n\t  // from the above\n\t  if( !isAtObstacle(j, i+1) ) {\n\t    dp[i+1][j][0] += dp[i][j][0] + dp[i][j][1];\n\t  }\n\t  \n\t  // from the upper right\n\t  if( j+1 < m\n\t      && !isAtObstacle(j+1, i+1)\n\t      && !isAtSkiJump (j+1, i+1) ) {\n\t    dp[i+1][j+1][1] += dp[i][j][0] + dp[i][j][1];\n\t  }\n\t}\n\t\n      }\n    }\n    \n    int ans = 0;\n    for(int i=0; i<m; i++) {\n      ans += dp[n-1][i][0] + dp[n-1][i][1];\n    }\n    \n    cout << ans + extra << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define N 15\nusing namespace std;\nvoid func(int,int);\nint jump(int,int);\nint X,Y,data[N][N],memo[N][N];\nint main(){\n  while(1){\n    cin >> X >> Y;\n    if(X==0&&Y==0) break;\n    for(int i=0;i<Y;i++)\n      for(int j=0;j<X;j++) cin >> data[i][j],memo[i][j]=0;\n    for(int i=0;i<X;i++)\n      if(data[0][i]==0) func(0,i);\n    int cnt=0;\n    for(int i=0;i<X;i++) cnt+=memo[0][i];\n    cout << cnt << endl;\n  }\n  return 0;\n}\nvoid func(int y,int x){\n  if(y==Y-1){\n    memo[Y-1][x]=1;\n    return ;\n  }\n  if(0<=x-1&&data[y+1][x-1]==0){\n    if(memo[y+1][x-1]==0) func(y+1,x-1);\n    memo[y][x]+=memo[y+1][x-1];\n  }\n  if(x+1<X&&data[y+1][x+1]==0){\n    if(memo[y+1][x+1]==0) func(y+1,x+1);\n    memo[y][x]+=memo[y+1][x+1];\n  }\n  if(data[y+1][x]==0){\n    if(memo[y+1][x]==0) func(y+1,x);\n    memo[y][x]+=memo[y+1][x];\n  }\n  if(data[y+1][x]==2){\n    int r=jump(y+1,x);\n    if(r==-2) memo[y][x]+=1;\n    else if(r!=-1){\n      if(memo[r][x]==0) func(r,x);\n      memo[y][x]+=memo[r][x];\n    }\n  }\n  if(memo[y][x]==0) data[y][x]=1;\n}\nint jump(int y,int x){\n  while(1){\n    y+=2;\n    if(y>Y-1) return -2;\n    if(data[y][x]==1) break;\n    if(y==Y-1) return -2;\n    if(data[y][x]==0) return y;\n  }\n  return -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <map>\n#include <cmath>\n\nusing namespace std;\n\n\nconst int MAX = 15;\nint c[MAX+1][MAX+1];\nint memo[3][MAX+1][MAX+1];\nint X, Y;\n\nint solve(int x0, int x, int y)\n{\n\tif( -1 < x && x < X && Y-1 <= y )\n\t\treturn 1;\n\t\n\tint& n = memo[x-x0+1][x][y];\n\tif( n != -1 )\n\t\treturn n;\n\t\n\tint r = 0;\n\tint p = c[x][y];\n\n\tif( p != 2 ) {\n\n\t\tif( -1 < x-1 && c[x-1][y+1] != 1 )\n\t\t\tr += solve(x,x-1,y+1);\n\n\t\tif( c[x][y+1] != 1 )\t\n\t\t\tr += solve(x,x,y+1);\n\n\t\tif( x+1 < X && c[x+1][y+1] != 1 )\n\t\t\tr += solve(x,x+1,y+1);\n\n\t} if( p == 2 && x == x0 ) {\n\n\t\tif( c[x][y+2] != 1 )\n\t\t\tr += solve(x,x,y+2);\n\t}\n\n\tn = r;\n\treturn n;\n}\n\nint main(int argc, char* argv[])\n{\n\twhile(1) {\n\n\t\tcin >> X;\n\t\tcin >> Y;\n\n\t\tif( X == 0 && Y == 0)\n\t\t\tbreak;\n\n\t\tfor( int j = 0; j < Y; j++ ) {\t\t\n\t\t\tfor( int i = 0; i < X; i++ ) {\n\t\t\t\tint p; cin >> p;\n\t\t\t\tc[i][j] = p;\n\t\t\t\tmemo[0][i][j] = -1;\n\t\t\t\tmemo[1][i][j] = -1;\n\t\t\t\tmemo[2][i][j] = -1;\n\t\t\t}\n\t\t}\n\n\t\tint r = 0;\n\t\tfor( int i = 0; i < X; i++ ) {\n\t\t\tif( c[i][0] != 1 )\n\t\t\t\tr += solve(i,i,0);\n\t\t}\n\n\t\tcout << r << endl;\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<climits>\n#include<map>\n#include<string>\nusing namespace std;\n\nint X, Y, Fld[17][15], memo[14][15];\n\nint DFS(int y, int x){\n\tif(y >= Y-1) return 1;\n\tif(memo[y][x] != -1) return memo[y][x];\n\tif(Fld[y][x] == 2) return DFS(y+2, x);\n\n\tmemo[y][x] = 0;\n\tfor(int i = -1; i <= 1; i++){\n\t\tint ny = y+1, nx = x + i;\n\t\tif( nx < 0 || X <= nx || Fld[ny][nx] == 1 || (Fld[ny][nx] == 2 && i != 0) )\n\t\t\tcontinue;\n\t\tmemo[y][x] += DFS(ny, nx);\n\t}\n\n\treturn memo[y][x];\n}\n\nint main(){\n\twhile(cin >> X >> Y, X || Y){\n\t\tfor(int i = 0; i < Y; i++){\n\t\t\tfor(int j = 0; j < X; j++){\n\t\t\t\tcin >> Fld[i][j];\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tfill_n( (int*)memo, 14*15, -1 );\n\t\tfor(int i = 0; i < X; i++) if(Fld[0][i] != 1) ans += DFS(0, i);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\nusing namespace std;\nint course[16][17][2];\nint main()\n{\n  for(;;){\n    int H,W;\n    cin >> H >> W;\n    if(H==0||W==0) break;\n    memset(course,0,sizeof(course));\n    for(int h=1; h<=H; h++){\n      for(int w=1; w<=W; w++){\n        cin >> course[h][w][0];\n      }\n    }\n    for(int w=1; w<=W; w++){\n      if(course[1][w][0] == 1) course[1][w][1] = 0;\n      else course[1][w][1] = 1;\n    }\n    for(int h=2; h<=H; h++){\n      for(int w=1; w<=W; w++){\n        if(course[h][w][0] == 1){\n          course[h][w][1] = 0;\n        }else if(course[h][w][0] == 2){\n          course[h][w][1] = course[h-1][w][1];\n          if(course[h-2][w][0] == 2){\n            course[h][w][1] += course[h-2][w][1];\n          }\n        }else {\n          for(int i=-1; i<=1; i++){\n            if(course[h-1][w+i][0] != 2){\n              course[h][w][1] += course[h-1][w+i][1];\n            }\n          }\n          if(course[h-2][w][0] == 2){\n            course[h][w][1] += course[h-2][w][1];\n          }\n        }\n      }\n    }\n    int sum = 0;\n    for(int w=1; w<=W; w++){\n      sum += course[H][w][1];\n      if(course[H-1][w][0] == 2){\n        sum += course[H-1][w][1];\n      }\n    }\n    cout << sum << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint w, h, c[15][15];\nint res;\n\nvoid dfs(int x, int y) {\n\tif (y <= h-1 && c[y][x] == 1) return;\n\tif (y >= h-1) {\n\t\t++res;\n\t\treturn;\n\t}\n\tif (c[y][x] == 0) {\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\tint nx = x + i - 1, ny = y + 1;\n\t\t\tif (0 <= nx && nx < w && ((x == nx && c[ny][nx] == 2) || c[ny][nx] == 0)) dfs(nx, ny);\n\t\t}\n\t}\n\tif (c[y][x] == 2) dfs(x, y+2);\n\treturn;\n}\n\nint main(void) {\n\twhile (cin >> w >> h, w && h) {\n\t\tfor (int i = 0; i < h; ++i) {\n\t\t\tfor (int j = 0; j < w; ++j) cin >> c[i][j];\n\t\t}\n\t\tres = 0;\n\t\tfor (int i = 0; i < w; ++i) {\n\t\t\tif (c[0][i] == 0) dfs(i, 0);\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n\nusing namespace std;\n\nchar mapData[15][15];\nint dp[15][15];\nint h, w;\nint dx[] = {-1, 0, 1};\n\nmain(){\n  while(cin >> w >> h && (h || w)){ \n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin >> mapData[i][j];\n      }\n    }\n    fill(dp[0], dp[15], 0);\n    for(int i=0;i<w;i++){\n      if(mapData[0][i] != '1')\n\tdp[0][i] = 1;\n    }\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(dp[i][j] == 0) continue;\n\tif(mapData[i][j] == '2'){\n\t  int ty = i + 2;\n\t  if(ty<0 || ty>=h) continue;\n\t  if(mapData[ty][j] == '1') continue;\n\t  dp[ty][j] += dp[i][j];\n\t}else{\n\t  for(int k=0;k<3;k++){\n\t    int ty = i + 1;\n\t    int tx = j + dx[k];\n\t    if(ty<0 || ty>=h) continue;\n\t    if(tx<0 || tx>=w) continue;\n\t    if(mapData[ty][tx] == '1') continue;\n\t    if(mapData[ty][tx] == '2' && k != 1) continue;\n\t    dp[ty][tx] += dp[i][j];\n\t  }\n\t}\n      }\n    }\n    int ans = 0;\n    for(int i=0;i<w;i++){\n      if(mapData[h-2][i] == '2') ans += dp[h-2][i];\n      if(mapData[h-1][i] != '1') ans += dp[h-1][i];\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n\ntypedef long long LL;\ntemplate<typename T> using V = std::vector<T>;\ntemplate<typename T> using VV = std::vector<std::vector<T>>;\ntemplate<typename T> using VVV = std::vector<std::vector<std::vector<T>>>;\n\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline void print_vec(const std::vector<T> &v) { for (int i = 0; i < v.size(); ++i) {  if (i != 0) {std::cout << \" \";} std::cout << v[i];} std::cout << \"\\n\"; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\ntemplate<class T> inline double euclidean_distance(T y1, T x1, T y2, T x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\ntemplate<class T> inline double manhattan_distance(T y1, T x1, T y2, T x2) { return abs(x1 - x2) + abs(y1 - y2); }\n\nconst int INF = 1L << 30;\nconst double EPS = 1e-9;\nconst std::string YES = \"YES\", Yes = \"Yes\", NO = \"NO\", No = \"No\";\nconst std::vector<int> dy4 = { 0, 1, 0, -1 }, dx4 = { 1, 0, -1, 0 };    // 4近傍（右, 下, 左, 上）\nconst std::vector<int> dy8 = { 0, -1, 0, 1, 1, -1, -1, 1 }, dx8 = { 1, 0, -1, 0, 1, 1, -1, -1 };\n\nusing namespace std;\n\n\nint main() {\n    cin.tie(0);\n\tios::sync_with_stdio(false);\n\n    while (true) {\n        int X, Y;\n        cin >> X >> Y;\n        if (X == 0 or Y == 0) {\n            break;\n        }\n\n        vector<vector<int>> f(Y, vector<int>(X));\n        FOR(y, 0, Y) {\n            FOR(x, 0, X) {\n                cin >> f[y][x];\n            }\n        }\n\n        vector<vector<int>> dp(Y, vector<int>(X));\n        FOR(x, 0, X) {\n            if (f[0][x] == 0) {\n                dp[0][x] = 1;\n            }\n        }\n\n        FOR(y, 0, Y - 1) {\n            FOR(x, 0, X) {\n                if (f[y][x] == 0) {\n                    if (x - 1 >= 0 and f[y + 1][x - 1] != 1 and f[y + 1][x - 1] != 2) {\n                        dp[y + 1][x - 1] += dp[y][x];\n                    }\n                    if (f[y + 1][x] != 1) {\n                        dp[y + 1][x] += dp[y][x];\n                    }\n                    if (x + 1 < f[0].size() and f[y + 1][x + 1] != 1 and f[y + 1][x + 1] != 2) {\n                        dp[y + 1][x + 1] += dp[y][x];\n                    }\n                }\n                else if (f[y][x] == 1) {\n\n                }\n                else if (f[y][x] == 2) {\n                    if (y + 2 < f.size()) {\n                        if (f[y + 2][x] != 1) {\n                            dp[y + 2][x] += dp[y][x];\n                        }\n                    }\n                    else {\n                        dp[y + 1][x] += dp[y][x];\n                    }\n                }\n            }\n        }\n\n        LL ans = 0;\n        FOR(x, 0, X) {\n            ans += dp[Y - 1][x];\n        }\n        print(ans);\n    }\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint w,h;\nint mp[20][20],memo[20][20];\nint dx[] = {-1,0,1};\nvoid saiki(int x,int y) {\n  if(y >= h-1) memo[y][x]++;\n  else if(mp[y][x] != 1) {\n    for(int i=0;i<3;i++) {\n      int nx = x+dx[i], ny = y+1;\n      if(nx==x && mp[ny][nx] == 2)while(mp[ny][nx] == 2) ny+=2;\n      if(nx <0|| nx >= w ||mp[ny][nx] == 1) continue;\n\n      if(memo[ny][nx] > 0 && mp[ny][nx] == 0) memo[y][x] += memo[ny][nx];\n      else if(mp[ny][nx] == 0){\n\tsaiki(nx,ny);\n\tmemo[y][x] += memo[ny][nx];\n      }\n    }\n    if(memo[y][x] == 0) mp[y][x] = 1;\n  }\n}\nint main() {\n  while(1) {\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n    for(int i=0;i<=19;i++)\n      for(int j=0;j<=19;j++)memo[i][j] = mp[i][j] = 0;\n     \n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)cin >> mp[i][j];\n  \n    for(int i=0;i<w;i++)\n      if(mp[0][i] !=1) saiki(i,0);\n     \n    int cnt = 0;\n    for(int i=0;i<w;i++)\n      if(memo[0][i] > 0) cnt+=memo[0][i];\n    cout <<cnt<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#define N 16\nusing namespace std;\nvoid func(int,int);\nint jump(int,int);\nint X,Y,data[N][N],memo[N+2][N];\nint main(){\n  while(1){\n    cin >> X >> Y;\n    if(X==0&&Y==0) break;\n    for(int i=0;i<Y;i++)\n      for(int j=0;j<X;j++) cin >> data[i][j];\n    for(int i=0;i<Y+2;i++)\n      for(int j=0;j<X;j++) memo[i][j]=0;\n    for(int i=0;i<X;i++)\n      if(data[0][i]!=1)\tfunc(0,i);\n    int cnt=0;\n    for(int i=0;i<X;i++) cnt+=memo[0][i];\n    cout << cnt << endl;\n  }\n  return 0;\n}\nvoid func(int y,int x){\n  if(y>=Y-1){\n    memo[Y][x]=memo[Y-1][x]=1;\n    return ;\n  }\n  if(y+1<Y&&0<=x-1&&data[y+1][x-1]==0){\n    if(memo[y+1][x-1]!=0) memo[y][x]+=memo[y+1][x-1];\n    else{\n      func(y+1,x-1),memo[y][x]+=memo[y+1][x-1];\n    }\n  }\n  if(y+1<Y&&x+1<X&&data[y+1][x+1]==0){\n    if(memo[y+1][x+1]!=0) memo[y][x]+=memo[y+1][x+1];\n    else{\n      func(y+1,x+1),memo[y][x]+=memo[y+1][x+1];\n    }\n  }\n  if(data[y+1][x]==0){\n    if(memo[y+1][x]!=0) memo[y][x]+=memo[y+1][x];\n    else{\n      func(y+1,x),memo[y][x]+=memo[y+1][x];\n    }\n  }\n  if(data[y+1][x]==2){\n    int r=jump(y+1,x);\n    if(r!=-1){\n      if(memo[r][x]!=0) memo[y][x]+=memo[r][x];\n      else func(r,x),memo[y][x]+=memo[r][x];\n    }\n  }\n  if(memo[y][x]==0) data[y][x]=1;\n}\nint jump(int y,int x){\n  y+=2;\n  while(1){\n    if(data[y][x]==1) break;\n    if(data[y][x]==0) return y;\n    if(y>=Y-1) return y;\n    y+=2;\n  }\n  return -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,a,n) for(int i=a;i<n;i++)\n#define repb(i,a,b) for(int i=a;i>=b;i--)\n#define all(a) a.begin(),a.end()\n#define o(a) cout<<a<<endl\n#define int long long\n#define fi first\n#define se second\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n\n\nsigned main() {\n\tint y, x;\n\twhile (1) {\n\t\tcin >> y >> x;\n\t\tif (y + x == 0) break;\n\t\tint d[20][20] = { -1 };\n\t\trep(i, 0, y) {\n\t\t\trep(j, 0, x) {\n\t\t\t\tcin >> d[i][j];\n\t\t\t}\n\t\t}\n\t\tint dp[20][20] = { 0 };\n\t\trep(i, 0, x) {\n\t\t\tif (d[0][i] == 0) dp[0][i] = 1;\n\t\t}\n\t\trep(i, 0, y) {\n\t\t\trep(j, 0, x) {\n\t\t\t\tif (d[i][j] == 1) continue;\n\t\t\t\tif (d[i][j] == 2) {\n\t\t\t\t\tdp[i + 2][j] += dp[i][j];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\trep(k, -1, 2) {\n\t\t\t\t\tif (j + k < 0 || j + k >= x || d[i + 1][j + k] != 0) continue;\n\t\t\t\t\tdp[i + 1][j + k] += dp[i][j];\n\t\t\t\t}\n\t\t\t\tif (d[i + 1][j] == 2) {\n\t\t\t\t\tdp[i + 1][j] += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*cout << endl;\n\t\trep(i, 0, y + 2) {\n\t\t\trep(j, 0, x) {\n\t\t\t\tcout << dp[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t\tint ans = 0;\n\t\trep(i, 0, x) {\n\t\t\tif (d[y - 1][i] == 0) {\n\t\t\t\tans += dp[y - 1][i];\n\t\t\t}\n\t\t\telse if (d[y - 1][i] == 2) {\n\t\t\t\tans += dp[y - 1][i];\n\t\t\t}\n\t\t\tif (d[y - 2][i] == 2) {\n\t\t\t\tans += dp[y - 2][i];\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint dp[20][20];\nint dat[20][20];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<b;i++)\n\t\t\tfor(int j=0;j<a;j++)\n\t\t\t\tscanf(\"%d\",&dat[i][j]);\n\t\tfor(int i=0;i<20;i++)\n\t\t\tfor(int j=0;j<20;j++)dp[i][j]=0;\n\t\tfor(int i=0;i<a;i++)if(dat[0][i]!=1)dp[0][i]=1;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(dat[i][j]==0){\n\t\t\t\t\tif(i<b-1&&j&&dat[i+1][j-1]==0)dp[i+1][j-1]+=dp[i][j];\n\t\t\t\t\tif(i<b-1&&j<a-1&&dat[i+1][j+1]==0)dp[i+1][j+1]+=dp[i][j];\n\t\t\t\t\tif(dat[i+1][j]!=1)dp[i+1][j]+=dp[i][j];\n\t\t\t\t}\n\t\t\t\tif(dat[i][j]==2){\n\t\t\t\t\tif(dat[i+2][j]!=1)dp[i+2][j]+=dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=0;\n\t\tfor(int i=b;i<20;i++)\n\t\t\tfor(int j=0;j<a;j++)\n\t\t\t\tret+=dp[i][j];\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n\nusing namespace std;\n\nint main(){\n  int x, y, course[50][50], route[52][52], i, j, sum;\n  while(cin >> x >> y, x+y){\n    sum = 0;\n    for(i=0; i<52; i++){\n      for(j=0; j<52; j++){\n        route[i][j] = 0;\n      }\n    }\n    for(i=0; i<y; i++){\n      for(j=0; j<x; j++){\n        cin >> course[i][j];\n      }\n    }\n    for(i=0; i<y; i++){\n      for(j=0; j<x; j++){\n\tif(i==0){\n          if(course[i][j]==0){\n            route[i][j] = 1;\n          }else{\n\t    route[i][j] = 0;\n          }\n        }else{\n          if(j==0){\n            if(course[i][j]==0){\n              if(course[i-1][j]==0){\n                route[i][j] += route[i-1][j];\n              }\n              if(course[i-1][j+1]==0){\n                route[i][j] += route[i-1][j+1];\n              }\n\t    }else if(course[i][j]==1){\n              route[i][j] = 0;\n            }else{\n              if(course[i-1][j]==0){\n\t        route[i][j] = route[i-1][j];\n                route[i+2][j] += route[i][j];\n              }\n            }\n          }else if(j==x-1){\n            if(course[i][j]==0){\n              if(course[i-1][j]==0){\n                route[i][j] += route[i-1][j];\n              }\n              if(course[i-1][j-1]==0){\n                route[i][j] += route[i-1][j-1];\n              }\n\t    }else if(course[i][j]==1){\n              route[i][j] = 0;\n            }else{\n              if(course[i-1][j]==0){\n\t        route[i][j] = route[i-1][j];\n                route[i+2][j] += route[i][j];\n              }\n            }\n          }else{\n            if(course[i][j]==0){\n              if(course[i-1][j]==0){\n                route[i][j] += route[i-1][j];\n              }\n              if(course[i-1][j-1]==0){\n                route[i][j] += route[i-1][j-1];\n              }\n              if(course[i-1][j+1]==0){\n                route[i][j] += route[i-1][j+1];\n              }\n\t    }else if(course[i][j]==1){\n              route[i][j] = 0;\n            }else{\n              if(course[i-1][j]==0){\n                route[i][j] = route[i-1][j];\n                route[i+2][j] += route[i][j];\n              }\n              if(course[i-2][j]==2){\n                route[i][j] = route[i-2][j];\n                route[i+2][j] += route[i][j];\n              }\n            }\n          }\n        }\n      }\n    }\n    for(i=y-1; i<y+2; i++){\n      for(j=0; j<x; j++){\n        sum+=route[i][j];\n      }\n    }\n    cout << sum << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<iostream>\nusing namespace std;\n \nint main(){\n        int x,y;\n        while(cin>>x>>y,x){\n                int D[16][16],P[16][16],ans=0;\n                for(int i=0;i<256;i++)P[i/16][i%16]=0;\n                for(int i=0;i<y;i++)for(int j=0;j<x;j++)cin>>D[i][j];\n                for(int i=0;i<x;i++)if(!D[0][i])P[0][i]=1;\n                for(int i=0;i<y-1;i++){\n                        for(int j=0;j<x;j++){\n                                if(!D[i][j]){\n                                        P[i+1][j]+=P[i][j];\n                                        if(j>0&&!D[i+1][j-1])P[i+1][j-1]+=P[i][j];\n                                        if(j<x-1&&!D[i+1][j+1])P[i+1][j+1]+=P[i][j];\n                                }\n                                if(D[i][j]==2){\n                                        if(i==y-2) ans += P[i][j];\n                                        else P[i+2][j]+=P[i][j];\n                                }\n                        }\n                }\n                for(int i=0;i<x;i++){\n                        if (D[y - 1][i] != 1)ans+=P[y-1][i];\n                }\n                cout<<ans<<endl;\n        }\n}\n "
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nunsigned int c;\nint n,m;\nint X[3]={-1,0,1};\nint main(){\n  int i,j,k;\n  while(1){\n    scanf(\"%d %d\",&n,&m);\n    if(n==0&&m==0)break;\n    int d[17][15]={{0}};\n    int p[17][15]={{0}};\n    for(i=0;i<m;i++){\n      for(j=0;j<n;j++){\n\tscanf(\"%d\",&d[i][j]);\n      }\n    }\n    for(i=0;i<n;i++)if(d[0][i]==0)p[0][i]=1;\n    for(i=0;i<m-1;i++){\n      for(j=0;j<n;j++){//printf(\"%5d\",p[i][j]);\n\tif(d[i][j]==0){\n\t  for(k=0;k<3;k++){\n\t    if(0<=j+X[k]&&j+X[k]<n){\n\t      if(d[i+1][j+X[k]]==0||(k==1&&d[i+1][j]==2)){\n\t\tp[i+1][j+X[k]]+=p[i][j];\n\t      }\n\t    }\n\t  }\n\t}\n\telse if(d[i][j]==2){\n\t  p[i+2][j]+=p[i][j];\n\t}\n      }\n    }\n    c=0;\n    for(;i<m+1;i++){\n      for(j=0;j<n;j++){//printf(\"%5d\",p[i][j]);\n\tif(d[i][j]!=1){\n\t  c+=p[i][j];\n\t}\n      }//printf(\"\\n\");\n    }\n    printf(\"%d\\n\",c);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(void){\n\tint f[16][17],d[16][17],i,j,c,x,y;\n\tfor(;scanf(\"%d%d\",&x,&y),x;){\n\t\tfor(i=0;i<y;*d[i]=d[i][x+1]=0,*f[i]=f[i][x+1]=1,i++)\n\t\t\tfor(j=1;j<=x;j++)\n\t\t\t\tscanf(\"%d\",f[i]+j);\n\t\tfor(j=1;j<=x;j++)\n\t\t\td[y][j]=1,d[y-1][j]=f[y-1][j]!=1;\n\t\tfor(i=y-1;i--;)\n\t\t\tfor(j=1;j<=x;d[i][j++]=c)\n\t\t\t\tswitch(f[i][j]){\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tc=d[i+1][j];\n\t\t\t\t\t\tf[i+1][j-1]-2?c+=d[i+1][j-1]:0;\n\t\t\t\t\t\tf[i+1][j+1]-2?c+=d[i+1][j+1]:0;\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tc=0;\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tc=d[i+2][j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\tc=0;\n\t\tfor(j=1;j<=x;j++)c+=d[0][j];\n\t\tprintf(\"%d\\n\",c);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint dx[3] = {-1, 0, 1};\nint dy[3] = {1, 1, 1};\n\nint main(void)\n{\n\tint **map, f1, f2, f3, **temp, x, y, sum, px, py;\n\t\n\twhile(scanf(\"%d %d\", &x, &y) && y > 0)\n\t{\n\t\tmap = new int *[y];\n\t\ttemp = new int *[y];\n\t\tsum = 0;\n\n\t\t//マップ土地&動的計画作成\n\t\tfor(f1 = 0; f1 < y; f1++)\n\t\t{\n\t\t\tmap[f1] = new int [x];\n\t\t\ttemp[f1] = new int [x];\n\t\t}\n\t\t//マップ構成入力&初期化\n\t\tfor(f1 = 0; f1 < y; f1++)\n\t\t{\n\t\t\tfor(f2 = 0; f2 < x; f2++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\",&map[f1][f2]);\n\t\t\t\ttemp[f1][f2] = 0;\n\t\t\t}\n\t\t}\n\t\t//最上のスタート地点設定\n\t\tfor(f1 = 0; f1 < x; f1++)\n\t\t{\n\t\t\tif(map[0][f1] != 1)\n\t\t\t{\n\t\t\t\ttemp[0][f1] = 1;\n\t\t\t\tsum++;\n\t\t\t}\n\t\t}\n\t\t//探索\n\t\tif(y >= 2)\n\t\t{\n\t\t\tsum = 0;\n\t\t\tfor(f1 = 0; f1 < y - 1; f1++)\n\t\t\t{\n\t\t\t\tfor(f2 = 0; f2 < x; f2++)\n\t\t\t\t{\n\t\t\t\t\tif(map[f1][f2] == 0 && temp[f1][f2] > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(f3 = 0; f3 < 3; f3++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//移動\n\t\t\t\t\t\t\tpx = f2 + dx[f3];\n\t\t\t\t\t\t\tpy = f1 + dy[f3];\n\t\t\t\t\t\t\t//範囲内か\n\t\t\t\t\t\t\tif(px >= 0 && px < x)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t//同じｘ座標からのジャンプ台\n\t\t\t\t\t\t\t\tif(f3 == 1 && py < y - 1){\n\t\t\t\t\t\t\t\t\t//ｙ軸2つ先へ\n\t\t\t\t\t\t\t\t\twhile(py < y - 1 && map[py][px] == 2)\n\t\t\t\t\t\t\t\t\t\tpy += 2;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t//着地した場所がゴール地点のｙ座標と同じで障害物にぶつかってないか\n\t\t\t\t\t\t\t\t//ゴール地点のｙ座標を超えたか\n\t\t\t\t\t\t\t\tif(py > y - 1 || py == y - 1 && map[py][px] != 1)\n\t\t\t\t\t\t\t\t\tsum += temp[f1][f2];\n\t\t\t\t\t\t\t\t//超えてないが、障害物がない地点に着地したか\n\t\t\t\t\t\t\t\telse if(map[py][px] == 0)\n\t\t\t\t\t\t\t\t\ttemp[py][px] += temp[f1][f2];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//出力\n\t\tprintf(\"%d\\n\",sum);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint main(void)\n{\n\tint ans, num[15][15];\n\tint w, h;\n\tint i, j;\n\tint map[15][15];\n\t\n\twhile (1){\n\t\tscanf(\"%d%d\", &w, &h);\n\t\t\n\t\tif (w + h == 0){\n\t\t\tbreak;\n\t\t}\n\t\tmemset(map, -1, sizeof(map));\n\t\tfor (i = 0; i < h; i++){\n\t\t\tfor (j = 0; j < w; j++){\n\t\t\t\tscanf(\"%d\", &map[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tmemset(num, 0, sizeof(num));\n\t\tfor (i = 0; i < w; i++){\n\t\t\tif (map[0][i] != 1){\n\t\t\t\tnum[0][i] = 1;\n\t\t\t}\n\t\t}\n\t\tfor (i = 1; i < h; i++){\n\t\t\tfor (j = 0; j < w; j++){\n\t\t\t\tif (j > 0 && map[i - 1][j - 1] == 0 && map[i][j] != 2){\n\t\t\t\t\tnum[i][j] += num[i - 1][j - 1];\n\t\t\t\t}\n\t\t\t\tif (map[i - 1][j] == 0){\n\t\t\t\t\tnum[i][j] += num[i - 1][j];\n\t\t\t\t}\n\t\t\t\tif (j < w - 1 && map[i - 1][j + 1] == 0 && map[i][j] != 2){\n\t\t\t\t\tnum[i][j] += num[i - 1][j + 1];\n\t\t\t\t}\n\t\t\t\tif (i > 1 && map[i - 2][j] == 2){\n\t\t\t\t\tnum[i][j] += num[i - 2][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = 0;\n\t\tfor (j = 0; j < w; j++){\n\t\t\tif (map[h - 1][j] != 1){\n\t\t\t\tans += num[h - 1][j];\n\t\t\t}\n\t\t\tif (h > 1 && map[h - 2][j] == 2){\n\t\t\t\tans += num[h - 2][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C",
    "code": "m[15][15],D[15][15];X,Y,x,y,d;main(){for(;scanf(\"%d%d\",&X,&Y),X;printf(\"%d\\n\",d)){for(y=0;y<Y;y++)for(x=X;x--;D[x][y]=d){scanf(\"%d\",m[x]+y);d=y?0:*m[x]!=1;if(m[x][y]-1)d+=m[x][y-1]?0:D[x][y-1],d+=y<2||m[x][y-2]-2?0:D[x][y-2];if(!m[x][y])d+=x<1||m[x-1][y-1]?0:D[x-1][y-1],d+=x+2>X||m[x+1][y-1]?0:D[x+1][y-1];}for(d=0;X--;d+=Y<2||m[X][Y-2]-2?0:D[X][Y-2])d+=D[X][Y-1];}exit(0);}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint memo[32][32];\nint map[32][32];\nint w, h;\n\nint dfs(int x, int y, int px){\n\tint ny = y + 1;\n\n\tif (x < 0 || x >= w) return (0);\n\tif (y >= h) return (1);\n\tif (memo[y][x] != -1) return (memo[y][x]);\n\n\tif (y == h - 1 && map[y][x] != 1) return (memo[y][x] = 1);\n\n\tswitch (map[y][x]){\n\t  case 0: return (memo[y][x] = dfs(x, ny, x) + dfs(x + 1, ny, x) + dfs(x - 1, ny, x));\n\t  case 1: return (memo[y][x] = 0);\n\t  case 2: return (x == px ? dfs(x, ny + 1, x) : 0);\n\t  default:fprintf(stderr, \"%d is invalid value\\n\", map[y][x]);\n\t}\n}\n\nint main(void)\n{\n\twhile (scanf(\"%d %d\", &w, &h), w){\n\t\tint ans = 0;\n\t\tint i, j;\n\n\t\tfor (i = 0; i < h; i++){\n\t\t\tfor (j = 0; j < w; j++){\n\t\t\t\tscanf(\"%d\", map[i] + j);\n\t\t\t}\n\t\t}\n\n\t\tmemset(memo, -1, sizeof(memo));\n\t\tfor (i = 0; i < w; i++){\n\t\t\tans += dfs(i, 0, i);\n\t\t}\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\treturn (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint main(void)\n{\n    int x, y;\n    int c[18][17];\n    int sum;\n    int i, j, k;\n    \n    while (1){\n        scanf(\"%d%d\", &x, &y);\n        if (x == 0 && y == 0){\n            break;\n        }\n        memset(c, 0, sizeof(c));\n        \n        for (i = 1; i <= y; i++){\n            for (j = 1; j <= x; j++){\n                scanf(\"%d\", &c[i][j]);\n                c[i][j] *= -1;\n            }\n        }\n        \n        for (i = 1; i <= x; i++){\n            if (c[1][i] == 0){\n                c[1][i] = 1;\n            }\n//printf(\"[%2d]\", c[1][i]);\n        }\n//printf(\"\\n\");\n\n        \n        for (i = 2; i <= y; i++){\n            for (j = 1; j <= x; j++){\n                if (c[i][j] >= 0){\n                    \n                    // 真上は何もない\n                    if (c[i - 1][j] > 0){\n                        c[i][j] += c[i - 1][j];\n//printf(\"(U%d)\", c[i - 1][j]);\n\n                    }\n\n                    // 左上は何もない\n                    if (c[i - 1][j - 1] > 0){\n                        c[i][j] += c[i - 1][j - 1];\n//printf(\"(L%d,%d=%d)\", i, j, c[i - 1][j - 1]);\n                    }\n                    \n                    // 右上は何もない\n                    if (c[i - 1][j + 1] > 0){\n                        c[i][j] += c[i - 1][j + 1];\n//printf(\"(R%d)\", c[i - 1][j + 1]);\n                    }\n                }\n                    // ジャンプ台\n                else if (c[i - 1][j] >=0 && c[i][j] == -2){\n                    k = i + 2;\n                    while (k <= y + 1){\n                        if (c[k][j] == -2){ //  ジャンプ台か？\n                            k += 2;\n                        }\n                        else {\n                            break;\n                        }\n                    }\n                    if (k <= y + 2 && c[k][j] >= 0){\n                        c[k][j] = c[i - 1][j];\n                    }\n                }\n//printf(\"[%2d]\", c[i][j]);\n                \n            }\n//printf(\"\\n\");\n        }\n        for (i = y + 1; i <= y + 2; i++){\n            for (j = 1; j <= x; j++){\n//printf(\"[%2d]\", c[i][j]);\n            }\n//printf(\"\\n\");\n        }\n        \n        sum = 0;\n        for (i = 1; i <= x; i++){\n            if (c[y][i] >= 0){\n                sum += c[y][i];\n            }\n            sum += c[y + 1][i];\n            sum += c[y + 2][i];\n        }\n        \n        printf(\"%d\\n\", sum);\n    }\n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\tint w,h,xd[]={1,0,-1},p,u[17][17];\n\tvoid ret(int x,int y){\n\t\tint i,s=x;\n\t\tif(h-1<=y)\n\t\t\tp++;\n\t\telse if(u[y][x]==2)\n\t\t\tret(x,y+2);\n\t\telse if(u[y][x]==0){\n\t\t\ty++;\n\t\t\tfor(i=0;i<3;i++){\n\t\t\t\tx=s+xd[i];\n\t\t\t\tif(x>=0&&x<=w-1){\n\t\t\t\t\tif(u[y][x]==2&&i==1)\n\t\t\t\t\t\tret(x,y+2);\n\t\t\t\t\telse if(u[y][x]==0)\n\t\t\t\t\t\tret(x,y);\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\nelse if(u[y][x]==2)\n\t\t\tret(x,y+2);\n\t}\n\tint main(){\n\t\tint i,j,x,y;\n\t\twhile(scanf(\"%d %d\",&w,&h),w||h){\n\t\t\tp=0;\n\t\t\tfor(i=0;i<h;i++){\n\t\t\t\tfor(j=0;j<w-1;j++)\n\t\t\t\tscanf(\"%d \",&u[i][j]);\n\t\t\t\tscanf(\"%d\",&u[i][w-1]);\n\t\t\t}\n\t\t\tfor(i=0;i<w;i++){\n\t\t\t\tif(u[0][i]==0){\n\t\t\t\t\tx=i;\n\t\t\t\t\ty=0;\n\t\t\t\t\tret(x,y);\n\t\t\t\t}\n\t\t\t\telse if(u[0][i]==2){\n\t\t\t\t\tx=i;\n\t\t\t\t\ty=2;\n\t\t\t\t\tret(x,y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",p);\n\t\t}\n\t\treturn 0;\n\t}"
  },
  {
    "language": "C",
    "code": "M[15][15],C[15][15],X,Y;\nint D(x,y){\n\tif(y>=Y-1)return 1;\n\tif(M[x][y])return M[x][y];\n\tif(C[x][y]==2)return M[x][y]=y+2>=Y||C[x][y+2]!=1?D(x,y+2):0;\n\tint s=0;\n\tif(0<x&&C[x-1][y+1]==0)s+=D(x-1,y+1);\n\tif(C[x][y+1]!=1)s+=D(x,y+1);\n\tif(x<X-1&&C[x+1][y+1]==0)s+=D(x+1,y+1);\n\treturn M[x][y]=s;\n}\nmain(i,j,s){for(;scanf(\"%d%d\",&X,&Y),X;printf(\"%d\\n\",j)){\nmemset(M,0,sizeof(M));\nfor(j=0;j<Y;j++)for(i=0;i<X;i++)scanf(\"%d\",C[i]+j);\nfor(j=i=0;i<X;i++)if(C[i][0]!=1)j+=D(i,0);\n}exit(0);}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint main(void)\n{\n\tint ans, num[15][15];\n\tint w, h;\n\tint i, j;\n\tint map[15][15];\n\t\n\twhile (1){\n\t\tscanf(\"%d%d\", &w, &h);\n\t\t\n\t\tif (w + h == 0){\n\t\t\tbreak;\n\t\t}\n\t\tmemset(map, -1, sizeof(map));\n\t\tfor (i = 0; i < h; i++){\n\t\t\tfor (j = 0; j < w; j++){\n\t\t\t\tscanf(\"%d\", &map[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tmemset(num, 0, sizeof(num));\n\t\tfor (i = 0; i < w; i++){\n\t\t\tif (map[0][i] != 1){\n\t\t\t\tnum[0][i] = 1;\n\t\t\t}\n\t\t}\n\t\tfor (i = 1; i < h; i++){\n\t\t\tfor (j = 0; j < w; j++){\n\t\t\t\tif (j > 0 && map[i - 1][j - 1] == 0 && map[i][j] != 2){\n\t\t\t\t\tnum[i][j] += num[i - 1][j - 1];\n\t\t\t\t}\n\t\t\t\tif (map[i - 1][j] == 0){\n\t\t\t\t\tnum[i][j] += num[i - 1][j];\n\t\t\t\t}\n\t\t\t\tif (j < w - 1 && map[i - 1][j + 1] == 0 && map[i][j] != 2){\n\t\t\t\t\tnum[i][j] += num[i - 1][j + 1];\n\t\t\t\t}\n\t\t\t\tif (i > 1 && map[i - 2][j] == 2){\n\t\t\t\t\tnum[i][j] += num[i - 2][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = 0;\n\t\tfor (j = 0; j < w; j++){\n\t\t\tif (map[h - 1][j] == 0){\n\t\t\t\tans += num[h - 1][j];\n\t\t\t}\n\t\t\tif (map[h - 2][j] == 2){\n\t\t\t\tans += num[h - 2][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint main(void)\n{\n\tint ans, num[15][15];\n\tint w, h;\n\tint i, j;\n\tint map[15][15];\n\t\n\twhile (1){\n\t\tscanf(\"%d%d\", &w, &h);\n\t\t\n\t\tif (w + h == 0){\n\t\t\tbreak;\n\t\t}\n\t\tmemset(map, -1, sizeof(map));\n\t\tfor (i = 0; i < h; i++){\n\t\t\tfor (j = 0; j < w; j++){\n\t\t\t\tscanf(\"%d\", &map[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tmemset(num, 0, sizeof(num));\n\t\tfor (i = 0; i < w; i++){\n\t\t\tif (map[0][i] != 1){\n\t\t\t\tnum[0][i] = 1;\n\t\t\t}\n\t\t}\n\t\tfor (i = 1; i < h; i++){\n\t\t\tfor (j = 0; j < w; j++){\n\t\t\t\tif (j > 0 && map[i - 1][j - 1] == 0 && map[i][j] != 2){\n\t\t\t\t\tnum[i][j] += num[i - 1][j - 1];\n\t\t\t\t}\n\t\t\t\tif (map[i - 1][j] == 0){\n\t\t\t\t\tnum[i][j] += num[i - 1][j];\n\t\t\t\t}\n\t\t\t\tif (j < w - 1 && map[i - 1][j + 1] == 0 && map[i][j] != 2){\n\t\t\t\t\tnum[i][j] += num[i - 1][j + 1];\n\t\t\t\t}\n\t\t\t\tif (i > 1 && map[i - 2][j] == 2){\n\t\t\t\t\tnum[i][j] += num[i - 2][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = 0;\n\t\tfor (j = 0; j < w; j++){\n\t\t\tans += num[h - 1][j];\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\nint main(void){int ans,num[15][15],w,h,i,j,map[15][15];while (1){scanf(\"%d%d\", &w, &h);if (w + h == 0){break;}memset(map, -1, sizeof(map));for (i = 0; i < h; i++){for (j = 0; j < w; j++){scanf(\"%d\", &map[i][j]);}}memset(num, 0, sizeof(num));for (i = 0; i < w; i++){if (map[0][i] != 1){num[0][i] = 1;}}for (i = 1; i < h; i++){for (j = 0; j < w; j++){if (j > 0 && map[i - 1][j - 1] == 0 && map[i][j] != 2){num[i][j] += num[i - 1][j - 1];}if (map[i - 1][j] == 0){num[i][j] += num[i - 1][j];}if (j < w - 1 && map[i - 1][j + 1] == 0 && map[i][j] != 2){num[i][j] += num[i - 1][j + 1];}if (i > 1 && map[i - 2][j] == 2){num[i][j] += num[i - 2][j];}}}ans = 0;for (j = 0; j < w; j++){if (map[h - 1][j] != 1){ans += num[h - 1][j];}if (h > 1 && map[h - 2][j] == 2){ans += num[h - 2][j];}}printf(\"%d\\n\", ans);}return (0);}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint main(){\n  while(1){\n    int dp[17][17], cond[17][17], x, y, i, j;\n    int ans = 0;\n    scanf(\"%d%d\", &x, &y);\n    if(x == 0 && y == 0)return 0;\n    memset(dp, 0, sizeof(dp));\n    for(i = 0;i < y;i++){\n      for(j = 1;j <= x;j++){\n\tscanf(\"%d\", &cond[i][j]);\n      }\n    }\n    for(i = 0;i <= y;i++){\n      for(j = 1;j <= x;j++){\n\tif(cond[i][j] == 1)continue;\n\tif(i == 0)dp[i][j] = 1;\n\tif(i > 2 && cond[i - 2][j] == 2)\n\t  dp[i][j] += dp[i - 2][j];\n\tif(i > 0 && cond[i][j] != 1){\n\t  if(cond[i - 1][j] == 0)\n\t    dp[i][j] += dp[i - 1][j];\n\t  if(cond[i][j] != 2 && cond[i - 1][j - 1] == 0)\n\t    dp[i][j] += dp[i - 1][j - 1];\n\t  if(cond[i][j] != 2 && cond[i - 1][j + 1] == 0)\n\t    dp[i][j] += dp[i - 1][j + 1];\n\t}\n      }\n    }\n    for(j = 1;j <= x;j++){\n      if(cond[y - 1][j] != 1)\n\tans += dp[y - 1][j];\n      if(cond[y - 2][j] == 2)\n\tans += dp[y - 2][j];\n    }\n   \n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint main(){\n\tint x,y,m[20][20],d[20][20],i,j,ans;\n\tFILE *fp;\n\t//fp=fopen(\"test.txt\",\"r\");\n\tfp=stdin;\n\twhile(1){\n\t\tfscanf(fp,\"%d%d\",&x,&y);\n\t\tif(x==0 && y==0)break;\n\t\tmemset(d,0,sizeof(d));\n\t\tmemset(m,0,sizeof(m));\n\t\tfor(i=1;i<=y;i++){\n\t\t\tfor(j=1;j<=x;j++){\n\t\t\t\tfscanf(fp,\"%d\",&m[i][j]);\n\t\t\t\tif(i==1){\n\t\t\t\t\tif(m[i][j]==0)d[i][j]=1;\n\t\t\t\t\telse if(m[i][j]==2)d[i+2][j]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=2;i<=y;i++){\n\t\t\tfor(j=1;j<=x;j++){\n\t\t\t\tif(m[i][j]==0){\n\t\t\t\t\td[i][j]+=d[i-1][j-1]+d[i-1][j]+d[i-1][j+1];\n\t\t\t\t}else if(m[i][j]==1){\n\t\t\t\t\td[i][j]=0;\n\t\t\t\t}else if(m[i][j]==2){\n\t\t\t\t\td[i+2][j]+=d[i-1][j]+d[i][j];\n\t\t\t\t\td[i][j]=0;\n\t\t\t\t}\n\t\t\t\t//printf(\"%d%s\",d[i][j],(j==x)?\"\\n\":\" \");\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=x;i++)d[y+1][i]+=d[y][i];\n\t\t//\tprintf(\"%d%s\",d[y+1][i],(i==x)?\"\\n\":\" \");\n\t\tans=0;\n\t\tfor(i=1;i<=x;i++)ans+=d[y+1][i]/*+d[y][i]*/;\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#define MOVE 0\n#define TREE 1\n#define JUMP 2\nm[15][15],D[15][15];\nX,Y,x,y,d;\nmain(){\n\tfor(;scanf(\"%d%d\",&X,&Y),X;){\n\t\tfor(y=0;y<Y;y++)\n\t\t\tfor(x=0;x<X;x++)\n\t\t\t\tscanf(\"%d\",&m[x][y]);\n\t\tfor(x=0;x<X;x++)\n\t\t\tD[x][0]=m[x][0]!=TREE;\n\t\tfor(y=1;y<Y;y++){\n\t\t\tfor(x=0;x<X;x++){\n\t\t\t\td=0;\n\t\t\t\tif(m[x][y]!=TREE){\n\t\t\t\t\tif(m[x][y-1]==MOVE)\n\t\t\t\t\t\td+=D[x][y-1];\n\t\t\t\t\tif(y-2>=0&&m[x][y-2]==JUMP)\n\t\t\t\t\t\td+=D[x][y-2];\n\t\t\t\t}\n\t\t\t\tif(m[x][y]==MOVE){\n\t\t\t\t\tif(x-1>=0&&m[x-1][y-1]==MOVE)\n\t\t\t\t\t\td+=D[x-1][y-1];\n\t\t\t\t\tif(x+1<X&&m[x+1][y-1]==MOVE)\n\t\t\t\t\t\td+=D[x+1][y-1];\n\t\t\t\t}\n\t\t\t\tD[x][y]=d;\n\t\t\t}\n\t\t}\n\t\td=0;\n\t\tfor(x=0;x<X;x++){\n\t\t\td+=D[x][Y-1];\n\t\t\tif(Y-2>=0&&m[x][Y-2]==JUMP)\n\t\t\t\td+=D[x][Y-2];\n\t\t}\n\t\tprintf(\"%d\\n\",d);\n\t}\n\texit(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define N 16\n\nint map[ N ][ N ];\nint w, h;\nint k_operafan[ N ][ N ];\n\nint dpFSA (\n  int x,\n  int y\n  )\n{\n  if ( x < 0 || y < 0 || x >= w )\n  {\n    return ( 0 );\n  }\n  else if ( y >= h )\n  {\n    return ( 1 );\n  }\n  else if ( ~k_operafan[ x ][ y ] ) ;\n  else if ( map[ x ][ y ] == 1 )\n  {\n    k_operafan[ x ][ y ] = 0;\n  }\n  else if ( map[ x ][ y ] == 2 )\n  {\n    k_operafan[ x ][ y ] = dpFSA ( x, y + 2 );\n  }\n  else if ( y == h - 1 )\n  {\n    k_operafan[ x ][ y ] = 1;\n  }\n  else\n  {\n    k_operafan[ x ][ y ] = ( map[ x - 1 ][ y + 1 ] == 2\n                           ? 0 : dpFSA ( x - 1, y + 1 ) )\n                         + dpFSA ( x, y + 1 )\n                         + ( map[ x + 1 ][ y + 1 ] == 2\n                           ? 0 : dpFSA ( x + 1, y + 1 ) );\n  }\n\n  return ( k_operafan[ x ][ y ] );\n}\n\n/** Application main entry point. */\nint main (\n  int     argc,\n  char  * argv[ ]\n  )\n{\n  int x, y;\n\n  for ( ; ; )\n  {\n    int res = 0;\n\n    scanf ( \"%d%d\", &w, &h );\n    if ( !( w | h ) ) break ;\n\n    for ( y = 0; y < h; ++y )\n    for ( x = 0; x < w; ++x )\n    {\n      scanf ( \"%d\", &map[ x ][ y ] );\n    }\n\n    memset ( k_operafan, -1, sizeof ( k_operafan ) );\n    for ( x = 0; x < w; ++x )\n    {\n      res += dpFSA ( x, 0 );\n    }\n\n    printf ( \"%d\\n\", res );\n  }\n\n  return ( 0 );\n}"
  },
  {
    "language": "C",
    "code": "int main(void){int ans, num[15][15], w, h, i, j, map[15][15];while (1){scanf(\"%d%d\", &w, &h);if (w + h == 0){break;}memset(map, -1, sizeof(map));for (i = 0; i < h; i++){for (j = 0; j < w; j++){scanf(\"%d\", &map[i][j]);}}memset(num, 0, sizeof(num));for (i = 0; i < w; i++){if (map[0][i] != 1){num[0][i] = 1;}}for (i = 1; i < h; i++){for (j = 0; j < w; j++){if (j > 0 && map[i - 1][j - 1] == 0 && map[i][j] != 2){num[i][j] += num[i - 1][j - 1];}if (map[i - 1][j] == 0){num[i][j] += num[i - 1][j];}if (j < w - 1 && map[i - 1][j + 1] == 0 && map[i][j] != 2){num[i][j] += num[i - 1][j + 1];}if (i > 1 && map[i - 2][j] == 2){num[i][j] += num[i - 2][j];}}}ans = 0;for (j = 0; j < w; j++){if (map[h - 1][j] != 1){ans += num[h - 1][j];}if (h > 1 && map[h - 2][j] == 2){ans += num[h - 2][j];}}printf(\"%d\\n\", ans);}return (0);}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint memo[16][16];\nint map[16][16];\nint w, h;\n\nint dfs(int x, int y, int px){\n\tint ny = y + 1;\n\n\tif (x < 0 || x >= w) return (0);\n\tif (y >= h) return (1);\n\tif (memo[y][x] != -1) return (memo[y][x]);\n\n\tif (y == h - 1 && map[y][x] != 1) return (memo[y][x] = 1);\n\n\tswitch (map[y][x]){\n\t  case 0: return (memo[y][x] = dfs(x, ny, x) + dfs(x + 1, ny, x) + dfs(x - 1, ny, x));\n\t  case 1: return (memo[y][x] = 0);\n\t  case 2: return (x == px ? dfs(x, ny + 1, x) : 0);\n\t  default:fprintf(stderr, \"%d is invalid value\\n\", map[y][x]);\n\t}\n}\n\nint main(void)\n{\n\twhile (scanf(\"%d %d\", &w, &h), w){\n\t\tint ans = 0;\n\t\tint i, j;\n\n\t\tfor (i = 0; i < h; i++){\n\t\t\tfor (j = 0; j < w; j++){\n\t\t\t\tscanf(\"%d\", map[i] + j);\n\t\t\t}\n\t\t}\n\n\t\tmemset(memo, -1, sizeof(memo));\n\t\tfor (i = 0; i < w; i++){\n\t\t\tans += dfs(i, 0, i);\n\t\t}\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\treturn (0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint i,j;\nint x,y;\nlong long int dp[1000][1000];\nint map[1000][1000];\nint main(void){\n\tscanf(\"%d %d\",&x,&y);\n\twhile(x!=0 && y!=0){\n\t\tfor(i=1;i<=17;i++){\n\t\t\tfor(j=1;j<=15;j++){\n\t\t\t\tdp[i][j]=0;\n\t\t\t\tmap[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=y;i++){\n\t\t\tfor(j=1;j<=x;j++){\n\t\t\t\tscanf(\"%d\",&map[i][j]);\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=x;i++){\n\t\t\tif(map[1][i]!=1){\n\t\t\t\tdp[1][i]=1;\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<y;i++){\n\t\t\tfor(j=1;j<=x;j++){\n\t\t\t\tif(dp[i][j]>0 && map[i][j]!=2){\n\t\t\t\t\tif(map[i+1][j-1]==0){\n\t\t\t\t\t\tif(j-1<0);\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tdp[i+1][j-1]+=dp[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(map[i+1][j]!=1 ){\n\t\t\t\t\t\tif(map[i+1][j]==0){\n\t\t\t\t\t\t\tdp[i+1][j]+=dp[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tint temp;\n\t\t\t\t\t\t\ttemp=i+1;\n\t\t\t\t\t\t\twhile(map[temp][j]==2){\n\t\t\t\t\t\t\t\ttemp+=2;\n\t\t\t\t\t\t\t\tdp[temp][j]+=dp[i][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(map[i+1][j+1]==0){\n\t\t\t\t\t\tif(j+1>x);\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tdp[i+1][j+1]+=dp[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n/*\t\tfor(i=1;i<=y+2;i++){\n\t\t\tprintf(\"%d=\",i);\n\t\t\tfor(j=1;j<=x;j++){\n\t\t\t\tprintf(\"%lld \",dp[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\tlong long int cnt=0;\n\t\tfor(i=0;i<=2;i++){\n\t\t\tfor(j=1;j<=x;j++){\n\t\t\t\tcnt+=dp[y+i][j];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",cnt);\n\t\tscanf(\"%d %d\",&x,&y);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint main(void)\n{\n    int x, y;\n    int c[18][17];\n    int sum;\n    int i, j, k;\n    \n    while (1){\n        scanf(\"%d%d\", &x, &y);\n        if (x == 0 && y == 0){\n            break;\n        }\n        memset(c, 0, sizeof(c));\n        \n        for (i = 1; i <= y; i++){\n            for (j = 1; j <= x; j++){\n                scanf(\"%d\", &c[i][j]);\n                c[i][j] *= -1;\n            }\n        }\n        \n        for (i = 1; i <= x; i++){\n            if (c[1][i] == 0){\n                c[1][i] = 1;\n            }\n//printf(\"[%2d]\", c[1][i]);\n        }\n//printf(\"\\n\");\n\n        \n        for (i = 2; i <= y; i++){\n            for (j = 1; j <= x; j++){\n                if (c[i][j] >= 0){\n                    \n                    // 真上は何もない\n                    if (c[i - 1][j] > 0){\n                        c[i][j] += c[i - 1][j];\n//printf(\"(U%d)\", c[i - 1][j]);\n\n                    }\n\n                    // 左上は何もない\n                    if (c[i - 1][j - 1] > 0){\n                        c[i][j] += c[i - 1][j - 1];\n//printf(\"(L%d,%d=%d)\", i, j, c[i - 1][j - 1]);\n                    }\n                    \n                    // 右上は何もない\n                    if (c[i - 1][j + 1] > 0){\n                        c[i][j] += c[i - 1][j + 1];\n//printf(\"(R%d)\", c[i - 1][j + 1]);\n                    }\n                }\n                    // ジャンプ台\n                else if (c[i - 1][j] >=0 && c[i][j] == -2){\n                    k = i + 2;\n                    while (k <= y + 1){\n                        if (c[k][j] == -2){ //  ジャンプ台か？\n                            k += 2;\n                        }\n                        else {\n                            break;\n                        }\n                    }\n                    if (k <= y + 1 && c[k][j] >= 0){\n                        c[k][j] = c[i - 1][j];\n                    }\n                }\n//printf(\"[%2d]\", c[i][j]);\n                \n            }\n//printf(\"\\n\");\n        }\n        for (i = 1; i <= x; i++){\n            if (c[y][i] >= 0){\n                c[y + 1][i] += c[y][i];\n                c[y + 1][i] += c[y + 2][i];\n            }\n//printf(\"[%2d]\", c[y + 1][i]);\n        }\n//printf(\"\\n\");\n        \n        sum = 0;\n        for (i = 1; i <= x; i++){\n            sum += c[y + 1][i];\n        }\n        \n        printf(\"%d\\n\", sum);\n    }\n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint x,y,dp[20][15],m[15][15],i,j,k,t,r;\nint main()\n{\n\tfor(;scanf(\"%d%d\",&x,&y),x;)\n\t{\n\t\tmemset(dp,0,sizeof(dp));\n\t\tfor(i=0;i<y;i++)\n\t\t\tfor(j=0;j<x;j++)\n\t\t\t\tscanf(\"%d\",&m[i][j]);\n\t\tfor(i=0;i<x;i++)\n\t\t\tif(!m[0][i])\n\t\t\t\tdp[0][i]=1;\n\t\tfor(i=0;i<y-1;i++)\n\t\t\tfor(j=0;j<x;j++)\n\t\t\t{\n\t\t\t\tif(m[i][j]==0)\n\t\t\t\t{\n\t\t\t\t\tif(m[i+1][j]!=1)\n\t\t\t\t\t\tdp[i+1][j]+=dp[i][j];\n\t\t\t\t\tif(j>0&&m[i+1][j-1]==0)\n\t\t\t\t\t\tdp[i+1][j-1]+=dp[i][j];\n\t\t\t\t\tif(j<x-1&&m[i+1][j+1]==0)\n\t\t\t\t\t\tdp[i+1][j+1]+=dp[i][j];\n\t\t\t\t}\n\t\t\t\telse if(m[i][j]==1)\n\t\t\t\t\tdp[i][j]=0;\n\t\t\t\telse\n\t\t\t\t\tif(m[i+2][j]!=1)\n\t\t\t\t\t\tdp[i+2][j]+=dp[i][j];\n\t\t\t}\n\t\tfor(i=r=0;i<x;i++)\n\t\t\tr+=dp[y-1][i]+dp[y][i]+dp[y+1][i];\n\t\tprintf(\"%d\\n\",r);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nunsigned int c;\nint n,m;\nint X[3]={-1,0,1};\nint main(){\n  int i,j,k;\n  while(1){\n    scanf(\"%d %d\",&n,&m);\n    if(n==0&&m==0)break;\n    int d[15][17]={{0}};\n    int p[15][17]={{0}};\n    for(i=0;i<m;i++){\n      for(j=0;j<n;j++){\n\tscanf(\"%d\",&d[i][j]);\n      }\n    }\n    for(i=0;i<n;i++)if(d[0][i]==0)p[0][i]=1;\n    for(i=0;i<m-1;i++){\n      for(j=0;j<n;j++){//printf(\"%5d\",p[i][j]);\n\tif(d[i][j]==0){\n\t  for(k=0;k<3;k++){\n\t    if(0<=j+X[k]&&j+X[k]<n){\n\t      if(d[i+1][j+X[k]]==0||(k==1&&d[i+1][j]==2)){\n\t\tp[i+1][j+X[k]]+=p[i][j];\n\t      }\n\t    }\n\t  }\n\t}\n\telse if(d[i][j]==2){\n\t  p[i+2][j]+=p[i][j];\n\t}\n      }//printf(\"\\n\");\n    }\n    c=0;\n    for(;i<m+1;i++){\n      for(j=0;j<n;j++){\n\tif(d[i][j]!=1){\n\t  c+=p[i][j];\n\t}\n      }\n    }\n    printf(\"%d\\n\",c);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A0203\nA New Plan of Aizu Ski Resort\n*/\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\nint X,Y;\nchar ski[15][16];\nlong int ways[16][16];\n#define DEBUG 0\ndisplay_ski()\n{\n  int i,j;\n\n  for(i=0;i<=Y;i++)\n    {\n      for(j=0;j<X;j++)\n\tprintf(\"%ld:\",ways[i][j]);\n      printf(\"\\n\");\n    }\n}\ndisplay_cource()\n{\n  int i,j;\n\n  for(i=0;i<=Y;i++)\n    {\n      for(j=0;j<X;j++)\n\tprintf(\"%c:\",ski[i][j]);\n      printf(\"\\n\");\n    }\n}\nmain()\n{\n  int i,j;\n  long int sum;\n  char buffer[50];\n  char *p;\n\n  while(EOF != scanf(\" %d %d \",&X,&Y) && (X||Y))\n    {\n      for(i=0;i<Y;i++)\n\t{\n\t  fgets(buffer,50,stdin);\n\t  for(j=0;j<X;j++)\n\t  {  \n\t    ski[i][j]=buffer[j*2];\n\t  }\n\t}\n\n      for(j=0;j<X;j++)\n\t{\n\t  ways[0][j] = (ski[0][j]=='0')?1:0;\n\t}\n      for(i=1;i<Y;i++)\n\tfor(j=0;j<X;j++)\n\t  {\n\t    if(ski[i][j] == '1')\n\t      ways[i][j] = 0;\n\t    if(ski[i][j] == '2')  \n\t      { \n\t\tways[i][j]=0;\n\t\tif (ski[i-1][j]=='0')\n\t\t  ways[i][j]+=ways[i-1][j];\n\t\tif( ski[i-2][j]=='2')\n\t\t  ways[i][j]+=ways[i-2][j];\n\t      }\n\t    else if(ski[i][j] == '0')\n\t      { \n\t\tways[i][j]=0;\n\t\tif(ski[i-1][j]=='0')\n\t\t  ways[i][j] +=ways[i-1][j];\n\t\tif(j>0&&ski[i-1][j-1]=='0')\n\t\t  ways[i][j] += ways[i-1][j-1];\n\t\tif(j<X&&ski[i-1][j+1]=='0')\n\t\t  ways[i][j] += ways[i-1][j+1];\n\t\tif(ski[i-2][j]=='2')\n\t\t  ways[i][j] += ways[i-2][j];\n\t      }\n\t  }\n\n      for(j=0;j<X;j++)\n\tif(ski[Y-2][j] == '2')\n\t  ways[Y][j] = ways[Y-2][j];\n\telse\n\t  ways[Y][j] = 0;\n      sum=0;\n      for(j=0;j<=X;j++)\n\t{\n\t  sum += ways[Y-1][j];\n\t  sum += ways[Y][j];\n\t}\n      /*display_ski();*/\n      printf(\"%ld\\n\",sum);\n    }\nreturn(0);\n}\n "
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint main(){\n  while(1){\n    int dp[17][17], cond[17][17], x, y, i, j, c;\n    long long int ans = 0;\n    scanf(\"%d%d\", &x, &y);\n    if(x == 0 && y == 0)return 0;\n    memset(dp, 0, sizeof(dp));\n    for(i = 0;i < y;i++){\n      for(j = 1;j <= x;j++){\n\tscanf(\"%d\", &cond[i][j]);\n      }\n    }\n    for(i = 0;i < y - 1;i++){\n      for(j = 1;j <= x;j++){\n\tif(i == 0)\n\t  dp[i][j] = !cond[i][j];\n\tif(cond[i][j] == 2)\n\t  dp[i + 2][j] += dp[i][j];\n\tif(cond[i][j] == 0){\n\t  dp[i + 1][j] += dp[i][j];\n\t  if(cond[i + 1][j - 1] != 2)\n\t    dp[i + 1][j - 1] += dp[i][j];\n\t  if(cond[i + 1][j + 1] != 2)\n\t    dp[i + 1][j + 1] += dp[i][j];\n\t}\t\n      }\n    }\n    for(i = y - 1;i <= y;i++){\n      for(j = 1;j <= x;j++){\n\tif(cond[i][j] != 1)\n\t  ans += dp[i][j];\t\n      }\n    }\n    printf(\"%lld\\n\", ans);\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint main(){\n\tint x,y,m[20][20],d[20][20],i,j,ans;\n\tFILE *fp;\n\t//fp=fopen(\"test.txt\",\"r\");\n\tfp=stdin;\n\twhile(1){\n\t\tfscanf(fp,\"%d%d\",&x,&y);\n\t\tif(x==0 && y==0)break;\n\t\tmemset(d,0,sizeof(d));\n\t\tmemset(m,0,sizeof(m));\n\t\tfor(i=1;i<=y;i++){\n\t\t\tfor(j=1;j<=x;j++){\n\t\t\t\tfscanf(fp,\"%d\",&m[i][j]);\n\t\t\t\tif(i==1 && m[i][j]==0)d[i][j]=1;\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=y;i++){\n\t\t\tfor(j=1;j<=x;j++){\n\t\t\t\tif(m[i][j]==0){\n\t\t\t\t\td[i][j]+=d[i-1][j-1]+d[i-1][j]+d[i-1][j+1];\n\t\t\t\t}else if(m[i][j]==1){\n\t\t\t\t\td[i][j]=0;\n\t\t\t\t}else if(m[i][j]==2){\n\t\t\t\t\td[i+2][j]+=d[i-1][j]+d[i][j];\n\t\t\t\t\td[i][j]=0;\n\t\t\t\t}\n\t\t\t\t//printf(\"%d%s\",d[i][j],(j==x)?\"\\n\":\" \");\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=x;i++){\n\t\t\td[y+1][i]+=d[y][i];\n\t\t\t//printf(\"%d%s\",d[y+1][i],(i==x)?\"\\n\":\" \");\n\t\t}\n\t\tans=0;\n\t\tfor(i=1;i<=x;i++)ans+=d[y+1][i]/*+d[y][i]*/;\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint x, y;\nint map[32][32];\nint dp[32][32];\n\nint solve(void)\n{\n    int i, j;\n    int sum;\n\n    memset(dp, 0, sizeof(int) * 32 * 32);\n\n    for (j = 1; j <= x; ++j) dp[1][j] = !map[1][j];\n\n    for (i = 1; i <= y - 1; ++i){\n        for (j = 1; j <= x; ++j){\n            switch (map[i][j]){\n            case 0:\n                dp[i + 1][j] += dp[i][j];\n                if (map[i + 1][j - 1] != 2) dp[i + 1][j - 1] += dp[i][j];\n                if (map[i + 1][j + 1] != 2) dp[i + 1][j + 1] += dp[i][j];\n                break;\n            case 1:\n                dp[i][j] = 0;\n                break;\n            case 2:\n                dp[i + 2][j] += dp[i][j];\n                break;\n            }\n        }\n    }\n\n    sum = 0;\n    for (j = 1; j <= x; ++j){\n        if (map[y][j] != 1) sum += dp[y][j];\n        if (map[y + 1][j] != 1) sum += dp[y + 1][j];\n    }\n\n    // for (i = 1; i <= y + 1; ++i){\n    //     for (j = 1; j <= x; ++j){\n    //         printf(\"%3d\", dp[i][j]);\n    //     }\n    //     puts(\"\");\n    // }\n\n    return sum;\n}\n\nint main(void)\n{\n    int i, j;\n\n    while (scanf(\"%d %d\", &x, &y), x){\n        for (i = 1; i <= y; ++i){\n            for (j = 1; j <= x; ++j) scanf(\"%d\", map[i] + j);\n        }\n        printf(\"%d\\n\", solve());\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A0203\nA New Plan of Aizu Ski Resort\n*/\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\nint X,Y;\nchar ski[15][16];\nlong int ways[16][16];\n#define DEBUG 0\ndisplay_ski()\n{\n  int i,j;\n\n  for(i=0;i<=Y;i++)\n    {\n      for(j=0;j<X;j++)\n\tprintf(\"%ld:\",ways[i][j]);\n      printf(\"\\n\");\n    }\n}\ndisplay_cource()\n{\n  int i,j;\n\n  for(i=0;i<=Y;i++)\n    {\n      for(j=0;j<X;j++)\n\tprintf(\"%c:\",ski[i][j]);\n      printf(\"\\n\");\n    }\n}\nmain()\n{\n  int i,j;\n  long int sum;\n  char buffer[50];\n  char *p;\n\n  while(EOF != scanf(\" %d %d \",&X,&Y) && (X||Y))\n    {\n      for(i=0;i<Y;i++)\n\t{\n\t  fgets(buffer,50,stdin);\n\t  for(j=0;j<X;j++)\n\t  {  \n\t    ski[i][j]=buffer[j*2];\n\t  }\n\t}\n\n      for(j=0;j<X;j++)\n\t{\n\t  ways[0][j] = (ski[0][j]=='0')?1:0;\n\t}\n      for(i=1;i<Y;i++)\n\tfor(j=0;j<X;j++)\n\t  {\n\t    if(ski[i][j] == '1')\n\t      ways[i][j] = 0;\n\t    else if(ski[i][j] == '2' && ski[i-1][j]=='0')\n\t      ways[i][j]=ways[i-1][j];\n\t    else if(ski[i][j] == '2' && ski[i-2][j]=='2')\n\t      ways[i][j]=ways[i-2][j];\n\t    else if(ski[i][j] == '0')\n\t      { if(ski[i-1][j]=='0')\n\t\t  ways[i][j]=ways[i-1][j];\n\t\tif(j>0&&ski[i-1][j-1]=='0')\n\t\t  ways[i][j] += ways[i-1][j-1];\n\t\tif(j<X&&ski[i-1][j+1]=='0')\n\t\t  ways[i][j] += ways[i-1][j+1];\n\t\tif(ski[i-2][j]=='2')\n\t\t  ways[i][j] += ways[i-2][j];\n\t      }\n\t  }\n\n      for(j=0;j<X;j++)\n\tif(ski[Y-2][j] == '2')\n\t  ways[Y][j] = ways[Y-2][j];\n      sum=0;\n      for(j=0;j<=X;j++)\n\t{\n\t  sum += ways[Y-1][j];\n\t  sum += ways[Y][j];\n\t}\n      printf(\"%ld\\n\",sum);\n    }\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint main(void)\n{\n\tlong long ans, num[16][16];\n\tint w, h;\n\tint i, j;\n\tint map[16][16];\n\t\n\twhile (1){\n\t\tscanf(\"%d%d\", &w, &h);\n\t\t\n\t\tif (w + h == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor (i = 0; i < h; i++){\n\t\t\tfor (j = 0; j < w; j++){\n\t\t\t\tscanf(\"%d\", &map[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tmemset(num, 0, sizeof(num));\n\t\tfor (i = 0; i < w; i++){\n\t\t\tif (map[0][i] != 1){\n\t\t\t\tnum[0][i] = 1;\n\t\t\t}\n\t\t}\n\t\tfor (i = 1; i <= h; i++){\n\t\t\tfor (j = 0; j < w; j++){\n\t\t\t\tif (j > 0 && map[i - 1][j - 1] == 0 && map[i][j] != 2){\n\t\t\t\t\tnum[i][j] += num[i - 1][j - 1];\n\t\t\t\t}\n\t\t\t\tif (map[i - 1][j] == 0){\n\t\t\t\t\tnum[i][j] += num[i - 1][j];\n\t\t\t\t}\n\t\t\t\tif (j < w - 1 && map[i - 1][j + 1] == 0 && map[i][j] != 2){\n\t\t\t\t\tnum[i][j] += num[i - 1][j + 1];\n\t\t\t\t}\n\t\t\t\tif (i > 1 && map[i - 2][j] == 2){\n\t\t\t\t\tnum[i][j] += num[i - 2][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = 0;\n\t\tfor (j = 0; j < w; j++){\n\t\t\tans += num[h - 1][j];\n\t\t}\n\t\t\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint map[19][19],dp[19][19];\nint main(){\n\tint i,j,x,y;\n\tlong long int ans;\n\t\n\twhile(1){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif(x+y==0)break;\n\t\tmemset(dp,0,sizeof(dp));\n\t\tmemset(map,0,sizeof(map));\n\t\tans=0;\n\t\tfor(i=1;i<=y;i++){\n\t\t\tfor(j=1;j<=x;j++){\n\t\t\t\tscanf(\"%d\",&map[i][j]);\n\t\t\t\tif(i==1 && map[1][j]==0)dp[1][j]=1;\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=y;i++){\n\t\t\tfor(j=1;j<=x;j++){\n\t\t\t\tif(map[i][j]==0){\n\t\t\t\t\tif(map[i+1][j]!=1)dp[i+1][j]+=dp[i][j];\n\t\t\t\t\tif(i<y){\n\t\t\t\t\t\tif(map[i+1][j-1]==0)dp[i+1][j-1]+=dp[i][j];\n\t\t\t\t\t\tif(map[i+1][j+1]==0)dp[i+1][j+1]+=dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(map[i][j]==2){\n\t\t\t\t\tdp[i+2][j]+=dp[i][j];\n\t\t\t\t}\n\t\t\t\t//printf(\"%2d \",dp[i][j]);\n\t\t\t}\n\t\t\t//printf(\"\\n\");\n\t\t}\n\t\tfor(j=1;j<=x;j++){\n\t\t\t//ans+=dp[y+1][j]+dp[y+2][j];\n\t\t\tif(map[y+1][j]!=1)ans+=dp[y+1][j];\n\t\t\tif(map[y+2][j]!=1)ans+=dp[y+2][j];\n\t\t\t//printf(\"%2d \",dp[y+1][j]);\n\t\t}\n\t\t//printf(\"\\n\");\n\t\t//for(j=1;j<=x;j++)printf(\"%2d \",dp[y+2][j]);\n\t\t//printf(\"\\n\");\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<iostream>\nusing namespace std;\n \nint main(){\n        int x,y;\n        while(cin>>x>>y,x){\n                int D[16][16],P[16][16],ans=0;\n                for(int i=0;i<256;i++)P[i/16][i%16]=0;\n                for(int i=0;i<y;i++)for(int j=0;j<x;j++)cin>>D[i][j];\n                for(int i=0;i<x;i++)if(!D[0][i])P[0][i]=1;\n                for(int i=0;i<y-1;i++){\n                        for(int j=0;j<x;j++){\n                                if(!D[i][j]){\n                                        if (D[i + 1][j] != 1) P[i+1][j]+=P[i][j];\n                                        if(j>0 && !D[i + 1][j - 1])P[i+1][j-1]+=P[i][j];\n                                        if(j<x-1 && !D[i + 1][j + 1])P[i+1][j+1]+=P[i][j];\n                                }\n                                if(D[i][j]==2){\n                                        if(i+2>y-1)P[i+1][j]+=P[i][j];\n                                        else P[i+2][j]+=P[i][j];\n                                }\n                        }\n                }\n                for(int i=0;i<x;i++)ans+=P[y-1][i];\n                cout<<ans<<endl;\n        }\n}\n "
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void) {\n\tint x_max,y_max;\n\tint course[17][17];\n\tint putterns[17][17];\n\tint x,y;\n\tint result;\n\twhile(1) {\n\t\tscanf(\"%d%d\",&x_max,&y_max);\n\t\tif(x_max==0 && y_max==0)break;\n\t\tfor(y=0;y<y_max;y++) {\n\t\t\tputterns[y][0]=0;\n\t\t\tfor(x=1;x<=x_max;x++) {\n\t\t\t\tscanf(\"%d\",&course[y][x]);\n\t\t\t\tputterns[y][x]=0;\n\t\t\t}\n\t\t\tputterns[y][x]=0;\n\t\t}\n\t\tfor(x=1;x<=x_max;x++) {\n\t\t\tputterns[y_max][x]=1;\n\t\t\tputterns[y_max+1][x]=1;\n\t\t}\n\t\tfor(x=1;x<=x_max;x++) {\n\t\t\tif(course[y_max-1][x]==1)putterns[y_max-1][x]=0;\n\t\t\telse putterns[y_max-1][x]=1;\n\t\t}\n\t\tfor(y=y_max-2;y>=0;y--) {\n\t\t\tfor(x=1;x<=x_max;x++) {\n\t\t\t\tswitch(course[y][x]) {\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tputterns[y][x]=0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tputterns[y][x]=putterns[y+2][x];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tputterns[y][x]=putterns[y+1][x];\n\t\t\t\t\t\tif(course[y+1][x-1]!=2) {\n\t\t\t\t\t\t\tputterns[y][x]+=putterns[y+1][x-1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(course[y+1][x+1]!=2) {\n\t\t\t\t\t\t\tputterns[y][x]+=putterns[y+1][x+1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(x=1,result=0;x<=x_max;x++)result+=putterns[0][x];\n\t\tprintf(\"%d\\n\",result);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<iostream>\nusing namespace std;\n \nint main(){\n        int x,y;\n        while(cin>>x>>y,x){\n                int D[16][16],P[16][16],ans=0;\n                for(int i=0;i<256;i++)P[i/16][i%16]=0;\n                for(int i=0;i<y;i++)for(int j=0;j<x;j++)cin>>D[i][j];\n                for(int i=0;i<x;i++)if(!D[0][i])P[0][i]=1;\n                for(int i=0;i<y-1;i++){\n                        for(int j=0;j<x;j++){\n                                if(!D[i][j]){\n                                        P[i+1][j]+=P[i][j];\n                                        if(j>0 && D[i + 1][j - 1] != 2)P[i+1][j-1]+=P[i][j];\n                                        if(j<x-1 && D[i + 1][j + 1] != 2)P[i+1][j+1]+=P[i][j];\n                                }\n                                if(D[i][j]==2){\n//                                        if(i+2>y-1)P[i+1][j]+=P[i][j];\n                                        P[i+2][j]+=P[i][j];\n                                }\n                        }\n                }\n                for(int i=0;i<x;i++)ans+=P[y-1][i];\n                cout<<ans<<endl;\n        }\n}\n "
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n\nint main(){\n  int i,j,w,h,map[15][15],pos[15][15],n;\n  while(1){\n    scanf(\"%d %d\",&w,&h);\n    if(w==0&&h==0) break;\n    for(i=0;i<h;i++){\n      scanf(\"%d\",&(map[i][0]));\n      pos[i][0]=0;\n      for(j=1;j<w;j++){\n\tscanf(\" %d\",&(map[i][j]));\n\tpos[i][j]=0;\n      }\n    }\n    for(i=0;i<w;i++) if(map[0][i]==0) pos[0][i]=1;\n    for(i=1;i<h;i++){\n      for(j=0;j<w;j++){\n\tif(map[i][j]!=1&&map[i-1][j]!=2)pos[i][j]+=pos[i-1][j];\n\tif(map[i][j]==2)\n\t  if(i+2<h&&map[i+2][j]!=1) pos[i+2][j]+=pos[i][j];\n\t  else if(i+1<h) pos[i+1][j]+=pos[i][j];\n\tif(map[i][j]==0){\n\t  if((j-1>-1)&&(map[i-1][j-1]==0)) pos[i][j]+=pos[i-1][j-1];\n\t  if((j+1<w)&&(map[i-1][j+1]==0)) pos[i][j]+=pos[i-1][j+1];\n\t}\n      }\n    }\n    for(n=0,i=0;i<w;i++) n+=pos[h-1][i];\n    printf(\"%d\\n\",n);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "m[15][15],D[15][15];X,Y,x,y,d;main(){for(;scanf(\"%d%d\",&X,&Y),X;printf(\"%d\\n\",d)){for(y=0;y<Y;y++)for(x=X;x--;D[x][y]=d){scanf(\"%d\",m[x]+y);if(!y)d=*m[x]!=1;else{d=0;if(m[x][y]-1)d+=m[x][y-1]?0:D[x][y-1],d+=y<2||m[x][y-2]-2?0:D[x][y-2];if(!m[x][y])d+=x<1||m[x-1][y-1]?0:D[x-1][y-1],d+=x+2>X||m[x+1][y-1]?0:D[x+1][y-1];}}for(d=0;X--;d+=Y<2||m[X][Y-2]-2?0:D[X][Y-2])d+=D[X][Y-1];}exit(0);}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint i,j;\nint x,y;\nlong long int dp[1000][1000];\nint map[1000][1000];\nint main(void){\n\tscanf(\"%d %d\",&x,&y);\n\twhile(x!=0 && y!=0){\n\t\tfor(i=1;i<=17;i++){\n\t\t\tfor(j=1;j<=15;j++){\n\t\t\t\tdp[i][j]=0;\n\t\t\t\tmap[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=y;i++){\n\t\t\tfor(j=1;j<=x;j++){\n\t\t\t\tscanf(\"%d\",&map[i][j]);\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=x;i++){\n\t\t\tif(map[1][i]!=1){\n\t\t\t\tdp[1][i]=1;\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<y;i++){\n\t\t\tfor(j=1;j<=x;j++){\n\t\t\t\tif(dp[i][j]>0 && map[i][j]!=2){\n\t\t\t\t\tif(map[i+1][j-1]==0){\n\t\t\t\t\t\tif(j-1<0);\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tdp[i+1][j-1]+=dp[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(map[i+1][j]!=1 ){\n\t\t\t\t\t\tif(map[i+1][j]==0){\n\t\t\t\t\t\t\tdp[i+1][j]+=dp[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tint temp;\n\t\t\t\t\t\t\ttemp=i+1;\n\t\t\t\t\t\t\twhile(map[temp][j]==2){\n\t\t\t\t\t\t\t\ttemp+=2;\n\t\t\t\t\t\t\t\tdp[temp][j]+=dp[i][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(map[i+1][j+1]==0){\n\t\t\t\t\t\tif(j+1>x);\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tdp[i+1][j+1]+=dp[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong long int cnt=0;\n\t\tfor(i=0;i<=2;i++){\n\t\t\tfor(j=1;j<=x;j++){\n\t\t\t\tcnt+=dp[y+i][j];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",cnt);\n\t\tscanf(\"%d %d\",&x,&y);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint main(void)\n{\n\tint ans, num[15][15];\n\tint w, h;\n\tint i, j;\n\tint map[15][15];\n\t\n\twhile (1){\n\t\tscanf(\"%d%d\", &w, &h);\n\t\t\n\t\tif (w + h == 0){\n\t\t\tbreak;\n\t\t}\n\t\tmemset(map, -1, sizeof(map));\n\t\tfor (i = 0; i < h; i++){\n\t\t\tfor (j = 0; j < w; j++){\n\t\t\t\tscanf(\"%d\", &map[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tmemset(num, 0, sizeof(num));\n\t\tfor (i = 0; i < w; i++){\n\t\t\tif (map[0][i] != 1){\n\t\t\t\tnum[0][i] = 1;\n\t\t\t}\n\t\t}\n\t\tfor (i = 1; i < h; i++){\n\t\t\tfor (j = 0; j < w; j++){\n\t\t\t\tif (j > 0 && map[i - 1][j - 1] == 0 && map[i][j] != 2){\n\t\t\t\t\tnum[i][j] += num[i - 1][j - 1];\n\t\t\t\t}\n\t\t\t\tif (map[i - 1][j] == 0){\n\t\t\t\t\tnum[i][j] += num[i - 1][j];\n\t\t\t\t}\n\t\t\t\tif (j < w - 1 && map[i - 1][j + 1] == 0 && map[i][j] != 2){\n\t\t\t\t\tnum[i][j] += num[i - 1][j + 1];\n\t\t\t\t}\n\t\t\t\tif (i > 1 && map[i - 2][j] == 2){\n\t\t\t\t\tnum[i][j] += num[i - 2][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = 0;\n\t\tfor (j = 0; j < w; j++){\n\t\t\tif (num[h - 1][j] != 1){\n\t\t\t\tans += num[h - 1][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint main(){\n  while(1){\n    int dp[17][17], cond[17][17], x, y, i, j;\n    int ans = 0;\n    scanf(\"%d%d\", &x, &y);\n    if(x == 0 && y == 0)return 0;\n    memset(dp, 0, sizeof(dp));\n    for(i = 0;i < y;i++){\n      for(j = 1;j <= x;j++){\n\tscanf(\"%d\", &cond[i][j]);\n      }\n    }\n    for(i = 0;i < y;i++){\n      for(j = 1;j <= x;j++){\n\tif(i == 0)\n\t  dp[i][j] = !cond[i][j];\n\tif(cond[i][j] == 2)\n\t  dp[i + 2][j] += dp[i][j];\n\tif(cond[i][j] == 0){\n\t  if(cond[i + 1][j] != 1)\n\t    dp[i + 1][j] += dp[i][j];\n\t  if(cond[i + 1][j - 1] == 0)\n\t    dp[i + 1][j - 1] += dp[i][j];\n\t  if(cond[i + 1][j + 1] == 0)\n\t    dp[i + 1][j + 1] += dp[i][j];\n\t}\t\n      }\n    }\n    for(j = 1;j <= x;j++){\n      if(cond[y - 1][j] != 1)\n\tans += dp[y - 1][j];\n      if(cond[y - 2][j] == 2)\n\tans += dp[y - 2][j];\n    }\n   \n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C",
    "code": "main(){ans, num[15][15], w, h, i, j, map[15][15];while (1){scanf(\"%d%d\", &w, &h);if (w + h == 0){break;}memset(map, -1, sizeof(map));for (i = 0; i < h; i++){for (j = 0; j < w; j++){scanf(\"%d\", &map[i][j]);}}memset(num, 0, sizeof(num));for (i = 0; i < w; i++){if (map[0][i] != 1){num[0][i] = 1;}}for (i = 1; i < h; i++){for (j = 0; j < w; j++){if (j > 0 && map[i - 1][j - 1] == 0 && map[i][j] != 2){num[i][j] += num[i - 1][j - 1];}if (map[i - 1][j] == 0){num[i][j] += num[i - 1][j];}if (j < w - 1 && map[i - 1][j + 1] == 0 && map[i][j] != 2){num[i][j] += num[i - 1][j + 1];}if (i > 1 && map[i - 2][j] == 2){num[i][j] += num[i - 2][j];}}}ans = 0;for (j = 0; j < w; j++){if (map[h - 1][j] != 1){ans += num[h - 1][j];}if (h > 1 && map[h - 2][j] == 2){ans += num[h - 2][j];}}printf(\"%d\\n\", ans);}return (0);}"
  },
  {
    "language": "C",
    "code": "// Aizu Vol-2 0203: A New Plan of Aizu Ski Resort\n// 2017.8.24 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX 15\nchar map[MAX+5][MAX+5];\nint p[MAX+5][MAX+5];\nint X, Y;\n\nint main()\n{\n\tint i, k, x, y, x2, y2;\n\tint m[2] = { -1,1 };\n\n\twhile (scanf(\"%d%d\", &X, &Y) && X) {\n\t\tmemset(map, 0, sizeof(map)), memset(p, 0, sizeof(p));\n\t\tfor (y = 1; y <= Y; y++) for (x = 1; x <= X; x++) scanf(\"%d\", &k), map[y][x] = k;\n\t\tfor (x = 1; x <= X; x++) p[1][x] = (map[1][x] != 1);\n\t\tfor (y = 1; y < Y; y++) for (x = 1; x <= X; x++) {\n\t\t\tif (map[y][x] == 1) continue;\n\t\t\tif (map[y][x] == 2) { if (map[y+2][x] != 1) p[y+2][x] += p[y][x]; continue; }\n\t\t\tfor (i = 0; i < 2; i++) {\n\t\t\t\tx2 = x + m[i], y2 = y + 1;\n\t\t\t\tif (x2 > 0 && x2 <= X && map[y2][x2] == 0) p[y2][x2] += p[y][x];\n\t\t\t}\n\t\t\ty2 = y + 1; if (map[y2][x] != 1) p[y2][x] += p[y][x];\n\t\t}\n\t\tfor (k = 0, y = Y; y <= Y+1; y++) for (x = 1; x <= X; x++) k += p[y][x];\n\t\tprintf(\"%d\\n\", k);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "M[15][15],C[15][15],X,Y;\nint D(x,y){\n\tif(y>=Y-1)return 1;\n\tif(M[x][y])return M[x][y];\n\tif(C[x][y]==2)return M[x][y]=y+2>=Y||C[x][y+2]!=-1?D(x,y+2):0;\n\tint s=0;\n\tif(0<x&&C[x-1][y+1]==0)s+=D(x-1,y+1);\n\tif(C[x][y+1]!=1)s+=D(x,y+1);\n\tif(x<X-1&&C[x+1][y+1]==0)s+=D(x+1,y+1);\n\treturn M[x][y]=s;\n}\nmain(i,j,s){for(;scanf(\"%d%d\",&X,&Y),X;printf(\"%d\\n\",j)){\nmemset(M,0,sizeof(M));\nfor(j=0;j<Y;j++)for(i=0;i<X;i++)scanf(\"%d\",C[i]+j);\nfor(j=i=0;i<X;i++)if(C[i][0]!=1)j+=D(i,0);\n}exit(0);}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A0203\nA New Plan of Aizu Ski Resort\n*/\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\nint X,Y;\nchar ski[15][16];\nlong int ways[16][16];\n#define DEBUG 0\ndisplay_ski()\n{\n  int i,j;\n\n  for(i=0;i<=Y;i++)\n    {\n      for(j=0;j<X;j++)\n\tprintf(\"%ld:\",ways[i][j]);\n      printf(\"\\n\");\n    }\n}\ndisplay_cource()\n{\n  int i,j;\n\n  for(i=0;i<=Y;i++)\n    {\n      for(j=0;j<X;j++)\n\tprintf(\"%c:\",ski[i][j]);\n      printf(\"\\n\");\n    }\n}\nmain()\n{\n  int i,j;\n  long int sum;\n  char buffer[50];\n  char *p;\n\n  while(EOF != scanf(\" %d %d \",&X,&Y) && (X||Y))\n    {\n      for(i=0;i<Y;i++)\n\t{\n\t  fgets(buffer,50,stdin);\n\t  for(j=0;j<X;j++)\n\t  {  \n\t    ski[i][j]=buffer[j*2];\n\t  }\n\t  for(j=0;j<16;j++)\n\t    ways[i][j]=0;\n\t}\n\n\n      for(j=0;j<X;j++)\n\t{\n\t  ways[0][j] = (ski[0][j]=='0')?1:0;\n\t}\n      for(i=1;i<Y;i++)\n\tfor(j=0;j<X;j++)\n\t  {\n\t    if(ski[i][j] == '1')\n\t      ways[i][j] = 0;\n\t    if(ski[i][j] == '2')  \n\t      { \n\t\tways[i][j]=0;\n\t\tif (ski[i-1][j]=='0')\n\t\t  ways[i][j]+=ways[i-1][j];\n\t\tif( ski[i-2][j]=='2')\n\t\t  ways[i][j]+=ways[i-2][j];\n\t      }\n\t    else if(ski[i][j] == '0')\n\t      { \n\t\tways[i][j]=0;\n\t\tif(ski[i-1][j]=='0')\n\t\t  ways[i][j] +=ways[i-1][j];\n\t\tif(j>0&&ski[i-1][j-1]=='0')\n\t\t  ways[i][j] += ways[i-1][j-1];\n\t\tif(j<X&&ski[i-1][j+1]=='0')\n\t\t  ways[i][j] += ways[i-1][j+1];\n\t\tif(ski[i-2][j]=='2')\n\t\t  ways[i][j] += ways[i-2][j];\n\t      }\n\t  }\n\n      for(j=0;j<X;j++)\n\tif(ski[Y-2][j] == '2')\n\t  ways[Y][j] = ways[Y-2][j];\n\telse\n\t  ways[Y][j] = 0;\n      sum=0;\n      for(j=0;j<=X;j++)\n\t{\n\t  sum += ways[Y-1][j];\n\t  sum += ways[Y][j];\n\t}\n      /*display_ski();*/\n      printf(\"%ld\\n\",sum);\n    }\nreturn(0);\n}\n "
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint main(){\n  while(1){\n    int dp[17][17], cond[17][17], x, y, i, j, c, ans = 0;\n    scanf(\"%d%d\", &x, &y);\n    if(x == 0 && y == 0)return 0;\n    memset(dp, 0, sizeof(cond));\n    for(i = 0;i < y;i++){\n      cond[i][0] = 1;\n      for(j = 1;j <= x;j++){\n\tscanf(\"%d\", &cond[i][j]);\n      }\n      cond[i][x + 1] = 1;\n    }\n    for(i = 0;i < y - 1;i++){\n      for(j = 1;j <= x;j++){\n\tif(i == 0)\n\t  dp[i][j] = !cond[i][j];\n\tif(cond[i][j] == 2)\n\t  dp[i + 2][j] += dp[i][j];\n\tif(cond[i][j] == 0){\n\t  dp[i + 1][j] += dp[i][j];\n\t  if(cond[i + 1][j - 1] != 2)\n\t      dp[i + 1][j - 1] += dp[i][j];\n\t  if(cond[i + 1][j + 1] != 2)\n\t    dp[i + 1][j + 1] += dp[i][j];\n\t}\n\t\n      }\n    }\n    for(i = y - 1;i <= y;i++){\n      for(j = 1;j <= x;j++){\n\tif(cond[i][j] != 1)\n\t  ans += dp[i][j];\t\n      }\n    }\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nunsigned int c;\nint n,m;\nint X[3]={-1,0,1};\nvoid f(int d[15][17],int x,int y){\n  if(y+1>=m)c++;\n  else{\n    if(d[y][x]==0){\n      int i;\n      for(i=0;i<3;i++){\n\ty++;\n\tx+=X[i];\n\tif(0<=x&&x<n){\n\t  if(d[y][x]==0||(i==1&&d[y][x]==2)){\n\t    f(d,x,y);\n\t  }\n\t}\n\tx-=X[i];\n\ty--;\n      }\n    }\n    else if(d[y+2][x]!=1){\n\tf(d,x,y+2);\n    }\n  }\n}\n\t\nint main(){\n  int i,j;\n  while(1){\n    scanf(\"%d %d\",&n,&m);\n    if(n==0&&m==0)break;\n    int d[15][17]={{0}};\n    for(i=0;i<m;i++){\n      for(j=0;j<n;j++){\n\tscanf(\"%d\",&d[i][j]);\n      }\n    }\n    c=0;\n    for(i=0;i<n;i++){\n      if(d[0][i]==0){\n\tf(d,i,0);\n      }\n    }\n    printf(\"%d\\n\",c);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint x,y,dp[20][15],m[20][15],i,j,k,t,r;\nint main()\n{\n\tfor(;scanf(\"%d%d\",&x,&y),x;)\n\t{\n\t\tmemset(dp,0,sizeof(dp));\n\t\tmemset(m,0,sizeof(m));\n\t\tfor(i=0;i<y;i++)\n\t\t\tfor(j=0;j<x;j++)\n\t\t\t\tscanf(\"%d\",&m[i][j]);\n\t\tfor(i=0;i<x;i++)\n\t\t\tif(!m[0][i])\n\t\t\t\tdp[0][i]=1;\n\t\tfor(i=0;i<y-1;i++)\n\t\t\tfor(j=0;j<x;j++)\n\t\t\t{\n\t\t\t\tif(m[i][j]==0)\n\t\t\t\t{\n\t\t\t\t\tif(m[i+1][j]!=1)\n\t\t\t\t\t\tdp[i+1][j]+=dp[i][j];\n\t\t\t\t\tif(j>0&&m[i+1][j-1]==0)\n\t\t\t\t\t\tdp[i+1][j-1]+=dp[i][j];\n\t\t\t\t\tif(j<x-1&&m[i+1][j+1]==0)\n\t\t\t\t\t\tdp[i+1][j+1]+=dp[i][j];\n\t\t\t\t}\n\t\t\t\telse if(m[i][j]==1)\n\t\t\t\t\tdp[i][j]=0;\n\t\t\t\telse\n\t\t\t\t\tif(m[i+2][j]!=1)\n\t\t\t\t\t\tdp[i+2][j]+=dp[i][j];\n\t\t\t}\n\t\tfor(i=r=0;i<x;i++)\n\t\t\tr+=dp[y-1][i]+dp[y][i]+dp[y+1][i];\n\t\tprintf(\"%d\\n\",r);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A0203\nA New Plan of Aizu Ski Resort\n*/\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\nint X,Y;\nchar ski[15][16];\nlong int ways[16][16];\n#define DEBUG 0\ndisplay_ski()\n{\n  int i,j;\n\n  for(i=0;i<=Y;i++)\n    {\n      for(j=0;j<X;j++)\n\tprintf(\"%ld:\",ways[i][j]);\n      printf(\"\\n\");\n    }\n}\ndisplay_cource()\n{\n  int i,j;\n\n  for(i=0;i<=Y;i++)\n    {\n      for(j=0;j<X;j++)\n\tprintf(\"%c:\",ski[i][j]);\n      printf(\"\\n\");\n    }\n}\nmain()\n{\n  int i,j;\n  long int sum;\n  char buffer[50];\n  char *p;\n\n  while(EOF != scanf(\" %d %d \",&X,&Y) && (X||Y))\n    {\n      for(i=0;i<16;i++)\n\tfor(j=0;j<16;j++)\n\t  ways[i][j]=0;\n\n      for(i=0;i<Y;i++)\n\t{\n\t  fgets(buffer,50,stdin);\n\t  for(j=0;j<X;j++)\n\t  {  \n\t    ski[i][j]=buffer[j*2];\n\t  }\n\t}\n\n\n      for(j=0;j<X;j++)\n\t{\n\t  ways[0][j] = (ski[0][j]=='0')?1:0;\n\t}\n      for(i=1;i<Y;i++)\n\tfor(j=0;j<X;j++)\n\t  {\n\t    if(ski[i][j] == '1')\n\t      ways[i][j] = 0;\n\t    if(ski[i][j] == '2')  \n\t      { \n\t\tways[i][j]=0;\n\t\tif (ski[i-1][j]=='0')\n\t\t  ways[i][j]+=ways[i-1][j];\n\t\tif( ski[i-2][j]=='2')\n\t\t  ways[i][j]+=ways[i-2][j];\n\t      }\n\t    else if(ski[i][j] == '0')\n\t      { \n\t\tways[i][j]=0;\n\t\tif(ski[i-1][j]=='0')\n\t\t  ways[i][j] +=ways[i-1][j];\n\t\tif(j>0&&ski[i-1][j-1]=='0')\n\t\t  ways[i][j] += ways[i-1][j-1];\n\t\tif(j<X&&ski[i-1][j+1]=='0')\n\t\t  ways[i][j] += ways[i-1][j+1];\n\t\tif(ski[i-2][j]=='2')\n\t\t  ways[i][j] += ways[i-2][j];\n\t      }\n\t  }\n\n      for(j=0;j<X;j++)\n\tif(ski[Y-2][j] == '2')\n\t  ways[Y][j] = ways[Y-2][j];\n\telse\n\t  ways[Y][j] = 0;\n      sum=0;\n      for(j=0;j<=X;j++)\n\t{\n\t  sum += ways[Y-1][j];\n\t  sum += ways[Y][j];\n\t}\n      /*display_ski();*/\n      printf(\"%ld\\n\",sum); \n    }\nreturn(0);\n}\n "
  },
  {
    "language": "C",
    "code": "// Aizu Vol-2 0203: A New Plan of Aizu Ski Resort\n// 2017.8.24 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX 15\nchar map[MAX+3][MAX+3];\nint p[MAX+3][MAX+3];\nint X, Y;\n\nint main()\n{\n\tint i, k, x, y, x2, y2;\n\tint m[2] = { -1,1 };\n\n\twhile (scanf(\"%d%d\", &X, &Y) && X) {\n\t\tfor (y = 1; y <= Y; y++) for (x = 1; x <= X; x++) scanf(\"%d\", &k), map[y][x] = k;\n\t\tmemset(p, 0, sizeof(p));\n\t\tfor (x = 1; x <= X; x++) p[1][x] = (map[1][x] == 0);\n\t\tfor (y = 1; y < Y; y++) for (x = 1; x <= X; x++) {\n\t\t\tif (map[y][x] == 1) continue;\n\t\t\tif (map[y][x] == 2) { if (p[y+2][x] != 1) p[y+2][x] += p[y][x]; continue; }\n\t\t\tfor (i = 0; i < 2; i++) {\n\t\t\t\tx2 = x + m[i], y2 = y + 1;\n\t\t\t\tif (x2 > 0 && x2 <= X && p[y][x] > 0 && map[y2][x2] == 0) p[y2][x2] += p[y][x];\n\t\t\t}\n\t\t\ty2 = y + 1; if (p[y][x] > 0 && map[y2][x] != 1) p[y2][x] += p[y][x];\n\t\t}\n\t\tfor (k = 0, y = Y; y <= Y+1; y++) for (x = 1; x <= X; x++) k += p[y][x];\n\t\tprintf(\"%d\\n\", k);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nvoid listen(char str[],int size);\nvoid listenSize(int *X,int *Y);\nvoid listenCourse(int **course,int X,int Y);\nvoid analyzeCourse(int **course,int X,int Y);\n\nint SkiResort();\n\nint main()\n{\n\twhile(SkiResort());\n\treturn 0;\n}\n\nint SkiResort()\n{\n\tint X,Y;\n\tlistenSize(&X,&Y);\n\tif(X==0 && Y==0)\n\t{\n\t\treturn 0;\n\t}\n\tint course[X][Y];\n\tint *pCourse[X];\n\tint i;\n\tfor(i=0;i<X;i++)\n\t{\n\t\tpCourse[i]=course[i];\n\t}\n\tlistenCourse(pCourse,X,Y);\n\tanalyzeCourse(pCourse,X,Y);\n\t\n\treturn 1;\n}\n\nvoid listen(char str[],int size)\n{\n\tfor(;1;)\n\t{\n\t\tfgets(str,size,stdin);\n\t\tif(strcmp(str,\"\\n\")!=0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid listenSize(int *X,int *Y)\n{\n\tchar str[64];\n\tlisten(str,sizeof(str));\n\t\n\t*X=atoi(strtok(str,\" \"));\n\t*Y=atoi(strtok(NULL,\" \"));\n}\n\t\n\nvoid listenCourse(int **course,int X,int Y)\n{\n\tchar str[1024];\n\tint i,j;\n\tfor(j=0;j<Y;j++)\n\t{\n\t\tlisten(str,sizeof(str));\n\t\tcourse[0][j]=atoi(strtok(str,\" \"));\n\t\tfor(i=1;i<X;i++)\n\t\t{\n\t\t\tcourse[i][j]=atoi(strtok(NULL,\" \"));\n\t\t}\n\t}\n}\n\nvoid analyzeCourse(int **course,int X,int Y)\n{\n\tint i,j,k,m;\n\tint pattern[X][Y+2];\n\tfor(i=0;i<X;i++)\n\t{\n\t\tfor(j=0;j<Y+2;j++)\n\t\t{\n\t\t\tpattern[i][j]=0;\n\t\t}\n\t}\n\t\n\tfor(i=0;i<X;i++)\n\t{\n\t\tif(course[i][0]==0)\n\t\t{\n\t\t\tpattern[i][0]=1;\n\t\t}\n\t}\n\tfor(j=0;j<Y-1;j++)\n\t{\n\t\tfor(i=0;i<X;i++)\n\t\t{\n\t\t\tfor(k=i-1;k<=i+1;k++)\n\t\t\t{\n\t\t\t\tif(k<0 || X<=k)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tswitch(course[k][j+1])\n\t\t\t\t{\n\t\t\t\t  case 0:\n\t\t\t\t\tpattern[k][j+1]+=pattern[i][j];\n\t\t\t\t\tbreak;\n\t\t\t\t  case 1:\n\t\t\t\t\tpattern[k][j+1]=0;\n\t\t\t\t\tbreak;\n\t\t\t\t  default:\n\t\t\t\t\tif(k==i)\n\t\t\t\t\t{\n\t\t\t\t\t\tm=0;\n\t\t\t\t\t\twhile(j+3+m<Y)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(course[k][j+3+m]==2)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tm+=2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpattern[k][j+3+m]+=pattern[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint sum=0;\n\tfor(i=0;i<X;i++)\n\t{\n\t\tfor(k=Y-1;k<=Y+1;k++)\n\t\t{\n\t\t\tsum+=pattern[i][k];\n\t\t}\n\t}\n\tprintf(\"%d\\n\",sum);\n}"
  },
  {
    "language": "C",
    "code": "// Aizu Vol-2 0203: A New Plan of Aizu Ski Resort\n// 2017.8.24 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX 15\nchar map[MAX+3][MAX+3];\nint p[MAX+3][MAX+3];\nint X, Y;\n\nint main()\n{\n\tint i, k, x, y, x2, y2;\n\tint m[2] = { -1,1 };\n\n\twhile (scanf(\"%d%d\", &X, &Y) && X) {\n\t\tfor (y = 1; y <= Y; y++) for (x = 1; x <= X; x++) scanf(\"%d\", &k), map[y][x] = k;\n\t\tmemset(p, 0, sizeof(p));\n\t\tfor (x = 1; x <= X; x++) p[1][x] = (map[1][x] != 1);\n\t\tfor (y = 1; y < Y; y++) for (x = 1; x <= X; x++) {\n\t\t\tif (map[y][x] == 1) continue;\n\t\t\tif (map[y][x] == 2) { if (p[y+2][x] != 1) p[y+2][x] += p[y][x]; continue; }\n\t\t\tfor (i = 0; i < 2; i++) {\n\t\t\t\tx2 = x + m[i], y2 = y + 1;\n\t\t\t\tif (x2 > 0 && x2 <= X && map[y2][x2] == 0) p[y2][x2] += p[y][x];\n\t\t\t}\n\t\t\ty2 = y + 1; if (map[y2][x] != 1) p[y2][x] += p[y][x];\n\t\t}\n\t\tfor (k = 0, y = Y; y <= Y+1; y++) for (x = 1; x <= X; x++) k += p[y][x];\n\t\tprintf(\"%d\\n\", k);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint main(){\n  while(1){\n    int dp[17][17], cond[17][17], x, y, i, j;\n    long long int ans = 0;\n    scanf(\"%d%d\", &x, &y);\n    if(x == 0 && y == 0)return 0;\n    memset(dp, 0, sizeof(dp));\n    for(i = 0;i < y;i++){\n      for(j = 1;j <= x;j++){\n\tscanf(\"%d\", &cond[i][j]);\n      }\n    }\n    for(i = 0;i < y - 1;i++){\n      for(j = 1;j <= x;j++){\n\tif(i == 0)\n\t  dp[i][j] = !cond[i][j];\n\tif(cond[i][j] == 2)\n\t  dp[i + 2][j] += dp[i][j];\n\tif(cond[i][j] == 0){\n\t  dp[i + 1][j] += dp[i][j];\n\t  if(cond[i + 1][j - 1] != 2)\n\t    dp[i + 1][j - 1] += dp[i][j];\n\t  if(cond[i + 1][j + 1] != 2)\n\t    dp[i + 1][j + 1] += dp[i][j];\n\t}\t\n      }\n    }\n    for(i = y - 1;i <= y;i++){\n      for(j = 1;j <= x;j++){\n\tif(cond[i][j] != 1)\n\t  ans += dp[i][j];\t\n      }\n    }\n    printf(\"%lld\\n\", ans);\n  }\n}"
  },
  {
    "language": "C",
    "code": "M[15][15],C[15][15],X,Y;\nint D(x,y){\n\tif(y>=Y-1)return 1;\n\tif(M[x][y])return M[x][y];\n\tif(C[x][y]==2)return M[x][y]=D(x,y+2);\n\tint s=0;\n\tif(0<x&&C[x-1][y+1]==0)s+=D(x-1,y+1);\n\tif(C[x][y+1]!=1)s+=D(x,y+1);\n\tif(x<X-1&&C[x+1][y+1]==0)s+=D(x+1,y+1);\n\treturn M[x][y]=s;\n}\nmain(i,j,s){for(;scanf(\"%d%d\",&X,&Y),X;printf(\"%d\\n\",j)){\nmemset(M,0,sizeof(M));\nfor(j=0;j<Y;j++)for(i=0;i<X;i++)scanf(\"%d\",C[i]+j);\nfor(j=i=0;i<X;i++)if(C[i][0]!=1)j+=D(i,0);\n}exit(0);}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define REP(i,n,m) for(i=n;i<m;i++)\n#define rep(i,n) REP(i,0,n)\n\nint main(void){\n\tint i,j;\n\tint w,h;\n\tint ans;\n\tint t[16][15],dp[16][15];\n\n\twhile(scanf(\"%d%d\",&w,&h) && (w||h)){\n\t\tmemset(dp,0,sizeof(dp));\n\t\tmemset(t,0,sizeof(t));\n\t\trep(i,w) if(t[0][i] == 0) dp[0][i] = 1;\n\n\t\trep(i,h) rep(j,w) scanf(\"%d\",&t[i][j]);\n\t\trep(i,h-1) rep(j,w) {\n\t\t\tint left = j-1;\n\t\t\tint center = j;\n\t\t\tint right = j+1;\n\n\t\t\tif(t[i][j] == 0){\n\t\t\t\tif(left >= 0){\n\t\t\t\t\tif(t[i+1][left] == 0) dp[i+1][left] += dp[i][j];\n\t\t\t\t}\n\t\t\t\tif(right < w){\n\t\t\t\t\tif(t[i+1][right] == 0) dp[i+1][right] += dp[i][j];\n\t\t\t\t}\n\t\t\t\tif(t[i+1][j] != 1) dp[i+1][j] += dp[i][j];\n\t\t\t}\n\t\t\telse if(t[i][j] == 2){\n\t\t\t\tif(t[i+2][j] != 1) dp[i+2][j] += dp[i][j];\n\t\t\t}\n\t\t}\n\n\t\tans = 0;\n\t\tREP(i,h-1,h+1) rep(j,w) ans += dp[i][j];\n\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint map[19][19],dp[19][19];\nint main(){\n\tint i,j,x,y;\n\tlong long int ans;\n\t\n\twhile(1){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif(x+y==0)break;\n\t\tmemset(dp,0,sizeof(dp));\n\t\tans=0;\n\t\tfor(i=1;i<=y;i++){\n\t\t\tfor(j=1;j<=x;j++){\n\t\t\t\tscanf(\"%d\",&map[i][j]);\n\t\t\t\tif(i==1 && map[1][j]==0)dp[1][j]=1;\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=y;i++){\n\t\t\tfor(j=1;j<=x;j++){\n\t\t\t\tif(map[i][j]==0){\n\t\t\t\t\tif(map[i+1][j]!=1)dp[i+1][j]+=dp[i][j];\n\t\t\t\t\tif(i<y){\n\t\t\t\t\t\tif(map[i+1][j-1]==0)dp[i+1][j-1]+=dp[i][j];\n\t\t\t\t\t\tif(map[i+1][j+1]==0)dp[i+1][j+1]+=dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(map[i][j]==2){\n\t\t\t\t\tdp[i+2][j]+=dp[i][j];\n\t\t\t\t}\n\t\t\t\t//printf(\"%2d \",dp[i][j]);\n\t\t\t}\n\t\t\t//printf(\"\\n\");\n\t\t}\n\t\tfor(j=1;j<=x;j++){\n\t\t\tans+=dp[y+1][j]+dp[y+2][j];\n\t\t\t//printf(\"%2d \",dp[y+1][j]);\n\t\t}\n\t\t//printf(\"\\n\");\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\tint w,h,xd[]={1,0,-1},p,u[20][20];\n\tvoid ret(int x,int y){\n\t\tint i,s=x;\n\t\tif(h-1<=y)\n\t\t\tp++;\n\t\telse if(u[y][x]==2)\n\t\t\tret(x,y+2);\n\t\telse if(u[y][x]==0){\n\t\t\ty++;\n\t\t\tfor(i=0;i<3;i++){\n\t\t\t\tx=s+xd[i];\n\t\t\t\tif(x>=0&&x<=w-1){\n\t\t\t\t\tif(u[y][x]==2&&i==1)\n\t\t\t\t\t\tret(x,y+2);\n\t\t\t\t\telse if(u[y][x]==0)\n\t\t\t\t\t\tret(x,y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint main(){\n\t\tint i,j,x,y;\n\t\twhile(scanf(\"%d %d\",&w,&h),w||h){\n\t\t\tp=0;\n\t\t\tfor(i=0;i<h;i++){\n\t\t\t\tfor(j=0;j<w-1;j++)\n\t\t\t\tscanf(\"%d \",&u[i][j]);\n\t\t\t\tscanf(\"%d\",&u[i][w-1]);\n\t\t\t}\n\t\t\tfor(i=0;i<w;i++){\n\t\t\t\tif(u[0][i]==0){\n\t\t\t\t\tx=i;\n\t\t\t\t\ty=0;\n\t\t\t\t\tret(x,y);\n\t\t\t\t}\n\t\t\t\telse if(u[0][i]==2){\n\t\t\t\t\tx=i;\n\t\t\t\t\ty=2;\n\t\t\t\t\tret(x,y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",p);\n\t\t}\n\t\treturn 0;\n\t}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint main(){\n  while(1){\n    int dp[17][17], cond[17][17], x, y, i, j;\n    int ans = 0;\n    scanf(\"%d%d\", &x, &y);\n    if(x == 0 && y == 0)return 0;\n    memset(dp, 0, sizeof(dp));\n    for(i = 0;i < y;i++){\n      for(j = 1;j <= x;j++){\n\tscanf(\"%d\", &cond[i][j]);\n      }\n    }\n    for(i = 0;i < y - 1;i++){\n      for(j = 1;j <= x;j++){\n\tif(i == 0)\n\t  dp[i][j] = !cond[i][j];\n\tif(cond[i][j] == 2)\n\t  dp[i + 2][j] += dp[i][j];\n\tif(cond[i][j] == 0){\n\t  if(cond[i + 1][j] != 1)\n\t    dp[i + 1][j] += dp[i][j];\n\t  if(cond[i + 1][j - 1] == 0)\n\t    dp[i + 1][j - 1] += dp[i][j];\n\t  if(cond[i + 1][j + 1] == 0)\n\t    dp[i + 1][j + 1] += dp[i][j];\n\t}\t\n      }\n    }\n    for(i = y - 1;i <= y;i++){\n      for(j = 1;j <= x;j++){\n\tif(cond[i][j] != 1)\n\t  ans += dp[i][j];\t\n      }\n    }\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint pos[16][17];\n\nint main(){\n  int i,j,w,h,map[15][15],n;\n\n  while(1){\n    scanf(\"%d %d\",&w,&h);\n    if(w==0&&h==0) break;\n    for(i=0;i<h;i++){\n      scanf(\"%d\",&(map[i][0]));\n      pos[i][w]=pos[i+1][w]=0;\n      for(j=1;j<w;j++){\n\tscanf(\" %d\",&(map[i][j]));\n\tpos[i][j]=pos[i+1][j]=0;\n      }\n    }\n    for(pos[0][0]=0,pos[0][w+1]=0,i=1;i<w+1;i++)\n      if(map[0][i-1]==0) pos[0][i]=1;\n    for(i=1;i<h;i++){\n      for(j=0;j<w;j++){\n\tif(map[i][j]!=1&&map[i-1][j]!=2) pos[i][j+1]+=pos[i-1][j+1];\n\tif(map[i][j]==2)pos[i+2][j+1]+=pos[i][j+1];\n\tif(map[i][j]==0){\n\t  if(i-1>-1&&map[i-1][j-1]==0) pos[i][j+1]+=pos[i-1][j];\n\t  if(j+1<w&&map[i-1][j+1]==0) pos[i][j+1]+=pos[i-1][j+2];\n\t}\n      }\n    }\n    for(n=0,i=1;i<w+1;i++) n+=pos[h-1][i]+pos[h][i];\n    printf(\"%d\\n\",n);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(void){\n\tint f[16][16],d[16][16],i,j,c,x,y;\n\tfor(;scanf(\"%d%d\",&x,&y),x;){\n\t\tfor(i=0;i<y;*d[i]=d[i][x+1]=0,*f[i]=f[i][x+1]=1,i++)\n\t\t\tfor(j=1;j<=x;j++)\n\t\t\t\tscanf(\"%d\",f[i]+j);\n\t\tfor(j=1;j<=x;j++)\n\t\t\td[y][j]=1,d[y-1][j]=f[y-1][j]!=1;\n\t\tfor(i=y-1;i--;)\n\t\t\tfor(j=1;j<=x;d[i][j++]=c)\n\t\t\t\tswitch(f[i][j]){\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tc=d[i+1][j];\n\t\t\t\t\t\tf[i+1][j-1]-2?c+=d[i+1][j-1]:0;\n\t\t\t\t\t\tf[i+1][j+1]-2?c+=d[i+1][j+1]:0;\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tc=0;\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tc=d[i+2][j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\tc=0;\n\t\tfor(j=1;j<=x;j++)c+=d[0][j];\n\t\tprintf(\"%d\\n\",c);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint main(){\n  while(1){\n    int dp[17][17], cond[17][17], x, y, i, j;\n    int ans = 0;\n    scanf(\"%d%d\", &x, &y);\n    if(x == 0 && y == 0)return 0;\n    memset(dp, 0, sizeof(dp));\n    memset(cond, 0, sizeof(cond));\n    for(i = 0;i < y;i++){\n      for(j = 1;j <= x;j++){\n\tscanf(\"%d\", &cond[i][j]);\n      }\n    }\n    for(i = 0;i < y - 1;i++){\n      for(j = 1;j <= x;j++){\n\tif(i == 0)\n\t  dp[i][j] = !cond[i][j];\n\tif(cond[i][j] == 2)\n\t  dp[i + 2][j] += dp[i][j];\n\tif(cond[i][j] == 0){\n\t  dp[i + 1][j] += dp[i][j];\n\t  if(cond[i + 1][j - 1] != 2)\n\t    dp[i + 1][j - 1] += dp[i][j];\n\t  if(cond[i + 1][j + 1] != 2)\n\t    dp[i + 1][j + 1] += dp[i][j];\n\t}\t\n      }\n    }\n    for(i = y - 1;i <= y;i++){\n      for(j = 1;j <= x;j++){\n\tif(cond[i][j] != 1)\n\t  ans += dp[i][j];\t\n      }\n    }\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint main(){\n  while(1){\n    int dp[17][17], cond[17][17], x, y, i, j;\n    int ans = 0;\n    scanf(\"%d%d\", &x, &y);\n    if(x == 0 && y == 0)return 0;\n    memset(dp, 0, sizeof(dp));\n    for(i = 0;i < y;i++){\n      for(j = 1;j <= x;j++){\n\tscanf(\"%d\", &cond[i][j]);\n      }\n    }\n    for(i = 0;i < y - 1;i++){\n      for(j = 1;j <= x;j++){\n\tif(i == 0)\n\t  dp[i][j] = !cond[i][j];\n\tif(cond[i][j] == 2)\n\t  dp[i + 2][j] += dp[i][j];\n\tif(cond[i][j] == 0){\n\t  if(cond[i + 1][j] != 1)\n\t    dp[i + 1][j] += dp[i][j];\n\t  if(cond[i + 1][j - 1] == 0)\n\t    dp[i + 1][j - 1] += dp[i][j];\n\t  if(cond[i + 1][j + 1] == 0)\n\t    dp[i + 1][j + 1] += dp[i][j];\n\t}\t\n      }\n    }\n    for(j = 1;j <= x;j++){\n      if(cond[y - 1][j] != 1)\n\tans += dp[y - 1][j];\n      if(cond[y - 2][j] == 2)\n\tans += dp[y - 2][j];\n    }\n   \n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define REP(i,n,m) for(i=n;i<m;i++)\n#define rep(i,n) REP(i,0,n)\n\nint main(void){\n\tint i,j;\n\tint w,h;\n\tint left,right,ans;\n\tint t[17][17],dp[17][17];\n\n\twhile(scanf(\"%d%d\",&w,&h) && (w||h)){\n\t\trep(i,17) rep(j,17) t[i][j] = dp[i][j] = 0;\n\t\trep(i,w) if(t[0][i] != 1) dp[0][i] = 1;\n\n\t\trep(i,h) rep(j,w) scanf(\"%d\",&t[i][j]);\n\n\t\trep(i,h) rep(j,w) {\n\t\t\tleft = j-1;\n\t\t\tright = j+1;\n\n\t\t\tif(t[i][j] == 0){\n\t\t\t\tif(i == h - 1){\n\t\t\t\t\tdp[i+1][j] += dp[i][j];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(left >= 0 && t[i+1][left] == 0){\n\t\t\t\t\t\tdp[i+1][left] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tif(right < w && t[i+1][right] == 0){\n\t\t\t\t\t\tdp[i+1][right] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tif(t[i+1][j] != 1){\n\t\t\t\t\t\tdp[i+1][j] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(t[i][j] == 2 && t[i+2][j] != 1){\n\t\t\t\tdp[i+2][j] += dp[i][j];\n\t\t\t}\n\t\t}\n\n\t\tans = 0;\n\t\trep(i,w) ans += dp[h+1][i] + dp[h][i];\n\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint memo[32][32];\nint map[32][32];\nint w, h;\n\nint dfs(int x, int y, int px){\n\tint ny = y + 1;\n\n\tif (x < 0 || x >= w) return (0);\n\tif (y >= h) return (1);\n\tif (memo[y][x] != -1) return (memo[y][x]);\n\n\tif (y == h - 1 && map[y][x] == 0) return (memo[y][x] = 1);\n\n\tswitch (map[y][x]){\n\t  case 0: return (memo[y][x] = dfs(x, ny, x) + dfs(x + 1, ny, x) + dfs(x - 1, ny, x));\n\t  case 1: return (memo[y][x] = 0);\n\t  case 2: return (x == px ? dfs(x, ny + 1, x) : 0);\n\t  default:fprintf(stderr, \"%d is invalid value\\n\", map[y][x]);\n\t}\n}\n\nint main(void)\n{\n\twhile (scanf(\"%d %d\", &w, &h), w){\n\t\tint ans = 0;\n\t\tint i, j;\n\n\t\tfor (i = 0; i < h; i++){\n\t\t\tfor (j = 0; j < w; j++){\n\t\t\t\tscanf(\"%d\", map[i] + j);\n\t\t\t}\n\t\t}\n\n\t\tmemset(memo, -1, sizeof(memo));\n\t\tfor (i = 0; i < w; i++){\n\t\t\tans += dfs(i, 0, i);\n\t\t}\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\treturn (0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint main(){\n\tint x,y,m[20][20],d[20][20],i,j,ans;\n\tFILE *fp;\n\t//fp=fopen(\"test.txt\",\"r\");\n\tfp=stdin;\n\twhile(1){\n\t\tfscanf(fp,\"%d%d\",&x,&y);\n\t\tif(x==0 && y==0)break;\n\t\tmemset(d,0,sizeof(d));\n\t\tmemset(m,0,sizeof(m));\n\t\tfor(i=1;i<=y;i++){\n\t\t\tfor(j=1;j<=x;j++){\n\t\t\t\tfscanf(fp,\"%d\",&m[i][j]);\n\t\t\t\tif(i==1 && m[i][j]!=1)d[i][j]=1;\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=y;i++){\n\t\t\tfor(j=1;j<=x;j++){\n\t\t\t\tif(m[i][j]==0){\n\t\t\t\t\td[i][j]+=d[i-1][j-1]+d[i-1][j]+d[i-1][j+1];\n\t\t\t\t}else if(m[i][j]==1){\n\t\t\t\t\td[i][j]=0;\n\t\t\t\t}else if(m[i][j]==2){\n\t\t\t\t\td[i+2][j]+=d[i-1][j]+d[i][j];\n\t\t\t\t\td[i][j]=0;\n\t\t\t\t}\n\t\t\t\t//printf(\"%d%s\",d[i][j],(j==x)?\"\\n\":\" \");\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=x;i++){\n\t\t\td[y+1][i]+=d[y][i];\n\t\t\t//printf(\"%d%s\",d[y+1][i],(i==x)?\"\\n\":\" \");\n\t\t}\n\t\tans=0;\n\t\tfor(i=1;i<=x;i++)ans+=d[y+1][i]/*+d[y][i]*/;\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint x,y,dp[20][15],m[15][15],i,j,k,t,r;\nint main()\n{\n\tfor(;scanf(\"%d%d\",&x,&y),x;)\n\t{\n\t\tmemset(dp,0,sizeof(dp));\n\t\tfor(i=0;i<y;i++)\n\t\t\tfor(j=0;j<x;j++)\n\t\t\t\tscanf(\"%d\",&m[i][j]);\n\t\tfor(i=0;i<x;i++)\n\t\t\tif(!m[0][i])\n\t\t\t\tdp[0][i]=1;\n\t\tfor(i=0;i<y-1;i++)\n\t\t\tfor(j=0;j<x;j++)\n\t\t\t{\n\t\t\t\tif(m[i][j]==0)\n\t\t\t\t{\n\t\t\t\t\tdp[i+1][j]+=dp[i][j];\n\t\t\t\t\tif(j>0&&m[i+1][j-1]==0)\n\t\t\t\t\t\tdp[i+1][j-1]+=dp[i][j];\n\t\t\t\t\tif(j<y-1&&m[i+1][j+1]==0)\n\t\t\t\t\t\tdp[i+1][j+1]+=dp[i][j];\n\t\t\t\t}\n\t\t\t\telse if(m[i][j]==1)\n\t\t\t\t\tdp[i][j]=0;\n\t\t\t\telse\n\t\t\t\t\tdp[i+2][j]+=dp[i][j];\n\t\t\t}\n\t\tfor(i=r=0;i<x;i++)\n\t\t\tr+=dp[y-1][i]+dp[y][i]+dp[y+1][i];\n\t\tprintf(\"%d\\n\",r);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define REP(i,n,m) for(i=n;i<m;i++)\n#define rep(i,n) REP(i,0,n)\n\nint main(void){\n\tint i,j;\n\tint w,h;\n\tint left,right,ans;\n\tint t[17][17],dp[17][17];\n\n\twhile(scanf(\"%d%d\",&w,&h) && (w||h)){\n\t\trep(i,17) rep(j,17) t[i][j] = dp[i][j] = 0;\n\t\trep(i,w) if(t[0][i] == 0) dp[0][i] = 1;\n\n\t\trep(i,h) rep(j,w) scanf(\"%d\",&t[i][j]);\n\n\t\trep(i,h-1) rep(j,w) {\n\t\t\tleft = j-1;\n\t\t\tright = j+1;\n\n\t\t\tif(t[i][j] == 0){\n\t\t\t\tif(left >= 0 && t[i+1][left] == 0){\n\t\t\t\t\tdp[i+1][left] += dp[i][j];\n\t\t\t\t}\n\t\t\t\tif(right < w && t[i+1][right] == 0){\n\t\t\t\t\tdp[i+1][right] += dp[i][j];\n\t\t\t\t}\n\t\t\t\tif(t[i+1][j] != 1){\n\t\t\t\t\tdp[i+1][j] += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(t[i][j] == 2 && t[i+2][j] != 1){\n\t\t\t\tdp[i+2][j] += dp[i][j];\n\t\t\t}\n\t\t}\n\n\t\tans = 0;\n\t\trep(i,w) ans += dp[h][i] + dp[h-1][i];\n\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#define MOVE 0\n#define TREE 1\n#define JUMP 2\nm[15][15],D[15][15];\nX,Y,x,y,d;\nmain(){\n\tfor(;scanf(\"%d%d\",&X,&Y),X;){\n\t\tfor(y=0;y<Y;y++)\n\t\t\tfor(x=0;x<X;x++)\n\t\t\t\tscanf(\"%d\",&m[x][y]);\n\t\tfor(x=0;x<X;x++){\n\t\t\td=m[x][0]!=TREE;\n\t\t\tD[x][0]=d;\n\t\t\tprintf(\"%3d\",d);\n\t\t}\n\t\tputs(\"\");\n\t\tfor(y=1;y<Y;y++){\n\t\t\tfor(x=0;x<X;x++){\n\t\t\t\td=0;\n\t\t\t\tif(m[x][y]!=TREE){\n\t\t\t\t\tif(m[x][y-1]==MOVE)\n\t\t\t\t\t\td+=D[x][y-1];\n\t\t\t\t\tif(y-2>=0&&m[x][y-2]==JUMP)\n\t\t\t\t\t\td+=D[x][y-2];\n\t\t\t\t}\n\t\t\t\tif(m[x][y]==MOVE){\n\t\t\t\t\tif(x-1>=0&&m[x-1][y-1]==MOVE)\n\t\t\t\t\t\td+=D[x-1][y-1];\n\t\t\t\t\tif(x+1<X&&m[x+1][y-1]==MOVE)\n\t\t\t\t\t\td+=D[x+1][y-1];\n\t\t\t\t}\n\t\t\t\tD[x][y]=d;\n\t\t\t\tprintf(\"%3d\",d);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}\n\t\td=0;\n\t\tfor(x=0;x<X;x++){\n\t\t\td+=D[x][Y-1];\n\t\t\tif(Y-2>=0&&m[x][Y-2]==JUMP)\n\t\t\t\td+=D[x][Y-2];\n\t\t}\n\t\tprintf(\"%d\\n\",d);\n\t}\n\texit(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint main(void)\n{\n    int x, y;\n    int c[18][17];\n    int sum;\n    int i, j, k;\n    \n    while (1){\n        scanf(\"%d%d\", &x, &y);\n        if (x == 0 && y == 0){\n            break;\n        }\n        memset(c, 0, sizeof(c));\n        \n        for (i = 1; i <= y; i++){\n            for (j = 1; j <= x; j++){\n                scanf(\"%d\", &c[i][j]);\n                c[i][j] *= -1;\n            }\n        }\n        \n        for (i = 1; i <= x; i++){\n            if (c[1][i] == 0){\n                c[1][i] = 1;\n            }\n//printf(\"[%2d]\", c[1][i]);\n        }\n//printf(\"\\n\");\n\n        \n        for (i = 2; i <= y; i++){\n            for (j = 1; j <= x; j++){\n                if (c[i][j] >= 0){\n                    \n                    // 真上は何もない\n                    if (c[i - 1][j] > 0){\n                        c[i][j] += c[i - 1][j];\n//printf(\"(U%d)\", c[i - 1][j]);\n\n                    }\n\n                    // 左上は何もない\n                    if (c[i - 1][j - 1] > 0){\n                        c[i][j] += c[i - 1][j - 1];\n//printf(\"(L%d,%d=%d)\", i, j, c[i - 1][j - 1]);\n                    }\n                    \n                    // 右上は何もない\n                    if (c[i - 1][j + 1] > 0){\n                        c[i][j] += c[i - 1][j + 1];\n//printf(\"(R%d)\", c[i - 1][j + 1]);\n                    }\n                }\n                    // ジャンプ台\n                else if (c[i - 1][j] >=0 && c[i][j] == -2){\n                    k = i + 2;\n                    while (k <= y + 1){\n                        if (c[k][j] == -2){ //  ジャンプ台か？\n                            k += 2;\n                        }\n                        else {\n                            break;\n                        }\n                    }\n                    if (k <= y + 2 && c[k][j] >= 0){\n                        c[k][j] += c[i - 1][j];\n                    }\n                }\n//printf(\"[%2d]\", c[i][j]);\n                \n            }\n//printf(\"\\n\");\n        }\n        for (i = y + 1; i <= y + 2; i++){\n            for (j = 1; j <= x; j++){\n//printf(\"[%2d]\", c[i][j]);\n            }\n//printf(\"\\n\");\n        }\n        \n        sum = 0;\n        for (i = 1; i <= x; i++){\n            if (c[y][i] >= 0){\n                sum += c[y][i];\n            }\n            sum += c[y + 1][i];\n            sum += c[y + 2][i];\n        }\n        \n        printf(\"%d\\n\", sum);\n    }\n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint dx[3] = {-1, 0, 1};\nint dy[3] = {1, 1, 1};\n\nint main(void)\n{\n\tint **map, f1, f2, f3, **temp, x, y, sum, px, py;\n\t\n\twhile(scanf(\"%d %d\", &x, &y) && y > 0)\n\t{\n\t\tmap = new int *[y];\n\t\ttemp = new int *[y];\n\t\tsum = 0;\n\n\t\t//マップ土地&動的計画作成\n\t\tfor(f1 = 0; f1 < y; f1++)\n\t\t{\n\t\t\tmap[f1] = new int [x];\n\t\t\ttemp[f1] = new int [x];\n\t\t}\n\t\t//マップ構成入力&初期化\n\t\tfor(f1 = 0; f1 < y; f1++)\n\t\t{\n\t\t\tfor(f2 = 0; f2 < x; f2++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\",&map[f1][f2]);\n\t\t\t\ttemp[f1][f2] = 0;\n\t\t\t}\n\t\t}\n\t\t//最上のスタート地点設定\n\t\tfor(f1 = 0; f1 < x; f1++)\n\t\t{\n\t\t\tif(map[0][f1] != 1)\n\t\t\t{\n\t\t\t\ttemp[0][f1] = 1;\n\t\t\t\tsum++;\n\t\t\t}\n\t\t}\n\t\t//探索\n\t\tif(y >= 2)\n\t\t{\n\t\t\tsum = 0;\n\t\t\tfor(f1 = 0; f1 < y - 1; f1++)\n\t\t\t{\n\t\t\t\tfor(f2 = 0; f2 < x; f2++)\n\t\t\t\t{\n\t\t\t\t\tif(map[f1][f2] == 0 && temp[f1][f2] > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(f3 = 0; f3 < 3; f3++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//移動\n\t\t\t\t\t\t\tpx = f2 + dx[f3];\n\t\t\t\t\t\t\tpy = f1 + dy[f3];\n\t\t\t\t\t\t\t//範囲内か\n\t\t\t\t\t\t\tif(px >= 0 && px < x)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t//同じｘ座標からのジャンプ台\n\t\t\t\t\t\t\t\tif(f3 == 1 && py <= y - 1){\n\t\t\t\t\t\t\t\t\t//ｙ軸2つ先へ\n\t\t\t\t\t\t\t\t\twhile(py < y - 1 && map[py][px] == 2)\n\t\t\t\t\t\t\t\t\t\tpy += 2;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t//着地した場所がゴール地点のｙ座標と同じで障害物にぶつかってないか\n\t\t\t\t\t\t\t\t//ゴール地点のｙ座標を超えたか\n\t\t\t\t\t\t\t\tif(py > y - 1 || py == y - 1 && map[py][px] != 1)\n\t\t\t\t\t\t\t\t\tsum += temp[f1][f2];\n\t\t\t\t\t\t\t\t//超えてないが、障害物がない地点に着地したか\n\t\t\t\t\t\t\t\telse if(map[py][px] == 0)\n\t\t\t\t\t\t\t\t\ttemp[py][px] += temp[f1][f2];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//出力\n\t\tprintf(\"%d\\n\",sum);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint main(void)\n{\n\tint ans, num[15][15];\n\tint w, h;\n\tint i, j;\n\tint map[15][15];\n\t\n\twhile (1){\n\t\tscanf(\"%d%d\", &w, &h);\n\t\t\n\t\tif (w + h == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor (i = 0; i < h; i++){\n\t\t\tfor (j = 0; j < w; j++){\n\t\t\t\tscanf(\"%d\", &map[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tmemset(num, 0, sizeof(num));\n\t\tfor (i = 0; i < w; i++){\n\t\t\tif (map[0][i] != 1){\n\t\t\t\tnum[0][i] = 1;\n\t\t\t}\n\t\t}\n\t\tfor (i = 1; i < h; i++){\n\t\t\tfor (j = 0; j < w; j++){\n\t\t\t\tif (j > 0 && map[i - 1][j - 1] == 0 && map[i][j] != 2){\n\t\t\t\t\tnum[i][j] += num[i - 1][j - 1];\n\t\t\t\t}\n\t\t\t\tif (map[i - 1][j] == 0){\n\t\t\t\t\tnum[i][j] += num[i - 1][j];\n\t\t\t\t}\n\t\t\t\tif (j < w - 1 && map[i - 1][j + 1] == 0 && map[i][j] != 2){\n\t\t\t\t\tnum[i][j] += num[i - 1][j + 1];\n\t\t\t\t}\n\t\t\t\tif (i > 1 && map[i - 2][j] == 2){\n\t\t\t\t\tnum[i][j] += num[i - 2][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = 0;\n\t\tfor (j = 0; j < w; j++){\n\t\t\tans += num[h - 1][j];\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint main(){\n  while(1){\n    int dp[17][17], cond[17][17], x, y, i, j;\n    int ans = 0;\n    scanf(\"%d%d\", &x, &y);\n    if(x == 0 && y == 0)return 0;\n    memset(dp, 0, sizeof(dp));\n    for(i = 0;i < y;i++){\n      for(j = 1;j <= x;j++){\n\tscanf(\"%d\", &cond[i][j]);\n      }\n    }\n    for(i = 0;i < y - 1;i++){\n      for(j = 1;j <= x;j++){\n\tif(cond[i][j] == 1)continue;\n\tif(i == 0)dp[i][j] = 1;\n\tif(i > 2 && cond[i - 2][j] == 2)\n\t  dp[i][j] += dp[i - 2][j];\n\tif(i > 0 && cond[i][j] == 0){\n\t  if(cond[i - 1][j] == 0)\n\t    dp[i][j] += dp[i - 1][j];\n\t  if(cond[i - 1][j - 1] == 0)\n\t    dp[i][j] += dp[i - 1][j - 1];\n\t  if(cond[i - 1][j + 1] == 0)\n\t    dp[i][j] += dp[i - 1][j + 1];\n\t}\t\n      }\n    }\n    for(j = 1;j <= x;j++){\n      if(cond[y - 1][j] != 1)\n\tans += dp[y - 1][j];\n      if(cond[y - 2][j] == 2)\n\tans += dp[y - 2][j];\n    }\n   \n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint main(){\n  while(1){\n    int dp[17][17], cond[17][17], x, y, i, j, c;\n    long long int ans = 0;\n    scanf(\"%d%d\", &x, &y);\n    if(x == 0 && y == 0)return 0;\n    memset(dp, 0, sizeof(dp));\n    for(i = 0;i < y;i++){\n      cond[i][0] = 1;\n      for(j = 1;j <= x;j++){\n\tscanf(\"%d\", &cond[i][j]);\n      }\n      cond[i][x + 1] = 1;\n    }\n    for(i = 0;i < y - 1;i++){\n      for(j = 1;j <= x;j++){\n\tif(i == 0)\n\t  dp[i][j] = !cond[i][j];\n\tif(cond[i][j] == 2)\n\t  dp[i + 2][j] += dp[i][j];\n\tif(cond[i][j] == 0){\n\t  dp[i + 1][j] += dp[i][j];\n\t  if(cond[i + 1][j - 1] != 2)\n\t      dp[i + 1][j - 1] += dp[i][j];\n\t  if(cond[i + 1][j + 1] != 2)\n\t    dp[i + 1][j + 1] += dp[i][j];\n\t}\t\n      }\n    }\n    for(i = y - 1;i <= y;i++){\n      for(j = 1;j <= x;j++){\n\tif(cond[i][j] != 1)\n\t  ans += dp[i][j];\t\n      }\n    }\n    printf(\"%lld\\n\", ans);\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint main(){\n\tint x,y,m[20][20],d[20][20],i,j,ans;\n\tFILE *fp;\n\t//fp=fopen(\"test.txt\",\"r\");\n\tfp=stdin;\n\twhile(1){\n\t\tfscanf(fp,\"%d%d\",&x,&y);\n\t\tif(x==0 && y==0)break;\n\t\tmemset(d,0,sizeof(d));\n\t\tmemset(m,0,sizeof(m));\n\t\tfor(i=1;i<=y;i++){\n\t\t\tfor(j=1;j<=x;j++){\n\t\t\t\tfscanf(fp,\"%d\",&m[i][j]);\n\t\t\t\tif(i==1){\n\t\t\t\t\tif(m[i][j]==0)d[i][j]=1;\n\t\t\t\t\telse if(m[i][j]==2)d[i+2][j]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=2;i<=y;i++){\n\t\t\tfor(j=1;j<=x;j++){\n\t\t\t\tif(m[i][j]==0){\n\t\t\t\t\td[i][j]+=d[i-1][j-1]+d[i-1][j]+d[i-1][j+1];\n\t\t\t\t}else if(m[i][j]==1){\n\t\t\t\t\td[i][j]=0;\n\t\t\t\t}else if(m[i][j]==2){\n\t\t\t\t\td[i+2][j]+=d[i-1][j]+d[i][j];\n\t\t\t\t\td[i][j]=0;\n\t\t\t\t}\n\t\t\t\t//printf(\"%d%s\",d[i][j],(j==x)?\"\\n\":\" \");\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=x;i++)d[y+1][i]+=d[y][i];\n\t\t//\tprintf(\"%d%s\",d[y+1][i],(i==x)?\"\\n\":\" \");\n\t\tans=0;\n\t\tfor(i=1;i<=x;i++)ans+=d[y+1][i]/*+d[y][i]*/;\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint main(void)\n{\n    int x, y;\n    int c[18][17];\n    int sum;\n    int i, j, k;\n    \n    while (1){\n        scanf(\"%d%d\", &x, &y);\n        if (x == 0 && y == 0){\n            break;\n        }\n        memset(c, 0, sizeof(c));\n        \n        for (i = 1; i <= y; i++){\n            for (j = 1; j <= x; j++){\n                scanf(\"%d\", &c[i][j]);\n                c[i][j] *= -1;\n            }\n        }\n        \n        for (i = 1; i <= x; i++){\n            if (c[1][i] == 0){\n                c[1][i] = 1;\n            }\n//printf(\"[%2d]\", c[1][i]);\n        }\n//printf(\"\\n\");\n\n        \n        for (i = 2; i <= y; i++){\n            for (j = 1; j <= x; j++){\n                if (c[i][j] >= 0){\n                    \n                    // 真上は何もない\n                    if (c[i - 1][j] > 0){\n                        c[i][j] += c[i - 1][j];\n//printf(\"(U%d)\", c[i - 1][j]);\n\n                    }\n\n                    // 左上は何もない\n                    if (c[i - 1][j - 1] > 0){\n                        c[i][j] += c[i - 1][j - 1];\n//printf(\"(L%d,%d=%d)\", i, j, c[i - 1][j - 1]);\n                    }\n                    \n                    // 右上は何もない\n                    if (c[i - 1][j + 1] > 0){\n                        c[i][j] += c[i - 1][j + 1];\n//printf(\"(R%d)\", c[i - 1][j + 1]);\n                    }\n                }\n                    // ジャンプ台\n                else if (c[i - 1][j] >=0 && c[i][j] == -2){\n                    k = i + 2;\n                    while (k <= y + 1){\n                        if (c[k][j] == -2){ //  ジャンプ台か？\n                            k += 2;\n                        }\n                        else {\n                            break;\n                        }\n                    }\n                    if (k <= y + 1 && c[k][j] >= 0){\n                        c[k][j] = c[i - 1][j];\n                    }\n                }\n//printf(\"[%2d]\", c[i][j]);\n                \n            }\n//printf(\"\\n\");\n        }\n        for (i = 1; i <= x; i++){\n            if (c[y][i] >= 0){\n                c[y + 1][i] += c[y][i];\n            }\n//printf(\"[%2d]\", c[y + 1][i]);\n        }\n//printf(\"\\n\");\n        \n        sum = 0;\n        for (i = 1; i <= x; i++){\n            sum += c[y + 1][i];\n        }\n        \n        printf(\"%d\\n\", sum);\n    }\n    return (0);\n}\n                        "
  },
  {
    "language": "C",
    "code": "// Aizu Vol-2 0203: A New Plan of Aizu Ski Resort\n// 2017.8.24 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX 15\nchar map[MAX+3][MAX+3];\nint p[MAX+3][MAX+3];\nint X, Y;\n\nint main()\n{\n\tint i, k, x, y, x2, y2;\n\tint m[2] = { -1,1 };\n\n\twhile (scanf(\"%d%d\", &X, &Y) && X) {\n\t\tmemset(map, 0, sizeof(map)), memset(p, 0, sizeof(p));\n\t\tfor (y = 1; y <= Y; y++) for (x = 1; x <= X; x++) scanf(\"%d\", &k), map[y][x] = k;\n\t\tfor (x = 1; x <= X; x++) p[1][x] = (map[1][x] != 1);\n\t\tfor (y = 1; y < Y; y++) for (x = 1; x <= X; x++) {\n\t\t\tif (map[y][x] == 1) continue;\n\t\t\tif (map[y][x] == 2) { if (p[y+2][x] != 1) p[y+2][x] += p[y][x]; continue; }\n\t\t\tfor (i = 0; i < 2; i++) {\n\t\t\t\tx2 = x + m[i], y2 = y + 1;\n\t\t\t\tif (x2 > 0 && x2 <= X && map[y2][x2] == 0) p[y2][x2] += p[y][x];\n\t\t\t}\n\t\t\ty2 = y + 1; if (map[y2][x] != 1) p[y2][x] += p[y][x];\n\t\t}\n\t\tfor (k = 0, y = Y; y <= Y+1; y++) for (x = 1; x <= X; x++) k += p[y][x];\n\t\tprintf(\"%d\\n\", k);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint main(void)\n{\n    int x, y;\n    int c[18][17];\n    int sum;\n    int i, j, k;\n    \n    while (1){\n        scanf(\"%d%d\", &x, &y);\n        if (x == 0 && y == 0){\n            break;\n        }\n        memset(c, 0, sizeof(c));\n        \n        for (i = 1; i <= y; i++){\n            for (j = 1; j <= x; j++){\n                scanf(\"%d\", &c[i][j]);\n                c[i][j] *= -1;\n            }\n        }\n        \n        for (i = 1; i <= x; i++){\n            if (c[1][i] == 0){\n                c[1][i] = 1;\n            }\n//printf(\"[%2d]\", c[1][i]);\n        }\n//printf(\"\\n\");\n\n        \n        for (i = 2; i <= y; i++){\n            for (j = 1; j <= x; j++){\n                if (c[i][j] >= 0){\n                    \n                    // 真上は何もない\n                    if (c[i - 1][j] > 0){\n                        c[i][j] += c[i - 1][j];\n//printf(\"(U%d)\", c[i - 1][j]);\n\n                    }\n\n                    // 左上は何もない\n                    if (c[i - 1][j - 1] > 0){\n                        c[i][j] += c[i - 1][j - 1];\n//printf(\"(L%d,%d=%d)\", i, j, c[i - 1][j - 1]);\n                    }\n                    \n                    // 右上は何もない\n                    if (c[i - 1][j + 1] > 0){\n                        c[i][j] += c[i - 1][j + 1];\n//printf(\"(R%d)\", c[i - 1][j + 1]);\n                    }\n                }\n                    // ジャンプ台\n                else if (c[i - 1][j] >=0 && c[i][j] == -2){\n                    k = i + 2;\n                    while (k <= y + 1){\n                        if (c[k][j] == -2){ //  ジャンプ台か？\n                            k += 2;\n                        }\n                        else {\n                            break;\n                        }\n                    }\n                    if (k <= y + 1 && c[k][j] >= 0){\n                        c[k][j] = c[i - 1][j];\n                    }\n                }\n//printf(\"[%2d]\", c[i][j]);\n                \n            }\n//printf(\"\\n\");\n        }\n        for (i = 1; i <= x; i++){\n            if (c[y][i] >= 0){\n                c[y + 1][i] += c[y][i];\n                c[y + 1][i] += c[y + 2][i];\n            }\n            else if (c[y][i] == -2){\n                c[y + 1][i] += c[y + 2][i];\n            }\n\n//printf(\"[%2d]\", c[y + 1][i]);\n        }\n//printf(\"\\n\");\n        \n        sum = 0;\n        for (i = 1; i <= x; i++){\n            sum += c[y + 1][i];\n        }\n        \n        printf(\"%d\\n\", sum);\n    }\n    return (0);\n}"
  },
  {
    "language": "Kotlin",
    "code": "fun main(args:Array<String>?): Unit {\n    while(true){\n        val (x, y) = readLine()!!.trim().split(' ').map(String::toInt)\n        if (x == 0 && y == 0) return\n        val state = Array(y){\n            readLine()!!.trim().split(' ').mapNotNull{\n                when(it){\n                    \"0\" -> State.Snow\n                    \"1\" -> State.Barrier\n                    \"2\" -> State.Jump\n                    else -> null\n                }\n            }.toTypedArray()\n        }\n        println(\n                solve(state)\n        )\n    }\n}\n\nfun sub(x: Int, y: Int, state: Array<Array<State>>, memo: Array<LongArray>): Long {\n    return when{\n        y !in state.indices || x !in state[y].indices || state[y][x] != State.Snow -> 0\n        y == 0 -> 1\n        memo[y][x] >= 0 -> memo[y][x]\n        else -> {\n            memo[y][x] = sub(x - 1, y - 1, state, memo) + sub(x, y - 1, state, memo) + sub(x + 1, y - 1, state,memo) + jumpFrom(x, y - 2, state, memo)\n            memo[y][x]\n        }\n    }\n}\nfun jumpFrom(x: Int, y: Int, state: Array<Array<State>>, memo: Array<LongArray>): Long {\n    return when{\n        y !in state.indices || x !in state[y].indices || state[y][x] != State.Jump -> 0\n        memo[y][x] >= 0 -> memo[y][x]\n        else -> {\n            memo[y][x] = jumpFrom(x, y - 2, state, memo) + sub(x, y - 1, state, memo)\n            memo[y][x]\n        }\n    }\n}\nfun solve(state: Array<Array<State>>): Long {\n    val memo = Array(state.size){LongArray(state[it].size){-1}}\n    return state.last().indices.map{x -> sub(x, state.lastIndex, state, memo) + jumpFrom(x, state.lastIndex, state, memo) + jumpFrom(x, state.lastIndex - 1, state, memo)}.sum()\n}\nenum class State {\n    Snow, Barrier, Jump\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n\tint w;\n\tint h;\n\tint count;\n\tshort[][] map;\n\tint[][] dp;\n\tpublic void run(){\n\t\tScanner scan = new Scanner(System.in);\n\t\twhile(scan.hasNext()){\n\t\t\tw = scan.nextInt();\n\t\t\th = scan.nextInt();\n\t\t\tif(w == 0 && h == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmap = new short[h][w];\n\t\t\tfor(int i = 0;i < h;i++){\n\t\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\t\tmap[i][j] = scan.nextShort();\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp = new int[h+1][w];\n\t\t\tfor(int i = 0;i < w;i++){\n\t\t\t\tif(map[0][i] == 0){\n\t\t\t\t\tdp[0][i] = 1;\n\t\t\t\t}else{\n\t\t\t\t\tdp[0][i] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 1;i < h;i++){\n\t\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\t\tif(map[i][j] == 1){\n\t\t\t\t\t\tdp[i][j] = 0;\n\t\t\t\t\t}else if(map[i][j] == 2){\n\t\t\t\t\t\tif(i < h-1){\n\t\t\t\t\t\t\tdp[i+2][j] += dp[i-1][j] + dp[i][j];\n\t\t\t\t\t\t\tdp[i][j] = 0;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tdp[i][j] += dp[i-1][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(j != 0){\n\t\t\t\t\t\t\tdp[i][j] += dp[i-1][j-1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(j != w-1){\n\t\t\t\t\t\t\tdp[i][j] += dp[i-1][j+1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp[i][j] += dp[i-1][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcount = 0;\n\t\t\tfor(int i = 0;i < w;i++){\n\t\t\t\tcount += Math.max(dp[h-1][i],dp[h][i]);\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int X = sc.nextInt();\n\t\t\tfinal int Y = sc.nextInt();\n\t\t\t\n\t\t\tif(X == 0 && Y == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[][] map = new int[Y][X];\n\t\t\t\n\t\t\tfor(int i = 0; i < Y; i++){\n\t\t\t\tfor(int j = 0; j < X; j++){\n\t\t\t\t\tmap[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint[][] dp = new int[Y+2][X];\n\t\t\t\n\t\t\tfor(int i = 0; i < Y; i++){\n\t\t\t\tfor(int j = 0; j < X; j++){\n\t\t\t\t\tif(map[i][j] == 1){\n\t\t\t\t\t\tdp[i][j] = 0;\n\t\t\t\t\t\t//System.out.print(dp[i][j] + \" \");\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(i == 0){\n\t\t\t\t\t\tdp[i][j] = 1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdp[i][j] += (map[i-1][j] == 0 ? dp[i-1][j] : 0);\n\t\t\t\t\t\tif(map[i][j] != 2){\n\t\t\t\t\t\t\tdp[i][j] += j != 0 ? (map[i-1][j-1] == 0 ? dp[i-1][j-1] : 0) : 0;\n\t\t\t\t\t\t\tdp[i][j] += j != X-1 ? (map[i-1][j+1] == 0 ? dp[i-1][j+1] : 0) : 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(map[i][j] == 2){\n\t\t\t\t\t\tdp[i+2][j] = dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t//System.out.print(dp[i][j] + \" \");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//System.out.println();\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(int i = Y; i < Y+2; i++){\n\t\t\t\tfor(int j = 0; j < X; j++){\n\t\t\t\t\tSystem.out.print(dp[i][j] + \" \");\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t*/\n\t\t\tfor(int i = Y; i < Y+2; i++){\n\t\t\t\tfor(int j = 0; j < X; j++){\n\t\t\t\t\tif(i == Y && map[i-1][j] == 2){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][j] += dp[i-1][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tSystem.out.println(\"--------------------------\");\n\t\t\tfor(int i = Y; i < Y+2; i++){\n\t\t\t\tfor(int j = 0; j < X; j++){\n\t\t\t\t\tSystem.out.print(dp[i][j] + \" \");\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t*/\n\t\t\tint sum = 0;\n\t\t\tfor(int j = 0; j < X; j++){\n\t\t\t\tsum += dp[Y+1][j];\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tw = scanner.nextInt();\n\t\t\th = scanner.nextInt();\n\t\t\tif ((w | h) == 0)\n\t\t\t\tbreak;\n\t\t\tmap = new int[h][w + 2];\n\t\t\tfor (int[] a : map)\n\t\t\t\tArrays.fill(a, 1);\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\t\tmap[i][j] = scanner.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[][] dp = new int[h][w + 2];\n\t\t\tfor (int i = 1; i <= w; i++) {\n\t\t\t\tif (map[0][i] == 0)\n\t\t\t\t\tdp[0][i] = 1;\n\t\t\t}\n\t\t\tfor (int i = 1; i < h; i++) {\n\t\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\t\tif (map[i][j] == 1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (map[i][j] == 0) {\n\t\t\t\t\t\tfor (int k = -1; k < 2; k++) {\n\t\t\t\t\t\t\tif (map[i - 1][j + k] == 0)\n\t\t\t\t\t\t\t\tdp[i][j] += dp[i - 1][j + k];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if (map[i][j] == 2) {\n\t\t\t\t\t\tif (map[i - 1][j] == 0)\n\t\t\t\t\t\t\tdp[i][j] += dp[i - 1][j];\n\t\t\t\t\t}\n\t\t\t\t\tif (i > 1 && map[i - 2][j] == 2)\n\t\t\t\t\t\tdp[i][j] += dp[i - 2][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sum = 0;\n\t\t\tfor (int i = 1; i <= w; i++) {\n\t\t\t\tsum += dp[h - 1][i];\n\t\t\t\tif (h > 1 && map[h - 2][i] == 2)\n\t\t\t\t\tsum += dp[h - 2][i];\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n\n\tint count;\n\tint w;\n\tint h;\n\tint[][] map;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int x, y;\n\tstatic int[][] field, dp;\n\tstatic int[] dx = {-1, 0, 1};\n\tpublic static void main(String[] args) {\n\t\twhile(read()){\n\t\t\tsolve();\n\t\t}\n\t}\n\t\n\tstatic boolean read(){\n\t\tx = sc.nextInt();\n\t\ty = sc.nextInt();\n\t\tif(x == 0 && y == 0)return false;\n\t\t\n\t\tfield = new int[y+2][x];\n\t\tdp = new int[y+2][x];\n\t\t\n\t\tfor(int i = 0; i < field.length-2; i++){\n\t\t\tfor(int j = 0; j < field[0].length; j++){\n\t\t\t\tfield[i][j] = sc.nextInt();\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tstatic void solve(){\n\t\tfor(int i = 0; i < field[0].length; i++){\n\t\t\tif(field[0][i] == 0)dp[0][i] = 1;\n\t\t}\n\t\t\n\t\tfor(int y = 0; y < field.length-3; y++){\n\t\t\tfor(int x = 0; x < field[0].length; x++){\n\t\t\t\tif(field[y][x] == 0){\n\t\t\t\t\tfor(int k = 0; k < dx.length; k++){\n\t\t\t\t\t\tint nx = x + dx[k], ny = y + 1;\n\t\t\t\t\t\tif(0 > nx || nx >= field[0].length)continue;\n\t\t\t\t\t\tif(field[ny][nx] == 0)dp[ny][nx] += dp[y][x];\n\t\t\t\t\t}\n\t\t\t\t}else if(field[y][x] == 2){\n\t\t\t\t\tint ny = y + 2, nx = x;\n\t\t\t\t\tdp[y][x] = dp[y-1][x];\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\tdp[ny][nx] += dp[y][x];\n\t\t\t\t\t\tif(field[ny][nx] != 2)break;\n\t\t\t\t\t\tny = ny + 2;\n\t\t\t\t\t}\n\t\t\t\t}else if(field[y][x] == 1){\n\t\t\t\t\tdp[y][x] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = 0;\n\t\tfor(int x = 0; x < dp[0].length; x++){\n\t\t\tres += dp[dp.length-1][x] + dp[dp.length-2][x] + dp[dp.length-3][x];\n\t\t}\n\t\tSystem.out.println(res);\n\t\t//printDP();\n\t}\n\t\n\tstatic void printDP(){\n\t\tfor(int i = 0; i < field.length; i++){\n\t\t\tfor(int j = 0; j < field[0].length; j++){\n\t\t\t\tSystem.out.print(dp[i][j] + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tint DP(int h,int w,int hw[][]){\n\t\tint result = 0;\n\t\tint yx[][] = new int [h][w];\n\t\tfor(int i = 0;i < w;i++){\n\t\t\tif(hw[0][i] == 0){\n\t\t\t\tyx[0][i] = 1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < h-1;i++){\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tif(j == 0){\n\t\t\t\t\tif(hw[i+1][j] == 0){\n\t\t\t\t\t\tyx[i+1][j] = yx[i+1][j] + yx[i][j] + yx[i][j+1];\n\t\t\t\t\t}\n\t\t\t\t}else if(j == w-1){\n\t\t\t\t\tif(hw[i+1][j] == 0){\n\t\t\t\t\t\tyx[i+1][j] = yx[i+1][j] + yx[i][j] + yx[i][j-1];\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(hw[i+1][j] == 0){\n\t\t\t\t\t\tyx[i+1][j] = yx[i+1][j] + yx[i][j-1] + yx[i][j] + yx[i][j+1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tif(hw[i+1][j] == 2){\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\tif(i+cnt+1 == h-2){\n\t\t\t\t\t\t\tcnt = cnt + 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tcnt = cnt + 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(hw[i+cnt+1][j] != 2)break;\n\t\t\t\t\t}\n\t\t\t\t\tyx[i+cnt+1][j] = yx[i+cnt+1][j] + yx[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < w;i++){\n\t\t\tresult = result + yx[h-1][i];\n\t\t}\n//\t\tfor(int i = 0;i < h;i++){\n//\t\t\tfor(int j = 0;j < w;j++){\n//\t\t\t\tSystem.out.print(yx[i][j]+\" \");\n//\t\t\t}\n//\t\t\tSystem.out.println();\n//\t\t}\n\t\treturn result;\n\t}\n\tvoid doIt() { \n\t\twhile(true){\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tint hw[][] = new int [h][w];\n\t\t\tif(h+w == 0)break;\n\t\t\tfor(int i = 0;i < h;i++){\n\t\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\t\thw[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(DP(h,w,hw));\n\t\t}\n     }\n    public static void main(String[] args) {\n    \t// TODO Auto-generated method stub\n    \tnew Main().doIt();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tint mod = 1000000007;\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint X = sc.nextInt();\n\t\t\tint Y = sc.nextInt();\n\t\t\tif ((X | Y) == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint[][] field = new int[Y][X];\n\t\t\tint[][] dp = new int[Y][X];\n\t\t\tfor (int i = 0; i < Y; i++) {\n\t\t\t\tfor (int j = 0; j < X; j++) {\n\t\t\t\t\tfield[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < X; i++) {\n\t\t\t\tif (field[0][i] == 0) {\n\t\t\t\t\tdp[0][i] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 1; i < Y; i++) {\n\t\t\t\tfor (int j = 0; j < X; j++) {\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\tif (field[i][j] == 1) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (j - 1 >= 0 && field[i][j] != 2\n\t\t\t\t\t\t\t&& field[i - 1][j - 1] != 1\n\t\t\t\t\t\t\t&& field[i - 1][j - 1] != 2) {\n\t\t\t\t\t\tcnt += dp[i - 1][j - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (field[i - 1][j] != 2) {\n\t\t\t\t\t\tcnt += dp[i - 1][j];\n\t\t\t\t\t\tif (i - 2 > 0 && field[i - 2][j] == 2) {\n\t\t\t\t\t\t\tcnt += dp[i - 2][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (j + 1 < X && field[i][j] != 2\n\t\t\t\t\t\t\t&& field[i - 1][j + 1] != 1\n\t\t\t\t\t\t\t&& field[i - 1][j + 1] != 2) {\n\t\t\t\t\t\tcnt += dp[i - 1][j + 1];\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][j] = cnt;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = 0;\n\t\t\tfor (int i = 0; i < X; i++) {\n\t\t\t\tans += dp[Y - 1][i];\n\t\t\t\tif (Y-2 >= 0 && field[Y - 2][i] == 2) {\n\t\t\t\t\tans += dp[Y - 2][i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(int[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.awt.geom.*;\nimport java.math.*;\n\npublic class Main {\n\n\tstatic final Scanner in = new Scanner(System.in);\n\tstatic final PrintWriter out = new PrintWriter(System.out,false);\n\tstatic boolean debug = false;\n\n\tstatic int h, w;\n\tstatic int[][] t, dp;\n\n\tstatic int[] dy = { 1, 1, 1,};\n\tstatic int[] dx = { -1, 0, 1};\n\n\tstatic int rec(int cy, int cx) {\n\t\tif (cy > h-1) return 1;\n\t\tif (cy == h-1) return t[cy][cx] != 1 ? 1 : 0;\n\t\tif (dp[cy][cx] != -1) return dp[cy][cx];\n\t\tif (t[cy][cx] == 2) return dp[cy][cx] = rec(cy+2, cx);\n\t\tint res = 0;\n\t\tfor (int i=0; i<3; i++) {\n\t\t\tint ny = cy + dy[i];\n\t\t\tint nx = cx + dx[i];\n\t\t\tif (nx < 0 || w <= nx) continue;\n\t\t\tif (t[ny][nx] == 1) continue;\n\t\t\tif (t[ny][nx] == 2 && nx != cx) continue;\n\t\t\tif (t[ny][nx] == 2)\n\t\t\t\tres += rec(ny+2, nx);\n\t\t\telse\n\t\t\t\tres += rec(ny, nx);\n\t\t}\n\t\treturn dp[cy][cx] = res;\n\t}\n\n\tstatic boolean solve() {\n\t\tw = in.nextInt();\n\t\th = in.nextInt();\n\t\tif (w + h == 0) return false;\n\n\t\tt = new int[h][w];\n\t\tfor (int i=0; i<h; i++) {\n\t\t\tfor (int j=0; j<w; j++) {\n\t\t\t\tt[i][j] = in.nextInt();\n\t\t\t}\n\t\t}\n\n\t\tdp = new int[h][w];\n\t\tfor (int i=0; i<h; i++) {\n\t\t\tArrays.fill(dp[i], -1);\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor (int i=0; i<w; i++) {\n\t\t\tif (t[0][i] != 1) {\n\t\t\t\tans += rec(0, i);\n\t\t\t}\n\t\t}\n\n\t\tout.println(ans);\n\n\t\treturn true;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tdebug = args.length > 0;\n\t\tlong start = System.nanoTime();\n\n\t\twhile(solve());\n\t\tout.flush();\n\n\t\tlong end = System.nanoTime();\n\t\tdump((end - start) / 1000000 + \" ms\");\n\t\tin.close();\n\t\tout.close();\n\t}\n\n\tstatic void dump(Object... o) { if (debug) System.err.println(Arrays.deepToString(o)); }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tint DP(int h,int w,int hw[][]){\n\t\tint result = 0;\n\t\tint yx[][] = new int [h][w];\n\t\tfor(int i = 0;i < w;i++){\n\t\t\tif(hw[0][i] == 0){\n\t\t\t\tyx[0][i] = 1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < h-1;i++){\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tif(j == 0){\n\t\t\t\t\tif(hw[i+1][j] == 0){\n\t\t\t\t\t\tif(w == 1){\n\t\t\t\t\t\t\tyx[i+1][j] = yx[i+1][j] + yx[i][j];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tyx[i+1][j] = yx[i+1][j] + yx[i][j] + yx[i][j+1];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else if(j == w-1){\n\t\t\t\t\tif(hw[i+1][j] == 0){\n\t\t\t\t\t\tyx[i+1][j] = yx[i+1][j] + yx[i][j] + yx[i][j-1];\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(hw[i+1][j] == 0){\n\t\t\t\t\t\tyx[i+1][j] = yx[i+1][j] + yx[i][j-1] + yx[i][j] + yx[i][j+1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tif(hw[i+1][j] == 2){\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\tif(i+cnt+1 == h-2){\n\t\t\t\t\t\t\tcnt = cnt + 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(i+cnt+2 == h)break;\n\t\t\t\t\t\t\tcnt = cnt + 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(hw[i+cnt+1][j] != 2)break;\n\t\t\t\t\t}\n\t\t\t\t\tif(hw[i+cnt+1][j] == 0){\n\t\t\t\t\t\tyx[i+cnt+1][j] = yx[i+cnt+1][j] + yx[i][j];\n\t\t\t\t\t}else if(hw[i+cnt+1][j] == 1 && (h-i) % 2 == 1 && i+cnt+1 == h-1){\n\t\t\t\t\t\tyx[i+cnt+1][j] = yx[i+cnt+1][j] + yx[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < w;i++){\n\t\t\tresult = result + yx[h-1][i];\n\t\t}\n//\t\tfor(int i = 0;i < h;i++){\n//\t\t\tfor(int j = 0;j < w;j++){\n//\t\t\t\tSystem.out.print(yx[i][j]+\" \");\n//\t\t\t}\n//\t\t\tSystem.out.println();\n//\t\t}\n\t\treturn result;\n\t}\n\tvoid doIt() { \n\t\twhile(true){\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tint hw[][] = new int [h][w];\n\t\t\tif(h+w == 0)break;\n\t\t\tfor(int i = 0;i < h;i++){\n\t\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\t\thw[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(DP(h,w,hw));\n\t\t}\n     }\n    public static void main(String[] args) {\n    \t// TODO Auto-generated method stub\n    \tnew Main().doIt();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint W=cin.nextInt();\n\t\t\tint H=cin.nextInt();\n\t\t\tif((W|H)==0)break;\n\t\t\tint[][] field=new int[W][H];\n\t\t\tint[][] dp=new int[W][H];\n\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\tfield[j][i]=cin.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<W;i++){\n\t\t\t\tdp[i][0]=1;\n\t\t\t}\n\t\t\tint ans=0;\n\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\tif(field[j][i]==1){\n\t\t\t\t\t\tdp[j][i]=0;\n\t\t\t\t\t}\n\t\t\t\t\telse if(field[j][i]==2){\n\t\t\t\t\t\tif(i+2>=H){\n\t\t\t\t\t\t\tans+=dp[j][i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tdp[j][i+2]+=dp[j][i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(i+1>=H){\n\t\t\t\t\t\t\tans+=dp[j][i];\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(j-1>=0){\n\t\t\t\t\t\t\tif(field[j-1][i+1]==0)\n\t\t\t\t\t\t\t\tdp[j-1][i+1]+=dp[j][i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(j+1<W){\n\t\t\t\t\t\t\tif(field[j+1][i+1]==0)\n\t\t\t\t\t\t\t\tdp[j+1][i+1]+=dp[j][i];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdp[j][i+1]+=dp[j][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\tfor(int j=0;j<W;j++){\n//\t\t\t\t\tSystem.out.print(dp[j][i]+\" \");\n\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    int[][] map;\n    int X;\n    int Y;\n    int[][] dp;\n    int[] dx = { -1, 0, 1 };\n    int[] dy = { 1, 1, 1 };\n\n    void run() {\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            X = sc.nextInt();\n            Y = sc.nextInt();\n            if ((X | Y) == 0)\n                break;\n            map = new int[Y + 2][X + 2];\n            dp = new int[Y + 2][X + 2];\n            for (int i = 0; i <= Y; i++) {\n                map[i][0] = 1;\n                map[i][X + 1] = 1;\n            }\n            for (int i = 1; i <= Y; i++) {\n                for (int j = 1; j <= X; j++) {\n                    map[i][j] = sc.nextInt();\n                }\n            }\n            int ans = 0;\n            for (int i = 1; i <= X; i++) {\n                for (int j = 0; j <= Y + 1; j++) {\n                    Arrays.fill(dp[j], -1);\n                }\n                ans += slove(i, 1);\n            }\n            System.out.println(ans);\n        }\n    }\n\n    int slove(int x, int y) {\n        if (dp[y][x] > 0) {\n            return dp[y][x];\n        } else {\n            int res = 0;\n            if (map[y][x] == 1) {\n                res = 0;\n            } else if (y >= Y) {\n                return 1;\n            } else if (map[y][x] == 2) {\n                res = slove(x, y + 2);\n            } else {\n                for (int i = 0; i < 3; i++) {\n                    int nx = x + dx[i];\n                    int ny = y + dy[i];\n                    if (!(map[ny][nx] == 2 && x != nx))\n                        res += slove(nx, ny);\n                }\n            }\n            return dp[y][x] = res;\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        new Main().run();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.lang.annotation.Retention;\nimport java.util.*;\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\tpublic Main() {\n\t\tnew AOJ0203();\n\t}\n\t//一番最後の行に2が来ている時のケースを考える。\n\n\tclass AOJ0203{\n\t\tint x,y;\n\t\tint[][] map;\n\t\tHashMap<String,Integer> memo;\n\t\tint dfs(int sx,int sy,int before_x){\n\t\t\t//\t\t\tSystem.out.println(sx+\" \"+sy+\" \"+before_x);\n\t\t\tif(memo.containsKey(sx+\" \"+sy+\" \"+before_x))return memo.get(sx+\" \"+sy+\" \"+before_x);\n\t\t\tint result = 0;\n\t\t\tif(sy>=y-1){\n\t\t\t\tif(sy==y-1){\n\t\t\t\t\tif(map[sy][sx]==1){\n\t\t\t\t\t\tmemo.put(sx+\" \"+sy+\" \"+before_x,0);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}else if(map[sy][sx]==2&&before_x!=sx)return 0;\n\t\t\t\t}\n\t\t\t\tmemo.put(sx+\" \"+sy+\" \"+before_x,1);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif(map[sy][sx]==1){\n\t\t\t\tmemo.put(sx+\" \"+sy+\" \"+before_x, 0);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse if(map[sy][sx]==2){\n\t\t\t\tif(before_x!=sx){\n\t\t\t\t\tmemo.put(sx+\" \"+sy+\" \"+before_x,0);\n\t\t\t\t\treturn 0;\n\t\t\t\t}else{\n\t\t\t\t\tmemo.put(sx+\" \"+sy+\" \"+before_x,dfs(sx,sy+2,sx));\n\t\t\t\t\treturn memo.get(sx+\" \"+sy+\" \"+before_x);\n\t\t\t\t}\n\t\t\t}else if(map[sy][sx]==0){\n\t\t\t\tfor(int i=-1;i<=1;i++){\n\t\t\t\t\tint nx=i+sx, ny=sy+1;\n\t\t\t\t\tif(nx<0||nx>=x||ny<0)continue;\n\t\t\t\t\tresult+=dfs(nx, ny,sx);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo.put(sx+\" \"+sy+\" \"+before_x,result);\n\t\t\treturn result;\n\t\t}\n\n\n\t\tpublic AOJ0203() {\n\t\t\twhile(true){\n\t\t\t\tmemo = new HashMap<String, Integer>();\n\t\t\t\tx = in.nextInt();\n\t\t\t\ty = in.nextInt();\n\t\t\t\tif(x==0&&y==0)break;\n\t\t\t\tmap = new int[y+1][x];\n\t\t\t\tfor(int i=0;i<y;i++)for(int s=0;s<x;s++)map[i][s] = in.nextInt();\n\t\t\t\tint result = 0;\n\t\t\t\tfor(int i=0;i<x;i++)result += dfs(i,0,-1);\n\t\t\t\tSystem.out.println(result);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tint mod = 1000000007;\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint X = sc.nextInt();\n\t\t\tint Y = sc.nextInt();\n\t\t\tif ((X | Y) == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint[][] field = new int[Y][X];\n\t\t\tint[][] dp = new int[Y][X];\n\t\t\tfor (int i = 0; i < Y; i++) {\n\t\t\t\tfor (int j = 0; j < X; j++) {\n\t\t\t\t\tfield[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < X; i++) {\n\t\t\t\tif (field[0][i] == 0) {\n\t\t\t\t\tdp[0][i] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 1; i < Y; i++) {\n\t\t\t\tfor (int j = 0; j < X; j++) {\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\tif (field[i][j] == 1) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (j - 1 >= 0 && field[i][j] != 2\n\t\t\t\t\t\t\t&& field[i - 1][j - 1] != 1\n\t\t\t\t\t\t\t&& field[i - 1][j - 1] != 2) {\n\t\t\t\t\t\tcnt += dp[i - 1][j - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (field[i - 1][j] != 2) {\n\t\t\t\t\t\tcnt += dp[i - 1][j];\n\t\t\t\t\t}\n\t\t\t\t\tif (i - 2 > 0 && field[i - 2][j] == 2) {\n\t\t\t\t\t\tcnt += dp[i - 2][j];\n\t\t\t\t\t}\n\t\t\t\t\tif (j + 1 < X && field[i][j] != 2\n\t\t\t\t\t\t\t&& field[i - 1][j + 1] != 1\n\t\t\t\t\t\t\t&& field[i - 1][j + 1] != 2) {\n\t\t\t\t\t\tcnt += dp[i - 1][j + 1];\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][j] = cnt;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//System.out.println(\"------\");\n\t\t\t//debug2(dp);\n\t\t\tint ans = 0;\n\t\t\tfor (int i = 0; i < X; i++) {\n\t\t\t\tans += dp[Y - 1][i];\n\t\t\t\tif (Y - 2 >= 0 && field[Y - 2][i] == 2) {\n\t\t\t\t\tans += dp[Y - 2][i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(int[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.awt.geom.*;\nimport java.math.*;\n\npublic class Main {\n\n\tstatic final Scanner in = new Scanner(System.in);\n\tstatic final PrintWriter out = new PrintWriter(System.out,false);\n\tstatic boolean debug = false;\n\n\tstatic int h, w;\n\tstatic int[][] t, dp;\n\n\tstatic int[] dy = { 1, 1, 1,};\n\tstatic int[] dx = { -1, 0, 1};\n\n\tstatic int rec(int cy, int cx) {\n\t\tif (cy > h-1) return 1;\n\t\tif (cy == h-1) return t[cy][cx] != 1 ? 1 : 0;\n\t\tif (dp[cy][cx] != -1) return dp[cy][cx];\n\t\tif (t[cy][cx] == 2) return dp[cy][cx] = rec(cy+2, cx);\n\t\tint res = 0;\n\t\tfor (int i=0; i<3; i++) {\n\t\t\tint ny = cy + dy[i];\n\t\t\tint nx = cx + dx[i];\n\t\t\tif (nx < 0 || w <= nx) continue;\n\t\t\tif (t[ny][nx] == 1) continue;\n\t\t\tif (t[ny][nx] == 2 && nx != cx) continue;\n\t\t\tres += rec(ny, nx);\n\t\t}\n\t\treturn dp[cy][cx] = res;\n\t}\n\n\tstatic boolean solve() {\n\t\tw = in.nextInt();\n\t\th = in.nextInt();\n\t\tif (w + h == 0) return false;\n\n\t\tt = new int[h][w];\n\t\tfor (int i=0; i<h; i++) {\n\t\t\tfor (int j=0; j<w; j++) {\n\t\t\t\tt[i][j] = in.nextInt();\n\t\t\t}\n\t\t}\n\n\t\tdp = new int[h][w];\n\t\tfor (int i=0; i<h; i++) {\n\t\t\tArrays.fill(dp[i], -1);\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor (int i=0; i<w; i++) {\n\t\t\tif (t[0][i] != 1) {\n\t\t\t\tans += rec(0, i);\n\t\t\t}\n\t\t}\n\n\t\tout.println(ans);\n\n\t\treturn true;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tdebug = args.length > 0;\n\t\tlong start = System.nanoTime();\n\n\t\twhile(solve());\n\t\tout.flush();\n\n\t\tlong end = System.nanoTime();\n\t\tdump((end - start) / 1000000 + \" ms\");\n\t\tin.close();\n\t\tout.close();\n\t}\n\n\tstatic void dump(Object... o) { if (debug) System.err.println(Arrays.deepToString(o)); }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//A New Plan of Aizu Ski Resort\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint[][] move = {{1,-1},{1,0},{1,1}};\n\t\twhile(true){\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tif((w|h)==0)break;\n\t\t\tint[][] map = new int[h+1][w];\n\t\t\tint[][] dp = new int[h][w];\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)map[i][j]=sc.nextInt();\n\t\t\tfor(int j=0;j<w;j++)if(map[h-1][j]!=1)dp[h-1][j]=1;\n\t\t\tfor(int i=h-2;i>=0;i--){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tif(map[i][j]==1){\n\t\t\t\t\t\tdp[i][j] = 0;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(map[i][j]==2){\n\t\t\t\t\t\tif(i+2==h)dp[i][j]=1;\n\t\t\t\t\t\telse dp[i][j]=dp[i+2][j];\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tint s = 0;\n\t\t\t\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\t\t\t\tint ni = i+move[k][0];\n\t\t\t\t\t\t\tint nj = j+move[k][1];\n\t\t\t\t\t\t\tif(0<=nj&&nj<w){\n\t\t\t\t\t\t\t\tif(k!=1 && map[ni][nj]==2)continue;\n\t\t\t\t\t\t\t\ts+=dp[ni][nj];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp[i][j]=s;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint s=0;\n\t\t\tfor(int j=0;j<w;j++)s+=dp[0][j];\n\t\t\tSystem.out.println(s);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "// A New Plan of Aizu Ski Resort\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint w = sc.nextInt(), h = sc.nextInt();\n\t\t\tif ((w | h) == 0)\n\t\t\t\tbreak;\n\t\t\tint[][] field = new int[h][w];\n\t\t\tint[][] dp = new int[h][w];\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\t\tfield[i][j] = sc.nextInt();\n\t\t\tfor (int i = 0; i < h - 1; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (i == 0 && field[i][j] == 0)\n\t\t\t\t\t\tdp[i][j] = 1;\n\t\t\t\t\tswitch (field[i][j]) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tif (field[i + 1][j] != 1)\n\t\t\t\t\t\t\tdp[i + 1][j] += dp[i][j];\n\t\t\t\t\t\tif (j >= 1 && field[i + 1][j - 1] == 0)\n\t\t\t\t\t\t\tdp[i + 1][j - 1] += dp[i][j];\n\t\t\t\t\t\tif (j < w - 1 && field[i + 1][j + 1] == 0)\n\t\t\t\t\t\t\tdp[i + 1][j + 1] += dp[i][j];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tif (i < h - 2 && field[i + 2][j] != 1)\n\t\t\t\t\t\t\tdp[i + 2][j] += dp[i][j];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint result = 0;\n\t\t\tfor (int i = 0; i < w; i++) {\n\t\t\t\tresult += dp[h - 1][i];\n\t\t\t\tif (field[h - 2][i] == 2)\n\t\t\t\t\tresult += dp[h - 2][i];\n\t\t\t}\n\t\t\tSystem.out.println(result);\n\t\t}\n\t\tsc.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    void solve(){\n\tScanner sc = new Scanner(System.in);\n\n\twhile(true){\n\n\t    int w = sc.nextInt();\n\t    int h = sc.nextInt();\n\t    if(w==0 && h==0) break;\n\n\t    int[][] map = new int[h][w];\n\t    for(int i=0; i<h; i++){\n\t\tfor(int j=0; j<w; j++){\n\t\t    map[i][j] = sc.nextInt();\n\t\t}\n\t    }\n\n\t    int[][] dp = new int[h][w];\n\t    for(int i=0; i<w; i++){\n\t\tif(map[0][i]==0) dp[0][i] = 1;\n\t    }\n\n\t    for(int i=0; i<h; i++){\n\t\tfor(int j=0; j<w; j++){\n\t\t    if(map[i][j]==0){\n\t\t\tint n1 = 0, n2 = 0, n3 = 0, n4 = 0;\n\t\t\tif(i-1>=0 && map[i-1][j]==0) n1 = dp[i-1][j];\n\t\t\tif(i-1>=0 && j-1>=0 && map[i-1][j-1]==0) n2 = dp[i-1][j-1];\n\t\t\tif(i-1>=0 && j+1<w && map[i-1][j+1]==0) n3 = dp[i-1][j+1];\n\t\t\tif(i-2>=0 && map[i-2][j]==2) n4 = dp[i-2][j];\n\t\t\tdp[i][j] += n1 + n2 + n3 + n4;\n\t\t    }else if(map[i][j]==2){\n\t\t\tint n1 = 0, n2 = 0;\n\t\t\tif(i-1>=0 && map[i-1][j]==0) n1 = dp[i-1][j];\n\t\t\tif(i-2>=0 && map[i-2][j]==2) n2 = dp[i-2][j];\n\t\t\tdp[i][j] = n1 + n2;\n\t\t    }\n\t\t}\n\t    }\n\n\t    int ans = 0;\n\t    for(int i=0; i<w; i++){\n\t\tif(map[h-1][i]!=1) ans += dp[h-1][i];\n\t\tif(h-2>=0 && map[h-2][i]==2) ans += dp[h-2][i];\n\t    }\n\n\t    System.out.println(ans);\n\t}\n    }\n\n    public static void main(String[] args){\n\tnew Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint w, h;\n\t\tint map[][];\n\t\tint cnt[][];\n\n\t\twhile (true) {\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif ((w | h) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmap = new int[h][w];\n\t\t\tcnt = new int[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tmap[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (map[h - 1][j] == 0) {\n\t\t\t\t\tcnt[h - 1][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint sum;\n\t\t\tfor (int i = h - 2; 0 <= i; i--) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tsum = 0;\n\t\t\t\t\tif (map[i][j] == 0) {\n\t\t\t\t\t\tif (j + 1 < w && map[i + 1][j + 1] == 0) {\n\t\t\t\t\t\t\tsum += cnt[i + 1][j + 1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (0 <= j - 1 && map[i + 1][j - 1] == 0) {\n\t\t\t\t\t\t\tsum += cnt[i + 1][j - 1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (map[i + 1][j] != 1) {\n\t\t\t\t\t\t\tsum += cnt[i + 1][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (map[i][j] == 2) {\n\t\t\t\t\t\tif (i + 2 < h) {\n\t\t\t\t\t\t\tsum += cnt[i + 2][j];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsum = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcnt[i][j] = sum;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsum = 0;\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tsum += cnt[0][j];\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "// A New Plan of Aizu Ski Resort\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint w = sc.nextInt(), h = sc.nextInt();\n\t\t\tif ((w | h) == 0)\n\t\t\t\tbreak;\n\t\t\tint[][] field = new int[h][w];\n\t\t\tint[][] dp = new int[h][w];\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\t\tfield[i][j] = sc.nextInt();\n\t\t\tfor (int i = 0; i < h - 1; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (i == 0 && field[i][j] == 0)\n\t\t\t\t\t\tdp[i][j] = 1;\n\t\t\t\t\tswitch (field[i][j]) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tif (field[i + 1][j] != 1)\n\t\t\t\t\t\t\tdp[i + 1][j] += dp[i][j];\n\t\t\t\t\t\tif (j >= 1 && field[i + 1][j - 1] == 0)\n\t\t\t\t\t\t\tdp[i + 1][j - 1] += dp[i][j];\n\t\t\t\t\t\tif (j < w - 1 && field[i + 1][j + 1] == 0)\n\t\t\t\t\t\t\tdp[i + 1][j + 1] += dp[i][j];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tif (i < h - 2 && field[i + 2][j] != 1)\n\t\t\t\t\t\t\tdp[i + 2][j] += dp[i][j];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint result = 0;\n\t\t\tfor (int i = 0; i < w; i++) {\n\t\t\t\tresult += dp[h - 1][i];\n\t\t\t\tif (h >= 2 && field[h - 2][i] == 2)\n\t\t\t\t\tresult += dp[h - 2][i];\n\t\t\t}\n\t\t\tSystem.out.println(result);\n\t\t}\n\t\tsc.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\tpublic Main() {\n\t\tnew AOJ0203();\n\t}\n\t\n\t\n\tclass AOJ0203{\n\t\tint x,y;\n\t\tint[][] map;\n\t\t\n\t\tint bfs(int sx,int sy,int before_x){\n//\t\t\tSystem.out.println(sx+\" \"+sy+ \" \"+before_x);\n\t\t\tint result = 0;\n\t\t\tif(sy==y)return 1;\n\t\t\tif(map[sy][sx]==1)return 0;\n\t\t\tif(map[sy][sx]==2){\n\t\t\t\tif(before_x!=sx)return 0;\n\t\t\t\tint nx = sx,ny = sy+2;\n\t\t\t\tif(nx<0||nx>=x||ny<0||ny>y)return 0;\n\t\t\t\treturn bfs(nx,ny,sx);\n\t\t\t}else if(map[sy][sx]==0){\n\t\t\t\tfor(int i=-1;i<=1;i++){\n\t\t\t\t\tint nx = sx+i;\n\t\t\t\t\tint ny = sy+1;\n//\t\t\t\t\tSystem.out.println(nx+\" \"+ny);\n\t\t\t\t\tif(nx<0||nx>=x||ny<0||ny>y)continue;\n\t\t\t\t\tif(sy!=y-1)result += bfs(nx,ny,sx);\n\t\t\t\t\telse if(sy==y-1)return bfs(nx,ny,sx);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\t\n\t\t\n\t\tpublic AOJ0203() {\n\t\t\twhile(true){\n\t\t\t\tx = in.nextInt();\n\t\t\t\ty = in.nextInt();\n\t\t\t\tmap = new int[y+1][x];\n\t\t\t\tfor(int i=0;i<y;i++)for(int s=0;s<x;s++)map[i][s] = in.nextInt();\n\t\t\t\tint result = 0;\n\t\t\t\tfor(int i=0;i<x;i++)result += bfs(i,0,-1);\n\t\t\t\tSystem.out.println(result);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * A New Plan of Aizu Ski Resort\n * PCK2009 ??????9\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tint x, y;\n\t\t\tx = parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\ty = parseInt(line.substring(line.indexOf(' ') + 1));\n\t\t\tif ((x | y) == 0) break;\n\n\t\t\tint[][] course = new int[y + 4][x + 2];\n\t\t\tint[][] dp = new int[y + 4][x + 2];\n\n\t\t\tfor (int i = 0; i < y; i++) {\n\t\t\t\twords = br.readLine().split(\" \");\n\t\t\t\tfor (int j = 0; j < words.length; j++) {\n\t\t\t\t\tcourse[i + 2][j + 1] = parseInt(words[j]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//\n\t\t\tfor (int i = 1; i < x + 1; i++) {\n\t\t\t\tif (course[2][i] == 0) dp[2][i] = 1;\n\t\t\t}\n\n\t\t\tfor (int i = 2; i < y + 2; i++) {\n\t\t\t\tfor (int j = 1; j < x + 1; j++) {\n\t\t\t\t\tswitch (course[i][j]) {\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tif (course[i - 1][j - 1] == 0) {\n\t\t\t\t\t\t\t\tdp[i][j] += dp[i - 1][j - 1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (course[i - 1][j] == 0) {\n\t\t\t\t\t\t\t\tdp[i][j] += dp[i - 1][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (course[i - 1][j + 1] == 0) {\n\t\t\t\t\t\t\t\tdp[i][j] += dp[i - 1][j + 1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (course[i - 2][j] == 2) {\n\t\t\t\t\t\t\t\tdp[i][j] += dp[i - 2][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tdp[i][j] = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tif (course[i - 1][j] == 0) {\n\t\t\t\t\t\t\t\tdp[i][j] += dp[i - 1][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (course[i - 2][j] == 2) {\n\t\t\t\t\t\t\t\tdp[i][j] += dp[i - 2][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = y + 2; i < y + 4; i++) {\n\t\t\t\tfor (int j = 1; j < x + 1; j++) {\n\t\t\t\t\tif (course[i - 2][j] == 2) {\n\t\t\t\t\t\tdp[i][j] += dp[i - 2][j];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdp[i][j] += dp[i - 1][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//\n\t\t\tint sum = 0;\n\t\t\tfor (int i = 1; i < x + 1; i++) sum += dp[y + 3][i];\n\t\t\tSystem.out.println(sum);\n\t\t}//end while\n\t}//end main\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tint DP(int h,int w,int hw[][]){\n\t\tint result = 0;\n\t\tint yx[][] = new int [h][w];\n\t\tfor(int i = 0;i < w;i++){\n\t\t\tif(hw[0][i] == 0){\n\t\t\t\tyx[0][i] = 1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < h-1;i++){\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tif(j == 0){\n\t\t\t\t\tif(hw[i+1][j] == 0){\n\t\t\t\t\t\tif(w == 1){\n\t\t\t\t\t\t\tyx[i+1][j] = yx[i+1][j] + yx[i][j];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tyx[i+1][j] = yx[i+1][j] + yx[i][j] + yx[i][j+1];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else if(j == w-1){\n\t\t\t\t\tif(hw[i+1][j] == 0){\n\t\t\t\t\t\tyx[i+1][j] = yx[i+1][j] + yx[i][j] + yx[i][j-1];\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(hw[i+1][j] == 0){\n\t\t\t\t\t\tyx[i+1][j] = yx[i+1][j] + yx[i][j-1] + yx[i][j] + yx[i][j+1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tif(hw[i+1][j] == 2){\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\tif(i+cnt+1 == h-2){\n\t\t\t\t\t\t\tcnt = cnt + 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(i+cnt+2 == h)break;\n\t\t\t\t\t\t\tcnt = cnt + 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(hw[i+cnt+1][j] != 2)break;\n\t\t\t\t\t}\n\t\t\t\t\tyx[i+cnt+1][j] = yx[i+cnt+1][j] + yx[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < w;i++){\n\t\t\tresult = result + yx[h-1][i];\n\t\t}\n//\t\tfor(int i = 0;i < h;i++){\n//\t\t\tfor(int j = 0;j < w;j++){\n//\t\t\t\tSystem.out.print(yx[i][j]+\" \");\n//\t\t\t}\n//\t\t\tSystem.out.println();\n//\t\t}\n\t\treturn result;\n\t}\n\tvoid doIt() { \n\t\twhile(true){\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tint hw[][] = new int [h][w];\n\t\t\tif(h+w == 0)break;\n\t\t\tfor(int i = 0;i < h;i++){\n\t\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\t\thw[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(DP(h,w,hw));\n\t\t}\n     }\n    public static void main(String[] args) {\n    \t// TODO Auto-generated method stub\n    \tnew Main().doIt();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nclass Main {\n\tstatic int[][] map;\n\tstatic int x;\n\tstatic int y;\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tx = stdIn.nextInt();\n\t\t\ty = stdIn.nextInt();\n\t\t\tif(x == 0 && y == 0) break;\n\t\t\tmap = new int[y+1][x];\n\t\t\tfor(int i = 0; i < y; i++) {\n\t\t\t\tfor(int j = 0; j < x; j++) {\n\t\t\t\t\tmap[i][j] = stdIn.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sum = 0;\n\t\t\tfor(int i = 0; i < x; i++) {\n\t\t\t\tsum += solv(y,i,false);\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n\t\n\tstatic int solv(int y, int x, boolean jump) {\n\t\tint ret = 0;\n\t\t\n\t\tif(y < 0 || x < 0 || x >= Main.x) return ret;\n\t\t\n\t\tif(map[y][x] == 1) return ret;\n\t\t\n\t\tif(map[y][x] == 2 && !jump) return ret;\n\t\tif(y == 0) return 1;\n\t\t\n\t\tif(y >= 2 && map[y-2][x] == 2) {\n\t\t\tret += solv(y-2,x,true);\n\t\t}\n\t\tif(!jump && y != Main.y) {\n\t\tret += solv(y-1,x-1,false);\n\t\tret += solv(y-1,x+1,false);\n\t\t}\n\t\tret += solv(y-1,x,false);\n\t\t\n\t\treturn ret;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int X = sc.nextInt();\n\t\t\tfinal int Y = sc.nextInt();\n\t\t\t\n\t\t\tif(X == 0 && Y == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[][] map = new int[Y][X];\n\t\t\t\n\t\t\tfor(int i = 0; i < Y; i++){\n\t\t\t\tfor(int j = 0; j < X; j++){\n\t\t\t\t\tmap[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint[][] dp = new int[Y+2][X];\n\t\t\t\n\t\t\tfor(int i = 0; i < Y; i++){\n\t\t\t\tfor(int j = 0; j < X; j++){\n\t\t\t\t\tif(map[i][j] == 1){\n\t\t\t\t\t\tdp[i][j] = 0;\n\t\t\t\t\t\t//System.out.print(dp[i][j] + \" \");\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(i == 0){\n\t\t\t\t\t\tdp[i][j] = 1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdp[i][j] += (map[i-1][j] == 0 ? dp[i-1][j] : 0);\n\t\t\t\t\t\tif(map[i][j] != 2){\n\t\t\t\t\t\t\tdp[i][j] += j != 0 ? (map[i-1][j-1] == 0 ? dp[i-1][j-1] : 0) : 0;\n\t\t\t\t\t\t\tdp[i][j] += j != X-1 ? (map[i-1][j+1] == 0 ? dp[i-1][j+1] : 0) : 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(map[i][j] == 2){\n\t\t\t\t\t\tdp[i+2][j] = dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t//System.out.print(dp[i][j] + \" \");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//System.out.println();\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(int i = Y; i < Y+2; i++){\n\t\t\t\tfor(int j = 0; j < X; j++){\n\t\t\t\t\tSystem.out.print(dp[i][j] + \" \");\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t*/\n\t\t\tfor(int i = Y; i < Y+2; i++){\n\t\t\t\tfor(int j = 0; j < X; j++){\n\t\t\t\t\tdp[i][j] += dp[i-1][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint sum = 0;\n\t\t\tfor(int j = 0; j < X; j++){\n\t\t\t\tsum += dp[Y+1][j];\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\tpublic Main() {\n\t\tnew AOJ0203();\n\t}\n\t\n\t\n\tclass AOJ0203{\n\t\tint x,y;\n\t\tint[][] map;\n\t\t\n\t\tint bfs(int sx,int sy,int before_x){\n//\t\t\tSystem.out.println(sx+\" \"+sy+ \" \"+before_x);\n\t\t\tint result = 0;\n\t\t\tif(sy>=y)return 1;\n\t\t\tif(map[sy][sx]==1)return 0;\n\t\t\tif(map[sy][sx]==2){\n\t\t\t\tif(before_x!=sx)return 0;\n\t\t\t\tint nx = sx,ny = sy+2;\n\t\t\t\tif(nx<0||nx>=x||ny<0||ny>y)return 0;\n\t\t\t\treturn bfs(nx,ny,sx);\n\t\t\t}else if(map[sy][sx]==0){\n\t\t\t\tfor(int i=-1;i<=1;i++){\n\t\t\t\t\tint nx = sx+i;\n\t\t\t\t\tint ny = sy+1;\n//\t\t\t\t\tSystem.out.println(nx+\" \"+ny);\n\t\t\t\t\tif(nx<0||nx>=x||ny<0)continue;\n\t\t\t\t\tif(sy!=y-1)result += bfs(nx,ny,sx);\n\t\t\t\t\telse if(sy==y-1)return bfs(nx,ny,sx);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\t\n\t\t\n\t\tpublic AOJ0203() {\n\t\t\twhile(true){\n\t\t\t\tx = in.nextInt();\n\t\t\t\ty = in.nextInt();\n\t\t\t\tif(x==0&&y==0)break;\n\t\t\t\tmap = new int[y+1][x];\n\t\t\t\tfor(int i=0;i<y;i++)for(int s=0;s<x;s++)map[i][s] = in.nextInt();\n\t\t\t\tint result = 0;\n\t\t\t\tfor(int i=0;i<x;i++)result += bfs(i,0,-1);\n\t\t\t\tSystem.out.println(result);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nclass Main {\n\tstatic int[][] map;\n\tstatic int x;\n\tstatic int y;\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tx = stdIn.nextInt();\n\t\t\ty = stdIn.nextInt();\n\t\t\tif(x == 0 && y == 0) break;\n\t\t\tmap = new int[y+1][x];\n\t\t\tfor(int i = 0; i < y; i++) {\n\t\t\t\tfor(int j = 0; j < x; j++) {\n\t\t\t\t\tmap[i][j] = stdIn.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sum = 0;\n\t\t\tfor(int i = 0; i < x; i++) {\n\t\t\t\tsum += solv(y-1,i,false);\n\t\t\t\tif(y >= 2 && map[y-1][i] == 2) {\n\t\t\t\t\tsum += solv(y-1,i,true);\n\t\t\t\t}\n\t\t\t\tif(y >= 2 && map[y-2][i] == 2) {\n\t\t\t\t\tsum += solv(y-2,i,true);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n\t\n\tstatic int solv(int y, int x, boolean jump) {\n\t\tint ret = 0;\n\t\t\n\t\tif(y < 0 || x < 0 || x >= Main.x) return 0;\n\t\t\n\t\tif(map[y][x] == 1) return 0;\n\t\t\n\t\tif(map[y][x] == 2 && !jump) return 0;\n\t\tif(y == 0) return 1;\n\t\t\n\t\tif(y >= 2 && map[y-2][x] == 2) {\n\t\t\tret += solv(y-2,x,true);\n\t\t}\n\t\tif(!jump) {\n\t\tret += solv(y-1,x-1,false);\n\t\tret += solv(y-1,x+1,false);\n\t\t}\n\t\tret += solv(y-1,x,false);\n\t\t\n\t\treturn ret;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tint mod = 1000000007;\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint X = sc.nextInt();\n\t\t\tint Y = sc.nextInt();\n\t\t\tif ((X | Y) == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint[][] field = new int[Y][X];\n\t\t\tint[][] dp = new int[Y][X];\n\t\t\tfor (int i = 0; i < Y; i++) {\n\t\t\t\tfor (int j = 0; j < X; j++) {\n\t\t\t\t\tfield[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < X; i++) {\n\t\t\t\tif (field[0][i] == 0) {\n\t\t\t\t\tdp[0][i] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 1; i < Y; i++) {\n\t\t\t\tfor (int j = 0; j < X; j++) {\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\tif (field[i][j] == 1) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (j - 1 >= 0 && field[i][j] != 2\n\t\t\t\t\t\t\t&& field[i - 1][j - 1] != 1\n\t\t\t\t\t\t\t&& field[i - 1][j - 1] != 2) {\n\t\t\t\t\t\tcnt += dp[i - 1][j - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (field[i - 1][j] != 2) {\n\t\t\t\t\t\tcnt += dp[i - 1][j];\n\t\t\t\t\t\tif (i - 2 > 0 && field[i - 2][j] == 2) {\n\t\t\t\t\t\t\tcnt += dp[i - 2][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (j + 1 < X && field[i][j] != 2\n\t\t\t\t\t\t\t&& field[i - 1][j + 1] != 1\n\t\t\t\t\t\t\t&& field[i - 1][j + 1] != 2) {\n\t\t\t\t\t\tcnt += dp[i - 1][j + 1];\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][j] = cnt;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = 0;\n\t\t\tfor (int i = 0; i < X; i++) {\n\t\t\t\tans += dp[Y - 1][i];\n\t\t\t\tif (field[Y - 2][i] == 2) {\n\t\t\t\t\tans += dp[Y - 2][i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(int[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n\n\n\tpublic static void main(String args[]){\n\t\tScanner in = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint w = in.nextInt(), h = in.nextInt();\n\t\t\tif(w==0 && h==0) break;\n\t\t\tint board[][] = new int[h][w];\n\t\t\tint dp[][] = new int[h+1][w];\n\t\t\tfor(int i=0; i<h; i++)for(int j=0; j<w; j++) board[i][j] = in.nextInt();\n\t\t\tfor(int j=0; j<w; j++) dp[0][j] = 1;\n\t\t\tfor(int i=0; i<h-1; i++){\n\t\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\t\tif(board[i][j] == 0){\n\t\t\t\t\t\tif(j>0 && board[i+1][j-1] != 2) dp[i+1][j-1] += dp[i][j];\n\t\t\t\t\t\tif(j<w-1 && board[i+1][j+1] != 2) dp[i+1][j+1] += dp[i][j];\n\t\t\t\t\t\tdp[i+1][j] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t\telse if(board[i][j] == 2){\n\t\t\t\t\t\tdp[i+2][j] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0; j<w; j++)if(board[h-1][j] != 1) dp[h][j] += dp[h-1][j];\n\t\t\tint ans = 0;\n\t\t\tfor(int j=0; j<w; j++) ans += dp[h][j];\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n\n\n\tpublic static void main(String args[]){\n\t\tScanner in = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint w = in.nextInt(), h = in.nextInt();\n\t\t\tint board[][] = new int[h][w];\n\t\t\tint dp[][] = new int[h+1][w];\n\t\t\tfor(int i=0; i<h; i++)for(int j=0; j<w; j++) board[i][j] = in.nextInt();\n\t\t\tfor(int j=0; j<w; j++) dp[0][j] = 1;\n\t\t\tfor(int i=0; i<h-1; i++){\n\t\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\t\tif(board[i][j] == 0){\n\t\t\t\t\t\tif(j>0 && board[i+1][j-1] != 2) dp[i+1][j-1] += dp[i][j];\n\t\t\t\t\t\tif(j<w-1 && board[i+1][j+1] != 2) dp[i+1][j+1] += dp[i][j];\n\t\t\t\t\t\tdp[i+1][j] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t\telse if(board[i][j] == 2){\n\t\t\t\t\t\tdp[i+2][j] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0; j<w; j++)if(board[h-1][j] != 1) dp[h][j] += dp[h-1][j];\n\t\t\tint ans = 0;\n\t\t\tfor(int j=0; j<w; j++) ans += dp[h][j];\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tm = scanner.nextInt();\n\t\t\tn = scanner.nextInt();\n\t\t\tif ((m | n) == 0)\n\t\t\t\tbreak;\n\t\t\tmap = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tmap[i][j] = scanner.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcount = 0;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tslove(i, 0, 0);\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\n\tprivate void slove(int x, int y, int r) {\n\t\tif (y == n) {\n\t\t\tcount++;\n\t\t\treturn;\n\t\t}\n\t\tif (x < 0 || x == m)\n\t\t\treturn;\n\n\t\tif (map[y][x] == 1)\n\t\t\treturn;\n\t\tif (map[y][x] == 2 && r != 1)\n\t\t\treturn;\n\n\t\tif (y == n - 1) {\n\t\t\tcount++;\n\t\t\treturn;\n\t\t}\n\t\tif (map[y][x] == 2)\n\t\t\tslove(x, y + 2, 1);\n\t\telse\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tslove(x + i - 1, y + 1, i);\n\t\t\t}\n\t}\n\n\tint count;\n\tint m;\n\tint n;\n\tint[][] map;\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * A New Plan of Aizu Ski Resort\n * PCK2009 ??????9\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tint x, y;\n\t\t\tx = parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\ty = parseInt(line.substring(line.indexOf(' ') + 1));\n\t\t\tif ((x | y) == 0) break;\n\n\t\t\tint[][] course = new int[y + 4][x + 2];\n\t\t\tint[][] dp = new int[y + 4][x + 2];\n\n\t\t\tfor (int i = 0; i < y; i++) {\n\t\t\t\twords = br.readLine().split(\" \");\n\t\t\t\tfor (int j = 0; j < words.length; j++) {\n\t\t\t\t\tcourse[i + 2][j + 1] = parseInt(words[j]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//\n\t\t\tfor (int i = 1; i < x + 1; i++) {\n\t\t\t\tif (course[2][i] == 0) dp[2][i] = 1;\n\t\t\t}\n\n\t\t\tfor (int i = 2; i < y + 2; i++) {\n\t\t\t\tfor (int j = 1; j < x + 1; j++) {\n\t\t\t\t\tswitch (course[i][j]) {\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tif (course[i - 1][j - 1] == 0) {\n\t\t\t\t\t\t\t\tdp[i][j] += dp[i - 1][j - 1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (course[i - 1][j] == 0) {\n\t\t\t\t\t\t\t\tdp[i][j] += dp[i - 1][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (course[i - 1][j + 1] == 0) {\n\t\t\t\t\t\t\t\tdp[i][j] += dp[i - 1][j + 1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (course[i - 2][j] == 2) {\n\t\t\t\t\t\t\t\tdp[i][j] += dp[i - 2][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tif (course[i - 1][j] == 0) {\n\t\t\t\t\t\t\t\tdp[i][j] += dp[i - 1][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (course[i - 2][j] == 2) {\n\t\t\t\t\t\t\t\tdp[i][j] += dp[i - 2][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = y + 2; i < y + 4; i++) {\n\t\t\t\tfor (int j = 1; j < x + 1; j++) {\n\t\t\t\t\tif (course[i - 1][j] == 0) {\n\t\t\t\t\t\tdp[i][j] += dp[i - 1][j];\n\t\t\t\t\t}\n\t\t\t\t\tif (course[i - 2][j] == 2) {\n\t\t\t\t\t\tdp[i][j] += dp[i - 2][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//\n\t\t\tint sum = 0;\n\t\t\tfor (int i = 1; i < x + 1; i++) sum += dp[y + 3][i];\n\t\t\tSystem.out.println(sum);\n\t\t}//end while\n\t}//end main\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\tpublic Main() {\n\t\tnew AOJ0203();\n\t}\n\t\n\t\n\tclass AOJ0203{\n\t\tint x,y;\n\t\tint[][] map;\n\t\t\n\t\tint bfs(int sx,int sy,int before_x){\n//\t\t\tSystem.out.println(sx+\" \"+sy+ \" \"+before_x);\n\t\t\tint result = 0;\n\t\t\tif(sy==y)return 1;\n\t\t\tif(map[sy][sx]==1)return 0;\n\t\t\tif(map[sy][sx]==2){\n\t\t\t\tif(before_x!=sx)return 0;\n\t\t\t\tint nx = sx,ny = sy+2;\n\t\t\t\tif(nx<0||nx>=x||ny<0||ny>y)return 0;\n\t\t\t\treturn bfs(nx,ny,sx);\n\t\t\t}else if(map[sy][sx]==0){\n\t\t\t\tfor(int i=-1;i<=1;i++){\n\t\t\t\t\tint nx = sx+i;\n\t\t\t\t\tint ny = sy+1;\n//\t\t\t\t\tSystem.out.println(nx+\" \"+ny);\n\t\t\t\t\tif(nx<0||nx>=x||ny<0||ny>y)continue;\n\t\t\t\t\tif(sy!=y-1)result += bfs(nx,ny,sx);\n\t\t\t\t\telse if(sy==y-1)return bfs(nx,ny,sx);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\t\n\t\t\n\t\tpublic AOJ0203() {\n\t\t\twhile(true){\n\t\t\t\tx = in.nextInt();\n\t\t\t\ty = in.nextInt();\n\t\t\t\tif(x==0&&y==0)break;\n\t\t\t\tmap = new int[y+1][x];\n\t\t\t\tfor(int i=0;i<y;i++)for(int s=0;s<x;s++)map[i][s] = in.nextInt();\n\t\t\t\tint result = 0;\n\t\t\t\tfor(int i=0;i<x;i++)result += bfs(i,0,-1);\n\t\t\t\tSystem.out.println(result);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tint m, n;\n\tint[][] a;\n\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tm=sc.nextInt();\n\t\t\tn=sc.nextInt();\n\t\t\tif((m|n)==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ta=new int[n][m];\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\t\ta[j][i]=sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve(){\n\t\tlong[][] dp=new long[n+1][m];\n\t\tfor(int i=0; i<m; i++){\n\t\t\tif(a[0][i]==0){\n\t\t\t\tdp[0][i]=1;\n\t\t\t}\n\t\t}\n\t\tfor(int j=0; j<n-1; j++){\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tswitch(a[j][i]){\n\t\t\t\tcase 0:\n\t\t\t\t\tif(i-1>=0&&a[j+1][i-1]==0)\n\t\t\t\t\t\tdp[j+1][i-1]+=dp[j][i];\n\t\t\t\t\tif(a[j+1][i]!=1)\n\t\t\t\t\t\tdp[j+1][i]+=dp[j][i];\n\t\t\t\t\tif(i+1<m&&a[j+1][i+1]==0)\n\t\t\t\t\t\tdp[j+1][i+1]+=dp[j][i];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tif(j>=n-2||a[j+2][i]!=1)\n\t\t\t\t\t\tdp[j+2][i]+=dp[j][i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong ans=0;\n\t\tfor(int j=n-1; j<n+1; j++){\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tans+=dp[j][i];\n\t\t\t}\n\t\t}\n\t\tprintln(ans+\"\");\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\n    int w,h;\n    int[][] grid;\n    int[] dx = {-1,0,1,0};\n    int[] dy = {-1,-1,-1,-2};\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            w = sc.nextInt();\n            h = sc.nextInt();\n            if(w==0 && h==0) break;\n\n            grid = new int[h][w];\n            for(int i=0; i<h; i++){\n                for(int j=0; j<w; j++){\n                    grid[i][j] = sc.nextInt();\n                }\n            }\n\n            int[][] dp = new int[h][w];\n            for(int i=0; i<w; i++){\n                if(grid[0][i]==0) dp[0][i] = 1;\n            }\n\n            for(int i=0; i<h; i++){\n                for(int j=0; j<w; j++){\n                    if(grid[i][j]==0){\n                        for(int k=0; k<4; k++){\n                            int nx = j+dx[k], ny = i+dy[k];\n                            if(nx<0 || nx>=w || ny<0 || ny>=h) continue;\n                            if((k<=2 && grid[ny][nx]==0) || (k==3 && grid[ny][nx]==2)){\n                                dp[i][j] += dp[ny][nx];\n                            }\n                        }\n                    }else if(grid[i][j]==2){\n                        if(i-1>=0 && grid[i-1][j]==0) dp[i][j] += dp[i-1][j];\n                        if(i-2>=0 && grid[i-2][j]==2) dp[i][j] += dp[i-2][j];\n                    }\n                }\n                //System.out.println(Arrays.toString(dp[i]));\n            }\n\n            int ans = 0;\n            for(int i=0; i<w; i++){\n                ans += dp[h-1][i];\n                if(h>=3 && grid[h-2][i]==2) ans += dp[h-2][i];\n            }\n\n            System.out.println(ans);\n        }\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic int X,Y,ans;\n\tstatic int[][] field;\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tX=cin.nextInt();\n\t\t\tY=cin.nextInt();\n\t\t\tans=0;\n\t\t\tif(X+Y==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfield = new int[Y+2][X+2];\n\t\t\tfor(int i = 0;i<Y+2;i++){\n\t\t\t\tfor(int j = 0;j<X+2;j++){\n\t\t\t\t\tfield[i][j]=-1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0;i<Y;i++){\n\t\t\t\tfor(int j = 1;j<X+1;j++){\n\t\t\t\t\tfield[i][j]=cin.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0;i<X+2;i++){\n\t\t\t\tif(field[0][i]==0){\n\t\t\t\t\tski(0,i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tstatic void ski(int y,int x){\n\t\t//System.out.println(y+\" \" + x);\n\t\tif(y>=Y-1 && field[y][x]!=2){\n\t\t\t//System.out.println(\"aaaaaaaa\"+y+\" \" + x);\n\t\t\tans++;\n\t\t\treturn;\n\t\t}\n\t\tif(field[y][x]==2&&(field[y+2][x]==0||field[y+2][x]==2||field[y+2][x]==-1)){\n\t\t\tski(y+2,x);\n\t\t\treturn;\n\t\t}\n\t\tif(field[y+1][x]==0){\n\t\t\tski(y+1,x);\n\t\t}\n\t\telse if(field[y+1][x]==2){\n\t\t\tski(y+1,x);\n\t\t}\n\t\t\n\t\tif(field[y+1][x-1]==0){\n\t\t\tski(y+1,x-1);\n\t\t}\n\t\tif(field[y+1][x+1]==0){\n\t\t\tski(y+1,x+1);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic int H,W;\n\tstatic int[][] field;\n\tstatic int[][] dp;\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tW=cin.nextInt();\n\t\t\tH=cin.nextInt();\n\t\t\tif(W+H==0)break;\n\t\t\tfield=new int[H+2][W];\n\t\t\tdp=new int[H+2][W];\n\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\tfield[i][j]=cin.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<W;i++){\n\t\t\t\tif(field[0][i]==0)dp[0][i]=1;\n\t\t\t}\n\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\tif(field[i][j]==0){\n\t\t\t\t\t\tif(i!=H-1){\n\t\t\t\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\t\t\t\tif(j+k<0||j+k>=W)continue;\n\t\t\t\t\t\t\t\tif(field[i+1][j+k]==1)continue;\n\t\t\t\t\t\t\t\tif(k!=0&&field[i+1][j+k]==2)continue;\n\t\t\t\t\t\t\t\tdp[i+1][j+k]+=dp[i][j];\n\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tdp[i+1][j]+=dp[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(field[i][j]==2){\n\t\t\t\t\t\tdp[i+2][j]+=dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans=0;\n\t\t\tfor(int i=H;i<H+1;i++){\n\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\tans+=dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t\t\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint X = sc.nextInt();\n\t\t\tint Y = sc.nextInt();\n\t\t\tif (X == 0 && Y == 0)\n\t\t\t\tbreak;\n\t\t\tint[][] field = new int[X][Y];\n\t\t\tint[][] movable = new int[X][Y];\n\t\t\tfor (int i = 0; i < Y; i++)\n\t\t\t\tfor (int j = 0; j < X; j++)\n\t\t\t\t\tmovable[j][i] = 0;\n\t\t\tfor (int i = 0; i < Y; i++)\n\t\t\t\tfor (int j = 0; j < X; j++)\n\t\t\t\t\tfield[j][i] = sc.nextInt();\n\t\t\tfor (int i = Y - 1; i >= 0; i--)\n\t\t\t\tfor (int j = 0; j < X; j++) {\n\t\t\t\t\tif (field[j][i] == 0) {\n\t\t\t\t\t\tif (i == Y - 1)\n\t\t\t\t\t\t\tmovable[j][i] = 1;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tmovable[j][i] += movable[j][i + 1];\n\t\t\t\t\t\t\tif (j > 0 && field[j - 1][i + 1] != 2)\n\t\t\t\t\t\t\t\tmovable[j][i] += movable[j - 1][i + 1];\n\t\t\t\t\t\t\tif (j < X - 1 && field[j + 1][i + 1] != 2)\n\t\t\t\t\t\t\t\tmovable[j][i] += movable[j + 1][i + 1];\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (field[j][i] == 1)\n\t\t\t\t\t\tmovable[j][i] = 0;\n\t\t\t\t\telse if (field[j][i] == 2) {\n\t\t\t\t\t\tif (i >= Y - 2)\n\t\t\t\t\t\t\tmovable[j][i] = 1;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tmovable[j][i] = movable[j][i + 2];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tint result = 0;\n\t\t\tfor (int i = 0; i < X; i++)\n\t\t\t\tresult += movable[i][0];\n\t\t\tSystem.out.println(result);\n\t\t}\n\t\tsc.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.*;\n\nimport static java.lang.Math.*;\nimport static java.lang.System.out;\n\n// AOJ\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().AOJ0203();\n\t}\n\t\n\tvoid AOJ0203(){\t// A New Plan of Aizu Ski Resort\n\t\twhile(sc.hasNext()){\n\t\t\tint x=sc.nextInt(), y=sc.nextInt();\n\t\t\tif(x==0)\tbreak;\n\t\t\tint[][] dp=new int[x+3][y+3],b=new int[x+2][y+2];\n\t\t\tfor(int j=1; j<=y; j++){\n\t\t\t\tfor(int i=1; i<=x; i++)\tb[i][j]=sc.nextInt();\n\t\t\t}\n\t\t\tfor(int i=1; i<=x; i++)\tdp[i][1]= b[i][1]==1?0:1;\n\t\t\tfor(int j=1; j<=y; j++){\n\t\t\t\tfor(int i=1; i<=x; i++){\n\t\t\t\t\tif(b[i][j]==2)\tdp[i][j]= b[i][j-1]!=2?dp[i][j-1]:0;\n\t\t\t\t\telse if(b[i][j]==0){\n\t\t\t\t\t\tfor(int k=i-1; k<=i+1; k++)\tdp[i][j]+= b[k][j-1]==0?dp[k][j-1]:0;\t\n\t\t\t\t\t}\n\t\t\t\t\tif(j>2 && b[i][j]!=1)\tdp[i][j]+= b[i][j-2]==2?dp[i][j-2]:0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// debug\n\t\t\t\n\t\t\tfor(int j=1; j<=y; j++){\n\t\t\t\tfor(int i=1; i<=x; i++)\tout.print(dp[i][j]+\" \");\n\t\t\t\tout.println();\n\t\t\t}\n\t\t\t\n\t\t\tint ans=0;\n\t\t\tfor(int i=1; i<=x; i++)\tans+= dp[i][y]+(b[i][y-1]==2?dp[i][y-1]:0);\n\t\t\tout.println(ans);\n\t\t}\n\t\t\n\t}\n\t\n\t// RE\n\tvoid AOJ0089(){\t// The Shortest Path on A Rhombic Path\n\t\tint[][] dp=new int[200][200];\n\t\tdp[1][1]=sc.nextInt();\n\t\tint idx=2, lastLen=1;\n\t\twhile(sc.hasNext()){\n\t\t\tString s=sc.next();\n\t\t\tScanner sc2=new Scanner(s).useDelimiter(\",\");\n\t\t\tint len=(int)((double)s.length()/(double)2+0.5);\n\t\t\tfor(int i=1; i<=len; i++){\n\t\t\t\tif(len>lastLen)\tdp[i][idx]=sc2.nextInt()+max(dp[i][idx-1], dp[i-1][idx-1]);\n\t\t\t\telse\tdp[i][idx]=sc2.nextInt()+max(dp[i][idx-1], dp[i+1][idx-1]);\n\t\t\t}\n\t\t\tlastLen=len;\n\t\t\tidx++;\n\t\t}\n\t\t//debug\n\t\t\n\t\tfor(int i=0; i<=idx; i++){\n\t\t\tfor(int j=0; j<=(int)((double)idx/2+0.5); j++)\tout.printf(\"%4d\",dp[j][i]);\n\t\t\tout.println();\n\t\t}\n\t\t\n\t\tout.println(dp[1][idx-1]);\n\t}\n\t\n\tvoid AOJ0004(){\n\t\t//while(sc.hasNext()){\n\t\t\t// int a=sc.nextInt(), b=sc.nextInt(), c=sc.nextInt(), d=sc.nextInt(), e=sc.nextInt(), f=sc.nextInt();\n\t\t\t// ax + by = c\n\t\t\t// dx + ey = f\n\t\t//}\n\t}\n\t\n\tvoid AOJ0042(){\t// A Thief\n\t\tint num=1;\n\t\twhile(sc.hasNext()){\n\t\t\tint w=sc.nextInt();\n\t\t\tif(w==0)\tbreak;\n\t\t\tint n=sc.nextInt();\n\t\t\tint[][] dp=new int[n+1][w+1];\n\t\t\tint[] ww=new int[n+1], pp=new int[n+1];\n\t\t\tfor(int i=1; i<=n; i++){\n\t\t\t\tScanner sc2=new Scanner(sc.next()).useDelimiter(\",\");\n\t\t\t\tpp[i]=sc2.nextInt();\n\t\t\t\tww[i]=sc2.nextInt();\n\t\t\t}\n\t\t\tint ans=0, wei=Integer.MAX_VALUE;\n\t\t\tfor(int i=1; i<=n; i++){\n\t\t\t\tfor(int j=1; j<=w; j++){\n\t\t\t\t\tdp[i][j]=max(dp[i-1][j], j>=ww[i]?dp[i-1][j-ww[i]]+pp[i]:dp[i-1][j]);\n\t\t\t\t\tif(dp[i][j]>ans){\n\t\t\t\t\t\twei=j;\n\t\t\t\t\t\tans=dp[i][j];\n\t\t\t\t\t}else if(dp[i][j]==ans){\n\t\t\t\t\t\twei=min(wei,j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//debug\n\t\t\t/*\n\t\t\tfor(int i=0; i<=w; i++){\n\t\t\t\tfor(int j=0; j<=n; j++)\tout.printf(\"%4d\",dp[j][i]);\n\t\t\t\tout.println();\n\t\t\t}\n\t\t\t*/\n\t\t\t\n\t\t\tout.println(\"Case \"+(num++)+\":\");\n\t\t\tout.println(ans);\n\t\t\tout.println(wei);\n\t\t}\n\t}\n\n\tvoid AOJ0003(){\n\t\tint n=sc.nextInt();\n\t\twhile(n-->0){\n\t\t\tint[] a=new int[3];\n\t\t\tfor(int i=0; i<3; i++)\ta[i]=sc.nextInt();\n\t\t\tArrays.sort(a);\n\t\t\tif(a[2]*a[2]==(a[1]*a[1])+(a[0]*a[0]))\tout.println(\"YES\");\n\t\t\telse\tout.println(\"NO\");\n\t\t}\n\t}\n\t\n\tvoid AOJ0002(){\n\t\twhile(sc.hasNext())\tout.println(new String(\"\"+(sc.nextInt()+sc.nextInt())).length());\n\t}\n\t\n\tvoid AOJ0516(){\n\t\twhile(sc.hasNext()){\n\t\t\tint n=sc.nextInt(), k=sc.nextInt(), ans=0;\n\t\t\tif(n==0)\tbreak;\n\t\t\tint[] sum=new int[n+1];\n\t\t\tfor(int i=1; i<=n; i++)\tsum[i]=sum[i-1]+sc.nextInt();\n\t\t\tfor(int i=k; i<=n; i++)\tans=max(ans, sum[i]-sum[i-k]);\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\t\n\tc547[][] r;\n\tfinal int MOD547=100000;\n\tvoid AOJ0547(){\t// Commute routes\n\t\twhile(sc.hasNext()){\n\t\t\tint w=sc.nextInt(), h=sc.nextInt();\n\t\t\tif(w<2)\tbreak;\n\t\t\tr=new c547[w+1][h+1];\n\t\t\tr[2][1]=new c547(0,0,0,1);\tr[1][2]=new c547(0,1,0,0);\n\t\t\tfor(int x=1; x<=w; x++){\n\t\t\t\tfor(int y=1; y<=h; y++)\tr[x][y] = r[x][y]==null?solve547(x,y): r[x][y];\n\t\t\t}\n\t\t\t//r[w][h].list();\n\t\t\tout.println(r[w][h].sum());\n\t\t}\n\t}\n\tc547 solve547(int x, int y){\n\t\tint s1=y-1>0? r[x][y-1].w2:0;\n\t\tint s2=y-1>0? (r[x][y-1].s1+r[x][y-1].s2)%MOD547:0;\n\t\tint w1=x-1>0? r[x-1][y].s2:0;\n\t\tint w2=x-1>0? (r[x-1][y].w1+r[x-1][y].w2)%MOD547:0;\n\t\treturn new c547(s1, s2, w1, w2);\n\t}\n\tclass c547{\n\t\tint s1, s2, w1, w2;\n\t\tc547(int s1, int s2, int w1, int w2){\n\t\t\tthis.s1=s1; this.s2=s2; this.w1=w1; this.w2=w2;\n\t\t}\n\t\tint sum(){\n\t\t\treturn (this.s1 + this.s2 + this.w1 + this.w2)%MOD547;\n\t\t}\n\t\tvoid list(){\n\t\t\tout.println(\"(\"+this.s1+\" \"+this.s2+\" \"+this.w1+\" \"+this.w2+\")\");\n\t\t}\n\t}\n\t\n\tint[][] a1209;\n\tvoid AOJ1209(){\n\t\twhile(sc.hasNext()){\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n<=0)\tbreak;\n\t\t\ta1209=new int[18][n+1];\n\t\t\tfor(int i=0; i<=n; i++)\ta1209[1][i]=1;\n\t\t\tfor(int x=2; x<=17; x++){\n\t\t\t\tfor(int y=1; y<=n; y++)\ta1209[x][y]=solve1209(x,y);\n\t\t\t}\n\t\t\tint ans=0;\n\t\t\tfor(int i=1; i<=17; i++)\tans+=a1209[i][n];\n\t\t\tout.println(ans);\n\t\t\t\n\t\t\t// debug\n\t\t\t/*\n\t\t\tfor(int i=0; i<=n; i++){\n\t\t\t\tfor(int j=0; j<=17; j++)\tout.print(a1209[j][i]+\" \");\n\t\t\t\tout.println();\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t}\n\tint solve1209(int x, int y){\n\t\tint ans=0;\n\t\tfor(int i=x;i>0; i--)\tans+= y-(x*x)>=0?a1209[i][y-(x*x)]:0;\n\t\treturn ans;\n\t}\n\t\n\tint[][] r515;\n\tboolean[][] b515;\n\tvoid AOJ0515(){\t// School Road\n\t\twhile(sc.hasNext()){\n\t\t\tint xn=sc.nextInt(), yn=sc.nextInt();\n\t\t\tif(xn<=0)\tbreak;\n\t\t\tint n=sc.nextInt();\n\t\t\tb515 = new boolean[xn+1][yn+1];\n\t\t\tfor(int i=0; i<n; i++)\tb515[sc.nextInt()][sc.nextInt()]=true;\n\t\t\tr515=new int[xn+1][yn+1];\n\t\t\tr515[1][1]=1;\n\t\t\tfor(int x=1; x<=xn; x++){\n\t\t\t\tfor(int y=1; y<=yn; y++){\n\t\t\t\t\tif(x==1&&y==1)\tcontinue;\n\t\t\t\t\tr515[x][y]=solve515(x,y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(r515[xn][yn]);\n\t\t}\n\t}\n\tint solve515(int x, int y){\n\t\tint ans=0;\n\t\tif(!b515[x][y]){\n\t\t\tans+= y-1>0? r515[x][y-1]:0;\n\t\t\tans+= x-1>0? r515[x-1][y]:0;\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\t\n\tint[] a168;\n\tvoid AOJ0168(){\t// Kannondou\n\t\twhile(sc.hasNext()){\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n<=0)\tbreak;\n\t\t\ta168=new int[n+1];\n\t\t\ta168[0]=1;\n\t\t\tfor(int i=1; i<=n; i++)\ta168[i]=solve168(i);\n\t\t\tint day=(a168[n]/10) + (a168[n]%10==0? 0: 1);\n\t\t\t// out.println(\"n\"+a168[n]+\" day\"+day);\n\t\t\tout.println(((day/365) + (day%365==0?0 :1)));\n\t\t}\n\t}\n\tint solve168(int a){\n\t\tint ans=0;\n\t\tfor(int i=a-1; i>=a-3; i--)\tans+= i>=0? a168[i]: 0;\n\t\treturn ans;\n\t}\n\t\n\tvoid AOJ0176(){\t// What Color?\n\t\tint[] R = {0,0,0,0,255,255,255,255};\n\t\tint[] G = {0,0,255,255,0,0,255,255};\n\t\tint[] B = {0,255,0,255,0,255,0,255};\n\t\tHashMap<Integer,String> dic = new HashMap<Integer,String>();\n\t\tdic.put(0, \"black\");\tdic.put(1, \"blue\");\tdic.put(2, \"lime\");\tdic.put(3, \"aqua\");\n\t\tdic.put(4, \"red\");\tdic.put(5, \"fuchsia\");\tdic.put(6, \"yellow\");\tdic.put(7, \"white\");\n\t\twhile(sc.hasNext()){\n\t\t\tString s=sc.next();\n\t\t\tif(s.equals(\"0\"))\tbreak;\n\t\t\tint r=Integer.parseInt(\"\"+s.charAt(1)+s.charAt(2),16), g=Integer.parseInt(\"\"+s.charAt(3)+s.charAt(4),16), b=Integer.parseInt(\"\"+s.charAt(5)+s.charAt(6),16);\n\t\t\tint index=0;\n\t\t\tdouble last=Double.MAX_VALUE;\n\t\t\tfor(int i=0; i<8; i++){\n\t\t\t\tdouble d=sqrt((abs(r-R[i])<<1)+(abs(g-G[i])<<1)+(abs(b-B[i])<<1));\n\t\t\t\tindex = last>d? i : index;\n\t\t\t\tlast = last>d? d : last;\n\t\t\t}\n\t\t\tout.println(dic.get(index));\n\t\t}\n\t}\n\t\n\tvoid AOJ0175(){\t// A King in Hawaii\n\t\twhile(sc.hasNext()){\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n<0)\tbreak;\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile(n!=0){\n\t\t\t\t//out.println(n&3);\n\t\t\t\tsb.append(n&3);\n\t\t\t\tn=n>>2;\n\t\t\t}\n\t\t\tout.println(sb.length()>0? sb.reverse(): 0);\n\t\t}\n\t}\n\t\n\tvoid AOJ0031(){\t// Weight\n\t\twhile(sc.hasNext()){\n\t\t\tint n=sc.nextInt();\n\t\t\tint temp=Integer.lowestOneBit(n);\n\t\t\tout.print(temp);\n\t\t\tn=(n^temp);\n\t\t\twhile(n!=0){\n\t\t\t\ttemp=Integer.lowestOneBit(n);\n\t\t\t\tout.print(\" \"+temp);\n\t\t\t\tn=(n^temp);\n\t\t\t}\n\t\t\tout.println();\n\t\t}\n\t}\n\t\n\tvoid AOJ0051(){\t// Differential II\n\t\tint n=sc.nextInt();\n\t\tfor(int i=0; i<n; i++){\n\t\t\tchar[] c = sc.next().toCharArray();\n\t\t\tint[] a = new int[8];\n\t\t\tfor(int j=0; j<8; j++)\ta[j]=Character.digit(c[j], 10);\n\t\t\tArrays.sort(a);\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor(int j=0; j<8; j++)\tsb.append(a[j]);\n\t\t\tint min=Integer.parseInt(sb.toString());\n\t\t\tsb=new StringBuilder();\n\t\t\tfor(int j=7; j>=0; j--)\tsb.append(a[j]);\n\t\t\tint max=Integer.parseInt(sb.toString());\n\t\t\tout.println(max-min);\n\t\t}\n\t}\n\t\n\tvoid AOJ0196(){\t// Baseball Championship\n\t\twhile(sc.hasNext()){\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n==0)\tbreak;\n\t\t\tTeam196[] teams = new Team196[n];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tString s=sc.next();\n\t\t\t\tint win=0, lose=0;\n\t\t\t\tfor(int j=0; j<n-1; j++){\n\t\t\t\t\tint temp=sc.nextInt();\n\t\t\t\t\tif(temp==0)\twin++;\n\t\t\t\t\tif(temp==1)\tlose++;\n\t\t\t\t}\n\t\t\t\tteams[i] = new Team196(s,win,lose,i);\n\t\t\t}\n\t\t\tArrays.sort(teams);\n\t\t\tfor(int i=0; i<n; i++)\tout.println(teams[i].name);\n\t\t}\n\t}\n\tclass Team196 implements Comparable<Team196>{\n\t\tString name;\n\t\tint win,lose,index;\n\t\tTeam196(String name, int win, int lose, int index){\n\t\t\tthis.name=name;\tthis.win=win;\tthis.lose=lose;\tthis.index=index;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Team196 o) {\n\t\t\tif(this.win<o.win)\treturn 1;\n\t\t\tif(this.win>o.win)\treturn -1;\n\t\t\tif(this.lose<o.lose)\treturn -1;\n\t\t\tif(this.lose>o.lose)\treturn 1;\n\t\t\tif(this.index<o.index)\treturn -1;\n\t\t\tif(this.index>o.index)\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tvoid AOJ0065(){\t// Trading\n\t\tfinal int MAX=1000000;\n\t\tint[] current=new int[MAX];\n\t\tint[] last=new int[MAX];\n\t\tboolean flag=false;\n\t\twhile(sc.hasNext()){\n\t\t\tString s=sc.nextLine();\n\t\t\tif(s.equals(\"\")){\n\t\t\t\tflag=true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tScanner sc2 = new Scanner(s).useDelimiter(\",\");\n\t\t\tif(flag)\tlast[sc2.nextInt()]++;\n\t\t\telse\tcurrent[sc2.nextInt()]++;\n\t\t}\n\t\tfor(int i=0; i<MAX; i++)\t\tif(current[i]>0 && last[i]>0)\tout.println(i+\" \"+(current[i]+last[i]));\n\t}\n\t\n\tvoid AOJ0161(){\t// Sport Meet\n\t\twhile(sc.hasNext()){\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n==0)\tbreak;\n\t\t\tTime161[] times = new Time161[n];\n\t\t\tfor(int i=0; i<n; i++)\ttimes[i] = new Time161(sc.nextInt(), (sc.nextInt()*60+sc.nextInt() + sc.nextInt()*60+sc.nextInt() + sc.nextInt()*60+sc.nextInt() + sc.nextInt()*60+sc.nextInt()));\n\t\t\tArrays.sort(times);\n\t\t\tout.println(times[0].num);\tout.println(times[1].num);\tout.println(times[times.length-2].num);\n\t\t}\n\t}\n\tclass Time161 implements Comparable<Time161>{\n\t\tint num, time;\n\t\tTime161(int num, int time){\n\t\t\tthis.num=num;\tthis.time=time;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Time161 o) {\n\t\t\tif(this.time<o.time)\treturn -1;\n\t\t\tif(this.time>o.time)\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tvoid AOJ0138(){\t// Track and Field Competition\n\t\tTime138[] times1st = new Time138[8];\n\t\tTime138[] times2nd = new Time138[8];\n\t\tTime138[] times3rd = new Time138[8];\n\t\tfor(int i=0; i<8; i++)\ttimes1st[i] = new Time138(sc.nextInt(), sc.nextDouble());\n\t\tfor(int i=0; i<8; i++)\ttimes2nd[i] = new Time138(sc.nextInt(), sc.nextDouble());\n\t\tfor(int i=0; i<8; i++)\ttimes3rd[i] = new Time138(sc.nextInt(), sc.nextDouble());\n\t\tArrays.sort(times1st);\tArrays.sort(times2nd);\tArrays.sort(times3rd);\n\t\tfor(int i=0; i<2; i++)\tout.println(times1st[i].num+\" \"+times1st[i].time);\n\t\tfor(int i=0; i<2; i++)\tout.println(times2nd[i].num+\" \"+times2nd[i].time);\n\t\tfor(int i=0; i<2; i++)\tout.println(times3rd[i].num+\" \"+times3rd[i].time);\n\t\tTime138[] times = new Time138[6];\n\t\ttimes[0]=times1st[2]; times[1]=times1st[3];\ttimes[2]=times2nd[2]; times[3]=times2nd[3];\ttimes[4]=times3rd[2]; times[5]=times3rd[3];\n\t\tArrays.sort(times);\n\t\tfor(int i=0; i<2; i++)\tout.println(times[i].num+\" \"+times[i].time);\n\t}\n\tclass Time138 implements Comparable<Time138>{\n\t\tint num;\tdouble time;\n\t\tTime138(int num, double time){\n\t\t\tthis.num=num;\tthis.time=time;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Time138 o) {\n\t\t\tif(this.time<o.time)\treturn -1;\n\t\t\tif(this.time>o.time)\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tvoid AOJ0005(){\t// GCD and LCM\n\t\twhile(sc.hasNext()){\n\t\t\tint a=sc.nextInt(), b=sc.nextInt();\n\t\t\tint temp=gcd(max(a,b), min(a,b));\n\t\t\tout.println(temp+\" \"+max(a,b)/temp*min(a,b));\n\t\t}\n\t}\n\tint gcd(int x, int y){\n\t\tif(y==0)\treturn x;\n\t\telse\treturn gcd(y, x%y);\n\t}\n\t\n\tint c197=0;\n\tvoid AOJ0197(){\t// Greatest Common Divisor: Euclidean Algorithm\n\t\twhile(sc.hasNext()){\n\t\t\tint x=sc.nextInt(), y=sc.nextInt();\n\t\t\tif(x<2)\tbreak;\n\t\t\tc197=0;\n\t\t\tout.println(gcd197(max(x,y), min(x,y))+\" \"+c197);\n\t\t}\n\t}\n\tint gcd197(int x, int y){\n\t\tif(y==0)\treturn x;\n\t\tc197++;\n\t\treturn gcd197(y, x%y);\n\t}\n\t\n\tvoid AOJ0001(){\t// List of Top 3 Hills\n\t\tint[] m = new int[10];\n\t\tfor(int i=0; i<10; i++)\tm[i]=sc.nextInt();\n\t\tArrays.sort(m);\n\t\tfor(int i=9; i>=7; i--)\tout.println(m[i]);\n\t}\n\t\n\tvoid AOJ10029(){\t// Sort II\n\t\tint n=sc.nextInt();\n\t\tint[] ans = new int[n];\n\t\tfor(int i=0; i<n; i++)\tans[i]=sc.nextInt();\n\t\tArrays.sort(ans);\n\t\tout.print(ans[0]);\n\t\tfor(int i=1; i<n; i++)\tout.print(\" \"+ans[i]);\n\t\tout.println();\n\t}\n\t\n\tint[][] p26 = new int[10][10];\n\tint c26=100;\n\tvoid AOJ0026(){\t// Dropping Ink\n\t\tint ans=0;\n\t\twhile(sc.hasNext()){\n\t\t\tScanner sc2 = new Scanner(sc.nextLine()).useDelimiter(\",\");\n\t\t\tint x=sc2.nextInt(), y=sc2.nextInt(), s=sc2.nextInt();\n\t\t\t// out.println(\"x\"+x+\" y\"+y+\" s\"+s);\n\t\t\tans=max(solve26(x,y),ans);\n\t\t\tans=max(solve26(x-1,y),ans);\tans=max(solve26(x+1,y),ans);\n\t\t\tans=max(solve26(x,y-1),ans);\tans=max(solve26(x,y+1),ans);\n\t\t\tif(s>=2){\n\t\t\t\tans=max(solve26(x-1,y-1),ans);\tans=max(solve26(x-1,y+1),ans);\n\t\t\t\tans=max(solve26(x+1,y-1),ans);\tans=max(solve26(x+1,y+1),ans);\n\t\t\t}\n\t\t\tif(s>=3){\n\t\t\t\tans=max(solve26(x-2,y),ans);\tans=max(solve26(x+2,y),ans);\n\t\t\t\tans=max(solve26(x,y-2),ans);\tans=max(solve26(x,y+2),ans);\n\t\t\t}\n\t\t}\n\t\tout.println(c26);\n\t\tout.println(ans);\n\t}\n\tint solve26(int x, int y){\n\t\tint r=-1;\n\t\tif(0<=x && x<=9 && 0<=y && y<=9){\n\t\t\tc26 -= p26[x][y]==0? 1: 0;\n\t\t\tp26[x][y]++;\n\t\t\tr=p26[x][y];\n\t\t}\n\t\treturn r;\t// RA\n\t}\n\t\n\tvoid AOJ0008(){\t//Sum of 4 Integers\n\t\twhile(sc.hasNext()){\n\t\t\tint ans=0, n=sc.nextInt();\n\t\t\tfor(int a=0; a<10; a++){\n\t\t\t\tfor(int b=0; b<10; b++){\n\t\t\t\t\tfor(int c=0; c<10; c++){\n\t\t\t\t\t\tfor(int d=0; d<10; d++)\t\tif((a+b+c+d)==n)\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\t\n\tvoid AOJ0055(){\t// Sequence\n\t\twhile(sc.hasNext()){\n\t\t\tdouble last=sc.nextDouble(), ans=last;\n\t\t\tfor(int i=2; i<=10; i++){\n\t\t\t\tans+= i%2==0? last*2: last/3;\n\t\t\t\tlast = i%2==0? last*2: last/3;\n\t\t\t\t// out.println(last);\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\t\n\tvoid AOJ0084(){\t// Search Engine\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(sc.hasNext()){\n\t\t\tString s=sc.next().replaceAll(\",\", \"\").replaceAll(\"\\\\.\", \"\").replaceAll(\" \", \"\");\n\t\t\t// out.println(s);\n\t\t\tif(s.length()<=2 || s.length()>=7)\tcontinue;\n\t\t\tsb.append(s+\" \");\n\t\t}\n\t\tout.println(sb.deleteCharAt(sb.length()-1));\n\t}\n\t\n\tvoid AOJ0077(){\t// Run Length\n\t\twhile(sc.hasNext()){\n\t\t\tchar[] c=sc.nextLine().toCharArray();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor(int i=0; i<c.length; i++){\n\t\t\t\tif(c[i]=='@'){\n\t\t\t\t\tfor(int j=0; j<Character.digit(c[i+1], 10); j++)\tsb.append(c[i+2]);\n\t\t\t\t\ti+=2;\n\t\t\t\t}else\tsb.append(c[i]);\n\t\t\t}\n\t\t\tout.println(sb.toString());\n\t\t}\n\t}\n\t\n\tvoid AOJ0064(){\t// Secret Number\n\t\tint ans=0;\n\t\twhile(sc.hasNext()){\n\t\t\tMatcher m = Pattern.compile(\"\\\\d+\").matcher(sc.nextLine());\n\t\t\twhile(m.find())\tans+=Integer.parseInt(m.group());\n\t\t}\n\t\tout.println(ans);\n\t}\n\t\n\tvoid AOJ0050(){\t// Apple and Peach\n\t\twhile(sc.hasNext()) out.println(sc.nextLine().replaceAll(\"apple\", \"PEACH\").replaceAll(\"peach\", \"apple\").replaceAll(\"PEACH\", \"peach\"));\n\t}\n\t\n\tvoid AOJ0039(){\t// Roman Figure\n\t\tHashMap<Character,Integer> dic = new HashMap<Character,Integer>();\n\t\tdic.put('I', 1);\tdic.put('V', 5);\tdic.put('X', 10);\tdic.put('L', 50);\n\t\tdic.put('C', 100);\tdic.put('D', 500);\tdic.put('M', 1000);\n\t\twhile(sc.hasNext()){\n\t\t\tchar[] c = sc.next().toCharArray();\n\t\t\tint ans=0,last=dic.get(c[0]);\n\t\t\tfor(int i=0; i<c.length; i++){\n\t\t\t\tif(last>=dic.get(c[i])){\n\t\t\t\t\tans+=dic.get(c[i]);\n\t\t\t\t\tlast=dic.get(c[i]);\n\t\t\t\t}else{\n\t\t\t\t\tans+=dic.get(c[i])-last-last;\n\t\t\t\t\tlast=dic.get(c[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\t\n\tvoid AOJ0020(){\t// Capitalize\n\t\twhile(sc.hasNext())\tout.println(sc.nextLine().toUpperCase());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n    static Scanner sc = new Scanner(System.in);\n    static int X, Y;\n    static int[][] field, dp;\n    public static void main(String[] args) {\n        while(read()){\n            solve();\n        }\n\n    }\n    static boolean read(){\n        X = sc.nextInt(); Y = sc.nextInt();\n        if(X == 0 && Y == 0)return false;\n\n        field = new int[Y][X];\n        dp = new int[Y][X];\n\n        for(int i = 0; i < Y; i++){\n            for(int j = 0; j < X; j++){\n                field[i][j] = sc.nextInt();\n            }\n        }\n        return true;\n    }\n    static void solve(){\n        //cÆ¡\n        int height = field.length;\n        int width = field[0].length;\n        int res = 0;\n        //dpÌú»\n        for(int i = 0; i < height; i++){\n            if(field[0][i] == 0){\n                dp[0][i] = 1;\n            }\n        }\n\n        for(int i = 1; i < height; i++){\n            for(int j = 0; j < width; j++){\n                if(field[i][j] == 0){\n                    /*\n                     * }XÚªOÈçãÌRÂ©çlðàç¤B\n                     * ½¾µAãÌ}XàOÅ éKvª éB\n                     */\n                    if( 0 <= j-1 && j-1 < width && field[i-1][j-1] == 0)dp[i][j] += dp[i-1][j-1];\n\n                    if( field[i-1][j] == 0 )dp[i][j] += dp[i-1][j];\n\n                    if( 0 <= j+1 && j+1 < width && field[i-1][j+1] == 0)dp[i][j] += dp[i-1][j+1];\n                }else if(field[i][j] == 2){\n                    /*\n                     * }XÚªQÈçWväÈÌÅ^ã©çàç¤B\n                     * »µÄAQÂºÉ«ÞB\n                     * ½¾µAÍÍOÉÈéêª éÌÅA»ÌÍêÔºÉ¢Ä¨­\n                     */\n                    dp[i][j] += dp[i-1][j];\n                    if(i+2 < height){\n                        dp[i+2][j] += dp[i][j];\n                    }else{\n                        res += dp[i][j];\n                    }\n\n                }else{\n                    /*\n                     * }XÚªPÈçØÈÌÅA½àÈ¢B\n                     */\n                    dp[i][j] = 0;\n                }\n            }\n\n        }//dpe[uXVÌI¹\n\n        for(int i = 0; i < width; i++){\n            res += dp[height-1][i];\n        }\n        System.out.println(res);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tw = scanner.nextInt();\n\t\t\th = scanner.nextInt();\n\t\t\tif ((w | h) == 0)\n\t\t\t\tbreak;\n\t\t\tmap = new int[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tmap[i][j] = scanner.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[][] dp = new int[h][w];\n\t\t\tfor (int i = 0; i < w; i++) {\n\t\t\t\tif (map[0][i] == 0)\n\t\t\t\t\tdp[0][i] = 1;\n\t\t\t}\n\t\t\tfor (int i = 1; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (map[i][j] == 0) {\n\t\t\t\t\t\tif (j > 0 && map[i - 1][j - 1] == 0)\n\t\t\t\t\t\t\tdp[i][j] += dp[i - 1][j - 1];\n\t\t\t\t\t\tif (j < w-1 && map[i - 1][j + 1] == 0)\n\t\t\t\t\t\t\tdp[i][j] += dp[i - 1][j + 1];\n\t\t\t\t\t\tif (map[i - 1][j] == 0)\n\t\t\t\t\t\t\tdp[i][j] += dp[i - 1][j];\n\t\t\t\t\t\tif (i > 1 && map[i - 2][j] == 2)\n\t\t\t\t\t\t\tdp[i][j] += dp[i - 2][j];\n\t\t\t\t\t} else if (map[i][j] == 2) {\n\t\t\t\t\t\tif (map[i - 1][j] == 0)\n\t\t\t\t\t\t\tdp[i][j] += dp[i - 1][j];\n\t\t\t\t\t\tif (i > 1 && map[i - 2][j] == 2)\n\t\t\t\t\t\t\tdp[i][j] += dp[i - 2][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sum = 0;\n\t\t\tfor (int i = 0; i < w; i++) {\n\t\t\t\tsum += dp[h - 1][i];\n\t\t\t\tif (h > 1 && map[h - 2][i] == 2)\n\t\t\t\t\tsum += dp[h - 2][i];\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n\n\tint count;\n\tint w;\n\tint h;\n\tint[][] map;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int x, y;\n\tstatic int[][] field, dp;\n\tstatic int[] dx = {-1, 0, 1}, dy = {1};\n\tpublic static void main(String[] args) {\n\t\twhile(read()){\n\t\t\tsolve();\n\t\t}\n\t}\n\t\n\tstatic boolean read(){\n\t\tx = sc.nextInt();\n\t\ty = sc.nextInt();\n\t\tif(x == 0 && y == 0)return false;\n\t\t\n\t\tfield = new int[y+2][x];\n\t\tdp = new int[y+2][x];\n\t\t\n\t\tfor(int i = 0; i < field.length-2; i++){\n\t\t\tfor(int j = 0; j < field[0].length; j++){\n\t\t\t\tfield[i][j] = sc.nextInt();\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tstatic void solve(){\n\t\tfor(int i = 0; i < field[0].length; i++){\n\t\t\tif(field[0][i] == 0)dp[0][i] = 1;\n\t\t}\n\t\t\n\t\tfor(int y = 0; y < field.length-3; y++){\n\t\t\tfor(int x = 0; x < field[0].length; x++){\n\t\t\t\tif(field[y][x] == 0){\n\t\t\t\t\tfor(int k = 0; k < dx.length; k++){\n\t\t\t\t\t\tint nx = x + dx[k], ny = y + 1;\n\t\t\t\t\t\tif(0 > nx || nx >= field[0].length)continue;\n\t\t\t\t\t\tif(field[ny][nx] == 0)dp[ny][nx] += dp[y][x];\n\t\t\t\t\t}\n\t\t\t\t}else if(field[y][x] == 2){\n\t\t\t\t\tint ny = y + 2, nx = x;\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\tdp[ny][nx] += dp[y-1][x];\n\t\t\t\t\t\tif(field[ny][nx] != 2)break;\n\t\t\t\t\t\tny = ny + 2;\n\t\t\t\t\t}\n\t\t\t\t}else if(field[y][x] == 1){\n\t\t\t\t\tdp[y][x] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = 0;\n\t\tfor(int x = 0; x < dp[0].length; x++){\n\t\t\tres += dp[dp.length-1][x] + dp[dp.length-2][x] + dp[dp.length-3][x];\n\t\t}\n\t\tSystem.out.println(res);\n\t\t//printDP();\n\t}\n\t\n\tstatic void printDP(){\n\t\tfor(int i = 0; i < field.length; i++){\n\t\t\tfor(int j = 0; j < field[0].length; j++){\n\t\t\t\tSystem.out.print(dp[i][j] + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.lang.annotation.Retention;\nimport java.util.*;\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\tpublic Main() {\n\t\tnew AOJ0203();\n\t}\n\t\n\t\n\tclass AOJ0203{\n\t\tint x,y;\n\t\tint[][] map;\n\t\tHashMap<String,Integer> memo;\n\t\tint dfs(int sx,int sy,int before_x){\n//\t\t\tSystem.out.println(sx+\" \"+sy+\" \"+before_x);\n\t\t\tif(memo.containsKey(sx+\" \"+sy+\" \"+before_x))return memo.get(sx+\" \"+sy+\" \"+before_x);\n\t\t\tint result = 0;\n\t\t\tif(sy>=y-1){\n\t\t\t\tif(sy==y-1)if(map[sy][sx]==1)return 0;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif(map[sy][sx]==1)return 0;\n\t\t\telse if(map[sy][sx]==2){\n\t\t\t\tif(before_x!=sx)return 0;\n\t\t\t\telse return dfs(sx,sy+2,sx);\n\t\t\t}else if(map[sy][sx]==0){\n\t\t\t\tfor(int i=-1;i<=1;i++){\n\t\t\t\t\tint nx=i+sx, ny=sy+1;\n\t\t\t\t\tif(nx<0||nx>=x||ny<0)continue;\n\t\t\t\t\tresult+=dfs(nx, ny,sx);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo.put(sx+\" \"+sy+\" \"+before_x,result);\n\t\t\treturn result;\n\t\t}\n\t\t\n\t\t\n\t\tpublic AOJ0203() {\n\t\t\twhile(true){\n\t\t\t\tmemo = new HashMap<String, Integer>();\n\t\t\t\tx = in.nextInt();\n\t\t\t\ty = in.nextInt();\n\t\t\t\tif(x==0&&y==0)break;\n\t\t\t\tmap = new int[y+1][x];\n\t\t\t\tfor(int i=0;i<y;i++)for(int s=0;s<x;s++)map[i][s] = in.nextInt();\n\t\t\t\tint result = 0;\n\t\t\t\tfor(int i=0;i<x;i++)result += dfs(i,0,-1);\n\t\t\t\tSystem.out.println(result);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint w, h;\n\t\tint map[][];\n\t\tint cnt[][];\n\n\t\twhile (true) {\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif ((w | h) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmap = new int[h][w];\n\t\t\tcnt = new int[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tmap[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (map[h - 1][j] != 1) {\n\t\t\t\t\tcnt[h - 1][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint sum;\n\t\t\tfor (int i = h - 2; 0 <= i; i--) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tsum = 0;\n\t\t\t\t\tif (map[i][j] == 0) {\n\t\t\t\t\t\tif (j + 1 < w && map[i + 1][j + 1] == 0) {\n\t\t\t\t\t\t\tsum += cnt[i + 1][j + 1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (0 <= j - 1 && map[i + 1][j - 1] == 0) {\n\t\t\t\t\t\t\tsum += cnt[i + 1][j - 1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (map[i + 1][j] != 1) {\n\t\t\t\t\t\t\tsum += cnt[i + 1][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (map[i][j] == 2) {\n\t\t\t\t\t\tif (i + 2 < h) {\n\t\t\t\t\t\t\tsum += cnt[i + 2][j];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsum = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcnt[i][j] = sum;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsum = 0;\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tsum += cnt[0][j];\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nclass Main {\n\tstatic int[][] map;\n\tstatic int x;\n\tstatic int y;\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tx = stdIn.nextInt();\n\t\t\ty = stdIn.nextInt();\n\t\t\tif(x == 0 && y == 0) break;\n\t\t\tmap = new int[y+1][x];\n\t\t\tfor(int i = 0; i < y; i++) {\n\t\t\t\tfor(int j = 0; j < x; j++) {\n\t\t\t\t\tmap[i][j] = stdIn.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sum = 0;\n\t\t\tfor(int i = 0; i < x; i++) {\n\t\t\t\tsum += solv(y-1,i,false);\n\t\t\t\tif(map[y-2][i] == 2) {\n\t\t\t\t\tsum += solv(y-2,i,true);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n\t\n\tstatic int solv(int y, int x, boolean jump) {\n\t\tint ret = 0;\n\t\t\n\t\tif(y < 0 || x < 0 || x >= Main.x) return ret;\n\t\t\n\t\tif(map[y][x] == 1) return ret;\n\t\t\n\t\tif(map[y][x] == 2 && !jump) return ret;\n\t\tif(y == 0) return 1;\n\t\t\n\t\tif(y >= 2 && map[y-2][x] == 2) {\n\t\t\tret += solv(y-2,x,true);\n\t\t}\n\t\tif(!jump) {\n\t\tret += solv(y-1,x-1,false);\n\t\tret += solv(y-1,x+1,false);\n\t\t}\n\t\tret += solv(y-1,x,false);\n\t\t\n\t\treturn ret;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n\n\n\tpublic static void main(String args[]){\n\t\tScanner in = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint w = in.nextInt(), h = in.nextInt();\n\t\t\tint board[][] = new int[h][w];\n\t\t\tint dp[][] = new int[h+1][w];\n\t\t\tfor(int i=0; i<h; i++)for(int j=0; j<w; j++) board[i][j] = in.nextInt();\n\t\t\tfor(int j=0; j<w; j++) dp[0][j] = 1;\n\t\t\tfor(int i=0; i<h-1; i++){\n\t\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\t\tif(board[i][j] == 0){\n\t\t\t\t\t\tif(j>0 && board[i+1][j-1] != 2) dp[i+1][j-1] += dp[i][j];\n\t\t\t\t\t\tif(j<w-1 && board[i+1][j+1] != 2) dp[i+1][j+1] += dp[i][j];\n\t\t\t\t\t\tdp[i+1][j] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t\telse if(board[i][j] == 2){\n\t\t\t\t\t\tif(i<h-1) dp[i+2][j] += dp[i][j];\n\t\t\t\t\t\telse dp[h][j] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = 0;\n\t\t\tfor(int j=0; j<w; j++) ans += dp[h][j];\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * A New Plan of Aizu Ski Resort\n * PCK2009 ??????9\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tint x, y;\n\t\t\tx = parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\ty = parseInt(line.substring(line.indexOf(' ') + 1));\n\t\t\tif ((x | y) == 0) break;\n\n\t\t\tint[][] course = new int[y + 4][x + 2];\n\t\t\tint[][] dp = new int[y + 4][x + 2];\n\n\t\t\tfor (int i = 0; i < y; i++) {\n\t\t\t\twords = br.readLine().split(\" \");\n\t\t\t\tfor (int j = 0; j < words.length; j++) {\n\t\t\t\t\tcourse[i + 2][j + 1] = parseInt(words[j]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//\n\t\t\tfor (int i = 1; i < x + 1; i++) {\n\t\t\t\tif (course[2][i] == 0) dp[2][i] = 1;\n\t\t\t}\n\n\t\t\tfor (int i = 2; i < y + 2; i++) {\n\t\t\t\tfor (int j = 1; j < x + 1; j++) {\n\t\t\t\t\tswitch (course[i][j]) {\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tif (course[i - 1][j - 1] == 0) {\n\t\t\t\t\t\t\t\tdp[i][j] += dp[i - 1][j - 1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (course[i - 1][j] == 0) {\n\t\t\t\t\t\t\t\tdp[i][j] += dp[i - 1][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (course[i - 1][j + 1] == 0) {\n\t\t\t\t\t\t\t\tdp[i][j] += dp[i - 1][j + 1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (course[i - 2][j] == 2) {\n\t\t\t\t\t\t\t\tdp[i][j] += dp[i - 2][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tif (course[i - 1][j] == 0) {\n\t\t\t\t\t\t\t\tdp[i][j] += dp[i - 1][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (course[i - 2][j] == 2) {\n\t\t\t\t\t\t\t\tdp[i][j] += dp[i - 2][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = y + 2; i < y + 4; i++) {\n\t\t\t\tfor (int j = 1; j < x + 1; j++) {\n\t\t\t\t\tdp[i][j] += dp[i - 1][j];\n\t\t\t\t\tif (course[i - 2][j] == 2) {\n\t\t\t\t\t\tdp[i][j] += dp[i - 2][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//\n\t\t\tint sum = 0;\n\t\t\tfor (int i = 1; i < x + 1; i++) sum += dp[y + 3][i];\n\t\t\tSystem.out.println(sum);\n\t\t}//end while\n\t}//end main\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * A New Plan of Aizu Ski Resort\n * PCK2009 ??????9\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tint x, y;\n\t\t\tx = parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\ty = parseInt(line.substring(line.indexOf(' ') + 1));\n\t\t\tif ((x | y) == 0) break;\n\n\t\t\tint[][] course = new int[y + 2][x];\n\t\t\tint[][] dp = new int[y + 2][x];\n\n\t\t\tfor (int i = 0; i < y; i++) {\n\t\t\t\twords = br.readLine().split(\" \");\n\t\t\t\tfor (int j = 0; j < words.length; j++) {\n\t\t\t\t\tcourse[i][j] = parseInt(words[j]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < x; i++) {\n\t\t\t\tif (course[0][i] == 0) dp[0][i] = 1;\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < y; i++) {\n\t\t\t\tfor (int j = 0; j < x; j++) {\n\t\t\t\t\tswitch (course[i][j]) {\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tif (i + 1 < y && j - 1 >= 0 && course[i + 1][j - 1] == 0) {\n\t\t\t\t\t\t\t\tdp[i + 1][j - 1] += dp[i][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i + 1 < y && course[i + 1][j] != 1) {\n\t\t\t\t\t\t\t\tdp[i + 1][j] += dp[i][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i + 1 < y && j + 1 < x && course[i + 1][j + 1] == 0) {\n\t\t\t\t\t\t\t\tdp[i + 1][j + 1] += dp[i][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tif (i + 2 < y + 2 && course[i + 2][j] != 1) {\n\t\t\t\t\t\t\t\tdp[i + 2][j] += dp[i][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sum = 0;\n\t\t\tfor (int i = y - 1; i < y + 2; i++) {\n\t\t\t\tfor (int j = 0; j < x; j++) {\n\t\t\t\t\tsum += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\n\t\t}//end while\n\t}//end main\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tint DP(int h,int w,int hw[][]){\n\t\tint result = 0;\n\t\tint yx[][] = new int [h][w];\n\t\tfor(int i = 0;i < w;i++){\n\t\t\tif(hw[0][i] == 0){\n\t\t\t\tyx[0][i] = 1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < h-1;i++){\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tif(j == 0){\n\t\t\t\t\tif(hw[i+1][j] == 0){\n\t\t\t\t\t\tif(w == 1){\n\t\t\t\t\t\t\tyx[i+1][j] = yx[i+1][j] + yx[i][j];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tyx[i+1][j] = yx[i+1][j] + yx[i][j] + yx[i][j+1];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else if(j == w-1){\n\t\t\t\t\tif(hw[i+1][j] == 0){\n\t\t\t\t\t\tyx[i+1][j] = yx[i+1][j] + yx[i][j] + yx[i][j-1];\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(hw[i+1][j] == 0){\n\t\t\t\t\t\tyx[i+1][j] = yx[i+1][j] + yx[i][j-1] + yx[i][j] + yx[i][j+1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tif(hw[i+1][j] == 2){\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\tif(i+cnt+1 == h-2){\n\t\t\t\t\t\t\tcnt = cnt + 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tcnt = cnt + 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(hw[i+cnt+1][j] != 2)break;\n\t\t\t\t\t}\n\t\t\t\t\tyx[i+cnt+1][j] = yx[i+cnt+1][j] + yx[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < w;i++){\n\t\t\tresult = result + yx[h-1][i];\n\t\t}\n//\t\tfor(int i = 0;i < h;i++){\n//\t\t\tfor(int j = 0;j < w;j++){\n//\t\t\t\tSystem.out.print(yx[i][j]+\" \");\n//\t\t\t}\n//\t\t\tSystem.out.println();\n//\t\t}\n\t\treturn result;\n\t}\n\tvoid doIt() { \n\t\twhile(true){\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tint hw[][] = new int [h][w];\n\t\t\tif(h+w == 0)break;\n\t\t\tfor(int i = 0;i < h;i++){\n\t\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\t\thw[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(DP(h,w,hw));\n\t\t}\n     }\n    public static void main(String[] args) {\n    \t// TODO Auto-generated method stub\n    \tnew Main().doIt();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nclass Main {\n\tstatic int[][] map;\n\tstatic int x;\n\tstatic int y;\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tx = stdIn.nextInt();\n\t\t\ty = stdIn.nextInt();\n\t\t\tif(x == 0 && y == 0) break;\n\t\t\tmap = new int[y+1][x];\n\t\t\tfor(int i = 0; i < y; i++) {\n\t\t\t\tfor(int j = 0; j < x; j++) {\n\t\t\t\t\tmap[i][j] = stdIn.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sum = 0;\n\t\t\tfor(int i = 0; i < x; i++) {\n\t\t\t\tsum += solv(y-1,i,false);\n\t\t\t\tif(y >= 2 && map[y-2][i] == 2) {\n\t\t\t\t\tsum += solv(y-2,i,true);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n\t\n\tstatic int solv(int y, int x, boolean jump) {\n\t\tint ret = 0;\n\t\t\n\t\tif(y < 0 || x < 0 || x >= Main.x) return ret;\n\t\t\n\t\tif(map[y][x] == 1) return ret;\n\t\t\n\t\tif(map[y][x] == 2 && !jump) return ret;\n\t\tif(y == 0) return 1;\n\t\t\n\t\tif(y >= 2 && map[y-2][x] == 2) {\n\t\t\tret += solv(y-2,x,true);\n\t\t}\n\t\tif(!jump) {\n\t\tret += solv(y-1,x-1,false);\n\t\tret += solv(y-1,x+1,false);\n\t\t}\n\t\tret += solv(y-1,x,false);\n\t\t\n\t\treturn ret;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n\tint w;\n\tint h;\n\tint count;\n\tshort[][] map;\n\tint[][] dp;\n\tpublic void run(){\n\t\tScanner scan = new Scanner(System.in);\n\t\twhile(scan.hasNext()){\n\t\t\tw = scan.nextInt();\n\t\t\th = scan.nextInt();\n\t\t\tif(w == 0 && h == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmap = new short[h][w];\n\t\t\tfor(int i = 0;i < h;i++){\n\t\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\t\tmap[i][j] = scan.nextShort();\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp = new int[h+1][w];\n\t\t\tfor(int i = 0;i < w;i++){\n\t\t\t\tif(map[0][i] == 0){\n\t\t\t\t\tdp[0][i] = 1;\n\t\t\t\t}else{\n\t\t\t\t\tdp[0][i] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 1;i < h;i++){\n\t\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\t\tif(map[i][j] == 1){\n\t\t\t\t\t\tdp[i][j] = 0;\n\t\t\t\t\t}else if(map[i][j] == 2){\n\t\t\t\t\t\tdp[i+2][j] += dp[i-1][j] + dp[i][j];\n\t\t\t\t\t\tdp[i][j] = 0;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(j != 0){\n\t\t\t\t\t\t\tdp[i][j] += dp[i-1][j-1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(j != w-1){\n\t\t\t\t\t\t\tdp[i][j] += dp[i-1][j+1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp[i][j] += dp[i-1][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcount = 0;\n\t\t\tfor(int i = 0;i < w;i++){\n\t\t\t\tcount += Math.max(dp[h-1][i],dp[h][i]);\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tint DP(int h,int w,int hw[][]){\n\t\tint result = 0;\n\t\tint yx[][] = new int [h][w];\n\t\tfor(int i = 0;i < w;i++){\n\t\t\tif(hw[0][i] == 0){\n\t\t\t\tyx[0][i] = 1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < h-1;i++){\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tif(j == 0){\n\t\t\t\t\tif(hw[i+1][j] == 0){\n\t\t\t\t\t\tif(w == 1){\n\t\t\t\t\t\t\tyx[i+1][j] = yx[i+1][j] + yx[i][j];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tyx[i+1][j] = yx[i+1][j] + yx[i][j] + yx[i][j+1];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else if(j == w-1){\n\t\t\t\t\tif(hw[i+1][j] == 0){\n\t\t\t\t\t\tyx[i+1][j] = yx[i+1][j] + yx[i][j] + yx[i][j-1];\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(hw[i+1][j] == 0){\n\t\t\t\t\t\tyx[i+1][j] = yx[i+1][j] + yx[i][j-1] + yx[i][j] + yx[i][j+1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tif(hw[i+1][j] == 2){\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\tif(i+cnt+1 == h-2){\n\t\t\t\t\t\t\tcnt = cnt + 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(i+cnt+2 == h)break;\n\t\t\t\t\t\t\tcnt = cnt + 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(hw[i+cnt+1][j] != 2)break;\n\t\t\t\t\t}\n\t\t\t\t\tif(hw[i+cnt+1][j] == 0){\n\t\t\t\t\t\tyx[i+cnt+1][j] = yx[i+cnt+1][j] + yx[i][j];\n\t\t\t\t\t}else if(hw[i+cnt+1][j] == 1 && (h-i) % 2 == 1){\n\t\t\t\t\t\tyx[i+cnt+1][j] = yx[i+cnt+1][j] + yx[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < w;i++){\n\t\t\tresult = result + yx[h-1][i];\n\t\t}\n//\t\tfor(int i = 0;i < h;i++){\n//\t\t\tfor(int j = 0;j < w;j++){\n//\t\t\t\tSystem.out.print(yx[i][j]+\" \");\n//\t\t\t}\n//\t\t\tSystem.out.println();\n//\t\t}\n\t\treturn result;\n\t}\n\tvoid doIt() { \n\t\twhile(true){\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tint hw[][] = new int [h][w];\n\t\t\tif(h+w == 0)break;\n\t\t\tfor(int i = 0;i < h;i++){\n\t\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\t\thw[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(DP(h,w,hw));\n\t\t}\n     }\n    public static void main(String[] args) {\n    \t// TODO Auto-generated method stub\n    \tnew Main().doIt();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.*;\n\nimport static java.lang.Math.*;\nimport static java.lang.System.out;\n\n// AOJ\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().AOJ0203();\n\t}\n\t\n\tvoid AOJ0203(){\t// A New Plan of Aizu Ski Resort\n\t\twhile(sc.hasNext()){\n\t\t\tint x=sc.nextInt(), y=sc.nextInt();\n\t\t\tif(x==0)\tbreak;\n\t\t\tint[][] dp=new int[x+3][y+3],b=new int[x+2][y+2];\n\t\t\tfor(int j=1; j<=y; j++){\n\t\t\t\tfor(int i=1; i<=x; i++)\tb[i][j]=sc.nextInt();\n\t\t\t}\n\t\t\tfor(int i=1; i<=x; i++)\tdp[i][1]= b[i][1]==1?0:1;\n\t\t\tfor(int j=1; j<=y; j++){\n\t\t\t\tfor(int i=1; i<=x; i++){\n\t\t\t\t\tif(b[i][j]==2)\tdp[i][j]= dp[i][j-1];\n\t\t\t\t\telse if(b[i][j]==0){\n\t\t\t\t\t\tfor(int k=i-1; k<=i+1; k++)\tdp[i][j]+=b[k][j-1]==0?dp[k][j-1]:0;\t\n\t\t\t\t\t}\n\t\t\t\t\tif(j>2)\tdp[i][j]+= b[i][j]!=1&&b[i][j-2]==2?dp[i][j-2]:0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// debug\n\t\t\t/*\n\t\t\tfor(int j=1; j<=y; j++){\n\t\t\t\tfor(int i=1; i<=x; i++)\tout.print(dp[i][j]+\" \");\n\t\t\t\tout.println();\n\t\t\t}\n\t\t\t*/\n\t\t\tint ans=0;\n\t\t\tfor(int i=1; i<=x; i++)\tans+= b[i][y-1]==2?dp[i][y-1]:dp[i][y];\n\t\t\tout.println(ans);\n\t\t}\n\t\t\n\t}\n\t\n\t// RE\n\tvoid AOJ0089(){\t// The Shortest Path on A Rhombic Path\n\t\tint[][] dp=new int[200][200];\n\t\tdp[1][1]=sc.nextInt();\n\t\tint idx=2, lastLen=1;\n\t\twhile(sc.hasNext()){\n\t\t\tString s=sc.next();\n\t\t\tScanner sc2=new Scanner(s).useDelimiter(\",\");\n\t\t\tint len=(int)((double)s.length()/(double)2+0.5);\n\t\t\tfor(int i=1; i<=len; i++){\n\t\t\t\tif(len>lastLen)\tdp[i][idx]=sc2.nextInt()+max(dp[i][idx-1], dp[i-1][idx-1]);\n\t\t\t\telse\tdp[i][idx]=sc2.nextInt()+max(dp[i][idx-1], dp[i+1][idx-1]);\n\t\t\t}\n\t\t\tlastLen=len;\n\t\t\tidx++;\n\t\t}\n\t\t//debug\n\t\t\n\t\tfor(int i=0; i<=idx; i++){\n\t\t\tfor(int j=0; j<=(int)((double)idx/2+0.5); j++)\tout.printf(\"%4d\",dp[j][i]);\n\t\t\tout.println();\n\t\t}\n\t\t\n\t\tout.println(dp[1][idx-1]);\n\t}\n\t\n\tvoid AOJ0004(){\n\t\t//while(sc.hasNext()){\n\t\t\t// int a=sc.nextInt(), b=sc.nextInt(), c=sc.nextInt(), d=sc.nextInt(), e=sc.nextInt(), f=sc.nextInt();\n\t\t\t// ax + by = c\n\t\t\t// dx + ey = f\n\t\t//}\n\t}\n\t\n\tvoid AOJ0042(){\t// A Thief\n\t\tint num=1;\n\t\twhile(sc.hasNext()){\n\t\t\tint w=sc.nextInt();\n\t\t\tif(w==0)\tbreak;\n\t\t\tint n=sc.nextInt();\n\t\t\tint[][] dp=new int[n+1][w+1];\n\t\t\tint[] ww=new int[n+1], pp=new int[n+1];\n\t\t\tfor(int i=1; i<=n; i++){\n\t\t\t\tScanner sc2=new Scanner(sc.next()).useDelimiter(\",\");\n\t\t\t\tpp[i]=sc2.nextInt();\n\t\t\t\tww[i]=sc2.nextInt();\n\t\t\t}\n\t\t\tint ans=0, wei=Integer.MAX_VALUE;\n\t\t\tfor(int i=1; i<=n; i++){\n\t\t\t\tfor(int j=1; j<=w; j++){\n\t\t\t\t\tdp[i][j]=max(dp[i-1][j], j>=ww[i]?dp[i-1][j-ww[i]]+pp[i]:dp[i-1][j]);\n\t\t\t\t\tif(dp[i][j]>ans){\n\t\t\t\t\t\twei=j;\n\t\t\t\t\t\tans=dp[i][j];\n\t\t\t\t\t}else if(dp[i][j]==ans){\n\t\t\t\t\t\twei=min(wei,j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//debug\n\t\t\t/*\n\t\t\tfor(int i=0; i<=w; i++){\n\t\t\t\tfor(int j=0; j<=n; j++)\tout.printf(\"%4d\",dp[j][i]);\n\t\t\t\tout.println();\n\t\t\t}\n\t\t\t*/\n\t\t\t\n\t\t\tout.println(\"Case \"+(num++)+\":\");\n\t\t\tout.println(ans);\n\t\t\tout.println(wei);\n\t\t}\n\t}\n\n\tvoid AOJ0003(){\n\t\tint n=sc.nextInt();\n\t\twhile(n-->0){\n\t\t\tint[] a=new int[3];\n\t\t\tfor(int i=0; i<3; i++)\ta[i]=sc.nextInt();\n\t\t\tArrays.sort(a);\n\t\t\tif(a[2]*a[2]==(a[1]*a[1])+(a[0]*a[0]))\tout.println(\"YES\");\n\t\t\telse\tout.println(\"NO\");\n\t\t}\n\t}\n\t\n\tvoid AOJ0002(){\n\t\twhile(sc.hasNext())\tout.println(new String(\"\"+(sc.nextInt()+sc.nextInt())).length());\n\t}\n\t\n\tvoid AOJ0516(){\n\t\twhile(sc.hasNext()){\n\t\t\tint n=sc.nextInt(), k=sc.nextInt(), ans=0;\n\t\t\tif(n==0)\tbreak;\n\t\t\tint[] sum=new int[n+1];\n\t\t\tfor(int i=1; i<=n; i++)\tsum[i]=sum[i-1]+sc.nextInt();\n\t\t\tfor(int i=k; i<=n; i++)\tans=max(ans, sum[i]-sum[i-k]);\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\t\n\tc547[][] r;\n\tfinal int MOD547=100000;\n\tvoid AOJ0547(){\t// Commute routes\n\t\twhile(sc.hasNext()){\n\t\t\tint w=sc.nextInt(), h=sc.nextInt();\n\t\t\tif(w<2)\tbreak;\n\t\t\tr=new c547[w+1][h+1];\n\t\t\tr[2][1]=new c547(0,0,0,1);\tr[1][2]=new c547(0,1,0,0);\n\t\t\tfor(int x=1; x<=w; x++){\n\t\t\t\tfor(int y=1; y<=h; y++)\tr[x][y] = r[x][y]==null?solve547(x,y): r[x][y];\n\t\t\t}\n\t\t\t//r[w][h].list();\n\t\t\tout.println(r[w][h].sum());\n\t\t}\n\t}\n\tc547 solve547(int x, int y){\n\t\tint s1=y-1>0? r[x][y-1].w2:0;\n\t\tint s2=y-1>0? (r[x][y-1].s1+r[x][y-1].s2)%MOD547:0;\n\t\tint w1=x-1>0? r[x-1][y].s2:0;\n\t\tint w2=x-1>0? (r[x-1][y].w1+r[x-1][y].w2)%MOD547:0;\n\t\treturn new c547(s1, s2, w1, w2);\n\t}\n\tclass c547{\n\t\tint s1, s2, w1, w2;\n\t\tc547(int s1, int s2, int w1, int w2){\n\t\t\tthis.s1=s1; this.s2=s2; this.w1=w1; this.w2=w2;\n\t\t}\n\t\tint sum(){\n\t\t\treturn (this.s1 + this.s2 + this.w1 + this.w2)%MOD547;\n\t\t}\n\t\tvoid list(){\n\t\t\tout.println(\"(\"+this.s1+\" \"+this.s2+\" \"+this.w1+\" \"+this.w2+\")\");\n\t\t}\n\t}\n\t\n\tint[][] a1209;\n\tvoid AOJ1209(){\n\t\twhile(sc.hasNext()){\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n<=0)\tbreak;\n\t\t\ta1209=new int[18][n+1];\n\t\t\tfor(int i=0; i<=n; i++)\ta1209[1][i]=1;\n\t\t\tfor(int x=2; x<=17; x++){\n\t\t\t\tfor(int y=1; y<=n; y++)\ta1209[x][y]=solve1209(x,y);\n\t\t\t}\n\t\t\tint ans=0;\n\t\t\tfor(int i=1; i<=17; i++)\tans+=a1209[i][n];\n\t\t\tout.println(ans);\n\t\t\t\n\t\t\t// debug\n\t\t\t/*\n\t\t\tfor(int i=0; i<=n; i++){\n\t\t\t\tfor(int j=0; j<=17; j++)\tout.print(a1209[j][i]+\" \");\n\t\t\t\tout.println();\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t}\n\tint solve1209(int x, int y){\n\t\tint ans=0;\n\t\tfor(int i=x;i>0; i--)\tans+= y-(x*x)>=0?a1209[i][y-(x*x)]:0;\n\t\treturn ans;\n\t}\n\t\n\tint[][] r515;\n\tboolean[][] b515;\n\tvoid AOJ0515(){\t// School Road\n\t\twhile(sc.hasNext()){\n\t\t\tint xn=sc.nextInt(), yn=sc.nextInt();\n\t\t\tif(xn<=0)\tbreak;\n\t\t\tint n=sc.nextInt();\n\t\t\tb515 = new boolean[xn+1][yn+1];\n\t\t\tfor(int i=0; i<n; i++)\tb515[sc.nextInt()][sc.nextInt()]=true;\n\t\t\tr515=new int[xn+1][yn+1];\n\t\t\tr515[1][1]=1;\n\t\t\tfor(int x=1; x<=xn; x++){\n\t\t\t\tfor(int y=1; y<=yn; y++){\n\t\t\t\t\tif(x==1&&y==1)\tcontinue;\n\t\t\t\t\tr515[x][y]=solve515(x,y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(r515[xn][yn]);\n\t\t}\n\t}\n\tint solve515(int x, int y){\n\t\tint ans=0;\n\t\tif(!b515[x][y]){\n\t\t\tans+= y-1>0? r515[x][y-1]:0;\n\t\t\tans+= x-1>0? r515[x-1][y]:0;\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\t\n\tint[] a168;\n\tvoid AOJ0168(){\t// Kannondou\n\t\twhile(sc.hasNext()){\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n<=0)\tbreak;\n\t\t\ta168=new int[n+1];\n\t\t\ta168[0]=1;\n\t\t\tfor(int i=1; i<=n; i++)\ta168[i]=solve168(i);\n\t\t\tint day=(a168[n]/10) + (a168[n]%10==0? 0: 1);\n\t\t\t// out.println(\"n\"+a168[n]+\" day\"+day);\n\t\t\tout.println(((day/365) + (day%365==0?0 :1)));\n\t\t}\n\t}\n\tint solve168(int a){\n\t\tint ans=0;\n\t\tfor(int i=a-1; i>=a-3; i--)\tans+= i>=0? a168[i]: 0;\n\t\treturn ans;\n\t}\n\t\n\tvoid AOJ0176(){\t// What Color?\n\t\tint[] R = {0,0,0,0,255,255,255,255};\n\t\tint[] G = {0,0,255,255,0,0,255,255};\n\t\tint[] B = {0,255,0,255,0,255,0,255};\n\t\tHashMap<Integer,String> dic = new HashMap<Integer,String>();\n\t\tdic.put(0, \"black\");\tdic.put(1, \"blue\");\tdic.put(2, \"lime\");\tdic.put(3, \"aqua\");\n\t\tdic.put(4, \"red\");\tdic.put(5, \"fuchsia\");\tdic.put(6, \"yellow\");\tdic.put(7, \"white\");\n\t\twhile(sc.hasNext()){\n\t\t\tString s=sc.next();\n\t\t\tif(s.equals(\"0\"))\tbreak;\n\t\t\tint r=Integer.parseInt(\"\"+s.charAt(1)+s.charAt(2),16), g=Integer.parseInt(\"\"+s.charAt(3)+s.charAt(4),16), b=Integer.parseInt(\"\"+s.charAt(5)+s.charAt(6),16);\n\t\t\tint index=0;\n\t\t\tdouble last=Double.MAX_VALUE;\n\t\t\tfor(int i=0; i<8; i++){\n\t\t\t\tdouble d=sqrt((abs(r-R[i])<<1)+(abs(g-G[i])<<1)+(abs(b-B[i])<<1));\n\t\t\t\tindex = last>d? i : index;\n\t\t\t\tlast = last>d? d : last;\n\t\t\t}\n\t\t\tout.println(dic.get(index));\n\t\t}\n\t}\n\t\n\tvoid AOJ0175(){\t// A King in Hawaii\n\t\twhile(sc.hasNext()){\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n<0)\tbreak;\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile(n!=0){\n\t\t\t\t//out.println(n&3);\n\t\t\t\tsb.append(n&3);\n\t\t\t\tn=n>>2;\n\t\t\t}\n\t\t\tout.println(sb.length()>0? sb.reverse(): 0);\n\t\t}\n\t}\n\t\n\tvoid AOJ0031(){\t// Weight\n\t\twhile(sc.hasNext()){\n\t\t\tint n=sc.nextInt();\n\t\t\tint temp=Integer.lowestOneBit(n);\n\t\t\tout.print(temp);\n\t\t\tn=(n^temp);\n\t\t\twhile(n!=0){\n\t\t\t\ttemp=Integer.lowestOneBit(n);\n\t\t\t\tout.print(\" \"+temp);\n\t\t\t\tn=(n^temp);\n\t\t\t}\n\t\t\tout.println();\n\t\t}\n\t}\n\t\n\tvoid AOJ0051(){\t// Differential II\n\t\tint n=sc.nextInt();\n\t\tfor(int i=0; i<n; i++){\n\t\t\tchar[] c = sc.next().toCharArray();\n\t\t\tint[] a = new int[8];\n\t\t\tfor(int j=0; j<8; j++)\ta[j]=Character.digit(c[j], 10);\n\t\t\tArrays.sort(a);\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor(int j=0; j<8; j++)\tsb.append(a[j]);\n\t\t\tint min=Integer.parseInt(sb.toString());\n\t\t\tsb=new StringBuilder();\n\t\t\tfor(int j=7; j>=0; j--)\tsb.append(a[j]);\n\t\t\tint max=Integer.parseInt(sb.toString());\n\t\t\tout.println(max-min);\n\t\t}\n\t}\n\t\n\tvoid AOJ0196(){\t// Baseball Championship\n\t\twhile(sc.hasNext()){\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n==0)\tbreak;\n\t\t\tTeam196[] teams = new Team196[n];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tString s=sc.next();\n\t\t\t\tint win=0, lose=0;\n\t\t\t\tfor(int j=0; j<n-1; j++){\n\t\t\t\t\tint temp=sc.nextInt();\n\t\t\t\t\tif(temp==0)\twin++;\n\t\t\t\t\tif(temp==1)\tlose++;\n\t\t\t\t}\n\t\t\t\tteams[i] = new Team196(s,win,lose,i);\n\t\t\t}\n\t\t\tArrays.sort(teams);\n\t\t\tfor(int i=0; i<n; i++)\tout.println(teams[i].name);\n\t\t}\n\t}\n\tclass Team196 implements Comparable<Team196>{\n\t\tString name;\n\t\tint win,lose,index;\n\t\tTeam196(String name, int win, int lose, int index){\n\t\t\tthis.name=name;\tthis.win=win;\tthis.lose=lose;\tthis.index=index;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Team196 o) {\n\t\t\tif(this.win<o.win)\treturn 1;\n\t\t\tif(this.win>o.win)\treturn -1;\n\t\t\tif(this.lose<o.lose)\treturn -1;\n\t\t\tif(this.lose>o.lose)\treturn 1;\n\t\t\tif(this.index<o.index)\treturn -1;\n\t\t\tif(this.index>o.index)\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tvoid AOJ0065(){\t// Trading\n\t\tfinal int MAX=1000000;\n\t\tint[] current=new int[MAX];\n\t\tint[] last=new int[MAX];\n\t\tboolean flag=false;\n\t\twhile(sc.hasNext()){\n\t\t\tString s=sc.nextLine();\n\t\t\tif(s.equals(\"\")){\n\t\t\t\tflag=true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tScanner sc2 = new Scanner(s).useDelimiter(\",\");\n\t\t\tif(flag)\tlast[sc2.nextInt()]++;\n\t\t\telse\tcurrent[sc2.nextInt()]++;\n\t\t}\n\t\tfor(int i=0; i<MAX; i++)\t\tif(current[i]>0 && last[i]>0)\tout.println(i+\" \"+(current[i]+last[i]));\n\t}\n\t\n\tvoid AOJ0161(){\t// Sport Meet\n\t\twhile(sc.hasNext()){\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n==0)\tbreak;\n\t\t\tTime161[] times = new Time161[n];\n\t\t\tfor(int i=0; i<n; i++)\ttimes[i] = new Time161(sc.nextInt(), (sc.nextInt()*60+sc.nextInt() + sc.nextInt()*60+sc.nextInt() + sc.nextInt()*60+sc.nextInt() + sc.nextInt()*60+sc.nextInt()));\n\t\t\tArrays.sort(times);\n\t\t\tout.println(times[0].num);\tout.println(times[1].num);\tout.println(times[times.length-2].num);\n\t\t}\n\t}\n\tclass Time161 implements Comparable<Time161>{\n\t\tint num, time;\n\t\tTime161(int num, int time){\n\t\t\tthis.num=num;\tthis.time=time;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Time161 o) {\n\t\t\tif(this.time<o.time)\treturn -1;\n\t\t\tif(this.time>o.time)\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tvoid AOJ0138(){\t// Track and Field Competition\n\t\tTime138[] times1st = new Time138[8];\n\t\tTime138[] times2nd = new Time138[8];\n\t\tTime138[] times3rd = new Time138[8];\n\t\tfor(int i=0; i<8; i++)\ttimes1st[i] = new Time138(sc.nextInt(), sc.nextDouble());\n\t\tfor(int i=0; i<8; i++)\ttimes2nd[i] = new Time138(sc.nextInt(), sc.nextDouble());\n\t\tfor(int i=0; i<8; i++)\ttimes3rd[i] = new Time138(sc.nextInt(), sc.nextDouble());\n\t\tArrays.sort(times1st);\tArrays.sort(times2nd);\tArrays.sort(times3rd);\n\t\tfor(int i=0; i<2; i++)\tout.println(times1st[i].num+\" \"+times1st[i].time);\n\t\tfor(int i=0; i<2; i++)\tout.println(times2nd[i].num+\" \"+times2nd[i].time);\n\t\tfor(int i=0; i<2; i++)\tout.println(times3rd[i].num+\" \"+times3rd[i].time);\n\t\tTime138[] times = new Time138[6];\n\t\ttimes[0]=times1st[2]; times[1]=times1st[3];\ttimes[2]=times2nd[2]; times[3]=times2nd[3];\ttimes[4]=times3rd[2]; times[5]=times3rd[3];\n\t\tArrays.sort(times);\n\t\tfor(int i=0; i<2; i++)\tout.println(times[i].num+\" \"+times[i].time);\n\t}\n\tclass Time138 implements Comparable<Time138>{\n\t\tint num;\tdouble time;\n\t\tTime138(int num, double time){\n\t\t\tthis.num=num;\tthis.time=time;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Time138 o) {\n\t\t\tif(this.time<o.time)\treturn -1;\n\t\t\tif(this.time>o.time)\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tvoid AOJ0005(){\t// GCD and LCM\n\t\twhile(sc.hasNext()){\n\t\t\tint a=sc.nextInt(), b=sc.nextInt();\n\t\t\tint temp=gcd(max(a,b), min(a,b));\n\t\t\tout.println(temp+\" \"+max(a,b)/temp*min(a,b));\n\t\t}\n\t}\n\tint gcd(int x, int y){\n\t\tif(y==0)\treturn x;\n\t\telse\treturn gcd(y, x%y);\n\t}\n\t\n\tint c197=0;\n\tvoid AOJ0197(){\t// Greatest Common Divisor: Euclidean Algorithm\n\t\twhile(sc.hasNext()){\n\t\t\tint x=sc.nextInt(), y=sc.nextInt();\n\t\t\tif(x<2)\tbreak;\n\t\t\tc197=0;\n\t\t\tout.println(gcd197(max(x,y), min(x,y))+\" \"+c197);\n\t\t}\n\t}\n\tint gcd197(int x, int y){\n\t\tif(y==0)\treturn x;\n\t\tc197++;\n\t\treturn gcd197(y, x%y);\n\t}\n\t\n\tvoid AOJ0001(){\t// List of Top 3 Hills\n\t\tint[] m = new int[10];\n\t\tfor(int i=0; i<10; i++)\tm[i]=sc.nextInt();\n\t\tArrays.sort(m);\n\t\tfor(int i=9; i>=7; i--)\tout.println(m[i]);\n\t}\n\t\n\tvoid AOJ10029(){\t// Sort II\n\t\tint n=sc.nextInt();\n\t\tint[] ans = new int[n];\n\t\tfor(int i=0; i<n; i++)\tans[i]=sc.nextInt();\n\t\tArrays.sort(ans);\n\t\tout.print(ans[0]);\n\t\tfor(int i=1; i<n; i++)\tout.print(\" \"+ans[i]);\n\t\tout.println();\n\t}\n\t\n\tint[][] p26 = new int[10][10];\n\tint c26=100;\n\tvoid AOJ0026(){\t// Dropping Ink\n\t\tint ans=0;\n\t\twhile(sc.hasNext()){\n\t\t\tScanner sc2 = new Scanner(sc.nextLine()).useDelimiter(\",\");\n\t\t\tint x=sc2.nextInt(), y=sc2.nextInt(), s=sc2.nextInt();\n\t\t\t// out.println(\"x\"+x+\" y\"+y+\" s\"+s);\n\t\t\tans=max(solve26(x,y),ans);\n\t\t\tans=max(solve26(x-1,y),ans);\tans=max(solve26(x+1,y),ans);\n\t\t\tans=max(solve26(x,y-1),ans);\tans=max(solve26(x,y+1),ans);\n\t\t\tif(s>=2){\n\t\t\t\tans=max(solve26(x-1,y-1),ans);\tans=max(solve26(x-1,y+1),ans);\n\t\t\t\tans=max(solve26(x+1,y-1),ans);\tans=max(solve26(x+1,y+1),ans);\n\t\t\t}\n\t\t\tif(s>=3){\n\t\t\t\tans=max(solve26(x-2,y),ans);\tans=max(solve26(x+2,y),ans);\n\t\t\t\tans=max(solve26(x,y-2),ans);\tans=max(solve26(x,y+2),ans);\n\t\t\t}\n\t\t}\n\t\tout.println(c26);\n\t\tout.println(ans);\n\t}\n\tint solve26(int x, int y){\n\t\tint r=-1;\n\t\tif(0<=x && x<=9 && 0<=y && y<=9){\n\t\t\tc26 -= p26[x][y]==0? 1: 0;\n\t\t\tp26[x][y]++;\n\t\t\tr=p26[x][y];\n\t\t}\n\t\treturn r;\t// RA\n\t}\n\t\n\tvoid AOJ0008(){\t//Sum of 4 Integers\n\t\twhile(sc.hasNext()){\n\t\t\tint ans=0, n=sc.nextInt();\n\t\t\tfor(int a=0; a<10; a++){\n\t\t\t\tfor(int b=0; b<10; b++){\n\t\t\t\t\tfor(int c=0; c<10; c++){\n\t\t\t\t\t\tfor(int d=0; d<10; d++)\t\tif((a+b+c+d)==n)\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\t\n\tvoid AOJ0055(){\t// Sequence\n\t\twhile(sc.hasNext()){\n\t\t\tdouble last=sc.nextDouble(), ans=last;\n\t\t\tfor(int i=2; i<=10; i++){\n\t\t\t\tans+= i%2==0? last*2: last/3;\n\t\t\t\tlast = i%2==0? last*2: last/3;\n\t\t\t\t// out.println(last);\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\t\n\tvoid AOJ0084(){\t// Search Engine\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(sc.hasNext()){\n\t\t\tString s=sc.next().replaceAll(\",\", \"\").replaceAll(\"\\\\.\", \"\").replaceAll(\" \", \"\");\n\t\t\t// out.println(s);\n\t\t\tif(s.length()<=2 || s.length()>=7)\tcontinue;\n\t\t\tsb.append(s+\" \");\n\t\t}\n\t\tout.println(sb.deleteCharAt(sb.length()-1));\n\t}\n\t\n\tvoid AOJ0077(){\t// Run Length\n\t\twhile(sc.hasNext()){\n\t\t\tchar[] c=sc.nextLine().toCharArray();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor(int i=0; i<c.length; i++){\n\t\t\t\tif(c[i]=='@'){\n\t\t\t\t\tfor(int j=0; j<Character.digit(c[i+1], 10); j++)\tsb.append(c[i+2]);\n\t\t\t\t\ti+=2;\n\t\t\t\t}else\tsb.append(c[i]);\n\t\t\t}\n\t\t\tout.println(sb.toString());\n\t\t}\n\t}\n\t\n\tvoid AOJ0064(){\t// Secret Number\n\t\tint ans=0;\n\t\twhile(sc.hasNext()){\n\t\t\tMatcher m = Pattern.compile(\"\\\\d+\").matcher(sc.nextLine());\n\t\t\twhile(m.find())\tans+=Integer.parseInt(m.group());\n\t\t}\n\t\tout.println(ans);\n\t}\n\t\n\tvoid AOJ0050(){\t// Apple and Peach\n\t\twhile(sc.hasNext()) out.println(sc.nextLine().replaceAll(\"apple\", \"PEACH\").replaceAll(\"peach\", \"apple\").replaceAll(\"PEACH\", \"peach\"));\n\t}\n\t\n\tvoid AOJ0039(){\t// Roman Figure\n\t\tHashMap<Character,Integer> dic = new HashMap<Character,Integer>();\n\t\tdic.put('I', 1);\tdic.put('V', 5);\tdic.put('X', 10);\tdic.put('L', 50);\n\t\tdic.put('C', 100);\tdic.put('D', 500);\tdic.put('M', 1000);\n\t\twhile(sc.hasNext()){\n\t\t\tchar[] c = sc.next().toCharArray();\n\t\t\tint ans=0,last=dic.get(c[0]);\n\t\t\tfor(int i=0; i<c.length; i++){\n\t\t\t\tif(last>=dic.get(c[i])){\n\t\t\t\t\tans+=dic.get(c[i]);\n\t\t\t\t\tlast=dic.get(c[i]);\n\t\t\t\t}else{\n\t\t\t\t\tans+=dic.get(c[i])-last-last;\n\t\t\t\t\tlast=dic.get(c[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\t\n\tvoid AOJ0020(){\t// Capitalize\n\t\twhile(sc.hasNext())\tout.println(sc.nextLine().toUpperCase());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "// A New Plan of Aizu Ski Resort\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint w = sc.nextInt(), h = sc.nextInt();\n\t\t\tif ((w | h) == 0)\n\t\t\t\tbreak;\n\t\t\tint[][] field = new int[h][w];\n\t\t\tint[][] dp = new int[h][w];\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\t\tfield[i][j] = sc.nextInt();\n\t\t\tfor (int i = 0; i < w; i++)\n\t\t\t\tif (field[0][i] == 0)\n\t\t\t\t\tdp[0][i] = 1;\n\t\t\tfor (int i = 0; i < h - 1; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tswitch (field[i][j]) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tif (field[i + 1][j] != 1)\n\t\t\t\t\t\t\tdp[i + 1][j] += dp[i][j];\n\t\t\t\t\t\tif (j >= 1 && field[i + 1][j - 1] == 0)\n\t\t\t\t\t\t\tdp[i + 1][j - 1] += dp[i][j];\n\t\t\t\t\t\tif (j < w - 1 && field[i + 1][j + 1] == 0)\n\t\t\t\t\t\t\tdp[i + 1][j + 1] += dp[i][j];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tif (i < h - 2 && field[i + 2][j] != 1)\n\t\t\t\t\t\t\tdp[i + 2][j] += dp[i][j];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint result = 0;\n\t\t\tfor (int i = 0; i < w; i++) {\n\t\t\t\tresult += dp[h - 1][i];\n\t\t\t\tif (h >= 2 && field[h - 2][i] == 2)\n\t\t\t\t\tresult += dp[h - 2][i];\n\t\t\t}\n\t\t\tSystem.out.println(result);\n\t\t}\n\t\tsc.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tw = scanner.nextInt();\n\t\t\th = scanner.nextInt();\n\t\t\tif ((w | h) == 0)\n\t\t\t\tbreak;\n\t\t\tmap = new int[h][w + 2];\n\t\t\tfor (int[] a : map)\n\t\t\t\tArrays.fill(a, 1);\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\t\tmap[i][j] = scanner.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[][] dp = new int[h][w + 2];\n\t\t\tfor (int i = 1; i <= w; i++) {\n\t\t\t\tif (map[0][i] == 0)\n\t\t\t\t\tdp[0][i] = 1;\n\t\t\t}\n\t\t\tfor (int i = 1; i < h; i++) {\n\t\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\t\tif (map[i][j] == 0) {\n\t\t\t\t\t\tfor (int k = -1; k < 2; k++) {\n\t\t\t\t\t\t\tif (map[i - 1][j + k] == 0)\n\t\t\t\t\t\t\t\tdp[i][j] += dp[i - 1][j + k];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if (map[i][j] == 2) {\n\t\t\t\t\t\tif (map[i - 1][j] == 0)\n\t\t\t\t\t\t\tdp[i][j] += dp[i - 1][j];\n\t\t\t\t\t}\n\t\t\t\t\tif (i > 1 && map[i - 2][j] == 2)\n\t\t\t\t\t\tdp[i][j] += dp[i - 2][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sum = 0;\n\t\t\tfor (int i = 1; i <= w; i++) {\n\t\t\t\tsum += dp[h - 1][i];\n\t\t\t\tif (h > 1 && map[h - 2][i] == 2)\n\t\t\t\t\tsum += dp[h - 2][i];\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n\n\tint count;\n\tint w;\n\tint h;\n\tint[][] map;\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\tint w, h;\n\t\twhile (((w = s.nextInt()) != 0 && ((h = s.nextInt()) != 0))) {\n\t\t\tint[][] t = new int[h+1][w+2];\n\t\t\tint[][] d = new int[h+1][w+2];\n\t\t\tfor (int y = 0; y <= h; y++)\n\t\t\t\tfor (int x = 0; x <= w+1; x++) {\n\t\t\t\t\tif (1 <= x && x <= w && 1 <= y && y <= h) t[y][x] = s.nextInt();\n\t\t\t\t\telse t[y][x] = -1;\n\t\t\t\t\td[y][x] = 0;\n\t\t\t\t}\n\t\t\t\n\t\t\tfor (int x = 1; x <= w; x++) \n\t\t\t\tif (t[1][x] == 0) d[1][x] = 1;\n\n\t\t\tfor (int y = 2; y <= h; y++) \n\t\t\t\tfor (int x = 1; x <= w; x++) {\n\t\t\t\t\tif (t[y][x] == 0) {\n\t\t\t\t\t\tif (t[y-1][x-1] == 0) d[y][x] += d[y-1][x-1];\n\t\t\t\t\t\tif (t[y-1][x+1] == 0) d[y][x] += d[y-1][x+1];\n\t\t\t\t\t}\n\t\t\t\t\tif (t[y][x] != 1) {\n\t\t\t\t\t\tif (t[y-1][x] == 0) d[y][x] += d[y-1][x];\n\t\t\t\t\t\tif (t[y-2][x] == 2) d[y][x] += d[y-2][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\tint sum = 0;\n\t\t\tfor (int x = 1; x <= w; x++) sum += d[h][x];\n\t\t\tfor (int x = 1; x <= w; x++) \n\t\t\t\tif (t[h-1][x] == 2) sum += d[h-1][x];\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\npublic class Main {\n\n\tpublic void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint x = sc.nextInt();\n\t\t\tint y = sc.nextInt();\n\t\t\tif(x == 0 && y == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint [][] dp = new int[y+2][x+2];\n\t\t\tint [][] data = new int[y+2][x+2];\n\t\t\tfor(int i=1; i< y+1; i++){\n\t\t\t\tfor(int j=1; j < x + 1; j++){\n\t\t\t\t\tdata[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\t//set a first value\n\t\t\tfor(int i=1; i < x+1; i++){\n\t\t\t\tdp[1][i] = 1;\n\t\t\t}\n\n\t\t\t//calc a dp\n\t\t\tfor(int i=1; i <= y-1; i++){\n\t\t\t\tfor(int j=1; j <= x; j++){\n\t\t\t\t\tint posSta = data[i][j];\n\t\t\t\t\tif(posSta == 1){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse if(posSta == 2){\n\t\t\t\t\t\tdp[i+2][j] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\t//left buttom\n\t\t\t\t\t\tif(data[i+1][j-1] != 2){\n\t\t\t\t\t\t\tdp[i+1][j-1] += dp[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//buttom\n\t\t\t\t\t\tdp[i+1][j] += dp[i][j];\n\n\t\t\t\t\t\t//right buttom\n\t\t\t\t\t\tif(data[i+1][j+1] != 2){\n\t\t\t\t\t\t\tdp[i+1][j+1] += dp[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//print\n\t\t\tint sum = 0;\n\t\t\tfor(int i=y; i <= y + 1; i++){\n\t\t\t\tfor(int j=1; j <= x; j++){\n\t\t\t\t\tif(data[i][j] == 1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tsum += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doIt();\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main2 {\n\n\tstatic int H,W;\n\tstatic int[][] field;\n\tstatic int[][] dp;\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tW=cin.nextInt();\n\t\t\tH=cin.nextInt();\n\t\t\tif(W+H==0)break;\n\t\t\tfield=new int[H+2][W];\n\t\t\tdp=new int[H+2][W];\n\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\tfield[i][j]=cin.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<W;i++){\n\t\t\t\tif(field[0][i]==0)dp[0][i]=1;\n\t\t\t}\n\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\tif(field[i][j]==0){\n\t\t\t\t\t\tif(i!=H-1){\n\t\t\t\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\t\t\t\tif(j+k<0||j+k>=W)continue;\n\t\t\t\t\t\t\t\tif(field[i+1][j+k]==1)continue;\n\t\t\t\t\t\t\t\tif(k!=0&&field[i+1][j+k]==2)continue;\n\t\t\t\t\t\t\t\tdp[i+1][j+k]+=dp[i][j];\n\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tdp[i+1][j]+=dp[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(field[i][j]==2){\n\t\t\t\t\t\tdp[i+2][j]+=dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans=0;\n\t\t\tfor(int i=H;i<H+2;i++){\n\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\tans+=dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t\t\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.awt.geom.*;\nimport java.math.*;\n\npublic class Main {\n\n\tstatic final Scanner in = new Scanner(System.in);\n\tstatic final PrintWriter out = new PrintWriter(System.out,false);\n\tstatic boolean debug = false;\n\n\tstatic int[] dy = { 1, 1, 1,};\n\tstatic int[] dx = { -1, 0, 1};\n\n\tstatic boolean solve() {\n\t\tint w = in.nextInt();\n\t\tint h = in.nextInt();\n\t\tif (w + h == 0) return false;\n\n\t\tint[][] t = new int[h][w];\n\t\tfor (int i=0; i<h; i++) {\n\t\t\tfor (int j=0; j<w; j++) {\n\t\t\t\tt[i][j] = in.nextInt();\n\t\t\t}\n\t\t}\n\n\t\tint[][] dp = new int[h][w];\n\t\tfor (int i=0; i<w; i++) {\n\t\t\tif (t[0][i] == 0) dp[0][i] = 1;\n\t\t}\n\n\t\tfor (int i=1; i<h; i++) {\n\t\t\tfor (int j=0; j<w; j++) {\n\t\t\t\tif (t[i][j] == 1) continue;\n\t\t\t\tint sum = 0;\n\t\t\t\tif (j - 1 >= 0 && t[i][j] != 2 && t[i-1][j-1] == 0) {\n\t\t\t\t\tsum += dp[i-1][j-1];\n\t\t\t\t}\n\t\t\t\tif (j + 1 < w && t[i][j] != 2 && t[i-1][j+1] == 0) {\n\t\t\t\t\tsum += dp[i-1][j+1];\n\t\t\t\t}\n\t\t\t\tif (t[i-1][j] == 0) {\n\t\t\t\t\tsum += dp[i-1][j];\n\t\t\t\t}\n\t\t\t\tif (i - 2 >= 0 && t[i-2][j] == 2) {\n\t\t\t\t\tsum += dp[i-2][j];\n\t\t\t\t}\n\t\t\t\tdp[i][j] = sum;\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor (int i=0; i<w; i++) {\n\t\t\tans += dp[h-1][i];\n\t\t\tif (h - 2 >= 0 && t[h-2][i] == 2) {\n\t\t\t\tans += dp[h-2][i];\n\t\t\t}\n\t\t}\n\n\t\tout.println(ans);\n\n\t\treturn true;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tdebug = args.length > 0;\n\t\tlong start = System.nanoTime();\n\n\t\twhile(solve());\n\t\tout.flush();\n\n\t\tlong end = System.nanoTime();\n\t\tdump((end - start) / 1000000 + \" ms\");\n\t\tin.close();\n\t\tout.close();\n\t}\n\n\tstatic void dump(Object... o) { if (debug) System.err.println(Arrays.deepToString(o)); }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.*;\n\nimport static java.lang.Math.*;\nimport static java.lang.System.out;\n\n// AOJ\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().AOJ0203();\n\t}\n\t\n\tvoid AOJ0203(){\t// A New Plan of Aizu Ski Resort\n\t\twhile(sc.hasNext()){\n\t\t\tint x=sc.nextInt(), y=sc.nextInt();\n\t\t\tif(x==0)\tbreak;\n\t\t\tint[][] dp=new int[x+3][y+3],b=new int[x+2][y+2];\n\t\t\tfor(int j=1; j<=y; j++){\n\t\t\t\tfor(int i=1; i<=x; i++)\tb[i][j]=sc.nextInt();\n\t\t\t}\n\t\t\tfor(int i=1; i<=x; i++)\tdp[i][1]= b[i][1]==1?0:1;\n\t\t\tfor(int j=1; j<=y; j++){\n\t\t\t\tfor(int i=1; i<=x; i++){\n\t\t\t\t\tif(b[i][j]==2)\tdp[i][j]= dp[i][j-1];\n\t\t\t\t\telse if(b[i][j]==0){\n\t\t\t\t\t\tfor(int k=i-1; k<=i+1; k++)\tdp[i][j]+=b[k][j-1]==0?dp[k][j-1]:0;\t\n\t\t\t\t\t}\n\t\t\t\t\tif(j>2 && b[i][j]!=1)\tdp[i][j]+= b[i][j-2]==2?dp[i][j-2]:0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// debug\n\t\t\t/*\n\t\t\tfor(int j=1; j<=y; j++){\n\t\t\t\tfor(int i=1; i<=x; i++)\tout.print(dp[i][j]+\" \");\n\t\t\t\tout.println();\n\t\t\t}\n\t\t\t*/\n\t\t\tint ans=0;\n\t\t\tfor(int i=1; i<=x; i++)\tans+= dp[i][y]+(b[i][y-1]==2?dp[i][y-1]:0);\n\t\t\tout.println(ans);\n\t\t}\n\t\t\n\t}\n\t\n\t// RE\n\tvoid AOJ0089(){\t// The Shortest Path on A Rhombic Path\n\t\tint[][] dp=new int[200][200];\n\t\tdp[1][1]=sc.nextInt();\n\t\tint idx=2, lastLen=1;\n\t\twhile(sc.hasNext()){\n\t\t\tString s=sc.next();\n\t\t\tScanner sc2=new Scanner(s).useDelimiter(\",\");\n\t\t\tint len=(int)((double)s.length()/(double)2+0.5);\n\t\t\tfor(int i=1; i<=len; i++){\n\t\t\t\tif(len>lastLen)\tdp[i][idx]=sc2.nextInt()+max(dp[i][idx-1], dp[i-1][idx-1]);\n\t\t\t\telse\tdp[i][idx]=sc2.nextInt()+max(dp[i][idx-1], dp[i+1][idx-1]);\n\t\t\t}\n\t\t\tlastLen=len;\n\t\t\tidx++;\n\t\t}\n\t\t//debug\n\t\t\n\t\tfor(int i=0; i<=idx; i++){\n\t\t\tfor(int j=0; j<=(int)((double)idx/2+0.5); j++)\tout.printf(\"%4d\",dp[j][i]);\n\t\t\tout.println();\n\t\t}\n\t\t\n\t\tout.println(dp[1][idx-1]);\n\t}\n\t\n\tvoid AOJ0004(){\n\t\t//while(sc.hasNext()){\n\t\t\t// int a=sc.nextInt(), b=sc.nextInt(), c=sc.nextInt(), d=sc.nextInt(), e=sc.nextInt(), f=sc.nextInt();\n\t\t\t// ax + by = c\n\t\t\t// dx + ey = f\n\t\t//}\n\t}\n\t\n\tvoid AOJ0042(){\t// A Thief\n\t\tint num=1;\n\t\twhile(sc.hasNext()){\n\t\t\tint w=sc.nextInt();\n\t\t\tif(w==0)\tbreak;\n\t\t\tint n=sc.nextInt();\n\t\t\tint[][] dp=new int[n+1][w+1];\n\t\t\tint[] ww=new int[n+1], pp=new int[n+1];\n\t\t\tfor(int i=1; i<=n; i++){\n\t\t\t\tScanner sc2=new Scanner(sc.next()).useDelimiter(\",\");\n\t\t\t\tpp[i]=sc2.nextInt();\n\t\t\t\tww[i]=sc2.nextInt();\n\t\t\t}\n\t\t\tint ans=0, wei=Integer.MAX_VALUE;\n\t\t\tfor(int i=1; i<=n; i++){\n\t\t\t\tfor(int j=1; j<=w; j++){\n\t\t\t\t\tdp[i][j]=max(dp[i-1][j], j>=ww[i]?dp[i-1][j-ww[i]]+pp[i]:dp[i-1][j]);\n\t\t\t\t\tif(dp[i][j]>ans){\n\t\t\t\t\t\twei=j;\n\t\t\t\t\t\tans=dp[i][j];\n\t\t\t\t\t}else if(dp[i][j]==ans){\n\t\t\t\t\t\twei=min(wei,j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//debug\n\t\t\t/*\n\t\t\tfor(int i=0; i<=w; i++){\n\t\t\t\tfor(int j=0; j<=n; j++)\tout.printf(\"%4d\",dp[j][i]);\n\t\t\t\tout.println();\n\t\t\t}\n\t\t\t*/\n\t\t\t\n\t\t\tout.println(\"Case \"+(num++)+\":\");\n\t\t\tout.println(ans);\n\t\t\tout.println(wei);\n\t\t}\n\t}\n\n\tvoid AOJ0003(){\n\t\tint n=sc.nextInt();\n\t\twhile(n-->0){\n\t\t\tint[] a=new int[3];\n\t\t\tfor(int i=0; i<3; i++)\ta[i]=sc.nextInt();\n\t\t\tArrays.sort(a);\n\t\t\tif(a[2]*a[2]==(a[1]*a[1])+(a[0]*a[0]))\tout.println(\"YES\");\n\t\t\telse\tout.println(\"NO\");\n\t\t}\n\t}\n\t\n\tvoid AOJ0002(){\n\t\twhile(sc.hasNext())\tout.println(new String(\"\"+(sc.nextInt()+sc.nextInt())).length());\n\t}\n\t\n\tvoid AOJ0516(){\n\t\twhile(sc.hasNext()){\n\t\t\tint n=sc.nextInt(), k=sc.nextInt(), ans=0;\n\t\t\tif(n==0)\tbreak;\n\t\t\tint[] sum=new int[n+1];\n\t\t\tfor(int i=1; i<=n; i++)\tsum[i]=sum[i-1]+sc.nextInt();\n\t\t\tfor(int i=k; i<=n; i++)\tans=max(ans, sum[i]-sum[i-k]);\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\t\n\tc547[][] r;\n\tfinal int MOD547=100000;\n\tvoid AOJ0547(){\t// Commute routes\n\t\twhile(sc.hasNext()){\n\t\t\tint w=sc.nextInt(), h=sc.nextInt();\n\t\t\tif(w<2)\tbreak;\n\t\t\tr=new c547[w+1][h+1];\n\t\t\tr[2][1]=new c547(0,0,0,1);\tr[1][2]=new c547(0,1,0,0);\n\t\t\tfor(int x=1; x<=w; x++){\n\t\t\t\tfor(int y=1; y<=h; y++)\tr[x][y] = r[x][y]==null?solve547(x,y): r[x][y];\n\t\t\t}\n\t\t\t//r[w][h].list();\n\t\t\tout.println(r[w][h].sum());\n\t\t}\n\t}\n\tc547 solve547(int x, int y){\n\t\tint s1=y-1>0? r[x][y-1].w2:0;\n\t\tint s2=y-1>0? (r[x][y-1].s1+r[x][y-1].s2)%MOD547:0;\n\t\tint w1=x-1>0? r[x-1][y].s2:0;\n\t\tint w2=x-1>0? (r[x-1][y].w1+r[x-1][y].w2)%MOD547:0;\n\t\treturn new c547(s1, s2, w1, w2);\n\t}\n\tclass c547{\n\t\tint s1, s2, w1, w2;\n\t\tc547(int s1, int s2, int w1, int w2){\n\t\t\tthis.s1=s1; this.s2=s2; this.w1=w1; this.w2=w2;\n\t\t}\n\t\tint sum(){\n\t\t\treturn (this.s1 + this.s2 + this.w1 + this.w2)%MOD547;\n\t\t}\n\t\tvoid list(){\n\t\t\tout.println(\"(\"+this.s1+\" \"+this.s2+\" \"+this.w1+\" \"+this.w2+\")\");\n\t\t}\n\t}\n\t\n\tint[][] a1209;\n\tvoid AOJ1209(){\n\t\twhile(sc.hasNext()){\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n<=0)\tbreak;\n\t\t\ta1209=new int[18][n+1];\n\t\t\tfor(int i=0; i<=n; i++)\ta1209[1][i]=1;\n\t\t\tfor(int x=2; x<=17; x++){\n\t\t\t\tfor(int y=1; y<=n; y++)\ta1209[x][y]=solve1209(x,y);\n\t\t\t}\n\t\t\tint ans=0;\n\t\t\tfor(int i=1; i<=17; i++)\tans+=a1209[i][n];\n\t\t\tout.println(ans);\n\t\t\t\n\t\t\t// debug\n\t\t\t/*\n\t\t\tfor(int i=0; i<=n; i++){\n\t\t\t\tfor(int j=0; j<=17; j++)\tout.print(a1209[j][i]+\" \");\n\t\t\t\tout.println();\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t}\n\tint solve1209(int x, int y){\n\t\tint ans=0;\n\t\tfor(int i=x;i>0; i--)\tans+= y-(x*x)>=0?a1209[i][y-(x*x)]:0;\n\t\treturn ans;\n\t}\n\t\n\tint[][] r515;\n\tboolean[][] b515;\n\tvoid AOJ0515(){\t// School Road\n\t\twhile(sc.hasNext()){\n\t\t\tint xn=sc.nextInt(), yn=sc.nextInt();\n\t\t\tif(xn<=0)\tbreak;\n\t\t\tint n=sc.nextInt();\n\t\t\tb515 = new boolean[xn+1][yn+1];\n\t\t\tfor(int i=0; i<n; i++)\tb515[sc.nextInt()][sc.nextInt()]=true;\n\t\t\tr515=new int[xn+1][yn+1];\n\t\t\tr515[1][1]=1;\n\t\t\tfor(int x=1; x<=xn; x++){\n\t\t\t\tfor(int y=1; y<=yn; y++){\n\t\t\t\t\tif(x==1&&y==1)\tcontinue;\n\t\t\t\t\tr515[x][y]=solve515(x,y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(r515[xn][yn]);\n\t\t}\n\t}\n\tint solve515(int x, int y){\n\t\tint ans=0;\n\t\tif(!b515[x][y]){\n\t\t\tans+= y-1>0? r515[x][y-1]:0;\n\t\t\tans+= x-1>0? r515[x-1][y]:0;\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\t\n\tint[] a168;\n\tvoid AOJ0168(){\t// Kannondou\n\t\twhile(sc.hasNext()){\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n<=0)\tbreak;\n\t\t\ta168=new int[n+1];\n\t\t\ta168[0]=1;\n\t\t\tfor(int i=1; i<=n; i++)\ta168[i]=solve168(i);\n\t\t\tint day=(a168[n]/10) + (a168[n]%10==0? 0: 1);\n\t\t\t// out.println(\"n\"+a168[n]+\" day\"+day);\n\t\t\tout.println(((day/365) + (day%365==0?0 :1)));\n\t\t}\n\t}\n\tint solve168(int a){\n\t\tint ans=0;\n\t\tfor(int i=a-1; i>=a-3; i--)\tans+= i>=0? a168[i]: 0;\n\t\treturn ans;\n\t}\n\t\n\tvoid AOJ0176(){\t// What Color?\n\t\tint[] R = {0,0,0,0,255,255,255,255};\n\t\tint[] G = {0,0,255,255,0,0,255,255};\n\t\tint[] B = {0,255,0,255,0,255,0,255};\n\t\tHashMap<Integer,String> dic = new HashMap<Integer,String>();\n\t\tdic.put(0, \"black\");\tdic.put(1, \"blue\");\tdic.put(2, \"lime\");\tdic.put(3, \"aqua\");\n\t\tdic.put(4, \"red\");\tdic.put(5, \"fuchsia\");\tdic.put(6, \"yellow\");\tdic.put(7, \"white\");\n\t\twhile(sc.hasNext()){\n\t\t\tString s=sc.next();\n\t\t\tif(s.equals(\"0\"))\tbreak;\n\t\t\tint r=Integer.parseInt(\"\"+s.charAt(1)+s.charAt(2),16), g=Integer.parseInt(\"\"+s.charAt(3)+s.charAt(4),16), b=Integer.parseInt(\"\"+s.charAt(5)+s.charAt(6),16);\n\t\t\tint index=0;\n\t\t\tdouble last=Double.MAX_VALUE;\n\t\t\tfor(int i=0; i<8; i++){\n\t\t\t\tdouble d=sqrt((abs(r-R[i])<<1)+(abs(g-G[i])<<1)+(abs(b-B[i])<<1));\n\t\t\t\tindex = last>d? i : index;\n\t\t\t\tlast = last>d? d : last;\n\t\t\t}\n\t\t\tout.println(dic.get(index));\n\t\t}\n\t}\n\t\n\tvoid AOJ0175(){\t// A King in Hawaii\n\t\twhile(sc.hasNext()){\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n<0)\tbreak;\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile(n!=0){\n\t\t\t\t//out.println(n&3);\n\t\t\t\tsb.append(n&3);\n\t\t\t\tn=n>>2;\n\t\t\t}\n\t\t\tout.println(sb.length()>0? sb.reverse(): 0);\n\t\t}\n\t}\n\t\n\tvoid AOJ0031(){\t// Weight\n\t\twhile(sc.hasNext()){\n\t\t\tint n=sc.nextInt();\n\t\t\tint temp=Integer.lowestOneBit(n);\n\t\t\tout.print(temp);\n\t\t\tn=(n^temp);\n\t\t\twhile(n!=0){\n\t\t\t\ttemp=Integer.lowestOneBit(n);\n\t\t\t\tout.print(\" \"+temp);\n\t\t\t\tn=(n^temp);\n\t\t\t}\n\t\t\tout.println();\n\t\t}\n\t}\n\t\n\tvoid AOJ0051(){\t// Differential II\n\t\tint n=sc.nextInt();\n\t\tfor(int i=0; i<n; i++){\n\t\t\tchar[] c = sc.next().toCharArray();\n\t\t\tint[] a = new int[8];\n\t\t\tfor(int j=0; j<8; j++)\ta[j]=Character.digit(c[j], 10);\n\t\t\tArrays.sort(a);\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor(int j=0; j<8; j++)\tsb.append(a[j]);\n\t\t\tint min=Integer.parseInt(sb.toString());\n\t\t\tsb=new StringBuilder();\n\t\t\tfor(int j=7; j>=0; j--)\tsb.append(a[j]);\n\t\t\tint max=Integer.parseInt(sb.toString());\n\t\t\tout.println(max-min);\n\t\t}\n\t}\n\t\n\tvoid AOJ0196(){\t// Baseball Championship\n\t\twhile(sc.hasNext()){\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n==0)\tbreak;\n\t\t\tTeam196[] teams = new Team196[n];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tString s=sc.next();\n\t\t\t\tint win=0, lose=0;\n\t\t\t\tfor(int j=0; j<n-1; j++){\n\t\t\t\t\tint temp=sc.nextInt();\n\t\t\t\t\tif(temp==0)\twin++;\n\t\t\t\t\tif(temp==1)\tlose++;\n\t\t\t\t}\n\t\t\t\tteams[i] = new Team196(s,win,lose,i);\n\t\t\t}\n\t\t\tArrays.sort(teams);\n\t\t\tfor(int i=0; i<n; i++)\tout.println(teams[i].name);\n\t\t}\n\t}\n\tclass Team196 implements Comparable<Team196>{\n\t\tString name;\n\t\tint win,lose,index;\n\t\tTeam196(String name, int win, int lose, int index){\n\t\t\tthis.name=name;\tthis.win=win;\tthis.lose=lose;\tthis.index=index;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Team196 o) {\n\t\t\tif(this.win<o.win)\treturn 1;\n\t\t\tif(this.win>o.win)\treturn -1;\n\t\t\tif(this.lose<o.lose)\treturn -1;\n\t\t\tif(this.lose>o.lose)\treturn 1;\n\t\t\tif(this.index<o.index)\treturn -1;\n\t\t\tif(this.index>o.index)\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tvoid AOJ0065(){\t// Trading\n\t\tfinal int MAX=1000000;\n\t\tint[] current=new int[MAX];\n\t\tint[] last=new int[MAX];\n\t\tboolean flag=false;\n\t\twhile(sc.hasNext()){\n\t\t\tString s=sc.nextLine();\n\t\t\tif(s.equals(\"\")){\n\t\t\t\tflag=true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tScanner sc2 = new Scanner(s).useDelimiter(\",\");\n\t\t\tif(flag)\tlast[sc2.nextInt()]++;\n\t\t\telse\tcurrent[sc2.nextInt()]++;\n\t\t}\n\t\tfor(int i=0; i<MAX; i++)\t\tif(current[i]>0 && last[i]>0)\tout.println(i+\" \"+(current[i]+last[i]));\n\t}\n\t\n\tvoid AOJ0161(){\t// Sport Meet\n\t\twhile(sc.hasNext()){\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n==0)\tbreak;\n\t\t\tTime161[] times = new Time161[n];\n\t\t\tfor(int i=0; i<n; i++)\ttimes[i] = new Time161(sc.nextInt(), (sc.nextInt()*60+sc.nextInt() + sc.nextInt()*60+sc.nextInt() + sc.nextInt()*60+sc.nextInt() + sc.nextInt()*60+sc.nextInt()));\n\t\t\tArrays.sort(times);\n\t\t\tout.println(times[0].num);\tout.println(times[1].num);\tout.println(times[times.length-2].num);\n\t\t}\n\t}\n\tclass Time161 implements Comparable<Time161>{\n\t\tint num, time;\n\t\tTime161(int num, int time){\n\t\t\tthis.num=num;\tthis.time=time;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Time161 o) {\n\t\t\tif(this.time<o.time)\treturn -1;\n\t\t\tif(this.time>o.time)\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tvoid AOJ0138(){\t// Track and Field Competition\n\t\tTime138[] times1st = new Time138[8];\n\t\tTime138[] times2nd = new Time138[8];\n\t\tTime138[] times3rd = new Time138[8];\n\t\tfor(int i=0; i<8; i++)\ttimes1st[i] = new Time138(sc.nextInt(), sc.nextDouble());\n\t\tfor(int i=0; i<8; i++)\ttimes2nd[i] = new Time138(sc.nextInt(), sc.nextDouble());\n\t\tfor(int i=0; i<8; i++)\ttimes3rd[i] = new Time138(sc.nextInt(), sc.nextDouble());\n\t\tArrays.sort(times1st);\tArrays.sort(times2nd);\tArrays.sort(times3rd);\n\t\tfor(int i=0; i<2; i++)\tout.println(times1st[i].num+\" \"+times1st[i].time);\n\t\tfor(int i=0; i<2; i++)\tout.println(times2nd[i].num+\" \"+times2nd[i].time);\n\t\tfor(int i=0; i<2; i++)\tout.println(times3rd[i].num+\" \"+times3rd[i].time);\n\t\tTime138[] times = new Time138[6];\n\t\ttimes[0]=times1st[2]; times[1]=times1st[3];\ttimes[2]=times2nd[2]; times[3]=times2nd[3];\ttimes[4]=times3rd[2]; times[5]=times3rd[3];\n\t\tArrays.sort(times);\n\t\tfor(int i=0; i<2; i++)\tout.println(times[i].num+\" \"+times[i].time);\n\t}\n\tclass Time138 implements Comparable<Time138>{\n\t\tint num;\tdouble time;\n\t\tTime138(int num, double time){\n\t\t\tthis.num=num;\tthis.time=time;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Time138 o) {\n\t\t\tif(this.time<o.time)\treturn -1;\n\t\t\tif(this.time>o.time)\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tvoid AOJ0005(){\t// GCD and LCM\n\t\twhile(sc.hasNext()){\n\t\t\tint a=sc.nextInt(), b=sc.nextInt();\n\t\t\tint temp=gcd(max(a,b), min(a,b));\n\t\t\tout.println(temp+\" \"+max(a,b)/temp*min(a,b));\n\t\t}\n\t}\n\tint gcd(int x, int y){\n\t\tif(y==0)\treturn x;\n\t\telse\treturn gcd(y, x%y);\n\t}\n\t\n\tint c197=0;\n\tvoid AOJ0197(){\t// Greatest Common Divisor: Euclidean Algorithm\n\t\twhile(sc.hasNext()){\n\t\t\tint x=sc.nextInt(), y=sc.nextInt();\n\t\t\tif(x<2)\tbreak;\n\t\t\tc197=0;\n\t\t\tout.println(gcd197(max(x,y), min(x,y))+\" \"+c197);\n\t\t}\n\t}\n\tint gcd197(int x, int y){\n\t\tif(y==0)\treturn x;\n\t\tc197++;\n\t\treturn gcd197(y, x%y);\n\t}\n\t\n\tvoid AOJ0001(){\t// List of Top 3 Hills\n\t\tint[] m = new int[10];\n\t\tfor(int i=0; i<10; i++)\tm[i]=sc.nextInt();\n\t\tArrays.sort(m);\n\t\tfor(int i=9; i>=7; i--)\tout.println(m[i]);\n\t}\n\t\n\tvoid AOJ10029(){\t// Sort II\n\t\tint n=sc.nextInt();\n\t\tint[] ans = new int[n];\n\t\tfor(int i=0; i<n; i++)\tans[i]=sc.nextInt();\n\t\tArrays.sort(ans);\n\t\tout.print(ans[0]);\n\t\tfor(int i=1; i<n; i++)\tout.print(\" \"+ans[i]);\n\t\tout.println();\n\t}\n\t\n\tint[][] p26 = new int[10][10];\n\tint c26=100;\n\tvoid AOJ0026(){\t// Dropping Ink\n\t\tint ans=0;\n\t\twhile(sc.hasNext()){\n\t\t\tScanner sc2 = new Scanner(sc.nextLine()).useDelimiter(\",\");\n\t\t\tint x=sc2.nextInt(), y=sc2.nextInt(), s=sc2.nextInt();\n\t\t\t// out.println(\"x\"+x+\" y\"+y+\" s\"+s);\n\t\t\tans=max(solve26(x,y),ans);\n\t\t\tans=max(solve26(x-1,y),ans);\tans=max(solve26(x+1,y),ans);\n\t\t\tans=max(solve26(x,y-1),ans);\tans=max(solve26(x,y+1),ans);\n\t\t\tif(s>=2){\n\t\t\t\tans=max(solve26(x-1,y-1),ans);\tans=max(solve26(x-1,y+1),ans);\n\t\t\t\tans=max(solve26(x+1,y-1),ans);\tans=max(solve26(x+1,y+1),ans);\n\t\t\t}\n\t\t\tif(s>=3){\n\t\t\t\tans=max(solve26(x-2,y),ans);\tans=max(solve26(x+2,y),ans);\n\t\t\t\tans=max(solve26(x,y-2),ans);\tans=max(solve26(x,y+2),ans);\n\t\t\t}\n\t\t}\n\t\tout.println(c26);\n\t\tout.println(ans);\n\t}\n\tint solve26(int x, int y){\n\t\tint r=-1;\n\t\tif(0<=x && x<=9 && 0<=y && y<=9){\n\t\t\tc26 -= p26[x][y]==0? 1: 0;\n\t\t\tp26[x][y]++;\n\t\t\tr=p26[x][y];\n\t\t}\n\t\treturn r;\t// RA\n\t}\n\t\n\tvoid AOJ0008(){\t//Sum of 4 Integers\n\t\twhile(sc.hasNext()){\n\t\t\tint ans=0, n=sc.nextInt();\n\t\t\tfor(int a=0; a<10; a++){\n\t\t\t\tfor(int b=0; b<10; b++){\n\t\t\t\t\tfor(int c=0; c<10; c++){\n\t\t\t\t\t\tfor(int d=0; d<10; d++)\t\tif((a+b+c+d)==n)\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\t\n\tvoid AOJ0055(){\t// Sequence\n\t\twhile(sc.hasNext()){\n\t\t\tdouble last=sc.nextDouble(), ans=last;\n\t\t\tfor(int i=2; i<=10; i++){\n\t\t\t\tans+= i%2==0? last*2: last/3;\n\t\t\t\tlast = i%2==0? last*2: last/3;\n\t\t\t\t// out.println(last);\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\t\n\tvoid AOJ0084(){\t// Search Engine\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(sc.hasNext()){\n\t\t\tString s=sc.next().replaceAll(\",\", \"\").replaceAll(\"\\\\.\", \"\").replaceAll(\" \", \"\");\n\t\t\t// out.println(s);\n\t\t\tif(s.length()<=2 || s.length()>=7)\tcontinue;\n\t\t\tsb.append(s+\" \");\n\t\t}\n\t\tout.println(sb.deleteCharAt(sb.length()-1));\n\t}\n\t\n\tvoid AOJ0077(){\t// Run Length\n\t\twhile(sc.hasNext()){\n\t\t\tchar[] c=sc.nextLine().toCharArray();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor(int i=0; i<c.length; i++){\n\t\t\t\tif(c[i]=='@'){\n\t\t\t\t\tfor(int j=0; j<Character.digit(c[i+1], 10); j++)\tsb.append(c[i+2]);\n\t\t\t\t\ti+=2;\n\t\t\t\t}else\tsb.append(c[i]);\n\t\t\t}\n\t\t\tout.println(sb.toString());\n\t\t}\n\t}\n\t\n\tvoid AOJ0064(){\t// Secret Number\n\t\tint ans=0;\n\t\twhile(sc.hasNext()){\n\t\t\tMatcher m = Pattern.compile(\"\\\\d+\").matcher(sc.nextLine());\n\t\t\twhile(m.find())\tans+=Integer.parseInt(m.group());\n\t\t}\n\t\tout.println(ans);\n\t}\n\t\n\tvoid AOJ0050(){\t// Apple and Peach\n\t\twhile(sc.hasNext()) out.println(sc.nextLine().replaceAll(\"apple\", \"PEACH\").replaceAll(\"peach\", \"apple\").replaceAll(\"PEACH\", \"peach\"));\n\t}\n\t\n\tvoid AOJ0039(){\t// Roman Figure\n\t\tHashMap<Character,Integer> dic = new HashMap<Character,Integer>();\n\t\tdic.put('I', 1);\tdic.put('V', 5);\tdic.put('X', 10);\tdic.put('L', 50);\n\t\tdic.put('C', 100);\tdic.put('D', 500);\tdic.put('M', 1000);\n\t\twhile(sc.hasNext()){\n\t\t\tchar[] c = sc.next().toCharArray();\n\t\t\tint ans=0,last=dic.get(c[0]);\n\t\t\tfor(int i=0; i<c.length; i++){\n\t\t\t\tif(last>=dic.get(c[i])){\n\t\t\t\t\tans+=dic.get(c[i]);\n\t\t\t\t\tlast=dic.get(c[i]);\n\t\t\t\t}else{\n\t\t\t\t\tans+=dic.get(c[i])-last-last;\n\t\t\t\t\tlast=dic.get(c[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\t\n\tvoid AOJ0020(){\t// Capitalize\n\t\twhile(sc.hasNext())\tout.println(sc.nextLine().toUpperCase());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    void solve(){\n\tScanner sc = new Scanner(System.in);\n\n\twhile(true){\n\n\t    int w = sc.nextInt();\n\t    int h = sc.nextInt();\n\t    if(w==0 && h==0) break;\n\n\t    int[][] map = new int[h][w];\n\t    for(int i=0; i<h; i++){\n\t\tfor(int j=0; j<w; j++){\n\t\t    map[i][j] = sc.nextInt();\n\t\t}\n\t    }\n\n\t    int[][] dp = new int[h][w];\n\t    for(int i=0; i<w; i++){\n\t\tif(map[0][i]==0) dp[0][i] = 1;\n\t    }\n\n\t    for(int i=0; i<w; i++){\n\t\tfor(int j=0; j<w; j++){\n\t\t    if(map[i][j]==0){\n\t\t\tint n1 = 0, n2 = 0, n3 = 0, n4 = 0;\n\t\t\tif(i-1>=0 && map[i-1][j]==0) n1 = dp[i-1][j];\n\t\t\tif(i-1>=0 && j-1>=0 && map[i-1][j-1]==0) n2 = dp[i-1][j-1];\n\t\t\tif(i-1>=0 && j+1<w && map[i-1][j+1]==0) n3 = dp[i-1][j+1];\n\t\t\tif(i-2>=0 && map[i-2][j]==2) n4 = dp[i-2][j];\n\t\t\t\n\t\t\tdp[i][j] += n1 + n2 + n3 + n4;\n\t\t    }else if(map[i][j]==2){\n\t\t\tint n1 = 0, n2 = 0;\n\t\t\tif(i-1>=0 && map[i-1][j]==0) n1 = dp[i-1][j];\n\t\t\tif(i-2>=0 && map[i-2][j]==2) n2 = dp[i-2][j];\n\t\t\tdp[i][j] = n1 + n2;\n\t\t    }\n\t\t}\n\t    }\n\n\t    int ans = 0;\n\t    for(int i=0; i<w; i++){\n\t\tif(map[h-1][i]!=1) ans += dp[h-1][i];\n\t\tif(h-2>=0 && map[h-2][i]==2) ans += dp[h-2][i];\n\t    }\n\n\t    System.out.println(ans);\n\t}\n    }\n\n    public static void main(String[] args){\n\tnew Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.*;\n\nimport static java.lang.Math.*;\nimport static java.lang.System.out;\n\n// AOJ\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().AOJ0203();\n\t}\n\t\n\tvoid AOJ0203(){\t// A New Plan of Aizu Ski Resort\n\t\twhile(sc.hasNext()){\n\t\t\tint x=sc.nextInt(), y=sc.nextInt();\n\t\t\tif(x==0)\tbreak;\n\t\t\tint[][] dp=new int[x+3][y+3],b=new int[x+2][y+2];\n\t\t\tfor(int j=1; j<=y; j++){\n\t\t\t\tfor(int i=1; i<=x; i++)\tb[i][j]=sc.nextInt();\n\t\t\t}\n\t\t\tfor(int i=1; i<=x; i++)\tdp[i][1]= b[i][1]==1?0:1;\n\t\t\tfor(int j=1; j<=y; j++){\n\t\t\t\tfor(int i=1; i<=x; i++){\n\t\t\t\t\tif(b[i][j]==2)\tdp[i][j]= b[i][j-1]!=2?dp[i][j-1]:0;\n\t\t\t\t\telse if(b[i][j]==0){\n\t\t\t\t\t\tfor(int k=i-1; k<=i+1; k++)\tdp[i][j]+= b[k][j-1]==0?dp[k][j-1]:0;\t\n\t\t\t\t\t}\n\t\t\t\t\tif(j>2 && b[i][j]!=1)\tdp[i][j]+= b[i][j-2]==2?dp[i][j-2]:0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// debug\n\t\t\t/*\n\t\t\tfor(int j=1; j<=y; j++){\n\t\t\t\tfor(int i=1; i<=x; i++)\tout.print(dp[i][j]+\" \");\n\t\t\t\tout.println();\n\t\t\t}\n\t\t\t*/\n\t\t\tint ans=0;\n\t\t\tfor(int i=1; i<=x; i++)\tans+= dp[i][y]+(b[i][y-1]==2?dp[i][y-1]:0);\n\t\t\tout.println(ans);\n\t\t}\n\t\t\n\t}\n\t\n\t// RE\n\tvoid AOJ0089(){\t// The Shortest Path on A Rhombic Path\n\t\tint[][] dp=new int[200][200];\n\t\tdp[1][1]=sc.nextInt();\n\t\tint idx=2, lastLen=1;\n\t\twhile(sc.hasNext()){\n\t\t\tString s=sc.next();\n\t\t\tScanner sc2=new Scanner(s).useDelimiter(\",\");\n\t\t\tint len=(int)((double)s.length()/(double)2+0.5);\n\t\t\tfor(int i=1; i<=len; i++){\n\t\t\t\tif(len>lastLen)\tdp[i][idx]=sc2.nextInt()+max(dp[i][idx-1], dp[i-1][idx-1]);\n\t\t\t\telse\tdp[i][idx]=sc2.nextInt()+max(dp[i][idx-1], dp[i+1][idx-1]);\n\t\t\t}\n\t\t\tlastLen=len;\n\t\t\tidx++;\n\t\t}\n\t\t//debug\n\t\t\n\t\tfor(int i=0; i<=idx; i++){\n\t\t\tfor(int j=0; j<=(int)((double)idx/2+0.5); j++)\tout.printf(\"%4d\",dp[j][i]);\n\t\t\tout.println();\n\t\t}\n\t\t\n\t\tout.println(dp[1][idx-1]);\n\t}\n\t\n\tvoid AOJ0004(){\n\t\t//while(sc.hasNext()){\n\t\t\t// int a=sc.nextInt(), b=sc.nextInt(), c=sc.nextInt(), d=sc.nextInt(), e=sc.nextInt(), f=sc.nextInt();\n\t\t\t// ax + by = c\n\t\t\t// dx + ey = f\n\t\t//}\n\t}\n\t\n\tvoid AOJ0042(){\t// A Thief\n\t\tint num=1;\n\t\twhile(sc.hasNext()){\n\t\t\tint w=sc.nextInt();\n\t\t\tif(w==0)\tbreak;\n\t\t\tint n=sc.nextInt();\n\t\t\tint[][] dp=new int[n+1][w+1];\n\t\t\tint[] ww=new int[n+1], pp=new int[n+1];\n\t\t\tfor(int i=1; i<=n; i++){\n\t\t\t\tScanner sc2=new Scanner(sc.next()).useDelimiter(\",\");\n\t\t\t\tpp[i]=sc2.nextInt();\n\t\t\t\tww[i]=sc2.nextInt();\n\t\t\t}\n\t\t\tint ans=0, wei=Integer.MAX_VALUE;\n\t\t\tfor(int i=1; i<=n; i++){\n\t\t\t\tfor(int j=1; j<=w; j++){\n\t\t\t\t\tdp[i][j]=max(dp[i-1][j], j>=ww[i]?dp[i-1][j-ww[i]]+pp[i]:dp[i-1][j]);\n\t\t\t\t\tif(dp[i][j]>ans){\n\t\t\t\t\t\twei=j;\n\t\t\t\t\t\tans=dp[i][j];\n\t\t\t\t\t}else if(dp[i][j]==ans){\n\t\t\t\t\t\twei=min(wei,j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//debug\n\t\t\t/*\n\t\t\tfor(int i=0; i<=w; i++){\n\t\t\t\tfor(int j=0; j<=n; j++)\tout.printf(\"%4d\",dp[j][i]);\n\t\t\t\tout.println();\n\t\t\t}\n\t\t\t*/\n\t\t\t\n\t\t\tout.println(\"Case \"+(num++)+\":\");\n\t\t\tout.println(ans);\n\t\t\tout.println(wei);\n\t\t}\n\t}\n\n\tvoid AOJ0003(){\n\t\tint n=sc.nextInt();\n\t\twhile(n-->0){\n\t\t\tint[] a=new int[3];\n\t\t\tfor(int i=0; i<3; i++)\ta[i]=sc.nextInt();\n\t\t\tArrays.sort(a);\n\t\t\tif(a[2]*a[2]==(a[1]*a[1])+(a[0]*a[0]))\tout.println(\"YES\");\n\t\t\telse\tout.println(\"NO\");\n\t\t}\n\t}\n\t\n\tvoid AOJ0002(){\n\t\twhile(sc.hasNext())\tout.println(new String(\"\"+(sc.nextInt()+sc.nextInt())).length());\n\t}\n\t\n\tvoid AOJ0516(){\n\t\twhile(sc.hasNext()){\n\t\t\tint n=sc.nextInt(), k=sc.nextInt(), ans=0;\n\t\t\tif(n==0)\tbreak;\n\t\t\tint[] sum=new int[n+1];\n\t\t\tfor(int i=1; i<=n; i++)\tsum[i]=sum[i-1]+sc.nextInt();\n\t\t\tfor(int i=k; i<=n; i++)\tans=max(ans, sum[i]-sum[i-k]);\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\t\n\tc547[][] r;\n\tfinal int MOD547=100000;\n\tvoid AOJ0547(){\t// Commute routes\n\t\twhile(sc.hasNext()){\n\t\t\tint w=sc.nextInt(), h=sc.nextInt();\n\t\t\tif(w<2)\tbreak;\n\t\t\tr=new c547[w+1][h+1];\n\t\t\tr[2][1]=new c547(0,0,0,1);\tr[1][2]=new c547(0,1,0,0);\n\t\t\tfor(int x=1; x<=w; x++){\n\t\t\t\tfor(int y=1; y<=h; y++)\tr[x][y] = r[x][y]==null?solve547(x,y): r[x][y];\n\t\t\t}\n\t\t\t//r[w][h].list();\n\t\t\tout.println(r[w][h].sum());\n\t\t}\n\t}\n\tc547 solve547(int x, int y){\n\t\tint s1=y-1>0? r[x][y-1].w2:0;\n\t\tint s2=y-1>0? (r[x][y-1].s1+r[x][y-1].s2)%MOD547:0;\n\t\tint w1=x-1>0? r[x-1][y].s2:0;\n\t\tint w2=x-1>0? (r[x-1][y].w1+r[x-1][y].w2)%MOD547:0;\n\t\treturn new c547(s1, s2, w1, w2);\n\t}\n\tclass c547{\n\t\tint s1, s2, w1, w2;\n\t\tc547(int s1, int s2, int w1, int w2){\n\t\t\tthis.s1=s1; this.s2=s2; this.w1=w1; this.w2=w2;\n\t\t}\n\t\tint sum(){\n\t\t\treturn (this.s1 + this.s2 + this.w1 + this.w2)%MOD547;\n\t\t}\n\t\tvoid list(){\n\t\t\tout.println(\"(\"+this.s1+\" \"+this.s2+\" \"+this.w1+\" \"+this.w2+\")\");\n\t\t}\n\t}\n\t\n\tint[][] a1209;\n\tvoid AOJ1209(){\n\t\twhile(sc.hasNext()){\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n<=0)\tbreak;\n\t\t\ta1209=new int[18][n+1];\n\t\t\tfor(int i=0; i<=n; i++)\ta1209[1][i]=1;\n\t\t\tfor(int x=2; x<=17; x++){\n\t\t\t\tfor(int y=1; y<=n; y++)\ta1209[x][y]=solve1209(x,y);\n\t\t\t}\n\t\t\tint ans=0;\n\t\t\tfor(int i=1; i<=17; i++)\tans+=a1209[i][n];\n\t\t\tout.println(ans);\n\t\t\t\n\t\t\t// debug\n\t\t\t/*\n\t\t\tfor(int i=0; i<=n; i++){\n\t\t\t\tfor(int j=0; j<=17; j++)\tout.print(a1209[j][i]+\" \");\n\t\t\t\tout.println();\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t}\n\tint solve1209(int x, int y){\n\t\tint ans=0;\n\t\tfor(int i=x;i>0; i--)\tans+= y-(x*x)>=0?a1209[i][y-(x*x)]:0;\n\t\treturn ans;\n\t}\n\t\n\tint[][] r515;\n\tboolean[][] b515;\n\tvoid AOJ0515(){\t// School Road\n\t\twhile(sc.hasNext()){\n\t\t\tint xn=sc.nextInt(), yn=sc.nextInt();\n\t\t\tif(xn<=0)\tbreak;\n\t\t\tint n=sc.nextInt();\n\t\t\tb515 = new boolean[xn+1][yn+1];\n\t\t\tfor(int i=0; i<n; i++)\tb515[sc.nextInt()][sc.nextInt()]=true;\n\t\t\tr515=new int[xn+1][yn+1];\n\t\t\tr515[1][1]=1;\n\t\t\tfor(int x=1; x<=xn; x++){\n\t\t\t\tfor(int y=1; y<=yn; y++){\n\t\t\t\t\tif(x==1&&y==1)\tcontinue;\n\t\t\t\t\tr515[x][y]=solve515(x,y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(r515[xn][yn]);\n\t\t}\n\t}\n\tint solve515(int x, int y){\n\t\tint ans=0;\n\t\tif(!b515[x][y]){\n\t\t\tans+= y-1>0? r515[x][y-1]:0;\n\t\t\tans+= x-1>0? r515[x-1][y]:0;\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\t\n\tint[] a168;\n\tvoid AOJ0168(){\t// Kannondou\n\t\twhile(sc.hasNext()){\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n<=0)\tbreak;\n\t\t\ta168=new int[n+1];\n\t\t\ta168[0]=1;\n\t\t\tfor(int i=1; i<=n; i++)\ta168[i]=solve168(i);\n\t\t\tint day=(a168[n]/10) + (a168[n]%10==0? 0: 1);\n\t\t\t// out.println(\"n\"+a168[n]+\" day\"+day);\n\t\t\tout.println(((day/365) + (day%365==0?0 :1)));\n\t\t}\n\t}\n\tint solve168(int a){\n\t\tint ans=0;\n\t\tfor(int i=a-1; i>=a-3; i--)\tans+= i>=0? a168[i]: 0;\n\t\treturn ans;\n\t}\n\t\n\tvoid AOJ0176(){\t// What Color?\n\t\tint[] R = {0,0,0,0,255,255,255,255};\n\t\tint[] G = {0,0,255,255,0,0,255,255};\n\t\tint[] B = {0,255,0,255,0,255,0,255};\n\t\tHashMap<Integer,String> dic = new HashMap<Integer,String>();\n\t\tdic.put(0, \"black\");\tdic.put(1, \"blue\");\tdic.put(2, \"lime\");\tdic.put(3, \"aqua\");\n\t\tdic.put(4, \"red\");\tdic.put(5, \"fuchsia\");\tdic.put(6, \"yellow\");\tdic.put(7, \"white\");\n\t\twhile(sc.hasNext()){\n\t\t\tString s=sc.next();\n\t\t\tif(s.equals(\"0\"))\tbreak;\n\t\t\tint r=Integer.parseInt(\"\"+s.charAt(1)+s.charAt(2),16), g=Integer.parseInt(\"\"+s.charAt(3)+s.charAt(4),16), b=Integer.parseInt(\"\"+s.charAt(5)+s.charAt(6),16);\n\t\t\tint index=0;\n\t\t\tdouble last=Double.MAX_VALUE;\n\t\t\tfor(int i=0; i<8; i++){\n\t\t\t\tdouble d=sqrt((abs(r-R[i])<<1)+(abs(g-G[i])<<1)+(abs(b-B[i])<<1));\n\t\t\t\tindex = last>d? i : index;\n\t\t\t\tlast = last>d? d : last;\n\t\t\t}\n\t\t\tout.println(dic.get(index));\n\t\t}\n\t}\n\t\n\tvoid AOJ0175(){\t// A King in Hawaii\n\t\twhile(sc.hasNext()){\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n<0)\tbreak;\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile(n!=0){\n\t\t\t\t//out.println(n&3);\n\t\t\t\tsb.append(n&3);\n\t\t\t\tn=n>>2;\n\t\t\t}\n\t\t\tout.println(sb.length()>0? sb.reverse(): 0);\n\t\t}\n\t}\n\t\n\tvoid AOJ0031(){\t// Weight\n\t\twhile(sc.hasNext()){\n\t\t\tint n=sc.nextInt();\n\t\t\tint temp=Integer.lowestOneBit(n);\n\t\t\tout.print(temp);\n\t\t\tn=(n^temp);\n\t\t\twhile(n!=0){\n\t\t\t\ttemp=Integer.lowestOneBit(n);\n\t\t\t\tout.print(\" \"+temp);\n\t\t\t\tn=(n^temp);\n\t\t\t}\n\t\t\tout.println();\n\t\t}\n\t}\n\t\n\tvoid AOJ0051(){\t// Differential II\n\t\tint n=sc.nextInt();\n\t\tfor(int i=0; i<n; i++){\n\t\t\tchar[] c = sc.next().toCharArray();\n\t\t\tint[] a = new int[8];\n\t\t\tfor(int j=0; j<8; j++)\ta[j]=Character.digit(c[j], 10);\n\t\t\tArrays.sort(a);\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor(int j=0; j<8; j++)\tsb.append(a[j]);\n\t\t\tint min=Integer.parseInt(sb.toString());\n\t\t\tsb=new StringBuilder();\n\t\t\tfor(int j=7; j>=0; j--)\tsb.append(a[j]);\n\t\t\tint max=Integer.parseInt(sb.toString());\n\t\t\tout.println(max-min);\n\t\t}\n\t}\n\t\n\tvoid AOJ0196(){\t// Baseball Championship\n\t\twhile(sc.hasNext()){\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n==0)\tbreak;\n\t\t\tTeam196[] teams = new Team196[n];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tString s=sc.next();\n\t\t\t\tint win=0, lose=0;\n\t\t\t\tfor(int j=0; j<n-1; j++){\n\t\t\t\t\tint temp=sc.nextInt();\n\t\t\t\t\tif(temp==0)\twin++;\n\t\t\t\t\tif(temp==1)\tlose++;\n\t\t\t\t}\n\t\t\t\tteams[i] = new Team196(s,win,lose,i);\n\t\t\t}\n\t\t\tArrays.sort(teams);\n\t\t\tfor(int i=0; i<n; i++)\tout.println(teams[i].name);\n\t\t}\n\t}\n\tclass Team196 implements Comparable<Team196>{\n\t\tString name;\n\t\tint win,lose,index;\n\t\tTeam196(String name, int win, int lose, int index){\n\t\t\tthis.name=name;\tthis.win=win;\tthis.lose=lose;\tthis.index=index;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Team196 o) {\n\t\t\tif(this.win<o.win)\treturn 1;\n\t\t\tif(this.win>o.win)\treturn -1;\n\t\t\tif(this.lose<o.lose)\treturn -1;\n\t\t\tif(this.lose>o.lose)\treturn 1;\n\t\t\tif(this.index<o.index)\treturn -1;\n\t\t\tif(this.index>o.index)\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tvoid AOJ0065(){\t// Trading\n\t\tfinal int MAX=1000000;\n\t\tint[] current=new int[MAX];\n\t\tint[] last=new int[MAX];\n\t\tboolean flag=false;\n\t\twhile(sc.hasNext()){\n\t\t\tString s=sc.nextLine();\n\t\t\tif(s.equals(\"\")){\n\t\t\t\tflag=true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tScanner sc2 = new Scanner(s).useDelimiter(\",\");\n\t\t\tif(flag)\tlast[sc2.nextInt()]++;\n\t\t\telse\tcurrent[sc2.nextInt()]++;\n\t\t}\n\t\tfor(int i=0; i<MAX; i++)\t\tif(current[i]>0 && last[i]>0)\tout.println(i+\" \"+(current[i]+last[i]));\n\t}\n\t\n\tvoid AOJ0161(){\t// Sport Meet\n\t\twhile(sc.hasNext()){\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n==0)\tbreak;\n\t\t\tTime161[] times = new Time161[n];\n\t\t\tfor(int i=0; i<n; i++)\ttimes[i] = new Time161(sc.nextInt(), (sc.nextInt()*60+sc.nextInt() + sc.nextInt()*60+sc.nextInt() + sc.nextInt()*60+sc.nextInt() + sc.nextInt()*60+sc.nextInt()));\n\t\t\tArrays.sort(times);\n\t\t\tout.println(times[0].num);\tout.println(times[1].num);\tout.println(times[times.length-2].num);\n\t\t}\n\t}\n\tclass Time161 implements Comparable<Time161>{\n\t\tint num, time;\n\t\tTime161(int num, int time){\n\t\t\tthis.num=num;\tthis.time=time;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Time161 o) {\n\t\t\tif(this.time<o.time)\treturn -1;\n\t\t\tif(this.time>o.time)\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tvoid AOJ0138(){\t// Track and Field Competition\n\t\tTime138[] times1st = new Time138[8];\n\t\tTime138[] times2nd = new Time138[8];\n\t\tTime138[] times3rd = new Time138[8];\n\t\tfor(int i=0; i<8; i++)\ttimes1st[i] = new Time138(sc.nextInt(), sc.nextDouble());\n\t\tfor(int i=0; i<8; i++)\ttimes2nd[i] = new Time138(sc.nextInt(), sc.nextDouble());\n\t\tfor(int i=0; i<8; i++)\ttimes3rd[i] = new Time138(sc.nextInt(), sc.nextDouble());\n\t\tArrays.sort(times1st);\tArrays.sort(times2nd);\tArrays.sort(times3rd);\n\t\tfor(int i=0; i<2; i++)\tout.println(times1st[i].num+\" \"+times1st[i].time);\n\t\tfor(int i=0; i<2; i++)\tout.println(times2nd[i].num+\" \"+times2nd[i].time);\n\t\tfor(int i=0; i<2; i++)\tout.println(times3rd[i].num+\" \"+times3rd[i].time);\n\t\tTime138[] times = new Time138[6];\n\t\ttimes[0]=times1st[2]; times[1]=times1st[3];\ttimes[2]=times2nd[2]; times[3]=times2nd[3];\ttimes[4]=times3rd[2]; times[5]=times3rd[3];\n\t\tArrays.sort(times);\n\t\tfor(int i=0; i<2; i++)\tout.println(times[i].num+\" \"+times[i].time);\n\t}\n\tclass Time138 implements Comparable<Time138>{\n\t\tint num;\tdouble time;\n\t\tTime138(int num, double time){\n\t\t\tthis.num=num;\tthis.time=time;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Time138 o) {\n\t\t\tif(this.time<o.time)\treturn -1;\n\t\t\tif(this.time>o.time)\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tvoid AOJ0005(){\t// GCD and LCM\n\t\twhile(sc.hasNext()){\n\t\t\tint a=sc.nextInt(), b=sc.nextInt();\n\t\t\tint temp=gcd(max(a,b), min(a,b));\n\t\t\tout.println(temp+\" \"+max(a,b)/temp*min(a,b));\n\t\t}\n\t}\n\tint gcd(int x, int y){\n\t\tif(y==0)\treturn x;\n\t\telse\treturn gcd(y, x%y);\n\t}\n\t\n\tint c197=0;\n\tvoid AOJ0197(){\t// Greatest Common Divisor: Euclidean Algorithm\n\t\twhile(sc.hasNext()){\n\t\t\tint x=sc.nextInt(), y=sc.nextInt();\n\t\t\tif(x<2)\tbreak;\n\t\t\tc197=0;\n\t\t\tout.println(gcd197(max(x,y), min(x,y))+\" \"+c197);\n\t\t}\n\t}\n\tint gcd197(int x, int y){\n\t\tif(y==0)\treturn x;\n\t\tc197++;\n\t\treturn gcd197(y, x%y);\n\t}\n\t\n\tvoid AOJ0001(){\t// List of Top 3 Hills\n\t\tint[] m = new int[10];\n\t\tfor(int i=0; i<10; i++)\tm[i]=sc.nextInt();\n\t\tArrays.sort(m);\n\t\tfor(int i=9; i>=7; i--)\tout.println(m[i]);\n\t}\n\t\n\tvoid AOJ10029(){\t// Sort II\n\t\tint n=sc.nextInt();\n\t\tint[] ans = new int[n];\n\t\tfor(int i=0; i<n; i++)\tans[i]=sc.nextInt();\n\t\tArrays.sort(ans);\n\t\tout.print(ans[0]);\n\t\tfor(int i=1; i<n; i++)\tout.print(\" \"+ans[i]);\n\t\tout.println();\n\t}\n\t\n\tint[][] p26 = new int[10][10];\n\tint c26=100;\n\tvoid AOJ0026(){\t// Dropping Ink\n\t\tint ans=0;\n\t\twhile(sc.hasNext()){\n\t\t\tScanner sc2 = new Scanner(sc.nextLine()).useDelimiter(\",\");\n\t\t\tint x=sc2.nextInt(), y=sc2.nextInt(), s=sc2.nextInt();\n\t\t\t// out.println(\"x\"+x+\" y\"+y+\" s\"+s);\n\t\t\tans=max(solve26(x,y),ans);\n\t\t\tans=max(solve26(x-1,y),ans);\tans=max(solve26(x+1,y),ans);\n\t\t\tans=max(solve26(x,y-1),ans);\tans=max(solve26(x,y+1),ans);\n\t\t\tif(s>=2){\n\t\t\t\tans=max(solve26(x-1,y-1),ans);\tans=max(solve26(x-1,y+1),ans);\n\t\t\t\tans=max(solve26(x+1,y-1),ans);\tans=max(solve26(x+1,y+1),ans);\n\t\t\t}\n\t\t\tif(s>=3){\n\t\t\t\tans=max(solve26(x-2,y),ans);\tans=max(solve26(x+2,y),ans);\n\t\t\t\tans=max(solve26(x,y-2),ans);\tans=max(solve26(x,y+2),ans);\n\t\t\t}\n\t\t}\n\t\tout.println(c26);\n\t\tout.println(ans);\n\t}\n\tint solve26(int x, int y){\n\t\tint r=-1;\n\t\tif(0<=x && x<=9 && 0<=y && y<=9){\n\t\t\tc26 -= p26[x][y]==0? 1: 0;\n\t\t\tp26[x][y]++;\n\t\t\tr=p26[x][y];\n\t\t}\n\t\treturn r;\t// RA\n\t}\n\t\n\tvoid AOJ0008(){\t//Sum of 4 Integers\n\t\twhile(sc.hasNext()){\n\t\t\tint ans=0, n=sc.nextInt();\n\t\t\tfor(int a=0; a<10; a++){\n\t\t\t\tfor(int b=0; b<10; b++){\n\t\t\t\t\tfor(int c=0; c<10; c++){\n\t\t\t\t\t\tfor(int d=0; d<10; d++)\t\tif((a+b+c+d)==n)\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\t\n\tvoid AOJ0055(){\t// Sequence\n\t\twhile(sc.hasNext()){\n\t\t\tdouble last=sc.nextDouble(), ans=last;\n\t\t\tfor(int i=2; i<=10; i++){\n\t\t\t\tans+= i%2==0? last*2: last/3;\n\t\t\t\tlast = i%2==0? last*2: last/3;\n\t\t\t\t// out.println(last);\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\t\n\tvoid AOJ0084(){\t// Search Engine\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(sc.hasNext()){\n\t\t\tString s=sc.next().replaceAll(\",\", \"\").replaceAll(\"\\\\.\", \"\").replaceAll(\" \", \"\");\n\t\t\t// out.println(s);\n\t\t\tif(s.length()<=2 || s.length()>=7)\tcontinue;\n\t\t\tsb.append(s+\" \");\n\t\t}\n\t\tout.println(sb.deleteCharAt(sb.length()-1));\n\t}\n\t\n\tvoid AOJ0077(){\t// Run Length\n\t\twhile(sc.hasNext()){\n\t\t\tchar[] c=sc.nextLine().toCharArray();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor(int i=0; i<c.length; i++){\n\t\t\t\tif(c[i]=='@'){\n\t\t\t\t\tfor(int j=0; j<Character.digit(c[i+1], 10); j++)\tsb.append(c[i+2]);\n\t\t\t\t\ti+=2;\n\t\t\t\t}else\tsb.append(c[i]);\n\t\t\t}\n\t\t\tout.println(sb.toString());\n\t\t}\n\t}\n\t\n\tvoid AOJ0064(){\t// Secret Number\n\t\tint ans=0;\n\t\twhile(sc.hasNext()){\n\t\t\tMatcher m = Pattern.compile(\"\\\\d+\").matcher(sc.nextLine());\n\t\t\twhile(m.find())\tans+=Integer.parseInt(m.group());\n\t\t}\n\t\tout.println(ans);\n\t}\n\t\n\tvoid AOJ0050(){\t// Apple and Peach\n\t\twhile(sc.hasNext()) out.println(sc.nextLine().replaceAll(\"apple\", \"PEACH\").replaceAll(\"peach\", \"apple\").replaceAll(\"PEACH\", \"peach\"));\n\t}\n\t\n\tvoid AOJ0039(){\t// Roman Figure\n\t\tHashMap<Character,Integer> dic = new HashMap<Character,Integer>();\n\t\tdic.put('I', 1);\tdic.put('V', 5);\tdic.put('X', 10);\tdic.put('L', 50);\n\t\tdic.put('C', 100);\tdic.put('D', 500);\tdic.put('M', 1000);\n\t\twhile(sc.hasNext()){\n\t\t\tchar[] c = sc.next().toCharArray();\n\t\t\tint ans=0,last=dic.get(c[0]);\n\t\t\tfor(int i=0; i<c.length; i++){\n\t\t\t\tif(last>=dic.get(c[i])){\n\t\t\t\t\tans+=dic.get(c[i]);\n\t\t\t\t\tlast=dic.get(c[i]);\n\t\t\t\t}else{\n\t\t\t\t\tans+=dic.get(c[i])-last-last;\n\t\t\t\t\tlast=dic.get(c[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\t\n\tvoid AOJ0020(){\t// Capitalize\n\t\twhile(sc.hasNext())\tout.println(sc.nextLine().toUpperCase());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\n    int w,h;\n    int[][] grid;\n    int[] dx = {-1,0,1,0};\n    int[] dy = {-1,-1,-1,-2};\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            w = sc.nextInt();\n            h = sc.nextInt();\n            if(w==0 && h==0) break;\n\n            grid = new int[h][w];\n            for(int i=0; i<h; i++){\n                for(int j=0; j<w; j++){\n                    grid[i][j] = sc.nextInt();\n                }\n            }\n\n            int[][] dp = new int[h][w];\n            for(int i=0; i<w; i++){\n                if(grid[0][i]==0) dp[0][i] = 1;\n            }\n\n            for(int i=0; i<h; i++){\n                for(int j=0; j<w; j++){\n                    if(grid[i][j]==0){\n                        for(int k=0; k<4; k++){\n                            int nx = j+dx[k], ny = i+dy[k];\n                            if(nx<0 || nx>=w || ny<0 || ny>=h) continue;\n                            if((k<=2 && grid[ny][nx]==0) || (k==3 && grid[ny][nx]==2)){\n                                dp[i][j] += dp[ny][nx];\n                            }\n                        }\n                    }else if(grid[i][j]==2){\n                        if(i-1>=0) dp[i][j] += dp[i-1][j];\n                        if(i-2>=0 && grid[i-2][j]==2) dp[i][j] += dp[i-2][j];\n                    }\n                }\n                //System.out.println(Arrays.toString(dp[i]));\n            }\n\n            int ans = 0;\n            for(int i=0; i<w; i++){\n                ans += dp[h-1][i];\n                if(h>=3 && grid[h-2][i]==2) ans += dp[h-2][i];\n            }\n\n            System.out.println(ans);\n        }\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int x, y;\n\tstatic int[][] field, dp;\n\tstatic int[] dx = {-1, 0, 1}, dy = {1};\n\tpublic static void main(String[] args) {\n\t\twhile(read()){\n\t\t\tsolve();\n\t\t}\n\t}\n\t\n\tstatic boolean read(){\n\t\tx = sc.nextInt();\n\t\ty = sc.nextInt();\n\t\tif(x == 0 && y == 0)return false;\n\t\t\n\t\tfield = new int[y+2][x];\n\t\tdp = new int[y+2][x];\n\t\t\n\t\tfor(int i = 0; i < field.length-2; i++){\n\t\t\tfor(int j = 0; j < field[0].length; j++){\n\t\t\t\tfield[i][j] = sc.nextInt();\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tstatic void solve(){\n\t\tfor(int i = 0; i < field[0].length; i++){\n\t\t\tif(field[0][i] == 0)dp[0][i] = 1;\n\t\t}\n\t\t\n\t\tfor(int y = 0; y < field.length-3; y++){\n\t\t\tfor(int x = 0; x < field[0].length; x++){\n\t\t\t\tif(field[y][x] == 0){\n\t\t\t\t\tfor(int k = 0; k < dx.length; k++){\n\t\t\t\t\t\tint nx = x + dx[k], ny = y + 1;\n\t\t\t\t\t\tif(0 > nx || nx >= field[0].length)continue;\n\t\t\t\t\t\tif(field[ny][nx] == 0)dp[ny][nx] += dp[y][x];\n\t\t\t\t\t}\n\t\t\t\t}else if(field[y][x] == 2){\n\t\t\t\t\tint ny = y + 2, nx = x;\n\t\t\t\t\tif(field[ny][nx] != 1)dp[ny][nx] += dp[y-1][x] + dp[y][x];\n\t\t\t\t}else if(field[y][x] == 1){\n\t\t\t\t\tdp[y][x] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = 0;\n\t\tfor(int x = 0; x < dp[0].length; x++){\n\t\t\tres += dp[dp.length-1][x] + dp[dp.length-2][x] + dp[dp.length-3][x];\n\t\t}\n\t\tSystem.out.println(res);\n\t\t//printDP();\n\t}\n\t\n\tstatic void printDP(){\n\t\tfor(int i = 0; i < field.length; i++){\n\t\t\tfor(int j = 0; j < field[0].length; j++){\n\t\t\t\tSystem.out.print(dp[i][j] + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * A New Plan of Aizu Ski Resort\n * PCK2009 ??????9\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tint x, y;\n\t\t\tx = parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\ty = parseInt(line.substring(line.indexOf(' ') + 1));\n\t\t\tif ((x | y) == 0) break;\n\n\t\t\tint[][] course = new int[y][x];\n\t\t\tint[][] dp = new int[y][x];\n\n\t\t\tfor (int i = 0; i < y; i++) {\n\t\t\t\twords = br.readLine().split(\" \");\n\t\t\t\tfor (int j = 0; j < words.length; j++) {\n\t\t\t\t\tcourse[i][j] = parseInt(words[j]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < x; i++) {\n\t\t\t\tif (course[0][i] == 0) dp[0][i] = 1;\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < y; i++) {\n\t\t\t\tfor (int j = 0; j < x; j++) {\n\t\t\t\t\tswitch (course[i][j]) {\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tif (i + 1 < y && j - 1 >= 0 && course[i + 1][j - 1] == 0) {\n\t\t\t\t\t\t\t\tdp[i + 1][j - 1] += dp[i][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i + 1 < y && course[i + 1][j] != 1) {\n\t\t\t\t\t\t\t\tdp[i + 1][j] += dp[i][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i + 1 < y && j + 1 < x && course[i + 1][j + 1] == 0) {\n\t\t\t\t\t\t\t\tdp[i + 1][j + 1] += dp[i][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tif (i + 2 < y && course[i + 2][j] != 1) {\n\t\t\t\t\t\t\t\tdp[i + 2][j] += dp[i][j];\n\t\t\t\t\t\t\t} else if (i + 2 >= y) {\n\t\t\t\t\t\t\t\tdp[y - 1][j] += dp[i][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sum = 0;\n\t\t\tfor (int i = 0; i < x; i++) sum += dp[y - 1][i];\n\t\t\tSystem.out.println(sum);\n\t\t}//end while\n\t}//end main\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tint DP(int h,int w,int hw[][]){\n\t\tint result = 0;\n\t\tint yx[][] = new int [h][w];\n\t\tfor(int i = 0;i < w;i++){\n\t\t\tif(hw[0][i] == 0){\n\t\t\t\tyx[0][i] = 1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < h-1;i++){\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tif(j == 0){\n\t\t\t\t\tif(hw[i+1][j] == 0){\n\t\t\t\t\t\tyx[i+1][j] = yx[i+1][j] + yx[i][j] + yx[i][j+1];\n\t\t\t\t\t}\n\t\t\t\t}else if(j == w-1){\n\t\t\t\t\tif(hw[i+1][j] == 0){\n\t\t\t\t\t\tyx[i+1][j] = yx[i+1][j] + yx[i][j] + yx[i][j-1];\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(hw[i+1][j] == 0){\n\t\t\t\t\t\tyx[i+1][j] = yx[i+1][j] + yx[i][j-1] + yx[i][j] + yx[i][j+1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tif(hw[i+1][j] == 2){\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\tif(i+cnt+1 == h-2){\n\t\t\t\t\t\t\tcnt = cnt + 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tcnt = cnt + 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(hw[i+cnt+1][j] != 2)break;\n\t\t\t\t\t}\n\t\t\t\t\tyx[i+cnt+1][j] = yx[i+cnt+1][j] + yx[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < w;i++){\n\t\t\tresult = result + yx[h-1][i];\n\t\t}\n//\t\tfor(int i = 0;i < h;i++){\n//\t\t\tfor(int j = 0;j < w;j++){\n//\t\t\t\tSystem.out.print(yx[i][j]+\" \");\n//\t\t\t}\n//\t\t\tSystem.out.println();\n//\t\t}\n\t\treturn result;\n\t}\n\tvoid doIt() { \n\t\twhile(true){\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tint hw[][] = new int [h][w];\n\t\t\tif(h+w == 0)break;\n\t\t\tfor(int i = 0;i < h;i++){\n\t\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\t\thw[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(DP(h,w,hw));\n\t\t}\n     }\n    public static void main(String[] args) {\n    \t// TODO Auto-generated method stub\n    \tnew Main().doIt();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic int X,Y,ans;\n\tstatic int[][] field;\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tX=cin.nextInt();\n\t\t\tY=cin.nextInt();\n\t\t\tans=0;\n\t\t\tif(X+Y==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfield = new int[Y+2][X+2];\n\t\t\tfor(int i = 0;i<Y+2;i++){\n\t\t\t\tfor(int j = 0;j<X+2;j++){\n\t\t\t\t\tfield[i][j]=-1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0;i<Y;i++){\n\t\t\t\tfor(int j = 1;j<X+1;j++){\n\t\t\t\t\tfield[i][j]=cin.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0;i<X+2;i++){\n\t\t\t\tif(field[0][i]==0){\n\t\t\t\t\tski(0,i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tstatic void ski(int y,int x){\n\t\t//System.out.println(y+\" \" + x);\n\t\tif(y>=Y-1){\n\t\t\t//System.out.println(\"aaaaaaaa\"+y+\" \" + x);\n\t\t\tans++;\n\t\t\treturn;\n\t\t}\n\t\tif(field[y][x]==2&&(field[y+2][x]==0||field[y+2][x]==2||field[y+2][x]==-1)){\n\t\t\tski(y+2,x);\n\t\t\treturn;\n\t\t}\n\t\tif(field[y+1][x]==0){\n\t\t\tski(y+1,x);\n\t\t}\n\t\telse if(field[y+1][x]==2){\n\t\t\tski(y+1,x);\n\t\t}\n\t\t\n\t\tif(field[y+1][x-1]==0){\n\t\t\tski(y+1,x-1);\n\t\t}\n\t\tif(field[y+1][x+1]==0){\n\t\t\tski(y+1,x+1);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.awt.geom.*;\nimport java.math.*;\n\npublic class Main {\n\n\tstatic final Scanner in = new Scanner(System.in);\n\tstatic final PrintWriter out = new PrintWriter(System.out,false);\n\tstatic boolean debug = false;\n\n\tstatic int[] dy = { 1, 1, 1,};\n\tstatic int[] dx = { -1, 0, 1};\n\n\tstatic boolean solve() {\n\t\tint w = in.nextInt();\n\t\tint h = in.nextInt();\n\t\tif (w + h == 0) return false;\n\n\t\tint[][] t = new int[h][w];\n\t\tfor (int i=0; i<h; i++) {\n\t\t\tfor (int j=0; j<w; j++) {\n\t\t\t\tt[i][j] = in.nextInt();\n\t\t\t}\n\t\t}\n\n\t\tint[][] dp = new int[h][w];\n\t\tfor (int i=0; i<h; i++) {\n\t\t\tArrays.fill(dp[i], -1);\n\t\t}\n\t\tfor (int i=0; i<w; i++) {\n\t\t\tif (t[0][i] == 0) dp[0][i] = 1;\n\t\t}\n\n\t\tfor (int i=1; i<h; i++) {\n\t\t\tfor (int j=0; j<w; j++) {\n\t\t\t\tif (t[i][j] == 1) continue;\n\t\t\t\tint sum = 0;\n\t\t\t\tif (j - 1 >= 0 && t[i][j] != 2 && t[i-1][j-1] == 0) {\n\t\t\t\t\tsum += dp[i-1][j-1];\n\t\t\t\t}\n\t\t\t\tif (j + 1 < w && t[i][j] != 2 && t[i-1][j+1] == 0) {\n\t\t\t\t\tsum += dp[i-1][j+1];\n\t\t\t\t}\n\t\t\t\tif (t[i-1][j] == 0) {\n\t\t\t\t\tsum += dp[i-1][j];\n\t\t\t\t}\n\t\t\t\tif (i - 2 >= 0 && t[i-2][j] == 2) {\n\t\t\t\t\tsum += dp[i-2][j];\n\t\t\t\t}\n\t\t\t\tdp[i][j] = sum;\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor (int i=0; i<w; i++) {\n\t\t\tans += dp[h-1][i];\n\t\t\tif (h - 2 >= 0 && t[h-2][i] == 2) {\n\t\t\t\tans += dp[h-2][i];\n\t\t\t}\n\t\t}\n\n\t\tout.println(ans);\n\n\t\treturn true;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tdebug = args.length > 0;\n\t\tlong start = System.nanoTime();\n\n\t\twhile(solve());\n\t\tout.flush();\n\n\t\tlong end = System.nanoTime();\n\t\tdump((end - start) / 1000000 + \" ms\");\n\t\tin.close();\n\t\tout.close();\n\t}\n\n\tstatic void dump(Object... o) { if (debug) System.err.println(Arrays.deepToString(o)); }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\t \n    static int X,Y,ans;\n    static int[][] field;\n    static int[][] count;\n    public static void main(String[] args) {\n        Scanner cin = new Scanner(System.in);\n        while(true){\n            X=cin.nextInt();\n            Y=cin.nextInt();\n            ans=0;\n            if(X+Y==0){\n                break;\n            }\n            field = new int[Y+2][X+2];\n            count = new int[Y+2][X+2];\n            for(int i = 0;i<Y+2;i++){\n                for(int j = 0;j<X+2;j++){\n                    field[i][j]=-1;\n                }\n            }\n            for(int i = 0;i<Y;i++){\n                for(int j = 1;j<X+1;j++){\n                    field[i][j]=cin.nextInt();\n                }\n            }\n            for(int i = 1;i<X+1;i++){\n            \tcount[0][i]=1;\n            }\n            for(int i = 0;i<Y-1;i++){\n            \tfor(int j = 1;j<=X;j++){\n            \t\tif(field[i][j]==0){\n            \t\t\tif(field[i+1][j-1]!=2)\n            \t\t\t\tcount[i+1][j-1]+=count[i][j];\n            \t\t\tcount[i+1][j]+=count[i][j];\n            \t\t\tif(field[i+1][j+1]!=2)\n            \t\t\t\tcount[i+1][j+1]+=count[i][j];\n            \t\t}\n            \t\telse if(field[i][j]==1){\n            \t\t\tcount[i][j]=0;\n            \t\t}\n            \t\telse if(field[i][j]==2){\n            \t\t\t\n            \t\t\tcount[i+2][j]+=count[i][j];\n            \t\t}\n            \t}\n            }\n            for(int i = 1;i<=X;i++){\n            \tif(field[Y-1][i]!=1)\n            \t\tcount[Y][i]+=count[Y-1][i];\n            }\n            for(int i = 0;i<Y+2;i++){\n            \tfor(int j = 0;j<X+2;j++){\n            \t\t//System.out.print(count[i][j]+\" \" );\n            \t}\n            \t//System.out.println();\n            }\n            for(int i = 0;i<X;i++){\n            \t//System.out.println(count[Y][i+1]);\n            \tans+=count[Y][i+1];\n            }\n            System.out.println(ans);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n\tint w;\n\tint h;\n\tint count;\n\tshort[][] map;\n\tpublic void run(){\n\t\tScanner scan = new Scanner(System.in);\n\t\twhile(scan.hasNext()){\n\t\t\tw = scan.nextInt();\n\t\t\th = scan.nextInt();\n\t\t\tif(w == 0 && h == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmap = new short[h][w];\n\t\t\tfor(int i = 0;i < h;i++){\n\t\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\t\tmap[i][j] = scan.nextShort();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcount = 0;\n\t\t\tfor(int i = 0;i < w;i++){\n\t\t\t\tif(map[0][i] != 1){\n\t\t\t\t\tcount += ski(0,i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\tpublic int ski(int y,int x){\n\t\tif(y == h-1 && x >= 0 && x < w){\n\t\t\treturn 1;\n\t\t}\n\t\tint res = 0;\n\t\tif(map[y][x] == 2){\n\t\t\tif(y == h-2){\n\t\t\t\treturn 1;\n\t\t\t}else if(map[y+2][x] == 1){\n\t\t\t\treturn 0;\n\t\t\t}else{\n\t\t\t\tres += ski(y+2,x);\n\t\t\t}\n\t\t}else{\n\t\t\tif(x-1 >= 0 && map[y+1][x-1] == 0){\n\t\t\t\tres += ski(y+1,x-1);\n\t\t\t}\n\t\t\tif(map[y+1][x] != 1){\n\t\t\t\tres += ski(y+1,x);\n\t\t\t}\n\t\t\tif(x+1 < w && map[y+1][x+1] == 0){\n\t\t\t\tres += ski(y+1,x+1);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tint DP(int h,int w,int hw[][]){\n\t\tint result = 0;\n\t\tint yx[][] = new int [h][w];\n\t\tfor(int i = 0;i < w;i++){\n\t\t\tif(hw[0][i] == 0){\n\t\t\t\tyx[0][i] = 1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < h-1;i++){\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tif(j == 0){\n\t\t\t\t\tif(hw[i+1][j] == 0){\n\t\t\t\t\t\tif(w == 1){\n\t\t\t\t\t\t\tyx[i+1][j] = yx[i+1][j] + yx[i][j];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tyx[i+1][j] = yx[i+1][j] + yx[i][j] + yx[i][j+1];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else if(j == w-1){\n\t\t\t\t\tif(hw[i+1][j] == 0){\n\t\t\t\t\t\tyx[i+1][j] = yx[i+1][j] + yx[i][j] + yx[i][j-1];\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(hw[i+1][j] == 0){\n\t\t\t\t\t\tyx[i+1][j] = yx[i+1][j] + yx[i][j-1] + yx[i][j] + yx[i][j+1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tif(hw[i+1][j] == 2){\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\tif(i+cnt+1 == h-2){\n\t\t\t\t\t\t\tcnt = cnt + 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tcnt = cnt + 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(hw[i+cnt+1][j] != 2)break;\n\t\t\t\t\t}\n\t\t\t\t\tyx[i+cnt+1][j] = yx[i+cnt+1][j] + yx[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < w;i++){\n\t\t\tresult = result + yx[h-1][i];\n\t\t}\n//\t\tfor(int i = 0;i < h;i++){\n//\t\t\tfor(int j = 0;j < w;j++){\n//\t\t\t\tSystem.out.print(yx[i][j]+\" \");\n//\t\t\t}\n//\t\t\tSystem.out.println();\n//\t\t}\n\t\treturn result;\n\t}\n\tvoid doIt() { \n\t\twhile(true){\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tint hw[][] = new int [h][w];\n\t\t\tif(h+w == 0)break;\n\t\t\tfor(int i = 0;i < h;i++){\n\t\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\t\thw[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(DP(h,w,hw));\n\t\t}\n     }\n    public static void main(String[] args) {\n    \t// TODO Auto-generated method stub\n    \tnew Main().doIt();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tint DP(int h,int w,int hw[][]){\n\t\tint result = 0;\n\t\tint yx[][] = new int [h][w];\n\t\tfor(int i = 0;i < w;i++){\n\t\t\tif(hw[0][i] == 0){\n\t\t\t\tyx[0][i] = 1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < h-1;i++){\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tif(j == 0){\n\t\t\t\t\tif(hw[i+1][j] == 0){\n\t\t\t\t\t\tif(w == 1){\n\t\t\t\t\t\t\tyx[i+1][j] = yx[i+1][j] + yx[i][j];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tyx[i+1][j] = yx[i+1][j] + yx[i][j] + yx[i][j+1];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else if(j == w-1){\n\t\t\t\t\tif(hw[i+1][j] == 0){\n\t\t\t\t\t\tyx[i+1][j] = yx[i+1][j] + yx[i][j] + yx[i][j-1];\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(hw[i+1][j] == 0){\n\t\t\t\t\t\tyx[i+1][j] = yx[i+1][j] + yx[i][j-1] + yx[i][j] + yx[i][j+1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tif(hw[i+1][j] == 2){\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\tif(i+cnt+1 == h-2){\n\t\t\t\t\t\t\tcnt = cnt + 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(i+cnt+2 == h)break;\n\t\t\t\t\t\t\tcnt = cnt + 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(hw[i+cnt+1][j] != 2)break;\n\t\t\t\t\t}\n\t\t\t\t\tif(hw[i+cnt+1][j] == 0 || hw[i+cnt+1][j] == 2){\n\t\t\t\t\t\tyx[i+cnt+1][j] = yx[i+cnt+1][j] + yx[i][j];\n\t\t\t\t\t}else if(hw[i+cnt+1][j] == 1 && (h-i) % 2 == 1 && i+cnt+1 == h-1){\n\t\t\t\t\t\tyx[i+cnt+1][j] = yx[i+cnt+1][j] + yx[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < w;i++){\n\t\t\tresult = result + yx[h-1][i];\n\t\t}\n//\t\tfor(int i = 0;i < h;i++){\n//\t\t\tfor(int j = 0;j < w;j++){\n//\t\t\t\tSystem.out.print(yx[i][j]+\" \");\n//\t\t\t}\n//\t\t\tSystem.out.println();\n//\t\t}\n\t\treturn result;\n\t}\n\tvoid doIt() { \n\t\twhile(true){\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tint hw[][] = new int [h][w];\n\t\t\tif(h+w == 0)break;\n\t\t\tfor(int i = 0;i < h;i++){\n\t\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\t\thw[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(DP(h,w,hw));\n\t\t}\n     }\n    public static void main(String[] args) {\n    \t// TODO Auto-generated method stub\n    \tnew Main().doIt();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nimport scala.inline;\nimport scala.noinline;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tm = scanner.nextInt();\n\t\t\tn = scanner.nextInt();\n\t\t\tif ((m | n) == 0)\n\t\t\t\tbreak;\n\t\t\tmap = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tmap[i][j] = scanner.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcount = 0;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tslove(i, 0, 0);\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\n\tprivate void slove(int x, int y, int r) {\n\t\tif (y == n) {\n\t\t\tcount++;\n\t\t\treturn;\n\t\t}\n\t\tif (x < 0 || x == m)\n\t\t\treturn;\n\n\t\tif (map[y][x] == 1)\n\t\t\treturn;\n\t\tif (map[y][x] == 2 && r != 1)\n\t\t\treturn;\n\n\t\tif (y == n - 1) {\n\t\t\tcount++;\n\t\t\treturn;\n\t\t}\n\t\tif (map[y][x] == 2)\n\t\t\tslove(x, y + 2, 1);\n\t\telse\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tslove(x + i - 1, y + 1, i);\n\t\t\t}\n\t}\n\n\tint count;\n\tint m;\n\tint n;\n\tint[][] map;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main2 {\n\t \n    static int X,Y,ans;\n    static int[][] field;\n    static int[][] count;\n    public static void main(String[] args) {\n        Scanner cin = new Scanner(System.in);\n        while(true){\n            X=cin.nextInt();\n            Y=cin.nextInt();\n            ans=0;\n            if(X+Y==0){\n                break;\n            }\n            field = new int[Y+2][X+2];\n            count = new int[Y+2][X+2];\n            for(int i = 0;i<Y+2;i++){\n                for(int j = 0;j<X+2;j++){\n                    field[i][j]=-1;\n                }\n            }\n            for(int i = 0;i<Y;i++){\n                for(int j = 1;j<X+1;j++){\n                    field[i][j]=cin.nextInt();\n                }\n            }\n            for(int i = 1;i<X+1;i++){\n            \tcount[0][i]=1;\n            }\n            for(int i = 0;i<Y-1;i++){\n            \tfor(int j = 1;j<=X;j++){\n            \t\tif(field[i][j]==0){\n            \t\t\tif(field[i+1][j-1]!=2)\n            \t\t\t\tcount[i+1][j-1]+=count[i][j];\n            \t\t\tcount[i+1][j]+=count[i][j];\n            \t\t\tif(field[i+1][j+1]!=2)\n            \t\t\t\tcount[i+1][j+1]+=count[i][j];\n            \t\t}\n            \t\telse if(field[i][j]==1){\n            \t\t\tcount[i][j]=0;\n            \t\t}\n            \t\telse if(field[i][j]==2){\n            \t\t\t\n            \t\t\tcount[i+2][j]+=count[i][j];\n            \t\t}\n            \t}\n            }\n            for(int i = 1;i<=X;i++){\n            \tif(field[Y-1][i]!=1)\n            \t\tcount[Y][i]+=count[Y-1][i];\n            }\n            for(int i = 0;i<Y+2;i++){\n            \tfor(int j = 0;j<X+2;j++){\n            \t\t//System.out.print(count[i][j]+\" \" );\n            \t}\n            \t//System.out.println();\n            }\n            for(int i = 0;i<X;i++){\n            \t//System.out.println(count[Y][i+1]);\n            \tans+=count[Y][i+1];\n            }\n            System.out.println(ans);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tif(w==0 && h==0) break;\n\t\t\t\n\t\t\tint[][] map = new int[h][w];\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tmap[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint[][] dp = new int[h][w];\n\t\t\tfor(int i=0;i<w;i++){\n\t\t\t\tif(map[0][i]==0) dp[0][i] = 1;\n\t\t\t}\n\t\t\tfor(int i=1;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tif(map[i][j]==0){\n\t\t\t\t\t\tif(j>0 && map[i-1][j-1]==0) dp[i][j] += dp[i-1][j-1];\n\t\t\t\t\t\tif(j<w-1 && map[i-1][j+1]==0) dp[i][j] += dp[i-1][j+1];\n\t\t\t\t\t\tif(map[i-1][j]==0) dp[i][j] += dp[i-1][j];\n\t\t\t\t\t\tif(i>1 && map[i-2][j]==2) dp[i][j] += dp[i-2][j];\n\t\t\t\t\t}else if(map[i][j]==2){\n\t\t\t\t\t\tif(map[i-1][j]==0) dp[i][j] += dp[i-1][j];\n\t\t\t\t\t\tif(i>1 && map[i-2][j]==2) dp[i][j] += dp[i-2][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint sum = 0;\n\t\t\tfor(int i=0;i<w;i++){\n\t\t\t\tsum += dp[h-1][i];\n\t\t\t\tif(h>1 && map[h-2][i]==2) sum += dp[h-2][i];\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\t\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n \n    static int X,Y,ans;\n    static int[][] field;\n    public static void main(String[] args) {\n        Scanner cin = new Scanner(System.in);\n        while(true){\n            X=cin.nextInt();\n            Y=cin.nextInt();\n            ans=0;\n            if(X+Y==0){\n                break;\n            }\n            field = new int[Y+2][X+2];\n            for(int i = 0;i<Y+2;i++){\n                for(int j = 0;j<X+2;j++){\n                    field[i][j]=-1;\n                }\n            }\n            for(int i = 0;i<Y;i++){\n                for(int j = 1;j<X+1;j++){\n                    field[i][j]=cin.nextInt();\n                }\n            }\n            for(int i = 0;i<X+2;i++){\n                if(field[0][i]==0){\n                    ski(0,i);\n                }\n            }\n            System.out.println(ans);\n        }\n    }\n    static void ski(int y,int x){\n        //System.out.println((y+1)+\" \" + x);\n        if(y>=Y-1){\n            //System.out.println(\"aaaaaaaa\"+(y+1)+\" \" + x);\n            ans++;\n            return;\n        }\n        if(field[y][x]==2){\n        \tif(field[y+2][x]!=1){\n        \t\tski(y+2,x);\n        \t}\n            return;\n        }\n        if(field[y+1][x]==0){\n            ski(y+1,x);\n        }\n        else if(field[y+1][x]==2){\n            ski(y+1,x);\n        }\n         \n        if(field[y+1][x-1]==0){\n            ski(y+1,x-1);\n        }\n        if(field[y+1][x+1]==0){\n            ski(y+1,x+1);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tScanner sc;\n\tint w,h;\n\tint[][] map;\n\tint[][] route;\n\t\n\tvoid printMap(){\n\t\tfor(int i=0;i<h+2;i++) {\n\t\t\tfor(int j =0;j<w+2;j++) {\n\t\t\t\tSystem.out.print(route[i][j] + \" \");\n\t\t\t}\n\t\t\tSystem.out.print(\" \");\n\t\t\tfor(int j =0;j<w+2;j++) {\n\t\t\t\tSystem.out.print(map[i][j] + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n\t}\n\t\n\tvoid run() {\n\t\tsc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif(w==0&&h==0) break;\n\t\t\tmap = new int[h+2][w+2];\n\t\t\troute = new int[h+2][w+2];\n\t\t\tfor(int i=0;i<h;i++) for(int j=0;j<w+2;j++) { map[i][j] = 1; route[i][j] = 0; }\n\t\t\tfor(int i=h;i<h+2;i++)for(int j=0;j<w+2;j++) { map[i][j] = 0; route[i][j] = 0; }\n\t\t\tfor(int i=0;i<h;i++) for(int j=1;j<w+1;j++) map[i][j] = sc.nextInt();\n\t\t\tfor(int j=1;j<w+1;j++) if(map[0][j] != 1) route[0][j] = 1;\n\t\t\tfor(int i=0;i<h-1;i++) for(int j=1;j<w+1;j++){\n//\t\t\t\tif(j==1)printMap();\n\t\t\t\tif(map[i][j] == 0){\n\t\t\t\t\tif(map[i+1][j-1] == 0) route[i+1][j-1] += route[i][j];\n\t\t\t\t\tif(map[i+1][j] != 1) route[i+1][ j ] += route[i][j];\n\t\t\t\t\tif(map[i+1][j+1] == 0) route[i+1][j+1] += route[i][j];\n\t\t\t\t}\n\t\t\t\telse if(map[i][j] == 2) {\n\t\t\t\t\tif(map[i+2][j] != 1) route[i+2][ j ] += route[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = 0;\n\t\t\tfor(int i=h-1;i<h+1;i++) for(int j=1;j<w+1;j++) {\n\t\t\t\tans += route[i][j];\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * A New Plan of Aizu Ski Resort\n * PCK2009 ??????9\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tint x, y;\n\t\t\tx = parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\ty = parseInt(line.substring(line.indexOf(' ') + 1));\n\t\t\tif ((x | y) == 0) break;\n\n\t\t\tint[][] course = new int[y + 4][x + 2];\n\t\t\tint[][] dp = new int[y + 4][x + 2];\n\n\t\t\tfor (int i = 0; i < y; i++) {\n\t\t\t\twords = br.readLine().split(\" \");\n\t\t\t\tfor (int j = 0; j < words.length; j++) {\n\t\t\t\t\tcourse[i + 2][j + 1] = parseInt(words[j]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//\n\t\t\tfor (int i = 1; i < x + 1; i++) {\n\t\t\t\tif (course[2][i] == 0) dp[2][i] = 1;\n\t\t\t}\n\n\t\t\tfor (int i = 2; i < y + 2; i++) {\n\t\t\t\tfor (int j = 1; j < x + 1; j++) {\n\t\t\t\t\tswitch (course[i][j]) {\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tif (course[i - 1][j - 1] == 0) {\n\t\t\t\t\t\t\t\tdp[i][j] += dp[i - 1][j - 1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (course[i - 1][j] == 0) {\n\t\t\t\t\t\t\t\tdp[i][j] += dp[i - 1][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (course[i - 1][j + 1] == 0) {\n\t\t\t\t\t\t\t\tdp[i][j] += dp[i - 1][j + 1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (course[i - 2][j] == 2) {\n\t\t\t\t\t\t\t\tdp[i][j] += dp[i - 2][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tif (course[i - 1][j] == 0) {\n\t\t\t\t\t\t\t\tdp[i][j] += dp[i - 1][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (course[i - 2][j] == 2) {\n\t\t\t\t\t\t\t\tdp[i][j] += dp[i - 2][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = y + 2; i < y + 4; i++) {\n\t\t\t\tfor (int j = 1; j < x + 1; j++) {\n\t\t\t\t\tif (course[i - 2][j] == 2) {\n\t\t\t\t\t\tdp[i][j] += dp[i - 2][j];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdp[i][j] += dp[i - 1][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//\n\t\t\tint sum = 0;\n\t\t\tfor (int i = 1; i < x + 1; i++) sum += dp[y + 3][i];\n\t\t\tSystem.out.println(sum);\n\t\t}//end while\n\t}//end main\n}"
  },
  {
    "language": "Java",
    "code": "mport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * A New Plan of Aizu Ski Resort\n * PCK2009 ??????9\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tint x, y;\n\t\t\tx = parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\ty = parseInt(line.substring(line.indexOf(' ') + 1));\n\t\t\tif ((x | y) == 0) break;\n\n\t\t\tint[][] course = new int[y + 4][x + 2];\n\t\t\tint[][] dp = new int[y + 4][x + 2];\n\n\t\t\tfor (int i = 0; i < y; i++) {\n\t\t\t\twords = br.readLine().split(\" \");\n\t\t\t\tfor (int j = 0; j < words.length; j++) {\n\t\t\t\t\tcourse[i + 2][j + 1] = parseInt(words[j]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//\n\t\t\tfor (int i = 1; i < x + 1; i++) {\n\t\t\t\tif (course[2][i] == 0) dp[2][i] = 1;\n\t\t\t}\n\n\t\t\tfor (int i = 2; i < y + 2; i++) {\n\t\t\t\tfor (int j = 1; j < x + 1; j++) {\n\t\t\t\t\tswitch (course[i][j]) {\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tif (course[i - 1][j - 1] == 0) {\n\t\t\t\t\t\t\t\tdp[i][j] += dp[i - 1][j - 1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (course[i - 1][j] == 0) {\n\t\t\t\t\t\t\t\tdp[i][j] += dp[i - 1][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (course[i - 1][j + 1] == 0) {\n\t\t\t\t\t\t\t\tdp[i][j] += dp[i - 1][j + 1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (course[i - 2][j] == 2) {\n\t\t\t\t\t\t\t\tdp[i][j] += dp[i - 2][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tif (course[i - 1][j] == 0) {\n\t\t\t\t\t\t\t\tdp[i][j] += dp[i - 1][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (course[i - 2][j] == 2) {\n\t\t\t\t\t\t\t\tdp[i][j] += dp[i - 2][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = y + 2; i < y + 4; i++) {\n\t\t\t\tfor (int j = 1; j < x + 1; j++) {\n\t\t\t\t\tif (course[i - 1][j] == 0) {\n\t\t\t\t\t\tdp[i][j] += dp[i - 1][j];\n\t\t\t\t\t}\n\t\t\t\t\tif (course[i - 2][j] == 2) {\n\t\t\t\t\t\tdp[i][j] += dp[i - 2][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//\n\t\t\tint sum = 0;\n\t\t\tfor (int i = 1; i < x + 1; i++) sum += dp[y + 3][i];\n\t\t\tSystem.out.println(sum);\n\t\t}//end while\n\t}//end main\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n\tint w;\n\tint h;\n\tint count;\n\tshort[][] map;\n\tint[][] dp;\n\tpublic void run(){\n\t\tScanner scan = new Scanner(System.in);\n\t\twhile(scan.hasNext()){\n\t\t\tw = scan.nextInt();\n\t\t\th = scan.nextInt();\n\t\t\tif(w == 0 && h == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmap = new short[h][w];\n\t\t\tfor(int i = 0;i < h;i++){\n\t\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\t\tmap[i][j] = scan.nextShort();\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp = new int[h+1][w];\n\t\t\tfor(int i = 0;i < w;i++){\n\t\t\t\tif(map[0][i] == 0){\n\t\t\t\t\tdp[0][i] = 1;\n\t\t\t\t}else{\n\t\t\t\t\tdp[0][i] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 1;i < h;i++){\n\t\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\t\tif(map[i][j] == 1){\n\t\t\t\t\t\tdp[i][j] = 0;\n\t\t\t\t\t}else if(map[i][j] == 2){\n\t\t\t\t\t\tif(i < h-1){\n\t\t\t\t\t\t\tdp[i+2][j] += dp[i-1][j] + dp[i][j];\n\t\t\t\t\t\t\tdp[i][j] = 0;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tdp[i][j] += dp[i-1][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(j != 0){\n\t\t\t\t\t\t\tdp[i][j] += dp[i-1][j-1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(j != w-1){\n\t\t\t\t\t\t\tdp[i][j] += dp[i-1][j+1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp[i][j] += dp[i-1][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcount = 0;\n\t\t\tfor(int i = 0;i < w;i++){\n\t\t\t\tcount += dp[h-1][i] + dp[h][i];\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tScanner sc;\n\tint w,h;\n\tint[][] map;\n\tint[][] route;\n\t\n\tvoid printMap(){\n\t\tfor(int i=0;i<h+2;i++) {\n\t\t\tfor(int j =0;j<w+2;j++) {\n\t\t\t\tSystem.out.print(route[i][j] + \" \");\n\t\t\t}\n\t\t\tSystem.out.print(\" \");\n\t\t\tfor(int j =0;j<w+2;j++) {\n\t\t\t\tSystem.out.print(map[i][j] + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n\t}\n\t\n\tvoid run() {\n\t\tsc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif(w==0&&h==0) break;\n\t\t\tmap = new int[h+2][w+2];\n\t\t\troute = new int[h+2][w+2];\n\t\t\tfor(int i=0;i<h;i++) for(int j=0;j<w+2;j++) { map[i][j] = 1; route[i][j] = 0; }\n\t\t\tfor(int i=h;i<h+2;i++)for(int j=0;j<w+2;j++) { map[i][j] = 0; route[i][j] = 0; }\n\t\t\tfor(int i=0;i<h;i++) for(int j=1;j<w+1;j++) map[i][j] = sc.nextInt();\n\t\t\tfor(int j=1;j<w+1;j++) if(map[0][j] != 1) route[0][j] = 1;\n\t\t\tfor(int i=0;i<h-1;i++) for(int j=1;j<w+1;j++){\n//\t\t\t\tif(j==1)printMap();\n\t\t\t\tif(map[i][j] == 0){\n\t\t\t\t\tif(map[i+1][j-1] == 0) route[i+1][j-1] += route[i][j];\n\t\t\t\t\tif(map[i+1][j] != 1) route[i+1][ j ] += route[i][j];\n\t\t\t\t\tif(map[i+1][j+1] == 0) route[i+1][j+1] += route[i][j];\n\t\t\t\t}\n\t\t\t\telse if(map[i][j] == 2) {\n\t\t\t\t\tif(map[i+2][j] != 1) route[i+2][ j ] += route[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = 0;\n\t\t\tfor(int i=h-1;i<h+1;i++) for(int j=1;j<w+1;j++) {\n\t\t\t\tans += route[i][j];\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic int H,W;\n\tstatic int[][] field;\n\tstatic int[][] dp;\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tW=cin.nextInt();\n\t\t\tH=cin.nextInt();\n\t\t\tif(W+H==0)break;\n\t\t\tfield=new int[H+2][W];\n\t\t\tdp=new int[H+2][W];\n\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\tfield[i][j]=cin.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<W;i++){\n\t\t\t\tif(field[0][i]==0)dp[0][i]=1;\n\t\t\t}\n\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\tif(field[i][j]==0){\n\t\t\t\t\t\tif(i!=H-1){\n\t\t\t\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\t\t\t\tif(j+k<0||j+k>=W)continue;\n\t\t\t\t\t\t\t\tif(field[i+1][j+k]==1)continue;\n\t\t\t\t\t\t\t\tif(k!=0&&field[i+1][j+k]==2)continue;\n\t\t\t\t\t\t\t\tdp[i+1][j+k]+=dp[i][j];\n\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tdp[i+1][j]+=dp[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(field[i][j]==2){\n\t\t\t\t\t\tdp[i+2][j]+=dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans=0;\n\t\t\tfor(int i=H;i<H+2;i++){\n\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\tans+=dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t\t\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\nnamespace AOJ\n{\n    class AOJ203\n    {\n        public string solve(int x,int y)\n        {\n            string[][] cource;\n            int[][] sum;\n            cource = new string[y][];\n            sum = new int[y][];\n            for (int i = 0; i < y; i++)\n            {\n                sum[i] = new int[x];\n            }\n\n            for (int i = 0; i < y; i++)\n            {\n                char[] delimi = new char[] { ' ' };\n                string[] row = Console.ReadLine().Split(delimi);\n                cource[i] = row;\n            }\n\n\n            for (int i = 0; i < x; i++)\n            {\n                if (cource[0][i].Equals(\"0\"))\n                {\n                    sum[0][i] = 1;\n                }\n            }\n\n            for (int i = 0; i < y - 1; i++)\n            {\n                for (int j = 0; j < x; j++)\n                {\n                    switch (cource[i][j])\n                    {\n                        case \"0\":\n                            if (!cource[i + 1][j].Equals(\"1\"))\n                            {\n                                sum[i + 1][j] += sum[i][j];\n                            }\n\n                            if (j < x - 1)\n                            {\n                                if (cource[i + 1][j + 1].Equals(\"0\"))\n                                {\n                                    sum[i + 1][j + 1] += sum[i][j];\n                                }\n                            }\n\n                            if (j > 0)\n                            {\n                                if (cource[i + 1][j - 1].Equals(\"0\"))\n                                {\n                                    sum[i + 1][j - 1] += sum[i][j];\n                                }\n                            }\n\n                            break;\n                        case \"2\":\n                            if (i < y - 2)\n                            {\n                                sum[i + 2][j] += sum[i][j];\n                            }\n                            break;\n                    }\n                }\n            }\n\n            int total = 0;\n            //for (int i = 0; i < x; i++)\n            //{\n            //    total += sum[y - 1][i];\n            //    total += (cource[y - 2][i].Equals(\"2\")) ? sum[y - 2][i] : 0;\n            //}\n\n            return total.ToString();\n        }\n    }\n    class Program\n    {\n        \n        static void Main(string[] args)\n        {\n            AOJ203 obj = new AOJ203();\n            while (true)\n            {\n                char[] delimi = { ' ' };\n                string[] str = Console.ReadLine().Split(delimi);\n                int n = int.Parse(str[0]);\n                int x = int.Parse(str[1]);\n                if (n == 0 && x == 0) break;\n\n                Console.WriteLine(obj.solve(n,x));\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class Hello\n{\n    public static void Main()\n    {\n        while (true)\n        {\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            var w = int.Parse(line[0]);\n            var h = int.Parse(line[1]);\n            if (w == 0 && h == 0) break;\n            var map = new int[h, w];\n            for (int i = 0; i < h; i++)\n            {\n                string[] line2 = Console.ReadLine().Trim().Split(' ');\n                for (int j = 0; j < w; j++) map[i, j] = int.Parse(line2[j]);\n            }\n            var dp = new int[h, w];\n            goDP(map, dp);\n            var ans = 0;\n            for (int i = 0; i < w; i++)\n            {\n                ans += dp[h - 1, i];\n                if (map[h - 2, i] == 2) ans += dp[h - 2, i];\n            }\n            Console.WriteLine(ans);\n        }\n    }\n    public static void goDP(int[,] map, int[,] dp)\n    {\n        var h = dp.GetLength(0); var w = dp.GetLength(1);\n        for (int i = 0; i < w; i++)\n            if (map[0, i] == 0) dp[0, i] = 1;\n        for (int i = 1; i < h; i++)\n            for (int j = 0; j < w; j++)\n                switch (map[i, j])\n                {\n                    case 0:\n                        if (i - 2 >= 0 && map[i - 2, j] == 2) dp[i, j] += dp[i - 2, j];\n                        if (map[i - 1, j] == 0) dp[i, j] += dp[i - 1, j];\n                        if (j - 1 >= 0 && map[i - 1, j - 1] == 0) dp[i, j] += dp[i - 1, j - 1];\n                        if (j + 1 <= w - 1 && map[i - 1, j + 1] == 0) dp[i, j] += dp[i - 1, j + 1];\n                        break;\n                    case 2:\n                        if (map[i - 1, j] == 0) dp[i, j] = dp[i - 1, j];\n                        if (i - 2 >= 0 && map[i - 2, j] == 2) dp[i, j] += dp[i - 2, j];\n                        break;\n                    default:\n                        break;\n                }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class Hello\n{\n    public static void Main()\n    {\n        while (true)\n        {\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            var w = int.Parse(line[0]);\n            var h = int.Parse(line[1]);\n            if (w == 0 && h == 0) break;\n            var map = new int[h, w];\n            for (int i = 0; i < h; i++)\n            {\n                string[] line2 = Console.ReadLine().Trim().Split(' ');\n                for (int j = 0; j < w; j++) map[i, j] = int.Parse(line2[j]);\n            }\n            var dp = new int[h , w ];\n            goDP(map, dp);\n            var ans = 0;\n            for (int i = 0; i < w; i++) ans += dp[h - 1, i];\n            Console.WriteLine(ans);\n        }\n    }\n    public static void goDP ( int[,] map ,  int[,] dp )\n    {\n        var h = dp.GetLength(0);  var w = dp.GetLength(1);\n        for (int i = 0; i < w; i++)\n            if (map[0, i] == 0) dp[0, i] = 1;\n        for (int i = 1; i < h; i++)\n            for (int j = 0; j < w; j++)\n                switch (map[i,j])\n                {\n                    case 0:\n                        dp[i, j] += dp[i - 1, j];\n                        if (j - 1 >= 0 && map[i-1,j-1] == 0) dp[i, j] += dp[i-1, j - 1];\n                        if (j + 1 <= w - 1 && map[i-1,j+1] == 0) dp[i, j] += dp[i -1, j + 1];\n                        break;\n                    case 1:\n                        if (map[i - 1, j] == 2) dp[i, j] = dp[i - 1, j];\n                        break;\n                    case 2:\n                        if (map[i-1,j] != 2) dp[i, j] = dp[i - 1, j];\n                        break;\n                }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class Hello{\n    public static int SizeX, SizeY;\n    public static int[,] MapInfo;\n    public static int[,] Step;\n    public static void Main(){\n        while(true){\n            string[] X_Y = System.Console.ReadLine().Split(' ');\n            SizeX = int.Parse(X_Y[0]);\n            SizeY = int.Parse(X_Y[1]);\n//Console.WriteLine(SizeX + \" \" + SizeY);\n            if(SizeX == 0 && SizeY == 0) break;\n            \n            MapInfo = new int[SizeY,SizeX];\n            Step = new int[SizeY,SizeX];\n            for(int y = 0; y < SizeY; y++){\n                string[] LineX = System.Console.ReadLine().Split(' ');\n                for(int x = 0; x < SizeX; x++){\n                    MapInfo[y,x] = int.Parse(LineX[x]);\n                    Step[y,x] = Solve(x, y);\n//Console.Write(Step[y,x] + \" \");\n                }\n//Console.WriteLine();\n            }\n            \n            int RoutesSum = 0;\n            for(int x = 0; x < SizeX; x++){\n                RoutesSum += Step[SizeY - 1, x];\n                RoutesSum += MapInfo[SizeY - 2, x] == Consts.JUMP ? Step[SizeY - 2, x] : 0;\n            }\n            System.Console.WriteLine(RoutesSum);\n        }\n    }\n    public static int Solve(int x, int y){\n        int PartialRoutesSum = 0;\n//Console.Write(\"x:\" + x + \" y:\" + y);\n        \n        switch(MapInfo[y,x]){\n            case Consts.EMPTY:\n//Console.WriteLine(\" \" + MapInfo[y,x] + \" is EMPTY\");\n                if(y == 0){ return 1; }\n                else{\n                    for(int PartialX = x - 1; PartialX < x + 2; PartialX++){\n                        try{ PartialRoutesSum += MapInfo[y-1,PartialX] != Consts.JUMP ? Step[y-1,PartialX] : 0; }\n                        catch(IndexOutOfRangeException){\n                            continue;\n                        }\n                    }\n                    try{ PartialRoutesSum += MapInfo[y-2,x] == Consts.JUMP ? Step[y-2,x] : 0; }\n                    catch(IndexOutOfRangeException){}\n                }\n                break;\n            case Consts.JUMP:\n//Console.WriteLine(\" \" + MapInfo[y,x] + \" is JUMP\");\n                try{\n                    PartialRoutesSum += MapInfo[y-1,x] == Consts.EMPTY ? Step[y-1,x] : 0;\n                    PartialRoutesSum += MapInfo[y-2,x] == Consts.JUMP ? Step[y-2,x] : 0;\n                }\n                catch(IndexOutOfRangeException){}\n                break;\n            case Consts.OBSTACLE:\n//Console.WriteLine(\" \" + MapInfo[y,x] + \" is OBSTACLE\");\n                return 0;\n            default:\n//Console.WriteLine();\n                break;\n        }\n        \n        return PartialRoutesSum;\n    }\n}\n\npublic static class Consts{\n    public const int EMPTY = 0;\n    public const int OBSTACLE = 1;\n    public const int JUMP = 2;\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class Hello{\n    public static int SizeX, SizeY;\n    public static int[,] MapInfo;\n    public static int[,] Step;\n    public static void Main(){\n        while(true){\n            string[] X_Y = System.Console.ReadLine().Split(' ');\n            SizeX = int.Parse(X_Y[0]);\n            SizeY = int.Parse(X_Y[1]);\n//Console.WriteLine(SizeX + \" \" + SizeY);\n            if(SizeX == 0 && SizeY == 0) break;\n            \n            MapInfo = new int[SizeY,SizeX];\n            Step = new int[SizeY,SizeX];\n            for(int y = 0; y < SizeY; y++){\n                string[] LineX = System.Console.ReadLine().Split(' ');\n                for(int x = 0; x < SizeX; x++){\n                    MapInfo[y,x] = int.Parse(LineX[x]);\n                    Step[y,x] = Solve(x, y);\n//Console.Write(Step[y,x] + \" \");\n                }\n//Console.WriteLine();\n            }\n            \n            int RoutesSum = 0;\n            for(int x = 0; x < SizeX; x++){\n                RoutesSum += Step[SizeY - 1, x];\n                RoutesSum += MapInfo[SizeY - 2, x] == Consts.JUMP ? Step[SizeY - 2, x] : 0;\n            }\n            System.Console.WriteLine(RoutesSum);\n        }\n    }\n    public static int Solve(int x, int y){\n        int PartialRoutesSum = 0;\n//Console.Write(\"x:\" + x + \" y:\" + y);\n        \n        switch(MapInfo[y,x]){\n            case Consts.EMPTY:\n//Console.WriteLine(\" \" + MapInfo[y,x] + \" is EMPTY\");\n                if(y == 0){ return 1; }\n                else{\n                    for(int PartialX = x - 1; PartialX < x + 2; PartialX++){\n                        try{ PartialRoutesSum += MapInfo[y-1,PartialX] != Consts.JUMP ? Step[y-1,PartialX] : 0; }\n                        catch(IndexOutOfRangeException){\n                            continue;\n                        }\n                    }\n                    try{ PartialRoutesSum += MapInfo[y-2,x] == Consts.JUMP ? Step[y-2,x] : 0; }\n                    catch(IndexOutOfRangeException){}\n                }\n                break;\n            case Consts.JUMP:\n//Console.WriteLine(\" \" + MapInfo[y,x] + \" is JUMP\");\n                try{\n                    PartialRoutesSum += MapInfo[y-1,x] == Consts.EMPTY ? Step[y-1,x] : 0;\n                    PartialRoutesSum += MapInfo[y-2,x] == Consts.JUMP ? Step[y-2,x] : 0;\n                }\n                catch(IndexOutOfRangeException){}\n                break;\n            case Consts.OBSTACLE:\n//Console.WriteLine(\" \" + MapInfo[y,x] + \" is OBSTACLE\");\n                return 0;\n            default:\n//Console.WriteLine();\n                break;\n        }\n        \n        return PartialRoutesSum;\n    }\n}\n\npublic static class Consts{\n    public const int EMPTY = 0;\n    public const int OBSTACLE = 1;\n    public const int JUMP = 2;\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\nnamespace AOJ\n{\n    class AOJ203\n    {\n        public string solve(int x,int y)\n        {\n            string[][] cource;\n            int[][] sum;\n            cource = new string[y][];\n            sum = new int[y][];\n            for (int i = 0; i < y; i++)\n            {\n                sum[i] = new int[x];\n            }\n\n            for (int i = 0; i < y; i++)\n            {\n                char[] delimi = new char[] { ' ' };\n                string[] row = Console.ReadLine().Split(delimi);\n                cource[i] = row;\n            }\n\n\n            for (int i = 0; i < x; i++)\n            {\n                if (cource[0][i].Equals(\"0\"))\n                {\n                    sum[0][i] = 1;\n                }\n            }\n\n            for (int i = 0; i < y-1; i++)\n            {\n                for (int j = 0; j < x; j++)\n                {\n                    switch (cource[i][j])\n                    {\n                        case \"0\":\n                            if (!cource[i + 1][j].Equals(\"1\"))\n                            {\n                                sum[i + 1][ j]+=sum[i][j];\n                            }\n\n                            if (j < x - 1)\n                            {\n                                if (cource[i + 1][j+1].Equals(\"0\"))\n                                {\n                                    sum[i + 1][j+1] += sum[i][j];\n                                }\n                            }\n\n                            if (j > 0)\n                            {\n                                if (cource[i + 1][j-1].Equals(\"0\"))\n                                {\n                                    sum[i + 1][j-1] += sum[i][j];\n                                }\n                            }\n\n                            break;\n                        case \"2\":\n                            if (i < y - 2)\n                            {\n                                sum[i + 2][j] += sum[i][ j];\n                            }\n                            break;\n                    }\n                }\n            }\n\n            int total = 0;\n            for (int i = 0; i < x; i++)\n            {\n                total += sum[y - 1][i];\n                if(cource[y - 2][i].Equals(\"2\")){\n                    total +=sum[y - 2][i];\n                }\n            }\n\n            return total.ToString();\n        }\n    }\n    class Program\n    {\n        \n        static void Main(string[] args)\n        {\n            AOJ203 obj = new AOJ203();\n            while (true)\n            {\n                char[] delimi = { ' ' };\n                string[] str = Console.ReadLine().Split(delimi);\n                int n = int.Parse(str[0]);\n                int x = int.Parse(str[1]);\n                if (n == 0 && x == 0) break;\n\n                Console.WriteLine(obj.solve(n,x));\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class Hello{\n    public static int SizeX, SizeY;\n    public static int[,] MapInfo;\n    public static int[,] Step;\n    public static void Main(){\n        while(true){\n            string[] X_Y = System.Console.ReadLine().Split(' ');\n            SizeX = int.Parse(X_Y[0]);\n            SizeY = int.Parse(X_Y[1]);\n            if(SizeX == 0 && SizeY == 0) break;\n            \n            MapInfo = new int[SizeY,SizeX];\n            Step = new int[SizeY,SizeX];\n            for(int y = 0; y < SizeY; y++){\n                string[] LineX = System.Console.ReadLine().Split(' ');\n                for(int x = 0; x < SizeX; x++){\n                    MapInfo[y,x] = int.Parse(LineX[x]);\n                    Step[y,x] = Solve(x, y);\n                }\n            }\n            \n            int RoutesSum = 0;\n            for(int x = 0; x < SizeX; x++){\n                RoutesSum += Step[SizeY - 1, x];\n                try{\n                    RoutesSum += MapInfo[SizeY - 2, x] == Consts.JUMP ? Step[SizeY - 2, x] : 0 ;\n                }\n                catch(IndexOutOfRangeException){\n                    break;\n                }\n            }\n            System.Console.WriteLine(RoutesSum);\n        }\n    }\n    \n    public static int Solve(int x, int y){\n        int PartialRoutesSum = 0;\n        \n        switch(MapInfo[y,x]){\n            case Consts.EMPTY:\n                if(y == 0){ return 1; }\n                else{\n                    for(int PartialX = x - 1; PartialX < x + 2; PartialX++){\n                        try{ PartialRoutesSum += MapInfo[y-1,PartialX] != Consts.JUMP ? Step[y-1,PartialX] : 0; }\n                        catch(IndexOutOfRangeException){\n                            continue;\n                        }\n                    }\n                    try{ PartialRoutesSum += MapInfo[y-2,x] == Consts.JUMP ? Step[y-2,x] : 0; }\n                    catch(IndexOutOfRangeException){}\n                }\n                break;\n            case Consts.JUMP:\n                try{\n                    PartialRoutesSum += MapInfo[y-1,x] == Consts.EMPTY ? Step[y-1,x] : 0;\n                    PartialRoutesSum += MapInfo[y-2,x] == Consts.JUMP ? Step[y-2,x] : 0;\n                }\n                catch(IndexOutOfRangeException){}\n                break;\n            case Consts.OBSTACLE:\n                return 0;\n            default:\n                break;\n        }\n        \n        return PartialRoutesSum;\n    }\n}\n\npublic static class Consts{\n    public const int EMPTY = 0;\n    public const int OBSTACLE = 1;\n    public const int JUMP = 2;\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\nnamespace AOJ\n{\n    class AOJ203\n    {\n        string[][] cource;\n        int[,] sum;\n        int x;\n        int y;\n\n        public int solve(int p_x,int p_y)\n        {\n            x = p_x;\n            y = p_y;\n            cource = new string[y][];\n            sum = new int[y,x];\n\n            for (int i = 0; i < y; i++)\n            {\n                string[] row = Console.ReadLine().Split(new char[]{' '});\n                cource[i] = row;\n            }\n\n\n            for (int i = 0; i < x; i++)\n            {\n                if (cource[0][i].Equals(\"0\"))\n                {\n                    sum[0, i] = 1;\n                }\n            }\n\n            for (int i = 0; i < y-1; i++)\n            {\n                for (int j = 0; j < x; j++)\n                {\n                    switch (cource[i][j])\n                    {\n                        case \"0\":\n                            if (!cource[i + 1][j].Equals(\"1\"))\n                            {\n                                sum[i + 1, j]+=sum[i,j];\n                            }\n\n                            if (j < x - 1)\n                            {\n                                if (cource[i + 1][j+1].Equals(\"0\"))\n                                {\n                                    sum[i + 1,j+1] += sum[i,j];\n                                }\n                            }\n\n                            if (j > 0)\n                            {\n                                if (cource[i + 1][j-1].Equals(\"0\"))\n                                {\n                                    sum[i + 1,j-1] += sum[i,j];\n                                }\n                            }\n\n                            break;\n                        case \"2\":\n                            if (i < y - 2)\n                            {\n                                sum[i + 2,j] += sum[i, j];\n                            }\n                            break;\n                    }\n                }\n            }\n\n            int total = 0;\n            for (int i = 0; i < x; i++)\n            {\n                total += sum[y - 1, i];\n                total += (cource[y - 2][i].Equals(\"2\")) ? sum[y - 2, i] : 0;\n            }\n\n            return total;\n        }\n        \n        \n    }\n    class Program\n    {\n        \n        static void Main(string[] args)\n        {\n            AOJ203 obj = new AOJ203();\n            while (true)\n            {\n                char[] delimi = { ' ' };\n                string[] str = Console.ReadLine().Split(delimi);\n                int n = int.Parse(str[0]);\n                int x = int.Parse(str[1]);\n                if (n == 0 && x == 0) break;\n\n                Console.WriteLine(obj.solve(n,x));\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class Hello\n{\n    public static void Main()\n    {\n        while (true)\n        {\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            var w = int.Parse(line[0]);\n            var h = int.Parse(line[1]);\n            if (w == 0 && h == 0) break;\n            var map = new int[h, w];\n            for (int i = 0; i < h; i++)\n            {\n                string[] line2 = Console.ReadLine().Trim().Split(' ');\n                for (int j = 0; j < w; j++) map[i, j] = int.Parse(line2[j]);\n            }\n            var dp = new int[h, w];\n            goDP(map, dp);\n            var ans = 0;\n            for (int i = 0; i < w; i++)\n            {\n                ans += dp[h - 1, i];\n                if (h-2 >= 0  && map[h - 2, i] == 2) ans += dp[h - 2, i];\n            }\n            Console.WriteLine(ans);\n        }\n    }\n    public static void goDP(int[,] map, int[,] dp)\n    {\n        var h = dp.GetLength(0); var w = dp.GetLength(1);\n        for (int i = 0; i < w; i++)\n            if (map[0, i] == 0) dp[0, i] = 1;\n        for (int i = 1; i < h; i++)\n            for (int j = 0; j < w; j++)\n                switch (map[i, j])\n                {\n                    case 0:\n                        if (i - 2 >= 0 && map[i - 2, j] == 2) dp[i, j] += dp[i - 2, j];\n                        if (map[i - 1, j] == 0) dp[i, j] += dp[i - 1, j];\n                        if (j - 1 >= 0 && map[i - 1, j - 1] == 0) dp[i, j] += dp[i - 1, j - 1];\n                        if (j + 1 <= w - 1 && map[i - 1, j + 1] == 0) dp[i, j] += dp[i - 1, j + 1];\n                        break;\n                    case 2:\n                        if (map[i - 1, j] == 0) dp[i, j] = dp[i - 1, j];\n                        if (i - 2 >= 0 && map[i - 2, j] == 2) dp[i, j] += dp[i - 2, j];\n                        break;\n                    default:\n                        break;\n                }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\nnamespace AOJ\n{\n    class AOJ203\n    {\n        public string solve(int x,int y)\n        {\n            string[][] cource;\n            int[][] sum;\n            cource = new string[y][];\n            sum = new int[y][];\n            for (int i = 0; i < y; i++)\n            {\n                sum[i] = new int[x];\n            }\n\n            for (int i = 0; i < y; i++)\n            {\n                char[] delimi = new char[] { ' ' };\n                string[] row = Console.ReadLine().Split(delimi);\n                cource[i] = row;\n            }\n\n\n            for (int i = 0; i < x; i++)\n            {\n                if (cource[0][i].Equals(\"0\"))\n                {\n                    sum[0][i] = 1;\n                }\n            }\n\n            for (int i = 0; i < y-1; i++)\n            {\n                for (int j = 0; j < x; j++)\n                {\n                    switch (cource[i][j])\n                    {\n                        case \"0\":\n                            if (!cource[i + 1][j].Equals(\"1\"))\n                            {\n                                sum[i + 1][ j]+=sum[i][j];\n                            }\n\n                            if (j < x - 1)\n                            {\n                                if (cource[i + 1][j+1].Equals(\"0\"))\n                                {\n                                    sum[i + 1][j+1] += sum[i][j];\n                                }\n                            }\n\n                            if (j > 0)\n                            {\n                                if (cource[i + 1][j-1].Equals(\"0\"))\n                                {\n                                    sum[i + 1][j-1] += sum[i][j];\n                                }\n                            }\n\n                            break;\n                        case \"2\":\n                            if (i < y - 2 && !cource[i+2][j].Equals(\"1\"))\n                            {\n                                sum[i + 2][j] += sum[i][ j];\n                            }\n                            break;\n                    }\n                }\n            }\n\n            int total = 0;\n            for (int i = 0; i < x; i++)\n            {\n                total += sum[y - 1][i];\n                if(y>3 && cource[y - 2][i].Equals(\"2\")){\n                    total +=sum[y - 2][i];\n                }\n            }\n\n            return total.ToString();\n        }\n    }\n    class Program\n    {\n        \n        static void Main(string[] args)\n        {\n            AOJ203 obj = new AOJ203();\n            while (true)\n            {\n                char[] delimi = { ' ' };\n                string[] str = Console.ReadLine().Split(delimi);\n                int n = int.Parse(str[0]);\n                int x = int.Parse(str[1]);\n                if (n == 0 && x == 0) break;\n\n                Console.WriteLine(obj.solve(n,x));\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class Hello\n{\n    public static void Main()\n    {\n        while (true)\n        {\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            var w = int.Parse(line[0]);\n            var h = int.Parse(line[1]);\n            if (w == 0 && h == 0) break;\n            var map = new int[h, w];\n            for (int i = 0; i < h; i++)\n            {\n                string[] line2 = Console.ReadLine().Trim().Split(' ');\n                for (int j = 0; j < w; j++) map[i, j] = int.Parse(line2[j]);\n            }\n            var dp = new int[h, w];\n            goDP(map, dp);\n            var ans = 0;\n            for (int i = 0; i < w; i++)\n            {\n                ans += dp[h - 1, i];\n                if (map[h - 2, i] == 2) ans += dp[h - 2, i];\n            }\n            Console.WriteLine(ans);\n        }\n    }\n    public static void goDP(int[,] map, int[,] dp)\n    {\n        var h = dp.GetLength(0); var w = dp.GetLength(1);\n        for (int i = 0; i < w; i++)\n            if (map[0, i] == 0) dp[0, i] = 1;\n        for (int i = 1; i < h; i++)\n            for (int j = 0; j < w; j++)\n                switch (map[i, j])\n                {\n                    case 0:\n                        if (i - 2 >= 0 && map[i - 2, j] == 2) dp[i, j] += dp[i - 2, j];\n                        if (map[i - 1, j] == 0) dp[i, j] += dp[i - 1, j];\n                        if (j - 1 >= 0 && map[i - 1, j - 1] == 0) dp[i, j] += dp[i - 1, j - 1];\n                        if (j + 1 <= w - 1 && map[i - 1, j + 1] == 0) dp[i, j] += dp[i - 1, j + 1];\n                        break;\n                    case 2:\n                        if (map[i - 1, j] == 0) dp[i, j] = dp[i - 1, j];\n                        if (i - 2 >= 0 && map[i - 2, j] == 2) dp[i, j] += dp[i - 2, j];\n                        break;\n                }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\nnamespace AOJ\n{\n    class AOJ203\n    {\n        public string solve(int x,int y)\n        {\n            string[][] cource;\n            int[][] sum;\n            cource = new string[y][];\n            sum = new int[y][];\n            for (int i = 0; i < y; i++)\n            {\n                sum[i] = new int[x];\n                for (int j = 0; j < x; j++)\n                {\n                    sum[i][j] = 0;\n                }\n            }\n\n            for (int i = 0; i < y; i++)\n            {\n                char[] delimi = new char[] { ' ' };\n                string[] row = Console.ReadLine().Split(delimi);\n                cource[i] = row;\n            }\n\n\n            for (int i = 0; i < x; i++)\n            {\n                if (cource[0][i].Equals(\"0\"))\n                {\n                    sum[0][i] = 1;\n                }\n            }\n\n            for (int i = 0; i < y-1; i++)\n            {\n                for (int j = 0; j < x; j++)\n                {\n                    switch (cource[i][j])\n                    {\n                        case \"0\":\n                            if (!cource[i + 1][j].Equals(\"1\"))\n                            {\n                                sum[i + 1][ j]+=sum[i][j];\n                            }\n\n                            if (j < x - 1)\n                            {\n                                if (cource[i + 1][j+1].Equals(\"0\"))\n                                {\n                                    sum[i + 1][j+1] += sum[i][j];\n                                }\n                            }\n\n                            if (j > 0)\n                            {\n                                if (cource[i + 1][j-1].Equals(\"0\"))\n                                {\n                                    sum[i + 1][j-1] += sum[i][j];\n                                }\n                            }\n\n                            break;\n                        case \"2\":\n                            if (i < y - 2 && !cource[i+2][j].Equals(\"1\"))\n                            {\n                                sum[i + 2][j] += sum[i][ j];\n                            }\n                            break;\n                    }\n                }\n            }\n\n            int total = 0;\n            for (int i = 0; i < x; i++)\n            {\n                total += sum[y - 1][i];\n                if(y>3 && cource[y - 2][i].Equals(\"2\")){\n                    total +=sum[y - 2][i];\n                }\n            }\n\n            return total.ToString();\n        }\n    }\n    class Program\n    {\n        \n        static void Main(string[] args)\n        {\n            AOJ203 obj = new AOJ203();\n            while (true)\n            {\n                char[] delimi = { ' ' };\n                string[] str = Console.ReadLine().Split(delimi);\n                int n = int.Parse(str[0]);\n                int x = int.Parse(str[1]);\n                if (n == 0 && x == 0) break;\n\n                Console.WriteLine(obj.solve(n,x));\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\nnamespace AOJ\n{\n    class AOJ203\n    {\n        public string solve(int x,int y)\n        {\n            string[][] cource;\n            int[][] sum;\n            cource = new string[y][];\n            sum = new int[y][];\n            for (int i = 0; i < y; i++)\n            {\n                sum[i] = new int[x];\n            }\n\n            for (int i = 0; i < y; i++)\n            {\n                char[] delimi = new char[] { ' ' };\n                string[] row = Console.ReadLine().Split(delimi);\n                cource[i] = row;\n            }\n\n\n            for (int i = 0; i < x; i++)\n            {\n                if (cource[0][i].Equals(\"0\"))\n                {\n                    sum[0][i] = 1;\n                }\n            }\n\n            for (int i = 0; i < y-1; i++)\n            {\n                for (int j = 0; j < x; j++)\n                {\n                    switch (cource[i][j])\n                    {\n                        case \"0\":\n                            if (!cource[i + 1][j].Equals(\"1\"))\n                            {\n                                sum[i + 1][ j]+=sum[i][j];\n                            }\n\n                            if (j < x - 1)\n                            {\n                                if (cource[i + 1][j+1].Equals(\"0\"))\n                                {\n                                    sum[i + 1][j+1] += sum[i][j];\n                                }\n                            }\n\n                            if (j > 0)\n                            {\n                                if (cource[i + 1][j-1].Equals(\"0\"))\n                                {\n                                    sum[i + 1][j-1] += sum[i][j];\n                                }\n                            }\n\n                            break;\n                        case \"2\":\n                            if (i < y - 2)\n                            {\n                                sum[i + 2][j] += sum[i][ j];\n                            }\n                            break;\n                    }\n                }\n            }\n\n            int total = 0;\n            for (int i = 0; i < x; i++)\n            {\n                total += sum[y - 1][i];\n                if(y>3 && cource[y - 2][i].Equals(\"2\")){\n                    total +=sum[y - 2][i];\n                }\n            }\n\n            return total.ToString();\n        }\n    }\n    class Program\n    {\n        \n        static void Main(string[] args)\n        {\n            AOJ203 obj = new AOJ203();\n            while (true)\n            {\n                char[] delimi = { ' ' };\n                string[] str = Console.ReadLine().Split(delimi);\n                int n = int.Parse(str[0]);\n                int x = int.Parse(str[1]);\n                if (n == 0 && x == 0) break;\n\n                Console.WriteLine(obj.solve(n,x));\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class Hello\n{\n    public static void Main()\n    {\n        while (true)\n        {\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            var w = int.Parse(line[0]);\n            var h = int.Parse(line[1]);\n            if (w == 0 && h == 0) break;\n            var map = new int[h, w];\n            for (int i = 0; i < h; i++)\n            {\n                string[] line2 = Console.ReadLine().Trim().Split(' ');\n                for (int j = 0; j < w; j++) map[i, j] = int.Parse(line2[j]);\n            }\n            var dp = new int[h , w ];\n            goDP(map, dp);\n            var ans = 0;\n            for (int i = 0; i < w; i++) ans += dp[h - 1, i];\n            Console.WriteLine(ans);\n        }\n    }\n    public static void goDP ( int[,] map ,  int[,] dp )\n    {\n        var h = dp.GetLength(0);  var w = dp.GetLength(1);\n        for (int i = 0; i < w; i++)\n            if (map[0, i] == 0) dp[0, i] = 1;\n        for (int i = 1; i < h; i++)\n            for (int j = 0; j < w; j++)\n                switch (map[i,j])\n                {\n                    case 0:\n                        dp[i, j] += dp[i - 1, j];\n                        if (j - 1 >= 0 && map[i-1,j-1] == 0) dp[i, j] += dp[i-1, j - 1];\n                        if (j + 1 <= w - 1 && map[i-1,j+1] == 0) dp[i, j] += dp[i -1, j + 1];\n                        break;\n                    case 1:\n                        if (map[i - 1, j] == 2) dp[i, j] = dp[i - 1, j];\n                        break;\n                    case 2:\n                        dp[i, j] = dp[i - 1, j];\n                        break;\n                }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\nnamespace AOJ\n{\n    class AOJ203\n    {\n        public string solve(int x,int y)\n        {\n            string[][] cource;\n            int[][] sum;\n            cource = new string[y][];\n            sum = new int[y][];\n            for (int i = 0; i < y; i++)\n            {\n                sum[i] = new int[x];\n            }\n\n            for (int i = 0; i < y; i++)\n            {\n                char[] delimi = new char[] { ' ' };\n                string[] row = Console.ReadLine().Split(delimi);\n                cource[i] = row;\n            }\n\n\n            for (int i = 0; i < x; i++)\n            {\n                if (cource[0][i].Equals(\"0\"))\n                {\n                    sum[0][i] = 1;\n                }\n            }\n\n            for (int i = 0; i < y - 1; i++)\n            {\n                for (int j = 0; j < x; j++)\n                {\n                    switch (cource[i][j])\n                    {\n                        case \"0\":\n                            if (!cource[i + 1][j].Equals(\"1\"))\n                            {\n                                sum[i + 1][j] += sum[i][j];\n                            }\n\n                            if (j < x - 1)\n                            {\n                                if (cource[i + 1][j + 1].Equals(\"0\"))\n                                {\n                                    sum[i + 1][j + 1] += sum[i][j];\n                                }\n                            }\n\n                            if (j > 0)\n                            {\n                                if (cource[i + 1][j - 1].Equals(\"0\"))\n                                {\n                                    sum[i + 1][j - 1] += sum[i][j];\n                                }\n                            }\n\n                            break;\n                        case \"2\":\n                            if (i < y - 2)\n                            {\n                                sum[i + 2][j] += sum[i][j];\n                            }\n                            break;\n                    }\n                }\n            }\n\n            int total = 0;\n            for (int i = 0; i < x; i++)\n            {\n                total += sum[y - 1][i];\n                total += (cource[y - 2][i].Equals(\"2\")) ? sum[y - 2][i] : 0;\n            }\n\n            return total.ToString();\n        }\n    }\n    class Program\n    {\n        \n        static void Main(string[] args)\n        {\n            AOJ203 obj = new AOJ203();\n            while (true)\n            {\n                char[] delimi = { ' ' };\n                string[] str = Console.ReadLine().Split(delimi);\n                int n = int.Parse(str[0]);\n                int x = int.Parse(str[1]);\n                if (n == 0 && x == 0) break;\n\n                Console.WriteLine(obj.solve(n,x));\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\n\nnamespace Test1 {\n\n    \n\n\n    class ClassMain {\n\n\n        static int[,] grid = new int[0, 0];\n        static long[,] dp = new long[0, 0];\n\n        public static void makeDP() {\n            int X = dp.GetLength(1);\n            int Y = dp.GetLength(0);\n\n            for (int x = 0; x < X; x++) { dp[Y - 1, x] = (grid[Y - 1, x] != 1) ? 1 : 0; }\n            for (int y = Y - 2; y >= 0; y--) {\n                for (int x = 0; x < X; x++) {\n                    if (grid[y, x] == 1) { dp[y, x] = 0; continue; }\n                    else if (grid[y, x] == 2) {\n                        if (y >= Y - 2) { dp[y, x] = 1; }\n                        else { dp[y, x] = dp[y + 2, x]; }\n                        continue;\n                    }\n                    if (grid[y, x] == 0) {\n                        dp[y, x] += dp[y + 1, x];\n                        if (x > 0) {\n                            dp[y, x] += (grid[y+1, x - 1] != 2) ? dp[y+1, x - 1] : 0;\n                        }\n                        if (x < X-1) {\n                            dp[y, x] += (grid[y+1, x + 1] != 2) ? dp[y+1, x + 1] : 0;\n                        }\n                    }\n\n\n                }\n            }\n                \n        }\n\n        public static void Main(String[] args) {\n            string line;\n            while ((line = Console.ReadLine()) != null) {\n                int[] ints = line.Split(' ').Select(int.Parse).ToArray();\n                int X = ints[0], Y = ints[1];\n                if (X == 0) { break; }\n                grid = new int[Y, X];\n                for (int i = 0; i < Y; i++) {\n                    line = Console.ReadLine();\n                    ints = line.Split(' ').Select(int.Parse).ToArray();\n                    for (int j = 0; j < X; j++) {\n                        grid[i, j] = ints[j];\n                    }\n                }\n                //stored.\n                dp = new long[Y, X];\n                makeDP();\n                long sum = 0;\n                for (int i = 0; i < X; i++) {\n                    sum += dp[0, i];\n                }\n                Console.WriteLine(sum);\n\n            }\n        }\n\n        \n    }\n\n\n\n    \n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\nnamespace AOJ\n{\n    class AOJ203\n    {\n        public string solve(int x,int y)\n        {\n            string[][] cource;\n            int[][] sum;\n            //x = p_x;\n            //y = p_y;\n            //cource = new string[y][];\n            //sum = new int[y][];\n            //for (int i = 0; i < y; i++)\n            //{\n            //    sum[i] = new int[x];\n            //}\n\n\n            //for (int i = 0; i < y; i++)\n            //{\n            //    char[] delimi = new char[] { ' ' };\n            //    string[] row = Console.ReadLine().Split(delimi);\n            //    cource[i] = row;\n            //}\n\n\n            //for (int i = 0; i < x; i++)\n            //{\n            //    if (cource[0][i].Equals(\"0\"))\n            //    {\n            //        sum[0][i] = 1;\n            //    }\n            //}\n\n            //for (int i = 0; i < y-1; i++)\n            //{\n            //    for (int j = 0; j < x; j++)\n            //    {\n            //        switch (cource[i][j])\n            //        {\n            //            case \"0\":\n            //                if (!cource[i + 1][j].Equals(\"1\"))\n            //                {\n            //                    sum[i + 1][ j]+=sum[i][j];\n            //                }\n\n            //                if (j < x - 1)\n            //                {\n            //                    if (cource[i + 1][j+1].Equals(\"0\"))\n            //                    {\n            //                        sum[i + 1][j+1] += sum[i][j];\n            //                    }\n            //                }\n\n            //                if (j > 0)\n            //                {\n            //                    if (cource[i + 1][j-1].Equals(\"0\"))\n            //                    {\n            //                        sum[i + 1][j-1] += sum[i][j];\n            //                    }\n            //                }\n\n            //                break;\n            //            case \"2\":\n            //                if (i < y - 2)\n            //                {\n            //                    sum[i + 2][j] += sum[i][ j];\n            //                }\n            //                break;\n            //        }\n            //    }\n            //}\n\n            int total = 0;\n            //for (int i = 0; i < x; i++)\n            //{\n            //    total += sum[y - 1][i];\n            //    total += (cource[y - 2][i].Equals(\"2\")) ? sum[y - 2][i] : 0;\n            //}\n\n            return total.ToString();\n        }\n    }\n    class Program\n    {\n        \n        static void Main(string[] args)\n        {\n            AOJ203 obj = new AOJ203();\n            while (true)\n            {\n                char[] delimi = { ' ' };\n                string[] str = Console.ReadLine().Split(delimi);\n                int n = int.Parse(str[0]);\n                int x = int.Parse(str[1]);\n                if (n == 0 && x == 0) break;\n\n                Console.WriteLine(obj.solve(n,x));\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\nnamespace AOJ\n{\n    class AOJ203\n    {\n        public string solve(int x,int y)\n        {\n            string[][] cource;\n            int[][] sum;\n            cource = new string[y][];\n            sum = new int[y][];\n            for (int i = 0; i < y; i++)\n            {\n                sum[i] = new int[x];\n            }\n\n            for (int i = 0; i < y; i++)\n            {\n                char[] delimi = new char[] { ' ' };\n                string[] row = Console.ReadLine().Split(delimi);\n                cource[i] = row;\n            }\n\n\n            //for (int i = 0; i < x; i++)\n            //{\n            //    if (cource[0][i].Equals(\"0\"))\n            //    {\n            //        sum[0][i] = 1;\n            //    }\n            //}\n\n            //for (int i = 0; i < y-1; i++)\n            //{\n            //    for (int j = 0; j < x; j++)\n            //    {\n            //        switch (cource[i][j])\n            //        {\n            //            case \"0\":\n            //                if (!cource[i + 1][j].Equals(\"1\"))\n            //                {\n            //                    sum[i + 1][ j]+=sum[i][j];\n            //                }\n\n            //                if (j < x - 1)\n            //                {\n            //                    if (cource[i + 1][j+1].Equals(\"0\"))\n            //                    {\n            //                        sum[i + 1][j+1] += sum[i][j];\n            //                    }\n            //                }\n\n            //                if (j > 0)\n            //                {\n            //                    if (cource[i + 1][j-1].Equals(\"0\"))\n            //                    {\n            //                        sum[i + 1][j-1] += sum[i][j];\n            //                    }\n            //                }\n\n            //                break;\n            //            case \"2\":\n            //                if (i < y - 2)\n            //                {\n            //                    sum[i + 2][j] += sum[i][ j];\n            //                }\n            //                break;\n            //        }\n            //    }\n            //}\n\n            int total = 0;\n            //for (int i = 0; i < x; i++)\n            //{\n            //    total += sum[y - 1][i];\n            //    total += (cource[y - 2][i].Equals(\"2\")) ? sum[y - 2][i] : 0;\n            //}\n\n            return total.ToString();\n        }\n    }\n    class Program\n    {\n        \n        static void Main(string[] args)\n        {\n            AOJ203 obj = new AOJ203();\n            while (true)\n            {\n                char[] delimi = { ' ' };\n                string[] str = Console.ReadLine().Split(delimi);\n                int n = int.Parse(str[0]);\n                int x = int.Parse(str[1]);\n                if (n == 0 && x == 0) break;\n\n                Console.WriteLine(obj.solve(n,x));\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nnamespace AOJ\n{\n    class AOJ203\n    {\n        string[][] cource;\n        int[,] sum;\n        int x;\n        int y;\n\n        public int solve(int p_x,int p_y)\n        {\n            x = p_x;\n            y = p_y;\n            cource = new string[y][];\n            sum = new int[y,x];\n\n            for (int i = 0; i < y; i++)\n            {\n                string[] row = Console.ReadLine().Split(new char[]{' '});\n                cource[i] = row;\n            }\n\n\n            for (int i = 0; i < x; i++)\n            {\n                if (cource[0][i].Equals(\"0\"))\n                {\n                    sum[0, i] = 1;\n                }\n            }\n\n            for (int i = 0; i < y-1; i++)\n            {\n                for (int j = 0; j < x; j++)\n                {\n                    switch (cource[i][j])\n                    {\n                        case \"0\":\n                            if (!cource[i + 1][j].Equals(\"1\"))\n                            {\n                                sum[i + 1, j]+=sum[i,j];\n                            }\n\n                            if (j < x - 1)\n                            {\n                                if (cource[i + 1][j+1].Equals(\"0\"))\n                                {\n                                    sum[i + 1,j+1] += sum[i,j];\n                                }\n                            }\n\n                            if (j > 0)\n                            {\n                                if (cource[i + 1][j-1].Equals(\"0\"))\n                                {\n                                    sum[i + 1,j-1] += sum[i,j];\n                                }\n                            }\n\n                            break;\n                        case \"2\":\n                            if (i < y - 2)\n                            {\n                                sum[i + 2,j] += sum[i, j];\n                            }\n                            break;\n                    }\n                }\n            }\n\n            int total = 0;\n            for (int i = 0; i < x; i++)\n            {\n                total += sum[y - 1, i];\n                total += (cource[y - 2][i].Equals(\"2\")) ? sum[y - 2, i] : 0;\n            }\n\n            return total;\n        }\n        \n        \n    }\n    class Program\n    {\n        \n        static void Main(string[] args)\n        {\n            AOJ203 obj = new AOJ203();\n            while (true)\n            {\n                char[] delimi = { ' ' };\n                string[] str = Console.ReadLine().Split(delimi);\n                int n = int.Parse(str[0]);\n                int x = int.Parse(str[1]);\n                if (n == 0 && x == 0) break;\n\n                Console.WriteLine(obj.solve(n,x));\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\n\nnamespace Test1 {\n\n    \n\n\n    class ClassMain {\n\n\n        static int[,] grid = new int[0, 0];\n        static int[,] dp = new int[0, 0];\n\n        public static void makeDP() {\n            int X = dp.GetLength(1);\n            int Y = dp.GetLength(0);\n\n            for (int x = 0; x < X; x++) { dp[Y - 1, x] = (grid[Y - 1, x] != 1) ? 1 : 0; }\n            for (int y = Y - 2; y >= 0; y--) {\n                for (int x = 0; x < X; x++) {\n                    if (grid[y, x] == 1) { dp[y, x] = 0; continue; }\n                    else if (grid[y, x] == 2) {\n                        if (y >= Y - 2) { dp[y, x] = 1; }\n                        else { dp[y, x] = dp[y + 2, x]; }\n                        continue;\n                    }\n                    if (grid[y, x] == 0) {\n                        dp[y, x] += dp[y + 1, x];\n                        if (x > 0) {\n                            dp[y, x] += (grid[y+1, x - 1] != 2) ? dp[y+1, x - 1] : 0;\n                        }\n                        if (x < X-1) {\n                            dp[y, x] += (grid[y+1, x + 1] != 2) ? dp[y+1, x + 1] : 0;\n                        }\n                    }\n\n\n                }\n            }\n            for (int i = 0; i < X; i++) {\n                for (int j = 0; j < Y; j++) {\n                 //   Console.Write(dp[i, j] + \",\");\n                }\n                //Console.WriteLine();\n            }\n           \n            \n                \n        }\n\n        public static void Main(String[] args) {\n            string line;\n            while ((line = Console.ReadLine()) != null) {\n                int[] ints = line.Split(' ').Select(int.Parse).ToArray();\n                int X = ints[0], Y = ints[1];\n                if (X == 0) { break; }\n                grid = new int[Y, X];\n                for (int i = 0; i < Y; i++) {\n                    line = Console.ReadLine();\n                    ints = line.Split(' ').Select(int.Parse).ToArray();\n                    for (int j = 0; j < X; j++) {\n                        grid[i, j] = ints[j];\n                    }\n                }\n                //stored.\n                dp = new int[Y, X];\n                makeDP();\n                int sum = 0;\n                for (int i = 0; i < X; i++) {\n                    sum += dp[0, i];\n                }\n                Console.WriteLine(sum);\n\n            }\n        }\n\n        \n    }\n\n\n\n    \n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\nnamespace AOJ\n{\n    class AOJ203\n    {\n        public string solve(int x,int y)\n        {\n            string[][] cource;\n            int[][] sum;\n            cource = new string[y][];\n            sum = new int[y][];\n            for (int i = 0; i < y; i++)\n            {\n                sum[i] = new int[x];\n                for (int j = 0; j < x; j++)\n                {\n                    sum[i][j] = 0;\n                }\n            }\n\n            for (int i = 0; i < y; i++)\n            {\n                char[] delimi = new char[] { ' ' };\n                string[] row = Console.ReadLine().Split(delimi);\n                cource[i] = row;\n            }\n\n            for (int i = 0; i < x; i++)\n            {\n                if (cource[0][i].Equals(\"0\"))\n                {\n                    sum[0][i] = 1;\n                }\n            }\n\n            for (int i = 0; i < y-1; i++)\n            {\n                for (int j = 0; j < x; j++)\n                {\n                    switch (cource[i][j])\n                    {\n                        case \"0\":\n                            if (!cource[i + 1][j].Equals(\"1\"))\n                            {\n                                sum[i + 1][ j]+=sum[i][j];\n                            }\n\n                            if (j < x - 1)\n                            {\n                                if (cource[i + 1][j+1].Equals(\"0\"))\n                                {\n                                    sum[i + 1][j+1] += sum[i][j];\n                                }\n                            }\n\n                            if (j > 0)\n                            {\n                                if (cource[i + 1][j-1].Equals(\"0\"))\n                                {\n                                    sum[i + 1][j-1] += sum[i][j];\n                                }\n                            }\n\n                            break;\n                        case \"2\":\n                            if (i < y - 2 && !cource[i+2][j].Equals(\"1\"))\n                            {\n                                sum[i + 2][j] += sum[i][ j];\n                            }\n                            break;\n                    }\n                }\n            }\n\n            int total = 0;\n            for (int i = 0; i < x; i++)\n            {\n                total += sum[y - 1][i];\n\n                //ジャンプ台分加算\n                if(y>2 && cource[y - 2][i].Equals(\"2\")){\n                    total +=sum[y - 2][i];\n                }\n            }\n\n            return total.ToString();\n        }\n    }\n    class Program\n    {\n        \n        static void Main(string[] args)\n        {\n            AOJ203 obj = new AOJ203();\n            while (true)\n            {\n                char[] delimi = { ' ' };\n                string[] str = Console.ReadLine().Split(delimi);\n                int n = int.Parse(str[0]);\n                int x = int.Parse(str[1]);\n                if (n == 0 && x == 0) break;\n\n                Console.WriteLine(obj.solve(n,x));\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\nnamespace AOJ\n{\n    class AOJ203\n    {\n        string[][] cource;\n        int[][] sum;\n        int x;\n        int y;\n\n        public int solve(int p_x,int p_y)\n        {\n            x = p_x;\n            y = p_y;\n            cource = new string[y][];\n            sum = new int[y][];\n            for (int i = 0; i < y; i++)\n            {\n                sum[i] = new int[x];\n            }\n\n\n            for (int i = 0; i < y; i++)\n            {\n                char[] delimi = new char[] { ' ' };\n                string[] row = Console.ReadLine().Split(delimi);\n                cource[i] = row;\n            }\n\n\n            for (int i = 0; i < x; i++)\n            {\n                if (cource[0][i].Equals(\"0\"))\n                {\n                    sum[0][i] = 1;\n                }\n            }\n\n            for (int i = 0; i < y-1; i++)\n            {\n                for (int j = 0; j < x; j++)\n                {\n                    switch (cource[i][j])\n                    {\n                        case \"0\":\n                            if (!cource[i + 1][j].Equals(\"1\"))\n                            {\n                                sum[i + 1][ j]+=sum[i][j];\n                            }\n\n                            if (j < x - 1)\n                            {\n                                if (cource[i + 1][j+1].Equals(\"0\"))\n                                {\n                                    sum[i + 1][j+1] += sum[i][j];\n                                }\n                            }\n\n                            if (j > 0)\n                            {\n                                if (cource[i + 1][j-1].Equals(\"0\"))\n                                {\n                                    sum[i + 1][j-1] += sum[i][j];\n                                }\n                            }\n\n                            break;\n                        case \"2\":\n                            if (i < y - 2)\n                            {\n                                sum[i + 2][j] += sum[i][ j];\n                            }\n                            break;\n                    }\n                }\n            }\n\n            int total = 0;\n            for (int i = 0; i < x; i++)\n            {\n                total += sum[y - 1][i];\n                total += (cource[y - 2][i].Equals(\"2\")) ? sum[y - 2][i] : 0;\n            }\n\n            return total;\n        }\n        \n        \n    }\n    class Program\n    {\n        \n        static void Main(string[] args)\n        {\n            AOJ203 obj = new AOJ203();\n            while (true)\n            {\n                char[] delimi = { ' ' };\n                string[] str = Console.ReadLine().Split(delimi);\n                int n = int.Parse(str[0]);\n                int x = int.Parse(str[1]);\n                if (n == 0 && x == 0) break;\n\n                Console.WriteLine(obj.solve(n,x));\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\n\nnamespace Test1 {\n\n    \n\n\n    class ClassMain {\n\n\n        static int[,] grid = new int[0, 0];\n        static int[,] dp = new int[0, 0];\n\n        public static void makeDP() {\n            int X = dp.GetLength(1);\n            int Y = dp.GetLength(0);\n\n            for (int x = 0; x < X; x++) { dp[Y - 1, x] = (grid[Y - 1, x] != 1) ? 1 : 0; }\n            for (int y = Y - 2; y >= 0; y--) {\n                for (int x = 0; x < X; x++) {\n                    if (grid[y, x] == 1) { dp[y, x] = 0; continue; }\n                    else if (grid[y, x] == 2) {\n                        if (y >= Y - 2) { dp[y, x] = 1; }\n                        else { dp[y, x] = dp[y + 2, x]; }\n                        continue;\n                    }\n                    if (grid[y, x] == 0) {\n                        dp[y, x] += dp[y + 1, x];\n                        if (x > 0) {\n                            dp[y, x] += (grid[y+1, x - 1] != 2) ? dp[y+1, x - 1] : 0;\n                        }\n                        if (x < X-1) {\n                            dp[y, x] += (grid[y+1, x + 1] != 2) ? dp[y+1, x + 1] : 0;\n                        }\n                    }\n\n\n                }\n            }\n                \n        }\n\n        public static void Main(String[] args) {\n            string line;\n            while ((line = Console.ReadLine()) != null) {\n                int[] ints = line.Split(' ').Select(int.Parse).ToArray();\n                int X = ints[0], Y = ints[1];\n                if (X == 0) { break; }\n                grid = new int[Y, X];\n                for (int i = 0; i < Y; i++) {\n                    line = Console.ReadLine();\n                    ints = line.Split(' ').Select(int.Parse).ToArray();\n                    for (int j = 0; j < X; j++) {\n                        grid[i, j] = ints[j];\n                    }\n                }\n                //stored.\n                dp = new int[Y, X];\n                makeDP();\n                int sum = 0;\n                for (int i = 0; i < X; i++) {\n                    sum += dp[0, i];\n                }\n                Console.WriteLine(sum);\n\n            }\n        }\n\n        \n    }\n\n\n\n    \n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class Hello{\n    public static int SizeX, SizeY;\n    public static int[,] MapInfo;\n    public static int[,] Step;\n    public static void Main(){\n        while(true){\n            string[] X_Y = System.Console.ReadLine().Split(' ');\n            SizeX = int.Parse(X_Y[0]);\n            SizeY = int.Parse(X_Y[1]);\n            if(SizeX == 0 && SizeY == 0) break;\n            \n            MapInfo = new int[SizeY,SizeX];\n            Step = new int[SizeY,SizeX];\n            for(int y = 0; y < SizeY; y++){\n                string[] LineX = System.Console.ReadLine().Split(' ');\n                for(int x = 0; x < SizeX; x++){\n                    MapInfo[y,x] = int.Parse(LineX[x]);\n                    Step[y,x] = Solve(x, y);\n                }\n            }\n            \n            int RoutesSum = 0;\n            for(int x = 0; x < SizeX; x++){\n                RoutesSum += Step[SizeY - 1, x];\n                try{\n                    RoutesSum += MapInfo[SizeY - 2, x] == Consts.JUMP ? Step[SizeY - 2, x] : 0 ;\n                }\n                catch(IndexOutOfRangeException){\n                    continue;\n                }\n            }\n            System.Console.WriteLine(RoutesSum);\n        }\n    }\n    \n    public static int Solve(int x, int y){\n        int PartialRoutesSum = 0;\n        \n        switch(MapInfo[y,x]){\n            case Consts.EMPTY:\n                if(y == 0){ return 1; }\n                else{\n                    for(int PartialX = x - 1; PartialX < x + 2; PartialX++){\n                        try{ PartialRoutesSum += MapInfo[y-1,PartialX] != Consts.JUMP ? Step[y-1,PartialX] : 0; }\n                        catch(IndexOutOfRangeException){\n                            continue;\n                        }\n                    }\n                    try{ PartialRoutesSum += MapInfo[y-2,x] == Consts.JUMP ? Step[y-2,x] : 0; }\n                    catch(IndexOutOfRangeException){}\n                }\n                break;\n            case Consts.JUMP:\n                try{\n                    PartialRoutesSum += MapInfo[y-1,x] == Consts.EMPTY ? Step[y-1,x] : 0;\n                    PartialRoutesSum += MapInfo[y-2,x] == Consts.JUMP ? Step[y-2,x] : 0;\n                }\n                catch(IndexOutOfRangeException){}\n                break;\n            case Consts.OBSTACLE:\n                return 0;\n            default:\n                break;\n        }\n        \n        return PartialRoutesSum;\n    }\n}\n\npublic static class Consts{\n    public const int EMPTY = 0;\n    public const int OBSTACLE = 1;\n    public const int JUMP = 2;\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0203\n{\n    public class Program\n\n    {\n        private static int[,] map;\n        private static int[,] cnt;\n\n        public static void Main(string[] args)\n        {\n            while (true)\n            {\n                int[] xy = RIntAr();\n                if (xy.Sum() == 0) break;\n                Init(xy);\n\n                for (int i = 1 ; i < cnt.GetLength(0) ; i++)\n                {\n                    for (int j = 0 ; j < cnt.GetLength(1) ; j++)\n                    {\n                        switch (map[i, j])\n                        {\n                            case 0:\n                                for (int k = -1 ; k <= 1 ; k++)\n                                {\n                                    if (IsInArea(i - 1, j + k) && map[i - 1, j + k] == 0) cnt[i, j] += cnt[i - 1, j + k];\n                                }\n                                if (IsInArea(i - 2, j) && map[i - 2, j] == 2) cnt[i, j] += cnt[i - 2, j];\n                                break;\n                            case 1:\n                                break;\n                            case 2:\n                                if (IsInArea(i - 1, j) && map[i - 1, j] == 0) cnt[i, j] += cnt[i - 1, j];\n                                if (IsInArea(i - 2, j) && map[i - 2, j] == 2) cnt[i, j] += cnt[i - 2, j];\n                                break;\n                        }\n                    }\n                }\n\n                int sum = 0;\n                for (int i = 0 ; i < cnt.GetLength(1) ; i++)\n                {\n                    sum += cnt[cnt.GetLength(0) - 1, i];\n                    if  (IsInArea(cnt.GetLength(0) - 2, i) && map[cnt.GetLength(0) - 2, i] == 2) sum += cnt[cnt.GetLength(0) - 2, i];\n                }\n                Console.WriteLine(sum);\n            }\n        }\n\n        private static bool IsInArea(int i, int j)\n        {\n            if (0 <= i && i < cnt.GetLength(0) && 0 <= j && j < cnt.GetLength(1)) return true;\n            else return false;\n        }\n\n        private static void Init(int[] xy)\n        {\n            map = new int[xy[1], xy[0]];\n            cnt = new int[xy[1], xy[0]];\n            for (int i = 0 ; i < map.GetLength(0) ; i++)\n            {\n                int[] items = RIntAr();\n                for (int j = 0 ; j < map.GetLength(1) ; j++)\n                {\n                    if (i == 0) cnt[i, j] = items[j] == 0 ? 1 : 0;\n                    map[i, j] = items[j];\n                }\n            }\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RStAr(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RIntAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RLongAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RDoubleAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\nnamespace AOJ\n{\n    class AOJ203\n    {\n        string[][] cource;\n        int[,] sum;\n        int x;\n        int y;\n\n        public int solve(int p_x,int p_y)\n        {\n            x = p_x;\n            y = p_y;\n            cource = new string[y][];\n            sum = new int[y,x];\n\n            for (int i = 0; i < y; i++)\n            {\n                char[] delimi = new char[] { ' ' };\n                string[] row = Console.ReadLine().Split(delimi);\n                cource[i] = row;\n            }\n\n\n            for (int i = 0; i < x; i++)\n            {\n                if (cource[0][i].Equals(\"0\"))\n                {\n                    sum[0, i] = 1;\n                }\n            }\n\n            for (int i = 0; i < y-1; i++)\n            {\n                for (int j = 0; j < x; j++)\n                {\n                    switch (cource[i][j])\n                    {\n                        case \"0\":\n                            if (!cource[i + 1][j].Equals(\"1\"))\n                            {\n                                sum[i + 1, j]+=sum[i,j];\n                            }\n\n                            if (j < x - 1)\n                            {\n                                if (cource[i + 1][j+1].Equals(\"0\"))\n                                {\n                                    sum[i + 1,j+1] += sum[i,j];\n                                }\n                            }\n\n                            if (j > 0)\n                            {\n                                if (cource[i + 1][j-1].Equals(\"0\"))\n                                {\n                                    sum[i + 1,j-1] += sum[i,j];\n                                }\n                            }\n\n                            break;\n                        case \"2\":\n                            if (i < y - 2)\n                            {\n                                sum[i + 2,j] += sum[i, j];\n                            }\n                            break;\n                    }\n                }\n            }\n\n            int total = 0;\n            for (int i = 0; i < x; i++)\n            {\n                total += sum[y - 1, i];\n                total += (cource[y - 2][i].Equals(\"2\")) ? sum[y - 2, i] : 0;\n            }\n\n            return total;\n        }\n        \n        \n    }\n    class Program\n    {\n        \n        static void Main(string[] args)\n        {\n            AOJ203 obj = new AOJ203();\n            while (true)\n            {\n                char[] delimi = { ' ' };\n                string[] str = Console.ReadLine().Split(delimi);\n                int n = int.Parse(str[0]);\n                int x = int.Parse(str[1]);\n                if (n == 0 && x == 0) break;\n\n                Console.WriteLine(obj.solve(n,x));\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\nnamespace AOJ\n{\n    class AOJ203\n    {\n        string[][] cource;\n        int[][] sum;\n        int x;\n        int y;\n\n        public int solve(int p_x,int p_y)\n        {\n            //x = p_x;\n            //y = p_y;\n            //cource = new string[y][];\n            //sum = new int[y][];\n            //for (int i = 0; i < y; i++)\n            //{\n            //    sum[i] = new int[x];\n            //}\n\n\n            //for (int i = 0; i < y; i++)\n            //{\n            //    char[] delimi = new char[] { ' ' };\n            //    string[] row = Console.ReadLine().Split(delimi);\n            //    cource[i] = row;\n            //}\n\n\n            //for (int i = 0; i < x; i++)\n            //{\n            //    if (cource[0][i].Equals(\"0\"))\n            //    {\n            //        sum[0][i] = 1;\n            //    }\n            //}\n\n            //for (int i = 0; i < y-1; i++)\n            //{\n            //    for (int j = 0; j < x; j++)\n            //    {\n            //        switch (cource[i][j])\n            //        {\n            //            case \"0\":\n            //                if (!cource[i + 1][j].Equals(\"1\"))\n            //                {\n            //                    sum[i + 1][ j]+=sum[i][j];\n            //                }\n\n            //                if (j < x - 1)\n            //                {\n            //                    if (cource[i + 1][j+1].Equals(\"0\"))\n            //                    {\n            //                        sum[i + 1][j+1] += sum[i][j];\n            //                    }\n            //                }\n\n            //                if (j > 0)\n            //                {\n            //                    if (cource[i + 1][j-1].Equals(\"0\"))\n            //                    {\n            //                        sum[i + 1][j-1] += sum[i][j];\n            //                    }\n            //                }\n\n            //                break;\n            //            case \"2\":\n            //                if (i < y - 2)\n            //                {\n            //                    sum[i + 2][j] += sum[i][ j];\n            //                }\n            //                break;\n            //        }\n            //    }\n            //}\n\n            int total = 0;\n            //for (int i = 0; i < x; i++)\n            //{\n            //    total += sum[y - 1][i];\n            //    total += (cource[y - 2][i].Equals(\"2\")) ? sum[y - 2][i] : 0;\n            //}\n\n            return total;\n        }\n        \n        \n    }\n    class Program\n    {\n        \n        static void Main(string[] args)\n        {\n            AOJ203 obj = new AOJ203();\n            while (true)\n            {\n                char[] delimi = { ' ' };\n                string[] str = Console.ReadLine().Split(delimi);\n                int n = int.Parse(str[0]);\n                int x = int.Parse(str[1]);\n                if (n == 0 && x == 0) break;\n\n                Console.WriteLine(obj.solve(n,x));\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\nnamespace AOJ\n{\n    class AOJ203\n    {\n        public string solve(int x,int y)\n        {\n            string[][] cource;\n            int[][] sum;\n            cource = new string[y][];\n            sum = new int[y][];\n            for (int i = 0; i < y; i++)\n            {\n                sum[i] = new int[x];\n            }\n\n            for (int i = 0; i < y; i++)\n            {\n                char[] delimi = new char[] { ' ' };\n                string[] row = Console.ReadLine().Split(delimi);\n                cource[i] = row;\n            }\n\n\n            for (int i = 0; i < x; i++)\n            {\n                if (cource[0][i].Equals(\"0\"))\n                {\n                    sum[0][i] = 1;\n                }\n            }\n\n            for (int i = 0; i < y-1; i++)\n            {\n                for (int j = 0; j < x; j++)\n                {\n                    switch (cource[i][j])\n                    {\n                        case \"0\":\n                            if (!cource[i + 1][j].Equals(\"1\"))\n                            {\n                                sum[i + 1][ j]+=sum[i][j];\n                            }\n\n                            if (j < x - 1)\n                            {\n                                if (cource[i + 1][j+1].Equals(\"0\"))\n                                {\n                                    sum[i + 1][j+1] += sum[i][j];\n                                }\n                            }\n\n                            if (j > 0)\n                            {\n                                if (cource[i + 1][j-1].Equals(\"0\"))\n                                {\n                                    sum[i + 1][j-1] += sum[i][j];\n                                }\n                            }\n\n                            break;\n                        case \"2\":\n                            if (i < y - 2)\n                            {\n                                sum[i + 2][j] += sum[i][ j];\n                            }\n                            break;\n                    }\n                }\n            }\n\n            int total = 0;\n            //for (int i = 0; i < x; i++)\n            //{\n            //    total += sum[y - 1][i];\n            //    total += (cource[y - 2][i].Equals(\"2\")) ? sum[y - 2][i] : 0;\n            //}\n\n            return total.ToString();\n        }\n    }\n    class Program\n    {\n        \n        static void Main(string[] args)\n        {\n            AOJ203 obj = new AOJ203();\n            while (true)\n            {\n                char[] delimi = { ' ' };\n                string[] str = Console.ReadLine().Split(delimi);\n                int n = int.Parse(str[0]);\n                int x = int.Parse(str[1]);\n                if (n == 0 && x == 0) break;\n\n                Console.WriteLine(obj.solve(n,x));\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\nnamespace AOJ\n{\n    class AOJ203\n    {\n        public string solve(int x,int y)\n        {\n            string[][] cource;\n            int[][] sum;\n            cource = new string[y][];\n            sum = new int[y][];\n            for (int i = 0; i < y; i++)\n            {\n                sum[i] = new int[x];\n            }\n\n            for (int i = 0; i < y; i++)\n            {\n                char[] delimi = new char[] { ' ' };\n                string[] row = Console.ReadLine().Split(delimi);\n                cource[i] = row;\n            }\n\n\n            for (int i = 0; i < x; i++)\n            {\n                if (cource[0][i].Equals(\"0\"))\n                {\n                    sum[0][i] = 1;\n                }\n            }\n\n            for (int i = 0; i < y-1; i++)\n            {\n                for (int j = 0; j < x; j++)\n                {\n                    switch (cource[i][j])\n                    {\n                        case \"0\":\n                            if (!cource[i + 1][j].Equals(\"1\"))\n                            {\n                                sum[i + 1][ j]+=sum[i][j];\n                            }\n\n                            if (j < x - 1)\n                            {\n                                if (cource[i + 1][j+1].Equals(\"0\"))\n                                {\n                                    sum[i + 1][j+1] += sum[i][j];\n                                }\n                            }\n\n                            if (j > 0)\n                            {\n                                if (cource[i + 1][j-1].Equals(\"0\"))\n                                {\n                                    sum[i + 1][j-1] += sum[i][j];\n                                }\n                            }\n\n                            break;\n                        case \"2\":\n                            if (i < y - 2)\n                            {\n                                sum[i + 2][j] += sum[i][ j];\n                            }\n                            break;\n                    }\n                }\n            }\n\n            int total = 0;\n            for (int i = 0; i < x; i++)\n            {\n                total += sum[y - 1][i];\n                if(y>2 && cource[y - 2][i].Equals(\"2\")){\n                    total +=sum[y - 2][i];\n                }\n            }\n\n            return total.ToString();\n        }\n    }\n    class Program\n    {\n        \n        static void Main(string[] args)\n        {\n            AOJ203 obj = new AOJ203();\n            while (true)\n            {\n                char[] delimi = { ' ' };\n                string[] str = Console.ReadLine().Split(delimi);\n                int n = int.Parse(str[0]);\n                int x = int.Parse(str[1]);\n                if (n == 0 && x == 0) break;\n\n                Console.WriteLine(obj.solve(n,x));\n            }\n        }\n    }\n}"
  },
  {
    "language": "JavaScript",
    "code": "var input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr=input.trim().split(\"\\n\");\nwhile(true){\n   var wh=arr.shift().split(\" \").map(Number);\n   var w=wh[0];\n   var h=wh[1];\n   if(w==0 && h==0)break;\n   var yx=[];\n   for(var i=0;i<h;i++)yx.push(arr.shift().split(\" \").map(Number));\n   var dp=[];\n   for(var i=0;i<h;i++){\n      dp[i]=[];\n      for(var j=0;j<w;j++){\n         dp[i][j]=0;\n      }\n   }\n   for(var i=0;i<h;i++){\n      for(var j=0;j<w;j++){\n         if(i==0 && yx[i][j]==0)dp[i][j]=1;\n         else if(i>=1){\n            var a=(j==0 || yx[i-1][j-1]==2)?0:dp[i-1][j-1];\n            var b=(yx[i-1][j]==2)?0:dp[i-1][j];\n            var c=(j==w-1 ||  yx[i-1][j+1]==2)?0:dp[i-1][j+1];\n            var d=(i>=2 && yx[i-2][j]==2)?dp[i-2][j]:0;\n            if(yx[i][j]==0)dp[i][j]+=a+b+c+d;\n            else if(yx[i][j]==1)dp[i][j]=0;\n            else if(yx[i][j]==2)dp[i][j]+=b+d;\n         }\n      }\n   }\n   var sum=0;\n   for(var i=h-2;i<h;i++){\n      for(var j=0;j<w;j++){\n         if(i==h-2 && yx[i][j]==2)sum+=dp[i][j];\n         if(i==h-1 && (yx[i][j]==0 || yx[i][j]==2))sum+=dp[i][j];\n      }\n   }\n   console.log(sum);\n}"
  },
  {
    "language": "JavaScript",
    "code": "function main() {\n  var\n  i = 0, j, y, x,\n  xy, cells, answers = {},\n  dummy = [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2];\n  for (;;) {\n    xy = input[i++].split(' ').map(parseFloat);\n    cells = [];\n    if (xy[0] === 0 && xy[1] === 0) break;\n    \n    for (j = 0; j < xy[1]; j++) {\n      cells.push(input[i++].split(' ').map(parseFloat));\n    }\n    cells.push(dummy);\n    \n    answer = 0;\n    answers = {};\n    for (x = 0; x < xy[0]; x++) answers[[x, 0]] = cells[0][x] === 0 ? 1 : 0;\n    for (y = 0; y < xy[1]; y++) {\n      for (x = 0; x < xy[0]; x++) {\n        answers[[x, y]] = answers[[x, y]] || 0;\n        switch (cells[y][x]) {\n        case 0:\n          if (cells[y + 1][x - 1] !== 2) answers[[x - 1, y + 1]] = (answers[[x - 1, y + 1]] || 0) + answers[[x, y]];\n          answers[[x, y + 1]] = (answers[[x, y + 1]] || 0) + answers[[x, y]];\n          if (cells[y + 1][x + 1] !== 2) answers[[x + 1, y + 1]] = (answers[[x + 1, y + 1]] || 0) + answers[[x, y]];\n          break;\n        case 1:\n          break;\n        case 2:\n          answers[[x, y + 2]] = (answers[[x, y + 2]] || 0) + answers[[x, y]];\n          break;\n        }\n      }\n    }\n\n//    show(xy, answers);\n\n    for (y = xy[1]; y <= xy[1] + 1; y++) {\n      for(x = 0; x < xy[0]; x++) {\n        answer += answers[[x, y]] || 0;\n      }\n    }\n\n    console.log(answer);\n  }\n}\n\n\nfunction show(xy, answers) {\n  var\n  x, y, line;\n  for (y = 0; y <= xy[1]; y++) {\n    line = [];\n    for (x = 0; x < xy[0]; x++) {\n      line.push(answers[[x, y]] || 0);\n    }\n    console.log(line.join(' '));\n  }\n}\n\n\nvar\ninput = '';\n\nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(chunk) {\n  input += chunk;\n});\nprocess.stdin.on('end', function() {\n  input = input.split('\\n');\n  main();\n});"
  },
  {
    "language": "JavaScript",
    "code": "var input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr=input.trim().split(\"\\n\");\nwhile(true){\n   var wh=arr.shift().split(\" \").map(Number);\n   var w=wh[0];\n   var h=wh[1];\n   if(w==0 && h==0)break;\n   var yx=[];\n   for(var i=0;i<h;i++)yx.push(arr.shift().split(\" \").map(Number));\n   var dp=[];\n   for(var i=0;i<h;i++){\n      dp[i]=[];\n      for(var j=0;j<w;j++){\n         dp[i][j]=0;\n      }\n   }\n   for(var i=0;i<h;i++){\n      for(var j=0;j<w;j++){\n         if(i==0 && yx[i][j]==0)dp[i][j]=1;\n         else if(i>=1){\n            var a=(j==0 || yx[i-1][j-1]==2)?0:dp[i-1][j-1];\n            var b=(yx[i-1][j]==2)?0:dp[i-1][j];\n            var c=(j==w-1 ||  yx[i-1][j+1]==2)?0:dp[i-1][j+1];\n            var d=(i>=2 && yx[i-2][j]==2)?dp[i-2][j]:0;\n            if(yx[i][j]==0)dp[i][j]+=a+b+c+d;\n            else if(yx[i][j]==1)dp[i][j]=0;\n            else if(yx[i][j]==2)dp[i][j]+=b+d;\n         }\n      }\n   }\n   var sum=0;\n   for(var i=h-2;i<h;i++){\n      for(var j=0;j<w;j++){\n         if(h>=2 && i==h-2 && yx[i][j]==2)sum+=dp[i][j];\n         if(h>=1 && i==h-1 && (yx[i][j]==0 || yx[i][j]==2))sum+=dp[i][j];\n      }\n   }\n   console.log(sum);\n}"
  },
  {
    "language": "JavaScript",
    "code": "var input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr=input.trim().split(\"\\n\");\nwhile(true){\n   var wh=arr.shift().split(\" \").map(Number);\n   var w=wh[0];\n   var h=wh[1];\n   if(w==0 && h==0)break;\n   var yx=[];\n   for(var i=0;i<h;i++)yx.push(arr.shift().split(\" \").map(Number));\n   var dp=[];\n   for(var i=0;i<h;i++){\n      dp[i]=[];\n      for(var j=0;j<w;j++){\n         dp[i][j]=0;\n      }\n   }\n   for(var i=0;i<h;i++){\n      for(var j=0;j<w;j++){\n         if(i==0 && yx[i][j]==0)dp[i][j]=1;\n         else if(i>=1){\n            var a=(j==0 || yx[i-1][j-1]==2)?0:dp[i-1][j-1];\n            var b=(yx[i-1][j]==2)?0:dp[i-1][j];\n            var c=(j==w-1 ||  yx[i-1][j+1]==2)?0:dp[i-1][j+1];\n            var d=(i>=2 && yx[i-2][j]==2)?dp[i-2][j]:0;\n            if(yx[i][j]==0)dp[i][j]+=a+b+c+d;\n            else if(yx[i][j]==1)dp[i][j]=0;\n            else if(yx[i][j]==2)dp[i][j]+=b+d;\n         }\n      }\n   }\n   var sum=0;\n   for(var i=h-2;i<h;i++){\n      for(var j=0;j<w;j++){\n         if(i==h-2 && yx[i][j]==2)sum+=dp[i][j];\n         if(i==h-1 && (yx[i][j]==0 || yx[i][j]==2))sum+=dp[i][j];\n      }\n   }\n   console.log(sum);\n}"
  },
  {
    "language": "JavaScript",
    "code": "function main() {\n  var\n  i = 0, j, y, x,\n  xy, cells, answers = {},\n  dummy = [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2];\n  for (;;) {\n    xy = input[i++].split(' ').map(parseFloat);\n    cells = [];\n    if (xy[0] === 0 && xy[1] === 0) break;\n    \n    for (j = 0; j < xy[1]; j++) {\n      cells.push(input[i++].split(' ').map(parseFloat));\n    }\n    \n    answers = {};\n    for (x = 0; x < xy[0]; x++) answers[[x, 0]] = 1;\n    for (y = 0; y < xy[1]; y++) {\n      for (x = 0; x < xy[0]; x++) {\n        answers[[x, y]] = answers[[x, y]] || 0;\n        switch (cells[y][x]) {\n        case 0:\n          if ((cells[y + 1] || dummy)[x - 1] !== 2) answers[[x - 1, y + 1]] = (answers[[x - 1, y + 1]] || 0) + answers[[x, y]];\n          answers[[x, y + 1]] = (answers[[x, y + 1]] || 0) + answers[[x, y]];\n          if ((cells[y + 1] || dummy)[x + 1] !== 2) answers[[x + 1, y + 1]] = (answers[[x + 1, y + 1]] || 0) + answers[[x, y]];\n          break;\n        case 1:\n          break;\n        case 2:\n          answers[[x, y + 2]] = (answers[[x, y + 2]] || 0) + answers[[x, y]];\n          break;\n        }\n      }\n    }\n    \n//    show(xy, answers);\n    \n    answer = 0;\n    y = xy[1];\n    for(x = 0; x < xy[0]; x++) answer += answers[[x, y]] || 0;\n    \n    console.log(answer);\n  }\n}\n\n/*\nfunction show(xy, answers) {\n  var\n  x, y, line;\n  for (y = 0; y <= xy[1]; y++) {\n    line = [];\n    for (x = 0; x < xy[0]; x++) {\n      line.push(answers[[x, y]] || 0);\n    }\n    console.log(line.join(' '));\n  }\n}\n*/\n\nvar\ninput = '';\n\nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(chunk) {\n  input += chunk;\n});\nprocess.stdin.on('end', function() {\n  input = input.split('\\n');\n  main();\n});"
  },
  {
    "language": "JavaScript",
    "code": "function bomb(y,x){\n   if(yx[y][x]==1)return;\n   else if(yx[y][x]==2){\n      var Y=y+2;\n      var X=x;\n      if(Y>=h){cnt++;return;}\n      bomb(Y,X);\n   }\n   else if(yx[y][x]==0){\n      var dx=[-1,0,1];\n      for(var i=0;i<dx.length;i++){\n         var Y=y+1;\n         var X=x+dx[i];\n         if(X<0 || X>=w)continue;\n         if(Y>=h){cnt++;return;}\n         if(yx[Y][X]==2 && dx[i]!=0)continue;\n         bomb(Y,X);\n      }\n   }\n}\nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr=input.trim().split(\"\\n\");\nwhile(true){\n   var wh=arr.shift().split(\" \").map(Number);\n   var w=wh[0];\n   var h=wh[1];\n   if(w==0 && h==0)break;\n   var yx=[];\n   for(var i=0;i<h;i++)yx.push(arr.shift().split(\" \").map(Number));\n   var cnt=0;\n   for(var i=0;i<w;i++){\n      bomb(0,i);\n   }\n   console.log(cnt);\n}"
  },
  {
    "language": "JavaScript",
    "code": "function main() {\n  var\n  i = 0, j, y, x,\n  xy, cells, answers = {},\n  dummy = [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2];\n  for (;;) {\n    xy = input[i++].split(' ').map(parseFloat);\n    cells = [];\n    if (xy[0] === 0 && xy[1] === 0) break;\n    \n    for (j = 0; j < xy[1]; j++) {\n      cells.push(input[i++].split(' ').map(parseFloat));\n    }\n    cells.push(dummy);\n    \n    answer = 0;\n    answers = {};\n    for (x = 0; x < xy[0]; x++) answers[[x, 0]] = cells[0][x] === 0 ? 1 : 0;\n    for (y = 0; y < xy[1]; y++) {\n      for (x = 0; x < xy[0]; x++) {\n        answers[[x, y]] = answers[[x, y]] || 0;\n        switch (cells[y][x]) {\n        case 0:\n          if (cells[y + 1][x - 1] !== 2) answers[[x - 1, y + 1]] = (answers[[x - 1, y + 1]] || 0) + answers[[x, y]];\n          answers[[x, y + 1]] = (answers[[x, y + 1]] || 0) + answers[[x, y]];\n          if (cells[y + 1][x + 1] !== 2) answers[[x + 1, y + 1]] = (answers[[x + 1, y + 1]] || 0) + answers[[x, y]];\n          break;\n        case 1:\n          break;\n        case 2:\n          answers[[x, y + 2]] = (answers[[x, y + 2]] || 0) + answers[[x, y]];\n          break;\n        }\n      }\n    }\n\n//    show(xy, answers);\n\n    for (y = xy[1]; y <= xy[1] + 1; y++) {\n      for(x = 0; x < xy[0]; x++) {\n        answer += answers[[x, y]] || 0;\n      }\n    }\n\n    console.log(answer);\n  }\n}\n\n\nfunction show(xy, answers) {\n  var\n  x, y, line;\n  for (y = 0; y <= xy[1]; y++) {\n    line = [];\n    for (x = 0; x < xy[0]; x++) {\n      line.push(answers[[x, y]] || 0);\n    }\n    console.log(line.join(' '));\n  }\n}\n\n\nvar\ninput = '';\n\nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(chunk) {\n  input += chunk;\n});\nprocess.stdin.on('end', function() {\n  input = input.split('\\n');\n  main();\n});"
  },
  {
    "language": "JavaScript",
    "code": "var input = require('fs').readFileSync('/dev/stdin', 'utf8');\nreturn;\nvar arr=input.trim().split(\"\\n\");\nwhile(true){\n   var wh=arr.shift().split(\" \").map(Number);\n   var w=wh[0];\n   var h=wh[1];\n   if(w==0 && h==0)break;\n   var yx=[];\n   for(var i=0;i<h;i++)yx.push(arr.shift().split(\" \").map(Number));\n   var dp=[];\n   for(var i=0;i<h;i++){\n      dp[i]=[];\n      for(var j=0;j<w;j++){\n         dp[i][j]=0;\n      }\n   }\n   for(var i=0;i<h;i++){\n      for(var j=0;j<w;j++){\n         if(i==0 && yx[i][j]==0)dp[i][j]=1;\n         else if(i>=1){\n            var a=(j==0 || yx[i-1][j-1]==2)?0:dp[i-1][j-1];\n            var b=(yx[i-1][j]==2)?0:dp[i-1][j];\n            var c=(j==w-1 ||  yx[i-1][j+1]==2)?0:dp[i-1][j+1];\n            var d=(i>=2 && yx[i-2][j]==2)?dp[i-2][j]:0;\n            if(yx[i][j]==0)dp[i][j]+=a+b+c+d;\n            else if(yx[i][j]==1)dp[i][j]=0;\n            else if(yx[i][j]==2)dp[i][j]+=b+d;\n         }\n      }\n   }\n   var sum=0;\n   for(var i=h-2;i<h;i++){\n      for(var j=0;j<w;j++){\n         if(i==h-2 && yx[i][j]==2)sum+=dp[i][j];\n         if(i==h-1 && (yx[i][j]==0 || yx[i][j]==2))sum+=dp[i][j];\n      }\n   }\n   console.log(sum);\n}"
  },
  {
    "language": "JavaScript",
    "code": "var input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr=input.trim().split(\"\\n\");\nwhile(true){\n   var wh=arr.shift().split(\" \").map(Number);\n   var w=wh[0];\n   var h=wh[1];\n   if(w==0 && h==0)break;\n   var yx=[];\n   for(var i=0;i<h;i++)yx.push(arr.shift().split(\" \").map(Number));\n   var dp=[];\n   for(var i=0;i<h;i++){\n      dp[i]=[];\n      for(var j=0;j<w;j++){\n         dp[i][j]=0;\n      }\n   }\n   for(var i=0;i<h;i++){\n      for(var j=0;j<w;j++){\n         if(i==0 && yx[i][j]==0)dp[i][j]=1;\n         else if(i>=1){\n            var a=(j==0 || yx[i-1][j-1]==2)?0:dp[i-1][j-1];\n            var b=(yx[i-1][j]==2)?0:dp[i-1][j];\n            var c=(j==w-1 ||  yx[i-1][j+1]==2)?0:dp[i-1][j+1];\n            var d=(i>=2 && yx[i-2][j]==2)?dp[i-2][j]:0;\n            if(yx[i][j]==0)dp[i][j]+=a+b+c+d;\n            else if(yx[i][j]==1)dp[i][j]=0;\n            else if(yx[i][j]==2)dp[i][j]+=b+d;\n         }\n      }\n   }\n   var sum=0;\n   for(var i=h-2;i<h;i++){\n      for(var j=0;j<w;j++){\n         if(i==h-2 && yx[i][j]==2)sum+=dp[i][j];\n         if(i==h-1 && (yx[i][j]==0 || yx[i][j]==2))sum+=dp[i][j];\n      }\n   }\n   console.log(sum);\n}"
  },
  {
    "language": "JavaScript",
    "code": "var input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr=input.trim().split(\"\\n\");\nwhile(true){\n   var wh=arr.shift().split(\" \").map(Number);\n   var w=wh[0];\n   var h=wh[1];\n   if(w==0 && h==0)break;\n   var yx=[];\n   for(var i=0;i<h;i++)yx.push(arr.shift().split(\" \").map(Number));\n   var dp=[];\n   for(var i=0;i<h;i++){\n      dp[i]=[];\n      for(var j=0;j<w;j++){\n         dp[i][j]=0;\n      }\n   }\n   for(var i=0;i<h;i++){\n      for(var j=0;j<w;j++){\n         if(i==0 && yx[i][j]==0)dp[i][j]=1;\n         else if(i>=1){\n            var a=(j==0 || yx[i-1][j-1]==2)?0:dp[i-1][j-1];\n            var b=(yx[i-1][j]==2)?0:dp[i-1][j];\n            var c=(j==w-1 ||  yx[i-1][j+1]==2)?0:dp[i-1][j+1];\n            var d=(i>=2 && yx[i-2][j]==2)?dp[i-2][j]:0;\n            if(yx[i][j]==0)dp[i][j]+=a+b+c+d;\n            else if(yx[i][j]==1)dp[i][j]=0;\n            else if(yx[i][j]==2)dp[i][j]+=b+d;\n         }\n      }\n   }\n   var sum=0;\n   for(var i=h-2;i<h;i++){\n      for(var j=0;j<w;j++){\n         if(i==h-2 && yx[i][j]==2)sum+=dp[i][j];\n         //if(i==h-1 && (yx[i][j]==0 || yx[i][j]==2))sum+=dp[i][j];\n      }\n   }\n   console.log(sum);\n}"
  },
  {
    "language": "JavaScript",
    "code": "console.log(\"111\");"
  },
  {
    "language": "Ruby",
    "code": "### subroutines\n\ndef count_rt(x0, y0)\n  return 1 if y0 >= $y\n  return $rtcache[y0][x0] if ! $rtcache[y0][x0].nil?\n\n  count = 0\n  y1 = y0 + 1\n\n  if $flds[y0][x0] == 0\n    count += count_rt(x0 - 1, y1) if x0 > 0 && $flds[y1][x0 - 1] == 0\n    count += count_rt(x0, y1)\n    count += count_rt(x0 + 1, y1) if x0 < $x - 1 && $flds[y1][x0 + 1] == 0\n  else\n    count += count_rt(x0, y0 + 2)\n  end\n\n  $rtcache[y0][x0] = count\nend\n\n### main\n\nwhile true\n  $x, $y = gets.strip.split(' ').map{|s| s.to_i}\n  break if $x == 0 && $y == 0\n\n  $flds = []\n  $y.times.each do\n    hl = gets.strip.split(' ').map{|s| s.to_i}\n    $flds << hl\n  end\n\n  $rtcache = $y.times.map{[nil] * $x}\n  $rtcache << [1] * $x\n\n  for y0 in (0...$y)\n    for x0 in (0...$x)\n      if $flds[y0][x0] == 1\n        $rtcache[y0][x0] = 0\n      elsif y0 == $y - 1\n        $rtcache[y0][x0] = 1\n      end\n    end\n  end\n\n  count = 0\n  for x0 in (0...$x)\n    count += count_rt(x0, 0)\n  end\n  puts count\nend"
  },
  {
    "language": "Ruby",
    "code": "M = 17\nm = Array.new(M).map{Array.new(M,0)}\nmemo = Array.new(M).map{Array.new(M,0)}\nwhile true do\n  x, y = gets.chomp.split().map(&:to_i)\n  if x==0 && y==0 then\n    break\n  end\n  for i in 0..y+1 do\n    for j in 0..x+1 do\n      m[i][j] = 1\n      memo[i][j] = 0\n    end\n  end\n  for i in 1..x do\n    memo[1][i] = 1\n  end\n  for i in 1..y do\n    m[i] = [1] + gets.chomp.split().map(&:to_i) + [1]\n  end\n  ans = 0\n  for i in 2..y do\n    for j in 1..x do\n      if m[i][j]!=1 then\n        if m[i][j]==0 then\n          if m[i-1][j-1]!=2 then\n            memo[i][j] += memo[i-1][j-1]\n          end\n          if m[i-1][j+1]!=2 then\n            memo[i][j] += memo[i-1][j+1]\n          end\n        end\n        if m[i-1][j]!=2 then\n          memo[i][j] += memo[i-1][j]\n        end\n        if m[i-2][j]==2 then\n          memo[i][j] += memo[i-2][j]\n        end\n      end\n    end\n  end\n  for i in 1..x do\n    ans += memo[y][i]\n    if m[y-1][i]==2 then\n      ans += memo[y-1][i]\n    end\n  end\n  puts ans\nend"
  },
  {
    "language": "Ruby",
    "code": "loop do\n    h, w = gets.split.map(&:to_i)\n    break if h == 0\n    a = (1..h).map { gets.split.map(&:to_i) }\n    a << Array.new(w, 0)\n    t = (1..h+1).map { Array.new(w, 0) }\n    (0..w-1).each do |j|\n        t[0][j] = (a[0][j] == 0 ? 1 : 0)\n    end\n    (0..h-1).each do |i|\n        (0..w-1).each do |j|\n            next if t[i][j] == 0\n            if a[i][j] == 2\n                t[i+2][j] += t[i][j] if a[i+2][j] != 1\n            elsif i == h - 1\n                t[i+1][j] += t[i][j]\n            else\n                t[i+1][j-1] += t[i][j] if j > 0 && a[i+1][j-1] == 0\n                t[i+1][j+1] += t[i][j] if j < w-1 && a[i+1][j+1] == 0\n                t[i+1][j] += t[i][j] if a[i+1][j] != 1\n            end\n        end\n    end\n    puts t[-1].inject(:+)\nend\n\n"
  },
  {
    "language": "Ruby",
    "code": "loop do\n  w, h = gets.split.map(&:to_i)\n  break if w + h == 0\n  \n  field = h.times.map {gets.split.map(&:to_i)}\n  dp = Array.new(h) {Array.new(w, 0)}\n  w.times {|x| dp[h - 1][x] = 1 if field[h - 1][x] != 1}\n  \n  (h - 2).downto(0) do |y|\n    w.times do |x|\n      case field[y][x]\n      when 2\n        if y + 2 == h\n          dp[y][x] = 1\n        else\n          dp[y][x] = dp[y + 2][x]\n        end\n      when 0\n        s = 0\n        [-1, 0, 1].each do |dx|\n          x1 = x + dx\n          next if x1 < 0 || x1 == w\n          next if dx.nonzero? && field[y + 1][x1] == 2\n          s += dp[y + 1][x1]\n        end\n        dp[y][x] = s\n      end\n    end\n  end\n  \n  puts dp[0].sum\nend\n\n"
  },
  {
    "language": "Ruby",
    "code": "loop do\n    w, h = gets.split.map(&:to_i)\n    break if h == 0\n    a = (1..h).map { gets.split.map(&:to_i) }\n    a << Array.new(w, 0)\n    t = (1..h+1).map { Array.new(w, 0) }\n    (0..w-1).each do |j|\n        t[0][j] = (a[0][j] == 0 ? 1 : 0)\n    end\n    (0..h-1).each do |i|\n        (0..w-1).each do |j|\n            next if t[i][j] == 0\n            if a[i][j] == 2\n                t[i+2][j] += t[i][j] if a[i+2][j] != 1\n            elsif i == h - 1\n                t[i+1][j] += t[i][j]\n            else\n                t[i+1][j-1] += t[i][j] if j > 0 && a[i+1][j-1] == 0\n                t[i+1][j+1] += t[i][j] if j < w-1 && a[i+1][j+1] == 0\n                t[i+1][j] += t[i][j] if a[i+1][j] != 1\n            end\n        end\n    end\n    puts t[-1].inject(:+)\nend\n\n"
  },
  {
    "language": "Ruby",
    "code": "while true\n  x, y = gets.split.map(&:to_i)\n  break if x + y == 0\n  \n  in_course = -> (a, b) { -1 < a && a < x && -1 < b && b < y }\n  \n  course = Array.new(y) { gets.split.map(&:to_i) } << Array.new(x) { 3 } << Array.new(x) { 3 }\n  routes = Array.new(y + 2) { Array.new(x) { 0 } }\n  direction = [[-1, -1], [-1, 0], [-1, 1]]\n  \n  course.each_with_index do |row, j|\n    row.each_with_index do |grid, i|\n      if j == 0\n        routes[j][i] = grid == 0 ? 1 : 0\n      else\n        case grid\n        when 0\n          direction.each do |dir|\n            b_y, b_x = j + dir[0], i + dir[1]\n            routes[j][i] += routes[b_y][b_x] if in_course[b_x, b_y] && course[b_y][b_x] == 0\n          end\n        when 1\n        when 2\n          routes[j][i] += routes[j - 1][i]\n          routes[j + 2][i] += routes[j][i]\n        when 3\n          routes[j][i] += routes[j - 1][i]\n        end\n      end\n    end\n  end\n  \n  puts routes.last.reduce(:+)\nend"
  },
  {
    "language": "Ruby",
    "code": "def g;$z=gets.split.map &:to_i;end\ndef f x,y\na=g<<1;b,c,d=y<2?[a.map{1}]*3:f(x,y-1)\n[a,(0..x-1).map{|i|a[i]>1?d[i]:a[i]>0?0:c[i]+(b[i-1]<1?c[i-1]:0)+(b[i+1]<1?c[i+1]:0)}<<0,c]end\np f(*$z)[1].inject(:+)while g[0]>0"
  },
  {
    "language": "Ruby",
    "code": "loop do\n    w, h = gets.split.map(&:to_i)\n    break if h == 0\n    a = (1..h).map { gets.split.map(&:to_i) }\n    a << Array.new(w, 0)\n    t = (1..h+1).map { Array.new(w, 0) }\n    (0..w-1).each do |j|\n        t[0][j] = (a[0][j] == 0 ? 1 : 0)\n    end\n    (0..h-1).each do |i|\n        (0..w-1).each do |j|\n            next if t[i][j] == 0\n            if a[i][j] == 2\n                t[i+2][j] += t[i][j] if a[i+2][j] != 1\n            elsif i == h - 1\n                t[i+1][j] += t[i][j]\n            else\n                t[i+1][j-1] += t[i][j] if j > 0 && a[i+1][j-1] == 0\n                t[i+1][j+1] += t[i][j] if j < w-1 && a[i+1][j+1] == 0\n                t[i+1][j] += t[i][j] if a[i+1][j] != 1\n            end\n        end\n    end\n    puts t[-1].inject(:+)\nend\n\n"
  },
  {
    "language": "Ruby",
    "code": "M = 17\nm = Array.new(M).map{Array.new(M,0)}\nmemo = Array.new(M).map{Array.new(M,0)}\nwhile true do\n  x, y = gets.chomp.split().map(&:to_i)\n  if x==0 && y==0 then\n    break\n  end\n  for i in 0..y+1 do\n    for j in 0..x+1 do\n      m[i][j] = 1\n      memo[i][j] = 0\n    end\n  end\n  for i in 1..y do\n    m[i] = [1] + gets.chomp.split().map(&:to_i) + [1]\n  end\n  for i in 1..x do\n    if m[1][i]==0 then\n      memo[1][i] = 1\n    end\n  end\n  ans = 0\n  for i in 2..y do\n    for j in 1..x do\n      if m[i][j]!=1 then\n        if m[i][j]==0 then\n          if m[i-1][j-1]!=2 then\n            memo[i][j] += memo[i-1][j-1]\n          end\n          if m[i-1][j+1]!=2 then\n            memo[i][j] += memo[i-1][j+1]\n          end\n        end\n        if m[i-1][j]!=2 then\n          memo[i][j] += memo[i-1][j]\n        end\n        if m[i-2][j]==2 then\n          memo[i][j] += memo[i-2][j]\n        end\n      end\n    end\n  end\n  for i in 1..x do\n    ans += memo[y][i]\n    if m[y-1][i]==2 then\n      ans += memo[y-1][i]\n    end\n  end\n  puts ans\nend"
  },
  {
    "language": "Ruby",
    "code": "loop do\n    h, w = gets.split.map(&:to_i)\n    break if h == 0\n    a = (1..h).map { gets.split.map(&:to_i) }\n    a << Array.new(w, 0)\n    t = (1..h+1).map { Array.new(w, 0) }\n    (0..w-1).each do |j|\n        t[0][j] = (a[0][j] == 0 ? 1 : 0)\n    end\n    (0..h-1).each do |i|\n        (0..w-1).each do |j|\n            next if t[i][j] == 0\n            if a[i][j] == 2\n                t[i+2][j] += t[i][j] if a[i+2][j] != 1\n            elsif i == h - 1\n                t[i+1][j] += t[i][j]\n            else\n                t[i+1][j-1] += t[i][j] if j > 0 && a[i+1][j-1] == 0\n                t[i+1][j+1] += t[i][j] if j < w-1 && a[i+1][j+1] == 0\n                t[i+1][j] += t[i][j] if a[i+1][j] != 1\n            end\n        end\n    end\n    puts t[-1].inject(:+)\nend\n\n"
  },
  {
    "language": "Ruby",
    "code": "loop do\n    w, h = gets.split.map(&:to_i)\n    break if w == 0\n    a = (1..h).map { gets.split.map(&:to_i) }\n    a << Array.new(w, 0)\n    t = (1..h+1).map { Array.new(w, 0) }\n    (0..w-1).each do |j|\n        t[0][j] = (a[0][j] == 0 ? 1 : 0)\n    end\n    (0..h-1).each do |i|\n        (0..w-1).each do |j|\n            # next if t[i][j] == 0\n            if i == h - 1\n                t[i+1][j] += t[i][j]\n            elsif a[i][j] == 2\n                t[i+2][j] += t[i][j] if a[i+2][j] != 1\n            else\n                t[i+1][j-1] += t[i][j] if j > 0 && a[i+1][j-1] == 0\n                t[i+1][j+1] += t[i][j] if j < w-1 && a[i+1][j+1] == 0\n                t[i+1][j] += t[i][j] if a[i+1][j] != 1\n            end\n        end\n    end\n    puts t[-1].inject(:+)\nend\n\n"
  },
  {
    "language": "Ruby",
    "code": "while true\n  x, y = gets.split.map(&:to_i)\n  break if x + y == 0\n  \n  in_course = -> (a, b) { -1 < a && a < x && -1 < b && b < y }\n  \n  course = Array.new(y) { gets.split.map(&:to_i) } << Array.new(x) { 3 }\n  routes = Array.new(y + 1) { Array.new(x) { 0 } }\n  direction = [[-1, -1], [-1, 0], [-1, 1]]\n  \n  course.each_with_index do |row, j|\n    row.each_with_index do |grid, i|\n      if j == 0\n        routes[j][i] = grid == 0 ? 1 : 0\n      else\n        case grid\n        when 0\n          direction.each do |dir|\n            b_y, b_x = j + dir[0], i + dir[1]\n            routes[j][i] += routes[b_y][b_x] if in_course[b_x, b_y] && course[b_y][b_x] == 0\n          end\n        when 1\n        when 2\n          routes[j][i] += routes[j - 1][i]\n          routes[j + 2][i] += routes[j][i]\n        when 3\n          routes[j][i] += routes[j - 1][i]\n        end\n      end\n    end\n  end\n  \n  puts routes.last.reduce(:+)\nend"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n\t)\n\nvar scanner = bufio.NewScanner(os.Stdin)\n\nfunc main() {\n\tfor scanner.Scan() {\n\t\tbuf := strings.Split(scanner.Text(), \" \")\n\t\tX, _ := strconv.Atoi(buf[0])\n\t\tY, _ := strconv.Atoi(buf[1])\n\t\tif X == 0 && Y == 0 {\n\t\t\tbreak\n\t\t}\n\t\ttbl := make([][]int, Y+2)\n\t\tfield := make([][]int, Y+2)\n\t\tfor i := range field {\n\t\t\tfield[i] = make([]int, X+2)\n\t\t\ttbl[i] = make([]int, X+2)\n\t\t\tfor j := range field[i] {\n\t\t\t\tfield[i][j] = 2\n\t\t\t\ttbl[i][j] = 0\n\t\t\t}\n\t\t}\n\t\tbuf_ := make([][]string, Y)\n\t\tfor i := range buf_ {\n\t\t\tscanner.Scan()\n\t\t\tbuf_[i] = strings.Split(scanner.Text(), \" \")\n\t\t}\n\t\tfor i := 1; i <= Y; i++ {\n\t\t\tfor j := 1; j <= X; j++ {\n\t\t\t\tfield[i][j], _ = strconv.Atoi(buf_[i-1][j-1])\n\t\t\t\tswitch field[i][j] {\n\t\t\t\tcase 0:\n\t\t\t\t\tif i == 1 {\n\t\t\t\t\t\ttbl[i][j] = 1 // スタートy=1\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif field[i-1][j-1] != 2 {\n\t\t\t\t\t\t\ttbl[i][j] += tbl[i-1][j-1] // 左上からやってくる\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif field[i-1][j] != 2 {\n\t\t\t\t\t\t\ttbl[i][j] += tbl[i-1][j] // 真上からやってくる\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif field[i-1][j+1] != 2 {\n\t\t\t\t\t\t\ttbl[i][j] += tbl[i-1][j+1] // 右上からやってくる\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif field[i-2][j] == 2 {\n\t\t\t\t\t\t\ttbl[i][j] += tbl[i-2][j] // ジャンプしてくる\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tcase 1:\n\t\t\t\t\ttbl[i][j] = 0 // 障害物あり\n\t\t\t\tcase 2:\n\t\t\t\t\tif field[i-1][j] != 2 {\n\t\t\t\t\t\ttbl[i][j] += tbl[i-1][j] // 真上からくる\n\t\t\t\t\t}\n\t\t\t\t\tif field[i-2][j] == 2 {\n\t\t\t\t\t\ttbl[i][j] += tbl[i-2][j] // ジャンプ台からジャンプしてくる\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsum := 0\n\t\tfor i := 1; i <= X; i++ {\n\t\t\tsum += tbl[Y][i] // とびこさないでゴール\n\t\t\tif field[Y-1][i] == 2 {\n\t\t\t\tsum += tbl[Y-1][i] // 飛び越してゴール\n\t\t\t}\n\t\t}\n\t\tfmt.Println(sum)\n\t}\n}\n\n"
  },
  {
    "language": "OCaml",
    "code": "open Scanf\n\nlet space_pattern = Str.regexp \" \"\n\nlet split_columns line = Str.split space_pattern line\n\ntype square = Pass | NonPass | Jump | Terminal\n\nlet previous_positions grid (x, y) =\n  let rec filter_positions acc = function\n    | [] -> acc\n    | ((x, y) as p, s) :: ps when grid.(y).(x) = s ->\n       filter_positions (p :: acc) ps\n    | _ :: ps -> filter_positions acc ps in\n  match y, grid.(y).(x) with\n  | 0, _ -> []\n  | _, NonPass -> []\n  | 1, Jump -> filter_positions [] [ ((x, y - 1), Pass) ]\n  | _, Jump | _, Terminal ->\n     filter_positions [] [ ((x, y - 1), Pass); ((x, y - 2), Jump) ]\n  | 1, Pass ->\n     filter_positions [] [ ((x - 1, y - 1), Pass);\n                           ((x    , y - 1), Pass);\n                           ((x + 1, y - 1), Pass) ]\n  | _, Pass ->\n     filter_positions [] [ ((x - 1, y - 1), Pass);\n                           ((x    , y - 1), Pass);\n                           ((x + 1, y - 1), Pass);\n                           ((x    , y - 2), Jump) ]\n\nlet square_of_int = function\n  | 0 -> Pass\n  | 1 -> NonPass\n  | 2 -> Jump\n  | _ -> assert false\n\nlet rec solve () =\n  sscanf\n    (read_line ()) \"%d %d\"\n    (fun x y ->\n     if x = 0 && y = 0 then ()\n     else\n       let grid =\n         Array.init\n           (y + 1)\n           (fun j ->\n            if j = y then Array.make (x + 2) Terminal\n            else\n              read_line ()\n              |> split_columns\n              |> List.map (fun column -> square_of_int (int_of_string column))\n              |> (fun columns -> [ NonPass ] @ columns @ [ NonPass ])\n              |> Array.of_list) in\n       let num_routes = Array.make_matrix (y + 1) (x + 2) 0 in\n       for i = 1 to x do\n         num_routes.(0).(i) <- if grid.(0).(i) = Pass then 1 else 0\n       done;\n       for j = 1 to y do\n         for i = 1 to x do\n           num_routes.(j).(i) <-\n             previous_positions grid (i, j)\n             |> List.map (fun (x, y) -> num_routes.(y).(x))\n             |> List.fold_left ( + ) 0\n         done\n       done;\n       print_int (Array.fold_left ( + ) 0 num_routes.(y));\n       print_newline ();\n       solve ())\n\nlet () = solve ()"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0203\n\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom collections import deque, defaultdict\ninput = stdin.readline\n\n\ndef solve(field):\n    BLANK, OBSTACLE, JUMP = 0, 1, 2\n    ans = 0                     #  ??????????????°???????????°\n\n    dy = [1, 1, 1]  # ?????????????????????????????????????§???????\n    dx = [0, -1, 1]\n    x_limit = len(field[0])\n    y_limit = len(field)\n\n    path = defaultdict(int)     #  ??????????????????????????°???????????°????????????'x???_y???'???????????????\n    Q = deque()\n    for x, m in enumerate(field[0]):\n        if m == BLANK:              #  ?????????????????°?????´?????????????????????????????????\n            t = '{}_{}'.format(x, 0)\n            Q.append((x, 0))\n            path[t] = 1\n\n    while Q:\n        cx, cy = Q.popleft()        #  ?????¨??°?????§?¨?\n        t = '{}_{}'.format(cx, cy)\n        num = path.pop(t)\n\n        if field[cy][cx] == OBSTACLE:\n            continue\n        elif field[cy][cx] == JUMP: #  ?????£????????§?????°?????????????????£????????°\n            if cy+2 > y_limit-1:\n                ans += num\n            else:\n                t = '{}_{}'.format(cx, cy+2)\n                if not path[t]:\n                    Q.append((cx, cy+2))\n                path[t] += num\n            continue\n        elif cy == y_limit -1:\n            ans += num\n            continue\n\n        for i in range(3):      #  ?????????3???len(dy)?????????\n            nx = cx + dx[i]     #  ?????°????????§?¨?\n            ny = cy + dy[i]\n\n            if 0<= nx < x_limit:\n                if field[ny][nx] == JUMP and dx[i] == 0: #  ?????£????????°????????£??????????????\\????????´???\n                    if ny+2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = '{}_{}'.format(nx, ny+2)\n                        if not path[t]:\n                            Q.append((nx, ny+2))\n                        path[t] += num\n                elif field[ny][nx] == BLANK:\n                    if (ny >= y_limit - 1):\n                        ans += num\n                    else:\n                        t = '{}_{}'.format(nx, ny)\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans\n\n\ndef main(args):\n    while True:\n        X, Y = map(int, input().strip().split())\n        if X == 0 and Y == 0:\n            break\n        field = []\n        for _ in range(Y):\n            temp = [int(x) for x in input().strip().split()]\n            field.append(temp)\n        result = solve(field)\n        print(result)\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])"
  },
  {
    "language": "Python",
    "code": "while(1):\n    [X,Y]=[int(x) for x in raw_input().split()]\n    if X==0:\n        break\n    else:\n        F=[]\n        for i in range(Y):\n            F.append([0]+[int(x) for x in raw_input().split()]+[0])\n        F.append([3 for x in range(X+2)])\n        S=[[0 for x in range(X+2)] for y in range(Y+1)] #F,S[y][x]\n        \n        #initilizing\n        for i in range(1,X+1):\n            S[0][i]=1-F[0][i]\n        for j in range(Y+1):\n            for i in range(1,X+1):\n                if F[j][i]==2:\n                    S[j][i]=S[j][i]+S[j-1][i]\n                    S[j+2][i]=S[j+2][i]+S[j][i]\n                elif F[j][i]==1:\n                    S[j][i]=0\n                elif F[j][i]==3:\n                    S[j][i]=S[j][i]+S[j-1][i]\n                else:\n                    S[j][i]=S[j][i]+(1-F[j-1][i]/2)*S[j-1][i]+(1-F[j-1][i-1]/2)*S[j-1][i-1]+(1-F[j-1][i+1]/2)*S[j-1][i+1]\n        print sum(S[Y])"
  },
  {
    "language": "Python",
    "code": "while 1:\n    x,y = list(map(int, input().split()))\n    if x == 0: break\n    c = [list(map(int, input().split())) for _ in range(y)]\n    c.append([0]*x)\n    c.append([0]*x)\n    dp = [[0]*x for _ in range(y+2)]\n    for i in range(x):\n        if c[0][i] == 0: dp[0][i] = 1\n    for i in range(y):\n        for j in range(x):\n            if c[i][j] == 0:\n                if i != y-1:\n                    if j != 0 and c[i+1][j-1] == 0:\n                        dp[i+1][j-1] += dp[i][j]\n                    if j != x-1 and c[i+1][j+1] == 0:\n                        dp[i+1][j+1] += dp[i][j]\n                    if c[i+1][j] != 1:\n                        dp[i+1][j] += dp[i][j]\n            elif c[i][j] == 2:\n                if c[i+2][j] != 1:\n                    dp[i+2][j] += dp[i][j]\n    ans = 0\n    for i in dp[y-1:y+1]:\n        ans += sum(i)\n    print(ans)\n\"\"\"\nwhile 1:\n    x,y = list(map(int, input().split()))\n    if x == 0: break\n    c = [list(map(int, input().split())) for _ in range(y)]\n    dp = [[0]*x for _ in range(y+1)]\n    for i in range(x):\n        if c[0][i] == 0: dp[0][i] = 1\n    for i in range(1,y):\n        for j in range(x):\n            if c[i][j] == 0:\n                if i >= 2 and c[i-2][j] == 2:\n                    dp[i][j] += dp[i-2][j]\n                if j != 0   and c[i-1][j-1] == 0:dp[i][j] += dp[i-1][j-1]\n                if j != x-1 and c[i-1][j+1] == 0:dp[i][j] += dp[i-1][j+1]\n                if c[i-1][j] != 1: dp[i][j] += dp[i-1][j]\n            elif c[i][j] == 2:\n                dp[i][j] += dp[i-1][j]\n                if i >= 2 and c[i-2][j] == 2:\n                    dp[i][j] += dp[i-2][j]\n    for i in dp:\n        print(i)\n    ans = 0\n    for i in range(x):\n        ans += dp[y-1][i]\n        if y >= 2 and c[y-2][i] == 2:\n            ans += dp[y-2][j]\n    print(ans)\n\"\"\"\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0203\n\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom collections import deque, defaultdict\ninput = stdin.readline\n\n\ndef solve(field):\n    BLANK, OBSTACLE, JUMP = 0, 1, 2\n    ans = 0                     #  ??????????????°???????????°\n\n    # dy = [1, 1, 1]\n    dx = [0, -1, 1] # ?????????????????????????????????????§???????\n    x_limit = len(field[0])\n    y_limit = len(field)\n\n    path = defaultdict(int)     #  ??????????????????????????°???????????°????????????'x???_y???'???????????????\n    Q = deque()                 #  ?????§??????????????????????????¨??????????????\\???\n    \n    # ???????????§??????????????§????????´????????¢???????????\\??????????????????\n    for x, m in enumerate(field[0]):\n        if m == BLANK:              #  ?????????????????°?????´?????????????????????????????????\n            k = '{}_{}'.format(x, 0)\n            Q.append((x, 0))\n            path[k] = 1\n\n    while Q:\n        cx, cy = Q.popleft()        #  ?????¨??°?????§?¨?\n        k = '{}_{}'.format(cx, cy)\n        num = path.pop(k)       #  ????????§?¨?????????????????????°\n\n        if field[cy][cx] == OBSTACLE: #  ?????£????????§?????°??????????????????????????±????????????????????????????????§?????£?????????????????\n            continue\n        elif field[cy][cx] == JUMP: #  ?????£????????§?????°?????????????????£????????°\n            if cy+2 > y_limit-1: #  ?????£???????????????????¶?????????´??????OK??¨?????????\n                ans += num\n            else:\n                k = '{}_{}'.format(cx, cy+2)\n                if not path[k]:\n                    Q.append((cx, cy+2))\n                path[k] += num\n            continue\n        elif cy == y_limit -1:\n            ans += num\n            continue\n\n        for i in range(3):      #  ?????????3???len(dy)?????????\n            nx = cx + dx[i]     #  ?????°????????§?¨?\n            ny = cy + 1         #  ??????+1????????§???dy[i]??¨?????????????????????OK\n\n            if 0<= nx < x_limit:\n                if field[ny][nx] == JUMP and dx[i] == 0: #  ?????£????????°????????£??????????????\\????????´???\n                    if ny+2 > y_limit - 1:\n                        ans += num\n                    else:\n                        k = '{}_{}'.format(nx, ny+2)\n                        if not path[k]:\n                            Q.append((nx, ny+2))\n                        path[k] += num\n                elif field[ny][nx] == BLANK:\n                    if (ny >= y_limit - 1):\n                        ans += num\n                    else:\n                        k = '{}_{}'.format(nx, ny)\n                        if not path[k]:\n                            Q.append((nx, ny))\n                        path[k] += num\n    return ans\n\n\ndef main(args):\n    while True:\n        X, Y = map(int, input().strip().split())\n        if X == 0 and Y == 0:\n            break\n        field = []\n        for _ in range(Y):\n            temp = [int(x) for x in input().strip().split()]\n            field.append(temp)\n        result = solve(field)\n        print(result)\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0203\n\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom collections import deque, defaultdict\ninput = stdin.readline\n\n\ndef solve(field):\n    BLANK, OBSTACLE, JUMP = 0, 1, 2\n    ans = 0                     #  ??????????????°???????????°\n\n    # dy = [1, 1, 1]\n    dx = [0, -1, 1] # ?????????????????????????????????????§???????\n    x_limit = len(field[0])\n    y_limit = len(field)\n\n    path = defaultdict(int)     #  ??????????????????????????°???????????°????????????'x???_y???'???????????????\n    Q = deque()                 #  ?????§??????????????????????????¨??????????????\\???\n\n    # ???????????§??????????????§????????´????????¢???????????\\??????????????????\n    for x, m in enumerate(field[0]):\n        if m == BLANK:              #  ?????????????????°?????´?????????????????????????????????\n            k = '{}_{}'.format(x, 0)\n            Q.append((x, 0))\n            path[k] = 1\n\n    while Q:\n        cx, cy = Q.popleft()        #  ?????¨??°?????§?¨?\n        k = '{}_{}'.format(cx, cy)\n        num = path.pop(k)       #  ????????§?¨?????????????????????°\n\n        if field[cy][cx] == OBSTACLE: #  ?????£????????§?????°??????????????????????????±????????????????????????????????§?????£?????????????????\n            continue\n        elif field[cy][cx] == JUMP: #  ?????£????????§?????°?????????????????£????????°\n            if cy+2 > y_limit-1: #  ?????£???????????????????¶?????????´??????OK??¨?????????\n                ans += num\n            else:\n                k = '{}_{}'.format(cx, cy+2)\n                if not path[k]:\n                    Q.append((cx, cy+2))\n                path[k] += num\n            continue\n        elif cy == y_limit -1:\n            ans += num\n            continue\n\n        for i in range(3):      #  ?????????3???len(dy)?????????\n            nx = cx + dx[i]     #  ?????°????????§?¨?\n            ny = cy + 1         #  ??????+1????????§???dy[i]??¨?????????????????????OK\n\n            if 0<= nx < x_limit:\n                if field[ny][nx] == JUMP and dx[i] == 0: #  ?????£????????°????????£??????????????\\????????´???\n                    if ny+2 > y_limit - 1:\n                        ans += num\n                    else:\n                        k = '{}_{}'.format(nx, ny+2)\n                        if not path[k]:\n                            Q.append((nx, ny+2))\n                        path[k] += num\n                elif field[ny][nx] == BLANK:\n                    if (ny >= y_limit - 1):\n                        ans += num\n                    else:\n                        k = '{}_{}'.format(nx, ny)\n                        if not path[k]:\n                            Q.append((nx, ny))\n                        path[k] += num\n    return ans\n\n\ndef solve2(field):\n    BLANK, OBSTACLE, JUMP = 0, 1, 2\n    ans = 0                     #  ??????????????°???????????°\n\n    dy = [1, 1, 1]  # ?????????????????????????????????????§???????\n    dx = [0, -1, 1]\n    x_limit = len(field[0])\n    y_limit = len(field)\n\n    path = defaultdict(int)     #  ??????????????????????????°???????????°????????????'x???_y???'???????????????\n    Q = deque()\n    for x, m in enumerate(field[0]):\n        if m == BLANK:              #  ?????????????????°?????´?????????????????????????????????\n            t = '{}_{}'.format(x, 0)\n            Q.append((x, 0))\n            path[t] = 1\n\n    while Q:\n        cx, cy = Q.popleft()        #  ?????¨??°?????§?¨?\n        t = '{}_{}'.format(cx, cy)\n        num = path.pop(t)\n\n        if field[cy][cx] == OBSTACLE:\n            continue\n        elif field[cy][cx] == JUMP: #  ?????£????????§?????°?????????????????£????????°\n            if cy+2 > y_limit-1:\n                ans += num\n            else:\n                t = '{}_{}'.format(cx, cy+2)\n                if not path[t]:\n                    Q.append((cx, cy+2))\n                path[t] += num\n            continue\n        elif cy == y_limit -1:\n            ans += num\n            continue\n\n        for i in range(3):      #  ?????????3???len(dy)?????????\n            nx = cx + dx[i]     #  ?????°????????§?¨?\n            ny = cy + dy[i]\n\n            if 0<= nx < x_limit:\n                if field[ny][nx] == JUMP and dx[i] == 0: #  ?????£????????°????????£??????????????\\????????´???\n                    if ny+2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = '{}_{}'.format(nx, ny+2)\n                        if not path[t]:\n                            Q.append((nx, ny+2))\n                        path[t] += num\n                elif field[ny][nx] == BLANK:\n                    if (ny >= y_limit - 1):\n                        ans += num\n                    else:\n                        t = '{}_{}'.format(nx, ny)\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans\n\n\ndef solve3(field):\n    BLANK, OBSTACLE, JUMP = 0, 1, 2\n    X = len(field[0])\n    Y = len(field)\n    dp = [[0] * X for _ in range(Y)]\n\n    # ??????????????°????????????\n    for x in range(X):\n        if field[0][x] == BLANK:\n            dp[0][x] = 1\n\n    for y in range(1, Y):\n        for x in range(X):\n            t = 0\n            mark = field[y][x]\n            if mark == BLANK:\n                if field[y-1][x] != JUMP:\n                    t += dp[y-1][x]\n                if x > 0 and field[y-1][x-1] != JUMP:\n                    t += dp[y-1][x-1]\n                if x < X-1 and field[y-1][x+1] != JUMP:\n                    t += dp[y-1][x+1]\n                if y > 1 and field[y-2][x] == JUMP:\n                    t += dp[y-2][x]\n            elif mark == JUMP:\n                t = dp[y-1][x]\n                if y > 1 and field[y-2][x] == JUMP:\n                    t += dp[y-2][x]\n            dp[y][x] = t\n    ans = sum(dp[-1])\n    if Y > 1:\n        for x in range(X):\n            if field[-2][x] == JUMP:\n                ans += dp[-2][x]\n    return ans\n\n\ndef main(args):\n    while True:\n        X, Y = map(int, input().strip().split())\n        if X == 0 and Y == 0:\n            break\n        field = []\n        for _ in range(Y):\n            temp = [int(x) for x in input().strip().split()]\n            field.append(temp)\n        result = solve3(field)\n        print(result)\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0203\n\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom collections import deque, defaultdict\ninput = stdin.readline\n\n\ndef solve(field):\n    # 0: ????????°, 1: ?????????, 2: ?????£????????°\n    course = 0\n\n    # ??????????????????????????????\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = len(field[0])\n    y_limit = len(field)\n\n    path = defaultdict(int)     #  ??????????????????????????°???????????°\n    Q = deque()\n    for x, m in enumerate(field[0]):\n        if m == 0:\n            Q.append((x, 0))\n            t = '{}_{}'.format(x, 0)\n            path[t] = 1\n    if x_limit == 1:\n        return len(Q)\n\n    while Q:\n        cx, cy = Q.popleft()        #  ?????¨??°?????§?¨?\n        t = '{}_{}'.format(cx, cy)\n        num = path.pop(t)\n\n        if field[cy][cx] == 2:\n            if cy+2 >= y_limit-1:\n                course += num\n            else:\n                t = '{}_{}'.format(cx, cy)\n                if path[t]:\n                    path[t] += num\n                else:\n                    Q.append((cx, cy+2))\n                    path[t] = num\n            continue\n\n\n        for i in range(len(dx)):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            #  ?§????????????§???????????? ?????? ??¢?????¢?´¢?????§???????????°??????????????§?????¢?´¢????¶???????\n            if 0<= nx < x_limit:\n                if ny >= y_limit - 1 and field[ny][nx] != 1:\n                    course += num\n                else:\n                    if field[ny][nx] == 2 and dx[i] == 0:\n                        if ny+2 >= y_limit - 1:\n                            course += num\n                        else:\n                            t = '{}_{}'.format(nx, ny+2)\n                            if path[t]:\n                                path[t] += num\n                            else:\n                                path[t] = num\n                                Q.append((nx, ny+2))\n                    elif field[ny][nx] == 0:\n                        t = '{}_{}'.format(nx, ny)\n                        if path[t]:\n                            path[t] += num\n                        else:\n                            path[t] = num\n                            Q.append((nx, ny))\n    return course\n\n\n\ndef main(args):\n    while True:\n        X, Y = map(int, input().split())\n        if X == 0 and Y == 0:\n            break\n        field = []\n        for _ in range(Y):\n            temp = [int(x) for x in input().split()]\n            field.append(temp)\n        result = solve(field)\n        print(result)\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n    "
  },
  {
    "language": "Python",
    "code": "def algorithm():\n    def down_jump(x, y, times):\n        if x == r:\n            out_map[x - 1][y] += times\n        elif x == r - 1:\n            out_map[x][y] += times\n        elif in_map[x][y] == 2:\n            down_jump(x + 2, y, times)\n        else:\n            out_map[x][y] += times\n\n    while True:\n        c, r = map(int, input().split())\n        if c == 0 and r == 0:\n            break\n\n        in_map = []\n        out_map = [[0 for _ in range(c)] for _ in range(r)]\n        for _ in range(r):\n            in_map.append(list(map(int, input().split())))\n\n        for i in range(c):\n            if in_map[0][i] == 0 or in_map[0][i] == 2:\n                out_map[0][i] = 1\n\n        for i in range(r):\n            for j in range(c):\n                if in_map[i][j] == 0 or (i == 0 and in_map[i][j] == 2):\n                    # ???.\n                    if i + 1 < r and j > 0 and in_map[i + 1][j - 1] == 0 and in_map[i][j] == 0:\n                        out_map[i + 1][j - 1] += out_map[i][j]\n                    # ???.\n                    if in_map[i][j] == 2:\n                        down_jump(i, j, out_map[i][j])\n                    elif i + 1 < r and in_map[i + 1][j] == 0:\n                        out_map[i + 1][j] += out_map[i][j]\n                    elif i + 1 < r and in_map[i + 1][j] == 2:\n                        down_jump(i + 1, j, out_map[i][j])\n                    # ???.\n                    if i + 1 < r and j + 1 < c and in_map[i + 1][j + 1] == 0 and in_map[i][j] == 0:\n                        out_map[i + 1][j + 1] += out_map[i][j]\n\n        for i in range(c):\n            out_map[r - 1][i] = 0 if in_map[r - 1][i] else out_map[r - 1][i]\n        print(sum(out_map[r - 1]))\n\n\ndef main():\n    algorithm()\n\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "while True:\n    X, Y = map(int, input().split())\n    if X == 0:\n        break\n    a = [[1]+list(map(int, input().split()))+[1] for _ in [0]*Y] + [[0]*(X+2)]\n    dp = [list(map(lambda x: x^1, a[0]))] + [[0]*(X+2) for _ in [0]*Y]\n\n    for y in range(Y-1):\n        for x, (square, cnt) in enumerate(zip(a[y][1:], dp[y][1:-1]), start=1):\n            if square == 0:\n                for tx in range(x-1, x+2):\n                    if a[y+1][tx] == 0 or a[y+1][tx] == 2 and x == tx:\n                        dp[y+1][tx] += cnt\n            elif square == 2:\n                dp[y+2][x] += cnt\n    for x in range(1, X+1):\n        if a[Y-1][x] != 1:\n            dp[Y][x] += dp[Y-1][x]\n\n    print(sum(dp[-1]))\n"
  },
  {
    "language": "Python",
    "code": "def algorithm():\n    def down_jump(x, y, times):\n        if r == 1:\n            return\n        elif x == r:\n            out_map[x - 1][y] += times\n        elif x == r - 1:\n            out_map[x][y] += times\n        elif in_map[x][y] == 2:\n            down_jump(x + 2, y, times)\n        else:\n            out_map[x][y] += times\n\n    while True:\n        c, r = map(int, input().split())\n        if c == 0 and r == 0:\n            break\n\n        in_map = []\n        out_map = [[0 for _ in range(c)] for _ in range(r)]\n        for _ in range(r):\n            in_map.append(list(map(int, input().split())))\n\n        for i in range(c):\n            if in_map[0][i] == 0 or in_map[0][i] == 2:\n                out_map[0][i] = 1\n\n        for i in range(r):\n            for j in range(c):\n                if in_map[i][j] == 0 or (i == 0 and in_map[i][j] == 2):\n                    # ???.\n                    if i + 1 < r and j > 0 and in_map[i + 1][j - 1] == 0 and in_map[i][j] == 0:\n                        out_map[i + 1][j - 1] += out_map[i][j]\n                    # ???.\n                    if in_map[i][j] == 2:\n                        down_jump(i, j, out_map[i][j])\n                    elif i + 1 < r and in_map[i + 1][j] == 0:\n                        out_map[i + 1][j] += out_map[i][j]\n                    elif i + 1 < r and in_map[i + 1][j] == 2:\n                        down_jump(i + 1, j, out_map[i][j])\n                    # ???.\n                    if i + 1 < r and j + 1 < c and in_map[i + 1][j + 1] == 0 and in_map[i][j] == 0:\n                        out_map[i + 1][j + 1] += out_map[i][j]\n\n        for i in range(c):\n            out_map[r - 1][i] = 0 if in_map[r - 1][i] and in_map[r - 2][i] != 2 else out_map[r - 1][i]\n        print(sum(out_map[r - 1]))\n\n\ndef main():\n    algorithm()\n\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0203\n\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom collections import deque, defaultdict\ninput = stdin.readline\n\n\ndef solve(field):\n    BLANK, OBSTACLE, JUMP = 0, 1, 2\n    ans = 0                     #  ??????????????°???????????°\n\n    dy = [1, 1, 1]  # ?????????????????????????????????????§???????\n    dx = [0, -1, 1]\n    x_limit = len(field[0])\n    y_limit = len(field)\n\n    path = defaultdict(int)     #  ??????????????????????????°???????????°????????????'x???_y???'???????????????\n    Q = deque()\n    for x, m in enumerate(field[0]):\n        if m == BLANK:              #  ?????????????????°?????´?????????????????????????????????\n            t = '{}_{}'.format(x, 0)\n            Q.append((x, 0))\n            path[t] = 1\n    if y_limit < 2:\n        return len(Q)\n\n\n    while Q:\n        cx, cy = Q.popleft()        #  ?????¨??°?????§?¨?\n        t = '{}_{}'.format(cx, cy)\n        num = path.pop(t)\n\n        if field[cy][cx] == OBSTACLE:\n            continue\n        elif field[cy][cx] == JUMP: #  ?????£????????§?????°?????????????????£????????°\n            if cy+2 > y_limit-1:\n                ans += num\n            else:\n                t = '{}_{}'.format(cx, cy+2)\n                if not path[t]:\n                    Q.append((cx, cy+2))\n                path[t] += num\n            continue\n        elif cy == y_limit -1:\n            ans += num\n            continue\n\n        for i in range(len(dx)):\n            nx = cx + dx[i]     #  ?????°????????§?¨?\n            ny = cy + dy[i]\n\n            if 0<= nx < x_limit:\n                if (ny >= y_limit - 1) and field[ny][nx] == BLANK:\n                    ans += num\n                else:\n                    if field[ny][nx] == JUMP and dx[i] == 0: #  ?????£????????°????????£??????????????\\????????´???\n                        if ny+2 > y_limit - 1:\n                            ans += num\n                        else:\n                            t = '{}_{}'.format(nx, ny+2)\n                            if not path[t]:\n                                Q.append((nx, ny+2))\n                            path[t] += num\n                    elif field[ny][nx] == BLANK:\n                        t = '{}_{}'.format(nx, ny)\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans\n\n\ndef main(args):\n    while True:\n        X, Y = map(int, input().strip().split())\n        if X == 0 and Y == 0:\n            break\n        field = []\n        for _ in range(Y):\n            temp = [int(x) for x in input().strip().split()]\n            field.append(temp)\n        result = solve(field)\n        print(result)\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])"
  },
  {
    "language": "Python",
    "code": "def printF(field,w,h):\n    for i in range(h):\n        print(field[i])\n\ndef getp(f,p,y,x,h,w,v):\n    if y<0 or x<0 or x>=w:\n        return 0\n    if y>=h:\n        if v==True:\n            return 1\n        return 0\n\n    \n    k = f[y][x]\n    r = 0\n    if k==0:\n        if p[y][x]>=0:\n            return p[y][x]\n\n        r = getp(f,p,y+1,x-1,h,w,False)+getp(f,p,y+1,x,h,w,True)+getp(f,p,y+1,x+1,h,w,False)\n        p[y][x] = r\n    elif k==1:\n        r = 0\n    elif k==2:\n        if v == True:\n            if p[y][x]>=0:\n                return p[y][x]\n            r = getp(f,p,y+2,x,h,w,True)\n            p[y][x] = r\n        else:\n            r = 0\n\n    #print(\"gp({},{},{}):({},{})\".format(x,y,v,k,r))\n    return r\n\nw,h = map(int,input().split())\nwhile w!=0 and h != 0:\n    field = []\n\n    for i in range(h):\n        field.append(list(map(int,input().split())))\n        \n\n    #initialize\n    p = []\n    for i in range(h):\n        p.append([-1]*w)\n\n    #calc\n\n    print(sum(map(lambda x:getp(field,p,0,x,h,w,True), range(w))))\n\n    w,h = map(int,input().split())\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0203\n\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom collections import deque, defaultdict\ninput = stdin.readline\n\n\ndef solve(field):\n    # 0: ????????°, 1: ?????????, 2: ?????£????????°\n    ans = 0                     #  ??????????????°???????????°\n\n    dy = [1, 1, 1]  # ?????????????????????????????????????§???????\n    dx = [0, -1, 1]\n    x_limit = len(field[0])\n    y_limit = len(field)\n\n    path = defaultdict(int)     #  ??????????????????????????°???????????°????????????'x???_y???'???????????????\n    Q = deque()\n    for x, m in enumerate(field[0]):\n        if m == 0:              #  ?????????????????°?????´?????????????????????????????????\n            t = '{}_{}'.format(x, 0)\n            Q.append((x, 0))\n            path[t] = 1\n    if y_limit < 2:\n        return len(Q)\n\n    return 0\n\n    while Q:\n        cx, cy = Q.popleft()        #  ?????¨??°?????§?¨?\n        t = '{}_{}'.format(cx, cy)\n        num = path.pop(t)\n\n        if field[cy][cx] == 1:  #  ?????£????????§?????°?????????????????????\n            continue\n        elif field[cy][cx] == 2: #  ?????£????????§?????°?????????????????£????????°\n            if cy+2 >= y_limit-1:\n                ans += num\n            else:\n                t = '{}_{}'.format(cx, cy+2)\n                if not path[t]:\n                    Q.append((cx, cy+2))\n                path[t] += num\n            continue\n\n        for i in range(len(dx)):\n            nx = cx + dx[i]     #  ?????°????????§?¨?\n            ny = cy + dy[i]\n\n            if 0<= nx < x_limit:\n                if (ny >= y_limit - 1) and field[ny][nx] != 1:\n                    ans += num\n                else:\n                    if field[ny][nx] == 2 and dx[i] == 0: #  ?????£????????°????????£??????????????\\????????´???\n                        if ny+2 > y_limit - 1:\n                            ans += num\n                        else:\n                            t = '{}_{}'.format(nx, ny+2)\n                            if not path[t]:\n                                Q.append((nx, ny+2))\n                            path[t] += num\n                    elif field[ny][nx] == 0:\n                        t = '{}_{}'.format(nx, ny)\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans\n\n\ndef main(args):\n    while True:\n        X, Y = map(int, input().strip().split())\n        if X == 0 and Y == 0:\n            break\n        field = []\n        for _ in range(Y):\n            temp = [int(x) for x in input().strip().split()]\n            field.append(temp)\n        result = solve(field)\n        print(result)\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0203\n\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom collections import deque, defaultdict\ninput = stdin.readline\n\n\ndef solve(field):\n    BLANK, OBSTACLE, JUMP = 0, 1, 2\n    ans = 0                     #  ??????????????°???????????°\n\n    # dy = [1, 1, 1]\n    dx = [0, -1, 1] # ?????????????????????????????????????§???????\n    x_limit = len(field[0])\n    y_limit = len(field)\n\n    path = defaultdict(int)     #  ??????????????????????????°???????????°????????????'x???_y???'???????????????\n    Q = deque()                 #  ?????§??????????????????????????¨??????????????\\???\n\n    # ???????????§??????????????§????????´????????¢???????????\\??????????????????\n    for x, m in enumerate(field[0]):\n        if m == BLANK:              #  ?????????????????°?????´?????????????????????????????????\n            k = '{}_{}'.format(x, 0)\n            Q.append((x, 0))\n            path[k] = 1\n\n    while Q:\n        cx, cy = Q.popleft()        #  ?????¨??°?????§?¨?\n        k = '{}_{}'.format(cx, cy)\n        num = path.pop(k)       #  ????????§?¨?????????????????????°\n\n        if field[cy][cx] == OBSTACLE: #  ?????£????????§?????°??????????????????????????±????????????????????????????????§?????£?????????????????\n            continue\n        elif field[cy][cx] == JUMP: #  ?????£????????§?????°?????????????????£????????°\n            if cy+2 > y_limit-1: #  ?????£???????????????????¶?????????´??????OK??¨?????????\n                ans += num\n            else:\n                k = '{}_{}'.format(cx, cy+2)\n                if not path[k]:\n                    Q.append((cx, cy+2))\n                path[k] += num\n            continue\n        elif cy == y_limit -1:\n            ans += num\n            continue\n\n        for i in range(3):      #  ?????????3???len(dy)?????????\n            nx = cx + dx[i]     #  ?????°????????§?¨?\n            ny = cy + 1         #  ??????+1????????§???dy[i]??¨?????????????????????OK\n\n            if 0<= nx < x_limit:\n                if field[ny][nx] == JUMP and dx[i] == 0: #  ?????£????????°????????£??????????????\\????????´???\n                    if ny+2 > y_limit - 1:\n                        ans += num\n                    else:\n                        k = '{}_{}'.format(nx, ny+2)\n                        if not path[k]:\n                            Q.append((nx, ny+2))\n                        path[k] += num\n                elif field[ny][nx] == BLANK:\n                    if (ny >= y_limit - 1):\n                        ans += num\n                    else:\n                        k = '{}_{}'.format(nx, ny)\n                        if not path[k]:\n                            Q.append((nx, ny))\n                        path[k] += num\n    return ans\n\n\ndef solve2(field):\n    BLANK, OBSTACLE, JUMP = 0, 1, 2\n    ans = 0                     #  ??????????????°???????????°\n\n    dy = [1, 1, 1]  # ?????????????????????????????????????§???????\n    dx = [0, -1, 1]\n    x_limit = len(field[0])\n    y_limit = len(field)\n\n    path = defaultdict(int)     #  ??????????????????????????°???????????°????????????'x???_y???'???????????????\n    Q = deque()\n    for x, m in enumerate(field[0]):\n        if m == BLANK:              #  ?????????????????°?????´?????????????????????????????????\n            t = '{}_{}'.format(x, 0)\n            Q.append((x, 0))\n            path[t] = 1\n\n    while Q:\n        cx, cy = Q.popleft()        #  ?????¨??°?????§?¨?\n        t = '{}_{}'.format(cx, cy)\n        num = path.pop(t)\n\n        if field[cy][cx] == OBSTACLE:\n            continue\n        elif field[cy][cx] == JUMP: #  ?????£????????§?????°?????????????????£????????°\n            if cy+2 > y_limit-1:\n                ans += num\n            else:\n                t = '{}_{}'.format(cx, cy+2)\n                if not path[t]:\n                    Q.append((cx, cy+2))\n                path[t] += num\n            continue\n        elif cy == y_limit -1:\n            ans += num\n            continue\n\n        for i in range(3):      #  ?????????3???len(dy)?????????\n            nx = cx + dx[i]     #  ?????°????????§?¨?\n            ny = cy + dy[i]\n\n            if 0<= nx < x_limit:\n                if field[ny][nx] == JUMP and dx[i] == 0: #  ?????£????????°????????£??????????????\\????????´???\n                    if ny+2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = '{}_{}'.format(nx, ny+2)\n                        if not path[t]:\n                            Q.append((nx, ny+2))\n                        path[t] += num\n                elif field[ny][nx] == BLANK:\n                    if (ny >= y_limit - 1):\n                        ans += num\n                    else:\n                        t = '{}_{}'.format(nx, ny)\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans\n\n\ndef solve3(field):\n    BLANK, OBSTACLE, JUMP = 0, 1, 2\n    X = len(field[0])\n    Y = len(field)\n    dp = [[0] * X for _ in range(Y)]\n\n    for x in range(X):\n        if field[0][x] == BLANK:\n            dp[0][x] = 1\n\n    for y in range(1, Y):\n        for x in range(X):\n            if field[y][x] == BLANK:\n                if field[y-1][x] != JUMP:\n                    dp[y][x] = dp[y-1][x]\n                if x > 0 and field[y-1][x-1] != JUMP:\n                    dp[y][x] += dp[y-1][x-1]\n                if x < X-1 and field[y-1][x+1] != JUMP:\n                    dp[y][x] += dp[y-1][x+1]\n                if y > 1 and field[y-2][x] == JUMP:\n                    dp[y][x] += dp[y-2][x]\n            elif field[y][x] == OBSTACLE:\n                dp[y][x] = 0\n            else:\n                dp[y][x] = dp[y-1][x]\n                if y > 1 and field[y-2][x] == JUMP:\n                    dp[y][x] += dp[y-2][x]\n    ans = sum(dp[-1])\n    if Y > 1:\n        for x in range(X):\n            if field[-2][x] == JUMP:\n                ans += dp[-2][x]\n    return ans\n\n\n\ndef main(args):\n    while True:\n        X, Y = map(int, input().strip().split())\n        if X == 0 and Y == 0:\n            break\n        field = []\n        for _ in range(Y):\n            temp = [int(x) for x in input().strip().split()]\n            field.append(temp)\n        result = solve3(field)\n        print(result)\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0203\n\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom collections import deque, defaultdict\ninput = stdin.readline\n\n\ndef solve(field):\n    # 0: ????????°, 1: ?????????, 2: ?????£????????°\n    course = 0\n\n    # ??????????????????????????????\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = len(field[0])\n    y_limit = len(field)\n\n    path = defaultdict(int)     #  ??????????????????????????°???????????°\n    Q = deque()\n    for x, m in enumerate(field[0]):\n        if m == 0:\n            Q.append((x, 0))\n            t = '{}_{}'.format(x, 0)\n            path[t] = 1\n\n    while Q:\n        cx, cy = Q.popleft()        #  ?????¨??°?????§?¨?\n        t = '{}_{}'.format(cx, cy)\n        num = path.pop(t)\n\n        if field[cy][cx] == 2:\n            if cy+2 >= y_limit-1:\n                course += num\n            else:\n                t = '{}_{}'.format(cx, cy)\n                if path[t]:\n                    path[t] += num\n                else:\n                    Q.append((cx, cy+2))\n                    path[t] = num\n            continue\n\n\n        for i in range(len(dx)):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            #  ?§????????????§???????????? ?????? ??¢?????¢?´¢?????§???????????°??????????????§?????¢?´¢????¶???????\n            if 0<= nx < x_limit:\n                if ny >= y_limit - 1 and field[ny][nx] != 1:\n                    course += num\n                else:\n                    if field[ny][nx] == 2 and dx[i] == 0:\n                        if ny+2 >= y_limit - 1:\n                            course += num\n                        else:\n                            t = '{}_{}'.format(nx, ny+2)\n                            if path[t]:\n                                path[t] += num\n                            else:\n                                path[t] = num\n                                Q.append((nx, ny+2))\n                    elif field[ny][nx] == 0:\n                        t = '{}_{}'.format(nx, ny)\n                        if path[t]:\n                            path[t] += num\n                        else:\n                            path[t] = num\n                            Q.append((nx, ny))\n    return course\n\n\n\ndef main(args):\n    while True:\n        X, Y = map(int, input().split())\n        if X == 0 and Y == 0:\n            break\n        field = []\n        for _ in range(Y):\n            temp = [int(x) for x in input().split()]\n            field.append(temp)\n        result = solve(field)\n        print(result)\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n    "
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0203\n\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom collections import deque, defaultdict\ninput = stdin.readline\n\n\ndef solve(field):\n    BLANK, OBSTACLE, JUMP = 0, 1, 2\n    ans = 0                     #  ??????????????°???????????°\n\n    dy = [1, 1, 1]  # ?????????????????????????????????????§???????\n    dx = [0, -1, 1]\n    x_limit = len(field[0])\n    y_limit = len(field)\n\n    path = defaultdict(int)     #  ??????????????????????????°???????????°????????????'x???_y???'???????????????\n    Q = deque()\n    for x, m in enumerate(field[0]):\n        if m == BLANK:              #  ?????????????????°?????´?????????????????????????????????\n            t = '{}_{}'.format(x, 0)\n            Q.append((x, 0))\n            path[t] = 1\n    if y_limit < 2:\n        return len(Q)\n\n\n    while Q:\n        cx, cy = Q.popleft()        #  ?????¨??°?????§?¨?\n        t = '{}_{}'.format(cx, cy)\n        num = path.pop(t)\n\n        if field[cy][cx] == OBSTACLE:\n            continue\n        elif field[cy][cx] == JUMP: #  ?????£????????§?????°?????????????????£????????°\n            if cy+2 > y_limit-1:\n                ans += num\n            else:\n                t = '{}_{}'.format(cx, cy+2)\n                if not path[t]:\n                    Q.append((cx, cy+2))\n                path[t] += num\n            continue\n        elif cy == y_limit -1:\n            ans += num\n            continue\n\n        for i in range(len(dx)):\n            nx = cx + dx[i]     #  ?????°????????§?¨?\n            ny = cy + dy[i]\n\n            if 0<= nx < x_limit:\n                if (ny >= y_limit - 1) and field[ny][nx] != OBSTACLE:\n                    ans += num\n                else:\n                    if field[ny][nx] == JUMP and dx[i] == 0: #  ?????£????????°????????£??????????????\\????????´???\n                        if ny+2 > y_limit - 1:\n                            ans += num\n                        else:\n                            t = '{}_{}'.format(nx, ny+2)\n                            if not path[t]:\n                                Q.append((nx, ny+2))\n                            path[t] += num\n                    elif field[ny][nx] == BLANK:\n                        t = '{}_{}'.format(nx, ny)\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans\n\n\ndef main(args):\n    while True:\n        X, Y = map(int, input().strip().split())\n        if X == 0 and Y == 0:\n            break\n        field = []\n        for _ in range(Y):\n            temp = [int(x) for x in input().strip().split()]\n            field.append(temp)\n        result = solve(field)\n        print(result)\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])"
  },
  {
    "language": "Python",
    "code": "while 1:\n\tX,Y = map(int,raw_input().split())\n\tif X == 0: break\n\tA = [[0]+map(int,raw_input().split())+[0] for i in range(Y)]\n\tS = [[0]*(X+2) for i in range(Y)]\n\tfor x in range(1,X+1): S[0][x] = 1 if A[0][x] == 0 else 0\n\tfor y in range(1,Y):\n\t\tfor x in range(1,X+1):\n\t\t\tif A[y][x] == 0:\n\t\t\t\tfor i in range(-1,2):\n\t\t\t\t\tS[y][x] += S[y-1][x-i] if A[y-1][x-i] == 0 else 0\n\t\t\tif A[y][x] == 2:\n\t\t\t\tS[y][x] += S[y-1][x] if A[y-1][x] == 0 else 0\n\t\t\t\tif y+2 < Y and A[y+2][x] != 1:\n\t\t\t\t\tS[y+2][x] = S[y][x]\n\tans = 0\n\tfor x in range(1,X+1):\n\t\tans += S[Y-1][x] + (S[Y-2][x] if A[Y-2][x] == 2 else 0)\n\tprint ans"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0203\n\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom collections import deque, defaultdict\ninput = stdin.readline\n\n\ndef solve(field):\n    # 0: ????????°, 1: ?????????, 2: ?????£????????°\n    ans = 0                     #  ??????????????°???????????°\n\n    dy = [1, 1, 1]  # ?????????????????????????????????????§???????\n    dx = [0, -1, 1]\n    x_limit = len(field[0])\n    y_limit = len(field)\n\n    path = defaultdict(int)     #  ??????????????????????????°???????????°\n    Q = deque()\n    for x, m in enumerate(field[0]):\n        if m == 0:              #  ?????????????????°?????´?????????????????????????????????\n            Q.append((x, 0))\n            t = '{}_{}'.format(x, 0)\n            path[t] = 1\n    if y_limit < 2:\n        return len(Q)\n\n    while Q:\n        cx, cy = Q.popleft()        #  ?????¨??°?????§?¨?\n        t = '{}_{}'.format(cx, cy)\n        num = path.pop(t)\n\n        if field[cy][cx] == 1:  #  ?????£????????§?????°?????????????????????\n            continue\n        elif field[cy][cx] == 2: #  ?????£????????§?????°?????????????????£????????°\n            if cy+2 >= y_limit-1:\n                ans += num\n            else:\n                t = '{}_{}'.format(cx, cy+2)\n                if not path[t]:\n                    Q.append((cx, cy+2))\n                path[t] += num\n            continue\n\n        for i in range(len(dx)):\n            nx = cx + dx[i]     #  ?????°????????§?¨?\n            ny = cy + dy[i]\n\n            if 0<= nx < x_limit:\n                if ny >= y_limit - 1 and field[ny][nx] != 1:\n                    ans += num\n                else:\n                    if field[ny][nx] == 2 and dx[i] == 0: #  ?????£????????°????????£??????????????\\????????´???\n                        if ny+2 > y_limit - 1:\n                            ans += num\n                        else:\n                            t = '{}_{}'.format(nx, ny+2)\n                            if not path[t]:\n                                Q.append((nx, ny+2))\n                            path[t] += num\n                    elif field[ny][nx] == 0:\n                        t = '{}_{}'.format(nx, ny)\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans\n\n\ndef main(args):\n    while True:\n        X, Y = map(int, input().strip().split())\n        if X == 0 and Y == 0:\n            break\n        field = []\n        for _ in range(Y):\n            temp = [int(x) for x in input().strip().split()]\n            field.append(temp)\n        result = solve(field)\n        print(result)\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n    "
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0203\n\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom collections import deque, defaultdict\ninput = stdin.readline\n\n\ndef solve(field):\n    BLANK, OBSTACLE, JUMP = 0, 1, 2\n    ans = 0                     #  ??????????????°???????????°\n\n    # dy = [1, 1, 1]\n    dx = [0, -1, 1] # ?????????????????????????????????????§???????\n    x_limit = len(field[0])\n    y_limit = len(field)\n\n    path = defaultdict(int)     #  ??????????????????????????°???????????°????????????'x???_y???'???????????????\n    Q = deque()                 #  ?????§??????????????????????????¨??????????????\\???\n\n    # ???????????§??????????????§????????´????????¢???????????\\??????????????????\n    for x, m in enumerate(field[0]):\n        if m == BLANK:              #  ?????????????????°?????´?????????????????????????????????\n            k = '{}_{}'.format(x, 0)\n            Q.append((x, 0))\n            path[k] = 1\n\n    while Q:\n        cx, cy = Q.popleft()        #  ?????¨??°?????§?¨?\n        k = '{}_{}'.format(cx, cy)\n        num = path.pop(k)       #  ????????§?¨?????????????????????°\n\n        if field[cy][cx] == OBSTACLE: #  ?????£????????§?????°??????????????????????????±????????????????????????????????§?????£?????????????????\n            continue\n        elif field[cy][cx] == JUMP: #  ?????£????????§?????°?????????????????£????????°\n            if cy+2 > y_limit-1: #  ?????£???????????????????¶?????????´??????OK??¨?????????\n                ans += num\n            else:\n                k = '{}_{}'.format(cx, cy+2)\n                if not path[k]:\n                    Q.append((cx, cy+2))\n                path[k] += num\n            continue\n        elif cy == y_limit -1:\n            ans += num\n            continue\n\n        for i in range(3):      #  ?????????3???len(dy)?????????\n            nx = cx + dx[i]     #  ?????°????????§?¨?\n            ny = cy + 1         #  ??????+1????????§???dy[i]??¨?????????????????????OK\n\n            if 0<= nx < x_limit:\n                if field[ny][nx] == JUMP and dx[i] == 0: #  ?????£????????°????????£??????????????\\????????´???\n                    if ny+2 > y_limit - 1:\n                        ans += num\n                    else:\n                        k = '{}_{}'.format(nx, ny+2)\n                        if not path[k]:\n                            Q.append((nx, ny+2))\n                        path[k] += num\n                elif field[ny][nx] == BLANK:\n                    if (ny >= y_limit - 1):\n                        ans += num\n                    else:\n                        k = '{}_{}'.format(nx, ny)\n                        if not path[k]:\n                            Q.append((nx, ny))\n                        path[k] += num\n    return ans\n\n\ndef solve2(field):\n    BLANK, OBSTACLE, JUMP = 0, 1, 2\n    ans = 0                     #  ??????????????°???????????°\n\n    dy = [1, 1, 1]  # ?????????????????????????????????????§???????\n    dx = [0, -1, 1]\n    x_limit = len(field[0])\n    y_limit = len(field)\n\n    path = defaultdict(int)     #  ??????????????????????????°???????????°????????????'x???_y???'???????????????\n    Q = deque()\n    for x, m in enumerate(field[0]):\n        if m == BLANK:              #  ?????????????????°?????´?????????????????????????????????\n            t = '{}_{}'.format(x, 0)\n            Q.append((x, 0))\n            path[t] = 1\n\n    while Q:\n        cx, cy = Q.popleft()        #  ?????¨??°?????§?¨?\n        t = '{}_{}'.format(cx, cy)\n        num = path.pop(t)\n\n        if field[cy][cx] == OBSTACLE:\n            continue\n        elif field[cy][cx] == JUMP: #  ?????£????????§?????°?????????????????£????????°\n            if cy+2 > y_limit-1:\n                ans += num\n            else:\n                t = '{}_{}'.format(cx, cy+2)\n                if not path[t]:\n                    Q.append((cx, cy+2))\n                path[t] += num\n            continue\n        elif cy == y_limit -1:\n            ans += num\n            continue\n\n        for i in range(3):      #  ?????????3???len(dy)?????????\n            nx = cx + dx[i]     #  ?????°????????§?¨?\n            ny = cy + dy[i]\n\n            if 0<= nx < x_limit:\n                if field[ny][nx] == JUMP and dx[i] == 0: #  ?????£????????°????????£??????????????\\????????´???\n                    if ny+2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = '{}_{}'.format(nx, ny+2)\n                        if not path[t]:\n                            Q.append((nx, ny+2))\n                        path[t] += num\n                elif field[ny][nx] == BLANK:\n                    if (ny >= y_limit - 1):\n                        ans += num\n                    else:\n                        t = '{}_{}'.format(nx, ny)\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans\n\n\ndef solve3(field):\n    BLANK, OBSTACLE, JUMP = 0, 1, 2\n    X = len(field[0])\n    Y = len(field)\n    dp = [[0] * X for _ in range(Y)]\n\n    # ??????????????°????????????\n    for x in range(X):\n        if field[0][x] == BLANK:\n            dp[0][x] = 1\n\n    for y in range(1, Y):\n        for x in range(X):\n            t = 0\n            mark = field[y][x]\n            if mark == BLANK:\n                if field[y-1][x] != JUMP:\n                    t += dp[y-1][x]\n                if x > 0 and field[y-1][x-1] != JUMP:\n                    t += dp[y-1][x-1]\n                if x < X-1 and field[y-1][x+1] != JUMP:\n                    t += dp[y-1][x+1]\n                if y > 1 and field[y-2][x] == JUMP:\n                    t += dp[y-2][x]\n            elif mark == JUMP:\n                if field[y-1][x] != JUMP:\n                    t = dp[y-1][x]\n                if y > 1 and field[y-2][x] == JUMP:\n                    t += dp[y-2][x]\n            dp[y][x] = t\n    ans = sum(dp[-1])\n    if Y > 1:\n        for x in range(X):\n            if field[-2][x] == JUMP:\n                ans += dp[-2][x]\n    return ans\n\n\ndef main(args):\n    while True:\n        X, Y = map(int, input().strip().split())\n        if X == 0 and Y == 0:\n            break\n        field = []\n        for _ in range(Y):\n            temp = [int(x) for x in input().strip().split()]\n            field.append(temp)\n        result = solve3(field)\n        print(result)\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])"
  },
  {
    "language": "Python",
    "code": "\"\"\" Created by Jieyi on 8/16/16. \"\"\"\n\n\ndef algorithm():\n    def down_jump(x, y, times):\n        if x == r:\n            out_map[x - 1][y] += times\n        elif x == r - 1:\n            out_map[x][y] += times\n        elif in_map[x][y] == 2:\n            down_jump(x + 2, y, times)\n        else:\n            out_map[x][y] += times\n\n    while True:\n        c, r = map(int, input().split())\n        if c == 0 and r == 0:\n            break\n\n        in_map = []\n        out_map = [[0 for _ in range(c)] for _ in range(r)]\n        for _ in range(r):\n            in_map.append(list(map(int, input().split())))\n\n        for i in range(c):\n            if in_map[0][i] == 0 or in_map[0][i] == 2:\n                out_map[0][i] = 1\n\n        for i in range(r):\n            for j in range(c):\n                if in_map[i][j] == 0 or (i == 0 and in_map[i][j] == 2):\n                    # ???.\n                    if i + 1 < r and j > 0 and in_map[i + 1][j - 1] == 0:\n                        out_map[i + 1][j - 1] += out_map[i][j]\n                    # ???.\n                    if i + 1 < r and in_map[i + 1][j] == 0:\n                        out_map[i + 1][j] += out_map[i][j]\n                    elif i + 1 < r and in_map[i + 1][j] == 2:\n                        down_jump(i + 1, j, out_map[i][j])\n                    # ???.\n                    if i + 1 < r and j + 1 < c and in_map[i + 1][j + 1] == 0:\n                        out_map[i + 1][j + 1] += out_map[i][j]\n\n        print(sum(out_map[r - 1]))\n\n\ndef main():\n    algorithm()\n\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0203\n\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom collections import deque, defaultdict\ninput = stdin.readline\n\n\ndef solve(field):\n    BLANK, OBSTACLE, JUMP = 0, 1, 2\n    ans = 0                     #  ??????????????°???????????°\n\n    # dy = [1, 1, 1]\n    dx = [0, -1, 1] # ?????????????????????????????????????§???????\n    x_limit = len(field[0])\n    y_limit = len(field)\n\n    path = defaultdict(int)     #  ??????????????????????????°???????????°????????????'x???_y???'???????????????\n    Q = deque()                 #  ?????§??????????????????????????¨??????????????\\???\n\n    # ???????????§??????????????§????????´????????¢???????????\\??????????????????\n    for x, m in enumerate(field[0]):\n        if m == BLANK:              #  ?????????????????°?????´?????????????????????????????????\n            k = '{}_{}'.format(x, 0)\n            Q.append((x, 0))\n            path[k] = 1\n\n    while Q:\n        cx, cy = Q.popleft()        #  ?????¨??°?????§?¨?\n        k = '{}_{}'.format(cx, cy)\n        num = path.pop(k)       #  ????????§?¨?????????????????????°\n\n        if field[cy][cx] == OBSTACLE: #  ?????£????????§?????°??????????????????????????±????????????????????????????????§?????£?????????????????\n            continue\n        elif field[cy][cx] == JUMP: #  ?????£????????§?????°?????????????????£????????°\n            if cy+2 > y_limit-1: #  ?????£???????????????????¶?????????´??????OK??¨?????????\n                ans += num\n            else:\n                k = '{}_{}'.format(cx, cy+2)\n                if not path[k]:\n                    Q.append((cx, cy+2))\n                path[k] += num\n            continue\n        elif cy == y_limit -1:\n            ans += num\n            continue\n\n        for i in range(3):      #  ?????????3???len(dy)?????????\n            nx = cx + dx[i]     #  ?????°????????§?¨?\n            ny = cy + 1         #  ??????+1????????§???dy[i]??¨?????????????????????OK\n\n            if 0<= nx < x_limit:\n                if field[ny][nx] == JUMP and dx[i] == 0: #  ?????£????????°????????£??????????????\\????????´???\n                    if ny+2 > y_limit - 1:\n                        ans += num\n                    else:\n                        k = '{}_{}'.format(nx, ny+2)\n                        if not path[k]:\n                            Q.append((nx, ny+2))\n                        path[k] += num\n                elif field[ny][nx] == BLANK:\n                    if (ny >= y_limit - 1):\n                        ans += num\n                    else:\n                        k = '{}_{}'.format(nx, ny)\n                        if not path[k]:\n                            Q.append((nx, ny))\n                        path[k] += num\n    return ans\n\n\ndef solve2(field):\n    BLANK, OBSTACLE, JUMP = 0, 1, 2\n    ans = 0                     #  ??????????????°???????????°\n\n    dy = [1, 1, 1]  # ?????????????????????????????????????§???????\n    dx = [0, -1, 1]\n    x_limit = len(field[0])\n    y_limit = len(field)\n\n    path = defaultdict(int)     #  ??????????????????????????°???????????°????????????'x???_y???'???????????????\n    Q = deque()\n    for x, m in enumerate(field[0]):\n        if m == BLANK:              #  ?????????????????°?????´?????????????????????????????????\n            t = '{}_{}'.format(x, 0)\n            Q.append((x, 0))\n            path[t] = 1\n\n    while Q:\n        cx, cy = Q.popleft()        #  ?????¨??°?????§?¨?\n        t = '{}_{}'.format(cx, cy)\n        num = path.pop(t)\n\n        if field[cy][cx] == OBSTACLE:\n            continue\n        elif field[cy][cx] == JUMP: #  ?????£????????§?????°?????????????????£????????°\n            if cy+2 > y_limit-1:\n                ans += num\n            else:\n                t = '{}_{}'.format(cx, cy+2)\n                if not path[t]:\n                    Q.append((cx, cy+2))\n                path[t] += num\n            continue\n        elif cy == y_limit -1:\n            ans += num\n            continue\n\n        for i in range(3):      #  ?????????3???len(dy)?????????\n            nx = cx + dx[i]     #  ?????°????????§?¨?\n            ny = cy + dy[i]\n\n            if 0<= nx < x_limit:\n                if field[ny][nx] == JUMP and dx[i] == 0: #  ?????£????????°????????£??????????????\\????????´???\n                    if ny+2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = '{}_{}'.format(nx, ny+2)\n                        if not path[t]:\n                            Q.append((nx, ny+2))\n                        path[t] += num\n                elif field[ny][nx] == BLANK:\n                    if (ny >= y_limit - 1):\n                        ans += num\n                    else:\n                        t = '{}_{}'.format(nx, ny)\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans\n\n\ndef main(args):\n    while True:\n        X, Y = map(int, input().strip().split())\n        if X == 0 and Y == 0:\n            break\n        field = []\n        for _ in range(Y):\n            temp = [int(x) for x in input().strip().split()]\n            field.append(temp)\n        result = solve2(field)\n        print(result)\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])"
  },
  {
    "language": "Python",
    "code": "while 1:\n    X,Y = map(int,raw_input().split())\n    if X == 0: break\n    A = [[0]+map(int,raw_input().split())+[0] for i in range(Y)]\n    S = [[0]*(X+2) for i in range(Y)]\n    for x in range(1,X+1): S[0][x] = 1 if A[0][x] == 0 else 0\n    for y in range(1,Y):\n        for x in range(1,X+1):\n            if A[y][x] == 0:\n                for i in range(-1,2):\n                    S[y][x] += S[y-1][x-i] if A[y-1][x-i] == 0 else 0\n            if A[y][x] == 2:\n                S[y][x] += S[y-1][x] if A[y-1][x] == 0 else 0\n                if y+2 < Y and A[y+2][x] != 1:\n                    S[y+2][x] = S[y][x]\n    ans = 0\n    for x in range(1,X+1):\n        ans += S[Y-1][x] + (S[Y-2][x] if A[Y-2][x] == 2 else 0)\n    print ans"
  },
  {
    "language": "Python",
    "code": "while(1):\n    [X,Y]=[int(x) for x in raw_input().split()]\n    if X==0:\n        break\n    else:\n        F=[]\n        for i in range(Y):\n            F.append([0]+[int(x) for x in raw_input().split()]+[0])\n        F.append([3 for x in range(X+2)])\n        F.append([3 for x in range(X+2)])        \n        S=[[0 for x in range(X+2)] for y in range(Y+2)] #F,S[y][x]\n        #initilizing\n        for i in range(1,X+1):\n            S[0][i]=1-F[0][i]\n        for j in range(Y+2):\n            for i in range(1,X+1):\n                if F[j][i]==2:\n                    S[j][i]=S[j][i]+S[j-1][i]\n                    S[j+2][i]=S[j+2][i]+S[j][i]\n                elif F[j][i]==1:\n                    S[j][i]=0\n                elif F[j][i]==3:\n                    S[j][i]=S[j][i]+S[j-1][i]\n                else:\n                    S[j][i]=S[j][i]+(1-F[j-1][i]/2)*S[j-1][i]+(1-F[j-1][i-1]/2)*S[j-1][i-1]+(1-F[j-1][i+1]/2)*S[j-1][i+1]\n        print sum(S[Y])\n        "
  },
  {
    "language": "Python",
    "code": "def algorithm():\n    def down_jump(x, y, times):\n        if x == r:\n            out_map[x - 1][y] += times\n        elif x == r - 1:\n            out_map[x][y] += times\n        elif in_map[x][y] == 2:\n            down_jump(x + 2, y, times)\n        else:\n            out_map[x][y] += times\n\n    while True:\n        c, r = map(int, input().split())\n        if c == 0 and r == 0:\n            break\n\n        in_map = []\n        out_map = [[0 for _ in range(c)] for _ in range(r)]\n        for _ in range(r):\n            in_map.append(list(map(int, input().split())))\n\n        for i in range(c):\n            if in_map[0][i] == 0 or in_map[0][i] == 2:\n                out_map[0][i] = 1\n\n        for i in range(r):\n            for j in range(c):\n                if in_map[i][j] == 0 or (i == 0 and in_map[i][j] == 2):\n                    # ???.\n                    if i + 1 < r and j > 0 and in_map[i + 1][j - 1] == 0 and in_map[i][j] == 0:\n                        out_map[i + 1][j - 1] += out_map[i][j]\n                    # ???.\n                    if in_map[i][j] == 2:\n                        down_jump(i, j, out_map[i][j])\n                    elif i + 1 < r and in_map[i + 1][j] == 0:\n                        out_map[i + 1][j] += out_map[i][j]\n                    elif i + 1 < r and in_map[i + 1][j] == 2:\n                        down_jump(i + 1, j, out_map[i][j])\n                    # ???.\n                    if i + 1 < r and j + 1 < c and in_map[i + 1][j + 1] == 0 and in_map[i][j] == 0:\n                        out_map[i + 1][j + 1] += out_map[i][j]\n\n        for i in range(c):\n            out_map[r - 1][i] = 0 if in_map[r - 1][i] and in_map[r - 2][i] != 2 else out_map[r - 1][i]\n        print(sum(out_map[r - 1]))\n\n\ndef main():\n    algorithm()\n\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "while(True):\n    X,Y = map(int, input().split())\n    if X==0 and Y==0:\n        break\n    ar = [list(map(int, input().split())) for _ in range(Y)]\n    ar.append([0]*X)\n    br = [[0]*X for _ in range(Y+1)]\n    for j in range(X):\n        if ar[-2][j] != 1:\n            br[-2][j] = 1\n        br[-1][j] = 1\n    for i in range(Y-2,-1,-1):\n        for j in range(X):\n            if j-1 >= 0 and ar[i][j] != 2 and ar[i+1][j-1] == 0: br[i][j] += br[i+1][j-1]\n            if j+1 < X and ar[i][j] != 2 and ar[i+1][j+1] == 0: br[i][j] += br[i+1][j+1]\n            if ar[i][j] != 2 and ar[i+1][j] != 1: br[i][j] += br[i+1][j]\n            if ar[i][j] == 2 and ar[i+2][j] != 1: br[i][j] += br[i+2][j]\n        for j in range(X):\n            if ar[i][j] == 1: br[i][j] = 0\n    print(sum(br[0]))\n\n"
  },
  {
    "language": "Python",
    "code": "while True:\n  x, y = map(int, input().split())\n  if x == 0:\n    break\n  mp = [[1] + list(map(int, input().split())) + [1] for _ in range(y)]\n  mp.insert(0, [1] * (x + 2))\n  mp.append([0] * (x + 2))\n  mp.append([0] * (x + 2))\n  tr = [[0] * (x + 2) for _ in range(y + 2)]\n  \n  for i in range(1, x + 1):\n    if mp[1][i] == 0:\n      tr[1][i] = 1\n  \n  for i in range(2, y + 1):\n    for j in range(1, x + 1):\n      if mp[i][j] == 0:\n        for k in range(j - 1, j + 2):\n          if mp[i - 1][k] == 0:\n            tr[i][j] += tr[i - 1][k]\n        if mp[i - 2][j] == 2:\n          tr[i][j] += tr[i - 2][j]\n  \n      elif mp[i][j] == 2:\n        if mp[i - 1][j] == 0:\n          tr[i][j] += tr[i - 1][j]\n        if mp[i - 2][j] == 2:\n          tr[i][j] += tr[i - 2][j]\n  \n  ans = sum(tr[y])\n  for i in range(1, x + 1):\n    if mp[y - 1][i] == 2:\n      ans += tr[y - 1][i]\n  print(ans)\n"
  },
  {
    "language": "Python",
    "code": "while True:\n    X,Y=map(int,raw_input().split())\n    if X==Y==0:break\n    C=[[0]+map(int,raw_input().split())+[0] for i in range(Y)]\n    C.append([0]*(X+2))\n    dp=[[0]*(X+2) for i in range(Y+1)]\n    for i in range(1,X+1):\n        if C[0][i]!=1:\n            dp[0][i]=1\n    for i in range(Y-1):\n        for j in range(1,X+1):\n            if C[i][j]==0:\n                if C[i+1][j]!=1:\n                    dp[i+1][j]+=dp[i][j]\n                if C[i+1][j+1]!=1 and C[i+1][j+1]!=2:\n                    dp[i+1][j+1]+=dp[i][j]\n                if C[i+1][j-1]!=1 and C[i+1][j-1]!=2:\n                    dp[i+1][j-1]+=dp[i][j]\n            if C[i][j]==2 and C[i+2][j]!=1:\n                dp[i+2][j]+=dp[i][j]\n    print sum(dp[-1][1:-1])+sum(dp[-2][1:-1])"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0203\n\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom collections import deque, defaultdict\ninput = stdin.readline\n\n\ndef solve(field):\n    BLANK, OBSTACLE, JUMP = 0, 1, 2\n    ans = 0                     #  ??????????????°???????????°\n\n    dy = [1, 1, 1]  # ?????????????????????????????????????§???????\n    dx = [0, -1, 1]\n    x_limit = len(field[0])\n    y_limit = len(field)\n\n    path = defaultdict(int)     #  ??????????????????????????°???????????°????????????'x???_y???'???????????????\n    Q = deque()\n    for x, m in enumerate(field[0]):\n        if m == BLANK:              #  ?????????????????°?????´?????????????????????????????????\n            t = '{}_{}'.format(x, 0)\n            Q.append((x, 0))\n            path[t] = 1\n\n    while Q:\n        cx, cy = Q.popleft()        #  ?????¨??°?????§?¨?\n        t = '{}_{}'.format(cx, cy)\n        num = path.pop(t)\n\n        if field[cy][cx] == OBSTACLE:\n            continue\n        elif field[cy][cx] == JUMP: #  ?????£????????§?????°?????????????????£????????°\n            if cy+2 > y_limit-1:\n                ans += num\n            else:\n                t = '{}_{}'.format(cx, cy+2)\n                if not path[t]:\n                    Q.append((cx, cy+2))\n                path[t] += num\n            continue\n        elif cy == y_limit -1:\n            ans += num\n            continue\n\n        for i in range(len(dx)):\n            nx = cx + dx[i]     #  ?????°????????§?¨?\n            ny = cy + dy[i]\n\n            if 0<= nx < x_limit:\n                if (ny >= y_limit - 1) and field[ny][nx] == BLANK:\n                    ans += num\n                else:\n                    if field[ny][nx] == JUMP and dx[i] == 0: #  ?????£????????°????????£??????????????\\????????´???\n                        if ny+2 > y_limit - 1:\n                            ans += num\n                        else:\n                            t = '{}_{}'.format(nx, ny+2)\n                            if not path[t]:\n                                Q.append((nx, ny+2))\n                            path[t] += num\n                    elif field[ny][nx] == BLANK:\n                        t = '{}_{}'.format(nx, ny)\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans\n\n\ndef main(args):\n    while True:\n        X, Y = map(int, input().strip().split())\n        if X == 0 and Y == 0:\n            break\n        field = []\n        for _ in range(Y):\n            temp = [int(x) for x in input().strip().split()]\n            field.append(temp)\n        result = solve(field)\n        print(result)\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0203\n\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom collections import deque, defaultdict\ninput = stdin.readline\n\n\ndef solve(field):\n    BLANK, OBSTACLE, JUMP = 0, 1, 2\n    ans = 0                     #  ??????????????°???????????°\n\n    dy = [1, 1, 1]  # ?????????????????????????????????????§???????\n    dx = [0, -1, 1]\n    x_limit = len(field[0])\n    y_limit = len(field)\n\n    path = defaultdict(int)     #  ??????????????????????????°???????????°????????????'x???_y???'???????????????\n    Q = deque()\n    for x, m in enumerate(field[0]):\n        if m == BLANK:              #  ?????????????????°?????´?????????????????????????????????\n            t = '{}_{}'.format(x, 0)\n            Q.append((x, 0))\n            path[t] = 1\n    if y_limit < 2:\n        return len(Q)\n\n\n    while Q:\n        cx, cy = Q.popleft()        #  ?????¨??°?????§?¨?\n        t = '{}_{}'.format(cx, cy)\n        num = path.pop(t)\n\n        if cy > y_limit - 1:\n            continue\n        if field[cy][cx] == OBSTACLE:\n            continue\n        if field[cy][cx] == JUMP: #  ?????£????????§?????°?????????????????£????????°\n            if cy+2 >= y_limit-1:\n                ans += num\n            else:\n                t = '{}_{}'.format(cx, cy+2)\n                if not path[t]:\n                    Q.append((cx, cy+2))\n                path[t] += num\n            continue\n\n        for i in range(len(dx)):\n            nx = cx + dx[i]     #  ?????°????????§?¨?\n            ny = cy + dy[i]\n\n            if 0<= nx < x_limit:\n                if (ny >= y_limit - 1) and field[ny][nx] != OBSTACLE:\n                    ans += num\n                else:\n                    if field[ny][nx] == JUMP and dx[i] == 0: #  ?????£????????°????????£??????????????\\????????´???\n                        if ny+2 > y_limit - 1:\n                            ans += num\n                        else:\n                            t = '{}_{}'.format(nx, ny+2)\n                            if not path[t]:\n                                Q.append((nx, ny+2))\n                            path[t] += num\n                    elif field[ny][nx] == BLANK:\n                        t = '{}_{}'.format(nx, ny)\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans\n\n\ndef main(args):\n    while True:\n        X, Y = map(int, input().strip().split())\n        if X == 0 and Y == 0:\n            break\n        field = []\n        for _ in range(Y):\n            temp = [int(x) for x in input().strip().split()]\n            field.append(temp)\n        result = solve(field)\n        print(result)\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0203\n\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom collections import deque, defaultdict\ninput = stdin.readline\n\n\ndef solve(field):\n    BLANK, OBSTACLE, JUMP = 0, 1, 2\n    ans = 0                     #  ??????????????°???????????°\n\n    dy = [1, 1, 1]  # ?????????????????????????????????????§???????\n    dx = [0, -1, 1]\n    x_limit = len(field[0])\n    y_limit = len(field)\n\n    path = defaultdict(int)     #  ??????????????????????????°???????????°????????????'x???_y???'???????????????\n    Q = deque()\n    for x, m in enumerate(field[0]):\n        if m == BLANK:              #  ?????????????????°?????´?????????????????????????????????\n            t = '{}_{}'.format(x, 0)\n            Q.append((x, 0))\n            path[t] = 1\n    if y_limit < 2:\n        return len(Q)\n\n\n    while Q:\n        cx, cy = Q.popleft()        #  ?????¨??°?????§?¨?\n        t = '{}_{}'.format(cx, cy)\n        num = path.pop(t)\n\n        if field[cy][cx] == JUMP: #  ?????£????????§?????°?????????????????£????????°\n            if cy+2 > y_limit-1:\n                ans += num\n            else:\n                t = '{}_{}'.format(cx, cy+2)\n                if not path[t]:\n                    Q.append((cx, cy+2))\n                path[t] += num\n            continue\n        elif cy == y_limit -1:\n            ans += num\n            continue\n\n        for i in range(len(dx)):\n            nx = cx + dx[i]     #  ?????°????????§?¨?\n            ny = cy + dy[i]\n\n            if 0<= nx < x_limit:\n                if (ny >= y_limit - 1) and field[ny][nx] != OBSTACLE:\n                    ans += num\n                else:\n                    if field[ny][nx] == JUMP and dx[i] == 0: #  ?????£????????°????????£??????????????\\????????´???\n                        if ny+2 > y_limit - 1:\n                            ans += num\n                        else:\n                            t = '{}_{}'.format(nx, ny+2)\n                            if not path[t]:\n                                Q.append((nx, ny+2))\n                            path[t] += num\n                    elif field[ny][nx] == BLANK:\n                        t = '{}_{}'.format(nx, ny)\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans\n\n\ndef main(args):\n    while True:\n        X, Y = map(int, input().strip().split())\n        if X == 0 and Y == 0:\n            break\n        field = []\n        for _ in range(Y):\n            temp = [int(x) for x in input().strip().split()]\n            field.append(temp)\n        result = solve(field)\n        print(result)\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])"
  },
  {
    "language": "Python",
    "code": "while(1):\n    [X,Y]=[int(x) for x in raw_input().split()]\n    if X==0:\n        break\n    else:\n        F=[]\n        for i in range(Y):\n            F.append([0]+[int(x) for x in raw_input().split()]+[0])\n        F.append([3 for x in range(X+2)])\n        F.append([4 for x in range(X+2)])        \n        S=[[0 for x in range(X+2)] for y in range(Y+2)] #F,S[y][x]\n        #initilizing\n        for i in range(1,X+1):\n            S[0][i]=1-F[0][i]\n        for j in range(Y+2):\n            for i in range(1,X+1):\n                if F[j][i]==2:\n                    S[j][i]=S[j][i]+(1-F[j-1][i]/2)*S[j-1][i]\n                    S[j+2][i]=S[j+2][i]+S[j][i]\n                elif F[j][i]==1:\n                    S[j][i]=0\n                elif F[j][i]==3:\n                    S[j][i]=S[j][i]+(1-F[j-1][i]/2)*S[j-1][i]\n                elif F[j][i]==4:\n                    S[j][i]=S[j][i]+S[j-1][i]                    \n                else:\n                    S[j][i]=S[j][i]+(1-F[j-1][i]/2)*S[j-1][i]+(1-F[j-1][i-1]/2)*S[j-1][i-1]+(1-F[j-1][i+1]/2)*S[j-1][i+1]\n        print sum(S[Y+1])\n        "
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0203\n\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom collections import deque, defaultdict\ninput = stdin.readline\n\n\ndef solve(field):\n    # 0: ????????°, 1: ?????????, 2: ?????£????????°\n    ans = 0\n\n    # ??????????????????????????????\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = len(field[0])\n    y_limit = len(field)\n\n    path = defaultdict(int)     #  ??????????????????????????°???????????°\n    Q = deque()\n    for x, m in enumerate(field[0]):\n        if m == 0:\n            Q.append((x, 0))\n            t = '{}_{}'.format(x, 0)\n            path[t] = 1\n    if x_limit == 1:\n        return len(Q)\n\n    while Q:\n        cx, cy = Q.popleft()        #  ?????¨??°?????§?¨?\n        t = '{}_{}'.format(cx, cy)\n        num = path.pop(t)\n\n        if field[cy][cx] == 2:\n            if cy+2 >= y_limit-1:\n                ans += num\n            else:\n                t = '{}_{}'.format(cx, cy)\n                if path[t]:\n                    path[t] += num\n                else:\n                    Q.append((cx, cy+2))\n                    path[t] = num\n            continue\n\n\n        for i in range(len(dx)):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            #  ?§????????????§???????????? ?????? ??¢?????¢?´¢?????§???????????°??????????????§?????¢?´¢????¶???????\n            if 0<= nx < x_limit:\n                if ny >= y_limit - 1 and field[ny][nx] != 1:\n                    ans += num\n                else:\n                    if field[ny][nx] == 2 and dx[i] == 0:\n                        if ny+2 >= y_limit - 1:\n                            ans += num\n                        else:\n                            t = '{}_{}'.format(nx, ny+2)\n                            if path[t]:\n                                path[t] += num\n                            else:\n                                path[t] = num\n                                Q.append((nx, ny+2))\n                    elif field[ny][nx] == 0:\n                        t = '{}_{}'.format(nx, ny)\n                        if path[t]:\n                            path[t] += num\n                        else:\n                            path[t] = num\n                            Q.append((nx, ny))\n    return ans\n\n\ndef main(args):\n    while True:\n        X, Y = map(int, input().strip().split())\n        if X == 0 and Y == 0:\n            break\n        field = []\n        for _ in range(Y):\n            temp = [int(x) for x in input().strip().split()]\n            field.append(temp)\n        result = solve(field)\n        print(result)\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n    "
  },
  {
    "language": "Python",
    "code": "\"\"\" Created by Jieyi on 8/16/16. \"\"\"\n\n\ndef algorithm():\n    def down_jump(x, y, times):\n        if x == r:\n            out_map[x - 1][y] += times\n        elif x == r - 1:\n            out_map[x][y] += times\n        elif in_map[x][y] == 2:\n            down_jump(x + 2, y, times)\n        else:\n            out_map[x][y] += times\n\n    while True:\n        c, r = map(int, input().split())\n        if c == 0 and r == 0:\n            break\n\n        in_map = []\n        out_map = [[0 for _ in range(c)] for _ in range(r)]\n        for _ in range(r):\n            in_map.append(list(map(int, input().split())))\n\n        for i in range(c):\n            if in_map[0][i] == 0 or in_map[0][i] == 2:\n                out_map[0][i] = 1\n\n        for i in range(r):\n            for j in range(c):\n                if in_map[i][j] == 0:\n                    # ???.\n                    if i + 1 < r and j > 0 and in_map[i + 1][j - 1] == 0:\n                        out_map[i + 1][j - 1] += out_map[i][j]\n                    # ???.\n                    if i + 1 < r and in_map[i + 1][j] == 0:\n                        out_map[i + 1][j] += out_map[i][j]\n                    elif i + 1 < r and in_map[i + 1][j] == 2:\n                        down_jump(i + 1, j, out_map[i][j])\n                    # ???.\n                    if i + 1 < r and j + 1 < c and in_map[i + 1][j + 1] == 0:\n                        out_map[i + 1][j + 1] += out_map[i][j]\n\n        print(sum(out_map[r - 1]))\n\n\ndef main():\n    algorithm()\n\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "def algorithm():\n    def down_jump(x, y, times):\n        if x == r:\n            out_map[x - 1][y] += times\n        elif x == r - 1:\n            out_map[x][y] += times\n        elif in_map[x][y] == 2:\n            down_jump(x + 2, y, times)\n        else:\n            out_map[x][y] += times\n\n    while True:\n        c, r = map(int, input().split())\n        if c == 0 and r == 0:\n            break\n\n        in_map = []\n        out_map = [[0 for _ in range(c)] for _ in range(r)]\n        for _ in range(r):\n            in_map.append(list(map(int, input().split())))\n\n        for i in range(c):\n            if in_map[0][i] == 0 or in_map[0][i] == 2:\n                out_map[0][i] = 1\n\n        for i in range(r):\n            for j in range(c):\n                if in_map[i][j] == 0 or (i == 0 and in_map[i][j] == 2):\n                    # ???.\n                    if i + 1 < r and j > 0 and in_map[i + 1][j - 1] == 0 and in_map[i][j] == 0:\n                        out_map[i + 1][j - 1] += out_map[i][j]\n                    # ???.\n                    if in_map[i][j] == 2:\n                        down_jump(i, j, out_map[i][j])\n                    elif i + 1 < r and in_map[i + 1][j] == 0:\n                        out_map[i + 1][j] += out_map[i][j]\n                    elif i + 1 < r and in_map[i + 1][j] == 2:\n                        down_jump(i + 1, j, out_map[i][j])\n                    # ???.\n                    if i + 1 < r and j + 1 < c and in_map[i + 1][j + 1] == 0 and in_map[i][j] == 0:\n                        out_map[i + 1][j + 1] += out_map[i][j]\n\n        print(sum(out_map[r - 1]))\n\n\ndef main():\n    algorithm()\n\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0203\n\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom collections import deque, defaultdict\ninput = stdin.readline\n\n\ndef solve(field):\n    # 0: ????????°, 1: ?????????, 2: ?????£????????°\n    ans = 0\n\n    # ??????????????????????????????\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = len(field[0])\n    y_limit = len(field)\n\n    path = defaultdict(int)     #  ??????????????????????????°???????????°\n    Q = deque()\n    for x, m in enumerate(field[0]):\n        if m == 0:\n            Q.append((x, 0))\n            t = '{}_{}'.format(x, 0)\n            path[t] = 1\n    if y_limit < 2:\n        return len(Q)\n\n    while Q:\n        cx, cy = Q.popleft()        #  ?????¨??°?????§?¨?\n        t = '{}_{}'.format(cx, cy)\n        num = path.pop(t)\n\n        if field[cy][cx] == 2:\n            if cy+2 >= y_limit-1:\n                ans += num\n            else:\n                t = '{}_{}'.format(cx, cy)\n                if path[t]:\n                    path[t] += num\n                else:\n                    Q.append((cx, cy+2))\n                    path[t] = num\n            continue\n\n\n        for i in range(len(dx)):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            #  ?§????????????§???????????? ?????? ??¢?????¢?´¢?????§???????????°??????????????§?????¢?´¢????¶???????\n            if 0<= nx < x_limit:\n                if ny >= y_limit - 1 and field[ny][nx] != 1:\n                    ans += num\n                else:\n                    if field[ny][nx] == 2 and dx[i] == 0:\n                        if ny+2 >= y_limit - 1:\n                            ans += num\n                        else:\n                            t = '{}_{}'.format(nx, ny+2)\n                            if path[t]:\n                                path[t] += num\n                            else:\n                                path[t] = num\n                                Q.append((nx, ny+2))\n                    elif field[ny][nx] == 0:\n                        t = '{}_{}'.format(nx, ny)\n                        if path[t]:\n                            path[t] += num\n                        else:\n                            path[t] = num\n                            Q.append((nx, ny))\n    return ans\n\n\ndef main(args):\n    while True:\n        X, Y = map(int, input().strip().split())\n        if X == 0 and Y == 0:\n            break\n        field = []\n        for _ in range(Y):\n            temp = [int(x) for x in input().strip().split()]\n            field.append(temp)\n        result = solve(field)\n        print(result)\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n    "
  },
  {
    "language": "Python",
    "code": "\"\"\" Created by Jieyi on 8/16/16. \"\"\"\n\n\ndef algorithm():\n    def down_jump(x, y, times):\n        if x == r:\n            out_map[x - 1][y] += times\n        elif x == r - 1:\n            out_map[x][y] += times\n        elif in_map[x][y] == 2:\n            down_jump(x + 2, y, times)\n        else:\n            out_map[x][y] += times\n\n    while True:\n        c, r = map(int, input().split())\n        if c == 0 and r == 0:\n            break\n\n        in_map = []\n        out_map = [[0 for _ in range(c)] for _ in range(r)]\n        for _ in range(r):\n            in_map.append(list(map(int, input().split())))\n\n        for i in range(r):\n            if in_map[0][i] == 0:\n                out_map[0][i] = 1\n\n        for i in range(r):\n            for j in range(c):\n                if in_map[i][j] == 0:\n                    # ???.\n                    if i + 1 < r and j > 0 and in_map[i + 1][j - 1] == 0:\n                        out_map[i + 1][j - 1] += out_map[i][j]\n                    # ???.\n                    if i + 1 < r and in_map[i + 1][j] == 0:\n                        out_map[i + 1][j] += out_map[i][j]\n                    elif i + 1 < r and in_map[i + 1][j] == 2:\n                        down_jump(i + 1, j, out_map[i][j])\n                    # ???.\n                    if i + 1 < r and j + 1 < c and in_map[i + 1][j + 1] == 0:\n                        out_map[i + 1][j + 1] += out_map[i][j]\n\n        print(sum(out_map[c - 1]))\n\n\ndef main():\n    algorithm()\n\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0203\n\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom collections import deque, defaultdict\ninput = stdin.readline\n\n\ndef solve(field):\n    # 0: ????????°, 1: ?????????, 2: ?????£????????°\n    ans = 0                     #  ??????????????°???????????°\n\n    dy = [1, 1, 1]  # ?????????????????????????????????????§???????\n    dx = [0, -1, 1]\n    x_limit = len(field[0])\n    y_limit = len(field)\n\n    path = defaultdict(int)     #  ??????????????????????????°???????????°????????????'x???_y???'???????????????\n    Q = deque()\n    for x, m in enumerate(field[0]):\n        if m == 0:              #  ?????????????????°?????´?????????????????????????????????\n            t = '{}_{}'.format(x, 0)\n            Q.append((x, 0))\n            path[t] = 1\n    if y_limit < 2:\n        return len(Q)\n\n\n    while Q:\n        cx, cy = Q.popleft()        #  ?????¨??°?????§?¨?\n        t = '{}_{}'.format(cx, cy)\n        num = path.pop(t)\n\n        if cy >= y_limit - 1:\n            continue\n\n        if field[cy][cx] == 1:  #  ?????£????????§?????°?????????????????????\n            continue\n        elif field[cy][cx] == 2: #  ?????£????????§?????°?????????????????£????????°\n            if cy+2 >= y_limit-1:\n                ans += num\n            else:\n                t = '{}_{}'.format(cx, cy+2)\n                if not path[t]:\n                    Q.append((cx, cy+2))\n                path[t] += num\n            continue\n\n        for i in range(len(dx)):\n            nx = cx + dx[i]     #  ?????°????????§?¨?\n            ny = cy + dy[i]\n\n            if 0<= nx < x_limit:\n                if (ny >= y_limit - 1) and field[ny][nx] != 1:\n                    ans += num\n                else:\n                    if field[ny][nx] == 2 and dx[i] == 0: #  ?????£????????°????????£??????????????\\????????´???\n                        if ny+2 > y_limit - 1:\n                            ans += num\n                        else:\n                            t = '{}_{}'.format(nx, ny+2)\n                            if not path[t]:\n                                Q.append((nx, ny+2))\n                            path[t] += num\n                    elif field[ny][nx] == 0:\n                        t = '{}_{}'.format(nx, ny)\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans\n\n\ndef main(args):\n    while True:\n        X, Y = map(int, input().strip().split())\n        if X == 0 and Y == 0:\n            break\n        field = []\n        for _ in range(Y):\n            temp = [int(x) for x in input().strip().split()]\n            field.append(temp)\n        result = solve(field)\n        print(result)\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])"
  },
  {
    "language": "Python",
    "code": "\"\"\" Created by Jieyi on 8/16/16. \"\"\"\n\n\ndef algorithm():\n    def down_jump(x, y, times):\n        if x == r:\n            out_map[x - 1][y] += times\n        elif in_map[x][y] == 2:\n            down_jump(x + 2, y, times)\n        else:\n            out_map[x][y] += times\n\n    while True:\n        c, r = map(int, input().split())\n        if c == 0 and r == 0:\n            break\n\n        in_map = []\n        out_map = [[0 for _ in range(c)] for _ in range(r)]\n        for _ in range(r):\n            in_map.append(list(map(int, input().split())))\n\n        for i in range(r):\n            if in_map[0][i] == 0:\n                out_map[0][i] = 1\n\n        for i in range(r):\n            for j in range(c):\n                if in_map[i][j] == 0:\n                    # ???.\n                    if i + 1 < r and j > 0 and in_map[i + 1][j - 1] == 0:\n                        out_map[i + 1][j - 1] += out_map[i][j]\n                    # ???.\n                    if i + 1 < r and in_map[i + 1][j] == 0:\n                        out_map[i + 1][j] += out_map[i][j]\n                    elif i + 1 < r and in_map[i + 1][j] == 2:\n                        down_jump(i + 1, j, out_map[i][j])\n                    # ???.\n                    if i + 1 < r and j + 1 < c and in_map[i + 1][j + 1] == 0:\n                        out_map[i + 1][j + 1] += out_map[i][j]\n\n        print(sum(out_map[c - 1]))\n\n\ndef main():\n    algorithm()\n\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0203\n\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom collections import deque, defaultdict\ninput = stdin.readline\n\n\ndef solve(field):\n    BLANK, OBSTACLE, JUMP = 0, 1, 2\n    ans = 0                     #  ??????????????°???????????°\n\n    dy = [1, 1, 1]  # ?????????????????????????????????????§???????\n    dx = [0, -1, 1]\n    x_limit = len(field[0])\n    y_limit = len(field)\n\n    path = defaultdict(int)     #  ??????????????????????????°???????????°????????????'x???_y???'???????????????\n    Q = deque()\n    for x, m in enumerate(field[0]):\n        if m == BLANK:              #  ?????????????????°?????´?????????????????????????????????\n            t = '{}_{}'.format(x, 0)\n            Q.append((x, 0))\n            path[t] = 1\n    if y_limit < 2:\n        return len(Q)\n\n\n    while Q:\n        cx, cy = Q.popleft()        #  ?????¨??°?????§?¨?\n        t = '{}_{}'.format(cx, cy)\n        num = path.pop(t)\n\n        if field[cy][cx] == OBSTACLE:\n            continue\n        if field[cy][cx] == JUMP: #  ?????£????????§?????°?????????????????£????????°\n            if cy+2 >= y_limit-1:\n                ans += num\n            else:\n                t = '{}_{}'.format(cx, cy+2)\n                if not path[t]:\n                    Q.append((cx, cy+2))\n                path[t] += num\n            continue\n\n        for i in range(len(dx)):\n            nx = cx + dx[i]     #  ?????°????????§?¨?\n            ny = cy + dy[i]\n\n            if 0<= nx < x_limit:\n                if (ny >= y_limit - 1) and field[ny][nx] != OBSTACLE:\n                    ans += num\n                else:\n                    if field[ny][nx] == JUMP and dx[i] == 0: #  ?????£????????°????????£??????????????\\????????´???\n                        if ny+2 > y_limit - 1:\n                            ans += num\n                        else:\n                            t = '{}_{}'.format(nx, ny+2)\n                            if not path[t]:\n                                Q.append((nx, ny+2))\n                            path[t] += num\n                    elif field[ny][nx] == BLANK:\n                        t = '{}_{}'.format(nx, ny)\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans\n\n\ndef main(args):\n    while True:\n        X, Y = map(int, input().strip().split())\n        if X == 0 and Y == 0:\n            break\n        field = []\n        for _ in range(Y):\n            temp = [int(x) for x in input().strip().split()]\n            field.append(temp)\n        result = solve(field)\n        print(result)\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])"
  },
  {
    "language": "Python",
    "code": "while 1:\n\tX,Y = map(int,raw_input().split())\n\tif X == 0: break\n\tA = [[0]+map(int,raw_input().split())+[0] for i in range(Y)]\n\tS = [[0]*(X+2) for i in range(Y)]\n\tfor x in range(1,X+1): S[0][x] = 1 if A[0][x] != 1 else 0\n\tfor y in range(1,Y):\n\t\tfor x in range(1,X+1):\n\t\t\tif A[y][x] == 0:\n\t\t\t\tfor i in range(-1,2):\n\t\t\t\t\tS[y][x] += (S[y-1][x-i] if A[y-1][x-i] == 0 else 0)\n\t\t\tif A[y][x] == 2:\n\t\t\t\tS[y][x] += S[y-1][x-1]\n\t\t\t\tif y+2 < Y and A[y+2][x] != 1:\n\t\t\t\t\tS[y+2][x] = S[y][x]\n\tans = 0\n\tfor x in range(1,X+1):\n\t\tans += S[Y-1][x] + (S[Y-2][x] if A[Y-2][x] == 2 else 0)\n\tprint ans"
  },
  {
    "language": "Python",
    "code": "while True:\n    X,Y=map(int,raw_input().split())\n    if X==Y==0:break\n    C=[[0]+map(int,raw_input().split())+[0] for i in range(Y)]\n    C.append([0]*(X+2))\n    dp=[[0]*(X+2) for i in range(Y+1)]\n    for i in range(1,X+1):\n        if C[0][i]!=1:\n            dp[0][i]=1\n    for i in range(Y-1):\n        for j in range(1,X+1):\n            if C[i][j]==0:\n                if C[i+1][j]!=1:\n                    dp[i+1][j]+=dp[i][j]\n                if C[i+1][j+1]!=1 and C[i+1][j+1]!=2:\n                    dp[i+1][j+1]+=dp[i][j]\n                if C[i+1][j-1]!=1 and C[i+1][j-1]!=2:\n                    dp[i+1][j-1]+=dp[i][j]\n            if C[i][j]==2:\n                dp[i+2][j]+=dp[i][j]\n    print sum(dp[-1][1:-1])+sum(dp[-2][1:-1])"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0203\n\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom collections import deque, defaultdict\ninput = stdin.readline\n\n\ndef solve(field):\n0 0    # 0: ????????°, 1: ?????????, 2: ?????£????????°\n    course = 0\n\n    # ??????????????????????????????\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = len(field[0])\n    y_limit = len(field)\n\n    path = defaultdict(int)\n    Q = deque()\n    for x, m in enumerate(field[0]):\n        if m == 0:\n            Q.append((x, 0))\n            t = '{}_{}'.format(x, 0)\n            path[t] = 1\n\n    while Q:\n        cx, cy = Q.popleft()        #  ?????¨??°?????§?¨?\n        t = '{}_{}'.format(cx, cy)\n        num = path.pop(t)\n        if cy+1 == y_limit:\n            course += num\n            continue\n        if field[cy][cx] == 2:\n            if cy+2 >= y_limit:\n                course += num\n            else:\n                t = '{}_{}'.format(cx, cy)\n                if path[t]:\n                    path[t] += num\n                else:\n                    Q.append((cx, cy+2))\n                    path[t] = num\n            continue\n        for i in range(len(dx)):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            #  ?§????????????§???????????? ?????? ??¢?????¢?´¢?????§???????????°??????????????§?????¢?´¢????¶???????\n            if 0<= nx < x_limit:\n                if ny >= y_limit:\n                    course += num\n                else:\n                    if field[ny][nx] == 2 and dx[i] == 0:\n                        if ny+2 >= y_limit:\n                            course += num\n                        else:\n                            t = '{}_{}'.format(nx, ny+2)\n                            if path[t]:\n                                path[t] += num\n                            else:\n                                path[t] = num\n                                Q.append((nx, ny+2))\n                    elif field[ny][nx] == 0:\n                        t = '{}_{}'.format(nx, ny)\n                        if path[t]:\n                            path[t] += num\n                        else:\n                            path[t] = num\n                            Q.append((nx, ny))\n    return course\n\n\n\ndef main(args):\n    while True:\n        X, Y = map(int, input().split())\n        if X == 0 and Y == 0:\n            break\n        field = []\n        for _ in range(Y):\n            temp = [int(x) for x in input().split()]\n            field.append(temp)\n        result = solve(field)\n        print(result)\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n    "
  },
  {
    "language": "Python",
    "code": "\"\"\" Created by Jieyi on 8/16/16. \"\"\"\n\n\ndef algorithm():\n    def down_jump(x, y, times):\n        if x == r:\n            out_map[x - 1][y] += times\n        elif x == r - 1:\n            out_map[x][y] += times\n        elif in_map[x][y] == 2:\n            down_jump(x + 2, y, times)\n        else:\n            out_map[x][y] += times\n\n    while True:\n        c, r = map(int, input().split())\n        if c == 0 and r == 0:\n            break\n\n        in_map = []\n        out_map = [[0 for _ in range(c)] for _ in range(r)]\n        for _ in range(r):\n            in_map.append(list(map(int, input().split())))\n\n        for i in range(c):\n            if in_map[0][i] == 0 or in_map[0][i] == 2:\n                out_map[0][i] = 1\n\n        for i in range(r):\n            for j in range(c):\n                if in_map[i][j] == 0:\n                    # ???.\n                    if i + 1 < r and j > 0 and in_map[i + 1][j - 1] == 0:\n                        out_map[i + 1][j - 1] += out_map[i][j]\n                    # ???.\n                    if i + 1 < r and in_map[i + 1][j] == 0:\n                        out_map[i + 1][j] += out_map[i][j]\n                    elif i + 1 < r and in_map[i + 1][j] == 2:\n                        down_jump(i + 1, j, out_map[i][j])\n                    # ???.\n                    if i + 1 < r and j + 1 < c and in_map[i + 1][j + 1] == 0:\n                        out_map[i + 1][j + 1] += out_map[i][j]\n\n        print(out_map)\n        print(sum(out_map[c - 1]))\n\n\ndef main():\n    algorithm()\n\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "while True:\n    X, Y = map(int, raw_input().split())\n    if (X, Y) == (0, 0):\n        break\n    grid = [map(int, raw_input().split()) for _ in xrange(Y)] + [[0] * X]\n    D = (((-1, 1), (0, 1), (1, 1)), (), ((0, 2),))\n    dp = [[1] * X] + [[0] * X for _ in xrange(Y+2)]\n    for y in xrange(Y-1):\n        for x in xrange(X):\n            for dx, dy in D[grid[y][x]]:\n                nx, ny = x + dx, y + dy\n                if nx < 0 or X <= nx or y < 0 or Y+1 <= ny:\n                    continue\n                if grid[ny][nx] == 2 and nx != x:\n                    continue\n                dp[ny][nx] += dp[y][x]\n    print sum(sum(dp[y][x] for x in xrange(X) if grid[y][x] != 1) for y in xrange(Y-1, Y+1))"
  },
  {
    "language": "Python",
    "code": "def solve(c):\n    w, h = len(c[0]), len(c)\n    dp = [[0] * w for _ in range(h)]\n    \n    #?????????\n    for x in range(w):\n        if c[1][x] == 0:\n            dp[1][x] = 1\n    \n    for y in range(2, h):\n        for x in range(w):\n            if c[y][x] == 1:\n                continue\n            if c[y - 2][x] == 2:\n                dp[y][x] += dp[y - 2][x]\n            if c[y - 1][x] == 0:\n                dp[y][x] += dp[y - 1][x]\n                \n            if c[y][x] == 0:\n                if c[y - 1][x - 1] == 0:\n                    dp[y][x] += dp[y - 1][x - 1]\n                if c[y - 1][x + 1] == 0:\n                    dp[y][x] += dp[y - 1][x + 1]\n\n    return sum(dp[-1]) + sum(dp[-2][x] for x in range(w) if c[-2][x] == 2)\n\nimport sys\nf = sys.stdin\n\nwhile True:\n    w, h = map(int, f.readline().split())\n    if w == 0:\n        break\n    course = [[1] * (w + 2)] + [[1] + list(map(int, f.readline().split())) + [1] for _ in range(h)]\n    print(solve(course))"
  },
  {
    "language": "Rust",
    "code": "fn main(){\n  loop {\n    let xy: Vec<usize> = read_vec();\n    let x = xy[0];\n    let y = xy[1];\n\n    if x == 0 && y == 0 { break; }\n\n    let mut fv: Vec<Vec<usize>> = Vec::new();\n\n    for _ in 0 .. y {\n      fv.push(read_vec());\n    }\n    \n    let mut dp: Vec<Vec<usize>> = vec![vec![0;x];y];\n\n    for i in 0 .. x {\n      if fv[0][i] != 1 { dp[0][i] = 1; }\n    }\n\n    for i in 1 .. y {\n      for j in 0 .. x {\n        if fv[i][j] == 0 {\n          if j > 0 && fv[i-1][j-1] == 0 {\n            dp[i][j] += dp[i-1][j-1];\n          }\n          if fv[i-1][j] == 0 {\n            dp[i][j] += dp[i-1][j];\n          }\n          if j + 1 < x && fv[i-1][j+1] == 0 {\n            dp[i][j] += dp[i-1][j+1];\n          }\n          if i > 1 && fv[i-2][j] == 2 {\n            dp[i][j] += dp[i-2][j];\n          }\n        } else if fv[i][j] == 2 {\n          if fv[i-1][j] == 0 {\n            dp[i][j] += dp[i-1][j];\n          }\n          if i > 1 && fv[i-2][j] == 2 {\n            dp[i][j] += dp[i-2][j];\n          }\n        }\n      }\n    }\n    \n    let mut ans: usize = 0;\n\n    for i in 0 .. x {\n      ans += dp[y-1][i];\n    }\n\n    if y > 1 {\n      for i in 0 .. x {\n        if fv[y-2][i] == 2 {\n          ans += dp[y-2][i];\n        }\n      }\n    }\n\n    println!(\"{}\", ans);\n  }\n}\n\nfn read_vec<T>() -> Vec<T>\n  where T: std::str::FromStr,\n        T::Err: std::fmt::Debug\n{\n  let mut buf = String::new();\n  std::io::stdin().read_line(&mut buf).expect(\"failed to read\");\n  buf.split_whitespace().map(|e| e.parse().unwrap()).collect()\n}\n\n"
  }
]