[
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <assert.h>\n#define int long long\n#define N_MAX (100000)\n#define min(a,b) (((a)<(b))?(a):(b))\ntypedef struct {\n\tint pos,value;\n} Info;\n\nsigned main(){\n\tint damage_total[N_MAX]={};\n\tInfo deque[N_MAX];\n\tint head=0,tail=0;\n\tint N,H;\n\tint answer = 0;\n\n\tscanf(\"%lld%lld\",&N,&H);\t\n\tint currentHP = H;\n\tfor(int i = 0 ; i < N-1 ; i++){\n\t\tint d,h;\n\t\tscanf(\"%lld%lld\",&d,&h);\n\t\twhile( head != tail && deque[tail-1].value <= h ) tail--;\n\n\t\tdeque[tail++] = (Info){i,h};\n\t\twhile( head != tail ){\n\t\t\tint maximumRecover = H - (damage_total[i] - damage_total[deque[head].pos]);\n\t\t\tif( maximumRecover > 0 ) break;\n\t\t\thead++;\n\t\t}\n\n\t\tfor(int j = head ; j < tail && currentHP <= d ; j++){\n\t\t\t// ????????§???????????§????????????\n\t\t\tint maximumRecover = H - (damage_total[i] - damage_total[deque[j].pos]);\n\t\t\t// j??????????????§?????????????????? needRecover ????¨????\n\t\t\tint needRecover = min( maximumRecover - currentHP , d - currentHP + 1);  \n\t\t\t// ???????????? needRecover ?????????????????????????????° useCount ????±???????\n\t\t\tint useCount = (needRecover+deque[j].value-1) / deque[j].value - 1;\n\t\t\tanswer += useCount;\n\t\t\tcurrentHP += useCount*deque[j].value;\n\t\t\t// ????°??????????????¬????????´?????????£?????´?????¨??????????´?????????£?????´??????????????????????????????????????????????´??????????\t\t\t\n\t\t\tif( j+1 ==  tail || maximumRecover > currentHP + deque[j+1].value ){\n\t\t\t\tcurrentHP = min(currentHP+deque[j].value,maximumRecover);\n\t\t\t\tanswer++;\n\t\t\t}\n\t\t}\n\t\tcurrentHP -= d;\n\t\tdamage_total[i+1] = damage_total[i] + d;\n\n\t}\n\tprintf(\"%lld\\n\",answer);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint N, H, d[100009], h[100009], dp[1009][1009];\nint main() {\n\tcin >> N >> H;\n\tassert(N <= 1000 && H <= 1000);\n\tfor (int i = 0; i < N - 1; i++) cin >> d[i] >> h[i];\n\tfor (int i = 0; i < N - 1; i++) {\n\t\tfill(dp[i + 1], dp[i + 1] + H + 1, 999999999);\n\t\tfor (int j = 1; j <= H - d[i]; j++) {\n\t\t\tint h2 = j + d[i];\n\t\t\tfor (int k = 0; h2 - (k - 1) * h[i] > 0; k++) {\n\t\t\t\tdp[i + 1][j] = min(dp[i + 1][j], dp[i][max(h2 - k * h[i], 1)] + k);\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[N - 1][1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\nusing namespace std;\ntypedef long long ll;\nint n;\nll segAdd[444444],segMax[444444];\nvoid init(int n_){\n  n = 1;\n  while( n < n_) n *= 2;\n}\n\n//[a,b)\nvoid add(int a,int b,int x,int k,int l,int r){\n  if(r <= a || b <= l) return;\n\n  if(a <= l && r <= b){\n    segAdd[k] += x;\n    while(k){\n      k = (k-1)/2;\n      segMax[k] = max(segMax[2*k+1] + segAdd[2*k+1],segMax[2*k+2] + segAdd[2*k+2]);\n    }\n  }else{\n    add(a,b,x,2*k+1,l,(l+r)/2);\n    add(a,b,x,2*k+2,(l+r)/2,r);\n  }\n}\n\nll getMax(int a,int b,int k,int l,int r){\n  if(r <= a || b <= l) return -11111111111;\n\n  if(a <= l && r <= b) return segMax[k] + segAdd[k];\n\n  ll left  = getMax(a,b,2*k+1,l,(l+r)/2);\n  ll right = getMax(a,b,2*k+2,(l+r)/2,r);\n\n  return max(left,right) + segAdd[k];\n}\n\nint H,d[111111],h[111111];\nint main(void){\n  cin >> n >> H;\n  for(int i = 0; i < n-1; i++){\n    cin >> d[i] >> h[i];\n  }\n\n  int res = 0;\n  priority_queue<pair<int,int> > que;\n  add(0,1,H,0,0,n);\n  for(int i = 0; i < n-1; i++){\n    que.push(make_pair(h[i],i));\n    while(1){\n      if(getMax(i,i+1,0,0,n) - d[i] > 0) break;\n      if(que.empty()) break;\n      int f = que.top().first;\n      if(!f) break;\n      int s = que.top().second;\n      que.pop();\n      if(getMax(s,i+1,0,0,n) + f <= H){\n\tint k = (H-getMax(s,i+1,0,0,n))/f;\n\tadd(s,i+1,f*k,0,0,n);\n\tres += k;\n      }else{\n\tque.push(make_pair(H - getMax(s,i+1,0,0,n),s));\n      }\n    }\n    add(i+1,i+2,getMax(i,i+1,0,0,n) - d[i],0,0,n);\n  }\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n\nusing namespace std;\n\nlong long int n,h;\n\nlong long int tai[100001];\nlong long int kai[100000];\n\n#define DEEP 19\n\nlong long int seg[(1 << DEEP)];\n\nint nextk[100000];\n\nint st[100000];\n\nlong long int segmax(int beg,int end)\n{\n\tif(end < beg)\n\t{\n\t\treturn -1;\n\t}\n\tint nowb1 = beg + (1 << (DEEP - 1)) - 1;\n\tint nowb2 = end + (1 << (DEEP - 1)) - 1;\n\tlong long int maxw = max(seg[nowb1],seg[nowb2]);\n\tfor(int i = 0; i < DEEP; i++)\n\t{\n\t\tint nowb1n = (nowb1 - 1) / 2;\n\t\tint nowb2n = (nowb2 - 1) / 2;\n\t\tif(nowb1n == nowb2n)\n\t\t{\n\t\t\treturn maxw;\n\t\t}\n\t\tif(nowb1 % 2 == 1)\n\t\t{\n\t\t\tmaxw = max(maxw,seg[nowb1 + 1]);\n\t\t}\n\t\tif(nowb2 % 2 == 0)\n\t\t{\n\t\t\tmaxw = max(maxw,seg[nowb2 - 1]);\n\t\t}\n\t\tnowb1 = nowb1n;\n\t\tnowb2 = nowb2n;\n\t}\n\treturn maxw;\n}\n\nint main()\n{\n\tscanf(\"%lld %lld\",&n,&h);\n\tlong long int nownt = 0;\n\ttai[0] = 0;\n\tfor(int i = (1 << (DEEP - 1)) - 1; i < (1 << DEEP); i++)\n\t{\n\t\tseg[i] = -1;\n\t}\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tlong long int dw,hw;\n\t\tscanf(\"%lld %lld\",&dw,&hw);\n\t\tnownt += dw;\n\t\ttai[i] = nownt;\n\t\tkai[i - 1] = hw;\n\t\tseg[(1 << (DEEP - 1)) - 1 + i - 1] = hw;\n\t}\n\ttai[n] = 10000000000000;\n\tkai[n - 1] = 100000000;\n\tint stn = 0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tfor(int j = stn - 1; j >= 0; j--)\n\t\t{\n\t\t\tif(kai[st[j]] <= kai[i])\n\t\t\t{\n\t\t\t\tnextk[st[j]] = i;\n\t\t\t\tstn--;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tst[stn] = i;\n\t\tstn++;\n\t}\n\tfor(int i = (1 << (DEEP - 1)) - 2; i >= 0; i--)\n\t{\n\t\tseg[i] = max(seg[i * 2 + 1],seg[i * 2 + 2]);\n\t}\n\tlong long int all = 0;\n\tlong long int nh = h;\n\tfor(int i = 0; i < n - 1; i++)\n\t{\n\t\tlong long int nt = tai[nextk[i]] - tai[i] + 1;\n\t\tlong long int tari = nt - nh;\n\t\tif(tari <= 0)\n\t\t{\n\t\t\ti = nextk[i] - 1;\n\t\t\tnh -= (nt - 1);\n\t\t\tcontinue;\n\t\t}\n\t\tlong long int kaikai = (tari - 1) / kai[i] + 1;\n\t\tlong long int kaiw = kaikai * kai[i];\n\t\tif(kaiw + nh > h)\n\t\t{\n\t\t\tlong long int na = h - nh;\n\t\t\tlong long int cank = na / kai[i];\n\t\t\tlong long int ak = h - (cank * kai[i] + nh);\n\t\t\tint now = i;\n\t\t\tint han = n - i;\n\t\t\tfor(int j = 0; j < 20; j++)\n\t\t\t{\n\t\t\t\tif(tai[now + han] - tai[i] + 1 <= cank * kai[i] + nh)\n\t\t\t\t{\n\t\t\t\t\tnow += han;\n\t\t\t\t}\n\t\t\t\than = (han + 1) / 2;\n\t\t\t}\n\t\t\tlong long int maxw = segmax(i + 1,now);\n\t\t\tif(maxw < ak)\n\t\t\t{\n\t\t\t\tall += cank + 1;\n\t\t\t\tnh = h - tai[i + 1] + tai[i];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tall += cank;\n\t\t\t\tnh = nh + cank * kai[i] - tai[i + 1] + tai[i];\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\ti = nextk[i] - 1;\n\t\t\tnh = nh + kaiw - (nt - 1);\n\t\t\tall += kaikai;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",all);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<map>\n#include<algorithm>\nusing namespace std;\nlong long n,h,d,p,y,x,z;\ndeque<pair<long long,long long> > w;\n\nint main(){\n  scanf(\"%lld%lld\", &n, &p);\n  y = p;\n  for(int i = 0;i < n - 1;i++){\n    scanf(\"%lld%lld\", &d, &h);\n    while(!w.empty() && w.back().first < h){\n      w.pop_back();\n    }\n    w.push_back(make_pair(h, x));\n    x += d;\n    while(p <= x){\n      long long int tmpp = p ;\n      while(!w.empty() && tmpp + w.front().first - w.front().second > y){\n\tp = max(p, w.front().second + y);\n\tw.pop_front();\n      }\n      if(!w.empty()){\n\tp = max(p, tmpp + w.front().first);\n\tint tmp = max(0ll, min((x - p) / w.front().first, (w.front().second + y - p) / w.front().first));\n\tz += tmp;\n\tp += tmp * w.front().first;\n      }\n      z++;\n    }\n  }\n  printf(\"%lld\\n\", z);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <map>\n#include <deque>\nusing namespace std;\n\nlong long d[100000];\nlong long h[100000];\nlong long s[100000];\nint main(){\n\tlong long N,H,mx;\n\tcin >> N >> H;\n\tmx = H;\n\tfor(int i = 0 ; i < N-1 ; i++){\n\t\tcin >> d[i] >> h[i];\n\t\ts[i+1] = s[i] + d[i];\n\t}\n\t\n\tint ans = 0;\n\tdeque<int> Q;\n\tfor(int i = 0 ; i < N-1 ; i++){\n\n\t\t//if( i > 10 ) return 0;\n\t\t//cout << \"s\" << i << \" \" << H << \" \" << ans << endl;\n\t\twhile( Q.size() && h[Q.back()] <= h[i]) Q.pop_back();\n\t\tQ.push_back(i);\n\t\twhile( Q.size() && s[i] - s[Q.front()] > mx) Q.pop_front();\n\t\t//for(int j = 0 ; j < Q.size() ; j++) cout << h[Q[j]] << \" (\" << Q[j] << \",\" << mx - (s[i]-s[Q[j]]) << \") \";cout << endl;\n\t\tif( H < d[i] ){\n\t\t\tfor(int j = 0 ; j < Q.size() ; j++){\n\t\t\t\tlong long heal_max = max(0ll, mx - (s[i] - s[Q[j]]) - H );\n\t\t\t\t\n\t\t\t\t//cout << i << \" \" << Q[j] << \" \" << s[i] << \" \" << s[Q[j]] << \" \" << H << \" \" << heal_max << endl;\n\t\t\t\tlong long need = d[i] - H + 1;\n\t\t\t\tlong long use = min(need,heal_max) / h[Q[j]];\n\t\t\t\t//cout << Q[j] << \" : \" << need << \" <========== \" << \" \" << heal_max << endl;\n\t\t\t\t//if( use == 0 ) continue;\n\t\t\t\tH += use * h[Q[j]];\n\t\t\t\t//H = min(H,mx - (s[i] - s[Q[j]]));\n\t\t\t\tans += use;\n\t\t\t\tif( H > d[i] ) break;\n\t\t\t\t\n\t\t\t\tif( j+1 >= Q.size() || mx - (s[i] - s[Q[j]]) - H >= h[Q[j+1]] ){\n\t\t\t\t\t//cout << H << \" \" << heal_max << endl;\n\t\t\t\t\tans++;\n\t\t\t\t\tH = min( H + h[Q[j]], mx - (s[i] - s[Q[j]]) );\n\t\t\t\t}\n\t\t\t\tif( H > d[i] ) break;\n\t\t\t}\n\t\t}\n\t\tH -= d[i];\n\t\tif( H <= 0 ){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//Bokan ga bokka--nn!!\n//Daily Lunch Special Tanoshii !!\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\n#include <deque>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\ntypedef long long ll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\n#define s(x) scanf(\"%d\",&x)\n#define rep(i,x) for(int i=0;i<x;i++)\nint main()\n{\n\tint n;\n\tll maxv;\n\tscanf(\"%d %lld\",&n,&maxv);\n\tll totv=maxv;\n\tll totd=0LL;\n\tdeque<pair<ll,ll> >deq;\n\tll ret=0LL;\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tll a,b;\n\t\tscanf(\"%lld %lld\",&a,&b);\n\t\twhile(!deq.empty() && deq.back().first<b) deq.pop_back();\n\t\tdeq.pb(mp(b,totd));\n//printf(\"%d %d %lld %lld %lld\\n\",i,deq.size(),totv,totd,ret);\n\t\ttotd+=a;\n\t\twhile(totv<=totd)\n\t\t{\n\t\t\tll s=0ll;\n\t\t\twhile(!deq.empty())\n\t\t\t{\n\t\t\t\tif(totv+deq.front().first-deq.front().second>maxv)\n\t\t\t\t{\n\t\t\t\t\ttotv=max(totv,maxv+deq.front().second);\n\t\t\t\t\tdeq.pop_front();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tll kai=deq.front().first;\n\t\t\tll prev=deq.front().second;\n\t\t\tif(!deq.empty())\n\t\t\t{\n\t\t\t\tll pv=max(0ll,min((totd-totv)/kai,(prev+maxv-totv)/kai));\n        \t\t\tret+=pv; ret--;\n        \t\t\ttotv+=pv*kai;\n      \t\t\t}\n      \t\t\tret++;\n      \t\t}\n\t}\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\nusing namespace std;\n\nint N, LIMIT;\n\nstruct water{\n    int heal, s, pay;\n    water(int _h, int _s, int _p): heal(_h), s(_s), pay(_p){}\n};\ndeque<water> DQ;\n\nint main(){\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n    scanf(\"%d %d\", &N, &LIMIT);\n    int res = 0;\n    int HP = LIMIT;\n    for(int i=1;i<N;i++){\n        int Di, Hi;\n        scanf(\"%d %d\", &Di, &Hi);\n        while(!DQ.empty() && DQ.front().heal <= Hi) DQ.pop_front();\n        DQ.push_front(water(Hi, HP, 0));\n        while(HP < Di){\n            water w = DQ.back();\n            int toheal = Di - HP;\n            int space = LIMIT - w.s - w.pay;\n            int full_heal = space - (space % w.heal);\n            if(full_heal > toheal){\n                int Times = toheal / w.heal;\n                if(toheal % w.heal) Times++;\n                res +=Times;\n                HP += Times * w.heal;\n                DQ.back().pay += Times * w.heal;\n            }\n            else{\n                HP += full_heal;\n                res += full_heal / w.heal;\n                w.pay += full_heal;\n                //\n                int other = space % w.heal;\n                DQ.pop_back();\n                if(!DQ.empty() && DQ.back().heal >= other){\n                    DQ.back().pay = w.pay;\n                }\n                else{\n                    res++;\n                    HP += space % w.heal;\n                    w.pay += space % w.heal;\n                    DQ.back().pay = w.pay;\n                }\n            }\n        }\n        DQ.front().s = HP;\n        DQ.front().pay = 0;\n        DQ.front().pay = -DQ.back().pay;\n        HP -= Hi;\n    }\n    printf(\"%d\\n\", res);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef pair<int,int>P;\nconst int SIZE=1<<17;\n\nstruct seg_tree{\n    int N;\n    vector<int>ma,lazy;\n\n    seg_tree(int n){\n        N=1;\n        while(n>N)N*=2;\n        ma.resize(N*2-1,0);\n        lazy.resize(N*2-1,0);\n    }\n\n    void evaluate(int k){\n        ma[k]+=lazy[k];\n        if(k<N-1){\n            lazy[k*2+1]+=lazy[k];\n            lazy[k*2+2]+=lazy[k];\n        }\n        lazy[k]=0;\n    }\n\n    void update_node(int k){\n        ma[k]=max(ma[k*2+1],ma[k*2+2]);\n    }\n\n    void add(int a,int b,int x){add(a,b,x,0,0,N);}\n    void add(int a,int b,int x,int k,int l,int r){\n        evaluate(k);\n        if(r<=a||b<=l)return;\n        if(a<=l&&r<=b){\n            lazy[k]+=x;\n            evaluate(k);\n            return;\n        }\n        int m=(l+r)/2;\n        add(a,b,x,k*2+1,l,m);\n        add(a,b,x,k*2+2,m,r);\n        update_node(k);\n    }\n\n    int get_max(int a,int b){return get_max(a,b,0,0,N);}\n    int get_max(int a,int b,int k,int l,int r){\n        evaluate(k);\n        if(r<=a||b<=l)return 0;\n        if(a<=l&&r<=b)return ma[k];\n        int m=(l+r)/2;\n        int vl=get_max(a,b,k*2+1,l,m);\n        int vr=get_max(a,b,k*2+2,m,r);\n        return max(vl,vr);\n    }\n};\n\nint N,H;\nint d[100000],h[100000];\n\nsigned main(){\n\n    cin>>N>>H;\n    for(int i=0;i<N-1;i++)cin>>d[i]>>h[i];\n\n    seg_tree seg(N);\n    int cur=H;\n    int ans=0;\n    priority_queue<P>que;\n    for(int i=0;i<N-1;i++){\n        seg.add(i,i+1,cur);\n        cur-=d[i];\n\n        que.push(P(h[i],i));\n\n        while(cur<=0){\n            if(que.size()==0)return 0;\n            P p=que.top();que.pop();\n            int ma=seg.get_max(p.second,i+1);\n            if(p.first+ma>H){\n                que.push(P(H-ma,p.second));\n                continue;\n            }\n            if(p.first==0)continue;\n            int x=min(abs(cur)/p.first+1,(H-ma)/p.first);\n            ans+=x;\n            cur+=x*p.first;\n            seg.add(p.second,i+1,p.first*x);\n        }\n    }\n\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\nstruct Starry_Sky_Tree\n{\n\tint data[(1<<19)-1],datb[(1<<19)-1];//data:add,datb:max\n\tStarry_Sky_Tree()\n\t{\n\t\tmemset(data,0,sizeof(data));\n\t\tmemset(datb,0,sizeof(datb));\n\t}\n\tvoid update(int a,int b,int x,int k,int l,int r)\n\t{\n\t\tif(a>=r||l>=b)return;\n\t\telse if(a<=l&&r<=b)\n\t\t{\n\t\t\tdata[k]+=x;\n\t\t\twhile(k>0)\n\t\t\t{\n\t\t\t\tk=(k-1)/2;\n\t\t\t\tdatb[k]=max(data[k*2+1]+datb[k*2+1],data[k*2+2]+datb[k*2+2]);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tupdate(a,b,x,k*2+1,l,(l+r)/2);\n\t\t\tupdate(a,b,x,k*2+2,(l+r)/2,r);\n\t\t}\n\t}\n\tint query(int a,int b,int k,int l,int r)\n\t{\n\t\tif(a>=r||l>=b)return 0;\n\t\tif(a<=l&&r<=b)return data[k]+datb[k];\n\t\telse return max(query(a,b,k*2+1,l,(l+r)/2),query(a,b,k*2+2,(l+r)/2,r))+data[k];\n\t}\n};\nStarry_Sky_Tree sst;\nP a[100000];\nint N,H;\nint main()\n{\n\tcin >> N >> H;\n\tfor(int i=0;i<N-1;i++)cin >> a[i].fi >> a[i].sec;\n\tpriority_queue<P> q;//fi num,sec index\n\tint now=H;\n\tll ans=0ll;\n\tfor(int i=0;i<N-1;i++)\n\t{\n\t\tsst.update(i,i+1,now,0,0,1<<18);\n\t\tnow-=a[i].fi;\n\t\tq.push(P(a[i].sec,i));\n\t\twhile(now<=0)\n\t\t{\n\t\t\t//loop:;\n\t\t\tP m=q.top();\n\t\t\tq.pop();\n\t\t\tint mx=sst.query(m.sec,i+1,0,0,1<<18);\n\t\t\tif(mx+m.fi>H)\n\t\t\t{\n\t\t\t\tm.fi=H-mx;\n\t\t\t\tq.push(m);\n\t\t\t\t//goto loop;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint num=min((-now)/m.fi+1,(H-mx)/m.fi);\n\t\t\tans+=(ll)num;\n\t\t\tnow+=num*m.fi;\n\t\t\tsst.update(m.sec,i+1,num*m.fi,0,0,1<<18);\n\t\t\tq.push(m);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll d[100000];\nll h[100000];\nll s[100000];\nint main(){\n\tll N,H,l;\tcin>>N>>H;\n\tl=H;\n\tfor(int i=0;i<N-1;i++){\n\t\tcin>>d[i]>>h[i];\n\t\ts[i+1]=s[i]+d[i];\n\t}\n\tll ans=0;\n\tdeque<int> dq;\n\tfor(int i=0;i<N-1;i++){\n\t\twhile(dq.size()&&h[dq.back()]<=h[i])\tdq.pop_back();\n\t\tdq.push_back(i);\n\t\twhile(dq.size()&&s[i]-s[dq.front()]>l)\tdq.pop_front();\n\t\tif(l<=d[i]){\n\t\t\tfor(int j=0;j<(int)dq.size();j++){\n\t\t\t\tll heal=max(0LL,H-(s[i]-s[dq[j]]-l));\n\t\t\t\tll req=d[i]-l+1;\n\t\t\t\tll use=min(heal,req)/h[dq[j]];\n\t\t\t\tl+=use*h[dq[j]];\n\t\t\t\tans+=use;\n\t\t\t\tif(l>d[i])\tbreak;\n\t\t\t\tif(j+1>=(int)dq.size()||H-(s[i]-s[dq[j]])-l>=h[dq[j+1]]){\n\t\t\t\t\tans++;\n\t\t\t\t\tl=min(l+h[dq[j]],H-(s[i]-s[dq[j]]));\n\t\t\t\t}\n\t\t\t\tif(l>d[i])\tbreak;\n\t\t\t}\n\t\t}\n\t\tl-=d[i];\n\t\tif(l<=0){\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <map>\n#include <deque>\nusing namespace std;\n\nlong long d[100000];\nlong long h[100000];\nlong long s[100000];\nint main(){\n\tlong long N,H,mx;\n\tcin >> N >> H;\n\tmx = H;\n\tfor(int i = 0 ; i < N-1 ; i++){\n\t\tcin >> d[i] >> h[i];\n\t\ts[i+1] = s[i] + d[i];\n\t}\n\t\n\tint ans = 0;\n\tdeque<int> Q;\n\tfor(int i = 0 ; i < N-1 ; i++){\n\n\t\t//if( i > 10 ) return 0;\n\t\t//cout << \"s\" << i << \" \" << H << \" \" << ans << endl;\n\t\twhile( Q.size() && h[Q.back()] <= h[i]) Q.pop_back();\n\t\tQ.push_back(i);\n\t\twhile( Q.size() && s[i] - s[Q.front()] > mx) Q.pop_front();\n\t\t//for(int j = 0 ; j < Q.size() ; j++) cout << h[Q[j]] << \" (\" << Q[j] << \",\" << mx - (s[i]-s[Q[j]]) << \") \";cout << endl;\n\t\tif( H <= d[i] ){\n\t\t\tfor(int j = 0 ; j < Q.size() ; j++){\n\t\t\t\tlong long heal_max = max(0ll, mx - (s[i] - s[Q[j]]) - H );\n\t\t\t\t\n\t\t\t\t//cout << i << \" \" << Q[j] << \" \" << s[i] << \" \" << s[Q[j]] << \" \" << H << \" \" << heal_max << endl;\n\t\t\t\tlong long need = d[i] - H + 1;\n\t\t\t\tlong long use = min(need,heal_max) / h[Q[j]];\n\t\t\t\t//cout << Q[j] << \" : \" << need << \" <========== \" << \" \" << heal_max << endl;\n\t\t\t\t//if( use == 0 ) continue;\n\t\t\t\tH += use * h[Q[j]];\n\t\t\t\t//H = min(H,mx - (s[i] - s[Q[j]]));\n\t\t\t\tans += use;\n\t\t\t\tif( H > d[i] ) break;\n\t\t\t\t\n\t\t\t\tif( j+1 >= Q.size() || mx - (s[i] - s[Q[j]]) - H >= h[Q[j+1]] ){\n\t\t\t\t\t//cout << H << \" \" << heal_max << endl;\n\t\t\t\t\tans++;\n\t\t\t\t\tH = min( H + h[Q[j]], mx - (s[i] - s[Q[j]]) );\n\t\t\t\t\tflag = 1;\n\t\t\t\t}\n\t\t\t\tif( H > d[i] ) break;\n\t\t\t}\n\t\t}\n\t\tH -= d[i];\n\t\tif( H <= 0 ){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 28;\ntypedef pair<int, int> Pr;\n\nint N, H;\nint d[100000], h[100000];\n\nconst int size = 1 << 20;\nint seg_v[size * 2 - 1];\nint seg_a[size * 2 - 1];\nPr rmq[size * 2 - 1];\n\nvoid seg_add(int l, int r, int x, int k = 0, int a = 0, int b = size){\n\tif (b <= l || r <= a) return;\n\tif (l <= a && b <= r){\n\t\tseg_a[k] += x;\n\t\twhile (k){\n\t\t\tk = (k - 1) / 2;\n\t\t\tseg_v[k] = max(\n\t\t\t\tseg_v[k * 2 + 1] + seg_a[k * 2 + 1],\n\t\t\t\tseg_v[k * 2 + 2] + seg_a[k * 2 + 2]\n\t\t\t);\n\t\t}\n\t\treturn;\n\t}\n\t\n\tint m = (a + b) / 2;\n\tseg_add(l, r, x, k * 2 + 1, a, m);\n\tseg_add(l, r, x, k * 2 + 2, m, b);\n}\nint seg_getMax(int l, int r, int k = 0, int a = 0, int b = size){\n\tif (b <= l || r <= a) return -INF;\n\tif (l <= a && b <= r) return seg_a[k] + seg_v[k];\n\tint m = (a + b) / 2;\n\tint vl = seg_getMax(l, r, k * 2 + 1, a, m);\n\tint vr = seg_getMax(l, r, k * 2 + 2, m, b);\n\treturn seg_a[k] + max(vl, vr);\n}\n\nvoid rmq_update(int k, int x){\n\tint i = k;\n\tk += size - 1;\n\trmq[k] = Pr(x, i);\n\twhile (k){\n\t\tk = (k - 1) / 2;\n\t\trmq[k] = max(rmq[k * 2 + 1], rmq[k * 2 + 2]);\n\t}\n}\nPr _rmq_getMax(int l, int r, int k = 0, int a = 0, int b = size){\n\tif (b <= l || r <= a) return Pr(-INF, -1);\n\tif (l <= a && b <= r) return rmq[k];\n\tint m = (a + b) / 2;\n\tPr vl = _rmq_getMax(l, r, k * 2 + 1, a, m);\n\tPr vr = _rmq_getMax(l, r, k * 2 + 2, m, b);\n\treturn max(vl, vr);\n}\nint rmq_getMax(int l, int r){\n\treturn _rmq_getMax(l, r).first;\n}\nint rmq_getMaxIdx(int l, int r){\n\treturn _rmq_getMax(l, r).second;\n}\n\nvoid solve()\n{\n\tlong long int res = 0;\n\t\n\tfor (int i = 0; i < N; i++){\n\t\trmq_update(i, h[i]);\n\t}\n\t\n\tseg_add(0, N, H);\n\t\n\tfor (int fl = 0; fl < N; fl++){\n\t\tif (seg_getMax(fl, fl + 1) > H){\n\t\t\tseg_add(fl, N, H - seg_getMax(fl, fl + 1));\n\t\t}\n\t\t\n\t\tseg_add(fl, N, -d[fl]);\n\t\t//printf(\"%dF HP=%d\\n\", fl, seg_getMax(fl, fl + 1));\n\t\tif (seg_getMax(fl, fl + 1) > 0) continue;\n\t\t\n\t\twhile (true){\n\t\t\tint idx = rmq_getMaxIdx(0, fl);\n\t\t\tif (h[idx] > H - seg_getMax(idx, fl)){\n\t\t\t\th[idx] = H - seg_getMax(idx, fl);\n\t\t\t\trmq_update(idx, h[idx]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t/*\n\t\t\tseg_add(idx, N, h[idx]);\n\t\t\tres++;\n\t\t\tif (seg_getMax(fl, fl + 1) > 0) break;\n\t\t\t*/\n\t\t\t\n\t\t\tint s = (H - seg_getMax(idx, fl)) / h[idx];\n\t\t\tint hp = seg_getMax(fl, fl + 1);\n\t\t\tint need = -hp + 1;\n\t\t\tint t = (need / h[idx]) + !!(need % h[idx]);\n\t\t\tint num = min(s, t);\n\t\t\t\n\t\t\tseg_add(idx, N, h[idx] * num);\n\t\t\tres += num;\n\t\t\tif (seg_getMax(fl, fl + 1) > 0) break;\n\t\t}\n\t\t\n\t\t//printf(\"%dF HP=%d\\n\", fl, seg_getMax(fl, fl + 1));\n\t}\n\t\n\tprintf(\"%lld\\n\", res);\n}\n\nint main()\n{\n\tscanf(\"%d %d\", &N, &H);\n\tfor (int i = 0; i < N - 1; i++){\n\t\tscanf(\"%d %d\", d + i + 1, h + i);\n\t}\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<iostream>\n#include<queue>\n#include<string>\n#include<climits>\nusing namespace std;\ntypedef long long ll;\n#define INF (LLONG_MAX)\ntypedef pair<ll,int> P;\n#define F first\n#define S second\nint N;\nll H;\nP d[400001];\nll h[400001];\nint n;\nvoid update(int k,ll a){\n  int i=k;\n  k += n-1;\n  d[k].F = a;\n  d[k].S = i;\n  while( k > 0 ){\n    k=(k-1)/2;\n    d[k] = max( d[k*2+1] ,d[k*2+2] );\n  }\n}  \nvoid init(){\n  n = 1;\n  while( n < N-1 ) n *= 2;\n  /*  for(int i=0;i<2*n-1;i++){\n    h[i]=H;\n    }*/\n}\n\nvoid add(int a,int b,ll x,int k,int l,int r){\n  if( r<=a || b<=l ) return;\n  if( a<=l && r<=b ){\n    h[k] += x;\n    return;\n  }\n  add(a,b,x,k*2+1,l,(l+r)/2);\n  add(a,b,x,k*2+2,(l+r)/2,r);\n}\n\nP qmax(int a,int b,int k, int l,int r){\n  //  printf(\"qmax:%d %d %d %d %d\\n\",a,b,k,l,r);\n  if( r<=a || b<=l ) return P(-1,-1);\n  if( a<=l && r<=b ) return d[k];\n  P vl = qmax(a,b,k*2+1,l,(l+r)/2);\n  P vr = qmax(a,b,k*2+2,(l+r)/2,r);\n  return max(vl,vr);\n}\n\nll sum(int k){\n  k += n-1;\n  ll ret = h[k];\n  while ( k > 0 ){\n    k = (k-1)/2;\n    ret += h[k];\n  }\n  return ret;\n}\n\npair<ll,ll> proc(int &st,int i){\n  bool r = true;\n  P p;\n  ll s;\n  while(r){\n    p = qmax(st,i+1,0,0,n);\n    s = sum(p.S);\n    if( s < p.F ){\n      update(p.S,s);\n    } else\n      r = false;\n    st = p.S;\n    //    printf(\"proc check : %lld %d  許容量:%lld st:%d i:%d\\n\",p.F,p.S,s,st,i);\n    //    sleep(1);\n  }\n  return pair<ll,ll>(p.F,s);\n}\n\nint main(){\n  scanf(\"%d %lld\",&N,&H);\n  ll dm = 0;\n  int st = 0;\n  ll res = 0;\n  init();\n  for(int i=0;i<N-1;i++){\n    ll a,b;\n    scanf(\"%lld %lld\",&b,&a);\n    update(i,a);\n    if( dm+b >= H ){\n      ll nd = (dm+b) - H;\n      while(nd>0){\n\tpair<ll,ll> p = proc(st,i);\n\tll c;\n\tif( p.S >= nd ){\n\t  c = (nd-1) / p.F + 1;\n\t} else {\n\t  c= p.S / p.F;\n\t}\n\tres+=c;\n\tadd( st, i+1, -c*p.F, 0, 0, n);\n\tnd -= c*p.F;\n\t//\tprintf(\"dm+b check : %lld 残り回復量:%lld st:%d i:%d\\n\",res,nd,st,i);     \n      }\n      dm = max( 0LL, dm - (((dm+b)-H)-nd)+1 );\n    }\n    dm+=b;\n    h[i+n] = dm;\n    //    printf(\"check: %lld %lld %d %d\\n\",res,dm,st,i);\n  }\n  printf(\"%lld\\n\",res);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef pair<int,int>P;\nconst int SIZE=1<<17;\n\nstruct seg_tree{\n    vector<int>ma,lazy;\n\n    seg_tree():ma(SIZE*2-1,0),lazy(SIZE*2-1,0){}\n\n    void evaluate(int k){\n        ma[k]+=lazy[k];\n        if(k<SIZE-1){\n            lazy[k*2+1]+=lazy[k];\n            lazy[k*2+2]+=lazy[k];\n        }\n        lazy[k]=0;\n    }\n    void update_node(int k){\n        ma[k]=max(ma[k*2+1],ma[k*2+2]);\n    }\n\n    void add(int a,int b,int x,int k=0,int l=0,int r=SIZE){\n        evaluate(k);\n        if(r<=a||b<=l)return;\n        if(a<=l&&r<=b){\n            lazy[k]+=x;\n            evaluate(k);\n            return;\n        }\n        int m=(l+r)/2;\n        add(a,b,x,k*2+1,l,m);\n        add(a,b,x,k*2+2,m,r);\n        update_node(k);\n    }\n\n    int get_max(int a,int b,int k=0,int l=0,int r=SIZE){\n        evaluate(k);\n        if(r<=a||b<=l)return 0;\n        if(a<=l&&r<=b)return ma[k];\n        int m=(l+r)/2;\n        int vl=get_max(a,b,k*2+1,l,m);\n        int vr=get_max(a,b,k*2+2,m,r);\n        return max(vl,vr);\n    }\n};\n\nint N,H;\nint d[100000],h[100000];\n\nsigned main(){\n    cin>>N>>H;\n    for(int i=0;i<N-1;i++)cin>>d[i]>>h[i];\n\n    seg_tree seg;\n    int cur=H;\n    int ans=0;\n    priority_queue<P>que;\n    for(int i=0;i<N-1;i++){\n        seg.add(i,i+1,cur);\n        cur-=d[i];\n\n        que.push(P(h[i],i));\n\n        while(cur<=0){\n            P p=que.top();que.pop();\n            int ma=seg.get_max(p.second,i+1);\n            if(p.first+ma>H){\n                que.push(P(H-ma,p.second));\n                continue;\n            }\n            assert(p.first>0);\n            int x=min(abs(cur)/p.first+1,(H-ma)/p.first);\n            ans+=x;\n            cur+=x*p.first;\n            seg.add(p.second,i+1,p.first*x);\n        }\n    }\n\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <cstdio>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\nusing namespace std;\n\nint di[100000];\nint hi[100000];\n\nint main(){\n  int n = getInt();\n  int h = getInt();\n\n  REP(i,n - 1){\n    di[i] = getInt();\n    hi[i] = getInt();\n  }\n\n  int now = 0;\n  int hh  = h;\n  int cnt = 0;\n\n  while(true){\n    int hp  = hh;\n    int pos = now;\n\n    int mxv = -1;\n    int memohp  = 0;\n    int memopos = 0;\n\n    // printf(\"pos: %d, hp: %d\\n\", pos, hp);\n\n    while(true){\n      if(mxv <= min(h - hp, hi[pos])){\n\tmxv     = min(h - hp, hi[pos]);\n\tmemohp  = hp;\n\tmemopos = pos;\n      }\n\n      if(hp - di[pos] > 0){\n\thp -= di[pos];\n\tpos++;\n      }else{\n\tbreak;\n      }\n\n      if(pos == n - 1){\n\tprintf(\"%d\\n\", cnt);\n\treturn 0;\n      }\n    }\n\n    // printf(\"mxv: %d, memopos: %d, memohp: %d\\n\", mxv, memopos, memohp);\n\n    now = memopos;\n    hh  = min(memohp + hi[now], h);\n    cnt++;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//Bokan ga bokka--nn!!\n//Daily Lunch Special Tanoshii !!\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\n#include <deque>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\ntypedef long long ll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\n#define s(x) scanf(\"%d\",&x)\n#define rep(i,x) for(int i=0;i<x;i++)\nint main()\n{\n\tint n;\n\tll maxv;\n\tscanf(\"%d %lld\",&n,&maxv);\n\tll totv=maxv;\n\tll totd=0LL;\n\tdeque<pair<ll,ll> >deq;\n\tll ret=0LL;\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tll a,b;\n\t\tscanf(\"%lld %lld\",&a,&b);\n\t\twhile(!deq.empty() && deq.back().first<b) deq.pop_back();\n\t\tdeq.pb(mp(b,totd));\n//printf(\"%d %d %lld %lld %lld\\n\",i,deq.size(),totv,totd,ret);\n\t\ttotd+=a;\n\t\twhile(totv<=totd)\n\t\t{\n\t\t\tll s=0ll; ll bef=totv;\n\t\t\twhile(!deq.empty())\n\t\t\t{\n\t\t\t\tif(totv+deq.front().first-deq.front().second>maxv)\n\t\t\t\t{\n\t\t\t\t\ttotv=max(totv,maxv+deq.front().second);\n\t\t\t\t\tdeq.pop_front();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tll kai=deq.front().first;\n\t\t\tll prev=deq.front().second;\n\t\t\tif(!deq.empty())\n\t\t\t{\n\t\t\t\ttotv=min(maxv+prev,max(totv,bef+kai));\n\t\t\t\tll pv=max(0ll,min((totd-totv)/kai,(prev+maxv-totv)/kai));\n        \t\t\tret+=pv;\n        \t\t\ttotv+=pv*kai;\n      \t\t\t}\n      \t\t\tret++;\n//cout << ret << \" \" << totv << endl;\n      \t\t}\n\t}\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint N, H, d[100009], h[100009], dp[2][10000009]; vector<int> z[100009];\nint main() {\n\tcin >> N >> H;\n\tfor (int i = 0; i < N - 1; i++) cin >> d[i] >> h[i];\n\tint count = 0; z[0] = { H };\n\tfor (int i = 0; i < N - 1; i++) {\n\t\tfill(dp[1], dp[1] + H + 1, 999999999);\n\t\tfor (int j : z[i]) {\n\t\t\tif (dp[0][j] == 999999999) continue;\n\t\t\tfor (int k = 0; j + (k - 1) * h[i] <= H; k++) {\n\t\t\t\tint val = min(j + k * h[i], H) - d[i];\n\t\t\t\tif (val > 0) dp[1][val] = min(dp[1][val], dp[0][j] + k);\n\t\t\t}\n\t\t}\n\t\tfor (int j = H - 1; j >= 1; j--) {\n\t\t\tdp[1][j] = min(dp[1][j], dp[1][j + 1]);\n\t\t\tif (dp[1][j] < dp[1][j + 1]) z[i + 1].push_back(j);\n\t\t\tdp[0][j] = dp[1][j];\n\t\t}\n\t\tcount += z[i + 1].size();\n\t}\n\tcout << dp[1][1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 28;\ntypedef pair<int, int> Pr;\n\nnamespace std {\n\tbool operator < (const Pr& a, const Pr& b){\n\t\tif (a.first != b.first) return a.first < b.first;\n\t\treturn a.second > b.second;\n\t}\n}\n\nint N, H;\nint d[100000], h[100000];\n\nconst int size = 1 << 20;\nint seg_v[size * 2 - 1];\nint seg_a[size * 2 - 1];\nPr rmq[size * 2 - 1];\n\nvoid seg_add(int l, int r, int x, int k = 0, int a = 0, int b = size){\n\tif (b <= l || r <= a) return;\n\tif (l <= a && b <= r){\n\t\tseg_a[k] += x;\n\t\twhile (k){\n\t\t\tk = (k - 1) / 2;\n\t\t\tseg_v[k] = max(\n\t\t\t\tseg_v[k * 2 + 1] + seg_a[k * 2 + 1],\n\t\t\t\tseg_v[k * 2 + 2] + seg_a[k * 2 + 2]\n\t\t\t);\n\t\t}\n\t\treturn;\n\t}\n\t\n\tint m = (a + b) / 2;\n\tseg_add(l, r, x, k * 2 + 1, a, m);\n\tseg_add(l, r, x, k * 2 + 2, m, b);\n}\nint seg_getMax(int l, int r, int k = 0, int a = 0, int b = size){\n\tif (b <= l || r <= a) return -INF;\n\tif (l <= a && b <= r) return seg_a[k] + seg_v[k];\n\tint m = (a + b) / 2;\n\tint vl = seg_getMax(l, r, k * 2 + 1, a, m);\n\tint vr = seg_getMax(l, r, k * 2 + 2, m, b);\n\treturn seg_a[k] + max(vl, vr);\n}\n\nvoid rmq_update(int k, int x){\n\tint i = k;\n\tk += size - 1;\n\trmq[k] = Pr(x, i);\n\twhile (k){\n\t\tk = (k - 1) / 2;\n\t\trmq[k] = max(rmq[k * 2 + 1], rmq[k * 2 + 2]);\n\t}\n}\nPr _rmq_getMax(int l, int r, int k = 0, int a = 0, int b = size){\n\tif (b <= l || r <= a) return Pr(-INF, -1);\n\tif (l <= a && b <= r) return rmq[k];\n\tint m = (a + b) / 2;\n\tPr vl = _rmq_getMax(l, r, k * 2 + 1, a, m);\n\tPr vr = _rmq_getMax(l, r, k * 2 + 2, m, b);\n\treturn max(vl, vr);\n}\nint rmq_getMax(int l, int r){\n\treturn _rmq_getMax(l, r).first;\n}\nint rmq_getMaxIdx(int l, int r){\n\treturn _rmq_getMax(l, r).second;\n}\n\nvoid solve()\n{\n\tlong long int res = 0;\n\t\n\tfor (int i = 0; i < N; i++){\n\t\trmq_update(i, h[i]);\n\t}\n\t\n\tseg_add(0, N, H);\n\t\n\tfor (int fl = 0; fl < N; fl++){\n\t\tif (seg_getMax(fl, fl + 1) > H){\n\t\t\tseg_add(fl, N, H - seg_getMax(fl, fl + 1));\n\t\t}\n\t\t\n\t\tseg_add(fl, N, -d[fl]);\n\t\t//printf(\"%dF HP=%d\\n\", fl, seg_getMax(fl, fl + 1));\n\t\tif (seg_getMax(fl, fl + 1) > 0) continue;\n\t\t\n\t\twhile (true){\n\t\t\tint idx = rmq_getMaxIdx(0, fl);\n\t\t\tif (h[idx] > H - seg_getMax(idx, fl)){\n\t\t\t\th[idx] = H - seg_getMax(idx, fl);\n\t\t\t\trmq_update(idx, h[idx]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t/*\n\t\t\tseg_add(idx, N, h[idx]);\n\t\t\tres++;\n\t\t\tif (seg_getMax(fl, fl + 1) > 0) break;\n\t\t\t*/\n\t\t\t\n\t\t\tint s = (H - seg_getMax(idx, fl)) / h[idx];\n\t\t\tint hp = seg_getMax(fl, fl + 1);\n\t\t\tint need = -hp + 1;\n\t\t\tint t = (need / h[idx]) + !!(need % h[idx]);\n\t\t\tint num = min(s, t);\n\t\t\t\n\t\t\tseg_add(idx, N, h[idx] * num);\n\t\t\tres += num;\n\t\t\tif (seg_getMax(fl, fl + 1) > 0) break;\n\t\t}\n\t\t\n\t\t//printf(\"%dF HP=%d\\n\", fl, seg_getMax(fl, fl + 1));\n\t}\n\t\n\tprintf(\"%lld\\n\", res);\n}\n\nint main()\n{\n\tscanf(\"%d %d\", &N, &H);\n\tfor (int i = 0; i < N - 1; i++){\n\t\tscanf(\"%d %d\", d + i + 1, h + i);\n\t}\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<string>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,P> P1;\n\n#define rep(i,x) for(ll i = 0 ; i < x ; i ++)\n#define rep1(i,x) for(ll i = 1 ; i <= x ; i ++)\n#define rrep(i,x) for(ll i = x-1 ; i >= 0 ; i --)\n#define rrep1(i,x) for(ll i = x ; i > 0 ; i --)\n#define sor(vec) sort(vec.begin(),vec.end())\n#define rev(vec) reverse(vec.begin(),vec.end())\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(min(a,b),c)\n#define max_3(a,b,c) max(max(a,b),c)\n#define mp1(a,b,c) P1(a,P(b,c))\n#define fr first\n#define sc second\n#define pb push_back\n\nconst ll INF = 1000000000000000000;\nconst ll dir_4[4][2] = { {1,0} , {0,1} , {-1,0} , {0,-1} };\n\nll siz;\nll seg[2][400010];\n\nvoid init(ll n){\n\tsiz = 1;\n\twhile(siz < n)siz *= 2;\n\trep(i,siz*2-1){\n\t\tseg[0][i] = -INF;\n\t\tseg[1][i] = 0;\n\t}\n}\n\nll query(ll k){\n\tll sum = 0;\n\tk += siz-1;\n\tll ret = seg[0][k];\n\twhile(k > 0){\n\t\tk = (k-1)/2;\n\t\tret = max ( ret + seg[1][k] , seg[0][k] );\n\t}\n\treturn ret;\n}\n\nvoid maxi(ll a,ll b,ll x,ll k,ll l,ll r){\n\tif(b <= l || r <= a)return;\n\tif(a <= l && r <= b){\n\t\tseg[0][k] = max ( seg[0][k] , x );\n\t\treturn;\n\t}\n\tmaxi(a,b,x-seg[1][k],2*k+1,l,(l+r)/2);\n\tmaxi(a,b,x-seg[1][k],2*k+2,(l+r)/2,r);\n}\n\nvoid add(ll a,ll b,ll x,ll k,ll l,ll r){\n\tif(b <= l || r <= a)return;\n\tif(a <= l && r <= b){\n\t\tseg[0][k] += x;\n\t\tseg[1][k] += x;\n\t\treturn;\n\t}\n\tadd(a,b,x,2*k+1,l,(l+r)/2);\n\tadd(a,b,x,2*k+2,(l+r)/2,r);\n}\n\nvoid updata(ll k,ll x){\n\tadd(k,k+1,x-query(k),0,0,siz);\n}\n\nint main(){\n\tll n,h;\n\tstatic ll c[100010],d[100010];\n\t\n\tscanf(\"%lld%lld\",&n,&h);\n\trep1(i,n-1){\n\t\tscanf(\"%lld%lld\",&c[i],&d[i]);\n\t}\n\t\n\tinit(n+10);\n\tupdata(0,h);\n\tc[0] = 0;\n\t\n\tpriority_queue<P> que;\n\tll ret = 0;\n\t\n\trep1(i,n-1){\n\t\tupdata(i,query(i-1)-c[i-1]);\n\t\tque.push( P ( d[i] , i ) );\n\t\tll t = c[i] - query(i) + 1;\n\t\twhile(t > 0){\n\t\t\tP p = que.top(); que.pop();\n\t\t\tll s1 = (t+p.fr-1)/p.fr;\n\t\t\tll s2 = (h-query(p.sc))/p.fr;\n\t\t\tif(s1 < s2){\n\t\t\t\tmaxi(0,p.sc,query(p.sc)+p.fr*s1,0,0,siz);\n\t\t\t\tadd(p.sc,siz,p.fr*s1,0,0,siz);\n\t\t\t\tt -= p.fr*s1;\n\t\t\t\tret += s1;\n\t\t\t\tque.push(p);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmaxi(0,p.sc,query(p.sc)+p.fr*s2,0,0,siz);\n\t\t\t\tadd(p.sc,siz,p.fr*s2,0,0,siz);\n\t\t\t\tt -= p.fr*s2;\n\t\t\t\tret += s2;\n\t\t\t\tque.push( P ( h-query(p.sc) , p.sc ) );\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\",ret);\n\t\t\t\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  ll N, maxHp;\n  while (cin >> N >> maxHp) {\n    vector<ll> totalDamage(N);\n    ll totalHealing = 0, answer = 0;\n    priority_queue<pair<ll, int>> Q;\n\n    for (int i = 0; i < N - 1; ++i) {\n      ll damage, healing;\n      cin >> damage >> healing;\n      totalDamage[i + 1] = totalDamage[i] + damage;\n      Q.push({min(healing, totalDamage[i] - totalHealing), i});\n\n      ll necessaryHealing = max(0LL, totalDamage[i + 1] - totalHealing - maxHp + 1);\n      while (necessaryHealing > 0) {\n        ll healing = Q.top().first;\n        int index = Q.top().second;\n        Q.pop();\n\n        ll netDamage = totalDamage[index] - totalHealing;\n        ll times = (necessaryHealing + healing - 1) / healing;\n        if (netDamage - healing * times < 0) --times;\n        answer += times;\n        necessaryHealing -= healing * times;\n        netDamage -= healing * times;\n        totalHealing += healing * times;\n        if (netDamage > 0) Q.push({netDamage, index});\n      }\n    }\n    cout << answer << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long l;\n\npair<int,int> p[100005];\nlong long imos[100005]={};\npair<int,int>seg[(1<<18)];\nint n,h;\nint cm[100005];\n\nvoid init()\n{\n\tfor(int i=0;i<(1<<18);i++)\n\t{\n\t\tseg[i].first=0;\n\t\tseg[i].second=0;\n\t}\n}\n\nvoid update(int x,pair<int,int> a)\n{\n\tx+=(1<<17)-1;\n\tseg[x]=a;\n\twhile(x>0)\n\t{\n\t\tx=(x-1)/2;\n\t\tif(seg[x].first<seg[x*2+1].first) seg[x]=seg[x*2+1];\n\t\tif(seg[x].first<seg[x*2+2].first) seg[x]=seg[x*2+2];\n\t}\n}\n\npair<int,int> query(int a,int b,int k,int l,int r)\n{\n\tpair<int,int>s;\n\ts.first=s.second=-1;\n\tif(b<l || r<a) return s;\n\tif(a<=l && r<=b) return seg[k];\n\tint sa=r-l+1;\n\tpair<int,int> le=query(a,b,k*2+1,l,l+sa/2-1);\n\tpair<int,int> ri=query(a,b,k*2+2,l+sa/2,r);\n\tif(le.first>ri.first) return le;\n\telse return ri;\n}\n\nint binarysearch(long long s,int w)\n{\n\tint lb=-1;\n\tint ub=n+1;\n\twhile(ub-lb>1)\n\t{\n\t\tint mid=(lb+ub)/2;\n\t\tif(imos[mid]-imos[w]>s) ub=mid;\n\t\telse lb=mid;\n\t}\n\tfor(int i=max(w,lb-3);i<=min(n-1,ub+3);i++)\n\t{\n\t\tif(imos[i]-imos[w]>s) return i-1;\n\t}\n\treturn 1e9;\n}\n\nint main()\n{\n\tscanf(\"%d %d\",&n,&h);\n\tinit();\n\tpriority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> >>que;\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d %d\",&x,&y);\n\t\timos[i+1]=imos[i]+1LL*x;\n\t\tp[i]=make_pair(y,i);\n\t\tupdate(i,p[i]);\n\t\twhile(!que.empty() && que.top().first<y)\n\t\t{\n\t\t\tcm[que.top().second]=i;\n\t\t\tque.pop();\n\t\t}\n\t\tque.push(p[i]);\n\t}\n\twhile(que.size()) cm[que.top().second]=n-1,que.pop();\n\tint cur=h;\n\tint now=0;\n\tlong long ret=0;\n\twhile(1)\n\t{\n\t\tint e=cm[now];\n\t\tlong long dis=imos[e]-imos[now];\n\t\tif(dis<cur)\n\t\t{\n\t\t\tcur-=dis;\n\t\t\tnow=e;\n\t\t}\n\t\telse if(dis<=h)\n\t\t{\n\t\t\tlong long fj=dis-cur+1;\n\t\t\tret+=(fj+p[now].first-1)/p[now].first;\n\t\t\tcur+=((fj+p[now].first-1)/p[now].first)*p[now].first;\n\t\t\tcur=min(cur,h);\n\t\t\tcur-=dis;\n\t\t\tnow=e;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint X=binarysearch(h,now);\n\t\t\tpair<int,int>se = query(now+1,X,0,0,(1<<17)-1);\n\t\t\tlong long fj=(imos[se.second]-imos[now])-cur+1;\n\t\t\tif(fj>0)\n\t\t\t{\n\t\t\t\tret+=(fj+p[now].first-1)/p[now].first;\n\t\t\t\tcur+=((fj+p[now].first-1)/p[now].first)*p[now].first;\n\t\t\t}\n\t\t\tcur=min(cur,h);\n\t\t\tcur-=(imos[se.second]-imos[now]);\n\t\t\tnow=se.second;\n\t\t}\n\t\tif(now==n-1) break;\n\t}\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef struct {\n    int plus, pos;\n} Dungeon;\n\nbool operator < (const Dungeon &a, const Dungeon &b)\n{\n    if (a.plus != b.plus){\n        return (a.plus < b.plus);\n    }\n    else {\n        return (a.pos < b.pos);\n    }\n}\nint data[1 << 18], datb[1 << 18];\n\nvoid add(int a, int b, int x, int k, int l, int r)\n{\n    if (a <= l && r <= b){ //comletely inclusive.\n        data[k] += x; //add to all segmets corresponds to [l, r).\n    }\n    else if (l < b && a < r){ //some of the segments are inclusive.\n        datb[k] += (min(b, r) - max(a, l)) * x;  //add the x to the segments that belongs to [max(a, l), min(r, b)).\n        add(a, b, x, k * 2 + 1, l, (l + r) / 2); //go to the left vertex.\n        add(a, b, x, k * 2 + 2, (l + r) / 2, r); //go to the right vertex.\n    }\n}\n\n//*\nint sum(int a, int b, int k, int l, int r)\n{\n    if (b <= l || r <= a){ //looking segment[l, r) cross with the segment [a, b).\n        return (0);\n    }\n    else if (a <= l && r <= b){ //completely inclusive.\n        return (data[k] * (r - l) + datb[k]);\n    }\n    else { //some of the segments are inclusive.\n        ll res;\n        res = (min(b, r) - max(a, l)) * data[k];\n        res += sum(a, b, k * 2 + 1, l, (l + r) / 2);\n        res += sum(a, b, k * 2 + 2, (l + r) / 2, r);\n        return (res);\n    }\n}\n//*/\n\nint main(void)\n{\n    int N, H;\n    int di[100000], hi[100000];\n    int curLife;\n    \n    scanf(\"%d%d\", &N, &H);\n    \n    for (int i = 0; i < N - 1; i++){\n        scanf(\"%d%d\", &di[i], &hi[i]);\n    }\n    \n    curLife = H;\n    \n    ll ans = 0;\n    priority_queue<Dungeon> que;\n    for (int i = 0; i < N - 1; i++){\n        add(i, i + 1, curLife, 0, 0, 1 << 17);\n        Dungeon in;\n        curLife -= di[i];\n        \n        in.plus = hi[i];\n        in.pos = i;\n        \n        que.push(in);\n        while (curLife <= 0){\n            Dungeon heal = que.top();\n            que.pop();\n            \n            /* O(logN)\n            int segMax = getMax(heal.pos, i + 1, 0, 0, 1 << 17);\n            //*/\n            \n            //* O(NlogN)\n            int segMax = 0;\n            for (int j = heal.pos; j <= i; j++){\n                segMax = max(segMax, sum(j, j + 1, 0, 0, 1 << 17));\n            }\n            //*/\n            \n            if (heal.plus + segMax > H){\n                heal.plus = H - segMax;\n                que.push(heal);\n                continue;\n            }\n            \n            int howMany = min((-1 * curLife) / heal.plus + 1, (H - segMax) / heal.plus);\n            ans += howMany;\n            curLife += howMany * heal.plus;\n            \n            add(heal.pos, i + 1, howMany * heal.plus, 0, 0, 1 << 17);\n            que.push(heal);\n        }\n    }\n    \n    printf(\"%lld\\n\", ans);\n    \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "//Bokan ga bokka--nn!!\n//Daily Lunch Special Tanoshii !!\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\ntypedef long long ll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\n#define s(x) scanf(\"%d\",&x)\n#define maxs 1<<18\nclass segtree\n{\n\tll seg[maxs]={};\n\tll lazy[maxs]={};\n\t\n\tvoid lazy_evaluate(int x)\n\t{\n\t\tif(x*2+2>=maxs) continue;\n\t\tlazy[x*2+1]+=lazy[x];\n\t\tlazy[x*2+2]+=lazy[x];\n\t\tseg[x*2+1]+=lazy[x];\n\t\tseg[x*2+2]+=lazy[x];\n\t\tlazy[x]=0;\n\t}\n\tll update(int beg,int en,int idx,int lb,int ub,int val)\n\t{\n\t\tif(ub<beg || en<lb)\n\t\t{\n\t\t\treturn seg[idx];\n\t\t}\n\t\tif(beg<=lb && ub<=en)\n\t\t{\n\t\t\tlazy[idx]+=val;\n\t\t\tseg[idx]+=val;\n\t\t\tlazy_evaluate(idx);\n\t\t\treturn seg[idx];\n\t\t}\n\t\tif(lazy[idx])\n\t\t{\n\t\t\tlazy_evaluate(idx);\n\t\t}\n\t\treturn seg[idx]=max(update(beg,en,idx*2+1,lb,(lb+ub)/2,val),update(beg,en,idx*2+2,(lb+ub)/2+1,ub,val));\n\t}\n\tll query(int beg,int en,int idx,int lb,int ub)\n\t{\n\t\tif(ub<beg || en<lb)\n\t\t{\n\t\t\treturn -1LLe12;\n\t\t}\n\t\tif(beg<=lb && ub<=en)\n\t\t{\n\t\t\treturn seg[idx];\n\t\t}\n\t\tif(lazy[idx])\n\t\t{\n\t\t\tlazy_evaluate(idx);\n\t\t}\n\t\treturn max(query(beg,en,idx*2+1,lb,(lb+ub)/2),query(beg,en,idx*2+2,(lb+ub)/2+1,ub));\n\t}\n}seg_tree;\nint main()\n{\n\tint n;ll x;\n\tscanf(\"%d %lld\",&n,&x);\n\tseg_tree.update(0,maxs-1,0,0,maxs-1,x);\n\tpriority_queue<pair<ll,ll> >que;\n\tint ret=0;\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tll x,y;\n\t\tscanf(\"%lld %lld\",&x,&y);\n\t\tque.push(mp(y,i));\n\t\t\n\t\tfor(;;)\n\t\t{\n\t\t\tif(que.empty()) break;\n\t\t\tif(seg_tree.query(i+1,i+1,0,0,maxs-1)>x) break;\n\t\t\tpair<ll,ll>p=que.top(); que.pop();\n\t\t\tint v1=(x-seg_tree.query(p.second,i,0,0,maxs-1)/p.first;\n\t\t\tint v2=(1-seg_tree.query(i+1,i+1,0,0,maxs-1)+x+p.first-1)/p.first;\n\t\t\tif(v1>=v2)\n\t\t\t{\n\t\t\t\tret+=v1;\n\t\t\t\tseg_tree.update(p.second,maxs-1,0,0,maxs-1,v1*p.first);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tret+=v2;\n\t\t\t\tque.pop();\n\t\t\t\tseg_tree.update(p.second,maxs-1,0,0,maxs-1,v2*p.first);\n\t\t\t}\n\t\t}\n\t\tseg_tree.update(i+1,maxs-1,0,0,maxs-1,-x);\n\t}\n\tprintf(\"%d\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\ntypedef pair< int, int > Pi;\n\nconst int INF = 1 << 30;\n// 区間への加算, 最大値が求まればいいかんじに出来る\n\nint64 seg[1 << 18], added[1 << 18];\n\nvoid add( int a, int b, int64 value, int k = 0, int l = 0, int r = 1 << 17){ // [a,b)にvalueを足すやつ\n  if(r <= a || b <= l) return;\n  if(a <= l && r <= b) { // 完全に含んでたら足す\n    added[k] += value;\n  } else {\n    int mid = (l + r) >> 1;\n    add( a, b, value, 2 * k + 1, l, mid);\n    add( a, b, value, 2 * k + 2, mid, r);\n    seg[k] = max( seg[2 * k + 1] + added[2 * k + 1], seg[2 * k + 2] + added[2 * k + 2]);\n  }\n  return;\n}\n\nint64 query( int a, int b, int k = 0, int l = 0, int r = 1 << 17){ // [a,b)の最大値を返すやつ\n  if(r <= a || b <= l) return -INF;\n  if(a <= l && r <= b) return seg[k] + added[k];\n  int mid = (l + r) >> 1;\n  return max( query( a, b, 2 * k + 1, l, mid), query( a, b, 2 * k + 2, mid, r)) + added[k];\n}\n\n\n int main()\n {\n   int N, H;\n   int64 life = 0; // 今の体力\n   int64 ret = 0;\n\n   scanf(\"%d %d\", &N, &H);\n   life = H;\n   priority_queue< Pi > que; // first: 一回あたりの回復体力量, second: どこ\n   for(int i = 0; i < N - 1; i++){\n     add( i, i + 1, life); // 今の体力を更新\n     int d, h;\n     scanf(\"%d %d\", &d, &h);\n     que.push( Pi( h, i));\n\n     life -= d; // 降りる\n     while(life <= 0){\n       Pi p = que.top(); que.pop();\n       int64 lange = query( p.second, i + 1); // 回復量の最大値\n       if(p.first + lange > H)  {\n         que.push( Pi( H - lange, p.second));\n       } else {\n         int64 cnt = min((H - lange) / p.first, -life / p.first + 1LL); // 回復量の最大値 OR lifeまでの回復量\n         ret += cnt;\n         life += cnt * p.first;\n         add( p.second, i + 1, cnt * p.first);\n         que.push(p);\n       }\n     }\n   }\n   printf(\"%lld\\n\", ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\n  \nint main()\n{\n  int64 N, H, d[100000], h[100000];\n  int64 power = H, ret = 0LL;\n  int64 now[100000];\n  \n  scanf(\"%lld %lld\", &N, &H);\n  for(int i = 0; i < N - 1; i++) {\n    scanf(\"%lld %lld\", &d[i], &h[i]);\n  }\n  \n  for(int i = 0; i < N - 1; i++) {\n    now[i] = power;\n    power -= d[i];\n    while(power <= 0) {\n      int MaxPos = i;\n      int64 hoge = H;\n      for(int j = i; j >= 0; j--) {\n        hoge = min(hoge, H - now[j]);\n        h[j] = min(h[j], hoge);\n        if(h[MaxPos] < h[j]) MaxPos = j;\n        if(hoge == 0) break;\n      }\n      int64 hori = min(-power / h[MaxPos] + 1, (H - now[MaxPos]) / h[MaxPos]);\n      ret += hori;\n      power += hori * h[MaxPos];\n      for(int j = MaxPos; j <= i; j++) {\n        now[j] += hori * h[MaxPos];\n        now[j] = min(now[j], H);\n      }\n    }\n  }\n  printf(\"%lld\\n\", ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint N, H, d[100009], h[100009], dp[1009][1009];\nint main() {\n\tcin >> N >> H;\n\tassert(N <= 1000 && H <= 1000);\n\tfor (int i = 0; i < N - 1; i++) cin >> d[i] >> h[i];\n\tint count = 0;\n\tfor (int i = 0; i < N - 1; i++) {\n\t\tfill(dp[i + 1], dp[i + 1] + H + 1, 999999999);\n\t\tfor (int j = 1; j <= H; j++) {\n\t\t\tif (dp[i][j] == 999999999) continue;\n\t\t\tfor (int k = 0; j + (k - 1) * h[i] <= H; k++) {\n\t\t\t\tint val = min(j + k * h[i], H) - d[i];\n\t\t\t\tif (val > 0) dp[i + 1][val] = min(dp[i + 1][val], dp[i][j] + k);\n\t\t\t}\n\t\t}\n\t\tfor (int j = H - 1; j >= 1; j--) dp[i + 1][j] = min(dp[i + 1][j], dp[i + 1][j + 1]);\n\t\tvector<int> w;\n\t\tfor (int j = 1; j <= H - d[i]; j++) w.push_back(dp[i + 1][j]);\n\t\tcount += unique(w.begin(), w.end()) - w.begin();\n\t}\n\tcout << dp[N - 1][1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 28;\ntypedef pair<int, int> Pr;\n\nint N, H;\nint d[100000], h[100000];\n\nconst int size = 1 << 20;\nint seg_v[size * 2 - 1];\nint seg_a[size * 2 - 1];\nPr rmq[size * 2 - 1];\n\nvoid seg_add(int l, int r, int x, int k = 0, int a = 0, int b = size){\n\tif (b <= l || r <= a) return;\n\tif (l <= a && b <= r){\n\t\tseg_a[k] += x;\n\t\twhile (k){\n\t\t\tk = (k - 1) / 2;\n\t\t\tseg_v[k] = max(\n\t\t\t\tseg_v[k * 2 + 1] + seg_a[k * 2 + 1],\n\t\t\t\tseg_v[k * 2 + 2] + seg_a[k * 2 + 2]\n\t\t\t);\n\t\t}\n\t\treturn;\n\t}\n\t\n\tint m = (a + b) / 2;\n\tseg_add(l, r, x, k * 2 + 1, a, m);\n\tseg_add(l, r, x, k * 2 + 2, m, b);\n}\nint seg_getMax(int l, int r, int k = 0, int a = 0, int b = size){\n\tif (b <= l || r <= a) return -INF;\n\tif (l <= a && b <= r) return seg_a[k] + seg_v[k];\n\tint m = (a + b) / 2;\n\tint vl = seg_getMax(l, r, k * 2 + 1, a, m);\n\tint vr = seg_getMax(l, r, k * 2 + 2, m, b);\n\treturn seg_a[k] + max(vl, vr);\n}\n\nvoid rmq_update(int k, int x){\n\tint i = k;\n\tk += size - 1;\n\trmq[k] = Pr(x, i);\n\twhile (k){\n\t\tk = (k - 1) / 2;\n\t\trmq[k] = max(rmq[k * 2 + 1], rmq[k * 2 + 2]);\n\t}\n}\nPr _rmq_getMax(int l, int r, int k = 0, int a = 0, int b = size){\n\tif (b <= l || r <= a) return Pr(-INF, -1);\n\tif (l <= a && b <= r) return rmq[k];\n\tint m = (a + b) / 2;\n\tPr vl = _rmq_getMax(l, r, k * 2 + 1, a, m);\n\tPr vr = _rmq_getMax(l, r, k * 2 + 2, m, b);\n\treturn max(vl, vr);\n}\nint rmq_getMax(int l, int r){\n\treturn _rmq_getMax(l, r).first;\n}\nint rmq_getMaxIdx(int l, int r){\n\treturn _rmq_getMax(l, r).second;\n}\n\nvoid solve()\n{\n\tlong long int res = 0;\n\t\n\tfor (int i = 0; i < N; i++){\n\t\trmq_update(i, h[i]);\n\t}\n\t\n\tseg_add(0, N, H);\n\t\n\tfor (int fl = 0; fl < N; fl++){\n\t\tif (seg_getMax(fl, fl + 1) > H){\n\t\t\tseg_add(fl, N, H - seg_getMax(fl, fl + 1));\n\t\t}\n\t\t\n\t\tseg_add(fl, N, -d[fl]);\n\t\t//printf(\"%dF HP=%d\\n\", fl, seg_getMax(fl, fl + 1));\n\t\tif (seg_getMax(fl, fl + 1) > 0) continue;\n\t\t\n\t\twhile (true){\n\t\t\tint idx = rmq_getMaxIdx(0, fl);\n\t\t\tif (h[idx] > H - seg_getMax(idx, fl)){\n\t\t\t\th[idx] = H - seg_getMax(idx, fl);\n\t\t\t\trmq_update(idx, h[idx]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tseg_add(idx, N, h[idx]);\n\t\t\t\n\t\t\tres++;\n\t\t\t//printf(\"! %dF HP=%d\\n\", fl, seg_getMax(fl, fl + 1));\n\t\t\tif (seg_getMax(fl, fl + 1) > 0) break;\n\t\t}\n\t\t\n\t\t//printf(\"%dF HP=%d\\n\", fl, seg_getMax(fl, fl + 1));\n\t}\n\t\n\tprintf(\"%lld\\n\", res);\n}\n\nint main()\n{\n\tscanf(\"%d %d\", &N, &H);\n\tfor (int i = 0; i < N - 1; i++){\n\t\tscanf(\"%d %d\", d + i + 1, h + i);\n\t}\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n\nint N,H,d[100000],h[100000],sum[100000];\nsigned main(){\n    cin>>N>>H;\n    rep(i,N-1)cin>>d[i]>>h[i];\n\n    sum[0]=H;\n    rep(i,N-1)sum[i+1]=sum[i]-d[i];\n    int D=0;\n\n    int ans=0,idx=0;\n    deque<int>deq;\n    rep(i,N-1){\n\n        if(H-(sum[i]-D)<=h[i]){\n            deq.clear();\n            idx=i;\n        }\n        else{\n            while(deq.size()&&h[deq.back()]<=h[i])deq.pop_back();\n            deq.push_back(i);\n        }\n\n        while(sum[i+1]-D<=0){\n            if(deq.size()&&H-(sum[idx]-D)<=h[deq.front()]){\n                int j=deq.front();\n                int t=min((H-(sum[j]-D))/h[j],(D-sum[i+1])/h[j]+1);\n                ans+=t;\n                D-=t*h[j];\n                while(deq.size()&&H-(sum[deq.front()]-D)<h[j]){\n                    deq.pop_front();\n                    idx=j;\n                }\n            }\n            else{\n                ans++;\n                D-=H-(sum[idx]-D);\n            }\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fst(t) std::get<0>(t)\n#define snd(t) std::get<1>(t)\n#define thd(t) std::get<2>(t)\n#define unless(p) if(!p)\n#define until(p) while(!p)\n\nusing ll = long long;\nusing P = std::tuple<ll,ll>;\n\nconst int dx[8] = {-1, 1, 0, 0, -1, -1, 1, 1}, dy[8] = {0, 0, -1, 1, -1, 1, -1, 1};\n\nll N, H;\nll hs[100100];\nll life[100100];\nstd::priority_queue<P> pq;\n\nint main(){\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    std::cin >> N >> H;\n\n    life[0] = H;\n    for(int i=0;i<N-1;++i){\n        ll d;\n        std::cin >> d >> hs[i];\n\n        life[i+1] = life[i] - d;\n    }\n    \n    int last = -1;\n    ll recovery = 0ll, counter = 0ll;\n\n    for(int i=0;i<N-1;++i){\n        pq.emplace(min(hs[i], H - (life[i] + recovery)), i);\n\n        while(life[i+1] + recovery <= 0){\n            ll h, idx;\n            tie(h, idx) = pq.top();\n            pq.pop();\n\n            if(idx < last){continue;}\n            ll needs = -(life[i+1] + recovery) + 1,\n                rest = H - (life[idx] + recovery);\n            if(rest < h){\n                if(rest > 0){\n                    pq.emplace(rest, idx);\n                }\n                continue;\n            }\n\n            ll t = min((needs + h - 1) / h, (rest + h - 1) / h);\n            recovery += min(h * t, rest);\n            counter += t;\n            ll new_h = min(h, H - (life[idx] + recovery));\n            if(new_h > 0){\n                pq.emplace(new_h, idx);\n            }\n            last = idx;\n        }\n    }\n\n    std::cout << counter << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n  long long int n, h, d, hp, maxhp, damage = 0, ans = 0;\n  deque<pair<long long int, long long int> > izumi;\n  scanf(\"%lld%lld\", &n, &hp);\n  maxhp = hp;\n  for(int i = 0;i < n - 1;i++){\n    scanf(\"%lld%lld\", &d, &h);\n    while(!izumi.empty() && izumi.back().first < h){\n      izumi.pop_back();\n    }\n    izumi.push_back(make_pair(h, damage));\n    damage += d;\n    while(hp <= damage){\n      long long int tmphp = hp ;\n      while(!izumi.empty() && tmphp + izumi.front().first - izumi.front().second > maxhp){\n\thp = max(hp, izumi.front().second + maxhp);\n\tizumi.pop_front();\n      }\n      if(!izumi.empty()){\n\thp = max(hp, tmphp + izumi.front().first);\n\tint tmp = max(0ll, min((damage - hp) / izumi.front().first, (izumi.front().second + maxhp - hp) / izumi.front().first));\n\tans += tmp;\n\thp += tmp * izumi.front().first;\n      }\n      ans++;\n    }\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\ntypedef pair< int, int > Pi;\n \nconst int INF = 1 << 30;\n// 区間への加算, 最大値が求まればいいかんじに出来る\n \nint64 seg[1 << 18], added[1 << 18];\n \ninline void add( int a, int b, int64 value, int k = 0, int l = 0, int r = 1 << 17){ // [a,b)にvalueを足すやつ\n  if(r <= a || b <= l) return;\n  if(a <= l && r <= b) { // 完全に含んでたら足す\n    added[k] += value;\n  } else {\n    int mid = (l + r) >> 1;\n    add( a, b, value, 2 * k + 1, l, mid);\n    add( a, b, value, 2 * k + 2, mid, r);\n    seg[k] = max( seg[2 * k + 1] + added[2 * k + 1], seg[2 * k + 2] + added[2 * k + 2]);\n  }\n  return;\n}\n \ninline int64 query( int a, int b, int k = 0, int l = 0, int r = 1 << 17){ // [a,b)の最大値を返すやつ\n  if(r <= a || b <= l) return -INF;\n  if(a <= l && r <= b) return seg[k] + added[k];\n  int mid = (l + r) >> 1;\n  return max( query( a, b, 2 * k + 1, l, mid), query( a, b, 2 * k + 2, mid, r)) + added[k];\n}\n \n \n int main()\n {\n   int N, H;\n   int64 life = 0; // 今の体力\n   int64 ret = 0;\n \n   scanf(\"%d %d\", &N, &H);\n   life = H;\n   priority_queue< Pi > que; // first: 一回あたりの回復体力量, second: どこ\n   for(int i = 0; i < N - 1; i++){\n     add( i, i + 1, life); // 今の体力を更新\n     int d, h;\n     scanf(\"%d %d\", &d, &h);\n     que.push( Pi( h, i));\n \n     life -= d; // 降りる\n     while(life <= 0){\n       Pi p = que.top(); que.pop();\n       int64 lange = query( p.second, i + 1); // 回復量の最大値\n       if(p.first + lange > H)  {\n         que.push( Pi( H - lange, p.second));\n       } else {\n         int64 cnt = min((H - lange) / p.first, -life / p.first + 1LL); // 回復量の最大値 OR lifeまでの回復量\n         ret += cnt;\n         life += cnt * p.first;\n         add( p.second, i + 1, cnt * p.first);\n         que.push(p);\n       }\n     }\n   }\n   printf(\"%lld\\n\", ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\ntemplate<typename T>\nclass LazyPropagationSegmentTree {\npublic:\n  LazyPropagationSegmentTree(int n) : size_(1) {\n    while(size_ < n) size_ <<= 1;\n    node_.assign(size_ << 1, 0);\n    lazy_.assign(size_ << 1, 0);\n  }\n  T find(int left, int right) {return find(left, right + 1, 1, 0, size_);}\n  void add(int left, int right, T value) {add(left, right + 1, value, 1, 0, size_);}\nprivate:\n  int left_child(int node) const {return node << 1;}\n  int right_child(int node) const {return (node << 1) + 1;}\n  T find(int a, int b, int k, int l, int r) {\n    if(b <= l || r <= a) return 0;\n    if(a <= l && r <= b) return node_.at(k) + (r - l) * lazy_.at(k);\n    lazy_.at(left_child(k)) += lazy_.at(k);\n    lazy_.at(right_child(k)) += lazy_.at(k);\n    lazy_.at(k) = 0;\n    auto vl = find(a, b, left_child(k), l, (l + r) / 2);\n    auto vr = find(a, b, right_child(k), (l + r) / 2, r);\n    return vl + vr;\n  }\n  T add(int a, int b, T value, int k, int l, int r) {\n    if(b <= l || r <= a) return node_.at(k) + (r - l) * lazy_.at(k);\n    if(a <= l && r <= b) return node_.at(k) + (r - l) * (lazy_.at(k) += value);\n    lazy_.at(left_child(k)) += lazy_.at(k);\n    lazy_.at(right_child(k)) += lazy_.at(k);\n    lazy_.at(k) = 0;\n    auto vl = add(a, b, value, left_child(k), l, (l + r) / 2);\n    auto vr = add(a, b, value, right_child(k), (l + r) / 2, r);\n    return node_.at(k) = vl + vr;\n  }\n  int size_;\n  std::vector<T> node_;\n  std::vector<T> lazy_;\n};\n\n#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Node {int f; long long h;};\nbool operator<(const Node& lhs, const Node& rhs) {\n  if(lhs.h != rhs.h) return lhs.h < rhs.h;\n  return lhs.f < rhs.f;\n}\n\nint main() {\n  int N, H;\n  cin >> N >> H;\n\n  LazyPropagationSegmentTree<long long> hp(N + 1);\n  hp.add(0, N, H);\n\n  long long answer = 0;\n  int last = 0;\n  priority_queue<Node> q;\n\n  for(int i = 1; i < N; ++i) {\n    long long d, h;\n    cin >> d >> h;\n\n    q.push({i, h});\n    hp.add(i, N, -d);\n\n    while(hp.find(i, i) <= 0) {\n      auto node = q.top();\n\n      if(node.f < last) {\n        q.pop();\n        continue;\n      }\n\n      if(H < node.h + hp.find(node.f-1, node.f-1)) {\n        q.pop();\n        q.push({node.f, H - hp.find(node.f-1, node.f-1)});\n        continue;\n      }\n\n      last = node.f;\n      int use = min((-hp.find(i, i) / node.h) + 1, (H - hp.find(node.f-1, node.f-1)) / node.h);\n      answer += use;\n      hp.add(node.f-1, N, use * node.h);\n    }\n  }\n\n  cout << answer <<endl;\n}"
  },
  {
    "language": "C++",
    "code": "//Bokan ga bokka--nn!!\n//Daily Lunch Special Tanoshii !!\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\n#include <deque>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\ntypedef long long ll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\n#define s(x) scanf(\"%d\",&x)\n#define rep(i,x) for(int i=0;i<x;i++)\nint main()\n{\n\tint n;\n\tll maxv;\n\tscanf(\"%d %lld\",&n,&maxv);\n\tll totv=maxv;\n\tll totd=0LL;\n\tdeque<pair<ll,ll> >deq;\n\tll ret=0LL;\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tll a,b;\n\t\tscanf(\"%lld %lld\",&a,&b);\n\t\twhile(!deq.empty() && deq.back().first<b) deq.pop_back();\n\t\tdeq.pb(mp(b,totd));\n//printf(\"%d %d %lld %lld %lld\\n\",i,deq.size(),totv,totd,ret);\n\t\ttotd+=a;\n\t\twhile(totv<=totd)\n\t\t{\n\t\t\tll bef=totv;\n\t\t\twhile(!deq.empty())\n\t\t\t{\n\t\t\t\tif(bef+deq.front().first-deq.front().second>maxv)\n\t\t\t\t{\n\t\t\t\t\ttotv=max(totv,maxv+deq.front().second);\n\t\t\t\t\tdeq.pop_front();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tll kai=deq.front().first;\n\t\t\tll prev=deq.front().second;\n\t\t\tif(!deq.empty())\n\t\t\t{\n\t\t\t\ttotv=min(maxv+prev,max(totv,bef+kai));\n\t\t\t\tll pv=max(0ll,min((totd-totv)/kai,(prev+maxv-totv)/kai));\n        \t\t\tret+=pv;\n        \t\t\ttotv+=pv*kai;\n      \t\t\t}\n      \t\t\tret++;\n//cout << ret << \" \" << totv << endl;\n      \t\t}\n\t}\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<map>\n#define INF 20000000\nusing namespace std;\ntypedef pair<int,int> P;\nint d[100000];\nint p[100000];\nP deq[200000];\nint max(int a,int b){return a>b?a:b;}\nint min(int a,int b){return a<b?a:b;}\nint main(){\n\tint n,mh;\n\tint i;\n\tscanf(\"%d %d\",&n,&mh);\n\tfor(i=0;i<n-1;i++)scanf(\"%d %d\",&d[i],&p[i]);\n\tlong long ans=0;\n\tint l=0,r=0;\n\tint s=0,t=0;\n\tint lim=0;\n\tint h=mh;\n\twhile(r<n-1){\n\t\twhile(s<t&&deq[t-1].first<p[r])t--;\n\t\tdeq[t++]=P(p[r],r);\n\t\twhile(h<=d[r]){\n\t\t\twhile(l<r&&min(lim,p[l])<deq[s].first){\n\t\t\t\tlim+=d[l++];\n\t\t\t\twhile(s<t&&deq[s].second<=l)s++;\n\t\t\t}\n\t\t\tint rec=d[r]-h+1;\n\t\t\tint a=rec/p[l];\n\t\t\tint b=lim/p[l];\n\t\t\tint c=min(a,b);\n\t\t\tif(c==0)c++;\n\t\t\tans+=c;\n\t\t\tint add=c*p[l];\n\t\t\tif(add>lim)add=lim;\n\t\t\tlim-=add;\n\t\t\th+=add;\n\t\t\tif(h>mh)h=mh;\n\t\t}\n\t\th-=d[r];\n\t\tr++;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Bokan ga bokka--nn!!\n//Daily Lunch Special Tanoshii !!\n//これは、頭が悪く競プロが世界で一番できないHIR180が\n//IOI2014日本代表になるまでのN日間の記録である。\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\ntypedef long long ll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\n#define f first\n#define s second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SIZE (1<<17)\nll out[100005],got[100005];\nstruct segtree\n{\n\tll seg[SIZE*2];\n\tll lazy[SIZE*2];\n\tvoid lazy_evaluate(int k)\n\t{\n\t\tseg[k*2+1]+=lazy[k];\n\t\tseg[k*2+2]+=lazy[k];\n\t\tlazy[k*2+1]+=lazy[k];\n\t\tlazy[k*2+2]+=lazy[k];\n\t\tlazy[k]=0;\n\t}\n\tll update(int a,int b,int k,int l,int r,ll num)\n\t{\n\t\tif(lazy[k] && l!=r) lazy_evaluate(k);\n\t\tif(b<l || r<a) return seg[k];\n\t\tif(a<=l && r<=b)\n\t\t{\n\t\t\tseg[k]+=num;\n\t\t\tlazy[k]+=num;\n\t\t\treturn seg[k];\n\t\t}\n\t\treturn seg[k]=max(update(a,b,k*2+1,l,(l+r)/2,num),update(a,b,k*2+2,(l+r)/2+1,r,num));\n\t}\n\tll query(int a,int b,int k,int l,int r)\n\t{\n\t\tif(lazy[k] && l!=r) lazy_evaluate(k);\n\t\tif(b<l || r<a) return -1LL*INF;\n\t\tif(a<=l && r<=b)\n\t\t{\n\t\t\treturn seg[k];\n\t\t}\n\t\treturn max(query(a,b,k*2+1,l,(l+r)/2),query(a,b,k*2+2,(l+r)/2+1,r));\n\t}\n}seg;\nint main()\n{\n\tsrand((unsigned int)time(NULL));\n\tint n; ll maxv; scanf(\"%d %lld\",&n,&maxv);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tscanf(\"%lld %lld\",&out[i],&got[i]);\n\t}\n\tseg.update(1,SIZE-1,0,0,SIZE-1,maxv);\n\tll ret=0;\n\tpriority_queue<P>que;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tll cur=seg.query(i,i,0,0,SIZE-1);\n\t\twhile(cur<=out[i]&&!que.empty())\n\t\t{\n\t\t\t//cout << ret << \" \"  << i << \" \" << cur << endl;\n\t\t\tint id=que.top().s;\n\t\t\tll gott=que.top().f;\n\t\t\tque.pop();\n\t\t\tll recov,upper;\n\t\t\trecov=(1+out[i]-cur+gott-1)/gott;\n\t\t\tupper=(maxv-seg.query(id,i,0,0,SIZE-1))/gott;\n\t\t\tif(recov<=upper)\n\t\t\t{\n\t\t\t\tseg.update(id,SIZE-1,0,0,SIZE-1,recov*gott);\n\t\t\t\tcur+=recov*gott; ret+=recov;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tseg.update(id,SIZE-1,0,0,SIZE-1,upper*gott);\n\t\t\t\tif(maxv-seg.query(id,i,0,0,SIZE-1)>0) que.push(mp(maxv-seg.query(id,i,0,0,SIZE-1),id));\n\t\t\t\tret+=upper; cur+=upper*gott;\n\t\t\t}\n\t\t}\n\t\tque.push(mp(got[i],i));\n\t\tseg.update(i+1,SIZE-1,0,0,SIZE-1,-1LL*out[i]);\n\t}\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\n  \nint main()\n{\n  int64 N, H, d[100000], h[100000];\n  int64 now[100000];\n  \n  scanf(\"%lld %lld\", &N, &H);\n  for(int i = 0; i < N - 1; i++) {\n    scanf(\"%lld %lld\", &d[i], &h[i]);\n  }\n  \n  int64 power = H, ret = 0LL;\n  for(int i = 0; i < N - 1; i++) {\n    now[i] = power;\n    power -= d[i];\n    while(power <= 0) {\n      int MaxPos = i;\n      int64 hoge = H;\n      for(int j = i; j >= 0; j--) {\n        hoge = min(hoge, H - now[j]);\n        h[j] = min(h[j], hoge);\n        if(h[MaxPos] < h[j]) MaxPos = j;\n        if(hoge == 0) break;\n      }\n      int64 hori = min(-power / h[MaxPos] + 1, (H - now[MaxPos]) / h[MaxPos]);\n      ret += hori;\n      power += hori * h[MaxPos];\n      for(int j = MaxPos; j <= i; j++) {\n        now[j] += hori * h[MaxPos];\n        now[j] = min(now[j], H);\n      }\n    }\n  }\n  printf(\"%lld\\n\", ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define sc second\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\n\nusing namespace std;\n#define N 100010\nll n,h;\ntypedef pair<ll,pair<bool,ll> >P;\nvector<P> Q;\nmap<ll,ll> m;\nint main(){\n    cin>>n>>h;\n    ll sum=0;\n    lol(i,n-1){\n\tll a,b;\n\tscanf(\"%lld%lld\",&a,&b);\n\tQ.pb(mp(sum+1,mp(0,b)));\n\tQ.pb(mp(sum+h-b,mp(1,b)));\n\tsum+=a;\n    }\n    sort(Q.begin(),Q.end());\n    ll pnt=h,ans=0,to=0,p=0;m[0]=1;\n    while(pnt<=sum){\n\tfor(;p<Q.size();p++){\n\t    ll t=Q[p].fi,k=Q[p].sc.sc;\n\t    if(t>pnt)break;\n\t    if(Q[p].sc.fi){\n\t\tm[k]--;if(!m[k])m.erase(k);\n\t\tto=max(to,t+k);\n\t    }\n\t    else m[k]++;\n\t}\n\tauto it=m.end();it--;ll k=it->fi;\n\tif(k>=to-pnt){\n\t    ll mov=(min(Q[p].first,sum+1)-pnt+k-1)/k;\n\t    ans+=mov,pnt+=mov*k;\n\t}\n\telse pnt=to,ans++;\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<long long> vll;\ntypedef pair<int,int> pint;\ntypedef pair<long long, long long> pll;\n\n#define MP make_pair\n#define PB push_back\n#define ALL(s) (s).begin(),(s).end()\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P) \n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P) \n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P) \n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s; }\n\n\nconst int MAX = 100100;\nconst int INF = 1<<29;\n\nint SIZE_R;\nstruct RMQ {\n    pair<int, int> dat[4*MAX];\n    \n    void init(int n = MAX, int v = -INF) {\n        SIZE_R = 1;\n        while (SIZE_R < n) SIZE_R *= 2; \n        for (int i = 0; i < 2*MAX-1; ++i) dat[i] = make_pair(v, -1);\n    }\n    \n    inline void set(int a, int x) { \n        int k = a + SIZE_R-1;\n        dat[k] = make_pair(x, a);\n    }\n    \n    void init_tree(int k = 0, int l = 0, int r = SIZE_R) {\n        if (r - l == 1) {}                  // leaf\n        else {\n            init_tree(k*2+1, l, (l+r)/2);\n            init_tree(k*2+2, (l+r)/2, r);\n            dat[k] = max(dat[k*2+1], dat[k*2+2]);\n        }\n    }\n    \n    inline void update(int a, int x) {\n        int k = a + SIZE_R-1;\n        dat[k] = make_pair(x, a);\n        while (k > 0) {\n            k = (k-1)/2;\n            dat[k] = max(dat[k*2+1], dat[k*2+2]);\n        }\n    }\n    \n    inline pair<int, int> get(int a, int b, int k = 0, int l = 0, int r = SIZE_R) {\n        if (r <= a || b <= l) return pair<int, int>(-INF, -1);\n        if (a <= l && r <= b) return dat[k];\n        else {\n            pair<int, int> vl = get(a, b, k*2+1, l, (l+r)/2);\n            pair<int, int> vr = get(a, b, k*2+2, (l+r)/2, r);\n            return max(vl, vr);\n        }\n    }\n    \n    void print(int r = SIZE_R) {\n        for (int i = 0; i < SIZE_R; ++i) {cout << get(i, i+1) << \",\";}\n        cout << endl;\n    }\n};\n\nRMQ rmq;\n\n\nint N;\nlong long H;\nint d[MAX], r[MAX];\n\nlong long sum[MAX];\nint next[MAX];\n\nint main() {\n    //freopen( \"/Users/macuser/Dropbox/Contest/input.in\", \"r\", stdin );\n    \n    while (cin >> N >> H) {\n        --H;\n        rmq.init(N+1);\n        for (int i = 1; i < N; ++i) {\n            cin >> d[i] >> r[i];\n            rmq.set(i, r[i]);\n        }\n        rmq.init_tree(); \n        \n        for (int i = 0; i <= N; ++i) next[i] = N;\n        stack<pint> st;\n        st.push( pint(1<<29, -1) );\n        for (int i = 1; i < N; ++i) {\n            if (r[i] <= st.top().first) {\n                st.push( pint(r[i], i) );\n            }\n            else {\n                while (true) {\n                    pint p = st.top();\n                    if (p.first < r[i]) { next[p.second] = i; st.pop(); }\n                    else { st.push(pint(r[i], i) ); break; }\n                }\n            }\n        }\n        \n        //memset(sum, 0, sizeof(sum));\n        for (int i = 0; i <= N; ++i) sum[i+1] = sum[i] + d[i+1];\n        \n        \n        int pos = 1, hp = H;\n        int res = 0;\n        \n        while (true) {\n            int H_MAX = hp + (H - hp) / r[pos] * r[pos];\n            \n            int npos = next[pos];\n            long long need = sum[npos-1] - sum[pos-1];\n            \n//            cout << endl;\n//            COUT(pos);\n//            COUT(hp);\n//            COUT(H_MAX);\n//            COUT( next[pos]);\n//            COUT(need);\n            \n            if (need > H_MAX) {\n                int add1 = (H_MAX - hp) / r[pos];\n                res += add1;\n                \n                int lo = pos, hi = npos;\n                while (hi - lo > 1) {\n                    int med = (lo + hi) / 2;\n                    long long deg = sum[med-1] - sum[pos-1];\n                    if (deg > H_MAX) hi = med;\n                    else lo = med;\n                }\n                \n                rmq.update(pos, H - H_MAX);\n                pint np = rmq.get(pos, lo+1);\n                \n                //COUT(lo); COUT(np);\n                \n                npos = np.second;\n                \n                if (npos == pos) {\n                    res += 1;\n                    hp = H;\n                }\n                else {\n                    long long need = sum[npos-1] - sum[pos-1];\n                \n                    hp = H_MAX - need;\n                    pos = npos;\n                }\n            }\n            else {\n                if (hp >= need) {\n                    hp -= need;\n                }\n                else {\n                    long long need_up = need - hp;\n                    long long add = (need_up + r[pos] - 1) / r[pos];\n                    \n                    res += add;\n                    hp += add * r[pos] - need;\n                }\n                pos = npos;\n            }\n            \n            //cout << pos << \", \" << hp << \"(\" << res << \")\" << endl;\n            \n            if (pos >= N) break;\n        }\n        \n        cout << res << endl;\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\nconst int MAX_N = 1000100;\n\nclass segTree{\n    public:\n        int n;\n        vector<int> dat;\n        void init(int n_, int value, int dat_b[4 * MAX_N] = NULL){\n            n = 1;\n            while(n < n_) n *= 2;\n\n            dat = vector<int>(4 * n);\n            rep(i,2 * n){\n                dat[i] = value;\n                if(dat_b != NULL) dat_b[i] = value;\n            }\n        }\n        void output(vector<int> a){\n            show(\"print\");\n            range(i,1,n * 2) cout << (a[i] == INT_MAX ? -1 : a[i]) << ' ';\n            cout << endl;\n        }\n};\n\nclass rangeMinimumQuery : public segTree{\n    private:\n        int query(int a, int b, int k, int l, int r){\n            //[a, b) ??¨[l, r)???????????????????????°???INT_MAX\n            if(r <= a || b <= l) return INT_MAX;\n            //[a,b)???[l,r)????????¨???????????§????????°?????????????????????\n            if(a <= l && r <= b) return dat[k];\n\n            //????????§???????????°??????????????????????°????\n            int vl = query(a, b, k * 2, l, ( l + r) / 2);\n            int vr = query(a, b, k * 2 + 1, (l + r) / 2, r);\n            return min(vl, vr);\n        }\n    public:\n        void init(int n_){ segTree::init(n_,INT_MAX); }\n        void update(int i, int x){\n            i += n; //????????????\n            dat[i] = x;\n            while(i > 0){ //?????????????????´??°\n                dat[i / 2] = min(dat[i], dat[i^1]);\n                i = i / 2;\n            }\n        }\n        //[a, b)???????°????????±???????\n        int query(int a, int b){ return query(a,b,1,0,n); }\n};\n\nclass rangeUpdateQuery : public segTree{ //??????????????????update??§?????????min??¨???sum???????????????\n    private:\n        int dat_lazy[4 * MAX_N]; //?????¶???????????????????????????\n        int query(int a, int b, int k, int l, int r){\n            //???????£?\n            evaluate(k);\n\n            if(b <= l || r <= a) return INT_MAX;\n            else if(a <= l && r <= b) return dat[k];\n\n            int vl = query(a, b, k * 2, l, (l + r) / 2);\n            int vr = query(a, b, k * 2 + 1, (l + r) / 2, r);\n            return min(vl, vr);\n        }\n        inline void evaluate(int k){\n            if(dat_lazy[k] == INT_MAX) return;\n            dat[k] = dat_lazy[k];\n            if(k < n){\n                dat_lazy[2 * k] = dat_lazy[k]; //?????¶????????¬????????¨???\n                dat_lazy[2 * k + 1] = dat_lazy[k];\n            }\n            dat_lazy[k] = INT_MAX;\n        }\n        void update(int a, int b, int k, int l, int r, int x){\n            evaluate(k);\n\n            if(b <= l || r <= a ) return;\n\n            if(a <= l && r <= b){\n                dat_lazy[k] = x;\n            }else{\n                evaluate(k);\n                update(a, b, k * 2, l, (l + r) / 2, x);\n                update(a, b, k * 2 + 1, (l + r) / 2, r, x);\n            }\n        }\n    public:\n        void init(int n_){ segTree::init(n_,INT_MAX,dat_lazy); }\n        int query(int a, int b){ return query(a,b,1,0,n); }\n        void update(int s, int t, int x){ update(s, t, 1, 0, n, x); }\n        void update(int i, int x){ update(i, i + 1, 1, 0, n, x); }\n        int get(int a){ return query(a, a + 1); };\n};\n\nclass starrySky : public segTree{\n    private:\n        int query(int a, int b, int k, int l, int r){\n            if(b <= l || r <= a) return 0;\n            if(a <= l && r <= b) return dat[k] + dat_add[k];\n\n            int vl = query(a, b, k * 2, l, (l + r) / 2);\n            int vr = query(a, b, k * 2 + 1, (l + r) / 2, r);\n            return max(vl, vr) + dat_add[k];\n        }\n        void add(int a, int b, int k, int l, int r, int x){\n            if(b <= l || r <= a) return;\n            if(a <= l && r <= b){\n                dat_add[k] += x;\n            }else{\n                add(a, b, k * 2, l, (l + r) / 2, x);\n                add(a, b, k * 2 + 1, (l + r) / 2, r, x);\n                dat[k] = max(dat[k * 2] + dat_add[k * 2], dat[k * 2 + 1] + dat_add[k * 2 + 1]);\n            }\n        }\n        void init(int n_){ segTree::init(n_,0,dat_add); }\n    public:\n        int dat_add[4 * MAX_N];\n        starrySky(int n){ init(n); }\n        int query(int a, int b){ return query(a, b, 1, 0, n); }\n        void add(int s, int t, int x){ add(s, t, 1, 0, n, x); }\n        void add(int i, int x){ add(i, i + 1, 1, 0, n, x); }\n};\n\n\nint main(){\n    int h, w, q;\n    while(cin >> h >> w >> q, h){\n        bool f = false;\n        if(h > w){\n            swap(h, w);\n            f = true;\n        }\n        vector<rangeMinimumQuery> seg(h);\n        rep(i,h){\n            seg[i].init(w);\n            rep(j,w){\n                int x;\n                cin >> x;\n                seg[i].update(j, x);\n            }\n        }\n        rep(i,q){\n            pair<int, int> a, b;\n            cin >> a.first >> a.second >> b.first >> b.second;\n            if(f){\n                swap(a.first, a.second);\n                swap(b.first, b.second);\n            }\n            //a.second++; b.second++;\n            //cout << a.first << ' ' << a.second << endl;\n            //cout << b.first << ' ' << b.second << endl;\n            //show(seg[0].query(1,9));\n\n            int ans = INT_MAX;\n            for(int i = a.first; i <= b.first; i++){\n                //show(i)\n                //show(seg[i].query(a.second, b.second + 1));\n                ans = min(ans, seg[i].query(a.second, b.second + 1));\n            }\n            cout << ans << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 1LL << 50;\nconst int MAX_N = 1 << 17;\nconst int def = 0;\n\nstruct MaxSegTree2 {\n\tint n;\n\tll segMax[2 * MAX_N - 1], segAdd[2 * MAX_N - 1];\n\tvoid init(int n_) {\n\t\tn = 1;\n\t\twhile(n < n_) n *= 2;\n\t\tfor(int i = 0; i < 2 * n - 1; i++) segMax[i] = def;\n\t}\n\n\tvoid add(int a, int b, ll x) { add(a, b, x, 0, 0, n); }\n\n\tvoid add(int a, int b, ll x, int k, int l, int r) {\n\t\tif(r <= a || b <= l) return;\n\t\tif(a <= l && r <= b) {\n\t\t\tsegAdd[k] += x;\n\t\t\treturn;\n\t\t}\n\t\tadd(a, b, x, k * 2 + 1, l, (l + r) / 2);\n\t\tadd(a, b, x, k * 2 + 2, (l + r) / 2, r);\n\t\tsegMax[k] = max(segMax[k * 2 + 1] + segAdd[k * 2 + 1], segMax[k * 2 + 2] + segAdd[k * 2 + 2]);\n\t}\n\n\tll query(int a, int b) { return query(a, b, 0, 0, n); }\n\n\tll query(int a, int b, int k, int l, int r) {\n\t\tif(r <= a || b <= l) return -INF;\n\t\tif(a <= l && r <= b) return segMax[k] + segAdd[k];\n\t\tll vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tll vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn max(vl, vr) + segAdd[k];\n\t}\n};\n\nMaxSegTree2 st;\ntypedef pair<ll, int> P;\n\nll d[100000];\nll heal[100000];\nint c[1000000];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tifstream ifs(\"input.txt\");\n\tcin.rdbuf(ifs.rdbuf());\n\tofstream ofs(\"output.txt\");\n\tcout.rdbuf(ofs.rdbuf());\n\n\tint N, H;\n\tcin >> N >> H;\n\tst.init(N);\n\tst.add(0, N, H);\n\tfor(int i = 0; i < N - 1; i++) {\n\t\tcin >> d[i] >> heal[i];\n\t\tst.add(i + 1, N, -d[i]);\n\t}\n\tll hp = H, ans = 0;\n\tpriority_queue<P> q; // <head,idx>\n\tfor(int i = 0; i < N - 1; i++) {\n\t\t////cerr << \"d : \" << d[i] << \", heal : \" << heal[i] << endl;\n\t\tq.push({ heal[i], i });\n\t\tif(hp - d[i] >= 1) {\n\t\t\thp -= d[i];\n\t\t}\n\t\telse {\n\t\t\twhile(hp - d[i] <= 0) {\n\t\t\t\tP p = q.top();\n\t\t\t\tq.pop();\n\t\t\t\tll h = p.first, idx = p.second;\n\n\t\t\t\tll x = -hp + d[i] + 1;\n\t\t\t\tll rem = H - st.query(idx, N);\n\t\t\t\tassert(rem >= 0);\n\t\t\t\tif(rem == 0) continue;\n\t\t\t\tif(rem < h) {\n\t\t\t\t\tq.push({ rem, idx });\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint cnt = (x + h - 1) / h;\n\t\t\t\tif(h * cnt > rem) cnt = rem / h;\n\t\t\t\t//cerr << \"idx : \" << idx << \", h : \" << h << \", cnt : \" << cnt << endl;\n\t\t\t\t//cerr << hp << \" -> \";\n\t\t\t\thp = min(ll(H), hp + h * cnt);\n\t\t\t\t//cerr << hp << endl;\n\t\t\t\tans += cnt;\n\t\t\t\tc[idx] += cnt;\n\t\t\t\tst.add(idx, N, h * cnt);\n\t\t\t\trem -= h * cnt;\n\t\t\t\tif(rem > 0) {\n\t\t\t\t\tq.push({ min(rem, h), idx });\n\t\t\t\t}\n\t\t\t}\n\t\t\thp -= d[i];\n\t\t}\n\t\t/*for(int j = 0; j < N - 1; j++) {\n\t\t\tcout << st.query(j, j + 1) << \" \";\n\t\t\t}\n\t\t\tcout << endl;*/\n\t\t////cerr << \"hp : \" << hp << endl;\n\n\t}\n\tcout << ans << endl;\n\n\thp = H;\n\tfor(int i = 0; i < N; i++) {\n\t\thp = min(ll(H), hp + c[i] * heal[i]);\n\t\thp -= d[i];\n\t\tassert(hp >= 1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,pair<ll,ll> > pp;\npp mm[100001];\nll d[100001];\n\nint main(){\n    ll n,h;\n    ll ans=0;\n    cin>>n>>h;\n    ll di,hi,ch=h;\n    for(int i=0;i<n-1;++i){\n        cin>>di>>hi;\n        mm[i].first=ch+hi<=h||ch<0 ? hi:h-ch;mm[i].second.first=i;mm[i].second.second=ch;\n        d[i]=di;\n        ch -= di;\n    }\n    int l=0;\n    for(int i=0;i<n;++i){\n        ch=mm[i].second.second;\n        if(ch<=0){\n            pp t=*max_element(mm+l,mm+i);\n            hi=t.first;\n            int ch2=t.second.second;\n            i=t.second.first;l=i;\n            int div;\n            if(-ch/hi+1>(h-ch2)/hi){\n                div=(h-ch2)/hi;\n                ans+=div;\n                ch=ch2+hi*div;\n            } \n            else{\n                div=-ch/hi+1;\n                ans+=div;\n                ch=min(h,ch2+hi*div); \n            }             \n        }\n        hi=mm[i].first;\n        mm[i].first=ch+hi>h ? h-ch:hi;\n        mm[i].second.second=ch; \n        mm[i+1].second.second= ch-d[i];\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n\nint N,H,d[100000],h[100000],sum[100000];\nsigned main(){\n    cin>>N>>H;\n    rep(i,N-1)cin>>d[i]>>h[i];\n\n    sum[0]=H;\n    rep(i,N-1)sum[i+1]=sum[i]-d[i];\n    int D=0;\n\n    int ans=0,idx=0;\n    deque<int>deq;\n    rep(i,N-1){\n\n        if(H-(sum[i]-D)<=h[i]){\n            deq.clear();\n            idx=i;\n        }\n        else{\n            while(deq.size()&&h[deq.back()]<=h[i])deq.pop_back();\n            deq.push_back(i);\n        }\n\n        while(sum[i+1]-D<=0){\n            if(deq.size()&&H-(sum[idx]-D)<=h[deq.front()]){\n                int j=deq.front();\n                int t=min((H-(sum[j]-D))/h[j],(D-sum[i+1])/h[j]+1);\n                ans+=t;\n                D-=t*h[j];\n            }\n            else{\n                ans++;\n                D-=H-(sum[idx]-D);\n            }\n            while(deq.size()&&H-(sum[deq.front()]-D)<h[deq.front()]){\n                    idx=deq.front();\n                    deq.pop_front();\n            }\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint main(){\n  int i;\n  int n,m,o,p,q;\n  cin>>n>>m;\n  int a[100000],b[100000];\n  for(i=0;i<n-1;i++)\n    cin>>a[i]>>b[i];\n  o=m;\n  q=0;\n  long long ct=0;\n  for(;;){\n    p=o;\n    pair<int,int> mx=make_pair(p,q);\n    for(i=q;i<n-1;i++){\n      if(min(m-mx.first,b[mx.second])<min(m-p,b[i])){\n\tmx.first=p;\n\tmx.second=i;\n      }\n      if(a[i]>=p)\n\tbreak;\n      p-=a[i];\n    }\n    if(i==n-1)\n      break;\n    else{\n      o=min(mx.first+b[mx.second],m);\n      q=mx.second;\n      ct++;\n    }\n  }\n  cout<<ct<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)x.size())\n\nusing namespace std;\n\nstruct timer{\n\ttime_t start;\n\ttimer(){start=clock();}\n\t~timer(){cerr<<1.*(clock()-start)/CLOCKS_PER_SEC<<\" secs\"<<endl;}\n};\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\nint N,H,d[100010],h[100010],sumd[100010];\n\nstruct segtree{\n\tll x;\n\tint l,r;\n\tsegtree *cl,*cr;\n\t\n\tsegtree(int l,int r): l(l),r(r){\n\t\tif(l+1==r){\n\t\t\tx=h[l];\n\t\t\treturn;\n\t\t}\n\t\tcl=new segtree(l,l+r>>1);\n\t\tcr=new segtree(l+r>>1,r);\n\t\tx=max(cl->x,cr->x);\n\t}\n\t\n\tvoid change(int pos,ll v){\n\t\tif(pos<l || r<=pos){\n\t\t\treturn;\n\t\t}\n\t\tif(l+1==r){\n\t\t\tx=v;\n\t\t\treturn;\n\t\t}\n\t\tcl->change(pos,v);\n\t\tcr->change(pos,v);\n\t\tx=max(cl->x,cr->x);\n\t}\n\t\n\tll query(int L,int R,int& ind){\n\t\tif(R<=l || r<=L){\n\t\t\treturn -INF*INF;\n\t\t}\n\t\tif(l+1==r){\n\t\t\tind=l;\n\t\t\treturn x;\n\t\t}\n\t\tint ind1,ind2;\n\t\tll res1 = cl->query(L,R,ind1);\n\t\tll res2 = cr->query(L,R,ind2);\n\t\tif(res1 >= res2){\n\t\t\tind=ind1;\n\t\t\treturn res1;\n\t\t}\n\t\tind=ind2;\n\t\treturn res2;\n\t}\n} *root;\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\tcin>>N>>H;\n\trep(i,N-1){\n\t\tcin>>d[i]>>h[i];\n\t\tsumd[i+1]=sumd[i]+d[i];\n\t}\n\troot=new segtree(0,N-1);\n\tll ans=0,hp=H,from=0;\n\trep(i,N-1){\n\t\thp-=d[i];\n\t\t//cout<<hp<<\" \"<<ans<<\" \"<<from<<endl;\n\t\twhile(hp<=0){\n\t\t\tll need=1-hp;\n\t\t\tint ind;\n\t\t\tll maxi=root->query(from,i+1,ind);\n\t\t\tfrom=ind;\n\t\t\tll HPpre=hp+sumd[i+1]-sumd[ind];\n\t\t\t//cout<<hp<<\" \"<<HPpre<<endl;\n\t\t\t//cout<<from<<\" - \"<<i<<\" : \"<<maxi<<\"(\"<<ind<<\")\"<<endl;\n\t\t\tll maxtime=(H-HPpre)/maxi;\n\t\t\tll want=(need+maxi-1)/maxi;\n\t\t\t//cout<<maxtime<<\" \"<<want<<endl;\n\t\t\tif(want <= maxtime){\n\t\t\t\tans+=want;\n\t\t\t\thp+=want*maxi;\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\tll rest=(H-HPpre)%maxi;\n\t\t\t\tif(rest==0)from++;\n\t\t\t\telse root->change(ind,rest);\n\t\t\t\tans+=maxtime;\n\t\t\t\thp+=maxtime*maxi;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<map>\n#include<algorithm>\nusing namespace std;\nlong long n,h,d,p,y,x,z;\ndeque<pair<long long,long long> > w;\nint main(){\n  scanf(\"%lld%lld\",&n,&p);\n  y=p;\n  for(;--n;){\n    scanf(\"%lld%lld\", &d, &h);\n    while(!w.empty() && w.back().first < h){\n      w.pop_back();\n    }\n    w.push_back(make_pair(h, x));\n    x += d;\n    while(p <= x){\n      long long int tmpp = p ;\n      while(!w.empty() && tmpp + w.front().first - w.front().second > y){\n\tp = max(p, w.front().second + y);\n\tw.pop_front();\n      }\n      if(!w.empty()){\n\tp = max(p, tmpp + w.front().first);\n\tint tmp = max(0ll, min((x - p) / w.front().first, (w.front().second + y - p) / w.front().first));\n\tz += tmp;\n\tp += tmp * w.front().first;\n      }\n      z++;\n    }\n  }\n  printf(\"%lld\\n\", z);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<string>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,P> P1;\n\n#define rep(i,x) for(ll i = 0 ; i < x ; i ++)\n#define rep1(i,x) for(ll i = 1 ; i <= x ; i ++)\n#define rrep(i,x) for(ll i = x-1 ; i >= 0 ; i --)\n#define rrep1(i,x) for(ll i = x ; i > 0 ; i --)\n#define sor(vec) sort(vec.begin(),vec.end())\n#define rev(vec) reverse(vec.begin(),vec.end())\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(min(a,b),c)\n#define max_3(a,b,c) max(max(a,b),c)\n#define mp1(a,b,c) P1(a,P(b,c))\n#define fr first\n#define sc second\n#define pb push_back\n\nconst ll INF = 1000000000;\nconst ll dir_4[4][2] = { {1,0} , {0,1} , {-1,0} , {0,-1} };\n\nll siz;\nll seg[2][400010];\n\nvoid init(ll n){\n\tsiz = 1;\n\twhile(siz < n)siz *= 2;\n\trep(i,siz*2-1){\n\t\tseg[0][i] = -INF;\n\t\tseg[1][i] = 0;\n\t}\n}\n\nll query(ll k){\n\tll sum = 0;\n\tk += siz-1;\n\tll ret = seg[0][k];\n\twhile(k > 0){\n\t\tk = (k-1)/2;\n\t\tret = max ( ret + seg[1][k] , seg[0][k] );\n\t}\n\treturn ret;\n}\n\nvoid maxi(ll a,ll b,ll x,ll k,ll l,ll r){\n\tif(b <= l || r <= a)return;\n\tif(a <= l && r <= b){\n\t\tseg[0][k] = max ( seg[0][k] , x );\n\t\treturn;\n\t}\n\tmaxi(a,b,x-seg[1][k],2*k+1,l,(l+r)/2);\n\tmaxi(a,b,x-seg[1][k],2*k+2,(l+r)/2,r);\n}\n\nvoid add(ll a,ll b,ll x,ll k,ll l,ll r){\n\tif(b <= l || r <= a)return;\n\tif(a <= l && r <= b){\n\t\tseg[0][k] += x;\n\t\tseg[1][k] += x;\n\t\treturn;\n\t}\n\tadd(a,b,x,2*k+1,l,(l+r)/2);\n\tadd(a,b,x,2*k+2,(l+r)/2,r);\n}\n\nvoid updata(ll k,ll x){\n\tadd(k,k+1,x-query(k),0,0,siz);\n}\n\nint main(){\n\tll n,h;\n\tstatic ll c[100010],d[100010];\n\t\n\tscanf(\"%lld%lld\",&n,&h);\n\trep1(i,n-1){\n\t\tscanf(\"%lld%lld\",&c[i],&d[i]);\n\t}\n\t\n\tinit(n+10);\n\tupdata(0,h);\n\tc[0] = 0;\n\t\n\tpriority_queue<P> que;\n\tll ret = 0;\n\t\n\trep1(i,n-1){\n\t\tupdata(i,query(i-1)-c[i-1]);\n\t\tque.push( P ( d[i] , i ) );\n\t\tll t = c[i] - query(i) + 1;\n\t\twhile(t > 0){\n\t\t\tP p = que.top(); que.pop();\n\t\t\tll s1 = (t+p.fr-1)/p.fr;\n\t\t\tll s2 = (h-query(p.sc))/p.fr;\n\t\t\tif(s1 < s2){\n\t\t\t\tmaxi(0,p.sc,query(p.sc)+p.fr*s1,0,0,siz);\n\t\t\t\tadd(p.sc,siz,p.fr*s1,0,0,siz);\n\t\t\t\tt -= p.fr*s1;\n\t\t\t\tret += s1;\n\t\t\t\tque.push(p);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmaxi(0,p.sc,query(p.sc)+p.fr*s2,0,0,siz);\n\t\t\t\tadd(p.sc,siz,p.fr*s2,0,0,siz);\n\t\t\t\tt -= p.fr*s2;\n\t\t\t\tret += s2;\n\t\t\t\tque.push( P ( h-query(p.sc) , p.sc ) );\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\",ret);\n\t\t\t\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)x.size())\n\nusing namespace std;\n\nstruct timer{\n\ttime_t start;\n\ttimer(){start=clock();}\n\t~timer(){cerr<<1.*(clock()-start)/CLOCKS_PER_SEC<<\" secs\"<<endl;}\n};\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\nll N,H,d[100010],h[100010],sumd[100010];\n\nstruct segtree{\n\tll x;\n\tint l,r;\n\tsegtree *cl,*cr;\n\t\n\tsegtree(int l,int r): l(l),r(r){\n\t\tif(l+1==r){\n\t\t\tx=h[l];\n\t\t\treturn;\n\t\t}\n\t\tcl=new segtree(l,l+r>>1);\n\t\tcr=new segtree(l+r>>1,r);\n\t\tx=max(cl->x,cr->x);\n\t}\n\t\n\tvoid change(int pos,ll v){\n\t\tif(pos<l || r<=pos){\n\t\t\treturn;\n\t\t}\n\t\tif(l+1==r){\n\t\t\tx=v;\n\t\t\treturn;\n\t\t}\n\t\tcl->change(pos,v);\n\t\tcr->change(pos,v);\n\t\tx=max(cl->x,cr->x);\n\t}\n\t\n\tll query(int L,int R,int& ind){\n\t\tif(R<=l || r<=L){\n\t\t\treturn -INF*INF;\n\t\t}\n\t\tif(l+1==r){\n\t\t\tind=l;\n\t\t\treturn x;\n\t\t}\n\t\tint ind1,ind2;\n\t\tll res1 = cl->query(L,R,ind1);\n\t\tll res2 = cr->query(L,R,ind2);\n\t\tif(res1 >= res2){\n\t\t\tind=ind1;\n\t\t\treturn res1;\n\t\t}\n\t\tind=ind2;\n\t\treturn res2;\n\t}\n} *root;\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\tcin>>N>>H;\n\trep(i,N-1){\n\t\tcin>>d[i]>>h[i];\n\t\tsumd[i+1]=sumd[i]+d[i];\n\t}\n\troot=new segtree(0,N-1);\n\tll ans=0,hp=H,from=0;\n\trep(i,N-1){\n\t\thp-=d[i];\n\t\t//cout<<hp<<\" \"<<ans<<\" \"<<from<<endl;\n\t\twhile(hp<=0){\n\t\t\tll need=1-hp;\n\t\t\tint ind;\n\t\t\tll maxi=root->query(from,i+1,ind);\n\t\t\tfrom=ind;\n\t\t\tll HPpre=hp+sumd[i+1]-sumd[ind];\n\t\t\t//cout<<hp<<\" \"<<HPpre<<endl;\n\t\t\t//cout<<from<<\" - \"<<i<<\" : \"<<maxi<<\"(\"<<ind<<\")\"<<endl;\n\t\t\tll maxtime=(H-HPpre)/maxi;\n\t\t\tll want=(need+maxi-1)/maxi;\n\t\t\t//cout<<maxtime<<\" \"<<want<<endl;\n\t\t\tif(want <= maxtime){\n\t\t\t\tans+=want;\n\t\t\t\thp=min(H,hp+want*maxi);\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\tll rest=(H-HPpre)%maxi;\n\t\t\t\troot->change(ind,rest);\n\t\t\t\tans+=maxtime;\n\t\t\t\thp+=maxtime*maxi;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\ntemplate<typename T>\nclass LazyPropagationSegmentTree {\npublic:\n  LazyPropagationSegmentTree(int n) : size_(1) {\n    while(size_ < n) size_ <<= 1;\n    node_.assign(size_ << 1, 0);\n    lazy_.assign(size_ << 1, 0);\n  }\n  T find(int left, int right) {return find(left, right + 1, 1, 0, size_);}\n  void add(int left, int right, T value) {add(left, right + 1, value, 1, 0, size_);}\nprivate:\n  int left_child(int node) const {return node << 1;}\n  int right_child(int node) const {return (node << 1) + 1;}\n  T find(int a, int b, int k, int l, int r) {\n    if(b <= l || r <= a) return 0;\n    if(a <= l && r <= b) return node_.at(k) + (r - l) * lazy_.at(k);\n    lazy_.at(left_child(k)) += lazy_.at(k);\n    lazy_.at(right_child(k)) += lazy_.at(k);\n    lazy_.at(k) = 0;\n    auto vl = find(a, b, left_child(k), l, (l + r) / 2);\n    auto vr = find(a, b, right_child(k), (l + r) / 2, r);\n    return vl + vr;\n  }\n  T add(int a, int b, T value, int k, int l, int r) {\n    if(b <= l || r <= a) return node_.at(k) + (r - l) * lazy_.at(k);\n    if(a <= l && r <= b) return node_.at(k) + (r - l) * (lazy_.at(k) += value);\n    lazy_.at(left_child(k)) += lazy_.at(k);\n    lazy_.at(right_child(k)) += lazy_.at(k);\n    lazy_.at(k) = 0;\n    auto vl = add(a, b, value, left_child(k), l, (l + r) / 2);\n    auto vr = add(a, b, value, right_child(k), (l + r) / 2, r);\n    return node_.at(k) = vl + vr;\n  }\n  int size_;\n  std::vector<T> node_;\n  std::vector<T> lazy_;\n};\n\n#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Node {int f; long long h;};\nbool operator<(const Node& lhs, const Node& rhs) {\n  if(lhs.h != rhs.h) return lhs.h < rhs.h;\n  return lhs.f < rhs.f;\n}\n\nint main() {\n  int N, H;\n  cin >> N >> H;\n\n  LazyPropagationSegmentTree<long long> hp(N + 1);\n  hp.add(0, N, H);\n\n  long long answer = 0;\n  int last = 0;\n  priority_queue<Node> q;\n\n  for(int i = 1; i < N; ++i) {\n    long long d, h;\n    cin >> d >> h;\n\n    q.push({i, h});\n    hp.add(i, N, -d);\n\n    while(hp.find(i, i) <= 0) {\n      auto node = q.top();\n\n      if(node.f < last) {\n        q.pop();\n        continue;\n      }\n\n      if(node.h + hp.find(node.f-1, node.f-1) <= H) {\n        last = node.f;\n        ++answer;\n        hp.add(node.f-1, N, node.h);\n        continue;\n      }\n\n      q.pop();\n      q.push({node.f, H - hp.find(node.f-1, node.f-1)});\n    }\n  }\n\n  cout << answer <<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll d[100000];\nll h[100000];\nll s[100000];\nint main(){\n\tll N,H,l;\tcin>>N>>H;\n\tl=H;\n\tfor(int i=0;i<N-1;i++){\n\t\tcin>>d[i]>>h[i];\n\t\ts[i+1]=s[i]+d[i];\n\t}\n\tll ans=0;\n\tdeque<int> dq;\n\tfor(int i=0;i<N-1;i++){\n\t\twhile(dq.size()&&h[dq.back()]<=h[i])\tdq.pop_back();\n\t\tdq.push_back(i);\n\t\twhile(dq.size()&&s[i]-s[dq.front()]>H)\tdq.pop_front();\n\t\tif(l<=d[i]){\n\t\t\tfor(int j=0;j<(int)dq.size();j++){\n\t\t\t\tll heal=max(0LL,H-(s[i]-s[dq[j]]-l));\n\t\t\t\tll req=d[i]-l+1;\n\t\t\t\tll use=min(heal,req)/h[dq[j]];\n\t\t\t\tl+=use*h[dq[j]];\n\t\t\t\tans+=use;\n\t\t\t\tif(l>d[i])\tbreak;\n\t\t\t\tif(j+1>=(int)dq.size()||H-(s[i]-s[dq[j]])-l>=h[dq[j+1]]){\n\t\t\t\t\tans++;\n\t\t\t\t\tl=min(l+h[dq[j]],H-(s[i]-s[dq[j]]));\n\t\t\t\t}\n\t\t\t\tif(l>d[i])\tbreak;\n\t\t\t}\n\t\t}\n\t\tl-=d[i];\n\t\tif(l<=0){\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef pair<int,int>P;\nconst int SIZE=1<<17;\n\nstruct seg_tree{\n    vector<int>ma,lazy;\n\n    seg_tree():ma(SIZE*2-1,0),lazy(SIZE*2-1,0){}\n\n    void evaluate(int k){\n        ma[k]+=lazy[k];\n        if(k<SIZE-1){\n            lazy[k*2+1]+=lazy[k];\n            lazy[k*2+2]+=lazy[k];\n        }\n        lazy[k]=0;\n    }\n    void update_node(int k){\n        ma[k]=max(ma[k*2+1],ma[k*2+2]);\n    }\n\n    void add(int a,int b,int x,int k=0,int l=0,int r=SIZE){\n        evaluate(k);\n        if(r<=a||b<=l)return;\n        if(a<=l&&r<=b){\n            lazy[k]+=x;\n            evaluate(k);\n            return;\n        }\n        int m=(l+r)/2;\n        add(a,b,x,k*2+1,l,m);\n        add(a,b,x,k*2+2,m,r);\n        update_node(k);\n    }\n\n    int get_max(int a,int b,int k=0,int l=0,int r=SIZE){\n        evaluate(k);\n        if(r<=a||b<=l)return 0;\n        if(a<=l&&r<=b)return ma[k];\n        int m=(l+r)/2;\n        int vl=get_max(a,b,k*2+1,l,m);\n        int vr=get_max(a,b,k*2+2,m,r);\n        return max(vl,vr);\n    }\n};\n\nint N,H;\nint d[100000],h[100000];\n\nsigned main(){\n    cin>>N>>H;\n    for(int i=0;i<N-1;i++)cin>>d[i]>>h[i];\n\n    seg_tree seg;\n    int cur=H;\n    int ans=0;\n    priority_queue<P>que;\n    for(int i=0;i<N-1;i++){\n        seg.add(i,i+1,cur);\n        cur-=d[i];\n\n        que.push(P(h[i],i));\n\n        while(cur<=0){\n            P p=que.top();que.pop();\n            int ma=seg.get_max(p.second,i+1);\n            if(p.first+ma>H){\n                que.push(P(H-ma,p.second));\n                continue;\n            }\n\n            int x=min((-cur)/p.first+1,(H-ma)/p.first);\n            ans+=x;\n            cur+=x*p.first;\n            seg.add(p.second,i+1,p.first*x);\n        }\n    }\n\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "const long long INF = 1ll << 50;\n\n#include<vector>\ntemplate<typename T>\nclass LazyPropagationSegmentTree {\npublic:\n  LazyPropagationSegmentTree(int n) : size_(1) {\n    while(size_ < n) size_ <<= 1;\n    node_.assign(size_ << 1, INF);\n    lazy_.assign(size_ << 1, 0);\n  }\n  T find(int left, int right) {return find(left, right + 1, 1, 0, size_);}\n  void add(int left, int right, T value) {add(left, right + 1, value, 1, 0, size_);}\n  void set(int i, T value) {set(i, i + 1, value, 1, 0, size_);}\nprivate:\n  int left_child(int node) const {return node << 1;}\n  int right_child(int node) const {return (node << 1) + 1;}\n  T find(int a, int b, int k, int l, int r) {\n    if(b <= l || r <= a) return INF;\n    if(a <= l && r <= b) return node_.at(k) + lazy_.at(k);\n    lazy_.at(left_child(k)) += lazy_.at(k);\n    lazy_.at(right_child(k)) += lazy_.at(k);\n    lazy_.at(k) = 0;\n    auto vl = find(a, b, left_child(k), l, (l + r) / 2);\n    auto vr = find(a, b, right_child(k), (l + r) / 2, r);\n    return std::min(vl, vr);\n  }\n  T add(int a, int b, T value, int k, int l, int r) {\n    if(b <= l || r <= a) return node_.at(k) + lazy_.at(k);\n    if(a <= l && r <= b) return node_.at(k) + (lazy_.at(k) += value);\n    lazy_.at(left_child(k)) += lazy_.at(k);\n    lazy_.at(right_child(k)) += lazy_.at(k);\n    lazy_.at(k) = 0;\n    auto vl = add(a, b, value, left_child(k), l, (l + r) / 2);\n    auto vr = add(a, b, value, right_child(k), (l + r) / 2, r);\n    return node_.at(k) = std::min(vl, vr);\n  }\n  T set(int a, int b, T value, int k, int l, int r) {\n    if(b <= l || r <= a) return node_.at(k) + lazy_.at(k);\n    if(a <= l && r <= b) {\n      lazy_.at(k) = 0;\n      return node_.at(k) = value;\n    }\n    lazy_.at(left_child(k)) += lazy_.at(k);\n    lazy_.at(right_child(k)) += lazy_.at(k);\n    lazy_.at(k) = 0;\n    auto vl = set(a, b, value, left_child(k), l, (l + r) / 2);\n    auto vr = set(a, b, value, right_child(k), (l + r) / 2, r);\n    return node_.at(k) = std::min(vl, vr);\n  }\n  int size_;\n  std::vector<T> node_;\n  std::vector<T> lazy_;\n};\n\n#include<iostream>\nusing namespace std;\nint main() {\n  int N, H;\n  cin >> N >> H;\n  LazyPropagationSegmentTree<long long> RMQ(H + 1);\n  RMQ.set(H, 0);\n  for(int i = 0; i < N; ++i) {\n    int d, h;\n    cin >> d >> h;\n    RMQ.add(d, H, 1);\n  }\n  cout << RMQ.find(1, H) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<map>\n#define INF 20000000\nusing namespace std;\ntypedef pair<int,int> P;\nint d[100000];\nint p[100000];\nP deq[200000];\nint max(int a,int b){return a>b?a:b;}\nint min(int a,int b){return a<b?a:b;}\nint ceil(int a,int b){\n\tif(a%b==0)return a/b;\n\telse return a/b+1;\n}\nint main(){\n\tint n,mh;\n\tint i;\n\tscanf(\"%d %d\",&n,&mh);\n\tfor(i=0;i<n-1;i++)scanf(\"%d %d\",&d[i],&p[i]);\n\tlong long ans=0;\n\tint l=0,r=0;\n\tint s=0,t=0;\n\tint lim=0;\n\tint h=mh;\n\twhile(r<n-1){\n\t\twhile(s<t&&deq[t-1].first<=p[r])t--;\n\t\tdeq[t++]=P(p[r],r);\n\t\twhile(h<=d[r]){\n\t\t\twhile(min(lim,p[l])<deq[s].first){\n\t\t\t\tlim+=d[l++];\n\t\t\t\twhile(s<t&&deq[s].second<=l)s++;\n\t\t\t}\n\t\t\tint rec=d[r]-h+1;\n\t\t\tint a=ceil(rec,p[l]);\n\t\t\tint b=lim/p[l];\n\t\t\tint c=min(a,b);\n\t\t\tif(c==0)c++;\n\t\t\tans+=c;\n\t\t\tint add=c*p[l];\n\t\t\tif(add>lim)add=lim;\n\t\t\tlim-=add;\n\t\t\th+=add;\n\t\t}\n\t\th-=d[r];\n\t\tr++;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Bokan ga bokka--nn!!\n//Daily Lunch Special Tanoshii !!\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\n#include <deque>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\ntypedef long long ll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\n#define s(x) scanf(\"%d\",&x)\n#define rep(i,x) for(int i=0;i<x;i++)\nint main()\n{\n\tint n;\n\tll maxv;\n\tscanf(\"%d %lld\",&n,&maxv);\n\tll totv=maxv;\n\tll totd=0LL;\n\tdeque<pair<ll,ll> >deq;\n\tll ret=0LL;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tll a,b;\n\t\tscanf(\"%lld %lld\",&a,&b);\n\t\twhile(!deq.empty() && deq.back().first<=b) deq.pop_back();\n\t\tdeq.pb(mp(b,totd));\n\t\ttotd+=a;\n\t\tif(totv<totd)\n\t\t{\n\t\t\twhile(totv+totd+deq.front().first-deq.front().second>maxv) deq.pop_front();\n\t\t\tll kai=deq.front().first;\n\t\t\tll prev=deq.front().second;\n\t\t\tret+=(maxv-(totv+totd-prev))/kai;\n\t\t\ttotv+=((maxv-(totv+totd-prev))/kai)*kai;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll d[100000];\nll h[100000];\nll s[100000];\nint main(){\n\tll N,H,l;\tcin>>N>>H;\n\tl=H;\n\tfor(int i=0;i<N-1;i++){\n\t\tcin>>d[i]>>h[i];\n\t\ts[i+1]=s[i]+d[i];\n\t}\n\tll ans=0;\n\tdeque<int> dq;\n\tfor(int i=0;i<N;i++){\n\t\twhile((!dq.empty())&&h[dq.back()]<=h[i])\tdq.pop_back();\n\t\tdq.push_back(i);\n\t\twhile((!dq.empty())&&s[i]-s[dq.front()]>l)\tdq.pop_front();\n\t\tif(l<=d[i]){\n\t\t\tfor(int j=0;j<(int)dq.size();j++){\n\t\t\t\tll heal=max(0LL,H-(s[i]-s[dq[j]]-l));\n\t\t\t\tll req=d[i]-l+1;\n\t\t\t\tll use=min(heal,req)/h[dq[j]];\n\t\t\t\tl+=use*h[dq[j]];\n\t\t\t\tans+=use;\n\t\t\t\tif(l>d[i])\tbreak;\n\t\t\t\tif(j+1>=(int)dq.size()||H-(s[i]-s[dq[j]])-l>=h[dq[j+1]]){\n\t\t\t\t\tans++;\n\t\t\t\t\tl=min(l+h[dq[j]],H-(s[i]-s[dq[j]]));\n\t\t\t\t}\n\t\t\t\tif(l>d[i])\tbreak;\n\t\t\t}\n\t\t}\n\t\tl-=d[i];\n\t\tif(l<=0){\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef pair<int,int>P;\nconst int SIZE=1<<17;\n\nstruct seg_tree{\n    vector<int>ma,lazy;\n\n    seg_tree():ma(SIZE*2-1,0),lazy(SIZE*2-1,0){}\n\n    void evaluate(int k){\n        ma[k]+=lazy[k];\n        if(k<SIZE-1){\n            lazy[k*2+1]+=lazy[k];\n            lazy[k*2+2]+=lazy[k];\n        }\n        lazy[k]=0;\n    }\n    void update_node(int k){\n        ma[k]=max(ma[k*2+1],ma[k*2+2]);\n    }\n\n    void add(int a,int b,int x,int k=0,int l=0,int r=SIZE){\n        evaluate(k);\n        if(r<=a||b<=l)return;\n        if(a<=l&&r<=b){\n            lazy[k]+=x;\n            evaluate(k);\n            return;\n        }\n        int m=(l+r)/2;\n        add(a,b,x,k*2+1,l,m);\n        add(a,b,x,k*2+2,m,r);\n        update_node(k);\n    }\n\n    int get_max(int a,int b,int k=0,int l=0,int r=SIZE){\n        evaluate(k);\n        if(r<=a||b<=l)return 0;\n        if(a<=l&&r<=b)return ma[k];\n        int m=(l+r)/2;\n        int vl=get_max(a,b,k*2+1,l,m);\n        int vr=get_max(a,b,k*2+2,m,r);\n        return max(vl,vr);\n    }\n};\n\nint N,H;\nint d[100000],h[100000];\n\nsigned main(){\n\n    cin>>N>>H;\n    for(int i=0;i<N-1;i++)cin>>d[i]>>h[i];\n\n    seg_tree seg;\n    int cur=H;\n    int ans=0;\n    priority_queue<P>que;\n    for(int i=0;i<N-1;i++){\n        seg.add(i,i+1,cur);\n        cur-=d[i];\n\n        que.push(P(h[i],i));\n\n        while(cur<=0){\n            P p=que.top();que.pop();\n            int ma=seg.get_max(p.second,i+1);\n            if(p.first+ma>H){\n                que.push(P(H-ma,p.second));\n                continue;\n            }\n            int val=min(p.first,H-ma);\n            int x=min(abs(cur)/val+1,(H-ma)/val);\n            ans+=x;\n            cur+=x*val;\n            seg.add(p.second,i+1,val*x);\n        }\n    }\n\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint dp[100000],hp[100000];\nlong long int ans=-1;\nvoid heal(long long int count,int N,int H,int now,int now_hp){\n  if(now==1) heal(count,N,H,now+1,now_hp-dp[now]);\n  else if(now==N){\n    if(ans<0||count<ans) ans = count;\n  }else{\n    if(now_hp-dp[now]>0) heal(count,N,H,now+1,now_hp-dp[now]);\n      int cou=0;\n      while(now_hp<H){\n\tcou++;\n\tnow_hp += hp[now];\n\tif(now_hp>H) now_hp = H;\n\tif(now_hp-dp[now]>0) heal(count+cou,N,H,now+1,now_hp-dp[now]);\n      }\n    }\n  }\nint main(){\n  int N,H;\n  cin >> N >> H;\n  for(int i=1;i<N;i++) cin >> dp[i] >> hp[i];\n  heal(0,N,H,1,H);\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n   \nusing namespace std;\n   \n\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void uniq(vector<T>& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n\ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n  \ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n  \ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n   \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n\nbool valid(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n  \nconst double PI = acos(-1.0);\nconst int mod = 1000000007;\n\n\n\nint main()\n{\n    int n;\n    ll max_h;\n    ll d[ten(5) + 100], h[ten(5) + 100];\n    scanf(\"%d%lld\", &n, &max_h);\n    rep(i, n - 1)\n        scanf(\"%lld%lld\", d + i, h + i);\n\n    ll sum_d[ten(5) + 100];\n    sum_d[0] = 0;\n    rep(i, n - 1)\n        sum_d[i + 1] = sum_d[i] + d[i];\n\n    ll res = 0, hp = max_h;\n    deque<int> q;\n    rep(i, n - 1)\n    {\n        while (!q.empty() && sum_d[i] - sum_d[q.front()] >= max_h)\n            q.pop_front();\n        while (!q.empty() && h[q.back()] <= h[i])\n            q.pop_back();\n        q.push_back(i);\n\n        while (hp <= d[i])\n        {\n            int k = q.front();\n#define heal_upper() (max_h - (hp + (sum_d[i] - sum_d[k])))\n\n            ll full_heal_use_upper = max(0LL, heal_upper() / h[k]);\n            ll need_hp = d[i] - hp + 1;\n            ll use = min(full_heal_use_upper, (need_hp + h[k] - 1) / h[k]);\n            res += use;\n            hp += use * h[k];\n\n            if (hp <= d[i])\n            {\n                ll hh = heal_upper();\n                if (q.size() >= 2 && h[q[1]] >= hh)\n                    q.pop_front();\n                else\n                {\n                    ++res;\n                    hp += hh;\n                }\n            }\n        }\n\n        hp -= d[i];\n    }\n\n    printf(\"%lld\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main(){\n  int N,H;\n  cin >> N >> H;\n  unsigned long long int ans=0;\n  int dp[H],di,hi,in=0,in2=0;\n  dp[0] = H;\n  for(int i=1;i<N;i++){\n    cin >> di >> hi;\n    for(int i=in2+1;i<H;i++) dp[i] = -1;\n    while(dp[in]!=H){\n      dp[in+1] = max(min(dp[in]+hi,H),dp[in+1]);\n      in++;\n    }\n    in2 = 0;\n    for(int i=0;i<=in;i++){\n      if(dp[i]-di<=0) continue;\n      else if(i!=0&&dp[i-1]-di<=0) ans += i;\n      dp[in2] = dp[i]-di;\n      in2++;\n    }\n    in = in2-1;\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef pair<ll,ll> P;\n\n#define rep(i,n) for(ll (i)=0;(i)<(n);++i)\n\n#define rep1(i,n) for(ll (i)=1;(i)<=(n);++i)\n\n#define rrep(i,n) for(ll (i)=(n)-1;(i)>=(0);--i)\n\n#define rrep1(i,n) for(ll (i)=(n);(i)>=(1);--i)\n\n#define pb push_back\n\n#define fr first\n\n#define sc second\n\nconst ll INF=0xfffffffffffff;\nconst ll inf=0xfffffff;\nconst ll SIZE=1<<17;\npriority_queue<P> q;\nll N,HP;\nll D[100000],H[100000];\nll hp[SIZE];\n\nll ans=0;\nll l=0;\nll pos;\nll data[SIZE*2-1],datb[SIZE*2-1];\nll init(ll k){\n\tdatb[k]=0;\n\tif(k>=SIZE-1) return data[k]=hp[k-SIZE+1];\n\treturn data[k]=max(init(k*2+1),init(k*2+2));\n}\n\nll update(ll a,ll b,ll val,ll k,ll l,ll r){\n\tif(a>b) swap(a,b);\n\tif(b<=l||r<=a) return data[k]+datb[k];\n\tif(a<=l&&r<=b){\n\t\tdatb[k]+=val;\n\t\treturn data[k]+datb[k];\n\t}\n\telse{\n\t\tdata[k]=max(update(a,b,val,k*2+1,l,(l+r)/2),update(a,b,val,k*2+2,(l+r)/2,r));\n\t\treturn data[k]+datb[k];\n\t}\n}\n\nll query(ll a,ll b,ll k,ll l,ll r){\n\tif(r<=a||b<=l) return -INF;\n\tif(a<=l&&r<=b) return data[k]+datb[k];\n\telse return max(query(a,b,k*2+1,l,(l+r)/2),query(a,b,k*2+2,(l+r)/2,r))+datb[k];\n}\n\n\nint main()\n\n{\n\tll ans=0;\n\n\tcin>>N>>HP;\n\thp[0]=HP;\n\trep(i,N-1){\n\t\tcin>>D[i]>>H[i];\n\t\thp[i+1]=hp[i]-D[i];\n\t}\n\tinit(0);\n\tpos=HP;\n\tll want;\n\tll z,zan;\n\trep(i,N-1){\n\t\tq.push(P(H[i],i));\n\t\twhile(pos-D[i]<1){\n\t\t\twant=D[i]-pos+1;\n\t\t\tP p=q.top();\n\t\t\tq.pop();\n\t\t\tzan = HP - query(p.sc,i+1,0,0,SIZE);\n\t\t\tif(zan<p.fr){\n\t\t\t\tq.push(P(zan,p.sc));\n\t\t\t}\n\t\t\telse if( (zan/p.fr)*p.fr<=want ){\n\t\t\t\tz=zan/p.fr;\n\t\t\t\tans+=z;\n\t\t\t\tpos+=z*p.fr;\n\t\t\t\tupdate(p.sc,N,z*p.fr,0,0,SIZE);\n\t\t\t\tif(zan%p.fr!=0){\n\t\t\t\t\tq.push(P(zan%p.fr,p.sc));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tz=(want-1)/p.fr+1;\n\t\t\t\tans+=z;\n\t\t\t\tpos+=z*p.fr;\n\t\t\t\tupdate(p.sc,N,z*p.fr,0,0,SIZE);\n\t\t\t\tq.push(p);\n\t\t\t}\n\t\t}\n\t\tpos-=D[i];\n\t}\n\tcout<<ans<<endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\ntypedef pair< int, int > Pi;\n\nconst int INF = 1 << 30;\n// 区間への加算, 最大値が求まればいいかんじに出来る\n\nstruct node{\n  int64 value;\n  int64 adding;\n};\n\nnode seg[1 << 18];\n\ninline void updatenode(int k){ // 遅延評価的な何か\n  if(k >= 1 >> 17) return;\n  seg[k * 2 + 1].adding += seg[k].adding;\n  seg[k * 2 + 1].adding += seg[k].adding;\n  seg[k].value += seg[k].adding;\n  seg[k].adding = 0;\n}\n\n\ninline void add( int a, int b, int64 value, int k = 0, int l = 0, int r = 1 << 17){ // [a,b)にvalueを足すやつ\n  if(r <= a || b <= l) return;\n  if(a <= l && r <= b) { // 完全に含んでたら足す\n    seg[k].adding += value;\n    updatenode(k);\n  } else {\n    int mid = (l + r) >> 1;\n    add( a, b, value, 2 * k + 1, l, mid);\n    add( a, b, value, 2 * k + 2, mid, r);\n    seg[k].value = max( seg[2 * k + 1].value + seg[2 * k + 1].adding, seg[2 * k + 2].value + seg[2 * k + 2].adding);\n  }\n  return;\n}\n\ninline int64 query( int a, int b, int k = 0, int l = 0, int r = 1 << 17){ // [a,b)の最大値を返すやつ\n  if(r <= a || b <= l) return -INF;\n  if(a <= l && r <= b){\n    int64 ans = seg[k].value + seg[k].adding;\n    updatenode(k);\n    return ans;\n  }\n  int mid = (l + r) >> 1;\n  updatenode(k);\n  return max( query( a, b, 2 * k + 1, l, mid), query( a, b, 2 * k + 2, mid, r));\n}\n\n\n int main()\n {\n   int N, H;\n   int64 life = 0; // 今の体力\n   int64 ret = 0;\n   for(int i = 0; i < 1 << 18; i++){\n     seg[i].value = seg[i].adding = 0;\n   }\n\n   scanf(\"%d %d\", &N, &H);\n   life = H;\n   priority_queue< Pi > que; // first: 一回あたりの回復体力量, second: どこ\n   for(int i = 0; i < N - 1; i++){\n     add( i, i + 1, life); // 今の体力を更新\n     int d, h;\n     scanf(\"%d %d\", &d, &h);\n     que.push( Pi( h, i));\n\n     life -= d; // 降りる\n     while(life <= 0){\n       Pi p = que.top(); que.pop();\n       int64 lange = query( p.second, i + 1); // 回復量の最大値\n       if(p.first + lange > H)  {\n         que.push( Pi( H - lange, p.second));\n       } else {\n         int64 cnt = min((H - lange) / p.first, -life / p.first + 1LL); // 回復量の最大値 OR lifeまでの回復量\n         ret += cnt;\n         life += cnt * p.first;\n         add( p.second, i + 1, cnt * p.first);\n         que.push(p);\n       }\n     }\n   }\n   printf(\"%lld\\n\", ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <assert.h>\n#define N_MAX (100000)\n#define min(a,b) (((a)<(b))?(a):(b))\ntypedef struct {\n\tint pos,value;\n} Info;\n\nsigned main(){\n\tint damage_total[N_MAX]={};\n\tInfo deque[N_MAX];\n\tint head=0,tail=0;\n\tint N,H;\n\tlong long answer = 0;\n\n\tscanf(\"%d%d\",&N,&H);\t\n\tint currentHP = H;\n\tfor(int i = 0 ; i < N-1 ; i++){\n\t\tint d,h;\n\t\tscanf(\"%d%d\",&d,&h);\n\t\twhile( head != tail && deque[tail-1].value <= h ) tail--;\n\n\t\tdeque[tail++] = (Info){i,h};\n\t\t/*while( head != tail ){\n\t\t\tint maximumRecover = H - (damage_total[i] - damage_total[deque[head].pos]);\n\t\t\tif( maximumRecover > 0 ) break;\n\t\t\thead++;\n\t\t}*/\n\n\t\tfor(int j = head ; j < tail && currentHP <= d ; j++){\n\t\t\t// ????????§???????????§????????????\n\t\t\tint maximumRecover = H - (damage_total[i] - damage_total[deque[j].pos]);\n\t\t\tif( maximumRecover < 0 ) continue;\n\t\t\t// ??¨???????????§????????????????£???°???\n\t\t\tif( maximumRecover <= currentHP) continue;\n\n\t\t\t// j??????????????§?????????????????? needRecover ????¨????\n\t\t\tint needRecover = min( maximumRecover - currentHP , d - currentHP + 1);  \n\t\t\t// ???????????? needRecover ?????????????????????????????° useCount ????±????????????????????????????\n\t\t\tint useCount = (needRecover+deque[j].value-1) / deque[j].value - 1;\n\t\t\tanswer += useCount;\n\t\t\tcurrentHP += useCount*deque[j].value;\n\n\t\t\t// ???j?????????????????§????°???????????????????j????????£?????´?????¨???j+1????????£?????´?????????????????????j+1????????£????????????????????????j?????????????????????\n\t\t\t// ??¨) ???????????¶???????????\\??£?????????????????¨???????????? currentHP > d ???????????????\n\t\t\tif( j+1 ==  tail || maximumRecover > currentHP + deque[j+1].value ){\n\t\t\t\tcurrentHP = min(currentHP+deque[j].value,maximumRecover);\n\t\t\t\tanswer++;\n\t\t\t}\n\t\t}\n\t\tcurrentHP -= d;\n\t\tdamage_total[i+1] = damage_total[i] + d;\n\t}\n\tprintf(\"%lld\\n\",answer);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int,pair<int,int> > pp;\npp mm[100001];\nint d[100001];\n\nint main(){\n    int n,h;\n    long long ans=0;\n    cin>>n>>h;\n    int di,hi,ch=h;\n    for(int i=0;i<n-1;++i){\n        cin>>di>>hi;\n        mm[i].first=ch+hi<=h||ch<0 ? hi:h-ch;mm[i].second.first=i;mm[i].second.second=ch;\n        d[i]=di;\n        ch -= di;\n    }\n    int l=0;\n    for(int i=0;i<n;++i){\n        ch=mm[i].second.second;\n        if(ch<=0){\n            pp t=*max_element(mm+l,mm+i);\n            hi=t.first;\n            int ch2=t.second.second;\n            i=t.second.first;l=i;\n            int div;\n            if(-ch/hi+1>(h-ch2)/hi){\n                div=(h-ch2)/hi;\n                ans+=div;\n                ch=ch2+hi*div;\n                mm[i].second.second=ch;\n                mm[i].first= ch+hi<=h ? hi:h-ch;\n                --i;continue;\n            } \n            div=-ch/hi+1;\n            ans+=div;\n            ch=min(h,ch2+hi*div);              \n        }\n        hi=mm[i].first;\n        mm[i].first=ch+hi>h ? h-ch:hi;\n        mm[i].second.second=ch; \n        mm[i+1].second.second= ch-d[i];\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\ntypedef pair< int, int > Pi;\n\nconst int INF = 1 << 30;\n// 区間への加算, 最大値が求まればいいかんじに出来る\n\nint64 seg[1 << 18];\n\nvoid add( int a, int b, int64 value, int k = 0, int l = 0, int r = 1 << 17){ // [a,b)にvalueを足すやつ\n  if(r <= a || b <= l) return;\n  if(a <= l && r <= b) { // 完全に含んでたら足す\n    seg[k] += value;\n  } else {\n    int mid = (l + r) >> 1;\n    add( a, b, value, 2 * k + 1, l, mid);\n    add( a, b, value, 2 * k + 2, mid, r);\n    seg[k] = max( seg[2 * k + 1], seg[2 * k + 2]);\n  }\n  return;\n}\n\nint64 query( int a, int b, int k = 0, int l = 0, int r = 1 << 17){ // [a,b)の最大値を返すやつ\n  if(r <= a || b <= l) return -INF;\n  if(a <= l && r <= b) return seg[k];\n  int mid = (l + r) >> 1;\n   return max( query( a, b, 2 * k + 1, l, mid), query( a, b, 2 * k + 2, mid, r));\n }\n\n\n int main()\n {\n   int N, H;\n   int64 life = 0; // 今の体力\n   int64 ret = 0;\n\n   scanf(\"%d %d\", &N, &H);\n   life = H;\n   priority_queue< Pi > que; // first: 一回あたりの回復体力量, second: どこ\n   for(int i = 0; i < N - 1; i++){\n     add( i, i + 1, life); // 今の体力を更新\n     int d, h;\n     scanf(\"%d %d\", &d, &h);\n     que.push( Pi( h, i));\n\n     life -= d; // 降りる\n     while(life <= 0){\n       Pi p = que.top(); que.pop();\n       int64 lange = query( p.second, i + 1); // 回復量の最大値\n       if(p.first + lange > H)  {\n         que.push( Pi( H - lange, p.second));\n       } else {\n         int64 cnt = min((H - lange) / p.first, -life / p.first + 1LL); // 回復量の最大値 OR lifeまでの回復量\n         ret += cnt;\n         life += cnt * p.first;\n         add( p.second, i + 1, cnt * p.first);\n         que.push(p);\n       }\n     }\n   }\n   printf(\"%lld\\n\", ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef pair<int,int>P;\nconst int SIZE=1<<17;\n\nstruct seg_tree{\n    vector<int>ma,lazy;\n\n    seg_tree():ma(SIZE*2-1,0),lazy(SIZE*2-1,0){}\n\n    void evaluate(int k){\n        ma[k]+=lazy[k];\n        if(k<SIZE-1){\n            lazy[k*2+1]+=lazy[k];\n            lazy[k*2+2]+=lazy[k];\n        }\n        lazy[k]=0;\n    }\n    void update_node(int k){\n        ma[k]=max(ma[k*2+1],ma[k*2+2]);\n    }\n\n    void add(int a,int b,int x,int k=0,int l=0,int r=SIZE){\n        evaluate(k);\n        if(r<=a||b<=l)return;\n        if(a<=l&&r<=b){\n            lazy[k]+=x;\n            evaluate(k);\n            return;\n        }\n        int m=(l+r)/2;\n        add(a,b,x,k*2+1,l,m);\n        add(a,b,x,k*2+2,m,r);\n        update_node(k);\n    }\n\n    int get_max(int a,int b,int k=0,int l=0,int r=SIZE){\n        evaluate(k);\n        if(r<=a||b<=l)return 0;\n        if(a<=l&&r<=b)return ma[k];\n        int m=(l+r)/2;\n        int vl=get_max(a,b,k*2+1,l,m);\n        int vr=get_max(a,b,k*2+2,m,r);\n        return max(vl,vr);\n    }\n};\n\nint N,H;\nint d[100000],h[100000];\n\nsigned main(){\n    cin>>N>>H;\n    for(int i=0;i<N-1;i++)cin>>d[i]>>h[i];\n\n    seg_tree seg;\n    int cur=H;\n    int ans=0;\n    priority_queue<P>que;\n    for(int i=0;i<N-1;i++){\n        seg.add(i,i+1,cur);\n        cur-=d[i];\n\n        que.push(P(h[i],i));\n\n        while(cur<=0){\n            P p=que.top();que.pop();\n            int ma=seg.get_max(p.second,i+1);\n            if(p.first+ma>H){\n                que.push(P(H-ma,p.second));\n                continue;\n            }\n            if(p.first<=0)return 0;\n            int x=min(abs(cur)/p.first+1,(H-ma)/p.first);\n            ans+=x;\n            cur+=x*p.first;\n            seg.add(p.second,i+1,p.first*x);\n        }\n    }\n\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\n#define int long long\n\nconst int MAX_N = 100010;\n\nclass segTree{\n    public:\n        int n, dat[4 * MAX_N];\n        void init(int n_, int value, int dat_b[4 * MAX_N] = NULL){\n            n = 1;\n            while(n < n_) n *= 2;\n            rep(i,2 * n){\n                dat[i] = value;\n                if(dat_b != NULL) dat_b[i] = value;\n            }\n        }\n        void output(int a[4 * MAX_N]){\n            show(\"print\");\n            range(i,1,n * 2) cout << (a[i] == INT_MAX ? 0 : a[i]) << ' ';\n            cout << endl;\n        }\n};\n\nclass starrySky : public segTree{\n    private:\n        int query(int a, int b, int k, int l, int r){\n            if(b <= l || r <= a) return 0;\n            if(a <= l && r <= b) return dat[k] + dat_add[k];\n\n            int vl = query(a, b, k * 2, l, (l + r) / 2);\n            int vr = query(a, b, k * 2 + 1, (l + r) / 2, r);\n            return max(vl, vr) + dat_add[k];\n        }\n        void add(int a, int b, int k, int l, int r, int x){\n            if(b <= l || r <= a) return;\n            if(a <= l && r <= b){\n                dat_add[k] += x;\n            }else{\n                add(a, b, k * 2, l, (l + r) / 2, x);\n                add(a, b, k * 2 + 1, (l + r) / 2, r, x);\n                dat[k] = max(dat[k * 2] + dat_add[k * 2], dat[k * 2 + 1] + dat_add[k * 2 + 1]);\n            }\n        }\n        void init(int n_){ segTree::init(n_,0,dat_add); }\n    public:\n        int dat_add[4 * MAX_N];\n        starrySky(int n){ init(n); }\n        int query(int a, int b){ return query(a, b, 1, 0, n); }\n        void add(int s, int t, int x){ add(s, t, 1, 0, n, x); }\n        void add(int i, int x){ add(i, i + 1, 1, 0, n, x); }\n};\n\n\nsigned main(){\n    long long n, h;\n    cin >> n >> h;\n\n???//1-index????????°??¨\n    starrySky seg(n); //?????????????????????\n    priority_queue<pair<long long, int>> q; //??????????????????pos\n    long long cur = h, ans = 0;\n    rep(i,n - 1){\n        long long damage, heal;\n        cin >> damage >> heal;\n        q.push(make_pair(heal, i));\n\n        seg.add(i + 1, cur);\n        cur -= damage;\n        while(cur <= 0){\n            pair<long long, int> use = q.top(); q.pop();\n            long long maxHP = seg.query(use.second + 1, i + 2); //????????°??????????????¨??°?????§?????????????????§\n\n            if(maxHP + use.first > h){ //??????????????????????¶????????????§?????????????????????????????´\n                q.push(make_pair(h - maxHP, use.second));\n                continue;\n            }\n\n            long long can_use = (h - maxHP) / use.first;\n            long long require = ceil((-1.0 * cur + 1) / use.first);\n            long long used = min(can_use, require);\n            ans += used;\n            cur += used * use.first;\n\n            seg.add(use.second + 1, i + 2, used * use.first);\n            q.push(use);\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\n//typedef pair<ll,ll> P;\n\n#define rep(i,n) for(ll (i)=0;(i)<(n);++i)\n\n#define rep1(i,n) for(ll (i)=1;(i)<=(n);++i)\n\n#define rrep(i,n) for(ll (i)=(n)-1;(i)>=(0);--i)\n\n#define rrep1(i,n) for(ll (i)=(n);(i)>=(1);--i)\n\n#define pb push_back\n\n#define fr first\n\n#define sc second\n\nconst ll INF=0xfffffffffffff;\nconst ll inf=0xfffffff;\nconst ll SIZE=1<<17;\nstruct P{\n\tll h,id,j;\n\tbool operator<(const P& an)const{\n\t\tif(h!=an.h) return h<an.h;\n\t\tif(j!=an.j) return j<an.j;\n\t\treturn id<an.id;\n\t}\n\tbool operator>(const P& an)const{\n\t\tif(h!=an.h) return h>an.h;\n\t\tif(j!=an.j) return j>an.j;\n\t\treturn id>an.id;\n\t}\n};\nll N,HP;\nll pos;\nll H[SIZE],D[SIZE];\nP dat[SIZE*2-1];\nll lazy[SIZE*2-1];\n\nP init(ll k){\n\tlazy[k]=0;\n\tif(SIZE-1<=k){\n\t\treturn dat[k]=P{H[k-SIZE+1],k-SIZE+1,HP};\n\t}\n\treturn dat[k]=max(init(k*2+1),init(k*2+2));\n}\n\nvoid lazy_ev(ll k){\n\tif(lazy[k]==0) return;\n\tdat[k].j+=lazy[k];\n\tif(k>=SIZE-1){\n\t\tdat[k].h=min(dat[k].h,dat[k].j);\t\t\n\t}\n\telse{\n\t\tdat[k].h=min(dat[k].h,dat[k].j);\n\t\tlazy[k*2+1]=lazy[k*2+2]=lazy[k];\n\t}\n\tlazy[k]=0;\n\treturn;\n}\n\nP query(ll a,ll b,ll k,ll l,ll r){//???????????§?????¨index\n\tlazy_ev(k);\n\tif(r<=a||b<=l) return P{-INF,-1,-INF};\n\tif(a<=l&&r<=b) return dat[k];\n\treturn max(query(a,b,k*2+1,l,(l+r)/2),query(a,b,k*2+2,(l+r)/2,r));\n}\n\nP update(ll a,ll b,ll val,ll k,ll l,ll r){\n\tlazy_ev(k);\n\tif(b<=l||r<=a) return dat[k];\n\tif(a<=l&&r<=b){\n\t\tlazy[k]=val;\n\t\tlazy_ev(k);\n\t}\n\telse{\n\t\tdat[k]=max(update(a,b,val,k*2+1,l,(l+r)/2),update(a,b,val,k*2+2,(l+r)/2,r));\n\t}\n\treturn dat[k];\n}\n\n\nll ans=0;\n\n\nint main()\n\n{\n\n\tcin>>N>>HP;\n\trep(i,SIZE) H[i]=-INF;\n\trep(i,N-1){\n\t\tcin>>D[i]>>H[i];\n\t}\n\tinit(0);\n\tpos=HP;\n\tll z;\n\trep(i,N-1){\n\t\tupdate(i,i+1,-pos,0,0,SIZE);\n\t\twhile(pos-D[i]<=0){\n\t\t\tP p=query(0,i+1,0,0,SIZE);\n\t\t\tif(p.h==p.j){\n\t\t\t\tpos+=p.h;\n\t\t\t\tans++;\n\t\t\t\tupdate(0,p.id+1,-inf,0,0,SIZE);\n\t\t\t\tupdate(p.id+1,i+1,-p.h,0,0,SIZE);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tz=p.j/p.h;\n\t\t\t\tpos+=p.h*z;\n\t\t\t\tans+=z;\n\t\t\t\tupdate(0,p.id,-inf,0,0,SIZE);\n\t\t\t\tupdate(p.id,i+1,-p.h*z,0,0,SIZE);\n\t\t\t}\n\t\t}\n\t\tpos-=D[i];\n\t}\n\tcout<<ans<<endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <assert.h>\n#define int long long\n#define N_MAX (100000)\n#define min(a,b) (((a)<(b))?(a):(b))\ntypedef struct {\n\tint pos,value;\n} Info;\n\nsigned main(){\n\tint damage_total[N_MAX]={};\n\tInfo deque[N_MAX];\n\tint head=0,tail=0;\n\tint N,H;\n\tint answer = 0;\n\n\tscanf(\"%lld%lld\",&N,&H);\t\n\tint currentHP = H;\n\tfor(int i = 0 ; i < N-1 ; i++){\n\t\tint d,h;\n\t\tscanf(\"%lld%lld\",&d,&h);\n\t\twhile( head != tail && deque[tail-1].value <= h ) tail--;\n\t\tdeque[tail++] = (Info){i,h};\n\n\t\tif( currentHP <= d ){\n\t\t\tint maximumRecover;\n\t\t\twhile( head != tail ){\n\t\t\t\tmaximumRecover = H - (damage_total[i] - damage_total[deque[head].pos]);\n\t\t\t\tif( maximumRecover > d ) break;\n\t\t\t\thead++;\n\t\t\t}\n\t\t\tassert(head!=tail);\n\t\t\tint useCount = (d - currentHP + 1 + deque[head].value - 1 ) / deque[head].value; \n\t\t\tcurrentHP = min(maximumRecover,currentHP+useCount*deque[head].value);\n\t\t\tanswer += useCount;\n\t\t}\t\n\t\tcurrentHP -= d;\n\t\tdamage_total[i+1] = damage_total[i] + d;\n\t}\n\tprintf(\"%lld\\n\",answer);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#include <stdio.h>\n#include <iostream>\n#include <bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> Pint;\ntypedef pair<ll, ll> P;\n//typedef pair<int, pair<int, int>> P;\n//typedef tuple<int,int,int> T;\nll INFL = 1000000000000000010;//10^18 = 2^60\nint INF = 2147483600;//10^9\nll MOD  = 1000000007;\n//vector<int> dy = {0,0,1,-1, 0, 1, 1, -1, -1}, dx = {1,-1,0,0, 0, 1, -1, 1, -1};\n//vector<int> dy = {0, 0, 1, -1}, dx = {1, -1, 0, 0};\n\nll N, H;\nll d[100010], h[100010];\n\nll Seg[262143], Whole[262143];\n\nvoid add(int a, int b, ll c, int k, int l, int r){\n    if(a <= l && r <= b) Whole[k] += c;\n    else if(b <= l || r <= a) ;\n    else{\n        add(a, b, c, 2*k+1, l, (l+r)/2);\n        add(a, b, c, 2*k+2, (l+r)/2, r);\n        Seg[k] = max(Seg[2*k+1] + Whole[2*k+1], Seg[2*k+2] + Whole[2*k+2]);\n    }\n}\n\nll query(int a, int b, int k, int l, int r){//最大値\n    if(a <= l && r <= b) return Seg[k] + Whole[k];\n    else if(b <= l || r <= a) return -LLONG_MAX;\n    else{\n        return max(query(a, b, 2*k+1, l, (l+r)/2), query(a, b, 2*k+2, (l+r)/2, r)) + Whole[k];\n    }\n}\n\nint main(void){\n    cin >> N >> H;\n    N--;\n    for(int i = 0; i < N; i++){\n        cin >> d[i] >> h[i];\n    }\n    \n    ll now_H = H;\n    priority_queue<pair<ll, int>> pque;\n    ll ans = 0;\n    \n    for(int i = 0; i < N; i++){\n        add(i, i+1, now_H, 0, 0, N);\n        now_H -= d[i];\n        pque.push({h[i], i});\n        while(now_H <= 0){\n            ll cost = pque.top().first;\n            int at = pque.top().second;\n            pque.pop();\n            ll m = query(at, i+1, 0, 0, N);\n            if(m + cost > H){\n                pque.push({H - m, at});\n                continue;\n            }\n            int maxnum = min((H-m)/cost, (-now_H)/cost + 1);\n            ans += maxnum;\n            add(at, i+1, maxnum * cost, 0, 0, N);\n            now_H += maxnum * cost;\n            pque.push({cost,at});\n        }\n    }\n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <assert.h>\n#define N_MAX (100000)\n#define min(a,b) (((a)<(b))?(a):(b))\ntypedef struct {\n\tint pos,value;\n} Info;\n\nsigned main(){\n\tint damage_total[N_MAX]={};\n\tInfo deque[N_MAX];\n\tint head=0,tail=0;\n\tint N,H;\n\tlong long answer = 0;\n\n\tscanf(\"%d%d\",&N,&H);\t\n\tint currentHP = H;\n\tfor(int i = 0 ; i < N-1 ; i++){\n\t\tint d,h;\n\t\tscanf(\"%d%d\",&d,&h);\n\t\twhile( head != tail && deque[tail-1].value <= h ) tail--;\n\n\t\tdeque[tail++] = (Info){i,h};\n\t\t/*while( head != tail ){\n\t\t\tint maximumRecover = H - (damage_total[i] - damage_total[deque[head].pos]);\n\t\t\tif( maximumRecover > 0 ) break;\n\t\t\thead++;\n\t\t}*/\n\n\t\tfor(int j = head ; j < tail && currentHP <= d ; j++){\n\t\t\t// ????????§???????????§????????????\n\t\t\tint maximumRecover = H - (damage_total[i] - damage_total[deque[j].pos]);\n\t\t\t\n\t\t\t// ??¨???????????§????????????????£???°???\n\t\t\tif( maximumRecover <= currentHP) continue;\n\n\t\t\t// j??????????????§?????????????????? needRecover ????¨????\n\t\t\tint needRecover = min( maximumRecover - currentHP , d - currentHP + 1);  \n\t\t\t// ???????????? needRecover ?????????????????????????????° useCount ????±????????????????????????????\n\t\t\tint useCount = (needRecover+deque[j].value-1) / deque[j].value - 1;\n\t\t\tanswer += useCount;\n\t\t\tcurrentHP += useCount*deque[j].value;\n\n\t\t\t// ???j?????????????????§????°???????????????????j????????£?????´?????¨???j+1????????£?????´?????????????????????j+1????????£????????????????????????j?????????????????????\n\t\t\t// ??¨) ???????????¶???????????\\??£?????????????????¨???????????? currentHP > d ???????????????\n\t\t\tif( j+1 ==  tail || maximumRecover > currentHP + deque[j+1].value ){\n\t\t\t\tcurrentHP = min(currentHP+deque[j].value,maximumRecover);\n\t\t\t\tanswer++;\n\t\t\t}\n\t\t}\n\t\tcurrentHP -= d;\n\t\tdamage_total[i+1] = damage_total[i] + d;\n\t}\n\tprintf(\"%lld\\n\",answer);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<string>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,P> P1;\n\n#define rep(i,x) for(ll i = 0 ; i < x ; i ++)\n#define rep1(i,x) for(ll i = 1 ; i <= x ; i ++)\n#define rrep(i,x) for(ll i = x-1 ; i >= 0 ; i --)\n#define rrep1(i,x) for(ll i = x ; i > 0 ; i --)\n#define sor(vec) sort(vec.begin(),vec.end())\n#define rev(vec) reverse(vec.begin(),vec.end())\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(min(a,b),c)\n#define max_3(a,b,c) max(max(a,b),c)\n#define mp1(a,b,c) P1(a,P(b,c))\n#define fr first\n#define sc second\n#define pb push_back\n\nconst int INF = 1000000000;\nconst int dir_4[4][2] = { {1,0} , {0,1} , {-1,0} , {0,-1} };\n\nint siz;\nint seg[2][400010];\n\nvoid init(int n){\n\tsiz = 1;\n\twhile(siz < n)siz *= 2;\n\trep(i,siz*2-1){\n\t\tseg[0][i] = -INF;\n\t\tseg[1][i] = 0;\n\t}\n}\n\nint query(int k){\n\tint sum = 0;\n\tk += siz-1;\n\tint ret = seg[0][k];\n\twhile(k > 0){\n\t\tk = (k-1)/2;\n\t\tret = max ( ret + seg[1][k] , seg[0][k] );\n\t}\n\treturn ret;\n}\n\nvoid maxi(int a,int b,int x,int k,int l,int r){\n\tif(b <= l || r <= a)return;\n\tif(a <= l && r <= b){\n\t\tseg[0][k] = max ( seg[0][k] , x );\n\t\treturn;\n\t}\n\tmaxi(a,b,x-seg[1][k],2*k+1,l,(l+r)/2);\n\tmaxi(a,b,x-seg[1][k],2*k+2,(l+r)/2,r);\n}\n\nvoid add(int a,int b,int x,int k,int l,int r){\n\tif(b <= l || r <= a)return;\n\tif(a <= l && r <= b){\n\t\tseg[0][k] += x;\n\t\tseg[1][k] += x;\n\t\treturn;\n\t}\n\tadd(a,b,x,2*k+1,l,(l+r)/2);\n\tadd(a,b,x,2*k+2,(l+r)/2,r);\n}\n\nvoid updata(int k,int x){\n\tadd(k,k+1,x-query(k),0,0,siz);\n}\n\nint main(){\n\tint n,h;\n\tstatic int c[100010],d[100010];\n\t\n\tscanf(\"%d%d\",&n,&h);\n\trep1(i,n-1){\n\t\tscanf(\"%d%d\",&c[i],&d[i]);\n\t}\n\t\n\tinit(n+10);\n\tupdata(0,h);\n\tc[0] = 0;\n\t\n\tpriority_queue<P> que;\n\tint ret = 0;\n\t\n\trep1(i,n-1){\n\t\tupdata(i,query(i-1)-c[i-1]);\n\t\tque.push( P ( d[i] , i ) );\n\t\tint t = c[i] - query(i) + 1;\n\t\twhile(t > 0){\n\t\t\tP p = que.top(); que.pop();\n\t\t\tint s1 = (t+p.fr-1)/p.fr;\n\t\t\tint s2 = (h-query(p.sc))/p.fr;\n\t\t\tif(s1 < s2){\n\t\t\t\tmaxi(0,p.sc,query(p.sc)+p.fr*s1,0,0,siz);\n\t\t\t\tadd(p.sc,siz,p.fr*s1,0,0,siz);\n\t\t\t\tt -= p.fr*s1;\n\t\t\t\tret += s1;\n\t\t\t\tque.push(p);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmaxi(0,p.sc,query(p.sc)+p.fr*s2,0,0,siz);\n\t\t\t\tadd(p.sc,siz,p.fr*s2,0,0,siz);\n\t\t\t\tt -= p.fr*s2;\n\t\t\t\tret += s2;\n\t\t\t\tque.push( P ( h-query(p.sc) , p.sc ) );\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\",ret);\n\t\t\t\t\n}"
  },
  {
    "language": "C++",
    "code": "//10点解法\n#include<iostream>\nusing namespace std;\nint healed[1000][1001];\t//healed[階層-1][体力](使用回数)\nint N,H;\nint damage[1000],heal[1000];\n\nint main(){\n\tint i,j;\n\tcin >> N >> H;\n\tfor(i = 0;i < N-1;i++){\n\t\tcin >> damage[i] >> heal[i];\n\t}\n\tfor(i = 0;i < N;i++){\n\t\tfor(j = 0;j < H+1;j++){\n\t\t\thealed[i][j] = -1;\n\t\t}\n\t}\n\thealed[0][H] = 0;\n\t//DP開始\n\tint hp,count;\n\tfor(i = 0;i < N-1;i++){\n\t\tfor(j = 1;j <= H;j++){\n\t\t\tif(healed[i][j] == -1)\n\t\t\t\tcontinue;\n\t\t\tcount = 0;\n\t\t\tfor(int l = 0;j+l < H+heal[i];l += heal[i]){\n\t\t\t\thp = j+l;\n\t\t\t\tif(hp > H)hp = H;\n\t\t\t\thp -= damage[i];\n\t\t\t\tif(hp <= 0){\n\t\t\t\t\tcount++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(healed[i+1][hp] == -1 || healed[i+1][hp] > healed[i][j]+count)\n\t\t\t\t\thealed[i+1][hp] = healed[i][j]+count;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\t//貪欲法で最小値を探索する\n\tint min = -1;\n\tfor(i = 0;i <= H;i++){\n\t\tif(healed[N-1][i] >= 0 && (min == -1 || min > healed[N-1][i]))\n\t\t\tmin = healed[N-1][i];\n\t}\n\tcout << min << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nconst int MAX_N = 100001*2;\n\nstruct SegMax {\n  int data[MAX_N * 2 - 1];\n  int datb[MAX_N * 2 - 1];\n  int n;\n  SegMax(int n) : n(n) {\n    REP(i,n) data[i]=datb[i]=0;\n  }\n  void add(int a, int b, int x) {\n    add(a,b,x,0,0,n);\n  }\n  void add(int a, int b, int x, int k, int l, int r) {\n    if (a <= l && r <= b) data[k] += x;\n    else if (l<b && a<r) {\n      datb[k] = max(datb[k], x);\n      add(a, b, x, k*2+1, l, (l+r)/2);\n      add(a, b, x, k*2+2, (l+r)/2, r);\n    }\n  }\n  int getmax(int a, int b) {\n    return getmax(a,b,0,0,n);\n  }\n  int getmax(int a, int b, int k, int l, int r) {\n    if (b<=l || r<=a) return 0;\n    else if (a<=l && r<=b) {\n      return data[k] + datb[k];\n    } else {\n      int res = 0;\n      res = max(res, getmax(a, b, k*2+1, l, (l+r)/2));\n      res = max(res, getmax(a, b, k*2+2, (l+r)/2, r));\n      return res + data[k];\n    }\n  }\n};\n\nint di[100000];\nint hi[100000];\n\nint main() {\n  int N, H;\n  cin >> N >> H;\n  REP(i,N-1) {\n    scanf(\"%d%d\",di+i,hi+i);\n  }\n  SegMax st(N);\n  priority_queue<pii> Q;\n  int now = H;\n  ll ans = 0;\n  REP(i,N-1) {\n    st.add(i,i+1,now);\n    Q.push(pii(hi[i], i));\n    now -= di[i];\n    while(now<=0) {\n      pii p = Q.top(); Q.pop();\n      int heal = p.first;\n      int pos = p.second;\n      int smax = st.getmax(pos, i+1);\n      if (smax + heal > H) {\n        Q.push(pii(H-smax, pos));\n        continue;\n      }\n      int num = (H-smax) / heal;\n      now += num*heal;\n      ans += num;\n      st.add(pos, i+1, num*heal);\n      Q.push(p);\n    }\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF=1001001001;\ntypedef pair<int,int>P;\nstruct seg_tree{\n    int N;\n    vector<int>mi,lazy,id;\n\n    void init(int n){\n        N=1;\n        while(n>N)N*=2;\n        mi.resize(N*2-1,0);\n        lazy.resize(N*2-1,0);\n        id.resize(N*2-1,0);\n        for(int i=N-1;i<N*2-1;i++)id[i]=i-N+1;\n    }\n\n    void evaluate(int k){\n        mi[k]+=lazy[k];\n        if(k<N-1){\n            lazy[k*2+1]+=lazy[k];\n            lazy[k*2+2]+=lazy[k];\n        }\n        lazy[k]=0;\n    }\n\n    void update_node(int k){\n        if(mi[k*2+1]<=mi[k*2+2]){\n            mi[k]=mi[k*2+1];\n            id[k]=id[k*2+1];\n        }\n        else{\n            mi[k]=mi[k*2+2];\n            id[k]=id[k*2+2];\n        }\n    }\n\n    void add(int a,int b,int x){\n        add(a,b,x,0,0,N);\n    }\n    void add(int a,int b,int x,int k,int l,int r){\n        evaluate(k);\n        if(r<=a||b<=l)return;\n        if(a<=l&&r<=b){\n            lazy[k]+=x;\n            evaluate(k);\n            return;\n        }\n\n        int m=(l+r)/2;\n        add(a,b,x,k*2+1,l,m);\n        add(a,b,x,k*2+2,m,r);\n        update_node(k);\n    }\n\n    P getMin(int a,int b){\n        return getMin(a,b,0,0,N);\n    }\n    P getMin(int a,int b,int k,int l,int r){\n        evaluate(k);\n        if(r<=a||b<=l)return P(INF,0);\n        if(a<=l&&r<=b)return P(mi[k],id[k]);\n\n        int m=(l+r)/2;\n        P vl=getMin(a,b,k*2+1,l,m);\n        P vr=getMin(a,b,k*2+2,m,r);\n        return min(vl,vr);\n    }\n};\n\nint N,H;\nint d[100000],h[100000];\n\nint main(){\n    cin>>N>>H;\n    for(int i=0;i<N-1;i++)cin>>d[i]>>h[i];\n\n    seg_tree seg,latte;\n    seg.init(N);\n    latte.init(N);\n    int ans=0,cur=H;\n    for(int i=0;i<N-1;i++){\n        seg.add(i,i+1,H-cur);\n        latte.add(i,i+1,-h[i]);\n        cur-=d[i];\n        while(cur<=0){\n            int lb=i,ub=-1;\n            while(lb-ub>1){\n                int mid=(ub+lb)/2;\n                if(seg.getMin(mid,i+1).first==0)ub=mid;\n                else lb=mid;\n            }\n            P p=seg.getMin(lb,i+1);\n            int val=min(p.first,-latte.getMin(lb,i+1).first);\n            int cnt=min(abs(cur)/val+1,p.first/val);\n            ans+=cnt;\n            cur+=cnt*val;\n        }\n    }\n\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <map>\n#include <deque>\nusing namespace std;\n\nlong long d[100000];\nlong long h[100000];\nlong long s[100000];\nint main(){\n\tlong long N,H,mx;\n\tscanf(\"%lld%lld\",&N,&H);\n\tmx = H;\n\tfor(int i = 0 ; i < N-1 ; i++){\n\t\tscanf(\"%lld%lld\",&d[i],&h[i]);\n\t\ts[i+1] = s[i] + d[i];\n\t}\n\t\n\tint ans = 0;\n\tdeque<int> Q;\n\tfor(int i = 0 ; i < N-1 ; i++){\n\t\twhile( Q.size() && h[Q.back()] <= h[i]) Q.pop_back();\n\t\tQ.push_back(i);\n\t\twhile( Q.size() && s[i] - s[Q.front()] > mx) Q.pop_front();\n\t\tif( H <= d[i] ){\n\t\t\tfor(int j = 0 ; j < Q.size() ; j++){\n\t\t\t\tlong long heal_max = max(0ll, mx - (s[i] - s[Q[j]]) - H );\n\t\t\t\tlong long need = d[i] - H + 1;\n\t\t\t\tlong long use = min(need,heal_max) / h[Q[j]];\n\t\t\t\tH += use * h[Q[j]];\n\t\t\t\tans += use;\n\t\t\t\tif( H > d[i] ) break;\n\t\t\t\t\n\t\t\t\tif( j+1 >= Q.size() || mx - (s[i] - s[Q[j]]) - H >= h[Q[j+1]] ){\n\t\t\t\t\tans++;\n\t\t\t\t\tH = min( H + h[Q[j]], mx - (s[i] - s[Q[j]]) );\n\t\t\t\t}\n\t\t\t\tif( H > d[i] ) break;\n\t\t\t}\n\t\t}\n\t\tH -= d[i];\n\t\tif( H <= 0 ){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n\nusing namespace std;\n\nlong long int n,h;\n\nlong long int tai[100001];\nlong long int kai[100000];\n\n#define DEEP 19\n\nlong long int seg[(1 << DEEP)];\nint segs[(1 << DEEP)];\nint segl[(1 << DEEP)];\n\nint nextk[100000];\n\nint st[100000];\n\nlong long int segmax(int beg,int end)\n{\n\tif(end < beg)\n\t{\n\t\treturn -1;\n\t}\n\tint nowb1 = beg + (1 << (DEEP - 1)) - 1;\n\tint nowb2 = end + (1 << (DEEP - 1)) - 1;\n\tlong long int maxw = max(seg[nowb1],seg[nowb2]);\n\tfor(int i = 0; i < DEEP; i++)\n\t{\n\t\tint nowb1n = (nowb1 - 1) / 2;\n\t\tint nowb2n = (nowb2 - 1) / 2;\n\t\tif(nowb1n == nowb2n)\n\t\t{\n\t\t\treturn maxw;\n\t\t}\n\t\tif(nowb1 % 2 == 1)\n\t\t{\n\t\t\tmaxw = max(maxw,seg[nowb1 + 1]);\n\t\t}\n\t\tif(nowb2 % 2 == 0)\n\t\t{\n\t\t\tmaxw = max(maxw,seg[nowb2 - 1]);\n\t\t}\n\t}\n\treturn maxw;\n}\n\nint main()\n{\n\tscanf(\"%lld %lld\",&n,&h);\n\tlong long int nownt = 0;\n\ttai[0] = 0;\n\tfor(int i = (1 << (DEEP - 1)) - 1; i < (1 << DEEP); i++)\n\t{\n\t\tseg[i] = -1;\n\t\tsegs[i] = i - ((1 << (DEEP - 1)) - 1);\n\t\tsegl[i] = i - ((1 << (DEEP - 1)) - 1);\n\t}\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tlong long int dw,hw;\n\t\tscanf(\"%lld %lld\",&dw,&hw);\n\t\tnownt += dw;\n\t\ttai[i] = nownt;\n\t\tkai[i - 1] = hw;\n\t\tseg[(1 << (DEEP - 1)) - 1 + i - 1] = hw;\n\t}\n\ttai[n] = 10000000000000;\n\tkai[n - 1] = 100000000;\n\tint stn = 0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tfor(int j = stn - 1; j >= 0; j--)\n\t\t{\n\t\t\tif(kai[st[j]] <= kai[i])\n\t\t\t{\n\t\t\t\tnextk[st[j]] = i;\n\t\t\t\tstn--;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tst[stn] = i;\n\t\tstn++;\n\t}\n\tfor(int i = (1 << (DEEP - 1)) - 2; i >= 0; i--)\n\t{\n\t\tseg[i] = max(seg[i * 2 + 1],seg[i * 2 + 2]);\n\t\tsegs[i] = segs[i * 2 + 1];\n\t\tsegl[i] = segl[i * 2 + 2];\n\t}\n\tlong long int all = 0;\n\tlong long int nh = h;\n\tfor(int i = 0; i < n - 1; i++)\n\t{\n\t\tlong long int nt = tai[nextk[i]] - tai[i] + 1;\n\t\tlong long int tari = nt - nh;\n\t\tif(tari <= 0)\n\t\t{\n\t\t\ti = nextk[i] - 1;\n\t\t\tnh -= (nt - 1);\n\t\t\tcontinue;\n\t\t}\n\t\tlong long int kaikai = (tari - 1) / kai[i] + 1;\n\t\tlong long int kaiw = kaikai * kai[i];\n\t\tif(kaiw + nh > h)\n\t\t{\n\t\t\tlong long int na = h - nh;\n\t\t\tlong long int cank = na / kai[i];\n\t\t\tlong long int ak = h - (cank * kai[i] + nh);\n\t\t\tint now = i;\n\t\t\tint han = n - i;\n\t\t\tfor(int j = 0; j < 20; j++)\n\t\t\t{\n\t\t\t\tif(tai[now + han] - tai[i] + 1 <= cank * kai[i] + nh)\n\t\t\t\t{\n\t\t\t\t\tnow += han;\n\t\t\t\t}\n\t\t\t\than = (han + 1) / 2;\n\t\t\t}\n\t\t\tlong long int maxw = segmax(i + 1,now);\n\t\t\tif(maxw < ak)\n\t\t\t{\n\t\t\t\tall += cank + 1;\n\t\t\t\tnh = h - tai[i + 1] + tai[i];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tall += cank;\n\t\t\t\tnh = nh + cank * kai[i] - tai[i + 1] + tai[i];\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\ti = nextk[i] - 1;\n\t\t\tnh = nh + kaiw - (nt - 1);\n\t\t\tall += kaikai;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",all);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 1LL << 50;\nconst int MAX_N = 1 << 17;\nconst int def = 0;\n\nstruct MaxSegTree2 {\n\tint n;\n\tll segMax[2 * MAX_N - 1], segAdd[2 * MAX_N - 1];\n\tvoid init(int n_) {\n\t\tn = 1;\n\t\twhile(n < n_) n *= 2;\n\t\tfor(int i = 0; i < 2 * n - 1; i++) segMax[i] = def;\n\t}\n\n\tvoid add(int a, int b, ll x) { add(a, b, x, 0, 0, n); }\n\n\tvoid add(int a, int b, ll x, int k, int l, int r) {\n\t\tif(r <= a || b <= l) return;\n\t\tif(a <= l && r <= b) {\n\t\t\tsegAdd[k] += x;\n\t\t\treturn;\n\t\t}\n\t\tadd(a, b, x, k * 2 + 1, l, (l + r) / 2);\n\t\tadd(a, b, x, k * 2 + 2, (l + r) / 2, r);\n\t\tsegMax[k] = max(segMax[k * 2 + 1] + segAdd[k * 2 + 1], segMax[k * 2 + 2] + segAdd[k * 2 + 2]);\n\t}\n\n\tll query(int a, int b) { return query(a, b, 0, 0, n); }\n\n\tll query(int a, int b, int k, int l, int r) {\n\t\tif(r <= a || b <= l) return -INF;\n\t\tif(a <= l && r <= b) return segMax[k] + segAdd[k];\n\t\tll vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tll vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn max(vl, vr) + segAdd[k];\n\t}\n};\n\nMaxSegTree2 st;\ntypedef pair<ll, int> P;\n\nll d[100000];\nll heal[100000];\nint c[1000000];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\t//ifstream ifs(\"input.txt\");\n\t//cin.rdbuf(ifs.rdbuf());\n\t//ofstream ofs(\"output.txt\");\n\t//cout.rdbuf(ofs.rdbuf());\n\n\tint N, H;\n\tcin >> N >> H;\n\tst.init(N);\n\tst.add(0, N, H);\n\tfor(int i = 0; i < N - 1; i++) {\n\t\tcin >> d[i] >> heal[i];\n\t\tst.add(i + 1, N, -d[i]);\n\t}\n\tll hp = H, ans = 0;\n\tpriority_queue<P> q; // <head,idx>\n\tfor(int i = 0; i < N - 1; i++) {\n\t\t////cerr << \"d : \" << d[i] << \", heal : \" << heal[i] << endl;\n\t\tq.push({ heal[i], i });\n\t\tif(hp - d[i] >= 1) {\n\t\t\thp -= d[i];\n\t\t}\n\t\telse {\n\t\t\twhile(hp - d[i] <= 0) {\n\t\t\t\tP p = q.top();\n\t\t\t\tq.pop();\n\t\t\t\tll h = p.first, idx = p.second;\n\n\t\t\t\tll x = -hp + d[i] + 1;\n\t\t\t\tll rem = H - st.query(idx, N);\n\t\t\t\tassert(rem >= 0);\n\t\t\t\tif(rem == 0) continue;\n\t\t\t\tif(rem < h) {\n\t\t\t\t\tq.push({ rem, idx });\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint cnt = (x + h - 1) / h;\n\t\t\t\tif(h * cnt > rem) cnt = rem / h;\n\t\t\t\t//cerr << \"idx : \" << idx << \", h : \" << h << \", cnt : \" << cnt << endl;\n\t\t\t\t//cerr << hp << \" -> \";\n\t\t\t\thp = min(ll(H), hp + h * cnt);\n\t\t\t\t//cerr << hp << endl;\n\t\t\t\tans += cnt;\n\t\t\t\tc[idx] += cnt;\n\t\t\t\tst.add(idx, N, h * cnt);\n\t\t\t\trem -= h * cnt;\n\t\t\t\tif(rem > 0) {\n\t\t\t\t\tq.push({ min(rem, h), idx });\n\t\t\t\t}\n\t\t\t}\n\t\t\thp -= d[i];\n\t\t}\n\t\t/*for(int j = 0; j < N - 1; j++) {\n\t\t\tcout << st.query(j, j + 1) << \" \";\n\t\t\t}\n\t\t\tcout << endl;*/\n\t\t//cerr << \"hp : \" << hp << endl;\n\n\t}\n\tcout << ans << endl;\n\n\thp = H;\n\tfor(int i = 0; i < N; i++) {\n\t\thp = min(ll(H), hp + c[i] * heal[i]);\n\t\thp -= d[i];\n\t\tassert(hp >= 1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define mp(a,b) make_pair((a),(b))\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nstruct Dungeon{\n\tint plus,pos;\n\n\tbool operator<(const Dungeon &d)const{\n\t\tif(plus!=d.plus) return plus<d.plus;\n\t\telse pos<d.pos;\n\t}\n};\n\nstruct SegmentTree{\n\tint sz;\n\tvector<int> val,lazy;\n\n\tSegmentTree(int n){\n\t\tInit(n);\n\t}\n\n\tvoid Init(int n){\n\t\tsz=1;\n\t\twhile(sz<n) sz*=2;\n\t\tval.assign(sz*2-1,0);\n\t\tlazy.assign(sz*2-1,0);\n\t}\n\n\tinline void Evaluate(int k,int l,int r){\n\t\tval[k]+=lazy[k];\n\t\tif(k<sz-1){\n\t\t\tlazy[k*2+1]+=lazy[k];\n\t\t\tlazy[k*2+2]+=lazy[l];\n\t\t}\n\t\tlazy[k]=0;\n\t}\n\n\tvoid Update(int k){\n\t\tval[k]=max(val[k*2+1],val[k*2+2]);\n\t}\n\n\tvoid Add(int a,int b,int x,int k,int l,int r){\n\t\tEvaluate(k,l,r);\n\n\t\tif(r<=a||b<=l) return;\n\t\tif(a<=l&&r<=b){\n\t\t\tlazy[k]+=x;\n\t\t\tEvaluate(k,l,r);\n\t\t\treturn;\n\t\t}\n\n\t\tAdd(a,b,x,k*2+1,l,(l+r)/2);\n\t\tAdd(a,b,x,k*2+2,(l+r)/2,r);\n\t\tUpdate(k);\n\t}\n\n\tvoid Add(int a,int b,int x){\n\t\tAdd(a,b,x,0,0,sz);\n\t}\n\n\tint Max(int a,int b,int k,int l,int r){\n\t\tEvaluate(k,l,r);\n\n\t\tif(r<=a||b<=l) return 0;\n\t\tif(a<=l&&r<=b) return val[k];\n\n\t\tint lv=Max(a,b,k*2+1,l,(l+r)/2);\n\t\tint rv=Max(a,b,k*2+2,(l+r)/2,r);\n\t\tUpdate(k);\n\n\t\treturn max(lv,rv);\n\t}\n\n\tint Max(int a,int b){\n\t\treturn Max(a,b,0,0,sz);\n\t}\n};\n\n\nvoid Solve(){\n\tint n,h,di[100000],hi[100000],life;\n\n\tcin >> n >> h;\n\trep(i,0,n-1) cin >> di[i] >> hi[i];\n\n\tlife=h;\n\n\tll ans=0;\n\tSegmentTree st(n);\n\tpriority_queue<Dungeon> que;\n\trep(i,0,n-1){\n\t\tst.Add(i,i+1,life);\n\t\tDungeon in;\n\t\tlife-=di[i];\n\n\t\tin.plus=hi[i];\n\t\tin.pos=i;\n\n\t\tque.push(in);\n\t\twhile(life<=0){\n\t\t\tDungeon heal=que.top();\n\t\t\tque.pop();\n\n\t\t\tint maxi=st.Max(heal.pos,i+1);\n\n\t\t\tif(heal.plus+maxi>h){\n\t\t\t\theal.plus=h-maxi;\n\t\t\t\tque.push(heal);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint num=min((-1*life)/heal.plus+1,(h-maxi)/heal.plus);\n\t\t\tans+=num;\n\t\t\tlife+=num*heal.plus;\n\n\t\t\tst.Add(heal.pos,i+1,num*heal.plus);\n\t\t\tque.push(heal);\n\t\t}\n\t}\n\n\tcout << ans << endl;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <assert.h>\n#define N_MAX (100000)\n#define min(a,b) (((a)<(b))?(a):(b))\ntypedef struct {\n\tint pos,value;\n} Info;\n\nsigned main(){\n\tint damage_total[N_MAX]={};\n\tInfo deque[N_MAX];\n\tint head=0,tail=0;\n\tint N,H;\n\tlong long answer = 0;\n\n\tscanf(\"%d%d\",&N,&H);\t\n\tint currentHP = H;\n\tfor(int i = 0 ; i < N-1 ; i++){\n\t\tint d,h;\n\t\tscanf(\"%d%d\",&d,&h);\n\t\twhile( head != tail && deque[tail-1].value <= h ) tail--;\n\n\t\tdeque[tail++] = (Info){i,h};\n\t\twhile( head != tail ){\n\t\t\tint maximumRecover = H - (damage_total[i] - damage_total[deque[head].pos]);\n\t\t\tif( maximumRecover > 0 ) break;\n\t\t\thead++;\n\t\t}\n\n\t\tfor(int j = head ; j < tail && currentHP <= d ; j++){\n\t\t\t// ????????§???????????§????????????\n\t\t\tint maximumRecover = H - (damage_total[i] - damage_total[deque[j].pos]);\n\t\t\t\n\t\t\t// ??¨???????????§????????????????£???°???\n\t\t\tif( maximumRecover <= currentHP) continue;\n\n\t\t\t// j??????????????§?????????????????? needRecover ????¨????\n\t\t\tint needRecover = min( maximumRecover - currentHP , d - currentHP + 1);  \n\t\t\t// ???????????? needRecover ?????????????????????????????° useCount ????±????????????????????????????\n\t\t\tint useCount = (needRecover+deque[j].value-1) / deque[j].value - 1;\n\t\t\tanswer += useCount;\n\t\t\tcurrentHP += useCount*deque[j].value;\n\n\t\t\t// ???j?????????????????§????°???????????????????j????????£?????´?????¨???j+1????????£?????´?????????????????????j+1????????£????????????????????????j?????????????????????\n\t\t\t// ??¨) ???????????¶???????????\\??£?????????????????¨???????????? currentHP > d ???????????????\n\t\t\tif( j+1 ==  tail || maximumRecover > currentHP + deque[j+1].value ){\n\t\t\t\tcurrentHP = min(currentHP+deque[j].value,maximumRecover);\n\t\t\t\tanswer++;\n\t\t\t}\n\t\t}\n\t\tcurrentHP -= d;\n\t\tdamage_total[i+1] = damage_total[i] + d;\n\t}\n\tprintf(\"%lld\\n\",answer);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\nusing namespace std;\n\nint N, LIMIT;\n\nstruct water{\n    int heal, s, pay;\n    water(int _h, int _s, int _p): heal(_h), s(_s), pay(_p){}\n};\ndeque<water> DQ;\n\nint main(){\n    scanf(\"%d %d\", &N, &LIMIT);\n    int res = 0;\n    int HP = LIMIT;\n    for(int i=1;i<N;i++){\n        int Di, Hi;\n        scanf(\"%d %d\", &Di, &Hi);\n        while(!DQ.empty() && DQ.front().heal <= Hi) DQ.pop_front();\n        DQ.push_front(water(Hi, HP, 0));\n        while(HP < Di){\n            water w = DQ.back();\n            int toheal = Di - HP;\n            int space = LIMIT - w.s - w.pay;\n            int full_heal = space - (space % w.heal);\n            if(full_heal > toheal){\n                int Times = toheal / w.heal;\n                if(toheal % w.heal) Times++;\n                res +=Times;\n                HP += Times * w.heal;\n                DQ.back().pay += Times * w.heal;\n            }\n            else{\n                HP += full_heal;\n                res += full_heal / w.heal;\n                w.pay += full_heal;\n                //\n                int other = space % w.heal;\n                DQ.pop_back();\n                if(!DQ.empty() && DQ.back().heal >= other){\n                    DQ.back().pay = w.pay;\n                }\n                else{\n                    res++;\n                    HP += space % w.heal;\n                    w.pay += space % w.heal;\n                    DQ.back().pay = w.pay;\n                }\n            }\n        }\n        DQ.front().s = HP;\n        DQ.front().pay = 0;\n        DQ.front().pay = -DQ.back().pay;\n        HP -= Hi;\n    }\n    printf(\"%d\\n\", res);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n  int n, h, d, hp, maxhp, damage = 0, ans = 0;\n  deque<pair<int, int> > izumi;\n  scanf(\"%d%d\", &n, &hp);\n  maxhp = hp;\n  for(int i = 0;i < n - 1;i++){\n    scanf(\"%d%d\", &d, &h);\n    damage += d;\n    while(hp <= damage){\n      hp += izumi.front().first;\n      ans++;\n      if(hp - izumi.front().second > maxhp){\n\tizumi.pop_front();\n      }\n    }\n    while(!izumi.empty() && izumi.back().first < h){\n      izumi.pop_back();\n    }\n    izumi.push_back(make_pair(h, damage));\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <iterator>\n#include <list>\n#include <map>\n#include <queue>\n#include <bitset>\n#include <fstream>\n#include <cmath>\nusing namespace std;\ntypedef long long ll;\n\nint main()\n{\n\tll N, H;\n\tcin>>N>>H;\n\tll res = 0;\n\tpriority_queue<long>  spring;\n\tfor(int i = 0; i < N-1; i++){\n\t\tint d, h;\n\t\tcin>>d>>h;\n\t\tspring.push(h);\n\t\tH -= d;\n\n\t\twhile(!spring.empty() && H < 1){\n\t\t\tH += spring.top();\n\t\t\tspring.pop();\n\t\t\tres++;\n\t\t}\n\t}\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n//#include <cstdlib>\n//#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n//#include <limits>\n//#include <sstream>\n//#include <functional>\nusing namespace std;\n\n#define len(array)  (sizeof (array) / sizeof *(array))\n#define rep(i, s, e) for(int i = s;i < e;i++)\n#define rrep(i, e, s) for(int i = e;s <= i;i--)\n#define vrange(v) v.begin(), v.end()\n#define vrrange(v) v.rbegin(), v.rend()\n#define vsort(v) sort(vrange(v))\n#define vrsort(v) sort(vrrange(v))\n#define arange(a) a, a + len(a)\n#define asort(a) sort(arange(a))\n#define arsort(a, t) sort(arange(a), greater<t>())\n#define afill(a, v) fill(arange(a), v)\n#define afill2(a, v, t) fill((t *)a, (t *)(a + len(a)), v)\n#define fmax(a, b) (a < b? b : a)\n#define fmin(a, b) (a > b? b : a)\n#define fabs(a) (a < 0? -a : a)\ntypedef unsigned int ui;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, int> P;\nconst int INF = (int)1e9;\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-10;\n//const int dx[] = {1, -1, 0, 0, 1, -1, -1, 1};\n//const int dy[] = {0, 0, 1, -1, -1, -1, 1, 1};\n//const int weight[] = {0,1,10,100,1000,10000,100000,1000000,10000000};\n//priority_queue<int, vector<int>, greater<int>> q;\ntypedef struct _Node {\n  _Node(int arg1 = 0, int arg2 = 0 , int arg3 = 0) {\n\ti = arg1;\n\tj = arg2;\n\tk = arg3;\n  }\n  int i,j,k;\n  bool operator <(const struct _Node &e) const{\n    return i == e.i? j < e.j : i < e.i;\n  }\n  bool operator >(const struct _Node &e) const{\n    return i == e.i? j > e.j : i > e.i;\n  }\n}node;\n\n#define MAX_SIZE 100002 * 4\n\nll segMax[MAX_SIZE], segAddMax[MAX_SIZE];\n\n//区間[a, b)に値xを加算する.\nvoid addMax(int a, int b, int x, int k, int l, int r)\n{\n  if (r <= a || b <= l) return;\n  if (a <= l && r <= b){\n\tsegAddMax[k] += x;\n\twhile (k){\n\t  k = (k - 1) / 2;\n\t  segMax[k] = fmax(segMax[k * 2 + 1] + segAddMax[k * 2 + 1], segMax[k * 2 + 2] + segAddMax[k * 2 + 2]);\n\t}\n\treturn;\n  }\n\n  addMax(a, b, x, k * 2 + 1, l, (l + r) / 2);\n  addMax(a, b, x, k * 2 + 2, (l + r) / 2, r);\n}\n\nll getMax(int a, int b, int k, int l, int r)\n{\n  if (r <= a || b <= l) return -1;\n  if (a <= l && r <= b) return (segMax[k] + segAddMax[k]);\n  ll left = getMax(a, b, k * 2 + 1, l, (l + r) / 2);\n  ll right = getMax(a, b, k * 2 + 2, (l + r) / 2, r);\n  return (fmax(left, right) + segAddMax[k]);\n}\n\n\n\n\nvoid doIt(){\n  int n, damage[100002], heal[100002];\n  ll h, hp, ans = 0, tmp;\n  priority_queue<P> q;\n  afill(segMax, 0);\n  afill(segAddMax, 0);\n  scanf(\"%d%lld\", &n, &h);\n  n--;\n  //cout << n << \", \" << h << endl;;\n  hp = h;\n  rep(i, 0, n) scanf(\"%d %d\", &damage[i], &heal[i]);\n  //cout << \"end.\" << endl;\n  rep(i, 0, n){\n\t//cout << \"i = \" << i << endl;\n\taddMax(i, i+1, hp, 0, 0, n);\n\tq.push(P(heal[i], i));\n\thp -= damage[i];\n\t//cout << \"i = \" << i << \", damaged hp = \" << hp << endl;\n\twhile(hp <= 0){\n\t  P p = q.top();\n\t  //cout << \"getMax(\" << p.second << \", \" << i+1 << \") = \" << getMax(p.second, i+1, 0, 0, n) << endl;;\n\t  tmp = h - getMax(p.second, i+1, 0, 0, n);\n\t  //cout << \"  tmp = \" << tmp << \"p = \" << p.first << \", \" << p.second << endl;\n\n\t  if(tmp <= 0 || tmp < p.first){\n\t\tq.pop();\n\t\tif(0 < tmp){\n\t\t  p.first = tmp;\n\t\t  q.push(p);\n\t\t}\n\t  }\n\t  else{\n\t\tll t = fabs(hp) / p.first;\n\t\thp += p.first * t;\n\t\t//cout << \"t = \" << t << \", hp = \" << hp << endl;\n\t\t//if(hp <= 0){hp += p.first; t++;}\n\t\tif(t == 0){hp += p.first; t++;}\n\t\tans += t;\n\t\taddMax(p.second, i+1, p.first*t, 0, 0, n);\n\t  }\n\t}\n\t//cout << \"  hp = \" << hp << \", count = \" << ans << endl;\n  }\n  //cout << ans << endl;\n  printf(\"%lld\\n\", ans);\n}\n\nint main() {\n  doIt();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef pair<int,int>P;\nconst int SIZE=1<<17;\n\nstruct seg_tree{\n    int N;\n    vector<int>ma,lazy;\n\n    seg_tree(int n){\n        N=1;\n        while(n>N)N*=2;\n        ma.resize(N*2-1,0);\n        lazy.resize(N*2-1,0);\n    }\n\n    void evaluate(int k){\n        ma[k]+=lazy[k];\n        if(k<N-1){\n            lazy[k*2+1]+=lazy[k];\n            lazy[k*2+2]+=lazy[k];\n        }\n        lazy[k]=0;\n    }\n\n    void update_node(int k){\n        ma[k]=max(ma[k*2+1],ma[k*2+2]);\n    }\n\n    void add(int a,int b,int x){add(a,b,x,0,0,N);}\n    void add(int a,int b,int x,int k,int l,int r){\n        evaluate(k);\n        if(r<=a||b<=l)return;\n        if(a<=l&&r<=b){\n            lazy[k]+=x;\n            evaluate(k);\n            return;\n        }\n        int m=(l+r)/2;\n        add(a,b,x,k*2+1,l,m);\n        add(a,b,x,k*2+2,m,r);\n        update_node(k);\n    }\n\n    int get_max(int a,int b){return get_max(a,b,0,0,N);}\n    int get_max(int a,int b,int k,int l,int r){\n        evaluate(k);\n        if(r<=a||b<=l)return 0;\n        if(a<=l&&r<=b)return ma[k];\n        int m=(l+r)/2;\n        int vl=get_max(a,b,k*2+1,l,m);\n        int vr=get_max(a,b,k*2+2,m,r);\n        return max(vl,vr);\n    }\n};\n\nint N,H;\nint d[100000],h[100000];\n\nsigned main(){\n\n    cin>>N>>H;\n    for(int i=0;i<N-1;i++)cin>>d[i]>>h[i];\n\n    seg_tree seg(N);\n    int cur=H;\n    int ans=0;\n    priority_queue<P>que;\n    for(int i=0;i<N-1;i++){\n        seg.add(i,i+1,cur);\n        cur-=d[i];\n\n        que.push(P(h[i],i));\n\n        while(cur<=0){\n            P p=que.top();que.pop();\n            int ma=seg.get_max(p.second,i+1);\n            if(p.first>H-ma){\n                que.push(P(H-ma,p.second));\n                continue;\n            }\n            int x=min(abs(cur)/p.first+1,(H-ma)/p.first);\n            ans+=x;\n            cur+=x*p.first;\n            seg.add(p.second,i+1,p.first*x);\n            que.push(p);\n        }\n    }\n\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int,pair<int,int> > pp;\npp mm[100001];\nint d[100001];\n\nint main(){\n    int n,h;\n    long long ans=0;\n    cin>>n>>h;\n    int di,hi,ch=h;\n    for(int i=0;i<n-1;++i){\n        cin>>di>>hi;\n        mm[i].first=ch+hi>h ? h-ch:hi;mm[i].second.first=i;mm[i].second.second=ch;\n        d[i]=di;\n        ch -= di;\n    }\n    for(int i=0;i<n;++i){\n        ch=mm[i].second.second;\n        if(ch<=0){\n            pp t=*max_element(mm,mm+i);\n            hi=t.first;\n            int div=-ch/hi+1;ans+=div;\n            i=t.second.first;\n            ch=t.second.second;\n            ch=min(h,ch+hi*div);               \n        }\n        hi=mm[i].first;\n        mm[i].first=ch+hi>h ? h-ch:hi;\n        mm[i].second.second=ch; \n        mm[i+1].second.second= ch-d[i];ch-=d[i];\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int INF=1001001001001001001;\ntypedef pair<int,int>P;\nstruct seg_tree{\n    int N;\n    vector<int>mi,lazy,id;\n\n    void init(int n){\n        N=1;\n        while(n>N)N*=2;\n        mi.resize(N*2-1,0);\n        lazy.resize(N*2-1,0);\n        id.resize(N*2-1,0);\n        for(int i=N-1;i<N*2-1;i++)id[i]=i-N+1;\n    }\n\n    void evaluate(int k){\n        mi[k]+=lazy[k];\n        if(k<N-1){\n            lazy[k*2+1]+=lazy[k];\n            lazy[k*2+2]+=lazy[k];\n        }\n        lazy[k]=0;\n    }\n\n    void update_node(int k){\n        if(mi[k*2+1]<=mi[k*2+2]){\n            mi[k]=mi[k*2+1];\n            id[k]=id[k*2+1];\n        }\n        else{\n            mi[k]=mi[k*2+2];\n            id[k]=id[k*2+2];\n        }\n    }\n\n    void add(int a,int b,int x){\n        add(a,b,x,0,0,N);\n    }\n    void add(int a,int b,int x,int k,int l,int r){\n        evaluate(k);\n        if(r<=a||b<=l)return;\n        if(a<=l&&r<=b){\n            lazy[k]+=x;\n            evaluate(k);\n            return;\n        }\n\n        int m=(l+r)/2;\n        add(a,b,x,k*2+1,l,m);\n        add(a,b,x,k*2+2,m,r);\n        update_node(k);\n    }\n\n    P getMin(int a,int b){\n        return getMin(a,b,0,0,N);\n    }\n    P getMin(int a,int b,int k,int l,int r){\n        evaluate(k);\n        if(r<=a||b<=l)return P(INF,0);\n        if(a<=l&&r<=b)return P(mi[k],id[k]);\n\n        int m=(l+r)/2;\n        P vl=getMin(a,b,k*2+1,l,m);\n        P vr=getMin(a,b,k*2+2,m,r);\n        return min(vl,vr);\n    }\n};\n\nint N,H;\nint d[100000],h[100000];\n\nsigned main(){\n    cin>>N>>H;\n    for(int i=0;i<N-1;i++)cin>>d[i]>>h[i];\n\n    seg_tree seg,latte;\n    seg.init(N);\n    latte.init(N);\n    int ans=0,cur=H;\n    for(int i=0;i<N-1;i++){\n        seg.add(i,i+1,H-cur);\n        latte.add(i,i+1,-h[i]);\n        cur-=d[i];\n        while(cur<=0){\n            int lb=i,ub=-1;\n            while(lb-ub>1){\n                int mid=(ub+lb)/2;\n                if(seg.getMin(mid,i+1).first==0)ub=mid;\n                else lb=mid;\n            }\n            P p=seg.getMin(lb,i+1);\n            int val=min(p.first,-latte.getMin(lb,i+1).first);\n            int cnt=min(abs(cur)/val+1,p.first/val);\n            ans+=cnt;\n            cur+=cnt*val;\n        }\n    }\n\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nconst int INF = 1<<29;\n\ntypedef long long ll;\n\nint N,H;\nll dp[1024][1024];\nint d[1024],h[1024];\n\nint main(){\n  scanf(\"%d%d\",&N,&H);\n  for(int i=0;i<N-1;i++) scanf(\"%d%d\", d+i, h+i);\n  for(int i=0;i<1024;i++) for(int j=0;j<1024;j++) dp[i][j] = INF;\n  dp[0][H] = 0;\n  for(int i=0;i<N-1;i++){\n    //    printf(\"%d %d\\n\", d[i], h[i]);\n    for(int j=1;j<=H;j++){\n      //      printf(\"%d\\n\", j);\n      if(dp[i][j] == INF) continue;\n      int k;\n      for(k=0;j+h[i]*k <= H;k++){\n\tif(j-d[i]+h[i]*k > 0) dp[i+1][j-d[i]+h[i]*k] = min(dp[i+1][j-d[i]+h[i]*k], dp[i][j]+k);\n      }\n      //      printf(\"%d\\n\", k);\n      dp[i+1][H-d[i]] = min(dp[i+1][H-d[i]], dp[i][j]+k);\n    }\n    //    for(int j=1;j<=H;j++) printf(\"%d \", dp[i+1][j]); puts(\"\");\n  }\n\n  ll res = INF;\n  for(int i=1;i<=H;i++) res = min(res,dp[N-1][i]);\n  printf(\"%lld\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int>P;\nconst int SIZE=1<<17;\n\nstruct seg_tree{\n    vector<int>ma,lazy;\n\n    seg_tree():ma(SIZE*2-1),lazy(SIZE*2-1){}\n\n    void evaluate(int k){\n        ma[k]+=lazy[k];\n        if(k<SIZE-1){\n            lazy[k*2+1]+=lazy[k];\n            lazy[k*2+2]+=lazy[k];\n        }\n        lazy[k]=0;\n    }\n    void update_node(int k){\n        ma[k]=max(ma[k*2+1],ma[k*2+2]);\n    }\n\n    void add(int a,int b,int x,int k=0,int l=0,int r=SIZE){\n        evaluate(k);\n        if(r<=a||b<=l)return;\n        if(a<=l&&r<=b){\n            lazy[k]+=x;\n            evaluate(k);\n            return;\n        }\n        int m=(l+r)/2;\n        add(a,b,x,k*2+1,l,m);\n        add(a,b,x,k*2+2,m,r);\n        update_node(k);\n    }\n\n    int get_max(int a,int b,int k=0,int l=0,int r=SIZE){\n        evaluate(k);\n        if(r<=a||b<=l)return 0;\n        if(a<=l&&r<=b)return ma[k];\n        int m=(l+r)/2;\n        int vl=get_max(a,b,k*2+1,l,m);\n        int vr=get_max(a,b,k*2+2,m,r);\n        return max(vl,vr);\n    }\n};\n\nint N,H;\nint d[100000],h[100000];\n\nint main(){\n    cin>>N>>H;\n    for(int i=0;i<N;i++)cin>>d[i]>>h[i];\n\n    seg_tree seg;\n    int cur=H;\n    int ans=0;\n    priority_queue<P>que;\n    for(int i=0;i<N-1;i++){\n        seg.add(i,i+1,cur);\n        cur-=d[i];\n\n        que.push(P(h[i],i));\n\n        while(cur<=0){\n            P p=que.top();que.pop();\n            int ma=seg.get_max(p.second,i+1);\n            if(p.first+ma>H){\n                que.push(P(H-ma,p.second));\n                continue;\n            }\n\n            int x=min((-cur)/p.first+1,(H-ma)/p.first);\n            ans+=x;\n            cur+=x*p.first;\n            seg.add(p.second,i+1,p.first*x);\n        }\n    }\n\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <deque>\n#include <utility>\n#include <algorithm>\nusing namespace std;\nint main() {\n\tlong long int n,total_h,max_h,total_d=0,ans=0;\n\tscanf(\"%lld %lld\",&n,&total_h);\n\tmax_h=total_h;\n\tdeque<pair<long long int,long long int> > Q;\n\tfor(int i=0;i<n-1;i++) {\n\t\tlong long int d,h;\n\t\tscanf(\"%lld %lld\",&d,&h);\n\t\twhile(!Q.empty()&&Q.front().first<=h)\n\t\t\tQ.pop_front();\n\t\tQ.push_back(make_pair(h,total_d));\n\t\ttotal_d+=d;\n\t\twhile(total_h<=total_d) {\n\t\t\tlong long int tmp_h=total_h;\n\t\t\twhile(!Q.empty()&&tmp_h+Q.front().first-Q.front().second>max_h) {\n\t\t\t\ttotal_h=max(total_h,Q.front().second+max_h);\n\t\t\t\tQ.pop_front();\n\t\t\t}\n\t\t\tif(!Q.empty()) {\n\t\t\t\ttotal_h=max(total_h,tmp_h+Q.front().first);\n\t\t\t\tlong long int tmp=max(0LL,min((total_d-total_h)/Q.front().first,(Q.front().second+max_h-total_h)/Q.front().first));\n\t\t\t\tans+=tmp;\n\t\t\t\ttotal_h+=tmp*Q.front().first;\n\t\t\t}\n\t\t\tans++;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#define MYDEBUG\n#include <bits/stdc++.h>\n\n#ifdef MYDEBUG\n#define dbp(x) cout<<#x<<\": \"<<x<<endl\n#define dbp2(x,y) cout<<#x<<\",\"<<#y<<\": \"<<x<<\",\"<<y<<endl\n#define dbp3(x,y,z) cout<<#x<<\",\"<<#y<<\",\"<<#z<<\": \"<<x<<\",\"<<y<<\",\"<<z<<endl\n#define dbp4(w,x,y,z) cout<<#w<<\",\"<<#x<<\",\"<<#y<<\",\"<<#z<<\": \"<<w<<\",\"<<x<<\",\"<<y<<\",\"<<z<<endl\n#define ifcin(x) std::ifstream cin(x)\n#else\n#define dbp(x)\n#define dbp2(x,y)\n#define dbp3(x,y,z)\n#define dbp4(w,x,y,z)\n#define ifcin(x)\n#endif\n#define ll long long\n#define ull unsigned long long\n#define all(x) x.begin(), x.end()\n#define rep(i, from, to) for(int i=from; i<to; ++i)\n#define REP(i, from, to) for(int i=from; i<=to; ++i)\nusing std::vector;\nusing std::cout;\nusing std::cin;\nusing std::endl;\nusing std::max;\nusing std::min;\nusing std::swap;\nusing std::string;\nusing std::fill;\nusing std::pair;\nusing std::sort;\nusing std::reverse;\nusing std::pair;\nusing std::priority_queue;\nusing std::ostream;\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<vector<T> >& v) {\n\tfor (size_t i = 0; i < v.size(); ++i) {\n\t\tout << v[i] << endl;\n\t}\n\treturn out;\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<T>& v) {\n\tout << \"[\";\n\tsize_t last = v.size() - 1;\n\tfor (size_t i = 0; i < v.size(); ++i) {\n\t\tout << v[i];\n\t\tif (i != last) {\n\t\t\tout << \",\";\n\t\t}\n\t}\n\tout << \"]\";\n\treturn out;\n}\n\nll N, H;\nll hp, maxi, heal, ans, rest;\nvoid solve() {\n\tifcin(\"/storage/emulated/0/AppProjects/xmas/jni/in.txt\");\n\tcin >> N >> H;\n\thp = H;\n\tans = 0;\n\tll d, h;\n\tcin >> d >> h;\n\tmaxi = h;\n\trep(i,0,N-1){\n\t\thp -= d;\n\t\tcin >> d >> h;\n\t\trest = hp - d;\n\t\tif(rest <= 0){\n\t\t\theal = (abs(rest) + maxi) / maxi;\n\t\t\thp += heal * maxi;\n\t\t\thp = min(hp, H);\n\t\t\tans += heal;\n\t\t}\n\t\tmaxi = max(maxi, h);\n\t\tdbp4(hp, maxi, heal, ans);\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "/*\n    明日からパソコン触りません(誓い)\n */\n\n#include <cstdio>\n#include <queue>\n\nusing namespace std;\n\n#define INF 0x7fffffff\n\nint N;\nint H;\nint size;\nlong long int ans;\npair<int, int> maxtree[262144];\nint addtree[262144];\nint lifes[100000];\n\nvoid add(int wishl, int wishr, int k, int watchl, int watchr, int x) {\n    int mid;\n\n    if (watchr <= wishl || wishr <= watchl) return ;\n    if (wishl <= watchl && watchr <= wishr) {\n        addtree[k] += x;\n        while (k > 0) {\n            int l, r;\n            pair<int, int> lval, rval;\n\n            k = (k-1)/2;\n            l = k*2+1;\n            r = k*2+2;\n            lval = maxtree[l];\n            rval = maxtree[r];\n            lval.first += addtree[l];\n            rval.first += addtree[r];\n            maxtree[k] = max(lval, rval);\n        }\n        return ;\n    }\n\n    mid = (watchl+watchr)/2;\n    add(wishl, wishr, k*2+1, watchl, mid, x);\n    add(wishl, wishr, k*2+2, mid, watchr, x);\n}\n\npair<int, int> get_max(int wishl, int wishr, int k, int watchl, int watchr) {\n    int mid;\n    pair<int, int> lval, rval, ret;\n\n    if (watchr <= wishl || wishr <= watchl) return make_pair(-INF, -INF);\n    if (wishl <= watchl && watchr <= wishr) {\n        ret = maxtree[k];\n        ret.first += addtree[k];\n        return ret;\n    }\n\n    mid = (watchl+watchr)/2;\n    lval = get_max(wishl, wishr, k*2+1, watchl, mid);\n    rval = get_max(wishl, wishr, k*2+2, mid, watchr);\n    ret = max(lval, rval);\n    ret.first += addtree[k];\n    return ret;\n}\n\nint main() {\n    int life;\n    int last;\n\n    scanf(\"%d %d\", &N, &H);\n    size = 1;\n    while (size < N) size *= 2;\n    for (int i=0; i<N; i++) {\n        maxtree[i+size-1].second = i;\n    }\n\n    life = H;\n    last = 0;\n    for (int i=0; i<N-1; i++) {\n        int d, h;\n\n        scanf(\"%d %d\", &d, &h);\n        add(i, i+1, 0, 0, size, min(H-life, h));\n        lifes[i] = life;\n        life -= d;\n        while (life <= 0) {\n            pair<int, int> p = get_max(last, i+1, 0, 0, size);\n            int cure = p.first;\n            int lim = H-lifes[p.second];\n            ans += lim/cure + (lim%cure != 0);\n            add(p.second, i+1, 0, 0, size, -lim);\n            life += lim;\n            last = p.second;\n        }\n    }\n\n    printf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<map>\n#define INF 20000000\nusing namespace std;\ntypedef pair<int,int> P;\nint d[100000];\nint p[100000];\nP deq[200000];\nint max(int a,int b){return a>b?a:b;}\nint min(int a,int b){return a<b?a:b;}\nint ceil(int a,int b){\n\tif(a%b==0)return a/b;\n\telse return a/b+1;\n}\nint main(){\n\tint n,mh;\n\tint i;\n\tscanf(\"%d %d\",&n,&mh);\n\tfor(i=0;i<n-1;i++)scanf(\"%d %d\",&d[i],&p[i]);\n\tlong long ans=0;\n\tint l=0,r=0;\n\tint s=0,t=0;\n\tint lim=0;\n\tint h=mh;\n\twhile(r<n-1){\n\t\twhile(s<t&&deq[t-1].first<=p[r])t--;\n\t\tdeq[t++]=P(p[r],r);\n\t\twhile(h<=d[r]){\n\t\t\twhile(min(lim,p[l])<deq[s].first){\n\t\t\t\tlim+=d[l++];\n\t\t\t\twhile(s<t&&deq[s].second<=l)s++;\n\t\t\t}\n\t\t\tint rec=d[r]-h+1;\n\t\t\tint a=ceil(rec,p[l]);\n\t\t\tint b=ceil(lim,p[l]);\n\t\t\tint c=min(a,b);\n\t\t\tans+=c;\n\t\t\tint add=c*p[l];\n\t\t\tif(add>lim)add=lim;\n\t\t\tlim-=add;\n\t\t\th+=add;\n\t\t}\n\t\th-=d[r];\n\t\tr++;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nconst int U = 100004;\ntypedef long long int ll;\ntypedef pair<ll,ll> PLL;\nll n,hp,d,h,maxhp,damage,ans;\ndeque<PLL> izumi;\nint main(){\n\tscanf(\"%lld%lld\",&n,&hp);\n\tmaxhp = hp;\n\tfor(int i = 0;i < n-1;i++){\n\t\tscanf(\"%lld%lld\",&d,&h);\n\t\twhile(!izumi.empty() && izumi.back().first < h){\n\t\t\tizumi.pop_back();\n\t\t}\n\t\tizumi.push_back(PLL(h,damage));\n\t\tdamage += d;\n\t\twhile(hp <= damage){\n\t\t\tll tmphp = hp;\n\t\t\twhile(!izumi.empty() &&\n\t\t\ttmphp + izumi.front().first - izumi.front().second > maxhp){\n\t\t\t\thp = max(hp,izumi.front().second + maxhp);\n\t\t\t\tizumi.pop_front();\n\t\t\t}\n\t\t\tif(!izumi.empty()){\n\t\t\t\thp = max(hp,tmphp + izumi.front().first);\n\t\t\t\tint tmp = max(0ll,min((damage-hp)/izumi.front().first,\n\t\t\t\t(izumi.front().second + maxhp - hp ) / izumi.front().first));\n\t\t\t\tans += tmp;\n\t\t\t\thp += tmp * izumi.front().first;\n\t\t\t}\n\t\t\tans++;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,pair<ll,ll> > pp;\npp mm[100001];\nll d[100001];\n\nint main(){\n    ll n,h;\n    ll ans=0;\n    cin>>n>>h;\n    ll di,hi,ch=h;\n    for(int i=0;i<n-1;++i){\n        cin>>di>>hi;\n        mm[i].first=ch+hi<=h||ch<0 ? hi:h-ch;mm[i].second.first=i;mm[i].second.second=ch;\n        d[i]=di;\n        ch -= di;\n    }\n    int l=0;\n    for(int i=0;i<n;++i){\n        ch=mm[i].second.second;\n        if(ch<=0){\n            pp t=*max_element(mm+l,mm+i);\n            hi=t.first;\n            int ch2=t.second.second;\n            i=t.second.first;l=i;\n            int dv;\n            if(-ch/hi+1>(h-ch2)/hi){\n                dv=(h-ch2)/hi;\n                ans+=dv;\n                ch=ch2+hi*dv;\n            } \n            else{\n                dv=-ch/hi+1;\n                ans+=dv;\n                ch=min(h,ch2+hi*dv); \n            }             \n        }\n        hi=mm[i].first;\n        mm[i].first=ch+hi>h ? h-ch:hi;\n        mm[i].second.second=ch; \n        mm[i+1].second.second= ch-d[i];\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n\nint N,H,d[100000],h[100000],sum[100000];\nsigned main(){\n    scanf(\"%lld%lld\",&N,&H);\n    rep(i,N-1)scanf(\"%lld%lld\",&d[i],&h[i]);\n\n    sum[0]=H;\n    rep(i,N-1)sum[i+1]=sum[i]-d[i];\n    int D=0;\n\n    int ans=0,idx=0;\n    deque<int>deq;\n    rep(i,N-1){\n\n        if(H-(sum[i]-D)<=h[i]){\n            deq.clear();\n            idx=i;\n        }\n        else{\n            while(deq.size()&&h[deq.back()]<=h[i])deq.pop_back();\n            deq.push_back(i);\n        }\n\n        while(sum[i+1]-D<=0){\n            if(deq.size()&&H-(sum[idx]-D)<=h[deq.front()]){\n                int j=deq.front();\n                int t=min((H-(sum[j]-D))/h[j],(D-sum[i+1])/h[j]+1);\n                ans+=t;\n                D-=t*h[j];\n            }\n            else{\n                ans++;\n                D-=H-(sum[idx]-D);\n            }\n            while(deq.size()&&H-(sum[deq.front()]-D)<h[deq.front()]){\n                    idx=deq.front();\n                    deq.pop_front();\n            }\n        }\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <assert.h>\n#define N_MAX (100000)\n#define min(a,b) (((a)<(b))?(a):(b))\ntypedef struct {\n\tint pos,value;\n} Info;\n\nsigned main(){\n\tlong long damage_total[N_MAX]={};\n\tInfo deque[N_MAX];\n\tint head=0,tail=0;\n\tint N,H;\n\tlong long answer = 0;\n\n\tscanf(\"%d%d\",&N,&H);\t\n\tint currentHP = H;\n\tfor(int i = 0 ; i < N-1 ; i++){\n\t\tint d,h;\n\t\tscanf(\"%d%d\",&d,&h);\n\t\twhile( head != tail && deque[tail-1].value <= h ) tail--;\n\n\t\tdeque[tail++] = (Info){i,h};\n\t\t/*while( head != tail ){\n\t\t\tint maximumRecover = H - (damage_total[i] - damage_total[deque[head].pos]);\n\t\t\tif( maximumRecover > 0 ) break;\n\t\t\thead++;\n\t\t}*/\n\n\t\tfor(int j = head ; j < tail && currentHP <= d ; j++){\n\t\t\t// ????????§???????????§????????????\n\t\t\tlong long maximumRecover = H - (damage_total[i] - damage_total[deque[j].pos]);\n\t\t\tif( maximumRecover > 0 ) continue;\n\t\t\t// ??¨???????????§????????????????£???°???\n\t\t\tif( maximumRecover <= currentHP) continue;\n\n\t\t\t// j??????????????§?????????????????? needRecover ????¨????\n\t\t\tint needRecover = min( maximumRecover - currentHP , d - currentHP + 1);  \n\t\t\t// ???????????? needRecover ?????????????????????????????° useCount ????±????????????????????????????\n\t\t\tint useCount = (needRecover+deque[j].value-1) / deque[j].value - 1;\n\t\t\tanswer += useCount;\n\t\t\tcurrentHP += useCount*deque[j].value;\n\n\t\t\t// ???j?????????????????§????°???????????????????j????????£?????´?????¨???j+1????????£?????´?????????????????????j+1????????£????????????????????????j?????????????????????\n\t\t\t// ??¨) ???????????¶???????????\\??£?????????????????¨???????????? currentHP > d ???????????????\n\t\t\tif( j+1 ==  tail || maximumRecover > currentHP + deque[j+1].value ){\n\t\t\t\tcurrentHP = min(currentHP+deque[j].value,maximumRecover);\n\t\t\t\tanswer++;\n\t\t\t}\n\t\t}\n\t\tcurrentHP -= d;\n\t\tdamage_total[i+1] = damage_total[i] + d;\n\t}\n\tprintf(\"%lld\\n\",answer);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\n#define int long long\n\nconst int MAX_N = 100010;\n\nclass segTree{\n    public:\n        int n, dat[4 * MAX_N];\n        void init(int n_, int value, int dat_b[4 * MAX_N] = NULL){\n            n = 1;\n            while(n < n_) n *= 2;\n            rep(i,2 * n){\n                dat[i] = value;\n                if(dat_b != NULL) dat_b[i] = value;\n            }\n        }\n        void output(int a[4 * MAX_N]){\n            show(\"print\");\n            range(i,1,n * 2) cout << (a[i] == INT_MAX ? 0 : a[i]) << ' ';\n            cout << endl;\n        }\n};\n\nclass starrySky : public segTree{\n    private:\n        int query(int a, int b, int k, int l, int r){\n            if(b <= l || r <= a) return 0;\n            if(a <= l && r <= b) return dat[k] + dat_add[k];\n\n            int vl = query(a, b, k * 2, l, (l + r) / 2);\n            int vr = query(a, b, k * 2 + 1, (l + r) / 2, r);\n            return max(vl, vr) + dat_add[k];\n        }\n        void add(int a, int b, int k, int l, int r, int x){\n            if(b <= l || r <= a) return;\n            if(a <= l && r <= b){\n                dat_add[k] += x;\n            }else{\n                add(a, b, k * 2, l, (l + r) / 2, x);\n                add(a, b, k * 2 + 1, (l + r) / 2, r, x);\n                dat[k] = max(dat[k * 2] + dat_add[k * 2], dat[k * 2 + 1] + dat_add[k * 2 + 1]);\n            }\n        }\n        void init(int n_){ segTree::init(n_,0,dat_add); }\n    public:\n        int dat_add[4 * MAX_N];\n        starrySky(int n){ init(n); }\n        int query(int a, int b){ return query(a, b, 1, 0, n); }\n        void add(int s, int t, int x){ add(s, t, 1, 0, n, x); }\n        void add(int i, int x){ add(i, i + 1, 1, 0, n, x); }\n};\n\n\nsigned main(){\n    long long n, h;\n    cin >> n >> h;\n\n\n    starrySky seg(n); //?????????????????????\n    priority_queue<pair<long long, int>> q; //??????????????????pos\n    long long cur = h, ans = 0;\n    rep(i,n - 1){\n        long long damage, heal;\n        cin >> damage >> heal;\n        q.push(make_pair(heal, i));\n\n        seg.add(i + 1, cur);\n        cur -= damage;\n        while(cur <= 0){\n            pair<long long, int> use = q.top(); q.pop();\n            long long maxHP = seg.query(use.second + 1, i + 2); //????????°??????????????¨??°?????§?????????????????§\n\n            if(maxHP + use.first > h){ //??????????????????????¶????????????§?????????????????????????????´\n                q.push(make_pair(h - maxHP, use.second));\n                continue;\n            }\n\n            long long can_use = (h - maxHP) / use.first;\n            long long require = ceil((-1.0 * cur + 1) / use.first);\n            long long used = min(can_use, require);\n            ans += used;\n            cur += used * use.first;\n\n            seg.add(use.second + 1, i + 2, used * use.first);\n            q.push(use);\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  ll N, maxHp;\n  while (cin >> N >> maxHp) {\n    vector<ll> totalDamage(N);\n    ll totalHealing = 0, answer = 0;\n    priority_queue<pair<ll, int>> Q;\n    int maxIndex = 0;\n\n    for (int i = 0; i < N - 1; ++i) {\n      ll damage, healing;\n      cin >> damage >> healing;\n      totalDamage[i + 1] = totalDamage[i] + damage;\n      Q.push({min(healing, totalDamage[i] - totalHealing), i});\n\n      ll necessaryHealing = max(0LL, totalDamage[i + 1] - totalHealing - maxHp + 1);\n      while (necessaryHealing > 0) {\n        ll healing = Q.top().first;\n        int index = Q.top().second;\n        Q.pop();\n\n        if (index < maxIndex) continue;\n        maxIndex = index;\n\n        ll netDamage = totalDamage[index] - totalHealing;\n        ll times = (necessaryHealing + healing - 1) / healing;\n        if (netDamage - healing * times < 0) --times;\n        answer += times;\n        necessaryHealing -= healing * times;\n        netDamage -= healing * times;\n        totalHealing += healing * times;\n        if (netDamage > 0) Q.push({netDamage, index});\n      }\n    }\n    cout << answer << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//Bokan ga bokka--nn!!\n//Daily Lunch Special Tanoshii !!\n//これは、頭が悪く競プロが世界で一番できないHIR180が\n//IOI2014日本代表になるまでのN日間の記録である。\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\ntypedef long long ll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\n#define f first\n#define s second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SIZE (1<<17)\nll out[100005],got[100005];\nstruct segtree\n{\n\tll seg[SIZE*2];\n\tll lazy[SIZE*2];\n\tvoid lazy_evaluate(int k)\n\t{\n\t\tseg[k*2+1]+=lazy[k];\n\t\tseg[k*2+2]+=lazy[k];\n\t\tlazy[k*2+1]+=lazy[k];\n\t\tlazy[k*2+2]+=lazy[k];\n\t\tlazy[k]=0;\n\t}\n\tll update(int a,int b,int k,int l,int r,ll num)\n\t{\n\t\tif(lazy[k] && l!=r) lazy_evaluate(k);\n\t\tif(b<l || r<a) return seg[k];\n\t\tif(a<=l && r<=b)\n\t\t{\n\t\t\tseg[k]+=num;\n\t\t\tlazy[k]+=num;\n\t\t\treturn seg[k];\n\t\t}\n\t\treturn seg[k]=max(update(a,b,k*2+1,l,(l+r)/2,num),update(a,b,k*2+2,(l+r)/2+1,r,num));\n\t}\n\tll query(int a,int b,int k,int l,int r)\n\t{\n\t\tif(lazy[k] && l!=r) lazy_evaluate(k);\n\t\tif(b<l || r<a) return -1LL*INF;\n\t\tif(a<=l && r<=b)\n\t\t{\n\t\t\treturn seg[k];\n\t\t}\n\t\treturn max(query(a,b,k*2+1,l,(l+r)/2),query(a,b,k*2+2,(l+r)/2+1,r));\n\t}\n}seg;\nint main()\n{\n\tsrand((unsigned int)time(NULL));\n\tint n; ll maxv; scanf(\"%d %lld\",&n,&maxv);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tscanf(\"%lld %lld\",&out[i],&got[i]);\n\t}\n\tseg.update(0,SIZE-1,0,0,SIZE-1,maxv);\n\tll ret=0;\n\tpriority_queue<P>que;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tll cur=seg.query(i,i,0,0,SIZE-1);\n\t\tque.push(mp(got[i],i));\n\t\twhile(cur<=out[i]&&!que.empty())\n\t\t{\n\t\t\t//cout << ret << \" \"  << i << \" \" << cur << endl;\n\t\t\tint id=que.top().s;\n\t\t\tll gott=que.top().f;\n\t\t\tll recov,upper;\n\t\t\trecov=(out[i]-cur)/gott+1;\n\t\t\tupper=(maxv-seg.query(id,i,0,0,SIZE-1))/gott;\n\t\t\tif(recov<=upper)\n\t\t\t{\n\t\t\t\tseg.update(id,SIZE-1,0,0,SIZE-1,recov*gott);\n\t\t\t\tcur+=recov*gott; ret+=recov;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tseg.update(id,SIZE-1,0,0,SIZE-1,upper*gott);\n\t\t\t\tque.pop();\n\t\t\t\tif(maxv-seg.query(id,i,0,0,SIZE-1)>0) que.push(mp(maxv-seg.query(id,i,0,0,SIZE-1),id));\n\t\t\t\tret+=upper; cur+=upper*gott;\n\t\t\t}\n\t\t}\n\t\tseg.update(i+1,SIZE-1,0,0,SIZE-1,-1LL*out[i]);\n\t}\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "/*\n    kagamizは神\n */ \n\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\n#define INF 0x7fffffff\ntypedef pair<int, int> Pair;\nint N;\nint H;\nint size;\nint life;\nlong long int ans;\nint lifetree[262144];\nint addtree[262144];\nint d[100000];\nint h[100000];\npriority_queue<Pair> cures;\n\nvoid add(int wishl, int wishr, int k, int watchl, int watchr, int x) {\n    int mid;\n\n    if (watchr <= wishl || wishr <= watchl) return;\n    if (wishl <= watchl && watchr <= wishr) {\n        addtree[k] += x;\n        while (k > 0) {\n            k = (k-1)/2;\n            lifetree[k] = min(lifetree[k*2+1]+addtree[k*2+1], lifetree[k*2+2]+addtree[k*2+2]);\n        }\n        return;\n    }\n\n    mid = (watchl+watchr)/2;\n    add(wishl, wishr, k*2+1, watchl, mid, x);\n    add(wishl, wishr, k*2+2, mid, watchr, x);\n}\n\nint get_min(int wishl, int wishr, int k, int watchl, int watchr) {\n    int mid;\n    int lval, rval;\n\n    if (watchr <= wishl || wishr <= watchl) return INF;\n    if (wishl <= watchl && watchr <= wishr) return lifetree[k]+addtree[k];\n\n    mid = (watchl+watchr)/2;\n    lval = get_min(wishl, wishr, k*2+1, watchl, mid);\n    rval = get_min(wishl, wishr, k*2+2, mid, watchr);\n    return min(lval, rval) + addtree[k];\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &H);\n    size = 1;\n    while(size < N) size *= 2;\n\n    life = H;\n    for (int i=0; i<N-1; i++) {\n        scanf(\"%d %d\", &d[i], &h[i]);\n\n        add(i, i+1, 0, 0, size, life);\n        cures.push(Pair(h[i], i));\n\n        life -= d[i];\n        while (life < 0) {\n            Pair p = cures.top(); cures.pop();\n            int val = p.first;\n            int idx = p.second;\n            int at_life = get_min(idx, idx+1, 0, 0, size);\n            int diff = H-at_life;\n\n            if (diff < val) {\n                cures.push(Pair(diff, idx));\n                continue;\n            }\n\n            add(idx, i+1, 0, 0, size, diff);\n            ans += diff/val + (diff%val != 0);\n            life += diff;\n        }\n    }\n\n    printf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\n//typedef pair<ll,ll> P;\n\n#define rep(i,n) for(ll (i)=0;(i)<(n);++i)\n\n#define rep1(i,n) for(ll (i)=1;(i)<=(n);++i)\n\n#define rrep(i,n) for(ll (i)=(n)-1;(i)>=(0);--i)\n\n#define rrep1(i,n) for(ll (i)=(n);(i)>=(1);--i)\n\n#define pb push_back\n\n#define fr first\n\n#define sc second\n\nconst ll INF=0xfffffffffffff;\nconst ll inf=0xfffffff;\nconst ll SIZE=1<<17;\nstruct P{\n\tll h,id,j;\n\tbool operator<(const P& an)const{\n\t\tif(h!=an.h) return h<an.h;\n\t\tif(id!=an.id) return id>an.id;\n\t\treturn j<an.j;\n\t}\n\tbool operator>(const P& an)const{\n\t\tif(h!=an.h) return h>an.h;\n\t\tif(id!=an.id) return id<an.id;\n\t\treturn j>an.j;\n\t}\n};\nll N,HP;\nll pos;\nll H[SIZE],D[SIZE];\nP dat[SIZE*2-1];\nll lazy[SIZE*2-1];\n\nP init(ll k){\n\tlazy[k]=0;\n\tif(SIZE-1<=k){\n\t\treturn dat[k]=P{H[k-SIZE+1],k-SIZE+1,HP};\n\t}\n\treturn dat[k]=max(init(k*2+1),init(k*2+2));\n}\n\nvoid lazy_ev(ll k){\n\tif(lazy[k]==0) return;\n\tdat[k].j+=lazy[k];\n\tif(k>=SIZE-1){\n\t\tdat[k].h=min(dat[k].h,dat[k].j);\t\t\n\t}\n\telse{\n\t\tdat[k].h=min(dat[k].h,dat[k].j);\n\t\tlazy[k*2+1]=lazy[k*2+2]=lazy[k];\n\t}\n\tlazy[k]=0;\n\treturn;\n}\n\nP query(ll a,ll b,ll k,ll l,ll r){//???????????§?????¨index\n\tlazy_ev(k);\n\tif(r<=a||b<=l) return P{-INF,-1,-INF};\n\tif(a<=l&&r<=b) return dat[k];\n\treturn max(query(a,b,k*2+1,l,(l+r)/2),query(a,b,k*2+2,(l+r)/2,r));\n}\n\nP update(ll a,ll b,ll val,ll k,ll l,ll r){\n\tlazy_ev(k);\n\tif(b<=l||r<=a) return dat[k];\n\tif(a<=l&&r<=b){\n\t\tlazy[k]=val;\n\t\tlazy_ev(k);\n\t}\n\telse{\n\t\tdat[k]=max(update(a,b,val,k*2+1,l,(l+r)/2),update(a,b,val,k*2+2,(l+r)/2,r));\n\t}\n\treturn dat[k];\n}\n\n\nll ans=0;\nll l=0;\n\nint main()\n\n{\n\n\tcin>>N>>HP;\n\trep(i,SIZE) H[i]=-INF;\n\trep(i,N-1){\n\t\tcin>>D[i]>>H[i];\n\t}\n\tinit(0);\n\tpos=HP;\n\tll z;\n\trep(i,N-1){\n\t\tupdate(i,i+1,-pos,0,0,SIZE);\n\t\twhile(pos-D[i]<=0){\n\t\t\tP p=query(l,i+1,0,0,SIZE);\n\t\t\tif(p.h==p.j){\n\t\t\t\tpos+=p.h;\n\t\t\t\tans++;\n\t\t\t\tupdate(p.id,i+1,-p.h,0,0,SIZE);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tz=p.j/p.h;\n\t\t\t\tpos+=p.h*z;\n\t\t\t\tans+=z;\n\t\t\t\tupdate(p.id,i+1,-p.h*z,0,0,SIZE);\n\t\t\t}\t\n\t\t\tl=p.id;\n\t\t}\n\t\tpos-=D[i];\n\t}\n\tcout<<ans<<endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n \n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)x.size())\n \nusing namespace std;\n \nstruct timer{\n    time_t start;\n    timer(){start=clock();}\n    ~timer(){cerr<<1.*(clock()-start)/CLOCKS_PER_SEC<<\" secs\"<<endl;}\n};\n \ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n \nll N,H,d[100010],h[100010],sumd[100010];\n \nstruct segtree{\n    ll x;\n    int l,r;\n    segtree *cl,*cr;\n     \n    segtree(int l,int r): l(l),r(r){\n        if(l+1==r){\n            x=h[l];\n            return;\n        }\n        cl=new segtree(l,l+r>>1);\n        cr=new segtree(l+r>>1,r);\n        x=max(cl->x,cr->x);\n    }\n     \n    void change(int pos,ll v){\n        if(pos<l || r<=pos){\n            return;\n        }\n        if(l+1==r){\n            x=v;\n            return;\n        }\n        cl->change(pos,v);\n        cr->change(pos,v);\n        x=max(cl->x,cr->x);\n    }\n     \n    ll query(int L,int R,int& ind){\n        if(R<=l || r<=L){\n            return -INF*INF;\n        }\n        if(l+1==r){\n            ind=l;\n            return x;\n        }\n        int ind1,ind2;\n        ll res1 = cl->query(L,R,ind1);\n        ll res2 = cr->query(L,R,ind2);\n        if(res1 >= res2){\n            ind=ind1;\n            return res1;\n        }\n        ind=ind2;\n        return res2;\n    }\n} *root;\n \nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n     \n    cin>>N>>H;\n    rep(i,N-1){\n        cin>>d[i]>>h[i];\n        sumd[i+1]=sumd[i]+d[i];\n    }\n    root=new segtree(0,N-1);\n    ll ans=0,hp=H,from=0;\n    rep(i,N-1){\n        hp-=d[i];\n        //cout<<hp<<\" \"<<ans<<\" \"<<from<<endl;\n        while(hp<=0){\n            ll need=1-hp;\n            int ind;\n            ll maxi=root->query(from,i+1,ind);\n            from=ind;\n            ll HPpre=hp+sumd[i+1]-sumd[ind];\n            //cout<<hp<<\" \"<<HPpre<<endl;\n            //cout<<from<<\" - \"<<i<<\" : \"<<maxi<<\"(\"<<ind<<\")\"<<endl;\n            ll maxtime=(H-HPpre)/maxi;\n            ll want=(need+maxi-1)/maxi;\n            //cout<<maxtime<<\" \"<<want<<endl;\n            if(want <= maxtime){\n                ans+=want;\n                hp+=want*maxi;\n                break;\n            }else{\n                ll rest=(H-HPpre)%maxi;\n                if(rest==0)from++;\n                else root->change(ind,rest);\n                ans+=maxtime;\n                hp+=maxtime*maxi;\n            }\n        }\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n  long long int n, h, d, hp, maxhp, damage = 0, ans = 0;\n  deque<pair<long long int, long long int> > izumi;\n  scanf(\"%lld%lld\", &n, &hp);\n  maxhp = hp;\n  for(int i = 0;i < n - 1;i++){\n    scanf(\"%lld%lld\", &d, &h);\n    damage += d;\n    while(hp <= damage){\n      hp += izumi.front().first;\n      ans++;\n      if(hp - izumi.front().second > maxhp){\n\tizumi.pop_front();\n      }\n    }\n    while(!izumi.empty() && izumi.back().first < h){\n      izumi.pop_back();\n    }\n    izumi.push_back(make_pair(h, damage));\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\nstruct Starry_Sky_Tree\n{\n\tint data[(1<<19)-1],datb[(1<<19)-1];//data:add,datb:max\n\tStarry_Sky_Tree()\n\t{\n\t\tmemset(data,0,sizeof(data));\n\t\tmemset(datb,0,sizeof(datb));\n\t}\n\tvoid update(int a,int b,int x,int k,int l,int r)\n\t{\n\t\tif(a>=r||l>=b)return;\n\t\telse if(a<=l&&r<=b)\n\t\t{\n\t\t\tdata[k]+=x;\n\t\t\twhile(k>0)\n\t\t\t{\n\t\t\t\tk=(k-1)/2;\n\t\t\t\tdatb[k]=max(data[k*2+1]+datb[k*2+1],data[k*2+2]+datb[k*2+2]);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tupdate(a,b,x,k*2+1,l,(l+r)/2);\n\t\t\tupdate(a,b,x,k*2+2,(l+r)/2,r);\n\t\t}\n\t}\n\tint query(int a,int b,int k,int l,int r)\n\t{\n\t\tif(a>=r||l>=b)return 0;\n\t\tif(a<=l&&r<=b)return data[k]+datb[k];\n\t\telse return max(query(a,b,k*2+1,l,(l+r)/2),query(a,b,k*2+2,(l+r)/2,r));\n\t}\n};\nStarry_Sky_Tree sst;\nP a[100000];\nint N,H;\nint main()\n{\n\tcin >> N >> H;\n\tfor(int i=0;i<N-1;i++)cin >> a[i].fi >> a[i].sec;\n\tpriority_queue<P> q;//fi num,sec index\n\tint now=H;\n\tll ans=0ll;\n\tfor(int i=0;i<N-1;i++)\n\t{\n\t\tsst.update(i,i+1,now,0,0,1<<18);\n\t\tnow-=a[i].fi;\n\t\tq.push(P(a[i].sec,i));\n\t\twhile(now<=0)\n\t\t{\n\t\t\t//loop:;\n\t\t\tP m=q.top();\n\t\t\tq.pop();\n\t\t\tint mx=sst.query(m.sec,i+1,0,0,1<<18);\n\t\t\tif(mx+m.fi>H)\n\t\t\t{\n\t\t\t\tm.fi=H-mx;\n\t\t\t\tq.push(m);\n\t\t\t\t//goto loop;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint num=min((-now)/m.fi+1,(H-mx)/m.fi);\n\t\t\tans+=(ll)num;\n\t\t\tnow+=num*m.fi;\n\t\t\tsst.update(m.sec,i+1,num*m.fi,0,0,1<<18);\n\t\t\tq.push(m);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nconst int MAX_N = 100001*2;\n\nstruct SegMax {\n  int data[MAX_N * 2 - 1];\n  int datb[MAX_N * 2 - 1];\n  int n;\n  SegMax(int n) : n(n) {\n    REP(i,n) data[i]=datb[i]=0;\n  }\n  void add(int a, int b, int x) {\n    add(a,b,x,0,0,n);\n  }\n  void add(int a, int b, int x, int k, int l, int r) {\n    if (a <= l && r <= b) data[k] += x;\n    else if (l<b && a<r) {\n      datb[k] = max(datb[k], x);\n      add(a, b, x, k*2+1, l, (l+r)/2);\n      add(a, b, x, k*2+2, (l+r)/2, r);\n    }\n  }\n  int getmax(int a, int b) {\n    return getmax(a,b,0,0,n);\n  }\n  int getmax(int a, int b, int k, int l, int r) {\n    if (b<=l || r<=a) return 0;\n    else if (a<=l && r<=b) {\n      return data[k] + datb[k];\n    } else {\n      int res = 0;\n      res = max(res, getmax(a, b, k*2+1, l, (l+r)/2));\n      res = max(res, getmax(a, b, k*2+2, (l+r)/2, r));\n      return res + data[k];\n    }\n  }\n};\n\nint di[100000];\nint hi[100000];\n\nint main() {\n  int N, H;\n  cin >> N >> H;\n  REP(i,N-1) {\n    scanf(\"%d%d\",di+i,hi+i);\n  }\n  SegMax st(N);\n  priority_queue<pii> Q;\n  int now = H;\n  ll ans = 0;\n  REP(i,N-1) {\n    st.add(i,i+1,now);\n    Q.push(pii(hi[i], i));\n    now -= di[i];\n    // cout << i << \" ; \" << now << endl;\n    while(now<=0) {\n      pii p = Q.top(); Q.pop();\n      int heal = p.first;\n      int pos = p.second;\n      // cout << \"(pos,heal) = \" << pos << \",\" << heal << endl;\n      int smax = st.getmax(pos, i+1);\n      // cout << \"segmax = \" << smax << endl;\n      if (smax + heal > H) {\n        Q.push(pii(H-smax, pos));\n        continue;\n      }\n      int num = min((0-now)/heal+1, (H-smax)/heal);\n      now += num*heal;\n      ans += num;\n      // cout << \"num = \" << num << endl;\n      // cout << \"now = \" << now << endl;\n      st.add(pos, i+1, num*heal);\n      Q.push(p);\n    }\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main(){\n  int N,H;\n  cin >> N >> H;\n  unsigned long long int ans=0;\n  int dp[H],di,hi,in,in2=1;\n  dp[0] = H;\n  for(int i=1;i<N;i++){\n    cin >> di >> hi;\n    for(int j=in2;j<H;j++) dp[j] = 0;\n    in = 0;\n    while(dp[in]!=H){\n      dp[in+1] = max(min(dp[in]+hi,H),dp[in+1]);\n      in++;\n    }\n    in2 = 0;\n    for(int j=0;j<=in;j++){\n      if(dp[j]-di<=0){\n\tans++;\n\tcontinue;\n      }\n      //if(j!=0&&dp[j-1]-di<=0) ans += j;\n      dp[in2] = dp[j]-di;\n      in2++;\n    }\n    for(int i=0;i<in2;i++) cout << dp[i] << ' ';\n    cout << endl;\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\nusing namespace std;\ntypedef long long ll;\nint n;\nll segAdd[444444],segMax[444444];\nvoid init(int n_){\n  n = 1;\n  while( n < n_) n *= 2;\n}\n\n//[a,b)\nvoid add(int a,int b,int x,int k,int l,int r){\n  if(r <= a || b <= l) return;\n\n  if(a <= l && r <= b){\n    segAdd[k] += x;\n    while(k){\n      k = (k-1)/2;\n      segMax[k] = max(segMax[2*k+1] + segAdd[2*k+1],segMax[2*k+2] + segAdd[2*k+2]);\n    }\n  }else{\n    add(a,b,x,2*k+1,l,(l+r)/2);\n    add(a,b,x,2*k+2,(l+r)/2,r);\n  }\n}\n\nll getMax(int a,int b,int k,int l,int r){\n  if(r <= a || b <= l) return -11111111111;\n\n  if(a <= l && r <= b) return segMax[k] + segAdd[k];\n\n  ll left  = getMax(a,b,2*k+1,l,(l+r)/2);\n  ll right = getMax(a,b,2*k+2,(l+r)/2,r);\n\n  return max(left,right) + segAdd[k];\n}\n\nint H,d[111111],h[111111];\nint main(void){\n  cin >> n >> H;\n  for(int i = 0; i < n-1; i++){\n    cin >> d[i] >> h[i];\n  }\n\n  int res = 0;\n  priority_queue<pair<int,int> > que;\n  add(0,1,H,0,0,n);\n  for(int i = 0; i < n-1; i++){\n    que.push(make_pair(h[i],i));\n    while(1){\n      if(getMax(i,i+1,0,0,n) - d[i] > 0) break;\n      if(que.empty()) break;\n      int f = que.top().first;\n      int s = que.top().second;\n      if(getMax(s,i+1,0,0,n) + f <= H){\n\tint k1 = (H-getMax(s,i+1,0,0,n))/f;\n\tint k2 = (d[i]-getMax(i,i+1,0,0,n))/f + 1;\n\tadd(s,i+1,f*min(k1,k2),0,0,n);\n\tres += min(k1,k2);\n      }else{\n\tque.pop();\n\tque.push(make_pair(H - getMax(s,i+1,0,0,n),s));\n      }\n    }\n    add(i+1,i+2,getMax(i,i+1,0,0,n) - d[i],0,0,n);\n  }\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nll n, h;\nll di[100010];\nll hi[100010];\n\nint main() {\n  while (scanf(\"%lld %lld\", &n, &h) > 0) {\n    REP(i, n - 1) {\n      scanf(\"%lld %lld\", &di[i], &hi[i]);\n    }\n    ll ans = 0;\n    ll hhp = h;\n    ll thp = h;\n    int head = 0;\n    int tail = 0;\n    multiset<int> spring;\n    spring.insert(-hi[0]);\n    spring.insert(0);\n    bool down = true;\n    while (head < n - 1) {\n      if (hhp > di[head]) {\n        hhp -= di[head];\n        head++;\n        spring.insert(-hi[head]);\n        continue;\n      }\n      if (down || hi[tail] != -*spring.begin()) {\n        thp -= di[tail];\n        spring.erase(spring.find(-hi[tail]));\n        tail++;\n        down = false;\n        continue;\n      }\n      ll rest = h - thp;\n      ll need = min(rest, di[head] - hhp + 1);\n      ll cnt = (need + hi[tail] - 1) / hi[tail];\n      if (cnt * hi[tail] > rest) { cnt--; }\n      ans += cnt;\n      hhp += cnt * hi[tail];\n      thp += cnt * hi[tail];\n      if (hhp > di[head]) { continue; }\n      ll up = h - thp;\n      assert(thp <= h);\n      down = true;\n      set<int>::iterator it = spring.begin();\n      it++;\n      if (-*it < up || head == tail) {\n        ans++;\n        hhp += up;\n        thp += up;\n      }\n    }\n    printf(\"%lld\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\n#define int long long\n\nconst int MAX_N = 100010;\n\nclass segTree{\n    public:\n        int n, dat[4 * MAX_N];\n        void init(int n_, int value, int dat_b[4 * MAX_N] = NULL){\n            n = 1;\n            while(n < n_) n *= 2;\n            rep(i,2 * n){\n                dat[i] = value;\n                if(dat_b != NULL) dat_b[i] = value;\n            }\n        }\n        void output(int a[4 * MAX_N]){\n            show(\"print\");\n            range(i,1,n * 2) cout << (a[i] == INT_MAX ? 0 : a[i]) << ' ';\n            cout << endl;\n        }\n};\n\nclass starrySky : public segTree{\n    private:\n        int query(int a, int b, int k, int l, int r){\n            if(b <= l || r <= a) return 0;\n            if(a <= l && r <= b) return dat[k] + dat_add[k];\n\n            int vl = query(a, b, k * 2, l, (l + r) / 2);\n            int vr = query(a, b, k * 2 + 1, (l + r) / 2, r);\n            return max(vl, vr) + dat_add[k];\n        }\n        void add(int a, int b, int k, int l, int r, int x){\n            if(b <= l || r <= a) return;\n            if(a <= l && r <= b){\n                dat_add[k] += x;\n            }else{\n                add(a, b, k * 2, l, (l + r) / 2, x);\n                add(a, b, k * 2 + 1, (l + r) / 2, r, x);\n                dat[k] = max(dat[k * 2] + dat_add[k * 2], dat[k * 2 + 1] + dat_add[k * 2 + 1]);\n            }\n        }\n        void init(int n_){ segTree::init(n_,0,dat_add); }\n    public:\n        int dat_add[4 * MAX_N];\n        starrySky(int n){ init(n); }\n        int query(int a, int b){ return query(a, b, 1, 0, n); }\n        void add(int s, int t, int x){ add(s, t, 1, 0, n, x); }\n        void add(int i, int x){ add(i, i + 1, 1, 0, n, x); }\n};\n\n\nsigned main(){\n    long long n, h;\n    cin >> n >> h;\n\n???//1-index????????°??¨\n    starrySky seg(n); //?????????????????????\n    priority_queue<pair<long long, int>> q; //??????????????????pos\n    long long cur = h, ans = 0;\n    rep(i,n - 1){\n        long long damage, heal;\n        cin >> damage >> heal;\n        q.push(make_pair(heal, i));\n\n        seg.add(i + 1, cur);\n        cur -= damage;\n        while(cur <= 0){\n            pair<long long, int> use = q.top(); q.pop();\n            long long maxHP = seg.query(use.second + 1, i + 2); //????????°??????????????¨??°?????§?????????????????§\n\n            if(maxHP + use.first > h){ //??????????????????????¶????????????§?????????????????????????????´\n                q.push(make_pair(h - maxHP, use.second));\n                continue;\n            }\n\n            long long can_use = (h - maxHP) / use.first;\n            long long require = ceil((-1.0 * cur + 1) / use.first);\n            long long used = min(can_use, require);\n            ans += used;\n            cur += used * use.first;\n\n            seg.add(use.second + 1, i + 2, used * use.first);\n            q.push(use);\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main(){\n  int N,H;\n  cin >> N >> H;\n  unsigned long long int ans=0;\n  int dp[H],di,hi,in,in2=1;\n  dp[0] = H;\n  for(int i=1;i<N;i++){\n    cin >> di >> hi;\n    for(int j=in2;j<H;j++) dp[j] = 0;\n    in = 0;\n    while(dp[in]!=H){\n      dp[in+1] = max(min(dp[in]+hi,H),dp[in+1]);\n      in++;\n    }\n    in2 = 0;\n    for(int j=0;j<=in;j++){\n      if(dp[j]-di<=0){\n\tans++;\n\tcontinue;\n      }\n      //if(j!=0&&dp[j-1]-di<=0) ans += j;\n      dp[in2] = dp[j]-di;\n      in2++;\n    }\n    //for(int i=0;i<in2;i++) cout << dp[i] << ' ';\n    //cout << endl;\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<algorithm>\nusing namespace std;\nint main() {\n\tlong long n, h, b, c, sum = 0;\n\tcin >> n >> h;\n\tlong long  h2 = h,a=0;\n\tfor (int i = 0; i < n-1; i++) {\n\t\tcin >> b >> c;\n\t\tif (h < 0) {\n\t\t\twhile (h < 0) {\t\n\t\t\t\th += a;\n\t\t\t\tsum++;\n\t\t\t}\n\t\t}\n\t\tif (h > h2) h = h2;\n\t\th -= b;\n\t\ta = max(a, c);\n\t}\n\twhile (h < 0) {\n\t\tsum++;\n\t\th += a;\n\t}\n\tcout << sum << endl;\n\tcin >> sum;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\n\nint N,H,d,h;\n\nint main(){\n  scanf(\"%d%d\",&N,&H);\n  ll ans = 0;\n\n  ll cur = H;\n  priority_queue<pll> q;\n  for(int i=0;i<N-1;i++){\n\n    scanf(\"%d%d\",&d,&h);\n    ll rem = H-cur;\n    priority_queue<pll> tmp;\n    while(q.size() && q.top().first >= h){\n      pll p = q.top(); q.pop();\n      rem -= p.second * p.first;\n      tmp.push(p);\n    }\n    swap(q,tmp);\n    ll times = rem/h;\n    if(times)q.push(pll(h,times));\n    if(times*h != rem)q.push(pll(rem-times*h,1));\n\n    cur -= d;\n    while(cur<=0){\n      pll p = q.top(); q.pop();\n      ll need = -cur/p.first+1;\n\n      if(need <= p.second){\n\tans += need;\n\tp.second -= need;\n\tcur += need * p.first;\n\tif(p.second)q.push(p);\n      }else{\n\tans += p.second;\n\tcur += p.first * p.second;\n      }\n    }\n  }\n\n  printf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "//Bokan ga bokka--nn!!\n//Daily Lunch Special Tanoshii !!\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\n#include <deque>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\ntypedef long long ll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\n#define s(x) scanf(\"%d\",&x)\n#define rep(i,x) for(int i=0;i<x;i++)\nint main()\n{\n\tint n;\n\tll maxv;\n\tscanf(\"%d %lld\",&n,&maxv);\n\tll totv=maxv;\n\tll totd=0LL;\n\tdeque<pair<ll,ll> >deq;\n\tll ret=0LL;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tll a,b;\n\t\tscanf(\"%lld %lld\",&a,&b);\n\t\twhile(!deq.empty() && deq.back().first<=b) deq.pop_back();\n\t\tdeq.push(mp(b,totd));\n\t\ttotd+=a;\n\t\tif(totv<totd)\n\t\t{\n\t\t\twhile(totv+totd+deq.front().first-deq.front().second>maxv) deq.pop_front();\n\t\t\tll kai=deq.front().first;\n\t\t\tll prev=deq.front().second;\n\t\t\tret+=(maxv-(totv+totd-prev))/kai;\n\t\t\ttotv+=((maxv-(totv+totd-prev))/kai)*kai;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<iostream>\n#include<queue>\n#include<string>\n#include<climits>\nusing namespace std;\ntypedef long long ll;\n#define INF (LLONG_MAX)\ntypedef pair<ll,int> P;\n#define F first\n#define S second\nint N;\nll H;\nP d[400001];\nll h[400001];\nint n;\nvoid update(int k,ll a){\n  int i=k;\n  k += n-1;\n  d[k].F = a;\n  d[k].S = i;\n  while( k > 0 ){\n    k=(k-1)/2;\n    d[k] = max( d[k*2+1] ,d[k*2+2] );\n  }\n}  \nvoid init(){\n  n = 1;\n  while( n < N-1 ) n *= 2;\n  /*  for(int i=0;i<2*n-1;i++){\n    h[i]=H;\n    }*/\n}\n\nvoid add(int a,int b,ll x,int k,int l,int r){\n  if( r<=a || b<=l ) return;\n  if( a<=l && r<=b ){\n    h[k] += x;\n    return;\n  }\n  add(a,b,x,k*2+1,l,(l+r)/2);\n  add(a,b,x,k*2+2,(l+r)/2,r);\n}\n\nP qmax(int a,int b,int k, int l,int r){\n  //  printf(\"qmax:%d %d %d %d %d\\n\",a,b,k,l,r);\n  if( r<=a || b<=l ) return P(-1,-1);\n  if( a<=l && r<=b ) return d[k];\n  P vl = qmax(a,b,k*2+1,l,(l+r)/2);\n  P vr = qmax(a,b,k*2+2,(l+r)/2,r);\n  return max(vl,vr);\n}\n\nll sum(int k){\n  k += n-1;\n  ll ret = h[k];\n  while ( k > 0 ){\n    k = (k-1)/2;\n    ret += h[k];\n  }\n  return ret;\n}\n\npair<ll,ll> proc(int &st,int i){\n  bool r = true;\n  P p;\n  ll s;\n  while(r){\n    p = qmax(st,i+1,0,0,n);\n    s = sum(p.S);\n    if( s < p.F ){\n      update(p.S,s);\n    } else\n      r = false;\n    st = p.S;\n    //printf(\"proc check : %lld %d  許容量:%lld st:%d i:%d\\n\",p.F,p.S,s,st,i);\n    //    sleep(1);\n  }\n  return pair<ll,ll>(p.F,s);\n}\n\nint main(){\n  scanf(\"%d %lld\",&N,&H);\n  ll dm = 0;\n  int st = 0;\n  ll res = 0;\n  init();\n  for(int i=0;i<N-1;i++){\n    ll a,b;\n    scanf(\"%lld %lld\",&b,&a);\n    update(i,a);\n    if( dm+b >= H ){\n      ll nd = (dm+b) - H + 1;\n      while(nd>0){\n\tpair<ll,ll> p = proc(st,i);\n\tll c;\n\t//\tif( p.S >= nd ){\n\tc = (nd-1) / p.F + 1;\n\tif( c*p.F > p.S ){\n\t  ///\t} else {\n\t  c= p.S / p.F;\n\t}\n\tres+=c;\n\tadd( st, i+1, -c*p.F, 0, 0, n);\n\tnd -= c*p.F;\n\t//\tprintf(\"dm+b check : %lld 残り回復量:%lld 回復量:%lld st:%d i:%d\\n\",res,nd,c*p.F,st,i);     \n      }\n      dm = max( 0LL, H + nd -1 );\n    } else\n      dm+=b;\n    h[i+n] = dm;\n    //  printf(\"check: %lld ダメージ総量:%lld %d %d\\n\",res,dm,st,i);\n  }\n  printf(\"%lld\\n\",res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  ll N, maxHp;\n  while (cin >> N >> maxHp) {\n    vector<ll> totalDamage(N);\n    ll totalHealing = 0, answer = 0;\n    priority_queue<pair<ll, int>> Q;\n\n    for (int i = 0; i < N - 1; ++i) {\n      ll damage, healing;\n      cin >> damage >> healing;\n      totalDamage[i + 1] = totalDamage[i] + damage;\n      Q.push({healing, i});\n\n      ll necessaryHealing = totalDamage[i + 1] - totalHealing - maxHp + 1;\n      while (necessaryHealing > 0) {\n        ll healing = Q.top().first;\n        int index = Q.top().second;\n        Q.pop();\n\n        ll netDamage = totalDamage[index] - totalHealing;\n        ll times = (necessaryHealing + healing - 1) / healing;\n        if (netDamage - healing * times < 0) --times;\n        answer += times;\n        necessaryHealing -= healing * times;\n        netDamage -= healing * times;\n        totalHealing += healing * times;\n        if (netDamage > 0) Q.push({min(healing, netDamage), index});\n      }\n    }\n    cout << answer << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll d[100000];\nll h[100000];\nll s[100000];\nint main(){\n\tll N,H,l;\tcin>>N>>H;\n\tl=H;\n\tfor(int i=0;i<N-1;i++){\n\t\tcin>>d[i]>>h[i];\n\t\ts[i+1]=s[i]+d[i];\n\t}\n\tll ans=0;\n\tdeque<int> dq;\n\tfor(int i=0;i<N;i++){\n\t\twhile((!dq.empty())&&h[dq.back()]<=h[i])\tdq.pop_back();\n\t\tdq.push_back(i);\n\t\twhile((!dq.empty())&&s[i]-s[dq.front()]>l)\tdq.pop_front();\n\t\tif(l<=d[i]){\n\t\t\tfor(int j=0;j<(int)dq.size();j++){\n\t\t\t\tll heal=max(0LL,H-(s[i]-s[dq[j]]-l));\n\t\t\t\tll req=d[i]-l+1;\n\t\t\t\tll use=min(heal,req)/h[dq[j]];\n\t\t\t\tl+=use*h[dq[j]];\n\t\t\t\tans+=use;\n\t\t\t\tif(l>d[i])\tbreak;\n\t\t\t\tif(j+1>=(int)dq.size()||H-(s[i]-s[dq[j]])-l>=h[dq[j+1]]){\n\t\t\t\t\tans++;\n\t\t\t\t\tl=min(l+h[dq[j]],H-(s[i]-s[dq[j]]));\n\t\t\t\t}\n\t\t\t\tif(l>d[i])\tbreak;\n\t\t\t}\n\t\t}\n\t\tl-=d[i];\n\t\tif(l<=0){\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#define s 131072\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll>pii;\nclass segtree\n{\npublic:\n\tll seg[s*2];\n\tll lazy[s*2];\n\tvoid lazy_evaluate(int k)\n\t{\n\t\tif(k*2+2>=s*2) return ;\n\t\tlazy[k*2+2]+=lazy[k];\n\t\tlazy[k*2+1]+=lazy[k];\n\t\tseg[k*2+2]+=lazy[k];\n\t\tseg[k*2+1]+=lazy[k];\n\t\tlazy[k]=0;\n\t}\n\tll update(int beg,int end,int idx,int lb,int ub,ll num)\n\t{\n\t\tif(ub<beg||end<lb)\n\t\t{\n\t\t\treturn seg[idx];\n\t\t}\n\t\tif(beg<=lb&&ub<=end)\n\t\t{\n\t\t\tlazy[idx]+=num;\n\t\t\tseg[idx]+=num;\n\t\t\treturn seg[idx];\n\t\t}\n\t\tif(lazy[idx])\n\t\t{\n\t\t\tlazy_evaluate(idx);\n\t\t}\n\t\treturn seg[idx]=max(update(beg,end,idx*2+1,lb,(lb+ub)/2,num),update(beg,end,idx*2+2,(lb+ub)/2+1,ub,num));\n\t}\n\tll query(int beg,int end,int idx,int lb,int ub)\n\t{\n\t\tif(ub<beg||end<lb)\n\t\t{\n\t\t\treturn -1000000000000000000LL;\n\t\t}\n\t\tif(beg<=lb&&ub<=end)\n\t\t{\n\t\t\treturn seg[idx];\n\t\t}\n\t\tif(lazy[idx])\n\t\t{\n\t\t\tlazy_evaluate(idx);\n\t\t}\n\t\treturn max(query(beg,end,idx*2+1,lb,(lb+ub)/2),query(beg,end,idx*2+2,(lb+ub)/2+1,ub));\n\t}\n};\nsegtree seg_tree;\nint main()\n{\n\tll n,x;\n\tscanf(\"%lld %lld\",&n,&x);\n\tseg_tree.update(0,s-1,0,0,s-1,x);\n\tll ret=0LL;\n\tpriority_queue<pii>que;\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tll za,zb;\n\t\tscanf(\"%lld %lld\",&za,&zb);\n\t\tque.push(make_pair(zb,i));\n\t\tfor(;;)\n\t\t{\n\t\t\tif(que.empty())\tbreak;\n\t\t\tif(seg_tree.query(i+1,i+1,0,0,s-1)>za) break;\n\t\t\tpii zan=que.top();\n\t\t\tll ka=(x-seg_tree.query(zan.second,i+1,0,0,s-1))/zan.first,kb=(1-seg_tree.query(i+1,i+1,0,0,s-1)+za+zan.first-1)/zan.first;\n\t\t\tif(ka>=kb)\n\t\t\t{\n\t\t\t\tret+=kb;\n\t\t\t\tseg_tree.update(zan.second,s-1,0,0,s-1,kb*zan.first);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tret+=ka;\n\t\t\t\tque.pop();\n\t\t\t\tque.push(make_pair((x-seg_tree.query(zan.second,i+1,0,0,s-1))%zan.first,zan.second));\n\t\t\t\tseg_tree.update(zan.second,s-1,0,0,s-1,ka*zan.first);\n\t\t\t}\n\t\t}\n\t\tseg_tree.update(i+1,s-1,0,0,s-1,-za);\n\t}\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\nusing namespace std;\ntypedef long long ll;\nint n;\nll segAdd[444444],segMax[444444];\nvoid init(int n_){\n  n = 1;\n  while( n < n_) n *= 2;\n}\n\n//[a,b)\nvoid add(int a,int b,int x,int k,int l,int r){\n  if(r <= a || b <= l) return;\n\n  if(a <= l && r <= b){\n    segAdd[k] += x;\n    while(k){\n      k = (k-1)/2;\n      segMax[k] = max(segMax[2*k+1] + segAdd[2*k+1],segMax[2*k+2] + segAdd[2*k+2]);\n    }\n  }else{\n    add(a,b,x,2*k+1,l,(l+r)/2);\n    add(a,b,x,2*k+2,(l+r)/2,r);\n  }\n}\n\nll getMax(int a,int b,int k,int l,int r){\n  if(r <= a || b <= l) return -1;\n\n  if(a <= l && r <= b) return segMax[k] + segAdd[k];\n\n  ll left  = getMax(a,b,2*k+1,l,(l+r)/2);\n  ll right = getMax(a,b,2*k+2,(l+r)/2,r);\n\n  return max(left,right) + segAdd[k];\n}\n\nint H,d[111111],h[111111];\nint main(void){\n  cin >> n >> H;\n  for(int i = 0; i < n-1; i++){\n    cin >> d[i] >> h[i];\n  }\n\n  int res = 0;\n  priority_queue<pair<int,int> > que;\n  add(0,1,H,0,0,n);\n  for(int i = 0; i < n-1; i++){\n    que.push(make_pair(h[i],i));\n    while(1){\n      if(getMax(i,i+1,0,0,n) - d[i] > 0) break;\n      if(que.empty()) break;\n      int f = que.top().first;\n      int s = que.top().second;\n      que.pop();\n      if(getMax(s,i+1,0,0,n) + f <= H){\n\tint k = (H-getMax(s,i+1,0,0,n))/f;\n\tadd(s,i+1,f*k,0,0,n);\n\tres += k;\n      }else{\n\tque.push(make_pair(H - getMax(s,i+1,0,0,n),s));\n      }\n    }\n    add(i+1,i+2,getMax(i,i+1,0,0,n) - d[i],0,0,n);\n  }\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nconst int INF = 1<<29;\n\ntypedef long long ll;\n\nint N,H;\nll dp[2][10000005];\nint d[1024],h[1024];\n\nint main(){  \n  scanf(\"%d%d\",&N,&H);\n  for(int i=0;i<N-1;i++) scanf(\"%d%d\", d+i, h+i);\n  for(int i=0;i<2;i++) for(int j=0;j<10000005;j++) dp[i][j] = INF;\n  dp[0][H] = 0;\n  int cur, tar;\n  for(int i=0;i<N-1;i++){\n    cur = i%2, tar = !cur;\n    for(int j=0;j<10000005;j++) dp[tar][j] = INF;\n    for(int j=1;j<=H;j++){\n      if(dp[cur][j] == INF) continue;\n      int k;\n      for(k=0;j+h[i]*k <= H;k++){\n\tif(j-d[i]+h[i]*k > 0) dp[tar][j-d[i]+h[i]*k] = min(dp[tar][j-d[i]+h[i]*k], dp[cur][j]+k);\n      }\n      dp[tar][H-d[i]] = min(dp[tar][H-d[i]], dp[cur][j]+k);\n    }\n  }\n  ll res = INF;\n  for(int i=1;i<=H;i++) res = min(res,dp[tar][i]);\n  printf(\"%lld\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <assert.h>\n#define N_MAX (100000)\n#define min(a,b) (((a)<(b))?(a):(b))\ntypedef struct {\n\tint pos,value;\n} Info;\n\nsigned main(){\n\tlong long damage_total[N_MAX]={};\n\tInfo deque[N_MAX];\n\tint head=0,tail=0;\n\tint N,H;\n\tlong long answer = 0;\n\n\tscanf(\"%d%d\",&N,&H);\t\n\tint currentHP = H;\n\tfor(int i = 0 ; i < N-1 ; i++){\n\t\tint d,h;\n\t\tscanf(\"%d%d\",&d,&h);\n\t\twhile( head != tail && deque[tail-1].value <= h ) tail--;\n\n\t\tdeque[tail++] = (Info){i,h};\n\t\t/*while( head != tail ){\n\t\t\tint maximumRecover = H - (damage_total[i] - damage_total[deque[head].pos]);\n\t\t\tif( maximumRecover > 0 ) break;\n\t\t\thead++;\n\t\t}*/\n\n\t\tfor(int j = head ; j < tail && currentHP <= d ; j++){\n\t\t\t// ????????§???????????§????????????\n\t\t\tlong long maximumRecover = H - (damage_total[i] - damage_total[deque[j].pos]);\n\t\t\t// ??¨???????????§????????????????£???°???\n\t\t\tif( maximumRecover <= currentHP) continue;\n\n\t\t\t// j??????????????§?????????????????? needRecover ????¨????\n\t\t\tint needRecover = min( maximumRecover - currentHP , d - currentHP + 1);  \n\t\t\t// ???????????? needRecover ?????????????????????????????° useCount ????±????????????????????????????\n\t\t\tint useCount = (needRecover+deque[j].value-1) / deque[j].value - 1;\n\t\t\tanswer += useCount;\n\t\t\tcurrentHP += useCount*deque[j].value;\n\n\t\t\t// ???j?????????????????§????°???????????????????j????????£?????´?????¨???j+1????????£?????´?????????????????????j+1????????£????????????????????????j?????????????????????\n\t\t\t// ??¨) ???????????¶???????????\\??£?????????????????¨???????????? currentHP > d ???????????????\n\t\t\tif( j+1 ==  tail || maximumRecover > currentHP + deque[j+1].value ){\n\t\t\t\tcurrentHP = min(currentHP+deque[j].value,maximumRecover);\n\t\t\t\tanswer++;\n\t\t\t}\n\t\t}\n\t\tcurrentHP -= d;\n\t\tdamage_total[i+1] = damage_total[i] + d;\n\t}\n\tprintf(\"%lld\\n\",answer);\n\n}"
  },
  {
    "language": "C++",
    "code": "//#define MYDEBUG\n#include <bits/stdc++.h>\n\n#ifdef MYDEBUG\n#define dbp(x) cout<<#x<<\": \"<<x<<endl\n#define dbp2(x,y) cout<<#x<<\",\"<<#y<<\": \"<<x<<\",\"<<y<<endl\n#define dbp3(x,y,z) cout<<#x<<\",\"<<#y<<\",\"<<#z<<\": \"<<x<<\",\"<<y<<\",\"<<z<<endl\n#define dbp4(w,x,y,z) cout<<#w<<\",\"<<#x<<\",\"<<#y<<\",\"<<#z<<\": \"<<w<<\",\"<<x<<\",\"<<y<<\",\"<<z<<endl\n#define ifcin(x) std::ifstream cin(x)\n#else\n#define dbp(x)\n#define dbp2(x,y)\n#define dbp3(x,y,z)\n#define dbp4(w,x,y,z)\n#define ifcin(x)\n#endif\n#define ll long long\n#define ull unsigned long long\n#define all(x) x.begin(), x.end()\n#define rep(i, from, to) for(int i=from; i<to; ++i)\n#define REP(i, from, to) for(int i=from; i<=to; ++i)\nusing std::vector;\nusing std::cout;\nusing std::cin;\nusing std::endl;\nusing std::max;\nusing std::min;\nusing std::swap;\nusing std::string;\nusing std::fill;\nusing std::pair;\nusing std::sort;\nusing std::reverse;\nusing std::pair;\nusing std::priority_queue;\nusing std::ostream;\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<vector<T> >& v) {\n\tfor (size_t i = 0; i < v.size(); ++i) {\n\t\tout << v[i] << endl;\n\t}\n\treturn out;\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<T>& v) {\n\tout << \"[\";\n\tsize_t last = v.size() - 1;\n\tfor (size_t i = 0; i < v.size(); ++i) {\n\t\tout << v[i];\n\t\tif (i != last) {\n\t\t\tout << \",\";\n\t\t}\n\t}\n\tout << \"]\";\n\treturn out;\n}\n\nll N, H;\nll hp, maxi, heal, ans, rest;\nvoid solve() {\n\tifcin(\"/storage/emulated/0/AppProjects/xmas/jni/in.txt\");\n\tcin >> N >> H;\n\thp = H;\n\tans = 0;\n\tll d, h;\n\tcin >> d >> h;\n\tmaxi = h;\n\trep(i,0,N-1){\n\t\thp -= d;\n\t\tcin >> d >> h;\n\t\trest = hp - d;\n\t\tif(rest <= 0){\n\t\t\theal = (abs(rest) + maxi) / maxi;\n\t\t\thp += heal * maxi;\n\t\t\thp = min(hp, H);\n\t\t\tans += heal;\n\t\t}\n\t\tmaxi = max(maxi, h);\n\t\tdbp4(hp, maxi, heal, ans);\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n//#include <cstdlib>\n//#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n//#include <limits>\n//#include <sstream>\n//#include <functional>\nusing namespace std;\n\n#define len(array)  (sizeof (array) / sizeof *(array))\n#define rep(i, s, e) for(int i = s;i < e;i++)\n#define rrep(i, e, s) for(int i = e;s <= i;i--)\n#define vrange(v) v.begin(), v.end()\n#define vrrange(v) v.rbegin(), v.rend()\n#define vsort(v) sort(vrange(v))\n#define vrsort(v) sort(vrrange(v))\n#define arange(a) a, a + len(a)\n#define asort(a) sort(arange(a))\n#define arsort(a, t) sort(arange(a), greater<t>())\n#define afill(a, v) fill(arange(a), v)\n#define afill2(a, v, t) fill((t *)a, (t *)(a + len(a)), v)\n#define fmax(a, b) (a < b? b : a)\n#define fmin(a, b) (a > b? b : a)\n#define fabs(a) (a < 0? -a : a)\ntypedef unsigned int ui;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, int> P;\nconst int INF = (int)1e9;\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-10;\n//const int dx[] = {1, -1, 0, 0, 1, -1, -1, 1};\n//const int dy[] = {0, 0, 1, -1, -1, -1, 1, 1};\n//const int weight[] = {0,1,10,100,1000,10000,100000,1000000,10000000};\n//priority_queue<int, vector<int>, greater<int>> q;\ntypedef struct _Node {\n  _Node(int arg1 = 0, int arg2 = 0 , int arg3 = 0) {\n    i = arg1;\n    j = arg2;\n    k = arg3;\n  }\n  int i,j,k;\n  bool operator <(const struct _Node &e) const{\n    return i == e.i? j < e.j : i < e.i;\n  }\n  bool operator >(const struct _Node &e) const{\n    return i == e.i? j > e.j : i > e.i;\n  }\n}node;\n\n#define MAX_SIZE 100002 * 4\n\nll segMax[MAX_SIZE], segAddMax[MAX_SIZE];\n\n//区間[a, b)に値xを加算する.\nvoid addMax(int a, int b, int x, int k, int l, int r)\n{\n  if (r <= a || b <= l) return;\n  if (a <= l && r <= b){\n    segAddMax[k] += x;\n    while (k){\n      k = (k - 1) / 2;\n      segMax[k] = fmax(segMax[k * 2 + 1] + segAddMax[k * 2 + 1], segMax[k * 2 + 2] + segAddMax[k * 2 + 2]);\n    }\n    return;\n  }\n\n  addMax(a, b, x, k * 2 + 1, l, (l + r) / 2);\n  addMax(a, b, x, k * 2 + 2, (l + r) / 2, r);\n}\n\nll getMax(int a, int b, int k, int l, int r)\n{\n  if (r <= a || b <= l) return -1;\n  if (a <= l && r <= b) return (segMax[k] + segAddMax[k]);\n  ll left = getMax(a, b, k * 2 + 1, l, (l + r) / 2);\n  ll right = getMax(a, b, k * 2 + 2, (l + r) / 2, r);\n  return (fmax(left, right) + segAddMax[k]);\n}\n\n\n\n\nvoid doIt(){\n  int n, damage[100002], heal[100002];\n  ll h, hp, ans = 0, tmp;\n  priority_queue<P> q;\n  afill(segMax, 0);\n  afill(segAddMax, 0);\n  scanf(\"%d%lld\", &n, &h);\n  n--;\n  //cout << n << \", \" << h << endl;;\n  hp = h;\n  rep(i, 0, n) scanf(\"%d %d\", &damage[i], &heal[i]);\n  //cout << \"end.\" << endl;\n  rep(i, 0, n){\n    //cout << \"i = \" << i << endl;\n    addMax(i, i+1, hp, 0, 0, n);\n    q.push(P(heal[i], i));\n    hp -= damage[i];\n    //cout << \"i = \" << i << \", damaged hp = \" << hp << endl;\n    while(hp <= 0){\n      P p = q.top();\n      //cout << \"getMax(\" << p.second << \", \" << i+1 << \") = \" << getMax(p.second, i+1, 0, 0, n) << endl;;\n      tmp = h - getMax(p.second, i+1, 0, 0, n);\n      //cout << \"  tmp = \" << tmp << \"p = \" << p.first << \", \" << p.second << endl;\n\n      if(tmp <= 0 || tmp < p.first){\n        q.pop();\n        if(0 < tmp){\n          p.first = tmp;\n          q.push(p);\n        }\n      }\n      else{\n        ll t1 = fabs(hp) / p.first, t, t2;\n\t\tt2 = tmp / p.first;\n        //cout << \"t = \" << t << \", hp = \" << hp << endl;\n        //if(hp <= 0){hp += p.first; t++;}\n        if(p.first*(t2+1) <= tmp) t2++;\n\t\tif(p.first*t1 <= 0) t1++;\n\t\tt = fmin(t1, t2);\n\t\thp += p.first * t;\n        ans += t;\n        addMax(p.second, i+1, p.first*t, 0, 0, n);\n      }\n    }\n    //cout << \"  hp = \" << hp << \", count = \" << ans << endl;\n  }\n  //cout << ans << endl;\n  printf(\"%lld\\n\", ans);\n}\n\nint main() {\n  doIt();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef pair<int,int>P;\nconst int SIZE=1<<17;\n\nstruct seg_tree{\n    vector<int>ma,lazy;\n\n    seg_tree():ma(SIZE*2-1,0),lazy(SIZE*2-1,0){}\n\n    void evaluate(int k){\n        ma[k]+=lazy[k];\n        if(k<SIZE-1){\n            lazy[k*2+1]+=lazy[k];\n            lazy[k*2+2]+=lazy[k];\n        }\n        lazy[k]=0;\n    }\n    void update_node(int k){\n        ma[k]=max(ma[k*2+1],ma[k*2+2]);\n    }\n\n    void add(int a,int b,int x,int k=0,int l=0,int r=SIZE){\n        evaluate(k);\n        if(r<=a||b<=l)return;\n        if(a<=l&&r<=b){\n            lazy[k]+=x;\n            evaluate(k);\n            return;\n        }\n        int m=(l+r)/2;\n        add(a,b,x,k*2+1,l,m);\n        add(a,b,x,k*2+2,m,r);\n        update_node(k);\n    }\n\n    int get_max(int a,int b,int k=0,int l=0,int r=SIZE){\n        evaluate(k);\n        if(r<=a||b<=l)return 0;\n        if(a<=l&&r<=b)return ma[k];\n        int m=(l+r)/2;\n        int vl=get_max(a,b,k*2+1,l,m);\n        int vr=get_max(a,b,k*2+2,m,r);\n        return max(vl,vr);\n    }\n};\n\nint N,H;\nint d[100000],h[100000];\n\nsigned main(){\n\n    cin>>N>>H;\n    for(int i=0;i<N-1;i++)cin>>d[i]>>h[i];\n\n    seg_tree seg;\n    int cur=H;\n    int ans=0;\n    priority_queue<P>que;\n    for(int i=0;i<N-1;i++){\n        seg.add(i,i+1,cur);\n        cur-=d[i];\n\n        que.push(P(h[i],i));\n\n        while(cur<=0){\n            if(que.size()==0)return 0;\n            P p=que.top();que.pop();\n            int ma=seg.get_max(p.second,i+1);\n            if(p.first+ma>H){\n                que.push(P(H-ma,p.second));\n                continue;\n            }\n            if(p.first==0)continue;\n            int val=min(p.first,H-ma);\n            int x=min(abs(cur)/val+1,(H-ma)/val);\n            ans+=x;\n            cur+=x*p.first;\n            seg.add(p.second,i+1,p.first*x);\n        }\n    }\n\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\n\nll N,H,d,h;\n\nint main(){\n  cin >> N >> H;\n  ll ans = 0;\n\n  ll cur = H;\n  priority_queue<pll> q;\n  for(int i=0;i<N-1;i++){\n\n    cin >> d >> h;\n    ll rem = H-cur;\n    priority_queue<pll> tmp;\n    while(q.size() && q.top().first >= h){\n      pll p = q.top(); q.pop();\n      rem -= p.second * p.first;\n      tmp.push(p);\n    }\n    swap(q,tmp);\n    ll times = rem/h;\n    if(times)q.push(pll(h,times));\n    if(times*h != rem)q.push(pll(rem-times*h,1));\n\n    cur -= d;\n    while(cur<=0){\n      pll p = q.top(); q.pop();\n      ll need = -cur/p.first+1;\n\n      if(need <= p.second){\n\tans += need;\n\tp.second -= need;\n\tcur += need * p.first;\n\tif(p.second)q.push(p);\n      }else{\n\tans += p.second;\n\tcur += p.first * p.second;\n      }\n    }\n  }\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma warning(disable:4996)\n#include<stdio.h>\n#define N_ 100010\nint H, HP, n;\nint Q2[N_], h = 1, t, C;\nlong long R, SS, Q[N_];\nvoid ins(long long a, int b){\n\twhile (t >= h && (Q[t] >= a || Q2[t] <= b)){\n\t\tif (b < Q2[t]) b = Q2[t];\n\t\tt--;\n\t}\n\tif (b > a) b = a;\n\tQ[++t] = a;\n\tQ2[t] = b;\n}\nlong long Gap(int x){\n\treturn Q[x] - SS;\n}\nint main()\n{\n\tint i, a, b, top = 0;\n\tlong long tp;\n\tscanf(\"%d%d\", &n, &HP);\n\tH = HP;\n\tfor (i = 1; i < n; i++){\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tins(HP - H + SS, b);\n\t\twhile (1){\n\t\t\tif (H > a){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (Gap(h) < Q2[h]){\n\t\t\t\tQ2[h] = Q[h] - SS;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (h < t && Q2[h] <= Q2[h+1]){\n\t\t\t\th++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Gap(h) <= a - H || a - H >= Q2[h]){\n\t\t\t\ttp = Gap(h);\n\t\t\t\tif (tp > a - H) tp = a - H;\n\t\t\t\tC = tp / Q2[h];\n\t\t\t\tH += Q2[h] * C;\n\t\t\t\tSS += Q2[h] * C;\n\t\t\t\tR += C;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tH += Q2[h];\n\t\t\tSS += Q2[h];\n\t\t\tR++;\n\t\t}\n\t\tH -= a;\n\t}\n\tprintf(\"%lld\\n\", R);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)   FOR(i,0,n)\n#define LL long long\n\nconst int MAXSSTN = 100010;\nclass StarrySkyTree{\npublic:\n  int size=0;\n  int depth=0; // the depth of the tree\n  int best=0;  // the index of maximum element\n  int start=0; // the initial index of inputs\n  long long dat_add[4 * MAXSSTN];\n  long long dat[4 * MAXSSTN];\n  StarrySkyTree(int n){\n    size=n;\n    while((1<<depth)<n)depth++;\n    start=(1<<depth)-1;\n    for(int i=start;i<(1<<(depth+1));i++){\n      dat[i]=-1e15;\n    }\n  }\n  StarrySkyTree(int n,long long* v){\n    size=n;\n    while((1<<depth)<n)depth++;\n    start=(1<<depth)-1;\n    for(int i=start;i<(1<<(depth+1));i++){\n      if(i<start+n)\n\tdat[i]=v[i-start];\n      else\n\tdat[i]=-1e15;\n    }\n    for(int i=start;i<start+n;i++){\n      int tmp=i;\n      while(par(tmp)!=-1){\n\tdat[par(tmp)]=max(dat[tmp],dat[(tmp+1)/2*4-1-tmp]);\n\ttmp=par(tmp);\n      }\n    }\n    int i=0;\n    while(i<start)i=(dat[i]==dat[2*i+1])?2*i+1:2*i+2;\n    best=i-start;\n  }\n  long long max_element(int a, int b){ return max_element(a, b, 0, 0, (1<<depth)); }\n  void add(int s, int t, long long x){ add(s, t, 0, 0, (1<<depth), x); }\n  void add(int i, long long x){ add(i, i + 1, 0, 0, (1<<depth), x); }\n\n  int par(int i){\n    if(i==0)\n      return -1;\n    return (i-1)/2;\n  }\n\n  void update(int d,long long x){\n    int i=d+start;\n    dat[i]=x;\n    while(par(i)!=-1){\n      dat[par(i)]=max(dat[i]+dat_add[i],dat[(i+1)/2*4-1-i]+dat_add[(i+1)/2*4-1-i]);\n      i=par(i);\n    }\n    i=0;\n    while(i<start){\n      i=(dat[i]==dat[2*i+1])?2*i+1:2*i+2;\n    }\n    best=i-start;\n  }\n  void dump(){\n    cerr<<\"SegTree:\"<<endl;\n    for(int i=0;i<depth+1;i++){\n      for(int j=0;j<(1<<i);j++)\n\tcerr<<dat[j+(1<<i)-1]<<\" \";\n      cerr<<endl;\n    }\n    cerr<<endl;\n    cerr<<\"SegTree lazy addition:\"<<endl;\n    for(int i=0;i<depth+1;i++){\n      for(int j=0;j<(1<<i);j++)\n\tcerr<<dat_add[j+(1<<i)-1]<<\" \";\n      cerr<<endl;\n    }\n    cerr<<endl;\n  }\nprivate:\n  long long max_element(int a, int b, int k, int l, int r){\n    if(b <= l || r <= a) return -1e15;\n    if(a <= l && r <= b) return dat[k] + dat_add[k];\n\n    long long vl = max_element(a, b, k * 2+1, l, (l + r) / 2);\n    long long vr = max_element(a, b, k * 2+2, (l + r) / 2, r);\n    return max(vl, vr) + dat_add[k];\n  }\n  void add(int a, int b, int k, int l, int r, long long x){\n    if(b <= l || r <= a) return;\n    if(a <= l && r <= b){\n      dat_add[k] += x;\n    }else{\n      add(a, b, k * 2+1, l, (l + r) / 2, x);\n      add(a, b, k * 2+2, (l + r) / 2, r, x);\n      dat[k] = max(dat[k * 2+1] + dat_add[k * 2+1], dat[k * 2 + 2] + dat_add[k * 2 + 2]);\n    }\n  }\n};\n\nint n;\nLL H;\nLL d[100000],h[100000];\n\nstruct cost{\n  int ind;\n  LL val;\n};\n\nbool operator<(const cost &c1,const cost &c2){\n  return c1.val<c2.val;\n}\n\nint main(){\n  cin>>n>>H;\n  vector<LL> heal(n,0);\n  REP(i,n-1)\n    cin>>d[i]>>h[i];\n  StarrySkyTree sst(n);\n  priority_queue<cost> que;\n  LL ret=0;\n  LL l=H;\n  REP(i,n-1){\n    sst.update(i,l);\n    cost c={i,min(h[i],H-l)};\n    que.push(c);\n    l-=d[i];\n    if(l>0)continue;\n    else{\n      while(l<=0){\n\tcost c = que.top();\n\tLL maxl = sst.max_element(c.ind,i+1);\n\tif(c.val > H-maxl){\n\t  que.pop();\n\t  c.val=H-maxl;\n\t  que.push(c);\n\t}else{\n\t  LL num = min((H-maxl)/c.val,1+(-l)/c.val);\n\t  sst.add(c.ind,i+1,c.val*num);\n\t  l+=c.val*num;\n\t  ret+=num;\n\t  heal[c.ind]+=num; \n\t}\n      }\n    }\n  }\n  /*\n  l=H;\n  REP(i,n-1){\n    l+=heal[i]*h[i];\n    l=min(l,H);\n    l-=d[i];\n    if(l<=0){\n      cerr<<i<<\":0 life\"<<endl;\n    }\n  }\n  */\n  cout<<ret<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef pair<int,int>P;\nconst int SIZE=1<<17;\n\nstruct seg_tree{\n    vector<int>ma,lazy;\n\n    seg_tree():ma(SIZE*2-1,0),lazy(SIZE*2-1,0){}\n\n    void evaluate(int k){\n        ma[k]+=lazy[k];\n        if(k<SIZE-1){\n            lazy[k*2+1]+=lazy[k];\n            lazy[k*2+2]+=lazy[k];\n        }\n        lazy[k]=0;\n    }\n    void update_node(int k){\n        ma[k]=max(ma[k*2+1],ma[k*2+2]);\n    }\n\n    void add(int a,int b,int x,int k=0,int l=0,int r=SIZE){\n        evaluate(k);\n        if(r<=a||b<=l)return;\n        if(a<=l&&r<=b){\n            lazy[k]+=x;\n            evaluate(k);\n            return;\n        }\n        int m=(l+r)/2;\n        add(a,b,x,k*2+1,l,m);\n        add(a,b,x,k*2+2,m,r);\n        update_node(k);\n    }\n\n    int get_max(int a,int b,int k=0,int l=0,int r=SIZE){\n        evaluate(k);\n        if(r<=a||b<=l)return 0;\n        if(a<=l&&r<=b)return ma[k];\n        int m=(l+r)/2;\n        int vl=get_max(a,b,k*2+1,l,m);\n        int vr=get_max(a,b,k*2+2,m,r);\n        return max(vl,vr);\n    }\n};\n\nint N,H;\nint d[100000],h[100000];\n\nsigned main(){\n    cin>>N>>H;\n    for(int i=0;i<N-1;i++)cin>>d[i]>>h[i];\n\n    seg_tree seg;\n    int cur=H;\n    int ans=0;\n    priority_queue<P>que;\n    for(int i=0;i<N-1;i++){\n        seg.add(i,i+1,cur);\n        cur-=d[i];\n\n        que.push(P(h[i],i));\n\n        while(cur<=0){\n            if(que.size()==0)return 0;\n            P p=que.top();que.pop();\n            int ma=seg.get_max(p.second,i+1);\n            if(p.first+ma>H){\n                que.push(P(H-ma,p.second));\n                continue;\n            }\n            if(p.first==0)continue;\n            int x=min(abs(cur)/p.first+1,(H-ma)/p.first);\n            ans+=x;\n            cur+=x*p.first;\n            seg.add(p.second,i+1,p.first*x);\n        }\n    }\n\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <math.h>\n#include <utility>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\n\nvector<int> di;\t\t\t//下りるときに消費する体力\nvector<int> hi;\t\t\t//その階の泉の回復量\n\nint main(){\n\tint n;\n\tint h;\n\tcin >> n >> h;\n\tint k = 0;\n\tfor ( int i = 0; i < n - 1; i++ ) {\n\t\tcin >> k;\n\t\tdi.push_back(k);\n\t\tcin >> k;\n\t\thi.push_back(k);\n\t}\n\tk = 0;\t\t\t\t//今いる階\n\tint l = h;\t\t\t//今の体力\n\tint s = 0;\t\t\t//泉を使った回数\n\twhile(true) {\n\t\tint x = l;\t\t//どこまで下にいけるか調べるための仮の体力\n\t\tint y = 0;\t\t//何回下まで行くか\n\t\tint z = 0;\t\t//その目的の階での回復量\n\t\tfor ( int i = 0; true; i++ ) {\n\t\t\tif ( k + i == n - 1 ) {\t\t//今の体力で一番下まで行けるなら終わり\n\t\t\t\ty = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( min( h-x, hi[ k+i ] ) >= z ) {\n\t\t\t\ty = i;\n\t\t\t\tz = min( h-x, hi[ k+i ] );\n\t\t\t}\n\t\t\tif ( x <= di[ k+i ] ) break;\n\t\t\tx -= di[ k+i ];\n\t\t}\n\t\tif ( k + y == n-1 ) break;\n\t\tfor ( int i = 0; i < y; i++ ) {\n\t\t\tl -= di[ k+i ];\n\t\t}\n\t\tk += y;\n\t\tl = min( h, l + hi[k] );\n\t\ts++;\n\t}\n\tcout << s << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long N, H, a[100009], b[100009], s[100009], sum, G, sx = 1, cx = 1;\n\nint main() {\n\tcin >> N >> H;\n\tfor (int i = 1; i <= N - 1; i++) cin >> a[i] >> b[i];\n\ts[1] = H; for (int i = 2; i <= N; i++) s[i] = s[i - 1] - a[i - 1];\n\n\t//for(int i=1;i<=N;i++) cout<<s[i]<<\" \";cout<<endl;\n\twhile (true) {\n\t\twhile (sx <= N && G + s[sx] >= 1) sx++; if (sx > N) break;\n\t\tlong long maxn = 0, maxid = 0;\n\t\tfor (int j = cx; j < sx; j++) {\n\t\t\tlong long cost = min(b[j], H - (G + s[j]));\n\t\t\tif (maxn < cost) { maxn = cost; maxid = j; }\n\t\t}\n\t\tlong long B = (H - (G + s[maxid])) / maxn;\n\t\tlong long B2 = (-(s[sx] + G) + maxn) / maxn; B = min(B, B2);//cout<<B<<endl;\n\t\t//cout<<G<<\" \"<<sx<<\" \"<<maxn<<\" \"<<maxid<<\" \"<<B<<\" \"<<sum<<endl;\n\t\tsum += B; G += maxn * B;\n\t\tcx = maxid;\n\t}\n\tcout << sum << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef long long ll;\n\nconst int INF = 100000000;\nint n, h;\nint segMax[100000*4], segAdd[100000*4];\n\nvoid add(int a, int b, int x, int k, int l, int r){\n\tif(r <= a || b <= l) return;\n\t\n\tif(a <= l && r <= b){\n\t\tsegAdd[k] += x;\n\t\twhile(k){\n\t\t\tk = (k-1)/2;\n\t\t\tsegMax[k] = max(segMax[k*2+1]+segAdd[k*2+1], segMax[k*2+2]+segAdd[k*2+2]);\n\t\t}\n\t\treturn;\n\t}\n\t\n\tadd(a,b,x,k*2+1,l,(l+r)/2);\n\tadd(a,b,x,k*2+2,(l+r)/2,r);\n}\n\nint getMax(int a, int b, int k, int l, int r){\n\tif(r <= a || b <= l) return 0;\n\tif(a <= l && r <= b) return (segMax[k]+segAdd[k]);\n\tint left = getMax(a,b,k*2+1,l,(l+r)/2);\n\tint right = getMax(a,b,k*2+2,(l+r)/2,r);\n\t\n\treturn (max(left,right)+segAdd[k]);\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&h);\n\tint hp = h;\n\tll ans = 0;\n\tpriority_queue<P> que;\n\tfor(int i = 0; i < n-1; i++){\n\t\tint a, b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tadd(i,i+1,hp,0,0,n);\n\t\tque.push(P(min(b,h-hp),i));\n\t\thp -= a;\n\t\twhile(hp <= 0){\n\t\t\tP p = que.top();\n\t\t\tque.pop();\n\t\t\tint sm = getMax(p.second, i+1, 0, 0, n);\n\t\t\t\n\t\t\tif(sm+p.first > h){\n\t\t\t\tp.first = h-sm;\n\t\t\t\tque.push(p);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tint num = min((-1*hp)/p.first + 1, (h-sm)/p.first);\n            ans += num;\n            hp += num*p.first;\n             \n            add(p.second, i + 1, num * p.first, 0, 0, n);\n            que.push(p);\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <iterator>\n#include <list>\n#include <map>\n#include <queue>\n#include <bitset>\n#include <fstream>\n#include <cmath>\nusing namespace std;\ntypedef long long ll;\n\nint main()\n{\n\tll N, H, R = 0;\n\tpriority_queue<long>  spring;\n\tcin>>N>>H;\n\tfor(int i = 0; i < N; i++){\n\t\tint d, h;\n\t\tcin>>d>>h;\n\t\tspring.push(h);\n\t\tH -= d;\n\n\t\twhile(!spring.empty() && H < 1){\n\t\t\tH += spring.top();\n\t\t\tspring.pop();\n\t\t\tR++;\n\t\t}\n\t}\n\tcout<<R<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int>P;\nconst int SIZE=1<<17;\n\nstruct seg_tree{\n    vector<int>ma,lazy;\n\n    seg_tree():ma(SIZE*2-1,0),lazy(SIZE*2-1,0){}\n\n    void evaluate(int k){\n        ma[k]+=lazy[k];\n        if(k<SIZE-1){\n            lazy[k*2+1]+=lazy[k];\n            lazy[k*2+2]+=lazy[k];\n        }\n        lazy[k]=0;\n    }\n    void update_node(int k){\n        ma[k]=max(ma[k*2+1],ma[k*2+2]);\n    }\n\n    void add(int a,int b,int x,int k=0,int l=0,int r=SIZE){\n        evaluate(k);\n        if(r<=a||b<=l)return;\n        if(a<=l&&r<=b){\n            lazy[k]+=x;\n            evaluate(k);\n            return;\n        }\n        int m=(l+r)/2;\n        add(a,b,x,k*2+1,l,m);\n        add(a,b,x,k*2+2,m,r);\n        update_node(k);\n    }\n\n    int get_max(int a,int b,int k=0,int l=0,int r=SIZE){\n        evaluate(k);\n        if(r<=a||b<=l)return 0;\n        if(a<=l&&r<=b)return ma[k];\n        int m=(l+r)/2;\n        int vl=get_max(a,b,k*2+1,l,m);\n        int vr=get_max(a,b,k*2+2,m,r);\n        return max(vl,vr);\n    }\n};\n\nint N,H;\nint d[100000],h[100000];\n\nint main(){\n    cin>>N>>H;\n    for(int i=0;i<N;i++)cin>>d[i]>>h[i];\n\n    seg_tree seg;\n    int cur=H;\n    int ans=0;\n    priority_queue<P>que;\n    for(int i=0;i<N-1;i++){\n        seg.add(i,i+1,cur);\n        cur-=d[i];\n\n        que.push(P(h[i],i));\n\n        while(cur<=0){\n            P p=que.top();que.pop();\n            int ma=seg.get_max(p.second,i+1);\n            if(p.first+ma>H){\n                que.push(P(H-ma,p.second));\n                continue;\n            }\n\n            int x=min((-cur)/p.first+1,(H-ma)/p.first);\n            ans+=x;\n            cur+=x*p.first;\n            seg.add(p.second,i+1,p.first*x);\n        }\n    }\n\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Bokan ga bokka--nn!!\n//Daily Lunch Special Tanoshii !!\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\n#include <deque>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\ntypedef long long ll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\n#define s(x) scanf(\"%d\",&x)\n#define rep(i,x) for(int i=0;i<x;i++)\nint main()\n{\n\tint n;\n\tll maxv;\n\tscanf(\"%d %lld\",&n,&maxv);\n\tll totv=maxv;\n\tll totd=0LL;\n\tdeque<pair<ll,ll> >deq;\n\tll ret=0LL;\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tll a,b;\n\t\tscanf(\"%lld %lld\",&a,&b);\n\t\twhile(!deq.empty() && deq.back().first<=b) deq.pop_back();\n\t\tdeq.pb(mp(b,totd));\n//printf(\"%d %d %lld %lld %lld\\n\",i,deq.size(),totv,totd,ret);\n\t\ttotd+=a;\n\t\tif(totv<=totd)\n\t\t{\n\t\t\tll s=0ll;\n\t\t\twhile(!deq.empty())\n\t\t\t{\n\t\t\t\tif(totv+deq.front().first-deq.front().second>maxv)\n\t\t\t\t{\n\t\t\t\t\ts=max(s,maxv-(totv-deq.front().second));\n\t\t\t\t\tdeq.pop_front();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tll kai=deq.front().first;\n\t\t\tll prev=deq.front().second;\n\t\t\tif(deq.empty() || s>kai)\n\t\t\t{\n\t\t\t\tret++;\n\t\t\t\ttotv+=s;\n\t\t\t\tif(totv<=totd)\n\t\t\t\t{\n\t\t\t\t\tret+=(totd-totv+kai)/kai;\n\t\t\t\t\ttotv+=((totd-totv+kai)/kai)*kai;\n\t\t\t\t\ttotv=min(totv,maxv+prev);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tret+=(totd-totv+kai)/kai;\n\t\t\t\ttotv+=((totd-totv+kai)/kai)*kai;\n\t\t\t\ttotv=min(totv,maxv+prev);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define mp(a,b) make_pair((a),(b))\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nstruct Dungeon{\n\tint plus,pos;\n\n\tbool operator<(const Dungeon &d)const{\n\t\tif(plus!=d.plus) return plus<d.plus;\n\t\telse pos<d.pos;\n\t}\n};\n\nstruct SegmentTree{\n\tint sz;\n\tvector<int> val,lazy;\n\n\tSegmentTree(int n){\n\t\tInit(n);\n\t}\n\n\tvoid Init(int n){\n\t\tsz=1;\n\t\twhile(sz<n) sz*=2;\n\t\tval.assign(sz*2-1,0);\n\t\tlazy.assign(sz*2-1,0);\n\t}\n\n\tinline void Evaluate(int k){\n\t\tval[k]+=lazy[k];\n\t\tif(k<sz-1){\n\t\t\tlazy[k*2+1]+=lazy[k];\n\t\t\tlazy[k*2+2]+=lazy[k];\n\t\t}\n\t\tlazy[k]=0;\n\t}\n\n\tvoid Update(int k){\n\t\tval[k]=max(val[k*2+1],val[k*2+2]);\n\t}\n\n\tvoid Add(int a,int b,int x,int k,int l,int r){\n\t\tEvaluate(k);\n\n\t\tif(r<=a||b<=l) return;\n\t\tif(a<=l&&r<=b){\n\t\t\tlazy[k]+=x;\n\t\t\tEvaluate(k);\n\t\t\treturn;\n\t\t}\n\n\t\tAdd(a,b,x,k*2+1,l,(l+r)/2);\n\t\tAdd(a,b,x,k*2+2,(l+r)/2,r);\n\t\tUpdate(k);\n\t}\n\n\tvoid Add(int a,int b,int x){\n\t\tAdd(a,b,x,0,0,sz);\n\t}\n\n\tint Max(int a,int b,int k,int l,int r){\n\t\tEvaluate(k);\n\n\t\tif(r<=a||b<=l) return 0;\n\t\tif(a<=l&&r<=b) return val[k];\n\n\t\tint lv=Max(a,b,k*2+1,l,(l+r)/2);\n\t\tint rv=Max(a,b,k*2+2,(l+r)/2,r);\n\t\tUpdate(k);\n\n\t\treturn max(lv,rv);\n\t}\n\n\tint Max(int a,int b){\n\t\treturn Max(a,b,0,0,sz);\n\t}\n};\n\n\nvoid Solve(){\n\tint n,h,di[100000],hi[100000],life;\n\n\tcin >> n >> h;\n\trep(i,0,n-1) cin >> di[i] >> hi[i];\n\n\tlife=h;\n\n\tll ans=0;\n\tSegmentTree st(n);\n\tpriority_queue<Dungeon> que;\n\trep(i,0,n-1){\n\t\tst.Add(i,i+1,life);\n\t\tDungeon in;\n\t\tlife-=di[i];\n\n\t\tin.plus=hi[i];\n\t\tin.pos=i;\n\n\t\tque.push(in);\n\t\twhile(life<=0){\n\t\t\tDungeon heal=que.top();\n\t\t\tque.pop();\n\n\t\t\tint maxi=st.Max(heal.pos,i+1);\n\n\t\t\tif(heal.plus+maxi>h){\n\t\t\t\theal.plus=h-maxi;\n\t\t\t\tque.push(heal);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint num=min((-1*life)/heal.plus+1,(h-maxi)/heal.plus);\n\t\t\tans+=num;\n\t\t\tlife+=num*heal.plus;\n\n\t\t\tst.Add(heal.pos,i+1,num*heal.plus);\n\t\t\tque.push(heal);\n\t\t}\n\t}\n\n\tcout << ans << endl;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 28;\ntypedef pair<int, int> Pr;\n\nint N, H;\nint d[100000], h[100000];\n\nconst int size = 1 << 20;\nint seg_v[size * 2 - 1];\nint seg_a[size * 2 - 1];\nPr rmq[size * 2 - 1];\n\nvoid seg_add(int l, int r, int x, int k = 0, int a = 0, int b = size){\n\tif (b <= l || r <= a) return;\n\tif (l <= a && b <= r){\n\t\tseg_a[k] += x;\n\t\twhile (k){\n\t\t\tk = (k - 1) / 2;\n\t\t\tseg_v[k] = max(\n\t\t\t\tseg_v[k * 2 + 1] + seg_a[k * 2 + 1],\n\t\t\t\tseg_v[k * 2 + 2] + seg_a[k * 2 + 2]\n\t\t\t);\n\t\t}\n\t\treturn;\n\t}\n\t\n\tint m = (a + b) / 2;\n\tseg_add(l, r, x, k * 2 + 1, a, m);\n\tseg_add(l, r, x, k * 2 + 2, m, b);\n}\nint seg_getMax(int l, int r, int k = 0, int a = 0, int b = size){\n\tif (b <= l || r <= a) return -INF;\n\tif (l <= a && b <= r) return seg_a[k] + seg_v[k];\n\tint m = (a + b) / 2;\n\tint vl = seg_getMax(l, r, k * 2 + 1, a, m);\n\tint vr = seg_getMax(l, r, k * 2 + 2, m, b);\n\treturn seg_a[k] + max(vl, vr);\n}\n\nvoid rmq_update(int k, int x){\n\tint i = k;\n\tk += size - 1;\n\trmq[k] = Pr(x, i);\n\twhile (k){\n\t\tk = (k - 1) / 2;\n\t\trmq[k] = max(rmq[k * 2 + 1], rmq[k * 2 + 2]);\n\t}\n}\nPr _rmq_getMax(int l, int r, int k = 0, int a = 0, int b = size){\n\tif (b <= l || r <= a) return Pr(-INF, -1);\n\tif (l <= a && b <= r) return rmq[k];\n\tint m = (a + b) / 2;\n\tPr vl = _rmq_getMax(l, r, k * 2 + 1, a, m);\n\tPr vr = _rmq_getMax(l, r, k * 2 + 2, m, b);\n\treturn max(vl, vr);\n}\nint rmq_getMax(int l, int r){\n\treturn _rmq_getMax(l, r).first;\n}\nint rmq_getMaxIdx(int l, int r){\n\treturn _rmq_getMax(l, r).second;\n}\n\nvoid solve()\n{\n\tlong long int res = 0;\n\t\n\tfor (int i = 0; i < N; i++){\n\t\trmq_update(i, h[i]);\n\t}\n\t\n\tseg_add(0, N, H);\n\t\n\tfor (int fl = 0; fl < N; fl++){\n\t\tif (seg_getMax(fl, fl + 1) > H){\n\t\t\tseg_add(fl, N, H - seg_getMax(fl, fl + 1));\n\t\t}\n\t\t\n\t\tseg_add(fl, N, -d[fl]);\n\t\t//printf(\"%dF HP=%d\\n\", fl, seg_getMax(fl, fl + 1));\n\t\tif (seg_getMax(fl, fl + 1) > 0) continue;\n\t\t\n\t\twhile (true){\n\t\t\tint idx = rmq_getMaxIdx(0, fl);\n\t\t\tif (h[idx] > H - seg_getMax(idx, fl)){\n\t\t\t\th[idx] = H - seg_getMax(idx, fl);\n\t\t\t\trmq_update(idx, h[idx]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t/*\n\t\t\tseg_add(idx, N, h[idx]);\n\t\t\tres++;\n\t\t\tif (seg_getMax(fl, fl + 1) > 0) break;\n\t\t\t*/\n\t\t\t\n\t\t\tint t = H - seg_getMax(idx, fl);\n\t\t\tint num = t / h[idx];\n\t\t\tseg_add(idx, N, h[idx] * num);\n\t\t\tres += num;\n\t\t\tif (seg_getMax(fl, fl + 1) > 0) break;\n\t\t}\n\t\t\n\t\t//printf(\"%dF HP=%d\\n\", fl, seg_getMax(fl, fl + 1));\n\t}\n\t\n\tprintf(\"%lld\\n\", res);\n}\n\nint main()\n{\n\tscanf(\"%d %d\", &N, &H);\n\tfor (int i = 0; i < N - 1; i++){\n\t\tscanf(\"%d %d\", d + i + 1, h + i);\n\t}\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <algorithm>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef struct {\n    int plus, pos;\n} Dungeon;\n \nbool operator < (const Dungeon &a, const Dungeon &b)\n{\n    if (a.plus != b.plus){\n        return (a.plus < b.plus);\n    }\n    else {\n        return (a.pos < b.pos);\n    }\n}\nint data[1 << 18], datb[1 << 18];\n\nint getMax(int a, int b, int k, int l, int r)\n{\n\tif (b <= l || r <= a) return (0);\n\tif (a <= l && r <= b){\n\t\treturn (data[k] + datb[k]);\n\t}\n\t\n\tint lch = getMax(a, b, k * 2 + 1, l, (l + r) / 2);\n\tint rch = getMax(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\n\treturn (max(lch, rch) + datb[k]);\n}\n\nvoid add(int a, int b, int x, int k, int l, int r)\n{\n\tif (b <= l || r <= a) return;\n\t\n\tif (a <= l && r <= b){\n\t\tdatb[k] += x;\n\t\twhile (k){\n\t\t\tk = (k - 1) / 2;\n\t\t\tdata[k] = max(data[k * 2 + 1] + datb[k * 2 + 1], data[k * 2 + 2] + datb[k * 2 + 2]);\n\t\t}\n\t}\n\telse {\n\t\tadd(a, b, x, k * 2 + 1, l, (l + r) / 2);\n\t\tadd(a, b, x, k * 2 + 2, (l + r) / 2, r);\n\t}\n}\n\nint main(void)\n{\n    int N, H;\n    int di[100000], hi[100000];\n    int curLife;\n     \n    scanf(\"%d %d\", &N, &H);\n    \n    for (int i = 0; i < N - 1; i++){\n        scanf(\"%d %d\", &di[i], &hi[i]);\n    }\n     \n    curLife = H;\n     \n    ll ans = 0;\n    priority_queue<Dungeon> que;\n    for (int i = 0; i < N - 1; i++){\n\t\tadd(i, i + 1, curLife, 0, 0, 1 << 17);\n        Dungeon in;\n        curLife -= di[i];\n         \n        in.plus = hi[i];\n        in.pos = i;\n         \n        que.push(in);\n        while (curLife <= 0){\n            Dungeon heal = que.top();\n            que.pop();\n            \n            int segMax = getMax(heal.pos, i + 1, 0, 0, 1 << 17);\n             \n            if (heal.plus + segMax > H){\n                heal.plus = H - segMax;\n                que.push(heal);\n                continue;\n            }\n             \n            int howMany = min((-1 * curLife) / heal.plus + 1, (H - segMax) / heal.plus);\n            ans += howMany;\n            curLife += howMany * heal.plus;\n             \n            add(heal.pos, i + 1, howMany * heal.plus, 0, 0, 1 << 17);\n            que.push(heal);\n        }\n    }\n     \n    printf(\"%lld\\n\", ans);\n     \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\n  \nint main()\n{\n  int64 N, H, d[100000], h[100000];\n  \n  cin >> N >> H;\n  for(int i = 0; i < N - 1; i++) {\n    cin >> d[i] >> h[i];\n  }\n  \n  \n  int64 power = H , ret = 0LL;\n  int64 hill[100000];\n  int64 now[100000];\n  for(int i = 0; i < N - 1; i++) hill[i] = h[i];\n  \n  \n  for(int i = 0; i < N - 1; i++) {\n    now[i] = power;\n    power -= d[i];\n    while(power <= 0) {\n      int MaxPos = i;\n      int64 hoge = H;\n      for(int j = i; j >= 0; j--) {\n        hoge = min(hoge, H - now[j]);\n        h[j] = min(h[j], hoge);\n        if(h[MaxPos] < h[j]) MaxPos = j;\n        if(hoge == 0) break;\n      }\n \n      int64 hori = min(-power / h[MaxPos] + 1, (H - now[MaxPos]) / h[MaxPos]);\n      ret += hori;\n      power += hori * h[MaxPos];\n      for(int j = MaxPos; j <= i; j++) {\n        now[j] += hori * h[MaxPos];\n        now[j] = min(now[j], H);\n      }\n    }\n  }\n \n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)x.size())\n\nusing namespace std;\n\nstruct timer{\n\ttime_t start;\n\ttimer(){start=clock();}\n\t~timer(){cerr<<1.*(clock()-start)/CLOCKS_PER_SEC<<\" secs\"<<endl;}\n};\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\nll N,H,d[100010],h[100010],sumd[100010];\n\nstruct segtree{\n\tll x;\n\tint l,r;\n\tsegtree *cl,*cr;\n\t\n\tsegtree(int l,int r): l(l),r(r){\n\t\tif(l+1==r){\n\t\t\tx=h[l];\n\t\t\treturn;\n\t\t}\n\t\tcl=new segtree(l,l+r>>1);\n\t\tcr=new segtree(l+r>>1,r);\n\t\tx=max(cl->x,cr->x);\n\t}\n\t\n\tvoid change(int pos,ll v){\n\t\tif(pos<l || r<=pos){\n\t\t\treturn;\n\t\t}\n\t\tif(l+1==r){\n\t\t\tx=v;\n\t\t\treturn;\n\t\t}\n\t\tcl->change(pos,v);\n\t\tcr->change(pos,v);\n\t\tx=max(cl->x,cr->x);\n\t}\n\t\n\tll query(int L,int R,int& ind){\n\t\tif(R<=l || r<=L){\n\t\t\treturn -INF*INF;\n\t\t}\n\t\tif(l+1==r){\n\t\t\tind=l;\n\t\t\treturn x;\n\t\t}\n\t\tint ind1,ind2;\n\t\tll res1 = cl->query(L,R,ind1);\n\t\tll res2 = cr->query(L,R,ind2);\n\t\tif(res1 >= res2){\n\t\t\tind=ind1;\n\t\t\treturn res1;\n\t\t}\n\t\tind=ind2;\n\t\treturn res2;\n\t}\n} *root;\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\tcin>>N>>H;\n\trep(i,N-1){\n\t\tcin>>d[i]>>h[i];\n\t\tsumd[i+1]=sumd[i]+d[i];\n\t}\n\troot=new segtree(0,N-1);\n\tll ans=0,hp=H,from=0;\n\trep(i,N-1){\n\t\thp-=d[i];\n\t\t//cout<<hp<<\" \"<<ans<<\" \"<<from<<endl;\n\t\twhile(hp<=0){\n\t\t\tll need=1-hp;\n\t\t\tint ind;\n\t\t\tll maxi=root->query(from,i+1,ind);\n\t\t\tfrom=ind;\n\t\t\tll HPpre=hp+sumd[i+1]-sumd[ind];\n\t\t\t//cout<<hp<<\" \"<<HPpre<<endl;\n\t\t\t//cout<<from<<\" - \"<<i<<\" : \"<<maxi<<\"(\"<<ind<<\")\"<<endl;\n\t\t\tll maxtime=(H-HPpre)/maxi;\n\t\t\tll want=(need+maxi-1)/maxi;\n\t\t\t//cout<<maxtime<<\" \"<<want<<endl;\n\t\t\tif(want <= maxtime){\n\t\t\t\tans+=want;\n\t\t\t\thp+=want*maxi;\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\tll rest=(H-HPpre)%maxi;\n\t\t\t\troot->change(ind,rest);\n\t\t\t\tans+=maxtime;\n\t\t\t\thp+=maxtime*maxi;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <deque>\n#include <utility>\n#include <algorithm>\nusing namespace std;\nint main() {\n\tlong long int n,total_h,max_h,total_d=0,ans=0;\n\tscanf(\"%lld %lld\",&n,&total_h);\n\tmax_h=total_h;\n\tdeque<pair<long long int,long long int> > Q;\n\tfor(int i=0;i<n-1;i++) {\n\t\tlong long int d,h;\n\t\tscanf(\"%lld %lld\",&d,&h);\n\t\twhile(!Q.empty()&&Q.back().first<=h)\n\t\t\tQ.pop_back();\n\t\tQ.push_back(make_pair(h,total_d));\n\t\ttotal_d+=d;\n\t\twhile(total_h<=total_d) {\n\t\t\tlong long int tmp_h=total_h;\n\t\t\twhile(!Q.empty()&&tmp_h+Q.front().first-Q.front().second>max_h) {\n\t\t\t\ttotal_h=max(total_h,Q.front().second+max_h);\n\t\t\t\tQ.pop_front();\n\t\t\t}\n\t\t\tif(!Q.empty()) {\n\t\t\t\ttotal_h=max(total_h,tmp_h+Q.front().first);\n\t\t\t\tlong long int tmp=max(0LL,min((total_d-total_h)/Q.front().first,(Q.front().second+max_h-total_h)/Q.front().first));\n\t\t\t\tans+=tmp;\n\t\t\t\ttotal_h+=tmp*Q.front().first;\n\t\t\t}\n\t\t\tans++;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  struct Level {int d, h;};\n  int N, H;\n  cin >> N >> H;\n  vector<Level> level(N - 1);\n  for(auto& i: level) cin >> i.d >> i.h;\n\n  // -???, ???, HP\n  typedef tuple<int, int, int> Node;\n  priority_queue<Node> q;\n  q.emplace(0, 0, H);\n  while(!q.empty()) {\n    int healed, f, hp;\n    tie(healed, f, hp) = q.top();\n    q.pop();\n    if(f == N - 1) {\n      cout << -healed << endl;\n      return 0;\n    }\n    if(0 < hp - level[f].d) q.emplace(healed, f + 1, hp - level[f].d);\n    while(hp < H) {\n      hp = min(H, hp + level[f].h);\n      --healed;\n      if(0 < hp - level[f].d) q.emplace(healed, f + 1, hp - level[f].d);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\nint di[100000];\nint hi[100000];\nll damage[100001];\n\nint main() {\n  int N,H;\n  scanf(\"%d%d\",&N,&H);\n  REP(i,N-1) scanf(\"%d%d\",di+i,hi+i);\n  priority_queue<pii> Q;\n  ll ans = 0;\n  ll totalHeal = 0;\n  int maxid = 0;\n  REP(i,N-1) {\n    Q.push(pii(hi[i],i));\n    damage[i+1] = damage[i] + di[i];\n    ll now = H + totalHeal - damage[i+1];\n    while(now <= 0) {\n      pii p = Q.top(); Q.pop();\n      int heal = p.first;\n      int id = p.second;\n\n      if (id < maxid) continue;\n      maxid = id;\n      ll tdamage = damage[id]-totalHeal;\n      if (tdamage < heal) {\n        Q.push(pii(tdamage,id));\n        continue;\n      }\n      ll num = min((0-now)/heal+1, tdamage/heal);\n      totalHeal += num*heal;\n      now += num*heal;\n      ans += num;\n      Q.push(p);\n    }\n  }\n  printf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;++i)\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\nll data[1<<18],datb[1<<18];\n\nvoid add(int a,int b,ll x,int k=0,int l=0,int r=(1<<17)){\n\tif(r<=a||b<=l) return;\n\tif(a<=l&&r<=b){\n\t\tdatb[k]+=x;\n\t\twhile(k){\n\t\t\tk=(k-1)/2;\n\t\t\tdata[k]=max(data[k*2+1]+datb[k*2+1],data[k*2+2]+datb[k*2+2]);\n\t\t}\n\t\treturn;\n\t}\n\tadd(a,b,x,k*2+1,l,(l+r)/2);\n\tadd(a,b,x,k*2+2,(l+r)/2,r);\n}\n\nint qry(int a,int b,int k=0,int l=0,int r=(1<<17)){\n\tif(r<=a||b<=l) return 0;\n\tif(a<=l&&r<=b){\n\t\treturn data[k]+datb[k];\n\t}\n\tll vl=qry(a,b,k*2+1,l,(l+r)/2);\n\tll vr=qry(a,b,k*2+2,(l+r)/2,r);\n\treturn max(vl,vr)+datb[k];\n}\n\nint main(void){\n\tint n,H;\n\tcin >> n >> H;\n\tpriority_queue<pii> q;\n\tll cur=H,ans=0;\n\trep(i,n-1){\n\t\tadd(i,i+1,cur);\n\t\tll d,h;\n\t\tcin >> d >> h;\n\t\tcur-=d;\n\t\tq.push(make_pair(h,i));\n\t\twhile(cur<=0){\n\t\t\tpii heal=q.top();q.pop();\n\t\t\tll cmax=qry(heal.second,i+1);\n\t\t\tif(heal.first+cmax>H){\n\t\t\t\theal.first=H-cmax;\n\t\t\t\tq.push(heal);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tll num=min(-cur/heal.first+1,(H-cmax)/heal.first);\n\t\t\tans+=num;\n\t\t\tcur+=heal.first*num;\n\t\t\tadd(heal.second,i+1,num*heal.first);\n\t\t\tq.push(heal);\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nint d[200000],t[200000];\nll sum[200000];\n\nint dat[400000],N;\nvoid init(int n_){\n\tN=1;while(N<n_)N<<=1;\n\tfor(int i=2*N-2;i>=0;i--){\n\t\tif(i>=N-1)dat[i]=(i-N+1>=n_?0:t[i-N+1]);\n\t\telse dat[i]=max(dat[i*2+1],dat[i*2+2]);\n\t}\n}\nint query(int a,int b,int k,int l,int r){\n\tif(b<=l||r<=a)return 0;\n\tif(a<=l&&r<=b)return dat[k];\n\treturn max(query(a,b,k*2+1,l,(l+r)/2),query(a,b,k*2+2,(l+r)/2,r));\n}\n\nint main(){\n\tint n,h;scanf(\"%d%d\",&n,&h);\n\trep(i,n-1){\n\t\tscanf(\"%d%d\",&d[i],&t[i]);\n\t\tsum[i]=d[i];\n\t\tif(i)sum[i]+=sum[i-1];\n\t}\n\tinit(n);\n\tint p=h;\n\tll cnt=0;\n\trep(i,n-1){\n\t\t//増加分がtになるとき\n\t\tint l=i,r=n-1;\n\t\twhile(r-l>1){\n\t\t\tint mid=(l+r)/2;\n\t\t\tif(query(i+1,mid+1,0,0,N)<t[i])l=mid;\n\t\t\telse r=mid;\n\t\t}\n\t\t//そこまでに必要な体力\n\t\tll b=sum[l]-(i?sum[i-1]:0);\n\t\tint a=min((h-p)/(ll)t[i],max(0LL,(b+t[i]-1-p)/t[i]));\n\t\tcnt+=a;\n\t\tp=min(h,p+a*t[i]);\n\t\t//あまり\n\t\tint c=min(h-p,t[i]);\n\t\tint j=lower_bound(sum,sum+n-1,(i?sum[i-1]:0)+p)-sum;\n\t\tif(j==n-1){\n\t\t\tcout<<cnt<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif(i==j||query(i+1,j+1,0,0,N)<c){\n\t\t\tcnt++;\n\t\t\tp+=c;\n\t\t}\n\t\tp-=d[i];\n\t}\n\tcout<<cnt<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef pair<int,int>P;\nconst int SIZE=1<<17;\n\nstruct seg_tree{\n    vector<int>ma,lazy;\n\n    seg_tree():ma(SIZE*2-1,0),lazy(SIZE*2-1,0){}\n\n    void evaluate(int k){\n        ma[k]+=lazy[k];\n        if(k<SIZE-1){\n            lazy[k*2+1]+=lazy[k];\n            lazy[k*2+2]+=lazy[k];\n        }\n        lazy[k]=0;\n    }\n    void update_node(int k){\n        ma[k]=max(ma[k*2+1],ma[k*2+2]);\n    }\n\n    void add(int a,int b,int x,int k=0,int l=0,int r=SIZE){\n        evaluate(k);\n        if(r<=a||b<=l)return;\n        if(a<=l&&r<=b){\n            lazy[k]+=x;\n            evaluate(k);\n            return;\n        }\n        int m=(l+r)/2;\n        add(a,b,x,k*2+1,l,m);\n        add(a,b,x,k*2+2,m,r);\n        update_node(k);\n    }\n\n    int get_max(int a,int b,int k=0,int l=0,int r=SIZE){\n        evaluate(k);\n        if(r<=a||b<=l)return 0;\n        if(a<=l&&r<=b)return ma[k];\n        int m=(l+r)/2;\n        int vl=get_max(a,b,k*2+1,l,m);\n        int vr=get_max(a,b,k*2+2,m,r);\n        return max(vl,vr);\n    }\n};\n\nint N,H;\nint d[100000],h[100000];\n\nsigned main(){\n\n    cin>>N>>H;\n    for(int i=0;i<N-1;i++)cin>>d[i]>>h[i];\n\n    seg_tree seg;\n    int cur=H;\n    int ans=0;\n    priority_queue<P>que;\n    for(int i=0;i<N-1;i++){\n        seg.add(i,i+1,cur);\n        cur-=d[i];\n\n        que.push(P(h[i],i));\n\n        while(cur<=0){\n            if(que.size()==0)return 0;\n            P p=que.top();que.pop();\n            int ma=seg.get_max(p.second,i+1);\n            if(p.first+ma>H){\n                que.push(P(H-ma,p.second));\n                continue;\n            }\n            if(p.first==0)continue;\n            int val=min(p.first,H-ma);\n            int x=min(abs(cur)/val+1,(H-ma)/val);\n            ans+=x;\n            cur+=x*val;\n            seg.add(p.second,i+1,val*x);\n        }\n    }\n\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n\n#define SIZE 100005\n\n\nint N;\nll max_HP,HP;\nll damage[SIZE],sum_damage[SIZE],recovery[SIZE];\n\nint main(){\n\n\tscanf(\"%d %lld\",&N,&max_HP);\n\n\tsum_damage[0] = 0;\n\n\tfor(int i = 0; i < N-1; i++){\n\n\t\tscanf(\"%lld %lld\",&damage[i],&recovery[i]);\n\n\t\tif(damage[i] >= max_HP){\n\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tsum_damage[i+1] = sum_damage[i]+damage[i]; //累積和にする\n\t}\n\n\tdeque<int> DEQ;\n\n\tll ans = 0;\n\tHP = max_HP;\n\n\tfor(int i = 0; i <= N-2; i++){\n\n\t\t/*過去に、【とある階で回復していた】ことに【変更】する場合、【既に食らったダメージ】を再び被ることはないので、\n\t\t * ■■■無駄(=上限による回復の打ち切り)が発生しない限り■■■、回復量が大きい泉で回復していたことにするのが良いはず。\n\t\t * HPの折れ線グラフを、より少ない回数で、必要な分だけ上にシフトさせるということ★*/\n\n\t\twhile(DEQ.empty() == false && recovery[DEQ.back()] <= recovery[i]){\n\n\t\t\tDEQ.pop_back(); //回数の最小化を図っているので、階iの回復量以下の泉は不要。過去使っていたことにすると損になるため\n\t\t}\n\t\tDEQ.push_back(i); //この階の泉\n\n\t\twhile(DEQ.empty() == false && sum_damage[i]-sum_damage[DEQ.front()] >= max_HP){\n\t\t\t/*最大HP以上に、移動の間に体力を失うならば、もうその泉は忘れて良い\n\t\t\t * →仮にその泉で完全回復したとしても、現在の体力が増えないため*/\n\n\t\t\tDEQ.pop_front();\n\t\t}\n\n\t\tif(HP <= damage[i]){ //何もしなければ死ぬ場合\n\n\t\t\tfor(int k = 0; k < DEQ.size(); k++){\n\n\t\t\t\tll theory_max = max_HP-(sum_damage[i]-sum_damage[DEQ[k]]); //階DEQ[k]で完全回復した場合に、今のHPがいくらになっているか\n\n\t\t\t\tif(theory_max <= HP){\n\t\t\t\t\t/*\n\t\t\t\t\t * 仮に階DEQ[k]で完全回復したとしても現在のHPは増えないのでSKIP\n\t\t\t\t\t * */\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tll need_HP = damage[i]+1; //死なないために必要な最少の体力\n\n\t\t\t\tll limit = min(theory_max,need_HP)-HP; //今回の回復量の上限:回数の最小化を図るため\n\n\t\t\t\t/*DEQには回復量の降順にデータが入っており、かつ【過去の行動を変えたとしても、現在までに食らったダメージは変化しないため】\n\t\t\t\t * 【無駄が生じない限り】は、選択肢の中で最大の回復量を誇る階DEQ[k]で回復するのが最適なはず。\n\t\t\t\t * 上限の存在による【無駄】が発生した場合は、DEQ[k+1]で回復した方が\n\t\t\t\t * 現在のHPが高くなる可能性があるので、残りの【回復し切らなかった分(limitの残り)】について\n\t\t\t\t * 再帰的に調べる必要がある\n\t\t\t\t * HPの折れ線グラフは、無駄(上限による回復の打ち切り)を生じさせなかった場合、\n\t\t\t\t * 階DEQ[k]においてのHPは、ぴったりmax_HP,またはそれ未満になるはずであり、\n\t\t\t\t * その位置までグラフをシフトさせるための必要回数は、回復量が選択肢の中で最大であるが故に、\n\t\t\t\t * 最も効率が良いはず\n\t\t\t\t * */\n\n\t\t\t\tint count = limit/recovery[DEQ[k]];\n\t\t\t\tHP += recovery[DEQ[k]]*count; //★★★確定回復量★★★\n\t\t\t\tans += count;\n\n\t\t\t\tif(limit%recovery[DEQ[k]] == 0){ //階DEQ[k]で無駄が生じなかった場合\n\n\t\t\t\t\tif(HP == need_HP){ //十分回復\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}else{ //need_HPでないということはHP==theroy_maxであるはずなので、次の泉を見に行く\n\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//階DEQ[k]で無駄が生じた場合(回復しきらなかった分がある場合)\n\n\t\t\t\tif(k+1 == DEQ.size()){ //もう泉が残っていない場合→階iの泉→最後の一回もこの階で回復\n\n\t\t\t\t\tHP = min(HP+recovery[DEQ[k]],max_HP);\n\t\t\t\t\tans++;\n\n\t\t\t\t}else{ //最後の1回を、DEQ[k]での回復に使うべきか、DEQ[k+1]での回復に使うべきかを【再帰的に】検討する\n\n\t\t\t\t\t/*最後の1回を、階DEQ[k]での回復に充てる場合*/\n\t\t\t\t\tll past_HP = HP+(sum_damage[i]-sum_damage[DEQ[k]]); //階DEQ[k]でHPがいくつだったか【回復しきらなかった分があるため、max_HPではあり得ない】\n\t\t\t\t\tpast_HP = min(past_HP+recovery[DEQ[k]],max_HP); //あと1回、階DEQ[k]で回復した場合の、階DEQ[k]でのHP\n\t\t\t\t\tll tmp_HP = past_HP-(sum_damage[i]-sum_damage[DEQ[k]]); //この場合、現在(階i)のHPはいくつになるか\n\n\n\t\t\t\t\t/*最後の1回を、階DEQ[k+1]での回復に充てる場合*/\n\t\t\t\t\tll past_HP_next = HP+(sum_damage[i]-sum_damage[DEQ[k+1]]); //次の階でのHPがいくつあったか\n\t\t\t\t\tpast_HP_next = min(past_HP_next+recovery[DEQ[k+1]],max_HP);\n\n\t\t\t\t\tll tmp_HP_next = past_HP_next-(sum_damage[i]-sum_damage[DEQ[k+1]]); //階DEQ[k+1]で回復していたとしたら、現在のHPはいくつか\n\n\t\t\t\t\tif(tmp_HP >= tmp_HP_next){ //階DEQ[k]を採用した方が現在のHPが高くなる場合、または同じである場合\n\n\t\t\t\t\t\tans++; //階DEQ[k]でもう1回回復\n\t\t\t\t\t\tHP = tmp_HP;\n\n\t\t\t\t\t}else{\n\n\t\t\t\t\t\tcontinue; //判断を保留【再帰的に論理が伝播するため】\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(HP >= need_HP)break;\n\t\t\t}\n\t\t}\n\n\t\tHP -= damage[i];\n\n\t\tif(HP <= 0){\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef pair<int,int>P;\nconst int SIZE=1<<17;\n\nstruct seg_tree{\n    int N;\n    vector<int>ma,lazy;\n\n    seg_tree(int n){\n        N=1;\n        while(n>N)N*=2;\n        ma.resize(N*2-1,0);\n        lazy.resize(N*2-1,0);\n    }\n\n    void evaluate(int k){\n        ma[k]+=lazy[k];\n        if(k<N-1){\n            lazy[k*2+1]+=lazy[k];\n            lazy[k*2+2]+=lazy[k];\n        }\n        lazy[k]=0;\n    }\n\n    void update_node(int k){\n        ma[k]=max(ma[k*2+1],ma[k*2+2]);\n    }\n\n    void add(int a,int b,int x){add(a,b,x,0,0,N);}\n    void add(int a,int b,int x,int k,int l,int r){\n        evaluate(k);\n        if(r<=a||b<=l)return;\n        if(a<=l&&r<=b){\n            lazy[k]+=x;\n            evaluate(k);\n            return;\n        }\n        int m=(l+r)/2;\n        add(a,b,x,k*2+1,l,m);\n        add(a,b,x,k*2+2,m,r);\n        update_node(k);\n    }\n\n    int get_max(int a,int b){return get_max(a,b,0,0,N);}\n    int get_max(int a,int b,int k,int l,int r){\n        evaluate(k);\n        if(r<=a||b<=l)return 0;\n        if(a<=l&&r<=b)return ma[k];\n        int m=(l+r)/2;\n        int vl=get_max(a,b,k*2+1,l,m);\n        int vr=get_max(a,b,k*2+2,m,r);\n        return max(vl,vr);\n    }\n};\n\nint N,H;\nint d[100000],h[100000];\n\nsigned main(){\n\n    cin>>N>>H;\n    for(int i=0;i<N-1;i++)cin>>d[i]>>h[i];\n\n    seg_tree seg(N);\n    int cur=H;\n    int ans=0;\n    priority_queue<P>que;\n    for(int i=0;i<N-1;i++){\n        seg.add(i,i+1,cur);\n        cur-=d[i];\n\n        que.push(P(h[i],i));\n\n        while(cur<=0){\n            P p=que.top();que.pop();\n            int ma=seg.get_max(p.second,i+1);\n            if(p.first+ma>H){\n                que.push(P(H-ma,p.second));\n                continue;\n            }\n            int x=min(abs(cur)/p.first+1,(H-ma)/p.first);\n            ans+=x;\n            cur+=x*p.first;\n            seg.add(p.second,i+1,p.first*x);\n        }\n    }\n\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\n\nlong long int INF = 1e18;\nlong long int MOD = 1e9 + 7;\n\nint main(){\n\tint N, H;\n\tcin >> N >> H;\n\tdeque<P> que;\n\tque.push_back(P(0, H));\n\tlong long int S = 1;\n\tfor(int loop = 0; loop < N - 1; loop++){\n\t\tlong long int Di, Hi;\n\t\tcin >> Di >> Hi;\n\t\twhile(que.size() >= 2){\n\t\t\tP p2 = que.back();\n\t\t\tque.pop_back();\n\t\t\tP p = que.back();\n\t\t\tque.pop_back();\n\t\t\tif((p2.second - p.second) > Hi * (p2.first - p.first)){\n\t\t\t\tque.push_back(p);\n\t\t\t\tque.push_back(p2);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tque.push_back(p);\n\t\t}\n\t\tP p3 = que.back();\n\t\tlong long int num = (S + H - 1 - p3.second) / Hi;\n\t\tP p4 = P(p3.first + num, p3.second + num * Hi);\n\t\tP p5 = P(p4.first + 1, p4.second + (S + H - 1 - p3.second) % Hi);\n\t\tque.push_back(p4);\n\t\tque.push_back(p5);\n\t\tS += Di;\n\t\twhile(S > que.front().second){\n\t\t\tP p = que.front();\n\t\t\tque.pop_front();\n\t\t\tif(S <= que.front().second){\n\t\t\t\tP p2 = que.front();\n\t\t\t\tlong long int h = (p2.second - p.second) / (p2.first - p.first);\n\t\t\t\tnum = (S - p.second) / h;\n\t\t\t\tif(p.second + h * num < S){\n\t\t\t\t\tnum += 1;\n\t\t\t\t}\n\t\t\t\tque.push_front(P(p.first + num, p.second + num * h));\n\t\t\t}\n\t\t}\n\t}\n\tcout << que.front().first << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF=1001001001;\ntypedef pair<int,int>P;\nstruct seg_tree{\n    int N;\n    vector<int>mi,lazy,id;\n\n    void init(int n){\n        N=1;\n        while(n>N)N*=2;\n        mi.resize(N*2-1,0);\n        lazy.resize(N*2-1,0);\n        id.resize(N*2-1,0);\n        for(int i=N-1;i<N*2-1;i++)id[i]=i-N+1;\n    }\n\n    void evaluate(int k){\n        mi[k]+=lazy[k];\n        if(k<N-1){\n            lazy[k*2+1]+=lazy[k];\n            lazy[k*2+2]+=lazy[k];\n        }\n        lazy[k]=0;\n    }\n\n    void update_node(int k){\n        if(mi[k*2+1]<mi[k*2+2]){\n            mi[k]=mi[k*2+1];\n            id[k]=id[k*2+1];\n        }\n        else{\n            mi[k]=mi[k*2+2];\n            id[k]=id[k*2+2];\n        }\n    }\n\n    void add(int a,int b,int x){\n        add(a,b,x,0,0,N);\n    }\n    void add(int a,int b,int x,int k,int l,int r){\n        evaluate(k);\n        if(r<=a||b<=l)return;\n        if(a<=l&&r<=b){\n            lazy[k]+=x;\n            evaluate(k);\n            return;\n        }\n\n        int m=(l+r)/2;\n        add(a,b,x,k*2+1,l,m);\n        add(a,b,x,k*2+2,m,r);\n        update_node(k);\n    }\n\n    P getMin(int a,int b){\n        return getMin(a,b,0,0,N);\n    }\n    P getMin(int a,int b,int k,int l,int r){\n        evaluate(k);\n        if(r<=a||b<=l)return P(INF,0);\n        if(a<=l&&r<=b)return P(mi[k],id[k]);\n\n        int m=(l+r)/2;\n        P vl=getMin(a,b,k*2+1,l,m);\n        P vr=getMin(a,b,k*2+2,m,r);\n        return vl.first!=vr.first?min(vl,vr):max(vl,vr);\n    }\n};\n\nint N,H;\nint d[100000],h[100000];\n\nint main(){\n    cin>>N>>H;\n    for(int i=0;i<N-1;i++)cin>>d[i]>>h[i];\n\n    seg_tree seg,latte;\n    seg.init(N);\n    latte.init(N);\n    int ans=0,cur=H;\n    for(int i=0;i<N-1;i++){\n        seg.add(i,i+1,H-cur);\n        latte.add(i,i+1,-h[i]);\n        cur-=d[i];\n        while(cur<=0){\n            int lb=i,ub=-1;\n            while(lb-ub>1){\n                int mid=(ub+lb)/2;\n                if(seg.getMin(mid,i+1).first==0)ub=mid;\n                else lb=mid;\n            }\n            P p=seg.getMin(lb,i+1);\n            P q=latte.getMin(p.second+1,i+1);\n            if(p.first<-q.first){\n                int lim=seg.getMin(q.second,i+1).first;\n                int cnt=min(-lim/q.first,-abs(cur)/q.first+1);\n                ans+=cnt;\n                cur+=-q.first*cnt;\n                seg.add(q.second,i+1,q.first*cnt);\n            }\n            else{\n                q=latte.getMin(lb,i+1);\n                int val=min(p.first,-q.first);\n                int cnt=min(p.first/val,abs(cur)/val+1);\n                ans+=cnt;\n                cur+=val*cnt;\n                seg.add(p.second,i+1,-cnt*val);\n            }\n        }\n    }\n\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef pair<int,int>P;\nconst int SIZE=1<<17;\n\nstruct seg_tree{\n    vector<int>ma,lazy;\n\n    seg_tree():ma(SIZE*2-1,0),lazy(SIZE*2-1,0){}\n\n    void evaluate(int k){\n        ma[k]+=lazy[k];\n        if(k<SIZE-1){\n            lazy[k*2+1]+=lazy[k];\n            lazy[k*2+2]+=lazy[k];\n        }\n        lazy[k]=0;\n    }\n    void update_node(int k){\n        ma[k]=max(ma[k*2+1],ma[k*2+2]);\n    }\n\n    void add(int a,int b,int x,int k=0,int l=0,int r=SIZE){\n        evaluate(k);\n        if(r<=a||b<=l)return;\n        if(a<=l&&r<=b){\n            lazy[k]+=x;\n            evaluate(k);\n            return;\n        }\n        int m=(l+r)/2;\n        add(a,b,x,k*2+1,l,m);\n        add(a,b,x,k*2+2,m,r);\n        update_node(k);\n    }\n\n    int get_max(int a,int b,int k=0,int l=0,int r=SIZE){\n        evaluate(k);\n        if(r<=a||b<=l)return 0;\n        if(a<=l&&r<=b)return ma[k];\n        int m=(l+r)/2;\n        int vl=get_max(a,b,k*2+1,l,m);\n        int vr=get_max(a,b,k*2+2,m,r);\n        return max(vl,vr);\n    }\n};\n\nint N,H;\nint d[100000],h[100000];\n\nsigned main(){\n    cin>>N>>H;\n    for(int i=0;i<N-1;i++)cin>>d[i]>>h[i];\n\n    seg_tree seg;\n    int cur=H;\n    int ans=0;\n    priority_queue<P>que;\n    for(int i=0;i<N-1;i++){\n        seg.add(i,i+1,cur);\n        cur-=d[i];\n\n        que.push(P(h[i],i));\n\n        while(cur<=0){\n            P p=que.top();que.pop();\n            int ma=seg.get_max(p.second,i+1);\n            if(p.first+ma>H){\n                que.push(P(H-ma,p.second));\n                continue;\n            }\n            if(p.first==0)continue;\n            int x=min(abs(cur)/p.first+1,(H-ma)/p.first);\n            ans+=x;\n            cur+=x*p.first;\n            seg.add(p.second,i+1,p.first*x);\n        }\n    }\n\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Bokan ga bokka--nn!!\n//Daily Lunch Special Tanoshii !!\n//これは、頭が悪く競プロが世界で一番できないHIR180が\n//IOI2014日本代表になるまでのN日間の記録である。\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000LL\n#define f first\n#define s second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SIZE (1<<17)\nclass segtree\n{\npublic:\n\tll seg[SIZE*2];\n\tll lazy[SIZE*2];\n\tvoid lazy_evaluate(int k)\n\t{\n\t\tlazy[k*2+2]+=lazy[k];\n\t\tlazy[k*2+1]+=lazy[k];\n\t\tseg[k*2+2]+=lazy[k];\n\t\tseg[k*2+1]+=lazy[k];\n\t\tlazy[k]=0;\n\t}\n\tll update(int beg,int end,int idx,int lb,int ub,ll num)\n\t{\n\t\tif(lazy[idx] && lb!=ub)\n\t\t{\n\t\t\tlazy_evaluate(idx);\n\t\t}\n\t\tif(ub<beg||end<lb)\n\t\t{\n\t\t\treturn seg[idx];\n\t\t}\n\t\tif(beg<=lb&&ub<=end)\n\t\t{\n\t\t\tlazy[idx]+=num;\n\t\t\tseg[idx]+=num;\n\t\t\treturn seg[idx];\n\t\t}\n\t\treturn seg[idx]=max(update(beg,end,idx*2+1,lb,(lb+ub)/2,num),update(beg,end,idx*2+2,(lb+ub)/2+1,ub,num));\n\t}\n\tll query(int beg,int end,int idx,int lb,int ub)\n\t{\n\t\tif(lazy[idx] && lb!=ub)\n\t\t{\n\t\t\tlazy_evaluate(idx);\n\t\t}\n\t\tif(ub<beg||end<lb)\n\t\t{\n\t\t\treturn -INF;\n\t\t}\n\t\tif(beg<=lb&&ub<=end)\n\t\t{\n\t\t\treturn seg[idx];\n\t\t}\n\t\treturn max(query(beg,end,idx*2+1,lb,(lb+ub)/2),query(beg,end,idx*2+2,(lb+ub)/2+1,ub));\n\t}\n}seg;\nint main()\n{\n\tsrand((unsigned int)time(NULL));\n\tint n; ll maxv; scanf(\"%d %lld\",&n,&maxv);\n\tseg.update(0,SIZE-1,0,0,SIZE-1,maxv);\n\tpriority_queue<P>bestfloor;\n\tint ret=0;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tll gen,pl; scanf(\"%lld%lld\",&gen,&pl);\n\t\tbestfloor.push(mp(pl,i));\n\t\twhile(!bestfloor.empty()&&seg.query(i,i,0,0,SIZE-1)<gen)\n\t\t{\n\t\t\tP p=bestfloor.top();\n\t\t\tll got=p.f;\n\t\t\tint id=p.s;\n\t\t\t//how many times can we use recovery without overflowing\n\t\t\tll x=(maxv-seg.query(id,SIZE-1,0,0,SIZE-1))/got;\n\t\t\t//how many times must we use recovery\n\t\t\tll y=(gen-seg.query(i,i,0,0,SIZE-1))/got+1;\n\t\t\tif(x>=y)\n\t\t\t{\n\t\t\t\t//we use best recovery\n\t\t\t\tret+=y;\n\t\t\t\tseg.update(id,SIZE-1,0,0,SIZE-1,y*got);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//we stop using this recovery\n\t\t\t\tret+=x;\n\t\t\t\tbestfloor.pop();\n\t\t\t\tbestfloor.push(mp((maxv-seg.query(id,SIZE-1,0,0,SIZE-1))%got,id));\n\t\t\t\tseg.update(id,SIZE-1,0,0,SIZE-1,x*got);\n\t\t\t}\n\t\t}\n\t\tseg.update(i,SIZE-1,0,0,SIZE-1,-1*gen);\n\t}\n\tprintf(\"%d\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint N, H, d[100009], h[100009], dp[1009][1009];\nint main() {\n\tcin >> N >> H;\n\tassert(N <= 1000 && H <= 1000);\n\tfor (int i = 0; i < N - 1; i++) cin >> d[i] >> h[i];\n\tfor (int i = 0; i < N - 1; i++) {\n\t\tfill(dp[i + 1], dp[i + 1] + H + 1, 999999999);\n\t\tfor (int j = 1; j <= H - d[i]; j++) {\n\t\t\tint h2 = j + d[i];\n\t\t\tfor (int k = 0; h2 - k * h[i] > 0; k++) {\n\t\t\t\tdp[i + 1][j] = min(dp[i + 1][j], dp[i][h2 - k * h[i]] + k);\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[N - 1][1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\n\nll N,H,d,h;\n\nint main(){\n  cin >> N >> H;\n  ll ans = 0;\n\n  ll cur = H;\n  priority_queue<pll> q;\n  for(int i=0;i<N-1;i++){\n\n    cin >> d >> h;\n    ll rem = H-cur;\n    priority_queue<pll> tmp;\n    while(q.size() && q.top().first >= h){\n      pll p = q.top(); q.pop();\n      rem -= p.second * p.first;\n      tmp.push(p);\n    }\n    swap(q,tmp);\n    ll times = rem/h;\n    //cerr << rem << \" \" << h << \" \" << times << endl;\n    if(times)q.push(pll(h,times));\n    if(times*h != rem)q.push(pll(rem-times*h,1));\n\n    cur -= d;\n    while(cur<=0){\n      //cerr << cur << endl;\n      pll p = q.top(); q.pop();\n      ll need = -cur/p.first+1;\n      //cerr << p.first << \" \" << need << \" \" << p.second << endl;\n\n      if(need <= p.second){\n\tans += need;\n\tp.second -= need;\n\tcur += need * p.first;\n\tif(p.second)q.push(p);\n      }else{\n\tans += p.second;\n\tcur += p.first * p.second;\n      }\n    }\n    //cerr << endl;\n  }\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <algorithm>\n#include <climits>\n\n#define MAX_N (100000)\n\nusing namespace std;\n\ntypedef long long lint;\n\nint size;\nstruct Node {\n\tint val, lazy;\n} seg[1 << 18];\n\nstruct Spring {\n\tint pos, val;\n\tSpring(int pos, int val) : pos(pos), val(val) {}\n\tSpring() {}\n};\n\nbool operator < (const Spring &a, const Spring &b)\n{\n\tif (a.val != b.val) return (a.val < b.val);\n\treturn (a.pos > b.pos);\n}\n\nvoid init(int n)\n{\n\tsize = 1;\n\twhile (size < n) size *= 2;\t\n}\n\ninline void evaluate(int k)\n{\n\tseg[k].val += seg[k].lazy;\n\t\n\tif (k < size - 1){\n\t\tseg[k * 2 + 1].lazy += seg[k].lazy;\n\t\tseg[k * 2 + 2].lazy += seg[k].lazy;\n\t}\n\t\n\tseg[k].lazy = 0;\n}\n\ninline void update(int k)\n{\n\tseg[k].val = max(seg[k * 2 + 1].val, seg[k * 2 + 2].val);\n}\n\nvoid add(int a, int b, int x, int k = 0, int l = 0, int r = size)\n{\n\tevaluate(k);\n\t\n\tif (b <= l || r <= a) return;\n\t\n\tif (a <= l && r <= b){\n\t\tseg[k].lazy += x;\n\t\tevaluate(k);\n\t\treturn;\n\t}\n\t\n\tadd(a, b, x, k * 2 + 1, l, (l + r) / 2);\n\tadd(a, b, x, k * 2 + 2, (l + r) / 2, r);\n\tupdate(k);\n}\n\nint getMax(int a, int b, int k = 0, int l = 0, int r = size)\n{\n\tevaluate(k);\n\t\n\tif (b <= l || r <= a) return (INT_MIN);\n\t\n\tif (a <= l && r <= b){\n\t\treturn (seg[k].val);\n\t}\n\t\n\tint lmax = getMax(a, b, k * 2 + 1, l, (l + r) / 2);\n\tint rmax = getMax(a, b, k * 2 + 2, (l + r) / 2, r);\n\tupdate(k);\n\t\n\treturn (max(lmax, rmax));\n}\n\nint main()\n{\n\tint N, H;\n\tint dmg[MAX_N], heal[MAX_N];\n\t\n\tscanf(\"%d %d\", &N, &H);\n\t\n\tfor (int i = 0; i < N - 1; i++){\n\t\tscanf(\"%d %d\", dmg + i, heal + i);\n\t}\n\t\n\tinit(N);\n\t\n\tlint ans = 0;\n\t\n\tint nowLife = H;\n\tpriority_queue<Spring> pq;\n\tfor (int i = 0; i < N - 1; i++){\n\t\tadd(i, i + 1, nowLife);\n\t\tpq.push(Spring(i, heal[i]));\n\t\tnowLife -= dmg[i];\n\t\t\n\t\twhile (nowLife <= 0){\n\t\t\tSpring x = pq.top();\n\t\t\tint mVal = getMax(x.pos, i + 1);\n\t\t\t\n\t\t\tif (mVal + x.val > H){\n\t\t\t\tx.val = H - mVal;\n\t\t\t\tpq.pop();\n\t\t\t\tpq.push(x);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tint plus = min((-nowLife) / x.val + 1, (H - mVal) / x.val);\n\t\t\tans += plus;\n\t\t\tadd(x.pos, i + 1, plus * x.val);\n\t\t\tnowLife += plus * x.val;\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", ans);\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  ll N, maxHp;\n  while (cin >> N >> maxHp) {\n    vector<ll> totalDamage(N);\n    ll totalHealing = 0, answer = 0;\n    priority_queue<pair<ll, int>> Q;\n    int maxIndex = 0;\n\n    for (int i = 0; i < N - 1; ++i) {\n      ll damage, healing;\n      cin >> damage >> healing;\n      totalDamage[i + 1] = totalDamage[i] + damage;\n      Q.push({healing, i});\n\n      ll necessaryHealing = totalDamage[i + 1] - totalHealing - maxHp + 1;\n      while (necessaryHealing > 0) {\n        ll healing = Q.top().first;\n        int index = Q.top().second;\n        Q.pop();\n\n        if (index < maxIndex) continue;\n        maxIndex = index;\n\n        ll netDamage = totalDamage[index] - totalHealing;\n        ll times = (necessaryHealing + healing - 1) / healing;\n        if (netDamage - healing * times < 0) --times;\n        answer += times;\n        necessaryHealing -= healing * times;\n        netDamage -= healing * times;\n        totalHealing += healing * times;\n        if (netDamage > 0) Q.push({min(healing, netDamage), index});\n      }\n    }\n    cout << answer << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <map>\n#include <deque>\nusing namespace std;\n\nlong long d[100000];\nlong long h[100000];\nlong long s[100000];\nint main(){\n\tlong long N,H,mx;\n\tcin >> N >> H;\n\tmx = H;\n\tfor(int i = 0 ; i < N-1 ; i++){\n\t\tcin >> d[i] >> h[i];\n\t\ts[i+1] = s[i] + d[i];\n\t}\n\t\n\tint ans = 0;\n\tdeque<int> Q;\n\tfor(int i = 0 ; i < N-1 ; i++){\n\n\t\t//if( i > 10 ) return 0;\n\t\t//cout << \"s\" << i << \" \" << H << \" \" << ans << endl;\n\t\twhile( Q.size() && h[Q.back()] <= h[i]) Q.pop_back();\n\t\tQ.push_back(i);\n\t\twhile( Q.size() && s[i] - s[Q.front()] > mx) Q.pop_front();\n\t\t//for(int j = 0 ; j < Q.size() ; j++) cout << h[Q[j]] << \" (\" << Q[j] << \",\" << mx - (s[i]-s[Q[j]]) << \") \";cout << endl;\n\t\tif( H <= d[i] ){\n\t\t\tfor(int j = 0 ; j < Q.size() ; j++){\n\t\t\t\tlong long heal_max = max(0ll, mx - (s[i] - s[Q[j]]) - H );\n\t\t\t\t\n\t\t\t\t//cout << i << \" \" << Q[j] << \" \" << s[i] << \" \" << s[Q[j]] << \" \" << H << \" \" << heal_max << endl;\n\t\t\t\tlong long need = d[i] - H + 1;\n\t\t\t\tlong long use = min(need,heal_max) / h[Q[j]];\n\t\t\t\t//cout << Q[j] << \" : \" << need << \" <========== \" << \" \" << heal_max << endl;\n\t\t\t\t//if( use == 0 ) continue;\n\t\t\t\tH += use * h[Q[j]];\n\t\t\t\t//H = min(H,mx - (s[i] - s[Q[j]]));\n\t\t\t\tans += use;\n\t\t\t\tif( H > d[i] ) break;\n\t\t\t\t\n\t\t\t\tif( j+1 >= Q.size() || mx - (s[i] - s[Q[j]]) - H >= h[Q[j+1]] ){\n\t\t\t\t\t//cout << H << \" \" << heal_max << endl;\n\t\t\t\t\tans++;\n\t\t\t\t\tH = min( H + h[Q[j]], mx - (s[i] - s[Q[j]]) );\n\t\t\t\t}\n\t\t\t\tif( H > d[i] ) break;\n\t\t\t}\n\t\t}\n\t\tH -= d[i];\n\t\tif( H <= 0 ){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint dp[100000],hp[100000];\nlong long int ans=-1;\nvoid heal(long long int count,int N,int H,int now,int now_hp){\n  if(now==N){\n    if(count<ans||ans<0) ans = count;\n  }else  if(hp[now+1]>=hp[now]&&now!=N-1){\n    if(now_hp>dp[now]) heal(count,N,H,now+1,now_hp-dp[now]);\n    else{\n      int cou;\n      cou = (dp[now]-now_hp) / hp[now] + 1;\n      now_hp += hp[now] * cou;\n      count += cou;\n      if(now_hp>H) now_hp = H;\n      heal(count,N,H,now+1,now_hp-dp[now]);\n    } \n  }\n  else{\n    if(now_hp-dp[now]>0) heal(count,N,H,now+1,now_hp-dp[now]);\n      int cou=0;\n      while(now_hp<H){\n\tcou++;\n\tnow_hp += hp[now];\n\tif(now_hp>H) now_hp = H;\n\tif(now_hp-dp[now]>0) heal(count+cou,N,H,now+1,now_hp-dp[now]);\n      }\n    }\n  }\nint main(){\n  int N,H;\n  cin >> N >> H;\n  for(int i=1;i<N;i++) cin >> dp[i] >> hp[i];\n  heal(0,N,H,1,H);\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  ll N, maxHp;\n  while (cin >> N >> maxHp) {\n    vector<ll> totalDamage(N);\n    ll totalHealing = 0, answer = 0;\n    priority_queue<pair<ll, int>> Q;\n    int maxIndex = 0;\n\n    for (int i = 0; i < N - 1; ++i) {\n      ll damage, healing;\n      cin >> damage >> healing;\n      totalDamage[i + 1] = totalDamage[i] + damage;\n      Q.push({healing, i});\n\n      ll necessaryHealing = totalDamage[i + 1] - totalHealing - maxHp + 1;\n      while (necessaryHealing > 0) {\n        ll healing = Q.top().first;\n        int index = Q.top().second;\n        Q.pop();\n\n        if (index < maxIndex) continue;\n        maxIndex = index;\n\n        ll netDamage = totalDamage[index] - totalHealing;\n        ll times = min((necessaryHealing + healing - 1) / healing, netDamage / healing);\n        answer += times;\n        necessaryHealing -= healing * times;\n        netDamage -= healing * times;\n        totalHealing += healing * times;\n        if (netDamage > 0) Q.push({min(healing, netDamage), index});\n      }\n    }\n    cout << answer << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fst(t) std::get<0>(t)\n#define snd(t) std::get<1>(t)\n#define thd(t) std::get<2>(t)\n\nusing ll = long long;\nusing P = std::tuple<ll,ll>;\n\nll N, H;\nll hs[100100];\nll life[100100];\nstd::priority_queue<P> pq;\n\nint main(){\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    std::cin >> N >> H;\n\n    life[0] = H;\n    for(int i=0;i<N-1;++i){\n        ll d;\n        std::cin >> d >> hs[i];\n\n        life[i+1] = life[i] - d;\n    }\n\n    // for(int i=0;i<10;++i){\n    //     std::cout << i << \": \" << life[i] << std::endl;\n    // }\n    \n    int last = -1;\n    ll recovery = 0ll, counter = 0ll;\n\n    for(int i=0;i<N-1;++i){\n        pq.emplace(min(hs[i], H - (life[i] + recovery)), -i);\n\n        // std::cout << \"In \" << i << \" th floor\" << std::endl;\n        while(life[i+1] + recovery <= 0){\n            ll h, idx;\n            tie(h, idx) = pq.top();\n            idx = -idx;\n            pq.pop();\n\n            if(idx < last){continue;}\n            ll needs = -(life[i+1] + recovery) + 1,\n                rest = H - (life[idx] + recovery);\n            if(rest < h){\n                if(rest > 0){\n                    pq.emplace(rest, -idx);\n                }\n                continue;\n            }\n\n            ll t = min((needs + h - 1) / h, rest / h);\n            recovery += min(h * t, rest);\n            counter += t;\n            ll new_h = min(h, H - (life[idx] + recovery));\n            if(new_h > 0){\n                pq.emplace(new_h, -idx);\n            }\n            last = idx;\n\n            // std::cout << \"Recovery \" << min(h * t, rest) << \" min(\" << rest << \", \" << h << \" * \" << t << \")\" << \" in \" << idx << std::endl;\n            // std::cout << \"Change \" << h << \" -> \" << new_h << std::endl;\n        }\n    }\n\n    std::cout << counter << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "//Bokan ga bokka--nn!!\n//Daily Lunch Special Tanoshii !!\n//これは、頭が悪く競プロが世界で一番できないHIR180が\n//IOI2014日本代表になるまでのN日間の記録である。\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000LL\n#define f first\n#define s second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SIZE 131072\nclass segtree\n{\npublic:\n\tll seg[SIZE*2];\n\tll lazy[SIZE*2];\n\tvoid lazy_evaluate(int k)\n\t{\n\t\tlazy[k*2+2]+=lazy[k];\n\t\tlazy[k*2+1]+=lazy[k];\n\t\tseg[k*2+2]+=lazy[k];\n\t\tseg[k*2+1]+=lazy[k];\n\t\tlazy[k]=0;\n\t}\n\tll update(int beg,int end,int idx,int lb,int ub,ll num)\n\t{\n\t\tif(lazy[idx] && lb!=ub)\n\t\t{\n\t\t\tlazy_evaluate(idx);\n\t\t}\n\t\tif(ub<beg||end<lb)\n\t\t{\n\t\t\treturn seg[idx];\n\t\t}\n\t\tif(beg<=lb&&ub<=end)\n\t\t{\n\t\t\tlazy[idx]+=num;\n\t\t\tseg[idx]+=num;\n\t\t\treturn seg[idx];\n\t\t}\n\t\treturn seg[idx]=max(update(beg,end,idx*2+1,lb,(lb+ub)/2,num),update(beg,end,idx*2+2,(lb+ub)/2+1,ub,num));\n\t}\n\tll query(int beg,int end,int idx,int lb,int ub)\n\t{\n\t\tif(lazy[idx] && lb!=ub)\n\t\t{\n\t\t\tlazy_evaluate(idx);\n\t\t}\n\t\tif(ub<beg||end<lb)\n\t\t{\n\t\t\treturn -INF;\n\t\t}\n\t\tif(beg<=lb&&ub<=end)\n\t\t{\n\t\t\treturn seg[idx];\n\t\t}\n\t\treturn max(query(beg,end,idx*2+1,lb,(lb+ub)/2),query(beg,end,idx*2+2,(lb+ub)/2+1,ub));\n\t}\n}seg;\nint main()\n{\n\tsrand((unsigned int)time(NULL));\n\tint n; ll maxv; scanf(\"%d %lld\",&n,&maxv);\n\tseg.update(0,SIZE-1,0,0,SIZE-1,maxv);\n\tpriority_queue<P>bestfloor;\n\tll ret=0;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tll gen,pl; scanf(\"%lld%lld\",&gen,&pl);\n\t\tbestfloor.push(mp(pl,i));\n\t\twhile(!bestfloor.empty()&&seg.query(i+1,i+1,0,0,SIZE-1)<=gen)\n\t\t{\n\t\t\tP p=bestfloor.top();\n\t\t\tll got=p.f;\n\t\t\tint id=p.s;\n\t\t\t//how many times can we use recovery without overflowing\n\t\t\tll x=(maxv-seg.query(id,i+1,0,0,SIZE-1))/got;\n\t\t\t//how many times must we use recovery\n\t\t\tll y=(1-seg.query(i+1,i+1,0,0,SIZE-1)+gen+got-1)/got;\n\t\t\tif(x>=y)\n\t\t\t{\n\t\t\t\t//we use best recovery\n\t\t\t\tret+=y;\n\t\t\t\tseg.update(id,SIZE-1,0,0,SIZE-1,y*got);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//we stop using this recovery\n\t\t\t\tret+=x;\n\t\t\t\tbestfloor.pop();\n\t\t\t\tbestfloor.push(mp(((maxv-seg.query(id,i+1,0,0,SIZE-1))%got),id));\n\t\t\t\tseg.update(id,SIZE-1,0,0,SIZE-1,x*got);\n\t\t\t}\n\t\t}\n\t\tseg.update(i+1,SIZE-1,0,0,SIZE-1,-1*gen);\n\t}\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <deque>\n#include <utility>\n#include <algorithm>\nusing namespace std;\nint main() {\n\tlong long int n,total_h,max_h,total_d=0,ans=0;\n\tscanf(\"%lld %lld\",&n,&total_h);\n\tmax_h=total_h;\n\tdeque<pair<long long int,long long int> > Q;\n\tfor(int i=0;i<n-1;i++) {\n\t\tlong long int d,h;\n\t\tscanf(\"%lld %lld\",&d,&h);\n\t\twhile(!Q.empty()&&Q.back().first<=h)\n\t\t\tQ.pop_back();\n\t\tQ.push_back(make_pair(h,total_d));\n\t\ttotal_d+=d;\n\t\twhile(total_h<=total_d) {\n\t\t\tlong long int tmp_h=total_h;\n\t\t\twhile(!Q.empty()&&tmp_h+Q.front().first-Q.front().second>max_h) {\n\t\t\t\ttotal_h=Q.front().second+max_h;\n\t\t\t\tQ.pop_front();\n\t\t\t}\n\t\t\tif(!Q.empty()) {\n\t\t\t\ttotal_h=max(total_h,tmp_h+Q.front().first);\n\t\t\t\tlong long int tmp=max(0LL,min((total_d-total_h)/Q.front().first,(Q.front().second+max_h-total_h)/Q.front().first));\n\t\t\t\tans+=tmp;\n\t\t\t\ttotal_h+=tmp*Q.front().first;\n\t\t\t}\n\t\t\tans++;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "/*\n    ま ご う こ と な き ウ ン コ ー ド&#128169;\n */\n\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\n#define INF 0x7fffffff\ntypedef pair<int, int> Pair;\nint N;\nint H;\nint size;\nint life;\nint ans;\nint segtree[262144];\nint addtree[262144];\npriority_queue<Pair> cures;\n\nvoid add(int wishl, int wishr, int k, int watchl, int watchr, int x) {\n    int mid;\n\n    if (watchr <= wishl || wishr <= watchl) return;\n    if (wishl <= watchl && watchr <= wishr) {\n        addtree[k] += x;\n        while (k > 0) {\n            k = (k-1)/2;\n            segtree[k] = max(segtree[k*2+1]+addtree[k*2+1], segtree[k*2+2]+addtree[k*2+2]);\n        }\n        return;\n    }\n\n    mid = (watchl+watchr)/2;\n    add(wishl, wishr, k*2+1, watchl, mid, x);\n    add(wishl, wishr, k*2+2, mid, watchr, x);\n}\n\nint get_max(int wishl, int wishr, int k, int watchl, int watchr) {\n    int mid;\n    int lval, rval;\n\n    if (watchr <= wishl || wishr <= watchl) return -INF;\n    if (wishl <= watchl && watchr <= wishr) return segtree[k] + addtree[k];\n\n    mid = (watchl+watchr)/2;\n    lval = get_max(wishl, wishr, k*2+1, watchl, mid);\n    rval = get_max(wishl, wishr, k*2+2, mid, watchr);\n    return max(lval, rval) + addtree[k];\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &H);\n    size = 1;\n    while(size < N) size *= 2;\n\n    life = H;\n    for (int i=0; i<N-1; i++) {\n        int d, h;\n        int prev_times = -1;\n\n        scanf(\"%d %d\", &d, &h);\n        add(i, i+1, 0, 0, size, life);\n        cures.push(Pair(min(H-life, h), i));\n\n        life -= d;\n        while (life <= 0) {\n            Pair p;\n            int val;\n            int idx;\n            int at_life;\n            int lim;\n            int diff;\n            int times;\n            int amount;\n\n            p = cures.top(); cures.pop();\n            val = p.first;\n            idx = p.second;\n            at_life = get_max(idx, i+1, 0, 0, size);\n            if (at_life >= H) {\n                continue;\n            }\n\n            lim = H-at_life;\n            if (lim < val) {\n                cures.push(Pair(lim, idx));\n                continue;\n            }\n\n            diff = 1-life;\n            if (lim < diff) {\n                times = lim/val;\n            } else {\n                times = diff/val;\n            }\n\n            if (prev_times == 0 && times == 0) times = 1;\n            amount = val * times;\n            if (amount > lim) amount = lim;\n            add(idx, i+1, 0, 0, size, val*times);\n            ans += times;\n            life += amount;\n            cures.push(Pair(min(lim-amount, val), idx));\n            prev_times = times;\n        }\n    }\n\n    printf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long l;\n\npair<int,int> p[100005];\nlong long imos[100005]={};\npair<int,int>seg[(1<<18)];\nint n,h;\nint cm[100005];\n\nvoid init()\n{\n\tfor(int i=0;i<(1<<18);i++)\n\t{\n\t\tseg[i].first=0;\n\t\tseg[i].second=0;\n\t}\n}\n\nvoid update(int x,pair<int,int> a)\n{\n\tx+=(1<<17)-1;\n\tseg[x]=a;\n\twhile(x>0)\n\t{\n\t\tx=(x-1)/2;\n\t\tif(seg[x].first<seg[x*2+1].first) seg[x]=seg[x*2+1];\n\t\tif(seg[x].first<seg[x*2+2].first) seg[x]=seg[x*2+2];\n\t}\n}\n\npair<int,int> query(int a,int b,int k,int l,int r)\n{\n\tpair<int,int>s;\n\ts.first=s.second=-1;\n\tif(b<l || r<a) return s;\n\tif(a<=l && r<=b) return seg[k];\n\tint sa=r-l+1;\n\tpair<int,int> le=query(a,b,k*2+1,l,l+sa/2-1);\n\tpair<int,int> ri=query(a,b,k*2+2,l+sa/2,r);\n\tif(le.first>ri.first) return le;\n\telse return ri;\n}\n\nint binarysearch(long long s,int w)\n{\n\tint lb=-1;\n\tint ub=n+1;\n\twhile(ub-lb>1)\n\t{\n\t\tint mid=(lb+ub)/2;\n\t\tif(imos[mid]-imos[w]>s) ub=mid;\n\t\telse lb=mid;\n\t}\n\tfor(int i=max(w,lb-3);i<=min(n-1,ub+3);i++)\n\t{\n\t\tif(imos[i]-imos[w]>s) return i-1;\n\t}\n\treturn 1e9;\n}\n\nint main()\n{\n\tscanf(\"%d %d\",&n,&h);\n\tinit();\n\tpriority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > >que;\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d %d\",&x,&y);\n\t\timos[i+1]=imos[i]+1LL*x;\n\t\tp[i]=make_pair(y,i);\n\t\tupdate(i,p[i]);\n\t\twhile(!que.empty() && que.top().first<y)\n\t\t{\n\t\t\tcm[que.top().second]=i;\n\t\t\tque.pop();\n\t\t}\n\t\tque.push(p[i]);\n\t}\n\twhile(que.size()) cm[que.top().second]=n-1,que.pop();\n\tint cur=h;\n\tint now=0;\n\tlong long ret=0;\n\twhile(1)\n\t{\n\t\tint e=cm[now];\n\t\tlong long dis=imos[e]-imos[now];\n\t\tif(dis<cur)\n\t\t{\n\t\t\tcur-=dis;\n\t\t\tnow=e;\n\t\t}\n\t\telse if(dis<=h)\n\t\t{\n\t\t\tlong long fj=dis-cur+1;\n\t\t\tret+=(fj+p[now].first-1)/p[now].first;\n\t\t\tcur+=((fj+p[now].first-1)/p[now].first)*p[now].first;\n\t\t\tcur=min(cur,h);\n\t\t\tcur-=dis;\n\t\t\tnow=e;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint X=binarysearch(h,now);\n\t\t\tpair<int,int>se = query(now+1,X,0,0,(1<<17)-1);\n\t\t\tlong long fj=(imos[se.second]-imos[now])-cur+1;\n\t\t\tif(fj>0)\n\t\t\t{\n\t\t\t\tret+=(fj+p[now].first-1)/p[now].first;\n\t\t\t\tcur+=((fj+p[now].first-1)/p[now].first)*p[now].first;\n\t\t\t}\n\t\t\tcur=min(cur,h);\n\t\t\tcur-=(imos[se.second]-imos[now]);\n\t\t\tnow=se.second;\n\t\t}\n\t\tif(now==n-1) break;\n\t}\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <limits.h>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <string>\n#include <functional>\n#include <vector>\n#include <numeric>\n#include <deque>\n#include <utility>\n#include <bitset>\n#include <iostream>\nusing namespace std;\ntypedef long long lint;\ntypedef long double llf;\ntypedef pair<int, int> pi;\n\nint n, t;\nint d[100005], h[100005];\nint cur_hel[100005];\n\nint main(){\n\tscanf(\"%d %d\",&n,&t);\n\tcur_hel[0] = t;\n\tint ret = 0;\n\tfor(int i=1; i<n; i++){\n\t\tscanf(\"%d %d\",&d[i],&h[i]);\n\t\tcur_hel[i] = cur_hel[i-1] - d[i];\n\t\tif(cur_hel[i] < 0){\n\t\t\tint maxv = -1e9, maxp = -1;\n\t\t\tint mint = cur_hel[i];\n\t\t\tfor(int j=i-1; j; j--){\n\t\t\t\tmint = min(mint, cur_hel[j]);\n\t\t\t\tint tmp = min(d[j], t - mint);\n\t\t\t\tif(maxv < tmp){\n\t\t\t\t\tmaxv = tmp;\n\t\t\t\t\tmaxp = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=maxp; j<=i; j++){\n\t\t\t\tcur_hel[i] += maxv;\n\t\t\t}\n\t\t\tret++;\n\t\t}\n\t}\n\tprintf(\"%d\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nint segtree[262144];\nvoid add(int a,int b,int c,int d,int e,int val){\n\tif(d<a||b<c);\n\telse if(c<=a&&b<=d){\n\t\tsegtree[e]+=val;\n\t}\n\telse{\n\t\tadd(a,(a+b)/2,c,d,e*2,val);\n\t\tadd((a+b)/2+1,b,c,d,e*2+1,val);\n\t}\n\tif(e>1){\n\t\tint v=max(segtree[e],segtree[e^1]);\n\t\tif(v>0){\n\t\t\tsegtree[e/2]+=v;\n\t\t\tsegtree[e]-=v;\n\t\t\tsegtree[e^1]-=v;\n\t\t}\n\t}\n}\nint query(int a,int b,int c,int d,int e,int now){\n\tif(d<a||b<c)return 0;\n\tif(c<=a&&b<=d)return now+segtree[e];\n\telse {\n\t\treturn max(query(a,(a+b)/2,c,d,e*2,now+segtree[e]),query((a+b)/2+1,b,c,d,e*2+1,now+segtree[e]));\n\t}\n}\nint d[100000];\nint h[100000];\nint main(){\n\tint a,b;\n\tscanf(\"%d%d\",&a,&b);\n\ta--;\n\tfor(int i=0;i<a;i++)scanf(\"%d%d\",d+i,h+i);\n\tpriority_queue<pair<int,int> > Q;\n\tlong long ret=0;\n\tint now=b;\n\tfor(int i=0;i<a;i++){\n\t\tadd(0,131071,i,i,1,now);\n\t\tnow-=d[i];\n\t\tQ.push(make_pair(h[i],i));\n\t//\tprintf(\"%d\\n\",now);\n\t\twhile(now<=0){\n\t\t\tint cost=Q.top().first;\n\t\t\tint at=Q.top().second;\n\t\t\tQ.pop();\n\t\t\tint q=query(0,131071,at,i,1,0);\n\t\t//\tprintf(\"%d\\n\",q);\n\t\t\tif(cost+q>b){\n\t\t\t\tQ.push(make_pair(b-q,at));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint usemax=min((-now)/cost+1,(b-q)/cost);\n\t\t\tret+=usemax;\n\t\t\tnow+=usemax*cost;\n\t//\t\tprintf(\"%d %d %d\\n\",cost,at,usemax);\n\t\t\tadd(0,131071,at,i,1,usemax*cost);\n\t\t\tQ.push(make_pair(cost,at));\n\t\t}\n\t//\tprintf(\"%d\\n\\n\",now);\n\t}\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <map>\n#include <deque>\nusing namespace std;\n\nlong long d[100000];\nlong long h[100000];\nlong long s[100000];\nint main(){\n\tlong long N,H,mx;\n\tcin >> N >> H;\n\tH++;\n\tmx = H;\n\tfor(int i = 0 ; i < N-1 ; i++){\n\t\tcin >> d[i] >> h[i];\n\t\ts[i] = (i ? s[i-1] : 0) + d[i];\n\t}\n\t\n\tint ans = 0;\n\tdeque<int> Q;\n\tfor(int i = 0 ; i <N ; i++){\n\t\t//cout << \"s\" << i << \" \" << H << endl;\n\t\twhile( Q.size() && h[Q.back()] <= h[i]) Q.pop_back();\n\t\tQ.push_back(i);\n\t\twhile( Q.size() && s[i] - s[Q.front()] > mx) Q.pop_front();\n\t\tif( H < d[i] ){\n\t\t\tfor(int j = 0 ; j < Q.size() ; j++){\n\t\t\t\tlong long heal_max = max(0ll, mx - (s[i] - s[Q[j]]) - H );\n\t\t\t\t//cout << i << \" \" << Q[j] << \" \" << s[i] << \" \" << s[Q[j]] << \" \" << H << \" \" << heal_max << endl;\n\t\t\t\tlong long need = d[i] - H;\n\t\t\t\tlong long use = min(need,heal_max) / h[Q[j]];\n\t\t\t\tH += use * h[Q[j]];\n\t\t\t\tans += use;\n\t\t\t\tif( H >= d[i] ) break;\n\t\t\t\t\n\t\t\t\tif( j+1 >= Q.size() || heal_max - use * h[Q[j]] > h[Q[j+1]] ){\n\t\t\t\t\tans++;\n\t\t\t\t\tH = heal_max;\n\t\t\t\t}\n\t\t\t\tif( H >= d[i] ) break;\n\t\t\t}\n\t\t}\n\t\tH -= d[i];\n\t\tif( H < 0 ){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define ALL(A) A.begin(), A.end()\n#define INF ((int)1e9 + 9)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nstruct segtree{\n\tint SIZE;\n\tvector<int> maximum, lazy;\n\n\tsegtree(int n){\n\n\t\tSIZE = 1;\n\t\twhile(SIZE < n) SIZE *= 2;\n\t\t\n\t\tmaximum.clear();\n\t\tmaximum.resize(SIZE * 2, 0);\n\t\tlazy.clear();\n\t\tlazy.resize(SIZE * 2, 0);\n\t};\n\n\tvoid lazy_evaluate(int k){\n\t\tmaximum[k] += lazy[k];\n\n\t\tif (k < SIZE - 1){ // k isn't leaf of SegmentTree\n\t\t\tlazy[k * 2 + 1] += lazy[k];\n\t\t\tlazy[k * 2 + 2] += lazy[k];\n\t\t} // end if\n\t\tlazy[k] = 0;\n\t} // end function\n\n\tvoid update(int a, int b, int k, int l, int r, int x){\n\t\tif (r <= a || b <= l) return;\n\n\t\tif (a <= l && r <= b){\n\t\t\tlazy[k] += x;\n\t\t\tlazy_evaluate(k);\n\t\t}else{\n\t\t\tlazy_evaluate(k);\n\t\t\tupdate(a, b, k * 2 + 1, l, (l + r) / 2, x);\n\t\t\tupdate(a, b, k * 2 + 2, (l + r) / 2, r, x);\n\t\t\tmaximum[k] = max(maximum[k * 2 + 1], maximum[k * 2 + 2]);\n\t\t\treturn;\n\t\t} // end if\n\t} // end function \n\n\tint query(int a, int b, int k, int l, int r){\n\t\tlazy_evaluate(k);\n\t\tif (r <= a || b <= l) return 0;\n\t\tif (a <= l && r <= b) return maximum[k];\n\t\telse{\n\t\t\tint lch = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\t\tint rch = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\n\t\t\treturn max(lch, rch);\n\t\t} // end if\n\t} // end function\n};\n\nint main()\n{\n\tint N, H;\n\tint di[(int)1e5 + 5] = {0};\n\tint hi[(int)1e5 + 5] = {0};\n\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcin >> N >> H;\n\trep (i, N - 1){\n\t\tcin >> di[i] >> hi[i];\n\t} // end rep\n\n\tint currLife = H;\n\tint ans = 0;\n\n\tauto cmp = [](P left, P right){ return left.first != right.first ? left.first < right.first : left.second < right.second; };\n\tpriority_queue<P, vector<P>, decltype(cmp) > que(cmp);\t// P(plus, pos) \n\n\tsegtree seg(N);\n\n\tfor (int i = 0; i < N - 1; ++i){\n\t\tseg.update(i, i + 1, 0, 0, seg.SIZE, currLife); // update(a, b, k, l, r, x);\n\t\tcurrLife -= di[i];\n\t\tque.push(P(hi[i], i));\n\n\t\twhile(currLife <= 0){\n\t\t\tP heal = que.top(); que.pop();\n\t\t\tint segMax = seg.query(heal.second, i + 1, 0, 0, seg.SIZE);\n\n\t\t\tif (heal.first + segMax > H){\n\t\t\t\theal.first = H - segMax;\n\t\t\t\tque.push(P(heal.first, heal.second));\n\t\t\t\tcontinue;\n\t\t\t} // end if\n\t\t\n\t\t\tint cnt = min((-1 * currLife) / heal.first + 1, (H - segMax) / heal.first);\n\t\t\tans += cnt;\n\t\t\tcurrLife += cnt * heal.first;\t\t\t\n\n\t\t\tseg.update(heal.second, i + 1, 0, 0, seg.SIZE, cnt * heal.first);\n\t\t\tque.push(P(heal));\n\t\t} // end while\n\t} // end for\n\n\tcout << ans << endl;\n\t\t  \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define mod 1000000007 //1e9+7\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 4010\n\nint main(){\n  int n,h;\n  int d[SIZE],u[SIZE];\n  \n  scanf(\"%d%d\",&n,&h);\n\n  for(int i=0;i<n-1;i++){\n    scanf(\"%d%d\",d+i,u+i);\n\n  }\n\n  ll ans = 0;\n  int l = 0;\n  int power = h;\n  ll powermemo[SIZE] = {};\n  ll sum[SIZE] = {};\n  ll now_sum = 0;\n  \n  priority_queue<pair<int,int> > pq;\n  \n  for(int i=0;i<n-1;i++){\n\n    pq.push({u[i],i});\n    \n    while(power-d[i] <= 0){\n\n      pair<int,int> p = pq.top();\n\n      assert(!pq.empty());\n      \n      if(p.second < l){\n\tpq.pop();\n\tcontinue;\n      }\n      \n      if(h - (powermemo[p.second]+(now_sum + sum[p.second])) <= p.first){\n\tint max_i = p.second;\n\tpq.pop();\n\n\twhile(pq.size()){\n\t  p = pq.top();\n\n\t  if(h - (powermemo[p.second]+(now_sum + sum[p.second])) > p.first) break;\n\n\t  max_i = max(max_i,p.second);\n\n\t  pq.pop();\n\t}\n\t\n\tll add = h - powermemo[max_i]+(now_sum + sum[max_i]);\n\tpower += add;\n\tnow_sum += add;\n\tsum[i+1] += -add;\n\n\tl = max_i;\n\tans ++;\n\t\n      }else{\n\tll d = h - (powermemo[p.second]+(now_sum + sum[p.second]));\n\n\tll add = d/p.first * p.first;\n\tpower += add;\n\tnow_sum += add;\n\tsum[i+1] += -add;\n\t\n\tl = p.second;\n\tans += d/p.first;\n      }\n    }\n\n    sum[i+1] += sum[i];\n    powermemo[i] = power;\n    power -= d[i];\n  }\n\n  printf(\"%lld\\n\",ans);\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <vector>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint N, H, d[100009], h[100009]; map<int, int> dp[2]; vector<int> z[100009];\nint main() {\n\tcin >> N >> H;\n\tfor (int i = 0; i < N - 1; i++) cin >> d[i] >> h[i];\n\tint count = 0; z[0] = { H }; dp[0][H] = 1;\n\tfor (int i = 0; i < N - 1; i++) {\n\t\tdp[1].clear();\n\t\tfor (int j : z[i]) {\n\t\t\tfor (int k = 0; j + (k - 1) * h[i] <= H; k++) {\n\t\t\t\tint val = min(j + k * h[i], H) - d[i];\n\t\t\t\tif (val > 0) {\n\t\t\t\t\tif (dp[1][val]) dp[1][val] = min(dp[1][val], dp[0][j] + k);\n\t\t\t\t\telse dp[1][val] = dp[0][j] + k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> w;\n\t\tfor (pair<int, int> j : dp[1]) w.push_back(j.first);\n\t\tfor (int j = (int)w.size() - 2; j >= 0; j--) dp[1][w[j]] = min(dp[1][w[j]], dp[1][w[j + 1]]);\n\t\tz[i + 1].push_back(w.back());\n\t\tfor (int j = (int)w.size() - 2; j >= 0; j--) {\n\t\t\tif (dp[1][w[j + 1]] != dp[1][w[j]]) z[i + 1].push_back(w[j]);\n\t\t}\n\t\tdp[0].clear();\n\t\tfor (int j : z[i + 1]) dp[0][j] = dp[1][j];\n\t\tcount += w.size();\n\t}\n\tcout << (*dp[1].begin()).second - 1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\ntypedef pair<int,int> P;\n \nbool operator < (const P &a, const P &b){\n\tif(a.first != b.first){\n\t\treturn (a.first< b.first);\n\t}else{\n\t\treturn (a.second< b.second);\n\t}\n}\ntypedef long long ll;\n\nint n,mh;\nint n2=1<<17;\nint d[100001],h[100001];\nll dat[1<<18],sum[1<<18];\n\nint query(int a,int b,int k,int l,int r){\n\tif(r<=a || b<=l)return 0;\n\tif(a<=l && r<=b)return dat[k]+sum[k];\n\telse{\n\t\tint ml=query(a,b,k*2+1,l,(l+r)/2);\n\t\tint mr=query(a,b,k*2+2,(l+r)/2,r);\n\t\treturn (max(ml,mr)+sum[k]);\n\t}\n}\n\nvoid add(int a,int b,int x,int k,int l,int r){\n\tif(r<=a || b<=l)return;\n\tif(a<=l && r<=b){\n\t\tsum[k]+=x;\n\t\twhile(k>0){\n\t\t\tk=(k-1)/2;\n\t\t\tdat[k]=max(dat[k*2+1]+sum[k*2+1],dat[k*2+2]+sum[k*2+2]);\n\t\t}\n\t}else{\n\t\tadd(a,b,x,k*2+1,l,(l+r)/2);\n\t\tadd(a,b,x,k*2+2,(l+r)/2,r);\n\t}\n}\n\nint main(void){\n\tscanf(\"%d%d\",&n,&mh);\n\tfor(int i=0;i<n-1;i++){\n\t\tscanf(\"%d%d\",&d[i],&h[i]);\n\t}\n\tll res=0;\n\tint nh=mh;\n\tpriority_queue<P> que;\n\tfor(int i=0;i<n-1;i++){\n\t\tadd(i,i+1,nh,0,0,n2);\n\t\tP in;\n\t\tin.second=i;\n\t\tin.first=h[i];\n\t\tque.push(in);\n\t\tnh-=d[i];\n\t\t\n\t\twhile(nh<=0){\n\t\t\tP p=que.top();\n\t\t\tque.pop();\n\t\t\tint Smax=query(p.second,i+1,0,0,n2);\n\t\t\t\n\t\t\tif(p.first+Smax>mh){\n\t\t\t\tp.first=mh-Smax;\n\t\t\t\tque.push(p);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tll cost=min((-1*nh)/p.first+1,(mh-Smax)/p.first);\n\t\t\tres+=cost;\n\t\t\tnh+=cost*p.first;\n\t\t\tadd(p.second,i+1,cost*p.first,0,0,n2);\n            \t\tque.push(p);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint main() {\n\tlong long n, h, b, c, sum = 0;\n\tcin >> n >> h;\n\tlong long  h2 = h,a=0;\n\tfor (int i = 0; i < n-1; i++) {\n\t\tcin >> b >> c;\n\t\twhile (h <= 0) {\n\t\t\th += a;\n\t\t\tsum++;\n\t\t}\n\t\tif (h > h2) h = h2;\n\t\th -= b;\n\t\ta = max(a, c);\n\t}\n\twhile (h <= 0) {\n\t\tsum++;\n\t\th += a;\n\t}\n\tcout << sum << endl;\n\tcin >> sum;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nconst int MAX_N = 100001*2;\n\nstruct SegMax {\n  int data[MAX_N * 2 - 1];\n  int datb[MAX_N * 2 - 1];\n  int n;\n  SegMax(int n) : n(n) {\n    REP(i,n) data[i]=datb[i]=0;\n  }\n  void add(int a, int b, int x) {\n    add(a,b,x,0,0,n);\n  }\n  void add(int a, int b, int x, int k, int l, int r) {\n    if (a <= l && r <= b) data[k] += x;\n    else if (l<b && a<r) {\n      add(a, b, x, k*2+1, l, (l+r)/2);\n      add(a, b, x, k*2+2, (l+r)/2, r);\n      datb[k] = max(data[k*2+1]+datb[k*2+1], data[k*2+2]+datb[k*2+2]);\n    }\n  }\n  int getmax(int a, int b) {\n    return getmax(a,b,0,0,n);\n  }\n  int getmax(int a, int b, int k, int l, int r) {\n    if (b<=l || r<=a) return 0;\n    else if (a<=l && r<=b) {\n      return data[k] + datb[k];\n    } else {\n      int res = 0;\n      res = max(res, getmax(a, b, k*2+1, l, (l+r)/2));\n      res = max(res, getmax(a, b, k*2+2, (l+r)/2, r));\n      return res + data[k];\n    }\n  }\n};\n\nint di[100000];\nint hi[100000];\n\nint main() {\n  int N, H;\n  cin >> N >> H;\n  REP(i,N-1) {\n    scanf(\"%d%d\",di+i,hi+i);\n  }\n  SegMax st(N);\n  priority_queue<pii> Q;\n  int now = H;\n  ll ans = 0;\n  REP(i,N-1) {\n    st.add(i,i+1,now);\n    Q.push(pii(hi[i], i));\n    now -= di[i];\n    // cout << i << \" ; \" << now << endl;\n    while(now<=0) {\n      pii p = Q.top(); Q.pop();\n      int heal = p.first;\n      int pos = p.second;\n      // cout << \"(pos,heal) = \" << pos << \",\" << heal << endl;\n      int smax = st.getmax(pos, i+1);\n      // cout << \"segmax = \" << smax << endl;\n      if (smax + heal > H) {\n        Q.push(pii(H-smax, pos));\n        continue;\n      }\n      int num = min((0-now)/heal+1, (H-smax)/heal);\n      now += num*heal;\n      ans += num;\n      // cout << \"num = \" << num << endl;\n      // cout << \"now = \" << now << endl;\n      st.add(pos, i+1, num*heal);\n      Q.push(p);\n    }\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint dp[100000],hp[100000];\nlong long int ans=-1;\nvoid heal(long long int count,int N,int H,int now,int now_hp){\n  if(count<ans||ans==-1){ \n    if(now==N){\n      if(count<ans||ans<0) ans = count;\n    }else  if(hp[now+1]>=hp[now]&&now!=N-1){\n      if(now_hp>dp[now]) heal(count,N,H,now+1,now_hp-dp[now]);\n      else{\n\tint cou;\n\tcou = (dp[now]-now_hp) / hp[now] + 1;\n\tnow_hp += hp[now] * cou;\n\tcount += cou;\n\tif(now_hp>H) now_hp = H;\n\theal(count,N,H,now+1,now_hp-dp[now]);\n      } \n    }\n    else{\n      if(now_hp-dp[now]>0) heal(count,N,H,now+1,now_hp-dp[now]);\n      int cou=0;\n      while(now_hp<H){\n\tcou++;\n\tnow_hp += hp[now];\n\tif(now_hp>H) now_hp = H;\n\tif(now_hp-dp[now]>0) heal(count+cou,N,H,now+1,now_hp-dp[now]);\n      }\n    }\n  }\n}\nint main(){\n  int N,H;\n  cin >> N >> H;\n  for(int i=1;i<N;i++) cin >> dp[i] >> hp[i];\n  heal(0,N,H,1,H);\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\n#define int long long\n\nconst int MAX_N = 100010;\n\nclass segTree{\n    public:\n        int n, dat[4 * MAX_N];\n        void init(int n_, int value, int dat_b[4 * MAX_N] = NULL){\n            n = 1;\n            while(n <= n_) n *= 2;\n            rep(i,2 * n){\n                dat[i] = value;\n                if(dat_b != NULL) dat_b[i] = value;\n            }\n        }\n        void initArray(int n_, int a[MAX_N]){ //??????a??§????????????\n            n = 1;\n            while(n <= n_) n *= 2;\n            for(int i = n; i < n * n; i++){\n                dat[i] = a[i - n];\n            }\n            for(int i = n - 1; i >= 1; i--){\n                dat[i] = min(dat[i * 2], dat[i * 2 + 1]);\n                //dat[i] = dat[i * 2] + dat[i * 2 + 1];\n            }\n        }\n        void output(int a[4 * MAX_N]){\n            show(\"print\");\n            range(i,1,n * 2) cout << (a[i] == INT_MAX ? 0 : a[i]) << ' ';\n            cout << endl;\n        }\n};\n\nclass rangeAddQuery : public segTree{\n    //dat : ???????????????????§???????????????????????????????\n    //dat_add : ????§???§?????????????????????????????????\n    private:\n        int dat_add[4 * MAX_N];\n        int query(int a, int b, int k, int l, int r){\n            if(b <= l || r <= a) return 0;\n            if(a <= l && r <= b) return dat[k] * (r - l) + dat_add[k];\n\n            int res = (min(b, r) - max(a, l)) * dat[k];\n            res += query(a, b, k * 2, l, (l + r) / 2);\n            res += query(a, b, k * 2 + 1, (l + r) / 2, r);\n            return res;\n        }\n        void add(int a, int b, int k, int l, int r, int x){\n            if(a <= l && r <= b){\n                dat[k] += x;\n            }else if(l < b && a < r){\n                dat_add[k] += (min(b, r) - max(a, l)) * x;\n                add(a, b, k * 2, l, (l + r) / 2, x);\n                add(a, b, k * 2 + 1, (l + r) / 2, r, x);\n            }\n        }\n    public:\n        void init(int n_){ segTree::init(n_, 0, dat_add); }\n        int query(int a, int b){ return query(a,b,1,0,n); }\n        void add(int s, int t, int x){ add(s, t, 1, 0, n, x); }\n        void add(int i, int x){ add(i, i + 1, 1, 0, n, x); }\n        int get(int a){ return query(a, a + 1); }\n};\n\nclass rangeSumQuery : public segTree{\n    private:\n        int query(int a, int b, int k, int l, int r){\n            if(r <= a || b <= l) return 0;\n            if(a <= l && r <= b) return dat[k];\n\n            int vl = query(a, b, k * 2, l, ( l + r) / 2);\n            int vr = query(a, b, k * 2 + 1, (l + r) / 2, r);\n            return vl + vr;\n        }\n    public:\n        void init(int n_){ segTree::init(n_, 0); }\n        void update(int i, int x){\n            i += n; //????????????\n            dat[i] += x;\n            while(i > 0){ //?????????????????´??°\n                dat[i / 2] = dat[i] + dat[i^1];\n                i = i / 2;\n            }\n        }\n        int query(int a, int b){ return query(a,b,1,0,n); }\n        int get(int a){ return query(a, a + 1); }\n};\n\nclass rangeMinimumQuery : public segTree{\n    private:\n        int query(int a, int b, int k, int l, int r){\n            //[a, b) ??¨[l, r)???????????????????????°???INT_MAX\n            if(r <= a || b <= l) return INT_MAX;\n            //[a,b)???[l,r)????????¨???????????§????????°?????????????????????\n            if(a <= l && r <= b) return dat[k];\n\n            //????????§???????????°??????????????????????°????\n            int vl = query(a, b, k * 2, l, ( l + r) / 2);\n            int vr = query(a, b, k * 2 + 1, (l + r) / 2, r);\n            return min(vl, vr);\n        }\n    public:\n        void init(int n_){ segTree::init(n_,INT_MAX); }\n        void update(int i, int x){\n            i += n; //????????????\n            dat[i] = x;\n            while(i > 0){ //?????????????????´??°\n                dat[i / 2] = min(dat[i], dat[i^1]);\n                i = i / 2;\n            }\n        }\n        //[a, b)???????°????????±???????\n        int query(int a, int b){ return query(a,b,1,0,n); }\n};\n\nclass rangeUpdateQuery : public segTree{ //??????????????????update??§?????????min??¨???sum???????????????\n    private:\n        int dat_lazy[4 * MAX_N]; //?????¶???????????????????????????\n        int query(int a, int b, int k, int l, int r){\n            //???????£?\n            evaluate(k);\n\n            if(b <= l || r <= a) return INT_MAX;\n            else if(a <= l && r <= b) return dat[k];\n\n            int vl = query(a, b, k * 2, l, (l + r) / 2);\n            int vr = query(a, b, k * 2 + 1, (l + r) / 2, r);\n            return min(vl, vr);\n        }\n        inline void evaluate(int k){\n            if(dat_lazy[k] == INT_MAX) return;\n            dat[k] = dat_lazy[k];\n            if(k < n){\n                dat_lazy[2 * k] = dat_lazy[k]; //?????¶????????¬????????¨???\n                dat_lazy[2 * k + 1] = dat_lazy[k];\n            }\n            dat_lazy[k] = INT_MAX;\n        }\n        void update(int a, int b, int k, int l, int r, int x){\n            evaluate(k);\n\n            if(b <= l || r <= a ) return;\n\n            if(a <= l && r <= b){\n                dat_lazy[k] = x;\n            }else{\n                evaluate(k);\n                update(a, b, k * 2, l, (l + r) / 2, x);\n                update(a, b, k * 2 + 1, (l + r) / 2, r, x);\n            }\n        }\n    public:\n        void init(int n_){ segTree::init(n_,INT_MAX,dat_lazy); }\n        int query(int a, int b){ return query(a,b,1,0,n); }\n        void update(int s, int t, int x){ update(s, t, 1, 0, n, x); }\n        void update(int i, int x){ update(i, i + 1, 1, 0, n, x); }\n        int get(int a){ return query(a, a + 1); };\n};\n\nclass starrySky : public segTree{\n    private:\n        int query(int a, int b, int k, int l, int r){\n            if(b <= l || r <= a) return 0;\n            if(a <= l && r <= b) return dat[k] + dat_add[k];\n\n            int vl = query(a, b, k * 2, l, (l + r) / 2);\n            int vr = query(a, b, k * 2 + 1, (l + r) / 2, r);\n            return max(vl, vr) + dat_add[k];\n        }\n        void add(int a, int b, int k, int l, int r, int x){\n            if(b <= l || r <= a) return;\n            if(a <= l && r <= b){\n                dat_add[k] += x;\n            }else{\n                add(a, b, k * 2, l, (l + r) / 2, x);\n                add(a, b, k * 2 + 1, (l + r) / 2, r, x);\n                dat[k] = max(dat[k * 2] + dat_add[k * 2], dat[k * 2 + 1] + dat_add[k * 2 + 1]);\n            }\n        }\n        void init(int n_){ segTree::init(n_,0,dat_add); }\n    public:\n        int dat_add[4 * MAX_N];\n        starrySky(int n){ init(n); }\n        int query(int a, int b){ return query(a, b, 1, 0, n); }\n        void add(int s, int t, int x){ add(s, t, 1, 0, n, x); }\n        void add(int i, int x){ add(i, i + 1, 1, 0, n, x); }\n};\n\n\nsigned main(){\n    long long n, h;\n    cin >> n >> h;\n\n    starrySky seg(n); //??????\n    priority_queue<pair<long long, int>> q; //??????????????????pos\n    long long cur = h, ans = 0;\n    rep(i,n - 1){\n        long long damage, heal;\n        cin >> damage >> heal;\n        q.push(make_pair(heal, i));\n\n        seg.add(i + 1, cur);\n        cur -= damage;\n        while(cur <= 0){\n            pair<long long, int> use = q.top(); q.pop();\n            long long maxHP = seg.query(use.second + 1, i + 2); //????????°??????????????¨??°?????§?????????????????§\n\n            if(maxHP + use.first > h){ //??????????????????????¶????????????§?????????????????????????????´\n                q.push(make_pair(h - maxHP, use.second));\n                continue;\n            }\n\n            long long can_use = (h - maxHP) / use.first;\n            long long require = ceil((-1.0 * cur + 1) / use.first);\n            long long used = min(can_use, require);\n            ans += used;\n            cur += used * use.first;\n\n            seg.add(use.second + 1, i + 2, used * use.first);\n            q.push(use);\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,pair<ll,ll> > pp;\npp mm[100001];\nll d[100001];\n\nint main(){\n    ll n,h;\n    ll ans=0;\n    cin>>n>>h;\n    ll di,hi,ch=h;\n    for(int i=0;i<n-1;++i){\n        cin>>di>>hi;\n        mm[i].first=ch+hi<=h||ch<0 ? hi:h-ch;mm[i].second.first=i;mm[i].second.second=ch;\n        d[i]=di;\n        ch -= di;\n    }\n    int l=0;\n    for(int i=0;i<n;++i){\n        ch=mm[i].second.second;\n        if(ch<=0){\n            pp t=*max_element(mm+l,mm+i);\n            hi=t.first;\n            int ch2=t.second.second;\n            i=t.second.first;l=i;\n            int dv;\n            if(-ch/hi+1>(h-ch2)/hi-1){\n                dv=(h-ch2)/hi;\n                ans+=dv;\n                ch=ch2+hi*dv;\n            } \n            else{\n                dv=-ch/hi+1;\n                ans+=dv;\n                ch=min(h,ch2+hi*dv); \n            }             \n        }\n        hi=mm[i].first;\n        mm[i].first=ch+hi>h ? h-ch:hi;\n        mm[i].second.second=ch; \n        mm[i+1].second.second= ch-d[i];\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\ntemplate<typename T>\nclass LazyPropagationSegmentTree {\npublic:\n  LazyPropagationSegmentTree(int n) : size_(1) {\n    while(size_ < n) size_ <<= 1;\n    node_.assign(size_ << 1, 0);\n    lazy_.assign(size_ << 1, 0);\n  }\n  T find(int left, int right) {return find(left, right + 1, 1, 0, size_);}\n  void add(int left, int right, T value) {add(left, right + 1, value, 1, 0, size_);}\nprivate:\n  int left_child(int node) const {return node << 1;}\n  int right_child(int node) const {return (node << 1) + 1;}\n  T find(int a, int b, int k, int l, int r) {\n    if(b <= l || r <= a) return 0;\n    if(a <= l && r <= b) return node_.at(k) + (r - l) * lazy_.at(k);\n    lazy_.at(left_child(k)) += lazy_.at(k);\n    lazy_.at(right_child(k)) += lazy_.at(k);\n    lazy_.at(k) = 0;\n    auto vl = find(a, b, left_child(k), l, (l + r) / 2);\n    auto vr = find(a, b, right_child(k), (l + r) / 2, r);\n    return vl + vr;\n  }\n  T add(int a, int b, T value, int k, int l, int r) {\n    if(b <= l || r <= a) return node_.at(k) + (r - l) * lazy_.at(k);\n    if(a <= l && r <= b) return node_.at(k) + (r - l) * (lazy_.at(k) += value);\n    lazy_.at(left_child(k)) += lazy_.at(k);\n    lazy_.at(right_child(k)) += lazy_.at(k);\n    lazy_.at(k) = 0;\n    auto vl = add(a, b, value, left_child(k), l, (l + r) / 2);\n    auto vr = add(a, b, value, right_child(k), (l + r) / 2, r);\n    return node_.at(k) = vl + vr;\n  }\n  int size_;\n  std::vector<T> node_;\n  std::vector<T> lazy_;\n};\n\n#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Node {int f; long long h;};\nbool operator<(const Node& lhs, const Node& rhs) {\n  if(lhs.h != rhs.h) return lhs.h < rhs.h;\n  return lhs.f < rhs.f;\n}\n\nint main() {\n  int N, H;\n  cin >> N >> H;\n\n  LazyPropagationSegmentTree<long long> hp(N + 1);\n  hp.add(0, N, H);\n\n  long long answer = 0;\n  int last = 0;\n  priority_queue<Node> q;\n\n  for(int i = 1; i < N; ++i) {\n    long long d, h;\n    cin >> d >> h;\n\n    q.push({i, h});\n    hp.add(i, N, -d);\n\n    while(hp.find(i, i) <= 0) {\n      auto node = q.top();\n\n      if(node.f < last) {\n        q.pop();\n        continue;\n      }\n\n      if(H < node.h + hp.find(node.f-1, node.f-1)) {\n        q.pop();\n        q.push({node.f, H - hp.find(node.f-1, node.f-1)});\n        continue;\n      }\n\n      last = node.f;\n      while(hp.find(i, i) <= 0 && node.h + hp.find(node.f-1, node.f-1) <= H) {\n        ++answer;\n        hp.add(node.f-1, N, node.h);\n      }\n    }\n  }\n\n  cout << answer <<endl;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 0553\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#define rep(i,a) for( int i = 0; i != (a); ++i )\n\ntypedef long long ll;\ntypedef std::pair<int, int> P;\n\nint N, H;\nint d[100000], h[100000];\nstd::priority_queue<P> pque;\n\nll data[1<<18], datb[1<<18];\n\nvoid add( int a, int b, int x, int k, int l, int r )\n{\n\tif( a <= l && r <= b )\n\t{\n\t\tdatb[k] += x;\n\n\t\twhile( k )\n\t\t{\n\t\t\tk = (k-1)>>1;\n\t\t\tdata[k] = std::max( data[(k<<1)+1]+datb[(k<<1)+1], data[(k<<1)+2]+datb[(k<<1)+2] );\n\t\t}\n\t}\n\telse if( l < b && a < r )\n\t{\n\t\tadd( a, b, x, (k<<1)+1, l, (l+r)>>1 );\n\t\tadd( a, b, x, (k<<1)+2, (l+r)>>1, r );\n\t}\n\n\treturn;\n}\n\nint query( int a, int b, int k, int l, int r )\n{\n\tif( b <= l || r <= a )\n\t\treturn 0;\n\telse if( a <= l && r <= b )\n\t\treturn data[k]+datb[k];\n\telse\n\t\treturn std::max( query( a, b, (k<<1)+1, l, (l+r)>>1 ), query( a, b, (k<<1)+2, (l+r)>>1, r ) ) + datb[k];\t\n}\n\nint main()\n{\n\tscanf( \"%d%d\", &N, &H );\n\trep( i, N-1 )\n\t\tscanf( \"%d%d\", d+i, h+i );\n\n\tint hp = H;\n\tll ans = 0;\n\trep( i, N-1 )\n\t{\n\t\tadd( i, i+1, hp, 0, 0, 1<<17 );\n\n\t\thp -= d[i];\n\t\tpque.push( P( h[i], i ) );\n\n\t\twhile( hp <= 0 )\n\t\t{\n\t\t\tP p = pque.top(); pque.pop();\n\t\t\tint heal = p.first, ma = query( p.second, i+1, 0, 0, 1<<17 );\n\n\t\t\tif( heal+ma > H )\n\t\t\t{\n\t\t\t\tp.first = H-ma;\n\t\t\t\tpque.push( p );\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint cnt = std::min( -hp/heal+1, (H-ma)/heal );\n\t\t\tans += cnt;\n\t\t\thp += cnt*heal;\n\n\t\t\tadd( p.second, i+1, cnt*heal, 0, 0, 1<<17 );\n\t\t\tpque.push( p );\n\t\t}\n\t}\n\n\tprintf( \"%lld\\n\", ans );\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main(){\n  int N,H;\n  cin >> N >> H;\n  unsigned long long int ans=0;\n  int dp[H],di,hi,in=0,in2=0;\n  dp[0] = H;\n  for(int i=1;i<N;i++){\n    cin >> di >> hi;\n    for(int i=in2+1;i<H;i++) dp[i] = -1;\n    while(dp[in]!=H){\n      dp[in+1] = max(min(dp[in]+hi,H),dp[in+1]);\n      in++;\n    }\n    in2 = 0;\n    for(int i=0;i<=in;i++){\n      if(dp[i]-di<=0) continue;\n      else if(i!=0&&dp[i-1]-di<=0) ans += i;\n      dp[in2] = dp[i]-di;\n      in2++;\n    }\n    in = in2-1;\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\nint di[100000];\nint hi[100000];\nint life[100000];\n\nint main() {\n  int N,H;\n  scanf(\"%d%d\",&N,&H);\n  REP(i,N-1) scanf(\"%d%d\",di+i,hi+i);\n  priority_queue<pii> Q;\n  ll ans = 0;\n  life[0] = H;\n  int maxid = 0;\n  REP(i,N-1) {\n    if (i) life[i] = life[i-1] - di[i];\n    else life[i] = H - di[i];\n    Q.push(pii(hi[i],i));\n    while(life[i] < 0) {\n      pii p = Q.top(); Q.pop();\n      int heal = p.first;\n      int id = p.second;\n\n      if (id < maxid) continue;\n      maxid = id;\n      int num = min((0-life[i])/heal+1, (H-life[id])/heal);\n      if (num == 0) continue;\n      life[i] += num*heal;\n      ans += num;\n      Q.push(p);\n    }\n  }\n  printf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n  \ntemplate<typename T1, typename T2> istream& operator>>(istream& is, pair<T1,T2>& a){ return is >> a.first >> a.second; }\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& os, pair<T1,T2>& a){ return os << a.first << \" \" << a.second; }\ntemplate<typename T> istream& operator>>(istream& is, vector< T >& vc){ for(int i = 0; i < vc.size(); i++) is >> vc[i]; return is; }\ntemplate<typename T> ostream& operator<<(ostream& os, vector< T >& vc){ for(int i = 0; i < vc.size(); i++) os << vc[i] << endl; return os; }\n  \n#define ForEach(it,c) for(__typeof (c).begin() it = (c).begin(); it != (c).end(); it++)\n#define ALL(v) (v).begin(), (v).end()\n#define UNQ(s) { sort(ALL(s)); (s).erase( unique( ALL(s)), (s).end());}\n \ntypedef long long int64;\ntypedef pair< int64 , int64 > Pi;\ntypedef pair< int , Pi > Pii;\nconst int INF = 1 << 30;\n\nvector< int64 > seg, added;\nstruct SegmentTree{\n  typedef pair< int, int > Pi;\nprivate:\n  int n;\npublic:\n  void add(int a, int b, int64 x, int k, int l, int r){\n    if( r <= a || b <= l) return;\n    if( a <= l && r <= b){\n      added[k] += x;\n      while(k > 0){\n        k = (k - 1) >> 1;\n        seg[k] = max( seg[k * 2 + 1] + added[k * 2 + 1], seg[k * 2 + 2] + added[k * 2 + 2]);\n      }\n    } else {\n      add( a, b, x, k * 2 + 1, l, (l + r) >> 1);\n      add( a, b, x, k * 2 + 2, (l + r) >> 1, r);\n    }\n  }\n  void add(int a, int b, int64 x){\n    add( a, b, x, 0, 0, n);\n  }\n\n  int64 query( int a, int b, int k, int l, int r){\n    if( r <= a || b <= l ) return 0;\n    if( a <= l && r <= b ) return seg[k] + added[k];\n    int64 vl = query( a, b, k * 2 + 1, l, (l + r) / 2);\n    int64 vr = query( a, b, k * 2 + 2, (l + r) / 2, r);\n    return(max( vl, vr) + added[k]);\n  }\n  int64 query( int a, int b){\n    return(query( a, b, 0, 0, n));\n  }\n  int64 top(){\n    return(seg[0]);\n  }\n  SegmentTree(const int& size){\n    n = 1;\n    while( n < size ) n *= 2;\n    seg = vector< int64 >(2 * n + 1, 0);\n    added = vector< int64 >(2 * n + 1, 0);\n  }\n};\n\n\nint main()\n{\n  int N, H;\n  scanf(\"%d %d\", &N, &H);\n  vector< int > d(N - 1), h(N - 1);\n  for(int i = 0; i < N - 1; i++){\n    scanf(\"%d %d\", &d[i], &h[i]);\n  }\n\n  priority_queue< Pi > que;\n  SegmentTree segtree(N);\n  int64 Life = H;\n  int64 ret = 0;\n  for(int i = 0; i < N - 1; i++){\n    segtree.add( i, i + 1, Life);\n\n    Life -= d[i];\n    que.push(make_pair( h[i], i));  //とてもわからない\n    while(Life <= 0){\n      Pi p = que.top(); que.pop();\n      int64 Big = segtree.query( p.second, i + 1); // 体力の最大値\n      if(p.first + Big > H){ // 上限を超えた\n        que.push( make_pair( H - Big, p.second));\n      } else {\n        int64 Count = min(-Life / p.first + 1, (H - Big) / p.first); // min( 必要な体力 / 回復量 + 1, (体力の上限 - 体力の最大値) / 回復量)\n        ret += Count;\n        int64 hell = Count * p.first;\n        Life += hell;\n        segtree.add( p.second, i + 1, hell);\n        que.push(p);\n      }\n    }\n  }\n  printf(\"%lld\\n\", ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#define s 131072\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll>pii;\nclass segtree\n{\npublic:\n\tll seg[s*2];\n\tll lazy[s*2];\n\tvoid lazy_evaluate(int k)\n\t{\n\t\tif(k*2+2>=s*2) return ;\n\t\tlazy[k*2+2]+=lazy[k];\n\t\tlazy[k*2+1]+=lazy[k];\n\t\tseg[k*2+2]+=lazy[k];\n\t\tseg[k*2+1]+=lazy[k];\n\t\tlazy[k]=0;\n\t}\n\tll update(int beg,int end,int idx,int lb,int ub,ll num)\n\t{\n\t\tif(ub<beg||end<lb)\n\t\t{\n\t\t\treturn seg[idx];\n\t\t}\n\t\tif(beg<=lb&&ub<=end)\n\t\t{\n\t\t\tlazy[idx]+=num;\n\t\t\tseg[idx]+=num;\n\t\t\treturn seg[idx];\n\t\t}\n\t\tif(lazy[idx])\n\t\t{\n\t\t\tlazy_evaluate(idx);\n\t\t}\n\t\treturn seg[idx]=max(update(beg,end,idx*2+1,lb,(lb+ub)/2,num),update(beg,end,idx*2+2,(lb+ub)/2+1,ub,num));\n\t}\n\tll query(int beg,int end,int idx,int lb,int ub)\n\t{\n\t\tif(ub<beg||end<lb)\n\t\t{\n\t\t\treturn -1000000000000000000LL;\n\t\t}\n\t\tif(beg<=lb&&ub<=end)\n\t\t{\n\t\t\treturn seg[idx];\n\t\t}\n\t\tif(lazy[idx])\n\t\t{\n\t\t\tlazy_evaluate(idx);\n\t\t}\n\t\treturn max(query(beg,end,idx*2+1,lb,(lb+ub)/2),query(beg,end,idx*2+2,(lb+ub)/2+1,ub));\n\t}\n};\nsegtree seg_tree;\nint main()\n{\n\tll n,x;\n\tscanf(\"%lld %lld\",&n,&x);\n\tseg_tree.update(0,s-1,0,0,s-1,x);\n\tll ret=0LL;\n\tpriority_queue<pii>que;\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tll za,zb;\n\t\tscanf(\"%lld %lld\",&za,&zb);\n\t\tque.push(make_pair(zb,i));\n\t\tfor(;;)\n\t\t{\n\t\t\tif(que.empty())\tbreak;\n\t\t\tif(seg_tree.query(i+1,i+1,0,0,s-1)>za) break;\n\t\t\tpii zan=que.top();\n\t\t\tll ka=(x-seg_tree.query(zan.second,i+1,0,0,s-1))/zan.first,kb=(1-seg_tree.query(i+1,i+1,0,0,s-1)+za+zan.first-1)/zan.first;\n\t\t\tif(ka>=kb)\n\t\t\t{\n\t\t\t\tret+=kb;\n\t\t\t\tseg_tree.update(zan.second,s-1,0,0,s-1,kb*zan.first);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tret+=ka;\n\t\t\t\tque.pop();\n\t\t\t\t//que.push(make_pair((x-seg_tree.query(zan.second,i+1,0,0,s-1))%zan.first,zan.second));\n\t\t\t\tseg_tree.update(zan.second,s-1,0,0,s-1,ka*zan.first);\n\t\t\t}\n\t\t}\n\t\tseg_tree.update(i+1,s-1,0,0,s-1,-za);\n\t}\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <assert.h>\n#define int long long\n#define N_MAX (100000)\n#define min(a,b) (((a)<(b))?(a):(b))\ntypedef struct {\n\tint pos,value;\n} Info;\n\nsigned main(){\n\tint damage_total[N_MAX]={};\n\tInfo deque[N_MAX];\n\tint head=0,tail=0;\n\tint N,H;\n\tint answer = 0;\n\n\tscanf(\"%lld%lld\",&N,&H);\t\n\tint currentHP = H;\n\tfor(int i = 0 ; i < N-1 ; i++){\n\t\tint d,h;\n\t\tscanf(\"%lld%lld\",&d,&h);\n\t\twhile( head != tail && deque[tail-1].value <= h ) tail--;\n\n\t\tdeque[tail++] = (Info){i,h};\n\t\twhile( head != tail ){\n\t\t\tint maximumRecover = H - (damage_total[i] - damage_total[deque[head].pos]);\n\t\t\tif( maximumRecover > 0 ) break;\n\t\t\thead++;\n\t\t}\n\n\t\tfor(int j = head ; j < tail && currentHP <= d ; j++){\n\t\t\t// ????????§???????????§????????????\n\t\t\tint maximumRecover = H - (damage_total[i] - damage_total[deque[j].pos]);\n\t\t\t\n\t\t\tif( maximumRecover <= currentHP) continue;\n\n\t\t\t// j??????????????§?????????????????? needRecover ????¨????\n\t\t\tint needRecover = min( maximumRecover - currentHP , d - currentHP + 1);  \n\t\t\t// ???????????? needRecover ?????????????????????????????° useCount ????±???????\n\t\t\tint useCount = (needRecover+deque[j].value-1) / deque[j].value - 1;\n\t\t\tanswer += useCount;\n\t\t\tcurrentHP += useCount*deque[j].value;\n\t\t\t// ????°??????????????¬????????´?????????£?????´?????¨??????????´?????????£?????´??????????????????????????????????????????????´??????????\t\t\t\n\t\t\tif( j+1 ==  tail || maximumRecover > currentHP + deque[j+1].value ){\n\t\t\t\tcurrentHP = min(currentHP+deque[j].value,maximumRecover);\n\t\t\t\tanswer++;\n\t\t\t}\n\t\t}\n\t\tcurrentHP -= d;\n\t\tdamage_total[i+1] = damage_total[i] + d;\n\n\t}\n\tprintf(\"%lld\\n\",answer);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,b)  FOR(i,0,b)\n#define X first\n#define Y second\n#define F first\n#define S second\n#define PB(a) push_back(a)\n#define BE(c) c.begin(),c.end()\nusing namespace std;\ntypedef long long LL;\ntypedef LL ut;\ntypedef pair<ut,ut> pr;\ntypedef pair<pr,ut> ppr;\ntypedef priority_queue<ppr,vector<ppr> > PQ;\ntypedef vector<pr> Vpr;\ntypedef vector<int> VI;\nconst int SIZE=1<<17;\nconst LL INF=1LL<<60;\nconst LL def=-INF;\nVpr flor;\nLL segA[SIZE<<1],segB[SIZE<<1];\nPQ qu;\nLL ans=0;\nLL N,H;\nLL get(int s,int e,int a,int b,int now){\n\tif(a<=s && e<=b) return segA[now]+segB[now];\n\telse if(e<a||b<s) return def;\n\telse\n\t\treturn segA[now]+max(get(s,(s+e)/2,a,b,now*2),get((s+e+1)/2,e,a,b,now*2+1));\n}\nLL get(int a,int b){return get(1,SIZE,a,b,1);}\nvoid add(int s,int e,int a,int b,LL p,int now){\n\tif(a<=s&&e<=b) segA[now]+=p;\n\telse if(e<a||b<s) return;\n\telse{\n\t\tadd(s,(s+e)/2,a,b,p,now*2);\n\t\tadd((s+e+1)/2,e,a,b,p,now*2+1);\n\t\tsegB[now]=max(segA[now*2]+segB[now*2],segA[now*2+1]+segB[now*2+1]);\n\t}\n}\nvoid add(int a,int b,LL p){add(1,SIZE,a,b,p,1);}\nvoid healing(int x){\n\tstatic int least=0;\n\twhile(get(x,x)<=0 && !qu.empty()){\n\t\t\n\t\tint now=qu.top().F.S;\n\t\tLL potencial=qu.top().F.F;\n\t\tbool isLast=qu.top().S;\n\t\tqu.pop();\n\t\tif(least>now) continue;\n\t\tleast=now;\n\t\tif(isLast){\n\t\t\tadd(now,N,potencial);\n\t\t\tans++;\t\n\n\t\t} \n\t\telse{\n\t\t\tLL times=min((H-get(now,now))/potencial,(-get(x,x)+potencial)/potencial);\n\t\t\tif(times==0) qu.push(ppr(pr(H-get(now,now),now),1));\n\t\t\telse{\n\t\t\t\tadd(now,N,times*potencial);\n\t\t\t\tans+=times;\n\t\t\t\tqu.push(ppr(pr(potencial,now),0));\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tLL a,b;\n\tcin >> N >> H;\n\tadd(1,N,H);\n\tFOR(i,1,N){\n\t\tscanf(\"%lld%lld\",&a,&b);\n\t\tif(get(i,i)<=0)\n\t\t\thealing(i);\n\t\tqu.push(ppr(pr(b,i),0));\n\t\tadd(i+1,N,-a);\n\t}\n\tif(get(N,N)<=0)\n\t\thealing(N);\n\tcout << ans << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <deque>\n#include <utility>\n#include <algorithm>\nusing namespace std;\nint main() {\n\tlong long int n,total_h,max_h,total_d=0,ans=0;\n\tscanf(\"%lld %lld\",&n,&total_h);\n\tmax_h=total_h;\n\tdeque<pair<long long int,long long int> > Q;\n\tfor(int i=0;i<n-1;i++) {\n\t\tlong long int d,h;\n\t\tscanf(\"%lld %lld\",&d,&h);\n\t\twhile(!Q.empty()&&Q.front().first<h)\n\t\t\tQ.pop_front();\n\t\tQ.push_back(make_pair(h,total_d));\n\t\ttotal_d+=d;\n\t\twhile(total_h<=total_d) {\n\t\t\tlong long int tmp_h=total_h;\n\t\t\twhile(!Q.empty()&&tmp_h+Q.front().first-Q.front().second>max_h) {\n\t\t\t\ttotal_h=max(total_h,Q.front().second+max_h);\n\t\t\t\tQ.pop_front();\n\t\t\t}\n\t\t\tif(!Q.empty()) {\n\t\t\t\ttotal_h=max(total_h,tmp_h+Q.front().first);\n\t\t\t\tlong long int tmp=max(0LL,min((total_d-total_h)/Q.front().first,(Q.front().second+max_h-total_h)/Q.front().first));\n\t\t\t\tans+=tmp;\n\t\t\t\ttotal_h+=tmp*Q.front().first;\n\t\t\t}\n\t\t\tans++;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\n#define MAX_SEG (1<<17)\n\nint remain_hp[100010];\nint healing_all[2 * MAX_SEG];\nint healing_part[2 * MAX_SEG];\nint n;\n\nvoid init(int n_) {\n    n = 1;\n    while (n < n_) n *= 2;\n}\n\n// ??????[a,b)??????x?????????\nvoid add_to_healingseg(int a, int b, int x, int k, int l, int r) {\n    if (r <= a || b <= l) return;\n    if (a <= l && r <= b) {\n        healing_all[k] += x; // ??????[l,r)??????x?????????\n        return;\n    }\n    healing_part[k] += (min(b,r) - max(a,l)) * x;\n    add_to_healingseg(a, b, x, 2*k + 1, l, (l + r)/2);\n    add_to_healingseg(a, b, x, 2*k + 2, (l + r)/2, r);\n    \n}\n\nint sum(int a, int b, int k, int l, int r) {\n    if (r <= a || b <= l) return 0;\n    if (a <= l && r <= b) return (r - l) * healing_all[k] + healing_part[k];\n    int res = 0;\n    res += (min(b,r) - max(a,l)) * healing_all[k];\n    res += sum(a, b, 2*k + 1, l, (l + r)/2);\n    res += sum(a, b, 2*k + 2, (l + r)/2, r);\n    return res;\n}\n\nint fetch_remainhp(int k) {\n    int a = remain_hp[k];\n    int b = sum(k, k + 1, 0, 0, MAX_SEG);\n    return a + b;\n}\n\nint main() {\n    int N,H;\n    cin >> N >> H;\n\n    init(N-1);\n\n    priority_queue<pair<int, int> > q;\n    long long ans = 0;\n    int curr_h = H;\n    int last_heal = -1;\n    for (int i=0; i<N-1; i++) {\n        int d,h; cin >> d >> h;\n        remain_hp[i] = curr_h;\n        q.push(make_pair(h, i));\n\n        //printf(\"[i:%d,d:%d,h:%d] curr_h:%d\\n\", i, d, h, curr_h);\n\n        while (d >= curr_h) {\n            int ch  = q.top().first;\n            int idx = q.top().second;\n            int rhp = fetch_remainhp(idx);\n            if (ch + rhp > H) {\n                q.pop();\n                q.push(make_pair(H - rhp, idx));\n                continue;\n            }\n            // ?????????????????????????±???????????????????\n            if (last_heal > idx) {\n                q.pop();\n                continue;\n            }\n            // ?????§?????§????????§???????????????????????????????????????1???\n            int heal_cnt = max(1, min(d - curr_h, H - fetch_remainhp(idx)) / ch);\n            int heal_amount = min(heal_cnt * ch, H - fetch_remainhp(idx));\n            ans += (long long)heal_cnt;\n            add_to_healingseg(idx, i+1, heal_amount, 0, 0, MAX_SEG);\n            curr_h = fetch_remainhp(i);\n            last_heal = idx;\n            //printf(\" - used heal(i:%d, h:%d) -> curr_h:%d, heal_cnt:%d, heal_amount:%d, ans:%lld\\n\", idx, ch, curr_h, heal_cnt, heal_amount, ans);\n            q.pop();\n            q.push(make_pair(min(ch, H - fetch_remainhp(idx)), idx));\n        }\n        curr_h -= d;\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int>P;\nconst int SIZE=1<<17;\n\nstruct seg_tree{\n    vector<int>ma,lazy;\n\n    seg_tree():ma(SIZE*2-1,0),lazy(SIZE*2-1,0){}\n\n    void evaluate(int k){\n        ma[k]+=lazy[k];\n        if(k<SIZE-1){\n            lazy[k*2+1]+=lazy[k];\n            lazy[k*2+2]+=lazy[k];\n        }\n        lazy[k]=0;\n    }\n    void update_node(int k){\n        ma[k]=max(ma[k*2+1],ma[k*2+2]);\n    }\n\n    void add(int a,int b,int x,int k=0,int l=0,int r=SIZE){\n        evaluate(k);\n        if(r<=a||b<=l)return;\n        if(a<=l&&r<=b){\n            lazy[k]+=x;\n            evaluate(k);\n            return;\n        }\n        int m=(l+r)/2;\n        add(a,b,x,k*2+1,l,m);\n        add(a,b,x,k*2+2,m,r);\n        update_node(k);\n    }\n\n    int get_max(int a,int b,int k=0,int l=0,int r=SIZE){\n        evaluate(k);\n        if(r<=a||b<=l)return 0;\n        if(a<=l&&r<=b)return ma[k];\n        int m=(l+r)/2;\n        int vl=get_max(a,b,k*2+1,l,m);\n        int vr=get_max(a,b,k*2+2,m,r);\n        return max(vl,vr);\n    }\n};\n\nint N,H;\nint d[100000],h[100000];\n\nint main(){\n    cin>>N>>H;\n    for(int i=0;i<N-1;i++)cin>>d[i]>>h[i];\n\n    seg_tree seg;\n    int cur=H;\n    int ans=0;\n    priority_queue<P>que;\n    for(int i=0;i<N-1;i++){\n        seg.add(i,i+1,cur);\n        cur-=d[i];\n\n        que.push(P(h[i],i));\n\n        while(cur<=0){\n            P p=que.top();que.pop();\n            int ma=seg.get_max(p.second,i+1);\n            if(p.first+ma>H){\n                que.push(P(H-ma,p.second));\n                continue;\n            }\n\n            int x=min((-cur)/p.first+1,(H-ma)/p.first);\n            ans+=x;\n            cur+=x*p.first;\n            seg.add(p.second,i+1,p.first*x);\n        }\n    }\n\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint main()\n{\n    int n, maxHp;\n    cin >> n >> maxHp;\n    vector<int> d(n-1), h(n-1);\n    for(int i=0; i<n-1; ++i)\n        cin >> d[i] >> h[i];\n\n    int hp = maxHp;\n    int heal = 0;\n    long long ret = 0;\n    for(int i=0; i<n-1; ++i){\n        if(h[i] > heal)\n            heal = h[i];\n\n        int x = max(0, (d[i] + 1 - hp + heal - 1) / heal);\n        ret += x;\n        hp = min(maxHp, hp + x * heal);\n\n        hp -= d[i];\n        heal -= d[i];\n    }\n\n    cout << ret << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define mod 1000000007 //1e9+7\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100000\n\nint main(){\n  int n,h;\n  int d[SIZE],u[SIZE];\n  \n  scanf(\"%d%d\",&n,&h);\n\n  for(int i=0;i<n-1;i++){\n    scanf(\"%d%d\",d+i,u+i);\n\n  }\n\n  ll ans = 0;\n  int l = 0;\n  int power = h;\n  ll powermemo[SIZE] = {};\n  ll sum[SIZE] = {};\n  ll now_sum = 0;\n  \n  priority_queue<pair<int,int> > pq;\n  \n  for(int i=0;i<n-1;i++){\n    //cerr << i << \" : \" << power << endl;\n    \n    pq.push({u[i],i});\n    powermemo[i] = power;\n\n    while(power-d[i] <= 0){\n\n      //cerr << \"power\" << \" : \" << power << endl;\n      \n      int max_add = 0;\n      int max_l = 0;\n      int add_ans = 0;\n      bool back = false;\n      pair<int,int> p,max_p;\n      \n      while(1){\n\tif(pq.empty()) break;\n\t\n\tp = pq.top();\n\tpq.pop();\n\n\t//cerr << \"p = {\" << p.first << \" : \" << p.second << \"} \" << pq.size() << endl;\n\t\n\tif(p.second < l) continue;\n\t\n\tif(h - (powermemo[p.second]+(now_sum + sum[p.second])) <= p.first){\n\t  \n\t  ll add = h - (powermemo[p.second]+(now_sum + sum[p.second]));\n\n\t  //cerr << h << \"-(\" << powermemo[p.second] << \" + \" << now_sum << \" + \" << sum[p.second] << \")\" <<endl;\n\t  //cerr << \"a = \" << add << endl;\n\t  \n\t  if(max_add < add || (max_add == add && max_l < p.second)){\n\t    max_l = p.second;\n\t    max_add = add;\n\t    max_p = p;\n\t    add_ans = 1;\n\t    back = false;\n\t  }\n\t  \n\t}else{\n\t  \n\t  if(max_add > p.first){\n\t    pq.push(p);\n\t    break;\n\t  }\n\t  \n\t  ll t = h - (powermemo[p.second]+(now_sum + sum[p.second]));\n\t  \n\t  ll add = min(t/p.first * p.first,\n\t\t       (ll)((d[i]-power)/p.first + 1) * p.first);\n\t  \n\t  if(max_add < add ||  (max_add == add && max_l < p.second)){\n\t    max_l = p.second;\n\t    max_add = add;\n\t    max_p = p;\n\t    add_ans = add/p.first;\n\t    back = true;\n\t  }\n\t  \n\t  break;\n\t}\n\t\n      } //while\n      \n      l = max_l;\n      power += max_add;\n      now_sum += max_add;\n      sum[i] -= max_add;\n      ans += add_ans;\n      \n      if(back) pq.push(max_p);\n      \n      //cerr << \"add : \" <<  max_add << \" (\" << add_ans << \")\" << max_l << endl;\n      assert(max_add>0);\n      \n      powermemo[i] = power;\n    }\n    \n    \n    sum[i+1] += sum[i];\n    powermemo[i] = power;\n    power -= d[i];\n  }\n  \n  printf(\"%lld\\n\",ans);\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Bokan ga bokka--nn!!\n//Daily Lunch Special Tanoshii !!\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\ntypedef long long ll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\n#define s(x) scanf(\"%d\",&x)\n#define maxs 1<<18\nclass segtree\n{\npublic:\n\tll seg[maxs];\n\tll lazy[maxs];\n\t\n\tvoid init(){ memset(seg,0,sizeof(seg));memset(lazy,0,sizeof(lazy));}\n\tvoid lazy_evaluate(int x)\n\t{\n\t\tif(x*2+2>=maxs) return;\n\t\tlazy[x*2+1]+=lazy[x];\n\t\tlazy[x*2+2]+=lazy[x];\n\t\tseg[x*2+1]+=lazy[x];\n\t\tseg[x*2+2]+=lazy[x];\n\t\tlazy[x]=0;\n\t}\n\tll update(int beg,int en,int idx,int lb,int ub,int val)\n\t{\n\t\tif(ub<beg || en<lb)\n\t\t{\n\t\t\treturn seg[idx];\n\t\t}\n\t\tif(beg<=lb && ub<=en)\n\t\t{\n\t\t\tlazy[idx]+=val;\n\t\t\tseg[idx]+=val;\n\t\t\tlazy_evaluate(idx);\n\t\t\treturn seg[idx];\n\t\t}\n\t\tif(lazy[idx])\n\t\t{\n\t\t\tlazy_evaluate(idx);\n\t\t}\n\t\treturn seg[idx]=max(update(beg,en,idx*2+1,lb,(lb+ub)/2,val),update(beg,en,idx*2+2,(lb+ub)/2+1,ub,val));\n\t}\n\tll query(int beg,int en,int idx,int lb,int ub)\n\t{\n\t\tif(ub<beg || en<lb)\n\t\t{\n\t\t\treturn -100000000000LL;\n\t\t}\n\t\tif(beg<=lb && ub<=en)\n\t\t{\n\t\t\treturn seg[idx];\n\t\t}\n\t\tif(lazy[idx])\n\t\t{\n\t\t\tlazy_evaluate(idx);\n\t\t}\n\t\treturn max(query(beg,en,idx*2+1,lb,(lb+ub)/2),query(beg,en,idx*2+2,(lb+ub)/2+1,ub));\n\t}\n}seg_tree;\nint main()\n{\n\tint n;ll x;\n\tscanf(\"%d %lld\",&n,&x);\n\tseg_tree.init();\n\tseg_tree.update(0,maxs-1,0,0,maxs-1,x);\n\tpriority_queue<pair<ll,ll> >que;\n\tint ret=0;\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tll x,y;\n\t\tscanf(\"%lld %lld\",&x,&y);\n\t\tque.push(mp(y,i));\n\t\t\n\t\tfor(;;)\n\t\t{\n\t\t\tif(que.empty()) break;\n\t\t\tif(seg_tree.query(i+1,i+1,0,0,maxs-1)>x) break;\n\t\t\tpair<ll,ll>p=que.top(); que.pop();\n\t\t\tint v1=(x-seg_tree.query(p.second,i,0,0,maxs-1))/p.first;\n\t\t\tint v2=(1-seg_tree.query(i+1,i+1,0,0,maxs-1)+x+p.first-1)/p.first;\n\t\t\tif(v1>=v2)\n\t\t\t{\n\t\t\t\tret+=v1;\n\t\t\t\tseg_tree.update(p.second,maxs-1,0,0,maxs-1,v1*p.first);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tret+=v2;\n\t\t\t\tque.pop();\n\t\t\t\tseg_tree.update(p.second,maxs-1,0,0,maxs-1,v2*p.first);\n\t\t\t}\n\t\t}\n\t\tseg_tree.update(i+1,maxs-1,0,0,maxs-1,-x);\n\t}\n\tprintf(\"%d\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define ALL(A) A.begin(), A.end()\n#define INF ((int)1e9 + 9)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nstruct segtree{\n\tint SIZE;\n\tvector<int> maximum, lazy;\n\n\tsegtree(int n){\n\n\t\tSIZE = 1;\n\t\twhile(SIZE < n) SIZE *= 2;\n\t\t\n\t\tmaximum.clear();\n\t\tmaximum.resize(SIZE * 2, 0);\n\t\tlazy.clear();\n\t\tlazy.resize(SIZE * 2, 0);\n\t};\n\n\tvoid lazy_evaluate(int k){\n\t\tmaximum[k] += lazy[k];\n\n\t\tif (k < SIZE - 1){ // k isn't leaf of SegmentTree\n\t\t\tlazy[k * 2 + 1] += lazy[k];\n\t\t\tlazy[k * 2 + 2] += lazy[k];\n\t\t} // end if\n\t\tlazy[k] = 0;\n\t} // end function\n\n\tvoid update(int a, int b, int k, int l, int r, int x){\n\t\tif (r <= a || b <= l) return;\n\n\t\tif (a <= l && r <= b){\n\t\t\tlazy[k] += x;\n\t\t\tlazy_evaluate(k);\n\t\t}else{\n\t\t\tlazy_evaluate(k);\n\t\t\tupdate(a, b, k * 2 + 1, l, (l + r) / 2, x);\n\t\t\tupdate(a, b, k * 2 + 2, (l + r) / 2, r, x);\n\t\t\tmaximum[k] = max(maximum[k * 2 + 1], maximum[k * 2 + 2]);\n\t\t\treturn;\n\t\t} // end if\n\t} // end function \n\n\tint query(int a, int b, int k, int l, int r){\n\t\tlazy_evaluate(k);\n\t\tif (r <= a || b <= l) return 0;\n\t\tif (a <= l && r <= b) return maximum[k];\n\t\telse{\n\t\t\tint lch = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\t\tint rch = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\n\t\t\treturn max(lch, rch);\n\t\t} // end if\n\t} // end function\n};\n\nint main()\n{\n\tint N, H;\n\tint di[(int)1e5 + 5] = {0};\n\tint hi[(int)1e5 + 5] = {0};\n\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcin >> N >> H;\n\trep (i, N - 1){\n\t\tcin >> di[i] >> hi[i];\n\t} // end rep\n\n\tint currLife = H;\n\tint ans = 0;\n\n\tauto cmp = [](P left, P right){ return left.first != right.first ? left.first < right.first : left.second < right.second; };\n\tpriority_queue<P, vector<P>, decltype(cmp) > que(cmp);\t// P(plus, pos) \n\n\tsegtree seg(N);\n\n\tfor (int i = 0; i < N - 1; ++i){\n\t\tseg.update(i, i + 1, 0, 0, seg.SIZE, currLife); // update(a, b, k, l, r, x);\n\t\tcurrLife -= di[i];\n\t\tque.push(P(hi[i], i));\n\n\t\twhile(currLife <= 0){\n\t\t\tP heal = que.top(); que.pop();\n\t\t\tint segMax = seg.query(heal.second, i + 1, 0, 0, seg.SIZE);\n\n\t\t\tif (heal.first + segMax > H){\n\t\t\t\theal.first = H - segMax;\n\t\t\t\tque.push(P(heal.first, heal.second));\n\t\t\t\tcontinue;\n\t\t\t} // end if\n\t\t\n\t\t\tint cnt = min((-1 * currLife) / heal.first + 1, (H - segMax) / heal.first);\n\t\t\tans += cnt;\n\t\t\tcurrLife += cnt * heal.first;\t\t\t\n\n\t\t\tseg.update(heal.second, i + 1, 0, 0, seg.SIZE, cnt * heal.first);\n\t\t\tque.push(P(heal));\n\t\t} // end while\n\t} // end for\n\n\tcout << ans << endl;\n\t\t  \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <assert.h>\n#define N_MAX (100000)\n#define min(a,b) (((a)<(b))?(a):(b))\ntypedef struct {\n\tint pos,value;\n} Info;\n\nsigned main(){\n\tlong long damage_total[N_MAX]={};\n\tInfo deque[N_MAX];\n\tint head=0,tail=0;\n\tint N,H;\n\tlong long answer = 0;\n\n\tscanf(\"%d%d\",&N,&H);\t\n\tint currentHP = H;\n\tfor(int i = 0 ; i < N-1 ; i++){\n\t\tint d,h;\n\t\tscanf(\"%d%d\",&d,&h);\n\t\twhile( head != tail && deque[tail-1].value <= h ) tail--;\n\n\t\tdeque[tail++] = (Info){i,h};\n\t\twhile( head != tail ){\n\t\t\tlong long maximumRecover = H - (damage_total[i] - damage_total[deque[head].pos]);\n\t\t\tif( maximumRecover > 0 ) break;\n\t\t\thead++;\n\t\t}\n\n\t\tfor(int j = head ; j < tail && currentHP <= d ; j++){\n\t\t\t// ????????§???????????§????????????\n\t\t\tint maximumRecover = H - (damage_total[i] - damage_total[deque[j].pos]);\n\t\t\t// ??¨???????????§????????????????£???°???\n\t\t\tif( maximumRecover <= currentHP) continue;\n\n\t\t\t// j??????????????§?????????????????? needRecover ????¨????\n\t\t\tint needRecover = min( maximumRecover - currentHP , d - currentHP + 1);  \n\t\t\t// ???????????? needRecover ?????????????????????????????° useCount ????±????????????????????????????\n\t\t\tint useCount = (needRecover+deque[j].value-1) / deque[j].value - 1;\n\t\t\tanswer += useCount;\n\t\t\tcurrentHP += useCount*deque[j].value;\n\n\t\t\t// ???j?????????????????§????°???????????????????j????????£?????´?????¨???j+1????????£?????´?????????????????????j+1????????£????????????????????????j?????????????????????\n\t\t\t// ??¨) ???????????¶???????????\\??£?????????????????¨???????????? currentHP > d ???????????????\n\t\t\tif( j+1 ==  tail || maximumRecover > currentHP + deque[j+1].value ){\n\t\t\t\tcurrentHP = min(currentHP+deque[j].value,maximumRecover);\n\t\t\t\tanswer++;\n\t\t\t}\n\t\t}\n\t\tcurrentHP -= d;\n\t\tdamage_total[i+1] = damage_total[i] + d;\n\t}\n\tprintf(\"%lld\\n\",answer);\n\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint di[100000];\nint hi[100000];\n\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n\nint main(){\n  int n, h; scanf(\"%d%d\", &n, &h);\n  int i;\n  int pos = 0;\n  int hp  = h;\n  int cnt = 0;\n\n  for(i = 0; i < n - 1; i++)\n    scanf(\"%d%d\", di+i, hi+i);\n\n  while(1){\n    int mxv = -1;\n    int memohp  = 0;\n    int memopos = 0;\n\n    // printf(\"pos: %d, hp: %d\\n\", pos, hp);\n\n    while(1){\n      if(mxv <= MIN(h - hp, hi[pos])){\n\tmxv     = MIN(h - hp, hi[pos]);\n\tmemohp  = hp;\n\tmemopos = pos;\n      }\n\n      if((hp -= di[pos]) > 0){\n\t++pos;\n      }else{\n\tbreak;\n      }\n\n      if(pos == n - 1){\n\tprintf(\"%d\\n\", cnt);\n\treturn 0;\n      }\n    }\n\n    pos = memopos;\n    hp  = MIN(memohp + hi[pos], h);\n    cnt++;\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define MAX_HP 1000000000\n\nint down[100000], heal[100000];\nint dp[2][1000000], *next, *current;\n\nint main(void) {\n    int N, H, i, j, h, max_count, hp;\n    \n    scanf(\"%d%d\", &N, &H);\n    for (i = 0; i < N - 1; i++) {\n        scanf(\"%d%d\", &down[i], &heal[i]);\n    }\n\n    for (i = 0; i < 1000001; i++) {\n        dp[0][i] = 0;\n    }\n    dp[0][0] = H;\n    max_count = 0;\n    for (i = 0; i < N - 1; i++) {\n        current = dp[i&1];\n        next = dp[(i+1)&1];\n        for (j = 0; j <= max_count; j++) next[j] = 0;\n        for (j = 0; j <= max_count; j++) {\n            if (current[j] == 0) continue;\n            for (h = 0;; h++) {\n                hp = current[j] + h * heal[i];\n                if (hp > H) hp = H;\n                hp -= down[i];\n                if (hp <= 0) continue;\n                // printf(\"%d, %d: %d\\n\", i, j + h, hp);\n                if (j + h >= max_count) {\n                    max_count = j + h + 1;\n                    next[j + h] = hp;\n                }\n                else if (next[j + h] < hp) {\n                    next[j + h] = hp;\n                }\n                if (hp + down[i] >= H) break;\n            }\n        }\n    }\n    for (i = 1;\n         i <= max_count; i++) {\n        if (next[i] > 0) break;\n    }\n    printf(\"%d\\n\", i);\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define MAX_HEAL_COUNT 1000000000\n\nint down[100000], heal[100000];\nint dp[2][10000001], *next, *current;\n\nint main(void) {\n    int N, H, i, j, h, hp, min_count;\n\n    scanf(\"%d%d\", &N, &H);\n    for (i = 0; i < N - 1; i++) {\n        scanf(\"%d%d\", &down[i], &heal[i]);\n    }\n\n    for (i = 0; i <= H; i++) {\n        dp[0][i] = MAX_HEAL_COUNT;\n    }\n    dp[0][H] = 0;\n    for (i = 0; i < N - 1; i++) {\n        current = dp[i&1];\n        next = dp[(i+1)&1];\n        for (j = 1; j <= H; j++) next[j] = MAX_HEAL_COUNT;\n        for (j = 1; j <= H; j++) {\n            if (current[j] == MAX_HEAL_COUNT) continue;\n            for (h = 0;; h++) {\n                hp = j+ h * heal[i];\n                if (hp > H) hp = H;\n                hp -= down[i];\n                if (hp <= 0) continue;\n                if (current[j] + h < next[hp]) {\n                    next[hp] = current[j] + h;\n                }\n                if (hp + down[i] >= H) break;\n            }\n        }\n    }\n    for (i = 1, min_count = MAX_HEAL_COUNT;\n         i <= H; i++) {\n        if (next[i] < min_count) min_count = next[i];\n    }\n    printf(\"%d\\n\", min_count);\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <assert.h>\n#define N_MAX (100000)\n#define min(a,b) (((a)<(b))?(a):(b))\ntypedef struct {\n\tint pos,value;\n} Info;\n\nsigned main(){\n\tint damage_total[N_MAX]={};\n\tInfo deque[N_MAX];\n\tint head=0,tail=0;\n\tint N,H;\n\tlong long answer = 0;\n\n\tscanf(\"%d%d\",&N,&H);\t\n\tint currentHP = H;\n\tfor(int i = 0 ; i < N-1 ; i++){\n\t\tint d,h;\n\t\tscanf(\"%d%d\",&d,&h);\n\t\twhile( head != tail && deque[tail-1].value <= h ) tail--;\n\n\t\tdeque[tail++] = (Info){i,h};\n\t\twhile( head != tail ){\n\t\t\tint maximumRecover = H - (damage_total[i] - damage_total[deque[head].pos]);\n\t\t\tif( maximumRecover > 0 ) break;\n\t\t\thead++;\n\t\t}\n\n\t\tfor(int j = head ; j < tail && currentHP <= d ; j++){\n\t\t\t// ????????§???????????§????????????\n\t\t\tint maximumRecover = H - (damage_total[i] - damage_total[deque[j].pos]);\n\t\t\t\n\t\t\t// ??¨???????????§????????????????£???°???\n\t\t\tif( maximumRecover <= currentHP) continue;\n\n\t\t\t// j??????????????§?????????????????? needRecover ????¨????\n\t\t\tint needRecover = min( maximumRecover - currentHP , d - currentHP + 1);  \n\t\t\t// ???????????? needRecover ?????????????????????????????° useCount ????±????????????????????????????\n\t\t\tint useCount = (needRecover+deque[j].value-1) / deque[j].value - 1;\n\t\t\tanswer += useCount;\n\t\t\tcurrentHP += useCount*deque[j].value;\n\n\t\t\t// ???j?????????????????§????°???????????????????j????????£?????´?????¨???j+1????????£?????´?????????????????????j+1????????£????????????????????????j?????????????????????\n\t\t\t// ??¨) ???????????¶???????????\\??£?????????????????¨???????????? currentHP > d ???????????????\n\t\t\tif( j+1 ==  tail || maximumRecover > currentHP + deque[j+1].value ){\n\t\t\t\tcurrentHP = min(currentHP+deque[j].value,maximumRecover);\n\t\t\t\tanswer++;\n\t\t\t}\n\t\t}\n\t\tcurrentHP -= d;\n\t\tdamage_total[i+1] = damage_total[i] + d;\n\t}\n\tprintf(\"%lld\\n\",answer);\n\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0553: Dungeon\n// 2018.1.28 bal4u\n\n#include <stdio.h>\n\ntypedef struct { long long d; int h; } Q;\nQ q[1000002]; int top, end;\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint main()\n{\n    int N, H, i, d, h, ans;\n\tlong long s, t, sd, max;\n\n\tN = in(), H = in();\n\tans = 0, sd = 0, max = H, top = end = 0;\n\tfor (i = 1; i < N; i++) {\n\t\td = in(), h = in();\n\t\twhile (top != end && h > q[end-1].h) end--;\n\t\tq[end].d = sd, q[end++].h = h;\n\t\tsd += d;\n\n\t\twhile (sd >= max) {\n\t\t\ts = max;\n\t\t\twhile (top != end && s + q[top].h - q[top].d > H) {\n\t\t\t\tif (max < q[top].d + H) max = q[top].d + H;\n\t\t\t\ttop++;\n\t\t\t}\n\t\t\tif (top != end) {\n\t\t\t\th = q[top].h;\n\t\t\t\tif (max < s + h) max = s + h;\n\t\t\t\tt = (q[top].d + H - max)/h;\n\t\t\t\tif (t > (sd - max)/h) t = (sd - max)/h;\n\t\t\t\tif (t > 0) ans += (int)t, max += t*h;\n\t\t\t}\n\t\t\tans++;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint MIN(int a,int b){return a<b?a:b;}\nint main(){\n  int n,m,i,f,hp,a[100010],b[100010],c[100010],max=0,mi=0;\n  scanf(\"%d %d\",&n,&m);\n  for(i=0;i<n-1;i++)scanf(\"%d %d\",&a[i],&b[i]);\n  a[i]=c[b[i]=0]=m;\n  hp=m;//printf(\"a\\n\");\n  for(i=0;f-n;i++){\n    hp=c[f=mi]+max;\n    max=0;\n    while(hp>0){\n      c[f]=hp;\n      if(max<=MIN(b[f],m-hp))max=MIN(b[mi=f],m-hp);\n      hp-=a[f++];//printf(\"%d %d %d\\n\",c[f-1],max,mi);\n    }\n  }\n  printf(\"%d\\n\",i-1);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define max(a, b) ((a) > (b) ? (a) : (b))\n#define min(a, b) ((a) > (b) ? (b) : (a))\n#define MAX_N (100000)\n\ntypedef long long ll;\ntypedef struct {\n    ll val;\n    int pos;\n} SEG;\n\nSEG seg[1 << 18];\nll data[1 << 18], datb[1 << 18];\nSEG dummy;\nint seg_size;\n\nvoid init(int N)\n{\n    seg_size = 1;\n    while (seg_size < N){\n        seg_size *= 2;\n    }\n    \n    memset(seg, -1, sizeof(seg));\n}\n\nvoid update(int k, int x)\n{\n    k += seg_size - 1;\n    seg[k].val = x;\n    seg[k].pos = k - (seg_size - 1);\n    \n    while (k != 0){\n        k = (k - 1) / 2;\n        if (seg[k * 2 + 2].val > seg[k * 2 + 1].val){\n            seg[k] = seg[k * 2 + 2];\n        }\n        else if (seg[k * 2 + 1].val > seg[k * 2 + 2].val){\n            seg[k] = seg[k * 2 + 1];\n        }\n        else {\n            seg[k] = (seg[k * 2 + 1].pos < seg[k * 2 + 2].pos) ? seg[k * 2 + 2] : seg[k * 2 + 1];\n        }\n    }\n}\n\nSEG query(int a, int b, int k, int l, int r)\n{\n    SEG vl, vr;\n    \n    if (r <= a || b <= l){\n        return (dummy);\n    }\n    \n    if (a <= l && r <= b){\n        return (seg[k]);\n    }\n    else {\n        vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n        vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n    }\n    if (vl.val > vr.val || (vl.val == vr.val && vl.pos > vr.pos)){\n        return (vl);\n    }\n    else {\n        return (vr);\n    }\n}\n\n\nvoid add(int a, int b, ll x, int k, int l, int r)\n{\n    if (a <= l && r <= b){ //comletely inclusive.\n        data[k] += x; //add to all segmets corresponds to [l, r).\n    }\n    else if (l < b && a < r){ //some of the segments are inclusive.\n        datb[k] += (min(b, r) - max(a, l)) * x;  //add the x to the segments that belongs to [max(a, l), min(r, b)).\n        add(a, b, x, k * 2 + 1, l, (l + r) / 2); //go to the left vertex.\n        add(a, b, x, k * 2 + 2, (l + r) / 2, r); //go to the right vertex.\n    }\n}\n\nll sum(int a, int b, int k, int l, int r)\n{\n    if (b <= l || r <= a){ //looking segment[l, r) cross with the segment [a, b).\n        return (0);\n    }\n    else if (a <= l && r <= b){ //completely inclusive.\n        return (data[k] * (r - l) + datb[k]);\n    }\n    else { //some of the segments are inclusive.\n        ll res;\n        res = (min(b, r) - max(a, l)) * data[k];\n        res += sum(a, b, k * 2 + 1, l, (l + r) / 2);\n        res += sum(a, b, k * 2 + 2, (l + r) / 2, r);\n        return (res);\n    }\n}\n\nint main(void)\n{\n    int i, j;\n    int N, H;\n    int dmg, life;\n    int tail;\n    ll ans;\n    ll sumLife;\n    \n    scanf(\"%d%d\", &N, &H);\n    \n    init(N);\n    \n    sumLife = H;\n    for (i = 0; i < N - 1; i++){\n        scanf(\"%d%d\", &dmg, &life);\n        update(i, min(life, H - sumLife));\n        \n        add(i, i + 1, sumLife, 0, 0, seg_size);\n        sumLife -= dmg;\n    }\n    add(i, i + 1, sumLife, 0, 0, seg_size);\n    update(i, 0);\n    \n    dummy.val = -100000, dummy.pos = -1;\n    \n    life = H;\n    ans = 0;\n    tail = 0;\n    \n    for (i = 0; i < N; i++){\n        while (sum(i, i + 1, 0, 0, seg_size) <= 0){\n            SEG temp;\n            temp = query(tail, i, 0, 0, seg_size);\n            //printf(\"%dF -> %dF\\n\", i + 1, temp.pos + 1);\n            ans++;\n            tail = temp.pos;\n            add(temp.pos, N, temp.val, 0, 0, seg_size);\n            for (j = temp.pos; j < N; j++){\n                ll t = sum(j, j + 1, 0, 0, seg_size);\n                if (H - t > seg[j + seg_size - 1].val){\n                    continue;\n                }\n                update(j, min(seg[j + seg_size - 1].val, H - t));\n            }\n        }\n    }\n    \n    printf(\"%d\\n\", ans);\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <assert.h>\n#define N_MAX (100000)\n#define min(a,b) (((a)<(b))?(a):(b))\ntypedef struct {\n\tint pos,value;\n} Info;\n\nsigned main(){\n\tlong long damage_total[N_MAX]={};\n\tInfo deque[N_MAX];\n\tint head=0,tail=0;\n\tint N,H;\n\tlong long answer = 0;\n\n\tscanf(\"%d%d\",&N,&H);\t\n\tint currentHP = H;\n\tfor(int i = 0 ; i < N-1 ; i++){\n\t\tint d,h;\n\t\tscanf(\"%d%d\",&d,&h);\n\t\twhile( head != tail && deque[tail-1].value <= h ) tail--;\n\n\t\tdeque[tail++] = (Info){i,h};\n\t\t/*while( head != tail ){\n\t\t\tint maximumRecover = H - (damage_total[i] - damage_total[deque[head].pos]);\n\t\t\tif( maximumRecover > 0 ) break;\n\t\t\thead++;\n\t\t}*/\n\n\t\tfor(int j = head ; j < tail && currentHP <= d ; j++){\n\t\t\t// ????????§???????????§????????????\n\t\t\tlong long maximumRecover = H - (damage_total[i] - damage_total[deque[j].pos]);\n\t\t\t// ??¨???????????§????????????????£???°???\n\t\t\tif( maximumRecover <= currentHP) continue;\n\n\t\t\t// j??????????????§?????????????????? needRecover ????¨????\n\t\t\tint needRecover = min( maximumRecover - currentHP , d - currentHP + 1);  \n\t\t\t// ???????????? needRecover ?????????????????????????????° useCount ????±????????????????????????????\n\t\t\tint useCount = (needRecover+deque[j].value-1) / deque[j].value - 1;\n\t\t\tanswer += useCount;\n\t\t\tcurrentHP += useCount*deque[j].value;\n\n\t\t\t// ???j?????????????????§????°???????????????????j????????£?????´?????¨???j+1????????£?????´?????????????????????j+1????????£????????????????????????j?????????????????????\n\t\t\t// ??¨) ???????????¶???????????\\??£?????????????????¨???????????? currentHP > d ???????????????\n\t\t\tif( j+1 ==  tail || maximumRecover > currentHP + deque[j+1].value ){\n\t\t\t\tcurrentHP = min(currentHP+deque[j].value,maximumRecover);\n\t\t\t\tanswer++;\n\t\t\t}\n\t\t}\n\t\tcurrentHP -= d;\n\t\tdamage_total[i+1] = damage_total[i] + d;\n\t}\n\tprintf(\"%lld\\n\",answer);\n\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define max(a, b) ((a) > (b) ? (a) : (b))\n#define min(a, b) ((a) > (b) ? (b) : (a))\n#define MAX_N (100000)\n\ntypedef __int64 ll;\ntypedef struct {\n    ll val;\n    int pos;\n} SEG;\n\nSEG seg[1 << 18];\nll data[1 << 18], datb[1 << 18];\nSEG dummy;\nint seg_size;\n\nvoid init(int N)\n{\n    seg_size = 1;\n    while (seg_size < N){\n        seg_size *= 2;\n    }\n    \n    memset(seg, -1, sizeof(seg));\n}\n\nvoid update(int k, int x)\n{\n    k += seg_size - 1;\n    seg[k].val = x;\n    seg[k].pos = k - (seg_size - 1);\n    \n    while (k != 0){\n        k = (k - 1) / 2;\n        if (seg[k * 2 + 2].val > seg[k * 2 + 1].val){\n            seg[k] = seg[k * 2 + 2];\n        }\n        else if (seg[k * 2 + 1].val > seg[k * 2 + 2].val){\n            seg[k] = seg[k * 2 + 1];\n        }\n        else {\n            seg[k] = (seg[k * 2 + 1].pos < seg[k * 2 + 2].pos) ? seg[k * 2 + 2] : seg[k * 2 + 1];\n        }\n    }\n}\n\nSEG query(int a, int b, int k, int l, int r)\n{\n    SEG vl, vr;\n    \n    if (r <= a || b <= l){\n        return (dummy);\n    }\n    \n    if (a <= l && r <= b){\n        return (seg[k]);\n    }\n    else {\n        vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n        vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n    }\n    if (vl.val > vr.val || (vl.val == vr.val && vl.pos > vr.pos)){\n        return (vl);\n    }\n    else {\n        return (vr);\n    }\n}\n\n\nvoid add(int a, int b, ll x, int k, int l, int r)\n{\n    if (a <= l && r <= b){ //comletely inclusive.\n        data[k] += x; //add to all segmets corresponds to [l, r).\n    }\n    else if (l < b && a < r){ //some of the segments are inclusive.\n        datb[k] += (min(b, r) - max(a, l)) * x;  //add the x to the segments that belongs to [max(a, l), min(r, b)).\n        add(a, b, x, k * 2 + 1, l, (l + r) / 2); //go to the left vertex.\n        add(a, b, x, k * 2 + 2, (l + r) / 2, r); //go to the right vertex.\n    }\n}\n\nll sum(int a, int b, int k, int l, int r)\n{\n    if (b <= l || r <= a){ //looking segment[l, r) cross with the segment [a, b).\n        return (0);\n    }\n    else if (a <= l && r <= b){ //completely inclusive.\n        return (data[k] * (r - l) + datb[k]);\n    }\n    else { //some of the segments are inclusive.\n        ll res;\n        res = (min(b, r) - max(a, l)) * data[k];\n        res += sum(a, b, k * 2 + 1, l, (l + r) / 2);\n        res += sum(a, b, k * 2 + 2, (l + r) / 2, r);\n        return (res);\n    }\n}\n\nint main(void)\n{\n    int i, j;\n    int N, H;\n    int dmg, life;\n    int tail;\n    ll ans;\n    ll sumLife;\n    \n    scanf(\"%d%d\", &N, &H);\n    \n    init(N);\n    \n    sumLife = H;\n    for (i = 0; i < N - 1; i++){\n        scanf(\"%d%d\", &dmg, &life);\n        update(i, min(life, H - sumLife));\n        \n        add(i, i + 1, sumLife, 0, 0, seg_size);\n        sumLife -= dmg;\n    }\n    add(i, i + 1, sumLife, 0, 0, seg_size);\n    update(i, 0);\n    \n    dummy.val = -100000, dummy.pos = -1;\n    \n    life = H;\n    ans = 0;\n    tail = 0;\n    \n    for (i = 0; i < N; i++){\n        while (sum(i, i + 1, 0, 0, seg_size) <= 0){\n            SEG temp;\n            temp = query(tail, i, 0, 0, seg_size);\n            //printf(\"%dF -> %dF\\n\", i + 1, temp.pos + 1);\n            ans++;\n            tail = temp.pos;\n            add(temp.pos, N, temp.val, 0, 0, seg_size);\n            for (j = temp.pos; j < N; j++){\n                ll t = sum(j, j + 1, 0, 0, seg_size);\n                if (H - t > seg[j + seg_size - 1].val){\n                    continue;\n                }\n                update(j, min(seg[j + seg_size - 1].val, H - t));\n            }\n        }\n    }\n    \n    printf(\"%d\\n\", ans);\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <cstdio>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef struct {\n    int plus, pos;\n} Dungeon;\n\nbool operator < (const Dungeon &a, const Dungeon &b)\n{\n    if (a.plus != b.plus){\n        return (a.plus < b.plus);\n    }\n    else {\n        return (a.pos < b.pos);\n    }\n}\nint data[1 << 18], datb[1 << 18];\n\nvoid add(int a, int b, int x, int k, int l, int r)\n{\n    if (a <= l && r <= b){ //comletely inclusive.\n        data[k] += x; //add to all segmets corresponds to [l, r).\n    }\n    else if (l < b && a < r){ //some of the segments are inclusive.\n        datb[k] += (min(b, r) - max(a, l)) * x;  //add the x to the segments that belongs to [max(a, l), min(r, b)).\n        add(a, b, x, k * 2 + 1, l, (l + r) / 2); //go to the left vertex.\n        add(a, b, x, k * 2 + 2, (l + r) / 2, r); //go to the right vertex.\n    }\n}\n\n//*\nint sum(int a, int b, int k, int l, int r)\n{\n    if (b <= l || r <= a){ //looking segment[l, r) cross with the segment [a, b).\n        return (0);\n    }\n    else if (a <= l && r <= b){ //completely inclusive.\n        return (data[k] * (r - l) + datb[k]);\n    }\n    else { //some of the segments are inclusive.\n        ll res;\n        res = (min(b, r) - max(a, l)) * data[k];\n        res += sum(a, b, k * 2 + 1, l, (l + r) / 2);\n        res += sum(a, b, k * 2 + 2, (l + r) / 2, r);\n        return (res);\n    }\n}\n//*/\n\nint main(void)\n{\n    int N, H;\n    int di[100000], hi[100000];\n    int curLife;\n    \n    scanf(\"%d%d\", &N, &H);\n    \n    for (int i = 0; i < N - 1; i++){\n        scanf(\"%d%d\", &di[i], &hi[i]);\n    }\n    \n    curLife = H;\n    \n    ll ans = 0;\n    priority_queue<Dungeon> que;\n    for (int i = 0; i < N - 1; i++){\n        add(i, i + 1, curLife, 0, 0, 1 << 17);\n        Dungeon in;\n        curLife -= di[i];\n        \n        in.plus = hi[i];\n        in.pos = i;\n        \n        que.push(in);\n        while (curLife <= 0){\n            Dungeon heal = que.top();\n            que.pop();\n            \n            /* O(logN)\n            int segMax = getMax(heal.pos, i + 1, 0, 0, 1 << 17);\n            //*/\n            \n            //* O(NlogN)\n            int segMax = 0;\n            for (int j = heal.pos; j <= i; j++){\n                segMax = max(segMax, sum(j, j + 1, 0, 0, 1 << 17));\n            }\n            //*/\n            \n            if (heal.plus + segMax > H){\n                heal.plus = H - segMax;\n                que.push(heal);\n                continue;\n            }\n            \n            int howMany = min((-1 * curLife) / heal.plus + 1, (H - segMax) / heal.plus);\n            ans += howMany;\n            curLife += howMany * heal.plus;\n            \n            add(heal.pos, i + 1, howMany * heal.plus, 0, 0, 1 << 17);\n            que.push(heal);\n        }\n    }\n    \n    printf(\"%lld\\n\", ans);\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint di[100000];\nint hi[100000];\n\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n\nint main(){\n  int n, h; scanf(\"%d%d\", &n, &h);\n  int i;\n  int pos = 0;\n  int hp  = h;\n  int cnt = 0;\n\n  for(i = 0; i < n - 1; i++)\n    scanf(\"%d%d\", di+i, hi+i);\n\n  while(1){\n    int mxv = -1;\n    int memohp  = 0;\n    int memopos = 0;\n\n    // printf(\"pos: %d, hp: %d\\n\", pos, hp);\n\n    while(1){\n      if(mxv <= MIN(h - hp, hi[pos])){\n        mxv     = MIN(h - hp, hi[pos]);\n        memohp  = hp;\n        memopos = pos;\n      }\n\n      if((hp -= di[pos]) > 0){\n        ++pos;\n      }else{\n        break;\n      }\n\n      if(pos == n - 1){\n        printf(\"%d\\n\", cnt);\n        return 0;\n      }\n    }\n\n    pos = memopos;\n    hp  = MIN(memohp + hi[pos], h);\n    cnt++;\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint max(int data[],int n){\n  int i,mm=0;\n  for(i=0;i<n;i++){\n    if(data[mm]<data[i]) mm=i;\n  }\n  return mm;\n}\n\nmain(){\n int a[10],b[10],j,k,x,y,amax[3],bmax[3],aa=0,bb=0;\n \n for(j=0;j<10;j++){\n    scanf(\"%d\",&a[j]);\n  }\n for(k=0;k<10;k++){\n    scanf(\"%d\",&b[k]);\n  }\n\n for(x=0;x<3;x++){\n    aa=max(a,10);\n    amax[x]=a[aa];\n    a[aa]=0;\n  }\n for(y=0;y<3;y++){\n    bb=max(b,10);\n    bmax[y]=b[bb];\n    b[bb]=0;\n  }\n\n printf(\"%d %d\\n\",amax[0]+amax[1]+amax[2],bmax[0]+bmax[1]+bmax[2]);\n\nreturn 0; \n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static class SegTree{\n\t\tint n;\n\t\tlong[] life;\n\t\tlong[] heal;\n\n\t\tpublic SegTree(int n_) {\n\t\t\tint n = 1;\n\t\t\twhile(n < n_){\n\t\t\t\tn *= 2;\n\t\t\t}\n\t\t\t\n\t\t\tthis.n = n;\n\t\t\tlife = new long[this.n * 2 - 1];\n\t\t\theal = new long[this.n];\n\t\t\tfor(int i = 0; i < this.n * 2 - 1 ; i++){\n\t\t\t\tlife[i] = 0;\n\t\t\t}\n\t\t\tfor(int i = 0; i < this.n; i++){\n\t\t\t\theal[i] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic void update(int k, long a){\n\t\t\tk += n - 1;\n\t\t\tlife[k] = a;\n\t\t\t\n\t\t\twhile(k > 0){\n\t\t\t\tk = (k - 1) / 2;\n\t\t\t\t//dat[k] = Math.max(dat[k * 2 + 1], dat[k * 2 + 2]);\n\t\t\t\tlife[k] = life[k * 2 + 1] + life[k * 2 + 2];\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic void update_add(int k, long a){\n\t\t\tk += n - 1;\n\t\t\tlife[k] += a;\n\t\t\t\n\t\t\twhile(k > 0){\n\t\t\t\tk = (k - 1) / 2;\n\t\t\t\t//dat[k] = Math.max(dat[k * 2 + 1], dat[k * 2 + 2]);\n\t\t\t\tlife[k] = life[k * 2 + 1] + life[k * 2 + 2];\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic void heal_update(int k, long a){\n\t\t\theal[k] = a;\n\t\t}\n\t\t\n\t\tpublic long query(int a, int b, int k, int l, int r){\n\t\t\tif(r <= a || b <= l){\n\t\t\t\treturn 0;\n\t\t\t}else if(a <= l && r <= b){\n\t\t\t\treturn life[k];\n\t\t\t}else {\n\t\t\t\treturn query(a, b, k * 2 + 1, l, (l + r) / 2) + query(a, b, k * 2 + 2 , (l + r) / 2, r);\n\t\t\t\t//return Math.max(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2 , (l + r) / 2, r));\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic long heal(int limit_floor, long H, long damage){\n\t\t\tint max_floor = -1;\n\t\t\tlong max_single = Long.MIN_VALUE;\n\t\t\tlong heal_count = 1;\n\t\t\tlong heal_val = -1;\n\t\t\t\n\t\t\tfor(int floor = limit_floor - 1; floor > 0; floor--){\n\t\t\t\tfinal long cur_hp = this.query(0, floor + 1, 0, 0, this.n);\n\t\t\t\tfinal long max_diff = H - cur_hp;\n\t\t\t\t\n\t\t\t\tfinal long single = Math.min(H - cur_hp, heal[floor]);\n\t\t\t\t\n\t\t\t\tif(single > max_single){\n\t\t\t\t\tmax_single = single;\n\t\t\t\t\theal_val = single;\n\t\t\t\t\tmax_floor = floor;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t/*\n\t\t\t\t//System.out.println(floor);\n\t\t\t\tlong hp_use = (H - cur_hp) / heal[floor];\n\t\t\t\tif(H - cur_hp != 0 && hp_use == 0){\n\t\t\t\t\thp_use++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tlong damage_use = damage / heal[floor];\n\t\t\t\tif(damage % heal[floor] != 0){\n\t\t\t\t\tdamage_use++;\n\t\t\t\t}\n\t\t\t\t//System.out.println(H + \" \" + cur_hp + \" \" + heal[floor] + \" \" + hp_use + \" \" + damage_use);\n\t\t\t\t\n\t\t\t\tfinal long min_use = Math.min(hp_use, damage_use);\n\t\t\t\tfinal long healing = Math.min(max_diff, min_use * heal[floor]);\n\t\t\t\t\n\t\t\t\tif(min_use <= 0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(single >= max_single){\n\t\t\t\t\tif(single > max_single || heal_count > min_use){\n\t\t\t\t\t\theal_count = min_use;\n\t\t\t\t\t\theal_val = healing;\n\t\t\t\t\t\tmax_single = single;\n\t\t\t\t\t\tmax_floor = floor;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tthis.update_add(max_floor, heal_val);\n\t\t\t\n\t\t\treturn heal_count;\n\t\t}\n\t\t\n\t\tpublic int size(){\n\t\t\treturn n;\n\t\t}\n\t\t\n\t\tpublic String toString(){\n\t\t\treturn Arrays.toString(life);\n\t\t}\n\t\t\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tfinal int N  = sc.nextInt();\n\t\tfinal long H = sc.nextLong();\n\t\t\n\t\tSegTree seg = new SegTree(N);\n\t\tseg.update(0, H);\n\t\t\n\t\tfor(int i = 1; i < N; i++){\n\t\t\tfinal long d = sc.nextLong();\n\t\t\tfinal long h = sc.nextLong();\n\t\t\t\n\t\t\tseg.update(i, -d);\n\t\t\tseg.heal_update(i, h);\n\t\t}\n\t\t\n\t\t//System.out.println(Arrays.toString(seg.life));\n\t\t\n\t\tlong count = 0;\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\twhile(true){\n\t\t\t\tfinal long damage = seg.query(0, i + 1, 0, 0, seg.size());\n\t\t\t\tif(damage >= 0){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t//System.out.println(i + \" \" + seg.query(0, i + 1, 0, 0, seg.size()));\n\t\t\t\t//System.out.println(seg);\n\t\t\t\tcount += seg.heal(i, H, -damage + 1);\n\t\t\t\t//System.out.println(count + \" \" + seg);\n\t\t\t\t//System.out.println(i + \" \" + seg.query(0, i + 1, 0, 0, seg.size()));\n\t\t\t\t//System.out.println(\"------------------------------------------\");\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(count);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static class SegTree{\n\t\tint n;\n\t\tlong[] life;\n\t\tlong[] heal;\n\n\t\tpublic SegTree(int n_) {\n\t\t\tint n = 1;\n\t\t\twhile(n < n_){\n\t\t\t\tn *= 2;\n\t\t\t}\n\t\t\t\n\t\t\tthis.n = n;\n\t\t\tlife = new long[this.n * 2 - 1];\n\t\t\theal = new long[this.n];\n\t\t\tfor(int i = 0; i < this.n * 2 - 1 ; i++){\n\t\t\t\tlife[i] = 0;\n\t\t\t}\n\t\t\tfor(int i = 0; i < this.n; i++){\n\t\t\t\theal[i] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic void update(int k, long a){\n\t\t\tk += n - 1;\n\t\t\tlife[k] = a;\n\t\t\t\n\t\t\twhile(k > 0){\n\t\t\t\tk = (k - 1) / 2;\n\t\t\t\t//dat[k] = Math.max(dat[k * 2 + 1], dat[k * 2 + 2]);\n\t\t\t\tlife[k] = life[k * 2 + 1] + life[k * 2 + 2];\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic void update_add(int k, long a){\n\t\t\tk += n - 1;\n\t\t\tlife[k] += a;\n\t\t\t\n\t\t\twhile(k > 0){\n\t\t\t\tk = (k - 1) / 2;\n\t\t\t\t//dat[k] = Math.max(dat[k * 2 + 1], dat[k * 2 + 2]);\n\t\t\t\tlife[k] = life[k * 2 + 1] + life[k * 2 + 2];\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic void heal_update(int k, long a){\n\t\t\theal[k] = a;\n\t\t}\n\t\t\n\t\tpublic long query(int a, int b, int k, int l, int r){\n\t\t\tif(r <= a || b <= l){\n\t\t\t\treturn 0;\n\t\t\t}else if(a <= l && r <= b){\n\t\t\t\treturn life[k];\n\t\t\t}else {\n\t\t\t\treturn query(a, b, k * 2 + 1, l, (l + r) / 2) + query(a, b, k * 2 + 2 , (l + r) / 2, r);\n\t\t\t\t//return Math.max(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2 , (l + r) / 2, r));\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic long heal(int limit_floor, long H, long damage){\n\t\t\tint max_floor = -1;\n\t\t\tlong max_single = Long.MIN_VALUE;\n\t\t\tlong heal_count = Long.MAX_VALUE;\n\t\t\tlong heal_val = -1;\n\t\t\t\n\t\t\tfor(int floor = limit_floor - 1; floor > 0; floor--){\n\t\t\t\tfinal long cur_hp = this.query(0, floor + 1, 0, 0, this.n);\n\t\t\t\tfinal long max_diff = H - cur_hp;\n\t\t\t\t\n\t\t\t\tfinal long single = Math.min(H - cur_hp, heal[floor]);\n\t\t\t\t\n\t\t\t\t//System.out.println(floor);\n\t\t\t\tlong hp_use = (H - cur_hp) / heal[floor];\n\t\t\t\tif(H - cur_hp != 0 && hp_use == 0){\n\t\t\t\t\thp_use++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tlong damage_use = damage / heal[floor];\n\t\t\t\tif(damage % heal[floor] != 0){\n\t\t\t\t\tdamage_use++;\n\t\t\t\t}\n\t\t\t\t//System.out.println(H + \" \" + cur_hp + \" \" + heal[floor] + \" \" + hp_use + \" \" + damage_use);\n\t\t\t\t\n\t\t\t\tfinal long min_use = Math.min(hp_use, damage_use);\n\t\t\t\tfinal long healing = Math.min(max_diff, min_use * heal[floor]);\n\t\t\t\t\n\t\t\t\tif(min_use <= 0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(single >= max_single){\n\t\t\t\t\tif(single > max_single || heal_count > min_use){\n\t\t\t\t\t\theal_count = min_use;\n\t\t\t\t\t\theal_val = healing;\n\t\t\t\t\t\tmax_single = single;\n\t\t\t\t\t\tmax_floor = floor;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tthis.update_add(max_floor, heal_val);\n\t\t\t\n\t\t\treturn heal_count;\n\t\t}\n\t\t\n\t\tpublic int size(){\n\t\t\treturn n;\n\t\t}\n\t\t\n\t\tpublic String toString(){\n\t\t\treturn Arrays.toString(life);\n\t\t}\n\t\t\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tfinal int N  = sc.nextInt();\n\t\tfinal long H = sc.nextLong();\n\t\t\n\t\tSegTree seg = new SegTree(N);\n\t\tseg.update(0, H);\n\t\t\n\t\tfor(int i = 1; i < N; i++){\n\t\t\tfinal long d = sc.nextLong();\n\t\t\tfinal long h = sc.nextLong();\n\t\t\t\n\t\t\tseg.update(i, -d);\n\t\t\tseg.heal_update(i, h);\n\t\t}\n\t\t\n\t\t//System.out.println(Arrays.toString(seg.life));\n\t\t\n\t\tlong count = 0;\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\twhile(true){\n\t\t\t\tfinal long damage = seg.query(0, i + 1, 0, 0, seg.size());\n\t\t\t\tif(damage >= 0){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t//System.out.println(i + \" \" + seg.query(0, i + 1, 0, 0, seg.size()));\n\t\t\t\t//System.out.println(seg);\n\t\t\t\tcount += seg.heal(i, H, -damage + 1);\n\t\t\t\t//System.out.println(count + \" \" + seg);\n\t\t\t\t//System.out.println(i + \" \" + seg.query(0, i + 1, 0, 0, seg.size()));\n\t\t\t\t//System.out.println(\"------------------------------------------\");\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(count);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tMyInput in = new MyInput(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskX solver = new TaskX();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic int INF = 1 << 30;\n\tstatic long LINF = 1L << 55;\n\tstatic int MOD = 1000000007;\n\tstatic int[] mh4 = { 0, -1, 1, 0 };\n\tstatic int[] mw4 = { -1, 0, 0, 1 };\n\tstatic int[] mh8 = { -1, -1, -1, 0, 0, 1, 1, 1 };\n\tstatic int[] mw8 = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\n\tstatic class TaskX {\n\n\t\tpublic void solve(int testNumber, MyInput in, PrintWriter out) {\n\n\t\t\tint n = in.nextInt();\n\t\t\tlong H = in.nextLong();\n\t\t\tPriorityQueue<P> pq = new PriorityQueue<>();\n\t\t\tLazySegTree seg = new LazySegTree(n);\n\n\t\t\tlong cur = H, ans = 0;\n\t\t\tfor (int i = 0; i < n-1; i++) {\n\t\t\t\tlong d = in.nextLong(), h = in.nextLong();\n\t\t\t\tpq.add(new P(h, i));\n\n\t\t\t\tseg.add(cur, i, i+1, 0, 0, seg.size());\n\n\t\t\t\tcur -= d;\n\n\t\t\t\twhile (cur <= 0) {\n\t\t\t\t\tP p = pq.remove();\n\t\t\t\t\tlong max = seg.max(p.idx, i+1, 0, 0, seg.size());\n\n\t\t\t\t\tif (max + p.h > H) {\n\t\t\t\t\t\tpq.add(new P(H - max, p.idx));\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tlong count = Math.min(-cur / p.h + 1, (H - max) / p.h);\n\t\t\t\t\tans += count;\n\t\t\t\t\tcur += count * p.h;\n\n\t\t\t\t\tseg.add(count * p.h, p.idx, i+1, 0, 0, seg.size());\n\t\t\t\t\tpq.add(p);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tout.println(ans);\n\n\t\t}\n\n\t\tclass P implements Comparable<P> {\n\t\t\tlong h;\n\t\t\tint idx;\n\n\t\t\tpublic P(long h, int idx) {\n\t\t\t\tsuper();\n\t\t\t\tthis.h = h;\n\t\t\t\tthis.idx = idx;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic int compareTo(P o) {\n\t\t\t\treturn -Long.compare(this.h, o.h);\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic String toString() {\n\t\t\t\treturn \"P [h=\" + h + \", idx=\" + idx + \"]\";\n\t\t\t}\n\t\t}\n\n\t\tclass LazySegTree {\n\t\t\tint n;\n\t\t\tlong[] dat;\n\t\t\tlong[] lazy;\n\n\t\t\tpublic LazySegTree(int n_) {\n\t\t\t\tint n = 1;\n\t\t\t\twhile (n < n_) {\n\t\t\t\t\tn *= 2;\n\t\t\t\t}\n\n\t\t\t\tthis.n = n;\n\t\t\t\tdat = new long[this.n * 2 - 1];\n\t\t\t\tlazy = new long[this.n * 2 - 1];\n\t\t\t\tfor (int i = 0; i < this.n * 2 - 1; i++) {\n\t\t\t\t\tdat[i] = 0;\n\t\t\t\t\tlazy[i] = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpublic void update_node(int k) {\n\t\t\t\tdat[k] = dat[2 * k + 1] + dat[2 * k + 2];\n\t\t\t}\n\n\t\t\tlong max(int a, int b, int k, int l, int r) {\n\t\t\t\tif (b <= l || r <= a) {\n\t\t\t\t\treturn 0;\n\t\t\t\t} else if (a <= l && r <= b) {\n\t\t\t\t\treturn dat[k] + lazy[k];\n\t\t\t\t}\n\n\t\t\t\tlong lch = max(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\t\t\tlong rch = max(a, b, k * 2 + 2, (l + r) / 2, r);\n\n\t\t\t\treturn (Math.max(lch, rch) + lazy[k]);\n\t\t\t}\n\n\t\t\tvoid add(long x, int a, int b, int k, int l, int r) {\n\t\t\t\tif (b <= l || r <= a)\n\t\t\t\t\treturn;\n\n\t\t\t\tif (a <= l && r <= b) {\n\t\t\t\t\tlazy[k] += x;\n\t\t\t\t\twhile (k > 0) {\n\t\t\t\t\t\tk = (k - 1) / 2;\n\t\t\t\t\t\tdat[k] = Math.max(dat[k * 2 + 1] + lazy[k * 2 + 1],\n\t\t\t\t\t\t\t\tdat[k * 2 + 2] + lazy[k * 2 + 2]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tadd(x, a, b, k * 2 + 1, l, (l + r) / 2);\n\t\t\t\t\tadd(x, a, b, k * 2 + 2, (l + r) / 2, r);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpublic int size() {\n\t\t\t\treturn this.n;\n\t\t\t}\n\n\t\t\tpublic String toString() {\n\t\t\t\treturn Arrays.toString(dat) + \"\\n\" + Arrays.toString(lazy);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tstatic class MyInput {\n\t\tprivate final BufferedReader in;\n\t\tprivate static int pos;\n\t\tprivate static int readLen;\n\t\tprivate static final char[] buffer = new char[1024 * 8];\n\t\tprivate static char[] str = new char[500 * 8 * 2];\n\t\tprivate static boolean[] isDigit = new boolean[256];\n\t\tprivate static boolean[] isSpace = new boolean[256];\n\t\tprivate static boolean[] isLineSep = new boolean[256];\n\n\t\tstatic {\n\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\tisDigit['0' + i] = true;\n\t\t\t}\n\t\t\tisDigit['-'] = true;\n\t\t\tisSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n\t\t\tisLineSep['\\r'] = isLineSep['\\n'] = true;\n\t\t}\n\n\t\tpublic MyInput(InputStream is) {\n\t\t\tin = new BufferedReader(new InputStreamReader(is));\n\t\t}\n\n\t\tpublic int read() {\n\t\t\tif (pos >= readLen) {\n\t\t\t\tpos = 0;\n\t\t\t\ttry {\n\t\t\t\t\treadLen = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException();\n\t\t\t\t}\n\t\t\t\tif (readLen <= 0) {\n\t\t\t\t\tthrow new MyInput.EndOfFileRuntimeException();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn buffer[pos++];\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tint len = 0;\n\t\t\tstr[len++] = nextChar();\n\t\t\tlen = reads(len, isSpace);\n\t\t\tint i = 0;\n\t\t\tint ret = 0;\n\t\t\tif (str[0] == '-') {\n\t\t\t\ti = 1;\n\t\t\t}\n\t\t\tfor (; i < len; i++)\n\t\t\t\tret = ret * 10 + str[i] - '0';\n\t\t\tif (str[0] == '-') {\n\t\t\t\tret = -ret;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tint len = 0;\n\t\t\tstr[len++] = nextChar();\n\t\t\tlen = reads(len, isSpace);\n\t\t\tint i = 0;\n\t\t\tlong ret = 0;\n\t\t\tif (str[0] == '-') {\n\t\t\t\ti = 1;\n\t\t\t}\n\t\t\tfor (; i < len; i++)\n\t\t\t\tret = ret * 10 + str[i] - '0';\n\t\t\tif (str[0] == '-') {\n\t\t\t\tret = -ret;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic char nextChar() {\n\t\t\twhile (true) {\n\t\t\t\tfinal int c = read();\n\t\t\t\tif (!isSpace[c]) {\n\t\t\t\t\treturn (char) c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic String nextString() {\n\t\t\treturn new String(nextChars());\n\t\t}\n\n\t\tpublic char[] nextChars() {\n\t\t\tint len = 0;\n\t\t\tstr[len++] = nextChar();\n\t\t\tlen = reads(len, isSpace);\n\t\t\treturn Arrays.copyOf(str, len);\n\t\t}\n\n\t\tpublic char[][] next2DChars(int h, int w) {\n\t\t\tchar[][] s = new char[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\ts[i] = nextChars();\n\t\t\t}\n\t\t\treturn s;\n\t\t}\n\n\t\tint reads(int len, boolean[] accept) {\n\t\t\ttry {\n\t\t\t\twhile (true) {\n\t\t\t\t\tfinal int c = read();\n\t\t\t\t\tif (accept[c]) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (str.length == len) {\n\t\t\t\t\t\tchar[] rep = new char[str.length * 3 / 2];\n\t\t\t\t\t\tSystem.arraycopy(str, 0, rep, 0, str.length);\n\t\t\t\t\t\tstr = rep;\n\t\t\t\t\t}\n\t\t\t\t\tstr[len++] = (char) c;\n\t\t\t\t}\n\t\t\t} catch (MyInput.EndOfFileRuntimeException e) {\n\t\t\t}\n\t\t\treturn len;\n\t\t}\n\n\t\tpublic int[] nextIntArray(final int n) {\n\t\t\tfinal int[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic int[] nextIntArray1Index(final int n) {\n\t\t\tfinal int[] res = new int[n + 1];\n\t\t\tfor (int i = 1; i < n + 1; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic int[] nextIntArrayDec(final int n) {\n\t\t\tfinal int[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt() - 1;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray(final int n) {\n\t\t\tfinal long[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray1Index(final int n) {\n\t\t\tfinal long[] res = new long[n + 1];\n\t\t\tfor (int i = 1; i < n + 1; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArrayDec(final int n) {\n\t\t\tfinal long[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong() - 1;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(nextString());\n\t\t}\n\n\t\tpublic double[] nextDoubleArray(int n) {\n\t\t\tdouble[] res = new double[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextDouble();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tstatic class EndOfFileRuntimeException extends RuntimeException {\n\t\t}\n\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static class LazySegTree{\n\t\tint n;\n\t\tlong[] dat;\n\t\tlong[] lazy;\n\n\t\tpublic LazySegTree(int n_) {\n\t\t\tint n = 1;\n\t\t\twhile(n < n_){\n\t\t\t\tn *= 2;\n\t\t\t}\n\t\t\t\n\t\t\tthis.n = n;\n\t\t\tdat = new long[this.n * 2 - 1];\n\t\t\tlazy = new long[this.n * 2 - 1];\n\t\t\tfor(int i = 0; i < this.n * 2 - 1 ; i++){\n\t\t\t\tdat[i] = 0;\n\t\t\t\tlazy[i] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tpublic void update_node(int k){\n\t\t\tdat[k] = dat[2 * k + 1] + dat[2 * k + 2];\n\t\t}\n\t\t\n\t\tlong max(int a, int b, int k, int l, int r)\n\t\t{\n\t\t\tif (b <= l || r <= a){\n\t\t\t\treturn 0;\n\t\t\t}else if (a <= l && r <= b){\n\t\t\t\treturn dat[k] + lazy[k];\n\t\t\t}\n\t\t\t\n\t\t\tlong lch = max(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\t\tlong rch = max(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\t\t\n\t\t\treturn (Math.max(lch, rch) + lazy[k]);\n\t\t}\n\n\t\tvoid add(long x, int a, int b, int k, int l, int r)\n\t\t{\n\t\t\tif (b <= l || r <= a) return;\n\t\t\t\n\t\t\tif (a <= l && r <= b){\n\t\t\t\tlazy[k] += x;\n\t\t\t\twhile (k > 0){\n\t\t\t\t\tk = (k - 1) / 2;\n\t\t\t\t\tdat[k] = Math.max(dat[k * 2 + 1] + lazy[k * 2 + 1], dat[k * 2 + 2] + lazy[k * 2 + 2]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tadd(x, a, b, k * 2 + 1, l, (l + r) / 2);\n\t\t\t\tadd(x, a, b, k * 2 + 2, (l + r) / 2, r);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int size(){\n\t\t\treturn this.n;\n\t\t}\n\t\t\n\t\tpublic String toString(){\n\t\t\treturn Arrays.toString(dat) + \"\\n\" + Arrays.toString(lazy);\n\t\t}\n\t}\n\t\n\tpublic static class Floor implements Comparable<Floor>{\n\t\tlong rest_value;\n\t\tint pos;\n\t\t\n\t\tpublic Floor(long rest_value, int pos) {\n\t\t\tsuper();\n\t\t\tthis.rest_value = rest_value;\n\t\t\tthis.pos = pos;\n\t\t}\n\t\t\n\t\tpublic Floor(Floor o){\n\t\t\tsuper();\n\t\t\tthis.rest_value = o.rest_value;\n\t\t\tthis.pos = o.pos;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Floor o) {\n\t\t\tif(this.rest_value == o.rest_value){\n\t\t\t\treturn this.pos - o.pos;\n\t\t\t}else{\n\t\t\t\treturn o.rest_value > this.rest_value ? 1 : o.rest_value < this.rest_value ? -1 : 0;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Floor [rest_value=\" + rest_value + \", pos=\" + pos + \"]\";\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tfinal int N  = sc.nextInt();\n\t\tfinal long H = sc.nextLong();\n\t\t\n\t\tLazySegTree seg = new LazySegTree(N);\n\t\tPriorityQueue<Floor> queue = new PriorityQueue<Floor>();\n\t\t\n\t\tlong count = 0;\n\t\tlong life = H;\n\t\tfor(int i = 0; i < N - 1; i++){\n\t\t\tfinal int d = sc.nextInt();\n\t\t\tfinal int h = sc.nextInt();\n\t\t\t\n\t\t\tqueue.add(new Floor(h, i));\n\t\t\tseg.add(life, i, i + 1, 0, 0, seg.size());\n\t\t\t\n\t\t\tlife -= d;\n\t\t\tqueue.add(new Floor(h, i));\n\t\t\t\n\t\t\twhile(life <= 0){\n\t\t\t\tFloor floor = queue.poll();\n\t\t\t\t\n\t\t\t\t//if(heal.rest_value == 0){\n\t\t\t\t//\tcontinue;\n\t\t\t\t//}\n\t\t\t\t\n\t\t\t\t//System.out.println(heal + \" \" +  queue);\n\t\t\t\t\n\t\t\t\tlong max = seg.max(floor.pos, i + 1, 0, 0, seg.size());\n\t\t\t\t\n\t\t\t\t//System.out.println(i + \" \" + max + \" \" + life);\n\t\t\t\t\n\t\t\t\tif(floor.rest_value + max > H){\n\t\t\t\t\t//heal.rest_value = H - max;\n\t\t\t\t\tqueue.add(new Floor(H - max, floor.pos));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tlong many = Math.min((-life) / floor.rest_value + 1, (H - max) / floor.rest_value);\n\t\t\t\tcount += many;\n\t\t\t\tlife += many * floor.rest_value;\n\t\t\t\t\n\t\t\t\tseg.add(many * floor.rest_value, floor.pos, i + 1, 0, 0, seg.size());\n\t\t\t\tqueue.add(new Floor(floor));\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\t//System.out.println(\n\t\tSystem.out.println(count);\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport core.stdc.stdio;\nimport std.typecons;\nimport std.algorithm;\n\nvoid main(){\n\tint n;\n\tlong h;\n\tscanf(\"%d%lld\",&n,&h);\n\tlong[] ds = new long[n];\n\tlong[] hs = new long[n-1];\n\tfor(int i=0;i<n-1;i++)\n\t\tscanf(\"%lld%lld\",&ds[i+1],&hs[i]);\n\tfor(int i=1;i<n;i++)\n\t\tds[i] += ds[i-1];\n\t//ds.writeln;\n\tlong heal=0;\n\tlong ans=0;\n\tint b=0;\n\tint e=0;\n\talias Tuple!(int,\"prev\",int,\"next\") pn;\n\tpn[] list = new pn[n];\n\tfor(int i=0;i<n;i++)\n\t\tlist[i] = pn(i,i);\n\tfor(int s=1;s<n;s++){\n\t\t\t/*\n\t\t\ts.writeln;\n\t\t\twriteln(b,\" \",e,\" \",list[b].next);\n\t\t\twriteln(heal);\n\t\t\twriteln;\n\t\t\t*/\n\t\twhile(h<=ds[s]-heal){\n\t\t\tlong t = min(ds[b]-heal,ds[n-1]-heal-h+1);\n\t\t\t//t.writeln;\t\n\t\t\tif(t>=hs[b]){\n\t\t\t\tlong c = t/hs[b];\n\t\t\t\tans += c;\n\t\t\t\theal += hs[b]*c;\n\t\t\t}else{\n\t\t\t\tans++;\n\t\t\t\theal += t;\n\t\t\t}\n\t\t\twhile(list[b].next != b){\n\t\t\t\tint k = list[b].next;\n\t\t\t\tif(min(ds[b]-heal,hs[b])<=min(ds[k]-heal,hs[k]))\n\t\t\t\t\tb=k;\n\t\t\t\telse{\n\t\t\t\t\tlist[b].prev = b;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(s==n-1)\n\t\t\tbreak;\n\t\tlist[s].prev = e;\n\t\tlist[e].next = s;\n\t\te = s;\n\t\twhile(list[e].prev != e){\n\t\t\tint k=list[e].prev;\n\t\t\tif(hs[k]<=hs[e]){\n\t\t\t\tif(k==b){\n\t\t\t\t\tlist[e].prev = e;\n\t\t\t\t\tb=e;\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\tlist[e].prev = list[k].prev;\n\t\t\t\t\tlist[list[e].prev].next = e;\n\t\t\t\t}\n\t\t\t}else\n\t\t\t\tbreak;\n\t\t}\n\t\t//writeln;\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport core.stdc.stdio;\nimport std.typecons;\nimport std.algorithm;\n\nvoid main(){\n\tint n;\n\tlong h;\n\tscanf(\"%d%lld\",&n,&h);\n\tlong[] ds = new long[n];\n\tlong[] hs = new long[n-1];\n\tfor(int i=0;i<n-1;i++)\n\t\tscanf(\"%lld%lld\",&ds[i+1],&hs[i]);\n\tfor(int i=1;i<n;i++)\n\t\tds[i] += ds[i-1];\n\t//ds.writeln;\n\tlong heal=0;\n\tlong ans=0;\n\tint b=0;\n\tint e=0;\n\talias Tuple!(int,\"prev\",int,\"next\") pn;\n\tpn[] list = new pn[n];\n\tfor(int i=0;i<n;i++)\n\t\tlist[i] = pn(i,i);\n\tfor(int s=1;s<n;s++){\n\t\t\t/*\n\t\t\ts.writeln;\n\t\t\twriteln(b,\" \",e,\" \",list[b].next);\n\t\t\twriteln(\"heal \",heal);\n\t\t\twriteln;\n\t\t\t*/\n\t\twhile(h<=ds[s]-heal){\n\t\t\twhile(list[b].next != b){\n\t\t\t\tint k = list[b].next;\n\t\t\t\tif(min(ds[b]-heal,hs[b])<=min(ds[k]-heal,hs[k]))\n\t\t\t\t\tb=k;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlist[b].prev = b;\n\t\t\t\n\t\t\tlong t = min(ds[b]-heal,ds[s]-heal-h+1);\n\t\t\t//t.writeln;\t\n\t\t\tif(t>=hs[b]){\n\t\t\t\tlong c = t/hs[b];\n\t\t\t\tans += c;\n\t\t\t\theal += hs[b]*c;\n\t\t\t}else{\n\t\t\t\tans++;\n\t\t\t\theal += min(ds[b]-heal,hs[b]);\n\t\t\t}\n\t\t}\n\t\tif(s==n-1)\n\t\t\tbreak;\n\t\tlist[s].prev = e;\n\t\tlist[e].next = s;\n\t\te = s;\n\t\twhile(1){\n\t\t\tint k=list[e].prev;\n\t\t\tif(hs[k]<=hs[e]){\n\t\t\t\tif(k==b){\n\t\t\t\t\tlist[e].prev = e;\n\t\t\t\t\tb=e;\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\tlist[e].prev = list[k].prev;\n\t\t\t\t\tlist[list[e].prev].next = e;\n\t\t\t\t}\n\t\t\t}else\n\t\t\t\tbreak;\n\t\t}\n\t\t//writeln;\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0553\n\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom heapq import heappop, heappush\ninput = stdin.readline\n\n\ndef main(args):\n    N, H = map(int, input().split())\n    MAX_H = H\n\n    costs = []\n    wells = []\n    for _ in range(N - 1):\n        di, hi = map(int, input().split())\n        costs.append(di)\n        wells.append(hi)\n    costs.append(1e7)\n    wells.append(0)\n\n    ans = 0\n    floor = 1\n\n    while floor < N:\n        # ?£????????????§N????????§??°?????§??????????????§????????????\n        pq = []\n        while H > 0:\n            if H != MAX_H:\n                heappush(pq, [-1 * min(MAX_H-H, wells[floor - 1]), -floor, wells[floor - 1], H])\n\n            c = costs[floor - 1]\n            H -= c\n            floor += 1\n\n        if floor > N:\n            break\n\n        # ??°?????§??????????????°??????????????§??????????????§??????????????????????????°?????§????????????????????????\n        # ????????§???????????? min(MAX_H - H, ???????????????) ????????????\n        # ?????????????????¨??????????¬???????????????? MAX_H - (H + ???????????????) ??¨?????????\n        replenish, f, replenish_orig, orig_H = heappop(pq)\n\n#        if replenish == -replenish_orig:\n#            if H == 0:\n#                rep = 1\n#            else:\n#                rep = -H // replenish_orig\n#                if H % replenish_orig != 0:\n#                    rep += 1\n#\n#            H  = orig_H + (replenish_orig * rep)\n#            ans += rep\n#        else:\n        H  = orig_H - replenish\n        ans += 1\n\n\n        # ???????????¨???????????¨????????????H?????????????????§????????????????????¢????????£????????¨???????????¢?´¢???????????´??????\n        floor = -f\n\n\n    print(ans)\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0553\n\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom heapq import heappop, heappush\nimport time\ninput = stdin.readline\n\n\nclass RMQ(object):\n    INT_MAX = 2**31 - 1\n\n    def __init__(self, nn):\n        self.n = 1\n        while self.n < nn:\n            self.n *= 2\n        self.dat = [RMQ.INT_MAX] * ((2 * self.n)-1)\n\n    def update(self, k, a):\n        # A[k]???a?????´??°?????????????????°???????????¨?????´??°\n        k += (self.n - 1)\n        self.dat[k] = a\n\n        while k > 0:\n            k = (k - 1) // 2        #  ??????index??????\n            self.dat[k] = min(self.dat[k * 2 + 1], self.dat[k * 2 + 2]) #  ???????????¨??????????????????????°?????????????????????´??°\n\n    def add(self, k, a):\n        # A[k]???a??????????????????????????°???????????¨?????´??°\n        k += (self.n - 1)\n        self.dat[k] += a\n\n        while k > 0:\n            k = (k - 1) // 2        #  ??????index??????\n            self.dat[k] = min(self.dat[k * 2 + 1], self.dat[k * 2 + 2]) #  ???????????¨??????????????????????°?????????????????????´??°\n\n    def query(self, a, b, k, l, r):\n        # [a, b)???????°????????±??????? (0????????§b???????????????)\n        # ??????????????¨?????????query(a, b, 0, 0, n)?????¢??§??????????????????k, l, r???????????????????????´??°?????????\n        if r <= a or b <= l:        #  ?????????????????§??¨??????????????????\n            return RMQ.INT_MAX\n        if a <=l and r <= b:\n            return self.dat[k]           #  ???????????°???????????????????????§????????°????????¨??????????????????????°?????????????????????????\n        else:\n            vl = self.query(a, b, k*2+1, l, (l+r)//2) #  ????????°????????????????°????\n            vr = self.query(a, b, k*2+2, (l+r)//2, r) #  ????????°????????????????°????\n            return min(vl, vr)\n\n    def find(self, s, t):\n        return self.query(s, t+1, 0, 0, self.n)\n\n\ndef solve_hq(N, H, costs, wells):\n    MAX_H = H\n    ans = 0\n    floor = 1\n    repeat = True\n\n    while floor < N:\n        # ?£????????????§N????????§??°?????§??????????????§????????????\n        pq = []\n        while H > 0:\n            deficit = MAX_H - H\n            if deficit != 0:\n                heappush(pq, [-1 * min(MAX_H - H, wells[floor - 1]), wells[floor - 1], floor, H])\n            c = costs[floor - 1]\n            H -= c\n\n            if floor >= N or H < 1:\n                break\n            floor += 1\n\n        if H > 0:\n            return ans\n\n        # ??°?????§??????????????°??????????????§??????????????§??????????????????????????°?????§????????????????????????\n        # ????????§???????????? min(MAX_H - H, ???????????????) ????????????\n        # ?????????????????¨??????????¬???????????????? MAX_H - (H + ???????????????) ??¨?????????\n        replenish, replenish_orig, f, orig_H = heappop(pq)\n\n        H  = min(orig_H - replenish, MAX_H)\n        ans += 1\n\n        # ???????????¨???????????¨????????????H?????????????????§????????????????????¢????????£????????¨???????????¢?´¢???????????´??????\n        floor = f\n\n\ndef main(args):\n    # start = time.clock()\n    N, H = map(int, input().split())\n\n    costs = []\n    wells = []\n    for _ in range(N - 1):\n        di, hi = map(int, input().split())\n        costs.append(di)\n        wells.append(hi)\n    costs.append(0)\n    wells.append(0)\n\n    ans = solve_hq(N, H, costs, wells)\n\n    print(ans)\n    \n    # end = time.clock()\n    # print('elapsed: {}'.format(end - start))\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0553\n\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom heapq import heappop, heappush\ninput = stdin.readline\n\n\ndef main(args):\n    N, H = map(int, input().split())\n    MAX_H = H\n\n    costs = []\n    wells = []\n    for _ in range(N - 1):\n        di, hi = map(int, input().split())\n        costs.append(di)\n        wells.append(hi)\n    costs.append(1e7)\n    wells.append(0)\n\n    ans = 0\n    floor = 1\n\n    while floor < N:\n        # ?£????????????§N????????§??°?????§??????????????§????????????\n        pq = []\n        while H > 0:\n            damage = MAX_H - H\n            if damage != 0:\n                heappush(pq, [-1 * min(damage, wells[floor - 1]), wells[floor - 1], floor, H])\n\n            c = costs[floor - 1]\n            H -= c\n            floor += 1\n\n        if floor > N:\n            break\n\n        # ??°?????§??????????????°??????????????§??????????????§??????????????????????????°?????§????????????????????????\n        # ????????§???????????? min(MAX_H - H, ???????????????) ????????????\n        # ?????????????????¨??????????¬???????????????? MAX_H - (H + ???????????????) ??¨?????????\n        replenish, replenish_orig, f, orig_H = heappop(pq)\n\n        if replenish == -replenish_orig:\n            if H == 0:\n                rep = 1\n            else:\n                rep = -H // replenish_orig\n                if H % replenish_orig != 0:\n                    rep += 1\n\n            H  = orig_H + (replenish_orig * rep)\n            ans += rep\n        else:\n            H  = orig_H - replenish\n            ans += 1\n\n\n        # ???????????¨???????????¨????????????H?????????????????§????????????????????¢????????£????????¨???????????¢?´¢???????????´??????\n        floor = f\n\n\n    print(ans)\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0553\n\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom heapq import heappop, heappush\ninput = stdin.readline\n\n\ndef main(args):\n    N, H = map(int, input().split())\n    MAX_H = H\n\n    costs = []\n    wells = []\n    for _ in range(N - 1):\n        di, hi = map(int, input().split())\n        costs.append(di)\n        wells.append(hi)\n    costs.append(0)\n    wells.append(0)\n\n    ans = 0\n    floor = 1\n    repeat = True\n\n    while floor < N:\n        # ?£????????????§N????????§??°?????§??????????????§????????????\n        pq = []\n        while H > 0:\n            deficit = MAX_H - H\n            if deficit != 0:\n                heappush(pq, [-1 * min(MAX_H - H, wells[floor - 1]), wells[floor - 1], floor, H])\n            c = costs[floor - 1]\n            H -= c\n\n            if floor >= N or H < 1:\n                break\n            floor += 1\n\n        if H > 0:\n            break\n\n        # ??°?????§??????????????°??????????????§??????????????§??????????????????????????°?????§????????????????????????\n        # ????????§???????????? min(MAX_H - H, ???????????????) ????????????\n        # ?????????????????¨??????????¬???????????????? MAX_H - (H + ???????????????) ??¨?????????\n        replenish, replenish_orig, f, orig_H = heappop(pq)\n\n        if replenish == -replenish_orig:\n            if H == 0:\n                rep = 1\n            else:\n                rep = -H // replenish_orig\n                if H % replenish_orig != 0:\n                    rep += 1\n            H  = min(orig_H + (replenish_orig * rep), MAX_H)\n            ans += rep\n        else:\n            H  = min(orig_H - replenish, MAX_H)\n            ans += 1\n\n        # ???????????¨???????????¨????????????H?????????????????§????????????????????¢????????£????????¨???????????¢?´¢???????????´??????\n        floor = f\n\n    print(ans)\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n    "
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0553\n\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom heapq import heappop, heappush\ninput = stdin.readline\n\n\ndef solve():\n    pass\n\n\ndef main(args):\n    N, H = map(int, input().split())\n    MAX_H = H\n\n    costs = []\n    wells = []\n    for _ in range(N - 1):\n        di, hi = map(int, input().split())\n        costs.append(di)\n        wells.append(hi)\n    costs.append(0)\n    wells.append(0)\n\n    ans = 0\n    floor = 1\n    repeat = True\n\n    while floor < N:\n        # ?£????????????§N????????§??°?????§??????????????§????????????\n        pq = []\n        while H > 0:\n            heappush(pq, [-1 * min(MAX_H - H, wells[floor - 1]), floor, H])\n            c = costs[floor - 1]\n            H -= c\n\n            if floor >= N or H < 1:\n                break\n            floor += 1\n\n        if H > 0:\n            break\n\n        # ??°?????§??????????????°??????????????§??????????????§??????????????????????????°?????§????????????????????????\n        # ????????§???????????? min(MAX_H - H, ???????????????) ????????????\n        # ?????????????????¨??????????¬???????????????? MAX_H - (H + ???????????????) ??¨?????????\n        replenish, f, orig_H = heappop(pq)\n        H  = min(orig_H - replenish, MAX_H)\n        ans += 1\n\n        # ???????????¨???????????¨????????????H?????????????????§????????????????????¢????????£????????¨???????????¢?´¢???????????´??????\n        floor = f\n\n\n    print(ans)\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])"
  }
]