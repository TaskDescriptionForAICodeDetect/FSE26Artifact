[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_DIGITS 10\n#define MAX_MATCHSTICKS 100\n\nint matchsticks[MAX_DIGITS] = {6, 2, 5, 5, 4, 5, 6, 3, 7, 6};  // Matchsticks per digit 0-9\n\nint solve(int N, int M, int* allowedDigits) {\n    char result[MAX_MATCHSTICKS + 1];\n    int dp[MAX_MATCHSTICKS + 1];\n    \n    memset(dp, -1, sizeof(dp));\n    dp[0] = 0;\n    \n    for (int i = 1; i <= N; i++) {\n        for (int j = 0; j < M; j++) {\n            int digit = allowedDigits[j];\n            int sticks = matchsticks[digit];\n            \n            if (i >= sticks && dp[i - sticks] != -1) {\n                dp[i] = (dp[i] == -1) ? dp[i - sticks] * 10 + digit : \n                    (dp[i - sticks] * 10 + digit > dp[i] ? dp[i - sticks] * 10 + digit : dp[i]);\n            }\n        }\n    }\n    \n    return dp[N];\n}\n\nint main() {\n    int N, M;\n    int allowedDigits[MAX_DIGITS];\n    \n    scanf(\"%d %d\", &N, &M);\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d\", &allowedDigits[i]);\n    }\n    \n    int result = solve(N, M, allowedDigits);\n    printf(\"%d\\n\", result);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:55:48"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint matchsticks[] = {6, 2, 5, 5, 4, 5, 6, 3, 7, 6}; // matchsticks needed for digits 0-9\n\nvoid findLargestNumber(int N, int* digits, int M) {\n    int* dp = (int*)malloc((N + 1) * sizeof(int));\n    char** num = (char**)malloc((N + 1) * sizeof(char*));\n    for (int i = 0; i <= N; i++) {\n        num[i] = (char*)malloc((N + 2) * sizeof(char));\n        num[i][0] = '\\0';\n    }\n    dp[0] = 0;\n    \n    for (int i = 1; i <= N; i++) {\n        dp[i] = -1;\n        for (int j = 0; j < M; j++) {\n            int d = digits[j];\n            int cost = matchsticks[d];\n            if (i >= cost && dp[i - cost] != -1) {\n                if (dp[i] < dp[i - cost] + 1) {\n                    dp[i] = dp[i - cost] + 1;\n                    strcpy(num[i], num[i - cost]);\n                    char temp[2];\n                    temp[0] = '0' + d;\n                    temp[1] = '\\0';\n                    strcat(num[i], temp);\n                } else if (dp[i] == dp[i - cost] + 1) {\n                    char temp1[2];\n                    temp1[0] = '0' + d;\n                    temp1[1] = '\\0';\n                    char temp[N + 2];\n                    strcpy(temp, num[i - cost]);\n                    strcat(temp, temp1);\n                    if (strcmp(temp, num[i]) > 0) {\n                        strcpy(num[i], temp);\n                    }\n                }\n            }\n        }\n    }\n    \n    if (dp[N] == -1) {\n        printf(\"-1\\n\");\n    } else {\n        printf(\"%s\\n\", num[N]);\n    }\n    \n    for (int i = 0; i <= N; i++) {\n        free(num[i]);\n    }\n    free(num);\n    free(dp);\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n    int* digits = (int*)malloc(M * sizeof(int));\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d\", &digits[i]);\n    }\n    findLargestNumber(N, digits, M);\n    free(digits);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:56:13"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint matchsticks[] = {6, 2, 5, 5, 4, 5, 6, 3, 7, 6};\n\nstring solve(int N, vector<int>& digits) {\n    vector<int> dp(N + 1, -1);\n    dp[0] = 0;\n    for (int i = 1; i <= N; ++i) {\n        for (int d : digits) {\n            int cost = matchsticks[d];\n            if (i >= cost && dp[i - cost] != -1) {\n                dp[i] = max(dp[i], dp[i - cost] + 1);\n            }\n        }\n    }\n    \n    if (dp[N] == -1) return \"\";\n    \n    string res;\n    int remaining = N;\n    sort(digits.begin(), digits.end(), greater<int>());\n    while (remaining > 0) {\n        for (int d : digits) {\n            int cost = matchsticks[d];\n            if (remaining >= cost && dp[remaining - cost] == dp[remaining] - 1) {\n                res += to_string(d);\n                remaining -= cost;\n                break;\n            }\n        }\n    }\n    return res;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector<int> digits(M);\n    for (int i = 0; i < M; ++i) {\n        cin >> digits[i];\n    }\n    string result = solve(N, digits);\n    if (result.empty()) {\n        cout << \"0\" << endl;\n    } else {\n        cout << result << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 22:56:31"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class LargestNumberWithMatchsticks {\n    private static final int[] matchCount = {6, 2, 5, 5, 4, 5, 6, 3, 7, 6}; // 0-9 match counts\n\n    public static String largestNumber(int[] digits, int n) {\n        // Preprocess digits to only include those with minimal matchstick counts for their value\n        Map<Integer, Integer> digitToMatches = new HashMap<>();\n        for (int d : digits) {\n            digitToMatches.put(d, matchCount[d]);\n        }\n        \n        // Sort digits in descending order to prioritize larger digits first\n        Arrays.sort(digits);\n        int[] sortedDigits = new int[digits.length];\n        for (int i = 0; i < digits.length; i++) {\n            sortedDigits[i] = digits[digits.length - 1 - i];\n        }\n        \n        // DP array to store the maximum number of digits possible for each matchstick count\n        int[] dp = new int[n + 1];\n        Arrays.fill(dp, -1);\n        dp[0] = 0;\n        \n        for (int i = 1; i <= n; i++) {\n            for (int d : sortedDigits) {\n                int cost = digitToMatches.get(d);\n                if (i >= cost && dp[i - cost] != -1) {\n                    dp[i] = Math.max(dp[i], dp[i - cost] + 1);\n                }\n            }\n        }\n        \n        if (dp[n] == -1) {\n            return \"0\";\n        }\n        \n        // Construct the largest number\n        StringBuilder sb = new StringBuilder();\n        int remaining = n;\n        while (remaining > 0) {\n            for (int d : sortedDigits) {\n                int cost = digitToMatches.get(d);\n                if (remaining >= cost && dp[remaining] == dp[remaining - cost] + 1) {\n                    sb.append(d);\n                    remaining -= cost;\n                    break;\n                }\n            }\n        }\n        \n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        int[] digits = new int[M];\n        for (int i = 0; i < M; i++) {\n            digits[i] = scanner.nextInt();\n        }\n        System.out.println(largestNumber(digits, N));\n    }\n}",
    "timestamp": "2025-08-05 22:56:56"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class MatchstickLargestNumber {\n    public static String largestNumber(int[] matchsticks, int[] digits, int N) {\n        int[] dp = new int[N + 1];\n        Arrays.fill(dp, -1);\n        dp[0] = 0;\n\n        for (int i = 1; i <= N; i++) {\n            for (int digit : digits) {\n                int matchCount = matchsticks[digit];\n                if (i >= matchCount && dp[i - matchCount] != -1) {\n                    dp[i] = Math.max(dp[i], dp[i - matchCount] * 10 + digit);\n                }\n            }\n        }\n\n        return dp[N] == -1 ? \"0\" : String.valueOf(dp[N]);\n    }\n\n    public static void main(String[] args) {\n        int[] matchsticks = {6, 2, 5, 5, 4, 5, 6, 3, 7, 6}; // Matchsticks for digits 0-9\n        int[] digits = {1, 3, 5, 7, 9}; // Allowed digits\n        int N = 15; // Total matchsticks available\n        \n        System.out.println(largestNumber(matchsticks, digits, N));\n    }\n}",
    "timestamp": "2025-08-05 22:57:02"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    \n    vector<int> matchsticks(10, 0);\n    vector<int> validDigits(M);\n    \n    for (int i = 0; i < 10; i++) {\n        cin >> matchsticks[i];\n    }\n    \n    for (int i = 0; i < M; i++) {\n        cin >> validDigits[i];\n    }\n    \n    sort(validDigits.begin(), validDigits.end(), greater<int>());\n    \n    vector<string> dp(N + 1, \"\");\n    \n    for (int i = 0; i <= N; i++) {\n        for (int digit : validDigits) {\n            int cost = matchsticks[digit];\n            \n            if (cost > i) continue;\n            \n            string curr = dp[i - cost] + to_string(digit);\n            \n            if (curr.length() > dp[i].length() || \n                (curr.length() == dp[i].length() && curr > dp[i])) {\n                dp[i] = curr;\n            }\n        }\n    }\n    \n    cout << (dp[N].empty() ? \"0\" : dp[N]) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:57:08"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def largest_number_with_matchsticks(N, digits, matchsticks_required):\n    # Map the digits to their matchstick requirements\n    digit_matchsticks = list(zip(digits, matchsticks_required))\n    # Sort digits primarily by matchsticks required in ascending order,\n    # and by digit in descending order for equal matchstick requirements\n    digit_matchsticks.sort(key=lambda x: (x[1], -x[0]))\n    \n    # Create a DP array to keep track of the largest number using the remaining matchsticks\n    dp = [\"\"] * (N + 1)\n    \n    # Iterate over each matchstick count possible\n    for i in range(1, N + 1):\n        for digit, m_req in digit_matchsticks:\n            if i >= m_req:  # If we can use this digit\n                # Form a new number by adding this digit to a previous solution\n                new_number = dp[i - m_req] + str(digit)\n                # Update dp[i] if the new number is larger\n                if len(new_number) > len(dp[i]) or (len(new_number) == len(dp[i]) and new_number > dp[i]):\n                    dp[i] = new_number\n    \n    return dp[N] if dp[N] else \"\"\n\n# Example usage\nN = 5  \ndigits = [1, 5, 7]\nmatchsticks_required = [2, 5, 3]\nprint(largest_number_with_matchsticks(N, digits, matchsticks_required))  # Output will depend on the mapping",
    "timestamp": "2025-08-13 13:02:17"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class LargestIntegerWithMatchsticks {\n    // Matchstick count for each digit from 0 to 9\n    private static final int[] matchstickCount = {6, 2, 5, 5, 4, 5, 6, 3, 7, 6}; \n    \n    // Custom comparator to sort digits\n    private static Comparator<Integer> digitComparator = new Comparator<Integer>() {\n        public int compare(Integer a, Integer b) {\n            if (b != a) return Integer.compare(b, a); // Sort by value descending\n            return Integer.compare(matchstickCount[a], matchstickCount[b]); // Then by matchstick count ascending\n        }\n    };\n    \n    public static String largestNumber(int N, int[] digits) {\n        Arrays.sort(digits); // Sort the digits for combination\n        int[] minSticks = new int[N + 1];\n        Arrays.fill(minSticks, Integer.MAX_VALUE); \n        String[] strings = new String[N + 1];\n        strings[0] = \"\"; // Base case\n        \n        for (int i = 0; i <= N; i++) {\n            if (strings[i] == null) continue; \n            for (int d : digits) {\n                int nextLength = i + matchstickCount[d];\n                if (nextLength <= N && minSticks[nextLength] > minSticks[i] + 1) {\n                    strings[nextLength] = strings[i] + d;\n                    minSticks[nextLength] = minSticks[i] + 1;\n                }\n            }\n        }\n\n        List<Integer> possibleDigits = new ArrayList<>();\n        for (char c : strings[N].toCharArray()) {\n            possibleDigits.add(c - '0');\n        }\n        possibleDigits.sort(digitComparator);\n\n        StringBuilder result = new StringBuilder();\n        for (int d : possibleDigits) {\n            result.append(d);\n        }\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        int N = 15; // Example value for N\n        int[] digits = {1, 2, 3, 5, 7}; // Example digit options\n        System.out.println(largestNumber(N, digits)); // Outputs the largest number possible\n    }\n}",
    "timestamp": "2025-08-13 13:02:25"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint cmp(const void *a, const void *b) {\n    return (*(char *)b - *(char *)a);\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n    \n    int matchsticks[10];\n    memset(matchsticks, -1, sizeof(matchsticks));\n\n    for (int i = 0; i < M; i++) {\n        int digit, sticks;\n        scanf(\"%d %d\", &digit, &sticks);\n        matchsticks[digit] = sticks;\n    }\n\n    // Step 1: Prepare the available digits and sort in descending order\n    char availableDigits[10], len = 0;\n    for (int i = 0; i < 10; i++) {\n        if (matchsticks[i] != -1) {\n            availableDigits[len++] = '0' + i;\n        }\n    }\n    availableDigits[len] = '\\0';\n    qsort(availableDigits, len, sizeof(char), cmp);\n\n    // Step 2: DP array for storing the maximum number of digits for given matchsticks\n    char dp[N+1][101] = {0}; // Assume maximum digits formed <= 100\n    memset(dp, 0, sizeof(dp));\n    \n    for (int i = 0; i <= N; i++) {\n        for (int j = 0; j < len; j++) {\n            int digit = availableDigits[j] - '0';\n            int matchNeed = matchsticks[digit];\n            if (i == matchNeed || (i > matchNeed && dp[i - matchNeed][0])) {\n                char newNum[101];\n                strcpy(newNum, dp[i - matchNeed]);\n                newNum[strlen(newNum)] = availableDigits[j];\n                newNum[strlen(newNum) + 1] = '\\0';\n                \n                if (strlen(newNum) > strlen(dp[i]) || \n                    (strlen(newNum) == strlen(dp[i]) && strcmp(newNum, dp[i]) > 0)) {\n                    strcpy(dp[i], newNum);\n                }\n            }\n        }\n    }\n\n    // Final result\n    if (dp[N][0]) {\n        printf(\"%s\\n\", dp[N]);\n    } else {\n        printf(\"0\\n\"); // If no number can be formed\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 13:02:37"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <climits>\n\nstd::string findLargestNumberWithMatchsticks(int N, const std::vector<int>& digits, const std::map<int, int>& matchstickUsage) {\n    std::vector<int> sortedDigits = digits;\n    std::sort(sortedDigits.begin(), sortedDigits.end(), [&](int a, int b) {\n        return matchstickUsage.at(a) < matchstickUsage.at(b);\n    });\n\n    std::vector<std::string> dp(N + 1, \"\");\n    \n    for (int i = 1; i <= N; ++i) {\n        for (const int& digit : sortedDigits) {\n            int matchsticksNeeded = matchstickUsage.at(digit);\n            if (i >= matchsticksNeeded && !dp[i - matchsticksNeeded].empty()) {\n                std::string candidate = dp[i - matchsticksNeeded] + char('0' + digit);\n                if (candidate.length() > dp[i].length() || \n                   (candidate.length() == dp[i].length() && candidate > dp[i])) {\n                    dp[i] = candidate;\n                }\n            }\n        }\n        if (i >= matchstickUsage.at(sortedDigits[0]))\n            dp[i] = std::string(dp[i - matchstickUsage.at(sortedDigits[0])].length() + 1, '0' + sortedDigits[0]);\n    }\n\n    return !dp[N].empty() ? dp[N] : \"0\";\n}\n\nint main() {\n    int N = 5;\n    std::vector<int> digits = {5, 7, 3};\n    std::map<int, int> matchstickUsage = {{0, 6}, {1, 2}, {2, 5}, {3, 5}, {4, 4}, {5, 5},\n                                          {6, 6}, {7, 3}, {8, 7}, {9, 6}};\n    std::cout << findLargestNumberWithMatchsticks(N, digits, matchstickUsage) << std::endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 13:02:44"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def largest_number_with_matchsticks(N, digits, matchstick_counts):\n    # Create a matchstick mapping for given digits\n    digit_matchsticks = {digit: count for digit, count in zip(digits, matchstick_counts)}\n    \n    # Dynamic programming to store maximum numbers possible\n    dp = [float('-inf')] * (N + 1)\n    dp[0] = 0\n    \n    # Track the digit used to reach each matchstick count\n    digit_used = [None] * (N + 1)\n    \n    # Try forming number for each possible matchstick count\n    for total_matchsticks in range(1, N + 1):\n        for digit in digits:\n            match_needed = digit_matchsticks[digit]\n            \n            # Check if we can form this digit\n            if total_matchsticks >= match_needed:\n                prev_state = total_matchsticks - match_needed\n                \n                # Update if forming this digit creates a larger number\n                if dp[prev_state] != float('-inf'):\n                    candidate = dp[prev_state] * 10 + int(digit)\n                    if candidate > dp[total_matchsticks]:\n                        dp[total_matchsticks] = candidate\n                        digit_used[total_matchsticks] = digit\n    \n    # Return largest number possible with exactly N matchsticks\n    return dp[N] if dp[N] != float('-inf') else 0",
    "timestamp": "2025-08-13 13:02:51"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def largest_number_with_matchsticks(N, digits, match_counts):\n    # Predefined match counts for each digit (0-9)\n    digit_matches = {\n        0: 6,\n        1: 2,\n        2: 5,\n        3: 5,\n        4: 4,\n        5: 5,\n        6: 6,\n        7: 3,\n        8: 7,\n        9: 6\n    }\n    \n    # Filter digits to only include those in A_1..A_M and get their match counts\n    valid_digits = []\n    for d in digits:\n        if d in digit_matches:\n            valid_digits.append((d, digit_matches[d]))\n    \n    if not valid_digits:\n        return \"0\"\n    \n    # Sort digits in descending order to prioritize larger digits first\n    valid_digits.sort(reverse=True, key=lambda x: x[0])\n    \n    # DP table: dp[i] = maximum number of digits possible using i matchsticks\n    dp = [-1] * (N + 1)\n    dp[0] = 0\n    \n    for i in range(1, N + 1):\n        for d, cost in valid_digits:\n            if i >= cost and dp[i - cost] != -1:\n                if dp[i] < dp[i - cost] + 1:\n                    dp[i] = dp[i - cost] + 1\n    \n    if dp[N] == -1:\n        return \"0\"\n    \n    # Reconstruct the largest number\n    remaining = N\n    result = []\n    \n    while remaining > 0:\n        for d, cost in valid_digits:\n            if remaining >= cost and dp[remaining] == dp[remaining - cost] + 1:\n                result.append(str(d))\n                remaining -= cost\n                break\n    \n    return ''.join(result) if result else \"0\"",
    "timestamp": "2025-08-13 13:03:02"
  }
]