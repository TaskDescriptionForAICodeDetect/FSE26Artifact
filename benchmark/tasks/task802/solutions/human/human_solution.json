[
  {
    "language": "Scala",
    "code": "import java.util\nimport java.util.{Collections, Comparator}\n\nobject Main {\n  import java.io.{BufferedReader, InputStream, InputStreamReader}\n  import java.util.StringTokenizer\n  import scala.reflect.ClassTag\n\n  def main(args: Array[String]): Unit = {\n    val out = new java.io.PrintWriter(System.out)\n    new Main(out, new InputReader(System.in)).solve()\n    out.flush()\n  }\n\n  private[this] val oj = System.getenv(\"MY_DEBUG\") == null\n  def DEBUG(f: => Unit): Unit = {\n    if (!oj){ f }\n  }\n  def debug(as: Array[Boolean]): Unit = if (!oj){ debug(as.map(x => if(x) \"1\" else \"0\").mkString) }\n  def debug(as: Array[Int]): Unit = if (!oj){ debug(as.mkString(\" \")) }\n  def debug(as: Array[Long]): Unit =if (!oj){ debug(as.mkString(\" \")) }\n  def debugDim(m: Array[Array[Int]]): Unit = if (!oj){\n    REP(m.length) { i =>\n      debug(m(i))\n    }\n  }\n  def debugDimFlip(m: Array[Array[Long]]): Unit = if (!oj){\n    REP(m(0).length) { j =>\n      REP(m.length) { i =>\n        System.err.print(m(i)(j))\n        System.err.print(\" \")\n      }\n      System.err.println()\n    }\n  }\n  def debug(s: => String): Unit = {\n    if (!oj){ System.err.println(s) }\n  }\n  def isDebug[A](debug: => A, online: => A): A = {\n    if (oj) online else debug\n  }\n\n  class InputReader(val stream: InputStream) {\n    private[this] val reader = new BufferedReader(new InputStreamReader(stream), 32768)\n    private[this] var tokenizer: StringTokenizer = _\n\n    private[this] def next(): String = {\n      while (tokenizer == null || !tokenizer.hasMoreTokens)\n        tokenizer = new StringTokenizer(reader.readLine)\n      tokenizer.nextToken\n    }\n\n    def nextInt(): Int = Integer.parseInt(next())\n    def nextLong(): Long = java.lang.Long.parseLong(next())\n    def nextChar(): Char = next().charAt(0)\n\n    def ni(): Int = nextInt()\n    def nl(): Long = nextLong()\n    def nc(): Char = nextChar()\n    def ns(): String = next()\n    def ns(n: Int): Array[Char] = ns().toCharArray\n    def na(n: Int, offset: Int = 0): Array[Int] = map(n)(_ => ni() + offset)\n    def na2(n: Int, offset: Int = 0): (Array[Int], Array[Int]) = {\n      val A1, A2 = Array.ofDim[Int](n)\n      REP(n) { i =>\n        A1(i) = ni() + offset\n        A2(i) = ni() + offset\n      }\n      (A1, A2)\n    }\n    def nm(n: Int, m: Int): Array[Array[Int]] = {\n      val A = Array.ofDim[Int](n, m)\n      REP(n) { i =>\n        REP(m) { j =>\n          A(i)(j) = ni()\n        }\n      }\n      A\n    }\n    def nal(n: Int): Array[Long] = map(n)(_ => nl())\n    def nm_c(n: Int, m: Int): Array[Array[Char]] = map(n) (_ => ns(m))\n  }\n\n  def REP(n: Int, offset: Int = 0)(f: Int => Unit): Unit = {\n    var i = offset\n    val N = n + offset\n    while(i < N) { f(i); i += 1 }\n  }\n  def REP_r(n: Int, offset: Int = 0)(f: Int => Unit): Unit = {\n    var i = n - 1 + offset\n    while(i >= offset) { f(i); i -= 1 }\n  }\n  def TO(from: Int, to: Int)(f: Int => Unit): Unit = {\n    REP(to - from + 1, from)(f)\n  }\n  def map[@specialized A: ClassTag](n: Int, offset: Int = 0)(f: Int => A): Array[A] = {\n    val res = Array.ofDim[A](n)\n    REP(n)(i => res(i) = f(i + offset))\n    res\n  }\n\n  def sumL(as: Array[Int]): Long = {\n    var s = 0L\n    REP(as.length)(i => s += as(i))\n    s\n  }\n  def cumSum(as: Array[Int]): Array[Long] = {\n    val cum = Array.ofDim[Long](as.length + 1)\n    REP(as.length) { i =>\n      cum(i + 1) = cum(i) + as(i)\n    }\n    cum\n  }\n}\n\nobject Workspace {\n  import Main._\n  import java.util.Arrays.sort\n\n  import scala.collection.mutable\n  import math.{abs, max, min}\n  import mutable.ArrayBuffer\n\n  def packUGraph(n: Int, from: Array[Int], to: Array[Int]): Array[Array[Int]] = {\n    val t = new Array[Array[Int]](n)\n    val p = new Array[Int](n)\n    val m = from.length\n    REP(m)(i => p(from(i)) += 1)\n    REP(m)(i => p(to(i)) += 1)\n    REP(n)(i => t(i) = new Array(p(i)))\n    REP(m) { i =>\n      p(from(i)) -= 1\n      t(from(i))(p(from(i))) = to(i)\n      p(to(i)) -= 1\n      t(to(i))(p(to(i))) = from(i)\n    }\n    t\n  }\n\n  /**\n   * @return (depth, parent, queue)\n   */\n  def traceBfs(g: Array[Array[Int]], rt: Option[Int] = Some(0)): (Array[Int], Array[Int], Array[Int]) = {\n    val n = g.length\n    val INF = 1e9.toInt + 10\n    val q, p = Array.ofDim[Int](n)\n    val d = Array.fill[Int](n)(INF)\n    var cur, last = 0\n\n    def bfs(rt: Int) {\n      q(last) = rt\n      last += 1\n      p(rt) = -1\n      d(rt) = 0\n\n      while (cur < last) {\n        val v = q(cur)\n        REP(g(v).length) { i =>\n          val u = g(v)(i)\n          if (d(u) == INF) {\n            d(u) = d(v) + 1\n            p(u) = v\n            q(last) = u\n            last += 1\n          }\n        }\n        cur += 1\n      }\n    }\n\n    rt.map(bfs).getOrElse {\n      REP(n) { v =>\n        if (d(v) == INF) bfs(v)\n      }\n    }\n\n    (d, p, q)\n  }\n}\n\nclass Main(out: java.io.PrintWriter, sc: Main.InputReader) {\n  import sc._\n  import Main._\n  import java.util.Arrays.sort\n\n  import scala.collection.mutable\n  import math.{abs, max, min}\n  import mutable.ArrayBuffer\n  import Workspace._\n\n  // toIntとか+7とかするならvalにしろ\n  final private[this] val MOD = 1000000007\n\n  def solve(): Unit = {\n    val N = ni()\n    val A = na(N)\n    val (from, to) = na2(N - 1, -1)\n    val g = packUGraph(N, from, to)\n    val (_, par, queue) = traceBfs(g)\n    val dp = Array.ofDim[Value](N)\n\n    REP_r(N) { i =>\n      val v = queue(i)\n      val vals = new util.ArrayList[Value]()\n      REP(g(v).length) { j =>\n        val u = g(v)(j)\n        if (u != par(v)) {\n          vals.add(dp(u))\n        }\n      }\n\n      Collections.sort(vals, new Comparator[Value] {\n        override def compare(o1: Value, o2: Value): Int = Integer.compare(o1.size, o2.size)\n      })\n\n      var cur = init(A(v))\n      REP(vals.size()) { j =>\n        cur = merge(cur, vals.get(j))\n      }\n\n      dp(v) = cur\n    }\n\n    debug(\"DP\")\n    debug(dp.zipWithIndex.map{ case (a, i) => s\"DP[$i]\\n\"+a.mkString(\"\\n\")}.mkString(\"\\n\"))\n\n    out.println(cntMinCut(dp(0)))\n  }\n\n  def cntMinCut(v: Value): Int = {\n    var res = 1e9.toInt\n    for {\n      (k, cnt) <- v\n    } {\n      if (k.noPc || cnt < 0) res = min(res, k.cuts)\n    }\n    res\n  }\n\n  def merge(rt: Value, child: Value): Value = {\n    val map = mutable.Map[Key, Int]()\n    def setMin(k: Key, cnt: Int): Unit = {\n      if (!map.contains(k) || cnt < map(k)) map(k) = cnt\n    }\n    // つなげた\n    for {\n      (k1, cnt1) <- rt\n      (k2, cnt2) <- child\n    } {\n      val k = Key(k1.cuts + k2.cuts, k1.noPc && k2.noPc)\n      setMin(k, cnt1 + cnt2)\n    }\n\n    val cut2 = cntMinCut(child) + 1 // child側をrtから切り離してすべてが条件を満たすようになる必要最低カット\n    for {\n      (k1, cnt) <- rt\n    } {\n      val k = Key(k1.cuts + cut2, k1.noPc)\n      if (k.noPc || cnt < 0) setMin(k, cnt)\n    }\n\n    map\n  }\n\n  def init(a: Int): Value = {\n    val v: Value = mutable.Map()\n    v(Key(0, a > 0)) = a\n    v\n  }\n\n  case class Key(cuts: Int, noPc: Boolean)\n  type Value = mutable.Map[Key, Int]\n}"
  },
  {
    "language": "Fortran",
    "code": "module mod_t_list\n  implicit none\n  type :: t_list\n    integer :: vol\n    integer, pointer :: arr(:)\n  end type t_list\n  private\n  public :: t_list, init_list, release_list,push_back\n  public :: pop_back, get_at, size_of_list\ncontains\n  subroutine init_list(list)\n    implicit none\n    type(t_list), intent(inout) :: list\n    list%vol = 0\n    allocate(list%arr(1))\n    return\n  end subroutine init_list\n  subroutine release_list(list)\n    implicit none\n    type(t_list), intent(inout) :: list\n    if (associated(list%arr)) deallocate(list%arr)\n    return\n  end subroutine release_list\n  subroutine push_back(list,item)\n    implicit none\n    type(t_list), intent(inout) :: list\n    integer, intent(in) :: item\n    integer, allocatable :: tmp(:)\n    if (size(list%arr).eq.list%vol) then\n      allocate(tmp(list%vol))\n      tmp = list%arr\n      deallocate(list%arr)\n      allocate(list%arr(2*list%vol))\n      list%arr(1:list%vol) = tmp\n      deallocate(tmp)\n    end if\n    list%vol = list%vol+1\n    list%arr(list%vol) = item\n    return\n  end subroutine push_back\n  function pop_back(list) result(item)\n    implicit none\n    type(t_list), intent(inout) :: list\n    integer :: item\n    item = list%arr(list%vol)\n    list%vol = list%vol-1\n    return\n  end function pop_back\n  function get_at(list,i) result(item)\n    implicit none\n    type(t_list), intent(in) :: list\n    integer, intent(in) :: i\n    integer :: item\n    item = list%arr(i)\n    return\n  end function get_at\n  function size_of_list(list) result(s)\n    implicit none\n    type(t_list), intent(in) :: list\n    integer :: s\n    s = list%vol\n    return\n  end function size_of_list\nend module mod_t_list\nmodule mod_t_graph\n  use mod_t_list\n  implicit none\n  integer, parameter :: infty = 1000000000\n  type :: t_graph\n    type(t_list), pointer :: edges(:)\n  end type t_graph\n  private\n  public :: infty\n  public :: t_graph, init_graph, release_graph, add\ncontains\n  subroutine init_graph(graph,n)\n    implicit none\n    type(t_graph), intent(inout) :: graph\n    integer, intent(in) :: n\n    integer :: i\n    allocate(graph%edges(n))\n    do i = 1, n\n      call init_list(graph%edges(i))\n    end do\n    return\n  end subroutine init_graph\n  subroutine release_graph(graph)\n    implicit none\n    type(t_graph), intent(inout) :: graph\n    integer :: n, i\n    if (.not.associated(graph%edges)) return\n    n = size(graph%edges)\n    do i = 1, n\n      call release_list(graph%edges(i))\n    end do\n    deallocate(graph%edges)\n    return\n  end subroutine release_graph\n  subroutine add(graph,x,y)\n    implicit none\n    type(t_graph), intent(inout) :: graph\n    integer, intent(in) :: x, y\n    call push_back(graph%edges(x),y)\n    return\n  end subroutine add\nend module mod_t_graph\nmodule mod_attack_to_a_tree\n  use mod_t_list\n  use mod_t_graph\n  implicit none\n  integer, parameter :: infty4 = 1000000000\n  integer(8), parameter :: infty8 = 1000000000000000000_8\n  integer :: n, dp(5000), dp1(5000), num(5000)\n  integer(8) :: a(5000), dp2(5000,5000)\n  logical :: ok(5000)\n  type(t_graph) :: tree\ncontains\n  subroutine solve()\n    implicit none\n    integer :: u, v, i\n    a = 0_8\n    dp = -1\n    dp1 = -1\n    dp2 = 0_8\n    num = 0\n    ok = .false.\n    read(*,*) n\n    read(*,*) a(1:n)\n    call init_graph(tree,n)\n    do i = 1, n-1\n      read(*,*) u, v\n      call add(tree,u,v)\n      call add(tree,v,u)\n    end do\n    write(*,'(i0)') dfs(1,-1)-1\n    return\n  end subroutine solve\n  recursive function dfs(v,p) result(m)\n    implicit none\n    integer, intent(in) :: v, p\n    integer :: m, i\n    m = dp(v)\n    if (m.ne.-1) return\n    m = dfs1(v,p)\n    do i = 1, size_of(v,p)\n      if (dfs2(v,i,p).lt.0_8) then\n        m = min(m,i)\n        exit\n      end if\n    end do\n    dp(v) = m\n    return\n  end function dfs\n  recursive function dfs1(v,p) result(m)\n    implicit none\n    integer, intent(in) :: v, p\n    integer :: m, i, e\n    m = dp1(v)\n    if (m.ne.-1) return\n    m = infty4\n    if (a(v).lt.0_8) return\n    m = 0\n    do i = 1, size_of_list(tree%edges(v))\n      e = get_at(tree%edges(v),i)\n      if (e.eq.p) cycle\n      m = m+min(dfs1(e,v),dfs(e,v)+1)\n    end do\n    dp1(v) = m\n    return\n  end function dfs1\n  recursive function dfs2(v,e,p) result(m)\n    implicit none\n    integer, intent(in) :: v, e, p\n    integer(8) :: m, y\n    integer :: i, j, s, t, l\n    m = dp2(v,e)\n    if (ok(v)) return\n    ok(v) = .true.\n    dp2(v,:) = infty8\n    dp2(v,1) = a(v)\n    s = 1\n    do i = 1, size_of_list(tree%edges(v))\n      t = get_at(tree%edges(v),i)\n      if (e.eq.p) cycle\n      do j = s, 1, -1\n        y = dp2(v,j)\n        dp2(v,j) = y+dfs2(t,1,v)\n        if (j+dfs(t,v).le.size_of(v,p)) then\n          dp2(v,j+dfs(t,v)) = min(dp2(v,j+dfs(t,v)),y)\n        end if\n        do l = size_of(t,v), 2, -1\n          dp2(v,j+l-1) = min(dp2(v,j+l-1),y+dfs2(t,l,v))\n        end do\n      end do\n      s = s+size_of(t,v)\n    end do\n    m = dp2(v,e)\n    return\n  end function dfs2\n  recursive function size_of(v,p) result(m)\n    implicit none\n    integer, intent(in) :: v, p\n    integer :: m, i, e\n    m = num(v)\n    if (m.ne.0) return\n    m = 1\n    do i = 1, size_of_list(tree%edges(v))\n      e = get_at(tree%edges(v),i)\n      if (e.eq.p) cycle\n      m = m+size_of(e,v)\n    end do\n    num(v) = m\n    return\n  end function size_of\nend module mod_attack_to_a_tree\nprogram attack_to_a_tree\n  use mod_attack_to_a_tree\n  implicit none\n  call solve()\n  stop\nend program attack_to_a_tree"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#define vll vector<ll>\n#define vvvl vector<vvl>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d> >(a, vector<d>(b, c))\n#define VVV(a, b, c, d) vector<vvl>(a, vvl(b, vll (c, d)));\n#define re(c, b) for(ll c=0;c<b;c++)\n#define all(obj) (obj).begin(), (obj).end()\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\n\nvll num;\nll N;\nvvl G = VV(5001, 0, 0, ll);\nll INF = 1000000000000000000;\nvvvl dp = VVV(5001, 0, 0, INF);\nvll sz(5001, -1);\n\nvoid dfs(ll now, ll from){\n  ll now_sz = 1;\n  vvl prev = VV(N+1, 2, INF, ll);\n  vvl dat = VV(N+1, 2, INF, ll);\n  dat[1][0] = num[now];\n  if(num[now]>0) dat[1][1] = num[now];\n\n  for(auto to:G[now]){\n    if(to==from) continue;\n    dfs(to, now);\n    now_sz += sz[to];\n\n    prev = dat;\n    dat = VV(N+1, 2, INF, ll);\n    ll minit_zero = INF, minit_one = INF;\n    for(int i=1;i<=N;i++){\n      if(dp[to][i][1]!=INF&&minit_one==INF) minit_one = i;\n      if(dp[to][i][0] < 0&&minit_zero==INF) minit_zero = i;\n    }\n    ll x = min(minit_one, minit_zero);\n\n    for(int i=1;i<=N;i++){\n      //分離\n      if(i+x>N) continue;\n      if(x!=INF){\n        dat[i+x][0] = min(dat[i+x][0], prev[i][0]);\n        dat[i+x][1] = min(dat[i+x][1], prev[i][1]);\n      }\n    }\n    for(int i=1;i<=now_sz;i++){\n      for(int j=1;j<=sz[to];j++){\n        if(i+j>N) continue;\n        //連結\n        dat[i+j-1][0] = min(dat[i+j-1][0],\n          prev[i][0] + dp[to][j][0]);\n        dat[i+j-1][1] = min(dat[i+j-1][1],\n          prev[i][1] + dp[to][j][1]);\n      }\n    }\n\n  }\n  sz[now] = now_sz;\n  dp[now] = dat;\n}\n\nint main(int argc, char const *argv[]) {\n  ll n;std::cin >> n;\n  N = n;\n  num.resize(n);\n  re(i, n) scanf(\"%lld\", &num[i]);\n  for(int i=0;i<n-1;i++){\n    ll a, b;scanf(\"%lld %lld\", &a, &b);\n    a--, b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  //幾らかの正のみで構成される部分を切って正、正、、、負にする\n  // dp[i][j][k] i以下でその部分木でj回カットしている場合の最小値\n  // kは今のところ全ての要素が正かのフラグ\n  // 0 <= i <= 5000, 0 <= j <= 5000, k = 0 or\n\n  //計算量O();\n  dfs(0, -1);\n  for(int i=1;i<=N;i++){\n    if(dp[0][i][0]<0||dp[0][i][1]!=INF){\n      std::cout << i - 1 << '\\n';\n      return 0;\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<bitset>\n#include<stack>\n#include<memory>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n\n/*\ncout<<fixed<<setprecision(20);\ncin.tie(0);\nios::sync_with_stdio(false);\n*/\nconst llint mod=1000000007;\nconst llint big=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-15;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\nvector<vector<int>>go;\nvector<llint>A;\nint n;\npair<vector<llint>,llint>solve(int ter,int per){\n\t//bigは不可\n\tvector<llint>ans(1,A[ter]);\n\tint sar=0;\n\tfor(auto it:go[ter]){\n\t\tif(it==per){continue;}\n\t\tauto ret=solve(it,ter);\n\t\t\n\t\tsar+=ret.sec;\n\t\tvector<llint>iti(ans.size()+ret.fir.size()-1,big);\n\t\tfor(int i=0;i<ans.size();i++){\n\t\t\tfor(int j=0;j<ret.fir.size();j++){\n\t\t\t\tmineq(iti[i+j],ans[i]+ret.fir[j]);\n\t\t\t}\n\t\t}\n\t\tans=iti;\n\t}\n\tans.pub(0);\n\tif(A[ter]<0){sar=mod;}\n\tfor(int i=0;i<ans.size();i++){\n\t\tif(ans[i]<0){mineq(sar,i+1);break;}\n\t}\n\tfor(int i=sar+1;i<ans.size();i++){mineq(ans[i],0);}\n\t\n\t//for(int i=0;i<ans.size();i++){cerr<<ans[i]<<\" \";}cerr<<\"i=\"<<ter<<endl;\n\treturn mp(ans,sar);\n}\nint main(void) {\n\tint i;cin>>n;\n\tgo.res(n);A.res(n);\n\tfor(i=0;i<n;i++){cin>>A[i];}\n\tfor(i=1;i<n;i++){\n\t\tint x,y;cin>>x>>y;x--;y--;\n\t\tgo[x].pub(y);\n\t\tgo[y].pub(x);\n\t}\n\tauto ret=solve(0,-1);\n\tfor(i=0;i<ret.fir.size();i++){\n\t\tif(ret.fir[i]<0){mineq(ret.sec,i);break;}\n\t}\n\tcout<<ret.sec<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nconst int MAX = 5000;\nconst ll INF = 1e17;\n\nint N;\nll A[MAX];\n\nvector<int> G[MAX];\n\nint size[MAX];\nll dp[MAX][MAX][2];\n\nvoid calc(int v, int prev) {\n\tsize[v] = 1;\n\tint deg = 0;\n\tfor (int i = 0; i < MAX; i++) {\n\t\tdp[v][i][0] = INF;\n\t}\n\tfor (auto to : G[v]) if (to != prev) {\n\t\tcalc(to, v);\n\t\t++deg;\n\t}\n\tif (A[v] > 0) {\n\t\tdp[v][0][1] = 1;\n\t\tfor (auto to : G[v]) if (to != prev) {\n\t\t\tvector<int> pre(size[v]);\n\t\t\tfor (int i = 0; i < size[v]; i++) {\n\t\t\t\tpre[i] = dp[v][i][1];\n\t\t\t\tdp[v][i][1] = 0;\n\t\t\t}\n\t\t\tfor (int i = 0; i < size[v]; i++) if (pre[i]) {\n\t\t\t\tfor (int j = 0; j < size[to]; j++) if (dp[to][j][1]) {\n\t\t\t\t\tdp[v][i + j][1] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < size[to]; i++) if (dp[to][i][1] || dp[to][i][0] < 0) {\n\t\t\t\tfor (int j = 0; j < size[v]; j++) if (pre[j]) {\n\t\t\t\t\tdp[v][i + j + 1][1] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsize[v] += size[to];\n\t\t}\n\t}\n\tdp[v][0][0] = A[v];\n\tsize[v] = 1;\n\tfor (auto to : G[v]) if (to != prev) {\n\t\tvector<ll> pre(size[v]);\n\t\tfor (int i = 0; i < size[v]; i++) {\n\t\t\tpre[i] = dp[v][i][0];\n\t\t\tdp[v][i][0] = INF;\n\t\t}\n\t\tfor (int i = 0; i < size[v]; i++) if (pre[i] != INF) {\n\t\t\tfor (int j = 0; j < size[to]; j++) if (dp[to][j][0] != INF) {\n\t\t\t\tdp[v][i + j][0] = min(dp[v][i + j][0], pre[i] + dp[to][j][0]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < size[to]; i++) if (dp[to][i][1] || dp[to][i][0] < 0) {\n\t\t\tfor (int j = 0; j < size[v]; j++) if (pre[j] != INF) {\n\t\t\t\tdp[v][i + j + 1][0] = min(dp[v][i + j + 1][0], pre[j]);\n\t\t\t}\n\t\t}\n\t\tsize[v] += size[to];\n\t}\n}\n\nint main()\n{\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> A[i];\n\t}\n\tfor (int i = 0; i < N - 1; i++) {\n\t\tint u, v;\n\t\tcin >> u >> v; --u, --v;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tcalc(0, -1);\n\tfor (int i = 0; i < N; i++) if (dp[0][i][1] || dp[0][i][0] < 0) {\n\t\tcout << i << endl;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\n#define INF 1000000000000000000LL\nvector<int>pat[5555];\nbool flag[5555];\nll dat[5555];\nvector<ll>dfs(int node)\n{\n\tflag[node] = true;\n\tvector<ll>dp;\n\tdp.push_back(0);\n\tdp.push_back(0);\n\tll pos = 1;\n\tfor (int i = 0; i < pat[node].size(); i++)\n\t{\n\t\tint v = pat[node][i];\n\t\tif (flag[v])continue;\n\t\tvector<ll>z = dfs(v);\n\t\tvector<ll>ns;\n\t\tns.resize(z.size() + dp.size() - 1);\n\t\tfill(ns.begin(), ns.end(), INF);\n\t\tll miniadd = INF;\n\t\tfor (int j = 1; j < dp.size(); j++)\n\t\t{\n\t\t\tfor (int k = 1; k < z.size(); k++)\n\t\t\t{\n\t\t\t\tns[j + k - 1] = min(ns[j + k - 1], dp[j] + z[k]);\n\t\t\t\tif (z[k] < 0)\n\t\t\t\t{\n\t\t\t\t\tns[j + k] = min(ns[j + k], dp[j]);\n\t\t\t\t\tminiadd = min(miniadd, (ll)k);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (z[0] < 100000)ns[j + z[0]] = min(ns[j + z[0]], dp[j]);\n\t\t}\n\t\tpos = min(pos + z[0] - 1, pos + miniadd);\n\t\tdp = ns;\n\t}\n\tfor (int i = 1; i < dp.size(); i++)dp[i] += dat[node];\n\tdp[0] = INF;\n\tif (dat[node] > 0)dp[0] = pos;\n\t//printf(\"%d:   %d\\n\", node + 1, pos);\n\t//for (int i = 0; i < dp.size(); i++)printf(\"%lld \", dp[i]); printf(\"\\n\");\n\treturn dp;\n}\nint main()\n{\n\tint num;\n\tscanf(\"%d\", &num);\n\tfor (int i = 0; i < num; i++)scanf(\"%lld\", &dat[i]);\n\tfor (int i = 0; i < num - 1; i++)\n\t{\n\t\tint za, zb;\n\t\tscanf(\"%d%d\", &za, &zb);\n\t\tza--, zb--;\n\t\tpat[za].push_back(zb);\n\t\tpat[zb].push_back(za);\n\t}\n\tvector<ll>v = dfs(0);\n\tint mini = 10000000000;\n\tfor (int i = 1; i < v.size(); i++)if (v[i] < 0)mini = min(mini, i);\n\tif (v[0] < mini)mini = v[0];\n\tprintf(\"%d\\n\", mini - 1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n#define reps(i, n) for (int i = 1; i <= (int) (n); i++)\n#define all(x) (x).begin(), (x).end()\n#define uniq(x) (x).erase(unique(all(x)), (x).end())\n#define bit(n) (1LL << (n))\n#define cdiv(a, b) (((a) - 1) / (b) + 1)\n#define dump(x) cerr << #x \" = \" << (x) << endl\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing pint = pair<int, int>;\nusing vpint = vector<pint>;\ntemplate<typename T> using priority_queue_rev = priority_queue<T, vector<T>, greater<T>>;\nconstexpr double PI = 3.1415926535897932384626433832795028;\nconstexpr int DY[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nconstexpr int DX[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nint gcd(int a, int b) {\n    while (b) { swap(a %= b, b); }\n    return a;\n}\nint lcm(int a, int b) { return a / gcd(a, b) * b; }\nint sgn(int x) { return (x > 0) - (x < 0); }\ntemplate<typename T> void fin(T mes) {\n    cout << mes << endl;\n    exit(0);\n}\ntemplate<typename T, typename U> bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &rhs) {\n    os << \"(\" << rhs.first << \", \" << rhs.second << \")\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\nstruct setup {\n    static constexpr int PREC = 20;\n\n    setup() {\n        cout << fixed << setprecision(PREC);\n        cerr << fixed << setprecision(PREC);\n    };\n} setup;\n\nint N;\nint A[5500];\nint U[5500], V[5500];\nvint G[5500];\npair<vint, int> dfs(int cur, int par) {\n    vint x = {A[cur]};\n    int cut = 0;\n    for (int to:G[cur]) {\n        if (to == par) { continue; }\n        pair<vint, int> tmp = dfs(to, cur);\n        vint nxt = tmp.first;\n        int ccut = tmp.second;\n        vint y(x.size() + nxt.size(), LLONG_MAX);\n        if (ccut >= 0) { rep(i, x.size()) { y[i + ccut + 1] = x[i]; }}\n        rep(i, x.size()) {\n            rep(j, nxt.size()) {\n                chmin(y[i + j], x[i] + nxt[j]);\n                if (nxt[j] < 0) { chmin(y[i + j + 1], x[i]); }\n            }\n        }\n        x = y;\n        reps(i, x.size() - 1) { chmin(x[i], x[i - 1]); }\n        int pl = -1;\n        for (int i = nxt.size() - 1; i >= 0; i--) { if (nxt[i] < 0) { pl = i; }}\n        assert(pl >= 0);\n        if (ccut >= 0) { cut += min(ccut, pl + 1); }\n        else { cut += pl + 1; }\n    }\n    if (A[cur] < 0) { cut = -1; }\n    return {x, cut};\n}\n\nsigned main() {\n    cin >> N;\n    rep(i, N) { cin >> A[i]; }\n    rep(i, N - 1) {\n        cin >> U[i] >> V[i];\n        U[i]--, V[i]--;\n        G[U[i]].push_back(V[i]), G[V[i]].push_back(U[i]);\n    }\n    pair<vint, int> res = dfs(0, -1);\n    int ans = N;\n    if (A[0] > 0) { ans = res.second; }\n    rep(i, res.first.size()) { if (res.first[i] < 0) { chmin(ans, i); }}\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "# include \"bits/stdc++.h\"\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconst double PI = acos(-1);\ntemplate<class T>constexpr T INF() { return ::std::numeric_limits<T>::max(); }\ntemplate<class T>constexpr T HINF() { return INF<T>() / 2; }\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\ntypedef pair<LL, LL> pii;\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\nint popcnt(unsigned long long n) { int cnt = 0; for (int i = 0; i < 64; i++)if ((n >> i) & 1)cnt++; return cnt; }\nint d_sum(LL n) { int ret = 0; while (n > 0) { ret += n % 10; n /= 10; }return ret; }\nint d_cnt(LL n) { int ret = 0; while (n > 0) { ret++; n /= 10; }return ret; }\nLL gcd(LL a, LL b) { if (b == 0)return a; return gcd(b, a%b); };\nLL lcm(LL a, LL b) { LL g = gcd(a, b); return a / g*b; };\n# define ALL(qpqpq)           (qpqpq).begin(),(qpqpq).end()\n# define UNIQUE(wpwpw)        sort(ALL((wpwpw)));(wpwpw).erase(unique(ALL((wpwpw))),(wpwpw).end())\n# define LOWER(epepe)         transform(ALL((epepe)),(epepe).begin(),TL<char>)\n# define UPPER(rprpr)         transform(ALL((rprpr)),(rprpr).begin(),TU<char>)\n# define FOR(i,tptpt,ypypy)   for(LL i=(tptpt);i<(ypypy);i++)\n# define REP(i,upupu)         FOR(i,0,upupu)\n# define INIT                 std::ios::sync_with_stdio(false);std::cin.tie(0)\n\nint n;\nint a[5050];\nvector<int> g[5050];\nLL dp[5050][5050][2];\nint visited[5050];\nLL dp2[5050][2];\nint u, v;\n\nvoid dfs(int cur, int pre){\n    visited[cur] = 1;\n    REP(i, (int)g[cur].size()){\n        if(g[cur][i] == pre)continue;\n        dfs(g[cur][i], cur);\n        visited[cur] += visited[g[cur][i]];\n    }\n\n    REP(j, 5050)dp2[j][0] = dp2[j][1] = HINF<LL>();\n\n    dp2[0][0] = a[cur];\n    if(a[cur] > 0)dp2[0][1] = a[cur];\n\n    int chcnt = 0;\n    REP(i, (int)g[cur].size()){\n        if(g[cur][i] == pre)continue;\n        for(int j = chcnt;j >= 0;j--){\n            LL tmp0 = dp2[j][0], tmp1 = dp2[j][1];\n            dp2[j][0] = dp2[j][1] = HINF<LL>();\n            for(int k = 0;k <= visited[g[cur][i]];k++){\n                dp2[j + k][0] = min(dp2[j + k][0], tmp0 + dp[g[cur][i]][k][0]);\n                if(dp[g[cur][i]][k][0] < 0 || dp[g[cur][i]][k][1] < HINF<LL>())dp2[j + k + 1][0] = min(dp2[j + k + 1][0], tmp0);\n                if(a[cur] > 0){\n                    dp2[j + k][1] = min(dp2[j + k][1], tmp1 + dp[g[cur][i]][k][1]);\n                    if(dp[g[cur][i]][k][0] < 0 || dp[g[cur][i]][k][1] < HINF<LL>())dp2[j + k + 1][1] = min(dp2[j + k + 1][1], tmp1);\n                }\n            }\n        }\n        chcnt += visited[g[cur][i]];\n    }\n    for(int j = 0;j < visited[cur];j++){\n        cout << cur << \" \" << j << \":\" << dp[cur][j][0] << \" \" << dp[cur][j][1] << endl;\n        dp[cur][j][0] = dp2[j][0];\n        dp[cur][j][1] = dp2[j][1];\n    }\n}\n\nint main(){\n    cin >> n;\n    REP(i, n)cin >> a[i];\n    REP(i, n - 1){\n        cin >> u >> v;\n        u--, v--;\n        g[u].emplace_back(v);\n        g[v].emplace_back(u);\n    }\n    REP(i, 5050)REP(j, 5050)REP(k, 2)dp[i][j][k] = HINF<LL>();\n    dfs(0, -1);\n\n    LL ans = n - 1;\n    REP(i, n){\n        cout << \"#\" << i << \":\" << dp[0][i][0] << \" \" << dp[0][i][1] << endl; \n        if(dp[0][i][0] < 0)ans = min(ans, i);\n        if(dp[0][i][1] < HINF<LL>())ans = min(ans, i);\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <fstream>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <complex>\n#include <iomanip>\n#include <stdio.h>\n#include <string.h>\n#include <random>\n#include <functional>\n\nusing std::cin;\nusing std::cout;\nusing std::cerr;\nusing std::endl;\n\nusing std::map;\nusing std::set;\nusing std::bitset;\nusing std::vector;\nusing std::string;\nusing std::multimap;\nusing std::multiset;\nusing std::deque;\nusing std::queue;\nusing std::stack;\nusing std::pair;\nusing std::iterator;\n\nusing std::sort;\nusing std::stable_sort;\nusing std::reverse;\nusing std::max_element;\nusing std::min_element;\nusing std::unique;\nusing std::ios_base;\nusing std::swap;\nusing std::fill;\n\nusing std::setprecision;\nusing std::fixed;\n\nlong long min(long long a, long long b) {return a < b ? a : b;}\nlong long min(int a, long long b) {return a < b ? a : b;}\nlong long min(long long a, int b) {return a < b ? a : b;}\nlong long min(int a, int b) {return a < b ? a : b;}\n\nlong long max(long long a, long long b) {return a > b ? a : b;}\nlong long max(int a, long long b) {return a > b ? a : b;}\nlong long max(long long a, int b) {return a > b ? a : b;}\nlong long max(int a, int b) {return a > b ? a : b;}\n\n#define int long long\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<long long> vl;\ntypedef string S;\n\n#define F(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define fi first\n#define se second\n#define re return\n#define all(x) (x).begin(), (x).end()\n\nconst long long INF = 1e18;\nconst int N = 10100;\nconst int MOD = 1e9 + 7;\nconst double eps = 1e-8;\n\nint n;\nint a[N];\nvector<int> graph[N];\nint dp[2][N][N / 2];\nint last_dinamics[N];\nint last_state[N];\nint tmp = 0;\n\nvoid Merge(int p1, int p2)\n{\n    for (int a = 0; a <= last_state[p1]; a++)\n    {\n        for (int b = 0; b <= last_state[p2]; b++)\n        {\n            dp[0][tmp][a + b] = min(dp[0][tmp][a + b], dp[0][p1][a] + dp[0][p2][b]);\n            if (dp[0][p2][b] < INF) dp[0][tmp][a + b + 1] = min(dp[0][tmp][a + b + 1], dp[0][p1][a]);\n            if (dp[1][p2][b] < 0) dp[0][tmp][a + b + 1] = min(dp[0][tmp][a + b + 1], dp[0][p1][a]);\n            dp[1][tmp][a + b] = min(dp[1][tmp][a + b], min(dp[0][p1][a], dp[1][p1][a]) + min(dp[0][p2][b], dp[1][p2][b]));\n            if (dp[0][p2][b] < INF) dp[1][tmp][a + b + 1] = min(dp[0][tmp][a + b + 1], min(dp[0][p1][a], dp[1][p1][a]));\n            if (dp[1][p2][b] < 0) dp[1][tmp][a + b + 1] = min(dp[0][tmp][a + b + 1], min(dp[0][p1][a], dp[1][p1][a]));\n        }\n    }\n    last_state[tmp] = last_state[p1] + last_state[p2] + 1;\n}\n\nvoid dfs(int v, int parent)\n{\n    int merge1 = tmp;\n    dp[0][tmp][0] = 0, dp[1][tmp][0] = 0;\n    tmp++;\n    for (auto u : graph[v]) if (u != parent)\n    {\n        dfs(u, v);\n        int merge2 = last_dinamics[u];\n        Merge(merge1, merge2);\n        merge1 = tmp;\n        tmp++;\n    }\n    tmp--;\n    for (int i = 0; i < n + 100; i++)\n    {\n        dp[1][tmp][i] = min(dp[1][tmp][i] + a[v], INF);\n        dp[0][tmp][i] = min(dp[0][tmp][i] + a[v], INF);\n    }\n    if (a[v] < 0)\n    {\n        for (int i = 0; i < n + 100; i++) dp[0][tmp][i] = INF;\n    }\n    last_dinamics[v] = tmp;\n    tmp++;\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n;\n    for (int i = 0; i < n + 100; i++)\n    {\n        for (int j = 0; j < n + 100; j++)\n        {\n            dp[0][i][j] = INF, dp[1][i][j] = INF;\n        }\n    }\n    for (int i = 0; i < n; i++)\n    {\n        cin >> a[i];\n    }\n    for (int i = 0; i + 1 < n; i++)\n    {\n        int v, u;\n        cin >> v >> u;\n        v--, u--;\n        graph[v].push_back(u);\n        graph[u].push_back(v);\n    }\n    dfs(0, -1);\n    long long ans = n - 1;\n    for (int i = 0; i < n - 1; i++)\n    {\n        cout << dp[1][tmp - 1][i] << \" \" << dp[0][tmp - 1][i] << \"\\n\";\n        if (dp[1][tmp - 1][i] < 0) ans = min(ans, i);\n        if (dp[0][tmp - 1][i] < INF) ans = min(ans, i);\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define ALL(A) A.begin(),A.end()\n#define RALL(A) A.rbegin(),A.rend()\ntypedef long long LL;\ntypedef pair<int,int> P;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\nconst LL mod=1000000007;\nconst LL LINF=1LL<<60;\nconst int INF=1<<30;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\n\nLL a[5001];\nLL dp1[5001][5001][2];\nLL d[5001];\nvector<int> G[5001];\n\nvoid rec(int u,int v){\n    d[u] = 1;\n    for(auto g:G[u]){\n        if(g==v) continue;\n        rec(g,u);\n        d[u] += d[g];\n    }\n    int num = 0;\n    vector<vector<LL>> dp(d[u]+1,vector<LL> (2,LINF));\n    dp[0][0] = a[u];\n    if(a[u] > 0) dp[0][1] = a[u];\n    for(auto g:G[u]){\n        if(g==v) continue;\n        for (int j = num; j >= 0; j--) {\n            LL t0 = dp[j][0], t1 = dp[j][1];\n            for (int k = 0; k <= d[g]; k++) {\n                chmin(dp[j+k][0],dp1[g][k][0]+t0);\n                if(dp1[g][k][0] < 0 || dp1[g][k][1] != LINF) chmin(dp[j+k+1][0],t0);\n                if(a[u]>0){\n                    chmin(dp[j+k][1],dp1[g][k][1]+t1);\n                    if(dp1[g][k][0] < 0 || dp1[g][k][1] != LINF) chmin(dp[j+k+1][1],t1);\n                }\n            }\n        }\n        num += d[g];\n    }\n    for (int i = 0; i <= d[u]; i++) {\n        dp1[u][i][0] = dp[i][0];\n        dp1[u][i][1] = dp[i][1];\n    }\n}\n\nint main(){\n    int n;cin >> n;\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n    for (int i = 0; i < n-1; i++) {\n        int x,y;cin >> x >> y;\n        x--,y--;\n        G[x].pb(y);\n        G[y].pb(x);\n    }\n    for (int i = 0; i < 5001; i++) {\n        for (int j = 0; j < 5001; j++) {\n            for (int k = 0; k < 2; k++) {\n                dp1[i][j][k] = LINF;\n            }\n        }\n    }\n    rec(0,0);\n    for (int i = 0; i <= n; i++) {\n        if(dp1[0][i][0] < 0){\n            cout << i << endl;\n            return 0;\n        }\n        if(dp1[0][i][1] != LINF){\n            cout << i << endl;\n            return 0;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nconst LL INF = 0x3f3f3f3f3f3f3f3fLL;\nconst int MAXN = 5011;\nint N;\nLL A[MAXN];\nVI G[MAXN];\nLL dp[MAXN][MAXN][2];\nLL nxt[MAXN][2];\nint par[MAXN];\nint sz[MAXN];\n\nVI ord;\n\nvoid MAIN() {\n    scanf(\"%d\", &N);\n    REP (i, N) scanf(\"%lld\", A+i);\n    REP (i, N-1) {\n\tint x, y;\n\tscanf(\"%d%d\", &x, &y);\n\tx--; y--;\n\tG[x].push_back(y);\n\tG[y].push_back(x);\n    }\n\n    ord.reserve(N);\n    ord.push_back(0);\n    REP (i_, N) {\n\tint v = ord[i_];\n\tEACH (e, G[v]) if (*e != par[v]) {\n\t    par[*e] = v;\n\t    ord.push_back(*e);\n\t}\n    }\n\n//    REP (i_, N) {\n//\tint v = ord[N-1-i_];\n//\tsz[v] = 1;\n//\tEACH (e, G[v]) if (*e != par[v]) {\n//\t    sz[v] += sz[*e];\n//\t}\n//    }\n\n    memset(dp, 0x3f, sizeof dp);\n\n    REP (i_, N) {\n\tint v = ord[N-1-i_];\n\tif (A[v] < 0) {\n\t    dp[v][0][1] = A[v];\n\t} else {\n\t    dp[v][0][0] = A[v];\n\t}\n\n\tsz[v] = 1;\n\tEACH (e, G[v]) if (*e != par[v]) {\n\t    memset(nxt, 0x3f, sizeof nxt);\n\n\t    REP (i, sz[v]) REP (a, 2) if (dp[v][i][a] < INF) {\n\t\tREP (j, sz[*e]) {\n\t\t    REP (b, 2) if (dp[*e][j][b] < INF) {\n\t\t\tamin(nxt[i+j][a|b], dp[v][i][a] + dp[*e][j][b]);\n\t\t    }\n\n\t\t    if (dp[*e][j][0] < INF || dp[*e][j][1] < 0) {\n\t\t\tamin(nxt[i+j+1][a], dp[v][i][a]);\n\t\t    }\n\t\t}\n\t    }\n\n\t    sz[v] += sz[*e];\n\t    REP (i, sz[v]) REP (a, 2) dp[v][i][a] = nxt[i][a];\n\t}\n    }\n\n    int ans = N;\n    REP (i, N) {\n\tif (dp[0][i][0] < INF || dp[0][i][1] < 0) {\n\t    ans = i;\n\t    break;\n\t}\n    }\n    printf(\"%d\\n\", ans);\n\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FAST ios_base::sync_with_stdio(false); cin.tie(0);\n#define pb push_back\n#define eb emplace_back\n#define ins insert\n#define f first\n#define s second\n#define cbr cerr << \"hi\\n\"\n#define mmst(x, v) memset((x), v, sizeof ((x)))\n#define siz(x) ll(x.size())\n#define all(x) (x).begin(), (x).end()\n#define lbd(x,y) (lower_bound(all(x),y)-x.begin())\n#define ubd(x,y) (upper_bound(all(x),y)-x.begin())\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());    //can be used by calling rng() or shuffle(A, A+n, rng)\ninline long long rand(long long x, long long y) { return (rng() % (y+1-x)) + x; } //inclusivesss\nstring inline to_string(char c) {string s(1,c);return s;} template<typename T> inline T gcd(T a,T b){ return a==0?llabs(b):gcd(b%a,a); }\n\ntypedef long long ll; \ntypedef long double ld;\n#define FOR(i,s,e) for(ll i=s;i<=ll(e);++i)\n#define DEC(i,s,e) for(ll i=s;i>=ll(e);--i)\ntypedef pair<ll,ll>pi; typedef pair<ll,pi>spi; typedef pair<pi,pi>dpi;\n\n#define LLINF ((long long)1e18)\n#define INF int(1e9+1e6)\n#define MAXN (5006)\nll n,A[MAXN],dp[MAXN][MAXN][2],sz[MAXN];// if 0 then max, 1 then min\nvector<int>v[MAXN];\nvoid dfs(ll x,ll p){\n\tsz[x]=1;\n\tdp[x][0][1]=A[x];\n\tfor(auto i:v[x]) if(i^p) dfs(i,x), sz[x]+=sz[i];\n\tll cur = 1;\n\tif(A[x]>0)dp[x][0][0]=A[x];\n\tfor(auto i:v[x]) if(i^p) {\n\t\tcur += sz[i];\n\t\tDEC(j,cur,0){\n\t\t\tif(dp[x][j][1]<LLINF) dp[x][j][1] += dp[i][0][1];\n\t\t\tdp[x][j][0] += dp[i][0][0], dp[x][j][0]=min(dp[x][j][0],LLINF);\n\t\t\tFOR(k,1,min(j,sz[i])){\n\t\t\t\tdp[x][j][1]=min(dp[x][j][1],dp[x][j-k][1]+dp[i][k][1]);\n\t\t\t\tif(dp[i][k-1][0]!=LLINF) dp[x][j][1]=min(dp[x][j][1],dp[x][j-k][1]);\n\t\t\t\tdp[x][j][0]=min(dp[x][j][0],dp[x][j-k][0]+dp[i][k][0]);\n\t\t\t\tif(dp[i][k-1][1] < 0) dp[x][j][0]=min(dp[x][j][0],dp[x][j-k][0]);\n\t\t\t}\n\t\t}\n\t}\n\t// if(A[x]>0){\n\t\t// dp[x][0][0]=A[x];\n\t\t// cur=1;\n\t\t// for(auto i:v[x]) if(i^p) {\n\t\t\t// cur+=sz[i];\n\t\t\t// DEC(j,cur,0){\n\t\t\t\t// dp[x][j][0] += dp[i][0][0], dp[x][j][0]=min(dp[x][j][0],LLINF);\n\t\t\t\t// FOR(k,1,min(j,sz[i])){\n\t\t\t\t\t// dp[x][j][0]=min(dp[x][j][0],dp[x][j-k][0]+dp[i][k][0]);\n\t\t\t\t\t// if(dp[i][k-1][1] < 0) dp[x][j][0]=min(dp[x][j][0],dp[x][j-k][0]);\n\t\t\t\t// }\n\t\t\t// }\n\t\t// }\n\t// }\n}\nint main(){\n\tFAST\n\tcin>>n;\n\tFOR(i,1,n)cin>>A[i];\n\tFOR(i,2,n){\n\t\tll a,b;cin>>a>>b;\n\t\tv[a].eb(b),v[b].eb(a);\n\t}\n\tFOR(i,0,MAXN-1)FOR(j,0,MAXN-1)FOR(b,0,1)dp[i][j][b]=LLINF;\n\tdfs(1,1);\n\tll ans = n-1;\n\tFOR(k,0,n-1) if(dp[1][k][1] < 0) ans = min(ans, k);\n\tFOR(k,0,n-1) if(dp[1][k][0] != LLINF) ans = min(ans, k);\n\tcout<<ans<<'\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//注意点\n//Tは3つの値を持つ構造\n//だがワイルドカードとしても使っている\n#include <bits/stdc++.h>\nusing namespace std;\n//@起動時\nstruct initon {\n    initon() {\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.setf(ios::fixed);\n        cout.precision(16);\n    };\n} __initon;\n\n//@必須構造\nstruct T {\n    int f, s, t;\n    T() { f = -1, s = -1, t = -1; }\n    T(int f, int s, int t) : f(f), s(s), t(t) {}\n    bool operator<(const T &r) const {\n        return f != r.f ? f < r.f : s != r.s ? s < r.s : t < r.t;\n        //return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 大きい順\n    }\n    bool operator>(const T &r) const {\n        return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t;\n        //return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 小さい順\n    }\n    int operator[](int i) {\n        assert(i < 3);\n        return i == 0 ? f : i == 1 ? s : t;\n    }\n};\n\n//@マクロ省略系 型,構造\n\n#define int long long\n#define ll long long\n#define double long double\n#define ull unsigned long long\nusing dou = double;\nusing itn = int;\nusing str = string;\nusing bo= bool;\nusing P = pair<int, int>;\n#define F first\n#define S second\n#define vec vector\n#define con continue\n#define bre break\n#define brk break\n#define is ==\n#define rs resize\n\n//マクロ省略系 コンテナ\nusing vi = vector<int>;\n#define vvi(a, b, c) vec<vi> a(b,vi(c))\nusing vb = vector<bool>;\n#define vvb(a, b, c) vec<vb> a(b,vb(c))\nusing vs = vector<string>;\n#define vvs(a, b, c) vec<vs> a(b,vs(c))\nusing vl = vector<ll>;\n#define vvl(a, b, c) vec<vl> a(b,vl(c))\nusing vd = vector<double>;\n#define vvd(a, b, c) vec<vd> a(b,vd(c))\nusing vc=vector<char>;\n#define vvc(a, b, c) vec<vc> a(b,vc(c))\nusing vp = vector<P>;\n#define vvp(a, b, c) vec<vp> a(b,vp(c))\nusing vt = vector<T>;\n#define vvt(a, b, c) vec<vt> a(b,vt(c))\n#define v3i(a, b, c, d) vector<vector<vi>> a(b, vector<vi>(c, vi(d)))\n#define v3d(a, b, c, d) vector<vector<vd>> a(b, vector<vd>(c, vd(d)))\n#define v3m(a, b, c, d) vector<vector<vm>> a(b, vector<vm>(c, vm(d)))\n#define PQ priority_queue<ll, vector<ll>, greater<ll> >\nusing seti = set<int>;\n#define uset unordered_set\n#define mset multiset\n#define umap unordered_map\n#define mmap multimap\n\n//マクロ 繰り返し\n#define _overloadrep(_1, _2, _3, name, ...) name\n# define _rep(i, n) for(int i = 0; i < n ; i++)\n#define repi(i, m, n) for(int i = m; i < n ; i++)\n#define rep(...) _overloadrep(__VA_ARGS__,repi,_rep,)(__VA_ARGS__)\n#define _rer(i, n) for(int i = n; i >= 0 ; i--)\n#define reri(i, m, n) for(int i = m; i >= n ; i--)\n#define rer(...) _overloadrep(__VA_ARGS__,reri,_rer,)(__VA_ARGS__)\n#define fora(a, b) for(auto&& a : b)\n#define forg(gi, ve) if (ve.size())for (int gi = 0, f = ve[gi].from, t = ve[gi].to, c = ve[gi].cost; gi < ve.size(); gi++,f = ve[gi].from, t = ve[gi].to, c = ve[gi].cost)\n\n//マクロ 定数\n#define k4 10101\n#define k5 101010\n#define k6 1010101\n#define k7 10101010\nconst int inf = (int) 1e9 + 100;\nconst ll linf = (ll) 1e18 + 100;\nconst double eps = 1e-9;\nconst int y4[] = {-1, 1, 0, 0};\nconst int x4[] = {0, 0, -1, 1};\nconst int y8[] = {0, 1, 0, -1, -1, 1, 1, -1};\nconst int x8[] = {1, 0, -1, 0, 1, -1, 1, -1};\n\n//マクロ省略形 関数等\n#define arsz(a) (sizeof(a)/sizeof(a[0]))\n#define sz(a) (a.size())\n#define mp make_pair\n#define pb push_back\n#define pf push_front\n#define eb emplace_back\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\n//@拡張系 こう出来るべきというもの\n\n//埋め込み 存在を意識せずに機能を増やされているもの\n// 境界チェック付きvector\nnamespace std_vector_bounds_checking {\n    using namespace std;\n    template<class T, class A = std::allocator<T>> struct vector : std::vector<T, A> {\n        using std::vector<T, A>::vector;\n        typename std::vector<T>::reference operator[](typename std::vector<T>::size_type n) {\n            return this->at(n);\n        }\n    };\n}\nnamespace std {\n    template<> class hash<std::pair<signed, signed>> {\n    public:\n        size_t operator()(const std::pair<signed, signed> &x) const {\n            return hash<ll>()(((ll) x.first << 32) + x.second);\n        }\n    };\n    template<> class hash<std::pair<ll, ll>> {\n    public:\n        size_t operator()(const std::pair<ll, ll> &x) const {\n            return hash<ll>()(((ll) x.first << 32) + x.second);\n        }\n    };\n}\ntemplate<typename T> istream &operator>>(istream &iss, vector<T> &vec) {\n    for (T &x: vec) iss >> x;\n    return iss;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, vector <T> &vec) {\n    for (int i = 0; i < vec.size(); i++)os << vec[i] << (i + 1 == vec.size() ? \"\" : \" \");\n    return os;\n}\ntemplate<typename V, typename H> void resize(vector<V> &vec, const H head) {  //再帰の終端。 可変長templateの長さが 0 になるとこっちが呼ばれる。\n    vec.resize(head);\n}\ntemplate<typename V, typename H, typename ... T> void resize(vector<V> &vec, const H &head, const T ... tail) {\n    vec.resize(head);\n    for (auto &v: vec) resize(v, tail...);\n}\ntemplate<class T> T pop(set<T> &set) {\n    T res = *set.begin();\n    set.erase(set.find(res));\n    return res;\n}\ntemplate<class T> T pop(mset<T> &set) {\n    T res = *set.begin();\n    set.erase(set.find(res));\n    return res;\n}\ntemplate<class T> T popBack(set<T> &set) {\n    T res = *set.rbegin();\n    set.erase(set.find(res));\n    return res;\n}\ntemplate<class T> T popBack(mset<T> &set) {\n    T res = *set.rbegin();\n    set.erase(set.find(res));\n    return res;\n}\ntemplate<class T> inline void sort(vector<T> &a) { sort(a.begin(), a.end()); };\ntemplate<class T> inline void rsort(vector<T> &a) { sort(a.begin(), a.end(), greater<T>()); };\ntemplate<class T> inline void sort(vector<T> &a, int len) { sort(a.begin(), a.begin() + len); };\ntemplate<class T> inline void rsort(vector<T> &a, int len) { sort(a.begin(), a.begin() + len, greater<T>()); };\ntemplate<class T> inline void sort2(vector<vector<T>> &a) { for (int i = 0, n = a.size(); i < n; i++)sort(a[i]); }\ntemplate<class T> inline void rsort2(vector<vector<T>> &a) { for (int i = 0, n = a.size(); i < n; i++)rsort(a[i]); }\ntemplate<typename A, size_t N, typename T> void fill(A (&a)[N], const T &v) { rep(i, N)a[i] = v; }\ntemplate<typename A, size_t N, size_t O, typename T> void fill(A (&a)[N][O], const T &v) { rep(i, N)rep(j, O)a[i][j] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, typename T> void fill(A (&a)[N][O][P], const T &v) { rep(i, N)rep(j, O)rep(k, P)a[i][j][k] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, typename T> void fill(A (&a)[N][O][P][Q], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)a[i][j][k][l] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, typename T> void fill(A (&a)[N][O][P][Q][R], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)a[i][j][k][l][m] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S, typename T> void fill(A (&a)[N][O][P][Q][R][S], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)rep(n, S)a[i][j][k][l][m][n] = v; }\ntemplate<typename V, typename T> void fill(V &x, const T &val) { x = val; }\ntemplate<typename V, typename T> void fill(vector<V> &vect, const T &val) { for (auto &v: vect) fill(v, val); }\n//@汎用便利関数 入力\ntemplate<typename T = int> T in() {\n    T x;\n    cin >> x;\n    return (x);\n}\nstring sin() { return in<string>(); }\ndouble din() { return in<double>(); }\nll lin() { return in<ll>(); }\n#define na(a, n) rep(i,n) cin >> a[i];\n#define nad(a, n) rep(i,n) cin >> a[i], a[i]--;\n#define na3(a, b, c, n) rep(i, n)cin >> a[i] >> b[i] >> c[i];\n#define add2(a, b, n) rep(i, n)a.pb(in()),b.pb(in());\n#define add2d(a, b, n) rep(i, n)a.pb(in()-1),b.pb(in()-1);\n#define add3(a, b, c, n) rep(i, n)a.pb(in()),b.pb(in()),c.pb(in());\n#define add3d(a, b, c, n) rep(i, n)a.pb(in()-1),b.pb(in()-1),c.pb(in());\n#define na2(a, b, n) rep(i, n)cin >> a[i] >> b[i];\n#define nt(a, h, w) rep(hi,h)rep(wi,w) cin >> a[hi][wi];\n#define ntd(a, h, w) rep(hi,h)rep(wi,w) cin >> a[hi][wi], a[hi][wi]--;\n#define ntp(a, h, w) fill(a,'#');rep(hi,1,h+1)rep(wi,1,w+1) cin >> a[hi][wi];\n#define addn(a, n) a.resize(n);na(a,n);\n#define addnd(a, n) a.resize(n);na(a,n);rep(i,n)a[i]--;\n\n\n//汎用便利関数 出力\ntemplate<class T> void out(T x) { typeid(x) == typeid(double) ? cout << fixed << setprecision(10) << x << endl : cout << x << endl; }\n//デバッグ\n#define debug(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n';\n//よく使うクラス、構造体\nclass UnionFind {\npublic:\n    vi par, rank, sizes;\n    int n, trees;\n    UnionFind(int n) : n(n), trees(n) {\n        par.resize(n), rank.resize(n), sizes.resize(n);\n        rep(i, n)par[i] = i, sizes[i] = 1;\n    }\n    int root(int x) {\n        if (par[x] == x)return x;\n        else return par[x] = root(par[x]);\n    }\n    int find(int x) { return root(x); }\n    void unite(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y)return;\n        if (rank[x] < rank[y])swap(x, y);\n        trees--;\n        par[y] = x;\n        sizes[x] += sizes[y];\n        if (rank[x] == rank[y])rank[x]++;\n    }\n    bool same(int x, int y) { return root(x) == root(y); }\n    int size(int x) { return sizes[root(x)]; }\n    //順不同 umapなので\n    vec<vi> sets() {\n        vec<vi> res(trees);\n        umap<int, vi> map;\n        rep(i, n) map[root(i)].push_back(i);\n        int i = 0;\n        for (auto &&p:map) {\n            int r = p.F;\n            res[i].push_back(r);\n            for (auto &&v:p.S) {\n                if (r == v)continue;\n                res[i].push_back(v);\n            }\n            i++;\n        }\n        return res;\n    }\n};\n\n//MOD関連\nll MOD = (int) 1e9 + 7;\nint mpow(int v, ll a) {\n    ll x = v, n = a, res = 1;\n    while (n) {\n        if (n & 1)res = (res * x) % MOD;\n        x = (x * x) % MOD;\n        n >>= 1;\n    }\n    return res;\n}\nclass mint {\nprivate:\n    ll v;\npublic:\n    static ll mod(ll a) { return (a % MOD + MOD) % MOD; }\n    mint(ll a = 0) { this->v = mod(a); };\n    mint(const mint &a) { v = a.v; }\n    mint operator+(const mint &a) { return mint(v + a.v); }\n    mint operator+(const ll a) { return mint(v + a % MOD); }\n    mint operator+(const signed a) { return mint(v + a % MOD); }\n    friend mint operator+(const ll a, const mint &b) { return mint(a % MOD + b.v); }\n    void operator+=(const mint &a) { v = (v + a.v) % MOD; }\n    void operator+=(const ll a) { v = mod(v + a % MOD); }\n    void operator+=(const signed a) { v = mod(v + a % MOD); }\n    friend void operator+=(ll &a, const mint &b) { a = mod(a % MOD + b.v); }\n    mint operator-(const mint &a) { return mint(v - a.v); }\n    mint operator-(const ll a) { return mint(v - a % MOD); }\n    mint operator-(const signed a) { return mint(v - a % MOD); }\n    friend mint operator-(const ll a, const mint &b) { return mint(a % MOD - b.v); }\n    void operator-=(const mint &a) { v = mod(v - a.v); }\n    void operator-=(const ll a) { v = mod(v - a % MOD); }\n    void operator-=(const signed a) { v = mod(v - a % MOD); }\n    friend void operator-=(ll &a, const mint &b) { a = mod(a % MOD - b.v); }\n    mint operator*(const mint &a) { return mint(v * a.v); }\n    mint operator*(const ll a) { return mint(v * (a % MOD)); }\n    mint operator*(const signed a) { return mint(v * (a % MOD)); }\n    friend mint operator*(const ll a, const mint &b) { return mint(a % MOD * b.v); }\n    void operator*=(const mint &a) { v = (v * a.v) % MOD; }\n    void operator*=(const ll a) { v = mod(v * (a % MOD)); }\n    void operator*=(const signed a) { v = mod(v * (a % MOD)); }\n    friend void operator*=(ll &a, const mint &b) { a = mod(a % MOD * b.v); }\n    mint operator/(const mint &a);\n    mint operator/(const ll a);\n    mint operator/(const signed a);\n    friend mint operator/(const ll a, const mint &b);\n    void operator/=(const mint &a);\n    void operator/=(const ll a);\n    void operator/=(const signed a);\n    friend void operator/=(ll &a, const mint &b);\n    mint operator^(const mint &a) { return mpow(v, a.v); };\n    mint operator^(const ll a) { return mpow(v, a); };\n    mint operator^(const signed a) { return mpow(v, a); };\n    friend mint operator^(const ll a, const mint &b) { return mpow(a, b.v); };\n    void operator^=(const mint &a) { v = mpow(v, a.v); }\n    void operator^=(const ll a) { v = mpow(v, a); }\n    void operator^=(const signed a) { v = mpow(v, a); }\n    //単項演算子\n    mint operator+() { return *this; }\n    mint operator++() {\n        v++;\n        return *this;\n    }\n    mint operator++(signed d) {\n        mint res = *this;\n        v++;\n        return res;\n    }\n    mint operator-() { return operator*(-1); }\n    mint operator--() {\n        v++;\n        return *this;\n    }\n    void operator--(signed d) {\n        mint res = *this;\n        v++;\n    }\n    bool operator==(mint &a) { return v == a.v; }\n    bool operator==(signed a) { return v == a; }\n    friend bool operator==(signed a, mint &b) { return a == b.v; }\n    bool operator!=(mint &a) { return v != a.v; }\n    bool operator!=(signed a) { return v != a; }\n    friend bool operator!=(signed a, mint &b) { return a != b.v; }\n    operator int() { return v; }\n};\nconst int setModMax = 510000;\nmint fac[setModMax], finv[setModMax], inv[setModMax];\nvoid setMod() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < setModMax; i++) {\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n\nmint minv(ll a) {\n    if (fac[0] == 0)setMod();\n    if (a < setModMax) return inv[a];\n    a %= MOD;\n    ll b = MOD, x = 1, y = 0;\n    while (b) {\n        ll t = a / b;\n        a -= t * b;\n        swap(a, b);\n        x -= t * y;\n        swap(x, y);\n    }\n    return (x % MOD + MOD) % MOD;\n}\nmint mint::operator/(const mint &a) { return mint(v * minv(a.v)); }\nmint mint::operator/(const ll a) { return mint(v * minv(a)); }\nmint mint::operator/(const signed a) { return mint(v * minv(a)); }\nmint operator/(const ll a, const mint &b) { return mint(a % MOD * minv(b.v)); }\nvoid mint::operator/=(const mint &a) { v = (v * minv(a.v)) % MOD; }\nvoid mint::operator/=(const ll a) { v = mod(v * minv(a)); }\nvoid mint::operator/=(const signed a) { v = mod(v * minv(a)); }\nvoid operator/=(ll &a, const mint &b) { a = mint::mod(a % MOD * minv(b.v)); }\nusing vm=vector<mint>;\n#define vvm(a, b, c) vec<vm> a(b,vm(c))\nbool isPrime[4010101];\nvi primes;\n\nvoid setPrime() {\n    fill(isPrime, true);\n    int len = sizeof(isPrime) / sizeof(isPrime[0]);\n    isPrime[0] = isPrime[1] = false;\n    for (int i = 2; i <= sqrt(len) + 5; ++i) {\n        if (!isPrime[i])continue;\n        for (int j = 2; i * j < len; ++j) {\n            isPrime[i * j] = false;\n        }\n    }\n    rep(i, len)if (isPrime[i])primes.pb(i);\n}\n\nmint com(ll n, ll r) {\n    if (n < r || n < 0 || r < 0)return 0;\n    if (fac[0] == 0)setMod();\n    return fac[n] * (finv[r] * finv[n - r] % MOD) % MOD;\n}\n\n//便利関数\nvoid ole() {\n    string a = \"a\";\n    rep(i, 30)a += a;\n    rep(i, 1 << 17)cout << a << endl;\n    cout << \"OLE 出力長制限超過\" << endl;\n    exit(0);\n}\nvoid tle() { while (inf)cout << inf << endl; }\nll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\nll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\nbool equal(double a, double b) { return fabs(a - b) < eps; }\nll reverse(ll a) {\n    ll res = 0;\n    while (a) {\n        res *= 10;\n        res += a % 10;\n        a /= 10;\n    }\n    return res;\n}\nll ceil(ll a, ll b) {\n    if (b == 0) {\n        ole();\n        return -1;\n    } else return (a + b - 1) / b;\n}\nll sqrt(ll a) {\n    if (a < 0)ole();\n    ll res = (ll) std::sqrt(a);\n    while (res * res < a)res++;\n    return res;\n}\ndouble log(double e, double x) { return log(x) / log(e); }\nll sig(ll t) { return (1 + t) * t / 2; }\nll sig(ll s, ll t) { return (s + t) * (t - s + 1) / 2; }\n\nvi divisors(int v) {\n    vi res;\n    for (int i = 1; i <= sqrt(v); ++i) {\n        if (v % i == 0) {\n            res.pb(i);\n            if (i != v / i)res.pb(v / i);\n        }\n    }\n    return res;\n}\n\nvi factorization(int v) {\n    int tv = v;\n    vi res;\n    if (!isPrime[2])setPrime();\n    for (auto &&p :primes) {\n        if (v % p == 0)res.push_back(p);\n        while (v % p == 0) {\n            v /= p;\n        }\n        if (v == 1 || p * p > tv)break;\n    }\n    if (v > 1)res.pb(v);\n    return res;\n}\n\nunordered_map<int, int> factorizationMap(int v) {\n    int tv = v;\n    unordered_map<int, int> res;\n    if (!isPrime[2])setPrime();\n    for (auto &&p :primes) {\n        while (v % p == 0) {\n            res[p]++;\n            v /= p;\n        }\n        if (v == 1 || p * p > tv)break;\n    }\n    if (v > 1)res[v]++;\n    return res;\n}\nint get(int a, int keta) { return (a / (int) pow(10, keta)) % 10; }\nint keta(int v) {\n    int cou = 0;\n    while (v) { cou++, v %= 10; }\n    return cou;\n}\n\ntemplate<class T> void imo(vector<T> &v) {\n    int n = v.size();\n    rep(i, n - 1)v[i + 1] += v[i];\n}\n\n//変換系\ntemplate<class T, class U> vector<U> keys(map<T, U> a) {\n    vector<U> res;\n    for (auto &&k :a)res.pb(k.F);\n    return res;\n}\n\ntemplate<class T, class U> vector<U> keys(umap<T, U> a) {\n    vector<U> res;\n    for (auto &&k :a)res.pb(k.F);\n    return res;\n}\n\ntemplate<class T, class U> vector<T> values(map<T, U> a) {\n    vector<T> res;\n    for (auto &&k :a)res.pb(k.S);\n    return res;\n}\n\ntemplate<class T, class U> vector<T> values(umap<T, U> a) {\n    vector<T> res;\n    for (auto &&k :a)res.pb(k.S);\n    return res;\n}\n\nvi list(int a) {\n    vi res;\n    while (a) {\n        res.insert(res.begin(), a % 10);\n        a /= 10;\n    }\n    return res;\n}\n\ntemplate<class T, class U> bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T, class U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> T min(T a, signed b) {\n    return a < b ? a : b;\n}\n\ntemplate<class T> T max(T a, signed b) {\n    return a < b ? b : a;\n}\n\ntemplate<class T> T min(vector<T> a) {\n    return *min_element(all(a));\n}\n\ntemplate<class T> T max(vector<T> a) {\n    return *max_element(all(a));\n}\n\ntemplate<class T> T min(T a[]) {\n    T res = a[0];\n    rep(i, arsz(a))chmin(res, a[i]);\n    return res;\n}\n\ntemplate<class T> T max(T a[]) {\n    T res = a[0];\n    rep(i, arsz(a))chmax(res, a[i]);\n    return res;\n}\ntemplate<class T> T sum(vector<T> &v, int len = -1) {\n    if (len == -1)len = v.size();\n    T res = 0;\n    chmin(len, v.size());\n    rep(i, len)res += v[i];\n    return res;\n}\n\ntemplate<class T> T sum(vector<vector<T>> &v, int h = -1, int w = -1) {\n    if (h == -1)h = v.size();\n    if (w == -1)w = v[0].size();\n    T res = 0;\n    chmin(h, v.size());\n    chmin(w, v[0].size());\n    rep(i, h)rep(j, w)res += v[i][j];\n    return res;\n}\n\nP sump(vp &v, int len = -1) {\n    if (len == -1)len = v.size();\n    P res = {0, 0};\n    chmin(len, v.size());\n    rep(i, len) {\n        res.F += v[i].F;\n        res.S += v[i].S;\n    }\n    return res;\n}\n\n///要素が0の時、返り値は0か1か\ntemplate<class T> T mul(vector<T> &v, int len = -1) {\n    if (len == -1)len = v.size();\n    T res = 1;\n    chmin(len, v.size());\n    rep(i, len)res *= v[i];\n    return res;\n}\nvoid clear(PQ &q) { while (q.size())q.pop(); }\ntemplate<class T> void clear(queue<T> &q) { while (q.size())q.pop(); }\ntemplate<class T> T *negarr(int size) {\n    T *body = (T *) malloc((size * 2 + 1) * sizeof(T));\n    return body + size;\n}\ntemplate<class T> T *negarr2(int h, int w) {\n    double **dummy1 = new double *[2 * h + 1];\n    double *dummy2 = new double[(2 * h + 1) * (2 * w + 1)];\n    dummy1[0] = dummy2 + w;\n    for (int i = 1; i <= 2 * h + 1; i++) {\n        dummy1[i] = dummy1[i - 1] + 2 * w + 1;\n    }\n    double **a = dummy1 + h;\n}\n\ntemplate<class T> vector<T> ruiv(vector<T> &a) {\n    vector<T> res(a.size() + 1);\n    rep(i, a.size())res[i + 1] = res[i] + a[i];\n    return res;\n}\n\ntemplate<class T> vector<T> ruim(vector<T> &a) {\n    vector<T> res(a.size() + 1, 1);\n    rep(i, a.size())res[i + 1] = res[i] * a[i];\n    return res;\n}\n//右から左にかけての半開区間 (-1 n-1]\ntemplate<class T> T *rrui(vector<T> &a) {\n    int len = a.size();\n    T *body = (T *) malloc((len + 1) * sizeof(T));\n    T *res = body + 1;\n    rer(i, len - 1)res[i - 1] = res[i] + a[i];\n    return res;\n}\n//掛け算\ntemplate<class T> T *rruim(vector<T> &a) {\n    int len = a.size();\n    T *body = (T *) malloc((len + 1) * sizeof(T));\n    T *res = body + 1;\n    res[len - 1] = 1;\n    rer(i, len - 1)res[i - 1] = res[i] * a[i];\n    return res;\n}\ntemplate<class T> void plus(vector<T> &a, T v = 1) { for (auto &&u :a)u += v; }\ntemplate<class T> void minu(vector<T> &a, T v = 1) { for (auto &&u :a)u -= v; }\ntemplate<class T> void minus(vector<T> &a, T v = 1) { for (auto &&u :a)u -= v; }\ninline bool inside(int y, int x, int H, int W) { return y >= 0 && x >= 0 && y < H && x < W; }\nll u(ll a) { return a < 0 ? 0 : a; }\n#define MIN(a) numeric_limits<a>::min()\n#define MAX(a) numeric_limits<a>::max()\ntemplate<class T> T min(vector<vector<T>> &a) {\n    T res = MAX(T);\n    rep(i, a.size())chmin(res, *min_element(all(a[i])));\n    return res;\n}\ntemplate<class T> T max(vector<vector<T>> &a) {\n    T res = MIN(T);\n    rep(i, a.size())chmax(res, *max_element(all(a[i])));\n    return res;\n}\nbool bget(ll m, int keta) { return (m >> keta) & 1; }\nint bget(ll m, int keta, int sinsuu) {\n    m /= (ll) pow(sinsuu, keta);\n    return m % sinsuu;\n}\ninline ll bit(int n) { return (1LL << (n)); }\ninline ll bit(int n, int sinsuu) { return (ll) pow(sinsuu, n); }\nint bcou(ll m) { return __builtin_popcount(m & 0xFFFFFFFF) + __builtin_popcount(m >> 32); }\n//初期化は0を渡す\nll nextComb(ll &mask, int n, int r) {\n    if (!mask)return mask = (1LL << r) - 1;\n    ll x = mask & -mask; //最下位の1\n    ll y = mask + x; //連続した下の1を繰り上がらせる\n    ll res = ((mask & ~y) / x >> 1) | y;\n    if (bget(res, n))return mask = 0;\n    else return mask = res;\n}\n\n//n桁以下でビットがr個立っているもののvectorを返す\nvl bitCombList(int n, int r) {\n    vl res;\n    int m = 0;\n    while (nextComb(m, n, r)) {\n        res.pb(m);\n    }\n    return res;\n}\n//大文字小文字を区別する\nint altoiaZ(char c) {\n    if ('A' <= c && c <= 'Z')return c - 'A';\n    return c - 'a' + 26;\n}\nchar itoalaZ(int i) {\n    if (i < 26)return 'A' + i;\n    return 'a' + i - 26;\n}\n//aもAも0を返す 基本小文字\nint altoi(char c) {\n    if ('A' <= c && c <= 'Z')return c - 'A';\n    return c - 'a';\n}\nchar itoal(int i) {\n    return 'a' + i;\n}\nint ctoi(char c) { return c - '0'; }\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\nvoid compress(vi &a) {\n    vi b;\n    int len = a.size();\n    for (int i = 0; i < len; ++i) {\n        b.push_back(a[i]);\n    }\n    sort(b);\n    UNIQUE(b);\n    for (int i = 0; i < len; ++i) {\n        a[i] = lower_bound(all(b), a[i]) - b.begin();\n    }\n}\n\nvoid compress(int a[], int len) {\n    vi b;\n    for (int i = 0; i < len; ++i) {\n        b.push_back(a[i]);\n    }\n    sort(b);\n    UNIQUE(b);\n    for (int i = 0; i < len; ++i) {\n        a[i] = lower_bound(all(b), a[i]) - b.begin();\n    }\n}\n//要素が見つからなかったときに困る\n#define binarySearch(a, v) (binary_search(all(a),v))\n#define lowerIndex(a, v) (lower_bound(all(a),v)-a.begin())\n#define lowerBound(a, v) (*lower_bound(all(a),v))\n#define upperIndex(a, v) (upper_bound(all(a),v)-a.begin())\n#define upperBound(a, v) (*upper_bound(all(a),v))\n#define ans(a) cout<<a<<endl;continue;\n#define poll(a) q.front();q.pop()\n#define dpoll(a) q.front();q.pop_front()\n#define pollLast(a) q.back();q.pop_back()\n#define pollBack(a) q.back();q.pop_back()\ntemplate<class T> inline void fin(T s) { cout << s << endl, exit(0); }\n\ntemplate<class T> struct edge {\n    int from, to;\n    T cost;\n    int id;\n    int type;\n    edge(int f, int t, T c = 1, int id = -1, int ty = -1) : from(f), to(t), cost(c), id(id), type(ty) {}\n    bool operator<(const edge &b) const { return cost < b.cost; }\n    bool operator>(const edge &b) const { return cost > b.cost; }\n};\n\ntemplate<typename T> class graph {\nprotected:\n    vector<bool> _used;\npublic :\n    vector<vector<edge<T>>> g;\n    vector<edge<T>> edges;\n    int n, root = -1;\n    graph(int n) : n(n) { g.resize(n), _used.resize(n); }\n    void clear() { g.clear(), edges.clear(); }\n    void resize(int n) {\n        this->n = n;\n        g.resize(n);\n        _used.resize(n);\n    }\n    int size() { return g.size(); }\n    bool isleaf(int v) {\n        assert(root != -1);\n        return g[v].size() == 1 && g[v][0].from != root;\n    }\n    vector<edge<T> > &operator[](int i) { return g[i]; }\n    virtual void add(int from, int to, T cost, int ty) = 0;\n    virtual bool used(edge<T> &e) = 0;\n    virtual bool used(int id) = 0;\n    virtual void del(edge<T> &e) = 0;\n    virtual void del(int id) = 0;\n};\n\ntemplate<class T=int> class undigraph : public graph<T> {\npublic:\n    using graph<T>::g;\n    using graph<T>::n;\n    using graph<T>::edges;\n    using graph<T>::_used;\n    undigraph(int n) : graph<T>(n) {\n    }\n    void add(int f, int t, T cost = 1, int ty = -1) {\n        if (!(0 <= f && f < n && 0 <= t && t < n))ole();\n        int id = edges.size();\n        g[f].emplace_back(f, t, cost, id, ty);\n        g[t].emplace_back(t, f, cost, id + 1, ty);\n        edges.emplace_back(f, t, cost, id, ty);\n        edges.emplace_back(t, f, cost, id + 1, ty);\n    }\n    void add(edge<T> &e) {\n        int f = e.from, t = e.to, ty = e.type;\n        T cost = e.cost;\n        add(f, t, cost, ty);\n    }\n    bool used(edge<T> &e) { return _used[e.id]; }\n    bool used(int id) { return _used[id]; }\n    void del(edge<T> &e) { _used[e.id] = _used[e.id ^ 1] = 1; }\n    void del(int id) { _used[id] = _used[id ^ 1] = 1; }\n};\n\ntemplate<typename T =ll> class digraph : public graph<T> {\npublic:\n    using graph<T>::g;\n    using graph<T>::n;\n    using graph<T>::edges;\n    using graph<T>::_used;\n\n    digraph(int n) : graph<T>(n) {}\n    void add(int f, int t, T cost = 1, int ty = -1) {\n        if (!(0 <= f && f < n && 0 <= t && t < n))ole();\n        int id = edges.size();\n        g[f].emplace_back(f, t, cost, ty, id);\n        edges.emplace_back(f, t, cost, ty, id);\n    }\n    bool used(edge<T> &e) { return _used[e.id]; }\n    bool used(int id) { return _used[id]; }\n    void del(edge<T> &e) { _used[e.id] = _used[e.id ^ 1] = 1; }\n    void del(int id) { _used[id] = _used[id ^ 1] = 1; }\n};\n\ntemplate<class T> bool nibu(const graph<T> &g) {\n    UnionFind uf(g.n * 2);\n    for (auto &&e :g.edges)uf.unite(e.f, e.t + g.n), uf.unite(e.f + g.n, e.t);\n    return !uf.same(0, g.n);\n}\n\ntemplate<class T> vector<T> &dijkstra(const graph<T> &g, int s) {\n    if (!(0 <= s && s < g.n))ole();\n    T initValue = MAX(T);\n    vector<T> dis(g.n, initValue);\n    priority_queue<pair<T, int>, vector<pair<T, int>>, greater<pair<T, int>>> q;\n    dis[s] = 0;\n    q.emplace(0, s);\n    while (q.size()) {\n        T nowc = q.top().F;\n        int i = q.top().S;\n        q.pop();\n        if (dis[i] != nowc)continue;\n        for (auto &&e  : g.g[i]) {\n            int to = e.to;\n            T cost = nowc + e.cost;\n            if (dis[to] > cost) {\n                dis[to] = cost;\n                q.emplace(dis[to], to);\n            }\n        }\n    }\n    //たどり着かないなら-1\n    for (auto &&d :dis) if (d == initValue)d = -1;\n    return dis;\n}\n\n//機能拡張\ntemplate<typename T> void remove(vector<T> &v, unsigned int i) { v.erase(v.begin() + i); }\n\ntemplate<typename T> void remove(vector<T> &v, unsigned int s, unsigned int e) {\n    v.erase(v.begin() + s, v.begin() + e);\n}\n\ntemplate<typename T> void removen(vector<T> &v, unsigned int s, unsigned int n) {\n    v.erase(v.begin() + s, v.begin() + s + n);\n}\n\ntemplate<typename T> void erase(vector<T> &v, unsigned int i) { v.erase(v.begin() + i); }\n\ntemplate<typename T> void erase(vector<T> &v, unsigned int s, unsigned int e) {\n    v.erase(v.begin() + s, v.begin() + e);\n}\n\ntemplate<typename T> void erasen(vector<T> &v, unsigned int s, unsigned int n) {\n    v.erase(v.begin() + s, v.begin() + s + n);\n}\n\ntemplate<typename T> void insert(vector<T> &v, unsigned int i, T t) { v.insert(v.begin() + i, t); }\n\ntemplate<typename T> void insert(vector<T> &v, unsigned int i, vector<T> list) {\n    for (auto &&va :list)v.insert(v.begin() + i++, va);\n}\n\ntemplate<typename T> void insert(vector<T> &v, unsigned int i, initializer_list<T> list) {\n    for (auto &&va :list)v.insert(v.begin() + i++, va);\n}\n\ntemplate<typename T> void insert(set<T> &v, vector<T> list) {\n    for (auto &&va :list)v.insert(va);\n}\n\ntemplate<typename T> void insert(set<T> &v, initializer_list<T> list) {\n    for (auto &&va :list)v.insert(va);\n}\n\nint mod(int a, int m) {\n    return (a % m + m) % m;\n}\n\nll ma = numeric_limits<ll>::min();\nll mi = numeric_limits<ll>::max();\n\n//閉路がなければtrue\nbool topo(vi &res, digraph<int> &g) {\n    int n = g.g.size();\n    vi nyu(n);\n    rep(i, n)for (auto &&e :g[i])nyu[e.to]++;\n    queue<int> st;\n    rep(i, n)if (nyu[i] == 0)st.push(i);\n    while (st.size()) {\n        int v = st.front();\n        st.pop();\n        res.pb(v);\n        fora(e, g[v]) if (--nyu[e.to] == 0)st.push(e.to);\n    }\n    return res.size() == n;\n}\n\n//辞書順最小トポロジカルソート\nbool topos(vi &res, digraph<int> &g) {\n    int n = g.g.size();\n    vi nyu(n);\n    rep(i, n)for (auto &&e :g[i])nyu[e.to]++;\n    //小さい順\n    priority_queue<int, vector<int>, greater<int> > q;\n    rep(i, n)if (nyu[i] == 0)q.push(i);\n    while (q.size()) {\n        int i = q.top();\n        q.pop();\n        res.pb(i);\n        fora(e, g[i])if (--nyu[e.to] == 0)q.push(e.to);\n    }\n    return res.size() == n;\n}\n\nvector<string> split(const string a, const char deli) {\n    string b = a + deli;\n    int l = 0, r = 0, n = b.size();\n    vector<string> res;\n    rep(i, n) {\n        if (b[i] == deli) {\n            r = i;\n            if (l < r)res.push_back(b.substr(l, r - l));\n            l = i + 1;\n        }\n    }\n    return res;\n}\n\nvector<string> split(const string a, const string deli) {\n    string b = a + deli;\n    int l = 0, r = 0, n = b.size(), dn = deli.size();\n    vector<string> res;\n    rep(i, n) {\n        if (i + dn <= n && b.substr(i, i + dn) == deli) {\n            r = i;\n            if (l < r)res.push_back(b.substr(l, r - l));\n            i += dn - 1;\n            l = i + 1;\n        }\n    }\n    return res;\n}\n\nint n, k, m, h, w, x, y, q;\nint cou;\nvi a, b, c;\nv3i(dp, 5000, 5001, 2);//コンピューターしかないか\nvvi(sub, 5050, 2);\nundigraph<> g(0);\nvi es(5050);\n\nvoid ds(int i, int p) {\n    forg(gi, g[i])if (t != p)ds(t, i);\n    int sum = 0;\n    dp[i][0][a[i] < 0] = a[i];\n    forg(gi, g[i]) {\n            if (t == p)continue;\n            rep(ci, sum + 1) {\n                rep(ct, es[t] + 1) {\n                    rep(ki, 2) {\n                        rep(kt, 2) {\n                            //繋ぐ\n                            if (dp[i][ci][ki] < linf && dp[t][ct][kt] < linf)\n                                chmin(sub[ci + ct][ki || kt], dp[i][ci][ki] + dp[t][ct][kt]);\n                            //切る\n                            if (dp[t][ct][kt] < 0 || (!kt && dp[t][ct][kt] != linf))\n                                chmin(sub[ci + ct + 1][ki], dp[i][ci][ki]);\n                        }\n                    }\n                }\n            }\n            sum += es[t] + 1;\n            rep(j, sum + 1)\n                rep(k, 2) {\n                    dp[i][j][k] = sub[j][k];\n                    sub[j][k] = linf;\n\n                }\n        }\n    es[i] = sum;\n}\nsigned main() {\n    cin >> n;\n    addn(a, n);\n    g.resize(n);\n    rep(i, n - 1) {\n        int f, s;\n        cin >> f >> s;\n        --f, --s;\n        g.add(f, s);\n    }\n    fill(dp, linf);\n    fill(sub, linf);\n//    ds(0, -1);\n    rep(c, n)rep(k, 2) {\n            if (k) {\n                if (dp[0][c][k] < 0)fin(c);\n            } else if (dp[0][c][k] != linf)fin(c);\n        }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FAST ios_base::sync_with_stdio(false); cin.tie(0);\n#define pb push_back\n#define eb emplace_back\n#define ins insert\n#define f first\n#define s second\n#define cbr cerr << \"hi\\n\"\n#define mmst(x, v) memset((x), v, sizeof ((x)))\n#define siz(x) ll(x.size())\n#define all(x) (x).begin(), (x).end()\n#define lbd(x,y) (lower_bound(all(x),y)-x.begin())\n#define ubd(x,y) (upper_bound(all(x),y)-x.begin())\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());    //can be used by calling rng() or shuffle(A, A+n, rng)\ninline long long rand(long long x, long long y) { return (rng() % (y+1-x)) + x; } //inclusivesss\nstring inline to_string(char c) {string s(1,c);return s;} template<typename T> inline T gcd(T a,T b){ return a==0?llabs(b):gcd(b%a,a); }\n\ntypedef long long ll; \ntypedef long double ld;\n#define FOR(i,s,e) for(ll i=s;i<=ll(e);++i)\n#define DEC(i,s,e) for(ll i=s;i>=ll(e);--i)\ntypedef pair<ll,ll>pi; typedef pair<ll,pi>spi; typedef pair<pi,pi>dpi;\n\n#define LLINF ((long long)1e18)\n#define INF int(1e9+1e6)\n#define MAXN (5006)\nll n,A[MAXN],dp[MAXN][MAXN],sz[MAXN];// if 0 then max, 1 then min\nbitset<MAXN> dp2[MAXN];\nvector<int>v[MAXN];\nvoid dfs(ll x,ll p){\n\tsz[x]=1;\n\tdp[x][0]=A[x];\n\tfor(auto i:v[x]) if(i^p) dfs(i,x), sz[x]+=sz[i];\n\tFOR(k,1,sz[x]) dp[x][k]=LLINF;\n\tll cur = 1;\n\tif(A[x]>0)dp2[x][0]=1;\n\tfor(auto i:v[x]) if(i^p) {\n\t\tcur += sz[i];\n\t\tDEC(j,cur,0){\n\t\t\tif(dp[x][j]<LLINF) dp[x][j] += dp[i][0];\n\t\t\tdp2[x][j] = dp2[x][j] & dp2[i][0];\n\t\t\tFOR(k,max(j-(cur-sz[i]),1ll),min(j,sz[i])){\n\t\t\t\tdp[x][j]=min(dp[x][j],dp[x][j-k]+dp[i][k]);\n\t\t\t\tif(dp2[i][k-1]) dp[x][j]=min(dp[x][j],dp[x][j-k]);\n\t\t\t\tdp2[x][j]=dp2[x][j]|(dp2[x][j-k]&dp2[i][k]);\n\t\t\t\tif(dp[i][k-1] < 0) dp2[x][j]=dp2[x][j]|dp2[x][j-k];\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tFAST\n\tcin>>n;\n\tFOR(i,1,n)cin>>A[i];\n\tFOR(i,2,n){\n\t\tll a,b;cin>>a>>b;\n\t\tv[a].eb(b),v[b].eb(a);\n\t}\n\tdfs(1,1);\n\tll ans = n-1;\n\tFOR(k,0,n-1) if(dp[1][k] < 0) ans = min(ans, k);\n\tFOR(k,0,n-1) if(dp2[1][k]) ans = min(ans, k);\n\tcout<<ans<<'\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#line 2 \"Library\\\\gcc_option.hpp\"\n#ifdef ONLINE_JUDGE\n    #pragma GCC optimize(\"O3\")\n    #pragma GCC target(\"avx,avx2\")\n    #pragma GCC optimize(\"unroll-loops\")\n#endif\n#line 2 \"Library\\\\gcc_builtin.hpp\"\n#include <cstdint>\nnamespace workspace {\nconstexpr int clz32(const uint32_t &n) noexcept { return __builtin_clz(n); }\nconstexpr int clz64(const uint64_t &n) noexcept{ return __builtin_clzll(n); }\nconstexpr int ctz(const uint64_t &n) noexcept { return __builtin_ctzll(n); }\nconstexpr int popcnt(const uint64_t &n) noexcept { return __builtin_popcountll(n); }\n} // namespace workspace\n#line 3 \"atcoder-workspace\\\\aising2019\\\\e\\\\e.cpp\"\n#include <bits/extc++.h>\n#line 5 \"Library\\\\config.hpp\"\nnamespace config {\nconst auto start_time{std::chrono::system_clock::now()};\nint64_t elapsed()\n{\n    using namespace std::chrono;\n    const auto end_time{system_clock::now()};\n    return duration_cast<milliseconds>(end_time - start_time).count();\n}\n__attribute__((constructor)) void setup()\n{\n    using namespace std;\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout << fixed << setprecision(15);\n#ifdef _buffer_check\n    atexit([]{ ofstream cnsl(\"CON\"); char bufc; if(cin >> bufc) cnsl << \"\\n\\033[43m\\033[30mwarning: buffer not empty.\\033[0m\\n\\n\"; });\n#endif\n}\nunsigned cases(void), caseid = 1;\ntemplate <class C> void main() { for(const unsigned total = cases(); caseid <= total; ++caseid) C(); }\n} // namespace config\n#line 5 \"Library\\\\utils\\\\binary_search.hpp\"\nnamespace workspace {\n// binary search on discrete range.\ntemplate <class iter_type, class pred_type, std::enable_if_t<std::is_convertible_v<std::invoke_result_t<pred_type, iter_type>, bool>, std::nullptr_t> = nullptr>\niter_type binary_search(iter_type ok, iter_type ng, pred_type pred)\n{\n    assert(ok != ng);\n    intmax_t dist(ng - ok);\n    while(std::abs(dist) > 1)\n    {\n        iter_type mid(ok + dist / 2);\n        if(pred(mid)) ok = mid, dist -= dist / 2;\n        else ng = mid, dist /= 2;\n    }\n    return ok;\n}\n// binary search on real numbers.\ntemplate <class real_type, class pred_type, std::enable_if_t<std::is_convertible_v<std::invoke_result_t<pred_type, real_type>, bool>, std::nullptr_t> = nullptr>\nreal_type binary_search(real_type ok, real_type ng, const real_type eps, pred_type pred)\n{\n    assert(ok != ng);\n    while(std::abs(ok - ng) > eps)\n    {\n        real_type mid{(ok + ng) / 2};\n        (pred(mid) ? ok : ng) = mid;\n    }\n    return ok;\n}\n} // namespace workspace\n#line 3 \"Library\\\\utils\\\\casefmt.hpp\"\nnamespace workspace {\nstd::ostream &casefmt(std::ostream& os) { return os << \"Case #\" << config::caseid << \": \"; }\n} // namespace workspace\n#line 3 \"Library\\\\utils\\\\chval.hpp\"\nnamespace workspace {\ntemplate <class T, class Comp = std::less<T>> bool chle(T &x, const T &y, Comp comp = Comp()) { return comp(y, x) ? x = y, true : false; }\ntemplate <class T, class Comp = std::less<T>> bool chge(T &x, const T &y, Comp comp = Comp()) { return comp(x, y) ? x = y, true : false; }\n} // namespace workspace\n#line 3 \"Library\\\\utils\\\\fixed_point.hpp\"\nnamespace workspace {\n// specify the return type of lambda.\ntemplate <class lambda_type>\nclass fixed_point\n{\n    lambda_type func;\npublic:\n    fixed_point(lambda_type &&f) : func(std::move(f)) {}\n    template <class... Args> auto operator()(Args &&... args) const { return func(*this, std::forward<Args>(args)...); }\n};\n} // namespace workspace\n#line 2 \"Library\\\\utils\\\\sfinae.hpp\"\n#include <type_traits>\ntemplate <class type, template <class> class trait>\nusing enable_if_trait_type = typename std::enable_if<trait<type>::value>::type;\ntemplate <class Container>\nusing element_type = std::remove_const_t<std::remove_reference_t<decltype(*std::begin(std::declval<Container&>()))>>;\n#line 7 \"Library\\\\utils\\\\hash.hpp\"\nnamespace workspace {\ntemplate <class T, class = void>\nstruct hash : std::hash<T> {};\ntemplate <class Unique_bits_type>\nstruct hash<Unique_bits_type, enable_if_trait_type<Unique_bits_type, std::has_unique_object_representations>>\n{\n    size_t operator()(uint64_t x) const\n    {\n        static const uint64_t m = std::random_device{}();\n        x ^= x >> 23;\n        // x *= 0x2127599bf4325c37ULL;\n        x ^= m;\n        x ^= x >> 47;\n        return x - (x >> 32);\n    }\n};\ntemplate <class Key>\nsize_t hash_combine(const size_t &seed, const Key &key)\n{\n    return seed ^ (hash<Key>()(key) + 0x9e3779b9 /* + (seed << 6) + (seed >> 2) */ );\n}\ntemplate <class T1, class T2>\nstruct hash<std::pair<T1, T2>>\n{\n    size_t operator()(const std::pair<T1, T2> &pair) const\n    {\n        return hash_combine(hash<T1>()(pair.first), pair.second);\n    }\n};\ntemplate <class... T>\nclass hash<std::tuple<T...>>\n{\n    template <class Tuple, size_t index = std::tuple_size<Tuple>::value - 1> struct tuple_hash { static uint64_t apply(const Tuple &t) { return hash_combine(tuple_hash<Tuple, index - 1>::apply(t), std::get<index>(t)); } };\n    template <class Tuple> struct tuple_hash<Tuple, size_t(-1)> { static uint64_t apply(const Tuple &t) { return 0; } };\npublic:\n    uint64_t operator()(const std::tuple<T...> &t) const { return tuple_hash<std::tuple<T...>>::apply(t); }\n};\n/*\ntemplate <class Key, class Mapped>\nstruct hash_map : public <Key, Mapped>\n{\n    using base = Container<Key, Mapped>;\n    size_t count(const Key &key) const { return base::find(key) != base::end(); }\n    template <class... Args> auto emplace(Args&&... args) { return base::insert(typename base::value_type(args...)); }\n};\n// template <class Key>\n// struct hash_map<Key, __gnu_pbds::null_type, std::unordered_map> : std::unordered_set<Key>\n// {\n\n// };\n// template <class Key> using hash_set = hash_map<Key, __gnu_pbds::null_type>;\n/*/\ntemplate <class Key, class Mapped> using hash_map = std::unordered_map<Key, Mapped, hash<Key>>;\ntemplate <class Key> using hash_set = std::unordered_set<Key, hash<Key>>;\n/**/\ntemplate <class Key, class Mapped> using hash_multimap = std::unordered_multimap<Key, Mapped, hash<Key>>;\ntemplate <class Key> using hash_multiset = std::unordered_multiset<Key, hash<Key>>;\n} // namespace workspace\n#line 3 \"Library\\\\utils\\\\iostream_overload.hpp\"\nnamespace std\n{\n    template <class T, class U> istream &operator>>(istream &is, pair<T, U> &p) { return is >> p.first >> p.second; }\n    template <class T, class U> ostream &operator<<(ostream &os, const pair<T, U> &p) { return os << p.first << ' ' << p.second; }\n    template <class tuple_t, size_t index> struct tuple_is { static istream &apply(istream &is, tuple_t &t) { tuple_is<tuple_t, index - 1>::apply(is, t); return is >> get<index>(t); } };\n    template <class tuple_t> struct tuple_is<tuple_t, SIZE_MAX> { static istream &apply(istream &is, tuple_t &t) { return is; } };\n    template <class... T> istream &operator>>(istream &is, tuple<T...> &t) { return tuple_is<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(is, t); }\n    template <class tuple_t, size_t index> struct tuple_os { static ostream &apply(ostream &os, const tuple_t &t) { tuple_os<tuple_t, index - 1>::apply(os, t); return os << ' ' << get<index>(t); } };\n    template <class tuple_t> struct tuple_os<tuple_t, 0> { static ostream &apply(ostream &os, const tuple_t &t) { return os << get<0>(t); } };\n    template <class tuple_t> struct tuple_os<tuple_t, SIZE_MAX> { static ostream &apply(ostream &os, const tuple_t &t) { return os; } };\n    template <class... T> ostream &operator<<(ostream &os, const tuple<T...> &t) { return tuple_os<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(os, t); }\n    template <class Container, typename Value = typename Container::value_type, enable_if_t<!is_same<decay_t<Container>, string>::value, nullptr_t> = nullptr>\n    istream& operator>>(istream& is, Container &cont) { for(auto&& e : cont) is >> e; return is; }\n    template <class Container, typename Value = typename Container::value_type, enable_if_t<!is_same<decay_t<Container>, string>::value, nullptr_t> = nullptr>\n    ostream& operator<<(ostream& os, const Container &cont) { bool flag = 1; for(auto&& e : cont) flag ? flag = 0 : (os << ' ', 0), os << e; return os; }\n} // namespace std\n#line 3 \"Library\\\\utils\\\\read.hpp\"\nnamespace workspace {\n// read with std::cin.\ntemplate <class T = void>\nstruct read\n{\n    typename std::remove_const<T>::type value;\n    template <class... types>\n    read(types... args) : value(args...) { std::cin >> value; }\n    operator T() const { return value; }\n};\ntemplate <>\nstruct read<void>\n{\n    template <class T>\n    operator T() const { T value; std::cin >> value; return value; }\n};\n} // namespace workspace\n#line 12 \"atcoder-workspace\\\\aising2019\\\\e\\\\e.cpp\"\nnamespace workspace {\n    constexpr char eol = '\\n';\n    using namespace std; using namespace __gnu_pbds; using namespace __gnu_cxx;\n    using i64 = int_least64_t; using p32 = pair<int, int>; using p64 = pair<i64, i64>;\n    using __gnu_pbds::priority_queue;\n    struct solver;\n}\nint main() { config::main<workspace::solver>(); }\nunsigned config::cases() {\n    // return -1; // not specify\n    // int t; std::cin >> t; return t; // given\n    return 1;\n}\n\nstruct workspace::solver { // start here!\n\nconst i64 inf=1ll<<61;\nvector<i64> a;\nvector<vector<int>> tr;\n\nvector<vector<i64>> dfs(int now,int pre)\n{\n    vector<vector<i64>> cdp;\n    if(a[now]>0) cdp={{a[now],inf}};\n    else cdp={{inf,a[now]}};\n    for(auto to: tr[now])\n    {\n        if(to==pre) continue;\n        const auto &tdp=dfs(to,now);\n        vector ndp(size(cdp)+size(tdp), vector<i64>(2,inf));\n        for(int i=0; i<size(cdp); ++i)\n        {\n            for(auto ei: {0,1})\n            {\n                if(cdp[i][ei]==inf) continue;\n                for(int j=0; j<size(tdp); ++j)\n                {\n                    for(auto ej: {0,1})\n                    {\n                        if(tdp[j][ej]==inf) continue;\n                        chle(ndp[i+j][ei|ej],cdp[i][ei]+tdp[j][ej]);\n                        if(!ej or tdp[j][ej]<0) chle(ndp[i+j+1][ei],cdp[i][ei]);\n                    }\n                }\n            }\n        }\n        swap(cdp,ndp);\n    }\n    return cdp;\n}\n\nsolver()\n{\n    int n; cin>>n;\n    a.resize(n); cin>>a;\n    tr.resize(n);\n    for(int i=1; i<n; ++i)\n    {\n        int u,v; cin>>u>>v; --u,--v;\n        tr[u].emplace_back(v);\n        tr[v].emplace_back(u);\n    }\n    const auto &cdp=dfs(0,-1);\n    for(int i=0; i<size(cdp); i++)\n    {\n        if(cdp[i][0]<inf or cdp[i][1]<0)\n        {\n            cout<<i<<eol;\n            return;\n        }\n    }\n}};\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int SZ = 5005;\ntypedef long long ll;\nvector<int> graph[5005];\nll wei[SZ];\nint visit[SZ];\nint n;\nint aa = 0;\nll post_order(int a){\n\tvisit[a]=1;\n\tll sm = wei[a];\n\tfor(auto x : graph[a]){\n\t\tif(visit[x]==1) continue;\n\t\tll chk = post_order(x);\n\t\tsm += chk;\n\t\tif(wei[a]+chk>0 && wei[a]<0 || chk<0 ) aa++;\n\t\telse if(wei[x]<0 && sm+wei[x]>0) aa++;\n\t}\n\treturn sm;\n}\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%lld\",&wei[i]);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y; scanf(\"%d %d\",&x,&y);\n\t\tgraph[x].push_back(y);\n\t\tgraph[y].push_back(x);\n\t}\n\tpost_order(1);\n\tprintf(\"%lld\",aa);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define ALL(A) A.begin(),A.end()\n#define RALL(A) A.rbegin(),A.rend()\ntypedef long long LL;\ntypedef pair<int,int> P;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\nconst LL mod=1000000007;\nconst LL LINF=1LL<<60;\nconst int INF=1<<30;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\n\nLL a[5001];\nLL dp1[5001][5001][2];\nLL d[5001];\nvector<int> G[5001];\n\nvoid rec(int u,int v){\n    d[u] = 1;\n    vector<vector<LL>> dp(5001,vector<LL> (2,LINF));\n    dp[0][0] = a[u];\n    if(a[u] > 0) dp[0][1] = a[u];\n    for(auto g:G[u]){\n        if(g==v) continue;\n        rec(g,u);\n        for (int j = d[u]-1; j >= 0; j--) {\n            LL t0 = dp[j][0], t1 = dp[j][1];\n            dp[j][0] = LINF;dp[j][1] = LINF;\n            for (int k = 0; k <= d[g]; k++) {\n                chmin(dp[j+k][0],dp1[g][k][0]+t0);\n                if(dp1[g][k][0] < 0 || dp1[g][k][1] != LINF) chmin(dp[j+k+1][0],t0);\n                if(a[u]>0){\n                    chmin(dp[j+k][1],dp1[g][k][1]+t1);\n                    if(dp1[g][k][0] < 0 || dp1[g][k][1] != LINF) chmin(dp[j+k+1][1],t1);\n                }\n            }\n        }\n        d[u] += d[g];\n    }\n    for (int i = 0; i <= d[u]; i++) {\n        dp1[u][i][0] = dp[i][0];\n        dp1[u][i][1] = dp[i][1];\n    }\n}\n\nint main(){\n    int n;cin >> n;\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n    for (int i = 0; i < n-1; i++) {\n        int x,y;cin >> x >> y;\n        x--,y--;\n        G[x].pb(y);\n        G[y].pb(x);\n    }\n    for (int i = 0; i < 5001; i++) {\n        for (int j = 0; j < 5001; j++) {\n            for (int k = 0; k < 2; k++) {\n                dp1[i][j][k] = LINF;\n            }\n        }\n    }\n    rec(0,0);\n    for (int i = 0; i <= n; i++) {\n        if(dp1[0][i][0] < 0){\n            cout << i << endl;\n            return 0;\n        }\n        if(dp1[0][i][1] != LINF){\n            cout << i << endl;\n            return 0;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n \n#define rep(i, n)      for (int i = 0; i < (n); i++)\n#define repr(i, n)     for (int i = (n) - 1; i >= 0; i--)\n#define repe(i, l, r)  for (int i = (l); i < (r); i++)\n#define reper(i, l, r) for (int i = (r) - 1; i >= (l); i--)\n#define repi(i, l, r)  for (int i = (l); i <= (r); i++)\n#define repir(i, l, r) for (int i = (r); i >= (l); i--)\n#define range(a) a.begin(), a.end()\nvoid initio() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); }\n\nvoid chmin(ll &x, ll y) {\n  x = min(x, y);\n}\n\nint main() { initio();\n  int N; cin >> N;\n  vector<ll> A(N); rep(i, N) cin >> A[i];\n  vector<vector<int>> G(N);\n  rep(i, N-1) {\n    int u, v; cin >> u >> v; u--; v--;\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  constexpr ll inf = 1e18;\n  vector<vector<ll>> dp0(N); // all positive\n  vector<vector<ll>> dp1(N); // some negative\n  auto merge = [&](vector<ll> a0, vector<ll> a1, vector<ll> b0, vector<ll> b1) -> pair<vector<ll>, vector<ll>> {\n    const int n = a0.size();\n    const int m = b0.size();\n    vector<ll> c0(n + m - 1, inf);\n    vector<ll> c1(n + m - 1, inf);\n    repe(i, 1, n) repe(j, 1, m) {\n      if (b0[j] != inf) {\n        if (a0[i] != inf) chmin(c0[i + j - 1], a0[i] + b0[j]);\n        if (a1[i] != inf) chmin(c1[i + j - 1], a1[i] + b0[j]);\n        if (a1[i] != inf) chmin(c1[i + j], a1[i]);\n        if (a1[i] != inf) chmin(c1[i + j], a1[i] + b0[j]);\n      }\n      if (b1[j] != inf) {\n        if (a0[i] != inf) chmin(c1[i + j - 1], a0[i] + b1[j]);\n        if (a1[i] != inf) chmin(c1[i + j - 1], a1[i] + b1[j]);\n        if (b1[j] < 0) {\n          if (a0[i] != inf) chmin(c0[i + j], a0[i]);\n          if (a1[i] != inf) chmin(c1[i + j], a1[i]);\n        }\n      }\n    }\n    return {c0, c1};\n  };\n  auto dfs = [&](auto dfs, int u, int p) -> void {\n    if (A[u] > 0) {\n      dp0[u] = {inf, A[u]};\n      dp1[u] = {inf, inf};\n    } else {\n      dp1[u] = {inf, A[u]};\n      dp0[u] = {inf, inf};\n    }\n    for (int v : G[u]) if (v != p) {\n      dfs(dfs, v, u);\n      auto p = merge(dp0[u], dp1[u], dp0[v], dp1[v]);\n      tie(dp0[u], dp1[u]) = p;\n    }\n  };\n  dfs(dfs, 0, -1);\n  repe(i, 1, N + 1) {\n    if (dp0[0][i] != inf || dp1[0][i] < 0) {\n      cout << i - 1 << endl;\n      return 0;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n#define reps(i, n) for (int i = 1; i <= (int) (n); i++)\n#define all(x) (x).begin(), (x).end()\n#define uniq(x) (x).erase(unique(all(x)), (x).end())\n#define bit(n) (1LL << (n))\n#define cdiv(a, b) (((a) - 1) / (b) + 1)\n#define dump(x) cerr << #x \" = \" << (x) << endl\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing pint = pair<int, int>;\nusing vpint = vector<pint>;\ntemplate<typename T> using priority_queue_rev = priority_queue<T, vector<T>, greater<T>>;\nconstexpr double PI = 3.1415926535897932384626433832795028;\nconstexpr int DY[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nconstexpr int DX[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nint gcd(int a, int b) {\n    while (b) { swap(a %= b, b); }\n    return a;\n}\nint lcm(int a, int b) { return a / gcd(a, b) * b; }\nint sgn(int x) { return (x > 0) - (x < 0); }\ntemplate<typename T> void fin(T mes) {\n    cout << mes << endl;\n    exit(0);\n}\ntemplate<typename T, typename U> bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &rhs) {\n    os << \"(\" << rhs.first << \", \" << rhs.second << \")\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\nstruct setup {\n    static constexpr int PREC = 20;\n\n    setup() {\n        cout << fixed << setprecision(PREC);\n        cerr << fixed << setprecision(PREC);\n    };\n} setup;\n\nint N;\nint A[5500];\nint U[5500], V[5500];\nvint G[5500];\npair<vint, int> dfs(int cur, int par) {\n    vint x = {A[cur]};\n    int cut = 0;\n    for (int to:G[cur]) {\n        if (to == par) { continue; }\n        pair<vint, int> tmp = dfs(to, cur);\n        vint nxt = tmp.first;\n        int ccut = tmp.second;\n        vint y(x.size() + nxt.size(), LLONG_MAX);\n        if (ccut >= 0) { rep(i, x.size()) { y[i + ccut + 1] = x[i]; }}\n        rep(i, x.size()) {\n            rep(j, nxt.size()) {\n                chmin(y[i + j], x[i] + nxt[j]);\n                if (nxt[j] < 0) { chmin(y[i + j + 1], x[i]); }\n            }\n        }\n        x = y;\n        reps(i, x.size() - 1) { chmin(x[i], x[i - 1]); }\n        int pl = -1;\n        for (int i = nxt.size() - 1; i >= 0; i--) { if (nxt[i] < 0) { pl = i; }}\n        assert(p >= 0);\n        if (ccut >= 0) { cut += min(ccut, pl + 1); }\n        else { cut += pl + 1; }\n    }\n    if (A[cur] < 0) { cut = -1; }\n    return {x, cut};\n}\n\nsigned main() {\n    cin >> N;\n    rep(i, N) { cin >> A[i]; }\n    rep(i, N - 1) {\n        cin >> U[i] >> V[i];\n        U[i]--, V[i]--;\n        G[U[i]].push_back(V[i]), G[V[i]].push_back(U[i]);\n    }\n    pair<vint, int> res = dfs(0, -1);\n    int ans = N;\n    if (A[0] > 0) { ans = res.second; }\n    rep(i, res.first.size()) { if (res.first[i] < 0) { chmin(ans, i); }}\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define debug(x) cerr<<#x<<\" = \"<<x\n#define sp <<\"  \"\n#define el <<endl\n#define fgx cerr<<\"-----------------------------------\"<<endl\n#define LL long long\n#define M 5020\n#define INF 10000000000000000ll\nusing namespace std;\nnamespace IO{\n\tconst int BS=(1<<23)+5; int Top=0;\n\tchar Buffer[BS],OT[BS],*OS=OT,*HD,*TL,SS[20]; const char *fin=OT+BS-1;\n\tchar Getchar(){if(HD==TL){TL=(HD=Buffer)+fread(Buffer,1,BS,stdin);} return (HD==TL)?EOF:*HD++;}\n\tvoid flush(){fwrite(OT,1,OS-OT,stdout),OS=OT;}\n\tvoid Putchar(char c){*OS++ =c;if(OS==fin)flush();}\n\tvoid write(int x){\n\t\tif(!x){Putchar('0');return;} if(x<0) x=-x,Putchar('-');\n\t\twhile(x) SS[++Top]=x%10,x/=10;\n\t\twhile(Top) Putchar(SS[Top]+'0'),--Top;\n\t}\n\tint read(){\n\t\tint nm=0,fh=1; char cw=getchar();\n\t\tfor(;!isdigit(cw);cw=getchar()) if(cw=='-') fh=-fh;\n\t\tfor(;isdigit(cw);cw=getchar()) nm=nm*10+(cw-'0');\n\t\treturn nm*fh;\n\t}\n}using namespace IO;\nint n,m,fs[M],nt[M<<2],to[M<<2],tmp,sz[M]; LL F[M][M][2],G[M][2],p[M];\ninline void link(int x,int y){nt[tmp]=fs[x],fs[x]=tmp,to[tmp++]=y;}\ninline void upd(LL &x,LL y){x=min(x,y);}\nvoid dp(int x,int last){\n\tF[x][sz[x]=1][p[x]<0]=p[x];\n\tfor(int i=fs[x],v;i!=-1;i=nt[i]) if((v=to[i])^last){\n\t\tdp(v,x);\n\t\tfor(int j=1;j<=sz[x]+sz[v];j++) G[j][0]=G[j][1]=INF;\n\t\tfor(int k=1;k<=sz[x];k++) for(int j=1;j<=sz[v];j++){\n\t\t\tfor(int tx=0;tx<2;tx++) for(int ty=0;ty<2;ty++){\n\t\t\t\tif(F[x][k][tx]==INF||F[v][j][ty]==INF) continue;\n\t\t\t\tupd(G[k+j-1][tx|ty],F[x][k][tx]+F[v][j][ty]);\n\t\t\t\tif(F[v][j][ty]<0||!ty) upd(G[k+j][tx],F[x][k][tx]);\n\t\t\t}\n\t\t} sz[x]+=sz[v];\n\t\tfor(int k=1;k<=sz[x];k++) F[x][k][0]=G[k][0],F[x][k][1]=G[k][1];\n\t}\n//\tdebug(x)sp,debug(p[x])el;\n//\tfor(int i=1;i<=sz[x];i++) debug(i)sp,debug(F[x][i][0])sp,debug(F[x][i][1])el;fgx;\n}\nvoid over(int ans){printf(\"%d\\n\",ans);exit(0);}\nint main(){\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tn=read(),memset(fs,-1,sizeof(fs));\n\tfor(int i=1;i<=n;i++) p[i]=read();\n\tfor(int i=1,x,y;i<n;i++) x=read(),y=read(),link(x,y),link(y,x);\n\tfor(int i=1;i<=n;i++) for(int j=1;j<=n;j++) F[i][j][0]=F[i][j][1]=INF;\n\tdp(1,0);\n\tfor(int i=1;i<=n;i++){\n\t\tif(F[1][i][0]<INF||F[1][i][1]<0) over(i-1);\n\t} over(n-1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cmath>  \n#include <cstdlib>\n#include <ctime>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <string> \n#include <vector>\n#include <bitset>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n\nusing namespace std;\nusing ll = long long;\n\n#define REP(i,n) for(long long i = 0; i < (n); i++)\n#define FOR(i, m, n) for(long long i = (m);i < (n); ++i)\n#define ALL(obj) (obj).begin(),(obj).end()\n\ntemplate<class T> using V = vector<T>;\ntemplate<class T, class U> using P = pair<T, U>;\n\nconst ll MOD = (ll)1e9 + 7;\nconst ll HINF = (ll)1e18;\nconst ll LINF = (ll)1e9;\nconst long double PI = 3.1415926535897932384626433;\n\ntemplate <class T> void corner(bool flg, T hoge) { if (flg) { cout << hoge << endl; exit(0); } }\ntemplate <class T, class U>ostream &operator<<(ostream &o, const map<T, U>&obj) { o << \"{\"; for (auto &x : obj) o << \" {\" << x.first << \" : \" << x.second << \"}\" << \",\"; o << \" }\"; return o; }\ntemplate <class T>ostream &operator<<(ostream &o, const set<T>&obj) { o << \"{\"; for (auto itr = obj.begin(); itr != obj.end(); ++itr) o << (itr != obj.begin() ? \", \" : \"\") << *itr; o << \"}\"; return o; }\ntemplate <class T>ostream &operator<<(ostream &o, const vector<T>&obj) { o << \"{\"; for (int i = 0; i < (int)obj.size(); ++i)o << (i > 0 ? \", \" : \"\") << obj[i]; o << \"}\"; return o; }\ntemplate <class T, class U>ostream &operator<<(ostream &o, const pair<T, U>&obj) { o << \"{\" << obj.first << \", \" << obj.second << \"}\"; return o; }\ntemplate <template <class tmp>  class T, class U> ostream &operator<<(ostream &o, const T<U> &obj) { o << \"{\"; for (auto itr = obj.begin(); itr != obj.end(); ++itr)o << (itr != obj.begin() ? \", \" : \"\") << *itr; o << \"}\"; return o; }\nvoid print(void) { cout << endl; }\ntemplate <class Head> void print(Head&& head) { cout << head; print(); }\ntemplate <class Head, class... Tail> void print(Head&& head, Tail&&... tail) { cout << head << \" \"; print(forward<Tail>(tail)...); }\nvoid YN(bool flg) { cout << ((flg) ? \"YES\" : \"NO\") << endl; }\nvoid Yn(bool flg) { cout << ((flg) ? \"Yes\" : \"No\") << endl; }\nvoid yn(bool flg) { cout << ((flg) ? \"yes\" : \"no\") << endl; }\n\nint main() {\n\tint N; cin >> N;\n\tV<ll> A(N); REP(i, N) cin >> A[i];\n\tV<V<int>> edge(N);\n\tREP(i, N - 1) {\n\t\tint u, v; cin >> u >> v; \n\t\tu--; v--;\n\t\tedge[u].push_back(v);\n\t\tedge[v].push_back(u);\n\t}\n\n\tint ans = 0;\n\tREP(p,N){\n\t\tV<int> deep(N, -1);\n\t\tqueue<int> q;\n\t\tq.push(p);\n\t\tdeep[p] = 0;\n\t\twhile(q.size()){\n\t\t\tint from = q.front();\n\t\t\tq.pop();\n\t\t\tfor(auto to: edge[from]){\n\t\t\t\tif(deep[to]==-1){\n\t\t\t\t\tq.push(to);\n\t\t\t\t\tdeep[to] = deep[from] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tV<P<int, int>> ord(N);\n\t\tREP(i, N) ord[i] = { -deep[i],i };\n\t\tsort(ALL(ord));\n\t\tV<ll> dp(N,0), flg(N, 0);\n\n\t\tREP(j,N){\n\t\t\tint from = ord[j].second;\n\t\t\tdeep[from] += A[from];\n\t\t\tif (flg[from] == 0 && A[from] > 0) flg[from] = 1;\n\t\t\tfor (auto to : edge[from]) {\n\t\t\t\tif (deep[to] < deep[from]) continue;\n\t\t\t\telse {\n\t\t\t\t\tdp[from] += deep[to];\n\t\t\t\t\tif (flg[to] == -1) dp[from] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint cnt = 0;\n\t\tif (dp[p] > 0 && flg[p] == 1) {\n\t\t\tans = 0;\n\t\t\tbreak;\n\t\t}\n\t\tq.push(p);\n\t\twhile (q.size()) {\n\t\t\tint from = q.front();\n\t\t\tq.pop();\n\t\t\tfor (auto to : edge[from]) {\n\t\t\t\tif (deep[to] < deep[from]) continue;\n\t\t\t\tif (dp[to]>0 && flg[to] == 1){\n\t\t\t\t\tcnt++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (dp[to]<0) {\n\t\t\t\t\tcnt++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t\tans = min(ans, cnt);\n\n\t\t}\n\tcout << ans << endl;\n\n\n\t\n\n\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <limits>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <iterator>\n#include <bitset>\n#include <unordered_map>\n#include <unordered_set>\n\nusing namespace std;\n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)c.size())\n#define ten(n) ((int)1e##n)\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing Pll = pair<ll, ll>;\n\ntemplate<typename ...> static inline int getchar_unlocked(void) { return getchar(); }\ntemplate<typename ...> static inline void putchar_unlocked(int c) { putchar(c); }\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nvoid reader(ll& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nint reader(char c[]) { int i, s = 0; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c[s++] = i; for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c[s++] = i; }c[s] = '\\0'; return s; }\nint reader(string& c) { int i; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c.push_back(i); for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c.push_back(i); }; return sz(c); }\ntemplate <class T, class S> void reader(T& x, S& y) { reader(x); reader(y); }\ntemplate <class T, class S, class U> void reader(T& x, S& y, U& z) { reader(x); reader(y); reader(z); }\ntemplate <class T, class S, class U, class V> void reader(T& x, S& y, U& z, V & w) { reader(x); reader(y); reader(z); reader(w); }\nvoid writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(ll x, char c) { int s = 0, m = 0; char f[20]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(const char c[]) { int i; for (i = 0; c[i] != '\\0'; i++)mypc(c[i]); }\nvoid writer(const string& x, char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\nvoid writer(const char x[], char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\ntemplate<class T> void writerLn(T x) { writer(x, '\\n'); }\ntemplate<class T, class S> void writerLn(T x, S y) { writer(x, ' '); writer(y, '\\n'); }\ntemplate<class T, class S, class U> void writerLn(T x, S y, U z) { writer(x, ' '); writer(y, ' '); writer(z, '\\n'); }\ntemplate<class T, class S, class U, class V> void writerLn(T x, S y, U z, V v) { writer(x, ' '); writer(y, ' '); writer(z, ' '); writer(v, '\\n'); }\ntemplate<class T> void writerArr(T x[], int n) { if (!n) { mypc('\\n'); return; }FOR(i, n - 1)writer(x[i], ' '); writer(x[n - 1], '\\n'); }\ntemplate<class T> void writerArr(vector<T>& x) { writerArr(x.data(), (int)x.size()); }\n\ntemplate<class T> void chmin(T& a, const T& b) { if (a > b) a = b; }\ntemplate<class T> void chmax(T& a, const T& b) { if (a < b) a = b; }\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\ntemplate<class T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\nll mod_pow(ll a, ll n, ll mod) {\n\tll ret = 1;\n\tll p = a % mod;\n\twhile (n) {\n\t\tif (n & 1) ret = ret * p % mod;\n\t\tp = p * p % mod;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\ntemplate<class T> T extgcd(T a, T b, T& x, T& y) { for (T u = y = 1, v = x = 0; a;) { T q = b / a; swap(x -= q * u, u); swap(y -= q * v, v); swap(b -= q * a, a); } return b; }\nll mod_inv(ll a, ll m) { ll x, y; extgcd<ll>(a, m, x, y); return (m + x % m) % m; }\n\n#ifdef _DEBUG\ntemplate <typename ... Args>\nvoid debugPrintf(const char *format, Args const & ... args) {\n\tfprintf(stdout, format, args ...);\n\tfflush(stdout);\n}\n#else\n#define debugPrintf(...)\n#endif\n\n\nll a[5000];\nint allPositiveMn[5000];\nvector<ll> memo[5000];\nvector<int> e[5000];\n\nvoid dfs(int v, int par) {\n\tfor (auto to : e[v]) {\n\t\tif (to == par) continue;\n\t\tdfs(to, v);\n\t}\n\n\tstatic vector<ll> cur, nxt;\n\tnxt.clear();\n\tnxt.push_back(a[v]);\n\tfor (auto to : e[v]) {\n\t\tif (to == par) continue;\n\t\tswap(cur, nxt);\n\t\tnxt.clear();\n\t\tauto& c2 = memo[to];\n\t\tint geta = allPositiveMn[to];\n\t\tFOR(i, sz(c2)) if (c2[i] < 0) {\n\t\t\tgeta = min(geta, i);\n\t\t\tbreak;\n\t\t}\n\t\tgeta++;\n\n\t\tint newSize = max(sz(c2) + sz(cur) - 1, sz(cur) + geta);\n\t\tnxt.resize(newSize, (ll)1e17);\n\t\tFOR(i, sz(c2)) {\n\t\t\tFOR(j, sz(cur)) {\n\t\t\t\tchmin(nxt[i + j], c2[i] + cur[j]);\n\t\t\t}\n\t\t}\n\t\tFOR(i, sz(cur)) {\n\t\t\tchmin(nxt[i + geta], cur[i]);\n\t\t}\n\t}\n\tmemo[v].swap(nxt);\n\n\tif (a[v] < 0) {\n\t\tallPositiveMn[v] = ten(5);\n\t} else {\n\t\tfor (auto to : e[v]) {\n\t\t\tif (to == par) continue;\n\t\t\tif (a[to] < 0) {\n\t\t\t\tFOR(i, sz(memo[to])) {\n\t\t\t\t\tif (memo[to][i] < 0) {\n\t\t\t\t\t\tallPositiveMn[v] += i + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tallPositiveMn[v] += allPositiveMn[to];\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tint n; reader(n);\n\tFOR(i, n) reader(a[i]);\n\tFOR(i, n - 1) {\n\t\tint a, b; reader(a, b);\n\t\ta--; b--;\n\t\te[a].push_back(b);\n\t\te[b].push_back(a);\n\t}\n\n\tdfs(0, -1);\n\tint ans = allPositiveMn[0];\n\tFOR(i, sz(memo[0])) if (memo[0][i] < 0) {\n\t\tans = min(ans, i);\n\t\tbreak;\n\t}\n\twriterLn(ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <unordered_map>\n#include <unordered_set>\n#include <array>\n// stream\n//#include <istream>\n#include <sstream>\n//#include <ostream>\n#include <fstream>\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n//#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int w_=0; w_<n; ++w_){MACRO_VEC_ROW_Scan(w_, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& R:c)for(auto& w:R)std::cin>>w;\n// output\n#define OUT(dist) std::cout<<(dist);\n#define FOUT(n, dist) std::cout<<std::fixed<<std::setprecision(n)<<(dist);\n#define SOUT(n, c, dist) std::cout<<std::setw(n)<<std::setfill(c)<<(dist);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(w, n) std::cout<<(w + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(dist) {std::cerr << #dist << \"\\t:\" << (dist) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(w, a, n) for(int w=(a);w<(n);++w)\n#define RFOR(w, a, n) for(int w=(n)-1;w>=(a);--w)\n#define REP(w, n) for(int w=0;w<int(n);++w)\n#define RREP(w, n) for(int w=int(n)-1;w>=0;--w)\n#define FORLL(w, a, n) for(ll w=ll(a);w<ll(n);++w)\n#define RFORLL(w, a, n) for(ll w=ll(n)-1;w>=ll(a);--w)\n#define REPLL(w, n) for(ll w=0;w<ll(n);++w)\n#define RREPLL(w, n) for(ll w=ll(n)-1;w>=0;--w)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<class T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<class T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\n//void CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-10;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n// ------------>8------------------------------------->8------------\n\n//Union-Find\nclass UnionFind {\nprivate:\n\tstd::vector<int> parent;\n\tstd::vector<int> height;\n\tstd::vector<int> m_size;\n\npublic:\n\tUnionFind(int size_) : parent(size_), height(size_, 0), m_size(size_, 1) {\n\t\tfor (int i = 0; i < size_; ++i) parent[i] = i;\n\t}\n\tvoid init(int size_) {\n\t\tparent.resize(size_);\n\t\theight.resize(size_, 0);\n\t\tm_size.resize(size_, 0);\n\t\tfor (int i = 0; i < size_; ++i) parent[i] = i;\n\t}\n\tint find(int x) {\n\t\tif (parent[x] == x) return x;\n\t\treturn parent[x] = find(parent[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return;\n\t\tint t = size(x) + size(y);\n\t\tm_size[x] = m_size[y] = t;\n\t\tif (height[x] < height[y]) parent[x] = y;\n\t\telse parent[y] = x;\n\t\tif (height[x] == height[y]) ++height[x];\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\tif (parent[x] == x) return m_size[x];\n\t\treturn size(parent[x] = find(parent[x]));\n\t}\n};\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n);\n\tVEC(int, a, n);\n\tVEC_ROW(int, n - 1, u, v);\n\n\tUnionFind uf(n);\n\tstd::vector<int> val(a);\n\tREP(i, n - 1) {\n\t\t--u[i]; --v[i];\n\t\tif (a[u[i]] * a[v[i]] > 0) {\n\t\t\tif (!uf.same(u[i], v[i])) {\n\t\t\t\tuf.unite(u[i], v[i]);\n\t\t\t\tval[uf.find(u[i])] = val[u[i]] + val[v[i]];\n\t\t\t}\n\t\t}\n\t}\n\tint sz = 0;\n\tstd::vector<std::vector<int>> g;\n\t{\n\t\tstd::map<int, int> map;\n\t\tREP(i, n) map[uf.find(i)];\n\t\tfor (auto& p : map) p.second = sz++;\n\t\tstd::vector<int> inv(sz);\n\t\tfor (auto& p : map) inv[p.second] = p.first;\n\n\t\tstd::vector<std::set<int>> vset(sz);\n\t\tREP(i, n - 1) {\n\t\t\tif (uf.same(u[i], v[i])) continue;\n\t\t\tvset[map[uf.find(u[i])]].insert(map[uf.find(v[i])]);\n\t\t\tvset[map[uf.find(v[i])]].insert(map[uf.find(u[i])]);\n\t\t}\n\n\t\tg.resize(sz);\n\t\ta.resize(sz);\n\t\tREP(i, sz) {\n\t\t\tfor (auto& to : vset[i]) {\n\t\t\t\tg[i].emplace_back(to);\n\t\t\t}\n\t\t\ta[i] = val[inv[i]];\n\t\t}\n\t}\n\n\tstd::vector<bool> banned(sz, false);\n\n\tstd::function<int(int, int)> dfs = [&](int v, int par) {\n\t\t{\n\t\t\tint cnt = 0;\n\t\t\tfor (auto& to : g[v]) if (to != par) {\n\t\t\t\tif (banned[to]) continue;\n\t\t\t\t++cnt;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!cnt) return 0;\n\t\t}\n\n\t\tstd::vector<int> nodes({ v });\n\t\tstd::function<int(int, int)> dfs2 = [&](int u, int pa) {\n\t\t\tint sum = a[u];\n\t\t\tfor (auto& to : g[u]) if (to != pa && !banned[to]) {\n\t\t\t\tnodes.emplace_back(to);\n\t\t\t\tsum += dfs2(to, u);\n\t\t\t}\n\t\t\treturn sum;\n\t\t};\n\t\tint sum = dfs2(v, par);\n\t\tif (sum < 0) return 0;\n\n\t\tsigned res = INFINT;\n\t\tfor (auto& node : nodes) {\n\t\t\tif (a[node] < 0) continue;\n\t\t\tsigned sum = g[node].size();\n\t\t\tbanned[node] = true;\n\t\t\tfor (auto& to : g[node]) {\n\t\t\t\tsum += dfs(to, node);\n\t\t\t}\n\t\t\tbanned[node] = false;\n\t\t\tCHMIN(res, sum);\n\t\t}\n\t\treturn res;\n\t};\n\n\tOUT(dfs(0, -1))BR;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint     = long long;\nconst lint inf = 1LL << 60;\nconst lint mod = 1000000007;\n\ntemplate <class T>\nbool chmax(T &a, const T &b) {\n    return (a < b) ? (a = b, 1) : 0;\n}\ntemplate <class T>\nbool chmin(T &a, const T &b) {\n    return (b < a) ? (a = b, 1) : 0;\n}\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    vector<lint> a(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n    }\n    vector<vector<int>> edges(n);\n    for (int i = 0; i < n - 1; ++i) {\n        int u, v;\n        cin >> u >> v;\n        u--, v--;\n        edges[u].emplace_back(v);\n        edges[v].emplace_back(u);\n    }\n    vector<int> size(n, 0);\n    vector<vector<lint>> dp1(n, vector<lint>(n, inf));\n    vector<vector<lint>> dp2(n, vector<lint>(n, inf));\n    vector<lint> to1(n, inf);\n    vector<lint> to2(n, inf);\n    function<void(int, int)> dfs = [&](int c, int p) {\n        size[c] = 1;\n        if (a[c] > 0)\n            dp1[c][0] = a[c];\n        else\n            dp2[c][0] = a[c];\n\n        for (auto &v : edges[c]) {\n            if (v == p)\n                continue;\n            dfs(v, c);\n            to1.assign(n, inf);\n            to2.assign(n, inf);\n            for (int i = 0; i < size[c]; ++i) {\n                for (int j = 0; j < size[v]; ++j) {\n                    if (dp1[v][j] < inf || dp2[v][j] < 0) {\n                        chmin(to1[i + j + 1], dp1[c][i]);\n                        chmin(to2[i + j + 1], dp2[c][i]);\n                    }\n                    chmin(to1[i + j], dp1[c][i] + dp1[v][j]);\n                    chmin(to2[i + j], dp1[c][i] + dp2[v][j]);\n                    chmin(to2[i + j], dp2[c][i] + dp1[v][j]);\n                    chmin(to2[i + j], dp2[c][i] + dp2[v][j]);\n                }\n            }\n            size[c] += size[v];\n            swap(to1, dp1[c]);\n            swap(to2, dp2[c]);\n        }\n    };\n    dfs(0, -1);\n    for (int i = 0; i < n; ++i) {\n        if (dp1[0][i] < inf || dp2[0][i] < 0) {\n            cout << i << \"\\n\";\n            return 0;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define oo ll(1e14)\n#define maxn 5003\n\nusing namespace std;\ntypedef long long ll;\n\nint n;\n\nint a[maxn];\n\nll dp[maxn][maxn][2];\nint sz[maxn];\n\nvector < int > g[maxn];\n\nvoid dfs(int u, int du) {\n  if (a[u] >= 0)\n    dp[u][1][1] = 1;\n  dp[u][1][0] = a[u];\n  sz[u] = 1;\n\n  for (auto v : g[u]) {\n    if (v == du) continue;\n\n    dfs(v, u);\n    sz[u] += sz[v];\n\n    for (int j = sz[u]; j > 0; --j) {\n      bool flag = 0;\n      ll mi = oo;\n\n      for (int k = 1; k <= j && k <= sz[v]; ++k) {\n        flag |= (dp[u][j - k + 1][1] & dp[v][k][1]);\n        mi = min(mi, dp[u][j - k + 1][0] + dp[v][k][0]);\n\n        if (dp[v][k][0] < 0 || dp[v][k][1]) {\n          mi = min(mi, dp[u][j - k][0]);\n          flag |= dp[u][j - k][1];\n        }\n      }\n\n      dp[u][j][1] = flag;\n      dp[u][j][0] = mi;\n    }\n  }\n\n  return;\n}\n\nint main(){\n\n  ios_base::sync_with_stdio(0);\n\n  cin >> n;\n\n  for (int i = 1; i <= n; ++i)\n    cin >> a[i];\n\n  for (int i = 1; i < n; ++i) {\n    int u, v;\n    cin >> u >> v;\n\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n\n  for (int i = 1; i <= n; ++i)\n    for (int j = 0; j <= n; ++j) {\n      dp[i][j][0] = oo;\n      dp[i][j][1] = 0;\n    }\n\n  dfs(1, 1);\n\n  for (int j = 1; j <= n; ++j)\n    if (dp[1][j][0] < 0 || dp[1][j][1]) {\n      cout << j - 1;\n      break;\n    }\n  return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst long long INF = 1e18;\n\nint n, a[5005], siz[5005];\nlong long dp[5005][5005][2], sum[5005], tmp[5005], tmp1[5005];\n\nvector <int> edge[5005];\n\nvoid solve(int id, int p) {\n    siz[id] = 1;\n    sum[id] = a[id];\n\n    int child = 0;\n\n    for (int i = 0; i < edge[id].size(); i++) {\n        int to = edge[id][i];\n        if (to == p) continue;\n        solve(to, id);\n        siz[id] += siz[to];\n        sum[id] += sum[to];\n        child++;\n    }\n\n    int cur = 0;\n\n    for (int i = 0; i < edge[id].size(); i++) {\n        int to = edge[id][i];\n        if (to == p) continue;\n\n        for (int j = siz[to]; j >= 0; j--) {\n            if (j - 1 >= 0 && dp[to][j - 1][0] < 0) {\n                dp[to][j][0] = min(dp[to][j][0], 0LL);\n                dp[to][j][1] = 1;\n            }\n            if (j - 1 >= 0 && dp[to][j - 1][1]) {\n                dp[to][j][0] = min(dp[to][j][0], 0LL);\n            }\n        }\n\n        cur += siz[to];\n\n\n        if (cur == siz[to]) {\n            //first child\n            for (int j = 0; j <= siz[to]; j++) dp[id][j][0] = dp[to][j][0];\n            for (int j = 0; j <= siz[to]; j++) dp[id][j][1] = dp[to][j][1] && (a[id] > 0);\n        }\n        else {\n            for (int j = cur; j >= 0; j--) {\n                tmp[j] = INF;\n                tmp1[j] = 0;\n                for (int k = 0; k <= min(j, siz[to]); k++) {\n                    if (dp[to][k][0] != INF && dp[id][j - k][0] != INF) tmp[j] = min(tmp[j], dp[to][k][0] + dp[id][j - k][0]);\n                    tmp1[j] |= (dp[to][k][1] && dp[id][j - k][1]);\n                }\n            }\n            for (int j = 0; j <= cur; j++) dp[id][j][0] = tmp[j];\n            for (int j = 0; j <= cur; j++) dp[id][j][1] = tmp1[j] && (a[id] > 0);\n        }\n    }\n\n    for (int i = siz[id]; i >= 0; i--) {\n        if (dp[id][i][0] != INF) dp[id][i][0] += a[id];\n    }\n\n    if (child == 0) {\n        dp[id][0][0] = sum[id];\n        dp[id][0][1] = a[id] >  0;\n    }\n}\n\nint main() {\n    scanf(\"%d\", &n);\n\n    for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\n    for (int i = 0; i < n - 1; i++) {\n        int x, y;\n        scanf(\"%d%d\", &x, &y);\n        edge[x].push_back(y);\n        edge[y].push_back(x);\n    }\n\n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j <= n; j++) {\n            dp[i][j][0] = INF;\n            dp[i][j][1] = 0;\n        }\n    }\n\n    solve(1, -1);\n\n    for (int i = 0; i < n; i++) {\n        if (dp[1][i][0] < 0) return 0 * printf(\"%d\\n\", i);\n        if (dp[1][i][1]) return 0 * printf(\"%d\\n\", i);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n#define reps(i, n) for (int i = 1; i <= (int) (n); i++)\n#define all(x) (x).begin(), (x).end()\n#define uniq(x) (x).erase(unique(all(x)), (x).end())\n#define bit(n) (1LL << (n))\n#define cdiv(a, b) (((a) - 1) / (b) + 1)\n#define dump(x) cerr << #x \" = \" << (x) << endl\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing pint = pair<int, int>;\nusing vpint = vector<pint>;\ntemplate<typename T> using priority_queue_rev = priority_queue<T, vector<T>, greater<T>>;\nconstexpr double PI = 3.1415926535897932384626433832795028;\nconstexpr int DY[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nconstexpr int DX[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nint gcd(int a, int b) {\n    while (b) { swap(a %= b, b); }\n    return a;\n}\nint lcm(int a, int b) { return a / gcd(a, b) * b; }\nint sgn(int x) { return (x > 0) - (x < 0); }\ntemplate<typename T> void fin(T mes) {\n    cout << mes << endl;\n    exit(0);\n}\ntemplate<typename T, typename U> bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &rhs) {\n    os << \"(\" << rhs.first << \", \" << rhs.second << \")\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\nstruct setup {\n    static constexpr int PREC = 20;\n\n    setup() {\n        cout << fixed << setprecision(PREC);\n        cerr << fixed << setprecision(PREC);\n    };\n} setup;\n\nstruct union_find_tree {\n    std::vector<int> par, size, val;\n    union_find_tree() {}\n    union_find_tree(int n, vint val) : par(n), size(n), val(val) {\n        for (int i = 0; i < n; i++) {\n            par[i] = i;\n            size[i] = 1;\n        }\n    }\n    int get_root(int i) {\n        if (par[i] == i) { return i; }\n        else { return par[i] = get_root(par[i]); }\n    }\n    void unite(int i, int j) {\n        if ((i = get_root(i)) == (j = get_root(j))) { return; }\n        if (size[i] < size[j]) { std::swap(i, j); }\n        par[j] = i;\n        size[i] += size[j];\n        val[i] += val[j];\n    }\n    bool are_same(int i, int j) { return get_root(i) == get_root(j); }\n    int get_size(int i) { return size[get_root(i)]; }\n    int get_val(int i) { return val[get_root(i)]; }\n};\n\nint N;\nint U[5500], V[5500];\nvint G[5500];\nunion_find_tree uf;\npair<vint, int> dfs(int cur, int par) {\n    vint x = {uf.get_val(cur)};\n    if (uf.get_val(cur) < 0) {\n        //コンピュータ\n        for (int to:G[cur]) {\n            if (to == par) { continue; }\n            pair<vint, int> tmp = dfs(to, cur);\n            vint nxt = tmp.first;\n            int cut = tmp.second;\n            vint y(x.size() + nxt.size(), LLONG_MAX);\n            rep(i, x.size()) { y[i + cut + 1] = x[i]; }\n            rep(i, x.size()) {\n                rep(j, nxt.size()) {\n                    chmin(y[i + j], x[i] + nxt[j]);\n                    if (nxt[j] < 0) { chmin(y[i + j + 1], x[i]); }\n                }\n            }\n            x = y;\n        }\n        return {x, -1};\n    }\n    if (uf.get_val(cur) > 0) {\n        //バッテリー\n        int cut = 0;\n        for (int to:G[cur]) {\n            if (to == par) { continue; }\n            vint nxt = dfs(to, cur).first;\n            vint y(x.size() + nxt.size(), LLONG_MAX);\n            rep(i, x.size()) {\n                rep(j, nxt.size()) {\n                    chmin(y[i + j], x[i] + nxt[j]);\n                    if (nxt[j] < 0) { chmin(y[i + j + 1], x[i]); }\n                }\n            }\n            x = y;\n            int pl;\n            for (int i = nxt.size(); i >= 0; i--) { if (nxt[i] < 0) { pl = i; }}\n            cut += pl + 1;\n        }\n        return {x, cut};\n    }\n    return {{}, 0};\n}\n\nsigned main() {\n    cin >> N;\n    vint val(N);\n    rep(i, N) { cin >> val[i]; }\n    uf = union_find_tree(N, val);\n    rep(i, N - 1) {\n        cin >> U[i] >> V[i];\n        U[i]--, V[i]--;\n        if ((uf.get_val(U[i]) * uf.get_val(V[i]) > 0)) { uf.unite(U[i], V[i]); }\n    }\n    rep(i, N - 1) {\n        int u = uf.get_root(U[i]), v = uf.get_root(V[i]);\n        if (u != v) { G[u].push_back(v), G[v].push_back(u); }\n    }\n    pair<vint, int> res = dfs(uf.get_root(0), -1);\n    int ans = N;\n    if (uf.get_val(0) > 0) { ans = res.second; }\n    rep(i, res.first.size()) { if (res.first[i] < 0) { chmin(ans, i); }}\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n# include <bits/stdc++.h>\n\n# define x first\n# define y second\n# define mp make_pair\n// everything goes according to my plan\n# define pb push_back\n# define sz(a) (int)(a.size())\n# define vec vector\n// shimkenttin kyzdary, dzyn, dzyn, dzyn...\n# define y1    Y_U_NO_y1\n# define left  Y_U_NO_left\n# define right Y_U_NO_right\n\n# define debug(x) cerr<<#x<<\":=\"<<x\n\n\nusing namespace std;\n\ntypedef pair <int, int> pii;\ntypedef long long ll;\ntypedef long double ld;\n\nconst int Mod = (int)1e9 + 7;\nconst int MX = 1073741822;\nconst ll MXLL = 1e15;\nconst int Sz = 1110111;\n// a pinch of soul\ninline void Read_rap () {\n  ios_base :: sync_with_stdio(0);\n  cin.tie(0); cout.tie(0);\n}\ninline void randomizer3000 () {\n  unsigned int seed;\n  asm (\"rdtsc\" : \"=A\"(seed));\n  srand (seed);\n}\nvoid files (string problem) {\n  if (fopen ((problem + \".in\").c_str(),\"r\")) {\n    freopen ((problem + \".in\").c_str(),\"r\",stdin);\n    freopen ((problem + \".out\").c_str(),\"w\",stdout);\n  }\n}\nvoid localInput(const char in[] = \"s\") {\n  if (fopen (in, \"r\")) {\n    freopen (in, \"r\", stdin);\n  }\n  else\n    cerr << \"Warning: Input file not found\" << endl;\n}                    \nvec<ll> dp[Sz];\n\nll ans[Sz];\n            \nll ps[Sz];\n\nint n;\n\nint a[Sz];\n\nvec<int> g[Sz];\n\nvoid calc (int v, int pr) {\n  int big = 0;\n  for (int to : g[v]) {\n    if (to == pr) continue;\n    calc (to, v);\n    if (sz(dp[to]) > sz(dp[big]))\n      big = to;\n  }\n  int siz = 1;\n  if (big) {\n    swap (dp[v], dp[big]);\n    siz = sz(dp[v]);\n    for (int i = 0; i < siz; i++)\n      dp[v][i] += a[v];   \n    dp[v].pb (a[v]);\n    dp[v][ans[big] + 1] = min (dp[v][ans[big] + 1], a[v] * 1ll);\n    siz++;\n  }\n  else\n    dp[v].pb (a[v]);\n              \n  for (int to : g[v]) {\n    if (to == pr || to == big) continue;                            \n    dp[v].resize (siz + sz(dp[to]), MXLL);\n                      \n    int nsiz = siz + sz(dp[to]);\n    for (int s = siz-1; s >= 0; s--) {\n      for (int x = sz(dp[to])-1; x >= 0; x--) {\n        if (s + x + 1 < nsiz) \n          dp[v][s+x+1] = min (dp[v][s+x+1], dp[v][s]);\n        if (s + x < nsiz)\n          dp[v][s+x] = min (dp[v][s + x], dp[v][s] + dp[to][x]);\n      }\n    }\n    siz = nsiz;\n    cout << \"V: \" << v << \" to: \" << to << endl;\n    for (int i = 0; i < siz ; i++)\n      cout << dp[v][i] << ' ';\n    cout << endl;\n\n  }\n  ans[v] = MXLL;\n  for (int i = 0; i < siz; i++)\n    if (dp[v][i] < 0) {\n      ans[v] = i;\n      break;\n    }\n                                \n  if (a[v] > 0) {\n    ps[v] = 0;\n    for (int to : g[v]) {\n      if (to == pr) continue;\n      if (a[to] > 0)\n        ps[v] += ps[to];\n      else\n        ps[v] += ans[to] + 1;\n    }\n    ans[v] = min (ans[v], ps[v]);      \n  }\n}\n\nint main()\n{\n  # ifdef Local\n    //localInput();\n  # endif\n  Read_rap();\n  cin >> n;\n  for (int i = 1; i <= n; i++)\n    cin >> a[i];       \n  for (int i = 1; i < n; i++) {\n    int u, v;\n    cin >> u >> v;\n    g[u].pb (v);\n    g[v].pb (u);\n  }\n  calc (1, 1);\n  cout << ans[1];\n\n  return 0;\n}\n\n\n\n\n\n\n// Coded by Z..\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 0.00000001\n#define LONG_INF 1e9\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007\n#define MOD 998244353\n#define seg_size 262144\n#define REP(i,n) for(long long i = 0;i < n;++i)\nlong long costings[20000];\nvector<int> vertexs[20000];\nlong long dp1[5001][5001];\nlong long dp2[5001][5001];\nlong long vertexes[5001];\nlong long tmp[5001][2];\nlong long dfs(long long now, long long back) {\n\tvertexes[now] = 1;\n\tfor (int i = 0; i < vertexs[now].size(); ++i) {\n\t\tif (vertexs[now][i] != back) {\n\t\t\tdfs(vertexs[now][i], now);\n\t\t\tvertexes[now] += vertexes[vertexs[now][i]];\n\t\t}\n\t}\n\tREP(i, vertexes[now] + 1) {\n\t\ttmp[i][0] = LONG_INF;\n\t\ttmp[i][1] = LONG_INF;\n\t}\n\ttmp[0][0] = costings[now];\n\tif (costings[now] > 0) tmp[0][1] = costings[now];\n\tlong long now_tea = 0;\n\tREP(i, vertexs[now].size()) {\n\t\tif (vertexs[now][i] != back) {\n\t\t\tfor (int j = now_tea; j >= 0; --j) {\n\t\t\t\tlong long geko_a = tmp[j][0];\n\t\t\t\tlong long geko_b = tmp[j][1];\n\t\t\t\ttmp[j][0] = LONG_INF;\n\t\t\t\ttmp[j][1] = LONG_INF;\n\t\t\t\tint visiting = vertexs[now][i];\n\t\t\t\tfor (int k = 0; k <= vertexes[visiting]; ++k) {\n\t\t\t\t\ttmp[j + k][0] = min(tmp[j + k][0], geko_a + dp1[visiting][k]);\n\t\t\t\t\tif (dp1[visiting][k] < 0 || dp2[visiting][k] < LONG_INF / 2) tmp[j + k + 1][0] = min(tmp[j + k + 1][0], geko_a);\n\t\t\t\t\tif (costings[now] > 0) {\n\t\t\t\t\t\ttmp[j + k][1] = min(tmp[j + k][1], geko_b + dp2[visiting][k]);\n\t\t\t\t\t\tif (dp1[visiting][k] < 0 || dp2[visiting][k] < LONG_INF / 2) tmp[j + k + 1][1] = min(tmp[j + k + 1][1], geko_b);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tnow_tea += vertexes[vertexs[now][i]];\n\t\t}\n\t}\n\tfor (int j = 0; j <= vertexes[now]; ++j) {\n\t\tdp1[now][j] = tmp[j][0];\n\t\tdp2[now][j] = tmp[j][1];\n\t}\n\treturn 0;\n}\nint main() {\n#define int long long\n\tint n;\n\tcin >> n;\n\tREP(i, 5001) {\n\t\tREP(q, 5001) {\n\t\t\tdp1[i][q] = LONG_INF;\n\t\t\tdp2[i][q] = LONG_INF;\n\t\t}\n\t}\n\tREP(i, n) {\n\t\tcin >> costings[i];\n\t}\n\tREP(i, n - 1) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--;\n\t\tb--;\n\t\tvertexs[a].push_back(b);\n\t\tvertexs[b].push_back(a);\n\t}\n\tdfs(0, -1);\n\tREP(i, n + 1) {\n\t\tif (dp1[0][i] < 0 || dp2[0][i] < LONG_INF / 2) {\n\t\t\tcout << i << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 100000000000000;\n\nint n;\nvector<ll> a(5000);\nvector<vector<ll> > adj(5000, vector<ll>());\n//vector<vector<vector<ll> > > dp(5000, vector<vector<ll> >(5000, vector<ll>(2, INF)));\nll dp[5000][5000][2];\nvector<int> edges(5000, 0);\nll sub[5000][5000][2];\n\nvoid chmin(ll& before, ll after) {\n\tif (before > after) before = after;\n\treturn;\n}\n\nint dfs_pre(int x, int p) {\n\tif (x != 0 && adj[x].size() == 1) return 0;\n\tfor (auto v : adj[x]) {\n\t\tif (v == p) continue;\n\t\telse edges[x] += dfs_pre(v, x) + 1;\n\t}\n\treturn edges[x];\n}\n\nvoid dfs(int x, int p) {\n\tfor (auto v : adj[x]) {\n\t\tif (v != p) dfs(v, x);\n\t}\n\n\t//vector<vector<vector<ll> > > sub(n, vector<vector<ll> >(n, vector<ll>(2, INF)));\n\t//ll sub[n][n][2];\n\tfor (int i = 0; i < adj[x].size()+1; ++i)\n\t{\n\t\tfor (int j = 0; j < edges[x]+1; ++j)\n\t\t{\n\t\t\tsub[i][j][0] = INF;\n\t\t\tsub[i][j][1] = INF;\n\t\t}\n\t}\n\tsub[0][0][1] = a[x];\n\tif (a[x] > 0) sub[0][0][0] = a[x];\n\tint i = 0;\n\tint e_cnt = 0;\n\n\tfor (auto v : adj[x]) {\n\t\tif (v == p) continue;\n\t\tfor (int j1 = 0; j1 < e_cnt+1; ++j1)\n\t\t{\n\t\t\tfor (int j2 = 0; j2 < edges[v]+1; ++j2)\n\t\t\t{\n\t\t\t\tchmin(sub[i+1][j1+j2][1], sub[i][j1][0] + dp[v][j2][1]);\n\t\t\t\tchmin(sub[i+1][j1+j2][1], sub[i][j1][1] + dp[v][j2][0]);\n\t\t\t\tchmin(sub[i+1][j1+j2][1], sub[i][j1][1] + dp[v][j2][1]);\n\t\t\t\tif (a[x] > 0) chmin(sub[i+1][j1+j2][0], sub[i][j1][0] + dp[v][j2][0]);\n\n\t\t\t\tif (dp[v][j2][0] < INF/2 || dp[v][j2][1] < 0) {\n\t\t\t\t\tchmin(sub[i+1][j1+j2+1][1], sub[i][j1][1]);\n\t\t\t\t\tif (a[x] > 0) chmin(sub[i+1][j1+j2+1][0], sub[i][j1][0]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\te_cnt += edges[v] + 1;\n\t\ti++;\n\t}\n\tfor (int j = 0; j < edges[x]+1; ++j)\n\t{\n\t\tdp[x][j][0] = sub[i][j][0];\n\t\tdp[x][j][1] = sub[i][j][1];\n\t}\n\n\treturn;\n}\n\nint main() {\n\tfor (int i = 0; i < 5000; ++i)\n\t{\n\t\tfor (int j = 0; j < 5000; ++j)\n\t\t{\n\t\t\tfor (int k = 0; k < 2; ++k)\n\t\t\t{\n\t\t\t\tdp[i][j][k] = INF;\n\t\t\t}\n\t\t}\n\t}\n\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i) cin >> a[i];\n\tfor (int i = 0; i < n-1; ++i)\n\t{\n\t\tint u, v; cin >> u >> v;\n\t\tadj[u-1].push_back(v-1);\n\t\tadj[v-1].push_back(u-1);\n\t}\n\n\tdfs_pre(0, -1);\n\n\tdfs(0, -1);\n\n\tint ans;\n\tfor (int j = 0; j < n; ++j)\n\t{\n\t\tif (dp[0][j][0] < INF/2 || dp[0][j][1] < 0) {\n\t\t\tans = j;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\nconst ll INF=1e15;\nint main(){\n    int n;\n    cin>>n;\n    vector<ll> a(n);\n    for(int i=0;i<n;i++){\n        cin>>a[i];        \n    }\n    vector<vector<int>> g(n);\n    for(int i=0;i<n-1;i++){\n        int u,v;\n        cin>>u>>v;\n        u--,v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    \n    vector<vector<ll>> dp(n);\n    auto cmin=[](ll &lhs,ll rhs){\n        lhs=min(lhs,rhs);\n    };\n    function<int(int,int)> dfs2=[&](int v,int pre){\n        int oki=n;\n        for(int i=0;i<dp[v].size();i++){\n            if(dp[v][i]<0){\n                oki=i;\n                break;\n            }\n        }\n        if(a[v]<0){\n            return 1+oki;\n        }\n        int sum=0;\n        for(auto &to:g[v]){\n            if(to==pre) continue;\n            sum+=dfs2(to,v);\n        }\n        return min(oki+1,sum);\n    };\n    int y=-1;\n    function<void(int,int)> dfs=[&](int v,int pre){\n        int sz=1;\n        int cnt=0;\n        for(auto to:g[v]){\n            if(to==pre) continue;\n            dfs(to,v);\n            sz+=dp[to].size();\n            cnt++;\n        }\n        vector<vector<ll>> dp2(cnt+1);\n        dp2[0].assign(1,a[v]);\n        int idx=0;\n        for(auto to:g[v]){\n            if(to==pre) continue;\n            for(int i=0;i<dp2[idx].size();i++){\n                for(int j=0;j<dp[to].size();j++){\n                    while(dp2[idx+1].size()<=i+j+1){\n                        dp2[idx+1].push_back(INF);\n                    }\n                    cmin(dp2[idx+1][i+j],dp2[idx][i]+dp[to][j]);\n                    if(dp[to][j]<0){\n                        cmin(dp2[idx+1][i+j+1],dp2[idx][i]);\n                    }\n                }\n            }\n            idx++;\n        }\n        dp[v]=dp2[idx];\n        if(a[v]>0 && (pre==-1 || a[pre]<0)){\n            int x=dfs2(v,pre);\n            while(dp[v].size()<=x+1){\n                dp[v].push_back(INF);\n            }\n            if(pre==-1) y=x;\n            cmin(dp[v][x+1],0);\n        }\n        return;\n    };\n    \n    dfs(0,-1);\n    for(int i=0;i<dp[0].size();i++){\n        if(dp[0][i]<0 || y==i){\n            cout<<i<<endl;\n            return 0;\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define ALL(A) A.begin(),A.end()\n#define RALL(A) A.rbegin(),A.rend()\ntypedef long long LL;\ntypedef pair<int,int> P;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\nconst LL mod=1000000007;\nconst LL LINF=1LL<<60;\nconst int INF=1<<30;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\n\nLL a[5001];\nLL dp1[5001][5001][2];\nLL d[5001];\nvector<int> G[5001];\n\nvoid rec(int u,int v){\n    d[u] = 1;\n    for(auto g:G[u]){\n        if(g==v) continue;\n        rec(g,u);\n        d[u] += d[g];\n    }\n    int num = 0;\n    vector<vector<LL>> dp(d[u]+1,vector<LL> (2,LINF));\n    dp[0][0] = a[u];\n    if(a[u] > 0) dp[0][1] = a[u];\n    for(auto g:G[u]){\n        if(g==v) continue;\n        for (int j = num; j >= 0; j--) {\n            LL t0 = dp[j][0], t1 = dp[j][1];\n            dp[j][0] = LINF;dp[j][1] = LINF;\n            for (int k = 0; k <= d[g]; k++) {\n                chmin(dp[j+k][0],dp1[g][k][0]+t0);\n                if(dp1[g][k][0] < 0 || dp1[g][k][1] != LINF) chmin(dp[j+k+1][0],t0);\n                if(a[u]>0){\n                    chmin(dp[j+k][1],dp1[g][k][1]+t1);\n                    if(dp1[g][k][0] < 0 || dp1[g][k][1] != LINF) chmin(dp[j+k+1][1],t1);\n                }\n            }\n        }\n        num += d[g];\n    }\n    for (int i = 0; i <= d[u]; i++) {\n        dp1[u][i][0] = dp[i][0];\n        dp1[u][i][1] = dp[i][1];\n    }\n}\n\nint main(){\n    int n;cin >> n;\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n    for (int i = 0; i < n-1; i++) {\n        int x,y;cin >> x >> y;\n        x--,y--;\n        G[x].pb(y);\n        G[y].pb(x);\n    }\n    for (int i = 0; i < 5001; i++) {\n        for (int j = 0; j < 5001; j++) {\n            for (int k = 0; k < 2; k++) {\n                dp1[i][j][k] = LINF;\n            }\n        }\n    }\n    rec(0,0);\n    for (int i = 0; i <= n; i++) {\n        if(dp1[0][i][0] < 0){\n            cout << i << endl;\n            return 0;\n        }\n        if(dp1[0][i][1] != LINF){\n            cout << i << endl;\n            return 0;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;using ll=long long;using uint=unsigned int;using pii=pair<int,int>;using pll=pair<ll,ll>;using ull = unsigned long long;using ld=long double;template<typename T>void _(const char*s,T h){cerr<<s<<\" = \"<<h<<\"\\n\";}template<typename T,typename...Ts>void _(const char*s,T h,Ts...t){int b=0;while(((b+=*s=='(')-=*s==')')!=0||*s!=',')cerr<<*s++;cerr<<\" = \"<<h<<\",\";_(s+1,t...);}// break continue pop_back 998244353\n#define int ll\n#define pii pll\n#define f first\n#define s second\n#define pb emplace_back\n#define forn(i,n) for(int i=0;i<(n);++i)\n#define sz(a)((int)(a).size())\n#define sqr(x) ((x)*(x))\nstruct init{init(){cin.tie(0);iostream::sync_with_stdio(0);cout<<fixed<<setprecision(10);cerr<<fixed<<setprecision(5);}~init(){\n#ifdef LOCAL\n#define dbg(...) _(#__VA_ARGS__,__VA_ARGS__)\ncerr<<\"Time elapsed: \"<<(double)clock()/CLOCKS_PER_SEC<<\"s.\\n\";\n#else\n#define dbg(...) \n#endif\n}}init;template<typename T,typename U>void upx(T&x,U y){if(x<y)x=y;}template<typename T,typename U>void upn(T&x,U y){if(x>y)x=y;}mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());const int D=4,dx[]={+1,0,-1,0},dy[]={0,+1,0,-1};\nconst int N=5001,OO=1e18;\nint dp[N][N],ba[N][N];\nint a[N];\nvector<int> g[N];\nint sz[N],dv[N],du[N],dt[N];\nvoid dfs(int v,int p=0){\n    sz[v]=1;\n    for(int to:g[v]){\n        if(to^p){\n            dfs(to,v);\n            sz[v]+=sz[to];\n        }\n    }\n    // forn(i,sz[v])dp[v][i]=ba[v][i]=OO;\n    {\n        int maxv=0;\n        forn(i,N)dv[i]=OO;\n        dv[0]=0;\n        for(int to:g[v]){\n            if(to^p){\n                int maxto=sz[to];\n                forn(i,maxv+maxto+2)dt[i]=OO;\n                forn(i,maxto+1){\n                    du[i]=dp[to][i];\n                    if(i&&du[i-1]<0)upn(du[i],0);\n                    if(i&&ba[to][i-1])upn(du[i],0);\n                }\n                forn(i,maxv+1){\n                    forn(j,maxto+1){\n                        upn(dt[i+j],dv[i]+du[j]);\n                    }\n                }\n                forn(i,maxv+maxto+2)dv[i]=dt[i];\n                maxv+=maxto;\n            }\n        }\n        forn(i,sz[v])dp[v][i]=dv[i]+a[v];\n    }\n    if(a[v]>0){\n        int maxv=0;\n        forn(i,N)dv[i]=0;\n        dv[0]=1;\n        for(int to:g[v]){\n            if(to^p){\n                int maxto=sz[to];\n                forn(i,maxv+maxto+2)dt[i]=0;\n                forn(i,maxto+1){\n                    du[i]=(i&&ba[to][i-1]);\n                    if(a[to]>0){\n                        du[i]|=ba[to][i];\n                    }\n                }\n                forn(i,maxv+1){\n                    forn(j,maxto+1){\n                        dt[i+j]|=dv[i]&du[j];\n                    }\n                }\n                forn(i,maxv+maxto+2)dv[i]=dt[i];\n                maxv+=maxto;\n            }\n        }\n        forn(i,sz[v])ba[v][i]=dv[i];\n    }else{\n        forn(i,sz[v])if(dp[v][i]<0)ba[v][i]=1;\n    }\n    dbg(v,a[v]);\n    forn(i,sz[v])dbg(dp[v][i],ba[v][i]);\n    dbg(\"=====\");\n}\nint32_t main(){\n    int n;\n    cin>>n;\n    for(int i=1;i<=n;++i)cin>>a[i];\n    forn(i,n-1){\n        int x,y;\n        cin>>x>>y;\n        g[x].pb(y);\n        g[y].pb(x);\n    }\n    dfs(1);\n    int ans=N;\n    forn(i,n){\n        if(ba[1][i]){\n            ans=i;\n            break;\n        }\n    }\n    cout<<ans<<'\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// this code is not mine, I am just testing something\n#include <bits/stdc++.h>\n#include <type_traits>\nusing namespace std;\n \nusing ll=int64_t;\n#define int ll\n \n#define FOR(i,a,b) for(int i=int(a);i<int(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back\n#define ALL(x) x.begin(),x.end()\nauto& errStream=cerr;\n#ifdef LOCAL\n#define cerr (cerr<<\"-- line \"<<__LINE__<<\" -- \")\n#else\nclass CerrDummy{}cerrDummy;\ntemplate<class T>\nCerrDummy& operator<<(CerrDummy&cd,const T&){\n\treturn cd;\n}\nusing charTDummy=char;\nusing traitsDummy=char_traits<charTDummy>;\nCerrDummy& operator<<(CerrDummy&cd,basic_ostream<charTDummy,traitsDummy>&(basic_ostream<charTDummy,traitsDummy>&)){\n\treturn cd;\n}\n#define cerr cerrDummy\n#endif\n#define REACH cerr<<\"reached\"<<endl\n#define DMP(x) cerr<<#x<<\":\"<<x<<endl\n#define ZERO(x) memset(x,0,sizeof(x))\n#define ONE(x) memset(x,-1,sizeof(x))\n \nusing pi=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n \ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n \ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"{\";\n\tREP(i,(int)v.size()){\n\t\tif(i)os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n \nll read(){\n\tll i;\n\tscanf(\"%\"  SCNd64,&i);\n\treturn i;\n}\n \nvoid printSpace(){\n\tprintf(\" \");\n}\n \nvoid printEoln(){\n\tprintf(\"\\n\");\n}\n \nvoid print(ll x,int suc=1){\n\tprintf(\"%\" PRId64,x);\n\tif(suc==1)\n\t\tprintEoln();\n\tif(suc==2)\n\t\tprintSpace();\n}\n \nstring readString(){\n\tstatic char buf[3341000];\n\tscanf(\"%s\",buf);\n\treturn string(buf);\n}\n \nchar* readCharArray(){\n\tstatic char buf[3341000];\n\tstatic int bufUsed=0;\n\tchar* ret=buf+bufUsed;\n\tscanf(\"%s\",ret);\n\tbufUsed+=strlen(ret)+1;\n\treturn ret;\n}\n \ntemplate<class T,class U>\nvoid chmax(T& a,U b){\n\tif(a<b)\n\t\ta=b;\n}\n \ntemplate<class T,class U>\nvoid chmin(T& a,U b){\n\tif(b<a)\n\t\ta=b;\n}\n \ntemplate<class T>\nT Sq(const T& t){\n\treturn t*t;\n}\n \n#define CAPITAL\nvoid Yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n \nconst ll infLL=LLONG_MAX/3;\n \n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n \nconst int S=5010;\nint a[S],dp1[S][S],dp2[S];\nvi tr[S];\n \nint dfs(int v,int p){\n\tint s=1;\n\tif(a[v]>0)\n\t\tdp2[v]=0;\n\tdp1[v][0]=a[v];\n\tfor(auto ch:tr[v])\n\t\tif(ch!=p){\n\t\t\tint t=dfs(ch,v);\n\t\t\t{\n\t\t\t\tint w=dp2[ch];\n\t\t\t\tREP(i,t)\n\t\t\t\t\tif(dp1[ch][i]<0)\n\t\t\t\t\t\tchmin(w,i+1);\n\t\t\t\tdp2[v]+=w;\n\t\t\t\tchmin(dp2[v],inf);\n\t\t\t}\n\t\t\tREP(i,t)if(dp1[ch][i]<0)\n\t\t\t\tchmin(dp1[ch][i+1],0);\n\t\t\tif(dp2[ch]<t)\n\t\t\t\tchmin(dp1[ch][dp2[ch]+1],0);\n\t\t\tfor(int i=s+t;i>=0;i--){\n\t\t\t\tint w=dp1[v][i];\n\t\t\t\tdp1[v][i]=inf;\n\t\t\t\tREP(j,t+1){\n\t\t\t\t\tchmin(dp1[v][i+j],w+dp1[ch][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\ts+=t;\n\t\t}\n\treturn s;\n}\n \n \nsigned main(){\n\tint n=read();\n\tREP(i,n+1){\n\t\tREP(j,n+1)\n\t\t\tdp1[i][j]=inf;\n\t\tdp2[i]=inf;\n\t}\n\tREP(i,n)\n\t\ta[i]=read();\n\tREP(_,n-1){\n\t\tint u=read()-1,v=read()-1;\n\t\ttr[u].PB(v);\n\t\ttr[v].PB(u);\n\t}\n\tdfs(0,-1);\n\tint ans=dp2[0];\n\tREP(i,n)if(dp1[0][i]<0)\n\t\tchmin(ans,i);\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cmath>  \n#include <cstdlib>\n#include <ctime>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <string> \n#include <vector>\n#include <bitset>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n\nusing namespace std;\nusing ll = long long;\n\n#define REP(i,n) for(long long i = 0; i < (n); i++)\n#define FOR(i, m, n) for(long long i = (m);i < (n); ++i)\n#define ALL(obj) (obj).begin(),(obj).end()\n\ntemplate<class T> using V = vector<T>;\ntemplate<class T, class U> using P = pair<T, U>;\n\nconst ll MOD = (ll)1e9 + 7;\nconst ll MOD2 = 998244353;\nconst ll LLINF = (ll)1e18;\nconst ll INTINF = (ll)1e9;\nconst long double PI = 3.1415926535897932384626433;\n\ntemplate <class T> void corner(bool flg, T hoge) {if (flg) {cout << hoge << endl; exit(0);}}\ntemplate <class T, class U>ostream &operator<<(ostream &o, const map<T, U>&obj) {o << \"{\"; for (auto &x : obj) o << \" {\" << x.first << \" : \" << x.second << \"}\" << \",\"; o << \" }\"; return o;}\ntemplate <class T>ostream &operator<<(ostream &o, const set<T>&obj) {o << \"{\"; for (auto itr = obj.begin(); itr != obj.end(); ++itr) o << (itr != obj.begin() ? \", \" : \"\") << *itr; o << \"}\"; return o;}\ntemplate <class T>ostream &operator<<(ostream &o, const vector<T>&obj) {o << \"{\"; for (int i = 0; i < (int)obj.size(); ++i)o << (i > 0 ? \", \" : \"\") << obj[i]; o << \"}\"; return o;}\ntemplate <class T, class U>ostream &operator<<(ostream &o, const pair<T, U>&obj) {o << \"{\" << obj.first << \", \" << obj.second << \"}\"; return o;}\ntemplate <template <class tmp>  class T, class U> ostream &operator<<(ostream &o, const T<U> &obj) {o << \"{\"; for (auto itr = obj.begin(); itr != obj.end(); ++itr)o << (itr != obj.begin() ? \", \" : \"\") << *itr; o << \"}\"; return o;}\nvoid print(void) {cout << endl;}\ntemplate <class Head> void print(Head&& head) {cout << head;print();}\ntemplate <class Head, class... Tail> void print(Head&& head, Tail&&... tail) {cout << head << \" \";print(forward<Tail>(tail)...);}\ntemplate <class T> void chmax(T& a, const T b){a=max<T>(a,b);}\ntemplate <class T> void chmin(T& a, const T b){a=min<T>(a,b);}\nvoid YN(bool flg) {cout << ((flg) ? \"YES\" : \"NO\") << endl;}\nvoid Yn(bool flg) {cout << ((flg) ? \"Yes\" : \"No\") << endl;}\nvoid yn(bool flg) {cout << ((flg) ? \"yes\" : \"no\") << endl;}\n\nint main() {\n\tint N; cin >> N;\n\tV<ll> A(N); REP(i,N) cin >> A[i];\n\tV<V<int>> edge(N);\n\tREP(i,N-1){\n\t\tint U,V; cin >> U >> V;\n\t\tU--,V--;\n\t\tedge[U].push_back(V);\n\t\tedge[V].push_back(U);\t\t\n\t}\n\tV<int> depth(N,-1),scale(N,1),parent(N,-1);\n\tdepth[0] = 0;\n\tqueue<int> q; q.push(0);\n\twhile(q.size()){\n\t\tint from = q.front();\n\t\tq.pop();\n\t\tfor(auto to: edge[from]){\n\t\t\tif(depth[to]!=-1) continue;\n\t\t\tdepth[to] = depth[from] + 1;\n\t\t\tparent[to] = from;\n\t\t\tq.push(to);\n\t\t}\n\t}\n\tV<P<int,int>> ord(N);\n\tREP(i,N) ord[i] = {-depth[i],i};\n\tsort(ALL(ord));\n\tfor(int i = 0; i < N; ++i) for(auto to: edge[ord[i].second]) if(depth[ord[i].second] > depth[to]) scale[to] += scale[ord[i].second];\n\t\n\tV<V<ll>> dp1(N,V<ll>(N,LLINF)),dp2(N,V<ll>(N,LLINF));\n\tREP(i,N) (A[i]>0?dp1:dp2)[i][0] = A[i];\n\n\tfor(int i = 0; i < N-1; ++i){\n\t\tint from = ord[i].second, to = parent[from];\n\t\tif(depth[to]>depth[from]) continue;\n\t\t\n\t\tV<ll> tmp1(N,LLINF),tmp2(N,LLINF);\n\t\tfor(int j = 0; j < scale[to]; ++j){\n\t\t\tfor(int k = 0; k < scale[from]; ++k){\n\t\t\t\t// merge\n\t\t\t\tchmin(tmp1[j+k],dp1[to][j]+dp1[from][k]);\n\t\t\t\tchmin(tmp2[j+k],dp1[to][j]+dp2[from][k]);\n\t\t\t\tchmin(tmp2[j+k],dp2[to][j]+dp1[from][k]);\n\t\t\t\tchmin(tmp2[j+k],dp2[to][j]+dp2[from][k]);\n\n\t\t\t\t// divide\n\t\t\t\tif(dp1[from][k]<LLINF || dp2[from][k] < 0)chmin(tmp1[j+k+1],dp1[to][j]);\n\t\t\t\tif(dp1[from][k]<LLINF || dp2[from][k] < 0)chmin(tmp2[j+k+1],dp2[to][j]);\n\n\t\t\t}\n\t\t}\n\t\tdp1[to] = tmp1;\n\t\tdp2[to] = tmp2;\n\t}\n\n\tint ans = N-1;\n\tfor(int j = 0; j < N; ++j){\n\t\tif(dp1[0][j]<LLINF) chmin(ans,j);\n\t\tif(dp2[0][j]<0) chmin(ans,j);\n\t}\n\tcout << ans << endl;\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\ntypedef long long ll;\n\ntemplate<class T> bool chkmax(T & a, T b){ if(a < b){ a = b; return true;} return false;}\ntemplate<class T> bool chkmin(T & a, T b){ if(a > b){ a = b; return true;} return false;}\n\nconst int maxn = 5005;\nconst ll llinf = 1e18;\n\nvector<int> adj[maxn];\nint N, a[maxn];\nll h[maxn][2];\nll f[maxn][maxn][2];\nint sub[maxn];\n\nvoid dfs(int u, int p = -1)\n{\n  sub[u] = 1;\n  f[u][0][0] = a[u] < 0 ? 1e18 : a[u];\n  f[u][0][1] = a[u] > 0 ? 1e18 : a[u];\n\n  for(int v : adj[u]) if (v != p) {\n    dfs(v, u);\n    for(int i = 0 ; i < sub[u] + sub[v] ; ++i)\n      h[i][0] = 1e18,\n      h[i][1] = 1e18;\n    for(int i = 0 ; i < sub[u] ; ++i){\n      for(int j = 0 ; j < sub[v] ; ++j){\n        int k = i + j;\n        h[k][0] = min(h[k][0],f[u][i][0] + f[v][j][0]);\n        h[k][1] = min(h[k][1],f[u][i][0] + f[v][j][1]);\n        h[k][1] = min(h[k][1],f[u][i][1] + f[v][j][0]);\n        h[k][1] = min(h[k][1],f[u][i][1] + f[v][j][1]);\n        if (f[v][j][0] < 1e18 || f[v][j][1] < 0)    {\n          h[k + 1][0] = min(h[k + 1][0],f[u][i][0]);\n          h[k + 1][1] = min(h[k + 1][1],f[u][i][1]);\n        }\n      }\n    }\n    sub[u] += sub[v];\n    for(int i = 0 ; i < sub[u] ; ++i)\n      f[u][i][0] = h[i][0],\n      f[u][i][1] = h[i][1];\n  }\n}\n\nsigned main(void)\n{\n  ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n  if(fopen(\"A.INP\", \"r\")){\n    freopen(\"A.INP\", \"r\", stdin);\n    freopen(\"A.OUT\", \"w\", stdout);\n  }\n  cin >> N;\n  for(int i = 1; i <= N; ++i){\n    cin >> a[i];\n  }\n  for(int i = 1; i < N; ++i){\n    int u, v; cin >> u >> v;\n    adj[u].pb(v); adj[v].pb(u);\n  }\n  dfs(1);\n  for(int i = 0; i < N; ++i){\n    if(f[1][i][0] < 1e18 || f[1][i][1] < 0){\n      cout << i;\n      return 0;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define REP(i, n) FOR(i,0,n)\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> bool mmax(T &m, const T q) { if (m < q) {m = q; return true;} else return false; }\ntemplate<typename T> bool mmin(T &m, const T q) { if (m > q) {m = q; return true;} else return false; }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n\nvector<lint> A;\nvector<set<int>> e;\n\nconstexpr lint INF = 1e14;\nvector<vector<lint>> dfs(int now, int prv)\n{\n    vector<vector<lint>> ret(1, vector<lint>(2));\n    ret[0][0] = (A[now] > 0 ? A[now] : INF);\n    ret[0][1] = (A[now] < 0 ? A[now] : INF);\n    for (auto nxt : e[now]) if (nxt != prv)\n    {\n        auto tmp = dfs(nxt, now);\n        vector<vector<lint>> retnew(ret.size() + tmp.size(), vector<lint>(2, INF));\n        REP(i, ret.size()) REP(j, tmp.size())\n        {\n            REP(d, 2) REP(e, 2) mmin(retnew[i + j][d | e], ret[i][d] + tmp[j][e]);\n            REP(d, 2)\n            {\n                if (tmp[j][0] < INF) mmin(retnew[i + j + 1][d], ret[i][d]);\n                if (tmp[j][1] < 0) mmin(retnew[i + j + 1][d], ret[i][d]);\n            }\n        }\n        ret = retnew;\n    }\n    return ret;\n}\n\nint main()\n{\n    int N;\n    cin >> N;\n    A.resize(N);\n    cin >> A;\n    e.resize(N);\n    REP(_, N - 1)\n    {\n        int u, v;\n        cin >> u >> v;\n        u--, v--;\n        e[u].insert(v);\n        e[v].insert(u);\n    }\n    auto ret = dfs(0, -1);\n    REP(i, N)\n    {\n        if (ret[i][0] < INF or ret[i][1] < 0)\n        {\n            cout << i << endl;\n            return 0;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n#define reps(i, n) for (int i = 1; i <= (int) (n); i++)\n#define all(x) (x).begin(), (x).end()\n#define uniq(x) (x).erase(unique(all(x)), (x).end())\n#define bit(n) (1LL << (n))\n#define cdiv(a, b) (((a) - 1) / (b) + 1)\n#define dump(x) cerr << #x \" = \" << (x) << endl\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing pint = pair<int, int>;\nusing vpint = vector<pint>;\ntemplate<typename T> using priority_queue_rev = priority_queue<T, vector<T>, greater<T>>;\nconstexpr double PI = 3.1415926535897932384626433832795028;\nconstexpr int DY[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nconstexpr int DX[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nint gcd(int a, int b) {\n    while (b) { swap(a %= b, b); }\n    return a;\n}\nint lcm(int a, int b) { return a / gcd(a, b) * b; }\nint sgn(int x) { return (x > 0) - (x < 0); }\ntemplate<typename T> void fin(T mes) {\n    cout << mes << endl;\n    exit(0);\n}\ntemplate<typename T, typename U> bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &rhs) {\n    os << \"(\" << rhs.first << \", \" << rhs.second << \")\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\nstruct setup {\n    static constexpr int PREC = 20;\n\n    setup() {\n        cout << fixed << setprecision(PREC);\n        cerr << fixed << setprecision(PREC);\n    };\n} setup;\n\nstruct union_find_tree {\n    std::vector<int> par, size, val;\n    union_find_tree() {}\n    union_find_tree(int n, vint val) : par(n), size(n), val(val) {\n        for (int i = 0; i < n; i++) {\n            par[i] = i;\n            size[i] = 1;\n        }\n    }\n    int get_root(int i) {\n        if (par[i] == i) { return i; }\n        else { return par[i] = get_root(par[i]); }\n    }\n    void unite(int i, int j) {\n        if ((i = get_root(i)) == (j = get_root(j))) { return; }\n        if (size[i] < size[j]) { std::swap(i, j); }\n        par[j] = i;\n        size[i] += size[j];\n        val[i] += val[j];\n    }\n    bool are_same(int i, int j) { return get_root(i) == get_root(j); }\n    int get_size(int i) { return size[get_root(i)]; }\n    int get_val(int i) { return val[get_root(i)]; }\n};\n\nint N;\nint U[5500], V[5500];\nvint G[5500];\nunion_find_tree uf;\npair<vint, int> dfs(int cur, int par) {\n    vint x = {uf.get_val(cur)};\n    if (uf.get_val(cur) < 0) {\n        //コンピュータ\n        for (int to:G[cur]) {\n            if (to == par) { continue; }\n            pair<vint, int> tmp = dfs(to, cur);\n            vint nxt = tmp.first;\n            int cut = tmp.second;\n            vint y(x.size() + nxt.size(), LLONG_MAX);\n            rep(i, x.size()) { y[i + cut + 1] = x[i]; }\n            rep(i, x.size()) {\n                rep(j, nxt.size()) {\n                    chmin(y[i + j], x[i] + nxt[j]);\n                    if (nxt[j] < 0) { chmin(y[i + j + 1], x[i]); }\n                }\n            }\n            x = y;\n            reps(i, x.size() - 1) { chmin(x[i], x[i - 1]); }\n        }\n        return {x, -1};\n    }\n    if (uf.get_val(cur) > 0) {\n        //バッテリー\n        int cut = 0;\n        for (int to:G[cur]) {\n            if (to == par) { continue; }\n            vint nxt = dfs(to, cur).first;\n            vint y(x.size() + nxt.size(), LLONG_MAX);\n            rep(i, x.size()) {\n                rep(j, nxt.size()) {\n                    chmin(y[i + j], x[i] + nxt[j]);\n                    if (nxt[j] < 0) { chmin(y[i + j + 1], x[i]); }\n                }\n            }\n            x = y;\n            reps(i, x.size() - 1) { chmin(x[i], x[i - 1]); }\n            int pl;\n            for (int i = nxt.size(); i >= 0; i--) { if (nxt[i] < 0) { pl = i; }}\n            cut += pl + 1;\n        }\n        return {x, cut};\n    }\n    return {{}, 0};\n}\n\nsigned main() {\n    cin >> N;\n    vint val(N);\n    rep(i, N) { cin >> val[i]; }\n    uf = union_find_tree(N, val);\n    rep(i, N - 1) {\n        cin >> U[i] >> V[i];\n        U[i]--, V[i]--;\n        if (uf.get_val(U[i]) * uf.get_val(V[i]) > 0) { uf.unite(U[i], V[i]); }\n    }\n    rep(i, N - 1) {\n        int u = uf.get_root(U[i]), v = uf.get_root(V[i]);\n        if (u != v) { G[u].push_back(v), G[v].push_back(u); }\n    }\n    pair<vint, int> res = dfs(uf.get_root(0), -1);\n    int ans = N;\n    if (uf.get_val(0) > 0) { ans = res.second; }\n    rep(i, res.first.size()) { if (res.first[i] < 0) { chmin(ans, i); }}\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <limits>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <iterator>\n#include <bitset>\n#include <unordered_map>\n#include <unordered_set>\n\nusing namespace std;\n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)c.size())\n#define ten(n) ((int)1e##n)\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing Pll = pair<ll, ll>;\n\ntemplate<typename ...> static inline int getchar_unlocked(void) { return getchar(); }\ntemplate<typename ...> static inline void putchar_unlocked(int c) { putchar(c); }\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nvoid reader(ll& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nint reader(char c[]) { int i, s = 0; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c[s++] = i; for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c[s++] = i; }c[s] = '\\0'; return s; }\nint reader(string& c) { int i; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c.push_back(i); for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c.push_back(i); }; return sz(c); }\ntemplate <class T, class S> void reader(T& x, S& y) { reader(x); reader(y); }\ntemplate <class T, class S, class U> void reader(T& x, S& y, U& z) { reader(x); reader(y); reader(z); }\ntemplate <class T, class S, class U, class V> void reader(T& x, S& y, U& z, V & w) { reader(x); reader(y); reader(z); reader(w); }\nvoid writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(ll x, char c) { int s = 0, m = 0; char f[20]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(const char c[]) { int i; for (i = 0; c[i] != '\\0'; i++)mypc(c[i]); }\nvoid writer(const string& x, char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\nvoid writer(const char x[], char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\ntemplate<class T> void writerLn(T x) { writer(x, '\\n'); }\ntemplate<class T, class S> void writerLn(T x, S y) { writer(x, ' '); writer(y, '\\n'); }\ntemplate<class T, class S, class U> void writerLn(T x, S y, U z) { writer(x, ' '); writer(y, ' '); writer(z, '\\n'); }\ntemplate<class T, class S, class U, class V> void writerLn(T x, S y, U z, V v) { writer(x, ' '); writer(y, ' '); writer(z, ' '); writer(v, '\\n'); }\ntemplate<class T> void writerArr(T x[], int n) { if (!n) { mypc('\\n'); return; }FOR(i, n - 1)writer(x[i], ' '); writer(x[n - 1], '\\n'); }\ntemplate<class T> void writerArr(vector<T>& x) { writerArr(x.data(), (int)x.size()); }\n\ntemplate<class T> void chmin(T& a, const T& b) { if (a > b) a = b; }\ntemplate<class T> void chmax(T& a, const T& b) { if (a < b) a = b; }\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\ntemplate<class T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\nll mod_pow(ll a, ll n, ll mod) {\n\tll ret = 1;\n\tll p = a % mod;\n\twhile (n) {\n\t\tif (n & 1) ret = ret * p % mod;\n\t\tp = p * p % mod;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\ntemplate<class T> T extgcd(T a, T b, T& x, T& y) { for (T u = y = 1, v = x = 0; a;) { T q = b / a; swap(x -= q * u, u); swap(y -= q * v, v); swap(b -= q * a, a); } return b; }\nll mod_inv(ll a, ll m) { ll x, y; extgcd<ll>(a, m, x, y); return (m + x % m) % m; }\n\n#ifdef _DEBUG\ntemplate <typename ... Args>\nvoid debugPrintf(const char *format, Args const & ... args) {\n\tfprintf(stdout, format, args ...);\n\tfflush(stdout);\n}\n#else\n#define debugPrintf(...)\n#endif\n\n\nll a[5000];\nint allPositiveMn[5000];\nvector<ll> memo[5000];\nvector<int> e[5000];\n\nint getAns(int id) {\n\tint ans = allPositiveMn[id];\n\tFOR(i, sz(memo[id])) if (memo[id][i] < 0) {\n\t\tans = min(ans, i);\n\t\tbreak;\n\t}\n\n\treturn ans;\n}\n\nvoid dfs(int v, int par) {\n\tfor (auto to : e[v]) {\n\t\tif (to == par) continue;\n\t\tdfs(to, v);\n\t}\n\n\tstatic vector<ll> cur, nxt;\n\tnxt.clear();\n\tnxt.push_back(a[v]);\n\tauto updateNext = [](int idx, ll val) {\n\t\tif (sz(nxt) <= idx) {\n\t\t\tnxt.resize(idx + 1, (ll)1e17);\n\t\t}\n\t\tchmin(nxt[idx], val);\n\t};\n\n\tfor (auto to : e[v]) {\n\t\tif (to == par) continue;\n\t\tswap(cur, nxt);\n\t\tnxt.clear();\n\t\tauto& c2 = memo[to];\n\t\tFOR(i, sz(c2)) {\n\t\t\tFOR(j, sz(cur)) {\n\t\t\t\tupdateNext(i + j, c2[i] + cur[j]);\n\t\t\t}\n\t\t}\n\t\tint geta = getAns(to) + 1;\n\t\tFOR(i, sz(cur)) {\n\t\t\tupdateNext(i + geta, cur[i]);\n\t\t}\n\t}\n\tmemo[v].swap(nxt);\n\n\tif (a[v] < 0) {\n\t\tallPositiveMn[v] = ten(5);\n\t} else {\n\t\tfor (auto to : e[v]) {\n\t\t\tif (to == par) continue;\n\t\t\tint add = ten(5);\n\t\t\tFOR(i, sz(memo[to])) {\n\t\t\t\tif (memo[to][i] < 0) {\n\t\t\t\t\tadd = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a[to] > 0) {\n\t\t\t\tadd = min(add, allPositiveMn[to]);\n\t\t\t}\n\t\t\tallPositiveMn[v] += add;\n\t\t}\n\t}\n}\n\nint main() {\n\tint n; reader(n);\n\tFOR(i, n) reader(a[i]);\n\tFOR(i, n - 1) {\n\t\tint a, b; reader(a, b);\n\t\ta--; b--;\n\t\te[a].push_back(b);\n\t\te[b].push_back(a);\n\t}\n\n\tdfs(0, -1);\n\tint ans = getAns(0);\n\twriterLn(ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF (1LL << 60)\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n\nusing namespace std;\n\ntemplate<typename S,typename T>auto&operator<<(ostream&o,pair<S,T>p){return o<<\"{\"<<p.fi<<\",\"<<p.se<<\"}\";}\ntemplate<typename T>auto&operator<<(ostream&o,set<T>s){for(auto&e:s)o<<e<<\" \";return o;}\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,priority_queue<S,T,U>q){while(!q.empty())o<<q.top()<<\" \",q.pop();return o;}\ntemplate<typename K,typename T>auto&operator<<(ostream&o,map<K,T>m){for(auto&e:m)o<<e<<\" \";return o;}\ntemplate<typename T>auto&operator<<(ostream&o,vector<T>v){for(auto&e:v)o<<e<<\" \";return o;}\nvoid ashow(){cout<<endl;}template<typename T,typename...A>void ashow(T t,A...a){cout<<t<<\" \";ashow(a...);}\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\n\nconst int MAX_N = 5005;\n\nvector<int> G[MAX_N];\nll a[MAX_N];\n\nvl dfs(int u, int p)\n{\n    vl dp(2);\n    if(a[u] < 0){\n        dp[0] = INF;\n    }else{\n        dp[0] = 1;\n    }\n    dp[1] = a[u];\n    each(v, G[u]){\n        if(v != p){\n            auto res = dfs(v, u);\n            vl ndp(len(dp)+len(res)-1, INF);\n            if(res[0] < INF){\n                cmn(ndp[0], dp[0] + res[0] - 1);\n            }else{\n                int num = -1;\n                srep(k,1,len(res)){\n                    if(res[k] < 0){\n                        num = k;\n                        break;\n                    }\n                }\n                cmn(ndp[0], dp[0] + num);\n            }\n            srep(j,1,len(dp)){\n                if(res[0] < INF){\n                    cmn(ndp[j+res[0]], dp[j]);\n                }\n                srep(k,1,len(res)){\n                    cmn(ndp[j+k-1], dp[j]+res[k]);\n                }\n            }\n            swap(dp, ndp);\n            srep(j,2,len(dp)){\n                cmn(dp[j], dp[j-1]);\n            }\n        }\n    }\n    return dp;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    rep(i,n){\n        cin >> a[i];\n    }\n    rep(i,n-1){\n        int u, v;\n        cin >> u >> v;\n        G[u-1].pb(v-1), G[v-1].pb(u-1);\n    }\n    auto res = dfs(0, -1);\n    ll ans = INF;\n    if(res[0] < INF) ans = res[0];\n    srep(i,1,len(res)){\n        if(res[i] < 0){\n            cmn(ans, (ll)i);\n            break;\n        }\n    }\n    cout << ans-1 << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <cstdio>\n#include <cstdint>\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cmath>\n#include <climits>\n#include <bitset>\n\n// macros\n#define ll long long int\n#define pb push_back\n#define mk make_pair\n#define pq priority_queue\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n\nusing namespace std;\n\n//  types\ntypedef pair<int, int> P;\ntypedef pair<ll, int> Pl;\ntypedef pair<ll, ll> Pll;\ntypedef pair<double, double> Pd;\n \n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 1e9 + 7;\n\n// solve\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\n\nvector<int> edge[5001];\nvector<int> child[5001];\nint par[5001], num[5001];\nll dp1[5001][5001], dp2[5001][5001];\n\nvoid dfs1(int i){\n  num[i] = 1;\n  rep(j, edge[i].size()){\n    int to = edge[i][j];\n    if(par[to] >= 0)continue;\n    par[to] = i;\n    child[i].pb(to);\n    dfs1(to);\n    num[i] += num[to];\n  }\n}\n\nvector<ll> a;\nint n;\n\nvoid dfs(int i){\n  rep(j, child[i].size()){\n    dfs(child[i][j]);\n  }\n  if(child[i].size() == 0){\n    if(a[i] < 0){\n      dp2[i][1] = a[i];\n    }else{\n      dp1[i][1] = dp2[i][1] = a[i];\n    }\n    return;\n  }\n  if(a[i] > 0){\n    vector<vector<ll> > dp = vector<vector<ll> >(child[i].size()+1, vector<ll>(num[i]+1, linf));\n    dp[0][1] = a[i];\n    int curr = 1;\n    rep(j, child[i].size()){\n      int to = child[i][j];\n      curr += num[to];\n      rep(k, curr+1){\n        for(int l = 1; l <= k; l++){\n          if(l > num[to])break;\n          if(dp1[to][l] < linf || dp2[to][l] < 0)chmin(dp[j+1][k], dp[j][k-l]);\n        }\n        if(a[to] > 0){\n          for(int l = 1; l <= k; l++){\n            if(l > num[to])break;\n            chmin(dp[j+1][k], dp[j][k-l+1] + dp1[to][l]);\n          }\n        }\n      }\n    }\n    rep(j, num[i]+1)dp1[i][j] = dp[child[i].size()][j];\n  }\n\n  vector<vector<ll> > dp = vector<vector<ll> >(child[i].size() +1, vector<ll>(num[i]+1, linf));\n  dp[0][1] = a[i];\n  int curr = 1;\n  rep(j, child[i].size()){\n    int to = child[i][j];\n    curr += num[to];\n    rep(k, curr+1){\n        for(int l = 1; l <= k; l++){\n          if(l > num[to])break;\n          if(dp1[to][l] < linf || dp2[to][l] < 0)chmin(dp[j+1][k], dp[j][k-l]);\n        }\n        for(int l = 1; l <= k; l++){\n          if(l > num[to])break;\n          chmin(dp[j+1][k], dp[j][k-l+1] + dp1[to][l]);\n          chmin(dp[j+1][k], dp[j][k-l+1] + dp2[to][l]);\n        }\n    }\n  }\n  rep(j, num[i]+1)dp2[i][j] = dp[child[i].size()][j];\n\n}\n\nint main(int argc, char const* argv[])\n{\n  cin >> n;\n  a = vector<ll>(n, 0);\n  rep(i, n)cin >> a[i];\n  rep(i, n - 1){\n    int x, y;\n    cin >> x >> y;\n    x--; y--;\n    edge[x].pb(y);\n    edge[y].pb(x);\n  }\n  fill(par, par + n, -1);\n  par[0] = 0;\n  dfs1(0);\n\n  rep(i, n+1){\n    rep(j, n+1){\n      dp1[i][j] = dp2[i][j] = linf;\n    }\n  }\n\n  dfs(0);\n  FOR(i, 1, n+1){\n    if(dp1[0][i] < linf || dp2[0][i] < 0){\n      cout << i - 1 << endl;\n      return 0;\n    }\n  }\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1LL<<60)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n;\nll a[5005];\nll a2[5005];\nvector<int> G[5005];\nvector<int> G2[5005];\nint cmp[5005];\nll dp[5005][5005][2];\nint sz[5005];\nint cnt2[5005];\n\nvoid dfs(int v,int c){\n    cmp[v]=c;\n    if(a[v]<0LL)return;\n    for(int i=0;i<G[v].size();i++){\n        int nv=G[v][i];\n        if(a[nv]>0 && cmp[nv]==-1){\n            dfs(nv,c);\n        }\n    }\n}\n\nint dfs2(int v,int p){\n    sz[v]=1;\n    for(int i=0;i<G2[v].size();i++){\n        int nv=G2[v][i];\n        if(nv!=p){\n            sz[v]+=dfs2(nv,v);\n        }\n    }\n    return sz[v];\n}\n\nll tmp[5005][2];\n\nvoid dfs3(int v,int p){\n    int szc=1;\n    dp[v][0][0]=a2[v];\n    cnt2[v]++;\n    assert(cnt2[v]==1);\n    for(int i=0;i<G2[v].size();i++){\n        int nv=G2[v][i];\n        if(nv==p)continue;\n        dfs3(nv,v);\n        for(int j=0;j<=szc+sz[nv];j++){\n            tmp[j][0]=INF;\n            tmp[j][1]=INF;\n        }\n        for(int j=0;j<szc;j++){\n            for(int k=0;k<sz[nv];k++){\n                tmp[j+k][1]=min(tmp[j+k][1],dp[v][j][0]+dp[nv][k][0]);\n                tmp[j+k][1]=min(tmp[j+k][1],dp[v][j][1]+dp[nv][k][0]);\n                tmp[j+k][1]=min(tmp[j+k][1],dp[v][j][0]+dp[nv][k][1]);\n                tmp[j+k][1]=min(tmp[j+k][1],dp[v][j][1]+dp[nv][k][1]);\n                if(dp[nv][k][1]<0LL || dp[nv][k][0]!=INF)tmp[j+k+1][1]=min(tmp[j+k+1][1],dp[v][j][1]);\n                if(dp[nv][k][1]<0LL || dp[nv][k][0]!=INF)tmp[j+k+1][0]=min(tmp[j+k+1][0],dp[v][j][0]);\n            }\n        }\n        for(int j=0;j<=szc+sz[nv];j++){\n            dp[v][j][0]=tmp[j][0];\n            dp[v][j][1]=tmp[j][1];\n        }\n        szc+=sz[nv];\n    }\n    /*\n    printf(\"%d\\n\",v);\n    for(int i=0;i<=szc;i++){\n        printf(\"%lld %lld\\n\",dp[v][i][0],dp[v][i][1]);\n    }\n     */\n}\n\nint main(void){\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%lld\",&a[i]);\n    }\n    for(int i=0;i<n-1;i++){\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        u--;\n        v--;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    memset(cmp,-1,sizeof(cmp));\n    int sz=0;\n    for(int i=0;i<n;i++){\n        if(cmp[i]==-1){\n            dfs(i,sz++);\n        }\n        //printf(\"%d \",cmp[i]);\n    }\n    //printf(\"\\n\");\n    for(int i=0;i<n;i++){\n        a2[cmp[i]]+=a[i];\n        for(int j=0;j<G[i].size();j++){\n            int nv=cmp[G[i][j]];\n            if(nv!=cmp[i]){\n                G2[cmp[i]].push_back(nv);\n                G2[nv].push_back(cmp[i]);\n            }\n        }\n    }\n    for(int i=0;i<sz;i++){\n        sort(G2[i].begin(),G2[i].end());\n        G2[i].erase(unique(G2[i].begin(),G2[i].end()),G2[i].end());\n    }\n    dfs2(0,-1);\n    for(int i=0;i<=sz;i++){\n        for(int j=0;j<=sz;j++){\n            for(int k=0;k<2;k++){\n                dp[i][j][k]=1LL<<60;\n            }\n        }\n    }\n    dfs3(0,-1);\n    int ans=n;\n    for(int i=0;i<=sz;i++){\n        if(dp[0][i][0]<0LL || dp[0][i][1]<0LL)ans=min(ans,i);\n        if(dp[0][i][0]!=INF)ans=min(ans,i);\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <string>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\n\n\nconst int SZ = 5003;\nint N;\nll A[SZ];\nvector<int> adj[SZ];\n\nvoid readInput() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\tcin >> N;\n\tfor (int i=1; i<=N; i++) cin >> A[i];\n\tfor (int z=0; z<N-1; z++) {\n\t\tint u, v; cin >> u >> v;\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n}\n\n\nint tsz[SZ];\nll D[SZ][SZ];\nbool E[SZ][SZ];\n\nvoid solve(int p, int u) {\n\ttsz[u] = 1;\n\tD[u][0] = A[u];\n\tE[u][0] = A[u] > 0;\n\tif (adj[u].size()==1 && adj[u][0]==p) return;\n\n\tfor (int v : adj[u]) if (v != p) solve(u, v);\n\tfor (int v : adj[u]) if (v != p) {\n\t\tstatic ll DD[SZ];\n\t\tstatic bool EE[SZ];\n\t\tmemset(DD, 1, sizeof(DD));\n\t\tmemset(EE, 0, sizeof(EE));\n\n\t\tfor (int a=0; a<tsz[u]; a++) for (int b=0; b<tsz[v]; b++) {\n\t\t\tDD[a+b] = min(DD[a+b], D[u][a]+D[v][b]);\n\t\t\tif (D[v][b]<0 || E[v][b]) DD[a+b+1] = min(DD[a+b+1], D[u][a]);\n\t\t}\n\t\tif (A[u]>0) for (int a=0; a<tsz[u]; a++) for (int b=0; b<tsz[v]; b++) {\n\t\t\tif (A[v]>0) EE[a+b] = EE[a+b] || (E[u][a] && E[v][b]);\n\t\t\tif (D[v][b]<0 || E[v][b]) EE[a+b+1] = EE[a+b+1] || E[u][a];\n\t\t}\n\n\t\ttsz[u] += tsz[v];\n\t\tmemcpy(D[u], DD, sizeof(D[u]));\n\t\tmemcpy(E[u], EE, sizeof(E[u]));\n\t}\n}\n\n\n\nint main() {\n\treadInput();\n\tsolve(-123, 1);\n\n\tint ans = 1e9;\n\tfor (int k=0; k<N; k++) {\n\t\tif (D[1][k] < 0) ans = min(ans, k);\n\t\tif (E[1][k]) ans = min(ans, k);\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#define INF 100000000000000\nusing namespace std;\n\nint n,u,v,cnt[5001];\nlong long a[5001],dp[5001][5001][2],dp2[5000][5001][2];\nvector<int> g[5001];\nvector<int> child[5001];\nvoid dfs(int x,int y){\n    cnt[x]++;\n    for(int i=0;i<g[x].size();i++){\n        if(g[x][i]!=y){\n            dfs(g[x][i],x);\n            child[x].push_back(g[x][i]);\n        }\n    }\n    for(int i=0;i<=child[x].size();i++){\n        for(int j=0;j<=5000;j++){\n            dp2[i][j][0]=INF;\n            dp2[i][j][1]=INF;\n        }\n    }\n    if(a[x]>0){\n        dp2[0][1][0]=a[x];\n        dp2[0][1][1]=a[x];\n    }\n    else{\n        dp2[0][1][0]=INF;\n        dp2[0][1][1]=a[x];\n    }\n    for(int i=0;i<child[x].size();i++){\n        for(int j=1;j<=cnt[x]+cnt[child[x][i]];j++){\n            for(int k=1;k<=min(j,cnt[child[x][i]]);k++){\n                if(a[x]>0){\n                    dp2[i+1][j][0]=min(dp2[i+1][j][0],dp2[i][j-k+1][0]+dp[child[x][i]][k][0]);\n                }\n                if((dp[child[x][i]][k][0]!=INF||dp[child[x][i]][k][1]<0)&&j!=1){\n                    dp2[i+1][j][0]=min(dp2[i+1][j][0],dp2[i][j-k][0]);\n                    dp2[i+1][j][1]=min(dp2[i+1][j][1],dp2[i][j-k][1]);\n                }\n                dp2[i+1][j][1]=min(dp2[i+1][j][1],dp2[i][j-k+1][1]+dp[child[x][i]][k][1]);\n            }//printf(\"%d %d %d %lld\\n\",x,i,j,dp2[i+1][j][0]);\n        }\n        cnt[x]+=cnt[child[x][i]];\n    }\n    for(int i=0;i<=cnt[x];i++){\n        dp[x][i][0]=dp2[child[x].size()][i][0];\n        dp[x][i][1]=dp2[child[x].size()][i][1];\n    }\n}\n\nint main(){\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%ld\",&a[i+1]);\n    }\n    for(int i=0;i<n-1;i++){\n        scanf(\"%d %d\",&u,&v);\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }//printf(\"\\n\");\n    dfs(1,-1);\n    /*for(int i=1;i<=n;i++){\n        for(int j=1;j<=cnt[i];j++){\n            printf(\"%d %d %lld %lld\\n\",i,j,dp[i][j][0],dp[i][j][1]);\n        }\n    }*/\n    for(int i=0;i<n;i++){\n        if(dp[1][i+1][0]!=INF||dp[1][i+1][1]<0){\n            printf(\"%d\\n\",i);\n            return 0;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n#include <array>\n# include <cassert>\n#include <cctype>\n#include <climits>\n#include <numeric>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <tuple>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n# include <chrono>\n# include <random>\n# include <limits.h>\n# include <unordered_map>\n# include <unordered_set>\n# include <deque>\n# include <cstdio>\n# include <cstring>\n#include <stdio.h>\n#include<time.h>\n#include <stdlib.h>\n#include <cstdint>\n#include <cfenv>\n#include<fstream>\n//#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nlong long MOD = 1000000000 + 7;//1000000000 + 7 998244353 924844033 1000000000 + 9;\nconstexpr long long INF = 1LL << 60;//numeric_limits<LL>::max();\nconst double PI = acos(-1);\n#define fir first\n#define sec second\n#define thi third\n#define debug(x) cerr<<#x<<\": \"<<x<<'\\n'\ntypedef pair<LL, LL> Pll;\ntypedef pair<double, double> Dll;\ntypedef pair<LL, pair<LL, LL>> Ppll;\ntypedef pair<LL, pair<LL, bitset<100001>>> Pbll;\ntypedef pair<LL, pair<LL, vector<LL>>> Pvll;\ntypedef pair<LL, LL> Vec2;\nstruct Tll { LL first, second, third; };\nstruct Fll { LL first, second, third, fourth; };\ntypedef pair<LL, Tll> Ptll;\n#define rep(i,rept) for(LL i=0;i<rept;i++)\n#define Rrep(i,mf) for(LL i=mf-1;i>=0;i--)\nvoid YN(bool f) {\n\tif (f)\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n}\nvoid yn(bool f) {\n\tif (f)\n\t\tcout << \"Yes\" << endl;\n\telse\n\t\tcout << \"No\" << endl;\n}\nstruct Edge { LL to, cost; };\nstruct edge {\n\tLL from, to, cost;\n};\nvector<vector<LL>>g;\nvector<edge>ed;\nvector<Pll>pv;\nset<LL>st;\nmap<Pll, LL>ma;\nint di[4][2] = { { 0,1 },{ 1,0 },{ 0,-1 },{ -1,0 } };\nstring str, ss;\nbool f;\nLL n, m, s, t, h, w, a[6010],sub[6010];\nLL dp1[6010][6010], dp2[6010][6010], to1[6010], to2[6010];\nvoid dfs(int cur, int par) {\n\tsub[cur] = 1;\n\trep(i, 6000)dp1[cur][i] = INF, dp2[cur][i] = INF;\n\tif (a[cur] > 0)\n\t\tdp1[cur][0] = a[cur];\n\telse\n\t\tdp2[cur][0] = a[cur];\n\trep(i, g[cur].size()) {\n\t\tLL v = g[cur][i];\n\t\tif (v == par)continue;\n\t\tdfs(v, cur);\n\t\t\n\t\trep(i, 6000)to1[i] = INF, to2[i] = INF;\n\t\tfor (int i = 0; i < sub[cur]; i++) {\n\t\t\tfor (int j = 0; j < sub[v]; j++) {\n\t\t\t\tif (dp2[v][j] < 0 || dp1[v][j] < INF) {\n\t\t\t\t\tto1[i + j + 1] = min(to1[i + j + 1], dp1[cur][i]);\n\t\t\t\t\tto2[i + j + 1] = min(to2[i + j + 1], dp2[cur][i]);\n\t\t\t\t}\n\t\t\t\tto1[i + j] = min(to1[i + j], dp1[cur][i] + dp1[v][j]);\n\t\t\t\tto2[i + j] = min({ to2[i + j], dp1[cur][i] + dp1[v][j] ,\n\t\t\t\t\tdp2[cur][i] + dp1[v][j] ,dp1[cur][i] + dp2[v][j],dp2[cur][i] + dp2[v][j] });\n\t\t\t}\n\t\t}\n\t\trep(i, 6000)dp1[cur][i] = to1[i], dp2[cur][i] = to2[i];\n\t\tsub[cur] += sub[v];\n\t}\n}\nint main() {\n\tcin >> n;\n\trep(i, n) {\n\t\tcin >> a[i];\n\t}\n\tg.resize(n);\n\trep(i, n - 1) {\n\t\tLL x, y;\n\t\tcin >> x >> y;\n\t\tx--, y--;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\tdfs(0, -1);\n\trep(i, n+1) {\n\t\tif (dp1[0][i] < INF) {\n\t\t\tcout << i << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif (dp2[0][i] < 0) {\n\t\t\tcout << i << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <vector>\n\nusing namespace std;\n\nconst int N = 5011;\nconst long long oo = 1e18;\n\nint n,C[N];\nvector <int> e[N];\nlong long a[N],f[N][N],f1[N];\nbool g[N][N],g1[N];\n\nvoid cal(int u,int p = 0){\n    f[u][0] = a[u]; g[u][0] = a[u] > 0; C[u] = 1;\n\n    for(int &v : e[u]){\n        if(v == p) continue;\n        cal(v,u);\n        // dp\n        for(int i = C[u]; i < C[u] + C[v]; ++i){\n            f1[i] = oo; g1[i] = 0;\n        }\n        for(int i = 0; i < C[u]; ++i){\n            f1[i] = f[u][i]; g1[i] = g[u][i];\n        }\n        C[u] += C[v];\n        for(int i = 0; i < C[u]; ++i){\n            f[u][i] = oo; g[u][i] = 0;\n            for(int j = 0; j <= min(i,C[v]); ++j){\n                f[u][i] = min(f[u][i],f1[i - j] + f[v][j]);\n                g[u][i] = (g[u][i] || (g1[i - j] && g[v][j]));\n            }\n        }\n    }\n    f[u][C[u]] = oo;\n    for(int i = 0; i < C[u]; ++i){\n        //cout << \"f[\"<<u<<\"][\"<<i<<\"] = \" << f[u][i] << endl;\n        //cout << \"g[\"<<u<<\"][\"<<i<<\"] = \" << g[u][i] << endl;\n        if(f[u][i] < 0 || g[u][i]){\n            f[u][i + 1] = min(f[u][i + 1],0LL);\n            g[u][i + 1] = 1;\n        }\n    }\n}\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie();\n\n    cin >> n;\n    for(int i = 1; i <= n; ++i) cin >> a[i];\n    for(int i = 1; i < n; ++i){\n        int u,v;\n        cin >> u >> v;\n        e[u].push_back(v);\n        e[v].push_back(u);\n    }\n\n    cal(1);\n\n    for(int i = 0; i < n; ++i) if(f[1][i] < 0 || g[1][i]){\n        cout << i;\n        break;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst ll INF = 1e18;\n\n#define p_ary(ary,a,b,i) do { cout << \"[\"; for (int i = a;i < b;++i) cout << ary[i] << (b-1 == i ? \"]\\n\" : \", \"); } while(0)\n#define p_map(map,it) do {cout << \"{\";for (auto it = map.begin();;++it) {if (it == map.end()) {cout << \"}\\n\";break;}else cout << \"\" << it->first << \"=>\" << it->second << \", \";}}while(0)\n\nint n;\nvector<int> sz(5010,1);\nvector<ll> a(5010);\nvector<vector<int>> edges(5010);\nvector<vector<ll>> dp0(5010,vector<ll>(5010,INF)),dp1(5010,vector<ll>(5010,INF));\n\nvoid dfs(int u,int par = -1) {\n    (a[u] > 0 ? dp0 : dp1)[u][0] = a[u];\n    for (int& v : edges[u]) if (v != par) {\n        dfs(v,u);\n        vector<ll> temp0(5010,INF),temp1(5010,INF);\n        sz[u] += sz[v];\n        for (int i = 0;i < sz[u];++i) {\n            if (dp0[u][i] == INF) continue;\n            for (int j = 0;j < sz[v];++j) {\n                if (dp0[v][j] == INF) continue;\n                temp0[i+j] = min(temp0[i+j],dp0[u][i]+dp0[v][j]);\n                temp0[i+j+1] = min(temp0[i+j+1],dp0[u][i]);\n            }\n            for (int j = 0;j < sz[v];++j) {\n                if (dp1[v][j] == INF) continue;\n                temp1[i+j] = min(temp1[i+j],dp0[u][i]+dp1[v][j]);\n                if (dp1[v][j] < 0) temp0[i+j+1] = min(temp0[i+j+1],dp0[u][i]);\n\n            }\n        }\n        for (int i = 0;i < sz[u];++i) {\n            if (dp1[u][i] == INF) continue;\n            for (int j = 0;j < sz[v];++j) {\n                if (dp0[v][j] == INF) continue;\n                temp1[i+j] = min(temp1[i+j],dp1[u][i]+dp0[v][j]);\n                temp1[i+j+1] = min(temp1[i+j+1],dp1[u][i]);\n            }\n            for (int j = 0;j < sz[v];++j) {\n                if (dp1[v][j] == INF) continue;\n                temp1[i+j] = min(temp1[i+j],dp1[u][i]+dp1[v][j]);\n                if (dp1[v][j] < 0) temp1[i+j+1] = min(temp1[i+j+1],dp1[u][i]);\n            }\n        }\n        dp0[u] = temp0;\n        dp1[u] = temp1;\n    }\n}\n\nint main() {\n    cin >> n;\n    for (int i = 0;i < n;++i) cin >> a[i];\n    for (int i = 0;i < n-1;++i) {\n        int u,v;\n        cin >> u >> v;\n        u--;v--;\n        edges[u].push_back(v);\n        edges[v].push_back(u);\n    }\n    dfs(0);\n    int ans = n;\n    for (int i = 0;i < n;++i) if (dp0[0][i] < INF) {\n        ans = i;\n        break;\n    }\n    for (int i = 0;i < n;++i) if (dp1[0][i] < INF && dp1[0][i] < 0) {\n        ans = min(ans,i);\n        break;\n    }\n    cout << ans << endl;\n    // for (int i = 0;i < n;++i) p_ary(dp0[i],0,n,j);\n    // cout << endl;\n    // for (int i = 0;i < n;++i) p_ary(dp1[i],0,n,j);\n    // cout << endl;\n    // p_ary(sz,0,n,i);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\n\nint n;\nvector<ll> a,S;\nvector<vector<int>> G;\nll dp[5000][5000][2]={INF},sdp[5000][2]={INF},new_sdp[5000][2]={INF};\n\nvoid dfs(int s,int par){\n    rep(i,G[s].size()){\n        int t=G[s][i];\n        if (t==par) continue;\n        dfs(t,s);\n        S[s]+=S[t]+1;\n    }\n\n    rep(i,S[s]+1){\n        sdp[i][0]=INF;\n        sdp[i][1]=INF;\n        new_sdp[i][0]=INF;\n        new_sdp[i][1]=INF;\n\n    }\n\n    if (a[s]>0) sdp[0][1]=a[s];\n    if (a[s]<0) sdp[0][0]=a[s];\n    int M=0;\n    rep(i,G[s].size()){\n        int t=G[s][i];\n        if (t==par) continue;\n        rep(k,M+S[t]+2) {\n            new_sdp[k][0]=INF;\n            new_sdp[k][1]=INF;\n        }\n        rep(k,M+1){\n            rep(c,S[t]+1){\n                new_sdp[k+c][0]=min(new_sdp[k+c][0],sdp[k][0]+dp[t][c][0]);\n                new_sdp[k+c][0]=min(new_sdp[k+c][0],sdp[k][1]+dp[t][c][0]);\n                new_sdp[k+c][0]=min(new_sdp[k+c][0],sdp[k][0]+dp[t][c][1]);\n                new_sdp[k+c][1]=min(new_sdp[k+c][1],sdp[k][1]+dp[t][c][1]);\n                if (dp[t][c][0]<0) {\n                    new_sdp[k+c+1][0]=min(new_sdp[k+c+1][0],sdp[k][0]);\n                    new_sdp[k+c+1][1]=min(new_sdp[k+c+1][1],sdp[k][1]);\n                }\n                if (dp[t][c][1]<INF) {\n                    new_sdp[k+c+1][0]=min(new_sdp[k+c+1][0],sdp[k][0]);\n                    new_sdp[k+c+1][1]=min(new_sdp[k+c+1][1],sdp[k][1]);\n                }\n            }\n\n        }\n        M+=S[t]+1;\n        rep(k,M+1) {\n            sdp[k][0]=new_sdp[k][0];\n            sdp[k][1]=new_sdp[k][1];\n            //cout <<  k << \" \" << sdp[k][0] << \" \" << sdp[k][1] << endl;;\n        }\n\n    }\n\n    rep(i,M+2){\n        dp[s][i][0]=sdp[i][0];\n        dp[s][i][1]=sdp[i][1];\n    }\n\n    // rep(i,S[s]+1){\n    //     cout << s << \",\" << i << \",\" << 0 << \" \" << dp[s][i][0] << endl;\n    //     cout << s << \",\" << i << \",\" << 1 << \" \" << dp[s][i][1] << endl;\n    // }\n\n}\n\nvoid solve(){\n    cin >> n;\n    a.resize(n,0);\n    G.resize(n,{});\n    S.resize(n,0);\n    rep(i,n) cin >> a[i];\n    rep(i,n-1){\n        int p,q;\n        cin >> p >> q;\n        G[p-1].push_back(q-1);\n        G[q-1].push_back(p-1);\n    }\n\n    dfs(0,-1);\n    ll ans=INF;\n    rep(i,S[0]+1){\n        if (dp[0][i][0]<0) ans=i;\n        if (dp[0][i][1]<INF) ans=i;\n        if (ans<INF) break;\n    }\n\n    cout << ans << endl;\n\n\n    \n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <typeinfo>\n#include <numeric>\n#include <functional>\n#include <unordered_map>\n#include <bitset>\n#include <stack>\n\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nconst ll INF = 1e16;\nconst ll MOD = 1e9 + 7;\n\n#define REP(i, n) for(ll i = 0; i < n; i++)\n\n\n\n\n\nconst int SIZE = 5005;\n\nint num[SIZE];\nll a[SIZE], sdp[SIZE][2], dp[SIZE][SIZE][2];\nvector<vector<int>> g;\n\n\nvoid rec(int v, int par){\n    num[v] = 1;\n    for(auto &child : g[v]){\n        if(child == par) continue;\n        rec(child, v);\n        num[v] += num[child];\n    }\n    \n    for(int i = 0; i <= num[v]; i++){\n        sdp[i][0] = sdp[i][1] = INF;\n    }\n    \n    sdp[0][0] = a[v];\n    if(a[v] > 0){\n        sdp[0][1] = a[v];\n    }\n    \n    int curnum = 0;\n    for(auto &child : g[v]){\n        if(child == par) continue;\n        for(int i = curnum; i >= 0; i--){\n            ll tmp0 = sdp[i][0], tmp1 = sdp[i][1];\n            sdp[i][0] = sdp[i][1] = INF;\n            for(int j = 0; j <= num[child]; j++){\n                sdp[i + j][0] = min(sdp[i + j][0], tmp0 + dp[child][j][0]);\n                if(dp[child][j][0] < 0 || dp[child][j][1] < INF / 2){\n                    sdp[i + j + 1][0] = min(sdp[i + j + 1][0], tmp0);\n                }\n                if(a[v] > 0){\n                    sdp[i + j][1] = min(sdp[i + j][1], tmp1 + dp[child][j][1]);\n                    if(dp[child][j][0] < 0 || dp[child][j][1] < INF / 2){\n                        sdp[i + j + 1][1] = min(sdp[i + j + 1][1], tmp1);\n                    }\n                }\n            }\n        }\n        curnum += num[child];\n    }\n    for(int i = 0; i <= num[v]; i++){\n        dp[v][i][0] = sdp[i][0];\n        dp[v][i][1] = sdp[i][1];\n    }\n}\n\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    for(int i = 0; i < n; i++){\n        scanf(\"%lld\", &a[i]);\n    }\n    g.resize(n);\n    for(int i = 0; i < n - 1; i++){\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        u--; v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    \n    for(int i = 0; i < SIZE; i++){\n        for(int j = 0; j < SIZE; j++){\n            dp[i][j][0] = dp[i][j][1] = INF;\n        }\n    }\n    rec(0, -1);\n    int ans = n;\n    for(int i = 0; i <= n; i++){\n        if(dp[0][i][0] < 0){\n            ans = min(ans, i);\n        }\n        if(dp[0][i][1] < INF / 2){\n            ans = min(ans, i);\n        }\n    }\n    printf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int64_t inf = 1LL << 40;\n\nint64_t a[5000], dp1[5000][5001], dp2[5000][5001], size[5000], merged1[5001], merged2[5001];\nvector<int> graph[5000];\n\ntemplate <typename T>\nvoid ChangeMin(T& var, T t) { var = min(var, t); }\n\nvoid DFS(int root, int parent) {\n  for (int num = 0; num <= 5000; num++) dp1[root][num] = dp2[root][num] = inf;\n\n  size[root] = 1;\n\n  dp1[root][1] = a[root] > 0 ? a[root] : inf;\n  dp2[root][1] = a[root];\n\n  for (int to : graph[root]) {\n    if (to == parent) continue;\n\n    DFS(to, root);\n\n    for (int num = 1; num <= size[root] + size[to]; num++) merged1[num] = merged2[num] = inf;\n\n    for (int num1 = 1; num1 <= size[root]; num1++) {\n      for (int num2 = 1; num2 <= size[to]; num2++) {\n        // 繋げない\n        if (dp1[to][num2] < inf) {\n          ChangeMin(merged1[num1 + num2], dp1[root][num1]);\n          ChangeMin(merged2[num1 + num2], dp2[root][num1]);\n        }\n        if (dp2[to][num2] < 0) {\n          ChangeMin(merged1[num1 + num2], dp1[root][num1]);\n          ChangeMin(merged2[num1 + num2], dp2[root][num1]);\n        }\n\n        // 繋げる\n        ChangeMin(merged1[num1 + num2 - 1], dp1[root][num1] + dp1[to][num2]);\n        ChangeMin(merged2[num1 + num2 - 1], dp2[root][num1] + dp2[to][num2]);\n      }\n    }\n    size[root] += size[to];\n    for (int num = 1; num <= size[root]; num++) {\n      dp1[root][num] = merged1[num];\n      dp2[root][num] = merged2[num];\n    }\n  }\n}\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n\n  for (int i = 0; i < n - 1; i++) {\n    int u, v;\n    cin >> u >> v;\n    u--; v--;\n    graph[u].push_back(v);\n    graph[v].push_back(u);\n  }\n\n  DFS(0, -1);\n\n  for (int num = 1; num <= n; num++) {\n    if (dp1[0][num] < inf or dp2[0][num] < 0) {\n      cout << num - 1 << endl;\n      break;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stdio.h>\n#include <vector>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stdlib.h>\n#include <time.h>\n#include <iomanip>\n#include <math.h>\n#include <bitset>\n\nusing namespace std;\n\n#define taskname \"A\"\n#define LL long long \n#define uLL unsigned long long \n#define FOR(i,l,r) for(int i = l; i <= r; ++i)\n#define REP(i,l,r) for(int i = l; i < r; ++i)\n#define FORD(i,r,l) for(int i = r; i >= l; --i)\n#define REPD(i,r,l) for(int i = r; i > l; --i)\n#define sz(x) (int)((x).size())\n#define all(x) (x).begin(), (x).end()\n#define debug(x) { cerr << #x << \" = \" << x << endl; }\n#define sci(x) int x; scanf(\"%d\", &x);\n#define scii(x, y) int x, y; scanf(\"%d %d\", &x, &y);\n#define sciii(x, y, z) int x, y, z; scanf(\"%d %d %d\", &x, &y, &z);\n#define pi pair<int,int>\n#define pii pair<int,pi>\n#define piLL pair<LL,LL>\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define _USE_MATH_DEFINES \n/* M_PI */\n#define SetLength2(a, n, t) a=((t*) calloc(n, sizeof(t))) + (n)/2\n\nconst int maxN = 5001;\nconst LL oo = 1e17 + 11;\n\nint tcases = 1;\n\nint N,M,total = 0,res = 0;\nvector <int> e[maxN];\nint C[maxN];\nLL W[maxN],A[maxN],F[maxN][maxN],f1[maxN],g1[maxN];\nbool G[maxN][maxN];\npiLL tmp[maxN],fg[maxN];\n\nvoid dfs(int u,int p = 0){\n    W[u] = A[u];\n    C[u] = 1;\n    REP(i,0,e[u].size()){\n        int v = e[u][i];\n        if(v == p) continue;\n        dfs(v,u);\n        W[u] += W[v];\n        C[u] += C[v];\n    }\n}\nvoid cal(int u,int p = 0){\n    REP(i,0,e[u].size()){\n        int v = e[u][i];\n        if(v != p) cal(v,u);\n    }\n    //\n    F[u][0] = W[u];\n    if(C[u] == 1) G[u][0] = A[u] > 0;\n    else{\n        REP(i,0,C[u]) f1[i] = oo,g1[i] = 0;\n        f1[0] = A[u]; g1[0] = A[u] > 0;\n        \n        REP(k,0,e[u].size()){\n            int v = e[u][k];\n            if(v == p) continue;\n            // cal F[u][i]\n            REP(i,0,C[u]){\n                F[u][i] = oo; G[u][i] = 0;\n                FOR(j,0,min(C[v],i)){\n                    F[u][i] = min(F[u][i],f1[i - j] + F[v][j]);\n                    G[u][i] |= g1[i - j] & G[v][j];\n                }\n            }\n            REP(i,0,C[u]) f1[i] = F[u][i],g1[i] = G[u][i];\n        }\n    }\n    REP(i,0,C[u]){\n        if(F[u][i] < 0 || G[u][i]){\n            F[u][i + 1] = min(F[u][i + 1],0LL);\n            G[u][i + 1] = 1;\n        }\n    }\n}\nvoid testcase(){\n\n    cin >> N;\n    FOR(i,1,N) cin >> A[i];\n    \n    REP(i,1,N){\n        scii(u,v);\n        e[u].pb(v);\n        e[v].pb(u);\n    }\n\n    dfs(1);\n\n    int root = 1;\n\n    FOR(i,1,N){\n        FOR(j,0,N) F[i][j] = oo;\n    }\n\n    cal(root);\n    \n    FOR(j,0,N) if(F[root][j] < 0 || G[root][j]){\n        cout << j;\n        return ;\n    }\n}\n\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie();\n    cout.tie();\n    \n    FOR(i,1,tcases) testcase();\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n#define int long long\nint hmt() {int x=0;int c=getchar(),n=0;for(;!isdigit(c);c=getchar()) n=(c=='-');for(;isdigit(c);c=getchar()) x=x*10+c-'0';if(n) x=-x;return x;}\n#define in hmt()\n#define ins ({string x;char c=getchar();for(;c==' '||c=='\\n';c=getchar());for(;c!=' '&&c!='\\n';c=getchar()) x+=c;x;})\n#define forinc(i,a,b) for(int i=a,_b=b;i<=_b;++i)\n#define fordec(i,a,b) for(int i=a;i>=b;--i)\n#define forb(i,BS) for(int i=BS._Find_first();i< BS.size();i = BS._Find_next(i))\n#define forv(a,b) for(auto &a:b)\n#define pb push_back\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define all(a) a.begin(),a.end()\n#define reset(f,x) memset(f,x,sizeof(f))\n#define bit(x,i) ((x>>(i-1))&1)\n#define onbit(x,i) (x|(1<<(i-1)))\n#define offbit(x,i) (x&~(1<<(i-1)))\nconst int N=5010;\nint n,a[N],s[N],f[N][N],g[N][N];\nvector<int> ke[N];\nvoid DFS(int u,int p)\n{\n\tf[u][0]=a[u];\n\tg[u][0]=a[u]>0?a[u]:1e17;\n\tforv(v,ke[u]) if(v!=p)\n\t{\n\t\tDFS(v,u);\n\t\tstatic int h[N];\n\t\tforinc(i,0,s[u]+s[v]) h[i]=1e17;\n\t\tforinc(i,0,s[u]) forinc(j,0,s[v]) h[i+j]=min(h[i+j],f[u][i]+f[v][j]);\n\t\tforinc(i,0,s[u]+s[v]) f[u][i]=h[i],h[i]=1e17;\n\t\tforinc(i,0,s[u]) forinc(j,0,s[v]) h[i+j]=min(h[i+j],g[u][i]+g[v][j]);\n\t\tforinc(i,0,s[u]+s[v]) g[u][i]=h[i];\n\t\ts[u]+=s[v];\n\t}\n\tf[u][++s[u]]=1e17;\n\tfordec(i,s[u]-1,0) if(f[u][i]<0||g[u][i]<1e17)\n\t{\n\t    f[u][i+1]=min(f[u][i+1],0ll);\n\t    g[u][i+1]=min(g[u][i+1],0ll);\n\t}\n}\nmain()\n{\n    //freopen(\"BB.inp\",\"r\",stdin);\n\tn=in;\n\tforinc(i,1,n) a[i]=in;\n\tforinc(i,1,n-1)\n\t{\n\t    int u=in,v=in;\n\t    ke[u].pb(v);\n\t    ke[v].pb(u);\n\t}\n\tDFS(1,0);\n\tint ans=0;\n\twhile(f[1][ans]>=0&&g[1][ans]>=1e17) ++ans;\n\tcout<<ans<<\"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n// #define int ll\nusing PII = pair<ll, ll>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n\ntemplate<typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value==0>::type\nfill_v(T &t, const V &v) { t=v; }\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t, const V &v ) { for(auto &e:t) fill_v(e,v); }\n\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')'; return out;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& vec){\n  for(T& x: vec) {is >> x;} return is;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'['; for(T i: a) {out<<i<<',';} out<<']'; return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; // DRUL\nconst int INF = 1<<30;\nconst ll LLINF = 1LL<<60;\nconst ll MOD = 1000000007;\n\nusing vll = vector<vector<ll>>;\nll a[5010];\nvector<ll> g[5010];\nvll dfs(ll v, ll p) {\n  vll ret(1, vector<ll>(2, LLINF));\n  if(a[v]>0) ret[0][0] = a[v];\n  ret[0][1] = a[v];\n  for(auto to: g[v]) if(to != p) {\n    auto vec = dfs(to, v);\n\n    vll nret(ret.size() + vec.size(), vector<ll>(2, LLINF));\n    REP(i, ret.size()) REP(j, vec.size()) {\n      // vからiまでの辺を切断しない\n      if(ret[i][0] != LLINF && vec[j][0] != LLINF) {\n        chmin(nret[i+j][0], ret[i][0]+vec[j][0]);\n      }\n      if(ret[i][1] != LLINF && vec[j][1] != LLINF) {\n        chmin(nret[i+j][1], ret[i][1]+vec[j][1]);\n      }\n      if(ret[i][0] != LLINF && vec[j][1] != LLINF) {\n        chmin(nret[i+j][1], ret[i][0]+vec[j][1]);\n      }\n      if(ret[i][1] != LLINF && vec[j][0] != LLINF) {\n        chmin(nret[i+j][1], ret[i][1]+vec[j][0]);\n      }\n      // vからiまでの辺を切断する\n      if(ret[i][0] != LLINF && vec[j][0] != LLINF && i+j+1<nret.size()) {\n        chmin(nret[i+j+1][0], ret[i][0]);\n      }\n      if(ret[i][0] != LLINF && vec[j][1] != LLINF && vec[j][1]<0 && i+j+1<nret.size()) {\n        chmin(nret[i+j+1][0], ret[i][0]);\n      }\n      if(ret[i][1] != LLINF && vec[j][0] != LLINF && i+j+1<nret.size()) {\n        chmin(nret[i+j+1][1], ret[i][1]);\n      }\n      if(ret[i][1] != LLINF && vec[j][1] != LLINF && vec[j][1]<0 && i+j+1<nret.size()) {\n        chmin(nret[i+j+1][1], ret[i][1]);\n      }\n    }\n    ret = nret;\n  }\n  // cout << v << \" \" << ret << endl;\n  return ret;\n}\n\nsigned main(void) \n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  ll n;\n  cin >> n;\n  REP(i, n) cin >> a[i];\n  REP(i, n-1) {\n    ll u, v;\n    cin >> u >> v;\n    u--, v--;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n\n  ll ret = INF;\n  auto ans = dfs(0, -1);\n  // REP(i, 2) {\n  //   REP(j, ans.size()) {\n  //     cout << ans[j][i] << \" \";\n  //   }\n  //   cout << endl;\n  // }\n  REP(i, ans.size()) REP(j, 2) {\n    if(j==0 && ans[i][j] != LLINF) chmin(ret, i);\n    if(j==1 && ans[i][j] < 0) chmin(ret, i);\n  }\n  cout << ret << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nconst ll INF = 1e16;\nconst int MAXN = 5050;\n\nusing Arr = array<ll, 2>;\n\nint N;\nint A[MAXN];\nvector<int> adj[MAXN];\n\nvector<Arr> dfs(int v, int p) {\n   vector<Arr> dp(1);\n   dp[0][0] = A[v];\n   if (A[v] > 0) dp[0][1] = A[v];\n   else dp[0][1] = INF;\n   for (int u : adj[v]) if (u != p) {\n      auto nxt = dfs(u, v);\n      vector<Arr> ndp(dp.size() + nxt.size(), Arr{INF, INF});\n      for (int i = 0; i < int(dp.size()); ++i) {\n         for (int j = 0; j < int(nxt.size()); ++j) {\n            // cut this edge\n            if (nxt[j][0] < 0 || nxt[j][1] < INF) {\n               ndp[i + j + 1][0] = min(ndp[i + j + 1][0], dp[i][0]);\n               ndp[i + j + 1][1] = min(ndp[i + j + 1][1], dp[i][1]);\n            }\n            if (dp[i][0] < INF && nxt[j][0] < INF) {\n               ndp[i + j][0] = min(ndp[i + j][0], dp[i][0] + nxt[j][0]);\n            }\n            if (dp[i][1] < INF && nxt[j][1] < INF) {\n               ndp[i + j][1] = min(ndp[i + j][1], dp[i][1] + nxt[j][1]);\n            }\n         }\n      }\n      dp = move(ndp);\n   }\n   return dp;\n}\n\nint main() {\n   ios_base::sync_with_stdio(false);\n   cin >> N;\n   for (int i = 1; i <= N; ++i) cin >> A[i];\n   for (int i = 0; i < N - 1; ++i) {\n      int v, u;\n      cin >> v >> u;\n      adj[v].emplace_back(u);\n      adj[u].emplace_back(v);\n   }\n   auto ans = dfs(1, -1);\n   int z = 0;\n   while (ans[z][0] >= 0 && ans[z][1] == INF) z++;\n   cout << z << \"\\n\";\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\nstruct UnionFind{\n  Int n;\n  vector<Int> r,p;\n  UnionFind(){}\n  UnionFind(Int sz):n(sz),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n  Int find(Int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(Int x,Int y){\n    return find(x)==find(y);\n  }\n  void unite(Int x,Int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];\n    p[y]=x;\n  }\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  auto shrink=\n    [&](){\n      Int n;\n      cin>>n;\n      vector<Int> a(n);\n      for(Int i=0;i<n;i++) cin>>a[i];\n      vector<vector<Int> > G(n);\n      for(Int i=1;i<n;i++){\n        Int x,y;\n        cin>>x>>y;\n        x--;y--;\n        G[x].emplace_back(y);\n        G[y].emplace_back(x);\n      }\n      UnionFind uf(n);\n      for(Int v=0;v<n;v++){\n        for(Int u:G[v]){\n          if(a[v]<0&&a[u]<0) uf.unite(u,v);\n          if(a[v]>0&&a[u]>0) uf.unite(u,v);\n        }\n      }\n      \n      vector<Int> vs;\n      for(Int i=0;i<n;i++){\n        if(uf.find(i)!=i) continue;\n        vs.emplace_back(i);\n      }\n      \n      Int m=vs.size();\n      map<Int, Int> rev;\n      for(Int i=0;i<m;i++) rev[vs[i]]=i;\n\n      vector<set<Int> > H(m);\n      vector<Int> na(m,0);\n      for(Int v=0;v<n;v++){\n        na[rev[uf.find(v)]]+=a[v];\n        for(Int u:G[v]){\n          if(uf.same(u,v)) continue;\n          Int x=rev[uf.find(v)],y=rev[uf.find(u)];\n          H[x].emplace(y);\n          H[y].emplace(x);\n        }\n      }\n      \n      vector<vector<Int> > nG(m);\n      for(Int i=0;i<m;i++) nG[i]=vector<Int>(H[i].begin(),H[i].end());\n      return make_tuple(m,na,nG);      \n    };\n  \n  auto graph=shrink();\n  auto n=get<0>(graph);\n  auto a=get<1>(graph);\n  auto G=get<2>(graph);\n  assert((Int)a.size()==n);\n  assert((Int)G.size()==n);\n\n  if(0){\n    cout<<n<<endl;\n    for(Int i=0;i<n;i++) cout<<a[i]<<\" \";\n    cout<<endl;\n    for(Int v=0;v<n;v++){\n      for(Int u:G[v]){\n        cout<<v<<\" \"<<u<<endl;\n      }\n    }\n  }\n  \n  if(n==1){\n    cout<<0<<endl;\n    return 0;\n  }\n\n  const Int INF = 1e17;\n  vector<vector<Int> > dp(n);\n  vector<Int> sum(n,0);\n  \n  function<void(Int, Int)> dfs=\n    [&](Int v,Int p){\n      for(Int u:G[v])\n        if(u!=p) dfs(u,v);\n      \n      dp[v].resize(1);\n      dp[v][0]=a[v];\n      for(Int u:G[v]){\n        if(u==p) continue;\n        const auto &p=dp[v];\n        const auto &q=dp[u];\n        Int x=p.size();\n        Int y=q.size();\n        vector<Int> nx(x+y,INF);\n        for(Int i=0;i<x;i++){\n          for(Int j=0;j<y;j++){\n            chmin(nx[i+j],p[i]+q[j]);\n            if(q[j]<0) chmin(nx[i+j+1],p[i]);\n          }\n        }\n        if(a[v]<0){          \n          for(Int i=0;i<x;i++)\n            if(i+sum[u]+1<x+y) chmin(nx[i+sum[u]+1],p[i]);\n        }else{\n          Int res=INF;\n          for(Int j=0;j<y;j++)\n            if(q[j]<0) chmin(res,j+1);\n          sum[v]+=res;\n        }\n        swap(dp[v],nx);\n      }      \n      //cout<<v<<\":\"<<a[v]<<endl;\n      //for(Int x:dp[v]) cout<<x<<\" \";\n      //cout<<endl<<endl;;\n    };\n  \n  dfs(0,-1);\n  Int ans=n;\n  //cout<<n<<\":\"<<dp[0].size()<<endl;\n  assert(n==(Int)dp[0].size());\n  for(Int i=0;i<n;i++)\n    if(dp[0][i]<0) chmin(ans,i);\n  \n  if(a[0]>0) chmin(ans,sum[0]);\n  \n  assert(ans<n);  \n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n)  for(long long i=0;i<(long long)(n);i++)\n#define REP(i,k,n) for(long long i=k;i<(long long)(n);i++)\n#define all(a) a.begin(),a.end()\n#define pb push_back\n#define eb emplace_back\n#define lb(v,k) (lower_bound(all(v),k)-v.begin())\n#define ub(v,k) (upper_bound(all(v),k)-v.begin())\n#define fi first\n#define se second\n#define pi M_PI\n#define PQ(T) priority_queue<T>\n#define SPQ(T) priority_queue<T,vector<T>,greater<T>>\n#define dame(a) {out(a);return 0;}\n#define decimal cout<<fixed<<setprecision(15);\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef tuple<ll,ll,ll> PP;\ntypedef tuple<ll,ll,ll,ll> PPP;\ntypedef multiset<ll> S;\nusing vi=vector<ll>;\nusing vvi=vector<vi>;\nusing vvvi=vector<vvi>;\nusing vp=vector<P>;\nusing vvp=vector<vp>;\nusing vb=vector<bool>;\nusing vvb=vector<vb>;\nconst ll inf=1001001001001001001;\nconst int INF=1001001001;\nconst int mod=998244353;\nconst double eps=1e-10;\ntemplate<class T> bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<class T> bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<class T> void out(T a){cout<<a<<'\\n';}\ntemplate<class T> void outp(T a){cout<<'('<<a.fi<<','<<a.se<<')'<<'\\n';}\ntemplate<class T> void outvp(T v){rep(i,v.size())cout<<'('<<v[i].fi<<','<<v[i].se<<')';cout<<'\\n';}\ntemplate<class T> void outvvp(T v){rep(i,v.size())outvp(v[i]);}\ntemplate<class T> void outv(T v){rep(i,v.size()){if(i)cout<<' ';cout<<v[i];}cout<<'\\n';}\ntemplate<class T> void outvv(T v){rep(i,v.size())outv(v[i]);}\ntemplate<class T> bool isin(T x,T l,T r){return (l)<=(x)&&(x)<=(r);}\ntemplate<class T> void yesno(T b){if(b)out(\"yes\");else out(\"no\");}\ntemplate<class T> void YesNo(T b){if(b)out(\"Yes\");else out(\"No\");}\ntemplate<class T> void YESNO(T b){if(b)out(\"YES\");else out(\"NO\");}\ntemplate<class T> void noyes(T b){if(b)out(\"no\");else out(\"yes\");}\ntemplate<class T> void NoYes(T b){if(b)out(\"No\");else out(\"Yes\");}\ntemplate<class T> void NOYES(T b){if(b)out(\"NO\");else out(\"YES\");}\nvoid outs(ll a,ll b){if(a>=inf-100)out(b);else out(a);}\nll gcd(ll a,ll b){if(b==0)return a;return gcd(b,a%b);}\nll modpow(ll a,ll b){a%=mod;if(b==0)return 1;if(b&1)return a*modpow(a,b-1)%mod;ll k=modpow(a,b/2);return k*k%mod;}\nvi val,sz;\nvvi g,dp,dp1;\nvoid dfs(int v,int p){\n    sz[v]=1;\n    for(ll x:g[v])if(x!=p){\n        dfs(x,v);\n        sz[v]+=sz[x];\n    }\n    /*vi sdp(1),sdp1(1);\n    sdp[0]=val[v];\n    if(val[v]>0)sdp1[0]=1;\n    for(ll x:g[v])if(x!=p){\n        vi ndp(sdp.size()+sz[x],inf),ndp1(sdp.size()+sz[x]);\n        rep(i,sdp.size())rep(j,sz[x]){\n            chmin(ndp[i+j],sdp[i]+dp[x][j]);\n            if(dp1[x][j]||dp[x][j]<0)chmin(ndp[i+j+1],sdp[i]);\n            if(sdp1[i]){\n                if(dp[x][j]<0||dp1[x][j])ndp1[i+j+1]=1;\n                if(dp1[x][j])ndp1[i+j]=1;\n            }\n        }\n        sdp=ndp;\n        sdp1=ndp1;\n    }*/\n    vi sdp(sz[v]+1,inf),sdp1(sz[v]+1);\n    sdp[0]=val[v];\n    if(val[v]>0)sdp1[0]=1;\n    int cur=0;\n    for(ll x:g[v])if(x!=p){\n        for(int j=cur;j>=0;j--){\n            ll t=sdp[j],t1=sdp1[j];\n            sdp[j]=inf;sdp1[j]=0;\n            rep(k,sz[x]+1){\n                chmin(sdp[j+k],t+dp[x][j]);\n                if(dp[x][k]<0||dp1[x][k])chmin(sdp[j+k+1],t);\n                if(val[v]>0&&t1){\n                    if(dp1[x][k])sdp1[j+k]=1;\n                    if(dp[x][k]<0||dp1[x][k])sdp1[j+k+1]=1;\n                }\n            }\n        }\n        cur+=sz[x];\n    }\n    rep(j,sz[v]+1){\n        dp[v][j]=sdp[j];\n        dp1[v][j]=sdp1[j];\n    }\n}\nint main(){\n    ll n;cin>>n;\n    val=vi(n);\n    sz=vi(n);\n    dp1=vvi(n,vi(n,inf));\n    dp=vvi(n,vi(n));\n    rep(i,n)cin>>val[i];\n    g=vvi(n);\n    rep(i,n-1){\n        ll a,b;cin>>a>>b;a--;b--;\n        g[a].pb(b);\n        g[b].pb(a);\n    }\n    dfs(0,-1);\n    ll ans=0;\n    while(dp[0][ans]>0&&!dp1[0][ans])ans++;\n    out(ans);\n}"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <cstdio>\n#include <cstdint>\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cmath>\n#include <climits>\n#include <bitset>\n\n// macros\n#define ll long long int\n#define pb push_back\n#define mk make_pair\n#define pq priority_queue\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n\nusing namespace std;\n\n//  types\ntypedef pair<int, int> P;\ntypedef pair<ll, int> Pl;\ntypedef pair<ll, ll> Pll;\ntypedef pair<double, double> Pd;\n \n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 1e9 + 7;\n\n// solve\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\n\nvector<int> edge[5001];\nvector<int> child[5001];\nint par[5001], num[5001];\nll dp1[5001][5001], dp2[5001][5001];\n\nvoid dfs1(int i){\n  num[i] = 1;\n  rep(j, edge[i].size()){\n    int to = edge[i][j];\n    if(par[to] >= 0)continue;\n    par[to] = i;\n    child[i].pb(to);\n    dfs1(to);\n    num[i] += num[to];\n  }\n}\n\nvector<ll> a;\nint n;\n\nvoid dfs(int i){\n  rep(j, child[i].size()){\n    dfs(child[i][j]);\n  }\n  if(child[i].size() == 0){\n    if(a[i] < 0){\n      dp2[i][1] = a[i];\n    }else{\n      dp1[i][1] = dp2[i][1] = a[i];\n    }\n    return;\n  }\n  if(a[i] > 0){\n    vector<vector<ll> > dp = vector<vector<ll> >(num[i]+1, vector<ll>(num[i]+1, linf));\n    dp[0][1] = a[i];\n    rep(j, child[i].size()){\n      int to = child[i][j];\n      rep(k, num[i]+1){\n        for(int l = 1; l <= k; l++){\n          if(dp1[to][l] < linf || dp2[to][l] < 0)chmin(dp[j+1][k], dp[j][k-l]);\n        }\n        if(a[to] > 0){\n          for(int l = 1; l <= k; l++){\n            chmin(dp[j+1][k], dp[j][k-l+1] + dp1[to][l]);\n          }\n        }\n      }\n    }\n    rep(j, num[i]+1)dp1[i][j] = dp[child[i].size()][j];\n  }\n\n  vector<vector<ll> > dp = vector<vector<ll> >(num[i]+1, vector<ll>(num[i]+1, linf));\n  dp[0][1] = a[i];\n  rep(j, child[i].size()){\n    int to = child[i][j];\n    rep(k, num[i]+1){\n        for(int l = 1; l <= k; l++){\n          if(dp1[to][l] < linf || dp2[to][l] < 0)chmin(dp[j+1][k], dp[j][k-l]);\n        }\n        for(int l = 1; l <= k; l++){\n          chmin(dp[j+1][k], dp[j][k-l+1] + dp1[to][l]);\n          chmin(dp[j+1][k], dp[j][k-l+1] + dp2[to][l]);\n        }\n    }\n  }\n  rep(j, num[i]+1)dp2[i][j] = dp[child[i].size()][j];\n\n}\n\nint main(int argc, char const* argv[])\n{\n  cin >> n;\n  a = vector<ll>(n, 0);\n  rep(i, n)cin >> a[i];\n  rep(i, n - 1){\n    int x, y;\n    cin >> x >> y;\n    x--; y--;\n    edge[x].pb(y);\n    edge[y].pb(x);\n  }\n  fill(par, par + n, -1);\n  par[0] = 0;\n  dfs1(0);\n\n  rep(i, n+1){\n    rep(j, n+1){\n      dp1[i][j] = dp2[i][j] = linf;\n    }\n  }\n\n  dfs(0);\n  FOR(i, 1, n+1){\n    if(dp1[0][i] < linf || dp2[0][i] < 0){\n      cout << i - 1 << endl;\n      return 0;\n    }\n  }\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 0x3f3f3f3f\nusing namespace std;\ntypedef long long ll;\nconst int N=5005;\nint n,a[N],si[N],tot,head[N],nex[N<<1],to[N<<1];\nvoid add(int u,int v){to[++tot]=v;nex[tot]=head[u];head[u]=tot;}\nll dp[N][N][2],f[N][2];\nvoid dfs(int u,int p)\n{\n    if(a[u]<0) dp[u][1][1]=a[u];\n    else dp[u][1][0]=a[u];\n    si[u]=1;\n    for(int i=head[u];i;i=nex[i])\n    {\n        int v=to[i];if(v==p) continue;\n        dfs(v,u);\n        memset(f,inf,sizeof(f));\n        for(int j=1;j<=si[u];j++)\n            for(int k=1;k<=si[v];k++)\n        {\n            if((dp[v][k][0]<inf||dp[v][k][1]<0)&&dp[u][j][0]<inf)\n                f[j+k][0]=min(f[j+k][0],dp[u][j][0]);\n            if((dp[v][k][0]<inf||dp[v][k][1]<0)&&dp[u][j][1]<inf)\n                f[j+k][1]=min(f[j+k][1],dp[u][j][1]);\n            for(int h=0;h<2;h++)\n                for(int p=0;p<2;p++)\n                if(dp[u][j][h]<inf&&dp[v][k][p]<inf)\n                f[j+k-1][h|p]=min(f[j+k-1][h|p],dp[u][j][h]+dp[v][k][p]);\n        }\n        si[u]+=si[v];\n        for(int j=1;j<=si[u];j++)\n            dp[u][j][0]=f[j][0],dp[u][j][1]=f[j][1];\n    }\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n    for(int i=1;i<n;i++)\n    {\n        int u,v;scanf(\"%d%d\",&u,&v);\n        add(u,v);add(v,u);\n    }\n    memset(dp,inf,sizeof(dp));\n    dfs(1,0);\n    int ans=0;\n    for(int i=1;i<=n;i++)\n        if(dp[1][i][0]<inf||dp[1][i][1]<0){ans=i-1;break;}\n    printf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define F first\n#define S second\n#define int long long\n#define ll long long\n//#define int  unsigned long long\n#define pb push_back\n//#define double long double\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef  tree< int , null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\nconst int mod = 1e9 + 7;\nconst int N = 5050;\nconst int K = 20;\nint dp1[N], dp2[N][N], sz[N], a[N];\nvector < int > g[N];\nint s[N];\nvoid dfs(int v, int p = -1){\n    sz[v]++;\n    if (a[v] > 0) dp1[v] = 0;\n    for (auto u: g[v]){\n        if (u == p) continue;\n        dfs(u, v);\n        for (int i = 0; i < sz[u]; i++){\n            if (dp1[u] + 1 < N) dp2[u][dp1[u] + 1] = min(dp2[u][dp1[u] + 1], 0LL);\n        }\n        for (int i = 0; i < sz[u]; i++){\n            if (dp2[u][i] <= 0){\n                if (dp2[u][i] != 0) dp1[u] = min(dp1[u], i + 1);\n                dp2[u][i + 1] = min(dp2[u][i + 1], 0LL);\n            }\n        }\n        if (sz[v] == 1){\n            for (int i = 0; i <= sz[u]; i++) dp2[v][i] = dp2[u][i];\n        } else{\n            for (int i = sz[v] + sz[u]; i >= 0; i--){\n                dp2[v][i] = dp2[v][i] + dp2[u][0];\n                for (int j = min(sz[u], i); j >= 1; j--){\n                    dp2[v][i] = min(dp2[v][i], dp2[v][i - j] + dp2[u][j]);\n                }\n            }\n        }\n        sz[v] += sz[u];\n        dp1[v] += dp1[u];\n    }\n   // cout << \"s[v] = \" << s[v] << \" v = \" << v << endl;\n    if (g[v].size() == 1 && p != -1){\n        if (a[v] > 0){\n            dp1[v] = 0;\n            dp2[v][0] = a[v];\n        } else{\n            dp2[v][0] = a[v];\n        }\n    } else{\n        for (int i = 0; i < sz[v]; i++){\n        dp2[v][i] += a[v];\n        }\n    };\n   // cout << \"v = \" << v << \" \" << dp1[v] << endl;\n   // for (int i = 0; i <= sz[v]; i++){\n   //     cout << dp2[v][i] << \" \";\n   // }\n  //  cout << endl;\n}\nmain(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n   // freopen(\"input.txt\", \"r\", stdin);\n    int n;\n    cin >> n;\n    srand(time(NULL));\n    for (int i = 0; i <= n; i++){\n        dp1[i] = 1e15;\n        for (int j = 0; j <= n; j++){\n            dp2[i][j] = 1e15;\n        }\n    }\n    for (int i = 1; i <= n; i++){\n        cin >> a[i];\n    }\n    for (int i = 1; i < n; i++){\n        int u, v;\n        cin >> u >> v;\n        g[u].pb(v);\n        g[v].pb(u);\n    }\n    dfs(1);\n    int ans = dp1[1];\n    for (int i = 0; i <= n; i++){\n        if (dp2[1][i] < 0) ans = min(ans, i);\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define ll  long long\n#define ld  double\n\n#define all(x)  x.begin(),x.end()\n#define sz(x)   (int)x.size()\n\n#define pb  emplace_back\n#define X   first\n#define Y   second\n\nconst int   N   = 5005;\n\ntypedef pair<int,int>   ii;\n\nvector<int> g[N];\n\nint nCh[N];\nll  f[N][N][2];\nll  h[N][2];\nint a[N];\n\nvoid dfs(int u,int p)   {\n    nCh[u] = 1;\n\n    f[u][0][0] = a[u] < 0 ? 1e18 : a[u];\n    f[u][0][1] = a[u] > 0 ? 1e18 : a[u];\n\n    for(int v : g[u])   if (v != p) {\n        dfs(v,u);\n\n        for(int i = 0 ; i < nCh[u] + nCh[v] ; ++i)\n            h[i][0] = 1e18,\n            h[i][1] = 1e18;\n\n        for(int i = 0 ; i < nCh[u] ; ++i)\n        for(int j = 0 ; j < nCh[v] ; ++j)   {\n            int k = i + j;\n            h[k][0] = min(h[k][0],f[u][i][0] + f[v][j][0]);\n            h[k][1] = min(h[k][1],f[u][i][0] + f[v][j][1]);\n            h[k][1] = min(h[k][1],f[u][i][1] + f[v][j][0]);\n            h[k][1] = min(h[k][1],f[u][i][1] + f[v][j][1]);\n\n\n            if (f[v][j][0] < 1e18 || f[v][j][1] < 0)    {\n                h[k + 1][0] = min(h[k + 1][0],f[u][i][0]);\n                h[k + 1][1] = min(h[k + 1][1],f[u][i][1]);\n            }\n        }\n        nCh[u] += nCh[v];\n\n        for(int i = 0 ; i < nCh[u] ; ++i)\n            f[u][i][0] = h[i][0],\n            f[u][i][1] = h[i][1];\n    }\n}\n\nint main()  {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    int n;  cin >> n;\n\n    for(int i = 1 ; i <= n ; ++i)\n        cin >> a[i];\n\n    for(int i = 1 ; i < n ; ++i)    {\n        int x;  cin >> x;\n        int y;  cin >> y;\n\n        g[x].pb(y);\n        g[y].pb(x);\n    }\n\n    dfs(1,0);\n\n    for(int i = 0 ; i < n ; ++i)\n        if (f[1][i][0] < 1e18 || f[1][i][1] < 0)    {\n            cout << i;\n            return  0;\n        }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <set>\n#include <map>\n#include <iostream>\n#include <utility>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <unordered_set>\n#include <unordered_map>\n#include <limits.h>\n#include <cstring>\n#include <tuple>\n#include <cassert>\n#include <numeric>\n#include <iomanip>\nusing namespace std;\n// type alias\ntypedef long long LL;\ntypedef pair< int , int > II;\ntypedef tuple< int, int, int > III;\ntypedef vector<int> VI;\ntypedef vector<string> VS;\ntypedef vector<vector<int>> VVI;\ntypedef unordered_map<int,int> MAPII;\ntypedef unordered_set<int> SETI;\ntemplate<class T> using VV=vector<vector<T>>;\n// minmax\ntemplate<class T> inline T SMIN(T& a, const T b) { return a=(a>b)?b:a; }\ntemplate<class T> inline T SMAX(T& a, const T b) { return a=(a<b)?b:a; }\n// repetition\n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)\n#define REPE(i,n)  for(int i=0;i<=(n);++i)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  for(int i=0;i<(n);++i)\n#define FORR(x,arr) for(auto& x:arr)\n#define SZ(a) int((a).size())\n// collection\n#define ALL(c) (c).begin(),(c).end()\n// DP\n#define MINUS(dp) memset(dp, -1, sizeof(dp))\n#define ZERO(dp) memset(dp, 0, sizeof(dp))\n\n// stdout\n#define println(args...) fprintf(stdout, ##args),putchar('\\n');\n\n// debug cerr\n#define TRACE true\n#define dump(x) if(TRACE) { cerr << #x << \" = \" << (x) << endl; }\n#define dump2(x,y) if(TRACE) { cerr << #x << \" = \" << (x) << \", \" << #y << \" = \" << (y) << endl; }\n#define dump3(x,y,z) if(TRACE) { cerr << #x << \" = \" << (x) << \", \" << #y << \" = \" << (y) << \", \" << #z << \" = \" << (z) << endl; }\n#define dump4(x,y,z,a) if(TRACE) { cerr << #x << \" = \" << (x) << \", \" << #y << \" = \" << (y) << \", \" << #z << \" = \" << (z) << \", \" << #a << \" = \" << (a) << endl; }\n#define dumpf(args...) if(TRACE) { fprintf(stderr, ##args); putchar('\\n'); }\n#define dumpAR(ar) if(TRACE) { FORR(x,(ar)) { cerr << x << ','; } cerr << endl; }\ntemplate<class Iter> void dumpc(Iter begin, Iter end) { if (TRACE) { for(; begin!=end; ++begin) { cerr<<*begin<<','; } cerr<<endl; } }\n\n// $ cp-batch AttackToATree | diff AttackToATree.out -\n// $ g++ -std=c++14 -Wall -O2 -D_GLIBCXX_DEBUG -fsanitize=address AttackToATree.cpp && ./a.out\n\n/*\n \n 1/17/2019\n \n 18:51-19:51 give up\n \n 1/18/2019\n \n 16:56-\n \n https://img.atcoder.jp/aising2019/editorial.pdf\n http://ferin-tech.hatenablog.com/entry/2019/01/13/011705\n http://drken1215.hatenablog.com/entry/2019/01/13/024000\n http://kmjp.hatenablog.jp/entry/2019/01/13/1000\n https://betrue12.hateblo.jp/entry/2019/01/13/030527\n \n https://atcoder.jp/contests/aising2019/submissions/3996371\n  - Clean implementation by @betrue12\n \n Result is upper-bounded by N. Add it to dp parameter.\n \n It's hard to keep `dp[u][cost]`=res in state because cost<=1e13.\n Have `dp[u][res]`=min cost instead.\n \n Key:\n  - transpose key-val in dp recurrence relation\n  - O(N^2) tree dp by children merge\n   - https://topcoder.g.hatena.ne.jp/iwiwi/20120428/1335635594\n \n */\n\nconst int MAX_N=5e3+1;\nLL A[MAX_N];\nVI G[MAX_N];\nint N;\n\nconst LL Inf=1e13;\n\nLL dp[MAX_N][MAX_N][2];\nint cnt[MAX_N];\n\nvoid dfs(int u, int pre) {\n//  dump(u);\n  cnt[u]=1;\n  if(A[u]>0) dp[u][0][0]=A[u];\n  dp[u][0][1]=A[u];\n  FORR(v,G[u]) if(v!=pre) {\n    dfs(v,u);\n    int M=cnt[u]+cnt[v];\n    VV<LL> dp2(M+1,vector<LL>(2,Inf));\n    REP(i,cnt[u])REP(j,cnt[v])REP(k,2)REP(l,2) {\n      // no-cut\n      SMIN(dp2[i+j][k|l],dp[u][i][k]+dp[v][j][l]);\n      \n      // cut\n      if(l==0&&dp[v][j][l]<Inf) SMIN(dp2[i+j+1][k],dp[u][i][k]);\n      if(l==1&&dp[v][j][l]<0) SMIN(dp2[i+j+1][k],dp[u][i][k]);\n    }\n    REPE(i,M)REP(j,2) dp[u][i][j]=dp2[i][j];\n    cnt[u]=M;\n  }\n}\n\nvoid solve() {\n  REP(i,MAX_N)REP(j,MAX_N)REP(k,2)dp[i][j][k]=Inf;\n  dfs(0,-1);\n  int res=MAX_N;\n  REP(i,N) {\n    if(dp[0][i][0]<Inf) res=i;\n    if(dp[0][i][1]<0) res=i;\n//    dump3(i,dp[0][i][0],dp[0][i][1]);\n    if(res<MAX_N) break;\n  }\n  cout<<res<<endl;\n}\n\n/*\nLL dpsum[MAX_N][MAX_N];\nint dppos[MAX_N][MAX_N];\nLL memo[MAX_N][MAX_N];\n\nvoid prep(int u, int pre) {\n  int &allpos=dppos[u][pre];\n  if(allpos>=0) return;\n  allpos=A[u]>0;\n  LL sum=0;\n  FORR(v,G[u]) if(v!=pre) {\n    prep(v,u);\n    sum+=dpsum[v][u];\n    allpos&=dppos[v][u];\n  }\n  dpsum[u][pre]=sum;\n  dppos[u][pre]=allpos;\n}\n\nLL f(int u, int pre) {\n  LL &res=memo[u][pre];\n  if(res>=0) return res;\n  if(dppos[u][pre]) return 0;\n  if(dpsum[u][pre]<0) return 0;\n  res=SZ(G[u])-1;\n  LL tot=0;\n  FORR(v,G[u])if(v!=pre) tot+=f(v,u);\n  FORR(v,G[u])if(v!=pre) {\n    LL a=f(v,u);\n    LL x=tot-a;\n    if(dppos[v][u]&&A[u]>0)\n  }\n}\n\nvoid solve() {\n  int res=MAX_N;\n  MINUS(dpsum),MINUS(dppos),MINUS(memo);\n  REP(i,N-1) {\n    int u=E[i].first,v=E[i].second;\n    prep(u,v);\n    prep(v,u);\n    if(dppos[u][v]&&dppos[v][u]) res=0;\n    if(dpsum[u][v]<0&&dpsum[v][u]<0) res=0;\n    SMIN(res,1LL+f(u,v)+f(v,u));\n  }\n  cout<<res<<endl;\n}*/\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout<<setprecision(12)<<fixed;\n  \n  cin>>N;\n  REP(i,N) cin>>A[i];\n  REP(i,N-1) {\n    int u,v; cin>>u>>v;\n    --u,--v;\n//    E[i]={u,v};\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  solve();\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define F first\n#define S second\n#define int long long\n#define ll long long\n//#define int  unsigned long long\n#define pb push_back\n//#define double long double\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef  tree< int , null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\nconst int mod = 1e9 + 7;\nconst int N = 5050;\nconst int K = 20;\nint dp1[N], dp2[N][N], sz[N], a[N];\nvector < int > g[N];\nint s[N];\nvoid dfs(int v, int p = -1){\n    sz[v]++;\n    if (a[v] > 0) dp1[v] = 0;\n    for (auto u: g[v]){\n        if (u == p) continue;\n        dfs(u, v);\n        for (int i = 0; i < sz[u]; i++){\n            if (dp1[u] + 1 < N) dp2[u][dp1[u] + 1] = min(dp2[u][dp1[u] + 1], 0LL);\n        }\n        for (int i = 0; i < sz[u]; i++){\n            if (dp2[u][i] <= 0){\n                if (dp2[u][i] != 0) dp1[u] = min(dp1[u], i + 1);\n                dp2[u][i + 1] = min(dp2[u][i + 1], 0LL);\n            }\n        }\n        if (sz[v] == 1){\n            for (int i = 0; i <= sz[u]; i++) dp2[v][i] = dp2[u][i];\n        } else{\n            for (int i = sz[v] + sz[u]; i >= 0; i--){\n                dp2[v][i] = dp2[v][i] + dp2[u][0];\n                for (int j = min(sz[u], i); j >= 1; j--){\n                    dp2[v][i] = min(dp2[v][i], dp2[v][i - j] + dp2[u][j]);\n                }\n            }\n        }\n        sz[v] += sz[u];\n        dp1[v] += dp1[u];\n    }\n   // cout << \"s[v] = \" << s[v] << \" v = \" << v << endl;\n    if (g[v].size() == 1 && p != -1){\n        if (a[v] > 0){\n            dp1[v] = 0;\n            dp2[v][0] = a[v];\n        } else{\n            dp2[v][0] = a[v];\n        }\n    } else{\n        for (int i = 0; i < sz[v]; i++){\n        dp2[v][i] += a[v];\n        }\n    };\n   // cout << \"v = \" << v << \" \" << dp1[v] << endl;\n   // for (int i = 0; i <= sz[v]; i++){\n   //     cout << dp2[v][i] << \" \";\n   // }\n  //  cout << endl;\n}\nmain(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n   // freopen(\"input.txt\", \"r\", stdin);\n    int n;\n    cin >> n;\n    srand(time(NULL));\n    for (int i = 0; i <= n; i++){\n        dp1[i] = 1e15;\n        for (int j = 0; j <= n; j++){\n            dp2[i][j] = 1e15;\n        }\n    }\n    for (int i = 1; i <= n; i++){\n        cin >> a[i];\n    }\n    for (int i = 1; i < n; i++){\n        int u, v;\n        cin >> u >> v;\n        g[u].pb(v);\n        g[v].pb(u);\n    }\n    int iv = rand() % n + 1;\n    dfs(iv);\n    int ans = dp1[iv];\n    for (int i = 0; i <= n; i++){\n        if (dp2[iv][i] < 0) ans = min(ans, i);\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\nstruct UnionFind{\n  Int n;\n  vector<Int> r,p;\n  UnionFind(){}\n  UnionFind(Int sz):n(sz),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n  Int find(Int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(Int x,Int y){\n    return find(x)==find(y);\n  }\n  void unite(Int x,Int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];\n    p[y]=x;\n  }\n};\n\n\ntemplate<typename T>\nvector<T> compress(vector<T> v){\n  sort(v.begin(),v.end());\n  v.erase(unique(v.begin(),v.end()),v.end());\n  return v;\n}\n\ntemplate<typename T>\nmap<T, Int> dict(const vector<T> &v){\n  map<T, Int> res;\n  for(Int i=0;i<(Int)v.size();i++)\n    res[v[i]]=i;\n  return res;\n}\n\n//INSERT ABOVE HERE\nsigned main(){\n  auto shrink=\n    [&](){\n      Int n;\n      cin>>n;\n      vector<Int> a(n);\n      for(Int i=0;i<n;i++) cin>>a[i];\n      vector<vector<Int> > G(n);\n      for(Int i=1;i<n;i++){\n        Int x,y;\n        cin>>x>>y;\n        x--;y--;\n        G[x].emplace_back(y);\n        G[y].emplace_back(x);\n      }\n      UnionFind uf(n);\n      for(Int v=0;v<n;v++){\n        for(Int u:G[v]){\n          if(a[v]<0&&a[u]<0) uf.unite(u,v);\n          if(a[v]>0&&a[u]>0) uf.unite(u,v);\n        }\n      }\n      \n      vector<Int> vs;\n      for(Int i=0;i<n;i++){\n        if(uf.find(i)!=i) continue;\n        vs.emplace_back(i);\n      }\n      \n      Int m=vs.size();\n      map<Int, Int> rev;\n      for(Int i=0;i<m;i++) rev[vs[i]]=i;\n\n      vector<set<Int> > H(m);\n      vector<Int> na(m,0);\n      for(Int v=0;v<n;v++){\n        na[rev[uf.find(v)]]+=a[v];\n        for(Int u:G[v]){\n          if(uf.same(u,v)) continue;\n          Int x=rev[uf.find(v)],y=rev[uf.find(u)];\n          H[x].emplace(y);\n          H[y].emplace(x);\n        }\n      }\n      \n      vector<vector<Int> > nG(m);\n      for(Int i=0;i<m;i++) nG[i]=vector<Int>(H[i].begin(),H[i].end());\n      return make_tuple(m,na,nG);      \n    };\n  \n  auto graph=shrink();\n  auto n=get<0>(graph);\n  auto a=get<1>(graph);\n  auto G=get<2>(graph);\n\n  if(0){\n    cout<<n<<endl;\n    for(Int i=0;i<n;i++) cout<<a[i]<<\" \";\n    cout<<endl;\n    for(Int v=0;v<n;v++){\n      for(Int u:G[v]){\n        cout<<v<<\" \"<<u<<endl;\n      }\n    }\n  }\n  \n  if(n==1){\n    cout<<0<<endl;\n    return 0;\n  }\n\n  const Int INF = 1e17;\n  vector<vector<Int> > dp(n);\n  vector<Int> sum(n,0);\n  \n  function<void(Int, Int)> dfs=\n    [&](Int v,Int p){\n      for(Int u:G[v])\n        if(u!=p) dfs(u,v);\n      dp[v].resize(1);\n      dp[v][0]=a[v];\n      for(Int u:G[v]){\n        if(u==p) continue;\n        auto &p=dp[v];\n        auto &q=dp[u];\n        Int x=p.size();\n        Int y=q.size();\n        vector<Int> nx(x+y,INF);\n        for(Int i=0;i<x;i++){\n          for(Int j=0;j<y;j++){\n            chmin(nx[i+j],p[i]+q[j]);\n            if(q[j]<0) chmin(nx[i+j+1],p[i]);\n          }\n        }\n        if(a[v]<0){          \n          for(Int i=0;i<x;i++)\n            if(i+sum[u]+1<x+y) chmin(nx[i+sum[u]+1],p[i]);\n        }else{\n          Int res=INF;\n          for(Int j=0;j<y;j++)\n            if(q[j]<0) chmin(res,j+1);\n          sum[v]+=res;\n        }\n        swap(dp[v],nx);\n      }      \n      //cout<<v<<\":\"<<a[v]<<endl;\n      //for(Int x:dp[v]) cout<<x<<\" \";\n      //cout<<endl<<endl;;\n    };\n  \n  dfs(0,-1);\n  Int ans=n;\n  for(Int i=0;i<n;i++)\n    if(dp[0][i]<0) chmin(ans,i);\n  \n  if(a[0]>0) chmin(ans,sum[0]);  \n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FAST ios_base::sync_with_stdio(false); cin.tie(0);\n#define pb push_back\n#define eb emplace_back\n#define ins insert\n#define f first\n#define s second\n#define cbr cerr << \"hi\\n\"\n#define mmst(x, v) memset((x), v, sizeof ((x)))\n#define siz(x) ll(x.size())\n#define all(x) (x).begin(), (x).end()\n#define lbd(x,y) (lower_bound(all(x),y)-x.begin())\n#define ubd(x,y) (upper_bound(all(x),y)-x.begin())\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());    //can be used by calling rng() or shuffle(A, A+n, rng)\ninline long long rand(long long x, long long y) { return (rng() % (y+1-x)) + x; } //inclusivesss\nstring inline to_string(char c) {string s(1,c);return s;} template<typename T> inline T gcd(T a,T b){ return a==0?llabs(b):gcd(b%a,a); }\n\ntypedef long long ll; \ntypedef long double ld;\n#define FOR(i,s,e) for(ll i=s;i<=ll(e);++i)\n#define DEC(i,s,e) for(ll i=s;i>=ll(e);--i)\ntypedef pair<ll,ll>pi; typedef pair<ll,pi>spi; typedef pair<pi,pi>dpi;\n\n#define LLINF ((long long)1e18)\n#define INF int(1e9+1e6)\n#define MAXN (5006)\nll n,A[MAXN],dp[MAXN][MAXN],sz[MAXN];// if 0 then max, 1 then min\n// bitset<MAXN> dp2[MAXN];\nvector<int>v[MAXN];\nvoid dfs(ll x,ll p){\n\tsz[x]=1;\n\tdp[x][0]=A[x];\n\tfor(auto i:v[x]) if(i^p) dfs(i,x), sz[x]+=sz[i];\n\tFOR(k,1,sz[x]) dp[x][k]=LLINF;\n\tll cur = 1;\n\t// if(A[x]>0)dp2[x][0]=1;\n\tfor(auto i:v[x]) if(i^p) {\n\t\tcur += sz[i];\n\t\tDEC(j,cur,0){\n\t\t\t// dp2[x][j] = dp2[x][j] & dp2[i][0];\n\t\t\tFOR(k,1,min(j,sz[i])){\n              if(dp[x][j]<LLINF) dp[x][j] += dp[i][0];\n\t\t\t\t// dp[x][j]=min(dp[x][j],dp[x][j-k]+dp[i][k]);\n\t\t\t\t// if(1) dp[x][j]=min(dp[x][j],dp[x][j-k]);\n\t\t\t\t// dp2[x][j]=dp2[x][j]|(dp2[x][j-k]&dp2[i][k]);\n\t\t\t\t// if(dp[i][k-1] < 0) dp2[x][j]=dp2[x][j]|dp2[x][j-k];\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tFAST\n\tcin>>n;\n\tFOR(i,1,n)cin>>A[i];\n\tFOR(i,2,n){\n\t\tll a,b;cin>>a>>b;\n\t\tv[a].eb(b),v[b].eb(a);\n\t}\n\tdfs(1,1);\n\tll ans = n-1;\n\tFOR(k,0,n-1) if(dp[1][k] < 0) ans = min(ans, k);\n\t// FOR(k,0,n-1) if(dp2[1][k]) ans = min(ans, k);\n\tcout<<ans<<'\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ostream>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\nconst ll INF = TEN(18);\n\nint n;\nV<ll> a;\nVV<int> g;\n\nusing P = pair<ll, ll>;\nV<P> dfs(int p, int b) {\n    V<P> dp = {{0, INF}};\n    for (int d: g[p]) {\n        if (d == b) continue;\n        auto ndp = dfs(d, p);\n        int k = int(ndp.size());\n        ndp.push_back({INF, INF});\n        for (int i = k - 1; i >= 0; i--) {\n            if (ndp[i].first < INF / 2 || ndp[i].second < 0) ndp[i + 1].first = min(ndp[i + 1].first, 0LL);\n        }\n        int m = int(dp.size()) - 1;\n        V<P> udp(m + k + 1, {INF, INF});\n        for (int i = 0; i <= m; i++) {\n            for (int j = 0; j <= k; j++) {\n                udp[i+j].first = min(udp[i+j].first, dp[i].first + ndp[j].first);\n                udp[i+j].second = min(udp[i+j].second, dp[i].first + ndp[j].second);\n                udp[i+j].second = min(udp[i+j].second, dp[i].second + ndp[j].second);\n                udp[i+j].second = min(udp[i+j].second, dp[i].second + ndp[j].second);\n            }\n        }\n        dp = udp;\n    }\n    int m = int(dp.size()) - 1;\n    V<P> udp(m + 1);\n    for (int i = 0; i <= m; i++) {\n        if (a[p] > 0) {\n            udp[i].first = dp[i].first + a[p];\n            udp[i].second = dp[i].second + a[p];\n        } else {\n            udp[i].first = INF;\n            udp[i].second = min(dp[i].first, dp[i].second) + a[p];\n        }\n    }\n\n    return udp;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout << setprecision(20) << fixed;\n\n    cin >> n;\n    a = V<ll>(n);\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n    g = VV<int>(n);\n    for (int j = 0; j < n - 1; ++j) {\n        int a, b;\n        cin >> a >> b; a--; b--;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n\n    auto dp = dfs(0, -1);\n\n    for (int i = 0; i < n; i++) {\n        if (dp[i].first < INF / 2 || dp[i].second < 0) {\n            cout << i << endl;\n            return 0;\n        }\n    }\n    assert(false);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//注意点\n//Tは3つの値を持つ構造\n//だがワイルドカードとしても使っている\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <complex>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n//@起動時\nstruct initon {\n    initon() {\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.setf(ios::fixed);\n        cout.precision(16);\n    };\n} __initon;\n\n//@必須構造\nstruct T {\n    int f, s, t;\n    T() { f = -1, s = -1, t = -1; }\n    T(int f, int s, int t) : f(f), s(s), t(t) {}\n    bool operator<(const T &r) const {\n        return f != r.f ? f < r.f : s != r.s ? s < r.s : t < r.t;\n        //return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 大きい順\n    }\n    bool operator>(const T &r) const {\n        return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t;\n        //return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 小さい順\n    }\n    int operator[](int i) {\n        assert(i < 3);\n        return i == 0 ? f : i == 1 ? s : t;\n    }\n};\n\n//@マクロ省略系 型,構造\n\n#define int long long\n#define ll long long\n#define double long double\n#define ull unsigned long long\nusing dou = double;\nusing itn = int;\nusing str = string;\nusing bo= bool;\nusing P = pair<int, int>;\n#define F first\n#define S second\n#define vec vector\n#define con continue\n#define bre break\n#define brk break\n#define is ==\n#define rs resize\n\n//マクロ省略系 コンテナ\nusing vi = vector<int>;\n#define vvi(a, b, c) vec<vi> a(b,vi(c))\nusing vb = vector<bool>;\n#define vvb(a, b, c) vec<vb> a(b,vb(c))\nusing vs = vector<string>;\n#define vvs(a, b, c) vec<vs> a(b,vs(c))\nusing vl = vector<ll>;\n#define vvl(a, b, c) vec<vl> a(b,vl(c))\nusing vd = vector<double>;\n#define vvd(a, b, c) vec<vd> a(b,vd(c))\nusing vc=vector<char>;\n#define vvc(a, b, c) vec<vc> a(b,vc(c))\nusing vp = vector<P>;\n#define vvp(a, b, c) vec<vp> a(b,vp(c))\nusing vt = vector<T>;\n#define vvt(a, b, c) vec<vt> a(b,vt(c))\n#define v3i(a, b, c, d) vector<vector<vi>> a(b, vector<vi>(c, vi(d)))\n#define v3d(a, b, c, d) vector<vector<vd>> a(b, vector<vd>(c, vd(d)))\n#define v3m(a, b, c, d) vector<vector<vm>> a(b, vector<vm>(c, vm(d)))\n#define PQ priority_queue<ll, vector<ll>, greater<ll> >\nusing seti = set<int>;\n#define uset unordered_set\n#define mset multiset\n#define umap unordered_map\n#define mmap multimap\n\n//マクロ 繰り返し\n#define _overloadrep(_1, _2, _3, name, ...) name\n# define _rep(i, n) for(int i = 0; i < n ; i++)\n#define repi(i, m, n) for(int i = m; i < n ; i++)\n#define rep(...) _overloadrep(__VA_ARGS__,repi,_rep,)(__VA_ARGS__)\n#define _rer(i, n) for(int i = n; i >= 0 ; i--)\n#define reri(i, m, n) for(int i = m; i >= n ; i--)\n#define rer(...) _overloadrep(__VA_ARGS__,reri,_rer,)(__VA_ARGS__)\n#define fora(a, b) for(auto&& a : b)\n#define forg(gi, ve) if (ve.size())for (int gi = 0, f = ve[gi].from, t = ve[gi].to, c = ve[gi].cost; gi < ve.size(); gi++,f = ve[gi].from, t = ve[gi].to, c = ve[gi].cost)\n\n//マクロ 定数\n#define k4 10101\n#define k5 101010\n#define k6 1010101\n#define k7 10101010\nconst int inf = (int) 1e9 + 100;\nconst ll linf = (ll) 1e18 + 100;\nconst double eps = 1e-9;\nconst int y4[] = {-1, 1, 0, 0};\nconst int x4[] = {0, 0, -1, 1};\nconst int y8[] = {0, 1, 0, -1, -1, 1, 1, -1};\nconst int x8[] = {1, 0, -1, 0, 1, -1, 1, -1};\n\n//マクロ省略形 関数等\n#define arsz(a) (sizeof(a)/sizeof(a[0]))\n#define sz(a) (a.size())\n#define mp make_pair\n#define pb push_back\n#define pf push_front\n#define eb emplace_back\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\n//@拡張系 こう出来るべきというもの\n\n//埋め込み 存在を意識せずに機能を増やされているもの\n// 境界チェック付きvector\nnamespace std_vector_bounds_checking {\n    using namespace std;\n    template<class T, class A = std::allocator<T>> struct vector : std::vector<T, A> {\n        using std::vector<T, A>::vector;\n        typename std::vector<T>::reference operator[](typename std::vector<T>::size_type n) {\n            return this->at(n);\n        }\n    };\n}\nnamespace std {\n    template<> class hash<std::pair<signed, signed>> {\n    public:\n        size_t operator()(const std::pair<signed, signed> &x) const {\n            return hash<ll>()(((ll) x.first << 32) + x.second);\n        }\n    };\n    template<> class hash<std::pair<ll, ll>> {\n    public:\n        size_t operator()(const std::pair<ll, ll> &x) const {\n            return hash<ll>()(((ll) x.first << 32) + x.second);\n        }\n    };\n}\ntemplate<typename T> istream &operator>>(istream &iss, vector<T> &vec) {\n    for (T &x: vec) iss >> x;\n    return iss;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, vector <T> &vec) {\n    for (int i = 0; i < vec.size(); i++)os << vec[i] << (i + 1 == vec.size() ? \"\" : \" \");\n    return os;\n}\ntemplate<typename V, typename H> void resize(vector<V> &vec, const H head) {  //再帰の終端。 可変長templateの長さが 0 になるとこっちが呼ばれる。\n    vec.resize(head);\n}\ntemplate<typename V, typename H, typename ... T> void resize(vector<V> &vec, const H &head, const T ... tail) {\n    vec.resize(head);\n    for (auto &v: vec) resize(v, tail...);\n}\ntemplate<class T> T pop(set<T> &set) {\n    T res = *set.begin();\n    set.erase(set.find(res));\n    return res;\n}\ntemplate<class T> T pop(mset<T> &set) {\n    T res = *set.begin();\n    set.erase(set.find(res));\n    return res;\n}\ntemplate<class T> T popBack(set<T> &set) {\n    T res = *set.rbegin();\n    set.erase(set.find(res));\n    return res;\n}\ntemplate<class T> T popBack(mset<T> &set) {\n    T res = *set.rbegin();\n    set.erase(set.find(res));\n    return res;\n}\ntemplate<class T> inline void sort(vector<T> &a) { sort(a.begin(), a.end()); };\ntemplate<class T> inline void rsort(vector<T> &a) { sort(a.begin(), a.end(), greater<T>()); };\ntemplate<class T> inline void sort(vector<T> &a, int len) { sort(a.begin(), a.begin() + len); };\ntemplate<class T> inline void rsort(vector<T> &a, int len) { sort(a.begin(), a.begin() + len, greater<T>()); };\ntemplate<class T> inline void sort2(vector<vector<T>> &a) { for (int i = 0, n = a.size(); i < n; i++)sort(a[i]); }\ntemplate<class T> inline void rsort2(vector<vector<T>> &a) { for (int i = 0, n = a.size(); i < n; i++)rsort(a[i]); }\ntemplate<typename A, size_t N, typename T> void fill(A (&a)[N], const T &v) { rep(i, N)a[i] = v; }\ntemplate<typename A, size_t N, size_t O, typename T> void fill(A (&a)[N][O], const T &v) { rep(i, N)rep(j, O)a[i][j] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, typename T> void fill(A (&a)[N][O][P], const T &v) { rep(i, N)rep(j, O)rep(k, P)a[i][j][k] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, typename T> void fill(A (&a)[N][O][P][Q], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)a[i][j][k][l] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, typename T> void fill(A (&a)[N][O][P][Q][R], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)a[i][j][k][l][m] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S, typename T> void fill(A (&a)[N][O][P][Q][R][S], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)rep(n, S)a[i][j][k][l][m][n] = v; }\ntemplate<typename V, typename T> void fill(V &x, const T &val) { x = val; }\ntemplate<typename V, typename T> void fill(vector<V> &vect, const T &val) { for (auto &v: vect) fill(v, val); }\n//@汎用便利関数 入力\ntemplate<typename T = int> T in() {\n    T x;\n    cin >> x;\n    return (x);\n}\nstring sin() { return in<string>(); }\ndouble din() { return in<double>(); }\nll lin() { return in<ll>(); }\n#define na(a, n) rep(i,n) cin >> a[i];\n#define nad(a, n) rep(i,n) cin >> a[i], a[i]--;\n#define na3(a, b, c, n) rep(i, n)cin >> a[i] >> b[i] >> c[i];\n#define add2(a, b, n) rep(i, n)a.pb(in()),b.pb(in());\n#define add2d(a, b, n) rep(i, n)a.pb(in()-1),b.pb(in()-1);\n#define add3(a, b, c, n) rep(i, n)a.pb(in()),b.pb(in()),c.pb(in());\n#define add3d(a, b, c, n) rep(i, n)a.pb(in()-1),b.pb(in()-1),c.pb(in());\n#define na2(a, b, n) rep(i, n)cin >> a[i] >> b[i];\n#define nt(a, h, w) rep(hi,h)rep(wi,w) cin >> a[hi][wi];\n#define ntd(a, h, w) rep(hi,h)rep(wi,w) cin >> a[hi][wi], a[hi][wi]--;\n#define ntp(a, h, w) fill(a,'#');rep(hi,1,h+1)rep(wi,1,w+1) cin >> a[hi][wi];\n#define addn(a, n) a.resize(n);na(a,n);\n#define addnd(a, n) a.resize(n);na(a,n);rep(i,n)a[i]--;\n\n\ntemplate<class T> inline void fin(T s) { cout << s << endl, exit(0); }\n\ntemplate<class T> struct edge {\n    int from, to;\n    T cost;\n    int id;\n    int type;\n    edge(int f, int t, T c = 1, int id = -1, int ty = -1) : from(f), to(t), cost(c), id(id), type(ty) {}\n    bool operator<(const edge &b) const { return cost < b.cost; }\n    bool operator>(const edge &b) const { return cost > b.cost; }\n};\n\ntemplate<typename T> class graph {\nprotected:\n    vector<bool> _used;\npublic :\n    vector<vector<edge<T>>> g;\n    vector<edge<T>> edges;\n    int n, root = -1;\n    graph(int n) : n(n) { g.resize(n), _used.resize(n); }\n    void clear() { g.clear(), edges.clear(); }\n    void resize(int n) {\n        this->n = n;\n        g.resize(n);\n        _used.resize(n);\n    }\n    int size() { return g.size(); }\n    bool isleaf(int v) {\n        assert(root != -1);\n        return g[v].size() == 1 && g[v][0].from != root;\n    }\n    vector<edge<T> > &operator[](int i) { return g[i]; }\n    virtual void add(int from, int to, T cost, int ty) = 0;\n    virtual bool used(edge<T> &e) = 0;\n    virtual bool used(int id) = 0;\n    virtual void del(edge<T> &e) = 0;\n    virtual void del(int id) = 0;\n};\n\ntemplate<class T=int> class undigraph : public graph<T> {\npublic:\n    using graph<T>::g;\n    using graph<T>::n;\n    using graph<T>::edges;\n    using graph<T>::_used;\n    undigraph(int n) : graph<T>(n) {\n    }\n    void add(int f, int t, T cost = 1, int ty = -1) {\n        int id = edges.size();\n        g[f].emplace_back(f, t, cost, id, ty);\n        g[t].emplace_back(t, f, cost, id + 1, ty);\n        edges.emplace_back(f, t, cost, id, ty);\n        edges.emplace_back(t, f, cost, id + 1, ty);\n    }\n    void add(edge<T> &e) {\n        int f = e.from, t = e.to, ty = e.type;\n        T cost = e.cost;\n        add(f, t, cost, ty);\n    }\n    bool used(edge<T> &e) { return _used[e.id]; }\n    bool used(int id) { return _used[id]; }\n    void del(edge<T> &e) { _used[e.id] = _used[e.id ^ 1] = 1; }\n    void del(int id) { _used[id] = _used[id ^ 1] = 1; }\n};\n\ntemplate<typename T =ll> class digraph : public graph<T> {\npublic:\n    using graph<T>::g;\n    using graph<T>::n;\n    using graph<T>::edges;\n    using graph<T>::_used;\n\n    digraph(int n) : graph<T>(n) {}\n    void add(int f, int t, T cost = 1, int ty = -1) {\n\n        int id = edges.size();\n        g[f].emplace_back(f, t, cost, ty, id);\n        edges.emplace_back(f, t, cost, ty, id);\n    }\n    bool used(edge<T> &e) { return _used[e.id]; }\n    bool used(int id) { return _used[id]; }\n    void del(edge<T> &e) { _used[e.id] = _used[e.id ^ 1] = 1; }\n    void del(int id) { _used[id] = _used[id ^ 1] = 1; }\n};\n\n\ntemplate<class T, class U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n\nint n, k, m, h, w, x, y, q;\nint cou;\nvi a, b, c;\nv3i(dp, 5000, 5001, 2);//コンピューターしかないか\nvvi(sub, 5050, 2);\nundigraph<> g(0);\nvi es(5050);\n\nvoid ds(int i, int p) {\n    forg(gi, g[i])if (t != p)ds(t, i);\n    int sum = 0;\n    dp[i][0][a[i] < 0] = a[i];\n    forg(gi, g[i]) {\n            if (t == p)continue;\n            rep(ci, sum + 1) {\n                rep(ct, es[t] + 1) {\n                    rep(ki, 2) {\n                        rep(kt, 2) {\n                            //繋ぐ\n                            if (dp[i][ci][ki] < linf && dp[t][ct][kt] < linf)\n                                chmin(sub[ci + ct][ki || kt], dp[i][ci][ki] + dp[t][ct][kt]);\n                            //切る\n                            if (dp[t][ct][kt] < 0 || (!kt && dp[t][ct][kt] != linf))\n                                chmin(sub[ci + ct + 1][ki], dp[i][ci][ki]);\n                        }\n                    }\n                }\n            }\n            sum += es[t] + 1;\n            rep(j, sum + 1)\n                rep(k, 2) {\n                    dp[i][j][k] = sub[j][k];\n                    sub[j][k] = linf;\n\n                }\n        }\n    es[i] = sum;\n}\nsigned main() {\n    cin >> n;\n    addn(a, n);\n    g.resize(n);\n    rep(i, n - 1) {\n        int f, s;\n        cin >> f >> s;\n        --f, --s;\n        g.add(f, s);\n    }\n    fill(dp, linf);\n    fill(sub, linf);\n    ds(0, -1);\n    rep(c, n)rep(k, 2) {\n            if (k) {\n                if (dp[0][c][k] < 0)fin(c);\n            } else if (dp[0][c][k] != linf)fin(c);\n        }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 1000000007;\nconst ll MAX = 4000001;\nconst double eps = 1E-18;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n\tlong long x;\npublic:\n\tmint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n\tmint operator-() const {\n\t\treturn mint(-x);\n\t}\n\tmint& operator+=(const mint& a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint& a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const  mint& a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint& a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\n\nmint pw(mint a, ll b) {\n\tif (b == 0) { return 1; }\n\tmint ret = pw(a, b >> 1);\n\tret *= ret;\n\tif (b & 1) { ret *= a; }\n\treturn ret;\n}\n\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<vector<vector<ll>>> vvvll;\n\ntypedef vector<mint> vmint;\ntypedef vector<vector<mint>> vvmint;\ntypedef vector<vector<vector<mint>>> vvvmint;\n\n//////////////////////////////////////\nll N;\nvll A;\nvvll g;\n\nvvll mn;\nvll dp1;\nvll dp2;\n\nvll merge(vll a, vll b) {\n\t//rep(i, a.size())cout << a[i] << \" \";\n\t//cout << endl;\n\t//rep(i, b.size())cout << b[i] << \" \";\n\t//cout << endl;\n\n\tvll c(a.size() + b.size() - 1, INF);\n\trep(i, c.size()) {\n\t\trep(j, b.size()) {\n\t\t\tif (i - j >= 0 && i - j < a.size())c[i] = min(c[i], a[i - j] + b[j]);\n\t\t}\n\t}\n\n\treturn c;\n}\n\nvoid dfs(ll u, ll v) {\n\tmn[v].assign(1, A[v]);\n\n\tfor (ll w : g[v]) {\n\t\tif (u == w) { continue; }\n\t\tdfs(v, w);\n\n\t\tvll b(mn[w].size() + 1, INF);\n\t\trep(i, mn[w].size()+1) {\n\t\t\tif(i<mn[w].size())b[i] = mn[w][i];\n\t\t\tif (i >= dp1[w] + 1) { b[i] = min(0, b[i]); }\n\t\t}\n\t\tmn[v]=merge(mn[v], b);\n\t}\n\n\tif (A[v] < 0) { dp1[v] = INF; }\n\telse {\n\t\tdp1[v] = 0;\n\t\tfor (ll w : g[v]) {\n\t\t\tif (u == w) { continue; }\n\t\t\tdp1[v] += min(dp1[w], dp2[w] + 1);\n\t\t}\n\t}\n\n\tdp2[v] = INF;\n\trep(i, mn[v].size()) {\n\t\tif (mn[v][i] < 0) { dp2[v] = i; break; }\n\t}\n\n\t//cout << v << \" \" << dp1[v] << \" \" << dp2[v] << endl;\n\t//for (ll x : mn[v]) { cout << x << \" \"; }\n\t//cout << endl;\n\n\treturn;\n}\n\nint main() {\n\tcin >> N;\n\tA.assign(N + 1, 0);\n\trepn(i, N)cin >> A[i];\n\n\tg.resize(N + 1);\n\trepn(i, N-1) {\n\t\tll u, v;\n\t\tcin >> u >> v;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\n\tmn.resize(N + 1);\n\tdp1.resize(N + 1);\n\tdp2.resize(N + 1);\n\n\tdfs(0, 1);\n\n\tcout << min(dp1[1], dp2[1]) << endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//注意点\n//Tは3つの値を持つ構造\n//だがワイルドカードとしても使っている\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <complex>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n//@起動時\nstruct initon {\n    initon() {\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.setf(ios::fixed);\n        cout.precision(16);\n    };\n} __initon;\n\n//@必須構造\nstruct T {\n    int f, s, t;\n    T() { f = -1, s = -1, t = -1; }\n    T(int f, int s, int t) : f(f), s(s), t(t) {}\n    bool operator<(const T &r) const {\n        return f != r.f ? f < r.f : s != r.s ? s < r.s : t < r.t;\n        //return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 大きい順\n    }\n    bool operator>(const T &r) const {\n        return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t;\n        //return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 小さい順\n    }\n    int operator[](int i) {\n        assert(i < 3);\n        return i == 0 ? f : i == 1 ? s : t;\n    }\n};\n\n//@マクロ省略系 型,構造\n\n#define int long long\n#define ll long long\n#define double long double\n#define ull unsigned long long\nusing dou = double;\nusing itn = int;\nusing str = string;\nusing bo= bool;\nusing P = pair<int, int>;\n#define F first\n#define S second\n#define vec vector\n#define con continue\n#define bre break\n#define brk break\n#define is ==\n#define rs resize\n\n//マクロ省略系 コンテナ\nusing vi = vector<int>;\n#define vvi(a, b, c) vec<vi> a(b,vi(c))\nusing vb = vector<bool>;\n#define vvb(a, b, c) vec<vb> a(b,vb(c))\nusing vs = vector<string>;\n#define vvs(a, b, c) vec<vs> a(b,vs(c))\nusing vl = vector<ll>;\n#define vvl(a, b, c) vec<vl> a(b,vl(c))\nusing vd = vector<double>;\n#define vvd(a, b, c) vec<vd> a(b,vd(c))\nusing vc=vector<char>;\n#define vvc(a, b, c) vec<vc> a(b,vc(c))\nusing vp = vector<P>;\n#define vvp(a, b, c) vec<vp> a(b,vp(c))\nusing vt = vector<T>;\n#define vvt(a, b, c) vec<vt> a(b,vt(c))\n#define v3i(a, b, c, d) vector<vector<vi>> a(b, vector<vi>(c, vi(d)))\n#define v3d(a, b, c, d) vector<vector<vd>> a(b, vector<vd>(c, vd(d)))\n#define v3m(a, b, c, d) vector<vector<vm>> a(b, vector<vm>(c, vm(d)))\n#define PQ priority_queue<ll, vector<ll>, greater<ll> >\nusing seti = set<int>;\n#define uset unordered_set\n#define mset multiset\n#define umap unordered_map\n#define mmap multimap\n\n//マクロ 繰り返し\n#define _overloadrep(_1, _2, _3, name, ...) name\n# define _rep(i, n) for(int i = 0; i < n ; i++)\n#define repi(i, m, n) for(int i = m; i < n ; i++)\n#define rep(...) _overloadrep(__VA_ARGS__,repi,_rep,)(__VA_ARGS__)\n#define _rer(i, n) for(int i = n; i >= 0 ; i--)\n#define reri(i, m, n) for(int i = m; i >= n ; i--)\n#define rer(...) _overloadrep(__VA_ARGS__,reri,_rer,)(__VA_ARGS__)\n#define fora(a, b) for(auto&& a : b)\n#define forg(gi, ve) if (ve.size())for (int gi = 0, f = ve[gi].from, t = ve[gi].to, c = ve[gi].cost; gi < ve.size(); gi++,f = ve[gi].from, t = ve[gi].to, c = ve[gi].cost)\n\n//マクロ 定数\n#define k4 10101\n#define k5 101010\n#define k6 1010101\n#define k7 10101010\nconst int inf = (int) 1e9 + 100;\nconst ll linf = (ll) 1e18 + 100;\nconst double eps = 1e-9;\nconst int y4[] = {-1, 1, 0, 0};\nconst int x4[] = {0, 0, -1, 1};\nconst int y8[] = {0, 1, 0, -1, -1, 1, 1, -1};\nconst int x8[] = {1, 0, -1, 0, 1, -1, 1, -1};\n\n//マクロ省略形 関数等\n#define arsz(a) (sizeof(a)/sizeof(a[0]))\n#define sz(a) (a.size())\n#define mp make_pair\n#define pb push_back\n#define pf push_front\n#define eb emplace_back\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\n//@拡張系 こう出来るべきというもの\n\n//埋め込み 存在を意識せずに機能を増やされているもの\n// 境界チェック付きvector\nnamespace std_vector_bounds_checking {\n    using namespace std;\n    template<class T, class A = std::allocator<T>> struct vector : std::vector<T, A> {\n        using std::vector<T, A>::vector;\n        typename std::vector<T>::reference operator[](typename std::vector<T>::size_type n) {\n            return this->at(n);\n        }\n    };\n}\nnamespace std {\n    template<> class hash<std::pair<signed, signed>> {\n    public:\n        size_t operator()(const std::pair<signed, signed> &x) const {\n            return hash<ll>()(((ll) x.first << 32) + x.second);\n        }\n    };\n    template<> class hash<std::pair<ll, ll>> {\n    public:\n        size_t operator()(const std::pair<ll, ll> &x) const {\n            return hash<ll>()(((ll) x.first << 32) + x.second);\n        }\n    };\n}\ntemplate<typename T> istream &operator>>(istream &iss, vector<T> &vec) {\n    for (T &x: vec) iss >> x;\n    return iss;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, vector <T> &vec) {\n    for (int i = 0; i < vec.size(); i++)os << vec[i] << (i + 1 == vec.size() ? \"\" : \" \");\n    return os;\n}\ntemplate<typename V, typename H> void resize(vector<V> &vec, const H head) {  //再帰の終端。 可変長templateの長さが 0 になるとこっちが呼ばれる。\n    vec.resize(head);\n}\ntemplate<typename V, typename H, typename ... T> void resize(vector<V> &vec, const H &head, const T ... tail) {\n    vec.resize(head);\n    for (auto &v: vec) resize(v, tail...);\n}\ntemplate<class T> T pop(set<T> &set) {\n    T res = *set.begin();\n    set.erase(set.find(res));\n    return res;\n}\ntemplate<class T> T pop(mset<T> &set) {\n    T res = *set.begin();\n    set.erase(set.find(res));\n    return res;\n}\ntemplate<class T> T popBack(set<T> &set) {\n    T res = *set.rbegin();\n    set.erase(set.find(res));\n    return res;\n}\ntemplate<class T> T popBack(mset<T> &set) {\n    T res = *set.rbegin();\n    set.erase(set.find(res));\n    return res;\n}\ntemplate<class T> inline void sort(vector<T> &a) { sort(a.begin(), a.end()); };\ntemplate<class T> inline void rsort(vector<T> &a) { sort(a.begin(), a.end(), greater<T>()); };\ntemplate<class T> inline void sort(vector<T> &a, int len) { sort(a.begin(), a.begin() + len); };\ntemplate<class T> inline void rsort(vector<T> &a, int len) { sort(a.begin(), a.begin() + len, greater<T>()); };\ntemplate<class T> inline void sort2(vector<vector<T>> &a) { for (int i = 0, n = a.size(); i < n; i++)sort(a[i]); }\ntemplate<class T> inline void rsort2(vector<vector<T>> &a) { for (int i = 0, n = a.size(); i < n; i++)rsort(a[i]); }\ntemplate<typename A, size_t N, typename T> void fill(A (&a)[N], const T &v) { rep(i, N)a[i] = v; }\ntemplate<typename A, size_t N, size_t O, typename T> void fill(A (&a)[N][O], const T &v) { rep(i, N)rep(j, O)a[i][j] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, typename T> void fill(A (&a)[N][O][P], const T &v) { rep(i, N)rep(j, O)rep(k, P)a[i][j][k] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, typename T> void fill(A (&a)[N][O][P][Q], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)a[i][j][k][l] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, typename T> void fill(A (&a)[N][O][P][Q][R], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)a[i][j][k][l][m] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S, typename T> void fill(A (&a)[N][O][P][Q][R][S], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)rep(n, S)a[i][j][k][l][m][n] = v; }\ntemplate<typename V, typename T> void fill(V &x, const T &val) { x = val; }\ntemplate<typename V, typename T> void fill(vector<V> &vect, const T &val) { for (auto &v: vect) fill(v, val); }\n//@汎用便利関数 入力\ntemplate<typename T = int> T in() {\n    T x;\n    cin >> x;\n    return (x);\n}\nstring sin() { return in<string>(); }\ndouble din() { return in<double>(); }\nll lin() { return in<ll>(); }\n#define na(a, n) rep(i,n) cin >> a[i];\n#define nad(a, n) rep(i,n) cin >> a[i], a[i]--;\n#define na3(a, b, c, n) rep(i, n)cin >> a[i] >> b[i] >> c[i];\n#define add2(a, b, n) rep(i, n)a.pb(in()),b.pb(in());\n#define add2d(a, b, n) rep(i, n)a.pb(in()-1),b.pb(in()-1);\n#define add3(a, b, c, n) rep(i, n)a.pb(in()),b.pb(in()),c.pb(in());\n#define add3d(a, b, c, n) rep(i, n)a.pb(in()-1),b.pb(in()-1),c.pb(in());\n#define na2(a, b, n) rep(i, n)cin >> a[i] >> b[i];\n#define nt(a, h, w) rep(hi,h)rep(wi,w) cin >> a[hi][wi];\n#define ntd(a, h, w) rep(hi,h)rep(wi,w) cin >> a[hi][wi], a[hi][wi]--;\n#define ntp(a, h, w) fill(a,'#');rep(hi,1,h+1)rep(wi,1,w+1) cin >> a[hi][wi];\n#define addn(a, n) a.resize(n);na(a,n);\n#define addnd(a, n) a.resize(n);na(a,n);rep(i,n)a[i]--;\n\n\ntemplate<class T> inline void fin(T s) { cout << s << endl, exit(0); }\n\ntemplate<class T> struct edge {\n    int from, to;\n    T cost;\n    int id;\n    int type;\n    edge(int f, int t, T c = 1, int id = -1, int ty = -1) : from(f), to(t), cost(c), id(id), type(ty) {}\n    bool operator<(const edge &b) const { return cost < b.cost; }\n    bool operator>(const edge &b) const { return cost > b.cost; }\n};\n\ntemplate<typename T> class graph {\nprotected:\n    vector<bool> _used;\npublic :\n    vector<vector<edge<T>>> g;\n    vector<edge<T>> edges;\n    int n, root = -1;\n    graph(int n) : n(n) { g.resize(n), _used.resize(n); }\n    void clear() { g.clear(), edges.clear(); }\n    void resize(int n) {\n        this->n = n;\n        g.resize(n);\n        _used.resize(n);\n    }\n    int size() { return g.size(); }\n    bool isleaf(int v) {\n        assert(root != -1);\n        return g[v].size() == 1 && g[v][0].from != root;\n    }\n    vector<edge<T> > &operator[](int i) { return g[i]; }\n    virtual void add(int from, int to, T cost, int ty) = 0;\n    virtual bool used(edge<T> &e) = 0;\n    virtual bool used(int id) = 0;\n    virtual void del(edge<T> &e) = 0;\n    virtual void del(int id) = 0;\n};\n\ntemplate<class T=int> class undigraph : public graph<T> {\npublic:\n    using graph<T>::g;\n    using graph<T>::n;\n    using graph<T>::edges;\n    using graph<T>::_used;\n    undigraph(int n) : graph<T>(n) {\n    }\n    void add(int f, int t, T cost = 1, int ty = -1) {\n        int id = edges.size();\n        g[f].emplace_back(f, t, cost, id, ty);\n        g[t].emplace_back(t, f, cost, id + 1, ty);\n        edges.emplace_back(f, t, cost, id, ty);\n        edges.emplace_back(t, f, cost, id + 1, ty);\n    }\n    void add(edge<T> &e) {\n        int f = e.from, t = e.to, ty = e.type;\n        T cost = e.cost;\n        add(f, t, cost, ty);\n    }\n    bool used(edge<T> &e) { return _used[e.id]; }\n    bool used(int id) { return _used[id]; }\n    void del(edge<T> &e) { _used[e.id] = _used[e.id ^ 1] = 1; }\n    void del(int id) { _used[id] = _used[id ^ 1] = 1; }\n};\n\ntemplate<typename T =ll> class digraph : public graph<T> {\npublic:\n    using graph<T>::g;\n    using graph<T>::n;\n    using graph<T>::edges;\n    using graph<T>::_used;\n\n    digraph(int n) : graph<T>(n) {}\n    void add(int f, int t, T cost = 1, int ty = -1) {\n\n        int id = edges.size();\n        g[f].emplace_back(f, t, cost, ty, id);\n        edges.emplace_back(f, t, cost, ty, id);\n    }\n    bool used(edge<T> &e) { return _used[e.id]; }\n    bool used(int id) { return _used[id]; }\n    void del(edge<T> &e) { _used[e.id] = _used[e.id ^ 1] = 1; }\n    void del(int id) { _used[id] = _used[id ^ 1] = 1; }\n};\n\n\ntemplate<class T, class U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n\nint n, k, m, h, w, x, y, q;\nint cou;\nvi a, b, c;\nv3i(dp, 5000, 5001, 2);//コンピューターしかないか\nvvi(sub, 5050, 2);\nundigraph<> g(0);\nvi es(5050);\n\nvoid ds(int i, int p) {\n    forg(gi, g[i])if (t != p)ds(t, i);\n    int sum = 0;\n    dp[i][0][a[i] < 0] = a[i];\n    forg(gi, g[i]) {\n            if (t == p)continue;\n            rep(ci, sum + 1) {\n                rep(ct, es[t] + 1) {\n                    rep(ki, 2) {\n                        rep(kt, 2) {\n                            //繋ぐ\n                            if (dp[i][ci][ki] < linf && dp[t][ct][kt] < linf)\n                                chmin(sub[ci + ct][ki || kt], dp[i][ci][ki] + dp[t][ct][kt]);\n                            //切る\n                            if (dp[t][ct][kt] < 0 || (!kt && dp[t][ct][kt] != linf))\n                                chmin(sub[ci + ct + 1][ki], dp[i][ci][ki]);\n                        }\n                    }\n                }\n            }\n            sum += es[t] + 1;\n            rep(j, sum + 1)\n                rep(k, 2) {\n                    dp[i][j][k] = sub[j][k];\n                    sub[j][k] = linf;\n\n                }\n        }\n    es[i] = sum;\n}\nsigned main() {\n    cin >> n;\n    addn(a, n);\n    g.resize(n);\n    rep(i, n - 1) {\n        int f, s;\n        cin >> f >> s;\n        --f, --s;\n        g.add(f, s);\n    }\n    fill(dp, linf);\n    fill(sub, linf);\n    ds(0, -1);\n    rep(c, n)rep(k, 2) {\n            if (k) {\n                if (dp[0][c][k] < 0)fin(c);\n            } else if (dp[0][c][k] != linf)fin(c);\n        }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <vector>\nusing namespace std;\nusing ll = long long;\n#define fst first\n#define snd second\n\n/* clang-format off */\ntemplate <class T, size_t D> struct _vec { using type = vector<typename _vec<T, D - 1>::type>; };\ntemplate <class T> struct _vec<T, 0> { using type = T; };\ntemplate <class T, size_t D> using vec = typename _vec<T, D>::type;\ntemplate <class T> vector<T> make_v(size_t size, const T& init) { return vector<T>(size, init); }\ntemplate <class... Ts> auto make_v(size_t size, Ts... rest) { return vector<decltype(make_v(rest...))>(size, make_v(rest...)); }\n/* clang-format on */\n\nconst ll INF = 1ll << 60;\n\nint N;\nll A[6000];\nvector<int> G[6000];\n\nint best[6000];\nvector<ll> dp1[6000];\nint dp2[6000];\n\nvoid dfs(int v, int p) {\n  vector<ll>& dp = dp1[v];\n  dp.resize(1, 0ll);\n  for (int u : G[v]) {\n    if (u == p) continue;\n    dfs(u, v);\n    auto& ch = dp1[u];\n    vector<ll> ndp(dp.size() + ch.size() - 1, INF);\n    for (int i = 0; i < dp.size(); i++) {\n      for (int j = 0; j < ch.size(); j++) {\n        ndp[i + j] = min(ndp[i + j], dp[i] + ch[j]);\n      }\n    }\n    dp.swap(ndp);\n  }\n  for (ll& x : dp) x += A[v];\n  dp.resize(dp.size() + 1, 0);\n  for (int i = 0; i + 1 < dp.size(); i++) {\n    if (dp[i] < 0) {\n      dp[i + 1] = min(dp[i + 1], 0ll);\n    }\n  }\n  best[v] = dp.size() - 2;\n  for (int i = 0; i < dp.size(); i++) {\n    if (dp[i] < 0) {\n      best[v] = i;\n      break;\n    }\n  }\n  if (A[v] < 0) {\n    dp2[v] = best[v] + 1;\n  } else {\n    dp2[v] = 0;\n    for (int u : G[v]) {\n      if (u == p) continue;\n      dp2[v] += dp2[u];\n    }\n    dp[dp2[v] + 1] = min(dp[dp2[v] + 1], 0ll);\n    best[v] = min(best[v], dp2[v]);\n  }\n}\n\nint main() {\n  while (cin >> N) {\n    for (int i = 0; i < N; i++) cin >> A[i];\n    for (int i = 0; i < N; i++) {\n      G[i].clear();\n      dp1[i].clear();\n    }\n    for (int i = 0; i < N - 1; i++) {\n      int x, y;\n      cin >> x >> y;\n      --x;\n      --y;\n      G[x].push_back(y);\n      G[y].push_back(x);\n    }\n    dfs(0, -1);\n    cout << best[0] << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3f\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\n\nint n;\nll a[6000];\nvector<int>E[6000];\nint siz[6000];\nll dp[6000][6000];\nbool dp2[6000][6000];\n\nvoid dfs(int v,int p){\n\tfor(int u:E[v]){\n\t\tif(u==p)continue;\n\t\tdfs(u,v);\n\t}\n\tvector<ll>prv1(n*2),nex1(n*2);\n\tvector<bool>prv2(n*2),nex2(n*2);\n\trep(i,n)prv1[i]=INFL;\n\tprv1[0]=a[v];\n\tif(a[v]>0)prv2[0]=true;\n\tsiz[v]=1;\n\tfor(int u:E[v]){\n\t\tif(u==p)continue;\n\t\tfor(int i=siz[v]+siz[u];i>=0;i--){\n\t\t\tnex1[i]=INFL;\n\t\t\tnex2[i]=false;\n\t\t}\n\t\trep(i,siz[v]+1){\n\t\t\trep(j,siz[u]+1){\n\t\t\t\tif(dp[u][j]<0||dp2[u][j]){\n\t\t\t\t\tnex1[i+j+1]=min(nex1[i+j+1],prv1[i]);\n\t\t\t\t\tnex2[i+j+1]=(nex2[i+j+1]|prv2[i]);\n\t\t\t\t}\n\t\t\t\tnex1[i+j]=min(nex1[i+j],prv1[i]+dp[u][j]);\n\t\t\t\tnex2[i+j]=(nex2[i+j]|(prv2[i]&dp2[u][j]));\n\t\t\t}\n\t\t}\n\t\tsiz[v]+=siz[u];\n\t\tswap(prv1,nex1);\n\t\tswap(prv2,nex2);\n\t}\n\trep(i,n){\n\t\tdp[v][i]=prv1[i];\n\t\tdp2[v][i]=prv2[i];\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\trep(i,n)scanf(\"%lld\",&a[i]);\n\trep(i,n-1){\n\t\tint a,b;scanf(\"%d%d\",&a,&b);a--;b--;\n\t\tE[a].push_back(b);\n\t\tE[b].push_back(a);\n\t}\n\tdfs(0,-1);\n\trep(i,n){\n\t\tif(dp[0][i]<0||dp2[0][i]==true){\n\t\t\tcout<<i<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <queue>\n#include <functional>\n#include <string>\n#include <set>\n#include <map>\n#include <cmath>\n#include <cassert>\n#define SIZE 5005\n#define INF 1000000000000000LL\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nvector <int> vec[SIZE];\nint dp1[SIZE],nd[SIZE];\nll dp2[SIZE][SIZE];\nll cur[SIZE];\nll A[SIZE];\n\nvoid dfs(int v=0,int p=-1)\n{\n\tnd[v]=1;\n\tdp2[v][0]=A[v];\n\tfor(int i=0;i<vec[v].size();i++)\n\t{\n\t\tint to=vec[v][i];\n\t\tif(to!=p)\n\t\t{\n\t\t\tdfs(to,v);\n\t\t\tif(A[v]>0)\n\t\t\t{\n\t\t\t\tint pl=SIZE;\n\t\t\t\tif(A[to]>0) pl=min(pl,dp1[to]);\n\t\t\t\tfor(int j=0;j<nd[to];j++) if(dp2[to][j]<0) pl=min(pl,j+1);\n\t\t\t\tdp1[v]+=pl;\n\t\t\t}\n\t\t\tfor(int j=0;j<nd[v]+nd[to];j++) cur[j]=INF;\n\t\t\tfor(int j=0;j<nd[v];j++)\n\t\t\t{\n\t\t\t\tfor(int k=0;k<nd[to];k++)\n\t\t\t\t{\n\t\t\t\t\tcur[j+k]=min(cur[j+k],dp2[v][j]+dp2[to][k]);\n\t\t\t\t\tif(dp2[to][k]<0) cur[j+k+1]=min(cur[j+k+1],dp2[v][j]);\n\t\t\t\t}\n\t\t\t\tif(A[to]>0)\n\t\t\t\t{\n\t\t\t\t\tcur[j+dp1[to]+1]=min(cur[j+dp1[to]+1],dp2[v][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tnd[v]+=nd[to];\n\t\t\tfor(int j=0;j<nd[v];j++) dp2[v][j]=cur[j];\n\t\t}\n\t}\n}\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++) scanf(\"%lld\",&A[i]);\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tint a,b;\n\t\tscanf(\"%d %d\",&a,&b);a--,b--;\n\t\tvec[a].push_back(b);\n\t\tvec[b].push_back(a);\n\t}\n\tdfs();\n\tint ret=SIZE;\n\tif(A[0]>0) ret=dp1[0];\n\tfor(int i=0;i<SIZE;i++) if(dp2[0][i]<0) ret=min(ret,i);\n\tprintf(\"%d\\n\",ret);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define int long long\n#define inf 1000000007\n#define LINF 100000000000000007LL\n#define ll long long\nusing namespace std;\nvector<int> nex[5001];\nint dp[5001][5001];\nbool ap[5001][5001];\nint deg[5001];\nbool used[5001];\nint siz[5001];\nint im[5001],tg[5001];\nbool am[5001],ag[5001];\nvector<int> a(6000);\nvoid calc(int pos){\n\tvector<int> ch;\n\tfor(int i=0;i<nex[pos].size();i++){\n\t\tint nx = nex[pos][i];\n\t\tif( used[nx] ){\n\t\t\tch.pb(nx);\n\t\t\tsiz[pos] += siz[nx];\n\t\t}\n\t}\n\tsiz[pos]++; // pos itself\n\tfor(int i=0;i<=siz[pos];i++){\n\t\ttg[i] = LINF;\n\t\tim[i] = a[pos];\n\t\tam[i] = false;\n\t\tag[i] = false;\n\t}\n\tif( a[pos] > 0 )am[0]=true;\n\tint cur = 0;\n\tfor(int i=0;i<ch.size();i++){\n\t\tint ma = siz[ ch[i] ] - 1;\n\t\tfor(int j=0;j<=ma;j++){\n\t\t\tfor(int k=0;k<=cur;k++){\n\t\t\t\ttg[j+k] = min(tg[j+k],im[k]+dp[ch[i]][j]);\n\t\t\t\t//cout<<i<<j<<k<<\" \"<<tg[j+k]<<\" \"<<dp[ch[i]][j]<<endl;\n\t\t\t\tif( dp[ch[i]][j] < 0 || ap[ch[i]][j] ){\n\t\t\t\t\ttg[j+k+1] = min( tg[j+k+1], im[k]);\n\t\t\t\t\t//cout<<j+k+1<<\" \"<<k<<\" \"<<im[k]<<endl;\n\t\t\t\t}\n\t\t\t\tif( am[k] && ap[ch[i]][j] ){ ag[j+k] = true; ag[j+k+1] = true; }\n\t\t\t\tif( am[k] && dp[ch[i]][j]<0 ) ag[j+k+1] = true;\n\t\t\t}\n\t\t}\n\t\tcur += ma+1;\n\t\tfor(int j=0;j<=cur;j++){\n\t\t\tim[j] = tg[j];\n\t\t\tam[j] = ag[j];\n\t\t\ttg[j] = LINF;\n\t\t\tag[j] = false;\n\t\t}\n\t}\n\tfor(int i=0;i<siz[pos];i++){\n\t\tdp[pos][i] = im[i];\n\t\tap[pos][i] = am[i];\n\t\t//cout<<\"!!\"<<pos<<\" \"<<i<<\" \"<<im[i]<<\" \"<<am[i]<<endl;\n\t}\n}\nsigned main(){\n\tint n;\n\tcin>>n;\n\ta[0]=0;\n\tfor(int i=1;i<=n;i++)cin>>a[i];\n\tfor(int i=0;i<n-1;i++){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tnex[x].pb(y);\n\t\tnex[y].pb(x);\n\t\tdeg[x]++;\n\t\tdeg[y]++;\n\t}\n\tqueue<int> que;\n\tfor(int i=2;i<=n;i++){\n\t\tif( deg[i] == 1 ){\n\t\t\tque.push(i);\n\t\t}\n\t}\n\twhile(!que.empty()){\n\t\tint cur = que.front(); que.pop();\n\t\tused[cur] = true;\n\t\tcalc(cur);\n\t\tfor(int i=0;i<nex[cur].size();i++){\n\t\t\tint nx = nex[cur][i];\n\t\t\tdeg[nx]--;\n\t\t\tif( deg[nx] == 1 && nx != 1){\n\t\t\t\tque.push(nx);\n\t\t\t}\n\t\t}\n\t}\n\tcalc(1);\n\tfor(int i=0;i<n;i++){\n\t\tif( dp[1][i] < 0 || ap[1][i] ){\n\t\t\tcout<<i<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <functional>\n\ntemplate <class T>\nstd::vector<T> vec(int len, T elem) { return std::vector<T>(len, elem); }\n\ntemplate <class Cost = int>\nstruct Edge {\n    int src, dst;\n    Cost cost;\n    Edge(int src = -1, int dst = -1, Cost cost = 1)\n        : src(src), dst(dst), cost(cost){};\n\n    bool operator<(const Edge<Cost>& e) const { return this->cost < e.cost; }\n    bool operator>(const Edge<Cost>& e) const { return this->cost > e.cost; }\n};\n\ntemplate <class Cost = int>\nusing Graph = std::vector<std::vector<Edge<Cost>>>;\n\nusing lint = long long;\nconstexpr lint INF = 1LL << 45;\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n\n    std::vector<lint> xs(n);\n    for (auto& x : xs) std::cin >> x;\n\n    Graph<> graph(n);\n    for (int i = 0; i < n - 1; ++i) {\n        int u, v;\n        std::cin >> u >> v;\n        --u, --v;\n        graph[u].emplace_back(u, v);\n        graph[v].emplace_back(v, u);\n    }\n\n    auto dp = vec(2, vec(n, vec(n, 0LL)));\n    auto ndp = std::vector<lint>(n);\n    auto esz = vec(n, 0);\n\n    std::function<void(int, int)> dfs =\n        [&](int v, int p) {\n            std::fill(dp[0][v].begin(), dp[0][v].end(), INF);\n            dp[0][v][0] = xs[v];\n\n            if (xs[v] > 0) dp[1][v][0] = 1;\n\n            for (auto e : graph[v]) {\n                int u = e.dst;\n                if (u == p) continue;\n\n                dfs(u, v);\n\n                std::fill(ndp.begin(), ndp.end(), INF);\n                for (int i = 0; i <= esz[v]; ++i) {\n                    for (int j = 0; j <= esz[u]; ++j) {\n                        // negative merge\n                        ndp[i + j] = std::min(ndp[i + j], dp[0][v][i] + dp[0][u][j]);\n\n                        if (dp[1][u][j]) {\n                            // cut\n                            ndp[i + j + 1] = std::min(ndp[i + j + 1], dp[0][v][i]);\n                        }\n                    }\n                }\n                std::swap(dp[0][v], ndp);\n\n                std::fill(ndp.begin(), ndp.end(), 0);\n                for (int i = 0; i <= esz[v]; ++i) {\n                    if (!dp[1][v][i]) continue;\n\n                    for (int j = 0; j <= esz[u]; ++j) {\n                        if (dp[0][u][j] < 0) {\n                            // cut\n                            while ((int)ndp.size() < i + j + 1) ndp.push_back(0);\n                            ndp[i + j + 1] = 1;\n                        }\n\n                        if (dp[1][u][j]) {\n                            // positive merge\n                            while ((int)ndp.size() < i + j) ndp.push_back(0);\n                            ndp[i + j] = 1;\n                        }\n                    }\n                }\n                std::swap(dp[1][v], ndp);\n\n                esz[v] += esz[u] + 1;\n            }\n        };\n\n    dfs(0, -1);\n    int ans = n;\n    for (int i = 0; i < n; ++i) {\n        if (dp[0][0][i] < 0 || dp[1][0][i]) {\n            ans = std::min(ans, i);\n            break;\n        }\n    }\n\n    std::cout << ans << std::endl;\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst long long MAXN = 5e3+5;\n\nvector<long long> v1[MAXN];\nlong long dp[MAXN][MAXN][3];\nlong long temp[MAXN][3];\nlong long sz[MAXN];\nlong long arr[MAXN];\nvoid dfs(long long curr,long long par){\n    for(long long x:v1[curr]){\n        if(x!=par){\n            dfs(x,curr);\n            \n        }\n        \n    }\n    long long sum = 1; //current subtree sz\n    dp[curr][0][arr[curr]<0] = arr[curr]; //0 edges cut, is a computer = 1, not a computer  = 0 \n    for(long long x:v1[curr]){\n        if(x!=par){\n            for(long long i=0;i<sum;i++){\n                for(long long j=0;j<sz[x];j++){\n                    for(long long k1=0;k1<2;k1++){\n                        for(long long k2=0;k2<2;k2++){\n                            //merge components together(all possible cuts)\n                            temp[i+j][k1|k2] = min(temp[i+j][k1|k2],dp[curr][i][k1]+dp[x][j][k2]);\n                            if((k2 == 0 && dp[x][j][k2]<1e18)||(k2 == 1 && dp[x][j][k2]<0)){\n                                //cut edge between curr and x, cuts++, whether or not a computer exists \n                                //depends on the current component itself. You can only do this if x's subtree\n                                //has a value less than 0 when it has a computer, or if x's subtree doesn't currently have a computer.\n                                temp[i+j+1][k1] = min(temp[i+j+1][k1],dp[curr][i][k1]);\n                            }\n                        }\n                    }\n                }\n            }\n            //(actually O(n))\n            sum+=sz[x];\n            for(long long i=0;i<sum;i++){\n                for(long long k=0;k<2;k++){\n                    dp[curr][i][k] = temp[i][k];\n                    temp[i][k] = 1e18;\n                    //update all values to dp\n                }\n            }\n        }\n    }\n    sz[curr] = sum;\n}\nint main(){\n    long long n;\n    cin>>n;\n    for(long long i=1;i<=n;i++){\n        cin>>arr[i];\n    }\n    for(long long i=1;i<n;i++){\n        long long u,v;\n        cin>>u>>v;\n        v1[u].push_back(v);\n        v1[v].push_back(u);\n    }\n    for(long long i=1;i<=n;i++){\n        for(long long j=0;j<=n;j++){\n            for(long long k=0;k<=1;k++){\n                dp[i][j][k] = 1e18;\n                temp[j][k] = 1e18;\n            }\n        }\n    }\n    dfs(1,1);\n    long long ans = n-1;\n    for(long long i=0;i<n;i++){\n        if(dp[1][i][0]<1e18){\n            ans = min(ans,i);\n        }\n        if(dp[1][i][1]<0){\n            ans = min(ans,i);\n        }\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx\")\n#pragma GCC optimize(\"unroll-loops\")\n//#pragma warning(disable : 4996)\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#define __builtin_popcount __popcnt\n#define __builtin_popcountll __popcnt64\n#endif\n\n#include <limits.h>\n#include <math.h>\n#include <time.h>\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\nusing namespace std;\n\n#define REP(i, n) for (int i = 0; i < (n); ++i)\n#define REPR(i, n) for (int i = n - 1; i >= 0; --i)\n#define FOR(i, m, n) for (int i = m; i < n; ++i)\n#define FORR(i, m, n) for (int i = m - 1; i >= n; --i)\n#define SORT(v, n) sort(v, v + n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define REVERSE(v, n) reverse(v, v + n);\n#define VREVERSE(v) reverse(v.begin(), v.end())\n#define ll long long\n#define print(x) cout << (x) << '\\n'\n#define pe(x) cout << (x) << \" \"\n#define DEBUG(x) cout << #x << \": \" << x << endl\n#define lb(v, n) lower_bound(v.begin(), v.end(), (n))\n#define ub(v, n) upper_bound(v.begin(), v.end(), (n))\n//#define int long long\n#define double long double\n#define all(x) (x).begin(), (x).end()\n#define print_space(v) REP(i, v.size()) cout << v[i] << ((i == v.size() - 1) ? \"\\n\" : \" \")\ntemplate <typename T1, typename T2> inline void chmin(T1& a, T2 b) {\n\tif (a > b) a = b;\n}\ntemplate <typename T1, typename T2> inline void chmax(T1& a, T2 b) {\n\tif (a < b) a = b;\n}\ntypedef pair<int, int> pii;\ntypedef pair<long long, long long> pll;\ntypedef array<int, 3> arr3;\nstd::random_device rd;\nstd::mt19937 mt(rd());\nconstexpr ll MOD = 998244353;\nconstexpr int MAX = 500050;\nconst double pi = acos(-1);\nconstexpr double EPS = 1e-8;\nconstexpr ll LINF = 1e18 + 1;\nconstexpr int INF = 1e9 + 1;\n\nvector<int>G[5001];\nint siz[5001];\nint par[5001];\nint calc_size(int n) {\n\t//print(n);\n\tint res = 1;\n\tfor (auto nxt : G[n]) {\n\t\tif (nxt == par[n])continue;\n\t\tpar[nxt] = n;\n\t\tres += calc_size(nxt);\n\t}\n\treturn siz[n] = res;\n}\n\n//ll dp[5001][2][5001];\nll dp[5010][2][5020];\nbool vis[5050];\nll ndp[2][5050];\nvoid rec(int i) {\n\tif (vis[i])return;\n\tvis[i] = true;\n\tint sz = 1;\n\tfor (auto nxt : G[i]) {\n\t\tif (nxt == par[i])continue;\n\t\trec(nxt);\n\t\tint nsz = siz[nxt];\n\t\tREP(j, 2)REP(k, sz + nsz + 1)ndp[j][k] = LINF;\n\t\tint mn = INF;\n\t\tREP(j, 2)REP(k, nsz)if ((j == 0 && dp[nxt][j][k] < LINF) || dp[nxt][j][k] < 0)chmin(mn, k);\n\t\t//cut\n\t\tREP(j, 2)REP(k, sz + nsz + 1) {\n\t\t\tif (k + mn > 5001)break;\n\t\t\tchmin(ndp[j][k + mn+1],dp[i][j][k]);\n\t\t}\n\t\t//merge\n\t\tREP(j, 2)REP(k, sz + 1)REP(nj, 2)REP(nk, nsz + 1) {\n\t\t\tchmin(ndp[j | nj][k + nk], dp[i][j][k] + dp[nxt][nj][nk]);\n\t\t}\n\t\tREP(j, 2)REP(k, sz + nsz + 1)dp[i][j][k] = ndp[j][k];\n\t\tsz += nsz;\n\t}\n\treturn;\n}\n\n\nvoid solve() {\n\tint N; cin >> N;\n\tvector<int>A(N);\n\tREP(i, N)cin >> A[i];\n\tREP(i, N-1) {\n\t\tint u, v; cin >> u >> v;\n\t\tu--, v--;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\n\tcalc_size(0);\n\n\tREP(i, N + 1)REP(j, 2)REP(k, N + 1)dp[i][j][k] = LINF;\n\tREP(i, N) {\n\t\tif (A[i] < 0)dp[i][1][0] = A[i];\n\t\telse dp[i][0][0] = A[i];\n\t}\n\trec(0);\n\tll ans = INF;\n\tREP(j, 2)REP(k, N) {\n\t\tif ((j == 0&&dp[0][j][k]<LINF) || dp[0][j][k] < 0) {\n\t\t\tchmin(ans, k);\n\t\t}\n\t}\n\tprint(ans);\n}\n\n\n\n\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tmt.seed((int)(time(0)));\n\t//int q;\n\t//cin >> q;\n\t//while (q--)\n\tsolve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,m,n) for(int (i)=(int)(m);i<(int)(n);++i)\n#define rep2(i,m,n) for(int (i)=(int)(n)-1;i>=(int)(m);--i)\n#define REP(i,n) rep(i,0,n)\n#define REP2(i,n) rep2(i,0,n)\n#define FOR(i,c) for(decltype((c).begin())i=(c).begin();i!=(c).end();++i)\n#define all(hoge) (hoge).begin(),(hoge).end()\n#define en '\\n'\nusing ll = long long;\nusing ull = unsigned long long;\ntemplate <class T> using vec = vector<T>;\ntemplate <class T> using vvec = vector<vec<T>>;\ntypedef pair<ll, ll> P;\nconstexpr long long INF = 1LL << 60;\nconstexpr int INF_INT = 1 << 25;\n//constexpr long long MOD = (ll) 1e9 + 7;\nconstexpr long long MOD = 998244353LL;\nusing ld=long double;\nstatic const ld pi = 3.141592653589793L;\ntypedef vector<ll> Array;\ntypedef vector<Array> Matrix;\n\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nstruct Edge {\n\tll to, cap, rev, col;\n\tEdge(ll _to, ll _cap, ll _rev) {\n\tto = _to; cap = _cap; rev = _rev;\n\t}\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\nvoid add_edge(Graph& G, ll from, ll to, ll cap, bool revFlag, ll revCap) {\n\tG[from].push_back(Edge(to, cap, (ll)G[to].size()));\n\tif (revFlag)G[to].push_back(Edge(from, revCap, (ll)G[from].size() - 1));\n}\n\nvoid solve(){\n    ll n;\n    cin>>n;\n    vec<ll> a(n);\n    REP(i,n) cin>>a[i];\n    Graph g(n);\n    REP(i,n-1){\n        ll a,b;\n        cin>>a>>b;\n        a--;b--;\n        add_edge(g,a,b,1,true,1);\n    }\n\n    vec<int> sz(n, 1);\n    vec<vvec<ll>> dp(n,vvec<ll>(2));//頂点iを根とするj書い切ったときにできる部分木の最小値\n    \n    auto dfs=[&](auto &&self,int v,int p)->void{\n        dp[v][0] = vec<ll>(1, INF);//ーをふくまない\n        dp[v][1] = vec<ll>(1, INF);//ーをふくむ\n        if(a[v]>0) dp[v][0][0]=a[v];\n        else dp[v][1][0]=a[v];\n\n        for(auto e:g[v]){\n            if(e.to==p) continue;\n            self(self,e.to,v);\n            vvec<ll> dp2(2,vec<ll>(sz[v]+sz[e.to], INF));\n            REP(i,sz[v]){\n                REP(j,sz[e.to]){\n                    REP(aa,2) REP(bb,2){\n                        if(dp[v][aa][i]==INF or dp[e.to][bb][j]==INF) continue;\n                        chmin(dp2[aa or bb][i+j], dp[v][aa][i] + dp[e.to][bb][j]);\n                        if(bb==0 or dp[e.to][bb][j] < 0) chmin(dp2[aa][i+j+1], dp[v][aa][i]);\n                    }\n                }\n            }\n            sz[v]+=sz[e.to];\n            dp[v]=dp2;\n        }\n\n    };\n    dfs(dfs,0,-1);\n\n    REP(i,n){\n        if(dp[0][0][i]!=INF or dp[0][1][i]<0){\n            cout<<i<<en;\n            return;\n        }\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\t\n\tsolve();\n\t//ll t;cin>>t;REP(i,t) solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n#define MOD 1000000007\n\nlong long int ppow(long long int i, long long int j) {\n\tlong long int res = 1LL;\n\twhile (j) {\n\t\tif ((j & 1LL)) {\n\t\t\tres *= i;\n\t\t\tif (res >= MOD) {\n\t\t\t\tres %= MOD;\n\t\t\t}\n\t\t}\n\t\tj >>= 1;\n\t\ti *= i;\n\t\tif (i >= MOD) {\n\t\t\ti %= MOD;\n\t\t}\n\t}\n\treturn res;\n}\nlong long int gcd(long long int a, long long int b) {\n\tif (a > b) {\n\t\tswap(a, b);\n\t}\n\twhile (a) {\n\t\tswap(a, b);\n\t\ta %= b;\n\t}\n\treturn b;\n}\nlong long int lcm(long long int a, long long int b) {\n\treturn a / gcd(a, b)*b;\n}\n#define MAX 5002\n\nint n;\nvector<long long int> v;\nvector<int> g[MAX];\n\nlong long int dp[MAX][MAX][2];  //ans,min,is there server?\nint child[MAX];\nlong long int tmp[MAX][2];\ninline void dfs(int b,int pr=-1){\n\tchild[b] = 1;\n\tfor (int i = 0; i < g[b].size(); i++) {\n\t\tif (g[b][i] == pr)continue;\n\t\tdfs(g[b][i], b);\n\t\tchild[b] += child[g[b][i]];\n\t}\n\tfor (int i = 0; i <= child[b]; i++) {\n\t\tdp[b][i][0] = dp[b][i][1] = LLONG_MAX;\n\t}\n\tint cur = 1;\n\tint f = (v[b] < 0LL);\n\tdp[b][0][f] = v[b];\n\tfor (int i = 0; i < g[b].size(); i++) {\n\t\tif (g[b][i] == pr)continue;\n\t\t//merge\n\t\tint node = g[b][i];\n\t\tint nex = cur + child[node];\n\t\tfor (int f = 0; f <= nex; f++)tmp[f][0]=tmp[f][1] = LLONG_MAX;\n\t\tfor (int c = 0; c <= cur; c++) {\n\t\t\tfor (int k = 0; k <= child[node]; k++) {\n\t\t\t\tfor (int jj = 0; jj < 2; jj++) {\n\t\t\t\t\tfor (int kk = 0; kk < 2; kk++) {\n\t\t\t\t\t\tif (dp[b][c][jj] == LLONG_MAX || dp[node][k][kk] == LLONG_MAX)continue;\n\t\t\t\t\t\ttmp[c + k][jj | kk] = min(tmp[c + k][jj | kk], dp[b][c][jj] + dp[node][k][kk]);\n\t\t\t\t\t\t//cut\n\t\t\t\t\t\tif (kk == 0 || dp[node][k][kk] < 0LL) {\n\t\t\t\t\t\t\ttmp[c + k + 1][jj] = min(tmp[c + k + 1][jj], dp[b][c][jj]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcur = nex;\n\t\tfor (int f = 0; f <= nex; f++) {\n\t\t\tdp[b][f][0] = tmp[f][0];\n\t\t\tdp[b][f][1] = tmp[f][1];\n\t\t}\n\t}\n}\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tint a;\n\t\tscanf(\"%d\", &a);\n\t\tv.push_back(a);\n\t}\n\tfor (int i = 1; i < n; i++) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\ta--;\n\t\tb--;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\tdfs(0);\n\tint ans = INT_MAX;\n\tfor (int i = 0; i <= n; i++) {\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tif (dp[0][i][j] == LLONG_MAX)continue;\n\t\t\tif (j == 0) {\n\t\t\t\tans = min(ans, i);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (dp[0][i][j] < 0LL) {\n\t\t\t\t\tans = min(ans, i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n)  for(long long i=0;i<(long long)(n);i++)\n#define REP(i,k,n) for(long long i=k;i<(long long)(n);i++)\n#define all(a) a.begin(),a.end()\n#define pb push_back\n#define eb emplace_back\n#define lb(v,k) (lower_bound(all(v),k)-v.begin())\n#define ub(v,k) (upper_bound(all(v),k)-v.begin())\n#define fi first\n#define se second\n#define pi M_PI\n#define PQ(T) priority_queue<T>\n#define SPQ(T) priority_queue<T,vector<T>,greater<T>>\n#define dame(a) {out(a);return 0;}\n#define decimal cout<<fixed<<setprecision(15);\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef tuple<ll,ll,ll> PP;\ntypedef tuple<ll,ll,ll,ll> PPP;\ntypedef multiset<ll> S;\nusing vi=vector<ll>;\nusing vvi=vector<vi>;\nusing vvvi=vector<vvi>;\nusing vp=vector<P>;\nusing vvp=vector<vp>;\nusing vb=vector<bool>;\nusing vvb=vector<vb>;\nconst ll inf=1001001001001001001;\nconst int INF=1001001001;\nconst int mod=998244353;\nconst double eps=1e-10;\ntemplate<class T> bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<class T> bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<class T> void out(T a){cout<<a<<'\\n';}\ntemplate<class T> void outp(T a){cout<<'('<<a.fi<<','<<a.se<<')'<<'\\n';}\ntemplate<class T> void outvp(T v){rep(i,v.size())cout<<'('<<v[i].fi<<','<<v[i].se<<')';cout<<'\\n';}\ntemplate<class T> void outvvp(T v){rep(i,v.size())outvp(v[i]);}\ntemplate<class T> void outv(T v){rep(i,v.size()){if(i)cout<<' ';cout<<v[i];}cout<<'\\n';}\ntemplate<class T> void outvv(T v){rep(i,v.size())outv(v[i]);}\ntemplate<class T> bool isin(T x,T l,T r){return (l)<=(x)&&(x)<=(r);}\ntemplate<class T> void yesno(T b){if(b)out(\"yes\");else out(\"no\");}\ntemplate<class T> void YesNo(T b){if(b)out(\"Yes\");else out(\"No\");}\ntemplate<class T> void YESNO(T b){if(b)out(\"YES\");else out(\"NO\");}\ntemplate<class T> void noyes(T b){if(b)out(\"no\");else out(\"yes\");}\ntemplate<class T> void NoYes(T b){if(b)out(\"No\");else out(\"Yes\");}\ntemplate<class T> void NOYES(T b){if(b)out(\"NO\");else out(\"YES\");}\nvoid outs(ll a,ll b){if(a>=inf-100)out(b);else out(a);}\nll gcd(ll a,ll b){if(b==0)return a;return gcd(b,a%b);}\nll modpow(ll a,ll b){a%=mod;if(b==0)return 1;if(b&1)return a*modpow(a,b-1)%mod;ll k=modpow(a,b/2);return k*k%mod;}\nvi val,sz;\nvvi g,dp,dp1;\nvoid dfs(int v,int p){\n    sz[v]=1;\n    for(ll x:g[v])if(x!=p){\n        dfs(x,v);\n        sz[v]+=sz[x];\n    }\n    vi sdp(1),sdp1(1);\n    sdp[0]=val[v];\n    if(val[v]>0)sdp1[0]=1;\n    for(ll x:g[v])if(x!=p){\n        vi ndp(sdp.size()+sz[x],inf),ndp1(sdp.size()+sz[x]);\n        rep(i,sdp.size())rep(j,sz[x]){\n            chmin(ndp[i+j],sdp[i]+dp[x][j]);\n            if(dp1[x][j]||dp[x][j]<0)chmin(ndp[i+j+1],sdp[i]);\n            if(sdp1[i]){\n                if(dp[x][j]<0)ndp1[i+j+1]=1;\n                if(dp1[x][j])ndp1[i+j]=1;\n            }\n        }\n        sdp=ndp;\n        sdp1=ndp1;\n    }\n    dp[v]=sdp;\n    dp1[v]=sdp1;\n}\nint main(){\n    ll n;cin>>n;\n    val=vi(n);\n    sz=vi(n);\n    dp1=vvi(n);\n    dp=vvi(n);\n    rep(i,n)cin>>val[i];\n    g=vvi(n);\n    rep(i,n-1){\n        ll a,b;cin>>a>>b;a--;b--;\n        g[a].pb(b);\n        g[b].pb(a);\n    }\n    dfs(0,-1);\n    ll ans=0;\n    while(dp[0][ans]>0&&!dp1[0][ans])ans++;\n    out(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stdio.h>\n#include <vector>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stdlib.h>\n#include <time.h>\n#include <iomanip>\n#include <math.h>\n#include <bitset>\n\nusing namespace std;\n\n#define taskname \"A\"\n#define LL long long \n#define uLL unsigned long long \n#define FOR(i,l,r) for(int i = l; i <= r; ++i)\n#define REP(i,l,r) for(int i = l; i < r; ++i)\n#define FORD(i,r,l) for(int i = r; i >= l; --i)\n#define REPD(i,r,l) for(int i = r; i > l; --i)\n#define sz(x) (int)((x).size())\n#define all(x) (x).begin(), (x).end()\n#define debug(x) { cerr << #x << \" = \" << x << endl; }\n#define sci(x) int x; scanf(\"%d\", &x);\n#define scii(x, y) int x, y; scanf(\"%d %d\", &x, &y);\n#define sciii(x, y, z) int x, y, z; scanf(\"%d %d %d\", &x, &y, &z);\n#define pi pair<int,int>\n#define pii pair<int,pi>\n#define piLL pair<LL,LL>\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define _USE_MATH_DEFINES \n/* M_PI */\n#define SetLength2(a, n, t) a=((t*) calloc(n, sizeof(t))) + (n)/2\n\nconst int maxN = 5001;\nconst LL oo = 1e17 + 11;\n\nint tcases = 1;\n\nint N,M,total = 0,res = 0;\nvector <int> e[maxN];\nint C[maxN];\nLL W[maxN],A[maxN],F[maxN][maxN],f1[maxN],g1[maxN];\nbool G[maxN][maxN];\npiLL tmp[maxN],fg[maxN];\n\nvoid dfs(int u,int p = 0){\n    W[u] = A[u];\n    C[u] = 1;\n    REP(i,0,e[u].size()){\n        int v = e[u][i];\n        if(v == p) continue;\n        dfs(v,u);\n        W[u] += W[v];\n        C[u] += C[v];\n    }\n}\nvoid cal(int u,int p = 0){\n    REP(i,0,e[u].size()){\n        int v = e[u][i];\n        if(v != p) cal(v,u);\n    }\n    //\n    F[u][0] = W[u];\n    if(C[u] == 1) G[u][0] = A[u] > 0;\n    else{\n        REP(i,0,C[u]) f1[i] = oo,g1[i] = 0;\n        f1[0] = A[u]; g1[0] = A[u] > 0;\n        \n        REP(k,0,e[u].size()){\n            int v = e[u][k];\n            if(v == p) continue;\n            // cal F[u][i]\n            REP(i,0,C[u]){\n                F[u][i] = oo; G[u][i] = 0;\n                FOR(j,0,min(C[v],i)){\n                    F[u][i] = min(F[u][i],f1[i - j] + F[v][j]);\n                    G[u][i] |= g1[i - j] && (G[v][j] || (j > 0 & F[v][j - 1] < 0));\n                }\n            }\n            REP(i,0,C[u]) f1[i] = F[u][i],g1[i] = G[u][i];\n        }\n    }\n    REP(i,0,C[u]){\n        if(F[u][i] < 0 || G[u][i]){\n            F[u][i + 1] = min(F[u][i + 1],0LL);\n            //G[u][i + 1] = 1;\n        }\n    }\n}\nvoid testcase(){\n\n    cin >> N;\n    FOR(i,1,N) cin >> A[i];\n    \n    REP(i,1,N){\n        scii(u,v);\n        e[u].pb(v);\n        e[v].pb(u);\n    }\n\n    dfs(1);\n\n    int root = 1;\n\n    FOR(i,1,N){\n        FOR(j,0,N) F[i][j] = oo;\n    }\n\n    cal(root);\n    \n    FOR(j,0,N) if(F[root][j] < 0 || G[root][j]){\n        cout << j;\n        return ;\n    }\n}\n\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie();\n    cout.tie();\n    \n    FOR(i,1,tcases) testcase();\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//https://atcoder.jp/contests/aising2019/tasks/aising2019_e\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n#ifdef BTK\n#define DEBUG if(1)\n#else\n#define CIN_ONLY if(1)\nstruct cww {cww() {CIN_ONLY{ios::sync_with_stdio(false); cin.tie(0);}}}star;\n#define DEBUG if(0)\n#endif\n#define ALL(v) (v).begin(),(v).end()\n#define REC(ret, ...) std::function<ret (__VA_ARGS__)>\ntemplate <typename T>inline bool chmin(T &l, T r){bool a = l>r; if (a)l = r; return a;}\ntemplate <typename T>inline bool chmax(T &l, T r){bool a = l<r; if (a)l = r; return a;}\ntemplate <typename T>istream& operator>>(istream &is, vector<T> &v){for (auto &it : v)is >> it;return is;}\nclass range {private: struct I { int x; int operator*() { return x; }bool operator!=(I& lhs) { return x<lhs.x; }void operator++() { ++x; } }; I i, n;public:range(int n) :i({ 0 }), n({ n }) {}range(int i, int n) :i({ i }), n({ n }) {}I& begin() { return i; }I& end() { return n; }};\n\nint N;\nLL A[5123];\nvector<int> g[5123];\nvector<int> t[5123];\nLL allB[5123][5123];\nLL dp[5123][5123];\nLL tmp[5123];\nint sub[5123];\nvoid dfs(int v,int p){\n    sub[v]=1;\n    for(int u:g[v]){\n        if(u==p)continue;\n        t[v].push_back(u);\n        dfs(u,v);\n        sub[v]+=sub[u];\n    }\n}\nvoid solve(int v){\n    for(int u:t[v]){\n        solve(u);\n    }\n    int x=1;\n    if(A[v]>0){\n        allB[v][0]=1;\n    }\n    else{\n        allB[v][0]=0;\n    }\n    dp[v][0]=A[v];\n    for(int u:t[v]){\n        const int nx=x+sub[u];\n        for(int i:range(nx+1)){\n            tmp[i]=0;\n        }\n        for(int i:range(x))for(int j:range(sub[u]+1)){\n            tmp[i+j]|=(allB[v][i]&allB[u][j]);\n        }\n        for(int i:range(nx+1)){\n            allB[v][i]=tmp[i];\n            tmp[i]=1e18;\n        }\n        for(int i:range(x))for(int j:range(sub[u]+1)){\n            chmin(tmp[i+j],dp[v][i]+dp[u][j]);\n        }\n        for(int i:range(nx+1)){\n            dp[v][i]=tmp[i];\n        }\n        x+=nx;\n    }\n    for(int i:range(x)){\n        if(allB[v][i]||dp[v][i]<0){\n            chmin(dp[v][i+1],0ll);\n            allB[v][i+1]=1;\n        }\n    }\n}\nint main(){\n    cin>>N;\n    for(int i:range(N)){\n        cin>>A[i+1];\n    }\n    for(int i:range(N-1)){\n        int u,v;\n        cin>>u>>v;\n        g[v].push_back(u);\n        g[u].push_back(v);\n    }\n    dfs(1,1);\n    solve(1);\n    int ret=N-1;\n    for(int i:range(N+1)){\n        if(allB[1][i])chmin(ret,i);\n        if(dp[1][i]<0)chmin(ret,i);\n    }\n    cout<<ret<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define all(x) (x).begin(), (x).end()\n#define sz(x) ( (int)(x).size() )\nusing LL = long long;\n\ntemplate<class T>\ninline bool asMn(T &a, const T &b) { return a > b ? a = b, true : false; }\ntemplate<class T>\ninline bool asMx(T &a, const T &b) { return a < b ? a = b, true : false; }\n\nconst LL infLL = 1e18;\nconst int inf = 1e9;\nmt19937 rng( (int)chrono::steady_clock::now().time_since_epoch().count() );\n\nvector<int> a;\nvector<vector<int> > gr;\nvector<vector<array<LL, 2> > > f;\nvoid dfs(int u, int pr) {\n  f[u].assign(1, array<LL, 2>{ infLL, infLL } );\n  f[u][0][ a[u] < 0 ] = a[u];\n\n  for (int v : gr[u]) if (v ^ pr) {\n    dfs(v, u);\n\n    vector<array<LL, 2> > nF(sz(f[u]) + sz(f[v]), array<LL, 2>{ infLL, infLL });\n    for (int i = 0; i < sz(f[u]); ++i) {\n      for (int flagI = 0; flagI < 2; ++flagI) if (f[u][i][flagI] ^ infLL) {\n        for (int j = 0; j < sz(f[v]); ++j) {\n          for (int flagJ = 0; flagJ < 2; ++flagJ) if (f[v][j][flagJ] ^ infLL) {\n            asMn(nF[i + j][flagI | flagJ], f[u][i][flagI] + f[v][j][flagJ]);\n            if (!flagJ || f[v][j][flagJ] < 0) asMn(nF[i + j + 1][flagI], f[u][i][flagI]);\n          }\n        }\n      }\n    }\n\n    f[u].swap(nF);\n  }\n\n//  cerr << \"u = \" << u + 1 << '\\n';\n//  for (int i = 0; i < sz(f[u]); ++i) {\n//    for (int j = 0; j < 2; ++j) if (f[u][i][j] ^ infLL) cerr << i << ' ' << j << ' ' << f[u][i][j] << '\\n';\n//  }\n}\n\nint main() {\n  ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\n  #ifdef FourLeafClover\n  freopen(\"input\", \"r\", stdin);\n  #endif // FourLeafClover\n\n  int n; cin >> n;\n  a.assign(n, 0);\n  for (auto &i : a) cin >> i;\n  gr.assign(n, {} );\n  for (int i = 1; i < n; ++i) {\n    int u, v; cin >> u >> v; --u; --v;\n    gr[u].emplace_back(v);\n    gr[v].emplace_back(u);\n  }\n\n  f.assign(n, {} );\n  dfs(0, -1);\n  int ans = inf;\n  for (int i = 0; i < sz(f[0]); ++i) {\n    for (int j = 0; j < 2; ++j) if (f[0][i][j] ^ infLL && (!j || f[0][i][j] < 0) ) asMn(ans, i);\n  }\n\n  cout << ans << '\\n';\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n//#include \"pch.h\"\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <stdlib.h>\n\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <utility>\n#include <queue>\n#include <algorithm>\n#include <functional>\n#include <string>\n\n#define ll long long\n#define fri(n) for(i=0;i<(n);i++)\n#define frj(n) for(j=0;j<(n);i++)\n#define min(p,q) ((p)<(q)?(p):(q))\n#define max(p,q) ((p)>(q)?(p):(q))\n#define swap(p,q) r=(p);(p)=(q);(q)=r\n#define INF 1000000000000000000//10^18\n#define INFINT 2000000001//2*10^9+1\n#define MOD 1000000007//10^9+7\n#define PI acos(-1)\n\nusing namespace std;\n\nstatic vector<int> graph[5010];\nstatic ll int dp[5010][5010][3];\nstatic int a[5010];\nstatic int come[5010];\n\nint oneway(int x){\n\tint i;\n\tcome[x]=1;\n\n\tint to;\n\tauto itr=graph[x].begin();\n\n\tfor(itr=graph[x].begin();itr!=graph[x].end();){\n\t\tto=*itr;\n\t\tif(come[to]==1){\n\t\t\titr=graph[x].erase(itr);\n\t\t\tcontinue;\n\t\t}else{\n\t\t\toneway(to);\n\t\t}\n\n\t\titr++;\n\t}\n\n\treturn 0;\n}\n\nint search(int x){\n\tint i,j,k,l;\n\tll int temp[5010];\n\tint to;\n\tll int c,d,e;\n\tint flag=0;\n\n\n\tfor(i=0;i<graph[x].size();i++){\n\t\tsearch(graph[x][i]);\n\t}\n\t\n\tif(graph[x].size()!=0){\n\t\tdp[x][0][0]=a[x];\n\t\tdp[x][0][1]=0;\n\t\tdp[x][1][1]=0;\n\n\t\tfor(i=0;i<graph[x].size();i++){\n\t\t\tto=graph[x][i];\n\t\t\tc=dp[to][0][1];\n\t\t\td=dp[x][0][1];\n\t\t\te=dp[to][2][1];\n\t\t\tfor(j=0;j<=d;j++){\n\t\t\t\ttemp[j]=dp[x][j][0];\n\t\t\t\tdp[x][j][0]=INF;\n\t\t\t}\n\n\t\t\tfor(j=0;j<=d;j++){\n\t\t\t\tfor(k=0;k<=c;k++){\n\t\t\t\t\tdp[x][j+k][0]=min(dp[x][j+k][0],temp[j]+dp[to][k][0]);\n\t\t\t\t}\n\t\t\t\tif(e!=INF){\n\t\t\t\t\tdp[x][j+e][0]=min(dp[x][j+e][0],temp[j]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(e!=INF){\n\t\t\t\tdp[x][0][1]=dp[x][0][1]+c+1;\n\t\t\t}else{\n\t\t\t\tdp[x][0][1]=dp[x][0][1]+c;\n\t\t\t}\n\n\t\t\tif(dp[x][1][1]!=INF){\n\t\t\t\tif(a[x]<0){\n\t\t\t\t\tdp[x][1][1]=INF;\n\t\t\t\t}else if(dp[to][1][1]!=INF){\n\t\t\t\t\tdp[x][1][1]=dp[x][1][1]+dp[to][1][1];\n\t\t\t\t}else{\n\t\t\t\t\tif(e!=INF){\n\t\t\t\t\t\tdp[x][1][1]=dp[x][1][1]+e;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdp[x][1][1]=INF;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tflag=0;\n\t\tfor(i=0;i<dp[x][1][1];i++){\n\t\t\tif(dp[x][i][0]<0){\n\t\t\t\tdp[x][2][1]=i+1;\n\t\t\t\tflag=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag==0) dp[x][2][1]=dp[x][1][1]+1;\n\n\n\t}else{\n\t\tdp[x][0][0]=a[x];\n\t\tdp[x][0][1]=0;\n\t\tif(a[x]>0) dp[x][1][1]=0;\n\t\tdp[x][2][1]=1;\n\t}\n\n\treturn 0;\n}\n\n\n\n\n\nint main(void)\n{\n\t//変数の宣言\n\tint n;\n//\tint a[5010];\n\tint u;\n\tint v;\n//\tvector<int> graph[5010];\n//\tll int dp[5010][5010][3];\n\n\t//よく使う変数\n\tint i,j,k,l;\n\tint flag=0;\n\tint ans=0;\n\tint count=0;\n\tll int temp,temp1,temp2;\n\tint max,min;\n\tint len;\n\tint sum=0;\n\tint ok,ng;\n\n\n\n\t//データの読み込み\n\n\tscanf(\"%d\",&n);\n//\tscanf_s(\"%d\",&n);\n\n\tfor(i=1;i<=n;i++){\n\t\tscanf(\"%d\",&a[i]);\n//\t\tscanf_s(\"%d\",&a[i]);\n\t}\n\n\tfor(i=0;i<n-1;i++){\n\t\tscanf(\"%d %d\",&u,&v);\n//\t\tscanf_s(\"%d %d\",&u,&v);\n\t\tgraph[u].push_back(v);\n\t\tgraph[v].push_back(u);\n\t}\n\n\t//\tprintf(\"nは%dです\\n\", n);\n\t//\tprintf(\"データの読み込み終了\\n\");\n\t//実際の処理\n\n\tfor(i=0;i<5010;i++){\n\t\tcome[i]=0;\n\t\tfor(j=0;j<5010;j++){\n\t\t\tfor(k=0;k<3;k++){\n\t\t\t\tdp[i][j][k]=INF;\n\t\t\t}\n\t\t}\n\t}\n\n\toneway(1);\n\n\n\tsearch(1);\n\n\t//\tprintf(\"計算部分終了\\n\");\n\n\t//出力\n\t\n\n\tprintf(\"%d\",dp[1][2][1]-1);\n\n\t//\tprintf(\"結果の出力終了\\n\");\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "../E.cpp"
  },
  {
    "language": "C++",
    "code": "\n//#include \"pch.h\"\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <stdlib.h>\n\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <utility>\n#include <queue>\n#include <algorithm>\n#include <functional>\n#include <string>\n\n#define ll long long\n#define fri(n) for(i=0;i<(n);i++)\n#define frj(n) for(j=0;j<(n);i++)\n#define min(p,q) ((p)<(q)?(p):(q))\n#define max(p,q) ((p)>(q)?(p):(q))\n#define swap(p,q) r=(p);(p)=(q);(q)=r\n#define INF 1000000000000000000//10^18\n#define INFINT 2000000001//2*10^9+1\n#define MOD 1000000007//10^9+7\n#define PI acos(-1)\n\nusing namespace std;\n\nstatic vector<int> graph[5010];\nstatic ll int dp[5010][5010][3];\nstatic int a[5010];\nstatic int come[5010];\n\nint oneway(int x){\n\tint i;\n\tcome[x]=1;\n\n\tint to;\n\tauto itr=graph[x].begin();\n\n\tfor(itr=graph[x].begin();itr!=graph[x].end();){\n\t\tto=*itr;\n\t\tif(come[to]==1){\n\t\t\titr=graph[x].erase(itr);\n\t\t\tcontinue;\n\t\t}else{\n\t\t\toneway(to);\n\t\t}\n\n\t\titr++;\n\t}\n\n\treturn 0;\n}\n\nint search(int x){\n\tint i,j,k,l;\n\tll int temp[5010];\n\tint to;\n\tll int c,d,e;\n\tint flag=0;\n\n\n\tfor(i=0;i<graph[x].size();i++){\n\t\tsearch(graph[x][i]);\n\t}\n\t\n\tif(graph[x].size()!=0){\n\t\tdp[x][0][0]=a[x];\n\t\tdp[x][0][1]=0;\n\t\tdp[x][1][1]=0;\n\n\t\tfor(i=0;i<graph[x].size();i++){\n\t\t\tto=graph[x][i];\n\t\t\tc=dp[to][0][1];\n\t\t\td=dp[x][0][1];\n\t\t\te=dp[to][2][1];\n\t\t\tfor(j=0;j<=d;j++){\n\t\t\t\ttemp[j]=dp[x][j][0];\n\t\t\t\tdp[x][j][0]=INF;\n\t\t\t}\n\n\t\t\tfor(j=0;j<=d;j++){\n\t\t\t\tfor(k=0;k<=c;k++){\n\t\t\t\t\tdp[x][j+k][0]=min(dp[x][j+k][0],temp[j]+dp[to][k][0]);\n\t\t\t\t}\n\t\t\t\tdp[x][j+e][0]=min(dp[x][j+e][0],temp[j]);\n\t\t\t}\n\n\t\t\tdp[x][0][1]=dp[x][0][1]+c+1;\n\n\t\t\tif(dp[x][1][1]!=INF){\n\t\t\t\tif(a[x]<0){\n\t\t\t\t\tdp[x][1][1]=INF;\n\t\t\t\t}else if(dp[to][1][1]!=INF){\n\t\t\t\t\tdp[x][1][1]=dp[x][1][1]+dp[to][1][1];\n\t\t\t\t}else{\n\t\t\t\t\tdp[x][1][1]=dp[x][1][1]+e;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tflag=0;\n\t\tfor(i=0;i<dp[x][1][1];i++){\n\t\t\tif(dp[x][i][0]<0){\n\t\t\t\tdp[x][2][1]=i+1;\n\t\t\t\tflag=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag==0) dp[x][2][1]=dp[x][1][1]+1;\n\n\n\t}else{\n\t\tdp[x][0][0]=a[x];\n\t\tdp[x][0][1]=0;\n\t\tif(a[x]>0) dp[x][1][1]=0;\n\t\tdp[x][2][1]=1;\n\t}\n\n\treturn 0;\n}\n\n\n\n\n\nint main(void)\n{\n\t//変数の宣言\n\tint n;\n//\tint a[5010];\n\tint u;\n\tint v;\n//\tvector<int> graph[5010];\n//\tll int dp[5010][5010][3];\n\n\t//よく使う変数\n\tint i,j,k,l;\n\tint flag=0;\n\tint ans=0;\n\tint count=0;\n\tll int temp,temp1,temp2;\n\tint max,min;\n\tint len;\n\tint sum=0;\n\tint ok,ng;\n\n\n\n\t//データの読み込み\n\n\tscanf(\"%d\",&n);\n//\tscanf_s(\"%d\",&n);\n\n\tfor(i=1;i<=n;i++){\n\t\tscanf(\"%d\",&a[i]);\n//\t\tscanf_s(\"%d\",&a[i]);\n\t}\n\n\tfor(i=0;i<n-1;i++){\n\t\tscanf(\"%d %d\",&u,&v);\n//\t\tscanf_s(\"%d %d\",&u,&v);\n\t\tgraph[u].push_back(v);\n\t\tgraph[v].push_back(u);\n\t}\n\n\t//\tprintf(\"nは%dです\\n\", n);\n\t//\tprintf(\"データの読み込み終了\\n\");\n\t//実際の処理\n\n\tfor(i=0;i<5010;i++){\n\t\tcome[i]=0;\n\t\tfor(j=0;j<5010;j++){\n\t\t\tfor(k=0;k<3;k++){\n\t\t\t\tdp[i][j][k]=INF;\n\t\t\t}\n\t\t}\n\t}\n\n\toneway(1);\n\n\n\tsearch(1);\n\n\t//\tprintf(\"計算部分終了\\n\");\n\n\t//出力\n\t\n\n\tprintf(\"%d\",dp[1][2][1]-1);\n\n\t//\tprintf(\"結果の出力終了\\n\");\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define i64 long long int\nconst i64 INF = (i64)(1e18);\nint n,sz[5555];\ni64 a[5555];\nbool dp1[5555][5555];\ni64 dp2[5555][5555];\n//current vertex as root, M cuts in subtree:\n//dp1: if all positive reachable?\n//dp2: minimized value of root block?\nvector<int> e[5555];\nvoid dfs(int x,int fat){\n\tsz[x] = 1;\n\tif(a[x] > 0)dp1[x][0] = true;\n\tdp2[x][0] = a[x];\n\tbool tmp1[5555];i64 tmp2[5555];\n\tfor(auto y : e[x]){\n\t\tif(y == fat)continue;\n\t\tdfs(y, x);\n\t\tfor(int i=0; i<sz[x]+sz[y]; i++){\n\t\t\ttmp1[i] = false;\n\t\t\ttmp2[i] = INF;\n\t\t}\n\t\tfor(int i=0; i<sz[x]; i++)for(int j=0; j<sz[y]; j++){\n\t\t\t//Cut at the root of Y.\n\t\t\tif(dp1[x][i]){\n\t\t\t\tif(dp1[y][j] || dp2[y][j] < 0)\n\t\t\t\t\ttmp1[i+j+1] = true;\n\t\t\t}\n\t\t\tif(dp2[x][i] != INF){\n\t\t\t\tif(dp1[y][j] || dp2[y][j] < 0)\n\t\t\t\t\ttmp2[i+j+1] = min(tmp2[i+j+1], dp2[x][i]);\n\t\t\t}\n\t\t\t//Not cut at the root of Y.\n\t\t\tif(dp1[x][i]){\n\t\t\t\tif(dp1[y][j])\n\t\t\t\t\ttmp1[i+j] = true;\n\t\t\t}\n\t\t\tif(dp2[x][i] != INF){\n\t\t\t\ttmp2[i+j] = min(tmp2[i+j], dp2[x][i] + dp2[y][j]);\n\t\t\t}\n\t\t}\n\t\tmemcpy(dp1[x], tmp1, sizeof(tmp1));\n\t\tmemcpy(dp2[x], tmp2, sizeof(tmp2));\n\t\tsz[x] += sz[y];\n\t}\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin >> n;for(int i=1; i<=n; i++)cin >> a[i];\n\tfor(int i=1; i<n; i++){\n\t\tint x,y;\n\t\tcin >> x >> y;\n\t\te[x].push_back(y);\n\t\te[y].push_back(x);\n\t}\n\tdfs(1, 1);\n\tfor(int i=0; i<n; i++)if(dp1[1][i] || dp2[1][i] < 0){\n\t\tprintf(\"%d\\n\",i);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\n\nconst ll INF = 100000000000000000;\n\nstruct Graph\n{\n    int n;\n    vector<vector<int>> g;\n    \n    Graph(int n) : n(n){\n        g.resize(n);\n    }\n    \n    void init(int n_){\n        n = n_;\n        g.resize(n_);\n    }\n    \n    void add_edge(int from, int to){\n        g[from].push_back(to);\n    }\n};\n\nstruct Tree\t//create tree(directed) from graph(undirected)\n{\n    int n;\n    int root;\n    vector<vector<int>> t;\n    vector<int> par;\n    vector<int> dpt;\n    \n    void init(Graph &g, int root_){\n        n = g.n;\n        root = root_;\n        t.resize(n);\n        par.resize(n);\n        dpt.resize(n);\n        fill(dpt.begin(), dpt.end(), -1);\n        queue<int> que;\n        par[root] = -1;\n        dpt[root] = 0;\n        que.push(root);\n        while(que.size()){\n            int pa = que.front();\n            que.pop();\n            for(int ch : g.g[pa]){\n                if(dpt[ch] == -1){\n                    t[pa].push_back(ch);\n                    par[ch] = pa;\n                    dpt[ch] = dpt[pa] + 1;\n                    que.push(ch);\n                }\n            }\n        }\n    }\n\n    Tree(){}\n    \n    Tree(Graph &g, int root_){\n        init(g, root_);\n    }\n    \n    vector<int> toposort(){\n        typedef pair<int, int> P;\n        vector<P> p(n);\n        for(int i = 0; i < n; i++) p[i] = P(dpt[i], i);\n        sort(p.begin(), p.end(), greater<P>());\n        vector<int> res(n);\n        for(int i = 0; i < n; i++) res[i] = p[i].second;\n        return res;\n    }\n};\n\nll dp[5005][2][5005];\nint w[5005];\n\nint main()\n{\n    int n;\n    cin >> n;\n    ll a[5005];\n    for(int i = 0; i < n; i++) cin >> a[i];\n    Graph g(n);\n    for(int i = 0; i < n - 1; i++){\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        g.add_edge(u, v);\n        g.add_edge(v, u);\n    }\n    Tree t(g, 0);\n    vector<int> d = t.toposort();\n    int s[5002];\n    for(int i = 0; i < n; i++){\n        int u = d[i];\n        s[u] = 1;\n        for(int v : t.t[u]){\n            s[u] += s[v];\n        }\n    }\n    for(int i = 0; i < n; i++){\n        for(int k = 0; k <= n; k++) dp[i][0][k] = dp[i][1][k] = INF;\n        dp[i][0][0] = 0;\n    }\n    for(int i = 0; i < n; i++){\n        int u = d[i];\n        int r = 1;\n        for(int j = 1; j <= (int)t.t[u].size(); j++){\n            int v = t.t[u][j - 1];\n            for(int k = 0; k < r + s[u]; k++){\n                dp[u][j % 2][k] = INF;\n            }\n            for(int k = 0; k < r; k++){\n                for(int l = 0; l <= s[v]; l++){\n                    dp[u][j % 2][k + l] = min(dp[u][j % 2][k + l], dp[u][(j + 1) % 2][k] + dp[v][0][l]);\n                }\n            }\n            r += s[v];\n            for(int k = 1; k < r; k++){\n                dp[u][j % 2][k] = min(dp[u][j % 2][k], dp[u][j % 2][k - 1]);\n            }\n        }\n        if((int)t.t[u].size() % 2){\n            for(int k = 0; k < r; k++) dp[u][0][k] = dp[u][1][k];\n        }\n        for(int k = 0; k < r; k++) dp[u][0][k] += a[u];\n        if(a[u] > 0){\n            for(int v : t.t[u]){\n                int k;\n                for(k = 0; k <= s[u]; k++){\n                    if(dp[v][0][k] < 0) break;\n                }\n                w[u] += min(w[v], k + 1);\n            }\n            for(int k = w[u] + 1; k <= s[u]; k++) dp[u][0][k] = min(dp[u][0][k], 0ll);\n        }\n        else{\n            w[u] = n;\n            dp[u][0][r] = dp[u][0][r - 1];\n        }\n    }\n    int ans;\n    for(ans = 0; ans <= s[0]; ans++){\n        if(dp[0][0][ans] < 0) break;\n    }\n    ans = min(ans, w[0]);\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n)  for(long long i=0;i<(long long)(n);i++)\n#define REP(i,k,n) for(long long i=k;i<(long long)(n);i++)\n#define all(a) a.begin(),a.end()\n#define pb push_back\n#define eb emplace_back\n#define lb(v,k) (lower_bound(all(v),k)-v.begin())\n#define ub(v,k) (upper_bound(all(v),k)-v.begin())\n#define fi first\n#define se second\n#define pi M_PI\n#define PQ(T) priority_queue<T>\n#define SPQ(T) priority_queue<T,vector<T>,greater<T>>\n#define dame(a) {out(a);return 0;}\n#define decimal cout<<fixed<<setprecision(15);\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef tuple<ll,ll,ll> PP;\ntypedef tuple<ll,ll,ll,ll> PPP;\ntypedef multiset<ll> S;\nusing vi=vector<ll>;\nusing vvi=vector<vi>;\nusing vvvi=vector<vvi>;\nusing vp=vector<P>;\nusing vvp=vector<vp>;\nusing vb=vector<bool>;\nusing vvb=vector<vb>;\nconst ll inf=1001001001001001001;\nconst int INF=1001001001;\nconst int mod=998244353;\nconst double eps=1e-10;\ntemplate<class T> bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<class T> bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<class T> void out(T a){cout<<a<<'\\n';}\ntemplate<class T> void outp(T a){cout<<'('<<a.fi<<','<<a.se<<')'<<'\\n';}\ntemplate<class T> void outvp(T v){rep(i,v.size())cout<<'('<<v[i].fi<<','<<v[i].se<<')';cout<<'\\n';}\ntemplate<class T> void outvvp(T v){rep(i,v.size())outvp(v[i]);}\ntemplate<class T> void outv(T v){rep(i,v.size()){if(i)cout<<' ';cout<<v[i];}cout<<'\\n';}\ntemplate<class T> void outvv(T v){rep(i,v.size())outv(v[i]);}\ntemplate<class T> bool isin(T x,T l,T r){return (l)<=(x)&&(x)<=(r);}\ntemplate<class T> void yesno(T b){if(b)out(\"yes\");else out(\"no\");}\ntemplate<class T> void YesNo(T b){if(b)out(\"Yes\");else out(\"No\");}\ntemplate<class T> void YESNO(T b){if(b)out(\"YES\");else out(\"NO\");}\ntemplate<class T> void noyes(T b){if(b)out(\"no\");else out(\"yes\");}\ntemplate<class T> void NoYes(T b){if(b)out(\"No\");else out(\"Yes\");}\ntemplate<class T> void NOYES(T b){if(b)out(\"NO\");else out(\"YES\");}\nvoid outs(ll a,ll b){if(a>=inf-100)out(b);else out(a);}\nll gcd(ll a,ll b){if(b==0)return a;return gcd(b,a%b);}\nll modpow(ll a,ll b){a%=mod;if(b==0)return 1;if(b&1)return a*modpow(a,b-1)%mod;ll k=modpow(a,b/2);return k*k%mod;}\nvi val,sz;\nvvi g,dp,dp1;\nvoid dfs(int v,int p){\n    sz[v]=1;\n    for(ll x:g[v])if(x!=p){\n        dfs(x,v);\n        sz[v]+=sz[x];\n    }\n    vi sdp(1),sdp1(1);\n    sdp[0]=val[v];\n    if(val[v]>0)sdp1[0]=1;\n    for(ll x:g[v])if(x!=p){\n        vi ndp(sdp.size()+sz[x],inf),ndp1(sdp.size()+sz[x]);\n        rep(i,sdp.size())rep(j,sz[x]){\n            chmin(ndp[i+j],sdp[i]+dp[x][j]);\n            if(dp1[x][j]||dp[x][j]<0)chmin(ndp[i+j+1],sdp[i]);\n            if(sdp1[i]){\n                if(dp[x][j]<0||dp1[x][j])ndp1[i+j+1]=1;\n                if(dp1[x][j])ndp1[i+j]=1;\n            }\n        }\n        sdp=ndp;\n        sdp1=ndp1;\n    }\n    dp[v]=sdp;\n    dp1[v]=sdp1;\n}\nint main(){\n    ll n;cin>>n;\n    val=vi(n);\n    sz=vi(n);\n    dp1=vvi(n);\n    dp=vvi(n);\n    rep(i,n)cin>>val[i];\n    g=vvi(n);\n    rep(i,n-1){\n        ll a,b;cin>>a>>b;a--;b--;\n        g[a].pb(b);\n        g[b].pb(a);\n    }\n    dfs(0,-1);\n    ll ans=0;\n    while(dp[0][ans]>0&&!dp1[0][ans])ans++;\n    out(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FAST ios_base::sync_with_stdio(false); cin.tie(0);\n#define pb push_back\n#define eb emplace_back\n#define ins insert\n#define f first\n#define s second\n#define cbr cerr << \"hi\\n\"\n#define mmst(x, v) memset((x), v, sizeof ((x)))\n#define siz(x) ll(x.size())\n#define all(x) (x).begin(), (x).end()\n#define lbd(x,y) (lower_bound(all(x),y)-x.begin())\n#define ubd(x,y) (upper_bound(all(x),y)-x.begin())\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());    //can be used by calling rng() or shuffle(A, A+n, rng)\ninline long long rand(long long x, long long y) { return (rng() % (y+1-x)) + x; } //inclusivesss\nstring inline to_string(char c) {string s(1,c);return s;} template<typename T> inline T gcd(T a,T b){ return a==0?llabs(b):gcd(b%a,a); }\n\ntypedef long long ll; \ntypedef long double ld;\n#define FOR(i,s,e) for(ll i=s;i<=ll(e);++i)\n#define DEC(i,s,e) for(ll i=s;i>=ll(e);--i)\ntypedef pair<ll,ll>pi; typedef pair<ll,pi>spi; typedef pair<pi,pi>dpi;\n\n#define LLINF ((long long)1e18)\n#define INF int(1e9+1e6)\n#define MAXN (5006)\nll n,A[MAXN],dp[MAXN][MAXN][2],sz[MAXN];// if 0 then max, 1 then min\nvector<int>v[MAXN];\nvoid dfs(ll x,ll p){\n\tsz[x]=1;\n\tdp[x][0][1]=A[x];\n\tfor(auto i:v[x]) if(i^p) dfs(i,x), sz[x]+=sz[i];\n\tfor(auto i:v[x]) if(i^p) {\n\t\tDEC(j,sz[x],0){\n\t\t\tif(dp[x][j][1]<LLINF) dp[x][j][1] += dp[i][0][1];\n\t\t\tFOR(k,1,min(j,sz[i])){\n\t\t\t\tdp[x][j][1]=min(dp[x][j][1],dp[x][j-k][1]+dp[i][k][1]);\n\t\t\t\tif(dp[i][k-1][0]!=LLINF) dp[x][j][1]=min(dp[x][j][1],dp[x][j-k][1]);\n\t\t\t}\n\t\t}\n\t}\n\tif(A[x]>0){\n\t\tdp[x][0][0]=A[x];\n\t\tfor(auto i:v[x]) if(i^p) {\n\t\t\tDEC(j,sz[x],0){\n\t\t\t\tdp[x][j][0] += dp[i][0][0], dp[x][j][0]=min(dp[x][j][0],LLINF);\n\t\t\t\tFOR(k,1,min(j,sz[i])){\n\t\t\t\t\tdp[x][j][0]=min(dp[x][j][0],dp[x][j-k][0]+dp[i][k][0]);\n\t\t\t\t\tif(dp[i][k-1][1] < 0) dp[x][j][0]=min(dp[x][j][0],dp[x][j-k][0]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tFAST\n\tcin>>n;\n\tFOR(i,1,n)cin>>A[i];\n\tFOR(i,2,n){\n\t\tll a,b;cin>>a>>b;\n\t\tv[a].eb(b),v[b].eb(a);\n\t}\n\tFOR(i,0,MAXN-1)FOR(j,0,MAXN-1)FOR(b,0,1)dp[i][j][b]=LLINF;\n\tdfs(1,1);\n\tll ans = n-1;\n\tFOR(k,0,n-1) if(dp[1][k][1] < 0) ans = min(ans, k);\n\tFOR(k,0,n-1) if(dp[1][k][0] != LLINF) ans = min(ans, k);\n\tcout<<ans<<'\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define F first\n#define S second\n#define int long long\n#define ll long long\n//#define int  unsigned long long\n#define pb push_back\n//#define double long double\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef  tree< int , null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\nconst int mod = 1e9 + 7;\nconst int N = 5050;\nconst int K = 20;\nint dp1[N], dp2[N][N], sz[N], a[N];\nvector < int > g[N];\nint s[N];\nvoid dfs(int v, int p = -1){\n    sz[v]++;\n    s[v] = a[v];\n    for (auto u: g[v]){\n        if (u == p) continue;\n        dfs(u, v);\n        s[v] += s[u];\n        int x = dp1[u];\n        for (int i = 0; i <= sz[u]; i++){\n            if (dp2[u][i] < 0) x = min(x, i + 1);\n        }\n        for (int i = 0; i < sz[u]; i++){\n            if (dp1[u] + 1 < N) dp2[u][dp1[u] + 1] = min(dp2[u][dp1[u] + 1], 0LL);\n        }\n        dp1[u] = min(dp1[u], x);\n        if (sz[v] == 1){\n            for (int i = 0; i <= sz[u]; i++) dp2[v][i] = dp2[u][i];\n        } else{\n            for (int i = sz[v] + sz[u]; i >= 0; i--){\n                for (int j = min(sz[u], i); j >= 0; j--){\n                    dp2[v][i] = min(dp2[v][i], dp2[v][i - j] + dp2[u][j]);\n                }\n            }\n        }\n        sz[v] += sz[u];\n        dp1[v] += dp1[u];\n    }\n    if (a[v] < 0){\n        dp1[v] = 1e15;\n        dp2[v][0] = s[v] - a[v];\n    }\n   // cout << \"s[v] = \" << s[v] << \" v = \" << v << endl;\n    if (g[v].size() == 1 && p != -1){\n        if (a[v] > 0){\n            dp1[v] = 0;\n            dp2[v][0] = 1e15;\n            dp2[v][1] = 1e15;\n        } else{\n            dp2[v][0] = a[v];\n            dp2[v][1] = 1e15;\n            dp1[v] = 1e15;\n        }\n    } else{\n        for (int i = 0; i < sz[v]; i++){\n        dp2[v][i] += a[v];\n        }\n    };\n}\nmain(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    //freopen(\"input.txt\", \"r\", stdin);\n    int n;\n    cin >> n;\n    for (int i = 1; i <= n; i++){\n        cin >> a[i];\n    }\n    for (int i = 1; i < n; i++){\n        int u, v;\n        cin >> u >> v;\n        g[u].pb(v);\n        g[v].pb(u);\n    }\n    dfs(1);\n    int ans = dp1[1];\n    for (int i = 1; i <= n; i++){\n        if (dp2[1][i] < 0) ans = min(ans, i);\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stdio.h>\n#include <vector>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stdlib.h>\n#include <time.h>\n#include <iomanip>\n#include <math.h>\n#include <bitset>\n\nusing namespace std;\n\n#define taskname \"A\"\n#define LL long long \n#define uLL unsigned long long \n#define FOR(i,l,r) for(int i = l; i <= r; ++i)\n#define REP(i,l,r) for(int i = l; i < r; ++i)\n#define FORD(i,r,l) for(int i = r; i >= l; --i)\n#define REPD(i,r,l) for(int i = r; i > l; --i)\n#define sz(x) (int)((x).size())\n#define all(x) (x).begin(), (x).end()\n#define debug(x) { cerr << #x << \" = \" << x << endl; }\n#define sci(x) int x; scanf(\"%d\", &x);\n#define scii(x, y) int x, y; scanf(\"%d %d\", &x, &y);\n#define sciii(x, y, z) int x, y, z; scanf(\"%d %d %d\", &x, &y, &z);\n#define pi pair<int,int>\n#define pii pair<int,pi>\n#define piLL pair<LL,LL>\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define _USE_MATH_DEFINES \n/* M_PI */\n#define SetLength2(a, n, t) a=((t*) calloc(n, sizeof(t))) + (n)/2\n\nconst int maxN = 5001;\nconst LL oo = 1e17 + 11;\n\nint tcases = 1;\n\nint N,M,total = 0,res = 0;\nvector <int> e[maxN];\nint C[maxN];\nLL W[maxN],A[maxN],F[maxN][maxN],f1[maxN],g1[maxN];\nbool G[maxN][maxN];\npiLL tmp[maxN],fg[maxN];\n\nvoid dfs(int u,int p = 0){\n    W[u] = A[u];\n    C[u] = 1;\n    REP(i,0,e[u].size()){\n        int v = e[u][i];\n        if(v == p) continue;\n        dfs(v,u);\n        W[u] += W[v];\n        C[u] += C[v];\n    }\n}\nvoid cal(int u,int p = 0){\n    REP(i,0,e[u].size()){\n        int v = e[u][i];\n        if(v == p) continue;\n        cal(v,u);\n    }\n    //\n    F[u][0] = W[u];\n    if(C[u] == 1) G[u][0] = A[u] > 0;\n    else{\n        REP(i,0,C[u]) f1[i] = oo,g1[i] = 0;\n        f1[0] = A[u]; g1[0] = A[u] < 0;\n        \n        REP(node,0,e[u].size()){\n            int v = e[u][node];\n            if(v == p) continue;\n            // cal F[u][i]\n            REP(i,0,C[u]){\n                F[u][i] = oo; G[u][i] = 0;\n                FOR(j,0,min(C[v],i)){\n                    F[u][i] = min(F[u][i],f1[i - j] + F[v][j]);\n                    G[u][i] |= (g1[i - j] && G[v][j]);\n                }\n            }\n            REP(i,0,C[u]) f1[i] = F[u][i],g1[i] = G[u][i];\n        }\n        /*REP(i,0,C[u]){\n            F[u][i] += A[u];\n            if(A[u] < 0) G[u][i] = 0;\n        }*/\n    }\n    REP(i,0,C[u]){\n        if(F[u][i] < 0 || G[u][i]){\n            F[u][i + 1] = min(F[u][i + 1],0LL);\n            G[u][i + 1] = 1;\n        }\n    }\n}\nvoid testcase(){\n    scanf(\"%d\",&N);\n    FOR(i,1,N) scanf(\"%lli\",&A[i]);\n    \n    REP(i,1,N){\n        scii(u,v);\n        e[u].pb(v);\n        e[v].pb(u);\n    }\n    dfs(1);\n\n    FOR(i,1,N){\n        FOR(j,0,N) F[i][j] = oo;\n    }\n\n    cal(1);\n    \n    FOR(j,0,N) if(F[1][j] < 0 || G[1][j]){\n        printf(\"%d\",j);\n        return ;\n    }\n}\n\nint main(){\n    \n    //scanf(\"%d\",&tcases);\n    \n    FOR(i,1,tcases) testcase();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cassert>\n#include<cmath>\n#include<climits>\n#include<iomanip>\n#include<stack>\n#include<unordered_map>\n#include<bitset>\n#include<limits>\n#include<complex>\n#include<array>\n#include<numeric>\n#include<functional>\n\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rrep(i,m,n) for(ll (i)=(ll)(m);(i)>=(ll)(n);(i)--)\n#define rep(i,m,n) for(ll (i)=(ll)(m);i<(ll)(n);i++)\n#define REP(i,n) rep(i,0,n)\n#define FOR(i,c) for(decltype((c).begin())i=(c).begin();i!=(c).end();++i)\n#define all(hoge) (hoge).begin(),(hoge).end()\ntypedef pair<ll, ll> P;\nconstexpr long double m_pi = 3.1415926535897932L;\nconstexpr ll MOD = 1000000007;\nconstexpr ll INF = 1LL << 61;\nconstexpr long double EPS = 1e-10;\ntemplate<typename T> using vector2 = vector<vector<T>>;\ntemplate<typename T> using vector3 = vector<vector2<T>>;\ntypedef vector<ll> Array;\ntypedef vector<Array> Matrix;\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstruct Edge {//グラフ\n\tint to, rev; ll cap;\n\tEdge(int _to, ll _cap, int _rev) {\n\t\tto = _to; cap = _cap; rev = _rev;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid add_edge(Graph& G, int from, int to, ll cap, bool revFlag, ll revCap) {//最大フロー求める Ford-fulkerson\n\tG[from].push_back(Edge(to, cap, (ll)G[to].size()));\n\tif (revFlag)G[to].push_back(Edge(from, revCap, (ll)G[from].size() - 1));//最小カットの場合逆辺は0にする\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\t\tll n;\n\tcin >> n;\n\tArray a(n);\n\tREP(i, n)cin >> a[i];\n\tGraph g(n);\n\tREP(i, n - 1) {\n\t\tll a, b; cin >> a >> b;\n\t\ta--; b--;\n\t\tadd_edge(g, a, b, 1, true, 1);\n\t}\n\n\tauto solve = [&](auto solve, ll x, ll par)->Matrix {\n\t\tMatrix v(1, Array(2, INF));\n\t\tif (a[x] > 0)v[0][0] = a[x];\n\t\telse v[0][1] = a[x];\n\t\tfor (auto e : g[x]) {\n\t\t\tif (e.to == par)continue;\n\t\t\tauto u = solve(solve, e.to, x);\n\t\t\tMatrix dp(v.size()+u.size(), Array(2, INF));\n\t\t\tREP(i, v.size()) REP(incv, 2) {\n\t\t\t\tif (v[i][incv] == INF)continue;\n\t\t\t\tREP(j, u.size()) REP(incu, 2) {\n\t\t\t\t\tif (u[j][incu] == INF)continue;\n\t\t\t\t\t//cutしないとき\n\t\t\t\t\tll inc = (incv | incu);\n\t\t\t\t\tll cut = i + j;\n\t\t\t\t\tchmin(dp[cut][inc], v[i][incv] + u[j][incu]);\n\t\t\t\t\t//cutするとき\n\t\t\t\t\tif (incu == 1 && u[j][incu] >= 0)continue;\n\t\t\t\t\tinc = incv;\n\t\t\t\t\tcut++;\n\t\t\t\t\tchmin(dp[cut][inc], v[i][incv]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tv = dp;\n\t\t}\n\t\treturn v;\n\t};\n\tMatrix dp = solve(solve, 0, -1);\n\tll ans = INF;\n\tREP(i, dp.size()) {\n\t\tif (dp[i][0] != INF)chmin(ans, i);\n\t\tif (dp[i][1] < 0)chmin(ans, i);\n\t}\n\tcout << ans << \"\\n\";\n  \n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n                     .:*+=%@@@@@@=-.\n                 .:=@#@@@#@@#######%==*.\n              .-=####@######%*-.....:%##%.\n            .*@###########%+:--........-%@-\n          .*@##############@+--.........-:%-\n        .+##################@==%%%%=+*:----+.\n      .-@####################%++%@@@@@=+**%@@*\n      .%###################@%%@@@###@%+:--%@@%.\n     -@###################@%%%%*::*%++:-----=@+.\n    -#####################@%=++++++*:-------.-=:\n   .+####################@%++*::-:::--::*:::***=:\n   .@#####################%=++*::::-:::++*=##@@#@-\n  ..#####################@%%=++**:::::**+%@#@%%##-..\n   .%####################@@%=+++*+****::*=@######@.\n  .=######################@%%==+==++**+=@%@##@###+:...\n  -#######################@@@%%%===++=@@@%=++===*::--...\n  -########################@@@@@@@%==%%=++==@@:::::*:--.\n..:#########################@@@@@@%%======++++::-..:-.--...\n%#############################@###@%%@@%==%=%*----.--.::---.\n#############################################*-:*:-:---*---- .\n#############################################*--*--:---*---:-.\n#############################################+--::--::-*::-::.\n###########################################+:*-.---.---.:---*-..\n###########################################**:-----------------.\n##########################################@::**:--::::::--:::::-\n###########################################:--:*:::::::::**::*+*\n###########################################=:::***::::::**:::*+*\n############################@@@@@@#########@+****::::********+++\n############################@%%%%%@@@@@@@###%+***::::::::***+==+\n############################@%%%%%%%%%%%@####=+:::-::::-::*+=%%+\n#############################@%%%%%%%%%%@#####=::--------:*=%@%+\n%###########################@%%%%==%%%%%%@##@#=:------..-:+%@@%=\n----------------------------------------------\n--------------------------------------------\n----------------------------------------------\n--------------------------------------------\n----------------------------------------------\n\n         o###########oo\n      o##\"          \"\"##o\n    o#\"                \"##\n  o#\"                    \"#o\n #\"  ##              ##   \"##\n#\"                          ##\n#  ###################       #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#o                           #\n\"#o                         ##\n \"#o                       ##\n  \"#o                    o#\"\n   \"#o                  ##\n     \"#o              o#\"\n       \"#ooo      ooo#######oo\n        ###############   \"######o\n     o###\"\"        \"###o      # ###\n   o###o     oooo    ###    oo####\"\n o###**#     #**#   ############\"\n \"\"##\"\"\"\"\"\"\"\"\"\"###########    #\n    # oooooooo#\"#**     ##    #\n    # #       # # **    ##    #\n    #o#       #o#  *****###ooo#\n                        ##\n                        ##   o###o\n                        ## o##***##\n               o########## #***#**##o\n             o##\"   \"\"###  #***##***#\n o#######o  ###   oo####   ##**####*#\no##\"  \"\"#############\"\"     ##****###\n##\"         ##              ##*##*###\n##          ###              ##### ##\n##           ###              # ##  #\n##            ##                 #\n##             ##\n##             ###\n##              ###oo\n###              \"\"###\n ###\n  ###\n*/\n\n///YEAH IM THE BEST I'VE EVER WAS\n\n///SO HAPPY\n\n#include <bits/stdc++.h>\n\n#define popcnt(x) __builtin_popcount(x)\n\n#define fr first\n\n#define sc second\n\n#define m_p make_pair\n\n#define low_bo(a, x) lower_bound(a.begin(), a.end(), x) - a.begin()\n\n#define up_bo(a, x) upper_bound(a.begin(), a.end(), x) - a.begin()\n\n#define unique(a) a.resize(unique(a.begin(), a.end()) - a.begin())\n\n#define popcnt(x) __builtin_popcount(x)\n\n//#include <ext/pb_ds/assoc_container.hpp>\n\n//using namespace __gnu_pbds;\n\n//gp_hash_table<int, int> table;\n\n//#pragma GCC optimize(\"O3\")\n//#pragma GCC optimize(\"Ofast,no-stack-protector\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\n//#pragma GCC target(\"avx,tune=native\")\n//float __attribute__((aligned(32)))\n\n/*char memory[(int)1e8];\n\nchar memorypos;\n\ninline void * operator new(size_t n){\n    char * ret = memory + memorypos;\n    memorypos += n;\n    return (void *)ret;\n}\n\ninline void operator delete(void *){}\n*/\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef unsigned long long ull;\n\ntypedef long double ld;\n\ntypedef unsigned int uint;\n\nll sqr(ll x){\n    return x * x;\n}\n\nint mysqrt(ll x){\n    int l = 0, r = 1e9 + 1;\n    while (r - l > 1){\n        int m = (l + r) / 2;\n        if (m * (ll)m <= x)\n            l = m;\n        else\n            r = m;\n    }\n    return l;\n}\n\n#ifdef ONPC\n    mt19937 rnd(231);\n    mt19937_64 rndll(231);\n#else\n    mt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\n    mt19937_64 rndll(chrono::high_resolution_clock::now().time_since_epoch().count());\n#endif\nll AR = 19, BR = 13, CR = 23, XR = 228, YR = 322, MODR = 1e9 + 993;\n\nll myrand(){\n    ll ZR = (XR * AR + YR * BR + CR) % MODR;\n    XR = YR;\n    YR = ZR;\n    return ZR;\n}\n\nint gcd(int a, int b){\n    return a ? gcd(b % a, a) : b;\n}\n\nint gcdex(int a, int b, int &x, int &y){\n    if (a == 0){\n        x = 0;\n        y = 1;\n        return b;\n    }\n    int x1, y1;\n    int ret = gcdex(b % a, a, x1, y1);\n    x = y1 - (b / a) * x1;\n    y = x1;\n    return ret;\n}\n\nconst int Mod = 1e9 + 7;\n\nint Bpow(int x, ll y){\n    int ret = 1;\n    int w = x;\n    while (y){\n        if (y & 1)\n            ret = (ret * (ll)w) % Mod;\n        w = (w * (ll)w) % Mod;\n        y >>= 1;\n    }\n    return ret;\n}\n\nint Bdiv(int x){\n    int a, b;\n    gcdex(x, Mod, a, b);\n    if (a < 0)\n        a += Mod;\n    return a;\n}\n\nint Bdiv(int x, int y){\n    return (x * (ll)Bpow(y, Mod - 2)) % Mod;\n}\n\ninline int ad(int x, int y){\n    return x + y >= Mod ? x + y - Mod : x + y;\n}\n\ninline int dif(int x, int y){\n    return x - y < 0 ? x - y + Mod : x - y;\n}\n\ninline int mul(int x, int y){\n    return (x * (ll)y) % Mod;\n}\n\nint inv(int a){\n    int b = Mod, x = 0, y = 1;\n    while (a){\n        int t = b / a;\n        b -= a * t;\n        x -= t * y;\n        swap(a, b);\n        swap(x, y);\n    }\n    if (x < 0)\n        x += Mod;\n    return x;\n}\n\nvoid setmin(int &x, int y){\n    x = min(x, y);\n}\n\nvoid setmax(int &x, int y){\n    x = max(x, y);\n}\n\nvoid setmin(ll &x, ll y){\n    x = min(x, y);\n}\n\nvoid setmax(ll &x, ll y){\n    x = max(x, y);\n}\n\nconst ll llinf = 1e18 + 100;\n\nconst ld eps = 1e-9;\n\nconst int maxn = 5e3 + 10, maxw = 1e6 + 100, inf = 2e9 + 100, sq = 600, X = 43, LG = 17;\n\nll q[maxn][maxn][2];\n\nint a[maxn];\n\nint n;\n\nvector<int> e[maxn];\n\nint dfs(int v, int par) {\n    int sz = 1;\n    for (int i = 0; i <= n; i++)\n        for (int t = 0; t < 2; t++)\n        q[v][i][t] = llinf;\n    q[v][0][(a[v] < 0)] = a[v];\n    for (int i : e[v])\n    if (i != par) {\n        int to = dfs(i, v);\n        ll p[to + sz + 2][2];\n        for (int k = 0; k < to + sz + 2; k++)\n            for (int t = 0; t < 2; t++)\n                p[k][t] = llinf;\n        for (int x = sz; x >= 0; x--)\n        for (int t1 = 1; t1 >= 0; t1--)\n        if (q[v][x][t1] != llinf)\n            for (int y = to; y >= 0; y--)\n            for (int t2 = 1; t2 >= 0; t2--)\n            if (q[i][y][t2] != llinf) {\n                ll X = q[v][x][t1], Y = q[i][y][t2];\n                if (t2 == 0 || Y < 0)\n                    setmin(p[x + y + 1][t1], X);\n                if (t1 + t2 == 0)\n                    setmin(p[x + y][0], X + Y);\n                else\n                    setmin(p[x + y][1], X + Y);\n            }\n        for (int k = 0; k < to + sz + 2; k++)\n            for (int t = 0; t < 2; t++)\n                q[v][k][t] = p[k][t];\n        sz += to;\n    }\n    return sz;\n}\n\nint main()\n{\n    #ifdef ONPC\n    //ifstream cin(\"a.in\");\n    //ofstream cout(\"a.out\");\n    freopen(\"a.in\", \"r\", stdin);\n    freopen(\"a.out\", \"w\", stdout);\n    #else\n    //ifstream cin(\"gymnasts.in\");\n    //ofstream cout(\"gymnasts.out\");\n    //freopen(\"nextpartition.in\", \"r\", stdin);\n    //freopen(\"nextpartition.out\", \"w\", stdout);\n    #endif // ONPC\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n;\n    for (int i = 0; i < n; i++)\n        cin >> a[i];\n    for (int i = 1; i < n; i++) {\n        int v, u;\n        cin >> v >> u;\n        v--;\n        u--;\n        e[v].push_back(u);\n        e[u].push_back(v);\n    }\n    dfs(0, -1);\n    int ans = inf;\n    for (int i = 0; i <= n; i++) {\n        if (q[0][i][0] != llinf)\n            setmin(ans, i);\n        if (q[0][i][1] < 0)\n            setmin(ans, i);\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define Endl endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const deque<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class T,size_t n> ostream& operator<<(ostream &os, const array<T,n> &t) {\n\tos<<\"{\"; rep(i,n) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T,class U> ostream& operator<<(ostream &os, const tuple<S,T,U> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\ntemplate<class S, class T,class U,class V> ostream& operator<<(ostream &os, const tuple<S,T,U,V> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\",\"<<get<3>(t)<<\")\";}\ntemplate<class S, class T,class U,class V,class W> ostream& operator<<(ostream &os, const tuple<S,T,U,V,W> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\",\"<<get<3>(t)<<\",\"<<get<4>(t)<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n//#undef NUIP\n#ifdef NUIP\n#define out(args...){vector<string> a_r_g_s=s_p_l_i_t(#args, ','); e_r_r(a_r_g_s.begin(), args); }\nvector<string> s_p_l_i_t(const string &s, char c){vector<string> v;int d=0,f=0;string t;for(char c:s){if(!d&&c==',')v.pb(t),t=\"\";else t+=c;if(c=='\\\"'||c=='\\'')f^=1;if(!f&&c=='(')++d;if(!f&&c==')')--d;}v.pb(t);return move(v);}\nvoid e_r_r(vector<string>::iterator it) {}\ntemplate<typename T, typename... Args> void e_r_r(vector<string>::iterator it, T a, Args... args){ if(*it==\" 1\"||*it==\"1\") cerr<<endl; else cerr << it -> substr((*it)[0] == ' ', it -> length()) << \" = \" << a << \", \"; e_r_r(++it, args...);}\n#else\n#define out\n#endif\n#ifdef __cpp_init_captures\ntemplate<typename T>vector<T> table(int n, T v){ return vector<T>(n, v);}\ntemplate <class... Args> auto table(int n, Args... args){auto val = table(args...); return vector<decltype(val)>(n, move(val));}\n#endif\nconst ll MOD=1e9+7;\n\nstruct UF{\n  vector<int> data;\n  UF(int size):data(size,-1){}\n  bool unite(int x,int y){\n    x=root(x); y=root(y);\n    if(x!=y){\n      if(-data[y]>-data[x]) swap(x,y);\n      data[x]+=data[y]; data[y]=x;\n    }\n    return x!=y;\n  }\n  bool findSet(int x,int y){return root(x)==root(y);}\n  int root(int x){return data[x]<0?x:data[x]=root(data[x]);}\n  int size(int x) {return -data[root(x)];}\n};\n\nconst ll INF=1e14;\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n\tint n;\n\tcin>>n;\n\tvector<ll> a(n);\n\trep(i,n) cin>>a[i];\n\tvv<int> G(n);\n\tvv<int> g(n);\n\tUF uf(n);\n\trep(i,n-1){\n\t\tint x,y;\n\t\tcin>>x>>y; --x; --y;\n\t\tg[x].pb(y);\n\t\tg[y].pb(x);\n\t\tif(a[x]*a[y]>0) uf.unite(x,y);\n\t}\n\t// int rt;\n\t// rep(i,n){\n\t// \tint u=uf.root(i);\n\t// \tif(u==i) rt=i;\n\t// \telse a[u]+=a[i];\n\t// \tfor(int v:g[i]){\n\t// \t\tint t=uf.root(v);\n\t// \t\tif(t!=u) g[u].pb(t);\n\t// \t}\n\t// }\n\tvv<ll> dp(n);\n\tvv<ll> pos(n);\n\tvv<ll> cut(n);\n\tfunction<void(int,int)> dfs=\n\t\t[&](int v,int p){\n\t\t\tvector<ll> cur(1,a[v]);\n\t\t\tvector<ll> cpos(1,(a[v]>0));\n\t\t\tfor(int w:g[v])if(w!=p){\n\t\t\t\t\tdfs(w,v);\n\t\t\t\t\tvector<ll> nxt(cur.size()+dp[w].size()-1,INF);\n\t\t\t\t\tvector<ll> npos(nxt.size(),0);\n\t\t\t\t\trep(i,cur.size())rep(j,dp[w].size()){\n\t\t\t\t\t\tMN(nxt[i+j],cur[i]+dp[w][j]);\n\t\t\t\t\t\tif((pos[w][j]||cut[w][j]) && cpos[i]) npos[i+j]=1;\n\t\t\t\t\t}\n\t\t\t\t\tcur=nxt;\n\t\t\t\t\tcpos=npos;\n\t\t\t\t}\n\t\t\tdp[v]=cur;\n\t\t\tpos[v]=cpos;\n\t\t\t// if(sum<n){\n\t\t\t// \tif(dp[v].size()<=sum) dp[v].resize(sum+1,INF);\n\t\t\t// \tMN(dp[v][sum],0);\n\t\t\t// }\n\n\t\t\tdp[v].eb(INF);\n\t\t\tpos[v].eb(0);\n\t\t\tcut[v].resize(dp[v].size());\n\t\t\treps(i,1,dp[v].size())if(dp[v][i-1]<0 || pos[v][i-1]){\n\t\t\t\tcut[v][i]=1;\n\t\t\t\tMN(dp[v][i],0ll);\n\t\t\t}\n\t\t};\n\tdfs(0,-1);\n\tout(dp,pos,1);\n\tint re=n-1;\n\trep(i,dp[0].size())if(dp[0][i]<=0 || pos[0][i]) MN(re,i);\n\tcout<<re<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\n/*\nsum<0なら0で終わり\nそうじゃないなら？必ず正だけの地点を作る\n根付き木にしてdp？\ndp[i][j]:部分根付き木iまででj本切った時の最小値(iの上の部分を切ることも考えてる)\n葉lに対してdp[l][0]=v[l],dp[l][1]=0;\n親pに対して子をsとして、dp[p][k]=それぞれのそれ\nつまり？dp[p][k]はmin(sum(dp[s][j]:sum j = k))\n高速化の方法は？\nえーなんかdpまでは絶対に合っていると思っていて、\n+のやつを取るところに関しては+をなるべく大量に消費して欲しくて、マイナスは一個も入っちゃいけない\n-が入る方は、+にならないようになるべく大きく取りたい\n実は葉から貪欲？最後にくっつけられるところはくっつけていいとか\n根付き木にして、葉から貪欲にやっていく　具体的には\n・スタートが+の時\n+で有る限り取り続ける\n-が来た場合、-が大きくなるなら取って変更\n・スタートが-の時\n合計が負で有る限り取り続ける\n\n貪欲が終わった時塊は　a:全部+で次の-入れても+ or b:合計が負で次のやつで+\n・貪欲をした後\n自分の子とくっつけられるかを試す？\n自分がaの時　aは子の候補にいなくて、bは絶対無理　なので終わり\n自分がbの時　子のbは全部取り込める\n　　　　　　 これで子のaも取り込めるし次の+も取り込める場合は？\n　　　　　　　・子のaを取り込むメリット:そのさらに子を取り込める可能性が出てくる\nまってそもそも合流を考えられていない　いやそれは大丈夫かも\n*/\nint dp1[5123][5123],//dp1[v][k]:v以下k個、vのところは全部正の時のその最小値\n    dp2[5123][5123],//dp2[v][k]:v以下k個、vの所の最小値\n    dpt1[5123][5123],//dpt1[i][j]:vのi番目までの子までからなる部分木をdp1と同様にj個に分ける時の一番上の最小値\n    dpt2[5123][5123];//dpt2[i][j]:同様\n\nconst int INF=1e18;\n\ntemplate<typename T>\nvoid fin(T a){\n  cout<<a<<endl;\n  exit(0);\n}\n\ntemplate<typename T>\nvoid chmin(T &a,T b){\n  if(a>b)a=b;\n}\ntemplate<typename T>\nvoid chmax(T &a,T b){\n  if(a<b)a=b;\n}\n\nsigned main(){\n  int n;cin>>n;\n  vector<int> v(n);\n  for(int i=0;i<n;i++)cin>>v[i];\n  vector<int> edge[n];\n  for(int i=1;i<n;i++){\n    int u,v;cin>>u>>v;u--;v--;\n    edge[u].push_back(v);\n    edge[v].push_back(u);\n  }\n\n  int sum=0;for(int i=0;i<n;i++)sum+=v[i];if(sum<0)fin(0);\n\n  int r;int m=0;\n  for(int i=0;i<n;i++)\n    if(m<edge[i].size())\n      m=edge[i].size(),r=i;\n\n  vector<int> parent(n),son[n],d1(n,0),d2(n,0);\n  parent[r]=-1;\n  queue<int> que;\n  que.push(r);\n  while(que.size()){\n    int p=que.front();que.pop();\n    for(int q:edge[p]){\n      if(parent[p]==q)continue;\n      parent[q]=p;\n      son[p].push_back(q);\n      que.push(q);\n    }\n  }\n\n  for(int i=0;i<5123;i++)\n    for(int j=0;j<5123;j++)\n      dp1[i][j]=dp2[i][j]=dpt1[i][j]=dpt2[i][j]=INF;\n\n  vector<int> rem(n);\n  for(int i=0;i<n;i++)rem[i]=son[i].size();\n  for(int i=0;i<n;i++)if(!rem[i])que.push(i);\n\n  while(que.size()){\n    int p=que.front();que.pop();\n\n    dpt1[0][0]=0;\n\n    int N=son[p].size();\n\n    int nowj=0,tmpj=0;\n    for(int i=0;i<N;i++){\n      int q=son[p][i];\n      for(int j=0;j<=nowj;j++){\n        if(dpt1[i][j]==INF)continue;\n        for(int k=0;k<=d1[q];k++){\n          if(dp1[q][k]==INF)continue;\n          chmin(dpt1[i+1][j+k],dpt1[i][j]+dp1[q][k]);\n          chmax(tmpj,j+k);\n        }\n        dpt1[i][j]=INF;\n      }\n      nowj=tmpj;\n      tmpj=0;\n    }\n\n    for(int k=0;k<=nowj;k++){\n      if(dpt1[N][k]==INF)continue;\n      if(v[p]>0){\n        chmin(dp1[p][k],dpt1[N][k]+v[p]);\n        chmax(d1[p],k);\n        chmin(dp2[p][k+1],0LL);\n        chmax(d2[p],k+1);\n      }\n      dpt1[N][k]=INF;\n    }\n\n    dpt2[0][0]=0;\n\n    nowj=tmpj=0;\n    for(int i=0;i<N;i++){\n      int q=son[p][i];\n      for(int j=0;j<=nowj;j++){\n        if(dpt2[i][j]==INF)continue;\n        for(int k=0;k<=d2[q];k++){\n          if(dp2[q][k]==INF)continue;\n          chmin(dpt2[i+1][j+k],dpt2[i][j]+dp2[q][k]);\n          chmax(tmpj,j+k);\n        }\n        dpt2[i][j]=INF;\n      }\n      nowj=tmpj;\n      tmpj=0;\n    }\n\n    for(int k=0;k<=nowj;k++){\n      if(dpt2[N][k]==INF)continue;\n      chmin(dp2[p][k],dpt2[N][k]+v[p]);\n      chmax(d2[p],k);\n      if(dpt2[N][k]+v[p]<0){\n        chmin(dp1[p][k+1],0LL);\n        chmax(d1[p],k+1);\n        chmin(dp2[p][k+1],0LL);\n        chmax(d2[p],k+1);\n      }\n      dpt2[N][k]=INF;\n    }\n    if(~parent[p]&&--rem[parent[p]]==0)que.push(parent[p]);\n  }\n\n  int ans=INF;\n  for(int j=0;j<5000;j++){\n    if(dp1[r][j]!=INF)chmin(ans,j);\n    if(dp2[r][j]<0)chmin(ans,j);\n  }\n\n  cout<<ans<<endl;\n}\n\n/*\n解説AC\nアイデア的には合っていた　根付き木にして管理して\nただ実装面しっかり詰められていなかったしそもそも計算量的に無理だと思っていた\n各親について見るのか自分の下にいるもの分しかなくてO(N^2)っぽい？\nどうやら二乗の木DPというやつらしい\n要勉強\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nvector <int> g[5555];\nlong long dp[5005][5005];\nlong long fn[5005][5005];\nbool gn[5005][5005];\nbool pos[5005][5005];\n\nint sub[5555];\nint a[5555];\n\nconst long long inf = 1e15;\n\nvoid dfs(int x, int par) {\n\tsub[x] = 1;\n\tfor(auto i : g[x]) {\n\t\tif(i - par) {\n\t\t\tdfs(i, x);\n\t\t\tsub[x] += sub[i];\n\t\t}\n\t}\n\tvector <int> c;\n\tint deg = 0;\n\tfor(auto i : g[x]) {\n\t\tif(i - par) {\n\t\t\tc.emplace_back(i);\n\t\t\t++deg;\n\t\t}\n\t}\n\tfor(int i = 1; i <= deg; i++) {\n\t\tfor(int j = 0; j <= sub[x]; j++) {\n\t\t\tfn[i][j] = inf;\n\t\t\tgn[i][j] = false;\n\t\t}\n\t}\n\tfor(int j = 0; j <= sub[x]; j++) {\n\t\tgn[0][j] = (a[x] > 0);\n\t}\n\tint tot = 0;\n\tfor(int i = 1; i <= deg; i++) {\n\t\tint node = c[i - 1];\n\t\tfor(int j = 0; j <= tot; j++) {\n\t\t\tfor(int k = 0; k <= sub[node]; k++) {\n\t\t\t\tif(dp[node][k] < 0 || pos[node][k]) {\n\t\t\t\t\tfn[i][j + k + 1] = min(fn[i][j + k], fn[i - 1][j]);\n\t\t\t\t}\n\t\t\t\tfn[i][j + k] = min(fn[i][j + k], fn[i - 1][j] + dp[node][k]);\n\t\t\t}\n\t\t\tfor(int k = 0; k <= sub[node]; k++) {\n\t\t\t\tif(dp[node][k] < 0 || pos[node][k]) {\n\t\t\t\t\tgn[i][j + k + 1] |= gn[i - 1][j];\n\t\t\t\t}\n\t\t\t\tgn[i][j + k] |= gn[i - 1][j] & pos[node][k];\n\t\t\t}\n\t\t}\n\t\ttot += sub[node];\n\t}\n\tfor(int i = 0; i <= tot; i++) {\t\n\t\tdp[x][i] = a[x] + fn[deg][i];\n\t\tpos[x][i] = gn[deg][i];\n\t}\n}\nint main(int argc, char const *argv[])\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tfor(int i = 1; i < n; i++) {\n\t\tint p, q;\n\t\tscanf(\"%d %d\", &p, &q);\n\t\tg[p].emplace_back(q);\n\t\tg[q].emplace_back(p);\n\t}\n\tfor(int i = 0; i <= n; i++) {\n\t\tfor(int j = 0; j <= n; j++) {\n\t\t\tdp[i][j] = inf;\n\t\t}\n\t}\n\tdfs(1, 0);\n\tint ans = -1;\n\tfor(int i = n; i >= 0; i--) {\n\t\tif(dp[1][i] < 0 || pos[1][i]) {\n\t\t\tans = i;\n\t\t}\n\t}\n\tassert(ans >= 0);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define MAXN 5005\n#define eps 1e-10\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef unsigned int u32;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;T f = 1;char c = getchar();\n    while(c < '0' || c > '9') {\n        if(c == '-') f = -1;\n        c = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n        res = res * 10 + c - '0';\n        c = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n        out(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nstruct node {\n    int to,next;\n}E[MAXN * 2];\nint head[MAXN],sumE;\nbool vis[MAXN][MAXN][2],used[MAXN][2];\nint64 dp[MAXN][MAXN][2],A[MAXN],g[MAXN][2];\nint N,siz[MAXN],ans;\nvoid add(int u,int v) {\n    E[++sumE].to = v;\n    E[sumE].next = head[u];\n    head[u] = sumE;\n}\nvoid dfs(int u,int fa) {\n    if(A[u] < 0) {\n        vis[u][0][1] = 1;dp[u][0][1] = A[u];\n    }\n    if(A[u] > 0) {\n        vis[u][0][0] = 1;dp[u][0][0] = A[u];\n    }\n    for(int i = head[u] ; i ; i = E[i].next) {\n        int v = E[i].to;\n        if(v != fa) {\n            dfs(v,u);\n        }\n    }\n    memset(used,0,sizeof(used));\n    siz[u] = 1;\n    for(int i = head[u] ; i ; i = E[i].next) {\n        int v = E[i].to;\n        if(v != fa) {\n            for(int j = 0 ; j <= siz[u] + siz[v] ; ++j) used[j][0] = used[j][1] = 0;\n            for(int j = 0 ; j <= siz[u] ; ++j) {\n                for(int a = 0 ; a <= 1 ; ++a) {\n                    if(!vis[u][j][a]) continue;\n                    for(int h = 0 ; h <= siz[v] ; ++h) {\n                        for(int b = 0 ; b <= 1 ; ++b) {\n                            if(!vis[v][h][b]) continue;\n                            if(!used[j + h][a | b]) {\n                                g[j + h][a | b] = dp[u][j][a] + dp[v][h][b];\n                                used[j + h][a | b] = 1;\n                            }\n                            else g[j + h][a | b] = min(g[j + h][a | b],dp[u][j][a] + dp[v][h][b]);\n                        }\n                    }\n                }\n            }\n            for(int j = 0 ; j <= siz[u] + siz[v] ; ++j) {\n                for(int a = 0 ; a <= 1 ; ++a) {\n                    vis[u][j][a] = used[j][a];\n                    dp[u][j][a] = g[j][a];\n                }\n            }\n            siz[u] += siz[v];\n        }\n    }\n    if(fa) {\n        for(int j = siz[u] ; j >= 0 ; --j) {\n            if(vis[u][j][1] && dp[u][j][1] < 0) {dp[u][j + 1][0] = 0;vis[u][j + 1][0] = 1;}\n            if(vis[u][j][0]) {dp[u][j + 1][0] = 0;vis[u][j + 1][0] = 1;}\n        }\n    }\n    else {\n        for(int j = 0 ; j <= siz[u] ; ++j) {\n            if(vis[u][j][1] && dp[u][j][1] < 0) {ans = j;break;}\n            if(vis[u][j][0]) {ans = j;break;}\n        }\n    }\n}\nvoid Solve() {\n    read(N);\n    for(int i = 1 ; i <= N ; ++i) read(A[i]);\n    int u,v;\n    for(int i = 1 ; i < N ; ++i) {\n        read(u);read(v);\n        add(u,v);add(v,u);\n    }\n    dfs(1,0);\n    out(ans);enter;\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <cassert>\nusing namespace std;\n#define INF 1LL<<60\n\nint N;\nvector<long long> A;\nvector<vector<int>> G;\nlong long dp[5555][2][5555];\nint sz[5555];\n\nvoid dfs(int s, int p){\n    sz[s] = 1;\n    dp[s][1][0] = A[s];\n    if(A[s] > 0) dp[s][0][0] = A[s];\n\n    for(int t : G[s]){\n        if(t == p) continue;\n        dfs(t, s);\n        if(A[s] > 0){\n            vector<long long> v(sz[s]+sz[t]+2, INF);\n\n            for(int i=0; i<=sz[s]; i++){\n                for(int j=0; j<=sz[t]; j++){\n                    v[i+j] = min(v[i+j], dp[s][0][i] + dp[t][0][j]);\n                    if(dp[t][0][j] != INF || dp[t][1][j] < 0){\n                        v[i+j+1] = min(v[i+j+1], dp[s][0][i]);\n                    }\n                }\n            }\n\n            for(int i=0; i<sz[s]+sz[t]+2; i++){\n                dp[s][0][i] = v[i];\n                dp[s][0][i] = min(dp[s][0][i], INF);\n            }\n        }\n        {\n            vector<long long> v(sz[s]+sz[t]+2, INF);\n\n            for(int i=0; i<=sz[s]; i++){\n                for(int j=0; j<=sz[t]; j++){\n                    v[i+j] = min(v[i+j], dp[s][0][i] + dp[t][1][j]);\n                    v[i+j] = min(v[i+j], dp[s][1][i] + dp[t][0][j]);\n                    v[i+j] = min(v[i+j], dp[s][1][i] + dp[t][1][j]);\n                    if(dp[t][0][j] != INF || dp[t][1][j] < 0){\n                        v[i+j+1] = min(v[i+j+1], dp[s][1][i]);\n                    }\n                }\n            }\n\n            for(int i=0; i<sz[s]+sz[t]+2; i++){\n                dp[s][1][i] = v[i];\n                dp[s][1][i] = min(dp[s][1][i], INF);\n            }\n        }\n        sz[s] += sz[t];\n    }\n}\n\nint main(){\n    cin >> N;\n    A.resize(N);\n    G.resize(N);\n    for(int i=0; i<N; i++) cin >> A[i];\n    for(int i=0; i<N-1; i++){\n        int U, V;\n        cin >> U >> V;\n        U--; V--;\n        G[U].push_back(V);\n        G[V].push_back(U);\n    }\n    for(int i=0; i<=N; i++)\n        for(int j=0; j<2; j++)\n            for(int k=0; k<=N; k++)\n                dp[i][j][k] = INF;\n\n    dfs(0, -1);\n\n    long long ans = INF;\n    for(long long i=0; i<=N; i++){\n        if(dp[0][1][i] < 0){\n            ans = i;\n            break;\n        }\n    }\n    for(long long i=0; i<=N; i++){\n        if(dp[0][0][i] != INF){\n            ans = min(ans, i);\n            break;\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n/*\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n */                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \n                                \n                int pr[1200010];\n                int inv[1200010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<=ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n    \n       \n       \n                               //----------------kokomade tenpure------------\n\n\nvector<int> G[5010],G2[5010];\nint a[5010];\n\nvoid dfsss(int r,int p){\n\tfor(auto v:G[r])if(v!=p){\n\t\tG2[r].pb(v);\n\t\tdfsss(v,r);\n\t}\n}\nvector<int> ve1[5010],ve2[5010];\nint inff=-inf*10000ll;\npair<vector<int>,vector<int>> mer(vector<int> v1,vector<int> v2,vector<int> w1,vector<int> w2){\n\t//cout<<\"her\"<<endl;\n\t\n\tint n=v1.size();\n\n\tint m=v2.size();\n\tint N=w1.size();\n\tint M=w2.size();\n//\tcout<<n<<\" \"<<m<<\" \"<<N<<\" \"<<M<<endl;\n\t\tvector<int> t1(max(n+N-1,0ll),-inff),t2(max({n+M,m+N,m+M})-1,-inff);\n\tfor(int i=0;i<n;i++)for(int j=0;j<N;j++)if(v1[i]!=inff && w1[j]!=inff){\n\t\tt1[i+j]=min(t1[i+j],v1[i]+w1[j]);\n\t}\n\t\n\tfor(int i=0;i<n;i++)for(int j=0;j<M;j++)if(v1[i]!=inff && w2[j]!=inff){\n\t\tt2[i+j]=min(t2[i+j],v1[i]+w2[j]);\n\t}\n\t\n\tfor(int i=0;i<m;i++)for(int j=0;j<N;j++)if(v2[i]!=inff && w1[j]!=inff){\n\t\tt2[i+j]=min(t2[i+j],v2[i]+w1[j]);\n\t}\n\t\n\tfor(int i=0;i<m;i++)for(int j=0;j<M;j++)if(v2[i]!=inff && w2[j]!=inff){\n\t\tt2[i+j]=min(t2[i+j],v2[i]+w2[j]);\n\t}\n//\tcout<<\"r\"<<endl;\n\tfor(auto &v:t1)if(v==-inff)v*=-1;\n\t\n\tfor(auto &v:t2)if(v==-inff)v*=-1;\n\treturn {t1,t2};\n}\n\nvoid dfs(int r){\n//\tcout<<r<<endl;\n\tfor(auto v:G2[r])dfs(v);\n\tif(G2[r].size()==0){\n\t\tif(a[r]>0){\n\t\t\tve1[r].pb(a[r]);\n\t\t}\n\t\telse ve2[r].pb(a[r]);\n\t}\n\telse{\n\t\n\t\tve1[r]=ve1[G2[r][0]];\n\t\tve2[r]=ve2[G2[r][0]];\n\t//\tcout<<\"dd \"<<ve1[r].size()<<\" \"<<ve2[r].size()<<endl;\n\t\tint e=G2[r].size();\n\t\tfor(int i=1;i<e;i++){\n\t//\t\tcout<<r<<\" dd\"<<endl;\n\t\t\ttie(ve1[r],ve2[r])=mer(ve1[r],ve2[r],ve1[G2[r][i]],ve2[G2[r][i]]);\n\t\t}\n\t\t\t\n\t\twhile(ve1[r].size()>ve2[r].size())ve2[r].pb(inff);\n\t\twhile(ve1[r].size()<ve2[r].size())ve1[r].pb(inff);\n\t\tif(a[r]>0){\n\t\t\tfor(auto &v:ve1[r])if(v!=inff)v+=a[r];\n\t\t\tfor(auto &v:ve2[r])if(v!=inff)v+=a[r];\n\t\t}\n\t\telse{\n\t\t\tfor(auto &v:ve2[r])if(v!=inff)v+=a[r];\n\t\t\tfor(int i=0;i<ve1[r].size();i++)if(ve1[r][i]!=inff){\n\t\t\t\tif(ve2[r][i]==inff) ve2[r][i]=ve1[r][i]+a[r];\n\t\t\t\telse ve2[r][i]=min(ve2[r][i],ve1[r][i]+a[r]);\n\t\t\t}\n\t\t\tve1[r].clear();\n\t\t}\n\t}\n\t\n\tif(r!=1){\n\t\t\n\t\t\n\t\tfor(int i=0;i<ve2[r].size();i++)if(ve2[r][i]<0 && ve2[r][i]!=inff){\n\t\t\twhile(ve1[r].size()<i+2)ve1[r].pb(inff);\n\t\t\tve1[r][i+1]=0ll;\n\t\t\t//else ve1[r][i+1]=max(0ll,ve1[r][i+1]);\n\t\t}\n\t\tif(ve1[r].size()==0||ve1[r].back()!=inff) ve1[r].pb(inff);\n\t\t\n\t\tfor(int i=ve1[r].size()-2;i>=0;i--)if(ve1[r][i]>0){\n\t\t//\tcout<<i<<endl;\n\t\t\tve1[r][i+1]=0ll;\n\t\t}\n\t\t\n\t\twhile(ve1[r].size()){\n\t\t\tif(ve1[r].back()==inff) ve1[r].pop_back();\n\t\t\telse break;\n\t\t}\n\t\t\n\t\twhile(ve2[r].size()){\n\t\t\tif(ve2[r].back()==inff) ve2[r].pop_back();\n\t\t\telse break;\n\t\t}\n\t}\n\t/*\n\tcout<<\" ===  \"<<r<<endl;\n\tfor(auto v:ve1[r])cout<<v<<\" \";\n\tcout<<endl;\n\t\tfor(auto v:ve2[r])cout<<v<<\" \";\n\tcout<<endl;\ncout<<\" ===  \"<<endl;\n\t*/\n}\n\n signed main(){\n \t\n\n    \t       cin.tie(0);\n   \t\t\tios::sync_with_stdio(false);\nint n;\n \tcin>>n;\n \tfor(int i=1;i<=n;i++)cin>>a[i];\n \tfor(int i=0;i<n-1;i++){\n \t\tint y,yy;\n \t\tcin>>y>>yy;\n \t\tG[y].pb(yy);\n \t\tG[yy].pb(y);\n \t}\n \tdfsss(1,1);\n //\tcout<<\"d\"<<endl;\n \tdfs(1);\n \tint ans=inf;\n \tfor(int i=0;i<ve2[1].size();i++)if(ve2[1][i]<0)ans=min(ans,i);\n \t\n \tfor(int i=0;i<ve1[1].size();i++)if(ve1[1][i]>=0)ans=min(ans,i);\n \t\n \tcout<<ans<<endl;\n \treturn 0;\n  }\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <fstream>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <complex>\n#include <iomanip>\n#include <stdio.h>\n#include <string.h>\n#include <random>\n#include <functional>\n\nusing std::cin;\nusing std::cout;\nusing std::cerr;\nusing std::endl;\n\nusing std::map;\nusing std::set;\nusing std::bitset;\nusing std::vector;\nusing std::string;\nusing std::multimap;\nusing std::multiset;\nusing std::deque;\nusing std::queue;\nusing std::stack;\nusing std::pair;\nusing std::iterator;\n\nusing std::sort;\nusing std::stable_sort;\nusing std::reverse;\nusing std::max_element;\nusing std::min_element;\nusing std::unique;\nusing std::ios_base;\nusing std::swap;\nusing std::fill;\n\nusing std::setprecision;\nusing std::fixed;\n\nlong long min(long long a, long long b) {return a < b ? a : b;}\nlong long min(int a, long long b) {return a < b ? a : b;}\nlong long min(long long a, int b) {return a < b ? a : b;}\nlong long min(int a, int b) {return a < b ? a : b;}\n\nlong long max(long long a, long long b) {return a > b ? a : b;}\nlong long max(int a, long long b) {return a > b ? a : b;}\nlong long max(long long a, int b) {return a > b ? a : b;}\nlong long max(int a, int b) {return a > b ? a : b;}\n\n#define int long long\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<long long> vl;\ntypedef string S;\n\n#define F(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define fi first\n#define se second\n#define re return\n#define all(x) (x).begin(), (x).end()\n\nconst long long INF = 1e18;\nconst int N = 10100;\nconst int MOD = 1e9 + 7;\nconst double eps = 1e-8;\n\nint n;\nint a[N];\nvector<int> graph[N];\nint dp[2][N][N / 2];\nint last_dinamics[N];\nint last_state[N];\nint tmp = 0;\n\nvoid Merge(int p1, int p2)\n{\n    for (int a = 0; a <= last_state[p1]; a++)\n    {\n        for (int b = 0; b <= last_state[p2]; b++)\n        {\n            dp[0][tmp][a + b] = min(dp[0][tmp][a + b], dp[0][p1][a] + dp[0][p2][b]);\n            if (dp[0][p2][b] < INF) dp[0][tmp][a + b + 1] = min(dp[0][tmp][a + b + 1], dp[0][p1][a]);\n            if (dp[1][p2][b] < 0) dp[0][tmp][a + b + 1] = min(dp[0][tmp][a + b + 1], dp[0][p1][a]);\n            dp[1][tmp][a + b] = min(dp[1][tmp][a + b], min(dp[0][p1][a], dp[1][p1][a]) + min(dp[0][p2][b], dp[1][p2][b]));\n            if (dp[0][p2][b] < INF) dp[1][tmp][a + b + 1] = min(dp[1][tmp][a + b + 1], min(dp[0][p1][a], dp[1][p1][a]));\n            if (dp[1][p2][b] < 0) dp[1][tmp][a + b + 1] = min(dp[1][tmp][a + b + 1], min(dp[0][p1][a], dp[1][p1][a]));\n        }\n    }\n    last_state[tmp] = last_state[p1] + last_state[p2] + 1;\n}\n\nvoid dfs(int v, int parent)\n{\n    int merge1 = tmp;\n    dp[0][tmp][0] = 0, dp[1][tmp][0] = 0;\n    tmp++;\n    for (auto u : graph[v]) if (u != parent)\n    {\n        dfs(u, v);\n        int merge2 = last_dinamics[u];\n        Merge(merge1, merge2);\n        merge1 = tmp;\n        tmp++;\n    }\n    tmp--;\n    for (int i = 0; i < n + 100; i++)\n    {\n        dp[1][tmp][i] = min(dp[1][tmp][i] + a[v], INF);\n        dp[0][tmp][i] = min(dp[0][tmp][i] + a[v], INF);\n    }\n    if (a[v] < 0)\n    {\n        for (int i = 0; i < n + 100; i++) dp[0][tmp][i] = INF;\n    }\n    last_dinamics[v] = tmp;\n    tmp++;\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n;\n    for (int i = 0; i < 2 * n + 100; i++)\n    {\n        for (int j = 0; j < n + 100; j++)\n        {\n            dp[0][i][j] = INF, dp[1][i][j] = INF;\n        }\n    }\n    for (int i = 0; i < n; i++)\n    {\n        cin >> a[i];\n    }\n    for (int i = 0; i + 1 < n; i++)\n    {\n        int v, u;\n        cin >> v >> u;\n        v--, u--;\n        graph[v].push_back(u);\n        graph[u].push_back(v);\n    }\n    dfs(0, -1);\n    long long ans = n - 1;\n    for (int i = 0; i < n - 1; i++)\n    {\n        //cout << dp[1][tmp - 1][i] << \" \" << dp[0][tmp - 1][i] << \"\\n\";\n        if (dp[1][tmp - 1][i] < 0) ans = min(ans, i);\n        if (dp[0][tmp - 1][i] < INF) ans = min(ans, i);\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const ll inf = 1e18;const double INF = 1e12, EPS = 1e-9;\n\nusing VL = vector<ll>;\nusing VVL = vector<VL>;\nint n, a[5000];\nvector<vi> e;\n\nconst VVL rec(int c, int p){\n\tVVL dp(1, VL(2, inf));\n\tdp[0][a[c] < 0] = a[c];\n\t\n\tfor(int cld : e[c]) if(cld != p){\n\t\tconst VVL tmp = rec(cld, c);\n\t\tVVL next(dp.size() + tmp.size(), VL(2, inf));\n\t\t\n\t\trep(i, tmp.size()) rep(j, 2) if(tmp[i][j] < inf)\n\t\trep(k, dp.size()) rep(l, 2) if(dp[k][l] < inf){\n\t\t\t\n\t\t\tnext[i + k][j | l] = min(next[i + k][j | l], tmp[i][j] + dp[k][l]);\n\t\t\tif(j == 0 || tmp[i][j] < 0) next[i + k + 1][l] = min(next[i + k + 1][l], dp[k][l]);\n\t\t}\n\t\t\n\t\tdp.swap(next);\n\t}\n\treturn dp;\n}\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tcin >> n; e.resize(n);\n\trep(i, n) cin >> a[i];\n\trep(i, n - 1){\n\t\tint u, v; cin >> u >> v; u--; v--;\n\t\te[u].pb(v);\n\t\te[v].pb(u);\n\t}\n\tVVL ans = rec(0, 0);\n\tint res = n - 1;\n\trep(i, ans.size()) rep(j, ans[i].size()) if(ans[i][j] < inf) if(j == 0 || ans[i][j] < 0) res = min(res, i);\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n\nint n;\nll a[5005],dp[5005][5005],dppos[5005];\nint sub[5005];\nvector<int>edge[5005];\nll t[2][5005];\nvoid dfs(int v,int u){\n\tsub[v] = 1;\n\trep(i,edge[v].size()){\n\t\tint to = edge[v][i];\n\t\tif(to == u) continue;\n\t\tdfs(to,v);\n\t}\n\tint cur = 0, nxt = 1;\n\t//dp[][]\n\trep(i,2)rep(j,5005) t[i][j] = 1e18;\n\tt[0][0] = 0;\n\trep(i,edge[v].size()){\n\t\tint to = edge[v][i];\n\t\tif(to == u) continue;\n\t\trep(i,sub[v]+sub[to]) t[nxt][i] = 1e18;\n\t\trep(i,sub[v]){\n\t\t\tif(t[cur][i] > 5e17) continue;\n\t\t\trepn(j,sub[to]){\n\t\t\t\t//cut\n\t\t\t\tif(dp[to][j] < 0){\n\t\t\t\t\tt[nxt][i+j] = min(t[nxt][i+j], t[cur][i]);\n\t\t\t\t}\n\t\t\t\t//cut2\n\t\t\t\tif(dppos[to] <= n){\n\t\t\t\t\tt[nxt][i+dppos[to]] = min(t[nxt][i+dppos[to]], t[cur][i]);\n\t\t\t\t}\n\t\t\t\t//connect\n\t\t\t\tt[nxt][i+j-1] = min(t[nxt][i+j-1], dp[to][j]+t[cur][i]);\n\t\t\t}\n\t\t}\n\t\tsub[v] += sub[to];\n\t\tswap(cur,nxt);\n\t}\n\trep(i,sub[v]) dp[v][i+1] = t[cur][i]+a[v];\n\tif(a[v] > 0){\n\t\tdppos[v] = 1;\n\t\t//dppos[]\n\t\trep(i,edge[v].size()){\n\t\t\tint to = edge[v][i];\n\t\t\tif(to == u) continue;\n\t\t\tll add = INF;\n\t\t\t{\n\t\t\t\trepn(j,sub[to]){\n\t\t\t\t\t//cut\n\t\t\t\t\tif(dp[to][j] < 0){\n\t\t\t\t\t\tadd = min(add,1LL*j);\n\t\t\t\t\t}\n\t\t\t\t\t//cut2\n\t\t\t\t\tif(dppos[to] <= n){\n\t\t\t\t\t\tadd = min(add,dppos[to]);\n\t\t\t\t\t}\n\t\t\t\t\t//connect\n\t\t\t\t\tif(dppos[to] <= n){\n\t\t\t\t\t\tadd = min(add,dppos[to]-1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdppos[v] += add;\n\t\t}\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\trepn(i,n) scanf(\"%lld\",&a[i]);\n\trep(i,n-1){\n\t\tint a,b; scanf(\"%d%d\",&a,&b);\n\t\tedge[a].pb(b);\n\t\tedge[b].pb(a);\n\t}\n\trep(i,5005)rep(j,5005){\n\t\tdp[i][j] = 1e18;\n\t\tdppos[i] = 1e18;\n\t}\n\tdfs(1,-1);\n\tll ans = dppos[1];\n\tfor(int j=0;j<5005;j++){\n\t\tif(dp[1][j] < 0){\n\t\t\tans = min(ans,1LL*j);\n\t\t\tbreak;\n\t\t}\n\t}\n\tcout << --ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3f\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\n\nint n;\nll a[6000];\nvector<int>E[6000];\nint siz[6000];\nll dp[2][6000][6000];\nbool dp2[2][6000][6000];\n\nvoid dfs(int v,int p){\n\tfor(int u:E[v]){\n\t\tif(u==p)continue;\n\t\tdfs(u,v);\n\t}\n\tint D=0;\n\trep(i,n)dp[0][v][i]=INFL;\n\tdp[0][v][0]=a[v];\n\tif(a[v]>0)dp2[0][v][0]=true;\n\tsiz[v]=1;\n\tfor(int u:E[v]){\n\t\tif(u==p)continue;\n\t\tint a=(E[u].size()-1)%2;\n\t\tfor(int i=siz[v]+siz[u];i>=0;i--){\n\t\t\tdp[!D][v][i]=INFL;\n\t\t\tdp2[!D][v][i]=false;\n\t\t}\n\t\trep(i,siz[v]+1){\n\t\t\trep(j,siz[u]+1){\n\t\t\t\t//切断する場合\n\t\t\t\tif(dp2[a][u][j]||dp[a][u][j]<0){\n\t\t\t\t\tdp[!D][v][i+j+1]=min(dp[!D][v][i+j+1],dp[D][v][i]);\n\t\t\t\t\tdp2[!D][v][i+j+1]|=dp2[D][v][i];\n\t\t\t\t}\n\t\t\t\t//切断しない場合\n\t\t\t\tdp[!D][v][i+j]=min(dp[!D][v][i+j],dp[D][v][i]+dp[a][u][j]);\n\t\t\t\tdp2[!D][v][i+j]|=(dp2[D][v][i]&dp2[a][u][j]);\n\t\t\t}\n\t\t}\n\t\tsiz[v]+=siz[u];\n\t\tD=!D;\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\trep(i,n)scanf(\"%lld\",&a[i]);\n\trep(i,n-1){\n\t\tint a,b;scanf(\"%d%d\",&a,&b);a--;b--;\n\t\tE[a].push_back(b);\n\t\tE[b].push_back(a);\n\t}\n\tdfs(0,-1);\n\trep(i,n){\n\t\tif(dp[E[0].size()%2][0][i]<0||dp2[E[0].size()%2][0][i]==true){\n\t\t\tcout<<i<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> v2l;\ntypedef vector<bool> vb;\ntypedef vector<vb> v2b;\n\nconst ll AMAX = 1e13;\n\nint dfs(vi e[], int a[], int x, int p, v2l &dp1, v2b &dp2) {\n    int sz = 1;\n    dp1[x] = {a[x]};\n    dp2[x] = {a[x] > 0};\n\n    for (int y : e[x]) {\n        if (y == p) {\n            continue;\n        }\n\n        int ysz = dfs(e, a, y, x, dp1, dp2);\n        dp1[x].resize(sz + ysz, AMAX);\n        dp2[x].resize(sz + ysz, false);\n\n        for (int i = sz - 1; i >= 0; i--) {\n            for (int j = ysz - 1; j >= 0; j--) {\n                if (j > 0) {\n                    dp1[x][i+j] = min(dp1[x][i+j], dp1[x][i] + dp1[y][j]);\n                    dp2[x][i+j] = dp2[x][i+j] || dp2[x][i] && dp2[y][j];\n                }\n                if (dp1[y][j] < 0 || dp2[y][j]) {\n                    dp1[x][i+j+1] = min(dp1[x][i+j+1], dp1[x][i]);\n                    dp2[x][i+j+1] = dp2[x][i+j+1] || dp2[x][i];\n                }\n            }\n            dp1[x][i] = min(AMAX, dp1[x][i] + dp1[y][0]);\n            dp2[x][i] = dp2[x][i] && dp2[y][0];\n        }\n\n        sz += ysz;\n    }\n\n    return sz;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    int a[n];\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n    vi e[n];\n    for (int i = 0; i < n - 1; i++) {\n        int u, v;\n        cin >> u >> v;\n        u--, v--;\n        e[u].push_back(v);\n        e[v].push_back(u);\n    }\n\n    v2l dp1(n);\n    v2b dp2(n);\n    dfs(e, a, 0, -1, dp1, dp2);\n\n    for (int i = 0; i < n; i++) {\n        if (dp1[0][i] < 0 || dp2[0][i]) {\n            cout << i << endl;\n            return 0;\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll MOD = 1e9+7;\n\nstruct UnionFind\n{\n    UnionFind(ll n, vector<ll> a);\n    bool Unite(ll x, ll y);\n    ll Find(ll x);\n    bool Same(ll x, ll y);\n    ll Size(ll x);\n    ll Sum(ll x);\n\n    ll n, unite_count;\n    std::vector<ll> par, a;\n};\nUnionFind::UnionFind(ll n, vector<ll> a) :\n    n(n),\n    unite_count(0),\n    par(n, -1),\n    a(a)\n{\n}\n\nbool UnionFind::Unite(ll x, ll y){\n    x = Find(x);\n    y = Find(y);\n    if(x == y)\n        return false;\n\n    if(x > y)\n        std::swap(x, y);\n\n    a[x] += a[y];\n    par[x] += par[y];\n    par[y] = x;\n\n    ++unite_count;\n    return true;\n}\n\nll UnionFind::Find(ll x){\n    return par[x] < 0 ? x : Find(par[x]);\n}\n\nbool UnionFind::Same(ll x, ll y){\n    return Find(x) == Find(y);\n}\n\nll UnionFind::Size(ll x){\n    return par[x] < 0 ? -par[x] : Size(par[x]);\n}\n\nll UnionFind::Sum(ll x){\n    return par[x] < 0 ? a[x] : Sum(par[x]);\n}\n\nsigned main()\n{\n    ll n;\n    cin >> n;\n    vector<ll> a(n);\n    for(auto& x : a)\n        cin >> x;\n    vector<ll> u(n - 1);\n    vector<ll> v(n - 1);\n    for(ll i = 0; i < n - 1; ++i){\n        cin >> u[i] >> v[i];\n        --u[i];\n        --v[i];\n    }\n    UnionFind uf(n, a);\n\n    vector<vector<ll>> edges(n);\n    for(ll i = 0; i < n - 1; ++i){\n        edges[u[i]].push_back(v[i]);\n        edges[v[i]].push_back(u[i]);\n        if(uf.Sum(u[i]) < 0 && uf.Sum(v[i]) < 0)\n            uf.Unite(u[i], v[i]);\n    }\n    for(ll i = 0; i < n; ++i){\n        bool flag = true;\n        if(a[i] < 0)\n            flag = false;\n        for(auto& x : edges[i])\n            if(a[x] < 0)\n                flag = false;\n        if(flag)\n            for(auto& x : edges[i])\n                uf.Unite(i, x);\n    }\n\n    vector<pair<ll,ll>> sei;\n    for(ll i = 0; i < n; ++i){\n        if(uf.Find(i) == i && uf.Sum(i) > 0)\n            sei.emplace_back(uf.Sum(i), i);\n    }\n    sort(sei.begin(), sei.end());\n\n    for(auto& p : sei){\n        ll x = p.second;\n        for(ll i = 0; i < n; ++i){\n            if(uf.Find(i) == x){\n                for(auto& y : edges[i]){\n                    if(uf.Find(y) == x)\n                        continue;\n                    if(uf.Sum(y) + uf.Sum(x) < 0)\n                        uf.Unite(x, y);\n                }\n            }\n        }\n    }\n\n    cout << n - 1 - uf.unite_count << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "//注意点\n//Tは3つの値を持つ構造\n//だがワイルドカードとしても使っている\n#include <bits/stdc++.h>\nusing namespace std;\n//@起動時\nstruct initon {\n    initon() {\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.setf(ios::fixed);\n        cout.precision(16);\n    };\n} __initon;\n\n//@必須構造\nstruct T {\n    int f, s, t;\n    T() { f = -1, s = -1, t = -1; }\n    T(int f, int s, int t) : f(f), s(s), t(t) {}\n    bool operator<(const T &r) const {\n        return f != r.f ? f < r.f : s != r.s ? s < r.s : t < r.t;\n        //return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 大きい順\n    }\n    bool operator>(const T &r) const {\n        return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t;\n        //return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 小さい順\n    }\n    int operator[](int i) {\n        assert(i < 3);\n        return i == 0 ? f : i == 1 ? s : t;\n    }\n};\n\n//@マクロ省略系 型,構造\n\n#define int long long\n#define ll long long\n#define double long double\n#define ull unsigned long long\nusing dou = double;\nusing itn = int;\nusing str = string;\nusing bo= bool;\nusing P = pair<int, int>;\n#define F first\n#define S second\n#define vec vector\n#define con continue\n#define bre break\n#define brk break\n#define is ==\n#define rs resize\n\n//マクロ省略系 コンテナ\nusing vi = vector<int>;\n#define vvi(a, b, c) vec<vi> a(b,vi(c))\nusing vb = vector<bool>;\n#define vvb(a, b, c) vec<vb> a(b,vb(c))\nusing vs = vector<string>;\n#define vvs(a, b, c) vec<vs> a(b,vs(c))\nusing vl = vector<ll>;\n#define vvl(a, b, c) vec<vl> a(b,vl(c))\nusing vd = vector<double>;\n#define vvd(a, b, c) vec<vd> a(b,vd(c))\nusing vc=vector<char>;\n#define vvc(a, b, c) vec<vc> a(b,vc(c))\nusing vp = vector<P>;\n#define vvp(a, b, c) vec<vp> a(b,vp(c))\nusing vt = vector<T>;\n#define vvt(a, b, c) vec<vt> a(b,vt(c))\n#define v3i(a, b, c, d) vector<vector<vi>> a(b, vector<vi>(c, vi(d)))\n#define v3d(a, b, c, d) vector<vector<vd>> a(b, vector<vd>(c, vd(d)))\n#define v3m(a, b, c, d) vector<vector<vm>> a(b, vector<vm>(c, vm(d)))\n#define PQ priority_queue<ll, vector<ll>, greater<ll> >\nusing seti = set<int>;\n#define uset unordered_set\n#define mset multiset\n#define umap unordered_map\n#define mmap multimap\n\n//マクロ 繰り返し\n#define _overloadrep(_1, _2, _3, name, ...) name\n# define _rep(i, n) for(int i = 0; i < n ; i++)\n#define repi(i, m, n) for(int i = m; i < n ; i++)\n#define rep(...) _overloadrep(__VA_ARGS__,repi,_rep,)(__VA_ARGS__)\n#define _rer(i, n) for(int i = n; i >= 0 ; i--)\n#define reri(i, m, n) for(int i = m; i >= n ; i--)\n#define rer(...) _overloadrep(__VA_ARGS__,reri,_rer,)(__VA_ARGS__)\n#define fora(a, b) for(auto&& a : b)\n#define forg(gi, ve) if (ve.size())for (int gi = 0, f = ve[gi].from, t = ve[gi].to, c = ve[gi].cost; gi < ve.size(); gi++,f = ve[gi].from, t = ve[gi].to, c = ve[gi].cost)\n\n//マクロ 定数\n#define k4 10101\n#define k5 101010\n#define k6 1010101\n#define k7 10101010\nconst int inf = (int) 1e9 + 100;\nconst ll linf = (ll) 1e18 + 100;\nconst double eps = 1e-9;\nconst int y4[] = {-1, 1, 0, 0};\nconst int x4[] = {0, 0, -1, 1};\nconst int y8[] = {0, 1, 0, -1, -1, 1, 1, -1};\nconst int x8[] = {1, 0, -1, 0, 1, -1, 1, -1};\n\n//マクロ省略形 関数等\n#define arsz(a) (sizeof(a)/sizeof(a[0]))\n#define sz(a) (a.size())\n#define mp make_pair\n#define pb push_back\n#define pf push_front\n#define eb emplace_back\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\n//@拡張系 こう出来るべきというもの\n\n//埋め込み 存在を意識せずに機能を増やされているもの\n// 境界チェック付きvector\nnamespace std_vector_bounds_checking {\n    using namespace std;\n    template<class T, class A = std::allocator<T>> struct vector : std::vector<T, A> {\n        using std::vector<T, A>::vector;\n        typename std::vector<T>::reference operator[](typename std::vector<T>::size_type n) {\n            return this->at(n);\n        }\n    };\n}\nnamespace std {\n    template<> class hash<std::pair<signed, signed>> {\n    public:\n        size_t operator()(const std::pair<signed, signed> &x) const {\n            return hash<ll>()(((ll) x.first << 32) + x.second);\n        }\n    };\n    template<> class hash<std::pair<ll, ll>> {\n    public:\n        size_t operator()(const std::pair<ll, ll> &x) const {\n            return hash<ll>()(((ll) x.first << 32) + x.second);\n        }\n    };\n}\ntemplate<typename T> istream &operator>>(istream &iss, vector<T> &vec) {\n    for (T &x: vec) iss >> x;\n    return iss;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, vector <T> &vec) {\n    for (int i = 0; i < vec.size(); i++)os << vec[i] << (i + 1 == vec.size() ? \"\" : \" \");\n    return os;\n}\ntemplate<typename V, typename H> void resize(vector<V> &vec, const H head) {  //再帰の終端。 可変長templateの長さが 0 になるとこっちが呼ばれる。\n    vec.resize(head);\n}\ntemplate<typename V, typename H, typename ... T> void resize(vector<V> &vec, const H &head, const T ... tail) {\n    vec.resize(head);\n    for (auto &v: vec) resize(v, tail...);\n}\ntemplate<class T> T pop(set<T> &set) {\n    T res = *set.begin();\n    set.erase(set.find(res));\n    return res;\n}\ntemplate<class T> T pop(mset<T> &set) {\n    T res = *set.begin();\n    set.erase(set.find(res));\n    return res;\n}\ntemplate<class T> T popBack(set<T> &set) {\n    T res = *set.rbegin();\n    set.erase(set.find(res));\n    return res;\n}\ntemplate<class T> T popBack(mset<T> &set) {\n    T res = *set.rbegin();\n    set.erase(set.find(res));\n    return res;\n}\ntemplate<class T> inline void sort(vector<T> &a) { sort(a.begin(), a.end()); };\ntemplate<class T> inline void rsort(vector<T> &a) { sort(a.begin(), a.end(), greater<T>()); };\ntemplate<class T> inline void sort(vector<T> &a, int len) { sort(a.begin(), a.begin() + len); };\ntemplate<class T> inline void rsort(vector<T> &a, int len) { sort(a.begin(), a.begin() + len, greater<T>()); };\ntemplate<class T> inline void sort2(vector<vector<T>> &a) { for (int i = 0, n = a.size(); i < n; i++)sort(a[i]); }\ntemplate<class T> inline void rsort2(vector<vector<T>> &a) { for (int i = 0, n = a.size(); i < n; i++)rsort(a[i]); }\ntemplate<typename A, size_t N, typename T> void fill(A (&a)[N], const T &v) { rep(i, N)a[i] = v; }\ntemplate<typename A, size_t N, size_t O, typename T> void fill(A (&a)[N][O], const T &v) { rep(i, N)rep(j, O)a[i][j] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, typename T> void fill(A (&a)[N][O][P], const T &v) { rep(i, N)rep(j, O)rep(k, P)a[i][j][k] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, typename T> void fill(A (&a)[N][O][P][Q], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)a[i][j][k][l] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, typename T> void fill(A (&a)[N][O][P][Q][R], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)a[i][j][k][l][m] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S, typename T> void fill(A (&a)[N][O][P][Q][R][S], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)rep(n, S)a[i][j][k][l][m][n] = v; }\ntemplate<typename V, typename T> void fill(V &x, const T &val) { x = val; }\ntemplate<typename V, typename T> void fill(vector<V> &vect, const T &val) { for (auto &v: vect) fill(v, val); }\n//@汎用便利関数 入力\ntemplate<typename T = int> T in() {\n    T x;\n    cin >> x;\n    return (x);\n}\nstring sin() { return in<string>(); }\ndouble din() { return in<double>(); }\nll lin() { return in<ll>(); }\n#define na(a, n) rep(i,n) cin >> a[i];\n#define nad(a, n) rep(i,n) cin >> a[i], a[i]--;\n#define na3(a, b, c, n) rep(i, n)cin >> a[i] >> b[i] >> c[i];\n#define add2(a, b, n) rep(i, n)a.pb(in()),b.pb(in());\n#define add2d(a, b, n) rep(i, n)a.pb(in()-1),b.pb(in()-1);\n#define add3(a, b, c, n) rep(i, n)a.pb(in()),b.pb(in()),c.pb(in());\n#define add3d(a, b, c, n) rep(i, n)a.pb(in()-1),b.pb(in()-1),c.pb(in());\n#define na2(a, b, n) rep(i, n)cin >> a[i] >> b[i];\n#define nt(a, h, w) rep(hi,h)rep(wi,w) cin >> a[hi][wi];\n#define ntd(a, h, w) rep(hi,h)rep(wi,w) cin >> a[hi][wi], a[hi][wi]--;\n#define ntp(a, h, w) fill(a,'#');rep(hi,1,h+1)rep(wi,1,w+1) cin >> a[hi][wi];\n#define addn(a, n) a.resize(n);na(a,n);\n#define addnd(a, n) a.resize(n);na(a,n);rep(i,n)a[i]--;\n\n\ntemplate<class T> inline void fin(T s) { cout << s << endl, exit(0); }\n\ntemplate<class T> struct edge {\n    int from, to;\n    T cost;\n    int id;\n    int type;\n    edge(int f, int t, T c = 1, int id = -1, int ty = -1) : from(f), to(t), cost(c), id(id), type(ty) {}\n    bool operator<(const edge &b) const { return cost < b.cost; }\n    bool operator>(const edge &b) const { return cost > b.cost; }\n};\n\ntemplate<typename T> class graph {\nprotected:\n    vector<bool> _used;\npublic :\n    vector<vector<edge<T>>> g;\n    vector<edge<T>> edges;\n    int n, root = -1;\n    graph(int n) : n(n) { g.resize(n), _used.resize(n); }\n    void clear() { g.clear(), edges.clear(); }\n    void resize(int n) {\n        this->n = n;\n        g.resize(n);\n        _used.resize(n);\n    }\n    int size() { return g.size(); }\n    bool isleaf(int v) {\n        assert(root != -1);\n        return g[v].size() == 1 && g[v][0].from != root;\n    }\n    vector<edge<T> > &operator[](int i) { return g[i]; }\n    virtual void add(int from, int to, T cost, int ty) = 0;\n    virtual bool used(edge<T> &e) = 0;\n    virtual bool used(int id) = 0;\n    virtual void del(edge<T> &e) = 0;\n    virtual void del(int id) = 0;\n};\n\ntemplate<class T=int> class undigraph : public graph<T> {\npublic:\n    using graph<T>::g;\n    using graph<T>::n;\n    using graph<T>::edges;\n    using graph<T>::_used;\n    undigraph(int n) : graph<T>(n) {\n    }\n    void add(int f, int t, T cost = 1, int ty = -1) {\n        int id = edges.size();\n        g[f].emplace_back(f, t, cost, id, ty);\n        g[t].emplace_back(t, f, cost, id + 1, ty);\n        edges.emplace_back(f, t, cost, id, ty);\n        edges.emplace_back(t, f, cost, id + 1, ty);\n    }\n    void add(edge<T> &e) {\n        int f = e.from, t = e.to, ty = e.type;\n        T cost = e.cost;\n        add(f, t, cost, ty);\n    }\n    bool used(edge<T> &e) { return _used[e.id]; }\n    bool used(int id) { return _used[id]; }\n    void del(edge<T> &e) { _used[e.id] = _used[e.id ^ 1] = 1; }\n    void del(int id) { _used[id] = _used[id ^ 1] = 1; }\n};\n\ntemplate<typename T =ll> class digraph : public graph<T> {\npublic:\n    using graph<T>::g;\n    using graph<T>::n;\n    using graph<T>::edges;\n    using graph<T>::_used;\n\n    digraph(int n) : graph<T>(n) {}\n    void add(int f, int t, T cost = 1, int ty = -1) {\n\n        int id = edges.size();\n        g[f].emplace_back(f, t, cost, ty, id);\n        edges.emplace_back(f, t, cost, ty, id);\n    }\n    bool used(edge<T> &e) { return _used[e.id]; }\n    bool used(int id) { return _used[id]; }\n    void del(edge<T> &e) { _used[e.id] = _used[e.id ^ 1] = 1; }\n    void del(int id) { _used[id] = _used[id ^ 1] = 1; }\n};\n\n\ntemplate<class T, class U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n\nint n, k, m, h, w, x, y, q;\nint cou;\nvi a, b, c;\nv3i(dp, 5000, 5001, 2);//コンピューターしかないか\nint dp[5000][5001][2],sub[5001][2];\n//vvi(sub, 5050, 2);\nundigraph<> g(0);\nvi es(5050);\n\nvoid ds(int i, int p) {\n    forg(gi, g[i])if (t != p)ds(t, i);\n    int sum = 0;\n    dp[i][0][a[i] < 0] = a[i];\n    forg(gi, g[i]) {\n            if (t == p)continue;\n            rep(ci, sum + 1) {\n                rep(ct, es[t] + 1) {\n                    rep(ki, 2) {\n                        rep(kt, 2) {\n                            //繋ぐ\n                            if (dp[i][ci][ki] < linf && dp[t][ct][kt] < linf)\n                                chmin(sub[ci + ct][ki || kt], dp[i][ci][ki] + dp[t][ct][kt]);\n                            //切る\n                            if (dp[t][ct][kt] < 0 || (!kt && dp[t][ct][kt] != linf))\n                                chmin(sub[ci + ct + 1][ki], dp[i][ci][ki]);\n                        }\n                    }\n                }\n            }\n            sum += es[t] + 1;\n            rep(j, sum + 1)\n                rep(k, 2) {\n                    dp[i][j][k] = sub[j][k];\n                    sub[j][k] = linf;\n\n                }\n        }\n    es[i] = sum;\n}\nsigned main() {\n    cin >> n;\n    addn(a, n);\n    g.resize(n);\n    rep(i, n - 1) {\n        int f, s;\n        cin >> f >> s;\n        --f, --s;\n        g.add(f, s);\n    }\n    fill(dp, linf);\n    fill(sub, linf);\n    ds(0, -1);\n    rep(c, n)rep(k, 2) {\n            if (k) {\n                if (dp[0][c][k] < 0)fin(c);\n            } else if (dp[0][c][k] != linf)fin(c);\n        }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\nconst int MAX_N=5e3;\nconst ll INF=1e18;\nint N;\nll A[MAX_N];\nvector<int> G[MAX_N];\nvector<ll> dp[2][MAX_N];\t\n\nvoid dfs(int v,int p){\n\tif (A[v]>0){\n\t\tdp[0][v]={A[v]};\n\t}else{\n\t\tdp[0][v]={INF};\n\t}\n\tdp[1][v]={A[v]};\n\tfor(auto e:G[v]){\n\t\tif (e!=p){\n\t\t\tdfs(e,v);\n\t\t\tvector<ll> vec[2];\n\t\t\tREP(i,2)vec[i].resize(dp[i][v].size()+dp[i][e].size());\n\t\t\tREP(i,2){\n\t\t\t\tfor(auto &j:vec[i]){\n\t\t\t\t\tj=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP(a,2){\n\t\t\t\tREP(i,(int)dp[a][v].size()){\n\t\t\t\t\tREP(b,2){\n\t\t\t\t\t\tREP(j,(int)dp[b][e].size()){\n\t\t\t\t\t\t\tif (dp[a][v][i]==INF || dp[b][e][j]==INF) continue;\n\t\t\t\t\t\t\tif (b==0 || dp[b][e][j]<0){\n\t\t\t\t\t\t\t\tif (a==0){\n\t\t\t\t\t\t\t\t\tvec[0][i+j+1]=min(vec[0][i+j+1],dp[a][v][i]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tvec[1][i+j+1]=min(vec[1][i+j+1],dp[a][v][i]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (a==0 && b==0){\n\t\t\t\t\t\t\t\tvec[0][i+j]=min(vec[0][i+j],dp[a][v][i]+dp[b][e][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvec[1][i+j]=min(vec[1][i+j],dp[a][v][i]+dp[b][e][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP(i,2){\n\t\t\t\tdp[i][v]=vec[i];\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tcin>>N;\n\tREP(i,N)cin>>A[i];\n\tREP(i,N-1){\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tu--;\n\t\tv--;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tdfs(0,-1);\n\tint ans=N;\n\tREP(i,(int)dp[0][0].size()){\n\t\tif (dp[0][0][i]!=INF){\n\t\t\tans=min(ans,i);\n\t\t}\n\t}\n\tREP(i,(int)dp[1][0].size()){\n\t\tif (dp[1][0][i]<0){\n\t\t\tans=min(ans,i);\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\t/*\n\tREP(i,2){\n\t\tREP(j,(int)dp[i][2].size()){\n\t\t\tcout<<\"dp[\"<<i<<\"][2][\"<<j<<\"]=\"<<dp[i][2][j]<<endl;\n\t\t}\n\t}\n\t*/\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <map>\n#include <numeric>\n#include <cmath>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <complex>\n#include <string.h>\n#include <unordered_set>\n#include <unordered_map>\n#include <bitset>\n#include <iomanip>\n#include <sys/time.h>\n#include <tuple>\n#include <random>\nusing namespace std;\n\n#define endl '\\n'\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\n#define UNIQ(v) (v).erase(unique((v).begin(), (v).end()), (v).end())\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, ll> P;\ntypedef tuple<int, ll, ll> T;\ntypedef complex<double> comp;\ntypedef vector< vector<ld> > matrix;\nstruct pairhash {\npublic:\n    template<typename T, typename U>\n    size_t operator()(const pair<T, U> &x) const {\n\tsize_t seed = hash<T>()(x.first);\n\treturn hash<U>()(x.second) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n    }\n};\nconst ll inf = 1e18 + 9;\nconst ll mod = 1e9 + 7;\nconst double eps = 1e-8;\nconst double pi = acos(-1);\n\nint n;\nll a[5010];\nint u[5010], v[5010];\n\nvector<int> G[5010];\nll dp[5010][5010];\nint all_b[5010];\nint num[5010];\n\nvoid calc(int v, int prev) {\n    num[v] = 1;\n    dp[v][0] = a[v];\n    for (int i = 1; i < 5010; i++) dp[v][i] = inf;\n    for (int u : G[v]) {\n        if (u == prev) continue;\n        calc(u, v);\n        vector<P> temp;\n        for (int i = 0; i < num[v]; i++) {\n            for (int j = 0; j < num[u]; j++) {\n                temp.push_back(make_pair(i+j, dp[v][i]+dp[u][j]));\n                if (dp[u][j] < 0 || (a[u]>0 && all_b[u]<=j))\n                    temp.push_back(make_pair(i+j+1, dp[v][i]));\n            }\n        }\n        for (int i = 0; i <= num[v]+num[u]; i++) dp[v][i] = inf;\n        for (P p : temp) {\n            dp[v][p.first] = min(dp[v][p.first], p.second);\n        }\n        num[v] += num[u];\n    }\n\n    if (a[v] > 0) {\n        all_b[v] = 0;\n        for (int u : G[v]) {\n            if (u == prev) continue;\n            if (a[u] < 0) {\n                for (int i = 0; i < num[u]; i++) {\n                    if (dp[u][i] < 0) {\n                        all_b[v] += i+1;\n                        break;\n                    }\n                }\n            } else {\n                int m = 1e9;\n                for (int i = 0; i < num[u]; i++) {\n                    if (dp[u][i] < 0) {\n                        m = i+1;\n                        break;\n                    }\n                }\n                all_b[v] += min(m+1, all_b[u]);\n            }\n        }\n    }\n}\n\nint solve() {\n    for (int i = 0; i < n-1; i++) {\n        G[u[i]].push_back(v[i]);\n        G[v[i]].push_back(u[i]);\n    }\n    int s = -1;\n    for (int i = 0; i < n; i++) {\n        if (a[i] < 0) {\n            s = i;\n            break;\n        }\n    }\n    if (s < 0) return 0;\n\n    calc(s, -1);\n\n    for (int i = 0; i < n; i++) {\n        if (dp[s][i] < 0)\n            return i;\n    }\n    return -1;\n}\n\nvoid input() {\n    cin >> n;\n    for (int i = 0; i < n; i++) cin >> a[i];\n    for (int i = 0; i < n-1; i++) {\n        cin >> u[i] >> v[i];\n        u[i]--;\n        v[i]--;\n    }\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << fixed << setprecision(15);\n\n    input();\n    cout << solve() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint A[5050];\nvector<int> E[5050];\nll dp[5060][5060][2];\nint C[5050];\nll to[5053][2];\n\nvoid dfs(int cur,int pre) {\n\tC[cur]=1;\n\tif(A[cur]>0) {\n\t\tdp[cur][0][1]=A[cur];\n\t}\n\telse {\n\t\tdp[cur][0][0]=A[cur];\n\t}\n\tFORR(e,E[cur]) if(e!=pre) {\n\t\tdfs(e,cur);\n\t\t\n\t\tint x,y;\n\t\tFOR(x,5050) to[x][0]=to[x][1]=1LL<<60;\n\t\tfor(x=0;x<=C[cur]-1;x++) {\n\t\t\tfor(y=0;y<=C[e]-1;y++) {\n\t\t\t\t\n\t\t\t\tif(dp[e][y][0]<0 || dp[e][y][1]<1LL<<60) {\n\t\t\t\t\tto[x+y+1][0]=min(to[x+y+1][0],dp[cur][x][0]);\n\t\t\t\t\tto[x+y+1][1]=min(to[x+y+1][1],dp[cur][x][1]);\n\t\t\t\t}\n\t\t\t\tto[x+y][1]=min(to[x+y][1],dp[cur][x][1]+dp[e][y][1]);\n\t\t\t\tto[x+y][0]=min(to[x+y][0],dp[cur][x][0]+dp[e][y][1]);\n\t\t\t\tto[x+y][0]=min(to[x+y][0],dp[cur][x][1]+dp[e][y][0]);\n\t\t\t\tto[x+y][0]=min(to[x+y][0],dp[cur][x][0]+dp[e][y][0]);\n\t\t\t}\n\t\t}\n\t\tFOR(x,5050) {\n\t\t\tdp[cur][x][0]=to[x][0];\n\t\t\tdp[cur][x][1]=to[x][1];\n\t\t}\n\t\tC[cur]+=C[e];\n\t}\n\t\n\t\n}\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N) cin>>A[i];\n\tFOR(x,5050) FOR(y,5050) dp[x][y][0]=dp[x][y][1]=1LL<<60;\n\t\n\tFOR(i,N-1) {\n\t\tcin>>x>>y;\n\t\tE[x-1].push_back(y-1);\n\t\tE[y-1].push_back(x-1);\n\t}\n\t\n\tdfs(0,-1);\n\tfor(i=0;i<=5050;i++) {\n\t\tif(dp[0][i][0]<0) return _P(\"%d\\n\",i);\n\t\tif(dp[0][i][1]<1LL<<60) return _P(\"%d\\n\",i);\n\t}\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n)  for(long long i=0;i<(long long)(n);i++)\n#define REP(i,k,n) for(long long i=k;i<(long long)(n);i++)\n#define all(a) a.begin(),a.end()\n#define pb push_back\n#define eb emplace_back\n#define lb(v,k) (lower_bound(all(v),k)-v.begin())\n#define ub(v,k) (upper_bound(all(v),k)-v.begin())\n#define fi first\n#define se second\n#define pi M_PI\n#define PQ(T) priority_queue<T>\n#define SPQ(T) priority_queue<T,vector<T>,greater<T>>\n#define dame(a) {out(a);return 0;}\n#define decimal cout<<fixed<<setprecision(15);\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef tuple<ll,ll,ll> PP;\ntypedef tuple<ll,ll,ll,ll> PPP;\ntypedef multiset<ll> S;\nusing vi=vector<ll>;\nusing vvi=vector<vi>;\nusing vvvi=vector<vvi>;\nusing vp=vector<P>;\nusing vvp=vector<vp>;\nusing vb=vector<bool>;\nusing vvb=vector<vb>;\nconst ll inf=1001001001001001001;\nconst int INF=1001001001;\nconst int mod=998244353;\nconst double eps=1e-10;\ntemplate<class T> bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<class T> bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<class T> void out(T a){cout<<a<<'\\n';}\ntemplate<class T> void outp(T a){cout<<'('<<a.fi<<','<<a.se<<')'<<'\\n';}\ntemplate<class T> void outvp(T v){rep(i,v.size())cout<<'('<<v[i].fi<<','<<v[i].se<<')';cout<<'\\n';}\ntemplate<class T> void outvvp(T v){rep(i,v.size())outvp(v[i]);}\ntemplate<class T> void outv(T v){rep(i,v.size()){if(i)cout<<' ';cout<<v[i];}cout<<'\\n';}\ntemplate<class T> void outvv(T v){rep(i,v.size())outv(v[i]);}\ntemplate<class T> bool isin(T x,T l,T r){return (l)<=(x)&&(x)<=(r);}\ntemplate<class T> void yesno(T b){if(b)out(\"yes\");else out(\"no\");}\ntemplate<class T> void YesNo(T b){if(b)out(\"Yes\");else out(\"No\");}\ntemplate<class T> void YESNO(T b){if(b)out(\"YES\");else out(\"NO\");}\ntemplate<class T> void noyes(T b){if(b)out(\"no\");else out(\"yes\");}\ntemplate<class T> void NoYes(T b){if(b)out(\"No\");else out(\"Yes\");}\ntemplate<class T> void NOYES(T b){if(b)out(\"NO\");else out(\"YES\");}\nvoid outs(ll a,ll b){if(a>=inf-100)out(b);else out(a);}\nll gcd(ll a,ll b){if(b==0)return a;return gcd(b,a%b);}\nll modpow(ll a,ll b){a%=mod;if(b==0)return 1;if(b&1)return a*modpow(a,b-1)%mod;ll k=modpow(a,b/2);return k*k%mod;}\nvi val,sz;\nvvi g,dp,dp1;\nvoid dfs(int v,int p){\n    sz[v]=1;\n    for(ll x:g[v])if(x!=p){\n        dfs(x,v);\n        sz[v]+=sz[x];\n    }\n    vi sdp(1),sdp1(1);\n    sdp[0]=val[v];\n    if(val[v]>0)sdp1[0]=1;\n    for(ll x:g[v])if(x!=p){\n        vi ndp(sdp.size()+sz[x]+1,inf),ndp1(sdp.size()+sz[x]+1);\n        rep(i,sdp.size())rep(j,sz[x]+1){\n            chmin(ndp[i+j],sdp[i]+dp[x][j]);\n            if(dp1[x][j]||dp[x][j]<0)chmin(ndp[i+j+1],sdp[i]);\n            if(sdp1[i]){\n                if(dp[x][j]<0||dp1[x][j])ndp1[i+j+1]=1;\n                if(dp1[x][j])ndp1[i+j]=1;\n            }\n        }\n        sdp=ndp;\n        sdp1=ndp1;\n    }\n    dp[v]=sdp;\n    dp1[v]=sdp1;\n}\nint main(){\n    ll n;cin>>n;\n    val=vi(n);\n    sz=vi(n);\n    dp1=vvi(n);\n    dp=vvi(n);\n    rep(i,n)cin>>val[i];\n    g=vvi(n);\n    rep(i,n-1){\n        ll a,b;cin>>a>>b;a--;b--;\n        g[a].pb(b);\n        g[b].pb(a);\n    }\n    dfs(0,-1);\n    ll ans=0;\n    while(dp[0][ans]>0&&!dp1[0][ans])ans++;\n    out(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <functional>\n\ntemplate <class T>\nstd::vector<T> vec(int len, T elem) { return std::vector<T>(len, elem); }\n\ntemplate <class Cost = int>\nstruct Edge {\n    int src, dst;\n    Cost cost;\n    Edge(int src = -1, int dst = -1, Cost cost = 1)\n        : src(src), dst(dst), cost(cost){};\n\n    bool operator<(const Edge<Cost>& e) const { return this->cost < e.cost; }\n    bool operator>(const Edge<Cost>& e) const { return this->cost > e.cost; }\n};\n\ntemplate <class Cost = int>\nusing Graph = std::vector<std::vector<Edge<Cost>>>;\n\nusing lint = long long;\nconstexpr lint INF = 1LL << 45;\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n\n    std::vector<lint> xs(n);\n    for (auto& x : xs) std::cin >> x;\n\n    Graph<> graph(n);\n    for (int i = 0; i < n - 1; ++i) {\n        int u, v;\n        std::cin >> u >> v;\n        --u, --v;\n        graph[u].emplace_back(u, v);\n        graph[v].emplace_back(v, u);\n    }\n\n    auto dp = vec(2, vec(n, vec(n, 0LL)));\n    auto ndp = std::vector<lint>(n);\n    auto esz = vec(n, 0);\n\n    std::function<void(int, int)> dfs =\n        [&](int v, int p) {\n            std::fill(dp[0][v].begin(), dp[0][v].end(), INF);\n            dp[0][v][0] = xs[v];\n\n            if (xs[v] > 0) dp[1][v][0] = 1;\n\n            for (auto e : graph[v]) {\n                int u = e.dst;\n                if (u == p) continue;\n\n                dfs(u, v);\n\n                std::fill(ndp.begin(), ndp.end(), INF);\n                for (int i = 0; i <= esz[v]; ++i) {\n                    for (int j = 0; j <= esz[u]; ++j) {\n                        // negative merge\n                        ndp[i + j] = std::min(ndp[i + j], dp[0][v][i] + dp[0][u][j]);\n\n                        if (dp[1][u][j]) {\n                            // cut\n                            ndp[i + j + 1] = std::min(ndp[i + j + 1], dp[0][v][i]);\n                        }\n                    }\n                }\n                std::swap(dp[0][v], ndp);\n\n                std::fill(ndp.begin(), ndp.end(), 0);\n                for (int i = 0; i <= esz[v]; ++i) {\n                    if (!dp[1][v][i]) continue;\n\n                    for (int j = 0; j <= esz[u]; ++j) {\n                        if (dp[0][u][j] < 0) {\n                            // cut\n                            while ((int)ndp.size() < i + j + 1) ndp.push_back(0);\n                            ndp[i + j + 1] = 1;\n                        }\n\n                        if (dp[1][u][j]) {\n                            // positive merge\n                            while ((int)ndp.size() < i + j) ndp.push_back(0);\n                            ndp[i + j] = 1;\n                        }\n                    }\n                }\n                std::swap(dp[1][v], ndp);\n\n                esz[v] += esz[u] + 1;\n            }\n        };\n\n    dfs(0, -1);\n    int ans = n;\n    for (int i = 0; i < n; ++i) {\n        if (dp[0][0][i] < 0 || dp[1][0][i]) {\n            ans = std::min(ans, i);\n            break;\n        }\n    }\n\n    std::cout << ans << std::endl;\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n#define int ll\n\n#define REP(i,n) for(int i=0;i<n;++i)\n#define SORT(name) sort(name.begin(), name.end())\n#define ZERO(p) memset(p, 0, sizeof(p))\n#define MINUS(p) memset(p, -1, sizeof(p))\n#if 1\n#  define DBG(fmt, ...) printf(fmt, ##__VA_ARGS__)\n#else\n#  define DBG(fmt, ...)\n#endif\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst double DINF = std::numeric_limits<double>::infinity();\nconst int MOD = 1000000007;\n#define MAX_N 5010\n\nll N;\nvector<ll> A;\nvector< vector<ll> > G; // グラフ(隣接リスト)\n\n// 頂点 v を根とした部分木に何個の頂点が含まれるか(自分含む)\nll num[MAX_N];\n\n// dp[v][num][0]\n// v が根。 num 本の辺を切断する場合 、かつ、\n// v を含まない連結成分は条件を満たす場合の、\n// v を含む連結成分の重みの総和の最小\n// dp[v][num][1]\n// v が根。 num 本の辺を切断する場合、かつ、\n// v を含まない連結成分は条件を満たす場合、かつ、\n// v を含む連結成分の重みがすべて正の場合の、総和の最小\nll dp[MAX_N][MAX_N][2];\n\n// 頂点 v の子ノードに対する dp\n// dp[][][] を作成するために各頂点ごとに初期化して利用する一時的なテーブル\n// sdp[num][0]\n// num 本の辺を切断する場合 、かつ、\n// v を含まない連結成分は条件を満たす場合の、\n// v を含む連結成分の重みの総和の最小\n// sdp[num][1]\n// num 本の辺を切断する場合、かつ、\n// v を含まない連結成分は条件を満たす場合、かつ、\n// v を含む連結成分の重みがすべて正の場合の、総和の最小\nll sdp[MAX_N][2];\n\n// v: 頂点 id\n// parent: v の前に辿っていた頂点(親)\n// dp[] を葉から順に埋めていく\nvoid rec(ll v, ll parent) {\n    // num[v] の作成\n    num[v] = 1;\n    for(auto& child : G[v]) {\n        if(child == parent) { continue; }\n        rec(child, v);\n        num[v] += num[child];\n    }\n\n    // sdp 初期化\n    for(ll j = 0; j <= num[v]; ++j) { sdp[j][0] = sdp[j][1] = LLINF; }\n\n    sdp[0][0] = A[v];\n    if(A[v] > 0) { sdp[0][1] = A[v]; }\n\n    // 現在までに見た部分木のノード数の和(= 今までの切断可能辺数)\n    ll curnum = 0;\n\n    // 頂点 v の子である頂点 child について考える\n    for(auto child : G[v]) {\n        if(child == parent) { continue; }\n\n        for(ll j = curnum; j >= 0; --j) {\n            ll tmp0 = sdp[j][0];    // v 以下の部分木で切断辺数が j のときの、総和の最小値\n            ll tmp1 = sdp[j][1];    // v 以下の部分木で切断辺数が j のときの、総和の最小値(重みが正のみ)\n            sdp[j][0] = sdp[j][1] = LLINF;\n\n            // k : 切断可能辺数\n            for(ll k = 0; k < num[child]; ++k) {\n                // dp[child][k][0] : 頂点 child 以下の部分木から k 個の辺を切断したときの\n                //                   連結成分の重みの総和の最大値\n                sdp[j+k][0] = min(sdp[j+k][0], tmp0 + dp[child][k][0]);\n\n                // もし総和が機能停止の条件を満たす\n                //   (負か重みが正のみの総和も値が入っている(LLINF じゃない) )\n                // ときは、全てを切り離した際の値も更新できる\n                if(dp[child][k][0] < 0 || dp[child][k][1] < LLINF / 2) {\n                    sdp[j+k+1][0] = min(sdp[j+k+1][0], tmp0);\n                }\n\n                // 重みが正なら、正のみの dp テーブルも更新\n                if(A[v] > 0) {\n                    sdp[j+k][1] = min(sdp[j+k][1], tmp1 + dp[child][k][1]);\n                    if(dp[child][k][0] < 0 || dp[child][k][1] < LLINF/ 2) {\n                        sdp[j+k+1][1] = min(sdp[j+k+1][1], tmp1);\n                    }\n                }\n            }\n        }\n        // この child 以下の辺の数 + v と child をつなぐ辺 = num[child]\n        // なので curnum として保持しておく\n        curnum += num[child];\n    }\n\n    // sdp の dp への反映\n    for(ll j = 0; j <= num[v]; ++j) {\n        dp[v][j][0] = sdp[j][0];\n        dp[v][j][1] = sdp[j][1];\n    }\n}\n\nsigned main()\n{\n    cin >> N;\n    A.resize(N);\n    REP(i, N) { cin >> A[i]; }\n    G.assign(N, vector<ll>());\n    REP(i, N-1) {\n        ll u, v;\n        cin >> u >> v;\n        --u; --v;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n\n    // DP 初期化\n    REP(i, MAX_N) { REP(j, MAX_N) { dp[i][j][0] = dp[i][j][1] = LLINF; } }\n    // 0 を根とした dp テーブルの作成\n    rec(0, -1);\n\n    // ans を求める\n    ll ans = N;\n    for(ll i = 0; i <= N; ++i) {\n        // 0 を根として、 i 回切断したときに条件が満たされるなら ans を更新\n        if(dp[0][i][0] < 0) { ans = min(ans, i); }\n        if(dp[0][i][1] < LLINF / 2) { ans = min(ans, i); }\n    }\n    printf(\"%lld\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize (\"-O3\")\n#include <bits/stdc++.h>\nusing namespace std;\n//衝突対策\n#define ws wszzzz\n#define int long long\n\n//@formatter:off\ntemplate<class A, class B, class C>struct T2 {A f;B s;C t;T2() { f = 0, s = 0, t = 0; }T2(A f, B s, C t) : f(f), s(s), t(t) {}bool operator<(const T2 &r) const {        return f != r.f ? f < r.f : s != r.s ? s < r.s : t < r.t;        /*return f != r.f ? f > r.f : s != r.s ?n s > r.s : t > r.t; 大きい順 */   }    bool operator>(const T2 &r) const {        return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t;        /*return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 小さい順 */   }    bool operator==(const T2 &r) const {        return f == r.f && s == r.s && t == r.t;    }    bool operator!=(const T2 &r) const {        return f != r.f || s != r.s || t != r.t;    }};\ntemplate<class A, class B, class C, class D> struct F2 {    A a;    B b;    C c;    D d;    F2() { a = 0, b = 0, c = 0, d = 0; }    F2(A a, B b, C c, D d) : a(a), b(b), c(c), d(d) {}    bool operator<(const F2 &r) const {        return a != r.a ? a < r.a : b != r.b ? b < r.b : c != r.c ? c < r.c : d < r.d;    /*    return a != r.a ? a > r.a : b != r.b ? b > r.b : c != r.c ? c > r.c : d > r.d;*/    }    bool operator>(const F2 &r) const {        return a != r.a ? a > r.a : b != r.b ? b > r.b : c != r.c ? c > r.c : d > r.d;/*        return a != r.a ? a < r.a : b != r.b ? b < r.b : c != r.c ? c < r.c : d < r.d;*/    }    bool operator==(const F2 &r) const {        return a == r.a && b == r.b && c == r.c && d == r.d;    }    bool operator!=(const F2 &r) const {        return a != r.a || b != r.b || c != r.c || d != r.d;    }    int operator[](int i) {        assert(i < 4);        return i == 0 ? a : i == 1 ? b : i == 2 ? c : d;    }};\ntypedef T2<int, int, int> T;\ntypedef F2<int, int, int, int> F;\nT mt(int a, int b, int c) {return T(a, b, c);}\n\n//@マクロ省略系 型,構造\n#define ll long long\n#define double long double\n#define ull unsigned long long\nusing dou = double;\nusing itn = int;\nusing str = string;\nusing bo= bool;\n#define au auto\nusing P = pair<int, int>;\nusing pd =pair<dou, dou>;\n#define fi first\n#define se second\n#define beg begin\n#define rbeg rbegin\n#define con continue\n#define bre break\n#define brk break\n#define is ==\n#define elf else if\n#define wh while\n\n#define maxq 1\n#define minq -1\n\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define MALLOC(type, len) (type*)malloc((len) * sizeof(type))\n#define lam(right) [&](int& p){return p right;}\n\n//マクロ省略系 コンテナ\nusing vi = vector<int>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\nusing vd = vector<double>;\nusing vc = vector<char>;\nusing vp = vector<P>;\nusing vt = vector<T>;\n\n#define V vector\n#define o_vvt(o1, o2, o3, o4, name, ...) name\n#define vvt0(t) V<V<t>>\n#define vvt1(t,a) V<V<t>>a\n#define vvt2(t,a, b) V<V<t>>a(b)\n#define vvt3(t,a, b, c) V<V<t>> a(b,V<t>(c))\n#define vvt4(t,a, b, c, d) V<V<t>> a(b,V<t>(c,d))\n\n#define vvi(...) o_vvt(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(int,__VA_ARGS__)\n#define vvb(...) o_vvt(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(bool,__VA_ARGS__)\n#define vvs(...) o_vvt(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(string,__VA_ARGS__)\n#define vvd(...) o_vvt(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(double,__VA_ARGS__)\n#define vvc(...) o_vvt(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(char,__VA_ARGS__)\n#define vvp(...) o_vvt(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(P,__VA_ARGS__)\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts> auto make_v(size_t a, Ts... ts) {return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));}\n#define vni(name, ...) auto name = make_v<int>(__VA_ARGS__)\n#define vnb(name, ...) auto name = make_v<bool>(__VA_ARGS__)\n#define vns(name, ...) auto name = make_v<string>(__VA_ARGS__)\n#define vnd(name, ...) auto name = make_v<double>(__VA_ARGS__)\n#define vnc(name, ...) auto name = make_v<char>(__VA_ARGS__)\n#define vnp(name, ...) auto name = make_v<P>(__VA_ARGS__)\n\n#define PQ priority_queue<int, vector<int>, greater<int> >\n#define tos to_string\nusing mapi = map<int, int>;\nusing mapp = map<P, int>;\nusing mapd = map<dou, int>;\nusing mapc = map<char, int>;\nusing maps = map<str, int>;\nusing seti = set<int>;\nusing setd = set<dou>;\nusing setc = set<char>;\nusing sets = set<str>;\nusing qui = queue<int>;\n#define bset bitset\n#define uset unordered_set\n#define mset multiset\n#define umap unordered_map\n#define umapi unordered_map<int,int>\n#define umapp unordered_map<P,int>\n#define mmap multimap\n\n\ntemplate<class T> struct pq {\n    priority_queue<T, vector<T>, greater<T> > q;//小さい順\n    T su = 0;\n    void clear() {q = priority_queue<T, vector<T>, greater<T> >();su = 0;}\n    void operator+=(T v) {su += v;q.push(v);}\n    T sum() {return su;}\n    T top() {return q.top();}\n    void pop() {su -= q.top();q.pop();}\n    T poll() {T ret = q.top();su -= ret;q.pop();return ret;}\n    int size() {return q.size();}\n};\ntemplate<class T> struct pqg {\n    priority_queue<T> q;//大きい順\n    T su = 0;\n    void clear() {q = priority_queue<T>();su = 0;}\n    void operator+=(T v) {su += v;q.push(v);}\n    T sum() {return su;}\n    T top() {return q.top();}\n    void pop() {su -= q.top();q.pop();}\n    T poll() {T ret = q.top();su -= ret;q.pop();return ret;}\n    int size() {return q.size();}\n};\n\n#define pqi pq<int>\n#define pqgi pqg<int>\n//マクロ 繰り返し\n#define o_rep(o1, o2, o3, o4, name, ...) name\n# define rep1(n) for(int rep1i = 0,rep1lim=n; rep1i < rep1lim ; rep1i++)\n# define rep2(i, n) for(int i = 0,rep2lim=n; i < rep2lim ; i++)\n#define rep3(i, m, n) for(int i = m,rep3lim=n; i < rep3lim ; i++)\n#define rep4(i, m, n, ad) for(int i = m,rep4lim=n; i < rep4lim ; i+= ad)\n#define rep(...) o_rep(__VA_ARGS__,rep4,rep3,rep2,rep1)(__VA_ARGS__)\n\n#define rer2(i, n) for(int i = n; i >= 0 ; i--)\n#define rer3(i, m, n) for(int i = m,rer3lim=n; i >= rer3lim ; i--)\n#define rer4(i, m, n, dec) for(int i = m,rer4lim=n; i >= rer4lim ; i-=dec)\n#define rer(...) o_rep(__VA_ARGS__,rer4,rer3,rer2,)(__VA_ARGS__)\n\n#define reps2(i, j, n) for(int i = 0,reps2lim=n; i < reps2lim ; i++)for(int j = 0; j < reps2lim ; j++)\n#define reps3(i, j, k, n) for(int i = 0,reps3lim=n; i < reps3lim ; i++)for(int j = 0; j < reps3lim ; j++)for(int k = 0; k < reps3lim ; k++)\n#define reps4(i, j, k, l, n) for(int i = 0,reps4lim=n; i < reps4lim ; i++)for(int j = 0; j < reps4lim ; j++)for(int k = 0; k < reps4lim ; k++)for(int l = 0; l < reps4lim ; l++)\n#define o_reps(o1, o2, o3, o4, o5, name, ...) name\n#define reps(...) o_reps(__VA_ARGS__,reps4,reps3,reps2,rep2,)(__VA_ARGS__)\n\n#define repss(i, j, k, a, b, c) for(int i = 0; i < a ; i++)for(int j = 0; j < b ; j++)for(int k = 0; k < c ; k++)\n\n#define fora(a, b) for(auto&& a : b)\n#define forg(gi, ve) for (int gi = 0,forglim = ve.size(), f, t, c; gi < forglim && (f = ve[gi].f, t = ve[gi].t, c = ve[gi].c, true); gi++)\n#define fort(gi, ve) for (int gi = 0, f, t, c; gi < ve.size() && (f = ve[gi].f, t = ve[gi].t, c = ve[gi].c, true); gi++)if(t!=p)\n\n#define form(st, l, r) for (auto &&it = st.lower_bound(l); it != st.end() && (*it).fi < r; it++)\n#define forit(st, l, r) for (auto &&it = st.lower_bound(l); it != st.end() && (*it) < r;)\n\n//マクロ 定数\n#define k3 1010\n#define k4 10101\n#define k5 101010\n#define k6 1010101\n#define k7 10101010\nconst int inf = (int) 1e9 + 100;\nconst ll linf = (ll) 1e18 + 100;\nconst char infc = '{';\nconst string infs = \"{\";\nconst double eps = 1e-9;\nconst double PI = 3.1415926535897932384626433832795029L;\nll ma = numeric_limits<ll>::min();\nll mi = numeric_limits<ll>::max();\nconst int y4[] = {-1, 1, 0, 0};\nconst int x4[] = {0, 0, -1, 1};\nconst int y8[] = {0, 1, 0, -1, -1, 1, 1, -1};\nconst int x8[] = {1, 0, -1, 0, 1, -1, 1, -1};\n\n//マクロ省略形 関数等\n#define arsz(a) (sizeof(a)/sizeof(a[0]))\n#define sz(a) ((int)(a).size())\n#define mp make_pair\n#define pb pop_back\n#define pf push_front\n#define eb emplace_back\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\nconstexpr bool ev(int a) { return !(a & 1); }\nconstexpr bool od(int a) { return (a & 1); }\n//@拡張系 こう出来るべきというもの\n\n//埋め込み 存在を意識せずに機能を増やされているもの\nnamespace std {template<> class hash<std::pair<signed, signed>> {public:size_t operator()(const std::pair<signed, signed> &x) const {return hash<ll>()(((ll) x.first << 32) + x.second);}};template<> class hash<std::pair<ll, ll>> {public:/*大きいllが渡されると、<<32でオーバーフローするがとりあえず問題ないと判断*/size_t operator()(const std::pair<ll, ll> &x) const {return hash<ll>()(((ll) x.first << 32) + x.second);}};}\n\n//stream まとめ\nistream &operator>>(istream &iss, P &a) {iss >> a.first >> a.second;return iss;}template<typename T> istream &operator>>(istream &iss, vector<T> &vec) {for (T &x: vec) iss >> x;return iss;}template<class T, class U> ostream &operator<<(ostream &os, pair<T, U> p) {os << p.fi << \" \" << p.se << endl;return os;}ostream &operator<<(ostream &os, T p) {    os << p.f << \" \" << p.s << \" \" << p.t;    return os;}ostream &operator<<(ostream &os, F p) {    os << p.a << \" \" << p.b << \" \" << p.c << \" \" << p.d;    return os;}template<typename T> ostream &operator<<(ostream &os, vector <T> &vec) {    for (int i = 0; i < vec.size(); i++)os << vec[i] << (i + 1 == vec.size() ? \"\" : \" \");    return os;}template<typename T> ostream &operator<<(ostream &os, vector <vector<T>> &vec) {    for (int i = 0; i < vec.size(); i++) {        for (int j = 0; j < vec[0].size(); j++) {            os << vec[i][j];        }        os << endl;    }    return os;}template<typename T, typename U> ostream &operator<<(ostream &os, map<T, U> &m) {    for (auto &&v:m) os << v;    return os;}\n\ntemplate<typename W, typename H> void resize(vector<W> &vec, const H head) { vec.resize(head); }template<typename W, typename H, typename ... T> void resize(vector<W> &vec, const H &head, const T ... tail) {vec.resize(head);for (auto &v: vec)resize(v, tail...);}\n//@formatter:on\ntemplate<typename T, typename F> bool all_of2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> bool all_of2(vector<T> &v, F f) {\n    rep(i, sz(v)) { if (!all_of2(v[i], f))return false; }\n    return true;\n}\ntemplate<typename T, typename F> bool any_of2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> bool any_of2(vector<T> &v, F f) {\n    rep(i, sz(v)) { if (any_of2(v[i], f))return true; }\n    return false;\n}\ntemplate<typename T, typename F> bool none_of2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> bool none_of2(vector<T> &v, F f) {\n    rep(i, sz(v)) { if (none_of2(v[i], f))return false; }\n    return true;\n}\ntemplate<typename T, typename F> bool find_if2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> int find_if2(vector<T> &v, F f) {\n    rep(i, sz(v)) { if (find_if2(v[i], f))return i; }\n    return sz(v);\n}\ntemplate<typename T, typename F> bool rfind_if2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> int rfind_if2(vector<T> &v, F f) {\n    rer(i, sz(v) - 1) { if (rfind_if2(v[i], f))return i; }\n    return -1;\n}\ntemplate<class T> bool contains(string &s, const T &v) { return s.find(v) != string::npos; }\ntemplate<typename T> bool contains(vector<T> &v, const T &val) { return std::find(v.begin(), v.end(), val) != v.end(); }\ntemplate<typename T, typename F> bool contains_if2(vector<T> &v, F f) { return find_if(v.begin(), v.end(), f) != v.end(); }\ntemplate<typename T, typename F> int count_if2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> int count_if2(vector<T> &vec, F f) {\n    int ret = 0;\n    fora(v, vec)ret += count_if2(v, f);\n    return ret;\n}\ntemplate<typename T, typename F> void for_each2(T &v, F f) { f(v); }\ntemplate<typename T, typename F> void for_each2(vector<T> &vec, F f) { fora(v, vec)for_each2(v, f); }\n//@formatter:off\ntemplate<typename W> int count_od(vector<W> &a) {return count_if2(a,[](int v){return v&1 ;});}\ntemplate<typename W> int count_ev(vector<W> &a) {return count_if2(a,[](int v){return !(v&1) ;});}\n#define all_of(a,right) all_of2(a,lam(right))\n#define any_of(a,right) any_of2(a,lam(right))\n#define none_of(a,right) none_of2(a,lam(right))\n#define find_if(a,right) find_if2(a,lam(right))\n#define rfind_if(a,right) rfind_if2(a,lam(right))\n#define contains_if(a,right) contains_if2(a,lam(right))\n#define count_if(a, right) count_if2(a,lam(right))\n#define for_each(a, right) do{fora(v,a){v right;}}while(0)\n\n\ntemplate<class T, class U> void replace(vector<T> &a, T key, U v) { replace(a.begin(), a.end(), key, v); }\nvoid replace(str &a, char key, str v) { if (v == \"\")a.erase(remove(all(a), key), a.end()); }\nvoid replace(str &a, char key, char v) { replace(all(a), key, v); }\n//keyと同じかどうか01で置き換える\ntemplate<class T, class U> void replace(vector<T> &a, U k) { rep(i, sz(a)) a[i] = a[i] == k; }\ntemplate<class T, class U> void replace(vector<vector<T >> &a, U k) { rep(i, sz(a))rep(j, sz(a[0])) a[i][j] = a[i][j] == k; }\ntemplate<class T> void replace(T &a) { replace(a, '#'); }\nvoid replace(str &a, str key, str v) {stringstream t;int kn = sz(key);std::string::size_type Pos(a.find(key));int l = 0;while (Pos != std::string::npos) {t << a.substr(l, Pos - l);t << v;l = Pos + kn;Pos = a.find(key, Pos + kn);}t << a.substr(l, sz(a) - l);a = t.str();}\ntemplate<class T> bool includes(vector<T> &a, vector<T> &b) {vi c = a;vi d = b;sort(all(c));sort(all(d));return includes(all(c), all(d));}\ntemplate<class T> bool is_permutation(vector<T> &a, vector<T> &b) { return is_permutation(all(a), all(b)); }\ntemplate<class T> bool next_permutation(vector<T> &a) { return next_permutation(all(a)); }\nvoid iota(vector<int> &ve, int s, int n) {ve.resize(n);iota(all(ve), s);}\nvi iota(int s, int len) {vi ve(len);iota(all(ve), s);return ve;}\ntemplate<class A, class B> auto vtop(vector<A> &a, vector<B> &b) {    assert(sz(a) == sz(b));    /*stringを0で初期化できない  */  vector<pair<A, B>> res;    rep(i, sz(a))res.eb(a[i], b[i]);return res;}\ntemplate<class A, class B> void ptov(vector<pair<A, B>> &p, vector<A> &a, vector<B> &b) {    a.resize(sz(p)), b.resize(sz(p));    rep(i, sz(p))a[i] = p[i].fi, b[i] = p[i].se;}\ntemplate<class A, class B, class C> auto vtot(vector<A> &a, vector<B> &b, vector<C> &c) {    assert(sz(a) == sz(b) && sz(b) == sz(c));    vector<T2<A, B, C>> res;    rep(i, sz(a))res.eb(a[i], b[i], c[i]);    return res;}\ntemplate<class A, class B, class C, class D> auto vtof(vector<A> &a, vector<B> &b, vector<C> &c, vector<D> &d) {    assert(sz(a) == sz(b) && sz(b) == sz(c) && sz(c) == sz(d));    vector<F2<A, B, C, D>> res;    rep(i, sz(a))res.eb(a[i], b[i], c[i], d[i]);    return res;}\nenum pcomparator { fisi, fisd, fdsi, fdsd, sifi, sifd, sdfi, sdfd };\nenum tcomparator {    fisiti, fisitd, fisdti, fisdtd, fdsiti, fdsitd, fdsdti, fdsdtd,    fitisi, fitisd, fitdsi, fitdsd, fdtisi, fdtisd, fdtdsi, fdtdsd,    sifiti, sifitd, sifdti, sifdtd, sdfiti, sdfitd, sdfdti, sdfdtd,    sitifi, sitifd, sitdfi, sitdfd, sdtifi, sdtifd, sdtdfi, sdfdfd,    tifisi, tifisd, tifdsi, tifdsd, tdfisi, tdfisd, tdfdsi, tdfdsd,    tisifi, tisifd, tisdfi, tisdfd, tdsifi, tdsifd, tdsdfi, tdsdfd};\ntemplate<class A, class B> void sort(vector<pair<A, B>> &a, pcomparator type) {    typedef pair<A, B> U;    if (type == fisi) sort(all(a), [&](U l, U r) { return l.fi != r.fi ? l.fi < r.fi : l.se < r.se; });    else if (type == fisd) sort(all(a), [&](U l, U r) { return l.fi != r.fi ? l.fi < r.fi : l.se > r.se; });    else if (type == fdsi) sort(all(a), [&](U l, U r) { return l.fi != r.fi ? l.fi > r.fi : l.se < r.se; });    else if (type == fdsd) sort(all(a), [&](U l, U r) { return l.fi != r.fi ? l.fi > r.fi : l.se > r.se; });    else if (type == sifi) sort(all(a), [&](U l, U r) { return l.se != r.se ? l.se < r.se : l.fi < r.fi; });    else if (type == sifd) sort(all(a), [&](U l, U r) { return l.se != r.se ? l.se < r.se : l.fi > r.fi; });    else if (type == sdfi) sort(all(a), [&](U l, U r) { return l.se != r.se ? l.se > r.se : l.fi < r.fi; });    else if (type == sdfd) sort(all(a), [&](U l, U r) { return l.se != r.se ? l.se > r.se : l.fi > r.fi; });};template<class U> void sort(vector<U> &a, pcomparator type) {    if (type == fisi) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s < r.s; });    else if (type == fisd) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s > r.s; });    else if (type == fdsi) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s < r.s; });    else if (type == fdsd) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s > r.s; });    else if (type == sifi) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f < r.f; });    else if (type == sifd) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f > r.f; });    else if (type == sdfi) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f < r.f; });    else if (type == sdfd) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f > r.f; });};template<class A, class B, class C, class D> void sort(vector<F2<A, B, C, D> > &a, pcomparator type) {    typedef F2<A, B, C, D> U;    if (type == fisi) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b < r.b; });    else if (type == fisd) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b > r.b; });    else if (type == fdsi) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b < r.b; });    else if (type == fdsd) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b > r.b; });    else if (type == sifi) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a < r.a; });    else if (type == sifd) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a > r.a; });    else if (type == sdfi) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a < r.a; });    else if (type == sdfd) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a > r.a; });};template<class U> void sort(vector<U> &a, tcomparator type) {    if (type == 0) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s < r.s : l.t < r.t; });    else if (type == 1) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s < r.s : l.t > r.t; });    else if (type == 2) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s > r.s : l.t < r.t; });    else if (type == 3) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s > r.s : l.t > r.t; });    else if (type == 4) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s < r.s : l.t < r.t; });    else if (type == 5) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s < r.s : l.t > r.t; });    else if (type == 6) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s > r.s : l.t < r.t; });    else if (type == 7) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s > r.s : l.t > r.t; });    else if (type == 8) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t < r.t : l.s < r.s; });    else if (type == 9) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t < r.t : l.s > r.s; });    else if (type == 10) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t > r.t : l.s < r.s; });    else if (type == 11) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t > r.t : l.s > r.s; });    else if (type == 12) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t < r.t : l.s < r.s; });    else if (type == 13) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t < r.t : l.s > r.s; });    else if (type == 14) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t > r.t : l.s < r.s; });    else if (type == 15) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t > r.t : l.s > r.s; });    else if (type == 16) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f < r.f : l.t < r.t; });    else if (type == 17) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f < r.f : l.t > r.t; });    else if (type == 18) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f > r.f : l.t < r.t; });    else if (type == 19) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f > r.f : l.t > r.t; });    else if (type == 20) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f < r.f : l.t < r.t; });    else if (type == 21) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f < r.f : l.t > r.t; });    else if (type == 22) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f > r.f : l.t < r.t; });    else if (type == 23) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f > r.f : l.t > r.t; });    else if (type == 24) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t < r.t : l.f < r.f; });    else if (type == 25) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t < r.t : l.f > r.f; });    else if (type == 26) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t > r.t : l.f < r.f; });    else if (type == 27) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t > r.t : l.f > r.f; });    else if (type == 28) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t < r.t : l.f < r.f; });    else if (type == 29) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t < r.t : l.f > r.f; });    else if (type == 30) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t > r.t : l.f < r.f; });    else if (type == 31) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t > r.t : l.f > r.f; });    else if (type == 32) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f < r.f : l.s < r.s; });    else if (type == 33) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f < r.f : l.s > r.s; });    else if (type == 34) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f > r.f : l.s < r.s; });    else if (type == 35) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f > r.f : l.s > r.s; });    else if (type == 36) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f < r.f : l.s < r.s; });    else if (type == 37) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f < r.f : l.s > r.s; });    else if (type == 38) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f > r.f : l.s < r.s; });    else if (type == 39) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f > r.f : l.s > r.s; });    else if (type == 40) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s < r.s : l.f < r.f; });    else if (type == 41) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s < r.s : l.f > r.f; });    else if (type == 42) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s > r.s : l.f < r.f; });    else if (type == 43) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s > r.s : l.f > r.f; });    else if (type == 44) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s < r.s : l.f < r.f; });    else if (type == 45) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s < r.s : l.f > r.f; });    else if (type == 46) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s > r.s : l.f < r.f; });    else if (type == 47) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s > r.s : l.f > r.f; });}template<class A, class B, class C, class D> void sort(vector<F2<A, B, C, D>> &a, tcomparator type) {    typedef F2<A, B, C, D> U;    if (type == 0) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b < r.b : l.c < r.c; });    else if (type == 1) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b < r.b : l.c > r.c; });    else if (type == 2) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b > r.b : l.c < r.c; });    else if (type == 3) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b > r.b : l.c > r.c; });    else if (type == 4) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b < r.b : l.c < r.c; });    else if (type == 5) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b < r.b : l.c > r.c; });    else if (type == 6) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b > r.b : l.c < r.c; });    else if (type == 7) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b > r.b : l.c > r.c; });    else if (type == 8) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c < r.c : l.b < r.b; });    else if (type == 9) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c < r.c : l.b > r.b; });    else if (type == 10) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c > r.c : l.b < r.b; });    else if (type == 11) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c > r.c : l.b > r.b; });    else if (type == 12) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c < r.c : l.b < r.b; });    else if (type == 13) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c < r.c : l.b > r.b; });    else if (type == 14) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c > r.c : l.b < r.b; });    else if (type == 15) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c > r.c : l.b > r.b; });    else if (type == 16) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a < r.a : l.c < r.c; });    else if (type == 17) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a < r.a : l.c > r.c; });    else if (type == 18) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a > r.a : l.c < r.c; });    else if (type == 19) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a > r.a : l.c > r.c; });    else if (type == 20) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a < r.a : l.c < r.c; });    else if (type == 21) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a < r.a : l.c > r.c; });    else if (type == 22) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a > r.a : l.c < r.c; });    else if (type == 23) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a > r.a : l.c > r.c; });    else if (type == 24) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c < r.c : l.a < r.a; });    else if (type == 25) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c < r.c : l.a > r.a; });    else if (type == 26) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c > r.c : l.a < r.a; });    else if (type == 27) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c > r.c : l.a > r.a; });    else if (type == 28) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c < r.c : l.a < r.a; });    else if (type == 29) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c < r.c : l.a > r.a; });    else if (type == 30) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c > r.c : l.a < r.a; });    else if (type == 31) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c > r.c : l.a > r.a; });    else if (type == 32) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a < r.a : l.b < r.b; });    else if (type == 33) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a < r.a : l.b > r.b; });    else if (type == 34) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a > r.a : l.b < r.b; });    else if (type == 35) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a > r.a : l.b > r.b; });    else if (type == 36) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a < r.a : l.b < r.b; });    else if (type == 37) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a < r.a : l.b > r.b; });    else if (type == 38) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a > r.a : l.b < r.b; });    else if (type == 39) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a > r.a : l.b > r.b; });    else if (type == 40) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b < r.b : l.a < r.a; });    else if (type == 41) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b < r.b : l.a > r.a; });    else if (type == 42) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b > r.b : l.a < r.a; });    else if (type == 43) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b > r.b : l.a > r.a; });    else if (type == 44) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b < r.b : l.a < r.a; });    else if (type == 45) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b < r.b : l.a > r.a; });    else if (type == 46) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b > r.b : l.a < r.a; });    else if (type == 47) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b > r.b : l.a > r.a; });}\n\nvoid sort(string &a) { sort(all(a)); }\ntemplate<class T> void sort(vector<T> &a) { sort(all(a)); }\n//P l, P rで f(P) の形で渡す\ntemplate<class U, class F> void sort(vector<U> &a, F f) { sort(all(a), [&](U l, U r) { return f(l) < f(r); }); };\ntemplate<class T> void rsort(vector<T> &a) { sort(all(a), greater<T>()); };\ntemplate<class U, class F> void rsort(vector<U> &a, F f) { sort(all(a), [&](U l, U r) { return f(l) > f(r); }); };\n//F = T<T>\n//例えばreturn p.fi + p.se;\ntemplate<class A, class B> void sortp(vector<A> &a, vector<B> &b) {    auto c = vtop(a, b);    sort(c);    rep(i, sz(a)) a[i] = c[i].fi, b[i] = c[i].se;}template<class A, class B, class F> void sortp(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    sort(c, f);    rep(i, sz(a)) a[i] = c[i].fi, b[i] = c[i].se;}template<class A, class B> void rsortp(vector<A> &a, vector<B> &b) {    auto c = vtop(a, b);    rsort(c);    rep(i, sz(a))a[i] = c[i].first, b[i] = c[i].second;}template<class A, class B, class F> void rsortp(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    rsort(c, f);    rep(i, sz(a))a[i] = c[i].first, b[i] = c[i].second;}template<class A, class B, class C> void sortt(vector<A> &a, vector<B> &b, vector<C> &c) {    auto d = vtot(a, b, c);    sort(d);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}template<class A, class B, class C, class F> void sortt(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    sort(d, f);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}template<class A, class B, class C> void rsortt(vector<A> &a, vector<B> &b, vector<C> &c) {    auto d = vtot(a, b, c);    rsort(d);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}template<class A, class B, class C, class F> void rsortt(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    rsort(d, f);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\n//sortindex 元のvectorはソートしない\ntemplate<class T> vi sorti(vector<T> &a) {    auto b = a;    vi ind = iota(0, sz(a));    sortp(b, ind);    return ind;}/*indexの分で型が変わるためpcomparatorが必要*/template<class T> vi sorti(vector<T> &a, pcomparator f) {    auto b = a;    vi ind = iota(0, sz(a));    sortp(b, ind, f);    return ind;}template<class T, class F> vi sorti(vector<T> &a, F f) {    vi ind = iota(0, sz(a));    sort(all(ind), [&](int x, int y) { return f(a[x]) < f(a[y]); });    return ind;}template<class T> vi rsorti(vector<T> &a) {    auto b = a;    vi ind = iota(0, sz(a));    rsortp(b, ind);    return ind;}template<class T, class F> vi rsorti(vector<T> &a, F f) {    vi ind = iota(0, sz(a));    sort(all(ind), [&](int x, int y) { return f(a[x]) > f(a[y]); });    return ind;}template<class A, class B, class F> vi sortpi(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    vi ind = iota(0, sz(a));    sort(all(ind), [&](int x, int y) { return f(c[x]) < f(c[y]); });    return ind;}template<class A, class B> vi sortpi(vector<A> &a, vector<B> &b, pcomparator f) {    vi ind = iota(0, sz(a));    auto c = a;    auto d = b;    sortt(c, d, ind, f);    return ind;}template<class A, class B> vi sortpi(vector<A> &a, vector<B> &b) { return sortpi(a, b, fisi); };template<class A, class B, class F> vi rsortpi(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    vi ind = iota(0, sz(a));    sort(all(ind), [&](int x, int y) { return f(c[x]) > f(c[y]); });    return ind;}template<class A, class B> vi rsortpi(vector<A> &a, vector<B> &b) { return sortpi(a, b, fdsd); };template<class A, class B, class C, class F> vi sortti(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    vi ind = iota(0, sz(a));    sort(all(ind), [&](int x, int y) { return f(d[x]) < f(d[y]); });    return ind;}template<class A, class B, class C> vi sortti(vector<A> &a, vector<B> &b, vector<C> &c, pcomparator f) {    vi ind = iota(0, sz(a));    auto d = vtof(a, b, c, ind);    sort(d, f);    rep(i, sz(a))ind[i] = d[i].d;    return ind;}template<class A, class B, class C> vi sortti(vector<A> &a, vector<B> &b, vector<C> &c) {    vi ind = iota(0, sz(a));    sort(all(ind), [&](int x, int y) {        if (a[x] == a[y]) {            if (b[x] == b[y])return c[x] < c[y];            else return b[x] < b[y];        } else {            return a[x] < a[y];        }    });    return ind;}template<class A, class B, class C, class F> vi rsortti(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    vi ind = iota(0, sz(a));    sort(all(ind), [&](int x, int y) { return f(d[x]) > f(d[y]); });    return ind;}template<class A, class B, class C> vi rsortti(vector<A> &a, vector<B> &b, vector<C> &c) {    vi ind = iota(0, sz(a));    sort(all(ind), [&](int x, int y) {        if (a[x] == a[y]) {            if (b[x] == b[y])return c[x] > c[y];            else return b[x] > b[y];        } else {            return a[x] > a[y];        }    });    return ind;}\ntemplate<class T> void sort2(vector<vector<T >> &a) { for (int i = 0, n = a.size(); i < n; i++)sort(a[i]); }\ntemplate<class T> void rsort2(vector<vector<T >> &a) { for (int i = 0, n = a.size(); i < n; i++)rsort(a[i]); }\n\ntemplate<typename A, size_t N, typename T> void fill(A (&a)[N], const T &v) { rep(i, N)a[i] = v; }template<typename A, size_t N, size_t O, typename T> void fill(A (&a)[N][O], const T &v) { rep(i, N)rep(j, O)a[i][j] = v; }template<typename A, size_t N, size_t O, size_t P, typename T> void fill(A (&a)[N][O][P], const T &v) { rep(i, N)rep(j, O)rep(k, P)a[i][j][k] = v; }template<typename A, size_t N, size_t O, size_t P, size_t Q, typename T> void fill(A (&a)[N][O][P][Q], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)a[i][j][k][l] = v; }template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, typename T> void fill(A (&a)[N][O][P][Q][R], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)a[i][j][k][l][m] = v; }template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S, typename T> void fill(A (&a)[N][O][P][Q][R][S], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)rep(n, S)a[i][j][k][l][m][n] = v; }\ntemplate<typename W, typename T>void fill(W &xx, const T vall) {    xx = vall;}template<typename W, typename T>void fill(vector<W> &vecc, const T vall) {    for (auto &&vx     : vecc)fill(vx, vall);}\ntemplate<class T,class U>void fill(vector<T> &a,U val,vi& ind) {fora(v,ind)a[v]=val;}\ntemplate<typename A, size_t N> A sum(A (&a)[N]) {    A res = 0;    rep(i, N)res += a[i];    return res;}template<typename A, size_t N, size_t O> A sum(A (&a)[N][O]) {    A res = 0;    rep(i, N)rep(j, O)res += a[i][j];    return res;}template<typename A, size_t N, size_t O, size_t P> A sum(A (&a)[N][O][P]) {    A res = 0;    rep(i, N)rep(j, O)rep(k, P)res += a[i][j][k];    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q> A sum(A (&a)[N][O][P][Q]) {    A res = 0;    rep(i, N)rep(j, O)rep(k, P)rep(l, Q)res += a[i][j][k][l];    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R> A sum(A (&a)[N][O][P][Q][R]) {    A res = 0;    rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)res += a[i][j][k][l][m];    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S> A sum(A (&a)[N][O][P][Q][R][S]) {    A res = 0;    rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)rep(n, S)res += a[i][j][k][l][m][n];    return res;}\n//@汎用便利関数 入力\nint in() {int ret;cin >> ret;return ret;}\nstring sin() {string ret;cin >> ret;return ret;}\ntemplate<class T>  void in(T &head) { cin >> head; }template<class T, class... U>  void in(T &head, U &... tail) {cin >> head;in(tail...);}\n\n#define o_din(o1, o2, o3, o4, name, ...) name\n#define din1(a) int a;cin>>a\n#define din2(a, b) int a,b;cin>>a>> b\n#define din3(a, b, c) int a,b,c;cin>>a>>b>>c\n#define din4(a, b, c, d) int a,b,c,d;cin>>a>>b>>c>>d\n#define din(...) o_din(__VA_ARGS__,din4,din3,din2 ,din1)(__VA_ARGS__)\n\n#define o_dind(o1, o2, o3, o4, name, ...) name\n#define din1d(a) din1(a);a--\n#define din2d(a, b) din2(a,b);a--,b--\n#define din3d(a, b, c) din3(a,b,c);a--,b--,c--\n#define din4d(a, b, c, d) din4(a,b,c,d);a--,b--,c--,d--\n#define dind(...) o_dind(__VA_ARGS__,din4d,din3d,din2d ,din1d)(__VA_ARGS__)\n\n\n#define o_out(o1, o2, o3, o4, name, ...) name\n#define out1(a) cout<<a<<endl\n#define out2(a, b) cout<<a<<\" \"<< b<<endl\n#define out3(a, b, c) cout<<a<<\" \"<<b<<\" \"<<c<<endl\n#define out4(a, b, c, d) cout<<a<<\" \"<<b<<\" \"<<c<<\" \"<<d<<endl\n#define out(...) o_out((__VA_ARGS__),out4,out3,out2,out1)((__VA_ARGS__))\n\ntemplate<class T> void outl(vector<T> &a) { fora(v, a)cout << v << endl; }\ntemplate<class T> void na(vector<T> &a, int n) {a.resize(n);rep(i, n)cin >> a[i];}\n#define dna(a, n) vi a(n); rep(dnai,n) cin >> a[dnai];\ntemplate<class T> void nao(vector<T> &a, int n) {    a.resize(n + 1);    a[0] = 0;    rep(i, n)cin >> a[i + 1];}\ntemplate<class T> void nad(vector<T> &a, int n) {    a.resize(n);    rep(i, n)cin >> a[i], a[i]--;}\ntemplate<class T, class U> void na2(vector<T> &a, vector<U> &b, int n) {    a.resize(n);    b.resize(n);    rep(i, n)cin >> a[i] >> b[i];}\n#define dna2(a, b, n) vi a(n),b(n);rep(dna2i, n)cin >> a[dna2i] >> b[dna2i];\ntemplate<class T, class U> void nao2(vector<T> &a, vector<U> &b, int n) {    a.resize(n + 1);    b.resize(n + 1);    a[0] = b[0] = 0;    rep(i, n)cin >> a[i + 1] >> b[i + 1];}\n#define dna2d(a, b, n) vi a(n),b(n);rep(dna2di, n){cin >> a[dna2di] >> b[dna2di];a[dna2di]--,b[dna2di]--;}\ntemplate<class T, class U> void na2d(vector<T> &a, vector<U> &b, int n) {    a.resize(n);    b.resize(n);    rep(i, n)cin >> a[i] >> b[i], a[i]--, b[i]--;}\ntemplate<class T, class U, class W> void na3(vector<T> &a, vector<U> &b, vector<W> &c, int n) {    a.resize(n);    b.resize(n);    c.resize(n);    rep(i, n)cin >> a[i] >> b[i] >> c[i];}\n#define dna3(a, b, c, n) vi a(n),b(n),c(n);   rep(dna3i, n)cin >> a[dna3i] >> b[dna3i] >> c[dna3i];\ntemplate<class T, class U, class W> void na3d(vector<T> &a, vector<U> &b, vector<W> &c, int n) {    a.resize(n);    b.resize(n);    c.resize(n);    rep(i, n)cin >> a[i] >> b[i] >> c[i], a[i]--, b[i]--, c[i]--;}\n#define dna3d(a, b, c, n) vi a(n),b(n),c(n);  rep(dna3di, n){cin >> a[dna3di] >> b[dna3di] >> c[dna3di];a[dna3di]--,b[dna3di]--,c[dna3di]--;}\n#define nt(a, h, w) resize(a,h,w);rep(nthi,h)rep(ntwi,w) cin >> a[nthi][ntwi];\n#define ntd(a, h, w) resize(a,h,w);rep(ntdhi,h)rep(ntdwi,w) cin >> a[ntdhi][ntdwi], a[ntdhi][ntdwi]--;\n#define ntp(a, h, w) resize(a,h+2,w+2);fill(a,'#');rep(ntphi,1,h+1)rep(ntpwi,1,w+1) cin >> a[ntphi][ntpwi];\n//デバッグ\n#define sp << \" \" <<\n\n#define debugName(VariableName) # VariableName\n\n#define deb1(x)  debugName(x)<<\" = \"<<x\n#define deb2(x, ...) deb1(x) <<\", \"<< deb1(__VA_ARGS__)\n#define deb3(x, ...) deb1(x) <<\", \"<< deb2(__VA_ARGS__)\n#define deb4(x, ...) deb1(x) <<\", \"<< deb3(__VA_ARGS__)\n#define deb5(x, ...) deb1(x) <<\", \"<< deb4(__VA_ARGS__)\n#define deb6(x, ...) deb1(x) <<\", \"<< deb5(__VA_ARGS__)\n#define deb7(x, ...) deb1(x) <<\", \"<< deb6(__VA_ARGS__)\n#define deb8(x, ...) deb1(x) <<\", \"<< deb7(__VA_ARGS__)\n#define deb9(x, ...) deb1(x) <<\", \"<< deb8(__VA_ARGS__)\n#define deb10(x, ...) deb1(x) <<\", \"<< deb9(__VA_ARGS__)\n\n#define o_ebug(o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, name, ...) name\n\n#ifdef _DEBUG\n#define deb(...)  cerr<< o_ebug(__VA_ARGS__,deb10,deb9,deb8,deb7,deb6,deb5,deb4,deb3,deb2,deb1)(__VA_ARGS__) <<endl\n#else\n#define deb(...) ;\n#endif\n\n#define debugline(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n'\n\n//よく使うクラス、構造体\nclass UnionFind {\npublic:\n    vi par, rank, sizes;\n    int n, trees;\n    UnionFind(int n) : n(n), trees(n) {\n        par.resize(n), rank.resize(n), sizes.resize(n);\n        rep(i, n)par[i] = i, sizes[i] = 1;\n    }\n    int root(int x) {\n        if (par[x] == x)return x;\n        else return par[x] = root(par[x]);\n    }\n    int find(int x) { return root(x); }\n    void unite(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y)return;\n        if (rank[x] < rank[y])swap(x, y);\n        trees--;\n        par[y] = x;\n        sizes[x] += sizes[y];\n        if (rank[x] == rank[y])rank[x]++;\n    }\n    bool same(int x, int y) { return root(x) == root(y); }\n    int size(int x) { return sizes[root(x)]; }\n    //順不同 umapなので\n    V<vi> sets() {\n        vvi(res,trees);\n        umap<int, vi> map;\n        rep(i, n) map[root(i)].push_back(i);\n        int i = 0;\n        for (auto &&p:map) {\n            int r = p.fi;\n            res[i].push_back(r);\n            for (auto &&v:p.se) {\n                if (r == v)continue;\n                res[i].push_back(v);\n            }\n            i++;\n        }\n        return res;\n    }\n};\n\nusing bint =__int128;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing u128 = __uint128_t;\n\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {    std::ostream::sentry s(dest);    if (s) {        __uint128_t tmp = value < 0 ? -value : value;        char buffer[128];        char *d = std::end(buffer);        do {            --d;            *d = \"0123456789\"[tmp % 10];            tmp /= 10;        } while (tmp != 0);        if (value < 0) {            --d;            *d = '-';        }        int len = std::end(buffer) - d;        if (dest.rdbuf()->sputn(d, len) != len) {            dest.setstate(std::ios_base::badbit);        }    }    return dest;}\n//__int128 toi128(string &s) {    __int128 ret = 0;    for (int i = 0; i < s.length(); i++)        if ('0' <= s[i] && s[i] <= '9')            ret = 10 * ret + s[i] - '0';    return ret;}\n\n\n//エラー\nvoid ole() {\n#ifdef _DEBUG\n    debugline(\"ole\");exit(0);\n#endif\n    string a = \"a\";rep(i, 30)a += a;rep(i, 1 << 17)cout << a << endl;cout << \"OLE 出力長制限超過\" << endl;exit(0);\n}\nvoid re() { assert(0 == 1);exit(0); }\nvoid tle() { while (inf)cout << inf << endl; }\n\n//便利関数\n\n//テスト用\nchar ranc() {return (char) ('a' + rand() % 26);}\nint rand(int min, int max) {    assert(min <= max);    if (min >= 0 && max >= 0) {        return rand() % (max + 1 - min) + min;    } else if (max < 0) {        return -rand(-max, -min);    } else {        if (rand() % 2) {            return rand(0, max);        } else {            return -rand(0, -min);        }    }}\nvi ranv(int n, int min, int max) {    vi v(n);    rep(i, n)v[i] = rand(min, max);    return v;}\nstr ransu(int n) {    str s;    rep(i, n)s += (char) rand('A', 'Z');    return s;}\nstr ransl(int n) {    str s;    rep(i, n)s += (char) rand('a', 'z');    return s;}\n//単調増加\nvi ranvinc(int n, int min, int max) {    vi v(n);    bool bad = 1;    while (bad) {        bad = 0;        v.resize(n);        rep(i, n) {            if (i && min > max - v[i - 1]) {                bad = 1;                break;            }            if (i)v[i] = v[i - 1] + rand(min, max - v[i - 1]);            else v[i] = rand(min, max);        }    }    return v;}\n//便利 汎用\nvoid ranvlr(int n, int min, int max, vi &l, vi &r) {    l.resize(n);    r.resize(n);    rep(i, n) {        l[i] = rand(min, max);        r[i] = l[i] + rand(0, max - l[i]);    }}\nvp run_length(vi &a) {    vp ret;    ret.eb(a[0], 1);    rep(i, 1, sz(a)) {        if (ret.back().fi == a[i]) {            ret.back().se++;        } else {            ret.eb(a[i], 1);        }    }    return ret;}\nvector<pair<char, int>> run_length(string &a) {    vector<pair<char, int>> ret;    ret.eb(a[0], 1);    rep(i, 1, sz(a)) {        if (ret.back().fi == a[i]) {            ret.back().se++;        } else {            ret.eb(a[i], 1);        }    }    return ret;}\ntemplate<class F>  int mgr(int ok, int ng, F f) {if (ok < ng)while (ng - ok > 1) { int mid = (ok + ng) / 2; if (f(mid))ok = mid; else ng = mid; } else while (ok - ng > 1) { int mid = (ok + ng) / 2; if (f(mid))ok = mid; else ng = mid; }return ok;}\n//strを整数として比較\nstring smax(str &a, str b) {    if (sz(a) < sz(b)) {        return b;    } else if (sz(a) > sz(b)) {        return a;    } else {        rep(i, sz(a)) {            if (a[i] < b[i]) {                return b;            } else if (a[i] > b[i])return a;        }    }    return a;}\n//strを整数として比較\nstring smin(str &a, str b) {    if (sz(a) < sz(b)) {        return a;    } else if (sz(a) > sz(b)) {        return b;    } else {        rep(i, sz(a)) {            if (a[i] < b[i]) {                return a;            } else if (a[i] > b[i])return b;        }    }    return a;}\ntemplate<typename W, typename T> int find(vector<W> &a,const T key) {rep(i, sz(a))if (a[i] == key)return i;return -1;}\ntemplate<typename W, typename T> P find(vector<vector<W >> &a,const T key) {rep(i, sz(a))rep(j, sz(a[0]))if (a[i][j] == key)return mp(i, j);return mp(-1, -1);}\ntemplate<typename W, typename U> T find(vector<vector<vector<W >>> &a,const U key) {rep(i, sz(a))rep(j, sz(a[0]))rep(k, sz(a[0][0]))if (a[i][j][k] == key)return mt(i, j, k);return mt(-1, -1, -1);}\n\n\ntemplate<typename W, typename T> int count2(W &a, const T k) { return a == k; }\ntemplate<typename W, typename T> int count2(vector<W> &a, const T k) {int ret = 0;fora(v, a)ret +=count(v, k);return ret;}\ntemplate<typename W, typename T> int count(vector<W> &a, const T k) {int ret = 0;fora(v, a)ret +=count2(v, k);return ret;}\nint count(str& a, str k) {int ret = 0, len = k.length();auto pos = a.find(k);while (pos != string::npos)pos = a.find(k, pos + len), ret++;return ret;}\nvi count(str& a){    vi cou(26);    char c='a';    if('A' <= a[0] && a[0]<='Z')c='A';    rep(i,sz(a))cou[a[i]-c]++;    return cou;}\n#define couif count_if\n//algorythm\n\n\ninline ll rev(ll a) {ll res = 0;while (a) {res *= 10;res += a % 10;a /= 10;}return res;}\ntemplate<class T> void rev(vector<T> &a) {reverse(all(a));}\ntemplate<class T> vector<T> revv(vector<T> &a) {vector<T> b = a;reverse(all(b));return b;}\nvoid inline rev(string &a) {reverse(all(a));}\nconstexpr int p10[] = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000, 10000000000ll, 100000000000ll, 1000000000000ll, 10000000000000ll, 100000000000000ll, 1000000000000000ll, 10000000000000000ll, 100000000000000000ll, 1000000000000000000ll};\n\nint get(int a, int keta) { return (a / (int) pow(10, keta)) % 10; }\nint keta(ll v) { if (v < p10[9]) { if (v < p10[4]) { if (v < p10[2]) { if (v < p10[1]) return 1; else return 2; } else { if (v < p10[3]) return 3; else return 4; }} else { if (v < p10[7]) { if (v < p10[5]) return 5; else if (v < p10[6])return 6; else return 7; } else { if (v < p10[8])return 8; else return 9; }}} else { if (v < p10[13]) { if (v < p10[11]) { if (v < p10[10]) return 10; else return 11; } else { if (v < p10[12]) return 12; else return 13; }} else { if (v < p10[15]) { if (v < p10[14]) return 14; else if (v < p10[15])return 15; else return 16; } else { if (v < p10[17])return 17; else return 18; }}}}\nint dsum(int v) {int ret = 0;for (; v; v /= 10)ret += v % 10;return ret;}\n\nstruct sint {\n    int v;\n    sint(int v) : v(v) {}\n    operator int() { return v; }\n    //下からi番目\n    int operator[](int i) { return (v / p10[i]) % 10; }\n    int back(int i) {        return operator[](i);    }\n    //上からi番目\n    int top(int i) {        int len = keta(v);        return operator[](len - 1 - i);    }\n    //先頭からi番目にセット\n    int settop(int i, int k) {        int len = keta(v);        return set(len - 1 - i, k);    }\n    int set(int i, int k) {        if (i < 0)return settop(abs(i) - 1, k);        return v += p10[i] * (k - (v / p10[i]) % 10);    }\n    int add(int i, int k = 1) {        return v += p10[i] * k;    }\n    int addtop(int i, int k = 1) {        return v += p10[keta(v) - i - 1] * k;    }\n    int dec(int i, int k = 1) {        return v -= p10[i] * k;    }\n    int dectop(int i, int k = 1) {        return v -= p10[keta(v) - i - 1] * k;    }\n#define op(t, o)template<class T>inline t operator o(T r){return v o r;}\n    op(int, +=);op(int, -=);op(int, *=);op(int, /=);op(int, %=);\n    op(int, +);op(int, -);op(int, *);op(int, /);op(int, %);\n    op(bool, ==);op(bool, !=);op(bool, <);op(bool, <=);op(bool, >);op(bool, >=);\n#undef op\n    template<class T> inline int operator<<=(T r) { return v *= p10[r]; }\n    template<class T> inline int operator<<(T r) { return v * p10[r]; }\n    template<class T> inline int operator>>=(T r) { return v /= p10[r]; }\n    template<class T> inline int operator>>(T r) { return v / p10[r]; }\n};\nint mask10(int v) { return p10[v] - 1; }\n//変換系\ntemplate<class T> auto keys(T a) {vector<decltype((a.begin())->fi)> res;for (auto &&k :a)res.push_back(k.fi);return res;}\ntemplate<class T> auto values(T a) {vector<decltype((a.begin())->se)> res;for (auto &&k :a)res.push_back(k.se);return res;}\ntemplate<class T, class U> inline bool chma(T &a, const U &b) {    if (a < b) {        a = b;        return true;    }    return false;}\ntemplate<class U> inline bool chma(const U &b) { return chma(ma, b); }\ntemplate<class T, class U> inline bool chmi(T &a, const U &b) {    if (b < a) {        a = b;        return true;    }    return false;}\ntemplate<class U> inline bool chmi(const U &b) { return chmi(mi, b); }\ntemplate<class T> inline T min(T a, signed b) { return a < b ? a : b; }\ntemplate<class T> inline T max(T a, signed b) { return a < b ? b : a; }\ntemplate<class T> inline T min(T a, T b, T c) { return a >= b ? b >= c ? c : b : a >= c ? c : a; }\ntemplate<class T> inline T max(T a, T b, T c) { return a <= b ? b <= c ? c : b : a <= c ? c : a; }\ntemplate<class T> inline T min(vector<T> a) { return *min_element(all(a)); }\ntemplate<class T> inline T mini(vector<T> a) { return min_element(all(a)) - a.begin(); }\ntemplate<class T> inline T min(vector<T> a, int n) { return *min_element(a.begin(), a.begin() + min(n, sz(a))); }\ntemplate<class T> inline T min(vector<T> a, int s, int n) { return *min_element(a.begin() + s, a.begin() + min(n, sz(a))); }\ntemplate<class T> inline T max(vector<T> a) { return *max_element(all(a)); }\ntemplate<class T> inline T maxi(vector<T> a) { return max_element(all(a)) - a.begin(); }\ntemplate<class T> inline T max(vector<T> a, int n) { return *max_element(a.begin(), a.begin() + min(n, sz(a))); }\ntemplate<class T> inline T max(vector<T> a, int s, int n) { return *max_element(a.begin() + s, a.begin() + min(n, sz(a))); }\ntemplate<typename A, size_t N> inline A max(A (&a)[N]) {    A res = a[0];    rep(i, N)res = max(res, a[i]);    return res;}template<typename A, size_t N, size_t O> inline A max(A (&a)[N][O]) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P> inline A max(A (&a)[N][O][P]) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q> inline A max(A (&a)[N][O][P][Q], const T &v) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R> inline A max(A (&a)[N][O][P][Q][R]) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S> inline A max(A (&a)[N][O][P][Q][R][S]) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}template<typename A, size_t N> inline A min(A (&a)[N]) {    A res = a[0];    rep(i, N)res = min(res, a[i]);    return res;}template<typename A, size_t N, size_t O> inline A min(A (&a)[N][O]) {    A res = min(a[0]);    rep(i, N)res = min(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P> inline A min(A (&a)[N][O][P]) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q> inline A min(A (&a)[N][O][P][Q], const T &v) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R> inline A min(A (&a)[N][O][P][Q][R]) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S> inline A min(A (&a)[N][O][P][Q][R][S]) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}\ntemplate<class T> T sum(vector<T> &v) {T ret = 0;rep(i, sz(v))ret += v[i];return ret;}\ntemplate<class T> T sum(vector<vector<T> > &v) {T ret = 0;rep(i, sz(v))ret += sum(v[i]);return ret;}\ntemplate<class T> T sum(vector<vector<vector<T> > > &v) {T ret = 0;rep(i, sz(v))ret += sum(v[i]);return ret;}\ntemplate<class T> T sum(vector<vector<vector<vector<T> > > > &v) {T ret = 0;rep(i, sz(v))ret += sum(v[i]);return ret;}\ntemplate<class T> T sum(vector<vector<vector<vector<vector<T> > > > > &v) {T ret = 0;rep(i, sz(v))ret += sum(v[i]);return ret;}\ntemplate<class T>  auto sum(priority_queue<T, vector<T>, greater<T> > &r) {auto q = r;T ret = 0;while (sz(q)) {ret += q.top();q.pop();}return ret;}\ntemplate<class T>  auto sum(priority_queue<T> &r) {    auto q = r;    T ret = 0;    while (sz(q)) {        ret += q.top();        q.pop();    }    return ret;}\ntemplate<class T, class U, class... W> inline auto sum(vector<T> &v, U head, W... tail) {    auto ret = sum(v[0], tail...);    rep(i, 1, min(sz(v), head))ret += sum(v[i], tail...);    return ret;}\nvoid clear(PQ &q) { q=PQ(); }\ntemplate<class T>  void clear(queue<T> &q) { while (q.size())q.pop(); }\ntemplate<class T>  T *negarr(int size) {    T *body = (T *) malloc((size * 2 + 1) * sizeof(T));    return body + size;}\ntemplate<class T>  T *negarr2(int h, int w) {    double **dummy1 = new double *[2 * h + 1];    double *dummy2 = new double[(2 * h + 1) * (2 * w + 1)];    dummy1[0] = dummy2 + w;    for (int i = 1; i <= 2 * h + 1; i++) {        dummy1[i] = dummy1[i - 1] + 2 * w + 1;    }    double **a = dummy1 + h;    return a;}\n//imoは0-indexed\n//ruiは1-indexed\ntemplate<class T> vector<T> imo(vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)ret[i + 1] += ret[i];    return ret;}\n//kと同じものの数\ntemplate<class T, class U>  vi imocou(vector<T> &a, U k) {    vector<T> ret = a;    rep(i, sz(ret) - 1)ret[i + 1] = ret[i] + (a[i] == k);    return    ret;}\ntemplate<class T>  vector<T> imox(vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)ret[i + 1] ^= ret[i];    return ret;}\n//漸化的に最小を持つ\ntemplate<class T>  vector<T> imi(vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)chmi(ret[i + 1], ret[i]);    return ret;}\ntemplate<class T> struct ruiC {    const vector<T> rui;    ruiC(vector<T> &ru) : rui(ru) {}    inline T operator()(int l, int r) {        assert(l <= r);        return rui[r] - rui[l];    }    inline T operator[](int i) {        return rui[i];    }};\ntemplate<class T> struct rruic {    const T *rrui;    rruic(T *ru) : rrui(ru) {}    inline T operator()(int l, int r) {        assert(l >= r);        return rrui[r] - rrui[l];    }    inline T operator[](int i) { return rrui[i]; }};\ntemplate<class T>  vector<T> ruiv(vector<T> &a) {    vector<T> ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] + a[i];    return ret;}\ntemplate<class T>  ruiC<T> ruic(vector<T> &a) {    vector<T> ret = ruiv(a);    return ruiC<T>(ret);}\n//kと同じものの数\ntemplate<class T, class U>  vi ruiv(T &a, U k) {    vi ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] + (a[i] == k);    return ret;}\ntemplate<class T, class U>  ruiC<int> ruic(T &a, U k) {    vi ret = ruiv(a, k);    return ruiC<int>(ret);}\n\n//xor\ntemplate<class T>  vector<T> ruix(vector<T> &a) {    vector<T> ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] ^ a[i];    return ret;}\ntemplate<class T>  vector<T> ruim(vector<T> &a) {    vector<T> res(a.size() + 1, 1);    rep(i, a.size())res[i + 1] = res[i] * a[i];    return res;}\n//漸化的に最小を1indexで持つ\ntemplate<class T>  vector<T> ruimi(vector<T> &a) {    int n = sz(a);    vector<T> ret(n + 1);    rep(i, 1, n) {        ret[i] = a[i - 1];        chmi(ret[i + 1], ret[i]);    }    return ret;}\n//template<class T> T *rrui(vector<T> &a) {\n//右から左にかけての半開区間 (-1 n-1]\ntemplate<class T> rruic<T> rrui(vector<T> &a) {    int len = a.size();    T *body = (T *) malloc((len + 1) * sizeof(T));    T *res = body + 1;    rer(i, len - 1)res[i - 1] = res[i] + a[i];    return rruic<T>(res);}\n//掛け算\ntemplate<class T> T *rruim(vector<T> &a) {    int len = a.size();    T *body = (T *) malloc((len + 1) * sizeof(T));    T *res = body + 1;    res[len - 1] = 1;    rer(i, len - 1)res[i - 1] = res[i] * a[i];    return res;}\ntemplate<class T, class U> void inc(T &a, U v = 1) { a += v; }\ntemplate<class T, class U> void inc(vector<T> &a, U v = 1) { for (auto &u:a)inc(u, v); }\ntemplate<class T, class U> void dec(T &a, U v = 1) { a -= v; }\ntemplate<class T, class U> void dec(vector<T> &a, U v = 1) { for (auto &u :a)dec(u, v); }\ntemplate<class U> void dec(string &a, U v = 1) { for (auto &u :a)dec(u, v); }\ntemplate<class T> void dec(vector<T> &a) { for (auto &u :a)dec(u, 1); }\ntemplate<class T, class U> void minu(T &a, U v = 1) { a -= v; }\ntemplate<class T, class U> void minu(vector<T> &a, U v = 1) { for (auto &u:a)dec(u, v); }\ntemplate<class T> void minu(vector<T> &a) { for (auto &u :a)dec(u, 1); }\ntemplate<class U> void minu(string &a, U v = 1) { for (auto &u :a)dec(u, v); }\nvoid minu(string &a) { for (auto &u :a)dec(u, 1); }\nbool inside(int h, int w, int H, int W) { return h >= 0 && w >= 0 && h < H && w < W; }\nbool inside(int l, int v, int r) { return l <= v && v < r; }\ntemplate<class T>bool inside(vector<T>& a,int i,int j=0){return inside(0,i,sz(a)) &&inside(0,j,sz(a));}\n#define ins inside\nll u(ll a) { return a < 0 ? 0 : a; }\ntemplate<class T> vector<T> u(const vector<T> &a) {vector<T> ret = a;fora(v, ret)v = u(v);return ret;}\n#define MIN(a) numeric_limits<a>::min()\n#define MAX(a) numeric_limits<a>::max()\nll goldd(ll left, ll right, function<ll(ll)> calc) {    double GRATIO = 1.6180339887498948482045868343656;    ll lm = left + (ll) ((right - left) / (GRATIO + 1.0));    ll rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));    ll fl = calc(lm);    ll fr = calc(rm);    while (right - left > 10) {        if (fl < fr) {            right = rm;            rm = lm;            fr = fl;            lm = left + (ll) ((right - left) / (GRATIO + 1.0));            fl = calc(lm);        } else {            left = lm;            lm = rm;            fl = fr;            rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));            fr = calc(rm);        }    }    ll minScore = MAX(ll);    ll resIndex = left;    for (ll i = left; i < right + 1; i++) {        ll score = calc(i);        if (minScore > score) {            minScore = score;            resIndex = i;        }    }    return resIndex;}\nll goldt(ll left, ll right, function<ll(ll)> calc) {    double GRATIO = 1.6180339887498948482045868343656;    ll lm = left + (ll) ((right - left) / (GRATIO + 1.0));    ll rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));    ll fl = calc(lm);    ll fr = calc(rm);    while (right - left > 10) {        if (fl > fr) {            right = rm;            rm = lm;            fr = fl;            lm = left + (ll) ((right - left) / (GRATIO + 1.0));            fl = calc(lm);        } else {            left = lm;            lm = rm;            fl = fr;            rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));            fr = calc(rm);        }    }    if (left > right) {        ll l = left;        left = right;        right = l;    }    ll maxScore = MIN(ll);    ll resIndex = left;    for (ll i = left; i < right + 1; i++) {        ll score = calc(i);        if (maxScore < score) {            maxScore = score;            resIndex = i;        }    }    return resIndex;}\ntemplate<class T> T min(vector<vector<T >> &a) {T res = MAX(T);rep(i, a.size())chmi(res, *min_element(all(a[i])));return res;}\ntemplate<class T> T max(vector<vector<T >> &a) {T res = MIN(T);rep(i, a.size())chma(res, *max_element(all(a[i])));return res;}\n\nconstexpr bool bget(ll m, int keta) {return (m >> keta) & 1;}\nint bget(ll m, int keta, int sinsuu) {m /= (ll) pow(sinsuu, keta);return m % sinsuu;}\nll bit(int n) { return (1LL << (n)); }\nll bit(int n, int sinsuu) { return (ll) pow(sinsuu, n); }\nint mask(int n) { return (1ll << n) - 1; }\n#define bcou __builtin_popcountll\n//最下位ビット\nint lbit(int n) {return n & -n;}\n//最上位ビット\nint hbit(int n) {n |= (n >> 1);n |= (n >> 2);n |= (n >> 4);n |= (n >> 8);n |= (n >> 16);n |= (n >> 32);return n - (n >> 1);}\nint hbitk(int n) {int k = 0;rer(i, 5) {int a = k + (1ll << i);int b = 1ll << a;if (b <= n)k += 1ll << i;}return k;}\n//初期化は0を渡す\nll nextComb(ll &mask, int n, int r) {    if (!mask)return mask = (1LL << r) - 1;    ll x = mask & -mask; /*最下位の1*/    ll y = mask + x; /*連続した下の1を繰り上がらせる*/    ll res = ((mask & ~y) / x >> 1) | y;    if (bget(res, n))return mask = 0;    else return mask = res;}\n//n桁以下でビットがr個立っているもののvectorを返す\nvi bitCombList(int n, int r) {vi res;int m = 0;while (nextComb(m, n, r)) {res.push_back(m);}return res;}\nchar itoal(int i) {    return 'a' + i;}\nchar itoaL(int i) {    return 'A' + i;}\nint altoi(char c) {    if ('A' <= c && c <= 'Z')return c - 'A';    return c - 'a';}\nint ctoi(char c) { return c - '0'; }\nchar itoc(int i) { return i + '0'; }\nint vtoi(vi &v) {    int res = 0;    if (sz(v) > 18) {        debugline(\"vtoi\");        deb(sz(v));        ole();    }    rep(i, sz(v)) {        res *= 10;        res += v[i];    }    return res;}\nvi itov(int i) {    vi res;    while (i) {        res.push_back(i % 10);        i /= 10;    }    rev(res);    return res;}\nvi stov(string &a) {    int n = sz(a);    vi ret(n);    rep(i, n) {        ret[i] = a[i] - '0';    }    return ret;}\n//基準を満たさないものは0になる\nvi stov(string &a,char one) {    int n=sz(a);    vi ret (n);    rep(i,n)ret[i]=a[i]==one;    return ret;}\nvector<vector<int>> ctoi(vector<vector<char>> s, char c) {    int n = sz(s), m = sz(s[0]);    vector<vector<int>> res(n, vector<int>(m));    rep(i, n)rep(j, m)res[i][j] = s[i][j] == c;    return res;}\n#define unique(v) v.erase( unique(v.begin(), v.end()), v.end() );\n//[i] := i番として圧縮されたものを返す\nvi compress(vi &a) {    vi b;    int len = a.size();    for (int i = 0; i < len; ++i) {        b.push_back(a[i]);    }    sort(b);    unique(b);    for (int i = 0; i < len; ++i) {        a[i] = lower_bound(all(b), a[i]) - b.begin();    }    int blen = sz(b);    vi ret(blen);    rep(i, blen) {        ret[i] = b[i];    }    return ret;}\nvi compress(vi &a, umap<int, int> &map) {    vi b;    int len = a.size();    for (int i = 0; i < len; ++i) {        b.push_back(a[i]);    }    sort(b);    unique(b);    for (int i = 0; i < len; ++i) {        int v = a[i];        a[i] = lower_bound(all(b), a[i]) - b.begin();        map[v] = a[i];    }    int blen = sz(b);    vi ret(blen);    rep(i, blen) {        ret[i] = b[i];    }    return ret;}\nvi compress(vi &a, vi &r) {    vi b;    int len = a.size();    fora(v, a)b.push_back(v);    fora(v, r)b.push_back(v);    sort(b);    unique(b);    for (int i = 0; i < len; ++i) a[i] = lower_bound(all(b), a[i]) - b.begin();    for (int i = 0; i < sz(r); ++i) r[i] = lower_bound(all(b), r[i]) - b.begin();    int blen = sz(b);    vi ret(blen);    rep(i, blen) {        ret[i] = b[i];    }    return ret;}\nvi compress(vi &a, vi &r, vi &s) {    vi b;    int len = a.size();    fora(v, a)b.push_back(v);    fora(v, r)b.push_back(v);    fora(v, s)b.push_back(v);    sort(b);    unique(b);    for (int i = 0; i < len; ++i) a[i] = lower_bound(all(b), a[i]) - b.begin();    for (int i = 0; i < sz(r); ++i) r[i] = lower_bound(all(b), r[i]) - b.begin();    for (int i = 0; i < sz(s); ++i) r[i] = lower_bound(all(b), s[i]) - b.begin();    int blen = sz(b);    vi ret(blen);    rep(i, blen) {        ret[i] = b[i];    }    return ret;}\nvi compress(V<vi> &a) {    vi b;    fora(vv, a)fora(v, vv)b.push_back(v);    sort(b);    unique(b);    fora(vv, a)fora(v, vv)v = lower_bound(all(b), v) - b.begin();    int blen = sz(b);    vi ret(blen);    rep(i, blen) {        ret[i] = b[i];    }    return ret;}\nvi compress(vector<vector<vi >> &a) {    vi b;    fora(vvv, a)fora(vv, vvv)fora(v, vv)b.push_back(v);    sort(b);    unique(b);    fora(vvv, a)fora(vv, vvv)fora(v, vv)v = lower_bound(all(b), v) - b.begin();    int blen = sz(b);    vi ret(blen);    rep(i, blen) {        ret[i] = b[i];    }    return ret;}\nvoid compress(int a[], int len) {    vi b;    for (int i = 0; i < len; ++i) {        b.push_back(a[i]);    }    sort(b);    unique(b);    for (int i = 0; i < len; ++i) {        a[i] = lower_bound(all(b), a[i]) - b.begin();    }}\n//要素が見つからなかったときに困る\n#define binarySearch(a, v) (binary_search(all(a),v))\n#define lowerIndex(a, v) (lower_bound(all(a),v)-a.begin())\n#define lowerBound(a, v) (*lower_bound(all(a),v))\n#define upperIndex(a, v) (upper_bound(all(a),v)-a.begin())\n#define upperBound(a, v) (*upper_bound(all(a),v))\ntemplate<class T>  void fin(T s) { cout << s << endl, exit(0); }\n\n//便利 数学 math\nint mod(int a, int m) { return (a % m + m) % m; }\nint pow(int a) { return a * a; };\nll fact(int v) { return v <= 1 ? 1 : v * fact(v - 1); }\n\nll comi(int n, int r) {    assert(n < 100);    static vvi(pas, 100, 100);    if (pas[0][0])return pas[n][r];    pas[0][0] = 1;    rep(i, 1, 100) {        pas[i][0] = 1;        rep(j, 1, i + 1)pas[i][j] = pas[i - 1][j - 1] + pas[i - 1][j];    }    return pas[n][r];}\ndouble comd(int n, int r) {    static vd fac;    if (sz(fac) < n + 1) {        if (sz(fac) == 0)fac.push_back(1);        rep(i, sz(fac) - 1, n) {            fac.push_back(fac.back() * (i + 1));        }    }    if (n < r || n <= 0)return 0;    return fac[n] / fac[n - r] / fac[r];}\nint gcd(int a, int b) {    while (b) a %= b, swap(a, b);    return abs(a);}\nint gcd(vi b) {    ll res = b[0];    rep(i, 1, sz(b))res = gcd(b[i], res);    return res;}\nll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\nll lcm(vi a) {    int res = a[0];    rep(i, 1, sz(a))res = lcm(a[i], res);    return res;}\nll ceil(ll a, ll b) {    if (b == 0) {        debugline(\"ceil\");        deb(a, b);        ole();        return -1;    } else if (a < 0) {        return 0;    } else {return (a + b - 1) / b;}}\n\n//v * v >= aとなる最小のvを返す\nll sqrt(ll a) {if (a < 0) {debugline(\"sqrt\");deb(a);ole();}ll res = (ll) std::sqrt(a);while (res * res < a)res++;return res;}\ndouble log(double e, double x) { return log(x) / log(e); }\nll sig(ll t) { return (1 + t) * t / 2; }\nll sig(ll s, ll t) { return (s + t) * (t - s + 1) / 2; }\n\n\n//幾何 Pをcomplexとして扱う\ntemplate<class T, class U> bool eq(T a, U b) { return fabs(a - b) < eps; }\ndou atan2(pd a) { return atan2(a.se, a.fi); }\ndou angle(pd f, pd t) { return atan2(t.se - f.se, t.fi - f.fi); }\ndou distance(pd a, pd b) { return hypot(a.fi - b.fi, a.se - b.se); }\n//bを中心とするabcのtheta aからcにかけて時計回り\ndou angle(pd a, pd b, pd c) {    dou ax = a.fi - b.fi;    dou ay = a.se - b.se;    dou cx = c.fi - b.fi;    dou cy = c.se - b.se;    double ret = atan2(cy, cx) - atan2(ay, ax);    if (ret < 0) ret += 2 * PI;    return ret;}\ndou dot(pd a, pd b) { return a.fi * b.fi + a.se + b.se; }\ndou cro(pd a, pd b) { return a.fi * b.se - a.se + b.fi; }\n\n//機能拡張\ntemplate<class T, class U> void operator+=(queue<T> &a, U v) { a.push(v); }template<class T, class U> void operator+=(deque<T> &a, U v) { a.push_back(v); }template<class T, class U> priority_queue<T, vector<T>, greater<T> > &operator+=(priority_queue<T, vector<T>, greater<T> > &a, vector <U> &v) {    fora(d, v)a.push(d);    return a;}template<class T, class U> priority_queue<T, vector<T>, greater<T> > &operator+=(priority_queue<T, vector<T>, greater<T> > &a, U v) {    a.push(v);    return a;}template<class T, class U> priority_queue<T> &operator+=(priority_queue<T> &a, U v) {    a.push(v);    return a;}template<class T> set<T> &operator+=(set<T> &a, vector<T>  v) {fora(d,v)a.insert(d);return a;}template<class T, class U> set<T> &operator+=(set<T> &a, U v) {    a.insert(v);    return a;}template<class T, class U> set<T, greater<T>> &operator+=(set<T, greater<T>> &a, U v) {    a.insert(v);    return a;}template<class T, class U> vector<T> &operator+=(vector<T> &a, U v) {    a.push_back(v);    return a;}\ntemplate<class T, class U> vector<T> operator+(const vector <T> &a, U v) {vector<T> ret = a;ret += v;return ret;}\ntemplate<class T, class U> vector<T> operator+(U v, const vector <T> &a) {vector<T> ret = a;ret.insert(ret.begin(), v);return ret;}\ntemplate<class T> vector<T> operator+(vector<T> a, vector <T> b) {vector<T> ret;ret = a;fora(v, b)ret += v;return ret;}\ntemplate<class T> vector<T> &operator+=(vector<T> &a, vector <T> &b) {fora(v, b)a += v;return a;}\ntemplate<class T> vector<T> &operator-=(vector<T> &a, vector <T> &b) {if (sz(a) != sz(b)) {debugline(\"vector<T> operator-=\");deb(a);deb(b);exit(0);}rep(i, sz(a))a[i] -= b[i];return a;}\ntemplate<class T> vector<T> operator-(vector<T> &a, vector <T> &b) {if (sz(a) != sz(b)) {debugline(\"vector<T> operator-\");deb(a);deb(b);ole();}vector<T> res(sz(a));rep(i, sz(a))res[i] = a[i] - b[i];return res;}\ntemplate<class T,class U> vector<T> operator*(vector<T> &a, U b) {vector<T> ret;fora(v,a)ret+=v*b;return ret;}\ntemplate<class T,class U> vector<T> operator/(vector<T> &a, U b) {vector<T> ret;fora(v,a)ret+=v/b;return ret;}\ntemplate<class T,class U> vector<T> operator*=(vector<T> &a, U b) {fora(v,a)v*=b;return a;}\ntemplate<class T,class U> vector<T> operator/=(vector<T> &a, U b) {fora(v,a)v/=b;return a;}\ntemplate<typename T> void erase(vector<T> &v, unsigned int i) {v.erase(v.begin()+ i);}\ntemplate<typename T> void erase(vector<T> &v, unsigned int s,unsigned int e) {v.erase(v.begin()+ s, v.begin()+ e);}\ntemplate<class T, class U> void erase(map<T, U> &m, int okl, int ngr) {m.erase(m.lower_bound(okl), m.lower_bound(ngr));}\ntemplate<class T> void erase(set<T> &m, int okl, int ngr) {m.erase(m.lower_bound(okl), m.lower_bound(ngr));}\ntemplate<typename T> void erasen(vector<T> &v, unsigned int s,unsigned int n) {v.erase(v.begin()+ s, v.begin()+ s + n);}\ntemplate<typename T, typename U> void insert(vector<T> &v, unsigned int i,U t) {v.insert(v.begin()+ i, t);}\ntemplate<typename T, typename U> void push_front(vector<T> &v, U t) {v.insert(v.begin(), t);}\ntemplate<typename T, typename U> void insert(vector<T> &v, unsigned int i,vector<T> list) {for (auto &&va:list)v.insert(v.begin()+ i++, va);}\ntemplate<typename T> void insert(set<T> &v, vector<T> list) {for (auto &&va :list)v.insert(va);}\nvector<string> split(const string a, const char deli) {    string b = a + deli;    int l = 0, r = 0, n = b.size();    vector<string> res;    rep(i, n) {        if (b[i] == deli) {            r = i;            if (l < r)res.push_back(b.substr(l, r - l));            l = i + 1;        }    }    return res;}\nvector<string> split(const string a, const string deli) {    vector<string> res;    int kn = sz(deli);    std::string::size_type Pos(a.find(deli));    int l = 0;    while (Pos != std::string::npos) {        if (Pos - l)res.push_back(a.substr(l, Pos - l));        l = Pos + kn;        Pos = a.find(deli, Pos + kn);    }    if (sz(a) - l)res.push_back(a.substr(l, sz(a) - l));    return res;}\nvoid yn(bool a) {if (a)cout << \"yes\" << endl;    else cout << \"no\" << endl;}\nvoid Yn(bool a) {if (a)cout << \"Yes\" << endl;    else cout << \"No\" << endl;}\nvoid YN(bool a) {if (a)cout << \"YES\" << endl;    else cout << \"NO\" << endl;}\nvoid fyn(bool a) {if (a)cout << \"yes\" << endl;    else cout << \"no\" << endl;    exit(0);}\nvoid fYn(bool a) {if (a)cout << \"Yes\" << endl;    else cout << \"No\" << endl;    exit(0);}\nvoid fYN(bool a) {if (a)cout << \"YES\" << endl;    else cout << \"NO\" << endl;    exit(0);}\nvoid Possible(bool a) {if (a)cout << \"Possible\" << endl;    else cout << \"Impossible\" << endl;    exit(0);}\nvoid POSSIBLE(bool a) {if (a)cout << \"POSSIBLE\" << endl;    else cout << \"IMPOSSIBLE\" << endl;    exit(0);}\n//@起動時\nstruct initon {\n    initon() {\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.setf(ios::fixed);\n        cout.precision(16);\n        srand((unsigned) clock() + (unsigned) time(NULL));\n    };\n} __initon;\n\n//@formatter:on\n//gra mint pr\nint n, m, k, d, H, W, x, y, z, q;\nint cou;\nvi t, a, b, c;\n//vvi (s, 0, 0);\nvvc (ba, 0, 0);\nvp p;\nstr s;\n\n\ntemplate<class T> struct edge { int f, t; T c; int id; int type; edge(int f, int t, T c = 1, int id = -1, int ty = -1) : f(f), t(t), c(c), id(id), type(ty) {} bool operator<(const edge &b) const { return c < b.c; } bool operator>(const edge &b) const { return c > b.c; }};\n\ntemplate<class T> ostream &operator<<(ostream &os, edge<T> &e) {\n    os << e.f << \" \" << e.t << \" \" << e.c;\n    return os;\n}\ntemplate<typename T> class graph {\nprotected:\n    vector<bool> _used;\npublic :\n    vector<vector<edge<T>>> g;\n    vector<edge<T>> edges;\n    int n;\n    graph(int n) : n(n) { g.resize(n), _used.resize(n); }\n    void clear() { g.clear(), edges.clear(); }\n    void resize(int n) {\n        this->n = n;\n        g.resize(n);\n        _used.resize(n);\n    }\n    int size() { return g.size(); }\n    vector<edge<T> > &operator[](int i) { return g[i]; }\n    virtual void add(int f, int t, T c, int id, int ty) = 0;\n    virtual bool used(edge<T> &e) = 0;\n    virtual bool used(int id) = 0;\n    virtual void del(edge<T> &e) = 0;\n    virtual void del(int id) = 0;\n    virtual void set_edges() = 0;\n};\ntemplate<typename T =ll> class digraph : public graph<T> {\npublic:\n    using graph<T>::g;\n    using graph<T>::n;\n    using graph<T>::edges;\n    using graph<T>::_used;\n    int eid = 0;\n\n    digraph(int n) : graph<T>(n) {}\n    void add(int f, int t, T c = 1, int id = -1, int ty = -1) {\n        if (!(0 <= f && f < n && 0 <= t && t < n)) {\n            debugline(\"digraph add\");\n            deb(f, t, c, id, ty);\n            ole();\n        }\n        if (id == -1)id = eid++;\n        g[f].emplace_back(f, t, c, id, ty);\n        edges.emplace_back(f, t, c, id, ty);\n    }\n    bool used(edge<T> &e) { return _used[e.id]; }\n    bool used(int id) { return _used[id]; }\n    void del(edge<T> &e) { _used[e.id] = _used[e.id ^ 1] = 1; }\n    void del(int id) { _used[id] = _used[id ^ 1] = 1; }\n    void set_edges() {\n        if (sz(edges))return;\n        rep(i, n)fora(e, g[i])edges.push_back(e);\n    }\n};\ntemplate<class T=int> class undigraph : public graph<T> {\npublic:\n    using graph<T>::g;\n    using graph<T>::n;\n    using graph<T>::edges;\n    using graph<T>::_used;\n    int eid = 0;\n    undigraph(int n) : graph<T>(n) {\n    }\n    void add(int f, int t, T c = 1, int id = -1, int ty = -1) {\n        if (!(0 <= f && f < n && 0 <= t && t < n)) {\n            debugline(\"undigraph add\");\n            deb(f, t, c, id, ty);\n            ole();\n        }\n        if (id == -1)id = eid, eid += 2;\n        g[f].emplace_back(f, t, c, id, ty);\n        g[t].emplace_back(t, f, c, id + 1, ty);\n        edges.emplace_back(f, t, c, id, ty);\n        edges.emplace_back(t, f, c, id + 1, ty);\n    }\n    void add(edge<T> &e) {\n        int f = e.f, t = e.t, ty = e.type;\n        T c = e.c;\n        add(f, t, c, ty);\n    }\n    bool used(edge<T> &e) { return _used[e.id]; }\n    bool used(int id) { return _used[id]; }\n    void del(edge<T> &e) { _used[e.id] = _used[e.id ^ 1] = 1; }\n    void del(int id) { _used[id] = _used[id ^ 1] = 1; }\n    void set_edges() {\n        if (sz(edges))return;\n        rep(i, n)fora(e, g[i])edges.push_back(e);\n    }\n};\ntemplate<typename T> struct radixheap {\n    vector<pair<u64, T> > v[65];\n    u64 size, last;\n    radixheap() : size(0), last(0) {}\n    bool empty() const { return size == 0; }\n    inline int getbit(int a) { return a ? 64 - __builtin_clzll(a) : 0; }\n    void push(u64 key, const T &value) {\n        ++size;\n        v[getbit(key ^ last)].emplace_back(key, value);\n    }\n    pair<u64, T> pop() {\n        if (v[0].empty()) {\n            int idx = 1;\n            while (v[idx].empty()) ++idx;\n            last = min_element(begin(v[idx]), end(v[idx]))->first;\n            for (auto &p : v[idx]) v[getbit(p.first ^ last)].emplace_back(p);\n            v[idx].clear();\n        }\n        --size;\n        auto ret = v[0].back();\n        v[0].pop_back();\n        return ret;\n    }\n};\nvi dijkstra2(const graph<int> &g, int s, int cant_arrive = -1) {\n    if (!(0 <= s && s < g.n)) {\n        debugline(\"dijkstra\");\n        deb(s, g.n);\n        ole();\n    }\n    int initValue = MAX(int);\n    vi dis(g.n, initValue);\n    radixheap<int> q;\n    dis[s] = 0;\n    q.push(0, s);\n    while (!q.empty()) {\n        int nowc, i;\n        tie(nowc, i) = q.pop();\n        if (dis[i] != nowc)continue;\n        for (auto &&e  : g.g[i]) {\n            int to = e.t;\n            int c = nowc + e.c;\n            if (dis[to] > c) {\n                dis[to] = c;\n                q.push(dis[to], to);\n            }\n        }\n    }    /*基本、たどり着かないなら-1*/    if (cant_arrive == -1)for (auto &&d :dis) if (d == initValue)d = -1;\n    return dis;\n}\n\ntemplate<class T> vector<T> dijkstra(const graph<T> &g, int s, int cant_arrive = -1) {\n    if (!(0 <= s && s < g.n)) {\n        debugline(\"dijkstra\");\n        deb(s, g.n);\n        ole();\n    }\n    T initValue = MAX(T);\n    vector<T> dis(g.n, initValue);\n    priority_queue<pair<T, int>, vector<pair<T, int>>, greater<pair<T, int>>> q;\n    dis[s] = 0;\n    q.emplace(0, s);\n    while (q.size()) {\n        T nowc = q.top().fi;\n        int i = q.top().se;\n        q.pop();\n        if (dis[i] != nowc)continue;\n        for (auto &&e  : g.g[i]) {\n            int to = e.t;\n            T c = nowc + e.c;\n            if (dis[to] > c) {\n                dis[to] = c;\n                q.emplace(dis[to], to);\n            }\n        }\n    }    /*基本、たどり着かないなら-1*/    if (cant_arrive == -1)for (auto &&d :dis) if (d == initValue)d = -1;\n    return dis;\n}\ntemplate<class T> vector<vector<T>> warshall(const graph<T> &g, int cant_arrive = -1) {\n    int n = g.n;\n    vector<vector<T> > dis(n, vector<T>(n, linf));\n    rep(i, n)fora(e, g.g[i])chmi(dis[e.f][e.t], e.c);\n    rep(i, n)dis[i][i] = 0;\n    rep(k, n)rep(i, n)rep(j, n)chmi(dis[i][j], dis[i][k] + dis[k][j]);    /*基本、たどり着かないなら-1*/    if (cant_arrive == -1)rep(i, n)rep(j, n) if (dis[i][j] == linf)dis[i][j] = -1;\n    return dis;\n}\n\ntemplate<class T=int> class tree : public undigraph<T> {\npublic:\n    using undigraph<T>::g;\n    using undigraph<T>::n;\n    using undigraph<T>::edges;\n    using undigraph<T>::_used;\n    vi disv;\nprivate:\n    bool never = 1;\n    int root = -1;\n    vi dep;//到着した順の深さ\n    vi vis;//到着した順\n    vi first;//初めてiに到着した時\n    vector<int> bestt;//タイミングを持つ\n    int sn = 0;//seg木の底辺の長さ euler tourの長さ\n    void built() {\n        never = 0;\n        n = g.size();\n        //euler tour\n        disv.resize(n);\n        first.resize(n);\n        dep.resize(n * 2);\n        vis.resize(n * 2);\n        function<void(int, int, int, int &)> dfs = [&](int i, int p, int d, int &k) {\n            first[i] = k;\n            vis[k] = i;\n            dep[k++] = d;\n            forg(gi, g[i]) {\n                if (t == p)continue;\n                disv[t] = disv[i] + c;\n                dfs(t, i, d + 1, k);\n                vis[k] = i;\n                dep[k++] = d;\n            }\n        };\n        int k = 0;\n        dfs(root, -1, 0, k);\n        //rmq\n        sn = 1;\n        while (sn < n * 2)sn <<= 1;\n\n        bestt.resize((sn << 1) - 1);\n        rep(i, k)bestt[i + sn - 1] = i;//時間を持つ\n        rer(i, sn - 2) {\n            int lt = (i << 1) + 1, rt = (i << 1) + 2;\n            if (dep[bestt[lt]] < dep[bestt[rt]]) {\n                bestt[i] = bestt[lt];\n            } else {\n                bestt[i] = bestt[rt];\n            }\n        }\n    }\n    //最小の深さを持つタイミングが知りたい\n    inline int lca_rmq(int l, int r) {\n        int midv = inf;\n        int midi = -1;\n        l += sn - 1;\n        r += sn - 1;\n        while (l < r) {\n            //右なら、次に右上へ移動してしまうので\n            if (!(l & 1)) {\n                if (chmi(midv, dep[bestt[l]])) {\n                    midi = bestt[l];\n                }\n            }\n            //右なら、左を取らないと機会を逃す\n            if (!(r & 1)) {\n                if (chmi(midv, dep[bestt[r - 1]])) {\n                    midi = bestt[r - 1];\n                }\n            }\n            l >>= 1;\n            r = (r - 1) >> 1;\n        }\n        return vis[midi];\n    }\n\npublic:\n    tree(int n, int root = 0) : undigraph<T>(n), root(root) {}\n    bool leaf(int v) {\n        return sz(g[v]) == 1 && v != root;\n    }\n    int lca(int u, int v) {\n        if (never)built();\n        if (first[u] > first[v])swap(u, v);\n        return lca_rmq(first[u], first[v] + 1);\n    }\n    int dis(int u, int v) {\n        if (never) built();\n        if (first[u] > first[v])swap(u, v);\n        int p = lca_rmq(first[u], first[v] + 1);\n        return disv[u] + disv[v] - disv[p] * 2;\n    }\n\n};\n//辺によりメモリを大量消費\n// よってedgesを消している\n//頂点10^6でメモリを190MB(制限の8割)使う\n\n//軽量化のため、辺を持たないbig gridクラスがあってもいいかもしれない\n//\ntemplate<class T=int> class grid_k6 : public undigraph<T> {\npublic:\n    using undigraph<T>::g;\n    using undigraph<T>::n;\n    using undigraph<T>::edges;\n    using undigraph<T>::_used;\n    int H, W;\n    int eid = 0;\n    void add(int f, int t, T c = 1, int id = -1, int ty = -1) {\n        if (!(0 <= f && f < n && 0 <= t && t < n)) {\n            debugline(\"grid_k6 add\");\n            deb(f, t, c, id, ty);\n            ole();\n        }\n        g[f].emplace_back(f, t, c, eid++, ty);\n        g[t].emplace_back(t, f, c, eid++, ty);\n    }\n    int getid(int h, int w) {\n        if (!inside(h, w, H, W))return -1;\n        return W * h + w;\n    }\n    P get2(int id) {\n        return mp(id / W, id % W);\n    }\n    P operator()(int id) {\n        return get2(id);\n    }\n    int operator()(int h, int w) {\n        return getid(h, w);\n    }\n    grid_k6(int H, int W) : H(H), W(W), undigraph<T>(H * W) {\n        rep(h, H) {\n            rep(w, W) {\n                int f = getid(h, w);\n                if (w + 1 < W) add(f, getid(h, w + 1));\n                if (h + 1 < H)add(f, getid(h + 1, w));\n            }\n        }\n    }\n    grid_k6(vector<vector<char>> ba, char wall = '#') : H(sz(ba)), W(sz(ba[0])), undigraph<T>(sz(ba) * sz(ba[0])) {\n        rep(h, H) {\n            rep(w, W) {\n                if (ba[h][w] == wall)con;\n                int f = getid(h, w);\n                if (w + 1 < W && ba[h][w + 1] != wall) {\n                    add(f, getid(h, w + 1));\n                }\n                if (h + 1 < H && ba[h + 1][w] != wall) {\n                    add(f, getid(h + 1, w));\n                }\n            }\n        }\n    }\n    void add(int fh, int fw, int th, int tw) {\n        add(getid(fh, fw), getid(th, tw));\n    }\n    void set_edges() {\n        rep(i, n)fora(e, g[i])edges.push_back(e);\n    }\n};\n//左上から右下に移動できる\ntemplate<class T=int> class digrid_k6 : public digraph<T> {\npublic:\n    using digraph<T>::g;\n    using digraph<T>::n;\n    using digraph<T>::edges;\n    using digraph<T>::_used;\n    int H, W;\n    int eid = 0;\n    void add(int f, int t, T c = 1, int id = -1, int ty = -1) {\n        if (!(0 <= f && f < n && 0 <= t && t < n)) {\n            debugline(\"digrid_k6 add\");\n            deb(f, t, c, id, ty);\n            ole();\n        }\n        g[f].emplace_back(f, t, c, eid++, ty);\n    }\n    int getid(int h, int w) {\n        if (!inside(h, w, H, W))return -1;\n        return W * h + w;\n    }\n    P get2(int id) {\n        return mp(id / W, id % W);\n    }\n    P operator()(int id) {\n        return get2(id);\n    }\n    int operator()(int h, int w) {\n        return getid(h, w);\n    }\n    digrid_k6(int H, int W) : H(H), W(W), digraph<T>(H * W) {\n        rep(h, H) {\n            rep(w, W) {\n                int f = getid(h, w);\n                if (w + 1 < W) add(f, getid(h, w + 1));\n                if (h + 1 < H)add(f, getid(h + 1, w));\n            }\n        }\n    }\n    digrid_k6(vector<vector<char>> ba, char wall = '#') : H(sz(ba)), W(sz(ba[0])), digraph<T>(sz(ba) * sz(ba[0])) {\n        rep(h, H) {\n            rep(w, W) {\n                if (ba[h][w] == wall)con;\n                int f = getid(h, w);\n                if (w + 1 < W && ba[h][w + 1] != wall) {\n                    add(f, getid(h, w + 1));\n                }\n                if (h + 1 < H && ba[h + 1][w] != wall) {\n                    add(f, getid(h + 1, w));\n                }\n            }\n        }\n    }\n    void add(int fh, int fw, int th, int tw) {\n        add(getid(fh, fw), getid(th, tw));\n    }\n    void set_edges() {\n        rep(i, n)fora(e, g[i])edges.push_back(e);\n    }\n};\ntemplate<class T> bool nibu(const graph<T> &g) {\n    int size = 0;\n    rep(i, g.n)size += sz(g.g[i]);\n    if (size == 0)return true;\n\n    UnionFind uf(g.n * 2);\n    rep(i, g.n)fora(e, g.g[i])uf.unite(e.f, e.t + g.n), uf.unite(e.f + g.n, e.t);\n    rep(i, g.n)if (uf.same(i, i + g.n))return 0;\n    return 1;\n}\n//二部グラフを色分けした際の頂点数を返す\ntemplate<class T> vp nibug(graph<T> &g) {\n    vp cg;\n    if (!nibu(g)) {\n        debugline(\"nibu\");\n        ole();\n    }\n    int _n = g.size();\n    vb _was(_n);\n    queue<P> q;\n    rep(i, _n) {\n        if (_was[i])continue;\n        q.push(mp(i, 1));\n        _was[i] = 1;\n        int red = 0;\n        int coun = 0;\n        while (q.size()) {\n            int now = q.front().fi;\n            int col = q.front().se;\n            red += col;\n            coun++;\n            q.pop();\n            forg(gi, g[now]) {\n                if (_was[t])continue;\n                q.push(mp(t, col ^ 1));\n                _was[t] = 1;\n            }\n        }\n        cg.push_back(mp(red, coun - red));\n    }\n    return cg;\n\n}\ntemplate<class T> ostream &operator<<(ostream &os, graph<T> &g) {\n    rep(i, sz(g)) {\n        forg(gi, g[i]) {\n            os << f << \" \" << t << \" \" << c << endl;\n        }\n    }\n    return os;\n}\n//閉路がなければtrue\nbool topo(vi &res, digraph<int> &g) {\n    int n = g.g.size();\n    vi nyu(n);\n    rep(i, n)for (auto &&e :g[i])nyu[e.t]++;\n    queue<int> st;\n    rep(i, n)if (nyu[i] == 0)st.push(i);\n    while (st.size()) {\n        int v = st.front();\n        st.pop();\n        res.push_back(v);\n        fora(e, g[v]) if (--nyu[e.t] == 0)st.push(e.t);\n    }\n    return res.size() == n;\n}\n//辞書順最小トポロジカルソート\nbool topos(vi &res, digraph<int> &g) {\n    int n = g.g.size();\n    vi nyu(n);\n    rep(i, n)for (auto &&e :g[i])nyu[e.t]++;\n    //小さい順\n    priority_queue<int, vector<int>, greater<int> > q;\n    rep(i, n)if (nyu[i] == 0)q.push(i);\n    while (q.size()) {\n        int i = q.top();\n        q.pop();\n        res.push_back(i);\n        fora(e, g[i])if (--nyu[e.t] == 0)q.push(e.t);\n    }\n    return res.size() == n;\n}\ntemplate<class T> vi indegree(graph<T> &g) {\n    vi ret(g.size());\n    rep(i, g.size()) {\n        forg(gi, g[i]) {\n            ret[t]++;\n        }\n    }\n    return ret;\n}\ntemplate<class T> vi outdegree(graph<T> &g) {\n    vi ret(g.size());\n    rep(i, g.size()) {\n        ret[i] = g[i].size();\n    }\n    return ret;\n}\ntemplate<class T> digraph<T> rev(digraph<T> &g) {\n    digraph<T> r(g.n);\n    rep(i, g.n) {\n        forg(gi, g[i]) {\n            r.add(t, f, c);\n        }\n    }\n    return r;\n}\ntemplate<class T> vp bridge(graph<T> &G) {\n    static bool was;\n    vp brid;\n    vi articulation;\n    vi ord(G.n), low(G.n);\n    vb vis(G.n);\n    function<void(int, int, int)> dfs = [&](int v, int p, int k) {\n        vis[v] = true;\n        ord[v] = k++;\n        low[v] = ord[v];\n        bool isArticulation = false;\n        int ct = 0;\n        for (int i = 0; i < G[v].size(); i++) {\n            if (!vis[G[v][i].t]) {\n                ct++;\n                dfs(G[v][i].t, v, k);\n                low[v] = min(low[v], low[G[v][i].t]);\n                if (~p && ord[v] <= low[G[v][i].t]) isArticulation = true;\n                if (ord[v] < low[G[v][i].t]) brid.push_back(make_pair(min(v, G[v][i].t), max(v, G[v][i].t)));\n            } else if (G[v][i].t != p) {\n                low[v] = min(low[v], ord[G[v][i].t]);\n            }\n        }\n\n        if (p == -1 && ct > 1) isArticulation = true;\n        if (isArticulation) articulation.push_back(v);\n    };\n    int k = 0;\n    rep(i, n) {\n        if (!vis[i]) dfs(i, -1, k);\n    }\n    sort(brid.begin(), brid.end());\n    return brid;\n}\ntemplate<class T> vi articulation(undigraph<T> &G) {\n    static bool was;\n    vp bridge;\n    vi arti;\n    vi ord(G.n), low(G.n);\n    vb vis(G.n);\n    function<void(int, int, int)> dfs = [&](int v, int p, int k) {\n        vis[v] = true;\n\n        ord[v] = k++;\n        low[v] = ord[v];\n\n        bool isArticulation = false;\n        int ct = 0;\n\n\n        for (int i = 0; i < G[v].size(); i++) {\n            if (!vis[G[v][i].t]) {\n                ct++;\n                dfs(G[v][i].t, v, k);\n                low[v] = min(low[v], low[G[v][i].t]);\n                if (~p && ord[v] <= low[G[v][i].t]) isArticulation = true;\n                if (ord[v] < low[G[v][i].t]) bridge.push_back(make_pair(min(v, G[v][i].t), max(v, G[v][i].t)));\n            } else if (G[v][i].t != p) {\n                low[v] = min(low[v], ord[G[v][i].t]);\n            }\n        }\n\n        if (p == -1 && ct > 1) isArticulation = true;\n        if (isArticulation) arti.push_back(v);\n    };\n    int k = 0;\n    rep(i, n) {\n        if (!vis[i]) dfs(i, -1, k);\n    }\n    sort(arti.begin(), arti.end());\n    return arti;\n}\n#define kansetu articulation\n\n\n\n\n\n//v3i(dp, 5000, 5001, 2);//コンピューターしかないか\nint dp[5000][5001][2], sub[5001][2];\n//vvi(sub, 5050, 2);\nundigraph<> g(0);\nvi es(5050);\n\nvoid ds(int i, int p) {\n    forg(gi, g[i])if (t != p)ds(t, i);\n    int sum = 0;\n    dp[i][0][a[i] < 0] = a[i];\n    forg(gi, g[i]) {\n        if (t == p)continue;\n        rep(ci, sum + 1) {\n            rep(ct, es[t] + 1) {\n                rep(ki, 2) {\n                    rep(kt, 2) {\n                        //繋ぐ\n                        if (dp[i][ci][ki] < linf && dp[t][ct][kt] < linf)\n                            chmi(sub[ci + ct][ki || kt], dp[i][ci][ki] + dp[t][ct][kt]);\n                        //切る\n                        if (dp[t][ct][kt] < 0 || (!kt && dp[t][ct][kt] != linf))\n                            chmi(sub[ci + ct + 1][ki], dp[i][ci][ki]);\n                    }\n                }\n            }\n        }\n        sum += es[t] + 1;\n        rep(j, sum + 1)rep(k, 2) {\n                dp[i][j][k] = sub[j][k];\n                sub[j][k] = linf;\n\n            }\n    }\n    es[i] = sum;\n}\nsigned main() {\n    cin >> n;\n    na(a, n);\n    g.resize(n);\n    rep(i, n - 1) {\n        int f, s;\n        cin >> f >> s;\n        --f, --s;\n        g.add(f, s);\n    }\n    fill(dp, linf);\n    fill(sub, linf);\n    ds(0, -1);\n    rep(c, n)\n        rep(k, 2) {\n            if (k) {\n                if (dp[0][c][k] < 0)fin(c);\n            } else if (dp[0][c][k] != linf)fin(c);\n        }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FAST ios_base::sync_with_stdio(false); cin.tie(0);\n#define pb push_back\n#define eb emplace_back\n#define ins insert\n#define f first\n#define s second\n#define cbr cerr << \"hi\\n\"\n#define mmst(x, v) memset((x), v, sizeof ((x)))\n#define siz(x) ll(x.size())\n#define all(x) (x).begin(), (x).end()\n#define lbd(x,y) (lower_bound(all(x),y)-x.begin())\n#define ubd(x,y) (upper_bound(all(x),y)-x.begin())\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());    //can be used by calling rng() or shuffle(A, A+n, rng)\ninline long long rand(long long x, long long y) { return (rng() % (y+1-x)) + x; } //inclusivesss\nstring inline to_string(char c) {string s(1,c);return s;} template<typename T> inline T gcd(T a,T b){ return a==0?llabs(b):gcd(b%a,a); }\n\ntypedef long long ll; \ntypedef long double ld;\n#define FOR(i,s,e) for(ll i=s;i<=ll(e);++i)\n#define DEC(i,s,e) for(ll i=s;i>=ll(e);--i)\ntypedef pair<ll,ll>pi; typedef pair<ll,pi>spi; typedef pair<pi,pi>dpi;\n\n#define LLINF ((long long)1e18)\n#define INF int(1e9+1e6)\n#define MAXN (5006)\nll n,A[MAXN],dp[MAXN][MAXN],sz[MAXN];// if 0 then max, 1 then min\n// bitset<MAXN> dp2[MAXN];\nvector<int>v[MAXN];\nvoid dfs(ll x,ll p){\n\tsz[x]=1;\n\tdp[x][0]=A[x];\n\tfor(auto i:v[x]) if(i^p) dfs(i,x), sz[x]+=sz[i];\n\tFOR(k,1,sz[x]) dp[x][k]=LLINF;\n\tll cur = 1;\n\t// if(A[x]>0)dp2[x][0]=1;\n\tfor(auto i:v[x]) if(i^p) {\n\t\tcur += sz[i];\n\t\tDEC(j,cur,0){\n\t\t\tif(dp[x][j]<LLINF) dp[x][j] += dp[i][0];\n\t\t\t// dp2[x][j] = dp2[x][j] & dp2[i][0];\n\t\t\tFOR(k,1,min(j,sz[i])){\n\t\t\t\tdp[x][j]=min(dp[x][j],dp[x][j-k]+dp[i][k]);\n\t\t\t\tif(1) dp[x][j]=min(dp[x][j],dp[x][j-k]);\n\t\t\t\t// dp2[x][j]=dp2[x][j]|(dp2[x][j-k]&dp2[i][k]);\n\t\t\t\t// if(dp[i][k-1] < 0) dp2[x][j]=dp2[x][j]|dp2[x][j-k];\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tFAST\n\tcin>>n;\n\tFOR(i,1,n)cin>>A[i];\n\tFOR(i,2,n){\n\t\tll a,b;cin>>a>>b;\n\t\tv[a].eb(b),v[b].eb(a);\n\t}\n\tdfs(1,1);\n\tll ans = n-1;\n\tFOR(k,0,n-1) if(dp[1][k] < 0) ans = min(ans, k);\n\t// FOR(k,0,n-1) if(dp2[1][k]) ans = min(ans, k);\n\tcout<<ans<<'\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define chmin(x, y) x = min(x, y)\nusing namespace std;\nconst int INF = 1e18;\n\nint n, ans;\nint a[5010];\nvector<int> G[5010];\nint dp[5010][5010][2];\nint to[5010][2];\nint sz[5010];\n\nvoid dfs(int v, int p){\n    sz[v] = 1;\n    if(a[v] > 0) dp[v][0][1] = a[v];\n    else dp[v][0][0] = a[v];\n    for(auto i : G[v]){\n        if(i == p) continue;\n        dfs(i, v);\n        for(int j = 0; j < 5010; j++) to[j][0] = to[j][1] = INF;\n        for(int j = 0; j < sz[v]; j++){\n            for(int k = 0; k < sz[i]; k++){\n                if(dp[i][k][0] < 0 || dp[i][k][1] < INF){\n                    chmin(to[j + k + 1][0], dp[v][j][0]);\n                    chmin(to[j + k + 1][1], dp[v][j][1]);\n                }\n                chmin(to[j + k][1], dp[v][j][1] + dp[i][k][1]);\n                chmin(to[j + k][0], dp[v][j][0] + dp[i][k][1]);\n                chmin(to[j + k][0], dp[v][j][1] + dp[i][k][0]);\n                chmin(to[j + k][0], dp[v][j][0] + dp[i][k][0]);\n            }\n        }\n        for(int j = 0; j < 5010; j++){\n            dp[v][j][0] = to[j][0];\n            dp[v][j][1] = to[j][1];\n        }\n        sz[v] += sz[i];\n    }\n}\n\nsigned main(){\n    cin >> n;\n    for(int i = 0; i < n; i++) cin >> a[i];\n    for(int i = 0; i < n - 1; i++){\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        G[u].push_back(v);\n        G[v].push_back(u); \n    }\n    for(int i = 0; i < 5010; i++) for(int j = 0; j < 5010; j++) dp[i][j][0] = dp[i][j][1] = INF;\n    dfs(0, -1);\n    for(int i = 0; i < n; i++){\n        if(dp[0][i][0] < 0){\n            cout << i << endl;\n            return 0;\n        }\n        if(dp[0][i][1] < INF){\n            cout << i << endl;\n            return 0;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "\n# include <bits/stdc++.h>\n\n# define x first\n# define y second\n# define mp make_pair\n// everything goes according to my plan\n# define pb push_back\n# define sz(a) (int)(a.size())\n# define vec vector\n// shimkenttin kyzdary, dzyn, dzyn, dzyn...\n# define y1    Y_U_NO_y1\n# define left  Y_U_NO_left\n# define right Y_U_NO_right\n\n# ifdef Local\n# define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n# else\n# define debug(...) (__VA_ARGS__)\n# define cerr if(0)cout\n# endif\n\nusing namespace std;\n\ntypedef pair <int, int> pii;\ntypedef long long ll;\ntypedef long double ld;\n\nconst int Mod = (int)1e9 + 7;\nconst int MX = 1073741822;\nconst ll MXLL = 4e18;\nconst int Sz = 1110111;\n// a pinch of soul\ninline void Read_rap () {\n  ios_base :: sync_with_stdio(0);\n  cin.tie(0); cout.tie(0);\n}\ninline void randomizer3000 () {\n  unsigned int seed;\n  asm (\"rdtsc\" : \"=A\"(seed));\n  srand (seed);\n}\nvoid files (string problem) {\n  if (fopen ((problem + \".in\").c_str(),\"r\")) {\n    freopen ((problem + \".in\").c_str(),\"r\",stdin);\n    freopen ((problem + \".out\").c_str(),\"w\",stdout);\n  }\n}\nvoid localInput(const char in[] = \"s\") {\n  if (fopen (in, \"r\")) {\n    freopen (in, \"r\", stdin);\n  }\n  else\n    cerr << \"Warning: Input file not found\" << endl;\n}                    \nvec<ll> dp[Sz];\n\nll ans[Sz];\n            \nll ps[Sz];\n\nint n;\n\nint a[Sz];\n\nvec<int> g[Sz];\n\nvoid calc (int v, int pr) {\n  int big = 0;\n  for (int to : g[v]) {\n    if (to == pr) continue;\n    calc (to, v);\n    if (sz(dp[to]) > sz(dp[big]))\n      big = to;\n  }\n  int siz = 1;\n  if (big) {\n    swap (dp[v], dp[big]);\n    siz = sz(dp[v]);\n    for (int i = 0; i < siz; i++)\n      dp[v][i] += a[v];   \n    dp[v].pb (a[v]);\n    dp[v][ans[big] + 1] = min (dp[v][ans[big] + 1], a[v] * 1ll);\n    siz++;\n  }\n  else\n    dp[v].pb (a[v]);\n              \n  for (int to : g[v]) {\n    if (to == pr || to == big) continue;\n    dp[v].resize (siz + sz(dp[to]), MXLL);\n    for (int s = siz-1; s >= 0; s--) {\n      if (s + ans[to] + 1 < siz)\n        dp[v][s + ans[to] + 1] = min (dp[v][s + ans[to] + 1], dp[v][s]);   \n\n      for (int x = sz(dp[to])-1; x >= 0; x--) {\n        if (s + x < siz)\n          dp[v][s+x] = min (dp[v][s + x], dp[v][s] + dp[to][x]);\n      }\n    }\n    siz += sz(dp[to]);\n  }\n  ans[v] = MXLL;\n  for (int i = 0; i < siz; i++)\n    if (dp[v][i] < 0) {\n      ans[v] = i;\n      break;\n    }\n                                \n  if (a[v] > 0) {\n    ps[v] = 0;\n    for (int to : g[v]) {\n      if (to == pr) continue;\n      if (a[to] > 0)\n        ps[v] += ps[to];\n      else\n        ps[v] += ans[to] + 1;\n    }\n    ans[v] = min (ans[v], ps[v]);      \n  }\n}\n\nint main()\n{\n  # ifdef Local\n    //localInput();\n  # endif\n  Read_rap();\n  cin >> n;\n  for (int i = 1; i <= n; i++)\n    cin >> a[i];       \n  for (int i = 1; i < n; i++) {\n    int u, v;\n    cin >> u >> v;\n    g[u].pb (v);\n    g[v].pb (u);\n  }\n  calc (1, 1);\n  cout << ans[1];\n\n  return 0;\n}\n\n\n\n\n\n\n// Coded by Z..\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define int long long\n#define inf 1000000007\n#define LINF 100000000000000007LL\n#define ll long long\nusing namespace std;\nvector<int> nex[5001];\nint dp[5001][5001];\nbool ap[5001][5001];\nint deg[5001];\nbool used[5001];\nint siz[5001];\nint im[5001],tg[5001];\nbool am[5001],ag[5001];\nvector<int> a(6000);\nvoid calc(int pos){\n\tvector<int> ch;\n\tfor(int i=0;i<nex[pos].size();i++){\n\t\tint nx = nex[pos][i];\n\t\tif( used[nx] ){\n\t\t\tch.pb(nx);\n\t\t\tsiz[pos] += siz[nx];\n\t\t}\n\t}\n\tsiz[pos]++; // pos itself\n\tfor(int i=0;i<=siz[pos];i++){\n\t\ttg[i] = inf;\n\t\tim[i] = a[pos];\n\t\tam[i] = false;\n\t\tag[i] = false;\n\t}\n\tif( a[pos] > 0 )am[0]=true;\n\tint cur = 0;\n\tfor(int i=0;i<ch.size();i++){\n\t\tint ma = siz[ ch[i] ] - 1;\n\t\tfor(int j=0;j<=ma;j++){\n\t\t\tfor(int k=0;k<=cur;k++){\n\t\t\t\ttg[j+k] = min(tg[j+k],im[k]+dp[ch[i]][j]);\n\t\t\t\t//cout<<i<<j<<k<<\" \"<<tg[j+k]<<\" \"<<dp[ch[i]][j]<<endl;\n\t\t\t\tif( dp[ch[i]][j] < 0 || ap[ch[i]][j] ){\n\t\t\t\t\ttg[j+k+1] = min( tg[j+k+1], im[k]);\n\t\t\t\t\t//cout<<j+k+1<<\" \"<<k<<\" \"<<im[k]<<endl;\n\t\t\t\t}\n\t\t\t\tif( am[k] && ap[ch[i]][j] ){ ag[j+k] = true; ag[j+k+1] = true; }\n\t\t\t\tif( am[k] && dp[ch[i]][j]<0 ) ag[j+k+1] = true;\n\t\t\t}\n\t\t}\n\t\tcur += ma+1;\n\t\tfor(int j=0;j<=cur;j++){\n\t\t\tim[j] = tg[j];\n\t\t\tam[j] = ag[j];\n\t\t\ttg[j] = inf;\n\t\t\tag[j] = false;\n\t\t}\n\t}\n\tfor(int i=0;i<siz[pos];i++){\n\t\tdp[pos][i] = im[i];\n\t\tap[pos][i] = am[i];\n\t\t//cout<<\"!!\"<<pos<<\" \"<<i<<\" \"<<im[i]<<\" \"<<am[i]<<endl;\n\t}\n}\nsigned main(){\n\tint n;\n\tcin>>n;\n\ta[0]=0;\n\tfor(int i=1;i<=n;i++)cin>>a[i];\n\tfor(int i=0;i<n-1;i++){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tnex[x].pb(y);\n\t\tnex[y].pb(x);\n\t\tdeg[x]++;\n\t\tdeg[y]++;\n\t}\n\tqueue<int> que;\n\tfor(int i=2;i<=n;i++){\n\t\tif( deg[i] == 1 ){\n\t\t\tque.push(i);\n\t\t}\n\t}\n\twhile(!que.empty()){\n\t\tint cur = que.front(); que.pop();\n\t\tused[cur] = true;\n\t\tcalc(cur);\n\t\tfor(int i=0;i<nex[cur].size();i++){\n\t\t\tint nx = nex[cur][i];\n\t\t\tdeg[nx]--;\n\t\t\tif( deg[nx] == 1 && nx != 1){\n\t\t\t\tque.push(nx);\n\t\t\t}\n\t\t}\n\t}\n\tcalc(1);\n\tfor(int i=0;i<n;i++){\n\t\tif( dp[1][i] < 0 || ap[1][i] ){\n\t\t\tcout<<i<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst long long INF = 1e18;\n\nint n, a[5005], siz[5005];\nlong long tmp[5005], tmp1[5005];\n\nvector <int> edge[5005];\nvector <long long> dp[5005][2];\n\nlong long min(long long a, long long b) {\n    return a < b ? a : b;\n}\n\nvoid solve(int id, int p) {\n    siz[id] = 1;\n\n    int child = 0;\n\n    for (int i = 0; i < edge[id].size(); i++) {\n        int to = edge[id][i];\n        if (to == p) continue;\n        solve(to, id);\n        siz[id] += siz[to];\n        child++;\n    }\n\n    int cur = 0;\n    dp[id][0].reserve(siz[id] + 1);\n    dp[id][1].reserve(siz[id] + 1);\n    for (int i = 0; i <= siz[id]; i++) {\n        dp[id][0].push_back(0);\n        dp[id][1].push_back(0);\n    }\n\n    for (int i = 0; i < edge[id].size(); i++) {\n        int to = edge[id][i];\n        if (to == p) continue;\n\n        for (int j = siz[to]; j >= 1; j--) {\n            if (dp[to][0][j - 1] < 0) {\n                dp[to][0][j] = min(dp[to][0][j], 0LL);\n                dp[to][1][j] = 1;\n            }\n            if (dp[to][1][j - 1]) {\n                dp[to][0][j] = min(dp[to][0][j], 0LL);\n            }\n        }\n\n        cur += siz[to];\n\n\n        if (cur == siz[to]) {\n            //first child\n            for (int j = 0; j <= siz[to]; j++) {\n                dp[id][0][j] = dp[to][0][j];\n                dp[id][1][j] = dp[to][1][j] && (a[id] > 0);\n            }\n        }\n        else {\n            for (int j = cur; j >= 0; j--) {\n                tmp[j] = INF;\n                tmp1[j] = 0;\n                int v = min(j, siz[to]);\n                for (int k = 0; k <= v; k++) {\n                    if (dp[to][0][k] != INF && dp[id][0][j - k] != INF) tmp[j] = min(tmp[j], dp[to][0][k] + dp[id][0][j - k]);\n                    tmp1[j] |= (dp[to][1][k] && dp[id][1][j - k]);\n                }\n            }\n            for (int j = 0; j <= cur; j++) {\n                dp[id][0][j] = tmp[j];\n                dp[id][1][j] = tmp1[j] && (a[id] > 0);\n            }\n        }\n    }\n\n    for (int i = siz[id] - 1; i >= 0; i--) {\n        if (dp[id][0][i] != INF) dp[id][0][i] += a[id];\n    }\n\n    if (child == 0) {\n        dp[id][0][0] = a[id];\n        dp[id][1][0] = a[id] >  0;\n    }\n}\n\nint main() {\n    scanf(\"%d\", &n);\n\n    for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\n    for (int i = 0; i < n - 1; i++) {\n        int x, y;\n        scanf(\"%d%d\", &x, &y);\n        edge[x].push_back(y);\n        edge[y].push_back(x);\n    }\n\n    solve(1, -1);\n\n    for (int i = 0; i < n; i++) {\n        if (dp[1][0][i] < 0) return 0 * printf(\"%d\\n\", i);\n        if (dp[1][1][i]) return 0 * printf(\"%d\\n\", i);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <string>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\n\n\nconst int SZ = 5003;\nint N;\nll A[SZ];\nvector<int> adj[SZ];\nvector<int> children[SZ];\nint tsz[SZ];\n\nvoid readInput() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\tcin >> N;\n\tfor (int i=1; i<=N; i++) cin >> A[i];\n\tfor (int z=0; z<N-1; z++) {\n\t\tint u, v; cin >> u >> v;\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n}\n\nvoid dfs(int p, int u) {\n\ttsz[u] += 1;\n\tfor (int v : adj[u]) if (v != p) {\n\t\tdfs(u, v);\n\t\tchildren[u].push_back(v);\n\t\ttsz[u] += tsz[v];\n\t}\n}\n\n\nll D[SZ][SZ];\nbool P[SZ][SZ];\nvoid solve(int u) {\n\tD[u][0] = A[u];\n\tP[u][0] = A[u] > 0;\n\tif (children[u].empty()) return;\n\tfor (int v : children[u]) solve(v);\n\n\tint sz = 1;\n\tfor (int v : children[u]) {\n\t\tstatic ll DD[SZ];\n\t\tstatic bool PP[SZ];\n\t\tmemset(DD, 1, sizeof(DD));\n\t\tmemset(PP, 0, sizeof(PP));\n\n\t\tfor (int a=0; a<sz; a++) for (int b=0; b<tsz[v]; b++) {\n\t\t\tDD[a+b] = min(DD[a+b], D[u][a]+D[v][b]);\n\t\t\tif (D[v][b] < 0) DD[a+b+1] = min(DD[a+b+1], D[u][a]);\n\t\t\tif (P[v][b]) DD[a+b+1] = min(DD[a+b+1], D[u][a]);\n\t\t}\n\t\tif (A[u]>0) for (int a=0; a<sz; a++) for (int b=0; b<tsz[v]; b++) {\n\t\t\tif (A[v]>0) PP[a+b] = PP[a+b] || (P[u][a] && P[v][b]);\n\t\t\tif (D[v][b] < 0) PP[a+b+1] = PP[a+b+1] || P[u][a];\n\t\t\tif (P[v][b]) PP[a+b+1] = PP[a+b+1] || P[u][a];\n\t\t}\n\n\t\tsz += tsz[v];\n\t\tfor (int k=0; k<sz; k++) {\n\t\t\tD[u][k] = DD[k];\n\t\t\tP[u][k] = PP[k];\n\t\t}\n\t}\n\n\t/*\n\tprintf(\"[debug]\\n\");\n\tfor (int k=0; k<sz; k++) cout << D[u][k] << \" \";\n\tcout << endl;\n\tfor (int k=0; k<sz; k++) cout << P[u][k] << \" \";\n\tcout << endl;\n\tcout << endl;\n\t*/\n}\n\n\n\nint main() {\n\treadInput();\n\tdfs(-123, 1);\n\tsolve(1);\n\n\tint ans = 1e9;\n\tfor (int k=0; k<N; k++) {\n\t\tif (D[1][k] < 0) ans = min(ans, k);\n\t\tif (P[1][k]) ans = min(ans, k);\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n#define reps(i, n) for (int i = 1; i <= (int) (n); i++)\n#define all(x) (x).begin(), (x).end()\n#define uniq(x) (x).erase(unique(all(x)), (x).end())\n#define bit(n) (1LL << (n))\n#define cdiv(a, b) (((a) - 1) / (b) + 1)\n#define dump(x) cerr << #x \" = \" << (x) << endl\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing pint = pair<int, int>;\nusing vpint = vector<pint>;\ntemplate<typename T> using priority_queue_rev = priority_queue<T, vector<T>, greater<T>>;\nconstexpr double PI = 3.1415926535897932384626433832795028;\nconstexpr int DY[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nconstexpr int DX[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nint gcd(int a, int b) {\n    while (b) { swap(a %= b, b); }\n    return a;\n}\nint lcm(int a, int b) { return a / gcd(a, b) * b; }\nint sgn(int x) { return (x > 0) - (x < 0); }\ntemplate<typename T> void fin(T mes) {\n    cout << mes << endl;\n    exit(0);\n}\ntemplate<typename T, typename U> bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &rhs) {\n    os << \"(\" << rhs.first << \", \" << rhs.second << \")\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\nstruct setup {\n    static constexpr int PREC = 20;\n\n    setup() {\n        cout << fixed << setprecision(PREC);\n        cerr << fixed << setprecision(PREC);\n    };\n} setup;\n\nint N;\nint A[5500];\nint U[5500], V[5500];\nvint G[5500];\npair<vint, int> dfs(int cur, int par) {\n    vint x = {A[cur]};\n    int cut = 0;\n    for (int to:G[cur]) {\n        if (to == par) { continue; }\n        pair<vint, int> tmp = dfs(to, cur);\n        vint nxt = tmp.first;\n        int ccut = tmp.second;\n        vint y(x.size() + nxt.size(), LLONG_MAX);\n        if (ccut >= 0) { rep(i, x.size()) { y[i + ccut + 1] = x[i]; }}\n        rep(i, x.size()) {\n            rep(j, nxt.size()) {\n                chmin(y[i + j], x[i] + nxt[j]);\n                if (nxt[j] < 0) { chmin(y[i + j + 1], x[i]); }\n            }\n        }\n        x = y;\n        reps(i, x.size() - 1) { chmin(x[i], x[i - 1]); }\n        int pl = INT_MAX;\n        for (int i = nxt.size() - 1; i >= 0; i--) { if (nxt[i] < 0) { pl = i; }}\n        if (ccut >= 0) { cut += min(ccut, pl + 1); }\n        else { cut += pl + 1; }\n    }\n    if (A[cur] < 0) { cut = -1; }\n    return {x, cut};\n}\n\nsigned main() {\n    cin >> N;\n    rep(i, N) { cin >> A[i]; }\n    rep(i, N - 1) {\n        cin >> U[i] >> V[i];\n        U[i]--, V[i]--;\n        G[U[i]].push_back(V[i]), G[V[i]].push_back(U[i]);\n    }\n    pair<vint, int> res = dfs(0, -1);\n    int ans = N;\n    if (A[0] > 0) { ans = res.second; }\n    rep(i, res.first.size()) { if (res.first[i] < 0) { chmin(ans, i); }}\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#define vll vector<ll>\n#define vvvl vector<vvl>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d> >(a, vector<d>(b, c))\n#define VVV(a, b, c, d) vector<vvl>(a, vvl(b, vll (c, d)));\n#define re(c, b) for(ll c=0;c<b;c++)\n#define all(obj) (obj).begin(), (obj).end()\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\n\nvll num;\nll N;\nvvl G = VV(5001, 0, 0, ll);\nll INF = 1000000000000000000;\nvvvl dp = VVV(5001, 0, 0, INF);\nvll sz(5001, -1);\n\nvoid dfs(ll now, ll from){\n  ll now_sz = 1;\n  vvl prev = VV(N+1, 2, INF, ll);\n  vvl dat = VV(N+1, 2, INF, ll);\n  dat[1][0] = num[now];\n  if(num[now]>0) dat[1][1] = num[now];\n\n  for(auto to:G[now]){\n    if(to==from) continue;\n    dfs(to, now);\n\n    prev = dat;\n    dat = VV(N+1, 2, INF, ll);\n    ll minit_zero = INF, minit_one = INF;\n    for(int i=1;i<=N;i++){\n      if(dp[to][i][1]!=INF&&minit_one==INF) minit_one = i;\n      if(dp[to][i][0] < 0&&minit_zero==INF) minit_zero = i;\n    }\n    ll x = min(minit_one, minit_zero);\n\n    for(int i=1;i<=N;i++){\n      //分離\n      if(i+x>N) continue;\n      if(x!=INF){\n        dat[i+x][0] = min(dat[i+x][0], prev[i][0]);\n        dat[i+x][1] = min(dat[i+x][1], prev[i][1]);\n      }\n    }\n\n    for(int i=1;i<=now_sz;i++){\n      for(int j=1;j<=sz[to];j++){\n        if(i+j>N) continue;\n        //連結\n        dat[i+j-1][0] = min(dat[i+j-1][0],\n          prev[i][0] + dp[to][j][0]);\n        dat[i+j-1][1] = min(dat[i+j-1][1],\n          prev[i][1] + dp[to][j][1]);\n      }\n    }\n    now_sz += sz[to];\n  }\n  sz[now] = now_sz;\n  dp[now] = dat;\n}\n\nint main(int argc, char const *argv[]) {\n  ll n;std::cin >> n;\n  N = n;\n  num.resize(n);\n  re(i, n) scanf(\"%lld\", &num[i]);\n  for(int i=0;i<n-1;i++){\n    ll a, b;scanf(\"%lld %lld\", &a, &b);\n    a--, b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  //幾らかの正のみで構成される部分を切って正、正、、、負にする\n  // dp[i][j][k] i以下でその部分木でj回カットしている場合の最小値\n  // kは今のところ全ての要素が正かのフラグ\n  // 0 <= i <= 5000, 0 <= j <= 5000, k = 0 or\n\n  //計算量O();\n  dfs(0, -1);\n  for(int i=1;i<=N;i++){\n    if(dp[0][i][0]<0||dp[0][i][1]!=INF){\n      std::cout << i - 1 << '\\n';\n      return 0;\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std;\nconst long long inf = 1234567891234567891;\nconst int inf_int = 1012345678;\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tint N;\n\tcin >> N;\n\tvector<int> A(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> A[i];\n\t}\n\tvector<vector<int> > G(N);\n\tfor (int i = 0; i < N - 1; ++i) {\n\t\tint u1, u2;\n\t\tcin >> u1 >> u2; --u1, --u2;\n\t\tG[u1].push_back(u2);\n\t\tG[u2].push_back(u1);\n\t}\n\tvector<int> c(N, 1);\n\tfunction<void(int, int)> calc_subtree = [&](int pos, int pre) {\n\t\tfor (int i : G[pos]) {\n\t\t\tif (i != pre) {\n\t\t\t\tcalc_subtree(i, pos);\n\t\t\t\tc[pos] += c[i];\n\t\t\t}\n\t\t}\n\t};\n\tcalc_subtree(0, -1);\n\tvector<vector<long long> > dp0(N), dp1(N);\n\tvector<int> commence(N, inf_int);\n\tfunction<void(int, int)> calc = [&](int pos, int pre) {\n\t\tdp0[pos].resize(c[pos] + 1, inf); dp0[pos][0] = 0;\n\t\tdp1[pos].resize(c[pos] + 1, inf);\n\t\tint sum = 1;\n\t\tfor (int i : G[pos]) {\n\t\t\tif (i != pre) {\n\t\t\t\tcalc(i, pos);\n\t\t\t\tfor (int j = sum + c[i] - 1; j >= 0; --j) {\n\t\t\t\t\tdp1[pos][j] = min(dp0[pos][j], dp1[pos][j]) + dp1[i][0];\n\t\t\t\t\tdp0[pos][j] = dp0[pos][j] + dp0[i][0];\n\t\t\t\t\tfor (int k = 1; k <= c[i] && k <= j; ++k) {\n\t\t\t\t\t\tdp1[pos][j] = min(dp1[pos][j], min(dp0[pos][j - k], dp1[pos][j - k]) + dp1[i][k]);\n\t\t\t\t\t\tdp0[pos][j] = min(dp0[pos][j], dp0[pos][j - k] + dp0[i][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsum += c[i];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < c[pos]; ++i) {\n\t\t\tif (A[pos] > 0) {\n\t\t\t\tdp0[pos][i] += A[pos];\n\t\t\t\tdp1[pos][i] += A[pos];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp1[pos][i] = min(dp0[pos][i], dp1[pos][i]) + A[pos];\n\t\t\t\tdp0[pos][i] = inf;\n\t\t\t}\n\t\t}\n\t\tfor (int i = c[pos] - 1; i >= 0; --i) {\n\t\t\tif (dp0[pos][i] < inf / 2 || dp1[pos][i] < 0) {\n\t\t\t\tdp0[pos][i + 1] = min(dp0[pos][i + 1], (long long)(0));\n\t\t\t\tcommence[pos] = i;\n\t\t\t}\n\t\t}\n\t};\n\tcalc(0, -1);\n\tcout << commence[0] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stdio.h>\n#include <vector>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stdlib.h>\n#include <time.h>\n#include <iomanip>\n#include <math.h>\n#include <bitset>\n\nusing namespace std;\n\n#define taskname \"A\"\n#define LL long long \n#define uLL unsigned long long \n#define FOR(i,l,r) for(int i = l; i <= r; ++i)\n#define REP(i,l,r) for(int i = l; i < r; ++i)\n#define FORD(i,r,l) for(int i = r; i >= l; --i)\n#define REPD(i,r,l) for(int i = r; i > l; --i)\n#define sz(x) (int)((x).size())\n#define all(x) (x).begin(), (x).end()\n#define debug(x) { cerr << #x << \" = \" << x << endl; }\n#define sci(x) int x; scanf(\"%d\", &x);\n#define scii(x, y) int x, y; scanf(\"%d %d\", &x, &y);\n#define sciii(x, y, z) int x, y, z; scanf(\"%d %d %d\", &x, &y, &z);\n#define pi pair<int,int>\n#define pii pair<int,pi>\n#define piLL pair<LL,LL>\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define _USE_MATH_DEFINES \n/* M_PI */\n#define SetLength2(a, n, t) a=((t*) calloc(n, sizeof(t))) + (n)/2\n\nconst int maxN = 5001;\nconst LL oo = 1e17 + 11;\n\nint tcases = 1;\n\nint N,M,total = 0,res = 0;\nvector <int> e[maxN];\nint C[maxN];\nLL W[maxN],A[maxN],F[maxN][maxN],f1[maxN],g1[maxN];\nbool G[maxN][maxN];\npiLL tmp[maxN],fg[maxN];\n\nvoid dfs(int u,int p = 0){\n    W[u] = A[u];\n    C[u] = 1;\n    REP(i,0,e[u].size()){\n        int v = e[u][i];\n        if(v == p) continue;\n        dfs(v,u);\n        W[u] += W[v];\n        C[u] += C[v];\n    }\n}\nvoid cal(int u,int p = 0){\n    REP(i,0,e[u].size()){\n        int v = e[u][i];\n        if(v != p) cal(v,u);\n    }\n    //\n    F[u][0] = W[u];\n    if(C[u] == 1) G[u][0] = A[u] > 0;\n    else{\n        REP(i,0,C[u]) f1[i] = oo,g1[i] = 0;\n        f1[0] = A[u]; g1[0] = A[u] > 0;\n        \n        REP(k,0,e[u].size()){\n            int v = e[u][k];\n            if(v == p) continue;\n            // cal F[u][i]\n            REP(i,0,C[u]){\n                F[u][i] = oo; G[u][i] = 0;\n                FOR(j,0,min(C[v],i)){\n                    F[u][i] = min(F[u][i],f1[i - j] + F[v][j]);\n                    G[u][i] |= g1[i - j] & (G[v][j] || (j > 0 & F[v][j - 1] < 0));\n                }\n            }\n            REP(i,0,C[u]) f1[i] = F[u][i],g1[i] = G[u][i];\n        }\n    }\n    REP(i,0,C[u]){\n        if(F[u][i] < 0 || G[u][i]){\n            F[u][i + 1] = min(F[u][i + 1],0LL);\n            //G[u][i + 1] = 1;\n        }\n    }\n}\nvoid testcase(){\n\n    cin >> N;\n    FOR(i,1,N) cin >> A[i];\n    \n    REP(i,1,N){\n        scii(u,v);\n        e[u].pb(v);\n        e[v].pb(u);\n    }\n\n    dfs(1);\n\n    int root = 1;\n\n    FOR(i,1,N){\n        FOR(j,0,N) F[i][j] = oo;\n    }\n\n    cal(root);\n    \n    FOR(j,0,N) if(F[root][j] < 0 || G[root][j]){\n        cout << j;\n        return ;\n    }\n}\n\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie();\n    cout.tie();\n    \n    FOR(i,1,tcases) testcase();\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n \n#define rep(i, n)      for (int i = 0; i < (n); i++)\n#define repr(i, n)     for (int i = (n) - 1; i >= 0; i--)\n#define repe(i, l, r)  for (int i = (l); i < (r); i++)\n#define reper(i, l, r) for (int i = (r) - 1; i >= (l); i--)\n#define repi(i, l, r)  for (int i = (l); i <= (r); i++)\n#define repir(i, l, r) for (int i = (r); i >= (l); i--)\n#define range(a) a.begin(), a.end()\nvoid initio() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); }\n\nvoid chmin(ll &x, ll y) {\n  x = min(x, y);\n}\n\nint main() { initio();\n  int N; cin >> N;\n  vector<ll> A(N); rep(i, N) cin >> A[i];\n  vector<vector<int>> G(N);\n  rep(i, N-1) {\n    int u, v; cin >> u >> v; u--; v--;\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  constexpr ll inf = 1e18;\n  vector<vector<ll>> dp0(N); // all positive\n  vector<vector<ll>> dp1(N); // some negative\n  auto merge = [&](vector<ll> a0, vector<ll> a1, vector<ll> b0, vector<ll> b1) -> pair<vector<ll>, vector<ll>> {\n    const int n = a0.size();\n    const int m = b0.size();\n    vector<ll> c0(n + m - 1, inf);\n    vector<ll> c1(n + m - 1, inf);\n    repe(i, 1, n) repe(j, 1, m) {\n      if (b0[j] != inf) {\n        chmin(c0[i + j - 1], a0[i] + b0[j]);\n        chmin(c1[i + j - 1], a1[i] + b0[j]);\n        chmin(c1[i + j], a1[i]);\n        chmin(c1[i + j], a1[i] + b0[j]);\n      }\n      if (b1[j] != inf) {\n        chmin(c1[i + j - 1], a0[i] + b1[j]);\n        chmin(c1[i + j - 1], a1[i] + b1[j]);\n        if (b1[j] < 0) {\n          chmin(c0[i + j], a0[i]);\n          chmin(c1[i + j], a1[i]);\n        }\n      }\n    }\n    return {c0, c1};\n  };\n  auto dfs = [&](auto dfs, int u, int p) -> void {\n    if (A[u] > 0) {\n      dp0[u] = {inf, A[u]};\n      dp1[u] = {inf, inf};\n    } else {\n      dp1[u] = {inf, A[u]};\n      dp0[u] = {inf, inf};\n    }\n    for (int v : G[u]) if (v != p) {\n      dfs(dfs, v, u);\n      auto p = merge(dp0[u], dp1[u], dp0[v], dp1[v]);\n      tie(dp0[u], dp1[u]) = p;\n    }\n  };\n  dfs(dfs, 0, -1);\n  repe(i, 1, N + 1) {\n    if (dp0[0][i] != inf || dp1[0][i] < 0) {\n      cout << i - 1 << endl;\n      return 0;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <string>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\nusing namespace std;\n#define int long long\nint MOD = 1000000007;\nvector<vector<int> > g;\nvector<int> A;\nvector<int> dp[5001][2];\nint N;\nvector<int> ndp[2];\nvoid amin(int &a, const int &b) {\n\ta = min(a, b);\n}\nconst int INF = (int)1 << 60;\nint dfs(int a, int p) {\n\tif (A[a] < 0) {\n\t\tdp[a][1].push_back(A[a]);\n\t}\n\telse {\n\t\tdp[a][0].push_back(A[a]);\n\t}\n\tfor (int b : g[a]) {\n\t\tif (b != p) {\n\t\t\tdfs(b, a);\n\t\t\tint mx1 = max(dp[a][0].size(), dp[a][1].size());\n\t\t\tint mx2 = max(dp[b][0].size(), dp[b][1].size());\n\t\t\tndp[0].clear();\n\t\t\tndp[0].resize(mx1 + mx2,INF);\n\t\t\tndp[1].clear();\n\t\t\tndp[1].resize(mx1 + mx2,INF);\n\t\t\tfor (int i = 0; i < dp[a][0].size(); i++) {\n\t\t\t\tfor (int j = 0; j < dp[b][0].size(); j++) {\n\t\t\t\t\tamin(ndp[0][i + j], dp[a][0][i] + dp[b][0][j]);\n\t\t\t\t\tif (dp[b][0][j] < INF) {\n\t\t\t\t\t\tamin(ndp[0][i + j + 1], dp[a][0][i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < dp[b][1].size(); j++) {\n\t\t\t\t\tamin(ndp[1][i + j], dp[a][0][i] + dp[b][1][j]);\n\t\t\t\t\tif (dp[b][1][j] < 0) {\n\t\t\t\t\t\tamin(ndp[0][i + j + 1], dp[a][0][i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < dp[a][1].size(); i++) {\n\t\t\t\tfor (int j = 0; j < dp[b][0].size(); j++) {\n\t\t\t\t\tamin(ndp[1][i + j], dp[a][1][i] + dp[b][0][j]);\n\t\t\t\t\tif (dp[b][0][j] < INF) {\n\t\t\t\t\t\tamin(ndp[1][i + j + 1], dp[a][1][i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < dp[b][1].size(); j++) {\n\t\t\t\t\tamin(ndp[1][i + j], dp[a][1][i] + dp[b][1][j]);\n\t\t\t\t\tif (dp[b][1][j] < 0) {\n\t\t\t\t\t\tamin(ndp[1][i + j + 1], dp[a][1][i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tswap(ndp[0], dp[a][0]);\n\t\t\tswap(ndp[1], dp[a][1]);\n\t\t}\n\t}\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tcin >> N;\n\tA.resize(N);\n\tg.resize(N);\n\n\tint res = 0;\n\tint a, b;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> A[i];\n\t}\n\tfor (int i = 0; i < N - 1; i++) {\n\t\tcin >> a >> b; a--; b--;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\tdfs(0, -1);\n\tres = INF;\n\tfor (int i = 0; i < dp[0][0].size(); i++) {\n\t\tif (dp[0][0][i] < INF) {\n\t\t\tres = min(res, i);\n\t\t}\n\t}\n\tfor (int i = 0; i < dp[0][1].size(); i++) {\n\t\tif (dp[0][1][i] < 0) {\n\t\t\tres = min(res, i);\n\t\t}\n\t}\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=5005;\ntypedef long long ll;\nint n,a[N],u,v,i,sz[N];\nll f[N][N],g[N][N];\nvector<int>e[N];\nvoid dfs(int u,int fa){\n\tf[u][0]=a[u];g[u][0]=a[u]>0?a[u]:1ll<<50;\nif(u==9){\n++u,--u;\n}\n\tfor(int v:e[u])if(v!=fa){\n\t\tdfs(v,u);\n\t\tstatic ll h[N];int i,j;\n\t\tfor(i=0;i<=sz[u]+sz[v];++i)h[i]=1ll<<50;\n\t\tfor(i=0;i<=sz[u];++i)for(j=0;j<=sz[v];++j)h[i+j]=min(h[i+j],f[u][i]+f[v][j]);\n\t\tmemcpy(f[u],h,sz[u]+sz[v]+1<<3);\n\t\tfor(i=0;i<=sz[u]+sz[v];++i)h[i]=1ll<<50;\n\t\tfor(i=0;i<=sz[u];++i)for(j=0;j<=sz[v];++j)h[i+j]=min(h[i+j],g[u][i]+g[v][j]);\n\t\tmemcpy(g[u],h,sz[u]+sz[v]+1<<3);sz[u]+=sz[v];\n\t}\n\tf[u][++sz[u]]=1ll<<50;\n\tfor(i=sz[u]-1;i>=0;--i)if(f[u][i]<0 || g[u][i]<1ll<<50)f[u][i+1]=min(f[u][i+1],0ll),g[u][i+1]=min(g[u][i+1],0ll);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;++i)scanf(\"%d\",a+i);\n\tfor(i=1;i<n;++i)scanf(\"%d%d\",&u,&v),e[u].push_back(v),e[v].push_back(u);\n\tdfs(1,0);\n\tfor(i=0;f[1][i]>=0 && g[1][i]>=1ll<<50;++i);printf(\"%d\\n\",i);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <complex>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\nusing namespace std;\n \n#define mod 1000000007\n#define FOR(x,to) for(int x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define long long long\ninline int rei(){int x;cin>>x;return x;}\ninline long rel(){long x;cin>>x;return x;}\ninline string res(){string x;cin>>x;return x;}\n//------------------------------------------------------- \nlong DP1[25000000];\nlong buffer[5000];\nint dp1[5000];\nint DP2[5000];\nint child[5000];\nlong A[5000];\nvector<int> G[5000];\nvoid Calc(){\n\tint N = rei();\n\tfor(int i=0;i<N;i++){\n\t\tA[i] = rel();\n\t}\n\tfor(int i=0;i<N-1;i++){\n\t\tint v = rei()-1;\n\t\tint u = rei()-1;\n\t\tG[v].push_back(u);\n\t\tG[u].push_back(v);\n\t}\n\tstack<pair<int,int>> sp;\n\tsp.push({0,-1});\n\twhile(!sp.empty()){\n\t\tint v = sp.top().first;\n\t\tint f = sp.top().second;\n\t\tsp.pop();\n\t\tif(v >= N){\n\t\t\tv -= N;\n\t\t\tif(A[v] > 0){\n\t\t\t\tint c = 0;\n\t\t\t\tfor(int t:G[v]){\n\t\t\t\t\tif(t != f){\n\t\t\t\t\t\tc += min(DP2[t],dp1[t]+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tDP2[v] = c;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tDP2[v] = 10000;\n\t\t\t}\n\t\t\t{\n\t\t\t\tint ch = 1;\n\t\t\t\tDP1[v*5000] = A[v];\n\t\t\t\tfor(int t:G[v]){\n\t\t\t\t\tif(t != f){\n\t\t\t\t\t\tfor(int i=0;i<ch+child[t];i++){\n\t\t\t\t\t\t\tbuffer[i] = 100000000000000000;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int i=ch-1;i>=0;i--){\n\t\t\t\t\t\t\tbuffer[i+dp1[t]+1] = min(buffer[i+dp1[t]+1],DP1[v*5000+i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int i=ch-1;i>=0;i--){\n\t\t\t\t\t\t\tfor(int j=child[t]-1;j>=0;j--){\n\t\t\t\t\t\t\t\tbuffer[i+j] = min(buffer[i+j],DP1[v*5000+i]+DP1[t*5000+j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int i=0;i<ch+child[t];i++){\n\t\t\t\t\t\t\tDP1[v*5000+i] = buffer[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tch += child[t];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint bf = 0;\n\t\t\t\tint bl = ch-1;\n\t\t\t\twhile(bf != bl){\n\t\t\t\t\tint bc = (bf+bl)/2;\n\t\t\t\t\tif(DP1[v*5000+bc] < 0){\n\t\t\t\t\t\tbl = bc;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tbf = bc+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp1[v] = min(DP2[v],bf);\n\t\t\t\tchild[v] = ch;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tsp.push({v+N,f});\n\t\t\tfor(int t:G[v]){\n\t\t\t\tif(t != f){\n\t\t\t\t\tsp.push({t,v});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp1[0] << endl;\n}\nint main(int argc,char** argv){\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcout.tie(0); Calc(); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\nint N;\nint s[5010] = {};\nll A[5010] = {},dp1[5010][5010] = {},dp2[5010][5010] = {};\n//1:その点を根とした部分木の各点の値がすべて正\n//2:負が含まれる\nconst ll inf = 2e18;\nvector<vector<int>> v(5010);\n\nvoid dfs(int n,int m){\n    s[n] = 1;\n    if(A[n]>0) dp1[n][0] = A[n];\n    dp2[n][0] = A[n];\n    for(auto x:v[n]){\n        if(x==m) continue;\n        dfs(x,n);\n        vector<ll> merge1(N+1,inf),merge2(N+1,inf);\n        for(int i=0;i<s[n];i++){\n            for(int j=0;j<s[x];j++){\n                if(dp1[x][j]!=inf){\n                    if(dp1[x][j]!=-1) merge1[i+j] = min(merge1[i+j],dp1[n][i]+dp1[x][j]);\n                    merge1[i+j+1] = min(merge1[i+j+1],dp1[n][i]);\n                    merge2[i+j+1] = min(merge2[i+j+1],dp2[n][i]);\n                }\n                if(dp2[x][j]!=inf){\n                    merge2[i+j] = min(merge2[i+j],dp2[n][i]+dp2[x][j]);\n                    if(dp2[x][j]<0){\n                        merge2[i+j+1] = min(merge2[i+j+1],dp2[n][i]);\n                        merge1[i+j+1] = min(merge1[i+j+1],dp1[n][i]);\n                    }\n                }\n            }\n        }\n        for(int i=0;i<N;i++){dp1[n][i] = merge1[i]; dp2[n][i] = merge2[i];}\n        s[n] += s[x];\n    }\n}\n\nint main(){\n    cin >> N;\n    for(int i=1;i<=N;i++) cin >> A[i];\n    int a,b;\n    for(int i=1;i<=N-1;i++){\n        cin >> a >> b;\n        v[a].push_back(b);\n        v[b].push_back(a);\n    }\n    for(int i=1;i<=N;i++) for(int j=0;j<=N;j++) {dp1[i][j] = inf; dp2[i][j] = inf;}\n    dfs(1,0);\n/*    cerr << \"dp1\" << endl;\n    for(int i=1;i<=N;i++){\n        for(int j=0;j<N;j++) cerr << dp1[i][j] << \" \";\n        cerr << endl;\n    }\n    cerr << \"dp2\" << endl;\n    for(int i=1;i<=N;i++){\n        for(int j=0;j<N;j++) cerr << dp2[i][j] << \" \";\n        cerr << endl;\n    }\n*/    int ans = N;\n    for(int i=N-1;i>=0;i--){\n        if(dp1[1][i]!=inf) ans = i;\n        if(dp2[1][i]<0) ans = i;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(ll (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(WW,n)cerr << v[WW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,WW,HH) {REP(W_,WW){REP(H_,HH)cerr << v[W_][H_] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nll n;\nll mp[5555];\nvector<vector<int>> v(5555);\nll dp1[5555][5555];\nll dp2[5555][5555];\nll tmp1[5555];\nll tmp2[5555];\nll subNum[5555];\n\nvoid dfs(int node, int pre){\n\tsubNum[node] = 1;\n\t\n\tif(mp[node] > 0)dp1[node][0] = mp[node];\n\tdp2[node][0] = mp[node];\n\t\n\tREP(i,v[node].size())if(v[node][i] != pre){\n\t\tint now = v[node][i];\n\t\tdfs(now, node);\n\t\t\n\t\tREP(j,subNum[node] + subNum[now] + 1){\n\t\t\ttmp1[j] = LLINF;\n\t\t\ttmp2[j] = LLINF;\n\t\t}\n\t\tREP(j,subNum[node]){\n\t\t\tREP(k,subNum[now]){\n\t\t\t\tif(dp1[now][k] != LLINF || dp2[now][k] < 0){\n\t\t\t\t\ttmp1[j+k+1] = min(tmp1[j+k+1],dp1[node][j]);\n\t\t\t\t\ttmp2[j+k+1] = min(tmp2[j+k+1],dp2[node][j]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ttmp1[j+k] = min(tmp1[j+k],dp1[node][j] + dp1[now][k]);\n\t\t\t\ttmp2[j+k] = min(tmp2[j+k],dp1[node][j] + dp2[now][k]);\n\t\t\t\ttmp2[j+k] = min(tmp2[j+k],dp2[node][j] + dp1[now][k]);\n\t\t\t\ttmp2[j+k] = min(tmp2[j+k],dp2[node][j] + dp2[now][k]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tsubNum[node] += subNum[now];\n\t\tREP(j,subNum[node]){\n\t\t\tdp1[node][j] = tmp1[j];\n\t\t\tdp2[node][j] = tmp2[j];\n\t\t}\n\t}\n}\n\nint main(){\n\t\n\tREP(i,5555){\n\t\tREP(j,5555){\n\t\t\tdp1[i][j] = LLINF;\n\t\t\tdp2[i][j] = LLINF;\n\t\t}\n\t}\t\n\t\n\tcin >> n;\n\tREP(i,n)cin >> mp[i];\n\tREP(i,n-1){\n\t\tint a, b;cin >> a >> b;\n\t\ta--;b--;\n\t\tv[a].PB(b);\n\t\tv[b].PB(a);\n\t}\n\t\n\tdfs(0, -1);\n\t\n\tfor(int i = 0;i <= n;i++){\n\t\tif(dp1[0][i] != LLINF){\n\t\t\tcout << i << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif(dp2[0][i] < 0){\n\t\t\tcout << i << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define F first\n#define S second\n#define int long long\n#define ll long long\n//#define int  unsigned long long\n#define pb push_back\n//#define double long double\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef  tree< int , null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\nconst int mod = 1e9 + 7;\nconst int N = 5050;\nconst int K = 20;\nint dp1[N], dp2[N][N], sz[N], a[N];\nvector < int > g[N];\nint s[N];\nvoid dfs(int v, int p = -1){\n    sz[v]++;\n    s[v] = a[v];\n    if (g[v].size() != 1 || p == -1) dp1[v] = 0;\n    for (auto u: g[v]){\n        if (u == p) continue;\n        dfs(u, v);\n        s[v] += s[u];\n        int x = dp1[u];\n        for (int i = 0; i <= sz[u]; i++){\n            if (dp2[u][i] < 0) x = min(x, i + 1);\n        }\n        for (int i = 0; i < sz[u]; i++){\n            if (dp1[u] + 1 < N) dp2[u][dp1[u] + 1] = min(dp2[u][dp1[u] + 1], 0LL);\n        }\n        dp1[u] = min(dp1[u], x);\n        if (sz[v] == 1){\n            for (int i = 0; i <= sz[u]; i++) dp2[v][i] = dp2[u][i];\n        } else{\n            for (int i = sz[v] + sz[u]; i >= 0; i--){\n                dp2[v][i] = dp2[v][i] + dp2[u][0];\n                for (int j = min(sz[u], i); j >= 0; j--){\n                    dp2[v][i] = min(dp2[v][i], dp2[v][i - j] + dp2[u][j]);\n                }\n            }\n        }\n        sz[v] += sz[u];\n        dp1[v] += dp1[u];\n    }\n    if (a[v] < 0){\n        dp1[v] = 1e15;\n        dp2[v][0] = s[v] - a[v];\n    }\n   // cout << \"s[v] = \" << s[v] << \" v = \" << v << endl;\n    if (g[v].size() == 1 && p != -1){\n        if (a[v] > 0){\n            dp1[v] = 0;\n        } else{\n            dp2[v][0] = a[v];\n        }\n    } else{\n        for (int i = 0; i < sz[v]; i++){\n        dp2[v][i] += a[v];\n        }\n    };\n}\nmain(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n   // freopen(\"input.txt\", \"r\", stdin);\n    int n;\n    cin >> n;\n    for (int i = 0; i <= n; i++){\n        dp1[i] = 1e15;\n        for (int j = 0; j <= n; j++){\n            dp2[i][j] = 1e15;\n        }\n    }\n    for (int i = 1; i <= n; i++){\n        cin >> a[i];\n    }\n    for (int i = 1; i < n; i++){\n        int u, v;\n        cin >> u >> v;\n        g[u].pb(v);\n        g[v].pb(u);\n    }\n    dfs(1);\n    int ans = dp1[1];\n    for (int i = 0; i <= n; i++){\n        if (dp2[1][i] < 0) ans = min(ans, i);\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define _for(i,j,N) for(int i = (j);i < (N);i++)\n#define _rep(i,j,N) for(int i = (j);i <= (N);i++)\n#define ALL(x) x.begin(),x.end()\n#define pb push_back\n#define LL long long\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& v) {\n    _for(i,0,(int)(v.size()-1)) os << v[i] << \" \";\n    os << v[v.size()-1];\n    return os;\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& os,const set<T>& v){\n    for(typename set<T>::iterator it = v.begin();it != v.end();it++)\n    os << *it <<\" \";\n    return os;\n}\nconst int maxn = 5005;\nint N;\nLL A[maxn];\nvector<int> G[maxn];\nLL res = 0;\n\nstruct Cmp{\n    bool operator()(const int &a,const int &b)const{\n        return A[a] > A[b];\n    }\n};\n\nconst LL INF = 1e16;\nLL dp[maxn][maxn][2];\nLL aux[maxn][2];\nint child[maxn];\n\nvoid dfs(int u,int p){\n    for(int j : G[u]){\n        if(j == p) continue;\n        dfs(j,u);\n    }\n    if(A[u] > 0){\n        dp[u][0][0] = A[u];\n    }else dp[u][0][1] = A[u];\n\n    _for(i,0,maxn) _for(j,0,2) aux[i][j] = INF;\n    int sum = 1;\n    child[u] = 1;\n\n    for(int v: G[u]){\n        if(v == p) continue;\n        _for(i,0,sum){\n            _for(j,0,child[v]){\n                _for(k1,0,2) _for(k2,0,2){\n                    //if(v == 5) cout <<\"j:\"<<j << \"val:\"<<dp[5][j][0] <<endl;\n                    if(dp[v][j][k2] < 0 || (!k2 && dp[v][j][k2] < INF)){\n                        chmin(aux[j+i+1][k1],dp[u][i][k1]);\n                    }\n                    chmin(aux[i+j][k1|k2],dp[u][i][k1] + dp[v][j][k2]);\n\n                }\n            }\n        }\n        child[u] += child[v];\n        sum += child[v];\n\n        _for(i,0,maxn) _for(j,0,2){\n            dp[u][i][j] =aux[i][j];\n            aux[i][j] = INF;\n        }\n\n    }\n}\n\nint main()\n{\n    cin >> N;\n    _rep(i,1,N){\n        cin >> A[i];\n    }\n\n    _for(i,0,N-1){\n        int u,v;\n        cin >> u >> v;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n\n    _for(i,0,maxn) _for(j,0,maxn) _for(k,0,2) dp[i][j][k] = INF;\n    _for(i,0,maxn) _for(k,0,2) aux[i][k] = INF;\n\n    dfs(1,-1);\n    int ans = maxn;\n    _for(i,0,maxn){\n        if(dp[1][i][1] < 0) chmin(ans,i);\n        //cout << dp[1][i][1] << endl;\n    }\n    _for(i,0,maxn){\n        if(dp[1][i][0] < INF) chmin(ans,i);\n        //cout << child[i] <<endl;\n    }\n    //cout << dp[4][2][1] << endl;\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <utility>\n#define maxn 5005\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst ll infll = 0x3f3f3f3f3f3f3f3fll;\nint n,siz[maxn];\nll a[maxn],f[2][maxn][maxn],tmp[maxn];\nvector <int> adj[maxn];\nvoid work_size(int u,int f){\n\tfor(int i = 0;i < (int)adj[u].size();i++){\n\t\tint v = adj[u][i];\n\t\tif(v == f) continue;\n\t\twork_size(v,u);\n\t\tsiz[u] += siz[v] + 1;\n\t}\n}\ninline bool able(int u,int i){\n\treturn f[0][u][i] < 0 || f[1][u][i] < infll;\n}\nvoid dfs(int u,int fa){\n\tif((int)adj[u].size() == (fa != -1)){\n\t\tf[0][u][0] = a[u];\n\t\tif(a[u] > 0) f[1][u][0] = a[u];\n\t\treturn;\n\t}\n\tint v;\n\tfor(int i = 0;i < (int)adj[u].size();i++){\n\t\tv = adj[u][i];\n\t\tif(v != fa) dfs(v,u);\n\t}\n\tint fir = 0;\n\tif(adj[u][fir] == fa) fir++;\n\tv = adj[u][fir];\n\tfor(int i = 0;i <= siz[v];i++){\n\t\tf[0][u][i] = min(f[0][u][i],f[0][v][i] + a[u]);\n\t\tif(able(v,i)) f[0][u][i + 1] = min(f[0][u][i + 1],a[u]);\n\t}\n\tint totsiz = siz[v] + 1;\n\tfor(int i = fir + 1;i < (int)adj[u].size();i++){\n\t\tv = adj[u][i];\n\t\tif(v == fa) continue;\n\t\tfor(int j = 0;j <= totsiz + siz[v] + 1;j++) tmp[j] = infll;\n\t\tfor(int j1 = totsiz;j1 >= 0;j1--){\n\t\t\tfor(int j2 = siz[v];j2 >= 0;j2--){\n\t\t\t\ttmp[j1 + j2] = min(tmp[j1 + j2],f[0][u][j1] + f[0][v][j2]);\n\t\t\t\tif(able(v,j2)) tmp[j1 + j2 + 1] = min(tmp[j1 + j2 + 1],f[0][u][j1]);\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0;j <= totsiz + siz[v] + 1;j++) f[0][u][j] = tmp[j];\n\t\ttotsiz += siz[v] + 1;\n\t}\n\tif(a[u] < 0) return;\n\tv = adj[u][fir];\n\tfor(int i = 0;i <= siz[v];i++){\n\t\tf[1][u][i] = min(f[1][u][i],f[1][v][i] + a[u]);\n\t\tif(able(v,i)) f[1][u][i + 1] = min(f[1][u][i + 1],a[u]);\n\t}\n\ttotsiz = siz[v] + 1;\n\tfor(int i = fir + 1;i < (int)adj[u].size();i++){\n\t\tv = adj[u][i];\n\t\tif(v == fa) continue;\n\t\tfor(int j = 0;j <= totsiz + siz[v] + 1;j++) tmp[j] = infll;\n\t\tfor(int j1 = totsiz;j1 >= 0;j1--){\n\t\t\tfor(int j2 = siz[v];j2 >= 0;j2--){\n\t\t\t\ttmp[j1 + j2] = min(tmp[j1 + j2],f[1][u][j1] + f[1][v][j2]);\n\t\t\t\tif(able(v,j2)) tmp[j1 + j2 + 1] = min(tmp[j1 + j2 + 1],f[1][u][j1]);\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0;j <= totsiz + siz[v] + 1;j++) f[1][u][j] = tmp[j];\n\t\ttotsiz += siz[v] + 1;\n\t}\n}\nint main(){\n\tfreopen(\"a.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tfor(int i = 1;i <= n;i++) scanf(\"%lld\",&a[i]);\n\tfor(int i = 1;i < n;i++){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\twork_size(1,-1);\n\tmemset(f,0x3f,sizeof(f));\n\tdfs(1,-1);\n\tfor(int i = 0;i <= n - 1;i++){\n\t\tif(able(1,i)){\n\t\t\tprintf(\"%d\\n\",i);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,a,b) for(int i=(a);i<(b);i++)\n#define pb push_back\n#define eb emplace_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n\nusing vint=vector<int>;\nusing pint=pair<int,int>;\nusing vpint=vector<pint>;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\ntemplate<class A,class B>\nostream& operator<<(ostream& ost,const pair<A,B>&p){\n\tost<<\"{\"<<p.first<<\",\"<<p.second<<\"}\";\n\treturn ost;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& ost,const vector<T>&v){\n\tost<<\"{\";\n\tfor(int i=0;i<v.size();i++){\n\t\tif(i)ost<<\",\";\n\t\tost<<v[i];\n\t}\n\tost<<\"}\";\n\treturn ost;\n}\n\nconst int INF=1001001001001001001;\nint N;\nint A[5555];\n\nvint G[5555];\nint dp[5010][5010];\nint dp2[5010];\nint sz[5010];\n\nint tmp[5010];\nvoid dfs(int v,int p){\n\tsz[v]=1;\n\n\tif(A[v]>0){\n\t\tdp2[v]=1;\n\t\tdp[v][1]=A[v];\n\t}\n\telse{\n\t\tdp2[v]=INF;\n\t\tdp[v][1]=A[v];\n\t}\n\tfor(auto u:G[v]){\n\t\tif(u==p)continue;\n\t\tdfs(u,v);\n\t\tint mi=dp2[u]-1;\n\t\tfor(int i=1;i<=sz[u];i++)if(dp[u][i]<0)chmin(mi,i);\n\t\tdp2[v]+=mi;\n\n\t\tfor(int i=1;i<=sz[v]+sz[u];i++)tmp[i]=INF;\n\t\tfor(int i=1;i<=sz[v];i++){\n\t\t\tfor(int j=1;j<=sz[u];j++){\n\t\t\t\tchmin(tmp[i+j-1],dp[v][i]+dp[u][j]);\n\t\t\t}\n\t\t\tif(dp2[u]<=N)chmin(tmp[i+dp2[u]],dp[v][i]);\n\t\t}\n\n\t\tsz[v]+=sz[u];\n\t\tfor(int i=1;i<=sz[v];i++)dp[v][i]=tmp[i];\n\t}\n}\nsigned main(){\n\tcin>>N;\n\trep(i,N)cin>>A[i];\n\trep(i,N-1){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\ta--;b--;\n\t\tG[a].pb(b);G[b].pb(a);\n\t}\n\t\n\tdfs(0,-1);\n\n\tint ans=dp2[0];\n\tfor(int i=1;i<=N;i++)if(dp[0][i]<0)chmin(ans,i);\n\tcout<<ans-1<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int64 INF = 1LL << 58;\n\nvector< int > g[5000];\nint N, A[5000];\nvector< bool > latte[5000];\nvector< int64 > malta[5000];\n\nvoid chmin(int64 &a, int64 b) { a = min(a, b); }\n\nvoid dfs(int idx, int par) {\n  for(auto &to : g[idx]) {\n    if(to == par) continue;\n    dfs(to, idx);\n  }\n\n  latte[idx].emplace_back(A[idx] > 0);\n  for(auto &to : g[idx]) {\n    if(to == par) continue;\n    if(A[to] > 0) {\n      vector< bool > nxt(latte[idx].size() + latte[to].size());\n      for(int i = 0; i < latte[idx].size(); i++) {\n        for(int j = 0; j < latte[to].size(); j++) {\n          if(latte[idx][i] & latte[to][j]) {\n            nxt[i + j] = true;\n          }\n        }\n        for(int j = 0; j < malta[to].size(); j++) {\n          if(!latte[idx][i] || malta[to][j] >= 0) continue;\n          nxt[i + j + 1] = true;\n        }\n      }\n      latte[idx].swap(nxt);\n    } else {\n      vector< bool > nxt(latte[idx].size() + latte[to].size());\n      for(int i = 0; i < latte[idx].size(); i++) {\n        for(int j = 0; j < malta[to].size(); j++) {\n          if(!latte[idx][i] || malta[to][j] >= 0) continue;\n          nxt[i + j + 1] = true;\n        }\n      }\n      latte[idx].swap(nxt);\n    }\n  }\n\n\n  malta[idx].emplace_back(A[idx]);\n  for(auto &to : g[idx]) {\n    if(to == par) continue;\n    vector< int64 > nxt(malta[idx].size() + malta[to].size(), INF);\n    for(int i = 0; i < malta[idx].size(); i++) {\n      for(int j = 0; j < latte[to].size(); j++) {\n        if(latte[to][j]) chmin(nxt[i + j + 1], malta[idx][i]);\n      }\n      for(int j = 0; j < malta[to].size(); j++) {\n        if(malta[idx][i] == INF) continue;\n        if(malta[to][j] == INF) continue;\n        chmin(nxt[i + j], malta[idx][i] + malta[to][j]);\n      }\n      for(int j = 0; j < malta[to].size(); j++) {\n        if(malta[idx][i] == INF) continue;\n        if(malta[to][j] >= 0) continue;\n        chmin(nxt[i + j + 1], malta[idx][i]);\n      }\n    }\n    malta[idx].swap(nxt);\n  }\n\n}\n\n\nint main() {\n  cin >> N;\n  for(int i = 0; i < N; i++) cin >> A[i];\n  for(int i = 1; i < N; i++) {\n    int x, y;\n    cin >> x >> y;\n    --x, --y;\n    g[x].emplace_back(y);\n    g[y].emplace_back(x);\n  }\n  dfs(0, -1);\n  for(int i = 0; i < latte[0].size(); i++) {\n    if(latte[0][i] || malta[0][i] < 0) {\n      cout << i << endl;\n      exit(0);\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define oo ll(1e14)\n#define maxn 5003\n\nusing namespace std;\ntypedef long long ll;\n\nint n;\n\nint a[maxn];\n\nll dp[maxn][maxn][2];\nint sz[maxn];\n\nvector < int > g[maxn];\n\nvoid dfs(int u, int du) {\n  if (a[u] >= 0)\n    dp[u][1][1] = 1;\n  dp[u][1][0] = a[u];\n  sz[u] = 1;\n\n  for (auto v : g[u]) {\n    if (v == du) continue;\n\n    dfs(v, u);\n    sz[u] += sz[v];\n\n    for (int j = sz[u]; j > 0; --j) {\n      bool flag = 0;\n      ll mi = oo;\n\n      for (int k = max(1, j - sz[u] + sz[v]); k <= j && k <= sz[v]; ++k) {\n        flag |= (dp[u][j - k + 1][1] & dp[v][k][1]);\n        mi = min(mi, dp[u][j - k + 1][0] + dp[v][k][0]);\n\n        if (dp[v][k][0] < 0 || dp[v][k][1]) {\n          mi = min(mi, dp[u][j - k][0]);\n          flag |= dp[u][j - k][1];\n        }\n      }\n\n      dp[u][j][1] = flag;\n      dp[u][j][0] = mi;\n    }\n  }\n\n  return;\n}\n\nint main(){\n\n  ios_base::sync_with_stdio(0);\n\n  cin >> n;\n\n  for (int i = 1; i <= n; ++i)\n    cin >> a[i];\n\n  for (int i = 1; i < n; ++i) {\n    int u, v;\n    cin >> u >> v;\n\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n\n  for (int i = 1; i <= n; ++i)\n    for (int j = 0; j <= n; ++j) {\n      dp[i][j][0] = oo;\n      dp[i][j][1] = 0;\n    }\n\n  dfs(1, 1);\n\n  for (int j = 1; j <= n; ++j)\n    if (dp[1][j][0] < 0 || dp[1][j][1]) {\n      cout << j - 1;\n      break;\n    }\n  return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing ull = unsigned long long;\nusing uint = unsigned;\nusing pcc = pair<char, char>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pdd = pair<ld, ld>;\nusing tuplis = array<ll, 3>;\ntemplate<class T> using pq = priority_queue<T, vector<T>, greater<T>>;\nconst ll LINF=0x1fffffffffffffff;\nconst ll MINF=0x7fffffffffff;\nconst int INF=0x3fffffff;\nconst int MOD=1000000007;\nconst int MODD=998244353;\nconst ld DINF=numeric_limits<ld>::infinity();\nconst ld EPS=1e-9;\nconst ld PI=3.1415926535897932;\nconst ll dx[] = {0, 1, 0, -1, 1, -1, 1, -1};\nconst ll dy[] = {1, 0, -1, 0, 1, 1, -1, -1};\n#define overload4(_1,_2,_3,_4,name,...) name\n#define overload3(_1,_2,_3,name,...) name\n#define rep1(n) for(ll i=0;i<n;++i)\n#define rep2(i,n) for(ll i=0;i<n;++i)\n#define rep3(i,a,b) for(ll i=a;i<b;++i)\n#define rep4(i,a,b,c) for(ll i=a;i<b;i+=c)\n#define rep(...) overload4(__VA_ARGS__,rep4,rep3,rep2,rep1)(__VA_ARGS__)\n#define rrep1(n) for(ll i=(n);i--;)\n#define rrep2(i,n) for(ll i=(n);i--;)\n#define rrep3(i,a,b) for(ll i=(b);i-->(a);)\n#define rrep4(i,a,b,c) for(ll i=a+(b-a-1)/c*c;i>=a;i-=c)\n#define rrep(...) overload4(__VA_ARGS__,rrep4,rrep3,rrep2,rrep1)(__VA_ARGS__)\n#define each1(i,a) for(auto&& i:a)\n#define each2(x,y,a) for(auto&& [x,y]:a)\n#define each3(x,y,z,a) for(auto&& [x,y,z]:a)\n#define each(...) overload4(__VA_ARGS__,each3,each2,each1)(__VA_ARGS__)\n#define all1(i) begin(i),end(i)\n#define all2(i,a) begin(i),begin(i)+a\n#define all3(i,a,b) begin(i)+a,begin(i)+b\n#define all(...) overload3(__VA_ARGS__,all3,all2,all1)(__VA_ARGS__)\n#define rall1(i) (i).rbegin(),(i).rend()\n#define rall2(i,k) (i).rbegin(),(i).rbegin()+k\n#define rall3(i,a,b) (i).rbegin()+a,(i).rbegin()+b\n#define rall(...) overload3(__VA_ARGS__,rall3,rall2,rall1)(__VA_ARGS__)\n#define sum(...) accumulate(all(__VA_ARGS__),0LL)\n#define dsum(...) accumulate(all(__VA_ARGS__),0.0L)\n#define Msum(...) accumulate(all(__VA_ARGS__),0_M)\n#define elif else if\n#define unless(a) if(!(a))\n#define mp make_pair\n#define mt make_tuple\n#define INT(...) int __VA_ARGS__;in(__VA_ARGS__)\n#define LL(...) ll __VA_ARGS__;in(__VA_ARGS__)\n#define ULL(...) ull __VA_ARGS__;in(__VA_ARGS__)\n#define STR(...) string __VA_ARGS__;in(__VA_ARGS__)\n#define CHR(...) char __VA_ARGS__;in(__VA_ARGS__)\n#define DBL(...) double __VA_ARGS__;in(__VA_ARGS__)\n#define LD(...) ld __VA_ARGS__;in(__VA_ARGS__)\n#define Sort(a) sort(all(a))\n#define Rev(a) reverse(all(a))\n#define Uniq(a) sort(all(a));a.erase(unique(all(a)),end(a))\n#define vec(type,name,...) vector<type> name(__VA_ARGS__)\n#define VEC(type,name,size) vector<type> name(size);in(name)\n#define vv(type,name,h,...) vector<vector<type>>name(h,vector<type>(__VA_ARGS__))\n#define VV(type,name,h,w) vector<vector<type>>name(h,vector<type>(w));in(name)\n#define vvv(type,name,h,w,...) vector<vector<vector<type>>>name(h,vector<vector<type>>(w,vector<type>(__VA_ARGS__)))\ntemplate<class T> auto min(const T& a){ return *min_element(all(a)); }\ntemplate<class T> auto max(const T& a){ return *max_element(all(a)); }\ninline ll popcnt(ull a){ return __builtin_popcountll(a); }\nll gcd(ll a, ll b){ while(b){ ll c = b; b = a % b; a = c; } return a; }\nll lcm(ll a, ll b){ if(!a || !b) return 0; return a * b / gcd(a, b); }\nll intpow(ll a, ll b){ ll ans = 1; while(b){ if(b & 1) ans *= a; a *= a; b /= 2; } return ans; }\nll modpow(ll a, ll b, ll p){ ll ans = 1; while(b){ if(b & 1) (ans *= a) %= p; (a *= a) %= p; b /= 2; } return ans; }\ntemplate<class T, class U> bool chmin(T& a, const U& b){ if(a > b){ a = b; return 1; } return 0; }\ntemplate<class T, class U> bool chmax(T& a, const U& b){ if(a < b){ a = b; return 1; } return 0; }\nvector<ll> iota(ll n){ vector<ll> a(n); iota(a.begin(), a.end(), 0); return a; }\nvector<pll> factor(ull x){ vector<pll> ans; for(ull i = 2; i * i <= x; i++) if(x % i == 0){ ans.push_back({i, 1}); while((x /= i) % i == 0) ans.back().second++; } if(x != 1) ans.push_back({x, 1}); return ans; }\nmap<ll,ll> factor_map(ull x){ map<ll,ll> ans; for(ull i = 2; i * i <= x; i++) if(x % i == 0){ ans[i] = 1; while((x /= i) % i == 0) ans[i]++; } if(x != 1) ans[x] = 1; return ans; }\nvector<ll> divisor(ull x){ vector<ll> ans; for(ull i = 1; i * i <= x; i++) if(x % i == 0) ans.push_back(i); rrep(ans.size() - (ans.back() * ans.back() == x)) ans.push_back(x / ans[i]); return ans; }\ntemplate<class T> unordered_map<T, ll> press(vector<T> a){ Uniq(a); unordered_map<T, ll> ans; rep(a.size()) ans[a[i]] = i; return ans; }\ntemplate<class T> map<T, ll> press_map(vector<T> a){ Uniq(a); map<T, ll> ans; rep(a.size()) ans[a[i]] = i; return ans; }\nint scan(){ return getchar(); }\nvoid scan(int& a){ scanf(\"%d\", &a); }\nvoid scan(unsigned& a){ scanf(\"%u\", &a); }\nvoid scan(long& a){ scanf(\"%ld\", &a); }\nvoid scan(long long& a){ scanf(\"%lld\", &a); }\nvoid scan(unsigned long long& a){ scanf(\"%llu\", &a); }\nvoid scan(char& a){ do{ a = getchar(); }while(a == ' ' || a == '\\n'); }\nvoid scan(float& a){ scanf(\"%f\", &a); }\nvoid scan(double& a){ scanf(\"%lf\", &a); }\nvoid scan(long double& a){ scanf(\"%Lf\", &a); }\nvoid scan(vector<bool>& a){ for(unsigned i = 0; i < a.size(); i++){ int b; scan(b); a[i] = b; } }\nvoid scan(char a[]){ scanf(\"%s\", a); }\nvoid scan(string& a){ cin >> a; }\ntemplate<class T> void scan(vector<T>&);\ntemplate<class T, size_t size> void scan(array<T, size>&);\ntemplate<class T, class L> void scan(pair<T, L>&);\ntemplate<class T, size_t size> void scan(T(&)[size]);\ntemplate<class T> void scan(vector<T>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T> void scan(deque<T>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T, size_t size> void scan(array<T, size>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T, class L> void scan(pair<T, L>& p){ scan(p.first); scan(p.second); }\ntemplate<class T, size_t size> void scan(T (&a)[size]){ for(auto&& i : a) scan(i); }\ntemplate<class T> void scan(T& a){ cin >> a; }\nvoid in(){}\ntemplate <class Head, class... Tail> void in(Head& head, Tail&... tail){ scan(head); in(tail...); }\nvoid print(){ putchar(' '); }\nvoid print(bool a){ printf(\"%d\", a); }\nvoid print(int a){ printf(\"%d\", a); }\nvoid print(unsigned a){ printf(\"%u\", a); }\nvoid print(long a){ printf(\"%ld\", a); }\nvoid print(long long a){ printf(\"%lld\", a); }\nvoid print(unsigned long long a){ printf(\"%llu\", a); }\nvoid print(char a){ printf(\"%c\", a); }\nvoid print(char a[]){ printf(\"%s\", a); }\nvoid print(const char a[]){ printf(\"%s\", a); }\nvoid print(float a){ printf(\"%.15f\", a); }\nvoid print(double a){ printf(\"%.15f\", a); }\nvoid print(long double a){ printf(\"%.15Lf\", a); }\nvoid print(const string& a){ for(auto&& i : a) print(i); }\ntemplate<class T> void print(const complex<T>& a){ if(a.real() >= 0) print('+'); print(a.real()); if(a.imag() >= 0) print('+'); print(a.imag()); print('i'); }\ntemplate<class T> void print(const vector<T>&);\ntemplate<class T, size_t size> void print(const array<T, size>&);\ntemplate<class T, class L> void print(const pair<T, L>& p);\ntemplate<class T, size_t size> void print(const T (&)[size]);\ntemplate<class T> void print(const vector<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T> void print(const deque<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T, size_t size> void print(const array<T, size>& a){ print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T, class L> void print(const pair<T, L>& p){ print(p.first); putchar(' '); print(p.second); }\ntemplate<class T, size_t size> void print(const T (&a)[size]){ print(a[0]); for(auto i = a; ++i != end(a); ){ putchar(' '); print(*i); } }\ntemplate<class T> void print(const T& a){ cout << a; }\nint out(){ putchar('\\n'); return 0; }\ntemplate<class T> int out(const T& t){ print(t); putchar('\\n'); return 0; }\ntemplate<class Head, class... Tail> int out(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); return 0; }\n#ifdef DEBUG\ninline ll __lg(ull __n){ return sizeof(ull) * __CHAR_BIT__  - 1 - __builtin_clzll(__n); }\n#define debug(...) { print(#__VA_ARGS__); print(\":\"); out(__VA_ARGS__); }\n#else\n#define debug(...) void(0)\n#endif\nint first(bool i = true){ return out(i?\"first\":\"second\"); }\nint yes(bool i = true){ return out(i?\"yes\":\"no\"); }\nint Yes(bool i = true){ return out(i?\"Yes\":\"No\"); }\nint No(){ return out(\"No\"); }\nint YES(bool i = true){ return out(i?\"YES\":\"NO\"); }\nint NO(){ return out(\"NO\"); }\nint Yay(bool i = true){ return out(i?\"Yay!\":\":(\"); }\nint possible(bool i = true){ return out(i?\"possible\":\"impossible\"); }\nint Possible(bool i = true){ return out(i?\"Possible\":\"Impossible\"); }\nint POSSIBLE(bool i = true){ return out(i?\"POSSIBLE\":\"IMPOSSIBLE\"); }\nvoid Case(ll i){ printf(\"Case #%lld: \", i); }\n\n\n\nstruct UnWeightedEdge{\n    ll to;\n    static constexpr ll cost = 1;\n    UnWeightedEdge(){}\n    UnWeightedEdge(ll to): to(to){}\n    operator ll() const { return to; }\n};\nstruct UnWeightedGraph{\n    using E = UnWeightedEdge;\n    vector<vector<E>> g;\n    UnWeightedGraph(){}\n    UnWeightedGraph(ll n): g(n){}\n    vector<E>& operator[](ll at){ return g[at]; }\n    operator vector<vector<E>>&(){ return g; }\n    auto begin() const { return g.cbegin(); }\n    auto end() const { return g.cend(); }\n    ll size() const { return g.size(); }\n    void resize(ll n){ g.resize(n); }\n    const vector<E>& operator[](ll at) const { return g[at]; }\n    operator const vector<vector<E>>&() const { return g; }\n    void add_edge(ll a, ll b){\n        g[a].emplace_back(b);\n        g[b].emplace_back(a);\n    }\n    void add_directed_edge(ll from, ll to){\n        g[from].emplace_back(to);\n    }\n    template<ll start_index = 1, bool directed = false> void input_graph(ll m){\n        while(m--){\n            ll a, b;\n            scanf(\"%lld%lld\", &a, &b);\n            a -= start_index;\n            b -= start_index;\n            g[a].emplace_back(b);\n            if(!directed) g[b].emplace_back(a);\n        }\n    }\n    template<ll start_index = 1> void input_tree(ll n = -1){ if(n == -1) n = g.size(); input_graph<start_index>(n - 1); }\n};\nstruct T{\n    ll plus;\n    vector<ll>dp;\n    T(){}\n    T(ll a):plus(a>0?0:LINF),dp{a}{}\n    void operator+=(const T&a){\n        ll cut=LINF;\n        rep(a.dp.size())if(a.dp[i]<0){\n            chmin(cut,i+1);\n            break;\n        }\n        plus+=min(cut,a.plus);\n        chmin(cut,a.plus+1);\n        vector<ll>conv(dp.size()+a.dp.size()-1,LINF);\n        rep(dp.size())rep(j,a.dp.size())chmin(conv[i+j],dp[i]+a.dp[j]);\n        if(cut<LINF){\n            while(cut+dp.size()>conv.size())conv.push_back(LINF);\n            rep(dp.size())chmin(conv[i+cut],dp[i]);\n        }\n        swap(dp,conv);\n    }\n    ll val() const {\n        ll cut=LINF;\n        rep(dp.size())if(dp[i]<0){\n            cut=i;\n            break;\n        }\n        return min(cut,plus);\n    }\n};\nsigned main(){\n    LL(n);\n    VEC(ll,a,n);\n    UnWeightedGraph g(n);\n    g.input_tree();\n    vec(T,dp,n);\n    rep(n)dp[i]=T(a[i]);\n    auto dfs = [&](ll from, ll at, auto dfs) -> void {\n        each(i, g[at]) if(i != from){\n            dfs(at, i, dfs);\n            dp[at]+=dp[i];\n        }\n    };\n    dfs(-1, 0, dfs);\n    out(dp[0].val());\n}"
  },
  {
    "language": "C++",
    "code": "「逆にケーブルを出来るだけ繋ぐ」と考えると、負集合は明らかに固めれば良くて、木なので正集合も出来るだけ固めて良いことが分かる。後はこれらをいい感じに繋いでいきたいんですけど...\n  木じゃなくて一次元だったらDP出来るけど、木DPに落とせなくて悲しい"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n\nint n;\nll a[5005],dp[5005][5005],dppos[5005];\nint sub[5005];\nvector<int>edge[5005];\n\nvoid dfs(int v,int u){\n\tsub[v] = 1;\n\tll t[2][5005];\n\tint cur = 0, nxt = 1;\n\t//dp[][]\n\trep(i,2)rep(j,5005) t[i][j] = 1e18;\n\tt[0][0] = 0;\n\trep(i,edge[v].size()){\n\t\tint to = edge[v][i];\n\t\tif(to == u) continue;\n\t\tdfs(to,v);\n\t\trep(i,sub[v]+sub[to]) t[nxt][i] = 1e18;\n\t\trep(i,sub[v]){\n\t\t\tif(t[cur][i] > 5e17) continue;\n\t\t\trepn(j,sub[to]){\n\t\t\t\t//cut\n\t\t\t\tif(dp[to][j] < 0){\n\t\t\t\t\tt[nxt][i+j] = min(t[nxt][i+j], t[cur][i]);\n\t\t\t\t}\n\t\t\t\t//cut2\n\t\t\t\tif(dppos[to] <= n){\n\t\t\t\t\tt[nxt][i+dppos[to]] = min(t[nxt][i+dppos[to]], t[cur][i]);\n\t\t\t\t}\n\t\t\t\t//connect\n\t\t\t\tt[nxt][i+j-1] = min(t[nxt][i+j-1], dp[to][j]+t[cur][i]);\n\t\t\t}\n\t\t}\n\t\tsub[v] += sub[to];\n\t\tswap(cur,nxt);\n\t}\n\trep(i,sub[v]) dp[v][i+1] = t[cur][i]+a[v];\n\tif(a[v] > 0){\n\t\tdppos[v] = 1;\n\t\t//dppos[]\n\t\trep(i,edge[v].size()){\n\t\t\tint to = edge[v][i];\n\t\t\tif(to == u) continue;\n\t\t\tll add = INF;\n\t\t\t{\n\t\t\t\trepn(j,sub[to]){\n\t\t\t\t\t//cut\n\t\t\t\t\tif(dp[to][j] < 0){\n\t\t\t\t\t\tadd = min(add,1LL*j);\n\t\t\t\t\t}\n\t\t\t\t\t//cut2\n\t\t\t\t\tif(dppos[to] <= n){\n\t\t\t\t\t\tadd = min(add,dppos[to]);\n\t\t\t\t\t}\n\t\t\t\t\t//connect\n\t\t\t\t\tif(dppos[to] <= n){\n\t\t\t\t\t\tadd = min(add,dppos[to]-1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdppos[v] += add;\n\t\t}\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\trepn(i,n) scanf(\"%lld\",&a[i]);\n\trep(i,n-1){\n\t\tint a,b; scanf(\"%d%d\",&a,&b);\n\t\tedge[a].pb(b);\n\t\tedge[b].pb(a);\n\t}\n\trep(i,5005)rep(j,5005){\n\t\tdp[i][j] = 1e18;\n\t\tdppos[i] = 1e18;\n\t}\n\tdfs(1,-1);\n\tll ans = dppos[1];\n\tfor(int j=0;j<5005;j++){\n\t\tif(dp[1][j] < 0){\n\t\t\tans = min(ans,1LL*j);\n\t\t\tbreak;\n\t\t}\n\t}\n\tcout << --ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <limits.h>\n#include <math.h>\n#include <functional>\n#include <bitset>\n#include <iomanip>\n#include <cassert>\n\n#define repeat(i,n) for (long long i = 0; (i) < (n); ++ (i))\n#define debug(x) cerr << #x << \": \" << x << '\\n'\n#define debugArray(x,n) for(long long i = 0; (i) < (n); ++ (i)) cerr << #x << \"[\" << i << \"]: \" << x[i] << '\\n'\n#define debugArrayP(x,n) for(long long i = 0; (i) < (n); ++ (i)) cerr << #x << \"[\" << i << \"]: \" << x[i].first<< \" \" << x[i].second << '\\n'\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> Pii;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\nconst ll INF = LLONG_MAX;\nconst ll MOD = 1e9+7;\n\n\nint N;\nll A[5010];\nvector<vint> G;\nll dp[5010][2][5010];\nll tmp[2][5010];\nll size[5010];\n\nvoid dfs(int v,int par){\n  size[v]=1;\n  dp[v][0][0] = A[v]>0;\n  dp[v][1][0] = A[v];\n  for(int chi:G[v])if(chi!=par){\n    dfs(chi,v);\n    fill(tmp[0],tmp[0]+N,0);\n    fill(tmp[1],tmp[1]+N,INF);\n    for(int k=size[v]-1;k>=0;k--){\n      for(int l=size[chi]-1;l>=0;l--){\n        if(dp[v][0][k]&&dp[chi][1][l]<0){\n          tmp[0][k+l+1]=1;\n        }\n        if(dp[v][0][k]&&dp[chi][0][l]){\n          tmp[0][k+l]=1;\n        }\n        if(dp[v][1][k]<INF&&dp[chi][0][l]){\n          tmp[1][k+l+1]=min(tmp[1][k+l+1],dp[v][1][k]);\n        }\n        if(dp[v][1][k]<INF&&dp[chi][1][l]<INF){\n          tmp[1][k+l]=min(tmp[1][k+l],dp[v][1][k]+dp[chi][1][l]);\n        }\n      }\n    }\n    swap(dp[v],tmp);\n    size[v]+=size[chi];\n  }\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cin>>N;\n  repeat(i,N){\n    cin>>A[i];\n  }\n  G.resize(N);\n  repeat(i,N-1){\n    int u,v;cin>>u>>v;\n    u--;v--;\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  dfs(0,-1);\n  ll ans;\n  for(ans=0;ans<N-1;ans++){\n    if(dp[0][0][ans]||dp[0][1][ans]<0){\n      break;\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 5000 + 5;\nconst long long inf = 1e18;\nvector<int> g[maxn];\nint a[maxn], sz[maxn];\nlong long dp[2][maxn][maxn];\n\nvoid dfs(int x, int p) {\n    sz[x] = 1;\n    for (int i = 0; i < maxn; ++i) {\n        dp[0][x][i] = inf;\n        dp[1][x][i] = inf;\n    }\n    dp[a[x] < 0][x][0] = a[x];\n    for (int i = 0; i < (int)g[x].size(); ++i) {\n        int u = g[x][i];\n        if (u == p) continue;\n        dfs(u, x);\n        vector<vector<long long>> nxt(2, vector<long long>(sz[x] + sz[u] + 1, inf));\n        for (int i = 0; i <= sz[u]; ++i) {\n            for (int j = 0; j <= sz[x]; ++j) {\n                for (int a = 0; a < 2; ++a) {\n                    for (int b = 0; b < 2; ++b)\n                        nxt[a || b][i + j] = min(nxt[a || b][i + j], dp[a][u][i] + dp[b][x][j]);\n                }\n            }\n        }\n        sz[x] += sz[u];\n        for (int i = 0; i <= sz[x]; ++i) {\n            dp[0][x][i] = nxt[0][i];\n            dp[1][x][i] = nxt[1][i];\n        }\n    }\n    for (int i = sz[x] - 1; i >= 0; --i) {\n        if (dp[0][x][i] < inf) \n            dp[0][x][i + 1] = min(dp[0][x][i + 1], 0ll);\n        if (dp[1][x][i] < 0) \n            dp[0][x][i + 1] = min(dp[0][x][i + 1], 0ll);\n    }\n}\n\nint main() {\n    int n; scanf(\"%d\", &n);\n    for (int i = 0; i < n; ++i) scanf(\"%d\", &a[i]);\n    for (int i = 0; i < n - 1; ++i) {\n        int x, y; scanf(\"%d%d\", &x, &y);\n        --x, --y;\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    dfs(0, -1);\n    for (int i = 0; i <= n; ++i) {\n        if (dp[0][0][i] < inf || dp[1][0][i] < 0) {\n            printf(\"%d\\n\", i);\n            return 0;\n        }\n    }\n    throw;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\nconst int N = 5010;\nconst ll INF = 1e18;\nint n;\nll a[N];\nVI e[N];\nvoid out(VVL &dp){\n    REP(f,2){\n        REP(i,dp[f].size()) cout << dp[f][i] << \" \";\n        cout << endl;\n    }\n    cout << endl;\n}\nvoid dfs(int now, int past, VVL &dp){\n    dp.assign(2, VL(1, INF));\n    if (a[now] > 0) dp[1][0] = a[now];\n    else dp[0][0] = a[now];\n    for (int next : e[now]){\n        if (next == past) continue;\n        VVL dp2(2);\n        dfs(next, now, dp2);\n        int n = dp[0].size(), m = dp2[0].size();\n        VVL dp_next(2, VL(n + m, INF));\n        REP(i,n) REP(f,2) REP(j,m) REP(g,2){\n            if (dp[f][i] == INF || dp2[g][j] == INF) continue;\n            dp_next[f & g][i + j] = min(dp_next[f & g][i + j], dp[f][i] + dp2[g][j]);\n            if (g || dp2[g][j] < 0) dp_next[f][i + j + 1] = min(dp_next[f][i + j + 1], dp[f][i]);\n        }\n        // out(dp);\n        // out(dp2);\n        // out(dp_next);\n        dp.swap(dp_next);\n    }\n}\nint main() {\n    cin >> n;\n    REP(i,n) a[i] = in();\n    REP(i,n-1){\n        int u = in() - 1, v = in() - 1;\n        e[u].push_back(v);\n        e[v].push_back(u);\n    }\n    VVL dp(2);\n    dfs(0, -1, dp);\n    int ans = n;\n    REP(i,n){\n        if (dp[0][i] < 0 || dp[1][i] < INF) ans = min(ans, i);\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████   \n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n#include \"bits/stdc++.h\"\nusing namespace std;\n#define MOD 1000000007\n#define INF 1LL<<60\n#define fs first\n#define sc second\n#define pb push_back\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i = (b-1);i>=a;i--)\n#define REP(i,n)  FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) (a)<=(i) && (i)<(b)\n#define debug(x)  cout << #x << \" = \" << (x) << endl;\n#define SP << \" \" << \ntypedef pair<int,int> P;\ntypedef vector<vector<P> > Graph;\n\nconst int NMAX = 1e4;\nvector<int> edge[NMAX],used(NMAX,0);\nvector<int> cost(NMAX,0),pos(NMAX,1);\nvector<int> a(NMAX);\nint ans = 0;\n\nint dfs2(int no){\n  used[no]++;\n  if(pos[no]){\n    return cost[no];\n  }\n  vector<int> tmp;\n  for(auto to:edge[no]){\n    if(used[to]) continue;\n    if(cost[to] < 0) continue;\n    if(pos[no] == 0) tmp.pb(dfs2(to));\n  }\n  sort(tmp.begin(),tmp.end());\n  reverse(tmp.begin(),tmp.end());\n  int id = 0;\n  while(cost[no] >= 0){\n    cost[no] -= tmp[no];\n    id++;\n    ans++;\n  }\n}\n\nvoid dfs(int no){\n  used[no]++;\n  for(auto to:edge[no]){\n    if(used[to]) continue;\n    dfs(to);\n    cost[no] += cost[to];\n    if(pos[to] == 0) pos[no] = 0;\n  }\n}\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);  \n\n  int n;\n  cin >> n;\n  \n  REP(i,n) cin >> a[i];\n  \n  REP(_,n-1){\n    int x,y;\n    cin >> x >> y;\n    x--;y--;\n    edge[x].pb(y);\n    edge[y].pb(x);\n  }\n\n  REP(i,n){\n    cost[i] = a[i];\n    if(a[i] < 0) pos[i] = 0;\n  }\n\n  dfs(0);\n  //REP(i,n) cout << cost[i] << \" \" << pos[i] << endl;\n\n  REP(i,n) used[i] = 0;\n  dfs2(0);\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define rng(a) a.begin(),a.end()\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\n#define dame { puts(\"-1\"); return 0;}\n#define yn {puts(\"Yes\");}else{puts(\"No\");}\n#define MAX_N 6005\n\n/*\n    Attack to a Tree\n*/\n\n\nvector<int> pre_G[MAX_N];\nvector<int> G[MAX_N];\nint par_[MAX_N];\nint flag_netsukigi[MAX_N];\nvoid make_netsukigi(int r){\n    rep(i,MAX_N){\n        G[i].clear();\n        par_[i] = 0;\n        flag_netsukigi[i] = 0;\n    }\n    queue<int> que;\n    que.push(r);\n    flag_netsukigi[r] = 1;\n    par_[r] = -1;\n\n    while(que.size() > 0){\n        int x = que.front();\n        que.pop();\n        flag_netsukigi[x] = 1;\n        rep(i,pre_G[x].size()){\n            if(flag_netsukigi[pre_G[x][i]] == 0){\n                par_[pre_G[x][i]] = x;\n                G[x].push_back(pre_G[x][i]);\n                que.push(pre_G[x][i]);\n            }\n        }\n    }\n}\n\nint n;\nll a[MAX_N];\nll u[MAX_N], v[MAX_N];\nvector<int> son[MAX_N];\nll dp[MAX_N][MAX_N][2];\nconst ll inf = 1001001001001001001;\n\nint main() {\n    cin >> n;\n    rep(i,n)cin >> a[i];\n    rep(i,n-1){\n        cin >> u[i] >> v[i];\n        u[i]--; v[i]--;\n        pre_G[u[i]].push_back(v[i]);\n        pre_G[v[i]].push_back(u[i]);\n    }\n\n    make_netsukigi(0);\n\n    rep(i,n){\n        rep(j,n){\n            rep(k,2){\n                dp[i][j][k] = inf;\n            }\n        }\n    }\n\n    queue<int> que;\n    rep(i,n){\n        if(G[i].empty()){\n            que.push(i);\n            if(a[i] < 0){\n                dp[i][0][1] = a[i];\n            }else{\n                dp[i][0][0] = a[i];\n            }\n        }\n    }\n\n    while(que.size() > 0){\n        int x = que.front();\n        que.pop();\n        int y = par_[x];\n        if(y == -1)break;\n        son[y].push_back(x);\n        if(son[y].size() == G[y].size()){\n            que.push(y);\n            // DP計算\n            rep(i,son[y].size()){\n                int z = son[y][i];\n                ll dp2[MAX_N][2];\n                rep(j,MAX_N)rep(k,2)dp2[j][k] = inf;\n                if(i == 0){\n                    if(a[y] < 0){\n                        // 切らない\n                        rep(j,n){\n                            dp2[j][1] = min(dp2[j][1], dp[z][j][0] + a[y]);\n                            dp2[j][1] = min(dp2[j][1], dp[z][j][1] + a[y]);\n                        }\n                        // 切る\n                        srep(j,1,n){\n                            if(dp[z][j-1][0] < inf) dp2[j][1] = min(dp2[j][1], a[y]);\n                            if(dp[z][j-1][1] < 0) dp2[j][1] = min(dp2[j][1], a[y]);\n                        }\n                    }else{\n                        // 切らない\n                        rep(j,n){\n                            dp2[j][0] = min(dp2[j][0], dp[z][j][0] + a[y]);\n                            dp2[j][1] = min(dp2[j][1], dp[z][j][1] + a[y]);\n                        }\n                        // 切る\n                        srep(j,1,n){\n                            if(dp[z][j-1][0] < inf) dp2[j][0] = min(dp2[j][0], a[y]);\n                            if(dp[z][j-1][1] < 0) dp2[j][0] = min(dp2[j][0], a[y]);\n                        }\n                    }\n                }else{\n                    // 切らない\n                    rep(j,n){\n                        rep(k,n){\n                            if(j+k>=n)break;\n                            dp2[j+k][0] = min(dp2[j+k][0], dp[y][j][0] + dp[z][k][0]);\n                            dp2[j+k][1] = min(min(dp2[j+k][1], dp[y][j][1] + dp[z][k][1]), min(dp[y][j][1] + dp[z][k][0], dp[y][j][0] + dp[z][k][1]));\n                        }\n                    }\n                    // 切る\n                    rep(j,n){\n                        rep(k,n){\n                            if(j+k+1>=n)break;\n                            if(dp[z][k][0] < inf || dp[z][k][1] < 0){\n                                dp2[j+k+1][0] = min(dp2[j+k+1][0], dp[y][j][0]);\n                                dp2[j+k+1][1] = min(dp2[j+k+1][1], dp[y][j][1]);\n                            }\n                        }\n                    }\n                }\n                rep(j,MAX_N)rep(k,2)dp[y][j][k] = dp2[j][k];\n            }\n        }\n    }\n\n    int ans = 1001001;\n    rep(j,n){\n        if(dp[0][j][1] < 0){\n            ans = min(ans, j);\n        }\n        if(dp[0][j][0] < inf){\n            ans = min(ans, j);\n        }\n    }\n\n    cout << ans << endl;\n    return 0;\n}\n \n \n"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n// #include<deque>\n// #include<multiset>\n// #include<bitset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\n// #undef DEBUG\n// #define DEBUG\n// DEBUG {{{\n#include <array>\n#include <deque>\n#include <iostream>\n#include <list>\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <valarray>\n#include <vector>\n// clang-format off\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\", \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream &o, tuple<T...> const &t){ o << \"(\"; _ot<0>(o, t); o << \")\"; return o; }\ntemplate<class T, class U> ostream & operator<<(ostream &o, pair<T, U> const &p) { o << \"(\" << p.first << \", \" << p.second << \")\"; return o; }\ntemplate < class T > ostream &operator<<(ostream &o, const stack<T> &a) { o << \"{\"; for(auto tmp = a; tmp.size(); tmp.pop()) o << (a.size() == tmp.size() ? \"\" : \", \") << tmp.top(); o << \"}\"; return o; }\ntemplate <class T, class Container, class Compare > ostream &operator<<(ostream &os, priority_queue<T, Container, Compare> a) { os << \"{ (top) \"; while(a.size()) os << a.top() << (a.size() == 1 ? \"\" : \", \"), a.pop(); os << \" }\"; return os; }\ntemplate <class T, class Container > ostream &operator<<(ostream &os, queue<T, Container> a) { os << \"{ \"; while(a.size()) os << a.front() << (a.size() == 1 ? \"\" : \", \"), a.pop(); os << \" }\"; return os; }\n#ifdef DEBUG\n#if !defined(DEBUG_OUT)\n#define DEBUG_OUT cerr\n#endif\n#if !defined(DEBUG_LEFT)\n#define DEBUG_LEFT \"\\e[1;36m\"\n#endif\n#if !defined(DEBUG_RIGHT)\n#define DEBUG_RIGHT \":\\e[m\"\n#endif\n#define dump(...) [&](){auto __debug_tap=make_tuple(__VA_ARGS__);DEBUG_OUT<<DEBUG_LEFT<<__LINE__ << DEBUG_RIGHT << \" \" <<#__VA_ARGS__<<\" = \"<<__debug_tap<<endl;}()\ntemplate < class T > inline void dump2D(T &d, size_t sizey, size_t sizex) { for(size_t i = 0; i < sizey; i++) { DEBUG_OUT << \"\\t\"; for(size_t j = 0; j < sizex; j++) DEBUG_OUT << d[i][j] << (j + 1 == sizex ? \"\" : \"\\t\"); DEBUG_OUT << endl; } }\ntemplate < class T > inline void dump1D(T &d, size_t sizey) { for(size_t i = 0; i < sizey; i++) { DEBUG_OUT << d[i] << (i + 1 == sizey ? \"\" : \" \"); } DEBUG_OUT << endl; }\ntemplate < class T, class = typename iterator_traits< decltype(begin(T())) >::value_type, class = typename enable_if<!is_same<T, string>::value>::type > ostream &operator<<(ostream &o, const T &a) { o << \"{\"; for(auto ite = begin(a); ite != end(a); ++ite) o << (ite == begin(a) ? \"\" : \", \") << *ite; o << \"}\"; return o; }\n#else\n#define dump(...) (42)\n#define dump2D(...) (42)\n#define dump1D(...) (42)\ntemplate < class T, class = typename iterator_traits< decltype(begin(T())) >::value_type, class = typename enable_if<!is_same<T, string>::value>::type > ostream &operator<<(ostream &o, const T &a) { for(auto ite = begin(a); ite != end(a); ++ite) o << (ite == begin(a) ? \"\" : \" \") << *ite; return o; }\n#endif\n// clang-format on\n// }}}\n\n\nconst int N = 5000;\nvector<int> g[N];\nint a[N];\nint n;\nconstexpr ll inf = 1e18;\n\n// smin, smax {{{\n// clang-format off\ntemplate < class T, class U > inline void smin(T &a, const U &b) { a = a < (T) b ? a : b; }\ntemplate < class T, class U > inline void smax(T &a, const U &b) { a = a < (T) b ? b : a; }\n// clang-format on\n// }}}\n\ntemplate<class T>\nT mrg(T & a, T & b) {\n  // dump(a);\n  // dump(b);\n  T c(2, vector<ll>(a[0].size() + b[0].size() - 1, inf));\n  for(int i = 0; i < 2; i++) for(int j = 0; j < 2; j++)\n    for(int k = 0; k < a[0].size(); k++) for(int l = 0; l < b[0].size(); l++) {\n    // dump(i, j, k, l, a[i][k] + b[j][l]);\n    if(a[i][k] != inf && b[j][l] != inf) smin(c[i&j][k + l], a[i][k] + b[j][l]);\n  }\n  return c;\n}\n\ntemplate<class T>\nvoid th(T & a) {\n  int m = a[0].size();\n  a[0].push_back(inf);\n  a[1].push_back(inf);\n  for(int i = 0; i < m; i++){\n    if(a[0][i] < 0 || a[1][i] != inf) {\n      smin(a[1][i + 1], 0);\n    }\n  }\n}\n\nvector<vector<ll>> dfs(int i, int p) {\n  vector<vector<ll>> v{ {inf}, {inf}, };\n  if(a[i] < 0) v[0][0] = a[i];\n  if(a[i] > 0) v[1][0] = a[i];\n  for(int j : g[i]) if(j != p) {\n    auto w = dfs(j, i);\n    v = mrg(v, w);\n  }\n  // dump(i);\n  // dump(v);\n  th(v);\n  // dump(v);\n  return v;\n}\n\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  cin >> n;\n  for(int i = 0; i < n; i++) cin >> a[i];\n  for(int i = 0; i < n - 1; i++) {\n    int a, b; cin >> a >> b;\n    a--; b--;\n    g[a].emplace_back(b);\n    g[b].emplace_back(a);\n  }\n  auto v = dfs(0, -1);\n  // dump(v);\n  // dump(v[0].size());\n  assert(v[0].size() == v[1].size());\n  for(int i = 0; i < v[0].size(); i++) {\n    if(v[0][i] < 0 || v[1][i] != inf) {\n      cout << i << endl;\n      return 0;\n    }\n  }\n  assert(0);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nint N, A[5010], sz[5010], dp[5010][5010][2], tmp[2][5010][2];\nvector<int> G[5010];\n\nvoid dfs(int cur, int par=-1) {\n    sz[cur] = 1;\n    for(int to : G[cur]) {\n        if(to == par) continue;\n        dfs(to, cur);\n        sz[cur] += sz[to];\n    }\n}\n\nvoid solve(int cur, int par=-1) {\n    int cnt = 0;\n    for(auto to : G[cur]) {\n        if(to == par) continue;\n        solve(to, cur);\n        cnt++;\n    }\n    \n    // cur を根とする部分木には sz[cur] 個のノードがある\n    // こたえは sz[cur] - 1 個以下にしかならない\n    for(int i=0; i<=sz[cur]; i++) {\n        for(int k=0; k<2; k++) {\n            tmp[k][i][0] = INF;\n            tmp[k][i][1] = false;\n        }\n    }\n\n    // (偶奇, 総和, mode)\n    tmp[0][0][0] = A[cur];\n    tmp[0][0][1] = (A[cur] > 0);\n    int pari = 0, sum = 0;\n    \n    for(int to : G[cur]) {\n        if(to == par) continue;\n        int now = pari, nxt = 1 - pari;\n        pari = 1 - pari;\n        for(int i=sum; i>=0; i--) {\n            \n            // 合計は sz[cur]-1 以下\n            for(int j=sz[to]-1; j>=0; j--) {\n                // 0: その回数を満たす中で総和が最小のもの\n                // j 回切った component とつなげるとき\n                // fprintf(stderr, \"nxt = %lld, i+j = %lld\\n\", nxt, i+j);\n                if(tmp[now][i][0] != INF) {\n                    // fprintf(stderr, \"tmp[now][%lld][0] = %lld, dp[%lld][%lld][0] = %lld\\n\", i, tmp[now][i][0], to, j, dp[to][j][0]);\n                    chmin(tmp[nxt][i+j][0], tmp[now][i][0] + dp[to][j][0]);\n                }\n                else {\n                    // fprintf(stderr, \"i = %lld, j = %lld, tmp[%lld][%lld][0] = INF\\n\", i, j, now, i);\n                }\n                \n                // j 回切った component とつなげないとき\n                // 0: dp[to][j][0] が負のときのみ可能\n                // 1: dp[to][j][1] が true のときのみ可能\n                if(i+j+1 <= sz[cur]-1) {\n                    if(dp[to][j][0] < 0) {\n                        chmin(tmp[nxt][i+j+1][0], tmp[now][i][0]);\n                    }\n                    if(dp[to][j][1] == true) {\n                        chmin(tmp[nxt][i+j+1][0], tmp[now][i][0]);\n                    }\n                }\n                \n                // 1: その回数を満たして全部正にできる？\n                // 正の component とつなげるとき\n                tmp[nxt][i+j][1] |= tmp[now][i][1] & dp[to][j][1];\n\n                // 正の component とつなげないとき\n                // 0: dp[to][j][0] が負のときのみ可能\n                // 1: to[to][j][1] が true のときのみ可能\n                if(i+j+1 <= sz[cur]-1) {\n                    if(dp[to][j][0] < 0 or dp[to][j][1] == true) {\n                        tmp[nxt][i+j+1][1] |= tmp[now][i][1];\n                    }\n                }\n            }\n        }\n        sum += sz[to];\n        for(int i=0; i<=sum; i++) {\n            tmp[now][i][0] = INF;\n            tmp[now][i][1] = false;\n        }        \n    }\n\n    for(int i=0; i<sz[cur]; i++) {\n        dp[cur][i][0] = tmp[cnt%2][i][0];\n        dp[cur][i][1] = tmp[cnt%2][i][1];\n    }\n    /*\n    fprintf(stderr, \"# debug: cur = %lld (size = %lld)\\n\", cur, sz[cur]);\n    fprintf(stderr, \"zro:\");\n    for(int i=0; i<sz[cur]; i++) {\n        fprintf(stderr, \" %lld\", dp[cur][i][0]);\n    }\n    fprintf(stderr, \"\\n\");\n    fprintf(stderr, \"one:\");\n    for(int i=0; i<sz[cur]; i++) {\n        fprintf(stderr, \" %lld\", dp[cur][i][1]);\n    }\n    fprintf(stderr, \"\\n\");\n    */\n}\n\nsigned main() {\n    cin >> N;\n    for(int i=0; i<N; i++) {\n        for(int j=0; j<N; j++) {\n            // 最小値なので\n            dp[i][j][0] = INF;\n        }\n    }\n    \n    for(int i=0; i<N; i++) {\n        cin >> A[i];\n    }\n    for(int i=0; i<N-1; i++) {\n        int u, v; cin >> u >> v;\n        u--; v--;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n\n    dfs(0);\n    solve(0);\n    int ans = INF;\n    for(int i=0; i<=N; i++) {\n        if(dp[0][i][0] < 0) ans = min(ans, i);\n        if(dp[0][i][1] == true) ans = min(ans, i);\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid chmin(int64_t& a, int64_t b){\n    a = min(a, b);\n}\n\nint N;\nint64_t A[5000];\nvector<int> edges[5000];\n\nvector<vector<int64_t>> dp[5000];\nint sz[5000];\n\nconst int64_t INF = 1e18;\n\nvoid dfs(int i, int p){\n    dp[i] = vector<vector<int64_t>>(N, vector<int64_t>(2, INF));\n    dp[i][0][(A[i] < 0)] = A[i];\n    for(int j : edges[i]) if(j != p){\n        dfs(j, i);\n        vector<vector<int64_t>> dp2(N, vector<int64_t>(2, INF));\n        for(int n1=0; n1<=sz[i]; n1++) for(int n2=0; n2<=sz[j]; n2++) for(int k1=0; k1<2; k1++) for(int k2=0; k2<2; k2++){\n            int64_t v1 = dp[i][n1][k1], v2 = dp[j][n2][k2];\n            if(max(v1, v2) == INF) continue;\n            chmin(dp2[n1+n2][k1|k2], v1+v2);\n            if(k2 == 0 || v2 < 0) chmin(dp2[n1+n2+1][k1], v1);\n        }\n        dp[i] = dp2;\n        sz[i] += sz[j] + 1;\n    }\n}\n\nint main(){\n    cin >> N;\n    for(int i=0; i<N; i++) cin >> A[i];\n    for(int i=0; i<N-1; i++){\n        int a, b;\n        cin >> a >> b;\n        edges[a-1].push_back(b-1);\n        edges[b-1].push_back(a-1);\n    }\n\n    dfs(0, -1);\n    for(int j=0; j<N; j++) if(dp[0][j][0] < INF || dp[0][j][1] < 0){\n        cout << j << endl;\n        return 0;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\nconst ll INF=1e17;\nint main(){\n    int n;\n    cin>>n;\n    vector<ll> a(n);\n    for(int i=0;i<n;i++){\n        cin>>a[i];        \n    }\n    vector<vector<int>> g(n);\n    for(int i=0;i<n-1;i++){\n        int u,v;\n        cin>>u>>v;\n        u--,v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    \n    vector<vector<ll>> dp(n);\n    auto cmin=[](ll &lhs,ll rhs){\n        lhs=min(lhs,rhs);\n    };\n    function<int(int,int)> dfs2=[&](int v,int pre){\n        int oki=n;\n        for(int i=0;i<dp[v].size();i++){\n            if(dp[v][i]<0){\n                oki=i;\n                break;\n            }\n        }\n        if(a[v]<0){\n            return 1+oki;\n        }\n        int sum=0;\n        for(auto &to:g[v]){\n            if(to==pre) continue;\n            sum+=dfs2(to,v);\n        }\n        return min(oki+1,sum);\n    };\n    int y=-1;\n    function<void(int,int)> dfs=[&](int v,int pre){\n        int sz=1;\n        int cnt=0;\n        for(auto to:g[v]){\n            if(to==pre) continue;\n            dfs(to,v);\n            sz+=dp[to].size();\n            cnt++;\n        }\n        vector<vector<ll>> dp2(cnt+1);\n        dp2[0].assign(1,a[v]);\n        int idx=0;\n        for(auto to:g[v]){\n            if(to==pre) continue;\n            for(int i=0;i<dp2[idx].size();i++){\n                for(int j=0;j<dp[to].size();j++){\n                    while(dp2[idx+1].size()<=i+j+1){\n                        dp2[idx+1].push_back(INF);\n                    }\n                    cmin(dp2[idx+1][i+j],dp2[idx][i]+dp[to][j]);\n                    if(dp[to][j]<0){\n                        cmin(dp2[idx+1][i+j+1],dp2[idx][i]);\n                    }\n                }\n            }\n            idx++;\n        }\n        dp[v]=dp2[idx];\n        if(a[v]>0 && (pre==-1 || a[pre]<0)){\n            int x=dfs2(v,pre);\n            while(dp[v].size()<=x+1){\n                dp[v].push_back(INF);\n            }\n            if(pre==-1) y=x;\n            cmin(dp[v][x+1],0);\n        }\n        return;\n    };\n    \n    dfs(0,-1);\n    for(int i=0;i<dp[0].size();i++){\n        if(dp[0][i]<0 || y==i){\n            cout<<i<<endl;\n            return 0;\n        }\n    }\n    \n    return 1;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nconst int INF = (1<<30);\nconst ll INFLL = (1ll<<60);\nconst ll MOD = (ll)(1e9+7);\n\n#define l_ength size\n\nvoid mul_mod(ll& a, ll b){\n\ta *= b;\n\ta %= MOD;\n}\n\nvoid add_mod(ll& a, ll b){\n\ta = (a<MOD)?a:(a-MOD);\n\tb = (b<MOD)?b:(b-MOD);\n\ta += b;\n\ta = (a<MOD)?a:(a-MOD);\n}\n\nint n,ch[5252];\nvector<int> g[5252];\nll a[5252],dp[2][5252][5252],sp[2][5252][5252];\n\nvoid solve(int u, int p = -1){\n\tint i,j,k,v;\n\tfor(i=(g[u].l_ength()-1); i>=0; --i){\n\t\tv = g[u][i];\n\t\tif(v==p){\n\t\t\tcontinue;\n\t\t}\n\t\tsolve(v,u);\n\t}\n\tfor(i=(g[u].l_ength()-1); i>=0; --i){\n\t\tv = g[u][i];\n\t\tif(v==p){\n\t\t\tg[u].erase(g[u].begin()+i);\n\t\t\tbreak;\n\t\t}\n\t}\n\tsp[0][0][1] = a[u];\n\tsp[1][0][1] = (a[u]>0ll)?a[u]:INFLL;\n\tch[u] = 1;\n\tfor(i=0; i<g[u].l_ength(); ++i){\n\t\tv = g[u][i];\n\t\tfor(j=1; j<=ch[u]; ++j){\n\t\t\tfor(k=1; k<=ch[v]; ++k){\n\t\t\t\tsp[0][i+1][j+k-1] = INFLL;\n\t\t\t\tsp[0][i+1][j+k] = INFLL;\n\t\t\t\tsp[1][i+1][j+k-1] = INFLL;\n\t\t\t\tsp[1][i+1][j+k] = INFLL;\n\t\t\t}\n\t\t}\n\t\tfor(j=1; j<=ch[u]; ++j){\n\t\t\tfor(k=1; k<=ch[v]; ++k){\n\t\t\t\tsp[0][i+1][j+k-1] = min(sp[0][i+1][j+k-1],sp[0][i][j]+dp[0][v][k]);\n\t\t\t\tsp[1][i+1][j+k-1] = min(sp[1][i+1][j+k-1],sp[1][i][j]+dp[1][v][k]);\n\t\t\t\tif(dp[0][v][k] < 0ll || dp[1][v][k] < INFLL){\n\t\t\t\t\tsp[0][i+1][j+k] = min(sp[0][i+1][j+k],sp[0][i][j]);\n\t\t\t\t\tsp[1][i+1][j+k] = min(sp[1][i+1][j+k],sp[1][i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tch[u] += ch[v];\n\t}\n\tfor(i=0; i<=ch[u]; ++i){\n\t\tdp[0][u][i] = sp[0][g[u].l_ength()][i];\n\t\tdp[1][u][i] = sp[1][g[u].l_ength()][i];\n\t}\n}\n\nint main(void){\n\tint i,u,v;\n\tcin >> n;\n\tfor(i=0; i<n; ++i){\n\t\tcin >> a[i];\n\t}\n\tfor(i=1; i<n; ++i){\n\t\tcin >> u >> v;\n\t\t--u; --v;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\tsolve(0);\n\tfor(i=1; i<=ch[0]; ++i){\n\t\tif(dp[0][0][i] < 0ll || dp[1][0][i] < INFLL){\n\t\t\tcout << (i-1) << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nint N, A[5010];\nvector<int>to[100005];\nvector<pair<long long, int>> dp[5010];\nint sz[5010];\n/*\ndp[cu][cut] := 頂点cuを根とした部分木について辺の削除をcut回行ったときに\n{根と連結している頂点の電力の総和の最小値, \n根と連結しているグループが全てバッテリーにできるか}\n*/\nvoid marge(int cu, int to) {\n\tvector<pair<long long, int>>res(sz[cu] + sz[to] + 1, {1e18,0});\n\tfor (int i = 0;i<sz[cu];++i) {\n\t\tfor (int j = 0;j<sz[to]; ++j) {\n\t\t\t//\n\t\t\tres[i + j].first = min(res[i + j].first, dp[cu][i].first + dp[to][j].first);\n\t\t\tif (dp[cu][i].second and dp[to][j].second) { \n\t\t\t\tres[i + j].second = 1; \n\t\t\t}\n\t\t\t//\n\t\t\tif (dp[to][j].first < 0 or dp[to][j].second) {\n\t\t\t\tres[i + j + 1].first = min(res[i + j + 1].first, dp[cu][i].first);\n\t\t\t}\n\t\t\tif ((dp[to][j].first < 0 or dp[to][j].second) and dp[cu][i].second) { \n\t\t\t\tres[i + j + 1].second = 1; \n\t\t\t}\n\t\t}\n\t}\n\tswap(dp[cu], res);\n\tsz[cu] += sz[to] + 1;\n}\n\nvoid dfs(int v, int p = -1) {\n\tsz[v] = 1;\n\tdp[v].resize(1);\n\tdp[v][0] = { A[v], 0 < A[v] };\n\tfor (int e : to[v]) {\n\t\tif (p == e) {\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(e, v);\n\t\tmarge(v, e);\n\t}\n}\n\n\nint main() {\n\tint N;\n\tcin >> N;\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> A[i];\n\t}\n\tfor (int n = 0; n < N - 1; ++n) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--;\n\t\tb--;\n\t\tto[a].push_back(b);\n\t\tto[b].push_back(a);\n\t}\n\tdfs(0);\n\tint ans = 1e9;\n\tfor (int i = 0; i < sz[0]; ++i) {\n\t\tif (dp[0][i].first < 0 or dp[0][i].second) {\n\t\t\tans = min(ans, i);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF (1LL << 60)\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n\nusing namespace std;\n\ntemplate<typename S,typename T>auto&operator<<(ostream&o,pair<S,T>p){return o<<\"{\"<<p.fi<<\",\"<<p.se<<\"}\";}\ntemplate<typename T>auto&operator<<(ostream&o,set<T>s){for(auto&e:s)o<<e<<\" \";return o;}\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,priority_queue<S,T,U>q){while(!q.empty())o<<q.top()<<\" \",q.pop();return o;}\ntemplate<typename K,typename T>auto&operator<<(ostream&o,map<K,T>m){for(auto&e:m)o<<e<<\" \";return o;}\ntemplate<typename T>auto&operator<<(ostream&o,vector<T>v){for(auto&e:v)o<<e<<\" \";return o;}\nvoid ashow(){cout<<endl;}template<typename T,typename...A>void ashow(T t,A...a){cout<<t<<\" \";ashow(a...);}\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\n\nconst int MAX_N = 5005;\n\nvector<int> G[MAX_N];\nll a[MAX_N];\n\nvl dfs(int u, int p)\n{\n    vl dp(2);\n    if(a[u] < 0){\n        dp[0] = INF;\n    }else{\n        dp[0] = 1;\n    }\n    dp[1] = a[u];\n    each(v, G[u]){\n        if(v != p){\n            auto res = dfs(v, u);\n            vl ndp(len(dp)+len(res)-1, INF);\n            if(res[0] < INF){\n                cmn(ndp[0], dp[0] + res[0] - 1);\n            }else{\n                int num = -1;\n                srep(k,1,len(res)){\n                    if(res[k] < 0){\n                        num = k;\n                        break;\n                    }\n                }\n                cmn(ndp[0], dp[0] + num);\n            }\n            srep(j,1,len(dp)){\n                if(res[0] < INF){\n                    cmn(ndp[j+res[0]], dp[j]);\n                }\n                srep(k,1,len(res)){\n                    cmn(ndp[j+k-1], dp[j]+res[k]);\n                }\n            }\n            swap(dp, ndp);\n        }\n    }\n    return dp;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    rep(i,n){\n        cin >> a[i];\n    }\n    rep(i,n-1){\n        int u, v;\n        cin >> u >> v;\n        G[u-1].pb(v-1), G[v-1].pb(u-1);\n    }\n    auto res = dfs(0, -1);\n    ll ans = INF;\n    if(res[0] < INF) ans = res[0];\n    srep(i,1,len(res)){\n        if(res[i] < 0){\n            cmn(ans, (ll)i);\n            break;\n        }\n    }\n    cout << ans-1 << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define all(vec) vec.begin(), vec.end()\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\nconst ll INF = 1LL << 30;\nconst ll LINF = 1LL << 60;\nconst double eps = 1e-9;\nconst ll MOD = 998244353LL;\ntemplate <typename T>\nvoid chmin(T& a, T b) {\n    a = min(a, b);\n};\ntemplate <typename T>\nvoid chmax(T& a, T b) {\n    a = max(a, b);\n};\ntemplate <typename T>\nvector<T> make_v(size_t a) {\n    return vector<T>(a);\n}\ntemplate <typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\ntemplate <typename T, typename V>\ntypename enable_if<is_class<T>::value == 0>::type fill_v(T& t, const V& v) {\n    t = v;\n}\ntemplate <typename T, typename V>\ntypename enable_if<is_class<T>::value != 0>::type fill_v(T& t, const V& v) {\n    for(auto& e : t) {\n        fill_v(e, v);\n    }\n};\nint n;\nvector<ll> a;\nvector<int> siz;\nvector<vector<int>> G;\nvector<vector<vector<ll>>> dp;\nvoid dfs(int i, int p) {\n    for(auto e : G[i]) {\n        if(e == p) {\n            continue;\n        }\n        dfs(e, i);\n        siz[i] += siz[e];\n    }\n    dp[i].resize(siz[i] + 10);\n    for(int j = 0; j < siz[i] + 10; j++) {\n        dp[i][j].resize(2, LINF);\n    }\n    int nn = G[i].size() - 1;\n    if(i == 0) {\n        nn++;\n    }\n    auto f = make_v<ll>(nn + 10, siz[i] + 10, 2);\n    fill_v(f, LINF);\n    f[0][0][0] = 0;\n    f[0][0][1] = 0;\n    int id = 1;\n    for(auto e : G[i]) {\n        if(e == p) {\n            continue;\n        }\n        for(int j = 0; j <= siz[i]; j++) {\n            for(int k = j - siz[e]; k <= j; k++) {\n                if(k < 0) {\n                    continue;\n                }\n                // eを使う\n                if(dp[e][j - k][0] != LINF) {\n                    chmin(f[id][j][0], f[id - 1][k][0] + dp[e][j - k][0]);\n                    chmin(f[id][j][1], f[id - 1][k][1] + dp[e][j - k][0]);\n                }\n                if(dp[e][j - k][1] != LINF) {\n                    chmin(f[id][j][1], f[id - 1][k][0] + dp[e][j - k][1]);\n                }\n                // eを切り離す\n                if(k < j &&\n                   (dp[e][j - k - 1][0] != LINF || dp[e][j - k - 1][1] < 0)) {\n                    chmin(f[id][j][0], f[id - 1][k][0]);\n                    chmin(f[id][j][1], f[id - 1][k][1]);\n                }\n            }\n        }\n        id++;\n    }\n    for(int j = 0; j <= siz[i]; j++) {\n        if(a[i] > 0 && f[nn][j][0] != LINF) {\n            dp[i][j][0] = f[nn][j][0] + a[i];\n        }\n        if(f[nn][j][1] != LINF) {\n            dp[i][j][1] = f[nn][j][1] + a[i];\n        }\n    }\n}\nint main() {\n    cin >> n;\n    a.resize(n);\n    G.resize(n);\n    dp.resize(n);\n    siz.resize(n, 1);\n    for(int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n    for(int i = 0; i < n - 1; i++) {\n        int u, v;\n        cin >> u >> v;\n        --u;\n        --v;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    dfs(0, -1);\n    for(int i = 0; i <= n; i++) {\n        if(dp[0][i][0] != LINF || dp[0][i][1] < 0) {\n            cout << i << endl;\n            return 0;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint A[5050];\nvector<int> E[5050];\nll dp[5060][5060][2];\nint C[5050];\n\nvoid dfs(int cur,int pre) {\n\tC[cur]=1;\n\tif(A[cur]>0) {\n\t\tdp[cur][0][1]=A[cur];\n\t}\n\telse {\n\t\tdp[cur][0][0]=A[cur];\n\t}\n\tFORR(e,E[cur]) if(e!=pre) {\n\t\tdfs(e,cur);\n\t\tll to[5053][2];\n\t\t\n\t\tint x,y;\n\t\tFOR(x,5050) to[x][0]=to[x][1]=1LL<<60;\n\t\tfor(x=0;x<=C[cur]-1;x++) {\n\t\t\tfor(y=0;y<=C[e]-1;y++) {\n\t\t\t\t\n\t\t\t\tif(dp[e][y][0]<0 || dp[e][y][1]<1LL<<60) {\n\t\t\t\t\tto[x+y+1][0]=min(to[x+y+1][0],dp[cur][x][0]);\n\t\t\t\t\tto[x+y+1][1]=min(to[x+y+1][1],dp[cur][x][1]);\n\t\t\t\t}\n\t\t\t\tto[x+y][1]=min(to[x+y][1],dp[cur][x][1]+dp[e][y][1]);\n\t\t\t\tto[x+y][0]=min(to[x+y][0],dp[cur][x][0]+dp[e][y][1]);\n\t\t\t\tto[x+y][0]=min(to[x+y][0],dp[cur][x][1]+dp[e][y][0]);\n\t\t\t\tto[x+y][0]=min(to[x+y][0],dp[cur][x][0]+dp[e][y][0]);\n\t\t\t}\n\t\t}\n\t\tFOR(x,5050) {\n\t\t\tdp[cur][x][0]=to[x][0];\n\t\t\tdp[cur][x][1]=to[x][1];\n\t\t}\n\t\tC[cur]+=C[e];\n\t}\n\t\n\t\n}\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N) cin>>A[i];\n\tFOR(x,5050) FOR(y,5050) dp[x][y][0]=dp[x][y][1]=1LL<<60;\n\t\n\tFOR(i,N-1) {\n\t\tcin>>x>>y;\n\t\tE[x-1].push_back(y-1);\n\t\tE[y-1].push_back(x-1);\n\t}\n\t\n\tdfs(0,-1);\n\tfor(i=0;i<=5050;i++) {\n\t\tif(dp[0][i][0]<0) return _P(\"%d\\n\",i);\n\t\tif(dp[0][i][1]<1LL<<60) return _P(\"%d\\n\",i);\n\t}\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <cstdio>\n#include <cstdint>\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cmath>\n#include <climits>\n#include <bitset>\n\n// macros\n#define ll long long int\n#define pb push_back\n#define mk make_pair\n#define pq priority_queue\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n\nusing namespace std;\n\n//  types\ntypedef pair<int, int> P;\ntypedef pair<ll, int> Pl;\ntypedef pair<ll, ll> Pll;\ntypedef pair<double, double> Pd;\n \n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 1e9 + 7;\n\n// solve\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\n\nvector<int> edge[5001];\nvector<int> child[5001];\nint par[5001], num[5001];\nll dp1[5001][5001], dp2[5001][5001];\n\nvoid dfs1(int i){\n  num[i] = 1;\n  rep(j, edge[i].size()){\n    int to = edge[i][j];\n    if(par[to] >= 0)continue;\n    par[to] = i;\n    child[i].pb(to);\n    dfs1(to);\n    num[i] += num[to];\n  }\n}\n\nvector<ll> a;\nint n;\n\nvoid dfs(int i){\n  rep(j, child[i].size()){\n    dfs(child[i][j]);\n  }\n  if(child[i].size() == 0){\n    if(a[i] < 0){\n      dp2[i][1] = a[i];\n    }else{\n      dp1[i][1] = dp2[i][1] = a[i];\n    }\n    return;\n  }\n  if(a[i] > 0){\n    vector<vector<ll> > dp = vector<vector<ll> >(num[i]+1, vector<ll>(num[i]+1, linf));\n    dp[0][1] = a[i];\n    rep(j, child[i].size()){\n      int to = child[i][j];\n      rep(k, num[i]+1){\n        for(int l = 1; l <= k; l++){\n          if(l > num[to])break;\n          if(dp1[to][l] < linf || dp2[to][l] < 0)chmin(dp[j+1][k], dp[j][k-l]);\n        }\n        if(a[to] > 0){\n          for(int l = 1; l <= k; l++){\n            if(l > num[to])break;\n            chmin(dp[j+1][k], dp[j][k-l+1] + dp1[to][l]);\n          }\n        }\n      }\n    }\n    rep(j, num[i]+1)dp1[i][j] = dp[child[i].size()][j];\n  }\n\n  vector<vector<ll> > dp = vector<vector<ll> >(num[i]+1, vector<ll>(num[i]+1, linf));\n  dp[0][1] = a[i];\n  rep(j, child[i].size()){\n    int to = child[i][j];\n    rep(k, num[i]+1){\n        for(int l = 1; l <= k; l++){\n          if(l > num[to])break;\n          if(dp1[to][l] < linf || dp2[to][l] < 0)chmin(dp[j+1][k], dp[j][k-l]);\n        }\n        for(int l = 1; l <= k; l++){\n          if(l > num[to])break;\n          chmin(dp[j+1][k], dp[j][k-l+1] + dp1[to][l]);\n          chmin(dp[j+1][k], dp[j][k-l+1] + dp2[to][l]);\n        }\n    }\n  }\n  rep(j, num[i]+1)dp2[i][j] = dp[child[i].size()][j];\n\n}\n\nint main(int argc, char const* argv[])\n{\n  cin >> n;\n  a = vector<ll>(n, 0);\n  rep(i, n)cin >> a[i];\n  rep(i, n - 1){\n    int x, y;\n    cin >> x >> y;\n    x--; y--;\n    edge[x].pb(y);\n    edge[y].pb(x);\n  }\n  fill(par, par + n, -1);\n  par[0] = 0;\n  dfs1(0);\n\n  rep(i, n+1){\n    rep(j, n+1){\n      dp1[i][j] = dp2[i][j] = linf;\n    }\n  }\n\n  dfs(0);\n  FOR(i, 1, n+1){\n    if(dp1[0][i] < linf || dp2[0][i] < 0){\n      cout << i - 1 << endl;\n      return 0;\n    }\n  }\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "///////////////////////////////////////////////////////////////////////////////\n\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <cmath>\n#include <typeinfo>\n#include <numeric>\n#include <cassert>\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n\nusing namespace std;\n\n///////////////////////////////////////////////////////////////////////////////\n\n#define DEBUG 0\n\n#define pb push_back\n#define V vector\n#define M unordered_map\n\n#define rep(i,n) for(ll i=0LL;i<n;++i)\n#define srep(i,s,n) for(ll i=s;i<n;++i)\n#define rrep(i,n) for(ll i=n-1LL;i>=0LL;--i)\n#define ALL(a) (a).begin(),(a).end()\n#define CIN(x) do { \\\n    assert(!cin.eof()); \\\n    cin >> x; \\\n    assert(!cin.fail()); \\\n} while(0);\n#if DEBUG\n#define debug_print(...) _debug_print(__VA_ARGS__)\n#define debug_printf(...) printf(__VA_ARGS__)\n#else // DEBUG\n#define debug_print(...)\n#define debug_printf(...)\n#endif // DEBUG\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef tuple<ll, ll> t2;\ntypedef tuple<ll, ll, ll> t3;\ntypedef tuple<ll, ll, ll, ll> t4;\ntypedef tuple<ll, ll, ll, ll, ll> t5;\ntemplate <typename T>\nusing priority_queue_incr = priority_queue<T, V<T>, greater<T>>;\n\ntemplate <typename S, typename T>\nT get_m(M<S, T> &m, S k, S default_value)\n{\n    if (m.find(k) == m.end()) return m[k] = default_value;\n    return m[k];\n}\n\nstruct UnionFind\n{\n    ull *parent, *count, *rank;\n\n    UnionFind(ull n) {\n        parent = new ull[n+1];\n        count = new ull[n+1];\n        rank = new ull[n+1];\n        for (ull i = 0ULL; i < n+1; ++i) {\n            parent[i] = i;\n            count[i] = 1;\n            rank[i] = 0;\n        }\n    }\n\n    ~UnionFind() {\n        delete rank;\n        delete count;\n        delete parent;\n    }\n\n    ull root(ull i) {\n        if (parent[i] == i) return i;\n        parent[i] = root(parent[i]);\n        return parent[i];\n    }\n\n    void unite(ull i, ull j) {\n        ull rooti = root(i);\n        ull rootj = root(j);\n\n        if (rooti == rootj) return;\n\n        if (rank[rootj] < rank[rooti]) {\n            parent[i] = parent[j] = parent[rootj] = rooti;\n            count[rooti] += count[rootj];\n        }\n        else {\n            parent[i] = parent[j] = parent[rooti] = rootj;\n            count[rootj] += count[rooti];\n            if (rank[rootj] == rank[rooti]) rank[rootj]++;\n        }\n    }\n\n    bool same(ull i, ull j) {\n        return root(i) == root(j);\n    }\n};\n\nstruct UnionFindM\n{\n    M<ull, ull> parent, count, rank;\n\n    ull root(ull i) {\n        ull parent_i = get_m(parent, i, i);\n        if (parent_i == i) return i;\n        return parent[i] = root(parent_i);\n    }\n\n    void unite(ull i, ull j) {\n        ull rooti = root(i);\n        ull rootj = root(j);\n\n        if (rooti == rootj) return;\n\n        if (get_m(rank, rootj, 0ULL) < get_m(rank, rooti, 0ULL)) {\n            parent[i] = parent[j] = parent[rootj] = rooti;\n            count[rooti] = get_m(count, rooti, 1ULL) + get_m(count, rootj, 1ULL);\n        }\n        else {\n            parent[i] = parent[j] = parent[rooti] = rootj;\n            count[rootj] = get_m(count, rootj, 1ULL) + get_m(count, rooti, 1ULL);\n            if (get_m(rank, rootj, 0ULL) == get_m(rank, rooti, 0ULL)) rank[rootj]++;\n        }\n    }\n\n    bool same(ull i, ull j) {\n        return root(i) == root(j);\n    }\n};\n\nstruct BIT\n{\n    ll *tree;\n    ll size;\n\n    BIT(ll n, ll init) {\n        tree = new ll[n+1];\n        size = n;\n        memset(tree, 0, sizeof(ll) * (n+1));\n        this->init(init);\n    }\n\n    void init(ll init) {\n        rep (i0, size) {\n            ll idx = i0 + 1LL;\n            while (idx <= size) {\n                tree[idx] += init;\n                idx += (idx & (-idx));\n            }\n        }\n    }\n\n    // idx is 1 origin\n    void add(ll idx, ll x) {\n        assert(idx > 0LL);\n        while (idx <= size) {\n            tree[idx] += x;\n            idx += (idx & (-idx));\n        }\n    }\n\n    // idx is 1 origin\n    ll sum(ll idx) {\n        assert(idx > 0LL);\n        ll ret = 0LL;\n        while (idx > 0LL) {\n            ret += tree[idx];\n            idx -= (idx & (-idx));\n        }\n        return ret;\n    }\n};\n\nstruct MaxFlow {\n    V<ll> links[1005];\n    ll capacities[1005][1005];\n    ll nodes;\n\n    MaxFlow(ll nodes) {\n        // i == 0       --> S\n        // i == nodes+1 --> T\n        rep (i, nodes+2LL) links[i].clear();\n        memset(capacities, 0, sizeof(capacities));\n        this->nodes = nodes;\n    }\n\n    void add_path(ll a, ll b, ll capacity) {\n        links[a].pb(b);\n        links[b].pb(a);\n        capacities[a][b] = capacity;\n        capacities[b][a] = 0LL;\n    }\n\n    ll solve(void) {\n        deque<V<ll>> q;\n        ll ret = 0LL;\n\n        for ( ; ; q.clear()) {\n\n            V<ll> start;\n            start.pb(0);\n            q.push_front(start);\n\n            bool checked[nodes+2];\n            memset(checked, 0, sizeof(checked));\n\n            V<ll> found;\n\n            for ( ; !(q.empty()); ) {\n                V<ll> path = q.front(); q.pop_front();\n                ll last = path[path.size()-1];\n\n                if (checked[last]) continue;\n                if (last == nodes+1) {\n                    found = path;\n                    break;\n                }\n\n                checked[last] = true;\n                for (auto next : (links[last])) {\n                    if (capacities[last][next] == 0) continue;\n                    V<ll> newpath(path);\n                    newpath.pb(next);\n                    q.push_front(newpath);\n                }\n            }\n\n            if (found.size() == 0) {\n                break;\n            }\n            else {\n                ll flowcount = capacities[found[0]][found[1]];\n                rep (i, found.size()-1) {\n                    ll src = found[i];\n                    ll dst = found[i+1];\n                    flowcount = min(flowcount, capacities[src][dst]);\n                }\n                rep (i, found.size()-1) {\n                    ll src = found[i];\n                    ll dst = found[i+1];\n                    capacities[src][dst] -= flowcount;\n                    capacities[dst][src] += flowcount;\n                }\n                ret += flowcount;\n            }\n        }\n\n        return ret;\n    }\n};\n\ntemplate <typename T>\nstruct SegmentTree {\n    T *nodes;\n    t2 *ranges;  // [start, end)\n    ll nodecount;\n    ll itemcount;\n    T unit;\n    T (*op)(T, T);\n\n    SegmentTree(ll itemcount, T unit, T op(T, T)) {\n        ll orig_itemcount = itemcount;\n        this->itemcount = 1LL;\n        while (this->itemcount < orig_itemcount) this->itemcount *= 2LL;\n        nodecount = this->itemcount * 2 - 1;\n        nodes = new T[nodecount];\n        ranges = new t2[nodecount];\n        this->unit = unit;\n        this->op = op;\n\n        ll start = 0LL;\n        ll end = this->itemcount;\n        ll len = this->itemcount;\n\n        rep (i, nodecount) {\n            nodes[i] = unit;\n            ranges[i] = t2(start, end);\n            if (end >= this->itemcount) {\n                len /= 2LL;\n                start = 0LL;\n                end = len;\n            }\n            else {\n                start = end;\n                end = start + len;\n            }\n        }\n    }\n\n    void update(ll k, T v) {\n        ll idx = k + itemcount - 1LL;\n        nodes[idx] = v;\n        idx = (idx - 1LL) / 2LL;\n\n        for ( ; idx >= 0; idx = (idx - 1LL) / 2LL) {\n            nodes[idx] = op(nodes[idx * 2LL + 1LL],\n                            nodes[idx * 2LL + 2LL]);\n            if (!idx) break;\n        }\n    }\n\n    T query(ll start, ll end) const {\n        return _query(start, end, 0LL);\n    }\n\n    T _query(ll start, ll end, ll idx) const {\n        ll rstart = get<0>(ranges[idx]);\n        ll rend = get<1>(ranges[idx]);\n\n        if (start <= rstart && rend <= end) {\n            return nodes[idx];\n        }\n        if (rend <= start || end <= rstart) {\n            return unit;\n        }\n        T left = _query(start, end, idx * 2LL + 1LL);\n        T right = _query(start, end, idx * 2LL + 2LL);\n        return op(left, right);\n    }\n\n};\n\nvoid llin(ll &a)\n{\n    CIN(a);\n}\n\nvoid llinl1(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a;\n        CIN(a);\n        v.push_back(a);\n    }\n}\n\nvoid llinl2(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a, b;\n        CIN(a >> b);\n        v.push_back(t2(a, b));\n    }\n}\n\nvoid llinl3(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a, b, c;\n        CIN(a >> b >> c);\n        v.push_back(t3(a, b, c));\n    }\n}\n\nvoid llinl4(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a, b, c, d;\n        CIN(a >> b >> c >> d);\n        v.push_back(t4(a, b, c, d));\n    }\n}\n\nvoid llina(auto &v, ll count)\n{\n    llinl1(v, count);\n}\n\ntemplate <typename T>\nT min(const V<T> v)\n{\n    T ret = v[0];\n    for (auto i : v) ret = min(ret, i);\n    return ret;\n}\n\ntemplate <typename T>\nT max(const V<T> v)\n{\n    T ret = v[0];\n    for (auto i : v) ret = max(ret, i);\n    return ret;\n}\n\nll absll(ll x)\n{\n    if (x < 0) return -x;\n    return x;\n}\n\nll mod_mlt(ll x, ll y, ll mod)\n{\n    ll ret = 0LL;\n    x %= mod;\n\n    while (y) {\n        if (y & 1LL) {\n            ret += x;\n            ret %= mod;\n        }\n        y >>= 1;\n        x <<= 1;\n        x %= mod;\n    }\n\n    return ret;\n}\n\n// O(log(exp))\nll mod_pow(ll base, ll exp, ll mod)\n{\n    ll ret = 1LL;\n\n    for ( ; exp; ) {\n        if (exp & 1LL) {\n            ret *= base;\n            ret %= mod;\n        }\n        base = (base * base) % mod;\n        exp >>= 1;\n    }\n\n    return ret;\n}\n\n// O(log(mod))\nll mod_inv(ll x, ll mod)\n{\n    // available only when mod is prime\n    return mod_pow(x, mod - 2LL, mod);\n}\n\nll gcm(ll x, ll y)\n{\n    while (y != 0) {\n        ll z = x % y;\n        x = y;\n        y = z;\n    }\n    return x;\n}\n\ntemplate <typename T>\nvoid sort(V<T> &v)\n{\n    sort(v.begin(), v.end());\n}\n\ntemplate <typename T>\nvoid sort_reverse(V<T> &v)\n{\n    sort(v.begin(), v.end(), greater<T>());\n}\n\nvoid get_divisors(V<ll> &retlist, ll x)\n{\n    for (ll i = 1LL; i < sqrt(x) + 3LL; ++i) {\n        if (x % i == 0LL) {\n            retlist.push_back(i);\n            retlist.push_back(x / i);\n        }\n    }\n}\n\nvoid get_factors(V<ll> &retlist, ll x)\n{\n    for (ll i = 2LL; i < (ll)(sqrt(x)) + 3LL; ++i) {\n        while (x % i == 0LL) {\n            retlist.pb(i);\n            x /= i;\n        }\n    }\n    retlist.pb(x);\n}\n\nbool is_prime(ll x)\n{\n    V<ll> factors, factors2;\n\n    get_factors(factors, x);\n\n    for (auto factor : factors) {\n        if (factor > 1) factors2.pb(factor);\n    }\n\n    return factors2.size() == 1 && x == factors2[0];\n}\n\ntemplate <typename T>\nvoid intersection(const set<T> &a, const set<T> &b,\n                  set<T> &result)\n{\n    set_intersection(ALL(a), ALL(b), inserter(result, result.end()));\n}\n\null combination(ll x, ll y)\n{\n    if (y > x / 2LL) y = x - y;\n\n    ull ret = 1LL;\n    for (ll i = 0LL; i < y; ++i) {\n        ret *= x--;\n        ret /= (i + 1LL);\n    }\n\n    return ret;\n}\n\null mod_combination(ll x, ll y, ll mod)\n{\n    if (y > x / 2LL) y = x - y;\n\n    ll ret = 1;\n\n    for (ll i = 0LL; i < y; ++i) {\n        ret = (ret * x--) % mod;\n        ret = (ret * mod_inv(i + 1LL, mod)) % mod;\n    }\n\n    return ret;\n}\n\nvoid make_linklist(const V<t2> &srclist, V<ll> dstlist[])\n{\n    for (auto src : srclist) {\n        ll a = get<0>(src);\n        ll b = get<1>(src);\n        dstlist[a].pb(b);\n        dstlist[b].pb(a);\n    }\n}\n\nvoid make_parental_relation(const V<ll> linklist[], ll root, ll n,\n                            ll parent[], V<ll> children[], ll level[])\n{\n    queue<ll> q;\n    bool checked[n+1];\n\n    memset(checked, 0, sizeof(checked));\n\n    q.push(root);\n    checked[root] = true;\n    parent[root] = root;\n    level[root] = 0LL;\n\n    for ( ; !(q.empty()); ) {\n        ll now = q.front(); q.pop();\n        for (auto next : linklist[now]) {\n            if (checked[next]) continue;\n            q.push(next);\n            checked[next] = true;\n            parent[next] = now;\n            children[now].pb(next);\n            level[next] = level[now] + 1LL;\n        }\n    }\n}\n\nvoid make_subtree_sizes(const ll child_count[], const ll parents[],\n                        ll subtree_sizes[], ll n)\n{\n    ll remain_count[n+1LL];\n    memcpy(remain_count, child_count, sizeof(remain_count));\n\n    queue<ll> q;\n    srep (node, 1LL, n+1LL) {\n        subtree_sizes[node] = 1LL;\n        if (remain_count[node] > 0) continue;\n        q.push(node);\n    }\n\n    while (!q.empty()) {\n        ll node = q.front(); q.pop();\n        ll parent = parents[node];\n        if (node == parent) continue;\n        remain_count[parent]--;\n        subtree_sizes[parent] += subtree_sizes[node];\n        if (remain_count[parent] == 0LL) q.push(parent);\n    }\n}\n\nvoid get_centroids(const V<ll> children[], const ll subtree_sizes[],\n                   ll root, ll n, V<ll> &centroids)\n{\n    queue<ll> q;\n    q.push(root);\n\n    while (!q.empty()) {\n        ll now = q.front(); q.pop();\n        bool is_centroid = true;\n        for (auto child : children[now]) {\n            q.push(child);\n            if (subtree_sizes[child] > n / 2LL) is_centroid = false;\n        }\n        if (n - subtree_sizes[now] > n / 2LL) is_centroid = false;\n        if (is_centroid) centroids.pb(now);\n    }\n\n    assert(centroids.size() == 1LL || centroids.size() == 2LL);\n}\n\n#define POW_ANCESTOR_MAXSIZE   20\n\n// preprocess for get_common_ancestor()\nvoid make_pow_ancestor(const ll parent[], ll n,\n                       ll (*pow_ancestor)[POW_ANCESTOR_MAXSIZE])\n{\n    rep (i, n) pow_ancestor[i+1][0] = parent[i+1];\n\n    for (int pow2 = 1; pow(2, pow2) <= n; ++pow2) {\n        rep (i0, n) {\n            int i = i0+1;\n            ll prev = pow_ancestor[i][pow2-1];\n            pow_ancestor[i][pow2] = pow_ancestor[prev][pow2-1];\n        }\n    }\n}\n\nll get_common_ancestor(ll n, ll x, ll y,\n                       const ll (*pow_ancestor)[POW_ANCESTOR_MAXSIZE],\n                       const ll level[])\n{\n    if (level[x] < level[y]) {\n        ll diff = level[y] - level[x];\n        for ( ; diff; ) {\n            ll bit = diff & -diff;\n            y = pow_ancestor[y][(int)log2(bit)];\n            diff -= bit;\n        }\n    }\n    else {\n        ll diff = level[x] - level[y];\n        for ( ; diff; ) {\n            ll bit = diff & -diff;\n            x = pow_ancestor[x][(int)log2(bit)];\n            diff -= bit;\n        }\n    }\n\n    if (x == y) return x;\n\n    rrep (i, (int)log2(n)+1) {\n        if (pow_ancestor[x][i] != pow_ancestor[y][i]) {\n            x = pow_ancestor[x][i];\n            y = pow_ancestor[y][i];\n        }\n    }\n\n    return pow_ancestor[x][0];\n}\n\nvoid kmp_init(const string &pattern, ll kmp_next[])\n{\n    kmp_next[0] = -1LL;\n\n    ll plen = pattern.size();\n    ll prefix_end = -1;\n\n    rep (suffix_end, pattern.size()) {\n        while (prefix_end >= 0 && pattern[suffix_end] != pattern[prefix_end]) {\n            prefix_end = kmp_next[prefix_end];\n        }\n        kmp_next[suffix_end+1] = ++prefix_end;\n    }\n\n    kmp_next[0] = 0LL;\n}\n\n// founds ... list of text's idx of match position. start position idx.\nvoid kmp_search(const string &text, const string &pattern, const ll kmp_next[],\n                V<ll> &founds)\n{\n    ll text_size = text.size();\n    ll pattern_size = pattern.size();\n    ll text_start = 0LL;\n    ll pattern_idx = 0LL;\n\n    assert(pattern_size <= text_size);\n\n    for ( ; ; ) {\n        if (text_start + pattern_idx >= text_size) break;\n        if (pattern_idx >= pattern_size) break;\n\n        if (text[text_start+pattern_idx] == pattern[pattern_idx]) {\n            pattern_idx++;\n            if (pattern_idx == pattern_size) {\n                founds.pb(text_start);\n                pattern_idx = kmp_next[pattern_idx];\n                text_start += (pattern_size - pattern_idx);\n            }\n        }\n\n        else {\n            text_start += (pattern_idx - kmp_next[pattern_idx]);\n            pattern_idx = kmp_next[pattern_idx];\n            if (pattern_idx == 0LL && text[text_start] != pattern[0]) {\n                text_start++;\n            }\n        }\n    }\n}\n\nvoid _debug_print(auto x)\n{\n    cout << x << endl;\n}\n\nvoid _debug_print(const t2 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2 << endl;\n}\n\nvoid _debug_print(const t3 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    ll x3 = get<2>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2 << \" -- \" << x3 << endl;\n}\n\nvoid _debug_print(const t4 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    ll x3 = get<2>(x);\n    ll x4 = get<3>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2\n        << \" -- \" << x3 << \" -- \" << x4 << endl;\n}\n\ntemplate <typename T>\nvoid _debug_print(T xarray[], ll n)\n{\n    rep (i, n) _debug_print(xarray[i]);\n}\n\ntemplate <typename T>\nvoid _debug_print(const V<T> &xlist)\n{\n    for (auto x : xlist) {\n        cout << \"-- \";\n        _debug_print(x);\n    }\n}\n\ntemplate <typename T>\nvoid _debug_print(const set<T> &xset)\n{\n    for (auto x : xset) {\n        cout << \"-- \";\n        _debug_print(x);\n    }\n}\n\ntemplate <typename S, typename T>\nvoid _debug_print(const M<S, T> &xlist)\n{\n    for (auto x : xlist) {\n        S k = x.first;\n        T v = x.second;\n        cout << \"====\" << endl;\n        cout << \"K=\";\n        _debug_print(k);\n        cout << \"V=\";\n        _debug_print(v);\n    }\n}\n\nint _main();\nint main()\n{\n    cout << setprecision(12);\n    return _main();\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\n#define SZ   5003\n#define INF  1e18\n\nvoid make_partsize(ll partsize[SZ], const ll parents[SZ],\n                   const V<ll> children[SZ], const ll childcounts[SZ], ll n)\n{\n    queue<ll> q;\n    srep (v, 1LL, n+1LL) if (childcounts[v] == 0LL) q.push(v);\n\n    ll cc[SZ];\n    memcpy(cc, childcounts, sizeof(ll) * SZ);\n\n    while (!q.empty()) {\n        ll v = q.front(); q.pop();\n        ll vp = parents[v];\n        partsize[v] = 1LL;\n        for (auto vc : children[v]) partsize[v] += partsize[vc];\n        cc[vp]--;\n        if (cc[vp] == 0LL) q.push(vp);\n    }\n\n    debug_printf(\"---- partsize\\n\"); debug_print(partsize, n+1);\n}\n\nvoid min_update(ll &dst, ll src)\n{\n    dst = min(dst, src);\n}\n\nvoid solve(ll dp_b[SZ][SZ], ll dp_f[SZ][SZ],\n           const ll parents[SZ], const V<ll> children[SZ],\n           ll childcounts[SZ], const ll partsize[SZ], const V<ll> &alist, ll n)\n{\n    static ll dpp_b[SZ][SZ];\n    static ll dpp_f[SZ][SZ];\n\n    queue<ll> q;\n    srep (v, 1LL, n+1LL) if (childcounts[v] == 0LL) q.push(v);\n\n    rep (i, SZ) rep (j, SZ) dp_b[i][j] = INF + 1LL;\n    rep (i, SZ) rep (j, SZ) dp_f[i][j] = INF + 1LL;\n\n    while (!q.empty()) {\n        ll v = q.front(); q.pop();\n        ll csize = children[v].size();\n        ll origsize = 1LL;\n\n        debug_printf(\"---- v=%lld\\n\", v);\n\n        rep (i, csize+1) rep (j, partsize[v]+1) dpp_b[i][j] = INF + 1LL;\n        rep (i, csize+1) rep (j, partsize[v]+1) dpp_f[i][j] = INF + 1LL;\n        dpp_b[0][1] = ((alist[v] > 0LL) ? alist[v] : INF + 1LL);\n        dpp_f[0][1] = alist[v];\n\n        rep (cidx, csize) {\n            ll vc = children[v][cidx];\n\n            srep (cnt1, 1LL, origsize + 1LL) {\n                srep (cnt2, 1LL, partsize[vc] + 1LL) {\n                    ll cnt = cnt1 + cnt2;\n                    if (dp_b[vc][cnt2] < INF || dp_f[vc][cnt2] < 0LL) {\n                        min_update(dpp_b[cidx+1][cnt], dpp_b[cidx][cnt1]);\n                        min_update(dpp_f[cidx+1][cnt], dpp_f[cidx][cnt1]);\n                    }\n                    min_update(dpp_b[cidx+1][cnt-1],\n                               dpp_b[cidx][cnt1] + dp_b[vc][cnt2]);\n                    min_update(dpp_f[cidx+1][cnt-1],\n                               dpp_f[cidx][cnt1] + dp_f[vc][cnt2]);\n                }\n            }\n\n            origsize += partsize[vc];\n        }\n\n        rep (i, SZ) dp_b[v][i] = dpp_b[csize][i];\n        rep (i, SZ) dp_f[v][i] = dpp_f[csize][i];\n\n        debug_printf(\"---- dp\\n\");\n        srep (i, 1LL, csize+2LL) {\n            debug_printf(\"cnt=%lld battery=%lld free=%lld\\n\",\n                         i, dp_b[v][i], dp_f[v][i]);\n        }\n\n        if (parents[v] >= 1LL && --childcounts[parents[v]] <= 0LL) {\n            q.push(parents[v]);\n        }\n    }\n}\n\nint _main()\n{\n    ll n; llin(n);\n    V<ll> alist; alist.pb(0LL); llina(alist, n);\n    V<t2> uvlist; llinl2(uvlist, n-1LL);\n\n    static V<ll> linklist[SZ];\n    make_linklist(uvlist, linklist);\n\n    static ll parents[SZ];\n    static V<ll> children[SZ];\n    static ll level[SZ];\n    make_parental_relation(linklist, 1LL, n, parents, children, level);\n\n    static ll childcounts[SZ];\n    srep (i, 1LL, n+1LL) childcounts[i] = children[i].size();\n\n    static ll partsize[SZ];\n    make_partsize(partsize, parents, children, childcounts, n);\n\n    static ll dp_b[SZ][SZ];\n    static ll dp_f[SZ][SZ];\n    parents[1] = -1LL;\n    solve(dp_b, dp_f, parents, children, childcounts, partsize, alist, n);\n\n    ll ans = n - 1LL;\n\n    srep (i, 1LL, SZ) {\n        if (dp_b[1][i] < INF) {\n            ans = min(ans, i-1LL);\n            break;\n        }\n    }\n\n    srep (i, 1LL, SZ) {\n        if (dp_f[1][i] < 0LL) {\n            ans = min(ans, i-1LL);\n            break;\n        }\n    }\n\n    debug_printf(\"---- ans\\n\");\n    cout << ans << endl;\n\n    return 0;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define LLI long long int\n#define FOR(v, a, b) for(LLI v = (a); v < (b); ++v)\n#define FORE(v, a, b) for(LLI v = (a); v <= (b); ++v)\n#define REP(v, n) FOR(v, 0, n)\n#define REPE(v, n) FORE(v, 0, n)\n#define REV(v, a, b) for(LLI v = (a); v >= (b); --v)\n#define ALL(x) (x).begin(), (x).end()\n#define RALL(x) (x).rbegin(), (x).rend()\n#define ITR(it, c) for(auto it = (c).begin(); it != (c).end(); ++it)\n#define RITR(it, c) for(auto it = (c).rbegin(); it != (c).rend(); ++it)\n#define EXIST(c,x) ((c).find(x) != (c).end())\n#define fst first\n#define snd second\n#define popcount __builtin_popcount\n#define UNIQ(v) (v).erase(unique(ALL(v)), (v).end())\n#define bit(i) (1LL<<(i))\n\n#ifdef DEBUG\n#include <misc/C++/Debug.cpp>\n#else\n#define dump(...) ((void)0)\n#endif\n\n#define gcd __gcd\n\nusing namespace std;\ntemplate <class T> constexpr T lcm(T m, T n){return m/gcd(m,n)*n;}\n\ntemplate <typename I> void join(ostream &ost, I s, I t, string d=\" \"){for(auto i=s; i!=t; ++i){if(i!=s)ost<<d; ost<<*i;}ost<<endl;}\ntemplate <typename T> istream& operator>>(istream &is, vector<T> &v){for(auto &a : v) is >> a; return is;}\n\ntemplate <typename T, typename U> bool chmin(T &a, const U &b){return (a>b ? a=b, true : false);}\ntemplate <typename T, typename U> bool chmax(T &a, const U &b){return (a<b ? a=b, true : false);}\ntemplate <typename T, size_t N, typename U> void fill_array(T (&a)[N], const U &v){fill((U*)a, (U*)(a+N), v);}\n\nconst LLI INF = 1LL << 60;\n\nvector<vector<int>> tree;\nvector<LLI> a;\nLLI dp[5100][5100][2];\nLLI dp2[5100][2];\n\nint subtree[5100];\n\nvoid rec(int cur, int par){\n  for(auto &e : tree[cur]){\n    if(e == par) continue;\n    rec(e,cur);\n  }\n\n  subtree[cur] = 1;\n  \n  fill_array(dp2, INF);\n\n  dp[cur][0][a[cur] < 0] = a[cur];\n\n  for(auto &e : tree[cur]){\n    if(e == par) continue;\n\n    REP(n1,subtree[cur]){\n      REP(n2,subtree[e]){\n        REP(k1,2){\n          REP(k2,2){\n            chmin(dp2[n1+n2][k1|k2], dp[cur][n1][k1]+dp[e][n2][k2]);\n\n            if((k2 == 0 and dp[e][n2][k2] < INF) or (k2 == 1 and dp[e][n2][k2] < 0)){\n              chmin(dp2[n1+n2+1][k1], dp[cur][n1][k1]);\n            }\n          }\n        }\n      }\n    }\n\n    subtree[cur] += subtree[e];\n\n    REP(i,subtree[cur]){\n      REP(j,2){\n        dp[cur][i][j] = dp2[i][j];\n        dp2[i][j] = INF;\n      }\n    }\n  }\n}\n\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n;\n  while(cin >> n){\n    a = vector<LLI>(n); cin >> a;\n\n    tree = vector<vector<int>>(n);\n    REP(i,n-1){\n      int u, v; cin >> u >> v;\n      --u, --v;\n      tree[u].push_back(v);\n      tree[v].push_back(u);\n    }\n\n    fill_array(dp, INF);\n    fill_array(subtree, 0);\n\n    rec(0,-1);\n\n    int ans = INT_MAX;\n\n    REP(i,n){\n      if(dp[0][i][0] < INF or dp[0][i][1] < 0) chmin(ans, i);\n    }\n\n    cout << ans << endl;\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <chrono>\n#define _USE_MATH_DEFINES\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <string>\n#include <tuple>\n#include <vector>\nusing namespace std;\n\n#define FOR(i,m,n) for(int i=(m);i<(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n\nconst int INF = 0x3f3f3f3f, MOD = 1000000007;\nconst long long LINF = 0x3f3f3f3f3f3f3f3fLL;\n/*-----------------------------------------*/\n// https://snuke.hatenablog.com/entry/2019/01/15/211812\nvector<int> edge[5000];\nint a[5000];\nlong long dp[5000][5001][2]; // true -> A_i > 0\nint dfs(int par, int ver) {\n  int cnt = 1;\n  if (a[ver] > 0) dp[ver][1][true] = a[ver];\n  dp[ver][1][false] = a[ver];\n  for (int e : edge[ver]) if (e != par) {\n    int kosu = dfs(ver, e);\n    vector<vector<long long> > tmp(cnt+kosu+1, vector<long long>(2, LINF));\n    FOR(i, 1, cnt+1) FOR(j, 1, kosu+1) {\n      if (a[ver] > 0) {\n        if (dp[e][j][true] != LINF || dp[e][j][false] < 0) tmp[i+j][true] = min(tmp[i+j][true], dp[ver][i][true]);\n        if (a[e] > 0) tmp[i+j-1][true] = min(tmp[i+j-1][true], dp[ver][i][true]+dp[e][j][true]);\n      }\n      if (dp[e][j][true] != LINF || dp[e][j][false] < 0) tmp[i+j][false] = min(tmp[i+j][false], dp[ver][i][false]);\n      tmp[i+j-1][false] = min(tmp[i+j-1][false], dp[ver][i][false]+dp[e][j][false]);\n    }\n    cnt += kosu;\n    FOR(j, 1, cnt+1) {\n      dp[ver][j][true] = tmp[j][true];\n      dp[ver][j][false] = tmp[j][false];\n    }\n  }\n  return cnt;\n}\n\nint main() {\n  cin.tie(0); ios::sync_with_stdio(false);\n  // freopen(\"input.txt\", \"r\", stdin);\n\n  int n; cin >> n;\n  REP(i, n) cin >> a[i];\n  REP(i, n - 1) {\n    int u, v; cin >> u >> v; --u; --v;\n    edge[u].emplace_back(v);\n    edge[v].emplace_back(u);\n  }\n  REP(i, n) FOR(j, 1, n+1) {\n    dp[i][j][true] = dp[i][j][false] = LINF;\n  }\n  dfs(-1, 0);\n  // REP(i, n) {\n  //   cout << i << \": \";\n  //   FOR(j, 1, n+1) {\n  //     cout << \"(\";\n  //     if (dp[i][j][true] == LINF) cout << \"x\";\n  //     else cout << dp[i][j][true];\n  //     cout << \",\";\n  //     if (dp[i][j][false] == LINF) cout << \"x\";\n  //     else cout << dp[i][j][false];\n  //     cout << \") \";\n  //   }\n  //   cout << '\\n';\n  // }\n  FOR(j, 1, n+1) {\n    if (dp[0][j][true] != LINF) {\n      cout << j - 1 << '\\n';\n      return 0;\n    }\n    if (dp[0][j][false] < 0) {\n      cout << j - 1 << '\\n';\n      return 0;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <vector>\nusing namespace std;\nusing ll = long long;\n#define fst first\n#define snd second\n\n/* clang-format off */\ntemplate <class T, size_t D> struct _vec { using type = vector<typename _vec<T, D - 1>::type>; };\ntemplate <class T> struct _vec<T, 0> { using type = T; };\ntemplate <class T, size_t D> using vec = typename _vec<T, D>::type;\ntemplate <class T> vector<T> make_v(size_t size, const T& init) { return vector<T>(size, init); }\ntemplate <class... Ts> auto make_v(size_t size, Ts... rest) { return vector<decltype(make_v(rest...))>(size, make_v(rest...)); }\n/* clang-format on */\n\nconst ll INF = 1ll << 60;\n\nint N;\nll A[6000];\nvector<int> G[6000];\n\nint best[6000];\nvector<ll> dp1[6000];\nint dp2[6000];\n\nvoid dfs(int v, int p) {\n  vector<ll>& dp = dp1[v];\n  dp.push_back(0ll);\n  for (int u : G[v]) {\n    if (u == p) continue;\n    dfs(u, v);\n    auto& ch = dp1[u];\n    vector<ll> ndp(dp.size() + ch.size() - 1, INF);\n    for (int i = 0; i < dp.size(); i++) {\n      for (int j = 0; j < ch.size(); j++) {\n        ndp[i + j] = min(ndp[i + j], dp[i] + ch[j]);\n      }\n    }\n    dp.swap(ndp);\n  }\n  for (ll& x : dp) x += A[v];\n  dp.push_back(0ll);\n  for (int i = 0; i + 1 < dp.size(); i++) {\n    if (dp[i] < 0) {\n      dp[i + 1] = min(dp[i + 1], 0ll);\n    }\n  }\n  best[v] = dp.size() - 2;\n  for (int i = 0; i < dp.size(); i++) {\n    if (dp[i] < 0) {\n      best[v] = i;\n      break;\n    }\n  }\n  if (A[v] < 0) {\n    dp2[v] = best[v] + 1;\n  } else {\n    dp2[v] = 0;\n    for (int u : G[v]) {\n      if (u == p) continue;\n      dp2[v] += dp2[u];\n    }\n    dp[dp2[v] + 1] = min(dp[dp2[v] + 1], 0ll);\n    best[v] = min(best[v], dp2[v]);\n  }\n}\n\nint main() {\n  while (cin >> N) {\n    for (int i = 0; i < N; i++) cin >> A[i];\n    for (int i = 0; i < N; i++) {\n      G[i].clear();\n      dp1[i].clear();\n    }\n    for (int i = 0; i < N - 1; i++) {\n      int x, y;\n      cin >> x >> y;\n      --x;\n      --y;\n      G[x].push_back(y);\n      G[y].push_back(x);\n    }\n    dfs(0, -1);\n    cout << best[0] << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long dp[5010][5010];\nlong long tmp[5010];\nbool pos[5010][5010];\nbool ptmp[5010];\nint sz[5010];\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n; cin >> n;\n    vector<long long> a(n);\n    for (int i = 0; i < n; i++) cin >> a[i];\n    vector<vector<int>> e(n);\n    for (int i = 1; i < n; i++) {\n        int u, v; cin >> u >> v;\n        u--, v--;\n        e[u].emplace_back(v);\n        e[v].emplace_back(u);\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j <= n; j++) {\n            dp[i][j] = 1e16;\n        }\n    }\n    auto f = [&](auto f, int curr, int prev) -> void {\n        sz[curr] = 1; pos[curr][0] = (a[curr] > 0);\n        dp[curr][0] = a[curr];\n        for (auto &to: e[curr]) {\n            if (to == prev) continue;\n            f(f, to, curr);\n            for (int i = 0; i < n; i++) tmp[i] = 1e16, ptmp[i] = 0;\n            for (int i = 0; i < sz[curr]; i--) {\n                for (int j = 0; j < sz[to]; j++) {\n                    if (pos[to][j] || dp[to][j] < 0) {\n                        tmp[i+j+1] = min(tmp[i+j+1], dp[curr][i]);\n                        ptmp[i+j+1] |= pos[curr][i];\n                    }\n                    ptmp[i+j] |= pos[curr][i] & pos[to][j];\n                    tmp[i+j] = min(tmp[i+j], dp[curr][i] + dp[to][j]);\n                }\n            }\n            sz[curr] += sz[to];\n            for (int i = 0; i < sz[curr]; i++) {\n                dp[curr][i] = tmp[i];\n                pos[curr][i] = ptmp[i];\n            }\n        }\n    };\n    f(f, 0, -1);\n    for (int i = 0; i < n; i++) {\n        if (dp[0][i] < 0 || pos[0][i]) {\n            cout << i << \"\\n\";\n            return 0;\n        }\n    }\n    assert(false);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n/*\nsum<0なら0で終わり\nそうじゃないなら？必ず正だけの地点を作る\n根付き木にしてdp？\ndp[i][j]:部分根付き木iまででj本切った時の最小値(iの上の部分を切ることも考えてる)\n葉lに対してdp[l][0]=v[l],dp[l][1]=0;\n親pに対して子をsとして、dp[p][k]=それぞれのそれ\nつまり？dp[p][k]はmin(sum(dp[s][j]:sum j = k))\n高速化の方法は？\nえーなんかdpまでは絶対に合っていると思っていて、\n+のやつを取るところに関しては+をなるべく大量に消費して欲しくて、マイナスは一個も入っちゃいけない\n-が入る方は、+にならないようになるべく大きく取りたい\n実は葉から貪欲？最後にくっつけられるところはくっつけていいとか\n根付き木にして、葉から貪欲にやっていく　具体的には\n・スタートが+の時\n+で有る限り取り続ける\n-が来た場合、-が大きくなるなら取って変更\n・スタートが-の時\n合計が負で有る限り取り続ける\n\n貪欲が終わった時塊は　a:全部+で次の-入れても+ or b:合計が負で次のやつで+\n・貪欲をした後\n自分の子とくっつけられるかを試す？\n自分がaの時　aは子の候補にいなくて、bは絶対無理　なので終わり\n自分がbの時　子のbは全部取り込める\n　　　　　　 これで子のaも取り込めるし次の+も取り込める場合は？\n　　　　　　　・子のaを取り込むメリット:そのさらに子を取り込める可能性が出てくる\nまってそもそも合流を考えられていない　いやそれは大丈夫かも\n*/\nint dp1[5123][5123],//dp1[v][k]:v以下k個、vのところは全部正の時のその最小値\n    dp2[5123][5123],//dp2[v][k]:v以下k個、vの所の最小値\n    dpt1[5123][5123],//dpt1[i][j]:vのi番目までの子までからなる部分木をdp1と同様にj個に分ける時の一番上の最小値\n    dpt2[5123][5123];//dpt2[i][j]:同様\n\nconst int INF=1e9;\n\ntemplate<typename T>\nvoid fin(T a){\n  cout<<a<<endl;\n  exit(0);\n}\n\ntemplate<typename T>\nvoid chmin(T &a,T b){\n  if(a>b)a=b;\n}\n\nsigned main(){\n  int n;cin>>n;\n  assert(n<100);\n  vector<int> v(n);\n  for(int i=0;i<n;i++)cin>>v[i];\n  vector<int> edge[n];\n  for(int i=1;i<n;i++){\n    int u,v;cin>>u>>v;u--;v--;\n    edge[u].push_back(v);\n    edge[v].push_back(u);\n  }\n\n  int sum=0;for(int i=0;i<n;i++)sum+=v[i];if(sum<0)fin(0);\n\n  int r;int m=0;\n  for(int i=0;i<n;i++)\n    if(m<edge[i].size())\n      m=edge[i].size(),r=i;\n\n  vector<int> parent(n),son[n];\n  parent[r]=-1;\n  queue<int> que;\n  que.push(r);\n  while(que.size()){\n    int p=que.front();que.pop();\n    for(int q:edge[p]){\n      if(parent[p]==q)continue;\n      parent[q]=p;\n      son[p].push_back(q);\n      que.push(q);\n    }\n  }\n\n  for(int i=0;i<5123;i++)\n    for(int j=0;j<5123;j++)\n      dp1[i][j]=dp2[i][j]=dpt1[i][j]=dpt2[i][j]=INF;\n\n  vector<int> rem(n);\n  for(int i=0;i<n;i++)rem[i]=son[i].size();\n  for(int i=0;i<n;i++)if(!rem[i])que.push(i);\n\n  while(que.size()){\n    int p=que.front();que.pop();\n\n    for(int j=0;j<100;j++)for(int k=0;k<100;k++)dpt1[j][k]=dpt2[j][k]=INF;\n    dpt1[0][0]=0;\n\n    int N=son[p].size();\n\n    for(int i=0;i<N;i++){\n      int q=son[p][i];\n      for(int j=0;j<100;j++){\n        for(int k=0;k<100;k++){\n          chmin(dpt1[i+1][j+k],dpt1[i][j]+dp1[q][k]);\n        }\n      }\n    }\n\n    for(int k=0;k<100;k++){\n      if(dpt1[N][k]==INF)continue;\n      if(v[p]>0){\n        chmin(dp1[p][k],dpt1[N][k]+v[p]);\n        dp2[p][k+1]=0;\n      }\n    }\n\n    dpt2[0][0]=0;\n\n    for(int i=0;i<N;i++){\n      int q=son[p][i];\n      for(int j=0;j<100;j++){\n        for(int k=0;k<100;k++){\n          chmin(dpt2[i+1][j+k],dpt2[i][j]+dp2[q][k]);\n        }\n      }\n    }\n\n    for(int k=0;k<100;k++){\n      chmin(dp2[p][k],dpt2[N][k]+v[p]);\n      if(dpt2[N][k]+v[p]<0)dp1[p][k+1]=dp2[p][k+1]=0;\n    }\n\n    if(~parent[p]&&--rem[parent[p]]==0)que.push(parent[p]);\n  }\n\n  int ans=INF;\n  for(int j=0;j<100;j++){\n    if(dp1[r][j]<50)chmin(ans,j);\n    if(dp2[r][j]<0)chmin(ans,j);\n  }\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n\ntemplate<class T> bool chmin(T &target, const T &value){\n  if( target > value ){\n    target = value;\n    return true;\n  }\n  return false;\n}\n\n\nconst long long INF = 1e18;\n\n\nvector<int> g[5050];\n\nvector<ll> A;\nvector<ll> dp0[5050];\nvector<ll> dp1[5050];\n\nvector<ll> merge(const vector<ll> &dp, const vector<ll> &op0, const vector<ll> &op1, bool source_only){\n  vector<ll> res(dp.size() + op0.size(), INF);\n  for(int i = 0 ; i < dp.size() ; i++){\n    for(int j = 0 ; j < op0.size() ; j++){\n      if( !source_only ) chmin(res[i+j], op0[j] + dp[i]);\n      chmin(res[i+j], op1[j] + dp[i]);\n      if( op0[j] < 0 ) chmin(res[i+j+1], dp[i]);\n      if( op1[j] != INF) chmin(res[i+j+1], dp[i]);\n    }\n  }\n  return move(res);\n}\n\nvoid dfs(int root, int parent){\n  dp0[root] = vector<ll>(1, A[root]);\n  dp1[root] = vector<ll>(1, A[root] > 0 ? A[root] : INF);\n\n  for( auto i : g[root]){\n    if( parent == i ) continue;\n    dfs(i, root);\n    dp0[root] = merge(dp0[root], dp0[i], dp1[i], false);\n    dp1[root] = merge(dp1[root], dp0[i], dp1[i], true);\n  }\n//  cout << \"==\" << \" \" << root << \" \" << \"==\" << endl;\n//  for(int i = 0 ; i < dp0[root].size() ; i++){\n//    cout << i << \": \" << dp0[root][i] << \" \" << dp1[root][i] << endl;\n//  }\n\n}\n\nvoid add_edge(int a,int b){\n  g[a].push_back(b);\n  g[b].push_back(a);\n}\n\n\nvoid solve(long long N, vector<long long> A, vector<long long> U,\n           vector<long long> V) {\n  ::A = A;\n\n  for(int i = 0 ; i < N - 1 ; i++){\n    add_edge(U[i]-1, V[i]-1);\n  }\n  dfs(0, -1);\n\n  for(int i = 0 ; i < dp0[0].size() ; i++){\n    if( dp0[0][i] < 0 || dp1[0][i] != INF ){\n      cout << i << endl;\n      return;\n    }\n  }\n\n\n\n\n}\n\n\n\n\nint main() {\n\n  long long N;\n  scanf(\"%lld\", &N);\n  vector<long long> A(N);\n  for (int i = 0; i < N; i++) {\n    scanf(\"%lld\", &A[i]);\n  }\n  vector<long long> U(N - 1);\n  vector<long long> V(N - 1);\n  for (int i = 0; i < N - 1; i++) {\n    scanf(\"%lld\", &U[i]);\n    scanf(\"%lld\", &V[i]);\n  }\n  solve(N, A, U, V);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <typeinfo>\n#include <numeric>\n#include <functional>\n#include <unordered_map>\n#include <bitset>\n#include <stack>\n\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nconst ll INF = 1e16;\nconst ll MOD = 1e9 + 7;\n\n#define REP(i, n) for(ll i = 0; i < n; i++)\n\n\n\n\n\n\nvector<ll> a, num;\nvector<vector<ll>> g, sdp;\nvector<vector<vector<ll>>> dp;\n\n\nvoid rec(ll v, ll par){\n    num[v] = 1;\n    for(auto &child : g[v]){\n        if(child == par) continue;\n        rec(child, v);\n        num[v] += num[child];\n    }\n    \n    for(ll i = 0; i <= num[v]; i++){\n        sdp[i][0] = sdp[i][1] = INF;\n    }\n    \n    sdp[0][0] = a[v];\n    if(a[v] > 0){\n        sdp[0][1] = a[v];\n    }\n    \n    ll curnum = 0;\n    for(auto &child : g[v]){\n        if(child == par) continue;\n        for(ll i = curnum; i >= 0; i--){\n            ll tmp0 = sdp[i][0], tmp1 = sdp[i][1];\n            sdp[i][0] = sdp[i][1] = INF;\n            for(ll j = 0; j <= num[child]; j++){\n                sdp[i + j][0] = min(sdp[i + j][0], tmp0 + dp[child][j][0]);\n                if(dp[child][j][0] < 0 || dp[child][j][1] < INF / 2){\n                    sdp[i + j + 1][0] = min(sdp[i + j + 1][0], tmp0);\n                }\n                if(a[v] > 0){\n                    sdp[i + j][1] = min(sdp[i + j][1], tmp1 + dp[child][j][1]);\n                    if(dp[child][j][0] < 0 || dp[child][j][1] < INF / 2){\n                        sdp[i + j + 1][1] = min(sdp[i + j + 1][1], tmp1);\n                    }\n                }\n            }\n        }\n        curnum += num[child];\n    }\n    for(ll i = 0; i <= num[v]; i++){\n        dp[v][i][0] = sdp[i][0];\n        dp[v][i][1] = sdp[i][1];\n    }\n}\n\n\nint main() {\n    ll n;\n    cin >> n;\n    a.resize(n);\n    REP(i, n){\n        cin >> a[i];\n    }\n    g.resize(n);\n    REP(i, n - 1){\n        ll u, v;\n        cin >> u >> v;\n        u--; v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    \n    num.resize(n);\n    sdp.resize(n + 100, vector<ll>(2));\n    dp.assign(n + 100, vector<vector<ll>>(n + 100, vector<ll>(2, INF)));\n    rec(0, -1);\n    ll ans = n;\n    for(ll i = 0; i <= n; i++){\n        if(dp[0][i][0] < 0){\n            ans = min(ans, i);\n        }\n        if(dp[0][i][1] < INF / 2){\n            ans = min(ans, i);\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cmath>  \n#include <cstdlib>\n#include <ctime>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <string> \n#include <vector>\n#include <bitset>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n\nusing namespace std;\nusing ll = long long;\n\n#define REP(i,n) for(long long i = 0; i < (n); i++)\n#define FOR(i, m, n) for(long long i = (m);i < (n); ++i)\n#define ALL(obj) (obj).begin(),(obj).end()\n\ntemplate<class T> using V = vector<T>;\ntemplate<class T, class U> using P = pair<T, U>;\n\nconst ll MOD = (ll)1e9 + 7;\nconst ll MOD2 = 998244353;\nconst ll LLINF = (ll)1e18;\nconst ll INTINF = (ll)1e9;\nconst long double PI = 3.1415926535897932384626433;\n\ntemplate <class T> void corner(bool flg, T hoge) {if (flg) {cout << hoge << endl; exit(0);}}\ntemplate <class T, class U>ostream &operator<<(ostream &o, const map<T, U>&obj) {o << \"{\"; for (auto &x : obj) o << \" {\" << x.first << \" : \" << x.second << \"}\" << \",\"; o << \" }\"; return o;}\ntemplate <class T>ostream &operator<<(ostream &o, const set<T>&obj) {o << \"{\"; for (auto itr = obj.begin(); itr != obj.end(); ++itr) o << (itr != obj.begin() ? \", \" : \"\") << *itr; o << \"}\"; return o;}\ntemplate <class T>ostream &operator<<(ostream &o, const vector<T>&obj) {o << \"{\"; for (int i = 0; i < (int)obj.size(); ++i)o << (i > 0 ? \", \" : \"\") << obj[i]; o << \"}\"; return o;}\ntemplate <class T, class U>ostream &operator<<(ostream &o, const pair<T, U>&obj) {o << \"{\" << obj.first << \", \" << obj.second << \"}\"; return o;}\ntemplate <template <class tmp>  class T, class U> ostream &operator<<(ostream &o, const T<U> &obj) {o << \"{\"; for (auto itr = obj.begin(); itr != obj.end(); ++itr)o << (itr != obj.begin() ? \", \" : \"\") << *itr; o << \"}\"; return o;}\nvoid print(void) {cout << endl;}\ntemplate <class Head> void print(Head&& head) {cout << head;print();}\ntemplate <class Head, class... Tail> void print(Head&& head, Tail&&... tail) {cout << head << \" \";print(forward<Tail>(tail)...);}\ntemplate <class T> void chmax(T& a, const T b){a=max<T>(a,b);}\ntemplate <class T> void chmin(T& a, const T b){a=min<T>(a,b);}\nvoid YN(bool flg) {cout << ((flg) ? \"YES\" : \"NO\") << endl;}\nvoid Yn(bool flg) {cout << ((flg) ? \"Yes\" : \"No\") << endl;}\nvoid yn(bool flg) {cout << ((flg) ? \"yes\" : \"no\") << endl;}\n\nint main() {\n\tint N; cin >> N;\n\tV<ll> A(N); REP(i,N) cin >> A[i];\n\tV<V<int>> edge(N);\n\tREP(i,N-1){\n\t\tint U,V; cin >> U >> V;\n\t\tU--,V--;\n\t\tedge[U].push_back(V);\n\t\tedge[V].push_back(U);\t\t\n\t}\n\tV<int> depth(N,-1),scale(N,1);\n\tdepth[0] = 0;\n\tqueue<int> q; q.push(0);\n\twhile(q.size()){\n\t\tint from = q.front();\n\t\tq.pop();\n\t\tfor(auto to: edge[from]){\n\t\t\tif(depth[to]!=-1) continue;\n\t\t\tdepth[to] = depth[from] + 1;\n\t\t\tq.push(to);\n\t\t}\n\t}\n\tV<P<int,int>> ord(N);\n\tREP(i,N) ord[i] = {-depth[i],i};\n\tsort(ALL(ord));\n\tfor(int i = 0; i < N; ++i) for(auto to: edge[ord[i].second]) if(depth[ord[i].second] > depth[to]) scale[to] += scale[ord[i].second];\n\t\n\tV<V<ll>> dp1(N,V<ll>(N,LLINF)),dp2(N,V<ll>(N,LLINF));\n\tREP(i,N) (A[i]>0?dp1:dp2)[i][0] = A[i];\n\n\tfor(int i = 0; i < N; ++i){\n\t\tint from = ord[i].second;\n\t\tfor(auto to: edge[from]){\n\t\t\tif(depth[to]>depth[from]) continue;\n\t\t\t\n\t\t\tV<ll> tmp1(N,LLINF),tmp2(N,LLINF);\n\t\t\tfor(int j = 0; j < scale[to]; ++j){\n\t\t\t\tfor(int k = 0; k < scale[from]; ++k){\n\t\t\t\t\t// merge\n\t\t\t\t\tchmin(tmp1[j+k],dp1[to][j]+dp1[from][k]);\n\t\t\t\t\tchmin(tmp2[j+k],dp1[to][j]+dp2[from][k]);\n\t\t\t\t\tchmin(tmp2[j+k],dp2[to][j]+dp1[from][k]);\n\t\t\t\t\tchmin(tmp2[j+k],dp2[to][j]+dp2[from][k]);\n\n\t\t\t\t\t// divide\n\t\t\t\t\tif(dp1[from][k]<LLINF || dp2[from][k] < 0)chmin(tmp1[j+k+1],dp1[to][j]);\n\t\t\t\t\tif(dp1[from][k]<LLINF || dp2[from][k] < 0)chmin(tmp2[j+k+1],dp2[to][j]);\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp1[to] = tmp1;\n\t\t\tdp2[to] = tmp2;\n\t\t}\n\t}\n\n\tint ans = N-1;\n\tfor(int j = 0; j < N; ++j){\n\t\tif(dp1[0][j]<LLINF) chmin(ans,j);\n\t\tif(dp2[0][j]<0) chmin(ans,j);\n\t}\n\tcout << ans << endl;\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing ll = long long;\nconstexpr ll INF = 1e15;\n\nconstexpr int NMAX = 5000;\n// https://img.atcoder.jp/aising2019/editorial.pdf\nint N;\nvector<ll> a(NMAX);\nvector<vector<int>> g(NMAX);\n// dp1[i][j] := i の部分木を条件を満たして j 個に分け,\n//              i を含む成分の a が全て正となるようにするときの i が属する集合の和の最小値\nvector<vector<ll>> dp1(NMAX);\n// dp2[i][j] := i の部分木を j 個に分け,\n//              i を含む成分以外は条件を満たすようにするときの i が属する集合の和の最小値\nvector<vector<ll>> dp2(NMAX);\n\nvector<ll> dfs2(vector<ll> &dp, vector<ll> &c1, vector<ll> &c2, bool flag)\n{\n    int sz0 = dp.size(), sz1 = c1.size(), sz2 = c2.size();\n    vector<ll> ret(sz0 + sz2 - 1, INF);\n    for (int i = 0; i < sz0; i++)\n    {\n        if (dp[i] == INF)\n            continue;\n        for (int j = 0; j < sz1; j++)\n        {\n            if (i + j - 1 >= 0)\n            {\n                if (c1[j] != INF)\n                    ret[i + j - 1] = min(ret[i + j - 1], dp[i] + c1[j]);\n                if (c2[j] != INF && !flag)\n                    ret[i + j - 1] = min(ret[i + j - 1], dp[i] + c2[j]);\n            }\n            if (c1[j] != INF)\n            {\n                ret[i + j] = min(ret[i + j], dp[i]);\n            }\n            if (c2[j] < 0)\n            {\n                ret[i + j] = min(ret[i + j], dp[i]);\n            }\n        }\n    }\n    return ret;\n}\n\nvoid dfs(int cur, int pre)\n{\n    // dp1[cur][0] = INF;\n    dp1[cur].push_back(INF);\n    // dp1[cur][1] = a[cur] or INF\n    dp1[cur].push_back(a[cur] > 0 ? a[cur] : INF);\n    // dp2[cur][0] = INF;\n    dp2[cur].push_back(INF);\n    // dp2[cur][1] = a[cur];\n    dp2[cur].push_back(a[cur]);\n\n    // dp1'[i][j] := cur の i 番目の子迄からなる部分木を dp1 と同条件で\n    //               j 個に分けたときの cur を含む成分の和の最小値\n    for (const auto &u : g[cur])\n    {\n        if (u == pre)\n            continue;\n        dfs(u, cur);\n        dp1[cur] = dfs2(dp1[cur], dp1[u], dp2[u], true);\n        dp2[cur] = dfs2(dp2[cur], dp1[u], dp2[u], false);\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin >> N;\n    for (int i = 0; i < N; i++)\n        cin >> a[i];\n    for (int i = 0; i < N - 1; i++)\n    {\n        int u, v;\n        cin >> u >> v;\n        u--;\n        v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    dfs(0, -1);\n    for (ll k = 1; k <= N; k++)\n    {\n        if (dp1[0][k] != INF || dp2[0][k] < 0)\n        {\n            cout << k - 1 << endl;\n            return 0;\n        }\n    }\n    assert(false);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\n#define max(x, y) ((x)>(y)?(x):(y))\n#define min(x, y) ((x)<(y)?(x):(y))\n\nInt n;\nInt sz[216000];\nInt dp[5010][5010][2];\nInt res;\nInt u, v;\nvector<Int> edge[5400];\nInt a[5400];\nInt tmp[5010][2];\nInt dfs(Int x, Int last= -1){\n  if(a[x] > 0)dp[x][0][0] = a[x];\n  else dp[x][0][1] = a[x];\n  sz[x] = 1;\n  for(Int i = 0;i < edge[x].size();i++){\n    Int to = edge[x][i];\n    if(to == last)continue;\n    dfs(to, x);\n    for(Int j = 0;j < sz[x] + sz[to];j++)tmp[j][0] = tmp[j][1] = INF;\n    for(Int j = sz[x] - 1;j >= 0;j--){\n      for(Int k = sz[to] - 1;k >= 0;k--){\n\ttmp[j+k][0] = min(tmp[j+k][0], dp[x][j][0] + dp[to][k][0]);\n\ttmp[j+k][1] = min(tmp[j+k][1], dp[x][j][1] + dp[to][k][1]);\n\ttmp[j+k][1] = min(tmp[j+k][1], dp[x][j][0] + dp[to][k][1]);\n\ttmp[j+k][1] = min(tmp[j+k][1], dp[x][j][1] + dp[to][k][0]);\n\tif(dp[to][k][1] < 0 || dp[to][k][0] != INF){\n\t  tmp[j+k+1][0] = min(tmp[j+k+1][0], dp[x][j][0]);\n\t  tmp[j+k+1][1] = min(tmp[j+k+1][1], dp[x][j][1]);\n\t}\n      }\n    }\n    for(Int j = 0;j < sz[x] + sz[to];j++){\n      dp[x][j][0] = tmp[j][0];\n      dp[x][j][1] = tmp[j][1];\n    }\n    sz[x] += sz[to];    \n  }\n}\nint main(){\n  cin >> n;\n  for(Int i = 0;i < n;i++)\n    for(Int j = 0;j < n;j++)\n      dp[i][j][0] = dp[i][j][1] = INF;\n  for(Int i = 0;i < n;i++)cin >> a[i];\n  for(Int i = 0;i < n-1;i++){\n    cin >> u >> v;u--,v--;\n    edge[u].push_back(v);\n    edge[v].push_back(u);\n  }\n  dfs(0);\n  for(Int i = n-1;i >= 0;i--){\n    if(dp[0][i][0] != INF)res = i;\n    if(dp[0][i][1] < 0)res = i;\n  }\n  cout << res << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define SORT(a) sort(a.begin(), a.end())\n#define REVERSE(a) reverse(a.begin(), a.end())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define int long long\n#define INF 1000000000000000000\nusing namespace std;\n\n#define ANS(f) if(f) cout << \"YES\" << endl; else cout << \"NO\" << endl;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef pair<int, int> Pii;\n\ntemplate<typename T>\nvoid readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readi(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\nvoid debug(mat m){REP(i, m.size()){ REP(j, m[i].size()){ cout << m[i][j] << \",\"; } cout << endl; }}\n\nstruct edge{int to, cost;};\n\nclass Graph\n{\npublic:\n    int V;\n    vector<vector<edge>> G;\n\n    vec gen, par;\n    mat chi, genlist;\n    int depth;\n\n    Graph(int V): V(V){\n        G = vector<vector<edge>>(V, vector<edge>(0));\n    }\n\n    void add_edge(int from, int to, int cost){\n        G[from].push_back(edge({to, cost}));\n    }\n\n    void add_edge2(int v1, int v2, int cost){\n        add_edge(v1, v2, cost);\n        add_edge(v2, v1, cost);\n    }\n\n    void dfs(int v, int d){\n        gen[v] = d;\n        depth = max(depth, d + 1);\n        REP(k, G[v].size()){\n            if(G[v][k].to == par[v]) continue;\n            par[G[v][k].to] = v;\n            chi[v].push_back(G[v][k].to);\n            dfs(G[v][k].to, d + 1);\n        }\n    }\n\n    mat makegenlist(){\n        REP(v, V) genlist[gen[v]].push_back(v);\n        return genlist;\n    }\n\n    void analyzeTree(int root){\n        gen = vec(V); par = vec(V);\n        chi = mat(V, vec(0));\n        depth = 0;\n        par[root] = -1;\n        dfs(root, 0);\n\n        genlist = mat(depth, vec(0));\n        makegenlist();\n    }\n\n};\n\nsigned main(){\n\n    int N; cin >> N;\n    vec A(N); readv(A);\n    Graph T(N);\n    int U, V;\n    REP(i, N - 1){\n        cin >> U >> V;\n        T.add_edge2(U - 1, V - 1, 0);\n    }\n    T.analyzeTree(0);\n\n    vector<mat> dp(N);\n    vec sz(N, 0);\n    IREP(d, T.depth){\n        for(int v: T.genlist[d]){\n\n            vector<mat> dq(1 + T.chi[v].size());\n\n            sz[v] = 1;\n            dq[0] = mat(2, vec(1, INF));\n            if(A[v] < 0) dq[0][1][0] = A[v];\n            else dq[0][0][0] = A[v];\n            int i0 = 1;\n            for(int chi: T.chi[v]){\n                sz[v] += sz[chi];\n                dq[i0] = mat(2, vec(sz[v], INF));\n                //切る\n                int m = INF;\n                REP(k, sz[chi]){\n                    if(dp[chi][0][k] < INF || dp[chi][1][k] < 0){\n                        m = k;\n                        break;\n                    }\n                }\n                if(m < INF){\n                    REP(k, dq[i0 - 1][0].size()){\n                        dq[i0][0][k + 1 + m] = dq[i0 - 1][0][k];\n                        dq[i0][1][k + 1 + m] = dq[i0 - 1][1][k]; \n                    }\n                }\n                //繫げる         \n                REP(k, sz[chi]){\n                    REP(l, dq[i0 - 1][0].size()){\n                        if(dp[chi][0][k] < INF && dq[i0 - 1][0][l] < INF) dq[i0][0][k + l] = min(dq[i0][0][k + l], dp[chi][0][k] + dq[i0 - 1][0][l]);\n                        if(dp[chi][1][k] < INF && dq[i0 - 1][1][l] < INF) dq[i0][1][k + l] = min(dq[i0][1][k + l], dp[chi][1][k] + dq[i0 - 1][1][l]);\n                        if(dp[chi][0][k] < INF && dq[i0 - 1][1][l] < INF) dq[i0][1][k + l] = min(dq[i0][1][k + l], dp[chi][0][k] + dq[i0 - 1][1][l]);\n                        if(dp[chi][1][k] < INF && dq[i0 - 1][0][l] < INF) dq[i0][1][k + l] = min(dq[i0][1][k + l], dp[chi][1][k] + dq[i0 - 1][0][l]);\n                    }\n                }\n                i0++;\n            }\n\n            dp[v] = dq[T.chi[v].size()];\n            /*\n            cout << v + 1 << endl;\n            REP(i, sz[v]) cout << dp[v][0][i] << \",\";\n            cout << endl;\n            REP(i, sz[v]) cout << dp[v][1][i] << \",\";\n            cout << endl << endl;*/\n        }\n    }\n    int ans = INF;\n    REP(k, sz[0]){\n        if(dp[0][0][k] < INF || dp[0][1][k] < 0){\n            ans = k;\n            break;\n        }\n    }\n    cout << ans;\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\nconst int RANDOM = chrono::high_resolution_clock::now().time_since_epoch().count();\nmt19937 randGen(RANDOM);\nconst int RANDOM_HASH = randGen();\n\nstruct chash\n{\n    int operator()(int x) const { return hash<int>{}(x ^ RANDOM_HASH); }\n};\ntypedef gp_hash_table<int, null_type, chash> hash_set;\ntypedef gp_hash_table<int, int, chash> hash_map;\n\ntypedef long long ll;\n\nconst int MAX_N = 5005;\nconst int MAX_ITERATIONS = 5005;\n\nint n;\nll a[MAX_N];\npair<int, int> edges[MAX_N];\nvector<pair<int, int>> g[MAX_N];\nint randP[MAX_N], randP2[MAX_N];\nbool forbiddenEdge[MAX_N];\nbool used[MAX_N];\nll currSum = 0;\nbool currHaveComp = false;\n\nvoid checkDfs(int u)\n{\n\tused[u] = true;\n\tif (a[u] < 0)\n\t\tcurrHaveComp = true;\n\tcurrSum += a[u];\n\tfor (const auto& p : g[u])\n\t\tif (!used[p.first] && !forbiddenEdge[p.second])\n\t\t\tcheckDfs(p.first);\n}\n\nbool check(int cntEdges)\n{\n\tfor (int it = 0; it < MAX_ITERATIONS; it++)\n\t{\n\t\tshuffle(randP, randP + (n - 1), randGen);\n\t\tmemset(forbiddenEdge, 0, sizeof(forbiddenEdge));\n\t\tfor (int i = 0; i < cntEdges; i++)\n\t\t\tforbiddenEdge[randP[i]] = true;\n\t\tmemset(used, 0, sizeof(used));\n\t\tshuffle(randP2, randP2 + n, randGen);\n\t\tbool currRes = true;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tint u = randP2[i];\n\t\t\tif (used[u])\n\t\t\t\tcontinue;\n\t\t\tcurrSum = 0;\n\t\t\tcurrHaveComp = false;\n\t\t\tcheckDfs(u);\n\t\t\tif (!currHaveComp || currSum < 0)\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t{\n\t\t\t\tcurrRes = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (currRes)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin >> n;\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> a[i];\n\tfor (int i = 0; i < n - 1; i++)\n\t{\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--; v--;\n\t\tedges[i].first = u;\n\t\tedges[i].second = v;\n\t\tg[u].emplace_back(v, i);\n\t\tg[v].emplace_back(u, i);\n\t}\n\n\tfor (int i = 0; i < n - 1; i++)\n\t\trandP[i] = i;\n\tfor (int i = 0; i < n; i++)\n\t\trandP2[i] = i;\n\n\tint l = 0, r = n - 1;\n\twhile (r - l > 1)\n\t{\n\t\tint mid = (l + r) / 2;\n\t\tif (check(mid))\n\t\t\tr = mid;\n\t\telse\n\t\t\tl = mid + 1;\n\t}\n\tif (!check(l))\n\t\tl = r;\n\tcout << l << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long               ll;\nconst int mod = 1e9+7;\n#ifndef M_PI\nconst double M_PI = acos(-1.0);\n#endif\n\nstruct vert{\n  int a;\n  vector<vert *> con;\n  int min_nc = 9999;\n  vector<ll> best;\n  void dfs(vert* par){\n    if(a > 0)\n      min_nc = 0;\n    best.push_back(a);\n    for(vert *nxt : con){\n      if(nxt != par){\n        nxt->dfs(this);\n        if(a > 0){\n          int add = nxt->min_nc;\n          for(int i=0; i<nxt->best.size(); ++i){\n            if(nxt->best[i] < 0){\n              add = min(add, i+1);\n              break;\n            }\n          }\n          min_nc += add;\n        }\n        vector<ll> tmp(best.size()+nxt->best.size()-1, LLONG_MAX);\n        for(int i=0; i<best.size(); ++i){\n          for(int j=0; j<nxt->best.size(); ++j){\n            tmp[i+j] = min(tmp[i+j], best[i]+nxt->best[j]);\n          }\n        }\n        if(nxt->min_nc < 9999){\n          for(int i=0; i<best.size(); ++i){\n            while(i+nxt->min_nc+1 >= tmp.size())\n              tmp.push_back(tmp.back());\n            tmp[i+nxt->min_nc+1] = min(best[i], tmp[i+nxt->min_nc+1]);\n          }\n        }\n        best = tmp;\n      }\n    }\n  }\n};\n\nint main(){\n  int n;\n  cin>>n;\n  vector<vert> graph(n+1);\n  for(int i=1; i<=n; ++i){\n    scanf(\"%d\", &graph[i].a);\n  }\n  for(int i=1; i<n; ++i){\n    int u, v;\n    scanf(\"%d %d\", &u, &v);\n    graph[u].con.push_back(&graph[v]);\n    graph[v].con.push_back(&graph[u]);\n  }\n  graph[1].dfs(0);\n  int res = graph[1].min_nc;\n  for(int i=0; i<graph[1].best.size(); ++i){\n    if(graph[1].best[i] < 0){\n      res = min(res, i);\n      break;\n    }\n  }\n  cout<<res<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fto(i,a,b) for(int i=a; i<=b;++i)\n#define fdto(i,a,b) for(int i=a; i>=b;--i)\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\n#define ll long long\n#define maxn 5009\n#define gb(i,j) ((i>>j)&1)\n#define name \"a\"\n#define endl '\\n'\n\nusing namespace std;\nint s[maxn],c[maxn],n;\nll f[maxn][maxn][2],g[maxn][2];\nvector<int> a[maxn];\nvoid dfs(int u, int p){\n    s[u]=1;\n    if(c[u]<0)f[u][0][1]=c[u];\n    else f[u][0][0]=c[u];\n    for(int v:a[u])\n    if(v!=p){\n        dfs(v,u);\n        fto(i,0,s[u]+s[v]-1)g[i][1]=g[i][0]=1e18;\n        for(int i=0; i<=s[v]-1; ++i){\n            fdto(j,s[u]-1,0){\n                /// cut\n                //if(v==2 && i==0) cout <<','<<j<<' '<< f[v][i][1] <<' '<< f[v][i][0]<<endl;\n                if(f[v][i][1]<0 || f[v][i][0]<1e18){\n                    g[i+j+1][1]=min(g[i+j+1][1],f[u][j][1]);\n                    g[i+j+1][0]=min(g[i+j+1][0],f[u][j][0]);\n                }\n                //if(v==2 && i==0)cout << g[1][1]<<endl;\n                /// not cut\n                if(f[v][i][0]<1e18){\n                    if(f[u][j][0]<1e18)g[i+j][0]=min(g[i+j][0],f[u][j][0]+f[v][i][0]);\n                    if(f[u][j][1]<1e18)g[j+i][1]=min(g[i+j][1],f[u][j][1]+f[v][i][0]);\n                }\n                if(f[v][i][1]<1e18 && min(f[u][j][1],f[u][j][0])<1e18){\n                    g[i+j][1]=min(g[i+j][1],f[v][i][1]+min(f[u][j][1],f[u][j][0]));\n                }\n            }\n        }\n        s[u]+=s[v];\n        //if(u==1)fto(j,0,s[u]-1)cout << g[j][0]<<' '<< g[j][1]<<endl;\n        fto(j,0,s[u]-1)\n            fto(t,0,1)f[u][j][t]=g[j][t];\n        //if(u==4) cout << f[u][1][1]<<endl;\n    }\n}\n\nmain()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n;\n    for(int i=1; i<=n; ++i)cin >> c[i];\n    fto(i,2,n){\n        int x,y;\n        cin >> x >> y;\n        a[x].pb(y);\n        a[y].pb(x);\n    }\n    fto(i,1,n)\n        fto(j,0,n)\n            fto(t,0,1)f[i][j][t]=1e18;\n    dfs(1,0);\n    int res=n-1;\n    //fto(j,1,n){cout << j <<endl;\n    //fto(i,0,n-1)cout << f[j][i][0] <<' '<< f[j][i][1]<<endl;\n    //}\n    fto(i,0,n-1)if(f[1][i][0]<1e18)res=min(res,i);\n    fto(i,0,n-1)if(f[1][i][1]<0)res=min(res,i);\n    cout << res;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, x, n) for(int i = x; i <= n; i++)\n#define rep3(i, x, n) for(int i = x; i >= n; i--)\n#define elif else if\n#define sp(x) fixed << setprecision(x)\n#define pb push_back\n#define eb emplace_back\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)x.size()\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pil = pair<int, ll>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nconst ll MOD = 1e9+7;\n//const ll MOD = 998244353;\nconst int inf = (1<<30)-1;\nconst ll INF = (1LL<<60)-1;\nconst ld EPS = 1e-10;\ntemplate<typename T> bool chmax(T &x, const T &y) {return (x < y)? (x = y, true) : false;};\ntemplate<typename T> bool chmin(T &x, const T &y) {return (x > y)? (x = y, true) : false;};\n\nconst int MAX_V = 5e3;\nvector<int> es[MAX_V];\nll A[MAX_V];\nll dp[MAX_V][MAX_V][2];\nll memo[MAX_V][2];\n\nint dfs(int now, int pre){\n    int sum = 1;\n    if(A[now] > 0) dp[now][0][0] = A[now];\n    else dp[now][0][1] = A[now];\n    for(auto &e: es[now]){\n        if(e == pre) continue;\n        int tmp = dfs(e, now);\n        rep(i, MAX_V) rep(j, 2) memo[i][j] = INF;\n        rep(i, sum){\n            rep(j, tmp){\n                if(dp[e][j][0] < INF || dp[e][j][1] < 0){\n                    chmin(memo[i+j+1][0], dp[now][i][0]);\n                    chmin(memo[i+j+1][1], dp[now][i][1]);\n                }\n                rep(p, 2) rep(q, 2){\n                    int r = (p != 0 || q != 0);\n                    chmin(memo[i+j][r], dp[now][i][p]+dp[e][j][q]);\n                }\n            }\n        }\n        rep(i, MAX_V) rep(j, 2) dp[now][i][j] = memo[i][j];\n        sum += tmp;\n    }\n    return sum;\n}\n\nint main(){\n    int N;\n    cin >> N;\n    rep(i, N) cin >> A[i];\n    rep(i, N-1){\n        int u, v; cin >> u >> v; u--, v--;\n        es[u].pb(v), es[v].pb(u);\n    }\n    rep(i, N) rep(j, N) rep(k, 2) dp[i][j][k] = INF;\n    dfs(0, -1);\n    rep(i, N){\n        if(dp[0][i][0] < INF || dp[0][i][1] < 0){\n            cout << i << endl;\n            break;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define INF 1LL<<50\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\nint n;\nvl a;\nvvl al,dpa,dpb;\nvl up(vl v, vl u1, vl u2, bool ml) {\n\tvl ret(v.size()+u1.size()+1,INF);\n\tfor(int i=0;i<v.size();i++) {\n\t\tif(v[i] == INF) {continue;}\n\t\tfor(int j=0;j<u1.size();j++) {\n\t\t\tif(i+j-1 >= 0) {\n\t\t\t\tif(u1[j] != INF) {ret[i+j-1] = min(ret[i+j-1],v[i]+u1[j]);}\n\t\t\t\tif(!ml && u2[j] != INF) {ret[i+j-1] = min(ret[i+j-1],v[i]+u2[j]);}\n\t\t\t}\n\t\t\tif(u1[j] != INF) {ret[i+j] = min(ret[i+j],v[i]);}\n\n\t\t\tif(u2[j] < 0) {ret[i+j] = min(ret[i+j],v[i]);}\n\t\t}\n\t}\n\treturn ret;\n}\nvoid dfs(int v, int p) {\n\tdpa[v].pb(INF);\n\tdpb[v].pb(INF);\n\tdpa[v].pb(a[v] > 0?a[v]:INF);\n\tdpb[v].pb(a[v]);\n\tfor(int i=0;i<al[v].size();i++) {\n\t\tint u = al[v][i];\n\t\tif(al[v][i] == p) {continue;}\n\t\tdfs(al[v][i],v);\n\t\tdpa[v] = up(dpa[v],dpa[u],dpb[u],true);\n\t\tdpb[v] = up(dpb[v],dpa[u],dpb[u],false);\n\t}\n}\nint main() {\n\tscanf(\"%d \",&n);\n\tal.assign(n,vl());\n\tdpa.assign(n,vl());\n\tdpb.assign(n,vl());\n\tfor(int i=0;i<n;i++) {\n\t\tint t;\n\t\tscanf(\"%d \",&t);\n\t\ta.pb(t);\n\t}\n\tfor(int i=0;i<n-1;i++) {\n\t\tint t,u;\n\t\tscanf(\"%d %d \",&t,&u);\n\t\tt--;u--;\n\t\tal[t].pb(u);\n\t\tal[u].pb(t);\n\t}\n\tdfs(0,-1);\n\tfor(int i=0;i<dpa[0].size();i++) {\n\t\t//printf(\"%lld %lld\\n\",dpa[0][i],dpb[0][i]);\n\t\tif(dpa[0][i] != INF || dpb[0][i] < 0) {printf(\"%d\\n\",i-1);\n\t\t\treturn 0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<ld,ld> pdd;\n\n#define X first\n#define Y second\n\n//#include <boost/unordered_map.hpp>\n//using namespace boost;\n\n/*\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> rbtree;\nrbtree T;\n*/\n\nnamespace io{\n\tconst int L = (1 << 20) + 1;\n\t\n\tchar buf[L], *S , *T, c;\n\t \n\tchar getchar() {\n\t\tif(__builtin_expect(S == T, 0)) {\n\t\t\tT = (S = buf) + fread(buf, 1, L, stdin);\n\t\t\treturn (S == T ? EOF : *S++);\n\t\t}\n\t\treturn *S++;\n\t}\n\t\n\tint inp() {\n\t\tint x = 0, f = 1; char ch;\n\t\tfor(ch = getchar(); !isdigit(ch); ch = getchar())\n\t\t\tif(ch == '-') f = -1;\n\t\tfor(; isdigit(ch); x = x * 10 + ch - '0', ch = getchar());\n\t\treturn x * f;\n\t}\n\t\n\tunsigned inpu()\n\t{\n\t\tunsigned x = 0; char ch;\n\t\tfor(ch = getchar(); !isdigit(ch); ch = getchar());\n\t\tfor(; isdigit(ch); x = x * 10 + ch - '0', ch = getchar());\n\t\treturn x;\n\t}\n\t\n\tll inp_ll() {\n\t\tll x = 0; int f = 1; char ch;\n\t\tfor(ch = getchar(); !isdigit(ch); ch = getchar())\n\t\t\tif(ch == '-') f = -1;\n\t\tfor(; isdigit(ch); x = x * 10 + ch - '0', ch = getchar());\n\t\treturn x * f;\n\t}\n\t\n\tchar B[25], *outs=B+20, *outr=B+20;\n\ttemplate<class T>\n\tinline void print(register T a,register char x=0){\n\t\tif(x) *--outs = x, x = 0;\n\t\t\n\t\tif(!a)*--outs = '0';\n\t\telse \n\t\t\twhile(a)\n\t\t\t\t*--outs = (a % 10) + 48, a /= 10;\n\t\t\n\t\tif(x)\n\t\t\t*--outs = x;\n\t\t\n\t\tfwrite(outs, outr - outs , 1, stdout);\n\t\touts = outr;\n\t}\n};\n\nusing io :: print;\nusing io :: inp;\nusing io :: inpu;\nusing io :: inp_ll;\n\nusing i32 = int;\nusing i64 = long long;\nusing u8 = unsigned char;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing f64 = double;\nusing f80 = long double;\n\nll power(ll a, ll b, ll p)\n{\n\tif (!b) return 1;\n\tll t = power(a, b/2, p);\n\tt = t*t%p;\n\tif (b&1) t = t*a%p;\n\treturn t;\n}\n\nconst int MAXN = 5010;\nconst int MAXP = 10000000;\nconst u64 MOD = 1000000007;\nconst f80 MI = f80(1)/MOD;\nconst ll INF = 10000000000000000LL;\nconst ll inf = 5000000000000LL;\n\nint n;\nint a[MAXN];\nvector<int> v[MAXN];\n\nint size[MAXN];\nll F[MAXN][MAXN][2]; // 0/1 whether there is a computer\nll tmp[MAXN][2];\n\nvoid fresh(ll &a, ll b)\n{\n\tif (a > b) a = b;\n}\n\nvoid dfs(int x, int pre)\n{\n\tsize[x] = 1;\n\tif (a[x] > 0)\n\t{\n\t\tF[x][0][0] = F[x][0][1] = a[x];\n\t}\n\telse\n\t{\n\t\tF[x][0][1] = a[x];\n\t}\n\tfor (auto y : v[x])\n\t{\n\t\tif (y == pre) continue;\n\t\tdfs(y, x);\n\t\tfor (int s = 0; s <= size[x]+size[y]; ++ s)\n\t\t{\n\t\t\ttmp[s][0] = INF;\n\t\t\ttmp[s][1] = INF;\n\t\t}\n\t\tfor (int sx = 0; sx <= size[x]; ++ sx)\n\t\t\tfor (int sy = 0; sy <= size[y]; ++ sy)\n\t\t\t{\n\t\t\t\tfresh(tmp[sx+sy][0], F[x][sx][0]+F[y][sy][0]);\n\t\t\t\tfresh(tmp[sx+sy][1], F[x][sx][1]+F[y][sy][0]);\n\t\t\t\tfresh(tmp[sx+sy][1], F[x][sx][0]+F[y][sy][1]);\n\t\t\t\tfresh(tmp[sx+sy][1], F[x][sx][1]+F[y][sy][1]);\n\t\t\t}\n\t\tfor (int s = 0; s <= size[x]+size[y]; ++ s)\n\t\t{\n\t\t\tF[x][s][0] = tmp[s][0];\n\t\t\tF[x][s][1] = tmp[s][1];\n\t\t}\n\t\tsize[x] += size[y];\n\t}\n\tfor (int s = 0; s <= size[x]; ++ s)\n\t\tif (F[x][s][0] != INF || F[x][s][1] < 0)\n\t\t{\n\t\t\tfor (; s <= size[x]; ++ s)\n\t\t\t{\n\t\t\t\tfresh(F[x][s+1][0], 0);\n\t\t\t\tfresh(F[x][s+1][1], 0);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t/*\n\tfor (int s = size[x]-1; s >= 0; -- s)\n\t{\n\t\tfresh(F[x][s+1][0], 0);\n\t\tfresh(F[x][s+1][1], 0);\n\t\tif (F[x][s][1] < 0)\n\t\t{\n\t\t\tfresh(F[x][s+1][0], 0);\n\t\t\tfresh(F[x][s+1][1], 0);\n\t\t}\n\t}\n\t*/\n}\n\nint main()\n{\n\t\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++ i)\n\t\tscanf(\"%d\", &a[i]);\n\tfor (int i = 1; i < n; ++ i)\n\t{\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tv[x].push_back(y);\n\t\tv[y].push_back(x);\n\t}\n\tfor (int i = 1; i <= n; ++ i)\n\t\tfor (int j = 0; j <= n; ++ j)\n\t\t\tF[i][j][0] = F[i][j][1] = INF;\n\tdfs(1, 0);\n\tfor (int i = 0; i <= n; ++ i)\n\t\tif (F[1][i][0] == 0)\n\t\t{\n\t\t\tcout << i-1 << endl;\n\t\t\tbreak;\n\t\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int N=5e3+2;\nconst int inf=1e15+2;\nint dp[N][N][2],ar[N],sz[N],ndp[N][2];\nvector<int> adj[N];\nvoid dfs(int x,int p){\n\tif(ar[x]>0){\n\t\tdp[x][0][0]=ar[x];\n\t}\t\n\telse{\n\t\tdp[x][0][1]=ar[x];\n\t}\n\tsz[x]=1;\n\tfor(int i:adj[x]){\n\t\tif(i!=p){\n\t\t\tdfs(i,x);\n\t\t\tfor(int j=0;j<sz[x]+sz[i];j++){\n\t\t\t\tndp[j][0]=ndp[j][1]=inf;\n\t\t\t}\n\t\t\tfor(int j=0;j<sz[x];j++){\n\t\t\t\tfor(int k=0;k<sz[i];k++){\n\t\t\t\t\tndp[j+k][0]=min(ndp[j+k][0],dp[x][j][0]+dp[i][k][0]);\n\t\t\t\t\tndp[j+k][1]=min(ndp[j+k][1],min(dp[x][j][1],dp[x][j][0])+min(dp[i][k][1],dp[i][k][0]));\n\t\t\t\t\tif(dp[i][k][1]<0||dp[i][k][0]<inf){\n\t\t\t\t\t\tndp[j+k+1][0]=min(ndp[j+k+1][0],dp[x][j][0]);\n\t\t\t\t\t\tndp[j+k+1][1]=min(ndp[j+k+1][1],dp[x][j][1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0;j<sz[x]+sz[i];j++){\n\t\t\t\tdp[x][j][0]=ndp[j][0];\n\t\t\t\tdp[x][j][1]=ndp[j][1];\n\t\t\t}\n\t\t\tsz[x]+=sz[i];\n\t\t}\n\t}\n}\nsigned main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n,i,j,k,l;\n\tcin>>n;\n\tfor(i=1;i<=n;i++){\n\t\tcin>>ar[i];\n\t\tfor(j=0;j<=n;j++){\n\t\t\tdp[i][j][0]=dp[i][j][1]=inf;\n\t\t}\n\t}\n\tfor(i=1;i<n;i++){\n\t\tcin>>j>>k;\n\t\tadj[j].push_back(k);\n\t\tadj[k].push_back(j);\n\t}\n\tdfs(1,1);\n\tfor(i=0;i<=n;i++){\n\t\tif(dp[1][i][0]<inf||dp[1][i][1]<0){\n\t\t\tcout<<i;\n\t\t\treturn 0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 1000000007;\nconst ll MAX = 4000001;\nconst double eps = 1E-18;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n\tlong long x;\npublic:\n\tmint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n\tmint operator-() const {\n\t\treturn mint(-x);\n\t}\n\tmint& operator+=(const mint& a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint& a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const  mint& a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint& a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\n\nmint pw(mint a, ll b) {\n\tif (b == 0) { return 1; }\n\tmint ret = pw(a, b >> 1);\n\tret *= ret;\n\tif (b & 1) { ret *= a; }\n\treturn ret;\n}\n\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<vector<vector<ll>>> vvvll;\n\ntypedef vector<mint> vmint;\ntypedef vector<vector<mint>> vvmint;\ntypedef vector<vector<vector<mint>>> vvvmint;\n\n//////////////////////////////////////\nll N;\nvll A;\nvvll g;\n\nvvll mn;\nvll dp1;\nvll dp2;\n\nvll merge(vll a, vll b) {\n\t//rep(i, a.size())cout << a[i] << \" \";\n\t//cout << endl;\n\t//rep(i, b.size())cout << b[i] << \" \";\n\t//cout << endl;\n\n\tvll c(a.size() + b.size() - 1, INF);\n\trep(i, a.size())rep(j, b.size()) {\n\t\tc[i + j] = min(c[i + j], a[i] + b[j]);\n\t}\n\treturn c;\n}\n\nvoid dfs(ll u, ll v) {\n\tmn[v].assign(1, A[v]);\n\n\tfor (ll w : g[v]) {\n\t\tif (u == w) { continue; }\n\t\tdfs(v, w);\n\n\t\tvll b(mn[w].size() + 1, INF);\n\t\trep(i, mn[w].size()+1) {\n\t\t\tif(i<mn[w].size())b[i] = mn[w][i];\n\t\t\tif (i >= dp1[w] + 1) { b[i] = min(0, b[i]); }\n\t\t}\n\t\tmn[v]=merge(mn[v], b);\n\t}\n\n\tif (A[v] < 0) { dp1[v] = INF; }\n\telse {\n\t\tdp1[v] = 0;\n\t\tfor (ll w : g[v]) {\n\t\t\tif (u == w) { continue; }\n\t\t\tdp1[v] += min(dp1[w], dp2[w] + 1);\n\t\t}\n\t}\n\n\tdp2[v] = INF;\n\trep(i, mn[v].size()) {\n\t\tif (mn[v][i] < 0) { dp2[v] = i; break; }\n\t}\n\n\t//cout << v << \" \" << dp1[v] << \" \" << dp2[v] << endl;\n\t//for (ll x : mn[v]) { cout << x << \" \"; }\n\t//cout << endl;\n\n\treturn;\n}\n\nint main() {\n\tcin >> N;\n\tA.assign(N + 1, 0);\n\trepn(i, N)cin >> A[i];\n\n\tg.resize(N + 1);\n\trepn(i, N-1) {\n\t\tll u, v;\n\t\tcin >> u >> v;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\n\tmn.resize(N + 1);\n\tdp1.resize(N + 1);\n\tdp2.resize(N + 1);\n\n\tdfs(0, 1);\n\n\tcout << min(dp1[1], dp2[1]) << endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// #define int long long\n#define rep(i, n) for (long long i = (long long)(0); i < (long long)(n); ++i)\n#define reps(i, n) for (long long i = (long long)(1); i <= (long long)(n); ++i)\n#define rrep(i, n) for (long long i = ((long long)(n)-1); i >= 0; i--)\n#define rreps(i, n) for (long long i = ((long long)(n)); i > 0; i--)\n#define irep(i, m, n) for (long long i = (long long)(m); i < (long long)(n); ++i)\n#define ireps(i, m, n) for (long long i = (long long)(m); i <= (long long)(n); ++i)\n#define SORT(v, n) sort(v, v + n);\n#define REVERSE(v, n) reverse(v, v+n);\n#define vsort(v) sort(v.begin(), v.end());\n#define all(v) v.begin(), v.end()\n#define mp(n, m) make_pair(n, m);\n#define cout(d) cout<<d<<endl;\n#define coutd(d) cout<<std::setprecision(10)<<d<<endl;\n#define cinline(n) getline(cin,n);\n#define replace_all(s, b, a) replace(s.begin(),s.end(), b, a);\n#define PI (acos(-1))\n#define FILL(v, n, x) fill(v, v + n, x);\n#define sz(x) long long(x.size())\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing vs = vector<string>;\nusing vpll = vector<pair<ll, ll>>;\nusing vtp = vector<tuple<ll,ll,ll>>;\nusing vb = vector<bool>;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nconst ll INF = 1e9+10;\nconst ll MOD = 1e9+7;\nconst ll LINF = 1e18;\n\nll n;\nvll a;\nvi G[5005];\n\nint num[5005];\nll dp[5005][5005][2]; // vで条件を満たすようにi辺取り除いたときvの連結成分の和の最小値(j=1なら全ての成分が正である)\n\nvoid dfs(int v, int p){\n  vi child;\n  for(auto &nv: G[v]){\n    if(nv==p) continue;\n    dfs(nv,v);\n    child.push_back(nv);\n  }\n  \n  dp[v][0][(a[v]>0)]=a[v];\n  \n  for(auto &nv: child){\n    vvll sub(num[v]+num[nv]+2, vll(2,LINF));\n    for(int i=0; i<=num[v]; i++){\n      for(int j=0; j<=num[nv]; j++){\n        rep(k1,2) rep(k2,2){\n          ll v1=dp[v][i][k1], v2=dp[nv][j][k2];\n          if(max(v1,v2)==LINF) continue;\n          chmin(sub[i+j][k1&k2], v1+v2);\n          if(k2==1 || v2<0) chmin(sub[i+j+1][k1], v1);\n        }\n      }\n    }\n    num[v]+=num[nv]+1;\n    for(int i=0; i<=num[v]; i++) for(int j=0; j<2; j++){\n      dp[v][i][j]=sub[i][j];\n    }\n  }\n}\n\nsigned main()\n{\n  cin.tie( 0 ); ios::sync_with_stdio( false );\n  \n  cin>>n;\n  a.resize(n);\n  rep(i,n) cin>>a[i];\n  rep(i,n-1){\n    ll a,b; cin>>a>>b; a--,b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  \n  rep(i,n+1) rep(j,n+1) rep(k,2) dp[i][j][k]=LINF;\n  dfs(0,-1);\n  \n  ll ans=LINF;\n  // rep(i,n) cout<<dp[0][i][0]<<' ';\n  // cout<<endl;\n  // rep(i,n) cout<<dp[0][i][1]<<' ';\n  // cout<<endl;\n  \n  rep(i,n){\n    if(dp[0][i][0]<0 || dp[0][i][1]!=LINF){\n      ans=i;\n      break;\n    }\n  }\n  \n  cout<<ans<<endl;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int64 INF = 1LL << 58;\n\nvector< int > g[5000];\nint N, A[5000];\nvector< bool > latte[5000];\nvector< int64 > malta[5000];\n\nvoid chmin(int64 &a, int64 b) { a = min(a, b); }\n\nvoid dfs(int idx, int par) {\n  for(auto &to : g[idx]) {\n    if(to == par) continue;\n    dfs(to, idx);\n  }\n\n  latte[idx].emplace_back(A[idx] > 0);\n  for(auto &to : g[idx]) {\n    if(to == par) continue;\n    if(A[to] > 0) {\n      vector< bool > nxt(latte[idx].size() + latte[to].size());\n      for(int i = 0; i < latte[idx].size(); i++) {\n        for(int j = 0; j < latte[to].size(); j++) {\n          if(latte[idx][i] & latte[to][j]) {\n            nxt[i + j] = true;\n          }\n        }\n        for(int j = 0; j < malta[to].size(); j++) {\n          if(!latte[idx][i] || malta[to][j] >= 0) continue;\n          nxt[i + j + 1] = true;\n        }\n      }\n      latte[idx].swap(nxt);\n    } else {\n      vector< bool > nxt(latte[idx].size() + latte[to].size());\n      for(int i = 0; i < latte[idx].size(); i++) {\n        for(int j = 0; j < malta[to].size(); j++) {\n          if(!latte[idx][i] || malta[to][j] >= 0) continue;\n          nxt[i + j + 1] = true;\n        }\n      }\n      latte[idx].swap(nxt);\n    }\n  }\n\n\n  malta[idx].emplace_back(A[idx]);\n  for(auto &to : g[idx]) {\n    if(to == par) continue;\n    vector< int64 > nxt(malta[idx].size() + malta[to].size(), INF);\n    for(int i = 0; i < malta[idx].size(); i++) {\n      for(int j = 0; j < latte[to].size(); j++) {\n        if(latte[to][j]) chmin(nxt[i + j + 1], malta[idx][i]);\n      }\n      for(int j = 0; j < malta[to].size(); j++) {\n        if(malta[idx][j] == INF) continue;\n        if(malta[to][j] == INF) continue;\n        chmin(nxt[i + j], malta[idx][i] + malta[to][j]);\n      }\n\n      for(int j = 0; j < malta[to].size(); j++) {\n        if(malta[idx][j] == INF) continue;\n        if(malta[to][j] >= 0) continue;\n        chmin(nxt[i + j + 1], malta[idx][i]);\n      }\n\n    }\n    malta[idx].swap(nxt);\n  }\n\n  for(int i = 0; i < malta[idx].size(); i++) {\n    if(malta[idx][i] < 0) latte[idx][i] = true;\n  }\n\n}\n\n\nint main() {\n  cin >> N;\n  for(int i = 0; i < N; i++) cin >> A[i];\n  for(int i = 1; i < N; i++) {\n    int x, y;\n    cin >> x >> y;\n    --x, --y;\n    g[x].emplace_back(y);\n    g[y].emplace_back(x);\n  }\n  dfs(0, -1);\n  for(int i = 0; i < latte[0].size(); i++) {\n    if(latte[0][i]) {\n      cout << i << endl;\n      exit(0);\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid chmin(int64_t& a, int64_t b){\n    a = min(a, b);\n}\n\nint N;\nint64_t A[5000];\nvector<int> edges[5000];\n\nint64_t dp[5000][5000][2], sub[5000][2];\nint sz[5000];\n\nconst int64_t INF = 1e18;\n\nvoid dfs(int i, int p){\n    for(int j=0; j<N; j++) for(int k=0; k<2; k++) dp[i][j][k] = sub[j][k] = INF;\n    dp[i][0][(A[i] < 0)] = A[i];\n    for(int j : edges[i]) if(j != p){\n        dfs(j, i);\n        for(int n1=0; n1<=sz[i]; n1++) for(int n2=0; n2<=sz[j]; n2++) for(int k1=0; k1<2; k1++) for(int k2=0; k2<2; k2++){\n            int64_t v1 = dp[i][n1][k1], v2 = dp[j][n2][k2];\n            if(max(v1, v2) == INF) continue;\n            chmin(sub[n1+n2][k1|k2], v1+v2);\n            if(k2 == 0 || v2 < 0) chmin(sub[n1+n2+1][k1], v1);\n        }\n        sz[i] += sz[j] + 1;\n        for(int j=0; j<=sz[i]; j++) for(int k=0; k<2; k++){\n            dp[i][j][k] = sub[j][k];\n            sub[j][k] = INF;\n        }\n    }\n}\n\nint main(){\n    cin >> N;\n    for(int i=0; i<N; i++) cin >> A[i];\n    for(int i=0; i<N-1; i++){\n        int a, b;\n        cin >> a >> b;\n        edges[a-1].push_back(b-1);\n        edges[b-1].push_back(a-1);\n    }\n\n    dfs(0, -1);\n    for(int j=0; j<N; j++) if(dp[0][j][0] < INF || dp[0][j][1] < 0){\n        cout << j << endl;\n        return 0;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <assert.h>\n#include <fstream>\n#include <iostream>\n#include <algorithm>\n#include <array>\n#include <vector>\n#include <queue>\n#include <set>\n#include <cmath>\n#include <iomanip>\n//#include <unordered_map>\n//#include <unordered_set>\n//#include <boost/container/static_vector.hpp>\n//#include <boost/unordered_set.hpp>\n//#include <boost/unordered_map.hpp>\n//#include <unistd.h>\n\nclass Tree {\n    public:\n    struct Node {\n        std::vector<int> edge;\n        int rank;\n        int child_bond_num;\n        int direction;\n    };\n    std::vector<Node> node;\n    Tree() {}\n    Tree(const int node_num_max) {\n        node.resize(node_num_max);\n    }\n    void add_directed_edge(const int from, const int to) {\n        node[from].edge.push_back(to);\n    }\n    void add_undirected_edge(const int node1, const int node2) {\n        add_directed_edge(node1, node2);\n        add_directed_edge(node2, node1);\n    }\n    void set_rank(int n, int rank, int parent) { // 辺が有向でも無向でも使える。呼び出すとき、parentは-1にしておくとよい。\n        node[n].rank = rank;\n        for (int c : node[n].edge) {\n            if (c != parent) {\n                set_rank(c, rank + 1, n);\n            }\n        }\n    }\n    int calc_diameter(int max_idx) {\n        // 点は1～max_idxという想定。\n        set_rank(1, 0, -1);\n        int tmp_idx = 1;\n        int tmp_diameter = 0;\n        for (int i = 1; i <= max_idx; i++) {\n            if (tmp_diameter < node[i].rank) {\n                tmp_idx = i;\n                tmp_diameter = node[i].rank;\n            }\n        }\n        set_rank(tmp_idx, 0, -1);\n        for (int i = 1; i <= max_idx; i++) {\n            tmp_diameter = std::max(tmp_diameter, node[i].rank);\n        }\n        return tmp_diameter;\n    }\n};\n\nconst int MAX_N = 5050;\nint N, U[MAX_N], V[MAX_N];\nlong long A[MAX_N];\n\nTree tree = Tree(MAX_N);\n\nlong long dp_pos[MAX_N][MAX_N], dp_neg[MAX_N][MAX_N];\nlong long MAX_V = (long long)1000000000 * 10000;\n\nlong long dp_pos_tmp[MAX_N][MAX_N], dp_neg_tmp[MAX_N][MAX_N];\n\nvoid merge(int n) {\n    int child[MAX_N];\n    int child_num = 0;\n    for (int i = 0; i < tree.node[n].edge.size(); i++) {\n        int c = tree.node[n].edge[i];\n        if (tree.node[c].rank > tree.node[n].rank) {\n            child[child_num+1] = c;\n            child_num++;\n        }\n    }\n\n    dp_pos_tmp[0][0] = 0 < A[n] ? A[n] : MAX_V;\n    dp_neg_tmp[0][0] = A[n];\n\n    tree.node[n].child_bond_num = 0;\n    for (int i = 1; i <= child_num; i++) {\n        int c = child[i];\n\n        for (int j = 0; j <= tree.node[n].child_bond_num + tree.node[c].child_bond_num + 1; j++) {\n            dp_pos_tmp[i][j] = MAX_V;\n            dp_neg_tmp[i][j] = MAX_V;\n        }\n\n        for (int j = 0; j <= tree.node[n].child_bond_num; j++) {\n            for (int k = 0; k <= tree.node[c].child_bond_num; k++) {\n                //if (n == 4) {\n                //    std::cout << \"check_s:\" << i << \" \" << j << \" \" << k << \" \" << dp_neg_tmp[i][1] << \" \" << dp_neg_tmp[i-1][j] << \" \" << dp_pos[c][k] << \" \" << dp_neg[c][k] << std::endl;\n                //}\n                if (dp_neg_tmp[i-1][j] < MAX_V && (dp_neg[c][k] < 0 || dp_pos[c][k] < MAX_V)) {\n                    dp_neg_tmp[i][j+k+1] = std::min(dp_neg_tmp[i][j+k+1], dp_neg_tmp[i-1][j]);\n                }\n                if (dp_neg_tmp[i-1][j] < MAX_V && dp_pos[c][k] < MAX_V) {\n                    dp_neg_tmp[i][j+k] = std::min(dp_neg_tmp[i][j+k], dp_neg_tmp[i-1][j] + dp_pos[c][k]);\n                }\n                if (dp_neg_tmp[i-1][j] < MAX_V && dp_neg[c][k] < MAX_V) {\n                    dp_neg_tmp[i][j+k] = std::min(dp_neg_tmp[i][j+k], dp_neg_tmp[i-1][j] + dp_neg[c][k]);\n                }\n                if (0 < A[n]) {\n                    dp_pos_tmp[i][j+k] = std::min(dp_pos_tmp[i][j+k], dp_pos_tmp[i-1][j] + dp_pos[c][k]);\n                    if (dp_pos[c][k] < MAX_V || dp_neg[c][k] < 0) {\n                        dp_pos_tmp[i][j+k+1] = std::min(dp_pos_tmp[i][j+k+1], dp_pos_tmp[i-1][j]);\n                    }\n                }\n\n                //if (n == 4) {\n                //    std::cout << \"check_e:\" << i << \" \" << j << \" \" << k << \" \" << dp_neg_tmp[i][1] << \" \" << dp_neg_tmp[i-1][j] << \" \" << dp_pos[c][k] << \" \" << dp_neg[c][k] << std::endl;\n                //}\n\n            }\n        }\n        tree.node[n].child_bond_num += 1 + tree.node[c].child_bond_num;\n\n        //for (int j = 0; j <= tree.node[n].child_bond_num; j++) {\n        //    std::cout << n << \" \" << i << \" \" << j << \" \" << dp_pos_tmp[i][j] << \" \" << dp_neg_tmp[i][j] << std::endl;\n        //}\n\n    }\n\n    for (int j = 0; j <= tree.node[n].child_bond_num; j++) {\n        dp_pos[n][j] = dp_pos_tmp[child_num][j];\n        dp_neg[n][j] = dp_neg_tmp[child_num][j];\n    }\n\n    //for (int i = 0; i <= tree.node[n].child_bond_num; i++) {\n    //    std::cout << n << \" \" << i << \" \" << dp_pos[n][i] << \" \" << dp_neg[n][i] << std::endl;\n    //}\n\n}\n\nint main(int argc, char **argv) {\n    std::cin >> N;\n    \n    for (int i = 1; i <= N; i++) {\n        std::cin >> A[i];\n    }\n\n    for (int i = 1; i <= N - 1; i++) {\n        std::cin >> U[i] >> V[i];\n    }\n\n    for (int i = 1; i <= N - 1; i++) {\n        tree.add_undirected_edge(U[i], V[i]);\n    }\n\n    tree.set_rank(1, 0, -1);\n\n    std::vector<int> nodes;\n    for (int i = 1; i <= N; i++) {\n        nodes.push_back(i);\n    }\n\n    std::sort(nodes.begin(), nodes.end(),\n        [](const int a, const int b) { return tree.node[a].rank > tree.node[b].rank; }\n    );\n\n    for (int n : nodes) {\n        merge(n);\n        //if (n == 4) {\n        //    break;\n        //}\n    }\n\n    int ret = N;\n    for (int i = 0; i <= N; i++) {\n        if (dp_pos[1][i] < MAX_V || dp_neg[1][i] < 0) {\n            ret = std::min(ret, i);\n        }\n    }\n\n    std::cout << ret << std::endl;\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\n\nconst ll INF = 100000000000000000;\n\nstruct Graph\n{\n    int n;\n    vector<vector<int>> g;\n    \n    Graph(int n) : n(n){\n        g.resize(n);\n    }\n    \n    void init(int n_){\n        n = n_;\n        g.resize(n_);\n    }\n    \n    void add_edge(int from, int to){\n        g[from].push_back(to);\n    }\n};\n\nstruct Tree\t//create tree(directed) from graph(undirected)\n{\n    int n;\n    int root;\n    vector<vector<int>> t;\n    vector<int> par;\n    vector<int> dpt;\n    \n    void init(Graph &g, int root_){\n        n = g.n;\n        root = root_;\n        t.resize(n);\n        par.resize(n);\n        dpt.resize(n);\n        fill(dpt.begin(), dpt.end(), -1);\n        queue<int> que;\n        par[root] = -1;\n        dpt[root] = 0;\n        que.push(root);\n        while(que.size()){\n            int pa = que.front();\n            que.pop();\n            for(int ch : g.g[pa]){\n                if(dpt[ch] == -1){\n                    t[pa].push_back(ch);\n                    par[ch] = pa;\n                    dpt[ch] = dpt[pa] + 1;\n                    que.push(ch);\n                }\n            }\n        }\n    }\n\n    Tree(){}\n    \n    Tree(Graph &g, int root_){\n        init(g, root_);\n    }\n    \n    vector<int> toposort(){\n        typedef pair<int, int> P;\n        vector<P> p(n);\n        for(int i = 0; i < n; i++) p[i] = P(dpt[i], i);\n        sort(p.begin(), p.end(), greater<P>());\n        vector<int> res(n);\n        for(int i = 0; i < n; i++) res[i] = p[i].second;\n        return res;\n    }\n};\n\nll dp[5005][2][5005];\nint w[5005];\n\nint main()\n{\n    int n;\n    cin >> n;\n    ll a[5005];\n    for(int i = 0; i < n; i++) cin >> a[i];\n    Graph g(n);\n    for(int i = 0; i < n - 1; i++){\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        g.add_edge(u, v);\n        g.add_edge(v, u);\n    }\n    Tree t(g, 0);\n    vector<int> d = t.toposort();\n    int s[5002];\n    for(int i = 0; i < n; i++){\n        int u = d[i];\n        s[u] = 1;\n        for(int v : t.t[u]){\n            s[u] += s[v];\n        }\n    }\n    for(int i = 0; i < n; i++){\n        for(int k = 0; k <= n; k++) dp[i][0][k] = dp[i][1][k] = INF;\n        dp[i][0][0] = 0;\n    }\n    for(int i = 0; i < n; i++){\n        int u = d[i];\n        int r = 1;\n        for(int j = 1; j <= (int)t.t[u].size(); j++){\n            int v = t.t[u][j - 1];\n            for(int k = 0; k < r + s[u]; k++){\n                dp[u][j % 2][k] = INF;\n            }\n            for(int k = 0; k < r; k++){\n                for(int l = 0; l <= s[v]; l++){\n                    dp[u][j % 2][k + l] = min(dp[u][j % 2][k + l], dp[u][(j + 1) % 2][k] + dp[v][0][l]);\n                }\n            }\n            r += s[v];\n        }\n        if((int)t.t[u].size() % 2){\n            for(int k = 0; k < r; k++) dp[u][0][k] = dp[u][1][k];\n        }\n        for(int k = 0; k < r; k++) dp[u][0][k] += a[u];\n        dp[u][0][r] = 0;\n        if(a[u] > 0){\n            for(int v : t.t[u]){\n                int k;\n                for(k = 0; k < s[v]; k++){\n                    if(dp[v][0][k] < 0) break;\n                }\n                w[u] += min(w[v], k + 1);\n            }\n            for(int k = w[u] + 1; k <= s[u]; k++) dp[u][0][k] = min(dp[u][0][k], 0ll);\n        }\n        else{\n            w[u] = n;\n        }\n    }\n    int ans;\n    for(ans = 0; ans <= s[0]; ans++){\n        if(dp[0][0][ans] < 0) break;\n    }\n    ans = min(ans, w[0]);\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <type_traits>\nusing namespace std;\n\nusing ll=int64_t;\n#define int ll\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back\n#define ALL(x) x.begin(),x.end()\nauto& errStream=cerr;\n#ifdef LOCAL\n#define cerr (cerr<<\"-- line \"<<__LINE__<<\" -- \")\n#else\nclass CerrDummy{}cerrDummy;\ntemplate<class T>\nCerrDummy& operator<<(CerrDummy&cd,const T&){\n\treturn cd;\n}\nusing charTDummy=char;\nusing traitsDummy=char_traits<charTDummy>;\nCerrDummy& operator<<(CerrDummy&cd,basic_ostream<charTDummy,traitsDummy>&(basic_ostream<charTDummy,traitsDummy>&)){\n\treturn cd;\n}\n#define cerr cerrDummy\n#endif\n#define REACH cerr<<\"reached\"<<endl\n#define DMP(x) cerr<<#x<<\":\"<<x<<endl\n#define ZERO(x) memset(x,0,sizeof(x))\n#define ONE(x) memset(x,-1,sizeof(x))\n\nusing pi=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"{\";\n\tREP(i,(int)v.size()){\n\t\tif(i)os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\nll read(){\n\tll i;\n\tscanf(\"%\"  SCNd64,&i);\n\treturn i;\n}\n\nvoid printSpace(){\n\tprintf(\" \");\n}\n\nvoid printEoln(){\n\tprintf(\"\\n\");\n}\n\nvoid print(ll x,int suc=1){\n\tprintf(\"%\" PRId64,x);\n\tif(suc==1)\n\t\tprintEoln();\n\tif(suc==2)\n\t\tprintSpace();\n}\n\nstring readString(){\n\tstatic char buf[3341000];\n\tscanf(\"%s\",buf);\n\treturn string(buf);\n}\n\nchar* readCharArray(){\n\tstatic char buf[3341000];\n\tstatic int bufUsed=0;\n\tchar* ret=buf+bufUsed;\n\tscanf(\"%s\",ret);\n\tbufUsed+=strlen(ret)+1;\n\treturn ret;\n}\n\ntemplate<class T,class U>\nvoid chmax(T& a,U b){\n\tif(a<b)\n\t\ta=b;\n}\n\ntemplate<class T,class U>\nvoid chmin(T& a,U b){\n\tif(b<a)\n\t\ta=b;\n}\n\ntemplate<class T>\nT Sq(const T& t){\n\treturn t*t;\n}\n\n#define CAPITAL\nvoid Yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nconst int S=5010;\nint a[S],dp1[S][S],dp2[S];\nvi tr[S];\n\nint dfs(int v,int p){\n\tint s=1;\n\tif(a[v]>0)\n\t\tdp2[v]=0;\n\tdp1[v][0]=a[v];\n\tfor(auto ch:tr[v])\n\t\tif(ch!=p){\n\t\t\tint t=dfs(ch,v);\n\t\t\t{\n\t\t\t\tint w=dp2[ch];\n\t\t\t\tREP(i,t)\n\t\t\t\t\tif(dp1[ch][i]<0)\n\t\t\t\t\t\tchmin(w,i+1);\n\t\t\t\tdp2[v]+=w;\n\t\t\t\tchmin(dp2[v],inf);\n\t\t\t}\n\t\t\tREP(i,t)if(dp1[ch][i]<0)\n\t\t\t\tchmin(dp1[ch][i+1],0);\n\t\t\tif(dp2[ch]<t)\n\t\t\t\tchmin(dp1[ch][dp2[ch]+1],0);\n\t\t\tfor(int i=s;i>=0;i--){\n\t\t\t\tint w=dp1[v][i];\n\t\t\t\tdp1[v][i]=inf;\n\t\t\t\tREP(j,t+1){\n\t\t\t\t\tchmin(dp1[v][i+j],w+dp1[ch][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\ts+=t;\n\t\t}\n\treturn s;\n}\n\n\nsigned main(){\n\tint n=read();\n\tREP(i,n+1){\n\t\tREP(j,n+1)\n\t\t\tdp1[i][j]=inf;\n\t\tdp2[i]=inf;\n\t}\n\tREP(i,n)\n\t\ta[i]=read();\n\tREP(_,n-1){\n\t\tint u=read()-1,v=read()-1;\n\t\ttr[u].PB(v);\n\t\ttr[v].PB(u);\n\t}\n\tdfs(0,-1);\n\tint ans=dp2[0];\n\tREP(i,n)if(dp1[0][i]<0)\n\t\tchmin(ans,i);\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FAST ios_base::sync_with_stdio(false); cin.tie(0);\n#define pb push_back\n#define eb emplace_back\n#define ins insert\n#define f first\n#define s second\n#define cbr cerr << \"hi\\n\"\n#define mmst(x, v) memset((x), v, sizeof ((x)))\n#define siz(x) ll(x.size())\n#define all(x) (x).begin(), (x).end()\n#define lbd(x,y) (lower_bound(all(x),y)-x.begin())\n#define ubd(x,y) (upper_bound(all(x),y)-x.begin())\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());    //can be used by calling rng() or shuffle(A, A+n, rng)\ninline long long rand(long long x, long long y) { return (rng() % (y+1-x)) + x; } //inclusivesss\nstring inline to_string(char c) {string s(1,c);return s;} template<typename T> inline T gcd(T a,T b){ return a==0?llabs(b):gcd(b%a,a); }\n\ntypedef long long ll; \ntypedef long double ld;\n#define FOR(i,s,e) for(ll i=s;i<=ll(e);++i)\n#define DEC(i,s,e) for(ll i=s;i>=ll(e);--i)\ntypedef pair<ll,ll>pi; typedef pair<ll,pi>spi; typedef pair<pi,pi>dpi;\n\n#define LLINF ((long long)1e18)\n#define INF int(1e9+1e6)\n#define MAXN (5006)\nll n,A[MAXN],dp[MAXN][MAXN],sz[MAXN];// if 0 then max, 1 then min\nbitset<MAXN> dp2[MAXN];\nvector<int>v[MAXN];\nvoid dfs(ll x,ll p){\n\tsz[x]=1;\n\tdp[x][0]=A[x];\n\tfor(auto i:v[x]) if(i^p) dfs(i,x), sz[x]+=sz[i];\n\tll cur = 1;\n\tif(A[x]>0)dp2[x][0]=1;\n\tfor(auto i:v[x]) if(i^p) {\n\t\tcur += sz[i];\n\t\tDEC(j,cur,0){\n\t\t\tif(dp[x][j]<LLINF) dp[x][j] += dp[i][0];\n\t\t\tdp2[x][j] = dp2[x][j] & dp2[i][0];\n\t\t\tFOR(k,1,min(j,sz[i])){\n\t\t\t\tdp[x][j]=min(dp[x][j],dp[x][j-k]+dp[i][k]);\n\t\t\t\tif(dp2[i][k-1]) dp[x][j]=min(dp[x][j],dp[x][j-k]);\n\t\t\t\tdp2[x][j]=dp2[x][j]|(dp2[x][j-k]&dp2[i][k]);\n\t\t\t\tif(dp[i][k-1] < 0) dp2[x][j]=dp2[x][j]|dp2[x][j-k];\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tFAST\n\tcin>>n;\n\tFOR(i,1,n)cin>>A[i];\n\tFOR(i,2,n){\n\t\tll a,b;cin>>a>>b;\n\t\tv[a].eb(b),v[b].eb(a);\n\t}\n\tFOR(i,0,MAXN-1)FOR(j,0,MAXN-1)dp[i][j]=LLINF;\n\tdfs(1,1);\n\tll ans = n-1;\n\tFOR(k,0,n-1) if(dp[1][k] < 0) ans = min(ans, k);\n\tFOR(k,0,n-1) if(dp2[1][k]) ans = min(ans, k);\n\tcout<<ans<<'\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n#ifdef _DEBUG\n#define _GLIBCXX_DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n#define int long long\n#define ll long long\n#define ll1 1ll\n#define ONE 1ll\n#define DBG 1\n#define rep(i, a, b) for (int i = (a); i < (b); i++)\n#define rrep(i, a, b) for (int i = (b)-1; i >= (a); i--)\n#define loop(n) rep(loop, (0), (n))\n#define all(c) begin(c), (c)\nconst int INF =\nsizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\nconst double PI = acos(-1);\nconst double EPS = 1e-9;\n#define fi first\n#define se second\n#define pb push_back\n#define eb emplace_back\nusing pii = pair<int, int>;\n// template<class T> ostream &operator<<(ostream &os,T &t){dump(t);return os;}\ntemplate <typename T, typename S>\nistream &operator>>(istream &is, pair<T, S> &p) {\n\tis >> p.first >> p.second;\n\treturn is;\n}\ntemplate <typename T, typename S>\nostream &operator<<(ostream &os, pair<T, S> &p) {\n\tos << p.first << \" \" << p.second;\n\treturn os;\n}\n\ntemplate <typename T> void printvv(const vector<vector<T>> &v) {\n\tcerr << endl;\n\trep(i, 0, v.size()) rep(j, 0, v[i].size()) {\n\t\tif (typeid(v[i][j]).name() == typeid(INF).name() and v[i][j] == INF) {\n\t\t\tcerr << \"INF\";\n\t\t}\n\t\telse\n\t\t\tcerr << v[i][j];\n\t\tcerr << (j == v[i].size() - 1 ? '\\n' : ' ');\n\t}\n\tcerr << endl;\n}\n/*\ntypedef __int128_t Int;\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {\nstd::ostream::sentry s(dest);\n  if (s) {\n\t__uint128_t tmp = value < 0 ? -value : value;\n\tchar buffer[128];\n\tchar *d = std::(buffer);\n\tdo {\n\t  --d;\n\t  *d = \"0123456789\"[tmp % 10];\n\t  tmp /= 10;\n\t} while (tmp != 0);\n\tif (value < 0) {\n\t  --d;\n\t  *d = '-';\n\t}\n\tint len = std::(buffer) - d;\n\tif (dest.rdbuf()->sputn(d, len) != len) {\n\t  dest.setstate(std::ios_base::badbit);\n\t}\n  }\n  return dest;\n}\n\n__int128 parse(string &s) {\n  __int128 ret = 0;\n  for (int i = 0; i < s.length(); i++)\n\tif ('0' <= s[i] && s[i] <= '9')\n\t  ret = 10 * ret + s[i] - '0';\n  return ret;\n}\n*/\n\n#ifndef _DEBUG\n#define printvv(...)\n#endif\nvoid YES(bool f) { cout << (f ? \"YES\" : \"NO\") << endl; }\nvoid Yes(bool f) { cout << (f ? \"Yes\" : \"No\") << endl; }\ntemplate <class T> bool chmax(T &a, const T &b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate <class T> bool chmin(T &a, const T &b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n//https://www.hamayanhamayan.com/entry/2019/01/13/145505\nconst int M = 5555;\nvector<int>g[M];\nint A[M];\nint sz[M];\npii dp[M][M];\nvoid merge(int parent, int child) {\n\tpii res[M];\n\trep(i, 0, M)res[i] = { INF,0 };\n\trep(i, 0, sz[parent])rep(j, 0, sz[child]) {\n\t\tchmin(res[i + j].first, dp[parent][i].first + dp[child][j].first);\n\t\tif (dp[parent][i].second and dp[child][j].second)res[i + j].second = 1;\n\n\t\tif (dp[child][j].first < 0 or dp[child][j].second) {\n\t\t\tchmin(res[i + j + 1].first, dp[parent][i].first);\n\t\t\tif (dp[parent][i].second)res[i + j + 1].second = 1;\n\t\t}\n\t}\n\trep(i, 0, M)dp[parent][i] = res[i];\n\tsz[parent] += sz[child];\n}\nvoid dfs(int v, int p) {\n\tsz[v] = 1;\n\tdp[v][0] = { A[v],A[v] > 0 };\n\tfor (auto u : g[v]) {\n\t\tif (u == p)continue;\n\t\tdfs(u, v);\n\t\tmerge(v, u);\n\t}\n}\nsigned main(signed argc, char *argv[]) {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(12);\n\n\tint N; cin >> N;\n\trep(i, 0, N) { cin >> A[i]; }\n\tvector<int>U(N - 1), V(N - 1); rep(i, 0, N - 1) { cin >> U[i] >> V[i]; U[i]--, V[i]--; g[U[i]].eb(V[i]); g[V[i]].eb(U[i]); }\n\tdfs(0, -1);\n\tint ans = INF;\n\trep(i, 0, sz[0]) {\n\t\tif (dp[0][i].first < 0 or dp[0][i].second)chmin(ans, i);\n\t}\n\tcout << ans << endl;\n\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/time.h>\nusing namespace std;\n\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using vll = vector<ll>; using vvll = vector<vll>; using P = pair<ll, ll>;\nll ugauss(ll a, ll b) { if (!a) return 0; if (a>0^b>0) return a/b; else return (a+(a>0?-1:1))/b+1; }\nll lgauss(ll a, ll b) { if (!a) return 0; if (a>0^b>0) return (a+(a>0?-1:1))/b-1; else return a/b; }\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; o << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const deque<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const unordered_set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U, typename V>  ostream &operator<<(ostream &o, const unordered_map<T, U, V> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvector<int> range(const int x, const int y) { vector<int> v(y - x + 1); iota(v.begin(), v.end(), x); return v; }\ntemplate <typename T> istream& operator>>(istream& i, vector<T>& o) { rep(j, o.size()) i >> o[j]; return i;}\ntemplate <typename T, typename S, typename U> ostream &operator<<(ostream &o, const priority_queue<T, S, U> &v) { auto tmp = v; while (tmp.size()) { auto x = tmp.top(); tmp.pop(); o << x << \" \";} return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const queue<T> &v) { auto tmp = v; while (tmp.size()) { auto x = tmp.front(); tmp.pop(); o << x << \" \";} return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const stack<T> &v) { auto tmp = v; while (tmp.size()) { auto x = tmp.top(); tmp.pop(); o << x << \" \";} return o; }\ntemplate <typename T> unordered_map<T, ll> counter(vector<T> vec){unordered_map<T, ll> ret; for (auto&& x : vec) ret[x]++; return ret;};\nvoid vizGraph(vvll& g, int mode = 0, string filename = \"out.png\") { ofstream ofs(\"./out.dot\"); ofs << \"digraph graph_name {\" << endl; set<P> memo; rep(i, g.size())  rep(j, g[i].size()) { if (mode && (memo.count(P(i, g[i][j])) || memo.count(P(g[i][j], i)))) continue; memo.insert(P(i, g[i][j])); ofs << \"    \" << i << \" -> \" << g[i][j] << (mode ? \" [arrowhead = none]\" : \"\")<< endl;  } ofs << \"}\" << endl; ofs.close(); system(((string)\"dot -T png out.dot >\" + filename).c_str()); }\nstruct timeval start; double sec() { struct timeval tv; gettimeofday(&tv, NULL); return (tv.tv_sec - start.tv_sec) + (tv.tv_usec - start.tv_usec) * 1e-6; }\nsize_t random_seed; struct init_{init_(){ ios::sync_with_stdio(false); cin.tie(0); gettimeofday(&start, NULL); struct timeval myTime; struct tm *time_st; gettimeofday(&myTime, NULL); time_st = localtime(&myTime.tv_sec); srand(myTime.tv_usec); random_seed = RAND_MAX / 2 + rand() / 2; }} init__;\n#define ldout fixed << setprecision(40) \n\n#define EPS (double)1e-14\n#define INF (ll)1e18\n#define mo  (ll)(1e9+7)\nll n;\nvll a;\nvll u, v;\nvvll g;\nll dp[5010][5010][2] = {};\nll tmp[5010][2];\nll tsize[5010];\nll dfs(ll v, ll p) {\n    ll ret = 1;\n    vector<P> c;\n    for (auto x : g[v]) if (x != p) {\n        ll tmp = dfs(x, v);\n        c.pb(P(x, tmp));\n        ret += tmp;\n    }\n    dp[v][0][0] = a[v] > 0;\n    dp[v][0][1] = a[v];\n\n    ll lsize = 1;\n    for (auto is : c) {\n//        cout << is << \"#child\" << endl;\n        ll ci = is.fi;\n        ll rsize = is.se;\n        rep(i, lsize+rsize) {\n            tmp[i][0] = 0;\n            tmp[i][1] = INF;\n        }\n        rep(i, lsize) rep(j, rsize) {\n            if (dp[v][i][0] == 1 && dp[ci][j][0] == 1) {\n                tmp[i+j][0] = 1;\n            }\n            if (dp[v][i][0] == 1 && (dp[ci][j][1] < 0 || dp[ci][j][0])) {\n                tmp[i+j+1][0] = 1;\n            } \n            if (dp[v][i][1] != INF &&  dp[ci][j][1] != INF) {\n                chmin(tmp[i+j+0][1], dp[v][i][1] + dp[ci][j][1]);\n                if (dp[ci][j][1] < 0 || dp[ci][j][0]) {\n                    chmin(tmp[i+j+1][1], dp[v][i][1]);\n                }\n            }\n        }\n        rep(i, lsize+rsize) rep(j, 2) {\n            dp[v][i][j] = tmp[i][j];\n//            cout << mt(v, i, j, dp[v][i][j]) << endl;\n        }\n        lsize += rsize;\n    }\n    return tsize[v] = ret;\n}\n\nint main(void) {\n    cin >> n;\n    a.resize(n);\n    u.resize(n-1);\n    v.resize(n-1);\n    g.resize(n);\n    cin >> a;\n    rep(i, n-1) {\n        cin >> u[i] >> v[i];\n        u[i]--, v[i]--;\n        g[u[i]].pb(v[i]);\n        g[v[i]].pb(u[i]);\n    }\n    dfs(0, -1);\n\n    rep(i, n) {\n//        cout << i << \"###########\" << endl;\n//        rep(j, tsize[i]) cout << dp[i][j][0] << \" \"; cout << endl;\n//        rep(j, tsize[i]) cout << dp[i][j][1] << \" \"; cout << endl;\n    }\n    rep(i, n) {\n        if (dp[0][i][0]) {\n            cout << i << endl;\n            return 0;\n        } \n        if (dp[0][i][1] < 0) {\n            cout << i << endl;\n            return 0;\n        } \n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//https://atcoder.jp/contests/aising2019/tasks/aising2019_e\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n#ifdef BTK\n#define DEBUG if(1)\n#else\n#define CIN_ONLY if(1)\nstruct cww {cww() {CIN_ONLY{ios::sync_with_stdio(false); cin.tie(0);}}}star;\n#define DEBUG if(0)\n#endif\n#define ALL(v) (v).begin(),(v).end()\n#define REC(ret, ...) std::function<ret (__VA_ARGS__)>\ntemplate <typename T>inline bool chmin(T &l, T r){bool a = l>r; if (a)l = r; return a;}\ntemplate <typename T>inline bool chmax(T &l, T r){bool a = l<r; if (a)l = r; return a;}\ntemplate <typename T>istream& operator>>(istream &is, vector<T> &v){for (auto &it : v)is >> it;return is;}\nclass range {private: struct I { int x; int operator*() { return x; }bool operator!=(I& lhs) { return x<lhs.x; }void operator++() { ++x; } }; I i, n;public:range(int n) :i({ 0 }), n({ n }) {}range(int i, int n) :i({ i }), n({ n }) {}I& begin() { return i; }I& end() { return n; }};\n\nint N;\nLL A[5123];\nvector<int> g[5123];\nvector<int> t[5123];\nLL allB[5123][5123];\nLL dp[5123][5123];\nLL tmp[5123];\nint sub[5123];\nvoid dfs(int v,int p){\n    sub[v]=1;\n    for(int u:g[v]){\n        if(u==p)continue;\n        t[v].push_back(u);\n        dfs(u,v);\n        sub[v]+=sub[u];\n    }\n}\nvoid solve(int v){\n    for(int u:t[v]){\n        solve(u);\n    }\n    int x=1;\n    if(A[v]>0){\n        allB[v][0]=1;\n    }\n    else{\n        allB[v][0]=0;\n    }\n    dp[v][0]=A[v];\n    for(int u:t[v]){\n        const int nx=x+sub[u];\n        for(int i:range(nx+1)){\n            tmp[i]=0;\n        }\n        for(int i:range(x))for(int j:range(sub[u]+1)){\n            tmp[i+j]|=(allB[v][i]&allB[u][j]);\n        }\n        for(int i:range(nx+1)){\n            allB[v][i]=tmp[i];\n            tmp[i]=1e18;\n        }\n        for(int i:range(x))for(int j:range(sub[u]+1)){\n            chmin(tmp[i+j],dp[v][i]+dp[u][j]);\n        }\n        for(int i:range(nx+1)){\n            dp[v][i]=tmp[i];\n        }\n        x=nx;\n    }\n    for(int i:range(x)){\n        if(allB[v][i]||dp[v][i]<0){\n            chmin(dp[v][i+1],0ll);\n            allB[v][i+1]=1;\n        }\n    }\n}\nint main(){\n    cin>>N;\n    for(int i:range(N)){\n        cin>>A[i+1];\n    }\n    for(int i:range(N-1)){\n        int u,v;\n        cin>>u>>v;\n        g[v].push_back(u);\n        g[u].push_back(v);\n    }\n    dfs(1,1);\n    solve(1);\n    int ret=N-1;\n    for(int i:range(N+1)){\n        if(allB[1][i])chmin(ret,i);\n        if(dp[1][i]<0)chmin(ret,i);\n    }\n    cout<<ret<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define REP rep\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\nconst ll MOD=1e9+7;\n\n#define rall(X) (X).rbegin(),(X).rend()\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n\nconst LL INF = 1LL << 61;\n\nint N;\nLL A[5145];\nvector<int> es[5145];\nvector<LL> dp[5145];\nvector<char> pos[5145];\n\nvoid Dfs(int v, int p) {\n  dp[v].resize(1, A[v]);\n  pos[v].resize(1, A[v] > 0);\n\n  for (int u : es[v]) {\n    if (u == p) continue;\n    Dfs(u, v);\n\n    vector<LL> tmp(dp[v].size() + dp[u].size(), INF);\n    vector<char> npos(dp[v].size() + dp[u].size());\n    rep(i, dp[v].size()) {\n      rep(j, dp[u].size()) {\n        if (dp[u][j] < 0 || pos[u][j]) {\n          MN(tmp[i+j+1], dp[v][i]);\n          npos[i+j+1] |= pos[v][i];\n        }\n        MN(tmp[i+j], dp[v][i] + dp[u][j]);\n        npos[i+j] |= pos[v][i] && pos[u][j];\n      }\n    }\n    dp[v].swap(tmp);\n    pos[v].swap(npos);\n  }\n}\n\nsigned main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  cin >> N;\n  rep(i, N) {\n    cin >> A[i];\n  }\n\n  rep(i, N-1) {\n    int u, v;\n    cin >> u >> v;\n    --u;\n    --v;\n    es[u].eb(v);\n    es[v].eb(u);\n  }\n\n  Dfs(0, 0);\n  rep(i, N) {\n    if (dp[0][i] < 0 || pos[0][i]) {\n      cout << i << endl;\n      return 0;\n    }\n  }\n  assert(0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst long double EPS=1e-9;\nconst long double PI=acos(-1.0);\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\nlong double ABS(long double a){return max(a,-a);}\nint c[5100];\nvector<int>g[5100];\nlong long dp[5100][5100];\nlong long dp3[5100][5100];\nint dp2[5100];\nint SZ[5100];\nvoid dfs(int a,int b){\n\tint sz=0;\n\tSZ[a]=1;\n\tfor(int i=0;i<g[a].size();i++){\n\t\tif(b==g[a][i])continue;\n\t\tdfs(g[a][i],a);\n\t\tsz++;\n\t\tSZ[a]+=SZ[g[a][i]];\n\t}\n\tif(sz==0){\n\t\tif(c[a]>0){\n\t\t\tdp2[a]=0;\n\t\t\tdp[a][0]=c[a];\n\t\t}else{\n\t\t\tdp[a][0]=c[a];\n\t\t}\n\t\treturn;\n\t}\n\tfor(int i=0;i<=sz;i++)\n\t\tfor(int j=0;j<5100;j++)\n\t\t\tdp3[i][j]=inf;\n\tdp3[0][0]=c[a];\n\tint ind=0;\n\tint cur=0;\n\tfor(int i=0;i<g[a].size();i++){\n\t\tif(b==g[a][i])continue;\n\t\tfor(int j=0;j<=cur;j++){\n\t\t\tfor(int k=0;k<SZ[g[a][i]];k++){\n\t\t\t\tdp3[ind+1][j+k]=min(dp3[ind+1][j+k],dp3[ind][j]+dp[g[a][i]][k]);\n\t\t\t\tif(dp[g[a][i]][k]<0)dp3[ind+1][j+k+1]=min(dp3[ind+1][j+k+1],dp3[ind][j]);\n\t\t\t}\n\t\t\tif(c[g[a][i]]>0)dp3[ind+1][j+dp2[g[a][i]]+1]=min(dp3[ind+1][j+dp2[g[a][i]]+1],dp3[ind][j]);\n\t\t\t\n\t\t}\n\t\tcur+=SZ[g[a][i]];\n\t\tind++;\n\t}\n\tfor(int i=0;i<=cur;i++){\n\t\tdp[a][i]=dp3[ind][i];\n\t}\n\tif(c[a]>0){\n\t\tdp2[a]=0;\n\t\tfor(int i=0;i<g[a].size();i++){\n\t\t\tif(b==g[a][i])continue;\n\t\t\tint tmp=mod;\n\t\t\tfor(int j=0;j<5100;j++){\n\t\t\t\tif(dp[g[a][i]][j]<0){\n\t\t\t\t\ttmp=j+1;break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(c[g[a][i]]>0){\n\t\t\t\ttmp=min(tmp,dp2[g[a][i]]);\n\t\t\t}\n\t\t\tdp2[a]+=tmp;\n\t\t}\n\t}\n}\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tfor(int i=0;i<a;i++)scanf(\"%d\",c+i);\n\tfor(int i=0;i<a-1;i++){\n\t\tint p,q;scanf(\"%d%d\",&p,&q);p--;q--;\n\t\tg[p].push_back(q);\n\t\tg[q].push_back(p);\n\t}\n\tfor(int i=0;i<a;i++)for(int j=0;j<=a;j++)for(int k=0;k<2;k++)\n\t\tdp[i][j]=inf;\n\tfor(int i=0;i<a;i++)dp2[i]=mod;\n\tdfs(0,-1);\n\tint ret=dp2[0];\n\tfor(int i=0;i<5100;i++)if(dp[0][i]<0){\n\t\tret=min(ret,i);\n\t}\n\tprintf(\"%d\\n\",ret);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nint n;\nint a[6005];\nint sz[6005];\nint dp[6005][6005][2];\nvector<int> adj[100005];\n\nvoid ddp(int node, int fa)\n{\n\t//cout<<\"AT \"<<node<<endl;\n\tsz[node]=1;\n\tfor(int i=0; i<=n; i++)\n\t{\n\t\tdp[node][i][0]=10000000000000;\n\t\tdp[node][i][1]=10000000000000;\n\t}\n\tif(a[node]>0) dp[node][0][0]=a[node];\n\telse dp[node][0][1]=a[node];\n\tint dp1[5005][2];\n\t\n\tfor(auto i:adj[node])\n\t{\n\t\tif(i==fa) continue;\n\t\tfor(int i=0; i<=n; i++)\n\t\t{\n\t\t\tdp1[i][0]=10000000000000;\n\t\t\tdp1[i][1]=10000000000000;\n\t\t}\n\t\tddp(i, node);\n\t\tfor(int sn=0; sn<sz[node]; sn++)\n\t\t{\n\t\t\tfor(int si=0; si<sz[i]; si++)\n\t\t\t{\n\t\t\t\tdp1[sn+si][0]=min(dp1[sn+si][0], dp[node][sn][0]+dp[i][si][0]);\n\t\t\t\tdp1[sn+si][1]=min(dp1[sn+si][1], min(dp[node][sn][1]+dp[i][si][1], min(dp[node][sn][0]+dp[i][si][1], dp[node][sn][1]+dp[i][si][0])));\n\t\t\t\tif(dp[i][si][1]<0)\n\t\t\t\t{\n\t\t\t\t\tdp1[sn+si+1][0]=min(dp1[sn+si+1][0], dp[node][sn][0]);\n\t\t\t\t\tdp1[sn+si+1][1]=min(dp1[sn+si+1][1], dp[node][sn][1]);\n\t\t\t\t}\n\t\t\t\tif(dp[i][si][0]<10000000000000)\n\t\t\t\t{\n\t\t\t\t\tdp1[sn+si+1][0]=min(dp1[sn+si+1][0], dp[node][sn][0]);\n\t\t\t\t\tdp1[sn+si+1][1]=min(dp1[sn+si+1][1], dp[node][sn][1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j=0; j<=n; j++)\n\t\t{\n\t\t\tdp[node][j][0]=dp1[j][0];\n\t\t\tdp[node][j][1]=dp1[j][1];\n\t\t}\n\t\tsz[node]+=sz[i];\n\t}\n}\n\nsigned main()\n{\n\tcin>>n;\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tcin>>a[i];\n\t}\n\tfor(int i=1; i<n; i++)\n\t{\n\t\tint u, v;\n\t\tcin>>u>>v;\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\tddp(1, 1);\n\tfor(int i=0; i<=n; i++)\n\t{\n\t\tif(dp[1][i][0]<10000000000000||dp[1][i][1]<0)\n\t\t{\n\t\t\t//cout<<dp[1][i][0]<<\" \"<<dp[1][i][1]<<endl;\n\t\t\tcout<<i;\n\t\t\treturn 0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#pragma region Macros\n#pragma GCC optimize(\"O3\")\n\n#include <bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;++i)\n#define rep3(i,a,b) for(ll i=a;i>=b;--i)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pb push_back\n#define eb emplace_back\n#define vi vector<int>\n#define vec vector<int>\n#define vll vector<ll>\n#define vpi vector<pii>\n#define vpll vector<pll>\n#define overload2(_1,_2,name,...) name\n#define vv(a,b) vector<vector<int>>(a,vector<int>(b))\n#define vv2(a,b,c) vector<vector<int>>(a,vector<int>(b,c))\n#define vvl(a,b) vector<vector<ll>>(a,vector<ll>(b))\n#define vvl2(a,b,c) vector<vector<ll>>(a,vector<ll>(b,c))\n#define vvv(a,b,c) vector<vv(b,c)>(a)\n#define vvv2(a,b,c,d) vector<vv(b,c,d)>(a)\n#define vvvl(a,b,c) vector<vvl(b,c)>(a)\n#define vvvl2(a,b,c,d) vector<vvl(b,c,d)>(a)\n#define fi first\n#define se second\n#define all(c) begin(c),end(c)\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance((c).begin(),lower_bound(all(c),(x)))\n#define ub(c,x) distance((c).begin(),upper_bound(all(c),(x)))\nusing namespace std;\ntemplate<class T> using pq = priority_queue<T>;\ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n#define INT(...) int __VA_ARGS__;IN(__VA_ARGS__)\n#define LL(...) ll __VA_ARGS__;IN(__VA_ARGS__)\n#define ULL(...) ull __VA_ARGS__;IN(__VA_ARGS__)\n#define STR(...) string __VA_ARGS__;IN(__VA_ARGS__)\n#define CHR(...) char __VA_ARGS__;IN(__VA_ARGS__)\n#define DBL(...) double __VA_ARGS__;IN(__VA_ARGS__)\n#define LD(...) ld __VA_ARGS__;IN(__VA_ARGS__)\n#define VEC(type,name,size) vector<type> name(size);IN(name)\n#define VV(type,name,h,w) vector<vector<type>>name(h,vector<type>(w));IN(name)\nint scan(){ return getchar(); }\nvoid scan(int& a){ cin>>a; }\nvoid scan(long long& a){ cin>>a; }\nvoid scan(char &a){cin>>a;}\nvoid scan(double &a){ cin>>a; }\nvoid scan(long double& a){ cin>>a; }\nvoid scan(char a[]){ scanf(\"%s\", a); }\nvoid scan(string& a){ cin >> a; }\ntemplate<class T> void scan(vector<T>&);\ntemplate<class T, size_t size> void scan(array<T, size>&);\ntemplate<class T, class L> void scan(pair<T, L>&);\ntemplate<class T, size_t size> void scan(T(&)[size]);\ntemplate<class T> void scan(vector<T>& a){ for(auto& i : a) scan(i); }\ntemplate<class T> void scan(deque<T>& a){ for(auto& i : a) scan(i); }\ntemplate<class T, size_t size> void scan(array<T, size>& a){ for(auto& i : a) scan(i); }\ntemplate<class T, class L> void scan(pair<T, L>& p){ scan(p.first); scan(p.second); }\ntemplate<class T, size_t size> void scan(T (&a)[size]){ for(auto& i : a) scan(i); }\ntemplate<class T> void scan(T& a){ cin >> a; }\nvoid IN(){}\ntemplate <class Head, class... Tail> void IN(Head& head, Tail&... tail){ scan(head); IN(tail...); }\nstring stin() {string s;cin>>s;return s;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\nvi iota(int n){vi a(n);iota(all(a),0);return a;}\ntemplate<class T> void UNIQUE(vector<T> &x){sort(all(x));x.erase(unique(all(x)),x.end());}\nint in() {int x;cin>>x;return x;}\nll lin() {unsigned long long x;cin>>x;return x;}\nvoid print(){putchar(' ');}\nvoid print(bool a){cout<<a;}\nvoid print(int a){cout<<a;}\nvoid print(long long a){cout<<a;}\nvoid print(char a){cout<<a;}\nvoid print(string &a){cout<<a;}\nvoid print(double a){cout<<a;}\ntemplate<class T> void print(const vector<T>&);\ntemplate<class T, size_t size> void print(const array<T, size>&);\ntemplate<class T, class L> void print(const pair<T, L>& p);\ntemplate<class T, size_t size> void print(const T (&)[size]);\ntemplate<class T> void print(const vector<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ cout<<\" \"; print(*i); } cout<<endl;}\ntemplate<class T> void print(const deque<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ cout<<\" \"; print(*i); } }\ntemplate<class T, size_t size> void print(const array<T, size>& a){ print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ cout<<\" \"; print(*i); } }\ntemplate<class T, class L> void print(const pair<T, L>& p){ cout<<'(';print(p.first); cout<<\",\"; print(p.second);cout<<')'; }\ntemplate<class T, size_t size> void print(const T (&a)[size]){ print(a[0]); for(auto i = a; ++i != end(a); ){ cout<<\" \"; print(*i); } }\ntemplate<class T> void print(const T& a){ cout << a; }\nint out(){ putchar('\\n'); return 0; }\ntemplate<class T> int out(const T& t){ print(t); putchar('\\n'); return 0; }\ntemplate<class Head, class... Tail> int out(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); return 0; }\nll gcd(ll a, ll b){ while(b){ ll c = b; b = a % b; a = c; } return a; }\nll lcm(ll a, ll b){ if(!a || !b) return 0; return a * b / gcd(a, b); }\nvector<pll> factor(ll x){ vector<pll> ans; for(ll i = 2; i * i <= x; i++) if(x % i == 0){ ans.push_back({i, 1}); while((x /= i) % i == 0) ans.back().second++; } if(x != 1) ans.push_back({x, 1}); return ans; }\nvector<int> divisor(int x){ vector<int> ans; for(int i=1;i*i<=x;i++)if(x%i==0){ans.pb(i);if(i*i!=x)ans.pb(x/i);} return ans;}\nint popcount(ll x){return __builtin_popcountll(x);}\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rnd(int n){return uniform_int_distribution<int>(0, n)(rng);}\n#define endl '\\n'\n\n#ifdef _LOCAL\n    #undef endl\n    #define debug(x) cout<<#x<<\": \";print(x);cout<<endl;\n    void err(){}\n    template<class T> void err(const T& t){ print(t);  cout<<\" \";}\n    template<class Head, class... Tail> void err(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); }\n#else\n    #define debug(x)\n    template<class... T> void err(const T&...){}\n#endif\n#pragma endregion\n\n\ntemplate< typename T >\nstruct edge{\n    int from, to;\n    T cost;\n    edge(int to,T cost) : from(-1), to(to), cost(cost){}\n    edge(int from,int to,T cost) : from(from), to(to), cost(cost){}\n    edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n    operator int() const{ return to;}\n};\n\ntemplate< typename T >\nusing Edges = vector< edge< T > >;\ntemplate< typename T >\nusing WeightedTree = vector< Edges<T>>;\nusing tree = vector< vector<int> >;\n\ntree make(int n,int offset = 1){\n    tree res(n);\n    for(int i = 0;i < n-1; i++){\n        int a,b; cin >> a >> b;\n        a -= offset,b -= offset;\n        res[a].emplace_back(b);\n        res[b].emplace_back(a);\n    }\n    return res;\n}\ntemplate< typename T >\nWeightedTree<T> make2(int n, int offset = 1){\n    WeightedTree<T> res(n);\n    for(int i = 0;i < n-1 ; i++){\n        int a,b ; cin >> a >> b;\n        a -= offset, b -= offset;\n        T c; cin >> c;\n        res[a].emplace_back(b,c);\n        res[b].emplace_back(a,c);\n    }\n    return res;\n}\n\n\nsigned main(){\n    ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);cout<<fixed<<setprecision(15);\n    INT(n);\n    VEC(ll,a,n);\n    auto g = make(n);\n    auto dp1 = vector<vll>(n);\n    // plus only\n    auto dp2 = vector<ll>(n,0);\n    // to cut all\n    auto dp3 = vector<ll>(n);\n\n    auto merge = [&](vll &x, vll &y){\n        int a = x.size() , b = y.size();\n        vll res(a+b-1,1e15);\n        rep(i,a)rep(j,b)chmin(res[i+j],x[i] + y[j]);\n        swap(x,res);\n    };\n    constexpr ll INF = 1e16;\n    auto dfs = [&](auto &&f,int x,int p) -> void{\n        dp1[x].pb(a[x]);\n        for(auto e:g[x])if(e!=p)f(f,e,x);\n        for(auto e:g[x]){\n            if(e==p)continue;\n            vll nxt(dp1[x].size() + max(dp1[e].size()-1,(size_t)dp3[e]),INF);\n            rep(i,dp1[x].size())rep(j,dp1[e].size()) chmin(nxt[i+j],dp1[x][i] + dp1[e][j]);\n            rep(i,dp1[x].size()) chmin(nxt[i+dp3[e]],dp1[x][i]);\n            swap(nxt,dp1[x]);\n        }\n\n        if( a[x] > 0 )\n        for(auto e:g[x]){\n            if(e==p)continue;\n            dp2[x] += dp2[e];\n        }\n        else dp2[x] = INF;\n        dp3[x] = INF;\n        rep(i,dp1[x].size()) if(dp1[x][i] < 0) chmin(dp3[x],i + 1);\n        chmin(dp3[x],dp2[x] + 1);\n        chmin(dp2[x],dp3[x]);\n    };\n    dfs(dfs,0,-1);\n    cout << dp3[0] - 1 << endl;  \n            \n            \n\n    \n    \n}           \n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\n\nint n;\nvector<ll> a,S;\nvector<vector<int>> G;\nll dp[5000][5000][2],sdp[5000][2],new_sdp[5000][2];\n\nvoid dfs(int s,int par){\n    rep(i,G[s].size()){\n        int t=G[s][i];\n        if (t==par) continue;\n        dfs(t,s);\n        S[s]+=S[t]+1;\n    }\n\n    rep(i,S[s]+1){\n        sdp[i][0]=INF;\n        sdp[i][1]=INF;\n        new_sdp[i][0]=INF;\n        new_sdp[i][1]=INF;\n\n    }\n\n    if (a[s]>0) sdp[0][1]=a[s];\n    if (a[s]<0) sdp[0][0]=a[s];\n    int M=0;\n    rep(i,G[s].size()){\n        int t=G[s][i];\n        if (t==par) continue;\n        rep(k,M+S[t]+2) {\n            new_sdp[k][0]=INF;\n            new_sdp[k][1]=INF;\n        }\n        rep(k,M+1){\n            rep(c,S[t]+1){\n                new_sdp[k+c][0]=min(new_sdp[k+c][0],sdp[k][0]+dp[t][c][0]);\n                new_sdp[k+c][0]=min(new_sdp[k+c][0],sdp[k][1]+dp[t][c][0]);\n                new_sdp[k+c][0]=min(new_sdp[k+c][0],sdp[k][0]+dp[t][c][1]);\n                new_sdp[k+c][1]=min(new_sdp[k+c][1],sdp[k][1]+dp[t][c][1]);\n                if (dp[t][c][0]<0) {\n                    new_sdp[k+c+1][0]=min(new_sdp[k+c+1][0],sdp[k][0]);\n                    new_sdp[k+c+1][1]=min(new_sdp[k+c+1][1],sdp[k][1]);\n                }\n                if (dp[t][c][1]<INF) {\n                    new_sdp[k+c+1][0]=min(new_sdp[k+c+1][0],sdp[k][0]);\n                    new_sdp[k+c+1][1]=min(new_sdp[k+c+1][1],sdp[k][1]);\n                }\n            }\n\n        }\n        M+=S[t]+1;\n        rep(k,M+1) {\n            sdp[k][0]=new_sdp[k][0];\n            sdp[k][1]=new_sdp[k][1];\n            //cout <<  k << \" \" << sdp[k][0] << \" \" << sdp[k][1] << endl;;\n        }\n\n    }\n\n    rep(i,M+2){\n        dp[s][i][0]=sdp[i][0];\n        dp[s][i][1]=sdp[i][1];\n    }\n\n    // rep(i,S[s]+1){\n    //     cout << s << \",\" << i << \",\" << 0 << \" \" << dp[s][i][0] << endl;\n    //     cout << s << \",\" << i << \",\" << 1 << \" \" << dp[s][i][1] << endl;\n    // }\n\n}\n\nvoid solve(){\n    cin >> n;\n    a.resize(n,0);\n    G.resize(n,{});\n    S.resize(n,0);\n    rep(i,n) cin >> a[i];\n    rep(i,n-1){\n        int p,q;\n        cin >> p >> q;\n        G[p-1].push_back(q-1);\n        G[q-1].push_back(p-1);\n    }\n\n    dfs(0,-1);\n    ll ans=INF;\n    rep(i,S[0]+1){\n        if (dp[0][i][0]<0) ans=i;\n        if (dp[0][i][1]<INF) ans=i;\n        if (ans<INF) break;\n    }\n\n    cout << ans << endl;\n\n\n    \n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "/**\n    *Makacha\n**/\n#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <typename T> inline void read (T &x) {bool b = 0; char c; while (!isdigit (c = getchar()) && c != '-');\nif (c == '-') c = getchar(), b = 1; x = c - 48; while (isdigit(c = getchar())) x = (x<<3) + (x<<1) + c - 48; if (b)x=-x;}\ntemplate <typename T> inline void wrip(T x) {if (x > 9) wrip(x / 10); putchar(x%10 + 48); }\n\ntemplate <typename T> inline void write(T x) {if (x < 0) putchar('-'), x = -x; wrip(x); putchar(' ');}\ntemplate <typename T> inline void writeln(T x) {if (x < 0) putchar('-'), x = -x; wrip(x); putchar('\\n');}\ninline char readch() {char c; do c = getchar(); while (c == '\\n' || c == ' '); return c;}\ninline void reads(string &s) {char c; while((c=getchar())==' '||c =='\\n'); s=c; while((c=getchar())!=' '&&c!='\\n') s+=c;}\ninline void getlines(string &s) {char c; while((c=getchar())=='\\n'); s=c; while((c=getchar())!='\\n') s+=c;}\ntypedef const int csint;\n\n#define fi first\n#define se second\n#define mp make_pair\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> ii;\ntypedef vector <int> vi;\n\nconst ld pi = acos(-1);\nconst ll inf = 1e16;\nconst int mod = 1e9 + 7,\nN = 5011;\n\nint n, a[N], num[N];\nll f[N][N][2];\nvi ke[N];\nvoid Dfs(int u, int p) {\n    num[u] = 1;\n    f[u][0][0] = f[u][0][1] = a[u];\n    if (a[u] < 0)\n        f[u][0][0] = inf;\n    for (auto v: ke[u]) {\n        if (v == p)\n            continue;\n        Dfs(v, u);\n        for (int i = num[u] - 1; i >= 0; i--) {\n            for (int j = num[v] - 1, k = i + num[v] - 1, t = i + num[v]; j >= 0; j--, k--, t--) {\n                if (j)\n                    f[u][k][1] = min(f[u][k][1], f[u][i][1] + f[v][j][1]),\n                    f[u][k][0] = min(f[u][k][0], f[u][i][0] + f[v][j][0]);\n                if (f[v][j][1] < 0)\n                    f[u][t][1] = min(f[u][t][1], f[u][i][1]),\n                    f[u][t][0] = min(f[u][t][0], f[u][i][0]);\n                if (f[v][j][0] < inf)\n                    f[u][t][1] = min(f[u][t][1], f[u][i][1]),\n                    f[u][t][0] = min(f[u][t][0], f[u][i][0]);\n            }\n            f[u][i][1] += f[v][0][1];\n            f[u][i][0] += f[v][0][0];\n        }\n        num[u] += num[v];\n        for (int i = 0; i < num[u]; i++) {\n            f[u][i][0] = min(f[u][i][0], inf);\n            f[u][i][1] = min(f[u][i][1], f[u][i][0]);\n        }\n    }\n}\nlong long Rand(long long l, long long h)\n{\n    return l + ((long long)rand() * (RAND_MAX + 1) * (RAND_MAX + 1) * (RAND_MAX + 1) +\n                (long long)rand() * (RAND_MAX + 1) * (RAND_MAX + 1) +\n                (long long)rand() * (RAND_MAX + 1) +\n                rand()) % (h - l + 1);\n}\nint main() {\n    #ifdef makacha\n        srand(time(NULL));\n        freopen(\"m.inp\", \"w\", stdout);\n        //Test();\n        n = 5000;\n        cout << n << '\\n';\n        for (int i = 1; i <= n; i++)\n            cout << Rand(-1e8, 1e9) << ' ';\n        cout << '\\n';\n        for (int i = 2; i <= n; i++)\n            cout << i / 2 << ' ' << i << '\\n';\n        freopen(\"m.inp\", \"r\", stdin);\n        freopen(\"m.out\", \"w\", stdout);\n    #endif // makacha\n    read(n);\n    for (int i = 1; i <= n; i++)\n        read(a[i]);\n    for (int i = 1, u, v; i < n; i++) {\n        read(u);\n        read(v);\n        ke[u].push_back(v);\n        ke[v].push_back(u);\n    }\n    for (int i = 1; i <= n; i++)\n        for (int j = 0; j <= n; j++)\n            f[i][j][0] = f[i][j][1] = inf;\n    Dfs(1, 1);\n    for (int i = 0; i < n; i++)\n        if (f[1][i][1] < 0 || f[1][i][0] < inf)\n            return cout << i, 0;\n    cout << 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████\n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define MOD 1000000007\n//#define MOD 998244353\nconst double EPS = 1e-9;\n#define INF (1LL<<60)\n#define D double\n#define fs first\n#define sc second\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i = (b-1);i>=a;i--)\n#define REP(i,n)  FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl;\n#define SP << \" \" << \ntypedef pair<int,int> P;\ntypedef vector<vector<P> > Graph;\ntypedef vector<int> vec;\ntypedef vector<vector<int>> mat;\n\nconst int N = 5050;\nvec edge[N], a(N), used(N,0), sz(N,1);\nint dp[2][N][N];\nint n;\n\nvoid dfs(int no){\n  used[no]++;\n  dp[a[no]>0][no][0] = a[no];\n\n  for(int to:edge[no]){\n    if(used[to]) continue;\n    dfs(to);\n\n    mat tmp(2,vec(N,INF));\n    REP(i,sz[no]){\n      REP(j,sz[to]){\n        //切るとき、制約を満たしているとき\n        if(dp[0][to][j] < 0 || dp[1][to][j] != INF){\n          tmp[0][i+j+1] = min(tmp[0][i+j+1],dp[0][no][i]);\n          tmp[1][i+j+1] = min(tmp[1][i+j+1],dp[1][no][i]);\n        }\n        //切らないとき\n        tmp[0][i+j] = min(tmp[0][i+j],dp[0][no][i]+dp[0][to][j]);\n        tmp[0][i+j] = min(tmp[0][i+j],dp[0][no][i]+dp[1][to][j]);\n        tmp[0][i+j] = min(tmp[0][i+j],dp[1][no][i]+dp[0][to][j]);\n        tmp[1][i+j] = min(tmp[1][i+j],dp[1][no][i]+dp[1][to][j]);\n      }\n    }\n    REP(i,N){\n      dp[0][no][i] = tmp[0][i];\n      dp[1][no][i] = tmp[1][i];\n    }\n    sz[no] += sz[to];\n  }\n}\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  cin >> n;\n\n  REP(i,n) cin >> a[i];\n  REP(_,n-1){\n    int u,v;\n    cin >> u >> v;\n    u--; v--;\n    edge[u].push_back(v);\n    edge[v].push_back(u);\n  }\n\n  REP(i,N) REP(j,N) dp[0][i][j] = dp[1][i][j] = INF;\n  \n  dfs(0);\n\n  REP(i,n){\n    //cout << dp[0][0][i] SP dp[1][0][i] << endl;\n    if(dp[0][0][i] < 0 || dp[1][0][i] != INF){\n      cout << i << endl;\n      return 0;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; ++i )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef pair<ll,int> pli;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\nvector<int> v[5050];\nvector<ll> dp[5050][2];\nint sz[5050];\nll a[5050];\nvoid dfs(int x,int p){\n    sz[x]=0;\n    dp[x][0].resize(1);\n    dp[x][1].resize(1);\n    for(auto to:v[x]){\n        if(to==p)continue;\n        dfs(to,x);\n        vector<ll> ret0(sz[x]+sz[to]+1,longinf),ret1(sz[x]+sz[to]+1,longinf);\n        rep(i,sz[x]+1)rep(j,sz[to]+1){\n            ret0[i+j]=min(ret0[i+j],min(dp[x][0][i],dp[x][1][i])+min(dp[to][0][j],dp[to][1][j]));\n            ret1[i+j]=min(ret1[i+j],dp[x][1][i]+dp[to][1][j]);\n        }\n        sz[x]+=sz[to];\n        dp[x][0]=ret0;\n        dp[x][1]=ret1;\n    }\n    ++sz[x];\n    dp[x][0].push_back(0);\n    dp[x][1].push_back(0);\n    for(int i=sz[x]-1;i>=0;--i){\n        dp[x][0][i+1]+=a[x];\n        if(dp[x][0][i]+a[x]<0)dp[x][0][i+1]=min(dp[x][0][i+1],0LL);\n        if(dp[x][1][i]<longinf&&a[x]>0)dp[x][0][i+1]=min(dp[x][0][i+1],0LL);\n        if(a[x]>0){\n            dp[x][1][i+1]+=a[x];\n            if(dp[x][1][i]<longinf)dp[x][1][i+1]=0;\n        }\n        else {\n            if(dp[x][1][i]+a[x]<0)dp[x][1][i+1]=0;\n            else dp[x][1][i+1]=longinf;\n        }\n    }\n    dp[x][0][0]+=a[x];\n    dp[x][1][0]=(a[x]>0?dp[x][1][0]+a[x]:longinf);\n}\n\n\n\nint main(){\n    int n;\n    cin>>n;\n    rep(i,n)cin>>a[i];\n    rep(i,n-1){\n        int x,y;\n        cin>>x>>y;\n        --x;--y;\n        v[x].push_back(y);\n        v[y].push_back(x);\n    }\n    dfs(0,-1);\n    rep(i,n+1){\n        if(dp[0][0][i]<0||dp[0][1][i]<longinf){\n            cout<<i<<endl;\n            return 0;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define fi first\n#define se second\n#define pb push_back\n#define rep(i, s, n) for (int i = s; i < n; i++)\n#define rrep(i, s, n) for (int i = (n)-1; i >= (s); i--)\n#define all(a) a.begin(),a.end()\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\nconst long long MOD = 1000000007, INF = 1e17;\ntemplate<class T>inline bool chmax(T& a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<class T>inline bool chmin(T& a,T b){if(a>b){a=b;return true;}return false;}\nstring get_str(string s) {\n\ts+=',';\n\tstring ret=\"\";\n\tfor(int i=0; i<s.size(); i++) {\n\t\tif(s[i]==',') ret+=\"=%ld, \";\n\t\telse ret+=s[i];\n\t}\n\treturn ret;\n}\n#define dump(...) printf(get_str(#__VA_ARGS__).c_str(),__VA_ARGS__);cout<<endl\n \n#define endl '\\n'\n#define IOS()                     \\\n\tios_base::sync_with_stdio(0); \\\n\tcin.tie(0)\n template<typename T>vector<T>\nmake_v(size_t a){return vector<T>(a);}\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n\treturn vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n \ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value==0>::type\nfill_v(T &t,const V &v){t=v;}\n \ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t,const V &v){\n\tfor(auto &e:t) fill_v(e,v);\n}\n//******************************************************************************\n \nint N,MINF=1e17;\nvint a;\nvint g[5050];\n \n \nvector<vector<int>>dfs(int now,int par){\n\tauto dp = make_v<int>(2,2);\n\tfill_v(dp,INF);\n\tdp[0][0] = a[now];\n\tif(a[now]>0)dp[0][1] = a[now];\n\tfor(auto e:g[now]){\n\t\tif(e==par)continue;\n\t\tauto tmp = dfs(e,now);\n\t\tint n = dp.size();\n\t\tint m = tmp.size();\n\t\tauto new_dp = make_v<int>(n+m-1,2);\n\t\tfill_v(new_dp,INF);\n\t\trep(i,0,n-1){\n\t\t\trep(j,0,m-1){\n\t\t\t\trep(k,0,2){\n\t\t\t\t\trep(l,0,2){\n\t\t\t\t\t\tchmin(new_dp[i+j][k&l],dp[i][k]+tmp[j][l]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(i+j+1>=n+m-1)continue;\n\t\t\t\tif(tmp[j][0]<0){\n\t\t\t\t\tchmin(new_dp[i+j+1][0],dp[i][0]);\n\t\t\t\t\tchmin(new_dp[i+j+1][1],dp[i][1]);\n\t\t\t\t}\n\t\t\t\tif(tmp[j][1]<INF/2){\n\t\t\t\t\tchmin(new_dp[i+j+1][0],dp[i][0]);\n\t\t\t\t\tchmin(new_dp[i+j+1][1],dp[i][1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdp = new_dp;\n\t}\n\treturn dp;\n}\n \nsigned main()\n{\n\t//IOS();\n\tcin>>N;\n\ta.resize(N);\n\tfor(int i = 0;i < N;i++){\n\t\tcin>>a[i];\n\t}\n\trep(i,0,N-1){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\ta--;b--;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\tauto dp = dfs(0,-1);\n\tint ans = INF;\n\trep(j,0,N+1){\n\t\tif(dp[j][1]<INF/2)chmin(ans,j);\n\t\tif(dp[j][0]<0)chmin(ans,j);\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing uint = unsigned int;\nusing lint = long long int;\nusing ulint = unsigned long long int;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\ntemplate<class T, class U> void assign(V<T>& v, int n, const U& a) { v.assign(n, a); }\ntemplate<class T, class... Args> void assign(V<T>& v, int n, const Args&... args) { v.resize(n); for (auto&& e : v) assign(e, args...); }\n\n\nint main() {\n  cin.tie(nullptr); ios_base::sync_with_stdio(false);\n  int n; cin >> n;\n  V<> a(n); for (int i = 0; i < n; ++i) cin >> a[i];\n  VV<> g(n);\n  for (int i = 0; i < n - 1; ++i) {\n    int u, v; cin >> u >> v, --u, --v;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  V<> sz(n, 1);\n  constexpr lint inf = 1e18;\n  V< VV<lint> > dp; assign(dp, n, 2, n, inf);\n  auto dfs = [&](const auto& dfs, int v, int p) -> void {\n    dp[v][a[v] < 0][0] = a[v];\n    for (int w : g[v]) if (w != p) {\n      dfs(dfs, w, v);\n      VV<lint> dpv; assign(dpv, 2, n, inf);\n      for (int f = 0; f < 2; ++f) for (int x = 0; x < sz[v]; ++x) {\n        for (int g = 0; g < 2; ++g) for (int y = 0; y < sz[w]; ++y) {\n          dpv[f or g][x + y] = min(dpv[f or g][x + y], dp[v][f][x] + dp[w][g][y]);\n          if (dp[w][g][y] < (g ? 0 : inf)) dpv[f][x + y + 1] = min(dpv[f][x + y + 1], dp[v][f][x]);\n        }\n      }\n      swap(dp[v], dpv);\n      sz[v] += sz[w];\n    }\n  };\n  dfs(dfs, 0, -1);\n  for (int x = 0; x < n; ++x) {\n    if (dp[0][0][x] != inf or dp[0][1][x] < 0) {\n      return cout << x << '\\n', 0;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\ntemplate <class Cost = int>\nstruct Edge {\n    int src, dst;\n    Cost cost;\n    Edge(int src = -1, int dst = -1, Cost cost = 1)\n        : src(src), dst(dst), cost(cost){};\n\n    bool operator<(const Edge<Cost>& e) const { return this->cost < e.cost; }\n    bool operator>(const Edge<Cost>& e) const { return this->cost > e.cost; }\n};\n\ntemplate <class Cost = int>\nstruct Graph {\n    std::vector<std::vector<Edge<Cost>>> graph;\n\n    Graph(int n = 0) : graph(n) {}\n\n    void span(bool direct, int src, int dst, Cost cost = 1) {\n        graph[src].emplace_back(src, dst, cost);\n        if (!direct) graph[dst].emplace_back(dst, src, cost);\n    }\n\n    std::vector<Edge<Cost>>& operator[](int v) { return graph[v]; }\n    std::vector<Edge<Cost>> operator[](int v) const { return graph[v]; }\n\n    int size() const { return graph.size(); }\n};\n\nusing lint = long long;\nconstexpr lint INF = 1LL << 60;\n\nstd::vector<lint> xs;\nGraph<> graph;\nstd::vector<std::vector<bool>> posdp;\nstd::vector<std::vector<lint>> negdp;\n\nvoid dfs(int v, int p) {\n    auto& pdp = posdp[v];\n    auto& ndp = negdp[v];\n\n    pdp.resize(1, xs[v] > 0);\n    ndp.resize(1, xs[v]);\n    int sz = 0;\n\n    for (auto e : graph[v]) {\n        int u = e.dst;\n        if (u == p) continue;\n\n        dfs(u, v);\n\n        const auto& cpdp = posdp[u];\n        const auto& cndp = negdp[u];\n        int csz = (int)cpdp.size() - 1;\n\n        auto opdp = pdp;\n        auto ondp = ndp;\n\n        pdp.assign(sz + csz + 2, false);\n        ndp.assign(sz + csz + 2, INF);\n\n        for (int i = 0; i <= sz; ++i) {\n            for (int j = 0; j <= csz; ++j) {\n                // don't cut\n                if (opdp[i] && cpdp[j]) pdp[i + j] = true;\n                ndp[i + j] = std::min(ndp[i + j], ondp[i] + cndp[j]);\n\n                // cut\n                if (!cpdp[j] && cndp[j] >= 0) continue;\n                if (opdp[i]) pdp[i + j + 1] = true;\n                ndp[i + j + 1] = std::min(ndp[i + j + 1], ondp[i]);\n            }\n        }\n\n        sz += csz + 1;\n    }\n}\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n\n    xs.resize(n);\n    for (auto& x : xs) std::cin >> x;\n\n    graph = Graph<>(n);\n    for (int i = 0; i < n - 1; ++i) {\n        int u, v;\n        std::cin >> u >> v;\n        graph.span(false, --u, --v);\n    }\n\n    posdp.resize(n);\n    negdp.resize(n);\n\n    dfs(0, -1);\n\n    int ans = n;\n    for (int i = 0; i < (int)posdp[0].size(); ++i) {\n        if (posdp[0][i] || negdp[0][i] < 0) ans = std::min(ans, i);\n    }\n\n    std::cout << ans << std::endl;\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 1000000007\n#define sp ' '\n#define intmax 2147483647\n#define llmax 9223372036854775807\n#define nyan \"(=^･ω･^=)\"\n#define mkp make_pair\n#define lP pair<ll, ll>\n#define iP pair<int,int>\ntypedef long long ll;\nusing namespace std;\n\nint N, A[5000], U, V, cnt, res;\nll g[5000], s;\nbool vis[5000], vis2[5000];\nvector<int>v[5000];\n\nvoid dfs(int x) {\n\tvis[x] = true;\n\tg[x] = A[x];\n\tfor (int i = 0; i != v[x].size(); ++i) {\n\t\tif (!vis[v[x][i]]) {\n\t\t\tdfs(v[x][i]);\n\t\t\tg[x] += g[v[x][i]];\n\t\t}\n\t}\n}\n\nvoid dfs2(int x) {\n\tif (g[x] < 0)\n\t\t++cnt;\n\telse{\n\tvis[x] = true;\n\t\tfor (int i = 0; i != v[x].size(); ++i) {\n\t\t\tif (!vis[v[x][i]])\n\t\t\t\tdfs2(v[x][i]);\n\t\t}\n\t}\n}\n\nbool dfs3(int x) {\n\tvis2[x] = true;\n\tif (A[x] < 0)return false;\n\telse {\n\t\tfor (int i = 0; i != v[x].size(); ++i) {\n\t\t\tif (vis[v[x][i]]&&!vis2[v[x][i]]) {\n\t\t\t\tif (!dfs3(v[x][i]))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n\nll dfs4(int x) {\n\tll sum = A[x];\n\tvis[x] = false;\n\tfor (int i = 0; i != v[x].size(); ++i) {\n\t\tif (vis[v[x][i]]) {\n\t\t\tsum += dfs4(v[x][i]);\n\t\t}\n\t}\n\treturn sum;\n}\n\nint main() {\n\tcin >> N;\n\tfor (int i = 0; i != N; ++i) {\n\t\tcin >> A[i];\n\t\ts += A[i];\n\t}\n\tif (s < 0) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i != N - 1; ++i) {\n\t\tcin >> U >> V;\n\t\t--U;\n\t\t--V;\n\t\tv[U].push_back(V);\n\t\tv[V].push_back(U);\n\t}\n\tres = intmax;\n\tfor (int i = 0; i != N; ++i) {\n\t\tmemset(g, 0, sizeof g);\n\t\tmemset(vis, false, sizeof vis);\n\t\tcnt = 0;\n\t\tdfs(i);\n\t\tmemset(vis, false, sizeof vis);\n\t\tdfs2(i);\n\t\tcerr << i << sp << cnt << endl;\n\t\tmemset(vis2, false, sizeof vis2);\n\t\tif (dfs3(i) || dfs4(i) < 0)\n\t\t\tres = min(res, cnt);\n\t}\n\tif (res == intmax) {\n\t\tres = N - 1;\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <fstream>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <complex>\n#include <iomanip>\n#include <stdio.h>\n#include <string.h>\n#include <random>\n#include <functional>\n\nusing std::cin;\nusing std::cout;\nusing std::cerr;\nusing std::endl;\n\nusing std::map;\nusing std::set;\nusing std::bitset;\nusing std::vector;\nusing std::string;\nusing std::multimap;\nusing std::multiset;\nusing std::deque;\nusing std::queue;\nusing std::stack;\nusing std::pair;\nusing std::iterator;\n\nusing std::sort;\nusing std::stable_sort;\nusing std::reverse;\nusing std::max_element;\nusing std::min_element;\nusing std::unique;\nusing std::ios_base;\nusing std::swap;\nusing std::fill;\n\nusing std::setprecision;\nusing std::fixed;\n\nlong long min(long long a, long long b) {return a < b ? a : b;}\nlong long min(int a, long long b) {return a < b ? a : b;}\nlong long min(long long a, int b) {return a < b ? a : b;}\nlong long min(int a, int b) {return a < b ? a : b;}\n\nlong long max(long long a, long long b) {return a > b ? a : b;}\nlong long max(int a, long long b) {return a > b ? a : b;}\nlong long max(long long a, int b) {return a > b ? a : b;}\nlong long max(int a, int b) {return a > b ? a : b;}\n\n#define int long long\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<long long> vl;\ntypedef string S;\n\n#define F(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define fi first\n#define se second\n#define re return\n#define all(x) (x).begin(), (x).end()\n\nconst long long INF = 1e18;\nconst int N = 10100;\nconst int MOD = 1e9 + 7;\nconst double eps = 1e-8;\n\nint n;\nint a[N];\nvector<int> graph[N];\nint dp[2][N][N];\nint last_dinamics[N];\nint last_state[N];\nint tmp = 0;\n\nvoid Merge(int p1, int p2)\n{\n    for (int a = 0; a <= last_state[p1]; a++)\n    {\n        for (int b = 0; b <= last_state[p2]; b++)\n        {\n            dp[0][tmp][a + b] = min(dp[0][tmp][a + b], dp[0][p1][a] + dp[0][p2][b]);\n            if (dp[0][p2][b] < INF) dp[0][tmp][a + b + 1] = min(dp[0][tmp][a + b + 1], dp[0][p1][a]);\n            if (dp[1][p2][b] < 0) dp[0][tmp][a + b + 1] = min(dp[0][tmp][a + b + 1], dp[0][p1][a]);\n            dp[1][tmp][a + b] = min(dp[1][tmp][a + b], min(dp[0][p1][a], dp[1][p1][a]) + min(dp[0][p2][b], dp[1][p2][b]));\n            if (dp[0][p2][b] < INF) dp[1][tmp][a + b + 1] = min(dp[0][tmp][a + b + 1], min(dp[0][p1][a], dp[1][p1][a]));\n            if (dp[1][p2][b] < 0) dp[1][tmp][a + b + 1] = min(dp[0][tmp][a + b + 1], min(dp[0][p1][a], dp[1][p1][a]));\n        }\n    }\n    last_state[tmp] = last_state[p1] + last_state[p2] + 1;\n}\n\nvoid dfs(int v, int parent)\n{\n    int merge1 = tmp;\n    dp[0][tmp][0] = 0, dp[1][tmp][0] = 0;\n    tmp++;\n    for (auto u : graph[v]) if (u != parent)\n    {\n        dfs(u, v);\n        int merge2 = last_dinamics[u];\n        Merge(merge1, merge2);\n        merge1 = tmp;\n        tmp++;\n    }\n    tmp--;\n    for (int i = 0; i < n + 100; i++)\n    {\n        dp[1][tmp][i] = min(dp[1][tmp][i] + a[v], INF);\n        dp[0][tmp][i] = min(dp[0][tmp][i] + a[v], INF);\n    }\n    if (a[v] < 0)\n    {\n        for (int i = 0; i < n + 100; i++) dp[0][tmp][i] = INF;\n    }\n    last_dinamics[v] = tmp;\n    tmp++;\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n;\n    for (int i = 0; i < n + 100; i++)\n    {\n        for (int j = 0; j < n + 100; j++)\n        {\n            dp[0][i][j] = INF, dp[1][i][j] = INF;\n        }\n    }\n    for (int i = 0; i < n; i++)\n    {\n        cin >> a[i];\n    }\n    for (int i = 0; i + 1 < n; i++)\n    {\n        int v, u;\n        cin >> v >> u;\n        v--, u--;\n        graph[v].push_back(u);\n        graph[u].push_back(v);\n    }\n    dfs(0, -1);\n    long long ans = n - 1;\n    for (int i = 0; i < n - 1; i++)\n    {\n        if (dp[1][tmp - 1][i] < 0) ans = min(ans, i);\n        if (dp[0][tmp - 1][i] < INF) ans = min(ans, i);\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#line 2 \"Library\\\\gcc_option.hpp\"\n#ifdef ONLINE_JUDGE\n    #pragma GCC optimize(\"O3\")\n    #pragma GCC target(\"avx,avx2\")\n    #pragma GCC optimize(\"unroll-loops\")\n#endif\n#line 2 \"Library\\\\gcc_builtin.hpp\"\n#include <cstdint>\nnamespace workspace {\nconstexpr int clz32(const uint32_t &n) noexcept { return __builtin_clz(n); }\nconstexpr int clz64(const uint64_t &n) noexcept{ return __builtin_clzll(n); }\nconstexpr int ctz(const uint64_t &n) noexcept { return __builtin_ctzll(n); }\nconstexpr int popcnt(const uint64_t &n) noexcept { return __builtin_popcountll(n); }\n} // namespace workspace\n#line 3 \"atcoder-workspace\\\\aising2019\\\\e\\\\e.cpp\"\n#include <bits/extc++.h>\n#line 5 \"Library\\\\config.hpp\"\nnamespace config {\nconst auto start_time{std::chrono::system_clock::now()};\nint64_t elapsed()\n{\n    using namespace std::chrono;\n    const auto end_time{system_clock::now()};\n    return duration_cast<milliseconds>(end_time - start_time).count();\n}\n__attribute__((constructor)) void setup()\n{\n    using namespace std;\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout << fixed << setprecision(15);\n#ifdef _buffer_check\n    atexit([]{ ofstream cnsl(\"CON\"); char bufc; if(cin >> bufc) cnsl << \"\\n\\033[43m\\033[30mwarning: buffer not empty.\\033[0m\\n\\n\"; });\n#endif\n}\nunsigned cases(void), caseid = 1;\ntemplate <class C> void main() { for(const unsigned total = cases(); caseid <= total; ++caseid) C(); }\n} // namespace config\n#line 5 \"Library\\\\utils\\\\binary_search.hpp\"\nnamespace workspace {\n// binary search on discrete range.\ntemplate <class iter_type, class pred_type, std::enable_if_t<std::is_convertible_v<std::invoke_result_t<pred_type, iter_type>, bool>, std::nullptr_t> = nullptr>\niter_type binary_search(iter_type ok, iter_type ng, pred_type pred)\n{\n    assert(ok != ng);\n    intmax_t dist(ng - ok);\n    while(std::abs(dist) > 1)\n    {\n        iter_type mid(ok + dist / 2);\n        if(pred(mid)) ok = mid, dist -= dist / 2;\n        else ng = mid, dist /= 2;\n    }\n    return ok;\n}\n// binary search on real numbers.\ntemplate <class real_type, class pred_type, std::enable_if_t<std::is_convertible_v<std::invoke_result_t<pred_type, real_type>, bool>, std::nullptr_t> = nullptr>\nreal_type binary_search(real_type ok, real_type ng, const real_type eps, pred_type pred)\n{\n    assert(ok != ng);\n    while(std::abs(ok - ng) > eps)\n    {\n        real_type mid{(ok + ng) / 2};\n        (pred(mid) ? ok : ng) = mid;\n    }\n    return ok;\n}\n} // namespace workspace\n#line 3 \"Library\\\\utils\\\\casefmt.hpp\"\nnamespace workspace {\nstd::ostream &casefmt(std::ostream& os) { return os << \"Case #\" << config::caseid << \": \"; }\n} // namespace workspace\n#line 3 \"Library\\\\utils\\\\chval.hpp\"\nnamespace workspace {\ntemplate <class T, class Comp = std::less<T>> bool chle(T &x, const T &y, Comp comp = Comp()) { return comp(y, x) ? x = y, true : false; }\ntemplate <class T, class Comp = std::less<T>> bool chge(T &x, const T &y, Comp comp = Comp()) { return comp(x, y) ? x = y, true : false; }\n} // namespace workspace\n#line 3 \"Library\\\\utils\\\\fixed_point.hpp\"\nnamespace workspace {\n// specify the return type of lambda.\ntemplate <class lambda_type>\nclass fixed_point\n{\n    lambda_type func;\npublic:\n    fixed_point(lambda_type &&f) : func(std::move(f)) {}\n    template <class... Args> auto operator()(Args &&... args) const { return func(*this, std::forward<Args>(args)...); }\n};\n} // namespace workspace\n#line 2 \"Library\\\\utils\\\\sfinae.hpp\"\n#include <type_traits>\ntemplate <class type, template <class> class trait>\nusing enable_if_trait_type = typename std::enable_if<trait<type>::value>::type;\ntemplate <class Container>\nusing element_type = std::remove_const_t<std::remove_reference_t<decltype(*std::begin(std::declval<Container&>()))>>;\n#line 7 \"Library\\\\utils\\\\hash.hpp\"\nnamespace workspace {\ntemplate <class T, class = void>\nstruct hash : std::hash<T> {};\ntemplate <class Unique_bits_type>\nstruct hash<Unique_bits_type, enable_if_trait_type<Unique_bits_type, std::has_unique_object_representations>>\n{\n    size_t operator()(uint64_t x) const\n    {\n        static const uint64_t m = std::random_device{}();\n        x ^= x >> 23;\n        // x *= 0x2127599bf4325c37ULL;\n        x ^= m;\n        x ^= x >> 47;\n        return x - (x >> 32);\n    }\n};\ntemplate <class Key>\nsize_t hash_combine(const size_t &seed, const Key &key)\n{\n    return seed ^ (hash<Key>()(key) + 0x9e3779b9 /* + (seed << 6) + (seed >> 2) */ );\n}\ntemplate <class T1, class T2>\nstruct hash<std::pair<T1, T2>>\n{\n    size_t operator()(const std::pair<T1, T2> &pair) const\n    {\n        return hash_combine(hash<T1>()(pair.first), pair.second);\n    }\n};\ntemplate <class... T>\nclass hash<std::tuple<T...>>\n{\n    template <class Tuple, size_t index = std::tuple_size<Tuple>::value - 1> struct tuple_hash { static uint64_t apply(const Tuple &t) { return hash_combine(tuple_hash<Tuple, index - 1>::apply(t), std::get<index>(t)); } };\n    template <class Tuple> struct tuple_hash<Tuple, size_t(-1)> { static uint64_t apply(const Tuple &t) { return 0; } };\npublic:\n    uint64_t operator()(const std::tuple<T...> &t) const { return tuple_hash<std::tuple<T...>>::apply(t); }\n};\n/*\ntemplate <class Key, class Mapped>\nstruct hash_map : public <Key, Mapped>\n{\n    using base = Container<Key, Mapped>;\n    size_t count(const Key &key) const { return base::find(key) != base::end(); }\n    template <class... Args> auto emplace(Args&&... args) { return base::insert(typename base::value_type(args...)); }\n};\n// template <class Key>\n// struct hash_map<Key, __gnu_pbds::null_type, std::unordered_map> : std::unordered_set<Key>\n// {\n\n// };\n// template <class Key> using hash_set = hash_map<Key, __gnu_pbds::null_type>;\n/*/\ntemplate <class Key, class Mapped> using hash_map = std::unordered_map<Key, Mapped, hash<Key>>;\ntemplate <class Key> using hash_set = std::unordered_set<Key, hash<Key>>;\n/**/\ntemplate <class Key, class Mapped> using hash_multimap = std::unordered_multimap<Key, Mapped, hash<Key>>;\ntemplate <class Key> using hash_multiset = std::unordered_multiset<Key, hash<Key>>;\n} // namespace workspace\n#line 3 \"Library\\\\utils\\\\iostream_overload.hpp\"\nnamespace std\n{\n    template <class T, class U> istream &operator>>(istream &is, pair<T, U> &p) { return is >> p.first >> p.second; }\n    template <class T, class U> ostream &operator<<(ostream &os, const pair<T, U> &p) { return os << p.first << ' ' << p.second; }\n    template <class tuple_t, size_t index> struct tuple_is { static istream &apply(istream &is, tuple_t &t) { tuple_is<tuple_t, index - 1>::apply(is, t); return is >> get<index>(t); } };\n    template <class tuple_t> struct tuple_is<tuple_t, SIZE_MAX> { static istream &apply(istream &is, tuple_t &t) { return is; } };\n    template <class... T> istream &operator>>(istream &is, tuple<T...> &t) { return tuple_is<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(is, t); }\n    template <class tuple_t, size_t index> struct tuple_os { static ostream &apply(ostream &os, const tuple_t &t) { tuple_os<tuple_t, index - 1>::apply(os, t); return os << ' ' << get<index>(t); } };\n    template <class tuple_t> struct tuple_os<tuple_t, 0> { static ostream &apply(ostream &os, const tuple_t &t) { return os << get<0>(t); } };\n    template <class tuple_t> struct tuple_os<tuple_t, SIZE_MAX> { static ostream &apply(ostream &os, const tuple_t &t) { return os; } };\n    template <class... T> ostream &operator<<(ostream &os, const tuple<T...> &t) { return tuple_os<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(os, t); }\n    template <class Container, typename Value = typename Container::value_type, enable_if_t<!is_same<decay_t<Container>, string>::value, nullptr_t> = nullptr>\n    istream& operator>>(istream& is, Container &cont) { for(auto&& e : cont) is >> e; return is; }\n    template <class Container, typename Value = typename Container::value_type, enable_if_t<!is_same<decay_t<Container>, string>::value, nullptr_t> = nullptr>\n    ostream& operator<<(ostream& os, const Container &cont) { bool flag = 1; for(auto&& e : cont) flag ? flag = 0 : (os << ' ', 0), os << e; return os; }\n} // namespace std\n#line 3 \"Library\\\\utils\\\\read.hpp\"\nnamespace workspace {\n// read with std::cin.\ntemplate <class T = void>\nstruct read\n{\n    typename std::remove_const<T>::type value;\n    template <class... types>\n    read(types... args) : value(args...) { std::cin >> value; }\n    operator T() const { return value; }\n};\ntemplate <>\nstruct read<void>\n{\n    template <class T>\n    operator T() const { T value; std::cin >> value; return value; }\n};\n} // namespace workspace\n#line 12 \"atcoder-workspace\\\\aising2019\\\\e\\\\e.cpp\"\nnamespace workspace {\n    constexpr char eol = '\\n';\n    using namespace std; using namespace __gnu_pbds; using namespace __gnu_cxx;\n    using i64 = int_least64_t; using p32 = pair<int, int>; using p64 = pair<i64, i64>;\n    using __gnu_pbds::priority_queue;\n    struct solver;\n}\nint main() { config::main<workspace::solver>(); }\nunsigned config::cases() {\n    // return -1; // not specify\n    // int t; std::cin >> t; return t; // given\n    return 1;\n}\n\nstruct workspace::solver { // start here!\n\nconst i64 inf=1ll<<61;\nvector<i64> a;\nvector<vector<int>> tr;\n\nvector<vector<vector<i64>>> dp;\n\nint dfs(int now,int pre)\n{\n    int sz=1;\n    auto &cdp=dp[now];\n    if(a[now]>0) cdp={{a[now],inf}};\n    else cdp={{inf,a[now]}};\n    for(auto to: tr[now])\n    {\n        if(to==pre) continue;\n        int cz=dfs(to,now);\n        auto &tdp=dp[to];\n        vector ndp(sz+cz,vector<i64>(2,inf));\n        for(int i=0; i<sz; ++i)\n        {\n            for(auto ei: {0,1})\n            {\n                if(cdp[i][ei]==inf) continue;\n                for(int j=0; j<cz; ++j)\n                {\n                    for(auto ej: {0,1})\n                    {\n                        if(tdp[j][ej]==inf) continue;\n                        chle(ndp[i+j][ei|ej],cdp[i][ei]+tdp[j][ej]);\n                        if(!ej or tdp[j][ej]<0) chle(ndp[i+j+1][ei],cdp[i][ei]);\n                    }\n                }\n            }\n        }\n        swap(cdp,ndp);\n        sz+=cz;\n    }\n    return sz;\n}\n\nsolver()\n{\n    int n; cin>>n;\n    a.resize(n); cin>>a;\n    tr.resize(n);\n    for(int i=1; i<n; ++i)\n    {\n        int u,v; cin>>u>>v; --u,--v;\n        tr[u].emplace_back(v);\n        tr[v].emplace_back(u);\n    }\n    dp.resize(n);\n    dfs(0,-1);\n    auto cdp=dp[0];\n    for(size_t i=0; i<cdp.size(); i++)\n    {\n        if(cdp[i][0]<inf or cdp[i][1]<0)\n        {\n            cout<<i<<eol;\n            return;\n        }\n    }\n}};\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF (1LL << 60)\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n\nusing namespace std;\n\ntemplate<typename S,typename T>auto&operator<<(ostream&o,pair<S,T>p){return o<<\"{\"<<p.fi<<\",\"<<p.se<<\"}\";}\ntemplate<typename T>auto&operator<<(ostream&o,set<T>s){for(auto&e:s)o<<e<<\" \";return o;}\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,priority_queue<S,T,U>q){while(!q.empty())o<<q.top()<<\" \",q.pop();return o;}\ntemplate<typename K,typename T>auto&operator<<(ostream&o,map<K,T>m){for(auto&e:m)o<<e<<\" \";return o;}\ntemplate<typename T>auto&operator<<(ostream&o,vector<T>v){for(auto&e:v)o<<e<<\" \";return o;}\nvoid ashow(){cout<<endl;}template<typename T,typename...A>void ashow(T t,A...a){cout<<t<<\" \";ashow(a...);}\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\n\nconst int MAX_N = 5005;\n\nvector<int> G[MAX_N];\nll a[MAX_N];\n\nvl dfs(int u, int p)\n{\n    vl dp(2);\n    if(a[u] < 0){\n        dp[0] = INF;\n    }else{\n        dp[0] = 1;\n    }\n    dp[1] = a[u];\n    each(v, G[u]){\n        if(v != p){\n            auto res = dfs(v, u);\n            vl ndp(len(dp)+len(res)-1, INF);\n            if(res[0] < INF){\n                cmn(ndp[0], dp[0] + res[0] - 1);\n            }else{\n                int num = -1;\n                srep(k,1,len(res)){\n                    if(res[k] < 0){\n                        num = k;\n                        break;\n                    }\n                }\n                cmn(ndp[0], dp[0] + num);\n            }\n            srep(j,1,len(dp)){\n                srep(k,1,len(res)){\n                    cmn(ndp[j+k-1], dp[j]+res[k]);\n                }\n            }\n            swap(dp, ndp);\n        }\n    }\n    return dp;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    rep(i,n){\n        cin >> a[i];\n    }\n    rep(i,n-1){\n        int u, v;\n        cin >> u >> v;\n        G[u-1].pb(v-1), G[v-1].pb(u-1);\n    }\n    auto res = dfs(0, -1);\n    ll ans = INF;\n    if(res[0] < INF) ans = res[0];\n    srep(i,1,len(res)){\n        if(res[i] < 0){\n            cmn(ans, (ll)i);\n            break;\n        }\n    }\n    cout << ans-1 << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 0.00000001\n#define LONG_INF 1e9\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007\n#define MOD 998244353\n#define seg_size 262144\n#define REP(i,n) for(long long i = 0;i < n;++i)\nlong long costings[20000];\nvector<int> vertexs[20000];\nlong long dp1[5101][5101];\nlong long dp2[5101][5101];\nlong long vertexes[5101];\nlong long tmp[5101*2][2];\nlong long dfs(long long now, long long back) {\n\tvertexes[now] = 1;\n\tfor (int i = 0; i < vertexs[now].size(); ++i) {\n\t\tif (vertexs[now][i] != back) {\n\t\t\tdfs(vertexs[now][i], now);\n\t\t\tvertexes[now] += vertexes[vertexs[now][i]];\n\t\t}\n\t}\n\tREP(i, vertexes[now] + 1) {\n\t\ttmp[i][0] = LONG_INF;\n\t\ttmp[i][1] = LONG_INF;\n\t}\n\ttmp[0][0] = costings[now];\n\tif (costings[now] > 0) tmp[0][1] = costings[now];\n\tlong long now_tea = 0;\n\tREP(i, vertexs[now].size()) {\n\t\tif (vertexs[now][i] != back) {\n\t\t\tfor (int j = now_tea; j >= 0; --j) {\n\t\t\t\tlong long geko_a = tmp[j][0];\n\t\t\t\tlong long geko_b = tmp[j][1];\n\t\t\t\ttmp[j][0] = LONG_INF;\n\t\t\t\ttmp[j][1] = LONG_INF;\n\t\t\t\tint visiting = vertexs[now][i];\n\t\t\t\tfor (int k = 0; k <= vertexes[visiting]; ++k) {\n\t\t\t\t\ttmp[j + k][0] = min(tmp[j + k][0], geko_a + dp1[visiting][k]);\n\t\t\t\t\tif (dp1[visiting][k] < 0 || dp2[visiting][k] < LONG_INF / 2) tmp[j + k + 1][0] = min(tmp[j + k + 1][0], geko_a);\n\t\t\t\t\tif (costings[now] > 0) {\n\t\t\t\t\t\ttmp[j + k][1] = min(tmp[j + k][1], geko_b + dp2[visiting][k]);\n\t\t\t\t\t\tif (dp1[visiting][k] < 0 || dp2[visiting][k] < LONG_INF / 2) tmp[j + k + 1][1] = min(tmp[j + k + 1][1], geko_b);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tnow_tea += vertexes[vertexs[now][i]];\n\t\t}\n\t}\n\tfor (int j = 0; j <= vertexes[now]; ++j) {\n\t\tdp1[now][j] = tmp[j][0];\n\t\tdp2[now][j] = tmp[j][1];\n\t}\n\treturn 0;\n}\nint main() {\n#define int long long\n\tint n;\n\tcin >> n;\n\tREP(i, 5001) {\n\t\tREP(q, 5001) {\n\t\t\tdp1[i][q] = LONG_INF;\n\t\t\tdp2[i][q] = LONG_INF;\n\t\t}\n\t}\n\tREP(i, n) {\n\t\tcin >> costings[i];\n\t}\n\tREP(i, n - 1) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--;\n\t\tb--;\n\t\tvertexs[a].push_back(b);\n\t\tvertexs[b].push_back(a);\n\t}\n\tdfs(0, -1);\n\tREP(i, n + 1) {\n\t\tif (dp1[0][i] < 0 || dp2[0][i] < LONG_INF / 2) {\n\t\t\tcout << i << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << n << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <fstream>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <complex>\n#include <iomanip>\n#include <stdio.h>\n#include <string.h>\n#include <random>\n#include <functional>\n\nusing std::cin;\nusing std::cout;\nusing std::cerr;\nusing std::endl;\n\nusing std::map;\nusing std::set;\nusing std::bitset;\nusing std::vector;\nusing std::string;\nusing std::multimap;\nusing std::multiset;\nusing std::deque;\nusing std::queue;\nusing std::stack;\nusing std::pair;\nusing std::iterator;\n\nusing std::sort;\nusing std::stable_sort;\nusing std::reverse;\nusing std::max_element;\nusing std::min_element;\nusing std::unique;\nusing std::ios_base;\nusing std::swap;\nusing std::fill;\n\nusing std::setprecision;\nusing std::fixed;\n\nlong long min(long long a, long long b) {return a < b ? a : b;}\nlong long min(int a, long long b) {return a < b ? a : b;}\nlong long min(long long a, int b) {return a < b ? a : b;}\nlong long min(int a, int b) {return a < b ? a : b;}\n\nlong long max(long long a, long long b) {return a > b ? a : b;}\nlong long max(int a, long long b) {return a > b ? a : b;}\nlong long max(long long a, int b) {return a > b ? a : b;}\nlong long max(int a, int b) {return a > b ? a : b;}\n\n#define int long long\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<long long> vl;\ntypedef string S;\n\n#define F(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define fi first\n#define se second\n#define re return\n#define all(x) (x).begin(), (x).end()\n\nconst long long INF = 1e18;\nconst int N = 10100;\nconst int MOD = 1e9 + 7;\nconst double eps = 1e-8;\n\nint n;\nint a[N];\nvector<int> graph[N];\nint dp[2][N][N / 2];\nint last_dinamics[N];\nint last_state[N];\nint tmp = 0;\n\nvoid Merge(int p1, int p2)\n{\n    for (int a = 0; a <= last_state[p1]; a++)\n    {\n        for (int b = 0; b <= last_state[p2]; b++)\n        {\n            dp[0][tmp][a + b] = min(dp[0][tmp][a + b], dp[0][p1][a] + dp[0][p2][b]);\n            if (dp[0][p2][b] < INF) dp[0][tmp][a + b + 1] = min(dp[0][tmp][a + b + 1], dp[0][p1][a]);\n            if (dp[1][p2][b] < 0) dp[0][tmp][a + b + 1] = min(dp[0][tmp][a + b + 1], dp[0][p1][a]);\n            dp[1][tmp][a + b] = min(dp[1][tmp][a + b], min(dp[0][p1][a], dp[1][p1][a]) + min(dp[0][p2][b], dp[1][p2][b]));\n            if (dp[0][p2][b] < INF) dp[1][tmp][a + b + 1] = min(dp[0][tmp][a + b + 1], min(dp[0][p1][a], dp[1][p1][a]));\n            if (dp[1][p2][b] < 0) dp[1][tmp][a + b + 1] = min(dp[0][tmp][a + b + 1], min(dp[0][p1][a], dp[1][p1][a]));\n        }\n    }\n    last_state[tmp] = last_state[p1] + last_state[p2] + 1;\n}\n\nvoid dfs(int v, int parent)\n{\n    int merge1 = tmp;\n    dp[0][tmp][0] = 0, dp[1][tmp][0] = 0;\n    tmp++;\n    for (auto u : graph[v]) if (u != parent)\n    {\n        dfs(u, v);\n        int merge2 = last_dinamics[u];\n        Merge(merge1, merge2);\n        merge1 = tmp;\n        tmp++;\n    }\n    tmp--;\n    for (int i = 0; i < n + 100; i++)\n    {\n        dp[1][tmp][i] = min(dp[1][tmp][i] + a[v], INF);\n        dp[0][tmp][i] = min(dp[0][tmp][i] + a[v], INF);\n    }\n    if (a[v] < 0)\n    {\n        for (int i = 0; i < n + 100; i++) dp[0][tmp][i] = INF;\n    }\n    last_dinamics[v] = tmp;\n    tmp++;\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n;\n    for (int i = 0; i < n + 100; i++)\n    {\n        for (int j = 0; j < n + 100; j++)\n        {\n            dp[0][i][j] = INF, dp[1][i][j] = INF;\n        }\n    }\n    for (int i = 0; i < n; i++)\n    {\n        cin >> a[i];\n    }\n    for (int i = 0; i + 1 < n; i++)\n    {\n        int v, u;\n        cin >> v >> u;\n        v--, u--;\n        graph[v].push_back(u);\n        graph[u].push_back(v);\n    }\n    dfs(0, -1);\n    long long ans = n - 1;\n    for (int i = 0; i < n - 1; i++)\n    {\n        //cout << dp[1][tmp - 1][i] << \" \" << dp[0][tmp - 1][i] << \"\\n\";\n        if (dp[1][tmp - 1][i] < 0) ans = min(ans, i);\n        if (dp[0][tmp - 1][i] < INF) ans = min(ans, i);\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#define vll vector<ll>\n#define vvvl vector<vvl>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d> >(a, vector<d>(b, c))\n#define VVV(a, b, c, d) vector<vvl>(a, vvl(b, vll (c, d)));\n#define re(c, b) for(ll c=0;c<b;c++)\n#define all(obj) (obj).begin(), (obj).end()\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\n\nvll num;\nll N;\nvvl G = VV(5001, 0, 0, ll);\nll INF = 1000000000000000000;\nvvvl dp = VVV(5001, 0, 0, INF);\nvll sz(5001, -1);\n\nvoid dfs(ll now, ll from){\n  ll now_sz = 1;\n  vvl prev = VV(2, 2, INF, ll);\n  vvl dat = VV(2, 2, INF, ll);\n  dat[1][0] = num[now];\n  if(num[now]>0) dat[1][1] = num[now];\n\n  for(auto to:G[now]){\n    if(to==from) continue;\n    dfs(to, now);\n    prev = dat;\n    dat = VV(now_sz+sz[to]+1, 2, INF, ll);\n\n    ll minit_zero = INF, minit_one = INF;\n    for(int i=1;i<=sz[to];i++){\n      if(dp[to][i][1]!=INF&&minit_one==INF) minit_one = i;\n      if(dp[to][i][0] < 0&&minit_zero==INF) minit_zero = i;\n    }\n\n    ll x = min(minit_one, minit_zero);\n    for(int i=1;i<=now_sz;i++){\n      //分離\n      if(i+x>N) continue;\n      if(x!=INF){\n        dat[i+x][0] = min(dat[i+x][0], prev[i][0]);\n        dat[i+x][1] = min(dat[i+x][1], prev[i][1]);\n      }\n    }\n\n    for(int i=1;i<=now_sz;i++){\n      for(int j=1;j<=sz[to];j++){\n        if(i+j>N) continue;\n        //連結\n        dat[i+j-1][0] = min(dat[i+j-1][0],\n          prev[i][0] + dp[to][j][0]);\n        dat[i+j-1][1] = min(dat[i+j-1][1],\n          prev[i][1] + dp[to][j][1]);\n      }\n    }\n    now_sz += sz[to];\n  }\n  sz[now] = now_sz;\n  dp[now] = dat;\n}\n\nint main(int argc, char const *argv[]) {\n  ll n;std::cin >> n;\n  N = n;\n  num.resize(n);\n  re(i, n) scanf(\"%lld\", &num[i]);\n  for(int i=0;i<n-1;i++){\n    ll a, b;scanf(\"%lld %lld\", &a, &b);\n    a--, b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  dfs(0, -1);\n  for(int i=1;i<=N;i++){\n    if(dp[0][i][0]<0||dp[0][i][1]!=INF){\n      std::cout << i - 1 << '\\n';\n      return 0;\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 100000000000000;\n\nint n;\nvector<ll> a(5000);\nvector<vector<ll> > adj(5000, vector<ll>());\n//vector<vector<vector<ll> > > dp(5000, vector<vector<ll> >(5000, vector<ll>(2, INF)));\nll dp[5000][5000][2];\nvector<int> edges(5000, 0);\n\nvoid chmin(ll& before, ll after) {\n\tif (before > after) before = after;\n\treturn;\n}\n\nint dfs_pre(int x, int p) {\n\tif (x != 0 && adj[x].size() == 1) return 0;\n\tfor (auto v : adj[x]) {\n\t\tif (v == p) continue;\n\t\telse edges[x] += dfs_pre(v, x) + 1;\n\t}\n\treturn edges[x];\n}\n\nvoid dfs(int x, int p) {\n\tfor (auto v : adj[x]) {\n\t\tif (v != p) dfs(v, x);\n\t}\n\n\t//vector<vector<vector<ll> > > sub(n, vector<vector<ll> >(n, vector<ll>(2, INF)));\n\tll sub[n][n][2];\n\tfor (int i = 0; i < adj[x].size()+1; ++i)\n\t{\n\t\tfor (int j = 0; j < edges[x]+1; ++j)\n\t\t{\n\t\t\tsub[i][j][0] = INF;\n\t\t\tsub[i][j][1] = INF;\n\t\t}\n\t}\n\tsub[0][0][1] = a[x];\n\tif (a[x] > 0) sub[0][0][0] = a[x];\n\tint i = 0;\n\tint e_cnt = 0;\n\n\tfor (auto v : adj[x]) {\n\t\tif (v == p) continue;\n\t\tfor (int j1 = 0; j1 < e_cnt+1; ++j1)\n\t\t{\n\t\t\tfor (int j2 = 0; j2 < edges[v]+1; ++j2)\n\t\t\t{\n\t\t\t\tchmin(sub[i+1][j1+j2][1], sub[i][j1][0] + dp[v][j2][1]);\n\t\t\t\tchmin(sub[i+1][j1+j2][1], sub[i][j1][1] + dp[v][j2][0]);\n\t\t\t\tchmin(sub[i+1][j1+j2][1], sub[i][j1][1] + dp[v][j2][1]);\n\t\t\t\tif (a[x] > 0) chmin(sub[i+1][j1+j2][0], sub[i][j1][0] + dp[v][j2][0]);\n\n\t\t\t\tif (dp[v][j2][0] < INF/2 || dp[v][j2][1] < 0) {\n\t\t\t\t\tchmin(sub[i+1][j1+j2+1][1], sub[i][j1][1]);\n\t\t\t\t\tif (a[x] > 0) chmin(sub[i+1][j1+j2+1][0], sub[i][j1][0]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\te_cnt += edges[v] + 1;\n\t\ti++;\n\t}\n\tfor (int j = 0; j < edges[x]+1; ++j)\n\t{\n\t\tdp[x][j][0] = sub[i][j][0];\n\t\tdp[x][j][1] = sub[i][j][1];\n\t}\n\n\treturn;\n}\n\nint main() {\n\tfor (int i = 0; i < 5000; ++i)\n\t{\n\t\tfor (int j = 0; j < 5000; ++j)\n\t\t{\n\t\t\tfor (int k = 0; k < 2; ++k)\n\t\t\t{\n\t\t\t\tdp[i][j][k] = INF;\n\t\t\t}\n\t\t}\n\t}\n\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i) cin >> a[i];\n\tfor (int i = 0; i < n-1; ++i)\n\t{\n\t\tint u, v; cin >> u >> v;\n\t\tadj[u-1].push_back(v-1);\n\t\tadj[v-1].push_back(u-1);\n\t}\n\n\tdfs_pre(0, -1);\n\n\tdfs(0, -1);\n\n\tint ans;\n\tfor (int j = 0; j < n; ++j)\n\t{\n\t\tif (dp[0][j][0] < INF/2 || dp[0][j][1] < 0) {\n\t\t\tans = j;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int64_t inf = 1LL << 40;\n\nint64_t a[5000], dp1[5000][5001], dp2[5000][5001], size[5000], merged1[5001], merged2[5001];\nvector<int> graph[5000];\n\ntemplate <typename T>\nvoid ChangeMin(T& var, T t) { var = min(var, t); }\n\nvoid DFS(int root, int parent) {\n  for (int num = 0; num <= 5000; num++) dp1[root][num] = dp2[root][num] = inf;\n\n  size[root] = 1;\n\n  dp1[root][1] = a[root] > 0 ? a[root] : inf;\n  dp2[root][1] = a[root];\n\n  for (int to : graph[root]) {\n    if (to == parent) continue;\n\n    DFS(to, root);\n\n    for (int num = 1; num <= size[root] + size[to]; num++) merged1[num] = merged2[num] = inf;\n\n    for (int num1 = 1; num1 <= size[root]; num1++) {\n      for (int num2 = 1; num2 <= size[to]; num2++) {\n        // 繋げない\n        if (dp1[to][num2] < inf) {\n          ChangeMin(merged1[num1 + num2], dp1[root][num1]);\n          ChangeMin(merged2[num1 + num2], dp2[root][num1]);\n        }\n        if (dp2[to][num2] < 0) {\n          ChangeMin(merged1[num1 + num2], dp1[root][num1]);\n          ChangeMin(merged2[num1 + num2], dp2[root][num1]);\n        }\n\n        // 繋げる\n        ChangeMin(merged1[num1 + num2 - 1], dp1[root][num1] + dp1[to][num2]);\n        ChangeMin(merged2[num1 + num2 - 1], dp2[root][num1] + dp2[to][num2]);\n      }\n    }\n    size[root] += size[to];\n    for (int num = 1; num <= size[root]; num++) {\n      dp1[root][num] = merged1[num];\n      dp2[root][num] = merged2[num];\n    }\n  }\n}\n\nint main() {\n  int n;\n  cin >> n;\n\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n\n  for (int i = 0; i < n - 1; i++) {\n    int u, v;\n    cin >> u >> v;\n    u--; v--;\n    graph[u].push_back(v);\n    graph[v].push_back(u);\n  }\n\n  DFS(0, -1);\n\n  for (int num = 1; num <= n; num++) {\n    if (dp1[0][num] < inf or dp2[0][num] < 0) {\n      cout << num - 1 << endl;\n      break;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nusing PII = pair<int, int>;\n#define FI(i,a,b) for(int i=(a);i<=(b);++i)\n#define FD(i,b,a) for(int i=(b);i>=(a);--i)\n#define DEBUG(x) cerr << #x << \": \" << (x) << endl;\nconstexpr int inv(LL x, int m) { return x > m ? inv(x % m, m) : x > 1 ? inv(m % x, m) * (m - m / x) % m : x; }\nconstexpr int mpow(LL a, LL k, int m) { int r(1); for (a %= m; k; k >>= 1, a = a * a % m) if (k & 1)r = r * a % m; return r; }\n\nconst int N = 5005;\nint n, A[N];\nvector<int> G[N];\nvector<LL> F[N], H[N];\nLL INF = 1LL << 60;\n\nvoid dfs(int u, int p) {\n    F[u].push_back(INF);\n    F[u].push_back(A[u] < 0 ? INF : A[u]);\n    H[u].push_back(INF);\n    H[u].push_back(A[u]);\n    for (auto v : G[u]) if (v != p) {\n            dfs(v, u);\n            vector<LL> TF(F[u].size() + F[v].size(), INF), TH(TF);\n            for (auto i = 1u; i < F[u].size(); i++) {\n                for (auto j = 1u; j < F[v].size(); j++) {\n                    TF[i + j - 1] = min(TF[i + j - 1], F[u][i] + F[v][j]);\n                    TH[i + j - 1] = min(TH[i + j - 1], H[u][i] + H[v][j]);\n                    if (F[v][j] < INF || H[v][j] < 0) {\n                        TF[i + j] = min(TF[i + j], F[u][i]);\n                        TH[i + j] = min(TH[i + j], H[u][i]);\n                    }\n                }\n            }\n            F[u] = TF, H[u] = TH;\n            F[v].clear(), H[v].clear();\n        }\n}\nint main() {\n    cin >> n;\n    FI(i, 1, n) scanf(\"%d\", A + i);\n    for (int i = 2, u, v; i <= n; i++)\n        scanf(\"%d%d\", &u, &v), G[u].push_back(v), G[v].push_back(u);\n    dfs(1, -1);\n    FI(i, 1, n) {\n        // printf(\"%d, %lld, %lld\\n\", i, F[1][i], H[1][i]);\n        if (F[1][i] < INF || H[1][i] < 0) return !printf(\"%d\\n\", i - 1);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long dp[5010][5010];\nlong long tmp[5010];\nbool pos[5010][5010];\nbool ptmp[5010];\nint sz[5010];\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n; cin >> n;\n    vector<long long> a(n);\n    for (int i = 0; i < n; i++) cin >> a[i];\n    vector<vector<int>> e(n);\n    for (int i = 1; i < n; i++) {\n        int u, v; cin >> u >> v;\n        u--, v--;\n        e[u].emplace_back(v);\n        e[v].emplace_back(u);\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j <= n; j++) {\n            dp[i][j] = 1e16;\n        }\n    }\n    auto f = [&](auto f, int curr, int prev) -> void {\n        sz[curr] = 1; pos[curr][0] = (a[curr] > 0);\n        dp[curr][0] = a[curr];\n        for (auto &to: e[curr]) {\n            if (to == prev) continue;\n            f(f, to, curr);\n            for (int i = 0; i < n; i++) tmp[i] = 1e16, ptmp[i] = 0;\n            for (int i = 0; i < sz[curr]; i++) {\n                for (int j = 0; j < sz[to]; j++) {\n                    if (pos[to][j] || dp[to][j] < 0) {\n                        tmp[i+j+1] = min(tmp[i+j+1], dp[curr][i]);\n                        ptmp[i+j+1] |= pos[curr][i];\n                    }\n                    ptmp[i+j] |= pos[curr][i] & pos[to][j];\n                    tmp[i+j] = min(tmp[i+j], dp[curr][i] + dp[to][j]);\n                }\n            }\n            sz[curr] += sz[to];\n            for (int i = 0; i < sz[curr]; i++) {\n                dp[curr][i] = tmp[i];\n                pos[curr][i] = ptmp[i];\n            }\n        }\n    };\n    f(f, 0, -1);\n    for (int i = 0; i < n; i++) {\n        if (dp[0][i] < 0 || pos[0][i]) {\n            cout << i << \"\\n\";\n            return 0;\n        }\n    }\n    assert(false);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target (\"avx2\")\n#pragma GCC optimize (\"unroll-loops\")\n#pragma GCC optimize (\"O3\")\n#include \"bits/stdc++.h\"\n#include <unordered_set>\n#include <unordered_map>\n#include <random>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1'000'000'007LL; /*998'244'353LL;*/\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define rep(i, n) for(int (i)=0; (i)<(n); (i)++)\nconst int dx[4]={ 1,0,-1,0 };\nconst int dy[4]={ 0,1,0,-1 };\n\nint N;\nll A[5000];\nvector<int> E[5000], chi[5000];\nint en[5000][5000];\n\nint cnt = 0;\nvoid dfs(int v, int p){\n    rep(i, E[v].size()){\n        if(E[v][i] == p) continue;\n        en[v][chi[v].size()] = cnt++;\n        chi[v].pb(E[v][i]);\n        dfs(E[v][i], v);\n    }\n}\n\nbool solveB(int, int, int);\n\nll dp[5000][5000];\nll solve(int v, int n, int e){\n    if(e == chi[v].size()){\n        if(n == 0) return A[v];\n        else return 1e18L;\n    }\n    if(dp[en[v][e]][n] != LLONG_MIN) return dp[en[v][e]][n];\n    ll ret = 1e18L;\n    rep(i, n+1){\n        ret = min(ret, solve(chi[v][e], n-i, 0) + solve(v, i, e+1));\n        if(n-i > 0)\n            ret = min(ret, solve(chi[v][e], n-i-1, 0) + solve(v, i, e+1));\n        if(A[chi[v][e]] > 0 && n-i > 0 && solveB(chi[v][e], n-i-1, 0))\n            ret = min(ret, solve(v, i, e+1));\n    }\n    return dp[en[v][e]][n] = ret;\n}\n\nint dpB[5000][5000];\nbool solveB(int v, int n, int e){\n    if(e == chi[v].size()){\n        if(n == 0) return true;\n        else return false;\n    }\n    if(dpB[en[v][e]][n] != -1) return dpB[en[v][e]][n];\n    bool ret = false;\n    rep(i, n+1){\n        if(n-i > 0)\n            ret |= (solve(chi[v][e], n-i-1, 0) < 0) && solveB(v, i, e+1);\n        if(A[chi[v][e]] > 0 && n-i > 0)\n            ret |= solveB(chi[v][e], n-i-1, 0) && solveB(v, i, e+1);\n        if(A[chi[v][e]] > 0)\n            ret |= solveB(chi[v][e], n-i, 0) && solveB(v, i, e+1);\n    }\n    return dpB[en[v][e]][n] = ret;\n}\n\nsigned main(){\n    cin >> N;\n    rep(i, N) cin >> A[i];\n    rep(i, N-1){\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        E[u].pb(v);\n        E[v].pb(u);\n    }\n    dfs(0, -1);\n    \n    rep(i, N){\n        rep(j, N){\n            dp[i][j] = LLONG_MIN;\n            dpB[i][j] = -1;\n        }\n    }\n    for(int i=N; i>=1; i--){\n        if(A[0] > 0){\n            if(solve(0, i-1, 0) >= 0 && solveB(0, i-1, 0) == false){\n                cout << i << endl;\n                exit(0);\n            }\n        }\n        else{\n            if(solve(0, i-1, 0) >= 0){\n                cout << i << endl;\n                exit(0);\n            }\n        }\n    }\n    cout << 0 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//注意点\n//Tは3つの値を持つ構造\n//だがワイルドカードとしても使っている\n#include <bits/stdc++.h>\nusing namespace std;\n//@起動時\nstruct initon {\n    initon() {\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.setf(ios::fixed);\n        cout.precision(16);\n    };\n} __initon;\n\n//@必須構造\nstruct T {\n    int f, s, t;\n    T() { f = -1, s = -1, t = -1; }\n    T(int f, int s, int t) : f(f), s(s), t(t) {}\n    bool operator<(const T &r) const {\n        return f != r.f ? f < r.f : s != r.s ? s < r.s : t < r.t;\n        //return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 大きい順\n    }\n    bool operator>(const T &r) const {\n        return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t;\n        //return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 小さい順\n    }\n    int operator[](int i) {\n        assert(i < 3);\n        return i == 0 ? f : i == 1 ? s : t;\n    }\n};\n\n//@マクロ省略系 型,構造\n\n#define int long long\n#define ll long long\n#define double long double\n#define ull unsigned long long\nusing dou = double;\nusing itn = int;\nusing str = string;\nusing bo= bool;\nusing P = pair<int, int>;\n#define F first\n#define S second\n#define vec vector\n#define con continue\n#define bre break\n#define brk break\n#define is ==\n#define rs resize\n\n//マクロ省略系 コンテナ\nusing vi = vector<int>;\n#define vvi(a, b, c) vec<vi> a(b,vi(c))\nusing vb = vector<bool>;\n#define vvb(a, b, c) vec<vb> a(b,vb(c))\nusing vs = vector<string>;\n#define vvs(a, b, c) vec<vs> a(b,vs(c))\nusing vl = vector<ll>;\n#define vvl(a, b, c) vec<vl> a(b,vl(c))\nusing vd = vector<double>;\n#define vvd(a, b, c) vec<vd> a(b,vd(c))\nusing vc=vector<char>;\n#define vvc(a, b, c) vec<vc> a(b,vc(c))\nusing vp = vector<P>;\n#define vvp(a, b, c) vec<vp> a(b,vp(c))\nusing vt = vector<T>;\n#define vvt(a, b, c) vec<vt> a(b,vt(c))\n#define v3i(a, b, c, d) vector<vector<vi>> a(b, vector<vi>(c, vi(d)))\n#define v3d(a, b, c, d) vector<vector<vd>> a(b, vector<vd>(c, vd(d)))\n#define v3m(a, b, c, d) vector<vector<vm>> a(b, vector<vm>(c, vm(d)))\n#define PQ priority_queue<ll, vector<ll>, greater<ll> >\nusing seti = set<int>;\n#define uset unordered_set\n#define mset multiset\n#define umap unordered_map\n#define mmap multimap\n\n//マクロ 繰り返し\n#define _overloadrep(_1, _2, _3, name, ...) name\n# define _rep(i, n) for(int i = 0; i < n ; i++)\n#define repi(i, m, n) for(int i = m; i < n ; i++)\n#define rep(...) _overloadrep(__VA_ARGS__,repi,_rep,)(__VA_ARGS__)\n#define _rer(i, n) for(int i = n; i >= 0 ; i--)\n#define reri(i, m, n) for(int i = m; i >= n ; i--)\n#define rer(...) _overloadrep(__VA_ARGS__,reri,_rer,)(__VA_ARGS__)\n#define fora(a, b) for(auto&& a : b)\n#define forg(gi, ve) if (ve.size())for (int gi = 0, f = ve[gi].from, t = ve[gi].to, c = ve[gi].cost; gi < ve.size(); gi++,f = ve[gi].from, t = ve[gi].to, c = ve[gi].cost)\n\n//マクロ 定数\n#define k4 10101\n#define k5 101010\n#define k6 1010101\n#define k7 10101010\nconst int inf = (int) 1e9 + 100;\nconst ll linf = (ll) 1e18 + 100;\nconst double eps = 1e-9;\nconst int y4[] = {-1, 1, 0, 0};\nconst int x4[] = {0, 0, -1, 1};\nconst int y8[] = {0, 1, 0, -1, -1, 1, 1, -1};\nconst int x8[] = {1, 0, -1, 0, 1, -1, 1, -1};\n\n//マクロ省略形 関数等\n#define arsz(a) (sizeof(a)/sizeof(a[0]))\n#define sz(a) (a.size())\n#define mp make_pair\n#define pb push_back\n#define pf push_front\n#define eb emplace_back\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\n//@拡張系 こう出来るべきというもの\n\n//埋め込み 存在を意識せずに機能を増やされているもの\n// 境界チェック付きvector\nnamespace std_vector_bounds_checking {\n    using namespace std;\n    template<class T, class A = std::allocator<T>> struct vector : std::vector<T, A> {\n        using std::vector<T, A>::vector;\n        typename std::vector<T>::reference operator[](typename std::vector<T>::size_type n) {\n            return this->at(n);\n        }\n    };\n}\nnamespace std {\n    template<> class hash<std::pair<signed, signed>> {\n    public:\n        size_t operator()(const std::pair<signed, signed> &x) const {\n            return hash<ll>()(((ll) x.first << 32) + x.second);\n        }\n    };\n    template<> class hash<std::pair<ll, ll>> {\n    public:\n        size_t operator()(const std::pair<ll, ll> &x) const {\n            return hash<ll>()(((ll) x.first << 32) + x.second);\n        }\n    };\n}\ntemplate<typename T> istream &operator>>(istream &iss, vector<T> &vec) {\n    for (T &x: vec) iss >> x;\n    return iss;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, vector <T> &vec) {\n    for (int i = 0; i < vec.size(); i++)os << vec[i] << (i + 1 == vec.size() ? \"\" : \" \");\n    return os;\n}\ntemplate<typename V, typename H> void resize(vector<V> &vec, const H head) {  //再帰の終端。 可変長templateの長さが 0 になるとこっちが呼ばれる。\n    vec.resize(head);\n}\ntemplate<typename V, typename H, typename ... T> void resize(vector<V> &vec, const H &head, const T ... tail) {\n    vec.resize(head);\n    for (auto &v: vec) resize(v, tail...);\n}\ntemplate<class T> T pop(set<T> &set) {\n    T res = *set.begin();\n    set.erase(set.find(res));\n    return res;\n}\ntemplate<class T> T pop(mset<T> &set) {\n    T res = *set.begin();\n    set.erase(set.find(res));\n    return res;\n}\ntemplate<class T> T popBack(set<T> &set) {\n    T res = *set.rbegin();\n    set.erase(set.find(res));\n    return res;\n}\ntemplate<class T> T popBack(mset<T> &set) {\n    T res = *set.rbegin();\n    set.erase(set.find(res));\n    return res;\n}\ntemplate<class T> inline void sort(vector<T> &a) { sort(a.begin(), a.end()); };\ntemplate<class T> inline void rsort(vector<T> &a) { sort(a.begin(), a.end(), greater<T>()); };\ntemplate<class T> inline void sort(vector<T> &a, int len) { sort(a.begin(), a.begin() + len); };\ntemplate<class T> inline void rsort(vector<T> &a, int len) { sort(a.begin(), a.begin() + len, greater<T>()); };\ntemplate<class T> inline void sort2(vector<vector<T>> &a) { for (int i = 0, n = a.size(); i < n; i++)sort(a[i]); }\ntemplate<class T> inline void rsort2(vector<vector<T>> &a) { for (int i = 0, n = a.size(); i < n; i++)rsort(a[i]); }\ntemplate<typename A, size_t N, typename T> void fill(A (&a)[N], const T &v) { rep(i, N)a[i] = v; }\ntemplate<typename A, size_t N, size_t O, typename T> void fill(A (&a)[N][O], const T &v) { rep(i, N)rep(j, O)a[i][j] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, typename T> void fill(A (&a)[N][O][P], const T &v) { rep(i, N)rep(j, O)rep(k, P)a[i][j][k] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, typename T> void fill(A (&a)[N][O][P][Q], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)a[i][j][k][l] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, typename T> void fill(A (&a)[N][O][P][Q][R], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)a[i][j][k][l][m] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S, typename T> void fill(A (&a)[N][O][P][Q][R][S], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)rep(n, S)a[i][j][k][l][m][n] = v; }\ntemplate<typename V, typename T> void fill(V &x, const T &val) { x = val; }\ntemplate<typename V, typename T> void fill(vector<V> &vect, const T &val) { for (auto &v: vect) fill(v, val); }\n//@汎用便利関数 入力\ntemplate<typename T = int> T in() {\n    T x;\n    cin >> x;\n    return (x);\n}\nstring sin() { return in<string>(); }\ndouble din() { return in<double>(); }\nll lin() { return in<ll>(); }\n#define na(a, n) rep(i,n) cin >> a[i];\n#define nad(a, n) rep(i,n) cin >> a[i], a[i]--;\n#define na3(a, b, c, n) rep(i, n)cin >> a[i] >> b[i] >> c[i];\n#define add2(a, b, n) rep(i, n)a.pb(in()),b.pb(in());\n#define add2d(a, b, n) rep(i, n)a.pb(in()-1),b.pb(in()-1);\n#define add3(a, b, c, n) rep(i, n)a.pb(in()),b.pb(in()),c.pb(in());\n#define add3d(a, b, c, n) rep(i, n)a.pb(in()-1),b.pb(in()-1),c.pb(in());\n#define na2(a, b, n) rep(i, n)cin >> a[i] >> b[i];\n#define nt(a, h, w) rep(hi,h)rep(wi,w) cin >> a[hi][wi];\n#define ntd(a, h, w) rep(hi,h)rep(wi,w) cin >> a[hi][wi], a[hi][wi]--;\n#define ntp(a, h, w) fill(a,'#');rep(hi,1,h+1)rep(wi,1,w+1) cin >> a[hi][wi];\n#define addn(a, n) a.resize(n);na(a,n);\n#define addnd(a, n) a.resize(n);na(a,n);rep(i,n)a[i]--;\n\n\n//汎用便利関数 出力\ntemplate<class T> void out(T x) { typeid(x) == typeid(double) ? cout << fixed << setprecision(10) << x << endl : cout << x << endl; }\n//デバッグ\n#define debug(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n';\n//よく使うクラス、構造体\nclass UnionFind {\npublic:\n    vi par, rank, sizes;\n    int n, trees;\n    UnionFind(int n) : n(n), trees(n) {\n        par.resize(n), rank.resize(n), sizes.resize(n);\n        rep(i, n)par[i] = i, sizes[i] = 1;\n    }\n    int root(int x) {\n        if (par[x] == x)return x;\n        else return par[x] = root(par[x]);\n    }\n    int find(int x) { return root(x); }\n    void unite(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y)return;\n        if (rank[x] < rank[y])swap(x, y);\n        trees--;\n        par[y] = x;\n        sizes[x] += sizes[y];\n        if (rank[x] == rank[y])rank[x]++;\n    }\n    bool same(int x, int y) { return root(x) == root(y); }\n    int size(int x) { return sizes[root(x)]; }\n    //順不同 umapなので\n    vec<vi> sets() {\n        vec<vi> res(trees);\n        umap<int, vi> map;\n        rep(i, n) map[root(i)].push_back(i);\n        int i = 0;\n        for (auto &&p:map) {\n            int r = p.F;\n            res[i].push_back(r);\n            for (auto &&v:p.S) {\n                if (r == v)continue;\n                res[i].push_back(v);\n            }\n            i++;\n        }\n        return res;\n    }\n};\n\n//MOD関連\nll MOD = (int) 1e9 + 7;\nint mpow(int v, ll a) {\n    ll x = v, n = a, res = 1;\n    while (n) {\n        if (n & 1)res = (res * x) % MOD;\n        x = (x * x) % MOD;\n        n >>= 1;\n    }\n    return res;\n}\nclass mint {\nprivate:\n    ll v;\npublic:\n    static ll mod(ll a) { return (a % MOD + MOD) % MOD; }\n    mint(ll a = 0) { this->v = mod(a); };\n    mint(const mint &a) { v = a.v; }\n    mint operator+(const mint &a) { return mint(v + a.v); }\n    mint operator+(const ll a) { return mint(v + a % MOD); }\n    mint operator+(const signed a) { return mint(v + a % MOD); }\n    friend mint operator+(const ll a, const mint &b) { return mint(a % MOD + b.v); }\n    void operator+=(const mint &a) { v = (v + a.v) % MOD; }\n    void operator+=(const ll a) { v = mod(v + a % MOD); }\n    void operator+=(const signed a) { v = mod(v + a % MOD); }\n    friend void operator+=(ll &a, const mint &b) { a = mod(a % MOD + b.v); }\n    mint operator-(const mint &a) { return mint(v - a.v); }\n    mint operator-(const ll a) { return mint(v - a % MOD); }\n    mint operator-(const signed a) { return mint(v - a % MOD); }\n    friend mint operator-(const ll a, const mint &b) { return mint(a % MOD - b.v); }\n    void operator-=(const mint &a) { v = mod(v - a.v); }\n    void operator-=(const ll a) { v = mod(v - a % MOD); }\n    void operator-=(const signed a) { v = mod(v - a % MOD); }\n    friend void operator-=(ll &a, const mint &b) { a = mod(a % MOD - b.v); }\n    mint operator*(const mint &a) { return mint(v * a.v); }\n    mint operator*(const ll a) { return mint(v * (a % MOD)); }\n    mint operator*(const signed a) { return mint(v * (a % MOD)); }\n    friend mint operator*(const ll a, const mint &b) { return mint(a % MOD * b.v); }\n    void operator*=(const mint &a) { v = (v * a.v) % MOD; }\n    void operator*=(const ll a) { v = mod(v * (a % MOD)); }\n    void operator*=(const signed a) { v = mod(v * (a % MOD)); }\n    friend void operator*=(ll &a, const mint &b) { a = mod(a % MOD * b.v); }\n    mint operator/(const mint &a);\n    mint operator/(const ll a);\n    mint operator/(const signed a);\n    friend mint operator/(const ll a, const mint &b);\n    void operator/=(const mint &a);\n    void operator/=(const ll a);\n    void operator/=(const signed a);\n    friend void operator/=(ll &a, const mint &b);\n    mint operator^(const mint &a) { return mpow(v, a.v); };\n    mint operator^(const ll a) { return mpow(v, a); };\n    mint operator^(const signed a) { return mpow(v, a); };\n    friend mint operator^(const ll a, const mint &b) { return mpow(a, b.v); };\n    void operator^=(const mint &a) { v = mpow(v, a.v); }\n    void operator^=(const ll a) { v = mpow(v, a); }\n    void operator^=(const signed a) { v = mpow(v, a); }\n    //単項演算子\n    mint operator+() { return *this; }\n    mint operator++() {\n        v++;\n        return *this;\n    }\n    mint operator++(signed d) {\n        mint res = *this;\n        v++;\n        return res;\n    }\n    mint operator-() { return operator*(-1); }\n    mint operator--() {\n        v++;\n        return *this;\n    }\n    void operator--(signed d) {\n        mint res = *this;\n        v++;\n    }\n    bool operator==(mint &a) { return v == a.v; }\n    bool operator==(signed a) { return v == a; }\n    friend bool operator==(signed a, mint &b) { return a == b.v; }\n    bool operator!=(mint &a) { return v != a.v; }\n    bool operator!=(signed a) { return v != a; }\n    friend bool operator!=(signed a, mint &b) { return a != b.v; }\n    operator int() { return v; }\n};\nconst int setModMax = 510000;\nmint fac[setModMax], finv[setModMax], inv[setModMax];\nvoid setMod() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < setModMax; i++) {\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n\nmint minv(ll a) {\n    if (fac[0] == 0)setMod();\n    if (a < setModMax) return inv[a];\n    a %= MOD;\n    ll b = MOD, x = 1, y = 0;\n    while (b) {\n        ll t = a / b;\n        a -= t * b;\n        swap(a, b);\n        x -= t * y;\n        swap(x, y);\n    }\n    return (x % MOD + MOD) % MOD;\n}\nmint mint::operator/(const mint &a) { return mint(v * minv(a.v)); }\nmint mint::operator/(const ll a) { return mint(v * minv(a)); }\nmint mint::operator/(const signed a) { return mint(v * minv(a)); }\nmint operator/(const ll a, const mint &b) { return mint(a % MOD * minv(b.v)); }\nvoid mint::operator/=(const mint &a) { v = (v * minv(a.v)) % MOD; }\nvoid mint::operator/=(const ll a) { v = mod(v * minv(a)); }\nvoid mint::operator/=(const signed a) { v = mod(v * minv(a)); }\nvoid operator/=(ll &a, const mint &b) { a = mint::mod(a % MOD * minv(b.v)); }\nusing vm=vector<mint>;\n#define vvm(a, b, c) vec<vm> a(b,vm(c))\nbool isPrime[4010101];\nvi primes;\n\nvoid setPrime() {\n    fill(isPrime, true);\n    int len = sizeof(isPrime) / sizeof(isPrime[0]);\n    isPrime[0] = isPrime[1] = false;\n    for (int i = 2; i <= sqrt(len) + 5; ++i) {\n        if (!isPrime[i])continue;\n        for (int j = 2; i * j < len; ++j) {\n            isPrime[i * j] = false;\n        }\n    }\n    rep(i, len)if (isPrime[i])primes.pb(i);\n}\n\nmint com(ll n, ll r) {\n    if (n < r || n < 0 || r < 0)return 0;\n    if (fac[0] == 0)setMod();\n    return fac[n] * (finv[r] * finv[n - r] % MOD) % MOD;\n}\n\n//便利関数\nvoid ole() {\n    string a = \"a\";\n    rep(i, 30)a += a;\n    rep(i, 1 << 17)cout << a << endl;\n    cout << \"OLE 出力長制限超過\" << endl;\n    exit(0);\n}\nvoid tle() { while (inf)cout << inf << endl; }\nll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\nll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\nbool equal(double a, double b) { return fabs(a - b) < eps; }\nll reverse(ll a) {\n    ll res = 0;\n    while (a) {\n        res *= 10;\n        res += a % 10;\n        a /= 10;\n    }\n    return res;\n}\nll ceil(ll a, ll b) {\n    if (b == 0) {\n        ole();\n        return -1;\n    } else return (a + b - 1) / b;\n}\nll sqrt(ll a) {\n    if (a < 0)ole();\n    ll res = (ll) std::sqrt(a);\n    while (res * res < a)res++;\n    return res;\n}\ndouble log(double e, double x) { return log(x) / log(e); }\nll sig(ll t) { return (1 + t) * t / 2; }\nll sig(ll s, ll t) { return (s + t) * (t - s + 1) / 2; }\n\nvi divisors(int v) {\n    vi res;\n    for (int i = 1; i <= sqrt(v); ++i) {\n        if (v % i == 0) {\n            res.pb(i);\n            if (i != v / i)res.pb(v / i);\n        }\n    }\n    return res;\n}\n\nvi factorization(int v) {\n    int tv = v;\n    vi res;\n    if (!isPrime[2])setPrime();\n    for (auto &&p :primes) {\n        if (v % p == 0)res.push_back(p);\n        while (v % p == 0) {\n            v /= p;\n        }\n        if (v == 1 || p * p > tv)break;\n    }\n    if (v > 1)res.pb(v);\n    return res;\n}\n\nunordered_map<int, int> factorizationMap(int v) {\n    int tv = v;\n    unordered_map<int, int> res;\n    if (!isPrime[2])setPrime();\n    for (auto &&p :primes) {\n        while (v % p == 0) {\n            res[p]++;\n            v /= p;\n        }\n        if (v == 1 || p * p > tv)break;\n    }\n    if (v > 1)res[v]++;\n    return res;\n}\nint get(int a, int keta) { return (a / (int) pow(10, keta)) % 10; }\nint keta(int v) {\n    int cou = 0;\n    while (v) { cou++, v %= 10; }\n    return cou;\n}\n\ntemplate<class T> void imo(vector<T> &v) {\n    int n = v.size();\n    rep(i, n - 1)v[i + 1] += v[i];\n}\n\n//変換系\ntemplate<class T, class U> vector<U> keys(map<T, U> a) {\n    vector<U> res;\n    for (auto &&k :a)res.pb(k.F);\n    return res;\n}\n\ntemplate<class T, class U> vector<U> keys(umap<T, U> a) {\n    vector<U> res;\n    for (auto &&k :a)res.pb(k.F);\n    return res;\n}\n\ntemplate<class T, class U> vector<T> values(map<T, U> a) {\n    vector<T> res;\n    for (auto &&k :a)res.pb(k.S);\n    return res;\n}\n\ntemplate<class T, class U> vector<T> values(umap<T, U> a) {\n    vector<T> res;\n    for (auto &&k :a)res.pb(k.S);\n    return res;\n}\n\nvi list(int a) {\n    vi res;\n    while (a) {\n        res.insert(res.begin(), a % 10);\n        a /= 10;\n    }\n    return res;\n}\n\ntemplate<class T, class U> bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T, class U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> T min(T a, signed b) {\n    return a < b ? a : b;\n}\n\ntemplate<class T> T max(T a, signed b) {\n    return a < b ? b : a;\n}\n\ntemplate<class T> T min(vector<T> a) {\n    return *min_element(all(a));\n}\n\ntemplate<class T> T max(vector<T> a) {\n    return *max_element(all(a));\n}\n\ntemplate<class T> T min(T a[]) {\n    T res = a[0];\n    rep(i, arsz(a))chmin(res, a[i]);\n    return res;\n}\n\ntemplate<class T> T max(T a[]) {\n    T res = a[0];\n    rep(i, arsz(a))chmax(res, a[i]);\n    return res;\n}\ntemplate<class T> T sum(vector<T> &v, int len = -1) {\n    if (len == -1)len = v.size();\n    T res = 0;\n    chmin(len, v.size());\n    rep(i, len)res += v[i];\n    return res;\n}\n\ntemplate<class T> T sum(vector<vector<T>> &v, int h = -1, int w = -1) {\n    if (h == -1)h = v.size();\n    if (w == -1)w = v[0].size();\n    T res = 0;\n    chmin(h, v.size());\n    chmin(w, v[0].size());\n    rep(i, h)rep(j, w)res += v[i][j];\n    return res;\n}\n\nP sump(vp &v, int len = -1) {\n    if (len == -1)len = v.size();\n    P res = {0, 0};\n    chmin(len, v.size());\n    rep(i, len) {\n        res.F += v[i].F;\n        res.S += v[i].S;\n    }\n    return res;\n}\n\n///要素が0の時、返り値は0か1か\ntemplate<class T> T mul(vector<T> &v, int len = -1) {\n    if (len == -1)len = v.size();\n    T res = 1;\n    chmin(len, v.size());\n    rep(i, len)res *= v[i];\n    return res;\n}\nvoid clear(PQ &q) { while (q.size())q.pop(); }\ntemplate<class T> void clear(queue<T> &q) { while (q.size())q.pop(); }\ntemplate<class T> T *negarr(int size) {\n    T *body = (T *) malloc((size * 2 + 1) * sizeof(T));\n    return body + size;\n}\ntemplate<class T> T *negarr2(int h, int w) {\n    double **dummy1 = new double *[2 * h + 1];\n    double *dummy2 = new double[(2 * h + 1) * (2 * w + 1)];\n    dummy1[0] = dummy2 + w;\n    for (int i = 1; i <= 2 * h + 1; i++) {\n        dummy1[i] = dummy1[i - 1] + 2 * w + 1;\n    }\n    double **a = dummy1 + h;\n}\n\ntemplate<class T> vector<T> ruiv(vector<T> &a) {\n    vector<T> res(a.size() + 1);\n    rep(i, a.size())res[i + 1] = res[i] + a[i];\n    return res;\n}\n\ntemplate<class T> vector<T> ruim(vector<T> &a) {\n    vector<T> res(a.size() + 1, 1);\n    rep(i, a.size())res[i + 1] = res[i] * a[i];\n    return res;\n}\n//右から左にかけての半開区間 (-1 n-1]\ntemplate<class T> T *rrui(vector<T> &a) {\n    int len = a.size();\n    T *body = (T *) malloc((len + 1) * sizeof(T));\n    T *res = body + 1;\n    rer(i, len - 1)res[i - 1] = res[i] + a[i];\n    return res;\n}\n//掛け算\ntemplate<class T> T *rruim(vector<T> &a) {\n    int len = a.size();\n    T *body = (T *) malloc((len + 1) * sizeof(T));\n    T *res = body + 1;\n    res[len - 1] = 1;\n    rer(i, len - 1)res[i - 1] = res[i] * a[i];\n    return res;\n}\ntemplate<class T> void plus(vector<T> &a, T v = 1) { for (auto &&u :a)u += v; }\ntemplate<class T> void minu(vector<T> &a, T v = 1) { for (auto &&u :a)u -= v; }\ntemplate<class T> void minus(vector<T> &a, T v = 1) { for (auto &&u :a)u -= v; }\ninline bool inside(int y, int x, int H, int W) { return y >= 0 && x >= 0 && y < H && x < W; }\nll u(ll a) { return a < 0 ? 0 : a; }\n#define MIN(a) numeric_limits<a>::min()\n#define MAX(a) numeric_limits<a>::max()\ntemplate<class T> T min(vector<vector<T>> &a) {\n    T res = MAX(T);\n    rep(i, a.size())chmin(res, *min_element(all(a[i])));\n    return res;\n}\ntemplate<class T> T max(vector<vector<T>> &a) {\n    T res = MIN(T);\n    rep(i, a.size())chmax(res, *max_element(all(a[i])));\n    return res;\n}\nbool bget(ll m, int keta) { return (m >> keta) & 1; }\nint bget(ll m, int keta, int sinsuu) {\n    m /= (ll) pow(sinsuu, keta);\n    return m % sinsuu;\n}\ninline ll bit(int n) { return (1LL << (n)); }\ninline ll bit(int n, int sinsuu) { return (ll) pow(sinsuu, n); }\nint bcou(ll m) { return __builtin_popcount(m & 0xFFFFFFFF) + __builtin_popcount(m >> 32); }\n//初期化は0を渡す\nll nextComb(ll &mask, int n, int r) {\n    if (!mask)return mask = (1LL << r) - 1;\n    ll x = mask & -mask; //最下位の1\n    ll y = mask + x; //連続した下の1を繰り上がらせる\n    ll res = ((mask & ~y) / x >> 1) | y;\n    if (bget(res, n))return mask = 0;\n    else return mask = res;\n}\n\n//n桁以下でビットがr個立っているもののvectorを返す\nvl bitCombList(int n, int r) {\n    vl res;\n    int m = 0;\n    while (nextComb(m, n, r)) {\n        res.pb(m);\n    }\n    return res;\n}\n//大文字小文字を区別する\nint altoiaZ(char c) {\n    if ('A' <= c && c <= 'Z')return c - 'A';\n    return c - 'a' + 26;\n}\nchar itoalaZ(int i) {\n    if (i < 26)return 'A' + i;\n    return 'a' + i - 26;\n}\n//aもAも0を返す 基本小文字\nint altoi(char c) {\n    if ('A' <= c && c <= 'Z')return c - 'A';\n    return c - 'a';\n}\nchar itoal(int i) {\n    return 'a' + i;\n}\nint ctoi(char c) { return c - '0'; }\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\nvoid compress(vi &a) {\n    vi b;\n    int len = a.size();\n    for (int i = 0; i < len; ++i) {\n        b.push_back(a[i]);\n    }\n    sort(b);\n    UNIQUE(b);\n    for (int i = 0; i < len; ++i) {\n        a[i] = lower_bound(all(b), a[i]) - b.begin();\n    }\n}\n\nvoid compress(int a[], int len) {\n    vi b;\n    for (int i = 0; i < len; ++i) {\n        b.push_back(a[i]);\n    }\n    sort(b);\n    UNIQUE(b);\n    for (int i = 0; i < len; ++i) {\n        a[i] = lower_bound(all(b), a[i]) - b.begin();\n    }\n}\n//要素が見つからなかったときに困る\n#define binarySearch(a, v) (binary_search(all(a),v))\n#define lowerIndex(a, v) (lower_bound(all(a),v)-a.begin())\n#define lowerBound(a, v) (*lower_bound(all(a),v))\n#define upperIndex(a, v) (upper_bound(all(a),v)-a.begin())\n#define upperBound(a, v) (*upper_bound(all(a),v))\n#define ans(a) cout<<a<<endl;continue;\n#define poll(a) q.front();q.pop()\n#define dpoll(a) q.front();q.pop_front()\n#define pollLast(a) q.back();q.pop_back()\n#define pollBack(a) q.back();q.pop_back()\ntemplate<class T> inline void fin(T s) { cout << s << endl, exit(0); }\n\ntemplate<class T> struct edge {\n    int from, to;\n    T cost;\n    int id;\n    int type;\n    edge(int f, int t, T c = 1, int id = -1, int ty = -1) : from(f), to(t), cost(c), id(id), type(ty) {}\n    bool operator<(const edge &b) const { return cost < b.cost; }\n    bool operator>(const edge &b) const { return cost > b.cost; }\n};\n\ntemplate<typename T> class graph {\nprotected:\n    vector<bool> _used;\npublic :\n    vector<vector<edge<T>>> g;\n    vector<edge<T>> edges;\n    int n, root = -1;\n    graph(int n) : n(n) { g.resize(n), _used.resize(n); }\n    void clear() { g.clear(), edges.clear(); }\n    void resize(int n) {\n        this->n = n;\n        g.resize(n);\n        _used.resize(n);\n    }\n    int size() { return g.size(); }\n    bool isleaf(int v) {\n        assert(root != -1);\n        return g[v].size() == 1 && g[v][0].from != root;\n    }\n    vector<edge<T> > &operator[](int i) { return g[i]; }\n    virtual void add(int from, int to, T cost, int ty) = 0;\n    virtual bool used(edge<T> &e) = 0;\n    virtual bool used(int id) = 0;\n    virtual void del(edge<T> &e) = 0;\n    virtual void del(int id) = 0;\n};\n\ntemplate<class T=int> class undigraph : public graph<T> {\npublic:\n    using graph<T>::g;\n    using graph<T>::n;\n    using graph<T>::edges;\n    using graph<T>::_used;\n    undigraph(int n) : graph<T>(n) {\n    }\n    void add(int f, int t, T cost = 1, int ty = -1) {\n        if (!(0 <= f && f < n && 0 <= t && t < n))ole();\n        int id = edges.size();\n        g[f].emplace_back(f, t, cost, id, ty);\n        g[t].emplace_back(t, f, cost, id + 1, ty);\n        edges.emplace_back(f, t, cost, id, ty);\n        edges.emplace_back(t, f, cost, id + 1, ty);\n    }\n    void add(edge<T> &e) {\n        int f = e.from, t = e.to, ty = e.type;\n        T cost = e.cost;\n        add(f, t, cost, ty);\n    }\n    bool used(edge<T> &e) { return _used[e.id]; }\n    bool used(int id) { return _used[id]; }\n    void del(edge<T> &e) { _used[e.id] = _used[e.id ^ 1] = 1; }\n    void del(int id) { _used[id] = _used[id ^ 1] = 1; }\n};\n\ntemplate<typename T =ll> class digraph : public graph<T> {\npublic:\n    using graph<T>::g;\n    using graph<T>::n;\n    using graph<T>::edges;\n    using graph<T>::_used;\n\n    digraph(int n) : graph<T>(n) {}\n    void add(int f, int t, T cost = 1, int ty = -1) {\n        if (!(0 <= f && f < n && 0 <= t && t < n))ole();\n        int id = edges.size();\n        g[f].emplace_back(f, t, cost, ty, id);\n        edges.emplace_back(f, t, cost, ty, id);\n    }\n    bool used(edge<T> &e) { return _used[e.id]; }\n    bool used(int id) { return _used[id]; }\n    void del(edge<T> &e) { _used[e.id] = _used[e.id ^ 1] = 1; }\n    void del(int id) { _used[id] = _used[id ^ 1] = 1; }\n};\n\ntemplate<class T> bool nibu(const graph<T> &g) {\n    UnionFind uf(g.n * 2);\n    for (auto &&e :g.edges)uf.unite(e.f, e.t + g.n), uf.unite(e.f + g.n, e.t);\n    return !uf.same(0, g.n);\n}\n\ntemplate<class T> vector<T> &dijkstra(const graph<T> &g, int s) {\n    if (!(0 <= s && s < g.n))ole();\n    T initValue = MAX(T);\n    vector<T> dis(g.n, initValue);\n    priority_queue<pair<T, int>, vector<pair<T, int>>, greater<pair<T, int>>> q;\n    dis[s] = 0;\n    q.emplace(0, s);\n    while (q.size()) {\n        T nowc = q.top().F;\n        int i = q.top().S;\n        q.pop();\n        if (dis[i] != nowc)continue;\n        for (auto &&e  : g.g[i]) {\n            int to = e.to;\n            T cost = nowc + e.cost;\n            if (dis[to] > cost) {\n                dis[to] = cost;\n                q.emplace(dis[to], to);\n            }\n        }\n    }\n    //たどり着かないなら-1\n    for (auto &&d :dis) if (d == initValue)d = -1;\n    return dis;\n}\n\n//機能拡張\ntemplate<typename T> void remove(vector<T> &v, unsigned int i) { v.erase(v.begin() + i); }\n\ntemplate<typename T> void remove(vector<T> &v, unsigned int s, unsigned int e) {\n    v.erase(v.begin() + s, v.begin() + e);\n}\n\ntemplate<typename T> void removen(vector<T> &v, unsigned int s, unsigned int n) {\n    v.erase(v.begin() + s, v.begin() + s + n);\n}\n\ntemplate<typename T> void erase(vector<T> &v, unsigned int i) { v.erase(v.begin() + i); }\n\ntemplate<typename T> void erase(vector<T> &v, unsigned int s, unsigned int e) {\n    v.erase(v.begin() + s, v.begin() + e);\n}\n\ntemplate<typename T> void erasen(vector<T> &v, unsigned int s, unsigned int n) {\n    v.erase(v.begin() + s, v.begin() + s + n);\n}\n\ntemplate<typename T> void insert(vector<T> &v, unsigned int i, T t) { v.insert(v.begin() + i, t); }\n\ntemplate<typename T> void insert(vector<T> &v, unsigned int i, vector<T> list) {\n    for (auto &&va :list)v.insert(v.begin() + i++, va);\n}\n\ntemplate<typename T> void insert(vector<T> &v, unsigned int i, initializer_list<T> list) {\n    for (auto &&va :list)v.insert(v.begin() + i++, va);\n}\n\ntemplate<typename T> void insert(set<T> &v, vector<T> list) {\n    for (auto &&va :list)v.insert(va);\n}\n\ntemplate<typename T> void insert(set<T> &v, initializer_list<T> list) {\n    for (auto &&va :list)v.insert(va);\n}\n\nint mod(int a, int m) {\n    return (a % m + m) % m;\n}\n\nll ma = numeric_limits<ll>::min();\nll mi = numeric_limits<ll>::max();\n\n//閉路がなければtrue\nbool topo(vi &res, digraph<int> &g) {\n    int n = g.g.size();\n    vi nyu(n);\n    rep(i, n)for (auto &&e :g[i])nyu[e.to]++;\n    queue<int> st;\n    rep(i, n)if (nyu[i] == 0)st.push(i);\n    while (st.size()) {\n        int v = st.front();\n        st.pop();\n        res.pb(v);\n        fora(e, g[v]) if (--nyu[e.to] == 0)st.push(e.to);\n    }\n    return res.size() == n;\n}\n\n//辞書順最小トポロジカルソート\nbool topos(vi &res, digraph<int> &g) {\n    int n = g.g.size();\n    vi nyu(n);\n    rep(i, n)for (auto &&e :g[i])nyu[e.to]++;\n    //小さい順\n    priority_queue<int, vector<int>, greater<int> > q;\n    rep(i, n)if (nyu[i] == 0)q.push(i);\n    while (q.size()) {\n        int i = q.top();\n        q.pop();\n        res.pb(i);\n        fora(e, g[i])if (--nyu[e.to] == 0)q.push(e.to);\n    }\n    return res.size() == n;\n}\n\nvector<string> split(const string a, const char deli) {\n    string b = a + deli;\n    int l = 0, r = 0, n = b.size();\n    vector<string> res;\n    rep(i, n) {\n        if (b[i] == deli) {\n            r = i;\n            if (l < r)res.push_back(b.substr(l, r - l));\n            l = i + 1;\n        }\n    }\n    return res;\n}\n\nvector<string> split(const string a, const string deli) {\n    string b = a + deli;\n    int l = 0, r = 0, n = b.size(), dn = deli.size();\n    vector<string> res;\n    rep(i, n) {\n        if (i + dn <= n && b.substr(i, i + dn) == deli) {\n            r = i;\n            if (l < r)res.push_back(b.substr(l, r - l));\n            i += dn - 1;\n            l = i + 1;\n        }\n    }\n    return res;\n}\n\nint n, k, m, h, w, x, y, q;\nint cou;\nvi a, b, c;\nv3i(dp, 5000, 5001, 2);//コンピューターしかないか\nvvi(sub, 5050, 2);\nundigraph<> g(0);\nvi es(5050);\n\nvoid ds(int i, int p) {\n    forg(gi, g[i])if (t != p)ds(t, i);\n    int sum = 0;\n    dp[i][0][a[i] < 0] = a[i];\n    forg(gi, g[i]) {\n            if (t == p)continue;\n            rep(ci, sum + 1) {\n                rep(ct, es[t] + 1) {\n                    rep(ki, 2) {\n                        rep(kt, 2) {\n                            //繋ぐ\n                            if (dp[i][ci][ki] < linf && dp[t][ct][kt] < linf)\n                                chmin(sub[ci + ct][ki || kt], dp[i][ci][ki] + dp[t][ct][kt]);\n                            //切る\n                            if (dp[t][ct][kt] < 0 || (!kt && dp[t][ct][kt] != linf))\n                                chmin(sub[ci + ct + 1][ki], dp[i][ci][ki]);\n                        }\n                    }\n                }\n            }\n            sum += es[t] + 1;\n            rep(j, sum + 1)\n                rep(k, 2) {\n                    dp[i][j][k] = sub[j][k];\n                    sub[j][k] = linf;\n\n                }\n        }\n    es[i] = sum;\n}\nsigned main() {\n    cin >> n;\n    addn(a, n);\n    g.resize(n);\n    rep(i, n - 1) {\n        int f, s;\n        cin >> f >> s;\n        --f, --s;\n        g.add(f, s);\n    }\n    fill(dp, linf);\n    fill(sub, linf);\n    ds(0, -1);\n    rep(c, n)rep(k, 2) {\n            if (k) {\n                if (dp[0][c][k] < 0)fin(c);\n            } else if (dp[0][c][k] != linf)fin(c);\n        }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define all(x) (x).begin(),(x).end()\n#define ln '\\n'\nconstexpr long long MOD = 1000000007LL;\n//constexpr long long MOD = 998244353LL;\ntypedef long long ll;\ntypedef unsigned long long ull; \ntypedef pair<int, int> pii;\ntypedef pair<long long, long long> pll;\ntemplate<class T, class U> inline bool chmax(T &a, U b) { if (a < b) { a = b; return true;} return false; }\ntemplate<class T, class U> inline bool chmin(T &a, U b) { if (a > b) { a = b; return true;} return false; }\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nvector<int> G[5050];\nll A[5050];\nll dp1[5050][5050]; //コンピュータあり\nll dp2[5050][5050]; //コンピュータなし\nint sub[5050];\n\nvoid dfs(int v, int pv) {\n    vector<ll> arr1(5050,1e18),arr2(5050,1e18);\n    sub[v] = 1;\n    if (A[v] < 0) arr1[0] = A[v];\n    else arr2[0] = A[v];\n    for (auto nv : G[v]) {\n        if (nv == pv) continue;\n        dfs(nv,v);\n        vector<ll> ch1(5050,1e18),ch2(5050,1e18);\n        rep(i,sub[v]) {\n            rep(j,sub[nv]) {\n                chmin(ch1[i+j],arr1[i]+dp1[nv][j]);\n                if (dp1[nv][j] < 0) chmin(ch1[i+j+1],arr1[i]);\n                chmin(ch1[i+j],arr1[i]+dp2[nv][j]);\n                if (dp2[nv][j] != 1e18) chmin(ch1[i+j+1],arr1[i]);\n\n                if (arr2[i] != 1e18) chmin(ch1[i+j],arr2[i]+dp1[nv][j]);\n                if (dp1[nv][j] < 0) chmin(ch2[i+j+1],arr2[i]);\n                chmin(ch2[i+j],arr2[i]+dp2[nv][j]);\n                if (dp2[nv][j] != 1e18) chmin(ch2[i+j+1],arr2[i]);\n            }\n        }\n        swap(arr1,ch1); swap(arr2,ch2);\n        sub[v] += sub[nv];\n    }\n\n    rep(i,sub[v]) {\n        dp1[v][i] = arr1[i];\n        dp2[v][i] = arr2[i];\n    }\n    return;\n}\nint main() {\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n    int N; cin >> N;\n    rep(i,N) cin >> A[i];\n    rep(i,N-1) {\n        int u,v; cin >> u >> v;\n        --u; --v;\n        G[u].emplace_back(v);\n        G[v].emplace_back(u);\n    }\n    rep(i,N) rep(j,N) dp1[i][j] = dp2[i][j] = 1e18; \n    dfs(0,-1);\n    int ans = 5000;\n    rep(i,N) {\n        if (dp1[0][i] < 0) chmin(ans,i);\n        if (dp2[0][i] != 1e18) chmin(ans,i);\n    }\n\n    cout << ans << ln;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll MOD = 1e9+7;\nconst ll INF = 1e18;\n\nsigned main()\n{\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for(auto& y : a)\n        cin >> y;\n    vector<int> u(n - 1);\n    vector<int> v(n - 1);\n    for(int i = 0; i < n - 1; ++i){\n        cin >> u[i] >> v[i];\n        --u[i];\n        --v[i];\n    }\n    vector<vector<int>> edges(n);\n    for(int i = 0; i < n - 1; ++i){\n        edges[u[i]].push_back(v[i]);\n        edges[v[i]].push_back(u[i]);\n    }\n    vector<vector<vector<ll>>> dp(n, vector<vector<ll>>(n + 1, vector<ll>(2, INF)));\n    vector<int> size(n, 1);\n\n    bitset<5000> flag;\n    function<void(int)> siz = [&](int x){\n        for(auto& y : edges[x])\n            if(!flag[y]){\n                flag[y] = 1;\n                siz(y);\n                size[x] += size[y];\n            }\n    };\n    flag[0] = 1;\n    siz(0);\n    flag.reset();\n\n    function<void(int)> f = [&](int x){\n        dp[x][0][0] = a[x];\n        if(a[x] > 0)\n            dp[x][0][1] = a[x];\n\n        int sizesum = 0;\n        for(auto& y : edges[x]){\n            if(flag[y])\n                continue;\n            flag[y] = 1;\n            f(y);\n\n            vector<vector<ll>> next(n + 1, vector<ll>(2, INF));\n\n            for(int i = 0; i <= sizesum; ++i){\n                for(int j = 0; j < size[y]; ++j){\n                    next[i + j][0] = min(next[i + j][0], dp[x][i][0] + dp[y][j][0]);\n                    next[i + j][0] = min(next[i + j][0], dp[x][i][0] + dp[y][j][1]);\n                    next[i + j][0] = min(next[i + j][0], dp[x][i][1] + dp[y][j][0]);\n                    next[i + j][0] = min(next[i + j][0], dp[x][i][1] + dp[y][j][1]);\n                    if(a[x] > 0 && dp[y][j][1] != INF)\n                        next[i + j][1] = min(next[i + j][1], dp[x][i][1] + dp[y][j][1]);\n                    // 分断が可能なら\n                    if(dp[y][j][0] < 0 || dp[y][j][1] != INF){\n                        next[i + j + 1][0] = min(next[i + j + 1][0], dp[x][i][0]);\n                        if(a[x] > 0){\n                            next[i + j + 1][1] = min(next[i + j + 1][1], dp[x][i][1]);\n                        }\n                    }\n                }\n            }\n            dp[x] = move(next);\n            sizesum += size[y];\n        }\n    };\n    flag[0] = 1;\n    f(0);\n    int ans = 1e9;\n    for(int j = 0; j <= n; ++j){\n        if(dp[0][j][0] < 0)\n            ans = min(ans, j);\n        if(dp[0][j][1] != INF)\n            ans = min(ans, j);\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n#define reps(i, n) for (int i = 1; i <= (int) (n); i++)\n#define all(x) (x).begin(), (x).end()\n#define uniq(x) (x).erase(unique(all(x)), (x).end())\n#define bit(n) (1LL << (n))\n#define cdiv(a, b) (((a) - 1) / (b) + 1)\n#define dump(x) cerr << #x \" = \" << (x) << endl\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing pint = pair<int, int>;\nusing vpint = vector<pint>;\ntemplate<typename T> using priority_queue_rev = priority_queue<T, vector<T>, greater<T>>;\nconstexpr double PI = 3.1415926535897932384626433832795028;\nconstexpr int DY[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nconstexpr int DX[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nint gcd(int a, int b) {\n    while (b) { swap(a %= b, b); }\n    return a;\n}\nint lcm(int a, int b) { return a / gcd(a, b) * b; }\nint sgn(int x) { return (x > 0) - (x < 0); }\ntemplate<typename T> void fin(T mes) {\n    cout << mes << endl;\n    exit(0);\n}\ntemplate<typename T, typename U> bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &rhs) {\n    os << \"(\" << rhs.first << \", \" << rhs.second << \")\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\nstruct setup {\n    static constexpr int PREC = 20;\n\n    setup() {\n        cout << fixed << setprecision(PREC);\n        cerr << fixed << setprecision(PREC);\n    };\n} setup;\n\nstruct union_find_tree {\n    std::vector<int> par, size, val;\n    union_find_tree() {}\n    union_find_tree(int n, vint val) : par(n), size(n), val(val) {\n        for (int i = 0; i < n; i++) {\n            par[i] = i;\n            size[i] = 1;\n        }\n    }\n    int get_root(int i) {\n        if (par[i] == i) { return i; }\n        else { return par[i] = get_root(par[i]); }\n    }\n    void unite(int i, int j) {\n        if ((i = get_root(i)) == (j = get_root(j))) { return; }\n        if (size[i] < size[j]) { std::swap(i, j); }\n        par[j] = i;\n        size[i] += size[j];\n        val[i] += val[j];\n    }\n    bool are_same(int i, int j) { return get_root(i) == get_root(j); }\n    int get_size(int i) { return size[get_root(i)]; }\n    int get_val(int i) { return val[get_root(i)]; }\n};\n\nint N;\nint U[5500], V[5500];\nvint G[5500];\nunion_find_tree uf;\npair<vint, int> dfs(int cur, int par) {\n    vint x = {uf.get_val(cur)};\n    if (uf.get_val(cur) < 0) {\n        //コンピュータ\n        for (int to:G[cur]) {\n            if (to == par) { continue; }\n            pair<vint, int> tmp = dfs(to, cur);\n            vint nxt = tmp.first;\n            int cut = tmp.second;\n            vint y(x.size() + nxt.size(), LLONG_MAX);\n            rep(i, x.size()) { y[i + cut + 1] = x[i]; }\n            rep(i, x.size()) {\n                rep(j, nxt.size()) {\n                    chmin(y[i + j], x[i] + nxt[j]);\n                    if (nxt[j] < 0) { chmin(y[i + j + 1], x[i]); }\n                }\n            }\n            x = y;\n        }\n        return {x, -1};\n    }\n    if (uf.get_val(cur) > 0) {\n        //バッテリー\n        int cut = 0;\n        for (int to:G[cur]) {\n            if (to == par) { continue; }\n            vint nxt = dfs(to, cur).first;\n            vint y(x.size() + nxt.size(), LLONG_MAX);\n            rep(i, x.size()) {\n                rep(j, nxt.size()) {\n                    chmin(y[i + j], x[i] + nxt[j]);\n                    if (nxt[j] < 0) { chmin(y[i + j + 1], x[i]); }\n                }\n            }\n            x = y;\n            int pl = 0;\n            for (int i = nxt.size(); i >= 0; i--) { if (nxt[i] < 0) { pl = i; }}\n            cut += pl + 1;\n        }\n        return {x, cut};\n    }\n    return {{}, 0};\n}\n\nsigned main() {\n    cin >> N;\n    vint val(N);\n    rep(i, N) { cin >> val[i]; }\n    uf = union_find_tree(N, val);\n    rep(i, N - 1) {\n        cin >> U[i] >> V[i];\n        U[i]--, V[i]--;\n        if (uf.get_val(U[i]) * uf.get_val(V[i]) > 0) { uf.unite(U[i], V[i]); }\n    }\n    rep(i, N - 1) {\n        int u = uf.get_root(U[i]), v = uf.get_root(V[i]);\n        if (u != v) { G[u].push_back(v), G[v].push_back(u); }\n    }\n    pair<vint, int> res = dfs(uf.get_root(0), -1);\n    int ans = N;\n    if (uf.get_val(0) > 0) { ans = res.second; }\n    rep(i, res.first.size()) { if (res.first[i] < 0) { chmin(ans, i); }}\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 100000000000000;\n\nll n;\nvector<ll> a(5000);\nvector<vector<ll> > adj(5000, vector<ll>());\nvector<vector<vector<ll> > > dp(5000, vector<vector<ll> >(5000, vector<ll>(2, INF)));\nvector<ll> edges(5000, 0);\n\nvoid chmin(ll& before, ll after) {\n\tif (before > after) before = after;\n\treturn;\n}\n\nll dfs_pre(ll x, ll p) {\n\tif (x != 0 && adj[x].size() == 1) return 0;\n\tfor (auto v : adj[x]) {\n\t\tif (v == p) continue;\n\t\telse edges[x] += dfs_pre(v, x) + 1;\n\t}\n\treturn edges[x];\n}\n\nvoid dfs(ll x, ll p) {\n\tfor (auto v : adj[x]) {\n\t\tif (v != p) dfs(v, x);\n\t}\n\n\tvector<vector<vector<ll> > > sub(n, vector<vector<ll> >(n, vector<ll>(2, INF)));\n\tsub[0][0][1] = a[x];\n\tif (a[x] > 0) sub[0][0][0] = a[x];\n\tll i = 0;\n\tll e_cnt = 0;\n\n\tfor (auto v : adj[x]) {\n\t\tif (v == p) continue;\n\t\tfor (ll j1 = 0; j1 < e_cnt+1; ++j1)\n\t\t{\n\t\t\tfor (ll j2 = 0; j2 < edges[v]+1; ++j2)\n\t\t\t{\n\t\t\t\tchmin(sub[i+1][j1+j2][1], sub[i][j1][0] + dp[v][j2][1]);\n\t\t\t\tchmin(sub[i+1][j1+j2][1], sub[i][j1][1] + dp[v][j2][0]);\n\t\t\t\tchmin(sub[i+1][j1+j2][1], sub[i][j1][1] + dp[v][j2][1]);\n\t\t\t\tif (a[x] > 0) chmin(sub[i+1][j1+j2][0], sub[i][j1][0] + dp[v][j2][0]);\n\n\t\t\t\tif (dp[v][j2][0] < INF/2 || dp[v][j2][1] < 0) {\n\t\t\t\t\tchmin(sub[i+1][j1+j2+1][1], sub[i][j1][1]);\n\t\t\t\t\tif (a[x] > 0) chmin(sub[i+1][j1+j2+1][0], sub[i][j1][0]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\te_cnt += edges[v] + 1;\n\t\ti++;\n\t}\n\tfor (ll j = 0; j < edges[x]+1; ++j)\n\t{\n\t\tdp[x][j][0] = sub[i][j][0];\n\t\tdp[x][j][1] = sub[i][j][1];\n\t}\n\n\treturn;\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i) cin >> a[i];\n\tfor (int i = 0; i < n-1; ++i)\n\t{\n\t\tll u, v; cin >> u >> v;\n\t\tadj[u-1].push_back(v-1);\n\t\tadj[v-1].push_back(u-1);\n\t}\n\n\tdfs_pre(0, -1);\n\n\tdfs(0, -1);\n\n\tll ans;\n\tfor (ll j = 0; j < n; ++j)\n\t{\n\t\tif (dp[0][j][0] < INF/2 || dp[0][j][1] < 0) {\n\t\t\tans = j;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <cstdio>\n#include <iomanip>\n#include <fstream>\n#include <cassert>\n#include <cstring>\n#include <unordered_set>\n#include <unordered_map>\n#include <numeric>\n#include <ctime>\n#include <bitset>\n#include <complex>\n#include <chrono>\n#include <random>\n#include <functional>\n\nusing namespace std;\n\n#define int long long\n\nconst int N = 5004;\nconst int INF = 1e18 + 239;\n\nint dp[2][N][N];\nint cdp[2][N][N];\n\nint a[N];\nint sz[N];\nvector<int> g[N];\n\n//dp[0] - pos\n//dp[1] - neg\n\nvoid dfs(int cur, int P) {\n\tsz[cur] = 1;\n\tvector<int> sons;\n\tfor (auto t : g[cur]) {\n\t\tif (t != P) {\n\t\t\tdfs(t, cur);\n\t\t\tsz[cur] += sz[t];\n\t\t\tsons.push_back(t);\n\t\t}\n\t}\n\tfor (int i = 0; i <= (int)sons.size(); i++) {\n\t\tfor (int j = 0; j < sz[cur]; j++) {\n\t\t\tcdp[0][i][j] = INF;\n\t\t\tcdp[1][i][j] = INF;\n\t\t}\n\t}\n\tif (a[cur] > 0) {\n\t\tcdp[0][0][0] = a[cur];\n\t\tcdp[1][0][0] = a[cur];\n\t} else {\n\t\tcdp[1][0][0] = a[cur];\n\t}\n\tint psz = 1;\n\tfor (int i = 0; i < (int)sons.size(); i++) {\n\t\tint son = sons[i];\n\t\tfor (int p = 0; p < psz; p++) {\n\t\t\t//0\n\t\t\t{\n\t\t\t\tfor (int n = 0; n < sz[son]; n++) {\n\t\t\t\t\tif (dp[0][son][n] != INF) {\n\t\t\t\t\t\tcdp[0][i + 1][p + n] = min(cdp[0][i + 1][p + n], cdp[0][i][p] + dp[0][son][n]);\n\t\t\t\t\t}\n\t\t\t\t\tif (dp[1][son][n] < 0 || dp[0][son][n] != INF) {\n\t\t\t\t\t\tcdp[0][i + 1][p + n + 1] = min(cdp[0][i + 1][p + n + 1], cdp[0][i][p]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//1\n\t\t\t{\n\t\t\t\tfor (int n = 0; n < sz[son]; n++) {\n\t\t\t\t\tcdp[1][i + 1][p + n] = min(cdp[1][i + 1][p + n], cdp[1][i][p] + dp[1][son][n]);\n\t\t\t\t\tif (dp[0][son][n] != INF) {\n\t\t\t\t\t\tcdp[1][i + 1][p + n] = min(cdp[1][i + 1][p + n], cdp[1][i][p] + dp[0][son][n]);\n\t\t\t\t\t}\n\t\t\t\t\tif (dp[1][son][n] < 0 || dp[0][son][n] != INF) {\n\t\t\t\t\t\tcdp[1][i + 1][p + n + 1] = min(cdp[1][i + 1][p + n + 1], cdp[1][i][p]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpsz += sz[son];\n\t}\n\tfor (int i = 0; i < sz[cur]; i++) {\n\t\tdp[0][cur][i] = cdp[0][sons.size()][i];\n\t\tdp[1][cur][i] = cdp[1][sons.size()][i];\n\t}\n}\n\nsigned main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t}\n\tfor (int i = 0; i + 1 < n; i++) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--;\n\t\tv--;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\tdfs(0, -1);\n\tint ans = n;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (dp[0][0][i] != INF) {\n\t\t\tans = min(ans, i);\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tif (dp[1][0][i] < 0) {\n\t\t\tans = min(ans, i);\n\t\t}\n\t}\n\tcout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(ll (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(WW,n)cerr << v[WW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,WW,HH) {REP(W_,WW){REP(H_,HH)cerr << v[W_][H_] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 10000LL\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nll n;\nll mp[5555];\nvector<vector<int>> v(5555);\nll dp1[5555][5555];\nll dp2[5555][5555];\nll tmp1[5555];\nll tmp2[5555];\nll subNum[5555];\n\nvoid dfs(int node, int pre){\n\t//cout << \"in dfs \" << node << \" \" << pre << endl;\n\tsubNum[node] = 1;\n\t\n\tif(mp[node] > 0)dp1[node][0] = mp[node];\n\tdp2[node][0] = mp[node];\n\t\n\tREP(i,v[node].size())if(v[node][i] != pre){\n\t\tint now = v[node][i];\n\t\tdfs(now, node);\n\t\t\n\t\tREP(j,subNum[node] + subNum[now] + 1){\n\t\t\ttmp1[j] = LLINF;\n\t\t\ttmp2[j] = LLINF;\n\t\t}\n\t\t//cout << \"  \" << now << \" \" << subNum[node] << \" \" << subNum[now] << endl;\n\t\tREP(j,subNum[node]){\n\t\t\tREP(k,subNum[now]){\n\t\t\t\tif(dp1[now][k] != LLINF || dp2[now][k] < 0){\n\t\t\t\t\t//cout << \"    \" << j << \" \" << now << \" \" << k << \" \" << dp1[node][k] << endl;\n\t\t\t\t\ttmp1[j+k+1] = min(tmp1[j+k+1],dp1[node][j]);\n\t\t\t\t\ttmp2[j+k+1] = min(tmp2[j+k+1],dp2[node][j]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ttmp1[j+k] = min(tmp1[j+k],dp1[node][j] + dp1[now][k]);\n\t\t\t\ttmp2[j+k] = min(tmp2[j+k],dp1[node][j] + dp2[now][k]);\n\t\t\t\ttmp2[j+k] = min(tmp2[j+k],dp2[node][j] + dp1[now][k]);\n\t\t\t\ttmp2[j+k] = min(tmp2[j+k],dp2[node][j] + dp2[now][k]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tsubNum[node] += subNum[now];\n\t\tREP(j,subNum[node]){\n\t\t\tdp1[node][j] = tmp1[j];\n\t\t\tdp2[node][j] = tmp2[j];\n\t\t}\n\t}\n\t//cout << \"out dfs \" << node << \" \" << pre << endl;\n}\n\nint main(){\n\t\n\tREP(i,5555){\n\t\tREP(j,5555){\n\t\t\tdp1[i][j] = LLINF;\n\t\t\tdp2[i][j] = LLINF;\n\t\t}\n\t}\t\n\t\n\tcin >> n;\n\tREP(i,n)cin >> mp[i];\n\tREP(i,n-1){\n\t\tint a, b;cin >> a >> b;\n\t\ta--;b--;\n\t\tv[a].PB(b);\n\t\tv[b].PB(a);\n\t}\n\t\n\tdfs(0, -1);\n\t\n\t//SHOW2d(dp1,n+1,n+1);\n\t//SHOW2d(dp2,n+1,n+1);\n\t\n\tfor(int i = 0;i <= n;i++){\n\t\tif(dp1[0][i] != LLINF){\n\t\t\tcout << i << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif(dp2[0][i] < 0){\n\t\t\tcout << i << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define MAXN 5005\n#define eps 1e-10\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef unsigned int u32;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n\tres = 0;T f = 1;char c = getchar();\n\twhile(c < '0' || c > '9') {\n\t\tif(c == '-') f = -1;\n\t\tc = getchar();\n\t}\n\twhile(c >= '0' && c <= '9') {\n\t\tres = res * 10 + c - '0';\n\t\tc = getchar();\n\t}\n\tres *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n\tif(x < 0) {x = -x;putchar('-');}\n\tif(x >= 10) {\n\t\tout(x / 10);\n\t}\n\tputchar('0' + x % 10);\n}\nstruct node {\n\tint to,next;\n}E[MAXN * 2];\nint head[MAXN],sumE;\nbool vis[MAXN][MAXN][2],used[MAXN][2];\nint64 dp[MAXN][MAXN][2],A[MAXN],g[MAXN][2];\nint N,siz[MAXN],ans;\nvoid add(int u,int v) {\n\tE[++sumE].to = v;\n\tE[sumE].next = head[u];\n\thead[u] = sumE;\n}\nvoid dfs(int u,int fa) {\n\tif(A[u] < 0) {\n\t\tvis[u][0][1] = 1;dp[u][0][1] = A[u];\n\t}\n\tif(A[u] > 0) {\n\t\tvis[u][0][0] = 1;dp[u][0][0] = A[u];\n\t}\n\tfor(int i = head[u] ; i ; i = E[i].next) {\n\t\tint v = E[i].to;\n\t\tif(v != fa) {\n\t\t\tdfs(v,u);\n\t\t}\n\t}\n\tmemset(used,0,sizeof(used));\n\tsiz[u] = 1;\n\tfor(int i = head[u] ; i ; i = E[i].next) {\n\t\tint v = E[i].to;\n\t\tif(v != fa) {\n\t\t\tfor(int j = 0 ; j <= siz[u] + siz[v] ; ++j) used[j][0] = used[j][1] = 0;\n\t\t\tfor(int j = 0 ; j <= siz[u] ; ++j) {\n\t\t\t\tfor(int a = 0 ; a <= 1 ; ++a) {\n\t\t\t\t\tif(!vis[u][j][a]) continue;\n\t\t\t\t\tfor(int h = 0 ; h <= siz[v] ; ++h) {\n\t\t\t\t\t\tfor(int b = 0 ; b <= 1 ; ++b) {\n\t\t\t\t\t\t\tif(!vis[v][h][b]) continue;\n\t\t\t\t\t\t\tif(!used[j + h][a | b]) {\n\t\t\t\t\t\t\t\tg[j + h][a | b] = dp[u][j][a] + dp[v][h][b];\n\t\t\t\t\t\t\t\tused[j + h][a | b] = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse g[j + h][a | b] = min(g[j + h][a | b],dp[u][j][a] + dp[v][h][b]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = 0 ; j <= siz[u] + siz[v] ; ++j) {\n\t\t\t\tfor(int a = 0 ; a <= 1 ; ++a) {\n\t\t\t\t\tvis[u][j][a] = used[j][a];\n\t\t\t\t\tdp[u][j][a] = g[j][a];\n\t\t\t\t}\n\t\t\t}\n\t\t\tsiz[u] += siz[v];\n\t\t}\n\t}\n\tif(fa) {\n\t\tfor(int j = siz[u] ; j >= 0 ; --j) {\n\t\t\tif(vis[u][j][1] && dp[u][j][1] < 0) {dp[u][j + 1][0] = 0;vis[u][j + 1][0] = 1;}\n\t\t\tif(vis[u][j][0]) {dp[u][j + 1][0] = 0;vis[u][j + 1][0] = 1;}\n\t\t}\n\t}\n\telse {\n\t\tfor(int j = 0 ; j <= siz[u] ; ++j) {\n\t\t\tif(vis[u][j][1] && dp[u][j][1] < 0) {ans = j;break;}\n\t\t\tif(vis[u][j][0]) {ans = j;break;}\n\t\t}\n\t}\n}\nvoid Solve() {\n\tread(N);\n\tfor(int i = 1 ; i <= N ; ++i) read(A[i]);\n\tint u,v;\n\tfor(int i = 1 ; i < N ; ++i) {\n\t\tread(u);read(v);\n\t\tadd(u,v);add(v,u);\n\t}\n\tdfs(1,0);\n\tout(ans);enter;\n}\nint main() {\n#ifdef ivorysi\n\tfreopen(\"f1.in\",\"r\",stdin);\n#endif\n\tSolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n/*\nsum<0なら0で終わり\nそうじゃないなら？必ず正だけの地点を作る\n根付き木にしてdp？\ndp[i][j]:部分根付き木iまででj本切った時の最小値(iの上の部分を切ることも考えてる)\n葉lに対してdp[l][0]=v[l],dp[l][1]=0;\n親pに対して子をsとして、dp[p][k]=それぞれのそれ\nつまり？dp[p][k]はmin(sum(dp[s][j]:sum j = k))\n高速化の方法は？\nえーなんかdpまでは絶対に合っていると思っていて、\n+のやつを取るところに関しては+をなるべく大量に消費して欲しくて、マイナスは一個も入っちゃいけない\n-が入る方は、+にならないようになるべく大きく取りたい\n実は葉から貪欲？最後にくっつけられるところはくっつけていいとか\n根付き木にして、葉から貪欲にやっていく　具体的には\n・スタートが+の時\n+で有る限り取り続ける\n-が来た場合、-が大きくなるなら取って変更\n・スタートが-の時\n合計が負で有る限り取り続ける\n\n貪欲が終わった時塊は　a:全部+で次の-入れても+ or b:合計が負で次のやつで+\n・貪欲をした後\n自分の子とくっつけられるかを試す？\n自分がaの時　aは子の候補にいなくて、bは絶対無理　なので終わり\n自分がbの時　子のbは全部取り込める\n　　　　　　 これで子のaも取り込めるし次の+も取り込める場合は？\n　　　　　　　・子のaを取り込むメリット:そのさらに子を取り込める可能性が出てくる\nまってそもそも合流を考えられていない　いやそれは大丈夫かも\n*/\nint dp1[5123][5123],//dp1[v][k]:v以下k個、vのところは全部正の時のその最小値\n    dp2[5123][5123],//dp2[v][k]:v以下k個、vの所の最小値\n    dpt1[5123][5123],//dpt1[i][j]:vのi番目までの子までからなる部分木をdp1と同様にj個に分ける時の一番上の最小値\n    dpt2[5123][5123];//dpt2[i][j]:同様\n\nconst int INF=1e9;\n\ntemplate<typename T>\nvoid fin(T a){\n  cout<<a<<endl;\n  exit(0);\n}\n\ntemplate<typename T>\nvoid chmin(T &a,T b){\n  if(a>b)a=b;\n}\n\nsigned main(){\n  int n;cin>>n;\n  assert(n<100);\n  vector<int> v(n);\n  for(int i=0;i<n;i++)cin>>v[i];\n  vector<int> edge[n];\n  for(int i=1;i<n;i++){\n    int u,v;cin>>u>>v;u--;v--;\n    edge[u].push_back(v);\n    edge[v].push_back(u);\n  }\n\n  int sum=0;for(int i=0;i<n;i++)sum+=v[i];if(sum<0)fin(0);\n\n  int r;int m=0;\n  for(int i=0;i<n;i++)\n    if(m<edge[i].size())\n      m=edge[i].size(),r=i;\n\n  vector<int> parent(n),son[n];\n  parent[r]=-1;\n  queue<int> que;\n  que.push(r);\n  while(que.size()){\n    int p=que.front();que.pop();\n    for(int q:edge[p]){\n      if(parent[p]==q)continue;\n      parent[q]=p;\n      son[p].push_back(q);\n      que.push(q);\n    }\n  }\n\n  for(int i=0;i<5123;i++)\n    for(int j=0;j<5123;j++)\n      dp1[i][j]=dp2[i][j]=dpt1[i][j]=dpt2[i][j]=INF;\n\n  vector<int> rem(n);\n  for(int i=0;i<n;i++)rem[i]=son[i].size();\n  for(int i=0;i<n;i++)if(!rem[i])que.push(i);\n\n  while(que.size()){\n    int p=que.front();que.pop();\n\n    for(int j=0;j<100;j++)for(int k=0;k<100;k++)dpt1[j][k]=dpt2[j][k]=INF;\n    dpt1[0][0]=0;\n\n    int N=son[p].size();\n\n    for(int i=0;i<N;i++){\n      int q=son[p][i];\n      for(int j=0;j<100;j++){\n        for(int k=0;k<100;k++){\n          chmin(dpt1[i+1][j+k],dpt1[i][j]+dp1[q][k]);\n        }\n      }\n    }\n\n    for(int k=0;k<100;k++){\n      if(dpt1[N][k]==INF)continue;\n      if(v[p]>0){\n        chmin(dp1[p][k],dpt1[N][k]+v[p]);\n        dp2[p][k+1]=0;\n      }\n    }\n\n    dpt2[0][0]=0;\n\n    for(int i=0;i<N;i++){\n      int q=son[p][i];\n      for(int j=0;j<100;j++){\n        for(int k=0;k<100;k++){\n          chmin(dpt2[i+1][j+k],dpt2[i][j]+dp2[q][k]);\n        }\n      }\n    }\n\n    for(int k=0;k<100;k++){\n      chmin(dp2[p][k],dpt2[N][k]+v[p]);\n      if(dpt2[N][k]+v[p]<0)dp1[p][k+1]=dp2[p][k+1]=0;\n    }\n\n    if(~parent[p]&&--rem[parent[p]]==0)que.push(parent[p]);\n  }\n\n  int ans=INF;\n  for(int j=0;j<100;j++){\n    if(dp1[r][j]<50)chmin(ans,j);\n    if(dp2[r][j]<0)chmin(ans,j);\n  }\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\nstruct UnionFind{\n  Int n;\n  vector<Int> r,p;\n  UnionFind(){}\n  UnionFind(Int sz):n(sz),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n  Int find(Int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(Int x,Int y){\n    return find(x)==find(y);\n  }\n  void unite(Int x,Int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];\n    p[y]=x;\n  }\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  auto shrink=\n    [&](){\n      Int n;\n      cin>>n;\n      vector<Int> a(n);\n      for(Int i=0;i<n;i++) cin>>a[i];\n      vector<vector<Int> > G(n);\n      for(Int i=1;i<n;i++){\n        Int x,y;\n        cin>>x>>y;\n        x--;y--;\n        G[x].emplace_back(y);\n        G[y].emplace_back(x);\n      }\n      UnionFind uf(n);\n      for(Int v=0;v<n;v++){\n        for(Int u:G[v]){\n          if(a[v]<0&&a[u]<0) uf.unite(u,v);\n          if(a[v]>0&&a[u]>0) uf.unite(u,v);\n        }\n      }\n      \n      vector<Int> vs;\n      for(Int i=0;i<n;i++){\n        if(uf.find(i)!=i) continue;\n        vs.emplace_back(i);\n      }\n      \n      Int m=vs.size();\n      map<Int, Int> rev;\n      for(Int i=0;i<m;i++) rev[vs[i]]=i;\n\n      vector<set<Int> > H(m);\n      vector<Int> na(m,0);\n      for(Int v=0;v<n;v++){\n        na[rev[uf.find(v)]]+=a[v];\n        for(Int u:G[v]){\n          if(uf.same(u,v)) continue;\n          Int x=rev[uf.find(v)],y=rev[uf.find(u)];\n          H[x].emplace(y);\n          H[y].emplace(x);\n        }\n      }\n      \n      vector<vector<Int> > nG(m);\n      for(Int i=0;i<m;i++) nG[i]=vector<Int>(H[i].begin(),H[i].end());\n      return make_tuple(m,na,nG);      \n    };\n  \n  auto graph=shrink();\n  auto n=get<0>(graph);\n  auto a=get<1>(graph);\n  auto G=get<2>(graph);\n  assert((Int)a.size()==n);\n  assert((Int)G.size()==n);\n\n  if(0){\n    cout<<n<<endl;\n    for(Int i=0;i<n;i++) cout<<a[i]<<\" \";\n    cout<<endl;\n    for(Int v=0;v<n;v++){\n      for(Int u:G[v]){\n        cout<<v<<\" \"<<u<<endl;\n      }\n    }\n  }\n  \n  if(n==1){\n    cout<<0<<endl;\n    return 0;\n  }\n\n  const Int INF = 1e17;\n  vector<vector<Int> > dp(n);\n  vector<Int> sum(n,0);\n  \n  function<void(Int, Int)> dfs=\n    [&](Int v,Int par){\n      for(Int u:G[v])\n        if(u!=par) dfs(u,v);\n      \n      dp[v].resize(1);\n      dp[v][0]=a[v];\n      for(Int u:G[v]){\n        if(u==par) continue;\n        const auto &p=dp[v];\n        const auto &q=dp[u];\n        Int x=p.size();\n        Int y=q.size();\n        vector<Int> nx(x+y,INF);\n        for(Int i=0;i<x;i++){\n          for(Int j=0;j<y;j++){\n            chmin(nx[i+j],p[i]+q[j]);\n            if(q[j]<0) chmin(nx[i+j+1],p[i]);\n          }\n        }\n        if(1){\n          {          \n            for(Int i=0;i<x;i++)\n              if(i+sum[u]+1<x+y) chmin(nx[i+sum[u]+1],p[i]);\n          }\n          {\n            Int res=sum[u]+1;\n            for(Int j=0;j<y;j++)\n              if(q[j]<0) chmin(res,j+1);\n            sum[v]+=res;\n          }\n        }\n        swap(dp[v],nx);\n      }\n    };\n\n  Int idx=0;\n  while(a[idx]>0) idx++;\n  assert(idx<n);\n  \n  dfs(idx,-1);\n  Int ans=n;\n  //cout<<n<<\":\"<<dp[idx].size()<<endl;\n  assert(n==(Int)dp[idx].size());\n  for(Int i=0;i<n;i++)\n    if(dp[idx][i]<0) chmin(ans,i);\n  \n  assert(ans<n);  \n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\n#include<cassert>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\nlint inf=1e15;\nlint dp[2][5010][5010][2];\nvector<int> gr[5010];\nlint a[5010];\nint n;\nint dfs(int v,int u){\n\tint ch=0,now=0,ne=1;\n\tif(a[v]<0) dp[0][v][0][1]=a[v];else dp[0][v][0][0]=a[v];\n\t//cout<<v<<' '<<dp[0][v][0][0]<<' '<<dp[0][v][0][0]<<endl;\n\trep(i,gr[v].size()){\n\t\tint w=gr[v][i];\n\t\tif(w==u) continue;\n\t\trep(j,ch+3) dp[ne][v][j][0]=dp[ne][v][j][1]=inf;\n\t\tint c2=dfs(w,v),x=1-gr[w].size()%2;\n\t\trep(j,ch+1) rep(k,c2+1){\n\t\t\t//切る\n\t\t\tif(dp[x][w][k][0]<inf/2 || dp[x][w][k][1]<0){\n\t\t\t\t//cout<<\"hoge\"<<endl;\n\t\t\t\tdp[ne][v][j+k+1][0]=min(dp[ne][v][j+k+1][0],dp[now][v][j][0]);\n\t\t\t\tdp[ne][v][j+k+1][1]=min(dp[ne][v][j+k+1][1],dp[now][v][j][1]);\n\t\t\t}\n\t\t\t//切らない\n\t\t\trep(l,2) rep(m,2){\n\t\t\t\t//cout<<\"huga\"<<' '<<dp[now][v][j][l]<<' '<<dp[x][w][k][m]<<' '<<x<<w<<k<<m<<endl;\n\t\t\t\tdp[ne][v][j+k][(l|m)]=min(dp[ne][v][j+k][(l|m)], dp[now][v][j][l]+dp[x][w][k][m]);\n\t\t\t}\n\t\t}\n\t\tch+=c2+1;\n\t\trep(j,ch+1){\n\t\t\t//cout<<v<<' '<<j<<' '<<dp[ne][v][j][0]<<' '<<dp[ne][v][j][1]<<endl;\n\t\t}\n\t\tswap(now,ne);\n\t}\n\treturn ch;\n}\nint main()\n{\n\tint x,y,out=5010;\n\tcin>>n;\n\trep(i,n) cin>>a[i];\n\trep(i,n-1){\n\t\tcin>>x>>y;x--;y--;\n\t\tgr[x].pb(y);gr[y].pb(x);\n\t}\n\trep(k,2) rep(i,5005) rep(j,5005) dp[k][i][j][0]=dp[k][i][j][1]=inf;\n\tdfs(0,-1);\n\trep(i,n+1){\n\t\tif(dp[gr[0].size()%2][0][i][0]<inf/2 || dp[gr[0].size()%2][0][i][1]<0L) out=min(out,i);\n\t}\n\tcout<<out<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i, a, b) for (int i = (a); i < (b); i++)\n#ifdef tabr\n#include \"library/debug.cpp\"\n#else\n#define debug(...) 0\n#endif\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n;\n    cin >> n;\n    vector<ll> a(n);\n    vector<vector<int>> g(n);\n    rep(i, 0, n) cin >> a[i];\n    rep(i, 0, n - 1) {\n        int u, v;\n        cin >> u >> v;\n        u--, v--;\n        g[u].emplace_back(v);\n        g[v].emplace_back(u);\n    }\n    vector<vector<vector<ll>>> dp(n, vector<vector<ll>>(n + 1, vector<ll>(2, 1e18)));\n    vector<int> sz(n, 1);\n    function<void(int, int)> dfs = [&](int v, int p) {\n        if (g[v].size() == 0) {\n            if (a[v] > 0)\n                dp[v][0][0] = a[v];\n            else\n                dp[v][0][1] = a[v];\n            return;\n        }\n        for (int u : g[v]) {\n            if (u == p) continue;\n            dfs(u, v);\n            sz[v] += sz[u];\n        }\n        int cur = 0;\n        vector<vector<ll>> tmp(sz[v] + 1, vector<ll>(2, 1e18));\n        tmp[0][0] = a[v];\n        if (a[v] > 0) tmp[0][1] = a[v];\n        for (int u : g[v]) {\n            if (u == p) continue;\n            for (int i = cur; i >= 0; i--) {\n                ll x = tmp[i][0], y = tmp[i][1];\n                tmp[i][0] = tmp[i][1] = 1e18;\n                rep(k, 0, sz[u] + 1) {\n                    tmp[i + k][0] = min(tmp[i + k][0], x + dp[u][k][0]);\n                    if (dp[u][k][0] < 0 || dp[u][k][1] < 1e18)\n                        tmp[i + k + 1][0] = min(tmp[i + k + 1][0], x);\n                    if (a[v] > 0) {\n                        tmp[i + k][1] = min(tmp[i + k][1], y + dp[u][k][1]);\n                        if (dp[u][k][0] < 0 || dp[u][k][1] < 1e18)\n                            tmp[i + k + 1][1] = min(tmp[i + k + 1][1], y);\n                    }\n                }\n            }\n            cur += sz[u];\n        }\n        rep(i, 0, sz[v] + 1) {\n            dp[v][i][0] = tmp[i][0];\n            dp[v][i][1] = tmp[i][1];\n        }\n        return;\n    };\n    dfs(0, -1);\n    rep(i, 0, n) {\n        if (dp[0][i][0] < 0 || dp[0][i][1] < 1e18) {\n            cout << i << endl;\n            return 0;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n\n#define null\t\t\t\t\"\"\n#define all(dat)\t\t\tdat.begin(), dat.end()\n#define over(msg)\t\t\tcout << msg << endl, exit(0);\n#define loop(i, to)\t\t\tfor (int i = 0; i < to; ++i)\n#define cont(i, to)\t\t\tfor (int i = 1; i <= to; ++i)\n#define foreach(i, dat)\t\tfor (__typeof(dat.begin()) i = dat.begin(); i != dat.end(); ++i)\n\ntypedef long long\t\t\tnum;\n\nusing namespace std;\n\nint n;\nnum inf = 1e15, sz[50005], w[5005], dp[2][5005][5005], tmp[2][5005];\nvector<int> g[5005];\n\nvoid init(int u, int p) {\n\tsz[u] = 1;\n\tfor (int v : g[u]) {\n\t\tif (v == p)  continue;\n\t\tinit(v, u);\n\t\tsz[u] += sz[v];\n\t}\n}\n\nvoid dfs(int u, int p) {\n\tcont (s, sz[u]) {\n\t\tdp[0][u][s] = dp[1][u][s] = inf;\n\t}\n\tdp[0][u][1] = w[u] < 0 ? inf : w[u];\n\tdp[1][u][1] = w[u];\n\tfor (int v : g[u]) {\n\t\tif (v == p)  continue;\n\t\tdfs(v, u);\n\t\tcont (s, sz[u]) {\n\t\t\ttmp[0][s] = tmp[1][s] = inf;\n\t\t}\n\t\tcont (s1, sz[u]) {\n\t\t\tcont (s2, sz[v]) {\n\t\t\t\tint s = s1 + s2;\n\t\t\t\tif (s > sz[u])  break;\n\t\t\t\tif (dp[0][v][s2] < inf) {\n\t\t\t\t\ttmp[0][s] = min(tmp[0][s], dp[0][u][s1]);\n\t\t\t\t\ttmp[1][s] = min(tmp[1][s], dp[1][u][s1]);\n//\t\t\t\t\tcout << u << ':' << s << ' ' << tmp[0][s] << ' ' << tmp[1][s] << endl;\n\t\t\t\t}\n\t\t\t\tif (dp[1][v][s2] < 0) {\n\t\t\t\t\ttmp[0][s] = min(tmp[0][s], dp[0][u][s1]);\n\t\t\t\t\ttmp[1][s] = min(tmp[1][s], dp[1][u][s1]);\n//\t\t\t\t\tcout << u << ':' << s << ' ' << tmp[0][s] << ' ' << tmp[1][s] << endl;\n\t\t\t\t}\n\t\t\t\ttmp[0][s - 1] = min(tmp[0][s - 1], dp[0][u][s1] + dp[0][v][s2]);\n\t\t\t\ttmp[1][s - 1] = min(tmp[1][s - 1], dp[1][u][s1] + dp[1][v][s2]);\n//\t\t\t\tcout << u << ':' << s - 1 << ' ' << dp[1][u][s1] << ',' << dp[1][v][s2] << endl;\n\t\t\t}\n\t\t}\n\t\tcont (s, sz[u]) {\n\t\t\tdp[0][u][s] = tmp[0][s];\n\t\t\tdp[1][u][s] = tmp[1][s];\n//\t\t\tcout << \"  \" << u << \":\" << s << ' ' << tmp[0][s] << ' ' << tmp[1][s] << endl;\n\t\t}\n\t}\n}\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin >> n;\n\tcont (i, n) {\n\t\tcin >> w[i];\n\t}\n\tcont (i, n - 1) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\tinit(1, -1);\n\tdfs(1, -1);\n//\tcont (u, n) {\n//\t\tcout << u << \": \" << endl;\n//\t\tcont (cnt, sz[u]) {\n//\t\t\tcout << \"  \" << cnt << \": \" << endl;\n//\t\t\tcout << \"    \";\n//\t\t\tloop (mem, 2) {\n//\t\t\t\tcout << dp[mem][u][cnt] << ' ';\n//\t\t\t}\n//\t\t\tcout << endl;\n//\t\t}\n//\t\tcout << endl;\n//\t}\n\tcont (cnt, n) {\n//\t\tcout << dp[0][1][cnt] << ' ' << dp[1][1][cnt] << endl;\n\t\tif (dp[0][1][cnt] < inf || dp[1][1][cnt] < 0) {\n\t\t\tcout << cnt - 1 << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\nint main()\n{\n    int N;\n    cin>>N;\n    vector<long long> A(N);\n    for (long long &a: A)\n        cin>>a;\n    vector<vector<int>> E(N);\n    for (int i=0; i<N-1; i++)\n    {\n        int U, V;\n        cin>>U>>V;\n        E[U-1].push_back(V-1);\n        E[V-1].push_back(U-1);\n    }\n\n    long long oo = 1000000000LL*N;\n    vector<vector<long long>> X(N, vector<long long>(N, oo));   //  no server\n    vector<vector<long long>> Y(N, vector<long long>(N, oo));   //  with server\n    vector<int> C(N);\n    vector<long long> Xt(N);\n    vector<long long> Yt(N);\n\n    function<void(int, int)> f = [&](int c, int p)\n    {\n        if (A[c] > 0)\n            X[c][0] = A[c];\n        else\n            Y[c][0] = A[c];\n\n        for (int e: E[c])\n        if (e != p)\n        {\n            f(e, c);\n\n            for (int i=0; i<=C[c]; i++)\n            {\n                Xt[i] = X[c][i];\n                Yt[i] = Y[c][i];\n                X[c][i] = oo;\n                Y[c][i] = oo;\n            }\n\n            for (int a=0; a<=C[c]; a++)\n            for (int b=0; b<=C[e]; b++)\n            {\n                //  cut\n                if (X[e][b] < oo || Y[e][b] < 0)\n                {\n                    if (Xt[a] < oo)\n                        X[c][a+b+1] = min(X[c][a+b+1], Xt[a]);\n                    if (Yt[a] < oo)\n                        Y[c][a+b+1] = min(Y[c][a+b+1], Yt[a]);\n                }\n                //  connect\n                if (Xt[a] < oo && X[e][b] < oo)\n                    X[c][a+b] = min(X[c][a+b], Xt[a] + X[e][b]);\n                if (Yt[a] < oo || Y[e][b] < oo)\n                    Y[c][a+b] = min(Y[c][a+b],\n                        min(Yt[a] + X[e][b],\n                        min(Yt[a] + Y[e][b],\n                            Xt[a] + Y[e][b])));\n            }\n            C[c] += C[e] + 1;\n        }\n    };\n\n    f(0, -1);\n\n    for (int a=0; a<N; a++)\n    {\n        if (X[0][a] < oo || Y[0][a] < 0)\n        {\n            cout<<a<<endl;\n            break;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████\n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define MOD 1000000007\n//#define MOD 998244353\nconst double EPS = 1e-9;\n#define INF (1LL<<60)\n#define D double\n#define fs first\n#define sc second\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i = (b-1);i>=a;i--)\n#define REP(i,n)  FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl;\n#define SP << \" \" << \ntypedef pair<int,int> P;\ntypedef vector<vector<P> > Graph;\ntypedef vector<int> vec;\ntypedef vector<vector<int>> mat;\n\nconst int N = 5050;\nvec edge[N], a(N), used(N,0), sz(N,1);\nint dp[2][N][N];\nint n;\n\nvoid dfs(int no){\n  used[no]++;\n  dp[a[no]>0][no][0] = a[no];\n\n  for(int to:edge[no]){\n    if(used[to]) continue;\n    dfs(to);\n\n    mat tmp(2,vec(N,INF));\n    REP(i,sz[no]){\n      REP(j,sz[to]){\n        //切るとき、制約を満たしているとき\n        if(dp[0][to][j] < 0 || dp[1][to][j] != INF){\n          tmp[0][i+j+1] = min(tmp[0][i+j+1],dp[0][no][i]);\n          tmp[1][i+j+1] = min(tmp[1][i+j+1],dp[1][no][i]);\n        }\n        //切らないとき\n        tmp[0][i+j] = min(tmp[0][i+j],dp[0][no][i]+dp[0][to][j]);\n        tmp[0][i+j] = min(tmp[0][i+j],dp[0][no][i]+dp[1][to][j]);\n        tmp[0][i+j] = min(tmp[0][i+j],dp[1][no][i]+dp[0][to][j]);\n        tmp[1][i+j] = min(tmp[1][i+j],dp[1][no][i]+dp[1][to][j]);\n      }\n    }\n    REP(i,sz[no]+sz[to]){\n      dp[0][no][i] = tmp[0][i];\n      dp[1][no][i] = tmp[1][i];\n    }\n    sz[no] += sz[to];\n  }\n}\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  cin >> n;\n\n  REP(i,n) cin >> a[i];\n  REP(_,n-1){\n    int u,v;\n    cin >> u >> v;\n    u--; v--;\n    edge[u].push_back(v);\n    edge[v].push_back(u);\n  }\n\n  REP(i,N) REP(j,N) dp[0][i][j] = dp[1][i][j] = INF;\n  \n  dfs(0);\n\n  REP(i,n){\n    //cout << dp[0][0][i] SP dp[1][0][i] << endl;\n    if(dp[0][0][i] < 0 || dp[1][0][i] != INF){\n      cout << i << endl;\n      return 0;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// #define int long long\n// #define double long double\n#define rep(i,a,b) for(int i=(int)(a); i<(int)(b); ++i)\n#define repeq(i,a,b) for(int i=(int)(a); i<=(int)(b); ++i)\n#define rrep(i,a,b) for(int i=(int)(a)-1; i>=(int)(b); --i)\n#define rrepeq(i,a,b) for(int i=(int)(a); i>=(int)(b); --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vb = vector<bool>;\ntemplate<typename T> using Graph = vector<vector<T>>;\ntemplate<typename T> using Spacial = vector<vector<vector<T>>>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\ntemplate<typename T> using greater_priority_queue = priority_queue<T, vector<T>, greater<T>>;\nconst int MOD = 1e9+7;\nconst int MOD2 = 998244353;\n// const double EPS = 1e-9;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nstring interval[2] = {\" \", \"\\n\"}; // {\" \", \"\\n\"}\n\ntemplate<typename T> struct is_plural : false_type{};\ntemplate<typename T1, typename T2> struct is_plural<pair<T1, T2>> : true_type{};\ntemplate<typename T> struct is_plural<vector<T>> : true_type{};\ntemplate<typename T> struct is_plural<complex<T>> : true_type{};\ntemplate<> struct is_plural<string> : true_type{};\n\ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { return is >> p.first >> p.second; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { return os << p.first << \" \" << p.second; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec) { for(auto itr = vec.begin(); itr != vec.end(); ++itr) is >> *itr; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec) { if(vec.empty()) return os; bool pl = is_plural<T>(); os << vec.front(); for(auto itr = ++vec.begin(); itr != vec.end(); ++itr) os << interval[pl] << *itr; return os; }\n\nbool CoutYN(bool a, string y = \"Yes\", string n = \"No\") { cout << (a ? y : n) << \"\\n\"; return a; }\n\ntemplate<typename T1, typename T2> inline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\ntemplate<typename T1, typename T2> inline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\nlong long modpow(int a, long long n, int mod = MOD) { long long ret = 1; do { if(n & 1) ret = ret * a % mod; a = 1LL * a * a % mod; } while(n >>= 1); return ret; }\n\ntemplate<typename T> T GCD(T a, T b) { return b ? GCD(b, a%b) : a; }\ntemplate<typename T> T LCM(T a, T b) { return a / GCD(a, b) * b; }\n\ntemplate<typename T1, typename T2> bool CompareBySecond(pair<T1, T2> a, pair<T1, T2> b) { return a.second != b.second ? a.second < b.second : a.first < b.first; }\ntemplate<typename T1, typename T2> bool CompareByInverse(pair<T1, T2> a, pair<T1, T2> b) { return a.first != b.first ? a.first < b.first : a.second > b.second; }\n\n\n/* -------- <templates end> -------- */\n\n\nvoid solve() {\n  int n; cin >> n;\n  vi a(n); cin >> a;\n  Graph<int> g(n);\n  rep(_,1,n) {\n    int u, v; cin >> u >> v; --u, --v;\n    g[u].emplace_back(v);\n    g[v].emplace_back(u);\n  }\n\n  const ll INFTY = 1LL << 60;\n  vi b(n, 0);\n  Graph<ll> c(n);\n  for(auto &vec : c) vec.reserve(n);\n\n  auto dfs = [&](auto dfs, int v, int p) -> int {\n    int sum = 1;\n    c[v].assign(1, a[v]);\n\n    for(auto &nv : g[v]) {\n      if(nv != p) {\n        int cnt = dfs(dfs, nv, v);\n        vl tmp = c[v];\n        c[v].assign(sum + cnt, INFTY);\n        rep(i,0,sum) {\n          rep(j,0,cnt) {\n            chmin(c[v][i + j], tmp[i] + c[nv][j]);\n          }\n          if(a[nv] > 0) {\n            chmin(c[v][i + b[nv] + 1], tmp[i]);\n          }\n        }\n\n        if(a[v] > 0) {\n          int k = 0;\n          while(k < c[nv].size()) {\n            if(c[nv][k++] < 0) break;\n          }\n          if(a[nv] > 0) b[v] += min(b[nv], k);\n          else b[v] += k;\n        }\n\n        sum += cnt;\n      }\n    }\n\n    return sum;\n  };\n\n  dfs(dfs, 0, -1);\n\n  int ans = 0;\n  while(ans < c[0].size()) {\n    if(c[0][ans] < 0) break;\n    ++ans;\n  }\n  if(a[0] > 0) chmin(ans, b[0]);\n  cout << ans << endl;\n}\n\n\n/* -------- <programs end> -------- */\n\n\nsigned main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\n#include <unordered_map>\nusing namespace std;\n\n#define REP(i, s) for (int i = 0; i < s; ++i)\n#define ALL(v) (v.begin(), v.end())\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\ntemplate<class T> ostream& operator << (ostream &s, set<T> P)\n{ EACH(it, P) { s << \"<\" << *it << \"> \"; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P)\n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s << endl; }\n\nconst long long INF = 1LL<<60;\nconst int MAX = 5100;\n\nint N;\nvector<long long> A;\nvector<vector<int> > G;\n\nint num[MAX];\nlong long dp[MAX][MAX][2]; // vの部分木、vを含めず何個か、(全部正かどうか)\nlong long sdp[2][MAX][2];\n\nvoid rec(int v, int p) {\n    int numc = 0;\n    num[v] = 1;\n    for (auto ch : G[v]) {\n        if (ch == p) continue;\n        rec(ch, v);\n        ++numc;\n        num[v] += num[ch];\n    }\n    \n    for (int i = 0; i < 2; ++i) for (int j = 0; j <= num[v]; ++j)\n        sdp[i][j][0] = sdp[i][j][1] = INF;\n    \n    sdp[0][0][0] = A[v];\n    if (A[v] > 0) sdp[0][0][1] = A[v];\n    \n    int i = 0;\n    for (auto ch : G[v]) {\n        if (ch == p) continue;\n        for (int j = 0; j <= num[v]; ++j) {\n            if (sdp[i%2][j][0] > INF/2) break;\n            for (int k = 0; k <= num[ch] && j+k <= num[v]; ++k) {\n                chmin(sdp[(i+1)%2][j+k][0], sdp[i%2][j][0] + dp[ch][k][0]);\n                chmin(sdp[(i+1)%2][j+k][0], sdp[i%2][j][0] + dp[ch][k][1]);\n                if (dp[ch][k][0] < 0) chmin(sdp[(i+1)%2][j+k+1][0], sdp[i%2][j][0]);\n                if (dp[ch][k][1] < INF/2) chmin(sdp[(i+1)%2][j+k+1][0], sdp[i%2][j][0]);\n                if (A[v] > 0) {\n                    chmin(sdp[(i+1)%2][j+k][1], sdp[i%2][j][1] + dp[ch][k][1]);\n                    if (dp[ch][k][0] < 0) chmin(sdp[(i+1)%2][j+k+1][1], sdp[i%2][j][1]);\n                    if (dp[ch][k][1] < INF/2) chmin(sdp[(i+1)%2][j+k+1][1], sdp[i%2][j][1]);\n                }\n            }\n        }\n        for (int j = 0; j <= num[v]; ++j) sdp[i%2][j][0] = sdp[i%2][j][1] = INF;\n        ++i;\n    }\n    for (int j = 0; j <= num[v]; ++j) {\n        dp[v][j][0] = sdp[numc%2][j][0];\n        dp[v][j][1] = sdp[numc%2][j][1];\n        \n        //cout << v << \", \" << j << \": \" << make_pair(dp[v][j][0], dp[v][j][1]) << endl;\n    }\n}\n\nint main() {\n    while (cin >> N) {\n        A.resize(N);\n        for (int i = 0; i < N; ++i) cin >> A[i];\n        G.assign(N, vector<int>());\n        for (int i = 0; i < N-1; ++i) {\n            int u, v; cin >> u >> v; --u, --v;\n            G[u].push_back(v);\n            G[v].push_back(u);\n        }\n        for (int i = 0; i < MAX; ++i) for (int j = 0; j < MAX; ++j)\n            dp[i][j][0] = dp[i][j][1] = INF;\n        rec(0, -1);\n        int res = N;\n        for (int i = 0; i <= N; ++i) {\n            if (dp[0][i][0] < 0) chmin(res, i);\n            if (dp[0][i][1] < INF/2) chmin(res, i);\n        }\n        cout << res << endl;\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nint N, A[5010], sz[5010], dp[5010][5010][2], tmp[2][5010][2];\nvector<int> G[5010];\n\nvoid dfs(int cur, int par=-1) {\n    sz[cur] = 1;\n    for(int to : G[cur]) {\n        if(to == par) continue;\n        dfs(to, cur);\n        sz[cur] += sz[to];\n    }\n}\n\nvoid solve(int cur, int par=-1) {\n    int cnt = 0;\n    for(auto to : G[cur]) {\n        if(to == par) continue;\n        solve(to, cur);\n        cnt++;\n    }\n    \n    // cur を根とする部分木には sz[cur] 個のノードがある\n    // こたえは sz[cur] - 1 個以下にしかならない\n    for(int i=0; i<=sz[cur]; i++) {\n        for(int k=0; k<2; k++) {\n            tmp[k][i][0] = INF;\n            tmp[k][i][1] = false;\n        }\n    }\n\n    // (偶奇, 総和, mode)\n    tmp[0][0][0] = A[cur];\n    tmp[0][0][1] = (A[cur] > 0);\n    int pari = 0;\n    \n    for(int to : G[cur]) {\n        if(to == par) continue;\n        int now = pari, nxt = 1 - pari;\n        pari = 1 - pari;\n        for(int i=sz[cur]-1; i>=0; i--) {\n            \n            // 合計は sz[cur]-1 以下\n            for(int j=min(sz[cur]-1-i, sz[to]-1); j>=0; j--) {\n                // 0: その回数を満たす中で総和が最小のもの\n                // j 回切った component とつなげるとき\n                // fprintf(stderr, \"nxt = %lld, i+j = %lld\\n\", nxt, i+j);\n                if(tmp[now][i][0] != INF) {\n                    // fprintf(stderr, \"tmp[now][%lld][0] = %lld, dp[%lld][%lld][0] = %lld\\n\", i, tmp[now][i][0], to, j, dp[to][j][0]);\n                    chmin(tmp[nxt][i+j][0], tmp[now][i][0] + dp[to][j][0]);\n                }\n                else {\n                    // fprintf(stderr, \"i = %lld, j = %lld, tmp[%lld][%lld][0] = INF\\n\", i, j, now, i);\n                }\n                \n                // j 回切った component とつなげないとき\n                // 0: dp[to][j][0] が負のときのみ可能\n                // 1: dp[to][j][1] が true のときのみ可能\n                if(i+j+1 <= sz[cur]-1) {\n                    if(dp[to][j][0] < 0) {\n                        chmin(tmp[nxt][i+j+1][0], tmp[now][i][0]);\n                    }\n                    if(dp[to][j][1] == true) {\n                        chmin(tmp[nxt][i+j+1][0], tmp[now][i][0]);\n                    }\n                }\n                \n                // 1: その回数を満たして全部正にできる？\n                // 正の component とつなげるとき\n                tmp[nxt][i+j][1] |= tmp[now][i][1] & dp[to][j][1];\n\n                // 正の component とつなげないとき\n                // 0: dp[to][j][0] が負のときのみ可能\n                // 1: to[to][j][1] が true のときのみ可能\n                if(i+j+1 <= sz[cur]-1) {\n                    if(dp[to][j][0] < 0 or dp[to][j][1] == true) {\n                        tmp[nxt][i+j+1][1] |= tmp[now][i][1];\n                    }\n                }\n            }\n        }\n        for(int i=0; i<sz[cur]; i++) {\n            tmp[now][i][0] = INF;\n            tmp[now][i][1] = false;\n        }\n    }\n\n    for(int i=0; i<sz[cur]; i++) {\n        dp[cur][i][0] = tmp[cnt%2][i][0];\n        dp[cur][i][1] = tmp[cnt%2][i][1];\n    }\n    /*\n    fprintf(stderr, \"# debug: cur = %lld (size = %lld)\\n\", cur, sz[cur]);\n    fprintf(stderr, \"zro:\");\n    for(int i=0; i<sz[cur]; i++) {\n        fprintf(stderr, \" %lld\", dp[cur][i][0]);\n    }\n    fprintf(stderr, \"\\n\");\n    fprintf(stderr, \"one:\");\n    for(int i=0; i<sz[cur]; i++) {\n        fprintf(stderr, \" %lld\", dp[cur][i][1]);\n    }\n    fprintf(stderr, \"\\n\");\n    */\n}\n\nsigned main() {\n    cin >> N;\n    for(int i=0; i<N; i++) {\n        for(int j=0; j<N; j++) {\n            // 最小値なので\n            dp[i][j][0] = INF;\n        }\n    }\n    \n    for(int i=0; i<N; i++) {\n        cin >> A[i];\n    }\n    for(int i=0; i<N-1; i++) {\n        int u, v; cin >> u >> v;\n        u--; v--;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n\n    dfs(0);\n    solve(0);\n    int ans = INF;\n    for(int i=0; i<=N; i++) {\n        if(dp[0][i][0] < 0) ans = min(ans, i);\n        if(dp[0][i][1] == true) ans = min(ans, i);\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <numeric>\n#include <functional>\n#include <tuple>\n\ntemplate <class T, class U>\ninline bool chmin(T& lhs, const U& rhs) {\n  if (lhs > rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\ntemplate <class T, class U>\ninline bool chmax(T& lhs, const U& rhs) {\n  if (lhs < rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\n// [l, r) from l to r\nstruct range {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { ++i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr l, r;\n  constexpr range(int l_, int r_): l(std::min<int>(l_, r_)), r(r_) {}\n  constexpr itr begin() const { return l; }\n  constexpr itr end() const { return r; }\n};\n\n// [l, r) from r to l\nstruct revrange {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { --i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr r, l;\n  constexpr revrange(int l_, int r_): r(std::max<int>(l_, r_) - 1), l(l_ - 1) {}\n  constexpr itr begin() const { return r; }\n  constexpr itr end() const { return l; }\n};\n\ntemplate <class T>\ninline T scan() {\n  T res;\n  std::cin >> res;\n  return res;\n}\n\nusing lint = long long;\nconstexpr int inf = (1 << 30) - 1;\nconstexpr lint linf = (1ll << 60) - 1;\n\nint N;\nint A[5000], cnt[5000];\nstd::vector<int> graph[5000];\nlint calc[5000][2], dp[5000][5000][2];\n\nvoid dfs(int v, int p) {\n  cnt[v] = 1;\n  chmin(dp[v][0][0], A[v]);\n  if (A[v] > 0) {\n    chmin(dp[v][0][1], A[v]);\n  }\n  for (int x: graph[v]) {\n    if (x == p) {\n      continue;\n    }\n    dfs(x, v);\n    for (int i: range(0, cnt[v] + cnt[x])) {\n      calc[i][0] = calc[i][1] = linf;\n    }\n    for (int i: range(0, cnt[v])) {\n      for (int j: range(0, cnt[x])) {\n        chmin(calc[i + j][0], dp[v][i][0] + dp[x][j][0]);\n        chmin(calc[i + j][0], dp[v][i][0] + dp[x][j][1]);\n        chmin(calc[i + j][1], dp[v][i][1] + dp[x][j][1]);\n        if (dp[x][j][1] < linf) {\n          chmin(calc[i + j + 1][0], dp[v][i][0]);\n          chmin(calc[i + j + 1][1], dp[v][i][1]);\n        }\n        if (dp[x][j][0] < 0) {\n          chmin(calc[i + j + 1][0], dp[v][i][0]);\n          chmin(calc[i + j + 1][1], dp[v][i][1]);\n        }\n      }\n    }\n    cnt[v] += cnt[x];\n    for (int i: range(0, cnt[v])) {\n      dp[v][i][0] = calc[i][0];\n      dp[v][i][1] = calc[i][1];\n    }\n  }\n}\n\nint main() {\n  std::cin >> N;\n  for (int i: range(0, N)) {\n    std::cin >> A[i];\n  }\n  for (int i: range(0, N - 1)) {\n    int u, v;\n    std::cin >> u >> v;\n    --u; --v;\n    graph[u].push_back(v);\n    graph[v].push_back(u);\n  }\n  for (int i: range(0, N)) {\n    for (int j: range(0, N)) {\n      dp[i][j][0] = dp[i][j][1] = linf;\n    }\n  }\n  dfs(0, -1);\n  int ans = inf;\n  for (int j: range(0, N)) {\n    if (dp[0][j][0] < 0) {\n      chmin(ans, j);\n    }\n    if (dp[0][j][1] < linf) {\n      chmin(ans, j);\n    }\n  }\n  std::cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) begin(v),end(v)\n#define fi first\n#define se second\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1; } return 0; }\nusing ll = long long;\nusing pii = pair<int, int>;\nconstexpr ll INF = 1ll<<30;\nconstexpr ll longINF = 1ll<<60;\nconstexpr ll MOD = 1000000007;\nconstexpr bool debug = 0;\n//---------------------------------//\n\nint N;\nint A[5000];\nvector<int> g[5000];\nll dp[5000][5000][2];\nll dp2[5000][2];\n\nint dfs(int u, int par) {\n\tint res = 1;\n\tdp[u][0][A[u] > 0] = A[u];\n\t\n\tfor (int v : g[u]) if (v != par) {\n\t\tint c = dfs(v, u);\n\t\tfill(dp2[0], dp2[res + c], longINF);\n\t\tREP(i, res) {\n\t\t\tREP(j, c) {\n\t\t\t\tREP(k, 2) REP(l, 2) {\n\t\t\t\t\tif (dp[u][i][k] != longINF && dp[v][j][l] != longINF) {\n\t\t\t\t\t\tchmin(dp2[i + j][k == 1 && l == 1], dp[u][i][k] + dp[v][j][l]);\n\t\t\t\t\t\tif (l == 0 && dp[v][j][l] >= 0) continue;\n\t\t\t\t\t\tchmin(dp2[i + j + 1][k], dp[u][i][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(i, res + c) REP(j, 2) dp[u][i][j] = dp2[i][j];\n\t\tres += c;\n\t}\n\treturn res;\n}\n\nint main() {\n\tcin >> N;\n\tREP(i, N) scanf(\"%d\", A + i);\n\tREP(i, N - 1) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\t--u; --v;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\t\n\tfill(dp[0][0], dp[N][0], longINF);\n\tdfs(0, -1);\n\t\n\tint ans = N - 1;\n\tREP(i, N) if (dp[0][i][0] < 0 || dp[0][i][1] != longINF) {\n\t\tans = i;\n\t\tbreak;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint     = long long;\nconst lint inf = 1LL << 60;\nconst lint mod = 1000000007;\n\ntemplate <class T>\nbool chmax(T &a, const T &b) {\n    return (a < b) ? (a = b, 1) : 0;\n}\ntemplate <class T>\nbool chmin(T &a, const T &b) {\n    return (b < a) ? (a = b, 1) : 0;\n}\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    vector<lint> a(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n    }\n    vector<vector<int>> edges(n);\n    for (int i = 0; i < n - 1; ++i) {\n        int u, v;\n        cin >> u >> v;\n        u--, v--;\n        edges[u].emplace_back(v);\n        edges[v].emplace_back(u);\n    }\n    vector<vector<lint>> dp1(n + 1, vector<lint>(n + 1, inf)); // all battery\n    vector<vector<lint>> dp2(n + 1, vector<lint>(n + 1, inf)); // minimum elec\n    vector<lint> size(n, 1);\n    function<void(int, int)> dfss = [&](int c, int p) {\n        for (auto &v : edges[c]) {\n            if (v == p)\n                continue;\n            dfss(v, c);\n            size[c] += size[v];\n        }\n    };\n    dfss(0, -1);\n    function<void(int, int)> dfs = [&](int c, int p) {\n        bool first = true;\n        int s      = 1;\n        vector<vector<lint>> d1(2, vector<lint>(n + 1, inf));\n        vector<vector<lint>> d2(2, vector<lint>(n + 1, inf));\n        for (auto &v : edges[c]) {\n            if (v == p)\n                continue;\n            s += size[v];\n            dfs(v, c);\n            if (first) {\n                first = false;\n                for (int i = 0; i <= s; ++i) {\n                    if (a[c] > 0) {\n                        if (dp1[v][i] < inf) {\n                            chmin(d1[0][i], dp1[v][i] + a[c]);\n                            chmin(d1[0][i + 1], a[c]);\n                        }\n                        if (dp2[v][i] < 0)\n                            chmin(d1[0][i + 1], a[c]);\n                    }\n                    chmin(d2[0][i], dp2[v][i] + a[c]);\n                    if (dp2[v][i] < 0)\n                        chmin(d2[0][i + 1], a[c]);\n                    if (dp1[v][i] < inf)\n                        chmin(d2[0][i + 1], a[c]);\n                }\n            } else {\n                for (int i = s; i >= 0; --i) {\n                    for (int j = 0; j <= i; ++j) {\n                        // cut\n                        if (d1[0][j] < inf && dp1[v][i - j] < inf)\n                            chmin(d1[1][i + 1], d1[0][j]);\n                        if (d2[0][j] < inf && dp2[v][i - j] < 0)\n                            chmin(d2[1][i + 1], d2[0][j]);\n                        if (d2[0][j] < inf && dp1[v][i - j] < inf)\n                            chmin(d2[1][i + 1], d2[0][j]);\n                        if (d1[0][j] < inf && dp2[v][i - j] < 0)\n                            chmin(d1[1][i + 1], d1[0][j]);\n                        // no cut\n                        if (d1[0][j] < inf && dp1[v][i - j] < inf)\n                            chmin(d1[1][i], d1[0][j] + dp1[v][i - j]);\n                        if (d2[0][j] < inf && dp2[v][i - j] < inf)\n                            chmin(d2[1][i], d2[0][j] + dp2[v][i - j]);\n                        if (d2[0][j] < inf && dp1[v][i - j] < inf)\n                            chmin(d2[1][i], d2[0][j] + dp1[v][i - j]);\n                        if (d1[0][j] < inf && dp2[v][i - j] < inf)\n                            chmin(d2[1][i], d1[0][j] + dp2[v][i - j]);\n                    }\n                }\n                swap(d1[0], d1[1]);\n                swap(d2[0], d2[1]);\n            }\n        }\n        swap(dp1[c], d1[0]);\n        swap(dp2[c], d2[0]);\n        if (s == 1) {\n            dp2[c][0] = a[c];\n            if (a[c] > 0)\n                dp1[c][0] = a[c];\n        }\n    };\n    dfs(0, -1);\n    for (int i = 0; i < n; ++i) {\n        if (dp1[0][i] < inf || dp2[0][i] < 0) {\n            cout << i << \"\\n\";\n            return 0;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n\n#define null\t\t\t\t\"\"\n#define all(dat)\t\t\tdat.begin(), dat.end()\n#define over(msg)\t\t\tcout << msg << endl, exit(0);\n#define loop(i, to)\t\t\tfor (int i = 0; i < to; ++i)\n#define cont(i, to)\t\t\tfor (int i = 1; i <= to; ++i)\n#define foreach(i, dat)\t\tfor (__typeof(dat.begin()) i = dat.begin(); i != dat.end(); ++i)\n\ntypedef long long\t\t\tnum;\n\nusing namespace std;\n\nint n;\nnum inf = 1e15, sz[50005], w[5005], dp[2][5005][5005], tmp[2][5005];\nvector<int> g[5005];\n\ninline num min(num a, num b) {\n\treturn a < b ? a : b;\n}\n\nvoid dfs(int u, int p) {\n\tsz[u] = 1;\n\tcont (s, 5000) {\n\t\tdp[0][u][s] = dp[1][u][s] = inf;\n\t}\n\tdp[0][u][1] = w[u] < 0 ? inf : w[u];\n\tdp[1][u][1] = w[u];\n\tfor (int v : g[u]) {\n\t\tif (v == p)  continue;\n\t\tdfs(v, u);\n\t\tcont (s, sz[u] + sz[v]) {\n\t\t\ttmp[0][s] = tmp[1][s] = inf;\n\t\t}\n\t\tcont (s1, sz[u]) {\n\t\t\tcont (s2, sz[v]) {\n\t\t\t\tint s = s1 + s2;\n\t\t\t\tif (dp[0][v][s2] < inf) {\n\t\t\t\t\ttmp[0][s] = min(tmp[0][s], dp[0][u][s1]);\n\t\t\t\t\ttmp[1][s] = min(tmp[1][s], dp[1][u][s1]);\n\t\t\t\t}\n\t\t\t\tif (dp[1][v][s2] < 0) {\n\t\t\t\t\ttmp[0][s] = min(tmp[0][s], dp[0][u][s1]);\n\t\t\t\t\ttmp[1][s] = min(tmp[1][s], dp[1][u][s1]);\n\t\t\t\t}\n\t\t\t\ttmp[0][s - 1] = min(tmp[0][s - 1], dp[0][u][s1] + dp[0][v][s2]);\n\t\t\t\ttmp[1][s - 1] = min(tmp[1][s - 1], dp[1][u][s1] + dp[1][v][s2]);\n\t\t\t}\n\t\t}\n\t\tsz[u] += sz[v];\n\t\tcont (s, sz[u]) {\n\t\t\tdp[0][u][s] = tmp[0][s];\n\t\t\tdp[1][u][s] = tmp[1][s];\n\t\t}\n\t}\n}\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin >> n;\n\tcont (i, n) {\n\t\tcin >> w[i];\n\t}\n\tcont (i, n - 1) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\tdfs(1, -1);\n\tcont (cnt, n) {\n\t\tif (dp[0][1][cnt] < inf || dp[1][1][cnt] < 0) {\n\t\t\tcout << cnt - 1 << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N, A[5000];\nvector<int> edges[5000];\n\nconst int64_t INF = 1e18;\nint64_t dp[5000][5001][2], sub[5001][2];\nint num[5000];\nvoid chmin(int64_t& a, int64_t b){\n    a = min(a, b);\n}\n\nvoid dfs(int i, int par){\n    for(int j : edges[i]) if(j != par) dfs(j, i);\n\n    int sum = 1;\n    dp[i][0][A[i] < 0] = A[i];\n\n    for(int j : edges[i]) if(j != par){\n\n        for(int n1=0; n1<sum; n1++){\n            for(int n2=0; n2<num[j]; n2++){\n                for(int k1=0; k1<2; k1++){\n                    for(int k2=0; k2<2; k2++){\n                        // 辺を繋ぐ場合\n                        chmin(sub[n1+n2][k1|k2], dp[i][n1][k1] + dp[j][n2][k2]);\n                        // 辺を切る場合\n                        if((k2==0 && dp[j][n2][k2] < INF) || dp[j][n2][k2] < 0) chmin(sub[n1+n2+1][k1], dp[i][n1][k1]);\n                    }\n                }\n            }\n        }\n\n        sum += num[j];\n        for(int n=0; n<sum; n++) for(int k=0; k<2; k++){\n            dp[i][n][k] = sub[n][k];\n            sub[n][k] = INF;\n        }\n    }\n\n    num[i] = sum;\n}\n\nint main(){\n    cin >> N;\n    for(int i=0; i<N; i++) cin >> A[i];\n    for(int i=0; i<N-1; i++){\n        int a, b;\n        cin >> a >> b;\n        edges[a-1].push_back(b-1);\n        edges[b-1].push_back(a-1);\n    }\n\n    for(int j=0; j<N; j++) for(int k=0; k<2; k++){\n        for(int i=0; i<N; i++) dp[i][j][k] = INF;\n        sub[j][k] = INF;\n    }\n\n    dfs(0, -1);\n\n    int ans = N-1;\n    for(int n=0; n<N; n++){\n        if(dp[0][n][0] < INF) ans = min(ans, n);\n        if(dp[0][n][1] < 0) ans = min(ans, n);\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N = 5e3 + 10;\nconst ll oo = 1e16;\n\nint n;\nll a[N];\nvector<int> adj[N];\nll dp[N][2][N], tmp[2][N], sz[N];\n\nvoid dfs(int u, int par){\n    dp[u][0][0] = (a[u] > 0);\n    dp[u][1][0] = a[u];\n    sz[u] = 1;\n    for(int v: adj[u]) if(v != par) {\n        dfs(v, u);\n        fill(tmp[0], tmp[0] + n, 0);\n        fill(tmp[1], tmp[1] + n, oo);\n        for(int k = sz[u] - 1; k >= 0; k--)\n            for(int l = sz[v] - 1; l >= 0; l--){\n                if(dp[u][0][k] && dp[v][1][l]<0)\n                    tmp[0][k + l + 1] = 1;\n                if(dp[u][0][k] && dp[v][0][l])\n                    tmp[0][k + l]=1;\n                if(dp[u][1][k] < oo && dp[v][0][l])\n                    tmp[1][k + l + 1] = min(tmp[1][k + l + 1], dp[u][1][k]);\n                if(dp[u][1][k] < oo && dp[v][1][l] < oo)\n                    tmp[1][k + l] = min(tmp[1][k + l], dp[u][1][k] + dp[v][1][l]);\n            }\n        sz[u] += sz[v];\n        swap(dp[u], tmp);\n    }\n}\n\nint main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> n;\n    for (int i = 0; i < n; i++)\n        cin >> a[i];\n    for (int i = 1; i < n; i++) {\n        int x, y;\n        cin >> x >> y;\n        x--; y--;\n        adj[x].push_back(y);\n        adj[y].push_back(x);\n    }\n    dfs(0, -1);\n    for(int i = 0; i < n; i++)\n        if(dp[0][0][i] || dp[0][1][i] < 0) {\n            cout << i;\n            return 0;\n        }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll MOD = 1e9+7;\nconst ll INF = 1e18;\n\nsigned main()\n{\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for(auto& y : a)\n        cin >> y;\n    vector<int> u(n - 1);\n    vector<int> v(n - 1);\n    for(int i = 0; i < n - 1; ++i){\n        cin >> u[i] >> v[i];\n        --u[i];\n        --v[i];\n    }\n    vector<vector<int>> edges(n);\n    for(int i = 0; i < n - 1; ++i){\n        edges[u[i]].push_back(v[i]);\n        edges[v[i]].push_back(u[i]);\n    }\n    vector<int> size(n, 1);\n\n    bitset<5000> flag;\n    function<void(int)> siz = [&](int x){\n        for(auto& y : edges[x])\n            if(!flag[y]){\n                flag[y] = 1;\n                siz(y);\n                size[x] += size[y];\n            }\n    };\n    flag[0] = 1;\n    siz(0);\n    flag.reset();\n\n    function<vector<vector<ll>>(int)> f = [&](int x){\n        vector<vector<ll>> dp(1, vector<ll>(2, INF));\n        dp[0][0] = a[x];\n        if(a[x] > 0)\n            dp[0][1] = a[x];\n\n        int sizesum = 0;\n        for(auto& y : edges[x]){\n            if(flag[y])\n                continue;\n            flag[y] = 1;\n            auto from = f(y);\n\n            vector<vector<ll>> next(sizesum + size[y] + 1, vector<ll>(2, INF));\n\n            for(int i = 0; i <= sizesum; ++i){\n                for(int j = 0; j < size[y]; ++j){\n                    next[i + j][0] = min(next[i + j][0], dp[i][0] + from[j][0]);\n                    next[i + j][0] = min(next[i + j][0], dp[i][0] + from[j][1]);\n                    next[i + j][0] = min(next[i + j][0], dp[i][1] + from[j][0]);\n                    next[i + j][0] = min(next[i + j][0], dp[i][1] + from[j][1]);\n                    if(a[x] > 0 && from[j][1] != INF)\n                        next[i + j][1] = min(next[i + j][1], dp[i][1] + from[j][1]);\n                    // 分断が可能なら\n                    if(from[j][0] < 0 || from[j][1] != INF){\n                        next[i + j + 1][0] = min(next[i + j + 1][0], dp[i][0]);\n                        if(a[x] > 0)\n                            next[i + j + 1][1] = min(next[i + j + 1][1], dp[i][1]);\n                    }\n                }\n            }\n            dp = move(next);\n            sizesum += size[y];\n        }\n        return dp;\n    };\n    flag[0] = 1;\n    auto dp = f(0);\n    int ans = 1e9;\n    for(int j = 0; j <= n; ++j){\n        if(dp[j][0] < 0)\n            ans = min(ans, j);\n        if(dp[j][1] != INF)\n            ans = min(ans, j);\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <iomanip>\n#define MOD 1000000007\ntypedef long long ll;\nusing namespace std;\n\nint N;\nll A[5050];\nvector<int> g[5050];\n\nll dp[5050][5050][2];\nll memo[5050][2];\nint num[5050];\nconst ll INF=1e18;\n\nvoid dfs(int now,int par){\n  for(int next:g[now]){\n    if(next==par) continue;\n    dfs(next,now);\n  }\n\n  int sum=1;\n  if(A[now]<0) dp[now][0][1]=A[now];\n  else dp[now][0][0]=A[now];\n\n  for(int next:g[now]){\n    if(next==par) continue;\n    for(int i=0;i<sum;i++){\n      for(int j=0;j<num[next];j++){\n        for(int k=0;k<2;k++){\n          for(int l=0;l<2;l++){\n            memo[i+j][k|l]=min(memo[i+j][k|l],dp[now][i][k]+dp[next][j][l]);\n\n            if(dp[next][j][l]<0||(l==0&&dp[next][j][l]<INF)){\n              memo[i+j+1][k]=min(memo[i+j+1][k],dp[now][i][k]);\n            }\n          }\n        }\n      }\n    }\n\n    sum+=num[next];\n    for(int i=0;i<sum;i++){\n      for(int k=0;k<2;k++){\n        dp[now][i][k]=memo[i][k];\n        memo[i][k]=INF;\n      }\n    }\n  }\n  num[now]=sum;\n}\n\nint main(){\n  cin>>N;\n  for(int i=0;i<N;i++) cin>>A[i];\n  for(int i=1;i<N;i++){\n    int u,v;\n    cin>>u>>v;\n    u--;v--;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n\n  for(int i=0;i<=N;i++){\n    for(int k=0;k<2;k++){\n      for(int j=0;j<=N;j++){\n        dp[i][j][k]=INF;\n      }\n      memo[i][k]=INF;\n    }\n  }\n\n  dfs(0,-1);\n\n  int ans=N-1;\n  for(int i=0;i<N;i++){\n    if(dp[0][i][0]<INF) ans=min(ans,i);\n    if(dp[0][i][1]<0) ans=min(ans,i);\n  }\n  cout<<ans<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// failed to generate code\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef ENABLE_DEBUG\n#define DEBUG(a) cerr<<#a<<\"=\"<<endl\n#define DEBUG_ARRAY(a,n) cerr<<#a<<\"[\"<<n<<\"]=\"<<a[n]<<endl\n#else\n#define DEBUG(a) \n#define DEBUG_ARRAY(a,n) \n#endif\n#define P(a,b) make_pair(a,b)\n#define FOR(i, a, b) for(int i = a;i < b;i++)\n#define For(i, a) FOR(i, 0, a)\n#define REV(i, a, b) for(int i = b-1;i >= a;i--)\n#define Rev(i, a) REV(i, 0, a)\n#define REP(a) For(i, a)\n#define INF (1L<<55)\n\ntypedef long long int ll;\ntypedef unsigned long long ull;\ntypedef unsigned int uint;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vll;\n\nlong N;\nlong A[5000];\nvector<long> m[5000];\nlong dp1[5000],nd[5000],dp2[5000][5000],curdp[5000];\n\nvoid dfs(long cur=0,long prev=-1){\n    nd[cur]=1;\n    dp2[cur][0]=A[cur];\n    for(size_t i = 0; i < m[cur].size(); i++)\n    {\n        long to=m[cur][i];\n        if(to!=prev){\n            dfs(to,cur);\n            if(A[cur]>0){\n                long pl=INF;\n                if(A[to]>0){\n                    pl=min(pl,dp1[to]);\n                }\n                for(long j = 0; j < nd[to]; j++)\n                {\n                    if(dp2[to][j]<0){\n                        pl=min(pl,j+1);\n                    }\n                }\n                dp1[cur]+=pl;\n            }\n            for(long j = 0; j < nd[cur]+nd[to]; j++)\n            {\n                curdp[j]=INF;\n            }\n            for(long j = 0; j < nd[cur]; j++)\n            {\n                for(long k = 0; k < nd[to]; k++)\n                {\n                    curdp[j+k]=min(curdp[j+k],dp2[cur][j]+dp2[to][k]);\n                    if(dp2[to][k]<0)curdp[j+k+1]=min(curdp[j+k+1],dp2[cur][j]);\n                }\n                if(A[to]>0){\n                    curdp[j+dp1[to]+1]=min(curdp[j+dp1[to]+1],dp2[cur][j]);\n                }\n            }\n            nd[cur]+=nd[to];\n            for(long j=0;j<nd[cur];j++){\n                dp2[cur][j]=curdp[j];\n            }\n        }\n    }\n}\n\nint main(){\t\n    ios::sync_with_stdio(false);\n    cin>>N;\n    REP(N){\n        cin>>A[i];\n    }\n    REP(N-1){\n        long tmp1,tmp2;\n        cin>>tmp1>>tmp2;\n        tmp1--;tmp2--;\n        m[tmp1].push_back(tmp2);\n        m[tmp2].push_back(tmp1);\n    }\n    dfs();\n    long ret=5005;\n    if(A[0]>0){\n        ret=dp1[0];\n    }\n    for(long i = 0; i < 5000; i++)\n    {\n        if(dp2[0][i]<0){\n            ret=min(ret,i);\n        }\n    }\n    cout<<ret<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define i_7 (ll)(1E9+7)\n#define i_5 (ll)(1E9+5)\nll mod(ll a){\n    ll c=a%i_7;\n    if(c>=0)return c;\n    else return c+i_7;\n}\ntypedef pair<int,int> i_i;\ntypedef pair<ll,ll> l_l;\nll inf=(ll)1E12;\n#define rep(i,l,r) for(ll i=l;i<=r;i++)\n#define pb push_back\nll max(ll a,ll b){if(a<b)return b;else return a;}\nll min(ll a,ll b){if(a>b)return b;else return a;}\nvoid Max(ll * pos,ll val){*pos=max(*pos,val);}//Max(&dp[i][j],dp[i-1][j]);\nvoid Min(ll * pos,ll val){*pos=min(*pos,val);}\nvoid Add(ll * pos,ll val){*pos=mod(*pos+val);}\nconst long double EPS=1E-8;\n////////////////////////////////////////\n\nint main(){\n    ll n;cin>>n;\n    ll a[n];rep(i,0,n-1)cin>>a[i];\n    vector<ll>v[n];\n    rep(i,1,n-1){\n        ll c,d;cin>>c>>d;c--;d--;\n        v[c].pb(d);v[d].pb(c);\n    }\n    ll p[n];p[0]=-2;rep(i,1,n-1)p[i]=-1;\n    vector<ll>chi[n];\n    queue<ll>q;q.push(0);\n    ll d[n];d[0]=1;\n    vector<ll>vd[n];vd[1].pb(0);\n    ll dmax=1;\n    while(!q.empty()){\n        ll t=q.front();q.pop();\n        for(auto x:v[t]){\n            if(p[x]==-1){\n                chi[t].pb(x);\n                p[x]=t;\n                q.push(x);\n                d[x]=d[t]+1;\n                vd[d[x]].pb(x);\n                Max(&dmax,d[x]);\n            }\n        }\n    }\n    /*rep(i,0,n-1){\n        cout<<p[i]<<\"  \";for(auto x:chi[i])cout<<x<<\" \";cout<<endl;\n    }*/\n    ll dp1[n];\n    ll dp2[n][n+1];rep(i,0,n-1)rep(j,0,n)dp2[i][j]=inf;\n    for(ll dep=dmax;dep>=1;dep--){\n        for(auto x:vd[dep]){\n            if(chi[x].size()==0){\n                if(a[x]>0){\n                    dp1[x]=1;\n                    dp2[x][1]=a[x];\n                }else{\n                    dp1[x]=inf;\n                    dp2[x][1]=a[x];\n                }\n            }else{\n                if(a[x]<0){\n                    dp1[x]=inf;\n                }else{\n                    ll count=1;\n                    for(auto y:chi[x]){\n                        if(a[y]>0){\n                            count+=dp1[y]-1;\n                        }else{\n                            rep(j,1,n+1){\n                                if(dp2[y][j]!=inf){\n                                    count+=j;\n                                    break;\n                                }else if(j==n+1){\n                                    cout<<-111;return 0;\n                                }\n                            }\n                        }\n                    }\n                    dp1[x]=count;\n                }\n                \n                \n            }\n        }\n    }\n    \n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#ifndef LOCAL\n#define debug(x) ;\n#else\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\ntemplate <typename T1, typename T2>\nostream &operator<<(ostream &out, const pair<T1, T2> &p) {\n  out << \"{\" << p.first << \", \" << p.second << \"}\";\n  return out;\n}\n\ntemplate <typename T>\nostream &operator<<(ostream &out, const vector<T> &v) {\n  out << '{';\n  for (const T &item : v) out << item << \", \";\n  out << \"\\b\\b}\";\n  return out;\n}\n#endif\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 5010\n\nint n;\nint a[SIZE];\nvector<int> tree[SIZE];\n\nll dp[SIZE][SIZE][2];\nbool dp2[SIZE][SIZE][2];\n\nint dfs(int now, int prev = -1) {\n  int sum_child = 1;\n\n  dp[now][0][0] = a[now];\n  dp2[now][0][0] = a[now] > 0;\n\n  for(int to : tree[now]) {\n    if (prev == to) continue;\n    int child = dfs(to, now);\n\n    for(int i=0;i<=sum_child;i++){\n      for(int j=0;j<=child;j++){\n        dp[now][i+j][1] = min(dp[now][i+j][1], dp[now][i][0] + dp[to][j][0]);\n        dp2[now][i+j][1] = dp2[now][i+j][1] || (dp2[now][i][0] && dp2[to][j][0]);\n      }\n    }\n    sum_child += child;\n\n    for(int i=0;i<=sum_child;i++){\n      dp[now][i][0] = dp[now][i][1];\n      dp2[now][i][0] = dp2[now][i][1];\n      dp[now][i][1] = LLINF;\n      dp2[now][i][1] = false;\n    }\n  }\n\n  for(int i=0;i<sum_child;i++){\n    if(dp2[now][i][0] || dp[now][i][0] < 0) {\n      dp2[now][i+1][0] = true;\n      dp[now][i+1][0] = min(dp[now][i+1][0], 0LL);\n    }\n  }\n\n  debug(sum_child);\n  return sum_child;\n}\n\nint main(){\n  scanf(\"%d\", &n);\n\n  for(int i=0;i<n;i++){\n    scanf(\"%d\", a+i);\n  }\n\n  for(int i=0;i<n-1;i++){\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    u--; v--;\n    tree[u].push_back(v);\n    tree[v].push_back(u);\n  }\n\n  for(int i=0;i<=n;i++){\n    for(int j=0;j<=n;j++){\n      dp[i][j][0] = dp[i][j][1] = LLINF;\n      dp2[i][j][0] = dp2[i][j][1] = false;\n    }\n  }\n\n  dfs(0);\n\n  int ans = INF;\n\n  for(int i=0;i<n;i++){\n    if(dp2[0][i][0]) ans = min(ans, i);\n    if(dp[0][i][0] < 0) ans = min(ans, i);\n  }\n\n  assert(ans != INF);\n\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1LL<<60)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n;\nll a[5005];\nll a2[5005];\nvector<int> G[5005];\nvector<int> G2[5005];\nint cmp[5005];\nll dp[5005][5005][2];\nint sz[5005];\nint cnt2[5005];\n\nvoid dfs(int v,int c){\n    cmp[v]=c;\n    if(a[v]<0LL)return;\n    for(int i=0;i<G[v].size();i++){\n        int nv=G[v][i];\n        if(a[nv]>0LL && cmp[nv]==-1){\n            dfs(nv,c);\n        }\n    }\n}\n\nint dfs2(int v,int p){\n    sz[v]=1;\n    for(int i=0;i<G[v].size();i++){\n        int nv=G[v][i];\n        if(nv!=p){\n            sz[v]+=dfs2(nv,v);\n        }\n    }\n    return sz[v];\n}\n\nll tmp[5005][2];\n\nvoid dfs3(int v,int p){\n    int szc=1;\n    if(a[v]<0LL)dp[v][0][1]=a[v];\n    else dp[v][0][0]=a[v];\n    cnt2[v]++;\n    assert(cnt2[v]==1);\n    for(int i=0;i<G[v].size();i++){\n        int nv=G[v][i];\n        if(nv==p)continue;\n        dfs3(nv,v);\n        for(int j=0;j<=szc+sz[nv];j++){\n            tmp[j][0]=INF;\n            tmp[j][1]=INF;\n        }\n        for(int j=0;j<szc;j++){\n            for(int k=0;k<sz[nv];k++){\n                tmp[j+k][0]=min(tmp[j+k][0],dp[v][j][0]+dp[nv][k][0]);\n                tmp[j+k][1]=min(tmp[j+k][1],dp[v][j][1]+dp[nv][k][0]);\n                tmp[j+k][1]=min(tmp[j+k][1],dp[v][j][0]+dp[nv][k][1]);\n                tmp[j+k][1]=min(tmp[j+k][1],dp[v][j][1]+dp[nv][k][1]);\n                if(dp[nv][k][1]<0LL || dp[nv][k][0]!=INF)tmp[j+k+1][1]=min(tmp[j+k+1][1],dp[v][j][1]);\n                if(dp[nv][k][1]<0LL || dp[nv][k][0]!=INF)tmp[j+k+1][0]=min(tmp[j+k+1][0],dp[v][j][0]);\n            }\n        }\n        for(int j=0;j<=szc+sz[nv];j++){\n            dp[v][j][0]=tmp[j][0];\n            dp[v][j][1]=tmp[j][1];\n        }\n        szc+=sz[nv];\n    }\n    /*\n    printf(\"%d\\n\",v);\n    for(int i=0;i<=szc;i++){\n        printf(\"%lld %lld\\n\",dp[v][i][0],dp[v][i][1]);\n    }\n     */\n}\n\nint main(void){\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%lld\",&a[i]);\n    }\n    for(int i=0;i<n-1;i++){\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        u--;\n        v--;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    memset(cmp,-1,sizeof(cmp));\n    int sz=0;\n    for(int i=0;i<n;i++){\n        if(cmp[i]==-1){\n            dfs(i,sz++);\n        }\n        //printf(\"%d \",cmp[i]);\n    }\n    //printf(\"\\n\");\n    for(int i=0;i<n;i++){\n        a2[cmp[i]]+=a[i];\n        for(int j=0;j<G[i].size();j++){\n            int nv=cmp[G[i][j]];\n            if(nv!=cmp[i]){\n                G2[cmp[i]].push_back(nv);\n                G2[nv].push_back(cmp[i]);\n            }\n        }\n    }\n    for(int i=0;i<sz;i++){\n        sort(G2[i].begin(),G2[i].end());\n        G2[i].erase(unique(G2[i].begin(),G2[i].end()),G2[i].end());\n    }\n    dfs2(0,-1);\n    for(int i=0;i<=sz;i++){\n        for(int j=0;j<=sz;j++){\n            for(int k=0;k<2;k++){\n                dp[i][j][k]=1LL<<60;\n            }\n        }\n    }\n    dfs3(0,-1);\n    int ans=n-1;\n    for(int i=0;i<n;i++){\n        if(dp[0][i][0]<0LL || dp[0][i][1]<0LL)ans=min(ans,i);\n        if(dp[0][i][0]!=INF)ans=min(ans,i);\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <fstream>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <complex>\n#include <iomanip>\n#include <stdio.h>\n#include <string.h>\n#include <random>\n#include <functional>\n\nusing std::cin;\nusing std::cout;\nusing std::cerr;\nusing std::endl;\n\nusing std::map;\nusing std::set;\nusing std::bitset;\nusing std::vector;\nusing std::string;\nusing std::multimap;\nusing std::multiset;\nusing std::deque;\nusing std::queue;\nusing std::stack;\nusing std::pair;\nusing std::iterator;\n\nusing std::sort;\nusing std::stable_sort;\nusing std::reverse;\nusing std::max_element;\nusing std::min_element;\nusing std::unique;\nusing std::ios_base;\nusing std::swap;\nusing std::fill;\n\nusing std::setprecision;\nusing std::fixed;\n\nlong long min(long long a, long long b) {return a < b ? a : b;}\nlong long min(int a, long long b) {return a < b ? a : b;}\nlong long min(long long a, int b) {return a < b ? a : b;}\nlong long min(int a, int b) {return a < b ? a : b;}\n\nlong long max(long long a, long long b) {return a > b ? a : b;}\nlong long max(int a, long long b) {return a > b ? a : b;}\nlong long max(long long a, int b) {return a > b ? a : b;}\nlong long max(int a, int b) {return a > b ? a : b;}\n\n#define int long long\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<long long> vl;\ntypedef string S;\n\n#define F(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define fi first\n#define se second\n#define re return\n#define all(x) (x).begin(), (x).end()\n\nconst long long INF = 1e18;\nconst int N = 10100;\nconst int MOD = 1e9 + 7;\nconst double eps = 1e-8;\n\nint n;\nint a[N];\nvector<int> graph[N];\nint dp[2][N][N / 2];\nint last_dinamics[N];\nint last_state[N];\nint tmp = 0;\n\nvoid Merge(int p1, int p2)\n{\n    for (int a = 0; a <= last_state[p1]; a++)\n    {\n        for (int b = 0; b <= last_state[p2]; b++)\n        {\n            dp[0][tmp][a + b] = min(dp[0][tmp][a + b], dp[0][p1][a] + dp[0][p2][b]);\n            if (dp[0][p2][b] < INF) dp[0][tmp][a + b + 1] = min(dp[0][tmp][a + b + 1], dp[0][p1][a]);\n            if (dp[1][p2][b] < 0) dp[0][tmp][a + b + 1] = min(dp[0][tmp][a + b + 1], dp[0][p1][a]);\n            dp[1][tmp][a + b] = min(dp[1][tmp][a + b], min(dp[0][p1][a], dp[1][p1][a]) + min(dp[0][p2][b], dp[1][p2][b]));\n            if (dp[0][p2][b] < INF) dp[1][tmp][a + b + 1] = min(dp[1][tmp][a + b + 1], min(dp[0][p1][a], dp[1][p1][a]));\n            if (dp[1][p2][b] < 0) dp[1][tmp][a + b + 1] = min(dp[1][tmp][a + b + 1], min(dp[0][p1][a], dp[1][p1][a]));\n        }\n    }\n    last_state[tmp] = last_state[p1] + last_state[p2] + 1;\n}\n\nvoid dfs(int v, int parent)\n{\n    int merge1 = tmp;\n    dp[0][tmp][0] = 0, dp[1][tmp][0] = 0;\n    tmp++;\n    for (auto u : graph[v]) if (u != parent)\n    {\n        dfs(u, v);\n        int merge2 = last_dinamics[u];\n        Merge(merge1, merge2);\n        merge1 = tmp;\n        tmp++;\n    }\n    tmp--;\n    for (int i = 0; i < n + 100; i++)\n    {\n        dp[1][tmp][i] = min(dp[1][tmp][i] + a[v], INF);\n        dp[0][tmp][i] = min(dp[0][tmp][i] + a[v], INF);\n    }\n    if (a[v] < 0)\n    {\n        for (int i = 0; i < n + 100; i++) dp[0][tmp][i] = INF;\n    }\n    last_dinamics[v] = tmp;\n    tmp++;\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n;\n    for (int i = 0; i < n + 100; i++)\n    {\n        for (int j = 0; j < n + 100; j++)\n        {\n            dp[0][i][j] = INF, dp[1][i][j] = INF;\n        }\n    }\n    for (int i = 0; i < n; i++)\n    {\n        cin >> a[i];\n    }\n    for (int i = 0; i + 1 < n; i++)\n    {\n        int v, u;\n        cin >> v >> u;\n        v--, u--;\n        graph[v].push_back(u);\n        graph[u].push_back(v);\n    }\n    dfs(0, -1);\n    long long ans = n - 1;\n    for (int i = 0; i < n - 1; i++)\n    {\n        //cout << dp[1][tmp - 1][i] << \" \" << dp[0][tmp - 1][i] << \"\\n\";\n        if (dp[1][tmp - 1][i] < 0) ans = min(ans, i);\n        if (dp[0][tmp - 1][i] < INF) ans = min(ans, i);\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define FOR(i,j,k) for(int (i)=(j);(i)<(int)(k);++(i))\n#define rep(i,j) FOR(i,0,j)\n#define each(x,y) for(auto &(x):(y))\n#define mp make_pair\n#define MT make_tuple\n#define all(x) (x).begin(),(x).end()\n#define debug(x) cout<<#x<<\": \"<<(x)<<endl\n#define smax(x,y) (x)=max((x),(y))\n#define smin(x,y) (x)=min((x),(y))\n#define MEM(x,y) memset((x),(y),sizeof (x))\n#define sz(x) (int)(x).size()\n#define RT return\nusing ll = long long;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vll = vector<ll>;\n\nconst ll INF = LLONG_MAX / 3;\nint A[5001];\nll dp[5001][5001];\nint no[5001][5001], sub[5001];\nvi G[5001];\n\nvoid f(int u, int p) {\n    int &num = sub[u];\n    num = 1;\n    each(v, G[u])if (v != p)f(v, u);\n\n    vll cur(5001, INF), nex(5001);\n    vector<bool> cc(5001, false), nn(5001);\n    cur[0] = A[u];\n    if (A[u] > 0)cc[0] = true;\n    \n    each(v, G[u]) if (v != p) {\n        rep(i, num + sub[v]) {\n            nex[i] = INF;\n            nn[i] = false;\n        }\n        rep(i, num) {\n            rep(j, sub[v]) {\n                // 切断\n                if (dp[v][j] < 0 || no[v][j]) {\n                    smin(nex[i + j + 1], cur[i]);\n                    if (cc[i]) {\n                        nn[i + j + 1] = true;\n                    }\n                }\n                //切断しない\n                if (cc[i] && no[v][j])nn[i + j] = true;\n                smin(nex[i + j], cur[i] + dp[v][j]);\n            }\n        }\n\n        num += sub[v];\n        swap(cur, nex);\n        swap(cc, nn);\n    }\n\n    rep(i, num) {\n        dp[u][i] = cur[i];\n        no[u][i] = cc[i];\n    }\n}\n\nvoid solve() {\n    int N;\n    cin >> N;\n    rep(i, N)cin >> A[i];\n    rep(i, N - 1) {\n        int u, v;\n        cin >> u >> v;\n        --u;\n        --v;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n\n    f(0, -1);\n    int ans = N;\n    rep(i, N) {\n        if (dp[0][i] < 0 || no[0][i])smin(ans, i);\n    }\n    cout << ans << endl;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout << fixed << setprecision(15);\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\nstruct UnionFind{\n  Int n;\n  vector<Int> r,p;\n  UnionFind(){}\n  UnionFind(Int sz):n(sz),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n  Int find(Int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(Int x,Int y){\n    return find(x)==find(y);\n  }\n  void unite(Int x,Int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];\n    p[y]=x;\n  }\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  auto shrink=\n    [&](){\n      Int n;\n      cin>>n;\n      vector<Int> a(n);\n      for(Int i=0;i<n;i++) cin>>a[i];\n      vector<vector<Int> > G(n);\n      for(Int i=1;i<n;i++){\n        Int x,y;\n        cin>>x>>y;\n        x--;y--;\n        G[x].emplace_back(y);\n        G[y].emplace_back(x);\n      }\n      UnionFind uf(n);\n      for(Int v=0;v<n;v++){\n        for(Int u:G[v]){\n          if(a[v]<0&&a[u]<0) uf.unite(u,v);\n          if(a[v]>0&&a[u]>0) uf.unite(u,v);\n        }\n      }\n      \n      vector<Int> vs;\n      for(Int i=0;i<n;i++){\n        if(uf.find(i)!=i) continue;\n        vs.emplace_back(i);\n      }\n      \n      Int m=vs.size();\n      map<Int, Int> rev;\n      for(Int i=0;i<m;i++) rev[vs[i]]=i;\n\n      vector<set<Int> > H(m);\n      vector<Int> na(m,0);\n      for(Int v=0;v<n;v++){\n        na[rev[uf.find(v)]]+=a[v];\n        for(Int u:G[v]){\n          if(uf.same(u,v)) continue;\n          Int x=rev[uf.find(v)],y=rev[uf.find(u)];\n          H[x].emplace(y);\n          H[y].emplace(x);\n        }\n      }\n      \n      vector<vector<Int> > nG(m);\n      for(Int i=0;i<m;i++) nG[i]=vector<Int>(H[i].begin(),H[i].end());\n      return make_tuple(m,na,nG);      \n    };\n  \n  auto graph=shrink();\n  auto n=get<0>(graph);\n  auto a=get<1>(graph);\n  auto G=get<2>(graph);\n  assert((Int)a.size()==n);\n  assert((Int)G.size()==n);\n\n  if(0){\n    cout<<n<<endl;\n    for(Int i=0;i<n;i++) cout<<a[i]<<\" \";\n    cout<<endl;\n    for(Int v=0;v<n;v++){\n      for(Int u:G[v]){\n        cout<<v<<\" \"<<u<<endl;\n      }\n    }\n  }\n  \n  if(n==1){\n    cout<<0<<endl;\n    return 0;\n  }\n\n  const Int INF = 1e17;\n  vector<vector<Int> > dp(n);\n  vector<Int> sum(n,0);\n  \n  function<void(Int, Int)> dfs=\n    [&](Int v,Int par){\n      for(Int u:G[v])\n        if(u!=par) dfs(u,v);\n      \n      dp[v].resize(1);\n      dp[v][0]=a[v];\n      for(Int u:G[v]){\n        if(u==par) continue;\n        const auto &p=dp[v];\n        const auto &q=dp[u];\n        Int x=p.size();\n        Int y=q.size();\n        vector<Int> nx(x+y,INF);\n        for(Int i=0;i<x;i++){\n          for(Int j=0;j<y;j++){\n            chmin(nx[i+j],p[i]+q[j]);\n            if(q[j]<0) chmin(nx[i+j+1],p[i]);\n          }\n        }\n        {          \n          for(Int i=0;i<x;i++)\n            if(i+sum[u]+1<x+y) chmin(nx[i+sum[u]+1],p[i]);\n        }\n        {\n          Int res=INF;\n          for(Int j=0;j<y;j++)\n            if(q[j]<0) chmin(res,j+1);\n          sum[v]+=res;\n        }        \n        swap(dp[v],nx);\n      }      \n      //cout<<v<<\":\"<<a[v]<<endl;\n      //for(Int x:dp[v]) cout<<x<<\" \";\n      //cout<<endl<<endl;;\n    };\n\n  Int idx=0;\n  while(a[idx]>0) idx++;\n  assert(idx<n);\n  \n  dfs(idx,-1);\n  Int ans=n;\n  //cout<<n<<\":\"<<dp[idx].size()<<endl;\n  assert(n==(Int)dp[idx].size());\n  for(Int i=0;i<n;i++)\n    if(dp[idx][i]<0) chmin(ans,i);\n  \n  assert(ans<n);  \n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define reps(i,x,n) for(int i=x; i<(n); i++)\n#define rrep(i,n) for(int i=(n)-1; i>=0; i--)\n#define all(X) (X).begin(),(X).end()\n#define X first\n#define Y second\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\ntemplate<class A, size_t N, class T> void Fill(A (&a)[N], const T &v){ fill( (T*)a, (T*)(a+N), v ); }\n\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {os<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"; return os;}\ntemplate<class T,size_t n> ostream& operator<<(ostream &os, const array<T,n> &t) {os<<\"{\"; rep(i,n) {os<<t[i]<<\",\";} os<<\"}\"; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst ll INF = 1e9+7;\n\ntypedef pair<map<ll,ll>, map<ll,ll>> state;\n\n\nll A[5005];\nvector<int> edge[5005];\nmap<pii,state> memo;\nstate dfs(int n, int b){\n        if( memo.count(pii(n, b)) ) return memo[pii(n,b)];\n        state ret;\n        ret.X[0] = 0;\n        auto func = [&](pll p, pll q, map<ll,ll> &s, ll check=0){\n                int id = p.X + q.X;\n                if( check && p.Y + check >= 0 ) return;\n                if( !s.count(id) ) s[id] = INF;\n                chmin(s[id], p.Y + q.Y);\n        };\n        for(auto t: edge[n]) if(t != b){\n                auto r = dfs(t, n);\n                state sum;\n                for(auto p: r.X) for(auto q: ret.X) func(p, q, sum.X);\n                for(auto p: r.X) for(auto q: ret.Y) func(p, q, sum.Y);\n                for(auto p: r.Y) for(auto q: ret.X) func(p, q, sum.Y);\n                for(auto p: r.Y) for(auto q: ret.Y) func(p, q, sum.Y);\n                ret = sum;\n        }\n\n        if( A[n] >= 0 ){\n                state sum;\n                for(auto p: ret.X) func(p, pll(0, A[n]), sum.X);\n                for(auto p: ret.Y) func(p, pll(0, A[n]), sum.Y);\n                for(auto p: ret.X) func(p, pll(1, -p.Y), sum.X);\n                for(auto p: ret.Y) func(p, pll(1, -p.Y), sum.X, A[n]);\n                ret = sum;\n        }else{\n                state sum;\n                for(auto p: ret.X) func(p, pll(0, A[n]), sum.Y);\n                for(auto p: ret.Y) func(p, pll(0, A[n]), sum.Y);\n                for(auto p: ret.X) func(p, pll(1, -p.Y), sum.X, A[n]);\n                for(auto p: ret.Y) func(p, pll(1, -p.Y), sum.X, A[n]);\n                ret = sum;\n        }\n\n        //cout << \"dfs \" << n+1 << \":\" << b+1 << endl;\n        //for(auto p: ret.X) cout << p << \",\"; cout << endl;\n        //for(auto p: ret.Y) cout << p << \",\"; cout << endl;\n\n        return memo[pii(n,b)] = ret;\n}\n\nint main(){\n        ios_base::sync_with_stdio(false);\n        ll N, ans=INF;\n\n        cin >> N;\n        rep(i,N) cin >> A[i];\n        rep(i,N-1){\n                int u, v;\n                cin >> u >> v;\n                u--; v--;\n                edge[u].push_back(v);\n                edge[v].push_back(u);\n        }\n\n        auto ret = dfs(0, -1);\n        for(auto p: ret.X) chmin(ans, p.X - (p.Y == 0));\n\n        cout << ans << endl;\n\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<ld,ld> pdd;\n\n#define X first\n#define Y second\n\n//#include <boost/unordered_map.hpp>\n//using namespace boost;\n\n/*\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> rbtree;\nrbtree T;\n*/\n\nnamespace io{\n\tconst int L = (1 << 20) + 1;\n\t\n\tchar buf[L], *S , *T, c;\n\t \n\tchar getchar() {\n\t\tif(__builtin_expect(S == T, 0)) {\n\t\t\tT = (S = buf) + fread(buf, 1, L, stdin);\n\t\t\treturn (S == T ? EOF : *S++);\n\t\t}\n\t\treturn *S++;\n\t}\n\t\n\tint inp() {\n\t\tint x = 0, f = 1; char ch;\n\t\tfor(ch = getchar(); !isdigit(ch); ch = getchar())\n\t\t\tif(ch == '-') f = -1;\n\t\tfor(; isdigit(ch); x = x * 10 + ch - '0', ch = getchar());\n\t\treturn x * f;\n\t}\n\t\n\tunsigned inpu()\n\t{\n\t\tunsigned x = 0; char ch;\n\t\tfor(ch = getchar(); !isdigit(ch); ch = getchar());\n\t\tfor(; isdigit(ch); x = x * 10 + ch - '0', ch = getchar());\n\t\treturn x;\n\t}\n\t\n\tll inp_ll() {\n\t\tll x = 0; int f = 1; char ch;\n\t\tfor(ch = getchar(); !isdigit(ch); ch = getchar())\n\t\t\tif(ch == '-') f = -1;\n\t\tfor(; isdigit(ch); x = x * 10 + ch - '0', ch = getchar());\n\t\treturn x * f;\n\t}\n\t\n\tchar B[25], *outs=B+20, *outr=B+20;\n\ttemplate<class T>\n\tinline void print(register T a,register char x=0){\n\t\tif(x) *--outs = x, x = 0;\n\t\t\n\t\tif(!a)*--outs = '0';\n\t\telse \n\t\t\twhile(a)\n\t\t\t\t*--outs = (a % 10) + 48, a /= 10;\n\t\t\n\t\tif(x)\n\t\t\t*--outs = x;\n\t\t\n\t\tfwrite(outs, outr - outs , 1, stdout);\n\t\touts = outr;\n\t}\n};\n\nusing io :: print;\nusing io :: inp;\nusing io :: inpu;\nusing io :: inp_ll;\n\nusing i32 = int;\nusing i64 = long long;\nusing u8 = unsigned char;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing f64 = double;\nusing f80 = long double;\n\nll power(ll a, ll b, ll p)\n{\n\tif (!b) return 1;\n\tll t = power(a, b/2, p);\n\tt = t*t%p;\n\tif (b&1) t = t*a%p;\n\treturn t;\n}\n\nconst int MAXN = 5010;\nconst int MAXP = 10000000;\nconst u64 MOD = 1000000007;\nconst f80 MI = f80(1)/MOD;\nconst ll INF = 10000000000000000LL;\nconst ll inf = 5000000000000LL;\n\nint n;\nint a[MAXN];\nvector<int> v[MAXN];\n\nint size[MAXN];\nll F[MAXN][MAXN][2]; // 0/1 whether there is a computer\nll tmp[MAXN][2];\n\nvoid fresh(ll &a, ll b)\n{\n\tif (a > b) a = b;\n}\n\nvoid dfs(int x, int pre)\n{\n\tsize[x] = 1;\n\tif (a[x] > 0)\n\t{\n\t\tF[x][0][0] = F[x][0][1] = a[x];\n\t}\n\telse\n\t{\n\t\tF[x][0][1] = a[x];\n\t}\n\tfor (auto y : v[x])\n\t{\n\t\tif (y == pre) continue;\n\t\tdfs(y, x);\n\t\tfor (int s = 0; s <= size[x]+size[y]; ++ s)\n\t\t{\n\t\t\ttmp[s][0] = INF;\n\t\t\ttmp[s][1] = INF;\n\t\t}\n\t\tfor (int sx = 0; sx <= size[x]; ++ sx)\n\t\t\tfor (int sy = 0; sy <= size[y]; ++ sy)\n\t\t\t{\n\t\t\t\tfresh(tmp[sx+sy][0], F[x][sx][0]+F[y][sy][0]);\n\t\t\t\tfresh(tmp[sx+sy][1], F[x][sx][1]+F[y][sy][0]);\n\t\t\t\tfresh(tmp[sx+sy][1], F[x][sx][0]+F[y][sy][1]);\n\t\t\t\tfresh(tmp[sx+sy][1], F[x][sx][1]+F[y][sy][1]);\n\t\t\t}\n\t\tfor (int s = 0; s <= size[x]+size[y]; ++ s)\n\t\t{\n\t\t\tF[x][s][0] = tmp[s][0];\n\t\t\tF[x][s][1] = tmp[s][1];\n\t\t}\n\t\tsize[x] += size[y];\n\t}\n\tfor (int s = 0; s <= size[x]; ++ s)\n\t\tif (F[x][s][0] < inf || F[x][s][1] < 0)\n\t\t{\n\t\t\tfor (; s <= size[x]; ++ s)\n\t\t\t{\n\t\t\t\tfresh(F[x][s+1][0], 0);\n\t\t\t\tfresh(F[x][s+1][1], 0);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t/*\n\tfor (int s = size[x]-1; s >= 0; -- s)\n\t{\n\t\tfresh(F[x][s+1][0], 0);\n\t\tfresh(F[x][s+1][1], 0);\n\t\tif (F[x][s][1] < 0)\n\t\t{\n\t\t\tfresh(F[x][s+1][0], 0);\n\t\t\tfresh(F[x][s+1][1], 0);\n\t\t}\n\t}\n\t*/\n}\n\nint main()\n{\n\t\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++ i)\n\t\tscanf(\"%d\", &a[i]);\n\tfor (int i = 1; i < n; ++ i)\n\t{\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tv[x].push_back(y);\n\t\tv[y].push_back(x);\n\t}\n\tfor (int i = 1; i <= n; ++ i)\n\t\tfor (int j = 0; j <= n; ++ j)\n\t\t\tF[i][j][0] = F[i][j][1] = INF;\n\tdfs(1, 0);\n\tfor (int i = 0; i <= n; ++ i)\n\t\tif (F[1][i][0] == 0 || F[1][i][1] == 0)\n\t\t{\n\t\t\tcout << i-1 << endl;\n\t\t\tbreak;\n\t\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\nconst ll INF = 1ll<<60;\n\nint n;\nint a[5252];\nvi g[5252];\nll dp[5252][5252], dp2[5252][5252];\nll tmp[2][5252];\nll sz[5252];\n\nvoid dfs(int p, int bef){\n  sz[p] = 1;\n  dp[p][0] = a[p]<0 ? INF : a[p];\n  dp2[p][0]= a[p]<0 ? a[p] : INF;\n  for(int to : g[p])if(to != bef){\n    dfs(to,p);\n    fill(tmp[0], tmp[0]+sz[p]+sz[to], INF);\n    fill(tmp[1], tmp[1]+sz[p]+sz[to], INF);\n    REP(i,sz[p])REP(j,sz[to]){\n      if(dp[to][j]<INF/2){\n        CHMIN(tmp[0][i+j], dp[p][i]+dp[to][j]);\n        CHMIN(tmp[0][i+j+1], dp[p][i]);\n\n        CHMIN(tmp[1][i+j], dp2[p][i]+dp[to][j]);\n        CHMIN(tmp[1][i+j+1], dp2[p][i]);\n      }\n\n      CHMIN(tmp[1][i+j], dp[p][i]+dp2[to][j]);\n      if(dp2[to][j]<0)CHMIN(tmp[0][i+j+1], dp[p][i]);\n\n      CHMIN(tmp[1][i+j], dp2[p][i]+dp2[to][j]);\n      if(dp2[to][j]<0)CHMIN(tmp[1][i+j+1], dp2[p][i]);\n    }\n    sz[p] = sz[p]+sz[to];\n    REP(i,sz[p])dp[p][i] = tmp[0][i];\n    REP(i,sz[p])dp2[p][i] = tmp[1][i];\n  }\n  // DEBUG(p);\n  // REP(i,sz[p])printf(\"%lld \",dp[p][i]==INF ? 252521ll : dp[p][i]);puts(\"\");\n  // REP(i,sz[p])printf(\"%lld \",dp2[p][i]==INF ? 252521ll : dp2[p][i]);puts(\"\");\n}\n\nint main(){\n  scanf(\"%d\",&n);\n  REP(i,n)scanf(\"%d\",a+i);\n  REP(i,n-1){\n    int u,v;\n    scanf(\"%d%d\",&u,&v);\n    --u;--v;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  dfs(0,-1);\n  int ans = n;\n  REP(i,n)if(dp[0][i]<INF/2)CHMIN(ans,i);\n  REP(i,n)if(dp2[0][i]<0)CHMIN(ans,i);\n  printf(\"%d\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nint n;\nint a[5005];\nint sz[5005];\nint dp[5005][5005][2];\nvector<int> adj[100005];\n\nvoid ddp(int node, int fa)\n{\n\t//cout<<\"AT \"<<node<<endl;\n\tsz[node]=1;\n\tfor(int i=0; i<=n; i++)\n\t{\n\t\tdp[node][i][0]=10000000000000;\n\t\tdp[node][i][1]=10000000000000;\n\t}\n\tif(a[node]>0) dp[node][0][0]=a[node];\n\telse dp[node][0][1]=a[node];\n\tint dp1[5005][2];\n\t\n\tfor(auto i:adj[node])\n\t{\n\t\tif(i==fa) continue;\n\t\tfor(int i=0; i<=n; i++)\n\t\t{\n\t\t\tdp1[i][0]=10000000000000;\n\t\t\tdp1[i][1]=10000000000000;\n\t\t}\n\t\tddp(i, node);\n\t\tfor(int sn=0; sn<sz[node]; sn++)\n\t\t{\n\t\t\tfor(int si=0; si<sz[i]; si++)\n\t\t\t{\n\t\t\t\tdp1[sn+si][0]=min(dp1[sn+si][0], dp[node][sn][0]+dp[i][si][0]);\n\t\t\t\tdp1[sn+si][1]=min(dp1[sn+si][1], min(dp[node][sn][1]+dp[i][si][1], min(dp[node][sn][0]+dp[i][si][1], dp[node][sn][1]+dp[i][si][0])));\n\t\t\t\tif(dp[i][si][1]<0)\n\t\t\t\t{\n\t\t\t\t\tdp1[sn+si+1][0]=min(dp1[sn+si+1][0], dp[node][sn][0]);\n\t\t\t\t\tdp1[sn+si+1][1]=min(dp1[sn+si+1][1], dp[node][sn][1]);\n\t\t\t\t}\n\t\t\t\tif(dp[i][si][0]<10000000000000)\n\t\t\t\t{\n\t\t\t\t\tdp1[sn+si+1][0]=min(dp1[sn+si+1][0], dp[node][sn][0]);\n\t\t\t\t\tdp1[sn+si+1][1]=min(dp1[sn+si+1][1], dp[node][sn][1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j=0; j<=n; j++)\n\t\t{\n\t\t\tdp[node][j][0]=dp1[j][0];\n\t\t\tdp[node][j][1]=dp1[j][1];\n\t\t}\n\t\tsz[node]+=sz[i];\n\t}\n}\n\nsigned main()\n{\n\tcin>>n;\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tcin>>a[i];\n\t}\n\tfor(int i=1; i<n; i++)\n\t{\n\t\tint u, v;\n\t\tcin>>u>>v;\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\tddp(1, 1);\n\tfor(int i=0; i<=n; i++)\n\t{\n\t\tif(dp[1][i][0]<10000000000000||dp[1][i][1]<0)\n\t\t{\n\t\t\t//cout<<dp[1][i][0]<<\" \"<<dp[1][i][1]<<endl;\n\t\t\tcout<<i;\n\t\t\treturn 0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ALL(x) x.begin(),x.end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define debug(v) cout<<#v<<\":\";for(auto x:v){cout<<x<<' ';}cout<<endl;\n#define INF 1000000000\n#define mod 1000000007\nusing ll=long long;\nconst ll LINF=1001002003004005006ll;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n// ll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\ntemplate<class T>bool chmax(T &a,const T &b){if(a<b){a=b;return true;}return false;}\ntemplate<class T>bool chmin(T &a,const T &b){if(b<a){a=b;return true;}return false;}\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    \n    int n;cin>>n;\n    ll a[n];rep(i,n) cin>>a[i];\n    vector<vector<int>> g(n);\n    rep(i,n-1){\n        int u,v;cin>>u>>v;u--,v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    // 2は正だけ\n    vector<vector<ll>> dp1(n+10,vector<ll>(n+10,LINF)),dp2(n+10,vector<ll>(n+10,LINF));\n    int sz[n];\n\n    function<void(int,int)> dfs=[&](int pre,int now){\n        sz[now]=1;\n        for(auto to:g[now])if(pre!=to){\n            dfs(now,to);\n            sz[now]+=sz[to];\n        }\n        \n        ll sub1[sz[now]],sub2[sz[now]];\n        rep(i,sz[now])sub1[i]=LINF,sub2[i]=LINF;\n        sub1[0]=a[now];\n        if(a[now]>0) sub2[0]=a[now];\n\n        int cnt=0;\n        for(auto to:g[now])if(to!=pre){\n            ll memo1[cnt+1],memo2[cnt+1];\n            rep(i,cnt+1)memo1[i]=sub1[i],memo2[i]=sub2[i];\n            rep(i,cnt+1)sub1[i]=LINF,sub2[i]=LINF;\n            rep(i,cnt+1){\n                rep(j,sz[to]){\n                    chmin(sub1[i+j],memo1[i]+dp1[to][j]);// 切らない\n                    // dp[to][j]->すでにj本切ってる．\n                    // sub1[i]->すでにi本切ってる\n                    // さらにもう1本切る．\n\n                    // 存在してないなら切れない\n                    if(dp1[to][j]<0 or dp2[to][j]<LINF) chmin(sub1[i+j+1],memo1[i]);\n                    if(a[now]>0){\n                        chmin(sub2[i+j],memo2[i]+dp2[to][j]);\n                        if(dp1[to][j]<0 or dp2[to][j]<LINF) chmin(sub2[i+j+1],memo2[i]);\n                    }\n                }\n            }\n            cnt+=sz[to];\n        }\n        rep(i,sz[now]){\n            dp1[now][i]=sub1[i];\n            dp2[now][i]=sub2[i];\n        }\n    };\n\n    dfs(-1,0);\n\n    // rep(i,n){\n    //     cout<<i<<\" : \";\n    //     rep(j,n){\n    //         cout<<\"(\";\n    //         if(dp1[i][j]>=LINF) cout<<\"X,\";\n    //         else cout<<dp1[i][j]<<\",\";\n\n    //         if(dp2[i][j]>=LINF) cout<<\"X)\";\n    //         else cout<<dp2[i][j]<<\")\";\n    //     }\n    //     cout<<endl;\n    // }\n\n    int ans=INF;\n    rep(i,n+1){\n        if(dp1[0][i]<0) chmin(ans,i);\n        if(dp2[0][i]<LINF) chmin(ans,i);\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <queue>\n#include <functional>\n#include <string>\n#include <set>\n#include <map>\n#include <cmath>\n#include <cassert>\n#define SIZE 5005\n#define INF 1000000000000000LL\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nvector <int> vec[SIZE];\nint dp1[SIZE],nd[SIZE];\nll dp2[SIZE][SIZE];\nll cur[SIZE];\nll A[SIZE];\n\nvoid dfs(int v=0,int p=-1)\n{\n\tnd[v]=1;\n\tdp2[v][0]=A[v];\n\tfor(int i=0;i<vec[v].size();i++)\n\t{\n\t\tint to=vec[v][i];\n\t\tif(to!=p)\n\t\t{\n\t\t\tdfs(to,v);\n\t\t\tif(A[v]>0)\n\t\t\t{\n\t\t\t\tint pl=SIZE;\n\t\t\t\tif(A[to]>0) pl=min(pl,dp1[to]);\n\t\t\t\tfor(int j=0;j<nd[to];j++) if(dp2[to][j]<0) pl=min(pl,j+1);\n\t\t\t\tdp1[v]+=pl;\n\t\t\t}\n\t\t\tfor(int j=0;j<nd[v]+nd[to];j++) cur[j]=INF;\n\t\t\tfor(int j=0;j<nd[v];j++)\n\t\t\t{\n\t\t\t\tfor(int k=0;k<nd[to];k++)\n\t\t\t\t{\n\t\t\t\t\tcur[j+k]=min(cur[j+k],dp2[v][j]+dp2[to][k]);\n\t\t\t\t\tif(dp2[to][k]<0) cur[j+k+1]=min(cur[j+k+1],dp2[v][j]);\n\t\t\t\t}\n\t\t\t\tif(A[to]>0)\n\t\t\t\t{\n\t\t\t\t\tcur[j+dp1[to]+1]=min(cur[j+dp1[to]+1],dp2[v][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tnd[v]+=nd[to];\n\t\t\tfor(int j=0;j<nd[v];j++) dp2[v][j]=cur[j];\n\t\t}\n\t}\n}\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++) scanf(\"%lld\",&A[i]);\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tint a,b;\n\t\tscanf(\"%d %d\",&a,&b);a--,b--;\n\t\tvec[a].push_back(b);\n\t\tvec[b].push_back(a);\n\t}\n\tdfs();\n\tint ret=SIZE;\n\tif(A[0]>0) ret=dp1[0];\n\tfor(int i=0;i<SIZE;i++) if(dp2[0][i]<0) ret=min(ret,i);\n\tprintf(\"%d\\n\",ret);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const ll inf = 1e18;const double INF = 1e12, EPS = 1e-9;\n\nusing VL = vector<ll>;\nusing VVL = vector<VL>;\nint n, a[5000];\nvector<vi> e;\n\nVVL rec(int c, int p){\n\tVVL dp(1, VL(2, inf));\n\tdp[0][a[c] < 0] = a[c];\n\t\n\tfor(int cld : e[c]) if(cld != p){\n\t\tVVL tmp = rec(cld, c);\n\t\tVVL next(dp.size() + tmp.size(), VL(2, inf));\n\t\t\n\t\trep(i, tmp.size()) rep(j, 2) rep(k, dp.size()) rep(l, 2){\n\t\t\tif(tmp[i][j] == inf || dp[k][l] == inf) continue;\n\t\t\t\n\t\t\tassert(i + k < next.size());\n\t\t\tassert(i + k + 1 < next.size());\n\t\t\tassert((j | l) < 2);\n\t\t\t\n\t\t\tnext[i + k][j | l] = min(next[i + k][j | l], tmp[i][j] + dp[k][l]);\n\t\t\tif(j == 0 || tmp[i][j] < 0) next[i + k + 1][l] = min(next[i + k + 1][l], dp[k][l]);\n\t\t}\n\t\t\n\t\tdp = next;\n\t}\n\treturn dp;\n}\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tcin >> n; e.resize(n);\n\trep(i, n) cin >> a[i];\n\trep(i, n - 1){\n\t\tint u, v; cin >> u >> v; u--; v--;\n\t\te[u].pb(v);\n\t\te[v].pb(u);\n\t}\n\tVVL ans = rec(0, 0);\n\tint res = n - 1;\n\trep(i, ans.size()) rep(j, ans[i].size()) if(ans[i][j] < inf) if(j == 0 || ans[i][j] < 0) res = min(res, i);\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nusing Graph = vector<vector<int>>;\nconst Int INF = 1e18;\nGraph G;\nvector<int> A;\nvector<Int> B;\nvector<vector<Int>> C;\nInt neg(const vector<Int> &A) {\n    for (int i = 0; i < A.size(); i++) {\n        if (A[i] < 0) return i;\n    }\n    return INF;\n}\nvector<Int> f(const vector<Int> &A, const vector<Int> &B) {\n    vector<Int> ans(A.size() + B.size() - 1, INF);\n    for (int i = 0; i < A.size(); i++) {\n        for (int j = 0; j < B.size(); j++) {\n            ans[i + j] = min(ans[i + j], A[i] + B[j]);\n        }\n    }\n    return ans;\n}\nvoid recur(int node, int prev) {\n    for (auto next : G[node]) if (next != prev) {\n        recur(next, node);\n    }\n    if (A[node] > 0) {\n        B[node] = 0;\n        for (auto next : G[node]) if (next != prev) {\n            if (A[next] > 0) {\n                B[node] += min(neg(C[next]) + 1, B[next]);\n            } else {\n                B[node] += neg(C[next]) + 1;\n            }\n        }\n    }\n    vector<Int> X = {A[node]};\n    for (auto next : G[node]) if (next != prev) {\n        X = f(X, C[next]);\n    }\n    if (A[node] > 0) {\n        X.resize(max((Int)X.size(), B[node] + 1 + 1), INF);\n        X[B[node] + 1] = min(X[B[node] + 1], 0LL);\n    }\n    C[node] = X;\n}\nint main() {\n    int N; cin >> N;\n    G.resize(N);\n    A.resize(N); for (auto &a : A) cin >> a;\n    B.resize(N, INF);\n    C.resize(N);\n    for (int i = 0; i < N - 1; i++) {\n        int u, v; cin >> u >> v; u--, v--;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    recur(0, -1);\n    cout << min(B[0], neg(C[0])) << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define ll long long\n#define N 5010\nint read()\n{\n    int x=0,f=1;char c=getchar();\n    while (c<'0'||c>'9') {if (c=='-') f=-1;c=getchar();}\n    while (c>='0'&&c<='9') x=(x<<1)+(x<<3)+(c^48),c=getchar();\n    return x*f;\n}\nint n,a[N],p[N],g[N],size[N],t;\nll sum[N],f[N][N];\nstruct data{int to,nxt;\n}edge[N<<1];\nvoid addedge(int x,int y){t++;edge[t].to=y,edge[t].nxt=p[x],p[x]=t;}\nvoid dfs(int k,int from)\n{\n\tsum[k]=a[k];\n    for (int i=p[k];i;i=edge[i].nxt)\n    if (edge[i].to!=from)\n\t{\n\t\tdfs(edge[i].to,k);\n\t\tsum[k]+=sum[edge[i].to];\n\t}\n    if (a[k]>0)\n    {\n        g[k]=0;\n        for (int i=p[k];i;i=edge[i].nxt)\n        if (edge[i].to!=from)\n        {\n            int x=g[edge[i].to];\n            for (int j=0;j<=n;j++)\n            if (f[edge[i].to][j]<0) {x=min(x,j+1);break;}\n            g[k]+=x;\n        }\n    }\n    f[k][0]=a[k];\n    size[k]=1;\n    for (int i=p[k];i;i=edge[i].nxt)\n    if (edge[i].to!=from)\n    {\n        for (int j=size[k]+size[edge[i].to];j>=0;j--)\n        {\n        \tf[k][j]+=sum[edge[i].to];if (j-g[edge[i].to]-1>=0) f[k][j]=min(f[k][j],f[k][j-g[edge[i].to]-1]);\n        \tfor (int x=max(0,j-size[k]);x<=min(j,size[edge[i].to]);x++)\n        \t{\n        \t\tif (x) f[k][j]=min(f[k][j],f[k][j-x]+f[edge[i].to][x]);\n        \t\tif (x<j&&f[edge[i].to][x]<0) f[k][j]=min(f[k][j],f[k][j-x-1]);\n        \t}\n        }\n        size[k]+=size[edge[i].to];\n    }\n}\nint main()\n{\n\t/*freopen(\"e.in\",\"r\",stdin);\n\tfreopen(\"e.out\",\"w\",stdout);*/\n    n=read();\n    for (int i=1;i<=n;i++) a[i]=read();\n    for (int i=1;i<n;i++)\n    {\n        int x=read(),y=read();\n        addedge(x,y),addedge(y,x);\n    }\n    memset(g,42,sizeof(g));\n    memset(f,42,sizeof(f));\n    dfs(1,1);\n    /*for (int i=1;i<=n;i++) cout<<a[i]<<' ';cout<<endl;\n    for (int i=1;i<=n;i++) cout<<g[i]<<' ';cout<<endl;\n    cout<<endl;\n    for (int i=1;i<=n;i++)\n    {\n    \tfor (int j=0;j<n;j++)\n    \tcout<<f[i][j]<<' ';\n    \tcout<<endl;;\n    }\n    for (int i=1;i<=n;i++) cout<<sum[i]<<' ';cout<<endl;*/\n    int ans=g[1];\n    for (int i=0;i<=n;i++) \n    if (f[1][i]<0) {ans=min(ans,i);break;}\n    cout<<ans;\n    return 0;\n}\n "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cassert>\n#include<cmath>\n#include<climits>\n#include<iomanip>\n#include<stack>\n#include<unordered_map>\n#include<bitset>\n#include<limits>\n#include<complex>\n#include<array>\n#include<numeric>\n#include<functional>\n\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rrep(i,m,n) for(ll (i)=(ll)(m);(i)>=(ll)(n);(i)--)\n#define rep(i,m,n) for(ll (i)=(ll)(m);i<(ll)(n);i++)\n#define REP(i,n) rep(i,0,n)\n#define FOR(i,c) for(decltype((c).begin())i=(c).begin();i!=(c).end();++i)\n#define all(hoge) (hoge).begin(),(hoge).end()\ntypedef pair<ll, ll> P;\nconstexpr long double m_pi = 3.1415926535897932L;\nconstexpr ll MOD = 1000000007;\nconstexpr ll INF = 1LL << 61;\nconstexpr long double EPS = 1e-10;\ntemplate<typename T> using vector2 = vector<vector<T>>;\ntemplate<typename T> using vector3 = vector<vector2<T>>;\ntypedef vector<ll> Array;\ntypedef vector<Array> Matrix;\nstring operator*(const string& s, int k) {\n\tif (k == 0) return \"\";\n\tstring p = (s + s) * (k / 2);\n\tif (k % 2 == 1) p += s;\n\treturn p;\n}\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstruct Edge {//グラフ\n\tint to, rev; ll cap;\n\tEdge(int _to, ll _cap, int _rev) {\n\t\tto = _to; cap = _cap; rev = _rev;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid add_edge(Graph& G, int from, int to, ll cap, bool revFlag, ll revCap) {//最大フロー求める Ford-fulkerson\n\tG[from].push_back(Edge(to, cap, (ll)G[to].size()));\n\tif (revFlag)G[to].push_back(Edge(from, revCap, (ll)G[from].size() - 1));//最小カットの場合逆辺は0にする\n}\n\nll max_flow_dfs(Graph& G, ll v, ll t, ll f, vector<bool>& used)\n{\n\tif (v == t)\n\t\treturn f;\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\tEdge& e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tll d = max_flow_dfs(G, e.to, t, min(f, e.cap), used);\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n//二分グラフの最大マッチングを求めたりも出来る　また二部グラフの最大独立集合は頂点数-最大マッチングのサイズ\nll max_flow(Graph& G, ll s, ll t)//O(V(V+E))\n{\n\tll flow = 0;\n\tfor (;;) {\n\t\tvector<bool> used(G.size());\n\t\tREP(i, used.size())used[i] = false;\n\t\tll f = max_flow_dfs(G, s, t, INF, used);\n\t\tif (f == 0) {\n\t\t\treturn flow;\n\t\t}\n\t\tflow += f;\n\t}\n}\nvoid BellmanFord(Graph& G, ll s, Array& d, Array& negative) {//O(|E||V|)\n\td.resize(G.size());\n\tnegative.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\tREP(i, d.size())negative[i] = false;\n\td[s] = 0;\n\tREP(k, G.size() - 1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tREP(k, G.size() - 1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t\tnegative[G[i][j].to] = true;\n\t\t\t\t}\n\t\t\t\tif (negative[i] == true)negative[G[i][j].to] = true;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid Dijkstra(Graph& G, ll s, Array& d) {//O(|E|log|V|)\n\td.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\td[s] = 0;\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(make_pair(0, s));\n\twhile (!q.empty()) {\n\t\tP a = q.top();\n\t\tq.pop();\n\t\tif (d[a.second] < a.first)continue;\n\t\tREP(i, G[a.second].size()) {\n\t\t\tEdge e = G[a.second][i];\n\t\t\tif (d[e.to] > d[a.second] + e.cap) {\n\t\t\t\td[e.to] = d[a.second] + e.cap;\n\t\t\t\tq.push(make_pair(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid WarshallFloyd(Graph& G, Matrix& d) {//O(V^3)\n\td.resize(G.size());\n\tREP(i, d.size())d[i].resize(G.size());\n\tREP(i, d.size()) {\n\t\tREP(j, d[i].size()) {\n\t\t\td[i][j] = ((i != j) ? INF : 0);\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G[i].size()) {\n\t\t\tchmin(d[i][G[i][j].to], G[i][j].cap);\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G.size()) {\n\t\t\tREP(k, G.size()) {\n\t\t\t\tchmin(d[j][k], d[j][i] + d[i][k]);\n\t\t\t}\n\t\t}\n\t}\n}\nbool tsort(Graph& graph, Array& order) {//トポロジカルソートO(E+V)\n\tint n = graph.size(), k = 0;\n\tArray in(n);\n\tfor (auto& es : graph)\n\t\tfor (auto& e : es)in[e.to]++;\n\tpriority_queue<ll, Array, greater<ll>> que;\n\tREP(i, n)\n\t\tif (in[i] == 0)que.push(i);\n\twhile (que.size()) {\n\t\tint v = que.top();\n\t\tque.pop();\n\t\torder.push_back(v);\n\t\tfor (auto& e : graph[v])\n\t\t\tif (--in[e.to] == 0)que.push(e.to);\n\t}\n\tif (order.size() != n)return false;\n\telse return true;\n}\nclass Lca {\npublic:\n\tconst int n = 0;\n\tconst int log2_n = 0;\n\tstd::vector<std::vector<int>> parent;\n\tstd::vector<int> depth;\n\n\tLca() {}\n\n\tLca(const Graph& g, int root)\n\t\t: n(g.size()), log2_n(log2(n) + 1), parent(log2_n, std::vector<int>(n)), depth(n) {\n\t\tdfs(g, root, -1, 0);\n\t\tfor (int k = 0; k + 1 < log2_n; k++) {\n\t\t\tfor (int v = 0; v < (int)g.size(); v++) {\n\t\t\t\tif (parent[k][v] < 0)\n\t\t\t\t\tparent[k + 1][v] = -1;\n\t\t\t\telse\n\t\t\t\t\tparent[k + 1][v] = parent[k][parent[k][v]];\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dfs(const Graph& g, int v, int p, int d) {\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\tfor (auto& e : g[v]) {\n\t\t\tif (e.to != p) dfs(g, e.to, v, d + 1);\n\t\t}\n\t}\n\n\tint get(int u, int v) {\n\t\tif (depth[u] > depth[v]) std::swap(u, v);\n\t\tfor (int k = 0; k < log2_n; k++) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v) return u;\n\t\tfor (int k = log2_n - 1; k >= 0; k--) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n};\nvoid visit(const Graph& g, int v, vector<vector<int>>& scc, stack<int>& S, vector<int>& inS, vector<int>& low,vector<int>& num, int& time) {\n\tlow[v] = num[v] = ++time;\n\tS.push(v); inS[v] = true;\n\tFOR(e, g[v]) {\n\t\tint w = e->to;\n\t\tif (num[w] == 0) {\n\t\t\tvisit(g, w, scc, S, inS, low, num, time);\n\t\t\tlow[v] = min(low[v], low[w]);\n\t\t}\n\t\telse if (inS[w])\n\t\t\tlow[v] = min(low[v], num[w]);\n\t}\n\tif (low[v] == num[v]) {\n\t\tscc.push_back(vector<int>());\n\t\twhile (1) {\n\t\t\tint w = S.top(); S.pop(); inS[w] = false;\n\t\t\tscc.back().push_back(w);\n\t\t\tif (v == w) break;\n\t\t}\n\t}\n}\nvoid stronglyConnectedComponents(const Graph& g, vector<vector<int>>& scc) {//強連結成分分解 O(E+V)\n\tconst int n = g.size();\n\tvector<int> num(n), low(n);\n\tstack<int> S;\n\tvector<int> inS(n);\n\tint time = 0;\n\tREP(u, n) if (num[u] == 0)\n\t\tvisit(g, u, scc, S, inS, low, num, time);\n}\n\nclass UnionFind {\n\tvector<int> data;\n\tll num;\npublic:\n\tUnionFind(int size) : data(size, -1), num(size) { }\n\tbool unite(int x, int y) {//xとyの集合を統合する\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\tnum -= (x != y);\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {//xとyが同じ集合か返す\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {//xのルートを返す\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tll size(int x) {//xの集合のサイズを返す\n\t\treturn -data[root(x)];\n\t}\n\tll numSet() {//集合の数を返す\n\t\treturn num;\n\t}\n};\n\ntemplate<typename T, typename F>\nclass SegmentTree {\nprivate:\n\tT identity;\n\tF merge;\n\tll n;\n\tvector<T> dat;\npublic:\n\tSegmentTree(F f, T id,vector<T> v) :merge(f), identity(id) {\n\t\tint _n = v.size();\n\t\tn = 1;\n\t\twhile (n < _n)n *= 2;\n\t\tdat.resize(2 * n - 1, identity);\n\t\tREP(i, _n)dat[n + i - 1] = v[i];\n\t\tfor (int i = n - 2; i >= 0; i--)dat[i] = merge(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t}\n\tSegmentTree(F f, T id, int _n) :merge(f), identity(id) {\n\t\tn = 1;\n\t\twhile (n < _n)n *= 2;\n\t\tdat.resize(2 * n - 1, identity);\n\t}\n\tvoid set_val(int i, T x) {\n\t\ti += n - 1;\n\t\tdat[i] = x;\n\t\twhile (i > 0) {\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] = merge(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t\t}\n\t}\n\tT query(int l, int r) {\n\t\tT left = identity, right = identity;\n\t\tl += n - 1; r += n - 1;\n\t\twhile (l < r) {\n\t\t\tif ((l & 1) == 0)left = merge(left, dat[l]);\n\t\t\tif ((r & 1) == 0)right = merge(dat[r - 1], right);\n\t\t\tl = l / 2;\n\t\t\tr = (r - 1) / 2;\n\t\t}\n\t\treturn merge(left, right);\n\t}\n};\nclass SumSegTree {\npublic:\n\tll n, height;\n\tvector<ll> dat;\n\n\t// 初期化（_nは最大要素数）\n\tSumSegTree(ll _n) {\n\t\tn = 1;\n\t\theight = 1;\n\t\twhile (n < _n) {\n\t\t\tn *= 2;\n\t\t\theight++;\n\t\t}\n\t\tdat = vector<ll>(2 * n - 1, 0);\n\t}\n\n\t// 場所i(0-indexed)にxを足す\n\tvoid add(ll i, ll x) {\n\t\ti += n - 1; // i番目の葉ノードへ\n\t\tdat[i] += x;\n\t\twhile (i > 0) { // 下から上がっていく\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] += x;\n\t\t}\n\t}\n\t// 区間[l,r)の総和\n\tll sum(ll l, ll r) {\n\t\tll ret = 0;\n\t\tl += n - 1; r += n - 1;\n\t\twhile (l < r) {\n\t\t\tif ((l & 1) == 0)ret += dat[l];\n\t\t\tif ((r & 1) == 0)ret += dat[r - 1];\n\t\t\tl = l / 2;\n\t\t\tr = (r - 1) / 2;\n\t\t}\n\t\treturn ret;\n\t}\n};\nclass RmqTree {\nprivate:\n\n\tll _find(ll a, ll b, ll k, ll l, ll r) {\n\t\tif (r <= a || b <= l)return INF;    // 交差しない\n\t\tif (a <= l && r <= b)return dat[k];   // a,l,r,bの順で完全に含まれる\n\t\telse {\n\t\t\tll s1 = _find(a, b, 2 * k + 1, l, (l + r) / 2); // 左の子\n\t\t\tll s2 = _find(a, b, 2 * k + 2, (l + r) / 2, r); // 右の子\n\t\t\treturn min(s1, s2);\n\t\t}\n\t}\npublic:\n\tll n, height;\n\tvector<ll> dat;\n\n\t// 初期化（_nは最大要素数）\n\tRmqTree(ll _n) {\n\t\tn = 1;\n\t\theight = 1;\n\t\twhile (n < _n) {\n\t\t\tn *= 2;\n\t\t\theight++;\n\t\t}\n\t\tdat = vector<ll>(2 * n - 1, INF);\n\t}\n\n\t// 場所i(0-indexed)をxにする\n\tvoid update(ll i, ll x) {\n\t\ti += n - 1; // i番目の葉ノードへ\n\t\tdat[i] = x;\n\t\twhile (i > 0) { // 下から上がっていく\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] = min(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t\t}\n\t}\n\n\t// 区間[a,b)の最小値。ノードk=[l,r)に着目している。\n\tll find(ll a, ll b) {\n\t\treturn _find(a, b, 0, 0, n);\n\t}\n};\n\n\n//約数求める //約数\nvoid divisor(ll n, vector<ll>& ret) {\n\tfor (ll i = 1; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back(i);\n\t\t\tif (i * i != n) ret.push_back(n / i);\n\t\t}\n\t}\n\tsort(ret.begin(), ret.end());\n}\n\nvoid prime_factorization(ll n, vector<P>& ret) {\n\tfor (ll i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back({ i,0 });\n\t\t\twhile (n % i == 0) {\n\t\t\t\tn /= i;\n\t\t\t\tret[ret.size() - 1].second++;\n\t\t\t}\n\t\t}\n\t}\n\tif (n != 1)ret.push_back({ n,1 });\n}\n\n\nll mod_pow(ll x, ll n, ll mod) {\n\tll res = 1;\nwhile (n > 0) {\n\tif (n & 1) res = res * x % mod;\n\tx = x * x % mod;\n\tn >>= 1;\n}\nreturn res;\n}\n\nll mod_inv(ll x, ll mod) {\n\treturn mod_pow(x, mod - 2, mod);\n}\n//nCrとか\nclass Combination {\npublic:\n\tArray fact;\n\tArray inv;\n\tll mod;\n\tll mod_inv(ll x) {\n\t\tll n = mod - 2LL;\n\t\tll res = 1LL;\n\t\twhile (n > 0) {\n\t\t\tif (n & 1) res = res * x % mod;\n\t\t\tx = x * x % mod;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\t//if n >= mod use lucas \n\tll nCr(ll n, ll r) {\n\t\tif (n < r)return 0;\n\t\tif (n < mod)return ((fact[n] * inv[r] % mod) * inv[n - r]) % mod;\n\n\t\tll ret = 1;\n\t\twhile (n || r) {\n\t\t\tll _n = n % mod, _r = r % mod;\n\t\t\tn /= mod; r /= mod;\n\t\t\t(ret *= nCr(_n, _r)) %= mod;\n\t\t}\n\t\treturn ret;\n\t}\n\tll nPr(ll n, ll r) {\n\t\treturn (fact[n] * inv[n - r]) % mod;\n\t}\n\tll nHr(ll n, ll r) {\n\t\treturn nCr(r + n - 1, r);\n\t}\n\tCombination(ll _n, ll _mod) {\n\t\tmod = _mod;\n\t\tll n = min(_n + 1, mod);\n\t\tfact.resize(n);\n\t\tfact[0] = 1;\n\t\tREP(i, n - 1) {\n\t\t\tfact[i + 1] = (fact[i] * (i + 1LL)) % mod;\n\t\t}\n\t\tinv.resize(n);\n\t\tinv[n - 1] = mod_inv(fact[n - 1]);\n\t\tfor (int i = n - 1; i > 0; i--) {\n\t\t\tinv[i - 1] = inv[i] * i % mod;\n\t\t}\n\t}\n};\n\nll popcount(ll x) {\n\tx = (x & 0x5555555555555555) + (x >> 1 & 0x5555555555555555);\n\tx = (x & 0x3333333333333333) + (x >> 2 & 0x3333333333333333);\n\tx = (x & 0x0F0F0F0F0F0F0F0F) + (x >> 4 & 0x0F0F0F0F0F0F0F0F);\n\tx = (x & 0x00FF00FF00FF00FF) + (x >> 8 & 0x00FF00FF00FF00FF);\n\tx = (x & 0x0000FFFF0000FFFF) + (x >> 16 & 0x0000FFFF0000FFFF);\n\tx = (x & 0x00000000FFFFFFFF) + (x >> 32 & 0x00000000FFFFFFFF);\n\n\treturn x;\n}\n\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\tll n;\n\tcin >> n;\n\tArray a(n);\n\tREP(i, n)cin >> a[i];\n\tGraph g(n);\n\tREP(i, n - 1) {\n\t\tll a, b; cin >> a >> b;\n\t\ta--; b--;\n\t\tadd_edge(g, a, b, 1, true, 1);\n\t}\n\n\tauto solve = [&](auto solve, ll x, ll par)->Matrix {\n\t\tMatrix v(1, Array(2, INF));\n\t\tif (a[x] > 0)v[0][0] = a[x];\n\t\telse v[0][1] = a[x];\n\t\tfor (auto e : g[x]) {\n\t\t\tif (e.to == par)continue;\n\t\t\tauto u = solve(solve, e.to, x);\n\t\t\tMatrix dp(v.size()+u.size(), Array(2, INF));\n\t\t\tREP(i, v.size()) {\n\t\t\t\tREP(incv, 2) {\n\t\t\t\t\tif (v[i][incv] == INF)continue;\n\t\t\t\t\tREP(j, u.size()) {\n\t\t\t\t\t\tREP(incu, 2) {\n\t\t\t\t\t\t\tif (u[j][incu] == INF)continue;\n\t\t\t\t\t\t\t//cutしないとき\n\t\t\t\t\t\t\tll inc = (incv | incu);\n\t\t\t\t\t\t\tll cut = i + j;\n\t\t\t\t\t\t\tchmin(dp[cut][inc], v[i][incv] + u[j][incu]);\n\n\t\t\t\t\t\t\t//cutするとき\n\t\t\t\t\t\t\tif (incu == 1 && u[j][incu] >= 0)continue;\n\t\t\t\t\t\t\tinc = incv;\n\t\t\t\t\t\t\tcut++;\n\t\t\t\t\t\t\tchmin(dp[cut][inc], v[i][incv]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tv = dp;\n\t\t}\n\t\treturn v;\n\t};\n\tMatrix dp = solve(solve, 0, -1);\n\tll ans = INF;\n\tREP(i, dp.size()) {\n\t\tif (dp[i][0] != INF)chmin(ans, i);\n\t\tif (dp[i][1] < 0)chmin(ans, i);\n\t}\n\tcout << ans << \"\\n\";\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nЗАПУСКАЕМ \n░ГУСЯ░▄▀▀▀▄░РАБОТЯГУ░░\n▄███▀░◐░░░▌░░░░░░░\n░░░░▌░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▌░░░░░▐▄▄░░░░░\n░░░░▌░░░░▄▀▒▒▀▀▀▀▄\n░░░▐░░░░▐▒▒▒▒▒▒▒▒▀▀▄\n░░░▐░░░░▐▄▒▒▒▒▒▒▒▒▒▒▀▄\n░░░░▀▄░░░░▀▄▒▒▒▒▒▒▒▒▒▒▀▄\n░░░░░░▀▄▄▄▄▄█▄▄▄▄▄▄▄▄▄▄▄▀▄\n░░░░░░░░░░░▌▌░▌▌░░░░░\n░░░░░░░░░░░▌▌░▌▌░░░░░\n░░░░░░░░░▄▄▌▌▄▌▌░░░░░ \n*/\n#include <iostream>\n#include <complex>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <random>\n#include <array>\n       \n        \nusing namespace std;\ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; } \ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const pair<T, U> &_p) { _out << _p.first << ' ' << _p.second; return _out; }\ntemplate<typename T, typename U> inline istream &operator>> (istream &_in, pair<T, U> &_p) { _in >> _p.first >> _p.second; return _in; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const vector<T> &_v) { if (_v.empty()) { return _out; } _out << _v.front(); for (auto _it = ++_v.begin(); _it != _v.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline istream &operator>> (istream &_in, vector<T> &_v) { for (auto &_i : _v) { _in >> _i; } return _in; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const set<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const multiset<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const unordered_set<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const unordered_multiset<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const map<T, U> &_m) { if (_m.empty()) { return _out; } _out << '(' << _m.begin()->first << \": \" << _m.begin()->second << ')'; for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) { _out << \", (\" << _it->first << \": \" << _it->second << ')'; } return _out; }\ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const unordered_map<T, U> &_m) { if (_m.empty()) { return _out; } _out << '(' << _m.begin()->first << \": \" << _m.begin()->second << ')'; for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) { _out << \", (\" << _it->first << \": \" << _it->second << ')'; } return _out; }\n#define sz(c) (int)(c).size()\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define left left228\n#define right right228\n#define rank rank228\n#define y1 y1228                                                         \n#define read(FILENAME) freopen((FILENAME + \".in\").c_str(), \"r\", stdin)\n#define write(FILENAME) freopen((FILENAME + \".out\").c_str(), \"w\", stdout)\n#define files(FILENAME) read(FILENAME), write(FILENAME)\n#define pb push_back\nconst string FILENAME = \"input\";\nconst int MAXN = 5005;\nconst long long INF = 1e18;\n\n\nint n;\nlong long a[MAXN];\nvector<int> g[MAXN];\n\n\narray<vector<long long>, 2> dfs(int u, int pr = -1) {\n    array<vector<long long>, 2> cur;\n    if (a[u] < 0) {\n        cur[0].pb(INF);\n        cur[1].pb(a[u]);\n    } else {\n        cur[0].pb(a[u]);\n        cur[1].pb(a[u]);\n    }\n    for (auto h: g[u]) {\n        if (h == pr) {\n            continue;\n        }\n        auto st = dfs(h, u);\n        array<vector<long long>, 2> st1;\n        st1[0].resize(sz(cur[0]) - 1 + sz(st[0]) - 1 + 1, INF);\n        st1[1].resize(sz(cur[0]) - 1 + sz(st[0]) - 1 + 1, INF);\n        for (int i = 0; i < sz(cur[0]); i++) {\n            for (int j = 0; j < sz(st[0]); j++) {\n                chkmin(st1[0][i + j], cur[0][i] + st[0][j]);\n                chkmin(st1[1][i + j], cur[1][i] + st[1][j]);\n            }\n        }\n        cur = st1;\n    }\n    cur[0].pb(INF);\n    cur[1].pb(INF);\n    for (int i = 0; i < sz(cur[0]) - 1; i++) {\n        if (cur[0][i] < INF) {\n            chkmin(cur[0][i + 1], 0LL);\n        }\n        if (cur[1][i] < 0) {\n            chkmin(cur[0][i + 1], 0LL);\n        }\n    }\n    for (int i = 0; i < sz(cur[0]); i++) {\n        cur[1][i] = min(cur[1][i], cur[0][i]);\n    }\n    return cur;\n}\n\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    //read(FILENAME);\n    cin >> n;\n    long long sum = 0;\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n        sum += a[i];\n    }\n    for (int i = 0; i < n - 1; i++) {\n        int as, bs;\n        cin >> as >> bs;\n        as--, bs--;\n        g[as].pb(bs);\n        g[bs].pb(as);\n    }\n    if (sum < 0) {\n        cout << 0 << endl;\n        return 0;\n    }\n    auto kek = dfs(0);\n    int ans = n - 1;\n    for (int i = 0; i < sz(kek[0]); i++) {\n        if (kek[0][i] < INF && kek[1][i] < 0) {\n            chkmin(ans, i + 1);\n        }\n    }\n    cout << ans << endl;\n    return 0;   \n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\nЗАПУСКАЕМ \n░ГУСЯ░▄▀▀▀▄░РАБОТЯГУ░░\n▄███▀░◐░░░▌░░░░░░░\n░░░░▌░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▌░░░░░▐▄▄░░░░░\n░░░░▌░░░░▄▀▒▒▀▀▀▀▄\n░░░▐░░░░▐▒▒▒▒▒▒▒▒▀▀▄\n░░░▐░░░░▐▄▒▒▒▒▒▒▒▒▒▒▀▄\n░░░░▀▄░░░░▀▄▒▒▒▒▒▒▒▒▒▒▀▄\n░░░░░░▀▄▄▄▄▄█▄▄▄▄▄▄▄▄▄▄▄▀▄\n░░░░░░░░░░░▌▌░▌▌░░░░░\n░░░░░░░░░░░▌▌░▌▌░░░░░\n░░░░░░░░░▄▄▌▌▄▌▌░░░░░ \n*/\n#include <iostream>\n#include <complex>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <random>\n#include <array>\n       \n        \nusing namespace std;\ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; } \ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const pair<T, U> &_p) { _out << _p.first << ' ' << _p.second; return _out; }\ntemplate<typename T, typename U> inline istream &operator>> (istream &_in, pair<T, U> &_p) { _in >> _p.first >> _p.second; return _in; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const vector<T> &_v) { if (_v.empty()) { return _out; } _out << _v.front(); for (auto _it = ++_v.begin(); _it != _v.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline istream &operator>> (istream &_in, vector<T> &_v) { for (auto &_i : _v) { _in >> _i; } return _in; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const set<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const multiset<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const unordered_set<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const unordered_multiset<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const map<T, U> &_m) { if (_m.empty()) { return _out; } _out << '(' << _m.begin()->first << \": \" << _m.begin()->second << ')'; for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) { _out << \", (\" << _it->first << \": \" << _it->second << ')'; } return _out; }\ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const unordered_map<T, U> &_m) { if (_m.empty()) { return _out; } _out << '(' << _m.begin()->first << \": \" << _m.begin()->second << ')'; for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) { _out << \", (\" << _it->first << \": \" << _it->second << ')'; } return _out; }\n#define sz(c) (int)(c).size()\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define left left228\n#define right right228\n#define rank rank228\n#define y1 y1228                                                         \n#define read(FILENAME) freopen((FILENAME + \".in\").c_str(), \"r\", stdin)\n#define write(FILENAME) freopen((FILENAME + \".out\").c_str(), \"w\", stdout)\n#define files(FILENAME) read(FILENAME), write(FILENAME)\n#define pb push_back\nconst string FILENAME = \"input\";\nconst int MAXN = 5005;\nconst long long INF = 1e18;\n\n\nint n;\nlong long a[MAXN];\nvector<int> g[MAXN];\n\n\narray<vector<long long>, 2> dfs(int u, int pr = -1) {\n    array<vector<long long>, 2> cur;\n    if (a[u] < 0) {\n        cur[0].pb(INF);\n        cur[1].pb(a[u]);\n    } else {\n        cur[0].pb(a[u]);\n        cur[1].pb(a[u]);\n    }\n    for (auto h: g[u]) {\n        if (h == pr) {\n            continue;\n        }\n        auto st = dfs(h, u);\n        array<vector<long long>, 2> st1;\n        st1[0].resize(sz(cur[0]) - 1 + sz(st[0]) - 1 + 1, INF);\n        st1[1].resize(sz(cur[0]) - 1 + sz(st[0]) - 1 + 1, INF);\n        for (int i = 0; i < sz(cur[0]); i++) {\n            for (int j = 0; j < sz(st[0]); j++) {\n                chkmin(st1[0][i + j], cur[0][i] + st[0][j]);\n                chkmin(st1[1][i + j], cur[1][i] + st[1][j]);\n            }\n        }\n        cur = st1;\n    }\n    cur[0].pb(INF);\n    cur[1].pb(INF);\n    for (int i = 0; i < sz(cur[0]) - 1; i++) {\n        if (cur[0][i] < INF) {\n            chkmin(cur[0][i + 1], 0LL);\n        }\n        if (cur[1][i] < 0) {\n            chkmin(cur[0][i + 1], 0LL);\n        }\n    }\n    for (int i = 0; i < sz(cur[0]); i++) {\n        chkmin(cur[1][i], cur[0][i]);\n    }\n    return cur;\n}\n\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    //read(FILENAME);\n    cin >> n;\n    long long sum = 0;\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n        sum += a[i];\n    }\n    for (int i = 0; i < n - 1; i++) {\n        int as, bs;\n        cin >> as >> bs;\n        as--, bs--;\n        g[as].pb(bs);\n        g[bs].pb(as);\n    }\n    if (sum < 0) {\n        cout << 0 << endl;\n        return 0;\n    }\n    auto kek = dfs(0);\n    int ans = n;\n    for (int i = 0; i < sz(kek[0]); i++) {\n        if (kek[0][i] < INF || kek[1][i] < 0) {\n            chkmin(ans, i + 1);\n        }\n    }\n    cout << ans - 1 << endl;\n    return 0;   \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll MOD = 1e9+7;\nconst ll INF = 1e18;\n\nsigned main()\n{\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for(auto& y : a)\n        cin >> y;\n    vector<int> u(n - 1);\n    vector<int> v(n - 1);\n    for(int i = 0; i < n - 1; ++i){\n        cin >> u[i] >> v[i];\n        --u[i];\n        --v[i];\n    }\n    vector<vector<int>> edges(n);\n    for(int i = 0; i < n - 1; ++i){\n        edges[u[i]].push_back(v[i]);\n        edges[v[i]].push_back(u[i]);\n    }\n    vector<int> size(n, 1);\n\n    bitset<5000> flag;\n    function<void(int)> siz = [&](int x){\n        for(auto& y : edges[x])\n            if(!flag[y]){\n                flag[y] = 1;\n                siz(y);\n                size[x] += size[y];\n            }\n    };\n    flag[0] = 1;\n    siz(0);\n    flag.reset();\n\n    function<vector<vector<ll>>(int)> f = [&](int x){\n        vector<vector<ll>> dp(1, vector<ll>(2, INF));\n        dp[0][0] = a[x];\n        if(a[x] > 0)\n            dp[0][1] = a[x];\n\n        int sizesum = 0;\n        for(auto& y : edges[x]){\n            if(flag[y])\n                continue;\n            flag[y] = 1;\n            auto from = f(y);\n\n            vector<vector<ll>> next(sizesum + size[y] + 1, vector<ll>(2, INF));\n\n            for(int i = 0; i <= sizesum; ++i){\n                for(int j = 0; j < size[y]; ++j){\n                    next[i + j][0] = min(next[i + j][0], dp[i][0] + from[j][0]);\n                    next[i + j][0] = min(next[i + j][0], dp[i][0] + from[j][1]);\n                    next[i + j][0] = min(next[i + j][0], dp[i][1] + from[j][0]);\n                    next[i + j][0] = min(next[i + j][0], dp[i][1] + from[j][1]);\n                    if(a[x] > 0 && from[j][1] != INF)\n                        next[i + j][1] = min(next[i + j][1], dp[i][1] + from[j][1]);\n                    // 分断が可能なら\n                    if(from[j][0] < 0 || from[j][1] != INF){\n                        next[i + j + 1][0] = min(next[i + j + 1][0], dp[i][0]);\n                        if(a[x] > 0)\n                            next[i + j + 1][1] = min(next[i + j + 1][1], dp[i][1]);\n                    }\n                }\n            }\n            dp = move(next);\n            sizesum += size[y];\n        }\n        return dp;\n    };\n    flag[0] = 1;\n    auto dp = f(0);\n    int ans = 1e9;\n    for(int j = 0; j < (int)dp.size(); ++j){\n        if(dp[j][0] < 0)\n            ans = min(ans, j);\n        if(dp[j][1] != INF)\n            ans = min(ans, j);\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n#define int ll\n\n#define REP(i,n) for(int i=0;i<n;++i)\n#define SORT(name) sort(name.begin(), name.end())\n#define ZERO(p) memset(p, 0, sizeof(p))\n#define MINUS(p) memset(p, -1, sizeof(p))\n#if 1\n#  define DBG(fmt, ...) printf(fmt, ##__VA_ARGS__)\n#else\n#  define DBG(fmt, ...)\n#endif\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst double DINF = std::numeric_limits<double>::infinity();\nconst int MOD = 1000000007;\n#define MAX_N 5010\n\nll N;\nvector<ll> A;\nvector< vector<ll> > G; // グラフ(隣接リスト)\n\n// 頂点 v を根とした部分木に何個の頂点が含まれるか(自分含む)\nll num[MAX_N];\n\n// dp[v][num][0]\n// v が根。 num 本の辺を切断する場合 、かつ、\n// v を含まない連結成分は条件を満たす場合の、\n// v を含む連結成分の重みの総和の最小\n// dp[v][num][1]\n// v が根。 num 本の辺を切断する場合、かつ、\n// v を含まない連結成分は条件を満たす場合、かつ、\n// v を含む連結成分の重みがすべて正の場合の、総和の最小\nll dp[MAX_N][MAX_N][2];\n\n// 頂点 v の子ノードに対する dp\n// dp[][][] を作成するために各頂点ごとに初期化して利用する一時的なテーブル\n// sdp[num][0]\n// num 本の辺を切断する場合 、かつ、\n// v を含まない連結成分は条件を満たす場合の、\n// v を含む連結成分の重みの総和の最小\n// sdp[num][1]\n// num 本の辺を切断する場合、かつ、\n// v を含まない連結成分は条件を満たす場合、かつ、\n// v を含む連結成分の重みがすべて正の場合の、総和の最小\nll sdp[MAX_N][2];\n\n// v: 頂点 id\n// parent: v の前に辿っていた頂点(親)\n// dp[] を葉から順に埋めていく\nvoid rec(ll v, ll parent) {\n    // num[v] の作成\n    num[v] = 1;\n    for(auto& child : G[v]) {\n        if(child == parent) { continue; }\n        rec(child, v);\n        num[v] += num[child];\n    }\n\n    // sdp 初期化\n    for(ll j = 0; j <= num[v]; ++j) { sdp[j][0] = sdp[j][1] = LLINF; }\n\n    sdp[0][0] = A[v];\n    if(A[v] > 0) { sdp[0][1] = A[v]; }\n\n    // 現在までに見た部分木のノード数の和(= 今までの切断可能辺数)\n    ll curnum = 0;\n\n    // 頂点 v の子である頂点 child について考える\n    for(auto child : G[v]) {\n        if(child == parent) { continue; }\n\n        for(ll j = curnum; j >= 0; --j) {\n            ll tmp0 = sdp[j][0];    // v 以下の部分木で切断辺数が j のときの、総和の最小値\n            ll tmp1 = sdp[j][1];    // v 以下の部分木で切断辺数が j のときの、総和の最小値(重みが正のみ)\n            sdp[j][0] = sdp[j][1] = LLINF;\n\n            // k : 切断可能辺数\n            for(ll k = 0; k <= num[child]; ++k) {\n                // dp[child][k][0] : 頂点 child 以下の部分木から k 個の辺を切断したときの\n                //                   連結成分の重みの総和の最大値\n                sdp[j+k][0] = min(sdp[j+k][0], tmp0 + dp[child][k][0]);\n\n                // もし総和が機能停止の条件を満たす\n                //   (負か重みが正のみの総和も値が入っている(LLINF じゃない) )\n                // ときは、全てを切り離した際の値も更新できる\n                if(dp[child][k][0] < 0 || dp[child][k][1] < LLINF / 2) {\n                    sdp[j+k+1][0] = min(sdp[j+k+1][0], tmp0);\n                }\n\n                // 重みが正なら、正のみの dp テーブルも更新\n                if(A[v] > 0) {\n                    sdp[j+k][1] = min(sdp[j+k][1], tmp1 + dp[child][k][1]);\n                    if(dp[child][k][0] < 0 || dp[child][k][1] < LLINF/ 2) {\n                        sdp[j+k+1][1] = min(sdp[j+k+1][1], tmp1);\n                    }\n                }\n            }\n        }\n        // この child 以下の辺の数 + v と child をつなぐ辺 = num[child]\n        // なので curnum として保持しておく\n        curnum += num[child];\n    }\n\n    // sdp の dp への反映\n    for(ll j = 0; j <= num[v]; ++j) {\n        dp[v][j][0] = sdp[j][0];\n        dp[v][j][1] = sdp[j][1];\n    }\n}\n\nsigned main()\n{\n    cin >> N;\n    A.resize(N);\n    REP(i, N) { cin >> A[i]; }\n    G.assign(N, vector<ll>());\n    REP(i, N-1) {\n        ll u, v;\n        cin >> u >> v;\n        --u; --v;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n\n    // DP 初期化\n    REP(i, MAX_N) { REP(j, MAX_N) { dp[i][j][0] = dp[i][j][1] = LLINF; } }\n    // 0 を根とした dp テーブルの作成\n    rec(0, -1);\n\n    // ans を求める\n    ll ans = N;\n    for(ll i = 0; i <= N; ++i) {\n        // 0 を根として、 i 回切断したときに条件が満たされるなら ans を更新\n        if(dp[0][i][0] < 0) { ans = min(ans, i); }\n        if(dp[0][i][1] < INF / 2) { ans = min(ans, i); }\n    }\n    printf(\"%lld\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst ll oo = 1e18;\nconst int N = 5005;\n\nint n, A[N];\nvector<int> adj[N];\nvector<ll> dp1[N], dp2[N];\n\nvector<ll> merge(const vector<ll> &dp, const vector<ll> &ch1, const vector<ll> &ch2, bool flag) {\n  vector<ll> res(dp.size() + ch1.size(), oo);\n  for (int i = 0; i < (int)dp.size(); ++i) {\n    for (int j = 0; j < (int)ch1.size(); ++j) {\n      if (i + j - 1) {\n        if (ch1[j] != oo) res[i + j - 1] = min(res[i + j - 1], dp[i] + ch1[j]);\n        if (ch2[j] != oo && !flag) res[i + j - 1] = min(res[i + j - 1], dp[i] + ch2[j]);\n      }\n      if (ch1[j] != oo) res[i + j] = min(res[i + j], dp[i]);\n      if (ch2[j] < 0) res[i + j] = min(res[i + j], dp[i]);\n    }\n  }\n  return res;\n}\n\nvoid dfs(int u, int p) {\n  dp1[u].emplace_back(oo);\n  dp1[u].emplace_back(A[u] > 0 ? A[u] : oo);\n  dp2[u].emplace_back(oo);\n  dp2[u].emplace_back(A[u]);\n  for (int v: adj[u]) {\n    if (v == p) continue;\n    dfs(v, u);\n    dp1[u] = merge(dp1[u], dp1[v], dp2[v], true);\n    dp2[u] = merge(dp2[u], dp1[v], dp2[v], false);\n  }\n}\n\nint main() {\n  ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n  cin >> n;\n  for (int i = 1; i <= n; ++i) cin >> A[i];\n  for (int i = 1, u, v; i < n; ++i) {\n    cin >> u >> v;\n    adj[u].emplace_back(v);\n    adj[v].emplace_back(u);\n  }\n  dfs(1, -1);\n  for (int k = 1; k <= n; ++k) {\n    if (dp1[1][k] != oo || dp2[1][k] < 0) {\n      cout << (k - 1);\n      return 0;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n \n#define rep(i, n)      for (int i = 0; i < (n); i++)\n#define repr(i, n)     for (int i = (n) - 1; i >= 0; i--)\n#define repe(i, l, r)  for (int i = (l); i < (r); i++)\n#define reper(i, l, r) for (int i = (r) - 1; i >= (l); i--)\n#define repi(i, l, r)  for (int i = (l); i <= (r); i++)\n#define repir(i, l, r) for (int i = (r); i >= (l); i--)\n#define range(a) a.begin(), a.end()\nvoid initio() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); }\n\nvoid chmin(ll &x, ll y) {\n  x = min(x, y);\n}\n\nint main() { initio();\n  int N; cin >> N;\n  vector<ll> A(N); rep(i, N) cin >> A[i];\n  vector<vector<int>> G(N);\n  rep(i, N-1) {\n    int u, v; cin >> u >> v; u--; v--;\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  constexpr ll inf = 1e18;\n  vector<vector<ll>> dp0(N); // all positive\n  vector<vector<ll>> dp1(N); // some negative\n  auto merge = [&](vector<ll> a0, vector<ll> a1, vector<ll> b0, vector<ll> b1) -> pair<vector<ll>, vector<ll>> {\n    const int n = a0.size();\n    const int m = b0.size();\n    vector<ll> c0(n + m - 1, inf);\n    vector<ll> c1(n + m - 1, inf);\n    repe(i, 1, n) repe(j, 1, m) {\n      if (b0[j] != inf) {\n        if (a0[i] != inf) chmin(c0[i + j - 1], a0[i] + b0[j]);\n        if (a1[i] != inf) chmin(c1[i + j - 1], a1[i] + b0[j]);\n        if (a0[i] != inf) chmin(c0[i + j], a0[i]);\n        if (a1[i] != inf) chmin(c1[i + j], a1[i]);\n      }\n      if (b1[j] != inf) {\n        if (a0[i] != inf) chmin(c1[i + j - 1], a0[i] + b1[j]);\n        if (a1[i] != inf) chmin(c1[i + j - 1], a1[i] + b1[j]);\n        if (b1[j] < 0) {\n          if (a0[i] != inf) chmin(c0[i + j], a0[i]);\n          if (a1[i] != inf) chmin(c1[i + j], a1[i]);\n        }\n      }\n    }\n    return {c0, c1};\n  };\n  auto dfs = [&](auto dfs, int u, int p) -> void {\n    if (A[u] > 0) {\n      dp0[u] = {inf, A[u]};\n      dp1[u] = {inf, inf};\n    } else {\n      dp1[u] = {inf, A[u]};\n      dp0[u] = {inf, inf};\n    }\n    for (int v : G[u]) if (v != p) {\n      dfs(dfs, v, u);\n      auto p = merge(dp0[u], dp1[u], dp0[v], dp1[v]);\n      tie(dp0[u], dp1[u]) = p;\n    }\n  };\n  dfs(dfs, 0, -1);\n  repe(i, 1, N + 1) {\n    if (dp0[0][i] != inf || dp1[0][i] < 0) {\n      cout << i - 1 << endl;\n      return 0;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\n\nconst ll INF = 10000000000000;\n\nstruct Graph\n{\n    int n;\n    vector<vector<int>> g;\n    \n    Graph(int n) : n(n){\n        g.resize(n);\n    }\n    \n    void init(int n_){\n        n = n_;\n        g.resize(n_);\n    }\n    \n    void add_edge(int from, int to){\n        g[from].push_back(to);\n    }\n};\n\nstruct Tree\t//create tree(directed) from graph(undirected)\n{\n    int n;\n    int root;\n    vector<vector<int>> t;\n    vector<int> par;\n    vector<int> dpt;\n    \n    void init(Graph &g, int root_){\n        n = g.n;\n        root = root_;\n        t.resize(n);\n        par.resize(n);\n        dpt.resize(n);\n        fill(dpt.begin(), dpt.end(), -1);\n        queue<int> que;\n        par[root] = -1;\n        dpt[root] = 0;\n        que.push(root);\n        while(que.size()){\n            int pa = que.front();\n            que.pop();\n            for(int ch : g.g[pa]){\n                if(dpt[ch] == -1){\n                    t[pa].push_back(ch);\n                    par[ch] = pa;\n                    dpt[ch] = dpt[pa] + 1;\n                    que.push(ch);\n                }\n            }\n        }\n    }\n\n    Tree(){}\n    \n    Tree(Graph &g, int root_){\n        init(g, root_);\n    }\n    \n    vector<int> toposort(){\n        typedef pair<int, int> P;\n        vector<P> p(n);\n        for(int i = 0; i < n; i++) p[i] = P(dpt[i], i);\n        sort(p.begin(), p.end(), greater<P>());\n        vector<int> res(n);\n        for(int i = 0; i < n; i++) res[i] = p[i].second;\n        return res;\n    }\n};\n\nll dp[5005][2][5005];\nint w[5005];\n\nint main()\n{\n    int n;\n    cin >> n;\n    ll a[5005];\n    for(int i = 0; i < n; i++) cin >> a[i];\n    Graph g(n);\n    for(int i = 0; i < n - 1; i++){\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        g.add_edge(u, v);\n        g.add_edge(v, u);\n    }\n    Tree t(g, 0);\n    vector<int> d = t.toposort();\n    int s[5002];\n    for(int i = 0; i < n; i++){\n        int u = d[i];\n        s[u] = 1;\n        for(int v : t.t[u]){\n            s[u] += s[v];\n        }\n    }\n    for(int i = 0; i < n; i++){\n        for(int k = 0; k <= n; k++) dp[i][0][k] = dp[i][1][k] = INF;\n        dp[i][0][0] = 0;\n    }\n    for(int i = 0; i < n; i++){\n        int u = d[i];\n        int r = 1;\n        for(int j = 1; j <= (int)t.t[u].size(); j++){\n            int v = t.t[u][j - 1];\n            for(int k = 0; k < r + s[v]; k++){\n                dp[u][j % 2][k] = INF;\n            }\n            for(int k = 0; k < r; k++){\n                for(int l = 0; l <= s[v]; l++){\n                    dp[u][j % 2][k + l] = min(dp[u][j % 2][k + l], dp[u][(j + 1) % 2][k] + dp[v][0][l]);\n                }\n            }\n            r += s[v];\n        }\n        if((int)t.t[u].size() % 2){\n            for(int k = 0; k < r; k++) dp[u][0][k] = dp[u][1][k];\n        }\n        for(int k = 0; k < r; k++) dp[u][0][k] += a[u];\n        dp[u][0][r] = 0;\n        if(a[u] > 0){\n            for(int v : t.t[u]){\n                int k;\n                for(k = 0; k < s[v]; k++){\n                    if(dp[v][0][k] < 0) break;\n                }\n                w[u] += min(w[v], k + 1);\n            }\n            for(int k = w[u] + 1; k <= s[u]; k++) dp[u][0][k] = min(dp[u][0][k], 0ll);\n        }\n        else{\n            w[u] = n;\n        }\n    }\n    int ans;\n    for(ans = 0; ans <= s[0]; ans++){\n        if(dp[0][0][ans] < 0) break;\n    }\n    ans = min(ans, w[0]);\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//注意点\n//Tは3つの値を持つ構造\n//だがワイルドカードとしても使っている\n#include <bits/stdc++.h>\nusing namespace std;\n//@起動時\nstruct initon {\n    initon() {\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.setf(ios::fixed);\n        cout.precision(16);\n    };\n} __initon;\n\n//@必須構造\nstruct T {\n    int f, s, t;\n    T() { f = -1, s = -1, t = -1; }\n    T(int f, int s, int t) : f(f), s(s), t(t) {}\n    bool operator<(const T &r) const {\n        return f != r.f ? f < r.f : s != r.s ? s < r.s : t < r.t;\n        //return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 大きい順\n    }\n    bool operator>(const T &r) const {\n        return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t;\n        //return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 小さい順\n    }\n    int operator[](int i) {\n        assert(i < 3);\n        return i == 0 ? f : i == 1 ? s : t;\n    }\n};\n\n//@マクロ省略系 型,構造\n\n#define int long long\n#define ll long long\n#define double long double\n#define ull unsigned long long\nusing dou = double;\nusing itn = int;\nusing str = string;\nusing bo= bool;\nusing P = pair<int, int>;\n#define F first\n#define S second\n#define vec vector\n#define con continue\n#define bre break\n#define brk break\n#define is ==\n#define rs resize\n\n//マクロ省略系 コンテナ\nusing vi = vector<int>;\n#define vvi(a, b, c) vec<vi> a(b,vi(c))\nusing vb = vector<bool>;\n#define vvb(a, b, c) vec<vb> a(b,vb(c))\nusing vs = vector<string>;\n#define vvs(a, b, c) vec<vs> a(b,vs(c))\nusing vl = vector<ll>;\n#define vvl(a, b, c) vec<vl> a(b,vl(c))\nusing vd = vector<double>;\n#define vvd(a, b, c) vec<vd> a(b,vd(c))\nusing vc=vector<char>;\n#define vvc(a, b, c) vec<vc> a(b,vc(c))\nusing vp = vector<P>;\n#define vvp(a, b, c) vec<vp> a(b,vp(c))\nusing vt = vector<T>;\n#define vvt(a, b, c) vec<vt> a(b,vt(c))\n#define v3i(a, b, c, d) vector<vector<vi>> a(b, vector<vi>(c, vi(d)))\n#define v3d(a, b, c, d) vector<vector<vd>> a(b, vector<vd>(c, vd(d)))\n#define v3m(a, b, c, d) vector<vector<vm>> a(b, vector<vm>(c, vm(d)))\n#define PQ priority_queue<ll, vector<ll>, greater<ll> >\nusing seti = set<int>;\n#define uset unordered_set\n#define mset multiset\n#define umap unordered_map\n#define mmap multimap\n\n//マクロ 繰り返し\n#define _overloadrep(_1, _2, _3, name, ...) name\n# define _rep(i, n) for(int i = 0; i < n ; i++)\n#define repi(i, m, n) for(int i = m; i < n ; i++)\n#define rep(...) _overloadrep(__VA_ARGS__,repi,_rep,)(__VA_ARGS__)\n#define _rer(i, n) for(int i = n; i >= 0 ; i--)\n#define reri(i, m, n) for(int i = m; i >= n ; i--)\n#define rer(...) _overloadrep(__VA_ARGS__,reri,_rer,)(__VA_ARGS__)\n#define fora(a, b) for(auto&& a : b)\n#define forg(gi, ve) if (ve.size())for (int gi = 0, f = ve[gi].from, t = ve[gi].to, c = ve[gi].cost; gi < ve.size(); gi++,f = ve[gi].from, t = ve[gi].to, c = ve[gi].cost)\n\n//マクロ 定数\n#define k4 10101\n#define k5 101010\n#define k6 1010101\n#define k7 10101010\nconst int inf = (int) 1e9 + 100;\nconst ll linf = (ll) 1e18 + 100;\nconst double eps = 1e-9;\nconst int y4[] = {-1, 1, 0, 0};\nconst int x4[] = {0, 0, -1, 1};\nconst int y8[] = {0, 1, 0, -1, -1, 1, 1, -1};\nconst int x8[] = {1, 0, -1, 0, 1, -1, 1, -1};\n\n//マクロ省略形 関数等\n#define arsz(a) (sizeof(a)/sizeof(a[0]))\n#define sz(a) (a.size())\n#define mp make_pair\n#define pb push_back\n#define pf push_front\n#define eb emplace_back\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\n//@拡張系 こう出来るべきというもの\n\n//埋め込み 存在を意識せずに機能を増やされているもの\n// 境界チェック付きvector\nnamespace std_vector_bounds_checking {\n    using namespace std;\n    template<class T, class A = std::allocator<T>> struct vector : std::vector<T, A> {\n        using std::vector<T, A>::vector;\n        typename std::vector<T>::reference operator[](typename std::vector<T>::size_type n) {\n            return this->at(n);\n        }\n    };\n}\nnamespace std {\n    template<> class hash<std::pair<signed, signed>> {\n    public:\n        size_t operator()(const std::pair<signed, signed> &x) const {\n            return hash<ll>()(((ll) x.first << 32) + x.second);\n        }\n    };\n    template<> class hash<std::pair<ll, ll>> {\n    public:\n        size_t operator()(const std::pair<ll, ll> &x) const {\n            return hash<ll>()(((ll) x.first << 32) + x.second);\n        }\n    };\n}\ntemplate<typename T> istream &operator>>(istream &iss, vector<T> &vec) {\n    for (T &x: vec) iss >> x;\n    return iss;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, vector <T> &vec) {\n    for (int i = 0; i < vec.size(); i++)os << vec[i] << (i + 1 == vec.size() ? \"\" : \" \");\n    return os;\n}\ntemplate<typename V, typename H> void resize(vector<V> &vec, const H head) {  //再帰の終端。 可変長templateの長さが 0 になるとこっちが呼ばれる。\n    vec.resize(head);\n}\ntemplate<typename V, typename H, typename ... T> void resize(vector<V> &vec, const H &head, const T ... tail) {\n    vec.resize(head);\n    for (auto &v: vec) resize(v, tail...);\n}\ntemplate<class T> T pop(set<T> &set) {\n    T res = *set.begin();\n    set.erase(set.find(res));\n    return res;\n}\ntemplate<class T> T pop(mset<T> &set) {\n    T res = *set.begin();\n    set.erase(set.find(res));\n    return res;\n}\ntemplate<class T> T popBack(set<T> &set) {\n    T res = *set.rbegin();\n    set.erase(set.find(res));\n    return res;\n}\ntemplate<class T> T popBack(mset<T> &set) {\n    T res = *set.rbegin();\n    set.erase(set.find(res));\n    return res;\n}\ntemplate<class T> inline void sort(vector<T> &a) { sort(a.begin(), a.end()); };\ntemplate<class T> inline void rsort(vector<T> &a) { sort(a.begin(), a.end(), greater<T>()); };\ntemplate<class T> inline void sort(vector<T> &a, int len) { sort(a.begin(), a.begin() + len); };\ntemplate<class T> inline void rsort(vector<T> &a, int len) { sort(a.begin(), a.begin() + len, greater<T>()); };\ntemplate<class T> inline void sort2(vector<vector<T>> &a) { for (int i = 0, n = a.size(); i < n; i++)sort(a[i]); }\ntemplate<class T> inline void rsort2(vector<vector<T>> &a) { for (int i = 0, n = a.size(); i < n; i++)rsort(a[i]); }\ntemplate<typename A, size_t N, typename T> void fill(A (&a)[N], const T &v) { rep(i, N)a[i] = v; }\ntemplate<typename A, size_t N, size_t O, typename T> void fill(A (&a)[N][O], const T &v) { rep(i, N)rep(j, O)a[i][j] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, typename T> void fill(A (&a)[N][O][P], const T &v) { rep(i, N)rep(j, O)rep(k, P)a[i][j][k] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, typename T> void fill(A (&a)[N][O][P][Q], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)a[i][j][k][l] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, typename T> void fill(A (&a)[N][O][P][Q][R], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)a[i][j][k][l][m] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S, typename T> void fill(A (&a)[N][O][P][Q][R][S], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)rep(n, S)a[i][j][k][l][m][n] = v; }\ntemplate<typename V, typename T> void fill(V &x, const T &val) { x = val; }\ntemplate<typename V, typename T> void fill(vector<V> &vect, const T &val) { for (auto &v: vect) fill(v, val); }\n//@汎用便利関数 入力\ntemplate<typename T = int> T in() {\n    T x;\n    cin >> x;\n    return (x);\n}\nstring sin() { return in<string>(); }\ndouble din() { return in<double>(); }\nll lin() { return in<ll>(); }\n#define na(a, n) rep(i,n) cin >> a[i];\n#define nad(a, n) rep(i,n) cin >> a[i], a[i]--;\n#define na3(a, b, c, n) rep(i, n)cin >> a[i] >> b[i] >> c[i];\n#define add2(a, b, n) rep(i, n)a.pb(in()),b.pb(in());\n#define add2d(a, b, n) rep(i, n)a.pb(in()-1),b.pb(in()-1);\n#define add3(a, b, c, n) rep(i, n)a.pb(in()),b.pb(in()),c.pb(in());\n#define add3d(a, b, c, n) rep(i, n)a.pb(in()-1),b.pb(in()-1),c.pb(in());\n#define na2(a, b, n) rep(i, n)cin >> a[i] >> b[i];\n#define nt(a, h, w) rep(hi,h)rep(wi,w) cin >> a[hi][wi];\n#define ntd(a, h, w) rep(hi,h)rep(wi,w) cin >> a[hi][wi], a[hi][wi]--;\n#define ntp(a, h, w) fill(a,'#');rep(hi,1,h+1)rep(wi,1,w+1) cin >> a[hi][wi];\n#define addn(a, n) a.resize(n);na(a,n);\n#define addnd(a, n) a.resize(n);na(a,n);rep(i,n)a[i]--;\n\n\n\n\n\n\n\n\ntemplate<class T> inline void fin(T s) { cout << s << endl, exit(0); }\n\ntemplate<class T> struct edge {\n    int from, to;\n    T cost;\n    int id;\n    int type;\n    edge(int f, int t, T c = 1, int id = -1, int ty = -1) : from(f), to(t), cost(c), id(id), type(ty) {}\n    bool operator<(const edge &b) const { return cost < b.cost; }\n    bool operator>(const edge &b) const { return cost > b.cost; }\n};\n\ntemplate<typename T> class graph {\nprotected:\n    vector<bool> _used;\npublic :\n    vector<vector<edge<T>>> g;\n    vector<edge<T>> edges;\n    int n, root = -1;\n    graph(int n) : n(n) { g.resize(n), _used.resize(n); }\n    void clear() { g.clear(), edges.clear(); }\n    void resize(int n) {\n        this->n = n;\n        g.resize(n);\n        _used.resize(n);\n    }\n    int size() { return g.size(); }\n    bool isleaf(int v) {\n        assert(root != -1);\n        return g[v].size() == 1 && g[v][0].from != root;\n    }\n    vector<edge<T> > &operator[](int i) { return g[i]; }\n    virtual void add(int from, int to, T cost, int ty) = 0;\n    virtual bool used(edge<T> &e) = 0;\n    virtual bool used(int id) = 0;\n    virtual void del(edge<T> &e) = 0;\n    virtual void del(int id) = 0;\n};\n\ntemplate<class T=int> class undigraph : public graph<T> {\npublic:\n    using graph<T>::g;\n    using graph<T>::n;\n    using graph<T>::edges;\n    using graph<T>::_used;\n    undigraph(int n) : graph<T>(n) {\n    }\n    void add(int f, int t, T cost = 1, int ty = -1) {\n        int id = edges.size();\n        g[f].emplace_back(f, t, cost, id, ty);\n        g[t].emplace_back(t, f, cost, id + 1, ty);\n        edges.emplace_back(f, t, cost, id, ty);\n        edges.emplace_back(t, f, cost, id + 1, ty);\n    }\n    void add(edge<T> &e) {\n        int f = e.from, t = e.to, ty = e.type;\n        T cost = e.cost;\n        add(f, t, cost, ty);\n    }\n    bool used(edge<T> &e) { return _used[e.id]; }\n    bool used(int id) { return _used[id]; }\n    void del(edge<T> &e) { _used[e.id] = _used[e.id ^ 1] = 1; }\n    void del(int id) { _used[id] = _used[id ^ 1] = 1; }\n};\n\ntemplate<typename T =ll> class digraph : public graph<T> {\npublic:\n    using graph<T>::g;\n    using graph<T>::n;\n    using graph<T>::edges;\n    using graph<T>::_used;\n\n    digraph(int n) : graph<T>(n) {}\n    void add(int f, int t, T cost = 1, int ty = -1) {\n\n        int id = edges.size();\n        g[f].emplace_back(f, t, cost, ty, id);\n        edges.emplace_back(f, t, cost, ty, id);\n    }\n    bool used(edge<T> &e) { return _used[e.id]; }\n    bool used(int id) { return _used[id]; }\n    void del(edge<T> &e) { _used[e.id] = _used[e.id ^ 1] = 1; }\n    void del(int id) { _used[id] = _used[id ^ 1] = 1; }\n};\n\n\n\n\n\ntemplate<class T, class U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n\n\n\n\n\n\n\n\nint n, k, m, h, w, x, y, q;\nint cou;\nvi a, b, c;\nv3i(dp, 5000, 5001, 2);//コンピューターしかないか\nvvi(sub, 5050, 2);\nundigraph<> g(0);\nvi es(5050);\n\nvoid ds(int i, int p) {\n    forg(gi, g[i])if (t != p)ds(t, i);\n    int sum = 0;\n    dp[i][0][a[i] < 0] = a[i];\n    forg(gi, g[i]) {\n            if (t == p)continue;\n            rep(ci, sum + 1) {\n                rep(ct, es[t] + 1) {\n                    rep(ki, 2) {\n                        rep(kt, 2) {\n                            //繋ぐ\n                            if (dp[i][ci][ki] < linf && dp[t][ct][kt] < linf)\n                                chmin(sub[ci + ct][ki || kt], dp[i][ci][ki] + dp[t][ct][kt]);\n                            //切る\n                            if (dp[t][ct][kt] < 0 || (!kt && dp[t][ct][kt] != linf))\n                                chmin(sub[ci + ct + 1][ki], dp[i][ci][ki]);\n                        }\n                    }\n                }\n            }\n            sum += es[t] + 1;\n            rep(j, sum + 1)\n                rep(k, 2) {\n                    dp[i][j][k] = sub[j][k];\n                    sub[j][k] = linf;\n\n                }\n        }\n    es[i] = sum;\n}\nsigned main() {\n    cin >> n;\n    addn(a, n);\n    g.resize(n);\n    rep(i, n - 1) {\n        int f, s;\n        cin >> f >> s;\n        --f, --s;\n        g.add(f, s);\n    }\n    fill(dp, linf);\n    fill(sub, linf);\n//    ds(0, -1);\n    rep(c, n)rep(k, 2) {\n            if (k) {\n                if (dp[0][c][k] < 0)fin(c);\n            } else if (dp[0][c][k] != linf)fin(c);\n        }\n    cout << \"aa\" << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << (x) << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){\n\treturn o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";\n}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){\n\to<<\"{\";\n\tfor(const T& v:vc) o<<v<<\",\";\n\to<<\"}\";\n\treturn o;\n}\nusing ll = long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<vector<T>>;\nint N;\nV<ll> A;\nVV<int> G;\nV<int> sz;\nll dp[5010][2][5010];\nll inner[2][5010];\nll ninner[2][5010];\nll inf = 1e18;\nvoid dfs(int v,int p){\n\tsz[v] = 1;\n\tfor(int u:G[v]) if(u!=p) dfs(u,v),sz[v] += sz[u];\n\tint S = 1;\n\tinner[0][0] = inner[1][0] = A[v];\n\tif(A[v]<0) inner[1][0] = inf;\n\tfor(int u:G[v]) if(u!=p){\n\t\trep(i,2) rep(j,S+sz[u]) ninner[i][j] = inf;\n\t\trep(allp,2) rep(c,S) if(inner[allp][c] != inf){\n\t\t\trep(uallp,2) rep(uc,sz[u]+1) if(dp[u][uallp][uc] != inf){\n\t\t\t\tchmin(ninner[allp&uallp][c+uc],inner[allp][c] + dp[u][uallp][uc]);\n\t\t\t\tif(uallp==1 || dp[u][uallp][uc]<0){\n\t\t\t\t\tchmin(ninner[allp][c+uc+1],inner[allp][c]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i,2) rep(j,S+sz[u]) inner[i][j] = ninner[i][j];\n\t\tS += sz[u];\n\t}\n\trep(i,2) rep(j,S) dp[v][i][j] = inner[i][j];\n}\nint main(){\n\tcin>>N;\n\tA.resize(N);\n\tG.resize(N);\n\tsz.resize(N);\n\trep(i,N) cin>>A[i];\n\trep(i,N-1){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tx--,y--;\n\t\tG[x].pb(y);\n\t\tG[y].pb(x);\n\t}\n\tdfs(0,-1);\n\tint ans = N;\n\trep(allp,2) rep(c,N) if(dp[0][allp][c] != inf){\n\t\tif(allp==1 || dp[0][allp][c]<0) chmin(ans,c);\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <assert.h>\n#include <fstream>\n#include <iostream>\n#include <algorithm>\n#include <array>\n#include <vector>\n#include <queue>\n#include <set>\n#include <cmath>\n#include <iomanip>\n//#include <unordered_map>\n//#include <unordered_set>\n//#include <boost/container/static_vector.hpp>\n//#include <boost/unordered_set.hpp>\n//#include <boost/unordered_map.hpp>\n//#include <unistd.h>\n\nclass Tree {\n    public:\n    struct Node {\n        std::vector<int> edge;\n        int rank;\n        int child_bond_num;\n        int direction;\n    };\n    std::vector<Node> node;\n    Tree() {}\n    Tree(const int node_num_max) {\n        node.resize(node_num_max);\n    }\n    void add_directed_edge(const int from, const int to) {\n        node[from].edge.push_back(to);\n    }\n    void add_undirected_edge(const int node1, const int node2) {\n        add_directed_edge(node1, node2);\n        add_directed_edge(node2, node1);\n    }\n    void set_rank(int n, int rank, int parent) { // 辺が有向でも無向でも使える。呼び出すとき、parentは-1にしておくとよい。\n        node[n].rank = rank;\n        for (int c : node[n].edge) {\n            if (c != parent) {\n                set_rank(c, rank + 1, n);\n            }\n        }\n    }\n    int calc_diameter(int max_idx) {\n        // 点は1～max_idxという想定。\n        set_rank(1, 0, -1);\n        int tmp_idx = 1;\n        int tmp_diameter = 0;\n        for (int i = 1; i <= max_idx; i++) {\n            if (tmp_diameter < node[i].rank) {\n                tmp_idx = i;\n                tmp_diameter = node[i].rank;\n            }\n        }\n        set_rank(tmp_idx, 0, -1);\n        for (int i = 1; i <= max_idx; i++) {\n            tmp_diameter = std::max(tmp_diameter, node[i].rank);\n        }\n        return tmp_diameter;\n    }\n};\n\nconst int MAX_N = 5050;\nint N, U[MAX_N], V[MAX_N];\nlong long A[MAX_N];\n\nTree tree = Tree(MAX_N);\n\nlong long dp_pos[MAX_N][MAX_N], dp_neg[MAX_N][MAX_N];\nlong long MAX_V = (long long)1000000000 * 10000;\n\nlong long dp_pos_tmp[MAX_N][MAX_N], dp_neg_tmp[MAX_N][MAX_N];\n\nvoid merge(int n) {\n    int child[MAX_N];\n    int child_num = 0;\n    for (int i = 0; i < tree.node[n].edge.size(); i++) {\n        int c = tree.node[n].edge[i];\n        if (tree.node[c].rank > tree.node[n].rank) {\n            child[child_num+1] = c;\n            child_num++;\n        }\n    }\n\n    dp_pos_tmp[0][0] = 0 < A[n] ? A[n] : MAX_V;\n    dp_neg_tmp[0][0] = A[n];\n\n    tree.node[n].child_bond_num = 0;\n    for (int i = 1; i <= child_num; i++) {\n        int c = child[i];\n\n        for (int j = 0; j <= tree.node[n].child_bond_num + tree.node[c].child_bond_num + 1; j++) {\n            dp_pos_tmp[i][j] = MAX_V;\n            dp_neg_tmp[i][j] = MAX_V;\n        }\n\n        for (int j = 0; j <= tree.node[n].child_bond_num; j++) {\n            for (int k = 0; k <= tree.node[c].child_bond_num; k++) {\n                //if (n == 4) {\n                //    std::cout << \"check_s:\" << i << \" \" << j << \" \" << k << \" \" << dp_neg_tmp[i][1] << \" \" << dp_neg_tmp[i-1][j] << \" \" << dp_pos[c][k] << \" \" << dp_neg[c][k] << std::endl;\n                //}\n                if (dp_neg_tmp[i-1][j] < 0 && (dp_neg[c][k] < 0 || dp_pos[c][k] < MAX_V)) {\n                    dp_neg_tmp[i][j+k+1] = std::min(dp_neg_tmp[i][j+k+1], dp_neg_tmp[i-1][j]);\n                }\n                if (dp_neg_tmp[i-1][j] < MAX_V && dp_pos[c][k] < MAX_V) {\n                    dp_neg_tmp[i][j+k] = std::min(dp_neg_tmp[i][j+k], dp_neg_tmp[i-1][j] + dp_pos[c][k]);\n                }\n                if (dp_neg_tmp[i-1][j] < MAX_V && dp_neg[c][k] < MAX_V) {\n                    dp_neg_tmp[i][j+k] = std::min(dp_neg_tmp[i][j+k], dp_neg_tmp[i-1][j] + dp_neg[c][k]);\n                }\n                if (0 < A[n]) {\n                    dp_pos_tmp[i][j+k] = std::min(dp_pos_tmp[i][j+k], dp_pos_tmp[i-1][j] + dp_pos[c][k]);\n                    if (dp_pos[c][k] < MAX_V || dp_neg[c][k] < 0) {\n                        dp_pos_tmp[i][j+k+1] = std::min(dp_pos_tmp[i][j+k+1], dp_pos_tmp[i-1][j]);\n                    }\n                }\n\n                //if (n == 4) {\n                //    std::cout << \"check_e:\" << i << \" \" << j << \" \" << k << \" \" << dp_neg_tmp[i][1] << \" \" << dp_neg_tmp[i-1][j] << \" \" << dp_pos[c][k] << \" \" << dp_neg[c][k] << std::endl;\n                //}\n\n            }\n        }\n        tree.node[n].child_bond_num += 1 + tree.node[c].child_bond_num;\n\n        //for (int j = 0; j <= tree.node[n].child_bond_num; j++) {\n        //    std::cout << n << \" \" << i << \" \" << j << \" \" << dp_pos_tmp[i][j] << \" \" << dp_neg_tmp[i][j] << std::endl;\n        //}\n\n    }\n\n    for (int j = 0; j <= tree.node[n].child_bond_num; j++) {\n        dp_pos[n][j] = dp_pos_tmp[child_num][j];\n        dp_neg[n][j] = dp_neg_tmp[child_num][j];\n    }\n\n    //for (int i = 0; i <= tree.node[n].child_bond_num; i++) {\n    //    std::cout << n << \" \" << i << \" \" << dp_pos[n][i] << \" \" << dp_neg[n][i] << std::endl;\n    //}\n\n}\n\nint main(int argc, char **argv) {\n    std::cin >> N;\n    \n    for (int i = 1; i <= N; i++) {\n        std::cin >> A[i];\n    }\n\n    for (int i = 1; i <= N - 1; i++) {\n        std::cin >> U[i] >> V[i];\n    }\n\n    for (int i = 1; i <= N - 1; i++) {\n        tree.add_undirected_edge(U[i], V[i]);\n    }\n\n    tree.set_rank(1, 0, -1);\n\n    std::vector<int> nodes;\n    for (int i = 1; i <= N; i++) {\n        nodes.push_back(i);\n    }\n\n    std::sort(nodes.begin(), nodes.end(),\n        [](const int a, const int b) { return tree.node[a].rank > tree.node[b].rank; }\n    );\n\n    for (int n : nodes) {\n        merge(n);\n        //if (n == 4) {\n        //    break;\n        //}\n    }\n\n    int ret = N;\n    for (int i = 0; i <= N; i++) {\n        if (dp_pos[1][i] < MAX_V || dp_neg[1][i] < 0) {\n            ret = std::min(ret, i);\n        }\n    }\n\n    std::cout << ret << std::endl;\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <limits>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <iterator>\n#include <bitset>\n#include <unordered_map>\n#include <unordered_set>\n\nusing namespace std;\n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)c.size())\n#define ten(n) ((int)1e##n)\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing Pll = pair<ll, ll>;\n\ntemplate<typename ...> static inline int getchar_unlocked(void) { return getchar(); }\ntemplate<typename ...> static inline void putchar_unlocked(int c) { putchar(c); }\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nvoid reader(ll& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nint reader(char c[]) { int i, s = 0; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c[s++] = i; for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c[s++] = i; }c[s] = '\\0'; return s; }\nint reader(string& c) { int i; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c.push_back(i); for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c.push_back(i); }; return sz(c); }\ntemplate <class T, class S> void reader(T& x, S& y) { reader(x); reader(y); }\ntemplate <class T, class S, class U> void reader(T& x, S& y, U& z) { reader(x); reader(y); reader(z); }\ntemplate <class T, class S, class U, class V> void reader(T& x, S& y, U& z, V & w) { reader(x); reader(y); reader(z); reader(w); }\nvoid writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(ll x, char c) { int s = 0, m = 0; char f[20]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(const char c[]) { int i; for (i = 0; c[i] != '\\0'; i++)mypc(c[i]); }\nvoid writer(const string& x, char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\nvoid writer(const char x[], char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\ntemplate<class T> void writerLn(T x) { writer(x, '\\n'); }\ntemplate<class T, class S> void writerLn(T x, S y) { writer(x, ' '); writer(y, '\\n'); }\ntemplate<class T, class S, class U> void writerLn(T x, S y, U z) { writer(x, ' '); writer(y, ' '); writer(z, '\\n'); }\ntemplate<class T, class S, class U, class V> void writerLn(T x, S y, U z, V v) { writer(x, ' '); writer(y, ' '); writer(z, ' '); writer(v, '\\n'); }\ntemplate<class T> void writerArr(T x[], int n) { if (!n) { mypc('\\n'); return; }FOR(i, n - 1)writer(x[i], ' '); writer(x[n - 1], '\\n'); }\ntemplate<class T> void writerArr(vector<T>& x) { writerArr(x.data(), (int)x.size()); }\n\ntemplate<class T> void chmin(T& a, const T& b) { if (a > b) a = b; }\ntemplate<class T> void chmax(T& a, const T& b) { if (a < b) a = b; }\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\ntemplate<class T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\nll mod_pow(ll a, ll n, ll mod) {\n\tll ret = 1;\n\tll p = a % mod;\n\twhile (n) {\n\t\tif (n & 1) ret = ret * p % mod;\n\t\tp = p * p % mod;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\ntemplate<class T> T extgcd(T a, T b, T& x, T& y) { for (T u = y = 1, v = x = 0; a;) { T q = b / a; swap(x -= q * u, u); swap(y -= q * v, v); swap(b -= q * a, a); } return b; }\nll mod_inv(ll a, ll m) { ll x, y; extgcd<ll>(a, m, x, y); return (m + x % m) % m; }\n\n#ifdef _DEBUG\ntemplate <typename ... Args>\nvoid debugPrintf(const char *format, Args const & ... args) {\n\tfprintf(stdout, format, args ...);\n\tfflush(stdout);\n}\n#else\n#define debugPrintf(...)\n#endif\n\n\nll a[5000];\nint allPositiveMn[5000];\nvector<ll> memo[5000];\nvector<int> e[5000];\n\nvoid dfs(int v, int par) {\n\tfor (auto to : e[v]) {\n\t\tif (to == par) continue;\n\t\tdfs(to, v);\n\t}\n\n\tstatic vector<ll> cur, nxt;\n\tnxt.clear();\n\tnxt.push_back(a[v]);\n\tauto updateNext = [](int idx, ll val) {\n\t\tif (sz(nxt) <= idx) {\n\t\t\tnxt.resize(idx + 1, (ll)1e17);\n\t\t}\n\t\tchmin(nxt[idx], val);\n\t};\n\n\tfor (auto to : e[v]) {\n\t\tif (to == par) continue;\n\t\tswap(cur, nxt);\n\t\tnxt.clear();\n\t\tauto& c2 = memo[to];\n\t\tint geta = allPositiveMn[to];\n\t\tFOR(i, sz(c2)) if (c2[i] < 0) {\n\t\t\tgeta = min(geta, i);\n\t\t\tbreak;\n\t\t}\n\t\tgeta++;\n\n\t\tFOR(i, sz(c2)) {\n\t\t\tFOR(j, sz(cur)) {\n\t\t\t\tupdateNext(i + j, c2[i] + cur[j]);\n\t\t\t}\n\t\t}\n\t\tFOR(i, sz(cur)) {\n\t\t\tupdateNext(i + geta, cur[i]);\n\t\t}\n\t}\n\tmemo[v].swap(nxt);\n\n\tif (a[v] < 0) {\n\t\tallPositiveMn[v] = ten(5);\n\t} else {\n\t\tfor (auto to : e[v]) {\n\t\t\tif (to == par) continue;\n\t\t\tif (a[to] < 0) {\n\t\t\t\tFOR(i, sz(memo[to])) {\n\t\t\t\t\tif (memo[to][i] < 0) {\n\t\t\t\t\t\tallPositiveMn[v] += i + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tallPositiveMn[v] += allPositiveMn[to];\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tint n; reader(n);\n\tFOR(i, n) reader(a[i]);\n\tFOR(i, n - 1) {\n\t\tint a, b; reader(a, b);\n\t\ta--; b--;\n\t\te[a].push_back(b);\n\t\te[b].push_back(a);\n\t}\n\n\tdfs(0, -1);\n\tint ans = allPositiveMn[0];\n\tFOR(i, sz(memo[0])) if (memo[0][i] < 0) {\n\t\tans = min(ans, i);\n\t\tbreak;\n\t}\n\twriterLn(ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\nconst ll INF=1e17;\nint main(){\n    int n;\n    cin>>n;\n    vector<ll> a(n);\n    for(int i=0;i<n;i++){\n        cin>>a[i];        \n    }\n    vector<vector<int>> g(n);\n    for(int i=0;i<n-1;i++){\n        int u,v;\n        cin>>u>>v;\n        u--,v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    \n    vector<vector<ll>> dp(n);\n    auto cmin=[](ll &lhs,ll rhs){\n        lhs=min(lhs,rhs);\n    };\n    function<int(int,int)> dfs2=[&](int v,int pre){\n        int oki=n;\n        for(int i=0;i<dp[v].size();i++){\n            if(dp[v][i]<0){\n                oki=i;\n                break;\n            }\n        }\n        if(a[v]<0){\n            return 1+oki;\n        }\n        int sum=0;\n        for(auto &to:g[v]){\n            if(to==pre) continue;\n            sum+=dfs2(to,v);\n        }\n        return min(oki+1,sum);\n    };\n    int y=-1;\n    function<void(int,int)> dfs=[&](int v,int pre){\n        int sz=1;\n        int cnt=0;\n        for(auto to:g[v]){\n            if(to==pre) continue;\n            dfs(to,v);\n            sz+=dp[to].size();\n            cnt++;\n        }\n        vector<vector<ll>> dp2(cnt+1);\n        dp2[0].assign(1,a[v]);\n        int idx=0;\n        for(auto to:g[v]){\n            if(to==pre) continue;\n            for(int i=0;i<dp2[idx].size();i++){\n                for(int j=0;j<dp[to].size();j++){\n                    while(dp2[idx+1].size()<=i+j+1){\n                        dp2[idx+1].push_back(INF);\n                    }\n                    cmin(dp2[idx+1][i+j],dp2[idx][i]+dp[to][j]);\n                    if(dp[to][j]<0){\n                        cmin(dp2[idx+1][i+j+1],dp2[idx][i]);\n                    }\n                }\n            }\n            idx++;\n        }\n        dp[v]=dp2[idx];\n        if(a[v]>0 && (pre==-1 || a[pre]<0)){\n            int x=dfs2(v,pre);\n            while(dp[v].size()<=x+1){\n                dp[v].push_back(INF);\n            }\n            if(pre==-1) y=x;\n            cmin(dp[v][x+1],0);\n        }\n        return;\n    };\n    \n    dfs(0,-1);\n    for(int i=0;i<dp[0].size();i++){\n        if(dp[0][i]<0 || y==i){\n            cout<<i<<endl;\n            return 0;\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1e9 + 7;\nconst ll INF = 1LL << 60;\nconst double PI = 3.141592653589793238;\nconst double EPS = 1e-10;\nvector<int> G[5000];\nll A[5000];\nint num[5000];\nll dp[5000][5000][2]; //[頂点][何本の辺をきるか][全て正か]\nll dp2[5000][2];\nvoid dfs(int v, int p) {\n\tnum[v] = 1;\n\tfor (int to : G[v]) {\n\t\tif (to == p) continue;\n\t\tdfs(to, v);\n\t\tnum[v] += num[to];\n\t}\n\tfor (int i = 0; i < num[v]; i++) dp2[i][0] = dp2[i][1] = INF;\n\tdp2[0][0] = A[v];\n\tif (A[v] > 0) dp2[0][1] = A[v];\n\tint sum = 1;\n\tfor (int to : G[v]) {\n\t\tif (to == p) continue;\n\t\tfor (int i = sum - 1; i >= 0; i--) {\n\t\t\tll x = dp2[i][0], y = dp2[i][1];\n\t\t\tdp2[i][0] = dp2[i][1] = INF;\n\t\t\tfor (int j = 0; j < num[to]; j++) {\n\t\t\t\tdp2[i + j][0] = min(dp2[i + j][0], x + dp[to][j][0]);\n\t\t\t\tif (dp[to][j][0] < 0 || dp[to][j][1] < INF) dp2[i + j + 1][0] = min(dp2[i + j + 1][0], x);\n\t\t\t\tif (A[v] > 0) {\n\t\t\t\t\tdp2[i + j][1] = min(dp2[i + j][1], y + dp[to][j][1]);\n\t\t\t\t\tif (dp[to][j][0] < 0 || dp[to][j][1] < INF) dp2[i + j + 1][1] = min(dp2[i + j + 1][1], y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsum += num[to];\n\t}\n\tfor (int i = 0; i < num[v]; i++) {\n\t\tdp[v][i][0] = dp2[i][0];\n\t\tdp[v][i][1] = dp2[i][1];\n\t}\n}\nint main() {\n\tint N;\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) cin >> A[i];\n\tfor (int i = 0; i + 1 < N; i++) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--; v--;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tdfs(0, -1);\n\tfor (int i = 0; i < num[0]; i++) {\n\t\tif (dp[0][i][0] < 0 || dp[0][i][1] < INF) {\n\t\t\tcout << i << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nusing Table = vector< pair<int, int> >;\nconst pair<int, int> INIT(INF, 0);\n\nint A[5010], sz[5010];\nvector<int> G[5010];\n\nvoid dfs(int cur, int par=-1) {\n    sz[cur] = 1;\n    for(int to : G[cur]) {\n        if(to == par) continue;\n        dfs(to, cur);\n        sz[cur] += sz[to];\n    }\n}\n\nTable merge(const Table &A, const Table &B) {\n    int N = A.size(), M = B.size();\n    Table res(N + M, INIT);\n    for(int i=N-1; i>=0; i--) {\n        for(int j=M-1; j>=0; j--) {\n            // 和を考える\n            chmin(res[i+j].first, A[i].first + B[j].first);\n            if(B[j].first < 0 or B[j].second) chmin(res[i+j+1].first, A[i].first);\n\n            // 全て正になるか考える\n            res[i+j].second |= A[i].second & B[j].second;\n            if(B[j].first < 0 or B[j].second) res[i+j+1].second |= A[i].second;\n        }\n    }\n    return res;\n}\n\nTable solve(int cur, int par=-1) {\n    Table res_dp(1);\n    res_dp[0].first = A[cur];\n    res_dp[0].second = (A[cur] > 0);\n    for(auto to : G[cur]) {\n        if(to == par) continue;\n        Table child_dp = solve(to, cur);\n        res_dp = merge(res_dp, child_dp);\n    }\n    return res_dp;\n}\n\nsigned main() {\n    int N; cin >> N;    \n    for(int i=0; i<N; i++) {\n        cin >> A[i];\n    }\n    for(int i=0; i<N-1; i++) {\n        int u, v; cin >> u >> v;\n        u--; v--;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n\n    dfs(0);\n    auto dp = solve(0);\n    int ans = INF;\n    for(int i=0; i<N; i++) {\n        if(dp[i].first < 0) ans = min(ans, i);\n        if(dp[i].second == true) ans = min(ans, i);\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\n#include <unordered_map>\nusing namespace std;\n\n#define REP(i, s) for (int i = 0; i < s; ++i)\n#define ALL(v) (v.begin(), v.end())\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\ntemplate<class T> ostream& operator << (ostream &s, set<T> P)\n{ EACH(it, P) { s << \"<\" << *it << \"> \"; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P)\n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s << endl; }\n\nconst long long INF = 1LL<<60;\nconst int MAX = 5100;\n\nint N;\nvector<long long> A;\nvector<vector<int> > G;\n\nint num[MAX];\nlong long dp[MAX][MAX][2]; // vの部分木、vを含めず何個か、(全部正かどうか)\nlong long sdp[MAX][MAX][2];\n\nvoid rec(int v, int p) {\n    int numc = 0;\n    num[v] = 1;\n    for (auto ch : G[v]) {\n        if (ch == p) continue;\n        rec(ch, v);\n        ++numc;\n        num[v] += num[ch];\n    }\n    \n    for (int i = 0; i < MAX; ++i) for (int j = 0; j < MAX; ++j)\n        sdp[i][j][0] = sdp[i][j][1] = INF;\n    \n    sdp[0][0][0] = A[v];\n    if (A[v] > 0) sdp[0][0][1] = A[v];\n    \n    int i = 0;\n    for (auto ch : G[v]) {\n        if (ch == p) continue;\n        for (int j = 0; j <= num[v]; ++j) {\n            for (int k = 0; k <= num[ch]; ++k) {\n                chmin(sdp[i+1][j+k][0], sdp[i][j][0] + dp[ch][k][0]);\n                chmin(sdp[i+1][j+k][0], sdp[i][j][0] + dp[ch][k][1]);\n                if (dp[ch][k][0] < 0) chmin(sdp[i+1][j+k+1][0], sdp[i][j][0]);\n                if (dp[ch][k][1] < INF/2) chmin(sdp[i+1][j+k+1][0], sdp[i][j][0]);\n                if (A[v] > 0) {\n                    chmin(sdp[i+1][j+k][1], sdp[i][j][1] + dp[ch][k][1]);\n                    if (dp[ch][k][0] < 0) chmin(sdp[i+1][j+k+1][1], sdp[i][j][1]);\n                    if (dp[ch][k][1] < INF/2) chmin(sdp[i+1][j+k+1][1], sdp[i][j][1]);\n                }\n            }\n        }\n        ++i;\n    }\n    for (int j = 0; j <= num[v]; ++j) {\n        dp[v][j][0] = sdp[numc][j][0];\n        dp[v][j][1] = sdp[numc][j][1];\n        \n        //cout << v << \", \" << j << \": \" << make_pair(dp[v][j][0], dp[v][j][1]) << endl;\n    }\n}\n\nint main() {\n    while (cin >> N) {\n        A.resize(N);\n        for (int i = 0; i < N; ++i) cin >> A[i];\n        G.assign(N, vector<int>());\n        for (int i = 0; i < N-1; ++i) {\n            int u, v; cin >> u >> v; --u, --v;\n            G[u].push_back(v);\n            G[v].push_back(u);\n        }\n        for (int i = 0; i < MAX; ++i) for (int j = 0; j < MAX; ++j)\n            dp[i][j][0] = dp[i][j][1] = INF;\n        rec(0, -1);\n        int res = N;\n        for (int i = 0; i <= N; ++i) {\n            if (dp[0][i][0] < 0) chmin(res, i);\n            if (dp[0][i][1] < INF/2) chmin(res, i);\n        }\n        cout << res << endl;\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n)  for(long long i=0;i<(long long)(n);i++)\n#define REP(i,k,n) for(long long i=k;i<(long long)(n);i++)\n#define all(a) a.begin(),a.end()\n#define pb push_back\n#define eb emplace_back\n#define lb(v,k) (lower_bound(all(v),k)-v.begin())\n#define ub(v,k) (upper_bound(all(v),k)-v.begin())\n#define fi first\n#define se second\n#define pi M_PI\n#define PQ(T) priority_queue<T>\n#define SPQ(T) priority_queue<T,vector<T>,greater<T>>\n#define dame(a) {out(a);return 0;}\n#define decimal cout<<fixed<<setprecision(15);\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef tuple<ll,ll,ll> PP;\ntypedef tuple<ll,ll,ll,ll> PPP;\ntypedef multiset<ll> S;\nusing vi=vector<ll>;\nusing vvi=vector<vi>;\nusing vvvi=vector<vvi>;\nusing vp=vector<P>;\nusing vvp=vector<vp>;\nusing vb=vector<bool>;\nusing vvb=vector<vb>;\nconst ll inf=1001001001001001001;\nconst int INF=1001001001;\nconst int mod=998244353;\nconst double eps=1e-10;\ntemplate<class T> bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<class T> bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<class T> void out(T a){cout<<a<<'\\n';}\ntemplate<class T> void outp(T a){cout<<'('<<a.fi<<','<<a.se<<')'<<'\\n';}\ntemplate<class T> void outvp(T v){rep(i,v.size())cout<<'('<<v[i].fi<<','<<v[i].se<<')';cout<<'\\n';}\ntemplate<class T> void outvvp(T v){rep(i,v.size())outvp(v[i]);}\ntemplate<class T> void outv(T v){rep(i,v.size()){if(i)cout<<' ';cout<<v[i];}cout<<'\\n';}\ntemplate<class T> void outvv(T v){rep(i,v.size())outv(v[i]);}\ntemplate<class T> bool isin(T x,T l,T r){return (l)<=(x)&&(x)<=(r);}\ntemplate<class T> void yesno(T b){if(b)out(\"yes\");else out(\"no\");}\ntemplate<class T> void YesNo(T b){if(b)out(\"Yes\");else out(\"No\");}\ntemplate<class T> void YESNO(T b){if(b)out(\"YES\");else out(\"NO\");}\ntemplate<class T> void noyes(T b){if(b)out(\"no\");else out(\"yes\");}\ntemplate<class T> void NoYes(T b){if(b)out(\"No\");else out(\"Yes\");}\ntemplate<class T> void NOYES(T b){if(b)out(\"NO\");else out(\"YES\");}\nvoid outs(ll a,ll b){if(a>=inf-100)out(b);else out(a);}\nll gcd(ll a,ll b){if(b==0)return a;return gcd(b,a%b);}\nll modpow(ll a,ll b){a%=mod;if(b==0)return 1;if(b&1)return a*modpow(a,b-1)%mod;ll k=modpow(a,b/2);return k*k%mod;}\nvi val,sz,dp1;\nvvi g,dp;\nvoid dfs(int v,int p){\n    sz[v]=1;\n    for(ll x:g[v])if(x!=p){\n        dfs(x,v);\n        sz[v]+=sz[x];\n    }\n    vi sdp(1);\n    sdp[0]=val[v];\n    if(val[v]>0)dp1[v]=0;\n    for(ll x:g[v])if(x!=p){\n        ll mi=inf;\n        chmin(mi,dp1[x]);\n        vi ndp(sdp.size()+sz[x],inf);\n        rep(i,sdp.size())rep(j,sz[x]){\n            chmin(ndp[i+j],sdp[i]+dp[x][j]);\n            if(dp1[x]<=j||dp[x][j]<0)chmin(ndp[i+j+1],sdp[i]);\n            if(dp[x][j]<0)chmin(mi,j+1);\n        }\n        if(dp1[v]<inf)dp1[v]+=mi;\n        sdp=ndp;\n    }\n    dp[v]=sdp;\n}\nint main(){\n    ll n;cin>>n;\n    val=vi(n);\n    sz=vi(n);\n    dp1=vi(n,inf);\n    dp=vvi(n);\n    rep(i,n)cin>>val[i];\n    g=vvi(n);\n    rep(i,n-1){\n        ll a,b;cin>>a>>b;a--;b--;\n        g[a].pb(b);\n        g[b].pb(a);\n    }\n    dfs(0,-1);\n    ll ans=0;\n    while(dp[0][ans]>0)ans++;\n    out(min(ans,dp1[0]));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll MOD = 1e9+7;\nconst ll INF = 1e18;\n\nsigned main()\n{\n    ll n;\n    cin >> n;\n    vector<ll> a(n);\n    for(auto& y : a)\n        cin >> y;\n    vector<ll> u(n - 1);\n    vector<ll> v(n - 1);\n    for(ll i = 0; i < n - 1; ++i){\n        cin >> u[i] >> v[i];\n        --u[i];\n        --v[i];\n    }\n    vector<vector<ll>> edges(n);\n    for(ll i = 0; i < n - 1; ++i){\n        edges[u[i]].push_back(v[i]);\n        edges[v[i]].push_back(u[i]);\n    }\n    vector<vector<vector<ll>>> dp(n, vector<vector<ll>>(n + 1, vector<ll>(2, INF)));\n    vector<ll> size(n, 1);\n\n    vector<ll> flag(n, 0);\n    function<void(ll)> siz = [&](ll x){\n        for(auto& y : edges[x])\n            if(!flag[y]){\n                flag[y] = 1;\n                siz(y);\n                size[x] += size[y];\n            }\n    };\n    flag[0] = 1;\n    siz(0);\n    flag = vector<ll>(n, 0);\n\n    function<void(ll)> f = [&](ll x){\n        dp[x][0][0] = a[x];\n        if(a[x] > 0)\n            dp[x][0][1] = a[x];\n\n        ll sizesum = 0;\n        for(auto& y : edges[x]){\n            if(flag[y])\n                continue;\n            flag[y] = 1;\n            f(y);\n\n            vector<vector<ll>> next(n + 1, vector<ll>(2, INF));\n\n            for(ll i = 0; i <= sizesum; ++i){\n                for(ll j = 0; j <= size[y]; ++j){\n                    next[i + j][0] = min(next[i + j][0], dp[x][i][0] + dp[y][j][0]);\n                    next[i + j][0] = min(next[i + j][0], dp[x][i][0] + dp[y][j][1]);\n                    next[i + j][0] = min(next[i + j][0], dp[x][i][1] + dp[y][j][0]);\n                    next[i + j][0] = min(next[i + j][0], dp[x][i][1] + dp[y][j][1]);\n                    if(a[x] > 0 && dp[y][j][1] != INF)\n                        next[i + j][1] = min(next[i + j][1], dp[x][i][1] + dp[y][j][1]);\n                    // 分断が可能なら\n                    if(dp[y][j][0] < 0 || dp[y][j][1] != INF){\n                        next[i + j + 1][0] = min(next[i + j + 1][0], dp[x][i][0]);\n                        if(a[x] > 0){\n                            next[i + j + 1][1] = min(next[i + j + 1][1], dp[x][i][1]);\n                        }\n                    }\n                }\n            }\n            dp[x] = move(next);\n            sizesum += size[y];\n        }\n    };\n    flag[0] = 1;\n    f(0);\n    ll ans = 1e9;\n    for(ll j = 0; j <= n; ++j){\n        if(dp[0][j][0] < 0)\n            ans = min(ans, j);\n        if(dp[0][j][1] != INF)\n            ans = min(ans, j);\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FAST ios_base::sync_with_stdio(false); cin.tie(0);\n#define pb push_back\n#define eb emplace_back\n#define ins insert\n#define f first\n#define s second\n#define cbr cerr << \"hi\\n\"\n#define mmst(x, v) memset((x), v, sizeof ((x)))\n#define siz(x) ll(x.size())\n#define all(x) (x).begin(), (x).end()\n#define lbd(x,y) (lower_bound(all(x),y)-x.begin())\n#define ubd(x,y) (upper_bound(all(x),y)-x.begin())\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());    //can be used by calling rng() or shuffle(A, A+n, rng)\ninline long long rand(long long x, long long y) { return (rng() % (y+1-x)) + x; } //inclusivesss\nstring inline to_string(char c) {string s(1,c);return s;} template<typename T> inline T gcd(T a,T b){ return a==0?llabs(b):gcd(b%a,a); }\n\ntypedef long long ll; \ntypedef long double ld;\n#define FOR(i,s,e) for(ll i=s;i<=ll(e);++i)\n#define DEC(i,s,e) for(ll i=s;i>=ll(e);--i)\ntypedef pair<ll,ll>pi; typedef pair<ll,pi>spi; typedef pair<pi,pi>dpi;\n\n#define LLINF ((long long)1e18)\n#define INF int(1e9+1e6)\n#define MAXN (5006)\nll n,A[MAXN],dp[MAXN][MAXN],sz[MAXN];// if 0 then max, 1 then min\nbitset<MAXN> dp2[MAXN];\nvector<int>v[MAXN];\nvoid dfs(ll x,ll p){\n\tsz[x]=1;\n\tdp[x][0]=A[x];\n\tfor(auto i:v[x]) if(i^p) dfs(i,x), sz[x]+=sz[i];\n\tFOR(k,1,sz[x]) dp[x][k]=LLINF;\n\tll cur = 1;\n\tif(A[x]>0)dp2[x][0]=1;\n\tfor(auto i:v[x]) if(i^p) {\n\t\tcur += sz[i];\n\t\tDEC(j,cur,0){\n\t\t\tif(dp[x][j]<LLINF) dp[x][j] += dp[i][0];\n\t\t\tdp2[x][j] = dp2[x][j] & dp2[i][0];\n\t\t\tFOR(k,1,min(j,sz[i])){\n\t\t\t\tdp[x][j]=min(dp[x][j],dp[x][j-k]+dp[i][k]);\n\t\t\t\tif(dp2[i][k-1]) dp[x][j]=min(dp[x][j],dp[x][j-k]);\n\t\t\t\tdp2[x][j]=dp2[x][j]|(dp2[x][j-k]&dp2[i][k]);\n\t\t\t\tif(dp[i][k-1] < 0) dp2[x][j]=dp2[x][j]|dp2[x][j-k];\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tFAST\n\tcin>>n;\n\tFOR(i,1,n)cin>>A[i];\n\tFOR(i,2,n){\n\t\tll a,b;cin>>a>>b;\n\t\tv[a].eb(b),v[b].eb(a);\n\t}\n\tdfs(1,1);\n\tll ans = n-1;\n\tFOR(k,0,n-1) if(dp[1][k] < 0) ans = min(ans, k);\n\tFOR(k,0,n-1) if(dp2[1][k]) ans = min(ans, k);\n\tcout<<ans<<'\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <array>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <iterator>\n#include <memory>\n#include <regex>\nusing namespace std;\n\nconst long long INF = LLONG_MAX / 2;\n\nvector<int> a;\nvector<vector<int> > edges;\n\nvoid solve(int curr, int prev, vector<vector<long long> >& ans)\n{\n    // ans[0] : コンピュータが存在しない\n    // ans[1] : 電力供給が不足\n    ans.assign(2, vector<long long>(1, a[curr]));\n    if(a[curr] < 0)\n        ans[0][0] = INF;\n    else\n        ans[1][0] = INF;\n\n    for(int next : edges[curr]){\n        if(prev == next)\n            continue;\n\n        vector<vector<long long> > v;\n        solve(next, curr, v);\n\n        int n = ans[0].size();\n        int m = v[0].size();\n        vector<vector<long long> > ans2(2, vector<long long>(n+m, INF));\n        for(int i=0; i<n; ++i){\n            for(int j=0; j<m; ++j){\n                ans2[0][i+j] = min(ans2[0][i+j], ans[0][i] + v[0][j]);\n                ans2[1][i+j] = min(ans2[1][i+j], ans[1][i] + v[0][j]);\n                ans2[1][i+j] = min(ans2[1][i+j], ans[0][i] + v[1][j]);\n                ans2[1][i+j] = min(ans2[1][i+j], ans[1][i] + v[1][j]);\n                if(v[0][j] < INF/2 || v[1][j] < 0){\n                    ans2[0][i+j+1] = min(ans2[0][i+j+1], ans[0][i]);\n                    ans2[1][i+j+1] = min(ans2[1][i+j+1], ans[1][i]);\n                }\n            }\n        }\n        ans = move(ans2);\n    }\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n    a.resize(n);\n    for(int i=0; i<n; ++i)\n        cin >> a[i];\n\n    edges.assign(n, vector<int>());\n    for(int i=0; i<n-1; ++i){\n        int u, v;\n        cin >> u >> v;\n        -- u;\n        -- v;\n        edges[u].push_back(v);\n        edges[v].push_back(u);\n    }\n\n    vector<vector<long long> > ans;\n    solve(0, -1, ans);\n    for(int i=0; ; ++i){\n        if(ans[0][i] < INF/2 || ans[1][i] < 0){\n            cout << i << endl;\n            return 0;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <stack>\n#include <queue>\n#include <list>\n#include <bitset>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n#include <numeric>\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <chrono>\n#include <random>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <functional>\n#include <sstream>\n\nusing namespace std;\n\n\nclass DisjointSet {\n    public:\n        DisjointSet(int n) : N(n), sz(n), pars(n, -1) {\n\n        }\n\n        int find(int x) {\n            return pars[x] < 0 ? x  : (pars[x] = find(pars[x]));\n        }\n\n        bool merge(int x, int y) {\n            x = find(x), y = find(y);\n            if (x == y) {\n                return false;\n            }\n            if (pars[x] < pars[y]) {\n                swap(x, y);\n            }\n            pars[y] += pars[x];\n            pars[x] = y;\n            --sz;\n            return true; \n        }\n        int size() {\n             return sz;\n        }\n\n        int count(int x) {\n            return - pars[find(x)];\n        }\n\n    private:\n        int N;\n        int sz;\n        vector<int> pars;\n};\n\n\nint main(int argc, char** argv) {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n\n    int n;\n    cin >> n;\n    vector<int> A(n, 0);\n    for (int i = 0; i < n; ++i) {\n        cin >> A[i];\n    }\n    vector<vector<int>> graph(n);\n    for (int i = 0; i + 1 < n; ++i) {\n        int u, v;\n        cin >> u >> v;\n        --u, --v;\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n\n    DisjointSet ds(n);\n    for (int i = 0; i < n; ++i) {\n        int u = i;\n        for (auto v : graph[u]) {\n            if (A[v] * 1LL * A[u] > 0) {\n                ds.merge(u, v);\n                // cout << u + 1 << \" :: \" << v + 1 << endl;\n            }\n        }\n    }\n\n    int N = ds.size();\n    vector<vector<int>> SG(N);\n    vector<long long> W(n, 0);\n    vector<int> indices(n, -1);\n    for (int i = 0, j = 0; i < n; ++i) {\n        if (ds.find(i) == i) {\n            indices[i] = j++;\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        int u = i;\n        int uu = indices[ds.find(u)];\n        W[uu] += A[u];\n        for (auto v : graph[u]) {\n            int vv = indices[ds.find(v)];\n            if (uu != vv) {\n                SG[uu].push_back(vv);\n                SG[vv].push_back(uu);\n            }\n        }\n    }\n\n    for (auto& V : SG) {\n        sort(V.begin(), V.end());\n        V.erase(unique(V.begin(), V.end()), V.end());\n    }\n\n\n    DisjointSet ds2(N);\n    // cout << N << endl;\n    while (true) {\n        int s = -1;\n        pair<int, long long> best{0, 0};\n        for (int i = 0; i < N; ++i) {\n            if (W[ds2.find(i)] > 0) {\n                int u = i;\n                long long sum = W[ds2.find(u)];\n                for (auto v : SG[u]) {\n                    v = ds2.find(v);\n                    sum += W[v];\n                }\n                if (sum >= 0) {\n                    continue;\n                }\n                if (SG[u].size() > best.first || (SG[u].size() == best.first && sum < best.second)) {\n                    s = u;\n                    best = make_pair(SG[u].size(), sum);\n                } \n            }\n        }\n        // cout << \"d \" << s << \" \" << W[ds2.find(s)] << \" \" << best.second <<  endl;\n        if (s < 0) {\n            break;\n        }\n        for (auto v : SG[s]) {\n            v = ds2.find(v);\n            int u = ds2.find(s);\n            ds2.merge(u, v);\n            int p = ds2.find(s);\n            W[p] = W[u] + W[v];\n        }\n    }\n    cout << ds2.size() - 1 << '\\n';\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Link : https://codeforces.com/contest/1194/problem/B\n\n#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define inf ((ll)1e18)\n#define N 5005\n\nvector<int> tdj[N],adj[N];\nint A[N],dsu[N];\n\nint f(int x) {\n    if(dsu[x]==x) {\n        return x;\n    }\n    return dsu[x] = f(dsu[x]);\n}\nvoid merge(int x,int y) {\n    x = f(x),y = f(y);\n    if(x!=y) {\n        dsu[x] = y;\n    }\n}\nll v[N];\nll dp[N][2][N];\nint subTreeSize[N];\n\nbool isSame(int x,int y) {\n    if((v[x]>0 && v[y]>0) || (v[x]<0 && v[y]<0)) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\nll tmp[2][N];\n\nvoid dfs(int node,int p) {\n    subTreeSize[node] = 1;\n    dp[node][0][0] = v[node];\n    dp[node][1][0] = inf;\n    for(int ch : adj[node]) {\n        if(ch!=p) {\n            dfs(ch,node);\n            for(int i=0;i<subTreeSize[node]+subTreeSize[ch];++i) {\n                tmp[0][i] = inf;\n                tmp[1][i] = inf;\n            }\n            bool isEqual = isSame(node,ch);\n            for(int i=0;i<subTreeSize[node];++i) {\n                for(int j = 0;j<subTreeSize[ch];++j) {\n                    if(isEqual) {\n                        if(dp[node][0][i]!=inf && dp[ch][0][j]!=inf)\n                            tmp[0][i+j] = min(tmp[0][i+j],dp[node][0][i] + dp[ch][0][j]);\n                    } else {\n                        if(dp[node][0][i]!=inf && dp[ch][0][j]!=inf)\n                            tmp[1][i+j] = min(tmp[1][i+j],dp[node][0][i] + dp[ch][0][j]);\n                    }\n                    if(dp[node][0][i]!=inf && dp[ch][1][j]<0)\n                        tmp[0][i+j+1] = min(tmp[0][i+j+1],dp[node][0][i]);\n                    if(dp[node][0][i]!=inf && dp[ch][0][j]!=inf) {\n                        tmp[0][i+j+1] = min(tmp[0][i+j+1],dp[node][0][i]);\n                    }\n                    if(dp[node][1][i]!=inf && dp[ch][1][j]<0)\n                        tmp[1][i+j+1] = min(tmp[1][i+j+1],dp[node][1][i]);\n                    if(dp[node][1][i]!=inf && dp[ch][0][j]!=inf) {\n                        tmp[1][i+j+1] = min(tmp[1][i+j+1],dp[node][1][i]);\n                    }\n\n                    if(dp[node][0][i]!=inf && dp[ch][1][j]!=inf)\n                        tmp[1][i+j] = min(tmp[1][i+j], dp[node][0][i] + dp[ch][1][j]);\n                    if(dp[node][1][i]!=inf && dp[ch][1][j]!=inf)\n                        tmp[1][i+j] = min(tmp[1][i+j], dp[node][1][i] + dp[ch][1][j]);\n                    if(dp[node][1][i]!=inf && dp[ch][0][j]!=inf)\n                        tmp[1][i+j] = min(tmp[1][i+j], dp[node][1][i] + dp[ch][0][j]);\n                }\n            }\n            subTreeSize[node] += subTreeSize[ch];\n            for(int j = 0;j<subTreeSize[node];++j) {\n                dp[node][0][j] = tmp[0][j];\n                dp[node][1][j] = tmp[1][j];\n            }\n        }\n    }\n}\n\nvoid solve() {\n  int n;scanf(\"%d\",&n);\n  for(int i=1;i<=n;++i) {\n      scanf(\"%d\",&A[i]);\n      dsu[i] = i;\n  }\n  for(int i=0;i<n-1;++i) {\n      int a,b;scanf(\"%d %d\",&a,&b);\n      tdj[a].push_back(b);\n  }\n  for(int i=1;i<=n;++i) {\n      if(A[i]>0) {\n          continue;\n      }\n      for(int ch : tdj[i]) {\n          if(A[ch]<0) {\n              merge(ch,i);\n          }\n      }\n  }\n  for(int i=1;i<=n;++i) {\n      v[f(i)] += A[i];\n  }\n  for(int i=1;i<=n;++i) {\n      int node = f(i);\n      for(int ch : tdj[i]) {\n          int ccx = f(ch);\n          if(node!=ccx) {\n              adj[node].push_back(ccx);\n              adj[ccx].push_back(node);\n          }\n      }\n  }\n  int root = -1;\n  for(int i=1;i<=n;++i) {\n      if(f(i)==i) {\n          root = i;\n      }\n  }\n  dfs(root,0);\n  int ret = n;\n  for(int i=0;i<n;++i) {\n      if(dp[root][0][i] !=inf) {\n          ret = min(ret,i);\n      }\n      if(dp[root][1][i]<0) {\n          ret = min(ret,i);\n      }\n  }\n  printf(\"%d\\n\",ret);\n}\n\nint main() {\n    ///freopen(\"input.txt\",\"r\",stdin);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cctype>\n#include <cstring>\n#include <ctime>\n#include <iterator>\n#include <bitset>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <cassert>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#define ALL(v) begin(v),end(v)\n#else\n#define ALL(v) (v).begin(),(v).end()\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long LL;\ntypedef pair<int,int> pii;\ntypedef pair<LL,LL> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n\tv.assign(a, vector<T>(b, t));\n}\ntemplate <class T> inline T &chmin(T &x, const T &y){ return x = min(x, y); }\ntemplate <class T> inline T &chmax(T &x, const T &y){ return x = max(x, y); }\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n\tstringstream ss;\n\tss << f;\n\tss >> t;\n}\n\n\n#define REP(i,n) for(int i=0;i<int(n);++i)\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n\nconst LL INF = 1LL << 58;\n\nint n;\nvector<LL> as;\nVV(int) G;\nvector<int> sz;\n\nint dfs1(int u, int par){\n\tG[u].erase(remove(ALL(G[u]), par), G[u].end());\n\tsz[u] = 1;\n\tfor(int v : G[u]){\n\t\tsz[u] += dfs1(v, u);\n\t}\n\tsort(ALL(G[u]), [](int x, int y){ return sz[x] < sz[y]; });\n\treturn sz[u];\n}\n\npair<vll,LL> dfs2(int u){\n\tvll dp(1, as[u]);\n\tvll dp2;\n\tint sumsz = 1;\n\tLL cnt = 0;\n\tfor(int v : G[u]){\n\t\tauto p = dfs2(v);\n\t\tint szv = sz[v];\n\t\tdp2.assign(sumsz + szv, INF);\n\t\tfor(int j = 0; j < szv; ++j){\n\t\t\tfor(int i = 0; i < sumsz; ++i){\n\t\t\t\tchmin(dp2[i + j], dp[i] + p.first[j]);\n\t\t\t\tif(p.first[j] < 0){\n\t\t\t\t\tchmin(dp2[i + j], dp[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(as[v] > 0){\n\t\t\tif(p.second != INF){\n\t\t\t\tfor(int i = 0; i < sumsz; ++i){\n\t\t\t\t\tchmin(dp2[i + p.second + 1], dp[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcnt = min(cnt + p.second, INF);\n\t\t}\n\t\telse{\n\t\t\tLL dcnt = INF;\n\t\t\tfor(int j = 0; j < szv; ++j){\n\t\t\t\tif(p.first[j] < 0){\n\t\t\t\t\tdcnt = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcnt = min(cnt + dcnt + 1, INF);\n\t\t}\n\n\t\tsumsz += szv;\n\t\tdp.swap(dp2);\n\t}\n\t\n\tif(as[u] < 0){\n\t\tcnt = INF;\n\t}\n\n\treturn make_pair(dp, cnt);\n}\n\nvoid mainmain(){\n\tcin >> n;\n\tas.resize(n);\n\tfor(int i = 0; i < n; ++i){\n\t\tcin >> as[i];\n\t}\n\n\tG.resize(n);\n\tfor(int i = 0; i < n - 1; ++i){\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\t--u;\n\t\t--v;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\n\tsz.resize(n);\n\tdfs1(0, -1);\n\n\tauto p = dfs2(0);\n\tLL ans = p.second;\n\tfor(int i = 0; i < n; ++i){\n\t\tif(p.first[i] < 0){\n\t\t\tchmin(ans, (LL)i);\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n}\n\n\n\n}\nint main() try{\n//\tios::sync_with_stdio(false); cin.tie(0);\n\tcout << fixed << setprecision(10);\n\tcerr << fixed << setprecision(4);\n\tmainmain();\n}\ncatch(...){}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int SZ = 5005;\ntypedef long long ll;\nvector<int> graph[5005];\nll wei[SZ];\nint visit[SZ];\nint n;\nint aa = 0;\nll post_order(int a){\n\tvisit[a]=1;\n\tll sm = wei[a];\n\tfor(auto x : graph[a]){\n\t\tif(visit[x]==1) continue;\n\t\tll chk = post_order(x);\n\t\tsm += chk;\n\t\tif(sm+chk>0 && sm<0 || chk<0 ) aa++;\n\t\telse if(wei[x]<0 && sm+wei[x]>0) aa++;\n\t}\n\treturn sm;\n}\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%lld\",&wei[i]);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y; scanf(\"%d %d\",&x,&y);\n\t\tgraph[x].push_back(y);\n\t\tgraph[y].push_back(x);\n\t}\n\tpost_order(1);\n\tprintf(\"%lld\",aa);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define ll long long\n#define N 5010\nint read()\n{\n    int x=0,f=1;char c=getchar();\n    while (c<'0'||c>'9') {if (c=='-') f=-1;c=getchar();}\n    while (c>='0'&&c<='9') x=(x<<1)+(x<<3)+(c^48),c=getchar();\n    return x*f;\n}\nint n,a[N],p[N],g[N],size[N],t;\nll sum[N],f[N][N];\nstruct data{int to,nxt;\n}edge[N<<1];\nvoid addedge(int x,int y){t++;edge[t].to=y,edge[t].nxt=p[x],p[x]=t;}\nvoid dfs(int k,int from)\n{\n\tsum[k]=a[k];\n    for (int i=p[k];i;i=edge[i].nxt)\n    if (edge[i].to!=from)\n\t{\n\t\tdfs(edge[i].to,k);\n\t\tsum[k]+=sum[edge[i].to];\n\t}\n    if (a[k]>0)\n    {\n        g[k]=0;\n        for (int i=p[k];i;i=edge[i].nxt)\n        if (edge[i].to!=from)\n        {\n            int x=g[edge[i].to];\n            for (int j=0;j<=n;j++)\n            if (f[edge[i].to][j]<0) {x=min(x,j+1);break;}\n            g[k]+=x;\n        }\n    }\n    f[k][0]=a[k];\n    size[k]=1;\n    for (int i=p[k];i;i=edge[i].nxt)\n    if (edge[i].to!=from)\n    {\n        for (int j=size[k]+size[edge[i].to];j>=0;j--)\n        {\n        \tf[k][j]+=sum[edge[i].to];if (j-g[edge[i].to]-1>=0) f[k][j]=min(f[k][j],f[k][j-g[edge[i].to]-1]);\n        \tfor (int x=max(0,j-size[edge[i].to]);x<=min(j,size[k]);x++)\n        \t{\n        \t\tf[k][j]=min(f[k][j],f[k][j-x]+f[edge[i].to][x]);\n        \t\tif (x<j&&f[edge[i].to][x]<0) f[k][j]=min(f[k][j],f[k][j-x-1]);\n        \t}\n        }\n        size[k]+=size[edge[i].to];\n    }\n}\nint main()\n{\n\t/*freopen(\"e.in\",\"r\",stdin);\n\tfreopen(\"e.out\",\"w\",stdout);*/\n    n=read();\n    for (int i=1;i<=n;i++) a[i]=read();\n    for (int i=1;i<n;i++)\n    {\n        int x=read(),y=read();\n        addedge(x,y),addedge(y,x);\n    }\n    memset(g,42,sizeof(g));\n    memset(f,42,sizeof(f));\n    dfs(1,1);\n    /*for (int i=1;i<=n;i++) cout<<a[i]<<' ';cout<<endl;\n    for (int i=1;i<=n;i++) cout<<g[i]<<' ';cout<<endl;\n    cout<<endl;\n    for (int i=1;i<=n;i++)\n    {\n    \tfor (int j=0;j<n;j++)\n    \tcout<<f[i][j]<<' ';\n    \tcout<<endl;;\n    }*/\n    int ans=g[1];\n    for (int i=0;i<=n;i++) \n    if (f[1][i]<0) {ans=min(ans,i);break;}\n    cout<<ans;\n    return 0;\n}\n "
  },
  {
    "language": "C++",
    "code": "// aising 2019 E Attack to a Tree\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n\n#define pb push_back\n\ntypedef long long LL;\n\nconst int MAXN = 5010;\n\nint N, A[MAXN], sz[MAXN];\nLL DP[MAXN][MAXN][2], INVALID;\nstd::vector<int> G[MAXN];\n\ninline void upd_min(LL & x, LL y) { y < x ? x = y : 0; }\nvoid dfs(int, int);\n\nint main() {\n\tscanf(\"%d\", &N);\n\tfor (int i = 0; i < N; i++) scanf(\"%d\", A + i);\n\tfor (int i = 1, ui, vi; i < N; i++) {\n\t\tscanf(\"%d%d\", &ui, &vi);\n\t\t--ui, --vi;\n\t\tG[ui].pb(vi), G[vi].pb(ui);\n\t}\n\n\tmemset(DP, 0x3f, sizeof DP);\n\tINVALID = DP[0][0][0];\n\tdfs(0, -1);\n\tfor (int i = 0; i < N; i++)\n\t\tif (DP[0][i][0] != INVALID || DP[0][i][1] < 0) {\n\t\t\tprintf(\"%d\\n\", i);\n\t\t\treturn 0;\n\t\t}\n\n\treturn 0;\n}\n\nvoid dfs(int u, int fa) {\n\tsz[u] = 1;\n\tDP[u][0][A[u] > 0 ? 0 : 1] = A[u];\n\t/* DP[u][j][0 / 1] - u is root, disconnect j cable(s), \n\t * whether there's a computer in the connected component\n\t * 0 - no, 1 - yes\n\t */\n\tLL (*nxt)[2] = DP[5005];\n\tfor (auto v : G[u]) {\n\t\tif (v == fa) continue;\n\t\tdfs(v, u);\n\n\t\tfor (int i = 0; i < MAXN; i++) nxt[i][0] = nxt[i][1] = INVALID;\n\t\tfor (int i = 0; i < sz[u]; i++)\n\t\t\tfor (int j = 0; j < sz[v]; j++) {\n\t\t\t\t// let v be alone\n\t\t\t\tif (DP[v][j][0] != INVALID || DP[v][j][1] < 0) {\n\t\t\t\t\tupd_min(nxt[i + j + 1][0], DP[u][i][0]);\n\t\t\t\t\tupd_min(nxt[i + j + 1][1], DP[u][i][1]);\n\t\t\t\t}\n\t\t\t\tfor (int su = 0; su <= 1; su++)\n\t\t\t\t\tfor (int sv = 0; sv <= 1; sv++)\n\t\t\t\t\t\tif (DP[u][i][su] != INVALID && DP[v][j][sv] != INVALID)\n\t\t\t\t\t\t\tupd_min(nxt[i + j][su | sv], DP[u][i][su] + DP[v][j][sv]);\n\t\t\t}\n\t\tfor (int i = 0; i < MAXN; i++) {\n\t\t\tDP[u][i][0] = nxt[i][0];\n\t\t\tDP[u][i][1] = nxt[i][1];\n\t\t}\n\t\tsz[u] += sz[v];\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n#define REP(i, a, n) for(LL i = (a), i##_max = (n); i < i##_max; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##min = (a); i >= i##min; --i)\n#define ALL(arr) (arr).begin(), (arr).end()\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP {cin.tie(NULL); ios::sync_with_stdio(false);}\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst string INFSTR = \"\\x7f\";\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate<class T>\nT Compare(T left, T right) { return left > right ? 1 : (left < right ? -1 : 0); }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\ntemplate <class T>\nT Next() { T buf; cin >> buf; return buf; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"UnionFind.h\"\n#include \"Graph.h\"\n#include \"Range.h\"\n#include \"Global.h\"\n#include \"FlowSolver.h\"\n#include \"Tree.h\"\n#include \"SuffixArray.h\"\n#include \"Geometry.h\"\n#include \"Matrix.h\"\n#include \"SegmentTree.h\"\n#include \"SegmentTree2D.h\"\n#include \"BIT.h\"\n#include \"Rational.h\"\n#include \"Position.h\"\n#include \"Factorization.h\"\n#include \"Math.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>> (istream& ist, __int128& val) { LL tmp;  ist >> tmp; val = tmp; return ist; }\nostream& operator<< (ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#if 1234567891\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\n// template <class T>\n// auto Is(const T& value) { return [value](const auto& comparand) -> bool { return comparand == value; }; }\n#endif\n\n\n\nint N;\nint A[5000];\nvector<int> G[5000];\n\npair<vector<bool>, vector<LL>> DFS(int from, int prev) {\n\tvector<bool> ok;\n\tvector<LL> al;\n\n\tok.push_back(A[from] > 0);\n\tal.push_back(A[from]);\n\n\tfor (int to : G[from]) {\n\t\tif (to == prev) continue;\n\n\t\tauto p = DFS(to, from);\n\t\tauto rok = p.first;\n\t\tauto ral = p.second;\n\n\t\tvector<bool> nok(ok.size() + rok.size(), false);\n\t\tvector<LL> nal(al.size() + ral.size(), INFLL);\n\n\t\tREP(i, 0, ok.size()) {\n\t\t\tREP(j, 0, rok.size()) {\n\t\t\t\tif (ok[i] && rok[j]) nok[i + j] = true;\n\t\t\t\tnal[i + j] = min(nal[i + j], al[i] + ral[j]);\n\n\t\t\t\tif (rok[j] || ral[j] < 0) {\n\t\t\t\t\tnok[i + j + 1] = ok[i];\n\t\t\t\t\tnal[i + j + 1] = min(nal[i + j + 1], al[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tok = move(nok);\n\t\tal = move(nal);\n\t}\n\n\treturn make_pair(ok, al);\n}\n\nint main() {\n\tcin >> N;\n\tREP(i, 0, N) {\n\t\tcin >> A[i];\n\t}\n\n\tREP(i, 1, N) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\t--a; --b;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\n\tauto p = DFS(0, -1);\n\tauto ok = p.first;\n\tauto al = p.second;\n\n\tint ans = INF;\n\tREM(i, 0, N) {\n\t\tif (ok[i] || al[i] < 0) ans = i;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\nll n;\nvector<ll> a;\nvector<vector<ll>> edge;\nvector<vector<pair<ll,bool>>> dp;\n\nvoid merge(vector<pair<ll,bool>> &ret,vector<pair<ll,bool>> P,vector<pair<ll,bool>> &C){\n    ret.resize(P.size()+C.size());\n    for(auto &i:ret){i.F=E; i.S=false;}\n    for(int i=0;i<P.size();i++){\n        for(int t=0;t<C.size();t++){\n            ret[i+t].F=min(ret[i+t].F,P[i].F+C[t].F);\n            if(C[t].F<0 || C[t].S){\n                ret[i+t+1].F=min(ret[i+t+1].F,P[i].F);\n            }\n            if(P[i].S && C[t].S){\n                ret[i+t].S=true;\n            }\n            if(P[i].S && (C[t].S || C[t].F<0)){\n                ret[i+t+1].S=true;\n            }\n        }\n    }\n}\n\nvoid dfs(ll w,ll p){\n    //cout<<w<<\" \"<<p<<endl;\n    for(auto &i:edge[w]){\n        if(i==p){continue;}\n        dfs(i,w);\n        merge(dp[w],dp[w],dp[i]);\n    }\n}\n\n\n\nint main(){\n    cin>>n;\n    a.resize(n);\n    edge.resize(n);\n    dp.resize(n,vector<pair<ll,bool>>(1,{0,false}));\n    for(int i=0;i<n;i++){\n        cin>>a[i];\n        dp[i][0].F=a[i];\n        if(a[i]>0){dp[i][0].S=true;}\n    }\n    for(int i=1;i<n;i++){\n        ll u,v;\n        cin>>u>>v;\n        u--; v--;\n        edge[u].push_back(v);\n        edge[v].push_back(u);\n    }\n    dfs(0,-1);\n    for(int i=0;i<dp[0].size();i++){\n        if(dp[0][i].F<0 || dp[0][i].S==true){\n            cout<<i<<endl;\n            return 0;\n        }\n    }\n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(ll (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(WW,n)cerr << v[WW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,WW,HH) {REP(W_,WW){REP(H_,HH)cerr << v[W_][H_] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nll n;\nll mp[5555];\nvector<vector<int>> v(5555);\nll dp1[5555][5555];\nll dp2[5555][5555];\nll tmp1[5555];\nll tmp2[5555];\nll subNum[5555];\n\nvoid dfs(int node, int pre){\n\t//cout << \"in dfs \" << node << \" \" << pre << endl;\n\tsubNum[node] = 1;\n\t\n\tif(mp[node] > 0)dp1[node][0] = mp[node];\n\tdp2[node][0] = mp[node];\n\t\n\tREP(i,v[node].size())if(v[node][i] != pre){\n\t\tint now = v[node][i];\n\t\tdfs(now, node);\n\t\t\n\t\tREP(j,subNum[node] + subNum[now] + 1){\n\t\t\ttmp1[j] = LLINF;\n\t\t\ttmp2[j] = LLINF;\n\t\t}\n\t\t//cout << \"  \" << now << \" \" << subNum[node] << \" \" << subNum[now] << endl;\n\t\tREP(j,subNum[node]){\n\t\t\tREP(k,subNum[now]){\n\t\t\t\tif(dp1[now][k] != LLINF || dp2[now][k] < 0){\n\t\t\t\t\t//cout << \"    \" << j << \" \" << now << \" \" << k << \" \" << dp1[node][k] << endl;\n\t\t\t\t\ttmp1[j+k+1] = min(tmp1[j+k+1],dp1[node][j]);\n\t\t\t\t\ttmp2[j+k+1] = min(tmp2[j+k+1],dp2[node][j]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ttmp1[j+k] = min(tmp1[j+k],dp1[node][j] + dp1[now][k]);\n\t\t\t\ttmp2[j+k] = min(tmp2[j+k],dp1[node][j] + dp2[now][k]);\n\t\t\t\ttmp2[j+k] = min(tmp2[j+k],dp2[node][j] + dp1[now][k]);\n\t\t\t\ttmp2[j+k] = min(tmp2[j+k],dp2[node][j] + dp2[now][k]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tsubNum[node] += subNum[now];\n\t\tREP(j,subNum[node]){\n\t\t\tdp1[node][j] = tmp1[j];\n\t\t\tdp2[node][j] = tmp2[j];\n\t\t}\n\t}\n\t//cout << \"out dfs \" << node << \" \" << pre << endl;\n}\n\nint main(){\n\t\n\tREP(i,5555){\n\t\tREP(j,5555){\n\t\t\tdp1[i][j] = LLINF;\n\t\t\tdp2[i][j] = LLINF;\n\t\t}\n\t}\t\n\t\n\tcin >> n;\n\tREP(i,n)cin >> mp[i];\n\tREP(i,n-1){\n\t\tint a, b;cin >> a >> b;\n\t\ta--;b--;\n\t\tv[a].PB(b);\n\t\tv[b].PB(a);\n\t}\n\t\n\tdfs(0, -1);\n\t\n\t//SHOW2d(dp1,n+1,n+1);\n\t//SHOW2d(dp2,n+1,n+1);\n\t\n\tfor(int i = 0;i <= n;i++){\n\t\tif(dp1[0][i] != LLINF){\n\t\t\tcout << i << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif(dp2[0][i] < 0){\n\t\t\tcout << i << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define rep(i,l,r) for (int i=(l); i<=(r); i++)\n#define For(i,x) for (int i=h[x],k; i; i=nxt[i])\ntypedef long long ll;\nusing namespace std;\n\nconst int N=5010;\nint n,cnt,u,v,ans,a[N],g[N],sz[N],h[N],to[N<<1],nxt[N<<1];\nll f[N][N];\nvoid add(int u,int v){ to[++cnt]=v; nxt[cnt]=h[u]; h[u]=cnt; }\n\nvoid dfs(int x,int fa){\n\tFor(i,x) if ((k=to[i])!=fa) dfs(k,x);\n\tif (a[x]>0){\n\t\tg[x]=0;\n\t\tFor(i,x) if ((k=to[i])!=fa){\n\t\t\tint s=g[k];\n\t\t\trep(j,0,n) if (f[k][j]<0){ s=min(s,j+1); break; }\n\t\t\tg[x]+=s;\n\t\t}\n\t}\n\tf[x][0]=a[x]; sz[x]=1;\n\tFor(i,x) if ((k=to[i])!=fa){\n\t\tfor (int j=sz[x]+sz[k]; ~j; j--){\n\t\t\tf[x][j]+=f[k][0];\n\t\t\tif (j-g[k]-1>=0) f[x][j]=min(f[x][j],f[x][j-g[k]-1]);\n\t\t\trep(s,max(0,j-sz[x]),min(j,sz[k])){\n\t\t\t\tif (s) f[x][j]=min(f[x][j],f[x][j-s]+f[k][s]);\n\t\t\t\tif (s<j && f[k][s]<0) f[x][j]=min(f[x][j],f[x][j-s-1]);\n\t\t\t}\n\t\t}\n\t\tsz[x]+=sz[k];\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\trep(i,1,n) scanf(\"%d\",&a[i]);\n\trep(i,2,n) scanf(\"%d%d\",&u,&v),add(u,v),add(v,u);\n\tmemset(g,42,sizeof(g)); memset(f,42,sizeof(f));\n\tdfs(1,1); ans=g[1];\n\trep(i,0,n) if (f[1][i]<0){ ans=min(ans,i); break; }\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n)  for(long long i=0;i<(long long)(n);i++)\n#define REP(i,k,n) for(long long i=k;i<(long long)(n);i++)\n#define all(a) a.begin(),a.end()\n#define pb push_back\n#define eb emplace_back\n#define lb(v,k) (lower_bound(all(v),k)-v.begin())\n#define ub(v,k) (upper_bound(all(v),k)-v.begin())\n#define fi first\n#define se second\n#define pi M_PI\n#define PQ(T) priority_queue<T>\n#define SPQ(T) priority_queue<T,vector<T>,greater<T>>\n#define dame(a) {out(a);return 0;}\n#define decimal cout<<fixed<<setprecision(15);\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef tuple<ll,ll,ll> PP;\ntypedef tuple<ll,ll,ll,ll> PPP;\ntypedef multiset<ll> S;\nusing vi=vector<ll>;\nusing vvi=vector<vi>;\nusing vvvi=vector<vvi>;\nusing vp=vector<P>;\nusing vvp=vector<vp>;\nusing vb=vector<bool>;\nusing vvb=vector<vb>;\nconst ll inf=1001001001001001001;\nconst int INF=1001001001;\nconst int mod=998244353;\nconst double eps=1e-10;\ntemplate<class T> bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<class T> bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<class T> void out(T a){cout<<a<<'\\n';}\ntemplate<class T> void outp(T a){cout<<'('<<a.fi<<','<<a.se<<')'<<'\\n';}\ntemplate<class T> void outvp(T v){rep(i,v.size())cout<<'('<<v[i].fi<<','<<v[i].se<<')';cout<<'\\n';}\ntemplate<class T> void outvvp(T v){rep(i,v.size())outvp(v[i]);}\ntemplate<class T> void outv(T v){rep(i,v.size()){if(i)cout<<' ';cout<<v[i];}cout<<'\\n';}\ntemplate<class T> void outvv(T v){rep(i,v.size())outv(v[i]);}\ntemplate<class T> bool isin(T x,T l,T r){return (l)<=(x)&&(x)<=(r);}\ntemplate<class T> void yesno(T b){if(b)out(\"yes\");else out(\"no\");}\ntemplate<class T> void YesNo(T b){if(b)out(\"Yes\");else out(\"No\");}\ntemplate<class T> void YESNO(T b){if(b)out(\"YES\");else out(\"NO\");}\ntemplate<class T> void noyes(T b){if(b)out(\"no\");else out(\"yes\");}\ntemplate<class T> void NoYes(T b){if(b)out(\"No\");else out(\"Yes\");}\ntemplate<class T> void NOYES(T b){if(b)out(\"NO\");else out(\"YES\");}\nvoid outs(ll a,ll b){if(a>=inf-100)out(b);else out(a);}\nll gcd(ll a,ll b){if(b==0)return a;return gcd(b,a%b);}\nll modpow(ll a,ll b){a%=mod;if(b==0)return 1;if(b&1)return a*modpow(a,b-1)%mod;ll k=modpow(a,b/2);return k*k%mod;}\nvi val,sz;\nvvi g,dp,dp1;\nvoid dfs(int v,int p){\n    sz[v]=1;\n    for(ll x:g[v])if(x!=p){\n        dfs(x,v);\n        sz[v]+=sz[x];\n    }\n    /*vi sdp(1),sdp1(1);\n    sdp[0]=val[v];\n    if(val[v]>0)sdp1[0]=1;\n    for(ll x:g[v])if(x!=p){\n        vi ndp(sdp.size()+sz[x],inf),ndp1(sdp.size()+sz[x]);\n        rep(i,sdp.size())rep(j,sz[x]){\n            chmin(ndp[i+j],sdp[i]+dp[x][j]);\n            if(dp1[x][j]||dp[x][j]<0)chmin(ndp[i+j+1],sdp[i]);\n            if(sdp1[i]){\n                if(dp[x][j]<0||dp1[x][j])ndp1[i+j+1]=1;\n                if(dp1[x][j])ndp1[i+j]=1;\n            }\n        }\n        sdp=ndp;\n        sdp1=ndp1;\n    }*/\n    vi sdp(sz[v]+1,inf),sdp1(sz[v]+1);\n    sdp[0]=val[v];\n    if(val[v]>0)sdp1[0]=1;\n    int cur=0;\n    for(ll x:g[v])if(x!=p){\n        for(int j=cur;j>=0;j--){\n            ll t=sdp[j],t1=sdp1[j];\n            sdp[j]=inf;sdp1[j]=0;\n            rep(k,sz[x]+1){\n                chmin(sdp[j+k],t+dp[x][k]);\n                if(dp[x][k]<0||dp1[x][k])chmin(sdp[j+k+1],t);\n                if(val[v]>0&&t1){\n                    if(dp1[x][k])sdp1[j+k]=1;\n                    if(dp[x][k]<0||dp1[x][k])sdp1[j+k+1]=1;\n                }\n            }\n        }\n        cur+=sz[x];\n    }\n    rep(j,sz[v]+1){\n        dp[v][j]=sdp[j];\n        dp1[v][j]=sdp1[j];\n    }\n}\nint main(){\n    ll n;cin>>n;\n    val=vi(n);\n    sz=vi(n);\n    dp1=vvi(n,vi(n+1,inf));\n    dp=vvi(n,vi(n+1));\n    rep(i,n)cin>>val[i];\n    g=vvi(n);\n    rep(i,n-1){\n        ll a,b;cin>>a>>b;a--;b--;\n        g[a].pb(b);\n        g[b].pb(a);\n    }\n    dfs(0,-1);\n    ll ans=n;\n    rep(i,n)if(dp[0][i]<0||dp1[0][i])chmin(ans,i);\n    out(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n//#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　  |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\n\n\n\n\nint N, A[5010];\nvector<int> E[5010];\n//---------------------------------------------------------------------------------------------------\nmap<int, pair<ll, int>> dp[5010];\nvoid marge(int cu, int to) {\n    map<int, pair<ll, int>> res;\n    fore(rootp, dp[cu]) fore(bp, dp[to]) {\n        // くっつける\n        if (!res.count(rootp.first + bp.first)) res[rootp.first + bp.first] = { infl, 0 };\n        chmin(res[rootp.first + bp.first].first, rootp.second.first + bp.second.first);\n        if (rootp.second.second and bp.second.second) res[rootp.first + bp.first].second = 1;\n\n        // くっつけない\n        if (!res.count(rootp.first + bp.first + 1)) res[rootp.first + bp.first + 1] = { infl, 0 };\n        if(bp.second.first < 0 or bp.second.second) chmin(res[rootp.first + bp.first + 1].first, rootp.second.first);\n        if ((bp.second.first < 0 or bp.second.second) and rootp.second.second) res[rootp.first + bp.first + 1].second = 1;\n    }\n    swap(dp[cu], res);\n}\n//---------------------------------------------------------------------------------------------------\nvoid dfs(int cu, int pa = -1) {\n    dp[cu][0] = { A[cu], 0 < A[cu] };\n    fore(to, E[cu]) if (to != pa) {\n        dfs(to, cu);\n        marge(cu, to);\n    }\n    /*printf(\"dp for %d\\n\", cu);\n    fore(p, res) {\n        printf(\"dp[%d] = %lld,%d\\n\", p.first, p.second.first, p.second.second);\n    }*/\n}\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> N;\n    rep(i, 0, N) cin >> A[i];\n    rep(i, 0, N - 1) {\n        int a, b; cin >> a >> b;\n        a--; b--;\n        E[a].push_back(b);\n        E[b].push_back(a);\n    }\n\n    dfs(0);\n    int ans = inf;\n    fore(p, dp[0]) {\n        if (p.second.first < 0 or p.second.second == 1) chmin(ans, p.first);\n        //printf(\"dp[%d] = %lld,%d\\n\", p.first, p.second.first, p.second.second);\n    }\n    cout << ans << endl;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FAST ios_base::sync_with_stdio(false); cin.tie(0);\n#define pb push_back\n#define eb emplace_back\n#define ins insert\n#define f first\n#define s second\n#define cbr cerr << \"hi\\n\"\n#define mmst(x, v) memset((x), v, sizeof ((x)))\n#define siz(x) ll(x.size())\n#define all(x) (x).begin(), (x).end()\n#define lbd(x,y) (lower_bound(all(x),y)-x.begin())\n#define ubd(x,y) (upper_bound(all(x),y)-x.begin())\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());    //can be used by calling rng() or shuffle(A, A+n, rng)\ninline long long rand(long long x, long long y) { return (rng() % (y+1-x)) + x; } //inclusivesss\nstring inline to_string(char c) {string s(1,c);return s;} template<typename T> inline T gcd(T a,T b){ return a==0?llabs(b):gcd(b%a,a); }\n\ntypedef long long ll; \ntypedef long double ld;\n#define FOR(i,s,e) for(ll i=s;i<=ll(e);++i)\n#define DEC(i,s,e) for(ll i=s;i>=ll(e);--i)\ntypedef pair<ll,ll>pi; typedef pair<ll,pi>spi; typedef pair<pi,pi>dpi;\n\n#define LLINF ((long long)1e18)\n#define INF int(1e9+1e6)\n#define MAXN (5006)\nll n,A[MAXN],dp[MAXN][MAXN],sz[MAXN];// if 0 then max, 1 then min\nbitset<MAXN> dp2[MAXN];\nvector<int>v[MAXN];\nvoid dfs(ll x,ll p){\n\tsz[x]=1;\n\tdp[x][0]=A[x];\n\tfor(auto i:v[x]) if(i^p) dfs(i,x), sz[x]+=sz[i];\n\tFOR(k,1,sz[x]) dp[x][k]=LLINF;\n\tll cur = 1;\n\tif(A[x]>0)dp2[x][0]=1;\n\tfor(auto i:v[x]) if(i^p) {\n\t\tDEC(j,cur+sz[i],0){\n\t\t\tif(dp[x][j]<LLINF) dp[x][j] += dp[i][0];\n\t\t\tdp2[x][j] = dp2[x][j] & dp2[i][0];\n\t\t\tFOR(k,max(j-cur,1ll),min(j,sz[i])){\n\t\t\t\tdp[x][j]=min(dp[x][j],dp[x][j-k]+dp[i][k]);\n\t\t\t\tif(dp2[i][k-1]) dp[x][j]=min(dp[x][j],dp[x][j-k]);\n\t\t\t\tdp2[x][j]=dp2[x][j]|(dp2[x][j-k]&dp2[i][k]);\n\t\t\t\tif(dp[i][k-1] < 0) dp2[x][j]=dp2[x][j]|dp2[x][j-k];\n\t\t\t}\n\t\t}\n\t\tcur += sz[i];\n\t}\n}\nint main(){\n\tFAST\n\tcin>>n;\n\tFOR(i,1,n)cin>>A[i];\n\tFOR(i,2,n){\n\t\tll a,b;cin>>a>>b;\n\t\tv[a].eb(b),v[b].eb(a);\n\t}\n\tdfs(1,1);\n\tll ans = n-1;\n\tFOR(k,0,n-1) if(dp[1][k] < 0) ans = min(ans, k);\n\tFOR(k,0,n-1) if(dp2[1][k]) ans = min(ans, k);\n\tcout<<ans<<'\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cctype>\n#include <cstdint>\n#include <cmath>\n#include <complex>\n#include <chrono>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n#include <random>\n#include <memory>\n#include <utility>\n#include <limits>\n \n#define rep(i, a, b) for (long long i = (a); (i) < (b); (i)++)\n#define all(i) i.begin(), i.end()\n#define debug(...) std::cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n\nvoid debug_out(){std::cerr<<std::endl;}\n\ntemplate<typename Head,typename... Tail>\nvoid debug_out(Head h,Tail... t){\n  std::cerr<<\" \"<<h;\n  debug_out(t...);\n}\n \ntemplate <typename T1, typename T2>\nstd::ostream& operator<<(std::ostream& os, std::pair<T1, T2> pa) {\n  return os << pa.first << \" \" << pa.second;\n}\n \ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, std::vector<T> vec) {\n  for (int i = 0; i < vec.size(); i++)os << vec[i] << (i + 1 == vec.size() ? \"\" : \" \");\n  return os;\n}\n \ntemplate<typename T1,typename T2>\ninline bool chmax(T1& a,T2 b){return a<b && (a=b,true);}\n \ntemplate<typename T1,typename T2>\ninline bool chmin(T1& a,T2 b){return a>b && (a=b,true);}\n \nlong long pow_mod(long long a, long long b, long long mod=-1) {\n  if(b==0)return 1;\n  if ((a == 0)||(mod!=-1&&(a+mod)%mod==0)) {\n    return 0;\n  }\n  long long x = 1;\n  while (b > 0) {\n    if (b & 1) {\n      x = (mod!=-1)?(x * a) % mod:x*a;\n    }\n    a = (mod!=-1)?(a * a) % mod:a*a;\n    b >>= 1;\n  }\n  return x;\n}\n\n// const long long MOD = 998244353;\nconst long long MOD = 1e9 + 7;\n\nusing ll = long long;\nusing P=std::pair<long long,long long>;\n\nint main() {\n  std::cin.tie(nullptr);\n  std::ios::sync_with_stdio(false);\n\n  ll n;\n  std::cin>>n;\n\n  std::vector<ll> a(n);\n  rep(i,0,n)std::cin>>a[i];\n\n  std::vector<std::vector<ll>> graph(n);\n  rep(i,0,n-1){\n    ll u,v;\n    std::cin>>u>>v;\n    u--;v--;\n    graph[u].push_back(v);\n    graph[v].push_back(u);\n  }\n\n  const ll INF=std::numeric_limits<ll>::max()/3;\n\n  std::vector<std::vector<ll>> dp1(5010,std::vector<ll>(5010,INF)),dp2(5010,std::vector<ll>(5010,INF));\n\n  auto dfs=[&](auto f,ll v,ll par)->ll{\n    dp1[v][0]=(a[v]>0)?a[v]:INF;\n    dp2[v][0]=a[v];\n\n    ll ret=1;\n    for(auto e:graph[v]){\n      if(e==par)continue;\n      std::vector<ll> temp1(5010,INF);\n      std::vector<ll> temp2(5010,INF);\n      ll sz=f(f,e,v);\n      rep(i,0,ret){\n        rep(j,0,sz){\n          chmin(temp1[i+j],dp1[v][i]+dp1[e][j]);\n          if(dp1[e][j]!=INF||dp2[e][j]<0)chmin(temp1[i+j+1],dp1[v][i]);\n          if(dp2[v][i]!=INF||dp2[e][j]!=INF)chmin(temp2[i+j],dp2[v][i]+dp2[e][j]);\n          if(dp2[e][j]<0||dp2[e][j]==dp1[e][j])chmin(temp2[i+j+1],dp2[v][i]);\n        }\n      }\n      dp1[v]=temp1;\n      dp2[v]=temp2;\n      ret+=sz;\n    }\n    /*\n    debug(v);\n    std::cout<<\"dp1 \";\n    rep(i,0,5010){\n      if(dp1[v][i]!=INF)std::cout<<\"[\"<<i<<\":\"<<dp1[v][i]<<\"] \";\n    }\n    std::cout<<\"\\n\";\n    std::cout<<\"dp2 \";\n    rep(i,0,5010){\n      if(dp2[v][i]!=INF)std::cout<<\"[\"<<i<<\":\"<<dp2[v][i]<<\"] \";\n    }\n    std::cout<<\"\\n\";\n    */\n    return ret;\n  };\n\n  dfs(dfs,0,-1);\n\n  rep(i,0,5010){\n    if(dp1[0][i]!=INF||dp2[0][i]<0){\n      std::cout<<i<<\"\\n\";\n      return 0;\n    }\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <deque>\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <iterator>\n#include<iomanip>\n\nusing namespace std;\n\n#define rep(i,a,b) for(int i=(a), i##_len=(b);i<i##_len;i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\n\n#define int ll\n#define SZ(x) ((int)(x).size())\n#define pb push_back\n#define mp make_pair\n\ntypedef long long ll;\n//typedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\ntypedef pair<double, double> pdd;\ntypedef vector<vector<int>> mat;\n//typedef unsigned int uint;\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\n\nint N;\nint A[5010];\nint V[5010];\nvector<int> G[5010];\nint dp[5010][5010][2], temp[5010][2];\n\nvoid dfs(int v, int p)\n{\n\tfor (auto n : G[v])if (p != n)dfs(n, v);\n\n\tint vs = 1;\n\tdp[v][0][A[v] < 0 ? 1 : 0] = A[v];\n\n\tfor (auto n : G[v])if (p != n)\n\t{\n\t\trep(j0, 0, vs)rep(j1, 0, V[n])rep(k0, 0, 2)rep(k1, 0, 2)\n\t\t{\n\t\t\tchmin(temp[j0 + j1][k0 | k1], dp[v][j0][k0] + dp[n][j1][k1]);\n\t\t\tif ((k1 == 0 && dp[n][j1][k1] < INF) || dp[n][j1][k1] < 0)\n\t\t\t{\n\t\t\t\tchmin(temp[j0 + j1 + 1][k0], dp[v][j0][k0]);\n\t\t\t}\n\t\t}\n\n\t\tvs += V[n];\n\t\trep(j, 0, vs)rep(k, 0, 2)\n\t\t{\n\t\t\tdp[v][j][k] = temp[j][k];\n\t\t\ttemp[j][k] = INF;\n\t\t}\n\t}\n\n\tV[v] = vs;\n}\n\nsigned main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tcin >> N;\n\trep(i, 0, N)cin >> A[i];\n\n\tint u, v;\n\trep(i, 0, N - 1)\n\t{\n\t\tcin >> u >> v;\n\t\tu--, v--;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\n\trep(j, 0, N)rep(k, 0, 2)\n\t{\n\t\trep(i, 0, 5010)dp[i][j][k] = INF;\n\t\ttemp[j][k] = INF;\n\t}\n\n\tdfs(0, -1);\n\n\tint ans = N - 1;\n\trep(j, 0, N)\n\t{\n\t\tif (dp[0][j][0] < INF)chmin(ans, j);\n\t\tif (dp[0][j][1] < 0)chmin(ans, j);\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1LL<<60)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n;\nll a[5005];\nll a2[5005];\nvector<int> G[5005];\nvector<int> G2[5005];\nint cmp[5005];\nll dp[5005][5005][2];\nint sz[5005];\nint cnt2[5005];\n\nvoid dfs(int v,int c){\n    cmp[v]=c;\n    if(a[v]<0LL)return;\n    for(int i=0;i<G[v].size();i++){\n        int nv=G[v][i];\n        if(a[nv]>0 && cmp[nv]==-1){\n            dfs(nv,c);\n        }\n    }\n}\n\nint dfs2(int v,int p){\n    sz[v]=1;\n    for(int i=0;i<G2[v].size();i++){\n        int nv=G2[v][i];\n        if(nv!=p){\n            sz[v]+=dfs2(nv,v);\n        }\n    }\n    return sz[v];\n}\n\nll tmp[5005][2];\n\nvoid dfs3(int v,int p){\n    int szc=1;\n    dp[v][0][0]=a2[v];\n    cnt2[v]++;\n    assert(cnt2[v]==1);\n    for(int i=0;i<G2[v].size();i++){\n        int nv=G2[v][i];\n        if(nv==p)continue;\n        dfs3(nv,v);\n        for(int j=0;j<=szc+sz[nv];j++){\n            tmp[j][0]=1LL<<60;\n            tmp[j][1]=1LL<<60;\n        }\n        for(int j=0;j<szc;j++){\n            for(int k=0;k<sz[nv];k++){\n                tmp[j+k][1]=min(tmp[j+k][1],dp[v][j][0]+dp[nv][k][0]);\n                tmp[j+k][1]=min(tmp[j+k][1],dp[v][j][1]+dp[nv][k][0]);\n                tmp[j+k][1]=min(tmp[j+k][1],dp[v][j][0]+dp[nv][k][1]);\n                tmp[j+k][1]=min(tmp[j+k][1],dp[v][j][1]+dp[nv][k][1]);\n                if(dp[nv][k][1]<0LL || dp[nv][k][0]!=INF)tmp[j+k+1][1]=min(tmp[j+k+1][1],dp[v][j][1]);\n                if(dp[nv][k][1]<0LL || dp[nv][k][0]!=INF)tmp[j+k+1][0]=min(tmp[j+k+1][0],dp[v][j][0]);\n            }\n        }\n        for(int j=0;j<=szc+sz[nv];j++){\n            dp[v][j][0]=tmp[j][0];\n            dp[v][j][1]=tmp[j][1];\n        }\n        szc+=sz[nv];\n    }\n    /*\n    printf(\"%d\\n\",v);\n    for(int i=0;i<=szc;i++){\n        printf(\"%lld %lld\\n\",dp[v][i][0],dp[v][i][1]);\n    }\n     */\n}\n\nint main(void){\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%lld\",&a[i]);\n    }\n    for(int i=0;i<n-1;i++){\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        u--;\n        v--;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    memset(cmp,-1,sizeof(cmp));\n    int sz=0;\n    for(int i=0;i<n;i++){\n        if(cmp[i]==-1){\n            dfs(i,sz++);\n        }\n        //printf(\"%d \",cmp[i]);\n    }\n    //printf(\"\\n\");\n    for(int i=0;i<n;i++){\n        a2[cmp[i]]+=a[i];\n        for(int j=0;j<G[i].size();j++){\n            int nv=cmp[G[i][j]];\n            if(nv!=cmp[i]){\n                G2[cmp[i]].push_back(nv);\n            }\n        }\n    }\n    for(int i=0;i<sz;i++){\n        sort(G2[i].begin(),G2[i].end());\n        G2[i].erase(unique(G2[i].begin(),G2[i].end()),G2[i].end());\n    }\n    dfs2(0,-1);\n    for(int i=0;i<=sz;i++){\n        for(int j=0;j<=sz;j++){\n            for(int k=0;k<2;k++){\n                dp[i][j][k]=1LL<<60;\n            }\n        }\n    }\n    dfs3(0,-1);\n    int ans=n;\n    for(int i=0;i<=sz;i++){\n        if(dp[0][i][0]<0LL || dp[0][i][1]<0LL)ans=min(ans,i);\n        if(dp[0][i][0]!=INF)ans=min(ans,i);\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define x first\n#define y second\nusing namespace std;\nconst int N = 5005;\nint n, A[N], ok[N], F[N], sz[N];\nlong long dp[N][N], dpt[N];\nvector < int > Adj[N];\nvoid DFS(int v, int p)\n{\n    sz[v] = 1;\n    for (int i = 0; i < Adj[v].size(); i++)\n        if (Adj[v][i] == p)\n            swap(Adj[v][i], Adj[v].back()), Adj[v].pop_back();\n\n    if (!Adj[v].size())\n    {\n        ok[v] = 0;\n        if (A[v] > 0)\n            F[v] = 0;\n        for (int i = 0; i < 1; i++)\n            dp[v][i] = A[v];\n        return ;\n    }\n\n    for (int &u : Adj[v])\n        DFS(u, v);\n\n    dp[v][0] = A[v];\n    for (int &u : Adj[v])\n    {\n        memset(dpt, 63, sizeof(dpt));\n        for (int i = 0; i < sz[v]; i++)\n            for (int j = 0; j < sz[u]; j++)\n                dpt[i + j] = min(dpt[i + j], dp[v][i] + dp[u][j]);\n        for (int i = 0; i < sz[v]; i++)\n            dpt[i + ok[u] + 1] = min(dpt[i + ok[u] + 1], dp[v][i]);\n        sz[v] += sz[u];\n        for (int i = 0; i < sz[v]; i++)\n            dp[v][i] = dpt[i];\n    }\n    for (int i = 0; i < N; i++)\n        if (dp[v][i] < 0)\n            ok[v] = min(ok[v], i);\n\n    if (A[v] > 0)\n    {\n        F[v] = 0;\n        for (int &u : Adj[v])\n            F[v] += min(ok[u] + 1, F[u]);\n        ok[v] = min(ok[v], F[v]);\n    }\n}\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++)\n        scanf(\"%d\", &A[i]);\n    for (int i = 1, v, u; i < n; i++)\n        scanf(\"%d%d\", &v, &u), Adj[v].pb(u), Adj[u].pb(v);\n    memset(ok, 63, sizeof(ok));\n    memset(F, 63, sizeof(F));\n    memset(dp, 63, sizeof(dp));\n    DFS(1, 0);\n    return !printf(\"%d\", ok[1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << (x) << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){\n\treturn o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";\n}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){\n\to<<\"{\";\n\tfor(const T& v:vc) o<<v<<\",\";\n\to<<\"}\";\n\treturn o;\n}\nusing ll = long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<vector<T>>;\nint N;\nV<ll> A;\nVV<int> G;\nV<int> sz;\nll dp[5010][2][5010];\nll inner[2][5010];\nll ninner[2][5010];\nll inf = 1e18;\nvoid dfs(int v,int p){\n\tsz[v] = 1;\n\tfor(int u:G[v]) if(u!=p) dfs(u,v),sz[v] += sz[u];\n\tint S = 1;\n\tinner[0][0] = inner[1][0] = A[v];\n\tif(A[v]<0) inner[1][0] = inf;\n\tfor(int u:G[v]) if(u!=p){\n\t\trep(i,2) rep(j,S+sz[u]) ninner[i][j] = inf;\n\t\trep(allp,2) rep(c,S) if(inner[allp][c] != inf){\n\t\t\trep(uallp,2) rep(uc,sz[u]+1) if(dp[u][uallp][uc] != inf){\n\t\t\t\tchmin(ninner[allp&uallp][c+uc],inner[allp][c] + dp[u][uallp][uc]);\n\t\t\t\tif(uallp==1 || dp[u][uallp][uc]<0){\n\t\t\t\t\tchmin(ninner[allp&uallp][c+uc+1],inner[allp][c]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i,2) rep(j,S+sz[u]) inner[i][j] = ninner[i][j];\n\t\tS += sz[u];\n\t}\n\trep(i,2) rep(j,S) dp[v][i][j] = inner[i][j];\n}\nint main(){\n\tcin>>N;\n\tA.resize(N);\n\tG.resize(N);\n\tsz.resize(N);\n\trep(i,N) cin>>A[i];\n\trep(i,N-1){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tx--,y--;\n\t\tG[x].pb(y);\n\t\tG[y].pb(x);\n\t}\n\tdfs(0,-1);\n\tint ans = N;\n\trep(allp,2) rep(c,N) if(dp[0][allp][c] != inf){\n\t\tif(allp==1 || dp[0][allp][c]<0) chmin(ans,c);\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n#define dump(x) cout << #x << \" = \" << (x) << endl\n\ninline void chmin(ll &x, ll y) {\n\tif (x >= y) x = y;\n}\n\nconst int MN = 5010;\nconst ll INF = 1e18;\n\nint N;\nll A[MN];\nvi g[MN];\nint u[MN];\nvector<ll> dp[MN][2][2];\nint sz[MN];\n\nvoid dfs(int v, int par) {\n\tsz[v] = 1;\n\tint c = 0;\n\n\tfor (int to : g[v]) if (to != par) {\n\t\tdfs(to, v);\n\t\tsz[v] += sz[to];\n\t}\n\n\tint p = 0, q = 1;\n\n\trep(t, 2) {\n\t\trep(k, 2) {\n\t\t\tdp[v][t][k].resize(sz[v] + 1);\n\t\t\trep(j, sz[v] + 1) {\n\t\t\t\tdp[v][t][k][j] = INF;\n\t\t\t}\n\t\t}\n\t}\n\n\tdp[v][0][A[v] < 0][0] = A[v];\n\n\tfor (int to : g[v]) if (to != par) {\n\t\trep(j, sz[v] + 1) rep(k, 2) dp[v][q][k][j] = INF;\n\n\t\tfor (int i = 0; i <= c; ++i) {\n\t\t\trep(f, 2) if (dp[v][p][f][i] != INF) {\t\n\t\t\t\tfor (int j = 0; j <= sz[to]; ++j) {\n\t\t\t\t\trep(k, 2) if (dp[to][u[to]][k][j] != INF) {\n\t\t\t\t\t\tchmin(dp[v][q][f | k][i + j], dp[v][p][f][i] + dp[to][u[to]][k][j]);\n\t\t\t\t\t\tif (k == 0 || dp[to][u[to]][k][j] < 0) {\n\t\t\t\t\t\t\tchmin(dp[v][q][f][i + j + 1], dp[v][p][f][i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tc += sz[to];\n\t\tswap(p, q);\n\t}\n\n\tu[v] = p;\n}\n\nint main() {\n\tcin >> N;\n\trep(i, N) cin >> A[i];\n\trep(i, N-1) {\n\t\tint a, b; cin >> a >> b;\n\t\t--a; --b;\n\t\tg[a].pb(b); g[b].pb(a);\n\t}\n\tdfs(0, -1);\n\n\tint ans = N;\n\n\trep(j, MN) {\n\t\tif (dp[0][u[0]][0][j] != INF) {\n\t\t\tans = j;\n\t\t\tbreak;\n\t\t}\n\t\tif (dp[0][u[0]][1][j] < 0) {\n\t\t\tans = j;\n\t\t\tbreak;\n\t\t}\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, int> l_i;\ntypedef pair<int, int> i_i;\n#define EPS (1e-7)\n#define INF ((ll)1e16)\nconst ll CHECK = 1e15;\nint Size[6000];\n//const ll mod = 1000000007;\nint n;\nll a[6000];\nvector<ll> pathes[6000];\nint par[6000];\nvector<ll> children[6000];\nll dp[6000][6000][2]; // dp1[i][j][k]:デバイスiより下でj回カットしたときの, デバイスiの電量総和の最小値\n//ただし, k=0なら連結成分はバッテリーのみ\n//ll dp2[6000]; //dp2[i][j]:デバイスiの部分木でデバイスiの連結成分がバッテリーのみとなるのに必要なカット回数の最小値\nll f(int from, int cut, int index);\nll g(int from, int cut, int index);\nvoid bfs(int from){\n    Size[from] = 1;\n    for(int i = 0; i < pathes[from].size(); i++){\n        int to = pathes[from][i];\n        if(par[from] == to) continue;\n        par[to] = from;\n        children[from].push_back(to);\n        bfs(to);\n        Size[from] += Size[to];\n    }\n}\n\nvoid bfs2(int from) {\n    if(children[from].empty()){\n        for(int i = 0; i <= 5000; i++){\n            dp[from][i][0] = INF;\n            dp[from][i][1] = INF;\n        }\n        dp[from][0][1] = a[from];\n        if(a[from] > 0) dp[from][0][0] = a[from];\n        return;\n    }\n    for(int i = 0; i < children[from].size(); i++) {\n        int to = children[from][i];\n        bfs2(to);\n        /*\n        dp1[from][0] += dp1[to][0];\n        dp1[from][0] = min(dp1[from][0], INF);\n        dp2[from][0] = dp2[from][0] & dp2[to][0];\n        */\n    }\n    for(int cut = 0; cut <= Size[from]; cut++) {\n        dp[from][cut][1] = f(from, cut, 0);\n        //cout << \"computerOK: \" << from << \" \" << cut << \" \" << dp[from][cut][1] << endl;\n        if(dp[from][cut][1] > CHECK) {\n            while(cut <= 5000) {\n                dp[from][cut][1] = INF;\n                cut++;\n            }\n        }\n    }\n    if(a[from] < 0) {\n        for(int cut = 0; cut <= 5000; cut++) {\n            dp[from][cut][0] = INF;\n        }\n        return;\n    }\n    for(int cut = 0; cut <= Size[from]; cut++) {\n        dp[from][cut][0] = g(from, cut, 0);\n        //cout << \"computerNG: \" << from << \" \" << cut << \" \" << dp[from][cut][0] << endl;\n        /*\n        if(dp[from][cut][0] > CHECK) {\n            while(cut <= 5000) {\n                dp[from][cut][0] = INF;\n                cut++;\n            }\n        }\n        */\n    }\n    return;\n}\n\nmap<pair<int, i_i>, ll> mp;\nll f(int from, int cut, int index) {\n    if(cut < 0) return INF;\n    if(index == children[from].size()) {\n        if(cut == 0) return 0;\n        return INF;\n    }\n    if(mp[{from, {cut, index}}] != 0){\n        return mp[{from, {cut, index}}];\n    }\n    int to = children[from][index];\n    ll val = INF;\n    for(int i = 0; i <= Size[to]; i++) {\n        ll now = f(from, cut - i, index + 1) + dp[to][i][1];\n        //cout << from << \" \" << cut << \" \" << i << \" \" << to << \" \" << dp[to][i][1] << endl;\n        //cout << to << \" \" << i << \" \" << dp[to][i][1] << \" \" << dp[to][i][0] << endl;\n        if((dp[to][i][1] < 0) || (dp[to][i][0] < CHECK)) {\n            //cout << \"cut \" << from << \" \" << to << endl;\n            now = min(now, f(from, cut - i - 1, index + 1));\n        }\n        val = min(now, val);\n    }\n    mp[{from, {cut, index}}] = val;\n    if(index == 0) {\n        return val + a[from];\n    }\n    return val;\n}\n\nmap<pair<int, i_i>, ll> mp2;\nll g(int from, int cut, int index) {\n    if(cut < 0) return INF;\n    if(index == children[from].size()) {\n        if(cut == 0) return 0;\n        return INF;\n    }\n    if(mp2[{from, {cut, index}}] != 0){\n        return mp2[{from, {cut, index}}];\n    }\n    int to = children[from][index];\n    ll val = INF;\n    for(int i = 0; i <= Size[to]; i++) {\n        ll now = g(from, cut - i, index + 1) + dp[to][i][0];\n        if((dp[to][i][1] < 0) || (dp[to][i][0] < CHECK)) {\n            now = min(now, g(from, cut - i - 1, index + 1));\n        }\n        val = min(now, val);\n    }\n    mp2[{from, {cut, index}}] = val;\n    if(index == 0) {\n        return val + a[from];\n    }\n    return val;\n}\n\nint main() {\n    //cout.precision(10);\n    cin >> n;\n    for(int i = 1; i <= n; i++){\n        cin >> a[i];\n    }\n    for(int i = 1; i < n; i++){\n        int u, v;\n        cin >> u >> v;\n        pathes[u].push_back(v);\n        pathes[v].push_back(u);\n    }\n    par[1] = -1;\n    bfs(1);\n    bfs2(1);\n    //cout << dp[1] << endl;\n    for(int cut = 0; ; cut++) {\n        if((dp[1][cut][0] < CHECK) || (dp[1][cut][1] < 0)) {\n            cout << cut << endl;\n            return 0;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n#define reps(i, n) for (int i = 1; i <= (int) (n); i++)\n#define all(x) (x).begin(), (x).end()\n#define uniq(x) (x).erase(unique(all(x)), (x).end())\n#define bit(n) (1LL << (n))\n#define cdiv(a, b) (((a) - 1) / (b) + 1)\n#define dump(x) cerr << #x \" = \" << (x) << endl\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing pint = pair<int, int>;\nusing vpint = vector<pint>;\ntemplate<typename T> using priority_queue_rev = priority_queue<T, vector<T>, greater<T>>;\nconstexpr double PI = 3.1415926535897932384626433832795028;\nconstexpr int DY[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nconstexpr int DX[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nint gcd(int a, int b) {\n    while (b) { swap(a %= b, b); }\n    return a;\n}\nint lcm(int a, int b) { return a / gcd(a, b) * b; }\nint sgn(int x) { return (x > 0) - (x < 0); }\ntemplate<typename T> void fin(T mes) {\n    cout << mes << endl;\n    exit(0);\n}\ntemplate<typename T, typename U> bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &rhs) {\n    os << \"(\" << rhs.first << \", \" << rhs.second << \")\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\nstruct setup {\n    static constexpr int PREC = 20;\n\n    setup() {\n        cout << fixed << setprecision(PREC);\n        cerr << fixed << setprecision(PREC);\n    };\n} setup;\n\nint N;\nint A[5500];\nint U[5500], V[5500];\nvint G[5500];\npair<vint, int> dfs(int cur, int par) {\n    vint x = {A[cur]};\n    int cut = 0;\n    for (int to:G[cur]) {\n        if (to == par) { continue; }\n        pair<vint, int> tmp = dfs(to, cur);\n        vint nxt = tmp.first;\n        int ccut = tmp.second;\n        vint y(x.size() + nxt.size(), LLONG_MAX);\n        if (ccut >= 0) { rep(i, x.size()) { y[i + ccut + 1] = x[i]; }}\n        rep(i, x.size()) {\n            rep(j, nxt.size()) {\n                chmin(y[i + j], x[i] + nxt[j]);\n                if (nxt[j] < 0) { chmin(y[i + j + 1], x[i]); }\n            }\n        }\n        x = y;\n        reps(i, x.size() - 1) { chmin(x[i], x[i - 1]); }\n        int pl;\n        for (int i = nxt.size(); i >= 0; i--) { if (nxt[i] < 0) { pl = i; }}\n        if (ccut >= 0) { cut += min(ccut, pl + 1); }\n        else { cut += pl + 1; }\n    }\n    if (A[cur] < 0) { cut = -1; }\n    return {x, cut};\n}\n\nsigned main() {\n    cin >> N;\n    rep(i, N) { cin >> A[i]; }\n    rep(i, N - 1) {\n        cin >> U[i] >> V[i];\n        U[i]--, V[i]--;\n        G[U[i]].push_back(V[i]), G[V[i]].push_back(U[i]);\n    }\n    pair<vint, int> res = dfs(0, -1);\n    int ans = N;\n    if (A[0] > 0) { ans = res.second; }\n    rep(i, res.first.size()) { if (res.first[i] < 0) { chmin(ans, i); }}\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int64 INF = 1LL << 58;\n\nvector< int > g[5000];\nint N, A[5000];\nvector< bool > latte[5000];\nvector< int64 > malta[5000];\n\nvoid chmin(int64 &a, int64 b) { a = min(a, b); }\n\nvoid dfs(int idx, int par) {\n  for(auto &to : g[idx]) {\n    if(to == par) continue;\n    dfs(to, idx);\n  }\n\n  latte[idx].emplace_back(A[idx] > 0);\n  for(auto &to : g[idx]) {\n    if(to == par) continue;\n    if(A[to] > 0) {\n      vector< bool > nxt(latte[idx].size() + latte[to].size());\n      for(int i = 0; i < latte[idx].size(); i++) {\n        for(int j = 0; j < latte[to].size(); j++) {\n          if(latte[idx][i] & latte[to][j]) {\n            nxt[i + j] = true;\n          }\n        }\n      }\n      latte[idx].swap(nxt);\n\n    } else {\n      vector< bool > nxt(latte[idx].size() + latte[to].size());\n      for(int i = 0; i < latte[idx].size(); i++) {\n        for(int j = 0; j < malta[to].size(); j++) {\n          if(!latte[idx][i] || malta[to][j] >= 0) continue;\n          nxt[i + j + 1] = true;\n        }\n      }\n      latte[idx].swap(nxt);\n    }\n  }\n\n\n  malta[idx].emplace_back(A[idx]);\n  for(auto &to : g[idx]) {\n    if(to == par) continue;\n    vector< int64 > nxt(malta[idx].size() + latte[to].size(), INF);\n    for(int i = 0; i < malta[idx].size(); i++) {\n      for(int j = 0; j < latte[to].size(); j++) {\n        if(latte[to][j]) chmin(nxt[i + j + 1], malta[idx][i]);\n      }\n      for(int j = 0; j < malta[to].size(); j++) {\n        if(malta[to][j] == INF) continue;\n        chmin(nxt[i + j], malta[idx][i] + malta[to][j]);\n      }\n    }\n    malta[idx].swap(nxt);\n  }\n\n  for(int i = 0; i < malta[idx].size(); i++) {\n    if(malta[idx][i] < 0) latte[idx][i] = true;\n  }\n\n}\n\n\nint main() {\n  cin >> N;\n  for(int i = 0; i < N; i++) cin >> A[i];\n  for(int i = 1; i < N; i++) {\n    int x, y;\n    cin >> x >> y;\n    --x, --y;\n    g[x].emplace_back(y);\n    g[y].emplace_back(x);\n  }\n  dfs(0, -1);\n  for(int i = 0; i < latte[0].size(); i++) {\n    if(latte[0][i]) {\n      cout << i << endl;\n      exit(0);\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) begin(v),end(v)\n#define fi first\n#define se second\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1; } return 0; }\nusing ll = long long;\nusing pii = pair<int, int>;\nconstexpr ll INF = 1ll<<30;\nconstexpr ll longINF = 1ll<<60;\nconstexpr ll MOD = 1000000007;\nconstexpr bool debug = 0;\n//---------------------------------//\n\nint N;\nint A[5000];\nvector<int> g[5000];\nll dp[5000][5001][2];\nll dp2[5001][2];\n\nint dfs(int u, int par) {\n\tint res = 1;\n\tdp[u][0][A[u] > 0] = A[u];\n\t\n\tfor (int v : g[u]) if (v != par) {\n\t\tint c = dfs(v, u);\n\t\tfill(dp2[0], dp2[res + c], longINF);\n\t\tREP(i, res) {\n\t\t\tREP(j, c) {\n\t\t\t\tREP(k, 2) REP(l, 2) {\n\t\t\t\t\tif (dp[u][i][k] != longINF && dp[v][j][l] != longINF) {\n\t\t\t\t\t\tchmin(dp2[i + j][k == 1 && l == 1], dp[u][i][k] + dp[v][j][l]);\n\t\t\t\t\t\tif (k == 0 && dp[u][i][k] >= 0) continue;\n\t\t\t\t\t\tif (l == 0 && dp[v][j][l] >= 0) continue;\n\t\t\t\t\t\tchmin(dp2[i + j + 1][k], dp[u][i][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(i, res + c) REP(j, 2) dp[u][i][j] = dp2[i][j];\n\t\tres += c;\n\t}\n\treturn res;\n}\n\nint main() {\n\tcin >> N;\n\tREP(i, N) scanf(\"%d\", A + i);\n\tREP(i, N - 1) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\t--u; --v;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\t\n\tfill(dp[0][0], dp[N][0], longINF);\n\tdfs(0, -1);\n\t\n\tint ans = N - 1;\n\tREP(i, N) if (dp[0][i][0] < 0 || dp[0][i][1] != longINF) chmin(ans, i);\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define SORT(a) sort(a.begin(), a.end())\n#define REVERSE(a) reverse(a.begin(), a.end())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define int long long\n#define INF 1000000000000000000\nusing namespace std;\n\n#define ANS(f) if(f) cout << \"YES\" << endl; else cout << \"NO\" << endl;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef pair<int, int> Pii;\n\ntemplate<typename T>\nvoid readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readi(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\nvoid debug(mat m){REP(i, m.size()){ REP(j, m[i].size()){ cout << m[i][j] << \",\"; } cout << endl; }}\n\nstruct edge{int to, cost;};\n\nclass Graph\n{\npublic:\n    int V;\n    vector<vector<edge>> G;\n\n    vec gen, par;\n    mat chi, genlist;\n    int depth;\n\n    Graph(int V): V(V){\n        G = vector<vector<edge>>(V, vector<edge>(0));\n    }\n\n    void add_edge(int from, int to, int cost){\n        G[from].push_back(edge({to, cost}));\n    }\n\n    void add_edge2(int v1, int v2, int cost){\n        add_edge(v1, v2, cost);\n        add_edge(v2, v1, cost);\n    }\n\n    void dfs(int v, int d){\n        gen[v] = d;\n        depth = max(depth, d + 1);\n        REP(k, G[v].size()){\n            if(G[v][k].to == par[v]) continue;\n            par[G[v][k].to] = v;\n            chi[v].push_back(G[v][k].to);\n            dfs(G[v][k].to, d + 1);\n        }\n    }\n\n    mat makegenlist(){\n        REP(v, V) genlist[gen[v]].push_back(v);\n        return genlist;\n    }\n\n    void analyzeTree(int root){\n        gen = vec(V); par = vec(V);\n        chi = mat(V, vec(0));\n        depth = 0;\n        par[root] = -1;\n        dfs(root, 0);\n\n        genlist = mat(depth, vec(0));\n        makegenlist();\n    }\n\n};\n\nsigned main(){\n\n    int N; cin >> N;\n    vec A(N); readv(A);\n    Graph T(N);\n    int U, V;\n    REP(i, N - 1){\n        cin >> U >> V;\n        T.add_edge2(U - 1, V - 1, 0);\n    }\n    T.analyzeTree(0);\n\n    vector<mat> dp(N);\n    vec sz(N, 0);\n    IREP(d, T.depth){\n        for(int v: T.genlist[d]){\n\n            vector<mat> dq(1 + T.chi[v].size());\n\n            sz[v] = 1;\n            dq[0] = mat(2, vec(1, INF));\n            if(A[v] < 0) dq[0][1][0] = A[v];\n            else dq[0][0][0] = A[v];\n            int i0 = 1;\n            for(int chi: T.chi[v]){\n                sz[v] += sz[chi];\n                dq[i0] = mat(2, vec(sz[v], INF));\n                //切る\n                int m = INF;\n                REP(k, sz[chi]){\n                    if(dp[chi][0][k] < INF || dp[chi][1][k] < 0){\n                        m = k;\n                        break;\n                    }\n                }\n                if(m < INF){\n                    REP(k, dq[i0 - 1][0].size()){\n                        dq[i0][0][k + 1 + m] = dq[i0 - 1][0][k];\n                        dq[i0][1][k + 1 + m] = dq[i0 - 1][1][k]; \n                    }\n                }\n                //繫げる         \n                REP(k, sz[v]){\n                    REP(l, min(sz[chi], k + 1)){\n                        if(!(k - l >= 0 && k - l < dq[i0 - 1][0].size())) continue;\n                        if(dp[chi][0][l] < INF && dq[i0 - 1][0][k - l] < INF) dq[i0][0][k] = min(dq[i0][0][k], dp[chi][0][l] + dq[i0 - 1][0][k - l]);\n                        if(dp[chi][1][l] < INF && dq[i0 - 1][1][k - l] < INF) dq[i0][1][k] = min(dq[i0][1][k], dp[chi][1][l] + dq[i0 - 1][1][k - l]);\n                        if(dp[chi][0][l] < INF && dq[i0 - 1][1][k - l] < INF) dq[i0][1][k] = min(dq[i0][1][k], dp[chi][0][l] + dq[i0 - 1][1][k - l]);\n                        if(dp[chi][1][l] < INF && dq[i0 - 1][0][k - l] < INF) dq[i0][1][k] = min(dq[i0][1][k], dp[chi][1][l] + dq[i0 - 1][0][k - l]);\n                    }\n                }\n                i0++;\n            }\n\n            dp[v] = dq[T.chi[v].size()];\n            /*\n            cout << v + 1 << endl;\n            REP(i, sz[v]) cout << dp[v][0][i] << \",\";\n            cout << endl;\n            REP(i, sz[v]) cout << dp[v][1][i] << \",\";\n            cout << endl << endl;*/\n        }\n    }\n    int ans = INF;\n    REP(k, sz[0]){\n        if(dp[0][0][k] < INF || dp[0][1][k] < 0){\n            ans = k;\n            break;\n        }\n    }\n    cout << ans;\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i, a, b) for (int i = (a); i < (b); i++)\n#ifdef tabr\n#include \"library/debug.cpp\"\n#else\n#define debug(...) 0\n#endif\n\nint n;\nvector<ll> a(5100);\nvector<vector<int>> g(5100);\nvector<vector<vector<ll>>> dp(5100, vector<vector<ll>>(5100, vector<ll>(2, 1e18)));\nvector<vector<ll>> tmp(5100, vector<ll>(2, 1e18));\nvector<int> sz(5100, 1);\n\nvoid dfs(int v, int p) {\n    if (g[v].size() == 0) {\n        if (a[v] > 0)\n            dp[v][0][0] = a[v];\n        else\n            dp[v][0][1] = a[v];\n        return;\n    }\n    for (int u : g[v]) {\n        if (u == p) continue;\n        dfs(u, v);\n        sz[v] += sz[u];\n    }\n    int cur = 0;\n    rep(i, 0, n + 1) tmp[i][0] = tmp[i][1] = 1e18;\n    tmp[0][0] = a[v];\n    if (a[v] > 0) tmp[0][1] = a[v];\n    for (int u : g[v]) {\n        if (u == p) continue;\n        for (int i = cur; i >= 0; i--) {\n            ll x = tmp[i][0], y = tmp[i][1];\n            tmp[i][0] = tmp[i][1] = 1e18;\n            rep(k, 0, sz[u] + 1) {\n                tmp[i + k][0] = min(tmp[i + k][0], x + dp[u][k][0]);\n                if (dp[u][k][0] < 0 || dp[u][k][1] < 1e18)\n                    tmp[i + k + 1][0] = min(tmp[i + k + 1][0], x);\n                if (a[v] > 0) {\n                    tmp[i + k][1] = min(tmp[i + k][1], y + dp[u][k][1]);\n                    if (dp[u][k][0] < 0 || dp[u][k][1] < 1e18)\n                        tmp[i + k + 1][1] = min(tmp[i + k + 1][1], y);\n                }\n            }\n        }\n        cur += sz[u];\n    }\n    rep(i, 0, sz[v] + 1) {\n        dp[v][i][0] = tmp[i][0];\n        dp[v][i][1] = tmp[i][1];\n    }\n    return;\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> n;\n    rep(i, 0, n) cin >> a[i];\n    rep(i, 0, n - 1) {\n        int u, v;\n        cin >> u >> v;\n        u--, v--;\n        g[u].emplace_back(v);\n        g[v].emplace_back(u);\n    }\n    dfs(0, -1);\n    rep(i, 0, n) {\n        if (dp[0][i][0] < 0 || dp[0][i][1] < 1e18) {\n            cout << i << endl;\n            return 0;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\n#include <unordered_map>\nusing namespace std;\n\n#define REP(i, s) for (int i = 0; i < s; ++i)\n#define ALL(v) (v.begin(), v.end())\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\ntemplate<class T> ostream& operator << (ostream &s, set<T> P)\n{ EACH(it, P) { s << \"<\" << *it << \"> \"; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P)\n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s << endl; }\n\nconst long long INF = 1LL<<60;\nconst int MAX = 5100;\n\nint N;\nvector<long long> A;\nvector<vector<int> > G;\n\nint num[MAX];\nlong long dp[MAX][MAX][2]; // vの部分木、vを含めず何個か、(全部正かどうか)\nlong long sdp[2][MAX][2];\n\nvoid rec(int v, int p) {\n    int numc = 0;\n    num[v] = 1;\n    for (auto ch : G[v]) {\n        if (ch == p) continue;\n        rec(ch, v);\n        ++numc;\n        num[v] += num[ch];\n    }\n    \n    for (int i = 0; i < 2; ++i) for (int j = 0; j < MAX; ++j)\n        sdp[i][j][0] = sdp[i][j][1] = INF;\n    \n    sdp[0][0][0] = A[v];\n    if (A[v] > 0) sdp[0][0][1] = A[v];\n    \n    int i = 0;\n    for (auto ch : G[v]) {\n        if (ch == p) continue;\n        for (int j = 0; j <= num[v]; ++j) {\n            for (int k = 0; k <= num[ch]; ++k) {\n                chmin(sdp[(i+1)%2][j+k][0], sdp[i%2][j][0] + dp[ch][k][0]);\n                chmin(sdp[(i+1)%2][j+k][0], sdp[i%2][j][0] + dp[ch][k][1]);\n                if (dp[ch][k][0] < 0) chmin(sdp[(i+1)%2][j+k+1][0], sdp[i%2][j][0]);\n                if (dp[ch][k][1] < INF/2) chmin(sdp[(i+1)%2][j+k+1][0], sdp[i%2][j][0]);\n                if (A[v] > 0) {\n                    chmin(sdp[(i+1)%2][j+k][1], sdp[i%2][j][1] + dp[ch][k][1]);\n                    if (dp[ch][k][0] < 0) chmin(sdp[(i+1)%2][j+k+1][1], sdp[i%2][j][1]);\n                    if (dp[ch][k][1] < INF/2) chmin(sdp[(i+1)%2][j+k+1][1], sdp[i%2][j][1]);\n                }\n            }\n        }\n        for (int j = 0; j < MAX; ++j) sdp[i%2][j][0] = sdp[i%2][j][1] = INF;\n        ++i;\n    }\n    for (int j = 0; j <= num[v]; ++j) {\n        dp[v][j][0] = sdp[numc%2][j][0];\n        dp[v][j][1] = sdp[numc%2][j][1];\n        \n        //cout << v << \", \" << j << \": \" << make_pair(dp[v][j][0], dp[v][j][1]) << endl;\n    }\n}\n\nint main() {\n    while (cin >> N) {\n        A.resize(N);\n        for (int i = 0; i < N; ++i) cin >> A[i];\n        G.assign(N, vector<int>());\n        for (int i = 0; i < N-1; ++i) {\n            int u, v; cin >> u >> v; --u, --v;\n            G[u].push_back(v);\n            G[v].push_back(u);\n        }\n        for (int i = 0; i < MAX; ++i) for (int j = 0; j < MAX; ++j)\n            dp[i][j][0] = dp[i][j][1] = INF;\n        rec(0, -1);\n        int res = N;\n        for (int i = 0; i <= N; ++i) {\n            if (dp[0][i][0] < 0) chmin(res, i);\n            if (dp[0][i][1] < INF/2) chmin(res, i);\n        }\n        cout << res << endl;\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <complex>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\nusing namespace std;\n \n#define mod 1000000007\n#define FOR(x,to) for(int x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define long long long\ninline int rei(){int x;cin>>x;return x;}\ninline long rel(){long x;cin>>x;return x;}\ninline string res(){string x;cin>>x;return x;}\n//------------------------------------------------------- \nlong DP1[25000000];\nlong buffer[5000];\nint dp1[5000];\nint DP2[5000];\nint child[5000];\nlong A[5000];\nvector<int> G[5000];\nvoid Calc(){\n\tint N = rei();\n\tfor(int i=0;i<N;i++){\n\t\tA[i] = rel();\n\t}\n\tfor(int i=0;i<N-1;i++){\n\t\tint v = rei()-1;\n\t\tint u = rei()-1;\n\t\tG[v].push_back(u);\n\t\tG[u].push_back(v);\n\t}\n\tstack<pair<int,int>> sp;\n\tsp.push({0,-1});\n\twhile(!sp.empty()){\n\t\tint v = sp.top().first;\n\t\tint f = sp.top().second;\n\t\tsp.pop();\n\t\tif(v >= N){\n\t\t\tv -= N;\n\t\t\tif(A[v] > 0){\n\t\t\t\tint c = 0;\n\t\t\t\tfor(int t:G[v]){\n\t\t\t\t\tif(t != f){\n\t\t\t\t\t\tc += min(DP2[t],dp1[t]+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tDP2[v] = c;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tDP2[v] = 10000;\n\t\t\t}\n\t\t\t{\n\t\t\t\tint ch = 1;\n\t\t\t\tDP1[v*5000] = A[v];\n\t\t\t\tfor(int t:G[v]){\n\t\t\t\t\tif(t != f){\n\t\t\t\t\t\tfor(int i=0;i<ch+child[t];i++){\n\t\t\t\t\t\t\tbuffer[i] = 100000000000000000;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int i=ch-1;i>=0;i--){\n\t\t\t\t\t\t\tbuffer[i+dp1[t]+1] = min(buffer[i],DP1[v*5000+i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int i=ch-1;i>=0;i--){\n\t\t\t\t\t\t\tfor(int j=child[t]-1;j>=0;j--){\n\t\t\t\t\t\t\t\tbuffer[i+j] = min(buffer[i+j],DP1[v*5000+i]+DP1[t*5000+j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int i=0;i<ch+child[t];i++){\n\t\t\t\t\t\t\tDP1[v*5000+i] = buffer[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tch += child[t];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint bf = 0;\n\t\t\t\tint bl = ch-1;\n\t\t\t\twhile(bf != bl){\n\t\t\t\t\tint bc = (bf+bl)/2;\n\t\t\t\t\tif(DP1[v*5000+bc] < 0){\n\t\t\t\t\t\tbl = bc;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tbf = bc+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp1[v] = min(DP2[v],bf);\n\t\t\t\tchild[v] = ch;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tsp.push({v+N,f});\n\t\t\tfor(int t:G[v]){\n\t\t\t\tif(t != f){\n\t\t\t\t\tsp.push({t,v});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp1[0] << endl;\n}\nint main(int argc,char** argv){\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcout.tie(0); Calc(); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define YES() printf(\"YES\\n\")\n#define NO() printf(\"NO\\n\")\n#define Yes() printf(\"Yes\\n\")\n#define No() printf(\"No\\n\")\n#define in(x,y,h,w) x >= 0 && x < h && y >= 0 && y < w\n\n#define int long long\n//using ll = long long;\nusing P = pair<int,int>;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n \nconst int INF=1e+18;\nconst double EPS=1e-9;\nconst int MOD=1000000007;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint n,a[5010],dp[5010][5010][2];\n\nvector<int> G[5010];\n\nint dfs(int v,int par){\n\tdp[v][0][a[v] < 0] = a[v];\n\tint macut = 0;\n\tfor(int to : G[v]){\n\t\tif(to == par) continue;\n\t\tint cut = dfs(to,v),newdp[5010][2];\n\t\tfor(int j = 0;j <= macut + cut + 1;j++) newdp[j][0] = newdp[j][1] = INF;\n\t\tfor(int j = 0;j <= macut;j++){\n\t\t\tfor(int k = 0;k <= cut;k++){\n\t\t\t\tfor(int l = 0;l < 2;l++){\n\t\t\t\t\tfor(int m = 0;m < 2;m++){\n\t\t\t\t\t\tchmin(newdp[j + k][l | m],dp[v][j][l] + dp[to][k][m]);\n\t\t\t\t\t\tif((!m && dp[to][k][m] != INF) || dp[to][k][m] < 0) chmin(newdp[j + k + 1][l],dp[v][j][l]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0;j <= macut + cut + 1;j++){\n\t\t\tdp[v][j][0] = newdp[j][0];\n\t\t\tdp[v][j][1] = newdp[j][1];\n\t\t}\n\t\tmacut += cut + 1;\n\t}\n\treturn macut;\n}\n\nsigned main(){\n\tcin >> n;\n\tfor(int i = 0;i < n;i++) cin >> a[i];\n\tfor(int i = 0;i < n - 1;i++){\n\t\tint u,v;\n\t\tcin >> u >> v; u--;v--;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tfor(int i = 0;i < n;i++){\n\t\tfor(int j = 0;j < n;j++) dp[i][j][0] = dp[i][j][1] = INF;\n\t}\n\tdfs(0,-1);\n\tfor(int i = 0;i < n;i++){\n\t\tif(dp[0][i][0] != INF || dp[0][i][1] < 0){\n\t\t\tcout << i << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <unordered_map>\n#include <unordered_set>\n#include <array>\n// stream\n//#include <istream>\n#include <sstream>\n//#include <ostream>\n#include <fstream>\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n//#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int w_=0; w_<n; ++w_){MACRO_VEC_ROW_Scan(w_, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& R:c)for(auto& w:R)std::cin>>w;\n// output\n#define OUT(dist) std::cout<<(dist);\n#define FOUT(n, dist) std::cout<<std::fixed<<std::setprecision(n)<<(dist);\n#define SOUT(n, c, dist) std::cout<<std::setw(n)<<std::setfill(c)<<(dist);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(w, n) std::cout<<(w + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(dist) {std::cerr << #dist << \"\\t:\" << (dist) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(w, a, n) for(int w=(a);w<(n);++w)\n#define RFOR(w, a, n) for(int w=(n)-1;w>=(a);--w)\n#define REP(w, n) for(int w=0;w<int(n);++w)\n#define RREP(w, n) for(int w=int(n)-1;w>=0;--w)\n#define FORLL(w, a, n) for(ll w=ll(a);w<ll(n);++w)\n#define RFORLL(w, a, n) for(ll w=ll(n)-1;w>=ll(a);--w)\n#define REPLL(w, n) for(ll w=0;w<ll(n);++w)\n#define RREPLL(w, n) for(ll w=ll(n)-1;w>=0;--w)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<class T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<class T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\n//void CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-10;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n// ------------>8------------------------------------->8------------\n\nstd::vector<int> a;\n\n// dp[v][x] := v部分木でx回切断したときのv連結成分のmin\n// dp2[v][x] := v部分木でx回切断したときにv連結成分が全て正のときのmin\n\nstruct Table {\n\tstd::vector<int> dp, dp2;\n\tTable(int sz) : dp(sz, INFLL), dp2(sz, INFLL) {}\n\n\tvoid setRoot(int val) {\n\t\tdp.resize(1, INFLL); dp[0] = val;\n\t\tdp2.resize(1, INFLL);\n\t\tif (val > 0) dp2[0] = val;\n\t}\n\n\tint size() const { return dp.size(); }\n\n\tstatic Table merge(const Table& l, const Table& r) {\n\t\tTable res(l.size() + r.size());\n\n\t\tREP(i, l.size()) REP(j, r.size()) {\n\t\t\tCHMIN(res.dp[i + j], l.dp[i] + r.dp[j]);\n\t\t\tCHMIN(res.dp2[i + j], l.dp2[i] + r.dp2[j]);\n\t\t\tif (r.dp[j] < 0 || r.dp2[j] < INFLL) {\n\t\t\t\tCHMIN(res.dp[i + j + 1], l.dp[i]);\n\t\t\t\tCHMIN(res.dp2[i + j + 1], l.dp2[i]);\n\t\t\t}\n\t\t}\n\n\t\twhile (res.dp.back() == INFLL && res.dp2.back() == INFLL) {\n\t\t\tres.dp.pop_back();\n\t\t\tres.dp2.pop_back();\n\t\t}\n\n\t\treturn res;\n\t}\n};\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n);\n\tVEC(int, a_, n); a = a_;\n\tVEC_ROW(int, n - 1, u_, v_);\n\n\tstd::vector<std::vector<int>> g(n);\n\tREP(i, n - 1) {\n\t\t--u_[i]; --v_[i];\n\t\tg[u_[i]].emplace_back(v_[i]);\n\t\tg[v_[i]].emplace_back(u_[i]);\n\t}\n\n\tauto dfs = [&](auto&& f, int v, int par) -> Table {\n\t\tTable res(0);\n\t\tres.setRoot(a[v]);\n\n\t\tfor (auto& to : g[v]) if (to != par) {\n\t\t\tauto tbl = f(f, to, v);\n\t\t\tres = Table::merge(res, tbl);\n\t\t}\n\t\treturn res;\n\t};\n\tauto tbl = dfs(dfs, 0, -1);\n\n\tREP(i, n) {\n\t\tif (tbl.dp[i] < 0 || tbl.dp2[i] < INFLL) {\n\t\t\tOUT(i)BR;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n//const int MOD = 998244353;\n\nlong long int N, M, K, H, W, L, R;\n//int N, M, K, H, W, L, R;\n\nvoid Calculate_Depth(vector<vector<int>>&edge, vector<int>&depth, int stnode) {\n\tdepth[stnode] = 0;\n\tqueue<int>Q;\n\tQ.push(stnode);\n\twhile (!Q.empty()) {\n\t\tint cn = Q.front();\n\t\tQ.pop();\n\t\tfor (auto i : edge[cn]) {\n\t\t\tif (depth[i] > depth[cn] + 1) {\n\t\t\t\tdepth[i] = depth[cn] + 1;\n\t\t\t\tQ.push(i);\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nvoid Search(vector<vector<long long int>>&m_min, vector<vector<long long int>>&p_all, vector<int>&max_num, int node, vector<vector<int>>&edge, vector<int>&depth, vector<int>&v) {\n\tif (v[node] > 0)p_all[node][0] = v[node];\n\telse m_min[node][0] = v[node];\n\tmax_num[node] = 0;\n\t//cout << node << endl;\n\t//cout << m_all[node][0] << \" \" << p_min[node][0] << endl;\n\tfor (auto i : edge[node]) {\n\t\tif (depth[i] < depth[node])continue;\n\t\t//cout << node << \" \" << i << endl;\n\t\tSearch(m_min, p_all, max_num, i, edge, depth, v);\n\t//\tcout << node << \" \" << i << endl;\n\t\tvector<long long int>box_m_min(max_num[node] + max_num[i] + 2, MOD*MOD);\n\t\tvector<long long int>box_p_all(max_num[node] + max_num[i] + 2, MOD*MOD);\n\t\tfor (int j = 0; j <= max_num[node]; j++) {\n\t\t\tfor (int k = 0; k <= max_num[i]; k++) {\n\t\t\t\tbox_m_min[j + k] = min(box_m_min[j + k], m_min[node][j] + m_min[i][k]);\n\t\t\t\tif (p_all[i][k] != MOD * MOD)box_m_min[j + k] = min(box_m_min[j + k], m_min[node][j] + p_all[i][k]);\n\t\t\t\tif (p_all[node][j] != MOD * MOD)box_m_min[j + k] = min(box_m_min[j + k], p_all[node][j] + m_min[i][k]);\n\t\t\t\tif (p_all[node][j] != MOD * MOD&&p_all[i][k] != MOD * MOD)box_p_all[j + k] = min(box_p_all[j + k], p_all[node][j] + p_all[i][k]);\n\t\t\t\tif (m_min[i][k] < 0 || p_all[i][k] != MOD * MOD) {\n\t\t\t\t//\tcout << \"hi \" << node << \" \" << i << \" \" << j << \" \" << k << endl;\n\t\t\t\t\tbox_m_min[j + k + 1] = min(box_m_min[j + k + 1], m_min[node][j]);\n\t\t\t\t//\tcout << j + k + 1 << \" \" << box_m_min[j + k + 1] << endl;\n\t\t\t\t\tif (p_all[node][j] != MOD * MOD)box_p_all[j + k + 1] = min(box_p_all[j + k + 1], p_all[node][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmax_num[node] += max_num[i] + 1;\n\t\tm_min[node] = box_m_min;\n\t\tp_all[node] = box_p_all;\n\t}\n\treturn;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<int>v(N);\n\tfor (auto &i : v)cin >> i;\n\tvector<vector<long long int>>m_min(N, vector<long long int>(N, MOD*MOD));\n\tvector<vector<long long int>>p_all(N, vector<long long int>(N, MOD*MOD));\n\tvector<int>max_num(N);\n\tvector<vector<int>>edge(N);\n\tfor (int i = 1; i < N; i++) {\n\t\tcin >> L >> R;\n\t\tL--;\n\t\tR--;\n\t\tedge[L].push_back(R);\n\t\tedge[R].push_back(L);\n\t}\n\tvector<int>depth(N, MOD);\n\tCalculate_Depth(edge, depth, 0);\n\tSearch(m_min, p_all, max_num, 0, edge, depth, v);\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t//\t\tcout << i << \" \" << j << \" \" << m_min[i][j] << \" \" << p_all[i][j] << endl;\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tif (m_min[0][i] < 0 || p_all[0][i] != MOD * MOD) {\n\t\t\tcout << i << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define all(vec) vec.begin(), vec.end()\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\nconst ll INF = 1LL << 30;\nconst ll LINF = 1LL << 60;\nconst double eps = 1e-9;\nconst ll MOD = 998244353LL;\ntemplate <typename T>\nvoid chmin(T& a, T b) {\n    a = min(a, b);\n};\ntemplate <typename T>\nvoid chmax(T& a, T b) {\n    a = max(a, b);\n};\ntemplate <typename T>\nvector<T> make_v(size_t a) {\n    return vector<T>(a);\n}\ntemplate <typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\ntemplate <typename T, typename V>\ntypename enable_if<is_class<T>::value == 0>::type fill_v(T& t, const V& v) {\n    t = v;\n}\ntemplate <typename T, typename V>\ntypename enable_if<is_class<T>::value != 0>::type fill_v(T& t, const V& v) {\n    for(auto& e : t) {\n        fill_v(e, v);\n    }\n};\nint n;\nvector<ll> a;\nvector<int> siz;\nvector<vector<int>> G;\nvector<vector<vector<ll>>> dp;\nvoid dfs(int i, int p) {\n    dp[i].resize(n + 10);\n    for(int j = 0; j < n + 10; j++) {\n        dp[i][j].resize(2, LINF);\n    }\n    int nn = G[i].size() - 1;\n    if(i == 0) {\n        nn++;\n    }\n    auto f = make_v<ll>(nn + 10, n + 10, 2);\n    fill_v(f, LINF);\n    f[0][0][0] = 0;\n    f[0][0][1] = 0;\n    int id = 1;\n    for(auto e : G[i]) {\n        if(e == p) {\n            continue;\n        }\n        dfs(e, i);\n        siz[i] += siz[e];\n        for(int j = 0; j <= siz[i]; j++) {\n            for(int k = max(0, j - siz[e]); k <= j; k++) {\n                // eを使う\n                if(dp[e][j - k][0] != LINF) {\n                    chmin(f[id][j][0], f[id - 1][k][0] + dp[e][j - k][0]);\n                    chmin(f[id][j][1], f[id - 1][k][1] + dp[e][j - k][0]);\n                }\n                if(dp[e][j - k][1] != LINF) {\n                    chmin(f[id][j][1], f[id - 1][k][0] + dp[e][j - k][1]);\n                }\n                // eを切り離す\n                if(k < j &&\n                   (dp[e][j - k - 1][0] != LINF || dp[e][j - k - 1][1] < 0)) {\n                    chmin(f[id][j][0], f[id - 1][k][0]);\n                    chmin(f[id][j][1], f[id - 1][k][1]);\n                }\n            }\n        }\n        id++;\n    }\n    for(int j = 0; j <= siz[i]; j++) {\n        if(a[i] > 0 && f[nn][j][0] != LINF) {\n            dp[i][j][0] = f[nn][j][0] + a[i];\n        }\n        if(f[nn][j][1] != LINF) {\n            dp[i][j][1] = f[nn][j][1] + a[i];\n        }\n    }\n}\nint main() {\n    cin >> n;\n    a.resize(n);\n    G.resize(n);\n    dp.resize(n);\n    siz.resize(n, 1);\n    for(int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n    for(int i = 0; i < n - 1; i++) {\n        int u, v;\n        cin >> u >> v;\n        --u;\n        --v;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    dfs(0, -1);\n    for(int i = 0; i <= n; i++) {\n        if(dp[0][i][0] != LINF || dp[0][i][1] < 0) {\n            cout << i << endl;\n            return 0;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <stack>\n#include <tuple>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <iomanip>\n\n#define int long long int\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() )\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int INF = 1e15;\nconst int MOD = 1e9+7;\n\nint n;\nvector<int> a, child;\nvector<vector<int>> edge, sub;\nvector<vector<vector<int>>> dp;\n\nvoid dfs(int v, int par){\n    if(a[v] > 0){\n        dp[v][0][0] = a[v];\n    }else{\n        dp[v][0][1] = a[v];\n    }\n\n    child[v] = 1;\n\n    for(int u : edge[v]){\n        if(u == par){\n            continue;\n        }\n        dfs(u, v);\n        for(int i = 0; i < child[v]; i++){\n            for(int j = 0; j < child[u]; j++){\n                rep(k1, 2) rep(k2, 2){\n                    sub[i+j][k1|k2] = min(sub[i+j][k1|k2], dp[v][i][k1] + dp[u][j][k2]);\n                    if(k2 == 0 && dp[u][j][k2] < INF || dp[u][j][k2] < 0){\n                        sub[i+j+1][k1] = min(sub[i+j+1][k1], dp[v][i][k1]);\n                    }\n                }\n\n            }\n        }\n        child[v] += child[u];\n        for(int i = 0; i < child[v]; i++){\n            rep(k, 2){\n                dp[v][i][k] = sub[i][k];\n                sub[i][k] = INF;\n            }\n        }\n    }\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    cin >> n;\n    a = vector<int>(n + 1);\n    rep(i, n) cin >> a[i+1];\n\n    edge = vector<vector<int>>(n + 1, vector<int>());\n    rep(i, n - 1){\n        int u, v;\n        cin >> u >> v;\n        edge[u].push_back(v);\n        edge[v].push_back(u);\n    }\n\n    dp = vector<vector<vector<int>>>(n + 1, vector<vector<int>>(n + 1, vector<int>(2, INF)));\n    sub = vector<vector<int>>(n + 1, vector<int>(2, INF));\n    child = vector<int>(n + 1);\n    dfs(1, 0);\n\n    int ans = INF;\n    rep(i, n + 1){\n        if(dp[1][i][0] != INF){\n            ans = min(ans, i);\n        }\n        if(dp[1][i][1] < 0){\n            ans = min(ans, i);\n        }\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cassert>\n#include<cmath>\n#include<climits>\n#include<iomanip>\n#include<stack>\n#include<unordered_map>\n#include<bitset>\n#include<limits>\n#include<complex>\n#include<array>\n#include<numeric>\n#include<functional>\n\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rrep(i,m,n) for(ll (i)=(ll)(m);(i)>=(ll)(n);(i)--)\n#define rep(i,m,n) for(ll (i)=(ll)(m);i<(ll)(n);i++)\n#define REP(i,n) rep(i,0,n)\n#define FOR(i,c) for(decltype((c).begin())i=(c).begin();i!=(c).end();++i)\n#define all(hoge) (hoge).begin(),(hoge).end()\ntypedef pair<ll, ll> P;\nconstexpr long double m_pi = 3.1415926535897932L;\nconstexpr ll MOD = 1000000007;\nconstexpr ll INF = 1LL << 61;\nconstexpr long double EPS = 1e-10;\ntemplate<typename T> using vector2 = vector<vector<T>>;\ntemplate<typename T> using vector3 = vector<vector2<T>>;\ntypedef vector<ll> Array;\ntypedef vector<Array> Matrix;\nstring operator*(const string& s, int k) {\n\tif (k == 0) return \"\";\n\tstring p = (s + s) * (k / 2);\n\tif (k % 2 == 1) p += s;\n\treturn p;\n}\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstruct Edge {//グラフ\n\tint to, rev; ll cap;\n\tEdge(int _to, ll _cap, int _rev) {\n\t\tto = _to; cap = _cap; rev = _rev;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid add_edge(Graph& G, int from, int to, ll cap, bool revFlag, ll revCap) {//最大フロー求める Ford-fulkerson\n\tG[from].push_back(Edge(to, cap, (ll)G[to].size()));\n\tif (revFlag)G[to].push_back(Edge(from, revCap, (ll)G[from].size() - 1));//最小カットの場合逆辺は0にする\n}\n\nll max_flow_dfs(Graph& G, ll v, ll t, ll f, vector<bool>& used)\n{\n\tif (v == t)\n\t\treturn f;\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\tEdge& e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tll d = max_flow_dfs(G, e.to, t, min(f, e.cap), used);\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n//二分グラフの最大マッチングを求めたりも出来る　また二部グラフの最大独立集合は頂点数-最大マッチングのサイズ\nll max_flow(Graph& G, ll s, ll t)//O(V(V+E))\n{\n\tll flow = 0;\n\tfor (;;) {\n\t\tvector<bool> used(G.size());\n\t\tREP(i, used.size())used[i] = false;\n\t\tll f = max_flow_dfs(G, s, t, INF, used);\n\t\tif (f == 0) {\n\t\t\treturn flow;\n\t\t}\n\t\tflow += f;\n\t}\n}\nvoid BellmanFord(Graph& G, ll s, Array& d, Array& negative) {//O(|E||V|)\n\td.resize(G.size());\n\tnegative.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\tREP(i, d.size())negative[i] = false;\n\td[s] = 0;\n\tREP(k, G.size() - 1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tREP(k, G.size() - 1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t\tnegative[G[i][j].to] = true;\n\t\t\t\t}\n\t\t\t\tif (negative[i] == true)negative[G[i][j].to] = true;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid Dijkstra(Graph& G, ll s, Array& d) {//O(|E|log|V|)\n\td.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\td[s] = 0;\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(make_pair(0, s));\n\twhile (!q.empty()) {\n\t\tP a = q.top();\n\t\tq.pop();\n\t\tif (d[a.second] < a.first)continue;\n\t\tREP(i, G[a.second].size()) {\n\t\t\tEdge e = G[a.second][i];\n\t\t\tif (d[e.to] > d[a.second] + e.cap) {\n\t\t\t\td[e.to] = d[a.second] + e.cap;\n\t\t\t\tq.push(make_pair(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid WarshallFloyd(Graph& G, Matrix& d) {//O(V^3)\n\td.resize(G.size());\n\tREP(i, d.size())d[i].resize(G.size());\n\tREP(i, d.size()) {\n\t\tREP(j, d[i].size()) {\n\t\t\td[i][j] = ((i != j) ? INF : 0);\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G[i].size()) {\n\t\t\tchmin(d[i][G[i][j].to], G[i][j].cap);\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G.size()) {\n\t\t\tREP(k, G.size()) {\n\t\t\t\tchmin(d[j][k], d[j][i] + d[i][k]);\n\t\t\t}\n\t\t}\n\t}\n}\nbool tsort(Graph& graph, Array& order) {//トポロジカルソートO(E+V)\n\tint n = graph.size(), k = 0;\n\tArray in(n);\n\tfor (auto& es : graph)\n\t\tfor (auto& e : es)in[e.to]++;\n\tpriority_queue<ll, Array, greater<ll>> que;\n\tREP(i, n)\n\t\tif (in[i] == 0)que.push(i);\n\twhile (que.size()) {\n\t\tint v = que.top();\n\t\tque.pop();\n\t\torder.push_back(v);\n\t\tfor (auto& e : graph[v])\n\t\t\tif (--in[e.to] == 0)que.push(e.to);\n\t}\n\tif (order.size() != n)return false;\n\telse return true;\n}\nclass Lca {\npublic:\n\tconst int n = 0;\n\tconst int log2_n = 0;\n\tstd::vector<std::vector<int>> parent;\n\tstd::vector<int> depth;\n\n\tLca() {}\n\n\tLca(const Graph& g, int root)\n\t\t: n(g.size()), log2_n(log2(n) + 1), parent(log2_n, std::vector<int>(n)), depth(n) {\n\t\tdfs(g, root, -1, 0);\n\t\tfor (int k = 0; k + 1 < log2_n; k++) {\n\t\t\tfor (int v = 0; v < (int)g.size(); v++) {\n\t\t\t\tif (parent[k][v] < 0)\n\t\t\t\t\tparent[k + 1][v] = -1;\n\t\t\t\telse\n\t\t\t\t\tparent[k + 1][v] = parent[k][parent[k][v]];\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dfs(const Graph& g, int v, int p, int d) {\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\tfor (auto& e : g[v]) {\n\t\t\tif (e.to != p) dfs(g, e.to, v, d + 1);\n\t\t}\n\t}\n\n\tint get(int u, int v) {\n\t\tif (depth[u] > depth[v]) std::swap(u, v);\n\t\tfor (int k = 0; k < log2_n; k++) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v) return u;\n\t\tfor (int k = log2_n - 1; k >= 0; k--) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n};\nvoid visit(const Graph& g, int v, vector<vector<int>>& scc, stack<int>& S, vector<int>& inS, vector<int>& low,vector<int>& num, int& time) {\n\tlow[v] = num[v] = ++time;\n\tS.push(v); inS[v] = true;\n\tFOR(e, g[v]) {\n\t\tint w = e->to;\n\t\tif (num[w] == 0) {\n\t\t\tvisit(g, w, scc, S, inS, low, num, time);\n\t\t\tlow[v] = min(low[v], low[w]);\n\t\t}\n\t\telse if (inS[w])\n\t\t\tlow[v] = min(low[v], num[w]);\n\t}\n\tif (low[v] == num[v]) {\n\t\tscc.push_back(vector<int>());\n\t\twhile (1) {\n\t\t\tint w = S.top(); S.pop(); inS[w] = false;\n\t\t\tscc.back().push_back(w);\n\t\t\tif (v == w) break;\n\t\t}\n\t}\n}\nvoid stronglyConnectedComponents(const Graph& g, vector<vector<int>>& scc) {//強連結成分分解 O(E+V)\n\tconst int n = g.size();\n\tvector<int> num(n), low(n);\n\tstack<int> S;\n\tvector<int> inS(n);\n\tint time = 0;\n\tREP(u, n) if (num[u] == 0)\n\t\tvisit(g, u, scc, S, inS, low, num, time);\n}\n\nclass UnionFind {\n\tvector<int> data;\n\tll num;\npublic:\n\tUnionFind(int size) : data(size, -1), num(size) { }\n\tbool unite(int x, int y) {//xとyの集合を統合する\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\tnum -= (x != y);\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {//xとyが同じ集合か返す\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {//xのルートを返す\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tll size(int x) {//xの集合のサイズを返す\n\t\treturn -data[root(x)];\n\t}\n\tll numSet() {//集合の数を返す\n\t\treturn num;\n\t}\n};\n\ntemplate<typename T, typename F>\nclass SegmentTree {\nprivate:\n\tT identity;\n\tF merge;\n\tll n;\n\tvector<T> dat;\npublic:\n\tSegmentTree(F f, T id,vector<T> v) :merge(f), identity(id) {\n\t\tint _n = v.size();\n\t\tn = 1;\n\t\twhile (n < _n)n *= 2;\n\t\tdat.resize(2 * n - 1, identity);\n\t\tREP(i, _n)dat[n + i - 1] = v[i];\n\t\tfor (int i = n - 2; i >= 0; i--)dat[i] = merge(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t}\n\tSegmentTree(F f, T id, int _n) :merge(f), identity(id) {\n\t\tn = 1;\n\t\twhile (n < _n)n *= 2;\n\t\tdat.resize(2 * n - 1, identity);\n\t}\n\tvoid set_val(int i, T x) {\n\t\ti += n - 1;\n\t\tdat[i] = x;\n\t\twhile (i > 0) {\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] = merge(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t\t}\n\t}\n\tT query(int l, int r) {\n\t\tT left = identity, right = identity;\n\t\tl += n - 1; r += n - 1;\n\t\twhile (l < r) {\n\t\t\tif ((l & 1) == 0)left = merge(left, dat[l]);\n\t\t\tif ((r & 1) == 0)right = merge(dat[r - 1], right);\n\t\t\tl = l / 2;\n\t\t\tr = (r - 1) / 2;\n\t\t}\n\t\treturn merge(left, right);\n\t}\n};\nclass SumSegTree {\npublic:\n\tll n, height;\n\tvector<ll> dat;\n\n\t// 初期化（_nは最大要素数）\n\tSumSegTree(ll _n) {\n\t\tn = 1;\n\t\theight = 1;\n\t\twhile (n < _n) {\n\t\t\tn *= 2;\n\t\t\theight++;\n\t\t}\n\t\tdat = vector<ll>(2 * n - 1, 0);\n\t}\n\n\t// 場所i(0-indexed)にxを足す\n\tvoid add(ll i, ll x) {\n\t\ti += n - 1; // i番目の葉ノードへ\n\t\tdat[i] += x;\n\t\twhile (i > 0) { // 下から上がっていく\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] += x;\n\t\t}\n\t}\n\t// 区間[l,r)の総和\n\tll sum(ll l, ll r) {\n\t\tll ret = 0;\n\t\tl += n - 1; r += n - 1;\n\t\twhile (l < r) {\n\t\t\tif ((l & 1) == 0)ret += dat[l];\n\t\t\tif ((r & 1) == 0)ret += dat[r - 1];\n\t\t\tl = l / 2;\n\t\t\tr = (r - 1) / 2;\n\t\t}\n\t\treturn ret;\n\t}\n};\nclass RmqTree {\nprivate:\n\n\tll _find(ll a, ll b, ll k, ll l, ll r) {\n\t\tif (r <= a || b <= l)return INF;    // 交差しない\n\t\tif (a <= l && r <= b)return dat[k];   // a,l,r,bの順で完全に含まれる\n\t\telse {\n\t\t\tll s1 = _find(a, b, 2 * k + 1, l, (l + r) / 2); // 左の子\n\t\t\tll s2 = _find(a, b, 2 * k + 2, (l + r) / 2, r); // 右の子\n\t\t\treturn min(s1, s2);\n\t\t}\n\t}\npublic:\n\tll n, height;\n\tvector<ll> dat;\n\n\t// 初期化（_nは最大要素数）\n\tRmqTree(ll _n) {\n\t\tn = 1;\n\t\theight = 1;\n\t\twhile (n < _n) {\n\t\t\tn *= 2;\n\t\t\theight++;\n\t\t}\n\t\tdat = vector<ll>(2 * n - 1, INF);\n\t}\n\n\t// 場所i(0-indexed)をxにする\n\tvoid update(ll i, ll x) {\n\t\ti += n - 1; // i番目の葉ノードへ\n\t\tdat[i] = x;\n\t\twhile (i > 0) { // 下から上がっていく\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] = min(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t\t}\n\t}\n\n\t// 区間[a,b)の最小値。ノードk=[l,r)に着目している。\n\tll find(ll a, ll b) {\n\t\treturn _find(a, b, 0, 0, n);\n\t}\n};\n\n\n//約数求める //約数\nvoid divisor(ll n, vector<ll>& ret) {\n\tfor (ll i = 1; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back(i);\n\t\t\tif (i * i != n) ret.push_back(n / i);\n\t\t}\n\t}\n\tsort(ret.begin(), ret.end());\n}\n\nvoid prime_factorization(ll n, vector<P>& ret) {\n\tfor (ll i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back({ i,0 });\n\t\t\twhile (n % i == 0) {\n\t\t\t\tn /= i;\n\t\t\t\tret[ret.size() - 1].second++;\n\t\t\t}\n\t\t}\n\t}\n\tif (n != 1)ret.push_back({ n,1 });\n}\n\n\nll mod_pow(ll x, ll n, ll mod) {\n\tll res = 1;\nwhile (n > 0) {\n\tif (n & 1) res = res * x % mod;\n\tx = x * x % mod;\n\tn >>= 1;\n}\nreturn res;\n}\n\nll mod_inv(ll x, ll mod) {\n\treturn mod_pow(x, mod - 2, mod);\n}\n//nCrとか\nclass Combination {\npublic:\n\tArray fact;\n\tArray inv;\n\tll mod;\n\tll mod_inv(ll x) {\n\t\tll n = mod - 2LL;\n\t\tll res = 1LL;\n\t\twhile (n > 0) {\n\t\t\tif (n & 1) res = res * x % mod;\n\t\t\tx = x * x % mod;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\t//if n >= mod use lucas \n\tll nCr(ll n, ll r) {\n\t\tif (n < r)return 0;\n\t\tif (n < mod)return ((fact[n] * inv[r] % mod) * inv[n - r]) % mod;\n\n\t\tll ret = 1;\n\t\twhile (n || r) {\n\t\t\tll _n = n % mod, _r = r % mod;\n\t\t\tn /= mod; r /= mod;\n\t\t\t(ret *= nCr(_n, _r)) %= mod;\n\t\t}\n\t\treturn ret;\n\t}\n\tll nPr(ll n, ll r) {\n\t\treturn (fact[n] * inv[n - r]) % mod;\n\t}\n\tll nHr(ll n, ll r) {\n\t\treturn nCr(r + n - 1, r);\n\t}\n\tCombination(ll _n, ll _mod) {\n\t\tmod = _mod;\n\t\tll n = min(_n + 1, mod);\n\t\tfact.resize(n);\n\t\tfact[0] = 1;\n\t\tREP(i, n - 1) {\n\t\t\tfact[i + 1] = (fact[i] * (i + 1LL)) % mod;\n\t\t}\n\t\tinv.resize(n);\n\t\tinv[n - 1] = mod_inv(fact[n - 1]);\n\t\tfor (int i = n - 1; i > 0; i--) {\n\t\t\tinv[i - 1] = inv[i] * i % mod;\n\t\t}\n\t}\n};\n\nll popcount(ll x) {\n\tx = (x & 0x5555555555555555) + (x >> 1 & 0x5555555555555555);\n\tx = (x & 0x3333333333333333) + (x >> 2 & 0x3333333333333333);\n\tx = (x & 0x0F0F0F0F0F0F0F0F) + (x >> 4 & 0x0F0F0F0F0F0F0F0F);\n\tx = (x & 0x00FF00FF00FF00FF) + (x >> 8 & 0x00FF00FF00FF00FF);\n\tx = (x & 0x0000FFFF0000FFFF) + (x >> 16 & 0x0000FFFF0000FFFF);\n\tx = (x & 0x00000000FFFFFFFF) + (x >> 32 & 0x00000000FFFFFFFF);\n\n\treturn x;\n}\n\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\tll n;\n\tcin >> n;\n\tArray a(n);\n\tREP(i, n)cin >> a[i];\n\tGraph g(n);\n\tREP(i, n - 1) {\n\t\tll a, b; cin >> a >> b;\n\t\ta--; b--;\n\t\tadd_edge(g, a, b, 1, true, 1);\n\t}\n\n\tauto solve = [&](auto solve, ll x, ll par)->Matrix {\n\t\tMatrix v(1, Array(2, INF));\n\t\tif (a[x] > 0)v[0][0] = a[x];\n\t\telse v[0][1] = a[x];\n\t\tfor (auto e : g[x]) {\n\t\t\tif (e.to == par)continue;\n\t\t\tauto u = solve(solve, e.to, x);\n\t\t\tMatrix dp(v.size()+u.size(), Array(2, INF));\n\t\t\tREP(i, v.size()) REP(incv, 2) {\n\t\t\t\tif (v[i][incv] == INF)continue;\n\t\t\t\tREP(j, u.size()) REP(incu, 2) {\n\t\t\t\t\tif (u[j][incu] == INF)continue;\n\t\t\t\t\t//cutしないとき\n\t\t\t\t\tll inc = (incv | incu);\n\t\t\t\t\tll cut = i + j;\n\t\t\t\t\tchmin(dp[cut][inc], v[i][incv] + u[j][incu]);\n\t\t\t\t\t//cutするとき\n\t\t\t\t\tif (incu == 1 && u[j][incu] >= 0)continue;\n\t\t\t\t\tinc = incv;\n\t\t\t\t\tcut++;\n\t\t\t\t\tchmin(dp[cut][inc], v[i][incv]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(v, dp);\n\t\t}\n\t\treturn v;\n\t};\n\tMatrix dp = solve(solve, 0, -1);\n\tll ans = INF;\n\tREP(i, dp.size()) {\n\t\tif (dp[i][0] != INF)chmin(ans, i);\n\t\tif (dp[i][1] < 0)chmin(ans, i);\n\t}\n\tcout << ans << \"\\n\";\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fr(i,n) for(int i=0;i<(n);++i)\n#define foor(i,a,b) for(int i=(a);i<=(b);++i)\n#define rf(i,n) for(int i=(n);i-->0;)\n#define roof(i,b,a) for(int i=(b);i>=(a);--i)\n#define elsif else if\n#define all(x) x.begin(),x.end()\n#define Sort(x) sort(all(x))\n#define Reverse(x) reverse(all(x))\n#define PQ priority_queue\n#define NP(x) next_permutation(all(x))\n#define M_PI 3.14159265358979323846\n#define popcount __builtin_popcountll\nusing namespace std;            typedef vector<bool> vb; typedef vector<vb>  vvb;\n                                typedef vector<int>  vi; typedef vector<vi>  vvi;\ntypedef long long ll;           typedef vector< ll>  vl; typedef vector<vl>  vvl;\ntypedef unsigned long long ull; typedef vector<ull>  vu; typedef vector<vu>  vvu;\ntypedef double dbl;             typedef vector<dbl>  vd; typedef vector<vd>  vvd;\ntypedef string str;             typedef vector<str>  vs; typedef vector<vs>  vvs;\ntypedef pair<int,int>pii;       typedef vector<pii>vpii; typedef map<int,int>mii;\ntypedef pair< ll, ll>pll;       typedef vector<pll>vpll; typedef map< ll, ll>mll;\ntypedef pair<dbl,dbl>pdd;       typedef vector<pdd>vpdd; typedef map<dbl,dbl>mdd;\ntypedef pair<str,str>pss;       typedef vector<pss>vpss; typedef map<str,str>mss;\ntypedef pair<int, ll>pil;       typedef vector<pil>vpil; typedef map<int, ll>mil;\ntypedef pair< ll,int>pli;       typedef vector<pli>vpli; typedef map< ll,int>mli;\ntypedef pair<dbl,int>pdi;       typedef vector<pdi>vpdi; typedef map<dbl,int>mdi;\ntemplate<typename T>vector<T>&operator<<(vector<T>&v,const T t){v.push_back(t);return v;}\ntemplate<typename T>multiset<T>&operator<<(multiset<T>&m,const T t){m.insert(t);return m;}\ntemplate<typename T>set<T>&operator<<(set<T>&s,const T t){s.insert(t);return s;}\ntemplate<typename T>stack<T>&operator<<(stack<T>&s,const T t){s.push(t);return s;}\ntemplate<typename T>stack<T>&operator>>(stack<T>&s,T&t){t=s.top();s.pop();return s;}\ntemplate<typename T>queue<T>&operator<<(queue<T>&q,const T t){q.push(t);return q;}\ntemplate<typename T>queue<T>&operator>>(queue<T>&q,T&t){t=q.front();q.pop();return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator<<(PQ<T,vector<T>,U>&q,const T t){q.push(t);return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator>>(PQ<T,vector<T>,U>&q,T&t){t=q.top();q.pop();return q;}\ntemplate<typename T,typename U>istream&operator>>(istream&s,pair<T,U>&p){return s>>p.first>>p.second;}\nistream&operator>>(istream&s,_Bit_reference b){int a;s>>a;assert(a==0||a==1);b=a;return s;}\ntemplate<typename T>istream&operator>>(istream&s,vector<T>&v){fr(i,v.size()){s>>v[i];}return s;}\ntemplate<typename T,typename U>ostream&operator<<(ostream&s,const pair<T,U>p){return s<<p.first<<\" \"<<p.second;}\n//template<typename T>ostream&operator<<(ostream&s,const vector<T>v){for(auto a:v){s<<a<<\"\\n\";}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const vector<T>v){fr(i,v.size()){i?s<<\" \"<<v[i]:s<<v[i];}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const deque<T>d){fr(i,d.size()){i?s<<\" \"<<d[i]:s<<d[i];}return s;}\ntemplate<typename T>_Bit_reference operator&=(_Bit_reference b,T t){return b=b&t;}\ntemplate<typename T>_Bit_reference operator^=(_Bit_reference b,T t){return b=b^t;}\ntemplate<typename T>_Bit_reference operator|=(_Bit_reference b,T t){return b=b|t;}\ntemplate<typename T,typename U>pair<T,U>operator+(pair<T,U>a,pair<T,U>b){return {a.first+b.first,a.second+b.second};}\ntemplate<typename T,typename U>pair<T,U>operator-(pair<T,U>a,pair<T,U>b){return {a.first-b.first,a.second-b.second};}\ntemplate<typename T,typename U>pair<T,U>&operator+=(pair<T,U>&a,pair<T,U>b){return a=a+b;}\ntemplate<typename T,typename U>pair<T,U>&operator-=(pair<T,U>&a,pair<T,U>b){return a=a-b;}\nvoid print(void){cout<<\"\\n\";}\nvoid Print(void){cout<<endl;}\ntemplate<typename T>void print(T t){cout<<t<<\"\\n\";}\ntemplate<typename T>void Print(T t){cout<<t<<endl;}\ntemplate<typename T,typename...U>void print(T&&t,U&&...u){cout<<t<<\" \";print(forward<U>(u)...);}\ntemplate<typename T,typename...U>void Print(T&&t,U&&...u){cout<<t<<\" \";Print(forward<U>(u)...);}\nbool YN(bool b){print(b?\"YES\":\"NO\");return b;}bool PI(bool b){print(b?\"POSSIBLE\":\"IMPOSSIBLE\");return b;}\nbool Yn(bool b){print(b?\"Yes\":\"No\");return b;}bool Pi(bool b){print(b?\"Possible\":\"Impossible\");return b;}\nbool yn(bool b){print(b?\"yes\":\"no\");return b;}bool pi(bool b){print(b?\"possible\":\"impossible\");return b;}\nconst int e5=1e5;\nconst int e9=1e9;\nconst int MD=1e9+7;\nconst int md=998244353;\nconst ll e18=1e18;\ntemplate<typename T>str to_string(const T&n){ostringstream s;s<<n;return s.str();}\ntemplate<typename T>T&chmax(T&a,T b){return a=max(a,b);}\ntemplate<typename T>T&chmin(T&a,T b){return a=min(a,b);}\ntemplate<typename T,typename U>vector<pair<T,U>>dijkstra(const vector<vector<pair<T,U>>>&E,const U s,const T inf){using P=pair<T,U>;vector<P>d;fr(i,E.size()){d<<P{inf,i};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\ntemplate<typename T,typename U>map<U,pair<T,U>>dijkstra(map<U,vector<pair<T,U>>>E,const U s,const T inf){using P=pair<T,U>;map<U,P>d;for(pair<U,vector<P>>e:E){d[e.first]=P{inf,e.first};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\nll maxflow(vector<mil>&E,int s,int t){ll z=0;vi b(E.size(),-1);for(int i=0;;++i){static auto dfs=[&](int v,ll f,auto&dfs)->ll{if(v==t)return f;b[v]=i;for(auto&p:E[v]){if(b[p.first]<i&&p.second){if(ll r=dfs(p.first,min(f,p.second),dfs)){p.second-=r;E[p.first][v]+=r;return r;}}}return 0;};ll x=dfs(s,ll(1e18),dfs);z+=x;if(x==0)return z;}}\ntemplate<typename T>T distsq(pair<T,T>a,pair<T,T>b){return (a.first-b.first)*(a.first-b.first)+(a.second-b.second)*(a.second-b.second);}\ntemplate<typename T>T max(const vector<T>a){assert(a.size());T m=a[0];for(T e:a){m=max(m,e);}return m;}\ntemplate<typename T>T min(const vector<T>a){assert(a.size());T m=a[0];for(T e:a){m=min(m,e);}return m;}\ntemplate<typename T>T gcd(const T a,const T b){return a?gcd(b%a,a):b;}\ntemplate<typename T>T gcd(const vector<T>a){T g=a[0];for(T e:a){g=gcd(g,e);}return g;}\ntemplate<typename T>vector<T>LCS(vector<T>A,vector<T>B){int N=A.size(),M=B.size();vector<vector<pair<int,pii>>>d(N+1,vector<pair<int,pii>>(M+1));fr(i,N){fr(j,M){if(A[i]==B[j]){d[i+1][j+1]={d[i][j].first+1,{i,j}};}else{d[i+1][j+1]=max(d[i][j+1],d[i+1][j]);}}}vector<T>r;for(pii p={N,M};d[p.first][p.second].first;p=d[p.first][p.second].second){r<<A[d[p.first][p.second].second.first];}Reverse(r);return r;}\nstr LCS(str S,str T){vector<char>s=LCS(vector<char>(S.begin(),S.end()),vector<char>(T.begin(),T.end()));return str(s.begin(),s.end());}\ntemplate<typename T>vector<pair<T,T>>ConvexHull(vector<pair<T,T>>V){if(V.size()<=3){return V;}Sort(V);rf(i,V.size()-1)V<<V[i];vector<pair<T,T>>r;for(pair<T,T>p:V){int s=r.size();while(s>=2&&(p.second-r[s-1].second)*(p.first-r[s-2].first)<(p.second-r[s-2].second)*(p.first-r[s-1].first)){r.pop_back();--s;}r<<p;}r.pop_back();return r;}\nclass UnionFind{vi p,s;void extend(int N){foor(i,p.size(),N){p<<i;s<<1;}}public:UnionFind(void){}UnionFind(int N){extend(N-1);}int find(int i){extend(i);return p[i]=p[i]==i?i:find(p[i]);}void unite(int a,int b){extend(a);extend(b);if((a=find(a))!=(b=find(b))){if(s[a]>s[b]){swap(a,b);}s[b]+=s[a];p[a]=b;}}void unite(pii p){return unite(p.first,p.second);}bool same(int a,int b){extend(a);extend(b);return find(a)==find(b);}bool same(pii p){return same(p.first,p.second);}int size(int x){extend(x);return s[find(x)];}};\nll MST(vector<pair<ll,pii>>&E){Sort(E);UnionFind uf;ll z=0;for(auto&e:E){if(!uf.same(e.second)){z+=e.first;uf.unite(e.second);}}return z;}\nll strmod(const str&s,const int m){ll x=0;fr(i,s.size()){x=(x*10+s[i]-48)%m;}return x;}\nvvl mul(const vvl&A,const vvl&B,const int m){vvl C;fr(y,A.size()){C<<vl(B[y].size());}fr(y,C.size()){fr(x,C[y].size()){fr(i,A[0].size()){(C[y][x]+=A[y][i]*B[i][x])%=m;}}}return C;}\nvvl pow(const vvl&A,const ll n,const int m){vvl B;fr(y,A.size()){B<<vl(A.size());}if(n==0){fr(i,B.size()){B[i][i]=1;}}elsif(n%2){B=mul(A,pow(A,n-1,m),m);}else{vvl C=pow(A,n/2,m);B=mul(C,C,m);}return B;}\nll pow(const ll a,const ll n,const int m){ll t;return n?(n&1?a>=0?a%m:(m-(-a%m))%m:1)*(t=pow(a,n>>1,m),t*t%m)%m:!!a;}\nll inv(const ll x,const int p){assert(x!=0);return pow(x,p-2,p);}\nll inv(const ll x){return inv(x,MD);}\nvpll fact(const int n,const int p){assert(n<p);vpll v(n+1);v[0].first=1;foor(i,1,n){v[i].first=v[i-1].first*i%p;}v[n].second=inv(v[n].first,p);roof(i,n,1){v[i-1].second=v[i].second*i%p;}return v;}\nclass Combination{const vpll f;const int M;public:Combination(int n,int m):f(fact(n,m)),M(m){}Combination(int n):Combination(n,MD){}ll P(int n,int k){return n<0||k<0||n<k?0ll:f[n].first*f[n-k].second%M;}ll C(int n,int k){return k<0?0:P(n,k)*f[k].second%M;}ll H(int n,int k){return n==0&&k==0?1ll:C(n+k-1,k);}ll F(int n){return n<0?0:f[n].first;}};\nll C2(const int n){return(ll)n*~-n/2;}\nll sum(const vi a){ll s=0;for(int e:a){s+=e;}return s;}\nll sum(const vl a){ll s=0;for(ll e:a){s+=e;}return s;}\ntemplate<typename T>int MSB(T N){int r=-1;for(;N>0;N/=2){++r;}return r;}\ntemplate<typename T>class SegmentTree{vector<T>S;T(*const op)(T a,T b);const T zero;const int B;public:SegmentTree(int N,T(*f)(T a,T b),const T zero):S(1<<MSB(N-1)+2,zero),op(f),zero(zero),B(1<<MSB(N-1)+1){}SegmentTree(vector<T>v,T(*f)(T a,T b),const T zero):SegmentTree(v.size(),f,zero){fr(i,v.size()){S[S.size()/2+i]=v[i];}roof(i,S.size()/2-1,1){S[i]=op(S[i*2],S[i*2+1]);}}T calc(int l,int r){l+=B;r+=B;if(l>r){return zero;}if(l==r){return S[l];}T L=S[l],R=S[r];for(;l/2<r/2;l/=2,r/=2){if(l%2==0){L=op(L,S[l+1]);}if(r%2==1){R=op(S[r-1],R);}}return op(L,R);}void replace(int i,T x){for(S[i+=B]=x;i!=1;i/=2){if(i%2){S[i/2]=op(S[i-1],S[i]);}else{S[i/2]=op(S[i],S[i+1]);}}}void add(int i,T x){replace(i,op(S[B+i],x));}T top(){return S[1];}T get(int i){return S[i+B];}};\nll BITsum(vl&B,int i){ll z=0;while(i>0){z+=B[i];i-=i&-i;}return z;}\nvoid BITadd(vl&B,int i,ll x){while(i<B.size()){B[i]+=x;i+=i&-i;}}\nll fib(const ll n,const int m){ll a,b,c,d,A,B,C,D;a=1;b=0;c=0;d=1;rf(i,63){A=a*a+b*c;B=a*b+b*d;C=c*a+d*c;D=c*b+d*d;if(n>>i&1){a=A;b=B;c=C;d=D;A=a+b;B=a;C=c+d;D=c;}a=A%m;b=B%m;c=C%m;d=D%m;}return b;}\nvi primes(int n){vb b(n+1);vi p;foor(i,2,n){if(!b[i]){p<<i;for(int j=2*i;j<=n;j+=i){b[j]=true;}}}return p;}\nvb isprime(const int n){vb v(n+1,true);v[0]=v[1]=false;foor(i,2,n){if(v[i]){for(int j=2*i;j<=n;j+=i){v[j]=false;}}}return v;}\nclass LCA{vvi par;vi dep;public:LCA(vvi&E,int root):par(MSB(E.size())+1,vi(E.size())),dep(E.size()){function<void(int,int)>dfs=[&](int i,int p){for(int j:E[i])if(j!=p){par[0][j]=i;dep[j]=dep[i]+1;dfs(j,i);}};par[0][root]=root;dfs(root,root);fr(i,par.size()-1){fr(j,par[0].size()){par[i+1][j]=par[i][par[i][j]];}}}int operator()(int a,int b){if(dep[a]>dep[b])swap(a,b);for(int t=dep[b]-dep[a],i=0;t;t>>=1,++i){if(t&1){b=par[i][b];}}if(a==b)return a;rf(i,par.size()){if(par[i][a]!=par[i][b]){a=par[i][a];b=par[i][b];}}return par[0][a];}};\nvpli factor(ll N){vpli r;for(ll i=2;i*i<=N;++i){if(N%i==0){r<<pli{i,0};while(N%i==0){N/=i;++r.back().second;}}}if(N>1){r<<pli{N,1};}return r;}\nvl divisors(ll n){vl r;ll m=sqrt(n);foor(i,1,m)if(n%i==0)r<<ll(i);rf(i,r.size()-(m*m==n))r<<n/r[i];return r;}\nvi SuffixArray(str S){int N=S.size();vi rank(N+1),tmp(N+1),sa(N+1);fr(i,N){sa[i]=i;rank[i]=S[i];}sa[N]=N;rank[N]=-1;int k;auto cmp=[&](int&a,int&b)->bool{if(rank[a]!=rank[b])return rank[a]<rank[b];return (a+k<=N?rank[a+k]:-1)<(b+k<=N?rank[b+k]:-1);};for(k=1;k<=N;k*=2){sort(all(sa),cmp);tmp[sa[0]]=0;foor(i,1,N){tmp[sa[i]]=tmp[sa[i-1]]+cmp(sa[i-1],sa[i]);}rank=tmp;}return sa;};\n\nint main(){cin.tie(0);ios::sync_with_stdio(false);\n\tint N;cin>>N;\n\tvi V(N);cin>>V;\n\tvvi E(N);\n\t{\n\t\tUnionFind uf;\n\t\tvi A(N-1),B(N-1);\n\t\tfr(i,N-1){\n\t\t\tcin>>A[i]>>B[i];\n\t\t\tint a=--A[i],b=--B[i];\n\t\t\tif(V[a]<0&&V[b]<0){\n\t\t\t\tint a=uf.find(a),b=uf.find(b);\n\t\t\t\tint v=V[a]+V[b];\n\t\t\t\tuf.unite(a,b);\n\t\t\t\tV[uf.find(a)]=v;\n\t\t\t\tV[a+b-uf.find(a)]=0;\n\t\t\t}\n\t\t}\n\t\tfr(i,N-1){\n\t\t\tint a=uf.find(A[i]),b=uf.find(B[i]);\n\t\t\tif(a!=b){\n\t\t\t\tE[a]<<b;\n\t\t\t\tE[b]<<a;\n\t\t\t}\n\t\t}\n\t}\n \treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define fi first\n#define se second\n#define pb push_back\n#define rep(i, s, n) for (int i = s; i < n; i++)\n#define rrep(i, s, n) for (int i = (n)-1; i >= (s); i--)\n#define all(a) a.begin(),a.end()\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\nconst long long MOD = 1000000007, INF = 1e17;\ntemplate<class T>inline bool chmax(T& a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<class T>inline bool chmin(T& a,T b){if(a>b){a=b;return true;}return false;}\nstring get_str(string s) {\n\ts+=',';\n\tstring ret=\"\";\n\tfor(int i=0; i<s.size(); i++) {\n\t\tif(s[i]==',') ret+=\"=%ld, \";\n\t\telse ret+=s[i];\n\t}\n\treturn ret;\n}\n#define dump(...) printf(get_str(#__VA_ARGS__).c_str(),__VA_ARGS__);cout<<endl\n \n#define endl '\\n'\n#define IOS()                     \\\n\tios_base::sync_with_stdio(0); \\\n\tcin.tie(0)\n template<typename T>vector<T>\nmake_v(size_t a){return vector<T>(a);}\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n\treturn vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n \ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value==0>::type\nfill_v(T &t,const V &v){t=v;}\n \ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t,const V &v){\n\tfor(auto &e:t) fill_v(e,v);\n}\n//******************************************************************************\n\nint N,MINF=1e17;\nvint a;\nvint g[5050];\n\n\nvector<vector<int>>dfs(int now,int par){\n\tauto dp = make_v<int>(2,2);\n\tfill_v(dp,INF);\n\tdp[0][0] = a[now];\n\tif(a[now]>0)dp[0][1] = a[now];\n\tfor(auto e:g[now]){\n\t\tif(e==par)continue;\n\t\tauto tmp = dfs(e,now);\n\t\tint n = dp.size();\n\t\tint m = tmp.size();\n\t\tauto new_dp = make_v<int>(n+m-1,2);\n\t\tfill_v(new_dp,INF);\n\t\trep(i,0,n){\n\t\t\trep(j,0,m){\n\t\t\t\trep(k,0,2){\n\t\t\t\t\trep(l,0,2){\n\t\t\t\t\t\tchmin(new_dp[i+j][k&l],dp[i][k]+tmp[j][l]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(i+j+1>=n+m-1)continue;\n\t\t\t\tif(tmp[j][0]<0){\n\t\t\t\t\tchmin(new_dp[i+j+1][0],dp[i][0]);\n\t\t\t\t\tchmin(new_dp[i+j+1][1],dp[i][1]);\n\t\t\t\t}\n\t\t\t\tif(tmp[j][1]<INF/2){\n\t\t\t\t\tchmin(new_dp[i+j+1][0],dp[i][0]);\n\t\t\t\t\tchmin(new_dp[i+j+1][1],dp[i][1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdp = new_dp;\n\t}\n\treturn dp;\n}\n\nsigned main()\n{\n\t//IOS();\n\tcin>>N;\n\ta.resize(N);\n\tfor(int i = 0;i < N;i++){\n\t\tcin>>a[i];\n\t}\n\trep(i,0,N-1){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\ta--;b--;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\tauto dp = dfs(0,-1);\n\tint ans = INF;\n\trep(j,0,N+1){\n\t\tif(dp[j][1]<INF/2)chmin(ans,j);\n\t\tif(dp[j][0]<=0)chmin(ans,j);\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const ll inf = 1e18;const double INF = 1e12, EPS = 1e-9;\n\nusing VL = vector<ll>;\nusing VVL = vector<VL>;\nint n, a[5000];\nvector<vi> e;\n\nconst VVL rec(int c, int p){\n\tVVL dp(1, VL(2, inf));\n\tdp[0][a[c] < 0] = a[c];\n\t\n\tfor(int cld : e[c]) if(cld != p){\n\t\tconst VVL& tmp = rec(cld, c);\n\t\tVVL next(dp.size() + tmp.size(), VL(2, inf));\n\t\t\n\t\trep(i, tmp.size()) rep(j, 2) if(tmp[i][j] < inf)\n\t\trep(k, dp.size()) rep(l, 2) if(dp[k][l] < inf){\n\t\t\t\n\t\t\tnext[i + k][j | l] = min(next[i + k][j | l], tmp[i][j] + dp[k][l]);\n\t\t\tif(j == 0 || tmp[i][j] < 0) next[i + k + 1][l] = min(next[i + k + 1][l], dp[k][l]);\n\t\t}\n\t\t\n\t\tdp.swap(next);\n\t}\n\treturn dp;\n}\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tcin >> n; e.resize(n);\n\trep(i, n) cin >> a[i];\n\trep(i, n - 1){\n\t\tint u, v; cin >> u >> v; u--; v--;\n\t\te[u].pb(v);\n\t\te[v].pb(u);\n\t}\n\tconst VVL& ans = rec(0, 0);\n\tint res = n - 1;\n\trep(i, ans.size()) rep(j, ans[i].size()) if(ans[i][j] < inf) if(j == 0 || ans[i][j] < 0) res = min(res, i);\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst long double EPS=1e-9;\nconst long double PI=acos(-1.0);\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\nlong double ABS(long double a){return max(a,-a);}\nint c[5100];\nvector<int>g[5100];\nlong long dp[5100][5100];\nlong long dp3[5100][5100];\nint dp2[5100];\nint SZ[5100];\nvoid dfs(int a,int b){\n\tint sz=0;\n\tSZ[a]=1;\n\tfor(int i=0;i<g[a].size();i++){\n\t\tif(b==g[a][i])continue;\n\t\tdfs(g[a][i],a);\n\t\tsz++;\n\t\tSZ[a]+=SZ[g[a][i]];\n\t}\n\tif(sz==0){\n\t\tif(c[a]>0){\n\t\t\tdp2[a]=0;\n\t\t\tdp[a][0]=c[a];\n\t\t}else{\n\t\t\tdp[a][0]=c[a];\n\t\t}\n\t\treturn;\n\t}\n\tfor(int i=0;i<=sz;i++)\n\t\tfor(int j=0;j<5100;j++)\n\t\t\tdp3[i][j]=mod;\n\tdp3[0][0]=c[a];\n\tint ind=0;\n\tint cur=0;\n\tfor(int i=0;i<g[a].size();i++){\n\t\tif(b==g[a][i])continue;\n\t\tfor(int j=0;j<=cur;j++){\n\t\t\tfor(int k=0;k<SZ[g[a][i]];k++){\n\t\t\t\tdp3[ind+1][j+k]=min(dp3[ind+1][j+k],dp3[ind][j]+dp[g[a][i]][k]);\n\t\t\t\tif(dp[g[a][i]][k]<0)dp3[ind+1][j+k+1]=min(dp3[ind+1][j+k+1],dp3[ind][j]);\n\t\t\t}\n\t\t\tif(c[g[a][i]]>0)dp3[ind+1][j+dp2[g[a][i]]+1]=min(dp3[ind+1][j+dp2[g[a][i]]+1],dp3[ind][j]);\n\t\t\t\n\t\t}\n\t\tcur+=SZ[g[a][i]];\n\t\tind++;\n\t}\n\tfor(int i=0;i<=cur;i++){\n\t\tdp[a][i]=dp3[ind][i];\n\t}\n\tif(c[a]>0){\n\t\tdp2[a]=0;\n\t\tfor(int i=0;i<g[a].size();i++){\n\t\t\tif(b==g[a][i])continue;\n\t\t\tint tmp=mod;\n\t\t\tfor(int j=0;j<5100;j++){\n\t\t\t\tif(dp[g[a][i]][j]<0){\n\t\t\t\t\ttmp=j+1;break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(c[g[a][i]]>0){\n\t\t\t\ttmp=min(tmp,dp2[g[a][i]]);\n\t\t\t}\n\t\t\tdp2[a]+=tmp;\n\t\t}\n\t}\n}\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tfor(int i=0;i<a;i++)scanf(\"%d\",c+i);\n\tfor(int i=0;i<a-1;i++){\n\t\tint p,q;scanf(\"%d%d\",&p,&q);p--;q--;\n\t\tg[p].push_back(q);\n\t\tg[q].push_back(p);\n\t}\n\tfor(int i=0;i<a;i++)for(int j=0;j<=a;j++)for(int k=0;k<2;k++)\n\t\tdp[i][j]=inf;\n\tfor(int i=0;i<a;i++)dp2[i]=mod;\n\tdfs(0,-1);\n\tint ret=dp2[0];\n\tfor(int i=0;i<5100;i++)if(dp[0][i]<0){\n\t\tret=min(ret,i);\n\t}\n\tprintf(\"%d\\n\",ret);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<unordered_map>\n#include<functional>\n#include<map>\n#include<iomanip>\n#include<limits>\n#include<unordered_set>\n#include<cmath>\n#include <numeric>\n#include <array>\n#include<utility>\n#include <complex>\nusing namespace std;\n#pragma region define\n#define M_PI 3.141592653589793238\n#define upperbound(v,val) upper_bound(v.begin(),v.end(),val)-v.begin()\n#define lowerbound(v,val) lower_bound(v.begin(),v.end(),val)-v.begin()\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp(a,b) make_pair(a,b)\n#define pin pair<int,int>\n#define qin pair<pin,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define fcout cout << fixed << setprecision(15)\n#define rev(s) reverse(s.begin(),s.end())\n#define lower(h,val) (lower_bound(h.begin(),h.end(),val)-h.begin())\n#define upper(h,val) (upper_bound(h.begin(),h.end(),val)-h.begin())\n#define vveb V<veb>\n#define omajinai cin.tie(0);ios::sync_with_stdio(false);\n#define endl \"\\n\"\n#define pb push_back\n#pragma endregion\n#pragma region Inner Class\nint root(int x, vel& pa) {\n\tif (pa[x] == -1) { return x; }\n\tint ans = root(pa[x], pa); pa[x] = ans;\n\treturn ans;\n}\nbool mar(int x, int y, vel& pa) {\n\tx = root(x, pa);\n\ty = root(y, pa);\n\tif (x != y) { pa[x] = y; }\n\treturn (x != y);\n}\nint gcd(int x, int y) {\n\tif (x < y) { return gcd(y, x); }\n\tif (y == 0) { return x; }\n\treturn gcd(y, x % y);\n}\nint lcm(int x, int y) {\n\tx = abs(x); y = abs(y);\n\treturn x * (y / gcd(x, y));\n}\nlong long modinv(long long a, long long m) {\n\tlong long b = m, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= m;\n\tif (u < 0) u += m;\n\treturn u;\n}\nvel dijk(V<V<pin>> way, int st, int inf) {\n\tint n = way.size();\n\tvel dist(n, inf); dist[st] = 0;\n\tpriority_queue<pin, vector<pin>, greater<pin>> pq;\n\tpq.push(mkp(0, st));\n\tveb is_checked(n, false);\n\twhile (!pq.empty()) {\n\t\tpin x = pq.top(); pq.pop();\n\t\tint pot = x.second;\n\t\tif (!is_checked[pot]) {\n\t\t\tis_checked[pot] = true;\n\t\t\tfor (auto y : way[pot]) {\n\t\t\t\tint nex_dist = x.first + y.second;\n\t\t\t\tint nex_pot = y.first;\n\t\t\t\tif (dist[nex_pot] > nex_dist) {\n\t\t\t\t\tdist[nex_pot] = nex_dist;\n\t\t\t\t\tpq.push(mkp(nex_dist, y.first));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\nV<V<pin>> make_w(vvel v) {\n\tint n = v.size();\n\tV<V<pin>> ret(n);\n\trep(i, n) {\n\t\tfor (int x : v[i]) {\n\t\t\tret[i].push_back(mkp(x, 1));\n\t\t}\n\t}\n\treturn ret;\n}\nvoid make_tree(vvel& chi, vel& par, int n) {\n\tV<V<pin>> way(n);\n\trep(i, n - 1) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tway[a].push_back(mkp(b, 1));\n\t\tway[b].push_back(mkp(a, 1));\n\t}\n\tvel dist = dijk(way, 0, n + 1);\n\tpar = vel(n, -1);\n\tchi = vvel(n);\n\trep(i, n) {\n\t\tfor (auto nex : way[i]) {\n\t\t\tint pot = nex.first;\n\t\t\tif (dist[pot] > dist[i]) { chi[i].push_back(pot); }\n\t\t\telse { par[i] = pot; }\n\t\t}\n\t}\n}\nvoid pri(vel& v) {\n\tif (v.size() == 0) { return; }\n\tcout << v[0];\n\trep(i, v.size() - 1) { cout << \" \" << v[i + 1]; }\n\tcout << endl;\n\treturn;\n}\nvvel disj_min(vel& v) {\n\tint n = v.size();\n\tvvel ret(22, vel(n));\n\tret[0] = v;\n\trep(i, 21) {\n\t\trep(j, n) {\n\t\t\tint nex = j + (1 << i);\n\t\t\tif (nex < n) {\n\t\t\t\tret[i + 1][j] = min(ret[i][j], ret[i][nex]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tret[i + 1][j] = ret[i][j];\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint find_min(vvel& dv, int l, int r) {\n\tint i = 21;\n\twhile (l + (1 << i) > r) {\n\t\ti--;\n\t}\n\twhile (i >= 0) {\n\t\tif (dv[i][l] > dv[i][r - (1 << i)]) {\n\t\t\tl = r - (1 << i);\n\t\t}\n\t\telse {\n\t\t\tr = l + (1 << i);\n\t\t}\n\t\ti--;\n\t}\n\treturn l;\n}\nV<V<pin>> dbl(V<pin>& v) {\n\tV<V<pin>> ans(20, V<pin>(v));\n\tint n = v.size();\n\trep(i, 19) {\n\t\trep(j, n) {\n\t\t\tans[i + 1][j].first = ans[i][ans[i][j].first].first;\n\t\t\tans[i + 1][j].second = max(ans[i][j].second, ans[i][ans[i][j].first].second);\n\t\t}\n\t}\n\treturn ans;\n}\nint lca(int s, int t, int diff, V<V<pin>>& pa) {\n\tif (diff < 0) { return lca(t, s, -diff, pa); }\n\tint ans = 0;\n\trep(i, 19) {\n\t\tif ((diff & (1 << i)) != 0) {\n\t\t\tmmax(ans, pa[i][s].second);\n\t\t\ts = pa[i][s].first;\n\t\t}\n\t}\n\tfor (int i = 19; i >= 0; i--) {\n\t\tif (pa[i][s] != pa[i][t]) {\n\t\t\tmmax(ans, pa[i][s].second);\n\t\t\ts = pa[i][s].first;\n\t\t\tmmax(ans, pa[i][t].second);\n\t\t\tt = pa[i][t].first;\n\t\t}\n\t}\n\tif (s != t) {\n\t\tmmax(ans, pa[0][s].second);\n\t\tmmax(ans, pa[0][t].second);\n\t}\n\treturn ans;\n}\nvoid alp(int n, vel& pr) {\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tpr.push_back(i);\n\t\t\twhile (n % i == 0) { n /= i; }\n\t\t}\n\t}\n\tif (n != 1) { pr.push_back(n); }\n}\nvel dx = { 0,0,-1,1,1,-1 };\nvel dy = { 1,-1,0,0,1,1 };\n#define all(a) a.begin(),a.end()\ntemplate<typename T>\nvoid mk_uni(V<T>& a) {\n\tstd::sort(a.begin(), a.end());\n\ta.erase(std::unique(a.begin(), a.end()), a.end());\n}\ntemplate <std::uint_fast64_t Modulus> class modint {\n\tusing u64 = std::uint_fast64_t;\n\npublic:\n\tu64 a;\n\n\tconstexpr modint(const u64 x = 0) noexcept : a(x% Modulus) {}\n\tconstexpr u64& value() noexcept { return a; }\n\tconstexpr const u64& value() const noexcept { return a; }\n\tconstexpr modint operator+(const modint rhs) const noexcept {\n\t\treturn modint(*this) += rhs;\n\t}\n\tconstexpr modint operator-(const modint rhs) const noexcept {\n\t\treturn modint(*this) -= rhs;\n\t}\n\tconstexpr modint operator*(const modint rhs) const noexcept {\n\t\treturn modint(*this) *= rhs;\n\t}\n\tconstexpr modint operator/(const modint rhs) const noexcept {\n\t\treturn modint(*this) /= rhs;\n\t}\n\tconstexpr modint& operator+=(const modint rhs) noexcept {\n\t\ta += rhs.a;\n\t\tif (a >= Modulus) {\n\t\t\ta -= Modulus;\n\t\t}\n\t\treturn *this;\n\t}\n\tconstexpr modint& operator-=(const modint rhs) noexcept {\n\t\tif (a < rhs.a) {\n\t\t\ta += Modulus;\n\t\t}\n\t\ta -= rhs.a;\n\t\treturn *this;\n\t}\n\tconstexpr modint& operator*=(const modint rhs) noexcept {\n\t\ta = a * rhs.a % Modulus;\n\t\treturn *this;\n\t}\n\tconstexpr modint& operator/=(modint rhs) noexcept {\n\t\tu64 exp = Modulus - 2;\n\t\twhile (exp) {\n\t\t\tif (exp % 2) {\n\t\t\t\t*this *= rhs;\n\t\t\t}\n\t\t\trhs *= rhs;\n\t\t\texp /= 2;\n\t\t}\n\t\treturn *this;\n\t}\n};\n#pragma endregion\n//using mint = modint<998244353>;\nusing mint = modint<1000000007>;\nusing vem = vector<mint>;\nusing vvem = vector<vem>;\n#pragma region mint\nmint mpow(mint a, int n) {\n\tmint ans = 1;\n\twhile (n) {\n\t\tif (n & 1) { ans *= a; }\n\t\ta *= a; n /= 2;\n\t}\n\treturn ans;\n}\nvem kai, inv_kai;\nvoid make_kai(int n) {\n\tkai = vem(n + 1, 1);\n\tinv_kai = vem(n + 1, 1);\n\trep(i, n) { kai[i + 1] = kai[i] * (i + 1); }\n\tinv_kai[n] = (mint)1 / kai[n];\n\tfor (int i = n; i > 0; i--) { inv_kai[i - 1] = inv_kai[i] * i; }\n}\nmint com(int n, int r) {\n\tif (n < 0 || r < 0 || n < r) { return 0; }\n\treturn kai[n] * inv_kai[r] * inv_kai[n - r];\n}\nmint per(int n, int r) {\n\tif (n < 0 || r < 0 || n < r) { return 0; }\n\treturn kai[n] * inv_kai[r];\n}\n#pragma endregion\nint inf;\nvvel dp;\nvel con;\nvel conv(vel& a, vel& b) {\n\tint sa = a.size();\n\tint sb = b.size();\n\tvel c(sa + sb - 1, inf*1e10);\n\trep(i, sa) {\n\t\trep(j, sb) {\n\t\t\tmmin(c[i + j], a[i] + b[j]);\n\t\t}\n\t}\n\treturn c;\n}\nvoid sol(int pot, vel& a, vvel& chi) {\n\tif (a[pot] > 0) {\n\t\tcon[pot] = 0;\n\t}\n\tdp[pot] = { a[pot] };\n\tfor (auto nex : chi[pot]) {\n\t\tsol(nex, a, chi);\n\t\tif (a[pot] > 0) { con[pot] += con[nex]; }\n\t\tdp[pot] = conv(dp[pot], dp[nex]);\n\t}\n\tbool fl = false;\n\tdp[pot].push_back(inf * 1e10);\n\tif (a[pot] > 0) {\n\t\tmmin(dp[pot][con[pot] + 1], (int)0);\n\t}\n\tint sz = dp[pot].size();\n\trep(i,sz) {\n\t\tif (fl) { mmin(dp[pot][i], (int)0); mmin(con[pot], i);}\n\t\tif (dp[pot][i] < 0) { fl = true; }\n\t}\n}\nsigned main() {\n\tomajinai;\n\tint n; cin >> n;\n\tvel a(n);\n\trep(i, n) { cin >> a[i]; }\n\tvel pa(n, -1);\n\tvvel chi(n);\n\tmake_tree(chi, pa, n);\n\tinf = n + 2;\n\tdp=vvel(n);\n\tcon=vel(n, inf);\n\tsol(0, a,chi);\n\tint ans = con[0];\n\trep(i, n + 1) {\n\t\tif (dp[0][i] < 0) { mmin(ans, i); }\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n)  for(long long i=0;i<(long long)(n);i++)\n#define REP(i,k,n) for(long long i=k;i<(long long)(n);i++)\n#define all(a) a.begin(),a.end()\n#define pb push_back\n#define eb emplace_back\n#define lb(v,k) (lower_bound(all(v),k)-v.begin())\n#define ub(v,k) (upper_bound(all(v),k)-v.begin())\n#define fi first\n#define se second\n#define pi M_PI\n#define PQ(T) priority_queue<T>\n#define SPQ(T) priority_queue<T,vector<T>,greater<T>>\n#define dame(a) {out(a);return 0;}\n#define decimal cout<<fixed<<setprecision(15);\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef tuple<ll,ll,ll> PP;\ntypedef tuple<ll,ll,ll,ll> PPP;\ntypedef multiset<ll> S;\nusing vi=vector<ll>;\nusing vvi=vector<vi>;\nusing vvvi=vector<vvi>;\nusing vp=vector<P>;\nusing vvp=vector<vp>;\nusing vb=vector<bool>;\nusing vvb=vector<vb>;\nconst ll inf=1001001001001001001;\nconst int INF=1001001001;\nconst int mod=998244353;\nconst double eps=1e-10;\ntemplate<class T> bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<class T> bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<class T> void out(T a){cout<<a<<'\\n';}\ntemplate<class T> void outp(T a){cout<<'('<<a.fi<<','<<a.se<<')'<<'\\n';}\ntemplate<class T> void outvp(T v){rep(i,v.size())cout<<'('<<v[i].fi<<','<<v[i].se<<')';cout<<'\\n';}\ntemplate<class T> void outvvp(T v){rep(i,v.size())outvp(v[i]);}\ntemplate<class T> void outv(T v){rep(i,v.size()){if(i)cout<<' ';cout<<v[i];}cout<<'\\n';}\ntemplate<class T> void outvv(T v){rep(i,v.size())outv(v[i]);}\ntemplate<class T> bool isin(T x,T l,T r){return (l)<=(x)&&(x)<=(r);}\ntemplate<class T> void yesno(T b){if(b)out(\"yes\");else out(\"no\");}\ntemplate<class T> void YesNo(T b){if(b)out(\"Yes\");else out(\"No\");}\ntemplate<class T> void YESNO(T b){if(b)out(\"YES\");else out(\"NO\");}\ntemplate<class T> void noyes(T b){if(b)out(\"no\");else out(\"yes\");}\ntemplate<class T> void NoYes(T b){if(b)out(\"No\");else out(\"Yes\");}\ntemplate<class T> void NOYES(T b){if(b)out(\"NO\");else out(\"YES\");}\nvoid outs(ll a,ll b){if(a>=inf-100)out(b);else out(a);}\nll gcd(ll a,ll b){if(b==0)return a;return gcd(b,a%b);}\nll modpow(ll a,ll b){a%=mod;if(b==0)return 1;if(b&1)return a*modpow(a,b-1)%mod;ll k=modpow(a,b/2);return k*k%mod;}\nvi val,sz;\nvvi g,dp,dp1;\nvoid dfs(int v,int p){\n    sz[v]=1;\n    for(ll x:g[v])if(x!=p){\n        dfs(x,v);\n        sz[v]+=sz[x];\n    }\n    vi sdp(1),sdp1(1);\n    sdp[0]=val[v];\n    if(val[v]>0)sdp1[0]=1;\n    for(ll x:g[v])if(x!=p){\n        vi ndp(sdp.size()+sz[x],inf),ndp1(sdp.size()+sz[x]);\n        rep(i,sdp.size())rep(j,sz[x]){\n            chmin(ndp[i+j],sdp[i]+dp[x][j]);\n            if(dp1[x][j]||dp[x][j]<0)chmin(ndp[i+j+1],sdp[i]);\n            if(sdp1[i]){\n                if(dp[x][j]<0||dp1[x][j])ndp1[i+j+1]=1;\n                if(dp1[x][j])ndp1[i+j]=1;\n            }\n        }\n        sdp=ndp;\n        sdp1=ndp1;\n    }\n    /*vi sdp(sz[v]+1,inf),sdp1(sz[v]+1);\n    sdp[0]=val[v];\n    if(val[v]>0)sdp1[0]=1;\n    int cur=0;\n    for(ll x:g[v])if(x!=p){\n        for(int j=cur;j>=0;j--){\n            ll t=sdp[j],t1=sdp1[j];\n            sdp[j]=inf;sdp1[j]=0;\n            rep(k,sz[x]+1){\n                chmin(sdp[j+k],t+dp[x][k]);\n                if(dp[x][k]<0||dp1[x][k])chmin(sdp[j+k+1],t);\n                if(val[v]>0&&t1){\n                    if(dp1[x][k])sdp1[j+k]=1;\n                    if(dp[x][k]<0||dp1[x][k])sdp1[j+k+1]=1;\n                }\n            }\n        }\n        cur+=sz[x];\n    }*/\n    rep(j,sz[v]+1){\n        dp[v][j]=sdp[j];\n        dp1[v][j]=sdp1[j];\n    }\n}\nint main(){\n    ll n;cin>>n;\n    val=vi(n);\n    sz=vi(n);\n    dp1=vvi(n,vi(n+1,inf));\n    dp=vvi(n,vi(n+1));\n    rep(i,n)cin>>val[i];\n    g=vvi(n);\n    rep(i,n-1){\n        ll a,b;cin>>a>>b;a--;b--;\n        g[a].pb(b);\n        g[b].pb(a);\n    }\n    dfs(0,-1);\n    ll ans=n;\n    rep(i,n)if(dp[0][i]<0||dp1[0][i])chmin(ans,i);\n    out(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nvector <int> g[5555];\nlong long dp[5005][5005];\nlong long fn[5005][5005];\nbool gn[5005][5005];\nbool pos[5005][5005];\n\nint sub[5555];\nint a[5555];\n\nconst long long inf = 1e15;\n\nvoid dfs(int x, int par) {\n\tsub[x] = 1;\n\tfor(auto i : g[x]) {\n\t\tif(i - par) {\n\t\t\tdfs(i, x);\n\t\t\tsub[x] += sub[i];\n\t\t}\n\t}\n\tvector <int> c;\n\tint deg = 0;\n\tfor(auto i : g[x]) {\n\t\tif(i - par) {\n\t\t\tc.emplace_back(i);\n\t\t\t++deg;\n\t\t}\n\t}\n\tfor(int i = 1; i <= deg; i++) {\n\t\tfor(int j = 0; j <= sub[x]; j++) {\n\t\t\tfn[i][j] = inf;\n\t\t\tgn[i][j] = false;\n\t\t}\n\t}\n\tfor(int j = 0; j <= sub[x]; j++) {\n\t\tgn[0][j] = (a[x] > 0);\n\t}\n\tint tot = 0;\n\tfor(int i = 1; i <= deg; i++) {\n\t\tint node = c[i - 1];\n\t\tfor(int j = 0; j <= tot; j++) {\n\t\t\tfor(int k = 0; k <= sub[node]; k++) {\n\t\t\t\tif(dp[node][k] < 0 || pos[node][k]) {\n\t\t\t\t\tfn[i][j + k + 1] = min(fn[i][j + k], fn[i - 1][j]);\n\t\t\t\t}\n\t\t\t\tfn[i][j + k] = min(fn[i][j + k], fn[i - 1][j] + dp[node][k]);\n\t\t\t}\n\t\t\tfor(int k = 0; k <= sub[node]; k++) {\n\t\t\t\tif(dp[node][k] < 0 || pos[node][k]) {\n\t\t\t\t\tgn[i][j + k + 1] |= gn[i - 1][j];\n\t\t\t\t}\n\t\t\t\tgn[i][j + k] |= gn[i - 1][j] & pos[node][k];\n\t\t\t}\n\t\t}\n\t\ttot += sub[node];\n\t}\n\tfor(int i = 0; i <= tot; i++) {\t\n\t\tdp[x][i] = a[x] + fn[deg][i];\n\t\tpos[x][i] = gn[deg][i];\n\t}\n}\nint main(int argc, char const *argv[])\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tfor(int i = 1; i < n; i++) {\n\t\tint p, q;\n\t\tscanf(\"%d %d\", &p, &q);\n\t\tg[p].emplace_back(q);\n\t\tg[q].emplace_back(p);\n\t}\n\tfor(int i = 0; i <= n; i++) {\n\t\tfor(int j = 0; j <= n; j++) {\n\t\t\tdp[i][j] = inf;\n\t\t}\n\t}\n\tdfs(1, 0);\n\tint ans = -1;\n\tfor(int i = n; i >= 0; i--) {\n\t\tif(dp[1][i] < 0 || pos[1][i]) {\n\t\t\tans = i;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<ld,ld> pdd;\n\n#define X first\n#define Y second\n\n//#include <boost/unordered_map.hpp>\n//using namespace boost;\n\n/*\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> rbtree;\nrbtree T;\n*/\n\nnamespace io{\n\tconst int L = (1 << 20) + 1;\n\t\n\tchar buf[L], *S , *T, c;\n\t \n\tchar getchar() {\n\t\tif(__builtin_expect(S == T, 0)) {\n\t\t\tT = (S = buf) + fread(buf, 1, L, stdin);\n\t\t\treturn (S == T ? EOF : *S++);\n\t\t}\n\t\treturn *S++;\n\t}\n\t\n\tint inp() {\n\t\tint x = 0, f = 1; char ch;\n\t\tfor(ch = getchar(); !isdigit(ch); ch = getchar())\n\t\t\tif(ch == '-') f = -1;\n\t\tfor(; isdigit(ch); x = x * 10 + ch - '0', ch = getchar());\n\t\treturn x * f;\n\t}\n\t\n\tunsigned inpu()\n\t{\n\t\tunsigned x = 0; char ch;\n\t\tfor(ch = getchar(); !isdigit(ch); ch = getchar());\n\t\tfor(; isdigit(ch); x = x * 10 + ch - '0', ch = getchar());\n\t\treturn x;\n\t}\n\t\n\tll inp_ll() {\n\t\tll x = 0; int f = 1; char ch;\n\t\tfor(ch = getchar(); !isdigit(ch); ch = getchar())\n\t\t\tif(ch == '-') f = -1;\n\t\tfor(; isdigit(ch); x = x * 10 + ch - '0', ch = getchar());\n\t\treturn x * f;\n\t}\n\t\n\tchar B[25], *outs=B+20, *outr=B+20;\n\ttemplate<class T>\n\tinline void print(register T a,register char x=0){\n\t\tif(x) *--outs = x, x = 0;\n\t\t\n\t\tif(!a)*--outs = '0';\n\t\telse \n\t\t\twhile(a)\n\t\t\t\t*--outs = (a % 10) + 48, a /= 10;\n\t\t\n\t\tif(x)\n\t\t\t*--outs = x;\n\t\t\n\t\tfwrite(outs, outr - outs , 1, stdout);\n\t\touts = outr;\n\t}\n};\n\nusing io :: print;\nusing io :: inp;\nusing io :: inpu;\nusing io :: inp_ll;\n\nusing i32 = int;\nusing i64 = long long;\nusing u8 = unsigned char;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing f64 = double;\nusing f80 = long double;\n\nll power(ll a, ll b, ll p)\n{\n\tif (!b) return 1;\n\tll t = power(a, b/2, p);\n\tt = t*t%p;\n\tif (b&1) t = t*a%p;\n\treturn t;\n}\n\nconst int MAXN = 5010;\nconst int MAXP = 10000000;\nconst u64 MOD = 1000000007;\nconst f80 MI = f80(1)/MOD;\nconst ll INF = 10000000000000000LL;\nconst ll inf = 5000000000000LL;\n\nint n;\nint a[MAXN];\nvector<int> v[MAXN];\n\nint size[MAXN];\nll F[MAXN][MAXN][2]; // 0/1 whether there is a computer\nll tmp[MAXN][2];\n\nvoid fresh(ll &a, ll b)\n{\n\tif (a > b) a = b;\n}\n\nvoid dfs(int x, int pre)\n{\n\tsize[x] = 1;\n\tif (a[x] > 0)\n\t{\n\t\tF[x][0][0] = F[x][0][1] = a[x];\n\t}\n\telse\n\t{\n\t\tF[x][0][1] = a[x];\n\t}\n\tfor (auto y : v[x])\n\t{\n\t\tif (y == pre) continue;\n\t\tdfs(y, x);\n\t\tfor (int s = 0; s <= size[x]+size[y]; ++ s)\n\t\t{\n\t\t\ttmp[s][0] = INF;\n\t\t\ttmp[s][1] = INF;\n\t\t}\n\t\tfor (int sx = 0; sx <= size[x]; ++ sx)\n\t\t\tfor (int sy = 0; sy <= size[y]; ++ sy)\n\t\t\t{\n\t\t\t\tfresh(tmp[sx+sy][0], F[x][sx][0]+F[y][sy][0]);\n\t\t\t\tfresh(tmp[sx+sy][1], F[x][sx][1]+F[y][sy][0]);\n\t\t\t\tfresh(tmp[sx+sy][1], F[x][sx][0]+F[y][sy][1]);\n\t\t\t\tfresh(tmp[sx+sy][1], F[x][sx][1]+F[y][sy][1]);\n\t\t\t}\n\t\tfor (int s = 0; s <= size[x]+size[y]; ++ s)\n\t\t{\n\t\t\tF[x][s][0] = tmp[s][0];\n\t\t\tF[x][s][1] = tmp[s][1];\n\t\t}\n\t\tsize[x] += size[y];\n\t}\n\tfor (int s = 0; s <= size[x]; ++ s)\n\t\tif (F[x][s][0] != INF || F[x][s][1] < 0)\n\t\t{\n\t\t\tfor (; s < size[x]; ++ s)\n\t\t\t{\n\t\t\t\tfresh(F[x][s+1][0], 0);\n\t\t\t\tfresh(F[x][s+1][1], 0);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t/*\n\tfor (int s = size[x]-1; s >= 0; -- s)\n\t{\n\t\tfresh(F[x][s+1][0], 0);\n\t\tfresh(F[x][s+1][1], 0);\n\t\tif (F[x][s][1] < 0)\n\t\t{\n\t\t\tfresh(F[x][s+1][0], 0);\n\t\t\tfresh(F[x][s+1][1], 0);\n\t\t}\n\t}\n\t*/\n}\n\nint main()\n{\n\t\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++ i)\n\t\tscanf(\"%d\", &a[i]);\n\tfor (int i = 1; i < n; ++ i)\n\t{\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tv[x].push_back(y);\n\t\tv[y].push_back(x);\n\t}\n\tfor (int i = 1; i <= n; ++ i)\n\t\tfor (int j = 0; j <= n; ++ j)\n\t\t\tF[i][j][0] = F[i][j][1] = INF;\n\tdfs(1, 0);\n\tfor (int i = 0; i <= n; ++ i)\n\t\tif (F[1][i][0] == 0 || F[1][i][1] == 0)\n\t\t{\n\t\t\tcout << i-1 << endl;\n\t\t\tbreak;\n\t\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\n\nconst ll INF = 100000000000000000;\n\nstruct Graph\n{\n    int n;\n    vector<vector<int>> g;\n    \n    Graph(int n) : n(n){\n        g.resize(n);\n    }\n    \n    void init(int n_){\n        n = n_;\n        g.resize(n_);\n    }\n    \n    void add_edge(int from, int to){\n        g[from].push_back(to);\n    }\n};\n\nstruct Tree\t//create tree(directed) from graph(undirected)\n{\n    int n;\n    int root;\n    vector<vector<int>> t;\n    vector<int> par;\n    vector<int> dpt;\n    \n    void init(Graph &g, int root_){\n        n = g.n;\n        root = root_;\n        t.resize(n);\n        par.resize(n);\n        dpt.resize(n);\n        fill(dpt.begin(), dpt.end(), -1);\n        queue<int> que;\n        par[root] = -1;\n        dpt[root] = 0;\n        que.push(root);\n        while(que.size()){\n            int pa = que.front();\n            que.pop();\n            for(int ch : g.g[pa]){\n                if(dpt[ch] == -1){\n                    t[pa].push_back(ch);\n                    par[ch] = pa;\n                    dpt[ch] = dpt[pa] + 1;\n                    que.push(ch);\n                }\n            }\n        }\n    }\n\n    Tree(){}\n    \n    Tree(Graph &g, int root_){\n        init(g, root_);\n    }\n    \n    vector<int> toposort(){\n        typedef pair<int, int> P;\n        vector<P> p(n);\n        for(int i = 0; i < n; i++) p[i] = P(dpt[i], i);\n        sort(p.begin(), p.end(), greater<P>());\n        vector<int> res(n);\n        for(int i = 0; i < n; i++) res[i] = p[i].second;\n        return res;\n    }\n};\n\nll dp[5005][2][5005];\nint w[5005];\n\nint main()\n{\n    int n;\n    cin >> n;\n    ll a[5005];\n    for(int i = 0; i < n; i++) cin >> a[i];\n    Graph g(n);\n    for(int i = 0; i < n - 1; i++){\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        g.add_edge(u, v);\n        g.add_edge(v, u);\n    }\n    Tree t(g, 0);\n    vector<int> d = t.toposort();\n    int s[5002];\n    for(int i = 0; i < n; i++){\n        int u = d[i];\n        s[u] = 1;\n        for(int v : t.t[u]){\n            s[u] += s[v];\n        }\n    }\n    for(int i = 0; i < n; i++){\n        for(int k = 0; k <= n; k++) dp[i][0][k] = dp[i][1][k] = INF;\n        dp[i][0][0] = 0;\n    }\n    for(int i = 0; i < n; i++){\n        int u = d[i];\n        int r = 1;\n        for(int j = 1; j <= (int)t.t[u].size(); j++){\n            int v = t.t[u][j - 1];\n            for(int k = 0; k < r + s[u]; k++){\n                dp[u][j % 2][k] = INF;\n            }\n            for(int k = 0; k < r; k++){\n                for(int l = 0; l <= s[v]; l++){\n                    dp[u][j % 2][k + l] = min(dp[u][j % 2][k + l], dp[u][(j + 1) % 2][k] + dp[v][0][l]);\n                }\n            }\n            r += s[v];\n            for(int k = 1; k <= r; k++){\n                dp[u][j % 2][k] = min(dp[u][j % 2][k], dp[u][j % 2][k - 1]);\n            }\n        }\n        if((int)t.t[u].size() % 2){\n            for(int k = 0; k <= r; k++) dp[u][0][k] = dp[u][1][k];\n        }\n        for(int k = 0; k <= r; k++) dp[u][0][k] += a[u];\n        if(a[u] > 0){\n            for(int v : t.t[u]){\n                int k;\n                for(k = 0; k <= s[v]; k++){\n                    if(dp[v][0][k] < 0) break;\n                }\n                w[u] += min(w[v], k + 1);\n            }\n            for(int k = w[u] + 1; k <= s[u]; k++) dp[u][0][k] = min(dp[u][0][k], 0ll);\n        }\n        else{\n            w[u] = n;\n            dp[u][0][r] = dp[u][0][r - 1];\n        }\n    }\n    int ans;\n    for(ans = 0; ans <= s[0]; ans++){\n        if(dp[0][0][ans] < 0) break;\n    }\n    ans = min(ans, w[0]);\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n\n#define null\t\t\t\t\"\"\n#define all(dat)\t\t\tdat.begin(), dat.end()\n#define over(msg)\t\t\tcout << msg << endl, exit(0);\n#define loop(i, to)\t\t\tfor (int i = 0; i < to; ++i)\n#define cont(i, to)\t\t\tfor (int i = 1; i <= to; ++i)\n#define foreach(i, dat)\t\tfor (__typeof(dat.begin()) i = dat.begin(); i != dat.end(); ++i)\n\ntypedef long long\t\t\tnum;\n\nusing namespace std;\n\nint n;\nnum inf = 1e15, sz[50005], w[5005], dp[2][5005][5005], tmp[2][5005];\nvector<int> g[5005];\n\nvoid dfs(int u, int p) {\n\tsz[u] = 1;\n\tcont (s, 5000) {\n\t\tdp[0][u][s] = dp[1][u][s] = inf;\n\t}\n\tdp[0][u][1] = w[u] < 0 ? inf : w[u];\n\tdp[1][u][1] = w[u];\n\tfor (int v : g[u]) {\n\t\tif (v == p)  continue;\n\t\tdfs(v, u);\n\t\tcont (s, sz[u] + sz[v]) {\n\t\t\ttmp[0][s] = tmp[1][s] = inf;\n\t\t}\n\t\tcont (s1, sz[u]) {\n\t\t\tcont (s2, sz[v]) {\n\t\t\t\tint s = s1 + s2;\n\t\t\t\tif (dp[0][v][s2] < inf) {\n\t\t\t\t\ttmp[0][s] = min(tmp[0][s], dp[0][u][s1]);\n\t\t\t\t\ttmp[1][s] = min(tmp[1][s], dp[1][u][s1]);\n//\t\t\t\t\tcout << u << ':' << s << ' ' << tmp[0][s] << ' ' << tmp[1][s] << endl;\n\t\t\t\t}\n\t\t\t\tif (dp[1][v][s2] < 0) {\n\t\t\t\t\ttmp[0][s] = min(tmp[0][s], dp[0][u][s1]);\n\t\t\t\t\ttmp[1][s] = min(tmp[1][s], dp[1][u][s1]);\n//\t\t\t\t\tcout << u << ':' << s << ' ' << tmp[0][s] << ' ' << tmp[1][s] << endl;\n\t\t\t\t}\n\t\t\t\ttmp[0][s - 1] = min(tmp[0][s - 1], dp[0][u][s1] + dp[0][v][s2]);\n\t\t\t\ttmp[1][s - 1] = min(tmp[1][s - 1], dp[1][u][s1] + dp[1][v][s2]);\n//\t\t\t\tcout << u << ':' << s - 1 << ' ' << dp[1][u][s1] << ',' << dp[1][v][s2] << endl;\n\t\t\t}\n\t\t}\n\t\tsz[u] += sz[v];\n\t\tcont (s, sz[u]) {\n\t\t\tdp[0][u][s] = tmp[0][s];\n\t\t\tdp[1][u][s] = tmp[1][s];\n//\t\t\tcout << \"  \" << u << \":\" << s << ' ' << tmp[0][s] << ' ' << tmp[1][s] << endl;\n\t\t}\n\t}\n}\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin >> n;\n\tcont (i, n) {\n\t\tcin >> w[i];\n\t}\n\tcont (i, n - 1) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\tdfs(1, -1);\n//\tcont (u, n) {\n//\t\tcout << u << \": \" << endl;\n//\t\tcont (cnt, sz[u]) {\n//\t\t\tcout << \"  \" << cnt << \": \" << endl;\n//\t\t\tcout << \"    \";\n//\t\t\tloop (mem, 2) {\n//\t\t\t\tcout << dp[mem][u][cnt] << ' ';\n//\t\t\t}\n//\t\t\tcout << endl;\n//\t\t}\n//\t\tcout << endl;\n//\t}\n\tcont (cnt, n) {\n//\t\tcout << dp[0][1][cnt] << ' ' << dp[1][1][cnt] << endl;\n\t\tif (dp[0][1][cnt] < inf || dp[1][1][cnt] < 0) {\n\t\t\tcout << cnt - 1 << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FAST ios_base::sync_with_stdio(false); cin.tie(0);\n#define pb push_back\n#define eb emplace_back\n#define ins insert\n#define f first\n#define s second\n#define cbr cerr << \"hi\\n\"\n#define mmst(x, v) memset((x), v, sizeof ((x)))\n#define siz(x) ll(x.size())\n#define all(x) (x).begin(), (x).end()\n#define lbd(x,y) (lower_bound(all(x),y)-x.begin())\n#define ubd(x,y) (upper_bound(all(x),y)-x.begin())\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());    //can be used by calling rng() or shuffle(A, A+n, rng)\ninline long long rand(long long x, long long y) { return (rng() % (y+1-x)) + x; } //inclusivesss\nstring inline to_string(char c) {string s(1,c);return s;} template<typename T> inline T gcd(T a,T b){ return a==0?llabs(b):gcd(b%a,a); }\n\ntypedef long long ll; \ntypedef long double ld;\n#define FOR(i,s,e) for(ll i=s;i<=ll(e);++i)\n#define DEC(i,s,e) for(ll i=s;i>=ll(e);--i)\ntypedef pair<ll,ll>pi; typedef pair<ll,pi>spi; typedef pair<pi,pi>dpi;\n\n#define LLINF ((long long)1e18)\n#define INF int(1e9+1e6)\n#define MAXN (5006)\nll n,A[MAXN],dp[MAXN][MAXN],sz[MAXN];// if 0 then max, 1 then min\nbitset<MAXN> dp2[MAXN];\nvector<int>v[MAXN];\nvoid dfs(ll x,ll p){\n\tsz[x]=1;\n\tdp[x][0]=A[x];\n\tfor(auto i:v[x]) if(i^p) dfs(i,x), sz[x]+=sz[i];\n\tFOR(k,1,sz[x]) dp[x][k]=LLINF;\n\tll cur = 1;\n\tif(A[x]>0)dp2[x][0]=1;\n\tfor(auto i:v[x]) if(i^p) {\n\t\tDEC(j,cur+sz[i],0){\n\t\t\tif(dp[x][j]<LLINF) dp[x][j] += dp[i][0];\n\t\t\tdp2[x][j] = dp2[x][j] & dp2[i][0];\n\t\t\tFOR(k,max(j-cur,1ll),min(j,sz[i])){\n\t\t\t\tdp[x][j]=min(dp[x][j],dp[x][j-k]+dp[i][k]);\n\t\t\t\tif(dp2[i][k-1]) dp[x][j]=min(dp[x][j],dp[x][j-k]);\n\t\t\t\tdp2[x][j]=dp2[x][j]|(dp2[x][j-k]&dp2[i][k]);\n\t\t\t\tif(dp[i][k-1] < 0) dp2[x][j]=dp2[x][j]|dp2[x][j-k];\n\t\t\t}\n\t\t}\n\t\tcur += sz[i];\n\t}\n}\nint main(){\n\tFAST\n\tcin>>n;\n\tFOR(i,1,n)cin>>A[i];\n\tFOR(i,2,n){\n\t\tll a,b;cin>>a>>b;\n\t\tv[a].eb(b),v[b].eb(a);\n\t}\n\tdfs(1,1);\n\tll ans = n-1;\n\tFOR(k,0,n-1) if(dp[1][k] < 0) ans = min(ans, k);\n\tFOR(k,0,n-1) if(dp2[1][k]) ans = min(ans, k);\n\tcout<<ans<<'\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\nconst LL INF = LL(1e18);\n\nint n;\nint a[5000];\nLL d[5000][2][5001];\nLL e[2][5001];\nint sz[5000];\nvector<int> g[5000];\n\ninline void upd(LL &x, LL y) {\n    x = min(x, y);\n}\n\nvoid solve(int v, int par) {\n    sz[v] = 1;\n    if (a[v] > 0) {\n        d[v][0][0] = a[v];\n        d[v][1][0] = INF;\n    } else {\n        d[v][1][0] = a[v];\n        d[v][0][0] = INF;\n    }\n    for (int to : g[v]) if (to != par) {\n        solve(to, v);\n        forn(i, sz[v] + sz[to]) {\n            e[0][i] = INF;\n            e[1][i] = INF;\n        }\n        forn(i, sz[v]) forn(j, sz[to]) {\n            if (d[v][0][i] != INF && d[to][0][j] != INF) {\n                upd(e[0][i + j], d[v][0][i] + d[to][0][j]);\n                upd(e[0][i + j + 1], d[v][0][i]);\n            }\n\n            if (d[v][0][i] != INF && d[to][1][j] != INF) {\n                upd(e[1][i + j], d[v][0][i] + d[to][1][j]);\n                if (d[to][1][j] < 0) {\n                    upd(e[0][i + j + 1], d[v][0][i]);\n                }\n            }\n\n            if (d[v][1][i] != INF && d[to][0][j] != INF) {\n                upd(e[1][i + j], d[v][1][i] + d[to][0][j]);\n                upd(e[1][i + j + 1], d[v][1][i]);\n            }\n\n            if (d[v][1][i] != INF && d[to][1][j] != INF) {\n                upd(e[1][i + j], d[v][1][i] + d[to][1][j]);\n                if (d[to][1][j] < 0) {\n                    upd(e[1][i + j + 1], d[v][1][i]);\n                }\n            }\n        }\n        sz[v] += sz[to];\n        forn(i, 2) forn(j, sz[v]) {\n            d[v][i][j] = e[i][j];\n        }\n    }\n}\n\nint main() {\n//    freopen(\"input.txt\", \"r\", stdin);\n    scanf(\"%d\", &n);\n    forn(i, n) scanf(\"%d\", a + i);\n    forn(i, n - 1) {\n        int from, to;\n        scanf(\"%d%d\", &from, &to), --from, --to;\n        g[from].pb(to);\n        g[to].pb(from);\n    }\n    solve(0, -1);\n    int best = n - 1;\n    forn(i, n) {\n        if (d[0][0][i] != INF) {\n            best = i;\n            break;\n        }\n        if (d[0][1][i] < 0) {\n            best = i;\n            break;\n        }\n    }\n    cout << best << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n#define reps(i, n) for (int i = 1; i <= (int) (n); i++)\n#define all(x) (x).begin(), (x).end()\n#define uniq(x) (x).erase(unique(all(x)), (x).end())\n#define bit(n) (1LL << (n))\n#define cdiv(a, b) (((a) - 1) / (b) + 1)\n#define dump(x) cerr << #x \" = \" << (x) << endl\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing pint = pair<int, int>;\nusing vpint = vector<pint>;\ntemplate<typename T> using priority_queue_rev = priority_queue<T, vector<T>, greater<T>>;\nconstexpr double PI = 3.1415926535897932384626433832795028;\nconstexpr int DY[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nconstexpr int DX[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nint gcd(int a, int b) {\n    while (b) { swap(a %= b, b); }\n    return a;\n}\nint lcm(int a, int b) { return a / gcd(a, b) * b; }\nint sgn(int x) { return (x > 0) - (x < 0); }\ntemplate<typename T> void fin(T mes) {\n    cout << mes << endl;\n    exit(0);\n}\ntemplate<typename T, typename U> bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &rhs) {\n    os << \"(\" << rhs.first << \", \" << rhs.second << \")\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\nstruct setup {\n    static constexpr int PREC = 20;\n\n    setup() {\n        cout << fixed << setprecision(PREC);\n        cerr << fixed << setprecision(PREC);\n    };\n} setup;\n\nstruct union_find_tree {\n    std::vector<int> par, size, val;\n    union_find_tree() {}\n    union_find_tree(int n, vint val) : par(n), size(n), val(val) {\n        for (int i = 0; i < n; i++) {\n            par[i] = i;\n            size[i] = 1;\n        }\n    }\n    int get_root(int i) {\n        if (par[i] == i) { return i; }\n        else { return par[i] = get_root(par[i]); }\n    }\n    void unite(int i, int j) {\n        if ((i = get_root(i)) == (j = get_root(j))) { return; }\n        if (size[i] < size[j]) { std::swap(i, j); }\n        par[j] = i;\n        size[i] += size[j];\n        val[i] += val[j];\n    }\n    bool are_same(int i, int j) { return get_root(i) == get_root(j); }\n    int get_size(int i) { return size[get_root(i)]; }\n    int get_val(int i) { return val[get_root(i)]; }\n};\n\nint N;\nint U[5500], V[5500];\nvint G[5500];\nunion_find_tree uf;\npair<vint, int> dfs(int cur, int par) {\n    vint x = {uf.get_val(cur)};\n    if (uf.get_val(cur) < 0) {\n        //コンピュータ\n        for (int to:G[cur]) {\n            if (to == par) { continue; }\n            pair<vint, int> tmp = dfs(to, cur);\n            vint nxt = tmp.first;\n            int cut = tmp.second;\n            vint y(x.size() + nxt.size(), LLONG_MAX);\n            rep(i, x.size()) { y[i + cut + 1] = x[i]; }\n            rep(i, x.size()) {\n                rep(j, nxt.size()) {\n                    chmin(y[i + j], x[i] + nxt[j]);\n                    if (nxt[j] < 0) { chmin(y[i + j + 1], x[i]); }\n                }\n            }\n            x = y;\n        }\n        reps(i, x.size() - 1) { chmin(x[i], x[i - 1]); }\n        return {x, -1};\n    }\n    if (uf.get_val(cur) > 0) {\n        //バッテリー\n        int cut = 0;\n        for (int to:G[cur]) {\n            if (to == par) { continue; }\n            vint nxt = dfs(to, cur).first;\n            vint y(x.size() + nxt.size(), LLONG_MAX);\n            rep(i, x.size()) {\n                rep(j, nxt.size()) {\n                    chmin(y[i + j], x[i] + nxt[j]);\n                    if (nxt[j] < 0) { chmin(y[i + j + 1], x[i]); }\n                }\n            }\n            x = y;\n            int pl;\n            for (int i = nxt.size(); i >= 0; i--) { if (nxt[i] < 0) { pl = i; }}\n            cut += pl + 1;\n        }\n        reps(i, x.size() - 1) { chmin(x[i], x[i - 1]); }\n        return {x, cut};\n    }\n    return {{}, 0};\n}\n\nsigned main() {\n    cin >> N;\n    vint val(N);\n    rep(i, N) { cin >> val[i]; }\n    uf = union_find_tree(N, val);\n    rep(i, N - 1) {\n        cin >> U[i] >> V[i];\n        U[i]--, V[i]--;\n        if (uf.get_val(U[i]) * uf.get_val(V[i]) > 0) { uf.unite(U[i], V[i]); }\n    }\n    rep(i, N - 1) {\n        int u = uf.get_root(U[i]), v = uf.get_root(V[i]);\n        if (u != v) { G[u].push_back(v), G[v].push_back(u); }\n    }\n    pair<vint, int> res = dfs(uf.get_root(0), -1);\n    int ans = N;\n    if (uf.get_val(0) > 0) { ans = res.second; }\n    rep(i, res.first.size()) { if (res.first[i] < 0) { chmin(ans, i); }}\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef double D;\ntypedef pair<ll,ll> P;\n#define M 1000000007\n#define F first\n#define S second\n#define PB push_back\n#define INF 100000000000000000\nll n,dp[5050][5050][2],a[5050],sz[5050],r[5050][2];;\nvector<ll>g[5050];\nvoid dfs(int v,int p){\n    sz[v]=1;\n    dp[v][0][0]=a[v];\n    if(a[v]>0)dp[v][0][1]=a[v];\n    for(int i=0;i<g[v].size();i++){\n        int u=g[v][i];\n        if(u==p)continue;\n        dfs(u,v);\n        for(int j=0;j<=sz[u]+sz[v];j++)r[j][0]=INF,r[j][1]=INF;\n        for(int j=0;j<sz[v];j++){\n            for(int k=0;k<sz[u];k++){\n                if(dp[u][k][0]<0||dp[u][k][1]!=INF){\n                    r[j+k+1][0]=min(r[j+k+1][0],dp[v][j][0]);\n                    r[j+k+1][1]=min(r[j+k+1][1],dp[v][j][1]);\n                }  \n                r[j+k][0]=min(r[j+k][0],dp[v][j][0]+min(dp[u][k][0],dp[u][k][1]));\n                r[j+k][1]=min(r[j+k][1],dp[v][j][1]+dp[u][k][1]);\n            }\n        }\n        sz[v]+=sz[u];\n        for(int j=0;j<sz[v];j++)dp[v][j][0]=r[j][0],dp[v][j][1]=r[j][1];\n    }\n}\nint main(void){\n    scanf(\"%lld\",&n);\n    for(int i=0;i<n;i++)for(int j=0;j<n;j++)dp[i][j][0]=INF,dp[i][j][1]=INF;\n    for(int i=0;i<n;i++)scanf(\"%lld\",a+i);\n    for(int i=0;i<n-1;i++){\n        ll x,y;\n        scanf(\"%lld%lld\",&x,&y);\n        g[--x].PB(--y);\n        g[y].PB(x);\n    }\n    dfs(0,-1);\n    for(int i=0;i<n;i++){\n        if(dp[0][i][0]<0||dp[0][i][1]!=INF){\n            printf(\"%d\\n\",i);\n            return 0;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n\nvector<LL> A;\nvector<vector<int>> V;\nconst LL INF = 1e18;\n\nvector<vector<LL>> solve(int p, int q){\n\tvector<vector<LL>> ret(1,vector<LL>(2,INF));\n\tret[0][0] = A[q];\n\tif(A[q] > 0) ret[0][1] = A[q];\n\tfor(auto u : V[q]) if(u != p){\n\t\tauto z = solve(q,u);\n\t\tvector<vector<LL>> nx(ret.size()+z.size(),vector<LL>(2,INF));\n\t\trepp(i,0,ret.size()) repp(j,0,z.size()){\n\t\t\tnx[i+j][0] = min(nx[i+j][0],ret[i][0]+z[j][0]);\n\t\t\tnx[i+j][1] = min(nx[i+j][1],ret[i][1]+z[j][1]);\n\t\t\tif(z[j][0] < 0 || z[j][1] < INF){\n\t\t\t\tnx[i+j+1][0] = min(nx[i+j+1][0],ret[i][0]);\n\t\t\t\tnx[i+j+1][1] = min(nx[i+j+1][1],ret[i][1]);\n\t\t\t}\n\t\t}\n\t\tswap(ret,nx);\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint N; cin >> N;\n\tA.resize(N); repp(i,0,N) cin >> A[i];\n\tV.resize(N);\n\trepp(i,1,N){\n\t\tint u,v; cin >> u >> v;\n\t\t--u; --v;\n\t\tV[u].push_back(v);\n\t\tV[v].push_back(u);\n\t}\n\tauto ans = solve(-1,0);\n\trepp(i,0,N) if(ans[i][1] < INF || ans[i][0] < 0) return cout << i << endl, 0;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\nconst int maxN = 5005;\nint a[maxN];\nvector < int > g[maxN];\nll dp[maxN][maxN];\nbool positive[maxN][maxN];\nbool nposs[maxN];\nint n;\nint sz[maxN];\nconst ll INF = (ll)1e18;\nint f[maxN];\nll ndp[maxN];\nvoid dfs(int v, int p) {\n    if (a[v] < 0) {\n        dp[v][0] = a[v];\n        positive[v][0] = false;\n    } else {\n        dp[v][0] = a[v];\n        positive[v][0] = true;\n    }\n    sz[v] = 1;\n    for (int to : g[v]) {\n        if (to == p) continue;\n        dfs(to, v);\n        for (int i = 0; i <= sz[v] + sz[to]; i++) {\n            for (int flag = 0; flag < 2; flag++) {\n                ndp[i] = INF;\n                nposs[i] = false;\n            }\n        }\n        for (int del_edges = 0; del_edges <= sz[v]; del_edges++) {\n            for (int del_edges2 = 0; del_edges2 <= sz[to]; del_edges2++) {\n                ndp[del_edges + del_edges2] = min(ndp[del_edges + del_edges2],\n                                                  dp[v][del_edges] + dp[to][del_edges2]);\n                nposs[del_edges + del_edges2] |= (positive[v][del_edges] & positive[to][del_edges2]);\n                if (dp[to][del_edges2] < 0) {\n                    ndp[del_edges + del_edges2 + 1] = min(ndp[del_edges + del_edges2 + 1],\n                                                          dp[v][del_edges]);\n                    nposs[del_edges + del_edges2 + 1] |= positive[v][del_edges];\n                }\n                if (positive[to][del_edges2]) {\n                    ndp[del_edges + del_edges2 + 1] = min(ndp[del_edges + del_edges2 + 1], dp[v][del_edges]);\n                    nposs[del_edges + del_edges2 + 1] |= positive[v][del_edges];\n                }\n            }\n        }\n        sz[v] += sz[to];\n        for (int i = 0; i <= sz[v]; i++) {\n            dp[v][i] = ndp[i];\n            positive[v][i] = nposs[i];\n        }\n    }\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    //freopen(\"input.txt\", \"r\", stdin);\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j <= n; j++) {\n            dp[i][j] = INF;\n            positive[i][j] = false;\n        }\n    }\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i];\n    }\n    for (int i = 1; i < n; i++) {\n        int a, b;\n        cin >> a >> b;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    dfs(1, -1);\n    for (int edges = 0; edges <= n - 1; edges++) {\n        if (dp[1][edges] < 0 || positive[1][edges]) {\n            cout << edges;\n            return 0;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\nconst long long INF = 1LL<<60;\nconst int MAX = 5100;\n\nint N;\nvector<long long> A;\nvector<vector<int> > G;\n\nint num[MAX]; // v の部分木に何個の頂点が含まれるか\nlong long dp[MAX][MAX][2]; // vの部分木、vを含めず何個か、(全部正かどうか)\nlong long sdp[MAX][2]; // 頂点 v の子ノード ch たちに足してナップサック\n\nvoid rec(int v, int p) {\n    num[v] = 1;\n    for (auto ch : G[v]) {\n        if (ch == p) continue;\n        rec(ch, v);\n        num[v] += num[ch];\n    }\n    \n    for (int j = 0; j <= num[v]; ++j) sdp[j][0] = sdp[j][1] = INF;\n    \n    sdp[0][0] = A[v];\n    if (A[v] > 0) sdp[0][1] = A[v];\n    \n    int curnum = 0; // 現在までに見た部分木のノード数の和\n    for (auto ch : G[v]) {\n        if (ch == p) continue;\n        for (int j = curnum; j >= 0; --j) {\n            long long tmp0 = sdp[j][0], tmp1 = sdp[j][1];\n            sdp[j][0] = sdp[j][1] = INF;\n            for (int k = 0; k <= num[ch]; ++k) {\n                chmin(sdp[j+k][0], tmp0 + dp[ch][k][0]);\n                if (dp[ch][k][0] < 0 || dp[ch][k][1] < INF/2) chmin(sdp[j+k+1][0], tmp0);\n                if (A[v] > 0) {\n                    chmin(sdp[j+k][1], tmp1 + dp[ch][k][1]);\n                    if (dp[ch][k][0] < 0 || dp[ch][k][1] < INF/2) chmin(sdp[j+k+1][1], tmp1);\n                }\n            }\n        }\n        curnum += num[ch];\n    }\n    for (int j = 0; j <= num[v]; ++j) {\n        dp[v][j][0] = sdp[j][0];\n        dp[v][j][1] = sdp[j][1];\n        \n        //cout << v << \", \" << j << \": \" << make_pair(dp[v][j][0], dp[v][j][1]) << endl;\n    }\n}\n\nint main() {\n    while (cin >> N) {\n        A.resize(N);\n        for (int i = 0; i < N; ++i) cin >> A[i];\n        G.assign(N, vector<int>());\n        for (int i = 0; i < N-1; ++i) {\n            int u, v; cin >> u >> v; --u, --v;\n            G[u].push_back(v);\n            G[v].push_back(u);\n        }\n        for (int i = 0; i < MAX; ++i) for (int j = 0; j < MAX; ++j)\n            dp[i][j][0] = dp[i][j][1] = INF;\n        rec(0, -1);\n        int res = N;\n        for (int i = 0; i <= N; ++i) {\n            if (dp[0][i][0] < 0) chmin(res, i);\n            if (dp[0][i][1] < INF/2) chmin(res, i);\n        }\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n\ntypedef long long ll;\n#define int ll\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = 1e18;\nconst ll MOD = 1000000007;\n//const ll MOD = 998244353;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { 1,0, -1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n//#define mp make_pair\n\nconst int N = 5010;\nvll dp1(N, vl(N, INF));\nvl dp2(N, INF);\nvii G(N);\nvl a(N);\nvl sum(N);\nvi fu(N);\nint n;\n\nvoid dfs_pre(int now, int par) {\n  if (a[now] < 0) fu[now]++;\n  sum[now] = a[now];\n  rep (i, G[now].size()) {\n    if (G[now][i] == par) continue;\n    int v = G[now][i];\n    dfs_pre(v, now);\n    sum[now] += sum[v];\n    fu[now] += fu[v];\n  }\n}\n\nvoid dfs(int now, int par) {\n  int m;\n  if (par == -1) {\n    m = G[now].size();\n  }\n  else {\n    m = G[now].size() - 1;\n  }\n  if (m == 0) {\n    if (a[now] > 0) {\n      dp2[now] = 0;\n    }\n    else {\n      dp2[now] = INF;\n    }\n    dp1[now][0] = a[now];\n    return;\n  }\n  vll dp(m + 1, vl(n), INF);\n  dp[0][0] = a[now];\n  int i = 0;\n  if (a[now] > 0) dp2[now] = 0;\n  rep (aaa, G[now].size()) {\n    if (G[now][aaa] == par) continue;\n    int v = G[now][aaa];\n    dfs(v, now);\n    rep (j, n) {\n      if (dp[i][j] >= INF) break;\n      rep (k, n) {\n        if (dp1[v][k] >= INF) break;\n        chmin(dp[i + 1][j + k], dp[i][j] + dp1[v][k]);\n        chmin(dp[i + 1][j + 1 + k], dp[i][j]);\n      }\n      chmin(dp[i + 1][j + 1 + dp2[v]], dp[i][j]);\n    }\n    if (a[now] > 0) {\n      ll add = dp2[v];\n      rep (j, n) {\n        if (dp[v][j] < 0) {\n          add = min(add, j);\n          break;\n        }\n      }\n      dp2[now] += add;\n    }\n    i++;\n  }\n  rep (i, n) {\n    dp1[now][i] = dp[m][i];\n  }\n  if (a[now] < 0) dp2[now] = INF;\n}\n\nsigned main() {\n  cin >> n;\n  rep (i, n) {\n    cin >> a[i];\n  }\n  rep (i, n - 1) {\n    int u, v;\n    cin >> u >> v;\n    u--; v--;\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  dfs_pre(0, -1);\n  dfs(0, -1);\n  ll ans = INF;\n  rep (i, n) {\n    if (dp1[0][i] < 0) {\n      ans = i;\n      break;\n    }\n  }\n  chmin(ans, dp2[0]);\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <queue>\n#define MAX_N 5005\n#define INF 10000000000000\n\nusing namespace std;\ntypedef long long ll;\n\nint N;\nll A[MAX_N];\nvector<int> G[MAX_N];\nll dp[2][MAX_N][MAX_N];//i,v,k 親成分以外が条件を満たす/親成分すべて正　連結成分の数\n\n\nvoid show(){\n    //debug\n    for(int n=0;n<N;n++){\n        for(int k=0;k<=N;k++){\n            if(dp[0][n][k]==INF){cout<<\"INF \";continue;}\n            cout<<dp[0][n][k]<<\" \";\n        }\n        cout<<endl;\n    }\n    cout<<endl;\n    for(int n=0;n<N;n++){\n        for(int k=0;k<=N;k++){\n            if(dp[1][n][k]==INF){cout<<\"INF \";continue;}\n            cout<<dp[1][n][k]<<\" \";\n        }\n        cout<<endl;\n    }\n    cout<<\"--------------------------------\"<<endl;\n\n}\n\nint dfs(int p,int n){//親ノード、今のノード\n    int count = 0;\n    int K = 1;\n    for(int i = 0;i < G[n].size();i++){\n        int c = G[n][i];\n        if(c==p)continue;\n        count++;\n        K += dfs(n,c);\n        if(count==1){\n            for(int k = 1;k <= K;k++){\n                //nをk個目の独立した連結成分にする場合\n                if(dp[0][c][k-1]<0||dp[1][c][k-1]!=INF){\n                    dp[0][n][k]=min(dp[0][n][k],A[n]);\n                    if(A[n]>0)\n                        dp[1][n][k]=min(dp[1][n][k],A[n]);\n                }\n                //cの連結成分につなげる場合\n                if(dp[0][c][k]!=INF)\n                    dp[0][n][k]=min(dp[0][n][k],dp[0][c][k]+A[n]);\n                if(A[n]>0&&dp[1][c][k]!=INF)\n                    dp[1][n][k]=min(dp[1][n][k],dp[1][c][k]+A[n]);\n            }\n            continue;\n        }\n        ll dpn[2][MAX_N];\n        for(int k = 0;k <= K;k++){\n            dpn[0][k]=INF;\n            dpn[1][k]=INF;\n        }\n        for(int k = 1;k <= K;k++){\n            //cのノードをnに繋げない場合\n            for(int k_ = k;k_ > 0;k_--){//k_:n側の連結成分数\n                if(dp[0][c][k-k_]<0||dp[1][c][k-k_]!=INF){//cのノード以下が問題文の条件を満たしていれば、繋がなくても良い。\n                    dpn[0][k] = min(dpn[0][k],dp[0][n][k_]);\n                    dpn[1][k] = min(dpn[1][k],dp[1][n][k_]);\n                }\n            }\n            //cをnの連結成分につなげる場合\n            for(int k_ = k;k_ > 0;k_--){//k_:n側の連結成分数\n                if(dp[0][c][k-k_+1]!=INF&&dp[0][n][k_]!=INF){\n                    dpn[0][k]=min(dpn[0][k],dp[0][c][k-k_+1]+dp[0][n][k_]);\n                }\n                if(dp[1][c][k-k_+1]!=INF&&dp[1][n][k_]!=INF){\n                    dpn[1][k]=min(dpn[1][k],dp[1][c][k-k_+1]+dp[1][n][k_]);\n                }\n            }\n        }\n        for(int k = 1;k <= K;k++){\n            dp[0][n][k]=dpn[0][k];\n            dp[1][n][k]=dpn[1][k];\n        }\n    }\n    if(p>=0&&count==0){\n        dp[0][n][1]=A[n];\n        if(A[n]>0){\n            dp[1][n][1]=A[n];\n        }\n    }\n//    cout<<n<<endl;\n//    show();\n    return K;\n}\n\nint main() {\n    cin>>N;\n    for(int i=0;i<N;i++){\n        for(int j=0;j<=N;j++){\n            dp[0][i][j]=INF;\n            dp[1][i][j]=INF;\n        }\n        cin>>A[i];\n    }\n    for(int i=0;i<N-1;i++){\n        int a,b;\n        cin>>a>>b;\n        a--,b--;\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n    dfs(-1,0);\n    int ans;\n    \n    \n    \n    for(int k=1;k<=N;k++){\n        if(dp[0][0][k]<0){\n            cout<<k-1<<endl;\n//            cout<<\"debug 1\"<<endl;\n            return 0;\n        }\n        if(dp[1][0][k]!=INF&&dp[1][0][k]>0){\n            cout<<k-1<<endl;\n//            cout<<\"debug 2:\"<<dp[1][0][k]<<endl;\n            return 0;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nlong long N, A[5009], U[5009], V[5009], dp[5009][5009][2], dp2[5009][5009][2], VV[5009];\nvector<int>X[5009]; bool used[5009];\n\nvoid dfs2(int pos) {\n\tVV[pos] += 1;\n\tfor (int i = 0; i < X[pos].size(); i++) {\n\t\tif (VV[X[pos][i]] >= 1) continue;\n\t\tdfs2(X[pos][i]);\n\t\tVV[pos] += VV[X[pos][i]];\n\t}\n}\n\nvoid dfs(int pos) {\n\tused[pos] = true; vector<int>Y;\n\tfor (int i = 0; i < X[pos].size(); i++) {\n\t\tif (used[X[pos][i]] == true) continue;\n\t\tdfs(X[pos][i]);\n\t\tY.push_back(X[pos][i]);\n\t}\n\n\tfor (int i = 0; i <= Y.size(); i++) { for (int j = 0; j <= VV[pos]; j++) { dp2[i][j][0] = (1LL << 60); dp2[i][j][1] = (1LL << 60); } }\n\tif (A[pos] >= 1) dp2[0][0][0] = A[pos]; else dp2[0][0][1] = A[pos];\n\n\tint S = 0;\n\tfor (int i = 0; i < Y.size(); i++) {\n\t\tfor (int j = 0; j <= S; j++) {\n\t\t\tif (dp2[i][j][0] != (1LL << 60)) {\n\t\t\t\tfor (int l = 0; l <= VV[Y[i]]; l++) {\n\t\t\t\t\tdp2[i + 1][j + l][0] = min(dp2[i + 1][j + l][0], dp2[i][j][0] + dp[Y[i]][l][0]);\n\t\t\t\t\tdp2[i + 1][j + l][1] = min(dp2[i + 1][j + l][1], dp2[i][j][0] + dp[Y[i]][l][1]);\n\t\t\t\t\tif (dp[Y[i]][l][0] < (1LL << 58) || dp[Y[i]][l][1] < 0) {\n\t\t\t\t\t\tdp2[i + 1][j + l + 1][0] = min(dp2[i + 1][j + l + 1][0], dp2[i][j][0]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dp2[i][j][1] != (1LL << 60)) {\n\t\t\t\tfor (int l = 0; l <= VV[Y[i]]; l++) {\n\t\t\t\t\tdp2[i + 1][j + l][1] = min(dp2[i + 1][j + l][1], dp2[i][j][1] + dp[Y[i]][l][0]);\n\t\t\t\t\tdp2[i + 1][j + l][1] = min(dp2[i + 1][j + l][1], dp2[i][j][1] + dp[Y[i]][l][1]);\n\t\t\t\t\tif (dp[Y[i]][l][0] < (1LL << 58) || dp[Y[i]][l][1] < 0) {\n\t\t\t\t\t\tdp2[i + 1][j + l + 1][1] = min(dp2[i + 1][j + l + 1][1], dp2[i][j][1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tS += VV[Y[i]];\n\t}\n\tfor (int i = 0; i <= VV[pos]; i++) {\n\t\tdp[pos][i][0] = dp2[Y.size()][i][0];\n\t\tdp[pos][i][1] = dp2[Y.size()][i][1];\n\t}\n}\n\nint main() {\n\tcin >> N;\n\tfor (int i = 1; i <= N; i++) cin >> A[i];\n\tfor (int i = 1; i <= N - 1; i++) {\n\t\tcin >> U[i] >> V[i];\n\t\tX[U[i]].push_back(V[i]);\n\t\tX[V[i]].push_back(U[i]);\n\t}\n\tdfs2(1);\n\tfor (int i = 1; i <= N; i++) { for (int j = 0; j <= N; j++) { dp[i][j][0] = (1LL << 60); dp[i][j][1] = (1LL << 60); } }\n\tdfs(1);\n\n\tint maxn = (1 << 30);\n\tfor (int i = 0; i <= N; i++) {\n\t\tif (dp[1][i][0] < (1LL << 58) || dp[1][i][1] < 0) { maxn = min(maxn, i); }\n\t}\n\tcout << maxn << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <cstdio>\n#include <cstdint>\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cmath>\n#include <climits>\n#include <bitset>\n\n// macros\n#define ll long long int\n#define pb push_back\n#define mk make_pair\n#define pq priority_queue\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n\nusing namespace std;\n\n//  types\ntypedef pair<int, int> P;\ntypedef pair<ll, int> Pl;\ntypedef pair<ll, ll> Pll;\ntypedef pair<double, double> Pd;\n \n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 1e9 + 7;\n\n// solve\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\n\nvector<int> edge[5001];\nvector<int> child[5001];\nint par[5001], num[5001];\nll dp1[5001][5001], dp2[5001][5001];\n\nvoid dfs1(int i){\n  num[i] = 1;\n  rep(j, edge[i].size()){\n    int to = edge[i][j];\n    if(par[to] >= 0)continue;\n    par[to] = i;\n    child[i].pb(to);\n    dfs1(to);\n    num[i] += num[to];\n  }\n}\n\nvector<ll> a;\nint n;\n\nll dp[5001][5001];\n\nvoid dfs(int i){\n  rep(j, child[i].size()){\n    dfs(child[i][j]);\n  }\n  if(child[i].size() == 0){\n    if(a[i] < 0){\n      dp2[i][1] = a[i];\n    }else{\n      dp1[i][1] = dp2[i][1] = a[i];\n    }\n    return;\n  }\n  if(a[i] > 0){\n    dp[0][0] = linf;\n    dp[0][1] = a[i];\n    int curr = 1;\n    int prev = 1;\n    rep(j, child[i].size()){\n      int to = child[i][j];\n      curr += num[to];\n      rep(k, curr+1){\n        dp[j+1][k] = linf;\n        for(int l = max(1, k-prev); l <= k; l++){\n          if(l > num[to])break;\n          if((dp1[to][l] < linf || dp2[to][l] < 0))chmin(dp[j+1][k], dp[j][k-l]);\n        }\n        if(a[to] > 0){\n          for(int l = max(1, k+1-prev); l <= k; l++){\n            if(l > num[to])break;\n            chmin(dp[j+1][k], dp[j][k-l+1] + dp1[to][l]);\n          }\n        }\n      }\n      prev = curr;\n    }\n    rep(j, num[i]+1)dp1[i][j] = dp[child[i].size()][j];\n  }\n\n  dp[0][0] = linf;\n  dp[0][1] = a[i];\n  int curr = 1;\n  int prev = 1;\n  rep(j, child[i].size()){\n    int to = child[i][j];\n    curr += num[to];\n    rep(k, curr+1){\n      dp[j+1][k] = linf;\n        for(int l = max(1, k-prev); l <= k; l++){\n          if(l > num[to])break;\n          if((dp1[to][l] < linf || dp2[to][l] < 0))chmin(dp[j+1][k], dp[j][k-l]);\n        }\n        for(int l = max(1,k+1-prev); l <= k; l++){\n          if(l > num[to])break;\n          chmin(dp[j+1][k], dp[j][k-l+1] + dp1[to][l]);\n          chmin(dp[j+1][k], dp[j][k-l+1] + dp2[to][l]);\n        }\n    }\n    prev = curr;\n  }\n  rep(j, num[i]+1)dp2[i][j] = dp[child[i].size()][j];\n\n}\n\nint main(int argc, char const* argv[])\n{\n  cin >> n;\n  a = vector<ll>(n, 0);\n  rep(i, n)cin >> a[i];\n  rep(i, n - 1){\n    int x, y;\n    cin >> x >> y;\n    x--; y--;\n    edge[x].pb(y);\n    edge[y].pb(x);\n  }\n  fill(par, par + n, -1);\n  par[0] = 0;\n  dfs1(0);\n\n  rep(i, n+1){\n    rep(j, n+1){\n      dp1[i][j] = dp2[i][j] = linf;\n    }\n  }\n\n  dfs(0);\n  FOR(i, 1, n+1){\n    if(dp1[0][i] < linf || dp2[0][i] < 0){\n      cout << i - 1 << endl;\n      return 0;\n    }\n  }\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\nstruct UnionFind{\n  Int n;\n  vector<Int> r,p;\n  UnionFind(){}\n  UnionFind(Int sz):n(sz),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n  Int find(Int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(Int x,Int y){\n    return find(x)==find(y);\n  }\n  void unite(Int x,Int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];\n    p[y]=x;\n  }\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  auto shrink=\n    [&](){\n      Int n;\n      cin>>n;\n      vector<Int> a(n);\n      for(Int i=0;i<n;i++) cin>>a[i];\n      vector<vector<Int> > G(n);\n      for(Int i=1;i<n;i++){\n        Int x,y;\n        cin>>x>>y;\n        x--;y--;\n        G[x].emplace_back(y);\n        G[y].emplace_back(x);\n      }\n      UnionFind uf(n);\n      for(Int v=0;v<n;v++){\n        for(Int u:G[v]){\n          if(a[v]<0&&a[u]<0) uf.unite(u,v);\n          if(a[v]>0&&a[u]>0) uf.unite(u,v);\n        }\n      }\n      \n      vector<Int> vs;\n      for(Int i=0;i<n;i++){\n        if(uf.find(i)!=i) continue;\n        vs.emplace_back(i);\n      }\n      \n      Int m=vs.size();\n      map<Int, Int> rev;\n      for(Int i=0;i<m;i++) rev[vs[i]]=i;\n\n      vector<set<Int> > H(m);\n      vector<Int> na(m,0);\n      for(Int v=0;v<n;v++){\n        na[rev[uf.find(v)]]+=a[v];\n        for(Int u:G[v]){\n          if(uf.same(u,v)) continue;\n          Int x=rev[uf.find(v)],y=rev[uf.find(u)];\n          H[x].emplace(y);\n          H[y].emplace(x);\n        }\n      }\n      \n      vector<vector<Int> > nG(m);\n      for(Int i=0;i<m;i++) nG[i]=vector<Int>(H[i].begin(),H[i].end());\n      return make_tuple(m,na,nG);      \n    };\n  \n  auto graph=shrink();\n  auto n=get<0>(graph);\n  auto a=get<1>(graph);\n  auto G=get<2>(graph);\n  assert((Int)a.size()==n);\n  assert((Int)G.size()==n);\n\n  if(0){\n    cout<<n<<endl;\n    for(Int i=0;i<n;i++) cout<<a[i]<<\" \";\n    cout<<endl;\n    for(Int v=0;v<n;v++){\n      for(Int u:G[v]){\n        cout<<v<<\" \"<<u<<endl;\n      }\n    }\n  }\n  \n  if(n==1){\n    cout<<0<<endl;\n    return 0;\n  }\n\n  const Int INF = 1e17;\n  vector<vector<Int> > dp(n);\n  vector<Int> sum(n,0);\n  \n  function<void(Int, Int)> dfs=\n    [&](Int v,Int par){\n      for(Int u:G[v])\n        if(u!=par) dfs(u,v);\n      \n      dp[v].resize(1);\n      dp[v][0]=a[v];\n      for(Int u:G[v]){\n        if(u==par) continue;\n        const auto &p=dp[v];\n        const auto &q=dp[u];\n        Int x=p.size();\n        Int y=q.size();\n        vector<Int> nx(x+y,INF);\n        for(Int i=0;i<x;i++){\n          for(Int j=0;j<y;j++){\n            chmin(nx[i+j],p[i]+q[j]);\n            if(q[j]<0) chmin(nx[i+j+1],p[i]);\n          }\n        }\n        if(a[v]<0){          \n          for(Int i=0;i<x;i++)\n            if(i+sum[u]+1<x+y) chmin(nx[i+sum[u]+1],p[i]);\n        }else{\n          Int res=INF;\n          for(Int j=0;j<y;j++)\n            if(q[j]<0) chmin(res,j+1);\n          sum[v]+=res;\n        }\n        swap(dp[v],nx);\n      }      \n      //cout<<v<<\":\"<<a[v]<<endl;\n      //for(Int x:dp[v]) cout<<x<<\" \";\n      //cout<<endl<<endl;;\n    };\n\n  Int idx=0;\n  while(a[idx]>0) idx++;\n  assert(idx<n);\n  \n  dfs(idx,-1);\n  Int ans=n;\n  //cout<<n<<\":\"<<dp[idx].size()<<endl;\n  assert(n==(Int)dp[idx].size());\n  for(Int i=0;i<n;i++)\n    if(dp[idx][i]<0) chmin(ans,i);\n  \n  assert(ans<n);  \n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\nusing namespace std;\n\nint n, a[5000], sz[5000];\nvector<int> adj[5000];\nvector<long long> dp1[5000], dp2[5000];\nconst long long INF = 1LL<<60;\n\nvoid solve(int u, int p) {\n    sz[u] = 1;\n    dp1[u].resize(1, INF);\n    dp2[u].resize(1, INF);\n    if (a[u] > 0) dp1[u][0] = a[u];\n    dp2[u][0] = a[u];\n    for (int v : adj[u]) {\n        if (v == p) continue;\n        solve(v, u);\n        sz[u] += sz[v];\n        vector<long long> temp1(sz[u], INF), temp2(sz[u], INF);\n        for (int i = 0; i < sz[u]-sz[v]; i++) {\n            for (int j = 0; j < sz[v]; j++) {\n                if (dp1[u][i] < INF && dp1[v][j] < INF)\n                    temp1[i+j] = min(temp1[i+j], dp1[u][i] + dp1[v][j]);\n                if (i+j+1 < sz[u] && dp1[u][i] < INF && (dp1[v][j] < INF || dp2[v][j] < 0))\n                    temp1[i+j+1] = min(temp1[i+j+1], dp1[u][i]);\n                temp2[i+j] = min(temp2[i+j], min(dp2[u][i] + dp2[v][j], INF));\n                if (i+j+1 < sz[u] && (dp1[v][j] < INF || dp2[v][j] < 0))\n                    temp2[i+j+1] = min(temp2[i+j+1], dp2[u][i]);\n            }\n        }\n        dp1[u].swap(temp1);\n        dp2[u].swap(temp2);\n    }\n}\n\nint main() {\n    cin >> n;\n    for (int i = 0; i < n; i++) cin >> a[i];\n    for (int i = 1; i < n; i++) {\n        int u, v; cin >> u >> v;\n        adj[u-1].push_back(v-1);\n        adj[v-1].push_back(u-1);\n    }\n    solve(0, -1);\n    int ans = 0;\n    while (dp1[0][ans] == INF && dp2[0][ans] >= 0) ans++;\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nint n;\nint a[5000];\nlong long dp[5000][2][5000][2];\nvector <int> v[5000];\n\nint dfs(int x, int y) {\n    int c = 1, i, j, k, l, r;\n    \n    for (i = 0; i < n; i++) {\n        for (j = 0; j < 2; j++) {\n            dp[x][0][i][j] = dp[x][1][i][j] = 1e18;\n        }\n    }\n    \n    if (a[x] > 0) {\n        dp[x][0][0][1] = a[x];\n    } else {\n        dp[x][0][0][0] = a[x];\n    }\n    \n    for (i = 0; i < v[x].size(); i++) {\n        int nx = v[x][i], p;\n        \n        if (nx == y) continue;\n        \n        p = dfs(nx, x);\n        \n        for (j = 0; j < c; j++) {\n            for (k = 0; k < 2; k++) {\n                if (dp[x][0][j][k] == 1e18) continue;\n                \n                for (l = 0; l < p; l++) {\n                    for (r = 0; r < 2; r++) {\n                        if (dp[nx][0][l][r] == 1e18) continue;\n                        \n                        if (r == 1 || dp[nx][0][l][r] < 0) dp[x][1][j + l + 1][k] = min(dp[x][1][j + l + 1][k], dp[x][0][j][k]);\n                        dp[x][1][j + l][k & r] = min(dp[x][1][j + l][k & r], dp[x][0][j][k] + dp[nx][0][l][r]);\n                    }\n                }\n            }\n        }\n        \n        c += p;\n        \n        for (j = 0; j < c; j++) {\n            for (k = 0; k < 2; k++) {\n                dp[x][0][j][k] = dp[x][1][j][k];\n                dp[x][1][j][k] = 1e18;\n            }\n        }\n    }\n    \n    return c;\n}\n\nint main() {\n    int i;\n    \n    scanf(\"%d\", &n);\n    \n    for (i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n    \n    for (i = 0; i < n - 1; i++) {\n        int x, y;\n        \n        scanf(\"%d %d\", &x, &y);\n        \n        x--;\n        y--;\n        \n        v[x].push_back(y);\n        v[y].push_back(x);\n    }\n    \n    dfs(0, -1);\n    \n    for (i = 0; i < n; i++) {\n        if (dp[0][0][i][0] < 0 || dp[0][0][i][1] < 1e18) {\n            printf(\"%d\\n\", i);\n            \n            break;\n        }\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n#define dump(x) cout << #x << \" = \" << (x) << endl\n\ninline void chmin(ll &x, ll y) {\n\tif (x >= y) x = y;\n}\n\nconst int MN = 5010;\nconst ll INF = 1e18;\n\nint N;\nll A[MN];\nvi g[MN];\nll dp[MN][2][MN][2];\nll r[MN][MN][2];\nint sz[MN];\n\nvoid dfs(int v, int par) {\n\tsz[v] = 1;\n\tint c = 0;\n\n\tint p = 0, q = 1;\n\trep(t, 2) rep(j, MN) rep(k, 2) {\n\t\tdp[v][t][j][k] = INF;\n\t}\n\tdp[v][0][0][A[v] < 0] = A[v];\n\n\tfor (int to : g[v]) if (to != par) {\n\t\trep(j, MN) rep(k, 2) dp[v][q][j][k] = INF;\n\n\t\tdfs(to, v);\n\t\tsz[v] += sz[to];\n\n\t\tfor (int i = 0; i <= c; ++i) {\n\t\t\trep(f, 2) if (dp[v][p][i][f] != INF) {\t\n\t\t\t\tfor (int j = 0; j <= sz[to]; ++j) {\n\t\t\t\t\trep(k, 2) if (r[to][j][k] != INF) {\n\t\t\t\t\t\tchmin(dp[v][q][i + j][f | k], dp[v][p][i][f] + r[to][j][k]);\n\t\t\t\t\t\tif (k == 0 || r[to][j][k] < 0) {\n\t\t\t\t\t\t\tchmin(dp[v][q][i + j + 1][f], dp[v][p][i][f]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tc += sz[to];\n\t\tswap(p, q);\n\t}\n\n\trep(j, MN) rep(k, 2) {\n\t\tr[v][j][k] = dp[v][p][j][k];\n\t}\n}\n\nint main() {\n\tcin >> N;\n\trep(i, N) cin >> A[i];\n\trep(i, N-1) {\n\t\tint a, b; cin >> a >> b;\n\t\t--a; --b;\n\t\tg[a].pb(b); g[b].pb(a);\n\t}\n\tdfs(0, -1);\n\n\tint ans = N;\n\n\trep(j, MN) {\n\t\tif (r[0][j][0] != INF) {\n\t\t\tans = j;\n\t\t\tbreak;\n\t\t}\n\t\tif (r[0][j][1] < 0) {\n\t\t\tans = j;\n\t\t\tbreak;\n\t\t}\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint     = long long;\nconst lint inf = 1LL << 60;\nconst lint mod = 1000000007;\n\ntemplate <class T>\nbool chmax(T &a, const T &b) {\n    return (a < b) ? (a = b, 1) : 0;\n}\ntemplate <class T>\nbool chmin(T &a, const T &b) {\n    return (b < a) ? (a = b, 1) : 0;\n}\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    vector<lint> a(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n    }\n    vector<vector<int>> edges(n);\n    for (int i = 0; i < n - 1; ++i) {\n        int u, v;\n        cin >> u >> v;\n        u--, v--;\n        edges[u].emplace_back(v);\n        edges[v].emplace_back(u);\n    }\n    vector<vector<lint>> dp1(n + 1, vector<lint>(n + 1, inf)); // all battery\n    vector<vector<lint>> dp2(n + 1, vector<lint>(n + 1, inf)); // minimum elec\n    vector<lint> size(n, 1);\n    function<void(int, int)> dfss = [&](int c, int p) {\n        for (auto &v : edges[c]) {\n            if (v == p)\n                continue;\n            dfss(v, c);\n            size[c] += size[v];\n        }\n    };\n    dfss(0, -1);\n    function<void(int, int)> dfs = [&](int c, int p) {\n        bool first = true;\n        int s      = size[c];\n        vector<vector<lint>> d1(2, vector<lint>(n + 1, inf));\n        vector<vector<lint>> d2(2, vector<lint>(n + 1, inf));\n        for (auto &v : edges[c]) {\n            if (v == p)\n                continue;\n            dfs(v, c);\n            if (first) {\n                first = false;\n                for (int i = 0; i <= s; ++i) {\n                    if (a[c] > 0) {\n                        if (dp1[v][i] < inf) {\n                            chmin(d1[0][i], dp1[v][i] + a[c]);\n                            chmin(d1[0][i + 1], a[c]);\n                        }\n                        if (dp2[v][i] < 0)\n                            chmin(d1[0][i + 1], a[c]);\n                    }\n                    chmin(d2[0][i], dp2[v][i] + a[c]);\n                    if (dp2[v][i] < 0)\n                        chmin(d2[0][i + 1], a[c]);\n                    if (dp1[v][i] < inf)\n                        chmin(d2[0][i + 1], a[c]);\n                }\n            } else {\n                for (int i = s; i >= 0; --i) {\n                    for (int j = 0; j <= i; ++j) {\n                        // cut\n                        if (d1[0][j] < inf && dp1[v][i - j] < inf)\n                            chmin(d1[1][i + 1], d1[0][j]);\n                        if (d2[0][j] < inf && dp2[v][i - j] < 0)\n                            chmin(d2[1][i + 1], d2[0][j]);\n                        if (d2[0][j] < inf && dp1[v][i - j] < inf)\n                            chmin(d2[1][i + 1], d2[0][j]);\n                        if (d1[0][j] < inf && dp2[v][i - j] < 0)\n                            chmin(d1[1][i + 1], d1[0][j]);\n                        // no cut\n                        if (d1[0][j] < inf && dp1[v][i - j] < inf)\n                            chmin(d1[1][i], d1[0][j] + dp1[v][i - j]);\n                        if (d2[0][j] < inf && dp2[v][i - j] < inf)\n                            chmin(d2[1][i], d2[0][j] + dp2[v][i - j]);\n                        if (d2[0][j] < inf && dp1[v][i - j] < inf)\n                            chmin(d2[1][i], d2[0][j] + dp1[v][i - j]);\n                        if (d1[0][j] < inf && dp2[v][i - j] < inf)\n                            chmin(d2[1][i], d1[0][j] + dp2[v][i - j]);\n                    }\n                }\n                swap(d1[0], d1[1]);\n                swap(d2[0], d2[1]);\n            }\n        }\n        swap(dp1[c], d1[0]);\n        swap(dp2[c], d2[0]);\n        if (s == 1) {\n            dp2[c][0] = a[c];\n            if (a[c] > 0)\n                dp1[c][0] = a[c];\n        }\n    };\n    dfs(0, -1);\n    for (int i = 0; i < n; ++i) {\n        if (dp1[0][i] < inf || dp2[0][i] < 0) {\n            cout << i << \"\\n\";\n            return 0;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\nstruct UnionFind{\n  Int n;\n  vector<Int> r,p;\n  UnionFind(){}\n  UnionFind(Int sz):n(sz),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n  Int find(Int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(Int x,Int y){\n    return find(x)==find(y);\n  }\n  void unite(Int x,Int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];\n    p[y]=x;\n  }\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  auto shrink=\n    [&](){\n      Int n;\n      cin>>n;\n      vector<Int> a(n);\n      for(Int i=0;i<n;i++) cin>>a[i];\n      vector<vector<Int> > G(n);\n      for(Int i=1;i<n;i++){\n        Int x,y;\n        cin>>x>>y;\n        x--;y--;\n        G[x].emplace_back(y);\n        G[y].emplace_back(x);\n      }\n      UnionFind uf(n);\n      for(Int v=0;v<n;v++){\n        for(Int u:G[v]){\n          if(a[v]<0&&a[u]<0) uf.unite(u,v);\n          if(a[v]>0&&a[u]>0) uf.unite(u,v);\n        }\n      }\n      \n      vector<Int> vs;\n      for(Int i=0;i<n;i++){\n        if(uf.find(i)!=i) continue;\n        vs.emplace_back(i);\n      }\n      \n      Int m=vs.size();\n      map<Int, Int> rev;\n      for(Int i=0;i<m;i++) rev[vs[i]]=i;\n\n      vector<set<Int> > H(m);\n      vector<Int> na(m,0);\n      for(Int v=0;v<n;v++){\n        na[rev[uf.find(v)]]+=a[v];\n        for(Int u:G[v]){\n          if(uf.same(u,v)) continue;\n          Int x=rev[uf.find(v)],y=rev[uf.find(u)];\n          H[x].emplace(y);\n          H[y].emplace(x);\n        }\n      }\n      \n      vector<vector<Int> > nG(m);\n      for(Int i=0;i<m;i++) nG[i]=vector<Int>(H[i].begin(),H[i].end());\n      return make_tuple(m,na,nG);      \n    };\n  \n  auto graph=shrink();\n  auto n=get<0>(graph);\n  auto a=get<1>(graph);\n  auto G=get<2>(graph);\n  assert((Int)a.size()==n);\n  assert((Int)G.size()==n);\n\n  if(0){\n    cout<<n<<endl;\n    for(Int i=0;i<n;i++) cout<<a[i]<<\" \";\n    cout<<endl;\n    for(Int v=0;v<n;v++){\n      for(Int u:G[v]){\n        cout<<v<<\" \"<<u<<endl;\n      }\n    }\n  }\n  \n  if(n==1){\n    cout<<0<<endl;\n    return 0;\n  }\n\n  const Int INF = 1e17;\n  vector<vector<Int> > dp(n);\n  vector<Int> sum(n,0);\n  \n  function<void(Int, Int)> dfs=\n    [&](Int v,Int par){\n      for(Int u:G[v])\n        if(u!=par) dfs(u,v);\n      \n      dp[v].resize(1);\n      dp[v][0]=a[v];\n      for(Int u:G[v]){\n        if(u==par) continue;\n        const auto &p=dp[v];\n        const auto &q=dp[u];\n        Int x=p.size();\n        Int y=q.size();\n        vector<Int> nx(x+y,INF);\n        for(Int i=0;i<x;i++){\n          for(Int j=0;j<y;j++){\n            chmin(nx[i+j],p[i]+q[j]);\n            if(q[j]<0) chmin(nx[i+j+1],p[i]);\n          }\n        }\n        if(a[v]<0){          \n          for(Int i=0;i<x;i++)\n            if(i+sum[u]+1<x+y) chmin(nx[i+sum[u]+1],p[i]);          \n          for(Int i=0;i<x;i++)\n            if(i+sum[u]<x+y) chmin(nx[i+sum[u]],p[i]+a[u]);\n        }else{\n          Int res=INF;\n          for(Int j=0;j<y;j++)\n            if(q[j]<0) chmin(res,j+1);\n          sum[v]+=res;\n        }\n        swap(dp[v],nx);\n      }      \n      //cout<<v<<\":\"<<a[v]<<endl;\n      //for(Int x:dp[v]) cout<<x<<\" \";\n      //cout<<endl<<endl;;\n    };\n\n  Int idx=0;\n  while(a[idx]>0) idx++;\n  assert(idx<n);\n  \n  dfs(idx,-1);\n  Int ans=n;\n  //cout<<n<<\":\"<<dp[idx].size()<<endl;\n  assert(n==(Int)dp[idx].size());\n  for(Int i=0;i<n;i++)\n    if(dp[idx][i]<0) chmin(ans,i);\n  \n  assert(ans<n);  \n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#define vll vector<ll>\n#define vvvl vector<vvl>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d> >(a, vector<d>(b, c))\n#define VVV(a, b, c, d) vector<vvl>(a, vvl(b, vll (c, d)));\n#define re(c, b) for(ll c=0;c<b;c++)\n#define all(obj) (obj).begin(), (obj).end()\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\n\nvll num;\nll N;\nvvl G = VV(5001, 0, 0, ll);\nll INF = 1000000000000000000;\nvvvl dp = VVV(5001, 0, 0, INF);\n\nvoid dfs(ll now, ll from){\n  vvl prev = VV(N+1, 2, INF, ll);\n  vvl dat = VV(N+1, 2, INF, ll);\n  dat[1][0] = num[now];\n  if(num[now]>0) dat[1][1] = num[now];\n\n  for(auto to:G[now]){\n    if(to==from) continue;\n    dfs(to, now);\n\n    prev = dat;\n    dat = VV(N+1, 2, INF, ll);\n    ll minit_zero = INF, minit_one = INF;\n    for(int i=1;i<=N;i++){\n      if(dp[to][i][1]!=INF&&minit_one==INF) minit_one = i;\n      if(dp[to][i][0] < 0&&minit_zero==INF) minit_zero = i;\n    }\n    ll x = min(minit_one, minit_zero);\n\n    for(int i=1;i<=N;i++){\n      //分離\n      if(i+x>N) continue;\n      if(x!=INF){\n        dat[i+x][0] = min(dat[i+x][0], prev[i][0]);\n        dat[i+x][1] = min(dat[i+x][1], prev[i][1]);\n      }\n    }\n    for(int i=1;i<=N;i++){\n      for(int j=1;j<=N;j++){\n        if(i+j>N) continue;\n        //連結\n        dat[i+j-1][0] = min(dat[i+j-1][0],\n          prev[i][0] + dp[to][j][0]);\n        dat[i+j-1][1] = min(dat[i+j-1][1],\n          prev[i][1] + dp[to][j][1]);\n      }\n    }\n  }\n  dp[now] = dat;\n}\n\nint main(int argc, char const *argv[]) {\n  ll n;std::cin >> n;\n  N = n;\n  num.resize(n);\n  re(i, n) scanf(\"%lld\", &num[i]);\n  for(int i=0;i<n-1;i++){\n    ll a, b;scanf(\"%lld %lld\", &a, &b);\n    a--, b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  //幾らかの正のみで構成される部分を切って正、正、、、負にする\n  // dp[i][j][k] i以下でその部分木でj回カットしている場合の最小値\n  // kは今のところ全ての要素が正かのフラグ\n  // 0 <= i <= 5000, 0 <= j <= 5000, k = 0 or\n  dfs(0, -1);\n  for(int i=1;i<=N;i++){\n    if(dp[0][i][0]<0||dp[0][i][1]!=INF){\n      std::cout << i - 1 << '\\n';\n      return 0;\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fr(i,n) for(int i=0;i<(n);++i)\n#define foor(i,a,b) for(int i=(a);i<=(b);++i)\n#define rf(i,n) for(int i=(n);i-->0;)\n#define roof(i,b,a) for(int i=(b);i>=(a);--i)\n#define elsif else if\n#define all(x) x.begin(),x.end()\n#define Sort(x) sort(all(x))\n#define Reverse(x) reverse(all(x))\n#define PQ priority_queue\n#define NP(x) next_permutation(all(x))\n#define M_PI 3.14159265358979323846\n#define popcount __builtin_popcountll\nusing namespace std;            typedef vector<bool> vb; typedef vector<vb>  vvb;\n                                typedef vector<int>  vi; typedef vector<vi>  vvi;\ntypedef long long ll;           typedef vector< ll>  vl; typedef vector<vl>  vvl;\ntypedef unsigned long long ull; typedef vector<ull>  vu; typedef vector<vu>  vvu;\ntypedef double dbl;             typedef vector<dbl>  vd; typedef vector<vd>  vvd;\ntypedef string str;             typedef vector<str>  vs; typedef vector<vs>  vvs;\ntypedef pair<int,int>pii;       typedef vector<pii>vpii; typedef map<int,int>mii;\ntypedef pair< ll, ll>pll;       typedef vector<pll>vpll; typedef map< ll, ll>mll;\ntypedef pair<dbl,dbl>pdd;       typedef vector<pdd>vpdd; typedef map<dbl,dbl>mdd;\ntypedef pair<str,str>pss;       typedef vector<pss>vpss; typedef map<str,str>mss;\ntypedef pair<int, ll>pil;       typedef vector<pil>vpil; typedef map<int, ll>mil;\ntypedef pair< ll,int>pli;       typedef vector<pli>vpli; typedef map< ll,int>mli;\ntypedef pair<dbl,int>pdi;       typedef vector<pdi>vpdi; typedef map<dbl,int>mdi;\ntemplate<typename T>vector<T>&operator<<(vector<T>&v,const T t){v.push_back(t);return v;}\ntemplate<typename T>multiset<T>&operator<<(multiset<T>&m,const T t){m.insert(t);return m;}\ntemplate<typename T>set<T>&operator<<(set<T>&s,const T t){s.insert(t);return s;}\ntemplate<typename T>stack<T>&operator<<(stack<T>&s,const T t){s.push(t);return s;}\ntemplate<typename T>stack<T>&operator>>(stack<T>&s,T&t){t=s.top();s.pop();return s;}\ntemplate<typename T>queue<T>&operator<<(queue<T>&q,const T t){q.push(t);return q;}\ntemplate<typename T>queue<T>&operator>>(queue<T>&q,T&t){t=q.front();q.pop();return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator<<(PQ<T,vector<T>,U>&q,const T t){q.push(t);return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator>>(PQ<T,vector<T>,U>&q,T&t){t=q.top();q.pop();return q;}\ntemplate<typename T,typename U>istream&operator>>(istream&s,pair<T,U>&p){return s>>p.first>>p.second;}\nistream&operator>>(istream&s,_Bit_reference b){int a;s>>a;assert(a==0||a==1);b=a;return s;}\ntemplate<typename T>istream&operator>>(istream&s,vector<T>&v){fr(i,v.size()){s>>v[i];}return s;}\ntemplate<typename T,typename U>ostream&operator<<(ostream&s,const pair<T,U>p){return s<<p.first<<\" \"<<p.second;}\n//template<typename T>ostream&operator<<(ostream&s,const vector<T>v){for(auto a:v){s<<a<<\"\\n\";}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const vector<T>v){fr(i,v.size()){i?s<<\" \"<<v[i]:s<<v[i];}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const deque<T>d){fr(i,d.size()){i?s<<\" \"<<d[i]:s<<d[i];}return s;}\ntemplate<typename T>_Bit_reference operator&=(_Bit_reference b,T t){return b=b&t;}\ntemplate<typename T>_Bit_reference operator^=(_Bit_reference b,T t){return b=b^t;}\ntemplate<typename T>_Bit_reference operator|=(_Bit_reference b,T t){return b=b|t;}\ntemplate<typename T,typename U>pair<T,U>operator+(pair<T,U>a,pair<T,U>b){return {a.first+b.first,a.second+b.second};}\ntemplate<typename T,typename U>pair<T,U>operator-(pair<T,U>a,pair<T,U>b){return {a.first-b.first,a.second-b.second};}\ntemplate<typename T,typename U>pair<T,U>&operator+=(pair<T,U>&a,pair<T,U>b){return a=a+b;}\ntemplate<typename T,typename U>pair<T,U>&operator-=(pair<T,U>&a,pair<T,U>b){return a=a-b;}\nvoid print(void){cout<<\"\\n\";}\nvoid Print(void){cout<<endl;}\ntemplate<typename T>void print(T t){cout<<t<<\"\\n\";}\ntemplate<typename T>void Print(T t){cout<<t<<endl;}\ntemplate<typename T,typename...U>void print(T&&t,U&&...u){cout<<t<<\" \";print(forward<U>(u)...);}\ntemplate<typename T,typename...U>void Print(T&&t,U&&...u){cout<<t<<\" \";Print(forward<U>(u)...);}\nbool YN(bool b){print(b?\"YES\":\"NO\");return b;}bool PI(bool b){print(b?\"POSSIBLE\":\"IMPOSSIBLE\");return b;}\nbool Yn(bool b){print(b?\"Yes\":\"No\");return b;}bool Pi(bool b){print(b?\"Possible\":\"Impossible\");return b;}\nbool yn(bool b){print(b?\"yes\":\"no\");return b;}bool pi(bool b){print(b?\"possible\":\"impossible\");return b;}\nconst int e5=1e5;\nconst int e9=1e9;\nconst int MD=1e9+7;\nconst int md=998244353;\nconst ll e18=1e18;\ntemplate<typename T>str to_string(const T&n){ostringstream s;s<<n;return s.str();}\ntemplate<typename T>T&chmax(T&a,T b){return a=max(a,b);}\ntemplate<typename T>T&chmin(T&a,T b){return a=min(a,b);}\ntemplate<typename T,typename U>vector<pair<T,U>>dijkstra(const vector<vector<pair<T,U>>>&E,const U s,const T inf){using P=pair<T,U>;vector<P>d;fr(i,E.size()){d<<P{inf,i};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\ntemplate<typename T,typename U>map<U,pair<T,U>>dijkstra(map<U,vector<pair<T,U>>>E,const U s,const T inf){using P=pair<T,U>;map<U,P>d;for(pair<U,vector<P>>e:E){d[e.first]=P{inf,e.first};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\nll maxflow(vector<mil>&E,int s,int t){ll z=0;vi b(E.size(),-1);for(int i=0;;++i){static auto dfs=[&](int v,ll f,auto&dfs)->ll{if(v==t)return f;b[v]=i;for(auto&p:E[v]){if(b[p.first]<i&&p.second){if(ll r=dfs(p.first,min(f,p.second),dfs)){p.second-=r;E[p.first][v]+=r;return r;}}}return 0;};ll x=dfs(s,ll(1e18),dfs);z+=x;if(x==0)return z;}}\ntemplate<typename T>T distsq(pair<T,T>a,pair<T,T>b){return (a.first-b.first)*(a.first-b.first)+(a.second-b.second)*(a.second-b.second);}\ntemplate<typename T>T max(const vector<T>a){assert(a.size());T m=a[0];for(T e:a){m=max(m,e);}return m;}\ntemplate<typename T>T min(const vector<T>a){assert(a.size());T m=a[0];for(T e:a){m=min(m,e);}return m;}\ntemplate<typename T>T gcd(const T a,const T b){return a?gcd(b%a,a):b;}\ntemplate<typename T>T gcd(const vector<T>a){T g=a[0];for(T e:a){g=gcd(g,e);}return g;}\ntemplate<typename T>vector<T>LCS(vector<T>A,vector<T>B){int N=A.size(),M=B.size();vector<vector<pair<int,pii>>>d(N+1,vector<pair<int,pii>>(M+1));fr(i,N){fr(j,M){if(A[i]==B[j]){d[i+1][j+1]={d[i][j].first+1,{i,j}};}else{d[i+1][j+1]=max(d[i][j+1],d[i+1][j]);}}}vector<T>r;for(pii p={N,M};d[p.first][p.second].first;p=d[p.first][p.second].second){r<<A[d[p.first][p.second].second.first];}Reverse(r);return r;}\nstr LCS(str S,str T){vector<char>s=LCS(vector<char>(S.begin(),S.end()),vector<char>(T.begin(),T.end()));return str(s.begin(),s.end());}\ntemplate<typename T>vector<pair<T,T>>ConvexHull(vector<pair<T,T>>V){if(V.size()<=3){return V;}Sort(V);rf(i,V.size()-1)V<<V[i];vector<pair<T,T>>r;for(pair<T,T>p:V){int s=r.size();while(s>=2&&(p.second-r[s-1].second)*(p.first-r[s-2].first)<(p.second-r[s-2].second)*(p.first-r[s-1].first)){r.pop_back();--s;}r<<p;}r.pop_back();return r;}\nclass UnionFind{vi p,s;void extend(int N){foor(i,p.size(),N){p<<i;s<<1;}}public:UnionFind(void){}UnionFind(int N){extend(N-1);}int find(int i){extend(i);return p[i]=p[i]==i?i:find(p[i]);}void unite(int a,int b){extend(a);extend(b);if((a=find(a))!=(b=find(b))){if(s[a]>s[b]){swap(a,b);}s[b]+=s[a];p[a]=b;}}void unite(pii p){return unite(p.first,p.second);}bool same(int a,int b){extend(a);extend(b);return find(a)==find(b);}bool same(pii p){return same(p.first,p.second);}int size(int x){extend(x);return s[find(x)];}};\nll MST(vector<pair<ll,pii>>&E){Sort(E);UnionFind uf;ll z=0;for(auto&e:E){if(!uf.same(e.second)){z+=e.first;uf.unite(e.second);}}return z;}\nll strmod(const str&s,const int m){ll x=0;fr(i,s.size()){x=(x*10+s[i]-48)%m;}return x;}\nvvl mul(const vvl&A,const vvl&B,const int m){vvl C;fr(y,A.size()){C<<vl(B[y].size());}fr(y,C.size()){fr(x,C[y].size()){fr(i,A[0].size()){(C[y][x]+=A[y][i]*B[i][x])%=m;}}}return C;}\nvvl pow(const vvl&A,const ll n,const int m){vvl B;fr(y,A.size()){B<<vl(A.size());}if(n==0){fr(i,B.size()){B[i][i]=1;}}elsif(n%2){B=mul(A,pow(A,n-1,m),m);}else{vvl C=pow(A,n/2,m);B=mul(C,C,m);}return B;}\nll pow(const ll a,const ll n,const int m){ll t;return n?(n&1?a>=0?a%m:(m-(-a%m))%m:1)*(t=pow(a,n>>1,m),t*t%m)%m:!!a;}\nll inv(const ll x,const int p){assert(x!=0);return pow(x,p-2,p);}\nll inv(const ll x){return inv(x,MD);}\nvpll fact(const int n,const int p){assert(n<p);vpll v(n+1);v[0].first=1;foor(i,1,n){v[i].first=v[i-1].first*i%p;}v[n].second=inv(v[n].first,p);roof(i,n,1){v[i-1].second=v[i].second*i%p;}return v;}\nclass Combination{const vpll f;const int M;public:Combination(int n,int m):f(fact(n,m)),M(m){}Combination(int n):Combination(n,MD){}ll P(int n,int k){return n<0||k<0||n<k?0ll:f[n].first*f[n-k].second%M;}ll C(int n,int k){return k<0?0:P(n,k)*f[k].second%M;}ll H(int n,int k){return n==0&&k==0?1ll:C(n+k-1,k);}ll F(int n){return n<0?0:f[n].first;}};\nll C2(const int n){return(ll)n*~-n/2;}\nll sum(const vi a){ll s=0;for(int e:a){s+=e;}return s;}\nll sum(const vl a){ll s=0;for(ll e:a){s+=e;}return s;}\ntemplate<typename T>int MSB(T N){int r=-1;for(;N>0;N/=2){++r;}return r;}\ntemplate<typename T>class SegmentTree{vector<T>S;T(*const op)(T a,T b);const T zero;const int B;public:SegmentTree(int N,T(*f)(T a,T b),const T zero):S(1<<MSB(N-1)+2,zero),op(f),zero(zero),B(1<<MSB(N-1)+1){}SegmentTree(vector<T>v,T(*f)(T a,T b),const T zero):SegmentTree(v.size(),f,zero){fr(i,v.size()){S[S.size()/2+i]=v[i];}roof(i,S.size()/2-1,1){S[i]=op(S[i*2],S[i*2+1]);}}T calc(int l,int r){l+=B;r+=B;if(l>r){return zero;}if(l==r){return S[l];}T L=S[l],R=S[r];for(;l/2<r/2;l/=2,r/=2){if(l%2==0){L=op(L,S[l+1]);}if(r%2==1){R=op(S[r-1],R);}}return op(L,R);}void replace(int i,T x){for(S[i+=B]=x;i!=1;i/=2){if(i%2){S[i/2]=op(S[i-1],S[i]);}else{S[i/2]=op(S[i],S[i+1]);}}}void add(int i,T x){replace(i,op(S[B+i],x));}T top(){return S[1];}T get(int i){return S[i+B];}};\nll BITsum(vl&B,int i){ll z=0;while(i>0){z+=B[i];i-=i&-i;}return z;}\nvoid BITadd(vl&B,int i,ll x){while(i<B.size()){B[i]+=x;i+=i&-i;}}\nll fib(const ll n,const int m){ll a,b,c,d,A,B,C,D;a=1;b=0;c=0;d=1;rf(i,63){A=a*a+b*c;B=a*b+b*d;C=c*a+d*c;D=c*b+d*d;if(n>>i&1){a=A;b=B;c=C;d=D;A=a+b;B=a;C=c+d;D=c;}a=A%m;b=B%m;c=C%m;d=D%m;}return b;}\nvi primes(int n){vb b(n+1);vi p;foor(i,2,n){if(!b[i]){p<<i;for(int j=2*i;j<=n;j+=i){b[j]=true;}}}return p;}\nvb isprime(const int n){vb v(n+1,true);v[0]=v[1]=false;foor(i,2,n){if(v[i]){for(int j=2*i;j<=n;j+=i){v[j]=false;}}}return v;}\nclass LCA{vvi par;vi dep;public:LCA(vvi&E,int root):par(MSB(E.size())+1,vi(E.size())),dep(E.size()){function<void(int,int)>dfs=[&](int i,int p){for(int j:E[i])if(j!=p){par[0][j]=i;dep[j]=dep[i]+1;dfs(j,i);}};par[0][root]=root;dfs(root,root);fr(i,par.size()-1){fr(j,par[0].size()){par[i+1][j]=par[i][par[i][j]];}}}int operator()(int a,int b){if(dep[a]>dep[b])swap(a,b);for(int t=dep[b]-dep[a],i=0;t;t>>=1,++i){if(t&1){b=par[i][b];}}if(a==b)return a;rf(i,par.size()){if(par[i][a]!=par[i][b]){a=par[i][a];b=par[i][b];}}return par[0][a];}};\nvpli factor(ll N){vpli r;for(ll i=2;i*i<=N;++i){if(N%i==0){r<<pli{i,0};while(N%i==0){N/=i;++r.back().second;}}}if(N>1){r<<pli{N,1};}return r;}\nvl divisors(ll n){vl r;ll m=sqrt(n);foor(i,1,m)if(n%i==0)r<<ll(i);rf(i,r.size()-(m*m==n))r<<n/r[i];return r;}\nvi SuffixArray(str S){int N=S.size();vi rank(N+1),tmp(N+1),sa(N+1);fr(i,N){sa[i]=i;rank[i]=S[i];}sa[N]=N;rank[N]=-1;int k;auto cmp=[&](int&a,int&b)->bool{if(rank[a]!=rank[b])return rank[a]<rank[b];return (a+k<=N?rank[a+k]:-1)<(b+k<=N?rank[b+k]:-1);};for(k=1;k<=N;k*=2){sort(all(sa),cmp);tmp[sa[0]]=0;foor(i,1,N){tmp[sa[i]]=tmp[sa[i-1]]+cmp(sa[i-1],sa[i]);}rank=tmp;}return sa;};\n\nint main(){cin.tie(0);ios::sync_with_stdio(false);\n\tint N;cin>>N;\n\tvi V(N);cin>>V;\n\tvvi E(N);\n\t{\n\t\tUnionFind uf;\n\t\tvi A(N-1),B(N-1);\n\t\tfr(i,N-1){\n\t\t\tcin>>A[i]>>B[i];\n\t\t\t--A[i];--B[i];\n\t\t\tif(V[A[i]]<0&&V[B[i]]<0){\n\t\t\t\tint a=uf.find(A[i]),b=uf.find(B[i]);\n\t\t\t\tint v=V[a]+V[b];\n\t\t\t\tuf.unite(A[i],B[i]);\n\t\t\t\tV[uf.find(A[i])]=v;\n\t\t\t\tV[a==uf.find(A[i])?b:a]=0;\n\t\t\t}\n\t\t}\n\t\tfr(i,N-1){\n\t\t\tint a=uf.find(A[i]),b=uf.find(B[i]);\n\t\t\tif(a!=b){\n\t\t\t\tE[a]<<b;\n\t\t\t\tE[b]<<a;\n\t\t\t}\n\t\t}\n\t}\n \treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> v2l;\ntypedef vector<bool> vb;\ntypedef vector<vb> v2b;\n\nconst ll AMAX = 1e13;\n\nstruct node {\n    vl dp1;\n    vb dp2;\n    int sz;\n};\n\nnode dfs(vi e[], int a[], int x, int p) {\n    node ret;\n    ret.sz = 1;\n    ret.dp1 = {a[x]};\n    ret.dp2 = {a[x] > 0};\n\n    for (int y : e[x]) {\n        if (y == p) {\n            continue;\n        }\n\n        node t = dfs(e, a, y, x);\n        ret.dp1.resize(ret.sz + t.sz, AMAX);\n        ret.dp2.resize(ret.sz + t.sz, false);\n\n        for (int i = ret.sz - 1; i >= 0; i--) {\n            for (int j = t.sz - 1; j >= 0; j--) {\n                if (j > 0) {\n                    ret.dp1[i+j] = min(ret.dp1[i+j], ret.dp1[i] + t.dp1[j]);\n                    ret.dp2[i+j] = ret.dp2[i+j] || ret.dp2[i] && t.dp2[j];\n                }\n                if (t.dp1[j] < 0 || t.dp2[j]) {\n                    ret.dp1[i+j+1] = min(ret.dp1[i+j+1], ret.dp1[i]);\n                    ret.dp2[i+j+1] = ret.dp2[i+j+1] || ret.dp2[i];\n                }\n            }\n            ret.dp1[i] = min(AMAX, ret.dp1[i] + t.dp1[0]);\n            ret.dp2[i] = ret.dp2[i] && t.dp2[0];\n        }\n\n        ret.sz += t.sz;\n    }\n\n    return ret;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    int a[n];\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n    vi e[n];\n    for (int i = 0; i < n - 1; i++) {\n        int u, v;\n        cin >> u >> v;\n        u--, v--;\n        e[u].push_back(v);\n        e[v].push_back(u);\n    }\n\n    node res = dfs(e, a, 0, -1);\n\n    for (int i = 0; i < n; i++) {\n        if (res.dp1[i] < 0 || res.dp2[i]) {\n            cout << i << endl;\n            return 0;\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 0x3f3f3f3f\nusing namespace std;\ntypedef long long ll;\nconst int N=5005;\nint n,a[N],si[N],tot,head[N],nex[N<<1],to[N<<1];\nvoid add(int u,int v){to[++tot]=v;nex[tot]=head[u];head[u]=tot;}\nll dp[N][N][2],f[N][2];\nvoid dfs(int u,int p)\n{\n    if(a[u]<0) dp[u][1][1]=a[u];\n    else dp[u][1][0]=a[u];\n    si[u]=1;\n    for(int i=head[u];i;i=nex[i])\n    {\n        int v=to[i];if(v==p) continue;\n        dfs(v,u);\n        memset(f,inf,sizeof(f));\n        for(int j=1;j<=si[u];j++)\n            for(int k=1;k<=si[v];k++)\n        {\n            if((dp[v][k][0]<inf||dp[v][k][1]<0)&&dp[u][j][0]<inf)\n                f[j+k][0]=min(f[j+k][0],dp[u][j][0]);\n            if((dp[v][k][0]<inf||dp[v][k][1]<0)&&dp[u][j][1]<inf)\n                f[j+k][1]=min(f[j+k][1],dp[u][j][1]);\n            for(int h=0;h<2;h++)\n                for(int p=0;p<2;p++)\n                if(dp[u][j][h]<inf&&dp[v][k][p]<inf)\n                f[j+k-1][h|p]=min(f[j+k-1][h|p],dp[u][j][h]+dp[v][k][p]);\n        }\n        si[u]+=si[v];\n        for(int j=1;j<=si[u];j++)\n            dp[u][j][0]=f[j][0],dp[u][j][1]=f[j][1];\n    }\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n    for(int i=1;i<n;i++)\n    {\n        int u,v;scanf(\"%d%d\",&u,&v);\n        add(u,v);add(v,u);\n    }\n    memset(dp,inf,sizeof(dp));\n    dfs(1,0);\n    int ans=n-1;\n    for(int i=1;i<=n;i++)\n        if(dp[1][i][0]<inf||dp[1][i][1]<0){ans=i-1;break;}\n    memset(dp,inf,sizeof(dp));\n    dfs(n,0);\n    for(int i=1;i<=n;i++)\n        if(dp[n][i][0]<inf||dp[n][i][1]<0){ans=i-1;break;}\n    printf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nint n;\nint a[6005];\nint sz[6005];\nint dp[6005][6005][2];\nvector<int> adj[100005];\nint dp1[6005][2];\n\nvoid ddp(int node, int fa)\n{\n\t//cout<<\"AT \"<<node<<endl;\n\tsz[node]=1;\n\tfor(int i=0; i<=n; i++)\n\t{\n\t\tdp[node][i][0]=10000000000000;\n\t\tdp[node][i][1]=10000000000000;\n\t}\n\tif(a[node]>0) dp[node][0][0]=a[node];\n\telse dp[node][0][1]=a[node];\n\tfor(auto i:adj[node])\n\t{\n\t\tif(i==fa) continue;\n\t\tddp(i, node);\n\t\tfor(int j=0; j<=n; j++)\n\t\t{\n\t\t\tdp1[j][0]=10000000000000;\n\t\t\tdp1[j][1]=10000000000000;\n\t\t}\n\t\tfor(int sn=0; sn<sz[node]; sn++)\n\t\t{\n\t\t\tfor(int si=0; si<sz[i]; si++)\n\t\t\t{\n\t\t\t\tdp1[sn+si][0]=min(dp1[sn+si][0], dp[node][sn][0]+dp[i][si][0]);\n\t\t\t\tdp1[sn+si][1]=min(dp1[sn+si][1], min(dp[node][sn][1]+dp[i][si][1], min(dp[node][sn][0]+dp[i][si][1], dp[node][sn][1]+dp[i][si][0])));\n\t\t\t\tif(dp[i][si][1]<0)\n\t\t\t\t{\n\t\t\t\t\tdp1[sn+si+1][0]=min(dp1[sn+si+1][0], dp[node][sn][0]);\n\t\t\t\t\tdp1[sn+si+1][1]=min(dp1[sn+si+1][1], dp[node][sn][1]);\n\t\t\t\t}\n\t\t\t\tif(dp[i][si][0]<10000000000000)\n\t\t\t\t{\n\t\t\t\t\tdp1[sn+si+1][0]=min(dp1[sn+si+1][0], dp[node][sn][0]);\n\t\t\t\t\tdp1[sn+si+1][1]=min(dp1[sn+si+1][1], dp[node][sn][1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j=0; j<=n; j++)\n\t\t{\n\t\t\tdp[node][j][0]=dp1[j][0];\n\t\t\tdp[node][j][1]=dp1[j][1];\n\t\t}\n\t\tsz[node]+=sz[i];\n\t}\n}\n\nsigned main()\n{\n\tcin>>n;\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tcin>>a[i];\n\t}\n\tfor(int i=1; i<n; i++)\n\t{\n\t\tint u, v;\n\t\tcin>>u>>v;\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\tddp(1, 1);\n\tfor(int i=0; i<=n; i++)\n\t{\n\t\tif(dp[1][i][0]<10000000000000||dp[1][i][1]<0)\n\t\t{\n\t\t\t//cout<<dp[1][i][0]<<\" \"<<dp[1][i][1]<<endl;\n\t\t\tcout<<i;\n\t\t\treturn 0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int64 INF = 1LL << 58;\n\nvector< int > g[5000];\nint N, A[5000];\nvector< bool > latte[5000];\nvector< int64 > malta[5000];\n\nvoid chmin(int64 &a, int64 b) { a = min(a, b); }\n\nvoid dfs(int idx, int par) {\n  for(auto &to : g[idx]) {\n    if(to == par) continue;\n    dfs(to, idx);\n  }\n\n  latte[idx].emplace_back(A[idx] > 0);\n  for(auto &to : g[idx]) {\n    if(to == par) continue;\n    if(A[to] > 0) {\n      vector< bool > nxt(latte[idx].size() + latte[to].size());\n      for(int i = 0; i < latte[idx].size(); i++) {\n        for(int j = 0; j < latte[to].size(); j++) {\n          if(latte[idx][i] & latte[to][j]) {\n            nxt[i + j] = true;\n          }\n        }\n        for(int j = 0; j < malta[to].size(); j++) {\n          if(!latte[idx][i] || malta[to][j] >= 0) continue;\n          nxt[i + j + 1] = true;\n        }\n      }\n      latte[idx].swap(nxt);\n    } else {\n      vector< bool > nxt(latte[idx].size() + latte[to].size());\n      for(int i = 0; i < latte[idx].size(); i++) {\n        for(int j = 0; j < malta[to].size(); j++) {\n          if(!latte[idx][i] || malta[to][j] >= 0) continue;\n          nxt[i + j + 1] = true;\n        }\n      }\n      latte[idx].swap(nxt);\n    }\n  }\n\n\n  malta[idx].emplace_back(A[idx]);\n  for(auto &to : g[idx]) {\n    if(to == par) continue;\n    vector< int64 > nxt(malta[idx].size() + malta[to].size(), INF);\n    for(int i = 0; i < malta[idx].size(); i++) {\n      for(int j = 0; j < latte[to].size(); j++) {\n        if(latte[to][j]) chmin(nxt[i + j + 1], malta[idx][i]);\n      }\n      for(int j = 0; j < malta[to].size(); j++) {\n        if(malta[idx][j] == INF) continue;\n        if(malta[to][j] == INF) continue;\n        chmin(nxt[i + j], malta[idx][i] + malta[to][j]);\n      }\n    }\n    malta[idx].swap(nxt);\n  }\n\n  for(int i = 0; i < malta[idx].size(); i++) {\n    if(malta[idx][i] < 0) latte[idx][i] = true;\n  }\n\n}\n\n\nint main() {\n  cin >> N;\n  for(int i = 0; i < N; i++) cin >> A[i];\n  for(int i = 1; i < N; i++) {\n    int x, y;\n    cin >> x >> y;\n    --x, --y;\n    g[x].emplace_back(y);\n    g[y].emplace_back(x);\n  }\n  dfs(0, -1);\n  for(int i = 0; i < latte[0].size(); i++) {\n    if(latte[0][i]) {\n      cout << i << endl;\n      exit(0);\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define beg(x) x.begin()\n#define en(x) x.end()\n#define all(x) beg(x), en(x)\n#define resz resize\n\nconst int MOD = 1000000007; // 998244353\nconst ll INF = 1e18;\nconst int MX = 200005;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; // const needed for vector<bool>\n        pr(\"}\");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) { \n        pr(first); ps(); // no space at end of line\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,\" \"); ps(rest...); // print w/ spaces\n    }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\n    T x = invGeneral(b,a); \n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n    T val; \n    explicit operator T() const { return val; }\n    modular() { val = 0; }\n    template<class U> modular(const U& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD;\n    }\n    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n\n    modular operator-() const { return modular(-val); }\n    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n    friend modular exp(modular a, ll p) {\n        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans;\n    }\n    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); } \n    // inv is equivalent to return exp(b,b.mod-2) if prime\n    modular& operator/=(const modular& m) { return (*this) *= inv(m); }\n    \n    friend modular operator+(modular a, const modular& b) { return a += b; }\n    friend modular operator-(modular a, const modular& b) { return a -= b; }\n    friend modular operator*(modular a, const modular& b) { return a *= b; }\n    \n    friend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nint N, A[5001];\nvi adj[5001];\narray<vl,2> dp[5001];\n\nvoid check(vl& a, int b, ll c) {\n    while (sz(a) <= b) a.pb(INF);\n    ckmin(a[b],c);\n}\n\narray<vl,2> cut(array<vl,2> x) {\n    array<vl,2> X = x;\n    F0R(a,2) F0R(b,sz(x[a])) if (x[a][b] != INF)\n        if (a == 0 || x[a][b] < 0) check(X[0],b+1,0);\n    return X;\n    // 0 or sum < 0\n}\n\narray<vl,2> comb(array<vl,2> x, array<vl,2> y) {\n    array<vl,2> res;\n    F0R(a,2) F0R(b,sz(x[a])) if (x[a][b] != INF) \n        F0R(c,2) F0R(d,sz(y[c])) if (y[c][d] != INF) \n            check(res[a|c],b+d,x[a][b]+y[c][d]);\n    return res;\n}\n\nvoid dfs(int a, int b) {\n    dp[a][A[a]<0] = {A[a]};\n    trav(t,adj[a]) if (t != b) {\n        dfs(t,a); dp[t] = cut(dp[t]);\n        // ps(\"HA\",t,dp[t]);\n        dp[a] = comb(dp[a],dp[t]);\n    }\n}\n\nint main() {\n    setIO(); re(N); FOR(i,1,N+1) re(A[i]);\n    F0R(i,N-1) {\n        int u,v; re(u,v);\n        adj[u].pb(v), adj[v].pb(u);\n    }\n    dfs(1,0);\n    int ret = MOD;\n    array<vl,2> x = dp[1];\n    F0R(a,2) F0R(b,sz(x[a])) if (x[a][b] != INF)\n        if (a == 0 || x[a][b] < 0) ckmin(ret,b+1);\n    ps(ret-1);\n}\n\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <utility>\n#define maxn 5005\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst ll infll = 0x3f3f3f3f3f3f3f3fll;\nint n,siz[maxn];\nll a[maxn],f[2][maxn][maxn],tmp[maxn];\nvector <int> adj[maxn];\nvoid work_size(int u,int f){\n\tfor(int i = 0;i < (int)adj[u].size();i++){\n\t\tint v = adj[u][i];\n\t\tif(v == f) continue;\n\t\twork_size(v,u);\n\t\tsiz[u] += siz[v] + 1;\n\t}\n}\ninline bool able(int u,int i){\n\treturn f[0][u][i] < 0 || f[1][u][i] < infll;\n}\nvoid dfs(int u,int fa){\n\tif((int)adj[u].size() == (fa != -1)){\n\t\tf[0][u][0] = a[u];\n\t\tif(a[u] > 0) f[1][u][0] = a[u];\n\t\treturn;\n\t}\n\tint v;\n\tfor(int i = 0;i < (int)adj[u].size();i++){\n\t\tv = adj[u][i];\n\t\tif(v != fa) dfs(v,u);\n\t}\n\tint fir = 0;\n\tif(adj[u][fir] == fa) fir++;\n\tv = adj[u][fir];\n\tfor(int i = 0;i <= siz[v];i++){\n\t\tf[0][u][i] = min(f[0][u][i],f[0][v][i] + a[u]);\n\t\tif(able(v,i)) f[0][u][i + 1] = min(f[0][u][i + 1],a[u]);\n\t}\n\tint totsiz = siz[v] + 1;\n\tfor(int i = fir + 1;i < (int)adj[u].size();i++){\n\t\tv = adj[u][i];\n\t\tif(v == fa) continue;\n\t\tfor(int j = 0;j <= totsiz + siz[v] + 1;j++) tmp[j] = infll;\n\t\tfor(int j1 = totsiz;j1 >= 0;j1--){\n\t\t\tfor(int j2 = siz[v];j2 >= 0;j2--){\n\t\t\t\ttmp[j1 + j2] = min(tmp[j1 + j2],f[0][u][j1] + f[0][v][j2]);\n\t\t\t\tif(able(v,j2)) tmp[j1 + j2 + 1] = min(tmp[j1 + j2 + 1],f[0][u][j1]);\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0;j <= totsiz + siz[v] + 1;j++) f[0][u][j] = tmp[j];\n\t\ttotsiz += siz[v] + 1;\n\t}\n\tif(a[u] < 0) return;\n\tv = adj[u][fir];\n\tfor(int i = 0;i <= siz[v];i++){\n\t\tf[1][u][i] = min(f[1][u][i],f[1][v][i] + a[u]);\n\t\tif(able(v,i)) f[1][u][i + 1] = min(f[1][u][i + 1],a[u]);\n\t}\n\ttotsiz = siz[v] + 1;\n\tfor(int i = fir + 1;i < (int)adj[u].size();i++){\n\t\tv = adj[u][i];\n\t\tif(v == fa) continue;\n\t\tfor(int j = 0;j <= totsiz + siz[v] + 1;j++) tmp[j] = infll;\n\t\tfor(int j1 = totsiz;j1 >= 0;j1--){\n\t\t\tfor(int j2 = siz[v];j2 >= 0;j2--){\n\t\t\t\ttmp[j1 + j2] = min(tmp[j1 + j2],f[1][u][j1] + f[1][v][j2]);\n\t\t\t\tif(able(v,j2)) tmp[j1 + j2 + 1] = min(tmp[j1 + j2 + 1],f[1][u][j1]);\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0;j <= totsiz + siz[v] + 1;j++) f[1][u][j] = tmp[j];\n\t\ttotsiz += siz[v] + 1;\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i = 1;i <= n;i++) scanf(\"%lld\",&a[i]);\n\tfor(int i = 1;i < n;i++){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\twork_size(1,-1);\n\tmemset(f,0x3f,sizeof(f));\n\tdfs(1,-1);\n\tfor(int i = 0;i <= n - 1;i++){\n\t\tif(able(1,i)){\n\t\t\tprintf(\"%d\\n\",i);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <unordered_map>\n#include <vector>\n#include <string.h>\n#include <set>\n#include <stack>\n\nusing namespace std;\n\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n\ntemplate<class T> void printvec(const vector<T>& v) {\n  for (auto x : v) { cout << x << \" \"; }\n  cout << endl;\n}\ntemplate<class T> void printtree(const vector< vector<T> >& tree) {\n  for (long long i = 0; i < tree.size(); ++i) {\n    cout << i + 1 << \": \"; printvec(tree[i]);\n  }\n}\ntemplate<class T, class U> void printmap(const map<T, U>& mp) {\n  for (auto x : mp) { cout << x.first << \"=>\" << x.second << endl; }\n}\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\n#define rep(i, n) for(ll i = 0; i < n; ++i)\n#define all(s) s.begin(), s.end()\n#define sz(x) (ll)(x).size()\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef tuple<ll, ll, ll> triple;\ntypedef double D;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\n\nconst ll INF = 1e15;\nconst ll MOD = 1000000007;  // 1e9 + 7\n\nvector<ll> a;\nvector<vector<ll>> g;\n\n// dp1[v][k] .. sum of a[u] in connected component including v where all a[u] > 0. Other connected components are valid.\n// dp2[v][k] .. sum of a[u] in connected component including v. Other connected components are valid.\nvector<vector<ll>> dp1, dp2;\n\n// flg .. if true, consider only positive value.\nvector<ll> tr(const vector<ll>& dp, const vector<ll>& ch1, const vector<ll>& ch2, bool flg) {\n  ll n = dp.size();\n  ll m = ch1.size();\n\n  vector<ll> ans(n+m-1, INF);\n  rep(i, n) {\n    if (dp[i] == INF) { continue; } // invalid\n    rep(j, m) {\n      // Update \"i+j-1\" as i and j is connected (it means -1). j must not be INF.\n      if (i+j-1 >= 0) {\n        if (ch1[j] != INF)         { chmin(ans[i+j-1], dp[i]+ch1[j]); }\n        if (ch2[j] != INF && !flg) { chmin(ans[i+j-1], dp[i]+ch2[j]); }\n      }\n      // Update \"i+j\" as i is separated from j and j is vaid.\n      if (ch1[j] != INF) { chmin(ans[i+j], dp[i]); }\n      if (ch2[j] < 0)    { chmin(ans[i+j], dp[i]); }\n    }\n  }\n  return ans;\n}\n\nvoid dfs(int v, int p = -1) {\n  dp1[v].push_back(INF);\n  dp1[v].push_back(a[v] > 0 ? a[v] : INF); // NOTE: Treat as INF when s[v] is not possitive. It is invalid in this case.\n  dp2[v].push_back(INF);\n  dp2[v].push_back(a[v]);\n  for (ll u : g[v]) {\n    if (u == p) { continue; }\n    dfs(u,v);\n    dp1[v] = tr(dp1[v], dp1[u], dp2[u], true);\n    dp2[v] = tr(dp2[v], dp1[u], dp2[u], false);\n  }\n}\n\nint main(int argc, char** argv) {\n  cin.tie(NULL);\n  cout.tie(NULL);\n  ios_base::sync_with_stdio(false);\n  //cout << setprecision(10) << fixed;\n\n  ll n;\n  cin >> n;\n  a.resize(n);\n  g.resize(n);\n  dp1.resize(n);\n  dp2.resize(n);\n  rep(i,n) {\n    cin >> a[i];\n  }\n  rep(i,n-1) {\n    ll u,v;\n    cin >> u >> v;\n    --u;--v;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  dfs(0);\n\n  ll ans = -1;\n  rep(i,n+1) {\n    if (dp1[0][i] < INF) { ans = i-1; break;; } // all positive\n    if (dp2[0][i] < 0) { ans = i-1; break; } // sum is minus\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define llint long long\n#define inf 100000000000000000\n\nusing namespace std;\n\nllint n;\nllint a[5005];\nvector<llint> G[5005];\nllint dp[5005][5005][2];\nllint dp2[5005][5005][2];\nllint size[5005];\n\nvoid dfs(int v, int p)\n{\n\tsize[v] = 1;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(G[v][i] == p) continue;\n\t\tdfs(G[v][i], v);\n\t\tsize[v] += size[G[v][i]];\n\t}\n\t\n\tllint sum = 1;\n\tfor(int i = 0; i <= sum; i++){\n\t\tfor(int j = 0; j < 2; j++){\n\t\t\tdp2[0][i][j] = inf;\n\t\t}\n\t}\n\tif(a[v] < 0) dp2[0][0][1] = a[v];\n\telse dp2[0][0][0] = a[v];\n\t\n\t\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(G[v][i] == p){\n\t\t\tfor(int j = 0; j <= sum; j++){\n\t\t\t\tfor(int k = 0; k < 2; k++){\n\t\t\t\t\tdp2[i+1][j][k] = dp2[i][j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tint u = G[v][i];\n\t\tfor(int j = 0; j <= sum+size[u]; j++){\n\t\t\tfor(int k = 0; k < 2; k++){\n\t\t\t\tdp2[i+1][j][k] = inf;\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0; j <= sum; j++){\n\t\t\tfor(int k = 0; k < 2; k++){\n\t\t\t\tfor(int l = 0; l <= size[u]; l++){\n\t\t\t\t\tfor(int m = 0; m < 2; m++){\n\t\t\t\t\t\tdp2[i+1][j+l][max(k, m)] = min(dp2[i+1][j+l][max(k, m)], dp2[i][j][k] + dp[u][l][m]);\n\t\t\t\t\t\tif((m == 0 && dp[u][l][m] < inf/2) || dp[u][l][m] < 0) dp2[i+1][j+l+1][k] = min(dp2[i+1][j+l+1][k], dp2[i][j][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsum += size[u];\n\t}\n\tfor(int i = 0; i <= size[v]; i++){\n\t\tfor(int j = 0; j < 2; j++){\n\t\t\tdp[v][i][j] = dp2[G[v].size()][i][j];\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\tcin >> n;\n\tfor(int i = 1; i <= n; i++) cin >> a[i];\n\tllint u, v;\n\tfor(int i = 1; i <= n-1; i++){\n\t\tcin >> u >> v;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\t\n\tdfs(1, -1);\n\t\n\tint ans = n;\n\tfor(int i = 0; i <= n; i++){\n\t\tif(dp[1][i][0] < inf/2) ans = min(ans, i);\n\t\tif(dp[1][i][1] < 0) ans = min(ans, i);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1LL<<60)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n;\nll a[5005];\nll a2[5005];\nvector<int> G[5005];\nvector<int> G2[5005];\nint cmp[5005];\nll dp[5005][5005][2];\nint sz[5005];\n\nvoid dfs(int v,int c){\n    cmp[v]=c;\n    if(a[v]<0LL)return;\n    for(int i=0;i<G[v].size();i++){\n        int nv=G[v][i];\n        if(a[nv]>0 && cmp[nv]==-1){\n            dfs(nv,c);\n        }\n    }\n}\n\nint dfs2(int v,int p){\n    sz[v]=1;\n    for(int i=0;i<G2[v].size();i++){\n        int nv=G2[v][i];\n        if(nv!=p){\n            sz[v]+=dfs2(nv,v);\n        }\n    }\n    return sz[v];\n}\n\nll tmp[5005][2];\n\nvoid dfs3(int v,int p){\n    int szc=1;\n    dp[v][0][0]=a2[v];\n    for(int i=0;i<G2[v].size();i++){\n        int nv=G2[v][i];\n        if(nv==p)continue;\n        dfs3(nv,v);\n        for(int j=0;j<=szc+sz[nv];j++){\n            tmp[j][0]=1LL<<60;\n            tmp[j][1]=1LL<<60;\n        }\n        for(int j=0;j<szc;j++){\n            for(int k=0;k<sz[nv];k++){\n                tmp[j+k][1]=min(tmp[j+k][1],dp[v][j][0]+dp[nv][k][0]);\n                tmp[j+k][1]=min(tmp[j+k][1],dp[v][j][1]+dp[nv][k][0]);\n                tmp[j+k][1]=min(tmp[j+k][1],dp[v][j][0]+dp[nv][k][1]);\n                tmp[j+k][1]=min(tmp[j+k][1],dp[v][j][1]+dp[nv][k][1]);\n                if(dp[nv][k][1]<0LL || dp[nv][k][0]!=INF)tmp[j+k+1][1]=min(tmp[j+k+1][1],dp[v][j][1]);\n                if(dp[nv][k][1]<0LL || dp[nv][k][0]!=INF)tmp[j+k+1][0]=min(tmp[j+k+1][0],dp[v][j][0]);\n            }\n        }\n        for(int j=0;j<=szc+sz[nv];j++){\n            dp[v][j][0]=tmp[j][0];\n            dp[v][j][1]=tmp[j][1];\n        }\n        szc+=sz[nv];\n    }\n    /*\n    printf(\"%d\\n\",v);\n    for(int i=0;i<=szc;i++){\n        printf(\"%lld %lld\\n\",dp[v][i][0],dp[v][i][1]);\n    }\n     */\n}\n\nint main(void){\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%lld\",&a[i]);\n    }\n    for(int i=0;i<n-1;i++){\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        u--;\n        v--;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    memset(cmp,-1,sizeof(cmp));\n    int sz=0;\n    for(int i=0;i<n;i++){\n        if(cmp[i]==-1){\n            dfs(i,sz++);\n        }\n        //printf(\"%d \",cmp[i]);\n    }\n    //printf(\"\\n\");\n    for(int i=0;i<n;i++){\n        a2[cmp[i]]+=a[i];\n        for(int j=0;j<G[i].size();j++){\n            int nv=cmp[G[i][j]];\n            if(nv!=cmp[i]){\n                G2[cmp[i]].push_back(nv);\n            }\n        }\n    }\n    for(int i=0;i<sz;i++){\n        sort(G2[i].begin(),G2[i].end());\n        G2[i].erase(unique(G2[i].begin(),G2[i].end()),G2[i].end());\n    }\n    dfs2(0,-1);\n    for(int i=0;i<=sz;i++){\n        for(int j=0;j<=sz;j++){\n            for(int k=0;k<2;k++){\n                dp[i][j][k]=1LL<<60;\n            }\n        }\n    }\n    dfs3(0,-1);\n    int ans=n;\n    for(int i=0;i<=sz;i++){\n        if(dp[0][i][0]<0LL || dp[0][i][1]<0LL)ans=min(ans,i);\n        if(dp[0][i][0]!=INF)ans=min(ans,i);\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\nconst int RANDOM = chrono::high_resolution_clock::now().time_since_epoch().count();\nmt19937 randGen(RANDOM);\nconst int RANDOM_HASH = randGen();\n\nstruct chash\n{\n    int operator()(int x) const { return hash<int>{}(x ^ RANDOM_HASH); }\n};\ntypedef gp_hash_table<int, null_type, chash> hash_set;\ntypedef gp_hash_table<int, int, chash> hash_map;\n\ntypedef long long ll;\n\nconst int MAX_N = 5005;\nconst int MAX_ITERATIONS = 505;\n\nint n;\nll a[MAX_N];\npair<int, int> edges[MAX_N];\nvector<pair<int, int>> g[MAX_N];\nint randP[MAX_N], randP2[MAX_N];\nbool forbiddenEdge[MAX_N];\nbool used[MAX_N];\nll currSum = 0;\nbool currHaveComp = false;\n\nvoid checkDfs(int u)\n{\n\tused[u] = true;\n\tif (a[u] < 0)\n\t\tcurrHaveComp = true;\n\tcurrSum += a[u];\n\tfor (const auto& p : g[u])\n\t\tif (!used[p.first] && !forbiddenEdge[p.second])\n\t\t\tcheckDfs(p.first);\n}\n\nbool check(int cntEdges)\n{\n\tif (cntEdges == n - 1)\n\t\treturn true;\n\tfor (int it = 0; it < MAX_ITERATIONS; it++)\n\t{\n\t\tshuffle(randP, randP + (n - 1), randGen);\n\t\tmemset(forbiddenEdge, 0, sizeof(forbiddenEdge));\n\t\tfor (int i = 0; i < cntEdges; i++)\n\t\t\tforbiddenEdge[randP[i]] = true;\n\t\tmemset(used, 0, sizeof(used));\n\t\tshuffle(randP2, randP2 + n, randGen);\n\t\tbool currRes = true;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tint u = randP2[i];\n\t\t\tif (used[u])\n\t\t\t\tcontinue;\n\t\t\tcurrSum = 0;\n\t\t\tcurrHaveComp = false;\n\t\t\tcheckDfs(u);\n\t\t\tif (!currHaveComp || currSum < 0)\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t{\n\t\t\t\tcurrRes = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (currRes)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin >> n;\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> a[i];\n\tfor (int i = 0; i < n - 1; i++)\n\t{\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--; v--;\n\t\tedges[i].first = u;\n\t\tedges[i].second = v;\n\t\tg[u].emplace_back(v, i);\n\t\tg[v].emplace_back(u, i);\n\t}\n\n\tfor (int i = 0; i < n - 1; i++)\n\t\trandP[i] = i;\n\tfor (int i = 0; i < n; i++)\n\t\trandP2[i] = i;\n\n\tint l = 0, r = n - 1;\n\twhile (r - l > 1)\n\t{\n\t\tint mid = (l + r) / 2;\n\t\tif (check(mid))\n\t\t\tr = mid;\n\t\telse\n\t\t\tl = mid + 1;\n\t}\n\tif (!check(l))\n\t\tl = r;\n\tcout << l << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define SORT(a) sort(a.begin(), a.end())\n#define REVERSE(a) reverse(a.begin(), a.end())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define int long long\n#define INF 1000000000000000000\nusing namespace std;\n\n#define ANS(f) if(f) cout << \"YES\" << endl; else cout << \"NO\" << endl;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef pair<int, int> Pii;\n\ntemplate<typename T>\nvoid readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readi(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\nvoid debug(mat m){REP(i, m.size()){ REP(j, m[i].size()){ cout << m[i][j] << \",\"; } cout << endl; }}\n\nstruct edge{int to, cost;};\n\nclass Graph\n{\npublic:\n    int V;\n    vector<vector<edge>> G;\n\n    vec gen, par;\n    mat chi, genlist;\n    int depth;\n\n    Graph(int V): V(V){\n        G = vector<vector<edge>>(V, vector<edge>(0));\n    }\n\n    void add_edge(int from, int to, int cost){\n        G[from].push_back(edge({to, cost}));\n    }\n\n    void add_edge2(int v1, int v2, int cost){\n        add_edge(v1, v2, cost);\n        add_edge(v2, v1, cost);\n    }\n\n    void dfs(int v, int d){\n        gen[v] = d;\n        depth = max(depth, d + 1);\n        REP(k, G[v].size()){\n            if(G[v][k].to == par[v]) continue;\n            par[G[v][k].to] = v;\n            chi[v].push_back(G[v][k].to);\n            dfs(G[v][k].to, d + 1);\n        }\n    }\n\n    mat makegenlist(){\n        REP(v, V) genlist[gen[v]].push_back(v);\n        return genlist;\n    }\n\n    void analyzeTree(int root){\n        gen = vec(V); par = vec(V);\n        chi = mat(V, vec(0));\n        depth = 0;\n        par[root] = -1;\n        dfs(root, 0);\n\n        genlist = mat(depth, vec(0));\n        makegenlist();\n    }\n\n};\n\nsigned main(){\n\n    int N; cin >> N;\n    vec A(N); readv(A);\n    Graph T(N);\n    int U, V;\n    REP(i, N - 1){\n        cin >> U >> V;\n        T.add_edge2(U - 1, V - 1, 0);\n    }\n    T.analyzeTree(0);\n\n    vector<mat> dp(N);\n    vec sz(N, 0);\n    IREP(d, T.depth){\n        for(int v: T.genlist[d]){\n            sz[v] = 1;\n            dp[v] = mat(2, vec(1, INF));\n            if(A[v] < 0) dp[v][1][0] = A[v];\n            else dp[v][0][0] = A[v];\n            for(int chi: T.chi[v]){\n                sz[v] += sz[chi];\n                mat dq(2, vec(sz[v], INF));\n                //切る\n                int m = INF;\n                REP(k, sz[chi]){\n                    if(dp[chi][0][k] < INF || dp[chi][1][k] < 0){\n                        m = k;\n                        break;\n                    }\n                }\n                if(m < INF){\n                    REP(k, dp[v][0].size()){\n                        dq[0][k + 1 + m] = dp[v][0][k];\n                        dq[1][k + 1 + m] = dp[v][1][k]; \n                    }\n                }\n                //繫げる         \n                REP(k, sz[v]){\n                    REP(l, sz[chi]){\n                        if(!(k - l >= 0 && k - l < dp[v][0].size())) continue;\n                        if(dp[chi][0][l] < INF && dp[v][0][k - l] < INF) dq[0][k] = min(dq[0][k], dp[chi][0][l] + dp[v][0][k - l]);\n                        if(dp[chi][1][l] < INF && dp[v][1][k - l] < INF) dq[1][k] = min(dq[1][k], dp[chi][1][l] + dp[v][1][k - l]);\n                        if(dp[chi][0][l] < INF && dp[v][1][k - l] < INF) dq[1][k] = min(dq[1][k], dp[chi][0][l] + dp[v][1][k - l]);\n                        if(dp[chi][1][l] < INF && dp[v][0][k - l] < INF) dq[1][k] = min(dq[1][k], dp[chi][1][l] + dp[v][0][k - l]);\n                    }\n                }\n                dp[v] = dq;\n            }\n            /*\n            cout << v + 1 << endl;\n            REP(i, sz[v]) cout << dp[v][0][i] << \",\";\n            cout << endl;\n            REP(i, sz[v]) cout << dp[v][1][i] << \",\";\n            cout << endl << endl;*/\n        }\n    }\n    int ans = INF;\n    REP(k, sz[0]){\n        if(dp[0][0][k] < INF || dp[0][1][k] < 0){\n            ans = k;\n            break;\n        }\n    }\n    cout << ans;\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n#define reps(i, n) for (int i = 1; i <= (int) (n); i++)\n#define all(x) (x).begin(), (x).end()\n#define uniq(x) (x).erase(unique(all(x)), (x).end())\n#define bit(n) (1LL << (n))\n#define cdiv(a, b) (((a) - 1) / (b) + 1)\n#define dump(x) cerr << #x \" = \" << (x) << endl\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing pint = pair<int, int>;\nusing vpint = vector<pint>;\ntemplate<typename T> using priority_queue_rev = priority_queue<T, vector<T>, greater<T>>;\nconstexpr double PI = 3.1415926535897932384626433832795028;\nconstexpr int DY[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nconstexpr int DX[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nint gcd(int a, int b) {\n    while (b) { swap(a %= b, b); }\n    return a;\n}\nint lcm(int a, int b) { return a / gcd(a, b) * b; }\nint sgn(int x) { return (x > 0) - (x < 0); }\ntemplate<typename T> void fin(T mes) {\n    cout << mes << endl;\n    exit(0);\n}\ntemplate<typename T, typename U> bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &rhs) {\n    os << \"(\" << rhs.first << \", \" << rhs.second << \")\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\nstruct setup {\n    static constexpr int PREC = 20;\n\n    setup() {\n        cout << fixed << setprecision(PREC);\n        cerr << fixed << setprecision(PREC);\n    };\n} setup;\n\nint N;\nint A[5500];\nint U[5500], V[5500];\nvint G[5500];\npair<vint, int> dfs(int cur, int par) {\n    vint x = {A[cur]};\n    int cut = 0;\n    for (int to:G[cur]) {\n        if (to == par) { continue; }\n        pair<vint, int> tmp = dfs(to, cur);\n        vint nxt = tmp.first;\n        int ccut = tmp.second;\n        vint y(x.size() + nxt.size(), LLONG_MAX);\n        if (ccut >= 0) { rep(i, x.size()) { y[i + ccut + 1] = x[i]; }}\n        rep(i, x.size()) {\n            rep(j, nxt.size()) {\n                chmin(y[i + j], x[i] + nxt[j]);\n                if (nxt[j] < 0) { chmin(y[i + j + 1], x[i]); }\n            }\n        }\n        x = y;\n        reps(i, x.size() - 1) { chmin(x[i], x[i - 1]); }\n        int pl;\n        for (int i = nxt.size(); i >= 0; i--) { if (nxt[i] < 0) { pl = i; }}\n        if (ccut >= 0) { cut += min(ccut, pl + 1); }\n        else { cut += pl + 1; }\n    }\n    if (A[cur] < 0) { cut = -1; }\n    return {x, cut};\n}\n\nsigned main() {\n    cin >> N;\n    rep(i, N) { cin >> A[i]; }\n    rep(i, N - 1) {\n        cin >> U[i] >> V[i];\n        U[i]--, V[i]--;\n        G[U[i]].push_back(V[i]), G[V[i]].push_back(U[i]);\n    }\n    pair<vint, int> res = dfs(0, -1);\n    int ans = N;\n    if (res.second >= 0) { ans = res.second; }\n    rep(i, res.first.size()) { if (res.first[i] < 0) { chmin(ans, i); }}\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<ll(n);++i)\n#define RREP(i,n) for(ll i=ll(n)-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<ll(n);++i)\n#define RFOR(i,m,n) for(ll i=ll(n)-1;i>=ll(m);--i)\n#define ALL(v) (v).begin(),(v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconstexpr int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconstexpr int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vvi = vector<vi>;\nusing vvl = vector<vl>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\ntemplate <class T> bool chmin(T &a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate <class T> bool chmax(T &a, T b) { if (a < b) { a = b; return true; } return false; }\n\n\nvoid merge(vvl &dp, vvl &b) {\n\tint n = dp[0].size(), m = b[0].size();\n\tvvl ret(2, vl(n + m, INF * INF));\n\tREP(i, n) {\n\t\tREP(j, m) {\n\t\t\tchmin(ret[0][i + j], dp[0][i] + b[0][j]);\n\t\t\tchmin(ret[1][i + j], dp[1][i] + b[1][j]);\n\t\t\tchmin(ret[0][i + j], dp[0][i] + b[1][j]);\n\t\t\tchmin(ret[0][i + j], dp[1][i] + b[0][j]);\n\t\t\tif (b[0][j] < 0) {\n\t\t\t\tchmin(ret[0][i + j + 1], dp[0][i]);\n\t\t\t\tchmin(ret[1][i + j + 1], dp[1][i]);\n\t\t\t}\n\t\t\tif (b[1][j] != INF * INF) {\n\t\t\t\tchmin(ret[0][i + j + 1], dp[0][i]);\n\t\t\t\tchmin(ret[1][i + j + 1], dp[1][i]);\n\t\t\t}\n\t\t}\n\t}\n\tswap(ret, dp);\n\n}\n\nvoid dfs(vector<vvl> &dp, vvi &g, vi &a, int v, int p) {\n\tvvl ret(2, vl(1));\n\tif (a[v] < 0) {\n\t\tret[0][0] = a[v];\n\t\tret[1][0] = INF * INF;\n\t}\n\telse {\n\t\tret[0][0] = INF * INF;\n\t\tret[1][0] = a[v];\n\t}\n\tREP(i, g[v].size()) {\n\t\tif (g[v][i] == p)continue;\n\t\tdfs(dp, g, a, g[v][i], v);\n\t\tmerge(ret, dp[g[v][i]]);\n\t}\n\tdp[v] = ret;\n}\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tvi v(n); REP(i, n)cin >> v[i];\n\tvvi g(n);\n\tREP(i, n - 1) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\n\tvector<vvl> dp(n, vvl(2));\n\tdfs(dp, g, v, 0, -1);\n\tll ans = INF;\n\tREP(i, n) {\n\t\tif (dp[0][0][i] < 0) {\n\t\t\tchmin(ans, i);\n\t\t}\n\t\tif (dp[0][1][i] != INF * INF) {\n\t\t\tchmin(ans, i);\n\t\t}\n\t}\n\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n#define reps(i, n) for (int i = 1; i <= (int) (n); i++)\n#define all(x) (x).begin(), (x).end()\n#define uniq(x) (x).erase(unique(all(x)), (x).end())\n#define bit(n) (1LL << (n))\n#define cdiv(a, b) (((a) - 1) / (b) + 1)\n#define dump(x) cerr << #x \" = \" << (x) << endl\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing pint = pair<int, int>;\nusing vpint = vector<pint>;\ntemplate<typename T> using priority_queue_rev = priority_queue<T, vector<T>, greater<T>>;\nconstexpr double PI = 3.1415926535897932384626433832795028;\nconstexpr int DY[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nconstexpr int DX[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nint gcd(int a, int b) {\n    while (b) { swap(a %= b, b); }\n    return a;\n}\nint lcm(int a, int b) { return a / gcd(a, b) * b; }\nint sgn(int x) { return (x > 0) - (x < 0); }\ntemplate<typename T> void fin(T mes) {\n    cout << mes << endl;\n    exit(0);\n}\ntemplate<typename T, typename U> bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &rhs) {\n    os << \"(\" << rhs.first << \", \" << rhs.second << \")\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\nstruct setup {\n    static constexpr int PREC = 20;\n\n    setup() {\n        cout << fixed << setprecision(PREC);\n        cerr << fixed << setprecision(PREC);\n    };\n} setup;\n\nint N;\nint A[5500];\nint U[5500], V[5500];\nvint G[5500];\npair<vint, int> dfs(int cur, int par) {\n    vint x = {A[cur]};\n    int cut = 0;\n    for (int to:G[cur]) {\n        if (to == par) { continue; }\n        pair<vint, int> tmp = dfs(to, cur);\n        vint nxt = tmp.first;\n        int ccut = tmp.second;\n        vint y(x.size() + nxt.size(), LLONG_MAX);\n        if (ccut >= 0) { rep(i, x.size()) { y[i + ccut + 1] = x[i]; }}\n        rep(i, x.size()) {\n            rep(j, nxt.size()) {\n                chmin(y[i + j], x[i] + nxt[j]);\n                if (nxt[j] < 0) { chmin(y[i + j + 1], x[i]); }\n            }\n        }\n        x = y;\n        reps(i, x.size() - 1) { chmin(x[i], x[i - 1]); }\n        int pl;\n        for (int i = nxt.size() - 1; i >= 0; i--) { if (nxt[i] < 0) { pl = i; }}\n        if (ccut >= 0) { cut += min(ccut, pl + 1); }\n        else { cut += pl + 1; }\n    }\n    if (A[cur] < 0) { cut = -1; }\n    return {x, cut};\n}\n\nsigned main() {\n    cin >> N;\n    rep(i, N) { cin >> A[i]; }\n    rep(i, N - 1) {\n        cin >> U[i] >> V[i];\n        U[i]--, V[i]--;\n        G[U[i]].push_back(V[i]), G[V[i]].push_back(U[i]);\n    }\n    pair<vint, int> res = dfs(0, -1);\n    int ans = N;\n    if (A[0] > 0) { ans = res.second; }\n    rep(i, res.first.size()) { if (res.first[i] < 0) { chmin(ans, i); }}\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <cstdio>\n#include <cstdint>\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cmath>\n#include <climits>\n#include <bitset>\n\n// macros\n#define ll long long int\n#define pb push_back\n#define mk make_pair\n#define pq priority_queue\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n\nusing namespace std;\n\n//  types\ntypedef pair<int, int> P;\ntypedef pair<ll, int> Pl;\ntypedef pair<ll, ll> Pll;\ntypedef pair<double, double> Pd;\n \n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 1e9 + 7;\n\n// solve\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\n\nvector<int> edge[5001];\nvector<int> child[5001];\nint par[5001], num[5001];\nll dp1[5001][5001], dp2[5001][5001];\n\nvoid dfs1(int i){\n  num[i] = 1;\n  rep(j, edge[i].size()){\n    int to = edge[i][j];\n    if(par[to] >= 0)continue;\n    par[to] = i;\n    child[i].pb(to);\n    dfs1(to);\n    num[i] += num[to];\n  }\n}\n\nvector<ll> a;\nint n;\n\nll dp[5001][5001];\n\nvoid dfs(int i){\n  rep(j, child[i].size()){\n    dfs(child[i][j]);\n  }\n  if(child[i].size() == 0){\n    if(a[i] < 0){\n      dp2[i][1] = a[i];\n    }else{\n      dp1[i][1] = dp2[i][1] = a[i];\n    }\n    return;\n  }\n  if(a[i] > 0){\n    dp[0][0] = linf;\n    dp[0][1] = a[i];\n    int curr = 1;\n    int prev = 1;\n    rep(j, child[i].size()){\n      int to = child[i][j];\n      curr += num[to];\n      rep(k, curr+1){\n        dp[j+1][k] = linf;\n        for(int l = 1; l <= k; l++){\n          if(l > num[to])break;\n          if((dp1[to][l] < linf || dp2[to][l] < 0) && k-l<=prev)chmin(dp[j+1][k], dp[j][k-l]);\n        }\n        if(a[to] > 0){\n          for(int l = 1; l <= k; l++){\n            if(l > num[to])break;\n            if(k-l+1<=prev)chmin(dp[j+1][k], dp[j][k-l+1] + dp1[to][l]);\n          }\n        }\n      }\n      prev = curr;\n    }\n    rep(j, num[i]+1)dp1[i][j] = dp[child[i].size()][j];\n  }\n\n  dp[0][0] = linf;\n  dp[0][1] = a[i];\n  int curr = 1;\n  int prev = 1;\n  rep(j, child[i].size()){\n    int to = child[i][j];\n    curr += num[to];\n    rep(k, curr+1){\n      dp[j+1][k] = linf;\n        for(int l = 1; l <= k; l++){\n          if(l > num[to])break;\n          if((dp1[to][l] < linf || dp2[to][l] < 0) && k-l<=prev)chmin(dp[j+1][k], dp[j][k-l]);\n        }\n        for(int l = 1; l <= k; l++){\n          if(l > num[to])break;\n          if(k-l+1<=prev)chmin(dp[j+1][k], dp[j][k-l+1] + dp1[to][l]);\n          if(k-l+1<=prev)chmin(dp[j+1][k], dp[j][k-l+1] + dp2[to][l]);\n        }\n    }\n    prev = curr;\n  }\n  rep(j, num[i]+1)dp2[i][j] = dp[child[i].size()][j];\n\n}\n\nint main(int argc, char const* argv[])\n{\n  cin >> n;\n  a = vector<ll>(n, 0);\n  rep(i, n)cin >> a[i];\n  rep(i, n - 1){\n    int x, y;\n    cin >> x >> y;\n    x--; y--;\n    edge[x].pb(y);\n    edge[y].pb(x);\n  }\n  fill(par, par + n, -1);\n  par[0] = 0;\n  dfs1(0);\n\n  rep(i, n+1){\n    rep(j, n+1){\n      dp1[i][j] = dp2[i][j] = linf;\n    }\n  }\n\n  dfs(0);\n  FOR(i, 1, n+1){\n    if(dp1[0][i] < linf || dp2[0][i] < 0){\n      cout << i - 1 << endl;\n      return 0;\n    }\n  }\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 5005;\n\nint n;\nint a[MAXN];\nvector<int> g[MAXN];\n\nint child[MAXN];\n\nlong long temp[MAXN];\nlong long f[MAXN][MAXN];\n/// f(v, d) largest sum remaning if we deleted d edges from subtree v\n\nbool temppos[MAXN];\nbool pos[MAXN][MAXN];\n/// g(v, d) = true if theres a way to delete d edges from subtree\n/// v so that the remaning components are all positive\n\nvoid dfs(int v, int p) {\n  if(g[v].size() == 1 && g[v].front() == p) {\n    child[v] = 1;\n    f[v][0] = a[v];\n    f[v][1] = 0;\n    pos[v][1] = 1;\n    pos[v][0] = (a[v] > 0);\n    return;\n  }\n\n  f[v][0] = a[v];\n  pos[v][0] = (a[v] > 0);\n\n  for(int s : g[v]) if(s != p) {\n    dfs(s, v);\n\n    fill(temp, temp + child[s] + child[v] + 1, (long long)1e18);\n    fill(temppos, temppos + child[s] + child[v] + 1, false);\n\n    for(int i = child[v]; i >= 0; --i) {\n      for(int j = 0; j <= child[s]; ++j) {\n        temp[i + j] = min(temp[i + j], f[v][i] + f[s][j]);\n        temppos[i + j] = max(temppos[i + j], (pos[v][i] && pos[s][j]));\n      }\n    }\n    child[v] += child[s];\n    for(int i = 0; i <= child[v]; ++i) {\n      f[v][i] = temp[i];\n      pos[v][i] = temppos[i];\n    }\n  }\n\n  child[v] += 1;\n\n  if(v == 0) {\n    for(int i = 0; i <= child[v]; ++i) {\n      if(f[v][i] < 0 || pos[v][i]) {\n        cout << i << endl;\n        return;\n      }\n    }\n  }\n\n  for(int i = child[v]; i > 0; --i) {\n    if(f[v][i - 1] < 0 || pos[v][i - 1]) {\n      f[v][i] = min(f[v][i], 0LL);\n      pos[v][i] = 1;\n    }\n  }\n}\n\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(NULL);\n\n  cin >> n;\n  for(int i = 0; i < n; ++i) cin >> a[i];\n  for(int i = 0; i < n - 1; ++i) {\n    int u, v; cin >> u >> v;\n    --u; --v;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n\n  memset(f, 60, sizeof f);\n\n  dfs(0, -1);\n\n  //cout << pos[4][2] << endl;\n\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst long long INF = 1e18;\n\nint n, a[5005], siz[5005];\nlong long dp[5005][5005][2], sum[5005], tmp[5005], tmp1[5005];\n\nvector <int> edge[5005];\n\nvoid solve(int id, int p) {\n    siz[id] = 1;\n    sum[id] = a[id];\n\n    int child = 0;\n\n    for (int i = 0; i < edge[id].size(); i++) {\n        int to = edge[id][i];\n        if (to == p) continue;\n        solve(to, id);\n        siz[id] += siz[to];\n        sum[id] += sum[to];\n        child++;\n    }\n\n    int cur = 0;\n\n    for (int i = 0; i < edge[id].size(); i++) {\n        int to = edge[id][i];\n        if (to == p) continue;\n\n        for (int j = siz[to]; j >= 1; j--) {\n            if (dp[to][j - 1][0] < 0) {\n                dp[to][j][0] = min(dp[to][j][0], 0LL);\n                dp[to][j][1] = 1;\n            }\n            if (dp[to][j - 1][1]) {\n                dp[to][j][0] = min(dp[to][j][0], 0LL);\n            }\n        }\n\n        cur += siz[to];\n\n\n        if (cur == siz[to]) {\n            //first child\n            for (int j = 0; j <= siz[to]; j++) {\n                dp[id][j][0] = dp[to][j][0];\n                dp[id][j][1] = dp[to][j][1] && (a[id] > 0);\n            }\n        }\n        else {\n            for (int j = cur; j >= 0; j--) {\n                tmp[j] = INF;\n                tmp1[j] = 0;\n                int v = min(j, siz[to]);\n                for (int k = 0; k <= v; k++) {\n                    if (dp[to][k][0] != INF && dp[id][j - k][0] != INF) tmp[j] = min(tmp[j], dp[to][k][0] + dp[id][j - k][0]);\n                    tmp1[j] |= (dp[to][k][1] && dp[id][j - k][1]);\n                }\n            }\n            for (int j = 0; j <= cur; j++) {\n                dp[id][j][0] = tmp[j];\n                dp[id][j][1] = tmp1[j] && (a[id] > 0);\n            }\n        }\n    }\n\n    for (int i = siz[id] - 1; i >= 0; i--) {\n        if (dp[id][i][0] != INF) dp[id][i][0] += a[id];\n    }\n\n    if (child == 0) {\n        dp[id][0][0] = sum[id];\n        dp[id][0][1] = a[id] >  0;\n    }\n}\n\nint main() {\n    scanf(\"%d\", &n);\n\n    for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\n    for (int i = 0; i < n - 1; i++) {\n        int x, y;\n        scanf(\"%d%d\", &x, &y);\n        edge[x].push_back(y);\n        edge[y].push_back(x);\n    }\n\n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j <= n; j++) {\n            dp[i][j][0] = INF;\n            dp[i][j][1] = 0;\n        }\n    }\n\n    solve(1, -1);\n\n    for (int i = 0; i < n; i++) {\n        if (dp[1][i][0] < 0) return 0 * printf(\"%d\\n\", i);\n        if (dp[1][i][1]) return 0 * printf(\"%d\\n\", i);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef long long ll;\n\nconst ll INF = 1e18;\n\nint N;\nll A[5000];\nvector<int> G[5000];\nvector<ll> dp[5000][2]; // 0 -> comなし、1 -> comあり\nbool used[50000];\n\nvoid dfs(int v){\n    used[v] = true;\n    if(A[v] < 0){\n        dp[v][0].push_back(-INF);\n        dp[v][1].push_back(-A[v]);\n    }else{\n        dp[v][0].push_back(-A[v]);\n        dp[v][1].push_back(-INF);\n    }\n    for(int to : G[v]){\n        if(!used[to]){\n            dfs(to);\n            int sl = dp[v][0].size();\n            int sr = dp[to][0].size();\n            int sum = sl+sr;\n            // cout << \"sum:\" << sum << endl;\n            vector<ll> buf0(sum, -INF);\n            vector<ll> buf1(sum, -INF);\n            for(int i = 0; i < sl; i++){\n                for(int j = 0; j < sr; j++){\n                    if(A[v] > 0){\n                        if(dp[to][0][j] < 0 && dp[to][0][j] > -1e13){\n                            // (0, 0)\n                            buf0[i+j] = max(buf0[i+j], dp[v][0][i]+dp[to][0][j]);\n                            buf0[i+j+1] = max(buf0[i+j+1], dp[v][0][i]); // comなしは切ってもいい\n                        }\n                        // (0, 1)\n                        buf1[i+j] = max(buf1[i+j], dp[v][0][i]+dp[to][1][j]);\n                        if(dp[to][1][j] > 0 ) buf0[i+j+1] = max(buf0[i+j+1], dp[v][0][i]);\n                    }\n                    // (1, 0)\n                    if(dp[to][0][j] < 0 && dp[to][0][j] > -1e13){\n                        buf1[i+j] = max(buf1[i+j], dp[v][1][i]+dp[to][0][j]);\n                        buf1[i+j+1] = max(buf1[i+j+1], dp[v][1][i]); // comなしは切ってもいい\n                    }\n                    // (1, 1)\n                    buf1[i+j] = max(buf1[i+j], dp[v][1][i]+dp[to][1][j]);\n                    if(dp[to][1][j] > 0 ) buf1[i+j+1] = max(buf1[i+j+1], dp[v][1][i]);\n                }\n            }\n            dp[v][0].resize(sum); dp[v][1].resize(sum);\n            for(int i = 0; i < sum; i++){\n                dp[v][0][i] = buf0[i];\n                dp[v][1][i] = buf1[i];\n            }\n        }\n    }\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << setprecision(10) << fixed;\n    cin >> N;\n    for(int i = 0; i < N; i++) cin >> A[i];\n    for(int i = 0; i < N-1; i++){\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    dfs(0);\n    for(int i = 0; i < dp[0][1].size(); i++){\n        // cout << dp[0][0][i] << ' ' << dp[0][1][i] << endl;\n        if(dp[0][1][i] > 0 || (dp[0][0][i] < 0 && dp[0][0][i] >= -1e13)){\n            cout << i << endl;\n            return 0;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n//#define int ll\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\ntypedef complex<double> base;\ntypedef complex<int> point;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n\n#ifdef MAX_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\n#define watch(x) cerr << (#x) << \" = \" << (x)    << endl;\n\nconst double PI = 2 * acos(0.0);\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\n\nvoid smain();\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n#ifdef MAX_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef MAX_HOME\n    cout << \"\\n\\n\\n\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n}\n\nconst int N = 5009;\n\nvi g[N], _g[N];\nll a[N];\nint n;\n\nvoid hang(int v, int par) {\n    for (int to : _g[v]) if (to != par) {\n        g[v].push_back(to);\n        hang(to, v);\n    }\n}\n\nvvvl dp(N, vvl(2));\nconst ll oo = 1e18;\n\nvvl m_merge(vvl dp, vvl sdp) {\n    int sz = max(dp[0].size(), dp[1].size()) + max(sdp[0].size(), sdp[1].size()) + 1;\n    inmin(sz, n);\n    vvl ret(2, vl(sz, oo));\n    fori (z, 2) {\n        fori (r, dp[z].size()) if (dp[z][r] < oo) {\n            fori (k, 2) {\n                fori (t, sdp[k].size()) if (sdp[k][t] < oo) {\n                    int nz = z || k;\n                    int ns = r + t;\n                    if (ns < sz) inmin(ret[nz][ns], dp[z][r] + sdp[k][t]);\n                    if ((k == 0 || sdp[k][t] < 0) && r + 1 + t < sz) inmin(ret[z][r + t + 1], dp[z][r]);\n                }\n            }\n        }\n    }\n    return ret;\n}\n\nvoid dfs(int v) {\n    if (g[v].empty()) {\n        dp[v][1] = {a[v]};\n        if (a[v] > 0) dp[v][0] = {a[v]};\n    } else {\n        dp[v][1] = {a[v]};\n        if (a[v] > 0) dp[v][0] = {a[v]};\n\n        for (int to : g[v]) {\n            dfs(to);\n            dp[v] = m_merge(dp[v], dp[to]);\n//            watch(to);\n        }\n    }\n}\n\nvoid smain() {\n\n    cin >> n;\n    fori (i, n) cin >> a[i + 1];\n    fori (i, n - 1) {\n        int u, v;\n        cin >> u >> v;\n        _g[u].push_back(v);\n        _g[v].push_back(u);\n    }\n    hang(1, -1);\n\n    dfs(1);\n    int ans = n - 1;\n    fori (z, 2) {\n        fori (r, dp[1][z].size()) if (dp[1][z][r] < oo) {\n            if (!z || dp[1][z][r] < 0) inmin(ans, r);\n        }\n    }\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cctype>\n#include <cstdint>\n#include <cmath>\n#include <complex>\n#include <chrono>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n#include <random>\n#include <memory>\n#include <utility>\n#include <limits>\n \n#define rep(i, a, b) for (long long i = (a); (i) < (b); (i)++)\n#define all(i) i.begin(), i.end()\n#define debug(...) std::cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n\nvoid debug_out(){std::cerr<<std::endl;}\n\ntemplate<typename Head,typename... Tail>\nvoid debug_out(Head h,Tail... t){\n  std::cerr<<\" \"<<h;\n  debug_out(t...);\n}\n \ntemplate <typename T1, typename T2>\nstd::ostream& operator<<(std::ostream& os, std::pair<T1, T2> pa) {\n  return os << pa.first << \" \" << pa.second;\n}\n \ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, std::vector<T> vec) {\n  for (int i = 0; i < vec.size(); i++)os << vec[i] << (i + 1 == vec.size() ? \"\" : \" \");\n  return os;\n}\n \ntemplate<typename T1,typename T2>\ninline bool chmax(T1& a,T2 b){return a<b && (a=b,true);}\n \ntemplate<typename T1,typename T2>\ninline bool chmin(T1& a,T2 b){return a>b && (a=b,true);}\n \nlong long pow_mod(long long a, long long b, long long mod=-1) {\n  if(b==0)return 1;\n  if ((a == 0)||(mod!=-1&&(a+mod)%mod==0)) {\n    return 0;\n  }\n  long long x = 1;\n  while (b > 0) {\n    if (b & 1) {\n      x = (mod!=-1)?(x * a) % mod:x*a;\n    }\n    a = (mod!=-1)?(a * a) % mod:a*a;\n    b >>= 1;\n  }\n  return x;\n}\n\n// const long long MOD = 998244353;\nconst long long MOD = 1e9 + 7;\n\nusing ll = long long;\nusing P=std::pair<long long,long long>;\n\nint main() {\n  std::cin.tie(nullptr);\n  std::ios::sync_with_stdio(false);\n\n  ll n;\n  std::cin>>n;\n\n  std::vector<ll> a(n);\n  rep(i,0,n)std::cin>>a[i];\n\n  std::vector<std::vector<ll>> graph(n);\n  rep(i,0,n-1){\n    ll u,v;\n    std::cin>>u>>v;\n    u--;v--;\n    graph[u].push_back(v);\n    graph[v].push_back(u);\n  }\n\n  const ll INF=std::numeric_limits<ll>::max()/3;\n\n  std::vector<std::vector<ll>> dp1(5010,std::vector<ll>(5010,INF)),dp2(5010,std::vector<ll>(5010,INF));\n\n  auto dfs=[&](auto f,ll v,ll par)->ll{\n    dp1[v][0]=(a[v]>0)?a[v]:INF;\n    dp2[v][0]=a[v];\n\n    ll ret=1;\n    for(auto e:graph[v]){\n      if(e==par)continue;\n      std::vector<ll> temp1(5010,INF);\n      std::vector<ll> temp2(5010,INF);\n      ll sz=f(f,e,v);\n      rep(i,0,ret){\n        rep(j,0,sz){\n          chmin(temp1[i+j],dp1[v][i]+dp1[e][j]);\n          if(dp1[e][j]!=INF||dp2[e][j]<0)chmin(temp1[i+j+1],dp1[v][i]);\n          if(dp2[v][i]!=INF&&dp2[e][j]!=INF)chmin(temp2[i+j],dp2[v][i]+dp2[e][j]);\n          if(dp2[e][j]<0||dp2[e][j]==dp1[e][j])chmin(temp2[i+j+1],dp2[v][i]);\n        }\n      }\n      dp1[v]=temp1;\n      dp2[v]=temp2;\n      ret+=sz;\n    }\n    return ret;\n  };\n\n  dfs(dfs,0,-1);\n\n  rep(i,0,5010){\n    if(dp1[0][i]!=INF||dp2[0][i]<0){\n      std::cout<<i<<\"\\n\";\n      return 0;\n    }\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define DEBUG_MODE\n#define endl '\\n'\n#ifdef DEBUG_MODE\n#define DEBUG(X) debug_func(X, #X)\n#define DEBUG_ENDL endl\n#define DEBUG_SEPARATOR_LINE cout<<\"=================\\n\"\n#else\n#define DEBUG(X) 0\n#define DEBUG_ENDL 0\n#define DEBUG_SEPARATOR_LINE 0\n#endif\n#define ALL(V) (V).begin(), (V).end()\n#define ALLR(V) (V).rbegin(), (V).rend()\n#define DEBUG_ENDL_S(S) ((S).size() ? \"\\n\" : \"\")\ntemplate <typename T> using V = vector<T>;\ntemplate <typename T> using VV = V<V<T>>;\ntemplate <typename T, typename U> using P = pair<T, U>;\nusing ll = int64_t;\nusing PLL = P<ll, ll>;\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename Head, typename... Tail> const Head& var_min(const Head &head, const Tail&... tail) { return min(head, var_min(tail...)); }\ntemplate <typename Head, typename... Tail> const Head& var_max(const Head &head, const Tail&... tail) { return max(head, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\nvoid debug_func_preffix(const string &s) { if(s.size()) cout << s << \" = \"; }\ntemplate <typename T>\nvoid debug_func(const T &t, const string &s = \"\") {\n    debug_func_preffix(s);\n    cout << t << DEBUG_ENDL_S(s);\n}\ntemplate <typename T, typename U>\nvoid debug_func(const P<T, U> &p, const string &s = \"\") {\n    debug_func_preffix(s);\n    cout << \"(\";\n    debug_func(p.first);\n    cout << \", \";\n    debug_func(p.second);\n    cout << \")\" << DEBUG_ENDL_S(s);\n}\ntemplate <typename T>\nvoid debug_func(const V<T> &v, const string &s = \"\") {\n    for(ll i = 0; i < 10; i++) {\n        string t = s + \"[\" + to_string(i) + \"]\";\n        debug_func(v[i], t);\n    }\n}\n\nconst ll INF = 5e15;\n\nV<ll> dp1(5010, INF);\nVV<ll> dp2(5010, V<ll>(5010, INF));\nV<ll> A;\nVV<ll> edges(5010);\n\nll min_cut(ll node) {\n    ll ret = INF;\n    for(ll i = 0; dp2[node][i] != INF; i++) if(dp2[node][i] < 0) chmin(ret, i);\n    return ret;\n}\n\nll dfs(ll now, ll pre) {\n    ll ret = 0;\n    dp2[now][0] = 0;\n    if(A[now] > 0) dp1[now] = 0;\n    for(ll nxt : edges[now]) {\n        if(nxt == pre) continue;\n        ret += dfs(nxt, now) + 1;\n        if(A[now] > 0) {\n            dp1[now] += min<ll>(dp1[nxt], min_cut(nxt) + 1);\n            chmin(dp1[now], INF);\n        }\n        V<ll> dp2sub(ret + 10, INF);\n        dp2sub[ret] = 0;\n        for(ll i = 0; dp2[now][i] != INF; i++) {\n            ll mcut = min_cut(nxt);\n            chmin(mcut, dp1[nxt]);\n            if(mcut < INF) chmin(dp2sub[i + mcut + 1], dp2[now][i]);\n            for(ll j = 0; dp2[nxt][j] != INF; j++) chmin(dp2sub[i + j], dp2[now][i] + dp2[nxt][j]);\n        }\n        dp2[now] = dp2sub;\n    }\n    if(ret == 0) dp2[now] = { A[now], INF };\n    else for(ll &e : dp2[now]) e += A[now];\n    return ret;\n}\n\nint main() {\n    ll N;\n    cin >> N;\n    A = V<ll>(N);\n    for(ll &e : A) cin >> e;\n    for(ll i = 1; i < N; i++) {\n        ll u, v;\n        cin >> u >> v;\n        u--;\n        v--;\n        edges[u].push_back(v);\n        edges[v].push_back(u);\n    }\n    dfs(0, -1);\n    ll ans = dp1[0];\n    for(ll i = 0; i < 5010; i++) if(dp2[0][i] < 0) chmin(ans, i);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ostream>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\nconst ll INF = TEN(18);\n\nint n;\nV<ll> a;\nVV<int> g;\n\nusing P = pair<ll, ll>;\nV<P> dfs(int p, int b) {\n    V<P> dp = {{0, INF}};\n    for (int d: g[p]) {\n        if (d == b) continue;\n        auto ndp = dfs(d, p);\n        int k = int(ndp.size());\n        ndp.push_back({INF, INF});\n        for (int i = 0; i < k; i++) {\n            if (ndp[i].first < INF / 2 || ndp[i].second < 0) ndp[i + 1].first = min(ndp[i + 1].first, 0LL);\n        }\n        int m = int(dp.size()) - 1;\n        V<P> udp(m + k + 1, {INF, INF});\n        for (int i = 0; i <= m; i++) {\n            for (int j = 0; j <= k; j++) {\n                udp[i+j].first = min(udp[i+j].first, dp[i].first + ndp[j].first);\n                udp[i+j].second = min(udp[i+j].second, dp[i].first + ndp[j].second);\n                udp[i+j].second = min(udp[i+j].second, dp[i].second + ndp[j].second);\n                udp[i+j].second = min(udp[i+j].second, dp[i].second + ndp[j].second);\n            }\n        }\n        dp = udp;\n    }\n    int m = int(dp.size()) - 1;\n    V<P> udp(m + 1);\n    for (int i = 0; i <= m; i++) {\n        if (a[p] > 0) {\n            udp[i].first = dp[i].first + a[p];\n            udp[i].second = dp[i].second + a[p];\n        } else {\n            udp[i].first = INF;\n            udp[i].second = min(dp[i].first, dp[i].second) + a[p];\n        }\n    }\n\n    return udp;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout << setprecision(20) << fixed;\n\n    cin >> n;\n    a = V<ll>(n);\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n    g = VV<int>(n);\n    for (int j = 0; j < n - 1; ++j) {\n        int a, b;\n        cin >> a >> b; a--; b--;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n\n    auto dp = dfs(0, -1);\n\n    for (int i = 0; i < n; i++) {\n        if (dp[i].first < INF / 2 || dp[i].second < 0) {\n            cout << i << endl;\n            return 0;\n        }\n    }\n    assert(false);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <tuple>\n#include <algorithm>\n#include <functional>\n#define int long long\n#define rep(i, n) for(i = 0; i < n; i++)\nusing namespace std;\ntypedef tuple<int, int, int> T;\n\nstruct UF {\n\tint par[5000];\n\tvoid init() { for(int i = 0; i < 5000; i++) par[i] = i; }\n\tint root(int x) { if (par[x] == x) return x; return par[x] = root(par[x]); }\n\tvoid unit(int x, int y) { x = root(x); y = root(y); par[x] = y; }\n\tbool same(int x, int y) { return root(x) == root(y); }\n};\n\nint n;\nint a[5000];\nT edges[5000];\nvector<int> ids;\nint convId[5000];\nint convA[5000];\nvector<int> et[5000];\nint dp[5000][5000];\t//dp[v][切った本数] = min和\nvector<int> as;\n\nvoid dfs(int p, int v) {\n\tif (p != -1 && et[v].size() == 1) {\n\t\tif (convA[v] > 0) {\n\t\t\tas.push_back(convA[v]);\n\t\t}\n\t\treturn;\n\t}\n\t\n\tfor (int i = 0; i < et[v].size(); i++) {\n\t\tint nv = et[v][i];\n\t\tif (p == et[v][i]) continue;\n\t\tdfs(v, nv);\n\t}\n}\n\nsigned main() {\n\tint i;\n\tint sumA = 0;\n\tcin >> n;\n\trep(i, n) { cin >> a[i]; sumA += a[i]; }\n\trep(i, n - 1) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--; v--;\n\t\tedges[i] = T(!(a[u] * a[v] > 0), u, v);\n\t}\n\tsort(edges, edges + n - 1);\n\t\n\tUF uf;\n\tuf.init();\n\trep(i, n - 1) {\n\t\tint cst = get<0>(edges[i]);\n\t\tint u = get<1>(edges[i]);\n\t\tint v = get<2>(edges[i]);\n\t\tif (cst > 0) break;\n\t\tuf.unit(u, v);\n\t}\n\t\n\trep(i, n) {\n\t\tids.push_back(uf.root(i));\n\t}\n\tsort(ids.begin(), ids.end());\n\tids.erase(unique(ids.begin(), ids.end()), ids.end());\n\t\n\trep(i, n) {\n\t\tint val = uf.root(i);\n\t\tconvId[i] = lower_bound(ids.begin(), ids.end(), val) - ids.begin();\n\t\tconvA[convId[i]] += a[i];\n\t}\n\t\n\trep(i, n - 1) {\n\t\tint u = get<1>(edges[i]);\n\t\tint v = get<2>(edges[i]);\n\t\tu = convId[u];\n\t\tv = convId[v];\n\t\tif (u != v) {\n\t\t\tet[u].push_back(v);\n\t\t\tet[v].push_back(u);\n\t\t}\n\t}\n\t//cout << \"Fuck\" << endl;\n\tdfs(-1, 0);\n\t\n\tsort(as.begin(), as.end(), greater<int>());\n\t\n\tfor (i = 0; i < as.size(); i++) {\n\t\tif (sumA < 0) break;\n\t\tsumA -= as[i];\n\t}\n\tcout << i << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n#define taskname \"A\"\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> ii;\nconst int maxn = 5e3 + 5;\nconst int logn = log2(maxn) + 1;\nconst int inf = 1e9 + 1;\nint n,a[maxn];\nvector<int> adj[maxn];\nll dp[maxn][maxn];\nbool dp1[maxn][maxn];\nll tmp[maxn];\nbool tmp1[maxn];\nint sub[maxn];\n\nvoid dfs(int u , int par){\n    dp1[u][0] = (a[u] > 0);\n    dp[u][0] = a[u];\n    sub[u] = 1;\n    for(auto c : adj[u]){\n        if(c == par)continue;\n        dfs(c , u);\n        fill_n(tmp,maxn,1e18);\n        fill_n(tmp1,maxn,0);\n        for(int i = 0 ; i <= sub[u] ; ++i){\n            for(int j = 0 ; j <= sub[c] ; ++j){\n                if(dp[c][j] < 0 || dp1[c][j])tmp[i + j + 1] = min(tmp[i + j + 1] , dp[u][i]);\n                tmp[i + j] = min(tmp[i + j] , dp[u][i] + dp[c][j]);\n                if(dp1[c][j] && dp1[u][i])tmp1[i + j] = 1;\n                if(dp1[u][i] && (dp[c][j] < 0 || dp1[c][j]))tmp1[i + j + 1] = 1;\n            }\n        }\n        sub[u] += sub[c];\n        for(int i = 0 ; i <= sub[u] ; ++i){\n            dp[u][i] = tmp[i];\n            dp1[u][i] = tmp1[i];\n        }\n    }\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if(fopen(taskname\".INP\" , \"r\")){\n        freopen(taskname\".INP\",\"r\",stdin);\n        freopen(taskname\".OUT\",\"w\",stdout);\n    }\n    fill_n(&dp[0][0],maxn*maxn,1e18);\n    memset(dp1,0,sizeof dp1);\n    cin >> n;\n    for(int i = 1 ; i <= n ; ++i)cin >> a[i];\n    for(int i = 1 ; i < n ; ++i){\n        int u , v;cin >> u >> v;\n        adj[u].pb(v);adj[v].pb(u);\n    }\n    dfs(1,0);\n//    cout << dp[1][2] << \" \" << dp1[1][2] << endl;\n    for(int i = 0 ; i <= n ; ++i){\n        if(dp[1][i] < 0 || dp1[1][i])return cout << i , 0;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; ++i )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef pair<ll,int> pli;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\nvector<int> v[5050];\nvector<ll> dp[5050][2];\nint sz[5050];\nll a[5050];\nvoid dfs(int x,int p){\n    sz[x]=0;\n    dp[x][0].resize(1);\n    dp[x][1].resize(1);\n    for(auto to:v[x]){\n        if(to==p)continue;\n        dfs(to,x);\n        vector<ll> ret0(sz[x]+sz[to]+1,longinf),ret1(sz[x]+sz[to]+1,longinf);\n        rep(i,sz[x]+1)rep(j,sz[to]+1){\n            ret0[i+j]=min(ret0[i+j],min(dp[x][0][i],dp[x][1][i])+min(dp[to][0][j],dp[to][1][j]));\n            ret1[i+j]=min(ret1[i+j],dp[x][1][i]+dp[to][1][j]);\n        }\n        sz[x]+=sz[to];\n        dp[x][0]=ret0;\n        dp[x][1]=ret1;\n    }\n    ++sz[x];\n    dp[x][0].push_back(longinf);\n    dp[x][1].push_back(longinf);\n    for(int i=sz[x]-1;i>=0;--i){\n        dp[x][0][i+1]+=a[x];\n        if(dp[x][0][i]+a[x]<0)dp[x][0][i+1]=min(dp[x][0][i+1],0LL);\n        if(dp[x][1][i]<longinf&&a[x]>0)dp[x][0][i+1]=min(dp[x][0][i+1],0LL);\n        if(a[x]>0){\n            dp[x][1][i+1]+=a[x];\n            if(dp[x][1][i]<longinf)dp[x][1][i+1]=0;\n        }\n        else {\n            if(dp[x][1][i]+a[x]<0)dp[x][1][i+1]=0;\n            else dp[x][1][i+1]=longinf;\n        }\n    }\n    dp[x][0][0]+=a[x];\n    dp[x][1][0]=(a[x]>0?dp[x][1][0]+a[x]:longinf);\n}\n\n\n\nint main(){\n    int n;\n    cin>>n;\n    rep(i,n)cin>>a[i];\n    rep(i,n-1){\n        int x,y;\n        cin>>x>>y;\n        --x;--y;\n        v[x].push_back(y);\n        v[y].push_back(x);\n    }\n    dfs(0,-1);\n\n    rep(i,n+1){\n        if(dp[0][0][i]<0||dp[0][1][i]<longinf){\n            cout<<i<<endl;\n            return 0;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = unsigned;\nusing namespace std;\n\ntemplate<class T>\nconstexpr T INF = ::numeric_limits<T>::max() / 32 * 15 + 208;\n\ntemplate <class T, class U>\nvector<T> make_v(U size, const T& init){ return vector<T>(static_cast<size_t>(size), init); }\n\ntemplate<class... Ts, class U>\nauto make_v(U size, Ts... rest) { return vector<decltype(make_v(rest...))>(static_cast<size_t>(size), make_v(rest...)); }\n\ntemplate <class T>\nostream& operator<<(ostream& os, vector<T> v) {\n    os << \"[\";\n    for (int i = 0; i < v.size(); ++i) {\n        if(i) os << \",\";\n        os << v[i];\n    }\n    return os << \"]\";\n}\n\ntemplate <class L, class R>\nostream& operator<<(ostream& os, pair<L, R> p) {\n    return os << \"(\" << p.first << \",\" << p.second << \")\";\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> v(n);\n    for (auto &&i : v) scanf(\"%d\", &i);\n    vector<vector<int>> G(n);\n    for (int i = 0; i < n-1; ++i) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        G[a-1].emplace_back(b-1);\n        G[b-1].emplace_back(a-1);\n    }\n    deque<int> Q;\n    vector<int> num(n);\n    {\n        stack<int> s;\n        int cnt = 0;\n        vector<int> visited(n, 0);\n        s.emplace(0);\n        while(!s.empty()){\n            int a = s.top(); s.pop();\n            visited[a]++;\n            num[a] = cnt++;\n            Q.emplace_front(a);\n            for (auto &&i : G[a]) {\n                if(!visited[i]) s.emplace(i);\n            }\n        }\n    }\n    auto dp = make_v(2, n, n, INF<ll>);\n    vector<int> sz(n, 1);\n    while(!Q.empty()){\n        int x = Q.front(); Q.pop_front();\n        dp[v[x] < 0][x][0] = v[x];\n        for (auto &&i : G[x]) {\n            if(num[i] < num[x]) continue;\n            auto tmp = make_v(2, sz[i]+sz[x], INF<ll>);\n            for (int j = 0; j < sz[x]; ++j) {\n                for (int k = 0; k < sz[i]; ++k) {\n                    for (int a = 0; a < 2; ++a) {\n                        if(dp[a][x][j] == INF<ll>) continue;\n                        if(dp[0][i][k] != INF<ll>) tmp[a][j+k] = min(tmp[a][j+k], dp[a][x][j]+dp[0][i][k]);\n                        if(dp[1][i][k] != INF<ll>) tmp[1][j+k] = min(tmp[1][j+k], dp[a][x][j]+dp[1][i][k]);\n                        if(dp[0][i][k] != INF<ll>) tmp[a][j+k+1] = min(tmp[a][j+k+1], dp[a][x][j]);\n                        if(dp[1][i][k] < 0) tmp[a][j+k+1] = min(tmp[a][j+k+1], dp[a][x][j]);\n                    }\n                }\n            }\n            sz[x] += sz[i];\n            for (int j = 0; j < sz[x]; ++j) {\n                for (int a = 0; a < 2; ++a) {\n                    dp[a][x][j] = tmp[a][j];\n                }\n            }\n        }\n    }\n    int ans = INF<int>;\n    for (int i = 0; i < n; ++i) {\n        if(dp[0][0][i] != INF<ll>) ans = min(ans, i);\n        if(dp[1][0][i] < 0) ans = min(ans, i);\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N, A[5000];\nvector<int> edges[5000];\n\nconst int64_t INF = 1e18;\nint64_t dp[5000][5001][2], sub[5001][2];\nint num[5000];\nvoid chmin(int64_t& a, int64_t b){\n    a = min(a, b);\n}\n\nvoid dfs(int i, int par){\n    vector<pair<int, int>> children;\n    for(int j : edges[i]) if(j != par){\n        dfs(j, i);\n        children.push_back({num[j], j});\n    }\n    sort(children.begin(), children.end());\n\n    int sum = 1;\n    dp[i][0][A[i] < 0] = A[i];\n    for(auto& pr : children){\n        int n = pr.first, j = pr.second;\n\n        for(int n1=0; n1<sum; n1++){\n            for(int n2=0; n2<n; n2++){\n                for(int k1=0; k1<2; k1++){\n                    for(int k2=0; k2<2; k2++){\n                        chmin(sub[n1+n2][k1|k2], dp[i][n1][k1] + dp[j][n2][k2]);\n                        if((k2==0 && dp[j][n2][k2] < INF) || dp[j][n2][k2] < 0) chmin(sub[n1+n2+1][k1], dp[i][n1][k1]);\n                    }\n                }\n            }\n        }\n\n        sum += n;\n        for(int n1=0; n1<sum; n1++) for(int k=0; k<2; k++){\n            dp[i][n1][k] = sub[n1][k];\n            sub[n1][k] = INF;\n        }\n    }\n\n    num[i] = sum;\n}\n\nint main(){\n    cin >> N;\n    for(int i=0; i<N; i++) cin >> A[i];\n    for(int i=0; i<N-1; i++){\n        int a, b;\n        cin >> a >> b;\n        edges[a-1].push_back(b-1);\n        edges[b-1].push_back(a-1);\n    }\n\n    for(int j=0; j<N; j++) for(int k=0; k<2; k++){\n        for(int i=0; i<N; i++) dp[i][j][k] = INF;\n        sub[j][k] = INF;\n    }\n\n    dfs(0, -1);\n\n    int ans = N-1;\n    for(int n=0; n<N; n++){\n        //for(int i=0; i<N; i++) cout << i << \" \" << n << \" \" << dp[i][n][0] << \" \" << dp[i][n][1] << endl;\n        if(dp[0][n][0] < INF) ans = min(ans, n);\n        if(dp[0][n][1] < 0) ans = min(ans, n);\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stdio.h>\n#include <vector>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stdlib.h>\n#include <time.h>\n#include <iomanip>\n#include <math.h>\n#include <bitset>\n\nusing namespace std;\n\n#define taskname \"A\"\n#define LL long long \n#define uLL unsigned long long \n#define FOR(i,l,r) for(int i = l; i <= r; ++i)\n#define REP(i,l,r) for(int i = l; i < r; ++i)\n#define FORD(i,r,l) for(int i = r; i >= l; --i)\n#define REPD(i,r,l) for(int i = r; i > l; --i)\n#define sz(x) (int)((x).size())\n#define all(x) (x).begin(), (x).end()\n#define debug(x) { cerr << #x << \" = \" << x << endl; }\n#define sci(x) int x; scanf(\"%d\", &x);\n#define scii(x, y) int x, y; scanf(\"%d %d\", &x, &y);\n#define sciii(x, y, z) int x, y, z; scanf(\"%d %d %d\", &x, &y, &z);\n#define pi pair<int,int>\n#define pii pair<int,pi>\n#define piLL pair<LL,LL>\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define _USE_MATH_DEFINES \n/* M_PI */\n#define SetLength2(a, n, t) a=((t*) calloc(n, sizeof(t))) + (n)/2\n\nconst int maxN = 5001;\nconst LL oo = 1e17 + 11;\n\nint tcases = 1;\n\nint N,M,total = 0,res = 0;\nvector <int> e[maxN];\nint C[maxN];\nLL W[maxN],A[maxN],F[maxN][maxN],G[maxN][maxN],f1[maxN],g1[maxN];\npiLL tmp[maxN],fg[maxN];\n\nvoid dfs(int u,int p = 0){\n    W[u] = A[u];\n    C[u] = 1;\n    REP(i,0,e[u].size()){\n        int v = e[u][i];\n        if(v == p) continue;\n        dfs(v,u);\n        W[u] += W[v];\n        C[u] += C[v];\n    }\n}\nvoid cal(int u,int p = 0){\n    REP(i,0,e[u].size()){\n        int v = e[u][i];\n        if(v == p) continue;\n        cal(v,u);\n    }\n    //\n    F[u][0] = W[u];\n    if(C[u] == 1) G[u][0] = A[u] > 0 ? A[u] : oo;\n    else{\n        REP(i,0,C[u]) f1[i] = g1[i] = oo;\n        f1[0] = g1[0] = 0; // \n        \n        REP(node,0,e[u].size()){\n            int v = e[u][node];\n            if(v == p) continue;\n            // cal F[u][i]\n            REP(i,0,C[u]){\n                F[u][i] = G[u][i] = oo;\n                FOR(j,0,min(C[v],i)){\n                    F[u][i] = min(F[u][i],f1[i - j] + min(F[v][j],G[v][j]));\n                    G[u][i] = min(G[u][i],g1[i - j] + G[v][j]);\n                }\n            }\n            REP(i,0,C[u]) f1[i] = F[u][i],g1[i] = G[u][i];\n        }\n        REP(i,0,C[u]){\n            F[u][i] += A[u];\n            if(A[u] < 0) G[u][i] = oo; else G[u][i] += A[u];\n        }\n    }\n    REP(i,0,C[u]){\n        if(F[u][i] < 0 || G[u][i] < oo){\n            F[u][i + 1] = min(F[u][i + 1],0LL);\n            G[u][i + 1] = min(G[u][i + 1],0LL);\n        }\n    }\n}\nvoid testcase(){\n    scanf(\"%d\",&N);\n    FOR(i,1,N) scanf(\"%lli\",&A[i]);\n    \n    REP(i,1,N){\n        scii(u,v);\n        e[u].pb(v);\n        e[v].pb(u);\n    }\n\n    dfs(1);\n\n    FOR(i,1,N){\n        FOR(j,0,N) F[i][j] = G[i][j] = oo;\n    }\n\n    cal(1);\n    \n    FOR(j,0,N) if(F[1][j] < 0 || G[1][j] < oo){\n        printf(\"%d\",j);\n        return ;\n    }\n}\n\nint main(){\n    \n    FOR(i,1,tcases) testcase();\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef BZ\n#pragma GCC optimize \"-O3\"\n#endif\n#include <bits/stdc++.h>\n\n#define FASTIO\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\n#ifdef FASTIO\n#define scanf abacaba\n#define printf abacaba\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\n\n/*\nll pw(ll a, ll b) {\n\tll ans = 1; while (b) {\n\t\twhile (!(b & 1)) b >>= 1, a = (a * a) % MOD;\n\t\tans = (ans * a) % MOD, --b;\n\t} return ans;\n}\n*/\n\nconst int MAXN = 5100;\nconst ll INF = 1e18;\n\nint n;\nll a[MAXN];\n\nvector<int> eds[MAXN];\nint was[MAXN];\n\narray<vector<ll>, 2> dfs1(int v) {\n\twas[v] = 1;\n\tarray<vector<ll>, 2> cur;\n\tif (a[v] < 0)\n\t\tcur[0].push_back(INF), cur[1].push_back(a[v]);\n\telse\n\t\tcur[0].push_back(a[v]), cur[1].push_back(a[v]);\n\tfor (int u: eds[v]) {\n\t\tif (was[u])\n\t\t\tcontinue;\n\t\tauto tmp = dfs1(u);\n\t\tarray<vector<ll>, 2> tmp2;\n\t\ttmp2[0].resize(cur[0].size() - 1 + tmp[0].size() - 1 + 1, INF);\n\t\ttmp2[1].resize(cur[0].size() - 1 + tmp[0].size() - 1 + 1, INF);\n\t\tfor (int i = 0; i < cur[0].size(); ++i)\n\t\t\tfor (int j = 0; j < tmp[0].size(); ++j) {\n\t\t\t\ttmp2[0][i + j] = min(tmp2[0][i + j], cur[0][i] + tmp[0][j]);\n\t\t\t\ttmp2[1][i + j] = min(tmp2[1][i + j], cur[1][i] + tmp[1][j]);\n\t\t\t}\n\t\tcur = tmp2;\n\t}\n\tcur[0].push_back(INF);\n\tcur[1].push_back(INF);\n\tfor (int i = 0; i + 1 < cur[0].size(); ++i) {\n\t\tif (cur[0][i] < INF)\n\t\t\tcur[0][i + 1] = min(cur[0][i + 1], 0ll);\n\t\tif (cur[1][i] < 0)\n\t\t\tcur[0][i + 1] = min(cur[0][i + 1], 0ll);\n\t}\n\tfor (int i = 0; i < cur[0].size(); ++i)\n\t\tcur[1][i] = min(cur[1][i], cur[0][i]);\n\treturn cur;\n}\n\nint main() {\n#ifdef FASTIO\n\tios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n#endif\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> a[i];\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\t--a, --b;\n\t\teds[a].push_back(b);\n\t\teds[b].push_back(a);\n\t}\n\tauto go = dfs1(0);\n\tint ans = n;\n\tfor (int i = 0; i < go[0].size(); ++i)\n\t\tif (go[0][i] < INF || go[1][i] < 0)\n\t\t\tans = min(ans, i + 1);\n\tcout << ans - 1 << \"\\n\";\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n#define NDEBUG\n#define SHOW(...) static_cast<void>(0)\n//!===========================================================!//\n//!  dP     dP                          dP                    !//\n//!  88     88                          88                    !//\n//!  88aaaaa88a .d8888b. .d8888b. .d888b88 .d8888b. 88d888b.  !//\n//!  88     88  88ooood8 88'  '88 88'  '88 88ooood8 88'  '88  !//\n//!  88     88  88.  ... 88.  .88 88.  .88 88.  ... 88        !//\n//!  dP     dP  '88888P' '88888P8 '88888P8 '88888P' dP        !//\n//!===========================================================!//\ntemplate <typename T, typename A>\nstd::istream& operator>>(std::istream& is, std::vector<T, A>& v)\n{\n    for (auto& e : v) { is >> e; }\n    return is;\n}\ntemplate <typename T>\nT read()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate <typename T>\nstd::vector<T> readVec(const std::size_t l)\n{\n    std::vector<T> v(l);\n    for (auto& e : v) { std::cin >> e; }\n    return v;\n}\nusing ld = long double;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr unsigned int MOD = 1000000007;\ntemplate <typename T>\nconstexpr T INF = std::numeric_limits<T>::max() / 4;\ntemplate <typename F>\nconstexpr F PI = static_cast<F>(3.1415926535897932385);\nstd::mt19937 mt{std::random_device{}()};\ntemplate <typename T>\nbool chmin(T& a, const T& b) { return a = std::min(a, b), a == b; }\ntemplate <typename T>\nbool chmax(T& a, const T& b) { return a = std::max(a, b), a == b; }\ntemplate <typename T>\nstd::vector<T> Vec(const std::size_t n, T v) { return std::vector<T>(n, v); }\ntemplate <class... Args>\nauto Vec(const std::size_t n, Args... args) { return std::vector<decltype(Vec(args...))>(n, Vec(args...)); }\ntemplate <typename T>\nconstexpr T popCount(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : (T)__builtin_popcountll(u);\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = (v & 0x5555555555555555ULL) + (v >> 1 & 0x5555555555555555ULL), v = (v & 0x3333333333333333ULL) + (v >> 2 & 0x3333333333333333ULL), v = (v + (v >> 4)) & 0x0F0F0F0F0F0F0F0FULL, static_cast<T>(v * 0x0101010101010101ULL >> 56 & 0x7f);\n#endif\n}\ntemplate <typename T>\nconstexpr T log2p1(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : T(64 - __builtin_clzll(u));\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = static_cast<unsigned long long>(v), v |= (v >> 1), v |= (v >> 2), v |= (v >> 4), v |= (v >> 8), v |= (v >> 16), v |= (v >> 32), popCount(v);\n#endif\n}\ntemplate <typename T>\nconstexpr T clog(const T v) { return v == 0 ? T(0) : log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T msbp1(const T v) { return log2p1(v); }\ntemplate <typename T>\nconstexpr T lsbp1(const T v)\n{\n#ifdef __has_builtin\n    return __builtin_ffsll(v);\n#else\n    return v == 0 ? T(0) : popCount((v & (-v)) - T(1)) + T(1);\n#endif\n}\ntemplate <typename T>\nconstexpr bool ispow2(const T v) { return popCount(v) == 1; }\ntemplate <typename T>\nconstexpr T ceil2(const T v) { return v == 0 ? T(1) : T(1) << log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T floor2(const T v) { return v == 0 ? T(0) : T(1) << (log2p1(v) - 1); }\n//!=================================================!//\n//!   .88888.                             dP        !//\n//!  d8'   '88                            88        !//\n//!  88        88d888b. .d8888b. 88d888b. 88d888b.  !//\n//!  88   YP88 88'  '88 88'  '88 88'  '88 88'  '88  !//\n//!  Y8.   .88 88       88.  .88 88.  .88 88    88  !//\n//!   '88888'  dP       '88888P8 88Y888P' dP    dP  !//\n//!                              88                 !//\n//!                              dP                 !//\n//!=================================================!//\nstruct Graph\n{\n    Graph(const std::size_t v) : V{v}, edge(v), rev_edge(v) {}\n    void addEdge(const std::size_t from, const std::size_t to, const bool bi = false)\n    {\n        assert(from < V), assert(to < V);\n        edge[from].push_back(to), rev_edge[to].push_back(from);\n        if (bi) { addEdge(to, from, false); }\n    }\n    const std::vector<std::size_t>& operator[](const std::size_t i) const { return assert(i < V), edge[i]; }\n    friend std::ostream& operator<<(std::ostream& os, const Graph& g)\n    {\n        os << \"[\\n\";\n        for (std::size_t i = 0; i < g.V; i++) {\n            for (const std::size_t to : g.edge[i]) { os << i << \"->\" << to << \"\\n\"; }\n        }\n        return (os << \"]\\n\");\n    }\n    std::size_t V;\n    std::vector<std::vector<std::size_t>> edge, rev_edge;\n};\n//!============================================!//\n//!    8888ba.88ba             oo              !//\n//!    88  '8b  '8b                            !//\n//!    88   88   88  .d8888b.  dP  88d888b.    !//\n//!    88   88   88  88'  '88  88  88'  '88    !//\n//!    88   88   88  88.  .88  88  88    88    !//\n//!    dP   dP   dP  '88888P8  dP  dP    dP    !//\n//!============================================!//\nusing Poly = std::vector<ll>;\nPoly operator*(const Poly& p1, const Poly& p2)\n{\n    const int s = p1.size() + p2.size() - 1;\n    Poly ans(s, INF<ll>);\n    for (int i = 0; i < p1.size(); i++) {\n        for (int j = 0; j < p2.size(); j++) { chmin(ans[i + j], p1[i] + p2[j]); }\n    }\n    return ans;\n}\nPoly operator+(const Poly& p1, const Poly& p2)\n{\n    const int s = std::max(p1.size(), p2.size());\n    Poly ans(s, INF<ll>);\n    for (int i = 0; i < p1.size(); i++) { chmin(ans[i], p1[i]); }\n    for (int i = 0; i < p2.size(); i++) { chmin(ans[i], p2[i]); }\n    return ans;\n}\nint main()\n{\n    const int N = read<int>();\n    const auto A = readVec<ll>(N);\n    Graph G(N);\n    for (int i = 0, u, v; i < N - 1; i++) { std::cin >> u >> v, G.addEdge(u - 1, v - 1, true); }\n    std::vector<int> sub(N, 1);\n    auto dp0 = Vec(N, Poly(1, INF<ll>)), dp1 = Vec(N, Poly(1, INF<ll>));\n    auto dfs = [&, N](auto&& self, const int s, const int p) -> void {\n        dp0[s][0] = A[s] > 0 ? A[s] : INF<ll>, dp1[s][0] = A[s];\n        for (const int to : G[s]) {\n            if (to == p) { continue; }\n            self(self, to, s);\n            Poly p0(dp0[to].size() + 1, INF<ll>);\n            Poly p1(dp1[to].size() + 1, INF<ll>);\n            for (int i = 0; i < dp1[to].size(); i++) {\n                if (dp0[to][i] < INF<ll>) { p0[i + 1] = 0; }\n                if (dp1[to][i] < 0) { p1[i + 1] = 0; }\n            }\n            p0 = p1 = p0 + p1;\n            p0 = p0 + dp0[to], p1 = p1 + dp1[to];\n            dp0[s] = dp0[s] * p0, dp1[s] = dp1[s] * (p0 + p1);\n            SHOW(s, dp0[s], dp1[s]);\n        }\n    };\n    dfs(dfs, 0, -1);\n    int ans = N;\n    for (int i = N - 1; i >= 0; i--) {\n        if (dp0[0][i] < INF<ll> / 4) { chmin(ans, i); }\n    }\n    for (int i = N - 1; i >= 0; i--) {\n        if (dp1[0][i] < 0) { chmin(ans, i); }\n    }\n    std::cout << ans << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/////////////////////////   _LeMur_\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <ctime>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <ctime>\n#include <list>\n#include <map>\n#include <set>\n\nusing namespace std;\n\nconst int N = 5005;\nconst int inf = 1000 * 1000 * 1000;\nconst int mod = 1000 * 1000 * 1000 + 7;\n\nint n;\nint a[N];\n\nlong long dp[N][N][2];\nlong long d[N][2];\n\nint order[N];\nvector <int> g[N];\n\nvoid dfs(int v,int p){\n    order[v] = 1;\n    dp[v][0][0] = a[v];\n    dp[v][0][1] = (a[v] > 0);\n    for(int i=0;i<(int)g[v].size();i++){\n        int to = g[v][i];\n        if(to == p)continue;\n        dfs(to , v);\n        for(int j=0;j<order[v];j++){\n            for(int h=0;h<order[to];h++){\n                /// edge does not pick\n                if(dp[to][h][0] < 0 || dp[to][h][1]){\n                    d[j + h + 1][0] = min(d[j + h + 1][0] , dp[v][j][0]);\n                    d[j + h + 1][1] |= dp[v][j][1];\n                }\n                /// edge pick\n                d[j + h][0] = min(d[j + h][0] , dp[v][j][0] + dp[to][h][0]);\n                d[j + h][1] |= (dp[v][j][1] & dp[to][h][1]);\n\n            }\n        }\n        order[v] += order[to];\n        for(int j=0;j<order[v];j++){\n            dp[v][j][0] = d[j][0];\n            dp[v][j][1] = d[j][1];\n            ///\n            d[j][0] = inf * 1ll * inf;\n            d[j][1] = 0;\n        }\n    }\n}\n\nint main(){\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++){\n        scanf(\"%d\",&a[i]);\n    }\n    for(int i=1;i<n;i++){\n        int a , b;\n        scanf(\"%d%d\",&a,&b);\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    for(int i=0;i<=n;i++){\n        d[i][0] = inf * 1ll * inf;\n        d[i][1] = 0;\n    }\n    dfs(1 , -1);\n    for(int i=0;i<n;i++){\n        if(dp[1][i][0] < 0 || dp[1][i][1]){\n            cout<<i<<endl;\n            break;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\ntemplate <typename X, typename Y> void Max(X &x, Y y) {\n  x = (x < y) ? y : x;\n}\ntemplate <typename X, typename Y> void Min(X &x, Y y) {\n  x = (x <= y) ? x : y;\n}\n\nconst int N = 5005;\nint n, a[N], f[N][N][2], h[N][2], sz[N];\nvector <int> ad[N];\n\nvoid dfs(int u, int p) {\n  sz[u] = 1;\n  f[u][0][0] = (a[u] < 0) ? 1e18 : a[u];\n  f[u][0][1] = (a[u] > 0) ? 1e18 : a[u];\n  for(auto &v : ad[u]) {\n    if(v != p) {\n      dfs(v, u);\n      for(int i = 0; i < sz[u] + sz[v]; ++i) h[i][0] = h[i][1] = 1e18;\n      for(int i = 0; i < sz[u]; ++i) {\n        for(int j = 0; j < sz[v]; ++j) {\n          int tot = i + j;\n          Min(h[tot][0], f[u][i][0] + f[v][j][0]);\n          Min(h[tot][1], f[u][i][0] + f[v][j][1]);\n          Min(h[tot][1], f[u][i][1] + f[v][j][0]);\n          Min(h[tot][1], f[u][i][1] + f[v][j][1]);\n          if(f[v][j][0] < 1e18 || f[v][j][1] < 0) {\n            Min(h[tot + 1][0], f[u][i][0]);\n            Min(h[tot + 1][1], f[u][i][1]);\n          }\n        }\n      }\n      sz[u] += sz[v];\n      for(int i = 0; i < sz[u]; ++i) {\n        f[u][i][0] = h[i][0]; f[u][i][1] = h[i][1];\n      }\n    }\n  }\n}\n\nmain() {\n  ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n  cin >> n;\n  for(int i = 1; i <= n; ++i) cin >> a[i];\n  for(int i = 1; i < n; ++i) {\n    int u, v;\n    cin >> u >> v;\n    ad[u].push_back(v);\n    ad[v].push_back(u);\n  }\n  dfs(1, -1);\n  for(int i = 0; i < n; ++i) {\n    if(f[1][i][0] < 1e18 || f[1][i][1] < 0) {\n      cout << i;\n      return 0;\n    }\n  }\n}\n/*\n6\n10 -1 10 -1 10 -1\n1 2\n2 3\n3 4\n4 5\n5 6\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define fi first\n#define se second\n#define pb push_back\n#define rep(i, s, n) for (int i = s; i < n; i++)\n#define rrep(i, s, n) for (int i = (n)-1; i >= (s); i--)\n#define all(a) a.begin(),a.end()\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\nconst long long MOD = 1000000007, INF = 1e17;\ntemplate<class T>inline bool chmax(T& a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<class T>inline bool chmin(T& a,T b){if(a>b){a=b;return true;}return false;}\nstring get_str(string s) {\n\ts+=',';\n\tstring ret=\"\";\n\tfor(int i=0; i<s.size(); i++) {\n\t\tif(s[i]==',') ret+=\"=%ld, \";\n\t\telse ret+=s[i];\n\t}\n\treturn ret;\n}\n#define dump(...) printf(get_str(#__VA_ARGS__).c_str(),__VA_ARGS__);cout<<endl\n \n#define endl '\\n'\n#define IOS()                     \\\n\tios_base::sync_with_stdio(0); \\\n\tcin.tie(0)\n template<typename T>vector<T>\nmake_v(size_t a){return vector<T>(a);}\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n\treturn vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n \ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value==0>::type\nfill_v(T &t,const V &v){t=v;}\n \ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t,const V &v){\n\tfor(auto &e:t) fill_v(e,v);\n}\n//******************************************************************************\n\nint N,MINF=1e17;\nvint a;\nvint g[5050];\n\n\nvector<vector<int>>dfs(int now,int par){\n\tauto dp = make_v<int>(2,2);\n\tfill_v(dp,INF);\n\tdp[0][0] = a[now];\n\tif(a[now]>0)dp[0][1] = a[now];\n\tfor(auto e:g[now]){\n\t\tif(e==par)continue;\n\t\tauto tmp = dfs(e,now);\n\t\tint n = dp.size();\n\t\tint m = tmp.size();\n\t\tauto new_dp = make_v<int>(n+m-1,2);\n\t\tfill_v(new_dp,INF);\n\t\trep(i,0,n){\n\t\t\trep(j,0,m){\n\t\t\t\trep(k,0,2){\n\t\t\t\t\trep(l,0,2){\n\t\t\t\t\t\tchmin(new_dp[i+j][k&l],dp[i][k]+tmp[j][l]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(i+j+1>=n+m-1)continue;\n\t\t\t\tif(tmp[j][0]<0){\n\t\t\t\t\tchmin(new_dp[i+j+1][0],dp[i][0]);\n\t\t\t\t\tchmin(new_dp[i+j+1][1],dp[i][1]);\n\t\t\t\t}\n\t\t\t\tif(tmp[j][1]<INF/2){\n\t\t\t\t\tchmin(new_dp[i+j+1][0],dp[i][0]);\n\t\t\t\t\tchmin(new_dp[i+j+1][1],dp[i][1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdp = new_dp;\n\t}\n\treturn dp;\n}\n\nsigned main()\n{\n\t//IOS();\n\tcin>>N;\n\ta.resize(N);\n\tfor(int i = 0;i < N;i++){\n\t\tcin>>a[i];\n\t}\n\trep(i,0,N-1){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\ta--;b--;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\tauto dp = dfs(0,-1);\n\tint ans = INF;\n\trep(j,0,N+1){\n\t\tif(dp[j][1]<INF/2)chmin(ans,j);\n\t\tif(dp[j][0]<0)chmin(ans,j);\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define ll long long\n#define N 5010\nint read()\n{\n    int x=0,f=1;char c=getchar();\n    while (c<'0'||c>'9') {if (c=='-') f=-1;c=getchar();}\n    while (c>='0'&&c<='9') x=(x<<1)+(x<<3)+(c^48),c=getchar();\n    return x*f;\n}\nint n,a[N],p[N],g[N],size[N],t;\nll sum[N],f[N][N];\nstruct data{int to,nxt;\n}edge[N<<1];\nvoid addedge(int x,int y){t++;edge[t].to=y,edge[t].nxt=p[x],p[x]=t;}\nvoid dfs(int k,int from)\n{\n    sum[k]=a[k];\n    for (int i=p[k];i;i=edge[i].nxt)\n    if (edge[i].to!=from)\n    {\n        dfs(edge[i].to,k);\n        sum[k]+=sum[edge[i].to];\n    }\n    if (a[k]>0)\n    {\n        g[k]=0;\n        for (int i=p[k];i;i=edge[i].nxt)\n        if (edge[i].to!=from)\n        {\n            int x=g[edge[i].to];\n            for (int j=0;j<=n;j++)\n            if (f[edge[i].to][j]<0) {x=min(x,j+1);break;}\n            g[k]+=x;\n        }\n    }\n    f[k][0]=a[k];\n    size[k]=1;\n    for (int i=p[k];i;i=edge[i].nxt)\n    if (edge[i].to!=from)\n    {\n        for (int j=size[k]+size[edge[i].to];j>=0;j--)\n        {\n            f[k][j]+=sum[edge[i].to];if (j-g[edge[i].to]-1>=0) f[k][j]=min(f[k][j],f[k][j-g[edge[i].to]-1]);\n            for (int x=max(0,j-size[k]);x<=min(j,size[edge[i].to]);x++)\n            {\n                if (x) f[k][j]=min(f[k][j],f[k][j-x]+f[edge[i].to][x]);\n                if (x<j&&f[edge[i].to][x]<0) f[k][j]=min(f[k][j],f[k][j-x-1]);\n            }\n        }\n        size[k]+=size[edge[i].to];\n    }\n}\nint main()\n{\n    /*freopen(\"e.in\",\"r\",stdin);\n    freopen(\"e.out\",\"w\",stdout);*/\n    n=read();\n    for (int i=1;i<=n;i++) a[i]=read();\n    for (int i=1;i<n;i++)\n    {\n        int x=read(),y=read();\n        addedge(x,y),addedge(y,x);\n    }\n    memset(g,42,sizeof(g));\n    memset(f,42,sizeof(f));\n    dfs(1,1);\n    /*for (int i=1;i<=n;i++) cout<<a[i]<<' ';cout<<endl;\n    for (int i=1;i<=n;i++) cout<<g[i]<<' ';cout<<endl;\n    cout<<endl;\n    for (int i=1;i<=n;i++)\n    {\n        for (int j=0;j<n;j++)\n        cout<<f[i][j]<<' ';\n        cout<<endl;;\n    }\n    for (int i=1;i<=n;i++) cout<<sum[i]<<' ';cout<<endl;*/\n    int ans=g[1];\n    for (int i=0;i<=n;i++) \n    if (f[1][i]<0) {ans=min(ans,i);break;}\n    cout<<ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "///////////////////////////////////////////////////////////////////////////////\n\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <cmath>\n#include <typeinfo>\n#include <numeric>\n#include <cassert>\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n\nusing namespace std;\n\n///////////////////////////////////////////////////////////////////////////////\n\n#define DEBUG 0\n\n#define pb push_back\n#define V vector\n#define M unordered_map\n\n#define rep(i,n) for(ll i=0LL;i<n;++i)\n#define srep(i,s,n) for(ll i=s;i<n;++i)\n#define rrep(i,n) for(ll i=n-1LL;i>=0LL;--i)\n#define ALL(a) (a).begin(),(a).end()\n#define CIN(x) do { \\\n    assert(!cin.eof()); \\\n    cin >> x; \\\n    assert(!cin.fail()); \\\n} while(0);\n#if DEBUG\n#define debug_print(...) _debug_print(__VA_ARGS__)\n#define debug_printf(...) printf(__VA_ARGS__)\n#else // DEBUG\n#define debug_print(...)\n#define debug_printf(...)\n#endif // DEBUG\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef tuple<ll, ll> t2;\ntypedef tuple<ll, ll, ll> t3;\ntypedef tuple<ll, ll, ll, ll> t4;\ntypedef tuple<ll, ll, ll, ll, ll> t5;\ntemplate <typename T>\nusing priority_queue_incr = priority_queue<T, V<T>, greater<T>>;\n\ntemplate <typename S, typename T>\nT get_m(M<S, T> &m, S k, S default_value)\n{\n    if (m.find(k) == m.end()) return m[k] = default_value;\n    return m[k];\n}\n\nstruct UnionFind\n{\n    ull *parent, *count, *rank;\n\n    UnionFind(ull n) {\n        parent = new ull[n+1];\n        count = new ull[n+1];\n        rank = new ull[n+1];\n        for (ull i = 0ULL; i < n+1; ++i) {\n            parent[i] = i;\n            count[i] = 1;\n            rank[i] = 0;\n        }\n    }\n\n    ~UnionFind() {\n        delete rank;\n        delete count;\n        delete parent;\n    }\n\n    ull root(ull i) {\n        if (parent[i] == i) return i;\n        parent[i] = root(parent[i]);\n        return parent[i];\n    }\n\n    void unite(ull i, ull j) {\n        ull rooti = root(i);\n        ull rootj = root(j);\n\n        if (rooti == rootj) return;\n\n        if (rank[rootj] < rank[rooti]) {\n            parent[i] = parent[j] = parent[rootj] = rooti;\n            count[rooti] += count[rootj];\n        }\n        else {\n            parent[i] = parent[j] = parent[rooti] = rootj;\n            count[rootj] += count[rooti];\n            if (rank[rootj] == rank[rooti]) rank[rootj]++;\n        }\n    }\n\n    bool same(ull i, ull j) {\n        return root(i) == root(j);\n    }\n};\n\nstruct UnionFindM\n{\n    M<ull, ull> parent, count, rank;\n\n    ull root(ull i) {\n        ull parent_i = get_m(parent, i, i);\n        if (parent_i == i) return i;\n        return parent[i] = root(parent_i);\n    }\n\n    void unite(ull i, ull j) {\n        ull rooti = root(i);\n        ull rootj = root(j);\n\n        if (rooti == rootj) return;\n\n        if (get_m(rank, rootj, 0ULL) < get_m(rank, rooti, 0ULL)) {\n            parent[i] = parent[j] = parent[rootj] = rooti;\n            count[rooti] = get_m(count, rooti, 1ULL) + get_m(count, rootj, 1ULL);\n        }\n        else {\n            parent[i] = parent[j] = parent[rooti] = rootj;\n            count[rootj] = get_m(count, rootj, 1ULL) + get_m(count, rooti, 1ULL);\n            if (get_m(rank, rootj, 0ULL) == get_m(rank, rooti, 0ULL)) rank[rootj]++;\n        }\n    }\n\n    bool same(ull i, ull j) {\n        return root(i) == root(j);\n    }\n};\n\nstruct BIT\n{\n    ll *tree;\n    ll size;\n\n    BIT(ll n, ll init) {\n        tree = new ll[n+1];\n        size = n;\n        memset(tree, 0, sizeof(ll) * (n+1));\n        this->init(init);\n    }\n\n    void init(ll init) {\n        rep (i0, size) {\n            ll idx = i0 + 1LL;\n            while (idx <= size) {\n                tree[idx] += init;\n                idx += (idx & (-idx));\n            }\n        }\n    }\n\n    // idx is 1 origin\n    void add(ll idx, ll x) {\n        assert(idx > 0LL);\n        while (idx <= size) {\n            tree[idx] += x;\n            idx += (idx & (-idx));\n        }\n    }\n\n    // idx is 1 origin\n    ll sum(ll idx) {\n        assert(idx > 0LL);\n        ll ret = 0LL;\n        while (idx > 0LL) {\n            ret += tree[idx];\n            idx -= (idx & (-idx));\n        }\n        return ret;\n    }\n};\n\nstruct MaxFlow {\n    V<ll> links[1005];\n    ll capacities[1005][1005];\n    ll nodes;\n\n    MaxFlow(ll nodes) {\n        // i == 0       --> S\n        // i == nodes+1 --> T\n        rep (i, nodes+2LL) links[i].clear();\n        memset(capacities, 0, sizeof(capacities));\n        this->nodes = nodes;\n    }\n\n    void add_path(ll a, ll b, ll capacity) {\n        links[a].pb(b);\n        links[b].pb(a);\n        capacities[a][b] = capacity;\n        capacities[b][a] = 0LL;\n    }\n\n    ll solve(void) {\n        deque<V<ll>> q;\n        ll ret = 0LL;\n\n        for ( ; ; q.clear()) {\n\n            V<ll> start;\n            start.pb(0);\n            q.push_front(start);\n\n            bool checked[nodes+2];\n            memset(checked, 0, sizeof(checked));\n\n            V<ll> found;\n\n            for ( ; !(q.empty()); ) {\n                V<ll> path = q.front(); q.pop_front();\n                ll last = path[path.size()-1];\n\n                if (checked[last]) continue;\n                if (last == nodes+1) {\n                    found = path;\n                    break;\n                }\n\n                checked[last] = true;\n                for (auto next : (links[last])) {\n                    if (capacities[last][next] == 0) continue;\n                    V<ll> newpath(path);\n                    newpath.pb(next);\n                    q.push_front(newpath);\n                }\n            }\n\n            if (found.size() == 0) {\n                break;\n            }\n            else {\n                ll flowcount = capacities[found[0]][found[1]];\n                rep (i, found.size()-1) {\n                    ll src = found[i];\n                    ll dst = found[i+1];\n                    flowcount = min(flowcount, capacities[src][dst]);\n                }\n                rep (i, found.size()-1) {\n                    ll src = found[i];\n                    ll dst = found[i+1];\n                    capacities[src][dst] -= flowcount;\n                    capacities[dst][src] += flowcount;\n                }\n                ret += flowcount;\n            }\n        }\n\n        return ret;\n    }\n};\n\ntemplate <typename T>\nstruct SegmentTree {\n    T *nodes;\n    t2 *ranges;  // [start, end)\n    ll nodecount;\n    ll itemcount;\n    T unit;\n    T (*op)(T, T);\n\n    SegmentTree(ll itemcount, T unit, T op(T, T)) {\n        ll orig_itemcount = itemcount;\n        this->itemcount = 1LL;\n        while (this->itemcount < orig_itemcount) this->itemcount *= 2LL;\n        nodecount = this->itemcount * 2 - 1;\n        nodes = new T[nodecount];\n        ranges = new t2[nodecount];\n        this->unit = unit;\n        this->op = op;\n\n        ll start = 0LL;\n        ll end = this->itemcount;\n        ll len = this->itemcount;\n\n        rep (i, nodecount) {\n            nodes[i] = unit;\n            ranges[i] = t2(start, end);\n            if (end >= this->itemcount) {\n                len /= 2LL;\n                start = 0LL;\n                end = len;\n            }\n            else {\n                start = end;\n                end = start + len;\n            }\n        }\n    }\n\n    void update(ll k, T v) {\n        ll idx = k + itemcount - 1LL;\n        nodes[idx] = v;\n        idx = (idx - 1LL) / 2LL;\n\n        for ( ; idx >= 0; idx = (idx - 1LL) / 2LL) {\n            nodes[idx] = op(nodes[idx * 2LL + 1LL],\n                            nodes[idx * 2LL + 2LL]);\n            if (!idx) break;\n        }\n    }\n\n    T query(ll start, ll end) const {\n        return _query(start, end, 0LL);\n    }\n\n    T _query(ll start, ll end, ll idx) const {\n        ll rstart = get<0>(ranges[idx]);\n        ll rend = get<1>(ranges[idx]);\n\n        if (start <= rstart && rend <= end) {\n            return nodes[idx];\n        }\n        if (rend <= start || end <= rstart) {\n            return unit;\n        }\n        T left = _query(start, end, idx * 2LL + 1LL);\n        T right = _query(start, end, idx * 2LL + 2LL);\n        return op(left, right);\n    }\n\n};\n\nvoid llin(ll &a)\n{\n    CIN(a);\n}\n\nvoid llinl1(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a;\n        CIN(a);\n        v.push_back(a);\n    }\n}\n\nvoid llinl2(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a, b;\n        CIN(a >> b);\n        v.push_back(t2(a, b));\n    }\n}\n\nvoid llinl3(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a, b, c;\n        CIN(a >> b >> c);\n        v.push_back(t3(a, b, c));\n    }\n}\n\nvoid llinl4(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a, b, c, d;\n        CIN(a >> b >> c >> d);\n        v.push_back(t4(a, b, c, d));\n    }\n}\n\nvoid llina(auto &v, ll count)\n{\n    llinl1(v, count);\n}\n\ntemplate <typename T>\nT min(const V<T> v)\n{\n    T ret = v[0];\n    for (auto i : v) ret = min(ret, i);\n    return ret;\n}\n\ntemplate <typename T>\nT max(const V<T> v)\n{\n    T ret = v[0];\n    for (auto i : v) ret = max(ret, i);\n    return ret;\n}\n\nll absll(ll x)\n{\n    if (x < 0) return -x;\n    return x;\n}\n\nll mod_mlt(ll x, ll y, ll mod)\n{\n    ll ret = 0LL;\n    x %= mod;\n\n    while (y) {\n        if (y & 1LL) {\n            ret += x;\n            ret %= mod;\n        }\n        y >>= 1;\n        x <<= 1;\n        x %= mod;\n    }\n\n    return ret;\n}\n\n// O(log(exp))\nll mod_pow(ll base, ll exp, ll mod)\n{\n    ll ret = 1LL;\n\n    for ( ; exp; ) {\n        if (exp & 1LL) {\n            ret *= base;\n            ret %= mod;\n        }\n        base = (base * base) % mod;\n        exp >>= 1;\n    }\n\n    return ret;\n}\n\n// O(log(mod))\nll mod_inv(ll x, ll mod)\n{\n    // available only when mod is prime\n    return mod_pow(x, mod - 2LL, mod);\n}\n\nll gcm(ll x, ll y)\n{\n    while (y != 0) {\n        ll z = x % y;\n        x = y;\n        y = z;\n    }\n    return x;\n}\n\ntemplate <typename T>\nvoid sort(V<T> &v)\n{\n    sort(v.begin(), v.end());\n}\n\ntemplate <typename T>\nvoid sort_reverse(V<T> &v)\n{\n    sort(v.begin(), v.end(), greater<T>());\n}\n\nvoid get_divisors(V<ll> &retlist, ll x)\n{\n    for (ll i = 1LL; i < sqrt(x) + 3LL; ++i) {\n        if (x % i == 0LL) {\n            retlist.push_back(i);\n            retlist.push_back(x / i);\n        }\n    }\n}\n\nvoid get_factors(V<ll> &retlist, ll x)\n{\n    for (ll i = 2LL; i < (ll)(sqrt(x)) + 3LL; ++i) {\n        while (x % i == 0LL) {\n            retlist.pb(i);\n            x /= i;\n        }\n    }\n    retlist.pb(x);\n}\n\nbool is_prime(ll x)\n{\n    V<ll> factors, factors2;\n\n    get_factors(factors, x);\n\n    for (auto factor : factors) {\n        if (factor > 1) factors2.pb(factor);\n    }\n\n    return factors2.size() == 1 && x == factors2[0];\n}\n\ntemplate <typename T>\nvoid intersection(const set<T> &a, const set<T> &b,\n                  set<T> &result)\n{\n    set_intersection(ALL(a), ALL(b), inserter(result, result.end()));\n}\n\null combination(ll x, ll y)\n{\n    if (y > x / 2LL) y = x - y;\n\n    ull ret = 1LL;\n    for (ll i = 0LL; i < y; ++i) {\n        ret *= x--;\n        ret /= (i + 1LL);\n    }\n\n    return ret;\n}\n\null mod_combination(ll x, ll y, ll mod)\n{\n    if (y > x / 2LL) y = x - y;\n\n    ll ret = 1;\n\n    for (ll i = 0LL; i < y; ++i) {\n        ret = (ret * x--) % mod;\n        ret = (ret * mod_inv(i + 1LL, mod)) % mod;\n    }\n\n    return ret;\n}\n\nvoid make_linklist(const V<t2> &srclist, V<ll> dstlist[])\n{\n    for (auto src : srclist) {\n        ll a = get<0>(src);\n        ll b = get<1>(src);\n        dstlist[a].pb(b);\n        dstlist[b].pb(a);\n    }\n}\n\nvoid make_parental_relation(const V<ll> linklist[], ll root, ll n,\n                            ll parent[], V<ll> children[], ll level[])\n{\n    queue<ll> q;\n    bool checked[n+1];\n\n    memset(checked, 0, sizeof(checked));\n\n    q.push(root);\n    checked[root] = true;\n    parent[root] = root;\n    level[root] = 0LL;\n\n    for ( ; !(q.empty()); ) {\n        ll now = q.front(); q.pop();\n        for (auto next : linklist[now]) {\n            if (checked[next]) continue;\n            q.push(next);\n            checked[next] = true;\n            parent[next] = now;\n            children[now].pb(next);\n            level[next] = level[now] + 1LL;\n        }\n    }\n}\n\nvoid make_subtree_sizes(const ll child_count[], const ll parents[],\n                        ll subtree_sizes[], ll n)\n{\n    ll remain_count[n+1LL];\n    memcpy(remain_count, child_count, sizeof(remain_count));\n\n    queue<ll> q;\n    srep (node, 1LL, n+1LL) {\n        subtree_sizes[node] = 1LL;\n        if (remain_count[node] > 0) continue;\n        q.push(node);\n    }\n\n    while (!q.empty()) {\n        ll node = q.front(); q.pop();\n        ll parent = parents[node];\n        if (node == parent) continue;\n        remain_count[parent]--;\n        subtree_sizes[parent] += subtree_sizes[node];\n        if (remain_count[parent] == 0LL) q.push(parent);\n    }\n}\n\nvoid get_centroids(const V<ll> children[], const ll subtree_sizes[],\n                   ll root, ll n, V<ll> &centroids)\n{\n    queue<ll> q;\n    q.push(root);\n\n    while (!q.empty()) {\n        ll now = q.front(); q.pop();\n        bool is_centroid = true;\n        for (auto child : children[now]) {\n            q.push(child);\n            if (subtree_sizes[child] > n / 2LL) is_centroid = false;\n        }\n        if (n - subtree_sizes[now] > n / 2LL) is_centroid = false;\n        if (is_centroid) centroids.pb(now);\n    }\n\n    assert(centroids.size() == 1LL || centroids.size() == 2LL);\n}\n\n#define POW_ANCESTOR_MAXSIZE   20\n\n// preprocess for get_common_ancestor()\nvoid make_pow_ancestor(const ll parent[], ll n,\n                       ll (*pow_ancestor)[POW_ANCESTOR_MAXSIZE])\n{\n    rep (i, n) pow_ancestor[i+1][0] = parent[i+1];\n\n    for (int pow2 = 1; pow(2, pow2) <= n; ++pow2) {\n        rep (i0, n) {\n            int i = i0+1;\n            ll prev = pow_ancestor[i][pow2-1];\n            pow_ancestor[i][pow2] = pow_ancestor[prev][pow2-1];\n        }\n    }\n}\n\nll get_common_ancestor(ll n, ll x, ll y,\n                       const ll (*pow_ancestor)[POW_ANCESTOR_MAXSIZE],\n                       const ll level[])\n{\n    if (level[x] < level[y]) {\n        ll diff = level[y] - level[x];\n        for ( ; diff; ) {\n            ll bit = diff & -diff;\n            y = pow_ancestor[y][(int)log2(bit)];\n            diff -= bit;\n        }\n    }\n    else {\n        ll diff = level[x] - level[y];\n        for ( ; diff; ) {\n            ll bit = diff & -diff;\n            x = pow_ancestor[x][(int)log2(bit)];\n            diff -= bit;\n        }\n    }\n\n    if (x == y) return x;\n\n    rrep (i, (int)log2(n)+1) {\n        if (pow_ancestor[x][i] != pow_ancestor[y][i]) {\n            x = pow_ancestor[x][i];\n            y = pow_ancestor[y][i];\n        }\n    }\n\n    return pow_ancestor[x][0];\n}\n\nvoid kmp_init(const string &pattern, ll kmp_next[])\n{\n    kmp_next[0] = -1LL;\n\n    ll plen = pattern.size();\n    ll prefix_end = -1;\n\n    rep (suffix_end, pattern.size()) {\n        while (prefix_end >= 0 && pattern[suffix_end] != pattern[prefix_end]) {\n            prefix_end = kmp_next[prefix_end];\n        }\n        kmp_next[suffix_end+1] = ++prefix_end;\n    }\n\n    kmp_next[0] = 0LL;\n}\n\n// founds ... list of text's idx of match position. start position idx.\nvoid kmp_search(const string &text, const string &pattern, const ll kmp_next[],\n                V<ll> &founds)\n{\n    ll text_size = text.size();\n    ll pattern_size = pattern.size();\n    ll text_start = 0LL;\n    ll pattern_idx = 0LL;\n\n    assert(pattern_size <= text_size);\n\n    for ( ; ; ) {\n        if (text_start + pattern_idx >= text_size) break;\n        if (pattern_idx >= pattern_size) break;\n\n        if (text[text_start+pattern_idx] == pattern[pattern_idx]) {\n            pattern_idx++;\n            if (pattern_idx == pattern_size) {\n                founds.pb(text_start);\n                pattern_idx = kmp_next[pattern_idx];\n                text_start += (pattern_size - pattern_idx);\n            }\n        }\n\n        else {\n            text_start += (pattern_idx - kmp_next[pattern_idx]);\n            pattern_idx = kmp_next[pattern_idx];\n            if (pattern_idx == 0LL && text[text_start] != pattern[0]) {\n                text_start++;\n            }\n        }\n    }\n}\n\nvoid _debug_print(auto x)\n{\n    cout << x << endl;\n}\n\nvoid _debug_print(const t2 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2 << endl;\n}\n\nvoid _debug_print(const t3 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    ll x3 = get<2>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2 << \" -- \" << x3 << endl;\n}\n\nvoid _debug_print(const t4 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    ll x3 = get<2>(x);\n    ll x4 = get<3>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2\n        << \" -- \" << x3 << \" -- \" << x4 << endl;\n}\n\ntemplate <typename T>\nvoid _debug_print(T xarray[], ll n)\n{\n    rep (i, n) _debug_print(xarray[i]);\n}\n\ntemplate <typename T>\nvoid _debug_print(const V<T> &xlist)\n{\n    for (auto x : xlist) {\n        cout << \"-- \";\n        _debug_print(x);\n    }\n}\n\ntemplate <typename T>\nvoid _debug_print(const set<T> &xset)\n{\n    for (auto x : xset) {\n        cout << \"-- \";\n        _debug_print(x);\n    }\n}\n\ntemplate <typename S, typename T>\nvoid _debug_print(const M<S, T> &xlist)\n{\n    for (auto x : xlist) {\n        S k = x.first;\n        T v = x.second;\n        cout << \"====\" << endl;\n        cout << \"K=\";\n        _debug_print(k);\n        cout << \"V=\";\n        _debug_print(v);\n    }\n}\n\nint _main();\nint main()\n{\n    cout << setprecision(12);\n    return _main();\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\n#define SZ   5003\n#define INF  1e18\n\nvoid make_partsize(ll partsize[SZ], const ll parents[SZ],\n                   const V<ll> children[SZ], const ll childcounts[SZ], ll n)\n{\n    queue<ll> q;\n    srep (v, 1LL, n+1LL) if (childcounts[v] == 0LL) q.push(v);\n\n    ll cc[SZ];\n    memcpy(cc, childcounts, sizeof(ll) * SZ);\n\n    while (!q.empty()) {\n        ll v = q.front(); q.pop();\n        ll vp = parents[v];\n        partsize[v] = 1LL;\n        for (auto vc : children[v]) partsize[v] += partsize[vc];\n        cc[vp]--;\n        if (cc[vp] == 0LL) q.push(vp);\n    }\n\n    debug_printf(\"---- partsize\\n\"); debug_print(partsize, n+1);\n}\n\nvoid solve(const ll parents[SZ], const V<ll> children[SZ],\n           ll childcounts[SZ], const ll partsize[SZ],\n           const V<ll> &alist, ll n)\n{\n    queue<ll> q;\n    srep (v, 1LL, n+1LL) if (childcounts[v] == 0LL) q.push(v);\n\n    static ll dp_battery[SZ][SZ];\n    static ll dp_free[SZ][SZ];\n    static ll subdp_battery[SZ][SZ];\n    static ll subdp_free[SZ][SZ];\n\n    rep (i, SZ) rep (j, SZ) dp_battery[i][j] = INF + 1LL;\n    rep (i, SZ) rep (j, SZ) dp_free[i][j] = INF + 1LL;\n\n    while (!q.empty()) {\n        ll v = q.front(); q.pop();\n\n        debug_printf(\"---- v=%lld\\n\", v);\n\n        ll csize = children[v].size();\n        ll origsize = 1LL;\n\n        rep (i, csize+1) rep (j, partsize[v]+1) subdp_battery[i][j] = INF + 1LL;\n        rep (i, csize+1) rep (j, partsize[v]+1) subdp_free[i][j] = INF + 1LL;\n        subdp_battery[0][1] = ((alist[v] > 0LL) ? alist[v] : INF + 1LL);\n        subdp_free[0][1] = alist[v];\n\n        rep (childidx, csize) {\n            ll vchild = children[v][childidx];\n\n            srep (origcount, 1LL, origsize + 1LL) {\n                srep (addcount, 1LL, partsize[vchild] + 1LL) {\n                    ll count = origcount + addcount;\n                    if (dp_battery[vchild][addcount] < INF ||\n                        dp_free[vchild][addcount] < 0LL) {\n                        subdp_battery[childidx+1][count] = min(\n                            subdp_battery[childidx+1][count],\n                            subdp_battery[childidx][origcount]);\n                    }\n                    subdp_battery[childidx+1][count-1] = min(\n                        subdp_battery[childidx+1][count-1],\n                        subdp_battery[childidx][origcount] +\n                        dp_battery[vchild][addcount]);\n                    if (dp_battery[vchild][addcount] < INF ||\n                        dp_free[vchild][addcount] < 0LL) {\n                        subdp_free[childidx+1][count] = min(\n                            subdp_free[childidx+1][count],\n                            subdp_free[childidx][origcount]);\n                    }\n\n                    subdp_free[childidx+1][count-1] = min(\n                        subdp_free[childidx+1][count-1],\n                        subdp_free[childidx][origcount] +\n                        dp_free[vchild][addcount]);\n                }\n            }\n\n            origsize += partsize[vchild];\n        }\n\n        rep (i, SZ) dp_battery[v][i] = subdp_battery[csize][i];\n        rep (i, SZ) dp_free[v][i] = subdp_free[csize][i];\n\n        debug_printf(\"---- dp\\n\");\n        srep (i, 1LL, csize+2LL) {\n            debug_printf(\"count=%lld battery=%lld free=%lld\\n\",\n                         i, dp_battery[v][i], dp_free[v][i]);\n        }\n\n        if (parents[v] >= 1LL && --childcounts[parents[v]] <= 0LL) {\n            q.push(parents[v]);\n        }\n    }\n\n    ll ans = n - 1LL;\n\n    srep (i, 1LL, SZ) {\n        if (dp_battery[1][i] < INF) {\n            ans = min(ans, i-1LL);\n            break;\n        }\n    }\n\n    srep (i, 1LL, SZ) {\n        if (dp_free[1][i] < 0LL) {\n            ans = min(ans, i-1LL);\n            break;\n        }\n    }\n\n    debug_printf(\"---- ans\\n\");\n    cout << ans << endl;\n}\n\nint _main()\n{\n    ll n; llin(n);\n    V<ll> alist; alist.pb(0LL); llina(alist, n);\n    V<t2> uvlist; llinl2(uvlist, n-1LL);\n\n    static V<ll> linklist[SZ];\n    make_linklist(uvlist, linklist);\n\n    static ll parents[SZ];\n    static V<ll> children[SZ];\n    static ll level[SZ];\n    make_parental_relation(linklist, 1LL, n, parents, children, level);\n\n    static ll childcounts[SZ];\n    srep (i, 1LL, n+1LL) childcounts[i] = children[i].size();\n\n    static ll partsize[SZ];\n    make_partsize(partsize, parents, children, childcounts, n);\n\n    parents[1] = -1LL;\n    solve(parents, children, childcounts, partsize, alist, n);\n\n    return 0;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define F first\n#define S second\n#define int long long\n#define ll long long\n//#define int  unsigned long long\n#define pb push_back\n//#define double long double\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef  tree< int , null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\nconst int mod = 1e9 + 7;\nconst int N = 5050;\nconst int K = 20;\nint dp1[N], dp2[N][N], sz[N], a[N];\nvector < int > g[N];\nint s[N];\nvoid dfs(int v, int p = -1){\n    sz[v]++;\n    s[v] = a[v];\n    if (g[v].size() != 1 || p == -1) dp1[v] = 0;\n    for (auto u: g[v]){\n        if (u == p) continue;\n        dfs(u, v);\n        s[v] += s[u];\n        for (int i = 0; i < sz[u]; i++){\n            if (dp1[u] + 1 < N) dp2[u][dp1[u] + 1] = min(dp2[u][dp1[u] + 1], 0LL);\n        }\n        for (int i = 0; i < sz[u]; i++){\n            if (dp2[u][i] < 0){\n                dp1[u] = min(dp1[u], i + 1);\n                dp2[u][i + 1] = min(dp2[u][i + 1], 0LL);\n            }\n        }\n        if (sz[v] == 1){\n            for (int i = 0; i <= sz[u]; i++) dp2[v][i] = dp2[u][i];\n        } else{\n            for (int i = sz[v] + sz[u]; i >= 0; i--){\n                dp2[v][i] = dp2[v][i] + dp2[u][0];\n                for (int j = min(sz[u], i); j >= 0; j--){\n                    dp2[v][i] = min(dp2[v][i], dp2[v][i - j] + dp2[u][j]);\n                }\n            }\n        }\n        sz[v] += sz[u];\n        dp1[v] += dp1[u];\n    }\n    if (a[v] < 0){\n        dp1[v] = 1e15;\n        dp2[v][0] = s[v] - a[v];\n    }\n   // cout << \"s[v] = \" << s[v] << \" v = \" << v << endl;\n    if (g[v].size() == 1 && p != -1){\n        if (a[v] > 0){\n            dp1[v] = 0;\n            dp2[v][0] = a[v];\n        } else{\n            dp2[v][0] = a[v];\n        }\n    } else{\n        for (int i = 0; i < sz[v]; i++){\n        dp2[v][i] += a[v];\n        }\n    };\n}\nmain(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n   // freopen(\"input.txt\", \"r\", stdin);\n    int n;\n    cin >> n;\n    for (int i = 0; i <= n; i++){\n        dp1[i] = 1e15;\n        for (int j = 0; j <= n; j++){\n            dp2[i][j] = 1e15;\n        }\n    }\n    for (int i = 1; i <= n; i++){\n        cin >> a[i];\n    }\n    for (int i = 1; i < n; i++){\n        int u, v;\n        cin >> u >> v;\n        g[u].pb(v);\n        g[v].pb(u);\n    }\n    dfs(1);\n    int ans = dp1[1];\n    for (int i = 0; i <= n; i++){\n        if (dp2[1][i] < 0) ans = min(ans, i);\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define reps(i,x,n) for(int i=x; i<(n); i++)\n#define rrep(i,n) for(int i=(n)-1; i>=0; i--)\n#define all(X) (X).begin(),(X).end()\n#define X first\n#define Y second\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\ntemplate<class A, size_t N, class T> void Fill(A (&a)[N], const T &v){ fill( (T*)a, (T*)(a+N), v ); }\n\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {os<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"; return os;}\ntemplate<class T,size_t n> ostream& operator<<(ostream &os, const array<T,n> &t) {os<<\"{\"; rep(i,n) {os<<t[i]<<\",\";} os<<\"}\"; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst ll INF = 1e9+7;\n\ntypedef pair<map<ll,ll>, map<ll,ll>> state;\n\n\nll A[5005];\nvector<int> edge[5005];\nmap<pii,state> memo;\nstate dfs(int n, int b){\n        if( memo.count(pii(n, b)) ) return memo[pii(n,b)];\n\n        auto func = [&](pll p, pll q, map<ll,ll> &s, ll check=0){\n                int id = p.X + q.X;\n                if( check && p.Y + check >= 0 ) return;\n                if( !s.count(id) ) s[id] = INF;\n                chmin(s[id], p.Y + q.Y);\n        };\n\n        auto cutting = [&](map<ll,ll> &s){\n                ll mn = INF;\n                vector<ll> keys;\n                for(auto p: s){\n                        if( p.Y >= mn ) keys.push_back(p.X);\n                        chmin(mn, p.Y);\n                }\n                for(auto k: keys) s.erase(k);\n        };\n\n        state ret;\n        ret.X[0] = 0;\n        for(auto t: edge[n]) if(t != b){\n                auto r = dfs(t, n);\n                state sum;\n                for(auto p: r.X) for(auto q: ret.X) func(p, q, sum.X);\n                for(auto p: r.X) for(auto q: ret.Y) func(p, q, sum.Y);\n                for(auto p: r.Y) for(auto q: ret.X) func(p, q, sum.Y);\n                for(auto p: r.Y) for(auto q: ret.Y) func(p, q, sum.Y);\n                cutting(sum.X);\n                cutting(sum.Y);\n                ret = sum;\n        }\n\n        {\n                state sum;\n                for(auto p: ret.X) func(p, pll(0, A[n]), (A[n] >= 0 ? sum.X : sum.Y));\n                for(auto p: ret.Y) func(p, pll(0, A[n]), sum.Y);\n                for(auto p: ret.X) func(p, pll(1, -p.Y), sum.X, (A[n] < 0 ? A[n] : 0));\n                for(auto p: ret.Y) func(p, pll(1, -p.Y), sum.X, A[n]);\n                ret = sum;\n        }\n        cutting(ret.X);\n        cutting(ret.Y);\n\n        //cout << \"dfs \" << n+1 << \":\" << b+1 << endl;\n        //for(auto p: ret.X) cout << p << \",\"; cout << endl;\n        //for(auto p: ret.Y) cout << p << \",\"; cout << endl;\n\n        return memo[pii(n,b)] = ret;\n}\n\nint main(){\n        ios_base::sync_with_stdio(false);\n        ll N, ans=INF;\n\n        cin >> N;\n        rep(i,N) cin >> A[i];\n        rep(i,N-1){\n                int u, v;\n                cin >> u >> v;\n                u--; v--;\n                edge[u].push_back(v);\n                edge[v].push_back(u);\n        }\n\n        auto ret = dfs(0, -1);\n        for(auto p: ret.X) chmin(ans, p.X - (p.Y == 0));\n\n        cout << ans << endl;\n\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//注意点\n//Tは3つの値を持つ構造\n//だがワイルドカードとしても使っている\n#include <bits/stdc++.h>\nusing namespace std;\n//@起動時\nstruct initon {\n    initon() {\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.setf(ios::fixed);\n        cout.precision(16);\n    };\n} __initon;\n\n//@必須構造\nstruct T {\n    int f, s, t;\n    T() { f = -1, s = -1, t = -1; }\n    T(int f, int s, int t) : f(f), s(s), t(t) {}\n    bool operator<(const T &r) const {\n        return f != r.f ? f < r.f : s != r.s ? s < r.s : t < r.t;\n        //return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 大きい順\n    }\n    bool operator>(const T &r) const {\n        return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t;\n        //return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 小さい順\n    }\n    int operator[](int i) {\n        assert(i < 3);\n        return i == 0 ? f : i == 1 ? s : t;\n    }\n};\n\n//@マクロ省略系 型,構造\n\n#define int long long\n#define ll long long\n#define double long double\n#define ull unsigned long long\nusing dou = double;\nusing itn = int;\nusing str = string;\nusing bo= bool;\nusing P = pair<int, int>;\n#define F first\n#define S second\n#define vec vector\n#define con continue\n#define bre break\n#define brk break\n#define is ==\n#define rs resize\n\n//マクロ省略系 コンテナ\nusing vi = vector<int>;\n#define vvi(a, b, c) vec<vi> a(b,vi(c))\nusing vb = vector<bool>;\n#define vvb(a, b, c) vec<vb> a(b,vb(c))\nusing vs = vector<string>;\n#define vvs(a, b, c) vec<vs> a(b,vs(c))\nusing vl = vector<ll>;\n#define vvl(a, b, c) vec<vl> a(b,vl(c))\nusing vd = vector<double>;\n#define vvd(a, b, c) vec<vd> a(b,vd(c))\nusing vc=vector<char>;\n#define vvc(a, b, c) vec<vc> a(b,vc(c))\nusing vp = vector<P>;\n#define vvp(a, b, c) vec<vp> a(b,vp(c))\nusing vt = vector<T>;\n#define vvt(a, b, c) vec<vt> a(b,vt(c))\n#define v3i(a, b, c, d) vector<vector<vi>> a(b, vector<vi>(c, vi(d)))\n#define v3d(a, b, c, d) vector<vector<vd>> a(b, vector<vd>(c, vd(d)))\n#define v3m(a, b, c, d) vector<vector<vm>> a(b, vector<vm>(c, vm(d)))\n#define PQ priority_queue<ll, vector<ll>, greater<ll> >\nusing seti = set<int>;\n#define uset unordered_set\n#define mset multiset\n#define umap unordered_map\n#define mmap multimap\n\n//マクロ 繰り返し\n#define _overloadrep(_1, _2, _3, name, ...) name\n# define _rep(i, n) for(int i = 0; i < n ; i++)\n#define repi(i, m, n) for(int i = m; i < n ; i++)\n#define rep(...) _overloadrep(__VA_ARGS__,repi,_rep,)(__VA_ARGS__)\n#define _rer(i, n) for(int i = n; i >= 0 ; i--)\n#define reri(i, m, n) for(int i = m; i >= n ; i--)\n#define rer(...) _overloadrep(__VA_ARGS__,reri,_rer,)(__VA_ARGS__)\n#define fora(a, b) for(auto&& a : b)\n#define forg(gi, ve) if (ve.size())for (int gi = 0, f = ve[gi].from, t = ve[gi].to, c = ve[gi].cost; gi < ve.size(); gi++,f = ve[gi].from, t = ve[gi].to, c = ve[gi].cost)\n\n//マクロ 定数\n#define k4 10101\n#define k5 101010\n#define k6 1010101\n#define k7 10101010\nconst int inf = (int) 1e9 + 100;\nconst ll linf = (ll) 1e18 + 100;\nconst double eps = 1e-9;\nconst int y4[] = {-1, 1, 0, 0};\nconst int x4[] = {0, 0, -1, 1};\nconst int y8[] = {0, 1, 0, -1, -1, 1, 1, -1};\nconst int x8[] = {1, 0, -1, 0, 1, -1, 1, -1};\n\n//マクロ省略形 関数等\n#define arsz(a) (sizeof(a)/sizeof(a[0]))\n#define sz(a) (a.size())\n#define mp make_pair\n#define pb push_back\n#define pf push_front\n#define eb emplace_back\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\n//@拡張系 こう出来るべきというもの\n\n//埋め込み 存在を意識せずに機能を増やされているもの\n// 境界チェック付きvector\nnamespace std_vector_bounds_checking {\n    using namespace std;\n    template<class T, class A = std::allocator<T>> struct vector : std::vector<T, A> {\n        using std::vector<T, A>::vector;\n        typename std::vector<T>::reference operator[](typename std::vector<T>::size_type n) {\n            return this->at(n);\n        }\n    };\n}\nnamespace std {\n    template<> class hash<std::pair<signed, signed>> {\n    public:\n        size_t operator()(const std::pair<signed, signed> &x) const {\n            return hash<ll>()(((ll) x.first << 32) + x.second);\n        }\n    };\n    template<> class hash<std::pair<ll, ll>> {\n    public:\n        size_t operator()(const std::pair<ll, ll> &x) const {\n            return hash<ll>()(((ll) x.first << 32) + x.second);\n        }\n    };\n}\ntemplate<typename T> istream &operator>>(istream &iss, vector<T> &vec) {\n    for (T &x: vec) iss >> x;\n    return iss;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, vector <T> &vec) {\n    for (int i = 0; i < vec.size(); i++)os << vec[i] << (i + 1 == vec.size() ? \"\" : \" \");\n    return os;\n}\ntemplate<typename V, typename H> void resize(vector<V> &vec, const H head) {  //再帰の終端。 可変長templateの長さが 0 になるとこっちが呼ばれる。\n    vec.resize(head);\n}\ntemplate<typename V, typename H, typename ... T> void resize(vector<V> &vec, const H &head, const T ... tail) {\n    vec.resize(head);\n    for (auto &v: vec) resize(v, tail...);\n}\ntemplate<class T> T pop(set<T> &set) {\n    T res = *set.begin();\n    set.erase(set.find(res));\n    return res;\n}\ntemplate<class T> T pop(mset<T> &set) {\n    T res = *set.begin();\n    set.erase(set.find(res));\n    return res;\n}\ntemplate<class T> T popBack(set<T> &set) {\n    T res = *set.rbegin();\n    set.erase(set.find(res));\n    return res;\n}\ntemplate<class T> T popBack(mset<T> &set) {\n    T res = *set.rbegin();\n    set.erase(set.find(res));\n    return res;\n}\ntemplate<class T> inline void sort(vector<T> &a) { sort(a.begin(), a.end()); };\ntemplate<class T> inline void rsort(vector<T> &a) { sort(a.begin(), a.end(), greater<T>()); };\ntemplate<class T> inline void sort(vector<T> &a, int len) { sort(a.begin(), a.begin() + len); };\ntemplate<class T> inline void rsort(vector<T> &a, int len) { sort(a.begin(), a.begin() + len, greater<T>()); };\ntemplate<class T> inline void sort2(vector<vector<T>> &a) { for (int i = 0, n = a.size(); i < n; i++)sort(a[i]); }\ntemplate<class T> inline void rsort2(vector<vector<T>> &a) { for (int i = 0, n = a.size(); i < n; i++)rsort(a[i]); }\ntemplate<typename A, size_t N, typename T> void fill(A (&a)[N], const T &v) { rep(i, N)a[i] = v; }\ntemplate<typename A, size_t N, size_t O, typename T> void fill(A (&a)[N][O], const T &v) { rep(i, N)rep(j, O)a[i][j] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, typename T> void fill(A (&a)[N][O][P], const T &v) { rep(i, N)rep(j, O)rep(k, P)a[i][j][k] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, typename T> void fill(A (&a)[N][O][P][Q], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)a[i][j][k][l] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, typename T> void fill(A (&a)[N][O][P][Q][R], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)a[i][j][k][l][m] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S, typename T> void fill(A (&a)[N][O][P][Q][R][S], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)rep(n, S)a[i][j][k][l][m][n] = v; }\ntemplate<typename V, typename T> void fill(V &x, const T &val) { x = val; }\ntemplate<typename V, typename T> void fill(vector<V> &vect, const T &val) { for (auto &v: vect) fill(v, val); }\n//@汎用便利関数 入力\ntemplate<typename T = int> T in() {\n    T x;\n    cin >> x;\n    return (x);\n}\nstring sin() { return in<string>(); }\ndouble din() { return in<double>(); }\nll lin() { return in<ll>(); }\n#define na(a, n) rep(i,n) cin >> a[i];\n#define nad(a, n) rep(i,n) cin >> a[i], a[i]--;\n#define na3(a, b, c, n) rep(i, n)cin >> a[i] >> b[i] >> c[i];\n#define add2(a, b, n) rep(i, n)a.pb(in()),b.pb(in());\n#define add2d(a, b, n) rep(i, n)a.pb(in()-1),b.pb(in()-1);\n#define add3(a, b, c, n) rep(i, n)a.pb(in()),b.pb(in()),c.pb(in());\n#define add3d(a, b, c, n) rep(i, n)a.pb(in()-1),b.pb(in()-1),c.pb(in());\n#define na2(a, b, n) rep(i, n)cin >> a[i] >> b[i];\n#define nt(a, h, w) rep(hi,h)rep(wi,w) cin >> a[hi][wi];\n#define ntd(a, h, w) rep(hi,h)rep(wi,w) cin >> a[hi][wi], a[hi][wi]--;\n#define ntp(a, h, w) fill(a,'#');rep(hi,1,h+1)rep(wi,1,w+1) cin >> a[hi][wi];\n#define addn(a, n) a.resize(n);na(a,n);\n#define addnd(a, n) a.resize(n);na(a,n);rep(i,n)a[i]--;\n\n\ntemplate<class T> inline void fin(T s) { cout << s << endl, exit(0); }\n\ntemplate<class T> struct edge {\n    int from, to;\n    T cost;\n    int id;\n    int type;\n    edge(int f, int t, T c = 1, int id = -1, int ty = -1) : from(f), to(t), cost(c), id(id), type(ty) {}\n    bool operator<(const edge &b) const { return cost < b.cost; }\n    bool operator>(const edge &b) const { return cost > b.cost; }\n};\n\ntemplate<typename T> class graph {\nprotected:\n    vector<bool> _used;\npublic :\n    vector<vector<edge<T>>> g;\n    vector<edge<T>> edges;\n    int n, root = -1;\n    graph(int n) : n(n) { g.resize(n), _used.resize(n); }\n    void clear() { g.clear(), edges.clear(); }\n    void resize(int n) {\n        this->n = n;\n        g.resize(n);\n        _used.resize(n);\n    }\n    int size() { return g.size(); }\n    bool isleaf(int v) {\n        assert(root != -1);\n        return g[v].size() == 1 && g[v][0].from != root;\n    }\n    vector<edge<T> > &operator[](int i) { return g[i]; }\n    virtual void add(int from, int to, T cost, int ty) = 0;\n    virtual bool used(edge<T> &e) = 0;\n    virtual bool used(int id) = 0;\n    virtual void del(edge<T> &e) = 0;\n    virtual void del(int id) = 0;\n};\n\ntemplate<class T=int> class undigraph : public graph<T> {\npublic:\n    using graph<T>::g;\n    using graph<T>::n;\n    using graph<T>::edges;\n    using graph<T>::_used;\n    undigraph(int n) : graph<T>(n) {\n    }\n    void add(int f, int t, T cost = 1, int ty = -1) {\n        int id = edges.size();\n        g[f].emplace_back(f, t, cost, id, ty);\n        g[t].emplace_back(t, f, cost, id + 1, ty);\n        edges.emplace_back(f, t, cost, id, ty);\n        edges.emplace_back(t, f, cost, id + 1, ty);\n    }\n    void add(edge<T> &e) {\n        int f = e.from, t = e.to, ty = e.type;\n        T cost = e.cost;\n        add(f, t, cost, ty);\n    }\n    bool used(edge<T> &e) { return _used[e.id]; }\n    bool used(int id) { return _used[id]; }\n    void del(edge<T> &e) { _used[e.id] = _used[e.id ^ 1] = 1; }\n    void del(int id) { _used[id] = _used[id ^ 1] = 1; }\n};\n\ntemplate<typename T =ll> class digraph : public graph<T> {\npublic:\n    using graph<T>::g;\n    using graph<T>::n;\n    using graph<T>::edges;\n    using graph<T>::_used;\n\n    digraph(int n) : graph<T>(n) {}\n    void add(int f, int t, T cost = 1, int ty = -1) {\n\n        int id = edges.size();\n        g[f].emplace_back(f, t, cost, ty, id);\n        edges.emplace_back(f, t, cost, ty, id);\n    }\n    bool used(edge<T> &e) { return _used[e.id]; }\n    bool used(int id) { return _used[id]; }\n    void del(edge<T> &e) { _used[e.id] = _used[e.id ^ 1] = 1; }\n    void del(int id) { _used[id] = _used[id ^ 1] = 1; }\n};\n\n\ntemplate<class T, class U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n\nint n, k, m, h, w, x, y, q;\nint cou;\nvi a, b, c;\n//v3i(dp, 5000, 5001, 2);//コンピューターしかないか\nint dp[5000][5001][2],sub[5001][2];\n//vvi(sub, 5050, 2);\nundigraph<> g(0);\nvi es(5050);\n\nvoid ds(int i, int p) {\n    forg(gi, g[i])if (t != p)ds(t, i);\n    int sum = 0;\n    dp[i][0][a[i] < 0] = a[i];\n    forg(gi, g[i]) {\n            if (t == p)continue;\n            rep(ci, sum + 1) {\n                rep(ct, es[t] + 1) {\n                    rep(ki, 2) {\n                        rep(kt, 2) {\n                            //繋ぐ\n                            if (dp[i][ci][ki] < linf && dp[t][ct][kt] < linf)\n                                chmin(sub[ci + ct][ki || kt], dp[i][ci][ki] + dp[t][ct][kt]);\n                            //切る\n                            if (dp[t][ct][kt] < 0 || (!kt && dp[t][ct][kt] != linf))\n                                chmin(sub[ci + ct + 1][ki], dp[i][ci][ki]);\n                        }\n                    }\n                }\n            }\n            sum += es[t] + 1;\n            rep(j, sum + 1)\n                rep(k, 2) {\n                    dp[i][j][k] = sub[j][k];\n                    sub[j][k] = linf;\n\n                }\n        }\n    es[i] = sum;\n}\nsigned main() {\n    cin >> n;\n    addn(a, n);\n    g.resize(n);\n    rep(i, n - 1) {\n        int f, s;\n        cin >> f >> s;\n        --f, --s;\n        g.add(f, s);\n    }\n    fill(dp, linf);\n    fill(sub, linf);\n    ds(0, -1);\n    rep(c, n)rep(k, 2) {\n            if (k) {\n                if (dp[0][c][k] < 0)fin(c);\n            } else if (dp[0][c][k] != linf)fin(c);\n        }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef double D;\ntypedef pair<ll,ll> P;\n#define M 1000000007\n#define F first\n#define S second\n#define PB push_back\n#define INF 100000000000000000\nll n,dp[5005][5005][2],a[5005],sz[5005];\nvector<ll>g[5005];\nvoid dfs(int v,int p){\n    sz[v]=1;\n    dp[v][0][0]=a[v];\n    if(a[v]>0)dp[v][0][1]=a[v];\n    for(int i=0;i<g[v].size();i++){\n        int u=g[v][i];\n        if(u==p)continue;\n        dfs(u,v);\n        ll r[5005][2];\n        for(int j=0;j<=sz[u]+sz[v]+1;j++)r[j][0]=INF,r[j][1]=INF;\n        for(int j=0;j<=sz[v];j++){\n            for(int k=0;k<=sz[u];k++){\n                if(dp[u][k][0]<0||dp[u][k][1]!=INF){\n                    r[j+k+1][0]=min(r[j+k+1][0],dp[v][j][0]);\n                    r[j+k+1][1]=min(r[j+k+1][1],dp[v][j][1]);\n                }  \n                r[j+k][0]=min(r[j+k][0],dp[v][j][0]+min(dp[u][k][0],dp[u][k][1]));\n                r[j+k][1]=min(r[j+k][1],dp[v][j][1]+dp[u][k][1]);\n            }\n        }\n        sz[v]+=sz[u];\n        for(int j=0;j<=sz[v];j++)dp[v][j][0]=r[j][0],dp[v][j][1]=r[j][1];\n    }\n}\nint main(void){\n    scanf(\"%lld\",&n);\n    for(int i=0;i<n;i++)for(int j=0;j<n;j++)dp[i][j][0]=INF,dp[i][j][1]=INF;\n    for(int i=0;i<n;i++)scanf(\"%lld\",a+i);\n    for(int i=0;i<n-1;i++){\n        ll x,y;\n        scanf(\"%lld%lld\",&x,&y);\n        g[--x].PB(--y);\n        g[y].PB(x);\n    }\n    dfs(0,-1);\n    for(int i=0;i<n;i++){\n        if(dp[0][i][0]<0||dp[0][i][1]!=INF){\n            printf(\"%d\\n\",i);\n            return 0;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n#include <array>\n# include <cassert>\n#include <cctype>\n#include <climits>\n#include <numeric>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <tuple>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n# include <chrono>\n# include <random>\n# include <limits.h>\n# include <unordered_map>\n# include <unordered_set>\n# include <deque>\n# include <cstdio>\n# include <cstring>\n#include <stdio.h>\n#include<time.h>\n#include <stdlib.h>\n#include <cstdint>\n#include <cfenv>\n#include<fstream>\n//#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nlong long MOD = 1000000000 + 7;//1000000000 + 7 998244353 924844033 1000000000 + 9;\nconstexpr long long INF = 1LL << 60;//numeric_limits<LL>::max();\nconst double PI = acos(-1);\n#define fir first\n#define sec second\n#define thi third\n#define debug(x) cerr<<#x<<\": \"<<x<<'\\n'\ntypedef pair<LL, LL> Pll;\ntypedef pair<double, double> Dll;\ntypedef pair<LL, pair<LL, LL>> Ppll;\ntypedef pair<LL, pair<LL, bitset<100001>>> Pbll;\ntypedef pair<LL, pair<LL, vector<LL>>> Pvll;\ntypedef pair<LL, LL> Vec2;\nstruct Tll { LL first, second, third; };\nstruct Fll { LL first, second, third, fourth; };\ntypedef pair<LL, Tll> Ptll;\n#define rep(i,rept) for(LL i=0;i<rept;i++)\n#define Rrep(i,mf) for(LL i=mf-1;i>=0;i--)\nvoid YN(bool f) {\n\tif (f)\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n}\nvoid yn(bool f) {\n\tif (f)\n\t\tcout << \"Yes\" << endl;\n\telse\n\t\tcout << \"No\" << endl;\n}\nstruct Edge { LL to, cost; };\nstruct edge {\n\tLL from, to, cost;\n};\nvector<vector<LL>>g;\nvector<edge>ed;\nvector<Pll>pv;\nset<LL>st;\nmap<Pll, LL>ma;\nint di[4][2] = { { 0,1 },{ 1,0 },{ 0,-1 },{ -1,0 } };\nstring str, ss;\nbool f;\nLL n, m, s, t, h, w, a[6010],sub[6010];\nLL dp1[6010][6010], dp2[6010][6010], to1[6010], to2[6010];\n//dp1[i][j]:頂点i,j回切ったときのiに含まれる木の合計の最小(正のみ)\n//dp2[i][j]:頂点i,j回切ったときのiに含まれる木の合計の最小(正負ともに)\n//二乗の木dp\nvoid dfs(int cur, int par) {\n\tsub[cur] = 1;\n\trep(i, 6000)dp1[cur][i] = INF, dp2[cur][i] = INF;\n\tif (a[cur] > 0)\n\t\tdp1[cur][0] = a[cur];\n\telse\n\t\tdp2[cur][0] = a[cur];\n\trep(i, g[cur].size()) {\n\t\tLL v = g[cur][i];\n\t\tif (v == par)continue;\n\t\tdfs(v, cur);\n\t\t\n\t\trep(i, 6000)to1[i] = INF, to2[i] = INF;\n\t\tfor (int i = 0; i < sub[cur]; i++) {\n\t\t\tfor (int j = 0; j < sub[v]; j++) {\n\t\t\t\t//子が切れるとき\n\t\t\t\tif (dp2[v][j] < 0 || dp1[v][j] < INF) {\n\t\t\t\t\tto1[i + j + 1] = min(to1[i + j + 1], dp1[cur][i]);\n\t\t\t\t\tto2[i + j + 1] = min(to2[i + j + 1], dp2[cur][i]);\n\t\t\t\t}\n\n\t\t\t\tto1[i + j] = min(to1[i + j], dp1[cur][i] + dp1[v][j]);\n\t\t\t\tto2[i + j] = min({ to2[i + j], dp1[cur][i] + dp1[v][j] ,\n\t\t\t\t\tdp2[cur][i] + dp1[v][j] ,dp1[cur][i] + dp2[v][j],dp2[cur][i] + dp2[v][j] });\n\t\t\t}\n\t\t}\n\t\trep(i, 6000)dp1[cur][i] = to1[i], dp2[cur][i] = to2[i];\n\t\tsub[cur] += sub[v];\n\t}\n}\nint main() {\n\tcin >> n;\n\trep(i, n) {\n\t\tcin >> a[i];\n\t}\n\tg.resize(n);\n\trep(i, n - 1) {\n\t\tLL x, y;\n\t\tcin >> x >> y;\n\t\tx--, y--;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\tdfs(0, -1);\n\trep(i, n+1) {\n\t\tif (dp1[0][i] < INF) {\n\t\t\tcout << i << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif (dp2[0][i] < 0) {\n\t\t\tcout << i << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long               ll;\nconst int mod = 1e9+7;\n#ifndef M_PI\nconst double M_PI = acos(-1.0);\n#endif\n\nstruct vert{\n  int a;\n  vector<vert *> con;\n  int min_nc = 9999;\n  vector<ll> best;\n  void dfs(vert* par){\n    if(a > 0)\n      min_nc = 0;\n    best.push_back(a);\n    for(vert *nxt : con){\n      if(nxt != par){\n        nxt->dfs(this);\n        if(a > 0){\n          int add = nxt->min_nc;\n          for(int i=0; i<nxt->best.size(); ++i){\n            if(nxt->best[i] < 0){\n              add = min(add, i+1);\n              break;\n            }\n          }\n          min_nc += add;\n        }\n        vector<ll> tmp(best.size()+nxt->best.size()-1, LLONG_MAX);\n        if(nxt->min_nc < 9999){\n          for(int i=0; i<best.size(); ++i){\n            while(i+nxt->min_nc+1 >= tmp.size())\n              tmp.push_back(tmp.back());\n            tmp[i+nxt->min_nc+1] = best[i];\n          }\n        }\n        for(int i=0; i<best.size(); ++i){\n          for(int j=0; j<nxt->best.size(); ++j){\n            tmp[i+j] = min(tmp[i+j], best[i]+nxt->best[j]);\n          }\n        }\n        best = tmp;\n      }\n    }\n  }\n};\n\nint main(){\n  int n;\n  cin>>n;\n  vector<vert> graph(n+1);\n  for(int i=1; i<=n; ++i){\n    scanf(\"%d\", &graph[i].a);\n  }\n  for(int i=1; i<n; ++i){\n    int u, v;\n    scanf(\"%d %d\", &u, &v);\n    graph[u].con.push_back(&graph[v]);\n    graph[v].con.push_back(&graph[u]);\n  }\n  graph[1].dfs(0);\n  int res = graph[1].min_nc;\n  for(int i=0; i<graph[1].best.size(); ++i){\n    if(graph[1].best[i] < 0){\n      res = min(res, i);\n      break;\n    }\n  }\n  cout<<res<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <vector>\nusing namespace std;\nusing ll = long long;\n#define fst first\n#define snd second\n\n/* clang-format off */\ntemplate <class T, size_t D> struct _vec { using type = vector<typename _vec<T, D - 1>::type>; };\ntemplate <class T> struct _vec<T, 0> { using type = T; };\ntemplate <class T, size_t D> using vec = typename _vec<T, D>::type;\ntemplate <class T> vector<T> make_v(size_t size, const T& init) { return vector<T>(size, init); }\ntemplate <class... Ts> auto make_v(size_t size, Ts... rest) { return vector<decltype(make_v(rest...))>(size, make_v(rest...)); }\n/* clang-format on */\n\nconst ll INF = 1ll << 60;\n\nint N;\nll A[6000];\nvector<int> G[6000];\n\nint best[6000];\nvector<ll> dp1[6000];\nint dp2[6000];\n\nvoid dfs(int v, int p) {\n  vector<ll>& dp = dp1[v];\n  dp.resize(1, 0ll);\n  for (int u : G[v]) {\n    if (u == p) continue;\n    dfs(u, v);\n    auto& ch = dp1[u];\n    vector<ll> ndp(dp.size() + ch.size() - 1, INF);\n    for (int i = 0; i < dp.size(); i++) {\n      for (int j = 0; j < ch.size(); j++) {\n        ndp[i + j] = min(ndp[i + j], dp[i] + ch[j]);\n      }\n    }\n    dp.swap(ndp);\n  }\n  for (ll& x : dp) x += A[v];\n  dp.resize(dp.size() + 1, INF);\n  for (int i = 0; i + 1 < dp.size(); i++) {\n    if (dp[i] < 0) {\n      dp[i + 1] = min(dp[i + 1], 0ll);\n    }\n  }\n  best[v] = dp.size() - 2;\n  for (int i = 0; i < dp.size(); i++) {\n    if (dp[i] < 0) {\n      best[v] = i;\n      break;\n    }\n  }\n  if (A[v] < 0) {\n    dp2[v] = best[v] + 1;\n  } else {\n    dp2[v] = 0;\n    for (int u : G[v]) {\n      if (u == p) continue;\n      dp2[v] += dp2[u];\n    }\n    dp[dp2[v] + 1] = min(dp[dp2[v] + 1], 0ll);\n    best[v] = min(best[v], dp2[v]);\n  }\n}\n\nint main() {\n  while (cin >> N) {\n    for (int i = 0; i < N; i++) cin >> A[i];\n    for (int i = 0; i < N; i++) {\n      G[i].clear();\n      dp1[i].clear();\n    }\n    for (int i = 0; i < N - 1; i++) {\n      int x, y;\n      cin >> x >> y;\n      --x;\n      --y;\n      G[x].push_back(y);\n      G[y].push_back(x);\n    }\n    dfs(0, -1);\n    cout << best[0] << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 100000000000000;\n\nint n;\nvector<ll> a(5000);\nvector<vector<ll> > adj(5000, vector<ll>());\nvector<vector<vector<ll> > > dp(5000, vector<vector<ll> >(5000, vector<ll>(2, INF)));\nvector<int> edges(5000, 0);\n\nvoid chmin(ll& before, ll after) {\n\tif (before > after) before = after;\n\treturn;\n}\n\nint dfs_pre(int x, int p) {\n\tif (x != 0 && adj[x].size() == 1) return 0;\n\tfor (auto v : adj[x]) {\n\t\tif (v == p) continue;\n\t\telse edges[x] += dfs_pre(v, x) + 1;\n\t}\n\treturn edges[x];\n}\n\nvoid dfs(int x, int p) {\n\tfor (auto v : adj[x]) {\n\t\tif (v != p) dfs(v, x);\n\t}\n\n\tvector<vector<vector<ll> > > sub(n, vector<vector<ll> >(n, vector<ll>(2, INF)));\n\tsub[0][0][1] = a[x];\n\tif (a[x] > 0) sub[0][0][0] = a[x];\n\tint i = 0;\n\tint e_cnt = 0;\n\n\tfor (auto v : adj[x]) {\n\t\tif (v == p) continue;\n\t\tfor (int j1 = 0; j1 < e_cnt+1; ++j1)\n\t\t{\n\t\t\tfor (int j2 = 0; j2 < edges[v]+1; ++j2)\n\t\t\t{\n\t\t\t\tchmin(sub[i+1][j1+j2][1], sub[i][j1][0] + dp[v][j2][1]);\n\t\t\t\tchmin(sub[i+1][j1+j2][1], sub[i][j1][1] + dp[v][j2][0]);\n\t\t\t\tchmin(sub[i+1][j1+j2][1], sub[i][j1][1] + dp[v][j2][1]);\n\t\t\t\tif (a[x] > 0) chmin(sub[i+1][j1+j2][0], sub[i][j1][0] + dp[v][j2][0]);\n\n\t\t\t\tif (dp[v][j2][0] < INF/2 || dp[v][j2][1] < 0) {\n\t\t\t\t\tchmin(sub[i+1][j1+j2+1][1], sub[i][j1][1]);\n\t\t\t\t\tif (a[x] > 0) chmin(sub[i+1][j1+j2+1][0], sub[i][j1][0]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\te_cnt += edges[v] + 1;\n\t\ti++;\n\t}\n\tfor (int j = 0; j < edges[x]+1; ++j)\n\t{\n\t\tdp[x][j][0] = sub[i][j][0];\n\t\tdp[x][j][1] = sub[i][j][1];\n\t}\n\n\treturn;\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i) cin >> a[i];\n\tfor (int i = 0; i < n-1; ++i)\n\t{\n\t\tint u, v; cin >> u >> v;\n\t\tadj[u-1].push_back(v-1);\n\t\tadj[v-1].push_back(u-1);\n\t}\n\n\tdfs_pre(0, -1);\n\n\tdfs(0, -1);\n\n\tint ans;\n\tfor (int j = 0; j < n; ++j)\n\t{\n\t\tif (dp[0][j][0] < INF/2 || dp[0][j][1] < 0) {\n\t\t\tans = j;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <string>\n#include <vector>\n#define llint long long\n#define inf 1e18\n\nusing namespace std;\n\nllint n;\nllint a[5005];\nvector<llint> G[5005];\nllint sum[5005];\nllint dp[5005][5005][2];\nllint dp2[5005][5005][2];\n\nllint dfs(llint v, llint p)\n{\n\tsum[v] = 1;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(G[v][i] == p) continue;\n\t\tsum[v] += dfs(G[v][i], v);\n\t}\n\t\n\tint m = G[v].size();\n\tfor(int i = 0; i <= m; i++){\n\t\tfor(int j = 0; j <= sum[v]; j++){\n\t\t\tfor(int k = 0; k < 2; k++){\n\t\t\t\tdp2[i][j][k] = inf;\n\t\t\t}\n\t\t}\n\t}\n\tif(a[v] > 0) dp2[0][0][0] = a[v];\n\telse dp2[0][0][1] = a[v];\n\t\n\tllint psum = 1;\n\tfor(int i = 0; i < m; i++){\n\t\tllint u = G[v][i];\n\t\tif(u == p){\n\t\t\tfor(int j = 0; j <= psum; j++){\n\t\t\t\tfor(int k = 0; k < 2; k++){\n\t\t\t\t\tdp2[i+1][j][k] = dp2[i][j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int j = 0; j <= psum; j++){\n\t\t\tfor(int k = 0; k < 2; k++){\n\t\t\t\tfor(int l = 0; l <= sum[u]; l++){\n\t\t\t\t\tfor(int s = 0; s < 2; s++){\n\t\t\t\t\t\tdp2[i+1][j+l][min(1,k+s)] = min(dp2[i+1][j+l][min(1,k+s)], dp2[i][j][k] + dp[u][l][s]);\n\t\t\t\t\t\tif(j+l+1 <= psum+sum[u]){\n\t\t\t\t\t\t\tif((s == 0 && dp[u][l][s] < inf/2) || (s == 1 && dp[u][l][s] < 0)){\n\t\t\t\t\t\t\t\tdp2[i+1][j+l+1][k] = min(dp2[i+1][j+l+1][k], dp2[i][j][k]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpsum += sum[u];\n\t}\n\tfor(int j = 0; j <= psum; j++){\n\t\tfor(int k = 0; k < 2; k++){\n\t\t\tdp[v][j][k] = dp2[m][j][k];\n\t\t}\n\t}\n\treturn sum[v];\n}\n\nint main(void)\n{\n\tcin >> n;\n\tfor(int i = 1; i <= n; i++) cin >> a[i];\n\tllint u, v;\n\tfor(int i = 1; i <= n-1; i++){\n\t\tcin >> u >> v;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tdfs(1, -1);\n\t\n\tllint ans = inf;\n\tfor(llint i = 0; i <= n-1; i++){\n\t\tif(dp[1][i][0] < inf/2) ans = min(ans, i);\n\t\tif(dp[1][i][1] < 0) ans = min(ans, i);\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEB\n#include<bits/stdc++.h>\n#define REP(i,m) for(int i=0;i<(m);++i)\n#define REPN(i,m,in) for(int i=(in);i<(m);++i)\n#define ALL(t) (t).begin(),(t).end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n\nusing namespace std;\n\n\n#ifdef DEB\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define prl cerr<<\"called:\"<< __LINE__<<endl\n#define dumpR(x) cerr<<\"\\x1b[31m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpY(x) cerr<<\"\\x1b[33m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpG(x) cerr<<\"\\x1b[32m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\ntemplate<class T> void debug(T a,T b){ for(;a!=b;++a) cerr<<*a<<' ';cerr<<endl;}\n#else\n#define dump(x) ;\n#define dumpR(x) ;\n#define dumpY(x) ;\n#define dumpG(x) ;\n#define prl ;\ntemplate<class T> void debug(T a,T b){ ;}\n#endif\n\ntemplate<class T> void chmin(T& a,const T& b) { if(a>b) a=b; }\ntemplate<class T> void chmax(T& a,const T& b) { if(a<b) a=b; }\n\ntypedef long long int lint;\ntypedef pair<int,int> pi;\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fr<<','<<a.sc<<')';\n    return out;\n  }\n}\n\nconst lint INF=1e18;\nconst lint INF2=INF/2;\n\nint n;\nlint w[5005];\nvector<int> g[5005];\nlint dp[5005][5005][2];//[1]: contains server\nvoid doit(lint ar1[5005][2],lint ar2[5005][2],int& n,int m){\n  lint tmp[5005][2];\n  REP(i,n+m+1) REP(t,2) tmp[i][t]=INF;\n  REP(i,n+1) REP(j,m+1) REP(t,2) REP(s,2){\n    chmin(tmp[i+j][t|s],ar1[i][t]+ar2[j][s]);\n  }\n  REP(i,n+m+1) REP(t,2) ar1[i][t]=tmp[i][t];\n  n+=m;\n}\nint dfs(int v,int p){\n  int size=1;\n  \n  if(w[v]>0){\n    dp[v][0][0]=w[v];\n  }\n  else{\n    dp[v][0][1]=w[v];\n  }\n  \n  for(auto to:g[v]){\n    if(to==p) continue;\n    int s=dfs(to,v);\n    doit(dp[v],dp[to],size,s);\n  }\n  for(int i=size;i>=0;--i) REP(t,2) if((t==0 && dp[v][i][t]<INF2)|| (t==1 && dp[v][i][t]<0)){\n    chmin(dp[v][i+1][0],0ll);\n  }\n\n  return size;\n}\nint main(){\n  cin>>n;\n  REP(i,n) cin>>w[i];\n  REP(i,n-1){\n    int a,b;cin>>a>>b;--a;--b;\n    g[a].pb(b);g[b].pb(a);\n  }\n  REP(i,n) REP(j,n+1) REP(t,2) dp[i][j][t]=INF;\n  dfs(0,-1);\n  int res=-1;\n  REP(i,n) REP(t,2) if((t==0 && dp[0][i][t]<INF2) || (t==1 && dp[0][i][t]<0)){\n    res=i;\n    goto exi;\n  }\nexi:;\n  cout<<res<<endl;\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nconstexpr ll inf = 1e18;\n\nll dp[5001][5001][2];\nll ndp[5001][2];\n\nint main() {\n    for(int i = 0; i < 5001; ++i) {\n        for(int j = 0; j < 5001; ++j) {\n            for(int k = 0; k < 2; ++k) {\n                dp[i][j][k] = inf;\n            }\n        }\n    }\n\n    int n; cin >> n;\n    vector<int> a(n);\n    for(int i = 0; i < n; ++i) {\n        cin >> a[i];\n    }\n    vector<vector<int>> g(n);\n    for(int i = 0; i < n - 1; ++i) {\n        int u, v; cin >> u >> v;\n        g[u - 1].push_back(v - 1);\n        g[v - 1].push_back(u - 1);\n    }\n\n    // 1 => including computer\n    vector<int> sz(n);\n    function<void(int, int)> solve = [&] (int v, int p) {\n        sz[v] = 1;\n        for(auto to : g[v]) {\n            if(to == p) continue;\n            solve(to, v);\n            sz[v] += sz[to];\n        }\n        dp[v][0][a[v] < 0] = a[v];\n        int cur_sz = 1;\n        for(auto to : g[v]) {\n            if(to == p) continue;\n            for(int i = 0; i <= n; ++i) {\n                for(int j = 0; j < 2; ++j) {\n                    ndp[i][j] = inf;\n                }\n            }\n            for(int i = 0; i <= cur_sz - 1; ++i) {\n                for(int c1 = 0; c1 < 2; ++c1) {\n                if(dp[v][i][c1] == inf) continue;\n                    for(int j = 0; j <= sz[to] - 1; ++j) {\n                        for(int c2 = 0; c2 < 2; ++c2) {\n                            if(dp[to][j][c2] == inf) continue;\n                            // connect\n                            if(i + j == 0) {\n                                ndp[i + j][max(c1, c2)] = dp[v][i][c1] + dp[to][j][c2];\n                            } else {\n                                ndp[i + j][max(c1, c2)] = min(ndp[i + j][max(c1, c2)], dp[v][i][c1] + dp[to][j][c2]);\n                            }\n                            // cut\n                            if(c2 == 0 || dp[to][j][c2] < 0) {\n                                ndp[i + j + 1][c1] = min(ndp[i + j + 1][c1], dp[v][i][c1]);\n                            }\n                        }\n                    }\n                }\n            }\n            memcpy(dp[v], ndp, sizeof(ndp));\n            cur_sz += sz[to];\n        }\n    };\n    solve(0, -1);\n\n    int ans = n;\n    for(int i = 0; i < n; ++i) {\n        if(dp[0][i][0] != inf || dp[0][i][1] < 0) {\n            ans = i;\n            break;\n        }\n    }\n\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n//#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　  |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\n\n\n\n\nint N, A[5010];\nvector<int> E[5010];\n//---------------------------------------------------------------------------------------------------\nmap<int, pair<ll, int>> marge(map<int, pair<ll, int>>& root, map<int, pair<ll, int>>& b) {\n    map<int, pair<ll, int>> res;\n    fore(rootp, root) fore(bp, b) {\n        // くっつける\n        if (!res.count(rootp.first + bp.first)) res[rootp.first + bp.first] = { infl, 0 };\n        chmin(res[rootp.first + bp.first].first, rootp.second.first + bp.second.first);\n        if (rootp.second.second and bp.second.second) res[rootp.first + bp.first].second = 1;\n\n        // くっつけない\n        if (!res.count(rootp.first + bp.first + 1)) res[rootp.first + bp.first + 1] = { infl, 0 };\n        if(bp.second.first < 0 or bp.second.second) chmin(res[rootp.first + bp.first + 1].first, rootp.second.first);\n        if ((bp.second.first < 0 or bp.second.second) and rootp.second.second) res[rootp.first + bp.first + 1].second = 1;\n    }\n    return res;\n}\n//---------------------------------------------------------------------------------------------------\nmap<int, pair<ll, int>> dfs(int cu, int pa = -1) {\n    map<int, pair<ll, int>> res;\n    res[0] = { A[cu], 0 < A[cu] };\n    fore(to, E[cu]) if (to != pa) {\n        auto nxt = dfs(to, cu);\n        res = marge(res, nxt);\n    }\n    /*printf(\"dp for %d\\n\", cu);\n    fore(p, res) {\n        printf(\"dp[%d] = %lld,%d\\n\", p.first, p.second.first, p.second.second);\n    }*/\n    return res;\n}\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> N;\n    rep(i, 0, N) cin >> A[i];\n    rep(i, 0, N - 1) {\n        int a, b; cin >> a >> b;\n        a--; b--;\n        E[a].push_back(b);\n        E[b].push_back(a);\n    }\n\n    auto dp = dfs(0);\n    int ans = inf;\n    fore(p, dp) {\n        if (p.second.first < 0 or p.second.second == 1) chmin(ans, p.first);\n        //printf(\"dp[%d] = %lld,%d\\n\", p.first, p.second.first, p.second.second);\n    }\n    cout << ans << endl;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nconstexpr ll inf = 1e18;\n\nll dp[5001][5001][2];\nll ndp[5001][2];\n\nint main() {\n    for(int i = 0; i < 5001; ++i) {\n        for(int j = 0; j < 5001; ++j) {\n            for(int k = 0; k < 2; ++k) {\n                dp[i][j][k] = inf;\n            }\n        }\n    }\n\n    int n; cin >> n;\n    vector<int> a(n);\n    for(int i = 0; i < n; ++i) {\n        cin >> a[i];\n    }\n    vector<vector<int>> g(n);\n    for(int i = 0; i < n - 1; ++i) {\n        int u, v; cin >> u >> v;\n        g[u - 1].push_back(v - 1);\n        g[v - 1].push_back(u - 1);\n    }\n\n    // 1 => including computer\n    vector<int> sz(n);\n    function<void(int, int)> solve = [&] (int v, int p) {\n        sz[v] = 1;\n        for(auto to : g[v]) {\n            if(to == p) continue;\n            solve(to, v);\n            sz[v] += sz[to];\n        }\n        dp[v][0][a[v] < 0] = a[v];\n        int cur_sz = 1;\n        for(auto to : g[v]) {\n            if(to == p) continue;\n            for(int i = 0; i <= n; ++i) {\n                for(int j = 0; j < 2; ++j) {\n                    ndp[i][j] = inf;\n                }\n            }\n            for(int i = 0; i <= cur_sz - 1; ++i) {\n                for(int c1 = 0; c1 < 2; ++c1) {\n                if(dp[v][i][c1] == inf) continue;\n                    for(int j = 0; j <= sz[to] - 1; ++j) {\n                        for(int c2 = 0; c2 < 2; ++c2) {\n                            if(dp[to][j][c2] == inf) continue;\n                            // connect\n                            ndp[i + j][max(c1, c2)] = min(ndp[i + j][max(c1, c2)], dp[v][i][c1] + dp[to][j][c2]);\n                            // cut\n                            if(c2 == 0 || dp[to][j][c2] < 0) {\n                                ndp[i + j + 1][c1] = min(ndp[i + j + 1][c1], dp[v][i][c1]);\n                            }\n                        }\n                    }\n                }\n            }\n            memcpy(dp[v], ndp, sizeof(ndp));\n            cur_sz += sz[to];\n        }\n    };\n    solve(0, -1);\n\n    int ans = n;\n    for(int i = 0; i < n; ++i) {\n        if(dp[0][i][0] != inf || dp[0][i][1] < 0) {\n            ans = i;\n            break;\n        }\n    }\n\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long dp[5010][5010];\nbool pos[5010][5010];\nint sz[5010];\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n; cin >> n;\n    vector<long long> a(n);\n    for (int i = 0; i < n; i++) cin >> a[i];\n    vector<vector<int>> e(n);\n    for (int i = 1; i < n; i++) {\n        int u, v; cin >> u >> v;\n        u--, v--;\n        e[u].emplace_back(v);\n        e[v].emplace_back(u);\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j <= n; j++) {\n            dp[i][j] = 1e16;\n        }\n    }\n    auto f = [&](auto f, int curr, int prev) -> void {\n        sz[curr] = 1; pos[curr][0] = (a[curr] > 0);\n        dp[curr][0] = a[curr];\n        for (auto &to: e[curr]) {\n            if (to == prev) continue;\n            f(f, to, curr);\n            sz[curr] += sz[to];\n        }\n        for (auto &to: e[curr]) {\n            if (to == prev) continue;\n            for (int i = sz[curr]; i >= 0; i--) {\n                for (int j = 0; j <= sz[to]; j++) {\n                    if (i >= j) {\n                        if (pos[to][j] || dp[to][j] < 0) {\n                            dp[curr][i+1] = min(dp[curr][i+1], dp[curr][i-j]);\n                            pos[curr][i+1] |= pos[curr][i-j];\n                        }\n                        pos[curr][i] |= pos[curr][i-j] & pos[to][j];\n                        if (j == 0) {\n                            dp[curr][i] = dp[curr][i-j] + dp[to][j];\n                            pos[curr][i] = pos[curr][i-j] & pos[to][j];\n                        } else {\n                            dp[curr][i] = min(dp[curr][i], dp[curr][i-j] + dp[to][j]);\n                            pos[curr][i] |= pos[curr][i-j] & pos[to][j];\n                        }\n                    }\n                }\n            }\n        }\n    };\n    f(f, 0, -1);\n    for (int i = 0; i < n; i++) {\n        if (dp[0][i] < 0 || pos[0][i]) {\n            cout << i << \"\\n\";\n            return 0;\n        }\n    }\n    assert(false);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <queue>\n#define MAX_N 5005\n#define INF 8000000000000\n\nusing namespace std;\ntypedef long long ll;\n\nint N;\nll A[MAX_N];\nvector<int> G[MAX_N];\nll dp[2][MAX_N][MAX_N];//i,v,k 親成分以外が条件を満たす/親成分すべて正　連結成分の数\nll dpn[2][MAX_N];\n\nvoid show(){\n    //debug\n    for(int n=0;n<N;n++){\n        for(int k=0;k<=N;k++){\n            if(dp[0][n][k]==INF){cout<<\"INF \";continue;}\n            cout<<dp[0][n][k]<<\" \";\n        }\n        cout<<endl;\n    }\n    cout<<endl;\n    for(int n=0;n<N;n++){\n        for(int k=0;k<=N;k++){\n            if(dp[1][n][k]==INF){cout<<\"INF \";continue;}\n            cout<<dp[1][n][k]<<\" \";\n        }\n        cout<<endl;\n    }\n    cout<<\"--------------------------------\"<<endl;\n\n}\n\nint dfs(int p,int n){//親ノード、今のノード\n    int count = 0;\n    int K = 1,K_;\n    for(int i = 0;i < G[n].size();i++){\n        int c = G[n][i];\n        if(c==p)continue;\n        count++;\n        K_=K;\n        K += dfs(n,c);\n        if(count==1){\n            for(int k = 1;k <= K;k++){\n                //nをk個目の独立した連結成分にする場合\n                if(dp[0][c][k-1]<0||dp[1][c][k-1]!=INF){\n                    dp[0][n][k]=min(dp[0][n][k],A[n]);\n                    if(A[n]>0)\n                        dp[1][n][k]=min(dp[1][n][k],A[n]);\n                }\n                //cの連結成分につなげる場合\n                if(dp[0][c][k]!=INF)\n                    dp[0][n][k]=min(dp[0][n][k],dp[0][c][k]+A[n]);\n                if(A[n]>0&&dp[1][c][k]!=INF)\n                    dp[1][n][k]=min(dp[1][n][k],dp[1][c][k]+A[n]);\n            }\n            continue;\n        }\n        for(int k = 0;k <= K;k++){\n            dpn[0][k]=INF;\n            dpn[1][k]=INF;\n        }\n        for(int k = 1;k <= K;k++){\n            //cのノードをnに繋げない場合\n            for(int k_ = min(k,K_);k_ > 0;k_--){//k_:n側の連結成分数\n                if(dp[0][c][k-k_]<0||dp[1][c][k-k_]!=INF){//cのノード以下が問題文の条件を満たしていれば、繋がなくても良い。\n                    dpn[0][k] = min(dpn[0][k],dp[0][n][k_]);\n                    dpn[1][k] = min(dpn[1][k],dp[1][n][k_]);\n                }\n            }\n            //cをnの連結成分につなげる場合\n            for(int k_ = min(k,K_);k_ > 0;k_--){//k_:n側の連結成分数\n                if(dp[0][c][k-k_+1]!=INF&&dp[0][n][k_]!=INF){\n                    dpn[0][k]=min(dpn[0][k],dp[0][c][k-k_+1]+dp[0][n][k_]);\n                }\n                if(dp[1][c][k-k_+1]!=INF&&dp[1][n][k_]!=INF){\n                    dpn[1][k]=min(dpn[1][k],dp[1][c][k-k_+1]+dp[1][n][k_]);\n                }\n            }\n        }\n        for(int k = 1;k <= K;k++){\n            dp[0][n][k]=dpn[0][k];\n            dp[1][n][k]=dpn[1][k];\n        }\n    }\n    if(p>=0&&count==0){\n        dp[0][n][1]=A[n];\n        if(A[n]>0){\n            dp[1][n][1]=A[n];\n        }\n    }\n//    cout<<n<<endl;\n//    show();\n    return K;\n}\n\nint main() {\n    cin>>N;\n    for(int i=0;i<N;i++){\n        for(int j=0;j<=N;j++){\n            dp[0][i][j]=INF;\n            dp[1][i][j]=INF;\n        }\n        cin>>A[i];\n    }\n    for(int i=0;i<N-1;i++){\n        int a,b;\n        cin>>a>>b;\n        a--,b--;\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n    dfs(-1,0);\n    int ans;\n    \n    \n    \n    for(int k=1;k<=N;k++){\n        if(dp[0][0][k]<0){\n            cout<<k-1<<endl;\n//            cout<<\"debug 1\"<<endl;\n            return 0;\n        }\n        if(dp[1][0][k]!=INF&&dp[1][0][k]>0){\n            cout<<k-1<<endl;\n//            cout<<\"debug 2:\"<<dp[1][0][k]<<endl;\n            return 0;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target (\"avx2\")\n#pragma GCC optimize (\"unroll-loops\")\n#pragma GCC optimize (\"O3\")\n#include \"bits/stdc++.h\"\n#include <unordered_set>\n#include <unordered_map>\n#include <random>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1'000'000'007LL; /*998'244'353LL;*/\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define rep(i, n) for(int (i)=0; (i)<(n); (i)++)\nconst int dx[4]={ 1,0,-1,0 };\nconst int dy[4]={ 0,1,0,-1 };\n\nint N;\nll A[5000];\nvector<int> E[5000], chi[5000];\n\nvoid dfs(int v, int p){\n    rep(i, E[v].size()){\n        if(E[v][i] == p) continue;\n        dfs(E[v][i], v);\n        chi[v].pb(E[v][i]);\n    }\n}\n\nbool solveB(int, int, int);\n\nunordered_map<int, ll> dp[5000][5000];\nll solve(int v, int n, int e){\n    if(e == chi[v].size()){\n        if(n == 0) return A[v];\n        else return 1e18L;\n    }\n    if(dp[v][n].count(e)) return dp[v][n][e];\n    ll ret = 1e18L;\n    rep(i, n+1){\n        ret = min(ret, solve(chi[v][e], n-i, 0) + solve(v, i, e+1));\n        if(n-i > 0)\n            ret = min(ret, solve(chi[v][e], n-i-1, 0) + solve(v, i, e+1));\n        if(A[chi[v][e]] > 0 && n-i > 0 && solveB(chi[v][e], n-i-1, 0))\n            ret = min(ret, solve(v, i, e+1));\n    }\n    return dp[v][n][e] = ret;\n}\n\nunordered_map<int, bool> dpB[5000][5000];\nbool solveB(int v, int n, int e){\n    if(e == chi[v].size()){\n        if(n == 0) return true;\n        else return false;\n    }\n    if(dpB[v][n].count(e)) return dpB[v][n][e];\n    bool ret = false;\n    rep(i, n+1){\n        if(n-i > 0)\n            ret |= (solve(chi[v][e], n-i-1, 0) < 0) && solveB(v, i, e+1);\n        if(A[chi[v][e]] > 0 && n-i > 0)\n            ret |= solveB(chi[v][e], n-i-1, 0) && solveB(v, i, e+1);\n        if(A[chi[v][e]] > 0)\n            ret |= solveB(chi[v][e], n-i, 0) && solveB(v, i, e+1);\n    }\n    return dpB[v][n][e] = ret;\n}\n\nsigned main(){\n    cin >> N;\n    rep(i, N) cin >> A[i];\n    rep(i, N-1){\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        E[u].pb(v);\n        E[v].pb(u);\n    }\n    dfs(0, -1);\n    \n    for(int i=N; i>=1; i--){\n        if(A[0] > 0){\n            if(solve(0, i-1, 0) >= 0 && solveB(0, i-1, 0) == false){\n                cout << i << endl;\n                exit(0);\n            }\n        }\n        else{\n            if(solve(0, i-1, 0) >= 0){\n                cout << i << endl;\n                exit(0);\n            }\n        }\n    }\n    cout << 0 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\n#include <bitset>\n\nusing namespace std;\nusing lint = long long int;\nlong long int INF = 1001001001001001LL;\nint inf = 1000000007;\nlong long int MOD = 1000000007LL;\ndouble PI = 3.1415926535897932;\n\ntemplate<typename T1,typename T2>inline void chmin(T1 &a,const T2 &b){if(a>b) a=b;}\ntemplate<typename T1,typename T2>inline void chmax(T1 &a,const T2 &b){if(a<b) a=b;}\n\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n\n/* do your best */\n\n// やっと会えたね，二乗の木 DP たん\n// https://drken1215.hatenablog.com/entry/2019/01/13/024000\nvector<lint> a;\nvector<vector<lint>> g;\n\nvector<pair<lint, lint>> merge(const vector<pair<lint, lint>> &dpl, const vector<pair<lint, lint>> &dpr) {\n\n  int n = dpl.size();\n  int m = dpr.size();\n  \n  vector<pair<lint, lint>> dp(n + m, {INF, 0});\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      // 和\n      // マージする\n      chmin(dp[i + j].first, dpl[i].first + dpr[j].first);\n      // r はカットする\n      if (dpr[j].first < 0 or dpr[j].second) {\n        chmin(dp[i + j + 1].first, dpl[i].first);\n      }\n\n      // すべて正にできるか\n      dp[i + j].second |= dpl[i].second & dpr[j].second;\n      // r はカットする\n      if (dpr[j].first < 0 or dpr[j].second) {\n        dp[i + j + 1].second |= dpl[i].second;\n      }\n    }\n  }\n\n  return dp;\n}\n\n// この書き方は半ばテンプレート気味\nvector<pair<lint, lint>> dfs(int cur, int par = -1) {\n\n  vector<pair<lint, lint>> dp(1);\n  dp[0].first = a[cur];\n  dp[0].second = (a[cur] > 0);\n  for (auto nxt : g[cur]) {\n    if (nxt == par) continue;\n    vector<pair<lint, lint>> cdp = dfs(nxt, cur);\n    dp = merge(dp, cdp);\n  }\n\n  return dp;\n}\n\nint main() {\n  \n  int n; cin >> n;\n  a.resize(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n\n  g.resize(n);\n  for (int i = 0; i < n - 1; i++) {\n    int u, v; cin >> u >> v;\n    u--;\n    v--;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n\n  auto dp = dfs(0);\n  int ans = inf;\n  for (int i = 0; i < n; i++) {\n    if (dp[i].first < 0) {\n      ans = min(ans, i);\n    }\n    if (dp[i].second == true) {\n      ans = min(ans, i);\n    }\n  }\n\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define NDEBUG\n#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\nstruct UnionFind{\n  Int n;\n  vector<Int> r,p;\n  UnionFind(){}\n  UnionFind(Int sz):n(sz),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n  Int find(Int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(Int x,Int y){\n    return find(x)==find(y);\n  }\n  void unite(Int x,Int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];\n    p[y]=x;\n  }\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  auto shrink=\n    [&](){\n      Int n;\n      cin>>n;\n      vector<Int> a(n);\n      for(Int i=0;i<n;i++) cin>>a[i];\n      vector<vector<Int> > G(n);\n      for(Int i=1;i<n;i++){\n        Int x,y;\n        cin>>x>>y;\n        x--;y--;\n        G[x].emplace_back(y);\n        G[y].emplace_back(x);\n      }\n      UnionFind uf(n);\n      for(Int v=0;v<n;v++){\n        for(Int u:G[v]){\n          if(a[v]<0&&a[u]<0) uf.unite(u,v);\n          if(a[v]>0&&a[u]>0) uf.unite(u,v);\n        }\n      }\n      \n      vector<Int> vs;\n      for(Int i=0;i<n;i++){\n        if(uf.find(i)!=i) continue;\n        vs.emplace_back(i);\n      }\n      \n      Int m=vs.size();\n      map<Int, Int> rev;\n      for(Int i=0;i<m;i++) rev[vs[i]]=i;\n\n      vector<set<Int> > H(m);\n      vector<Int> na(m,0);\n      for(Int v=0;v<n;v++){\n        na[rev[uf.find(v)]]+=a[v];\n        for(Int u:G[v]){\n          if(uf.same(u,v)) continue;\n          Int x=rev[uf.find(v)],y=rev[uf.find(u)];\n          H[x].emplace(y);\n          H[y].emplace(x);\n        }\n      }\n      \n      vector<vector<Int> > nG(m);\n      for(Int i=0;i<m;i++) nG[i]=vector<Int>(H[i].begin(),H[i].end());\n      return make_tuple(m,na,nG);      \n    };\n  \n  auto graph=shrink();\n  auto n=get<0>(graph);\n  auto a=get<1>(graph);\n  auto G=get<2>(graph);\n  assert((Int)a.size()==n);\n  assert((Int)G.size()==n);\n\n  if(0){\n    cout<<n<<endl;\n    for(Int i=0;i<n;i++) cout<<a[i]<<\" \";\n    cout<<endl;\n    for(Int v=0;v<n;v++){\n      for(Int u:G[v]){\n        cout<<v<<\" \"<<u<<endl;\n      }\n    }\n  }\n  \n  if(n==1){\n    cout<<0<<endl;\n    return 0;\n  }\n\n  const Int INF = 1e17;\n  vector<vector<Int> > dp(n);\n  vector<Int> sum(n,0);\n  \n  function<void(Int, Int)> dfs=\n    [&](Int v,Int par){\n      for(Int u:G[v])\n        if(u!=par) dfs(u,v);\n      \n      dp[v].resize(1);\n      dp[v][0]=a[v];\n      for(Int u:G[v]){\n        if(u==par) continue;\n        const auto &p=dp[v];\n        const auto &q=dp[u];\n        Int x=p.size();\n        Int y=q.size();\n        vector<Int> nx(x+y,INF);\n        for(Int i=0;i<x;i++){\n          for(Int j=0;j<y;j++){\n            chmin(nx[i+j],p[i]+q[j]);\n            if(q[j]<0) chmin(nx[i+j+1],p[i]);\n          }\n        }\n        if(0){\n          {          \n            for(Int i=0;i<x;i++)\n              if(i+sum[u]+1<x+y) chmin(nx[i+sum[u]+1],p[i]);\n          }\n          {\n            Int res=sum[u]+1;\n            for(Int j=0;j<y;j++)\n              if(q[j]<0) chmin(res,j+1);\n            sum[v]+=res;\n          }\n        }\n        swap(dp[v],nx);\n      }\n    };\n\n  Int idx=0;\n  while(a[idx]>0) idx++;\n  assert(idx<n);\n  \n  dfs(idx,-1);\n  Int ans=n;\n  //cout<<n<<\":\"<<dp[idx].size()<<endl;\n  assert(n==(Int)dp[idx].size());\n  for(Int i=0;i<n;i++)\n    if(dp[idx][i]<0) chmin(ans,i);\n  \n  assert(ans<n);  \n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int64 INF = 1LL << 58;\n\nvector< int > g[5000];\nint N, A[5000];\nvector< bool > latte[5000];\nvector< int64 > malta[5000];\n\nvoid chmin(int64 &a, int64 b) { a = min(a, b); }\n\nvoid dfs(int idx, int par) {\n  for(auto &to : g[idx]) {\n    if(to == par) continue;\n    dfs(to, idx);\n  }\n\n  latte[idx].emplace_back(A[idx] > 0);\n  for(auto &to : g[idx]) {\n    if(to == par) continue;\n    if(A[to] > 0) {\n      vector< bool > nxt(latte[idx].size() + latte[to].size());\n      for(int i = 0; i < latte[idx].size(); i++) {\n        for(int j = 0; j < latte[to].size(); j++) {\n          if(latte[idx][i] & latte[to][j]) {\n            nxt[i + j] = true;\n          }\n        }\n        for(int j = 0; j < malta[to].size(); j++) {\n          if(!latte[idx][i] || malta[to][j] >= 0) continue;\n          nxt[i + j + 1] = true;\n        }\n      }\n      latte[idx].swap(nxt);\n    } else {\n      vector< bool > nxt(latte[idx].size() + latte[to].size());\n      for(int i = 0; i < latte[idx].size(); i++) {\n        for(int j = 0; j < malta[to].size(); j++) {\n          if(!latte[idx][i] || malta[to][j] >= 0) continue;\n          nxt[i + j + 1] = true;\n        }\n      }\n      latte[idx].swap(nxt);\n    }\n  }\n\n\n  malta[idx].emplace_back(A[idx]);\n  for(auto &to : g[idx]) {\n    if(to == par) continue;\n    vector< int64 > nxt(malta[idx].size() + malta[to].size(), INF);\n    for(int i = 0; i < malta[idx].size(); i++) {\n      for(int j = 0; j < latte[to].size(); j++) {\n        if(latte[to][j]) chmin(nxt[i + j + 1], malta[idx][i]);\n      }\n      for(int j = 0; j < malta[to].size(); j++) {\n        if(malta[idx][j] == INF) continue;\n        if(malta[to][j] == INF) continue;\n        chmin(nxt[i + j], malta[idx][i] + malta[to][j]);\n      }\n\n      for(int j = 0; j < malta[to].size(); j++) {\n        if(malta[idx][j] == INF) continue;\n        if(malta[to][j] >= 0) continue;\n        chmin(nxt[i + j + 1], malta[idx][i]);\n      }\n\n    }\n    malta[idx].swap(nxt);\n  }\n\n  for(int i = 0; i < malta[idx].size(); i++) {\n    if(malta[idx][i] < 0) latte[idx][i] = true;\n  }\n\n}\n\n\nint main() {\n  cin >> N;\n  for(int i = 0; i < N; i++) cin >> A[i];\n  for(int i = 1; i < N; i++) {\n    int x, y;\n    cin >> x >> y;\n    --x, --y;\n    g[x].emplace_back(y);\n    g[y].emplace_back(x);\n  }\n  dfs(0, -1);\n  for(int i = 0; i < latte[0].size(); i++) {\n    if(latte[0][i]) {\n      cout << i << endl;\n      exit(0);\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;using ll=long long;using uint=unsigned int;using pii=pair<int,int>;using pll=pair<ll,ll>;using ull = unsigned long long;using ld=long double;template<typename T>void _(const char*s,T h){cerr<<s<<\" = \"<<h<<\"\\n\";}template<typename T,typename...Ts>void _(const char*s,T h,Ts...t){int b=0;while(((b+=*s=='(')-=*s==')')!=0||*s!=',')cerr<<*s++;cerr<<\" = \"<<h<<\",\";_(s+1,t...);}// break continue pop_back 998244353\n#define int ll\n#define pii pll\n#define f first\n#define s second\n#define pb emplace_back\n#define forn(i,n) for(int i=0;i<(n);++i)\n#define sz(a)((int)(a).size())\n#define sqr(x) ((x)*(x))\nstruct init{init(){cin.tie(0);iostream::sync_with_stdio(0);cout<<fixed<<setprecision(10);cerr<<fixed<<setprecision(5);}~init(){\n#ifdef LOCAL\n#define dbg(...) _(#__VA_ARGS__,__VA_ARGS__)\ncerr<<\"Time elapsed: \"<<(double)clock()/CLOCKS_PER_SEC<<\"s.\\n\";\n#else\n#define dbg(...) \n#endif\n}}init;template<typename T,typename U>void upx(T&x,U y){if(x<y)x=y;}template<typename T,typename U>void upn(T&x,U y){if(x>y)x=y;}mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());const int D=4,dx[]={+1,0,-1,0},dy[]={0,+1,0,-1};\nconst int N=5001,OO=1e18;\nint dp[N][N],ba[N][N];\nint a[N];\nvector<int> g[N];\nint sz[N],dv[N],du[N],dt[N];\nvoid dfs(int v,int p=0){\n    sz[v]=1;\n    for(int to:g[v]){\n        if(to^p){\n            dfs(to,v);\n            sz[v]+=sz[to];\n        }\n    }\n    // forn(i,sz[v])dp[v][i]=ba[v][i]=OO;\n    {\n        int maxv=0;\n        forn(i,N)dv[i]=OO;\n        dv[0]=0;\n        for(int to:g[v]){\n            if(to^p){\n                int maxto=sz[to];\n                forn(i,maxv+maxto+2)dt[i]=OO;\n                forn(i,maxto+1){\n                    du[i]=dp[to][i];\n                    if(i&&du[i-1]<0)upn(du[i],0);\n                    if(i&&ba[to][i-1])upn(du[i],0);\n                }\n                forn(i,maxv+1){\n                    forn(j,maxto+1){\n                        upn(dt[i+j],dv[i]+du[j]);\n                    }\n                }\n                forn(i,maxv+maxto+2)dv[i]=dt[i];\n                maxv+=maxto;\n            }\n        }\n        forn(i,sz[v])dp[v][i]=dv[i]+a[v];\n    }\n    if(a[v]>0){\n        int maxv=0;\n        forn(i,N)dv[i]=0;\n        dv[0]=1;\n        for(int to:g[v]){\n            if(to^p){\n                int maxto=sz[to];\n                forn(i,maxv+maxto+2)dt[i]=0;\n                forn(i,maxto+1){\n                    du[i]=(i&&ba[to][i-1]);\n                    if(a[to]>0){\n                        du[i]|=ba[to][i];\n                    }\n                }\n                forn(i,maxv+1){\n                    forn(j,maxto+1){\n                        dt[i+j]|=dv[i]&du[j];\n                    }\n                }\n                forn(i,maxv+maxto+2)dv[i]=dt[i];\n                maxv+=maxto;\n            }\n        }\n        forn(i,sz[v])ba[v][i]=dv[i];\n    }else{\n        forn(i,sz[v])if(dp[v][i]<0)ba[v][i]=1;\n    }\n    // dbg(v,a[v]);\n    // forn(i,sz[v])dbg(dp[v][i],ba[v][i]);\n    // dbg(\"=====\");\n}\nint32_t main(){\n    int n;\n    cin>>n;\n    for(int i=1;i<=n;++i)cin>>a[i];\n    forn(i,n-1){\n        int x,y;\n        cin>>x>>y;\n        g[x].pb(y);\n        g[y].pb(x);\n    }\n    dfs(1);\n    int ans=N;\n    forn(i,n){\n        if(ba[1][i]||dp[1][i]<0){\n            ans=i;\n            break;\n        }\n    }\n    cout<<ans<<'\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <unordered_set>\n#include <unordered_map>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <cstdio>\n#include <complex>\n#include <cstdint>\n#include <tuple>\n\n#define M_PI       3.14159265358979323846\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\ninline int readInt() { int x; scanf(\"%d\", &x); return x; }\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SQ(a) ((a)*(a))\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,s,n) for(int i=s;i<(int)n;++i)\n#define REP(i,n) FOR(i,0,n)\n#define MOD 1000000007\n\nconst int N = 5005;\nvector<LL> dp1[N], dp2[N];\nint a[N];\nLL INF = 0x3f3f3f3f3f3f3f3f;\n\n\nvoid dfs(VVI& g, int u, int p = -1) {\n\tdp1[u].push_back(INF);\n\tdp1[u].push_back((a[u] > 0) ? a[u] : INF);\n\tdp2[u].PB(INF);\n\tdp2[u].PB(a[u]);\n\tfor (auto v : g[u]) {\n\t\tif (v == p)continue;\n\t\tdfs(g, v, u);\n\t\tVLL dp1x = VLL(dp1[u].size() + dp1[v].size() - 1, INF);\n\t\tVLL dp2x = VLL(dp1[u].size() + dp1[v].size() - 1, INF);\n\t\tREP(i, dp1[u].size()) {\n\t\t\tif (dp2[u][i]==INF)continue;\n\t\t\tREP(j, dp1[v].size()) {\n\t\t\t\tif (i + j - 1 >= 0) {//統合\n\t\t\t\t\tdp1x[i + j - 1] = min(dp1x[i + j - 1], dp1[u][i] + dp1[v][j]);\n\t\t\t\t\tdp2x[i + j - 1] = min(dp2x[i + j - 1], dp2[u][i] + dp1[v][j]);\n\t\t\t\t\tdp2x[i + j - 1] = min(dp2x[i + j - 1], dp2[u][i] + dp2[v][j]);\n\t\t\t\t}\n\t\t\t\t//分離\n\t\t\t\tif (dp1[v][j] != INF) {\n\t\t\t\t\tdp1x[i + j] = min(dp1x[i + j], dp1[u][i]);\n\t\t\t\t\tdp2x[i + j] = min(dp2x[i + j], dp2[u][i]);\n\t\t\t\t}\n\t\t\t\tif (dp2[v][j] < 0) {\n\t\t\t\t\tdp1x[i + j] = min(dp1x[i + j], dp1[u][i]);\n\t\t\t\t\tdp2x[i + j] = min(dp2x[i + j], dp2[u][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdp1[u] = move(dp1x);\n\t\tdp2[u] = move(dp2x);\n\t}\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tREP(i, n)scanf(\"%d\", &a[i]);\n\tVVI g(n);\n\tREP(i, n - 1) {\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tu--, v--;\n\t\tg[u].PB(v);\n\t\tg[v].PB(u);\n\t}\n\tdfs(g, 0);\n\tfor (int i = 0; dp1[0].size(); i++) {\n\t\tif (dp1[0][i] > 0 && dp1[0][i] < INF) {\n\t\t\tprintf(\"%d\\n\", i-1);\n\t\t\treturn 0;\n\t\t}\n\t\tif (dp2[0][i] < 0) {\n\t\t\tprintf(\"%d\\n\", i-1);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include \"bits/stdc++.h\"\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconst double PI = acos(-1);\ntemplate<class T>constexpr T INF() { return ::std::numeric_limits<T>::max(); }\ntemplate<class T>constexpr T HINF() { return INF<T>() / 2; }\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\ntypedef pair<LL, LL> pii;\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\nint popcnt(unsigned long long n) { int cnt = 0; for (int i = 0; i < 64; i++)if ((n >> i) & 1)cnt++; return cnt; }\nint d_sum(LL n) { int ret = 0; while (n > 0) { ret += n % 10; n /= 10; }return ret; }\nint d_cnt(LL n) { int ret = 0; while (n > 0) { ret++; n /= 10; }return ret; }\nLL gcd(LL a, LL b) { if (b == 0)return a; return gcd(b, a%b); };\nLL lcm(LL a, LL b) { LL g = gcd(a, b); return a / g*b; };\n# define ALL(qpqpq)           (qpqpq).begin(),(qpqpq).end()\n# define UNIQUE(wpwpw)        sort(ALL((wpwpw)));(wpwpw).erase(unique(ALL((wpwpw))),(wpwpw).end())\n# define LOWER(epepe)         transform(ALL((epepe)),(epepe).begin(),TL<char>)\n# define UPPER(rprpr)         transform(ALL((rprpr)),(rprpr).begin(),TU<char>)\n# define FOR(i,tptpt,ypypy)   for(LL i=(tptpt);i<(ypypy);i++)\n# define REP(i,upupu)         FOR(i,0,upupu)\n# define INIT                 std::ios::sync_with_stdio(false);std::cin.tie(0)\n\nint n;\nint a[5050];\nvector<int> g[5050];\nLL dp[5050][5050][2];\nint visited[5050];\nLL dp2[5050][2];\nint u, v;\n\nvoid dfs(int cur, int pre){\n    visited[cur] = 1;\n    REP(i, (int)g[cur].size()){\n        if(g[cur][i] == pre)continue;\n        dfs(g[cur][i], cur);\n        visited[cur] += visited[g[cur][i]];\n    }\n\n    REP(j, 5050)dp2[j][0] = dp2[j][1] = HINF<LL>();\n\n    dp2[0][0] = a[cur];\n    if(a[cur] > 0)dp2[0][1] = a[cur];\n\n    int chcnt = 0;\n    REP(i, (int)g[cur].size()){\n        if(g[cur][i] == pre)continue;\n        for(int j = chcnt;j >= 0;j--){\n            LL tmp0 = dp2[j][0], tmp1 = dp2[j][1];\n            dp2[j][0] = dp2[j][1] = HINF<LL>();\n            for(int k = 0;k < visited[g[cur][i]];k++){\n                dp2[j + k][0] = min(dp2[j + k][0], tmp0 + dp[g[cur][i]][k][0]);\n                if(dp[g[cur][i]][k][0] < 0 || dp[g[cur][i]][k][1] < HINF<LL>())dp2[j + k + 1][0] = min(dp2[j + k + 1][0], tmp0);\n                if(a[cur] > 0){\n                    dp2[j + k][1] = min(dp2[j + k][1], tmp1 + dp[g[cur][i]][k][1]);\n                    if(dp[g[cur][i]][k][0] < 0 || dp[g[cur][i]][k][1] < HINF<LL>())dp2[j + k + 1][1] = min(dp2[j + k + 1][1], tmp1);\n                }\n            }\n        }\n        chcnt += visited[g[cur][i]];\n    }\n    for(int j = 0;j < visited[cur];j++){\n        dp[cur][j][0] = dp2[j][0];\n        dp[cur][j][1] = dp2[j][1];\n    }\n}\n\nint main(){\n    cin >> n;\n    REP(i, n)cin >> a[i];\n    REP(i, n - 1){\n        cin >> u >> v;\n        u--, v--;\n        g[u].emplace_back(v);\n        g[v].emplace_back(u);\n    }\n    REP(i, 5050)REP(j, 5050)REP(k, 2)dp[i][j][k] = HINF<LL>();\n    dfs(0, -1);\n\n    LL ans = n - 1;\n    REP(i, n){\n        if(dp[0][i][0] < 0)ans = min(ans, i);\n        if(dp[0][i][1] < HINF<LL>())ans = min(ans, i);\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n#include <functional>\n\nusing namespace std;\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for(int (i) = (a) - 1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for(int (i) = (a) - 1; (i) >= (b); (i)--)\n#define DEBUG(C) cerr << #C << \" = \" << C << endl;\nusing LL = long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing VD = vector<double>;\nusing VVD = vector<VD>;\nusing PII = pair<int, int>;\nusing PDD = pair<double, double>;\nusing PLL = pair<LL, LL>;\nusing VPII = vector<PII>;\ntemplate<typename T> using VT = vector<T>;\n#define ALL(a) begin((a)), end((a))\n#define RALL(a) rbegin((a)), rend((a))\n#define SORT(a) sort(ALL((a)))\n#define RSORT(a) sort(RALL((a)))\n#define REVERSE(a) reverse(ALL((a)))\n#define MP make_pair\n#define FORE(a, b) for (auto &&a : (b))\n#define FIND(s, e) ((s).find(e) != (s).end())\n#define EB emplace_back\ntemplate<typename T> inline bool chmax(T &a, T b){if (a < b){a = b;return true;}return false;}\ntemplate<typename T> inline bool chmin(T &a, T b){if (a > b){a = b;return true;}return false;}\n\nconst int INF = 1e9;\nconst int MOD = INF + 7;\nconst LL LLINF = 1e18;\n\n// UnionFind,素集合データ構造,DisjointSet\n\nclass union_find {\nprivate:\n    std::vector<int> uni;\n    int size_;\n    const void check(const int n) const {\n        if (this->group_size() < 0) {\n            assert(false);\n        }\n        if (!(0 <= n && n < this->all_size())) {\n            assert(false);\n        }\n    }\npublic:\n    union_find() : size_(-1) {}\n    union_find(const int n)\n        : uni(n, -1), size_(n) {\n        this->check(n - 1);\n    }\n    bool same(const int a, const int b) {\n        this->check(a);\n        this->check(b);\n        return this->find(a) == this->find(b);\n    }\n    int find(const int a) {\n        this->check(a);\n        return this->uni[a] < 0 ?\n                a :\n            this->uni[a] = this->find(this->uni[a]);\n    }\n    bool unite(int a, int b) {\n        a = this->find(a);\n        b = this->find(b);\n        if (a == b) {\n            return false;\n        }\n        this->size_--;\n        if (this->uni[a] > this->uni[b]) {\n            std::swap(a, b);\n        }\n        this->uni[a] += this->uni[b];\n        this->uni[b] = a;\n        return true;\n    }\n    const int group_size() const {\n        return this->size_;\n    }\n    const int all_size() const {\n        return this->uni.size();\n    }\n    const int size(const int a) {\n        this->check(a);\n        return -this->uni[this->find(a)];\n    }\n};\n\nconst int MAX = 5555;\nint N;\nLL A[MAX];\nLL sum[MAX];\nVT<pair<LL, PII>> edge;\nunion_find uf;\n\nvoid unite(int u, int v) {\n    u = uf.find(u);\n    v = uf.find(v);\n    uf.unite(u, v);\n    if (uf.find(u) == u) sum[u] += sum[v];\n    else sum[v] += sum[u];\n}\n\nint main(void) {\n    scanf(\"%d\", &N);\n    uf = union_find(N);\n    REP(i, N) {\n        scanf(\"%lld\", A + i);\n        sum[i] = A[i];\n    }\n    REP(i, N - 1) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        u--;v--;\n        if ((A[u] < 0) ^ (A[v] < 0)) {\n            edge.EB(MP(-1, MP(u, v)));\n        } else {\n            unite(u, v);\n        }\n    }\n    FORE(e, edge) {\n        e.first = sum[uf.find(e.second.first)] + sum[uf.find(e.second.second)];\n    }\n    SORT(edge);\n    int cnt = 0;\n    FORE(e, edge) {\n        if (sum[uf.find(e.second.first)] + sum[uf.find(e.second.second)] <= 0) {\n            unite(e.second.first, e.second.second);\n        } else {\n            cnt++;\n        }\n    }\n    cout << cnt << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// #define int long long\n#define rep(i, n) for (long long i = (long long)(0); i < (long long)(n); ++i)\n#define reps(i, n) for (long long i = (long long)(1); i <= (long long)(n); ++i)\n#define rrep(i, n) for (long long i = ((long long)(n)-1); i >= 0; i--)\n#define rreps(i, n) for (long long i = ((long long)(n)); i > 0; i--)\n#define irep(i, m, n) for (long long i = (long long)(m); i < (long long)(n); ++i)\n#define ireps(i, m, n) for (long long i = (long long)(m); i <= (long long)(n); ++i)\n#define SORT(v, n) sort(v, v + n);\n#define REVERSE(v, n) reverse(v, v+n);\n#define vsort(v) sort(v.begin(), v.end());\n#define all(v) v.begin(), v.end()\n#define mp(n, m) make_pair(n, m);\n#define cout(d) cout<<d<<endl;\n#define coutd(d) cout<<std::setprecision(10)<<d<<endl;\n#define cinline(n) getline(cin,n);\n#define replace_all(s, b, a) replace(s.begin(),s.end(), b, a);\n#define PI (acos(-1))\n#define FILL(v, n, x) fill(v, v + n, x);\n#define sz(x) long long(x.size())\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing vs = vector<string>;\nusing vpll = vector<pair<ll, ll>>;\nusing vtp = vector<tuple<ll,ll,ll>>;\nusing vb = vector<bool>;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nconst ll INF = 1e9+10;\nconst ll MOD = 1e9+7;\nconst ll LINF = 1e18;\n\nll n;\nvll a;\nvi G[5005];\n\nint num[5005];\nll dp[5005][5005][2]; // vで条件を満たすようにi辺取り除いたときvの連結成分の和の最小値(j=1なら全ての成分が正である)\nll sub[5005][2];\n\nvoid dfs(int v, int p){\n  vi child;\n  for(auto &nv: G[v]){\n    if(nv==p) continue;\n    dfs(nv,v);\n    child.push_back(nv);\n  }\n  \n  dp[v][0][(a[v]>0)]=a[v];\n  \n  for(auto &nv: child){\n    for(int i=0; i<=num[v]; i++){\n      for(int j=0; j<=num[nv]; j++){\n        rep(k1,2) rep(k2,2){\n          ll v1=dp[v][i][k1], v2=dp[nv][j][k2];\n          if(max(v1,v2)==LINF) continue;\n          chmin(sub[i+j][k1&k2], v1+v2);\n          if(k2==1 || v2<0) chmin(sub[i+j+1][k1], v1);\n        }\n      }\n    }\n    num[v]+=num[nv]+1;\n    for(int i=0; i<=num[v]; i++) for(int j=0; j<2; j++){\n      dp[v][i][j]=sub[i][j];\n      sub[i][j]=LINF;\n    }\n  }\n}\n\nsigned main()\n{\n  cin.tie( 0 ); ios::sync_with_stdio( false );\n  \n  cin>>n;\n  a.resize(n);\n  rep(i,n) cin>>a[i];\n  rep(i,n-1){\n    ll a,b; cin>>a>>b; a--,b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  \n  rep(i,n+1) rep(j,n+1) rep(k,2) dp[i][j][k]=LINF;\n  rep(i,n+1) rep(j,2) sub[i][j]=LINF;\n  dfs(0,-1);\n  \n  ll ans=LINF;\n  // rep(i,n) cout<<dp[0][i][0]<<' ';\n  // cout<<endl;\n  // rep(i,n) cout<<dp[0][i][1]<<' ';\n  // cout<<endl;\n  \n  rep(i,n){\n    if(dp[0][i][0]<0 || dp[0][i][1]!=LINF){\n      ans=i;\n      break;\n    }\n  }\n  \n  cout<<ans<<endl;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nconst int N = 5010;\nconst ll INF = 1e18;\nint n;\nll a[N];\nVI e[N];\n\nvoid out(VVL &dp){\n    REP(f,2){\n        REP(i,dp[f].size()) cout << dp[f][i] << \" \";\n        cout << endl;\n    }\n    cout << endl;\n}\n\nvoid dfs(int now, int past, VVL &dp){\n    dp.assign(2, VL(1, INF));\n    if (a[now] > 0) dp[1][0] = a[now];\n    else dp[0][0] = a[now];\n    for (int next : e[now]){\n        if (next == past) continue;\n        VVL dp2(2);\n        dfs(next, now, dp2);\n        int n = dp[0].size(), m = dp2[0].size();\n        VVL dp_next(2, VL(n + m, INF));\n        REP(i,n) REP(f,2) REP(j,m) REP(g,2){\n            if (dp[f][i] == INF || dp2[g][j] == INF) continue;\n            dp_next[f & g][i + j] = min(dp_next[f & g][i + j], dp[f][i] + dp2[g][j]);\n            if (g || dp2[g][j] < 0) dp_next[f][i + j + 1] = min(dp_next[f][i + j + 1], dp[f][i]);\n        }\n        // out(dp);\n        // out(dp2);\n        // out(dp_next);\n        dp.swap(dp_next);\n    }\n}\n\nint main() {\n    cin >> n;\n    REP(i,n) a[i] = in();\n    REP(i,n-1){\n        int u = in() - 1, v = in() - 1;\n        e[u].push_back(v);\n        e[v].push_back(u);\n    }\n\n    VVL dp(2);\n    dfs(0, -1, dp);\n\n    int ans = n;\n    REP(i,n){\n        if (dp[0][i] < 0 || dp[1][i] < INF) ans = min(ans, i);\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <limits.h>\n#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define int long long\n#define REP(i, n) for (int i = 0, i##_len = (n); i < i##_len; ++i)\n#define REPS(i, n) for (int i = 1, i##_len = (n); i <= i##_len; ++i)\n#define FOR(i, a, b) for (int i = (a), i##_len = (b); i <= i##_len; ++i)\n#define REV(i, a, b) for (int i = (a); i >= (b); --i)\n#define CLR(a, b) memset((a), (b), sizeof(a))\n#define DUMP(x) cout << #x << \" = \" << (x) << endl;\n#define INF 1001001001001001ll\n#define fcout cout << fixed << setprecision(10)\n\nusing namespace std;\n\nint dp[5005][5005][2];\nint sdp[5005][2];\nvector<int> G[5005];\nint A[5005];\nint num[5005];\n\nvoid dfs(int x, int par) {\n    REP(j, G[x].size()) {\n        int c = G[x][j];\n        if (c == par) continue;\n        dfs(c, x);\n    }\n\n    REP(i, 5005) sdp[i][0] = sdp[i][1] = INF;\n\n    dp[x][0][A[x] < 0] = A[x];\n\n    int sum = 1;\n    REP(j, G[x].size()) {\n        int c = G[x][j];\n        if (c == par) continue;\n        REP(s1, sum) {\n            REP(s2, num[c]) {\n                REP(k1, 2) {\n                    REP(k2, 2) {\n                        // つなぐ\n                        if (dp[c][s2][k2] < INF) {\n                            sdp[s1 + s2][k1 | k2] = min(sdp[s1 + s2][k1 | k2], dp[x][s1][k1] + dp[c][s2][k2]);\n                        }\n\n                        // 切る\n                        if (dp[c][s2][k2] < 0 || (k2 == 0 && dp[c][s2][k2] < INF)) {\n                            sdp[s1 + s2 + 1][k1] = min(sdp[s1 + s2 + 1][k1], dp[x][s1][k1]);\n                        }\n                    }\n                }\n            }\n        }\n        sum += num[c];\n        REP(nj, sum) {\n            REP(k, 2) {\n                dp[x][nj][k] = sdp[nj][k];\n                sdp[nj][k] = INF;\n            }\n        }\n\n    }\n\n    num[x] = sum;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n\n    int N;\n    cin >> N;\n    REP(i, N) cin >> A[i];\n    REP(i, N - 1) {\n        int u, v;\n        cin >> u >> v;\n        u--;\n        v--;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    REP(i, N) REP(j, N - 1) REP(k, 2) dp[i][j][k] = INF;\n\n    dfs(0, -1);\n\n    int res = INF;\n    REP(j, N) {\n        if (dp[0][j][0] < INF) res = min(res, j);\n        if (dp[0][j][1] < 0) res = min(res, j);\n    }\n    cout << res << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 100000000000000;\n\nint n;\nvector<ll> a(5000);\nvector<vector<ll> > adj(5000, vector<ll>());\n//vector<vector<vector<ll> > > dp(5000, vector<vector<ll> >(5000, vector<ll>(2, INF)));\nll dp[5000][5000][2];\nvector<int> edges(5000, 0);\n\nvoid chmin(ll& before, ll after) {\n\tif (before > after) before = after;\n\treturn;\n}\n\nint dfs_pre(int x, int p) {\n\tif (x != 0 && adj[x].size() == 1) return 0;\n\tfor (auto v : adj[x]) {\n\t\tif (v == p) continue;\n\t\telse edges[x] += dfs_pre(v, x) + 1;\n\t}\n\treturn edges[x];\n}\n\nvoid dfs(int x, int p) {\n\tfor (auto v : adj[x]) {\n\t\tif (v != p) dfs(v, x);\n\t}\n\n\t//vector<vector<vector<ll> > > sub(n, vector<vector<ll> >(n, vector<ll>(2, INF)));\n\tll sub[n+1][n+1][2];\n\tfor (int i = 0; i < adj[x].size()+2; ++i)\n\t{\n\t\tfor (int j = 0; j < edges[x]+2; ++j)\n\t\t{\n\t\t\tsub[i][j][0] = INF;\n\t\t\tsub[i][j][1] = INF;\n\t\t}\n\t}\n\tsub[0][0][1] = a[x];\n\tif (a[x] > 0) sub[0][0][0] = a[x];\n\tint i = 0;\n\tint e_cnt = 0;\n\n\tfor (auto v : adj[x]) {\n\t\tif (v == p) continue;\n\t\tfor (int j1 = 0; j1 < e_cnt+1; ++j1)\n\t\t{\n\t\t\tfor (int j2 = 0; j2 < edges[v]+1; ++j2)\n\t\t\t{\n\t\t\t\tchmin(sub[i+1][j1+j2][1], sub[i][j1][0] + dp[v][j2][1]);\n\t\t\t\tchmin(sub[i+1][j1+j2][1], sub[i][j1][1] + dp[v][j2][0]);\n\t\t\t\tchmin(sub[i+1][j1+j2][1], sub[i][j1][1] + dp[v][j2][1]);\n\t\t\t\tif (a[x] > 0) chmin(sub[i+1][j1+j2][0], sub[i][j1][0] + dp[v][j2][0]);\n\n\t\t\t\tif (dp[v][j2][0] < INF/2 || dp[v][j2][1] < 0) {\n\t\t\t\t\tchmin(sub[i+1][j1+j2+1][1], sub[i][j1][1]);\n\t\t\t\t\tif (a[x] > 0) chmin(sub[i+1][j1+j2+1][0], sub[i][j1][0]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\te_cnt += edges[v] + 1;\n\t\ti++;\n\t}\n\tfor (int j = 0; j < edges[x]+1; ++j)\n\t{\n\t\tdp[x][j][0] = sub[i][j][0];\n\t\tdp[x][j][1] = sub[i][j][1];\n\t}\n\n\treturn;\n}\n\nint main() {\n\tfor (int i = 0; i < 5000; ++i)\n\t{\n\t\tfor (int j = 0; j < 5000; ++j)\n\t\t{\n\t\t\tfor (int k = 0; k < 2; ++k)\n\t\t\t{\n\t\t\t\tdp[i][j][k] = INF;\n\t\t\t}\n\t\t}\n\t}\n\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i) cin >> a[i];\n\tfor (int i = 0; i < n-1; ++i)\n\t{\n\t\tint u, v; cin >> u >> v;\n\t\tadj[u-1].push_back(v-1);\n\t\tadj[v-1].push_back(u-1);\n\t}\n\n\tdfs_pre(0, -1);\n\n\tdfs(0, -1);\n\n\tint ans;\n\tfor (int j = 0; j < n; ++j)\n\t{\n\t\tif (dp[0][j][0] < INF/2 || dp[0][j][1] < 0) {\n\t\t\tans = j;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define int long long\nusing namespace std;\n#define rep(i, n) for(int i=0;i<(n);++i)\ntypedef pair<int, int> pii;\nconst int INF = 1l << 60;\n#define u_b upper_bound\n#define l_b lower_bound\n\nconst int MAX_N = 5000;\nint N;\nint A[MAX_N];\nvector<int> G[MAX_N];\nvector<int> dp1[MAX_N];\nvector<int> dp2[MAX_N];\n\nvector<int> tr(vector<int> dp, vector<int> ch1, vector<int> ch2, bool flg) {\n    int a = dp.size(), b = ch1.size();\n    vector<int> ans(a + b - 1);\n    rep(i, ans.size())ans[i] = INF;\n    rep(i, dp.size()) {\n        if (dp[i] == INF)continue;\n        rep(j, ch1.size()) {\n            if (i + j - 1 >= 0) {\n                if (ch1[j] != INF)ans[i + j - 1] = min(ans[i + j - 1], dp[i] + ch1[j]);\n                if (ch2[j] != INF && !flg)ans[i + j - 1] = min(ans[i + j - 1], dp[i] + ch2[j]);\n            }\n            if (ch1[j] != INF)ans[i + j] = min(ans[i + j], dp[i]);\n            if (ch2[j] < 0)ans[i + j] = min(ans[i + j], dp[i]);\n        }\n    }\n    return ans;\n}\n\nvoid dfs(int v, int par) {\n    dp1[v].push_back(INF);\n    dp1[v].push_back(A[v] > 0 ? A[v] : INF);\n    dp2[v].push_back(INF);\n    dp2[v].push_back(A[v]);\n    for (int u:G[v]) {\n        if (u == par)continue;\n        dfs(u, v);\n        dp1[v] = tr(dp1[v], dp1[u], dp2[u], true);\n        dp2[v] = tr(dp2[v], dp1[u], dp2[u], false);\n    }\n}\n\nint solve() {\n    dfs(0, -1);\n    for (int i = 0; i <= N; ++i) {\n        if (dp1[0][i] < INF)return i - 1;\n        if (dp2[0][i] < 0)return i - 1;\n    }\n    return -1;\n}\n\nsigned main() {\n    cin >> N;\n    rep(i, N)cin >> A[i];\n    rep(i, N - 1) {\n        int u, v;\n        cin >> u >> v;\n        u--, v--;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    int ans = solve();\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <unordered_set>\n#include <unordered_map>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <cstdio>\n#include <complex>\n#include <cstdint>\n#include <tuple>\n\n#define M_PI       3.14159265358979323846\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\ninline int readInt() { int x; scanf(\"%d\", &x); return x; }\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SQ(a) ((a)*(a))\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,s,n) for(int i=s;i<(int)n;++i)\n#define REP(i,n) FOR(i,0,n)\n#define MOD 1000000007\n\nconst int N = 5005;\nvector<LL> dp1[N], dp2[N];\nint a[N];\nLL INF = 0x3f3f3f3f3f3f3f3f;\n\n\nvoid dfs(VVI& g, int u, int p = -1) {\n\tdp1[u].push_back(INF);\n\tdp1[u].push_back((a[u] > 0) ? a[u] : INF);\n\tdp2[u].PB(INF);\n\tdp2[u].PB(a[u]);\n\tfor (auto v : g[u]) {\n\t\tif (v == p)continue;\n\t\tdfs(g, v, u);\n\t\tVLL dp1x = VLL(dp1[u].size() + dp1[v].size() - 1, INF);\n\t\tVLL dp2x = VLL(dp1[u].size() + dp1[v].size() - 1, INF);\n\t\tREP(i, dp1[u].size()) {\n\t\t\tif (dp2[u][i]==INF)continue;\n\t\t\tREP(j, dp1[v].size()) {\n\t\t\t\tif (i + j - 1 >= 0) {//統合\n\t\t\t\t\tdp1x[i + j - 1] = min(dp1x[i + j - 1], dp1[u][i] + dp1[v][j]);\n\t\t\t\t\tdp2x[i + j - 1] = min(dp2x[i + j - 1], dp2[u][i] + dp1[v][j]);\n\t\t\t\t\tdp2x[i + j - 1] = min(dp2x[i + j - 1], dp2[u][i] + dp2[v][j]);\n\t\t\t\t}\n\t\t\t\t//分離\n\t\t\t\tif (dp1[v][j] != INF) {\n\t\t\t\t\tdp1x[i + j] = min(dp1x[i + j], dp1[u][i]);\n\t\t\t\t\tdp2x[i + j] = min(dp2x[i + j], dp2[u][i]);\n\t\t\t\t}\n\t\t\t\tif (dp2[v][j] < 0) {\n\t\t\t\t\tdp1x[i + j] = min(dp1x[i + j], dp1[u][i]);\n\t\t\t\t\tdp2x[i + j] = min(dp2x[i + j], dp2[u][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdp1[u] = dp1x;\n\t\tdp2[u] = dp2x;\n\t}\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tREP(i, n)scanf(\"%d\", &a[i]);\n\tVVI g(n);\n\tREP(i, n - 1) {\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tu--, v--;\n\t\tg[u].PB(v);\n\t\tg[v].PB(u);\n\t}\n\tdfs(g, 0);\n\tfor (int i = 0; dp1[0].size(); i++) {\n\t\tif (dp1[0][i] > 0 && dp1[0][i] < INF) {\n\t\t\tprintf(\"%d\\n\", i-1);\n\t\t\treturn 0;\n\t\t}\n\t\tif (dp2[0][i] < 0) {\n\t\t\tprintf(\"%d\\n\", i-1);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int64 INF = 1LL << 58;\n\nvector< int > g[5000];\nint N, A[5000];\nvector< bool > latte[5000];\nvector< int64 > malta[5000];\n\nvoid chmin(int64 &a, int64 b) { a = min(a, b); }\n\nvoid dfs(int idx, int par) {\n  for(auto &to : g[idx]) {\n    if(to == par) continue;\n    dfs(to, idx);\n  }\n\n  latte[idx].emplace_back(A[idx] > 0);\n  for(auto &to : g[idx]) {\n    if(to == par) continue;\n    if(A[to] > 0) {\n      vector< bool > nxt(latte[idx].size() + latte[to].size());\n      for(int i = 0; i < latte[idx].size(); i++) {\n        for(int j = 0; j < latte[to].size(); j++) {\n          if(latte[idx][i] & latte[to][j]) {\n            nxt[i + j] = true;\n          }\n        }\n        for(int j = 0; j < malta[to].size(); j++) {\n          if(!latte[idx][i] || malta[to][j] >= 0) continue;\n          nxt[i + j + 1] = true;\n        }\n      }\n      latte[idx].swap(nxt);\n    } else {\n      vector< bool > nxt(latte[idx].size() + latte[to].size());\n      for(int i = 0; i < latte[idx].size(); i++) {\n        for(int j = 0; j < malta[to].size(); j++) {\n          if(!latte[idx][i] || malta[to][j] >= 0) continue;\n          nxt[i + j + 1] = true;\n        }\n      }\n      latte[idx].swap(nxt);\n    }\n  }\n\n\n  malta[idx].emplace_back(A[idx]);\n  for(auto &to : g[idx]) {\n    if(to == par) continue;\n    vector< int64 > nxt(malta[idx].size() + latte[to].size(), INF);\n    for(int i = 0; i < malta[idx].size(); i++) {\n      for(int j = 0; j < latte[to].size(); j++) {\n        if(latte[to][j]) chmin(nxt[i + j + 1], malta[idx][i]);\n      }\n      for(int j = 0; j < malta[to].size(); j++) {\n        if(malta[to][j] == INF) continue;\n        chmin(nxt[i + j], malta[idx][i] + malta[to][j]);\n      }\n    }\n    malta[idx].swap(nxt);\n  }\n\n  for(int i = 0; i < malta[idx].size(); i++) {\n    if(malta[idx][i] < 0) latte[idx][i] = true;\n  }\n\n}\n\n\nint main() {\n  cin >> N;\n  for(int i = 0; i < N; i++) cin >> A[i];\n  for(int i = 1; i < N; i++) {\n    int x, y;\n    cin >> x >> y;\n    --x, --y;\n    g[x].emplace_back(y);\n    g[y].emplace_back(x);\n  }\n  dfs(0, -1);\n  for(int i = 0; i < latte[0].size(); i++) {\n    if(latte[0][i]) {\n      cout << i << endl;\n      exit(0);\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define MT make_tuple\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\n\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class T>\nistream& operator>>(istream& is, vector<T>& xs){\n  for(auto& x: xs)\n\tis >> x;\n  return is;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& xs){\n  for(unsigned int i=0;i<xs.size();++i)\n\tos << (i?\" \":\"\") << xs[i];\n  return os;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\nvoid debug(istringstream&){}\ntemplate <char sep=',', class Head, class... Tail>\nvoid debug(istringstream& iss, Head&& head, Tail&&... tail)\n{\n  string name;\n  getline(iss, name, ',');\n  cerr << sep << name << \"=\" << head;\n  debug(iss, forward<Tail>(tail)...);\n}\n#define DEBUG(...) \\\n  do{ \\\n    istringstream ss(#__VA_ARGS__); \\\n    debug<' '>(ss, __VA_ARGS__); \\\n    cerr<<endl; \\\n  }while(0)\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\nconst LL INF = 1e15;\n\nLL dp[5010][5010][2];\nLL crts[5010][5010][2];\nLL nxts[5010][5010][2];\nint sz[5010];\n\nvoid dfs(const VVI& G, int u, int p, VL& xs){\n  sz[u] = 1;\n\n  auto crt = crts[u];\n  auto nxt = nxts[u];\n\n  fill((LL*)crt, (LL*)crt+5010*2, INF);\n  fill((LL*)nxt, (LL*)nxt+5010*2, INF);\n  int ub = 1;\n  if(xs[u] > 0) crt[0][0] = xs[u];\n  crt[0][1] = xs[u];\n\n  for(int v: G[u]){\n    if(v == p) continue;\n\n    dfs(G, v, u, xs);\n    sz[u] += sz[v];\n    REP(i,ub+1) REP(j,2) nxt[i][j] = INF;\n    for(int k=0;k<=ub;++k){\n      for(int l=0;l<=sz[v];++l){\n        if(xs[u] > 0 && crt[k][0] < INF){\n          if(dp[v][l][1] < 0 || dp[v][l][0] < INF){\n            mini(nxt[k+l+1][0], crt[k][0]);\n            mini(nxt[k+l+1][1], crt[k][0]);\n          }\n          if(dp[v][l][0] < INF){\n            mini(nxt[k+l][0], crt[k][0] + dp[v][l][0]);\n            mini(nxt[k+l][1], crt[k][0] + dp[v][l][0]);\n          }\n        }\n\n        if(crt[k][1] < INF){\n          if(dp[v][l][1] < INF)\n            mini(nxt[k+l][1], crt[k][1] + dp[v][l][1]);\n          if(dp[v][l][1] < 0 || dp[v][l][0] < INF)\n            mini(nxt[k+l+1][1], crt[k][1]);\n        }\n      }\n    }\n    ub += sz[v];\n    swap(crt, nxt);\n  }\n\n  REP(k,ub+1) REP(j,2){\n    dp[u][k][j] = crt[k][j];\n    //DEBUG(u,k,j,dp[u][k][j]);\n  }\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N;\n  cin >> N;\n  VL xs(N);\n  cin >> xs;\n\n  VVI G(N);\n\n  REP(i,N-1){\n    int u, v;\n    cin >> u >> v;\n    --u;\n    --v;\n    G[u].PB(v);\n    G[v].PB(u);\n  }\n\n  fill((LL*)dp, (LL*)dp+5010*5010*2, INF);\n  dfs(G, 0, -1, xs);\n\n  int ans = N;\n  for(int i=0;i<N;++i){\n    if(dp[0][i][0] < INF || dp[0][i][1] < 0){\n      ans = i;\n      break;\n    }\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stdio.h>\n#include <vector>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stdlib.h>\n#include <time.h>\n#include <iomanip>\n#include <math.h>\n#include <bitset>\n\nusing namespace std;\n\n#define taskname \"A\"\n#define LL long long \n#define uLL unsigned long long \n#define FOR(i,l,r) for(int i = l; i <= r; ++i)\n#define REP(i,l,r) for(int i = l; i < r; ++i)\n#define FORD(i,r,l) for(int i = r; i >= l; --i)\n#define REPD(i,r,l) for(int i = r; i > l; --i)\n#define sz(x) (int)((x).size())\n#define all(x) (x).begin(), (x).end()\n#define debug(x) { cerr << #x << \" = \" << x << endl; }\n#define sci(x) int x; scanf(\"%d\", &x);\n#define scii(x, y) int x, y; scanf(\"%d %d\", &x, &y);\n#define sciii(x, y, z) int x, y, z; scanf(\"%d %d %d\", &x, &y, &z);\n#define pi pair<int,int>\n#define pii pair<int,pi>\n#define piLL pair<LL,LL>\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define _USE_MATH_DEFINES \n/* M_PI */\n#define SetLength2(a, n, t) a=((t*) calloc(n, sizeof(t))) + (n)/2\n\nconst int maxN = 5001;\nconst LL oo = 1e17 + 11;\n\nint tcases = 1;\n\nint N,M,total = 0,res = 0;\nvector <int> e[maxN];\nint C[maxN];\nLL W[maxN],A[maxN],F[maxN][maxN],f1[maxN],g1[maxN];\nbool G[maxN][maxN];\npiLL tmp[maxN],fg[maxN];\n\nvoid dfs(int u,int p = 0){\n    W[u] = A[u];\n    C[u] = 1;\n    REP(i,0,e[u].size()){\n        int v = e[u][i];\n        if(v == p) continue;\n        dfs(v,u);\n        W[u] += W[v];\n        C[u] += C[v];\n    }\n}\nvoid cal(int u,int p = 0){\n    REP(i,0,e[u].size()){\n        int v = e[u][i];\n        if(v == p) continue;\n        cal(v,u);\n    }\n    //\n    F[u][0] = W[u];\n    if(C[u] == 1) G[u][0] = A[u] > 0;\n    else{\n        REP(i,0,C[u]) f1[i] = oo,g1[i] = 0;\n        f1[0] = 0; g1[0] = 1;\n        \n        REP(node,0,e[u].size()){\n            int v = e[u][node];\n            if(v == p) continue;\n            // cal F[u][i]\n            REP(i,0,C[u]){\n                F[u][i] = oo; G[u][i] = 0;\n                FOR(j,0,min(C[v],i)){\n                    F[u][i] = min(F[u][i],f1[i - j] + F[v][j]);\n                    G[u][i] |= g1[i - j] & G[v][j];\n                }\n            }\n            REP(i,0,C[u]) f1[i] = F[u][i],g1[i] = G[u][i];\n        }\n        REP(i,0,C[u]){\n            F[u][i] += A[u];\n            if(A[u] < 0) G[u][i] = 0;\n        }\n    }\n    REP(i,0,C[u]){\n        if(F[u][i] < 0 || G[u][i]){\n            F[u][i + 1] = min(F[u][i + 1],0LL);\n            G[u][i + 1] = 1;\n        }\n    }\n}\nvoid testcase(){\n    scanf(\"%d\",&N);\n    FOR(i,1,N) scanf(\"%lli\",&A[i]);\n    \n    REP(i,1,N){\n        scii(u,v);\n        e[u].pb(v);\n        e[v].pb(u);\n    }\n    dfs(1);\n\n    FOR(i,1,N){\n        FOR(j,0,N) F[i][j] = oo;\n    }\n\n    cal(1);\n    \n    FOR(j,0,N) if(F[1][j] < 0 || G[1][j]){\n        printf(\"%d\",j);\n        return ;\n    }\n}\n\nint main(){\n    \n    //scanf(\"%d\",&tcases);\n    \n    FOR(i,1,tcases) testcase();\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stdio.h>\n#include <vector>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stdlib.h>\n#include <time.h>\n#include <iomanip>\n#include <math.h>\n#include <bitset>\n\nusing namespace std;\n\n#define taskname \"A\"\n#define LL long long \n#define uLL unsigned long long \n#define FOR(i,l,r) for(int i = l; i <= r; ++i)\n#define REP(i,l,r) for(int i = l; i < r; ++i)\n#define FORD(i,r,l) for(int i = r; i >= l; --i)\n#define REPD(i,r,l) for(int i = r; i > l; --i)\n#define sz(x) (int)((x).size())\n#define all(x) (x).begin(), (x).end()\n#define debug(x) { cerr << #x << \" = \" << x << endl; }\n#define sci(x) int x; scanf(\"%d\", &x);\n#define scii(x, y) int x, y; scanf(\"%d %d\", &x, &y);\n#define sciii(x, y, z) int x, y, z; scanf(\"%d %d %d\", &x, &y, &z);\n#define pi pair<int,int>\n#define pii pair<int,pi>\n#define piLL pair<LL,LL>\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define _USE_MATH_DEFINES \n/* M_PI */\n#define SetLength2(a, n, t) a=((t*) calloc(n, sizeof(t))) + (n)/2\n\nconst int maxN = 5011;\nconst LL oo = 1e17 + 11;\n\nint tcases = 1;\n\nint N,M,total = 0,res = 0;\nvector <int> e[maxN];\nint C[maxN];\nLL W[maxN],A[maxN],F[maxN][maxN],f1[maxN];\nbool G[maxN][maxN],g1[maxN];\npiLL tmp[maxN],fg[maxN];\n\nvoid dfs(int u,int p = 0){\n    W[u] = A[u];\n    C[u] = 1;\n    REP(i,0,e[u].size()){\n        int v = e[u][i];\n        if(v == p) continue;\n        dfs(v,u);\n        W[u] += W[v];\n        C[u] += C[v];\n    }\n}\nvoid cal(int u,int p = 0){\n    REP(i,0,e[u].size()){\n        int v = e[u][i];\n        if(v != p) cal(v,u);\n    }\n    //\n    F[u][0] = W[u];\n    if(C[u] == 1) G[u][0] = A[u] > 0;\n    else{\n        REP(i,0,C[u]) f1[i] = oo,g1[i] = 0;\n        f1[0] = 0; g1[0] = 1;\n        \n        REP(k,0,e[u].size()){\n            int v = e[u][k];\n            if(v == p) continue;\n            // cal F[u][i]\n            REP(i,0,C[u]){\n                F[u][i] = oo; G[u][i] = 0;\n                FOR(j,0,min(C[v],i)){\n                    F[u][i] = min(F[u][i],f1[i - j] + F[v][j]);\n                    G[u][i] |= (g1[i - j] && G[v][j]);\n                }\n            }\n            REP(i,0,C[u]) f1[i] = F[u][i],g1[i] = G[u][i];\n        }\n        REP(i,0,C[u]){\n            F[u][i] += A[u];\n            if(A[u] < 0) G[u][i] = 0;\n        }\n    }\n    REP(i,0,C[u]){\n        if(F[u][i] < 0 || G[u][i]){\n            F[u][i + 1] = min(F[u][i + 1],0LL);\n            G[u][i + 1] = 1;\n        }\n    }\n}\nvoid testcase(){\n\n    cin >> N;\n    FOR(i,1,N) cin >> A[i];\n    \n    REP(i,1,N){\n        scii(u,v);\n        e[u].pb(v);\n        e[v].pb(u);\n    }\n\n    dfs(1);\n\n    int root = 1;\n\n    FOR(i,1,N){\n        FOR(j,0,N) F[i][j] = oo;\n    }\n\n    cal(root);\n    \n    FOR(j,0,N) if(F[root][j] < 0 || G[root][j]){\n        cout << j;\n        return ;\n    }\n}\n\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie();\n    cout.tie();\n    \n    FOR(i,1,tcases) testcase();\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <queue>\n#define MAX_N 5005\n#define INF 8000000000000\n\nusing namespace std;\ntypedef long long ll;\n\nint N;\nll A[MAX_N];\nvector<int> G[MAX_N];\nll dp[2][MAX_N][MAX_N];//i,v,k 親成分以外が条件を満たす/親成分すべて正　連結成分の数\nll dpn[2][MAX_N];\n\nvoid show(){\n    //debug\n    for(int n=0;n<N;n++){\n        for(int k=0;k<=N;k++){\n            if(dp[0][n][k]==INF){cout<<\"INF \";continue;}\n            cout<<dp[0][n][k]<<\" \";\n        }\n        cout<<endl;\n    }\n    cout<<endl;\n    for(int n=0;n<N;n++){\n        for(int k=0;k<=N;k++){\n            if(dp[1][n][k]==INF){cout<<\"INF \";continue;}\n            cout<<dp[1][n][k]<<\" \";\n        }\n        cout<<endl;\n    }\n    cout<<\"--------------------------------\"<<endl;\n\n}\n\nint dfs(int p,int n){//親ノード、今のノード\n    int count = 0;\n    int K = 1,K_;\n    for(int i = 0;i < G[n].size();i++){\n        int c = G[n][i];\n        if(c==p)continue;\n        count++;\n        K_=K;\n        K += dfs(n,c);\n        if(count==1){\n            for(int k = 1;k <= K;k++){\n                //nをk個目の独立した連結成分にする場合\n                if(dp[0][c][k-1]<0||dp[1][c][k-1]!=INF){\n                    dp[0][n][k]=min(dp[0][n][k],A[n]);\n                    if(A[n]>0)\n                        dp[1][n][k]=min(dp[1][n][k],A[n]);\n                }\n                //cの連結成分につなげる場合\n                if(dp[0][c][k]!=INF)\n                    dp[0][n][k]=min(dp[0][n][k],dp[0][c][k]+A[n]);\n                if(A[n]>0&&dp[1][c][k]!=INF)\n                    dp[1][n][k]=min(dp[1][n][k],dp[1][c][k]+A[n]);\n            }\n            continue;\n        }\n        for(int k = 0;k <= K;k++){\n            dpn[0][k]=INF;\n            dpn[1][k]=INF;\n        }\n        for(int k = 1;k <= K;k++){\n            //cのノードをnに繋げない場合\n            /*for(int k_ = min(k,K_);k_ > 0;k_--){//k_:n側の連結成分数\n                if(dp[0][c][k-k_]<0||dp[1][c][k-k_]!=INF){//cのノード以下が問題文の条件を満たしていれば、繋がなくても良い。\n                    dpn[0][k] = min(dpn[0][k],dp[0][n][k_]);\n                    dpn[1][k] = min(dpn[1][k],dp[1][n][k_]);\n                }\n            }\n            //cをnの連結成分につなげる場合\n            for(int k_ = min(k,K_);k_ > 0;k_--){//k_:n側の連結成分数\n                if(dp[0][c][k-k_+1]!=INF&&dp[0][n][k_]!=INF){\n                    dpn[0][k]=min(dpn[0][k],dp[0][c][k-k_+1]+dp[0][n][k_]);\n                }\n                if(dp[1][c][k-k_+1]!=INF&&dp[1][n][k_]!=INF){\n                    dpn[1][k]=min(dpn[1][k],dp[1][c][k-k_+1]+dp[1][n][k_]);\n                }\n            }*/\n        }\n        for(int k = 1;k <= K;k++){\n            dp[0][n][k]=dpn[0][k];\n            dp[1][n][k]=dpn[1][k];\n        }\n    }\n    if(p>=0&&count==0){\n        dp[0][n][1]=A[n];\n        if(A[n]>0){\n            dp[1][n][1]=A[n];\n        }\n    }\n//    cout<<n<<endl;\n//    show();\n    return K;\n}\n\nint main() {\n    cin>>N;\n    for(int i=0;i<N;i++){\n        for(int j=0;j<=N;j++){\n            dp[0][i][j]=INF;\n            dp[1][i][j]=INF;\n        }\n        cin>>A[i];\n    }\n    for(int i=0;i<N-1;i++){\n        int a,b;\n        cin>>a>>b;\n        a--,b--;\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n    dfs(-1,0);\n    int ans;\n    \n    \n    \n    for(int k=1;k<=N;k++){\n        if(dp[0][0][k]<0){\n            cout<<k-1<<endl;\n//            cout<<\"debug 1\"<<endl;\n            return 0;\n        }\n        if(dp[1][0][k]!=INF&&dp[1][0][k]>0){\n            cout<<k-1<<endl;\n//            cout<<\"debug 2:\"<<dp[1][0][k]<<endl;\n            return 0;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <map>\n#include <set>\n#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <iomanip>\n#include <math.h>\n#include <time.h>\nusing namespace std;\n#define rep(i, n) for (ll i = 0; i < (ll)n; i++)\n#define repf(i, a, b) for (ll i = (ll)a; i < (ll)b; i++)\n#define repr(i, a, b) for (ll i = (ll)a; i > (ll)b; i--)\n#define all(v) (v).begin(), (v).end()\n#define mp(a, b) make_pair(a, b)\n#define pb(x) push_back(x)\n#define eb(x) emplace_back(x)\n#define F first\n#define S second\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ld, ld> pdd;\ntypedef vector<ll> vll;\ntypedef vector<vll> vvll;\ntypedef vector<int> vii;\ntypedef vector<vii> vvii;\nconst ll mod = 1e9 + 7;\nconst int infi = 1147483600;\nconst ll infl = 1e18 + 5;\nconst char ENDL = '\\n';\n//cout << fixed << setprecision(17) << res << endl;\nvoid chmin(ll& a,ll b){\n    a = min(a, b);\n}\nvoid chmax(ll& a,ll b){\n    a = max(a, b);\n}\nint n;\nll a[5005], prt[5005];\nvll edges[5005];\nll dp0[5005][5005], dp1[5005][5005];\n//dp0[i][j]:iの部分木をj個切断したとき、j+1個にわかれて、全て正かどうか\n//正なら整数値、正にできないならinfl\n//dp1[i][j]:上と同じで、負を含む場合の最小値\nvoid read(){\n    cin >> n;\n    rep(i, n) cin >> a[i];\n    rep(i,n-1){\n        int u, v;\n        cin >> u >> v;\n        u--;\n        v--;\n        edges[u].eb(v);\n        edges[v].eb(u);\n    }\n}\nvoid init(){\n    rep(i,n){\n        rep(j,n){\n            dp0[i][j] = dp1[i][j] = infl;\n        }\n    }\n    rep(i, n) prt[i] = -1;\n}\nint dfs(int now){\n    int child = 1;\n    if (a[now]>0)\n        dp0[now][0] = a[now];\n    dp1[now][0] = a[now];\n    for (auto nex:edges[now]){\n        if (nex==prt[now])\n            continue;\n        prt[nex] = now;\n        int c = dfs(nex);\n        //dp0[nex]dp1[nex]が求まった\n        //dp0[now]dp1[now]にマージしていく\n        //このとき、now側で既に決まっているのは数を考えなければならない。\n        //配るDPでマージするといいかも\n        /*\n        子の部分木をそのままくっつつける\n        ：くっつつける切断数足す。dp1の値を足す\n        dp0が実数かつ、遷移前のdp0が実数なら実数。\n        子の部分木を切り離す。\n        ：切断数+1を足す。dp0が実数か、dp1が負でなければならない。\n        値はそのまま\n        */\n        repr(i,child-1,-1){\n            ll tmp0 = dp0[now][i], tmp1 = dp1[now][i];\n            dp0[now][i] = dp1[now][i] = infl;\n            repr(j,c-1,-1)\n            {\n                chmin(dp0[now][i + j], tmp0 + dp0[nex][j]);\n                chmin(dp1[now][i + j], tmp1 + dp1[nex][j]);\n                if (dp0[nex][j]<infl/2 || dp1[nex][j]<0){\n                    chmin(dp0[now][i + j + 1], tmp0);\n                    chmin(dp1[now][i + j + 1], tmp1);\n                }\n            }\n        }\n        child += c;\n    }\n    return child;\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    read();\n    init();\n    dfs(0);\n    //make result\n    rep(i,n){\n        if (dp0[0][i]<infl/2 || dp1[0][i]<0){\n            cout << i << ENDL;\n            return 0;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5003;\nlong long dp[N][N];\nint a[N];\nint sz[N];\nlong long can[N];\nint num[N];\n\nstruct graph {\n\tint n;\n\tvector<vector<int>> edge;\n\tgraph(int n) : n(n) {\n\t\tedge.resize(n + 1);\n\t}\n\tvoid add(int u,int v) {\n\t\tedge[u].emplace_back(v);\n\t\tedge[v].emplace_back(u);\n\t}\n\tvoid dfs(int u,int p = 0) {\n\t\tsz[u] = 1;\n\t\tdp[u][0] = a[u];\n\t\tfor (auto&v : edge[u]) {\n\t\t\tif (v == p) continue;\n\t\t\tdfs(v,u);\n\t\t\tfor (int i = 0;i < sz[u] + sz[v];++i) can[i] = 1e16;\n\t\t\tif (a[u] > 0) {\n\t\t\t\tint pos ;\n\t\t\t\tif (a[v] > 0) pos = num[v];\n\t\t\t\telse pos = n;\n\t\t\t\tfor (int i = 0;i < sz[v];++i) if (dp[v][i] < 0) {\n\t\t\t\t\tpos =min(pos,i+1);\n\t\t\t\t\tbreak;\n\t\t\t\t} \n\t\t\t\tnum[u] += pos ;\n\t\t\t}\n\t\t\tfor (int i = 0;i < sz[u];++i) {\n\t\t\t\tfor (int j = 0;j < sz[v];++j) {\n\t\t\t\t\tcan[i+j] = min(can[i+j],dp[u][i] + dp[v][j]);\n\t\t\t\t\tif (dp[v][j] < 0) can[i+j+1] = min(can[i+j+1],dp[u][i]);\n\t\t\t\t}\n\t\t\t\tif (a[v] > 0) {\n\t\t\t\t\tcan[i + num[v] + 1] = min(can[i+num[v]+1],dp[u][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsz[u] += sz[v];\n\t\t\tfor (int i = 0;i < sz[u];++i) dp[u][i] = can[i];\n\t\t}\n\t}\n};\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\tcin >> n;\n\tgraph g(n);\n\tfor (int i = 1;i <= n;++i) cin >> a[i];\n\tfor (int i = 1;i < n;++i) {\n\t\tint u,v;\n\t\tcin >> u >> v;\n\t\tg.add(u,v);\n\t}\n\tg.dfs(1);\n\tint pos = n;\n\tif (a[1] > 0) pos = num[1];\n\tfor (int i = 0;i < n;++i) if (dp[1][i] < 0) return cout << min(pos,i),0;\n\tassert(pos != n);\n\tcout << pos;\n}"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <cstdio>\n#include <cstdint>\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cmath>\n#include <climits>\n#include <bitset>\n\n// macros\n#define ll long long int\n#define pb push_back\n#define mk make_pair\n#define pq priority_queue\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n\nusing namespace std;\n\n//  types\ntypedef pair<int, int> P;\ntypedef pair<ll, int> Pl;\ntypedef pair<ll, ll> Pll;\ntypedef pair<double, double> Pd;\n \n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 1e9 + 7;\n\n// solve\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\n\nvector<int> edge[5001];\nvector<int> child[5001];\nint par[5001], num[5001];\nll dp1[5001][5001], dp2[5001][5001];\n\nvoid dfs1(int i){\n  num[i] = 1;\n  rep(j, edge[i].size()){\n    int to = edge[i][j];\n    if(par[to] >= 0)continue;\n    par[to] = i;\n    child[i].pb(to);\n    dfs1(to);\n    num[i] += num[to];\n  }\n}\n\nvector<ll> a;\nint n;\n\nvoid dfs(int i){\n  rep(j, child[i].size()){\n    dfs(child[i][j]);\n  }\n  if(child[i].size() == 0){\n    if(a[i] < 0){\n      dp2[i][1] = a[i];\n    }else{\n      dp1[i][1] = dp2[i][1] = a[i];\n    }\n    return;\n  }\n  if(a[i] > 0){\n    vector<vector<ll> > dp = vector<vector<ll> >(num[i]+1, vector<ll>(num[i]+1, linf));\n    dp[0][1] = a[i];\n    int curr = 1;\n    rep(j, child[i].size()){\n      int to = child[i][j];\n      curr += num[to];\n      rep(k, curr+1){\n        for(int l = 1; l <= k; l++){\n          if(l > num[to])break;\n          if(dp1[to][l] < linf || dp2[to][l] < 0)chmin(dp[j+1][k], dp[j][k-l]);\n        }\n        if(a[to] > 0){\n          for(int l = 1; l <= k; l++){\n            if(l > num[to])break;\n            chmin(dp[j+1][k], dp[j][k-l+1] + dp1[to][l]);\n          }\n        }\n      }\n    }\n    rep(j, num[i]+1)dp1[i][j] = dp[child[i].size()][j];\n  }\n\n  vector<vector<ll> > dp = vector<vector<ll> >(num[i]+1, vector<ll>(num[i]+1, linf));\n  dp[0][1] = a[i];\n  int curr = 1;\n  rep(j, child[i].size()){\n    int to = child[i][j];\n    curr += num[to];\n    rep(k, curr+1){\n        for(int l = 1; l <= k; l++){\n          if(l > num[to])break;\n          if(dp1[to][l] < linf || dp2[to][l] < 0)chmin(dp[j+1][k], dp[j][k-l]);\n        }\n        for(int l = 1; l <= k; l++){\n          if(l > num[to])break;\n          chmin(dp[j+1][k], dp[j][k-l+1] + dp1[to][l]);\n          chmin(dp[j+1][k], dp[j][k-l+1] + dp2[to][l]);\n        }\n    }\n  }\n  rep(j, num[i]+1)dp2[i][j] = dp[child[i].size()][j];\n\n}\n\nint main(int argc, char const* argv[])\n{\n  cin >> n;\n  a = vector<ll>(n, 0);\n  rep(i, n)cin >> a[i];\n  rep(i, n - 1){\n    int x, y;\n    cin >> x >> y;\n    x--; y--;\n    edge[x].pb(y);\n    edge[y].pb(x);\n  }\n  fill(par, par + n, -1);\n  par[0] = 0;\n  dfs1(0);\n\n  rep(i, n+1){\n    rep(j, n+1){\n      dp1[i][j] = dp2[i][j] = linf;\n    }\n  }\n\n  dfs(0);\n  FOR(i, 1, n+1){\n    if(dp1[0][i] < linf || dp2[0][i] < 0){\n      cout << i - 1 << endl;\n      return 0;\n    }\n  }\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long dp[5010][5010];\nbool pos[5010][5010];\nint sz[5010];\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n; cin >> n;\n    vector<long long> a(n);\n    for (int i = 0; i < n; i++) cin >> a[i];\n    vector<vector<int>> e(n);\n    for (int i = 1; i < n; i++) {\n        int u, v; cin >> u >> v;\n        u--, v--;\n        e[u].emplace_back(v);\n        e[v].emplace_back(u);\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j <= n; j++) {\n            dp[i][j] = 1e16;\n        }\n    }\n    auto f = [&](auto f, int curr, int prev) -> void {\n        sz[curr] = 1; pos[curr][0] = (a[curr] > 0);\n        dp[curr][0] = a[curr];\n        for (auto &to: e[curr]) {\n            if (to == prev) continue;\n            f(f, to, curr);\n            sz[curr] += sz[to];\n            for (int i = sz[curr]; i >= 0; i--) {\n                for (int j = 0; j <= sz[to]; j++) {\n                    if (i >= j) {\n                        if (pos[to][j] || dp[to][j] < 0) {\n                            dp[curr][i+1] = min(dp[curr][i+1], dp[curr][i-j]);\n                            pos[curr][i+1] |= pos[curr][i-j];\n                        }\n                        pos[curr][i] |= pos[curr][i-j] & pos[to][j];\n                        if (j == 0) {\n                            dp[curr][i] = dp[curr][i-j] + dp[to][j];\n                            pos[curr][i] = pos[curr][i-j] & pos[to][j];\n                        } else {\n                            dp[curr][i] = min(dp[curr][i], dp[curr][i-j] + dp[to][j]);\n                            pos[curr][i] |= pos[curr][i-j] & pos[to][j];\n                        }\n                    }\n                }\n            }\n        }\n    };\n    f(f, 0, -1);\n    for (int i = 0; i < n; i++) {\n        if (dp[0][i] < 0 || pos[0][i]) {\n            cout << i << \"\\n\";\n            return 0;\n        }\n    }\n    assert(false);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define bp __builtin_popcountll\n#define pb push_back\n#define in(s) freopen(s, \"r\", stdin);\n#define out(s) freopen(s, \"w\", stdout);\n#define inout(s, end1, end2) freopen((string(s) + \".\" + end1).c_str(), \"r\", stdin),\\\n\t\tfreopen((string(s) + \".\" + end2).c_str(), \"w\", stdout);\n#define fi first\n#define se second\n#define bw(i, r, l) for (int i = r - 1; i >= l; i--)\n#define fw(i, l, r) for (int i = l; i < r; i++)\n#define fa(i, x) for (auto i: x)\nusing namespace std;\nconst int mod = 1e9 + 7, inf = 1061109567;\nconst long long infll = 4557430888798830399;\nconst int N = 5005;\nint n, a[N], sz[N], dp[N][N][2];\nvector<int> g[N];\nint solve(int u, int p) {\n\tif (a[u] > 0) dp[u][0][0] = a[u];\n\telse dp[u][0][1] = a[u];\n\t\n\tsz[u] = 1;\n\t\n\tfa (v, g[u]) if (v != p) {\n\t\tsolve(v, u);\n\t\tsz[u] += sz[v];\n\t\t\n\t\tbw (j, sz[u], 0) {\n\t\t\tint og0 = dp[u][j][0], og1 = dp[u][j][1];\n\t\t\tdp[u][j][0] = infll, dp[u][j][1] = infll;\n\t\t\tfw (k, max(0ll, sz[v] - sz[u] + j), min(j + 1, sz[v])) {\n\t\t\t\t//Cut edge i - v\n\t\t\t\tif (j - k >= 1) {\n\t\t\t\t\tif (dp[v][k][0] != infll || dp[v][k][1] < 0) {\n\t\t\t\t\t\tdp[u][j][0] = min(dp[u][j][0], dp[u][j - 1 - k][0]);\n\t\t\t\t\t\tdp[u][j][1] = min(dp[u][j][1], dp[u][j - 1 - k][1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//Keep edge i - v\n\t\t\t\tif (k > 0) {\n\t\t\t\t\tdp[u][j][0] = min(dp[u][j][0], dp[u][j - k][0] + dp[v][k][0]);\n\t\t\t\t\n\t\t\t\t\tdp[u][j][1] = min(dp[u][j][1], dp[u][j - k][1] + dp[v][k][1]);\n\t\t\t\t\tdp[u][j][1] = min(dp[u][j][1], dp[u][j - k][0] + dp[v][k][1]);\n\t\t\t\t\tdp[u][j][1] = min(dp[u][j][1], dp[u][j - k][1] + dp[v][k][0]);\n\t\t\t\t} else {\n\t\t\t\t\tdp[u][j][0] = min(dp[u][j][0], og0 + dp[v][k][0]);\n\t\t\t\t\n\t\t\t\t\tdp[u][j][1] = min(dp[u][j][1], og1 + dp[v][k][1]);\n\t\t\t\t\tdp[u][j][1] = min(dp[u][j][1], og0 + dp[v][k][1]);\n\t\t\t\t\tdp[u][j][1] = min(dp[u][j][1], og1 + dp[v][k][0]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n//\tfw (j, 0, sz[u]) fw (k, 0, 2) cout << \"dp[\" << u + 1 << \"][\" << j << \"][\" << k << \"] = \" << dp[u][j][k] << \"\\n\";\n}\nsigned main() {\n\t#ifdef BLU\n\tin(\"blu.inp\");\n\t#endif\n\tios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tcin >> n;\n\tfw (i, 0, n) cin >> a[i];\n\tfw (i, 1, n) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--, v--;\n\t\tg[u].pb(v), g[v].pb(u);\n\t}\n\tmemset(dp, 63, sizeof dp);\n\tsolve(0, -1);\n\tfw (k, 0, n) {\n\t\tif (dp[0][k][0] != infll || dp[0][k][1] < 0) {\n\t\t\tcout << k << \"\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst ll INF = 1e18;\n\n#define p_ary(ary,a,b,i) do { cout << \"[\"; for (int i = a;i < b;++i) cout << ary[i] << (b-1 == i ? \"]\\n\" : \", \"); } while(0)\n#define p_map(map,it) do {cout << \"{\";for (auto it = map.begin();;++it) {if (it == map.end()) {cout << \"}\\n\";break;}else cout << \"\" << it->first << \"=>\" << it->second << \", \";}}while(0)\n\nint n;\nvector<int> sz(5010,1);\nvector<ll> a(5010);\nvector<vector<int>> edges(5010);\nvector<vector<ll>> dp0(5010,vector<ll>(5010,INF)),dp1(5010,vector<ll>(5010,INF));\n\nvoid dfs(int u,int par = -1) {\n    (a[u] > 0 ? dp0 : dp1)[u][0] = a[u];\n    for (int& v : edges[u]) if (v != par) {\n        dfs(v,u);\n        vector<ll> temp0(5010,INF),temp1(5010,INF);\n        for (int i = 0;i < sz[u];++i) {\n            if (dp0[u][i] == INF) continue;\n            for (int j = 0;j < sz[v];++j) {\n                if (dp0[v][j] == INF) continue;\n                temp0[i+j] = min(temp0[i+j],dp0[u][i]+dp0[v][j]);\n                temp0[i+j+1] = min(temp0[i+j+1],dp0[u][i]);\n            }\n            for (int j = 0;j < sz[v];++j) {\n                if (dp1[v][j] == INF) continue;\n                temp1[i+j] = min(temp1[i+j],dp0[u][i]+dp1[v][j]);\n                if (dp1[v][j] < 0) temp0[i+j+1] = min(temp0[i+j+1],dp0[u][i]);\n\n            }\n        }\n        for (int i = 0;i < sz[u];++i) {\n            if (dp1[u][i] == INF) continue;\n            for (int j = 0;j < sz[v];++j) {\n                if (dp0[v][j] == INF) continue;\n                temp1[i+j] = min(temp1[i+j],dp1[u][i]+dp0[v][j]);\n                temp1[i+j+1] = min(temp1[i+j+1],dp1[u][i]);\n            }\n            for (int j = 0;j < sz[v];++j) {\n                if (dp1[v][j] == INF) continue;\n                temp1[i+j] = min(temp1[i+j],dp1[u][i]+dp1[v][j]);\n                if (dp1[v][j] < 0) temp1[i+j+1] = min(temp1[i+j+1],dp1[u][i]);\n            }\n        }\n        dp0[u] = temp0;\n        dp1[u] = temp1;\n        sz[u] += sz[v];\n    }\n}\n\nint main() {\n    cin >> n;\n    for (int i = 0;i < n;++i) cin >> a[i];\n    for (int i = 0;i < n-1;++i) {\n        int u,v;\n        cin >> u >> v;\n        u--;v--;\n        edges[u].push_back(v);\n        edges[v].push_back(u);\n    }\n    dfs(0);\n    int ans = n;\n    for (int i = 0;i < n;++i) if (dp0[0][i] < INF) {\n        ans = i;\n        break;\n    }\n    for (int i = 0;i < n;++i) if (dp1[0][i] < INF && dp1[0][i] < 0) {\n        ans = min(ans,i);\n        break;\n    }\n    cout << ans << endl;\n    // for (int i = 0;i < n;++i) p_ary(dp0[i],0,n,j);\n    // cout << endl;\n    // for (int i = 0;i < n;++i) p_ary(dp1[i],0,n,j);\n    // cout << endl;\n    // p_ary(sz,0,n,i);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//https://atcoder.jp/contests/aising2019/tasks/aising2019_e\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n#ifdef BTK\n#define DEBUG if(1)\n#else\n#define CIN_ONLY if(1)\nstruct cww {cww() {CIN_ONLY{ios::sync_with_stdio(false); cin.tie(0);}}}star;\n#define DEBUG if(0)\n#endif\n#define ALL(v) (v).begin(),(v).end()\n#define REC(ret, ...) std::function<ret (__VA_ARGS__)>\ntemplate <typename T>inline bool chmin(T &l, T r){bool a = l>r; if (a)l = r; return a;}\ntemplate <typename T>inline bool chmax(T &l, T r){bool a = l<r; if (a)l = r; return a;}\ntemplate <typename T>istream& operator>>(istream &is, vector<T> &v){for (auto &it : v)is >> it;return is;}\nclass range {private: struct I { int x; int operator*() { return x; }bool operator!=(I& lhs) { return x<lhs.x; }void operator++() { ++x; } }; I i, n;public:range(int n) :i({ 0 }), n({ n }) {}range(int i, int n) :i({ i }), n({ n }) {}I& begin() { return i; }I& end() { return n; }};\n\nint N;\nLL A[5123];\nvector<int> g[5123];\nvector<int> t[5123];\nLL allB[5123][5123];\nLL dp[5123][5123];\nLL tmp[5123];\nint sub[5123];\nvoid dfs(int v,int p){\n    sub[v]=1;\n    for(int u:g[v]){\n        if(u==p)continue;\n        t[v].push_back(u);\n        dfs(u,v);\n        sub[v]+=sub[u];\n    }\n}\nvoid solve(int v){\n    for(int u:t[v]){\n        solve(u);\n    }\n    int x=1;\n    if(A[v]>0){\n        allB[v][0]=1;\n    }\n    else{\n        allB[v][0]=0;\n    }\n    dp[v][0]=A[v];\n    for(int u:t[v]){\n        const int nx=x+sub[u];\n        for(int i:range(nx+1)){\n            tmp[i]=0;\n        }\n        for(int i:range(x))for(int j:range(sub[u]+1)){\n            tmp[i+j]|=(allB[v][i]&allB[u][j]);\n        }\n        for(int i:range(nx+1)){\n            allB[v][i]=tmp[i];\n            tmp[i]=1e18;\n        }\n        for(int i:range(x))for(int j:range(sub[u]+1)){\n            chmin(tmp[i+j],dp[v][i]+dp[u][j]);\n        }\n        for(int i:range(nx+1)){\n            dp[v][i]=tmp[i];\n        }\n        x+=nx;\n    }\n    for(int i:range(x)){\n        if(allB[v][i]||dp[v][i]<0){\n            chmin(dp[v][i+1],0ll);\n            allB[v][i+1]=1;\n        }\n    }\n}\nint main(){\n    cin>>N;\n    for(int i:range(N)){\n        cin>>A[i+1];\n    }\n    for(int i:range(N-1)){\n        int u,v;\n        cin>>u>>v;\n        g[v].push_back(u);\n        g[u].push_back(v);\n    }\n    dfs(1,1);\n    return 0;\n    solve(1);\n    int ret=N-1;\n    for(int i:range(N+1)){\n        if(allB[1][i])chmin(ret,i);\n        if(dp[1][i]<0)chmin(ret,i);\n    }\n    cout<<ret<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\ntemplate <typename X, typename Y> void Max(X &x, Y y) {\n  x = (x > y) ? x : y;\n}\ntemplate <typename X, typename Y> void Min(X &x, Y y) {\n  x = (x < y) ? x : y;\n}\n\nconst int N = 5005;\nint n, a[N], f[N][N][2], h[N][2], sz[N];\nvector <int> ad[N];\n\nvoid dfs(int u, int p) {\n  sz[u] = 1;\n  f[u][0][0] = (a[u] < 0) ? 1e18 : a[u];\n  f[u][0][1] = (a[u] > 0) ? 1e18 : a[u];\n  for(auto &v : ad[u]) {\n    if(v != p) {\n      dfs(v, u);\n      for(int i = 0; i < sz[u] + sz[v]; ++i) h[i][0] = h[i][1] = 1e18;\n      for(int i = 0; i < sz[u]; ++i) {\n        for(int j = 0; j < sz[v]; ++j) {\n          int tot = i + j;\n          Min(h[tot][0], f[u][i][0] + f[v][j][0]);\n          Min(h[tot][0], f[u][i][0] + f[v][j][1]);\n          Min(h[tot][1], f[u][i][1] + f[v][j][0]);\n          Min(h[tot][1], f[u][i][1] + f[v][j][1]);\n          if(f[v][j][0] < 1e18 || f[v][j][1] < 0) {\n            Min(h[tot + 1][0], f[u][i][0]);\n            Min(h[tot + 1][1], f[u][i][1]);\n          }\n        }\n      }\n      sz[u] += sz[v];\n      for(int i = 0; i < sz[u]; ++i) {\n        f[u][i][0] = h[i][0]; f[u][i][1] = h[i][1];\n      }\n    }\n  }\n}\n\nmain() {\n  ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n  cin >> n;\n  for(int i = 1; i <= n; ++i) cin >> a[i];\n  for(int i = 1; i < n; ++i) {\n    int u, v;\n    cin >> u >> v;\n    ad[u].push_back(v);\n    ad[v].push_back(u);\n  }\n  dfs(1, -1);\n  for(int i = 0; i < n; ++i) {\n    if(f[1][i][0] < 1e18 || f[1][i][1] < 0) {\n      cout << i;\n      return 0;\n    }\n  }\n}\n/*\n6\n10 -1 10 -1 10 -1\n1 2\n2 3\n3 4\n4 5\n5 6\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define oo ll(1e14)\n#define maxn 5003\n\nusing namespace std;\ntypedef long long ll;\n\nint n;\n\nint a[maxn];\n\nll dp[maxn][maxn][2];\nint sz[maxn];\n\nvector < int > g[maxn];\n\nvoid dfs(int u, int du) {\n  if (a[u] >= 0)\n    dp[u][1][1] = 1;\n  dp[u][1][0] = a[u];\n  sz[u] = 1;\n\n  for (auto v : g[u]) {\n    if (v == du) continue;\n\n    dfs(v, u);\n    sz[u] += sz[v];\n\n    for (int j = sz[u]; j > 0; --j) {\n      bool flag = 0;\n      ll mi = oo;\n\n      for (int k = max(1, j - sz[u] + sz[v]); k <= j && k <= sz[v]; ++k) {\n        flag |= (dp[u][j - k + 1][1] & dp[v][k][1]);\n        mi = min(mi, dp[u][j - k + 1][0] + dp[v][k][0]);\n\n        if (dp[v][k][0] < 0 || dp[v][k][1]) {\n          mi = min(mi, dp[u][j - k][0]);\n          flag |= dp[u][j - k][1];\n        }\n      }\n\n      dp[u][j][1] = flag;\n      dp[u][j][0] = mi;\n    }\n  }\n\n  return;\n}\n\nint main(){\n  ios_base::sync_with_stdio(0);\n\n  cin >> n;\n\n  for (int i = 1; i <= n; ++i)\n    cin >> a[i];\n\n  for (int i = 1; i < n; ++i) {\n    int u, v;\n    cin >> u >> v;\n\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n\n  for (int i = 1; i <= n; ++i)\n    for (int j = 0; j <= n; ++j) {\n      dp[i][j][0] = oo;\n      dp[i][j][1] = 0;\n    }\n\n  dfs(1, 1);\n\n  for (int j = 1; j <= n; ++j)\n    if (dp[1][j][0] < 0 || dp[1][j][1]) {\n      cout << j - 1;\n      break;\n    }\n  return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\ntypedef unsigned long long ul;\nint n;\nll a[5000];\nvector<int> G[5000];\nbool used[5000];\nvector<ll> x[5000];\nint mi[5000];\n\nvoid dfs(int id) {\n\tused[id] = true;\n\tx[id].push_back({ a[id] });\n\tif (a[id] > 0)mi[id] = 0;\n\telse mi[id] = 10000;\n\trep(j, G[id].size()) {\n\t\tint to = G[id][j];\n\t\tif (used[to])continue;\n\t\tdfs(to);\n\t\tint len = x[to].size();\n\t\tint add = mi[to];\n\t\tvector<ll> nex; nex.resize(len + x[id].size(),INF);\n\t\trep(k, len) {\n\t\t\tif (x[to][k] < 0) {\n\t\t\t\tadd = min(add, k + 1);\n\t\t\t\trep(l, x[id].size()) {\n\t\t\t\t\tnex[k+l + 1] = min(nex[k+l + 1], x[id][l]);\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(l, x[id].size()) {\n\t\t\t\tnex[k + l] = min(nex[k + l], x[to][k] + x[id][l]);\n\t\t\t}\n\t\t}\n\t\tif (mi[to] < 10000) {\n\t\t\trep(l, x[id].size()) {\n\t\t\t\tnex[l + mi[to]+1] = min(nex[l + mi[to]+1], x[id][l]);\n\t\t\t}\n\t\t}\n\t\tx[id] = nex;\n\t\tmi[id] += add;\n\t}\n}\n\nint main() {\n\tcin >> n;\n\trep(i, n)cin >> a[i];\n\trep(i, n - 1) {\n\t\tint u, v; cin >> u >> v; u--; v--;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tdfs(0);\n\tint ans = mi[0];\n\trep(i, x[0].size()) {\n\t\tif (x[0][i] < 0) {\n\t\t\tans = min(ans, i);\n\t\t}\n\t}\n\tcout << ans << endl;\n\t//stop\n\t\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n \nlong long N, A[5009], U[5009], V[5009], dp[5009][5009][2], dp2[5009][5009][2], VV[5009];\nvector<int>X[5009]; bool used[5009];\n \nvoid dfs2(int pos) {\n\tVV[pos] += 1;\n\tfor (int i = 0; i < X[pos].size(); i++) {\n\t\tif (VV[X[pos][i]] >= 1) continue;\n\t\tdfs2(X[pos][i]);\n\t\tVV[pos] += VV[X[pos][i]];\n\t}\n}\n \nvoid dfs(int pos) {\n\tused[pos] = true; vector<int>Y;\n\tfor (int i = 0; i < X[pos].size(); i++) {\n\t\tif (used[X[pos][i]] == true) continue;\n\t\tdfs(X[pos][i]);\n\t\tY.push_back(X[pos][i]);\n\t}\n \n\tfor (int i = 0; i <= Y.size(); i++) { for (int j = 0; j <= VV[pos]; j++) { dp2[i][j][0] = (1LL << 60); dp2[i][j][1] = (1LL << 60); } }\n\tif (A[pos] >= 1) dp2[0][0][0] =dp2[0][0][1]= A[pos]; else dp2[0][0][1] = A[pos];\n \n\tint S = 0;\n\tfor (int i = 0; i < Y.size(); i++) {\n\t\tfor (int j = 0; j <= S; j++) {\n\t\t\tif (dp2[i][j][0] != (1LL << 60)) {\n\t\t\t\tfor (int l = 0; l <= VV[Y[i]]; l++) {\n\t\t\t\t\tdp2[i + 1][j + l][0] = min(dp2[i + 1][j + l][0], dp2[i][j][0] + dp[Y[i]][l][0]);\n\t\t\t\t\tdp2[i + 1][j + l][1] = min(dp2[i + 1][j + l][1], dp2[i][j][0] + dp[Y[i]][l][1]);\n\t\t\t\t\tif (dp[Y[i]][l][0] < (1LL << 58) || dp[Y[i]][l][1] < 0) {\n\t\t\t\t\t\tdp2[i + 1][j + l + 1][0] = min(dp2[i + 1][j + l + 1][0], dp2[i][j][0]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dp2[i][j][1] != (1LL << 60)) {\n\t\t\t\tfor (int l = 0; l <= VV[Y[i]]; l++) {\n\t\t\t\t\tdp2[i + 1][j + l][1] = min(dp2[i + 1][j + l][1], dp2[i][j][1] + dp[Y[i]][l][0]);\n\t\t\t\t\tdp2[i + 1][j + l][1] = min(dp2[i + 1][j + l][1], dp2[i][j][1] + dp[Y[i]][l][1]);\n\t\t\t\t\tif (dp[Y[i]][l][0] < (1LL << 58) || dp[Y[i]][l][1] < 0) {\n\t\t\t\t\t\tdp2[i + 1][j + l + 1][1] = min(dp2[i + 1][j + l + 1][1], dp2[i][j][1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tS += VV[Y[i]];\n\t}\n\tfor (int i = 0; i <= VV[pos]; i++) {\n\t\tdp[pos][i][0] = dp2[Y.size()][i][0];\n\t\tdp[pos][i][1] = dp2[Y.size()][i][1];\n\t}\n}\n \nint main() {\n\tcin >> N;\n\tfor (int i = 1; i <= N; i++) cin >> A[i];\n\tfor (int i = 1; i <= N - 1; i++) {\n\t\tcin >> U[i] >> V[i];\n\t\tX[U[i]].push_back(V[i]);\n\t\tX[V[i]].push_back(U[i]);\n\t}\n\tdfs2(1);\n\tfor (int i = 1; i <= N; i++) { for (int j = 0; j <= N; j++) { dp[i][j][0] = (1LL << 60); dp[i][j][1] = (1LL << 60); } }\n\tdfs(1);\n \n\tint maxn = (1 << 30);\n\tfor (int i = 0; i <= N; i++) {\n\t\tif (dp[1][i][0] < (1LL << 58) || dp[1][i][1] < 0) { maxn = min(maxn, i); }\n\t}\n\tcout << maxn << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n\ntypedef long long ll;\n#define int ll\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = 1e18;\nconst ll MOD = 1000000007;\n//const ll MOD = 998244353;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { 1,0, -1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n//#define mp make_pair\n\nconst int N = 5010;\nvll dp1(N, vl(N, INF));\nvl dp2(N, INF);\nvii G(N);\nvl a(N);\nvl sum(N);\nvi fu(N);\nint n;\n\nvoid dfs_pre(int now, int par) {\n  if (a[now] < 0) fu[now]++;\n  sum[now] = a[now];\n  rep (i, G[now].size()) {\n    if (G[now][i] == par) continue;\n    int v = G[now][i];\n    dfs_pre(v, now);\n    sum[now] += sum[v];\n    fu[now] += fu[v];\n  }\n}\n\nvoid dfs(int now, int par) {\n  int m;\n  if (par == -1) {\n    m = G[now].size();\n  }\n  else {\n    m = G[now].size() - 1;\n  }\n  if (m == 0) {\n    if (a[now] > 0) {\n      dp2[now] = 0;\n    }\n    else {\n      dp2[now] = INF;\n    }\n    dp1[now][0] = a[now];\n    return;\n  }\n  vll dp(m + 1, vl(n, INF));\n  dp[0][0] = a[now];\n  int i = 0;\n  if (a[now] > 0) dp2[now] = 0;\n  rep (aaa, G[now].size()) {\n    if (G[now][aaa] == par) continue;\n    int v = G[now][aaa];\n    dfs(v, now);\n    rep (j, n) {\n      if (dp[i][j] >= INF / 2) break;\n      rep (k, n) {\n        if (dp1[v][k] >= INF / 2) break;\n        dp[i + 1][j + k] = min(dp[i + 1][j + k], dp[i][j] + dp1[v][k]);\n        if (dp1[v][k] < 0) {\n          dp[i + 1][j + 1 + k] = min(dp[i + 1][j + 1 + k], dp[i][j]);\n        }\n      }\n      if (dp2[v] < INF / 2) {\n        dp[i + 1][j + 1 + dp2[v]] = min(dp[i + 1][j + 1 + dp2[v]], dp[i][j]);\n      }\n    }\n    if (a[now] > 0) {\n      ll add = dp2[v];\n      rep (j, n) {\n        if (dp1[v][j] < 0) {\n          add = min(add, j + 1);\n          break;\n        }\n      }\n      dp2[now] += add;\n    }\n    i++;\n  }\n  rep (i, n) {\n    dp1[now][i] = dp[m][i];\n  }\n  if (a[now] < 0) dp2[now] = INF;\n}\n\nsigned main() {\n  cin >> n;\n  rep (i, n) {\n    cin >> a[i];\n  }\n  rep (i, n - 1) {\n    int u, v;\n    cin >> u >> v;\n    u--; v--;\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  dfs_pre(0, -1);\n  dfs(0, -1);\n  ll ans = INF;\n  rep (i, n) {\n    if (dp1[0][i] < 0) {\n      ans = i;\n      break;\n    }\n  }\n  ans = min(ans, dp2[0]);\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 5123;\nconst long long inf = 1ll<<60;\nlong long f[2][maxn][maxn], tmp[2][maxn];\nlong long a[maxn];\nvector<int> e[maxn];\nint sz[maxn];\nvoid solve(int u, int v){\n\tf[0][u][0] = a[u] > 0 ? a[u] : inf;\n\tf[1][u][0] = a[u];\n\tsz[u] = 1;\n\tfor(int to : e[u]) if(to != v) {\n\t\tsolve(to, u);\n\t\tfor(int i = 0; i < sz[u] + sz[to]; i++) tmp[0][i] = tmp[1][i] = inf;\n\t\tfor(int pci = 0; pci <= 1; pci++){\n\t\t\tfor(int i = 0; i < sz[u]; i++){\n\t\t\t\tfor(int pcj = 0; pcj <= 1; pcj++){\n\t\t\t\t\tfor(int j = 0; j < sz[to]; j++){\n\t\t\t\t\t\tint pcn = pci | pcj;\n\t\t\t\t\t\tlong long comb = f[pci][u][i] + f[pcj][to][j];\n\t\t\t\t\t\tif(pcn){\n\t\t\t\t\t\t\ttmp[pcn][i + j] = min(tmp[pcn][i + j], comb);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmp[pcn][i + j] = min(tmp[pcn][i + j], comb);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlong long cut = f[pci][u][i];\n\t\t\t\t\t\tif(pcj && f[pcj][to][j] >= 0) cut = inf;\n\t\t\t\t\t\tif(!pcj && f[pcj][to][j] == inf) cut = inf;\n\t\t\t\t\t\ttmp[pci][i+j+1] = min(tmp[pci][i+j+1], cut);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsz[u] += sz[to];\n\t\tfor(int i = 0; i < sz[u]; i++) f[0][u][i] = tmp[0][i];\n\t\tfor(int i = 0; i < sz[u]; i++) f[1][u][i] = tmp[1][i];\n\t}\n}\t\nint main(){\n\tint n; cin >> n;\n\tfor(int i = 1; i <= n; i++) cin >> a[i];\n\tfor(int i = 0; i < n - 1; i++){\n\t\tint u, v; cin >> u >> v;\n\t\te[u].push_back(v);\n\t\te[v].push_back(u);\n\t}\n\tsolve(1, 0);\n\tint ans = n - 1;\n\tfor(int i = n - 1; i >= 0; i--) if(f[0][1][i] < inf || f[1][1][i] < 0) ans = i;\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n    *Makacha\n**/\n#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <typename T> inline void read (T &x) {bool b = 0; char c; while (!isdigit (c = getchar()) && c != '-');\nif (c == '-') c = getchar(), b = 1; x = c - 48; while (isdigit(c = getchar())) x = (x<<3) + (x<<1) + c - 48; if (b)x=-x;}\ntemplate <typename T> inline void wrip(T x) {if (x > 9) wrip(x / 10); putchar(x%10 + 48); }\n\ntemplate <typename T> inline void write(T x) {if (x < 0) putchar('-'), x = -x; wrip(x); putchar(' ');}\ntemplate <typename T> inline void writeln(T x) {if (x < 0) putchar('-'), x = -x; wrip(x); putchar('\\n');}\ninline char readch() {char c; do c = getchar(); while (c == '\\n' || c == ' '); return c;}\ninline void reads(string &s) {char c; while((c=getchar())==' '||c =='\\n'); s=c; while((c=getchar())!=' '&&c!='\\n') s+=c;}\ninline void getlines(string &s) {char c; while((c=getchar())=='\\n'); s=c; while((c=getchar())!='\\n') s+=c;}\ntypedef const int csint;\n\n#define fi first\n#define se second\n#define mp make_pair\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> ii;\ntypedef vector <int> vi;\n\nconst ld pi = acos(-1);\nconst ll inf = 1e16;\nconst int mod = 1e9 + 7,\nN = 5011;\n\nint n, a[N], num[N];\nll f[N][N][2];\nvi ke[N];\nvoid Dfs(int u, int p) {\n    num[u] = 1;\n    f[u][0][0] = f[u][0][1] = a[u];\n    if (a[u] < 0)\n        f[u][0][0] = inf;\n    for (auto v: ke[u]) {\n        if (v == p)\n            continue;\n        Dfs(v, u);\n        num[u] += num[v];\n        for (int i = num[u] - 1; i >= 0; i--) {\n            f[u][i][1] += f[v][0][1];\n            f[u][i][0] += f[v][0][0];\n            int lim = min(i, num[v] - 1);\n            for (int j = 1, k = i - 1; j <= lim; j++, k--) {\n                f[u][i][1] = min(f[u][i][1], f[u][k][1] + f[v][j][1]);\n                f[u][i][0] = min(f[u][i][0], f[u][k][0] + f[v][j][0]);\n            }\n            for (int j = 0, k = i - 1; k >= 0; j++, k--) {\n                if (f[v][j][1] < 0)\n                    f[u][i][1] = min(f[u][i][1], f[u][k][1]),\n                    f[u][i][0] = min(f[u][i][0], f[u][k][0]);\n                if (f[v][j][0] < inf)\n                    f[u][i][1] = min(f[u][i][1], f[u][k][1]),\n                    f[u][i][0] = min(f[u][i][0], f[u][k][0]);\n            }\n            f[u][i][1] = min(f[u][i][0], f[u][i][1]);\n        }\n    }\n}\nint main() {\n    #ifdef makacha\n        //Test();\n        freopen(\"m.inp\", \"r\", stdin);\n        freopen(\"m.out\", \"w\", stdout);\n    #endif // makacha\n    read(n);\n    for (int i = 1; i <= n; i++)\n        read(a[i]);\n    for (int i = 1, u, v; i < n; i++) {\n        read(u);\n        read(v);\n        ke[u].push_back(v);\n        ke[v].push_back(u);\n    }\n    for (int i = 1; i <= n; i++)\n        for (int j = 0; j <= n; j++)\n            f[i][j][0] = f[i][j][1] = inf;\n    Dfs(1, 1);\n    for (int i = 0; i < n; i++)\n        if (f[1][i][1] < 0 || f[1][i][0] < inf)\n            return cout << i, 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nvector <int> g[5555];\nlong long dp[5005][5005];\nlong long fn[5005][5005];\nbool gn[5005][5005];\nbool pos[5005][5005];\n\nint sub[5555];\nint a[5555];\n\nconst long long inf = 1e15;\n\nvoid dfs(int x, int par) {\n\tsub[x] = 1;\n\tfor(auto i : g[x]) {\n\t\tif(i - par) {\n\t\t\tdfs(i, x);\n\t\t\tsub[x] += sub[i];\n\t\t}\n\t}\n\tvector <int> c;\n\tint deg = 0;\n\tfor(auto i : g[x]) {\n\t\tif(i - par) {\n\t\t\tc.emplace_back(i);\n\t\t\t++deg;\n\t\t}\n\t}\n\tfor(int i = 1; i <= deg; i++) {\n\t\tfor(int j = 0; j <= sub[x]; j++) {\n\t\t\tfn[i][j] = inf;\n\t\t\tgn[i][j] = false;\n\t\t}\n\t}\n\tfor(int j = 0; j <= sub[x]; j++) {\n\t\tgn[0][j] = (a[x] > 0);\n\t}\n\tint tot = 0;\n\tfor(int i = 1; i <= deg; i++) {\n\t\tint node = c[i - 1];\n\t\tfor(int j = 0; j <= tot; j++) {\n\t\t\tfor(int k = 0; k <= sub[node]; k++) {\n\t\t\t\tif(dp[node][k] < 0 || pos[node][k]) {\n\t\t\t\t\tfn[i][j + k + 1] = min(fn[i][j + k], fn[i - 1][j]);\n\t\t\t\t}\n\t\t\t\tfn[i][j + k] = min(fn[i][j + k], fn[i - 1][j] + dp[node][k]);\n\t\t\t}\n\t\t\tfor(int k = 0; k <= sub[node]; k++) {\n\t\t\t\tif(dp[node][k] < 0 || pos[node][k]) {\n\t\t\t\t\tgn[i][j + k + 1] |= gn[i - 1][j];\n\t\t\t\t}\n\t\t\t\tgn[i][j + k] |= gn[i - 1][j] & pos[node][k];\n\t\t\t}\n\t\t}\n\t\ttot += sub[node];\n\t}\n\tfor(int i = 0; i <= tot; i++) {\t\n\t\tdp[x][i] = a[x] + fn[deg][i];\n\t\tpos[x][i] = gn[deg][i];\n\t}\n}\nint main(int argc, char const *argv[])\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tfor(int i = 1; i < n; i++) {\n\t\tint p, q;\n\t\tscanf(\"%d %d\", &p, &q);\n\t\tg[p].emplace_back(q);\n\t\tg[q].emplace_back(p);\n\t}\n\tfor(int i = 0; i <= n; i++) {\n\t\tfor(int j = 0; j <= n; j++) {\n\t\t\tdp[i][j] = inf;\n\t\t}\n\t}\n\tdfs(1, 0);\n\tint ans = -1;\n\tfor(int i = n; i >= 0; i--) {\n\t\tif(dp[1][i] < 0 || pos[1][i]) {\n\t\t\tans = i;\n\t\t}\n\t}\n\tassert(ans > 0);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n//#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　  |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\n\n\n\n\nint N, A[5010];\nvector<int> E[5010];\n//---------------------------------------------------------------------------------------------------\nvector<pair<ll, int>> dp[5010];\nint sz[5010];\nvoid marge(int cu, int to) {\n    vector<pair<ll, int>> res(sz[cu] + sz[to] + 1, { infl,0 });\n    rep(cui, 0, sz[cu]) rep(toi, 0, sz[to]) {\n        // くっつける\n        chmin(res[cui + toi].first, dp[cu][cui].first + dp[to][toi].first);\n        if (dp[cu][cui].second and dp[to][toi].second) res[cui + toi].second = 1;\n\n        // くっつけない\n        if (dp[to][toi].first < 0 or dp[to][toi].second) chmin(res[cui + toi + 1].first, dp[cu][cui].first);\n        if ((dp[to][toi].first < 0 or dp[to][toi].second) and dp[cu][cui].second) res[cui + toi + 1].second = 1;\n    }\n    swap(dp[cu], res);\n    sz[cu] += sz[to] + 1;\n}\n//---------------------------------------------------------------------------------------------------\nvoid dfs(int cu, int pa = -1) {\n    sz[cu] = 1;\n    dp[cu].resize(1);\n    dp[cu][0] = { A[cu], 0 < A[cu] };\n    fore(to, E[cu]) if (to != pa) {\n        dfs(to, cu);\n        marge(cu, to);\n    }\n}\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> N;\n    rep(i, 0, N) cin >> A[i];\n    rep(i, 0, N - 1) {\n        int a, b; cin >> a >> b;\n        a--; b--;\n        E[a].push_back(b);\n        E[b].push_back(a);\n    }\n\n    dfs(0);\n    int ans = inf;\n    rep(i, 0, sz[0]) if (dp[0][i].first < 0 or dp[0][i].second) chmin(ans, i);\n    cout << ans << endl;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint A[5050];\nvector<int> E[5050];\nll dp[5060][5060][2];\nint C[5050];\n\nvoid dfs(int cur,int pre) {\n\tC[cur]=1;\n\tif(A[cur]>0) {\n\t\tdp[cur][0][1]=A[cur];\n\t}\n\telse {\n\t\tdp[cur][0][0]=A[cur];\n\t}\n\t\n\tFORR(e,E[cur]) if(e!=pre) {\n\t\tdfs(e,cur);\n\t\tll to[5050][2];\n\t\t\n\t\tint x,y;\n\t\tFOR(x,5050) to[x][0]=to[x][1]=1LL<<60;\n\t\tfor(x=0;x<=C[cur]-1;x++) {\n\t\t\tfor(y=0;y<=C[e]-1;y++) {\n\t\t\t\t\n\t\t\t\tif(dp[e][y][0]<0 || dp[e][y][1]<1LL<<60) {\n\t\t\t\t\tto[x+y+1][0]=min(to[x+y+1][0],dp[cur][x][0]);\n\t\t\t\t\tto[x+y+1][1]=min(to[x+y+1][1],dp[cur][x][1]);\n\t\t\t\t}\n\t\t\t\tto[x+y][1]=min(to[x+y][1],dp[cur][x][1]+dp[e][y][1]);\n\t\t\t\tto[x+y][0]=min(to[x+y][0],dp[cur][x][0]+dp[e][y][1]);\n\t\t\t\tto[x+y][0]=min(to[x+y][0],dp[cur][x][1]+dp[e][y][0]);\n\t\t\t\tto[x+y][0]=min(to[x+y][0],dp[cur][x][0]+dp[e][y][0]);\n\t\t\t}\n\t\t}\n\t\tFOR(x,5050) {\n\t\t\tdp[cur][x][0]=to[x][0];\n\t\t\tdp[cur][x][1]=to[x][1];\n\t\t}\n\t\tC[cur]+=C[e];\n\t}\n\t\n\t\n\t\n}\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(x,5050) FOR(y,5050) dp[x][y][0]=dp[x][y][1]=1LL<<60;\n\t\n\tFOR(i,N-1) {\n\t\tcin>>x>>y;\n\t\tE[x-1].push_back(y-1);\n\t\tE[y-1].push_back(x-1);\n\t}\n\t\n\tdfs(0,-1);\n\tfor(i=0;i<=5050;i++) {\n\t\tif(dp[0][i][0]<0) return _P(\"%d\\n\",i);\n\t\tif(dp[0][i][1]<1LL<<60) return _P(\"%d\\n\",i);\n\t}\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <typeinfo>\n#include <numeric>\n#include <functional>\n#include <unordered_map>\n#include <bitset>\n#include <stack>\n\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nconst ll INF = 1e16;\nconst ll MOD = 1e9 + 7;\n\n#define REP(i, n) for(ll i = 0; i < n; i++)\n\n\n\n\n\n\nvector<int> num;\nvector<ll> a;\nvector<vector<int>> g;\nvector<vector<ll>> sdp;\nvector<vector<vector<ll>>> dp;\n\n\nvoid rec(ll v, ll par){\n    num[v] = 1;\n    for(auto &child : g[v]){\n        if(child == par) continue;\n        rec(child, v);\n        num[v] += num[child];\n    }\n    \n    for(int i = 0; i <= num[v]; i++){\n        sdp[i][0] = sdp[i][1] = INF;\n    }\n    \n    sdp[0][0] = a[v];\n    if(a[v] > 0){\n        sdp[0][1] = a[v];\n    }\n    \n    int curnum = 0;\n    for(auto &child : g[v]){\n        if(child == par) continue;\n        for(int i = curnum; i >= 0; i--){\n            ll tmp0 = sdp[i][0], tmp1 = sdp[i][1];\n            sdp[i][0] = sdp[i][1] = INF;\n            for(int j = 0; j <= num[child]; j++){\n                sdp[i + j][0] = min(sdp[i + j][0], tmp0 + dp[child][j][0]);\n                if(dp[child][j][0] < 0 || dp[child][j][1] < INF / 2){\n                    sdp[i + j + 1][0] = min(sdp[i + j + 1][0], tmp0);\n                }\n                if(a[v] > 0){\n                    sdp[i + j][1] = min(sdp[i + j][1], tmp1 + dp[child][j][1]);\n                    if(dp[child][j][0] < 0 || dp[child][j][1] < INF / 2){\n                        sdp[i + j + 1][1] = min(sdp[i + j + 1][1], tmp1);\n                    }\n                }\n            }\n        }\n        curnum += num[child];\n    }\n    for(int i = 0; i <= num[v]; i++){\n        dp[v][i][0] = sdp[i][0];\n        dp[v][i][1] = sdp[i][1];\n    }\n}\n\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    a.resize(n);\n    for(int i = 0; i < n; i++){\n        scanf(\"%lld\", &a[i]);\n    }\n    g.resize(n);\n    for(int i = 0; i < n - 1; i++){\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        u--; v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    \n    num.resize(n);\n    sdp.resize(n + 1, vector<ll>(2));\n    dp.assign(n + 1, vector<vector<ll>>(n + 1, vector<ll>(2, INF)));\n    rec(0, -1);\n    int ans = n;\n    for(int i = 0; i <= n; i++){\n        if(dp[0][i][0] < 0){\n            ans = min(ans, i);\n        }\n        if(dp[0][i][1] < INF / 2){\n            ans = min(ans, i);\n        }\n    }\n    printf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst ll inf=1e18; \nconst int MAXN=5e3+10;\nll a[MAXN];\nint n,x,y;\nvector<ll>dp1[MAXN],dp0[MAXN],e[MAXN];\nvoid pr(int x)\n{\n\tcout << x << endl;\n\texit(0);\n}\nvoid merge(int now,int u){\n\tvector<ll>q1,q0;\n\tfor (int i=0;i<dp1[now].size()+dp1[u].size();i++) \n\t{\n\t\tq1.push_back(inf); q0.push_back(-1);\n\t}\n\tfor (int i=0;i<dp1[now].size();i++) {\n\t\tfor (int j=0;j<dp1[u].size();j++) {\n                   q1[i+j]=min(q1[i+j],dp1[now][i]+dp1[u][j]);\n                   if (dp1[u][j]<0||dp0[u][j]==1) q1[i+j+1]=min(q1[i+j+1],dp1[now][i]);\n                   if (dp0[u][j]!=-1&&dp0[now][i]!=-1) q0[i+j]=1;\n                   if (dp1[u][j]<0||dp0[u][j]==1) if (dp0[now][i]!=-1) q0[i+j+1]=1;\n\t\t}\n\t}\n\tdp1[now]=q1; dp0[now]=q0;\n}\nvoid dfs(int now,int fa)\n{ \n\tdp1[now].push_back(a[now]);\n\tdp0[now].push_back(a[now]>0?1:-1);\n\tfor (int i=0;i<e[now].size();i++) {\n\t\tint u=e[now][i];\n\t\tif (u==fa) continue;\n\t\tdfs(u,now);\n\t\tmerge(now,u);\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) scanf(\"%lld\",&a[i]);\n\t\tfor (int i=1;i<n;i++) {\n\t\t\tscanf(\"%d%d\",&x,&y); e[x].push_back(y); e[y].push_back(x);\n\t\t}\n\tdfs(1,0);\n\t// cout << dp0[1][1] << endl;\n\tfor (int i=0;i<=n;i++)\n\t {\n\t \tif (dp0[1][i]>0) pr(i);\n\t \tif (dp1[1][i]<0) pr(i);\n\t } \n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nvector <int> g[5555];\nlong long dp[5005][5005];\nlong long fn[5005][5005];\nbool gn[5005][5005];\nbool pos[5005][5005];\n\nint sub[5555];\nint a[5555];\nint n;\n\nconst long long inf = 1e15;\n\nvoid dfs(int x, int par) {\n\tsub[x] = 1;\n\tfor(auto i : g[x]) {\n\t\tif(i - par) {\n\t\t\tdfs(i, x);\n\t\t\tsub[x] += sub[i];\n\t\t}\n\t}\n\tvector <int> c;\n\tint deg = 0;\n\tfor(auto i : g[x]) {\n\t\tif(i - par) {\n\t\t\tc.emplace_back(i);\n\t\t\t++deg;\n\t\t}\n\t}\n\tfor(int i = 1; i <= deg; i++) {\n\t\tfor(int j = 0; j <= sub[x]; j++) {\n\t\t\tfn[i][j] = inf;\n\t\t\tgn[i][j] = false;\n\t\t}\n\t}\n\tfor(int j = 0; j <= sub[x]; j++) {\n\t\tgn[0][j] = (a[x] > 0);\n\t}\n\tint tot = 0;\n\tfor(int i = 1; i <= deg; i++) {\n\t\tint node = c[i - 1];\n\t\tfor(int j = 0; j <= n; j++) {\n\t\t\tfor(int k = 0; k <= n; k++) {\n\t\t\t\tif(dp[node][k] < 0 || pos[node][k]) {\n\t\t\t\t\tfn[i][j + k + 1] = min(fn[i][j + k], fn[i - 1][j]);\n\t\t\t\t}\n\t\t\t\tfn[i][j + k] = min(fn[i][j + k], fn[i - 1][j] + dp[node][k]);\n\t\t\t}\n\t\t\tfor(int k = 0; k <= n; k++) {\n\t\t\t\tif(dp[node][k] < 0 || pos[node][k]) {\n\t\t\t\t\tgn[i][j + k + 1] |= gn[i - 1][j];\n\t\t\t\t}\n\t\t\t\tgn[i][j + k] |= gn[i - 1][j] && pos[node][k];\n\t\t\t}\n\t\t}\n\t\ttot += sub[node];\n\t}\n\tfor(int i = 0; i <= n; i++) {\t\n\t\tdp[x][i] = a[x] + fn[deg][i];\n\t\tpos[x][i] = gn[deg][i];\n\t}\n}\nint main(int argc, char const *argv[])\n{\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tfor(int i = 1; i < n; i++) {\n\t\tint p, q;\n\t\tscanf(\"%d %d\", &p, &q);\n\t\tg[p].emplace_back(q);\n\t\tg[q].emplace_back(p);\n\t}\n\tfor(int i = 0; i <= n; i++) {\n\t\tfor(int j = 0; j <= n; j++) {\n\t\t\tdp[i][j] = inf;\n\t\t}\n\t}\n\tdfs(1, 0);\n\tint ans = -1;\n\tfor(int i = n; i >= 0; i--) {\n\t\tif(dp[1][i] < 0 || pos[1][i]) {\n\t\t\tans = i;\n\t\t}\n\t}\n\tassert(ans >= 0);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <iomanip>\n#define MOD 1000000007\ntypedef long long ll;\nusing namespace std;\n\nint N;\nll A[5050];\nvector<int> g[5050];\n\nll dp[5050][5050][2];\nll memo[5050][2];\nint num[5050];\nconst ll INF=1e18;\n\nvoid dfs(int now,int par){\n  for(int next:g[now]){\n    if(next==par) continue;\n    dfs(next,now);\n  }\n\n  int sum=1;\n  if(A[now]<0) dp[now][0][1]=A[now];\n  else dp[now][0][0]=A[now];\n\n  for(int next:g[now]){\n    if(next==par) continue;\n    for(int i=0;i<sum;i++){\n      for(int j=0;j<num[next];j++){\n        for(int k=0;k<2;k++){\n          for(int l=0;l<2;l++){\n            memo[i+j][k|l]=min(memo[i+j][k|l],dp[now][i][k]+dp[next][j][l]);\n\n            if(dp[next][j][l]<0||(l==0&&dp[next][j][l]<INF)){\n              memo[i+j+1][k]=min(memo[i+j+1][k],dp[now][i][k]);\n            }\n          }\n        }\n      }\n    }\n\n    sum+=num[next];\n    for(int i=0;i<sum;i++){\n      for(int k=0;k<2;k++){\n        dp[now][i][k]=memo[i][k];\n        memo[i][k]=INF;\n      }\n    }\n  }\n  num[now]=sum;\n}\n\nint main(){\n  cin>>N;\n  for(int i=0;i<N;i++) cin>>A[i];\n  for(int i=1;i<N;i++){\n    int u,v;\n    cin>>u>>v;\n    u--;v--;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n\n  for(int i=0;i<=N;i++){\n    for(int k=0;k<2;k++){\n      for(int j=0;j<=N;j++){\n        dp[i][j][k]=INF;\n      }\n      memo[i][k]=INF;\n    }\n  }\n\n  dfs(0,-1);\n\n  int ans=N-1;\n  for(int i=0;i<N;i++){\n    if(dp[0][i][0]<INF) ans=min(ans,i);\n    if(dp[0][i][1]<0) ans=min(ans,i);\n  }\n  cout<<ans<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//注意点\n//Tは3つの値を持つ構造\n//だがワイルドカードとしても使っている\n#include <bits/stdc++.h>\nusing namespace std;\n//@起動時\nstruct initon {\n    initon() {\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.setf(ios::fixed);\n        cout.precision(16);\n    };\n} __initon;\n\n//@必須構造\nstruct T {\n    int f, s, t;\n    T() { f = -1, s = -1, t = -1; }\n    T(int f, int s, int t) : f(f), s(s), t(t) {}\n    bool operator<(const T &r) const {\n        return f != r.f ? f < r.f : s != r.s ? s < r.s : t < r.t;\n        //return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 大きい順\n    }\n    bool operator>(const T &r) const {\n        return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t;\n        //return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 小さい順\n    }\n    int operator[](int i) {\n        assert(i < 3);\n        return i == 0 ? f : i == 1 ? s : t;\n    }\n};\n\n//@マクロ省略系 型,構造\n\n#define int long long\n#define ll long long\n#define double long double\n#define ull unsigned long long\nusing dou = double;\nusing itn = int;\nusing str = string;\nusing bo= bool;\nusing P = pair<int, int>;\n#define F first\n#define S second\n#define vec vector\n#define con continue\n#define bre break\n#define brk break\n#define is ==\n#define rs resize\n\n//マクロ省略系 コンテナ\nusing vi = vector<int>;\n#define vvi(a, b, c) vec<vi> a(b,vi(c))\nusing vb = vector<bool>;\n#define vvb(a, b, c) vec<vb> a(b,vb(c))\nusing vs = vector<string>;\n#define vvs(a, b, c) vec<vs> a(b,vs(c))\nusing vl = vector<ll>;\n#define vvl(a, b, c) vec<vl> a(b,vl(c))\nusing vd = vector<double>;\n#define vvd(a, b, c) vec<vd> a(b,vd(c))\nusing vc=vector<char>;\n#define vvc(a, b, c) vec<vc> a(b,vc(c))\nusing vp = vector<P>;\n#define vvp(a, b, c) vec<vp> a(b,vp(c))\nusing vt = vector<T>;\n#define vvt(a, b, c) vec<vt> a(b,vt(c))\n#define v3i(a, b, c, d) vector<vector<vi>> a(b, vector<vi>(c, vi(d)))\n#define v3d(a, b, c, d) vector<vector<vd>> a(b, vector<vd>(c, vd(d)))\n#define v3m(a, b, c, d) vector<vector<vm>> a(b, vector<vm>(c, vm(d)))\n#define PQ priority_queue<ll, vector<ll>, greater<ll> >\nusing seti = set<int>;\n#define uset unordered_set\n#define mset multiset\n#define umap unordered_map\n#define mmap multimap\n\n//マクロ 繰り返し\n#define _overloadrep(_1, _2, _3, name, ...) name\n# define _rep(i, n) for(int i = 0; i < n ; i++)\n#define repi(i, m, n) for(int i = m; i < n ; i++)\n#define rep(...) _overloadrep(__VA_ARGS__,repi,_rep,)(__VA_ARGS__)\n#define _rer(i, n) for(int i = n; i >= 0 ; i--)\n#define reri(i, m, n) for(int i = m; i >= n ; i--)\n#define rer(...) _overloadrep(__VA_ARGS__,reri,_rer,)(__VA_ARGS__)\n#define fora(a, b) for(auto&& a : b)\n#define forg(gi, ve) if (ve.size())for (int gi = 0, f = ve[gi].from, t = ve[gi].to, c = ve[gi].cost; gi < ve.size(); gi++,f = ve[gi].from, t = ve[gi].to, c = ve[gi].cost)\n\n//マクロ 定数\n#define k4 10101\n#define k5 101010\n#define k6 1010101\n#define k7 10101010\nconst int inf = (int) 1e9 + 100;\nconst ll linf = (ll) 1e18 + 100;\nconst double eps = 1e-9;\nconst int y4[] = {-1, 1, 0, 0};\nconst int x4[] = {0, 0, -1, 1};\nconst int y8[] = {0, 1, 0, -1, -1, 1, 1, -1};\nconst int x8[] = {1, 0, -1, 0, 1, -1, 1, -1};\n\n//マクロ省略形 関数等\n#define arsz(a) (sizeof(a)/sizeof(a[0]))\n#define sz(a) (a.size())\n#define mp make_pair\n#define pb push_back\n#define pf push_front\n#define eb emplace_back\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\n//@拡張系 こう出来るべきというもの\n\n//埋め込み 存在を意識せずに機能を増やされているもの\n// 境界チェック付きvector\nnamespace std_vector_bounds_checking {\n    using namespace std;\n    template<class T, class A = std::allocator<T>> struct vector : std::vector<T, A> {\n        using std::vector<T, A>::vector;\n        typename std::vector<T>::reference operator[](typename std::vector<T>::size_type n) {\n            return this->at(n);\n        }\n    };\n}\nnamespace std {\n    template<> class hash<std::pair<signed, signed>> {\n    public:\n        size_t operator()(const std::pair<signed, signed> &x) const {\n            return hash<ll>()(((ll) x.first << 32) + x.second);\n        }\n    };\n    template<> class hash<std::pair<ll, ll>> {\n    public:\n        size_t operator()(const std::pair<ll, ll> &x) const {\n            return hash<ll>()(((ll) x.first << 32) + x.second);\n        }\n    };\n}\ntemplate<typename T> istream &operator>>(istream &iss, vector<T> &vec) {\n    for (T &x: vec) iss >> x;\n    return iss;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, vector <T> &vec) {\n    for (int i = 0; i < vec.size(); i++)os << vec[i] << (i + 1 == vec.size() ? \"\" : \" \");\n    return os;\n}\ntemplate<typename V, typename H> void resize(vector<V> &vec, const H head) {  //再帰の終端。 可変長templateの長さが 0 になるとこっちが呼ばれる。\n    vec.resize(head);\n}\ntemplate<typename V, typename H, typename ... T> void resize(vector<V> &vec, const H &head, const T ... tail) {\n    vec.resize(head);\n    for (auto &v: vec) resize(v, tail...);\n}\ntemplate<class T> T pop(set<T> &set) {\n    T res = *set.begin();\n    set.erase(set.find(res));\n    return res;\n}\ntemplate<class T> T pop(mset<T> &set) {\n    T res = *set.begin();\n    set.erase(set.find(res));\n    return res;\n}\ntemplate<class T> T popBack(set<T> &set) {\n    T res = *set.rbegin();\n    set.erase(set.find(res));\n    return res;\n}\ntemplate<class T> T popBack(mset<T> &set) {\n    T res = *set.rbegin();\n    set.erase(set.find(res));\n    return res;\n}\ntemplate<class T> inline void sort(vector<T> &a) { sort(a.begin(), a.end()); };\ntemplate<class T> inline void rsort(vector<T> &a) { sort(a.begin(), a.end(), greater<T>()); };\ntemplate<class T> inline void sort(vector<T> &a, int len) { sort(a.begin(), a.begin() + len); };\ntemplate<class T> inline void rsort(vector<T> &a, int len) { sort(a.begin(), a.begin() + len, greater<T>()); };\ntemplate<class T> inline void sort2(vector<vector<T>> &a) { for (int i = 0, n = a.size(); i < n; i++)sort(a[i]); }\ntemplate<class T> inline void rsort2(vector<vector<T>> &a) { for (int i = 0, n = a.size(); i < n; i++)rsort(a[i]); }\ntemplate<typename A, size_t N, typename T> void fill(A (&a)[N], const T &v) { rep(i, N)a[i] = v; }\ntemplate<typename A, size_t N, size_t O, typename T> void fill(A (&a)[N][O], const T &v) { rep(i, N)rep(j, O)a[i][j] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, typename T> void fill(A (&a)[N][O][P], const T &v) { rep(i, N)rep(j, O)rep(k, P)a[i][j][k] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, typename T> void fill(A (&a)[N][O][P][Q], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)a[i][j][k][l] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, typename T> void fill(A (&a)[N][O][P][Q][R], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)a[i][j][k][l][m] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S, typename T> void fill(A (&a)[N][O][P][Q][R][S], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)rep(n, S)a[i][j][k][l][m][n] = v; }\ntemplate<typename V, typename T> void fill(V &x, const T &val) { x = val; }\ntemplate<typename V, typename T> void fill(vector<V> &vect, const T &val) { for (auto &v: vect) fill(v, val); }\n//@汎用便利関数 入力\ntemplate<typename T = int> T in() {\n    T x;\n    cin >> x;\n    return (x);\n}\nstring sin() { return in<string>(); }\ndouble din() { return in<double>(); }\nll lin() { return in<ll>(); }\n#define na(a, n) rep(i,n) cin >> a[i];\n#define nad(a, n) rep(i,n) cin >> a[i], a[i]--;\n#define na3(a, b, c, n) rep(i, n)cin >> a[i] >> b[i] >> c[i];\n#define add2(a, b, n) rep(i, n)a.pb(in()),b.pb(in());\n#define add2d(a, b, n) rep(i, n)a.pb(in()-1),b.pb(in()-1);\n#define add3(a, b, c, n) rep(i, n)a.pb(in()),b.pb(in()),c.pb(in());\n#define add3d(a, b, c, n) rep(i, n)a.pb(in()-1),b.pb(in()-1),c.pb(in());\n#define na2(a, b, n) rep(i, n)cin >> a[i] >> b[i];\n#define nt(a, h, w) rep(hi,h)rep(wi,w) cin >> a[hi][wi];\n#define ntd(a, h, w) rep(hi,h)rep(wi,w) cin >> a[hi][wi], a[hi][wi]--;\n#define ntp(a, h, w) fill(a,'#');rep(hi,1,h+1)rep(wi,1,w+1) cin >> a[hi][wi];\n#define addn(a, n) a.resize(n);na(a,n);\n#define addnd(a, n) a.resize(n);na(a,n);rep(i,n)a[i]--;\n\n\n//汎用便利関数 出力\ntemplate<class T> void out(T x) { typeid(x) == typeid(double) ? cout << fixed << setprecision(10) << x << endl : cout << x << endl; }\n//デバッグ\n#define debug(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n';\n//よく使うクラス、構造体\nclass UnionFind {\npublic:\n    vi par, rank, sizes;\n    int n, trees;\n    UnionFind(int n) : n(n), trees(n) {\n        par.resize(n), rank.resize(n), sizes.resize(n);\n        rep(i, n)par[i] = i, sizes[i] = 1;\n    }\n    int root(int x) {\n        if (par[x] == x)return x;\n        else return par[x] = root(par[x]);\n    }\n    int find(int x) { return root(x); }\n    void unite(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y)return;\n        if (rank[x] < rank[y])swap(x, y);\n        trees--;\n        par[y] = x;\n        sizes[x] += sizes[y];\n        if (rank[x] == rank[y])rank[x]++;\n    }\n    bool same(int x, int y) { return root(x) == root(y); }\n    int size(int x) { return sizes[root(x)]; }\n    //順不同 umapなので\n    vec<vi> sets() {\n        vec<vi> res(trees);\n        umap<int, vi> map;\n        rep(i, n) map[root(i)].push_back(i);\n        int i = 0;\n        for (auto &&p:map) {\n            int r = p.F;\n            res[i].push_back(r);\n            for (auto &&v:p.S) {\n                if (r == v)continue;\n                res[i].push_back(v);\n            }\n            i++;\n        }\n        return res;\n    }\n};\n\n//MOD関連\nll MOD = (int) 1e9 + 7;\nint mpow(int v, ll a) {\n    ll x = v, n = a, res = 1;\n    while (n) {\n        if (n & 1)res = (res * x) % MOD;\n        x = (x * x) % MOD;\n        n >>= 1;\n    }\n    return res;\n}\nclass mint {\nprivate:\n    ll v;\npublic:\n    static ll mod(ll a) { return (a % MOD + MOD) % MOD; }\n    mint(ll a = 0) { this->v = mod(a); };\n    mint(const mint &a) { v = a.v; }\n    mint operator+(const mint &a) { return mint(v + a.v); }\n    mint operator+(const ll a) { return mint(v + a % MOD); }\n    mint operator+(const signed a) { return mint(v + a % MOD); }\n    friend mint operator+(const ll a, const mint &b) { return mint(a % MOD + b.v); }\n    void operator+=(const mint &a) { v = (v + a.v) % MOD; }\n    void operator+=(const ll a) { v = mod(v + a % MOD); }\n    void operator+=(const signed a) { v = mod(v + a % MOD); }\n    friend void operator+=(ll &a, const mint &b) { a = mod(a % MOD + b.v); }\n    mint operator-(const mint &a) { return mint(v - a.v); }\n    mint operator-(const ll a) { return mint(v - a % MOD); }\n    mint operator-(const signed a) { return mint(v - a % MOD); }\n    friend mint operator-(const ll a, const mint &b) { return mint(a % MOD - b.v); }\n    void operator-=(const mint &a) { v = mod(v - a.v); }\n    void operator-=(const ll a) { v = mod(v - a % MOD); }\n    void operator-=(const signed a) { v = mod(v - a % MOD); }\n    friend void operator-=(ll &a, const mint &b) { a = mod(a % MOD - b.v); }\n    mint operator*(const mint &a) { return mint(v * a.v); }\n    mint operator*(const ll a) { return mint(v * (a % MOD)); }\n    mint operator*(const signed a) { return mint(v * (a % MOD)); }\n    friend mint operator*(const ll a, const mint &b) { return mint(a % MOD * b.v); }\n    void operator*=(const mint &a) { v = (v * a.v) % MOD; }\n    void operator*=(const ll a) { v = mod(v * (a % MOD)); }\n    void operator*=(const signed a) { v = mod(v * (a % MOD)); }\n    friend void operator*=(ll &a, const mint &b) { a = mod(a % MOD * b.v); }\n    mint operator/(const mint &a);\n    mint operator/(const ll a);\n    mint operator/(const signed a);\n    friend mint operator/(const ll a, const mint &b);\n    void operator/=(const mint &a);\n    void operator/=(const ll a);\n    void operator/=(const signed a);\n    friend void operator/=(ll &a, const mint &b);\n    mint operator^(const mint &a) { return mpow(v, a.v); };\n    mint operator^(const ll a) { return mpow(v, a); };\n    mint operator^(const signed a) { return mpow(v, a); };\n    friend mint operator^(const ll a, const mint &b) { return mpow(a, b.v); };\n    void operator^=(const mint &a) { v = mpow(v, a.v); }\n    void operator^=(const ll a) { v = mpow(v, a); }\n    void operator^=(const signed a) { v = mpow(v, a); }\n    //単項演算子\n    mint operator+() { return *this; }\n    mint operator++() {\n        v++;\n        return *this;\n    }\n    mint operator++(signed d) {\n        mint res = *this;\n        v++;\n        return res;\n    }\n    mint operator-() { return operator*(-1); }\n    mint operator--() {\n        v++;\n        return *this;\n    }\n    void operator--(signed d) {\n        mint res = *this;\n        v++;\n    }\n    bool operator==(mint &a) { return v == a.v; }\n    bool operator==(signed a) { return v == a; }\n    friend bool operator==(signed a, mint &b) { return a == b.v; }\n    bool operator!=(mint &a) { return v != a.v; }\n    bool operator!=(signed a) { return v != a; }\n    friend bool operator!=(signed a, mint &b) { return a != b.v; }\n    operator int() { return v; }\n};\nconst int setModMax = 510000;\nmint fac[setModMax], finv[setModMax], inv[setModMax];\nvoid setMod() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < setModMax; i++) {\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n\nmint minv(ll a) {\n    if (fac[0] == 0)setMod();\n    if (a < setModMax) return inv[a];\n    a %= MOD;\n    ll b = MOD, x = 1, y = 0;\n    while (b) {\n        ll t = a / b;\n        a -= t * b;\n        swap(a, b);\n        x -= t * y;\n        swap(x, y);\n    }\n    return (x % MOD + MOD) % MOD;\n}\nmint mint::operator/(const mint &a) { return mint(v * minv(a.v)); }\nmint mint::operator/(const ll a) { return mint(v * minv(a)); }\nmint mint::operator/(const signed a) { return mint(v * minv(a)); }\nmint operator/(const ll a, const mint &b) { return mint(a % MOD * minv(b.v)); }\nvoid mint::operator/=(const mint &a) { v = (v * minv(a.v)) % MOD; }\nvoid mint::operator/=(const ll a) { v = mod(v * minv(a)); }\nvoid mint::operator/=(const signed a) { v = mod(v * minv(a)); }\nvoid operator/=(ll &a, const mint &b) { a = mint::mod(a % MOD * minv(b.v)); }\nusing vm=vector<mint>;\n#define vvm(a, b, c) vec<vm> a(b,vm(c))\nbool isPrime[4010101];\nvi primes;\n\nvoid setPrime() {\n    fill(isPrime, true);\n    int len = sizeof(isPrime) / sizeof(isPrime[0]);\n    isPrime[0] = isPrime[1] = false;\n    for (int i = 2; i <= sqrt(len) + 5; ++i) {\n        if (!isPrime[i])continue;\n        for (int j = 2; i * j < len; ++j) {\n            isPrime[i * j] = false;\n        }\n    }\n    rep(i, len)if (isPrime[i])primes.pb(i);\n}\n\nmint com(ll n, ll r) {\n    if (n < r || n < 0 || r < 0)return 0;\n    if (fac[0] == 0)setMod();\n    return fac[n] * (finv[r] * finv[n - r] % MOD) % MOD;\n}\n\n//便利関数\nvoid ole() {\n    string a = \"a\";\n    rep(i, 30)a += a;\n    rep(i, 1 << 17)cout << a << endl;\n    cout << \"OLE 出力長制限超過\" << endl;\n    exit(0);\n}\nvoid tle() { while (inf)cout << inf << endl; }\nll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\nll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\nbool equal(double a, double b) { return fabs(a - b) < eps; }\nll reverse(ll a) {\n    ll res = 0;\n    while (a) {\n        res *= 10;\n        res += a % 10;\n        a /= 10;\n    }\n    return res;\n}\nll ceil(ll a, ll b) {\n    if (b == 0) {\n        ole();\n        return -1;\n    } else return (a + b - 1) / b;\n}\nll sqrt(ll a) {\n    if (a < 0)ole();\n    ll res = (ll) std::sqrt(a);\n    while (res * res < a)res++;\n    return res;\n}\ndouble log(double e, double x) { return log(x) / log(e); }\nll sig(ll t) { return (1 + t) * t / 2; }\nll sig(ll s, ll t) { return (s + t) * (t - s + 1) / 2; }\n\nvi divisors(int v) {\n    vi res;\n    for (int i = 1; i <= sqrt(v); ++i) {\n        if (v % i == 0) {\n            res.pb(i);\n            if (i != v / i)res.pb(v / i);\n        }\n    }\n    return res;\n}\n\nvi factorization(int v) {\n    int tv = v;\n    vi res;\n    if (!isPrime[2])setPrime();\n    for (auto &&p :primes) {\n        if (v % p == 0)res.push_back(p);\n        while (v % p == 0) {\n            v /= p;\n        }\n        if (v == 1 || p * p > tv)break;\n    }\n    if (v > 1)res.pb(v);\n    return res;\n}\n\nunordered_map<int, int> factorizationMap(int v) {\n    int tv = v;\n    unordered_map<int, int> res;\n    if (!isPrime[2])setPrime();\n    for (auto &&p :primes) {\n        while (v % p == 0) {\n            res[p]++;\n            v /= p;\n        }\n        if (v == 1 || p * p > tv)break;\n    }\n    if (v > 1)res[v]++;\n    return res;\n}\nint get(int a, int keta) { return (a / (int) pow(10, keta)) % 10; }\nint keta(int v) {\n    int cou = 0;\n    while (v) { cou++, v %= 10; }\n    return cou;\n}\n\ntemplate<class T> void imo(vector<T> &v) {\n    int n = v.size();\n    rep(i, n - 1)v[i + 1] += v[i];\n}\n\n//変換系\ntemplate<class T, class U> vector<U> keys(map<T, U> a) {\n    vector<U> res;\n    for (auto &&k :a)res.pb(k.F);\n    return res;\n}\n\ntemplate<class T, class U> vector<U> keys(umap<T, U> a) {\n    vector<U> res;\n    for (auto &&k :a)res.pb(k.F);\n    return res;\n}\n\ntemplate<class T, class U> vector<T> values(map<T, U> a) {\n    vector<T> res;\n    for (auto &&k :a)res.pb(k.S);\n    return res;\n}\n\ntemplate<class T, class U> vector<T> values(umap<T, U> a) {\n    vector<T> res;\n    for (auto &&k :a)res.pb(k.S);\n    return res;\n}\n\nvi list(int a) {\n    vi res;\n    while (a) {\n        res.insert(res.begin(), a % 10);\n        a /= 10;\n    }\n    return res;\n}\n\ntemplate<class T, class U> bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T, class U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> T min(T a, signed b) {\n    return a < b ? a : b;\n}\n\ntemplate<class T> T max(T a, signed b) {\n    return a < b ? b : a;\n}\n\ntemplate<class T> T min(vector<T> a) {\n    return *min_element(all(a));\n}\n\ntemplate<class T> T max(vector<T> a) {\n    return *max_element(all(a));\n}\n\ntemplate<class T> T min(T a[]) {\n    T res = a[0];\n    rep(i, arsz(a))chmin(res, a[i]);\n    return res;\n}\n\ntemplate<class T> T max(T a[]) {\n    T res = a[0];\n    rep(i, arsz(a))chmax(res, a[i]);\n    return res;\n}\ntemplate<class T> T sum(vector<T> &v, int len = -1) {\n    if (len == -1)len = v.size();\n    T res = 0;\n    chmin(len, v.size());\n    rep(i, len)res += v[i];\n    return res;\n}\n\ntemplate<class T> T sum(vector<vector<T>> &v, int h = -1, int w = -1) {\n    if (h == -1)h = v.size();\n    if (w == -1)w = v[0].size();\n    T res = 0;\n    chmin(h, v.size());\n    chmin(w, v[0].size());\n    rep(i, h)rep(j, w)res += v[i][j];\n    return res;\n}\n\nP sump(vp &v, int len = -1) {\n    if (len == -1)len = v.size();\n    P res = {0, 0};\n    chmin(len, v.size());\n    rep(i, len) {\n        res.F += v[i].F;\n        res.S += v[i].S;\n    }\n    return res;\n}\n\n///要素が0の時、返り値は0か1か\ntemplate<class T> T mul(vector<T> &v, int len = -1) {\n    if (len == -1)len = v.size();\n    T res = 1;\n    chmin(len, v.size());\n    rep(i, len)res *= v[i];\n    return res;\n}\nvoid clear(PQ &q) { while (q.size())q.pop(); }\ntemplate<class T> void clear(queue<T> &q) { while (q.size())q.pop(); }\ntemplate<class T> T *negarr(int size) {\n    T *body = (T *) malloc((size * 2 + 1) * sizeof(T));\n    return body + size;\n}\ntemplate<class T> T *negarr2(int h, int w) {\n    double **dummy1 = new double *[2 * h + 1];\n    double *dummy2 = new double[(2 * h + 1) * (2 * w + 1)];\n    dummy1[0] = dummy2 + w;\n    for (int i = 1; i <= 2 * h + 1; i++) {\n        dummy1[i] = dummy1[i - 1] + 2 * w + 1;\n    }\n    double **a = dummy1 + h;\n}\n\ntemplate<class T> vector<T> ruiv(vector<T> &a) {\n    vector<T> res(a.size() + 1);\n    rep(i, a.size())res[i + 1] = res[i] + a[i];\n    return res;\n}\n\ntemplate<class T> vector<T> ruim(vector<T> &a) {\n    vector<T> res(a.size() + 1, 1);\n    rep(i, a.size())res[i + 1] = res[i] * a[i];\n    return res;\n}\n//右から左にかけての半開区間 (-1 n-1]\ntemplate<class T> T *rrui(vector<T> &a) {\n    int len = a.size();\n    T *body = (T *) malloc((len + 1) * sizeof(T));\n    T *res = body + 1;\n    rer(i, len - 1)res[i - 1] = res[i] + a[i];\n    return res;\n}\n//掛け算\ntemplate<class T> T *rruim(vector<T> &a) {\n    int len = a.size();\n    T *body = (T *) malloc((len + 1) * sizeof(T));\n    T *res = body + 1;\n    res[len - 1] = 1;\n    rer(i, len - 1)res[i - 1] = res[i] * a[i];\n    return res;\n}\ntemplate<class T> void plus(vector<T> &a, T v = 1) { for (auto &&u :a)u += v; }\ntemplate<class T> void minu(vector<T> &a, T v = 1) { for (auto &&u :a)u -= v; }\ntemplate<class T> void minus(vector<T> &a, T v = 1) { for (auto &&u :a)u -= v; }\ninline bool inside(int y, int x, int H, int W) { return y >= 0 && x >= 0 && y < H && x < W; }\nll u(ll a) { return a < 0 ? 0 : a; }\n#define MIN(a) numeric_limits<a>::min()\n#define MAX(a) numeric_limits<a>::max()\ntemplate<class T> T min(vector<vector<T>> &a) {\n    T res = MAX(T);\n    rep(i, a.size())chmin(res, *min_element(all(a[i])));\n    return res;\n}\ntemplate<class T> T max(vector<vector<T>> &a) {\n    T res = MIN(T);\n    rep(i, a.size())chmax(res, *max_element(all(a[i])));\n    return res;\n}\nbool bget(ll m, int keta) { return (m >> keta) & 1; }\nint bget(ll m, int keta, int sinsuu) {\n    m /= (ll) pow(sinsuu, keta);\n    return m % sinsuu;\n}\ninline ll bit(int n) { return (1LL << (n)); }\ninline ll bit(int n, int sinsuu) { return (ll) pow(sinsuu, n); }\nint bcou(ll m) { return __builtin_popcount(m & 0xFFFFFFFF) + __builtin_popcount(m >> 32); }\n//初期化は0を渡す\nll nextComb(ll &mask, int n, int r) {\n    if (!mask)return mask = (1LL << r) - 1;\n    ll x = mask & -mask; //最下位の1\n    ll y = mask + x; //連続した下の1を繰り上がらせる\n    ll res = ((mask & ~y) / x >> 1) | y;\n    if (bget(res, n))return mask = 0;\n    else return mask = res;\n}\n\n//n桁以下でビットがr個立っているもののvectorを返す\nvl bitCombList(int n, int r) {\n    vl res;\n    int m = 0;\n    while (nextComb(m, n, r)) {\n        res.pb(m);\n    }\n    return res;\n}\n//大文字小文字を区別する\nint altoiaZ(char c) {\n    if ('A' <= c && c <= 'Z')return c - 'A';\n    return c - 'a' + 26;\n}\nchar itoalaZ(int i) {\n    if (i < 26)return 'A' + i;\n    return 'a' + i - 26;\n}\n//aもAも0を返す 基本小文字\nint altoi(char c) {\n    if ('A' <= c && c <= 'Z')return c - 'A';\n    return c - 'a';\n}\nchar itoal(int i) {\n    return 'a' + i;\n}\nint ctoi(char c) { return c - '0'; }\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\nvoid compress(vi &a) {\n    vi b;\n    int len = a.size();\n    for (int i = 0; i < len; ++i) {\n        b.push_back(a[i]);\n    }\n    sort(b);\n    UNIQUE(b);\n    for (int i = 0; i < len; ++i) {\n        a[i] = lower_bound(all(b), a[i]) - b.begin();\n    }\n}\n\nvoid compress(int a[], int len) {\n    vi b;\n    for (int i = 0; i < len; ++i) {\n        b.push_back(a[i]);\n    }\n    sort(b);\n    UNIQUE(b);\n    for (int i = 0; i < len; ++i) {\n        a[i] = lower_bound(all(b), a[i]) - b.begin();\n    }\n}\n//要素が見つからなかったときに困る\n#define binarySearch(a, v) (binary_search(all(a),v))\n#define lowerIndex(a, v) (lower_bound(all(a),v)-a.begin())\n#define lowerBound(a, v) (*lower_bound(all(a),v))\n#define upperIndex(a, v) (upper_bound(all(a),v)-a.begin())\n#define upperBound(a, v) (*upper_bound(all(a),v))\n#define ans(a) cout<<a<<endl;continue;\n#define poll(a) q.front();q.pop()\n#define dpoll(a) q.front();q.pop_front()\n#define pollLast(a) q.back();q.pop_back()\n#define pollBack(a) q.back();q.pop_back()\ntemplate<class T> inline void fin(T s) { cout << s << endl, exit(0); }\n\ntemplate<class T> struct edge {\n    int from, to;\n    T cost;\n    int id;\n    int type;\n    edge(int f, int t, T c = 1, int id = -1, int ty = -1) : from(f), to(t), cost(c), id(id), type(ty) {}\n    bool operator<(const edge &b) const { return cost < b.cost; }\n    bool operator>(const edge &b) const { return cost > b.cost; }\n};\n\ntemplate<typename T> class graph {\nprotected:\n    vector<bool> _used;\npublic :\n    vector<vector<edge<T>>> g;\n    vector<edge<T>> edges;\n    int n, root = -1;\n    graph(int n) : n(n) { g.resize(n), _used.resize(n); }\n    void clear() { g.clear(), edges.clear(); }\n    void resize(int n) {\n        this->n = n;\n        g.resize(n);\n        _used.resize(n);\n    }\n    int size() { return g.size(); }\n    bool isleaf(int v) {\n        assert(root != -1);\n        return g[v].size() == 1 && g[v][0].from != root;\n    }\n    vector<edge<T> > &operator[](int i) { return g[i]; }\n    virtual void add(int from, int to, T cost, int ty) = 0;\n    virtual bool used(edge<T> &e) = 0;\n    virtual bool used(int id) = 0;\n    virtual void del(edge<T> &e) = 0;\n    virtual void del(int id) = 0;\n};\n\ntemplate<class T=int> class undigraph : public graph<T> {\npublic:\n    using graph<T>::g;\n    using graph<T>::n;\n    using graph<T>::edges;\n    using graph<T>::_used;\n    undigraph(int n) : graph<T>(n) {\n    }\n    void add(int f, int t, T cost = 1, int ty = -1) {\n        if (!(0 <= f && f < n && 0 <= t && t < n))ole();\n        int id = edges.size();\n        g[f].emplace_back(f, t, cost, id, ty);\n        g[t].emplace_back(t, f, cost, id + 1, ty);\n        edges.emplace_back(f, t, cost, id, ty);\n        edges.emplace_back(t, f, cost, id + 1, ty);\n    }\n    void add(edge<T> &e) {\n        int f = e.from, t = e.to, ty = e.type;\n        T cost = e.cost;\n        add(f, t, cost, ty);\n    }\n    bool used(edge<T> &e) { return _used[e.id]; }\n    bool used(int id) { return _used[id]; }\n    void del(edge<T> &e) { _used[e.id] = _used[e.id ^ 1] = 1; }\n    void del(int id) { _used[id] = _used[id ^ 1] = 1; }\n};\n\ntemplate<typename T =ll> class digraph : public graph<T> {\npublic:\n    using graph<T>::g;\n    using graph<T>::n;\n    using graph<T>::edges;\n    using graph<T>::_used;\n\n    digraph(int n) : graph<T>(n) {}\n    void add(int f, int t, T cost = 1, int ty = -1) {\n        if (!(0 <= f && f < n && 0 <= t && t < n))ole();\n        int id = edges.size();\n        g[f].emplace_back(f, t, cost, ty, id);\n        edges.emplace_back(f, t, cost, ty, id);\n    }\n    bool used(edge<T> &e) { return _used[e.id]; }\n    bool used(int id) { return _used[id]; }\n    void del(edge<T> &e) { _used[e.id] = _used[e.id ^ 1] = 1; }\n    void del(int id) { _used[id] = _used[id ^ 1] = 1; }\n};\n\ntemplate<class T> bool nibu(const graph<T> &g) {\n    UnionFind uf(g.n * 2);\n    for (auto &&e :g.edges)uf.unite(e.f, e.t + g.n), uf.unite(e.f + g.n, e.t);\n    return !uf.same(0, g.n);\n}\n\ntemplate<class T> vector<T> &dijkstra(const graph<T> &g, int s) {\n    if (!(0 <= s && s < g.n))ole();\n    T initValue = MAX(T);\n    vector<T> dis(g.n, initValue);\n    priority_queue<pair<T, int>, vector<pair<T, int>>, greater<pair<T, int>>> q;\n    dis[s] = 0;\n    q.emplace(0, s);\n    while (q.size()) {\n        T nowc = q.top().F;\n        int i = q.top().S;\n        q.pop();\n        if (dis[i] != nowc)continue;\n        for (auto &&e  : g.g[i]) {\n            int to = e.to;\n            T cost = nowc + e.cost;\n            if (dis[to] > cost) {\n                dis[to] = cost;\n                q.emplace(dis[to], to);\n            }\n        }\n    }\n    //たどり着かないなら-1\n    for (auto &&d :dis) if (d == initValue)d = -1;\n    return dis;\n}\n\n//機能拡張\ntemplate<typename T> void remove(vector<T> &v, unsigned int i) { v.erase(v.begin() + i); }\n\ntemplate<typename T> void remove(vector<T> &v, unsigned int s, unsigned int e) {\n    v.erase(v.begin() + s, v.begin() + e);\n}\n\ntemplate<typename T> void removen(vector<T> &v, unsigned int s, unsigned int n) {\n    v.erase(v.begin() + s, v.begin() + s + n);\n}\n\ntemplate<typename T> void erase(vector<T> &v, unsigned int i) { v.erase(v.begin() + i); }\n\ntemplate<typename T> void erase(vector<T> &v, unsigned int s, unsigned int e) {\n    v.erase(v.begin() + s, v.begin() + e);\n}\n\ntemplate<typename T> void erasen(vector<T> &v, unsigned int s, unsigned int n) {\n    v.erase(v.begin() + s, v.begin() + s + n);\n}\n\ntemplate<typename T> void insert(vector<T> &v, unsigned int i, T t) { v.insert(v.begin() + i, t); }\n\ntemplate<typename T> void insert(vector<T> &v, unsigned int i, vector<T> list) {\n    for (auto &&va :list)v.insert(v.begin() + i++, va);\n}\n\ntemplate<typename T> void insert(vector<T> &v, unsigned int i, initializer_list<T> list) {\n    for (auto &&va :list)v.insert(v.begin() + i++, va);\n}\n\ntemplate<typename T> void insert(set<T> &v, vector<T> list) {\n    for (auto &&va :list)v.insert(va);\n}\n\ntemplate<typename T> void insert(set<T> &v, initializer_list<T> list) {\n    for (auto &&va :list)v.insert(va);\n}\n\nint mod(int a, int m) {\n    return (a % m + m) % m;\n}\n\nll ma = numeric_limits<ll>::min();\nll mi = numeric_limits<ll>::max();\n\n//閉路がなければtrue\nbool topo(vi &res, digraph<int> &g) {\n    int n = g.g.size();\n    vi nyu(n);\n    rep(i, n)for (auto &&e :g[i])nyu[e.to]++;\n    queue<int> st;\n    rep(i, n)if (nyu[i] == 0)st.push(i);\n    while (st.size()) {\n        int v = st.front();\n        st.pop();\n        res.pb(v);\n        fora(e, g[v]) if (--nyu[e.to] == 0)st.push(e.to);\n    }\n    return res.size() == n;\n}\n\n//辞書順最小トポロジカルソート\nbool topos(vi &res, digraph<int> &g) {\n    int n = g.g.size();\n    vi nyu(n);\n    rep(i, n)for (auto &&e :g[i])nyu[e.to]++;\n    //小さい順\n    priority_queue<int, vector<int>, greater<int> > q;\n    rep(i, n)if (nyu[i] == 0)q.push(i);\n    while (q.size()) {\n        int i = q.top();\n        q.pop();\n        res.pb(i);\n        fora(e, g[i])if (--nyu[e.to] == 0)q.push(e.to);\n    }\n    return res.size() == n;\n}\n\nvector<string> split(const string a, const char deli) {\n    string b = a + deli;\n    int l = 0, r = 0, n = b.size();\n    vector<string> res;\n    rep(i, n) {\n        if (b[i] == deli) {\n            r = i;\n            if (l < r)res.push_back(b.substr(l, r - l));\n            l = i + 1;\n        }\n    }\n    return res;\n}\n\nvector<string> split(const string a, const string deli) {\n    string b = a + deli;\n    int l = 0, r = 0, n = b.size(), dn = deli.size();\n    vector<string> res;\n    rep(i, n) {\n        if (i + dn <= n && b.substr(i, i + dn) == deli) {\n            r = i;\n            if (l < r)res.push_back(b.substr(l, r - l));\n            i += dn - 1;\n            l = i + 1;\n        }\n    }\n    return res;\n}\n\nint n, k, m, h, w, x, y, q;\nint cou;\nvi a, b, c;\nv3i(dp, 5050, 5050, 2);//コンピューターしかないか\nvvi(sub, 5050, 2);\nundigraph<> g(0);\nvi es(5050);\n\nvoid ds(int i, int p) {\n    forg(gi, g[i])if (t != p)ds(t, i);\n    int sum = 0;\n    dp[i][0][a[i] < 0] = a[i];\n    forg(gi, g[i]) {\n            if (t == p)continue;\n            rep(ci, sum + 1) {\n                rep(ct, es[t] + 1) {\n                    rep(ki, 2) {\n                        rep(kt, 2) {\n                            //繋ぐ\n                            if (dp[i][ci][ki] < linf && dp[t][ct][kt] < linf)\n                                chmin(sub[ci + ct][ki || kt], dp[i][ci][ki] + dp[t][ct][kt]);\n                            //切る\n                            if (dp[t][ct][kt] < 0 || (!kt && dp[t][ct][kt] != linf))\n                                chmin(sub[ci + ct + 1][ki], dp[i][ci][ki]);\n                        }\n                    }\n                }\n            }\n            sum += es[t] + 1;\n            rep(j, sum + 1)\n                rep(k, 2) {\n                    dp[i][j][k] = sub[j][k];\n                    sub[j][k] = linf;\n\n                }\n        }\n    es[i] = sum;\n}\nsigned main() {\n    cin >> n;\n    addn(a, n);\n    g.resize(n);\n    rep(i, n - 1) {\n        int f, s;\n        cin >> f >> s;\n        --f, --s;\n        g.add(f, s);\n    }\n    fill(dp, linf);\n    fill(sub, linf);\n    ds(0, -1);\n    rep(c, n)rep(k, 2) {\n            if (k) {\n                if (dp[0][c][k] < 0)fin(c);\n            } else if (dp[0][c][k] != linf)fin(c);\n        }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ostream>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\nconst ll INF = TEN(18);\n\nint n;\nV<ll> a;\nVV<int> g;\n\nusing P = pair<ll, ll>;\nV<P> dfs(int p, int b) {\n    V<P> dp = {{0, INF}};\n    for (int d: g[p]) {\n        if (d == b) continue;\n        auto ndp = dfs(d, p);\n        int k = int(ndp.size());\n        ndp.push_back({INF, INF});\n        for (int i = k - 1; i >= 0; i--) {\n            if (ndp[i].first < INF / 2 || ndp[i].second < 0) ndp[i + 1].first = min(ndp[i + 1].first, 0LL);\n        }\n        int m = int(dp.size()) - 1;\n        V<P> udp(m + k + 1, {INF, INF});\n        for (int i = 0; i <= m; i++) {\n            for (int j = 0; j <= k; j++) {\n                udp[i+j].first = min(udp[i+j].first, dp[i].first + ndp[j].first);\n                udp[i+j].second = min(udp[i+j].second, dp[i].first + ndp[j].second);\n                udp[i+j].second = min(udp[i+j].second, dp[i].second + ndp[j].first);\n                udp[i+j].second = min(udp[i+j].second, dp[i].second + ndp[j].second);\n            }\n        }\n        dp = udp;\n    }\n    int m = int(dp.size()) - 1;\n    V<P> udp(m + 1);\n    for (int i = 0; i <= m; i++) {\n        if (a[p] > 0) {\n            udp[i].first = dp[i].first + a[p];\n            udp[i].second = dp[i].second + a[p];\n        } else {\n            udp[i].first = INF;\n            udp[i].second = min(dp[i].first, dp[i].second) + a[p];\n        }\n    }\n\n    return udp;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout << setprecision(20) << fixed;\n\n    cin >> n;\n    a = V<ll>(n);\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n    g = VV<int>(n);\n    for (int j = 0; j < n - 1; ++j) {\n        int a, b;\n        cin >> a >> b; a--; b--;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n\n    auto dp = dfs(0, -1);\n\n    for (int i = 0; i < n; i++) {\n        if (dp[i].first < INF / 2 || dp[i].second < 0) {\n            cout << i << endl;\n            return 0;\n        }\n    }\n    assert(false);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <stack>\n#include <tuple>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <iomanip>\n\n#define int long long int\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() )\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int INF = 1e15;\nconst int MOD = 1e9+7;\n\nint n;\nvector<int> a, child;\nvector<vector<int>> edge, sub;\nvector<vector<vector<int>>> dp;\n\nvoid dfs(int v, int par){\n    for(int u : edge[v]){\n        if(u == par){\n            continue;\n        }\n        dfs(u, v);\n    }\n    if(a[v] > 0){\n        dp[v][0][0] = a[v];\n    }else{\n        dp[v][0][1] = a[v];\n    }\n\n    int sum = 1;\n\n    for(int u : edge[v]){\n        if(u == par){\n            continue;\n        }\n        for(int i = 0; i < sum; i++){\n            for(int j = 0; j < child[u]; j++){\n                rep(k1, 2) rep(k2, 2){\n                    sub[i+j][k1|k2] = min(sub[i+j][k1|k2], dp[v][i][k1] + dp[u][j][k2]);\n                    if(k2 == 0 && dp[u][j][k2] < INF || dp[u][j][k2] < 0){\n                        sub[i+j+1][k1] = min(sub[i+j+1][k1], dp[v][i][k1]);\n                    }\n                }\n\n            }\n        }\n        sum += child[u];\n        for(int i = 0; i <= sum; i++){\n            rep(k, 2){\n                dp[v][i][k] = sub[i][k];\n                sub[i][k] = INF;\n            }\n        }\n    }\n    child[v] = sum;\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    cin >> n;\n    a = vector<int>(n + 1);\n    rep(i, n) cin >> a[i+1];\n\n    edge = vector<vector<int>>(n + 1, vector<int>());\n    rep(i, n - 1){\n        int u, v;\n        cin >> u >> v;\n        edge[u].push_back(v);\n        edge[v].push_back(u);\n    }\n\n    dp = vector<vector<vector<int>>>(n + 1, vector<vector<int>>(n + 1, vector<int>(2, INF)));\n    sub = vector<vector<int>>(n + 1, vector<int>(2, INF));\n    child = vector<int>(n + 1);\n    dfs(1, 0);\n\n    int ans = INF;\n    rep(i, n + 1){\n        if(dp[1][i][0] != INF){\n            ans = min(ans, i);\n        }\n        if(dp[1][i][1] < 0){\n            ans = min(ans, i);\n        }\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "///////////////////////////////////////////////////////////////////////////////\n\n#include <bits/stdc++.h>\n#include <unistd.h>\n#include <time.h>\n#include <sys/time.h>\n\nusing namespace std;\n\n///////////////////////////////////////////////////////////////////////////////\n\n#define DEBUG 0\n\n#define pb push_back\n#define V vector\n#define M unordered_map\n#define S static\n#define PI  (3.1415926535)\n\n#define rep(i,n) for(ll i=0LL; i<n; ++i)\n#define srep(i,s,n) for(ll i=s; i<n; ++i)\n#define rrep(i,n) for(ll i=n-1LL; i>=0LL; --i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CIN(x) do { \\\n        assert(!cin.eof()); \\\n        cin >> x; \\\n        assert(!cin.fail()); \\\n} while(0);\n#if DEBUG\n#define debug_print(...) _debug_print(__VA_ARGS__)\n#define debug_printf(...) printf(__VA_ARGS__)\n#define debug_print_time _debug_print_time\n#else // DEBUG\n#define debug_print(...)\n#define debug_printf(...)\n#define debug_print_time\n#endif // DEBUG\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef tuple<ll, ll> t2;\ntypedef tuple<ll, ll, ll> t3;\ntypedef tuple<ll, ll, ll, ll> t4;\ntypedef tuple<ll, ll, ll, ll, ll> t5;\ntemplate <typename T>\nusing priority_queue_incr = priority_queue<T, V<T>, greater<T> >;\n\n///////////////////////////////////////////////////////////////////////////////\n\ntemplate <typename TT, typename T>\nT get_m(M<TT, T> &m, TT k, T default_value)\n{\n    if (m.find(k) == m.end()) return m[k] = default_value;\n    return m[k];\n}\n\ntemplate <typename TT, typename T>\nvoid incr_m(M<TT, T> &m, TT k)\n{\n    if (m.find(k) == m.end()) m[k] = 0;\n    m[k]++;\n}\n\nstruct UnionFind\n{\n    ull *parent, *count, *rank;\n\n    UnionFind(ull n) {\n        parent = new ull[n+1];\n        count = new ull[n+1];\n        rank = new ull[n+1];\n        for (ull i = 0ULL; i < n+1; ++i) {\n            parent[i] = i;\n            count[i] = 1;\n            rank[i] = 0;\n        }\n    }\n\n    ~UnionFind() {\n        delete rank;\n        delete count;\n        delete parent;\n    }\n\n    ull root(ull i) {\n        if (parent[i] == i) return i;\n        parent[i] = root(parent[i]);\n        return parent[i];\n    }\n\n    void unite(ull i, ull j) {\n        ull rooti = root(i);\n        ull rootj = root(j);\n\n        if (rooti == rootj) return;\n\n        if (rank[rootj] < rank[rooti]) {\n            parent[i] = parent[j] = parent[rootj] = rooti;\n            count[rooti] += count[rootj];\n        }\n        else {\n            parent[i] = parent[j] = parent[rooti] = rootj;\n            count[rootj] += count[rooti];\n            if (rank[rootj] == rank[rooti]) rank[rootj]++;\n        }\n    }\n\n    bool same(ull i, ull j) {\n        return root(i) == root(j);\n    }\n};\n\nstruct UnionFindM\n{\n    M<ull, ull> parent, count, rank;\n\n    ull root(ull i) {\n        ull parent_i = get_m(parent, i, i);\n        if (parent_i == i) return i;\n        return parent[i] = root(parent_i);\n    }\n\n    void unite(ull i, ull j) {\n        ull rooti = root(i);\n        ull rootj = root(j);\n\n        if (rooti == rootj) return;\n\n        if (get_m(rank, rootj, 0ULL) < get_m(rank, rooti, 0ULL)) {\n            parent[i] = parent[j] = parent[rootj] = rooti;\n            count[rooti] = get_m(count, rooti, 1ULL) + get_m(count, rootj, 1ULL);\n        }\n        else {\n            parent[i] = parent[j] = parent[rooti] = rootj;\n            count[rootj] = get_m(count, rootj, 1ULL) + get_m(count, rooti, 1ULL);\n            if (get_m(rank, rootj, 0ULL) == get_m(rank, rooti, 0ULL)) rank[rootj]++;\n        }\n    }\n\n    bool same(ull i, ull j) {\n        return root(i) == root(j);\n    }\n};\n\nstruct BIT\n{\n    ll *tree;\n    ll size;\n\n    BIT(ll n, ll init) {\n        tree = new ll[n+1];\n        size = n;\n        this->init(init);\n    }\n\n    void init(ll init) {\n        memset(tree, 0, sizeof(ll) * (size+1));\n        rep (i0, size) {\n            ll idx = i0 + 1LL;\n            while (idx <= size) {\n                tree[idx] += init;\n                idx += (idx & (-idx));\n            }\n        }\n    }\n\n    // idx is 1 origin\n    void add(ll idx, ll x) {\n        assert(idx > 0LL);\n        while (idx <= size) {\n            tree[idx] += x;\n            idx += (idx & (-idx));\n        }\n    }\n\n    // idx is 1 origin\n    ll sum(ll idx) {\n        assert(idx > 0LL);\n        ll ret = 0LL;\n        while (idx > 0LL) {\n            ret += tree[idx];\n            idx -= (idx & (-idx));\n        }\n        return ret;\n    }\n};\n\nstruct MaxFlow {\n    V<ll> links[1005];\n    ll capacities[1005][1005];\n    ll nodes;\n\n    MaxFlow(ll nodes) {\n        // i == 0       --> S\n        // i == nodes+1 --> T\n        rep (i, nodes+2LL) links[i].clear();\n        memset(capacities, 0, sizeof(capacities));\n        this->nodes = nodes;\n    }\n\n    void add_path(ll a, ll b, ll capacity) {\n        links[a].pb(b);\n        links[b].pb(a);\n        capacities[a][b] = capacity;\n        capacities[b][a] = 0LL;\n    }\n\n    ll solve(void) {\n        deque<V<ll> > q;\n        ll ret = 0LL;\n\n        for ( ; ; q.clear()) {\n\n            V<ll> start;\n            start.pb(0);\n            q.push_front(start);\n\n            bool checked[nodes+2];\n            memset(checked, 0, sizeof(checked));\n\n            V<ll> found;\n\n            for ( ; !(q.empty()); ) {\n                V<ll> path = q.front(); q.pop_front();\n                ll last = path[path.size()-1];\n\n                if (checked[last]) continue;\n                if (last == nodes+1) {\n                    found = path;\n                    break;\n                }\n\n                checked[last] = true;\n                for (auto next : (links[last])) {\n                    if (capacities[last][next] == 0) continue;\n                    V<ll> newpath(path);\n                    newpath.pb(next);\n                    q.push_front(newpath);\n                }\n            }\n\n            if (found.size() == 0) {\n                break;\n            }\n            else {\n                ll flowcount = capacities[found[0]][found[1]];\n                rep (i, found.size()-1) {\n                    ll src = found[i];\n                    ll dst = found[i+1];\n                    flowcount = min(flowcount, capacities[src][dst]);\n                }\n                rep (i, found.size()-1) {\n                    ll src = found[i];\n                    ll dst = found[i+1];\n                    capacities[src][dst] -= flowcount;\n                    capacities[dst][src] += flowcount;\n                }\n                ret += flowcount;\n            }\n        }\n\n        return ret;\n    }\n};\n\ntemplate <typename T>\nstruct SegmentTree {\n    T *nodes;\n    t2 *ranges;  // [start, end)\n    ll nodecount;\n    ll itemcount;\n    T unit;\n    T (*op)(T, T);\n\n    SegmentTree(ll itemcount, T unit, T op(T, T)) {\n        ll orig_itemcount = itemcount;\n        this->itemcount = 1LL;\n        while (this->itemcount < orig_itemcount) this->itemcount *= 2LL;\n        nodecount = this->itemcount * 2 - 1;\n        nodes = new T[nodecount];\n        ranges = new t2[nodecount];\n        this->unit = unit;\n        this->op = op;\n\n        ll start = 0LL;\n        ll end = this->itemcount;\n        ll len = this->itemcount;\n\n        rep (i, nodecount) {\n            nodes[i] = unit;\n            ranges[i] = t2(start, end);\n            if (end >= this->itemcount) {\n                len /= 2LL;\n                start = 0LL;\n                end = len;\n            }\n            else {\n                start = end;\n                end = start + len;\n            }\n        }\n    }\n\n    void build(const T arr[]) {\n        memcpy(nodes + nodecount / 2LL, arr, sizeof(T) * itemcount);\n        rrep (i, nodecount / 2LL) {\n            nodes[i] = op(nodes[i * 2LL + 1LL], nodes[i * 2LL + 2LL]);\n        }\n    }\n\n    void update(ll k, T v) {\n        ll idx = k + itemcount - 1LL;\n        nodes[idx] = v;\n        idx = (idx - 1LL) / 2LL;\n\n        for ( ; idx >= 0; idx = (idx - 1LL) / 2LL) {\n            nodes[idx] = op(nodes[idx * 2LL + 1LL],\n                            nodes[idx * 2LL + 2LL]);\n            if (!idx) break;\n        }\n    }\n\n    // query to [start, end)\n    virtual T query(ll start, ll end) const {\n        return _query(start, end, 0LL);\n    }\n\n    virtual T _query(ll start, ll end, ll idx) const {\n        ll rstart = get<0>(ranges[idx]);\n        ll rend = get<1>(ranges[idx]);\n\n        if (start <= rstart && rend <= end) {\n            return nodes[idx];\n        }\n        if (rend <= start || end <= rstart) {\n            return unit;\n        }\n        T left = _query(start, end, idx * 2LL + 1LL);\n        T right = _query(start, end, idx * 2LL + 2LL);\n        return op(left, right);\n    }\n\n    T query_fast(ll start, ll end) const {\n        start += nodecount / 2LL;\n        end += nodecount / 2LL;\n        T lval = unit;\n        T rval = unit;\n        for ( ; start < end; start >>= 1LL, end >>= 1LL) {\n            if (!(start & 1LL)) lval = op(lval, nodes[start]);\n            if (!(end & 1LL)) rval = op(rval, nodes[end-1]);\n            end--;\n        }\n        return op(lval, rval);\n    }\n\n};\n\n//// update : sum / query : range sum\n// ll op(ll x, ll y){ return x + y; }\n// void op_upd(ll &x, ll y) { x += y; }\n// ll op_div(ll x) { return x / 2LL; }\n// ll op_mlt(ll x, ll y) { return x * y; }\n//// update : sum / query : range max\n// ll op(ll x, ll y) { return max(x, y); }\n// void op_upd(ll &x, ll y) { x += y; }\n// ll op_div(ll x) { return x; }\n// ll op_mlt(ll x, ll y) { return x; }\n//// update : substitute / query : range sum\n// ll add(ll x, ll y) { return x + y; }\n// void upd(ll &x, ll y) { x = y; }\n// ll div(ll x) { return x / 2LL; }\n// ll mlt(ll x, ll y) { return x * y; }\ntemplate <typename T>\nstruct SegmentTreeLazy : public SegmentTree<T> {\n    T *lzvals;\n    bool *lzvalids;\n    ll unit_upd;\n    void (*op_upd)(T&, T);\n    T (*op_div)(T);\n    T (*op_mlt)(T, T);\n\n    SegmentTreeLazy(ll itemcount, T unit, T unit_upd,\n                    T op(T, T), void op_upd(T&, T), T op_div(T), T op_mlt(T, T))\n        : SegmentTree<T>(itemcount, unit, op) {\n        this->lzvals = new T[this->nodecount];\n        this->lzvalids = new bool[this->nodecount];\n        this->unit_upd = unit_upd;\n        this->op_upd = op_upd;\n        this->op_div = op_div;\n        this->op_mlt = op_mlt;\n        rep (i, this->nodecount) this->lzvals[i] = unit_upd;\n        memset(this->lzvalids, 0, sizeof(bool) * this->nodecount);\n    }\n\n    // newval = op_upd(oldval, lzval);\n    void eval(ll nodeidx) {\n        if (!lzvalids[nodeidx]) return;\n\n        op_upd(this->nodes[nodeidx], lzvals[nodeidx]);\n\n        if (nodeidx * 2LL + 2LL < this->nodecount) {\n            ll downval = op_div(lzvals[nodeidx]);\n            op_upd(lzvals[nodeidx * 2LL + 1LL], downval);\n            op_upd(lzvals[nodeidx * 2LL + 2LL], downval);\n            lzvalids[nodeidx * 2LL + 1LL] = lzvalids[nodeidx * 2LL + 2LL] = true;\n        }\n\n        lzvalids[nodeidx] = false;\n        lzvals[nodeidx] = this->unit_upd;\n    }\n\n    void update(ll start, ll end, ll val) {\n        _update(start, end, val, 0LL);\n    }\n\n    void _update(ll start, ll end, ll val, ll nodeidx) {\n        eval(nodeidx);\n\n        ll rstart = get<0>(this->ranges[nodeidx]);\n        ll rend = get<1>(this->ranges[nodeidx]);\n        if (end <= rstart || rend <= start) return;\n\n        if (start <= rstart && rend <= end) {\n            op_upd(lzvals[nodeidx], op_mlt(val, rend - rstart));\n            lzvalids[nodeidx] = true;\n            eval(nodeidx);\n        }\n        else {\n            _update(start, end, val, nodeidx * 2LL + 1LL);\n            _update(start, end, val, nodeidx * 2LL + 2LL);\n            this->nodes[nodeidx] = this->op(this->nodes[nodeidx * 2LL + 1LL],\n                                            this->nodes[nodeidx * 2LL + 2LL]);\n        }\n    }\n\n    // query to [start, end)\n    virtual T query(ll start, ll end) {\n        return _query(start, end, 0LL);\n    }\n\n    virtual T _query(ll start, ll end, ll nodeidx) {\n        ll rstart = get<0>(this->ranges[nodeidx]);\n        ll rend = get<1>(this->ranges[nodeidx]);\n\n        eval(nodeidx);\n\n        if (start <= rstart && rend <= end) {\n            return this->nodes[nodeidx];\n        }\n        if (rend <= start || end <= rstart) {\n            return this->unit;\n        }\n        T left = _query(start, end, nodeidx * 2LL + 1LL);\n        T right = _query(start, end, nodeidx * 2LL + 2LL);\n        return this->op(left, right);\n    }\n};\n\nvoid llin(ll &a)\n{\n    CIN(a);\n}\n\nvoid llinl1(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count; ++i) {\n        ll a;\n        CIN(a);\n        v.push_back(a);\n    }\n}\n\nvoid llinl2(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count; ++i) {\n        ll a, b;\n        CIN(a >> b);\n        v.push_back(t2(a, b));\n    }\n}\n\nvoid llinl3(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count; ++i) {\n        ll a, b, c;\n        CIN(a >> b >> c);\n        v.push_back(t3(a, b, c));\n    }\n}\n\nvoid llinl4(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count; ++i) {\n        ll a, b, c, d;\n        CIN(a >> b >> c >> d);\n        v.push_back(t4(a, b, c, d));\n    }\n}\n\nvoid llina(auto &v, ll count)\n{\n    llinl1(v, count);\n}\n\ntemplate <typename T>\nT min(const V<T> v)\n{\n    T ret = v[0];\n    for (auto i : v) ret = min(ret, i);\n    return ret;\n}\n\ntemplate <typename T>\nT max(const V<T> v)\n{\n    T ret = v[0];\n    for (auto i : v) ret = max(ret, i);\n    return ret;\n}\n\nll absll(ll x)\n{\n    if (x < 0) return -x;\n    return x;\n}\n\nll mod_mlt(ll x, ll y, ll mod)\n{\n    ll ret = 0LL;\n    x %= mod;\n\n    while (y) {\n        if (y & 1LL) {\n            ret += x;\n            ret %= mod;\n        }\n        y >>= 1;\n        x <<= 1;\n        x %= mod;\n    }\n\n    return ret;\n}\n\n// O(log(exp))\nll mod_pow(ll base, ll exp, ll mod)\n{\n    ll ret = 1LL;\n\n    for ( ; exp; ) {\n        if (exp & 1LL) {\n            ret *= base;\n            ret %= mod;\n        }\n        base = (base * base) % mod;\n        exp >>= 1;\n    }\n\n    return ret;\n}\n\n// O(log(mod))\nll mod_inv(ll x, ll mod)\n{\n    // available only when mod is prime\n    return mod_pow(x, mod - 2LL, mod);\n}\n\nll gcm(ll x, ll y)\n{\n    while (y != 0) {\n        ll z = x % y;\n        x = y;\n        y = z;\n    }\n    return x;\n}\n\ntemplate <typename T>\nvoid sort(V<T> &v)\n{\n    sort(v.begin(), v.end());\n}\n\ntemplate <typename T>\nvoid sort_reverse(V<T> &v)\n{\n    sort(v.begin(), v.end(), greater<T>());\n}\n\nvoid get_divisors(V<ll> &retlist, ll x)\n{\n    for (ll i = 1LL; i < sqrt(x) + 3LL; ++i) {\n        if (x % i == 0LL) {\n            retlist.push_back(i);\n            retlist.push_back(x / i);\n        }\n    }\n}\n\n// returns factors and 1\nvoid get_factors(V<ll> &retlist, ll x)\n{\n    retlist.pb(1LL);\n    for (ll i = 2LL; i < (ll)(sqrt(x)) + 3LL; ++i) {\n        while (x % i == 0LL) {\n            retlist.pb(i);\n            x /= i;\n        }\n    }\n    retlist.pb(x);\n}\n\nbool is_prime(ll x)\n{\n    V<ll> factors, factors2;\n\n    get_factors(factors, x);\n\n    for (auto factor : factors) {\n        if (factor > 1) factors2.pb(factor);\n    }\n\n    return factors2.size() == 1 && x == factors2[0];\n}\n\ntemplate <typename T>\nvoid intersection(const set<T> &a, const set<T> &b,\n                  set<T> &result)\n{\n    set_intersection(ALL(a), ALL(b), inserter(result, result.end()));\n}\n\null combination(ll x, ll y)\n{\n    if (y > x / 2LL) y = x - y;\n\n    ull ret = 1LL;\n    for (ll i = 0LL; i < y; ++i) {\n        ret *= x--;\n        ret /= (i + 1LL);\n    }\n\n    return ret;\n}\n\null mod_combination(ll x, ll y, ll mod)\n{\n    if (y > x / 2LL) y = x - y;\n\n    ll ret = 1;\n\n    for (ll i = 0LL; i < y; ++i) {\n        ret = (ret * x--) % mod;\n        ret = (ret * mod_inv(i + 1LL, mod)) % mod;\n    }\n\n    return ret;\n}\n\nvoid make_perms(ll perms[], ll perm_invs[], ll size, ll mod)\n{\n    perms[0] = 1LL;\n    srep (i, 1, size) {\n        perms[i] = perms[i-1] * i;\n        perms[i] %= mod;\n    }\n\n    rep (i, size) {\n        perm_invs[i] = mod_inv(perms[i], mod);\n    }\n}\n\n#if 0\nS V<ll> edgelist[n+1];\n#endif\nvoid make_edgelist(const V<t2> &srclist, V<ll> edgelist[])\n{\n    for (auto src : srclist) {\n        ll a = get<0>(src);\n        ll b = get<1>(src);\n        edgelist[a].pb(b);\n        edgelist[b].pb(a);\n    }\n}\n\n#if 0\nS ll parents[n+1];\nS V<ll> children[n+1];\nS ll levels[n+1];\n#endif\nvoid make_parental_relation(const V<ll> edgelist[], ll root, ll n,\n                            ll parents[], V<ll> children[], ll levels[])\n{\n    queue<ll> q;\n    bool checked[n+1];\n\n    memset(checked, 0, sizeof(checked));\n\n    q.push(root);\n    checked[root] = true;\n    parents[root] = root;\n    levels[root] = 0LL;\n\n    for ( ; !(q.empty()); ) {\n        ll now = q.front(); q.pop();\n        for (auto next : edgelist[now]) {\n            if (checked[next]) continue;\n            q.push(next);\n            checked[next] = true;\n            parents[next] = now;\n            children[now].pb(next);\n            levels[next] = levels[now] + 1LL;\n        }\n    }\n}\n\nvoid make_subtree_sizes(const ll child_count[], const ll parents[],\n                        ll subtree_sizes[], ll n)\n{\n    ll remain_count[n+1LL];\n    memcpy(remain_count, child_count, sizeof(remain_count));\n\n    queue<ll> q;\n    srep (node, 1LL, n+1LL) {\n        subtree_sizes[node] = 1LL;\n        if (remain_count[node] > 0) continue;\n        q.push(node);\n    }\n\n    while (!q.empty()) {\n        ll node = q.front(); q.pop();\n        ll parent = parents[node];\n        if (node == parent) continue;\n        remain_count[parent]--;\n        subtree_sizes[parent] += subtree_sizes[node];\n        if (remain_count[parent] == 0LL) q.push(parent);\n    }\n}\n\nvoid get_centroids(const V<ll> children[], const ll subtree_sizes[],\n                   ll root, ll n, V<ll> &centroids)\n{\n    queue<ll> q;\n    q.push(root);\n\n    while (!q.empty()) {\n        ll now = q.front(); q.pop();\n        bool is_centroid = true;\n        for (auto child : children[now]) {\n            q.push(child);\n            if (subtree_sizes[child] > n / 2LL) is_centroid = false;\n        }\n        if (n - subtree_sizes[now] > n / 2LL) is_centroid = false;\n        if (is_centroid) centroids.pb(now);\n    }\n\n    assert(centroids.size() == 1LL || centroids.size() == 2LL);\n}\n\n#define POW_ANCESTOR_MAXSIZE   20\n\n// preprocess for get_common_ancestor()\nvoid make_pow_ancestor(const ll parent[], ll n,\n                       ll (*pow_ancestor)[POW_ANCESTOR_MAXSIZE])\n{\n    rep (i, n) pow_ancestor[i+1][0] = parent[i+1];\n\n    for (int pow2 = 1; pow(2, pow2) <= n; ++pow2) {\n        rep (i0, n) {\n            int i = i0+1;\n            ll prev = pow_ancestor[i][pow2-1];\n            pow_ancestor[i][pow2] = pow_ancestor[prev][pow2-1];\n        }\n    }\n}\n\nll get_common_ancestor(ll n, ll x, ll y,\n                       const ll (*pow_ancestor)[POW_ANCESTOR_MAXSIZE],\n                       const ll level[])\n{\n    if (level[x] < level[y]) {\n        ll diff = level[y] - level[x];\n        for ( ; diff; ) {\n            ll bit = diff & -diff;\n            y = pow_ancestor[y][(int)log2(bit)];\n            diff -= bit;\n        }\n    }\n    else {\n        ll diff = level[x] - level[y];\n        for ( ; diff; ) {\n            ll bit = diff & -diff;\n            x = pow_ancestor[x][(int)log2(bit)];\n            diff -= bit;\n        }\n    }\n\n    if (x == y) return x;\n\n    rrep (i, (int)log2(n)+1) {\n        if (pow_ancestor[x][i] != pow_ancestor[y][i]) {\n            x = pow_ancestor[x][i];\n            y = pow_ancestor[y][i];\n        }\n    }\n\n    return pow_ancestor[x][0];\n}\n\nvoid kmp_init(const string &pattern, ll kmp_next[])\n{\n    kmp_next[0] = -1LL;\n\n    ll plen = pattern.size();\n    ll prefix_end = -1;\n\n    rep (suffix_end, pattern.size()) {\n        while (prefix_end >= 0 && pattern[suffix_end] != pattern[prefix_end]) {\n            prefix_end = kmp_next[prefix_end];\n        }\n        kmp_next[suffix_end+1] = ++prefix_end;\n    }\n\n    kmp_next[0] = 0LL;\n}\n\n// founds ... list of text's idx of match position. start position idx.\nvoid kmp_search(const string &text, const string &pattern, const ll kmp_next[],\n                V<ll> &founds)\n{\n    ll text_size = text.size();\n    ll pattern_size = pattern.size();\n    ll text_start = 0LL;\n    ll pattern_idx = 0LL;\n\n    assert(pattern_size <= text_size);\n\n    for ( ; ; ) {\n        if (text_start + pattern_idx >= text_size) break;\n        if (pattern_idx >= pattern_size) break;\n\n        if (text[text_start+pattern_idx] == pattern[pattern_idx]) {\n            pattern_idx++;\n            if (pattern_idx == pattern_size) {\n                founds.pb(text_start);\n                pattern_idx = kmp_next[pattern_idx];\n                text_start += (pattern_size - pattern_idx);\n            }\n        }\n\n        else {\n            text_start += (pattern_idx - kmp_next[pattern_idx]);\n            pattern_idx = kmp_next[pattern_idx];\n            if (pattern_idx == 0LL && text[text_start] != pattern[0]) {\n                text_start++;\n            }\n        }\n    }\n}\n\nvoid z_algorithm(ll matchcounts[], const string &str)\n{\n    ll n = str.size();\n    ll base_idx = 0LL;\n    memset(matchcounts, 0, sizeof(ll) * n);\n\n    srep (idx, 1LL, n) {\n\n        ll checked_len = base_idx + matchcounts[base_idx];\n\n        if (idx + matchcounts[idx-base_idx] < checked_len) {\n            matchcounts[idx] = matchcounts[idx-base_idx];\n            continue;\n        }\n\n        ll start = max(0LL, base_idx + matchcounts[base_idx] - idx);\n        matchcounts[idx] = start;\n        srep (cmp, start, n-idx) {\n            if (str[cmp] == str[idx+cmp]) matchcounts[idx]++;\n            else break;\n        }\n        base_idx = idx;\n\n    }\n\n    matchcounts[0] = n;\n}\n\nvoid _manacher(V<ll> &rlist, const string &s)\n{\n    ll n = s.size();\n    rep (i, n) rlist.pb(1);\n\n    ll center = -1;\n\n    rep (i, n) {\n        assert(center < i);\n        if (center < 0) {\n            center = 0;\n            continue;\n        }\n\n        ll opi = center - (i - center);\n        if (opi <= center - rlist[center]) {\n            rlist[i] = 1LL;\n            ll d = 1LL;\n            while (i-d >= 0 && i+d < n && s[i-d] == s[i+d]) rlist[i]++, d++;\n            center = i;\n            continue;\n        }\n\n        if (i + rlist[opi] < center + rlist[center]) {\n            rlist[i] = rlist[opi];\n            continue;\n        }\n\n        rlist[i] = center + rlist[center] - i;\n        ll d = center + rlist[center] - i;\n        while (i-d >= 0 && i+d < n && s[i-d] == s[i+d]) rlist[i]++, d++;\n        center = i;\n    }\n}\n\nvoid manacher(V<ll> &r_oddlist, V<ll> &r_evenlist, const string &s)\n{\n    _manacher(r_oddlist, s);\n\n    string ps;\n    ps += s[0];\n    srep (i, 1, s.size()) {\n        ps += \"$\";\n        ps += s[i];\n    }\n\n    V<ll> tmpr;\n    _manacher(tmpr, ps);\n    rep (i, s.size()-1) r_evenlist.pb(tmpr[i*2+1] / 2LL);\n    r_evenlist.pb(0LL);\n}\n\ndouble xy_distance(double x1, double y1, double x2, double y2)\n{\n    double xx = (x1 - x2) * (x1 - x2);\n    double yy = (y1 - y2) * (y1 - y2);\n    return sqrt(xx + yy);\n}\n\ndouble heron(double a, double b, double c)\n{\n    double s = (a + b + c) / 2.;\n    double ret = 1.;\n    ret *= s;\n    ret *= (s - a);\n    ret *= (s - b);\n    ret *= (s - c);\n    ret = sqrt(ret);\n    return ret;\n}\n\ndouble rad_normarize(double rad)\n{\n    while (rad < -PI) rad += 2. * PI;\n    while (rad > PI) rad -= 2. * PI;\n    return rad;\n}\n\nvoid _debug_print(auto x)\n{\n    cout << x << endl;\n}\n\nvoid _debug_print(const t2 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2 << endl;\n}\n\nvoid _debug_print(const t3 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    ll x3 = get<2>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2 << \" -- \" << x3 << endl;\n}\n\nvoid _debug_print(const t4 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    ll x3 = get<2>(x);\n    ll x4 = get<3>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2\n         << \" -- \" << x3 << \" -- \" << x4 << endl;\n}\n\ntemplate <typename T>\nvoid _debug_print(T xarray[], ll n)\n{\n    rep (i, n) _debug_print(xarray[i]);\n}\n\ntemplate <typename T>\nvoid _debug_print(const V<T> &xlist)\n{\n    for (auto x : xlist) {\n        cout << \"-- \";\n        _debug_print(x);\n    }\n}\n\ntemplate <typename T>\nvoid _debug_print(const set<T> &xset)\n{\n    for (auto x : xset) {\n        cout << \"-- \";\n        _debug_print(x);\n    }\n}\n\ntemplate <typename TT, typename T>\nvoid _debug_print(const M<TT, T> &xlist)\n{\n    for (auto x : xlist) {\n        TT k = x.first;\n        T v = x.second;\n        cout << \"====\" << endl;\n        cout << \"K=\";\n        _debug_print(k);\n        cout << \"V=\";\n        _debug_print(v);\n    }\n}\n\nvoid _debug_print_time(const char *prefix)\n{\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    struct tm *tm = localtime(&tv.tv_sec);\n    printf(\"-- %s %02d:%02d:%02d.%06ld\\n\",\n           prefix, tm->tm_hour, tm->tm_min, tm->tm_sec, tv.tv_usec);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\nvoid _main();\nint main()\n{\n    cout << setprecision(12);\n#if 0\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n\n    _main();\n    return 0;\n}\n\nvoid _main()\n{\n    ll n; llin(n);\n    S V<ll> alist; alist.pb(1e18); llina(alist, n);\n    S V<t2> uvlist; llinl2(uvlist, n-1);\n\n    if (n == 1) {\n        cout << 0 << endl;\n        return;\n    }\n\n    S V<ll> edgelist[5005];\n    make_edgelist(uvlist, edgelist);\n\n    S ll parents[5005];\n    S V<ll> children[5005];\n    S ll levels[5005];\n    make_parental_relation(edgelist, 1, n+1,parents, children, levels);\n\n    S ll cldcnts[5005];\n    srep (v, 1, n+1) cldcnts[v] = children[v].size();\n\n    S queue<ll> q;\n    S ll dp0[5005][5005];\n    S ll dp1[5005][5005];\n    rep (i, 5005) rep (j, 5005) dp0[i][j] = 1e18;\n    rep (i, 5005) rep (j, 5005) dp1[i][j] = 1e18;\n\n    S ll vcnts[5005] = {};\n    rep (v, 5005) vcnts[v] = 1;\n\n    srep (v, 1, n+1) if (cldcnts[v] == 0) {\n        q.push(v);\n        if (alist[v] > 0) dp0[v][0] = alist[v];\n        dp1[v][0] = alist[v];\n    }\n\n    while (q.size()) {\n        ll v = q.front(); q.pop();\n        ll pv = parents[v];\n        if (v == pv) continue;\n        cldcnts[pv]--;\n        if (cldcnts[pv]) continue;\n\n        v = pv;\n        ll a = alist[v];\n        q.push(v);\n        if (a > 0) dp0[v][0] = a;\n        dp1[v][0] = a;\n\n        for (auto cv : children[v]) {\n            S ll dp0_prev[5005];\n            S ll dp1_prev[5005];\n            memcpy(dp0_prev, dp0[v], sizeof(dp0_prev));\n            memcpy(dp1_prev, dp1[v], sizeof(dp1_prev));\n            rep (i, 5005) dp0[v][i] = 1e18;\n            rep (i, 5005) dp1[v][i] = 1e18;\n            rep (i, vcnts[v]) {\n                rep (j, vcnts[cv]) {\n                    if (a > 0) {\n                        dp0[v][i+j] = min(dp0[v][i+j], dp0_prev[i] + dp0[cv][j]);\n                        if (dp0[cv][j] < 1e17 || dp1[cv][j] < 0) dp0[v][i+j+1] = min(dp0[v][i+j+1], dp0_prev[i]);\n                    }\n                    dp1[v][i+j] = min(dp1[v][i+j], dp1_prev[i] + dp1[cv][j]);\n                    if (dp0[cv][j] < 1e17 || dp1[cv][j] < 0) dp1[v][i+j+1] = min(dp1[v][i+j+1], dp1_prev[i]);\n                }\n            }\n            vcnts[v] += vcnts[cv];\n        }\n    }\n\n    debug_printf(\"---- vcnts\\n\");\n    debug_print(vcnts, n+1);\n    debug_printf(\"---- dp0_v1\\n\");\n    debug_print(dp0[1], 3);\n    debug_printf(\"---- dp0_v2\\n\");\n    debug_print(dp0[2], 3);\n    debug_printf(\"---- dp1_v1\\n\");\n    debug_print(dp1[1], 3);\n    debug_printf(\"---- dp1_v2\\n\");\n    debug_print(dp1[2], 3);\n\n    debug_printf(\"---- ans\\n\");\n    rep (i, 5005) {\n        if (dp0[1][i] < 1e17) {\n            cout << i << endl;\n            return;\n        }\n        if (dp1[1][i] < 0) {\n            cout << i << endl;\n            return;\n        }\n    }\n\n    assert(false);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\n#include <unordered_map>\nusing namespace std;\n\n#define REP(i, s) for (int i = 0; i < s; ++i)\n#define ALL(v) (v.begin(), v.end())\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\ntemplate<class T> ostream& operator << (ostream &s, set<T> P)\n{ EACH(it, P) { s << \"<\" << *it << \"> \"; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P)\n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s << endl; }\n\nconst long long INF = 1LL<<60;\nconst int MAX = 5100;\n\nint N;\nvector<long long> A;\nvector<vector<int> > G;\n\nint num[MAX];\nlong long dp[MAX][MAX][2]; // vの部分木、vを含めず何個か、(全部正かどうか)\nlong long sdp[2][MAX][2];\n\nvoid rec(int v, int p) {\n    int numc = 0;\n    num[v] = 1;\n    for (auto ch : G[v]) {\n        if (ch == p) continue;\n        rec(ch, v);\n        ++numc;\n        num[v] += num[ch];\n    }\n    \n    for (int i = 0; i < 2; ++i) for (int j = 0; j <= num[v]; ++j)\n        sdp[i][j][0] = sdp[i][j][1] = INF;\n    \n    sdp[0][0][0] = A[v];\n    if (A[v] > 0) sdp[0][0][1] = A[v];\n    \n    int i = 0;\n    for (auto ch : G[v]) {\n        if (ch == p) continue;\n        for (int j = 0; j <= num[v]; ++j) {\n            for (int k = 0; k <= num[ch] && j+k <= num[v]; ++k) {\n                chmin(sdp[(i+1)%2][j+k][0], sdp[i%2][j][0] + dp[ch][k][0]);\n                chmin(sdp[(i+1)%2][j+k][0], sdp[i%2][j][0] + dp[ch][k][1]);\n                if (dp[ch][k][0] < 0) chmin(sdp[(i+1)%2][j+k+1][0], sdp[i%2][j][0]);\n                if (dp[ch][k][1] < INF/2) chmin(sdp[(i+1)%2][j+k+1][0], sdp[i%2][j][0]);\n                if (A[v] > 0) {\n                    chmin(sdp[(i+1)%2][j+k][1], sdp[i%2][j][1] + dp[ch][k][1]);\n                    if (dp[ch][k][0] < 0) chmin(sdp[(i+1)%2][j+k+1][1], sdp[i%2][j][1]);\n                    if (dp[ch][k][1] < INF/2) chmin(sdp[(i+1)%2][j+k+1][1], sdp[i%2][j][1]);\n                }\n            }\n        }\n        for (int j = 0; j <= num[v]; ++j) sdp[i%2][j][0] = sdp[i%2][j][1] = INF;\n        ++i;\n    }\n    for (int j = 0; j <= num[v]; ++j) {\n        dp[v][j][0] = sdp[numc%2][j][0];\n        dp[v][j][1] = sdp[numc%2][j][1];\n        \n        //cout << v << \", \" << j << \": \" << make_pair(dp[v][j][0], dp[v][j][1]) << endl;\n    }\n}\n\nint main() {\n    while (cin >> N) {\n        A.resize(N);\n        for (int i = 0; i < N; ++i) cin >> A[i];\n        G.assign(N, vector<int>());\n        for (int i = 0; i < N-1; ++i) {\n            int u, v; cin >> u >> v; --u, --v;\n            G[u].push_back(v);\n            G[v].push_back(u);\n        }\n        for (int i = 0; i < MAX; ++i) for (int j = 0; j < MAX; ++j)\n            dp[i][j][0] = dp[i][j][1] = INF;\n        rec(0, -1);\n        int res = N;\n        for (int i = 0; i <= N; ++i) {\n            if (dp[0][i][0] < 0) chmin(res, i);\n            if (dp[0][i][1] < INF/2) chmin(res, i);\n        }\n        cout << res << endl;\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nusing Graph = vector<vector<int>>;\nconst int INF = 1e9;\nGraph G;\nvector<int> A;\nvector<int> B;\nvector<vector<int>> C;\nint neg(const vector<int> &A) {\n    for (int i = 0; i < A.size(); i++) {\n        if (A[i] < 0) return i;\n    }\n    return INF;\n}\nvector<int> f(const vector<int> &A, const vector<int> &B) {\n    vector<int> ans(A.size() + B.size() - 1, INF);\n    for (int i = 0; i < A.size(); i++) {\n        for (int j = 0; j < B.size(); j++) {\n            ans[i + j] = min(ans[i + j], A[i] + B[j]);\n        }\n    }\n    return ans;\n}\nvoid recur(int node, int prev) {\n    for (auto next : G[node]) if (next != prev) {\n        recur(next, node);\n    }\n    if (A[node] > 0) {\n        B[node] = 0;\n        for (auto next : G[node]) if (next != prev) {\n            if (A[next] > 0) {\n                B[node] += B[next];\n            } else {\n                B[node] += neg(C[next]) + 1;\n            }\n        }\n    }\n    vector<int> X = {A[node]};\n    for (auto next : G[node]) if (next != prev) {\n        X = f(X, C[next]);\n    }\n    if (A[node] > 0) {\n        X.resize(max((int)X.size(), B[node] + 1 + 1), INF);\n        X[B[node] + 1] = min(X[B[node] + 1], 0);\n    }\n    C[node] = X;\n}\nint main() {\n    int N; cin >> N;\n    G.resize(N);\n    A.resize(N); for (auto &a : A) cin >> a;\n    B.resize(N, INF);\n    C.resize(N);\n    for (int i = 0; i < N - 1; i++) {\n        int u, v; cin >> u >> v; u--, v--;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    recur(0, -1);\n    cout << min(B[0], neg(C[0])) << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\n/*\nsum<0なら0で終わり\nそうじゃないなら？必ず正だけの地点を作る\n根付き木にしてdp？\ndp[i][j]:部分根付き木iまででj本切った時の最小値(iの上の部分を切ることも考えてる)\n葉lに対してdp[l][0]=v[l],dp[l][1]=0;\n親pに対して子をsとして、dp[p][k]=それぞれのそれ\nつまり？dp[p][k]はmin(sum(dp[s][j]:sum j = k))\n高速化の方法は？\nえーなんかdpまでは絶対に合っていると思っていて、\n+のやつを取るところに関しては+をなるべく大量に消費して欲しくて、マイナスは一個も入っちゃいけない\n-が入る方は、+にならないようになるべく大きく取りたい\n実は葉から貪欲？最後にくっつけられるところはくっつけていいとか\n根付き木にして、葉から貪欲にやっていく　具体的には\n・スタートが+の時\n+で有る限り取り続ける\n-が来た場合、-が大きくなるなら取って変更\n・スタートが-の時\n合計が負で有る限り取り続ける\n\n貪欲が終わった時塊は　a:全部+で次の-入れても+ or b:合計が負で次のやつで+\n・貪欲をした後\n自分の子とくっつけられるかを試す？\n自分がaの時　aは子の候補にいなくて、bは絶対無理　なので終わり\n自分がbの時　子のbは全部取り込める\n　　　　　　 これで子のaも取り込めるし次の+も取り込める場合は？\n　　　　　　　・子のaを取り込むメリット:そのさらに子を取り込める可能性が出てくる\nまってそもそも合流を考えられていない　いやそれは大丈夫かも\n*/\nint dp1[5123][5123],//dp1[v][k]:v以下k個、vのところは全部正の時のその最小値\n    dp2[5123][5123],//dp2[v][k]:v以下k個、vの所の最小値\n    dpt1[5123][5123],//dpt1[i][j]:vのi番目までの子までからなる部分木をdp1と同様にj個に分ける時の一番上の最小値\n    dpt2[5123][5123];//dpt2[i][j]:同様\n\nconst int INF=1e18;\n\ntemplate<typename T>\nvoid fin(T a){\n  cout<<a<<endl;\n  exit(0);\n}\n\ntemplate<typename T>\nvoid chmin(T &a,T b){\n  if(a>b)a=b;\n}\ntemplate<typename T>\nvoid chmax(T &a,T b){\n  if(a<b)a=b;\n}\n\nsigned main(){\n  int n;cin>>n;\n  vector<int> v(n);\n  for(int i=0;i<n;i++)cin>>v[i];\n  vector<int> edge[n];\n  for(int i=1;i<n;i++){\n    int u,v;cin>>u>>v;u--;v--;\n    edge[u].push_back(v);\n    edge[v].push_back(u);\n  }\n\n  int sum=0;for(int i=0;i<n;i++)sum+=v[i];if(sum<0)fin(0);\n\n  int r;int m=0;\n  for(int i=0;i<n;i++)\n    if(m<edge[i].size())\n      m=edge[i].size(),r=i;\n\n  vector<int> parent(n),son[n],d1(n,0),d2(n,0);\n  parent[r]=-1;\n  queue<int> que;\n  que.push(r);\n  while(que.size()){\n    int p=que.front();que.pop();\n    for(int q:edge[p]){\n      if(parent[p]==q)continue;\n      parent[q]=p;\n      son[p].push_back(q);\n      que.push(q);\n    }\n  }\n\n  for(int i=0;i<5123;i++)\n    for(int j=0;j<5123;j++)\n      dp1[i][j]=dp2[i][j]=dpt1[i][j]=dpt2[i][j]=INF;\n\n  vector<int> rem(n);\n  for(int i=0;i<n;i++)rem[i]=son[i].size();\n  for(int i=0;i<n;i++)if(!rem[i])que.push(i);\n\n  while(que.size()){\n    int p=que.front();que.pop();\n\n    dpt1[0][0]=0;\n\n    int N=son[p].size();\n\n    int nowj=0,tmpj=0;\n    for(int i=0;i<N;i++){\n      int q=son[p][i];\n      for(int j=0;j<=nowj;j++){\n        if(dpt1[i][j]==INF)continue;\n        for(int k=0;k<=d1[q];k++){\n          if(dp1[q][k]==INF)continue;\n          chmin(dpt1[i+1][j+k],dpt1[i][j]+dp1[q][k]);\n          chmax(tmpj,j+k);\n        }\n        dpt1[i][j]=INF;\n      }\n      nowj=tmpj;\n      tmpj=0;\n    }\n\n    for(int k=0;k<=nowj;k++){\n      if(dpt1[N][k]==INF)continue;\n      if(v[p]>0){\n        chmin(dp1[p][k],dpt1[N][k]+v[p]);\n        chmax(d1[p],k);\n        chmin(dp2[p][k+1],0LL);\n        chmax(d2[p],k+1);\n      }\n      dpt1[N][k]=INF;\n    }\n\n    dpt2[0][0]=0;\n\n    nowj=tmpj=0;\n    for(int i=0;i<N;i++){\n      int q=son[p][i];\n      for(int j=0;j<=nowj;j++){\n        if(dpt2[i][j]==INF)continue;\n        for(int k=0;k<=d2[q];k++){\n          if(dp2[q][k]==INF)continue;\n          chmin(dpt2[i+1][j+k],dpt2[i][j]+dp2[q][k]);\n          chmax(tmpj,j+k);\n        }\n        dpt2[i][j]=INF;\n      }\n      nowj=tmpj;\n      tmpj=0;\n    }\n\n    for(int k=0;k<=nowj;k++){\n      if(dpt2[N][k]==INF)continue;\n      chmin(dp2[p][k],dpt2[N][k]+v[p]);\n      chmax(d2[p],k);\n      if(dpt2[N][k]+v[p]<0){\n        chmin(dp1[p][k+1],0LL);\n        chmax(d1[p],k+1);\n        chmin(dp2[p][k+1],0LL);\n        chmax(d2[p],k+1);\n      }\n      dpt2[N][k]=INF;\n    }\n    if(~parent[p]&&--rem[parent[p]]==0)que.push(parent[p]);\n  }\n\n  int ans=INF;\n  for(int j=0;j<5000;j++){\n    if(dp1[r][j]!=INF)chmin(ans,j);\n    if(dp2[r][j]<0)chmin(ans,j);\n  }\n\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define debug(a) cout << #a << \": \" << a << endl\n#define debuga1(a, l, r) fto(i, l, r) cout << a[i] << \" \"; cout << endl\n#define fdto(i, r, l) for(int i = (r); i >= (l); --i)\n#define fto(i, l, r) for(int i = (l); i <= (r); ++i)\n#define ff first\n#define ss second\n#define mp make_pair\n#define pb push_back\n#define sz(a) (int)a.size()\n\nconst double PI = acos(-1.0);\n\ndouble fRand(double fMin, double fMax)\n{\n    double f = (double)rand() / RAND_MAX;\n    return fMin + f * (fMax - fMin);\n}\n\ntemplate <class T>\nT min(T a, T b, T c) {\n    return min(a, min(b, c));\n}\n\ntemplate <class T>\nT max(T a, T b, T c) {\n    return max(a, max(b, c));\n}\n\nconst int MAXN = 5005;\nconst ll oo = 1e18;\n\nvoid minimize(ll &a, ll b) {a = min(a, b);}\n\nint n, a[MAXN], siz[MAXN];\nvector<int> g[MAXN];\nll dp[MAXN][MAXN][2];\n\nvoid DFS(int u, int par) {\n    dp[u][0][a[u] < 0] = a[u];\n    siz[u] = 1;\n\n    for(int v: g[u]) {\n        if (v == par) continue;\n\n        DFS(v, u);\n\n        vector<vector<ll> > tmp(siz[u], vector<ll>(2, 0));\n        fto(a, 0, siz[u]-1) {\n            fto(compU, 0, 1) {\n                tmp[a][compU] = dp[u][a][compU];\n                dp[u][a][compU] = oo;\n            }\n        }\n\n        fto(a, 0, siz[u]-1) {\n            fto(b, 0, siz[v]-1) {\n                fto(compU, 0, 1) {\n                    if (tmp[a][compU] == oo) continue;\n                    fto(compV, 0, 1)\n                        minimize(dp[u][a+b][compU|compV], tmp[a][compU] + dp[v][b][compV]);\n                    if (dp[v][b][0] < oo)\n                        minimize(dp[u][a+b+1][compU], tmp[a][compU]);\n                    if (dp[v][b][1] < 0)\n                        minimize(dp[u][a+b+1][compU], tmp[a][compU]);\n                }\n            }\n        }\n\n//        debug(u);\n//        fto(comp, 0, 1) {\n//            debug(comp);\n//            fto(k, 0, n) printf(\"%lld \", dp[u][k][comp]);\n//            puts(\"\");\n//        }\n//        puts(\"\");\n\n        siz[u] += siz[v];\n    }\n}\n\nint main () {\n    scanf(\"%d\", &n);\n    fto(i, 1, n) scanf(\"%d\", &a[i]);\n    fto(i, 1, n-1) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        g[u].pb(v); g[v].pb(u);\n    }\n\n    fto(u, 1, n)\n        fto(k, 0, n)\n            fto(comp, 0, 1)\n                dp[u][k][comp] = oo;\n\n    DFS(1, -1);\n\n//    fto(comp, 0, 1) {\n//        debug(comp);\n//        fto(u, 1, n) {\n//            fto(k, 0, n) printf(\"%lld \", dp[u][k][comp]);\n//            puts(\"\");\n//        }\n//    }\n\n    int ans = n;\n    fto(k, 0, n-1) {\n        if (dp[1][k][0] < oo)\n            ans = min(ans, k);\n        if (dp[1][k][1] < 0)\n            ans = min(ans, k);\n    }\n\n    printf(\"%d\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nusing Graph = vector<vector<int>>;\nconst Int INF = 1e18;\nGraph G;\nvector<int> A;\nvector<Int> B;\nvector<vector<Int>> C;\nInt neg(const vector<Int> &A) {\n    for (int i = 0; i < A.size(); i++) {\n        if (A[i] < 0) return i;\n    }\n    return INF;\n}\nvector<Int> f(const vector<Int> &A, const vector<Int> &B) {\n    vector<Int> ans(A.size() + B.size() - 1, INF);\n    for (int i = 0; i < A.size(); i++) {\n        for (int j = 0; j < B.size(); j++) {\n            ans[i + j] = min(ans[i + j], A[i] + B[j]);\n        }\n    }\n    return ans;\n}\nvoid recur(int node, int prev) {\n    for (auto next : G[node]) if (next != prev) {\n        recur(next, node);\n    }\n    if (A[node] > 0) {\n        B[node] = 0;\n        for (auto next : G[node]) if (next != prev) {\n            if (A[next] > 0) {\n                B[node] += B[next];\n            } else {\n                B[node] += neg(C[next]) + 1;\n            }\n        }\n    }\n    vector<Int> X = {A[node]};\n    for (auto next : G[node]) if (next != prev) {\n        X = f(X, C[next]);\n    }\n    if (A[node] > 0) {\n        X.resize(max((Int)X.size(), B[node] + 1 + 1), INF);\n        X[B[node] + 1] = min(X[B[node] + 1], 0LL);\n    }\n    C[node] = X;\n}\nint main() {\n    int N; cin >> N;\n    G.resize(N);\n    A.resize(N); for (auto &a : A) cin >> a;\n    B.resize(N, INF);\n    C.resize(N);\n    for (int i = 0; i < N - 1; i++) {\n        int u, v; cin >> u >> v; u--, v--;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    recur(0, -1);\n    cout << min(B[0], neg(C[0])) << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <complex>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\nusing namespace std;\n \n#define mod 1000000007\n#define FOR(x,to) for(int x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define long long long\ninline int rei(){int x;cin>>x;return x;}\ninline long rel(){long x;cin>>x;return x;}\ninline string res(){string x;cin>>x;return x;}\n//------------------------------------------------------- \nlong DP1[25000000];\nlong buffer[5000];\nint dp1[5000];\nint DP2[5000];\nint child[5000];\nlong A[5000];\nvector<int> G[5000];\nvoid Calc(){\n\tint N = rei();\n\tfor(int i=0;i<N;i++){\n\t\tA[i] = rel();\n\t}\n\tfor(int i=0;i<N-1;i++){\n\t\tint v = rei()-1;\n\t\tint u = rei()-1;\n\t\tG[v].push_back(u);\n\t\tG[u].push_back(v);\n\t}\n\tstack<pair<int,int>> sp;\n\tsp.push({0,-1});\n\twhile(!sp.empty()){\n\t\tint v = sp.top().first;\n\t\tint f = sp.top().second;\n\t\tsp.pop();\n\t\tif(v >= N){\n\t\t\tv -= N;\n\t\t\tif(A[v] > 0){\n\t\t\t\tint c = 0;\n\t\t\t\tfor(int t:G[v]){\n\t\t\t\t\tif(t != f){\n\t\t\t\t\t\tc += min(DP2[t],dp1[t]+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tDP2[v] = c;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tDP2[v] = 10000;\n\t\t\t}\n\t\t\t{\n\t\t\t\tint ch = 1;\n\t\t\t\tDP1[v*5000] = A[v];\n\t\t\t\tfor(int t:G[v]){\n\t\t\t\t\tif(t != f){\n\t\t\t\t\t\tfor(int i=0;i<ch+child[t];i++){\n\t\t\t\t\t\t\tbuffer[i] = 100000000000000000;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int i=ch-1;i>=0;i--){\n\t\t\t\t\t\t\tbuffer[i+dp1[t]+1] = min(buffer[i+dp1[t]+1],DP1[v*5000+i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int i=ch-1;i>=0;i--){\n\t\t\t\t\t\t\tfor(int j=child[t]-1;j>=0;j--){\n\t\t\t\t\t\t\t\tbuffer[i+j] = min(buffer[i+j],DP1[v*5000+i]+DP1[t*5000+j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int i=0;i<ch+child[t];i++){\n\t\t\t\t\t\t\tDP1[v*5000+i] = buffer[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tch += child[t];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint cm = DP2[v];\n\t\t\t\tfor(int i=0;i<ch;i++){\n\t\t\t\t\tif(DP1[v*5000+i] < 0){\n\t\t\t\t\t\tcm = min(cm,i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp1[v] = cm;\n\t\t\t\tchild[v] = ch;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tsp.push({v+N,f});\n\t\t\tfor(int t:G[v]){\n\t\t\t\tif(t != f){\n\t\t\t\t\tsp.push({t,v});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp1[0] << endl;\n}\nint main(int argc,char** argv){\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcout.tie(0); Calc(); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int SZ = 5005;\ntypedef long long ll;\nvector<int> graph[5005];\nll wei[SZ];\nint visit[SZ];\nint n;\nint aa = 0;\nll post_order(int a){\n\tvisit[a]=1;\n\tll sm = wei[a];\n\tfor(auto x : graph[a]){\n\t\tif(visit[x]==1) continue;\n\t\tll chk = post_order(x);\n\t\tsm += chk;\n\t\tif(wei[a]+chk>0 && (wei[a]<0 || chk<0 || (wei[x]<0 && sm+wei[x]>0))){\n\t\t\taa++;\n\t\t}\n\t}\n\treturn sm;\n}\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%lld\",&wei[i]);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y; scanf(\"%d %d\",&x,&y);\n\t\tgraph[x].push_back(y);\n\t\tgraph[y].push_back(x);\n\t}\n\tpost_order(1);\n\tprintf(\"%lld\",aa);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 100000000000000;\n\nint n;\nvector<ll> a(5000);\nvector<vector<ll> > adj(5000, vector<ll>());\n//vector<vector<vector<ll> > > dp(5000, vector<vector<ll> >(5000, vector<ll>(2, INF)));\nll dp[5000][5000][2];\nvector<int> edges(5000, 0);\n\nvoid chmin(ll& before, ll after) {\n\tif (before > after) before = after;\n\treturn;\n}\n\nint dfs_pre(int x, int p) {\n\tif (x != 0 && adj[x].size() == 1) return 0;\n\tfor (auto v : adj[x]) {\n\t\tif (v == p) continue;\n\t\telse edges[x] += dfs_pre(v, x) + 1;\n\t}\n\treturn edges[x];\n}\n\nvoid dfs(int x, int p) {\n\tfor (auto v : adj[x]) {\n\t\tif (v != p) dfs(v, x);\n\t}\n\n\tvector<vector<vector<ll> > > sub(n, vector<vector<ll> >(n, vector<ll>(2, INF)));\n\tsub[0][0][1] = a[x];\n\tif (a[x] > 0) sub[0][0][0] = a[x];\n\tint i = 0;\n\tint e_cnt = 0;\n\n\tfor (auto v : adj[x]) {\n\t\tif (v == p) continue;\n\t\tfor (int j1 = 0; j1 < e_cnt+1; ++j1)\n\t\t{\n\t\t\tfor (int j2 = 0; j2 < edges[v]+1; ++j2)\n\t\t\t{\n\t\t\t\tchmin(sub[i+1][j1+j2][1], sub[i][j1][0] + dp[v][j2][1]);\n\t\t\t\tchmin(sub[i+1][j1+j2][1], sub[i][j1][1] + dp[v][j2][0]);\n\t\t\t\tchmin(sub[i+1][j1+j2][1], sub[i][j1][1] + dp[v][j2][1]);\n\t\t\t\tif (a[x] > 0) chmin(sub[i+1][j1+j2][0], sub[i][j1][0] + dp[v][j2][0]);\n\n\t\t\t\tif (dp[v][j2][0] < INF/2 || dp[v][j2][1] < 0) {\n\t\t\t\t\tchmin(sub[i+1][j1+j2+1][1], sub[i][j1][1]);\n\t\t\t\t\tif (a[x] > 0) chmin(sub[i+1][j1+j2+1][0], sub[i][j1][0]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\te_cnt += edges[v] + 1;\n\t\ti++;\n\t}\n\tfor (int j = 0; j < edges[x]+1; ++j)\n\t{\n\t\tdp[x][j][0] = sub[i][j][0];\n\t\tdp[x][j][1] = sub[i][j][1];\n\t}\n\n\treturn;\n}\n\nint main() {\n\tfor (int i = 0; i < 5000; ++i)\n\t{\n\t\tfor (int j = 0; j < 5000; ++j)\n\t\t{\n\t\t\tfor (int k = 0; k < 2; ++k)\n\t\t\t{\n\t\t\t\tdp[i][j][k] = INF;\n\t\t\t}\n\t\t}\n\t}\n\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i) cin >> a[i];\n\tfor (int i = 0; i < n-1; ++i)\n\t{\n\t\tint u, v; cin >> u >> v;\n\t\tadj[u-1].push_back(v-1);\n\t\tadj[v-1].push_back(u-1);\n\t}\n\n\tdfs_pre(0, -1);\n\n\tdfs(0, -1);\n\n\tint ans;\n\tfor (int j = 0; j < n; ++j)\n\t{\n\t\tif (dp[0][j][0] < INF/2 || dp[0][j][1] < 0) {\n\t\t\tans = j;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nint n;\nint a[6005];\nint sz[6005];\nint dp[6005][6005][2];\nvector<int> adj[100005];\n\nvoid ddp(int node, int fa)\n{\n\t//cout<<\"AT \"<<node<<endl;\n\tsz[node]=1;\n\tfor(int i=0; i<=n; i++)\n\t{\n\t\tdp[node][i][0]=10000000000000;\n\t\tdp[node][i][1]=10000000000000;\n\t}\n\tif(a[node]>0) dp[node][0][0]=a[node];\n\telse dp[node][0][1]=a[node];\n\tint dp1[5005][2];\n\t\n\tfor(auto i:adj[node])\n\t{\n\t\tif(i==fa) continue;\n\t\tfor(int i=0; i<=n; i++)\n\t\t{\n\t\t\tdp1[i][0]=10000000000000;\n\t\t\tdp1[i][1]=10000000000000;\n\t\t}\n\t\tddp(i, node);\n\t\tfor(int sn=0; sn<sz[node]; sn++)\n\t\t{\n\t\t\tfor(int si=0; si<sz[i]; si++)\n\t\t\t{\n\t\t\t\tdp1[sn+si][0]=min(dp1[sn+si][0], dp[node][sn][0]+dp[i][si][0]);\n\t\t\t\tdp1[sn+si][1]=min(dp1[sn+si][1], min(dp[node][sn][1]+dp[i][si][1], min(dp[node][sn][0]+dp[i][si][1], dp[node][sn][1]+dp[i][si][0])));\n\t\t\t\tif(dp[i][si][1]<0)\n\t\t\t\t{\n\t\t\t\t\tdp1[sn+si+1][0]=min(dp1[sn+si+1][0], dp[node][sn][0]);\n\t\t\t\t\tdp1[sn+si+1][1]=min(dp1[sn+si+1][1], dp[node][sn][1]);\n\t\t\t\t}\n\t\t\t\tif(dp[i][si][0]<10000000000000)\n\t\t\t\t{\n\t\t\t\t\tdp1[sn+si+1][0]=min(dp1[sn+si+1][0], dp[node][sn][0]);\n\t\t\t\t\tdp1[sn+si+1][1]=min(dp1[sn+si+1][1], dp[node][sn][1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j=0; j<=n; j++)\n\t\t{\n\t\t\tdp[node][j][0]=dp1[j][0];\n\t\t\tdp[node][j][1]=dp1[j][1];\n\t\t}\n\t\tsz[node]+=sz[i];\n\t}\n}\n\nsigned main()\n{\n\tcin>>n;\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tcin>>a[i];\n\t}\n\tfor(int i=1; i<n; i++)\n\t{\n\t\tint u, v;\n\t\tcin>>u>>v;\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\tddp(1, 1);\n\tfor(int i=0; i<=n; i++)\n\t{\n\t\tif(dp[1][i][0]<10000000000000||dp[1][i][1]<0)\n\t\t{\n\t\t\t//cout<<dp[1][i][0]<<\" \"<<dp[1][i][1]<<endl;\n\t\t\tcout<<i;\n\t\t\treturn 0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst long long MAXN = 3e3+5;\n\nvector<long long> v1[MAXN];\nlong long dp[MAXN][MAXN][3];\nlong long temp[MAXN][3];\nlong long sz[MAXN];\nlong long arr[MAXN];\nvoid dfs(long long curr,long long par){\n    for(long long x:v1[curr]){\n        if(x!=par){\n            dfs(x,curr);\n            \n        }\n        \n    }\n    long long sum = 1; //current subtree sz\n    dp[curr][0][arr[curr]<0] = arr[curr]; //0 edges cut, is a computer = 1, not a computer  = 0 \n    for(long long x:v1[curr]){\n        if(x!=par){\n            for(long long i=0;i<sum;i++){\n                for(long long j=0;j<sz[x];j++){\n                    for(long long k1=0;k1<2;k1++){\n                        for(long long k2=0;k2<2;k2++){\n                            //merge components together(all possible cuts)\n                            temp[i+j][k1|k2] = min(temp[i+j][k1|k2],dp[curr][i][k1]+dp[x][j][k2]);\n                            if((k2 == 0 && dp[x][j][k2]<1e18)||(k2 == 1 && dp[x][j][k2]<0)){\n                                //cut edge between curr and x, cuts++, whether or not a computer exists \n                                //depends on the current component itself. You can only do this if x's subtree\n                                //has a value less than 0 when it has a computer, or if x's subtree doesn't currently have a computer.\n                                temp[i+j+1][k1] = min(temp[i+j+1][k1],dp[curr][i][k1]);\n                            }\n                        }\n                    }\n                }\n            }\n            //(actually O(n))\n            sum+=sz[x];\n            for(long long i=0;i<sum;i++){\n                for(long long k=0;k<2;k++){\n                    dp[curr][i][k] = temp[i][k];\n                    temp[i][k] = 1e18;\n                    //update all values to dp\n                }\n            }\n        }\n    }\n    sz[curr] = sum;\n}\nint main(){\n    long long n;\n    cin>>n;\n    for(long long i=1;i<=n;i++){\n        cin>>arr[i];\n    }\n    for(long long i=1;i<n;i++){\n        long long u,v;\n        cin>>u>>v;\n        v1[u].push_back(v);\n        v1[v].push_back(u);\n    }\n    for(long long i=1;i<=n;i++){\n        for(long long j=0;j<=n;j++){\n            for(long long k=0;k<=1;k++){\n                dp[i][j][k] = 1e18;\n                temp[j][k] = 1e18;\n            }\n        }\n    }\n    dfs(1,1);\n    long long ans = n-1;\n    for(long long i=0;i<n;i++){\n        if(dp[1][i][0]<1e18){\n            ans = min(ans,i);\n        }\n        if(dp[1][i][1]<0){\n            ans = min(ans,i);\n        }\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <functional>\n\ntemplate <class T>\nstd::vector<T> vec(int len, T elem) { return std::vector<T>(len, elem); }\n\ntemplate <class Cost = int>\nstruct Edge {\n    int src, dst;\n    Cost cost;\n    Edge(int src = -1, int dst = -1, Cost cost = 1)\n        : src(src), dst(dst), cost(cost){};\n\n    bool operator<(const Edge<Cost>& e) const { return this->cost < e.cost; }\n    bool operator>(const Edge<Cost>& e) const { return this->cost > e.cost; }\n};\n\ntemplate <class Cost = int>\nusing Graph = std::vector<std::vector<Edge<Cost>>>;\n\nusing lint = long long;\nconstexpr lint INF = 1LL << 45;\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n\n    std::vector<lint> xs(n);\n    for (auto& x : xs) std::cin >> x;\n\n    Graph<> graph(n);\n    for (int i = 0; i < n - 1; ++i) {\n        int u, v;\n        std::cin >> u >> v;\n        --u, --v;\n        graph[u].emplace_back(u, v);\n        graph[v].emplace_back(v, u);\n    }\n\n    auto dp = vec(2, vec(n, vec(n, 0LL)));\n    auto ndp = std::vector<lint>(n);\n    auto esz = vec(n, 0);\n\n    std::function<void(int, int)> dfs =\n        [&](int v, int p) {\n            std::fill(dp[0][v].begin(), dp[0][v].end(), INF);\n            dp[0][v][0] = xs[v];\n\n            if (xs[v] > 0) dp[1][v][0] = 1;\n\n            for (auto e : graph[v]) {\n                int u = e.dst;\n                if (u == p) continue;\n\n                dfs(u, v);\n\n                std::fill(ndp.begin(), ndp.end(), INF);\n                for (int i = 0; i <= esz[v]; ++i) {\n                    for (int j = 0; j <= esz[u]; ++j) {\n                        // negative merge\n                        ndp[i + j] = std::min(ndp[i + j], dp[0][v][i] + dp[0][u][j]);\n\n                        if (dp[1][u][j]) {\n                            // cut\n                            ndp[i + j + 1] = std::min(ndp[i + j + 1], dp[0][v][i]);\n                        }\n                    }\n                }\n                std::swap(dp[0][v], ndp);\n\n                std::fill(ndp.begin(), ndp.end(), 0);\n                for (int i = 0; i <= esz[v]; ++i) {\n                    if (!dp[1][v][i]) continue;\n\n                    for (int j = 0; j <= esz[u]; ++j) {\n                        if (dp[0][u][j] < 0) {\n                            // cut\n                            while ((int)ndp.size() < i + j + 1) ndp.push_back(0);\n                            ndp[i + j + 1] = 1;\n                        }\n\n                        if (dp[1][u][j]) {\n                            // positive merge\n                            while ((int)ndp.size() < i + j) ndp.push_back(0);\n                            ndp[i + j] = 1;\n                        }\n                    }\n                }\n                std::swap(dp[1][v], ndp);\n\n                esz[v] += esz[u] + 1;\n            }\n\n            // std::cerr << v << \": \" << esz[v] << std::endl;\n            // for (auto x : dp[0][v]) std::cerr << x << \" \";\n            // std::cerr << std::endl;\n            // for (auto x : dp[1][v]) std::cerr << x << \" \";\n            // std::cerr << std::endl\n            //           << std::endl;\n        };\n\n    dfs(0, -1);\n    int ans = n;\n    for (int i = 0; i < n; ++i) {\n        if (dp[0][0][i] < 0 || dp[1][0][i]) {\n            ans = std::min(ans, i);\n            break;\n        }\n    }\n\n    std::cout << ans << std::endl;\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) do{print_vars(cout<<\"# \"<<#__VA_ARGS__<<'=',__VA_ARGS__);cout<<endl;}while(0)\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\nusing uint=unsigned;\nusing ll=long long;\nusing ull=unsigned long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing vd=vector<double>;\nusing vvd=vector<vd>;\nusing vs=vector<string>;\n\ntemplate<typename T,typename U>bool chmin(T& a,const U& b){return a>b?(a=b,1):0;}\ntemplate<typename T,typename U>bool chmax(T& a,const U& b){return a<b?(a=b,1):0;}\n\nvoid print_vars(ostream&){}\ntemplate<typename Car,typename... Cdr>\nvoid print_vars(ostream& os,const Car& car,const Cdr&... cdr){\n\tprint_vars(os<<car<<(sizeof...(cdr)?\",\":\"\"),cdr...);\n}\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<int I,typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<int I,typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tos<<get<I>(t)<<(sizeof...(Cdr)?\",\":\"\");\n\tprint_tuple<I+1,Cdr...>(os,t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<0,Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr ll INF=1e18;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nvvl solve(const vvi& g,const vl& a,int u,int p)\n{\n\t// udp[0][i]: uを根とする部分木をi回切断した場合の、uを含む連結成分がバッテリーだけのときのsumの最小値\n\t// udp[1][i]: uを根とする部分木をi回切断した場合の、uを含む連結成分のsumの最小値\n\tvvl udp(2,vl(1,INF));\n\tif(a[u]>0)\n\t\tudp[0][0]=a[u];\n\tudp[1][0]=a[u];\n\tfor(int v:g[u]) if(v!=p){\n\t\tvvl vdp=solve(g,a,v,u);\n\t\tint usize=udp[0].size(),vsize=vdp[0].size();\n\t\tvvl dp(2,vl(usize+vsize,INF));\n\t\trep(i,usize) rep(j,vsize){\n\t\t\t// u-v間を切断しない\n\t\t\tchmin(dp[0][i+j],udp[0][i]+vdp[0][j]);\n\t\t\tchmin(dp[1][i+j],udp[1][i]+vdp[1][j]);\n\t\t\t// u-v間を切断する\n\t\t\tif(vdp[0][j]!=INF||vdp[1][j]<0){\n\t\t\t\tchmin(dp[0][i+j+1],udp[0][i]);\n\t\t\t\tchmin(dp[1][i+j+1],udp[1][i]);\n\t\t\t}\n\t\t}\n\t\tudp=dp;\n\t}\n\treturn udp;\n}\n\nint main()\n{\n\t#ifndef _GLIBCXX_DEBUG\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tconstexpr char endl='\\n';\n\t#endif\n\n\tfor(int n;cin>>n&&n;){\n\t\tvl a(n);\n\t\trep(i,n) cin>>a[i];\n\t\tvvi g(n);\n\t\trep(i,n-1){\n\t\t\tint u,v; cin>>u>>v; u--,v--;\n\t\t\tg[u].push_back(v);\n\t\t\tg[v].push_back(u);\n\t\t}\n\n\t\tvvl dp=solve(g,a,0,-1);\n\t\tint res=n-1;\n\t\trep(i,n){\n\t\t\tif(dp[0][i]!=INF)\n\t\t\t\tchmin(res,i);\n\t\t\tif(dp[1][i]<0)\n\t\t\t\tchmin(res,i);\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3f\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\n\nint n;\nll a[6000];\nvector<int>E[6000];\nint siz[6000];\nll dp[2][6000][6000];\nbool dp2[2][6000][6000];\n\nvoid dfs(int v,int p){\n\tfor(int u:E[v]){\n\t\tif(u==p)continue;\n\t\tdfs(u,v);\n\t}\n\tint D=0;\n\trep(i,n)dp[0][v][i]=INF;\n\tdp[0][v][0]=a[v];\n\tif(a[v]>0)dp2[0][v][0]=true;\n\tsiz[v]=1;\n\tfor(int u:E[v]){\n\t\tif(u==p)continue;\n\t\tint a=(E[u].size()-1)%2;\n\t\tfor(int i=siz[v]+siz[u];i>=0;i--){\n\t\t\tdp[!D][v][i]=INF;\n\t\t\tdp2[!D][v][i]=false;\n\t\t}\n\t\trep(i,siz[v]+1){\n\t\t\trep(j,siz[u]+1){\n\t\t\t\t//切断する場合\n\t\t\t\tif(dp2[a][u][j]||dp[a][u][j]<0){\n\t\t\t\t\tdp[!D][v][i+j+1]=min(dp[!D][v][i+j+1],dp[D][v][i]);\n\t\t\t\t\tdp2[!D][v][i+j+1]|=dp2[D][v][i];\n\t\t\t\t}\n\t\t\t\t//切断しない場合\n\t\t\t\tdp[!D][v][i+j]=min(dp[!D][v][i+j],dp[D][v][i]+dp[a][u][j]);\n\t\t\t\tdp2[!D][v][i+j]|=(dp2[D][v][i]&dp2[a][u][j]);\n\t\t\t}\n\t\t}\n\t\tsiz[v]+=siz[u];\n\t\tD=!D;\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\trep(i,n)scanf(\"%lld\",&a[i]);\n\trep(i,n-1){\n\t\tint a,b;scanf(\"%d%d\",&a,&b);a--;b--;\n\t\tE[a].push_back(b);\n\t\tE[b].push_back(a);\n\t}\n\tdfs(0,-1);\n\trep(i,n){\n\t\tif(dp[E[0].size()%2][0][i]<0||dp2[E[0].size()%2][0][i]==true){\n\t\t\tcout<<i<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;  \n  vector<Int> a(n);\n  for(Int i=0;i<n;i++) cin>>a[i];\n  \n  vector<vector<Int> > G(n);\n  for(Int i=1;i<n;i++){\n    Int x,y;\n    cin>>x>>y;\n    x--;y--;   \n    G[x].emplace_back(y);\n    G[y].emplace_back(x);\n  }\n\n  const Int INF = 1e17;\n  vector<vector<Int> > dp1(n),dp2(n);\n  function<void(Int, Int)> dfs=\n    [&](Int v,Int p){\n      for(Int u:G[v])\n        if(u!=p) dfs(u,v);\n      \n      dp1[v].assign(1,INF);\n      dp2[v].assign(1,INF);\n\n      if(a[v]>0) dp1[v][0]=a[v];\n      if(a[v]<0) dp2[v][0]=a[v];\n\n      for(Int u:G[v]){\n        if(u==p) continue;\n        Int x=dp1[v].size();        \n        Int y=dp1[u].size();        \n        vector<Int> nx1(x+y,INF),nx2(x+y,INF);\n        for(Int i=0;i<x;i++){\n          for(Int j=0;j<y;j++){\n            chmin(nx1[i+j],dp1[v][i]+dp1[u][j]);\n            chmin(nx2[i+j],dp1[v][i]+dp2[u][j]);\n            chmin(nx2[i+j],dp2[v][i]+dp1[u][j]);\n            chmin(nx2[i+j],dp2[v][i]+dp2[u][j]);\n            \n            if(i+j+1<x+y){\n              if(dp1[u][j]<INF/2) chmin(nx1[i+j+1],dp1[v][i]);\n              if(dp1[u][j]<INF/2) chmin(nx2[i+j+1],dp2[v][i]);\n              if(dp2[u][j]<0) chmin(nx1[i+j+1],dp1[v][i]);\n              if(dp2[u][j]<0) chmin(nx2[i+j+1],dp2[v][i]);\n            }           \n          }\n        }        \n        swap(dp1[v],nx1);\n        swap(dp2[v],nx2);\n      }\n    };\n  dfs(0,-1);\n  \n  Int ans=n;\n  for(Int i=0;i<n;i++){\n    //cout<<i<<\":\"<<dp1[0][i]<<\" \"<<dp2[0][i]<<endl;\n    if(dp1[0][i]<INF/2) chmin(ans,i);\n    if(dp2[0][i]<0) chmin(ans,i);\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define rng(a) a.begin(),a.end()\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\n#define dame { puts(\"-1\"); return 0;}\n#define yn {puts(\"Yes\");}else{puts(\"No\");}\n#define MAX_N 6005\n\n/*\n    Attack to a Tree\n*/\n\n\nvector<int> pre_G[MAX_N];\nvector<int> G[MAX_N];\nint par_[MAX_N];\nint flag_netsukigi[MAX_N];\nvoid make_netsukigi(int r){\n    rep(i,MAX_N){\n        G[i].clear();\n        par_[i] = 0;\n        flag_netsukigi[i] = 0;\n    }\n    queue<int> que;\n    que.push(r);\n    flag_netsukigi[r] = 1;\n    par_[r] = -1;\n\n    while(que.size() > 0){\n        int x = que.front();\n        que.pop();\n        flag_netsukigi[x] = 1;\n        rep(i,pre_G[x].size()){\n            if(flag_netsukigi[pre_G[x][i]] == 0){\n                par_[pre_G[x][i]] = x;\n                G[x].push_back(pre_G[x][i]);\n                que.push(pre_G[x][i]);\n            }\n        }\n    }\n}\n\nint n;\nll a[MAX_N];\nll u[MAX_N], v[MAX_N];\nvector<int> son[MAX_N];\nll dp[MAX_N][MAX_N][2];\nconst ll inf = 1001001001001001001;\nint cnt_son[MAX_N];\n\nint main() {\n    cin >> n;\n    rep(i,n)cin >> a[i];\n    rep(i,n-1){\n        cin >> u[i] >> v[i];\n        u[i]--; v[i]--;\n        pre_G[u[i]].push_back(v[i]);\n        pre_G[v[i]].push_back(u[i]);\n    }\n\n    make_netsukigi(0);\n\n    rep(i,n){\n        rep(j,n){\n            rep(k,2){\n                dp[i][j][k] = inf;\n            }\n        }\n    }\n\n    queue<int> que;\n    rep(i,n){\n        if(G[i].empty()){\n            que.push(i);\n            cnt_son[i] = 1;\n            if(a[i] < 0){\n                dp[i][0][1] = a[i];\n            }else{\n                dp[i][0][0] = a[i];\n            }\n        }\n    }\n\n    while(que.size() > 0){\n        int x = que.front();\n        que.pop();\n        int y = par_[x];\n        if(y == -1)break;\n        son[y].push_back(x);\n        if(son[y].size() == G[y].size()){\n            que.push(y);\n            cnt_son[y] = 1;\n            // DP計算\n            rep(i,son[y].size()){\n                int z = son[y][i];\n                ll dp2[n][2];\n                rep(j,n)rep(k,2)dp2[j][k] = inf;\n                if(i == 0){\n                    if(a[y] < 0){\n                        // 切らない\n                        rep(j,cnt_son[z]+1){\n                            dp2[j][1] = min(dp2[j][1], dp[z][j][0] + a[y]);\n                            dp2[j][1] = min(dp2[j][1], dp[z][j][1] + a[y]);\n                        }\n                        // 切る\n                        srep(j,1,cnt_son[z]+1){\n                            if(dp[z][j-1][0] < inf || dp[z][j-1][1] < 0) dp2[j][1] = min(dp2[j][1], a[y]);\n                        }\n                    }else{\n                        // 切らない\n                        rep(j,cnt_son[z]+1){\n                            dp2[j][0] = min(dp2[j][0], dp[z][j][0] + a[y]);\n                            dp2[j][1] = min(dp2[j][1], dp[z][j][1] + a[y]);\n                        }\n                        // 切る\n                        srep(j,1,cnt_son[z]+1){\n                            if(dp[z][j-1][0] < inf || dp[z][j-1][1] < 0) dp2[j][0] = min(dp2[j][0], a[y]);\n                        }\n                    }\n                }else{\n                    // 切らない\n                    rep(j,cnt_son[y]){\n                        rep(k,cnt_son[z]){\n                            if(j+k>=n)break;\n                            dp2[j+k][0] = min(dp2[j+k][0], dp[y][j][0] + dp[z][k][0]);\n                            dp2[j+k][1] = min(min(dp2[j+k][1], dp[y][j][1] + dp[z][k][1]), min(dp[y][j][1] + dp[z][k][0], dp[y][j][0] + dp[z][k][1]));\n                        }\n                    }\n                    // 切る\n                    rep(j,cnt_son[y]){\n                        rep(k,cnt_son[z]){\n                            if(j+k+1>=n)break;\n                            if(dp[z][k][0] < inf || dp[z][k][1] < 0){\n                                dp2[j+k+1][0] = min(dp2[j+k+1][0], dp[y][j][0]);\n                                dp2[j+k+1][1] = min(dp2[j+k+1][1], dp[y][j][1]);\n                            }\n                        }\n                    }\n                }\n                rep(j,n)rep(k,2)dp[y][j][k] = dp2[j][k];\n                cnt_son[y] += cnt_son[z];\n            }\n        }\n    }\n\n    int ans = 1001001;\n    rep(j,n){\n        if(dp[0][j][1] < 0){\n            ans = min(ans, j);\n        }\n        if(dp[0][j][0] < inf){\n            ans = min(ans, j);\n        }\n    }\n\n    cout << ans << endl;\n    return 0;\n}\n \n \n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <numeric>\n#include <functional>\n#include <tuple>\n\ntemplate <class T, class U>\ninline bool chmin(T& lhs, const U& rhs) {\n  if (lhs > rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\ntemplate <class T, class U>\ninline bool chmax(T& lhs, const U& rhs) {\n  if (lhs < rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\n// [l, r) from l to r\nstruct range {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { ++i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr l, r;\n  constexpr range(int l_, int r_): l(std::min<int>(l_, r_)), r(r_) {}\n  constexpr itr begin() const { return l; }\n  constexpr itr end() const { return r; }\n};\n\n// [l, r) from r to l\nstruct revrange {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { --i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr r, l;\n  constexpr revrange(int l_, int r_): r(std::max<int>(l_, r_) - 1), l(l_ - 1) {}\n  constexpr itr begin() const { return r; }\n  constexpr itr end() const { return l; }\n};\n\ntemplate <class T>\ninline T scan() {\n  T res;\n  std::cin >> res;\n  return res;\n}\n\nusing lint = long long;\nconstexpr int inf = (1 << 30) - 1;\nconstexpr lint linf = (1ll << 60) - 1;\n\nint N;\nint A[5000], cnt[5000];\nstd::vector<int> graph[5000];\nlint dp[5000][5000][2];\n\nvoid dfs(int v, int p) {\n  cnt[v] = 1;\n  chmin(dp[v][0][0], A[v]);\n  if (A[v] > 0) {\n    chmin(dp[v][0][1], A[v]);\n  }\n  for (int x: graph[v]) {\n    if (x == p) {\n      continue;\n    }\n    dfs(x, v);\n    for (int i: revrange(0, cnt[v])) {\n      lint a = dp[v][i][0], b = dp[v][i][1];\n      dp[v][i][0] = dp[v][i][1] = linf;\n      for (int j: range(0, cnt[x])) {\n        chmin(dp[v][i + j][0], a + dp[x][j][0]);\n        chmin(dp[v][i + j][0], a + dp[x][j][1]);\n        chmin(dp[v][i + j][1], b + dp[x][j][1]);\n        if (dp[x][j][1] < linf) {\n          chmin(dp[v][i + j + 1][0], a);\n          chmin(dp[v][i + j + 1][1], b);\n        }\n        if (dp[x][j][0] < 0) {\n          chmin(dp[v][i + j + 1][0], a);\n          chmin(dp[v][i + j + 1][1], b);\n        }\n      }\n    }\n    cnt[v] += cnt[x];\n  }\n}\n\nint main() {\n  std::cin >> N;\n  for (int i: range(0, N)) {\n    std::cin >> A[i];\n  }\n  for (int i: range(0, N - 1)) {\n    int u, v;\n    std::cin >> u >> v;\n    --u; --v;\n    graph[u].push_back(v);\n    graph[v].push_back(u);\n  }\n  for (int i: range(0, N)) {\n    for (int j: range(0, N)) {\n      dp[i][j][0] = dp[i][j][1] = linf;\n    }\n  }\n  dfs(0, -1);\n  int ans = inf;\n  for (int j: range(0, N)) {\n    if (dp[0][j][0] < 0) {\n      chmin(ans, j);\n    }\n    if (dp[0][j][1] < linf) {\n      chmin(ans, j);\n    }\n  }\n  std::cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(ll i=0;i<(ll)n;i++)\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n\nusing ld = long double;\nusing ll = long long;\nusing ull = unsigned long long;\nusing pii = pair<int, int>;\nusing pll = pair<long, long>;\nusing pdd = pair<ld, ld>;\n\ntemplate<typename T> struct V : vector<T> { using vector<T>::vector; };\nV() -> V<ll>;\nV(size_t) -> V<ll>;\ntemplate<typename T> V(size_t, T) -> V<T>;\ntemplate<typename T> vector<T> make_vec(size_t n, T a) { return vector<T>(n, a); }\ntemplate<typename... Ts> auto make_vec(size_t n, Ts... ts) { return vector<decltype(make_vec(ts...))>(n, make_vec(ts...)); }\ntemplate<class S, class T> ostream& operator << (ostream& os, const pair<S, T> v){os << \"(\" << v.first << \", \" << v.second << \")\"; return os;}\ntemplate<typename T> ostream& operator<<(ostream &os, const vector<T> &v) { for (auto &e : v) os << e << ' '; return os; }\ntemplate<class T> ostream& operator<<(ostream& os, const vector<vector<T>> &v){ for(auto &e : v){os << e << \"\\n\";} return os;}\nstruct fast_ios { fast_ios(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\nvoid fail() { cout << -1 << '\\n'; exit(0); }\ninline int popcount(const int x) { return __builtin_popcount(x); }\ninline int popcount(const ll x) { return __builtin_popcountll(x); }\ntemplate<typename T> void debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{cerr<<v[i][0];for(ll j=1;j<w;j++)cerr spa v[i][j];cerr<<endl;}};\ntemplate<typename T> void debug(vector<T>&v,ll n){if(n!=0)cerr<<v[0];\nfor(ll i=1;i<n;i++)cerr spa v[i];\ncerr<<endl;};\n\nconst ll INF = (1ll<<60);\n// const ld EPS   = 1e-10;\n// const ld PI    = acos(-1.0);\nconst ll mod = (int)1e9 + 7;\n//const ll mod = 998244353;\nusing Graph = V<V<ll>>;\n\nint main(){\n\n    ll N;\n    cin >> N;\n    V<ll> A(N);\n    REP(i, N) cin >> A[i];\n    Graph G(N);\n    REP(i, N-1){\n        ll u, v;\n        cin >> u >> v;\n        u--, v--;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n\n    V<V<ll>> dp(N);\n    V<V<bool>> pos(N);\n    V<ll> sz(N, 0);\n\n    auto dfs = [&](auto self, ll now, ll par)->void{\n        sz[now] = 1;\n        dp[now] = V<ll>(sz[now], INF); \n        pos[now] = V<bool>(sz[now], false); \n        dp[now][0] = A[now];\n        pos[now][0] = (A[now]>=0);\n        for(auto next: G[now]){\n            if(next == par) continue;\n            self(self, next, now);\n            V<ll> merged(sz[now]+sz[next], INF);\n            V<bool> pos_merged(sz[now]+sz[next], false);\n            REP(i, sz[now]){\n                REP(j, sz[next]){\n                    // dump(i)\n                    // dump(j)\n                    // dump(merged.size())\n                    chmin(merged[i+j], dp[now][i]+dp[next][j]);\n                    if(pos[now][i] and pos[next][j]) pos_merged[i+j] = true;\n                    if(dp[next][j]<0 or pos[next][j]){\n                        chmin(merged[i+j+1], dp[now][i]);\n                        if(pos[now][i]) pos_merged[i+j+1] = true;\n                    }\n                }\n            }\n            sz[now] += sz[next];\n            dp[now] = merged;\n            pos[now] = pos_merged;\n        }\n    };\n\n    dfs(dfs, 0, -1);\n\n    ll res = (1ll<<60);\n\n    REP(i, N){\n        if(dp[0][i]<0) chmin(res, i);\n        if(pos[0][i]) chmin(res, i);\n    }\n\n    cout << res << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1LL<<60)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n;\nll a[5005];\nll a2[5005];\nvector<int> G[5005];\nvector<int> G2[5005];\nint cmp[5005];\nll dp[5005][5005][2];\nint sz[5005];\nint cnt2[5005];\n\nvoid dfs(int v,int c){\n    cmp[v]=c;\n    if(a[v]<0LL)return;\n    for(int i=0;i<G[v].size();i++){\n        int nv=G[v][i];\n        if(a[nv]>0LL && cmp[nv]==-1){\n            dfs(nv,c);\n        }\n    }\n}\n\nint dfs2(int v,int p){\n    sz[v]=1;\n    for(int i=0;i<G[v].size();i++){\n        int nv=G[v][i];\n        if(nv!=p){\n            sz[v]+=dfs2(nv,v);\n        }\n    }\n    return sz[v];\n}\n\nll tmp[5005][2];\n\nvoid dfs3(int v,int p){\n    int szc=1;\n    if(a[v]<0LL)dp[v][0][1]=a[v];\n    else dp[v][0][0]=a[v];\n    cnt2[v]++;\n    assert(cnt2[v]==1);\n    for(int i=0;i<G[v].size();i++){\n        int nv=G[v][i];\n        if(nv==p)continue;\n        dfs3(nv,v);\n        for(int j=0;j<=szc+sz[nv];j++){\n            tmp[j][0]=INF;\n            tmp[j][1]=INF;\n        }\n        for(int j=0;j<szc;j++){\n            for(int k=0;k<sz[nv];k++){\n                tmp[j+k][0]=min(tmp[j+k][0],dp[v][j][0]+dp[nv][k][0]);\n                tmp[j+k][1]=min(tmp[j+k][1],dp[v][j][1]+dp[nv][k][0]);\n                tmp[j+k][1]=min(tmp[j+k][1],dp[v][j][0]+dp[nv][k][1]);\n                tmp[j+k][1]=min(tmp[j+k][1],dp[v][j][1]+dp[nv][k][1]);\n                if(dp[nv][k][1]<0LL || dp[nv][k][0]!=INF)tmp[j+k+1][1]=min(tmp[j+k+1][1],dp[v][j][1]);\n                if(dp[nv][k][1]<0LL || dp[nv][k][0]!=INF)tmp[j+k+1][0]=min(tmp[j+k+1][0],dp[v][j][0]);\n            }\n        }\n        for(int j=0;j<=szc+sz[nv];j++){\n            dp[v][j][0]=tmp[j][0];\n            dp[v][j][1]=tmp[j][1];\n        }\n        szc+=sz[nv];\n    }\n    /*\n    printf(\"%d\\n\",v);\n    for(int i=0;i<=szc;i++){\n        printf(\"%lld %lld\\n\",dp[v][i][0],dp[v][i][1]);\n    }\n     */\n}\n\nint main(void){\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%lld\",&a[i]);\n    }\n    for(int i=0;i<n-1;i++){\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        u--;\n        v--;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    memset(cmp,-1,sizeof(cmp));\n    int sz=0;\n    for(int i=0;i<n;i++){\n        if(cmp[i]==-1){\n            dfs(i,sz++);\n        }\n        //printf(\"%d \",cmp[i]);\n    }\n    //printf(\"\\n\");\n    for(int i=0;i<n;i++){\n        a2[cmp[i]]+=a[i];\n        for(int j=0;j<G[i].size();j++){\n            int nv=cmp[G[i][j]];\n            if(nv!=cmp[i]){\n                G2[cmp[i]].push_back(nv);\n                G2[nv].push_back(cmp[i]);\n            }\n        }\n    }\n    for(int i=0;i<sz;i++){\n        sort(G2[i].begin(),G2[i].end());\n        G2[i].erase(unique(G2[i].begin(),G2[i].end()),G2[i].end());\n    }\n    dfs2(0,-1);\n    for(int i=0;i<=n;i++){\n        for(int j=0;j<=n;j++){\n            for(int k=0;k<2;k++){\n                dp[i][j][k]=1LL<<60;\n            }\n        }\n    }\n    dfs3(0,-1);\n    int ans=n-1;\n    for(int i=0;i<n;i++){\n        if(dp[0][i][0]<0LL || dp[0][i][1]<0LL)ans=min(ans,i);\n        if(dp[0][i][0]!=INF)ans=min(ans,i);\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <climits>\n#include <set>\n#include <algorithm>\n#include <unordered_map>\n#include <queue>\n#include <iomanip>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <chrono>\n#include <ctime>\n#include <bitset>\n#include <iterator>\n\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define P pair<long long, long long>\n#define debug(x) cerr << #x << \": \" << x << \", \"\n#define debugln(x) cerr << #x << \": \" << x << '\\n'\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nusing namespace std;\nusing ll = long long;\nconst ll mod = 1e9 + 7;\n\nconst ll INF = 1LL << 60;\nvector<ll> a;\nvector<vector<int>> graph;\nll dp[5005][5005][2];\nll sdp[5005][2];\n// num[v]: num of vertices in the subtree under v\nvector<int> num(5005);\n\n// p: parent\nvoid rec(int v, int p) {\n  num[v] = 1;\n  for(auto e: graph[v]) {\n    if (e == p) continue;\n    rec(e, v);\n    num[v] += num[e];\n  }\n  for(int j=0; j<=num[v]; j++) {\n    sdp[j][0] = sdp[j][1] = INF;\n  }\n\n  sdp[0][0] = a[v];\n  if (a[v] > 0) {\n    sdp[0][1] = a[v];\n  }\n\n  int curnum = 0;\n  for(auto e: graph[v]) {\n    if (e == p) continue;\n    for(int j=curnum; j>=0; j--) {\n      ll tmp0 = sdp[j][0];\n      ll tmp1 = sdp[j][1];\n      sdp[j][0] = sdp[j][1] = INF;\n      for(int k=0; k<=num[e]; k++) {\n        chmin(sdp[j+k][0], tmp0 + dp[e][k][0]);\n        // check if we can cut between v and e\n        if (dp[e][k][0] < 0 || dp[e][k][1] < INF/2) {\n          chmin(sdp[j+k+1][0], tmp0);\n        }\n        if (a[v] > 0) {\n          chmin(sdp[j+k][1], tmp1 + dp[e][k][1]);\n          // check if we can cut between v and e\n          if (dp[e][k][0] < 0 || dp[e][k][1] < INF/2) {\n            chmin(sdp[j+k+1][1], tmp1);\n          }\n        }\n      }\n    }\n    curnum += num[e];\n  }\n  for(int j=0; j<=num[v]; j++) {\n    dp[v][j][0] = sdp[j][0];\n    dp[v][j][1] = sdp[j][1];\n  }\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n; cin >> n;\n  a.resize(n);\n  rep(i, n) {\n    cin >> a[i];\n  }\n  graph.assign(n, vector<int>());\n  for(int i=0; i<n-1; i++) {\n    int u, v; cin >> u >> v;\n    u--; v--;\n    graph[u].push_back(v);\n    graph[v].push_back(u);\n  }\n  rep(i, 5005) {\n    rep(j, 5005) {\n      dp[i][j][0] = INF;\n      dp[i][j][1] = INF;\n    }\n  }\n\n  rec(0, -1);\n  int ans = n;\n  for(int i=0; i<=n; i++) {\n    if (dp[0][i][0] < 0) chmin(ans, i);\n    if (dp[0][i][1] < INF/2) chmin(ans, i);\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;using ll=long long;using uint=unsigned int;using pii=pair<int,int>;using pll=pair<ll,ll>;using ull = unsigned long long;using ld=long double;template<typename T>void _(const char*s,T h){cerr<<s<<\" = \"<<h<<\"\\n\";}template<typename T,typename...Ts>void _(const char*s,T h,Ts...t){int b=0;while(((b+=*s=='(')-=*s==')')!=0||*s!=',')cerr<<*s++;cerr<<\" = \"<<h<<\",\";_(s+1,t...);}// break continue pop_back 998244353\n#define int ll\n#define pii pll\n#define f first\n#define s second\n#define pb emplace_back\n#define forn(i,n) for(int i=0;i<(n);++i)\n#define sz(a)((int)(a).size())\n#define sqr(x) ((x)*(x))\nstruct init{init(){cin.tie(0);iostream::sync_with_stdio(0);cout<<fixed<<setprecision(10);cerr<<fixed<<setprecision(5);}~init(){\n#ifdef LOCAL\n#define dbg(...) _(#__VA_ARGS__,__VA_ARGS__)\ncerr<<\"Time elapsed: \"<<(double)clock()/CLOCKS_PER_SEC<<\"s.\\n\";\n#else\n#define dbg(...) \n#endif\n}}init;template<typename T,typename U>void upx(T&x,U y){if(x<y)x=y;}template<typename T,typename U>void upn(T&x,U y){if(x>y)x=y;}mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());const int D=4,dx[]={+1,0,-1,0},dy[]={0,+1,0,-1};\nconst int N=5001,OO=1e18;\nint dp[N][N],ba[N][N];\nint a[N];\nvector<int> g[N];\nint sz[N],dv[N],du[N],dt[N];\nvoid dfs(int v,int p=0){\n    sz[v]=1;\n    for(int to:g[v]){\n        if(to^p){\n            dfs(to,v);\n            sz[v]+=sz[to];\n        }\n    }\n    {\n        int maxv=0;\n        forn(i,N)dv[i]=OO;\n        dv[0]=0;\n        for(int to:g[v]){\n            if(to^p){\n                int maxto=sz[to];\n                forn(i,maxv+maxto+2)dt[i]=OO;\n                forn(i,maxto+1){\n                    du[i]=dp[to][i];\n                    if(i&&du[i-1]<0)upn(du[i],0);\n                    if(i&&a[to]>0&&ba[to][i-1])upn(du[i],0);\n                }\n                forn(i,maxv+1){\n                    forn(j,maxto+1){\n                        upn(dt[i+j],dv[i]+du[j]);\n                    }\n                }\n                forn(i,maxv+maxto+2)dv[i]=dt[i];\n                maxv+=maxto;\n            }\n        }\n        forn(i,sz[v])dp[v][i]=dv[i]+a[v];\n    }\n    if(a[v]>0){\n        int maxv=0;\n        forn(i,N)dv[i]=0;\n        dv[0]=1;\n        for(int to:g[v]){\n            if(to^p){\n                int maxto=sz[to];\n                forn(i,maxv+maxto+2)dt[i]=0;\n                forn(i,maxto+1){\n                    if(a[to]>0){\n                        du[i]=ba[to][i];\n                        if(i)du[i]|=ba[to][i-1];\n                        if(i)du[i]|=dp[to][i-1]<0;\n                    }else{\n                        du[i]=0;\n                        if(i)du[i]=dp[to][i-1]<0;\n                    }\n                }\n                forn(i,maxv+1){\n                    forn(j,maxto+1){\n                        dt[i+j]|=dv[i]&du[j];\n                    }\n                }\n                forn(i,maxv+maxto+2)dv[i]=dt[i];\n                maxv+=maxto;\n            }\n        }\n        forn(i,sz[v])ba[v][i]=dv[i];\n    }\n}\nint32_t main(){\n    int n;\n    cin>>n;\n    for(int i=1;i<=n;++i)cin>>a[i];\n    forn(i,n-1){\n        int x,y;\n        cin>>x>>y;\n        g[x].pb(y);\n        g[y].pb(x);\n    }\n    dfs(1);\n    int ans=N;\n    forn(i,n){\n        if(a[1]>0&&ba[1][i]){\n            ans=i;\n            break;\n        }\n        if(dp[1][i]<0){\n            ans=i;\n            break;\n        }\n    }\n    cout<<ans<<'\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define NDEBUG\n#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\nstruct UnionFind{\n  Int n;\n  vector<Int> r,p;\n  UnionFind(){}\n  UnionFind(Int sz):n(sz),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n  Int find(Int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(Int x,Int y){\n    return find(x)==find(y);\n  }\n  void unite(Int x,Int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];\n    p[y]=x;\n  }\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  assert(0);\n  auto shrink=\n    [&](){\n      Int n;\n      cin>>n;\n      vector<Int> a(n);\n      for(Int i=0;i<n;i++) cin>>a[i];\n      vector<vector<Int> > G(n);\n      for(Int i=1;i<n;i++){\n        Int x,y;\n        cin>>x>>y;\n        x--;y--;\n        G[x].emplace_back(y);\n        G[y].emplace_back(x);\n      }\n      UnionFind uf(n);\n      for(Int v=0;v<n;v++){\n        for(Int u:G[v]){\n          if(a[v]<0&&a[u]<0) uf.unite(u,v);\n          if(a[v]>0&&a[u]>0) uf.unite(u,v);\n        }\n      }\n      \n      vector<Int> vs;\n      for(Int i=0;i<n;i++){\n        if(uf.find(i)!=i) continue;\n        vs.emplace_back(i);\n      }\n      \n      Int m=vs.size();\n      map<Int, Int> rev;\n      for(Int i=0;i<m;i++) rev[vs[i]]=i;\n\n      vector<set<Int> > H(m);\n      vector<Int> na(m,0);\n      for(Int v=0;v<n;v++){\n        na[rev[uf.find(v)]]+=a[v];\n        for(Int u:G[v]){\n          if(uf.same(u,v)) continue;\n          Int x=rev[uf.find(v)],y=rev[uf.find(u)];\n          H[x].emplace(y);\n          H[y].emplace(x);\n        }\n      }\n      \n      vector<vector<Int> > nG(m);\n      for(Int i=0;i<m;i++) nG[i]=vector<Int>(H[i].begin(),H[i].end());\n      return make_tuple(m,na,nG);      \n    };\n  \n  auto graph=shrink();\n  auto n=get<0>(graph);\n  auto a=get<1>(graph);\n  auto G=get<2>(graph);\n  assert((Int)a.size()==n);\n  assert((Int)G.size()==n);\n\n  if(0){\n    cout<<n<<endl;\n    for(Int i=0;i<n;i++) cout<<a[i]<<\" \";\n    cout<<endl;\n    for(Int v=0;v<n;v++){\n      for(Int u:G[v]){\n        cout<<v<<\" \"<<u<<endl;\n      }\n    }\n  }\n  \n  if(n==1){\n    cout<<0<<endl;\n    return 0;\n  }\n\n  const Int INF = 1e17;\n  vector<vector<Int> > dp(n);\n  vector<Int> sum(n,0);\n  \n  function<void(Int, Int)> dfs=\n    [&](Int v,Int par){\n      for(Int u:G[v])\n        if(u!=par) dfs(u,v);\n      \n      dp[v].resize(1);\n      dp[v][0]=a[v];\n      for(Int u:G[v]){\n        if(u==par) continue;\n        const auto &p=dp[v];\n        const auto &q=dp[u];\n        Int x=p.size();\n        Int y=q.size();\n        vector<Int> nx(x+y,INF);\n        for(Int i=0;i<x;i++){\n          for(Int j=0;j<y;j++){\n            chmin(nx[i+j],p[i]+q[j]);\n            if(q[j]<0) chmin(nx[i+j+1],p[i]);\n          }\n        }\n        {          \n          for(Int i=0;i<x;i++)\n            if(i+sum[u]+1<x+y) chmin(nx[i+sum[u]+1],p[i]);\n        }\n        {\n          Int res=INF;\n          for(Int j=0;j<y;j++)\n            if(q[j]<0) chmin(res,j+1);\n          sum[v]+=res;\n        }        \n        swap(dp[v],nx);\n      }\n    };\n\n  Int idx=0;\n  while(a[idx]>0) idx++;\n  assert(idx<n);\n  \n  dfs(idx,-1);\n  Int ans=n;\n  //cout<<n<<\":\"<<dp[idx].size()<<endl;\n  assert(n==(Int)dp[idx].size());\n  for(Int i=0;i<n;i++)\n    if(dp[idx][i]<0) chmin(ans,i);\n  \n  assert(ans<n);  \n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n//#include \"pch.h\"\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <stdlib.h>\n\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <utility>\n#include <queue>\n#include <algorithm>\n#include <functional>\n#include <string>\n\n#define ll long long\n#define fri(n) for(i=0;i<(n);i++)\n#define frj(n) for(j=0;j<(n);i++)\n#define min(p,q) ((p)<(q)?(p):(q))\n#define max(p,q) ((p)>(q)?(p):(q))\n#define swap(p,q) r=(p);(p)=(q);(q)=r\n#define INF 1000000000000000000//10^18\n#define INFINT 2000000001//2*10^9+1\n#define MOD 1000000007//10^9+7\n#define PI acos(-1)\n\nusing namespace std;\n\nstatic vector<int> graph[5010];\nstatic ll int dp[5010][5010][3];\nstatic int a[5010];\nstatic int come[5010];\n\nint oneway(int x){\n\tint i;\n\tcome[x]=1;\n\n\tint to;\n\tauto itr=graph[x].begin();\n\n\tfor(itr=graph[x].begin();itr!=graph[x].end();){\n\t\tto=*itr;\n\t\tif(come[to]==1){\n\t\t\titr=graph[x].erase(itr);\n\t\t\tcontinue;\n\t\t}else{\n\t\t\toneway(to);\n\t\t}\n\n\t\titr++;\n\t}\n\n\treturn 0;\n}\n\nint search(int x){\n\tint i,j,k,l;\n\tll int temp[5010];\n\tint to;\n\tll int c,d,e;\n\tint flag=0;\n\n\n\tfor(i=0;i<graph[x].size();i++){\n\t\tsearch(graph[x][i]);\n\t}\n\t\n\tif(graph[x].size()!=0){\n\t\tdp[x][0][0]=a[x];\n\t\tdp[x][0][1]=0;\n\t\tdp[x][1][1]=0;\n\n\t\tfor(i=0;i<graph[x].size();i++){\n\t\t\tto=graph[x][i];\n\t\t\tc=dp[to][0][1];\n\t\t\td=dp[x][0][1];\n\t\t\te=dp[to][2][1];\n\t\t\tfor(j=0;j<=d;j++){\n\t\t\t\ttemp[j]=dp[x][j][0];\n\t\t\t\tdp[x][j][0]=INF;\n\t\t\t}\n\n\t\t\tfor(j=0;j<=d;j++){\n\t\t\t\tfor(k=0;k<=c;k++){\n\t\t\t\t\tdp[x][j+k][0]=min(dp[x][j+k][0],temp[j]+dp[to][k][0]);\n\t\t\t\t}\n\t\t\t\tdp[x][j+e][0]=min(dp[x][j+e][0],temp[j]);\n\t\t\t}\n\n\t\t\tdp[x][0][1]=dp[x][0][1]+c+1;\n\n\t\t\tif(dp[x][1][1]!=INF){\n\t\t\t\tif(a[x]<0){\n\t\t\t\t\tdp[x][1][1]=INF;\n\t\t\t\t}else if(dp[to][1][1]!=INF){\n\t\t\t\t\tdp[x][1][1]=dp[x][1][1]+dp[to][1][1];\n\t\t\t\t}else{\n\t\t\t\t\tdp[x][1][1]=dp[x][1][1]+e;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tflag=0;\n\t\tfor(i=0;i<dp[x][1][1];i++){\n\t\t\tif(dp[x][i][0]<0){\n\t\t\t\tdp[x][2][1]=i+1;\n\t\t\t\tflag=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag==0) dp[x][2][1]=dp[x][1][1]+1;\n\n\n\t}else{\n\t\tdp[x][0][0]=a[x];\n\t\tdp[x][0][1]=0;\n\t\tif(a[x]>0) dp[x][1][1]=0;\n\t\tdp[x][2][1]=1;\n\t}\n\n\treturn 0;\n}\n\n\n\n\n\nint main(void)\n{\n\t//変数の宣言\n\tint n;\n//\tint a[5010];\n\tint u;\n\tint v;\n//\tvector<int> graph[5010];\n//\tll int dp[5010][5010][3];\n\n\t//よく使う変数\n\tint i,j,k,l;\n\tint flag=0;\n\tint ans=0;\n\tint count=0;\n\tll int temp,temp1,temp2;\n\tint max,min;\n\tint len;\n\tint sum=0;\n\tint ok,ng;\n\n\n\n\t//データの読み込み\n\n\tscanf(\"%d\",&n);\n//\tscanf_s(\"%d\",&n);\n\n\tfor(i=1;i<=n;i++){\n\t\tscanf(\"%d\",&a[i]);\n//\t\tscanf_s(\"%d\",&a[i]);\n\t}\n\n\tfor(i=0;i<n-1;i++){\n\t\tscanf(\"%d %d\",&u,&v);\n//\t\tscanf_s(\"%d %d\",&u,&v);\n\t\tgraph[u].push_back(v);\n\t\tgraph[v].push_back(u);\n\t}\n\n\t//\tprintf(\"nは%dです\\n\", n);\n\t//\tprintf(\"データの読み込み終了\\n\");\n\t//実際の処理\n\n\tfor(i=0;i<n+5;i++){\n\t\tcome[i]=0;\n\t\tfor(j=0;j<n+5;j++){\n\t\t\tfor(k=0;k<3;k++){\n\t\t\t\tdp[i][j][k]=INF;\n\t\t\t}\n\t\t}\n\t}\n\n\toneway(1);\n\n\n\tsearch(1);\n\n\t//\tprintf(\"計算部分終了\\n\");\n\n\t//出力\n\t\n\n\tprintf(\"%d\",dp[1][2][1]-1);\n\n\t//\tprintf(\"結果の出力終了\\n\");\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define ll long long\n#define fornum(A,B,C) for(A=B;A<C;A++)\n\nusing namespace std;\n\n/////////////////////////////////////////////////////\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define mp make_pair\n\n#define INF (ll)1e18\n\n\nll N,Q;\nll A[5050];\nvector<ll> tuv[5050];\nvector<ll> dp1[5050], dp2[5050];\n\nll i, j, k, ans;\n\nll minn(ll a,ll b){\n    return a < b ? a : b;\n}\n\nvoid dfs(ll a,ll p){\n    dp1[a].push_back(A[a] > 0 ? A[a] : INF);\n    dp2[a].push_back(A[a]);\n    ll i, j, k;\n    fornum(i,0,tuv[a].size()){\n        ll b = tuv[a][i];\n        if(b==p){\n            continue;\n        }\n        dfs(b, a);\n        ll an = dp1[a].size();\n        ll bn = dp1[b].size();\n        vector<ll> ndp1(an + bn,INF),ndp2(an + bn,INF);\n        fornum(j,0,an){\n            fornum(k,0,bn){\n                if(dp1[a][j]!=INF&&dp1[b][k]!=INF){\n                    ndp1[j + k] = minn(ndp1[j + k], dp1[a][j] + dp1[b][k]);\n                }\n                if(dp2[a][j]!=INF&&dp2[b][k]!=INF){\n                    ndp2[j + k] = minn(ndp2[j + k], dp2[a][j] + dp2[b][k]);\n                }\n                if(dp1[b][k]!=INF||dp2[b][k]<0){\n                    ndp1[j + k + 1] = minn(ndp1[j + k + 1], dp1[a][j]);\n                    ndp2[j + k + 1] = minn(ndp2[j + k + 1], dp2[a][j]);\n                }\n            }\n        }\n        dp1[a] = ndp1;\n        dp2[a] = ndp2;\n    }\n    /*\n    printf(\"%lld:\\n\", a);\n    fornum(i,0,dp1[a].size()){\n        printf(\"%lld,%lld,%lld\\n\", i, dp1[a][i], dp2[a][i]);\n    }\n    */\n}\n\n\nint main(){\n    scanf(\"%lld\", &N);\n    fornum(i,0,N){\n        scanf(\"%lld\", &A[i+1]);\n    }\n    fornum(i,1,N){\n        ll u, v;\n        scanf(\"%lld%lld\", &u, &v);\n        tuv[u].push_back(v);\n        tuv[v].push_back(u);\n    }\n    dfs(1, 0);\n    fornum(i,0,N){\n        fornum(j,0,N){\n        }\n    }\n    fornum(i,0,dp1[1].size()){\n        //printf(\"%lld,%lld,%lld\\n\", i, dp1[1][i], dp2[1][i]);\n        if(dp1[1][i]<INF||dp2[1][i]<0){\n            printf(\"%lld\", i);\n            return 0;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;using ll=long long;using uint=unsigned int;using pii=pair<int,int>;using pll=pair<ll,ll>;using ull = unsigned long long;using ld=long double;template<typename T>void _(const char*s,T h){cerr<<s<<\" = \"<<h<<\"\\n\";}template<typename T,typename...Ts>void _(const char*s,T h,Ts...t){int b=0;while(((b+=*s=='(')-=*s==')')!=0||*s!=',')cerr<<*s++;cerr<<\" = \"<<h<<\",\";_(s+1,t...);}// break continue pop_back 998244353\n#define int ll\n#define pii pll\n#define f first\n#define s second\n#define pb emplace_back\n#define forn(i,n) for(int i=0;i<(n);++i)\n#define sz(a)((int)(a).size())\n#define sqr(x) ((x)*(x))\nstruct init{init(){cin.tie(0);iostream::sync_with_stdio(0);cout<<fixed<<setprecision(10);cerr<<fixed<<setprecision(5);}~init(){\n#ifdef LOCAL\n#define dbg(...) _(#__VA_ARGS__,__VA_ARGS__)\ncerr<<\"Time elapsed: \"<<(double)clock()/CLOCKS_PER_SEC<<\"s.\\n\";\n#else\n#define dbg(...) \n#endif\n}}init;template<typename T,typename U>void upx(T&x,U y){if(x<y)x=y;}template<typename T,typename U>void upn(T&x,U y){if(x>y)x=y;}mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());const int D=4,dx[]={+1,0,-1,0},dy[]={0,+1,0,-1};\nconst int N=5001,OO=1e18;\nint dp[N][N],ba[N][N];\nint a[N];\nvector<int> g[N];\nint sz[N],dv[N],du[N],dt[N];\nvoid dfs(int v,int p=0){\n    sz[v]=1;\n    for(int to:g[v]){\n        if(to^p){\n            dfs(to,v);\n            sz[v]+=sz[to];\n        }\n    }\n    // forn(i,sz[v])dp[v][i]=ba[v][i]=OO;\n    {\n        int maxv=0;\n        forn(i,N)dv[i]=OO;\n        dv[0]=0;\n        for(int to:g[v]){\n            if(to^p){\n                int maxto=sz[to];\n                forn(i,maxv+maxto+2)dt[i]=OO;\n                forn(i,maxto+1){\n                    du[i]=dp[to][i];\n                    if(i&&du[i-1]<0)upn(du[i],0);\n                    if(i&&a[to]>0&&ba[to][i-1])upn(du[i],0);\n                }\n                forn(i,maxv+1){\n                    forn(j,maxto+1){\n                        upn(dt[i+j],dv[i]+du[j]);\n                    }\n                }\n                forn(i,maxv+maxto+2)dv[i]=dt[i];\n                maxv+=maxto;\n            }\n        }\n        forn(i,sz[v])dp[v][i]=dv[i]+a[v];\n    }\n    if(a[v]>0){\n        int maxv=0;\n        forn(i,N)dv[i]=0;\n        dv[0]=1;\n        for(int to:g[v]){\n            if(to^p){\n                int maxto=sz[to];\n                forn(i,maxv+maxto+2)dt[i]=0;\n                forn(i,maxto+1){\n                    if(a[to]>0){\n                        du[i]=ba[to][i];\n                        if(i)du[i]|=ba[to][i-1];\n                        if(i)du[i]|=dp[to][i-1]<0;\n                    }else{\n                        du[i]=0;\n                        if(i)du[i]=dp[to][i-1]<0;\n                    }\n                }\n                // if(v==3){\n                //     dbg(to);\n                //     forn(i,maxv+1)dbg(i,dv[i]);\n                //     forn(i,maxto+1)dbg(i,du[i]);\n                // }\n                forn(i,maxv+1){\n                    forn(j,maxto+1){\n                        dt[i+j]|=dv[i]&du[j];\n                    }\n                }\n                forn(i,maxv+maxto+2)dv[i]=dt[i];\n                maxv+=maxto;\n            }\n        }\n        forn(i,sz[v])ba[v][i]=dv[i];\n    }else{\n        // forn(i,sz[v])if(dp[v][i]<0)ba[v][i]=1;\n    }\n    dbg(v,a[v]);\n    forn(i,sz[v])dbg(dp[v][i],ba[v][i]);\n    dbg(\"=====\");\n}\nint32_t main(){\n    int n;\n    cin>>n;\n    for(int i=1;i<=n;++i)cin>>a[i];\n    forn(i,n-1){\n        int x,y;\n        cin>>x>>y;\n        g[x].pb(y);\n        g[y].pb(x);\n    }\n    dfs(1);\n    int ans=N;\n    forn(i,n){\n        if(a[1]>0&&ba[1][i]){\n            ans=i;\n            break;\n        }\n        if(a[1]<0&&dp[1][i]<0){\n            ans=i;\n            break;\n        }\n    }\n    cout<<ans<<'\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cmath>  \n#include <cstdlib>\n#include <ctime>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <string> \n#include <vector>\n#include <bitset>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n\nusing namespace std;\nusing ll = long long;\n\n#define REP(i,n) for(long long i = 0; i < (n); i++)\n#define FOR(i, m, n) for(long long i = (m);i < (n); ++i)\n#define ALL(obj) (obj).begin(),(obj).end()\n\ntemplate<class T> using V = vector<T>;\ntemplate<class T, class U> using P = pair<T, U>;\n\nconst ll MOD = (ll)1e9 + 7;\nconst ll MOD2 = 998244353;\nconst ll LLINF = (ll)1e18;\nconst ll INTINF = (ll)1e9;\nconst long double PI = 3.1415926535897932384626433;\n\ntemplate <class T> void corner(bool flg, T hoge) {if (flg) {cout << hoge << endl; exit(0);}}\ntemplate <class T, class U>ostream &operator<<(ostream &o, const map<T, U>&obj) {o << \"{\"; for (auto &x : obj) o << \" {\" << x.first << \" : \" << x.second << \"}\" << \",\"; o << \" }\"; return o;}\ntemplate <class T>ostream &operator<<(ostream &o, const set<T>&obj) {o << \"{\"; for (auto itr = obj.begin(); itr != obj.end(); ++itr) o << (itr != obj.begin() ? \", \" : \"\") << *itr; o << \"}\"; return o;}\ntemplate <class T>ostream &operator<<(ostream &o, const vector<T>&obj) {o << \"{\"; for (int i = 0; i < (int)obj.size(); ++i)o << (i > 0 ? \", \" : \"\") << obj[i]; o << \"}\"; return o;}\ntemplate <class T, class U>ostream &operator<<(ostream &o, const pair<T, U>&obj) {o << \"{\" << obj.first << \", \" << obj.second << \"}\"; return o;}\ntemplate <template <class tmp>  class T, class U> ostream &operator<<(ostream &o, const T<U> &obj) {o << \"{\"; for (auto itr = obj.begin(); itr != obj.end(); ++itr)o << (itr != obj.begin() ? \", \" : \"\") << *itr; o << \"}\"; return o;}\nvoid print(void) {cout << endl;}\ntemplate <class Head> void print(Head&& head) {cout << head;print();}\ntemplate <class Head, class... Tail> void print(Head&& head, Tail&&... tail) {cout << head << \" \";print(forward<Tail>(tail)...);}\ntemplate <class T> void chmax(T& a, const T b){a=max<T>(a,b);}\ntemplate <class T> void chmin(T& a, const T b){a=min<T>(a,b);}\nvoid YN(bool flg) {cout << ((flg) ? \"YES\" : \"NO\") << endl;}\nvoid Yn(bool flg) {cout << ((flg) ? \"Yes\" : \"No\") << endl;}\nvoid yn(bool flg) {cout << ((flg) ? \"yes\" : \"no\") << endl;}\n\nint main() {\n\tint N; cin >> N;\n\tV<ll> A(N); REP(i,N) cin >> A[i];\n\tV<V<int>> edge(N);\n\tREP(i,N-1){\n\t\tint U,V; cin >> U >> V;\n\t\tU--,V--;\n\t\tedge[U].push_back(V);\n\t\tedge[V].push_back(U);\t\t\n\t}\n\tV<int> depth(N,-1),scale(N,1),parent(N,-1);\n\tdepth[0] = 0;\n\tqueue<int> q; q.push(0);\n\twhile(q.size()){\n\t\tint from = q.front();\n\t\tq.pop();\n\t\tfor(auto to: edge[from]){\n\t\t\tif(depth[to]!=-1) continue;\n\t\t\tdepth[to] = depth[from] + 1;\n\t\t\tparent[to] = from;\n\t\t\tq.push(to);\n\t\t}\n\t}\n\tV<P<int,int>> ord(N);\n\tREP(i,N) ord[i] = {-depth[i],i};\n\tsort(ALL(ord));\n\t\n\tV<V<ll>> dp1(N,V<ll>(N,LLINF)),dp2(N,V<ll>(N,LLINF));\n\tREP(i,N) (A[i]>0?dp1:dp2)[i][0] = A[i];\n\n\tfor(int i = 0; i < N-1; ++i){\n\t\tint from = ord[i].second, to = parent[from];\n\t\tif(depth[to]>depth[from]) continue;\n\t\t\n\t\tV<ll> tmp1(N,LLINF),tmp2(N,LLINF);\n\t\tfor(int j = 0; j < scale[to]; ++j){\n\t\t\tfor(int k = 0; k < scale[from]; ++k){\n\t\t\t\t// merge\n\t\t\t\tchmin(tmp1[j+k],dp1[to][j]+dp1[from][k]);\n\t\t\t\tchmin(tmp2[j+k],dp1[to][j]+dp2[from][k]);\n\t\t\t\tchmin(tmp2[j+k],dp2[to][j]+dp1[from][k]);\n\t\t\t\tchmin(tmp2[j+k],dp2[to][j]+dp2[from][k]);\n\n\t\t\t\t// divide\n\t\t\t\tif(dp1[from][k]<LLINF || dp2[from][k] < 0)chmin(tmp1[j+k+1],dp1[to][j]);\n\t\t\t\tif(dp1[from][k]<LLINF || dp2[from][k] < 0)chmin(tmp2[j+k+1],dp2[to][j]);\n\n\t\t\t}\n\t\t}\n\t\tdp1[to] = tmp1;\n\t\tdp2[to] = tmp2;\n\t\tscale[to] += scale[from];\n\t}\n\n\tint ans = N-1;\n\tfor(int j = 0; j < N; ++j){\n\t\tif(dp1[0][j]<LLINF) chmin(ans,j);\n\t\tif(dp2[0][j]<0) chmin(ans,j);\n\t}\n\tcout << ans << endl;\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std;\nconst long long inf = 1234567891234567891;\nconst int inf_int = 1012345678;\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tint N;\n\tcin >> N;\n\tvector<int> A(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> A[i];\n\t}\n\tvector<vector<int> > G(N);\n\tfor (int i = 0; i < N - 1; ++i) {\n\t\tint u1, u2;\n\t\tcin >> u1 >> u2; --u1, --u2;\n\t\tG[u1].push_back(u2);\n\t\tG[u2].push_back(u1);\n\t}\n\tvector<int> c(N, 1);\n\tfunction<void(int, int)> calc_subtree = [&](int pos, int pre) {\n\t\tfor (int i : G[pos]) {\n\t\t\tif (i != pre) {\n\t\t\t\tcalc_subtree(i, pos);\n\t\t\t\tc[pos] += c[i];\n\t\t\t}\n\t\t}\n\t};\n\tcalc_subtree(0, -1);\n\tvector<vector<long long> > dp0(N), dp1(N);\n\tvector<int> commence(N, inf_int);\n\tfunction<void(int, int)> calc = [&](int pos, int pre) {\n\t\tdp0[pos].resize(c[pos] + 1, inf); dp0[pos][0] = 0;\n\t\tdp1[pos].resize(c[pos] + 1, inf);\n\t\tint sum = 1;\n\t\tfor (int i : G[pos]) {\n\t\t\tif (i != pre) {\n\t\t\t\tcalc(i, pos);\n\t\t\t\tfor (int j = sum + c[i] - 1; j >= 0; --j) {\n\t\t\t\t\tdp1[pos][j] = min(min(min(dp0[pos][j], dp1[pos][j]) + dp1[i][0], dp1[pos][j] + dp0[i][0]), inf);\n\t\t\t\t\tdp0[pos][j] = min(dp0[pos][j] + dp0[i][0], inf);\n\t\t\t\t\tfor (int k = 1; k <= c[i] && k <= j; ++k) {\n\t\t\t\t\t\tdp1[pos][j] = min(dp1[pos][j], min(dp0[pos][j - k], dp1[pos][j - k]) + dp1[i][k]);\n\t\t\t\t\t\tdp0[pos][j] = min(dp0[pos][j], dp0[pos][j - k] + dp0[i][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsum += c[i];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < c[pos]; ++i) {\n\t\t\tif (A[pos] > 0) {\n\t\t\t\tdp0[pos][i] += A[pos];\n\t\t\t\tdp1[pos][i] += A[pos];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp1[pos][i] = min(dp0[pos][i], dp1[pos][i]) + A[pos];\n\t\t\t\tdp0[pos][i] = inf;\n\t\t\t}\n\t\t}\n\t\tfor (int i = c[pos] - 1; i >= 0; --i) {\n\t\t\tif (dp0[pos][i] < inf / 2 || dp1[pos][i] < 0) {\n\t\t\t\tdp0[pos][i + 1] = min(dp0[pos][i + 1], (long long)(0));\n\t\t\t\tcommence[pos] = i;\n\t\t\t}\n\t\t}\n\t};\n\tcalc(0, -1);\n\tcout << commence[0] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define SORT(a) sort(a.begin(), a.end())\n#define REVERSE(a) reverse(a.begin(), a.end())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define int long long\n#define INF 1000000000000000000\nusing namespace std;\n\n#define ANS(f) if(f) cout << \"YES\" << endl; else cout << \"NO\" << endl;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef pair<int, int> Pii;\n\ntemplate<typename T>\nvoid readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readi(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\nvoid debug(mat m){REP(i, m.size()){ REP(j, m[i].size()){ cout << m[i][j] << \",\"; } cout << endl; }}\n\nstruct edge{int to, cost;};\n\nclass Graph\n{\npublic:\n    int V;\n    vector<vector<edge>> G;\n    vector<mat> dp;\n    vec sz;\n\n    Graph(int V): V(V){\n        G = vector<vector<edge>>(V, vector<edge>(0));\n        dp = vector<mat>(V);\n        sz = vec(V, 1);\n    }\n\n    void add_edge(int from, int to, int cost){\n        G[from].push_back(edge({to, cost}));\n    }\n\n    void add_edge2(int v1, int v2, int cost){\n        add_edge(v1, v2, cost);\n        add_edge(v2, v1, cost);\n    }\n\n    void dfs(int v, vec &A, int par){\n        vec chi(0);\n        REP(k, G[v].size()){\n            if(G[v][k].to != par){\n                chi.push_back(G[v][k].to);\n                dfs(G[v][k].to, A, v);\n            }\n        }\n        vector<mat> dq(chi.size() + 1);\n        dq[0] = mat(2, vec(1, INF));\n        if(A[v] > 0) dq[0][0][0] = A[v];\n        else dq[0][1][0] = A[v];\n\n        REP(i, chi.size()){\n            int c = chi[i];\n            dq[i + 1] = mat(2, vec(sz[v] + sz[c], INF));\n            \n            int m = INF;\n            REP(j, sz[c]){\n                if(dp[c][0][j] < INF || dp[c][1][j] < 0){\n                    m = j;\n                    break;\n                }\n            }\n            if(m < INF){\n                REP(j, sz[v]){\n                    dq[i + 1][0][j + m + 1] = dq[i][0][j];\n                    dq[i + 1][1][j + m + 1] = dq[i][1][j];\n                }\n            }\n\n            REP(j, sz[c]) REP(k, sz[v]){\n                if(dp[c][0][j] < INF && dq[i][0][k] < INF) dq[i + 1][0][j + k] = min(dq[i + 1][0][j + k], dp[c][0][j] + dq[i][0][k]);\n                if(dp[c][1][j] < INF && dq[i][1][k] < INF) dq[i + 1][1][j + k] = min(dq[i + 1][1][j + k], dp[c][1][j] + dq[i][1][k]);\n                if(dp[c][0][j] < INF && dq[i][1][k] < INF) dq[i + 1][1][j + k] = min(dq[i + 1][1][j + k], dp[c][0][j] + dq[i][1][k]);\n                if(dp[c][1][j] < INF && dq[i][0][k] < INF) dq[i + 1][1][j + k] = min(dq[i + 1][1][j + k], dp[c][1][j] + dq[i][0][k]);\n            }\n\n            sz[v] += sz[c];\n        }\n\n        dp[v] = dq[chi.size()];\n    }\n\n};\n\nsigned main(){\n\n    int N; cin >> N;\n    Graph T(N);\n    vec A(N); readv(A);\n    int U, V;\n    REP(i, N - 1){\n        cin >> U >> V;\n        T.add_edge2(U - 1, V - 1, 0);\n    }\n    T.dfs(0, A, -1);\n    int ans = INF;\n    REP(i, N){\n        if(T.dp[0][0][i] < INF || T.dp[0][1][i] < 0){\n            ans = i;\n            break;\n        }\n    }\n    cout << ans;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <stack>\n#include <tuple>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <iomanip>\n\n#define int long long int\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() )\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int INF = 1e15;\nconst int MOD = 1e9+7;\n\nint n;\nvector<int> a, child;\nvector<vector<int>> edge;\nint dp[5001][5001][2];\nint sub[5001][2];\n\nvoid dfs(int v, int par){\n    if(a[v] > 0){\n        dp[v][0][0] = a[v];\n    }else{\n        dp[v][0][1] = a[v];\n    }\n\n    child[v] = 1;\n\n    for(int u : edge[v]){\n        if(u == par){\n            continue;\n        }\n        dfs(u, v);\n        for(int i = 0; i < child[v]; i++){\n            for(int j = 0; j < child[u]; j++){\n                rep(k1, 2) rep(k2, 2){\n                    sub[i+j][k1|k2] = min(sub[i+j][k1|k2], dp[v][i][k1] + dp[u][j][k2]);\n                    if(k2 == 0 && dp[u][j][k2] < INF || dp[u][j][k2] < 0){\n                        sub[i+j+1][k1] = min(sub[i+j+1][k1], dp[v][i][k1]);\n                    }\n                }\n\n            }\n        }\n        child[v] += child[u];\n        for(int i = 0; i < child[v]; i++){\n            rep(k, 2){\n                dp[v][i][k] = sub[i][k];\n                sub[i][k] = INF;\n            }\n        }\n    }\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    cin >> n;\n    a = vector<int>(n + 1);\n    rep(i, n) cin >> a[i+1];\n\n    edge = vector<vector<int>>(n + 1, vector<int>());\n    rep(i, n - 1){\n        int u, v;\n        cin >> u >> v;\n        edge[u].push_back(v);\n        edge[v].push_back(u);\n    }\n\n    rep(i, n+1) rep(j, n+1) rep(k, 2) dp[i][j][k] = INF;\n    rep(i, n+1) rep(k, 2) sub[i][k] = INF;\n\n    child = vector<int>(n + 1);\n    dfs(1, 0);\n\n    int ans = INF;\n    rep(i, n + 1){\n        if(dp[1][i][0] != INF){\n            ans = min(ans, i);\n        }\n        if(dp[1][i][1] < 0){\n            ans = min(ans, i);\n        }\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nvector <int> g[5555];\nlong long dp[5005][5005];\nlong long fn[5005][5005];\nbool gn[5005][5005];\nbool pos[5005][5005];\n\nint sub[5555];\nint a[5555];\nint n;\n\nconst long long inf = 1e15;\n\nvoid dfs(int x, int par) {\n\tsub[x] = 1;\n\tfor(auto i : g[x]) {\n\t\tif(i - par) {\n\t\t\tdfs(i, x);\n\t\t\tsub[x] += sub[i];\n\t\t}\n\t}\n\tvector <int> c;\n\tint deg = 0;\n\tfor(auto i : g[x]) {\n\t\tif(i - par) {\n\t\t\tc.emplace_back(i);\n\t\t\t++deg;\n\t\t}\n\t}\n\tfor(int i = 1; i <= deg; i++) {\n\t\tfor(int j = 0; j <= sub[x]; j++) {\n\t\t\tfn[i][j] = inf;\n\t\t\tgn[i][j] = false;\n\t\t}\n\t}\n\tfor(int j = 0; j <= sub[x]; j++) {\n\t\tgn[0][j] = (a[x] > 0);\n\t}\n\tfor(int i = 1; i <= deg; i++) {\n\t\tint node = c[i - 1];\n\t\tfor(int j = 0; j <= sub[x]; j++) {\n\t\t\tfor(int k = 0; k <= sub[node]; k++) {\n\t\t\t\tif(dp[node][k] < 0 || pos[node][k]) {\n\t\t\t\t\tfn[i][j + k + 1] = min(fn[i][j + k], fn[i - 1][j]);\n\t\t\t\t}\n\t\t\t\tfn[i][j + k] = min(fn[i][j + k], fn[i - 1][j] + dp[node][k]);\n\t\t\t}\n\t\t\tfor(int k = 0; k <= sub[node]; k++) {\n\t\t\t\tif(dp[node][k] < 0 || pos[node][k]) {\n\t\t\t\t\tgn[i][j + k + 1] |= gn[i - 1][j];\n\t\t\t\t}\n\t\t\t\tgn[i][j + k] |= gn[i - 1][j] && pos[node][k];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i <= n; i++) {\t\n\t\tdp[x][i] = a[x] + fn[deg][i];\n\t\tpos[x][i] = gn[deg][i];\n\t}\n}\nint main(int argc, char const *argv[])\n{\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tfor(int i = 1; i < n; i++) {\n\t\tint p, q;\n\t\tscanf(\"%d %d\", &p, &q);\n\t\tg[p].emplace_back(q);\n\t\tg[q].emplace_back(p);\n\t}\n\tfor(int i = 0; i <= n; i++) {\n\t\tfor(int j = 0; j <= n; j++) {\n\t\t\tdp[i][j] = inf;\n\t\t}\n\t}\n\tdfs(1, 0);\n\tint ans = -1;\n\tfor(int i = n; i >= 0; i--) {\n\t\tif(dp[1][i] < 0 || pos[1][i]) {\n\t\t\tans = i;\n\t\t}\n\t}\n\tassert(ans >= 0);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int64 INF = 1LL << 58;\n\nvector< int > g[5000];\nint N, A[5000];\nvector< bool > latte[5000];\nvector< int64 > malta[5000];\n\nvoid chmin(int64 &a, int64 b) { a = min(a, b); }\n\nvoid dfs(int idx, int par) {\n  for(auto &to : g[idx]) {\n    if(to == par) continue;\n    dfs(to, idx);\n  }\n\n  latte[idx].emplace_back(A[idx] > 0);\n  for(auto &to : g[idx]) {\n    if(to == par) continue;\n    if(A[to] > 0) {\n      vector< bool > nxt(latte[idx].size() + latte[to].size());\n      for(int i = 0; i < latte[idx].size(); i++) {\n        for(int j = 0; j < latte[to].size(); j++) {\n          if(latte[idx][i] & latte[to][j]) {\n            nxt[i + j] = true;\n          }\n        }\n        for(int j = 0; j < malta[to].size(); j++) {\n          if(!latte[idx][i] || malta[to][j] >= 0) continue;\n          nxt[i + j + 1] = true;\n        }\n      }\n      latte[idx].swap(nxt);\n    } else {\n      vector< bool > nxt(latte[idx].size() + latte[to].size());\n      for(int i = 0; i < latte[idx].size(); i++) {\n        for(int j = 0; j < malta[to].size(); j++) {\n          if(!latte[idx][i] || malta[to][j] >= 0) continue;\n          nxt[i + j + 1] = true;\n        }\n      }\n      latte[idx].swap(nxt);\n    }\n  }\n\n\n  malta[idx].emplace_back(A[idx]);\n  for(auto &to : g[idx]) {\n    if(to == par) continue;\n    vector< int64 > nxt(malta[idx].size() + malta[to].size(), INF);\n    for(int i = 0; i < malta[idx].size(); i++) {\n      for(int j = 0; j < latte[to].size(); j++) {\n        if(latte[to][j]) chmin(nxt[i + j + 1], malta[idx][i]);\n      }\n      for(int j = 0; j < malta[to].size(); j++) {\n        if(malta[idx][i] == INF) continue;\n        if(malta[to][j] == INF) continue;\n        chmin(nxt[i + j], malta[idx][i] + malta[to][j]);\n      }\n    }\n    malta[idx].swap(nxt);\n  }\n\n  for(int i = 0; i < malta[idx].size(); i++) {\n    if(malta[idx][i] < 0) latte[idx][i] = true;\n  }\n\n}\n\n\nint main() {\n  cin >> N;\n  for(int i = 0; i < N; i++) cin >> A[i];\n  for(int i = 1; i < N; i++) {\n    int x, y;\n    cin >> x >> y;\n    --x, --y;\n    g[x].emplace_back(y);\n    g[y].emplace_back(x);\n  }\n  dfs(0, -1);\n  for(int i = 0; i < latte[0].size(); i++) {\n    if(latte[0][i]) {\n      cout << i << endl;\n      exit(0);\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF (1LL << 60)\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n\nusing namespace std;\n\ntemplate<typename S,typename T>auto&operator<<(ostream&o,pair<S,T>p){return o<<\"{\"<<p.fi<<\",\"<<p.se<<\"}\";}\ntemplate<typename T>auto&operator<<(ostream&o,set<T>s){for(auto&e:s)o<<e<<\" \";return o;}\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,priority_queue<S,T,U>q){while(!q.empty())o<<q.top()<<\" \",q.pop();return o;}\ntemplate<typename K,typename T>auto&operator<<(ostream&o,map<K,T>&m){for(auto&e:m)o<<e<<\" \";return o;}\ntemplate<typename T>auto&operator<<(ostream&o,vector<T>v){for(auto&e:v)o<<e<<\" \";return o;}\nvoid ashow(){cout<<endl;}template<typename T,typename...A>void ashow(T t,A...a){cout<<t<<\" \";ashow(a...);}\ntemplate<typename S,typename T,typename U>\nstruct TRI{S fi;T se;U th;TRI(){}TRI(S f,T s,U t):fi(f),se(s),th(t){}};\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,TRI<S,T,U>&t){return o<<\"{\"<<t.fi<<\",\"<<t.se<<\",\"<<t.th<<\"}\";}\n\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> pll;\ntypedef TRI<int, int, int> tri;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\n\nconst int MAX_N = 5005;\n\nvector<int> G[MAX_N];\nll dp[MAX_N][MAX_N][2][2];\nll a[MAX_N];\n\nint dfs(int u, int p)\n{\n    int nw = 0;\n    dp[u][0][0][0] = dp[u][0][1][0] = INF;\n    if(a[u] < 0) dp[u][0][1][0] = a[u];\n    else dp[u][0][0][0] = a[u];\n    for(int v : G[u]){\n        if(v != p){\n            int st = dfs(v, u);\n            rep(j,nw+st+1){\n                rep(k,2){\n                    dp[u][j][k][1] = INF;\n                }\n            }\n            rrep(i,nw+1){\n                rep(j,st){\n                    // 0 の場合\n                    cmn(dp[u][i+j][0][1], dp[u][i][0][0]+dp[v][j][0][0]);\n                    // 1 の場合\n                    cmn(dp[u][i+j][1][1], dp[u][i][0][0]+dp[v][j][1][0]);\n                    cmn(dp[u][i+j][1][1], dp[u][i][1][0]+dp[v][j][0][0]);\n                    cmn(dp[u][i+j][1][1], dp[u][i][1][0]+dp[v][j][1][0]);\n                    // 切る場合\n                    if(dp[v][j][0][0] <= INF/10 || dp[v][j][1][0] < 0){\n                        cmn(dp[u][i+j+1][0][1], dp[u][i][0][0]);\n                        cmn(dp[u][i+j+1][1][1], dp[u][i][1][0]);\n                    }\n                }\n            }\n            nw += st;\n            rep(j,nw+1){\n                rep(k,2){\n                    dp[u][j][k][0] = dp[u][j][k][1];\n                }\n            }\n        }\n    }\n    return nw+1;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    rep(i,n){\n        cin >> a[i];\n    }\n    rep(i,n-1){\n        int u,v;\n        cin >> u >> v;\n        G[u-1].pb(v-1), G[v-1].pb(u-1);\n    }\n    dfs(0, -1);\n    int ans = n-1;\n    rep(i,n){\n        if(dp[0][i][0][0] <= INF/10) cmn(ans, i);\n        if(dp[0][i][1][0] < 0) cmn(ans, i);\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; ++i )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef pair<ll,int> pli;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\nvector<int> v[5050];\nvector<ll> dp[5050][2];\nint sz[5050];\nll a[5050];\nvoid dfs(int x,int p){\n    sz[x]=0;\n    dp[x][0].resize(1);\n    dp[x][1].resize(1);\n    for(auto to:v[x]){\n        if(to==p)continue;\n        dfs(to,x);\n        vector<ll> ret0(sz[x]+sz[to]+1,longinf),ret1(sz[x]+sz[to]+1,longinf);\n        rep(i,sz[x]+1)rep(j,sz[to]+1){\n            ret0[i+j]=min(ret0[i+j],min(dp[x][0][i],dp[x][1][i])+min(dp[to][0][j],dp[to][1][j]));\n            ret1[i+j]=min(ret1[i+j],dp[x][1][i]+dp[to][1][j]);\n        }\n        sz[x]+=sz[to];\n        dp[x][0]=ret0;\n        dp[x][1]=ret1;\n    }\n    ++sz[x];\n    dp[x][0].push_back(longinf);\n    dp[x][1].push_back(longinf);\n    for(int i=sz[x]-1;i>=0;--i){\n        dp[x][0][i+1]+=a[x];\n        if(dp[x][0][i]+a[x]<0)dp[x][0][i+1]=min(dp[x][0][i+1],0LL);\n        if(dp[x][1][i]<longinf&&a[x]>0)dp[x][0][i+1]=min(dp[x][0][i+1],0LL);\n        if(a[x]>0){\n            dp[x][1][i+1]+=a[x];\n            if(dp[x][1][i]<longinf||dp[x][0][i]+a[x]<0)dp[x][1][i+1]=0;\n        }\n        else {\n            if(dp[x][1][i]+a[x]<0||dp[x][0][i]+a[x]<0)dp[x][1][i+1]=0;\n            else dp[x][1][i+1]=longinf;\n        }\n    }\n    dp[x][0][0]+=a[x];\n    dp[x][1][0]=(a[x]>0?min(longinf,dp[x][1][0]+a[x]):longinf);\n}\n\n\n\nint main(){\n    int n;\n    cin>>n;\n    rep(i,n)cin>>a[i];\n    rep(i,n-1){\n        int x,y;\n        cin>>x>>y;\n        --x;--y;\n        v[x].push_back(y);\n        v[y].push_back(x);\n    }\n    dfs(0,-1);\n    rep(i,n+1){\n        if(dp[0][0][i]<0||dp[0][1][i]<longinf){\n            cout<<i<<endl;\n            return 0;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=998244353,MAX=5003;\nconst ll INF=1LL<<60;\nll dp[MAX][MAX][2];//iの部分木でj個カットして(k=0のとき全部正,k=1のとき直近の最小の和)\nll cost[MAX];\nint size[MAX];\n\nvector<int> G[MAX];\n\nvoid sizeDFS(int u,int p){\n    size[u]=1;\n    for(int to:G[u]){\n        if(to==p) continue;\n        sizeDFS(to,u);\n        size[u]+=size[to];\n    }\n}\n\nvoid DFS(int u,int p){\n    int sizesum=0;\n    dp[u][0][1]=cost[u];\n    \n    if(cost[u]>0){\n        dp[u][0][0]=cost[u];\n    }\n    \n    for(int to:G[u]){\n        if(to==p) continue;\n        \n        DFS(to,u);\n        \n        ll subdp[sizesum+size[to]+2][2];\n        \n        for(int i=0;i<sizesum+size[to]+2;i++){\n            subdp[i][0]=INF;\n            subdp[i][1]=INF;\n        }\n        \n        for(int i=0;i<=sizesum;i++){\n            for(int j=0;j<=size[to];j++){\n                if(dp[to][j][0]<INF) subdp[i+j][0]=min(subdp[i+j][0],dp[u][i][0]+dp[to][j][0]);//つなぐ\n                if((0<=dp[to][j][0]&&dp[to][j][0]<INF)||dp[to][j][1]<0) subdp[i+j+1][0]=min(subdp[i+j+1][0],dp[u][i][0]);//きる\n                \n                for(int bit=0;bit<4;bit++){\n                    subdp[i+j][1]=min(subdp[i+j][1],dp[u][i][bit/2]+dp[to][j][bit%2]);//つなぐ\n                    \n                    if(bit%2==0){\n                        if(0<=dp[to][j][bit%2]&&dp[to][j][bit%2]<INF) subdp[i+j+1][1]=min(subdp[i+j+1][1],dp[u][i][bit/2]);//きる\n                    }else{\n                        if(dp[to][j][bit%2]<0) subdp[i+j+1][1]=min(subdp[i+j+1][1],dp[u][i][bit/2]);//きる\n                    }\n                }\n                \n            }\n        }\n        \n        for(int i=0;i<sizesum+size[to]+2;i++){\n            dp[u][i][0]=subdp[i][0];\n            dp[u][i][1]=subdp[i][1];\n        }\n        \n        sizesum+=size[to]+1;\n    }\n}\n\nint main(){\n    \n    int N;cin>>N;\n    for(int i=0;i<=N;i++){\n        for(int j=0;j<=N;j++){\n            dp[i][j][0]=INF;\n            dp[i][j][1]=INF;\n        }\n    }\n    \n    for(int i=0;i<N;i++) cin>>cost[i];\n    \n    for(int i=0;i<N-1;i++){\n        int a,b;cin>>a>>b;\n        a--;b--;\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n    \n    sizeDFS(0,-1);\n    \n    DFS(0,-1);\n    \n    for(int j=0;j<=N+3;j++){\n        if(dp[0][j][0]<INF||dp[0][j][1]<0){\n            cout<<j<<endl;\n            return 0;\n        }\n    }\n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> v2l;\ntypedef vector<bool> vb;\ntypedef vector<vb> v2b;\n\nconst ll AMAX = 5e12;\n\nint dfs(vi e[], int x, int p, v2l &dp1, v2b &dp2) {\n    int sz = 1;\n\n    for (int y : e[x]) {\n        if (y == p) {\n            continue;\n        }\n\n        int ysz = dfs(e, y, x, dp1, dp2);\n        for (int i = sz - 1; i >= 0; i--) {\n            for (int j = ysz - 1; j >= 0; j--) {\n                if (j > 0) {\n                    dp1[x][i+j] = min(dp1[x][i+j], dp1[x][i] + dp1[y][j]);\n                    dp2[x][i+j] = dp2[x][i+j] || dp2[x][i] && dp2[y][j];\n                }\n                if (dp1[y][j] < 0 || dp2[y][j]) {\n                    dp1[x][i+j+1] = min(dp1[x][i+j+1], dp1[x][i]);\n                    dp2[x][i+j+1] = dp2[x][i+j+1] || dp2[x][i];\n                }\n            }\n            dp1[x][i] = min(AMAX, dp1[x][i] + dp1[y][0]);\n            dp2[x][i] = dp2[x][i] && dp2[y][0];\n        }\n\n        sz += ysz;\n    }\n\n    return sz;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    int a[n];\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n    vi e[n];\n    for (int i = 0; i < n - 1; i++) {\n        int u, v;\n        cin >> u >> v;\n        u--, v--;\n        e[u].push_back(v);\n        e[v].push_back(u);\n    }\n\n    v2l dp1(n, vl(n, AMAX));\n    for (int i = 0; i < n; i++) {\n        dp1[i][0] = a[i];\n    }\n\n    v2b dp2(n, vb(n, false));\n    for (int i = 0; i < n; i++) {\n        if (a[i] > 0) {\n            dp2[i][0] = true;\n        }\n    }\n\n    dfs(e, 0, -1, dp1, dp2);\n\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        if (dp1[0][i] < 0 || dp2[0][i]) {\n            ans = i;\n            break;\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\n#define li          long long int\n#define rep(i,to)   for(li i=0;i<((li)(to));i++)\n#define repp(i,start,to)    for(li i=(li)(start);i<((li)(to));i++)\n#define pb          push_back\n#define sz(v)       ((li)(v).size())\n#define bgn(v)      ((v).begin())\n#define eend(v)     ((v).end())\n#define allof(v)    (v).begin(), (v).end()\n#define dodp(v,n)       memset(v,(li)n,sizeof(v))\n#define bit(n)      (1ll<<(li)(n))\n#define mp(a,b)     make_pair(a,b)\n#define rin rep(i,n)\n#define EPS 1e-12\n#define ETOL 1e-8\n#define MOD 1000000007\ntypedef pair<li, li> PI;\n\n#define INF bit(60)\n\n#define DBGP 1\n\n\n#define idp if(DBGP)\n#define F first\n#define S second\n#define p2(a,b)     idp cout<<a<<\"\\t\"<<b<<endl\n#define p3(a,b,c)       idp cout<<a<<\"\\t\"<<b<<\"\\t\"<<c<<endl\n#define p4(a,b,c,d)     idp cout<<a<<\"\\t\"<<b<<\"\\t\"<<c<<\"\\t\"<<d<<endl\n#define p5(a,b,c,d,e)       idp cout<<a<<\"\\t\"<<b<<\"\\t\"<<c<<\"\\t\"<<d<<\"\\t\"<<e<<endl\n#define p6(a,b,c,d,e,f)     idp cout<<a<<\"\\t\"<<b<<\"\\t\"<<c<<\"\\t\"<<d<<\"\\t\"<<e<<\"\\t\"<<f<<endl\n#define p7(a,b,c,d,e,f,g)       idp cout<<a<<\"\\t\"<<b<<\"\\t\"<<c<<\"\\t\"<<d<<\"\\t\"<<e<<\"\\t\"<<f<<\"\\t\"<<g<<endl\n#define p8(a,b,c,d,e,f,g,h)     idp cout<<a<<\"\\t\"<<b<<\"\\t\"<<c<<\"\\t\"<<d<<\"\\t\"<<e<<\"\\t\"<<f<<\"\\t\"<<g<<\"\\t\"<<h<<endl\n#define p9(a,b,c,d,e,f,g,h,i)       idp cout<<a<<\"\\t\"<<b<<\"\\t\"<<c<<\"\\t\"<<d<<\"\\t\"<<e<<\"\\t\"<<f<<\"\\t\"<<g<<\"\\t\"<<h<<\"\\t\"<<i<<endl\n#define p10(a,b,c,d,e,f,g,h,i,j)        idp cout<<a<<\"\\t\"<<b<<\"\\t\"<<c<<\"\\t\"<<d<<\"\\t\"<<e<<\"\\t\"<<f<<\"\\t\"<<g<<\"\\t\"<<h<<\"\\t\"<<i<<\"\\t\"<<j<<endl\n#define foreach(it,v)   for(__typeof((v).begin()) it=(v).begin(); it!=(v).end(); ++it)\n#define p2p(x)      idp p2((x).F, (x).S)\n#define dump(x,n)   idp{rep(i,n){cout<<x[i]<<\" \";}puts(\"\");}\n#define dump2(x,n)  idp{rep(i,n){cout<<\"[\"<<x[i].F<<\" , \"<<x[i].S<<\"] \";}puts(\"\");}\n#define dumpi(x)    idp{foreach(it, x){cout<<(*it)<<\" \";}puts(\"\");}\n#define dumpi2(x)   idp{foreach(it, x){cout<<\"[\"<<(it)->F<<\" , \"<<(it)->S<<\"] \";}puts(\"\");}\n\n#define read2d(a,w,h)   rep(i,h)rep(j,w)cin>>a[i][j]\n#define dump2d(a,w,h)   rep(i,h){rep(j,w)cout<<a[i][j]<<\" \";puts(\"\");}\n\ntypedef pair<li, li> PI;\n\n\n// dp1[i][j] : i以下の部分木をj個に分け、iが入るパーツが全部正な場合の最小値\nvector<li> dp1[5050];\n// dp2[i][j] : i以下の部分木をj個に分け、iが入るパーツの最小値\nvector<li> dp2[5050];\n\nli n;\nvector<li> edge[5050];\nli a[5050];\n\ninline vector<li> merge1(const vector<li>& parent,\n                         const vector<li>& child,\n                         const vector<li>& child2) {\n    li num1 = sz(parent) - 1;\n    li num2 = sz(child) - 1;\n    vector<li> res(num1 + num2 + 1, INF);\n    repp(i, 1, sz(parent)) {\n        repp(j, 1, sz(child)) {\n            if (parent[i] == INF) {\n                continue;\n            }\n            // merge\n            res[i + j - 1] = min(res[i + j - 1], parent[i] + child[j]);\n            // not merge\n            if (child2[j] < 0 || child[j] != INF) {\n                res[i + j] = min(res[i + j], parent[i]);\n            }\n        }\n    }\n    return res;\n}\n\ninline vector<li> merge2(const vector<li>& parent,\n                         const vector<li>& child1,\n                         const vector<li>& child) {\n    li num1 = sz(parent) - 1;\n    li num2 = sz(child) - 1;\n    vector<li> res(num1 + num2 + 1, INF);\n    repp(i, 1, sz(parent)) {\n        repp(j, 1, sz(child)) {\n            // merge\n            res[i + j - 1] = min(res[i + j - 1], parent[i] + child[j]);\n            // not merge\n            if (child[j] < 0 || child1[j] != INF) {\n                res[i + j] = min(res[i + j], parent[i]);\n            }\n        }\n    }\n    return res;\n}\n\ninline void calc(li now, li from) {\n    li cn = sz(edge[now]);\n    if (from >= 0) {\n        cn--;\n    }\n    li i = 0;\n    vector<vector<li>> dpp1(1);\n    vector<vector<li>> dpp2(1);\n    dpp1[0].pb(INF);\n    dpp1[0].pb(a[now] > 0 ? a[now] : INF);\n    dpp2[0].pb(INF);\n    dpp2[0].pb(a[now]);\n    for (auto && child : edge[now]) {\n        if (child == from) {\n            continue;\n        }\n        calc(child, now);\n        dpp1.pb(merge1(dpp1.back(), dp1[child], dp2[child]));\n        dpp2.pb(merge2(dpp2.back(), dp1[child], dp2[child]));\n\n        i++;\n    }\n    dp1[now] = dpp1.back();\n    dp2[now] = dpp2.back();\n\n    //cout << \"-------------------- \" << now << endl;\n    //dumpi(dp1[now]);\n    //dumpi(dp2[now]);\n}\n\nint main() {\n    cin >> n;\n    rin{\n        cin >> a[i];\n    }\n    rep(i, n - 1) {\n        li u, v;\n        cin >> u >> v;\n        u--;\n        v--;\n        edge[u].pb(v);\n        edge[v].pb(u);\n    }\n\n    calc(0, -1);\n    li res = INF;\n    rep(i, sz(dp1[0])) {\n        if (dp1[0][i] != INF) {\n            res = min(res, i - 1);\n        }\n        if (dp2[0][i] < 0) {\n            res = min(res, i - 1);\n        }\n    }\n    cout << res << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <map>\n#include <set>\n#include <vector>\n#include <deque>\n#include <queue>\n\n#define pb push_back\n#define mp make_pair\n#define x first\n#define y second\n#define FOR(i, a, b) for(int i=a, loop=b; i<=loop; ++i)\n#define REV(i, a, b) for(int i=a, loop=b; i>=loop; --i)\n#define mize(a, b) a = min(a, b)\n#define maxi(a, b) a = max(a, b)\n#define shl(k) ((k) << 1)\nusing namespace std;\n\nconst int N = 5005;\nint n, a[N], g[N][N], e[N], G[N];\nint64_t f[N][N], F[N], INF = 1e15;\nvector<int> ke[N];\n\nvoid dfs(int u, int p)\n{\n    for(int v: ke[u]) if (v != p) {\n        dfs(v, u);\n        e[u] += e[v] + 1;\n    }\n\n    int m = 0;\n    f[u][0] = a[u];\n    g[u][0] = (a[u] > 0);\n\n    for(int v: ke[u]) if (v != p) {\n        FOR(i, 0, m+e[v]+1) F[i] = INF, G[i] = 0;\n\n        FOR(i, 0, m) FOR(j, 0, e[v]) {\n            mize(F[i+j], f[u][i] + f[v][j]);\n            if (f[v][j] < 0 || g[v][j]) mize(F[i+j+1], f[u][i]);\n            if (g[u][i]) {\n                if (g[v][j]) G[i+j] = 1;\n                if (f[v][j] < 0) G[i+j+1] = 1;\n            }\n        }\n\n        m = m + e[v] + 1;\n        FOR(i, 0, m) f[u][i] = F[i], g[u][i] = G[i];\n    }\n}\nint main()\n{\n    ios::sync_with_stdio(); cin.tie(0);\n\n    cin >> n;\n    FOR(i, 1, n) cin >> a[i];\n    FOR(i, 1, n-1) {\n        int u, v; cin >> u >> v;\n        ke[u].pb(v); ke[v].pb(u);\n    }\n\n    dfs(1, 0);\n    FOR(i, 0, n-1) if (f[1][i] < 0 || g[1][i]) {\n        cout << i; return 0;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FAST ios_base::sync_with_stdio(false); cin.tie(0);\n#define pb push_back\n#define eb emplace_back\n#define ins insert\n#define f first\n#define s second\n#define cbr cerr << \"hi\\n\"\n#define mmst(x, v) memset((x), v, sizeof ((x)))\n#define siz(x) ll(x.size())\n#define all(x) (x).begin(), (x).end()\n#define lbd(x,y) (lower_bound(all(x),y)-x.begin())\n#define ubd(x,y) (upper_bound(all(x),y)-x.begin())\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());    //can be used by calling rng() or shuffle(A, A+n, rng)\ninline long long rand(long long x, long long y) { return (rng() % (y+1-x)) + x; } //inclusivesss\nstring inline to_string(char c) {string s(1,c);return s;} template<typename T> inline T gcd(T a,T b){ return a==0?llabs(b):gcd(b%a,a); }\n\ntypedef long long ll; \ntypedef long double ld;\n#define FOR(i,s,e) for(ll i=s;i<=ll(e);++i)\n#define DEC(i,s,e) for(ll i=s;i>=ll(e);--i)\ntypedef pair<ll,ll>pi; typedef pair<ll,pi>spi; typedef pair<pi,pi>dpi;\n\n#define LLINF ((long long)1e18)\n#define INF int(1e9+1e6)\n#define MAXN (5006)\nll n,A[MAXN],dp[MAXN][MAXN],sz[MAXN];// if 0 then max, 1 then min\nbitset<MAXN> dp2[MAXN];\nvector<int>v[MAXN];\nvoid dfs(ll x,ll p){\n\tsz[x]=1;\n\tdp[x][0]=A[x];\n\tfor(auto i:v[x]) if(i^p) dfs(i,x), sz[x]+=sz[i];\n\tFOR(k,1,sz[x]) dp[x][k]=LLINF;\n\tll cur = 1;\n\tif(A[x]>0)dp2[x][0]=1;\n\tfor(auto i:v[x]) if(i^p) {\n\t\tDEC(j,cur+sz[i],0){\n\t\t\tif(dp[x][j]<LLINF) dp[x][j] += dp[i][0];\n\t\t\tdp2[x][j] = dp2[x][j] & dp2[i][0];\n\t\t\tFOR(k,1ll,min(j,sz[i])){\n\t\t\t\tdp[x][j]=min(dp[x][j],dp[x][j-k]+dp[i][k]);\n\t\t\t\tif(dp2[i][k-1]) dp[x][j]=min(dp[x][j],dp[x][j-k]);\n\t\t\t\tdp2[x][j]=dp2[x][j]|(dp2[x][j-k]&dp2[i][k]);\n\t\t\t\tif(dp[i][k-1] < 0) dp2[x][j]=dp2[x][j]|dp2[x][j-k];\n\t\t\t}\n\t\t}\n\t\tcur += sz[i];\n\t}\n}\nint main(){\n\tFAST\n\tcin>>n;\n\tFOR(i,1,n)cin>>A[i];\n\tFOR(i,2,n){\n\t\tll a,b;cin>>a>>b;\n\t\tv[a].eb(b),v[b].eb(a);\n\t}\n\tdfs(1,1);\n\tll ans = n-1;\n\tFOR(k,0,n-1) if(dp[1][k] < 0) ans = min(ans, k);\n\tFOR(k,0,n-1) if(dp2[1][k]) ans = min(ans, k);\n\tcout<<ans<<'\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(a); (i)<(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(a)-1; (i)>=(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef pair<int, int> pii;\ntypedef complex<double> xy_t;\nconst lint mod = 1e9 + 7;\n\nconst int MAX = 5010;\nconst lint INF = mod * mod;\nint n;\nlint a[MAX];\nvector<int> G[MAX];\nlint dp[MAX][MAX][2], dp2[MAX][2];\nint ch_num[MAX];\n\nvoid dfs(int v, int prev){\n    for(int nv: G[v])if(nv != prev) dfs(nv, v);\n    int ch_tmp = 1;\n    dp[v][0][a[v] < 0] = a[v];\n    for(int nv: G[v])if(nv != prev){\n        rep(j, ch_tmp)rep(cj, ch_num[nv])rep(k, 2)rep(ck, 2){\n            dp2[j+cj][k|ck] = min(dp2[j+cj][k|ck], dp[v][j][k] + dp[nv][cj][ck]);\n            if((!ck && dp[nv][cj][ck] < INF) || dp[nv][cj][ck] < 0){\n                dp2[j+cj+1][k] = min(dp2[j+cj+1][k], dp[v][j][k]);\n            }\n        }\n        ch_tmp += ch_num[nv];\n        rep(j, ch_tmp)rep(k, 2){\n            dp[v][j][k] = dp2[j][k];\n            dp2[j][k] = INF;\n        }\n    }\n    ch_num[v] = ch_tmp;\n}\n\nint main(){\n    scanf(\"%d\", &n);\n    rep(i, n) scanf(\"%lld\", &a[i]);\n    rep(i, n-1){\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        G[--u].push_back(--v);\n        G[v].push_back(u);\n    }\n    rep(i, n)rep(k, 2){\n        rep(j, n) dp[i][j][k] = INF;\n        dp2[i][k] = INF;\n    }\n    dfs(0, -1);\n    int ans = n;\n    rep(i, n){\n        if(dp[0][i][0] < INF) ans = min(ans ,i);\n        if(dp[0][i][1] < 0) ans = min(ans, i);\n    }\n    printf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define _for(i,j,N) for(int i = (j);i < (N);i++)\n#define _rep(i,j,N) for(int i = (j);i <= (N);i++)\n#define ALL(x) x.begin(),x.end()\n#define pb push_back\n#define LL long long\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& v) {\n    _for(i,0,(int)(v.size()-1)) os << v[i] << \" \";\n    os << v[v.size()-1];\n    return os;\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& os,const set<T>& v){\n    for(typename set<T>::iterator it = v.begin();it != v.end();it++)\n    os << *it <<\" \";\n    return os;\n}\nconst int maxn = 5005;\nint N;\nLL A[maxn];\nvector<int> G[maxn];\nLL res = 0;\n\nstruct Cmp{\n    bool operator()(const int &a,const int &b)const{\n        return A[a] > A[b];\n    }\n};\n\nconst LL INF = 1e16;\nLL dp[maxn][maxn][2];\nLL aux[maxn][2];\nint child[maxn];\n\nvoid dfs(int u,int p){\n    for(int j : G[u]){\n        if(j == p) continue;\n        dfs(j,u);\n    }\n    if(A[u] > 0){\n        dp[u][0][0] = A[u];\n    }else dp[u][0][1] = A[u];\n\n    _for(i,0,maxn) _for(j,0,2) aux[i][j] = INF;\n    int sum = 1;\n    child[u] = 1;\n\n    for(int v: G[u]){\n        if(v == p) continue;\n        _for(i,0,sum){\n            _for(j,0,child[v]){\n                _for(k1,0,2) _for(k2,0,2){\n                    //if(v == 5) cout <<\"j:\"<<j << \"val:\"<<dp[5][j][0] <<endl;\n                    if(dp[v][j][k2] < 0 || (!k2 && dp[v][j][k2] < INF)){\n                        chmin(aux[j+i+1][k1],dp[u][i][k1]);\n                    }\n                    chmin(aux[i+j][k1|k2],dp[u][i][k1] + dp[v][j][k2]);\n\n                }\n            }\n        }\n        child[u] += child[v];\n        sum += child[v];\n\n        _for(i,0,maxn) _for(j,0,2){\n            dp[u][i][j] =aux[i][j];\n            aux[i][j] = INF;\n        }\n\n    }\n}\n\nint main()\n{\n    cin >> N;\n    _rep(i,1,N){\n        cin >> A[i];\n    }\n\n    _for(i,0,N-1){\n        int u,v;\n        cin >> u >> v;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n\n    _for(i,0,maxn) _for(j,0,maxn) _for(k,0,2) dp[i][j][k] = INF;\n    _for(i,0,maxn) _for(k,0,2) aux[i][k] = INF;\n\n    dfs(1,-1);\n    int ans = maxn;\n    _for(i,1,maxn){\n        if(dp[1][i][1] < 0) chmin(ans,i);\n        //cout << dp[1][i][1] << endl;\n    }\n    _for(i,1,maxn){\n        if(dp[1][i][0] < INF) chmin(ans,i);\n        //cout << child[i] <<endl;\n    }\n    //cout << dp[4][2][1] << endl;\n\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FAST ios_base::sync_with_stdio(false); cin.tie(0);\n#define pb push_back\n#define eb emplace_back\n#define ins insert\n#define f first\n#define s second\n#define cbr cerr << \"hi\\n\"\n#define mmst(x, v) memset((x), v, sizeof ((x)))\n#define siz(x) ll(x.size())\n#define all(x) (x).begin(), (x).end()\n#define lbd(x,y) (lower_bound(all(x),y)-x.begin())\n#define ubd(x,y) (upper_bound(all(x),y)-x.begin())\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());    //can be used by calling rng() or shuffle(A, A+n, rng)\ninline long long rand(long long x, long long y) { return (rng() % (y+1-x)) + x; } //inclusivesss\nstring inline to_string(char c) {string s(1,c);return s;} template<typename T> inline T gcd(T a,T b){ return a==0?llabs(b):gcd(b%a,a); }\n\ntypedef long long ll; \ntypedef long double ld;\n#define FOR(i,s,e) for(ll i=s;i<=ll(e);++i)\n#define DEC(i,s,e) for(ll i=s;i>=ll(e);--i)\ntypedef pair<ll,ll>pi; typedef pair<ll,pi>spi; typedef pair<pi,pi>dpi;\n\n#define LLINF ((long long)1e18)\n#define INF int(1e9+1e6)\n#define MAXN (5006)\nll n,A[MAXN],dp[MAXN][MAXN][2],sz[MAXN];// if 0 then max, 1 then min\nvector<int>v[MAXN];\nvoid dfs(ll x,ll p){\n\tsz[x]=1;\n\tdp[x][0][1]=A[x];\n\tfor(auto i:v[x]) if(i^p) dfs(i,x), sz[x]+=sz[i];\n\tll cur = 1;\n\tfor(auto i:v[x]) if(i^p) {\n\t\tcur += sz[i];\n\t\tDEC(j,cur,0){\n\t\t\tif(dp[x][j][1]<LLINF) dp[x][j][1] += dp[i][0][1];\n\t\t\tFOR(k,1,min(j,sz[i])){\n\t\t\t\tdp[x][j][1]=min(dp[x][j][1],dp[x][j-k][1]+dp[i][k][1]);\n\t\t\t\tif(dp[i][k-1][0]!=LLINF) dp[x][j][1]=min(dp[x][j][1],dp[x][j-k][1]);\n\t\t\t}\n\t\t}\n\t}\n\tif(A[x]>0){\n\t\tdp[x][0][0]=A[x];\n\t\tcur=1;\n\t\tfor(auto i:v[x]) if(i^p) {\n\t\t\tcur+=sz[i];\n\t\t\tDEC(j,cur,0){\n\t\t\t\tdp[x][j][0] += dp[i][0][0], dp[x][j][0]=min(dp[x][j][0],LLINF);\n\t\t\t\tFOR(k,1,min(j,sz[i])){\n\t\t\t\t\tdp[x][j][0]=min(dp[x][j][0],dp[x][j-k][0]+dp[i][k][0]);\n\t\t\t\t\tif(dp[i][k-1][1] < 0) dp[x][j][0]=min(dp[x][j][0],dp[x][j-k][0]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tFAST\n\tcin>>n;\n\tFOR(i,1,n)cin>>A[i];\n\tFOR(i,2,n){\n\t\tll a,b;cin>>a>>b;\n\t\tv[a].eb(b),v[b].eb(a);\n\t}\n\tFOR(i,0,MAXN-1)FOR(j,0,MAXN-1)FOR(b,0,1)dp[i][j][b]=LLINF;\n\tdfs(1,1);\n\tll ans = n-1;\n\tFOR(k,0,n-1) if(dp[1][k][1] < 0) ans = min(ans, k);\n\tFOR(k,0,n-1) if(dp[1][k][0] != LLINF) ans = min(ans, k);\n\tcout<<ans<<'\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing Int = long long;\ntemplate<class T> inline void chmin(T & x, T y) { x = min(x, y); }\n\nconst int N = 1<<11<<3;\nint n;\nint A[N];\nvector<int> adj[N];\n\nstruct Answer {\n\tint min_cost_allpositive;\n\tvector<Int> min_sum;\n};\n\nAnswer dfs(int x, int pare) {\n\tint min_cost_allpositive = (A[x] > 0) ? 0 : 1e9;\n\tvector<Int> min_sum (1, A[x]);\n\tfor (int y : adj[x]) if (y != pare) {\n\t\tAnswer sub = dfs(y, x);\n\t\tint min_cost_allpositive2 = 1e9;\n\t\tvector<Int> min_sum2 (min_sum.size() + sub.min_sum.size(), 1e18);\n\t\t// 1. cut\n\t\t{\n\t\t\tchmin(min_cost_allpositive2, min_cost_allpositive + 1 + sub.min_cost_allpositive);\n\t\t\tfor (int child = 0; child < (int) sub.min_sum.size(); child++)\n\t\t\t\tif (sub.min_sum[child] < 0)\n\t\t\t\t\tchmin(min_cost_allpositive2, min_cost_allpositive + 1 + child);\n\t\t\tfor (int at = 0; at < (int) min_sum.size(); at++)\n\t\t\t\tfor (int child = 0; child < (int) sub.min_sum.size(); child++)\n\t\t\t\t\tif (sub.min_sum[child] < 0)\n\t\t\t\t\t\tchmin(min_sum2[at + child + 1], min_sum[at]);\n\t\t\tif (sub.min_cost_allpositive != 1e9)\n\t\t\t\tfor (int at = 0; at < (int) min_sum.size(); at++)\n\t\t\t\t\tchmin(min_sum2[at + sub.min_cost_allpositive + 1], min_sum[at]);\n\t\t}\n\t\t// 2. do not cut\n\t\t{\n\t\t\tchmin(min_cost_allpositive2, min_cost_allpositive + sub.min_cost_allpositive);\n\t\t\tfor (int at = 0; at < (int) min_sum.size(); at++)\n\t\t\t\tfor (int child = 0; child < (int) sub.min_sum.size(); child++)\n\t\t\t\t\tchmin(min_sum2[at + child], min_sum[at] + sub.min_sum[child]);\n\t\t}\n\t\tmin_cost_allpositive = min_cost_allpositive2;\n\t\tmin_sum = min_sum2;\n\t}\n\treturn {min_cost_allpositive, min_sum};\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i=1; i<=n; i++) cin >> A[i];\n\tfor (int e=0; e<n-1; e++) {\n\t\tint x, y; cin >> x >> y;\n\t\tadj[x].push_back(y);\n\t\tadj[y].push_back(x);\n\t}\n\tAnswer the_answer = dfs(1, 1);\n\tint answer = the_answer.min_cost_allpositive;\n\tfor (size_t i = 0; i < the_answer.min_sum.size(); i++) {\n\t\tif (the_answer.min_sum[i] < 0) answer = min<int>(answer, i);\n\t}\n\tcout << answer << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_DEPRECATE\n#define _USE_MATH_DEFINES\n#include <iostream>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <memory.h>\n#include <set>\n#include <ctime>\n#include <map>\n#include <cstring>\n#include <iterator>\n#include <queue>\n#include <assert.h>\n#include <bitset>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <functional>\n\n//#pragma comment(linker, \"/STACK:512000000\")\n\nusing namespace std;\n\n#define pb emplace_back\n#define mp make_pair\n#define all(a) (a).begin(), (a).end()\n#define forn(i, n) for (int i = 0; i < (n); ++i)\n#define forab(i, a, b) for (int i = (a); i < (b); ++i)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int infi = 1e9 + 7;\nconst ll infl = (ll)1e18 + (ll)7;\n\nll ar[5010];\nll dp[5010][5010][2];\nll ndp[5010][2];\nvoid upd(ll& a, ll b) {\n    a = min(a, b);\n}\nvector<vector<int> > g;\nint dfs(int v, int p = -1) {\n    int sz = 1;\n    forn(i, 5010)\n        dp[v][i][0] = dp[v][i][1] = infl;\n    if (ar[v] > 0)\n        dp[v][0][0] = ar[v];\n    else\n        dp[v][0][1] = ar[v];\n    for (int to : g[v]) {\n        if (to == p)\n            continue;\n        int cur_sz = dfs(to, v);\n        forn(i, cur_sz + sz)\n            ndp[i][0] = ndp[i][1] = infl;\n        forn(i, cur_sz) {\n            int flag = 0;\n            if (dp[to][i][0] < infl / 2 || dp[to][i][1] < 0)\n                flag = 1;\n            ll a = dp[to][i][0];\n            ll b = min(dp[to][i][0], dp[to][i][1]);\n            forn(j, sz) {\n                upd(ndp[i + j][0], a + dp[v][j][0]);\n                upd(ndp[i + j][1], b + min(dp[v][j][0], dp[v][j][1]));\n                if (flag) {\n                    upd(ndp[i + j + 1][0], dp[v][j][0]);\n                    upd(ndp[i + j + 1][1], dp[v][j][1]);\n                }\n            }\n        }\n        sz += cur_sz;\n        forn(i, sz)\n            dp[v][i][0] = ndp[i][0], dp[v][i][1] = ndp[i][1];\n    }\n    return sz;\n}\n\nint32_t main() {\n    cin.sync_with_stdio(false);\n    cin.tie(0);\n    //srand(time(NULL));\n    //freopen(\"input.txt\", \"r\", stdin); freopen(\"output.txt\", \"w\", stdout);\n    //freopen(\"customs.in\", \"r\", stdin); freopen(\"customs.out\", \"w\", stdout);\n    int n;\n    cin >> n;\n    forn(i, n)\n        cin >> ar[i];\n    g.resize(n);\n    forn(i, n - 1) {\n        int u, v;\n        cin >> u >> v;\n        --u, --v;\n        g[u].pb(v);\n        g[v].pb(u);\n    }\n    dfs(0);\n    for (int i = 0; i < n; ++i) {\n        if (dp[0][i][0] < infl / 2 || dp[0][i][1] < 0) {\n            cout << i << '\\n';\n            return 0;\n        }\n    }\n    assert(0);\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, m, n) for(int(i) = (int)(m); i < (int)(n); ++i)\n#define rep2(i, m, n) for(int(i) = (int)(n)-1; i >= (int)(m); --i)\n#define REP(i, n) rep(i, 0, n)\n#define REP2(i, n) rep2(i, 0, n)\n#define all(hoge) (hoge).begin(), (hoge).end()\n#define en '\\n'\nusing ll = long long;\nusing ull = unsigned long long;\ntemplate <class T>\nusing vec = vector<T>;\ntemplate <class T>\nusing vvec = vector<vec<T>>;\ntypedef pair<ll, ll> P;\nconstexpr long long INF = 1LL << 60;\nconstexpr int INF_INT = 1 << 25;\nconstexpr long long MOD = (ll)1e9 + 7;\n//constexpr long long MOD = 998244353LL;\nusing ld = long double;\nstatic const ld pi = 3.141592653589793L;\ntypedef vector<ll> Array;\ntypedef vector<Array> Matrix;\n\ntemplate <class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate <class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nstruct Edge {\n    ll to, rev;\n    long double cap;\n    Edge(ll _to, long double _cap, ll _rev) {\n        to = _to;\n        cap = _cap;\n        rev = _rev;\n    }\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\nvoid add_edge(Graph &G, ll from, ll to, long double cap, bool revFlag,\n              long double revCap) {\n    G[from].push_back(Edge(to, cap, (ll)G[to].size()));\n    if(revFlag)\n        G[to].push_back(Edge(from, revCap, (ll)G[from].size() - 1));\n}\n\nvoid solve() {\n\n    ll n;\n    cin >> n;\n    vec<ll> a(n);\n    REP(i, n) { cin >> a[i]; }\n    Graph g(n);\n    REP(i, n - 1) {\n        ll u, v;\n        cin >> u >> v;\n        add_edge(g, --u, --v, 1, true, 1);\n    }\n\n    vec<vvec<ll>> dp(n); //i番目の頂点において、j回カットした場合の、kが1ならばコンピュータを含む場合の消費電力の大きさ\n\n    auto dfs = [&](auto &&self, int v, int p) -> void {\n        dp[v] = vvec<ll>(1, vec<ll>(2, INF));\n        dp[v][0][a[v] < 0] = a[v];\n\n        for(auto e : g[v]) {\n            if(e.to == p)\n                continue;\n            self(self, e.to, v);\n\n            vvec<ll> dp2(dp[v].size() + dp[e.to].size(), vec<ll>(2, INF));\n            REP(i, dp[v].size()) {\n                REP(j, dp[e.to].size()) {\n                    REP(k, 2) {\n                        REP(l, 2) {\n                            if(dp[v][i][k] == INF or dp[e.to][j][l] == INF)\n                                continue;\n                            chmin(dp2[i + j][k or l], dp[v][i][k] + dp[e.to][j][l]);\n                            if(!l or (l and dp[e.to][j][l] < 0)) {\n                                chmin(dp2[i + j + 1][k], dp[v][i][k]); //カットする\n                            }\n                        }\n                    }\n                }\n            }\n            dp[v] = dp2;\n        }\n    };\n    dfs(dfs, 0, -1);\n\n    REP(i, dp[0].size()) {\n        REP(j, 2) {\n            if(dp[0][i][j] == INF)\n                continue;\n            if(!j or dp[0][i][j] < 0) {\n                cout << i << en;\n                return;\n            }\n        }\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    solve();\n    /*\n    ll t;\n    cin >> t;\n    REP(i, t)\n    solve();\n    */\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint A[5050];\nvector<int> E[5050];\nll dp[5050][5050][2];\nint C[5050];\n\nvoid dfs(int cur,int pre) {\n\tC[cur]=1;\n\tif(A[cur]>0) {\n\t\tdp[cur][0][1]=A[cur];\n\t}\n\telse {\n\t\tdp[cur][0][0]=A[cur];\n\t}\n\t\n\tFORR(e,E[cur]) if(e!=pre) {\n\t\tdfs(e,cur);\n\t\tll to[5050][2];\n\t\t\n\t\tint x,y;\n\t\tFOR(x,5050) to[x][0]=to[x][1]=1LL<<60;\n\t\tfor(x=0;x<=C[cur];x++) {\n\t\t\tfor(y=0;y<=C[e];y++) {\n\t\t\t\t\n\t\t\t\tif(dp[e][y][0]<0 || dp[e][y][1]<1LL<<60) {\n\t\t\t\t\tto[x+y+1][0]=min(to[x+y+1][0],dp[cur][x][0]);\n\t\t\t\t\tto[x+y+1][1]=min(to[x+y+1][1],dp[cur][x][1]);\n\t\t\t\t}\n\t\t\t\tto[x+y][1]=min(to[x+y][1],dp[cur][x][1]+dp[e][y][1]);\n\t\t\t\tto[x+y][0]=min(to[x+y][0],dp[cur][x][0]+dp[e][y][1]);\n\t\t\t\tto[x+y][0]=min(to[x+y][0],dp[cur][x][1]+dp[e][y][0]);\n\t\t\t\tto[x+y][0]=min(to[x+y][0],dp[cur][x][0]+dp[e][y][0]);\n\t\t\t}\n\t\t}\n\t\tFOR(x,5050) {\n\t\t\tdp[cur][x][0]=to[x][0];\n\t\t\tdp[cur][x][1]=to[x][1];\n\t\t}\n\t\tC[cur]+=C[e];\n\t}\n\t\n\t\n\t\n}\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tll S=0;\n\tint mi=-1;\n\tFOR(i,N) {\n\t\tcin>>A[i];\n\t\tS+=A[i];\n\t\tif(A[i]<0) mi=i;\n\t}\n\tif(S<0 || mi==-1) return _P(\"0\\n\");\n\t\n\tFOR(x,5050) FOR(y,5050) dp[x][y][0]=dp[x][y][1]=1LL<<60;\n\t\n\tFOR(i,N-1) {\n\t\tcin>>x>>y;\n\t\tE[x-1].push_back(y-1);\n\t\tE[y-1].push_back(x-1);\n\t}\n\t\n\tdfs(0,-1);\n\tfor(i=0;i<=5050;i++) {\n\t\tif(dp[0][i][0]<0) return _P(\"%d\\n\",i);\n\t\tif(dp[0][i][1]<1LL<<60) return _P(\"%d\\n\",i);\n\t}\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int Maxn = 5005;\nconst ll Inf = 1000000000000000000ll;\n\nint n;\nint A[Maxn];\nvector <int> neigh[Maxn];\nll mn[Maxn][Maxn];\nbool pos[Maxn][Maxn];\nint cnt[Maxn];\n\nvoid Solve(int v, int p = 0)\n{\n    fill(mn[v], mn[v] + Maxn, Inf);\n    mn[v][0] = A[v]; pos[v][0] = A[v] > 0;\n    cnt[v] = 1;\n    for (int i = 0; i < neigh[v].size(); i++) {\n        int u = neigh[v][i];\n        if (u == p) continue;\n        Solve(u, v);\n        for (int j = cnt[v] - 1; j >= 0; j--) {\n            bool po = pos[v][j]; pos[v][j] = false;\n            ll my = mn[v][j]; mn[v][j] = Inf;\n            for (int k = 0; k < cnt[u]; k++) {\n                if (pos[u][k] || mn[u][k] < 0) {\n                    pos[v][j + k + 1] |= po;\n                    mn[v][j + k + 1] = min(mn[v][j + k + 1], my);\n                }\n                pos[v][j + k] |= (po & pos[u][k]);\n                mn[v][j + k] = min(mn[v][j + k], my + mn[u][k]);\n            }\n        }\n        cnt[v] += cnt[u];\n    }\n}\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++)\n        scanf(\"%d\", &A[i]);\n    for (int i = 0; i < n - 1; i++) {\n        int a, b; scanf(\"%d %d\", &a, &b);\n        neigh[a].push_back(b);\n        neigh[b].push_back(a);\n    }\n    Solve(1);\n    int res = 0;\n    while (!pos[1][res] && mn[1][res] >= 0) res++;\n    printf(\"%d\\n\", res);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0; i<(n); i++)\nusing ll = long long;\nstruct dev{\n\tll v;\n\tbool b;\n\tvoid ch(dev d){v = min(v,d.v); b |= d.b;}\n\tdev mg(dev d){return {v + d.v, b && d.b};}\n\tbool ok(){return v < 0 || b;}\n};\nusing vd = vector<dev>;\nconst ll INF = 1e16;\nconst int MX = 5005;\nint n, a[MX], u, v;\nvector<int> G[MX];\nvd dfs(int t, int p){\n\tvd ret(1,{a[t], a[t] > 0});\n\tfor(int nx: G[t]) if(nx != p){\n\t\tvd ch = dfs(nx,t);\n\t\tint sc = (int)ch.size(), sr = (int)ret.size();\n\t\tvd tmp(sc+sr,{INF,false});\n\t\trep(i,sc) if(ch[i].ok()) rep(j,sr) tmp[i+j+1].ch(ret[j]);\n\t\trep(i,sc) rep(j,sr) tmp[i+j].ch(ch[i].mg(ret[j]));\n\t\tret = tmp;\n\t}\n\treturn ret;\n}\nint main(){\n\tscanf(\"%d\", &n);\n\trep(i,n) scanf(\"%d\", a+i);\n\trep(i,n-1){\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tu--; v--;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tvd res = dfs(0,0);\n\trep(i,res.size()) if(res[i].ok()) return 0*printf(\"%d\\n\", i);\n}"
  },
  {
    "language": "C++",
    "code": "#pragma region kyopro_template\n#include <bits/stdc++.h>\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define each(x, v) for (auto &x : v)\n#define all(v) (v).begin(), (v).end()\n#define sz(v) ((int)(v).size())\n#define mem(a, val) memset(a, val, sizeof(a))\n#define ini(...)   \\\n  int __VA_ARGS__; \\\n  in(__VA_ARGS__)\n#define inl(...)         \\\n  long long __VA_ARGS__; \\\n  in(__VA_ARGS__)\n#define ins(...)      \\\n  string __VA_ARGS__; \\\n  in(__VA_ARGS__)\n#define inc(...)    \\\n  char __VA_ARGS__; \\\n  in(__VA_ARGS__)\n#define in2(s, t)                           \\\n  for (int i = 0; i < (int)s.size(); i++) { \\\n    in(s[i], t[i]);                         \\\n  }\n#define in3(s, t, u)                        \\\n  for (int i = 0; i < (int)s.size(); i++) { \\\n    in(s[i], t[i], u[i]);                   \\\n  }\n#define in4(s, t, u, v)                     \\\n  for (int i = 0; i < (int)s.size(); i++) { \\\n    in(s[i], t[i], u[i], v[i]);             \\\n  }\n#define rep(i, N) for (long long i = 0; i < (long long)(N); i++)\n#define repr(i, N) for (long long i = (long long)(N)-1; i >= 0; i--)\n#define rep1(i, N) for (long long i = 1; i <= (long long)(N); i++)\n#define repr1(i, N) for (long long i = (N); (long long)(i) > 0; i--)\nusing namespace std;\nvoid solve();\nusing ll = long long;\ntemplate <class T = ll>\nusing V = vector<T>;\nusing vi = vector<int>;\nusing vl = vector<long long>;\nusing vvi = vector<vector<int>>;\nusing vd = V<double>;\nusing vs = V<string>;\nusing vvl = vector<vector<long long>>;\nusing P = pair<long long, long long>;\nusing vp = vector<P>;\nusing pii = pair<int, int>;\nusing vpi = vector<pair<int, int>>;\nconstexpr int inf = 1001001001;\nconstexpr long long infLL = (1LL << 61) - 1;\ntemplate <typename T, typename U>\ninline bool amin(T &x, U y) {\n  return (y < x) ? (x = y, true) : false;\n}\ntemplate <typename T, typename U>\ninline bool amax(T &x, U y) {\n  return (x < y) ? (x = y, true) : false;\n}\ntemplate <typename T, typename U>\nll ceil(T a, U b) {\n  return (a + b - 1) / b;\n}\nconstexpr ll TEN(int n) {\n  ll ret = 1, x = 10;\n  while (n) {\n    if (n & 1) ret *= x;\n    x *= x;\n    n >>= 1;\n  }\n  return ret;\n}\n\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, const pair<T, U> &p) {\n  os << p.first << \" \" << p.second;\n  return os;\n}\ntemplate <typename T, typename U>\nistream &operator>>(istream &is, pair<T, U> &p) {\n  is >> p.first >> p.second;\n  return is;\n}\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n  int s = (int)v.size();\n  for (int i = 0; i < s; i++) os << (i ? \" \" : \"\") << v[i];\n  return os;\n}\ntemplate <typename T>\nistream &operator>>(istream &is, vector<T> &v) {\n  for (auto &x : v) is >> x;\n  return is;\n}\nvoid in() {}\ntemplate <typename T, class... U>\nvoid in(T &t, U &... u) {\n  cin >> t;\n  in(u...);\n}\nvoid out() { cout << \"\\n\"; }\ntemplate <typename T, class... U>\nvoid out(const T &t, const U &... u) {\n  cout << t;\n  if (sizeof...(u)) cout << \" \";\n  out(u...);\n}\ntemplate <typename T>\nvoid die(T x) {\n  out(x);\n  exit(0);\n}\n\n#ifdef NyaanDebug\n#include \"NyaanDebug.h\"\n#define trc(...)                   \\\n  do {                             \\\n    cerr << #__VA_ARGS__ << \" = \"; \\\n    dbg_out(__VA_ARGS__);          \\\n  } while (0)\n#define trca(v, N)       \\\n  do {                   \\\n    cerr << #v << \" = \"; \\\n    array_out(v, N);     \\\n  } while (0)\n#define trcc(v)                             \\\n  do {                                      \\\n    cerr << #v << \" = {\";                   \\\n    each(x, v) { cerr << \" \" << x << \",\"; } \\\n    cerr << \"}\" << endl;                    \\\n  } while (0)\n#else\n#define trc(...)\n#define trca(...)\n#define trcc(...)\nint main() { solve(); }\n#endif\n\nstruct IoSetupNya {\n  IoSetupNya() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(15);\n    cerr << fixed << setprecision(7);\n  }\n} iosetupnya;\n\ninline int popcnt(unsigned long long a) { return __builtin_popcountll(a); }\ninline int lsb(unsigned long long a) { return __builtin_ctzll(a); }\ninline int msb(unsigned long long a) { return 63 - __builtin_clzll(a); }\ntemplate <typename T>\ninline int getbit(T a, int i) {\n  return (a >> i) & 1;\n}\ntemplate <typename T>\ninline void setbit(T &a, int i) {\n  a |= (1LL << i);\n}\ntemplate <typename T>\ninline void delbit(T &a, int i) {\n  a &= ~(1LL << i);\n}\ntemplate <typename T>\nint lb(const vector<T> &v, const T &a) {\n  return lower_bound(begin(v), end(v), a) - begin(v);\n}\ntemplate <typename T>\nint ub(const vector<T> &v, const T &a) {\n  return upper_bound(begin(v), end(v), a) - begin(v);\n}\ntemplate <typename T>\nvector<T> mkrui(const vector<T> &v) {\n  vector<T> ret(v.size() + 1);\n  for (int i = 0; i < int(v.size()); i++) ret[i + 1] = ret[i] + v[i];\n  return ret;\n};\n\ntemplate <typename T>\nvector<T> mkuni(const vector<T> &v) {\n  vector<T> ret(v);\n  sort(ret.begin(), ret.end());\n  ret.erase(unique(ret.begin(), ret.end()), ret.end());\n  return ret;\n}\n\ntemplate <typename F>\nvector<int> mkord(int N, F f) {\n  vector<int> ord(N);\n  iota(begin(ord), end(ord), 0);\n  sort(begin(ord), end(ord), f);\n  return ord;\n}\n\n#pragma endregion\n\nconstexpr long long MOD = /** 1000000007;  //*/ 998244353;\n\ntemplate <typename T>\nstruct edge {\n  int src, to;\n  T cost;\n\n  edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n  edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n  edge &operator=(const int &x) {\n    to = x;\n    return *this;\n  }\n\n  operator int() const { return to; }\n};\ntemplate <typename T>\nusing Edges = vector<edge<T> >;\ntemplate <typename T>\nusing WeightedGraph = vector<Edges<T> >;\nusing UnweightedGraph = vector<vector<int> >;\n\n// Input of (Unweighted) Graph\nUnweightedGraph graph(int N, int M = -1, bool is_directed = false,\n                      bool is_1origin = true) {\n  UnweightedGraph g(N);\n  if (M == -1) M = N - 1;\n  for (int _ = 0; _ < M; _++) {\n    int x, y;\n    cin >> x >> y;\n    if (is_1origin) x--, y--;\n    g[x].pb(y);\n    if (!is_directed) g[y].pb(x);\n  }\n  return g;\n}\n\n// Input of Weighted Graph\ntemplate <typename T>\nWeightedGraph<T> wgraph(int N, int M = -1, bool is_directed = false,\n                        bool is_1origin = true) {\n  WeightedGraph<T> g(N);\n  if (M == -1) M = N - 1;\n  for (int _ = 0; _ < M; _++) {\n    int x, y;\n    cin >> x >> y;\n    T c;\n    cin >> c;\n    if (is_1origin) x--, y--;\n    g[x].eb(x, y, c);\n    if (!is_directed) g[y].eb(y, x, c);\n  }\n  return g;\n}\n\n// Depth of Rooted Tree\n// unvisited nodes : d = -1\nvector<int> Depth(UnweightedGraph &g, int start = 0) {\n  vector<int> d(g.size(), -1);\n  auto dfs = [&](auto rec, int cur, int par = -1) -> void {\n    d[cur] = par == -1 ? 0 : d[par] + 1;\n    each(dst, g[cur]) {\n      if (dst == par) continue;\n      rec(rec, dst, cur);\n    }\n  };\n  dfs(dfs, start);\n  return d;\n}\n\n// Diameter of Tree\npair<int, int> Diameter(UnweightedGraph &g, int start = 0) {\n  auto d = Depth(g, start);\n  int u = max_element(begin(d), end(d)) - begin(d);\n  d = Depth(g, u);\n  int v = max_element(begin(d), end(d)) - begin(d);\n  return make_pair(u, v);\n}\n\nvoid solve(){\n  ini(N);\n  vl a(N); in(a);\n  auto g  = graph(N);\n\n\n  using p = pair<vl,vl>;\n  V<p> dp(N);\n  auto merge = [](p p1,p p2) -> p{\n    vl &s = p1.first, &t = p1.second;\n    vl &u = p2.first, &v = p2.second;\n\n    vl x(sz(s) + sz(u), infLL);\n    vl y(sz(s) + sz(u), infLL);\n\n    rep(i,sz(s)) rep(j,sz(u)){\n      if(s[i] != infLL && u[j] != infLL){      \n        amin(x[i + j], s[i] + u[j]);\n        amin(x[i + j + 1], s[i]);\n      }\n      if(s[i] != infLL && v[j] != infLL){      \n        amin(y[i + j], s[i] + v[j]);\n        if(v[j] < 0) amin(x[i + j + 1], s[i]);\n      }\n      if(t[i] != infLL && u[j] != infLL){\n        amin(y[i + j], t[i] + u[j]);\n        amin(y[i + j + 1], t[i]);\n      }\n      if(t[i] != infLL && v[j] != infLL){\n        amin(y[i + j], t[i] + v[j]);\n        if(v[j] < 0) amin(y[i + j + 1], t[i]);\n      }\n    }\n\n    return p{x, y};\n  };\n\n  auto dfs = [&](auto rec,int cur,int par = -1) -> void{\n    dp[cur] = p({infLL},{infLL});\n    if(a[cur] > 0) dp[cur].first[0] = a[cur];  \n    else dp[cur].second[0] = a[cur]; \n\n    each(dst , g[cur]){\n      if(dst == par) continue;\n      rec(rec , dst , cur);\n      dp[cur] = merge(dp[cur], dp[dst]);\n    }\n\n    trc(cur,dp[cur].first, dp[cur].second);\n  \n  };\n  dfs(dfs , 0);\n\n  ll ans = N - 1;\n  rep(i,sz(dp[0].first)){\n    if(dp[0].first[i] < 1e16) amin(ans,i);\n    if(dp[0].second[i] < 0) amin(ans,i);\n  }\n  out(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "// this code is not mine, I am just testing something\n#include <bits/stdc++.h>\n#include <type_traits>\nusing namespace std;\n \nusing ll=int64_t;\n#define int ll\n \n#define FOR(i,a,b) for(int i=int(a);i<int(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back\n#define ALL(x) x.begin(),x.end()\nauto& errStream=cerr;\n#ifdef LOCAL\n#define cerr (cerr<<\"-- line \"<<__LINE__<<\" -- \")\n#else\nclass CerrDummy{}cerrDummy;\ntemplate<class T>\nCerrDummy& operator<<(CerrDummy&cd,const T&){\n\treturn cd;\n}\nusing charTDummy=char;\nusing traitsDummy=char_traits<charTDummy>;\nCerrDummy& operator<<(CerrDummy&cd,basic_ostream<charTDummy,traitsDummy>&(basic_ostream<charTDummy,traitsDummy>&)){\n\treturn cd;\n}\n#define cerr cerrDummy\n#endif\n#define REACH cerr<<\"reached\"<<endl\n#define DMP(x) cerr<<#x<<\":\"<<x<<endl\n#define ZERO(x) memset(x,0,sizeof(x))\n#define ONE(x) memset(x,-1,sizeof(x))\n \nusing pi=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n \ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n \ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"{\";\n\tREP(i,(int)v.size()){\n\t\tif(i)os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n \nll read(){\n\tll i;\n\tscanf(\"%\"  SCNd64,&i);\n\treturn i;\n}\n \nvoid printSpace(){\n\tprintf(\" \");\n}\n \nvoid printEoln(){\n\tprintf(\"\\n\");\n}\n \nvoid print(ll x,int suc=1){\n\tprintf(\"%\" PRId64,x);\n\tif(suc==1)\n\t\tprintEoln();\n\tif(suc==2)\n\t\tprintSpace();\n}\n \nstring readString(){\n\tstatic char buf[3341000];\n\tscanf(\"%s\",buf);\n\treturn string(buf);\n}\n \nchar* readCharArray(){\n\tstatic char buf[3341000];\n\tstatic int bufUsed=0;\n\tchar* ret=buf+bufUsed;\n\tscanf(\"%s\",ret);\n\tbufUsed+=strlen(ret)+1;\n\treturn ret;\n}\n \ntemplate<class T,class U>\nvoid chmax(T& a,U b){\n\tif(a<b)\n\t\ta=b;\n}\n \ntemplate<class T,class U>\nvoid chmin(T& a,U b){\n\tif(b<a)\n\t\ta=b;\n}\n \ntemplate<class T>\nT Sq(const T& t){\n\treturn t*t;\n}\n \n#define CAPITAL\nvoid Yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n \nconst ll infLL=LLONG_MAX/3;\n \n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n \nconst int S=5010;\nint a[S],dp1[S][S],dp2[S];\nvi tr[S];\n \nint dfs(int v,int p){\n\tint s=1;\n\tif(a[v]>0)\n\t\tdp2[v]=0;\n\tdp1[v][0]=a[v];\n\tfor(auto ch:tr[v])\n\t\tif(ch!=p){\n\t\t\tint t=dfs(ch,v);\n\t\t\t{\n\t\t\t\tint w=dp2[ch];\n\t\t\t\tREP(i,t)\n\t\t\t\t\tif(dp1[ch][i]<0)\n\t\t\t\t\t\tchmin(w,i+1);\n\t\t\t\tdp2[v]+=w;\n\t\t\t\tchmin(dp2[v],inf);\n\t\t\t}\n\t\t\tREP(i,t)if(dp1[ch][i]<0)\n\t\t\t\tchmin(dp1[ch][i+1],0);\n\t\t\tif(dp2[ch]<t)\n\t\t\t\tchmin(dp1[ch][dp2[ch]+1],0);\n\t\t\tfor(int i=s;i>=0;i--){\n\t\t\t\tint w=dp1[v][i];\n\t\t\t\tdp1[v][i]=inf;\n\t\t\t\tREP(j,t+1){\n\t\t\t\t\tchmin(dp1[v][i+j],w+dp1[ch][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\ts+=t;\n\t\t}\n\treturn s;\n}\n \n \nsigned main(){\n\tint n=read();\n\tREP(i,n+1){\n\t\tREP(j,n+1)\n\t\t\tdp1[i][j]=inf;\n\t\tdp2[i]=inf;\n\t}\n\tREP(i,n)\n\t\ta[i]=read();\n\tREP(_,n-1){\n\t\tint u=read()-1,v=read()-1;\n\t\ttr[u].PB(v);\n\t\ttr[v].PB(u);\n\t}\n\tdfs(0,-1);\n\tint ans=dp2[0];\n\tREP(i,n)if(dp1[0][i]<0)\n\t\tchmin(ans,i);\n\tprint(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint A[5050];\nvector<int> E[5050];\nll dp[5060][5060][2];\nint C[5050];\n\nvoid dfs(int cur,int pre) {\n\tC[cur]=1;\n\tif(A[cur]>0) {\n\t\tdp[cur][0][1]=A[cur];\n\t}\n\telse {\n\t\tdp[cur][0][0]=A[cur];\n\t}\n\t\n\tFORR(e,E[cur]) if(e!=pre) {\n\t\tdfs(e,cur);\n\t\tll to[5050][2];\n\t\t\n\t\tint x,y;\n\t\tFOR(x,5050) to[x][0]=to[x][1]=1LL<<60;\n\t\tfor(x=0;x<=C[cur];x++) {\n\t\t\tfor(y=0;y<=C[e];y++) {\n\t\t\t\t\n\t\t\t\tif(dp[e][y][0]<0 || dp[e][y][1]<1LL<<60) {\n\t\t\t\t\tto[x+y+1][0]=min(to[x+y+1][0],dp[cur][x][0]);\n\t\t\t\t\tto[x+y+1][1]=min(to[x+y+1][1],dp[cur][x][1]);\n\t\t\t\t}\n\t\t\t\tto[x+y][1]=min(to[x+y][1],dp[cur][x][1]+dp[e][y][1]);\n\t\t\t\tto[x+y][0]=min(to[x+y][0],dp[cur][x][0]+dp[e][y][1]);\n\t\t\t\tto[x+y][0]=min(to[x+y][0],dp[cur][x][1]+dp[e][y][0]);\n\t\t\t\tto[x+y][0]=min(to[x+y][0],dp[cur][x][0]+dp[e][y][0]);\n\t\t\t}\n\t\t}\n\t\tFOR(x,5050) {\n\t\t\tdp[cur][x][0]=to[x][0];\n\t\t\tdp[cur][x][1]=to[x][1];\n\t\t}\n\t\tC[cur]+=C[e];\n\t}\n\t\n\t\n\t\n}\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tll S=0;\n\tint mi=-1;\n\tFOR(i,N) {\n\t\tcin>>A[i];\n\t\tS+=A[i];\n\t\tif(A[i]<0) mi=i;\n\t}\n\tif(S<0 || mi==-1) return _P(\"0\\n\");\n\t\n\tFOR(x,5050) FOR(y,5050) dp[x][y][0]=dp[x][y][1]=1LL<<60;\n\t\n\tFOR(i,N-1) {\n\t\tcin>>x>>y;\n\t\tE[x-1].push_back(y-1);\n\t\tE[y-1].push_back(x-1);\n\t}\n\t\n\tdfs(0,-1);\n\tfor(i=0;i<=5050;i++) {\n\t\tif(dp[0][i][0]<0) return _P(\"%d\\n\",i);\n\t\tif(dp[0][i][1]<1LL<<60) return _P(\"%d\\n\",i);\n\t}\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define MT make_tuple\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\n\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class T>\nistream& operator>>(istream& is, vector<T>& xs){\n  for(auto& x: xs)\n\tis >> x;\n  return is;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& xs){\n  for(unsigned int i=0;i<xs.size();++i)\n\tos << (i?\" \":\"\") << xs[i];\n  return os;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\nvoid debug(istringstream&){}\ntemplate <char sep=',', class Head, class... Tail>\nvoid debug(istringstream& iss, Head&& head, Tail&&... tail)\n{\n  string name;\n  getline(iss, name, ',');\n  cerr << sep << name << \"=\" << head;\n  debug(iss, forward<Tail>(tail)...);\n}\n#define DEBUG(...) \\\n  do{ \\\n    istringstream ss(#__VA_ARGS__); \\\n    debug<' '>(ss, __VA_ARGS__); \\\n    cerr<<endl; \\\n  }while(0)\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\nconst LL INF = 1e15;\n\nLL dp[5010][5010][2];\nLL nxts[5010][5010][2];\nint sz[5010];\n\nvoid dfs(const VVI& G, int u, int p, VL& xs){\n  sz[u] = 1;\n\n  auto crt = dp[u];\n  auto nxt = nxts[u];\n\n  fill((LL*)crt, (LL*)crt+5010*2, INF);\n  fill((LL*)nxt, (LL*)nxt+5010*2, INF);\n  int ub = 1;\n  if(xs[u] > 0) crt[0][0] = xs[u];\n  crt[0][1] = xs[u];\n\n  for(int v: G[u]){\n    if(v == p) continue;\n\n    dfs(G, v, u, xs);\n    sz[u] += sz[v];\n    REP(i,ub+1) REP(j,2) nxt[i][j] = INF;\n    for(int k=0;k<=ub;++k){\n      for(int l=0;l<=sz[v];++l){\n        if(xs[u] > 0 && crt[k][0] < INF){\n          if(dp[v][l][1] < 0 || dp[v][l][0] < INF){\n            mini(nxt[k+l+1][0], crt[k][0]);\n            mini(nxt[k+l+1][1], crt[k][0]);\n          }\n          if(dp[v][l][0] < INF){\n            mini(nxt[k+l][0], crt[k][0] + dp[v][l][0]);\n            mini(nxt[k+l][1], crt[k][0] + dp[v][l][0]);\n          }\n        }\n\n        if(crt[k][1] < INF){\n          if(dp[v][l][1] < INF)\n            mini(nxt[k+l][1], crt[k][1] + dp[v][l][1]);\n          if(dp[v][l][1] < 0 || dp[v][l][0] < INF)\n            mini(nxt[k+l+1][1], crt[k][1]);\n        }\n      }\n    }\n    ub += sz[v];\n    swap(crt, nxt);\n  }\n\n  REP(k,ub+1) REP(j,2){\n    dp[u][k][j] = crt[k][j];\n    //DEBUG(u,k,j,dp[u][k][j]);\n  }\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N;\n  cin >> N;\n  VL xs(N);\n  cin >> xs;\n\n  VVI G(N);\n\n  REP(i,N-1){\n    int u, v;\n    cin >> u >> v;\n    --u;\n    --v;\n    G[u].PB(v);\n    G[v].PB(u);\n  }\n\n  fill((LL*)dp, (LL*)dp+5010*5010*2, INF);\n  dfs(G, 0, -1, xs);\n\n  int ans = N;\n  for(int i=0;i<N;++i){\n    if(dp[0][i][0] < INF || dp[0][i][1] < 0){\n      ans = i;\n      break;\n    }\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize (\"-O3\")\n#include <bits/stdc++.h>\nusing namespace std;\n//衝突対策\n#define ws wszzzz\n#define int long long\n\n//@formatter:off\ntemplate<class A, class B, class C>struct T2 {A f;B s;C t;T2() { f = 0, s = 0, t = 0; }T2(A f, B s, C t) : f(f), s(s), t(t) {}bool operator<(const T2 &r) const {        return f != r.f ? f < r.f : s != r.s ? s < r.s : t < r.t;        /*return f != r.f ? f > r.f : s != r.s ?n s > r.s : t > r.t; 大きい順 */   }    bool operator>(const T2 &r) const {        return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t;        /*return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 小さい順 */   }    bool operator==(const T2 &r) const {        return f == r.f && s == r.s && t == r.t;    }    bool operator!=(const T2 &r) const {        return f != r.f || s != r.s || t != r.t;    }};\ntemplate<class A, class B, class C, class D> struct F2 {    A a;    B b;    C c;    D d;    F2() { a = 0, b = 0, c = 0, d = 0; }    F2(A a, B b, C c, D d) : a(a), b(b), c(c), d(d) {}    bool operator<(const F2 &r) const {        return a != r.a ? a < r.a : b != r.b ? b < r.b : c != r.c ? c < r.c : d < r.d;    /*    return a != r.a ? a > r.a : b != r.b ? b > r.b : c != r.c ? c > r.c : d > r.d;*/    }    bool operator>(const F2 &r) const {        return a != r.a ? a > r.a : b != r.b ? b > r.b : c != r.c ? c > r.c : d > r.d;/*        return a != r.a ? a < r.a : b != r.b ? b < r.b : c != r.c ? c < r.c : d < r.d;*/    }    bool operator==(const F2 &r) const {        return a == r.a && b == r.b && c == r.c && d == r.d;    }    bool operator!=(const F2 &r) const {        return a != r.a || b != r.b || c != r.c || d != r.d;    }    int operator[](int i) {        assert(i < 4);        return i == 0 ? a : i == 1 ? b : i == 2 ? c : d;    }};\ntypedef T2<int, int, int> T;\ntypedef F2<int, int, int, int> F;\nT mt(int a, int b, int c) {return T(a, b, c);}\n\n//@マクロ省略系 型,構造\n#define ll long long\n#define double long double\n#define ull unsigned long long\nusing dou = double;\nusing itn = int;\nusing str = string;\nusing bo= bool;\n#define au auto\nusing P = pair<int, int>;\nusing pd =pair<dou, dou>;\n#define fi first\n#define se second\n#define beg begin\n#define rbeg rbegin\n#define con continue\n#define bre break\n#define brk break\n#define is ==\n#define elf else if\n#define wh while\n\n#define maxq 1\n#define minq -1\n\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define MALLOC(type, len) (type*)malloc((len) * sizeof(type))\n#define lam(right) [&](int& p){return p right;}\n\n//マクロ省略系 コンテナ\nusing vi = vector<int>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\nusing vd = vector<double>;\nusing vc = vector<char>;\nusing vp = vector<P>;\nusing vt = vector<T>;\n\n#define V vector\n#define o_vvt(o1, o2, o3, o4, name, ...) name\n#define vvt0(t) V<V<t>>\n#define vvt1(t,a) V<V<t>>a\n#define vvt2(t,a, b) V<V<t>>a(b)\n#define vvt3(t,a, b, c) V<V<t>> a(b,V<t>(c))\n#define vvt4(t,a, b, c, d) V<V<t>> a(b,V<t>(c,d))\n\n#define vvi(...) o_vvt(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(int,__VA_ARGS__)\n#define vvb(...) o_vvt(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(bool,__VA_ARGS__)\n#define vvs(...) o_vvt(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(string,__VA_ARGS__)\n#define vvd(...) o_vvt(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(double,__VA_ARGS__)\n#define vvc(...) o_vvt(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(char,__VA_ARGS__)\n#define vvp(...) o_vvt(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(P,__VA_ARGS__)\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts> auto make_v(size_t a, Ts... ts) {return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));}\n#define vni(name, ...) auto name = make_v<int>(__VA_ARGS__)\n#define vnb(name, ...) auto name = make_v<bool>(__VA_ARGS__)\n#define vns(name, ...) auto name = make_v<string>(__VA_ARGS__)\n#define vnd(name, ...) auto name = make_v<double>(__VA_ARGS__)\n#define vnc(name, ...) auto name = make_v<char>(__VA_ARGS__)\n#define vnp(name, ...) auto name = make_v<P>(__VA_ARGS__)\n\n#define PQ priority_queue<int, vector<int>, greater<int> >\n#define tos to_string\nusing mapi = map<int, int>;\nusing mapp = map<P, int>;\nusing mapd = map<dou, int>;\nusing mapc = map<char, int>;\nusing maps = map<str, int>;\nusing seti = set<int>;\nusing setd = set<dou>;\nusing setc = set<char>;\nusing sets = set<str>;\nusing qui = queue<int>;\n#define bset bitset\n#define uset unordered_set\n#define mset multiset\n#define umap unordered_map\n#define umapi unordered_map<int,int>\n#define umapp unordered_map<P,int>\n#define mmap multimap\n\n\ntemplate<class T> struct pq {\n    priority_queue<T, vector<T>, greater<T> > q;//小さい順\n    T su = 0;\n    void clear() {q = priority_queue<T, vector<T>, greater<T> >();su = 0;}\n    void operator+=(T v) {su += v;q.push(v);}\n    T sum() {return su;}\n    T top() {return q.top();}\n    void pop() {su -= q.top();q.pop();}\n    T poll() {T ret = q.top();su -= ret;q.pop();return ret;}\n    int size() {return q.size();}\n};\ntemplate<class T> struct pqg {\n    priority_queue<T> q;//大きい順\n    T su = 0;\n    void clear() {q = priority_queue<T>();su = 0;}\n    void operator+=(T v) {su += v;q.push(v);}\n    T sum() {return su;}\n    T top() {return q.top();}\n    void pop() {su -= q.top();q.pop();}\n    T poll() {T ret = q.top();su -= ret;q.pop();return ret;}\n    int size() {return q.size();}\n};\n\n#define pqi pq<int>\n#define pqgi pqg<int>\n//マクロ 繰り返し\n#define o_rep(o1, o2, o3, o4, name, ...) name\n# define rep1(n) for(int rep1i = 0,rep1lim=n; rep1i < rep1lim ; rep1i++)\n# define rep2(i, n) for(int i = 0,rep2lim=n; i < rep2lim ; i++)\n#define rep3(i, m, n) for(int i = m,rep3lim=n; i < rep3lim ; i++)\n#define rep4(i, m, n, ad) for(int i = m,rep4lim=n; i < rep4lim ; i+= ad)\n#define rep(...) o_rep(__VA_ARGS__,rep4,rep3,rep2,rep1)(__VA_ARGS__)\n\n#define rer2(i, n) for(int i = n; i >= 0 ; i--)\n#define rer3(i, m, n) for(int i = m,rer3lim=n; i >= rer3lim ; i--)\n#define rer4(i, m, n, dec) for(int i = m,rer4lim=n; i >= rer4lim ; i-=dec)\n#define rer(...) o_rep(__VA_ARGS__,rer4,rer3,rer2,)(__VA_ARGS__)\n\n#define reps2(i, j, n) for(int i = 0,reps2lim=n; i < reps2lim ; i++)for(int j = 0; j < reps2lim ; j++)\n#define reps3(i, j, k, n) for(int i = 0,reps3lim=n; i < reps3lim ; i++)for(int j = 0; j < reps3lim ; j++)for(int k = 0; k < reps3lim ; k++)\n#define reps4(i, j, k, l, n) for(int i = 0,reps4lim=n; i < reps4lim ; i++)for(int j = 0; j < reps4lim ; j++)for(int k = 0; k < reps4lim ; k++)for(int l = 0; l < reps4lim ; l++)\n#define o_reps(o1, o2, o3, o4, o5, name, ...) name\n#define reps(...) o_reps(__VA_ARGS__,reps4,reps3,reps2,rep2,)(__VA_ARGS__)\n\n#define repss(i, j, k, a, b, c) for(int i = 0; i < a ; i++)for(int j = 0; j < b ; j++)for(int k = 0; k < c ; k++)\n\n#define fora(a, b) for(auto&& a : b)\n#define forg(gi, ve) for (int gi = 0,forglim = ve.size(), f, t, c; gi < forglim && (f = ve[gi].f, t = ve[gi].t, c = ve[gi].c, true); gi++)\n#define fort(gi, ve) for (int gi = 0, f, t, c; gi < ve.size() && (f = ve[gi].f, t = ve[gi].t, c = ve[gi].c, true); gi++)if(t!=p)\n\n#define form(st, l, r) for (auto &&it = st.lower_bound(l); it != st.end() && (*it).fi < r; it++)\n#define forit(st, l, r) for (auto &&it = st.lower_bound(l); it != st.end() && (*it) < r;)\n\n//マクロ 定数\n#define k3 1010\n#define k4 10101\n#define k5 101010\n#define k6 1010101\n#define k7 10101010\nconst int inf = (int) 1e9 + 100;\nconst ll linf = (ll) 1e18 + 100;\nconst char infc = '{';\nconst string infs = \"{\";\nconst double eps = 1e-9;\nconst double PI = 3.1415926535897932384626433832795029L;\nll ma = numeric_limits<ll>::min();\nll mi = numeric_limits<ll>::max();\nconst int y4[] = {-1, 1, 0, 0};\nconst int x4[] = {0, 0, -1, 1};\nconst int y8[] = {0, 1, 0, -1, -1, 1, 1, -1};\nconst int x8[] = {1, 0, -1, 0, 1, -1, 1, -1};\n\n//マクロ省略形 関数等\n#define arsz(a) (sizeof(a)/sizeof(a[0]))\n#define sz(a) ((int)(a).size())\n#define mp make_pair\n#define pb pop_back\n#define pf push_front\n#define eb emplace_back\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\nconstexpr bool ev(int a) { return !(a & 1); }\nconstexpr bool od(int a) { return (a & 1); }\n//@拡張系 こう出来るべきというもの\n\n//埋め込み 存在を意識せずに機能を増やされているもの\nnamespace std {template<> class hash<std::pair<signed, signed>> {public:size_t operator()(const std::pair<signed, signed> &x) const {return hash<ll>()(((ll) x.first << 32) + x.second);}};template<> class hash<std::pair<ll, ll>> {public:/*大きいllが渡されると、<<32でオーバーフローするがとりあえず問題ないと判断*/size_t operator()(const std::pair<ll, ll> &x) const {return hash<ll>()(((ll) x.first << 32) + x.second);}};}\n\n//stream まとめ\nistream &operator>>(istream &iss, P &a) {iss >> a.first >> a.second;return iss;}template<typename T> istream &operator>>(istream &iss, vector<T> &vec) {for (T &x: vec) iss >> x;return iss;}template<class T, class U> ostream &operator<<(ostream &os, pair<T, U> p) {os << p.fi << \" \" << p.se << endl;return os;}ostream &operator<<(ostream &os, T p) {    os << p.f << \" \" << p.s << \" \" << p.t;    return os;}ostream &operator<<(ostream &os, F p) {    os << p.a << \" \" << p.b << \" \" << p.c << \" \" << p.d;    return os;}template<typename T> ostream &operator<<(ostream &os, vector <T> &vec) {    for (int i = 0; i < vec.size(); i++)os << vec[i] << (i + 1 == vec.size() ? \"\" : \" \");    return os;}template<typename T> ostream &operator<<(ostream &os, vector <vector<T>> &vec) {    for (int i = 0; i < vec.size(); i++) {        for (int j = 0; j < vec[0].size(); j++) {            os << vec[i][j];        }        os << endl;    }    return os;}template<typename T, typename U> ostream &operator<<(ostream &os, map<T, U> &m) {    for (auto &&v:m) os << v;    return os;}\n\ntemplate<typename W, typename H> void resize(vector<W> &vec, const H head) { vec.resize(head); }template<typename W, typename H, typename ... T> void resize(vector<W> &vec, const H &head, const T ... tail) {vec.resize(head);for (auto &v: vec)resize(v, tail...);}\n//@formatter:on\ntemplate<typename T, typename F> bool all_of2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> bool all_of2(vector<T> &v, F f) {\n    rep(i, sz(v)) { if (!all_of2(v[i], f))return false; }\n    return true;\n}\ntemplate<typename T, typename F> bool any_of2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> bool any_of2(vector<T> &v, F f) {\n    rep(i, sz(v)) { if (any_of2(v[i], f))return true; }\n    return false;\n}\ntemplate<typename T, typename F> bool none_of2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> bool none_of2(vector<T> &v, F f) {\n    rep(i, sz(v)) { if (none_of2(v[i], f))return false; }\n    return true;\n}\ntemplate<typename T, typename F> bool find_if2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> int find_if2(vector<T> &v, F f) {\n    rep(i, sz(v)) { if (find_if2(v[i], f))return i; }\n    return sz(v);\n}\ntemplate<typename T, typename F> bool rfind_if2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> int rfind_if2(vector<T> &v, F f) {\n    rer(i, sz(v) - 1) { if (rfind_if2(v[i], f))return i; }\n    return -1;\n}\ntemplate<class T> bool contains(string &s, const T &v) { return s.find(v) != string::npos; }\ntemplate<typename T> bool contains(vector<T> &v, const T &val) { return std::find(v.begin(), v.end(), val) != v.end(); }\ntemplate<typename T, typename F> bool contains_if2(vector<T> &v, F f) { return find_if(v.begin(), v.end(), f) != v.end(); }\ntemplate<typename T, typename F> int count_if2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> int count_if2(vector<T> &vec, F f) {\n    int ret = 0;\n    fora(v, vec)ret += count_if2(v, f);\n    return ret;\n}\ntemplate<typename T, typename F> void for_each2(T &v, F f) { f(v); }\ntemplate<typename T, typename F> void for_each2(vector<T> &vec, F f) { fora(v, vec)for_each2(v, f); }\n//@formatter:off\ntemplate<typename W> int count_od(vector<W> &a) {return count_if2(a,[](int v){return v&1 ;});}\ntemplate<typename W> int count_ev(vector<W> &a) {return count_if2(a,[](int v){return !(v&1) ;});}\n#define all_of(a,right) all_of2(a,lam(right))\n#define any_of(a,right) any_of2(a,lam(right))\n#define none_of(a,right) none_of2(a,lam(right))\n#define find_if(a,right) find_if2(a,lam(right))\n#define rfind_if(a,right) rfind_if2(a,lam(right))\n#define contains_if(a,right) contains_if2(a,lam(right))\n#define count_if(a, right) count_if2(a,lam(right))\n#define for_each(a, right) do{fora(v,a){v right;}}while(0)\n\n\ntemplate<class T, class U> void replace(vector<T> &a, T key, U v) { replace(a.begin(), a.end(), key, v); }\nvoid replace(str &a, char key, str v) { if (v == \"\")a.erase(remove(all(a), key), a.end()); }\nvoid replace(str &a, char key, char v) { replace(all(a), key, v); }\n//keyと同じかどうか01で置き換える\ntemplate<class T, class U> void replace(vector<T> &a, U k) { rep(i, sz(a)) a[i] = a[i] == k; }\ntemplate<class T, class U> void replace(vector<vector<T >> &a, U k) { rep(i, sz(a))rep(j, sz(a[0])) a[i][j] = a[i][j] == k; }\ntemplate<class T> void replace(T &a) { replace(a, '#'); }\nvoid replace(str &a, str key, str v) {stringstream t;int kn = sz(key);std::string::size_type Pos(a.find(key));int l = 0;while (Pos != std::string::npos) {t << a.substr(l, Pos - l);t << v;l = Pos + kn;Pos = a.find(key, Pos + kn);}t << a.substr(l, sz(a) - l);a = t.str();}\ntemplate<class T> bool includes(vector<T> &a, vector<T> &b) {vi c = a;vi d = b;sort(all(c));sort(all(d));return includes(all(c), all(d));}\ntemplate<class T> bool is_permutation(vector<T> &a, vector<T> &b) { return is_permutation(all(a), all(b)); }\ntemplate<class T> bool next_permutation(vector<T> &a) { return next_permutation(all(a)); }\nvoid iota(vector<int> &ve, int s, int n) {ve.resize(n);iota(all(ve), s);}\nvi iota(int s, int len) {vi ve(len);iota(all(ve), s);return ve;}\ntemplate<class A, class B> auto vtop(vector<A> &a, vector<B> &b) {    assert(sz(a) == sz(b));    /*stringを0で初期化できない  */  vector<pair<A, B>> res;    rep(i, sz(a))res.eb(a[i], b[i]);return res;}\ntemplate<class A, class B> void ptov(vector<pair<A, B>> &p, vector<A> &a, vector<B> &b) {    a.resize(sz(p)), b.resize(sz(p));    rep(i, sz(p))a[i] = p[i].fi, b[i] = p[i].se;}\ntemplate<class A, class B, class C> auto vtot(vector<A> &a, vector<B> &b, vector<C> &c) {    assert(sz(a) == sz(b) && sz(b) == sz(c));    vector<T2<A, B, C>> res;    rep(i, sz(a))res.eb(a[i], b[i], c[i]);    return res;}\ntemplate<class A, class B, class C, class D> auto vtof(vector<A> &a, vector<B> &b, vector<C> &c, vector<D> &d) {    assert(sz(a) == sz(b) && sz(b) == sz(c) && sz(c) == sz(d));    vector<F2<A, B, C, D>> res;    rep(i, sz(a))res.eb(a[i], b[i], c[i], d[i]);    return res;}\nenum pcomparator { fisi, fisd, fdsi, fdsd, sifi, sifd, sdfi, sdfd };\nenum tcomparator {    fisiti, fisitd, fisdti, fisdtd, fdsiti, fdsitd, fdsdti, fdsdtd,    fitisi, fitisd, fitdsi, fitdsd, fdtisi, fdtisd, fdtdsi, fdtdsd,    sifiti, sifitd, sifdti, sifdtd, sdfiti, sdfitd, sdfdti, sdfdtd,    sitifi, sitifd, sitdfi, sitdfd, sdtifi, sdtifd, sdtdfi, sdfdfd,    tifisi, tifisd, tifdsi, tifdsd, tdfisi, tdfisd, tdfdsi, tdfdsd,    tisifi, tisifd, tisdfi, tisdfd, tdsifi, tdsifd, tdsdfi, tdsdfd};\ntemplate<class A, class B> void sort(vector<pair<A, B>> &a, pcomparator type) {    typedef pair<A, B> U;    if (type == fisi) sort(all(a), [&](U l, U r) { return l.fi != r.fi ? l.fi < r.fi : l.se < r.se; });    else if (type == fisd) sort(all(a), [&](U l, U r) { return l.fi != r.fi ? l.fi < r.fi : l.se > r.se; });    else if (type == fdsi) sort(all(a), [&](U l, U r) { return l.fi != r.fi ? l.fi > r.fi : l.se < r.se; });    else if (type == fdsd) sort(all(a), [&](U l, U r) { return l.fi != r.fi ? l.fi > r.fi : l.se > r.se; });    else if (type == sifi) sort(all(a), [&](U l, U r) { return l.se != r.se ? l.se < r.se : l.fi < r.fi; });    else if (type == sifd) sort(all(a), [&](U l, U r) { return l.se != r.se ? l.se < r.se : l.fi > r.fi; });    else if (type == sdfi) sort(all(a), [&](U l, U r) { return l.se != r.se ? l.se > r.se : l.fi < r.fi; });    else if (type == sdfd) sort(all(a), [&](U l, U r) { return l.se != r.se ? l.se > r.se : l.fi > r.fi; });};template<class U> void sort(vector<U> &a, pcomparator type) {    if (type == fisi) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s < r.s; });    else if (type == fisd) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s > r.s; });    else if (type == fdsi) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s < r.s; });    else if (type == fdsd) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s > r.s; });    else if (type == sifi) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f < r.f; });    else if (type == sifd) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f > r.f; });    else if (type == sdfi) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f < r.f; });    else if (type == sdfd) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f > r.f; });};template<class A, class B, class C, class D> void sort(vector<F2<A, B, C, D> > &a, pcomparator type) {    typedef F2<A, B, C, D> U;    if (type == fisi) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b < r.b; });    else if (type == fisd) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b > r.b; });    else if (type == fdsi) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b < r.b; });    else if (type == fdsd) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b > r.b; });    else if (type == sifi) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a < r.a; });    else if (type == sifd) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a > r.a; });    else if (type == sdfi) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a < r.a; });    else if (type == sdfd) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a > r.a; });};template<class U> void sort(vector<U> &a, tcomparator type) {    if (type == 0) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s < r.s : l.t < r.t; });    else if (type == 1) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s < r.s : l.t > r.t; });    else if (type == 2) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s > r.s : l.t < r.t; });    else if (type == 3) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s > r.s : l.t > r.t; });    else if (type == 4) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s < r.s : l.t < r.t; });    else if (type == 5) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s < r.s : l.t > r.t; });    else if (type == 6) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s > r.s : l.t < r.t; });    else if (type == 7) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s > r.s : l.t > r.t; });    else if (type == 8) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t < r.t : l.s < r.s; });    else if (type == 9) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t < r.t : l.s > r.s; });    else if (type == 10) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t > r.t : l.s < r.s; });    else if (type == 11) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t > r.t : l.s > r.s; });    else if (type == 12) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t < r.t : l.s < r.s; });    else if (type == 13) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t < r.t : l.s > r.s; });    else if (type == 14) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t > r.t : l.s < r.s; });    else if (type == 15) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t > r.t : l.s > r.s; });    else if (type == 16) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f < r.f : l.t < r.t; });    else if (type == 17) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f < r.f : l.t > r.t; });    else if (type == 18) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f > r.f : l.t < r.t; });    else if (type == 19) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f > r.f : l.t > r.t; });    else if (type == 20) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f < r.f : l.t < r.t; });    else if (type == 21) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f < r.f : l.t > r.t; });    else if (type == 22) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f > r.f : l.t < r.t; });    else if (type == 23) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f > r.f : l.t > r.t; });    else if (type == 24) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t < r.t : l.f < r.f; });    else if (type == 25) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t < r.t : l.f > r.f; });    else if (type == 26) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t > r.t : l.f < r.f; });    else if (type == 27) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t > r.t : l.f > r.f; });    else if (type == 28) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t < r.t : l.f < r.f; });    else if (type == 29) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t < r.t : l.f > r.f; });    else if (type == 30) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t > r.t : l.f < r.f; });    else if (type == 31) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t > r.t : l.f > r.f; });    else if (type == 32) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f < r.f : l.s < r.s; });    else if (type == 33) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f < r.f : l.s > r.s; });    else if (type == 34) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f > r.f : l.s < r.s; });    else if (type == 35) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f > r.f : l.s > r.s; });    else if (type == 36) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f < r.f : l.s < r.s; });    else if (type == 37) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f < r.f : l.s > r.s; });    else if (type == 38) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f > r.f : l.s < r.s; });    else if (type == 39) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f > r.f : l.s > r.s; });    else if (type == 40) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s < r.s : l.f < r.f; });    else if (type == 41) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s < r.s : l.f > r.f; });    else if (type == 42) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s > r.s : l.f < r.f; });    else if (type == 43) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s > r.s : l.f > r.f; });    else if (type == 44) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s < r.s : l.f < r.f; });    else if (type == 45) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s < r.s : l.f > r.f; });    else if (type == 46) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s > r.s : l.f < r.f; });    else if (type == 47) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s > r.s : l.f > r.f; });}template<class A, class B, class C, class D> void sort(vector<F2<A, B, C, D>> &a, tcomparator type) {    typedef F2<A, B, C, D> U;    if (type == 0) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b < r.b : l.c < r.c; });    else if (type == 1) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b < r.b : l.c > r.c; });    else if (type == 2) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b > r.b : l.c < r.c; });    else if (type == 3) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b > r.b : l.c > r.c; });    else if (type == 4) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b < r.b : l.c < r.c; });    else if (type == 5) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b < r.b : l.c > r.c; });    else if (type == 6) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b > r.b : l.c < r.c; });    else if (type == 7) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b > r.b : l.c > r.c; });    else if (type == 8) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c < r.c : l.b < r.b; });    else if (type == 9) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c < r.c : l.b > r.b; });    else if (type == 10) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c > r.c : l.b < r.b; });    else if (type == 11) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c > r.c : l.b > r.b; });    else if (type == 12) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c < r.c : l.b < r.b; });    else if (type == 13) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c < r.c : l.b > r.b; });    else if (type == 14) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c > r.c : l.b < r.b; });    else if (type == 15) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c > r.c : l.b > r.b; });    else if (type == 16) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a < r.a : l.c < r.c; });    else if (type == 17) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a < r.a : l.c > r.c; });    else if (type == 18) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a > r.a : l.c < r.c; });    else if (type == 19) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a > r.a : l.c > r.c; });    else if (type == 20) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a < r.a : l.c < r.c; });    else if (type == 21) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a < r.a : l.c > r.c; });    else if (type == 22) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a > r.a : l.c < r.c; });    else if (type == 23) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a > r.a : l.c > r.c; });    else if (type == 24) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c < r.c : l.a < r.a; });    else if (type == 25) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c < r.c : l.a > r.a; });    else if (type == 26) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c > r.c : l.a < r.a; });    else if (type == 27) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c > r.c : l.a > r.a; });    else if (type == 28) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c < r.c : l.a < r.a; });    else if (type == 29) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c < r.c : l.a > r.a; });    else if (type == 30) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c > r.c : l.a < r.a; });    else if (type == 31) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c > r.c : l.a > r.a; });    else if (type == 32) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a < r.a : l.b < r.b; });    else if (type == 33) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a < r.a : l.b > r.b; });    else if (type == 34) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a > r.a : l.b < r.b; });    else if (type == 35) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a > r.a : l.b > r.b; });    else if (type == 36) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a < r.a : l.b < r.b; });    else if (type == 37) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a < r.a : l.b > r.b; });    else if (type == 38) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a > r.a : l.b < r.b; });    else if (type == 39) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a > r.a : l.b > r.b; });    else if (type == 40) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b < r.b : l.a < r.a; });    else if (type == 41) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b < r.b : l.a > r.a; });    else if (type == 42) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b > r.b : l.a < r.a; });    else if (type == 43) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b > r.b : l.a > r.a; });    else if (type == 44) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b < r.b : l.a < r.a; });    else if (type == 45) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b < r.b : l.a > r.a; });    else if (type == 46) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b > r.b : l.a < r.a; });    else if (type == 47) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b > r.b : l.a > r.a; });}\n\nvoid sort(string &a) { sort(all(a)); }\ntemplate<class T> void sort(vector<T> &a) { sort(all(a)); }\n//P l, P rで f(P) の形で渡す\ntemplate<class U, class F> void sort(vector<U> &a, F f) { sort(all(a), [&](U l, U r) { return f(l) < f(r); }); };\ntemplate<class T> void rsort(vector<T> &a) { sort(all(a), greater<T>()); };\ntemplate<class U, class F> void rsort(vector<U> &a, F f) { sort(all(a), [&](U l, U r) { return f(l) > f(r); }); };\n//F = T<T>\n//例えばreturn p.fi + p.se;\ntemplate<class A, class B> void sortp(vector<A> &a, vector<B> &b) {    auto c = vtop(a, b);    sort(c);    rep(i, sz(a)) a[i] = c[i].fi, b[i] = c[i].se;}template<class A, class B, class F> void sortp(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    sort(c, f);    rep(i, sz(a)) a[i] = c[i].fi, b[i] = c[i].se;}template<class A, class B> void rsortp(vector<A> &a, vector<B> &b) {    auto c = vtop(a, b);    rsort(c);    rep(i, sz(a))a[i] = c[i].first, b[i] = c[i].second;}template<class A, class B, class F> void rsortp(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    rsort(c, f);    rep(i, sz(a))a[i] = c[i].first, b[i] = c[i].second;}template<class A, class B, class C> void sortt(vector<A> &a, vector<B> &b, vector<C> &c) {    auto d = vtot(a, b, c);    sort(d);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}template<class A, class B, class C, class F> void sortt(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    sort(d, f);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}template<class A, class B, class C> void rsortt(vector<A> &a, vector<B> &b, vector<C> &c) {    auto d = vtot(a, b, c);    rsort(d);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}template<class A, class B, class C, class F> void rsortt(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    rsort(d, f);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\n//sortindex 元のvectorはソートしない\ntemplate<class T> vi sorti(vector<T> &a) {    auto b = a;    vi ind = iota(0, sz(a));    sortp(b, ind);    return ind;}/*indexの分で型が変わるためpcomparatorが必要*/template<class T> vi sorti(vector<T> &a, pcomparator f) {    auto b = a;    vi ind = iota(0, sz(a));    sortp(b, ind, f);    return ind;}template<class T, class F> vi sorti(vector<T> &a, F f) {    vi ind = iota(0, sz(a));    sort(all(ind), [&](int x, int y) { return f(a[x]) < f(a[y]); });    return ind;}template<class T> vi rsorti(vector<T> &a) {    auto b = a;    vi ind = iota(0, sz(a));    rsortp(b, ind);    return ind;}template<class T, class F> vi rsorti(vector<T> &a, F f) {    vi ind = iota(0, sz(a));    sort(all(ind), [&](int x, int y) { return f(a[x]) > f(a[y]); });    return ind;}template<class A, class B, class F> vi sortpi(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    vi ind = iota(0, sz(a));    sort(all(ind), [&](int x, int y) { return f(c[x]) < f(c[y]); });    return ind;}template<class A, class B> vi sortpi(vector<A> &a, vector<B> &b, pcomparator f) {    vi ind = iota(0, sz(a));    auto c = a;    auto d = b;    sortt(c, d, ind, f);    return ind;}template<class A, class B> vi sortpi(vector<A> &a, vector<B> &b) { return sortpi(a, b, fisi); };template<class A, class B, class F> vi rsortpi(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    vi ind = iota(0, sz(a));    sort(all(ind), [&](int x, int y) { return f(c[x]) > f(c[y]); });    return ind;}template<class A, class B> vi rsortpi(vector<A> &a, vector<B> &b) { return sortpi(a, b, fdsd); };template<class A, class B, class C, class F> vi sortti(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    vi ind = iota(0, sz(a));    sort(all(ind), [&](int x, int y) { return f(d[x]) < f(d[y]); });    return ind;}template<class A, class B, class C> vi sortti(vector<A> &a, vector<B> &b, vector<C> &c, pcomparator f) {    vi ind = iota(0, sz(a));    auto d = vtof(a, b, c, ind);    sort(d, f);    rep(i, sz(a))ind[i] = d[i].d;    return ind;}template<class A, class B, class C> vi sortti(vector<A> &a, vector<B> &b, vector<C> &c) {    vi ind = iota(0, sz(a));    sort(all(ind), [&](int x, int y) {        if (a[x] == a[y]) {            if (b[x] == b[y])return c[x] < c[y];            else return b[x] < b[y];        } else {            return a[x] < a[y];        }    });    return ind;}template<class A, class B, class C, class F> vi rsortti(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    vi ind = iota(0, sz(a));    sort(all(ind), [&](int x, int y) { return f(d[x]) > f(d[y]); });    return ind;}template<class A, class B, class C> vi rsortti(vector<A> &a, vector<B> &b, vector<C> &c) {    vi ind = iota(0, sz(a));    sort(all(ind), [&](int x, int y) {        if (a[x] == a[y]) {            if (b[x] == b[y])return c[x] > c[y];            else return b[x] > b[y];        } else {            return a[x] > a[y];        }    });    return ind;}\ntemplate<class T> void sort2(vector<vector<T >> &a) { for (int i = 0, n = a.size(); i < n; i++)sort(a[i]); }\ntemplate<class T> void rsort2(vector<vector<T >> &a) { for (int i = 0, n = a.size(); i < n; i++)rsort(a[i]); }\n\ntemplate<typename A, size_t N, typename T> void fill(A (&a)[N], const T &v) { rep(i, N)a[i] = v; }template<typename A, size_t N, size_t O, typename T> void fill(A (&a)[N][O], const T &v) { rep(i, N)rep(j, O)a[i][j] = v; }template<typename A, size_t N, size_t O, size_t P, typename T> void fill(A (&a)[N][O][P], const T &v) { rep(i, N)rep(j, O)rep(k, P)a[i][j][k] = v; }template<typename A, size_t N, size_t O, size_t P, size_t Q, typename T> void fill(A (&a)[N][O][P][Q], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)a[i][j][k][l] = v; }template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, typename T> void fill(A (&a)[N][O][P][Q][R], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)a[i][j][k][l][m] = v; }template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S, typename T> void fill(A (&a)[N][O][P][Q][R][S], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)rep(n, S)a[i][j][k][l][m][n] = v; }\ntemplate<typename W, typename T>void fill(W &xx, const T vall) {    xx = vall;}template<typename W, typename T>void fill(vector<W> &vecc, const T vall) {    for (auto &&vx     : vecc)fill(vx, vall);}\ntemplate<class T,class U>void fill(vector<T> &a,U val,vi& ind) {fora(v,ind)a[v]=val;}\ntemplate<typename A, size_t N> A sum(A (&a)[N]) {    A res = 0;    rep(i, N)res += a[i];    return res;}template<typename A, size_t N, size_t O> A sum(A (&a)[N][O]) {    A res = 0;    rep(i, N)rep(j, O)res += a[i][j];    return res;}template<typename A, size_t N, size_t O, size_t P> A sum(A (&a)[N][O][P]) {    A res = 0;    rep(i, N)rep(j, O)rep(k, P)res += a[i][j][k];    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q> A sum(A (&a)[N][O][P][Q]) {    A res = 0;    rep(i, N)rep(j, O)rep(k, P)rep(l, Q)res += a[i][j][k][l];    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R> A sum(A (&a)[N][O][P][Q][R]) {    A res = 0;    rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)res += a[i][j][k][l][m];    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S> A sum(A (&a)[N][O][P][Q][R][S]) {    A res = 0;    rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)rep(n, S)res += a[i][j][k][l][m][n];    return res;}\n//@汎用便利関数 入力\nint in() {int ret;cin >> ret;return ret;}\nstring sin() {string ret;cin >> ret;return ret;}\ntemplate<class T>  void in(T &head) { cin >> head; }template<class T, class... U>  void in(T &head, U &... tail) {cin >> head;in(tail...);}\n\n#define o_din(o1, o2, o3, o4, name, ...) name\n#define din1(a) int a;cin>>a\n#define din2(a, b) int a,b;cin>>a>> b\n#define din3(a, b, c) int a,b,c;cin>>a>>b>>c\n#define din4(a, b, c, d) int a,b,c,d;cin>>a>>b>>c>>d\n#define din(...) o_din(__VA_ARGS__,din4,din3,din2 ,din1)(__VA_ARGS__)\n\n#define o_dind(o1, o2, o3, o4, name, ...) name\n#define din1d(a) din1(a);a--\n#define din2d(a, b) din2(a,b);a--,b--\n#define din3d(a, b, c) din3(a,b,c);a--,b--,c--\n#define din4d(a, b, c, d) din4(a,b,c,d);a--,b--,c--,d--\n#define dind(...) o_dind(__VA_ARGS__,din4d,din3d,din2d ,din1d)(__VA_ARGS__)\n\n\n#define o_out(o1, o2, o3, o4, name, ...) name\n#define out1(a) cout<<a<<endl\n#define out2(a, b) cout<<a<<\" \"<< b<<endl\n#define out3(a, b, c) cout<<a<<\" \"<<b<<\" \"<<c<<endl\n#define out4(a, b, c, d) cout<<a<<\" \"<<b<<\" \"<<c<<\" \"<<d<<endl\n#define out(...) o_out((__VA_ARGS__),out4,out3,out2,out1)((__VA_ARGS__))\n\ntemplate<class T> void outl(vector<T> &a) { fora(v, a)cout << v << endl; }\ntemplate<class T> void na(vector<T> &a, int n) {a.resize(n);rep(i, n)cin >> a[i];}\n#define dna(a, n) vi a(n); rep(dnai,n) cin >> a[dnai];\ntemplate<class T> void nao(vector<T> &a, int n) {    a.resize(n + 1);    a[0] = 0;    rep(i, n)cin >> a[i + 1];}\ntemplate<class T> void nad(vector<T> &a, int n) {    a.resize(n);    rep(i, n)cin >> a[i], a[i]--;}\ntemplate<class T, class U> void na2(vector<T> &a, vector<U> &b, int n) {    a.resize(n);    b.resize(n);    rep(i, n)cin >> a[i] >> b[i];}\n#define dna2(a, b, n) vi a(n),b(n);rep(dna2i, n)cin >> a[dna2i] >> b[dna2i];\ntemplate<class T, class U> void nao2(vector<T> &a, vector<U> &b, int n) {    a.resize(n + 1);    b.resize(n + 1);    a[0] = b[0] = 0;    rep(i, n)cin >> a[i + 1] >> b[i + 1];}\n#define dna2d(a, b, n) vi a(n),b(n);rep(dna2di, n){cin >> a[dna2di] >> b[dna2di];a[dna2di]--,b[dna2di]--;}\ntemplate<class T, class U> void na2d(vector<T> &a, vector<U> &b, int n) {    a.resize(n);    b.resize(n);    rep(i, n)cin >> a[i] >> b[i], a[i]--, b[i]--;}\ntemplate<class T, class U, class W> void na3(vector<T> &a, vector<U> &b, vector<W> &c, int n) {    a.resize(n);    b.resize(n);    c.resize(n);    rep(i, n)cin >> a[i] >> b[i] >> c[i];}\n#define dna3(a, b, c, n) vi a(n),b(n),c(n);   rep(dna3i, n)cin >> a[dna3i] >> b[dna3i] >> c[dna3i];\ntemplate<class T, class U, class W> void na3d(vector<T> &a, vector<U> &b, vector<W> &c, int n) {    a.resize(n);    b.resize(n);    c.resize(n);    rep(i, n)cin >> a[i] >> b[i] >> c[i], a[i]--, b[i]--, c[i]--;}\n#define dna3d(a, b, c, n) vi a(n),b(n),c(n);  rep(dna3di, n){cin >> a[dna3di] >> b[dna3di] >> c[dna3di];a[dna3di]--,b[dna3di]--,c[dna3di]--;}\n#define nt(a, h, w) resize(a,h,w);rep(nthi,h)rep(ntwi,w) cin >> a[nthi][ntwi];\n#define ntd(a, h, w) resize(a,h,w);rep(ntdhi,h)rep(ntdwi,w) cin >> a[ntdhi][ntdwi], a[ntdhi][ntdwi]--;\n#define ntp(a, h, w) resize(a,h+2,w+2);fill(a,'#');rep(ntphi,1,h+1)rep(ntpwi,1,w+1) cin >> a[ntphi][ntpwi];\n//デバッグ\n#define sp << \" \" <<\n\n#define debugName(VariableName) # VariableName\n\n#define deb1(x)  debugName(x)<<\" = \"<<x\n#define deb2(x, ...) deb1(x) <<\", \"<< deb1(__VA_ARGS__)\n#define deb3(x, ...) deb1(x) <<\", \"<< deb2(__VA_ARGS__)\n#define deb4(x, ...) deb1(x) <<\", \"<< deb3(__VA_ARGS__)\n#define deb5(x, ...) deb1(x) <<\", \"<< deb4(__VA_ARGS__)\n#define deb6(x, ...) deb1(x) <<\", \"<< deb5(__VA_ARGS__)\n#define deb7(x, ...) deb1(x) <<\", \"<< deb6(__VA_ARGS__)\n#define deb8(x, ...) deb1(x) <<\", \"<< deb7(__VA_ARGS__)\n#define deb9(x, ...) deb1(x) <<\", \"<< deb8(__VA_ARGS__)\n#define deb10(x, ...) deb1(x) <<\", \"<< deb9(__VA_ARGS__)\n\n#define o_ebug(o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, name, ...) name\n\n#ifdef _DEBUG\n#define deb(...)  cerr<< o_ebug(__VA_ARGS__,deb10,deb9,deb8,deb7,deb6,deb5,deb4,deb3,deb2,deb1)(__VA_ARGS__) <<endl\n#else\n#define deb(...) ;\n#endif\n\n#define debugline(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n'\n\n//よく使うクラス、構造体\nclass UnionFind {\npublic:\n    vi par, rank, sizes;\n    int n, trees;\n    UnionFind(int n) : n(n), trees(n) {\n        par.resize(n), rank.resize(n), sizes.resize(n);\n        rep(i, n)par[i] = i, sizes[i] = 1;\n    }\n    int root(int x) {\n        if (par[x] == x)return x;\n        else return par[x] = root(par[x]);\n    }\n    int find(int x) { return root(x); }\n    void unite(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y)return;\n        if (rank[x] < rank[y])swap(x, y);\n        trees--;\n        par[y] = x;\n        sizes[x] += sizes[y];\n        if (rank[x] == rank[y])rank[x]++;\n    }\n    bool same(int x, int y) { return root(x) == root(y); }\n    int size(int x) { return sizes[root(x)]; }\n    //順不同 umapなので\n    V<vi> sets() {\n        vvi(res,trees);\n        umap<int, vi> map;\n        rep(i, n) map[root(i)].push_back(i);\n        int i = 0;\n        for (auto &&p:map) {\n            int r = p.fi;\n            res[i].push_back(r);\n            for (auto &&v:p.se) {\n                if (r == v)continue;\n                res[i].push_back(v);\n            }\n            i++;\n        }\n        return res;\n    }\n};\n\nusing bint =__int128;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing u128 = __uint128_t;\n\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {    std::ostream::sentry s(dest);    if (s) {        __uint128_t tmp = value < 0 ? -value : value;        char buffer[128];        char *d = std::end(buffer);        do {            --d;            *d = \"0123456789\"[tmp % 10];            tmp /= 10;        } while (tmp != 0);        if (value < 0) {            --d;            *d = '-';        }        int len = std::end(buffer) - d;        if (dest.rdbuf()->sputn(d, len) != len) {            dest.setstate(std::ios_base::badbit);        }    }    return dest;}\n//__int128 toi128(string &s) {    __int128 ret = 0;    for (int i = 0; i < s.length(); i++)        if ('0' <= s[i] && s[i] <= '9')            ret = 10 * ret + s[i] - '0';    return ret;}\n\n\n//エラー\nvoid ole() {\n#ifdef _DEBUG\n    debugline(\"ole\");exit(0);\n#endif\n    string a = \"a\";rep(i, 30)a += a;rep(i, 1 << 17)cout << a << endl;cout << \"OLE 出力長制限超過\" << endl;exit(0);\n}\nvoid re() { assert(0 == 1);exit(0); }\nvoid tle() { while (inf)cout << inf << endl; }\n\n//便利関数\n\n//テスト用\nchar ranc() {return (char) ('a' + rand() % 26);}\nint rand(int min, int max) {    assert(min <= max);    if (min >= 0 && max >= 0) {        return rand() % (max + 1 - min) + min;    } else if (max < 0) {        return -rand(-max, -min);    } else {        if (rand() % 2) {            return rand(0, max);        } else {            return -rand(0, -min);        }    }}\nvi ranv(int n, int min, int max) {    vi v(n);    rep(i, n)v[i] = rand(min, max);    return v;}\nstr ransu(int n) {    str s;    rep(i, n)s += (char) rand('A', 'Z');    return s;}\nstr ransl(int n) {    str s;    rep(i, n)s += (char) rand('a', 'z');    return s;}\n//単調増加\nvi ranvinc(int n, int min, int max) {    vi v(n);    bool bad = 1;    while (bad) {        bad = 0;        v.resize(n);        rep(i, n) {            if (i && min > max - v[i - 1]) {                bad = 1;                break;            }            if (i)v[i] = v[i - 1] + rand(min, max - v[i - 1]);            else v[i] = rand(min, max);        }    }    return v;}\n//便利 汎用\nvoid ranvlr(int n, int min, int max, vi &l, vi &r) {    l.resize(n);    r.resize(n);    rep(i, n) {        l[i] = rand(min, max);        r[i] = l[i] + rand(0, max - l[i]);    }}\nvp run_length(vi &a) {    vp ret;    ret.eb(a[0], 1);    rep(i, 1, sz(a)) {        if (ret.back().fi == a[i]) {            ret.back().se++;        } else {            ret.eb(a[i], 1);        }    }    return ret;}\nvector<pair<char, int>> run_length(string &a) {    vector<pair<char, int>> ret;    ret.eb(a[0], 1);    rep(i, 1, sz(a)) {        if (ret.back().fi == a[i]) {            ret.back().se++;        } else {            ret.eb(a[i], 1);        }    }    return ret;}\ntemplate<class F>  int mgr(int ok, int ng, F f) {if (ok < ng)while (ng - ok > 1) { int mid = (ok + ng) / 2; if (f(mid))ok = mid; else ng = mid; } else while (ok - ng > 1) { int mid = (ok + ng) / 2; if (f(mid))ok = mid; else ng = mid; }return ok;}\n//strを整数として比較\nstring smax(str &a, str b) {    if (sz(a) < sz(b)) {        return b;    } else if (sz(a) > sz(b)) {        return a;    } else {        rep(i, sz(a)) {            if (a[i] < b[i]) {                return b;            } else if (a[i] > b[i])return a;        }    }    return a;}\n//strを整数として比較\nstring smin(str &a, str b) {    if (sz(a) < sz(b)) {        return a;    } else if (sz(a) > sz(b)) {        return b;    } else {        rep(i, sz(a)) {            if (a[i] < b[i]) {                return a;            } else if (a[i] > b[i])return b;        }    }    return a;}\ntemplate<typename W, typename T> int find(vector<W> &a,const T key) {rep(i, sz(a))if (a[i] == key)return i;return -1;}\ntemplate<typename W, typename T> P find(vector<vector<W >> &a,const T key) {rep(i, sz(a))rep(j, sz(a[0]))if (a[i][j] == key)return mp(i, j);return mp(-1, -1);}\ntemplate<typename W, typename U> T find(vector<vector<vector<W >>> &a,const U key) {rep(i, sz(a))rep(j, sz(a[0]))rep(k, sz(a[0][0]))if (a[i][j][k] == key)return mt(i, j, k);return mt(-1, -1, -1);}\n\n\ntemplate<typename W, typename T> int count2(W &a, const T k) { return a == k; }\ntemplate<typename W, typename T> int count2(vector<W> &a, const T k) {int ret = 0;fora(v, a)ret +=count(v, k);return ret;}\ntemplate<typename W, typename T> int count(vector<W> &a, const T k) {int ret = 0;fora(v, a)ret +=count2(v, k);return ret;}\nint count(str& a, str k) {int ret = 0, len = k.length();auto pos = a.find(k);while (pos != string::npos)pos = a.find(k, pos + len), ret++;return ret;}\nvi count(str& a){    vi cou(26);    char c='a';    if('A' <= a[0] && a[0]<='Z')c='A';    rep(i,sz(a))cou[a[i]-c]++;    return cou;}\n#define couif count_if\n//algorythm\n\n\ninline ll rev(ll a) {ll res = 0;while (a) {res *= 10;res += a % 10;a /= 10;}return res;}\ntemplate<class T> void rev(vector<T> &a) {reverse(all(a));}\ntemplate<class T> vector<T> revv(vector<T> &a) {vector<T> b = a;reverse(all(b));return b;}\nvoid inline rev(string &a) {reverse(all(a));}\nconstexpr int p10[] = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000, 10000000000ll, 100000000000ll, 1000000000000ll, 10000000000000ll, 100000000000000ll, 1000000000000000ll, 10000000000000000ll, 100000000000000000ll, 1000000000000000000ll};\n\nint get(int a, int keta) { return (a / (int) pow(10, keta)) % 10; }\nint keta(ll v) { if (v < p10[9]) { if (v < p10[4]) { if (v < p10[2]) { if (v < p10[1]) return 1; else return 2; } else { if (v < p10[3]) return 3; else return 4; }} else { if (v < p10[7]) { if (v < p10[5]) return 5; else if (v < p10[6])return 6; else return 7; } else { if (v < p10[8])return 8; else return 9; }}} else { if (v < p10[13]) { if (v < p10[11]) { if (v < p10[10]) return 10; else return 11; } else { if (v < p10[12]) return 12; else return 13; }} else { if (v < p10[15]) { if (v < p10[14]) return 14; else if (v < p10[15])return 15; else return 16; } else { if (v < p10[17])return 17; else return 18; }}}}\nint dsum(int v) {int ret = 0;for (; v; v /= 10)ret += v % 10;return ret;}\n\nstruct sint {\n    int v;\n    sint(int v) : v(v) {}\n    operator int() { return v; }\n    //下からi番目\n    int operator[](int i) { return (v / p10[i]) % 10; }\n    int back(int i) {        return operator[](i);    }\n    //上からi番目\n    int top(int i) {        int len = keta(v);        return operator[](len - 1 - i);    }\n    //先頭からi番目にセット\n    int settop(int i, int k) {        int len = keta(v);        return set(len - 1 - i, k);    }\n    int set(int i, int k) {        if (i < 0)return settop(abs(i) - 1, k);        return v += p10[i] * (k - (v / p10[i]) % 10);    }\n    int add(int i, int k = 1) {        return v += p10[i] * k;    }\n    int addtop(int i, int k = 1) {        return v += p10[keta(v) - i - 1] * k;    }\n    int dec(int i, int k = 1) {        return v -= p10[i] * k;    }\n    int dectop(int i, int k = 1) {        return v -= p10[keta(v) - i - 1] * k;    }\n#define op(t, o)template<class T>inline t operator o(T r){return v o r;}\n    op(int, +=);op(int, -=);op(int, *=);op(int, /=);op(int, %=);\n    op(int, +);op(int, -);op(int, *);op(int, /);op(int, %);\n    op(bool, ==);op(bool, !=);op(bool, <);op(bool, <=);op(bool, >);op(bool, >=);\n#undef op\n    template<class T> inline int operator<<=(T r) { return v *= p10[r]; }\n    template<class T> inline int operator<<(T r) { return v * p10[r]; }\n    template<class T> inline int operator>>=(T r) { return v /= p10[r]; }\n    template<class T> inline int operator>>(T r) { return v / p10[r]; }\n};\nint mask10(int v) { return p10[v] - 1; }\n//変換系\ntemplate<class T> auto keys(T a) {vector<decltype((a.begin())->fi)> res;for (auto &&k :a)res.push_back(k.fi);return res;}\ntemplate<class T> auto values(T a) {vector<decltype((a.begin())->se)> res;for (auto &&k :a)res.push_back(k.se);return res;}\ntemplate<class T, class U> inline bool chma(T &a, const U &b) {    if (a < b) {        a = b;        return true;    }    return false;}\ntemplate<class U> inline bool chma(const U &b) { return chma(ma, b); }\ntemplate<class T, class U> inline bool chmi(T &a, const U &b) {    if (b < a) {        a = b;        return true;    }    return false;}\ntemplate<class U> inline bool chmi(const U &b) { return chmi(mi, b); }\ntemplate<class T> inline T min(T a, signed b) { return a < b ? a : b; }\ntemplate<class T> inline T max(T a, signed b) { return a < b ? b : a; }\ntemplate<class T> inline T min(T a, T b, T c) { return a >= b ? b >= c ? c : b : a >= c ? c : a; }\ntemplate<class T> inline T max(T a, T b, T c) { return a <= b ? b <= c ? c : b : a <= c ? c : a; }\ntemplate<class T> inline T min(vector<T> a) { return *min_element(all(a)); }\ntemplate<class T> inline T mini(vector<T> a) { return min_element(all(a)) - a.begin(); }\ntemplate<class T> inline T min(vector<T> a, int n) { return *min_element(a.begin(), a.begin() + min(n, sz(a))); }\ntemplate<class T> inline T min(vector<T> a, int s, int n) { return *min_element(a.begin() + s, a.begin() + min(n, sz(a))); }\ntemplate<class T> inline T max(vector<T> a) { return *max_element(all(a)); }\ntemplate<class T> inline T maxi(vector<T> a) { return max_element(all(a)) - a.begin(); }\ntemplate<class T> inline T max(vector<T> a, int n) { return *max_element(a.begin(), a.begin() + min(n, sz(a))); }\ntemplate<class T> inline T max(vector<T> a, int s, int n) { return *max_element(a.begin() + s, a.begin() + min(n, sz(a))); }\ntemplate<typename A, size_t N> inline A max(A (&a)[N]) {    A res = a[0];    rep(i, N)res = max(res, a[i]);    return res;}template<typename A, size_t N, size_t O> inline A max(A (&a)[N][O]) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P> inline A max(A (&a)[N][O][P]) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q> inline A max(A (&a)[N][O][P][Q], const T &v) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R> inline A max(A (&a)[N][O][P][Q][R]) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S> inline A max(A (&a)[N][O][P][Q][R][S]) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}template<typename A, size_t N> inline A min(A (&a)[N]) {    A res = a[0];    rep(i, N)res = min(res, a[i]);    return res;}template<typename A, size_t N, size_t O> inline A min(A (&a)[N][O]) {    A res = min(a[0]);    rep(i, N)res = min(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P> inline A min(A (&a)[N][O][P]) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q> inline A min(A (&a)[N][O][P][Q], const T &v) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R> inline A min(A (&a)[N][O][P][Q][R]) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S> inline A min(A (&a)[N][O][P][Q][R][S]) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}\ntemplate<class T> T sum(vector<T> &v) {T ret = 0;rep(i, sz(v))ret += v[i];return ret;}\ntemplate<class T> T sum(vector<vector<T> > &v) {T ret = 0;rep(i, sz(v))ret += sum(v[i]);return ret;}\ntemplate<class T> T sum(vector<vector<vector<T> > > &v) {T ret = 0;rep(i, sz(v))ret += sum(v[i]);return ret;}\ntemplate<class T> T sum(vector<vector<vector<vector<T> > > > &v) {T ret = 0;rep(i, sz(v))ret += sum(v[i]);return ret;}\ntemplate<class T> T sum(vector<vector<vector<vector<vector<T> > > > > &v) {T ret = 0;rep(i, sz(v))ret += sum(v[i]);return ret;}\ntemplate<class T>  auto sum(priority_queue<T, vector<T>, greater<T> > &r) {auto q = r;T ret = 0;while (sz(q)) {ret += q.top();q.pop();}return ret;}\ntemplate<class T>  auto sum(priority_queue<T> &r) {    auto q = r;    T ret = 0;    while (sz(q)) {        ret += q.top();        q.pop();    }    return ret;}\ntemplate<class T, class U, class... W> inline auto sum(vector<T> &v, U head, W... tail) {    auto ret = sum(v[0], tail...);    rep(i, 1, min(sz(v), head))ret += sum(v[i], tail...);    return ret;}\nvoid clear(PQ &q) { q=PQ(); }\ntemplate<class T>  void clear(queue<T> &q) { while (q.size())q.pop(); }\ntemplate<class T>  T *negarr(int size) {    T *body = (T *) malloc((size * 2 + 1) * sizeof(T));    return body + size;}\ntemplate<class T>  T *negarr2(int h, int w) {    double **dummy1 = new double *[2 * h + 1];    double *dummy2 = new double[(2 * h + 1) * (2 * w + 1)];    dummy1[0] = dummy2 + w;    for (int i = 1; i <= 2 * h + 1; i++) {        dummy1[i] = dummy1[i - 1] + 2 * w + 1;    }    double **a = dummy1 + h;    return a;}\n//imoは0-indexed\n//ruiは1-indexed\ntemplate<class T> vector<T> imo(vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)ret[i + 1] += ret[i];    return ret;}\n//kと同じものの数\ntemplate<class T, class U>  vi imocou(vector<T> &a, U k) {    vector<T> ret = a;    rep(i, sz(ret) - 1)ret[i + 1] = ret[i] + (a[i] == k);    return    ret;}\ntemplate<class T>  vector<T> imox(vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)ret[i + 1] ^= ret[i];    return ret;}\n//漸化的に最小を持つ\ntemplate<class T>  vector<T> imi(vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)chmi(ret[i + 1], ret[i]);    return ret;}\ntemplate<class T> struct ruiC {    const vector<T> rui;    ruiC(vector<T> &ru) : rui(ru) {}    inline T operator()(int l, int r) {        assert(l <= r);        return rui[r] - rui[l];    }    inline T operator[](int i) {        return rui[i];    }};\ntemplate<class T> struct rruic {    const T *rrui;    rruic(T *ru) : rrui(ru) {}    inline T operator()(int l, int r) {        assert(l >= r);        return rrui[r] - rrui[l];    }    inline T operator[](int i) { return rrui[i]; }};\ntemplate<class T>  vector<T> ruiv(vector<T> &a) {    vector<T> ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] + a[i];    return ret;}\ntemplate<class T>  ruiC<T> ruic(vector<T> &a) {    vector<T> ret = ruiv(a);    return ruiC<T>(ret);}\n//kと同じものの数\ntemplate<class T, class U>  vi ruiv(T &a, U k) {    vi ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] + (a[i] == k);    return ret;}\ntemplate<class T, class U>  ruiC<int> ruic(T &a, U k) {    vi ret = ruiv(a, k);    return ruiC<int>(ret);}\n\n//xor\ntemplate<class T>  vector<T> ruix(vector<T> &a) {    vector<T> ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] ^ a[i];    return ret;}\ntemplate<class T>  vector<T> ruim(vector<T> &a) {    vector<T> res(a.size() + 1, 1);    rep(i, a.size())res[i + 1] = res[i] * a[i];    return res;}\n//漸化的に最小を1indexで持つ\ntemplate<class T>  vector<T> ruimi(vector<T> &a) {    int n = sz(a);    vector<T> ret(n + 1);    rep(i, 1, n) {        ret[i] = a[i - 1];        chmi(ret[i + 1], ret[i]);    }    return ret;}\n//template<class T> T *rrui(vector<T> &a) {\n//右から左にかけての半開区間 (-1 n-1]\ntemplate<class T> rruic<T> rrui(vector<T> &a) {    int len = a.size();    T *body = (T *) malloc((len + 1) * sizeof(T));    T *res = body + 1;    rer(i, len - 1)res[i - 1] = res[i] + a[i];    return rruic<T>(res);}\n//掛け算\ntemplate<class T> T *rruim(vector<T> &a) {    int len = a.size();    T *body = (T *) malloc((len + 1) * sizeof(T));    T *res = body + 1;    res[len - 1] = 1;    rer(i, len - 1)res[i - 1] = res[i] * a[i];    return res;}\ntemplate<class T, class U> void inc(T &a, U v = 1) { a += v; }\ntemplate<class T, class U> void inc(vector<T> &a, U v = 1) { for (auto &u:a)inc(u, v); }\ntemplate<class T, class U> void dec(T &a, U v = 1) { a -= v; }\ntemplate<class T, class U> void dec(vector<T> &a, U v = 1) { for (auto &u :a)dec(u, v); }\ntemplate<class U> void dec(string &a, U v = 1) { for (auto &u :a)dec(u, v); }\ntemplate<class T> void dec(vector<T> &a) { for (auto &u :a)dec(u, 1); }\ntemplate<class T, class U> void minu(T &a, U v = 1) { a -= v; }\ntemplate<class T, class U> void minu(vector<T> &a, U v = 1) { for (auto &u:a)dec(u, v); }\ntemplate<class T> void minu(vector<T> &a) { for (auto &u :a)dec(u, 1); }\ntemplate<class U> void minu(string &a, U v = 1) { for (auto &u :a)dec(u, v); }\nvoid minu(string &a) { for (auto &u :a)dec(u, 1); }\nbool inside(int h, int w, int H, int W) { return h >= 0 && w >= 0 && h < H && w < W; }\nbool inside(int l, int v, int r) { return l <= v && v < r; }\ntemplate<class T>bool inside(vector<T>& a,int i,int j=0){return inside(0,i,sz(a)) &&inside(0,j,sz(a));}\n#define ins inside\nll u(ll a) { return a < 0 ? 0 : a; }\ntemplate<class T> vector<T> u(const vector<T> &a) {vector<T> ret = a;fora(v, ret)v = u(v);return ret;}\n#define MIN(a) numeric_limits<a>::min()\n#define MAX(a) numeric_limits<a>::max()\nll goldd(ll left, ll right, function<ll(ll)> calc) {    double GRATIO = 1.6180339887498948482045868343656;    ll lm = left + (ll) ((right - left) / (GRATIO + 1.0));    ll rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));    ll fl = calc(lm);    ll fr = calc(rm);    while (right - left > 10) {        if (fl < fr) {            right = rm;            rm = lm;            fr = fl;            lm = left + (ll) ((right - left) / (GRATIO + 1.0));            fl = calc(lm);        } else {            left = lm;            lm = rm;            fl = fr;            rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));            fr = calc(rm);        }    }    ll minScore = MAX(ll);    ll resIndex = left;    for (ll i = left; i < right + 1; i++) {        ll score = calc(i);        if (minScore > score) {            minScore = score;            resIndex = i;        }    }    return resIndex;}\nll goldt(ll left, ll right, function<ll(ll)> calc) {    double GRATIO = 1.6180339887498948482045868343656;    ll lm = left + (ll) ((right - left) / (GRATIO + 1.0));    ll rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));    ll fl = calc(lm);    ll fr = calc(rm);    while (right - left > 10) {        if (fl > fr) {            right = rm;            rm = lm;            fr = fl;            lm = left + (ll) ((right - left) / (GRATIO + 1.0));            fl = calc(lm);        } else {            left = lm;            lm = rm;            fl = fr;            rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));            fr = calc(rm);        }    }    if (left > right) {        ll l = left;        left = right;        right = l;    }    ll maxScore = MIN(ll);    ll resIndex = left;    for (ll i = left; i < right + 1; i++) {        ll score = calc(i);        if (maxScore < score) {            maxScore = score;            resIndex = i;        }    }    return resIndex;}\ntemplate<class T> T min(vector<vector<T >> &a) {T res = MAX(T);rep(i, a.size())chmi(res, *min_element(all(a[i])));return res;}\ntemplate<class T> T max(vector<vector<T >> &a) {T res = MIN(T);rep(i, a.size())chma(res, *max_element(all(a[i])));return res;}\n\nconstexpr bool bget(ll m, int keta) {return (m >> keta) & 1;}\nint bget(ll m, int keta, int sinsuu) {m /= (ll) pow(sinsuu, keta);return m % sinsuu;}\nll bit(int n) { return (1LL << (n)); }\nll bit(int n, int sinsuu) { return (ll) pow(sinsuu, n); }\nint mask(int n) { return (1ll << n) - 1; }\n#define bcou __builtin_popcountll\n//最下位ビット\nint lbit(int n) {return n & -n;}\n//最上位ビット\nint hbit(int n) {n |= (n >> 1);n |= (n >> 2);n |= (n >> 4);n |= (n >> 8);n |= (n >> 16);n |= (n >> 32);return n - (n >> 1);}\nint hbitk(int n) {int k = 0;rer(i, 5) {int a = k + (1ll << i);int b = 1ll << a;if (b <= n)k += 1ll << i;}return k;}\n//初期化は0を渡す\nll nextComb(ll &mask, int n, int r) {    if (!mask)return mask = (1LL << r) - 1;    ll x = mask & -mask; /*最下位の1*/    ll y = mask + x; /*連続した下の1を繰り上がらせる*/    ll res = ((mask & ~y) / x >> 1) | y;    if (bget(res, n))return mask = 0;    else return mask = res;}\n//n桁以下でビットがr個立っているもののvectorを返す\nvi bitCombList(int n, int r) {vi res;int m = 0;while (nextComb(m, n, r)) {res.push_back(m);}return res;}\nchar itoal(int i) {    return 'a' + i;}\nchar itoaL(int i) {    return 'A' + i;}\nint altoi(char c) {    if ('A' <= c && c <= 'Z')return c - 'A';    return c - 'a';}\nint ctoi(char c) { return c - '0'; }\nchar itoc(int i) { return i + '0'; }\nint vtoi(vi &v) {    int res = 0;    if (sz(v) > 18) {        debugline(\"vtoi\");        deb(sz(v));        ole();    }    rep(i, sz(v)) {        res *= 10;        res += v[i];    }    return res;}\nvi itov(int i) {    vi res;    while (i) {        res.push_back(i % 10);        i /= 10;    }    rev(res);    return res;}\nvi stov(string &a) {    int n = sz(a);    vi ret(n);    rep(i, n) {        ret[i] = a[i] - '0';    }    return ret;}\n//基準を満たさないものは0になる\nvi stov(string &a,char one) {    int n=sz(a);    vi ret (n);    rep(i,n)ret[i]=a[i]==one;    return ret;}\nvector<vector<int>> ctoi(vector<vector<char>> s, char c) {    int n = sz(s), m = sz(s[0]);    vector<vector<int>> res(n, vector<int>(m));    rep(i, n)rep(j, m)res[i][j] = s[i][j] == c;    return res;}\n#define unique(v) v.erase( unique(v.begin(), v.end()), v.end() );\n//[i] := i番として圧縮されたものを返す\nvi compress(vi &a) {    vi b;    int len = a.size();    for (int i = 0; i < len; ++i) {        b.push_back(a[i]);    }    sort(b);    unique(b);    for (int i = 0; i < len; ++i) {        a[i] = lower_bound(all(b), a[i]) - b.begin();    }    int blen = sz(b);    vi ret(blen);    rep(i, blen) {        ret[i] = b[i];    }    return ret;}\nvi compress(vi &a, umap<int, int> &map) {    vi b;    int len = a.size();    for (int i = 0; i < len; ++i) {        b.push_back(a[i]);    }    sort(b);    unique(b);    for (int i = 0; i < len; ++i) {        int v = a[i];        a[i] = lower_bound(all(b), a[i]) - b.begin();        map[v] = a[i];    }    int blen = sz(b);    vi ret(blen);    rep(i, blen) {        ret[i] = b[i];    }    return ret;}\nvi compress(vi &a, vi &r) {    vi b;    int len = a.size();    fora(v, a)b.push_back(v);    fora(v, r)b.push_back(v);    sort(b);    unique(b);    for (int i = 0; i < len; ++i) a[i] = lower_bound(all(b), a[i]) - b.begin();    for (int i = 0; i < sz(r); ++i) r[i] = lower_bound(all(b), r[i]) - b.begin();    int blen = sz(b);    vi ret(blen);    rep(i, blen) {        ret[i] = b[i];    }    return ret;}\nvi compress(vi &a, vi &r, vi &s) {    vi b;    int len = a.size();    fora(v, a)b.push_back(v);    fora(v, r)b.push_back(v);    fora(v, s)b.push_back(v);    sort(b);    unique(b);    for (int i = 0; i < len; ++i) a[i] = lower_bound(all(b), a[i]) - b.begin();    for (int i = 0; i < sz(r); ++i) r[i] = lower_bound(all(b), r[i]) - b.begin();    for (int i = 0; i < sz(s); ++i) r[i] = lower_bound(all(b), s[i]) - b.begin();    int blen = sz(b);    vi ret(blen);    rep(i, blen) {        ret[i] = b[i];    }    return ret;}\nvi compress(V<vi> &a) {    vi b;    fora(vv, a)fora(v, vv)b.push_back(v);    sort(b);    unique(b);    fora(vv, a)fora(v, vv)v = lower_bound(all(b), v) - b.begin();    int blen = sz(b);    vi ret(blen);    rep(i, blen) {        ret[i] = b[i];    }    return ret;}\nvi compress(vector<vector<vi >> &a) {    vi b;    fora(vvv, a)fora(vv, vvv)fora(v, vv)b.push_back(v);    sort(b);    unique(b);    fora(vvv, a)fora(vv, vvv)fora(v, vv)v = lower_bound(all(b), v) - b.begin();    int blen = sz(b);    vi ret(blen);    rep(i, blen) {        ret[i] = b[i];    }    return ret;}\nvoid compress(int a[], int len) {    vi b;    for (int i = 0; i < len; ++i) {        b.push_back(a[i]);    }    sort(b);    unique(b);    for (int i = 0; i < len; ++i) {        a[i] = lower_bound(all(b), a[i]) - b.begin();    }}\n//要素が見つからなかったときに困る\n#define binarySearch(a, v) (binary_search(all(a),v))\n#define lowerIndex(a, v) (lower_bound(all(a),v)-a.begin())\n#define lowerBound(a, v) (*lower_bound(all(a),v))\n#define upperIndex(a, v) (upper_bound(all(a),v)-a.begin())\n#define upperBound(a, v) (*upper_bound(all(a),v))\ntemplate<class T>  void fin(T s) { cout << s << endl, exit(0); }\n\n//便利 数学 math\nint mod(int a, int m) { return (a % m + m) % m; }\nint pow(int a) { return a * a; };\nll fact(int v) { return v <= 1 ? 1 : v * fact(v - 1); }\n\nll comi(int n, int r) {    assert(n < 100);    static vvi(pas, 100, 100);    if (pas[0][0])return pas[n][r];    pas[0][0] = 1;    rep(i, 1, 100) {        pas[i][0] = 1;        rep(j, 1, i + 1)pas[i][j] = pas[i - 1][j - 1] + pas[i - 1][j];    }    return pas[n][r];}\ndouble comd(int n, int r) {    static vd fac;    if (sz(fac) < n + 1) {        if (sz(fac) == 0)fac.push_back(1);        rep(i, sz(fac) - 1, n) {            fac.push_back(fac.back() * (i + 1));        }    }    if (n < r || n <= 0)return 0;    return fac[n] / fac[n - r] / fac[r];}\nint gcd(int a, int b) {    while (b) a %= b, swap(a, b);    return abs(a);}\nint gcd(vi b) {    ll res = b[0];    rep(i, 1, sz(b))res = gcd(b[i], res);    return res;}\nll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\nll lcm(vi a) {    int res = a[0];    rep(i, 1, sz(a))res = lcm(a[i], res);    return res;}\nll ceil(ll a, ll b) {    if (b == 0) {        debugline(\"ceil\");        deb(a, b);        ole();        return -1;    } else if (a < 0) {        return 0;    } else {return (a + b - 1) / b;}}\n\n//v * v >= aとなる最小のvを返す\nll sqrt(ll a) {if (a < 0) {debugline(\"sqrt\");deb(a);ole();}ll res = (ll) std::sqrt(a);while (res * res < a)res++;return res;}\ndouble log(double e, double x) { return log(x) / log(e); }\nll sig(ll t) { return (1 + t) * t / 2; }\nll sig(ll s, ll t) { return (s + t) * (t - s + 1) / 2; }\n\n\n//幾何 Pをcomplexとして扱う\ntemplate<class T, class U> bool eq(T a, U b) { return fabs(a - b) < eps; }\ndou atan2(pd a) { return atan2(a.se, a.fi); }\ndou angle(pd f, pd t) { return atan2(t.se - f.se, t.fi - f.fi); }\ndou distance(pd a, pd b) { return hypot(a.fi - b.fi, a.se - b.se); }\n//bを中心とするabcのtheta aからcにかけて時計回り\ndou angle(pd a, pd b, pd c) {    dou ax = a.fi - b.fi;    dou ay = a.se - b.se;    dou cx = c.fi - b.fi;    dou cy = c.se - b.se;    double ret = atan2(cy, cx) - atan2(ay, ax);    if (ret < 0) ret += 2 * PI;    return ret;}\ndou dot(pd a, pd b) { return a.fi * b.fi + a.se + b.se; }\ndou cro(pd a, pd b) { return a.fi * b.se - a.se + b.fi; }\n\n//機能拡張\ntemplate<class T, class U> void operator+=(queue<T> &a, U v) { a.push(v); }template<class T, class U> void operator+=(deque<T> &a, U v) { a.push_back(v); }template<class T, class U> priority_queue<T, vector<T>, greater<T> > &operator+=(priority_queue<T, vector<T>, greater<T> > &a, vector <U> &v) {    fora(d, v)a.push(d);    return a;}template<class T, class U> priority_queue<T, vector<T>, greater<T> > &operator+=(priority_queue<T, vector<T>, greater<T> > &a, U v) {    a.push(v);    return a;}template<class T, class U> priority_queue<T> &operator+=(priority_queue<T> &a, U v) {    a.push(v);    return a;}template<class T> set<T> &operator+=(set<T> &a, vector<T>  v) {fora(d,v)a.insert(d);return a;}template<class T, class U> set<T> &operator+=(set<T> &a, U v) {    a.insert(v);    return a;}template<class T, class U> set<T, greater<T>> &operator+=(set<T, greater<T>> &a, U v) {    a.insert(v);    return a;}template<class T, class U> vector<T> &operator+=(vector<T> &a, U v) {    a.push_back(v);    return a;}\ntemplate<class T, class U> vector<T> operator+(const vector <T> &a, U v) {vector<T> ret = a;ret += v;return ret;}\ntemplate<class T, class U> vector<T> operator+(U v, const vector <T> &a) {vector<T> ret = a;ret.insert(ret.begin(), v);return ret;}\ntemplate<class T> vector<T> operator+(vector<T> a, vector <T> b) {vector<T> ret;ret = a;fora(v, b)ret += v;return ret;}\ntemplate<class T> vector<T> &operator+=(vector<T> &a, vector <T> &b) {fora(v, b)a += v;return a;}\ntemplate<class T> vector<T> &operator-=(vector<T> &a, vector <T> &b) {if (sz(a) != sz(b)) {debugline(\"vector<T> operator-=\");deb(a);deb(b);exit(0);}rep(i, sz(a))a[i] -= b[i];return a;}\ntemplate<class T> vector<T> operator-(vector<T> &a, vector <T> &b) {if (sz(a) != sz(b)) {debugline(\"vector<T> operator-\");deb(a);deb(b);ole();}vector<T> res(sz(a));rep(i, sz(a))res[i] = a[i] - b[i];return res;}\ntemplate<class T,class U> vector<T> operator*(vector<T> &a, U b) {vector<T> ret;fora(v,a)ret+=v*b;return ret;}\ntemplate<class T,class U> vector<T> operator/(vector<T> &a, U b) {vector<T> ret;fora(v,a)ret+=v/b;return ret;}\ntemplate<class T,class U> vector<T> operator*=(vector<T> &a, U b) {fora(v,a)v*=b;return a;}\ntemplate<class T,class U> vector<T> operator/=(vector<T> &a, U b) {fora(v,a)v/=b;return a;}\ntemplate<typename T> void erase(vector<T> &v, unsigned int i) {v.erase(v.begin()+ i);}\ntemplate<typename T> void erase(vector<T> &v, unsigned int s,unsigned int e) {v.erase(v.begin()+ s, v.begin()+ e);}\ntemplate<class T, class U> void erase(map<T, U> &m, int okl, int ngr) {m.erase(m.lower_bound(okl), m.lower_bound(ngr));}\ntemplate<class T> void erase(set<T> &m, int okl, int ngr) {m.erase(m.lower_bound(okl), m.lower_bound(ngr));}\ntemplate<typename T> void erasen(vector<T> &v, unsigned int s,unsigned int n) {v.erase(v.begin()+ s, v.begin()+ s + n);}\ntemplate<typename T, typename U> void insert(vector<T> &v, unsigned int i,U t) {v.insert(v.begin()+ i, t);}\ntemplate<typename T, typename U> void push_front(vector<T> &v, U t) {v.insert(v.begin(), t);}\ntemplate<typename T, typename U> void insert(vector<T> &v, unsigned int i,vector<T> list) {for (auto &&va:list)v.insert(v.begin()+ i++, va);}\ntemplate<typename T> void insert(set<T> &v, vector<T> list) {for (auto &&va :list)v.insert(va);}\nvector<string> split(const string a, const char deli) {    string b = a + deli;    int l = 0, r = 0, n = b.size();    vector<string> res;    rep(i, n) {        if (b[i] == deli) {            r = i;            if (l < r)res.push_back(b.substr(l, r - l));            l = i + 1;        }    }    return res;}\nvector<string> split(const string a, const string deli) {    vector<string> res;    int kn = sz(deli);    std::string::size_type Pos(a.find(deli));    int l = 0;    while (Pos != std::string::npos) {        if (Pos - l)res.push_back(a.substr(l, Pos - l));        l = Pos + kn;        Pos = a.find(deli, Pos + kn);    }    if (sz(a) - l)res.push_back(a.substr(l, sz(a) - l));    return res;}\nvoid yn(bool a) {if (a)cout << \"yes\" << endl;    else cout << \"no\" << endl;}\nvoid Yn(bool a) {if (a)cout << \"Yes\" << endl;    else cout << \"No\" << endl;}\nvoid YN(bool a) {if (a)cout << \"YES\" << endl;    else cout << \"NO\" << endl;}\nvoid fyn(bool a) {if (a)cout << \"yes\" << endl;    else cout << \"no\" << endl;    exit(0);}\nvoid fYn(bool a) {if (a)cout << \"Yes\" << endl;    else cout << \"No\" << endl;    exit(0);}\nvoid fYN(bool a) {if (a)cout << \"YES\" << endl;    else cout << \"NO\" << endl;    exit(0);}\nvoid Possible(bool a) {if (a)cout << \"Possible\" << endl;    else cout << \"Impossible\" << endl;    exit(0);}\nvoid POSSIBLE(bool a) {if (a)cout << \"POSSIBLE\" << endl;    else cout << \"IMPOSSIBLE\" << endl;    exit(0);}\n//@起動時\nstruct initon {\n    initon() {\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.setf(ios::fixed);\n        cout.precision(16);\n        srand((unsigned) clock() + (unsigned) time(NULL));\n    };\n} __initon;\n\n//@formatter:on\n//gra mint pr\nint n, m, k, d, H, W, x, y, z, q;\nint cou;\nvi t, a, b, c;\n//vvi (s, 0, 0);\nvvc (ba, 0, 0);\nvp p;\nstr s;\n\n//@formatter:off\ntemplate<class T> struct edge { int f, t; T c; int id; int type; edge(int f, int t, T c = 1, int id = -1, int ty = -1) : f(f), t(t), c(c), id(id), type(ty) {} bool operator<(const edge &b) const { return c < b.c; } bool operator>(const edge &b) const { return c > b.c; }};\ntemplate<class T> ostream &operator<<(ostream &os, edge<T> &e) {    os << e.f << \" \" << e.t << \" \" << e.c;    return os;}\ntemplate<typename T> class graph {protected:    vector<bool> usedv;public :    vector<vector<edge<T>>> g;    vector<edge<T>> edges;    int n;    graph(int n) : n(n) { g.resize(n), usedv.resize(n); }    void clear() { g.clear(), edges.clear(); }    void resize(int n) {        this->n = n;        g.resize(n);        usedv.resize(n);    }    int size() { return g.size(); }    vector<edge<T> > &operator[](int i) { return g[i]; }    virtual void add(int f, int t, T c, int id, int ty) = 0;    virtual bool used(edge<T> &e) = 0;    virtual bool used(int id) = 0;    virtual void del(edge<T> &e) = 0;    virtual void del(int id) = 0;    virtual void set_edges() = 0;};\ntemplate<typename T =ll> class digraph : public graph<T> {\npublic:\n    using graph<T>::g;\n    using graph<T>::n;\n    using graph<T>::edges;\n    using graph<T>::usedv;\n    int eid = 0;\n\n    digraph(int n) : graph<T>(n) {}\n    void add(int f, int t, T c = 1, int id = -1, int ty = -1) {\n        if (!(0 <= f && f < n && 0 <= t && t < n)) {\n            debugline(\"digraph add\");\n            deb(f, t, c, id, ty);\n            ole();\n        }\n        if (id == -1)id = eid++;\n        g[f].emplace_back(f, t, c, id, ty);\n        edges.emplace_back(f, t, c, id, ty);\n    }\n    bool used(edge<T> &e) { return usedv[e.id]; }\n    bool used(int id) { return usedv[id]; }\n    void del(edge<T> &e) { usedv[e.id] = usedv[e.id ^ 1] = 1; }\n    void del(int id) { usedv[id] = usedv[id ^ 1] = 1; }\n    void set_edges() {        if (sz(edges))return;        rep(i, n)fora(e, g[i])edges.push_back(e);    }\n};\ntemplate<class T=int> class undigraph : public graph<T> {\npublic:\n    using graph<T>::g;\n    using graph<T>::n;\n    using graph<T>::edges;\n    using graph<T>::usedv;\n    int eid = 0;\n    undigraph(int n) : graph<T>(n) {}\n    void add(int f, int t, T c = 1, int id = -1, int ty = -1) {\n        if (!(0 <= f && f < n && 0 <= t && t < n)) {\n            debugline(\"undigraph add\");\n            deb(f, t, c, id, ty);\n            ole();\n        }\n        if (id == -1)id = eid, eid += 2;\n        g[f].emplace_back(f, t, c, id, ty);\n        g[t].emplace_back(t, f, c, id + 1, ty);\n        edges.emplace_back(f, t, c, id, ty);\n        edges.emplace_back(t, f, c, id + 1, ty);\n    }\n    void add(edge<T> &e) {        int f = e.f, t = e.t, ty = e.type;        T c = e.c;        add(f, t, c, ty);    }\n    bool used(edge<T> &e) { return usedv[e.id]; }\n    bool used(int id) { return usedv[id]; }\n    void del(edge<T> &e) { usedv[e.id] = usedv[e.id ^ 1] = 1; }\n    void del(int id) { usedv[id] = usedv[id ^ 1] = 1; }\n    void set_edges() {        if (sz(edges))return;        rep(i, n)fora(e, g[i])edges.push_back(e);    }\n};\ntemplate<typename T> struct radixheap {    vector<pair<u64, T> > v[65];    u64 size, last;    radixheap() : size(0), last(0) {}    bool empty() const { return size == 0; }    inline int getbit(int a) { return a ? 64 - __builtin_clzll(a) : 0; }    void push(u64 key, const T &value) {        ++size;        v[getbit(key ^ last)].emplace_back(key, value);    }    pair<u64, T> pop() {        if (v[0].empty()) {            int idx = 1;            while (v[idx].empty()) ++idx;            last = min_element(begin(v[idx]), end(v[idx]))->first;            for (auto &p : v[idx]) v[getbit(p.first ^ last)].emplace_back(p);            v[idx].clear();        }        --size;        auto ret = v[0].back();        v[0].pop_back();        return ret;    }};\n//radiq_heap\nvi dijkstra2(const graph<int> &g, int s, int cant_arrive = -1) {    if (!(0 <= s && s < g.n)) {        debugline(\"dijkstra\");        deb(s, g.n);        ole();    }    int initValue = MAX(int);    vi dis(g.n, initValue);    radixheap<int> q;    dis[s] = 0;    q.push(0, s);    while (!q.empty()) {        int nowc, i;        tie(nowc, i) = q.pop();        if (dis[i] != nowc)continue;        for (auto &&e  : g.g[i]) {            int to = e.t;            int c = nowc + e.c;            if (dis[to] > c) {                dis[to] = c;                q.push(dis[to], to);            }        }    }    /*基本、たどり着かないなら-1*/    if (cant_arrive == -1)for (auto &&d :dis) if (d == initValue)d = -1;    return dis;}\n//priority_queue\ntemplate<class T> vector<T> dijkstra(const graph<T> &g, int s, int cant_arrive = -1) {    if (!(0 <= s && s < g.n)) {        debugline(\"dijkstra\");        deb(s, g.n);        ole();    }    T initValue = MAX(T);    vector<T> dis(g.n, initValue);    priority_queue<pair<T, int>, vector<pair<T, int>>, greater<pair<T, int>>> q;    dis[s] = 0;    q.emplace(0, s);    while (q.size()) {        T nowc = q.top().fi;        int i = q.top().se;        q.pop();        if (dis[i] != nowc)continue;        for (auto &&e  : g.g[i]) {            int to = e.t;            T c = nowc + e.c;            if (dis[to] > c) {                dis[to] = c;                q.emplace(dis[to], to);            }        }    }    /*基本、たどり着かないなら-1*/    if (cant_arrive == -1)for (auto &&d :dis) if (d == initValue)d = -1;    return dis;}\ntemplate<class T> vector<vector<T>> warshall(const graph<T> &g, int cant_arrive = -1) {    int n = g.n;    vector<vector<T> > dis(n, vector<T>(n, linf));    rep(i, n)fora(e, g.g[i])chmi(dis[e.f][e.t], e.c);    rep(i, n)dis[i][i] = 0;    rep(k, n)rep(i, n)rep(j, n)chmi(dis[i][j], dis[i][k] + dis[k][j]);    /*基本、たどり着かないなら-1*/    if (cant_arrive == -1)rep(i, n)rep(j, n) if (dis[i][j] == linf)dis[i][j] = -1;    return dis;}\ntemplate<class T=int> class tree : public undigraph<T> {public:    using undigraph<T>::g;    using undigraph<T>::n;    using undigraph<T>::edges;    using undigraph<T>::usedv;    vi disv;private:    bool never = 1;    int root = -1;    vi dep;/*到着した順の深さ*/    vi vis;/*到着した順*/    vi first;/*初めてiに到着した時*/    vector<int> bestt;/*タイミングを持つ*/    int sn = 0;/*seg木の底辺の長さ euler tourの長さ*/    void built() {        never = 0;        n = g.size();        /*euler tour*/        disv.resize(n);        first.resize(n);        dep.resize(n * 2);        vis.resize(n * 2);        function<void(int, int, int, int &)> dfs = [&](int i, int p, int d, int &k) {            first[i] = k;            vis[k] = i;            dep[k++] = d;            forg(gi, g[i]) {                if (t == p)continue;                disv[t] = disv[i] + c;                dfs(t, i, d + 1, k);                vis[k] = i;                dep[k++] = d;            }        };        int k = 0;        dfs(root, -1, 0, k);        /*rmq*/        sn = 1;        while (sn < n * 2)sn <<= 1;        bestt.resize((sn << 1) - 1);        rep(i, k)bestt[i + sn - 1] = i;/*時間を持つ*/        rer(i, sn - 2) {            int lt = (i << 1) + 1, rt = (i << 1) + 2;            if (dep[bestt[lt]] < dep[bestt[rt]]) {                bestt[i] = bestt[lt];            } else {                bestt[i] = bestt[rt];            }        }    }    /*最小の深さを持つタイミングが知りたい*/    inline int lca_rmq(int l, int r) {        int midv = inf;        int midi = -1;        l += sn - 1;        r += sn - 1;        while (l < r) {            /*右なら、次に右上へ移動してしまうので*/            if (!(l & 1)) {                if (chmi(midv, dep[bestt[l]])) {                    midi = bestt[l];                }            }            /*右なら、左を取らないと機会を逃す*/            if (!(r & 1)) {                if (chmi(midv, dep[bestt[r - 1]])) {                    midi = bestt[r - 1];                }            }            l >>= 1;            r = (r - 1) >> 1;        }        return vis[midi];    }public:    tree(int n, int root = 0) : undigraph<T>(n), root(root) {}    bool leaf(int v) {        return sz(g[v]) == 1 && v != root;    }    int lca(int u, int v) {        if (never)built();        if (first[u] > first[v])swap(u, v);        return lca_rmq(first[u], first[v] + 1);    }    int dis(int u, int v) {        if (never) built();        if (first[u] > first[v])swap(u, v);        int p = lca_rmq(first[u], first[v] + 1);        return disv[u] + disv[v] - disv[p] * 2;    }};\n//辺によりメモリを大量消費\n// よってedgesを消している\n//頂点10^6でメモリを190MB(制限の8割)使う\ntemplate<class T=int> class grid_k6 : public undigraph<T> {public:    using undigraph<T>::g;    using undigraph<T>::n;    using undigraph<T>::edges;    using undigraph<T>::usedv;    int H, W;    int eid = 0;    void add(int f, int t, T c = 1, int id = -1, int ty = -1) {        if (!(0 <= f && f < n && 0 <= t && t < n)) {            debugline(\"grid_k6 add\");            deb(f, t, c, id, ty);            ole();        }        g[f].emplace_back(f, t, c, eid++, ty);        g[t].emplace_back(t, f, c, eid++, ty);    }    int getid(int h, int w) {        if (!inside(h, w, H, W))return -1;        return W * h + w;    }    P get2(int id) {        return mp(id / W, id % W);    }    P operator()(int id) {        return get2(id);    }    int operator()(int h, int w) {        return getid(h, w);    }    grid_k6(int H, int W) : H(H), W(W), undigraph<T>(H * W) {        rep(h, H) {            rep(w, W) {                int f = getid(h, w);                if (w + 1 < W) add(f, getid(h, w + 1));                if (h + 1 < H)add(f, getid(h + 1, w));            }        }    }    grid_k6(vector<vector<char>> ba, char wall = '#') : H(sz(ba)), W(sz(ba[0])), undigraph<T>(sz(ba) * sz(ba[0])) {        rep(h, H) {            rep(w, W) {                if (ba[h][w] == wall)con;                int f = getid(h, w);                if (w + 1 < W && ba[h][w + 1] != wall) {                    add(f, getid(h, w + 1));                }                if (h + 1 < H && ba[h + 1][w] != wall) {                    add(f, getid(h + 1, w));                }            }        }    }    void add(int fh, int fw, int th, int tw) {        add(getid(fh, fw), getid(th, tw));    }    void set_edges() {        rep(i, n)fora(e, g[i])edges.push_back(e);    }};\n//左上から右下に移動できる\ntemplate<class T=int> class digrid_k6 : public digraph<T> {public:    using digraph<T>::g;    using digraph<T>::n;    using digraph<T>::edges;    using digraph<T>::usedv;    int H, W;    int eid = 0;    void add(int f, int t, T c = 1, int id = -1, int ty = -1) {        if (!(0 <= f && f < n && 0 <= t && t < n)) {            debugline(\"digrid_k6 add\");            deb(f, t, c, id, ty);            ole();        }        g[f].emplace_back(f, t, c, eid++, ty);    }    int getid(int h, int w) {        if (!inside(h, w, H, W))return -1;        return W * h + w;    }    P get2(int id) {        return mp(id / W, id % W);    }    P operator()(int id) {        return get2(id);    }    int operator()(int h, int w) {        return getid(h, w);    }    digrid_k6(int H, int W) : H(H), W(W), digraph<T>(H * W) {        rep(h, H) {            rep(w, W) {                int f = getid(h, w);                if (w + 1 < W) add(f, getid(h, w + 1));                if (h + 1 < H)add(f, getid(h + 1, w));            }        }    }    digrid_k6(vector<vector<char>> ba, char wall = '#') : H(sz(ba)), W(sz(ba[0])), digraph<T>(sz(ba) * sz(ba[0])) {        rep(h, H) {            rep(w, W) {                if (ba[h][w] == wall)con;                int f = getid(h, w);                if (w + 1 < W && ba[h][w + 1] != wall) {                    add(f, getid(h, w + 1));                }                if (h + 1 < H && ba[h + 1][w] != wall) {                    add(f, getid(h + 1, w));                }            }        }    }    void add(int fh, int fw, int th, int tw) {        add(getid(fh, fw), getid(th, tw));    }    void set_edges() {        rep(i, n)fora(e, g[i])edges.push_back(e);    }};\ntemplate<class T> bool nibu(const graph<T> &g) {    int size = 0;    rep(i, g.n)size += sz(g.g[i]);    if (size == 0)return true;    UnionFind uf(g.n * 2);    rep(i, g.n)fora(e, g.g[i])uf.unite(e.f, e.t + g.n), uf.unite(e.f + g.n, e.t);    rep(i, g.n)if (uf.same(i, i + g.n))return 0;    return 1;}\n//二部グラフを色分けした際の頂点数を返す\ntemplate<class T> vp nibug(graph<T> &g) {    vp cg;    if (!nibu(g)) {        debugline(\"nibu\");        ole();    }    int n = g.size();    vb was(n);    queue<P> q;    rep(i, n) {        if (was[i])continue;        q.push(mp(i, 1));        was[i] = 1;        int red = 0;        int coun = 0;        while (q.size()) {            int now = q.front().fi;            int col = q.front().se;            red += col;            coun++;            q.pop();            forg(gi, g[now]) {                if (was[t])continue;                q.push(mp(t, col ^ 1));                was[t] = 1;            }        }        cg.push_back(mp(red, coun - red));    }    return cg;}\ntemplate<class T> ostream &operator<<(ostream &os, graph<T> &g) {    rep(i, sz(g)) {        forg(gi, g[i]) {            os << f << \" \" << t << \" \" << c << endl;        }    }    return os;}\n//閉路がなければtrue\nbool topo(vi &res, digraph<int> &g) {    int n = g.g.size();    vi nyu(n);    rep(i, n)for (auto &&e :g[i])nyu[e.t]++;    queue<int> st;    rep(i, n)if (nyu[i] == 0)st.push(i);    while (st.size()) {        int v = st.front();        st.pop();        res.push_back(v);        fora(e, g[v]) if (--nyu[e.t] == 0)st.push(e.t);    }    return res.size() == n;}\n//辞書順最小トポロジカルソート\nbool topos(vi &res, digraph<int> &g) {    int n = g.g.size();    vi nyu(n);    rep(i, n)for (auto &&e :g[i])nyu[e.t]++;    /*小さい順*/    priority_queue<int, vector<int>, greater<int> > q;    rep(i, n)if (nyu[i] == 0)q.push(i);    while (q.size()) {        int i = q.top();        q.pop();        res.push_back(i);        fora(e, g[i])if (--nyu[e.t] == 0)q.push(e.t);    }    return res.size() == n;}\ntemplate<class T> vi indegree(graph<T> &g) {    vi ret(g.size());    rep(i, g.size()) {        forg(gi, g[i]) {            ret[t]++;        }    }    return ret;}\ntemplate<class T> vi outdegree(graph<T> &g) {    vi ret(g.size());    rep(i, g.size()) {        ret[i] = g[i].size();    }    return ret;}\ntemplate<class T> digraph<T> rev(digraph<T> &g) {    digraph<T> r(g.n);    rep(i, g.n) {        forg(gi, g[i]) {            r.add(t, f, c);        }    }    return r;}\ntemplate<class T> vp bridge(graph<T> &G) {    static bool was;    vp brid;    vi articulation;    vi ord(G.n), low(G.n);    vb vis(G.n);    function<void(int, int, int)> dfs = [&](int v, int p, int k) {        vis[v] = true;        ord[v] = k++;        low[v] = ord[v];        bool isArticulation = false;        int ct = 0;        for (int i = 0; i < G[v].size(); i++) {            if (!vis[G[v][i].t]) {                ct++;                dfs(G[v][i].t, v, k);                low[v] = min(low[v], low[G[v][i].t]);                if (~p && ord[v] <= low[G[v][i].t]) isArticulation = true;                if (ord[v] < low[G[v][i].t]) brid.push_back(make_pair(min(v, G[v][i].t), max(v, G[v][i].t)));            } else if (G[v][i].t != p) {                low[v] = min(low[v], ord[G[v][i].t]);            }        }        if (p == -1 && ct > 1) isArticulation = true;        if (isArticulation) articulation.push_back(v);    };    int k = 0;    rep(i, n) {        if (!vis[i]) dfs(i, -1, k);    }    sort(brid.begin(), brid.end());    return brid;}\ntemplate<class T> vi articulation(undigraph<T> &G) {    static bool was;    vp bridge;    vi arti;    vi ord(G.n), low(G.n);    vb vis(G.n);    function<void(int, int, int)> dfs = [&](int v, int p, int k) {        vis[v] = true;        ord[v] = k++;        low[v] = ord[v];        bool isArticulation = false;        int ct = 0;        for (int i = 0; i < G[v].size(); i++) {            if (!vis[G[v][i].t]) {                ct++;                dfs(G[v][i].t, v, k);                low[v] = min(low[v], low[G[v][i].t]);                if (~p && ord[v] <= low[G[v][i].t]) isArticulation = true;                if (ord[v] < low[G[v][i].t]) bridge.push_back(make_pair(min(v, G[v][i].t), max(v, G[v][i].t)));            } else if (G[v][i].t != p) {                low[v] = min(low[v], ord[G[v][i].t]);            }        }        if (p == -1 && ct > 1) isArticulation = true;        if (isArticulation) arti.push_back(v);    };    int k = 0;    rep(i, n) {        if (!vis[i]) dfs(i, -1, k);    }    sort(arti.begin(), arti.end());    return arti;}\n#define kansetu articulation\n//@formatter:on\n\n\n\n\n//v3i(dp, 5000, 5001, 2);//コンピューターしかないか\nint dp[5000][5001][2], sub[5001][2];\n//vvi(sub, 5050, 2);\nundigraph<> g(0);\nvi es(5050);\n\nvoid ds(int i, int p) {\n    forg(gi, g[i])if (t != p)ds(t, i);\n    int sum = 0;\n    dp[i][0][a[i] < 0] = a[i];\n    forg(gi, g[i]) {\n        if (t == p)continue;\n        rep(ci, sum + 1) {\n            rep(ct, es[t] + 1) {\n                rep(ki, 2) {\n                    rep(kt, 2) {\n                        //繋ぐ\n                        if (dp[i][ci][ki] < linf && dp[t][ct][kt] < linf)\n                            chmi(sub[ci + ct][ki || kt], dp[i][ci][ki] + dp[t][ct][kt]);\n                        //切る\n                        if (dp[t][ct][kt] < 0 || (!kt && dp[t][ct][kt] != linf))\n                            chmi(sub[ci + ct + 1][ki], dp[i][ci][ki]);\n                    }\n                }\n            }\n        }\n        sum += es[t] + 1;\n        rep(j, sum + 1)\n            rep(k, 2) {\n                dp[i][j][k] = sub[j][k];\n                sub[j][k] = linf;\n\n            }\n    }\n    es[i] = sum;\n}\nsigned main() {\n    cin >> n;\n    na(a, n);\n    g.resize(n);\n    rep(i, n - 1) {\n        int f, s;\n        cin >> f >> s;\n        --f, --s;\n        g.add(f, s);\n    }\n    fill(dp, linf);\n    fill(sub, linf);\n    ds(0, -1);\n    rep(c, n)rep(k, 2) {\n            if (k) {\n                if (dp[0][c][k] < 0)fin(c);\n            } else if (dp[0][c][k] != linf)fin(c);\n        }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 0x3f3f3f3f\nusing namespace std;\ntypedef long long ll;\nconst int N=5005;\nint n,a[N],si[N],tot,head[N],nex[N<<1],to[N<<1];\nvoid add(int u,int v){to[++tot]=v;nex[tot]=head[u];head[u]=tot;}\nll dp[N][N][2],f[N][2];\nvoid dfs(int u,int p)\n{\n    if(a[u]<0) dp[u][1][1]=a[u];\n    else dp[u][1][0]=a[u];\n    si[u]=1;\n    for(int i=head[u];i;i=nex[i])\n    {\n        int v=to[i];if(v==p) continue;\n        dfs(v,u);\n        memset(f,inf,sizeof(f));\n        for(int j=1;j<=si[u];j++)\n            for(int k=1;k<=si[v];k++)\n        {\n            if((dp[v][k][0]<inf||dp[v][k][1]<0)&&dp[u][j][0]<inf)\n                f[j+k][0]=min(f[j+k][0],dp[u][j][0]);\n            if((dp[v][k][0]<inf||dp[v][k][1]<0)&&dp[u][j][1]<inf)\n                f[j+k][1]=min(f[j+k][1],dp[u][j][1]);\n            for(int h=0;h<2;h++)\n                for(int p=0;p<2;p++)\n                if(dp[u][j][h]<inf&&dp[v][k][p]<inf)\n                f[j+k-1][h|p]=min(f[j+k-1][h|p],dp[u][j][h]+dp[v][k][p]);\n        }\n        si[u]+=si[v];\n        for(int j=1;j<=si[u];j++)\n            dp[u][j][0]=f[j][0],dp[u][j][1]=f[j][1];\n    }\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n    for(int i=1;i<n;i++)\n    {\n        int u,v;scanf(\"%d%d\",&u,&v);\n        add(u,v);add(v,u);\n    }\n    memset(dp,inf,sizeof(dp));\n    dfs(1,0);\n    int ans=n-1;\n    for(int i=1;i<=n;i++)\n        if(dp[1][i][0]<inf||dp[1][i][1]<0){ans=i-1;break;}\n    printf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;using ll=long long;using uint=unsigned int;using pii=pair<int,int>;using pll=pair<ll,ll>;using ull = unsigned long long;using ld=long double;template<typename T>void _(const char*s,T h){cerr<<s<<\" = \"<<h<<\"\\n\";}template<typename T,typename...Ts>void _(const char*s,T h,Ts...t){int b=0;while(((b+=*s=='(')-=*s==')')!=0||*s!=',')cerr<<*s++;cerr<<\" = \"<<h<<\",\";_(s+1,t...);}// break continue pop_back 998244353\n#define int ll\n#define pii pll\n#define f first\n#define s second\n#define pb emplace_back\n#define forn(i,n) for(int i=0;i<(n);++i)\n#define sz(a)((int)(a).size())\n#define sqr(x) ((x)*(x))\nstruct init{init(){cin.tie(0);iostream::sync_with_stdio(0);cout<<fixed<<setprecision(10);cerr<<fixed<<setprecision(5);}~init(){\n#ifdef LOCAL\n#define dbg(...) _(#__VA_ARGS__,__VA_ARGS__)\ncerr<<\"Time elapsed: \"<<(double)clock()/CLOCKS_PER_SEC<<\"s.\\n\";\n#else\n#define dbg(...) \n#endif\n}}init;template<typename T,typename U>void upx(T&x,U y){if(x<y)x=y;}template<typename T,typename U>void upn(T&x,U y){if(x>y)x=y;}mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());const int D=4,dx[]={+1,0,-1,0},dy[]={0,+1,0,-1};\nconst int N=5001,OO=1e18;\nint dp[N][N],ba[N][N];\nint a[N];\nvector<int> g[N];\nint sz[N],dv[N],du[N],dt[N];\nvoid dfs(int v,int p=0){\n    sz[v]=1;\n    for(int to:g[v]){\n        if(to^p){\n            dfs(to,v);\n            sz[v]+=sz[to];\n        }\n    }\n    // forn(i,sz[v])dp[v][i]=ba[v][i]=OO;\n    {\n        int maxv=0;\n        forn(i,N)dv[i]=OO;\n        dv[0]=0;\n        for(int to:g[v]){\n            if(to^p){\n                int maxto=sz[to];\n                forn(i,maxv+maxto+2)dt[i]=OO;\n                forn(i,maxto+1){\n                    du[i]=dp[to][i];\n                    if(i&&du[i-1]<0)upn(du[i],0);\n                    if(i&&a[to]>0&&ba[to][i-1])upn(du[i],0);\n                }\n                forn(i,maxv+1){\n                    forn(j,maxto+1){\n                        upn(dt[i+j],dv[i]+du[j]);\n                    }\n                }\n                forn(i,maxv+maxto+2)dv[i]=dt[i];\n                maxv+=maxto;\n            }\n        }\n        forn(i,sz[v])dp[v][i]=dv[i]+a[v];\n    }\n    if(a[v]>0){\n        int maxv=0;\n        forn(i,N)dv[i]=0;\n        dv[0]=1;\n        for(int to:g[v]){\n            if(to^p){\n                int maxto=sz[to];\n                forn(i,maxv+maxto+2)dt[i]=0;\n                forn(i,maxto+1){\n                    if(a[to]>0){\n                        du[i]=ba[to][i];\n                        if(i)du[i]|=ba[to][i-1];\n                    }else{\n                        du[i]=0;\n                        if(i)du[i]=dp[to][i-1]<0;\n                    }\n                }\n                if(v==3){\n                    dbg(to);\n                    forn(i,maxv+1)dbg(i,dv[i]);\n                    forn(i,maxto+1)dbg(i,du[i]);\n                }\n                forn(i,maxv+1){\n                    forn(j,maxto+1){\n                        dt[i+j]|=dv[i]&du[j];\n                    }\n                }\n                forn(i,maxv+maxto+2)dv[i]=dt[i];\n                maxv+=maxto;\n            }\n        }\n        forn(i,sz[v])ba[v][i]=dv[i];\n    }else{\n        // forn(i,sz[v])if(dp[v][i]<0)ba[v][i]=1;\n    }\n    dbg(v,a[v]);\n    forn(i,sz[v])dbg(dp[v][i],ba[v][i]);\n    dbg(\"=====\");\n}\nint32_t main(){\n    int n;\n    cin>>n;\n    for(int i=1;i<=n;++i)cin>>a[i];\n    forn(i,n-1){\n        int x,y;\n        cin>>x>>y;\n        g[x].pb(y);\n        g[y].pb(x);\n    }\n    dfs(1);\n    int ans=N;\n    forn(i,n){\n        if(a[1]>0&&ba[1][i]){\n            ans=i;\n            break;\n        }\n        if(a[1]<0&&dp[1][i]<0){\n            ans=i;\n            break;\n        }\n    }\n    cout<<ans<<'\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stdio.h>\n#include <vector>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stdlib.h>\n#include <time.h>\n#include <iomanip>\n#include <math.h>\n#include <bitset>\n\nusing namespace std;\n\n#define taskname \"A\"\n#define LL long long \n#define uLL unsigned long long \n#define FOR(i,l,r) for(int i = l; i <= r; ++i)\n#define REP(i,l,r) for(int i = l; i < r; ++i)\n#define FORD(i,r,l) for(int i = r; i >= l; --i)\n#define REPD(i,r,l) for(int i = r; i > l; --i)\n#define sz(x) (int)((x).size())\n#define all(x) (x).begin(), (x).end()\n#define debug(x) { cerr << #x << \" = \" << x << endl; }\n#define sci(x) int x; scanf(\"%d\", &x);\n#define scii(x, y) int x, y; scanf(\"%d %d\", &x, &y);\n#define sciii(x, y, z) int x, y, z; scanf(\"%d %d %d\", &x, &y, &z);\n#define pi pair<int,int>\n#define pii pair<int,pi>\n#define piLL pair<LL,LL>\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define _USE_MATH_DEFINES \n/* M_PI */\n#define SetLength2(a, n, t) a=((t*) calloc(n, sizeof(t))) + (n)/2\n\nconst int maxN = 5001;\nconst LL oo = 1e17 + 11;\n\nint tcases = 1;\n\nint N,M,total = 0,res = 0;\nvector <int> e[maxN];\nint C[maxN];\nLL W[maxN],A[maxN],F[maxN][maxN],G[maxN][maxN],f1[maxN],g1[maxN];\npiLL tmp[maxN],fg[maxN];\n\nvoid dfs(int u,int p = 0){\n    W[u] = A[u];\n    C[u] = 1;\n    REP(i,0,e[u].size()){\n        int v = e[u][i];\n        if(v == p) continue;\n        dfs(v,u);\n        W[u] += W[v];\n        C[u] += C[v];\n    }\n}\nvoid cal(int u,int p = 0){\n    REP(i,0,e[u].size()){\n        int v = e[u][i];\n        if(v == p) continue;\n        cal(v,u);\n    }\n    //\n    F[u][0] = W[u];\n    if(C[u] == 1) G[u][0] = A[u] > 0 ? A[u] : oo;\n    else{\n        REP(i,0,C[u]) f1[i] = g1[i] = oo;\n        f1[0] = g1[0] = 0; // \n        \n        REP(node,0,e[u].size()){\n            int v = e[u][node];\n            if(v == p) continue;\n            // cal F[u][i]\n            REP(i,0,C[u]){\n                F[u][i] = G[u][i] = oo;\n                FOR(j,0,i){\n                    F[u][i] = min(F[u][i],f1[i - j] + min(F[v][j],G[v][j]));\n                    G[u][i] = min(G[u][i],g1[i - j] + G[v][j]);\n                }\n            }\n            REP(i,0,C[u]) f1[i] = F[u][i],g1[i] = G[u][i];\n            /*cout << \"after first round \" << v << \" : \" << endl;\n            REP(i,0,C[u]) cout << f1[i] << \" \";\n            cout << endl;\n            REP(i,0,C[u]) cout << g1[i] << \" \";\n            cout << endl;*/\n        }\n        REP(i,0,C[u]){\n            F[u][i] += A[u];\n            if(A[u] < 0) G[u][i] = oo; else G[u][i] += A[u];\n        }\n    }\n    REP(i,0,C[u]){\n        //cout << \" F[\"<<u<<\"][\"<<i<<\"] = \" << F[u][i] << endl;\n        //cout << \" G[\"<<u<<\"][\"<<i<<\"] = \" << G[u][i] << endl;\n        if(F[u][i] < 0 || G[u][i] < oo){\n            F[u][i + 1] = min(F[u][i + 1],0LL);\n            G[u][i + 1] = min(G[u][i + 1],0LL);\n        }\n    }\n}\nvoid testcase(){\n    scanf(\"%d\",&N);\n    FOR(i,1,N) scanf(\"%lli\",&A[i]);\n    \n    REP(i,1,N){\n        scii(u,v);\n        e[u].pb(v);\n        e[v].pb(u);\n    }\n    dfs(1);\n\n    FOR(i,1,N){\n        FOR(j,0,N) F[i][j] = G[i][j] = oo;\n    }\n\n    cal(1);\n    \n    FOR(j,0,N) if(F[1][j] < 0 || G[1][j] < oo){\n        printf(\"%d\",j);\n        return ;\n    }\n}\n\nint main(){\n    \n    //scanf(\"%d\",&tcases);\n    \n    FOR(i,1,tcases) testcase();\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst ll oo = 1e18;\nconst int N = 5005;\n\nint n, A[N];\nvector<int> adj[N];\nvector<ll> dp1[N], dp2[N];\n\nvector<ll> merge(const vector<ll> &dp, const vector<ll> &ch1, const vector<ll> &ch2, bool flag) {\n  vector<ll> res(dp.size() + ch1.size(), oo);\n  for (int i = 0; i < (int)dp.size(); ++i) {\n    for (int j = 0; j < (int)ch1.size(); ++j) {\n      if (i + j - 1) {\n        if (ch1[j] != oo) res[i + j - 1] = min(res[i + j - 1], dp[i] + ch1[j]);\n        if (ch2[j] != oo && !flag) res[i + j - 1] = min(res[i + j - 1], dp[i] + ch2[j]);\n      }\n      if (ch1[j] != oo) res[i + j] = min(res[i + j], dp[i]);\n      if (ch2[j] < 0) res[i + j] = min(res[i + j], dp[i]);\n    }\n  }\n  return res;\n}\n\nvoid dfs(int u, int p) {\n  dp1[u].emplace_back(oo);\n  dp1[u].emplace_back(A[u] > 0 ? A[u] : oo);\n  dp2[u].emplace_back(oo);\n  dp2[u].emplace_back(A[u]);\n  for (int v: adj[u]) {\n    if (v == p) continue;\n    dfs(v, u);\n    dp1[u] = merge(dp1[u], dp1[v], dp2[v], true);\n    dp2[u] = merge(dp2[u], dp1[v], dp2[v], false);\n  }\n}\n\nint main() {\n  ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n  cin >> n;\n  for (int i = 1; i <= n; ++i) cin >> A[i];\n  for (int i = 1, u, v; i < n; ++i) {\n    cin >> u >> v;\n    adj[u].emplace_back(v);\n    adj[v].emplace_back(u);\n  }\n  dfs(1, -1);\n  for (int k = 1; k <= n; ++k) {\n    if (dp1[1][k] != oo || dp2[1][k] < 0) {\n      cout << (k - 1);\n      return 0;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <string>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\n\n\nconst int SZ = 5003;\nint N;\nll A[SZ];\nvector<int> adj[SZ];\nvector<int> children[SZ];\nint tsz[SZ];\n\nvoid readInput() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\tcin >> N;\n\tfor (int i=1; i<=N; i++) cin >> A[i];\n\tfor (int z=0; z<N-1; z++) {\n\t\tint u, v; cin >> u >> v;\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n}\n\nvoid dfs(int p, int u) {\n\ttsz[u] += 1;\n\tfor (int v : adj[u]) if (v != p) {\n\t\tdfs(u, v);\n\t\tchildren[u].push_back(v);\n\t\ttsz[u] += tsz[v];\n\t}\n}\n\n\nll D[SZ][SZ];\nbool E[SZ][SZ];\nvoid solve(int u) {\n\tD[u][0] = A[u];\n\tE[u][0] = A[u] > 0;\n\tif (children[u].empty()) return;\n\tfor (int v : children[u]) solve(v);\n\n\tint sz = 1;\n\tfor (int v : children[u]) {\n\t\tstatic ll DD[SZ];\n\t\tstatic bool EE[SZ];\n\t\tmemset(DD, 1, sizeof(DD));\n\t\tmemset(EE, 0, sizeof(EE));\n\n\t\tfor (int a=0; a<sz; a++) for (int b=0; b<tsz[v]; b++) {\n\t\t\tDD[a+b] = min(DD[a+b], D[u][a]+D[v][b]);\n\t\t\tif (D[v][b]<0 || E[v][b]) DD[a+b+1] = min(DD[a+b+1], D[u][a]);\n\t\t}\n\t\tif (A[u]>0) for (int a=0; a<sz; a++) for (int b=0; b<tsz[v]; b++) {\n\t\t\tif (A[v]>0) EE[a+b] = EE[a+b] || (E[u][a] && E[v][b]);\n\t\t\tif (D[v][b]<0 || E[v][b]) EE[a+b+1] = EE[a+b+1] || E[u][a];\n\t\t}\n\n\t\tsz += tsz[v];\n\t\tmemcpy(D[u], DD, sizeof(D[u]));\n\t\tmemcpy(E[u], EE, sizeof(E[u]));\n\t}\n\n\t/*\n\tprintf(\"[debug]\\n\");\n\tfor (int k=0; k<sz; k++) cout << D[u][k] << \" \";\n\tcout << endl;\n\tfor (int k=0; k<sz; k++) cout << P[u][k] << \" \";\n\tcout << endl;\n\tcout << endl;\n\t*/\n}\n\n\n\nint main() {\n\treadInput();\n\tdfs(-123, 1);\n\tsolve(1);\n\n\tint ans = 1e9;\n\tfor (int k=0; k<N; k++) {\n\t\tif (D[1][k] < 0) ans = min(ans, k);\n\t\tif (E[1][k]) ans = min(ans, k);\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream> \n#include<cstring>\n#include<cstdlib>\n#include<cstdio>\n#include<cmath> \n#include<algorithm>\n#define ll long long \nusing namespace std;\nconst int maxn=5010, inf=1e9+233;\nstruct edge{int too, pre;}e[maxn<<1];\nint n, x, y, tot;\nll f[maxn][maxn][2], g[maxn][2];\nint last[maxn], size[maxn], a[maxn];\n\ntemplate<typename T>\ninline void read(T &k)\n{\n    int f=1; k=0; char c=getchar();\n    while(c<'0' || c>'9') c=='-'&&(f=-1), c=getchar();\n    while(c<='9' && c>='0') k=k*10+c-'0', c=getchar();\n    k*=f;\n}\n\ninline void add(int x, int y) {e[++tot]=(edge){y, last[x]}; last[x]=tot;}\n\nvoid dfs(int x, int fa)\n{\n    size[x]=1;\n\n    if(a[x]>0) f[x][0][0]=a[x];\n    else f[x][0][1]=a[x];\n\n    for(int i=last[x], too;i;i=e[i].pre)\n        if((too=e[i].too)!=fa)\n        {\n            dfs(too, x);\n            memset(g, 0x3f, sizeof(g));\n            for(int j=0;j<size[x];j++)\n            {\n                for(int k=0;k<=size[too];k++)\n                {\n                    if(a[x]>0)\n                    {\n                        g[j+k][0]=min(g[j+k][0], f[x][j][0]+f[too][k][0]);\n                        g[j+k][1]=min(g[j+k][1], f[x][j][1]+min(f[too][k][0], f[too][k][1]));\n                        g[j+k][1]=min(g[j+k][1], min(f[x][j][0], f[x][j][1])+f[too][k][1]);\n                        // if(x==2) printf(\"x:%d too:%d j:%d k:%d f[too][k][1]:%lld g:%lld\\n\", x, too, j, k, f[too][k][1], g[j+k][1]);\n                    }\n                    else g[j+k][1]=min(g[j+k][1], f[x][j][1]+min(f[too][k][1], f[too][k][0]));\n                }\n            }\n            memcpy(f[x], g, sizeof(g));\n            size[x]+=size[too];\n        }\n\n    for(int i=0;i<size[x];i++) if(f[x][i][1]<0) f[x][i+1][0]=min(f[x][i+1][0], 0ll);//, printf(\"x:%d qaq\\n\", x);\n    for(int i=0;i<size[x];i++) if(f[x][i][0]<=(ll)(1e13)) f[x][i+1][0]=min(f[x][i+1][0], 0ll);//, printf(\"x:%d qwq\\n\", x);\n}\n\nint main()\n{\n    read(n);\n    for(int i=1;i<=n;i++) read(a[i]);\n    for(int i=1;i<n;i++)\n        read(x), read(y), add(x, y), add(y, x);\n\n    memset(f, 0x3f, sizeof(f));\n    dfs(1, 0);\n\n    for(int i=0;i<n;i++)\n        if(f[1][i][0]<=(ll)(1e13) || f[1][i][1]<0) return printf(\"%d\\n\", i), 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define mp make_pair\n#define X first\n#define Y second\n#define FOE(x, a) for(auto x : a)\n#define FOR(i, a, b) for(int i = a; i <= b; i++)\n#define FOD(i, a, b) for(int i = a; i >= b; i--)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int, int> ii;\n\nconst int N = 5010;\nconst ll INF = 1e18;\n\nint n, a[N];\nvector <int> adj[N];\n\nint sz[N];\nll f[N][N], g[N][N]; /// f : sum; g : min\nll tmpF[N], tmpG[N];\n\nvoid dfs(int u, int p){\n    f[u][0] = g[u][0] = a[u];\n    sz[u] = 1;\n\n    for(int v : adj[u])\n        if (v != p){\n            dfs(v, u);\n            FOR(i, 0, sz[u] + sz[v] - 1){\n                tmpF[i] = INF;\n                tmpG[i] = -INF;\n            }\n            FOR(x, 0, sz[u] - 1)\n                FOR(y, 0, sz[v] - 1){\n                    tmpF[x + y] = min(tmpF[x + y], f[u][x] + f[v][y]);\n                    tmpG[x + y] = max(tmpG[x + y], min(g[u][x], g[v][y]));\n                    if (f[v][y] < 0 || g[v][y] > 0){\n                        tmpF[x + y + 1] = min(tmpF[x + y + 1], f[u][x]);\n                        tmpG[x + y + 1] = max(tmpG[x + y + 1], g[u][x]);\n                    }\n                }\n\n            sz[u] += sz[v];\n            FOR(i, 0, sz[u] - 1){\n                f[u][i] = tmpF[i];\n                g[u][i] = tmpG[i];\n            }\n        }\n}\n\nint main(){\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    cin >> n;\n    FOR(i, 1, n)\n        cin >> a[i];\n    FOR(i, 1, n - 1){\n        int u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    dfs(1, -1);\n    int ans = n - 1;\n    FOR(i, 0, n - 1)\n        if (f[1][i] < 0 || g[1][i] > 0)\n            ans = min(ans, i);\n\n    cout << ans;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,a,b) for(int i=(a);i<(b);i++)\n#define pb push_back\n#define eb emplace_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n\nusing vint=vector<int>;\nusing pint=pair<int,int>;\nusing vpint=vector<pint>;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\ntemplate<class A,class B>\nostream& operator<<(ostream& ost,const pair<A,B>&p){\n\tost<<\"{\"<<p.first<<\",\"<<p.second<<\"}\";\n\treturn ost;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& ost,const vector<T>&v){\n\tost<<\"{\";\n\tfor(int i=0;i<v.size();i++){\n\t\tif(i)ost<<\",\";\n\t\tost<<v[i];\n\t}\n\tost<<\"}\";\n\treturn ost;\n}\n\nconst int INF=1001001001;\nint N;\nint A[5555];\n\nvint G[5555];\nint dp[5010][5010];\nint dp2[5010];\nint sz[5010];\n\nint tmp[5010];\nvoid dfs(int v,int p){\n\tsz[v]=1;\n\n\tif(A[v]>0){\n\t\tdp2[v]=1;\n\t\tdp[v][1]=A[v];\n\t}\n\telse{\n\t\tdp2[v]=INF;\n\t\tdp[v][1]=A[v];\n\t}\n\tfor(auto u:G[v]){\n\t\tif(u==p)continue;\n\t\tdfs(u,v);\n\t\tint mi=dp2[u]-1;\n\t\tfor(int i=1;i<=sz[u];i++)if(dp[u][i]<0)chmin(mi,i);\n\t\tdp2[v]+=mi;\n\n\t\tfor(int i=1;i<=sz[v]+sz[u];i++)tmp[i]=INF;\n\t\tfor(int i=1;i<=sz[v];i++){\n\t\t\tfor(int j=1;j<=sz[u];j++){\n\t\t\t\tchmin(tmp[i+j-1],dp[v][i]+dp[u][j]);\n\t\t\t}\n\t\t\tif(dp2[u]<=N)chmin(tmp[i+dp2[u]],dp[v][i]);\n\t\t}\n\n\t\tsz[v]+=sz[u];\n\t\tfor(int i=1;i<=sz[v];i++)dp[v][i]=tmp[i];\n\t}\n}\nsigned main(){\n\tcin>>N;\n\trep(i,N)cin>>A[i];\n\trep(i,N-1){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\ta--;b--;\n\t\tG[a].pb(b);G[b].pb(a);\n\t}\n\t\n\tdfs(0,-1);\n\n\tint ans=dp2[0];\n\tfor(int i=1;i<=N;i++)if(dp[0][i]<0)chmin(ans,i);\n\tcout<<ans-1<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n\nunsigned long long int getCycle()\n{\n  unsigned int low, high;\n  __asm__ volatile (\"rdtsc\" : \"=a\" (low), \"=d\" (high));\n  return ((unsigned long long int)low) | ((unsigned long long int)high << 32);\n}\n\n\nint dead[5050][5050];\n\nvector<ll> a;\nint mi = 0;\nint sc = 0;\nint d[5050];\n\nvector<int> g[5050];\n\nint dfs(int root){\n  if( d[root]++ ) return 0;\n  sc += a[root];\n  mi = min<int>(mi, a[root]);\n  for( auto &&i : g[root]){\n    if( dead[i][root] == 0 ) dfs(i);\n  }\n}\n\nint nn;\nint check(bool dbg=false){\n  memset(d, 0, sizeof(d));\n  for(int i = 0 ; i < nn ; i++){\n    if( d[i] ) continue;\n    mi = 0;\n    sc = 0;\n    dfs(i);\n    if(dbg)cout << mi << \" \" << sc << endl;\n    if( mi == 0 ) continue;\n    if( sc < 0 ) continue;\n    return false;\n  }\n  return true;\n}\nvoid solve(long long N, vector<long long> A, vector<long long> U,\n           vector<long long> V) {\n  a = A;\n  nn = N;\n  rep(i, N-1){\n    U[i]--, V[i]--;\n    g[U[i]].push_back(V[i]), g[V[i]].push_back(U[i]);\n    dead[U[i]][V[i]] = dead[V[i]][U[i]] = true;\n  }\n  int cnt = N - 1;\n  int mi = cnt;\n  for(int o = 0 ; o < 20000 ; o++){\n    int i = rand() % U.size();\n    cnt -= dead[U[i]][V[i]] == 1;\n    cnt += dead[U[i]][V[i]] == 0;\n    dead[U[i]][V[i]] ^= 1;\n    dead[V[i]][U[i]] ^= 1;\n\n\n    if( check() ){\n      if( mi > cnt ) {\n        mi = cnt;\n        //cout << check(true) << endl;\n        //cout << \"OK\" << \" \" << cnt << endl;\n      }\n    }\n  }\n  cout << mi << endl;\n\n}\n\n\n\n\nint main() {\n\n  long long N;\n  scanf(\"%lld\", &N);\n  vector<long long> A(N);\n  for (int i = 0; i < N; i++) {\n    scanf(\"%lld\", &A[i]);\n  }\n  vector<long long> U(N - 1);\n  vector<long long> V(N - 1);\n  for (int i = 0; i < N - 1; i++) {\n    scanf(\"%lld\", &U[i]);\n    scanf(\"%lld\", &V[i]);\n  }\n  solve(N, A, U, V);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream> \n#include<cstring>\n#include<cstdlib>\n#include<cstdio>\n#include<cmath> \n#include<algorithm>\n#define ll long long \nusing namespace std;\nconst int maxn=5010, inf=1e9+233;\nstruct edge{int too, pre;}e[maxn<<1];\nint n, x, y, tot;\nll f[maxn][maxn][2], g[maxn][2];\nint last[maxn], size[maxn], a[maxn];\n\ntemplate<typename T>\ninline void read(T &k)\n{\n    int f=1; k=0; char c=getchar();\n    while(c<'0' || c>'9') c=='-'&&(f=-1), c=getchar();\n    while(c<='9' && c>='0') k=k*10+c-'0', c=getchar();\n    k*=f;\n}\n\ninline void add(int x, int y) {e[++tot]=(edge){y, last[x]}; last[x]=tot;}\n\nvoid dfs(int x, int fa)\n{\n    // printf(\"x:%d fa:%d\\n\", x, fa);\n    size[x]=1;\n\n    if(a[x]>0) f[x][0][0]=a[x];\n    else f[x][0][1]=a[x];\n\n    // if(x==5) printf(\"x:%d f[x][0][1]:%lld\\n\", x, f[x][0][1]);\n\n    for(int i=last[x], too;i;i=e[i].pre)\n        if((too=e[i].too)!=fa)\n        {\n            dfs(too, x);\n            memset(g, 0x3f, sizeof(g));\n            for(int j=0;j<size[x];j++)\n            {\n                for(int k=0;k<=size[too];k++)\n                {\n                    if(a[x]>0)\n                    {\n                        g[j+k][0]=min(g[j+k][0], f[x][j][0]+f[too][k][0]);\n                        g[j+k][1]=min(g[j+k][1], f[x][j][1]+min(f[too][k][0], f[too][k][1]));\n                        g[j+k][1]=min(g[j+k][1], min(f[x][j][0], f[x][j][1])+f[too][k][1]);\n                        // if(x==2) printf(\"x:%d too:%d j:%d k:%d f[too][k][1]:%lld g:%lld\\n\", x, too, j, k, f[too][k][1], g[j+k][1]);\n                    }\n                    else g[j+k][1]=min(g[j+k][1], f[x][j][1]+min(f[too][k][1], f[too][k][0]));\n                }\n            }\n            memcpy(f[x], g, sizeof(g));\n            size[x]+=size[too];\n            // printf(\"x:%d size[x]:%d size[too]:%d\\n\", x, size[x], size[too]);\n            // if(x==5) printf(\"x:%d f[x][1][1]:%lld f[x][2][1]:%lld\\n\", x, f[x][1][1], f[x][2][1]);\n        }\n\n    for(int i=0;i<size[x];i++) if(f[x][i][1]<0) f[x][i+1][0]=min(f[x][i+1][0], 0ll);//, printf(\"x:%d qaq\\n\", x);\n    for(int i=0;i<size[x];i++) if(f[x][i][0]<=(ll)(1e13)) f[x][i+1][0]=min(f[x][i+1][0], 0ll);//, printf(\"x:%d qwq\\n\", x);\n        // printf(\"x:%d size[x]:%d f[x][size[x]][0]:%lld\\n\", x, size[x], f[x][size[x]][0]);\n    // if(x==5) printf(\"x:%d f[x][2][1]:%lld f1:%lld f2:%lld\\n\", x, f[x][2][1], f[6][1][0], f[7][1][0]);\n}\n\nint main()\n{\n    read(n);\n    for(int i=1;i<=n;i++) read(a[i]);\n    for(int i=1;i<n;i++)\n        read(x), read(y), add(x, y), add(y, x);\n\n    memset(f, 0x3f, sizeof(f));\n    dfs(1, 0);\n\n    // printf(\"f[4][1][0]:%lld f[5][1][0]:%lld f[7][3][0]:%lld\\n\", f[4][1][0], f[5][1][0], f[7][3][0]);\n    // printf(\"f:%lld\\n\", f[2][3][1]);\n\n    for(int i=0;i<n;i++)\n        if(f[1][i][0]<=(ll)(1e13) || f[1][i][1]<0) return printf(\"%d\\n\", i), 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5003;\nlong long dp[N][N];\nint a[N];\nint sz[N];\nlong long can[N];\nint num[N];\n\nstruct graph {\n\tint n;\n\tvector<vector<int>> edge;\n\tgraph(int n) : n(n) {\n\t\tedge.resize(n + 1);\n\t}\n\tvoid add(int u,int v) {\n\t\tedge[u].emplace_back(v);\n\t\tedge[v].emplace_back(u);\n\t}\n\tvoid dfs(int u,int p = 0) {\n\t\tsz[u] = 1;\n\t\tdp[u][0] = a[u];\n\t\tfor (auto&v : edge[u]) {\n\t\t\tif (v == p) continue;\n\t\t\tdfs(v,u);\n\t\t\tfor (int i = 0;i < sz[u] + sz[v];++i) can[i] = 1e16;\n\t\t\tif (a[u] > 0) {\n\t\t\t\tint pos ;\n\t\t\t\tif (a[v] > 0) pos = num[v];\n\t\t\t\telse pos = n;\n\t\t\t\tfor (int i = 0;i < sz[v];++i) if (dp[v][i] < 0) {\n\t\t\t\t\tpos =min(pos,i+1);\n\t\t\t\t\tbreak;\n\t\t\t\t} \n\t\t\t\tnum[u] += pos ;\n\t\t\t}\n\t\t\tfor (int i = 0;i < sz[u];++i) {\n\t\t\t\tfor (int j = 0;j < sz[v];++j) {\n\t\t\t\t\tcan[i+j] = min(can[i+j],dp[u][i] + dp[v][j]);\n\t\t\t\t\tif (dp[v][j] < 0) can[i+j+1] = min(can[i+j+1],dp[u][i]);\n\t\t\t\t}\n\t\t\t\tif (a[v] > 0) {\n\t\t\t\t\tcan[i + num[v] + 1] = min(can[i+num[v]+1],dp[u][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsz[u] += sz[v];\n\t\t\tfor (int i = 0;i < sz[u];++i) dp[u][i] = can[i];\n\t\t}\n\t}\n};\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\tcin >> n;\n\tgraph g(n);\n\tfor (int i = 1;i <= n;++i) cin >> a[i];\n\tfor (int i = 1;i < n;++i) {\n\t\tint u,v;\n\t\tcin >> u >> v;\n\t\tg.add(u,v);\n\t}\n\tg.dfs(1);\n\tint pos = n;\n\tif (a[1] > 0) pos = num[1];\n\tfor (int i = 0;i < n;++i) if (dp[1][i] < 0) return cout << min(pos,i),0;\n\tassert(pos != n);\n\tcout << pos;\n}"
  },
  {
    "language": "C++",
    "code": "/* <ik:include(base.hpp)> */\n/* subset of bits/stdc++.h */\n#include<algorithm>\n#include<iomanip>\n#include<iostream>\n#include<map>\n#include<numeric>\n#include<queue>\n#include<vector>\n\nusing namespace std;\n\nusing LL = long long;\nusing ULL = unsigned long long;\n#define int LL\n#define times(n, i)      uptil(0, n, i)\n#define rtimes(n, i)     downto((n) - 1, 0, i)\n#define upto(f, t, i)    for(auto i##0_to = (t), i = decltype(t)(f); i <= i##0_to; i++)\n#define uptil(f, t, i)   for(auto i##0_to = (t), i = decltype(t)(f); i <  i##0_to; i++)\n#define downto(f, t, i)  for(auto i##0_to = decltype(f)(t), i = (f); i >= i##0_to; i--)\n#define downtil(f, t, i) for(auto i##0_to = decltype(f)(t), i = (f); i >  i##0_to; i--)\n#define iter(v) begin(v), end(v)\n#define citer(v) cbegin(v), cend(v)\n#if defined(EBUG) && !defined(ONLINE_JUDGE)\n  #define debug true\n  #define _GLIBCXX_DEBUG\n  #define _LIBCPP_DEBUG 2\n  #define _LIBCPP_DEBUG2 2\n  #define ln << endl\n  #define dd(x) cerr << #x << \" = \" << (x) << \", \"\n  #define ddd(x) cerr << #x << \" = \" << (x) ln\n#else\n  #define debug false\n  #define ln << '\\n'\n  #define dd(x) cerr\n  #define ddd(x) cerr\n#endif\n#define tb << '\\t'\n#define sp << ' '\n#define db dd\n#define dbg ddd\n#if __cplusplus >= 201703L\n  #if debug\n    #define PARABLE execution::par_unseq,\n  #else\n    #define PARABLE execution::seq,\n  #endif\n#else\n  #define PARABLE /* none */\n#endif\n#define CS const\n#define IL inline\n#define RT return\n#define TL template\n#define lambda [&]\n#define foldl accumulate\n#define scanl accumulate\ntypedef struct unit{}unit;\n\nTL<class T> void amax(T&v,const T&a){v=max(v,a);}\nTL<class T> void amin(T&v,const T&a){v=min(v,a);}\n\nnamespace kpl {\n  template<class V, class W>\n  static inline void append(V& v, const W& w) { copy(PARABLE citer(w), back_inserter(v)); }\n\n  template<class V>\n  static inline auto flatten(const V& xss, unsigned reserve_size = 0) {\n    vector<decltype(*begin(*begin(xss)))> ret;\n    ret.reserve(reserve_size);\n    for(const auto& xs : xss) append(ret, xs);\n    ret.shrink_to_fit();\n    return move(ret);\n  }\n\n  template<class I>\n  static inline bool is_in(I x, I l, I r) { /* Of course half-open interval [l,r) is used */\n    return l <= x && x < r;\n  }\n}\n/* <ik:include(util.hpp)> */\n#ifndef __cpp_lib_exchange_function\n  #define __cpp_lib_exchange_function 201304L\n  TL<class T, class U=T> T exchange(T& t, U&& u) {\n    T ret = move(t); t = forward<U>(u); return ret;\n  }\n#endif\n/* </ik:include(util.hpp)> */\n/* <ik:include(mod.hpp)> */\n#ifndef MOD\n#ifdef MOD9\n#define MOD 1000000009\n#elif defined MOD998244353\n#define MOD 998244353\n#else\n#define MOD 1000000007\n#endif\n#endif\n/* <ik:include(power.hpp)> */\nTL<class T> T power(T x,ULL n){T rt(1);while(n){if(n%2)rt*=x;x*=x;n/=2;}RT rt;}\n/* </ik:include(power.hpp)> */\nIL int modulo(int a,int m){a%=m;RT a>=0?a:a+m;}\nTL<ULL mod=MOD>class MInt{\n  /*\n    int with modulo.\n    `mod` must be a prime for `log`.\n    `mod` must be coprime to `val` for `inv` and to `m.val` for `operator/` and `operator/=`.\n  */\n  /*! https://ei1333.github.io/luzhiled/snippets/other/mod-int.html */\npublic:\n  int val;\n  MInt():val(0){}\n  explicit MInt(int v):val(modulo(v,mod)){}\n  MInt&operator+=(CS MInt&m){val+=m.val;if(val>=mod)val-=mod;RT*this;}\n  MInt&operator-=(CS MInt&m){val-=m.val;if(val<0)val+=mod;RT*this;}\n  MInt&operator*=(CS MInt&m){val=val*m.val%mod;RT*this;}\n  MInt&operator/=(CS MInt&m){val=val*m.inv().val%mod;RT*this;}\n  MInt operator+(CS MInt&m)CS{RT MInt(*this)+=m;}\n  MInt operator-(CS MInt&m)CS{RT MInt(*this)-=m;}\n  MInt operator*(CS MInt&m)CS{RT MInt(*this)*=m;}\n  MInt operator/(CS MInt&m)CS{RT MInt(*this)/=m;}\n  MInt operator-()CS{MInt m;m.val=val?mod-val:0;RT m;}\n  bool operator==(CS MInt&m)CS{RT val==m.val;}\n  bool operator!=(CS MInt&m)CS{RT val!=m.val;}\n  //MInt pow(int n)CS{MInt x(*this),rt(1);while(n){if(n%2)rt*=x;x*=x;n/=2;}RT rt;}\n  MInt pow(int n)CS{RT power(*this,n);}\n  MInt inv()CS{int a=val,b=mod,x=1,y=0,t;while(b){t=a/b;swap(b,a-=t*b);swap(y,x-=t*y);}RT(MInt)x;}\n  friend ostream&operator<<(ostream&o,CS MInt<mod>&m){RT o<<m.val;}\n  friend istream&operator>>(istream&i,MInt<mod>&m){int v;i>>v;m=MInt<mod>(v);RT i;}\n};\nusing mint=MInt<>;\n#pragma rab:gsub \\b(\\d+)m\\b mint(\\1)\n/* </ik:include(mod.hpp)> */\n/* <ik:include(vector_usings.hpp)> */\nTL<class T> using vec = vector<T>;\nTL<class T> using vvec = vec<vec<T>>;\n#define VUSE(v,t)using P##v=pair<t,t>;using V##v=vec<t>;using W##v=vvec<t>\nVUSE(I,int);VUSE(M,mint);VUSE(PI,PI);VUSE(PM,PM);\n/* </ik:include(vector_usings.hpp)> */\n/* <ik:include(debug.hpp)> */\nTL<class T>\nIL istream&operator>>(istream&s,vec<T>&v){for(auto&&p:v)s>>p;RT s;}\nTL<class T,class S>\nIL ostream&operator<<(ostream&s,CS pair<T,S>&p){RT s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nTL<class T>\nIL ostream&operator<<(ostream&,CS vec<T>&);\nTL<class T,class S>\nIL ostream&operator<<(ostream&,CS map<T,S>&);\n#define DEFINE_ITER_OUTPUT(s,x,sep){int i=0;for(CS auto&x##0_elem:x){if(i++)s<<sep;s<<x##0_elem;}RT s;}\nTL<class T>\nIL ostream&operator<<(ostream&s,CS vec<T>&v)DEFINE_ITER_OUTPUT(s,v,' ')\nTL<class T,class S>\nIL ostream&operator<<(ostream&s,CS map<T,S>&m)DEFINE_ITER_OUTPUT(s,m,' ')\nTL<class T>\nIL ostream&operator<<(ostream&s,CS vec<vec<T>>&w)DEFINE_ITER_OUTPUT(s,w,'\\n')\nTL<class T,class S>\nIL ostream&operator<<(ostream&s,CS vec<map<T,S>>&v)DEFINE_ITER_OUTPUT(s,v,'\\n')\n/* </ik:include(debug.hpp)> */\n\nvoid solve();\n\nsigned main() {\n  if(debug) {\n    cerr << \"mod = \" << MOD ln;\n  } else {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n  }\n  cout << fixed << setprecision(20);\n  cerr << fixed << setprecision(20);\n\n  solve();\n\n  return 0;\n}\n/* </ik:include(base.hpp)> */\n/* <ik:include(graph.hpp)> */\n\ntemplate<class EdgeVal>\nusing Edge = tuple<EdgeVal, int, int>;\n\ntemplate<class VtxVal, class EdgeVal = unit>\nclass Graph {\nprotected:\n  int nv_, ne_;\npublic:\n  vec<VtxVal> vs;\n  vec<vec<Edge<EdgeVal>>> edges;\n\n  Graph(int nv): nv_(nv), ne_(0), vs(nv), edges(nv) {}\n\n  int nv()CS{RT nv_;}\n  int ne()CS{RT ne_;}\n\n  void add_dedge(int i, int j, const EdgeVal& val) {\n    if(!kpl::is_in(i, 0LL, nv_) || !kpl::is_in(j, 0LL, nv_)) {\n      cerr << \"invalid index: (\" << i << \", \" << j << \") for Graph(nv = \" << nv_ << \")\" ln;\n      exit(1);\n    }\n    edges[i].emplace_back(val, i, j);\n    ++ne_;\n  }\n  typename enable_if<is_default_constructible<EdgeVal>::value,void>::type add_dedge(int i, int j) {\n    add_dedge(i, j, EdgeVal());\n  }\n\n  void add_uedge(int i, int j, const EdgeVal& val) {\n    add_dedge(i, j, val);\n    add_dedge(j, i, val);\n  }\n  typename enable_if<is_default_constructible<EdgeVal>::value,void>::type add_uedge(int i, int j) {\n    add_uedge(i, j, EdgeVal());\n  }\n};\n/* </ik:include(graph.hpp)> */\n/* <ik:include(tree_dp.hpp)> */\n\ntemplate<class T, class VtxVal, class EdgeVal> T tree_dp(\n  const Graph<VtxVal, EdgeVal>& graph, int i,\n  const function<T(int, vec<T>&, int)>& f, int parent = -1\n) {\n  vec<T> ts; ts.reserve(graph.edges[i].size());\n  for(const auto& edge : graph.edges[i]) {\n    int j = get<2>(edge);\n    if(j != parent) ts.push_back(tree_dp(graph, j, f, i));\n  }\n  return f(i, ts, parent);\n}\n/* </ik:include(tree_dp.hpp)> */\nconstexpr int INF = (int)1e9 * 5000 + 1;\n\nVI pyon(WI& ch, int sz, int f) {\n  VI dp(sz, INF), dr(sz);\n  dp[0] = 0;\n  times(ch.size(), i) {\n    swap(dp, dr);\n    fill(iter(dp), INF);\n    times(sz, j) {\n      upto(0, min(j, (int)ch[i].size()/2-1), k) amin(dp[j], ch[i][k * 2 + f] + dr[j - k]);\n    }\n  }\n  return dp;\n}\n\nvoid solve() {\n// NN(A)N-1(UV)\n/* <foxy.memo-area> */\nint N;cin>>N;VI A(N);times(N,Ri_0){cin>>A[Ri_0];}VI U(N-1);VI V(N-1);times(N-1,Ri_0){\ncin>>U[Ri_0];--U[Ri_0];cin>>V[Ri_0];--V[Ri_0];}\n/* </foxy.memo-area> */\n\n  Graph<unit> g(N);\n  times(N-1, i) g.add_uedge(U[i], V[i]);\n\n  VI v = tree_dp<VI>(g, 0, lambda(int i, WI& ch, int _par) {\n    if(debug) cerr << i ln;\n    if(debug) cerr << ch ln;\n    if(ch.size() == 0) {\n      if(debug) cerr << i ln ln;\n      return VI{ A[i] > 0 ? A[i] : INF, A[i], 0, 0 };\n    } else {\n      int sz = 1; for(auto& c : ch) sz += c.size() / 2;\n      VI ret(sz * 2);\n\n      VI p1 = pyon(ch, sz, 0), p2 = pyon(ch, sz, 1);\n\n      times(sz, a) {\n        ret[a * 2] = A[i] > 0 ? p1[a] + A[i] : INF;\n        ret[a * 2 + 1] = p2[a] + A[i];\n        if(a) {\n          if(ret[a * 2 - 2] < INF || ret[a * 2 - 1] < 0) {\n            amin(ret[a * 2], 0ll);\n            amin(ret[a * 2 + 1], 0ll);\n          }\n        }\n      }\n      if(debug) cerr << i ln ln;\n      return ret;\n    }\n  });\n  times(v.size()/2, a) if(v[a * 2] < INF || v[a * 2 + 1] < 0) { cout << a ln; break; }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst long long INF = 1LL << 60;\n\nlong long dp1[5000][5001];\nlong long dp2[5000][5001];\n\nint solve(const vector<vector<int>>& g, const vector<long long>& A, int pos, int prev){\n    int res = 1;\n        if(A[pos] > 0) dp1[pos][1] = A[pos];\n        dp2[pos][1] = A[pos];\n    if(g[pos].size() == 1 && prev != -1) return res;\n    vector<long long> ndp1(g.size()+1), ndp2(g.size()+1);\n    for(auto next : g[pos]){\n        if(next == prev) continue;\n        int size = solve(g, A, next, pos);\n        for(int i=1;i<=res+size;i++) ndp1[i] = ndp2[i] = INF;\n        for(int i=1;i<=size;i++){\n            for(int j=1;j<=res;j++){\n                if(dp1[pos][j] != INF){\n                    if(dp1[next][i] != INF){\n                        ndp1[i+j-1] = min(ndp1[i+j-1], dp1[next][i] + dp1[pos][j]);\n                    }\n                    if(dp1[next][i] != INF || dp2[next][i] < 0){\n                        ndp1[i+j] = min(ndp1[i+j], dp1[pos][j]);\n                    }\n                }\n                ndp2[i+j-1] = min(ndp2[i+j-1], dp2[next][i] + dp2[pos][j]);\n                if(dp1[next][i] != INF || dp2[next][i] < 0){\n                    ndp2[i+j] = min(ndp2[i+j], dp2[pos][j]);\n                }\n            }\n        }\n        res += size;\n        for(int i=0;i<=res;i++){\n            dp1[pos][i] = ndp1[i];\n            dp2[pos][i] = ndp2[i];\n        }\n    }\n    return res;\n}\n\nint main(){\n    int N;\n    while(cin >> N && N){\n        for(int i=0;i<N;i++){\n            for(int j=0;j<=N;j++) dp1[i][j] = dp2[i][j] = INF;\n        }\n        vector<long long> A(N);\n        for(auto& t : A) cin >> t;\n        vector<vector<int>> g(N, vector<int>());\n        for(int i=0;i<N-1;i++){\n            int U, V; cin >> U >> V;\n            --U; --V;\n            g[U].push_back(V);\n            g[V].push_back(U);            \n        }\n        solve(g, A, 0, -1);\n        for(int i=1;i<=N;i++){\n            if(dp1[0][i] != INF || dp2[0][i] < 0){\n                cout << i-1 << endl;\n                break;\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nint n;\nint a[6005];\nint sz[6005];\nint dp[6005][6005][2];\nvector<int> adj[100005];\n\nvoid ddp(int node, int fa)\n{\n\t//cout<<\"AT \"<<node<<endl;\n\tsz[node]=1;\n\tfor(int i=0; i<=n; i++)\n\t{\n\t\tdp[node][i][0]=10000000000000;\n\t\tdp[node][i][1]=10000000000000;\n\t}\n\tif(a[node]>0) dp[node][0][0]=a[node];\n\telse dp[node][0][1]=a[node];\n\tint dp1[6005][2];\n\t\n\tfor(auto i:adj[node])\n\t{\n\t\tif(i==fa) continue;\n\t\tfor(int j=0; j<=n; j++)\n\t\t{\n\t\t\tdp1[j][0]=10000000000000;\n\t\t\tdp1[j][1]=10000000000000;\n\t\t}\n\t\tddp(i, node);\n\t\tfor(int sn=0; sn<sz[node]; sn++)\n\t\t{\n\t\t\tfor(int si=0; si<sz[i]; si++)\n\t\t\t{\n\t\t\t\tdp1[sn+si][0]=min(dp1[sn+si][0], dp[node][sn][0]+dp[i][si][0]);\n\t\t\t\tdp1[sn+si][1]=min(dp1[sn+si][1], min(dp[node][sn][1]+dp[i][si][1], min(dp[node][sn][0]+dp[i][si][1], dp[node][sn][1]+dp[i][si][0])));\n\t\t\t\tif(dp[i][si][1]<0)\n\t\t\t\t{\n\t\t\t\t\tdp1[sn+si+1][0]=min(dp1[sn+si+1][0], dp[node][sn][0]);\n\t\t\t\t\tdp1[sn+si+1][1]=min(dp1[sn+si+1][1], dp[node][sn][1]);\n\t\t\t\t}\n\t\t\t\tif(dp[i][si][0]<10000000000000)\n\t\t\t\t{\n\t\t\t\t\tdp1[sn+si+1][0]=min(dp1[sn+si+1][0], dp[node][sn][0]);\n\t\t\t\t\tdp1[sn+si+1][1]=min(dp1[sn+si+1][1], dp[node][sn][1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j=0; j<=n; j++)\n\t\t{\n\t\t\tdp[node][j][0]=dp1[j][0];\n\t\t\tdp[node][j][1]=dp1[j][1];\n\t\t}\n\t\tsz[node]+=sz[i];\n\t}\n}\n\nsigned main()\n{\n\tcin>>n;\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tcin>>a[i];\n\t}\n\tfor(int i=1; i<n; i++)\n\t{\n\t\tint u, v;\n\t\tcin>>u>>v;\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\tddp(1, 1);\n\tfor(int i=0; i<=n; i++)\n\t{\n\t\tif(dp[1][i][0]<10000000000000||dp[1][i][1]<0)\n\t\t{\n\t\t\t//cout<<dp[1][i][0]<<\" \"<<dp[1][i][1]<<endl;\n\t\t\tcout<<i;\n\t\t\treturn 0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  otera    \n**/\n#include<iostream>\n#include<string> \n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#include<algorithm> \n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<deque>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\n#define int long long\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\ntypedef long double ld;\nconst int inf=1e9+7;\nconst ll INF=1LL<<60 ;\nconst ll mod=1e9+7 ;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<int, int> P;\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define debug(x)  cerr << #x << \" = \" << (x) << endl;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nconst int MAX = 5100;\n\nint n;\nvector<int> a;\nvector<vector<int>> g;\n\nint num[MAX];\nint dp[MAX][MAX][2];\nint sdp[MAX][2];\n\nvoid rec(int v, int p) {\n\tnum[v] = 1;\n\tfor(int nv: g[v]) {\n\t\tif(nv == p) continue;\n\t\trec(nv, v);\n\t\tnum[v] += num[nv];\n\t}\n\n\tfor(int i = 0; i <= num[v]; ++ i) {\n\t\tsdp[i][0] = sdp[i][1] = INF;\n\t}\n\n\tsdp[0][0] = a[v];\n\tif(a[v] > 0) sdp[0][1] = a[v];\n\n\tint cur = 0;\n\tfor(int nv: g[v]) {\n\t\tif(nv == p) continue;\n\t\tfor(int i = cur; i >= 0; -- i) {\n\t\t\tint tmp0 = sdp[i][0], tmp1 = sdp[i][1];\n\t\t\tsdp[i][0] = INF, sdp[i][1] = INF;\n\t\t\tfor(int j = 0; j <= num[nv]; ++ j) {\n\t\t\t\tchmin(sdp[i + j][0], tmp0 + dp[nv][j][0]);\n\t\t\t\tif(dp[nv][j][0] < 0 || dp[nv][j][1] < INF) chmin(sdp[i + j + 1][0], tmp0);\n\t\t\t\tif(a[v] > 0) {\n\t\t\t\t\tchmin(sdp[i + j][1], tmp1 + dp[nv][j][1]);\n\t\t\t\t\tif(dp[nv][j][0] < 0 || dp[nv][j][1] < INF) chmin(sdp[i + j + 1][1], tmp1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcur += num[v];\n\t}\n\n\tfor(int i = 0; i <= num[v]; ++ i) {\n\t\tdp[v][i][0] = sdp[i][0];\n\t\tdp[v][i][1] = sdp[i][1];\n\t}\n}\n\nvoid solve() {\n\tcin >> n;\n\ta.resize(n);\n\trep(i, n) {\n\t\tcin >> a[i];\n\t}\n\tg.assign(n, vector<int>());\n\trep(i, n - 1) {\n\t\tint u, v; cin >> u >> v; \n\t\t-- u, -- v;\n\t\tg[u].pb(v);\n\t\tg[v].pb(u);\n\t}\n\tfor(int i = 0; i < n; ++ i) {\n\t\tfor(int j = 0; j <= MAX; ++ j) {\n\t\t\tdp[i][j][0] = dp[i][j][1] = INF;\n\t\t}\n\t}\n\trec(0, -1);\n\tint ans = n;\n\tfor(int j = n; j >= 0; -- j) {\n\t\tif(dp[0][j][0] < 0) ans = j;\n\t\tif(dp[0][j][1] < INF) ans = j;\n\t}\n\tcout << ans << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n//template\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(a);i>(b);i--)\ntypedef long long int ll;\ntypedef pair<ll, ll> P; typedef pair<ll, P> T;\ntypedef complex<double> com;\nstruct edge { int u, v, cost; };\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\nll gcd(ll a, ll b) { if (!b)return a; else return gcd(b, a % b); }\nconst int inf = INT_MAX / 2; const ll INF = LLONG_MAX / 2;\nint mod = 1e9 + 7; //998244353;\nstruct Mint {\n\tint val;\n\tMint inv() const {\n\t\tunsigned tmp, a = val, b = mod; int x = 1, y = 0;\n\t\twhile (b) tmp = a / b, a -= tmp * b, swap(a, b), x -= tmp * y, swap(x, y);\n\t\treturn Mint(x);\n\t}\npublic:\n\tMint() :val(0) {}\n\tMint(ll x) :val(x >= 0 ? x % mod : x % mod + mod) {}\n\tint mtoi() { return this->val; }\n\tMint pow(ll t) { Mint res = 1; while (t > 0) { if (t & 1) res *= *this; *this *= *this; t >>= 1; }return res; }\n\tMint& operator+=(const Mint& x) { if ((val += x.val) >= mod) val -= mod; return *this; }\n\tMint& operator-=(const Mint& x) { if ((val += mod - x.val) >= mod) val -= mod; return *this; }\n\tMint& operator*=(const Mint& x) { val = (ll)val * x.val % mod; return *this; }\n\tMint& operator/=(const Mint& x) { return *this *= x.inv(); }\n\tbool operator==(const Mint& x) const { return val == x.val; }\n\tbool operator!=(const Mint& x) const { return val != x.val; }\n\tbool operator<(const Mint& x) const { return val < x.val; }\n\tbool operator<=(const Mint& x) const { return val <= x.val; }\n\tbool operator>(const Mint& x) const { return val > x.val; }\n\tbool operator>=(const Mint& x) const { return val >= x.val; }\n\tMint operator-() const { return Mint(-val); }\n\tMint operator+(const Mint& x) const { return Mint(*this) += x; }\n\tMint operator-(const Mint& x) const { return Mint(*this) -= x; }\n\tMint operator*(const Mint& x) const { return Mint(*this) *= x; }\n\tMint operator/(const Mint& x) const { return Mint(*this) /= x; }\n};\nstruct factorial {\n\tvector<Mint> Fact, Finv;\npublic:\n\tfactorial(int maxx) {\n\t\tFact.resize(maxx + 1, Mint(1)); Finv.resize(maxx + 1);\n\t\trep(i, 0, maxx) Fact[i + 1] = Fact[i] * Mint(i + 1);\n\t\tFinv[maxx] = Mint(1) / Fact[maxx];\n\t\trrep(i, maxx, 0) Finv[i - 1] = Finv[i] * Mint(i);\n\t}\n\tMint fact(int n) { return Fact[n]; }\n\tMint finv(int n) { return Finv[n]; }\n\tMint nCr(int n, int r) {\n\t\tif (n < 0 || n < r || r < 0) return Mint(0);\n\t\treturn Fact[n] * Finv[r] * Finv[n - r];\n\t}\n\tMint nPr(int n, int r) {\n\t\tif (n < 0 || n < r || r < 0) return Mint(0);\n\t\treturn Fact[n] * Finv[n - r];\n\t}\n};\nclass UnionFind {\n\tvector<int> par;\npublic:\n\tUnionFind(int n) { par = vector<int>(n, -1); }\n\tint root(int a) {\n\t\tif (par[a] < 0) return a;\n\t\telse return par[a] = root(par[a]);\n\t}\n\tint size(int a) { return -par[root(a)]; }\n\tbool connect(int a, int b) {\n\t\ta = root(a), b = root(b);\n\t\tif (a == b) return false;\n\t\tif (size(a) < size(b)) swap(a, b);\n\t\tpar[a] += par[b], par[b] = a;\n\t\treturn true;\n\t}\n};\nstruct max_flow {\n\tstruct Edge { int to, cap, rev; };\n\tint V; vector<vector<Edge>> G; vector<int> itr, level;\npublic:\n\tmax_flow(int V) : V(V) { G.assign(V, vector<Edge>()); }\n\tvoid add_edge(int from, int to, int cap) {\n\t\tG[from].push_back({ to, cap, (int)G[to].size() });\n\t\tG[to].push_back({ from, 0, (int)G[from].size() - 1 });\n\t}\n\tvoid bfs(int s) {\n\t\tlevel.assign(V, -1); queue<int> q;\n\t\tlevel[s] = 0; q.push(s);\n\t\twhile (!q.empty()) {\n\t\t\tint v = q.front(); q.pop();\n\t\t\tfor (auto& e : G[v]) {\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tq.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t) return f;\n\t\tfor (int& i = itr[v]; i < (int)G[v].size(); ++i) {\n\t\t\tEdge& e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d, G[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint run(int s, int t) {\n\t\tint ret = 0, f;\n\t\twhile (bfs(s), level[t] >= 0) {\n\t\t\titr.assign(V, 0);\n\t\t\twhile ((f = dfs(s, t, inf)) > 0) ret += f;\n\t\t}\n\t\treturn ret;\n\t}\n};\nvector<ll> dijkstra(vector<vector<edge>> Grp, int s) {\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\tvector<ll> dist(Grp.size(), INF); dist[s] = 0; que.push(P(0, s));\n\twhile (!que.empty()) {\n\t\tP p = que.top(); que.pop();\n\t\tint v = p.second; if (dist[v] < p.first) continue;\n\t\trep(i, 0, Grp[v].size()) {\n\t\t\tedge e = Grp[v][i];\n\t\t\tif (dist[e.v] > dist[v] + e.cost) {\n\t\t\t\tdist[e.v] = dist[v] + e.cost;\n\t\t\t\tque.push(P(dist[e.v], e.v));\n\t\t\t}\n\t\t}\n\t} return dist;\n}\nvoid fft(vector<com>& x, bool inv) {\n\tint s = x.size(); if (s == 1) return;\n\tvector<com> even(s / 2), odd(s / 2);\n\trep(i, 0, s / 2)even[i] = x[i * 2], odd[i] = x[i * 2 + 1];\n\tfft(even, inv), fft(odd, inv);\n\tcom w = 1, w_0 = polar(1.0, (inv ? -1 : 1) * 2LL * M_PI / s);\n\trep(i, 0, s)x[i] = even[i % (s / 2)] + w * odd[i % (s / 2)], w *= w_0;\n}\nvoid MultiFunction(vector<int>& a, vector<int>& b) {\n\tint n = a.size(), maxx = 1; while (maxx <= 2 * n)maxx *= 2;\n\tvector<com> x(maxx), y(maxx);\n\trep(i, 0, n) x[i] = com(a[i], 0), y[i] = com(b[i], 0);\n\tfft(x, 0), fft(y, 0); rep(i, 0, maxx) x[i] *= y[i];\n\tfft(x, 1); rep(i, 0, maxx)x[i] /= maxx;\n\ta.resize(2 * n - 1, 0);\n\trep(i, 0, 2 * n - 1)a[i] = (int)(x[i].real() + 0.5);\n}\nll merge_cnt(vector<int> a) {\n\tll n = a.size(), ai = 0, bi = 0, ci = 0, cnt = 0;\n\tif (n <= 1) return 0;\n\tvector<int> b(a.begin(), a.begin() + n / 2);\n\tvector<int> c(a.begin() + n / 2, a.end());\n\tcnt += merge_cnt(b) + merge_cnt(c);\n\twhile (ai < n) {\n\t\tif (bi < b.size() && (ci == c.size() || b[bi] <= c[ci]))a[ai++] = b[bi++];\n\t\telse cnt += n / 2LL - bi, a[ai++] = c[ci++];\n\t}\n\treturn cnt;\n}\n//template end\n\nint n, w[5010];\nvector<vector<int>> g;\nll dp[5010][5010][2];\nint root[5010];\n\nvoid dfs(int u, int pre) {\n\tfor (int v : g[u])if (v != pre)dfs(v, u);\n\tint es = 1; \n\tif (w[u] > 0)dp[u][0][0] = w[u]; else dp[u][0][1] = w[u];\n\tfor (int v : g[u])if (v != pre) {\n\t\tvector<vector<ll>> sub(n);\n\t\trep(i, 0, n)sub[i].resize(2, inf);\n\t\trep(j1, 0, es)rep(j2, 0, root[v])rep(f1, 0, 2)rep(f2, 0, 2) {\n\t\t\tchmin(sub[j1 + j2][f1 | f2], dp[u][j1][f1] + dp[v][j2][f2]);\n\t\t\tif ((f2 && dp[v][j2][f2] < 0) || (!f2 && dp[v][j2][f2] != inf))chmin(sub[j1 + j2 + 1][f1], dp[u][j1][f1]);\n\t\t}\n\t\tes += root[v];\n\t\trep(i, 0, es)dp[u][i][0] = sub[i][0], dp[u][i][1] = sub[i][1];\n\t}\n\troot[u] = es;\n}\n\nint main() {\n\tcin >> n; g.resize(n);\n\trep(i, 0, n) cin >> w[i];\n\trep(i, 0, n - 1) {\n\t\tint u, v; cin >> u >> v; u--; v--;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\trep(i, 0, n)rep(j, 0, n)rep(k, 0, 2)dp[i][j][k] = inf;\n\tdfs(0, -1);\n\tint ans = n;\n\trep(i, 0, n)if (dp[0][i][0] != inf || dp[0][i][1] < 0)chmin(ans, i);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stdio.h>\n#include <vector>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stdlib.h>\n#include <time.h>\n#include <iomanip>\n#include <math.h>\n#include <bitset>\n\nusing namespace std;\n\n#define taskname \"A\"\n#define LL long long \n#define uLL unsigned long long \n#define FOR(i,l,r) for(int i = l; i <= r; ++i)\n#define REP(i,l,r) for(int i = l; i < r; ++i)\n#define FORD(i,r,l) for(int i = r; i >= l; --i)\n#define REPD(i,r,l) for(int i = r; i > l; --i)\n#define sz(x) (int)((x).size())\n#define all(x) (x).begin(), (x).end()\n#define debug(x) { cerr << #x << \" = \" << x << endl; }\n#define sci(x) int x; scanf(\"%d\", &x);\n#define scii(x, y) int x, y; scanf(\"%d %d\", &x, &y);\n#define sciii(x, y, z) int x, y, z; scanf(\"%d %d %d\", &x, &y, &z);\n#define pi pair<int,int>\n#define pii pair<int,pi>\n#define piLL pair<LL,LL>\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define _USE_MATH_DEFINES \n/* M_PI */\n#define SetLength2(a, n, t) a=((t*) calloc(n, sizeof(t))) + (n)/2\n\nconst int maxN = 5001;\nconst LL oo = 1e17 + 11;\n\nint tcases = 1;\n\nint N,M,total = 0,res = 0;\nvector <int> e[maxN];\nint C[maxN];\nLL W[maxN],A[maxN],F[maxN][maxN],f1[maxN],g1[maxN];\nbool G[maxN][maxN];\npiLL tmp[maxN],fg[maxN];\n\nvoid dfs(int u,int p = 0){\n    W[u] = A[u];\n    C[u] = 1;\n    REP(i,0,e[u].size()){\n        int v = e[u][i];\n        if(v == p) continue;\n        dfs(v,u);\n        W[u] += W[v];\n        C[u] += C[v];\n    }\n}\nvoid cal(int u,int p = 0){\n    REP(i,0,e[u].size()){\n        int v = e[u][i];\n        if(v != p) cal(v,u);\n    }\n    //\n    F[u][0] = W[u];\n    if(C[u] == 1) G[u][0] = A[u] > 0;\n    else{\n        REP(i,0,C[u]) f1[i] = oo,g1[i] = 0;\n        f1[0] = 0; g1[0] = 1;\n        \n        REP(k,0,e[u].size()){\n            int v = e[u][k];\n            if(v == p) continue;\n            // cal F[u][i]\n            REP(i,0,C[u]){\n                F[u][i] = oo; G[u][i] = 0;\n                FOR(j,0,min(C[v],i)){\n                    F[u][i] = min(F[u][i],f1[i - j] + F[v][j]);\n                    G[u][i] |= g1[i - j] & G[v][j];\n                }\n            }\n            REP(i,0,C[u]) f1[i] = F[u][i],g1[i] = G[u][i];\n        }\n        REP(i,0,C[u]){\n            F[u][i] += A[u];\n            if(A[u] < 0) G[u][i] = 0;\n        }\n    }\n    REP(i,0,C[u]){\n        if(F[u][i] < 0 || G[u][i]){\n            F[u][i + 1] = min(F[u][i + 1],0LL);\n            G[u][i + 1] = 1;\n        }\n    }\n}\nvoid testcase(){\n\n    cin >> N;\n    FOR(i,1,N) cin >> A[i];\n    \n    REP(i,1,N){\n        scii(u,v);\n        e[u].pb(v);\n        e[v].pb(u);\n    }\n\n    dfs(1);\n\n    int root = 1;\n\n    FOR(i,1,N){\n        FOR(j,0,N) F[i][j] = oo;\n    }\n\n    cal(root);\n    \n    FOR(j,0,N) if(F[root][j] < 0 || G[root][j]){\n        cout << j;\n        return ;\n    }\n}\n\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie();\n    cout.tie();\n    \n    FOR(i,1,tcases) testcase();\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std;\nconst long long inf = 1234567891234567891;\nconst int inf_int = 1012345678;\nint N; vector<int> A, c, commence; vector<vector<int> > G; vector<vector<long long> > dp0, dp1;\nvoid calc_subtree(int pos, int pre) {\n\tfor (int i : G[pos]) {\n\t\tif (i != pre) {\n\t\t\tcalc_subtree(i, pos);\n\t\t\tc[pos] += c[i];\n\t\t}\n\t}\n}\nvoid calc(int pos, int pre) {\n\tdp0[pos].resize(c[pos] + 1, inf); dp0[pos][0] = 0;\n\tdp1[pos].resize(c[pos] + 1, inf);\n\tint sum = 1;\n\tfor (int i : G[pos]) {\n\t\tif (i != pre) {\n\t\t\tcalc(i, pos);\n\t\t\tfor (int j = sum + c[i] - 1; j >= 0; --j) {\n\t\t\t\tdp1[pos][j] = min(min(min(dp0[pos][j], dp1[pos][j]) + dp1[i][0], dp1[pos][j] + dp0[i][0]), inf);\n\t\t\t\tdp0[pos][j] = min(dp0[pos][j] + dp0[i][0], inf);\n\t\t\t\tfor (int k = max(j - sum + 1, 1); k <= c[i] && k <= j; ++k) {\n\t\t\t\t\tdp1[pos][j] = min(dp1[pos][j], min(min(dp0[pos][j - k], dp1[pos][j - k]) + dp1[i][k], dp1[pos][j - k] + dp0[i][k]));\n\t\t\t\t\tdp0[pos][j] = min(dp0[pos][j], dp0[pos][j - k] + dp0[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsum += c[i];\n\t\t}\n\t}\n\tfor (int i = 0; i < c[pos]; ++i) {\n\t\tif (A[pos] > 0) {\n\t\t\tdp0[pos][i] += A[pos];\n\t\t\tdp1[pos][i] += A[pos];\n\t\t}\n\t\telse {\n\t\t\tdp1[pos][i] = min(dp0[pos][i], dp1[pos][i]) + A[pos];\n\t\t\tdp0[pos][i] = inf;\n\t\t}\n\t}\n\tfor (int i = c[pos] - 1; i >= 0; --i) {\n\t\tif (dp0[pos][i] < inf / 2 || dp1[pos][i] < 0) {\n\t\t\tdp0[pos][i + 1] = min(dp0[pos][i + 1], (long long)(0));\n\t\t\tcommence[pos] = i;\n\t\t}\n\t}\n}\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tcin >> N;\n\tA = vector<int>(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> A[i];\n\t}\n\tG = vector<vector<int> >(N);\n\tfor (int i = 0; i < N - 1; ++i) {\n\t\tint u1, u2;\n\t\tcin >> u1 >> u2; --u1, --u2;\n\t\tG[u1].push_back(u2);\n\t\tG[u2].push_back(u1);\n\t}\n\tc = vector<int>(N, 1);\n\tcalc_subtree(0, -1);\n\tdp0.resize(N);\n\tdp1.resize(N);\n\tcommence = vector<int>(N, inf_int);\n\tcalc(0, -1);\n\tcout << commence[0] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nconst ll INF=1e18;\nint n;\nll a[5001];\nvector<int> g[5001];\nvector<ll> dp[2][5001];\nint dp2[5001];\n//int ans[5001];\nbool used[5001];\nint ct[5001];\nll sum[5001];\nvoid dfs(int x){\n\tused[x]=1;\n\tvector<int> c;\n\tct[x]=1;\n\tsum[x]=a[x];\n\tfor(auto y:g[x]){\n\t\tif(used[y]){\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(y);\n\t\tct[x]+=ct[y];\n\t\tsum[x]+=sum[y];\n\t\tc.push_back(y);\n\t}\n\tfor(int i=0; i<=ct[x]; i++) dp[0][x].push_back(INF), dp[1][x].push_back(INF);\n\tdp[0][x][1]=a[x];\n\tint ct0=1;\n\tfor(auto y:c){\n\t\t//dp[1][x].clear();\n\t\tfor(int i=0; i<=ct0+ct[y]; i++) dp[1][x][i]=INF;\n\t\tfor(int i=ct0; i>=1; i--){\n\t\t\tfor(int j=1; j<=ct[y]; j++){\n\t\t\t\tdp[1][x][i+j-1]=min(dp[1][x][i+j-1], dp[0][x][i]+dp[0][y][j]);\n\t\t\t\tif(dp[0][y][j]<0) dp[1][x][i+j]=min(dp[1][x][i+j], dp[0][x][i]);\n\t\t\t}\n\t\t\tif(a[y]>0) dp[1][x][i+dp2[y]]=min(dp[0][x][i], dp[1][x][i+dp2[y]]);\n\t\t}\n\t\tct0+=ct[y];\n\t\tfor(int i=0; i<=ct0; i++) dp[0][x][i]=dp[1][x][i];\n\t}\n\tif(a[x]>0){\n\t\tdp2[x]=1;\n\t\tfor(auto y:c){\n\t\t\tif(a[y]<0){\n\t\t\t\tfor(int j=1; j<=ct[y]; j++){\n\t\t\t\t\tif(dp[0][y][j]<0){\n\t\t\t\t\t\tdp2[x]+=j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tint j1=n+1;\n\t\t\t\tfor(int j=1; j<=ct[y]; j++){\n\t\t\t\t\tif(dp[0][y][j]<0){\n\t\t\t\t\t\tj1=j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp2[x]+=min(j1, dp2[y]-1);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tcin>>n;\n\tfor(int i=0; i<n; i++) cin>>a[i];\n\tfor(int i=0; i<n-1; i++){\n\t\tint u, v; cin>>u>>v;\n\t\tu--; v--;\n\t\tg[u].push_back(v); g[v].push_back(u);\n\t}\n\tdfs(0);\n\tint ans=n;\n\tfor(int i=1; i<=n; i++){\n\t\tif(dp[0][0][i]<0){\n          //cout<<dp[0][0][i]<<endl;\n          //cout<<i<<endl;\n\t\t\tans=min(ans, i);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(a[0]>0) ans=min(ans, dp2[0]);\n\tcout<<ans-1<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <cstdio>\n#include <iomanip>\n#include <fstream>\n#include <cassert>\n#include <cstring>\n#include <unordered_set>\n#include <unordered_map>\n#include <numeric>\n#include <ctime>\n#include <bitset>\n#include <complex>\n#include <chrono>\n#include <random>\n#include <functional>\n\nusing namespace std;\n\n#define int long long\n\nconst int N = 5004;\nconst int INF = 1e18 + 239;\n\nint dp[2][N][N];\nint cdp[2][N][N];\n\nint a[N];\nint sz[N];\nvector<int> g[N];\n\n//dp[0] - pos\n//dp[1] - neg\n\nvoid dfs(int cur, int P) {\n\tsz[cur] = 1;\n\tvector<int> sons;\n\tfor (auto t : g[cur]) {\n\t\tif (t != P) {\n\t\t\tdfs(t, cur);\n\t\t\tsz[cur] += sz[t];\n\t\t\tsons.push_back(t);\n\t\t}\n\t}\n\tfor (int i = 0; i <= (int)sons.size(); i++) {\n\t\tfor (int j = 0; j < sz[cur]; j++) {\n\t\t\tcdp[0][i][j] = INF;\n\t\t\tcdp[1][i][j] = INF;\n\t\t}\n\t}\n\tif (a[cur] > 0) {\n\t\tcdp[0][0][0] = a[cur];\n\t\tcdp[1][0][0] = a[cur];\n\t} else {\n\t\tcdp[1][0][0] = a[cur];\n\t}\n\tint psz = 1;\n\tfor (int i = 0; i < (int)sons.size(); i++) {\n\t\tint son = sons[i];\n\t\tfor (int p = 0; p < psz; p++) {\n\t\t\t//0\n\t\t\t{\n\t\t\t\tfor (int n = 0; n < sz[son]; n++) {\n\t\t\t\t\tif (dp[0][son][n] < INF) {\n\t\t\t\t\t\tcdp[0][i + 1][p + n] = min(cdp[0][i + 1][p + n], cdp[0][i][p] + dp[0][son][n]);\n\t\t\t\t\t}\n\t\t\t\t\tif (dp[1][son][n] < 0 || dp[0][son][n] < INF) {\n\t\t\t\t\t\tcdp[0][i + 1][p + n + 1] = min(cdp[0][i + 1][p + n + 1], cdp[0][i][p]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//1\n\t\t\t{\n\t\t\t\tfor (int n = 0; n < sz[son]; n++) {\n\t\t\t\t\tcdp[1][i + 1][p + n] = min(cdp[1][i + 1][p + n], cdp[1][i][p] + dp[1][son][n]);\n\t\t\t\t\tif (dp[0][son][n] < INF) {\n\t\t\t\t\t\tcdp[1][i + 1][p + n] = min(cdp[1][i + 1][p + n], cdp[1][i][p] + dp[0][son][n]);\n\t\t\t\t\t}\n\t\t\t\t\tif (dp[1][son][n] < 0 || dp[0][son][n] < INF) {\n\t\t\t\t\t\tcdp[1][i + 1][p + n + 1] = min(cdp[1][i + 1][p + n + 1], cdp[1][i][p]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpsz += sz[son];\n\t}\n\tfor (int i = 0; i < sz[cur]; i++) {\n\t\tdp[0][cur][i] = cdp[0][sons.size()][i];\n\t\tdp[1][cur][i] = cdp[1][sons.size()][i];\n\t}\n}\n\nsigned main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t}\n\tfor (int i = 0; i + 1 < n; i++) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--;\n\t\tv--;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\tdfs(0, -1);\n\tint ans = n;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (dp[0][0][i] != INF) {\n\t\t\tans = min(ans, i);\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tif (dp[1][0][i] < 0) {\n\t\t\tans = min(ans, i);\n\t\t}\n\t}\n\tcout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std;\nconst long long inf = 1234567891234567891;\nconst int inf_int = 1012345678;\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tint N;\n\tcin >> N;\n\tvector<int> A(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> A[i];\n\t}\n\tvector<vector<int> > G(N);\n\tfor (int i = 0; i < N - 1; ++i) {\n\t\tint u1, u2;\n\t\tcin >> u1 >> u2; --u1, --u2;\n\t\tG[u1].push_back(u2);\n\t\tG[u2].push_back(u1);\n\t}\n\tvector<int> c(N, 1);\n\tfunction<void(int, int)> calc_subtree = [&](int pos, int pre) {\n\t\tfor (int i : G[pos]) {\n\t\t\tif (i != pre) {\n\t\t\t\tcalc_subtree(i, pos);\n\t\t\t\tc[pos] += c[i];\n\t\t\t}\n\t\t}\n\t};\n\tcalc_subtree(0, -1);\n\tvector<vector<long long> > dp0(N), dp1(N);\n\tvector<int> commence(N, inf_int);\n\tfunction<void(int, int)> calc = [&](int pos, int pre) {\n\t\tdp0[pos].resize(c[pos] + 1, inf); dp0[pos][0] = 0;\n\t\tdp1[pos].resize(c[pos] + 1, inf);\n\t\tint sum = 1;\n\t\tfor (int i : G[pos]) {\n\t\t\tif (i != pre) {\n\t\t\t\tcalc(i, pos);\n\t\t\t\tfor (int j = sum + c[i] - 1; j >= 0; --j) {\n\t\t\t\t\tdp1[pos][j] = min(min(min(dp0[pos][j], dp1[pos][j]) + dp1[i][0], dp1[pos][j] + dp0[i][0]), inf);\n\t\t\t\t\tdp0[pos][j] = min(dp0[pos][j] + dp0[i][0], inf);\n\t\t\t\t\tfor (int k = 1; k <= c[i] && k <= j; ++k) {\n\t\t\t\t\t\tdp1[pos][j] = min(dp1[pos][j], min(min(dp0[pos][j - k], dp1[pos][j - k]) + dp1[i][k], dp1[pos][j - k] + dp0[i][k]));\n\t\t\t\t\t\tdp0[pos][j] = min(dp0[pos][j], dp0[pos][j - k] + dp0[i][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsum += c[i];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < c[pos]; ++i) {\n\t\t\tif (A[pos] > 0) {\n\t\t\t\tdp0[pos][i] += A[pos];\n\t\t\t\tdp1[pos][i] += A[pos];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp1[pos][i] = min(dp0[pos][i], dp1[pos][i]) + A[pos];\n\t\t\t\tdp0[pos][i] = inf;\n\t\t\t}\n\t\t}\n\t\tfor (int i = c[pos] - 1; i >= 0; --i) {\n\t\t\tif (dp0[pos][i] < inf / 2 || dp1[pos][i] < 0) {\n\t\t\t\tdp0[pos][i + 1] = min(dp0[pos][i + 1], (long long)(0));\n\t\t\t\tcommence[pos] = i;\n\t\t\t}\n\t\t}\n\t};\n\tcalc(0, -1);\n\tcout << commence[0] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n\nint n;\nll a[5005],dp[5005][5005],dppos[5005];\nint sub[5005];\nvector<int>edge[5005];\nll t[2][5005];\nvoid dfs(int v,int u){\n\tsub[v] = 1;\n\trep(i,edge[v].size()){\n\t\tint to = edge[v][i];\n\t\tif(to == u) continue;\n\t\tdfs(to,v);\n\t}\n\tint cur = 0, nxt = 1;\n\t//dp[][]\n\trep(i,2)rep(j,5005) t[i][j] = 1e18;\n\tt[0][0] = 0;\n\trep(i,edge[v].size()){\n\t\tint to = edge[v][i];\n\t\tif(to == u) continue;\n\t\trep(i,sub[v]+sub[to]) t[nxt][i] = 1e18;\n\t\trep(i,sub[v]){\n\t\t\tif(t[cur][i] > 5e17) continue;\n\t\t\trepn(j,sub[to]){\n\t\t\t\t//cut\n\t\t\t\tif(dp[to][j] < 0){\n\t\t\t\t\tt[nxt][i+j] = min(t[nxt][i+j], t[cur][i]);\n\t\t\t\t}\n\t\t\t\t//cut2\n\t\t\t\tif(dppos[to] <= n){\n\t\t\t\t\tt[nxt][i+dppos[to]] = min(t[nxt][i+dppos[to]], t[cur][i]);\n\t\t\t\t}\n\t\t\t\t//connect\n\t\t\t\tt[nxt][i+j-1] = min(t[nxt][i+j-1], dp[to][j]+t[cur][i]);\n\t\t\t}\n\t\t}\n\t\tsub[v] += sub[to];\n\t\tswap(cur,nxt);\n\t}\n\trep(i,sub[v]) dp[v][i+1] = t[cur][i]+a[v];\n\tif(a[v] > 0){\n\t\tdppos[v] = 1;\n\t\t//dppos[]\n\t\trep(i,edge[v].size()){\n\t\t\tint to = edge[v][i];\n\t\t\tif(to == u) continue;\n\t\t\tll add = INF;\n\t\t\t{\n\t\t\t\trepn(j,sub[to]){\n\t\t\t\t\t//cut\n\t\t\t\t\tif(dp[to][j] < 0){\n\t\t\t\t\t\tadd = min(add,1LL*j);\n\t\t\t\t\t}\n\t\t\t\t\t//cut2\n\t\t\t\t\tif(dppos[to] <= n){\n\t\t\t\t\t\tadd = min(add,dppos[to]);\n\t\t\t\t\t}\n\t\t\t\t\t//connect\n\t\t\t\t\tif(dppos[to] <= n){\n\t\t\t\t\t\tadd = min(add,dppos[to]-1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdppos[v] += add;\n\t\t}\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\trepn(i,n) scanf(\"%lld\",&a[i]);\n\trep(i,n-1){\n\t\tint a,b; scanf(\"%d%d\",&a,&b);\n\t\tedge[a].pb(b);\n\t\tedge[b].pb(a);\n\t}\n\trep(i,5005)rep(j,5005){\n\t\tdp[i][j] = 1e18;\n\t\tdppos[i] = 1e18;\n\t}\n\tdfs(1,-1);\n\tll ans = dppos[1];\n\tfor(int j=0;j<5005;j++){\n\t\tif(dp[1][j] < 0){\n\t\t\tans = min(ans,1LL*j);\n\t\t\tbreak;\n\t\t}\n\t}\n\tcout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;using ll=long long;using uint=unsigned int;using pii=pair<int,int>;using pll=pair<ll,ll>;using ull = unsigned long long;using ld=long double;template<typename T>void _(const char*s,T h){cerr<<s<<\" = \"<<h<<\"\\n\";}template<typename T,typename...Ts>void _(const char*s,T h,Ts...t){int b=0;while(((b+=*s=='(')-=*s==')')!=0||*s!=',')cerr<<*s++;cerr<<\" = \"<<h<<\",\";_(s+1,t...);}// break continue pop_back 998244353\n#define int ll\n#define pii pll\n#define f first\n#define s second\n#define pb emplace_back\n#define forn(i,n) for(int i=0;i<(n);++i)\n#define sz(a)((int)(a).size())\n#define sqr(x) ((x)*(x))\nstruct init{init(){cin.tie(0);iostream::sync_with_stdio(0);cout<<fixed<<setprecision(10);cerr<<fixed<<setprecision(5);}~init(){\n#ifdef LOCAL\n#define dbg(...) _(#__VA_ARGS__,__VA_ARGS__)\ncerr<<\"Time elapsed: \"<<(double)clock()/CLOCKS_PER_SEC<<\"s.\\n\";\n#else\n#define dbg(...) \n#endif\n}}init;template<typename T,typename U>void upx(T&x,U y){if(x<y)x=y;}template<typename T,typename U>void upn(T&x,U y){if(x>y)x=y;}mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());const int D=4,dx[]={+1,0,-1,0},dy[]={0,+1,0,-1};\nconst int N=5001,OO=1e18;\nint dp[N][N],ba[N][N];\nint a[N];\nvector<int> g[N];\nint sz[N],dv[N],du[N],dt[N];\nvoid dfs(int v,int p=0){\n    sz[v]=1;\n    for(int to:g[v]){\n        if(to^p){\n            dfs(to,v);\n            sz[v]+=sz[to];\n        }\n    }\n    // forn(i,sz[v])dp[v][i]=ba[v][i]=OO;\n    {\n        int maxv=0;\n        forn(i,N)dv[i]=OO;\n        dv[0]=0;\n        for(int to:g[v]){\n            if(to^p){\n                int maxto=sz[to];\n                forn(i,maxv+maxto+2)dt[i]=OO;\n                forn(i,maxto+1){\n                    du[i]=dp[to][i];\n                    if(i&&du[i-1]<0)upn(du[i],0);\n                    if(i&&a[to]>0&&ba[to][i-1])upn(du[i],0);\n                }\n                forn(i,maxv+1){\n                    forn(j,maxto+1){\n                        upn(dt[i+j],dv[i]+du[j]);\n                    }\n                }\n                forn(i,maxv+maxto+2)dv[i]=dt[i];\n                maxv+=maxto;\n            }\n        }\n        forn(i,sz[v])dp[v][i]=dv[i]+a[v];\n    }\n    if(a[v]>0){\n        int maxv=0;\n        forn(i,N)dv[i]=0;\n        dv[0]=1;\n        for(int to:g[v]){\n            if(to^p){\n                int maxto=sz[to];\n                forn(i,maxv+maxto+2)dt[i]=0;\n                forn(i,maxto+1){\n                    if(a[to]>0){\n                        du[i]=ba[to][i];\n                        if(i)du[i]|=ba[to][i-1];\n                        if(i)du[i]|=dp[to][i-1]<0;\n                    }else{\n                        du[i]=0;\n                        if(i)du[i]=dp[to][i-1]<0;\n                    }\n                }\n                // if(v==3){\n                //     dbg(to);\n                //     forn(i,maxv+1)dbg(i,dv[i]);\n                //     forn(i,maxto+1)dbg(i,du[i]);\n                // }\n                forn(i,maxv+1){\n                    forn(j,maxto+1){\n                        dt[i+j]|=dv[i]&du[j];\n                    }\n                }\n                forn(i,maxv+maxto+2)dv[i]=dt[i];\n                maxv+=maxto;\n            }\n        }\n        forn(i,sz[v])ba[v][i]=dv[i];\n    }else{\n        // forn(i,sz[v])if(dp[v][i]<0)ba[v][i]=1;\n    }\n    dbg(v,a[v]);\n    forn(i,sz[v])dbg(dp[v][i],ba[v][i]);\n    dbg(\"=====\");\n}\nint32_t main(){\n    int n;\n    cin>>n;\n    for(int i=1;i<=n;++i)cin>>a[i];\n    forn(i,n-1){\n        int x,y;\n        cin>>x>>y;\n        g[x].pb(y);\n        g[y].pb(x);\n    }\n    dfs(1);\n    int ans=N;\n    forn(i,n){\n        if(a[1]>0&&ba[1][i]){\n            ans=i;\n            break;\n        }\n        if(dp[1][i]<0){\n            ans=i;\n            break;\n        }\n    }\n    cout<<ans<<'\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fr(i,n) for(int i=0;i<(n);++i)\n#define foor(i,a,b) for(int i=(a);i<=(b);++i)\n#define rf(i,n) for(int i=(n);i-->0;)\n#define roof(i,b,a) for(int i=(b);i>=(a);--i)\n#define elsif else if\n#define all(x) x.begin(),x.end()\n#define Sort(x) sort(all(x))\n#define Reverse(x) reverse(all(x))\n#define PQ priority_queue\n#define NP(x) next_permutation(all(x))\n#define M_PI 3.14159265358979323846\n#define popcount __builtin_popcountll\nusing namespace std;            typedef vector<bool> vb; typedef vector<vb>  vvb;\n                                typedef vector<int>  vi; typedef vector<vi>  vvi;\ntypedef long long ll;           typedef vector< ll>  vl; typedef vector<vl>  vvl;\ntypedef unsigned long long ull; typedef vector<ull>  vu; typedef vector<vu>  vvu;\ntypedef double dbl;             typedef vector<dbl>  vd; typedef vector<vd>  vvd;\ntypedef string str;             typedef vector<str>  vs; typedef vector<vs>  vvs;\ntypedef pair<int,int>pii;       typedef vector<pii>vpii; typedef map<int,int>mii;\ntypedef pair< ll, ll>pll;       typedef vector<pll>vpll; typedef map< ll, ll>mll;\ntypedef pair<dbl,dbl>pdd;       typedef vector<pdd>vpdd; typedef map<dbl,dbl>mdd;\ntypedef pair<str,str>pss;       typedef vector<pss>vpss; typedef map<str,str>mss;\ntypedef pair<int, ll>pil;       typedef vector<pil>vpil; typedef map<int, ll>mil;\ntypedef pair< ll,int>pli;       typedef vector<pli>vpli; typedef map< ll,int>mli;\ntypedef pair<dbl,int>pdi;       typedef vector<pdi>vpdi; typedef map<dbl,int>mdi;\ntemplate<typename T>vector<T>&operator<<(vector<T>&v,const T t){v.push_back(t);return v;}\ntemplate<typename T>multiset<T>&operator<<(multiset<T>&m,const T t){m.insert(t);return m;}\ntemplate<typename T>set<T>&operator<<(set<T>&s,const T t){s.insert(t);return s;}\ntemplate<typename T>stack<T>&operator<<(stack<T>&s,const T t){s.push(t);return s;}\ntemplate<typename T>stack<T>&operator>>(stack<T>&s,T&t){t=s.top();s.pop();return s;}\ntemplate<typename T>queue<T>&operator<<(queue<T>&q,const T t){q.push(t);return q;}\ntemplate<typename T>queue<T>&operator>>(queue<T>&q,T&t){t=q.front();q.pop();return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator<<(PQ<T,vector<T>,U>&q,const T t){q.push(t);return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator>>(PQ<T,vector<T>,U>&q,T&t){t=q.top();q.pop();return q;}\ntemplate<typename T,typename U>istream&operator>>(istream&s,pair<T,U>&p){return s>>p.first>>p.second;}\nistream&operator>>(istream&s,_Bit_reference b){int a;s>>a;assert(a==0||a==1);b=a;return s;}\ntemplate<typename T>istream&operator>>(istream&s,vector<T>&v){fr(i,v.size()){s>>v[i];}return s;}\ntemplate<typename T,typename U>ostream&operator<<(ostream&s,const pair<T,U>p){return s<<p.first<<\" \"<<p.second;}\n//template<typename T>ostream&operator<<(ostream&s,const vector<T>v){for(auto a:v){s<<a<<\"\\n\";}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const vector<T>v){fr(i,v.size()){i?s<<\" \"<<v[i]:s<<v[i];}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const deque<T>d){fr(i,d.size()){i?s<<\" \"<<d[i]:s<<d[i];}return s;}\ntemplate<typename T>_Bit_reference operator&=(_Bit_reference b,T t){return b=b&t;}\ntemplate<typename T>_Bit_reference operator^=(_Bit_reference b,T t){return b=b^t;}\ntemplate<typename T>_Bit_reference operator|=(_Bit_reference b,T t){return b=b|t;}\ntemplate<typename T,typename U>pair<T,U>operator+(pair<T,U>a,pair<T,U>b){return {a.first+b.first,a.second+b.second};}\ntemplate<typename T,typename U>pair<T,U>operator-(pair<T,U>a,pair<T,U>b){return {a.first-b.first,a.second-b.second};}\ntemplate<typename T,typename U>pair<T,U>&operator+=(pair<T,U>&a,pair<T,U>b){return a=a+b;}\ntemplate<typename T,typename U>pair<T,U>&operator-=(pair<T,U>&a,pair<T,U>b){return a=a-b;}\nvoid print(void){cout<<\"\\n\";}\nvoid Print(void){cout<<endl;}\ntemplate<typename T>void print(T t){cout<<t<<\"\\n\";}\ntemplate<typename T>void Print(T t){cout<<t<<endl;}\ntemplate<typename T,typename...U>void print(T&&t,U&&...u){cout<<t<<\" \";print(forward<U>(u)...);}\ntemplate<typename T,typename...U>void Print(T&&t,U&&...u){cout<<t<<\" \";Print(forward<U>(u)...);}\nbool YN(bool b){print(b?\"YES\":\"NO\");return b;}bool PI(bool b){print(b?\"POSSIBLE\":\"IMPOSSIBLE\");return b;}\nbool Yn(bool b){print(b?\"Yes\":\"No\");return b;}bool Pi(bool b){print(b?\"Possible\":\"Impossible\");return b;}\nbool yn(bool b){print(b?\"yes\":\"no\");return b;}bool pi(bool b){print(b?\"possible\":\"impossible\");return b;}\nconst int e5=1e5;\nconst int e9=1e9;\nconst int MD=1e9+7;\nconst int md=998244353;\nconst ll e18=1e18;\ntemplate<typename T>str to_string(const T&n){ostringstream s;s<<n;return s.str();}\ntemplate<typename T>T&chmax(T&a,T b){return a=max(a,b);}\ntemplate<typename T>T&chmin(T&a,T b){return a=min(a,b);}\ntemplate<typename T,typename U>vector<pair<T,U>>dijkstra(const vector<vector<pair<T,U>>>&E,const U s,const T inf){using P=pair<T,U>;vector<P>d;fr(i,E.size()){d<<P{inf,i};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\ntemplate<typename T,typename U>map<U,pair<T,U>>dijkstra(map<U,vector<pair<T,U>>>E,const U s,const T inf){using P=pair<T,U>;map<U,P>d;for(pair<U,vector<P>>e:E){d[e.first]=P{inf,e.first};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\nll maxflow(vector<mil>&E,int s,int t){ll z=0;vi b(E.size(),-1);for(int i=0;;++i){static auto dfs=[&](int v,ll f,auto&dfs)->ll{if(v==t)return f;b[v]=i;for(auto&p:E[v]){if(b[p.first]<i&&p.second){if(ll r=dfs(p.first,min(f,p.second),dfs)){p.second-=r;E[p.first][v]+=r;return r;}}}return 0;};ll x=dfs(s,ll(1e18),dfs);z+=x;if(x==0)return z;}}\ntemplate<typename T>T distsq(pair<T,T>a,pair<T,T>b){return (a.first-b.first)*(a.first-b.first)+(a.second-b.second)*(a.second-b.second);}\ntemplate<typename T>T max(const vector<T>a){assert(a.size());T m=a[0];for(T e:a){m=max(m,e);}return m;}\ntemplate<typename T>T min(const vector<T>a){assert(a.size());T m=a[0];for(T e:a){m=min(m,e);}return m;}\ntemplate<typename T>T gcd(const T a,const T b){return a?gcd(b%a,a):b;}\ntemplate<typename T>T gcd(const vector<T>a){T g=a[0];for(T e:a){g=gcd(g,e);}return g;}\ntemplate<typename T>vector<T>LCS(vector<T>A,vector<T>B){int N=A.size(),M=B.size();vector<vector<pair<int,pii>>>d(N+1,vector<pair<int,pii>>(M+1));fr(i,N){fr(j,M){if(A[i]==B[j]){d[i+1][j+1]={d[i][j].first+1,{i,j}};}else{d[i+1][j+1]=max(d[i][j+1],d[i+1][j]);}}}vector<T>r;for(pii p={N,M};d[p.first][p.second].first;p=d[p.first][p.second].second){r<<A[d[p.first][p.second].second.first];}Reverse(r);return r;}\nstr LCS(str S,str T){vector<char>s=LCS(vector<char>(S.begin(),S.end()),vector<char>(T.begin(),T.end()));return str(s.begin(),s.end());}\ntemplate<typename T>vector<pair<T,T>>ConvexHull(vector<pair<T,T>>V){if(V.size()<=3){return V;}Sort(V);rf(i,V.size()-1)V<<V[i];vector<pair<T,T>>r;for(pair<T,T>p:V){int s=r.size();while(s>=2&&(p.second-r[s-1].second)*(p.first-r[s-2].first)<(p.second-r[s-2].second)*(p.first-r[s-1].first)){r.pop_back();--s;}r<<p;}r.pop_back();return r;}\nclass UnionFind{vi p,s;void extend(int N){foor(i,p.size(),N){p<<i;s<<1;}}public:UnionFind(void){}UnionFind(int N){extend(N-1);}int find(int i){extend(i);return p[i]=p[i]==i?i:find(p[i]);}void unite(int a,int b){extend(a);extend(b);if((a=find(a))!=(b=find(b))){if(s[a]>s[b]){swap(a,b);}s[b]+=s[a];p[a]=b;}}void unite(pii p){return unite(p.first,p.second);}bool same(int a,int b){extend(a);extend(b);return find(a)==find(b);}bool same(pii p){return same(p.first,p.second);}int size(int x){extend(x);return s[find(x)];}};\nll MST(vector<pair<ll,pii>>&E){Sort(E);UnionFind uf;ll z=0;for(auto&e:E){if(!uf.same(e.second)){z+=e.first;uf.unite(e.second);}}return z;}\nll strmod(const str&s,const int m){ll x=0;fr(i,s.size()){x=(x*10+s[i]-48)%m;}return x;}\nvvl mul(const vvl&A,const vvl&B,const int m){vvl C;fr(y,A.size()){C<<vl(B[y].size());}fr(y,C.size()){fr(x,C[y].size()){fr(i,A[0].size()){(C[y][x]+=A[y][i]*B[i][x])%=m;}}}return C;}\nvvl pow(const vvl&A,const ll n,const int m){vvl B;fr(y,A.size()){B<<vl(A.size());}if(n==0){fr(i,B.size()){B[i][i]=1;}}elsif(n%2){B=mul(A,pow(A,n-1,m),m);}else{vvl C=pow(A,n/2,m);B=mul(C,C,m);}return B;}\nll pow(const ll a,const ll n,const int m){ll t;return n?(n&1?a>=0?a%m:(m-(-a%m))%m:1)*(t=pow(a,n>>1,m),t*t%m)%m:!!a;}\nll inv(const ll x,const int p){assert(x!=0);return pow(x,p-2,p);}\nll inv(const ll x){return inv(x,MD);}\nvpll fact(const int n,const int p){assert(n<p);vpll v(n+1);v[0].first=1;foor(i,1,n){v[i].first=v[i-1].first*i%p;}v[n].second=inv(v[n].first,p);roof(i,n,1){v[i-1].second=v[i].second*i%p;}return v;}\nclass Combination{const vpll f;const int M;public:Combination(int n,int m):f(fact(n,m)),M(m){}Combination(int n):Combination(n,MD){}ll P(int n,int k){return n<0||k<0||n<k?0ll:f[n].first*f[n-k].second%M;}ll C(int n,int k){return k<0?0:P(n,k)*f[k].second%M;}ll H(int n,int k){return n==0&&k==0?1ll:C(n+k-1,k);}ll F(int n){return n<0?0:f[n].first;}};\nll C2(const int n){return(ll)n*~-n/2;}\nll sum(const vi a){ll s=0;for(int e:a){s+=e;}return s;}\nll sum(const vl a){ll s=0;for(ll e:a){s+=e;}return s;}\ntemplate<typename T>int MSB(T N){int r=-1;for(;N>0;N/=2){++r;}return r;}\ntemplate<typename T>class SegmentTree{vector<T>S;T(*const op)(T a,T b);const T zero;const int B;public:SegmentTree(int N,T(*f)(T a,T b),const T zero):S(1<<MSB(N-1)+2,zero),op(f),zero(zero),B(1<<MSB(N-1)+1){}SegmentTree(vector<T>v,T(*f)(T a,T b),const T zero):SegmentTree(v.size(),f,zero){fr(i,v.size()){S[S.size()/2+i]=v[i];}roof(i,S.size()/2-1,1){S[i]=op(S[i*2],S[i*2+1]);}}T calc(int l,int r){l+=B;r+=B;if(l>r){return zero;}if(l==r){return S[l];}T L=S[l],R=S[r];for(;l/2<r/2;l/=2,r/=2){if(l%2==0){L=op(L,S[l+1]);}if(r%2==1){R=op(S[r-1],R);}}return op(L,R);}void replace(int i,T x){for(S[i+=B]=x;i!=1;i/=2){if(i%2){S[i/2]=op(S[i-1],S[i]);}else{S[i/2]=op(S[i],S[i+1]);}}}void add(int i,T x){replace(i,op(S[B+i],x));}T top(){return S[1];}T get(int i){return S[i+B];}};\nll BITsum(vl&B,int i){ll z=0;while(i>0){z+=B[i];i-=i&-i;}return z;}\nvoid BITadd(vl&B,int i,ll x){while(i<B.size()){B[i]+=x;i+=i&-i;}}\nll fib(const ll n,const int m){ll a,b,c,d,A,B,C,D;a=1;b=0;c=0;d=1;rf(i,63){A=a*a+b*c;B=a*b+b*d;C=c*a+d*c;D=c*b+d*d;if(n>>i&1){a=A;b=B;c=C;d=D;A=a+b;B=a;C=c+d;D=c;}a=A%m;b=B%m;c=C%m;d=D%m;}return b;}\nvi primes(int n){vb b(n+1);vi p;foor(i,2,n){if(!b[i]){p<<i;for(int j=2*i;j<=n;j+=i){b[j]=true;}}}return p;}\nvb isprime(const int n){vb v(n+1,true);v[0]=v[1]=false;foor(i,2,n){if(v[i]){for(int j=2*i;j<=n;j+=i){v[j]=false;}}}return v;}\nclass LCA{vvi par;vi dep;public:LCA(vvi&E,int root):par(MSB(E.size())+1,vi(E.size())),dep(E.size()){function<void(int,int)>dfs=[&](int i,int p){for(int j:E[i])if(j!=p){par[0][j]=i;dep[j]=dep[i]+1;dfs(j,i);}};par[0][root]=root;dfs(root,root);fr(i,par.size()-1){fr(j,par[0].size()){par[i+1][j]=par[i][par[i][j]];}}}int operator()(int a,int b){if(dep[a]>dep[b])swap(a,b);for(int t=dep[b]-dep[a],i=0;t;t>>=1,++i){if(t&1){b=par[i][b];}}if(a==b)return a;rf(i,par.size()){if(par[i][a]!=par[i][b]){a=par[i][a];b=par[i][b];}}return par[0][a];}};\nvpli factor(ll N){vpli r;for(ll i=2;i*i<=N;++i){if(N%i==0){r<<pli{i,0};while(N%i==0){N/=i;++r.back().second;}}}if(N>1){r<<pli{N,1};}return r;}\nvl divisors(ll n){vl r;ll m=sqrt(n);foor(i,1,m)if(n%i==0)r<<ll(i);rf(i,r.size()-(m*m==n))r<<n/r[i];return r;}\nvi SuffixArray(str S){int N=S.size();vi rank(N+1),tmp(N+1),sa(N+1);fr(i,N){sa[i]=i;rank[i]=S[i];}sa[N]=N;rank[N]=-1;int k;auto cmp=[&](int&a,int&b)->bool{if(rank[a]!=rank[b])return rank[a]<rank[b];return (a+k<=N?rank[a+k]:-1)<(b+k<=N?rank[b+k]:-1);};for(k=1;k<=N;k*=2){sort(all(sa),cmp);tmp[sa[0]]=0;foor(i,1,N){tmp[sa[i]]=tmp[sa[i-1]]+cmp(sa[i-1],sa[i]);}rank=tmp;}return sa;};\n\nint main(){cin.tie(0);ios::sync_with_stdio(false);\n\tint N;cin>>N;\n\tvi V(N);cin>>V;\n\tvvi E(N);\n\t{\n\t\tUnionFind uf;\n\t\tvi A(N-1),B(N-1);\n\t\tfr(i,N-1){\n\t\t\tcin>>A[i]>>B[i];\n\t\t\tint a=--A[i],b=--B[i];\n\t\t\tif(V[a]<0&&V[b]<0){\n\t\t\t\ta=uf.find(a),b=uf.find(b);\n\t\t\t\tint v=V[a]+V[b];\n\t\t\t\tuf.unite(a,b);\n\t\t\t\tV[uf.find(a)]=v;\n\t\t\t\tV[a+b-uf.find(a)]=0;\n\t\t\t}\n\t\t}\n\t\tfr(i,N-1){\n\t\t\tint a=uf.find(A[i]),b=uf.find(B[i]);\n\t\t\tif(a!=b){\n\t\t\t\tE[a]<<b;\n\t\t\t\tE[b]<<a;\n\t\t\t}\n\t\t}\n\t}\n \treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,a) for(int i=0;i<(a);i++)\nconst ll MOD=1000000007;\n\nint N;\nint A[5050],num[5050];\n// dp[v][i]:vの部分木がi個のときの最小\nll dp[5050][5050],dpdp[5050];\n// dp2:バッテリーのみ\nbool dp2[5050][5050],dpdp2[5050];\nvector<vector<int>> G(5050);\nconst ll INF=1e14;\n\nvoid solve(int v,int p){\n  num[v]=1;\n  for(int u:G[v]){\n    if(u==p) continue;\n    solve(u,v);\n    num[v]+=num[u];\n  }\n  fill(dpdp,dpdp+num[v]+1,INF);\n  dpdp[0]=A[v];\n  fill(dpdp2,dpdp2+num[v]+1,0);\n  dpdp2[0]=(A[v]>0);\n  int curnum=0;\n  for(int u:G[v]) if(u!=p){\n    for(int j=curnum;j>=0;j--){\n      ll tmp=dpdp[j];\n      bool tmp2=dpdp2[j];\n      dpdp[j]=INF;\n      dpdp2[j]=0;\n      for(int k=0;k<=num[u];k++){\n        // 辺を切らない\n        dpdp[j+k]=min(dpdp[j+k],tmp+dp[u][k]);\n        if(dp[u][k]<0||dp2[u][k]){\n          // 辺を切る\n          dpdp[j+k+1]=min(dpdp[j+k+1],tmp);\n        }\n        \n        // 辺を切らない\n        dpdp2[j+k]|=tmp2&&dp2[u][k];\n        if(dp[u][k]<0||dp2[u][k]){\n          // 辺を切る\n          dpdp2[j+k+1]|=tmp2;\n        }\n      }\n    }\n    curnum+=num[u];\n  }\n  for(int j=0;j<=num[v];j++){\n    dp[v][j]=dpdp[j];\n    dp2[v][j]=dpdp2[j];\n  }\n}\n\nint main(){\n  cin>>N; rep(i,N) cin>>A[i];\n  rep(i,N-1){\n    int u,v; cin>>u>>v; u--,v--;\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  solve(0,-1);\n  int ans=N;\n  rep(i,N+1){\n    if(dp[0][i]<0) ans=min(ans,i);\n    if(dp2[0][i]) ans=min(ans,i);\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> v2l;\ntypedef vector<bool> vb;\ntypedef vector<vb> v2b;\n\nconst ll AMAX = 1e13;\n\nint dfs(vi e[], int x, int p, v2l &dp1, v2b &dp2) {\n    int sz = 1;\n\n    for (int y : e[x]) {\n        if (y == p) {\n            continue;\n        }\n\n        int ysz = dfs(e, y, x, dp1, dp2);\n        dp1[x].resize(sz + ysz, AMAX);\n        dp2[x].resize(sz + ysz, false);\n\n        for (int i = sz - 1; i >= 0; i--) {\n            for (int j = ysz - 1; j >= 0; j--) {\n                if (j > 0) {\n                    dp1[x][i+j] = min(dp1[x][i+j], dp1[x][i] + dp1[y][j]);\n                    dp2[x][i+j] = dp2[x][i+j] || dp2[x][i] && dp2[y][j];\n                }\n                if (dp1[y][j] < 0 || dp2[y][j]) {\n                    dp1[x][i+j+1] = min(dp1[x][i+j+1], dp1[x][i]);\n                    dp2[x][i+j+1] = dp2[x][i+j+1] || dp2[x][i];\n                }\n            }\n            dp1[x][i] = min(AMAX, dp1[x][i] + dp1[y][0]);\n            dp2[x][i] = dp2[x][i] && dp2[y][0];\n        }\n\n        sz += ysz;\n    }\n\n    return sz;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    int a[n];\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n    vi e[n];\n    for (int i = 0; i < n - 1; i++) {\n        int u, v;\n        cin >> u >> v;\n        u--, v--;\n        e[u].push_back(v);\n        e[v].push_back(u);\n    }\n\n    v2l dp1(n);\n    for (int i = 0; i < n; i++) {\n        dp1[i] = {a[i]};\n    }\n\n    v2b dp2(n);\n    for (int i = 0; i < n; i++) {\n        dp2[i] = {a[i] > 0};\n    }\n\n    dfs(e, 0, -1, dp1, dp2);\n\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        if (dp1[0][i] < 0 || dp2[0][i]) {\n            ans = i;\n            break;\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3)\n#include<bits/stdc++.h>\n#define MAXN 5005\n#define INF 1000000000000000000LL\n#define MOD 1000000007\n#define F first\n#define S second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nll n,a[MAXN],sz[MAXN],dp[MAXN][MAXN][2];\nll cur[MAXN][2],upd[MAXN][2];\nvector<int> G[MAXN];\nvoid dfs(ll v,ll p)\n{\n    sz[v]=1;\n    for(auto to:G[v])\n    {\n        if(to==p) continue;\n        dfs(to,v);\n    }\n    if(a[v]>0)\n    {\n        cur[0][0]=a[v];\n        cur[0][1]=a[v];\n    }\n    else\n    {\n        cur[0][0]=INF;\n        cur[0][1]=a[v];\n    }\n    for(auto to:G[v])\n    {\n        if(to==p) continue;\n        for(ll i=0;i<n;i++) upd[i][0]=upd[i][1]=INF;\n        for(ll j=0;j<sz[to];j++)\n        {\n            if(dp[to][j][0]!=INF)\n            {\n                for(ll i=0;i<sz[v];i++) if(cur[i][0]!=INF) upd[i+j][0]=min(upd[i+j][0],cur[i][0]+dp[to][j][0]);\n                for(ll i=0;i<sz[v];i++) upd[i+j][1]=min(upd[i+j][1],cur[i][1]+dp[to][j][0]);\n                for(ll i=0;i<sz[v];i++) if(cur[i][0]!=INF) upd[i+j+1][0]=min(upd[i+j+1][0],cur[i][0]);\n                for(ll i=0;i<sz[v];i++) if(cur[i][1]!=INF) upd[i+j+1][1]=min(upd[i+j+1][1],cur[i][1]);\n            }\n            if(dp[to][j][1]!=INF)\n            {\n                for(ll i=0;i<sz[v];i++) if(cur[i][0]!=INF) upd[i+j][1]=min(upd[i+j][1],cur[i][0]+dp[to][j][1]);\n                for(ll i=0;i<sz[v];i++) upd[i+j][1]=min(upd[i+j][1],cur[i][1]+dp[to][j][1]);\n            }\n            if(dp[to][j][1]<0)\n            {\n                for(ll i=0;i<sz[v];i++) if(cur[i][0]!=INF) upd[i+j+1][0]=min(upd[i+j+1][0],cur[i][0]);\n                for(ll i=0;i<sz[v];i++) if(cur[i][1]!=INF) upd[i+j+1][1]=min(upd[i+j+1][1],cur[i][1]);\n            }\n        }\n        sz[v]+=sz[to];\n        for(ll i=0;i<sz[v];i++) cur[i][0]=upd[i][0],cur[i][1]=upd[i][1];\n    }\n    for(ll i=0;i<sz[v];i++) dp[v][i][0]=cur[i][0],dp[v][i][1]=cur[i][1];\n}\nint main()\n{\n    scanf(\"%lld\",&n);\n    for(ll i=1;i<=n;i++) scanf(\"%lld\",&a[i]);\n    for(ll i=0;i<n-1;i++)\n    {\n        ll u,v;\n        scanf(\"%lld%lld\",&u,&v);\n        G[u].push_back(v);G[v].push_back(u);\n    }\n    dfs(1,0);\n    ll ans=INF;\n    for(ll i=0;i<=n-1;i++)\n    {\n        //printf(\"%lld %lld\\n\",dp[1][i][0],dp[1][i][1]);\n        if(dp[1][i][0]!=INF) ans=min(ans,i);\n        if(dp[1][i][1]<0) ans=min(ans,i);\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#define int long long\n#define gmax(x,y) x=max(x,y)\n#define gmin(x,y) x=min(x,y)\n#define F first\n#define S second\n#define P pair\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define V vector\n#define RE return\n#define ALL(a) a.begin(),a.end()\n#define MP make_pair\n#define PB emplace_back\n#define PF emplace_front\n#define FILL(a,b) memset(a,b,sizeof(a))\n#define lwb lower_bound\n#define upb upper_bound\nusing namespace std;\nV<int> v[5005];\nint a[5005],n,dp[5005][5005][2],ch[5005],maxi=1e18,d[5005][2];\nvoid dfs(int p,int fa){\n\tfor(auto u:v[p])if(u!=fa)dfs(u,p);\n\tch[p]=1;\n\tfor(auto u:v[p])if(u!=fa){\n\t\tFOR(i,1,ch[p]+ch[u])d[i][0]=d[i][1]=1e18;\n\t\tFOR(i,1,ch[p]){\n\t\t\tFOR(j,1,ch[u]+1){\n\t\t\t\tgmin(d[i+j-1][0],dp[p][i][0]+dp[u][j][0]);\n\t\t\t\tgmin(d[i+j-1][1],dp[p][i][1]+dp[u][j][0]);\n\t\t\t\tgmin(d[i+j-1][1],dp[p][i][0]+dp[u][j][1]);\n\t\t\t\tgmin(d[i+j-1][1],dp[p][i][1]+dp[u][j][1]);\n\t\t\t}\n\t\t}\n\t\tFOR(i,1,ch[p]+ch[u])dp[p][i][0]=d[i][0],dp[p][i][1]=d[i][1];\n\t\tch[p]+=ch[u];\n\t} \n\tFOR(i,1,ch[p]){\n\t\tif(dp[p][i][1]<0)gmin(dp[p][i+1][0],0ll);\n\t\tif(dp[p][i][0]<maxi)gmin(dp[p][i+1][0],0ll);\n\t}\n}\nsigned main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcin>>n;\n\tFOR(i,1,n)FOR(j,1,n)dp[i][j][0]=dp[i][j][1]=maxi;\n\tFOR(i,1,n){\n\t\tcin>>a[i];\n\t\tif(a[i]<0){\n\t\t\tdp[i][1][1]=a[i];\n\t\t}else dp[i][1][0]=a[i];\n\t}\n\tint x,y;\n\trep(i,1,n){\n\t\tcin>>x>>y;\n\t\tv[x].PB(y);\n\t\tv[y].PB(x);\n\t}\n\tdfs(1,0);\n\tFOR(i,1,n){\n\t\tif(dp[1][i][0]!=maxi||dp[1][i][1]<0){\n\t\t\tcout<<i-1;RE 0;\n\t\t}\n\t}\n\tRE 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst long long INF=1e18;\nconst int MAX_N=5010;\n\nint N;\nint A[MAX_N],sub[MAX_N];\nvector<int> G[MAX_N];\nll dp[MAX_N][MAX_N][2];\n\nvoid dfs(int v,int p){\n    sub[v]=1;\n    dp[v][0][A[v]<0]=A[v];\n    for (int u:G[v]){\n        if (u==p) continue;\n        dfs(u,v);\n        vector<vector<ll>> mrg(sub[v]+sub[u],vector<ll>(2,INF));\n        for (int i=0;i<sub[v];++i){\n            for (int j=0;j<sub[u];++j){\n                for (int k=0;k<2;++k){\n                    for (int l=0;l<2;++l){\n                        mrg[i+j][k|l]=min(mrg[i+j][k|l],dp[v][i][k]+dp[u][j][l]);\n                        if (dp[u][j][l]<0||(!l&&dp[u][j][l]!=INF)){\n                            mrg[i+j+1][k]=min(mrg[i+j+1][k],dp[v][i][k]);\n                        }\n                    }\n                }\n            }\n        }\n        sub[v]+=sub[u];\n        for (int i=0;i<sub[v];++i){\n            for (int j=0;j<2;++j){\n                dp[v][i][j]=mrg[i][j];\n            }\n        }\n    }\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> N;\n    for (int i=0;i<N;++i) cin >> A[i];\n    for (int i=0;i<N-1;++i){\n        int U,V; cin >> U >> V; --U,--V;\n        G[U].emplace_back(V);\n        G[V].emplace_back(U);\n    }\n    for (int i=0;i<N;++i){\n        for (int j=0;j<N;++j){\n            for (int k=0;k<2;++k){\n                dp[i][j][k]=INF;\n            }\n        }\n    }\n    dfs(0,-1);\n    int ans=N;\n    for (int i=0;i<N;++i){\n        for (int j=0;j<2;++j){\n            if (dp[0][i][j]<0||(!j&&dp[0][i][j]!=INF)){\n                ans=min(ans,i);\n            }\n        }\n    }\n    cout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stdio.h>\n#include <vector>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stdlib.h>\n#include <time.h>\n#include <iomanip>\n#include <math.h>\n#include <bitset>\n\nusing namespace std;\n\n#define taskname \"A\"\n#define LL long long \n#define uLL unsigned long long \n#define FOR(i,l,r) for(int i = l; i <= r; ++i)\n#define REP(i,l,r) for(int i = l; i < r; ++i)\n#define FORD(i,r,l) for(int i = r; i >= l; --i)\n#define REPD(i,r,l) for(int i = r; i > l; --i)\n#define sz(x) (int)((x).size())\n#define all(x) (x).begin(), (x).end()\n#define debug(x) { cerr << #x << \" = \" << x << endl; }\n#define sci(x) int x; scanf(\"%d\", &x);\n#define scii(x, y) int x, y; scanf(\"%d %d\", &x, &y);\n#define sciii(x, y, z) int x, y, z; scanf(\"%d %d %d\", &x, &y, &z);\n#define pi pair<int,int>\n#define pii pair<int,pi>\n#define piLL pair<LL,LL>\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define _USE_MATH_DEFINES \n/* M_PI */\n#define SetLength2(a, n, t) a=((t*) calloc(n, sizeof(t))) + (n)/2\n\nconst int maxN = 5001;\nconst LL oo = 1e17 + 11;\n\nint tcases = 1;\n\nint N,M,total = 0,res = 0;\nvector <int> e[maxN];\nint C[maxN];\nLL W[maxN],A[maxN],F[maxN][maxN],G[maxN][maxN];\npiLL tmp[maxN],fg[maxN];\n\nvoid dfs(int u,int p = 0){\n    W[u] = A[u];\n    C[u] = 1;\n    REP(i,0,e[u].size()){\n        int v = e[u][i];\n        if(v == p) continue;\n        dfs(v,u);\n        W[u] += W[v];\n        C[u] += C[v];\n    }\n}\nvoid cal(int u,int p = 0){\n    if(C[u] == 1){\n        F[u][0] = W[u];\n        if(A[u] < 0){\n            G[u][1] = 0;\n        }else{\n            G[u][0] = A[u];\n            G[u][1] = 0;\n        }\n        F[u][1] = 0;\n        return ;\n    }\n    int c = 0;\n    REP(i,0,e[u].size()){\n        int v = e[u][i];\n        if(v == p) continue;\n        cal(v,u);\n        ++c;\n        if(c == 1){\n            REP(j,0,C[u]) F[u][j] = F[v][j],G[u][j] = G[v][j];\n        }else{\n            REP(j,0,C[u]) tmp[j] = mp(F[u][j],G[u][j]);\n            REP(j,0,C[u]){\n                fg[j] = mp(oo,oo);\n                if(j <= 2){\n\n                    FOR(k,0,j){\n                        fg[j].fi = min(fg[j].fi,tmp[j - k].fi + min(F[v][k],G[v][k]));\n                        fg[j].se = min(fg[j].se,tmp[j - k].se + G[v][k]);\n                    }\n                    F[u][j] = fg[j].fi;\n                    G[u][j] = fg[j].se;\n                }\n            }\n        }\n    }\n    REP(j,0,C[u]){\n        F[u][j] += A[u];\n        if(A[u] > 0) G[u][j] += A[u]; else G[u][j] = oo;\n    }\n    FORD(j,C[u] - 1,0){\n        if(F[u][j] < 0){\n            F[u][j + 1] = min(F[u][j + 1],0LL);\n            G[u][j + 1] = min(G[u][j + 1],0LL);\n        }\n        if(G[u][j] < oo){\n            G[u][j + 1] = min(G[u][j + 1],0LL);\n            F[u][j + 1] = min(F[u][j + 1],0LL);\n        }\n    }\n}\nvoid testcase(){\n    scanf(\"%d\",&N);\n    FOR(i,1,N) scanf(\"%lli\",&A[i]);\n    \n    REP(i,1,N){\n        scii(u,v);\n        e[u].pb(v);\n        e[v].pb(u);\n    }\n    dfs(1);\n\n    FOR(i,1,N){\n        FOR(j,0,N) F[i][j] = G[i][j] = oo;\n    }\n\n    FOR(i,0,N) tmp[i] = mp(oo,oo);\n    cal(1);\n\n    FOR(j,0,N - 1) if(F[1][j] < 0 || G[1][j] < oo){\n        printf(\"%d\",j);\n        return ;\n    }\n}\n\nint main(){\n    \n    //scanf(\"%d\",&tcases);\n    \n    FOR(i,1,tcases) testcase();\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < (N); i++)\n#define all(a) (a).begin(), (a).end()\n#define pb push_back\n\nusing ll = long long;\nusing i_i = tuple<int, int>;\n\nint N;\n\nvoid f(int u, int p, vector<int>& a, vector<vector<int>>& G, vector<vector<ll>>& dp, vector<vector<ll>>& ep) {\n    dp[u] = vector<ll>{a[u]};\n    ep[u] = vector<ll>{a[u]};\n    for (int v: G[u]) if (v != p) {\n        f(v, u, a, G, dp, ep);\n        int n = dp[u].size();\n        int m = dp[v].size();\n        vector<ll> unko(n + m - 1, LLONG_MAX / 10);\n        vector<ll> hoge(n + m - 1, LLONG_MAX / 10);\n        rep(i, n) rep(j, m) {\n            unko[i + j] = min(unko[i + j], dp[u][i] + dp[v][j]);\n            hoge[i + j] = min(hoge[i + j], ep[u][i] + ep[v][j]);\n        }\n        dp[u] = unko;\n        ep[u] = hoge;\n    }\n    if (a[u] < 0) rep(i, ep[u].size()) ep[u][i] = LLONG_MAX / 10;\n    dp[u].pb(LLONG_MAX / 10);\n    ep[u].pb(LLONG_MAX / 10);\n    for (int i = (int)dp[u].size() - 2; i >= 0; i--) {\n        if (dp[u][i] < 0 || ep[u][i] < LLONG_MAX / 100) {\n            dp[u][i + 1] = min(dp[u][i + 1], 0LL);\n            ep[u][i + 1] = min(ep[u][i + 1], 0LL);\n        }\n    }\n}\n\nint main() {\n    cin >> N;\n    vector<int> a(N);\n    rep(u, N) cin >> a[u];\n    vector<vector<int>> G(N);\n    rep(i, N - 1) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        G[u].pb(v);\n        G[v].pb(u);\n    }\n    vector<vector<ll>> dp(N), ep(N);\n    f(0, -1, a, G, dp, ep);\n    int ans = N;\n    rep(i, dp[0].size()) if (dp[0][i] < 0 || ep[0][i] < LLONG_MAX / 100)\n        ans = min(ans, i);\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n// pbds\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/detail/standard_policies.hpp>\nusing namespace __gnu_pbds;\n// gp_hash_table<int, int> table;\n\nusing namespace std;\n\n#define vec vector\n#define ALL(x) begin(x), end(x)\n\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair< int, int > pii;\ntypedef pair< long long, long long > pll;\n\nconst int inf = 1000 * 1000 * 1000;\nconst ll inf64 = 1e18;\n\nconst int N = 5005;\n\nint n;\nint a[N];\nvector< int > g[N];\nll dp[N][N][2];\nll buf[N][2];\nint sz[N];\n\nvoid go(int v, int par = -1) {\n    sz[v] = 1;\n    for(int to : g[v]) {\n        if(to == par) continue;\n        go(to, v);\n        sz[v] += sz[to];\n    }\n}\n\ninline void upd(ll &x, ll y) {\n    if(x > y) x = y;\n}\n\nvoid dfs(int v, int par = -1) {\n    dp[v][1][ a[v] < 0 ] = a[v];\n    int cur = 1;\n    for(int to : g[v]) {\n        if(to == par) continue;\n        dfs(to, v);\n\n        for(int cv = 1;cv <= cur + sz[to];cv++) {\n            for(int xv = 0;xv < 2;xv++) {\n                buf[cv][xv] = inf64;\n            }\n        }\n\n        for(int cto = 1;cto <= sz[to];cto++) {\n            for(int xto = 0;xto < 2;xto++) {\n                for(int cv = 1;cv <= cur;cv++) {\n                    for(int xv = 0;xv < 2;xv++) {\n                        if(dp[to][cto][xto] == inf64) continue;\n                        if(dp[v][cv][xv] == inf64) continue;\n                        if(dp[to][cto][xto] < 0 || !xto)\n                            upd(buf[cv + cto][xv], dp[v][cv][xv]);\n                        upd(buf[cv + cto - 1][xv | xto], dp[v][cv][xv] + dp[to][cto][xto]);\n                    }\n                }\n            }\n        }\n\n        cur += sz[to];\n\n        for(int cv = 1;cv <= cur;cv++) {\n            for(int xv = 0;xv < 2;xv++) {\n                dp[v][cv][xv] = buf[cv][xv];\n            }\n        }\n    }\n}\n\nint main() {\n\n#ifdef debug\n    freopen(\"input.txt\", \"r\", stdin);\n#endif\n\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n\n    cin >> n;\n\n    for(int v = 1;v <= n;v++) {\n        cin >> a[v];\n    }\n\n    for(int u, v, i = 1;i < n;i++) {\n        cin >> u >> v;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n\n    for(int v = 1;v <= n;v++) {\n        for(int c = 1;c <= n;c++) {\n            for(int x = 0;x < 2;x++) {\n                dp[v][c][x] = inf64;\n            }\n        }\n    }\n\n    go(1);\n    dfs(1);\n\n    int res = n;\n\n    for(int c = 1;c <= n;c++) {\n        for(int x = 0;x < 2;x++) {\n            if(dp[1][c][x] == inf64) continue;\n            if(dp[1][c][x] < 0 || !x) {\n                res = min(res, c - 1);\n            }\n        }\n    }\n\n    cout << res << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define ll long long\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define all(vr) vr.begin(),vr.end()\nconst ll N=5e3+10,inf=1e17;\nll a[N],n,sub[N],dp[N][N][2],val[N][2];\nvector<int> G[N];\n\nvoid read()\n{\n    cin>>n;\n    for (int i=1;i<=n;i++) cin>>a[i];\n    for (int i=1,u,v;i<n;i++)\n    {\n        cin>>u>>v;\n        G[u].pb(v);\n        G[v].pb(u);\n    }\n}\n\nvoid opt(ll &x,ll y) { x=min(x,y); }\n\nvoid dfs(int u,int r)\n{\n    sub[u]=1;\n    if (a[u]>0)\n    {\n        dp[u][0][0]=a[u];\n        dp[u][0][1]=inf;\n    }\n    else\n    {\n        dp[u][0][0]=inf;\n        dp[u][0][1]=a[u];\n    }\n    for (int v : G[u])\n        if (v!=r)\n        {\n            dfs(v,u);\n            for (int i=0;i<sub[u]+sub[v];i++)\n                for (int t=0;t<=1;t++) val[i][t]=inf;\n            for (int i=0;i<sub[u];i++)\n                for (int j=0;j<sub[v];j++)\n                    for (int x=0;x<=1;x++)\n                        for (int y=0;y<=1;y++)\n                        {\n                            opt(val[i+j][x | y],dp[u][i][x]+dp[v][j][y]);\n                            if ((y==0 && dp[v][j][y]<inf) || dp[v][j][y]<0) opt(val[i+j+1][x],dp[u][i][x]);\n                        }\n            sub[u]+=sub[v];\n            for (int i=0;i<sub[u];i++)\n                for (int t=0;t<=1;t++) dp[u][i][t]=val[i][t];\n        }\n}\n\nvoid process()\n{\n    dfs(1,0);\n    for (int i=0;i<sub[1];i++)\n        if (dp[1][i][1]<0 || dp[1][i][0]<inf)\n        {\n            cout<<i;\n            return;\n        }\n}\n\nint main()\n{\n    //freopen(\"ss.inp\",\"r\",stdin);\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    read();\n    process();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst ll INF = 1e17;\n//const ll mod = 1000000007;\nvector<ll> dp[5005][2];\nint N;\nll A[5005];\nvector<int> pathes[5005];\n\nvoid f(int now, vector<ll> &v1, vector<ll> &v2, vector<ll> &v3, vector<ll> &v4) {\n    vector<ll> u1, u2;\n    u2.resize(v2.size() + v4.size(), 0);\n    for(int i = 0; i < v2.size(); i++) {\n        for(int j = 0; j < v4.size(); j++) {\n            u2[i+j] |= (v2[i] & v4[j]);\n            if(v3[j] < 0) {\n                u2[i+j+1] |= v2[i];\n            }\n        }\n    }\n    u1.resize(v1.size() + v3.size(), INF);\n    for(int i = 0; i < v1.size(); i++) {\n        for(int j = 0; j < v3.size(); j++) {\n            chmin(u1[i+j], v1[i] + v3[j]);\n            if(v3[j] < 0) {\n                chmin(u1[i+j+1], v1[i]);\n            }\n            if(v4[j] == 1) {\n                chmin(u1[i+j+1], v1[i]);\n            }\n        }\n    }\n    v1.resize(u1.size());\n    v2.resize(u2.size());\n    for(int i = 0; i < u1.size(); i++) {\n        //cerr << i << \" \" << u1[i] << endl;\n        v1[i] = u1[i];\n    }\n    //cerr << endl;\n    for(int i = 0; i < u2.size(); i++) {\n        //cerr << i << \" \" << u2[i] << endl;\n        v2[i] = u2[i];\n    }\n}\n\nvoid dfs(int now, int from) {\n    //cerr << \"dfs on \" << now << \"\\n\";\n    dp[now][0].push_back(A[now]);\n    if(A[now] > 0) dp[now][1].push_back(1);\n    else dp[now][1].push_back(0);\n    for(int a = 0; a < pathes[now].size(); a++) {\n        int to = pathes[now][a];\n        if(to == from) continue;\n        dfs(to, now);\n        //cerr << \"merging \" << to << \" to \" << now << endl;\n        f(now, dp[now][0], dp[now][1], dp[to][0], dp[to][1]);\n    }\n    /*\n    cerr << \"---\" << now << \"---\" << endl;\n    for(int i = 0; i < dp[now][0].size(); i++) {\n        cerr << i << \" \" << dp[now][0][i] << endl;\n    }\n    cerr << \"\\n\";\n    for(int i = 0; i < dp[now][1].size(); i++) {\n        cerr << i << \" \" << dp[now][1][i] << endl;\n    }\n    cerr << \"--------------\" << endl;\n    */\n}\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> N;\n    for(int i = 1; i <= N; i++) cin >> A[i];\n    for(int i = 1; i < N; i++) {\n        int u, v;\n        cin >> u >> v;\n        pathes[u].push_back(v);\n        pathes[v].push_back(u);\n    }\n    dfs(1, -1);\n    int ans = N;\n    for(int i = 0; i < dp[1][0].size(); i++) {\n        if(dp[1][0][i] < 0) chmin(ans, i);\n        if(dp[1][1][i]) chmin(ans, i);\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3f\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\n\nint n;\nll a[6000];\nvector<int>E[6000];\nint siz[6000];\nint dp[2][6000][6000];\nbool dp2[2][6000][6000];\n\nvoid dfs(int v,int p){\n\tfor(int u:E[v]){\n\t\tif(u==p)continue;\n\t\tdfs(u,v);\n\t}\n\tint D=0;\n\trep(i,n)dp[0][v][i]=INF;\n\tdp[0][v][0]=a[v];\n\tif(a[v]>0)dp2[0][v][0]=true;\n\tsiz[v]=1;\n\tfor(int u:E[v]){\n\t\tif(u==p)continue;\n\t\tint a=(E[u].size()-1)%2;\n\t\tfor(int i=siz[v]+siz[u];i>=0;i--){\n\t\t\tdp[!D][v][i]=INF;\n\t\t\tdp2[!D][v][i]=false;\n\t\t}\n\t\trep(i,siz[v]+1){\n\t\t\trep(j,siz[u]+1){\n\t\t\t\t//切断する場合\n\t\t\t\tif(dp2[a][u][j]||dp[a][u][j]<0){\n\t\t\t\t\tdp[!D][v][i+j+1]=min(dp[!D][v][i+j+1],dp[D][v][i]);\n\t\t\t\t\tdp2[!D][v][i+j+1]|=dp2[D][v][i];\n\t\t\t\t}\n\t\t\t\t//切断しない場合\n\t\t\t\tdp[!D][v][i+j]=min(dp[!D][v][i+j],dp[D][v][i]+dp[a][u][j]);\n\t\t\t\tdp2[!D][v][i+j]|=(dp2[D][v][i]&dp2[a][u][j]);\n\t\t\t}\n\t\t}\n\t\tsiz[v]+=siz[u];\n\t\tD=!D;\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\trep(i,n)scanf(\"%lld\",&a[i]);\n\trep(i,n-1){\n\t\tint a,b;scanf(\"%d%d\",&a,&b);a--;b--;\n\t\tE[a].push_back(b);\n\t\tE[b].push_back(a);\n\t}\n\tdfs(0,-1);\n\trep(i,n){\n\t\tif(dp[E[0].size()%2][0][i]<0||dp2[E[0].size()%2][0][i]==true){\n\t\t\tcout<<i<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\nconst ll INF = 1000000000000000LL;\n\nll a[5005];\nvector<int> g[5005];\nvector< array<ll, 2> > dp[5005];\n\nvoid dfs(int cur, int par) {\n    dp[cur].push_back({a[cur], (a[cur] < 0)});\n    for (int nex : g[cur]) {\n        if (nex == par) continue;\n        dfs(nex, cur);\n\n        vector< array<ll, 2> > ndp(dp[nex].size() + dp[cur].size(), {INF, INF});\n        for (int i = 0; i < dp[cur].size(); i++) {\n            for (int j = 0; j < dp[nex].size(); j++) {\n                ndp[i + j][0] = min(ndp[i + j][0], dp[cur][i][0] + dp[nex][j][0]);\n                ndp[i + j][1] = min(ndp[i + j][1], dp[cur][i][1] + dp[nex][j][1]);\n\n                if (dp[nex][j][0] < 0 || dp[nex][j][1] == 0) {\n                    ndp[i + j + 1][0] = min(ndp[i + j + 1][0], dp[cur][i][0]);\n                    ndp[i + j + 1][1] = min(ndp[i + j + 1][1], dp[cur][i][1]);\n                }\n            }\n        }\n        dp[cur] = move(ndp);\n    }\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; i++) cin >> a[i];\n\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n\n    dfs(0, -1);\n\n    for (int i = 0; i < dp[0].size(); i++) {\n        if (dp[0][i][0] < 0 || dp[0][i][1] == 0) {\n            cout << i << endl;\n            break;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int SZ = 5005;\ntypedef long long ll;\nvector<int> graph[5005];\nll wei[SZ];\nint visit[SZ];\nint n;\nint aa = 0;\nll post_order(int a){\n\tvisit[a]=1;\n\tll sm = wei[a];\n\tfor(auto x : graph[a]){\n\t\tif(visit[x]==1) continue;\n\t\tll chk = post_order(x);\n\t\tsm += chk;\n\t\tif(wei[a]+chk>0 && (wei[a]<0 || chk<0 || (wei[x]<0 && max(sm,wei[a])+wei[x]>0))){\n\t\t\taa++;\n\t\t}\n\t}\n\treturn sm;\n}\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%lld\",&wei[i]);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y; scanf(\"%d %d\",&x,&y);\n\t\tgraph[x].push_back(y);\n\t\tgraph[y].push_back(x);\n\t}\n\tpost_order(1);\n\tprintf(\"%lld\",aa);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n#define reps(i, n) for (int i = 1; i <= (int) (n); i++)\n#define all(x) (x).begin(), (x).end()\n#define uniq(x) (x).erase(unique(all(x)), (x).end())\n#define bit(n) (1LL << (n))\n#define cdiv(a, b) (((a) - 1) / (b) + 1)\n#define dump(x) cerr << #x \" = \" << (x) << endl\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing pint = pair<int, int>;\nusing vpint = vector<pint>;\ntemplate<typename T> using priority_queue_rev = priority_queue<T, vector<T>, greater<T>>;\nconstexpr double PI = 3.1415926535897932384626433832795028;\nconstexpr int DY[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nconstexpr int DX[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nint gcd(int a, int b) {\n    while (b) { swap(a %= b, b); }\n    return a;\n}\nint lcm(int a, int b) { return a / gcd(a, b) * b; }\nint sgn(int x) { return (x > 0) - (x < 0); }\ntemplate<typename T> void fin(T mes) {\n    cout << mes << endl;\n    exit(0);\n}\ntemplate<typename T, typename U> bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &rhs) {\n    os << \"(\" << rhs.first << \", \" << rhs.second << \")\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\nstruct setup {\n    static constexpr int PREC = 20;\n\n    setup() {\n        cout << fixed << setprecision(PREC);\n        cerr << fixed << setprecision(PREC);\n    };\n} setup;\n\nint N;\nint A[5500];\nint U[5500], V[5500];\nvint G[5500];\npair<vint, int> dfs(int cur, int par) {\n    vint x = {A[cur]};\n    int cut = 0;\n    for (int to:G[cur]) {\n        if (to == par) { continue; }\n        pair<vint, int> tmp = dfs(to, cur);\n        vint nxt = tmp.first;\n        int ccut = tmp.second;\n        vint y(x.size() + nxt.size(), 10000LL * INT_MAX);\n        if (ccut >= 0) { rep(i, x.size()) { y[i + ccut + 1] = x[i]; }}\n        rep(i, x.size()) {\n            rep(j, nxt.size()) {\n                chmin(y[i + j], x[i] + nxt[j]);\n                if (nxt[j] < 0) { chmin(y[i + j + 1], x[i]); }\n            }\n        }\n        x = y;\n        //reps(i, x.size() - 1) { chmin(x[i], x[i - 1]); }\n        int pl;\n        for (int i = nxt.size() - 1; i >= 0; i--) { if (nxt[i] < 0) { pl = i; }}\n        if (ccut >= 0) { cut += min(ccut, pl + 1); }\n        else { cut += pl + 1; }\n    }\n    if (A[cur] < 0) { cut = -1; }\n    return {x, cut};\n}\n\nsigned main() {\n    cin >> N;\n    rep(i, N) { cin >> A[i]; }\n    rep(i, N - 1) {\n        cin >> U[i] >> V[i];\n        U[i]--, V[i]--;\n        G[U[i]].push_back(V[i]), G[V[i]].push_back(U[i]);\n    }\n    pair<vint, int> res = dfs(0, -1);\n    int ans = N;\n    if (A[0] > 0) { ans = res.second; }\n    rep(i, res.first.size()) { if (res.first[i] < 0) { chmin(ans, i); }}\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < (N); i++)\n#define all(a) (a).begin(), (a).end()\n#define pb push_back\n\nusing ll = long long;\nusing i_i = tuple<int, int>;\n\nint N;\n\nvoid f(int u, int p, vector<int>& a, vector<vector<int>>& G, vector<vector<ll>>& dp, vector<vector<ll>>& ep) {\n    dp[u] = vector<ll>{a[u]};\n    ep[u] = vector<ll>{a[u]};\n    for (int v: G[u]) if (v != p) {\n        f(v, u, a, G, dp, ep);\n        int n = dp[u].size();\n        int m = dp[v].size();\n        vector<ll> unko(n + m - 1, LLONG_MAX / 10);\n        vector<ll> hoge(n + m - 1, LLONG_MAX / 10);\n        rep(i, n) rep(j, m) {\n            unko[i + j] = min(unko[i + j], dp[u][i] + dp[v][j]);\n            hoge[i + j] = min(hoge[i + j], ep[u][i] + ep[v][j]);\n        }\n        dp[u] = unko;\n        ep[u] = hoge;\n    }\n    if (a[u] < 0) rep(i, ep[u].size()) ep[u][i] = LLONG_MAX / 10;\n    dp[u].pb(LLONG_MAX / 10);\n    ep[u].pb(LLONG_MAX / 10);\n    for (int i = (int)dp[u].size() - 2; i >= 0; i--) {\n        if (dp[u][i] < 0 || ep[u][i] < LLONG_MAX / 100) {\n            dp[u][i + 1] = min(dp[u][i + 1], 0LL);\n            ep[u][i + 1] = min(ep[u][i + 1], 0LL);\n        }\n    }\n}\n\nint main() {\n    cin >> N;\n    vector<int> a(N);\n    rep(u, N) cin >> a[u];\n    vector<vector<int>> G(N);\n    rep(i, N - 1) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        G[u].pb(v);\n        G[v].pb(u);\n    }\n    vector<vector<ll>> dp(N), ep(N);\n    f(0, -1, a, G, dp, ep);\n    int ans = N;\n    rep(i, dp[0].size()) if (dp[0][i] <= 0 || ep[0][i] < LLONG_MAX / 100)\n        ans = min(ans, i);\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n#define reps(i, n) for (int i = 1; i <= (int) (n); i++)\n#define all(x) (x).begin(), (x).end()\n#define uniq(x) (x).erase(unique(all(x)), (x).end())\n#define bit(n) (1LL << (n))\n#define cdiv(a, b) (((a) - 1) / (b) + 1)\n#define dump(x) cerr << #x \" = \" << (x) << endl\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing pint = pair<int, int>;\nusing vpint = vector<pint>;\ntemplate<typename T> using priority_queue_rev = priority_queue<T, vector<T>, greater<T>>;\nconstexpr double PI = 3.1415926535897932384626433832795028;\nconstexpr int DY[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nconstexpr int DX[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nint gcd(int a, int b) {\n    while (b) { swap(a %= b, b); }\n    return a;\n}\nint lcm(int a, int b) { return a / gcd(a, b) * b; }\nint sgn(int x) { return (x > 0) - (x < 0); }\ntemplate<typename T> void fin(T mes) {\n    cout << mes << endl;\n    exit(0);\n}\ntemplate<typename T, typename U> bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &rhs) {\n    os << \"(\" << rhs.first << \", \" << rhs.second << \")\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\nstruct setup {\n    static constexpr int PREC = 20;\n\n    setup() {\n        cout << fixed << setprecision(PREC);\n        cerr << fixed << setprecision(PREC);\n    };\n} setup;\n\nstruct union_find_tree {\n    std::vector<int> par, size, val;\n    union_find_tree() {}\n    union_find_tree(int n, vint val) : par(n), size(n), val(val) {\n        for (int i = 0; i < n; i++) {\n            par[i] = i;\n            size[i] = 1;\n        }\n    }\n    int get_root(int i) {\n        if (par[i] == i) { return i; }\n        else { return par[i] = get_root(par[i]); }\n    }\n    void unite(int i, int j) {\n        if ((i = get_root(i)) == (j = get_root(j))) { return; }\n        if (size[i] < size[j]) { std::swap(i, j); }\n        par[j] = i;\n        size[i] += size[j];\n        val[i] += val[j];\n    }\n    bool are_same(int i, int j) { return get_root(i) == get_root(j); }\n    int get_size(int i) { return size[get_root(i)]; }\n    int get_val(int i) { return val[get_root(i)]; }\n};\n\nint N;\nint U[5500], V[5500];\nvint G[5500];\nunion_find_tree uf;\npair<vint, int> dfs(int cur, int par) {\n    vint x = {uf.get_val(cur)};\n    if (uf.get_val(cur) < 0) {\n        //コンピュータ\n        for (int to:G[cur]) {\n            if (to == par) { continue; }\n            pair<vint, int> tmp = dfs(to, cur);\n            vint nxt = tmp.first;\n            int cut = tmp.second;\n            vint y(x.size() + nxt.size(), LLONG_MAX);\n            rep(i, x.size()) { y[i + cut + 1] = x[i]; }\n            rep(i, x.size()) {\n                rep(j, nxt.size()) {\n                    chmin(y[i + j], x[i] + nxt[j]);\n                    if (nxt[j] < 0) { chmin(y[i + j + 1], x[i]); }\n                }\n            }\n            x = y;\n            reps(i, x.size() - 1) { chmin(x[i], x[i - 1]); }\n        }\n        return {x, -1};\n    }\n    if (uf.get_val(cur) > 0) {\n        //バッテリー\n        int cut = 0;\n        for (int to:G[cur]) {\n            if (to == par) { continue; }\n            vint nxt = dfs(to, cur).first;\n            vint y(x.size() + nxt.size(), LLONG_MAX);\n            rep(i, x.size()) {\n                rep(j, nxt.size()) {\n                    chmin(y[i + j], x[i] + nxt[j]);\n                    if (nxt[j] < 0) { chmin(y[i + j + 1], x[i]); }\n                }\n            }\n            x = y;\n            reps(i, x.size() - 1) { chmin(x[i], x[i - 1]); }\n            int pl;\n            for (int i = nxt.size(); i >= 0; i--) { if (nxt[i] < 0) { pl = i; }}\n            cut += pl + 1;\n        }\n        return {x, cut};\n    }\n    return {{}, 0};\n}\n\nsigned main() {\n    cin >> N;\n    vint val(N);\n    rep(i, N) { cin >> val[i]; }\n    uf = union_find_tree(N, val);\n    rep(i, N - 1) {\n        cin >> U[i] >> V[i];\n        U[i]--, V[i]--;\n        if ((uf.get_val(U[i]) > 0) == (uf.get_val(V[i]) > 0)) { uf.unite(U[i], V[i]); }\n    }\n    rep(i, N - 1) {\n        int u = uf.get_root(U[i]), v = uf.get_root(V[i]);\n        if (u != v) { G[u].push_back(v), G[v].push_back(u); }\n    }\n    pair<vint, int> res = dfs(uf.get_root(0), -1);\n    int ans = N;\n    if (uf.get_val(0) > 0) { ans = res.second; }\n    rep(i, res.first.size()) { if (res.first[i] < 0) { chmin(ans, i); }}\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n# include <bits/stdc++.h>\n\n# define x first\n# define y second\n# define mp make_pair\n// everything goes according to my plan\n# define pb push_back\n# define sz(a) (int)(a.size())\n# define vec vector\n// shimkenttin kyzdary, dzyn, dzyn, dzyn...\n# define y1    Y_U_NO_y1\n# define left  Y_U_NO_left\n# define right Y_U_NO_right\n\n# define debug(x) cerr<<#x<<\":=\"<<x\n\n\nusing namespace std;\n\ntypedef pair <int, int> pii;\ntypedef long long ll;\ntypedef long double ld;\n\nconst int Mod = (int)1e9 + 7;\nconst int MX = 1073741822;\nconst ll MXLL = 1e15;\nconst int Sz = 1110111;\n// a pinch of soul\ninline void Read_rap () {\n  ios_base :: sync_with_stdio(0);\n  cin.tie(0); cout.tie(0);\n}\ninline void randomizer3000 () {\n  unsigned int seed;\n  asm (\"rdtsc\" : \"=A\"(seed));\n  srand (seed);\n}\nvoid files (string problem) {\n  if (fopen ((problem + \".in\").c_str(),\"r\")) {\n    freopen ((problem + \".in\").c_str(),\"r\",stdin);\n    freopen ((problem + \".out\").c_str(),\"w\",stdout);\n  }\n}\nvoid localInput(const char in[] = \"s\") {\n  if (fopen (in, \"r\")) {\n    freopen (in, \"r\", stdin);\n  }\n  else\n    cerr << \"Warning: Input file not found\" << endl;\n}                    \nvec<ll> dp[Sz];\n\nll ans[Sz];\n            \nll ps[Sz];\n\nint n;\n\nint a[Sz];\n\nvec<int> g[Sz];\n\nvoid calc (int v, int pr) {\n  int big = 0;\n  for (int to : g[v]) {\n    if (to == pr) continue;\n    calc (to, v);\n    if (sz(dp[to]) > sz(dp[big]))\n      big = to;\n  }\n  int siz = 1;\n  if (big) {\n    swap (dp[v], dp[big]);\n    siz = sz(dp[v]);\n    for (int i = 0; i < siz; i++)\n      dp[v][i] += a[v];   \n    dp[v].pb (a[v]);\n    dp[v][ans[big] + 1] = min (dp[v][ans[big] + 1], a[v] * 1ll);\n    siz++;\n  }\n  else\n    dp[v].pb (a[v]);\n              \n  for (int to : g[v]) {\n    if (to == pr || to == big) continue;                            \n    dp[v].resize (siz + sz(dp[to]), MXLL);\n                      \n    int nsiz = siz + sz(dp[to]);\n    for (int s = siz-1; s >= 0; s--) {\n      for (int x = sz(dp[to])-1; x >= 0; x--) {\n        if (s + x + 1 < nsiz) \n          dp[v][s+x+1] = min (dp[v][s+x+1], dp[v][s]);\n        if (s + x < nsiz)\n          dp[v][s+x] = min (dp[v][s + x], dp[v][s] + dp[to][x]);\n      }\n    }\n    siz = nsiz;\n    /*\n    cout << \"V: \" << v << \" to: \" << to << endl;\n    for (int i = 0; i < siz ; i++)\n      cout << dp[v][i] << ' ';\n    cout << endl;\n    */\n  }\n  ans[v] = MXLL;\n  for (int i = 0; i < siz; i++)\n    if (dp[v][i] < 0) {\n      ans[v] = i;\n      break;\n    }\n                                \n  if (a[v] > 0) {\n    ps[v] = 0;\n    for (int to : g[v]) {\n      if (to == pr) continue;\n      if (a[to] > 0)\n        ps[v] += ps[to];\n      else\n        ps[v] += ans[to] + 1;\n    }\n    ans[v] = min (ans[v], ps[v]);      \n  }\n}\n\nint main()\n{\n  # ifdef Local\n    //localInput();\n  # endif\n  Read_rap();\n  cin >> n;\n  for (int i = 1; i <= n; i++)\n    cin >> a[i];       \n  for (int i = 1; i < n; i++) {\n    int u, v;\n    cin >> u >> v;\n    g[u].pb (v);\n    g[v].pb (u);\n  }\n  calc (1, 1);\n  cout << ans[1];\n\n  return 0;\n}\n\n\n\n\n\n\n// Coded by Z..\n"
  },
  {
    "language": "C++",
    "code": "// >>> TEMPLATES\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\n#define int ll\n#define double ld\n#define rep(i,n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i,n) for (int i = 1; i <= (int)(n); i++)\n#define repR(i,n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rep1R(i,n) for (int i = (int)(n); i >= 1; i--)\n#define loop(i,a,B) for (int i = a; i B; i++)\n#define loopR(i,a,B) for (int i = a; i B; i--)\n#define all(x) begin(x), end(x)\n#define allR(x) rbegin(x), rend(x)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\ntemplate <class Int> auto constexpr inf = numeric_limits<Int>::max()/2-1;\nauto constexpr INF32 = inf<int32_t>;\nauto constexpr INF64 = inf<int64_t>;\nauto constexpr INF   = inf<int>;\n#ifdef LOCAL\n#include \"debug.hpp\"\n#else\n#define dump(...) (void)(0)\n#define say(x) (void)(0)\n#define debug if (0)\n#endif\ntemplate <class T> using pque_max = priority_queue<T>;\ntemplate <class T> using pque_min = priority_queue<T, vector<T>, greater<T> >;\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nostream& operator<<(ostream& os, T const& v) { bool f = true; for (auto const& x : v) os << (f ? \"\" : \" \") << x, f = false; return os; }\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nistream& operator>>(istream& is, T &v) { for (auto& x : v) is >> x; return is; }\ntemplate <class T, class S> ostream& operator<<(ostream& os, pair<T,S> const& p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\ntemplate <class T, class S> istream& operator>>(istream& is, pair<T,S>& p) { return is >> p.first >> p.second; }\nstruct IOSetup { IOSetup() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); } } iosetup;\ntemplate <class F> struct FixPoint : private F {\n    constexpr FixPoint(F&& f) : F(forward<F>(f)) {}\n    template <class... T> constexpr auto operator()(T&&... x) const { return F::operator()(*this, forward<T>(x)...); }\n};\nstruct MakeFixPoint {\n    template <class F> constexpr auto operator|(F&& f) const { return FixPoint<F>(forward<F>(f)); }\n};\n#define MFP MakeFixPoint()|\n#define def(name, ...) auto name = MFP [&](auto &&name, __VA_ARGS__)\ntemplate <class T, size_t d> struct vec_impl {\n    using type = vector<typename vec_impl<T,d-1>::type>;\n    template <class... U> static type make_v(size_t n, U&&... x) { return type(n, vec_impl<T,d-1>::make_v(forward<U>(x)...)); }\n};\ntemplate <class T> struct vec_impl<T,0> { using type = T; static type make_v(T const& x = {}) { return x; } };\ntemplate <class T, size_t d = 1> using vec = typename vec_impl<T,d>::type;\ntemplate <class T, size_t d = 1, class... Args> auto make_v(Args&&... args) { return vec_impl<T,d>::make_v(forward<Args>(args)...); }\ntemplate <class T> void quit(T const& x) { cout << x << endl; exit(0); }\ntemplate <class T, class U> constexpr bool chmin(T& x, U const& y) { if (x > y) { x = y; return true; } return false; }\ntemplate <class T, class U> constexpr bool chmax(T& x, U const& y) { if (x < y) { x = y; return true; } return false; }\ntemplate <class It> constexpr auto sumof(It b, It e) {\n    using S = typename iterator_traits<It>::value_type;\n    using T = conditional_t<is_signed_v<S>,i64,u64>;\n    return accumulate(b,e,T{});\n}\ntemplate <class T> int sz(T const& x) { return x.size(); }\ntemplate <class C, class T> int lbd(C const& v, T const& x) {\n    return lower_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class T> int ubd(C const& v, T const& x) {\n    return upper_bound(v.begin(), v.end(), x)-v.begin();\n}\nconst int dx[] = { 1,0,-1,0 };\nconst int dy[] = { 0,1,0,-1 };\nconstexpr int popcnt(ll x) { return __builtin_popcountll(x); }\ntemplate <class Int> Int rand(Int a, Int b) { // [a,b]\n    static mt19937_64 mt{random_device{}()};\n    return uniform_int_distribution<Int>(a,b)(mt);\n}\ni64 irand(i64 a, i64 b) { return rand<i64>(a,b); }\nu64 urand(u64 a, u64 b) { return rand<u64>(a,b); }\n// <<<\n\nint32_t main() {\n    int n; cin >> n;\n    vector<int> a(n); cin >> a;\n    vector<vector<int>> g(n);\n    rep (_,n-1) {\n        int x,y; cin >> x >> y; --x,--y;\n        g[x].eb(y);\n        g[y].eb(x);\n    }\n\n    auto dp = make_v<int,3>(n,2,0);\n    def (dfs, int x, int p) -> void {\n        if (a[x] > 0) {\n            dp[x][0] = {a[x]};\n            dp[x][1] = {INF};\n        } else {\n            dp[x][0] = {INF};\n            dp[x][1] = {a[x]};\n        }\n        for (int y : g[x]) {\n            if (y == p) continue;\n            dfs(y,x);\n\n            int A = dp[x][0].size()-1;\n            int B = dp[y][0].size()-1;\n            int C = A+B+1;\n            vector<int> ndp[2];\n            rep (a,2) ndp[a].resize(C+1,INF);\n            rep (a,2) rep (i,A+1) if (dp[x][a][i] < INF) {\n                rep (b,2) rep (j,B+1) if (dp[y][b][j] < INF) {\n                    chmin(ndp[a||b][i+j], dp[x][a][i] + dp[y][b][j]);\n                    if (b == 0 || dp[y][b][j] < 0) {\n                        chmin(ndp[a][i+j+1], dp[x][a][i]);\n                    }\n                }\n            }\n            rep (a,2) swap(dp[x][a], ndp[a]);\n        }\n\n    };\n    dfs(0,-1);\n    dump(as_mat(dp));\n\n    int mi = INF;\n    rep (a,2) rep (i,n) if (dp[0][a][i] < INF) {\n        if (a == 0 || dp[0][a][i] < 0) {\n            chmin(mi, i);\n        }\n    }\n\n    cout << mi << endl;\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "//注意点\n//Tは3つの値を持つ構造\n//だがワイルドカードとしても使っている\n#include <bits/stdc++.h>\nusing namespace std;\n//@起動時\nstruct initon {\n    initon() {\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.setf(ios::fixed);\n        cout.precision(16);\n    };\n} __initon;\n\n//@必須構造\nstruct T {\n    int f, s, t;\n    T() { f = -1, s = -1, t = -1; }\n    T(int f, int s, int t) : f(f), s(s), t(t) {}\n    bool operator<(const T &r) const {\n        return f != r.f ? f < r.f : s != r.s ? s < r.s : t < r.t;\n        //return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 大きい順\n    }\n    bool operator>(const T &r) const {\n        return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t;\n        //return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 小さい順\n    }\n    int operator[](int i) {\n        assert(i < 3);\n        return i == 0 ? f : i == 1 ? s : t;\n    }\n};\n\n//@マクロ省略系 型,構造\n\n#define int int_fast64_t\n#define ll long long\n#define double long double\n#define ull unsigned long long\nusing dou = double;\nusing itn = int;\nusing str = string;\nusing bo= bool;\nusing P = pair<int, int>;\n#define F first\n#define S second\n#define vec vector\n#define con continue\n#define bre break\n#define brk break\n#define is ==\n#define rs resize\n\n//マクロ省略系 コンテナ\nusing vi = vector<int>;\n#define vvi(a, b, c) vec<vi> a(b,vi(c))\nusing vb = vector<bool>;\n#define vvb(a, b, c) vec<vb> a(b,vb(c))\nusing vs = vector<string>;\n#define vvs(a, b, c) vec<vs> a(b,vs(c))\nusing vl = vector<ll>;\n#define vvl(a, b, c) vec<vl> a(b,vl(c))\nusing vd = vector<double>;\n#define vvd(a, b, c) vec<vd> a(b,vd(c))\nusing vc=vector<char>;\n#define vvc(a, b, c) vec<vc> a(b,vc(c))\nusing vp = vector<P>;\n#define vvp(a, b, c) vec<vp> a(b,vp(c))\nusing vt = vector<T>;\n#define vvt(a, b, c) vec<vt> a(b,vt(c))\n#define v3i(a, b, c, d) vector<vector<vi>> a(b, vector<vi>(c, vi(d)))\n#define v3d(a, b, c, d) vector<vector<vd>> a(b, vector<vd>(c, vd(d)))\n#define v3m(a, b, c, d) vector<vector<vm>> a(b, vector<vm>(c, vm(d)))\n#define PQ priority_queue<ll, vector<ll>, greater<ll> >\nusing seti = set<int>;\n#define uset unordered_set\n#define mset multiset\n#define umap unordered_map\n#define mmap multimap\n\n//マクロ 繰り返し\n#define _overloadrep(_1, _2, _3, name, ...) name\n# define _rep(i, n) for(int i = 0; i < n ; i++)\n#define repi(i, m, n) for(int i = m; i < n ; i++)\n#define rep(...) _overloadrep(__VA_ARGS__,repi,_rep,)(__VA_ARGS__)\n#define _rer(i, n) for(int i = n; i >= 0 ; i--)\n#define reri(i, m, n) for(int i = m; i >= n ; i--)\n#define rer(...) _overloadrep(__VA_ARGS__,reri,_rer,)(__VA_ARGS__)\n#define fora(a, b) for(auto&& a : b)\n#define forg(gi, ve) if (ve.size())for (int gi = 0, f = ve[gi].from, t = ve[gi].to, c = ve[gi].cost; gi < ve.size(); gi++,f = ve[gi].from, t = ve[gi].to, c = ve[gi].cost)\n\n//マクロ 定数\n#define k4 10101\n#define k5 101010\n#define k6 1010101\n#define k7 10101010\nconst int inf = (int) 1e9 + 100;\nconst ll linf = (ll) 1e18 + 100;\nconst double eps = 1e-9;\nconst int y4[] = {-1, 1, 0, 0};\nconst int x4[] = {0, 0, -1, 1};\nconst int y8[] = {0, 1, 0, -1, -1, 1, 1, -1};\nconst int x8[] = {1, 0, -1, 0, 1, -1, 1, -1};\n\n//マクロ省略形 関数等\n#define arsz(a) (sizeof(a)/sizeof(a[0]))\n#define sz(a) (a.size())\n#define mp make_pair\n#define pb push_back\n#define pf push_front\n#define eb emplace_back\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\n//@拡張系 こう出来るべきというもの\n\n//埋め込み 存在を意識せずに機能を増やされているもの\n// 境界チェック付きvector\nnamespace std_vector_bounds_checking {\n    using namespace std;\n    template<class T, class A = std::allocator<T>> struct vector : std::vector<T, A> {\n        using std::vector<T, A>::vector;\n        typename std::vector<T>::reference operator[](typename std::vector<T>::size_type n) {\n            return this->at(n);\n        }\n    };\n}\nnamespace std {\n    template<> class hash<std::pair<signed, signed>> {\n    public:\n        size_t operator()(const std::pair<signed, signed> &x) const {\n            return hash<ll>()(((ll) x.first << 32) + x.second);\n        }\n    };\n    template<> class hash<std::pair<ll, ll>> {\n    public:\n        size_t operator()(const std::pair<ll, ll> &x) const {\n            return hash<ll>()(((ll) x.first << 32) + x.second);\n        }\n    };\n}\ntemplate<typename T> istream &operator>>(istream &iss, vector<T> &vec) {\n    for (T &x: vec) iss >> x;\n    return iss;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, vector <T> &vec) {\n    for (int i = 0; i < vec.size(); i++)os << vec[i] << (i + 1 == vec.size() ? \"\" : \" \");\n    return os;\n}\ntemplate<typename V, typename H> void resize(vector<V> &vec, const H head) {  //再帰の終端。 可変長templateの長さが 0 になるとこっちが呼ばれる。\n    vec.resize(head);\n}\ntemplate<typename V, typename H, typename ... T> void resize(vector<V> &vec, const H &head, const T ... tail) {\n    vec.resize(head);\n    for (auto &v: vec) resize(v, tail...);\n}\ntemplate<class T> T pop(set<T> &set) {\n    T res = *set.begin();\n    set.erase(set.find(res));\n    return res;\n}\ntemplate<class T> T pop(mset<T> &set) {\n    T res = *set.begin();\n    set.erase(set.find(res));\n    return res;\n}\ntemplate<class T> T popBack(set<T> &set) {\n    T res = *set.rbegin();\n    set.erase(set.find(res));\n    return res;\n}\ntemplate<class T> T popBack(mset<T> &set) {\n    T res = *set.rbegin();\n    set.erase(set.find(res));\n    return res;\n}\ntemplate<class T> inline void sort(vector<T> &a) { sort(a.begin(), a.end()); };\ntemplate<class T> inline void rsort(vector<T> &a) { sort(a.begin(), a.end(), greater<T>()); };\ntemplate<class T> inline void sort(vector<T> &a, int len) { sort(a.begin(), a.begin() + len); };\ntemplate<class T> inline void rsort(vector<T> &a, int len) { sort(a.begin(), a.begin() + len, greater<T>()); };\ntemplate<class T> inline void sort2(vector<vector<T>> &a) { for (int i = 0, n = a.size(); i < n; i++)sort(a[i]); }\ntemplate<class T> inline void rsort2(vector<vector<T>> &a) { for (int i = 0, n = a.size(); i < n; i++)rsort(a[i]); }\ntemplate<typename A, size_t N, typename T> void fill(A (&a)[N], const T &v) { rep(i, N)a[i] = v; }\ntemplate<typename A, size_t N, size_t O, typename T> void fill(A (&a)[N][O], const T &v) { rep(i, N)rep(j, O)a[i][j] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, typename T> void fill(A (&a)[N][O][P], const T &v) { rep(i, N)rep(j, O)rep(k, P)a[i][j][k] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, typename T> void fill(A (&a)[N][O][P][Q], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)a[i][j][k][l] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, typename T> void fill(A (&a)[N][O][P][Q][R], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)a[i][j][k][l][m] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S, typename T> void fill(A (&a)[N][O][P][Q][R][S], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)rep(n, S)a[i][j][k][l][m][n] = v; }\ntemplate<typename V, typename T> void fill(V &x, const T &val) { x = val; }\ntemplate<typename V, typename T> void fill(vector<V> &vect, const T &val) { for (auto &v: vect) fill(v, val); }\n//@汎用便利関数 入力\ntemplate<typename T = int> T in() {\n    T x;\n    cin >> x;\n    return (x);\n}\nstring sin() { return in<string>(); }\ndouble din() { return in<double>(); }\nll lin() { return in<ll>(); }\n#define na(a, n) rep(i,n) cin >> a[i];\n#define nad(a, n) rep(i,n) cin >> a[i], a[i]--;\n#define na3(a, b, c, n) rep(i, n)cin >> a[i] >> b[i] >> c[i];\n#define add2(a, b, n) rep(i, n)a.pb(in()),b.pb(in());\n#define add2d(a, b, n) rep(i, n)a.pb(in()-1),b.pb(in()-1);\n#define add3(a, b, c, n) rep(i, n)a.pb(in()),b.pb(in()),c.pb(in());\n#define add3d(a, b, c, n) rep(i, n)a.pb(in()-1),b.pb(in()-1),c.pb(in());\n#define na2(a, b, n) rep(i, n)cin >> a[i] >> b[i];\n#define nt(a, h, w) rep(hi,h)rep(wi,w) cin >> a[hi][wi];\n#define ntd(a, h, w) rep(hi,h)rep(wi,w) cin >> a[hi][wi], a[hi][wi]--;\n#define ntp(a, h, w) fill(a,'#');rep(hi,1,h+1)rep(wi,1,w+1) cin >> a[hi][wi];\n#define addn(a, n) a.resize(n);na(a,n);\n#define addnd(a, n) a.resize(n);na(a,n);rep(i,n)a[i]--;\n\n\ntemplate<class T> inline void fin(T s) { cout << s << endl, exit(0); }\n\ntemplate<class T> struct edge {\n    int from, to;\n    T cost;\n    int id;\n    int type;\n    edge(int f, int t, T c = 1, int id = -1, int ty = -1) : from(f), to(t), cost(c), id(id), type(ty) {}\n    bool operator<(const edge &b) const { return cost < b.cost; }\n    bool operator>(const edge &b) const { return cost > b.cost; }\n};\n\ntemplate<typename T> class graph {\nprotected:\n    vector<bool> _used;\npublic :\n    vector<vector<edge<T>>> g;\n    vector<edge<T>> edges;\n    int n, root = -1;\n    graph(int n) : n(n) { g.resize(n), _used.resize(n); }\n    void clear() { g.clear(), edges.clear(); }\n    void resize(int n) {\n        this->n = n;\n        g.resize(n);\n        _used.resize(n);\n    }\n    int size() { return g.size(); }\n    bool isleaf(int v) {\n        assert(root != -1);\n        return g[v].size() == 1 && g[v][0].from != root;\n    }\n    vector<edge<T> > &operator[](int i) { return g[i]; }\n    virtual void add(int from, int to, T cost, int ty) = 0;\n    virtual bool used(edge<T> &e) = 0;\n    virtual bool used(int id) = 0;\n    virtual void del(edge<T> &e) = 0;\n    virtual void del(int id) = 0;\n};\n\ntemplate<class T=int> class undigraph : public graph<T> {\npublic:\n    using graph<T>::g;\n    using graph<T>::n;\n    using graph<T>::edges;\n    using graph<T>::_used;\n    undigraph(int n) : graph<T>(n) {\n    }\n    void add(int f, int t, T cost = 1, int ty = -1) {\n        int id = edges.size();\n        g[f].emplace_back(f, t, cost, id, ty);\n        g[t].emplace_back(t, f, cost, id + 1, ty);\n        edges.emplace_back(f, t, cost, id, ty);\n        edges.emplace_back(t, f, cost, id + 1, ty);\n    }\n    void add(edge<T> &e) {\n        int f = e.from, t = e.to, ty = e.type;\n        T cost = e.cost;\n        add(f, t, cost, ty);\n    }\n    bool used(edge<T> &e) { return _used[e.id]; }\n    bool used(int id) { return _used[id]; }\n    void del(edge<T> &e) { _used[e.id] = _used[e.id ^ 1] = 1; }\n    void del(int id) { _used[id] = _used[id ^ 1] = 1; }\n};\n\ntemplate<typename T =ll> class digraph : public graph<T> {\npublic:\n    using graph<T>::g;\n    using graph<T>::n;\n    using graph<T>::edges;\n    using graph<T>::_used;\n\n    digraph(int n) : graph<T>(n) {}\n    void add(int f, int t, T cost = 1, int ty = -1) {\n\n        int id = edges.size();\n        g[f].emplace_back(f, t, cost, ty, id);\n        edges.emplace_back(f, t, cost, ty, id);\n    }\n    bool used(edge<T> &e) { return _used[e.id]; }\n    bool used(int id) { return _used[id]; }\n    void del(edge<T> &e) { _used[e.id] = _used[e.id ^ 1] = 1; }\n    void del(int id) { _used[id] = _used[id ^ 1] = 1; }\n};\n\n\ntemplate<class T, class U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n\nint n, k, m, h, w, x, y, q;\nint cou;\nvi a, b, c;\n//v3i(dp, 5000, 5001, 2);//コンピューターしかないか\nint dp[5000][5001][2],sub[5001][2];\n//vvi(sub, 5050, 2);\nundigraph<> g(0);\nvi es(5050);\n\nvoid ds(int i, int p) {\n    forg(gi, g[i])if (t != p)ds(t, i);\n    int sum = 0;\n    dp[i][0][a[i] < 0] = a[i];\n    forg(gi, g[i]) {\n            if (t == p)continue;\n            rep(ci, sum + 1) {\n                rep(ct, es[t] + 1) {\n                    rep(ki, 2) {\n                        rep(kt, 2) {\n                            //繋ぐ\n                            if (dp[i][ci][ki] < linf && dp[t][ct][kt] < linf)\n                                chmin(sub[ci + ct][ki || kt], dp[i][ci][ki] + dp[t][ct][kt]);\n                            //切る\n                            if (dp[t][ct][kt] < 0 || (!kt && dp[t][ct][kt] != linf))\n                                chmin(sub[ci + ct + 1][ki], dp[i][ci][ki]);\n                        }\n                    }\n                }\n            }\n            sum += es[t] + 1;\n            rep(j, sum + 1)\n                rep(k, 2) {\n                    dp[i][j][k] = sub[j][k];\n                    sub[j][k] = linf;\n\n                }\n        }\n    es[i] = sum;\n}\nsigned main() {\n    cin >> n;\n    addn(a, n);\n    g.resize(n);\n    rep(i, n - 1) {\n        int f, s;\n        cin >> f >> s;\n        --f, --s;\n        g.add(f, s);\n    }\n    fill(dp, linf);\n    fill(sub, linf);\n    ds(0, -1);\n    rep(c, n)rep(k, 2) {\n            if (k) {\n                if (dp[0][c][k] < 0)fin(c);\n            } else if (dp[0][c][k] != linf)fin(c);\n        }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define all(vec) vec.begin(), vec.end()\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\nconst ll INF = 1LL << 30;\nconst ll LINF = 1LL << 60;\nconst double eps = 1e-9;\nconst ll MOD = 998244353LL;\ntemplate <typename T>\nvoid chmin(T& a, T b) {\n    a = min(a, b);\n};\ntemplate <typename T>\nvoid chmax(T& a, T b) {\n    a = max(a, b);\n};\ntemplate <typename T>\nvector<T> make_v(size_t a) {\n    return vector<T>(a);\n}\ntemplate <typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\ntemplate <typename T, typename V>\ntypename enable_if<is_class<T>::value == 0>::type fill_v(T& t, const V& v) {\n    t = v;\n}\ntemplate <typename T, typename V>\ntypename enable_if<is_class<T>::value != 0>::type fill_v(T& t, const V& v) {\n    for(auto& e : t) {\n        fill_v(e, v);\n    }\n};\nint n;\nvector<ll> a;\nvector<int> siz;\nvector<vector<int>> G;\nvector<vector<vector<ll>>> dp;\nvoid dfs(int i, int p) {\n    dp[i].resize(siz[i] + 10);\n    for(int j = 0; j < siz[i] + 10; j++) {\n        dp[i][j].resize(2, LINF);\n    }\n    int nn = G[i].size() - 1;\n    if(i == 0) {\n        nn++;\n    }\n    auto f = make_v<ll>(nn + 10, siz[i] + 10, 2);\n    fill_v(f, LINF);\n    f[0][0][0] = 0;\n    f[0][0][1] = 0;\n    int id = 1;\n    for(auto e : G[i]) {\n        if(e == p) {\n            continue;\n        }\n        dfs(e, i);\n        siz[i] += siz[e];\n        for(int j = 0; j <= siz[i]; j++) {\n            for(int k = max(0, j - siz[e]); k <= j; k++) {\n                // eを使う\n                if(dp[e][j - k][0] != LINF) {\n                    chmin(f[id][j][0], f[id - 1][k][0] + dp[e][j - k][0]);\n                    chmin(f[id][j][1], f[id - 1][k][1] + dp[e][j - k][0]);\n                }\n                if(dp[e][j - k][1] != LINF) {\n                    chmin(f[id][j][1], f[id - 1][k][0] + dp[e][j - k][1]);\n                }\n                // eを切り離す\n                if(k < j &&\n                   (dp[e][j - k - 1][0] != LINF || dp[e][j - k - 1][1] < 0)) {\n                    chmin(f[id][j][0], f[id - 1][k][0]);\n                    chmin(f[id][j][1], f[id - 1][k][1]);\n                }\n            }\n        }\n        id++;\n    }\n    for(int j = 0; j <= siz[i]; j++) {\n        if(a[i] > 0 && f[nn][j][0] != LINF) {\n            dp[i][j][0] = f[nn][j][0] + a[i];\n        }\n        if(f[nn][j][1] != LINF) {\n            dp[i][j][1] = f[nn][j][1] + a[i];\n        }\n    }\n}\nint main() {\n    cin >> n;\n    a.resize(n);\n    G.resize(n);\n    dp.resize(n);\n    siz.resize(n, 1);\n    for(int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n    for(int i = 0; i < n - 1; i++) {\n        int u, v;\n        cin >> u >> v;\n        --u;\n        --v;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    dfs(0, -1);\n    for(int i = 0; i <= n; i++) {\n        if(dp[0][i][0] != LINF || dp[0][i][1] < 0) {\n            cout << i << endl;\n            return 0;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define _for(i,j,N) for(int i = (j);i < (N);i++)\n#define _rep(i,j,N) for(int i = (j);i <= (N);i++)\n#define ALL(x) x.begin(),x.end()\n#define pb push_back\n#define LL long long\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& v) {\n    _for(i,0,(int)(v.size()-1)) os << v[i] << \" \";\n    os << v[v.size()-1];\n    return os;\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& os,const set<T>& v){\n    for(typename set<T>::iterator it = v.begin();it != v.end();it++)\n    os << *it <<\" \";\n    return os;\n}\nconst int maxn = 5005;\nint N;\nLL A[maxn];\nint vis[maxn];\nvector<int> G[maxn];\nLL res = 0;\n\nstruct Cmp{\n    bool operator()(const int &a,const int &b)const{\n        return A[a] > A[b];\n    }\n};\n\n\nLL mst(int u,int f){\n    priority_queue<int,vector<int>,Cmp> pq;\n    res = A[u];\n    memset(vis,0,sizeof(vis));\n    vis[u] = 1;\n    _for(i,0,G[u].size()){\n        vis[G[u][i]] = 1;\n        pq.push(G[u][i]);\n    }\n    while(!pq.empty()){\n        //cout << A[pq.top()] << endl;\n        if(A[pq.top()] + res > 0) break;\n        u = pq.top();pq.pop();\n        //cout << u << endl;\n        vis[u] = 1;\n        res += A[u];\n        A[u] = 0;\n        _for(i,0,G[u].size()){\n            if(!vis[G[u][i]]){\n                vis[G[u][i]] = 1;\n                pq.push(G[u][i]);\n            }\n        }\n    }\n    return res;\n}\n\nLL dfs(int u){\n    LL ret = A[u];\n    A[u] = 0;\n    _for(i,0,G[u].size()){\n        if(A[G[u][i]] > 0) (ret += dfs(G[u][i]));\n    }\n    return ret;\n}\n\nint main()\n{\n    cin >> N;\n    _rep(i,1,N){\n        cin >> A[i];\n    }\n\n    _for(i,0,N-1){\n        int u,v;\n        cin >> u >> v;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n\n     _rep(i,1,N){\n        if(A[i] > 0){\n            A[i] = dfs(i);\n            //cout << \"i:\"<<i<<\"Ai:\"<<A[i]<<endl;\n        }\n    }\n\n    _rep(i,1,N){\n        if(A[i] < 0){\n            A[i] = mst(i,-1);\n        }\n    }\n\n    int cnt = 0;\n    _rep(i,1,N){\n        if(A[i] > 0 || A[i] < 0) cnt++;\n    }\n\n\n    cout << cnt-1<<endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <deque>\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <iterator>\n#include<iomanip>\n\nusing namespace std;\n\n#define rep(i,a,b) for(int i=(a), i##_len=(b);i<i##_len;i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\n\n#define int ll\n#define SZ(x) ((int)(x).size())\n#define pb push_back\n#define mp make_pair\n\ntypedef long long ll;\n//typedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\ntypedef pair<double, double> pdd;\ntypedef vector<vector<int>> mat;\n//typedef unsigned int uint;\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\n\nint N;\nint A[5010];\nint V[5010];\nvector<int> G[5010];\nint dp[5010][5010][2], temp[5010][2];\n\nvoid dfs(int v, int p)\n{\n\tfor (auto n : G[v])if (p != n)dfs(n, v);\n\n\tint vs = 1;\n\tdp[v][0][A[v] < 0 ? 1 : 0] = A[v];\n\n\tfor (auto n : G[v])if (p != n)\n\t{\n\t\trep(j0, 0, vs)rep(j1, 0, V[n])rep(k0, 0, 2)rep(k1, 0, 2)\n\t\t{\n\t\t\tchmin(temp[j0 + j1][k0 | k1], dp[v][j0][k0] + dp[n][j1][k1]);\n\t\t\tif ((k1 == 0 && dp[n][j1][k1] < INF) || dp[n][j1][k1] < 0)\n\t\t\t{\n\t\t\t\tchmin(temp[j0 + j1 + 1][k0], dp[n][j0][k0]);\n\t\t\t}\n\t\t}\n\n\t\tvs += V[n];\n\t\trep(j, 0, vs)rep(k, 0, 2)\n\t\t{\n\t\t\tdp[v][j][k] = temp[j][k];\n\t\t\ttemp[j][k] = INF;\n\t\t}\n\t}\n\n\tV[v] = vs;\n}\n\nsigned main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tcin >> N;\n\trep(i, 0, N)cin >> A[i];\n\n\tint u, v;\n\trep(i, 0, N - 1)\n\t{\n\t\tcin >> u >> v;\n\t\tu--, v--;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\n\trep(j, 0, N)rep(k, 0, 2)\n\t{\n\t\trep(i, 0, 5010)dp[i][j][k] = INF;\n\t\ttemp[j][k] = INF;\n\t}\n\n\tdfs(0, -1);\n\n\tint ans = N - 1;\n\trep(j, 0, N)\n\t{\n\t\tif (dp[0][j][0] < INF)chmin(ans, j);\n\t\tif (dp[0][j][1] < 0)chmin(ans, j);\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nusing tpl = tuple<ll, ll, ll>;\ntypedef pair<ll,ll> pii;\nconst ll INF = 1LL << 60;\n\nvoid fastStream(){cin.tie(0);std::ios_base::sync_with_stdio(0);}\n\n// TODO dpの値は-INFを初期値とする\n\nll rec1(int, int);\nll rec2(int, int);\nll rec1_sub(int, int, int, int, int);\nll rec2_sub(int, int, int, int, int);\n\nll N;\nll A[5010];\nvector<pii> G[5010];\nvector<pii> Gsub[5010];\n\n// dp1[a][b] => ノードa以下をb本のケーブルを切って構成するとき、\n// 条件を満たし、aの存在する連結成分の値がすべて正であるときの和の最小値\nll dp1[5010][5010]; \n// dp1_sub[a][b] => edge a以降を使う場合の、dp1と同じ条件を満たすような、構成要素の和の最小値\nll dp1_sub[5010][5010];\n\n// dp2[a][b] => ノードa以下をb本のケーブルを切って構成するとき、\n// 条件を満たし、aの存在する連結成分の値の和の最小値\nll dp2[5010][5010]; \n// dp2_sub[a][b] => edge a以降を使う場合の、dp2と同じ条件を満たすような、構成要素の和の最小値\nll dp2_sub[5010][5010];\nint des[5010];\n\nll rec1(int pos, int k){\n    if(dp1[pos][k] > -INF) return dp1[pos][k];\n    // cout << \"rec1 \" << pos << \" \" << k << \" \" << des[pos] << endl;\n    ll res = 0;\n    if(des[pos] == 1){\n        if(k == 0 && A[pos] > 0) res = A[pos];\n        else res = INF;\n    }\n    else if(A[pos] < 0){\n        res = INF;\n    }\n    else{\n        int e_id = G[pos][0].second;\n        res = rec1_sub(e_id, pos, 0, des[pos] - 1, k);\n        if(res != INF) res = res + A[pos];\n    }\n    return dp1[pos][k] = res;\n}\n\nll rec1_sub(int e_id, int pos, int e_num, int left_des, int k){\n    if(dp1_sub[e_id][k] > -INF) return dp1_sub[e_id][k];\n    ll res = INF;\n    int to = G[pos][e_num].first;\n    // cout << \"rec1_sub\" << \" \" << pos << \" \" << to << \" \" << left_des << \" \" << k << endl;\n    int r_des = left_des - des[to];\n    // e_idのエッジを切り離す処理\n    for(int l_k = max(0, k - r_des); l_k <= min(k, des[to]); l_k++){\n        int r_k = k - l_k;\n        // if(r_k > r_des) continue;\n        // 左を切り離す or そのまま使う\n        ll l_res = INF;\n        {\n            // 切らない\n            if(l_k != des[to]){\n                l_res = rec1(to, l_k);\n            }\n            // 切り離す\n            if(l_k > 0 && (rec1(to, l_k - 1) != INF || rec2(to, l_k - 1) < 0)){\n                l_res = 0;\n            }\n        }\n        ll r_res = 0;\n        if(e_num != (int)G[pos].size() - 1){\n            r_res = rec1_sub(G[pos][e_num + 1].second, pos, e_num + 1, left_des - des[to], r_k);\n        }\n        // cout << l_res << \" \" << r_res << endl;\n        res = min(res, l_res + r_res);\n    }\n    return dp1_sub[e_id][k] = res;\n}\n\n\nll rec2(int pos, int k){\n    if(dp2[pos][k] > -INF) return dp2[pos][k];\n    // cout << \"rec2 \" << pos << \" \" << k << \" \" << des[pos] << endl;\n    ll res = 0;\n    if(des[pos] == 1){\n        if(k == 0) res = A[pos];\n        else res = INF;\n    }\n    else{\n        int e_id = G[pos][0].second;\n        res = rec2_sub(e_id, pos, 0, des[pos] - 1, k);\n        if(res != INF) res = res + A[pos];\n    }\n    return dp2[pos][k] = res;\n}\n\n\nll rec2_sub(int e_id, int pos, int e_num, int left_des, int k){\n    if(dp2_sub[e_id][k] > -INF) return dp2_sub[e_id][k];\n    ll res = INF;\n    int to = G[pos][e_num].first;\n    int r_des = left_des - des[to];\n    // cout << \"rec2_sub\" << \" \" << pos << \" \" << to << \" \" << left_des << \" \" << k << endl;\n    // r_k <= r_desを満たすl_kから始める\n    for(int l_k = max(0, k - r_des); l_k <= min(k, des[to]); l_k++){\n        int r_k = k - l_k; \n        // if(r_k > r_des) continue;\n        // 左を切り離す or そのまま使う\n        ll l_res = INF;\n        {\n            // 切らない\n            if(l_k != des[to]){\n                l_res = rec2(to, l_k);\n            }\n            // 切り離す\n            if(l_k > 0 && (rec1(to, l_k - 1) != INF || rec2(to, l_k - 1) < 0)){\n                l_res = min(l_res, 0LL);\n            }\n        }\n        ll r_res = 0;\n        if(e_num != (int)G[pos].size() - 1){\n            r_res = rec2_sub(G[pos][e_num + 1].second, pos, e_num + 1, left_des - des[to], r_k);\n        }\n        if(l_res != INF && r_res != INF)\n            res = min(res, l_res + r_res);\n    }\n    return dp2_sub[e_id][k] = res;\n}\n\n\nint des_cnt(int pos, int par){\n    int cnt = 1;\n    for(pii p : Gsub[pos]){\n        int to = p.first;\n        if(to == par) continue;\n        G[pos].push_back(p);\n        cnt += des_cnt(to, pos);\n    }\n    return des[pos] = cnt;\n}\n\nint main(){\n\n    cin >> N;\n    for(ll i = 0; i < N; i++) cin >> A[i];\n    for(ll i = 0; i < N - 1; i++){\n        ll u, v;\n        cin >> u >> v;\n        u--; v--;\n        Gsub[u].push_back(pii(v, i));\n        Gsub[v].push_back(pii(u, i));\n    }\n\n    for(int i = 0; i < 5010; i++)\n        for(int j = 0; j < 5010; j++)\n            dp1[i][j] = dp2[i][j] = dp1_sub[i][j] = dp2_sub[i][j] = -INF;\n\n    des_cnt(0, -1);\n\n\n    for(int i = 0; i < N; i++){\n        bool ok = false;\n        if(rec1(0, i) != INF) ok = true;\n        if(rec2(0, i) < 0) ok = true;\n        if(ok){\n            cout << i << endl;\n            break;\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nlong int MOD = (int)1e4 + 7;\n\ntemplate<typename T> istream& operator>>(istream &s, vector<T> &v) {\n    for (T &t : v) s >> t;\n    return s;\n}\ntemplate<typename T> ostream& operator<<(ostream &s, const vector<T> &v) {\n    for (const T &t : v) s << t << endl;\n    return s;\n}\ntemplate<typename T> T min(const vector<T>& v) {return *min_element(v.begin(), v.end());}\ntemplate<typename T> T max(const vector<T>& v) {return *max_element(v.begin(), v.end());}\ntemplate<typename T> int min_element(vector<T>& v) {return min_element(v.begin(), v.end()) - v.begin();}\ntemplate<typename T> int max_element(vector<T>& v) {return max_element(v.begin(), v.end()) - v.begin();}\ntemplate<typename T> void sort(vector<T>& v) {sort(v.begin(), v.end());}\ntemplate<typename T> void greatersort(vector<T>& v) {sort(v.begin(), v.end(), greater<>());}\ntemplate<typename T, typename Function> void sort(vector<T>& v, Function func) {sort(v.begin(), v.end(), func);}\ntemplate<typename T> void rsort(vector<T>& v) {sort(v.rbegin(), v.rend());}\ntemplate<typename T> void reverse(vector<T>& v) {reverse(v.begin(), v.end());}\ntemplate<typename T> void unique(vector<T>& v) {v.erase(unique(v.begin(), v.end()), v.end());}\ntemplate<typename T> void nth_element(vector<T>& v, int n) {nth_element(v.begin(), v.begin() + n, v.end());}\ntemplate<typename T> bool next_permutation(vector<T>& v) {return next_permutation(v.begin(), v.end());}\ntemplate<typename T> int find(vector<T>& v, T t) {return find(v.begin(), v.end(), t) - v.begin();}\ntemplate<typename T> int in(vector<T> v, T t) {return find(v, t) != int(v.size());}\ntemplate<typename T> int lower_bound(vector<T>& v, T t) {return lower_bound(v.begin(), v.end(), t) - v.begin();}\ntemplate<typename T> int upper_bound(vector<T>& v, T t) {return upper_bound(v.begin(), v.end(), t) - v.begin();}\ntemplate<typename T> T accumulate(const vector<T>& v, function<T(T, T)> func = plus<T>()) {return accumulate(v.begin(), v.end(), T(), func);}\ntemplate<typename T> void adjacent_difference(vector<T>& v) {adjacent_difference(v.begin(), v.end(), v.begin());}\ntemplate<typename T> void adjacent_difference(vector<T>& v, vector<T>& u) {adjacent_difference(v.begin(), v.end(), u.begin());}\ntemplate<typename T> vector<T> partial_sum(const vector<T>& v) {\n    vector<T> u(v.size());\n    partial_sum(v.begin(), v.end(), u.begin());\n    return u;\n}\\\ntemplate<typename T> T inner_product(vector<T>& v, vector<T>& u) {return inner_product(v.begin(), v.end(), u.begin(), T(0));}\ntemplate<typename T> int count(const vector<T>& v, T t) {return count(v.begin(), v.end(), t);}\ntemplate<typename T, typename Function> int count_if(const vector<T>& v, Function func) {return count_if(v.begin(), v.end(), func);}\ntemplate<typename T, typename Function> void remove_if(vector<T>& v, Function func) {v.erase(remove_if(v.begin(), v.end(), func), v.end());}\ntemplate<typename T, typename Function> bool all_of(vector<T> v, Function func) {return all_of(v.begin(), v.end(), func);}\ntemplate<typename T, typename Function> bool any_of(vector<T> v, Function func) {return any_of(v.begin(), v.end(), func);}\ntemplate<typename T, typename Function> bool none_of(vector<T> v, Function func) {return none_of(v.begin(), v.end(), func);}\ntemplate<typename T> vector<T> subvector(vector<T>& v, int a, int b) {return vector<T>(v.begin() + a, v.begin() + b);}\ntemplate<typename T> int kinds(const vector<T>& v) {return set<T>(v.begin(), v.end()).size();}\ntemplate<typename T> map<T, int> count_kinds(const vector<T>& v) {\n    map<T, int> res;\n    for (const auto& i : v) ++res[i];\n    return res;\n}\ntemplate<typename T> void iota(vector<T>& v, T t = 0) {iota(v.begin(), v.end(), t);}\ntemplate<typename T> bool is_sorted(const vector<T>& v) {return is_sorted(v.begin(), v.end());}\nint plusVector(vector<int>& v, int n) {int r = 0; for (int i = 0; i < n; ++i) {r += v[i];} return r;}\nvoid yesno(bool b) {if (b) {cout << \"yes\" << endl;} else {cout << \"no\" << endl;}}\nvoid YesNo(bool b) {if (b) {cout << \"Yes\" << endl;} else {cout << \"No\" << endl;}}\nvoid YESNO(bool b) {if (b) {cout << \"YES\" << endl;} else {cout << \"NO\" << endl;}}\nlong addMOD(long a, long b) {return (a + b) % MOD;}\nlong subMOD(long a, long b) {return (a + MOD - b) % MOD;}\nlong mulMOD(long a, long b) {return ((a % MOD) * (b % MOD)) % MOD;}\nlong long invMOD(long long a, long long m) {long long b = m, u = 1, v = 0;while (b) {long long t = a / b;a -= t * b; swap(a, b);u -= t * v; swap(u, v);}u %= m;if (u < 0) u += m;return u;}\ndouble PI = 3.1415926535897932384626433832795;\n\n\nint main() {\n    long N;\n    cin >> N;\n    std::random_device rnd;\n    std::mt19937 mt(rnd());\n    std::uniform_int_distribution<> rand(0, N);\n    cout << rand(mt) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nconstexpr ll inf = 1e9;\n\nint main() {\n    int n; cin >> n;\n    vector<int> a(n);\n    for(int i = 0; i < n; ++i) {\n        cin >> a[i];\n    }\n    vector<vector<int>> g(n);\n    for(int i = 0; i < n - 1; ++i) {\n        int u, v; cin >> u >> v;\n        g[u - 1].push_back(v - 1);\n        g[v - 1].push_back(u - 1);\n    }\n\n    // 1 => including computer\n    vector<vector<vector<ll>>> dp(n, vector<vector<ll>>(n + 1, vector<ll>(2, inf)));\n    vector<int> sz(n);\n    function<void(int, int)> solve = [&] (int v, int p) {\n        sz[v] += 1;\n        for(auto to : g[v]) {\n            if(to == p) continue;\n            solve(to, v);\n            sz[v] += sz[to];\n        }\n        dp[v][0][a[v] < 0] = a[v];\n        int cur_sz = 1;\n        for(auto to : g[v]) {\n            if(to == p) continue;\n            vector<vector<ll>> ndp(n + 1, vector<ll>(2, inf));\n            for(int i = 0; i <= cur_sz - 1; ++i) {\n                for(int c1 = 0; c1 < 2; ++c1) {\n                if(dp[v][i][c1] == inf) continue;\n                    for(int j = 0; j <= sz[to] - 1; ++j) {\n                        for(int c2 = 0; c2 < 2; ++c2) {\n                            if(dp[to][j][c2] == inf) continue;\n                            // connect\n                            if(i + j == 0) {\n                                ndp[i + j][max(c1, c2)] = dp[v][i][c1] + dp[to][j][c2];\n                            } else {\n                                ndp[i + j][max(c1, c2)] = min(ndp[i + j][max(c1, c2)], dp[v][i][c1] + dp[to][j][c2]);\n                            }\n                            // cut\n                            if(c2 == 0 || dp[to][j][c2] < 0) {\n                                ndp[i + j + 1][c1] = min(ndp[i + j + 1][c1], dp[v][i][c1]);\n                            }\n                        }\n                    }\n                }\n            }\n            dp[v] = move(ndp);\n            cur_sz += sz[to];\n        }\n    };\n    solve(0, -1);\n\n    int ans = inf;\n    for(int i = 0; i <= n; ++i) {\n        if(dp[0][i][0] != inf || dp[0][i][1] < 0) {\n            ans = i;\n            break;\n        }\n    }\n\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <queue>\n#define MAX_N 5005\n#define INF 8000000000000\n\nusing namespace std;\ntypedef long long ll;\n\nint N;\nll A[MAX_N];\nvector<int> G[MAX_N];\nll dp[2][MAX_N][MAX_N];//i,v,k 親成分以外が条件を満たす/親成分すべて正　連結成分の数\nll dpn[2][MAX_N];\n\nvoid show(){\n    //debug\n    for(int n=0;n<N;n++){\n        for(int k=0;k<=N;k++){\n            if(dp[0][n][k]==INF){cout<<\"INF \";continue;}\n            cout<<dp[0][n][k]<<\" \";\n        }\n        cout<<endl;\n    }\n    cout<<endl;\n    for(int n=0;n<N;n++){\n        for(int k=0;k<=N;k++){\n            if(dp[1][n][k]==INF){cout<<\"INF \";continue;}\n            cout<<dp[1][n][k]<<\" \";\n        }\n        cout<<endl;\n    }\n    cout<<\"--------------------------------\"<<endl;\n    \n}\n\nint dfs(int p,int n){//親ノード、今のノード\n    int count = 0;\n    int K_n=1,K_c=0;\n    for(int i = 0;i < G[n].size();i++){\n        int c = G[n][i];\n        if(c==p)continue;\n        count++;\n        K_c = dfs(n,c);\n        if(count==1){\n            for(int k = 1;k <= K_n+K_c;k++){\n                //nをk個目の独立した連結成分にする場合\n                if(dp[0][c][k-1]<0||dp[1][c][k-1]!=INF){\n                    dp[0][n][k]=min(dp[0][n][k],A[n]);\n                    if(A[n]>0)\n                        dp[1][n][k]=min(dp[1][n][k],A[n]);\n                }\n                //cの連結成分につなげる場合\n                if(dp[0][c][k]!=INF)\n                    dp[0][n][k]=min(dp[0][n][k],dp[0][c][k]+A[n]);\n                if(A[n]>0&&dp[1][c][k]!=INF)\n                    dp[1][n][k]=min(dp[1][n][k],dp[1][c][k]+A[n]);\n            }\n        }else{\n            for(int k = 0;k <= K_n+K_c;k++){\n                dpn[0][k]=INF;\n                dpn[1][k]=INF;\n            }\n            for(int k_n = 1;k_n <= K_n;k_n++){\n                if(dp[0][n][k_n]==INF)continue;\n                for(int k_c = 1;k_c <= K_c;k_c++){\n                    //cのノードをnに繋げない場合\n                    if(dp[0][c][k_c]<0||dp[1][c][k_c]!=INF){//cのノード以下が問題文の条件を満たしていれば、繋がなくても良い。\n                        dpn[0][k_c+k_n] = min(dpn[0][k_c+k_n],dp[0][n][k_n]);\n                        dpn[1][k_c+k_n] = min(dpn[1][k_c+k_n],dp[1][n][k_n]);\n                    }\n                    //cをnの連結成分につなげる場合\n                    if(dp[0][c][k_c]!=INF){\n                        dpn[0][k_c+k_n-1]=min(dpn[0][k_c+k_n-1],dp[0][c][k_c]+dp[0][n][k_n]);\n                    }\n                    if(dp[1][c][k_c]!=INF&&dp[1][n][k_n]!=INF){\n                        dpn[1][k_c+k_n-1]=min(dpn[1][k_c+k_n-1],dp[1][c][k_c]+dp[1][n][k_n]);\n                    }\n                }\n            }\n            for(int k = 0;k <= K_n+K_c;k++){\n                dp[0][n][k]=dpn[0][k];\n                dp[1][n][k]=dpn[1][k];\n            }\n            \n        }\n        K_n += K_c;\n    }\n    if(p>=0&&count==0){\n        dp[0][n][1]=A[n];\n        if(A[n]>0){\n            dp[1][n][1]=A[n];\n        }\n    }\n//    cout<<n<<endl;\n//    show();\n    return K_n;\n}\n\nint main() {\n    cin>>N;\n    for(int i=0;i<N;i++){\n        for(int j=0;j<=N;j++){\n            dp[0][i][j]=INF;\n            dp[1][i][j]=INF;\n        }\n        cin>>A[i];\n    }\n    for(int i=0;i<N-1;i++){\n        int a,b;\n        cin>>a>>b;\n        a--,b--;\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n    dfs(-1,0);\n    int ans;\n    \n    \n    \n    for(int k=1;k<=N;k++){\n        if(dp[0][0][k]<0){\n            cout<<k-1<<endl;\n            //            cout<<\"debug 1\"<<endl;\n            return 0;\n        }\n        if(dp[1][0][k]!=INF&&dp[1][0][k]>0){\n            cout<<k-1<<endl;\n            //            cout<<\"debug 2:\"<<dp[1][0][k]<<endl;\n            return 0;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <fstream>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <complex>\n#include <iomanip>\n#include <stdio.h>\n#include <string.h>\n#include <random>\n#include <functional>\n\nusing std::cin;\nusing std::cout;\nusing std::cerr;\nusing std::endl;\n\nusing std::map;\nusing std::set;\nusing std::bitset;\nusing std::vector;\nusing std::string;\nusing std::multimap;\nusing std::multiset;\nusing std::deque;\nusing std::queue;\nusing std::stack;\nusing std::pair;\nusing std::iterator;\n\nusing std::sort;\nusing std::stable_sort;\nusing std::reverse;\nusing std::max_element;\nusing std::min_element;\nusing std::unique;\nusing std::ios_base;\nusing std::swap;\nusing std::fill;\n\nusing std::setprecision;\nusing std::fixed;\n\nlong long min(long long a, long long b) {return a < b ? a : b;}\nlong long min(int a, long long b) {return a < b ? a : b;}\nlong long min(long long a, int b) {return a < b ? a : b;}\nlong long min(int a, int b) {return a < b ? a : b;}\n\nlong long max(long long a, long long b) {return a > b ? a : b;}\nlong long max(int a, long long b) {return a > b ? a : b;}\nlong long max(long long a, int b) {return a > b ? a : b;}\nlong long max(int a, int b) {return a > b ? a : b;}\n\n#define int long long\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<long long> vl;\ntypedef string S;\n\n#define F(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define fi first\n#define se second\n#define re return\n#define all(x) (x).begin(), (x).end()\n\nconst long long INF = 1e18;\nconst int N = 10110;\nconst int MOD = 1e9 + 7;\nconst double eps = 1e-8;\n\nint n;\nint a[N];\nvector<int> graph[N];\nint dp[2][N][N / 2];\nint last_dinamics[N];\nint last_state[N];\nint tmp = 0;\n\nvoid Merge(int p1, int p2)\n{\n    for (int a = 0; a <= last_state[p1]; a++)\n    {\n        for (int b = 0; b <= last_state[p2]; b++)\n        {\n            dp[0][tmp][a + b] = min(dp[0][tmp][a + b], dp[0][p1][a] + dp[0][p2][b]);\n            if (dp[0][p2][b] < INF) dp[0][tmp][a + b + 1] = min(dp[0][tmp][a + b + 1], dp[0][p1][a]);\n            if (dp[1][p2][b] < 0) dp[0][tmp][a + b + 1] = min(dp[0][tmp][a + b + 1], dp[0][p1][a]);\n            dp[1][tmp][a + b] = min(dp[1][tmp][a + b], min(dp[0][p1][a], dp[1][p1][a]) + min(dp[0][p2][b], dp[1][p2][b]));\n            if (dp[0][p2][b] < INF) dp[1][tmp][a + b + 1] = min(dp[1][tmp][a + b + 1], min(dp[0][p1][a], dp[1][p1][a]));\n            if (dp[1][p2][b] < 0) dp[1][tmp][a + b + 1] = min(dp[1][tmp][a + b + 1], min(dp[0][p1][a], dp[1][p1][a]));\n        }\n    }\n    last_state[tmp] = last_state[p1] + last_state[p2] + 1;\n}\n\nvoid dfs(int v, int parent)\n{\n    int merge1 = tmp;\n    dp[0][tmp][0] = 0, dp[1][tmp][0] = 0;\n    tmp++;\n    for (auto u : graph[v]) if (u != parent)\n    {\n        dfs(u, v);\n        int merge2 = last_dinamics[u];\n        Merge(merge1, merge2);\n        merge1 = tmp;\n        tmp++;\n    }\n    tmp--;\n    for (int i = 0; i < n + 100; i++)\n    {\n        dp[1][tmp][i] = min(dp[1][tmp][i] + a[v], INF);\n        dp[0][tmp][i] = min(dp[0][tmp][i] + a[v], INF);\n    }\n    if (a[v] < 0)\n    {\n        for (int i = 0; i < n + 100; i++) dp[0][tmp][i] = INF;\n    }\n    last_dinamics[v] = tmp;\n    tmp++;\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n;\n    for (int i = 0; i < 2 * n + 100; i++)\n    {\n        for (int j = 0; j < n + 100; j++)\n        {\n            dp[0][i][j] = INF, dp[1][i][j] = INF;\n        }\n    }\n    for (int i = 0; i < n; i++)\n    {\n        cin >> a[i];\n    }\n    for (int i = 0; i + 1 < n; i++)\n    {\n        int v, u;\n        cin >> v >> u;\n        v--, u--;\n        graph[v].push_back(u);\n        graph[u].push_back(v);\n    }\n    dfs(0, -1);\n    long long ans = n - 1;\n    for (int i = 0; i < n - 1; i++)\n    {\n        //cout << dp[1][tmp - 1][i] << \" \" << dp[0][tmp - 1][i] << \"\\n\";\n        if (dp[1][tmp - 1][i] < 0) ans = min(ans, i);\n        if (dp[0][tmp - 1][i] < INF) ans = min(ans, i);\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n#define taskname \"A\"\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> ii;\nconst int maxn = 5e3 + 5;\nconst int logn = log2(maxn) + 1;\nconst int inf = 1e9 + 1;\nint n,a[maxn];\nvector<int> adj[maxn];\nll dp[maxn][maxn];\nbool dp1[maxn][maxn];\nll tmp[maxn];\nbool tmp1[maxn];\nint sub[maxn];\n\nvoid dfs(int u , int par){\n    dp1[u][0] = (a[u] > 0);\n    dp[u][0] = a[u];\n    sub[u] = 1;\n    for(auto c : adj[u]){\n        if(c == par)continue;\n        dfs(c , u);\n        fill_n(tmp,maxn,1e18);\n        fill_n(tmp1,maxn,0);\n        for(int i = 0 ; i <= sub[u] ; ++i){\n            for(int j = 0 ; j <= sub[c] ; ++j){\n                if(dp[c][j] < 0 || dp1[c][j])tmp[i + j + 1] = min(tmp[i + j + 1] , dp[u][i]);\n                tmp[i + j] = min(tmp[i + j] , dp[u][i] + dp[c][j]);\n                if(dp1[c][j] && dp1[u][i])tmp1[i + j] = 1;\n                if(dp1[u][i] && (dp[c][j] < 0 || dp1[c][j]))tmp1[i + j + 1] = 1;\n            }\n        }\n        sub[u] += sub[c];\n        for(int i = 0 ; i <= sub[u] ; ++i){\n            dp[u][i] = tmp[i];\n            dp1[u][i] = tmp1[i];\n        }\n    }\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if(fopen(taskname\".INP\" , \"r\")){\n        freopen(taskname\".INP\",\"r\",stdin);\n        freopen(taskname\".OUT\",\"w\",stdout);\n    }\n    fill_n(&dp[0][0],maxn*maxn,1e18);\n    memset(dp1,0,sizeof dp1);\n    cin >> n;\n    for(int i = 1 ; i <= n ; ++i)cin >> a[i];\n    for(int i = 1 ; i < n ; ++i){\n        int u , v;cin >> u >> v;\n        adj[u].pb(v);adj[v].pb(u);\n    }\n    dfs(1,0);\n//    cout << dp[1][2] << \" \" << dp1[1][2] << endl;\n    for(int i = 0 ; i <= n ; ++i){\n        if(dp[1][i] < 0 || dp1[1][i])return cout << i , 0;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\nint N;\nint s[5010] = {};\nll A[5010] = {},dp1[5010][5010] = {},dp2[5010][5010] = {};\n//1:その点を根とした部分木の各点の値がすべて正\n//2:負が含まれる\nconst ll inf = 2e18;\nvector<vector<int>> v(5010);\n\nvoid dfs(int n,int m){\n    s[n] = 1;\n    if(A[n]>0) dp1[n][0] = A[n];\n    dp2[n][0] = A[n];\n    for(auto x:v[n]){\n        if(x==m) continue;\n        dfs(x,n);\n        vector<ll> merge1(N+1,inf),merge2(N+1,inf);\n        for(int i=0;i<s[n];i++){\n            for(int j=0;j<s[x];j++){\n                if(dp1[x][j]!=inf){\n                    merge1[i+j] = min(merge1[i+j],dp1[n][i]+dp1[x][j]);\n                    merge1[i+j+1] = min(merge1[i+j+1],dp1[n][i]);\n                    merge2[i+j+1] = min(merge2[i+j+1],dp2[n][i]);\n                }\n                if(dp2[x][j]!=inf){\n                    merge2[i+j] = min(merge2[i+j],dp2[n][i]+dp2[x][j]);\n                    if(dp2[x][j]<0){\n                        merge2[i+j+1] = min(merge2[i+j+1],dp2[n][i]);\n                        merge1[i+j+1] = min(merge1[i+j+1],dp1[n][i]);\n                    }\n                }\n            }\n        }\n        for(int i=0;i<N;i++){dp1[n][i] = merge1[i]; dp2[n][i] = merge2[i];}\n        s[n] += s[x];\n    }\n}\n\nint main(){\n    cin >> N;\n    for(int i=1;i<=N;i++) cin >> A[i];\n    int a,b;\n    for(int i=1;i<=N-1;i++){\n        cin >> a >> b;\n        v[a].push_back(b);\n        v[b].push_back(a);\n    }\n    for(int i=1;i<=N;i++) for(int j=0;j<=N;j++) {dp1[i][j] = inf; dp2[i][j] = inf;}\n    dfs(1,0);\n    int ans = N;\n    for(int i=N-1;i>=0;i--){\n        if(dp1[1][i]!=inf) ans = i;\n        if(dp2[1][i]<0) ans = i;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <vector>\n\nusing namespace std;\n\nconst int N = 5011;\nconst long long oo = 1e18;\n\nint n,sz[N];\nvector <int> e[N],children[N];\nlong long a[N],f[N][N],w[N],tmp[N];\nbool g[N][N],g1[N];\n\nvoid dfs(int u,int p = 0){\n    w[u] = a[u];\n    sz[u] = 1;\n    \n    for(auto &v : e[u]){\n        if(v == p) continue;\n        dfs(v,u);\n        w[u] += w[v];\n        children[u].push_back(v);\n        sz[u] += sz[v];\n    }\n    \n    f[u][0] = w[u];\n\n    if(sz[u] <= 1){\n        g[u][0] = a[u] > 0;\n    }else{\n        int c = 0;\n        tmp[0] = a[u];\n        g1[0] = a[u] > 0;\n        for(int i = 0; i <= sz[i]; ++i) f[u][i] = oo;\n\n        for(auto &v: children[u]){\n            for(int i = 0; i <= c + sz[v]; ++i) f[u][i] = oo,g[u][i] = 0;\n\n            for(int i = 0; i <= c; ++i){\n                for(int j = 0; j <= sz[v]; ++j){\n                    f[u][i + j] = min(f[u][i + j],tmp[i] + f[v][j]);\n                    if(!g[u][i + j]) g[u][i + j] = (g1[i] && g[v][j]);\n                }\n            }\n            c += sz[v];\n            for(int i = 0; i <= c + sz[v]; ++i) tmp[i] = f[u][i],g1[i] = g[u][i];\n        }\n    }\n    \n    f[u][sz[u]] = oo;\n    g[u][sz[u]] = 0;\n    for(int i = sz[u] - 1; i >= 0; --i){\n        if(f[u][i] < 0 || g[u][i]){\n            f[u][i + 1] = min(f[u][i + 1],0LL);\n            g[u][i + 1] = 1;\n        }\n    }\n\n    /*for(int i = 0; i <= sz[u]; ++i){\n        cout << \"f[\"<<u<<\"][\"<<i<<\"] = \" << f[u][i] << endl;\n        cout << \"g[\"<<u<<\"][\"<<i<<\"] = \" << g[u][i] << endl;\n    }*/\n}\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie();\n\n    cin >> n;\n\n    for(int i = 1; i <= n; ++i) cin >> a[i];\n\n    for(int i = 1; i < n; ++i){\n        int u,v;\n        cin >> u >> v;\n        e[u].push_back(v);\n        e[v].push_back(u);\n    }\n\n    dfs(1);\n\n    for(int i = 0; i < n; ++i){\n        if(f[1][i] < 0 || g[1][i]){\n            cout << i;\n            break;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FAST ios_base::sync_with_stdio(false); cin.tie(0);\n#define pb push_back\n#define eb emplace_back\n#define ins insert\n#define f first\n#define s second\n#define cbr cerr << \"hi\\n\"\n#define mmst(x, v) memset((x), v, sizeof ((x)))\n#define siz(x) ll(x.size())\n#define all(x) (x).begin(), (x).end()\n#define lbd(x,y) (lower_bound(all(x),y)-x.begin())\n#define ubd(x,y) (upper_bound(all(x),y)-x.begin())\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());    //can be used by calling rng() or shuffle(A, A+n, rng)\ninline long long rand(long long x, long long y) { return (rng() % (y+1-x)) + x; } //inclusivesss\nstring inline to_string(char c) {string s(1,c);return s;} template<typename T> inline T gcd(T a,T b){ return a==0?llabs(b):gcd(b%a,a); }\n\ntypedef long long ll; \ntypedef long double ld;\n#define FOR(i,s,e) for(ll i=s;i<=ll(e);++i)\n#define DEC(i,s,e) for(ll i=s;i>=ll(e);--i)\ntypedef pair<ll,ll>pi; typedef pair<ll,pi>spi; typedef pair<pi,pi>dpi;\n\n#define LLINF ((long long)1e18)\n#define INF int(1e9+1e6)\n#define MAXN (5006)\nll n,A[MAXN],dp[MAXN][MAXN][2],sz[MAXN];// if 0 then max, 1 then min\nvector<int>v[MAXN];\nvoid dfs(ll x,ll p){\n\tsz[x]=1;\n\tdp[x][0][1]=A[x];\n\tfor(auto i:v[x]) if(i^p) dfs(i,x), sz[x]+=sz[i];\n\tll cur = 1;\n\tif(A[x]>0)dp[x][0][0]=1;\n\tfor(auto i:v[x]) if(i^p) {\n\t\tcur += sz[i];\n\t\tDEC(j,cur,0){\n\t\t\tif(dp[x][j][1]<LLINF) dp[x][j][1] += dp[i][0][1];\n\t\t\tdp[x][j][0] &= dp[i][0][0];\n\t\t\tFOR(k,1,min(j,sz[i])){\n\t\t\t\tdp[x][j][1]=min(dp[x][j][1],dp[x][j-k][1]+dp[i][k][1]);\n\t\t\t\tif(dp[i][k-1][0]) dp[x][j][1]=min(dp[x][j][1],dp[x][j-k][1]);\n\t\t\t\tdp[x][j][0]|=dp[x][j-k][0]&dp[i][k][0];\n\t\t\t\tif(dp[i][k-1][1] < 0) dp[x][j][0]|=dp[x][j-k][0];\n\t\t\t}\n\t\t}\n\t}\n\t// if(A[x]>0){\n\t\t// dp[x][0][0]=A[x];\n\t\t// cur=1;\n\t\t// for(auto i:v[x]) if(i^p) {\n\t\t\t// cur+=sz[i];\n\t\t\t// DEC(j,cur,0){\n\t\t\t\t// dp[x][j][0] += dp[i][0][0], dp[x][j][0]=min(dp[x][j][0],LLINF);\n\t\t\t\t// FOR(k,1,min(j,sz[i])){\n\t\t\t\t\t// dp[x][j][0]=min(dp[x][j][0],dp[x][j-k][0]+dp[i][k][0]);\n\t\t\t\t\t// if(dp[i][k-1][1] < 0) dp[x][j][0]=min(dp[x][j][0],dp[x][j-k][0]);\n\t\t\t\t// }\n\t\t\t// }\n\t\t// }\n\t// }\n}\nint main(){\n\tFAST\n\tcin>>n;\n\tFOR(i,1,n)cin>>A[i];\n\tFOR(i,2,n){\n\t\tll a,b;cin>>a>>b;\n\t\tv[a].eb(b),v[b].eb(a);\n\t}\n\tFOR(i,0,MAXN-1)FOR(j,0,MAXN-1)dp[i][j][1]=LLINF;\n\tdfs(1,1);\n\tll ans = n-1;\n\tFOR(k,0,n-1) if(dp[1][k][1] < 0) ans = min(ans, k);\n\tFOR(k,0,n-1) if(dp[1][k][0]) ans = min(ans, k);\n\tcout<<ans<<'\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<ll,pll> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-9;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nint n;\nvl a;\nvvl g,dp[2];\n\nint dfs(int v,int p){\n\tint S=1;\n\tfor(auto u:g[v]) if(u!=p){\n\t\tint T=dfs(u,v);\n\t\tvl DP[2];\n\t\tDP[0]=DP[1]=vl(S+T,INF);\n\t\tfor(int i=0;i<S;i++) for(int j=0;j<T;j++) for(int t=0;t<4;t++){\n\t\t\tint x=t/2,y=t%2;\n\t\t\tDP[x|y][i+j]=min(DP[x|y][i+j],dp[x][v][i]+dp[y][u][j]);\n\t\t\tif(y==0&&dp[y][u][j]<INF||dp[y][u][j]<0) DP[x][i+j+1]=min(DP[x][i+j+1],dp[x][v][i]);\n\t\t}\n\t\tdp[0][v]=DP[0];dp[1][v]=DP[1];\n\t\tS+=T;\n\t}\n\treturn S;\n}\n\nint main(){\n\tcin>>n;\n\ta=vl(n);\n\tdp[0]=dp[1]=g=vvl(n);\n\tfor(int i=0;i<n;i++){\n\t\tcin>>a[i];\n\t\tdp[(a[i]<0?1:0)][i].push_back(a[i]);\n\t\tdp[(a[i]<0?0:1)][i].push_back(INF);\n\t}\n\tfor(int i=1;i<n;i++){\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tu--;v--;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\tdfs(0,-1);\n\tfor(int i=0;i<n;i++) if(dp[0][0][i]<INF||dp[1][0][i]<0){\n\t\tcout<<i<<endl;\n\t\treturn 0;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n#define reps(i, n) for (int i = 1; i <= (int) (n); i++)\n#define all(x) (x).begin(), (x).end()\n#define uniq(x) (x).erase(unique(all(x)), (x).end())\n#define bit(n) (1LL << (n))\n#define cdiv(a, b) (((a) - 1) / (b) + 1)\n#define dump(x) cerr << #x \" = \" << (x) << endl\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing pint = pair<int, int>;\nusing vpint = vector<pint>;\ntemplate<typename T> using priority_queue_rev = priority_queue<T, vector<T>, greater<T>>;\nconstexpr double PI = 3.1415926535897932384626433832795028;\nconstexpr int DY[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nconstexpr int DX[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nint gcd(int a, int b) {\n    while (b) { swap(a %= b, b); }\n    return a;\n}\nint lcm(int a, int b) { return a / gcd(a, b) * b; }\nint sgn(int x) { return (x > 0) - (x < 0); }\ntemplate<typename T> void fin(T mes) {\n    cout << mes << endl;\n    exit(0);\n}\ntemplate<typename T, typename U> bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &rhs) {\n    os << \"(\" << rhs.first << \", \" << rhs.second << \")\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\nstruct setup {\n    static constexpr int PREC = 20;\n\n    setup() {\n        cout << fixed << setprecision(PREC);\n        cerr << fixed << setprecision(PREC);\n    };\n} setup;\n\nint N;\nint A[5500];\nint U[5500], V[5500];\nvint G[5500];\npair<vint, int> dfs(int cur, int par) {\n    vint x = {A[cur]};\n    int cut = 0;\n    for (int to:G[cur]) {\n        if (to == par) { continue; }\n        pair<vint, int> tmp = dfs(to, cur);\n        vint nxt = tmp.first;\n        int ccut = tmp.second;\n        vint y(x.size() + nxt.size(), LLONG_MAX);\n        if (ccut >= 0) { rep(i, x.size()) { y[i + ccut + 1] = x[i]; }}\n        rep(i, x.size()) {\n            rep(j, nxt.size()) {\n                chmin(y[i + j], x[i] + nxt[j]);\n                if (nxt[j] < 0) { chmin(y[i + j + 1], x[i]); }\n            }\n        }\n        x = y;\n        reps(i, x.size() - 1) { chmin(x[i], x[i - 1]); }\n        int pl = -1;\n        for (int i = nxt.size() - 1; i >= 0; i--) { if (nxt[i] < 0) { pl = i; }}\n        assert(pl >= 0);\n        if (ccut >= 0) { cut += min(ccut, pl + 1); }\n        else { cut += pl + 1; }\n    }\n    if (A[cur] < 0) { cut = -1; }\n    return {x, cut};\n}\n\nsigned main() {\n    cin >> N;\n    rep(i, N) { cin >> A[i]; }\n    rep(i, N - 1) {\n        cin >> U[i] >> V[i];\n        U[i]--, V[i]--;\n        G[U[i]].push_back(V[i]), G[V[i]].push_back(U[i]);\n    }\n    pair<vint, int> res = dfs(0, -1);\n    int ans = N;\n    if (A[0] > 0) { ans = res.second; }\n    rep(i, res.first.size()) { if (res.first[i] < 0) { chmin(ans, i); }}\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\nconst int64 mod = 1e9+7;\n\nint32 N;\nvector<int64> A;\nvector<int32> G[5050];\nvector<int32> sz;\nvector<vector<int64>> dp[2];\n\nvoid init(int32 v, int32 p){\n\tREP(i, G[v].size()){\n\t\tif(G[v][i] == p) continue;\n\t\tinit(G[v][i], v);\n\t\tsz[v] += sz[G[v][i]];\n\t}\n}\n\nvoid dfs(int32 v, int32 p){\n\tREP(i, G[v].size()){\n\t\tif(G[v][i] == p) continue;\n\t\tdfs(G[v][i], v);\n\t}\n\tvector<vector<int64>> dp2(2, vector<int64>(N+1, INF_LL));\n\tif(A[v] > 0)\n\t\tdp2[0][0] = A[v];\n\tdp2[1][0] = A[v];\n\tint32 now = 1;\n\tREP(i, G[v].size()){\n\t\tif(G[v][i] == p) continue;\n\t\tvector<vector<int64>> dp3(2, vector<int64>(N+1, INF_LL));\n\t\tint32 u = G[v][i];\n\t\tREP(l, 2){\n\t\t\tif(l == 0 && A[v] < 0) continue;\n\t\t\tREP(j, sz[G[v][i]]){\n\t\t\t\tREP(k, now){\n\t\t\t\t\tif(dp[0][u][j] != INF_LL)\n\t\t\t\t\t\tchmin(dp3[l][k+j], dp2[l][k]+dp[0][u][j]);\n\t\t\t\t\tif(dp[1][u][j] != INF_LL)\n\t\t\t\t\t\tchmin(dp3[l|1][k+j], dp2[l][k]+dp[1][u][j]);\n\t\t\t\t\tif(dp[1][u][j] < 0)\n\t\t\t\t\t\tchmin(dp3[l][k+j+1], dp2[l][k]);\n\t\t\t\t\tif(dp[0][u][j] != INF_LL){\n\t\t\t\t\t\tchmin(dp3[l][k+j+1], dp2[l][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswap(dp2, dp3);\n\t\tnow += sz[u];\n\t}\n\tREP(i, sz[v]){\n\t\tdp[0][v][i] = dp2[0][i];\n\t\tdp[1][v][i] = dp2[1][i];\n\t}\n}\n\nint main(void){\n\tcin >> N;\n\tA.resize(N);\n\tsz.resize(N, 1);\n\tREP(i, 2)\n\t\tdp[i] = vector<vector<int64>>(N+1, vector<int64>(N+1, INF_LL));\n\tREP(i, N) cin >> A[i];\n\tREP(i, N-1){\n\t\tint32 u, v;\n\t\tcin >> u >> v;u--;v--;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tinit(0, -1);\n\tdfs(0, -1);\n\tREP(i, N+1){\n\t\tif(dp[1][0][i] < 0 || dp[0][0][i] != INF_LL){\n\t\t\tcout << i << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n//template\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(a);i>(b);i--)\ntypedef long long int ll;\ntypedef pair<ll, ll> P; typedef pair<ll, P> T;\ntypedef complex<double> com;\nstruct edge { int u, v, cost; };\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\nll gcd(ll a, ll b) { if (!b)return a; else return gcd(b, a % b); }\nconst int inf = INT_MAX / 2; const ll INF = LLONG_MAX / 2;\nint mod = 1e9 + 7; //998244353;\nstruct Mint {\n\tint val;\n\tMint inv() const {\n\t\tunsigned tmp, a = val, b = mod; int x = 1, y = 0;\n\t\twhile (b) tmp = a / b, a -= tmp * b, swap(a, b), x -= tmp * y, swap(x, y);\n\t\treturn Mint(x);\n\t}\npublic:\n\tMint() :val(0) {}\n\tMint(ll x) :val(x >= 0 ? x % mod : x % mod + mod) {}\n\tint mtoi() { return this->val; }\n\tMint pow(ll t) { Mint res = 1; while (t > 0) { if (t & 1) res *= *this; *this *= *this; t >>= 1; }return res; }\n\tMint& operator+=(const Mint& x) { if ((val += x.val) >= mod) val -= mod; return *this; }\n\tMint& operator-=(const Mint& x) { if ((val += mod - x.val) >= mod) val -= mod; return *this; }\n\tMint& operator*=(const Mint& x) { val = (ll)val * x.val % mod; return *this; }\n\tMint& operator/=(const Mint& x) { return *this *= x.inv(); }\n\tbool operator==(const Mint& x) const { return val == x.val; }\n\tbool operator!=(const Mint& x) const { return val != x.val; }\n\tbool operator<(const Mint& x) const { return val < x.val; }\n\tbool operator<=(const Mint& x) const { return val <= x.val; }\n\tbool operator>(const Mint& x) const { return val > x.val; }\n\tbool operator>=(const Mint& x) const { return val >= x.val; }\n\tMint operator-() const { return Mint(-val); }\n\tMint operator+(const Mint& x) const { return Mint(*this) += x; }\n\tMint operator-(const Mint& x) const { return Mint(*this) -= x; }\n\tMint operator*(const Mint& x) const { return Mint(*this) *= x; }\n\tMint operator/(const Mint& x) const { return Mint(*this) /= x; }\n};\nstruct factorial {\n\tvector<Mint> Fact, Finv;\npublic:\n\tfactorial(int maxx) {\n\t\tFact.resize(maxx + 1, Mint(1)); Finv.resize(maxx + 1);\n\t\trep(i, 0, maxx) Fact[i + 1] = Fact[i] * Mint(i + 1);\n\t\tFinv[maxx] = Mint(1) / Fact[maxx];\n\t\trrep(i, maxx, 0) Finv[i - 1] = Finv[i] * Mint(i);\n\t}\n\tMint fact(int n) { return Fact[n]; }\n\tMint finv(int n) { return Finv[n]; }\n\tMint nCr(int n, int r) {\n\t\tif (n < 0 || n < r || r < 0) return Mint(0);\n\t\treturn Fact[n] * Finv[r] * Finv[n - r];\n\t}\n\tMint nPr(int n, int r) {\n\t\tif (n < 0 || n < r || r < 0) return Mint(0);\n\t\treturn Fact[n] * Finv[n - r];\n\t}\n};\nclass UnionFind {\n\tvector<int> par;\npublic:\n\tUnionFind(int n) { par = vector<int>(n, -1); }\n\tint root(int a) {\n\t\tif (par[a] < 0) return a;\n\t\telse return par[a] = root(par[a]);\n\t}\n\tint size(int a) { return -par[root(a)]; }\n\tbool connect(int a, int b) {\n\t\ta = root(a), b = root(b);\n\t\tif (a == b) return false;\n\t\tif (size(a) < size(b)) swap(a, b);\n\t\tpar[a] += par[b], par[b] = a;\n\t\treturn true;\n\t}\n};\nstruct max_flow {\n\tstruct Edge { int to, cap, rev; };\n\tint V; vector<vector<Edge>> G; vector<int> itr, level;\npublic:\n\tmax_flow(int V) : V(V) { G.assign(V, vector<Edge>()); }\n\tvoid add_edge(int from, int to, int cap) {\n\t\tG[from].push_back({ to, cap, (int)G[to].size() });\n\t\tG[to].push_back({ from, 0, (int)G[from].size() - 1 });\n\t}\n\tvoid bfs(int s) {\n\t\tlevel.assign(V, -1); queue<int> q;\n\t\tlevel[s] = 0; q.push(s);\n\t\twhile (!q.empty()) {\n\t\t\tint v = q.front(); q.pop();\n\t\t\tfor (auto& e : G[v]) {\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tq.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t) return f;\n\t\tfor (int& i = itr[v]; i < (int)G[v].size(); ++i) {\n\t\t\tEdge& e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d, G[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint run(int s, int t) {\n\t\tint ret = 0, f;\n\t\twhile (bfs(s), level[t] >= 0) {\n\t\t\titr.assign(V, 0);\n\t\t\twhile ((f = dfs(s, t, inf)) > 0) ret += f;\n\t\t}\n\t\treturn ret;\n\t}\n};\nvector<ll> dijkstra(vector<vector<edge>> Grp, int s) {\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\tvector<ll> dist(Grp.size(), INF); dist[s] = 0; que.push(P(0, s));\n\twhile (!que.empty()) {\n\t\tP p = que.top(); que.pop();\n\t\tint v = p.second; if (dist[v] < p.first) continue;\n\t\trep(i, 0, Grp[v].size()) {\n\t\t\tedge e = Grp[v][i];\n\t\t\tif (dist[e.v] > dist[v] + e.cost) {\n\t\t\t\tdist[e.v] = dist[v] + e.cost;\n\t\t\t\tque.push(P(dist[e.v], e.v));\n\t\t\t}\n\t\t}\n\t} return dist;\n}\nvoid fft(vector<com>& x, bool inv) {\n\tint s = x.size(); if (s == 1) return;\n\tvector<com> even(s / 2), odd(s / 2);\n\trep(i, 0, s / 2)even[i] = x[i * 2], odd[i] = x[i * 2 + 1];\n\tfft(even, inv), fft(odd, inv);\n\tcom w = 1, w_0 = polar(1.0, (inv ? -1 : 1) * 2LL * M_PI / s);\n\trep(i, 0, s)x[i] = even[i % (s / 2)] + w * odd[i % (s / 2)], w *= w_0;\n}\nvoid MultiFunction(vector<int>& a, vector<int>& b) {\n\tint n = a.size(), maxx = 1; while (maxx <= 2 * n)maxx *= 2;\n\tvector<com> x(maxx), y(maxx);\n\trep(i, 0, n) x[i] = com(a[i], 0), y[i] = com(b[i], 0);\n\tfft(x, 0), fft(y, 0); rep(i, 0, maxx) x[i] *= y[i];\n\tfft(x, 1); rep(i, 0, maxx)x[i] /= maxx;\n\ta.resize(2 * n - 1, 0);\n\trep(i, 0, 2 * n - 1)a[i] = (int)(x[i].real() + 0.5);\n}\nll merge_cnt(vector<int> a) {\n\tll n = a.size(), ai = 0, bi = 0, ci = 0, cnt = 0;\n\tif (n <= 1) return 0;\n\tvector<int> b(a.begin(), a.begin() + n / 2);\n\tvector<int> c(a.begin() + n / 2, a.end());\n\tcnt += merge_cnt(b) + merge_cnt(c);\n\twhile (ai < n) {\n\t\tif (bi < b.size() && (ci == c.size() || b[bi] <= c[ci]))a[ai++] = b[bi++];\n\t\telse cnt += n / 2LL - bi, a[ai++] = c[ci++];\n\t}\n\treturn cnt;\n}\n//template end\n\nint n, w[5010];\nvector<vector<int>> g;\nll dp[5010][5010][2];\nint root[5010];\n\nvoid dfs(int u, int pre) {\n\tfor (int v : g[u])if (v != pre)dfs(v, u);\n\tint es = 1; \n\tif (w[u] > 0)dp[u][0][0] = w[u]; else dp[u][0][1] = w[u];\n\tfor (int v : g[u])if (v != pre) {\n\t\tvector<vector<ll>> sub(n);\n\t\trep(i, 0, n)sub[i].resize(2, INF);\n\t\trep(j1, 0, es)rep(j2, 0, root[v])rep(f1, 0, 2)rep(f2, 0, 2) {\n\t\t\tchmin(sub[j1 + j2][f1 | f2], dp[u][j1][f1] + dp[v][j2][f2]);\n\t\t\tif ((f2 && dp[v][j2][f2] < 0) || (!f2 && dp[v][j2][f2] != INF))chmin(sub[j1 + j2 + 1][f1], dp[u][j1][f1]);\n\t\t}\n\t\tes += root[v];\n\t\trep(i, 0, es)dp[u][i][0] = sub[i][0], dp[u][i][1] = sub[i][1];\n\t}\n\troot[u] = es;\n}\n\nint main() {\n\tcin >> n; g.resize(n);\n\trep(i, 0, n) cin >> w[i];\n\trep(i, 0, n - 1) {\n\t\tint u, v; cin >> u >> v; u--; v--;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\trep(i, 0, n)rep(j, 0, n)rep(k, 0, 2)dp[i][j][k] = INF;\n\tdfs(0, -1);\n\tint ans = n;\n\trep(i, 0, n)if (dp[0][i][0] != INF || dp[0][i][1] < 0)chmin(ans, i);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define fi first\n#define se second\n#define pb push_back\n#define rep(i, s, n) for (int i = s; i < n; i++)\n#define rrep(i, s, n) for (int i = (n)-1; i >= (s); i--)\n#define all(a) a.begin(),a.end()\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\nconst long long MOD = 1000000007, INF = 1e17;\ntemplate<class T>inline bool chmax(T& a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<class T>inline bool chmin(T& a,T b){if(a>b){a=b;return true;}return false;}\nstring get_str(string s) {\n\ts+=',';\n\tstring ret=\"\";\n\tfor(int i=0; i<s.size(); i++) {\n\t\tif(s[i]==',') ret+=\"=%ld, \";\n\t\telse ret+=s[i];\n\t}\n\treturn ret;\n}\n#define dump(...) printf(get_str(#__VA_ARGS__).c_str(),__VA_ARGS__);cout<<endl\n \n#define endl '\\n'\n#define IOS()                     \\\n\tios_base::sync_with_stdio(0); \\\n\tcin.tie(0)\n template<typename T>vector<T>\nmake_v(size_t a){return vector<T>(a);}\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n\treturn vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n \ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value==0>::type\nfill_v(T &t,const V &v){t=v;}\n \ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t,const V &v){\n\tfor(auto &e:t) fill_v(e,v);\n}\n//******************************************************************************\n \nint N,MINF=1e17;\nvint a;\nvint g[5050];\n \n \nvector<vector<int>>dfs(int now,int par){\n\tauto dp = make_v<int>(1,2);\n\tfill_v(dp,INF);\n\tdp[0][0] = a[now];\n\tif(a[now]>0)dp[0][1] = a[now];\n\tfor(auto e:g[now]){\n\t\tif(e==par)continue;\n\t\tauto tmp = dfs(e,now);\n\t\tint n = dp.size();\n\t\tint m = tmp.size();\n\t\tauto new_dp = make_v<int>(n+m,2);\n\t\tfill_v(new_dp,INF);\n\t\trep(i,0,n){\n\t\t\trep(j,0,m){\n\t\t\t\trep(k,0,2){\n\t\t\t\t\trep(l,0,2){\n\t\t\t\t\t\tchmin(new_dp[i+j][k&l],dp[i][k]+tmp[j][l]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(i+j+1>=n+m)continue;\n\t\t\t\tif(tmp[j][0]<0){\n\t\t\t\t\tchmin(new_dp[i+j+1][0],dp[i][0]);\n\t\t\t\t\tchmin(new_dp[i+j+1][1],dp[i][1]);\n\t\t\t\t}\n\t\t\t\tif(tmp[j][1]<INF/2){\n\t\t\t\t\tchmin(new_dp[i+j+1][0],dp[i][0]);\n\t\t\t\t\tchmin(new_dp[i+j+1][1],dp[i][1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdp = new_dp;\n\t}\n\treturn dp;\n}\n \nsigned main()\n{\n\t//IOS();\n\tcin>>N;\n\ta.resize(N);\n\tfor(int i = 0;i < N;i++){\n\t\tcin>>a[i];\n\t}\n\trep(i,0,N-1){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\ta--;b--;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\tauto dp = dfs(0,-1);\n\tint ans = INF;\n\trep(j,0,N){\n\t\tif(dp[j][1]<INF/2)chmin(ans,j);\n\t\tif(dp[j][0]<0)chmin(ans,j);\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define rep(i,l,r) for (int i=(l); i<=(r); i++)\n#define For(i,x) for (int i=h[x],k; i; i=nxt[i])\ntypedef long long ll;\nusing namespace std;\n\nconst int N=5010;\nint n,cnt,u,v,ans,a[N],g[N],sz[N],h[N],to[N<<1],nxt[N<<1];\nll sm[N],f[N][N];\nvoid add(int u,int v){ to[++cnt]=v; nxt[cnt]=h[u]; h[u]=cnt; }\n\nvoid dfs(int x,int fa){\n\tsm[x]=a[x];\n\tFor(i,x) if ((k=to[i])!=fa) dfs(k,x),sm[x]+=sm[k];\n\tif (a[x]>0){\n\t\tg[x]=0;\n\t\tFor(i,x) if ((k=to[i])!=fa){\n\t\t\tint s=g[k];\n\t\t\trep(j,0,n) if (f[k][j]<0){ s=min(s,j+1); break; }\n\t\t\tg[x]+=s;\n\t\t}\n\t}\n\tf[x][0]=a[x]; sz[x]=1;\n\tFor(i,x) if ((k=to[i])!=fa){\n\t\tfor (int j=sz[x]+sz[k]; ~j; j--){\n\t\t\tf[x][j]+=sm[k];\n\t\t\tif (j-g[k]-1>=0) f[x][j]=min(f[x][j],f[x][j-g[k]-1]);\n\t\t\trep(s,max(0,j-sz[x]),min(j,sz[k])){\n\t\t\t\tif (s) f[x][j]=min(f[x][j],f[x][j-s]+f[k][s]);\n\t\t\t\tif (s<j && f[k][s]<0) f[x][j]=min(f[x][j],f[x][j-s-1]);\n\t\t\t}\n\t\t}\n\t\tsz[x]+=sz[k];\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\trep(i,1,n) scanf(\"%d\",&a[i]);\n\trep(i,2,n) scanf(\"%d%d\",&u,&v),add(u,v),add(v,u);\n\tmemset(g,42,sizeof(g)); memset(f,42,sizeof(f));\n\tdfs(1,1); ans=g[1];\n\trep(i,0,n) if (f[1][i]<0){ ans=min(ans,i); break; }\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  otera    \n**/\n#include<iostream>\n#include<string> \n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#include<algorithm> \n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<deque>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\n#define int long long\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\ntypedef long double ld;\nconst int inf=1e9+7;\nconst ll INF=1LL<<60 ;\nconst ll mod=1e9+7 ;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<int, int> P;\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define debug(x)  cerr << #x << \" = \" << (x) << endl;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nconst int MAX = 5100;\n\nint n;\nvector<int> a;\nvector<vector<int>> g;\n\nint num[MAX];\nint dp[MAX][MAX][2];\nint sdp[MAX][2];\n\nvoid rec(int v, int p) {\n\tnum[v] = 1;\n\tfor(int nv: g[v]) {\n\t\tif(nv == p) continue;\n\t\trec(nv, v);\n\t\tnum[v] += num[nv];\n\t}\n\n\tfor(int i = 0; i <= num[v]; ++ i) {\n\t\tsdp[i][0] = sdp[i][1] = INF;\n\t}\n\n\tsdp[0][0] = a[v];\n\tif(a[v] > 0) sdp[0][1] = a[v];\n\n\tint cur = 0;\n\tfor(int nv: g[v]) {\n\t\tif(nv == p) continue;\n\t\tfor(int i = cur; i >= 0; -- i) {\n\t\t\tint tmp0 = sdp[i][0], tmp1 = sdp[i][1];\n\t\t\tsdp[i][0] = INF, sdp[i][1] = INF;\n\t\t\tfor(int j = 0; j <= num[nv]; ++ j) {\n\t\t\t\tchmin(sdp[i + j][0], tmp0 + dp[nv][j][0]);\n\t\t\t\tif(dp[nv][j][0] < 0 || dp[nv][j][1] < INF) chmin(sdp[i + j + 1][0], tmp0);\n\t\t\t\tif(a[v] > 0) {\n\t\t\t\t\tchmin(sdp[i + j][1], tmp1 + dp[nv][j][1]);\n\t\t\t\t\tif(dp[nv][j][0] < 0 || dp[nv][j][1] < INF) chmin(sdp[i + j + 1][1], tmp1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcur += num[nv];\n\t}\n\n\tfor(int i = 0; i <= num[v]; ++ i) {\n\t\tdp[v][i][0] = sdp[i][0];\n\t\tdp[v][i][1] = sdp[i][1];\n\t}\n}\n\nvoid solve() {\n\tcin >> n;\n\ta.resize(n);\n\trep(i, n) {\n\t\tcin >> a[i];\n\t}\n\tg.assign(n, vector<int>());\n\trep(i, n - 1) {\n\t\tint u, v; cin >> u >> v; \n\t\t-- u, -- v;\n\t\tg[u].pb(v);\n\t\tg[v].pb(u);\n\t}\n\tfor(int i = 0; i < n; ++ i) {\n\t\tfor(int j = 0; j <= MAX; ++ j) {\n\t\t\tdp[i][j][0] = dp[i][j][1] = INF;\n\t\t}\n\t}\n\trec(0, -1);\n\tint ans = n;\n\tfor(int j = n; j >= 0; -- j) {\n\t\tif(dp[0][j][0] < 0) ans = j;\n\t\tif(dp[0][j][1] < INF) ans = j;\n\t}\n\tcout << ans << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MaxN = 5005;\nconst long long oo = 1e18;\n\nint n;\nvector<int> Adj[MaxN];\nint a[MaxN];\nint s[MaxN];\nlong long dp0[MaxN][MaxN];\nbool dp1[MaxN][MaxN];\n\nvoid DFS(int u, int Pd)\n{\n    if (a[u] >= 0)\n    {\n        dp1[u][1] = true;\n    }\n    dp0[u][1] = a[u];\n    s[u] = 1;\n    for (auto v : Adj[u])\n    {\n        if (v != Pd)\n        {\n            DFS(v, u);\n            s[u] += s[v];\n            for (int i = s[u]; i > 0; i--)\n            {\n                bool flag = false;\n                long long Min = oo;\n                for (int j = max(1, i - s[u] + s[v]); j <= min(i, s[v]); j++)\n                {\n                    flag |= (dp1[u][i - j + 1] & dp1[v][j]);\n                    Min = min(Min, dp0[u][i - j + 1] + dp0[v][j]);\n                    if (dp0[v][j] < 0 || dp1[v][j])\n                    {\n                        flag |= dp1[u][i - j];\n                        Min = min(Min, dp0[u][i - j]);\n                    }\n                }\n                dp1[u][i] = flag;\n                dp0[u][i] = Min;\n            }\n        }\n    }\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n;\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> a[i];\n    }\n    int u, v;\n    for (int i = 1; i < n; i++)\n    {\n        cin >> u >> v;\n        Adj[u].push_back(v);\n        Adj[v].push_back(u);\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j <= n; j++)\n        {\n            dp0[i][j] = oo;\n            dp1[i][j] = false;\n        }\n    }\n    DFS(1, -1);\n    for (int i = 1; i <= n; i++)\n    {\n        if (dp0[1][i] < 0 || dp1[1][i])\n        {\n            cout << i - 1;\n            break;\n        }\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i, a, b) for (int i = (a); i < (b); i++)\n#ifdef tabr\n#include \"library/debug.cpp\"\n#else\n#define debug(...) 0\n#endif\n\nint n;\nvector<ll> a(5100);\nvector<vector<int>> g(5100);\n// vector<vector<vector<ll>>> dp(5100, vector<vector<ll>>(5100, vector<ll>(2, 1e18)));\nll dp[5100][5100][2];\nvector<vector<ll>> tmp(5100, vector<ll>(2, 1e18));\nvector<int> sz(5100, 1);\n\nvoid dfs(int v, int p) {\n    if (g[v].size() == 0) {\n        if (a[v] > 0)\n            dp[v][0][0] = a[v];\n        else\n            dp[v][0][1] = a[v];\n        return;\n    }\n    for (int u : g[v]) {\n        if (u == p) continue;\n        dfs(u, v);\n        sz[v] += sz[u];\n    }\n    int cur = 0;\n    rep(i, 0, n + 1) tmp[i][0] = tmp[i][1] = 1e18;\n    tmp[0][0] = a[v];\n    if (a[v] > 0) tmp[0][1] = a[v];\n    for (int u : g[v]) {\n        if (u == p) continue;\n        for (int i = cur; i >= 0; i--) {\n            ll x = tmp[i][0], y = tmp[i][1];\n            tmp[i][0] = tmp[i][1] = 1e18;\n            rep(k, 0, sz[u] + 1) {\n                tmp[i + k][0] = min(tmp[i + k][0], x + dp[u][k][0]);\n                if (dp[u][k][0] < 0 || dp[u][k][1] < 1e18)\n                    tmp[i + k + 1][0] = min(tmp[i + k + 1][0], x);\n                if (a[v] > 0) {\n                    tmp[i + k][1] = min(tmp[i + k][1], y + dp[u][k][1]);\n                    if (dp[u][k][0] < 0 || dp[u][k][1] < 1e18)\n                        tmp[i + k + 1][1] = min(tmp[i + k + 1][1], y);\n                }\n            }\n        }\n        cur += sz[u];\n    }\n    rep(i, 0, sz[v] + 1) {\n        dp[v][i][0] = tmp[i][0];\n        dp[v][i][1] = tmp[i][1];\n    }\n    return;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> n;\n    rep(i, 0, n) cin >> a[i];\n    rep(i, 0, 5100) rep(j, 0, 5100) dp[i][j][0] = dp[i][j][1] = 1e18;\n    rep(i, 0, n - 1) {\n        int u, v;\n        cin >> u >> v;\n        u--, v--;\n        g[u].emplace_back(v);\n        g[v].emplace_back(u);\n    }\n    dfs(0, -1);\n    rep(i, 0, n) {\n        if (dp[0][i][0] < 0 || dp[0][i][1] < 1e18) {\n            cout << i << endl;\n            return 0;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stdio.h>\n#include <vector>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stdlib.h>\n#include <time.h>\n#include <iomanip>\n#include <math.h>\n#include <bitset>\n\nusing namespace std;\n\n#define taskname \"A\"\n#define LL long long \n#define uLL unsigned long long \n#define FOR(i,l,r) for(int i = l; i <= r; ++i)\n#define REP(i,l,r) for(int i = l; i < r; ++i)\n#define FORD(i,r,l) for(int i = r; i >= l; --i)\n#define REPD(i,r,l) for(int i = r; i > l; --i)\n#define sz(x) (int)((x).size())\n#define all(x) (x).begin(), (x).end()\n#define debug(x) { cerr << #x << \" = \" << x << endl; }\n#define sci(x) int x; scanf(\"%d\", &x);\n#define scii(x, y) int x, y; scanf(\"%d %d\", &x, &y);\n#define sciii(x, y, z) int x, y, z; scanf(\"%d %d %d\", &x, &y, &z);\n#define pi pair<int,int>\n#define pii pair<int,pi>\n#define piLL pair<LL,LL>\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define _USE_MATH_DEFINES \n/* M_PI */\n#define SetLength2(a, n, t) a=((t*) calloc(n, sizeof(t))) + (n)/2\n\nconst int maxN = 5001;\nconst LL oo = 1e17 + 11;\n\nint tcases = 1;\n\nint N,M,total = 0,res = 0;\nvector <int> e[maxN];\nint C[maxN];\nLL W[maxN],A[maxN],F[maxN][maxN],f1[maxN],g1[maxN];\nbool G[maxN][maxN];\npiLL tmp[maxN],fg[maxN];\n\nvoid dfs(int u,int p = 0){\n    W[u] = A[u];\n    C[u] = 1;\n    REP(i,0,e[u].size()){\n        int v = e[u][i];\n        if(v == p) continue;\n        dfs(v,u);\n        W[u] += W[v];\n        C[u] += C[v];\n    }\n}\nvoid cal(int u,int p = 0){\n    REP(i,0,e[u].size()){\n        int v = e[u][i];\n        if(v != p) cal(v,u);\n    }\n    //\n    F[u][0] = W[u];\n    if(C[u] == 1) G[u][0] = A[u] > 0;\n    else{\n        REP(i,0,C[u]) f1[i] = oo,g1[i] = 0;\n        f1[0] = A[u]; g1[0] = A[u] > 0;\n        \n        REP(k,0,e[u].size()){\n            int v = e[u][k];\n            if(v == p) continue;\n            // cal F[u][i]\n            REP(i,0,C[u]){\n                F[u][i] = oo; G[u][i] = 0;\n                FOR(j,0,min(C[v],i)){\n                    F[u][i] = min(F[u][i],f1[i - j] + F[v][j]);\n                    if(j > 0 && (F[v][j - 1] < 0 || G[v][j - 1])) F[u][i] = min(F[u][i],f1[i - j] + 0);\n                    G[u][i] |= g1[i - j] & (G[v][j] || (j > 0 & F[v][j - 1] < 0));\n                }\n            }\n            REP(i,0,C[u]) f1[i] = F[u][i],g1[i] = G[u][i];\n        }\n    }\n    /*REP(i,0,C[u]){\n        if(F[u][i] < 0 || G[u][i]){\n            F[u][i + 1] = min(F[u][i + 1],0LL);\n            G[u][i + 1] = 1;\n        }\n    }*/\n}\nvoid testcase(){\n\n    cin >> N;\n    FOR(i,1,N) cin >> A[i];\n    \n    REP(i,1,N){\n        scii(u,v);\n        e[u].pb(v);\n        e[v].pb(u);\n    }\n\n    dfs(1);\n\n    int root = 1;\n\n    FOR(i,1,N){\n        FOR(j,0,N) F[i][j] = oo;\n    }\n\n    cal(root);\n    \n    FOR(j,0,N) if(F[root][j] < 0 || G[root][j]){\n        cout << j;\n        return ;\n    }\n}\n\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie();\n    cout.tie();\n\n    FOR(i,1,tcases) testcase();\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 0x3f3f3f3f\nusing namespace std;\ntypedef long long ll;\nconst int N=5005;\nint n,a[N],si[N],tot,head[N],nex[N<<1],to[N<<1];\nvoid add(int u,int v){to[++tot]=v;nex[tot]=head[u];head[u]=tot;}\nll dp[N][N][2],f[N][2];\nvoid dfs(int u,int p)\n{\n    if(a[u]<0) dp[u][1][1]=a[u];\n    else dp[u][1][0]=a[u];\n    si[u]=1;\n    for(int i=head[u];i;i=nex[i])\n    {\n        int v=to[i];if(v==p) continue;\n        dfs(v,u);\n        memset(f,inf,sizeof(f));\n        for(int j=1;j<=si[u];j++)\n            for(int k=1;k<=si[v];k++)\n        {\n            if((dp[v][k][0]<dp[0][0][0]||dp[v][k][1]<0)&&dp[u][j][0]<dp[0][0][0])\n                f[j+k][0]=min(f[j+k][0],dp[u][j][0]);\n            if((dp[v][k][0]<dp[0][0][0]||dp[v][k][1]<0)&&dp[u][j][1]<dp[0][0][0])\n                f[j+k][1]=min(f[j+k][1],dp[u][j][1]);\n            for(int h=0;h<2;h++)\n                for(int p=0;p<2;p++)\n                if(dp[u][j][h]<dp[0][0][0]&&dp[v][k][p]<dp[0][0][0])\n                f[j+k-1][h|p]=min(f[j+k-1][h|p],dp[u][j][h]+dp[v][k][p]);\n        }\n        si[u]+=si[v];\n        for(int j=1;j<=si[u];j++)\n            dp[u][j][0]=f[j][0],dp[u][j][1]=f[j][1];\n    }\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n    for(int i=1;i<n;i++)\n    {\n        int u,v;scanf(\"%d%d\",&u,&v);\n        add(u,v);add(v,u);\n    }\n    memset(dp,inf,sizeof(dp));\n    dfs(1,0);\n    int ans=n-1;\n    for(int i=1;i<=n;i++)\n        if(dp[1][i][0]<dp[0][0][0]||dp[1][i][1]<0){ans=i-1;break;}\n    printf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████   \n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n#include \"bits/stdc++.h\"\nusing namespace std;\n#define MOD 1000000007\n#define INF 1LL<<60\n#define fs first\n#define sc second\n#define pb push_back\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i = (b-1);i>=a;i--)\n#define REP(i,n)  FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) (a)<=(i) && (i)<(b)\n#define debug(x)  cout << #x << \" = \" << (x) << endl;\n#define SP << \" \" << \ntypedef pair<int,int> P;\ntypedef vector<vector<P> > Graph;\n\nconst int NMAX = 1e4;\nvector<int> edge[NMAX],used(NMAX,0);\nvector<int> cost(NMAX,0),pos(NMAX,1);\nvector<int> a(NMAX);\nint ans = 0;\n\nint dfs2(int no){\n  used[no]++;\n  if(pos[no]){\n    return cost[no];\n  }\n  vector<int> tmp;\n  for(auto to:edge[no]){\n    if(used[to]) continue;\n    if(cost[to] < 0) continue;\n    tmp.pb(dfs2(to));\n  }\n  sort(tmp.begin(),tmp.end());\n  reverse(tmp.begin(),tmp.end());\n  int id = 0;\n  while(cost[no] >= 0){\n    cost[no] -= tmp[id];\n    id++;\n    ans++;\n  }\n}\n\nvoid dfs(int no){\n  used[no]++;\n  for(auto to:edge[no]){\n    if(used[to]) continue;\n    dfs(to);\n    cost[no] += cost[to];\n    if(pos[to] == 0) pos[no] = 0;\n  }\n}\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);  \n\n  int n;\n  cin >> n;\n  \n  REP(i,n) cin >> a[i];\n  \n  REP(_,n-1){\n    int x,y;\n    cin >> x >> y;\n    x--;y--;\n    edge[x].pb(y);\n    edge[y].pb(x);\n  }\n\n  REP(i,n){\n    cost[i] = a[i];\n    if(a[i] < 0) pos[i] = 0;\n  }\n\n  dfs(0);\n  //REP(i,n) cout << cost[i] << \" \" << pos[i] << endl;\n\n  REP(i,n) used[i] = 0;\n  dfs2(0);\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for (ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nconst ll INF = 1LL << 60;\nll N, A[5000];\nvector<ll> E[5000];\n\nvector<ll> merge1(vector<ll> &dp, vector<ll> &ch1, vector<ll> &ch2) {\n  vector<ll> next(dp.size() + ch1.size(), INF);\n  REP(i, 0, dp.size()) if (dp[i] < INF) {\n    REP(j, 0, ch1.size()) {\n      if (ch1[j] < INF) next[i + j] = min(next[i + j], dp[i] + ch1[j]);\n      if (ch1[j] < INF) next[i + j + 1] = min(next[i + j + 1], dp[i]);\n      if (ch2[j] < 0) next[i + j + 1] = min(next[i + j + 1], dp[i]);\n    }\n  }\n  return next;\n}\n\nvector<ll> merge2(vector<ll> &dp, vector<ll> &ch1, vector<ll> &ch2) {\n  vector<ll> next(dp.size() + ch1.size(), INF);\n  REP(i, 0, dp.size()) if (dp[i] < INF) {\n    REP(j, 0, ch1.size()) {\n      if (ch1[j] < INF) next[i + j] = min(next[i + j], dp[i] + ch1[j]);\n      if (ch2[j] < INF) next[i + j] = min(next[i + j], dp[i] + ch2[j]);\n      if (ch1[j] < INF) next[i + j + 1] = min(next[i + j + 1], dp[i]);\n      if (ch2[j] < 0) next[i + j + 1] = min(next[i + j + 1], dp[i]);\n    }\n  }\n  return next;\n}\n\npair<vector<ll>, vector<ll>> dfs(ll v, ll p) {\n  vector<ll> dp1(1, A[v] > 0 ? A[v] : INF), dp2(1, A[v]);\n  for (ll u : E[v]) if (u != p) {\n    pair<vector<ll>, vector<ll>> ch = dfs(u, v);\n    vector<ll> ch1 = ch.first, ch2 = ch.second;\n    dp1 = merge1(dp1, ch1, ch2);\n    dp2 = merge2(dp2, ch1, ch2);\n  }\n  return make_pair(dp1, dp2);\n}\n\nll solve() {\n}\n\nint main(void) {\n  cin >> N;\n  REP(i, 0, N) cin >> A[i];\n  REP(i, 0, N - 1) {\n    ll u, v;\n    cin >> u >> v, u--, v--;\n    E[u].push_back(v);\n    E[v].push_back(u);\n  }\n\n  pair<vector<ll>, vector<ll>> dp = dfs(0, -1);\n  vector<ll> dp1 = dp.first, dp2 = dp.second;\n\n  ll ans = INF;\n  REP(i, 0, dp1.size()) if (dp1[i] < INF || dp2[i] < 0) ans = min(ans, i);\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF (1LL << 60)\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n\nusing namespace std;\n\ntemplate<typename S,typename T>auto&operator<<(ostream&o,pair<S,T>p){return o<<\"{\"<<p.fi<<\",\"<<p.se<<\"}\";}\ntemplate<typename T>auto&operator<<(ostream&o,set<T>s){for(auto&e:s)o<<e<<\" \";return o;}\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,priority_queue<S,T,U>q){while(!q.empty())o<<q.top()<<\" \",q.pop();return o;}\ntemplate<typename K,typename T>auto&operator<<(ostream&o,map<K,T>m){for(auto&e:m)o<<e<<\" \";return o;}\ntemplate<typename T>auto&operator<<(ostream&o,vector<T>v){for(auto&e:v)o<<e<<\" \";return o;}\nvoid ashow(){cout<<endl;}template<typename T,typename...A>void ashow(T t,A...a){cout<<t<<\" \";ashow(a...);}\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\n\nconst int MAX_N = 5005;\n\nvector<int> G[MAX_N];\nll a[MAX_N];\n\nvl dfs(int u, int p)\n{\n    vl dp(2);\n    if(a[u] < 0){\n        dp[0] = INF;\n    }else{\n        dp[0] = 1;\n    }\n    dp[1] = a[u];\n    each(v, G[u]){\n        if(v != p){\n            auto res = dfs(v, u);\n            vl ndp(len(dp)+len(res), INF);\n            if(res[0] < INF){\n                ndp[0] = dp[0] + res[0] - 1;\n            }else{\n                int num = -1;\n                srep(k,1,len(res)){\n                    if(res[k] < 0){\n                        num = k;\n                        break;\n                    }\n                }\n                ndp[0] = dp[0] + num;\n            }\n            srep(j,1,len(dp)){\n                srep(k,1,len(res)){\n                    if(res[0] < INF){\n                        cmn(ndp[j+res[0]], dp[j]);\n                    }else if(res[k] < 0){\n                        cmn(ndp[j+k], dp[j]);\n                    }\n                    cmn(ndp[j+k-1], dp[j]+res[k]);\n                }\n            }\n            swap(dp, ndp);\n        }\n    }\n    return dp;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    rep(i,n){\n        cin >> a[i];\n    }\n    rep(i,n-1){\n        int u, v;\n        cin >> u >> v;\n        G[u-1].pb(v-1), G[v-1].pb(u-1);\n    }\n    auto res = dfs(0, -1);\n    ll ans = INF;\n    if(res[0] < INF) ans = res[0];\n    srep(i,1,len(res)){\n        if(res[i] < 0){\n            cmn(ans, (ll)i);\n            break;\n        }\n    }\n    cout << ans-1 << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ostream>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\nconst ll INF = TEN(18);\n\nint n;\nV<ll> a;\nVV<int> g;\n\nusing P = pair<ll, ll>;\nV<P> dfs(int p, int b) {\n    V<P> dp = {{0, INF}};\n    for (int d: g[p]) {\n        if (d == b) continue;\n        auto ndp = dfs(d, p);\n        int k = int(ndp.size());\n        ndp.push_back({INF, INF});\n        for (int i = k - 1; i >= 0; i--) {\n            if (ndp[i].first < INF / 2 || ndp[i].second < 0) ndp[i + 1].first = min(ndp[i + 1].first, 0LL);\n        }\n        int m = int(dp.size()) - 1;\n        V<P> udp(m + k + 1, {INF, INF});\n        for (int i = 0; i <= m; i++) {\n            for (int j = 0; j <= k; j++) {\n                udp[i+j].first = min(udp[i+j].first, dp[i].first + ndp[j].first);\n                udp[i+j].second = min(udp[i+j].second, dp[i].first + ndp[j].second);\n                udp[i+j].second = min(udp[i+j].second, dp[i].second + ndp[j].first);\n                udp[i+j].second = min(udp[i+j].second, dp[i].second + ndp[j].second);\n            }\n        }\n        dp = udp;\n    }\n    int m = int(dp.size()) - 1;\n    V<P> udp(m + 1);\n    for (int i = 0; i <= m; i++) {\n        if (a[p] > 0) {\n            udp[i].first = dp[i].first + a[p];\n            udp[i].second = dp[i].second + a[p];\n        } else {\n            udp[i].first = INF;\n            udp[i].second = min(dp[i].first, dp[i].second) + a[p];\n        }\n    }\n\n    return udp;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout << setprecision(20) << fixed;\n\n    cin >> n;\n    a = V<ll>(n);\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n    g = VV<int>(n);\n    for (int j = 0; j < n - 1; ++j) {\n        int a, b;\n        cin >> a >> b; a--; b--;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n\n    auto dp = dfs(0, -1);\n\n    for (int i = 0; i < n; i++) {\n        if (dp[i].first < INF / 2 || dp[i].second < 0) {\n            cout << i << endl;\n            return 0;\n        }\n    }\n    assert(false);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nconst int MAX_N = 5000;\nconst long long inf = 1e15;\n\nint N;\nvector<int> G[MAX_N];\n\nint A[MAX_N];\n\nvoid input(){\n\tscanf(\"%d\", &N);\n\tfor(int i = 0; i < N; ++i) scanf(\"%d\", A + i);\n\tfor(int i = 0; i < N - 1; ++i){\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tu--;\n\t\tv--;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n}\n\nvector<long long> dp1[MAX_N], dp2[MAX_N];\n\nvector<long long> tr(vector<long long> dp, vector<long long> ch1, vector<long long> ch2, bool flg){\n\tint a = dp.size(), b = ch1.size();\n\tvector<long long> ans(a + b - 1);\n\tfor(int i = 0; i < ans.size(); ++i) ans[i] = inf;\n\tfor(int i = 0; i < dp.size(); ++i){\n\t\tif(dp[i] == inf) continue;\n\t\tfor(int j = 0; j < ch1.size(); ++j){\n\t\t\tif(i + j - 1 >= 0){\n\t\t\t\tif(ch1[j] != inf) ans[i + j - 1] = min(ans[i + j - 1], dp[i] + ch1[j]);\n\t\t\t\tif(ch2[j] != inf && (!flg)) ans[i + j - 1] = min(ans[i + j - 1], dp[i] + ch2[j]);\n\t\t\t}\n\t\t\tif(ch1[j] != inf) ans[i + j] = min(ans[i + j], dp[i]);\n\t\t\tif(ch2[j] < 0) ans[i + j] = min(ans[i + j], dp[i]);\n\t\t}\n\t}\n\treturn ans;\n}\n\nvoid dfs(int v, int p){\n\tdp1[v].push_back(inf);\n\tdp1[v].push_back(A[v] > 0 ? A[v] : inf);\n\tdp2[v].push_back(inf);\n\tdp2[v].push_back(A[v]);\n\tfor(int i = 0; i < G[v].size(); ++i){\n\t\tint u = G[v][i];\n\t\tif(u == p) continue;\n\t\tdfs(u, v);\n\t\tdp1[v] = tr(dp1[v], dp1[u], dp2[u], true);\n\t\tdp2[v] = tr(dp2[v], dp1[u], dp2[u], false);\n\t}\n}\n\nint solve(){\n\tdfs(0, -1);\n\t/*if(N <= 10){\n\t\tfor(int i = 0; i < N; ++i){\n\t\t\tfor(int j = 0; j < min(3, (int)dp2[i].size()); ++j){\n\t\t\t\tprintf(\"%lld,%lld \", dp1[i][j], dp2[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}*/\n\tfor(int i = 0; i <= N; ++i){\n\t\tif(dp1[0][i] < inf) return i - 1;\n\t\tif(dp2[0][i] < 0) return i - 1;\n\t}\n\treturn -1;\n}\n\nint main(){\n\tinput();\n\tint ans = solve();\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n#include <array>\n# include <cassert>\n#include <cctype>\n#include <climits>\n#include <numeric>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <tuple>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n# include <chrono>\n# include <random>\n# include <limits.h>\n# include <unordered_map>\n# include <unordered_set>\n# include <deque>\n# include <cstdio>\n# include <cstring>\n#include <stdio.h>\n#include<time.h>\n#include <stdlib.h>\n#include <cstdint>\n#include <cfenv>\n#include<fstream>\n//#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nlong long MOD = 1000000000 + 7;//1000000000 + 7 998244353 924844033 1000000000 + 9;\nconstexpr long long INF = 1LL << 60;//numeric_limits<LL>::max();\nconst double PI = acos(-1);\n#define fir first\n#define sec second\n#define thi third\n#define debug(x) cerr<<#x<<\": \"<<x<<'\\n'\ntypedef pair<LL, LL> Pll;\ntypedef pair<double, double> Dll;\ntypedef pair<LL, pair<LL, LL>> Ppll;\ntypedef pair<LL, pair<LL, bitset<100001>>> Pbll;\ntypedef pair<LL, pair<LL, vector<LL>>> Pvll;\ntypedef pair<LL, LL> Vec2;\nstruct Tll { LL first, second, third; };\nstruct Fll { LL first, second, third, fourth; };\ntypedef pair<LL, Tll> Ptll;\n#define rep(i,rept) for(LL i=0;i<rept;i++)\n#define Rrep(i,mf) for(LL i=mf-1;i>=0;i--)\nvoid YN(bool f) {\n\tif (f)\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n}\nvoid yn(bool f) {\n\tif (f)\n\t\tcout << \"Yes\" << endl;\n\telse\n\t\tcout << \"No\" << endl;\n}\nstruct Edge { LL to, cost; };\nstruct edge {\n\tLL from, to, cost;\n};\nvector<vector<LL>>g;\nvector<edge>ed;\nvector<Pll>pv;\nset<LL>st;\nmap<Pll, LL>ma;\nint di[4][2] = { { 0,1 },{ 1,0 },{ 0,-1 },{ -1,0 } };\nstring str, ss;\nbool f;\nLL n, m, s, t, h, w, a[6000],sub[6000];\nLL dp1[6000][6000], dp2[6000][6000];\nvoid dfs(int cur, int par) {\n\tsub[cur] = 1;\n\trep(i, 6000)dp1[cur][i] = INF, dp2[cur][i] = INF;\n\tif (a[cur] > 0)\n\t\tdp1[cur][0] = a[cur];\n\telse\n\t\tdp2[cur][0] = a[cur];\n\trep(i, g[cur].size()) {\n\t\tLL v = g[cur][i];\n\t\tif (v == par)continue;\n\t\tdfs(v, cur);\n\t\tLL to1[6000], to2[6000];\n\t\trep(i, 6000)to1[i] = INF, to2[i] = INF;\n\t\tfor (int i = 0; i < sub[cur]; i++) {\n\t\t\tfor (int j = 0; j < sub[v]; j++) {\n\t\t\t\tif (dp2[v][j] < 0 || dp1[v][j] < INF) {\n\t\t\t\t\tto1[i + j + 1] = min(to1[i + j + 1], dp1[cur][i]);\n\t\t\t\t\tto2[i + j + 1] = min(to2[i + j + 1], dp2[cur][i]);\n\t\t\t\t}\n\t\t\t\tto1[i + j] = min(to1[i + j], dp1[cur][i] + dp1[v][j]);\n\t\t\t\tto2[i + j] = min({ to2[i + j], dp1[cur][i] + dp1[v][j] ,\n\t\t\t\t\tdp2[cur][i] + dp1[v][j] ,dp1[cur][i] + dp2[v][j],dp2[cur][i] + dp2[v][j] });\n\t\t\t}\n\t\t}\n\t\trep(i, 6000)dp1[cur][i] = to1[i], dp2[cur][i] = to2[i];\n\t\tsub[cur] += sub[v];\n\t}\n}\nint main() {\n\tcin >> n;\n\trep(i, n) {\n\t\tcin >> a[i];\n\t}\n\tg.resize(n);\n\trep(i, n - 1) {\n\t\tLL x, y;\n\t\tcin >> x >> y;\n\t\tx--, y--;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\tdfs(0, -1);\n\trep(i, n+1) {\n\t\tif (dp1[0][i] < INF) {\n\t\t\tcout << i << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif (dp2[0][i] < 0) {\n\t\t\tcout << i << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <map>\n#include <numeric>\n#include <cmath>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <complex>\n#include <string.h>\n#include <unordered_set>\n#include <unordered_map>\n#include <bitset>\n#include <iomanip>\n#include <sys/time.h>\n#include <tuple>\n#include <random>\nusing namespace std;\n\n#define endl '\\n'\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\n#define UNIQ(v) (v).erase(unique((v).begin(), (v).end()), (v).end())\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, ll> P;\ntypedef tuple<int, ll, ll> T;\ntypedef complex<double> comp;\ntypedef vector< vector<ld> > matrix;\nstruct pairhash {\npublic:\n    template<typename T, typename U>\n    size_t operator()(const pair<T, U> &x) const {\n\tsize_t seed = hash<T>()(x.first);\n\treturn hash<U>()(x.second) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n    }\n};\nconst ll inf = 1e18 + 9;\nconst ll mod = 1e9 + 7;\nconst double eps = 1e-8;\nconst double pi = acos(-1);\n\nint n;\nll a[5010];\nint u[5010], v[5010];\n\nvector<int> G[5010];\nll dp[5010][5010];\nint all_b[5010];\nint num[5010];\n\nvoid calc(int v, int prev) {\n    num[v] = 1;\n    dp[v][0] = a[v];\n    for (int i = 1; i < 5010; i++) dp[v][i] = inf;\n    for (int u : G[v]) {\n        if (u == prev) continue;\n        calc(u, v);\n        vector<P> temp;\n        for (int i = 0; i < num[v]; i++) {\n            for (int j = 0; j < num[u]; j++) {\n                temp.push_back(make_pair(i+j, dp[v][i]+dp[u][j]));\n                if (dp[u][j] < 0 || (a[u]>0 && all_b[u]<=j))\n                    temp.push_back(make_pair(i+j+1, dp[v][i]));\n            }\n        }\n        for (int i = 0; i <= num[v]+num[u]; i++) dp[v][i] = inf;\n        for (P p : temp) {\n            dp[v][p.first] = min(dp[v][p.first], p.second);\n        }\n        num[v] += num[u];\n    }\n\n    if (a[v] > 0) {\n        all_b[v] = 0;\n        for (int u : G[v]) {\n            if (u == prev) continue;\n            if (a[u] < 0) {\n                for (int i = 0; i < num[u]; i++) {\n                    if (dp[u][i] < 0) {\n                        all_b[v] += i+1;\n                        break;\n                    }\n                }\n            } else {\n                int m = 1e9;\n                for (int i = 0; i < num[u]; i++) {\n                    if (dp[u][i] < 0) {\n                        m = i+1;\n                        break;\n                    }\n                }\n                all_b[v] += min(m, all_b[u]);\n            }\n        }\n    }\n}\n\nint solve() {\n    for (int i = 0; i < n-1; i++) {\n        G[u[i]].push_back(v[i]);\n        G[v[i]].push_back(u[i]);\n    }\n    int s = -1;\n    for (int i = 0; i < n; i++) {\n        if (a[i] < 0) {\n            s = i;\n            break;\n        }\n    }\n    if (s < 0) return 0;\n\n    calc(s, -1);\n\n    for (int i = 0; i < n; i++) {\n        if (dp[s][i] < 0)\n            return i;\n    }\n    return -1;\n}\n\nvoid input() {\n    cin >> n;\n    for (int i = 0; i < n; i++) cin >> a[i];\n    for (int i = 0; i < n-1; i++) {\n        cin >> u[i] >> v[i];\n        u[i]--;\n        v[i]--;\n    }\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << fixed << setprecision(15);\n\n    input();\n    cout << solve() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <stack>\n#include <queue>\n#include <list>\n#include <bitset>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n#include <numeric>\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <chrono>\n#include <random>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <functional>\n#include <sstream>\n\nusing namespace std;\n\n\nint main(int argc, char** argv) {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n\n    int n;\n    cin >> n;\n    vector<int> A(n, 0);\n    for (int i = 0; i < n; ++i) {\n        cin >> A[i];\n    }\n    vector<vector<int>> graph(n);\n    for (int i = 0; i + 1 < n; ++i) {\n        int u, v;\n        cin >> u >> v;\n        --u, --v;\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n\n\n    vector<int> sizes(n, 0);\n\n    const long long INF = 1LL << 60;\n    vector<vector<long long>> dp1(n);\n    vector<vector<long long>> dp2(n);\n\n    auto update = [&](vector<long long>& A, vector<long long>& B, vector<long long>& C, bool ok) {\n        int n = A.size();\n        int m = B.size();\n        vector<long long> res (n + m - 1, INF);\n\n        for (int i = 0; i < n; ++i) {\n            if (A[i] >= INF) {\n                continue;\n            }\n            for (int j = 0; j < m; ++j) {\n                if (i + j - 1 >= 0) {\n                    if (B[j] < INF) {\n                        res[i + j - 1] = min(res[i + j - 1], A[i] + B[j]);\n                    }\n                    if (ok && C[j] < INF) {\n                        res[i + j - 1] = min(res[i + j - 1], A[i] + C[j]);\n                    }\n                }\n                if (B[j] < INF) {\n                    res[i + j] = min(res[i + j], A[i]);\n                }\n                if (C[j] < 0) {\n                    res[i + j] = min(res[i + j], A[i]);\n                }\n            }\n        }\n        return res;\n    };\n\n\n    function<void(int,int)> dfs = [&](int u, int p) {\n        sizes[u] = 1;\n        dp1[u].resize(sizes[u] + 1, INF);\n        dp1[u][1] = A[u] > 0 ? A[u] : INF;\n        dp2[u].resize(sizes[u] + 1, INF);\n        dp2[u][1] = A[u];\n\n        for (auto v : graph[u]) {\n            if (v == p) {\n                continue;\n            }\n            dfs(v, u);\n            sizes[u] += sizes[v];\n            dp1[u] = update(dp1[u], dp1[v], dp2[v], false);\n            dp2[u] = update(dp2[u], dp1[v], dp2[v], true);\n        }\n        assert(dp1[u].size() == sizes[u] + 1);\n        assert(dp2[u].size() == sizes[u] + 1);\n    };\n\n    dfs(0, -1);\n\n\n    int res = n;\n    for (int i = 1; i <= n; ++i) {\n        if (dp1[0][i] < INF || dp2[0][i] < 0) {\n            res = i - 1;\n            break;\n        }\n    }\n\n    cout << res << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n\nvector<LL> A;\nvector<vector<int>> V;\nconst LL INF = 1e18;\n\nvector<vector<LL>> solve(int p, int q){\n\tvector<vector<LL>> ret(1,vector<LL>(2,INF));\n\tret[0][0] = A[q];\n\tif(A[q] > 0) ret[0][1] = A[q];\n\tfor(auto u : V[q]) if(u != p){\n\t\tauto z = solve(q,u);\n\t\tvector<vector<LL>> nx(ret.size()+z.size(),vector<LL>(2,INF));\n\t\trepp(i,0,ret.size()) repp(j,0,z.size()){\n\t\t\tnx[i+j][1] = min(nx[i+j][1],ret[i][1]+z[j][1]);\n\t\t\tnx[i+j][0] = min(nx[i+j][0],ret[i][0]+z[j][0]);\n\t\t\tif(z[j][0] < 0 || z[j][1] < INF){\n\t\t\t\tnx[i+j+1][0] = min(nx[i+j][0],ret[i][0]);\n\t\t\t\tnx[i+j+1][1] = min(nx[i+j][1],ret[i][1]);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tswap(ret,nx);\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint N; cin >> N;\n\tA.resize(N); repp(i,0,N) cin >> A[i];\n\tV.resize(N);\n\trepp(i,1,N){\n\t\tint u,v; cin >> u >> v;\n\t\t--u; --v;\n\t\tV[u].push_back(v);\n\t\tV[v].push_back(u);\n\t}\n\tauto ans = solve(-1,0);\n\trepp(i,0,N) if(ans[i][1] < INF || ans[i][0] < 0) return cout << i << endl, 0;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << (x) << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){\n\treturn o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";\n}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){\n\to<<\"{\";\n\tfor(const T& v:vc) o<<v<<\",\";\n\to<<\"}\";\n\treturn o;\n}\nusing ll = long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<vector<T>>;\nusing P = pair<int,int>;\nstruct UnionFind{\n\tvector<int> par;\n\tUnionFind(int N){\n\t\tpar.assign(N,0);\n\t\trep(i,N) par[i]=i;\n\t}\n\tint find(int x){\n\t\tif(par[x]==x) return x;\n\t\treturn par[x]=find(par[x]);\n\t}\n\tbool same(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n\tvoid unite(int x,int y){\n\t\tx=find(x),y=find(y);\n\t\tif(x==y) return;\n\t\tpar[y]=x;\n\t}\n};\nint N;\nVV<int> G;\nV<ll> A;\nV<int> sz;\nll dp[6000][6000];\nconst ll inf = 1e18;\nvoid dfs(int v,int p){\n\tsz[v] = 1;\n\tfor(int u:G[v]) if(u!=p) dfs(u,v),sz[v] += sz[u];\n\n\tif(A[v]>0){\n\t\tint S = 1;\n\t\tV<ll> inner(1,A[v]);\n\t\tfor(int u:G[v]) if(u!=p){\n\t\t\tV<ll> ninner(S+sz[u],inf);\n\t\t\trep(c,S) if(inner[c]){\n\t\t\t\trep(cu,sz[u]+1){\n\t\t\t\t\tchmin(ninner[c+cu],inner[c]+dp[u][cu]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tS += sz[u];\n\t\t\tinner = ninner;\n\t\t}\n\t\trep(c,S) dp[v][c] = inner[c];\n\n\n\t\t{\t//alone\n\t\t\tint sm = 0;\n\t\t\tfor(int u:G[v]) if(u!=p){\n\t\t\t\tint ok = -1;\n\t\t\t\trep(c,sz[u]+1) if(dp[u][c]<0){\n\t\t\t\t\tok = c;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tassert(ok != -1);\n\t\t\t\tsm += ok + 1;\n\t\t\t}\n\t\t\tif(p != -1){\n\t\t\t\tsm ++;\n\t\t\t\tchmin(dp[v][sm],0LL);\n\t\t\t}else{\n\t\t\t\tchmin(dp[v][sm],-1LL);\n\t\t\t}\n\t\t}\n\t\t// printf(\" ----- v = %d ---------\\n\",v);\n\t\t// rep(c,S) cout<<\"dp[v][\"<<c<<\"]=  \"<<dp[v][c]<<endl;\n\t\t// cout<<endl;\n\t}else{\n\t\tint S = 1;\n\t\tV<ll> inner(1,A[v]);\n\t\tfor(int u:G[v]) if(u!=p){\n\t\t\tV<ll> ninner(S+sz[u],inf);\n\t\t\trep(c,S) if(inner[c]){\n\t\t\t\trep(cu,sz[u]+1){\n\t\t\t\t\tchmin(ninner[c+cu],inner[c]+dp[u][cu]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tS += sz[u];\n\t\t\tinner = ninner;\n\t\t}\n\t\trep(c,S) dp[v][c] = inner[c];\n\n\t\t// printf(\" ----- v = %d ---------\\n\",v);\n\t\t// rep(c,S) cout<<\"dp[v][\"<<c<<\"]=  \"<<dp[v][c]<<endl;\n\t\t// cout<<endl;\n\t}\n}\nint solve(VV<int>& _G, V<ll>& _A){\n\tG = _G, A = _A;\n\tN = G.size();\n\tsz.resize(N);\n\trep(i,6000) rep(j,6000) dp[i][j] = inf;\n\tif(N==1) return 0;\n\tdfs(0,-1);\n\trep(c,N) if(dp[0][c]<0) return c;\n\tassert(false);\n\treturn 0;\n}\nint main(){\n\tint N;\n\tcin>>N;\n\tVV<int> G(N);\n\tV<ll> A(N);\n\tV<P> es(N-1);\n\trep(i,N) cin>>A[i];\n\tUnionFind UF(N);\n\trep(i,N-1){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tx--,y--;\n\t\tes[i] = P(x,y);\n\t\tif(A[x]*A[y]>0){\n\t\t\tUF.unite(x,y);\n\t\t}\n\t}\n\t{\n\t\tmap<int,V<int>> mp;\n\t\tV<int> roots;\n\t\tmap<int,int> r2id;\n\t\trep(i,N){\n\t\t\tmp[UF.find(i)].pb(i);\n\t\t\tif(UF.find(i) == i) roots.pb(i);\n\t\t}\n\t\tint K = roots.size();\n\t\trep(i,K) r2id[roots[i]] = i;\n\t\tV<ll> AA(K);\n\t\trep(i,K){\n\t\t\tfor(int v:mp[roots[i]]) AA[i] += A[v];\n\t\t}\n\t\tVV<int> GG(K);\n\t\trep(i,N-1){\n\t\t\tint x = es[i].fs, y = es[i].sc;\n\t\t\tif(UF.same(x,y)) continue;\n\t\t\tint xx = r2id[UF.find(x)], yy = r2id[UF.find(y)];\n\t\t\tGG[xx].pb(yy);\n\t\t\tGG[yy].pb(xx);\n\t\t}\n\t\tcout<<solve(GG,AA)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nusing Table = vector< pair<int, int> >;\nconst pair<int, int> INIT(INF, 0);\n\nint A[5010];\nvector<int> G[5010];\n\nTable merge(const Table &A, const Table &B) {\n    int N = A.size(), M = B.size();\n    Table res(N + M, INIT);\n    for(int i=N-1; i>=0; i--) {\n        for(int j=M-1; j>=0; j--) {\n            // 和を考える\n            chmin(res[i+j].first, A[i].first + B[j].first);\n            if(B[j].first < 0 or B[j].second) chmin(res[i+j+1].first, A[i].first);\n\n            // 全て正になるか考える\n            res[i+j].second |= A[i].second & B[j].second;\n            if(B[j].first < 0 or B[j].second) res[i+j+1].second |= A[i].second;\n        }\n    }\n    return res;\n}\n\nTable solve(int cur, int par=-1) {\n    Table res_dp(1);\n    res_dp[0].first = A[cur];\n    res_dp[0].second = (A[cur] > 0);\n    for(auto to : G[cur]) {\n        if(to == par) continue;\n        Table child_dp = solve(to, cur);\n        res_dp = merge(res_dp, child_dp);\n    }\n    return res_dp;\n}\n\nsigned main() {\n    int N; cin >> N;    \n    for(int i=0; i<N; i++) {\n        cin >> A[i];\n    }\n    for(int i=0; i<N-1; i++) {\n        int u, v; cin >> u >> v;\n        u--; v--;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n\n    auto dp = solve(0);\n    int ans = INF;\n    for(int i=0; i<N; i++) {\n        if(dp[i].first < 0) ans = min(ans, i);\n        if(dp[i].second == true) ans = min(ans, i);\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n#define int ll\n\n#define REP(i,n) for(int i=0;i<n;++i)\n#define SORT(name) sort(name.begin(), name.end())\n#define ZERO(p) memset(p, 0, sizeof(p))\n#define MINUS(p) memset(p, -1, sizeof(p))\n#if 1\n#  define DBG(fmt, ...) printf(fmt, ##__VA_ARGS__)\n#else\n#  define DBG(fmt, ...)\n#endif\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst double DINF = std::numeric_limits<double>::infinity();\nconst int MOD = 1000000007;\n#define MAX_N 5010\n\nll N;\nvector<ll> A;\nvector< vector<ll> > G; // グラフ(隣接リスト)\n\n// 頂点 v を根とした部分木に何個の頂点が含まれるか(自分含む)\nll num[MAX_N];\n\n// dp[v][num][0]\n// v が根。 num 本の辺を切断する場合 、かつ、\n// v を含まない連結成分は条件を満たす場合の、\n// v を含む連結成分の重みの総和の最小\n// dp[v][num][1]\n// v が根。 num 本の辺を切断する場合、かつ、\n// v を含まない連結成分は条件を満たす場合、かつ、\n// v を含む連結成分の重みがすべて正の場合の、総和の最小\nll dp[MAX_N][MAX_N][2];\n\n// 頂点 v の子ノードに対する dp\n// dp[][][] を作成するために各頂点ごとに初期化して利用する一時的なテーブル\n// sdp[num][0]\n// num 本の辺を切断する場合 、かつ、\n// v を含まない連結成分は条件を満たす場合の、\n// v を含む連結成分の重みの総和の最小\n// sdp[num][1]\n// num 本の辺を切断する場合、かつ、\n// v を含まない連結成分は条件を満たす場合、かつ、\n// v を含む連結成分の重みがすべて正の場合の、総和の最小\nll sdp[MAX_N][2];\n\n// v: 頂点 id\n// parent: v の前に辿っていた頂点(親)\n// dp[] を葉から順に埋めていく\nvoid rec(ll v, ll parent) {\n    // num[v] の作成\n    num[v] = 1;\n    for(auto& child : G[v]) {\n        if(child == parent) { continue; }\n        rec(child, v);\n        num[v] += num[child];\n    }\n\n    // sdp 初期化\n    for(ll j = 0; j <= num[v]; ++j) { sdp[j][0] = sdp[j][1] = LLINF; }\n\n    sdp[0][0] = A[v];\n    if(A[v] > 0) { sdp[0][1] = A[v]; }\n\n    // 現在までに見た部分木のノード数の和(= 今までの切断可能辺数)\n    ll curnum = 0;\n\n    // 頂点 v の子である頂点 child について考える\n    for(auto child : G[v]) {\n        if(child == parent) { continue; }\n\n        for(ll j = curnum; j >= 0; --j) {\n            ll tmp0 = sdp[j][0];    // v 以下の部分木で切断辺数が j のときの、総和の最小値\n            ll tmp1 = sdp[j][1];    // v 以下の部分木で切断辺数が j のときの、総和の最小値(重みが正のみ)\n            sdp[j][0] = sdp[j][1] = LLINF;\n\n            // k : 切断可能辺数\n            for(ll k = 0; k < num[child]; ++k) {\n                // dp[child][k][0] : 頂点 child 以下の部分木から k 個の辺を切断したときの\n                //                   連結成分の重みの総和の最大値\n                sdp[j+k][0] = min(sdp[j+k][0], tmp0 + dp[child][k][0]);\n\n                // もし総和が機能停止の条件を満たす\n                //   (負か重みが正のみの総和も値が入っている(LLINF じゃない) )\n                // ときは、全てを切り離した際の値も更新できる\n                if(dp[child][k][0] < 0 || dp[child][k][1] < LLINF / 2) {\n                    sdp[j+k+1][0] = min(sdp[j+k+1][0], tmp0);\n                }\n\n                // 重みが正なら、正のみの dp テーブルも更新\n                if(A[v] > 0) {\n                    sdp[j+k][1] = min(sdp[j+k][1], tmp1 + dp[child][k][1]);\n                    if(dp[child][k][0] < 0 || dp[child][k][1] < LLINF/ 2) {\n                        sdp[j+k+1][1] = min(sdp[j+k+1][1], tmp1);\n                    }\n                }\n            }\n        }\n        // この child 以下の辺の数 + v と child をつなぐ辺 = num[child]\n        // なので curnum として保持しておく\n        curnum += num[child];\n    }\n\n    // sdp の dp への反映\n    for(ll j = 0; j <= num[v]; ++j) {\n        dp[v][j][0] = sdp[j][0];\n        dp[v][j][1] = sdp[j][1];\n    }\n}\n\nsigned main()\n{\n    cin >> N;\n    A.resize(N);\n    REP(i, N) { cin >> A[i]; }\n    G.assign(N, vector<ll>());\n    REP(i, N-1) {\n        ll u, v;\n        cin >> u >> v;\n        --u; --v;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n\n    // DP 初期化\n    REP(i, MAX_N) { REP(j, MAX_N) { dp[i][j][0] = dp[i][j][1] = LLINF; } }\n    // 0 を根とした dp テーブルの作成\n    rec(0, -1);\n\n    // ans を求める\n    ll ans = N;\n    for(ll i = 0; i <= N; ++i) {\n        // 0 を根として、 i 回切断したときに条件が満たされるなら ans を更新\n        if(dp[0][i][0] < 0) { ans = min(ans, i); }\n        if(dp[0][i][1] < INF / 2) { ans = min(ans, i); }\n    }\n    printf(\"%lld\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N=5005;\nconst long long inf=1e18;\nint n,a[N],g[N][N],num_edge[N],G[N];\nlong long f[N][N],F[N];\nvector<int>adj[N];\n\nvoid dfs(int u,int p)\n{\n    for(int v:adj[u])\n    {\n        if(v!=p)\n        {\n            dfs(v,u);\n            num_edge[u]+=num_edge[v]+1;\n        }\n    }\n    int m=0;\n    f[u][0]=a[u];\n    g[u][0]=(a[u]>0);\n    for(auto&v:adj[u])\n    {\n        if(v==p) continue;\n        for(int i=0;i<=m+num_edge[v]+1;i++)\n        {\n            F[i]=inf;\n            G[i]=0;\n        }\n        for(int i=0;i<=m;i++)\n        {\n            for(int j=0;j<=num_edge[v];j++)\n            {\n                F[i+j]=min(F[i+j],f[u][i]+f[v][j]);\n                if(f[v][j]<0||g[v][j]) F[i+j+1]=min(F[i+j+1],f[u][i]);\n                if(g[u][i])\n                {\n                    if(g[v][j]) G[i+j]=1;\n                    if(f[v][j]<0) G[i+j+1]=1;\n                }\n            }\n        }\n        m+=num_edge[v]+1;\n        for(int i=0;i<=m;i++)\n        {\n            f[u][i]=F[i];\n            g[u][i]=G[i];\n        }\n    }\n}\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cin>>n;\n    for(int i=1;i<=n;i++) cin>>a[i];\n    for(int i=1;i<=n-1;i++)\n    {\n        int u,v;\n        cin>>u>>v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    dfs(1,0);\n    for(int i=0;i<n;i++)\n    {\n        if(f[1][i]<0||g[1][i]) return cout<<i,0;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <limits.h>\n#include <math.h>\n#include <functional>\n#include <bitset>\n#include <iomanip>\n#include <cassert>\n\n#define repeat(i,n) for (long long i = 0; (i) < (n); ++ (i))\n#define debug(x) cerr << #x << \": \" << x << '\\n'\n#define debugArray(x,n) for(long long i = 0; (i) < (n); ++ (i)) cerr << #x << \"[\" << i << \"]: \" << x[i] << '\\n'\n#define debugArrayP(x,n) for(long long i = 0; (i) < (n); ++ (i)) cerr << #x << \"[\" << i << \"]: \" << x[i].first<< \" \" << x[i].second << '\\n'\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> Pii;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\nconst ll INF = INT_MAX;\nconst ll MOD = 1e9+7;\n\n\nint N;\nll A[5010];\nvector<vint> G;\nll dp[5010][2][5010];\nll tmp[2][5010];\nll size[5010];\n\nvoid dfs(int v,int par){\n  size[v]=1;\n  dp[v][0][0] = A[v]>0;\n  dp[v][1][0] = A[v];\n  for(int chi:G[v])if(chi!=par){\n    dfs(chi,v);\n    fill(tmp[0],tmp[0]+N,0);\n    fill(tmp[1],tmp[1]+N,INF);\n    for(int k=size[v]-1;k>=0;k--){\n      for(int l=size[chi]-1;l>=0;l--){\n        if(dp[v][0][k]&&dp[chi][1][l]<0){\n          tmp[0][k+l+1]=1;\n        }\n        if(dp[v][0][k]&&dp[chi][0][l]){\n          tmp[0][k+l]=1;\n        }\n        if(dp[v][1][k]<INF&&dp[chi][0][l]){\n          tmp[1][k+l+1]=min(tmp[1][k+l+1],dp[v][1][k]);\n        }\n        if(dp[v][1][k]<INF&&dp[chi][1][l]<INF){\n          tmp[1][k+l]=min(tmp[1][k+l],dp[v][1][k]+dp[chi][1][l]);\n        }\n      }\n    }\n    swap(dp[v],tmp);\n    size[v]+=size[chi];\n  }\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cin>>N;\n  repeat(i,N){\n    cin>>A[i];\n  }\n  G.resize(N);\n  repeat(i,N-1){\n    int u,v;cin>>u>>v;\n    u--;v--;\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  dfs(0,-1);\n  ll ans;\n  for(ans=0;ans<N-1;ans++){\n    if(dp[0][0][ans]||dp[0][1][ans]<0){\n      break;\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\n#define max(x, y) ((x)>(y)?(x):(y))\n#define min(x, y) ((x)<(y)?(x):(y))\n\nInt n;\nInt sz[216000];\nInt dp[5010][5010][2];\nInt res;\nInt u, v;\nvector<Int> edge[5400];\nInt a[5400];\nInt tmp[5010][2];\nInt dfs(Int x, Int last= -1){\n  if(a[x] > 0)dp[x][0][0] = a[x];\n  else dp[x][0][1] = a[x];\n  sz[x] = 1;\n  for(Int i = 0;i < edge[x].size();i++){\n    Int to = edge[x][i];\n    if(to == last)continue;\n    dfs(to, x);\n    for(Int j = 0;j < sz[x] + sz[to];j++)tmp[j][0] = tmp[j][1] = INF;\n    for(Int j = sz[x] - 1;j >= 0;j--){\n      for(Int k = sz[to] - 1;k >= 0;k--){\n\ttmp[j+k][0] = min(tmp[j+k][0], dp[x][j][0] + dp[to][k][0]);\n\ttmp[j+k][1] = min(tmp[j+k][1], dp[x][j][1] + dp[to][k][1]);\n\ttmp[j+k][1] = min(tmp[j+k][1], dp[x][j][0] + dp[to][k][1]);\n\ttmp[j+k][1] = min(tmp[j+k][1], dp[x][j][1] + dp[to][k][0]);\n\tif(dp[to][k][1] < 0 || dp[to][k][0] != INF){\n\t  tmp[j+k+1][0] = min(tmp[j+k+1][0], dp[x][j][0]);\n\t  tmp[j+k+1][1] = min(tmp[j+k+1][1], dp[x][j][1]);\n\t}\n      }\n    }\n    for(Int j = 0;j < sz[x] + sz[to];j++){\n      dp[x][j][0] = tmp[j][0];\n      dp[x][j][1] = tmp[j][1];\n    }\n    sz[x] += sz[to];    \n  }\n}\nint main(){\n  cin >> n;\n  for(Int i = 0;i < n;i++)\n    for(Int j = 0;j < n;j++)\n      dp[i][j][0] = dp[i][j][1] = INF;\n  for(Int i = 0;i < n;i++)cin >> a[i];\n  for(Int i = 0;i < n-1;i++){\n    cin >> u >> v;u--,v--;\n    edge[u].push_back(v);\n    edge[v].push_back(u);\n  }\n  dfs(0);\n  for(Int i = n-1;i >= 0;i--){\n    if(dp[0][i][0] != INF)res = i;\n    if(dp[0][i][1] < 0)res = i;\n  }\n  cout << res << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define YES() printf(\"YES\\n\")\n#define NO() printf(\"NO\\n\")\n#define Yes() printf(\"Yes\\n\")\n#define No() printf(\"No\\n\")\n#define in(x,y,h,w) x >= 0 && x < h && y >= 0 && y < w\n\n#define int long long\n//using ll = long long;\nusing P = pair<int,int>;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n \nconst int INF=1e+18;\nconst double EPS=1e-9;\nconst int MOD=1000000007;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint n,a[5010],dp[5010][5010][2],newdp[5010][2];\n\nvector<int> G[5010];\n\nint dfs(int v,int par){\n\tdp[v][0][a[v] < 0] = a[v];\n\tint macut = 0;\n\tfor(int to : G[v]){\n\t\tif(to == par) continue;\n\t\tint cut = dfs(to,v);\n\t\tfor(int j = 0;j <= macut + cut + 1;j++) newdp[j][0] = newdp[j][1] = INF;\n\t\tfor(int j = 0;j <= macut;j++){\n\t\t\tfor(int k = 0;k <= cut;k++){\n\t\t\t\tfor(int l = 0;l < 2;l++){\n\t\t\t\t\tfor(int m = 0;m < 2;m++){\n\t\t\t\t\t\tchmin(newdp[j + k][l | m],dp[v][j][l] + dp[to][k][m]);\n\t\t\t\t\t\tif((!m && dp[to][k][m] != INF) || dp[to][k][m] < 0) chmin(newdp[j + k + 1][l],dp[v][j][l]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0;j <= macut + cut + 1;j++){\n\t\t\tdp[v][j][0] = newdp[j][0];\n\t\t\tdp[v][j][1] = newdp[j][1];\n\t\t}\n\t\tmacut += cut + 1;\n\t}\n\treturn macut;\n}\n\nsigned main(){\n\tcin >> n;\n\tfor(int i = 0;i < n;i++) cin >> a[i];\n\tfor(int i = 0;i < n - 1;i++){\n\t\tint u,v;\n\t\tcin >> u >> v; u--;v--;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tfor(int i = 0;i < n;i++){\n\t\tfor(int j = 0;j < n;j++) dp[i][j][0] = dp[i][j][1] = INF;\n\t}\n\tdfs(0,-1);\n\tfor(int i = 0;i < n;i++){\n\t\tif(dp[0][i][0] != INF || dp[0][i][1] < 0){\n\t\t\tcout << i << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\nconst int RANDOM = chrono::high_resolution_clock::now().time_since_epoch().count();\nmt19937 randGen(RANDOM);\nconst int RANDOM_HASH = randGen();\n\nstruct chash\n{\n    int operator()(int x) const { return hash<int>{}(x ^ RANDOM_HASH); }\n};\ntypedef gp_hash_table<int, null_type, chash> hash_set;\ntypedef gp_hash_table<int, int, chash> hash_map;\n\ntypedef long long ll;\n\nconst int MAX_N = 5005;\nconst int MAX_ITERATIONS = 1005;\n\nint n;\nll a[MAX_N];\npair<int, int> edges[MAX_N];\nvector<pair<int, int>> g[MAX_N];\nint randP[MAX_N], randP2[MAX_N];\nbool forbiddenEdge[MAX_N];\nbool used[MAX_N];\nll currSum = 0;\nbool currHaveComp = false;\n\nvoid checkDfs(int u)\n{\n\tused[u] = true;\n\tif (a[u] < 0)\n\t\tcurrHaveComp = true;\n\tcurrSum += a[u];\n\tfor (const auto& p : g[u])\n\t\tif (!used[p.first] && !forbiddenEdge[p.second])\n\t\t\tcheckDfs(p.first);\n}\n\nbool check(int cntEdges)\n{\n\tfor (int it = 0; it < MAX_ITERATIONS; it++)\n\t{\n\t\tshuffle(randP, randP + (n - 1), randGen);\n\t\tmemset(forbiddenEdge, 0, sizeof(forbiddenEdge));\n\t\tfor (int i = 0; i < cntEdges; i++)\n\t\t\tforbiddenEdge[randP[i]] = true;\n\t\tmemset(used, 0, sizeof(used));\n\t\tshuffle(randP2, randP2 + n, randGen);\n\t\tbool currRes = true;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tint u = randP2[i];\n\t\t\tif (used[u])\n\t\t\t\tcontinue;\n\t\t\tcurrSum = 0;\n\t\t\tcurrHaveComp = false;\n\t\t\tcheckDfs(u);\n\t\t\tif (!currHaveComp || currSum < 0)\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t{\n\t\t\t\tcurrRes = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (currRes)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin >> n;\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> a[i];\n\tfor (int i = 0; i < n - 1; i++)\n\t{\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--; v--;\n\t\tedges[i].first = u;\n\t\tedges[i].second = v;\n\t\tg[u].emplace_back(v, i);\n\t\tg[v].emplace_back(u, i);\n\t}\n\n\tfor (int i = 0; i < n - 1; i++)\n\t\trandP[i] = i;\n\tfor (int i = 0; i < n; i++)\n\t\trandP2[i] = i;\n\n\tint l = 0, r = n - 1;\n\twhile (r - l > 1)\n\t{\n\t\tint mid = (l + r) / 2;\n\t\tif (check(mid))\n\t\t\tr = mid;\n\t\telse\n\t\t\tl = mid + 1;\n\t}\n\tif (!check(l))\n\t\tl = r;\n\tcout << l << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 0.00000001\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007\n#define MOD 998244353\n#define seg_size 262144\n#define REP(i,n) for(long long i = 0;i < n;++i)\nlong long costings[20000];\nvector<int> vertexs[20000];\nlong long dp1[5101][5101];\nlong long dp2[5101][5101];\nlong long vertexes[5101];\nlong long tmp[5101*2][2];\nlong long dfs(long long now, long long back) {\n\tvertexes[now] = 1;\n\tfor (int i = 0; i < vertexs[now].size(); ++i) {\n\t\tif (vertexs[now][i] != back) {\n\t\t\tdfs(vertexs[now][i], now);\n\t\t\tvertexes[now] += vertexes[vertexs[now][i]];\n\t\t}\n\t}\n\tREP(i, vertexes[now] + 2) {\n\t\ttmp[i][0] = LONG_INF;\n\t\ttmp[i][1] = LONG_INF;\n\t}\n\ttmp[0][0] = costings[now];\n\tif (costings[now] > 0) tmp[0][1] = costings[now];\n\n\tlong long now_tea = 0;\n\tREP(i, vertexs[now].size()) {\n\t\tif (vertexs[now][i] != back) {\n\t\t\tint visiting = vertexs[now][i];\n\t\t\tfor (int j = now_tea; j >= 0; --j) {\n\t\t\t\tlong long geko_a = tmp[j][0];\n\t\t\t\tlong long geko_b = tmp[j][1];\n\t\t\t\ttmp[j][0] = LONG_INF;\n\t\t\t\ttmp[j][1] = LONG_INF;\n\t\t\t\tfor (int k = 0; k <= vertexes[visiting]; ++k) {\n\t\t\t\t\ttmp[j + k][0] = min(tmp[j + k][0], geko_a + dp1[visiting][k]);\n\t\t\t\t\tif (dp1[visiting][k] < 0 || dp2[visiting][k] < LONG_INF / 2) tmp[j + k + 1][0] = min(tmp[j + k + 1][0], geko_a);\n\t\t\t\t\tif (costings[now] > 0) {\n\t\t\t\t\t\ttmp[j + k][1] = min(tmp[j + k][1], geko_b + dp2[visiting][k]);\n\t\t\t\t\t\tif (dp1[visiting][k] < 0 || dp2[visiting][k] < LONG_INF / 2) tmp[j + k + 1][1] = min(tmp[j + k + 1][1], geko_b);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tnow_tea += vertexes[visiting];\n\t\t}\n\t}\n\tfor (int j = 0; j <= vertexes[now]; ++j) {\n\t\tdp1[now][j] = tmp[j][0];\n\t\tdp2[now][j] = tmp[j][1];\n\t}\n\treturn 0;\n}\nint main() {\n#define int long long\n\tint n;\n\tcin >> n;\n\tREP(i, 5001) {\n\t\tREP(q, 5001) {\n\t\t\tdp1[i][q] = LONG_INF;\n\t\t\tdp2[i][q] = LONG_INF;\n\t\t}\n\t}\n\tREP(i, n) {\n\t\tcin >> costings[i];\n\t}\n\tREP(i, n - 1) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--;\n\t\tb--;\n\t\tvertexs[a].push_back(b);\n\t\tvertexs[b].push_back(a);\n\t}\n\tdfs(0, -1);\n\tREP(i, n + 1) {\n\t\tif (dp1[0][i] < 0 || dp2[0][i] < LONG_INF / 2) {\n\t\t\tcout << i << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << n << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#define INF 100000000000000\nusing namespace std;\n\nint n,u,v,cnt[5001];\nlong long a[5001],dp[5001][5001][2],dp2[5000][5001][2];\nvector<int> g[5001];\nvector<int> child[5001];\nvoid dfs(int x,int y){\n    cnt[x]++;\n    for(int i=0;i<g[x].size();i++){\n        if(g[x][i]!=y){\n            dfs(g[x][i],x);\n            child[x].push_back(g[x][i]);\n        }\n    }\n    for(int i=0;i<=child[x].size();i++){\n        for(int j=0;j<=5000;j++){\n            dp2[i][j][0]=INF;\n            dp2[i][j][1]=INF;\n        }\n    }\n    if(a[x]>0){\n        dp2[0][1][0]=a[x];\n        dp2[0][1][1]=a[x];\n    }\n    else{\n        dp2[0][1][0]=INF;\n        dp2[0][1][1]=a[x];\n    }\n    for(int i=0;i<child[x].size();i++){\n        for(int j=1;j<=cnt[x];j++){\n            for(int k=1;k<=cnt[child[x][i]];k++){\n                if(a[x]>0){\n                    dp2[i+1][j+k-1][0]=min(dp2[i+1][j+k-1][0],dp2[i][j][0]+dp[child[x][i]][k][0]);\n                }\n                if((dp[child[x][i]][k][0]!=INF||dp[child[x][i]][k][1]<0)){\n                    dp2[i+1][j+k][0]=min(dp2[i+1][j+k][0],dp2[i][j][0]);\n                    dp2[i+1][j+k][1]=min(dp2[i+1][j+k][1],dp2[i][j][1]);\n                }\n                dp2[i+1][j+k-1][1]=min(dp2[i+1][j+k-1][1],dp2[i][j][1]+dp[child[x][i]][k][1]);\n            }\n        }\n        cnt[x]+=cnt[child[x][i]];\n    }\n    for(int i=0;i<=cnt[x];i++){\n        dp[x][i][0]=dp2[child[x].size()][i][0];\n        dp[x][i][1]=dp2[child[x].size()][i][1];\n    }\n}\n\nint main(){\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%lld\",&a[i+1]);\n    }\n    for(int i=0;i<n-1;i++){\n        scanf(\"%d %d\",&u,&v);\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    dfs(1,-1);\n    for(int i=0;i<n;i++){\n        if(dp[1][i+1][0]!=INF||dp[1][i+1][1]<0){\n            printf(\"%d\\n\",i);\n            return 0;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, x, n) for(int i = x; i <= n; i++)\n#define rep3(i, x, n) for(int i = x; i >= n; i--)\n#define elif else if\n#define sp(x) fixed << setprecision(x)\n#define pb push_back\n#define eb emplace_back\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)x.size()\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pil = pair<int, ll>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nconst ll MOD = 1e9+7;\n//const ll MOD = 998244353;\nconst int inf = (1<<30)-1;\nconst ll INF = (1LL<<60)-1;\nconst ld EPS = 1e-10;\ntemplate<typename T> bool chmax(T &x, const T &y) {return (x < y)? (x = y, true) : false;};\ntemplate<typename T> bool chmin(T &x, const T &y) {return (x > y)? (x = y, true) : false;};\n\nconst int MAX_V = 5e3;\nvector<int> es[MAX_V];\nll A[MAX_V];\nll dp[MAX_V][MAX_V][2];\n\nint dfs(int now, int pre){\n    int sum = 1;\n    if(A[now] > 0) dp[now][0][0] = A[now];\n    else dp[now][0][1] = A[now];\n    for(auto &e: es[now]){\n        if(e == pre) continue;\n        int tmp = dfs(e, now);\n        ll memo[MAX_V][2];\n        rep(i, MAX_V) rep(j, 2) memo[i][j] = INF;\n        rep(i, sum) rep(j, tmp){\n            if(dp[e][j][0] < INF || dp[e][j][1] < 0){\n                memo[i+j+1][0] = dp[now][i][0];\n                memo[i+j+1][1] = dp[now][i][1];\n            }\n            rep(p, 2) rep(q, 2){\n                int r = (p != 0 || q != 0);\n                chmin(memo[i+j][r], dp[now][i][p]+dp[e][j][q]);\n            }\n        }\n        rep(i, MAX_V) rep(j, 2) dp[now][i][j] = memo[i][j];\n        sum += tmp;\n    }\n    return sum;\n}\n\nint main(){\n    int N;\n    cin >> N;\n    rep(i, N) cin >> A[i];\n    rep(i, N-1){\n        int u, v; cin >> u >> v; u--, v--;\n        es[u].pb(v), es[v].pb(u);\n    }\n    rep(i, N) rep(j, N) rep(k, 2) dp[i][j][k] = INF;\n    dfs(0, -1);\n    rep(i, N){\n        if(dp[0][i][0] < INF || dp[0][i][1] < 0){\n            cout << i << endl;\n            break;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define ll long long\n#define N 5010\nint read()\n{\n    int x=0,f=1;char c=getchar();\n    while (c<'0'||c>'9') {if (c=='-') f=-1;c=getchar();}\n    while (c>='0'&&c<='9') x=(x<<1)+(x<<3)+(c^48),c=getchar();\n    return x*f;\n}\nint n,a[N],p[N],g[N],size[N],t;\nll sum[N],f[N][N];\nstruct data{int to,nxt;\n}edge[N<<1];\nvoid addedge(int x,int y){t++;edge[t].to=y,edge[t].nxt=p[x],p[x]=t;}\nvoid dfs(int k,int from)\n{\n\tsum[k]=a[k];\n    for (int i=p[k];i;i=edge[i].nxt)\n    if (edge[i].to!=from)\n\t{\n\t\tdfs(edge[i].to,k);\n\t\tsum[k]+=sum[edge[i].to];\n\t}\n    if (a[k]>0)\n    {\n        g[k]=0;\n        for (int i=p[k];i;i=edge[i].nxt)\n        if (edge[i].to!=from)\n        {\n            int x=g[edge[i].to];\n            for (int j=0;j<=n;j++)\n            if (f[edge[i].to][j]<0) {x=min(x,j+1);break;}\n            g[k]+=x;\n        }\n    }\n    f[k][0]=a[k];\n    size[k]=1;\n    for (int i=p[k];i;i=edge[i].nxt)\n    if (edge[i].to!=from)\n    {\n        for (int j=size[k]+size[edge[i].to];j>=0;j--)\n        {\n        \tf[k][j]+=sum[edge[i].to];if (j-g[edge[i].to]-1>=0) f[k][j]=min(f[k][j],f[k][j-g[edge[i].to]-1]);\n        \tfor (int x=max(0,j-size[edge[i].to]);x<=min(j,size[edge[i].to]);x++)\n        \t{\n        \t\tif (x) f[k][j]=min(f[k][j],f[k][j-x]+f[edge[i].to][x]);\n        \t\tif (x<j&&f[edge[i].to][x]<0) f[k][j]=min(f[k][j],f[k][j-x-1]);\n        \t}\n        }\n        size[k]+=size[edge[i].to];\n    }\n}\nint main()\n{\n\t/*freopen(\"e.in\",\"r\",stdin);\n\tfreopen(\"e.out\",\"w\",stdout);*/\n    n=read();\n    for (int i=1;i<=n;i++) a[i]=read();\n    for (int i=1;i<n;i++)\n    {\n        int x=read(),y=read();\n        addedge(x,y),addedge(y,x);\n    }\n    memset(g,42,sizeof(g));\n    memset(f,42,sizeof(f));\n    dfs(1,1);\n    /*for (int i=1;i<=n;i++) cout<<a[i]<<' ';cout<<endl;\n    for (int i=1;i<=n;i++) cout<<g[i]<<' ';cout<<endl;\n    cout<<endl;\n    for (int i=1;i<=n;i++)\n    {\n    \tfor (int j=0;j<n;j++)\n    \tcout<<f[i][j]<<' ';\n    \tcout<<endl;;\n    }\n    for (int i=1;i<=n;i++) cout<<sum[i]<<' ';cout<<endl;*/\n    int ans=g[1];\n    for (int i=0;i<=n;i++) \n    if (f[1][i]<0) {ans=min(ans,i);break;}\n    cout<<ans;\n    return 0;\n}\n "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\nconst int N = 5010;\nconst ll INF = 1e18;\nint n;\nll a[N];\nVI e[N];\nvoid out(VVL &dp){\n    REP(f,2){\n        REP(i,dp[f].size()) cout << dp[f][i] << \" \";\n        cout << endl;\n    }\n    cout << endl;\n}\nvoid dfs(int now, int past, VVL &dp){\n    dp.assign(2, VL(1, INF));\n    if (a[now] > 0) dp[1][0] = a[now];\n    else dp[0][0] = a[now];\n    for (int next : e[now]){\n        if (next == past) continue;\n        VVL dp2(2);\n        dfs(next, now, dp2);\n        int n = dp[0].size(), m = dp2[0].size();\n        VVL dp_next(2, VL(n + m, INF));\n        REP(i,n) REP(f,2) REP(j,m) REP(g,2){\n            if (dp[f][i] == INF || dp2[g][j] == INF) continue;\n            dp_next[f & g][i + j] = min(dp_next[f & g][i + j], dp[f][i] + dp2[g][j]);\n            if (g || dp2[g][j] < 0) dp_next[f][i + j + 1] = min(dp_next[f][i + j + 1], dp[f][i]);\n        }\n        // out(dp);\n        // out(dp2);\n        // out(dp_next);\n        dp.swap(dp_next);\n    }\n}\nint main() {\n    cin >> n;\n    REP(i,n) a[i] = in();\n    REP(i,n-1){\n        int u = in() - 1, v = in() - 1;\n        e[u].push_back(v);\n        e[v].push_back(u);\n    }\n    VVL dp(2);\n    dfs(0, -1, dp);\n    int ans = n;\n    REP(i,n){\n        if (dp[0][i] < 0 || dp[1][i] < INF) ans = min(ans, i);\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T1, typename T2>\nbool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>\nbool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>\nvoid ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>\nvoid debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>\nvoid debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];\nfor(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>\nvector<vector<T>>vec(ll x, ll y, T w){\n  vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,-1,0,0,1,1,-1,-1};\nvector<ll>dy={0,0,1,-1,1,-1,1,-1};\ntemplate<typename T>\nvector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v(ts...))>(a,make_v(ts...));\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2>&p){\n  return os << p.first << \" \" << p.second;\n}\n//mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll n;cin>>n;\n  vector<ll>a(n);\n  rep(i,0,n)cin>>a[i];\n  vector<vector<ll>>g(n);\n  rep(i,0,n-1){\n    ll u,v;cin>>u>>v;u--;v--;\n    g[u].PB(v);\n    g[v].PB(u);\n  }\n  using VV=vector<vector<ll>>;\n  auto dfs=[&](auto &&f,ll k,ll par)->VV{\n    VV ret=vec(1,2,INF);\n    if(a[k]<0)ret[0][1]=a[k];\n    else ret[0][0]=a[k];\n    for(auto to:g[k]){\n      if(to==par)continue;\n      auto v=f(f,to,k);\n      ll s1=ret.size();\n      ll s2=v.size();\n      //cout<<s1 spa s2 spa to<<endl;\n      auto tmp=vec(s1+s2,2,INF);\n      rep(i,0,s1)rep(j,0,2)rep(p,0,s2)rep(q,0,2){\n        if(ret[i][j]==INF||v[p][q]==INF)continue;\n        //cout<<i spa j spa p spa q<<endl;\n        if(v[p][q]<0||q==0)chmin(tmp[i+p+1][j],ret[i][j]);\n        chmin(tmp[i+p][j||q],ret[i][j]+v[p][q]);\n      }\n      //debug(tmp,tmp.size(),2);\n      ret=move(tmp);\n    }\n    //cout<<k<<endl;\n    //debug(ret,ret.size(),2);\n    return move(ret);\n  };\n  auto v=dfs(dfs,0,-1);\n  res=INF;\n  rep(i,0,v.size())rep(j,0,2){\n    if(v[i][j]<0)chmin(res,i);\n    if(j==0&&v[i][j]!=INF)chmin(res,i);\n  }\n  cout<<res<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include \"bits/stdc++.h\"\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconst double PI = acos(-1);\ntemplate<class T>constexpr T INF() { return ::std::numeric_limits<T>::max(); }\ntemplate<class T>constexpr T HINF() { return INF<T>() / 2; }\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\ntypedef pair<LL, LL> pii;\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\nint popcnt(unsigned long long n) { int cnt = 0; for (int i = 0; i < 64; i++)if ((n >> i) & 1)cnt++; return cnt; }\nint d_sum(LL n) { int ret = 0; while (n > 0) { ret += n % 10; n /= 10; }return ret; }\nint d_cnt(LL n) { int ret = 0; while (n > 0) { ret++; n /= 10; }return ret; }\nLL gcd(LL a, LL b) { if (b == 0)return a; return gcd(b, a%b); };\nLL lcm(LL a, LL b) { LL g = gcd(a, b); return a / g*b; };\n# define ALL(qpqpq)           (qpqpq).begin(),(qpqpq).end()\n# define UNIQUE(wpwpw)        sort(ALL((wpwpw)));(wpwpw).erase(unique(ALL((wpwpw))),(wpwpw).end())\n# define LOWER(epepe)         transform(ALL((epepe)),(epepe).begin(),TL<char>)\n# define UPPER(rprpr)         transform(ALL((rprpr)),(rprpr).begin(),TU<char>)\n# define FOR(i,tptpt,ypypy)   for(LL i=(tptpt);i<(ypypy);i++)\n# define REP(i,upupu)         FOR(i,0,upupu)\n# define INIT                 std::ios::sync_with_stdio(false);std::cin.tie(0)\n\nint n;\nint a[5050];\nvector<int> g[5050];\nLL dp[5050][5050][2];\nint visited[5050];\nLL dp2[5050][2];\nint u, v;\n\nvoid dfs(int cur, int pre){\n    visited[cur] = 1;\n    REP(i, (int)g[cur].size()){\n        if(g[cur][i] == pre)continue;\n        dfs(g[cur][i], cur);\n        visited[cur] += visited[g[cur][i]];\n    }\n\n    REP(j, 5050)dp2[j][0] = dp2[j][1] = HINF<LL>();\n\n    dp2[0][0] = a[cur];\n    if(a[cur] > 0)dp2[0][1] = a[cur];\n\n    int chcnt = 0;\n    REP(i, (int)g[cur].size()){\n        if(g[cur][i] == pre)continue;\n        for(int j = chcnt;j >= 0;j--){\n            LL tmp0 = dp2[j][0], tmp1 = dp2[j][1];\n            dp2[j][0] = dp2[j][1] = HINF<LL>();\n            for(int k = 0;k < visited[g[cur][i]];k++){\n                dp2[j + k][0] = min(dp2[j + k][0], tmp0 + dp[g[cur][i]][k][0]);\n                if(dp[g[cur][i]][k][0] < 0 || dp[g[cur][i]][k][1] < HINF<LL>())dp2[j + k + 1][0] = min(dp2[j + k + 1][0], tmp0);\n                if(a[cur] > 0){\n                    dp2[j + k][1] = min(dp2[j + k][1], tmp1 + dp[g[cur][i]][k][1]);\n                    if(dp[g[cur][i]][k][0] < 0 || dp[g[cur][i]][k][1] < HINF<LL>())dp2[j + k + 1][1] = min(dp2[j + k + 1][1], tmp1);\n                }\n            }\n        }\n        chcnt += visited[g[cur][i]];\n    }\n    for(int j = 0;j < visited[cur];j++){\n        cout << cur << \" \" << j << \":\" << dp[cur][j][0] << \" \" << dp[cur][j][1] << endl;\n        dp[cur][j][0] = dp2[j][0];\n        dp[cur][j][1] = dp2[j][1];\n    }\n}\n\nint main(){\n    cin >> n;\n    REP(i, n)cin >> a[i];\n    REP(i, n - 1){\n        cin >> u >> v;\n        u--, v--;\n        g[u].emplace_back(v);\n        g[v].emplace_back(u);\n    }\n    REP(i, 5050)REP(j, 5050)REP(k, 2)dp[i][j][k] = HINF<LL>();\n    dfs(0, -1);\n\n    LL ans = n - 1;\n    REP(i, n){\n        cout << \"#\" << i << \":\" << dp[0][i][0] << \" \" << dp[0][i][1] << endl; \n        if(dp[0][i][0] < 0)ans = min(ans, i);\n        if(dp[0][i][1] < HINF<LL>())ans = min(ans, i);\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i, a, b) for (int i = (a); i < (b); i++)\n#ifdef tabr\n#include \"library/debug.cpp\"\n#else\n#define debug(...) 0\n#endif\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n;\n    cin >> n;\n    vector<ll> a(n);\n    vector<vector<int>> g(n);\n    rep(i, 0, n) cin >> a[i];\n    rep(i, 0, n - 1) {\n        int u, v;\n        cin >> u >> v;\n        u--, v--;\n        g[u].emplace_back(v);\n        g[v].emplace_back(u);\n    }\n    vector<vector<vector<ll>>> dp(n, vector<vector<ll>>(n + 1, vector<ll>(2, 1e18)));\n    vector<vector<ll>> tmp(n + 1, vector<ll>(2, 1e18));\n    vector<int> sz(n, 1);\n    function<void(int, int)> dfs = [&](int v, int p) {\n        if (g[v].size() == 0) {\n            if (a[v] > 0)\n                dp[v][0][0] = a[v];\n            else\n                dp[v][0][1] = a[v];\n            return;\n        }\n        for (int u : g[v]) {\n            if (u == p) continue;\n            dfs(u, v);\n            sz[v] += sz[u];\n        }\n        int cur = 0;\n        rep(i, 0, n + 1) tmp[i][0] = tmp[i][1] = 1e18;\n        tmp[0][0] = a[v];\n        if (a[v] > 0) tmp[0][1] = a[v];\n        for (int u : g[v]) {\n            if (u == p) continue;\n            for (int i = cur; i >= 0; i--) {\n                ll x = tmp[i][0], y = tmp[i][1];\n                tmp[i][0] = tmp[i][1] = 1e18;\n                rep(k, 0, sz[u] + 1) {\n                    tmp[i + k][0] = min(tmp[i + k][0], x + dp[u][k][0]);\n                    if (dp[u][k][0] < 0 || dp[u][k][1] < 1e18)\n                        tmp[i + k + 1][0] = min(tmp[i + k + 1][0], x);\n                    if (a[v] > 0) {\n                        tmp[i + k][1] = min(tmp[i + k][1], y + dp[u][k][1]);\n                        if (dp[u][k][0] < 0 || dp[u][k][1] < 1e18)\n                            tmp[i + k + 1][1] = min(tmp[i + k + 1][1], y);\n                    }\n                }\n            }\n            cur += sz[u];\n        }\n        rep(i, 0, sz[v] + 1) {\n            dp[v][i][0] = tmp[i][0];\n            dp[v][i][1] = tmp[i][1];\n        }\n        return;\n    };\n    dfs(0, -1);\n    rep(i, 0, n) {\n        if (dp[0][i][0] < 0 || dp[0][i][1] < 1e18) {\n            cout << i << endl;\n            return 0;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst long long INF = 1e18;\n\nint n, a[5005], siz[5005];\nlong long dp[5005][5005][2], tmp[5005], tmp1[5005];\n\nvector <int> edge[5005];\n\nlong long min(long long a, long long b) {\n    return a < b ? a : b;\n}\n\nvoid solve(int id, int p) {\n    siz[id] = 1;\n\n    int child = 0;\n\n    for (int i = 0; i < edge[id].size(); i++) {\n        int to = edge[id][i];\n        if (to == p) continue;\n        solve(to, id);\n        siz[id] += siz[to];\n        child++;\n    }\n\n    int cur = 0;\n\n    for (int i = 0; i < edge[id].size(); i++) {\n        int to = edge[id][i];\n        if (to == p) continue;\n\n        for (int j = siz[to]; j >= 1; j--) {\n            if (dp[to][j - 1][0] < 0) {\n                dp[to][j][0] = min(dp[to][j][0], 0LL);\n                dp[to][j][1] = 1;\n            }\n            if (dp[to][j - 1][1]) {\n                dp[to][j][0] = min(dp[to][j][0], 0LL);\n            }\n        }\n\n        cur += siz[to];\n\n\n        if (cur == siz[to]) {\n            //first child\n            for (int j = 0; j <= siz[to]; j++) {\n                dp[id][j][0] = dp[to][j][0];\n                dp[id][j][1] = dp[to][j][1] && (a[id] > 0);\n            }\n        }\n        else {\n            for (int j = cur; j >= 0; j--) {\n                tmp[j] = INF;\n                tmp1[j] = 0;\n                int v = min(j, siz[to]);\n                for (int k = 0; k <= v; k++) {\n                    if (dp[to][k][0] != INF && dp[id][j - k][0] != INF) tmp[j] = min(tmp[j], dp[to][k][0] + dp[id][j - k][0]);\n                    tmp1[j] |= (dp[to][k][1] && dp[id][j - k][1]);\n                }\n            }\n            for (int j = 0; j <= cur; j++) {\n                dp[id][j][0] = tmp[j];\n                dp[id][j][1] = tmp1[j] && (a[id] > 0);\n            }\n        }\n    }\n\n    for (int i = siz[id] - 1; i >= 0; i--) {\n        if (dp[id][i][0] != INF) dp[id][i][0] += a[id];\n    }\n\n    if (child == 0) {\n        dp[id][0][0] = a[id];\n        dp[id][0][1] = a[id] >  0;\n    }\n}\n\nint main() {\n    scanf(\"%d\", &n);\n\n    for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\n    for (int i = 0; i < n - 1; i++) {\n        int x, y;\n        scanf(\"%d%d\", &x, &y);\n        edge[x].push_back(y);\n        edge[y].push_back(x);\n    }\n\n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j <= n; j++) {\n            dp[i][j][0] = INF;\n            dp[i][j][1] = 0;\n        }\n    }\n\n    solve(1, -1);\n\n    for (int i = 0; i < n; i++) {\n        if (dp[1][i][0] < 0) return 0 * printf(\"%d\\n\", i);\n        if (dp[1][i][1]) return 0 * printf(\"%d\\n\", i);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing i64 = long long;\n\nconstexpr i64 inf = 10000000000000;\n\ni64 dp[5010][5010][2];\nstd::vector<i64> a;\nstd::vector<std::deque<int>> g;\n\nint dfs(int v, int p) {\n    if (a[v] > 0) dp[v][0][0] = a[v];\n    else dp[v][0][1] = a[v];\n\n    int ret = 1;\n\n    for (auto c : g[v]) {\n        if (c == p) continue;\n        int ss = dfs(c, v);\n\n        std::vector<std::vector<i64>> tmp(ret + ss, std::vector<i64>(2, inf));\n\n        for (int i = 0; i < ret; i++) {\n            for (int j = 0; j < ss; j++) {\n                tmp[i + j][0] = std::min(tmp[i + j][0], dp[v][i][0] + dp[c][j][0]);\n                tmp[i + j][1] = std::min({ tmp[i + j][1], dp[v][i][0] + dp[c][j][1], dp[v][i][1] + dp[c][j][0], dp[v][i][1] + dp[c][j][1] });\n\n                if (dp[c][j][0] >= inf && dp[c][j][1] >= 0) continue;\n\n                tmp[i + j + 1][0] = std::min(tmp[i + j + 1][0], dp[v][i][0]);\n                tmp[i + j + 1][1] = std::min(tmp[i + j + 1][1], dp[v][i][1]);\n            }\n        }\n\n        ret += ss;\n\n        for (int i = 0; i < ret; i++) {\n            dp[v][i][0] = tmp[i][0];\n            dp[v][i][1] = tmp[i][1];\n            tmp[i][0] = inf;\n            tmp[i][1] = inf;\n        }\n    }\n\n    // for (int i = 0; i < ret; i++) {\n    //     printf(\"dp[%d][%d] = { %lld, %lld }\\n\", v + 1, i, dp[v][i][0], dp[v][i][1]);\n    // }\n\n    return ret;\n}\n\nint main() {\n    int n;\n    std::cin >> n;\n    a.resize(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    g.resize(n);\n    for (int i = 0; i < n - 1; i++) {\n        int u, v;\n        std::cin >> u >> v;\n        u--; v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n\n    for (int i = 0; i < n; i++) for (int j = 0; j < n; j++) {\n        dp[i][j][0] = inf;\n        dp[i][j][1] = inf;\n    }\n\n    dfs(0, -1);\n\n    int ret = 0;\n    while (dp[0][ret][0] >= inf && dp[0][ret][1] >= 0) ret++;\n    std::cout << ret << std::endl;\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thanks for @rsk0315_h4x\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 2000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1000000\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\nusing std::get;\n\ntemplate <typename T, typename U>\npair<T, U> operator+(pair<T, U> l, pair<T, U> r) {\n\treturn pair<T, U>(l.first + r.first, l.second + r.second);\n}\n\n#endif\n\ntypedef struct {\n\tint32_t a;\n\tint32_t b;\n} hw;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n#define BEGCMP(NAME) int32_t NAME (const void *left, const void *right)\n#define DEFLR(TYPE) TYPE l=*(TYPE*)left,r=*(TYPE*)right\n#define CMPRET(L, R) if((L)<(R))return-1;if((L)>(R))return+1\n\n// int32_t pullcomp (const void *left, const void *right) {\n// \tull l = *(ull*)left;\n// \tull r = *(ull*)right;\n// \tif (l < r) {\n// \t\treturn -1;\n// \t}\n// \tif (l > r) {\n// \t\treturn +1;\n// \t}\n// \treturn 0;\n// }\nBEGCMP(pullcomp){\n\tDEFLR(ull);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(prevcomp){\n\tDEFLR(ull);\n\tCMPRET(r, l);\n\treturn 0;\n}\nBEGCMP(psllcomp){\n\tDEFLR(sll);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pcharcomp){\n\tDEFLR(char);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pdoublecomp){\n\tDEFLR(double);\n\tCMPRET(l, r);\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nBEGCMP(phwllABcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwllREVcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\treturn 0;\n}\nBEGCMP(ptriplecomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleREVcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nsll a[N_MAX + 5];\n// ull a[N_MAX + 5];\n// sll a[3001][3001];\nsll b[N_MAX + 5];\n// ull b[N_MAX + 5];\n// sll b[3001][3001];\nsll c[N_MAX + 5];\null d[N_MAX + 5];\nsll e[N_MAX];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\nchar u[N_MAX + 1];\nhwll xy[N_MAX + 5];\nhwllc tup[N_MAX + 5];\nsll table[3005][3005];\n// here we go\n\null gin[N_MAX];\null vvv (ull v, ull p) {\n\te[v] = 1;\n\tfor (sll i = gin[v]; i < gin[v + 1]; i++) {\n\t\tull u = xy[i].b;\n\t\tif (u == p) continue;\n\t\td[u] = d[v] + 1;\n\t\te[v] += vvv(u, v);\n\t}\n\treturn e[v];\n}\n\nsll dp[5005][2][5005];\null dfs (ull v, ull p) {\n\tsll tmp[2][e[v]];\n\n\tfor (sll i = 0; i <= n; i++) {\n\t\tdp[v][0][i] = dp[v][1][i] = VERYBIG;\n\t}\n\tdp[v][(c[v] < 0) ? 1 : 0][0] = c[v];\n\t// printf(\"%lld %lld: %lld\\n\", v, 0LL, c[v]);\n\tull maxv = 1;\n\tfor (sll i = gin[v]; i < gin[v + 1]; i++) {\n\t\tull u = xy[i].b;\n\t\tif (u == p) continue;\n\t\tull maxu = dfs(u, v);\n\n\t\tfor (sll x = 0; x < e[v]; x++) tmp[0][x] = tmp[1][x] = VERYBIG;\n\t\tfor (sll x = 0; x <= maxv - 1; x++) {\n\t\t\tfor (sll y = 0; y <= maxu - 1; y++) {\n\n\t\t\t\tfor (sll z1 = 0; z1 <= 1; z1++) {\n\n\t\t\t\t\tfor (sll z2 = 0; z2 <= 1; z2++) {\n\n\t\t\t\t\t\ttmp[z1 | z2][x + y] = smin(tmp[z1 | z2][x + y], dp[v][z1][x] + dp[u][z2][y]);\n\t\t\t\t\t\t// printf(\"%lld+%lld [%lld] <- %lld\\n\", x, y, (z1 | z2), tmp[z1 | z2][x + y]);\n\t\t\t\t\t\tif ((!z2 && dp[u][z2][y] != VERYBIG) || dp[u][z2][y] < 0) {\n\t\t\t\t\t\t\ttmp[z1][x + y + 1] = smin(tmp[z1][x + y + 1], dp[v][z1][x]);\n\t\t\t\t\t\t\t// printf(\"%lld+%lld+1 [%lld] <- %lld (%lld %lld %lld: %lld)\\n\", x, y, z1, tmp[z1][x + y + 1], u, z2, y, dp[u][z2][y]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tfor (sll x = 0; x < e[v]; x++) {\n\t\t\tdp[v][0][x] = tmp[0][x];\n\t\t\tdp[v][1][x] = tmp[1][x];\n\t\t\t// printf(\"%lld/%lld: %lld, %lld\\n\", v, x, dp[v][0][x], dp[v][1][x]);\n\t\t}\n\t\tmaxv += maxu;\n\t}\n\t// printf(\"%lld: %llu %s\\n\", v, maxv, (hascon[v] ? \"HAS\" : \"NO\"));\n\treturn maxv;\n}\n\null solve () {\n\tsll i, j, ki, li;\n\t// ull result = 0;\n\tsll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tull *dpcell;\n\n\tfor (i = 0; i < n - 1; i++) {\n\t\txy[i * 2] = (hwll){a[i], b[i]};\n\t\txy[i * 2 + 1] = (hwll){b[i], a[i]};\n\t}\n\tqsort(xy, (n - 1) * 2, sizeof(hwll), phwllABcomp);\n\ti = j = 0;\n\twhile (i <= n) {\n\t\tgin[i] = j;\n\t\twhile (j < (n - 1) * 2 && xy[j].a == i) j++;\n\t\ti++;\n\t}\n\n\tull v = 0;\n\tvvv(v, n);\n\tfor (i = 0; i < n; i++) if (d[i] > d[v]) v = i;\n\tvvv(v, n);\n\tull u = 0;\n\tfor (i = 0; i < n; i++) if (d[i] > d[u]) u = i;\n\tfor (i = 0; i < n; i++) if (d[i] == d[u] / 2) break;\n\tv = i;\n\tvvv(v, n);\n\n\tdfs(v, n);\n\n\tfor (i = 0; i <= n; i++) {\n\t\tif (dp[v][0][i] != VERYBIG || dp[v][1][i] < 0) break;\n\t}\n\tresult = i;\n\n\tprintf(\"%lld\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\tputs(\"YES\");\n\t// puts(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"Yay!\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\t// puts(\"No\");\n\t// puts(\"0\");\n\tputs(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\"Impossible\");\n\treturn 1;\n}\n\nint32_t main (void) {\n\tint32_t i, j;\n\tint32_t x, y;\n\n\n\n\t// scanf(\"%llu%llu\", &h, &w);\n\tscanf(\"%llu\", &n, &m);\n\t// scanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%lld%lld\", &va, &vb, &vc, &vd);\n\t// scanf(\"%llu%llu%llu\", &ua, &ub, &uc, &ud);\n\t// scanf(\"%s\", t);\n\t// scanf(\"%lld\", &m);\n\tfor (i = 0; i < n; i++) {\n\t\t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\t// scanf(\"%lld%lld%lld\", &tup[i].a, &tup[i].b, &tup[i].c);\n\t\t// scanf(\"%lld\", &a[i]);\n\t\t// scanf(\"%lld\", &b[i]);\n\t\tscanf(\"%lld\", &c[i]);\n\t\t// scanf(\"%lld\", &d[i]);\n\t\t// a[i]--;\n\t\t// b[i]--;\n\t\t// c[i]--;\n\t\t// d[i]--;\n\t\t// xy[i].a--;\n\t\t// xy[i].b--;\n\t\t// tup[i].a--;\n\t\t// tup[i].b--;\n\t}\n\tfor (i = 0; i < n - 1; i++) {\n\t\tscanf(\"%lld%lld\", &a[i], &b[i]);\n\t\ta[i]--;\n\t\tb[i]--;\n\t}\n\t// scanf(\"%llu\", &m, &k);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%lld\", &a[i]);\n\t// \t// scanf(\"%lld\", &b[i]);\n\t// \t// b[i]--;\n\t// \t// c[i]--;\n\t// }\n\t// scanf(\"%llu\", &q);\n\n\t// for (i = 0; i < q; i++) {\n\t// \tscanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \txy[i].a--;\n\t// \txy[i].b--;\n\t// }\n\n\t// for (i = 0; i < n; i++) {\n\t// \tfor (j = 0; j < n; j++) {\n\t// \t\tscanf(\"%lld\", &table[i][j]);\n\t// \t\t// table[i][j]--;\n\t// \t}\n\t// }\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", s[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thanks for @rsk0315_h4x\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 2000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1000000\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\nusing std::get;\n\ntemplate <typename T, typename U>\npair<T, U> operator+(pair<T, U> l, pair<T, U> r) {\n\treturn pair<T, U>(l.first + r.first, l.second + r.second);\n}\n\n#endif\n\ntypedef struct {\n\tint32_t a;\n\tint32_t b;\n} hw;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n#define BEGCMP(NAME) int32_t NAME (const void *left, const void *right)\n#define DEFLR(TYPE) TYPE l=*(TYPE*)left,r=*(TYPE*)right\n#define CMPRET(L, R) if((L)<(R))return-1;if((L)>(R))return+1\n\n// int32_t pullcomp (const void *left, const void *right) {\n// \tull l = *(ull*)left;\n// \tull r = *(ull*)right;\n// \tif (l < r) {\n// \t\treturn -1;\n// \t}\n// \tif (l > r) {\n// \t\treturn +1;\n// \t}\n// \treturn 0;\n// }\nBEGCMP(pullcomp){\n\tDEFLR(ull);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(prevcomp){\n\tDEFLR(ull);\n\tCMPRET(r, l);\n\treturn 0;\n}\nBEGCMP(psllcomp){\n\tDEFLR(sll);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pcharcomp){\n\tDEFLR(char);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pdoublecomp){\n\tDEFLR(double);\n\tCMPRET(l, r);\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nBEGCMP(phwllABcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwllREVcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\treturn 0;\n}\nBEGCMP(ptriplecomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleREVcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nsll a[N_MAX + 5];\n// ull a[N_MAX + 5];\n// sll a[3001][3001];\nsll b[N_MAX + 5];\n// ull b[N_MAX + 5];\n// sll b[3001][3001];\nsll c[N_MAX + 5];\null d[N_MAX + 5];\nsll e[N_MAX];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\nchar u[N_MAX + 1];\nhwll xy[N_MAX + 5];\nhwllc tup[N_MAX + 5];\nsll table[3005][3005];\n// here we go\n\null gin[N_MAX];\nbool hascon[N_MAX];\nsll dp[5005][2][5005];\null dfs (ull v, ull p) {\n\tsll tmp[2][5005];\n\thascon[v] = ((c[v] < 0) ? true : false);\n\n\tfor (sll i = 0; i <= n; i++) {\n\t\tdp[v][0][i] = dp[v][1][i] = VERYBIG;\n\t}\n\tdp[v][hascon[v] ? 1 : 0][0] = c[v];\n\t// printf(\"%lld %lld: %lld\\n\", v, 0LL, c[v]);\n\tull maxv = 1;\n\tfor (sll i = gin[v]; i < gin[v + 1]; i++) {\n\t\tull u = xy[i].b;\n\t\tif (u == p) continue;\n\t\tull maxu = dfs(u, v);\n\n\t\tfor (sll x = 0; x <= n; x++) tmp[0][x] = tmp[1][x] = VERYBIG;\n\t\tfor (sll x = 0; x <= maxv - 1; x++) {\n\t\t\tfor (sll y = 0; y <= maxu - 1; y++) {\n\n\t\t\t\tfor (sll z1 = 0; z1 <= 1; z1++) {\n\n\t\t\t\t\tfor (sll z2 = 0; z2 <= 1; z2++) {\n\n\t\t\t\t\t\ttmp[z1 | z2][x + y] = smin(tmp[z1 | z2][x + y], dp[v][z1][x] + dp[u][z2][y]);\n\t\t\t\t\t\t// printf(\"%lld+%lld [%lld] <- %lld\\n\", x, y, (z1 | z2), tmp[z1 | z2][x + y]);\n\t\t\t\t\t\tif ((!z2 && dp[u][z2][y] != VERYBIG) || dp[u][z2][y] < 0) {\n\t\t\t\t\t\t\ttmp[z1][x + y + 1] = smin(tmp[z1][x + y + 1], dp[v][z1][x]);\n\t\t\t\t\t\t\t// printf(\"%lld+%lld+1 [%lld] <- %lld (%lld %lld %lld: %lld)\\n\", x, y, z1, tmp[z1][x + y + 1], u, z2, y, dp[u][z2][y]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tfor (sll x = 0; x <= n; x++) {\n\t\t\tdp[v][0][x] = tmp[0][x];\n\t\t\tdp[v][1][x] = tmp[1][x];\n\t\t\t// printf(\"%lld/%lld: %lld, %lld\\n\", v, x, dp[v][0][x], dp[v][1][x]);\n\t\t}\n\t\t// hascon[v] |= hascon[u];\n\t\tmaxv += maxu;\n\t}\n\t// printf(\"%lld: %llu %s\\n\", v, maxv, (hascon[v] ? \"HAS\" : \"NO\"));\n\treturn maxv;\n}\n\null solve () {\n\tsll i, j, ki, li;\n\t// ull result = 0;\n\tsll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tull *dpcell;\n\n\tfor (i = 0; i < n - 1; i++) {\n\t\txy[i * 2] = (hwll){a[i], b[i]};\n\t\txy[i * 2 + 1] = (hwll){b[i], a[i]};\n\t}\n\tqsort(xy, (n - 1) * 2, sizeof(hwll), phwllABcomp);\n\ti = j = 0;\n\twhile (i <= n) {\n\t\tgin[i] = j;\n\t\twhile (j < (n - 1) * 2 && xy[j].a == i) j++;\n\t\ti++;\n\t}\n\n\tdfs(0, n);\n\tfor (i = 0; i <= n; i++) {\n\t\tif (dp[0][0][i] != VERYBIG || dp[0][1][i] < 0) break;\n\t}\n\tresult = i;\n\n\tprintf(\"%lld\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\tputs(\"YES\");\n\t// puts(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"Yay!\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\t// puts(\"No\");\n\t// puts(\"0\");\n\tputs(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\"Impossible\");\n\treturn 1;\n}\n\nint32_t main (void) {\n\tint32_t i, j;\n\tint32_t x, y;\n\n\n\n\t// scanf(\"%llu%llu\", &h, &w);\n\tscanf(\"%llu\", &n, &m);\n\t// scanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%lld%lld\", &va, &vb, &vc, &vd);\n\t// scanf(\"%llu%llu%llu\", &ua, &ub, &uc, &ud);\n\t// scanf(\"%s\", t);\n\t// scanf(\"%lld\", &m);\n\tfor (i = 0; i < n; i++) {\n\t\t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\t// scanf(\"%lld%lld%lld\", &tup[i].a, &tup[i].b, &tup[i].c);\n\t\t// scanf(\"%lld\", &a[i]);\n\t\t// scanf(\"%lld\", &b[i]);\n\t\tscanf(\"%lld\", &c[i]);\n\t\t// scanf(\"%lld\", &d[i]);\n\t\t// a[i]--;\n\t\t// b[i]--;\n\t\t// c[i]--;\n\t\t// d[i]--;\n\t\t// xy[i].a--;\n\t\t// xy[i].b--;\n\t\t// tup[i].a--;\n\t\t// tup[i].b--;\n\t}\n\tfor (i = 0; i < n - 1; i++) {\n\t\tscanf(\"%lld%lld\", &a[i], &b[i]);\n\t\ta[i]--;\n\t\tb[i]--;\n\t}\n\t// scanf(\"%llu\", &m, &k);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%lld\", &a[i]);\n\t// \t// scanf(\"%lld\", &b[i]);\n\t// \t// b[i]--;\n\t// \t// c[i]--;\n\t// }\n\t// scanf(\"%llu\", &q);\n\n\t// for (i = 0; i < q; i++) {\n\t// \tscanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \txy[i].a--;\n\t// \txy[i].b--;\n\t// }\n\n\t// for (i = 0; i < n; i++) {\n\t// \tfor (j = 0; j < n; j++) {\n\t// \t\tscanf(\"%lld\", &table[i][j]);\n\t// \t\t// table[i][j]--;\n\t// \t}\n\t// }\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", s[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.StringJoiner;\nimport java.util.StringTokenizer;\nimport java.util.function.Function;\n\npublic class Main {\n\n    static int N;\n    static int[] A;\n    static int[] U, V;\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner(System.in);\n        N = sc.nextInt();\n        A = sc.nextIntArray(N);\n        U = new int[N-1];\n        V = new int[N-1];\n        for (int i = 0; i < N - 1; i++) {\n            U[i] = sc.nextInt()-1;\n            V[i] = sc.nextInt()-1;\n        }\n\n        System.out.println(solve());\n    }\n\n    static long INF = Long.MAX_VALUE / 2;\n    static int ROOT = 0;\n\n    static int solve() {\n        // バッテリーだけ\n        // (v, cut) => 最小値\n        long[][] dp = new long[N][];\n\n        // コンピューター含む\n        // (v, cut) => 最小値\n        long[][] dp2 = new long[N][];\n\n        // v -> カット数の容量\n        int[] dp3 = new int[N];\n\n        int[][] G = adjB(N, U, V);\n        for (Node node : orderFromLeaf(N, G, ROOT)) {\n            merge(node, G, dp, dp2, dp3);\n        }\n\n        int ret = Integer.MAX_VALUE;\n        for (int i = 0; i < N; i++) {\n            if( dp[ROOT][i] != INF ) {\n                ret = Math.min(i, ret);\n            }\n            if( dp2[ROOT][i] != INF && dp2[ROOT][i] < 0) {\n                ret = Math.min(i, ret);\n            }\n        }\n        return ret;\n    }\n\n    static void merge(Node node, int[][] G, long[][] dp, long[][] dp2, int[] dp3) {\n        dp[node.a] = new long[]{INF};\n        dp2[node.a] = new long[]{INF};\n        if( A[node.a] > 0 ) {\n            dp[node.a][0] = A[node.a];\n        } else {\n            dp2[node.a][0] = A[node.a];\n        }\n        int c = 1;\n        for (int next : G[node.a]) {\n            if( node.parent == next ) continue;\n\n            long[] tdp = new long[c+dp3[next]];\n            Arrays.fill(tdp, INF);\n            long[] tdp2 = new long[c+dp3[next]];\n            Arrays.fill(tdp2, INF);\n\n            for (int i = 0; i < c; i++) {\n                for (int j = 0; j < dp3[next]; j++) {\n                    // バ + バ = バ\n                    if( dp[node.a][i] != INF && dp[next][j] != INF ) {\n                        tdp[i+j] = Math.min(dp[node.a][i] + dp[next][j], tdp[i+j]);\n                    }\n\n                    // バ + コ = コ\n                    if( dp[node.a][i] != INF && dp2[next][j] != INF ) {\n                        long sum = dp[node.a][i] + dp2[next][j];\n                        tdp2[i+j] = Math.min(sum, tdp2[i+j]);\n                    }\n                    if( dp2[node.a][i] != INF && dp[next][j] != INF ) {\n                        long sum = dp2[node.a][i] + dp[next][j];\n                        tdp2[i+j] = Math.min(sum, tdp2[i+j]);\n                    }\n\n                    // コ + コ = コ\n                    if( dp2[node.a][i] != INF && dp2[next][j] != INF ) {\n                        tdp2[i+j] = Math.min(dp2[node.a][i] + dp2[next][j], tdp2[i+j]);\n                    }\n\n                    // cutする\n                    if( dp[node.a][i] != INF && (dp[next][j] != INF || dp2[next][j] != INF && dp2[next][j] < 0) ) {\n                        tdp[i+j+1] = Math.min(dp[node.a][i], tdp[i+j+1]);\n                    }\n                    if( dp2[node.a][i] != INF && (dp[next][j] != INF || dp2[next][j] != INF && dp2[next][j] < 0)) {\n                        tdp2[i+j+1] = Math.min(dp2[node.a][i], tdp2[i+j+1]);\n                    }\n                }\n            }\n\n            dp[node.a] = tdp;\n            dp2[node.a] = tdp2;\n            c += dp3[next];\n        }\n        dp3[node.a] = c;\n    }\n\n    static int[][] adjB(int n, int[] from, int[] to) {\n        int[][] adj = new int[n][];\n        int[] cnt = new int[n];\n        for (int f : from) {\n            cnt[f]++;\n        }\n        for (int t : to) {\n            cnt[t]++;\n        }\n        for (int i = 0; i < n; i++) {\n            adj[i] = new int[cnt[i]];\n        }\n        for (int i = 0; i < from.length; i++) {\n            adj[from[i]][--cnt[from[i]]] = to[i];\n            adj[to[i]][--cnt[to[i]]] = from[i];\n        }\n        return adj;\n    }\n\n    static Node[] orderFromLeaf(int N, int[][] G, int root) {\n        ArrayDeque<Node> q = new ArrayDeque<>();\n        Node[] ret = new Node[N];\n        int idx = N-1;\n        q.add(new Node(-1, root));\n        while(!q.isEmpty()) {\n            Node n = q.poll();\n            ret[idx--] = n;\n            for (int next : G[n.a]) {\n                if( next == n.parent ) continue;\n\n                q.add(new Node(n.a, next));\n            }\n        }\n        return ret;\n    }\n\n    static class Node {\n        int parent, a;\n\n        public Node(int parent, int a) {\n            this.parent = parent;\n            this.a = a;\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    static class FastScanner {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        int[] nextIntArray(int n, int delta) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt() + delta;\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n    }\n\n    static <A> void writeLines(A[] as, Function<A, String> f) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (A a : as) {\n            pw.println(f.apply(a));\n        }\n        pw.flush();\n    }\n\n    static void writeLines(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static void writeLines(long[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (long a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static int max(int... as) {\n        int max = Integer.MIN_VALUE;\n        for (int a : as) max = Math.max(a, max);\n        return max;\n    }\n\n    static int min(int... as) {\n        int min = Integer.MAX_VALUE;\n        for (int a : as) min = Math.min(a, min);\n        return min;\n    }\n\n    static void debug(Object... args) {\n        StringJoiner j = new StringJoiner(\" \");\n        for (Object arg : args) {\n            if (arg instanceof int[]) j.add(Arrays.toString((int[]) arg));\n            else if (arg instanceof long[]) j.add(Arrays.toString((long[]) arg));\n            else if (arg instanceof double[]) j.add(Arrays.toString((double[]) arg));\n            else if (arg instanceof Object[]) j.add(Arrays.toString((Object[]) arg));\n            else j.add(arg.toString());\n        }\n        System.err.println(j.toString());\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\n\npublic class Main {\n  private static void solve() {\n    int n = ni();\n    long[] a = nal(n);\n    int[] from = new int[n - 1];\n    int[] to = new int[n - 1];\n    for (int i = 0; i < n - 1; i ++) {\n      from[i] = ni() - 1;\n      to[i] = ni() - 1;\n    }\n    int[][] g = packU(n, from, to);\n    int[][] pars = parents3(g, 0);\n    long[][][] dp = new long[n][2][];\n    int[] ord = pars[1];\n    int[] par = pars[0];\n    \n    for (int i = n - 1; i >= 0; i --) {\n      int cur = ord[i];\n      long[][] ldp = new long[2][1];\n      ldp[0][0] = a[cur];\n      ldp[1][0] = a[cur] < 0 ? Long.MAX_VALUE / 2 : a[cur];\n      for (int e : g[cur]) {\n        if (par[cur] == e) continue;\n        long[][] nldp = conv(ldp, dp[e]);\n        ldp = nldp;\n      }\n      dp[cur] = ldp;\n    }\n    \n    for (int i = 0; i < dp[0][0].length;  i++) {\n      if (dp[0][0][i] < 0 || dp[0][1][i] < Long.MAX_VALUE / 3) {\n        out.println(i);\n        return;\n      }\n    }\n  }\n  \n\n  private static long[][] conv(long[][] a, long[][] b) {\n    int n = a[0].length;\n    int m = b[0].length;\n    long[][] c = new long[2][n + m];\n    for (long[] v: c) Arrays.fill(v, Long.MAX_VALUE / 2);\n    for (int i = 0; i < n; i ++) {\n      for (int j = 0; j < m; j ++) {\n        c[0][i + j] = Math.min(c[0][i + j], a[0][i] + b[0][j]);\n        c[1][i + j] = Math.min(c[1][i + j], a[1][i] + b[1][j]);\n        \n        if (b[0][j] < 0 || b[1][j] <= Long.MAX_VALUE / 3) {\n          c[0][i + j + 1] = Math.min(c[0][i + j + 1], a[0][i]);\n          c[1][i + j + 1] = Math.min(c[1][i + j + 1], a[1][i]);\n        }\n      }\n    }\n    return c;\n  }\n\n\n  public static int[][] parents3(int[][] g, int root) {\n    int n = g.length;\n    int[] par = new int[n];\n    Arrays.fill(par, -1);\n\n    int[] depth = new int[n];\n    depth[0] = 0;\n\n    int[] q = new int[n];\n    q[0] = root;\n    for (int p = 0, r = 1; p < r; p++) {\n        int cur = q[p];\n        for (int nex : g[cur]) {\n            if (par[cur] != nex) {\n                q[r++] = nex;\n                par[nex] = cur;\n                depth[nex] = depth[cur] + 1;\n            }\n        }\n    }\n    return new int[][] { par, q, depth };\n}\n  \n  static int[][] packU(int n, int[] from, int[] to) {\n    int[][] g = new int[n][];\n    int[] p = new int[n];\n    for (int f : from)\n        p[f]++;\n    for (int t : to)\n        p[t]++;\n    for (int i = 0; i < n; i++)\n        g[i] = new int[p[i]];\n    for (int i = 0; i < from.length; i++) {\n        g[from[i]][--p[from[i]]] = to[i];\n        g[to[i]][--p[to[i]]] = from[i];\n    }\n    return g;\n}\n  \n  public static void main(String[] args) {\n    new Thread(null, new Runnable() {\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        String debug = args.length > 0 ? args[0] : null;\n        if (debug != null) {\n          try {\n            is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n        reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n        solve();\n        out.flush();\n        tr((System.currentTimeMillis() - start) + \"ms\");\n      }\n    }, \"\", 64000000).start();\n  }\n\n  private static java.io.InputStream is = System.in;\n  private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n  private static java.util.StringTokenizer tokenizer = null;\n  private static java.io.BufferedReader reader;\n\n  public static String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  private static double nd() {\n    return Double.parseDouble(next());\n  }\n\n  private static long nl() {\n    return Long.parseLong(next());\n  }\n\n  private static int[] na(int n) {\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static char[] ns() {\n    return next().toCharArray();\n  }\n\n  private static long[] nal(int n) {\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++)\n      a[i] = nl();\n    return a;\n  }\n\n  private static int[][] ntable(int n, int m) {\n    int[][] table = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[i][j] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int[][] nlist(int n, int m) {\n    int[][] table = new int[m][n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[j][i] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int ni() {\n    return Integer.parseInt(next());\n  }\n\n  private static void tr(Object... o) {\n    if (is != System.in)\n      System.out.println(java.util.Arrays.deepToString(o));\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\n\npublic class Main {\n  private static void solve() {\n    int n = ni();\n    long[] a = nal(n);\n    int[] from = new int[n - 1];\n    int[] to = new int[n - 1];\n    for (int i = 0; i < n - 1; i ++) {\n      from[i] = ni() - 1;\n      to[i] = ni() - 1;\n    }\n    int[][] g = packU(n, from, to);\n    long[][] dp = dfs(0, -1, g, a);\n    \n    for (int i = 0; i < dp[0].length; i ++) {\n      if (dp[0][i] < 0 || dp[1][i] < Long.MAX_VALUE / 3) {\n        System.out.println(i);\n        return;\n      }\n    }\n  }\n  \n  private static long[][] dfs(int now, int pre, int[][] g, long[] a) {\n    long[][] dp = new long[2][1];\n    dp[0][0] = a[now];\n    dp[1][0] = a[now] < 0 ? Long.MAX_VALUE / 2 : a[now];\n\n    for (int next : g[now]) {\n      if (next == pre) continue;\n      \n      long[][] cdp = dfs(next, now, g, a);\n      \n      int n = dp[0].length;\n      int m = cdp[0].length;\n      long[][] ndp = new long[2][n + m];\n      for (long[] v : ndp) Arrays.fill(v, Long.MAX_VALUE / 2);\n      for (int i = 0; i < n; i ++) {\n        for (int j = 0; j < m; j ++) {\n          ndp[0][i + j] = Math.min(ndp[0][i + j], dp[0][i] + cdp[0][j]);\n          ndp[1][i + j] = Math.min(ndp[1][i + j], dp[1][i] + cdp[1][j]);\n          \n          if (cdp[0][j] < 0 || cdp[1][j] < Long.MAX_VALUE / 3) {\n            ndp[0][i + j + 1] = Math.min(ndp[0][i + j + 1], dp[0][i]);\n            ndp[1][i + j + 1] = Math.min(ndp[1][i + j + 1], dp[1][i]);\n          }\n        }\n      }\n      dp = ndp;\n    }\n    return dp;\n  }\n  \n  static int[][] packU(int n, int[] from, int[] to) {\n    int[][] g = new int[n][];\n    int[] p = new int[n];\n    for (int f : from)\n        p[f]++;\n    for (int t : to)\n        p[t]++;\n    for (int i = 0; i < n; i++)\n        g[i] = new int[p[i]];\n    for (int i = 0; i < from.length; i++) {\n        g[from[i]][--p[from[i]]] = to[i];\n        g[to[i]][--p[to[i]]] = from[i];\n    }\n    return g;\n}\n  \n  public static void main(String[] args) {\n    new Thread(null, new Runnable() {\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        String debug = args.length > 0 ? args[0] : null;\n        if (debug != null) {\n          try {\n            is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n        reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n        solve();\n        out.flush();\n        tr((System.currentTimeMillis() - start) + \"ms\");\n      }\n    }, \"\", 64000000).start();\n  }\n\n  private static java.io.InputStream is = System.in;\n  private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n  private static java.util.StringTokenizer tokenizer = null;\n  private static java.io.BufferedReader reader;\n\n  public static String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  private static double nd() {\n    return Double.parseDouble(next());\n  }\n\n  private static long nl() {\n    return Long.parseLong(next());\n  }\n\n  private static int[] na(int n) {\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static char[] ns() {\n    return next().toCharArray();\n  }\n\n  private static long[] nal(int n) {\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++)\n      a[i] = nl();\n    return a;\n  }\n\n  private static int[][] ntable(int n, int m) {\n    int[][] table = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[i][j] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int[][] nlist(int n, int m) {\n    int[][] table = new int[m][n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[j][i] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int ni() {\n    return Integer.parseInt(next());\n  }\n\n  private static void tr(Object... o) {\n    if (is != System.in)\n      System.out.println(java.util.Arrays.deepToString(o));\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyInput in = new MyInput(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskE solver = new TaskE();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskE {\n        int n;\n        int[] dp;\n        int[] dp1;\n        long[][] dp2;\n        List<Integer>[] g;\n        int[] a;\n        int[] size = new int[10000];\n\n        public void solve(int testNumber, MyInput in, PrintWriter out) {\n            n = in.nextInt();\n            a = in.nextIntArray(n);\n            g = new List[n];\n            for (int i = 0; i < n; i++) {\n                g[i] = new ArrayList<>();\n            }\n            for (int i = 0; i < n - 1; i++) {\n                int a = in.nextInt() - 1;\n                int b = in.nextInt() - 1;\n                g[a].add(b);\n                g[b].add(a);\n            }\n            dp = new int[n];\n            dp1 = new int[n];\n            dp2 = new long[n][];\n            Arrays.fill(dp, -1);\n            Arrays.fill(dp1, -1);\n            out.println(rec(0, -1));\n        }\n\n        int rec(int v, int p) {\n            if (dp[v] != -1) {\n                return dp[v];\n            }\n\n            int ans = rec1(v, p);\n            for (int i = 0; i < size(v, p); i++) {\n                if (rec2(v, i, p) < 0) {\n                    ans = Math.min(ans, i);\n                    break;\n                }\n            }\n\n//        dump(v, ans);\n            return dp[v] = ans;\n        }\n\n        int rec1(int v, int p) {\n            if (dp1[v] != -1) {\n                return dp1[v];\n            }\n            if (a[v] < 0) return 1 << 29;\n            int ans = 0;\n            for (int t : g[v]) {\n                if (t == p) continue;\n                ans += Math.min(rec1(t, v), rec(t, v) + 1);\n            }\n//        if (v == 2) dump(\"come\", v, ans);\n            return dp1[v] = ans;\n        }\n\n        long rec2(int v, int e, int p) {\n            e = Math.min(e, size(v, p) - 1);\n            if (dp2[v] == null) {\n                long[] dp = new long[size(v, p)];\n                Arrays.fill(dp, 1L << 60);\n                dp[0] = a[v];\n                int num = 1;\n                for (int t : g[v]) {\n                    if (t == p) continue;\n                    num += size(t, v);\n                    for (int k = num - 1; k >= 0; k--) {\n                        dp[k] = dp[k] + rec2(t, 0, v);\n                        if (k > rec(t, v)) dp[k] = Math.min(dp[k - 1 - rec(t, v)], dp[k]);\n                        for (int i = 1; i < size(t, v) && i <= k; i++) {\n                            dp[k] = Math.min(dp[k], dp[k - i] + rec2(t, i, v));\n                        }\n                    }\n//                if (v == 0) {\n//                    dump(t, rec(t, v), dp);\n//                }\n                }\n                dp2[v] = dp;\n//            if (v == 2) dump(\"come\", v, dp);\n            }\n            return dp2[v][e];\n        }\n\n        int size(int v, int p) {\n            if (size[v] != 0) {\n                return size[v];\n            }\n            for (int t : g[v]) {\n                if (t == p) continue;\n                size[v] += size(t, v);\n            }\n            return ++size[v];\n        }\n\n    }\n\n    static class MyInput {\n        private final BufferedReader in;\n        private static int pos;\n        private static int readLen;\n        private static final char[] buffer = new char[1024 * 8];\n        private static char[] str = new char[500 * 8 * 2];\n        private static boolean[] isDigit = new boolean[256];\n        private static boolean[] isSpace = new boolean[256];\n        private static boolean[] isLineSep = new boolean[256];\n\n        static {\n            for (int i = 0; i < 10; i++) {\n                isDigit['0' + i] = true;\n            }\n            isDigit['-'] = true;\n            isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n            isLineSep['\\r'] = isLineSep['\\n'] = true;\n        }\n\n        public MyInput(InputStream is) {\n            in = new BufferedReader(new InputStreamReader(is));\n        }\n\n        public int read() {\n            if (pos >= readLen) {\n                pos = 0;\n                try {\n                    readLen = in.read(buffer);\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n                if (readLen <= 0) {\n                    throw new MyInput.EndOfFileRuntimeException();\n                }\n            }\n            return buffer[pos++];\n        }\n\n        public int nextInt() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            int ret = 0;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n\n        public char nextChar() {\n            while (true) {\n                final int c = read();\n                if (!isSpace[c]) {\n                    return (char) c;\n                }\n            }\n        }\n\n        int reads(int len, boolean[] accept) {\n            try {\n                while (true) {\n                    final int c = read();\n                    if (accept[c]) {\n                        break;\n                    }\n                    if (str.length == len) {\n                        char[] rep = new char[str.length * 3 / 2];\n                        System.arraycopy(str, 0, rep, 0, str.length);\n                        str = rep;\n                    }\n                    str[len++] = (char) c;\n                }\n            } catch (MyInput.EndOfFileRuntimeException e) {\n            }\n            return len;\n        }\n\n        public int[] nextIntArray(final int n) {\n            final int[] res = new int[n];\n            for (int i = 0; i < n; i++) {\n                res[i] = nextInt();\n            }\n            return res;\n        }\n\n        static class EndOfFileRuntimeException extends RuntimeException {\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            TaskE solver = new TaskE();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class TaskE {\n        MultiWayIntStack edges;\n        int[] a;\n        long[][] negDp;\n        long[] posDp;\n        int[] sizes;\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            a = new int[n + 1];\n            for (int i = 1; i <= n; i++) {\n                a[i] = in.readInt();\n            }\n            edges = new MultiWayIntStack(n + 1, n * 2);\n            for (int i = 1; i < n; i++) {\n                int a = in.readInt();\n                int b = in.readInt();\n                edges.addLast(a, b);\n                edges.addLast(b, a);\n            }\n            negDp = new long[n + 1][];\n            posDp = new long[n + 1];\n            sizes = new int[n + 1];\n\n            dfsForSize(1, 0);\n            dfs(1, 0);\n            long ans = posDp[1];\n            for (int i = 0; i < n; i++) {\n                if (negDp[1][i] < 0) {\n                    ans = Math.min(ans, i);\n                    break;\n                }\n            }\n            out.println(ans);\n        }\n\n        public void dfsForSize(int root, int p) {\n            sizes[root] = 1;\n            for (IntIterator iterator = edges.iterator(root); iterator.hasNext(); ) {\n                int node = iterator.next();\n                if (node == p) {\n                    continue;\n                }\n                dfsForSize(node, root);\n                sizes[root] += sizes[node];\n            }\n        }\n\n        public void dfs(int root, int p) {\n            posDp[root] = a[root] > 0 ? 0 : (long) 1e18;\n            int total = 1;\n\n            long[] last = new long[sizes[root]];\n            long[] next = new long[sizes[root]];\n            last[0] = a[root];\n            for (IntIterator iterator = edges.iterator(root); iterator.hasNext(); ) {\n                int node = iterator.next();\n                if (node == p) {\n                    continue;\n                }\n                dfs(node, root);\n                long atLeastNeed = posDp[node];\n                long cutAtLeast = posDp[node] + 1;\n                for (int i = 0; i < sizes[node]; i++) {\n                    if (negDp[node][i] < 0) {\n                        atLeastNeed = Math.min(atLeastNeed, i + 1);\n                        cutAtLeast = Math.min(cutAtLeast, i + 1);\n                        break;\n                    }\n                }\n                posDp[root] += atLeastNeed;\n                for (int i = 0; i < total + sizes[node]; i++) {\n                    next[i] = (long) 1e18;\n                    if (i >= cutAtLeast && i - cutAtLeast < total) {\n                        next[i] = Math.min(next[i], last[(int) (i - cutAtLeast)]);\n                    }\n                }\n                for (int i = 0; i < total; i++) {\n                    for (int j = 0; j < sizes[node]; j++) {\n                        next[i + j] = Math.min(next[i + j], last[i] + negDp[node][j]);\n                    }\n                }\n\n                total += sizes[node];\n                {\n                    long[] tmp = next;\n                    next = last;\n                    last = tmp;\n                }\n            }\n            negDp[root] = last;\n        }\n\n    }\n\n    static class MultiWayIntStack {\n        private int[] values;\n        private int[] next;\n        private int[] heads;\n        private int alloc;\n        private int stackNum;\n\n        public IntIterator iterator(final int queue) {\n            return new IntIterator() {\n                int ele = heads[queue];\n\n\n                public boolean hasNext() {\n                    return ele != 0;\n                }\n\n\n                public int next() {\n                    int ans = values[ele];\n                    ele = next[ele];\n                    return ans;\n                }\n            };\n        }\n\n        private void doubleCapacity() {\n            int newSize = Math.max(next.length + 10, next.length * 2);\n            next = Arrays.copyOf(next, newSize);\n            values = Arrays.copyOf(values, newSize);\n        }\n\n        public void alloc() {\n            alloc++;\n            if (alloc >= next.length) {\n                doubleCapacity();\n            }\n            next[alloc] = 0;\n        }\n\n        public MultiWayIntStack(int qNum, int totalCapacity) {\n            values = new int[totalCapacity + 1];\n            next = new int[totalCapacity + 1];\n            heads = new int[qNum];\n            stackNum = qNum;\n        }\n\n        public void addLast(int qId, int x) {\n            alloc();\n            values[alloc] = x;\n            next[alloc] = heads[qId];\n            heads[qId] = alloc;\n        }\n\n        public String toString() {\n            StringBuilder builder = new StringBuilder();\n            for (int i = 0; i < stackNum; i++) {\n                builder.append(i).append(\": \");\n                for (IntIterator iterator = iterator(i); iterator.hasNext(); ) {\n                    builder.append(iterator.next()).append(\",\");\n                }\n                if (builder.charAt(builder.length() - 1) == ',') {\n                    builder.setLength(builder.length() - 1);\n                }\n                builder.append('\\n');\n            }\n            return builder.toString();\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput println(long c) {\n            cache.append(c).append('\\n');\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static interface IntIterator {\n        boolean hasNext();\n\n        int next();\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyInput in = new MyInput(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskE solver = new TaskE();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskE {\n        int n;\n        int[] dp;\n        int[] dp1;\n        long[][] dp2;\n        List<Integer>[] g;\n        int[] a;\n        int[] size = new int[10000];\n\n        public void solve(int testNumber, MyInput in, PrintWriter out) {\n            n = in.nextInt();\n            a = in.nextIntArray(n);\n            g = new List[n];\n            for (int i = 0; i < n; i++) {\n                g[i] = new ArrayList<>();\n            }\n            for (int i = 0; i < n - 1; i++) {\n                int a = in.nextInt() - 1;\n                int b = in.nextInt() - 1;\n                g[a].add(b);\n                g[b].add(a);\n            }\n            dp = new int[n];\n            dp1 = new int[n];\n            dp2 = new long[n][];\n            Arrays.fill(dp, -1);\n            Arrays.fill(dp1, -1);\n            out.println(rec(0, -1));\n        }\n\n        int rec(int v, int p) {\n            if (dp[v] != -1) {\n                return dp[v];\n            }\n\n            int ans = rec1(v, p);\n            for (int i = 0; i < size(v, p); i++) {\n                if (rec2(v, i, p) < 0) {\n                    ans = Math.min(ans, i);\n                    break;\n                }\n            }\n\n//        dump(v, ans);\n            return dp[v] = ans;\n        }\n\n        int rec1(int v, int p) {\n            if (dp1[v] != -1) {\n                return dp1[v];\n            }\n            if (a[v] < 0) return 1 << 29;\n            int ans = 0;\n            for (int t : g[v]) {\n                if (t == p) continue;\n                ans += Math.min(rec1(t, v), rec(t, v) + 1);\n            }\n//        if (v == 2) dump(\"come\", v, ans);\n            return dp1[v] = ans;\n        }\n\n        long rec2(int v, int e, int p) {\n            e = Math.min(e, size(v, p) - 1);\n            if (dp2[v] == null) {\n                long[] dp = new long[size(v, p)];\n                Arrays.fill(dp, 1L << 60);\n                dp[0] = a[v];\n                int num = 1;\n                for (int t : g[v]) {\n                    if (t == p) continue;\n                    for (int k = num - 1; k >= 0; k--) {\n                        long cur = dp[k];\n                        dp[k] += rec2(t, 0, v);\n                        if (k + rec(t, v) + 1 < size(v, p)) {\n                            dp[k + rec(t, v) + 1] = Math.min(dp[k + rec(t, v) + 1], cur);\n                        }\n                        for (int i = size(t, v) - 1; i > 0; i--) {\n                            dp[k + i] = Math.min(dp[k + i], cur + rec2(t, i, v));\n                        }\n                    }\n                    num += size(t, v);\n//                if (v == 0) {\n//                    dump(t, rec(t, v), dp);\n//                }\n                }\n                dp2[v] = dp;\n//            if (v == 2) dump(\"come\", v, dp);\n            }\n            return dp2[v][e];\n        }\n\n        int size(int v, int p) {\n            if (size[v] != 0) {\n                return size[v];\n            }\n            for (int t : g[v]) {\n                if (t == p) continue;\n                size[v] += size(t, v);\n            }\n            return ++size[v];\n        }\n\n    }\n\n    static class MyInput {\n        private final BufferedReader in;\n        private static int pos;\n        private static int readLen;\n        private static final char[] buffer = new char[1024 * 8];\n        private static char[] str = new char[500 * 8 * 2];\n        private static boolean[] isDigit = new boolean[256];\n        private static boolean[] isSpace = new boolean[256];\n        private static boolean[] isLineSep = new boolean[256];\n\n        static {\n            for (int i = 0; i < 10; i++) {\n                isDigit['0' + i] = true;\n            }\n            isDigit['-'] = true;\n            isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n            isLineSep['\\r'] = isLineSep['\\n'] = true;\n        }\n\n        public MyInput(InputStream is) {\n            in = new BufferedReader(new InputStreamReader(is));\n        }\n\n        public int read() {\n            if (pos >= readLen) {\n                pos = 0;\n                try {\n                    readLen = in.read(buffer);\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n                if (readLen <= 0) {\n                    throw new MyInput.EndOfFileRuntimeException();\n                }\n            }\n            return buffer[pos++];\n        }\n\n        public int nextInt() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            int ret = 0;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n\n        public char nextChar() {\n            while (true) {\n                final int c = read();\n                if (!isSpace[c]) {\n                    return (char) c;\n                }\n            }\n        }\n\n        int reads(int len, boolean[] accept) {\n            try {\n                while (true) {\n                    final int c = read();\n                    if (accept[c]) {\n                        break;\n                    }\n                    if (str.length == len) {\n                        char[] rep = new char[str.length * 3 / 2];\n                        System.arraycopy(str, 0, rep, 0, str.length);\n                        str = rep;\n                    }\n                    str[len++] = (char) c;\n                }\n            } catch (MyInput.EndOfFileRuntimeException e) {\n            }\n            return len;\n        }\n\n        public int[] nextIntArray(final int n) {\n            final int[] res = new int[n];\n            for (int i = 0; i < n; i++) {\n                res[i] = nextInt();\n            }\n            return res;\n        }\n\n        static class EndOfFileRuntimeException extends RuntimeException {\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyInput in = new MyInput(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskE solver = new TaskE();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskE {\n        int n;\n        int[] dp;\n        int[] dp1;\n        long[][] dp2;\n        List<Integer>[] g;\n        int[] a;\n        int[] size = new int[10000];\n\n        public void solve(int testNumber, MyInput in, PrintWriter out) {\n            n = in.nextInt();\n            a = in.nextIntArray(n);\n            g = new List[n];\n            for (int i = 0; i < n; i++) {\n                g[i] = new ArrayList<>();\n            }\n            for (int i = 0; i < n - 1; i++) {\n                int a = in.nextInt() - 1;\n                int b = in.nextInt() - 1;\n                g[a].add(b);\n                g[b].add(a);\n            }\n            dp = new int[n];\n            dp1 = new int[n];\n            dp2 = new long[n][];\n            Arrays.fill(dp, -1);\n            Arrays.fill(dp1, -1);\n            out.println(rec(0, -1));\n        }\n\n        int rec(int v, int p) {\n            if (dp[v] != -1) {\n                return dp[v];\n            }\n\n            int ans = rec1(v, p);\n            for (int i = 0; i < size(v, p); i++) {\n                if (rec2(v, i, p) < 0) {\n                    ans = Math.min(ans, i);\n                    break;\n                }\n            }\n\n//        dump(v, ans);\n            return dp[v] = ans;\n        }\n\n        int rec1(int v, int p) {\n            if (dp1[v] != -1) {\n                return dp1[v];\n            }\n            if (a[v] < 0) return 1 << 29;\n            int ans = 0;\n            for (int t : g[v]) {\n                if (t == p) continue;\n                ans += Math.min(rec1(t, v), rec(t, v) + 1);\n            }\n//        if (v == 2) dump(\"come\", v, ans);\n            return dp1[v] = ans;\n        }\n\n        long rec2(int v, int e, int p) {\n            e = Math.min(e, size(v, p) - 1);\n            if (dp2[v] == null) {\n                long[] dp = new long[size(v, p)];\n                Arrays.fill(dp, 1L << 60);\n                dp[0] = a[v];\n                for (int t : g[v]) {\n                    if (t == p) continue;\n                    for (int k = size(v, p) - 1; k >= 0; k--) {\n                        dp[k] = dp[k] + rec2(t, 0, v);\n                        if (k > rec(t, v)) dp[k] = Math.min(dp[k - 1 - rec(t, v)], dp[k]);\n                        for (int i = 0; i < k; i++) {\n                            dp[k] = Math.min(dp[k], dp[i] + rec2(t, k - i, v));\n                        }\n                    }\n//                if (v == 0) {\n//                    dump(t, rec(t, v), dp);\n//                }\n                }\n                dp2[v] = dp;\n//            if (v == 2) dump(\"come\", v, dp);\n            }\n            return dp2[v][e];\n        }\n\n        int size(int v, int p) {\n            if (size[v] != 0) {\n                return size[v];\n            }\n            for (int t : g[v]) {\n                if (t == p) continue;\n                size[v] += size(t, v);\n            }\n            return ++size[v];\n        }\n\n    }\n\n    static class MyInput {\n        private final BufferedReader in;\n        private static int pos;\n        private static int readLen;\n        private static final char[] buffer = new char[1024 * 8];\n        private static char[] str = new char[500 * 8 * 2];\n        private static boolean[] isDigit = new boolean[256];\n        private static boolean[] isSpace = new boolean[256];\n        private static boolean[] isLineSep = new boolean[256];\n\n        static {\n            for (int i = 0; i < 10; i++) {\n                isDigit['0' + i] = true;\n            }\n            isDigit['-'] = true;\n            isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n            isLineSep['\\r'] = isLineSep['\\n'] = true;\n        }\n\n        public MyInput(InputStream is) {\n            in = new BufferedReader(new InputStreamReader(is));\n        }\n\n        public int read() {\n            if (pos >= readLen) {\n                pos = 0;\n                try {\n                    readLen = in.read(buffer);\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n                if (readLen <= 0) {\n                    throw new MyInput.EndOfFileRuntimeException();\n                }\n            }\n            return buffer[pos++];\n        }\n\n        public int nextInt() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            int ret = 0;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n\n        public char nextChar() {\n            while (true) {\n                final int c = read();\n                if (!isSpace[c]) {\n                    return (char) c;\n                }\n            }\n        }\n\n        int reads(int len, boolean[] accept) {\n            try {\n                while (true) {\n                    final int c = read();\n                    if (accept[c]) {\n                        break;\n                    }\n                    if (str.length == len) {\n                        char[] rep = new char[str.length * 3 / 2];\n                        System.arraycopy(str, 0, rep, 0, str.length);\n                        str = rep;\n                    }\n                    str[len++] = (char) c;\n                }\n            } catch (MyInput.EndOfFileRuntimeException e) {\n            }\n            return len;\n        }\n\n        public int[] nextIntArray(final int n) {\n            final int[] res = new int[n];\n            for (int i = 0; i < n; i++) {\n                res[i] = nextInt();\n            }\n            return res;\n        }\n\n        static class EndOfFileRuntimeException extends RuntimeException {\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni();\n\t\tint[] a = na(n);\n\t\tint[] from = new int[n - 1];\n\t\tint[] to = new int[n - 1];\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tfrom[i] = ni() - 1;\n\t\t\tto[i] = ni() - 1;\n\t\t}\n\t\tint[][] g = packU(n, from, to);\n\t\tint[][] pars = parents3(g, 0);\n\t\tint[] par = pars[0], ord = pars[1], dep = pars[2];\n\t\t\n\t\tlong[][][] dp = new long[n][2][]; // [node][allpositive][#cut] = root's minsum\n\t\t\n\t\tfor(int i = n-1;i >= 0;i--){\n\t\t\tint cur = ord[i];\n\t\t\tlong[][] ldp = new long[2][1];\n\t\t\tldp[0][0] = a[cur];\n\t\t\tldp[1][0] = a[cur] < 0 ? Long.MAX_VALUE / 2 : a[cur];\n\t\t\tfor(int e : g[cur]){\n\t\t\t\tif(par[cur] == e)continue;\n\t\t\t\t\n\t\t\t\tlong[][] nldp = conv(ldp, dp[e]);\n\t\t\t\tldp = nldp;\n\t\t\t}\n\t\t\t\n\t\t\tdp[cur] = ldp;\n\t\t}\n\t\tfor(int i = 0;i < dp[0][0].length;i++){\n\t\t\tif(dp[0][0][i] < 0 || dp[0][1][i] < Long.MAX_VALUE / 3){\n\t\t\t\tout.println(i);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tthrow new RuntimeException();\n\t}\n\t\n\tstatic long[][] conv(long[][] a, long[][] b)\n\t{\n\t\tint n = a[0].length, m = b[0].length;\n\t\tlong[][] c = new long[2][n+m];\n\t\tArrays.fill(c[0], Long.MAX_VALUE / 2);\n\t\tArrays.fill(c[1], Long.MAX_VALUE / 2);\n\t\t\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tfor(int j = 0;j < m;j++){\n\t\t\t\tc[0][i+j] = Math.min(c[0][i+j], a[0][i] + b[0][j]);\n\t\t\t\tc[1][i+j] = Math.min(c[1][i+j], a[1][i] + b[1][j]);\n\t\t\t\t\n\t\t\t\tif(b[0][j] < 0 || b[1][j] < Long.MAX_VALUE / 3)c[0][i+j+1] = Math.min(c[0][i+j+1], a[0][i]);\n\t\t\t\tif(b[0][j] < 0 || b[1][j] < Long.MAX_VALUE / 3)c[1][i+j+1] = Math.min(c[1][i+j+1], a[1][i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn c;\n\t}\n\n\tpublic static int[][] parents3(int[][] g, int root) {\n\t\tint n = g.length;\n\t\tint[] par = new int[n];\n\t\tArrays.fill(par, -1);\n\n\t\tint[] depth = new int[n];\n\t\tdepth[0] = 0;\n\n\t\tint[] q = new int[n];\n\t\tq[0] = root;\n\t\tfor (int p = 0, r = 1; p < r; p++) {\n\t\t\tint cur = q[p];\n\t\t\tfor (int nex : g[cur]) {\n\t\t\t\tif (par[cur] != nex) {\n\t\t\t\t\tq[r++] = nex;\n\t\t\t\t\tpar[nex] = cur;\n\t\t\t\t\tdepth[nex] = depth[cur] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn new int[][] { par, q, depth };\n\t}\n\n\tstatic int[][] packU(int n, int[] from, int[] to) {\n\t\tint[][] g = new int[n][];\n\t\tint[] p = new int[n];\n\t\tfor (int f : from)\n\t\t\tp[f]++;\n\t\tfor (int t : to)\n\t\t\tp[t]++;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tg[i] = new int[p[i]];\n\t\tfor (int i = 0; i < from.length; i++) {\n\t\t\tg[from[i]][--p[from[i]]] = to[i];\n\t\t\tg[to[i]][--p[to[i]]] = from[i];\n\t\t}\n\t\treturn g;\n\t}\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            TaskE solver = new TaskE();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class TaskE {\n        MultiWayIntStack edges;\n        int[] a;\n        long[][] negDp;\n        long[] posDp;\n        int[] sizes;\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            a = new int[n + 1];\n            for (int i = 1; i <= n; i++) {\n                a[i] = in.readInt();\n            }\n            edges = new MultiWayIntStack(n + 1, n * 2);\n            for (int i = 1; i < n; i++) {\n                int a = in.readInt();\n                int b = in.readInt();\n                edges.addLast(a, b);\n                edges.addLast(b, a);\n            }\n            negDp = new long[n + 1][];\n            posDp = new long[n + 1];\n            sizes = new int[n + 1];\n\n            dfsForSize(1, 0);\n            dfs(1, 0);\n            long ans = posDp[1];\n            for (int i = 0; i < n; i++) {\n                if (negDp[1][i] < 0) {\n                    ans = Math.min(ans, i);\n                    break;\n                }\n            }\n            out.println(ans);\n        }\n\n        public void dfsForSize(int root, int p) {\n            sizes[root] = 1;\n            for (IntIterator iterator = edges.iterator(root); iterator.hasNext(); ) {\n                int node = iterator.next();\n                if (node == p) {\n                    continue;\n                }\n                dfsForSize(node, root);\n                sizes[root] += sizes[node];\n            }\n        }\n\n        public void dfs(int root, int p) {\n            posDp[root] = a[root] > 0 ? 0 : (int) 1e8;\n            int total = 1;\n\n            long[] last = new long[sizes[root]];\n            long[] next = new long[sizes[root]];\n            last[0] = a[root];\n            for (IntIterator iterator = edges.iterator(root); iterator.hasNext(); ) {\n                int node = iterator.next();\n                if (node == p) {\n                    continue;\n                }\n                dfs(node, root);\n                long atLeastNeed = posDp[node];\n                long cutAtLeast = posDp[node] + 1;\n                for (int i = 0; i < sizes[node]; i++) {\n                    if (negDp[node][i] < 0) {\n                        atLeastNeed = Math.min(atLeastNeed, i + 1);\n                        cutAtLeast = Math.min(cutAtLeast, i + 1);\n                        break;\n                    }\n                }\n                posDp[root] += atLeastNeed;\n                for (int i = 0; i <= total + sizes[node] - 1; i++) {\n                    next[i] = (long) 1e18;\n                    if (i >= cutAtLeast) {\n                        next[i] = Math.min(next[i], last[(int) (i - cutAtLeast)]);\n                    }\n                }\n                for (int i = 0; i < total; i++) {\n                    for (int j = 0; j < sizes[node]; j++) {\n                        next[i + j] = Math.min(next[i + j], last[i] + negDp[node][j]);\n                    }\n                }\n\n                total += sizes[node];\n                {\n                    long[] tmp = next;\n                    next = last;\n                    last = tmp;\n                }\n            }\n            negDp[root] = last;\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n\n    static interface IntIterator {\n        boolean hasNext();\n\n        int next();\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput println(long c) {\n            cache.append(c).append('\\n');\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static class MultiWayIntStack {\n        private int[] values;\n        private int[] next;\n        private int[] heads;\n        private int alloc;\n        private int stackNum;\n\n        public IntIterator iterator(final int queue) {\n            return new IntIterator() {\n                int ele = heads[queue];\n\n\n                public boolean hasNext() {\n                    return ele != 0;\n                }\n\n\n                public int next() {\n                    int ans = values[ele];\n                    ele = next[ele];\n                    return ans;\n                }\n            };\n        }\n\n        private void doubleCapacity() {\n            int newSize = Math.max(next.length + 10, next.length * 2);\n            next = Arrays.copyOf(next, newSize);\n            values = Arrays.copyOf(values, newSize);\n        }\n\n        public void alloc() {\n            alloc++;\n            if (alloc >= next.length) {\n                doubleCapacity();\n            }\n            next[alloc] = 0;\n        }\n\n        public MultiWayIntStack(int qNum, int totalCapacity) {\n            values = new int[totalCapacity + 1];\n            next = new int[totalCapacity + 1];\n            heads = new int[qNum];\n            stackNum = qNum;\n        }\n\n        public void addLast(int qId, int x) {\n            alloc();\n            values[alloc] = x;\n            next[alloc] = heads[qId];\n            heads[qId] = alloc;\n        }\n\n        public String toString() {\n            StringBuilder builder = new StringBuilder();\n            for (int i = 0; i < stackNum; i++) {\n                builder.append(i).append(\": \");\n                for (IntIterator iterator = iterator(i); iterator.hasNext(); ) {\n                    builder.append(iterator.next()).append(\",\");\n                }\n                if (builder.charAt(builder.length() - 1) == ',') {\n                    builder.setLength(builder.length() - 1);\n                }\n                builder.append('\\n');\n            }\n            return builder.toString();\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            TaskE solver = new TaskE();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class TaskE {\n        MultiWayIntStack edges;\n        int[] a;\n        long[][] negDp;\n        long[] posDp;\n        int[] sizes;\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            a = new int[n + 1];\n            for (int i = 1; i <= n; i++) {\n                a[i] = in.readInt();\n            }\n            edges = new MultiWayIntStack(n + 1, n * 2);\n            for (int i = 1; i < n; i++) {\n                int a = in.readInt();\n                int b = in.readInt();\n                edges.addLast(a, b);\n                edges.addLast(b, a);\n            }\n            negDp = new long[n + 1][];\n            posDp = new long[n + 1];\n            sizes = new int[n + 1];\n\n            dfsForSize(1, 0);\n            dfs(1, 0);\n            long ans = posDp[1];\n            for (int i = 0; i < n; i++) {\n                if (negDp[1][i] < 0) {\n                    ans = Math.min(ans, i);\n                    break;\n                }\n            }\n            out.println(ans);\n        }\n\n        public void dfsForSize(int root, int p) {\n            sizes[root] = 1;\n            for (IntIterator iterator = edges.iterator(root); iterator.hasNext(); ) {\n                int node = iterator.next();\n                if (node == p) {\n                    continue;\n                }\n                dfsForSize(node, root);\n                sizes[root] += sizes[node];\n            }\n        }\n\n        public void dfs(int root, int p) {\n            posDp[root] = a[root] > 0 ? 0 : (long) 1e18;\n            int total = 1;\n\n            long[] last = new long[sizes[root]];\n            long[] next = new long[sizes[root]];\n            last[0] = a[root];\n            for (IntIterator iterator = edges.iterator(root); iterator.hasNext(); ) {\n                int node = iterator.next();\n                if (node == p) {\n                    continue;\n                }\n                dfs(node, root);\n                long atLeastNeed = posDp[node];\n                long cutAtLeast = posDp[node] + 1;\n                for (int i = 0; i < sizes[node]; i++) {\n                    if (negDp[node][i] < 0) {\n                        atLeastNeed = Math.min(atLeastNeed, i + 1);\n                        cutAtLeast = Math.min(cutAtLeast, i + 1);\n                        break;\n                    }\n                }\n                posDp[root] += atLeastNeed;\n                for (int i = 0; i <= total + sizes[node] - 1; i++) {\n                    next[i] = (long) 1e18;\n                    if (i >= cutAtLeast) {\n                        next[i] = Math.min(next[i], last[(int) (i - cutAtLeast)]);\n                    }\n                }\n                for (int i = 0; i < total; i++) {\n                    for (int j = 0; j < sizes[node]; j++) {\n                        next[i + j] = Math.min(next[i + j], last[i] + negDp[node][j]);\n                    }\n                }\n\n                total += sizes[node];\n                {\n                    long[] tmp = next;\n                    next = last;\n                    last = tmp;\n                }\n            }\n            negDp[root] = last;\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n\n    static interface IntIterator {\n        boolean hasNext();\n\n        int next();\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput println(long c) {\n            cache.append(c).append('\\n');\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static class MultiWayIntStack {\n        private int[] values;\n        private int[] next;\n        private int[] heads;\n        private int alloc;\n        private int stackNum;\n\n        public IntIterator iterator(final int queue) {\n            return new IntIterator() {\n                int ele = heads[queue];\n\n\n                public boolean hasNext() {\n                    return ele != 0;\n                }\n\n\n                public int next() {\n                    int ans = values[ele];\n                    ele = next[ele];\n                    return ans;\n                }\n            };\n        }\n\n        private void doubleCapacity() {\n            int newSize = Math.max(next.length + 10, next.length * 2);\n            next = Arrays.copyOf(next, newSize);\n            values = Arrays.copyOf(values, newSize);\n        }\n\n        public void alloc() {\n            alloc++;\n            if (alloc >= next.length) {\n                doubleCapacity();\n            }\n            next[alloc] = 0;\n        }\n\n        public MultiWayIntStack(int qNum, int totalCapacity) {\n            values = new int[totalCapacity + 1];\n            next = new int[totalCapacity + 1];\n            heads = new int[qNum];\n            stackNum = qNum;\n        }\n\n        public void addLast(int qId, int x) {\n            alloc();\n            values[alloc] = x;\n            next[alloc] = heads[qId];\n            heads[qId] = alloc;\n        }\n\n        public String toString() {\n            StringBuilder builder = new StringBuilder();\n            for (int i = 0; i < stackNum; i++) {\n                builder.append(i).append(\": \");\n                for (IntIterator iterator = iterator(i); iterator.hasNext(); ) {\n                    builder.append(iterator.next()).append(\",\");\n                }\n                if (builder.charAt(builder.length() - 1) == ',') {\n                    builder.setLength(builder.length() - 1);\n                }\n                builder.append('\\n');\n            }\n            return builder.toString();\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nimport java.io.*;\nimport java.math.BigInteger;\n\npublic class Main {\n\tFastScanner in;\n\tPrintWriter out;\n\tboolean systemIO = true;\n\n\tpublic class Fraction implements Comparable<Fraction> {\n\t\tlong x;\n\t\tlong y;\n\n\t\tpublic Fraction(long x, long y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tpublic void norm() {\n\t\t\tlong gcd = gcd(x, y);\n\t\t\tx /= gcd;\n\t\t\ty /= gcd;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Fraction o) {\n\t\t\tif (x > o.x) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (x < o.x) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (y > o.y) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (y < o.y) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tpublic Fraction sum(Fraction a, Fraction b) {\n\t\tFraction c = new Fraction(a.x * b.y + a.y * b.x, a.y * b.y);\n\t\tc.norm();\n\t\treturn c;\n\t}\n\n\tpublic long gcd(long x, long y) {\n\t\tif (y == 0) {\n\t\t\treturn x;\n\t\t}\n\t\tif (x == 0) {\n\t\t\treturn y;\n\t\t}\n\t\treturn gcd(y, x % y);\n\t}\n\t\n\tpublic class Pair implements Comparable<Pair> {\n\t\tlong x;\n\t\tlong y;\n\n\t\tpublic Pair(long x, long y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\t\n\t\tpublic void add(Pair p) {\n\t\t\tx += p.x;\n\t\t\ty += p.y;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n//\t\t\tif (x != o.x) {\n//\t\t\t\treturn x - o.x;\n//\t\t\t}\n//\t\t\treturn y - o.y;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tpublic class DSU {\n\t\tint[] sz;\n\t\tint[] p;\n\t\tlong[] sum;\n\t\t\n\t\tpublic DSU(long[] a) {\n\t\t\tsz = new int[a.length];\n\t\t\tp = new int[a.length];\n\t\t\tsum = new long[a.length];\n\t\t\tfor (int i = 0; i < p.length; i++) {\n\t\t\t\tp[i] = i;\n\t\t\t\tsz[i] = 1;\n\t\t\t\tsum[i] = a[i];\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int get(int x) {\n\t\t\tif (x == p[x]) {\n\t\t\t\treturn x;\n\t\t\t}\n\t\t\tint par = get(p[x]);\n\t\t\tp[x] = par;\n\t\t\treturn par;\n\t\t}\n\t\t\n\t\tpublic long getSum(int x) {\n\t\t\treturn sum[get(x)];\n\t\t}\n\t\t\n\t\tpublic boolean unite(int a, int b) {\n\t\t\tint pa = get(a);\n\t\t\tint pb = get(b);\n\t\t\tif (pa == pb) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (sz[pa] < sz[pb]) {\n\t\t\t\tp[pa] = pb;\n\t\t\t\tsz[pb] += sz[pa];\n\t\t\t\tsum[pb] += sum[pa];\n\t\t\t} else {\n\t\t\t\tp[pb] = pa;\n\t\t\t\tsz[pa] += sz[pb];\n\t\t\t\tsum[pa] += sum[pb];\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tDSU dsu;\n\tArrayList<Integer>[] to;\n\t\n\tpublic class Ans {\n\t\tlong[] dp;\n\t\tint flag;\n\t\t\n\t\tpublic Ans(long[] dp, int flag) {\n\t\t\tthis.dp = dp;\n\t\t\tthis.flag = flag;\n\t\t}\n\t}\n\t\n\tpublic Ans dfs(int v, int prev) {\n\t\tlong[] dp = new long[1];\n\t\tdp[0] = dsu.getSum(v);\n\t\tint sumf = 0;\n\t\tfor (int x : to[v]) {\n\t\t\tif (x == prev) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tAns ans = dfs(x, v);\n\t\t\tsumf += 1 + ans.flag;\n\t\t\tlong[] dp1 = new long[dp.length + ans.dp.length + 1];\n\t\t\tfor (int i = 0; i < dp1.length; i++) {\n\t\t\t\tdp1[i] = Long.MAX_VALUE / 2;\n\t\t\t}\n\t\t\tfor (int i = 0; i < dp.length; i++) {\n\t\t\t\tfor (int j = 0; j < ans.dp.length; j++) {\n\t\t\t\t\tdp1[i + j] = Math.min(dp1[i + j], dp[i] + ans.dp[j]);\n\t\t\t\t}\n\t\t\t\tfor (int j = ans.flag; j < ans.dp.length; j++) {\n\t\t\t\t\tdp1[i + 1 + j] = Math.min(dp1[i + 1 + j], dp[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp = dp1;\n\t\t}\n\t\tint flag = Integer.MAX_VALUE;\n//\t\tSystem.out.println(dsu.get(v));\n\t\tif (dsu.getSum(v) > 0) {\n\t\t\tflag = sumf;\n\t\t}\n\t\tfor (int i = 0; i < dp.length; i++) {\n\t\t\tif (dp[i] < 0) {\n\t\t\t\tflag = Math.min(flag, i);\n\t\t\t}\n\t\t}\n//\t\tSystem.out.println(v + \" \" + flag);\n//\t\tfor (int i = 0; i < dp.length; i++) {\n//\t\t\tSystem.out.println(dp[i]);\n//\t\t}\n\t\treturn new Ans(dp, flag);\n\t}\n\t\n\tpublic void solve() {\n\t\tint n = in.nextInt();\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\ta[i] = in.nextLong();\n\t\t}\n\t\tdsu = new DSU(a);\n\t\tto = new ArrayList[n];\n\t\tfor (int i = 0; i < to.length; i++) {\n\t\t\tto[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tint x = in.nextInt() - 1;\n\t\t\tint y = in.nextInt() - 1;\n\t\t\tif (a[x] * a[y] < 0) {\n\t\t\t\tto[x].add(y);\n\t\t\t\tto[y].add(x);\n\t\t\t} else {\n\t\t\t\tdsu.unite(x, y);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < to.length; i++) {\n\t\t\tif (dsu.get(i) != i) {\n\t\t\t\tfor (int j = 0; j < to[i].size(); j++) {\n\t\t\t\t\tif (dsu.get(i) != dsu.get(to[i].get(j))) {\n\t\t\t\t\t\tto[dsu.get(i)].add(dsu.get(to[i].get(j)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tto[i].clear();\n\t\t\t} else {\n\t\t\t\tfor (int j = 0; j < to[i].size(); j++) {\n//\t\t\t\t\tSystem.out.println(to[i].get(j));\n\t\t\t\t\tto[i].set(j, dsu.get(to[i].get(j)));\n\t\t\t\t}\n\t\t\t}\n//\t\t\tfor (int x : to[i]) {\n//\t\t\t\tSystem.out.println(i + \" \" + x);\n//\t\t\t}\n\t\t}\n//\t\tSystem.out.println();\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tif (dsu.get(i) == i) {\n\t\t\t\tout.println(dfs(i, -1).flag);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void run() {\n\t\ttry {\n\t\t\tif (systemIO) {\n\t\t\t\tin = new FastScanner(System.in);\n\t\t\t\tout = new PrintWriter(System.out);\n\t\t\t} else {\n\t\t\t\tin = new FastScanner(new File(\"input.txt\"));\n\t\t\t\tout = new PrintWriter(new File(\"output.txt\"));\n\t\t\t}\n\t\t\tsolve();\n\n\t\t\tout.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tclass FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tFastScanner(File f) {\n\t\t\ttry {\n\t\t\t\tbr = new BufferedReader(new FileReader(f));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tFastScanner(InputStream f) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(f));\n\t\t}\n\n\t\tString nextLine() {\n\t\t\ttry {\n\t\t\t\treturn br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t}\n\n\t// AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n\tpublic static void main(String[] arg) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nimport java.io.*;\nimport java.math.BigInteger;\n\npublic class Main {\n\tFastScanner in;\n\tPrintWriter out;\n\tboolean systemIO = true;\n\n\tpublic class Fraction implements Comparable<Fraction> {\n\t\tlong x;\n\t\tlong y;\n\n\t\tpublic Fraction(long x, long y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tpublic void norm() {\n\t\t\tlong gcd = gcd(x, y);\n\t\t\tx /= gcd;\n\t\t\ty /= gcd;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Fraction o) {\n\t\t\tif (x > o.x) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (x < o.x) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (y > o.y) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (y < o.y) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tpublic Fraction sum(Fraction a, Fraction b) {\n\t\tFraction c = new Fraction(a.x * b.y + a.y * b.x, a.y * b.y);\n\t\tc.norm();\n\t\treturn c;\n\t}\n\n\tpublic long gcd(long x, long y) {\n\t\tif (y == 0) {\n\t\t\treturn x;\n\t\t}\n\t\tif (x == 0) {\n\t\t\treturn y;\n\t\t}\n\t\treturn gcd(y, x % y);\n\t}\n\t\n\tpublic class Pair implements Comparable<Pair> {\n\t\tlong x;\n\t\tlong y;\n\n\t\tpublic Pair(long x, long y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\t\n\t\tpublic void add(Pair p) {\n\t\t\tx += p.x;\n\t\t\ty += p.y;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n//\t\t\tif (x != o.x) {\n//\t\t\t\treturn x - o.x;\n//\t\t\t}\n//\t\t\treturn y - o.y;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tpublic class DSU {\n\t\tint[] sz;\n\t\tint[] p;\n\t\tlong[] sum;\n\t\t\n\t\tpublic DSU(long[] a) {\n\t\t\tsz = new int[a.length];\n\t\t\tp = new int[a.length];\n\t\t\tsum = new long[a.length];\n\t\t\tfor (int i = 0; i < p.length; i++) {\n\t\t\t\tp[i] = i;\n\t\t\t\tsz[i] = 1;\n\t\t\t\tsum[i] = a[i];\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int get(int x) {\n\t\t\tif (x == p[x]) {\n\t\t\t\treturn x;\n\t\t\t}\n\t\t\tint par = get(p[x]);\n\t\t\tp[x] = par;\n\t\t\treturn par;\n\t\t}\n\t\t\n\t\tpublic long getSum(int x) {\n\t\t\treturn sum[get(x)];\n\t\t}\n\t\t\n\t\tpublic boolean unite(int a, int b) {\n\t\t\tint pa = get(a);\n\t\t\tint pb = get(b);\n\t\t\tif (pa == pb) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (sz[pa] < sz[pb]) {\n\t\t\t\tp[pa] = pb;\n\t\t\t\tsz[pb] += sz[pa];\n\t\t\t\tsum[pb] += sum[pa];\n\t\t\t} else {\n\t\t\t\tp[pb] = pa;\n\t\t\t\tsz[pa] += sz[pb];\n\t\t\t\tsum[pa] += sum[pb];\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tDSU dsu;\n\tArrayList<Integer>[] to;\n\t\n\tpublic class Ans {\n\t\tlong[] dp;\n\t\tint flag;\n\t\t\n\t\tpublic Ans(long[] dp, int flag) {\n\t\t\tthis.dp = dp;\n\t\t\tthis.flag = flag;\n\t\t}\n\t}\n\t\n\tpublic Ans dfs(int v, int prev) {\n\t\tlong[] dp = new long[1];\n\t\tdp[0] = dsu.getSum(v);\n\t\tint sumf = 0;\n\t\tfor (int x : to[v]) {\n\t\t\tif (x == prev) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tAns ans = dfs(x, v);\n\t\t\tsumf += 1 + ans.flag;\n\t\t\tlong[] dp1 = new long[dp.length + ans.dp.length + 1];\n\t\t\tfor (int i = 0; i < dp1.length; i++) {\n\t\t\t\tdp1[i] = Long.MAX_VALUE / 2;\n\t\t\t}\n\t\t\tfor (int i = 0; i < dp.length; i++) {\n\t\t\t\tfor (int j = 0; j < ans.dp.length; j++) {\n\t\t\t\t\tdp1[i + j] = Math.min(dp1[i + j], dp[i] + ans.dp[j]);\n\t\t\t\t}\n\t\t\t\tfor (int j = ans.flag; j < ans.dp.length; j++) {\n\t\t\t\t\tdp1[i + 1 + j] = Math.min(dp1[i + 1 + j], dp[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp = dp1;\n\t\t}\n\t\tint flag = Integer.MAX_VALUE;\n//\t\tSystem.out.println(dsu.get(v));\n\t\tif (dsu.getSum(v) > 0) {\n\t\t\tflag = sumf;\n\t\t}\n\t\tfor (int i = 0; i < dp.length; i++) {\n\t\t\tif (dp[i] < 0) {\n\t\t\t\tflag = Math.min(flag, i);\n\t\t\t}\n\t\t}\n\t\tdp[flag] += 0;\n//\t\tSystem.out.println(v + \" \" + flag);\n//\t\tfor (int i = 0; i < dp.length; i++) {\n//\t\t\tSystem.out.println(dp[i]);\n//\t\t}\n\t\treturn new Ans(dp, flag);\n\t}\n\t\n\tpublic void solve() {\n\t\tint n = in.nextInt();\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\ta[i] = in.nextLong();\n\t\t}\n\t\tdsu = new DSU(a);\n\t\tto = new ArrayList[n];\n\t\tfor (int i = 0; i < to.length; i++) {\n\t\t\tto[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tint x = in.nextInt() - 1;\n\t\t\tint y = in.nextInt() - 1;\n\t\t\tif (a[x] * a[y] < 0) {\n\t\t\t\tto[x].add(y);\n\t\t\t\tto[y].add(x);\n\t\t\t} else {\n\t\t\t\tdsu.unite(x, y);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < to.length; i++) {\n\t\t\tif (dsu.get(i) != i) {\n\t\t\t\tfor (int j = 0; j < to[i].size(); j++) {\n\t\t\t\t\tif (dsu.get(i) != dsu.get(to[i].get(j))) {\n\t\t\t\t\t\tto[dsu.get(i)].add(dsu.get(to[i].get(j)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tto[i].clear();\n\t\t\t} else {\n\t\t\t\tfor (int j = 0; j < to[i].size(); j++) {\n//\t\t\t\t\tSystem.out.println(to[i].get(j));\n\t\t\t\t\tto[i].set(j, dsu.get(to[i].get(j)));\n\t\t\t\t}\n\t\t\t}\n//\t\t\tfor (int x : to[i]) {\n//\t\t\t\tSystem.out.println(i + \" \" + x);\n//\t\t\t}\n\t\t}\n//\t\tSystem.out.println();\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tif (dsu.get(i) == i) {\n\t\t\t\tout.println(dfs(i, -1).flag);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void run() {\n\t\ttry {\n\t\t\tif (systemIO) {\n\t\t\t\tin = new FastScanner(System.in);\n\t\t\t\tout = new PrintWriter(System.out);\n\t\t\t} else {\n\t\t\t\tin = new FastScanner(new File(\"input.txt\"));\n\t\t\t\tout = new PrintWriter(new File(\"output.txt\"));\n\t\t\t}\n\t\t\tsolve();\n\n\t\t\tout.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tclass FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tFastScanner(File f) {\n\t\t\ttry {\n\t\t\t\tbr = new BufferedReader(new FileReader(f));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tFastScanner(InputStream f) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(f));\n\t\t}\n\n\t\tString nextLine() {\n\t\t\ttry {\n\t\t\t\treturn br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t}\n\n\t// AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n\tpublic static void main(String[] arg) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            TaskE solver = new TaskE();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class TaskE {\n        MultiWayIntStack edges;\n        int[] a;\n        long[][] negDp;\n        long[] posDp;\n        int[] sizes;\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            a = new int[n + 1];\n            for (int i = 1; i <= n; i++) {\n                a[i] = in.readInt();\n            }\n            edges = new MultiWayIntStack(n + 1, n * 2);\n            for (int i = 1; i < n; i++) {\n                int a = in.readInt();\n                int b = in.readInt();\n                edges.addLast(a, b);\n                edges.addLast(b, a);\n            }\n            negDp = new long[n + 1][];\n            posDp = new long[n + 1];\n            sizes = new int[n + 1];\n\n            dfsForSize(1, 0);\n            dfs(1, 0);\n            long ans = posDp[1];\n            for (int i = 0; i < n; i++) {\n                if (negDp[1][i] < 0) {\n                    ans = Math.min(ans, i);\n                    break;\n                }\n            }\n            out.println(ans);\n        }\n\n        public void dfsForSize(int root, int p) {\n            sizes[root] = 1;\n            for (IntIterator iterator = edges.iterator(root); iterator.hasNext(); ) {\n                int node = iterator.next();\n                if (node == p) {\n                    continue;\n                }\n                dfsForSize(node, root);\n                sizes[root] += sizes[node];\n            }\n        }\n\n        public void dfs(int root, int p) {\n            posDp[root] = a[root] > 0 ? 0 : (int) 1e8;\n            int total = 1;\n\n            long[] last = new long[sizes[root]];\n            long[] next = new long[sizes[root]];\n            last[0] = a[root];\n            for (IntIterator iterator = edges.iterator(root); iterator.hasNext(); ) {\n                int node = iterator.next();\n                if (node == p) {\n                    continue;\n                }\n                dfs(node, root);\n                long atLeastNeed = posDp[node];\n                for (int i = 0; i < sizes[node]; i++) {\n                    if (negDp[node][i] < 0) {\n                        atLeastNeed = Math.min(atLeastNeed, i + 1);\n                        break;\n                    }\n                }\n                posDp[root] += atLeastNeed;\n                for (int i = 0; i <= total + sizes[node] - 1; i++) {\n                    next[i] = (long) 1e18;\n                    if (i >= posDp[node] + 1) {\n                        next[i] = Math.min(next[i], last[i - ((int) posDp[node] + 1)]);\n                    }\n                }\n                for (int i = 0; i < total; i++) {\n                    for (int j = 0; j < sizes[node]; j++) {\n                        next[i + j] = Math.min(next[i + j], last[i] + negDp[node][j]);\n                    }\n                }\n\n                total += sizes[node];\n                {\n                    long[] tmp = next;\n                    next = last;\n                    last = tmp;\n                }\n            }\n            negDp[root] = last;\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n\n    static interface IntIterator {\n        boolean hasNext();\n\n        int next();\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput println(long c) {\n            cache.append(c).append('\\n');\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static class MultiWayIntStack {\n        private int[] values;\n        private int[] next;\n        private int[] heads;\n        private int alloc;\n        private int stackNum;\n\n        public IntIterator iterator(final int queue) {\n            return new IntIterator() {\n                int ele = heads[queue];\n\n\n                public boolean hasNext() {\n                    return ele != 0;\n                }\n\n\n                public int next() {\n                    int ans = values[ele];\n                    ele = next[ele];\n                    return ans;\n                }\n            };\n        }\n\n        private void doubleCapacity() {\n            int newSize = Math.max(next.length + 10, next.length * 2);\n            next = Arrays.copyOf(next, newSize);\n            values = Arrays.copyOf(values, newSize);\n        }\n\n        public void alloc() {\n            alloc++;\n            if (alloc >= next.length) {\n                doubleCapacity();\n            }\n            next[alloc] = 0;\n        }\n\n        public MultiWayIntStack(int qNum, int totalCapacity) {\n            values = new int[totalCapacity + 1];\n            next = new int[totalCapacity + 1];\n            heads = new int[qNum];\n            stackNum = qNum;\n        }\n\n        public void addLast(int qId, int x) {\n            alloc();\n            values[alloc] = x;\n            next[alloc] = heads[qId];\n            heads[qId] = alloc;\n        }\n\n        public String toString() {\n            StringBuilder builder = new StringBuilder();\n            for (int i = 0; i < stackNum; i++) {\n                builder.append(i).append(\": \");\n                for (IntIterator iterator = iterator(i); iterator.hasNext(); ) {\n                    builder.append(iterator.next()).append(\",\");\n                }\n                if (builder.charAt(builder.length() - 1) == ',') {\n                    builder.setLength(builder.length() - 1);\n                }\n                builder.append('\\n');\n            }\n            return builder.toString();\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n// import java.awt.Point;\n \npublic class Main {\n    InputStream is;\n    PrintWriter out;\n    String INPUT = \"\";\n \n    static int mod = 1_000_000_007;\n    long inf = Long.MAX_VALUE/2;\n\n    ArrayList<Integer>[] edge;\n    boolean[] seen;\n    int[] nodenum;\n    int n;\n    long[] a;\n\n    void solve(){\n        n = ni();\n        a = new long[n];\n        for(int i = 0; i < n; i++){\n            a[i] = nl();\n        }\n        edge = new ArrayList[n];\n        for(int i = 0; i < n; i++){\n            edge[i] = new ArrayList<Integer>();\n        }\n        for(int i = 0; i < n-1; i++){\n            int s = ni()-1;\n            int t = ni()-1;\n            edge[s].add(t);\n            edge[t].add(s);\n        }\n        seen = new boolean[n];\n        nodenum = new int[n];\n        seen[0] = true;\n        dfs_node(0);\n        seen = new boolean[n];\n        seen[0] = true;\n        long[][] ans = f(0);\n        for(int i = 0; i < n; i++){\n            // out.println(ans[i][0]+\" \"+ans[i][1]);\n            if(ans[i][0]!=inf || ans[i][1]<0){\n                out.println(i);\n                return;\n            }\n        }\n\n    }\n\n    int dfs_node(int r){\n        int ans = 1;\n        for(int t : edge[r]){\n            if(seen[t]) continue;\n            seen[t] = true;\n            ans += dfs_node(t);\n        }\n        nodenum[r] = ans;\n        // System.err.println(r+\" \"+ans);\n        return ans;\n    }\n\n    long[][] f(int r){\n        int u = nodenum[r];\n        // System.err.println(u);\n        long[][][] dp = new long[2][u][2];\n        for(int i = 0; i < u; i++){\n            dp[0][i][0] = inf;\n            dp[0][i][1] = inf;\n            dp[1][i][0] = inf;\n            dp[1][i][1] = inf;\n        }\n        if(a[r]>0){\n            dp[0][0][0] = a[r];\n            dp[0][0][1] = a[r];\n        }\n        else{\n            dp[0][0][1] = a[r]; \n        }\n        int p = 1;\n        int q = 0;\n        for(int t : edge[r]){\n            if(seen[t]) continue;\n            seen[t] = true;\n            long[][] rdp = f(t);\n            for(int i = 0; i < u; i++){\n                dp[1-q][i][0] = inf;\n                dp[1-q][i][1] = inf;\n            }\n            for(int i = 0; i < p; i++){\n                for(int j = 0; j < nodenum[t]; j++){\n                    boolean f1 = (dp[q][i][0]!=inf);\n                    boolean f2 = (dp[q][i][1]!=inf);\n                    boolean f3 = (rdp[j][0]!=inf);\n                    boolean f4 = (rdp[j][1]!=inf);\n                    boolean f5 = (rdp[j][1]<0);\n                    if(!f1&&!f2) break;\n                    if(!f3&&!f4&&!f5) break;\n                    if(f1 && f3) dp[1-q][i+j][0] = Math.min(dp[1-q][i+j][0], dp[q][i][0] + rdp[j][0]);\n                    if(f2 && f4) dp[1-q][i+j][1] = Math.min(dp[1-q][i+j][1], dp[q][i][1] + rdp[j][1]);\n                    if((f3 || f5) && f1) dp[1-q][i+j+1][0] = Math.min(dp[1-q][i+j+1][0], dp[q][i][0]);\n                    if((f3 || f5) && f2){\n                        // out.println(\"cut\");\n                        dp[1-q][i+j+1][1] = Math.min(dp[1-q][i+j+1][1], dp[q][i][1]);\n                    }\n                }\n            }\n            // out.println(r+\" \"+t+\" \"+dp[1-q][1][0]);\n            p += nodenum[t];\n            q = 1-q;\n        }\n        // out.println(r);\n        // for(int i = 0; i < nodenum[r]; i++){\n        //     out.println(dp[q][i][0]+\" \"+dp[q][i][1]);\n        // }\n        // System.err.println(\"ret\");\n        return dp[q];\n    }\n\n    void run() throws Exception\n    {\n        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n        out = new PrintWriter(System.out);\n        long s = System.currentTimeMillis();\n        solve();\n        out.flush();\n        if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+\"ms\");\n    }\n    \n    public static void main(String[] args) throws Exception { new Main().run(); }\n    \n    private byte[] inbuf = new byte[1024];\n    private int lenbuf = 0, ptrbuf = 0;\n    \n    private int readByte()\n    {\n        if(lenbuf == -1)throw new InputMismatchException();\n        if(ptrbuf >= lenbuf){\n            ptrbuf = 0;\n            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n            if(lenbuf <= 0)return -1;\n        }\n        return inbuf[ptrbuf++];\n    }\n    \n    private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n    private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n    \n    private double nd() { return Double.parseDouble(ns()); }\n    private char nc() { return (char)skip(); }\n    \n    private String ns()\n    {\n        int b = skip();\n        StringBuilder sb = new StringBuilder();\n        while(!(isSpaceChar(b) && b != ' ')){\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    \n    private char[] ns(int n)\n    {\n        char[] buf = new char[n];\n        int b = skip(), p = 0;\n        while(p < n && !(isSpaceChar(b))){\n            buf[p++] = (char)b;\n            b = readByte();\n        }\n        return n == p ? buf : Arrays.copyOf(buf, p);\n    }\n    \n    private char[][] nm(int n, int m)\n    {\n        char[][] map = new char[n][];\n        for(int i = 0;i < n;i++)map[i] = ns(m);\n        return map;\n    }\n    \n    private int[] na(int n)\n    {\n        int[] a = new int[n];\n        for(int i = 0;i < n;i++)a[i] = ni();\n        return a;\n    }\n    \n    private int ni()\n    {\n        int num = 0, b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        \n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    \n    private long nl()\n    {\n        long num = 0;\n        int b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        \n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    \n    private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }\n \n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n// import java.awt.Point;\n \npublic class Main {\n    InputStream is;\n    PrintWriter out;\n    String INPUT = \"\";\n \n    static int mod = 1_000_000_007;\n    long inf = Long.MAX_VALUE/2;\n\n    ArrayList<Integer>[] edge;\n    boolean[] seen;\n    int[] nodenum;\n    int n;\n    long[] a;\n\n    void solve(){\n        n = ni();\n        a = new long[n];\n        for(int i = 0; i < n; i++){\n            a[i] = nl();\n        }\n        edge = new ArrayList[n];\n        for(int i = 0; i < n; i++){\n            edge[i] = new ArrayList<Integer>();\n        }\n        for(int i = 0; i < n-1; i++){\n            int s = ni()-1;\n            int t = ni()-1;\n            edge[s].add(t);\n            edge[t].add(s);\n        }\n        seen = new boolean[n];\n        nodenum = new int[n];\n        seen[0] = true;\n        dfs_node(0);\n        seen = new boolean[n];\n        seen[0] = true;\n        long[][] ans = f(0);\n        for(int i = 0; i < n; i++){\n            // out.println(ans[i][0]+\" \"+ans[i][1]);\n            if(ans[i][0]!=inf || ans[i][1]<0){\n                out.println(i);\n                return;\n            }\n        }\n\n    }\n\n    int dfs_node(int r){\n        int ans = 1;\n        for(int t : edge[r]){\n            if(seen[t]) continue;\n            seen[t] = true;\n            ans += dfs_node(t);\n        }\n        nodenum[r] = ans;\n        // System.err.println(r+\" \"+ans);\n        return ans;\n    }\n\n    long[][] f(int r){\n        int u = nodenum[r];\n        // System.err.println(u);\n        long[][][] dp = new long[2][u][2];\n        for(int i = 0; i < u; i++){\n            dp[0][i][0] = inf;\n            dp[0][i][1] = inf;\n            dp[1][i][0] = inf;\n            dp[1][i][1] = inf;\n        }\n        if(a[r]>0){\n            dp[0][0][0] = a[r];\n            dp[0][0][1] = a[r];\n        }\n        else{\n            dp[0][0][1] = a[r]; \n        }\n        int p = 1;\n        int q = 0;\n        for(int t : edge[r]){\n            if(seen[t]) continue;\n            seen[t] = true;\n            long[][] rdp = f(t);\n            for(int i = 0; i < u; i++){\n                dp[1-q][i][0] = inf;\n                dp[1-q][i][1] = inf;\n            }\n            for(int i = 0; i < p; i++){\n                for(int j = 0; j < nodenum[t]; j++){\n                    // boolean f1 = (dp[q][i][0]!=inf);\n                    // boolean f2 = (dp[q][i][1]!=inf);\n                    boolean f3 = (rdp[j][0]!=inf);\n                    // boolean f4 = (rdp[j][1]!=inf);\n                    boolean f5 = (rdp[j][1]<0);\n                    dp[1-q][i+j][0] = Math.min(dp[1-q][i+j][0], dp[q][i][0] + rdp[j][0]);\n                    dp[1-q][i+j][1] = Math.min(dp[1-q][i+j][1], dp[q][i][1] + rdp[j][1]);\n                    if(f3||f5){\n                        dp[1-q][i+j+1][0] = Math.min(dp[1-q][i+j+1][0], dp[q][i][0]);\n                        dp[1-q][i+j+1][1] = Math.min(dp[1-q][i+j+1][1], dp[q][i][1]);\n                    }\n                }\n            }\n            // out.println(r+\" \"+t+\" \"+dp[1-q][1][0]);\n            p += nodenum[t];\n            q = 1-q;\n        }\n        // out.println(r);\n        // for(int i = 0; i < nodenum[r]; i++){\n        //     out.println(dp[q][i][0]+\" \"+dp[q][i][1]);\n        // }\n        // System.err.println(\"ret\");\n        return dp[q];\n    }\n\n    void run() throws Exception\n    {\n        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n        out = new PrintWriter(System.out);\n        long s = System.currentTimeMillis();\n        solve();\n        out.flush();\n        if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+\"ms\");\n    }\n    \n    public static void main(String[] args) throws Exception { new Main().run(); }\n    \n    private byte[] inbuf = new byte[1024];\n    private int lenbuf = 0, ptrbuf = 0;\n    \n    private int readByte()\n    {\n        if(lenbuf == -1)throw new InputMismatchException();\n        if(ptrbuf >= lenbuf){\n            ptrbuf = 0;\n            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n            if(lenbuf <= 0)return -1;\n        }\n        return inbuf[ptrbuf++];\n    }\n    \n    private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n    private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n    \n    private double nd() { return Double.parseDouble(ns()); }\n    private char nc() { return (char)skip(); }\n    \n    private String ns()\n    {\n        int b = skip();\n        StringBuilder sb = new StringBuilder();\n        while(!(isSpaceChar(b) && b != ' ')){\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    \n    private char[] ns(int n)\n    {\n        char[] buf = new char[n];\n        int b = skip(), p = 0;\n        while(p < n && !(isSpaceChar(b))){\n            buf[p++] = (char)b;\n            b = readByte();\n        }\n        return n == p ? buf : Arrays.copyOf(buf, p);\n    }\n    \n    private char[][] nm(int n, int m)\n    {\n        char[][] map = new char[n][];\n        for(int i = 0;i < n;i++)map[i] = ns(m);\n        return map;\n    }\n    \n    private int[] na(int n)\n    {\n        int[] a = new int[n];\n        for(int i = 0;i < n;i++)a[i] = ni();\n        return a;\n    }\n    \n    private int ni()\n    {\n        int num = 0, b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        \n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    \n    private long nl()\n    {\n        long num = 0;\n        int b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        \n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    \n    private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }\n \n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.UncheckedIOException;\nimport java.util.List;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            TaskE solver = new TaskE();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n    static class TaskE {\n        private int inf = (int) 1e8;\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            Node[] nodes = new Node[n + 1];\n            for (int i = 1; i <= n; i++) {\n                nodes[i] = new Node();\n                nodes[i].id = i;\n                nodes[i].val = in.readInt();\n            }\n            for (int i = 1; i < n; i++) {\n                Node a = nodes[in.readInt()];\n                Node b = nodes[in.readInt()];\n                a.next.add(b);\n                b.next.add(a);\n            }\n\n            dfs(nodes[1], null);\n            dsuOnTree(nodes[1], null);\n            int minCost = nodes[1].allPositive;\n            for (int i = 0; i < nodes[1].size; i++) {\n                if (nodes[1].dp[i] < 0) {\n                    minCost = Math.min(minCost, i);\n                    break;\n                }\n            }\n\n            out.println(minCost);\n        }\n\n        public void dsuOnTree(Node root, long[] dp) {\n            if (dp == null) {\n                dp = new long[root.size];\n            }\n            root.dp = dp;\n            if (root.size == 1) {\n                root.allPositive = root.val > 0 ? 0 : inf;\n                root.dp[0] = root.val;\n                return;\n            }\n\n            dsuOnTree(root.heavy, dp);\n            root.allPositive = root.heavy.allPositive;\n            for (int i = 0; i < root.heavy.size; i++) {\n                if (dp[i] < 0) {\n                    root.allPositive = Math.min(root.allPositive, i + 1);\n                    break;\n                }\n            }\n            for (int i = root.heavy.size; i >= 0; i--) {\n                dp[i] += root.val;\n                if (i > 0 && dp[i - 1] < 0) {\n                    dp[i] = Math.min(dp[i], root.val);\n                }\n                if (i > root.heavy.allPositive) {\n                    dp[i] = Math.min(dp[i], root.val);\n                }\n            }\n            for (int i = root.heavy.size + 1; i < root.size; i++) {\n                dp[i] = (long) 1e18;\n            }\n\n            for (Node node : root.next) {\n                if (node == root.heavy) {\n                    continue;\n                }\n                dsuOnTree(node, null);\n                // update all positive\n                int localAllPos = node.allPositive;\n                for (int i = 0; i < node.size; i++) {\n                    if (node.dp[i] < 0) {\n                        localAllPos = Math.min(localAllPos, i + 1);\n                        break;\n                    }\n                }\n                root.allPositive += localAllPos;\n\n                int splitCost = root.allPositive + 1;\n                for (int i = 0; i < node.size; i++) {\n                    if (node.dp[i] < 0) {\n                        splitCost = Math.min(splitCost, i + 1);\n                        break;\n                    }\n                }\n                // split or not\n                for (int i = root.size - 1; i >= 0; i--) {\n                    // split\n                    dp[i] += node.dp[0];\n                    if (i >= splitCost) {\n                        dp[i] = Math.min(dp[i], dp[i - splitCost]);\n                    }\n                    for (int j = 1; j < node.size && j <= i; j++) {\n                        int k = i - j;\n                        dp[i] = Math.min(dp[i], dp[k] + node.dp[j]);\n                    }\n                }\n            }\n\n            if (root.val < 0) {\n                root.allPositive = inf;\n            }\n\n        }\n\n        public void dfs(Node root, Node p) {\n            root.next.remove(p);\n            root.size = 1;\n            for (Node node : root.next) {\n                dfs(node, root);\n                root.size += node.size;\n                if (root.heavy == null || root.heavy.size < node.size) {\n                    root.heavy = node;\n                }\n            }\n        }\n\n    }\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n    static class FastOutput implements AutoCloseable, Closeable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput println(int c) {\n            cache.append(c).append('\\n');\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n    static class Node {\n        List<Node> next = new ArrayList<>();\n        Node heavy;\n        int size;\n        long[] dp;\n        int allPositive;\n        int val;\n        int id;\n\n        public String toString() {\n            return \"\" + id;\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nimport java.io.*;\nimport java.math.BigInteger;\n\npublic class Main {\n\tFastScanner in;\n\tPrintWriter out;\n\tboolean systemIO = true;\n\n\tpublic class Fraction implements Comparable<Fraction> {\n\t\tlong x;\n\t\tlong y;\n\n\t\tpublic Fraction(long x, long y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tpublic void norm() {\n\t\t\tlong gcd = gcd(x, y);\n\t\t\tx /= gcd;\n\t\t\ty /= gcd;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Fraction o) {\n\t\t\tif (x > o.x) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (x < o.x) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (y > o.y) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (y < o.y) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tpublic Fraction sum(Fraction a, Fraction b) {\n\t\tFraction c = new Fraction(a.x * b.y + a.y * b.x, a.y * b.y);\n\t\tc.norm();\n\t\treturn c;\n\t}\n\n\tpublic long gcd(long x, long y) {\n\t\tif (y == 0) {\n\t\t\treturn x;\n\t\t}\n\t\tif (x == 0) {\n\t\t\treturn y;\n\t\t}\n\t\treturn gcd(y, x % y);\n\t}\n\t\n\tpublic class Pair implements Comparable<Pair> {\n\t\tlong x;\n\t\tlong y;\n\n\t\tpublic Pair(long x, long y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\t\n\t\tpublic void add(Pair p) {\n\t\t\tx += p.x;\n\t\t\ty += p.y;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n//\t\t\tif (x != o.x) {\n//\t\t\t\treturn x - o.x;\n//\t\t\t}\n//\t\t\treturn y - o.y;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tpublic class DSU {\n\t\tint[] sz;\n\t\tint[] p;\n\t\tlong[] sum;\n\t\t\n\t\tpublic DSU(long[] a) {\n\t\t\tsz = new int[a.length];\n\t\t\tp = new int[a.length];\n\t\t\tsum = new long[a.length];\n\t\t\tfor (int i = 0; i < p.length; i++) {\n\t\t\t\tp[i] = i;\n\t\t\t\tsz[i] = 1;\n\t\t\t\tsum[i] = a[i];\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int get(int x) {\n\t\t\tif (x == p[x]) {\n\t\t\t\treturn x;\n\t\t\t}\n\t\t\tint par = get(p[x]);\n\t\t\tp[x] = par;\n\t\t\treturn par;\n\t\t}\n\t\t\n\t\tpublic long getSum(int x) {\n\t\t\treturn sum[get(x)];\n\t\t}\n\t\t\n\t\tpublic boolean unite(int a, int b) {\n\t\t\tint pa = get(a);\n\t\t\tint pb = get(b);\n\t\t\tif (pa == pb) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (sz[pa] < sz[pb]) {\n\t\t\t\tp[pa] = pb;\n\t\t\t\tsz[pb] += sz[pa];\n\t\t\t\tsum[pb] += sum[pa];\n\t\t\t} else {\n\t\t\t\tp[pb] = pa;\n\t\t\t\tsz[pa] += sz[pb];\n\t\t\t\tsum[pa] += sum[pb];\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tDSU dsu;\n\tArrayList<Integer>[] to;\n\t\n\tpublic class Ans {\n\t\tlong[] dp;\n\t\tint flag;\n\t\t\n\t\tpublic Ans(long[] dp, int flag) {\n\t\t\tthis.dp = dp;\n\t\t\tthis.flag = flag;\n\t\t}\n\t}\n\t\n\tpublic Ans dfs(int v, int prev) {\n\t\tlong[] dp = new long[1];\n\t\tdp[0] = dsu.getSum(v);\n\t\tint sumf = 0;\n\t\tfor (int x : to[v]) {\n\t\t\tif (x == prev) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tAns ans = dfs(x, v);\n\t\t\tsumf += 1 + ans.flag;\n\t\t\tlong[] dp1 = new long[dp.length + ans.dp.length + 1];\n\t\t\tfor (int i = 0; i < dp1.length; i++) {\n\t\t\t\tdp1[i] = Long.MAX_VALUE / 2;\n\t\t\t}\n\t\t\tfor (int i = 0; i < dp.length; i++) {\n\t\t\t\tfor (int j = 0; j < ans.dp.length; j++) {\n\t\t\t\t\tdp1[i + j] = Math.min(dp1[i + j], dp[i] + ans.dp[j]);\n\t\t\t\t}\n\t\t\t\tfor (int j = ans.flag; j < ans.dp.length; j++) {\n\t\t\t\t\tdp1[i + 1 + j] = Math.min(dp1[i + 1 + j], dp[i]);\n\t\t\t\t}\n\t\t\t\tlong min = Long.MAX_VALUE / 2;\n\t\t\t\tfor (int j = 0; j < dp1.length; j++) {\n\t\t\t\t\tmin = Math.min(min, dp1[j]);\n\t\t\t\t\tdp1[j] = min;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp = dp1;\n\t\t}\n\t\tint flag = Integer.MAX_VALUE;\n//\t\tSystem.out.println(dsu.get(v));\n\t\tif (dsu.getSum(v) > 0) {\n\t\t\tflag = sumf;\n\t\t}\n\t\tfor (int i = 0; i < dp.length; i++) {\n\t\t\tif (dp[i] < 0) {\n\t\t\t\tflag = Math.min(flag, i);\n\t\t\t}\n\t\t}\n\t\tdp[flag] += 0;\n//\t\tSystem.out.println(v + \" \" + flag);\n//\t\tfor (int i = 0; i < dp.length; i++) {\n//\t\t\tSystem.out.println(dp[i]);\n//\t\t}\n\t\treturn new Ans(dp, flag);\n\t}\n\t\n\tpublic void solve() {\n\t\tint n = in.nextInt();\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\ta[i] = in.nextLong();\n\t\t}\n\t\tdsu = new DSU(a);\n\t\tto = new ArrayList[n];\n\t\tfor (int i = 0; i < to.length; i++) {\n\t\t\tto[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tint x = in.nextInt() - 1;\n\t\t\tint y = in.nextInt() - 1;\n\t\t\tif (a[x] * a[y] < 0) {\n\t\t\t\tto[x].add(y);\n\t\t\t\tto[y].add(x);\n\t\t\t} else {\n\t\t\t\tdsu.unite(x, y);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < to.length; i++) {\n\t\t\tif (dsu.get(i) != i) {\n\t\t\t\tfor (int j = 0; j < to[i].size(); j++) {\n\t\t\t\t\tif (dsu.get(i) != dsu.get(to[i].get(j))) {\n\t\t\t\t\t\tto[dsu.get(i)].add(dsu.get(to[i].get(j)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tto[i].clear();\n\t\t\t} else {\n\t\t\t\tfor (int j = 0; j < to[i].size(); j++) {\n//\t\t\t\t\tSystem.out.println(to[i].get(j));\n\t\t\t\t\tto[i].set(j, dsu.get(to[i].get(j)));\n\t\t\t\t}\n\t\t\t}\n//\t\t\tfor (int x : to[i]) {\n//\t\t\t\tSystem.out.println(i + \" \" + x);\n//\t\t\t}\n\t\t}\n//\t\tSystem.out.println();\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tif (dsu.get(i) == i) {\n\t\t\t\tout.println(dfs(i, -1).flag);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void run() {\n\t\ttry {\n\t\t\tif (systemIO) {\n\t\t\t\tin = new FastScanner(System.in);\n\t\t\t\tout = new PrintWriter(System.out);\n\t\t\t} else {\n\t\t\t\tin = new FastScanner(new File(\"input.txt\"));\n\t\t\t\tout = new PrintWriter(new File(\"output.txt\"));\n\t\t\t}\n\t\t\tsolve();\n\n\t\t\tout.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tclass FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tFastScanner(File f) {\n\t\t\ttry {\n\t\t\t\tbr = new BufferedReader(new FileReader(f));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tFastScanner(InputStream f) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(f));\n\t\t}\n\n\t\tString nextLine() {\n\t\t\ttry {\n\t\t\t\treturn br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t}\n\n\t// AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n\tpublic static void main(String[] arg) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n// import java.awt.Point;\n \npublic class Main {\n    InputStream is;\n    PrintWriter out;\n    String INPUT = \"\";\n \n    static int mod = 1_000_000_007;\n    long inf = Long.MAX_VALUE/2;\n\n    ArrayList<Integer>[] edge;\n    boolean[] seen;\n    int[] nodenum;\n    int n;\n    long[] a;\n\n    void solve(){\n        n = ni();\n        a = new long[n];\n        for(int i = 0; i < n; i++){\n            a[i] = nl();\n        }\n        edge = new ArrayList[n];\n        for(int i = 0; i < n; i++){\n            edge[i] = new ArrayList<Integer>();\n        }\n        for(int i = 0; i < n-1; i++){\n            int s = ni()-1;\n            int t = ni()-1;\n            edge[s].add(t);\n            edge[t].add(s);\n        }\n        seen = new boolean[n];\n        nodenum = new int[n];\n        seen[0] = true;\n        dfs_node(0);\n        seen = new boolean[n];\n        seen[0] = true;\n        long[][] ans = f(0);\n        for(int i = 0; i < n; i++){\n            // out.println(ans[i][0]+\" \"+ans[i][1]);\n            if(ans[i][0]!=inf || ans[i][1]<0){\n                out.println(i);\n                return;\n            }\n        }\n\n    }\n\n    int dfs_node(int r){\n        int ans = 1;\n        for(int t : edge[r]){\n            if(seen[t]) continue;\n            seen[t] = true;\n            ans += dfs_node(t);\n        }\n        nodenum[r] = ans;\n        // System.err.println(r+\" \"+ans);\n        return ans;\n    }\n\n    long[][] f(int r){\n        int u = nodenum[r];\n        // System.err.println(u);\n        long[][][] dp = new long[2][u][2];\n        for(int i = 0; i < u; i++){\n            dp[0][i][0] = inf;\n            dp[0][i][1] = inf;\n            dp[1][i][0] = inf;\n            dp[1][i][1] = inf;\n        }\n        if(a[r]>0){\n            dp[0][0][0] = a[r];\n            dp[0][0][1] = a[r];\n        }\n        else{\n            dp[0][0][1] = a[r]; \n        }\n        int p = 1;\n        int q = 0;\n        for(int t : edge[r]){\n            if(seen[t]) continue;\n            seen[t] = true;\n            long[][] rdp = f(t);\n            for(int i = 0; i < u; i++){\n                dp[1-q][i][0] = inf;\n                dp[1-q][i][1] = inf;\n            }\n            for(int i = 0; i < p; i++){\n                for(int j = 0; j < nodenum[t]; j++){\n                    if(dp[q][i][0]!=inf && rdp[j][0]!=inf) dp[1-q][i+j][0] = Math.min(dp[1-q][i+j][0], dp[q][i][0] + rdp[j][0]);\n                    if(dp[q][i][1]!=inf && rdp[j][1]!=inf) dp[1-q][i+j][1] = Math.min(dp[1-q][i+j][1], dp[q][i][1] + rdp[j][1]);\n                    if((rdp[j][0]!=inf || rdp[j][1]<0) && dp[q][i][0]!=inf) dp[1-q][i+j+1][0] = Math.min(dp[1-q][i+j+1][0], dp[q][i][0]);\n                    if((rdp[j][1]<0 ||rdp[j][0]!=inf) && dp[q][i][1]!=inf){\n                        // out.println(\"cut\");\n                        dp[1-q][i+j+1][1] = Math.min(dp[1-q][i+j+1][1], dp[q][i][1]);\n                    }\n                }\n            }\n            // out.println(r+\" \"+t+\" \"+dp[1-q][1][0]);\n            p += nodenum[t];\n            q = 1-q;\n        }\n        // out.println(r);\n        // for(int i = 0; i < nodenum[r]; i++){\n        //     out.println(dp[q][i][0]+\" \"+dp[q][i][1]);\n        // }\n        // System.err.println(\"ret\");\n        return dp[q];\n    }\n\n    void run() throws Exception\n    {\n        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n        out = new PrintWriter(System.out);\n        long s = System.currentTimeMillis();\n        solve();\n        out.flush();\n        if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+\"ms\");\n    }\n    \n    public static void main(String[] args) throws Exception { new Main().run(); }\n    \n    private byte[] inbuf = new byte[1024];\n    private int lenbuf = 0, ptrbuf = 0;\n    \n    private int readByte()\n    {\n        if(lenbuf == -1)throw new InputMismatchException();\n        if(ptrbuf >= lenbuf){\n            ptrbuf = 0;\n            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n            if(lenbuf <= 0)return -1;\n        }\n        return inbuf[ptrbuf++];\n    }\n    \n    private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n    private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n    \n    private double nd() { return Double.parseDouble(ns()); }\n    private char nc() { return (char)skip(); }\n    \n    private String ns()\n    {\n        int b = skip();\n        StringBuilder sb = new StringBuilder();\n        while(!(isSpaceChar(b) && b != ' ')){\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    \n    private char[] ns(int n)\n    {\n        char[] buf = new char[n];\n        int b = skip(), p = 0;\n        while(p < n && !(isSpaceChar(b))){\n            buf[p++] = (char)b;\n            b = readByte();\n        }\n        return n == p ? buf : Arrays.copyOf(buf, p);\n    }\n    \n    private char[][] nm(int n, int m)\n    {\n        char[][] map = new char[n][];\n        for(int i = 0;i < n;i++)map[i] = ns(m);\n        return map;\n    }\n    \n    private int[] na(int n)\n    {\n        int[] a = new int[n];\n        for(int i = 0;i < n;i++)a[i] = ni();\n        return a;\n    }\n    \n    private int ni()\n    {\n        int num = 0, b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        \n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    \n    private long nl()\n    {\n        long num = 0;\n        int b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        \n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    \n    private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }\n \n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.UncheckedIOException;\nimport java.util.List;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            TaskE solver = new TaskE();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n    static class TaskE {\n        private int inf = (int) 1e8;\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            Node[] nodes = new Node[n + 1];\n            for (int i = 1; i <= n; i++) {\n                nodes[i] = new Node();\n                nodes[i].id = i;\n                nodes[i].val = in.readInt();\n            }\n            for (int i = 1; i < n; i++) {\n                Node a = nodes[in.readInt()];\n                Node b = nodes[in.readInt()];\n                a.next.add(b);\n                b.next.add(a);\n            }\n\n            dfs(nodes[1], null);\n            dsuOnTree(nodes[1], null);\n            int minCost = nodes[1].allPositive;\n            for (int i = 0; i < nodes[1].size; i++) {\n                if (nodes[1].dp[i] < 0) {\n                    minCost = Math.min(minCost, i);\n                    break;\n                }\n            }\n\n            out.println(minCost);\n        }\n\n        public void dsuOnTree(Node root, long[] dp) {\n            if (dp == null) {\n                dp = new long[root.size];\n            }\n            root.dp = dp;\n            if (root.size == 1) {\n                root.allPositive = root.val > 0 ? 0 : inf;\n                root.dp[0] = root.val;\n                return;\n            }\n\n            dsuOnTree(root.heavy, dp);\n            root.allPositive = root.heavy.allPositive;\n            for (int i = 0; i < root.heavy.size; i++) {\n                if (dp[i] < 0) {\n                    root.allPositive = Math.min(root.allPositive, i + 1);\n                    break;\n                }\n            }\n            for (int i = root.heavy.size; i >= 0; i--) {\n                dp[i] += root.val;\n                if (i > 0 && dp[i - 1] < 0) {\n                    dp[i] = Math.min(dp[i], root.val);\n                }\n                if (i > root.heavy.allPositive) {\n                    dp[i] = Math.min(dp[i], root.val);\n                }\n            }\n            for (int i = root.heavy.size + 1; i < root.size; i++) {\n                dp[i] = (long) 1e18;\n            }\n\n            for (Node node : root.next) {\n                if (node == root.heavy) {\n                    continue;\n                }\n                dsuOnTree(node, null);\n                // update all positive\n                int localAllPos = node.allPositive;\n                for (int i = 0; i < node.size; i++) {\n                    if (node.dp[i] < 0) {\n                        localAllPos = Math.min(localAllPos, i + 1);\n                        break;\n                    }\n                }\n                root.allPositive += localAllPos;\n\n                int splitCost = node.allPositive + 1;\n                for (int i = 0; i < node.size; i++) {\n                    if (node.dp[i] < 0) {\n                        splitCost = Math.min(splitCost, i + 1);\n                        break;\n                    }\n                }\n                // split or not\n                for (int i = root.size - 1; i >= 0; i--) {\n                    // split\n                    dp[i] += node.dp[0];\n                    if (i >= splitCost) {\n                        dp[i] = Math.min(dp[i], dp[i - splitCost]);\n                    }\n                    for (int j = 1; j < node.size && j <= i; j++) {\n                        int k = i - j;\n                        dp[i] = Math.min(dp[i], dp[k] + node.dp[j]);\n                    }\n                }\n            }\n\n            if (root.val < 0) {\n                root.allPositive = inf;\n            }\n\n        }\n\n        public void dfs(Node root, Node p) {\n            root.next.remove(p);\n            root.size = 1;\n            for (Node node : root.next) {\n                dfs(node, root);\n                root.size += node.size;\n                if (root.heavy == null || root.heavy.size < node.size) {\n                    root.heavy = node;\n                }\n            }\n        }\n\n    }\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n    static class FastOutput implements AutoCloseable, Closeable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput println(int c) {\n            cache.append(c).append('\\n');\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n    static class Node {\n        List<Node> next = new ArrayList<>();\n        Node heavy;\n        int size;\n        long[] dp;\n        int allPositive;\n        int val;\n        int id;\n\n        public String toString() {\n            return \"\" + id;\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n// import java.awt.Point;\n \npublic class Main {\n    InputStream is;\n    PrintWriter out;\n    String INPUT = \"\";\n \n    static int mod = 1_000_000_007;\n    long inf = Long.MAX_VALUE/2;\n\n    ArrayList<Integer>[] edge;\n    boolean[] seen;\n    int[] nodenum;\n    int n;\n    long[] a;\n\n    void solve(){\n        n = ni();\n        a = new long[n];\n        for(int i = 0; i < n; i++){\n            a[i] = nl();\n        }\n        edge = new ArrayList[n];\n        for(int i = 0; i < n; i++){\n            edge[i] = new ArrayList<Integer>();\n        }\n        for(int i = 0; i < n-1; i++){\n            int s = ni()-1;\n            int t = ni()-1;\n            edge[s].add(t);\n            edge[t].add(s);\n        }\n        seen = new boolean[n];\n        nodenum = new int[n];\n        seen[0] = true;\n        dfs_node(0);\n        seen = new boolean[n];\n        seen[0] = true;\n        long[][] ans = f(0);\n        for(int i = 0; i < n; i++){\n            // out.println(ans[i][0]+\" \"+ans[i][1]);\n            if(ans[i][0]!=inf || ans[i][1]<0){\n                out.println(i);\n                return;\n            }\n        }\n\n    }\n\n    int dfs_node(int r){\n        int ans = 1;\n        for(int t : edge[r]){\n            if(seen[t]) continue;\n            seen[t] = true;\n            ans += dfs_node(t);\n        }\n        nodenum[r] = ans;\n        // System.err.println(r+\" \"+ans);\n        return ans;\n    }\n\n    long[][] f(int r){\n        // System.err.println(u);\n        long[][] dp = new long[1][2];\n        dp[0][0] = a[r] > 0 ? a[r] : inf;\n        dp[0][1] = a[r];\n        int p = 1;\n        for(int t : edge[r]){\n            if(seen[t]) continue;\n            seen[t] = true;\n            long[][] rdp = f(t);\n            long[][] ndp = new long[p+nodenum[t]][2];\n            for(long[] v : ndp) Arrays.fill(v, inf);\n            for(int i = 0; i < p; i++){\n                for(int j = 0; j < nodenum[t]; j++){\n                    ndp[i+j][0] = Math.min(ndp[i+j][0], dp[i][0] + rdp[j][0]);\n                    ndp[i+j][1] = Math.min(ndp[i+j][1], dp[i][1] + rdp[j][1]);\n                    if(rdp[j][0]!=inf||rdp[j][1]<0){\n                        ndp[i+j+1][0] = Math.min(ndp[i+j+1][0], dp[i][0]);\n                        ndp[i+j+1][1] = Math.min(ndp[i+j+1][1], dp[i][1]);\n                    }\n                }\n            }\n            // out.println(r+\" \"+t+\" \"+dp[1-q][1][0]);\n            p += nodenum[t];\n            dp = ndp;\n        }\n        // out.println(r);\n        // for(int i = 0; i < nodenum[r]; i++){\n        //     out.println(dp[q][i][0]+\" \"+dp[q][i][1]);\n        // }\n        // System.err.println(\"ret\");\n        return dp;\n    }\n\n    void run() throws Exception\n    {\n        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n        out = new PrintWriter(System.out);\n        long s = System.currentTimeMillis();\n        solve();\n        out.flush();\n        if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+\"ms\");\n    }\n    \n    public static void main(String[] args) throws Exception { new Main().run(); }\n    \n    private byte[] inbuf = new byte[1024];\n    private int lenbuf = 0, ptrbuf = 0;\n    \n    private int readByte()\n    {\n        if(lenbuf == -1)throw new InputMismatchException();\n        if(ptrbuf >= lenbuf){\n            ptrbuf = 0;\n            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n            if(lenbuf <= 0)return -1;\n        }\n        return inbuf[ptrbuf++];\n    }\n    \n    private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n    private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n    \n    private double nd() { return Double.parseDouble(ns()); }\n    private char nc() { return (char)skip(); }\n    \n    private String ns()\n    {\n        int b = skip();\n        StringBuilder sb = new StringBuilder();\n        while(!(isSpaceChar(b) && b != ' ')){\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    \n    private char[] ns(int n)\n    {\n        char[] buf = new char[n];\n        int b = skip(), p = 0;\n        while(p < n && !(isSpaceChar(b))){\n            buf[p++] = (char)b;\n            b = readByte();\n        }\n        return n == p ? buf : Arrays.copyOf(buf, p);\n    }\n    \n    private char[][] nm(int n, int m)\n    {\n        char[][] map = new char[n][];\n        for(int i = 0;i < n;i++)map[i] = ns(m);\n        return map;\n    }\n    \n    private int[] na(int n)\n    {\n        int[] a = new int[n];\n        for(int i = 0;i < n;i++)a[i] = ni();\n        return a;\n    }\n    \n    private int ni()\n    {\n        int num = 0, b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        \n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    \n    private long nl()\n    {\n        long num = 0;\n        int b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        \n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    \n    private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }\n \n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n// import java.awt.Point;\n \npublic class Main {\n    InputStream is;\n    PrintWriter out;\n    String INPUT = \"\";\n \n    static int mod = 1_000_000_007;\n    long inf = Long.MAX_VALUE/2;\n\n    ArrayList<Integer>[] edge;\n    boolean[] seen;\n    int[] nodenum;\n    int n;\n    long[] a;\n\n    void solve(){\n        n = ni();\n        a = new long[n];\n        for(int i = 0; i < n; i++){\n            a[i] = nl();\n        }\n        edge = new ArrayList[n];\n        for(int i = 0; i < n; i++){\n            edge[i] = new ArrayList<Integer>();\n        }\n        for(int i = 0; i < n-1; i++){\n            int s = ni()-1;\n            int t = ni()-1;\n            edge[s].add(t);\n            edge[t].add(s);\n        }\n        seen = new boolean[n];\n        nodenum = new int[n];\n        seen[0] = true;\n        dfs_node(0);\n        seen = new boolean[n];\n        seen[0] = true;\n        long[][] ans = f(0);\n        for(int i = 0; i < n; i++){\n            // out.println(ans[i][0]+\" \"+ans[i][1]);\n            if(ans[i][0]!=inf || ans[i][1]<0){\n                out.println(i);\n                return;\n            }\n        }\n\n    }\n\n    int dfs_node(int r){\n        int ans = 1;\n        for(int t : edge[r]){\n            if(seen[t]) continue;\n            seen[t] = true;\n            ans += dfs_node(t);\n        }\n        nodenum[r] = ans;\n        // System.err.println(r+\" \"+ans);\n        return ans;\n    }\n\n    long[][] f(int r){\n        int u = nodenum[r];\n        // System.err.println(u);\n        long[][][] dp = new long[2][u][2];\n        for(int i = 0; i < u; i++){\n            dp[0][i][0] = inf;\n            dp[0][i][1] = inf;\n            dp[1][i][0] = inf;\n            dp[1][i][1] = inf;\n        }\n        if(a[r]>0){\n            dp[0][0][0] = a[r];\n            dp[0][0][1] = a[r];\n        }\n        else{\n            dp[0][0][1] = a[r]; \n        }\n        int p = 1;\n        int q = 0;\n        for(int t : edge[r]){\n            if(seen[t]) continue;\n            seen[t] = true;\n            long[][] rdp = f(t);\n            for(int i = 0; i < u; i++){\n                dp[1-q][i][0] = inf;\n                dp[1-q][i][1] = inf;\n            }\n            for(int i = 0; i < p; i++){\n                for(int j = 0; j < nodenum[t]; j++){\n                    boolean f1 = (dp[q][i][0]!=inf);\n                    boolean f2 = (dp[q][i][1]!=inf);\n                    boolean f3 = (rdp[j][0]!=inf);\n                    boolean f4 = (rdp[j][1]!=inf);\n                    boolean f5 = (rdp[j][1]<0);\n                    if(f1 && f3) dp[1-q][i+j][0] = Math.min(dp[1-q][i+j][0], dp[q][i][0] + rdp[j][0]);\n                    if(f2 && f4) dp[1-q][i+j][1] = Math.min(dp[1-q][i+j][1], dp[q][i][1] + rdp[j][1]);\n                    if((f3 || f5) && f1) dp[1-q][i+j+1][0] = Math.min(dp[1-q][i+j+1][0], dp[q][i][0]);\n                    if((f3 || f5) && f2){\n                        // out.println(\"cut\");\n                        dp[1-q][i+j+1][1] = Math.min(dp[1-q][i+j+1][1], dp[q][i][1]);\n                    }\n                }\n            }\n            // out.println(r+\" \"+t+\" \"+dp[1-q][1][0]);\n            p += nodenum[t];\n            q = 1-q;\n        }\n        // out.println(r);\n        // for(int i = 0; i < nodenum[r]; i++){\n        //     out.println(dp[q][i][0]+\" \"+dp[q][i][1]);\n        // }\n        // System.err.println(\"ret\");\n        return dp[q];\n    }\n\n    void run() throws Exception\n    {\n        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n        out = new PrintWriter(System.out);\n        long s = System.currentTimeMillis();\n        solve();\n        out.flush();\n        if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+\"ms\");\n    }\n    \n    public static void main(String[] args) throws Exception { new Main().run(); }\n    \n    private byte[] inbuf = new byte[1024];\n    private int lenbuf = 0, ptrbuf = 0;\n    \n    private int readByte()\n    {\n        if(lenbuf == -1)throw new InputMismatchException();\n        if(ptrbuf >= lenbuf){\n            ptrbuf = 0;\n            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n            if(lenbuf <= 0)return -1;\n        }\n        return inbuf[ptrbuf++];\n    }\n    \n    private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n    private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n    \n    private double nd() { return Double.parseDouble(ns()); }\n    private char nc() { return (char)skip(); }\n    \n    private String ns()\n    {\n        int b = skip();\n        StringBuilder sb = new StringBuilder();\n        while(!(isSpaceChar(b) && b != ' ')){\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    \n    private char[] ns(int n)\n    {\n        char[] buf = new char[n];\n        int b = skip(), p = 0;\n        while(p < n && !(isSpaceChar(b))){\n            buf[p++] = (char)b;\n            b = readByte();\n        }\n        return n == p ? buf : Arrays.copyOf(buf, p);\n    }\n    \n    private char[][] nm(int n, int m)\n    {\n        char[][] map = new char[n][];\n        for(int i = 0;i < n;i++)map[i] = ns(m);\n        return map;\n    }\n    \n    private int[] na(int n)\n    {\n        int[] a = new int[n];\n        for(int i = 0;i < n;i++)a[i] = ni();\n        return a;\n    }\n    \n    private int ni()\n    {\n        int num = 0, b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        \n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    \n    private long nl()\n    {\n        long num = 0;\n        int b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        \n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    \n    private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }\n \n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.StringJoiner;\nimport java.util.StringTokenizer;\nimport java.util.function.Function;\n\npublic class Main {\n\n    static int N;\n    static int[] A;\n    static int[] U, V;\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner(System.in);\n        N = sc.nextInt();\n        A = sc.nextIntArray(N);\n        U = new int[N-1];\n        V = new int[N-1];\n        for (int i = 0; i < N - 1; i++) {\n            U[i] = sc.nextInt()-1;\n            V[i] = sc.nextInt()-1;\n        }\n\n        System.out.println(solve());\n    }\n\n    static long INF = Long.MAX_VALUE / 2;\n    static int ROOT = 0;\n\n    static int solve() {\n        // バッテリーだけ\n        // (v, cut) => 最小値\n        long[][] dp = new long[N][];\n\n        // コンピューター含む\n        // (v, cut) => 最小値\n        long[][] dp2 = new long[N][];\n\n        // v -> カット数の容量\n        int[] dp3 = new int[N];\n\n        int[][] G = adjB(N, U, V);\n        for (Node node : orderFromLeaf(N, G, ROOT)) {\n            merge(node, G, dp, dp2, dp3);\n        }\n\n        int ret = Integer.MAX_VALUE;\n        for (int i = 0; i < N; i++) {\n            if( dp[ROOT][i] != INF ) {\n                ret = Math.min(i, ret);\n            }\n            if( dp2[ROOT][i] != INF && dp2[ROOT][i] < 0) {\n                ret = Math.min(i, ret);\n            }\n        }\n        return ret;\n    }\n\n    static void merge(Node node, int[][] G, long[][] dp, long[][] dp2, int[] dp3) {\n        dp[node.a] = new long[]{INF};\n        dp2[node.a] = new long[]{INF};\n        if( A[node.a] > 0 ) {\n            dp[node.a][0] = A[node.a];\n        } else {\n            dp2[node.a][0] = A[node.a];\n        }\n        int c = 1;\n        for (int next : G[node.a]) {\n            if( node.parent == next ) continue;\n\n            long[] tdp = new long[c+dp3[next]];\n            Arrays.fill(tdp, INF);\n            long[] tdp2 = new long[c+dp3[next]];\n            Arrays.fill(tdp2, INF);\n\n            for (int i = 0; i < c; i++) {\n                for (int j = 0; j < dp3[next]; j++) {\n                    if( dp[node.a][i] != INF ) {\n                        // バ + バ = バ\n                        if( dp[next][j] != INF ) {\n                            tdp[i+j] = Math.min(dp[node.a][i] + dp[next][j], tdp[i+j]);\n                        }\n\n                        // バ + コ = コ\n                        if( dp2[next][j] != INF ) {\n                            tdp2[i+j] = Math.min(dp[node.a][i] + dp2[next][j], tdp2[i+j]);\n                        }\n\n                        // cutする\n                        // コはcutして大丈夫かどうか調べる\n                        if( dp[next][j] != INF || dp2[next][j] < 0 ) {\n                            tdp[i+j+1] = Math.min(dp[node.a][i], tdp[i+j+1]);\n                        }\n                    }\n\n                    if( dp2[node.a][i] != INF ) {\n                        // バ + コ = コ\n                        if( dp[next][j] != INF ) {\n                            tdp2[i+j] = Math.min(dp2[node.a][i] + dp[next][j], tdp2[i+j]);\n                        }\n\n                        // コ + コ = コ\n                        if( dp2[next][j] != INF ) {\n                            tdp2[i+j] = Math.min(dp2[node.a][i] + dp2[next][j], tdp2[i+j]);\n                        }\n\n                        // cutする\n                        // コはcutして大丈夫かどうか調べる\n                        if( dp[next][j] != INF || dp2[next][j] < 0 ) {\n                            tdp2[i+j+1] = Math.min(dp2[node.a][i], tdp2[i+j+1]);\n                        }\n                    }\n                }\n            }\n\n            dp[node.a] = tdp;\n            dp2[node.a] = tdp2;\n            c += dp3[next];\n        }\n\n        dp3[node.a] = c;\n    }\n\n    static int[][] adjB(int n, int[] from, int[] to) {\n        int[][] adj = new int[n][];\n        int[] cnt = new int[n];\n        for (int f : from) {\n            cnt[f]++;\n        }\n        for (int t : to) {\n            cnt[t]++;\n        }\n        for (int i = 0; i < n; i++) {\n            adj[i] = new int[cnt[i]];\n        }\n        for (int i = 0; i < from.length; i++) {\n            adj[from[i]][--cnt[from[i]]] = to[i];\n            adj[to[i]][--cnt[to[i]]] = from[i];\n        }\n        return adj;\n    }\n\n    static Node[] orderFromLeaf(int N, int[][] G, int root) {\n        ArrayDeque<Node> q = new ArrayDeque<>();\n        Node[] ret = new Node[N];\n        int idx = N-1;\n        q.add(new Node(-1, root));\n        while(!q.isEmpty()) {\n            Node n = q.poll();\n            ret[idx--] = n;\n            for (int next : G[n.a]) {\n                if( next == n.parent ) continue;\n\n                q.add(new Node(n.a, next));\n            }\n        }\n        return ret;\n    }\n\n    static class Node {\n        int parent, a;\n\n        public Node(int parent, int a) {\n            this.parent = parent;\n            this.a = a;\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    static class FastScanner {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        int[] nextIntArray(int n, int delta) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt() + delta;\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n    }\n\n    static <A> void writeLines(A[] as, Function<A, String> f) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (A a : as) {\n            pw.println(f.apply(a));\n        }\n        pw.flush();\n    }\n\n    static void writeLines(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static void writeLines(long[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (long a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static int max(int... as) {\n        int max = Integer.MIN_VALUE;\n        for (int a : as) max = Math.max(a, max);\n        return max;\n    }\n\n    static int min(int... as) {\n        int min = Integer.MAX_VALUE;\n        for (int a : as) min = Math.min(a, min);\n        return min;\n    }\n\n    static void debug(Object... args) {\n        StringJoiner j = new StringJoiner(\" \");\n        for (Object arg : args) {\n            if (arg instanceof int[]) j.add(Arrays.toString((int[]) arg));\n            else if (arg instanceof long[]) j.add(Arrays.toString((long[]) arg));\n            else if (arg instanceof double[]) j.add(Arrays.toString((double[]) arg));\n            else if (arg instanceof Object[]) j.add(Arrays.toString((Object[]) arg));\n            else j.add(arg.toString());\n        }\n        System.err.println(j.toString());\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\nusing System.Numerics;\nusing static System.Math;\nnamespace Program {\n    public class Solver {\n        Random rnd = new Random(0);\n        public void Solve() {\n            var n = ri;\n            var A = Enumerate(n, x => rl);\n            var G = Enumerate(n, x => new List<int>());\n            for (int i = 0; i < n - 1; i++) {\n                var u = ri - 1;\n                var v = ri - 1;\n                G[u].Add(v);\n                G[v].Add(u);\n            }\n            // all plus\n            var dp = Enumerate(n, x => new long[0]);\n\n            // other case\n            var ep = Enumerate(n, x => new long[0]);\n\n\n            Action<int, int> dfs = null;\n            dfs = (prev, cur) =>\n            {\n                var d = new long[1];\n                var e = new long[1];\n                d[0] = INF;\n                e[0] = INF;\n                if (A[cur] > 0) d[0] = A[cur];\n                else e[0] = A[cur];\n                if (cur == 4) {\n\n                }\n\n                foreach (var t in G[cur]) {\n                    if (t == prev) continue;\n                    dfs(cur, t);\n                    var dd = dp[t];\n                    var ee = ep[t];\n\n                    var nd = new long[d.Length + dd.Length];\n                    var ne = new long[e.Length + ee.Length];\n                    for (int i = 0; i < nd.Length; i++)\n                        nd[i] = ne[i] = INF;\n\n                    for (int i = 0; i < d.Length; i++)\n                        for (int j = 0; j < dd.Length; j++) {\n                            nd[i + j] = Min(nd[i + j], d[i] + dd[j]);\n\n                            ne[i + j] = Min(ne[i + j], e[i] + ee[j]);\n                            ne[i + j] = Min(ne[i + j], d[i] + ee[j]);\n                            ne[i + j] = Min(ne[i + j], e[i] + dd[j]);\n                            if (dd[j] != INF || ee[j] < 0) {\n                                nd[i + j + 1] = Min(nd[i + j + 1], d[i]);\n                                ne[i + j + 1] = Min(ne[i + j], e[i]);\n                            }\n                        }\n\n                    d = nd;\n                    e = ne;\n                }\n                dp[cur] = d;\n                ep[cur] = e;\n            };\n            dfs(-1, 0);\n            for (int i = 0; i < n; i++) {\n                Debug.WriteLine(i);\n                Debug.WriteLine(dp[i].AsJoinedString());\n                Debug.WriteLine(ep[i].AsJoinedString());\n            }\n            for (int i = 0; i < dp[0].Length; i++) {\n                if (dp[0][i] != INF || (ep[0][i] < 0)) {\n                    Console.WriteLine(i);\n                    return;\n                }\n            }\n        }\n\n        const long INF = 1L << 60;\n        int ri { get { return sc.Integer(); } }\n        long rl { get { return sc.Long(); } }\n        double rd { get { return sc.Double(); } }\n        string rs { get { return sc.Scan(); } }\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex {\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie);\n    }\n    static public void Main() {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        solver.Solve();\n        Console.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer: StreamWriter {\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len) {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0) {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.IO;\nusing System.Text;\n\nusing static util;\nusing P = pair<int, int>;\n\nusing Binary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.ParameterExpression,\n                           System.Linq.Expressions.BinaryExpression>;\nusing Unary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.UnaryExpression>;\n\nclass Program\n{\n    static StreamWriter sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n    static Scan sc = new Scan();\n    const int M = 1000000007;\n    const int M2 = 998244353;\n    const long LM = (long)1e18;\n    const double eps = 1e-11;\n    static readonly int[] dd = { 0, 1, 0, -1, 0 };\n    const string dstring = \"RDLU\";\n    static void Main()\n    {\n        int n = sc.Int;\n        a = sc.LongArr;\n        edge = new List<int>[n];\n        for (int i = 0; i < n; i++)\n        {\n            edge[i] = new List<int>();\n        }\n        for (int i = 0; i < n - 1; i++)\n        {\n            int u, v;\n            sc.Multi(out u, out v);\n            --u;\n            --v;\n            edge[u].Add(v);\n            edge[v].Add(u);\n        }\n        var b = dfs(0, -1);\n        for (int i = 0; i < n; i++)\n        {\n            if (b[i][0] < LM / 100 || b[i][1] < 0) {\n                DBG(i);\n                return;\n            }\n        }\n        sw.Flush();\n    }\n    static long[] a;\n    static List<int>[] edge;\n\n    static long[][] dfs(int p, int par) {\n        var dp = new long[1][];\n        for (int i = 0; i < 1; i++)\n        {\n            dp[i] = new long[2];\n            dp[i][0] = LM;\n            dp[i][1] = LM;\n        }\n        if (a[p] > 0) {\n            dp[0][0] = a[p];\n        }\n        else {\n            dp[0][1] = a[p];\n        }\n        foreach (var item in edge[p])\n        {\n            if (item == par) continue;\n            var b = dfs(item, p);\n            var nex = new long[dp.Length + b.Length][];\n            for (int i = 0; i < nex.Length; i++)\n            {\n                nex[i] = new long[2];\n                nex[i][0] = LM;\n                nex[i][1] = LM;\n            }\n            for (int i = 0; i < dp.Length; i++)\n            {\n                if (dp[i][0] > LM / 100 && dp[i][1] > LM / 100) continue;\n                for (int j = 0; j < b.Length; j++)\n                {\n                    nex[i + j][0] = Math.Min(nex[i + j][0], dp[i][0] + b[j][0]);\n                    nex[i + j][1] = Math.Min(nex[i + j][1], dp[i][0] + b[j][1]);\n                    nex[i + j][1] = Math.Min(nex[i + j][1], dp[i][1] + b[j][0]);\n                    nex[i + j][1] = Math.Min(nex[i + j][1], dp[i][1] + b[j][1]);\n                    if (b[j][0] < LM / 100 || b[j][1] < 0) {\n                        nex[i + j + 1][0] = Math.Min(nex[i + j + 1][0], dp[i][0]);\n                        nex[i + j + 1][1] = Math.Min(nex[i + j + 1][1], dp[i][1]);\n                    }\n                }\n            }\n            dp = nex;\n        }\n        return dp;\n    }\n\n    static void DBG(string a) => Console.WriteLine(a);\n    static void DBG<T>(IEnumerable<T> a) => DBG(string.Join(\" \", a));\n    static void DBG(params object[] a) => DBG(string.Join(\" \", a));\n    static void Prt(string a) => sw.WriteLine(a);\n    static void Prt<T>(IEnumerable<T> a) => Prt(string.Join(\" \", a));\n    static void Prt(params object[] a) => Prt(string.Join(\" \", a));\n}\nclass pair<T, U> : IComparable<pair<T, U>>\n{\n    public T v1;\n    public U v2;\n    public pair(T v1, U v2) {\n        this.v1 = v1;\n        this.v2 = v2;\n    }\n    public int CompareTo(pair<T, U> a) {\n        int c = Comparer<T>.Default.Compare(v1, a.v1);\n        return c != 0 ? c : Comparer<U>.Default.Compare(v2, a.v2);\n    }\n    public override string ToString() => v1 + \" \" + v2;\n    public void Deconstruct(out T a, out U b) {\n        a = v1; b = v2;\n    }\n    public static bool operator>(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) > 0;\n    public static bool operator<(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) < 0;\n    public static bool operator>=(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) >= 0;\n    public static bool operator<=(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) <= 0;\n}\nstatic class util\n{\n    public static pair<T, U> make_pair<T, U>(T v1, U v2) => new pair<T, U>(v1, v2);\n    public static T sq<T>(T a) => Operator<T>.Multiply(a, a);\n    public static T Max<T>(params T[] a) => a.Max();\n    public static T Min<T>(params T[] a) => a.Min();\n    public static bool inside(int i, int j, int h, int w) => i >= 0 && i < h && j >= 0 && j < w;\n    public static Dictionary<T, int> compress<T>(this IEnumerable<T> a)\n        => a.Distinct().OrderBy(v => v).Select((v, i) => new { v, i }).ToDictionary(p => p.v, p => p.i);\n    public static Dictionary<T, int> compress<T>(params IEnumerable<T>[] a) => compress(a.Aggregate(Enumerable.Union));\n    public static void swap<T>(ref T a, ref T b) where T : struct { var t = a; a = b; b = t; }\n    public static void swap<T>(this IList<T> a, int i, int j) where T : struct { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a) {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n}\nstatic class Operator<T>\n{\n    static readonly ParameterExpression x = Expression.Parameter(typeof(T), \"x\");\n    static readonly ParameterExpression y = Expression.Parameter(typeof(T), \"y\");\n    public static readonly Func<T, T, T> Add = Lambda(Expression.Add);\n    public static readonly Func<T, T, T> Subtract = Lambda(Expression.Subtract);\n    public static readonly Func<T, T, T> Multiply = Lambda(Expression.Multiply);\n    public static readonly Func<T, T, T> Divide = Lambda(Expression.Divide);\n    public static readonly Func<T, T> Plus = Lambda(Expression.UnaryPlus);\n    public static readonly Func<T, T> Negate = Lambda(Expression.Negate);\n    public static Func<T, T, T> Lambda(Binary op) => Expression.Lambda<Func<T, T, T>>(op(x, y), x, y).Compile();\n    public static Func<T, T> Lambda(Unary op) => Expression.Lambda<Func<T, T>>(op(x), x).Compile();\n}\n\nclass Scan\n{\n    public int Int => int.Parse(Str);\n    public long Long => long.Parse(Str);\n    public double Double => double.Parse(Str);\n    public string Str => Console.ReadLine().Trim();\n    public pair<T, U> Pair<T, U>() {\n        T a; U b;\n        Multi(out a, out b);\n        return new pair<T, U>(a, b);\n    }\n    public P P {\n        get {\n            int a, b;\n            Multi(out a, out b);\n            return new P(a, b);\n        }\n    }\n    public int[] IntArr => StrArr.Select(int.Parse).ToArray();\n    public long[] LongArr => StrArr.Select(long.Parse).ToArray();\n    public double[] DoubleArr => StrArr.Select(double.Parse).ToArray();\n    public string[] StrArr => Str.Split(new[]{' '}, StringSplitOptions.RemoveEmptyEntries);\n    bool eq<T, U>() => typeof(T).Equals(typeof(U));\n    T ct<T, U>(U a) => (T)Convert.ChangeType(a, typeof(T));\n    T cv<T>(string s) => eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                       : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                       : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                       : eq<T, char>()   ? ct<T, char>(s[0])\n                                         : ct<T, string>(s);\n    public void Multi<T>(out T a) => a = cv<T>(Str);\n    public void Multi<T, U>(out T a, out U b)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); }\n    public void Multi<T, U, V>(out T a, out U b, out V c)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); }\n    public void Multi<T, U, V, W, X, Y>(out T a, out U b, out V c, out W d, out X e, out Y f)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); f = cv<Y>(ar[5]); }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Text;\nusing System.Numerics;\nusing System.Threading;\nusing System.Runtime.CompilerServices;\nusing System.Diagnostics;\nusing static System.Math;\nusing static System.Array;\nusing static AtCoder.Cout;\nusing static AtCoder.Tool;\nusing static AtCoder.ModInt;\nnamespace AtCoder\n{\n    class AC\n    {\n        const int MOD = 1000000007;\n        //const int MOD = 998244353;\n        const int INF = int.MaxValue / 2;\n        const long SINF = long.MaxValue / 3;\n        const double EPS = 1e-8;\n        static readonly int[] dI = { 0, 1, 0, -1, 1, -1, -1, 1 };\n        static readonly int[] dJ = { 1, 0, -1, 0, 1, 1, -1, -1 };\n        static void Main(string[] args)\n        {\n            //var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false }; Console.SetOut(sw);\n\n            var th = new Thread(Run, 1 << 26);\n            th.Start();\n            th.Join();\n\n            //Run();\n            Console.Out.Flush();\n        }\n        static void Run()\n        {\n            int Testcase = 1;\n            //Testcase = Cin.Int;\n            for (var _ = 0; _ < Testcase; _++) Solve();\n        }\n        static void Solve()\n        {\n            int N = Cin.Int;\n            var A = Cin.ReadSplitLong;\n            var G = new List<List<int>>();\n            for (var i = 0; i < N; i++) G.Add(new List<int>());\n            for(var i = 0; i < N - 1; i++)\n            {\n                Cin.Input(out int a, out int b);\n                a--;b--;\n                G[a].Add(b);\n                G[b].Add(a);\n            }\n            var dpp = new bool[N][];\n            var dpm = new long[N][];\n            var sz = new int[N];\n            void dfs(int v,int pre = -1)\n            {\n                sz[v] = 1;\n                dpp[v] = new bool[1];\n                dpp[v][0] = A[v] > 0;\n\n                dpm[v] = new long[1];\n                dpm[v][0] = A[v];\n\n                foreach(var nx in G[v])\n                {\n                    if (nx == pre) continue;\n                    dfs(nx, v);\n                    var mgp = new bool[sz[v] + sz[nx] + 1];\n                    var mgm = new long[sz[v] + sz[nx] + 1];\n                    Fill(mgm, SINF);\n                    for(var i = 0; i < sz[v]; i++)\n                    {\n                        for(var j = 0; j < sz[nx]; j++)\n                        {\n                            //全部正\n                            //辺を切らない\n                            mgp[i + j] |= dpp[v][i] & dpp[nx][j];\n                            //辺を切る\n                            mgp[i + j + 1] |= dpp[v][i] & (dpp[nx][j] | dpm[nx][j] < 0);\n\n                            //合計が負\n                            //辺を切らない\n                            mgm[i + j] = Min(mgm[i + j], dpm[v][i] + dpm[nx][j]);\n                            //辺を切る\n                            if (dpp[nx][j] || dpm[nx][j] < 0) mgm[i + j + 1] = Min(mgm[i], dpm[v][i]);\n                        }\n                    }\n                    sz[v] += sz[nx];\n                    dpp[v] = mgp;\n                    dpm[v] = mgm;\n                }\n            }\n            dfs(0);\n            int ans = N - 1;\n            /*for(var i = 0; i < N; i++)\n            {\n                OutL($\"v={i + 1}\");\n                Out_Sep(dpp[i]);\n                Out_Sep(dpm[i]);\n                OutL($\"===========\");\n            }*/\n            for(var i = 0; i < N; i++)\n            {\n                if (dpp[0][i] || dpm[0][i] < 0)\n                {\n                    ans = i;\n                    break;\n                }\n            }\n            OutL(ans);\n            \n        }\n        public struct Edge\n        {\n            public int from;\n\n            public int to;\n            public long dist;\n\n            public Edge(int t, long c)\n            {\n                from = -1;\n                to = t;\n                dist = c;\n            }\n            public Edge(int f, int t, long c)\n            {\n                from = f;\n                to = t;\n                dist = c;\n            }\n        }\n    }\n    struct ModInt\n    {\n        public long value;\n        private const int MOD = 1000000007;\n        //private const int MOD = 998244353;\n        public ModInt(long value) { this.value = value; }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static implicit operator ModInt(long a)\n        {\n            var ret = a % MOD;\n            return new ModInt(ret < 0 ? (ret + MOD) : ret);\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt operator +(ModInt a, ModInt b) => (a.value + b.value);\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt operator -(ModInt a, ModInt b) => (a.value - b.value);\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt operator *(ModInt a, ModInt b) => (a.value * b.value);\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt operator /(ModInt a, ModInt b) => a * Modpow(b, MOD - 2);\n\n        public static ModInt operator <<(ModInt a, int n) => (a.value << n);\n        public static ModInt operator >>(ModInt a, int n) => (a.value >> n);\n        public static ModInt operator ++(ModInt a) => a.value + 1;\n        public static ModInt operator --(ModInt a) => a.value - 1;\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt Modpow(ModInt a, long n)\n        {\n            var k = a;\n            ModInt ret = 1;\n            while (n > 0)\n            {\n                if ((n & 1) != 0) ret *= k;\n                k *= k;\n                n >>= 1;\n            }\n            return ret;\n        }\n        private static readonly List<long> Factorials = new List<long>() { 1 };\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt Fac(long n)\n        {\n            for (var i = Factorials.Count(); i <= n; i++)\n            {\n                Factorials.Add((Factorials[i - 1] * i) % MOD);\n            }\n            return Factorials[(int)n];\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt nCr(long n, long r)\n        {\n            if (n < 0 || r < 0) return 0;\n            return n < r ? 0 : Fac(n) / (Fac(r) * Fac(n - r));\n        }\n        public static explicit operator int(ModInt a) => (int)a.value;\n    }\n    public class Rolling_Hash\n    {\n        const ulong m30 = (1UL << 30) - 1;\n        const ulong m31 = (1UL << 31) - 1;\n        const ulong MOD = (1UL << 61) - 1;\n        const ulong Pl = (MOD << 1) << 1;\n        private uint B;\n        private string S;\n        ulong[] hash;\n        ulong[] pw;\n\n        public Rolling_Hash(string str)\n        {\n            S = str;\n            B = (uint)new Random().Next(1 << 12 + 1, int.MaxValue);\n            int L = S.Length;\n            hash = new ulong[L + 1];\n            pw = new ulong[L + 1];\n            hash[0] = 0;\n            pw[0] = 1;\n            for (var i = 0; i < L; i++)\n            {\n                hash[i + 1] = CalcMod(Mul(hash[i], B) + S[i]);\n                pw[i + 1] = CalcMod(Mul(pw[i], B));\n            }\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public ulong GetHashValue(int idx) => hash[idx];\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]//segment [l,r]\n        public ulong Hash_fold(int l, int r) => CalcMod(Pl + hash[r + 1] - Mul(hash[l], pw[r - l + 1]));\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]//segment[start,start+len-1]\n        public ulong Hash_sub(int start, int len) => CalcMod(Pl + hash[start + len] - Mul(hash[start], pw[len]));\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public ulong[] GetHashArray() => hash;\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        ulong Mul(ulong a, ulong b)\n        {\n            ulong au = a >> 31;\n            ulong ad = a & m31;\n            ulong bu = b >> 31;\n            ulong bd = b & m31;\n            ulong mid = ad * bu + au * bd;\n            ulong midu = mid >> 30;\n            ulong midd = mid & m30;\n            return au * bu * 2 + midu + (midd << 31) + ad * bd;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        ulong CalcMod(ulong x)\n        {\n            ulong xu = x >> 61;\n            ulong xd = x & MOD;\n            ulong res = xu + xd;\n            if (res >= MOD) res -= MOD;\n            return res;\n        }\n    }\n    public class Priority_Queue<T>\n    {\n        private List<T> Q;\n        private readonly Comparison<T> Func_Compare;\n        public Priority_Queue(Comparison<T> comp)\n        {\n            Func_Compare = comp;\n            Q = new List<T>();\n        }\n        private void PushHeap(List<T> list, T item)\n        {\n            int n = list.Count();\n            list.Add(item);\n\n            while (n != 0)\n            {\n                int pIndex = (n - 1) / 2;\n\n                if (Func_Compare(list[n], list[pIndex]) < 0)\n                {\n                    Swap(Q, n, pIndex);\n                }\n                else { break; }\n\n                n = pIndex;\n            }\n        }\n        private void PopHeap(List<T> list)\n        {\n            int n = list.Count() - 1;\n            list[0] = list[n];\n            list.RemoveAt(n);\n\n            int cur = 0;\n            int comp;\n\n            while (2 * cur + 1 <= n - 1)\n            {\n                int c1 = 2 * cur + 1;\n                int c2 = 2 * (cur + 1);\n                if (c1 == n - 1)\n                {\n                    comp = c1;\n                }\n                else\n                {\n\n                    comp = Func_Compare(list[c1], list[c2]) < 0 ? c1 : c2;\n                }\n\n                if (Func_Compare(list[cur], list[comp]) > 0)\n                {\n                    Swap(Q, cur, comp);\n                }\n                else { break; }\n\n                cur = comp;\n            }\n        }\n        private void Swap(List<T> list, int a, int b)\n        {\n            T keep = list[a];\n            list[a] = list[b];\n            list[b] = keep;\n        }\n\n        public void Enqueue(T value)\n        {\n            PushHeap(Q, value);\n        }\n\n        public T Dequeue()\n        {\n            T ret = Q[0];\n            PopHeap(Q);\n            return ret;\n        }\n\n        public T Peek()\n        {\n            return Q[0];\n        }\n\n        public int Count()\n        {\n            return Q.Count();\n        }\n        public bool Any()\n        {\n            return Q.Any();\n        }\n    }\n    public class SegmentTree<T>\n    {\n        //1-indexed type\n        int n;\n        T[] Tree;\n        Func<T, T, T> f;\n        T ex;\n        int L;\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public SegmentTree(int size, Func<T, T, T> fun, T exvalue)\n        {\n            ex = exvalue;\n            f = fun;\n            n = 1;\n            while (n < size) n <<= 1;\n            Tree = new T[n << 1];\n            L = (n << 1) - 1;\n            for (var i = 0; i <= L; i++) Tree[i] = ex;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public SegmentTree(int size, Func<T, T, T> fun, T exvalue, T[] initial)\n        {\n            ex = exvalue;\n            n = 1; while (n < size) n <<= 1;\n            f = fun;\n            Tree = new T[n << 1];\n            L = (n << 1) - 1;\n            for (var i = 0; i <= L; i++) Tree[i] = (n <= i && i <= n + initial.Length - 1) ? initial[i - n] : ex;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Set_All()\n        {\n            for (var i = n - 1; i >= 1; i--) Tree[i] = f(Tree[i << 1], Tree[(i << 1) | 1]);\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Assign(int idx, T nxt) => Tree[idx + n] = nxt;\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Update(int idx)\n        {\n            int now = idx + n;\n            while (now > 1)\n            {\n                now >>= 1;\n                Tree[now] = f(Tree[now << 1], Tree[now << 1 | 1]);\n            }\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Query_Update(int idx, T nxt)\n        {\n            Assign(idx, nxt); Update(idx);\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Query_Update_func(int idx, T y)\n        {\n            Assign(idx, f(Peek(idx), y)); Update(idx);\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public T Query_Fold(int l, int r)\n        {\n            int L = n + l;\n            int R = n + r;\n            T vL = ex, vR = ex;\n            while (L < R)\n            {\n                if (L % 2 == 1)\n                {\n                    vL = f(vL, Tree[L]);\n                    L++;\n                }\n                if (R % 2 == 1)\n                {\n                    vR = f(Tree[R - 1], vR);\n                    R--;\n                }\n                L >>= 1;\n                R >>= 1;\n            }\n            return f(vL, vR);\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public T Peek(int idx) => Tree[idx + n];\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Display(int len)\n        {\n            for (var i = 0; i < len; i++) Console.Write($\"{Tree[i + n]} \");\n            Console.WriteLine();\n        }\n    }\n    public class UnionFind\n    {\n        private int[] parent;\n        private int[] rank;\n        private int[] size;\n        public UnionFind(int n)\n        {\n            parent = new int[n];\n            rank = new int[n];\n            size = new int[n];\n            for (var i = 0; i < n; i++)\n            {\n                parent[i] = i;\n                rank[i] = 0;\n                size[i] = 1;\n            }\n        }\n\n        public int Root(int x)\n        {\n            return parent[x] == x ? x : parent[x] = Root(parent[x]);\n        }\n\n        public bool SameRoot(int x, int y)\n        {\n            return Root(x) == Root(y);\n        }\n\n        public void Unite(int x, int y)\n        {\n            x = Root(x);\n            y = Root(y);\n            if (x == y) { return; }\n\n            if (rank[x] < rank[y])\n            {\n                parent[x] = y;\n                size[y] += size[x];\n                size[x] = 0;\n            }\n            else\n            {\n                parent[y] = x;\n                if (rank[x] == rank[y]) { rank[x]++; }\n                size[x] += size[y];\n                size[y] = 0;\n            }\n        }\n\n        public int SizeOf(int x)\n        {\n            return size[Root(x)];\n        }\n\n    }\n    static class Cin\n    {\n        public static string[] ReadSplit => Console.ReadLine().Split();\n        public static int[] ReadSplitInt => ConvertAll(Console.ReadLine().Split(), int.Parse);\n        public static long[] ReadSplitLong => ConvertAll(Console.ReadLine().Split(), long.Parse);\n        public static double[] ReadSplit_Double => ConvertAll(Console.ReadLine().Split(), double.Parse);\n        public static string Str => Console.ReadLine();\n        public static int Int => int.Parse(Console.ReadLine());\n        public static long Long => long.Parse(Console.ReadLine());\n        public static double Double => double.Parse(Console.ReadLine());\n        public static T Conv<T>(string input)\n        {\n            if (typeof(T).Equals(typeof(ModInt)))\n            {\n                return (T)(dynamic)(long.Parse(input));\n            }\n            return (T)Convert.ChangeType(input, typeof(T));\n        }\n        public static void Input<T>(out T a) => a = Conv<T>(Console.ReadLine());\n        public static void Input<T, U>(out T a, out U b)\n        { var q = ReadSplit; a = Conv<T>(q[0]); b = Conv<U>(q[1]); }\n        public static void Input<T, U, V>(out T a, out U b, out V c)\n        { var q = ReadSplit; a = Conv<T>(q[0]); b = Conv<U>(q[1]); c = Conv<V>(q[2]); }\n        public static void Input<T, U, V, W>(out T a, out U b, out V c, out W d)\n        { var q = ReadSplit; a = Conv<T>(q[0]); b = Conv<U>(q[1]); c = Conv<V>(q[2]); d = Conv<W>(q[3]); }\n        public static void Input<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n        { var q = ReadSplit; a = Conv<T>(q[0]); b = Conv<U>(q[1]); c = Conv<V>(q[2]); d = Conv<W>(q[3]); e = Conv<X>(q[4]); }\n    }\n    static class Cout\n    {\n        public static void OutL(object s) => Console.WriteLine(s);\n        public static void Out_Sep<T>(IEnumerable<T> s) => Console.WriteLine(string.Join(\" \", s));\n        public static void Out_Sep<T>(IEnumerable<T> s, string sep) => Console.WriteLine(string.Join($\"{sep}\", s));\n        public static void Out_Sep(params object[] s) => Console.WriteLine(string.Join(\" \", s));\n        public static void Out_One(object s) => Console.Write($\"{s} \");\n        public static void Out_One(object s, string sep) => Console.Write($\"{s}{sep}\");\n        public static void Endl() => Console.WriteLine();\n    }\n    public static class Tool\n    {\n        static public void Initialize<T>(ref T[] array, T initialvalue)\n        {\n            array = ConvertAll(array, x => initialvalue);\n        }\n        static public void Swap<T>(ref T a, ref T b)\n        {\n            T keep = a;\n            a = b;\n            b = keep;\n        }\n        static public void Display<T>(T[,] array2d, int n, int m)\n        {\n            for (var i = 0; i < n; i++)\n            {\n                for (var j = 0; j < m; j++)\n                {\n                    Console.Write($\"{array2d[i, j]} \");\n                }\n                Console.WriteLine();\n            }\n        }\n        static public long Gcd(long a, long b)\n        {\n            if (a == 0 || b == 0) return Max(a, b);\n            return a % b == 0 ? b : Gcd(b, a % b);\n        }\n        static public long LPow(int a, int b) => (long)Pow(a, b);\n        static public bool Bit(long x, int dig) => ((1L << dig) & x) != 0;\n        static public int Sig(long a) => a == 0 ? 0 : (int)(a / Abs(a));\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.IO;\nusing System.Text;\n\nusing static util;\nusing P = pair<int, int>;\n\nusing Binary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.ParameterExpression,\n                           System.Linq.Expressions.BinaryExpression>;\nusing Unary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.UnaryExpression>;\n\nclass Program\n{\n    static StreamWriter sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n    static Scan sc = new Scan();\n    const int M = 1000000007;\n    const int M2 = 998244353;\n    const long LM = (long)1e18;\n    const double eps = 1e-11;\n    static readonly int[] dd = { 0, 1, 0, -1, 0 };\n    const string dstring = \"RDLU\";\n    static void Main()\n    {\n        int n = sc.Int;\n        a = sc.LongArr;\n        edge = new List<int>[n];\n        for (int i = 0; i < n; i++)\n        {\n            edge[i] = new List<int>();\n        }\n        for (int i = 0; i < n - 1; i++)\n        {\n            int u, v;\n            sc.Multi(out u, out v);\n            --u;\n            --v;\n            edge[u].Add(v);\n            edge[v].Add(u);\n        }\n        var b = dfs(0, -1);\n        for (int i = 0; i < n; i++)\n        {\n            if (b[i][0] < LM / 100 || b[i][1] < 0) {\n                DBG(i);\n                return;\n            }\n        }\n        sw.Flush();\n    }\n    static long[] a;\n    static List<int>[] edge;\n\n    static long[][] dfs(int p, int par) {\n        var dp = new long[1][];\n        for (int i = 0; i < 1; i++)\n        {\n            dp[i] = new long[2];\n            dp[i][0] = LM;\n            dp[i][1] = LM;\n        }\n        dp[0][1] = a[p];\n        if (a[p] > 0) {\n            dp[0][0] = a[p];\n        }\n        foreach (var item in edge[p])\n        {\n            if (item == par) continue;\n            var b = dfs(item, p);\n            var nex = new long[dp.Length + b.Length][];\n            for (int i = 0; i < nex.Length; i++)\n            {\n                nex[i] = new long[2];\n                nex[i][0] = LM;\n                nex[i][1] = LM;\n            }\n            for (int i = 0; i < dp.Length; i++)\n            {\n                if (dp[i][0] > LM / 100 && dp[i][1] > LM / 100) continue;\n                for (int j = 0; j < b.Length; j++)\n                {\n                    nex[i + j][0] = Math.Min(nex[i + j][0], dp[i][0] + b[j][0]);\n                    nex[i + j][1] = Math.Min(nex[i + j][1], dp[i][1] + b[j][1]);\n                    if (b[j][0] < LM / 100 || b[j][1] < 0) {\n                        nex[i + j + 1][0] = Math.Min(nex[i + j + 1][0], dp[i][0]);\n                        nex[i + j + 1][1] = Math.Min(nex[i + j + 1][1], dp[i][1]);\n                    }\n                }\n            }\n            dp = nex;\n        }\n        return dp;\n    }\n\n    static void DBG(string a) => Console.WriteLine(a);\n    static void DBG<T>(IEnumerable<T> a) => DBG(string.Join(\" \", a));\n    static void DBG(params object[] a) => DBG(string.Join(\" \", a));\n    static void Prt(string a) => sw.WriteLine(a);\n    static void Prt<T>(IEnumerable<T> a) => Prt(string.Join(\" \", a));\n    static void Prt(params object[] a) => Prt(string.Join(\" \", a));\n}\nclass pair<T, U> : IComparable<pair<T, U>>\n{\n    public T v1;\n    public U v2;\n    public pair(T v1, U v2) {\n        this.v1 = v1;\n        this.v2 = v2;\n    }\n    public int CompareTo(pair<T, U> a) {\n        int c = Comparer<T>.Default.Compare(v1, a.v1);\n        return c != 0 ? c : Comparer<U>.Default.Compare(v2, a.v2);\n    }\n    public override string ToString() => v1 + \" \" + v2;\n    public void Deconstruct(out T a, out U b) {\n        a = v1; b = v2;\n    }\n    public static bool operator>(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) > 0;\n    public static bool operator<(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) < 0;\n    public static bool operator>=(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) >= 0;\n    public static bool operator<=(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) <= 0;\n}\nstatic class util\n{\n    public static pair<T, U> make_pair<T, U>(T v1, U v2) => new pair<T, U>(v1, v2);\n    public static T sq<T>(T a) => Operator<T>.Multiply(a, a);\n    public static T Max<T>(params T[] a) => a.Max();\n    public static T Min<T>(params T[] a) => a.Min();\n    public static bool inside(int i, int j, int h, int w) => i >= 0 && i < h && j >= 0 && j < w;\n    public static Dictionary<T, int> compress<T>(this IEnumerable<T> a)\n        => a.Distinct().OrderBy(v => v).Select((v, i) => new { v, i }).ToDictionary(p => p.v, p => p.i);\n    public static Dictionary<T, int> compress<T>(params IEnumerable<T>[] a) => compress(a.Aggregate(Enumerable.Union));\n    public static void swap<T>(ref T a, ref T b) where T : struct { var t = a; a = b; b = t; }\n    public static void swap<T>(this IList<T> a, int i, int j) where T : struct { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a) {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n}\nstatic class Operator<T>\n{\n    static readonly ParameterExpression x = Expression.Parameter(typeof(T), \"x\");\n    static readonly ParameterExpression y = Expression.Parameter(typeof(T), \"y\");\n    public static readonly Func<T, T, T> Add = Lambda(Expression.Add);\n    public static readonly Func<T, T, T> Subtract = Lambda(Expression.Subtract);\n    public static readonly Func<T, T, T> Multiply = Lambda(Expression.Multiply);\n    public static readonly Func<T, T, T> Divide = Lambda(Expression.Divide);\n    public static readonly Func<T, T> Plus = Lambda(Expression.UnaryPlus);\n    public static readonly Func<T, T> Negate = Lambda(Expression.Negate);\n    public static Func<T, T, T> Lambda(Binary op) => Expression.Lambda<Func<T, T, T>>(op(x, y), x, y).Compile();\n    public static Func<T, T> Lambda(Unary op) => Expression.Lambda<Func<T, T>>(op(x), x).Compile();\n}\n\nclass Scan\n{\n    public int Int => int.Parse(Str);\n    public long Long => long.Parse(Str);\n    public double Double => double.Parse(Str);\n    public string Str => Console.ReadLine().Trim();\n    public pair<T, U> Pair<T, U>() {\n        T a; U b;\n        Multi(out a, out b);\n        return new pair<T, U>(a, b);\n    }\n    public P P {\n        get {\n            int a, b;\n            Multi(out a, out b);\n            return new P(a, b);\n        }\n    }\n    public int[] IntArr => StrArr.Select(int.Parse).ToArray();\n    public long[] LongArr => StrArr.Select(long.Parse).ToArray();\n    public double[] DoubleArr => StrArr.Select(double.Parse).ToArray();\n    public string[] StrArr => Str.Split(new[]{' '}, StringSplitOptions.RemoveEmptyEntries);\n    bool eq<T, U>() => typeof(T).Equals(typeof(U));\n    T ct<T, U>(U a) => (T)Convert.ChangeType(a, typeof(T));\n    T cv<T>(string s) => eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                       : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                       : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                       : eq<T, char>()   ? ct<T, char>(s[0])\n                                         : ct<T, string>(s);\n    public void Multi<T>(out T a) => a = cv<T>(Str);\n    public void Multi<T, U>(out T a, out U b)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); }\n    public void Multi<T, U, V>(out T a, out U b, out V c)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); }\n    public void Multi<T, U, V, W, X, Y>(out T a, out U b, out V c, out W d, out X e, out Y f)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); f = cv<Y>(ar[5]); }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.IO;\nusing System.Text;\n\nusing static util;\nusing P = pair<int, int>;\n\nusing Binary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.ParameterExpression,\n                           System.Linq.Expressions.BinaryExpression>;\nusing Unary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.UnaryExpression>;\n\nclass Program\n{\n    static StreamWriter sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n    static Scan sc = new Scan();\n    const int M = 1000000007;\n    const int M2 = 998244353;\n    const long LM = (long)1e18;\n    const double eps = 1e-11;\n    static readonly int[] dd = { 0, 1, 0, -1, 0 };\n    const string dstring = \"RDLU\";\n    static void Main()\n    {\n        int n = sc.Int;\n        a = sc.LongArr;\n        edge = new List<int>[n];\n        for (int i = 0; i < n; i++)\n        {\n            edge[i] = new List<int>();\n        }\n        for (int i = 0; i < n - 1; i++)\n        {\n            int u, v;\n            sc.Multi(out u, out v);\n            --u;\n            --v;\n            edge[u].Add(v);\n            edge[v].Add(u);\n        }\n        var r = new Random();\n        var b = dfs(r.Next(n), -1);\n        for (int i = 0; i < n; i++)\n        {\n            if (b[i][0] < LM2 || b[i][1] < 0) {\n                DBG(i);\n                return;\n            }\n        }\n        sw.Flush();\n    }\n    static long[] a;\n    static List<int>[] edge;\n    static long LM2 = (long)1e16;\n\n    static long[][] dfs(int p, int par) {\n        var dp = new long[1][];\n        for (int i = 0; i < 1; i++)\n        {\n            dp[i] = new long[2];\n            dp[i][0] = LM;\n            dp[i][1] = LM;\n        }\n        dp[0][1] = a[p];\n        if (a[p] > 0) {\n            dp[0][0] = a[p];\n        }\n        foreach (var item in edge[p])\n        {\n            if (item == par) continue;\n            var b = dfs(item, p);\n            var nex = new long[dp.Length + b.Length][];\n            for (int i = 0; i < nex.Length; i++)\n            {\n                nex[i] = new long[2];\n                nex[i][0] = LM;\n                nex[i][1] = LM;\n            }\n            for (int i = 0; i < dp.Length; i++)\n            {\n                if (dp[i][0] > LM2 && dp[i][1] > LM2) continue;\n                for (int j = 0; j < b.Length; j++)\n                {\n                    nex[i + j][0] = Math.Min(nex[i + j][0], dp[i][0] + b[j][0]);\n                    nex[i + j][1] = Math.Min(nex[i + j][1], dp[i][1] + b[j][1]);\n                    if (b[j][0] < LM2 || b[j][1] < 0) {\n                        nex[i + j + 1][0] = Math.Min(nex[i + j + 1][0], dp[i][0]);\n                        nex[i + j + 1][1] = Math.Min(nex[i + j + 1][1], dp[i][1]);\n                    }\n                }\n            }\n            dp = nex;\n        }\n        return dp;\n    }\n\n    static void DBG(string a) => Console.WriteLine(a);\n    static void DBG<T>(IEnumerable<T> a) => DBG(string.Join(\" \", a));\n    static void DBG(params object[] a) => DBG(string.Join(\" \", a));\n    static void Prt(string a) => sw.WriteLine(a);\n    static void Prt<T>(IEnumerable<T> a) => Prt(string.Join(\" \", a));\n    static void Prt(params object[] a) => Prt(string.Join(\" \", a));\n}\nclass pair<T, U> : IComparable<pair<T, U>>\n{\n    public T v1;\n    public U v2;\n    public pair(T v1, U v2) {\n        this.v1 = v1;\n        this.v2 = v2;\n    }\n    public int CompareTo(pair<T, U> a) {\n        int c = Comparer<T>.Default.Compare(v1, a.v1);\n        return c != 0 ? c : Comparer<U>.Default.Compare(v2, a.v2);\n    }\n    public override string ToString() => v1 + \" \" + v2;\n    public void Deconstruct(out T a, out U b) {\n        a = v1; b = v2;\n    }\n    public static bool operator>(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) > 0;\n    public static bool operator<(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) < 0;\n    public static bool operator>=(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) >= 0;\n    public static bool operator<=(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) <= 0;\n}\nstatic class util\n{\n    public static pair<T, U> make_pair<T, U>(T v1, U v2) => new pair<T, U>(v1, v2);\n    public static T sq<T>(T a) => Operator<T>.Multiply(a, a);\n    public static T Max<T>(params T[] a) => a.Max();\n    public static T Min<T>(params T[] a) => a.Min();\n    public static bool inside(int i, int j, int h, int w) => i >= 0 && i < h && j >= 0 && j < w;\n    public static Dictionary<T, int> compress<T>(this IEnumerable<T> a)\n        => a.Distinct().OrderBy(v => v).Select((v, i) => new { v, i }).ToDictionary(p => p.v, p => p.i);\n    public static Dictionary<T, int> compress<T>(params IEnumerable<T>[] a) => compress(a.Aggregate(Enumerable.Union));\n    public static void swap<T>(ref T a, ref T b) where T : struct { var t = a; a = b; b = t; }\n    public static void swap<T>(this IList<T> a, int i, int j) where T : struct { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a) {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n}\nstatic class Operator<T>\n{\n    static readonly ParameterExpression x = Expression.Parameter(typeof(T), \"x\");\n    static readonly ParameterExpression y = Expression.Parameter(typeof(T), \"y\");\n    public static readonly Func<T, T, T> Add = Lambda(Expression.Add);\n    public static readonly Func<T, T, T> Subtract = Lambda(Expression.Subtract);\n    public static readonly Func<T, T, T> Multiply = Lambda(Expression.Multiply);\n    public static readonly Func<T, T, T> Divide = Lambda(Expression.Divide);\n    public static readonly Func<T, T> Plus = Lambda(Expression.UnaryPlus);\n    public static readonly Func<T, T> Negate = Lambda(Expression.Negate);\n    public static Func<T, T, T> Lambda(Binary op) => Expression.Lambda<Func<T, T, T>>(op(x, y), x, y).Compile();\n    public static Func<T, T> Lambda(Unary op) => Expression.Lambda<Func<T, T>>(op(x), x).Compile();\n}\n\nclass Scan\n{\n    public int Int => int.Parse(Str);\n    public long Long => long.Parse(Str);\n    public double Double => double.Parse(Str);\n    public string Str => Console.ReadLine().Trim();\n    public pair<T, U> Pair<T, U>() {\n        T a; U b;\n        Multi(out a, out b);\n        return new pair<T, U>(a, b);\n    }\n    public P P {\n        get {\n            int a, b;\n            Multi(out a, out b);\n            return new P(a, b);\n        }\n    }\n    public int[] IntArr => StrArr.Select(int.Parse).ToArray();\n    public long[] LongArr => StrArr.Select(long.Parse).ToArray();\n    public double[] DoubleArr => StrArr.Select(double.Parse).ToArray();\n    public string[] StrArr => Str.Split(new[]{' '}, StringSplitOptions.RemoveEmptyEntries);\n    bool eq<T, U>() => typeof(T).Equals(typeof(U));\n    T ct<T, U>(U a) => (T)Convert.ChangeType(a, typeof(T));\n    T cv<T>(string s) => eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                       : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                       : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                       : eq<T, char>()   ? ct<T, char>(s[0])\n                                         : ct<T, string>(s);\n    public void Multi<T>(out T a) => a = cv<T>(Str);\n    public void Multi<T, U>(out T a, out U b)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); }\n    public void Multi<T, U, V>(out T a, out U b, out V c)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); }\n    public void Multi<T, U, V, W, X, Y>(out T a, out U b, out V c, out W d, out X e, out Y f)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); f = cv<Y>(ar[5]); }\n}\n"
  },
  {
    "language": "C#",
    "code": "#region いつもの\nusing AtCoderProject;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing static AtCoderProject.Global;\nusing BigInteger = System.Numerics.BigInteger;\nusing BitOperations = System.Numerics.BitOperations;\nusing IEnumerable = System.Collections.IEnumerable;\nusing IEnumerator = System.Collections.IEnumerator;\nusing StringBuilder = System.Text.StringBuilder;\nusing Unsafe = System.Runtime.CompilerServices.Unsafe;\n\nnamespace AtCoderProject { using System.IO; using System.Text; using System.Diagnostics; using System.Runtime.CompilerServices; using System.Linq.Expressions; public static class Global { public static T[] NewArray<T>(int len0, T value) => new T[len0].Fill(value); public static T[] NewArray<T>(int len0, Func<T> factory) { var arr = new T[len0]; for (int i = 0; i < arr.Length; i++) arr[i] = factory(); return arr; } public static T[][] NewArray<T>(int len0, int len1, T value) where T : struct { var arr = new T[len0][]; for (int i = 0; i < arr.Length; i++) arr[i] = NewArray(len1, value); return arr; } public static T[][] NewArray<T>(int len0, int len1, Func<T> factory) { var arr = new T[len0][]; for (int i = 0; i < arr.Length; i++) arr[i] = NewArray(len1, factory); return arr; } public static T[][][] NewArray<T>(int len0, int len1, int len2, T value) where T : struct { var arr = new T[len0][][]; for (int i = 0; i < arr.Length; i++) arr[i] = NewArray(len1, len2, value); return arr; } public static T[][][] NewArray<T>(int len0, int len1, int len2, Func<T> factory) { var arr = new T[len0][][]; for (int i = 0; i < arr.Length; i++) arr[i] = NewArray(len1, len2, factory); return arr; } public static T[][][][] NewArray<T>(int len0, int len1, int len2, int len3, T value) where T : struct { var arr = new T[len0][][][]; for (int i = 0; i < arr.Length; i++) arr[i] = NewArray(len1, len2, len3, value); return arr; } public static T[][][][] NewArray<T>(int len0, int len1, int len2, int len3, Func<T> factory) { var arr = new T[len0][][][]; for (int i = 0; i < arr.Length; i++) arr[i] = NewArray(len1, len2, len3, factory); return arr; } public static int Pow(int x, int y) { int res = 1; for (; y > 0; y >>= 1) { if ((y & 1) == 1) res *= x; x *= x; } return res; } public static BigInteger ParseBigInteger(ReadOnlySpan<char> s) { /* 自前実装の方が速い */ BigInteger res; if (s.Length % 9 == 0) res = 0; else { res = new BigInteger(int.Parse(s.Slice(0, s.Length % 9))); s = s.Slice(s.Length % 9); } while (s.Length > 0) { var sp = s.Slice(0, 9); res *= 1000_000_000; res += int.Parse(sp); s = s.Slice(9); } return res; } public static int PopCount(int x) => BitOperations.PopCount((uint)x); public static int PopCount(long x) => BitOperations.PopCount((ulong)x); public static int PopCount(ulong x) => BitOperations.PopCount(x); public static int MSB(int x) => BitOperations.Log2((uint)x); public static int MSB(uint x) => BitOperations.Log2(x); public static int MSB(long x) => BitOperations.Log2((ulong)x); public static int MSB(ulong x) => BitOperations.Log2(x); public static int LSB(int x) => BitOperations.TrailingZeroCount((uint)x); public static int LSB(uint x) => BitOperations.TrailingZeroCount(x); public static int LSB(long x) => BitOperations.TrailingZeroCount((ulong)x); public static int LSB(ulong x) => BitOperations.TrailingZeroCount(x); } public static class Ext { public static bool UpdateMax(this ref int r, int val) { if (r < val) { r = val; return true; } return false; } public static bool UpdateMax(this ref long r, long val) { if (r < val) { r = val; return true; } return false; } public static bool UpdateMin(this ref int r, int val) { if (r > val) { r = val; return true; } return false; } public static bool UpdateMin(this ref long r, long val) { if (r > val) { r = val; return true; } return false; } public static long ToLong(this int i) => i; public static T[] Fill<T>(this T[] arr, T value) { Array.Fill(arr, value); return arr; } public static T[] Sort<T>(this T[] arr) { Array.Sort(arr); return arr; } public static string[] Sort(this string[] arr) => Sort(arr, StringComparer.OrdinalIgnoreCase); public static T[] Sort<T, U>(this T[] arr, Expression<Func<T, U>> selector) where U : IComparable<U> => Sort(arr, new ExpComparer<T, U>(selector)); public static T[] Sort<T>(this T[] arr, Comparison<T> comparison) { Array.Sort(arr, comparison); return arr; } public static T[] Sort<T>(this T[] arr, IComparer<T> comparer) { Array.Sort(arr, comparer); return arr; } public static T[] Reverse<T>(this T[] arr) { Array.Reverse(arr); return arr; } public static (int index, T max) MaxBy<T>(this T[] arr) where T : IComparable<T> { T max = arr[0]; int maxIndex = 0; for (int i = 0; i < arr.Length; i++) { if (max.CompareTo(arr[i]) < 0) { max = arr[i]; maxIndex = i; } } return (maxIndex, max); } public static (TSource item, TMax max) MaxBy<TSource, TMax>(this IEnumerable<TSource> source, Func<TSource, TMax> maxBySelector) where TMax : IComparable<TMax> { TMax max; TSource maxByItem; var e = source.GetEnumerator(); e.MoveNext(); maxByItem = e.Current; max = maxBySelector(maxByItem); while (e.MoveNext()) { var item = e.Current; var next = maxBySelector(item); if (max.CompareTo(next) < 0) { max = next; maxByItem = item; } } return (maxByItem, max); } public static (int index, T min) MinBy<T>(this T[] arr) where T : IComparable<T> { T min = arr[0]; int minIndex = 0; for (int i = 0; i < arr.Length; i++) { if (min.CompareTo(arr[i]) > 0) { min = arr[i]; minIndex = i; } } return (minIndex, min); } public static (TSource item, TMin min) MinBy<TSource, TMin>(this IEnumerable<TSource> source, Func<TSource, TMin> minBySelector) where TMin : IComparable<TMin> { TMin min; TSource minByItem; var e = source.GetEnumerator(); e.MoveNext(); minByItem = e.Current; min = minBySelector(minByItem); while (e.MoveNext()) { var item = e.Current; var next = minBySelector(item); if (min.CompareTo(next) > 0) { min = next; minByItem = item; } } return (minByItem, min); } public static IComparer<T> Reverse<T>(this IComparer<T> comparer) => Comparer<T>.Create((x, y) => comparer.Compare(y, x)); public static Dictionary<TKey, int> GroupCount<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector) => source.GroupBy(keySelector).ToDictionary(g => g.Key, g => g.Count()); public static Dictionary<TKey, int> GroupCount<TKey>(this IEnumerable<TKey> source) => source.GroupCount(i => i); public static ref T Get<T>(this T[] arr, int index) { if (index < 0) return ref arr[arr.Length + index]; return ref arr[index]; } public static TValue Get<TKey, TValue>(this IDictionary<TKey, TValue> dic, TKey key) { dic.TryGetValue(key, out var v); return v; } public static TValue GetOrInit<TKey, TValue>(this IDictionary<TKey, TValue> dic, TKey key, TValue value) { if (dic.TryGetValue(key, out var v)) return v; return dic[key] = value; } } public class ExpComparer<T, K> : IComparer<T> where K : IComparable<K> { private class ParameterReplaceVisitor : ExpressionVisitor { private readonly ParameterExpression from; private readonly ParameterExpression to; public ParameterReplaceVisitor(ParameterExpression from, ParameterExpression to) { this.from = from; this.to = to; } protected override Expression VisitParameter(ParameterExpression node) => node == from ? to : base.VisitParameter(node); } private readonly Func<T, T, int> func; public ExpComparer(Expression<Func<T, K>> expression) { var paramA = expression.Parameters[0]; var paramB = Expression.Parameter(typeof(T)); var f2 = (Expression<Func<T, K>>)new ParameterReplaceVisitor(expression.Parameters[0], paramB).Visit(expression); var compExp = Expression.Lambda<Func<T, T, int>>(Expression.Call(expression.Body, typeof(K).GetMethod(nameof(IComparable<K>.CompareTo), new[] { typeof(K) }), f2.Body), paramA, paramB); this.func = compExp.Compile(); } public int Compare(T x, T y) => func(x, y); public override bool Equals(object obj) => obj != null && GetType() == obj.GetType(); public override int GetHashCode() => GetType().GetHashCode(); } public class ReverseComparer<T> : IComparer<T> where T : IComparable<T> { private static ReverseComparer<T> defaultComparer; public static IComparer<T> Default => defaultComparer ??= new ReverseComparer<T>(); public int Compare(T y, T x) => x.CompareTo(y); public override bool Equals(object obj) => obj != null && GetType() == obj.GetType(); public override int GetHashCode() => GetType().GetHashCode(); } public class ΔDebugView<T> { private IEnumerable<T> collection; public ΔDebugView(IEnumerable<T> collection) { this.collection = collection ?? throw new ArgumentNullException(nameof(collection)); }[DebuggerBrowsable(DebuggerBrowsableState.RootHidden)] public T[] Items => collection.ToArray(); }[DebuggerStepThrough] public class ConsoleReader { const int BufSize = 1 << 12; private readonly byte[] buffer = new byte[BufSize]; private readonly Stream input; private readonly Encoding encoding; private int pos = 0; private int len = 0; public ConsoleReader(Stream input, Encoding encoding) { this.input = input; this.encoding = encoding; } public ConsoleReader(Stream input) : this(input, Console.InputEncoding) { } private void MoveNext() { if (++pos >= len) { len = input.Read(buffer, 0, buffer.Length); if (len == 0) { buffer[0] = 10; } pos = 0; } } public int Int { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { int res = 0; bool neg = false; while (buffer[pos] < 48) { neg = buffer[pos] == 45; MoveNext(); } do { res = checked(res * 10 + (buffer[pos] ^ 48)); MoveNext(); } while (48 <= buffer[pos]); return neg ? -res : res; } } public int Int0 => this.Int - 1; public long Long { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { long res = 0; bool neg = false; while (buffer[pos] < 48) { neg = buffer[pos] == 45; MoveNext(); } do { res = res * 10 + (buffer[pos] ^ 48); MoveNext(); } while (48 <= buffer[pos]); return neg ? -res : res; } } public long Long0 => this.Long - 1; public string String { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { var sb = new List<byte>(); while (buffer[pos] <= 32) MoveNext(); do { sb.Add(buffer[pos]); MoveNext(); } while (32 < buffer[pos]); return this.encoding.GetString(sb.ToArray()); } } public string Ascii { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { var sb = new StringBuilder(); while (buffer[pos] <= 32) MoveNext(); do { sb.Append((char)buffer[pos]); MoveNext(); } while (32 < buffer[pos]); return sb.ToString(); } } public string Line { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { var sb = new List<byte>(); while (buffer[pos] <= 32) MoveNext(); do { sb.Add(buffer[pos]); MoveNext(); } while (buffer[pos] != 10 && buffer[pos] != 13); return this.encoding.GetString(sb.ToArray()); } } public char Char { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { while (buffer[pos] <= 32) MoveNext(); char res = (char)buffer[pos]; MoveNext(); return res; } } public double Double => double.Parse(this.Ascii);[DebuggerStepThrough] public struct RepeatReader { ConsoleReader cr; int count; public RepeatReader(ConsoleReader cr, int count) { this.cr = cr; this.count = count; } public T[] Select<T>(Func<ConsoleReader, T> factory) { var arr = new T[count]; for (var i = 0; i < count; i++) arr[i] = factory(cr); return arr; } public T[] Select<T>(Func<ConsoleReader, int, T> factory) { var arr = new T[count]; for (var i = 0; i < count; i++) arr[i] = factory(cr, i); return arr; } public string[] Line { get { var arr = new string[count]; for (var i = 0; i < count; i++) arr[i] = cr.Line; return arr; } } public string[] String { get { var arr = new string[count]; for (var i = 0; i < count; i++) arr[i] = cr.String; return arr; } } public string[] Ascii { get { var arr = new string[count]; for (var i = 0; i < count; i++) arr[i] = cr.Ascii; return arr; } } public int[] Int { get { var arr = new int[count]; for (var i = 0; i < count; i++) arr[i] = cr.Int; return arr; } } public int[] Int0 { get { var arr = new int[count]; for (var i = 0; i < count; i++) arr[i] = cr.Int0; return arr; } } public long[] Long { get { var arr = new long[count]; for (var i = 0; i < count; i++) arr[i] = cr.Long; return arr; } } public long[] Long0 { get { var arr = new long[count]; for (var i = 0; i < count; i++) arr[i] = cr.Long0; return arr; } } public double[] Double { get { var arr = new double[count]; for (var i = 0; i < count; i++) arr[i] = cr.Double; return arr; } } public static implicit operator int[](RepeatReader rr) => rr.Int; public static implicit operator long[](RepeatReader rr) => rr.Long; public static implicit operator double[](RepeatReader rr) => rr.Double; public static implicit operator string[](RepeatReader rr) => rr.Ascii; } public RepeatReader Repeat(int count) => new RepeatReader(this, count);[DebuggerStepThrough] public struct SplitReader { ConsoleReader cr; public SplitReader(ConsoleReader cr) { this.cr = cr; } public string[] String { get { while (cr.buffer[cr.pos] <= 32) cr.MoveNext(); var list = new List<string>(); do { if (cr.buffer[cr.pos] < 32) cr.MoveNext(); else list.Add(cr.String); } while (cr.buffer[cr.pos] != 10 && cr.buffer[cr.pos] != 13); return list.ToArray(); } } public string[] Ascii { get { while (cr.buffer[cr.pos] <= 32) cr.MoveNext(); var list = new List<string>(); do { if (cr.buffer[cr.pos] < 32) cr.MoveNext(); else list.Add(cr.Ascii); } while (cr.buffer[cr.pos] != 10 && cr.buffer[cr.pos] != 13); return list.ToArray(); } } public int[] Int { get { while (cr.buffer[cr.pos] <= 32) cr.MoveNext(); var list = new List<int>(); do { if (cr.buffer[cr.pos] < 32) cr.MoveNext(); else list.Add(cr.Int); } while (cr.buffer[cr.pos] != 10 && cr.buffer[cr.pos] != 13); return list.ToArray(); } } public int[] Int0 { get { while (cr.buffer[cr.pos] <= 32) cr.MoveNext(); var list = new List<int>(); do { if (cr.buffer[cr.pos] < 32) cr.MoveNext(); else list.Add(cr.Int0); } while (cr.buffer[cr.pos] != 10 && cr.buffer[cr.pos] != 13); return list.ToArray(); } } public long[] Long { get { while (cr.buffer[cr.pos] <= 32) cr.MoveNext(); var list = new List<long>(); do { if (cr.buffer[cr.pos] < 32) cr.MoveNext(); else list.Add(cr.Long); } while (cr.buffer[cr.pos] != 10 && cr.buffer[cr.pos] != 13); return list.ToArray(); } } public long[] Long0 { get { while (cr.buffer[cr.pos] <= 32) cr.MoveNext(); var list = new List<long>(); do { if (cr.buffer[cr.pos] < 32) cr.MoveNext(); else list.Add(cr.Long0); } while (cr.buffer[cr.pos] != 10 && cr.buffer[cr.pos] != 13); return list.ToArray(); } } public double[] Double { get { while (cr.buffer[cr.pos] <= 32) cr.MoveNext(); var list = new List<double>(); do { if (cr.buffer[cr.pos] < 32) cr.MoveNext(); else list.Add(cr.Double); } while (cr.buffer[cr.pos] != 10 && cr.buffer[cr.pos] != 13); return list.ToArray(); } } public static implicit operator int[](SplitReader sr) => sr.Int; public static implicit operator long[](SplitReader sr) => sr.Long; public static implicit operator double[](SplitReader sr) => sr.Double; public static implicit operator string[](SplitReader sr) => sr.Ascii; } public SplitReader Split => new SplitReader(this); public static implicit operator int(ConsoleReader cr) => cr.Int; public static implicit operator long(ConsoleReader cr) => cr.Long; public static implicit operator double(ConsoleReader cr) => cr.Double; public static implicit operator string(ConsoleReader cr) => cr.Ascii; public void Deconstruct(out ConsoleReader o1, out ConsoleReader o2) => (o1, o2) = (this, this); public void Deconstruct(out ConsoleReader o1, out ConsoleReader o2, out ConsoleReader o3) => (o1, o2, o3) = (this, this, this); public void Deconstruct(out ConsoleReader o1, out ConsoleReader o2, out ConsoleReader o3, out ConsoleReader o4) => (o1, o2, o3, o4) = (this, this, this, this); public void Deconstruct(out ConsoleReader o1, out ConsoleReader o2, out ConsoleReader o3, out ConsoleReader o4, out ConsoleReader o5) => (o1, o2, o3, o4, o5) = (this, this, this, this, this); public void Deconstruct(out ConsoleReader o1, out ConsoleReader o2, out ConsoleReader o3, out ConsoleReader o4, out ConsoleReader o5, out ConsoleReader o6) => (o1, o2, o3, o4, o5, o6) = (this, this, this, this, this, this); public void Deconstruct(out ConsoleReader o1, out ConsoleReader o2, out ConsoleReader o3, out ConsoleReader o4, out ConsoleReader o5, out ConsoleReader o6, out ConsoleReader o7) => (o1, o2, o3, o4, o5, o6, o7) = (this, this, this, this, this, this, this); public void Deconstruct(out ConsoleReader o1, out ConsoleReader o2, out ConsoleReader o3, out ConsoleReader o4, out ConsoleReader o5, out ConsoleReader o6, out ConsoleReader o7, out ConsoleReader o8) => (o1, o2, o3, o4, o5, o6, o7, o8) = (this, this, this, this, this, this, this, this); }[DebuggerStepThrough] public class ConsoleWriter {[DebuggerBrowsable(DebuggerBrowsableState.Never)] public readonly StreamWriter sw; public ConsoleWriter(Stream output) : this(output, Console.OutputEncoding) { } public ConsoleWriter(Stream output, Encoding encoding) { sw = new StreamWriter(output, encoding); } public void Flush() => sw.Flush(); public ConsoleWriter WriteLine(ReadOnlySpan<char> obj) { sw.WriteLine(obj); return this; } public ConsoleWriter WriteLine<T>(T obj) { sw.WriteLine(obj.ToString()); return this; } public ConsoleWriter WriteLineJoin<T>(ReadOnlySpan<T> col) => WriteMany(' ', col); public ConsoleWriter WriteLineJoin<T>(IEnumerable<T> col) => WriteMany(' ', col); public ConsoleWriter WriteLines<T>(ReadOnlySpan<T> col) => WriteMany('\\n', col); public ConsoleWriter WriteLines<T>(IEnumerable<T> col) => WriteMany('\\n', col); public ConsoleWriter WriteLineGrid<T>(IEnumerable<IEnumerable<T>> cols) { var en = cols.GetEnumerator(); while (en.MoveNext()) WriteLineJoin(en.Current); return this; } private ConsoleWriter WriteMany<T>(char sep, ReadOnlySpan<T> col) { var en = col.GetEnumerator(); if (!en.MoveNext()) return this; sw.Write(en.Current.ToString()); while (en.MoveNext()) { sw.Write(sep); sw.Write(en.Current.ToString()); } sw.WriteLine(); return this; } private ConsoleWriter WriteMany<T>(char sep, IEnumerable<T> col) { var en = col.GetEnumerator(); if (!en.MoveNext()) return this; sw.Write(en.Current.ToString()); while (en.MoveNext()) { sw.Write(sep); sw.Write(en.Current.ToString()); } sw.WriteLine(); return this; } } }\npublic partial class Program {[System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)] public ConsoleReader cr;[System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)] public ConsoleWriter cw; public Program(ConsoleReader reader, ConsoleWriter writer) { this.cr = reader; this.cw = writer; System.Globalization.CultureInfo.CurrentCulture = System.Globalization.CultureInfo.InvariantCulture; } static void Main() => new Program(new ConsoleReader(Console.OpenStandardInput()), new ConsoleWriter(Console.OpenStandardOutput())).Run(); public void Run() { var res = Calc(); if (res is double) cw.WriteLine(Result((double)res)); else if (res is bool) cw.WriteLine(Result((bool)res)); else if (res != null) cw.WriteLine(res.ToString()); cw.Flush(); } }\npublic partial class Program\n{\n    public static string Result(double d) => d.ToString(\"0.####################\", System.Globalization.CultureInfo.InvariantCulture);\n    #endregion\n    public static string Result(bool b) => b ? \"Yes\" : \"No\";\n    private object Calc()\n    {\n        N = cr;\n        A = cr.Repeat(N);\n        dp1 = new long[N][];\n        dp2 = new long[N][];\n        tree = new GraphBuilder(N, cr, N - 1, false).ToTree(0);\n        size = new int[N];\n        Calc(0);\n        for (int i = 0; i < dp1[0].Length; i++)\n            if (dp1[0][i] < INF / 2 || dp2[0][i] < 0)\n                return i;\n        return null;\n    }\n    void Calc(int v)\n    {\n        var s = 1;\n        var dpp1 = new[] { A[v] };\n        if (A[v] < 0) dpp1[0] = INF;\n        var dpp2 = new[] { A[v] };\n        foreach (var ch in tree[v].children)\n        {\n            Calc(ch);\n            s += Size(ch);\n            var nx1 = NewArray(s, INF);\n            var nx2 = NewArray(s, INF);\n            for (int k1 = 0; k1 < dpp1.Length; k1++)\n                for (int k2 = 0; k2 < dp1[ch].Length; k2++)\n                {\n                    if (dp1[ch][k2] < INF / 2 || dp2[ch][k2] < 0) nx1[k1 + k2 + 1].UpdateMin(dpp1[k1]);\n                    if (dp1[ch][k2] < INF / 2 || dp2[ch][k2] < 0) nx2[k1 + k2 + 1].UpdateMin(dpp2[k1]);\n                    nx1[k1 + k2].UpdateMin(dpp1[k1] + dp1[ch][k2]);\n                    nx2[k1 + k2].UpdateMin(dpp2[k1] + dp2[ch][k2]);\n                }\n\n            dpp1 = nx1; dpp2 = nx2;\n        }\n        dp1[v] = dpp1;\n        dp2[v] = dpp2;\n    }\n    const long INF = 1L << 48;\n    int Size(int v)\n    {\n        if (size[v] > 0) return size[v];\n        size[v] = 1;\n        foreach (var ch in tree[v].children) size[v] += Size(ch);\n        return size[v];\n    }\n    int N;\n    long[] A;\n    int[] size;\n    long[][] dp1;\n    long[][] dp2;\n    TreeNode[] tree;\n}\n\nclass GraphBuilder { private List<int>[] roots; private List<int>[] children; public GraphBuilder(int count, bool isOriented) { this.roots = new List<int>[count]; this.children = new List<int>[count]; for (var i = 0; i < count; i++) { if (isOriented) { this.roots[i] = new List<int>(); this.children[i] = new List<int>(); } else { this.roots[i] = this.children[i] = new List<int>(); } } } public GraphBuilder(int count, ConsoleReader cr, int edgeCount, bool isOriented) : this(count, isOriented) { for (var i = 0; i < edgeCount; i++) this.Add(cr.Int0, cr.Int0); } public void Add(int from, int to) { children[from].Add(to); roots[to].Add(from); } public TreeNode[] ToTree(int root) { if (this.roots[0] != this.children[0]) throw new Exception(\"木には無向グラフをしたほうが良い\"); var res = new TreeNode[this.children.Length]; res[root] = new TreeNode(root, -1, 0, this.children[root].ToArray()); var queue = new Queue<int>(); foreach (var child in res[root].children) { res[child] = new TreeNode(child, root, 1, Array.Empty<int>()); queue.Enqueue(child); } while (queue.Count > 0) { var from = queue.Dequeue(); if (res[from].root == -1) res[from].children = this.children[from].ToArray(); else { var children = new List<int>(this.children[from].Count); foreach (var c in this.children[from]) if (c != res[from].root) children.Add(c); res[from].children = children.ToArray(); } foreach (var child in res[from].children) { res[child] = new TreeNode(child, from, res[from].depth + 1, Array.Empty<int>()); queue.Enqueue(child); } } return res; } public Node[] ToArray() => Enumerable.Zip(roots, children, (root, child) => (root, child)).Select((t, i) => new Node(i, t.root.ToArray(), t.child.ToArray())).ToArray(); public GraphBuilder Clone() { var count = this.roots.Length; var isOriented = this.roots[0] != this.children[0]; var cl = new GraphBuilder(count, isOriented); for (int i = 0; i < count; i++) { if (isOriented) { cl.children[i] = this.children[i].ToList(); cl.roots[i] = this.roots[i].ToList(); } else cl.children[i] = cl.roots[i] = this.roots[i].ToList(); } return cl; } }\nclass TreeNode { public TreeNode(int i, int root, int depth, int[] children) { this.index = i; this.root = root; this.children = children; this.depth = depth; } public readonly int index; public readonly int root; public readonly int depth; public int[] children; public override string ToString() => $\"children: {string.Join(\",\", children)}\"; public override bool Equals(object obj) { if (obj is TreeNode) return this.Equals((TreeNode)obj); else return false; } public bool Equals(TreeNode other) => this.index == other.index; public override int GetHashCode() => this.index; }\nclass Node { public Node(int i, int[] roots, int[] children) { this.index = i; this.roots = roots; this.children = children; } public readonly int index; public readonly int[] roots; public readonly int[] children; public override string ToString() => $\"children: {string.Join(\",\", children)}\"; public override bool Equals(object obj) { if (obj is Node) return this.Equals((Node)obj); else return false; } public bool Equals(Node other) => this.index == other.index; public override int GetHashCode() => this.index; }\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.IO;\nusing System.Text;\n\nusing static util;\nusing P = pair<int, int>;\n\nusing Binary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.ParameterExpression,\n                           System.Linq.Expressions.BinaryExpression>;\nusing Unary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.UnaryExpression>;\n\nclass Program\n{\n    static StreamWriter sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n    static Scan sc = new Scan();\n    const int M = 1000000007;\n    const int M2 = 998244353;\n    const long LM = (long)1e18;\n    const double eps = 1e-11;\n    static readonly int[] dd = { 0, 1, 0, -1, 0 };\n    const string dstring = \"RDLU\";\n    static void Main()\n    {\n        n = sc.Int;\n        a = sc.LongArr;\n        edge = new List<int>[n];\n        memo = new long[n][][];\n        max = new int[n];\n        for (int i = 0; i < n; i++)\n        {\n            edge[i] = new List<int>();\n        }\n        for (int i = 0; i < n - 1; i++)\n        {\n            int u, v;\n            sc.Multi(out u, out v);\n            --u;\n            --v;\n            edge[u].Add(v);\n            edge[v].Add(u);\n        }\n        var b = dfs(0, -1);\n        for (int i = 0; i < n; i++)\n        {\n            if (b[i][0] < LM / 100 || b[i][1] < 0) {\n                DBG(i);\n                return;\n            }\n        }\n        sw.Flush();\n    }\n    static int n;\n    static long[] a;\n    static List<int>[] edge;\n    static long[][][] memo;\n    static int[] max;\n\n    static long[][] dfs(int p, int par) {\n        if (memo[p] != null) return memo[p];\n        var dp = new long[n][];\n        for (int i = 0; i < n; i++)\n        {\n            dp[i] = new long[2];\n            dp[i][0] = LM;\n            dp[i][1] = LM;\n        }\n        if (a[p] > 0) {\n            dp[0][0] = a[p];\n        }\n        else {\n            dp[0][1] = a[p];\n        }\n        foreach (var item in edge[p])\n        {\n            if (item == par) continue;\n            var b = dfs(item, p);\n            var nex = new long[n][];\n            for (int i = 0; i < n; i++)\n            {\n                nex[i] = new long[2];\n                nex[i][0] = LM;\n                nex[i][1] = LM;\n            }\n            for (int i = 0; i < n; i++)\n            {\n                if (dp[i][0] > LM / 100 && dp[i][1] > LM / 100) continue;\n                for (int j = 0; j < max[item]; j++)\n                {\n                    if (b[j][0] > LM / 100 && b[j][1] > LM / 100) continue;\n                    nex[i + j][0] = Math.Min(nex[i + j][0], dp[i][0] + b[j][0]);\n                    nex[i + j][1] = Math.Min(nex[i + j][1], dp[i][0] + b[j][1]);\n                    nex[i + j][1] = Math.Min(nex[i + j][1], dp[i][1] + b[j][0]);\n                    nex[i + j][1] = Math.Min(nex[i + j][1], dp[i][1] + b[j][1]);\n                    if (b[j][0] < LM / 100 || b[j][1] < 0) {\n                        nex[i + j + 1][0] = Math.Min(nex[i + j + 1][0], dp[i][0]);\n                        nex[i + j + 1][1] = Math.Min(nex[i + j + 1][1], dp[i][1]);\n                    }\n                }\n            }\n            dp = nex;\n        }\n        for (int i = 0; i < n; i++)\n        {\n            if (dp[i][0] < LM / 100 || dp[i][1] < 0)  {\n                max[p] = i + 1;\n            }\n        }\n        return memo[p] = dp;\n    }\n\n    static void DBG(string a) => Console.WriteLine(a);\n    static void DBG<T>(IEnumerable<T> a) => DBG(string.Join(\" \", a));\n    static void DBG(params object[] a) => DBG(string.Join(\" \", a));\n    static void Prt(string a) => sw.WriteLine(a);\n    static void Prt<T>(IEnumerable<T> a) => Prt(string.Join(\" \", a));\n    static void Prt(params object[] a) => Prt(string.Join(\" \", a));\n}\nclass pair<T, U> : IComparable<pair<T, U>>\n{\n    public T v1;\n    public U v2;\n    public pair(T v1, U v2) {\n        this.v1 = v1;\n        this.v2 = v2;\n    }\n    public int CompareTo(pair<T, U> a) {\n        int c = Comparer<T>.Default.Compare(v1, a.v1);\n        return c != 0 ? c : Comparer<U>.Default.Compare(v2, a.v2);\n    }\n    public override string ToString() => v1 + \" \" + v2;\n    public void Deconstruct(out T a, out U b) {\n        a = v1; b = v2;\n    }\n    public static bool operator>(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) > 0;\n    public static bool operator<(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) < 0;\n    public static bool operator>=(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) >= 0;\n    public static bool operator<=(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) <= 0;\n}\nstatic class util\n{\n    public static pair<T, U> make_pair<T, U>(T v1, U v2) => new pair<T, U>(v1, v2);\n    public static T sq<T>(T a) => Operator<T>.Multiply(a, a);\n    public static T Max<T>(params T[] a) => a.Max();\n    public static T Min<T>(params T[] a) => a.Min();\n    public static bool inside(int i, int j, int h, int w) => i >= 0 && i < h && j >= 0 && j < w;\n    public static Dictionary<T, int> compress<T>(this IEnumerable<T> a)\n        => a.Distinct().OrderBy(v => v).Select((v, i) => new { v, i }).ToDictionary(p => p.v, p => p.i);\n    public static Dictionary<T, int> compress<T>(params IEnumerable<T>[] a) => compress(a.Aggregate(Enumerable.Union));\n    public static void swap<T>(ref T a, ref T b) where T : struct { var t = a; a = b; b = t; }\n    public static void swap<T>(this IList<T> a, int i, int j) where T : struct { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a) {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n}\nstatic class Operator<T>\n{\n    static readonly ParameterExpression x = Expression.Parameter(typeof(T), \"x\");\n    static readonly ParameterExpression y = Expression.Parameter(typeof(T), \"y\");\n    public static readonly Func<T, T, T> Add = Lambda(Expression.Add);\n    public static readonly Func<T, T, T> Subtract = Lambda(Expression.Subtract);\n    public static readonly Func<T, T, T> Multiply = Lambda(Expression.Multiply);\n    public static readonly Func<T, T, T> Divide = Lambda(Expression.Divide);\n    public static readonly Func<T, T> Plus = Lambda(Expression.UnaryPlus);\n    public static readonly Func<T, T> Negate = Lambda(Expression.Negate);\n    public static Func<T, T, T> Lambda(Binary op) => Expression.Lambda<Func<T, T, T>>(op(x, y), x, y).Compile();\n    public static Func<T, T> Lambda(Unary op) => Expression.Lambda<Func<T, T>>(op(x), x).Compile();\n}\n\nclass Scan\n{\n    public int Int => int.Parse(Str);\n    public long Long => long.Parse(Str);\n    public double Double => double.Parse(Str);\n    public string Str => Console.ReadLine().Trim();\n    public pair<T, U> Pair<T, U>() {\n        T a; U b;\n        Multi(out a, out b);\n        return new pair<T, U>(a, b);\n    }\n    public P P {\n        get {\n            int a, b;\n            Multi(out a, out b);\n            return new P(a, b);\n        }\n    }\n    public int[] IntArr => StrArr.Select(int.Parse).ToArray();\n    public long[] LongArr => StrArr.Select(long.Parse).ToArray();\n    public double[] DoubleArr => StrArr.Select(double.Parse).ToArray();\n    public string[] StrArr => Str.Split(new[]{' '}, StringSplitOptions.RemoveEmptyEntries);\n    bool eq<T, U>() => typeof(T).Equals(typeof(U));\n    T ct<T, U>(U a) => (T)Convert.ChangeType(a, typeof(T));\n    T cv<T>(string s) => eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                       : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                       : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                       : eq<T, char>()   ? ct<T, char>(s[0])\n                                         : ct<T, string>(s);\n    public void Multi<T>(out T a) => a = cv<T>(Str);\n    public void Multi<T, U>(out T a, out U b)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); }\n    public void Multi<T, U, V>(out T a, out U b, out V c)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); }\n    public void Multi<T, U, V, W, X, Y>(out T a, out U b, out V c, out W d, out X e, out Y f)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); f = cv<Y>(ar[5]); }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing SB = System.Text.StringBuilder;\n//using System.Threading.Tasks;\n//using System.Text.RegularExpressions;\n//using System.Globalization;\n//using System.Diagnostics;\nusing static System.Console;\nusing System.Numerics;\nusing static System.Math;\nusing pair = Pair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        //SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().solve();\n        Out.Flush();\n    }\n    readonly Scanner cin = new Scanner();\n    readonly int[] dd = { 0, 1, 0, -1, 0 }; //→↓←↑\n    readonly int mod = 1000000007;\n    readonly int dom = 998244353;\n    bool chmax<T>(ref T a, T b) where T : IComparable<T> { if (a.CompareTo(b) < 0) { a = b; return true; } return false; }\n    bool chmin<T>(ref T a, T b) where T : IComparable<T> { if (b.CompareTo(a) < 0) { a = b; return true; } return false; }\n\n    int N;\n    List<int>[] G;\n    long[] A;\n\n    long[,] dp, pd; //vの部分木の最小値、後者はすべて正\n    long[] sdp, spd;\n    int[] num; //vの部分木の頂点数\n\n\n    void dfs(int u, int pa)\n    {\n        num[u] = 1;\n        foreach (var v in G[u])\n        {\n            if (v == pa) continue;\n            dfs(v, u);\n            num[u] += num[v];\n\n        }\n        for (int j = 0; j < num[u]; j++)\n        {\n            sdp[j] = (long)1e14;\n            spd[j] = -1;\n        }\n\n        sdp[0] = A[u];\n        if (A[u] > 0) spd[0] = A[u];\n\n        int curnum = 1; //見たノードの数の和\n        foreach (var v in G[u])\n        {\n            if (v == pa) continue;\n            for (int j = curnum - 1; j >= 0; j--)\n            {\n                var p = sdp[j];\n                var q = spd[j];\n                sdp[j] = (long)1e14;\n                spd[j] = -1;\n                for (int k = 0; k < num[v]; k++)\n                {\n                    chmin(ref sdp[j + k], p + dp[v, k]);\n                    if (dp[v, k] < 0 || pd[v, k] > 0) chmin(ref sdp[j + k + 1], p);\n\n                    if (q > 0)\n                    {\n                        if (pd[v, k] > 0)\n                        {\n                            if (spd[j + k] < 0) spd[j + k] = q + pd[v, k];\n                            else chmin(ref spd[j + k], q + pd[v, k]);\n                        }\n                        if (dp[v, k] < 0 || pd[v, k] > 0)\n                        {\n                            if (spd[j + k + 1] < 0) spd[j + k + 1] = q;\n                            else chmin(ref spd[j + k + 1], q);\n                        }\n                    }\n                }\n            }\n\n            curnum += num[v];\n        }\n\n        for (int j = 0; j < num[u]; j++)\n        {\n            dp[u, j] = sdp[j];\n            pd[u, j] = spd[j];\n        }\n        //Write($\"i={u}: \"); sdp.join();\n        //Write($\"i={u}: \"); spd.join();\n    }\n\n    void solve()\n    {\n        N = cin.nextint;\n        A = cin.scanlong;\n\n        G = Enumerable.Range(0, N).Select(i => new List<int>()).ToArray();\n        for (int i = 0; i < N - 1; i++)\n        {\n            int a = cin.nextint - 1;\n            int b = cin.nextint - 1;\n            G[a].Add(b);\n            G[b].Add(a);\n        }\n\n        pd = new long[N, N];\n        dp = new long[N, N];\n        sdp = new long[N];\n        spd = new long[N];\n        for (int i = 0; i < N; i++)\n        {\n            for (int j = 0; j < N; j++)\n            {\n                dp[i, j] = (long)1e14;\n                pd[i, j] = -1;\n            }\n        }\n        num = new int[N];\n\n        dfs(0, -1);\n\n        for (int i = 0; i < N; i++)\n        {\n            if (dp[0, i] < 0 || pd[0, i] > 0)\n            {\n                WriteLine(i);\n                return;\n            }\n        }\n\n    }\n\n}\n\n\nstatic class Ex\n{\n    public static void join<T>(this IEnumerable<T> values, string sep = \" \") => WriteLine(string.Join(sep, values));\n    public static string concat<T>(this IEnumerable<T> values) => string.Concat(values);\n    public static string reverse(this string s) { var t = s.ToCharArray(); Array.Reverse(t); return t.concat(); }\n\n    public static int lower_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) < 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n    public static int upper_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) <= 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n}\n\nclass Pair<T, U> : IComparable<Pair<T, U>> where T : IComparable<T> where U : IComparable<U>\n{\n    public T f; public U s;\n    public Pair(T f, U s) { this.f = f; this.s = s; }\n    public int CompareTo(Pair<T, U> a) => f.CompareTo(a.f) != 0 ? f.CompareTo(a.f) : s.CompareTo(a.s);\n    public override string ToString() => $\"{f} {s}\";\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    readonly char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] scan => ReadLine().Split();\n    public int[] scanint => Array.ConvertAll(scan, int.Parse);\n    public long[] scanlong => Array.ConvertAll(scan, long.Parse);\n    public double[] scandouble => Array.ConvertAll(scan, double.Parse);\n    public string next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return next;\n        }\n    }\n    public int nextint => int.Parse(next);\n    public long nextlong => long.Parse(next);\n    public double nextdouble => double.Parse(next);\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.IO;\nusing System.Text;\n\nusing static util;\nusing P = pair<int, int>;\n\nusing Binary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.ParameterExpression,\n                           System.Linq.Expressions.BinaryExpression>;\nusing Unary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.UnaryExpression>;\n\nclass Program\n{\n    static StreamWriter sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n    static Scan sc = new Scan();\n    const int M = 1000000007;\n    const int M2 = 998244353;\n    const long LM = (long)1e18;\n    const double eps = 1e-11;\n    static readonly int[] dd = { 0, 1, 0, -1, 0 };\n    const string dstring = \"RDLU\";\n    static void Main()\n    {\n        int n = sc.Int;\n        a = sc.LongArr;\n        edge = new List<int>[n];\n        for (int i = 0; i < n; i++)\n        {\n            edge[i] = new List<int>();\n        }\n        for (int i = 0; i < n - 1; i++)\n        {\n            int u, v;\n            sc.Multi(out u, out v);\n            --u;\n            --v;\n            edge[u].Add(v);\n            edge[v].Add(u);\n        }\n        var r = new Random();\n        var b = dfs(r.Next(n), -1);\n        for (int i = 0; i < n; i++)\n        {\n            if (b[i][0] < LM / 2 || b[i][1] < 0) {\n                DBG(i);\n                return;\n            }\n        }\n        sw.Flush();\n    }\n    static long[] a;\n    static List<int>[] edge;\n\n    static long[][] dfs(int p, int par) {\n        var dp = new long[1][];\n        for (int i = 0; i < 1; i++)\n        {\n            dp[i] = new long[2];\n            dp[i][0] = LM;\n            dp[i][1] = LM;\n        }\n        dp[0][1] = a[p];\n        if (a[p] > 0) {\n            dp[0][0] = a[p];\n        }\n        foreach (var item in edge[p])\n        {\n            if (item == par) continue;\n            var b = dfs(item, p);\n            var nex = new long[dp.Length + b.Length][];\n            for (int i = 0; i < nex.Length; i++)\n            {\n                nex[i] = new long[2];\n                nex[i][0] = LM;\n                nex[i][1] = LM;\n            }\n            for (int i = 0; i < dp.Length; i++)\n            {\n                for (int j = 0; j < b.Length; j++)\n                {\n                    nex[i + j][0] = Math.Min(nex[i + j][0], dp[i][0] + b[j][0]);\n                    nex[i + j][1] = Math.Min(nex[i + j][1], dp[i][1] + b[j][1]);\n                    if (b[j][0] < LM / 2 || b[j][1] < 0) {\n                        nex[i + j + 1][0] = Math.Min(nex[i + j + 1][0], dp[i][0]);\n                        nex[i + j + 1][1] = Math.Min(nex[i + j + 1][1], dp[i][1]);\n                    }\n                }\n            }\n            dp = nex;\n        }\n        return dp;\n    }\n\n    static void DBG(string a) => Console.WriteLine(a);\n    static void DBG<T>(IEnumerable<T> a) => DBG(string.Join(\" \", a));\n    static void DBG(params object[] a) => DBG(string.Join(\" \", a));\n    static void Prt(string a) => sw.WriteLine(a);\n    static void Prt<T>(IEnumerable<T> a) => Prt(string.Join(\" \", a));\n    static void Prt(params object[] a) => Prt(string.Join(\" \", a));\n}\nclass pair<T, U> : IComparable<pair<T, U>>\n{\n    public T v1;\n    public U v2;\n    public pair(T v1, U v2) {\n        this.v1 = v1;\n        this.v2 = v2;\n    }\n    public int CompareTo(pair<T, U> a) {\n        int c = Comparer<T>.Default.Compare(v1, a.v1);\n        return c != 0 ? c : Comparer<U>.Default.Compare(v2, a.v2);\n    }\n    public override string ToString() => v1 + \" \" + v2;\n    public void Deconstruct(out T a, out U b) {\n        a = v1; b = v2;\n    }\n    public static bool operator>(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) > 0;\n    public static bool operator<(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) < 0;\n    public static bool operator>=(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) >= 0;\n    public static bool operator<=(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) <= 0;\n}\nstatic class util\n{\n    public static pair<T, U> make_pair<T, U>(T v1, U v2) => new pair<T, U>(v1, v2);\n    public static T sq<T>(T a) => Operator<T>.Multiply(a, a);\n    public static T Max<T>(params T[] a) => a.Max();\n    public static T Min<T>(params T[] a) => a.Min();\n    public static bool inside(int i, int j, int h, int w) => i >= 0 && i < h && j >= 0 && j < w;\n    public static Dictionary<T, int> compress<T>(this IEnumerable<T> a)\n        => a.Distinct().OrderBy(v => v).Select((v, i) => new { v, i }).ToDictionary(p => p.v, p => p.i);\n    public static Dictionary<T, int> compress<T>(params IEnumerable<T>[] a) => compress(a.Aggregate(Enumerable.Union));\n    public static void swap<T>(ref T a, ref T b) where T : struct { var t = a; a = b; b = t; }\n    public static void swap<T>(this IList<T> a, int i, int j) where T : struct { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a) {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n}\nstatic class Operator<T>\n{\n    static readonly ParameterExpression x = Expression.Parameter(typeof(T), \"x\");\n    static readonly ParameterExpression y = Expression.Parameter(typeof(T), \"y\");\n    public static readonly Func<T, T, T> Add = Lambda(Expression.Add);\n    public static readonly Func<T, T, T> Subtract = Lambda(Expression.Subtract);\n    public static readonly Func<T, T, T> Multiply = Lambda(Expression.Multiply);\n    public static readonly Func<T, T, T> Divide = Lambda(Expression.Divide);\n    public static readonly Func<T, T> Plus = Lambda(Expression.UnaryPlus);\n    public static readonly Func<T, T> Negate = Lambda(Expression.Negate);\n    public static Func<T, T, T> Lambda(Binary op) => Expression.Lambda<Func<T, T, T>>(op(x, y), x, y).Compile();\n    public static Func<T, T> Lambda(Unary op) => Expression.Lambda<Func<T, T>>(op(x), x).Compile();\n}\n\nclass Scan\n{\n    public int Int => int.Parse(Str);\n    public long Long => long.Parse(Str);\n    public double Double => double.Parse(Str);\n    public string Str => Console.ReadLine().Trim();\n    public pair<T, U> Pair<T, U>() {\n        T a; U b;\n        Multi(out a, out b);\n        return new pair<T, U>(a, b);\n    }\n    public P P {\n        get {\n            int a, b;\n            Multi(out a, out b);\n            return new P(a, b);\n        }\n    }\n    public int[] IntArr => StrArr.Select(int.Parse).ToArray();\n    public long[] LongArr => StrArr.Select(long.Parse).ToArray();\n    public double[] DoubleArr => StrArr.Select(double.Parse).ToArray();\n    public string[] StrArr => Str.Split(new[]{' '}, StringSplitOptions.RemoveEmptyEntries);\n    bool eq<T, U>() => typeof(T).Equals(typeof(U));\n    T ct<T, U>(U a) => (T)Convert.ChangeType(a, typeof(T));\n    T cv<T>(string s) => eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                       : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                       : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                       : eq<T, char>()   ? ct<T, char>(s[0])\n                                         : ct<T, string>(s);\n    public void Multi<T>(out T a) => a = cv<T>(Str);\n    public void Multi<T, U>(out T a, out U b)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); }\n    public void Multi<T, U, V>(out T a, out U b, out V c)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); }\n    public void Multi<T, U, V, W, X, Y>(out T a, out U b, out V c, out W d, out X e, out Y f)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); f = cv<Y>(ar[5]); }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\nusing System.Numerics;\nusing static System.Math;\nnamespace Program {\n    public class Solver {\n        Random rnd = new Random(0);\n        public void Solve() {\n            var n = ri;\n            var A = Enumerate(n, x => rl);\n            var G = Enumerate(n, x => new List<int>());\n            for (int i = 0; i < n - 1; i++) {\n                var u = ri - 1;\n                var v = ri - 1;\n                G[u].Add(v);\n                G[v].Add(u);\n            }\n            // all plus\n            var dp = Enumerate(n, x => new long[0]);\n\n            // other case\n            var ep = Enumerate(n, x => new long[0]);\n            const long MAX = 5050 * 1000000000L;\n\n            Action<int, int> dfs = null;\n            dfs = (prev, cur) =>\n            {\n                var d = new long[1];\n                var e = new long[1];\n                d[0] = INF;\n                e[0] = INF;\n                if (A[cur] > 0) d[0] = A[cur];\n                else e[0] = A[cur];\n\n                foreach (var t in G[cur]) {\n                    if (t == prev) continue;\n                    dfs(cur, t);\n                    var dd = dp[t];\n                    var ee = ep[t];\n\n                    var nd = new long[d.Length + dd.Length];\n                    var ne = new long[e.Length + ee.Length];\n                    for (int i = 0; i < nd.Length; i++)\n                        nd[i] = ne[i] = INF;\n\n                    for (int i = 0; i < d.Length; i++)\n                        for (int j = 0; j < dd.Length; j++) {\n                            nd[i + j] = Min(nd[i + j], d[i] + dd[j]);\n\n                            ne[i + j] = Min(ne[i + j], e[i] + ee[j]);\n                            ne[i + j] = Min(ne[i + j], d[i] + ee[j]);\n                            ne[i + j] = Min(ne[i + j], e[i] + dd[j]);\n                            if (dd[j] < MAX || ee[j] < 0) {\n                                nd[i + j + 1] = Min(nd[i + j + 1], d[i]);\n                                ne[i + j + 1] = Min(ne[i + j + 1], e[i]);\n                            }\n                        }\n\n                    d = nd;\n                    e = ne;\n                }\n                dp[cur] = d;\n                ep[cur] = e;\n            };\n            dfs(-1, 0);\n            for (int i = 0; i < n; i++) {\n                Debug.WriteLine(i);\n                Debug.WriteLine(dp[i].AsJoinedString());\n                Debug.WriteLine(ep[i].AsJoinedString());\n            }\n            for (int i = 0; i < dp[0].Length; i++) {\n                if (dp[0][i] < MAX || (ep[0][i] < 0)) {\n                    Console.WriteLine(i);\n                    return;\n                }\n            }\n        }\n\n        const long INF = 1L << 60;\n        int ri { get { return sc.Integer(); } }\n        long rl { get { return sc.Long(); } }\n        double rd { get { return sc.Double(); } }\n        string rs { get { return sc.Scan(); } }\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex {\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie);\n    }\n    static public void Main() {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        solver.Solve();\n        Console.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer: StreamWriter {\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len) {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0) {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Text;\nusing System.Numerics;\nusing System.Threading;\nusing System.Runtime.CompilerServices;\nusing System.Diagnostics;\nusing static System.Math;\nusing static System.Array;\nusing static AtCoder.Cout;\nusing static AtCoder.Tool;\nusing static AtCoder.ModInt;\nnamespace AtCoder\n{\n    class AC\n    {\n        const int MOD = 1000000007;\n        //const int MOD = 998244353;\n        const int INF = int.MaxValue / 2;\n        const long SINF = long.MaxValue / 3;\n        const double EPS = 1e-8;\n        static readonly int[] dI = { 0, 1, 0, -1, 1, -1, -1, 1 };\n        static readonly int[] dJ = { 1, 0, -1, 0, 1, 1, -1, -1 };\n        static void Main(string[] args)\n        {\n            //var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false }; Console.SetOut(sw);\n\n            var th = new Thread(Run, 1 << 26);\n            th.Start();\n            th.Join();\n\n            //Run();\n            Console.Out.Flush();\n        }\n        static void Run()\n        {\n            int Testcase = 1;\n            //Testcase = Cin.Int;\n            for (var _ = 0; _ < Testcase; _++) Solve();\n        }\n        static void Solve()\n        {\n            int N = Cin.Int;\n            var A = Cin.ReadSplitLong;\n            var G = new List<List<int>>();\n            for (var i = 0; i < N; i++) G.Add(new List<int>());\n            for(var i = 0; i < N - 1; i++)\n            {\n                Cin.Input(out int a, out int b);\n                a--;b--;\n                G[a].Add(b);\n                G[b].Add(a);\n            }\n            var dpp = new bool[N][];\n            var dpm = new long[N][];\n            var sz = new int[N];\n            void dfs(int v,int pre = -1)\n            {\n                sz[v] = 1;\n                dpp[v] = new bool[1];\n                dpp[v][0] = A[v] > 0;\n\n                dpm[v] = new long[1];\n                dpm[v][0] = A[v];\n\n                foreach(var nx in G[v])\n                {\n                    if (nx == pre) continue;\n                    dfs(nx, v);\n                    var mgp = new bool[sz[v] + sz[nx] + 1];\n                    var mgm = new long[sz[v] + sz[nx] + 1];\n                    Fill(mgm, SINF);\n                    for(var i = 0; i < sz[v]; i++)\n                    {\n                        for(var j = 0; j < sz[nx]; j++)\n                        {\n                            //全部正\n                            //辺を切らない\n                            mgp[i + j] |= (dpp[v][i] & dpp[nx][j]);\n                            //辺を切る\n                            mgp[i + j + 1] |= (dpp[v][i] & (dpp[nx][j] | dpm[nx][j] < 0));\n\n                            //合計が負\n                            //辺を切らない\n                            mgm[i + j] = Min(mgm[i + j], dpm[v][i] + dpm[nx][j]);\n                            //辺を切る\n                            if (dpp[nx][j] || dpm[nx][j] < 0) mgm[i + j + 1] = Min(mgm[i + j + 1], dpm[v][i]);\n                        }\n                    }\n                    sz[v] += sz[nx];\n                    dpp[v] = mgp;\n                    dpm[v] = mgm;\n                }\n            }\n            dfs(0);\n            int ans = N - 1;\n            /*for(var i = 0; i < N; i++)\n            {\n                OutL($\"v={i + 1}\");\n                Out_Sep(dpp[i]);\n                Out_Sep(dpm[i]);\n                OutL($\"===========\");\n            }*/\n            for(var i = 0; i < N; i++)\n            {\n                if (dpp[0][i] || dpm[0][i] < 0)\n                {\n                    ans = i;\n                    break;\n                }\n            }\n            OutL(ans);\n            \n        }\n        public struct Edge\n        {\n            public int from;\n\n            public int to;\n            public long dist;\n\n            public Edge(int t, long c)\n            {\n                from = -1;\n                to = t;\n                dist = c;\n            }\n            public Edge(int f, int t, long c)\n            {\n                from = f;\n                to = t;\n                dist = c;\n            }\n        }\n    }\n    struct ModInt\n    {\n        public long value;\n        private const int MOD = 1000000007;\n        //private const int MOD = 998244353;\n        public ModInt(long value) { this.value = value; }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static implicit operator ModInt(long a)\n        {\n            var ret = a % MOD;\n            return new ModInt(ret < 0 ? (ret + MOD) : ret);\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt operator +(ModInt a, ModInt b) => (a.value + b.value);\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt operator -(ModInt a, ModInt b) => (a.value - b.value);\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt operator *(ModInt a, ModInt b) => (a.value * b.value);\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt operator /(ModInt a, ModInt b) => a * Modpow(b, MOD - 2);\n\n        public static ModInt operator <<(ModInt a, int n) => (a.value << n);\n        public static ModInt operator >>(ModInt a, int n) => (a.value >> n);\n        public static ModInt operator ++(ModInt a) => a.value + 1;\n        public static ModInt operator --(ModInt a) => a.value - 1;\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt Modpow(ModInt a, long n)\n        {\n            var k = a;\n            ModInt ret = 1;\n            while (n > 0)\n            {\n                if ((n & 1) != 0) ret *= k;\n                k *= k;\n                n >>= 1;\n            }\n            return ret;\n        }\n        private static readonly List<long> Factorials = new List<long>() { 1 };\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt Fac(long n)\n        {\n            for (var i = Factorials.Count(); i <= n; i++)\n            {\n                Factorials.Add((Factorials[i - 1] * i) % MOD);\n            }\n            return Factorials[(int)n];\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt nCr(long n, long r)\n        {\n            if (n < 0 || r < 0) return 0;\n            return n < r ? 0 : Fac(n) / (Fac(r) * Fac(n - r));\n        }\n        public static explicit operator int(ModInt a) => (int)a.value;\n    }\n    public class Rolling_Hash\n    {\n        const ulong m30 = (1UL << 30) - 1;\n        const ulong m31 = (1UL << 31) - 1;\n        const ulong MOD = (1UL << 61) - 1;\n        const ulong Pl = (MOD << 1) << 1;\n        private uint B;\n        private string S;\n        ulong[] hash;\n        ulong[] pw;\n\n        public Rolling_Hash(string str)\n        {\n            S = str;\n            B = (uint)new Random().Next(1 << 12 + 1, int.MaxValue);\n            int L = S.Length;\n            hash = new ulong[L + 1];\n            pw = new ulong[L + 1];\n            hash[0] = 0;\n            pw[0] = 1;\n            for (var i = 0; i < L; i++)\n            {\n                hash[i + 1] = CalcMod(Mul(hash[i], B) + S[i]);\n                pw[i + 1] = CalcMod(Mul(pw[i], B));\n            }\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public ulong GetHashValue(int idx) => hash[idx];\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]//segment [l,r]\n        public ulong Hash_fold(int l, int r) => CalcMod(Pl + hash[r + 1] - Mul(hash[l], pw[r - l + 1]));\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]//segment[start,start+len-1]\n        public ulong Hash_sub(int start, int len) => CalcMod(Pl + hash[start + len] - Mul(hash[start], pw[len]));\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public ulong[] GetHashArray() => hash;\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        ulong Mul(ulong a, ulong b)\n        {\n            ulong au = a >> 31;\n            ulong ad = a & m31;\n            ulong bu = b >> 31;\n            ulong bd = b & m31;\n            ulong mid = ad * bu + au * bd;\n            ulong midu = mid >> 30;\n            ulong midd = mid & m30;\n            return au * bu * 2 + midu + (midd << 31) + ad * bd;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        ulong CalcMod(ulong x)\n        {\n            ulong xu = x >> 61;\n            ulong xd = x & MOD;\n            ulong res = xu + xd;\n            if (res >= MOD) res -= MOD;\n            return res;\n        }\n    }\n    public class Priority_Queue<T>\n    {\n        private List<T> Q;\n        private readonly Comparison<T> Func_Compare;\n        public Priority_Queue(Comparison<T> comp)\n        {\n            Func_Compare = comp;\n            Q = new List<T>();\n        }\n        private void PushHeap(List<T> list, T item)\n        {\n            int n = list.Count();\n            list.Add(item);\n\n            while (n != 0)\n            {\n                int pIndex = (n - 1) / 2;\n\n                if (Func_Compare(list[n], list[pIndex]) < 0)\n                {\n                    Swap(Q, n, pIndex);\n                }\n                else { break; }\n\n                n = pIndex;\n            }\n        }\n        private void PopHeap(List<T> list)\n        {\n            int n = list.Count() - 1;\n            list[0] = list[n];\n            list.RemoveAt(n);\n\n            int cur = 0;\n            int comp;\n\n            while (2 * cur + 1 <= n - 1)\n            {\n                int c1 = 2 * cur + 1;\n                int c2 = 2 * (cur + 1);\n                if (c1 == n - 1)\n                {\n                    comp = c1;\n                }\n                else\n                {\n\n                    comp = Func_Compare(list[c1], list[c2]) < 0 ? c1 : c2;\n                }\n\n                if (Func_Compare(list[cur], list[comp]) > 0)\n                {\n                    Swap(Q, cur, comp);\n                }\n                else { break; }\n\n                cur = comp;\n            }\n        }\n        private void Swap(List<T> list, int a, int b)\n        {\n            T keep = list[a];\n            list[a] = list[b];\n            list[b] = keep;\n        }\n\n        public void Enqueue(T value)\n        {\n            PushHeap(Q, value);\n        }\n\n        public T Dequeue()\n        {\n            T ret = Q[0];\n            PopHeap(Q);\n            return ret;\n        }\n\n        public T Peek()\n        {\n            return Q[0];\n        }\n\n        public int Count()\n        {\n            return Q.Count();\n        }\n        public bool Any()\n        {\n            return Q.Any();\n        }\n    }\n    public class SegmentTree<T>\n    {\n        //1-indexed type\n        int n;\n        T[] Tree;\n        Func<T, T, T> f;\n        T ex;\n        int L;\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public SegmentTree(int size, Func<T, T, T> fun, T exvalue)\n        {\n            ex = exvalue;\n            f = fun;\n            n = 1;\n            while (n < size) n <<= 1;\n            Tree = new T[n << 1];\n            L = (n << 1) - 1;\n            for (var i = 0; i <= L; i++) Tree[i] = ex;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public SegmentTree(int size, Func<T, T, T> fun, T exvalue, T[] initial)\n        {\n            ex = exvalue;\n            n = 1; while (n < size) n <<= 1;\n            f = fun;\n            Tree = new T[n << 1];\n            L = (n << 1) - 1;\n            for (var i = 0; i <= L; i++) Tree[i] = (n <= i && i <= n + initial.Length - 1) ? initial[i - n] : ex;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Set_All()\n        {\n            for (var i = n - 1; i >= 1; i--) Tree[i] = f(Tree[i << 1], Tree[(i << 1) | 1]);\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Assign(int idx, T nxt) => Tree[idx + n] = nxt;\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Update(int idx)\n        {\n            int now = idx + n;\n            while (now > 1)\n            {\n                now >>= 1;\n                Tree[now] = f(Tree[now << 1], Tree[now << 1 | 1]);\n            }\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Query_Update(int idx, T nxt)\n        {\n            Assign(idx, nxt); Update(idx);\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Query_Update_func(int idx, T y)\n        {\n            Assign(idx, f(Peek(idx), y)); Update(idx);\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public T Query_Fold(int l, int r)\n        {\n            int L = n + l;\n            int R = n + r;\n            T vL = ex, vR = ex;\n            while (L < R)\n            {\n                if (L % 2 == 1)\n                {\n                    vL = f(vL, Tree[L]);\n                    L++;\n                }\n                if (R % 2 == 1)\n                {\n                    vR = f(Tree[R - 1], vR);\n                    R--;\n                }\n                L >>= 1;\n                R >>= 1;\n            }\n            return f(vL, vR);\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public T Peek(int idx) => Tree[idx + n];\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Display(int len)\n        {\n            for (var i = 0; i < len; i++) Console.Write($\"{Tree[i + n]} \");\n            Console.WriteLine();\n        }\n    }\n    public class UnionFind\n    {\n        private int[] parent;\n        private int[] rank;\n        private int[] size;\n        public UnionFind(int n)\n        {\n            parent = new int[n];\n            rank = new int[n];\n            size = new int[n];\n            for (var i = 0; i < n; i++)\n            {\n                parent[i] = i;\n                rank[i] = 0;\n                size[i] = 1;\n            }\n        }\n\n        public int Root(int x)\n        {\n            return parent[x] == x ? x : parent[x] = Root(parent[x]);\n        }\n\n        public bool SameRoot(int x, int y)\n        {\n            return Root(x) == Root(y);\n        }\n\n        public void Unite(int x, int y)\n        {\n            x = Root(x);\n            y = Root(y);\n            if (x == y) { return; }\n\n            if (rank[x] < rank[y])\n            {\n                parent[x] = y;\n                size[y] += size[x];\n                size[x] = 0;\n            }\n            else\n            {\n                parent[y] = x;\n                if (rank[x] == rank[y]) { rank[x]++; }\n                size[x] += size[y];\n                size[y] = 0;\n            }\n        }\n\n        public int SizeOf(int x)\n        {\n            return size[Root(x)];\n        }\n\n    }\n    static class Cin\n    {\n        public static string[] ReadSplit => Console.ReadLine().Split();\n        public static int[] ReadSplitInt => ConvertAll(Console.ReadLine().Split(), int.Parse);\n        public static long[] ReadSplitLong => ConvertAll(Console.ReadLine().Split(), long.Parse);\n        public static double[] ReadSplit_Double => ConvertAll(Console.ReadLine().Split(), double.Parse);\n        public static string Str => Console.ReadLine();\n        public static int Int => int.Parse(Console.ReadLine());\n        public static long Long => long.Parse(Console.ReadLine());\n        public static double Double => double.Parse(Console.ReadLine());\n        public static T Conv<T>(string input)\n        {\n            if (typeof(T).Equals(typeof(ModInt)))\n            {\n                return (T)(dynamic)(long.Parse(input));\n            }\n            return (T)Convert.ChangeType(input, typeof(T));\n        }\n        public static void Input<T>(out T a) => a = Conv<T>(Console.ReadLine());\n        public static void Input<T, U>(out T a, out U b)\n        { var q = ReadSplit; a = Conv<T>(q[0]); b = Conv<U>(q[1]); }\n        public static void Input<T, U, V>(out T a, out U b, out V c)\n        { var q = ReadSplit; a = Conv<T>(q[0]); b = Conv<U>(q[1]); c = Conv<V>(q[2]); }\n        public static void Input<T, U, V, W>(out T a, out U b, out V c, out W d)\n        { var q = ReadSplit; a = Conv<T>(q[0]); b = Conv<U>(q[1]); c = Conv<V>(q[2]); d = Conv<W>(q[3]); }\n        public static void Input<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n        { var q = ReadSplit; a = Conv<T>(q[0]); b = Conv<U>(q[1]); c = Conv<V>(q[2]); d = Conv<W>(q[3]); e = Conv<X>(q[4]); }\n    }\n    static class Cout\n    {\n        public static void OutL(object s) => Console.WriteLine(s);\n        public static void Out_Sep<T>(IEnumerable<T> s) => Console.WriteLine(string.Join(\" \", s));\n        public static void Out_Sep<T>(IEnumerable<T> s, string sep) => Console.WriteLine(string.Join($\"{sep}\", s));\n        public static void Out_Sep(params object[] s) => Console.WriteLine(string.Join(\" \", s));\n        public static void Out_One(object s) => Console.Write($\"{s} \");\n        public static void Out_One(object s, string sep) => Console.Write($\"{s}{sep}\");\n        public static void Endl() => Console.WriteLine();\n    }\n    public static class Tool\n    {\n        static public void Initialize<T>(ref T[] array, T initialvalue)\n        {\n            array = ConvertAll(array, x => initialvalue);\n        }\n        static public void Swap<T>(ref T a, ref T b)\n        {\n            T keep = a;\n            a = b;\n            b = keep;\n        }\n        static public void Display<T>(T[,] array2d, int n, int m)\n        {\n            for (var i = 0; i < n; i++)\n            {\n                for (var j = 0; j < m; j++)\n                {\n                    Console.Write($\"{array2d[i, j]} \");\n                }\n                Console.WriteLine();\n            }\n        }\n        static public long Gcd(long a, long b)\n        {\n            if (a == 0 || b == 0) return Max(a, b);\n            return a % b == 0 ? b : Gcd(b, a % b);\n        }\n        static public long LPow(int a, int b) => (long)Pow(a, b);\n        static public bool Bit(long x, int dig) => ((1L << dig) & x) != 0;\n        static public int Sig(long a) => a == 0 ? 0 : (int)(a / Abs(a));\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\nusing System.Numerics;\nusing static System.Math;\nnamespace Program {\n    public class Solver {\n        Random rnd = new Random(0);\n        public void Solve() {\n            var n = ri;\n            var A = Enumerate(n, x => rl);\n            var G = Enumerate(n, x => new List<int>());\n            for (int i = 0; i < n - 1; i++) {\n                var u = ri - 1;\n                var v = ri - 1;\n                G[u].Add(v);\n                G[v].Add(u);\n            }\n            // all plus\n            var dp = Enumerate(n, x => new long[0]);\n\n            // other case\n            var ep = Enumerate(n, x => new long[0]);\n           const long MAX = 5050 * 1000000000L;\n\n            Action<int, int> dfs = null;\n            dfs = (prev, cur) =>\n            {\n                var d = new long[1];\n                var e = new long[1];\n                d[0] = INF;\n                e[0] = INF;\n                if (A[cur] > 0) d[0] = A[cur];\n                else e[0] = A[cur];\n\n                foreach (var t in G[cur]) {\n                    if (t == prev) continue;\n                    dfs(cur, t);\n                    var dd = dp[t];\n                    var ee = ep[t];\n\n                    var nd = new long[d.Length + dd.Length];\n                    var ne = new long[e.Length + ee.Length];\n                    for (int i = 0; i < nd.Length; i++)\n                        nd[i] = ne[i] = INF;\n\n                    for (int i = 0; i < d.Length; i++)\n                        for (int j = 0; j < dd.Length; j++) {\n                            nd[i + j] = Min(nd[i + j], d[i] + dd[j]);\n\n                            ne[i + j] = Min(ne[i + j], e[i] + ee[j]);\n                            ne[i + j] = Min(ne[i + j], d[i] + ee[j]);\n                            ne[i + j] = Min(ne[i + j], e[i] + dd[j]);\n                            if (dd[j] < MAX || ee[j] < 0) {\n                                nd[i + j + 1] = Min(nd[i + j + 1], d[i]);\n                                ne[i + j + 1] = Min(ne[i + j], e[i]);\n                            }\n                        }\n\n                    d = nd;\n                    e = ne;\n                }\n                dp[cur] = d;\n                ep[cur] = e;\n            };\n            dfs(-1, 0);\n            for (int i = 0; i < n; i++) {\n                Debug.WriteLine(i);\n                Debug.WriteLine(dp[i].AsJoinedString());\n                Debug.WriteLine(ep[i].AsJoinedString());\n            }\n            for (int i = 0; i < dp[0].Length; i++) {\n                if (dp[0][i] < MAX || (ep[0][i] < 0)) {\n                    Console.WriteLine(i);\n                    return;\n                }\n            }\n        }\n\n        const long INF = 1L << 60;\n        int ri { get { return sc.Integer(); } }\n        long rl { get { return sc.Long(); } }\n        double rd { get { return sc.Double(); } }\n        string rs { get { return sc.Scan(); } }\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex {\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie);\n    }\n    static public void Main() {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        solver.Solve();\n        Console.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer: StreamWriter {\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len) {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0) {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.IO;\nusing System.Text;\n\nusing static util;\nusing P = pair<int, int>;\n\nusing Binary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.ParameterExpression,\n                           System.Linq.Expressions.BinaryExpression>;\nusing Unary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.UnaryExpression>;\n\nclass Program\n{\n    static StreamWriter sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n    static Scan sc = new Scan();\n    const int M = 1000000007;\n    const int M2 = 998244353;\n    const long LM = (long)1e18;\n    const double eps = 1e-11;\n    static readonly int[] dd = { 0, 1, 0, -1, 0 };\n    const string dstring = \"RDLU\";\n    static void Main()\n    {\n        int n = sc.Int;\n        a = sc.LongArr;\n        edge = new List<int>[n];\n        for (int i = 0; i < n; i++)\n            edge[i] = new List<int>();\n\n        for (int i = 0; i < n - 1; i++)\n        {\n            int u, v;\n            sc.Multi(out u, out v);\n            --u;\n            --v;\n            edge[u].Add(v);\n            edge[v].Add(u);\n        }\n        var r = new Random();\n        var b = dfs(r.Next(n), -1);\n        for (int i = 0; i < n; i++)\n        {\n            if (b[i][0] < LM / 2 || b[i][1] < 0) {\n                DBG(i);\n                return;\n            }\n        }\n        sw.Flush();\n    }\n    static long[] a;\n    static List<int>[] edge;\n    static long[][] dfs(int p, int par) {\n        var dp = new long[1][];\n        dp[0] = new long[2];\n        dp[0][0] = a[p] > 0 ? a[p] : LM;\n        dp[0][1] = a[p];\n        foreach (var item in edge[p])\n        {\n            if (item == par) continue;\n            var b = dfs(item, p);\n            var nex = new long[dp.Length + b.Length][];\n            for (int i = 0; i < nex.Length; i++)\n            {\n                nex[i] = new long[2];\n                nex[i][0] = nex[i][1] = LM;\n            }\n            for (int i = 0; i < dp.Length; i++)\n            {\n                for (int j = 0; j < b.Length; j++)\n                {\n                    for (int k = 0; k < 2; k++)\n                    {\n                        nex[i + j][k] = Math.Min(nex[i + j][k], dp[i][k] + b[j][k]);\n                        if (b[j][0] < LM / 2 || b[j][1] < 0)\n                            nex[i + j + 1][k] = Math.Min(nex[i + j + 1][k], dp[i][k]);\n                    }\n                }\n            }\n            dp = nex;\n        }\n        return dp;\n    }\n\n    static void DBG(string a) => Console.WriteLine(a);\n    static void DBG<T>(IEnumerable<T> a) => DBG(string.Join(\" \", a));\n    static void DBG(params object[] a) => DBG(string.Join(\" \", a));\n    static void Prt(string a) => sw.WriteLine(a);\n    static void Prt<T>(IEnumerable<T> a) => Prt(string.Join(\" \", a));\n    static void Prt(params object[] a) => Prt(string.Join(\" \", a));\n}\nclass pair<T, U> : IComparable<pair<T, U>>\n{\n    public T v1;\n    public U v2;\n    public pair(T v1, U v2) {\n        this.v1 = v1;\n        this.v2 = v2;\n    }\n    public int CompareTo(pair<T, U> a) {\n        int c = Comparer<T>.Default.Compare(v1, a.v1);\n        return c != 0 ? c : Comparer<U>.Default.Compare(v2, a.v2);\n    }\n    public override string ToString() => v1 + \" \" + v2;\n    public void Deconstruct(out T a, out U b) {\n        a = v1; b = v2;\n    }\n    public static bool operator>(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) > 0;\n    public static bool operator<(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) < 0;\n    public static bool operator>=(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) >= 0;\n    public static bool operator<=(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) <= 0;\n}\nstatic class util\n{\n    public static pair<T, U> make_pair<T, U>(T v1, U v2) => new pair<T, U>(v1, v2);\n    public static T sq<T>(T a) => Operator<T>.Multiply(a, a);\n    public static T Max<T>(params T[] a) => a.Max();\n    public static T Min<T>(params T[] a) => a.Min();\n    public static bool inside(int i, int j, int h, int w) => i >= 0 && i < h && j >= 0 && j < w;\n    public static Dictionary<T, int> compress<T>(this IEnumerable<T> a)\n        => a.Distinct().OrderBy(v => v).Select((v, i) => new { v, i }).ToDictionary(p => p.v, p => p.i);\n    public static Dictionary<T, int> compress<T>(params IEnumerable<T>[] a) => compress(a.Aggregate(Enumerable.Union));\n    public static void swap<T>(ref T a, ref T b) where T : struct { var t = a; a = b; b = t; }\n    public static void swap<T>(this IList<T> a, int i, int j) where T : struct { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a) {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n}\nstatic class Operator<T>\n{\n    static readonly ParameterExpression x = Expression.Parameter(typeof(T), \"x\");\n    static readonly ParameterExpression y = Expression.Parameter(typeof(T), \"y\");\n    public static readonly Func<T, T, T> Add = Lambda(Expression.Add);\n    public static readonly Func<T, T, T> Subtract = Lambda(Expression.Subtract);\n    public static readonly Func<T, T, T> Multiply = Lambda(Expression.Multiply);\n    public static readonly Func<T, T, T> Divide = Lambda(Expression.Divide);\n    public static readonly Func<T, T> Plus = Lambda(Expression.UnaryPlus);\n    public static readonly Func<T, T> Negate = Lambda(Expression.Negate);\n    public static Func<T, T, T> Lambda(Binary op) => Expression.Lambda<Func<T, T, T>>(op(x, y), x, y).Compile();\n    public static Func<T, T> Lambda(Unary op) => Expression.Lambda<Func<T, T>>(op(x), x).Compile();\n}\n\nclass Scan\n{\n    public int Int => int.Parse(Str);\n    public long Long => long.Parse(Str);\n    public double Double => double.Parse(Str);\n    public string Str => Console.ReadLine().Trim();\n    public pair<T, U> Pair<T, U>() {\n        T a; U b;\n        Multi(out a, out b);\n        return new pair<T, U>(a, b);\n    }\n    public P P {\n        get {\n            int a, b;\n            Multi(out a, out b);\n            return new P(a, b);\n        }\n    }\n    public int[] IntArr => StrArr.Select(int.Parse).ToArray();\n    public long[] LongArr => StrArr.Select(long.Parse).ToArray();\n    public double[] DoubleArr => StrArr.Select(double.Parse).ToArray();\n    public string[] StrArr => Str.Split(new[]{' '}, StringSplitOptions.RemoveEmptyEntries);\n    bool eq<T, U>() => typeof(T).Equals(typeof(U));\n    T ct<T, U>(U a) => (T)Convert.ChangeType(a, typeof(T));\n    T cv<T>(string s) => eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                       : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                       : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                       : eq<T, char>()   ? ct<T, char>(s[0])\n                                         : ct<T, string>(s);\n    public void Multi<T>(out T a) => a = cv<T>(Str);\n    public void Multi<T, U>(out T a, out U b)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); }\n    public void Multi<T, U, V>(out T a, out U b, out V c)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); }\n    public void Multi<T, U, V, W, X, Y>(out T a, out U b, out V c, out W d, out X e, out Y f)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); f = cv<Y>(ar[5]); }\n}\n"
  },
  {
    "language": "Lisp",
    "code": "(in-package :cl-user)\n(eval-when (:compile-toplevel :load-toplevel :execute)\n  (sb-int:defconstant-eqx opt\n    #+swank '(optimize (speed 3) (safety 2))\n    #-swank '(optimize (speed 3) (safety 0) (debug 0))\n    #'equal)\n  #+swank (ql:quickload '(:cl-debug-print :fiveam) :silent t)\n  #-swank (set-dispatch-macro-character\n           #\\# #\\> (lambda (s c p) (declare (ignore c p)) `(values ,(read s nil nil t)))))\n#+swank (set-dispatch-macro-character #\\# #\\> #'cl-debug-print:debug-print-reader)\n\n(macrolet ((def-int (b)\n             `(progn (deftype ,(intern (format nil \"UINT~A\" b)) () '(unsigned-byte ,b))\n                     (deftype ,(intern (format nil \"INT~A\" b)) () '(signed-byte ,b))))\n           (defs (&rest bits) `(progn ,@(mapcar (lambda (b) `(def-int ,b)) bits))))\n  (defs 2 4 7 8 15 16 31 32 62 63 64))\n\n(defconstant +mod+ 1000000007)\n\n(defmacro dbg (&rest forms)\n  #+swank (if (= (length forms) 1)\n              `(format *error-output* \"~A => ~A~%\" ',(car forms) ,(car forms))\n              `(format *error-output* \"~A => ~A~%\" ',forms `(,,@forms)))\n  #-swank (declare (ignore forms)))\n\n(declaim (inline println))\n(defun println (obj &optional (stream *standard-output*))\n  (let ((*read-default-float-format* 'double-float))\n    (prog1 (princ obj stream) (terpri stream))))\n\n;; BEGIN_INSERTED_CONTENTS\n(defpackage :cp/modify-macro\n  (:use :cl)\n  (:export #:minf #:maxf #:mulf #:divf #:iorf #:xorf #:andf))\n(in-package :cp/modify-macro)\n\n(macrolet ((def (name fname)\n             `(define-modify-macro ,name (new-value) ,fname)))\n  (def minf min)\n  (def maxf max)\n  (def mulf *)\n  (def divf /)\n  (def iorf logior)\n  (def xorf logxor)\n  (def andf logand))\n\n;; BEGIN_USE_PACKAGE\n(eval-when (:compile-toplevel :load-toplevel :execute)\n  (use-package :cp/modify-macro :cl-user))\n(in-package :cl-user)\n\n;;;\n;;; Body\n;;;\n\n(defconstant +inf+ most-positive-fixnum)\n(defun main ()\n  (let* ((n (read))\n         (as (make-array n :element-type 'int32 :initial-element 0))\n         (graph (make-array n :element-type 'list :initial-element nil))\n         (sizes (make-array n :element-type 'uint31 :initial-element 0))\n         (gs (make-array n :element-type 'uint62 :initial-element +inf+)))\n    (dotimes (i n)\n      (setf (aref as i) (read)))\n    (dotimes (i (- n 1))\n      (let ((u (- (read) 1))\n            (v (- (read) 1)))\n        (push u (aref graph v))\n        (push v (aref graph u))))\n    (sb-int:named-let dfs ((v 0) (parent -1))\n      (let ((size 1))\n        (dolist (child (aref graph v))\n          (unless (= child parent)\n            (dfs child v)\n            (incf size (aref sizes child)))\n          (setf (aref sizes v) size))))\n    (labels ((%merge (dp1 dp2 child)\n               (let* ((n1 (length dp1))\n                      (n2 (length dp2))\n                      (res-dp (make-array (+ n1 n2) :element-type 'fixnum :initial-element 0)))\n                 \n                 (dotimes (y (length res-dp))\n                   (let ((value +inf+))\n                     (loop for i to y\n                           for j = (- y i)\n                           when (and (<= 0 i (- n1 1))\n                                     (<= 0 j (- n2 1)))\n                           do (minf value (+ (aref dp1 i) (aref dp2 j))))\n                     (loop for i below y\n                           for j = (- y i 1)\n                           when (and (<= 0 i (- n1 1))\n                                     (<= 0 j (- n2 1))\n                                     (< (aref dp2 j) 0))\n                           do (minf value (aref dp1 i)))\n                     (when (<= 0 (- y (aref gs child) 1) (- n1 1))\n                       (minf value (aref dp1 (- y (aref gs child) 1))))\n                     (setf (aref res-dp y) value)))\n                 (dbg dp1 dp2 res-dp child)\n                 res-dp)))\n      (let ((dp (sb-int:named-let dfs ((v 0) (parent -1))\n                  (let ((g 0)\n                        (dp (make-array 1 :element-type 'fixnum :initial-element (aref as v))))\n                    (dolist (child (aref graph v))\n                      (unless (= child parent)\n                        (let ((child-dp (dfs child v)))\n                          (setq dp (%merge dp child-dp child))\n                          (incf g (min (aref gs child)\n                                       (loop for y below (length child-dp)\n                                             when (< (aref child-dp y) 0)\n                                             do (return (+ y 1))\n                                             finally (return +inf+)))))))\n                    (when (> (aref as v) 0)\n                      (setf (aref gs v) g))\n                    (dbg v g dp)\n                    dp))))\n        (println (min (aref gs 0)\n                      (dotimes (y (length dp) most-positive-fixnum)\n                        (when (< (aref dp y) 0)\n                          (return y)))))))))\n\n#-swank (main)\n\n;;;\n;;; Test and benchmark\n;;;\n\n#+swank\n(defun get-clipbrd ()\n  (with-output-to-string (out)\n    #+os-windows (run-program \"powershell.exe\" '(\"-Command\" \"Get-Clipboard\") :output out :search t)\n    #+os-unix (run-program \"xsel\" '(\"-b\" \"-o\") :output out :search t)))\n\n#+swank (defparameter *this-pathname* (uiop:current-lisp-file-pathname))\n#+swank (defparameter *dat-pathname* (uiop:merge-pathnames* \"test.dat\" *this-pathname*))\n\n#+swank\n(defun run (&optional thing (out *standard-output*))\n  \"THING := null | string | symbol | pathname\n\nnull: run #'MAIN using the text on clipboard as input.\nstring: run #'MAIN using the string as input.\nsymbol: alias of FIVEAM:RUN!.\npathname: run #'MAIN using the text file as input.\"\n  (let* ((*standard-output* (or out (make-string-output-stream)))\n         (res (etypecase thing\n                (null\n                 (with-input-from-string (*standard-input* (delete #\\Return (get-clipbrd)))\n                   (main)))\n                (string\n                 (with-input-from-string (*standard-input* (delete #\\Return thing))\n                   (main)))\n                (symbol (5am:run! thing))\n                (pathname\n                 (with-open-file (*standard-input* thing)\n                   (main))))))\n    (if out res (get-output-stream-string *standard-output*))))\n\n#+swank\n(defun gen-dat ()\n  (uiop:with-output-file (out *dat-pathname* :if-exists :supersede)\n    (format out \"\")))\n\n#+swank\n(defun bench (&optional (out (make-broadcast-stream)))\n  (time (run *dat-pathname* out)))\n\n#-swank\n(eval-when (:compile-toplevel)\n  (when (and (boundp 'sb-c::*compiler-warning-count*)\n             (> sb-c::*compiler-warning-count* 0))\n    (sb-ext:quit :unix-status 1)))\n\n;; To run: (5am:run! :sample)\n#+swank\n(it.bese.fiveam:test :sample\n  (5am:is\n   (equal \"1\n\"\n          (run \"7\n-2 7 5 6 -8 3 4\n1 2\n2 3\n2 4\n1 5\n5 6\n5 7\n\" nil)))\n  (5am:is\n   (equal \"0\n\"\n          (run \"4\n1 2 3 4\n1 2\n1 3\n1 4\n\" nil)))\n  (5am:is\n   (equal \"5\n\"\n          (run \"6\n10 -1 10 -1 10 -1\n1 2\n2 3\n3 4\n4 5\n5 6\n\" nil)))\n  (5am:is\n   (equal \"3\n\"\n          (run \"8\n-2 3 6 -2 -2 -5 3 2\n3 4\n7 6\n6 2\n8 2\n5 3\n1 8\n3 7\n\" nil)))\n  (5am:is\n   (equal \"3\n\"\n          (run \"10\n3 4 9 6 1 5 -1 10 -10 -10\n7 4\n5 6\n8 1\n9 5\n7 1\n10 3\n2 8\n4 10\n9 2\n\" nil))))\n"
  },
  {
    "language": "Lisp",
    "code": "(in-package :cl-user)\n(eval-when (:compile-toplevel :load-toplevel :execute)\n  (sb-int:defconstant-eqx opt\n    #+swank '(optimize (speed 3) (safety 2))\n    #-swank '(optimize (speed 3) (safety 0) (debug 0))\n    #'equal)\n  #+swank (ql:quickload '(:cl-debug-print :fiveam) :silent t)\n  #-swank (set-dispatch-macro-character\n           #\\# #\\> (lambda (s c p) (declare (ignore c p)) `(values ,(read s nil nil t)))))\n#+swank (set-dispatch-macro-character #\\# #\\> #'cl-debug-print:debug-print-reader)\n\n(macrolet ((def-int (b)\n             `(progn (deftype ,(intern (format nil \"UINT~A\" b)) () '(unsigned-byte ,b))\n                     (deftype ,(intern (format nil \"INT~A\" b)) () '(signed-byte ,b))))\n           (defs (&rest bits) `(progn ,@(mapcar (lambda (b) `(def-int ,b)) bits))))\n  (defs 2 4 7 8 15 16 31 32 62 63 64))\n\n(defconstant +mod+ 1000000007)\n\n(defmacro dbg (&rest forms)\n  #+swank (if (= (length forms) 1)\n              `(format *error-output* \"~A => ~A~%\" ',(car forms) ,(car forms))\n              `(format *error-output* \"~A => ~A~%\" ',forms `(,,@forms)))\n  #-swank (declare (ignore forms)))\n\n(declaim (inline println))\n(defun println (obj &optional (stream *standard-output*))\n  (let ((*read-default-float-format* 'double-float))\n    (prog1 (princ obj stream) (terpri stream))))\n\n;; BEGIN_INSERTED_CONTENTS\n(defpackage :cp/modify-macro\n  (:use :cl)\n  (:export #:minf #:maxf #:mulf #:divf #:iorf #:xorf #:andf))\n(in-package :cp/modify-macro)\n\n(macrolet ((def (name fname)\n             `(define-modify-macro ,name (new-value) ,fname)))\n  (def minf min)\n  (def maxf max)\n  (def mulf *)\n  (def divf /)\n  (def iorf logior)\n  (def xorf logxor)\n  (def andf logand))\n\n;; BEGIN_USE_PACKAGE\n(eval-when (:compile-toplevel :load-toplevel :execute)\n  (use-package :cp/modify-macro :cl-user))\n(in-package :cl-user)\n\n;;;\n;;; Body\n;;;\n\n(defconstant +inf+ most-positive-fixnum)\n\n(defun main ()\n  (declare #.cl-user::opt)\n  (let* ((n (read))\n         (as (make-array n :element-type 'int32 :initial-element 0))\n         (graph (make-array n :element-type 'list :initial-element nil))\n         (gs (make-array n :element-type 'uint62 :initial-element +inf+)))\n    (dotimes (i n)\n      (setf (aref as i) (read)))\n    (dotimes (i (- n 1))\n      (let ((u (- (read) 1))\n            (v (- (read) 1)))\n        (push u (aref graph v))\n        (push v (aref graph u))))\n    (labels ((%merge (dp1 dp2 child)\n               (declare ((simple-array fixnum (*)) dp1 dp2))\n               (let* ((n1 (length dp1))\n                      (n2 (length dp2))\n                      (res-dp (make-array (+ n1 n2) :element-type 'fixnum :initial-element 0)))\n                 \n                 (dotimes (y (length res-dp))\n                   (let ((value +inf+))\n                     (declare (fixnum value))\n                     (loop for i from (max (+ 1 (- y n2)) 0) to (min y (- n1 1))\n                           for j = (- y i)\n                           do (minf value (+ (aref dp1 i) (aref dp2 j))))\n                     (loop for i from (max (+ 1 (- y n2)) 0) to (min (- y 1) (- n1 1))\n                           for j = (- y i 1)\n                           when (< (aref dp2 j) 0)\n                           do (minf value (aref dp1 i)))\n                     (when (<= 0 (- y (aref gs child) 1) (- n1 1))\n                       (minf value (aref dp1 (- y (aref gs child) 1))))\n                     (setf (aref res-dp y) value)))\n                 res-dp)))\n      (let ((res (sb-int:named-let dfs ((v 0) (parent -1))\n                   (let ((g 0)\n                         (dp (make-array 1 :element-type 'fixnum :initial-element (aref as v))))\n                     (declare (uint62 g))\n                     (dolist (child (aref graph v))\n                       (unless (= child parent)\n                         (let ((child-dp (dfs child v)))\n                           (setq dp (%merge dp child-dp child))\n                           (incf g (min (aref gs child)\n                                        (loop for y below (length child-dp)\n                                              when (< (aref child-dp y) 0)\n                                              do (return (+ y 1))\n                                              finally (return +inf+)))))))\n                     (when (> (aref as v) 0)\n                       (setf (aref gs v) g))\n                     dp))))\n        (println (min (aref gs 0)\n                      (dotimes (y (length res) +inf+)\n                        (when (< (aref res y) 0)\n                          (return y)))))))))\n\n#-swank (main)\n\n;;;\n;;; Test and benchmark\n;;;\n\n#+swank\n(defun get-clipbrd ()\n  (with-output-to-string (out)\n    #+os-windows (run-program \"powershell.exe\" '(\"-Command\" \"Get-Clipboard\") :output out :search t)\n    #+os-unix (run-program \"xsel\" '(\"-b\" \"-o\") :output out :search t)))\n\n#+swank (defparameter *this-pathname* (uiop:current-lisp-file-pathname))\n#+swank (defparameter *dat-pathname* (uiop:merge-pathnames* \"test.dat\" *this-pathname*))\n\n#+swank\n(defun run (&optional thing (out *standard-output*))\n  \"THING := null | string | symbol | pathname\n\nnull: run #'MAIN using the text on clipboard as input.\nstring: run #'MAIN using the string as input.\nsymbol: alias of FIVEAM:RUN!.\npathname: run #'MAIN using the text file as input.\"\n  (let* ((*standard-output* (or out (make-string-output-stream)))\n         (res (etypecase thing\n                (null\n                 (with-input-from-string (*standard-input* (delete #\\Return (get-clipbrd)))\n                   (main)))\n                (string\n                 (with-input-from-string (*standard-input* (delete #\\Return thing))\n                   (main)))\n                (symbol (5am:run! thing))\n                (pathname\n                 (with-open-file (*standard-input* thing)\n                   (main))))))\n    (if out res (get-output-stream-string *standard-output*))))\n\n#+swank\n(defun gen-dat ()\n  (uiop:with-output-file (out *dat-pathname* :if-exists :supersede)\n    (format out \"\")))\n\n#+swank\n(defun bench (&optional (out (make-broadcast-stream)))\n  (time (run *dat-pathname* out)))\n\n#-swank\n(eval-when (:compile-toplevel)\n  (when (and (boundp 'sb-c::*compiler-warning-count*)\n             (> sb-c::*compiler-warning-count* 0))\n    (sb-ext:quit :unix-status 1)))\n\n;; To run: (5am:run! :sample)\n#+swank\n(it.bese.fiveam:test :sample\n  (5am:is\n   (equal \"1\n\"\n          (run \"7\n-2 7 5 6 -8 3 4\n1 2\n2 3\n2 4\n1 5\n5 6\n5 7\n\" nil)))\n  (5am:is\n   (equal \"0\n\"\n          (run \"4\n1 2 3 4\n1 2\n1 3\n1 4\n\" nil)))\n  (5am:is\n   (equal \"5\n\"\n          (run \"6\n10 -1 10 -1 10 -1\n1 2\n2 3\n3 4\n4 5\n5 6\n\" nil)))\n  (5am:is\n   (equal \"3\n\"\n          (run \"8\n-2 3 6 -2 -2 -5 3 2\n3 4\n7 6\n6 2\n8 2\n5 3\n1 8\n3 7\n\" nil)))\n  (5am:is\n   (equal \"3\n\"\n          (run \"10\n3 4 9 6 1 5 -1 10 -10 -10\n7 4\n5 6\n8 1\n9 5\n7 1\n10 3\n2 8\n4 10\n9 2\n\" nil))))\n"
  },
  {
    "language": "Lisp",
    "code": "(in-package :cl-user)\n(eval-when (:compile-toplevel :load-toplevel :execute)\n  (sb-int:defconstant-eqx opt\n    #+swank '(optimize (speed 3) (safety 2))\n    #-swank '(optimize (speed 3) (safety 0) (debug 0))\n    #'equal)\n  #+swank (ql:quickload '(:cl-debug-print :fiveam) :silent t)\n  #-swank (set-dispatch-macro-character\n           #\\# #\\> (lambda (s c p) (declare (ignore c p)) `(values ,(read s nil nil t)))))\n#+swank (set-dispatch-macro-character #\\# #\\> #'cl-debug-print:debug-print-reader)\n\n(macrolet ((def-int (b)\n             `(progn (deftype ,(intern (format nil \"UINT~A\" b)) () '(unsigned-byte ,b))\n                     (deftype ,(intern (format nil \"INT~A\" b)) () '(signed-byte ,b))))\n           (defs (&rest bits) `(progn ,@(mapcar (lambda (b) `(def-int ,b)) bits))))\n  (defs 2 4 7 8 15 16 31 32 62 63 64))\n\n(defconstant +mod+ 1000000007)\n\n(defmacro dbg (&rest forms)\n  #+swank (if (= (length forms) 1)\n              `(format *error-output* \"~A => ~A~%\" ',(car forms) ,(car forms))\n              `(format *error-output* \"~A => ~A~%\" ',forms `(,,@forms)))\n  #-swank (declare (ignore forms)))\n\n(declaim (inline println))\n(defun println (obj &optional (stream *standard-output*))\n  (let ((*read-default-float-format* 'double-float))\n    (prog1 (princ obj stream) (terpri stream))))\n\n;; BEGIN_INSERTED_CONTENTS\n(defpackage :cp/modify-macro\n  (:use :cl)\n  (:export #:minf #:maxf #:mulf #:divf #:iorf #:xorf #:andf))\n(in-package :cp/modify-macro)\n\n(macrolet ((def (name fname)\n             `(define-modify-macro ,name (new-value) ,fname)))\n  (def minf min)\n  (def maxf max)\n  (def mulf *)\n  (def divf /)\n  (def iorf logior)\n  (def xorf logxor)\n  (def andf logand))\n\n;; BEGIN_USE_PACKAGE\n(eval-when (:compile-toplevel :load-toplevel :execute)\n  (use-package :cp/modify-macro :cl-user))\n(in-package :cl-user)\n\n;;;\n;;; Body\n;;;\n\n(defconstant +inf+ most-positive-fixnum)\n(defun main ()\n  (let* ((n (read))\n         (as (make-array n :element-type 'int32 :initial-element 0))\n         (graph (make-array n :element-type 'list :initial-element nil))\n         (sizes (make-array n :element-type 'uint31 :initial-element 0))\n         (gs (make-array n :element-type 'uint62 :initial-element +inf+)))\n    (dotimes (i n)\n      (setf (aref as i) (read)))\n    (dotimes (i (- n 1))\n      (let ((u (- (read) 1))\n            (v (- (read) 1)))\n        (push u (aref graph v))\n        (push v (aref graph u))))\n    (sb-int:named-let dfs ((v 0) (parent -1))\n      (let ((size 1))\n        (dolist (child (aref graph v))\n          (unless (= child parent)\n            (dfs child v)\n            (incf size (aref sizes child)))\n          (setf (aref sizes v) size))))\n    (labels ((%merge (dp1 dp2 child)\n               (declare ((simple-array fixnum (*)) dp1 dp2))\n               (let* ((n1 (length dp1))\n                      (n2 (length dp2))\n                      (res-dp (make-array (+ n1 n2) :element-type 'fixnum :initial-element 0)))\n                 \n                 (dotimes (y (length res-dp))\n                   (let ((value +inf+))\n                     (declare (fixnum value))\n                     (loop for i from (max (+ 1 (- y n2)) 0) to (min y (- n1 1))\n                           for j = (- y i)\n                           do (assert (and (<= 0 i (- n1 1))\n                                           (<= 0 j (- n2 1))))\n                              (minf value (+ (aref dp1 i) (aref dp2 j))))\n                     (loop for i from (max (+ 1 (- y n2)) 0) to (min (- y 1) (- n1 1))\n                           for j = (- y i 1)\n                           do (assert (and (<= 0 i (- n1 1))\n                                           (<= 0 j (- n2 1))))\n                           when (< (aref dp2 j) 0)\n                           do (minf value (aref dp1 i)))\n                     (when (<= 0 (- y (aref gs child) 1) (- n1 1))\n                       (minf value (aref dp1 (- y (aref gs child) 1))))\n                     (setf (aref res-dp y) value)))\n                 res-dp)))\n      (let ((dp (sb-int:named-let dfs ((v 0) (parent -1))\n                  (let ((g 0)\n                        (dp (make-array 1 :element-type 'fixnum :initial-element (aref as v))))\n                    (declare (uint62 g))\n                    (dolist (child (aref graph v))\n                      (unless (= child parent)\n                        (let ((child-dp (dfs child v)))\n                          (setq dp (%merge dp child-dp child))\n                          (incf g (min (aref gs child)\n                                       (loop for y below (length child-dp)\n                                             when (< (aref child-dp y) 0)\n                                             do (return (+ y 1))\n                                             finally (return +inf+)))))))\n                    (when (> (aref as v) 0)\n                      (setf (aref gs v) g))\n                    (dbg v g dp)\n                    dp))))\n        (println (min (aref gs 0)\n                      (dotimes (y (length dp) +inf+)\n                        (when (< (aref dp y) 0)\n                          (return y)))))))))\n\n#-swank (main)\n\n;;;\n;;; Test and benchmark\n;;;\n\n#+swank\n(defun get-clipbrd ()\n  (with-output-to-string (out)\n    #+os-windows (run-program \"powershell.exe\" '(\"-Command\" \"Get-Clipboard\") :output out :search t)\n    #+os-unix (run-program \"xsel\" '(\"-b\" \"-o\") :output out :search t)))\n\n#+swank (defparameter *this-pathname* (uiop:current-lisp-file-pathname))\n#+swank (defparameter *dat-pathname* (uiop:merge-pathnames* \"test.dat\" *this-pathname*))\n\n#+swank\n(defun run (&optional thing (out *standard-output*))\n  \"THING := null | string | symbol | pathname\n\nnull: run #'MAIN using the text on clipboard as input.\nstring: run #'MAIN using the string as input.\nsymbol: alias of FIVEAM:RUN!.\npathname: run #'MAIN using the text file as input.\"\n  (let* ((*standard-output* (or out (make-string-output-stream)))\n         (res (etypecase thing\n                (null\n                 (with-input-from-string (*standard-input* (delete #\\Return (get-clipbrd)))\n                   (main)))\n                (string\n                 (with-input-from-string (*standard-input* (delete #\\Return thing))\n                   (main)))\n                (symbol (5am:run! thing))\n                (pathname\n                 (with-open-file (*standard-input* thing)\n                   (main))))))\n    (if out res (get-output-stream-string *standard-output*))))\n\n#+swank\n(defun gen-dat ()\n  (uiop:with-output-file (out *dat-pathname* :if-exists :supersede)\n    (format out \"\")))\n\n#+swank\n(defun bench (&optional (out (make-broadcast-stream)))\n  (time (run *dat-pathname* out)))\n\n#-swank\n(eval-when (:compile-toplevel)\n  (when (and (boundp 'sb-c::*compiler-warning-count*)\n             (> sb-c::*compiler-warning-count* 0))\n    (sb-ext:quit :unix-status 1)))\n\n;; To run: (5am:run! :sample)\n#+swank\n(it.bese.fiveam:test :sample\n  (5am:is\n   (equal \"1\n\"\n          (run \"7\n-2 7 5 6 -8 3 4\n1 2\n2 3\n2 4\n1 5\n5 6\n5 7\n\" nil)))\n  (5am:is\n   (equal \"0\n\"\n          (run \"4\n1 2 3 4\n1 2\n1 3\n1 4\n\" nil)))\n  (5am:is\n   (equal \"5\n\"\n          (run \"6\n10 -1 10 -1 10 -1\n1 2\n2 3\n3 4\n4 5\n5 6\n\" nil)))\n  (5am:is\n   (equal \"3\n\"\n          (run \"8\n-2 3 6 -2 -2 -5 3 2\n3 4\n7 6\n6 2\n8 2\n5 3\n1 8\n3 7\n\" nil)))\n  (5am:is\n   (equal \"3\n\"\n          (run \"10\n3 4 9 6 1 5 -1 10 -10 -10\n7 4\n5 6\n8 1\n9 5\n7 1\n10 3\n2 8\n4 10\n9 2\n\" nil))))\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n  \"bufio\"\n  \"container/list\"\n  \"fmt\"\n  \"os\"\n  \"strconv\"\n  \"strings\"\n)\n\nconst INF32 = 100000000\nconst INF64 int64 = 1000000000000000000\n\nvar n int\nvar a []int64\nvar tree [][]int\n\nfunc main() {\n  input := Input{bufio.NewReaderSize(os.Stdin,10000)}\n  n = input.NextInt()\n  a = input.NextIntArray()\n  tree = make([][]int,n)\n  for i:=0;i<n-1;i++ {\n    u,v := input.NextInts()\n    tree[u-1] = append(tree[u-1],v-1)\n    tree[v-1] = append(tree[v-1],u-1)\n  }\n  fmt.Println(solve())\n}\nfunc min32(n,m int) int {\n  if n < m { return n }\n  return m\n}\nfunc min64(n,m int64) int64 {\n  if n < m { return n }\n  return m\n}\nfunc fill(a *[]int64,n int64) {\n  for i:=0;i<len(*a);i++ { (*a)[i] = n }\n}\n\nvar order []Node\nvar dp1 [][]int64\nvar dp2 [][]int64\nvar dp3 []int\n\nfunc solve() int {\n  order_from_leaf()\n  dp1 = make([][]int64,n)\n  dp2 = make([][]int64,n)\n  dp3 = make([]int,n)\n  for _,node := range order { merge(node) }\n  m := INF32\n  for i:=0;i<n;i++ {\n    if dp1[0][i] != INF64 { m = min32(m,i) }\n    if dp2[0][i] < 0 { m = min32(m,i) }\n  }\n  return m\n}\nfunc merge(node Node) {\n  id := node.id\n  dp1[id] = []int64{INF64}\n  dp2[id] = []int64{INF64}\n  if a[id] > 0 {\n    dp1[id][0] = a[id]\n  } else {\n    dp2[id][0] = a[id]\n  }\n  c := 1\n  for _,e := range tree[id] {\n    if e == node.par { continue }\n    tmp1 := make([]int64,c+dp3[e])\n    fill(&tmp1,INF64)\n    tmp2 := make([]int64,c+dp3[e])\n    fill(&tmp2,INF64)\n    for i:=0;i<c;i++ {\n      for j:=0;j<dp3[e];j++ {\n        if dp1[id][i] != INF64 {\n          if dp1[e][j] != INF64 {\n            tmp1[i+j] = min64(tmp1[i+j],dp1[id][i]+dp1[e][j])\n          }\n          if dp2[e][j] != INF64 {\n            tmp2[i+j] = min64(tmp2[i+j],dp1[id][i]+dp2[e][j])\n          }\n          if dp1[e][j] != INF64 || dp2[e][j] < 0 {\n            tmp1[i+j+1] = min64(tmp1[i+j+1],dp1[id][i])\n          }\n        }\n        if dp2[id][i] != INF64 {\n          if dp1[e][j] != INF64 {\n            tmp2[i+j] = min64(tmp2[i+j],dp2[id][i]+dp1[e][j])\n          }\n          if dp2[e][j] != INF64 {\n            tmp2[i+j] = min64(tmp2[i+j],dp2[id][i]+dp2[e][j])\n          }\n          if dp1[e][j] != INF64 || dp2[e][j] < 0 {\n            tmp2[i+j+1] = min64(tmp2[i+j+1],dp2[id][i])\n          }\n        }\n      }\n    }\n    dp1[id] = tmp1\n    dp2[id] = tmp2\n    c += dp3[e]\n  }\n  dp3[id] = c\n}\nfunc order_from_leaf() {\n  order = make([]Node,n)\n  q := list.New()\n  q.PushBack(Node{-1,0})\n  i := n-1\n  for q.Len() > 0 {\n    p := q.Remove(q.Front()).(Node)\n    order[i] = p\n    i--\n    for _,e := range tree[p.id] {\n      if e == p.par { continue }\n      q.PushBack(Node{p.id,e})\n    }\n  }\n}\n\ntype Node struct { par,id int }\n\ntype Input struct { reader *bufio.Reader }\nfunc(i *Input) NextLine() string {\n  var buffer []byte\n  for {\n    line,isPrefix,err := i.reader.ReadLine()\n    if err != nil { panic(err) }\n    buffer = append(buffer,line...)\n    if !isPrefix { break }\n  }\n  return string(buffer)\n}\nfunc(i *Input) NextInt() int {\n  x,_ := strconv.Atoi(i.NextLine())\n  return x\n}\nfunc(i *Input) NextInts() (int,int) {\n  s := strings.Fields(i.NextLine())\n  x,_ := strconv.Atoi(s[0])\n  y,_ := strconv.Atoi(s[1])\n  return x,y\n}\nfunc(i *Input) NextIntArray() []int64 {\n  s := strings.Fields(i.NextLine())\n  a := make([]int64,len(s))\n  for i:=0;i<len(s);i++ { a[i],_ = strconv.ParseInt(s[i],10,64) }\n  return a\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.string, std.conv;\nimport std.range, std.algorithm, std.array, std.typecons, std.container;\nimport std.math, std.numeric, core.bitop;\n\nenum inf3 = 1_001_001_001;\nenum inf6 = 1_001_001_001_001_001_001L;\nenum mod = 1_000_000_007L;\n\n\nvoid main() {\n    int n;\n    scan(n);\n    auto a = readln.split.to!(long[]);\n    auto adj = new int[][](n, 0);\n    foreach (i ; 0 .. n - 1) {\n        int u, v;\n        scan(u, v);\n        u--, v--;\n        adj[u] ~= v;\n        adj[v] ~= u;\n    }\n\n    auto dp = new long[][][](2, n, 0);\n    auto size = new int[](n);\n\n    void dfs(int v, int p) {\n        size[v] = 1;\n        dp[0][v] = new long[](2);\n        dp[0][v][] = inf6;\n        dp[0][v][1] = a[v];\n        dp[1][v] = new long[](2);\n        dp[1][v][] = inf6;\n        if (a[v] > 0) dp[1][v][1] = a[v];\n\n        foreach (u ; adj[v]) {\n            if (u == p) continue;\n            dfs(u, v);\n\n            auto next0 = new long[](size[v] + size[u] + 1);\n            next0[] = inf6;\n            //next0[0 .. dp[0][v].length] = dp[0][v][];\n\n            auto next1 = new long[](size[v] + size[u] + 1);\n            next1[] = inf6;\n            //next1[0 .. dp[1][v].length] = dp[1][v][];\n\n            foreach (i ; 1 .. size[v] + 1) {\n                foreach (j ; 1 .. size[u] + 1) {\n                    next0[i + j - 1] = min(next0[i + j - 1], dp[0][v][i] + dp[0][u][j]);\n                    if (dp[0][u][j] < 0 || dp[1][u][j] < inf6) next0[i + j] = min(next0[i + j], dp[0][v][i]);\n\n                    next1[i + j - 1] = min(next1[i + j - 1], dp[1][v][i] + dp[1][u][j]);\n                    if (dp[0][u][j] < 0 || dp[1][u][j] < inf6) next1[i + j] = min(next1[i + j], dp[1][v][i]);\n                }\n            }\n\n            dp[0][v] = next0;\n            //dp[0][v][0] = 0;\n            dp[1][v] = next1;\n            //dp[1][v][0] = 0;\n            size[v] += size[u];\n        }\n\n    }\n\n    dfs(0, -1);\n\n    debug {\n        foreach (i ; 0 .. n) {\n            writefln(\"%d:\", i);\n            writeln(dp[0][i]);\n            writeln(dp[1][i]);\n        }\n    }\n\n    int ans = -1;\n\n    foreach (i ; 1 .. n + 1) {\n        if (dp[0][0][i] < 0 || dp[1][0][i] < inf6) {\n            ans = i - 1;\n            break;\n        }\n    }\n\n    writeln(ans);\n}\n\n\n\n\n\n\nvoid scan(T...)(ref T args) {\n    import std.stdio : readln;\n    import std.algorithm : splitter;\n    import std.conv : to;\n    import std.range.primitives;\n\n    auto line = readln().splitter();\n    foreach (ref arg; args) {\n        arg = line.front.to!(typeof(arg));\n        line.popFront();\n    }\n    assert(line.empty);\n}\n\nvoid fillAll(R, T)(ref R arr, T value) {\n    static if (is(typeof(arr[] = value))) {\n        arr[] = value;\n    }\n    else {\n        foreach (ref e; arr) {\n            fillAll(e, value);\n        }\n    }\n}\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop, core.stdc.string;\n\nimmutable long INF = 1L<<59;\n\nvoid main() {\n    auto N = readln.chomp.to!int;\n    auto A = readln.split.map!(to!long).array;\n    auto G = new int[][](N);\n    foreach (i; 0..N-1) {\n        auto s = readln.split.map!(to!int);\n        G[s[0]-1] ~= s[1]-1;\n        G[s[1]-1] ~= s[0]-1;\n    }\n\n    auto children = new int[](N);\n    auto sub = new int[](N);\n\n    int dfs1(int n, int p) {\n        sub[n] = 1;\n        foreach (m; G[n]) if (m != p) sub[n] += dfs1(m, n), children[n] += 1;\n        return sub[n];\n    }\n\n    dfs1(0, -1);\n\n    /*\n      dp1[i][j]: 頂点iを根とする部分木で、辺をj本切っており、iを含む連結成分にコンピュータがないときの最小コスト\n      dp2[i][j]: 頂点iを根とする部分木で、辺をj本切っており、iを含む連結成分にコンピュータがあるときの最小コスト\n     */\n    auto dp1 = new long[][][](N);\n    auto dp2 = new long[][][](N);\n    foreach (i; 0..N) {\n        dp1[i] = new long[][](children[i]+1, sub[i]+1);\n        dp2[i] = new long[][](children[i]+1, sub[i]+1);\n        foreach (j; 0..children[i]+1) dp1[i][j][] = dp2[i][j][] = INF;\n    }\n\n    int dfs(int n, int p) {\n        if (A[n] > 0) {\n            dp1[n][0][0] = A[n];\n            dp2[n][0][0] = A[n];\n        } else {\n            dp2[n][0][0] = A[n];\n        }\n\n        int s = 1;\n        int c = 0;\n\n        foreach (m; G[n]) {\n            if (m == p) continue;\n            int mc = children[m];\n            int x = dfs(m, n);\n            foreach (i; 0..s) {\n                foreach (j; 0..sub[m]) {\n                    // 切る\n                    if (dp1[m][mc][j] != INF || dp2[m][mc][j] < 0) {\n                        dp1[n][c+1][i+j+1] = min(dp1[n][c+1][i+j+1], dp1[n][c][i]);\n                        dp2[n][c+1][i+j+1] = min(dp2[n][c+1][i+j+1], dp2[n][c][i]);\n                    }\n                    // 切らない\n                    dp1[n][c+1][i+j] = min(dp1[n][c+1][i+j], dp1[n][c][i] + dp1[m][mc][j]);\n                    dp2[n][c+1][i+j] = min(dp2[n][c+1][i+j], dp2[n][c][i] + dp1[m][mc][j], dp2[n][c][i] + dp2[m][mc][j], dp1[n][c][i] + dp2[m][mc][j]);\n                }\n            }\n            s += x;\n            c += 1;\n        }\n\n        return s;\n    }\n\n    dfs(0, -1);\n\n    int ans = 1 << 29;\n    foreach (i; 0..N) if (dp1[0][children[0]][i] != INF) ans = min(ans, i);\n    foreach (i; 0..N) if (dp2[0][children[0]][i] < 0) ans = min(ans, i);\n    ans.writeln;\n}\n"
  },
  {
    "language": "D",
    "code": "import std.conv, std.stdio, std.string;\nimport std.algorithm, std.array, std.bigint, std.container, std.math, std.range, std.regex, std.typecons;\nimport core.bitop;\n\nclass EOFException : Throwable { this() { super(\"EOF\"); } }\nstring[] tokens;\nstring readToken() { for (; tokens.empty; ) { if (stdin.eof) { throw new EOFException; } tokens = readln.split; } auto token = tokens.front; tokens.popFront; return token; }\nint readInt() { return readToken().to!int; }\nlong readLong() { return readToken().to!long; }\nreal readReal() { return readToken().to!real; }\n\nvoid chmin(T)(ref T t, in T f) { if (t > f) t = f; }\nvoid chmax(T)(ref T t, in T f) { if (t < f) t = f; }\n\nint binarySearch(T)(in T[] as, in bool delegate(T) test) { int low = -1, upp = cast(int)(as.length); for (; low + 1 < upp; ) { int mid = (low + upp) >> 1; (test(as[mid]) ? low : upp) = mid; } return upp; }\nint lowerBound(T)(in T[] as, in T val) { return as.binarySearch((T a) => (a < val)); }\nint upperBound(T)(in T[] as, in T val) { return as.binarySearch((T a) => (a <= val)); }\n\n\nimmutable INF = 10L^^18;\n\nint N;\nlong[] A;\nint[] U, V;\n\nint[][] G;\nint[] sz;\nlong[][][] dp;\n\nvoid dfs(int u, int p) {\n  foreach (v; G[u]) {\n    if (v != p) {\n      dfs(v, u);\n    }\n  }\n  sz[u] = 1;\n  dp[u] = [[INF, INF]];\n  chmin(dp[u][0][(A[u] < 0) ? 1 : 0], A[u]);\n  foreach (v; G[u]) {\n    if (v != p) {\n      auto nxt = new long[][](sz[u] + sz[v], 2);\n      foreach (x; 0 .. nxt.length) {\n        nxt[x][] = INF;\n      }\n      foreach (x; 0 .. sz[u]) foreach (s; 0 .. 2) {\n        if (dp[u][x][s] < INF) {\n          foreach (y; 0 .. sz[v]) foreach (t; 0 .. 2) {\n            if (dp[v][y][t] < INF) {\n              // connect\n              {\n                chmin(nxt[x + y][s | t], dp[u][x][s] + dp[v][y][t]);\n              }\n              // cut\n              if (t == 0 || dp[v][y][t] < 0) {\n                chmin(nxt[x + y + 1][s], dp[u][x][s]);\n              }\n            }\n          }\n        }\n      }\n      sz[u] += sz[v];\n      dp[u] = nxt;\n    }\n  }\n}\n\nvoid main() {\n  try {\n    for (; ; ) {\n      N = readInt();\n      A = new long[N];\n      foreach (u; 0 .. N) {\n        A[u] = readLong();\n      }\n      U = new int[N - 1];\n      V = new int[N - 1];\n      foreach (i; 0 .. N - 1) {\n        U[i] = readInt() - 1;\n        V[i] = readInt() - 1;\n      }\n      G = new int[][N];\n      foreach (i; 0 .. N - 1) {\n        G[U[i]] ~= V[i];\n        G[V[i]] ~= U[i];\n      }\n      sz = new int[N];\n      dp = new long[][][N];\n      dfs(0, -1);\n      debug {\n        writefln(\"sz = %s\", sz);\n        foreach (u; 0 .. N) {\n          writefln(\"dp[%s] = %s\", u, dp[u]);\n        }\n      }\n      int ans = N;\n      foreach (x; 0 .. N) foreach (s; 0 .. 2) {\n        if (dp[0][x][s] < INF) {\n          if (s == 0 || dp[0][x][s] < 0) {\n            chmin(ans, x);\n          }\n        }\n      }\n      writeln(ans);\n    }\n  } catch (EOFException e) {\n  }\n}\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop, core.stdc.string;\n\nimmutable long INF = 1L<<59;\n\nvoid main() {\n    auto N = readln.chomp.to!int;\n    auto A = readln.split.map!(to!long).array;\n    auto G = new int[][](N);\n    foreach (i; 0..N-1) {\n        auto s = readln.split.map!(to!int);\n        G[s[0]-1] ~= s[1]-1;\n        G[s[1]-1] ~= s[0]-1;\n    }\n\n    auto sub = new int[](N);\n\n    int dfs1(int n, int p) {\n        sub[n] = 1;\n        foreach (m; G[n]) if (m != p) sub[n] += dfs1(m, n);\n        return sub[n];\n    }\n\n    dfs1(0, -1);\n\n    /*\n      dp1[i][j]: 頂点iを根とする部分木で、辺をj本切っており、iを含む連結成分にコンピュータがないときの最小コスト\n      dp2[i][j]: 頂点iを根とする部分木で、辺をj本切っており、iを含む連結成分にコンピュータがあるときの最小コスト\n     */\n    auto dp1 = new long[][](N, N+1);\n    auto dp2 = new long[][](N, N+1);\n    foreach (i; 0..N) dp1[i][] = dp2[i][] = INF;\n\n    void dfs(int n, int p) {\n        auto dpdp1 = new long[][](2, sub[n]+1);\n        auto dpdp2 = new long[][](2, sub[n]+1);\n        foreach (i; 0..2) dpdp1[i][] = dpdp2[i][] = INF;\n\n        if (A[n] > 0) {\n            dpdp1[0][0] = A[n];\n            dpdp2[0][0] = A[n];\n        } else {\n            dpdp2[0][0] = A[n];\n        }\n\n        int cur = 0;\n        int tar = 1;\n\n        foreach (m; G[n]) {\n            if (m == p) continue;\n            dfs(m, n);\n            dpdp1[tar][] = INF;\n            dpdp2[tar][] = INF;\n            foreach_reverse (i; 0..sub[n]) {\n                foreach (j; 0..sub[m]) {\n                    if (i + j >= sub[n]) continue;\n                    // 切る\n                    if (dp1[m][j] != INF || dp2[m][j] < 0) {\n                        dpdp1[tar][i+j+1] = min(dpdp1[tar][i+j+1], dpdp1[cur][i]);\n                        dpdp2[tar][i+j+1] = min(dpdp2[tar][i+j+1], dpdp2[cur][i]);\n                    }\n                    // 切らない\n                    dpdp1[tar][i+j] = min(dpdp1[tar][i+j], dpdp1[cur][i] + dp1[m][j]);\n                    dpdp2[tar][i+j] = min(dpdp2[tar][i+j], dpdp2[cur][i] + dp1[m][j], dpdp2[cur][i] + dp2[m][j], dpdp1[cur][i] + dp2[m][j]);\n                }\n            }\n            swap(cur, tar);\n        }\n\n        foreach (j; 0..sub[n]) {\n            dp1[n][j] = dpdp1[cur][j];\n            dp2[n][j] = dpdp2[cur][j];\n        }\n    }\n\n    dfs(0, -1);\n\n    int ans = 1 << 29;\n    foreach (i; 0..N) if (dp1[0][i] != INF) ans = min(ans, i);\n    foreach (i; 0..N) if (dp2[0][i] < 0) ans = min(ans, i);\n    ans.writeln;\n}\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop, core.stdc.string;\n\nimmutable long INF = 1L<<59;\n\nvoid main() {\n    auto N = readln.chomp.to!int;\n    auto A = readln.split.map!(to!long).array;\n    auto G = new int[][](N);\n    foreach (i; 0..N-1) {\n        auto s = readln.split.map!(to!int);\n        G[s[0]-1] ~= s[1]-1;\n        G[s[1]-1] ~= s[0]-1;\n    }\n\n    auto sub = new int[](N);\n\n    int dfs1(int n, int p) {\n        sub[n] = 1;\n        foreach (m; G[n]) if (m != p) sub[n] += dfs1(m, n);\n        return sub[n];\n    }\n\n    dfs1(0, -1);\n\n    /*\n      dp1[i][j]: 頂点iを根とする部分木で、辺をj本切っており、iを含む連結成分にコンピュータがないときの最小コスト\n      dp2[i][j]: 頂点iを根とする部分木で、辺をj本切っており、iを含む連結成分にコンピュータがあるときの最小コスト\n     */\n    auto dp1 = new long[][](N, N+1);\n    auto dp2 = new long[][](N, N+1);\n    foreach (i; 0..N) dp1[i][] = dp2[i][] = INF;\n\n    void dfs(int n, int p) {\n        auto dpdp1 = new long[][](2, sub[n]+1);\n        auto dpdp2 = new long[][](2, sub[n]+1);\n        foreach (i; 0..2) dpdp1[i][] = dpdp2[i][] = INF;\n\n        if (A[n] > 0) {\n            dpdp1[0][0] = A[n];\n            dpdp2[0][0] = A[n];\n        } else {\n            dpdp2[0][0] = A[n];\n        }\n\n        int cur = 0;\n        int tar = 1;\n\n        foreach (m; G[n]) {\n            if (m == p) continue;\n            dfs(m, n);\n            dpdp1[tar][] = INF;\n            dpdp2[tar][] = INF;\n            foreach_reverse (i; 0..sub[n]) {\n                foreach (j; 0..sub[m]) {\n                    if (i + j >= sub[n]) break;\n                    // 切る\n                    if (dp1[m][j] != INF || dp2[m][j] < 0) {\n                        dpdp1[tar][i+j+1] = min(dpdp1[tar][i+j+1], dpdp1[cur][i]);\n                        dpdp2[tar][i+j+1] = min(dpdp2[tar][i+j+1], dpdp2[cur][i]);\n                    }\n                    // 切らない\n                    dpdp1[tar][i+j] = min(dpdp1[tar][i+j], dpdp1[cur][i] + dp1[m][j]);\n                    dpdp2[tar][i+j] = min(dpdp2[tar][i+j], dpdp2[cur][i] + dp1[m][j], dpdp2[cur][i] + dp2[m][j], dpdp1[cur][i] + dp2[m][j]);\n                }\n            }\n            swap(cur, tar);\n        }\n\n        foreach (j; 0..sub[n]) {\n            dp1[n][j] = dpdp1[cur][j];\n            dp2[n][j] = dpdp2[cur][j];\n        }\n    }\n\n    dfs(0, -1);\n\n    int ans = 1 << 29;\n    foreach (i; 0..N) if (dp1[0][i] != INF) ans = min(ans, i);\n    foreach (i; 0..N) if (dp2[0][i] < 0) ans = min(ans, i);\n    ans.writeln;\n}\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.string, std.conv;\nimport std.range, std.algorithm, std.array, std.typecons, std.container;\nimport std.math, std.numeric, core.bitop;\n\nenum inf = 1_001_001_001;\nenum infl = 1_001_001_001_001_001_001L;\nenum mod = 1_000_000_007L;\n\n\nvoid main() {\n    int n;\n    scan(n);\n    auto a = readln.split.to!(long[]);\n    auto adj = new int[][](n, 0);\n    foreach (i ; 0 .. n - 1) {\n        int ui, vi;\n        scan(ui, vi);\n        ui--, vi--;\n        adj[ui] ~= vi;\n        adj[vi] ~= ui;\n    }\n\n    auto chil = new int[][](n, 0);\n    auto cnt = new int[](n);\n\n    int cntDfs(int v, int p) {\n        cnt[v] = 1;\n        foreach (u ; adj[v]) {\n            if (u == p) continue;\n            chil[v] ~= u;\n            cnt[v] += cntDfs(u, v);\n        }\n        return cnt[v];\n    }\n\n    cntDfs(0, -1);\n\n    // dp(0, v, k) = (vをrootとしたsubtreeにおいて、CCがk個で、vを含むCC以外は条件を満たすときの、vを含むCCの総和の最小)\n    // dp(1, v, k) = (..., vを含むCC以外は全て条件を満たし、vを含むCCは全て正のときの、vを含むCCの総和の最小)\n    auto dp = new long[][][](2, n + 1, n + 1);\n    auto dp2 = new long[][][](2, n + 1, n + 1);\n    fillAll(dp, infl);\n    fillAll(dp2, infl);\n\n    void dfs(int v) {\n        if (chil[v].empty) {\n            dp[0][v][1] = a[v];\n            if (a[v] > 0) dp[1][v][1] = a[v];\n            return;\n        }\n\n        foreach (u ; chil[v]) {\n            dfs(u);\n        }\n        \n        auto m = chil[v].length.to!int;\n\n        foreach (b ; 0 .. 2) {\n            foreach (i ; 0 .. m + 1) {\n                foreach (k ; 0 .. cnt[v] + 1) {\n                    dp2[b][i][k] = infl;\n                }\n            }\n        }\n\n        dp2[0][0][1] = a[v];\n        if (a[v] > 0) dp2[1][0][1] = a[v];\n\n\n        debug {\n            writeln(\"chil[v]:\", chil[v]);\n            writeln(dp2[0][0]);\n            writeln(dp2[1][0]);\n        }\n\n        foreach (i ; 1 .. m + 1) {\n            auto u = chil[v][i - 1];\n\n            \n            foreach (k ; 1 .. cnt[v] + 1) {\n                foreach (b ; 0 .. (a[v] > 0 ? 2 : 1)) {\n                    foreach (j ; 1 .. min(k, cnt[u]) + 1) {\n                        // 繋がないときは切ったところが条件を満たすか確かめる\n                        if (dp[0][u][j] < 0 || dp[1][u][j] < infl) {\n                            dp2[b][i][k] = min(dp2[b][i][k], dp2[b][i-1][k-j]);\n                        }\n\n                        // 繋ぐときはどうでもいい\n                        if (j > 0) {\n                            dp2[b][i][k] = min(dp2[b][i][k], dp2[b][i-1][k+1-j] + dp[1][u][j]);\n                            if (b == 0) dp2[b][i][k] = min(dp2[b][i][k], dp2[b][i-1][k+1-j] + dp[0][u][j]);\n                        }\n                    }\n                }\n            }\n\n            debug {\n                foreach (b ; 0 .. 2) {\n                    writefln(\"v = %d, b = %b, i = %d, %s\", v, b, i, dp2[b][i]);\n                }\n                writeln;\n            }\n\n        }\n\n        foreach (k ; 1 .. cnt[v] + 1) {\n            dp[0][v][k] = dp2[0][m][k];\n            dp[1][v][k] = dp2[1][m][k];\n        }\n    }\n\n    dfs(0);\n\n    debug {\n        foreach (v; 0 .. n) {\n            foreach (b ; 0 .. 2) {\n                writefln(\"v = %d, b = %b, %s\", v, b, dp[b][v]);\n            }\n        }\n    }\n\n    int ans;\n\n    foreach (i ; 1 .. n + 1) {\n        if (dp[0][0][i] < 0 || dp[1][0][i] < inf) {\n            ans = i;\n            break;\n        }\n    }\n\n    ans--;\n\n    writeln(ans);\n}\n\n\n\n\n\nvoid scan(T...)(ref T args) {\n    import std.stdio : readln;\n    import std.algorithm : splitter;\n    import std.conv : to;\n    import std.range.primitives;\n\n    auto line = readln().splitter();\n    foreach (ref arg; args) {\n        arg = line.front.to!(typeof(arg));\n        line.popFront();\n    }\n    assert(line.empty);\n}\n\nvoid fillAll(R, T)(ref R arr, T value) {\n    static if (is(typeof(arr[] = value))) {\n        arr[] = value;\n    }\n    else {\n        foreach (ref e; arr) {\n            fillAll(e, value);\n        }\n    }\n}\n"
  },
  {
    "language": "Nim",
    "code": "#{{{ header\n{.hints:off warnings:off optimization:speed.}\nimport algorithm, sequtils, tables, macros, math, sets, strutils\nwhen defined(MYDEBUG):\n  import header\n\nproc scanf(formatstr: cstring){.header: \"<stdio.h>\", varargs.}\nproc getchar(): char {.header: \"<stdio.h>\", varargs.}\nproc nextInt(): int = scanf(\"%lld\",addr result)\nproc nextFloat(): float = scanf(\"%lf\",addr result)\nproc nextString(): string =\n  var get = false\n  result = \"\"\n  while true:\n    let c = getchar()\n    if int(c) > int(' '):\n      get = true\n      result.add(c)\n    else:\n      if get: break\n      get = false\ntype SomeSignedInt = int|int8|int16|int32|int64|BiggestInt\ntype SomeUnsignedInt = uint|uint8|uint16|uint32|uint64\ntype SomeInteger = SomeSignedInt|SomeUnsignedInt\ntype SomeFloat = float|float32|float64|BiggestFloat\ntemplate `max=`*(x,y:typed):void = x = max(x,y)\ntemplate `min=`*(x,y:typed):void = x = min(x,y)\ntemplate inf(T): untyped = \n  when T is SomeFloat: T(Inf)\n  elif T is SomeInteger: ((T(1) shl T(sizeof(T)*8-2)) - (T(1) shl T(sizeof(T)*4-1)))\n  else: assert(false)\n\nproc sort[T](v: var seq[T]) = v.sort(cmp[T])\n\nproc discardableId[T](x: T): T {.discardable.} =\n  return x\nmacro `:=`(x, y: untyped): untyped =\n  if (x.kind == nnkIdent):\n    return quote do:\n      when declaredInScope(`x`):\n        `x` = `y`\n      else:\n        var `x` = `y`\n      discardableId(`x`)\n  else:\n    return quote do:\n      `x` = `y`\n      discardableId(`x`)\nmacro dump*(x: typed): untyped =\n  let s = x.toStrLit\n  let r = quote do:\n    debugEcho `s`, \" = \", `x`\n  return r\n#}}}\n\nvar N:int\nvar A:seq[int]\nvar U:seq[int]\nvar V:seq[int]\n\n\n#{{{ input part\nblock:\n  N = nextInt()\n  A = newSeqWith(N, nextInt())\n  U = newSeqWith(N-1, 0)\n  V = newSeqWith(N-1, 0)\n  for i in 0..<N-1:\n    U[i] = nextInt() - 1\n    V[i] = nextInt() - 1\n#}}}\n\n#{{{ Graph\nimport sequtils\n\ntype\n  Edge[T] = object\n    src,dst:int\n    weight:T\n    rev:int\n  Edges[T] = seq[Edge[T]]\n  Graph[T] = seq[seq[Edge[T]]]\n\nproc initEdge[T](src,dst:int,weight:T,rev:int = -1):Edge[T] =\n  var e:Edge[T]\n  e.src = src\n  e.dst = dst\n  e.weight = weight\n  e.rev = rev\n  return e\n\nproc initGraph[T](n:int):Graph[T] =\n  return newSeqWith(n,newSeq[Edge[T]]())\n\nproc addBiEdge[T](g:var Graph[T],src,dst:int,weight:T=1):void =\n  g[src].add(initEdge(src,dst,weight,g[dst].len))\n  g[dst].add(initEdge(dst,src,weight,g[src].len-1))\n\nproc addEdge[T](g:var Graph[T],src,dst:int,weight:T=1):void =\n  g[src].add(initEdge(src,dst,weight,-1))\n\nproc `<`[T](l,r:Edge[T]):bool = l.weight < r.weight\n#}}}\n\ng := initGraph[int](N)\n\nfor i in 0..<N - 1: g.addBiEdge(U[i], V[i])\n\nproc merge(a,b:seq[int], n:int):seq[int] =\n  result = newSeqWith(a.len + b.len, int.inf)\n  # cut b\n  var t = 0\n  while t < b.len:\n    if b[t] < 0: break\n    t += 1\n  if t < b.len:\n    for i in 0..<a.len:\n      result[i + t + 1].min=a[i]\n  if n != int.inf:\n    for i in 0..<a.len:\n      result[i + n + 1].min=a[i]\n  # not cut b\n  for i in 0..<a.len:\n    for j in 0..<b.len:\n      result[i + j].min=a[i] + b[j]\n  for i in 0..<result.len - 1:\n    result[i + 1].min=result[i]\n\nproc dfs(u:int, p = -1):(seq[int], int) =\n  v := newSeq[int](1)\n  var n: int\n  if A[u] > 0:\n    n = 0\n  else:\n    n = int.inf\n  v[0] = A[u]\n  for e in g[u]:\n    if e.dst == p: continue\n    var (v2, n2) = dfs(e.dst, u)\n    v = merge(v, v2, n2)\n    if n < int.inf:\n      # cut\n      var t = 0\n      while t < v2.len:\n        if v2[t] < 0: break\n        t += 1\n      if t == v2.len: t = int.inf\n      else: t += 1\n      if n2 != int.inf: t.min=n2\n      if t != int.inf: n += t\n  return (v, n)\n\nlet (v, n) = dfs(0)\n\nans := int.inf\nfor i in 0..<v.len:\n  if v[i] < 0: ans.min= i\nans.min=n\n\necho ans\n"
  },
  {
    "language": "Nim",
    "code": "import strutils\nimport sequtils\nimport algorithm\nimport math\nimport queues\nimport tables\nimport sets\nimport future\n\nconst INF* = int(1e18 + 373)\n\nproc readLine*(): string =\n  stdin.readLine()\nproc readSeq*(): seq[string] =\n  readLine().strip().split()\nproc readSeq*(n: Natural): seq[string] =\n  result = newSeq[string](n)\n  for i in 0..<n:\n    result[i] = readLine().strip()\nproc readInt1*(): int =\n  readSeq().map(parseInt)[0]\nproc readInt2*(): (int, int) =\n  let a = readSeq().map(parseInt)\n  return (a[0], a[1])\nproc readInt3*(): (int, int, int) =\n  let a = readSeq().map(parseInt)\n  return (a[0], a[1], a[2])\nproc readInt4*(): (int, int, int, int) =\n  let a = readSeq().map(parseInt)\n  return (a[0], a[1], a[2], a[3])\nproc newSeqWith*[T](n: Natural; e: T): seq[T] =\n  result = newSeq[T](n)\n  for i in 0..<n:\n    result[i] = e\ntype seq2*[T] = seq[seq[T]]\nproc newSeq2*[T](n1, n2: Natural): seq2[T] =\n  newSeqWith(n1, newSeq[T](n2))\ntype seq3*[T] = seq[seq[seq[T]]]\nproc newSeq3*[T](n1, n2, n3: Natural): seq3[T] =\n  newSeqWith(n1, newSeqWith(n2, newSeq[T](n3)))\n\n#------------------------------------------------------------------------------#\nproc toRootedTree(g: seq2[int]; v, p: int; res: var seq2[int]) =\n  for u in g[v]:\n    if u == p:\n      continue\n    res[v].add(u)\n    toRootedTree(g, u, v, res)\n\nproc partialTreeWeight(g: seq2[int]; v: int; res: var seq[int]): int =\n  var sum = 1\n  for u in g[v]:\n    sum += partialTreeWeight(g, u, res)\n  res[v] = sum\n  return sum\n\nproc dfs(g: seq2[int]; a, w: seq[int]; v: int; dp1, dp2: var seq2[int]) =\n  if g[v].len() == 0:\n    dp1[v] = @[ (if a[v] > 0: a[v] else: INF) ]\n    dp2[v] = @[ a[v] ]\n    return\n\n  for u in g[v]:\n    dfs(g, a, w, u, dp1, dp2)\n\n  let deg = g[v].len()\n\n  # dp1\n  if a[v] < 0:\n    dp1[v] = newSeq[int](w[v])\n    dp1[v].fill(INF)\n  else:\n    var subDp1 = newSeq2[int](deg + 1, 0)\n\n    subDp1[0] = @[ a[v] ]\n\n    for i in 1..deg:\n      let u = g[v][i - 1]\n      subDp1[i] = newSeq[int](subDp1[i - 1].len() + w[g[v][i - 1]])\n      subDp1[i].fill(INF)\n      for jL in 0..<subDp1[i - 1].len():\n        for jR in 0..<w[u]:\n          if subDp1[i - 1][jL] != INF and dp1[u][jR] != INF:\n            subDp1[i][jL + jR] = min(subDp1[i][jL + jR], subDp1[i - 1][jL] + dp1[u][jR])\n          if subDp1[i - 1][jL] != INF and (dp1[u][jR] != INF or dp2[u][jR] < 0):\n            subDp1[i][jL + jR + 1] = min(subDp1[i][jL + jR + 1], subDp1[i - 1][jL])\n\n    dp1[v] = subDp1[deg]\n\n  # dp2\n  var subDp2 = newSeq2[int](deg + 1, 0)\n  subDp2[0] = @[ a[v] ]\n\n  for i in 1..deg:\n    let u = g[v][i - 1]\n    subDp2[i] = newSeq[int](subDp2[i - 1].len() + w[u])\n    subDp2[i].fill(INF)\n    for jL in 0..<subDp2[i - 1].len():\n      for jR in 0..<w[u]:\n        if subDp2[i - 1][jL] != INF and dp2[u][jR] != INF:\n          subDp2[i][jL + jR] = min(subDp2[i][jL + jR], subDp2[i - 1][jL] + dp2[u][jR])\n        if subDp2[i - 1][jL] != INF and (dp2[u][jR] < 0 or dp1[u][jR] != INF):\n          subDp2[i][jL + jR + 1] = min(subDp2[i][jL + jR + 1], subDp2[i - 1][jL])\n\n  dp2[v] = subDp2[deg]\n\nproc main() =\n  let n = readInt1()\n  let a = readSeq().map(parseInt)\n\n  var g = newSeq2[int](n, 0)\n  for i in 0..<n - 1:\n    let (u, v) = readInt2()\n    g[u - 1].add(v - 1)\n    g[v - 1].add(u - 1)\n\n  var gg = newSeq2[int](n, 0)\n  toRootedTree(g, 0, -1, gg)\n\n  var w = newSeq[int](n)\n  discard partialTreeWeight(gg, 0, w)\n\n  var dp1 = newSeq2[int](n, 0)\n  var dp2 = newSeq2[int](n, 0)\n  dfs(gg, a, w, 0, dp1, dp2)\n\n  var ans = INF\n  for i in countdown(n - 1, 0):\n    if dp1[0][i] != INF:\n      ans = min(ans, i)\n\n  for i in countdown(n - 1, 0):\n    if dp2[0][i] != INF and dp2[0][i] < 0:\n      ans = min(ans, i)\n\n  echo ans\n\nmain()\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\nN=int(input())\nA=list(map(int,input().split()))\nedge=[[] for i in range(N)]\nfor _ in range(N-1):\n    u,v=map(int,input().split())\n    edge[u-1].append(v-1)\n    edge[v-1].append(u-1)\n\nans=[0]\nparent=[-1]*N\nque=deque([(0,-1)])\nwhile que:\n    v,pv=que.popleft()\n    for nv in edge[v]:\n        if nv!=pv:\n            parent[nv]=v\n            ans.append(nv)\n            que.append((nv,v))\nans=ans[::-1]\n\nfor v in range(N):\n    edge[v]=[nv for nv in edge[v] if nv!=parent[v]]\n\n\ndpc=[[] for i in range(N)]\ndpn=[[] for i in range(N)]\nsz=[0]*N\nfor v in ans:\n    sz[v]=1\n    sz[v]=1\n    dpc[v]=[10**18,A[v]]\n    for nv in edge[v]:\n        merged=[10**18]*(sz[v]+sz[nv]+1)\n        for i in range(1+sz[v]):\n            for j in range(1+sz[nv]):\n                merged[i+j-1]=min(merged[i+j-1],dpc[v][i]+min(dpc[nv][j],dpn[nv][j]))\n                if dpn[nv][j]<=10**15:\n                    merged[i+j]=min(merged[i+j],dpc[v][i])\n        dpc[v]=merged\n        sz[v]+=sz[nv]\n    sz[v]=1\n    if A[v]<0:\n        dpn[v]=[10**18]*2\n    else:\n        dpn[v]=[10**18,A[v]]\n    for nv in edge[v]:\n        merged=[10**18]*(sz[v]+sz[nv]+1)\n        for i in range(1,1+sz[v]):\n            for j in range(1,1+sz[nv]):\n                if dpc[nv][j]<0:\n                    merged[i+j]=min(merged[i+j],dpn[v][i])\n                merged[i+j-1]=min(merged[i+j-1],dpn[v][i]+dpn[nv][j])\n                if dpn[nv][j]<=10**15:\n                    merged[i+j]=min(merged[i+j],dpn[v][i])\n        dpn[v]=merged\n        sz[v]+=sz[nv]\n\nans=N\nfor i in range(1,N+1):\n    if dpc[0][i]<0 or dpn[0][i]<=10**15:\n        ans=i\n        break\n\nprint(ans-1)\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\nN=int(input())\n*A,=map(int,input().split())\nG=[[] for _ in range(N)]\nfor i in range(N-1):\n  a,b=map(int,input().split())\n  G[a-1].append(b-1)\n  G[b-1].append(a-1)\n\ndef bfs(s):\n    seen = [0]*N\n    d = [0]*N\n    prev = [0]*N\n    todo = deque()\n    seen[s]=1\n    todo.append(s)\n    while len(todo):\n      a = todo.popleft()\n      for b in G[a]:\n        if seen[b] == 0:\n          seen[b] = 1\n          todo.append(b)\n          d[b] += d[a] + 1\n          prev[b] = a\n    return d, prev\n  \nd,prev = bfs(0)\norder = list(zip(*sorted(enumerate(d),key=lambda x:x[1])))[0]\n\ndp1=[set() for _ in range(N)]\ndp2=[0]*N\n\nfor a in reversed(order):\n  for b in G[a]:\n    if prev[a]==b:continue\n    if len(G[b])==1:\n      if A[b]>0:\n        dp1[b].add(b)\n      dp2[b] = A[b]\n    if len(G[b])==2:\n      for d in G[b]:\n        if d == prev[b]:continue\n        c = d\n      if A[b]>0 and dp1[c] != []:\n        dp1[b] = dp1[c]+[b]\n      elif A[b]>0:\n        dp1[b].add(b)\n      dp2[b] = dp2[c] + A[b]\n    if len(G[b])>2:\n      for c in G[b]:\n        if c == prev[b]:continue\n        if A[b]>0 and dp1[c] != []:\n          dp1[b] |= dp1[c]\n        dp2[b] += dp2[c]\n      if A[b]>0:\n        dp1[b].add(b)\n      dp2[b] += A[b]\n      \nprint(dp1)\nprint(dp2)\n\nDP1 = [{} for _ in range(N)]\nDP2 = [{} for _ in range(N)]\nfor a in order:\n  if a == 0:\n    for i in range(len(G[a])):\n      DP1[a][i] = dp1[G[a][i]]\n      DP2[a][i] = dp2[G[a][i]]\n    continue\n  for b in G[a]:\n    if prev[a]==b:\n      if dp1[a] != [] and "
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10**9)\n\nINF = 10**15\n\nN = int(input())\nAs = list(map(int, input().split()))\nadjL = [[] for _ in range(N)]\nfor _ in range(N-1):\n    U, V = map(int, input().split())\n    U, V = U-1, V-1\n    adjL[U].append(V)\n    adjL[V].append(U)\n\nuseds = [False] * N\nsizes = [0] * N\ndp0 = [[] for _ in range(N)]\ndp1 = [[] for _ in range(N)]\n\ndef dfs(v):\n    useds[v] = True\n    sizes[v] = 1\n    dp0[v] = [As[v] if As[v] > 0 else INF]\n    dp1[v] = [As[v] if As[v] < 0 else INF]\n    for v2 in adjL[v]:\n        if useds[v2]: continue\n        dfs(v2)\n        merged0 = [INF] * (sizes[v]+sizes[v2])\n        merged1 = [INF] * (sizes[v]+sizes[v2])\n        for i in range(sizes[v]):\n            for j in range(sizes[v2]):\n                merged0[i+j] = min(merged0[i+j], dp0[v][i]+dp0[v2][j])\n                merged1[i+j] = min(merged1[i+j], dp0[v][i]+dp1[v2][j])\n                merged1[i+j] = min(merged1[i+j], dp1[v][i]+dp0[v2][j])\n                merged1[i+j] = min(merged1[i+j], dp1[v][i]+dp1[v2][j])\n                if dp0[v2][j] != INF:\n                    merged0[i+j+1] = min(merged0[i+j+1], dp0[v][i])\n                if dp1[v2][j] < 0:\n                    merged0[i+j+1] = min(merged0[i+j+1], dp0[v][i])\n                if dp0[v2][j] != INF:\n                    merged1[i+j+1] = min(merged1[i+j+1], dp1[v][i])\n                if dp1[v2][j] < 0:\n                    merged1[i+j+1] = min(merged1[i+j+1], dp1[v][i])\n        sizes[v] += sizes[v2]\n        dp0[v] = merged0\n        dp1[v] = merged1\n\ndfs(0)\n\nfor i, (v0, v1) in enumerate(zip(dp0[0], dp1[0])):\n    if v0 != INF or v1 < 0:\n        print(i)\n        break\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef MI1(): return map(int1, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LI1(): return list(map(int1, sys.stdin.readline().split()))\ndef LLI1(rows_number): return [LI1() for _ in range(rows_number)]\ndef SI(): return sys.stdin.readline()[:-1]\n\ndef dfs(u=0,pu=-1):\n    if aa[u]<0:dp[u][0][0]=aa[u]\n    else:dp[u][1][0]=aa[u]\n    for v in to[u]:\n        if v==pu:continue\n        dfs(v,u)\n        size[u]+=size[v]\n        ndp0=[inf]*n\n        ndp1=[inf]*n\n        for k in range(size[u]):\n            pre=dp[u][0][k]\n            if pre==inf:continue\n            for kv in range(size[v]):\n                s=dp[v][0][kv]\n                if s!=inf:ndp0[k+kv+1]=min(ndp0[k+kv+1],pre+s)\n                if s<0:ndp0[k+kv]=min(ndp0[k+kv],pre)\n                s = dp[v][1][kv]\n                if s != inf: ndp0[k + kv+1] = min(ndp0[k + kv+1], pre + s)\n                if s != inf: ndp0[k + kv] = min(ndp0[k + kv], pre)\n\n        for k in range(size[u]):\n            pre=dp[u][1][k]\n            if pre==inf:continue\n            for kv in range(size[v]):\n                s=dp[v][0][kv]\n                if s!=inf:ndp0[k+kv+1]=min(ndp0[k+kv+1],pre+s)\n                if s<0:ndp1[k+kv]=min(ndp1[k+kv],pre)\n                s = dp[v][1][kv]\n                if s != inf: ndp1[k + kv+1] = min(ndp1[k + kv+1], pre + s)\n                if s != inf: ndp1[k + kv] = min(ndp1[k + kv], pre)\n\n        dp[u][0]=ndp0\n        dp[u][1]=ndp1\n\ninf=10**16\nn=II()\naa=LI()\nto=[[] for _ in range(n)]\nfor _ in range(n-1):\n    u,v=MI1()\n    to[u].append(v)\n    to[v].append(u)\n\ndp=[[[inf]*n for _ in range(2)] for _ in range(n)]\nsize=[1]*n\ndfs()\n\nmx=0\nfor k in range(n-1,-1,-1):\n    if dp[0][0][k]<0:\n        mx=max(mx,k)\n        break\nfor k in range(n-1,-1,-1):\n    if dp[0][1][k]!=inf:\n        mx=max(mx,k)\n        break\nprint(n-1-mx)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10**5)\ndef input():\n\treturn sys.stdin.buffer.readline()[:-1]\nINF = 10**14\n\nn = int(input())\na = list(map(int, input().split()))\nadj = [[] for _ in range(n)]\nfor _ in range(n-1):\n\tu, v = map(int, input().split())\n\tadj[u-1].append(v-1)\n\tadj[v-1].append(u-1)\n\ndp = [[[INF for _ in range(2)] for _ in range(n)] for _ in range(n)]\nedges = [0 for _ in range(n)]\n\ndef dfs_pre(x, p):\n\tif x != 0 and len(adj[x]) == 1:\n\t\treturn 0\n\tfor v in adj[x]:\n\t\tif v == p:\n\t\t\tcontinue\n\t\telse:\n\t\t\tedges[x] += dfs_pre(v, x) + 1\n\treturn edges[x]\n\ndfs_pre(0, -1)\n\ndef dfs(x, p):\n\tfor v in adj[x]:\n\t\tif v != p:\n\t\t\tdfs(v, x)\n\tsub = [[[INF for _ in range(2)] for _ in range(n)] for _ in range(n)]\n\tsub[0][0][1] = a[x]\n\tif a[x] > 0:\n\t\tsub[0][0][0] = a[x]\n\ti = 0\n\te_cnt = 0\n\tfor v in adj[x]:\n\t\tif v == p:\n\t\t\tcontinue\n\t\tfor j1 in range(e_cnt+1):\n\t\t\tfor j2 in range(edges[v]+1):\n\t\t\t\tsub[i+1][j1+j2][1] = min(sub[i+1][j1+j2][1], sub[i][j1][0] + dp[v][j2][1], sub[i][j1][1] + dp[v][j2][1], sub[i][j1][1] + dp[v][j2][0])\n\t\t\t\tif a[x] > 0:\n\t\t\t\t\tsub[i+1][j1+j2][0] = min(sub[i+1][j1+j2][0], sub[i][j1][0] + dp[v][j2][0])\n\n\t\t\t\tif dp[v][j2][0] < INF//2 or dp[v][j2][1] < 0:\n\t\t\t\t\tsub[i+1][j1+j2+1][1] = min(sub[i+1][j1+j2+1][1], sub[i][j1][1])\n\t\t\t\t\tif a[x] > 0:\n\t\t\t\t\t\tsub[i+1][j1+j2+1][0] = min(sub[i+1][j1+j2+1][0], sub[i][j1][0])\n\n\t\te_cnt += edges[v] + 1\n\t\ti += 1\n\n\tfor j in range(edges[x]+1):\n\t\tdp[x][j][0] = sub[i][j][0]\n\t\tdp[x][j][1] = sub[i][j][1]\n\n\treturn\n\ndfs(0, -1)\n\nfor j in range(n):\n\tif dp[0][j][0] < INF//2 or dp[0][j][1] < 0:\n\t\tans = j\n\t\tbreak\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import sys\n\nsys.setrecursionlimit(5001)\n\nN=int(input())\nA=list(map(int,input().split()))\nedge=[[] for i in range(N)]\nfor _ in range(N-1):\n    u,v=map(int,input().split())\n    edge[u-1].append(v-1)\n    edge[v-1].append(u-1)\n\ndpc=[[] for i in range(N)]\ndpn=[[] for i in range(N)]\nsz=[0]*N\n\ndef dfs(v,pv):\n    sz[v]=1\n    if A[v]<0:\n        dpc[v]=[float(\"inf\"),A[v]]\n        for nv in edge[v]:\n            if nv!=pv:\n                dfs(nv,v)\n                merged=[float(\"inf\")]*(sz[v]+sz[nv]+1)\n                for i in range(1,1+sz[v]):\n                    for j in range(1,1+sz[nv]):\n                        merged[i+j-1]=min(merged[i+j-1],dpc[v][i]+dpc[nv][j])\n                        if dpn[nv][j]!=float(\"inf\"):\n                            merged[i+j]=min(merged[i+j],dpc[v][i])\n                        merged[i+j-1]=min(merged[i+j-1],dpc[v][i]+dpn[nv][j])\n                dpc[v]=merged\n                sz[v]+=sz[nv]\n        dpn[v]=[float(\"inf\")]*(sz[v]+1)\n    else:\n        dpn[v]=[float(\"inf\"),A[v]]\n        for nv in edge[v]:\n            if nv!=pv:\n                dfs(nv,v)\n                merged=[float(\"inf\")]*(sz[v]+sz[nv]+1)\n                for i in range(1,1+sz[v]):\n                    for j in range(1,1+sz[nv]):\n                        if dpc[nv][j]<0:\n                            merged[i+j]=min(merged[i+j],dpn[v][i])\n                        merged[i+j-1]=min(merged[i+j-1],dpn[v][i]+dpn[nv][j])\n                        if dpn[nv][j]!=float(\"inf\"):\n                            merged[i+j]=min(merged[i+j],dpn[v][i])\n                dpn[v]=merged\n                sz[v]+=sz[nv]\n\n        sz[v]=1\n        dpc[v]=[float(\"inf\"),A[v]]\n        for nv in edge[v]:\n            if nv!=pv:\n                merged=[float(\"inf\")]*(sz[v]+sz[nv]+1)\n                for i in range(1+sz[v]):\n                    for j in range(1+sz[nv]):\n                        merged[i+j-1]=min(merged[i+j-1],dpc[v][i]+dpc[nv][j])\n                        if dpn[nv][j]!=float(\"inf\"):\n                            merged[i+j]=min(merged[i+j],dpc[v][i])\n                        merged[i+j-1]=min(merged[i+j-1],dpc[v][i]+dpn[nv][j])\n                dpc[v]=merged\n                sz[v]+=sz[nv]\n\ndfs(0,-1)\n\nans=N\nfor i in range(1,N+1):\n    if dpc[0][i]<0 or dpn[0][i]!=float(\"inf\"):\n        ans=i\n        break\n\nprint(ans-1)"
  },
  {
    "language": "Python",
    "code": "import sys\nimport copy\nsys.setrecursionlimit(1000000)\n\ndef dfs(used,tree,node, capacity_and_cut_num):\n    if used[node]!=0:\n        return\n    \n    if energy[node]>0:\n        capacity_and_cut_num[0]+=energy[node]\n    else:\n        capacity_and_cut_num[1]+=1\n        return\n    \n    used[node]=1\n    for x in tree[node]:\n        dfs(used,tree,x, capacity_and_cut_num)\n\nN=int(input())\nenergy=list(map(int,input().split()))\n\nbattery=[]\nfor i,x in enumerate(energy):\n    if x>0:\n        battery.append(i)\n\ncable=[[] for _ in range(N)]\nused=[0 for _ in range(N)]\n\nfor i in range(N-1):\n    U,V=list(map(int,input().split()))\n    cable[U-1].append(V-1)\n    cable[V-1].append(U-1)\n\nnew_battery=[]\nfor b in battery:\n    capacity_and_cut_num=[0,0]\n    dfs(used, cable, b, capacity_and_cut_num)\n    if capacity_and_cut_num[0] == 0:\n        continue\n    new_battery.append(capacity_and_cut_num)\n\nnew_battery=sorted(new_battery,key=lambda x:x[1])\nsum_energy=sum(energy)\nans=0\ndp=[[0,copy.deepcopy(new_battery)] for _ in range(N)]\nfor i in range(1,N):\n    for j in range(0,i):\n        for k,b in enumerate(dp[j][1]):\n            if b[1]==i-j and dp[j][0]+b[0]>dp[i][0]:\n                dp[i][0]=dp[j][0]+b[0]\n                dp[i][1]=dp[j][1][:k]+dp[j][1][k+1:]\n    if dp[i][0]>sum_energy:\n        ans=i\n        break\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nimport numpy as np\n\nN = int(readline())\nA = [0]+list(map(int,readline().split()))\n\nm = map(int,read().split())\nUV = zip(m,m)\ngraph = [[] for _ in range(N+1)]\nfor u,v in UV:\n    graph[u].append(v)\n    graph[v].append(u)\n\nroot=1\nparent = [0] * (N+1)\nts = []\nstack = [root]\nwhile stack:\n    x = stack.pop()\n    ts.append(x)\n    for y in graph[x]:\n        if y == parent[x]:\n            continue\n        parent[y] = x\n        stack.append(y)\n\nINF = 10**18\n\n\"\"\"\n各頂点において、\n・「根側を全て正にするための切断回数」\n・「各切断回数ごとの、根側に残る数の和の最小値」（array）\nを持つ\n\"\"\"\n\npositive_cut_cnt = [None]*(N+1)\nrest_sum_array = [None]*(N+1)\n\ndef merge(dp1,dp2):\n    # 回数 -> 和の最小値が入っている\n    L1,L2 = len(dp1),len(dp2)\n    if L1>L2:\n        L1,L2=L2,L1\n        dp1,dp2=dp2,dp1\n    dp = np.full(L1+L2-1,INF)\n    for i,x in enumerate(dp1):\n        np.minimum(dp[i:L2+i],x+dp2,out=dp[i:L2+i])\n    return dp\n\nfor x in ts[::-1]:\n    a = A[x]\n    arr = np.array([a],np.int64)\n    cut = 0\n    for c in graph[x]:\n        if c == parent[x]:\n            continue\n        arr = merge(arr,rest_sum_array[c])\n        cut += positive_cut_cnt[c]\n    arr = np.append(arr,0)\n    negative = np.where(arr<0)[0]\n    if a>0:\n        positive_cut_cnt[x]=cut\n        # 全て正として切る\n        np.minimum(arr[cut+1:],0,out=arr[cut+1:])\n    if a<0:\n        positive_cut_cnt[x]=negative[0]+1\n    if len(negative):\n        # 負として切る\n        np.minimum(arr[negative+1],0,out=arr[negative+1])\n        if cut>negative[0]:\n            cut=negative[0]\n    rest_sum_array[x] = arr\n\nnegative = np.where(rest_sum_array[1]<0)[0]\nanswer = INF\nif len(negative):\n    answer = negative[0]\nif answer > positive_cut_cnt[1]:\n    answer = positive_cut_cnt[1]\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nimport numpy as np\n\nN = int(readline())\nA = [0]+list(map(int,readline().split()))\n\nm = map(int,read().split())\nUV = zip(m,m)\ngraph = [[] for _ in range(N+1)]\nfor u,v in UV:\n    graph[u].append(v)\n    graph[v].append(u)\n\nroot=1\nparent = [0] * (N+1)\nts = []\nstack = [root]\nwhile stack:\n    x = stack.pop()\n    ts.append(x)\n    for y in graph[x]:\n        if y == parent[x]:\n            continue\n        parent[y] = x\n        stack.append(y)\n\nINF = 10**18\n\n\"\"\"\n各頂点において、\n・「根側を全て正にするための切断回数」\n・「各切断回数ごとの、根側に残る数の和の最小値」（array）\nを持つ\n\"\"\"\n\ndef merge(dp1,dp2):\n    # 回数 -> 和の最小値が入っている\n    L1,L2 = len(dp1),len(dp2)\n    if L1>L2:\n        L1,L2=L2,L1\n        dp1,dp2=dp2,dp1\n    dp = np.full(L1+L2-1,INF)\n    for i,x in enumerate(dp1):\n        np.minimum(dp[i:L2+i],x+dp2,out=dp[i:L2+i])\n    return dp\n\ndef v_to_e(cut,arr):\n    # 部分木頂点までのdp情報を、辺までのdp情報に変更\n    arr = np.append(arr,0)\n    negative = np.where(arr<0)[0]\n    # 全て正として切る\n    if cut != INF:\n        if arr[cut+1] > 0:\n            arr[cut+1] = 0\n    # 全て負として切る\n    if len(negative)>0:\n        n = negative[0]\n        if cut>n+1:\n            cut=n+1\n    np.minimum(arr[negative+1],0,out=arr[negative+1])\n    return cut,arr\n\npositive_cut_cnt = [None]*(N+1)\nrest_sum_array = [None]*(N+1)\n\nfor x in ts[::-1]:\n    a = A[x]\n    arr = np.array([a],np.int64)\n    cut = 0\n    for c in graph[x]:\n        if c == parent[x]:\n            continue\n        c_cut = positive_cut_cnt[c]\n        c_arr = rest_sum_array[c]\n        c_cut,c_arr = v_to_e(c_cut,c_arr)\n        cut += c_cut\n        arr = merge(arr,c_arr)\n    if a<0:\n        cut=INF\n    positive_cut_cnt[x]=cut\n    rest_sum_array[x] = arr\n\nanswer = positive_cut_cnt[1]\nnegative = np.where(rest_sum_array[1]<0)[0]\nif len(negative):\n    n = negative[0]\n    if answer > n:\n        answer = n\n\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import sys\n\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef MI1(): return map(int1, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LI1(): return list(map(int1, sys.stdin.readline().split()))\ndef LLI1(rows_number): return [LI1() for _ in range(rows_number)]\ndef SI(): return sys.stdin.readline()[:-1]\n\ndef dfs(u=0,pu=-1):\n    if aa[u]<0:dp[u][0][0]=aa[u]\n    else:dp[u][1][0]=aa[u]\n    for v in to[u]:\n        if v==pu:continue\n        dfs(v,u)\n        size[u]+=size[v]\n        ndp0=[inf]*n\n        ndp1=[inf]*n\n        for k in range(size[u]):\n            pre=dp[u][0][k]\n            if pre==inf:continue\n            for kv in range(size[v]):\n                s=dp[v][0][kv]\n                if s!=inf:ndp0[k+kv+1]=min(ndp0[k+kv+1],pre+s)\n                if s<0:ndp0[k+kv]=min(ndp0[k+kv],pre)\n                s = dp[v][1][kv]\n                if s != inf: ndp0[k + kv+1] = min(ndp0[k + kv+1], pre + s)\n                if s != inf: ndp0[k + kv] = min(ndp0[k + kv], pre)\n\n        for k in range(size[u]):\n            pre=dp[u][1][k]\n            if pre==inf:continue\n            for kv in range(size[v]):\n                s=dp[v][0][kv]\n                if s!=inf:ndp0[k+kv+1]=min(ndp0[k+kv+1],pre+s)\n                if s<0:ndp1[k+kv]=min(ndp1[k+kv],pre)\n                s = dp[v][1][kv]\n                if s != inf: ndp1[k + kv+1] = min(ndp1[k + kv+1], pre + s)\n                if s != inf: ndp1[k + kv] = min(ndp1[k + kv], pre)\n\n        dp[u][0]=ndp0\n        dp[u][1]=ndp1\n\ninf=10**16\nn=II()\naa=LI()\nto=[[] for _ in range(n)]\nfor _ in range(n-1):\n    u,v=MI1()\n    to[u].append(v)\n    to[v].append(u)\n\ndp=[[[inf]*n for _ in range(2)] for _ in range(n)]\nsize=[1]*n\ndfs()\n\nmx=0\nfor k in range(n-1,-1,-1):\n    if dp[0][0][k]<0:\n        mx=max(mx,k)\n        break\nfor k in range(n-1,-1,-1):\n    if dp[0][1][k]!=inf:\n        mx=max(mx,k)\n        break\nprint(n-1-mx)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10**9)\n\nINF = 10**15\n\nN = int(input())\nAs = list(map(int, input().split()))\nadjL = [[] for _ in range(N)]\nfor _ in range(N-1):\n    U, V = map(int, input().split())\n    U, V = U-1, V-1\n    adjL[U].append(V)\n    adjL[V].append(U)\n\nuseds = [False] * N\nsizes = [0] * N\ndp0 = [[] for _ in range(N)]\ndp1 = [[] for _ in range(N)]\n\ndef dfs(v):\n    useds[v] = True\n    sizes[v] = 1\n    dp0[v] = [As[v] if As[v] > 0 else INF]\n    dp1[v] = [As[v] if As[v] < 0 else INF]\n    for v2 in adjL[v]:\n        if useds[v2]: continue\n        dfs(v2)\n        merged0 = [INF] * (sizes[v]+sizes[v2])\n        merged1 = [INF] * (sizes[v]+sizes[v2])\n        for i in range(sizes[v]):\n            for j in range(sizes[v2]):\n                merged0[i+j] = min(merged0[i+j], dp0[v][i]+dp0[v2][j])\n                merged1[i+j] = min(merged1[i+j], dp0[v][i]+dp1[v2][j])\n                merged1[i+j] = min(merged1[i+j], dp1[v][i]+dp0[v2][j])\n                merged1[i+j] = min(merged1[i+j], dp1[v][i]+dp1[v2][j])\n                if dp0[v2][j] != INF:\n                    merged0[i+j+1] = min(merged0[i+j+1], dp0[v][i])\n                if dp1[v2][j] < 0:\n                    merged0[i+j+1] = min(merged0[i+j+1], dp0[v][i])\n                if dp0[v2][j] != INF:\n                    merged1[i+j+1] = min(merged1[i+j+1], dp1[v][i])\n                if dp1[v2][j] < 0:\n                    merged1[i+j+1] = min(merged1[i+j+1], dp1[v][i])\n        sizes[v] += sizes[v2]\n        dp0[v] = merged0\n        dp1[v] = merged1\n\ndfs(0)\n\nfor i, (v0, v1) in enumerate(zip(dp0[0], dp1[0])):\n    if v0 != INF or v1 < 0:\n        print(i)\n        break\n"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\n\ninf = 10**9+7\ndef merge(d1a, d2a, d1b, d2b):\n    la = len(d1a)\n    lb = len(d1b)\n    k = la+lb\n    res1 = [inf]*k\n    res2 = [inf]*k\n    for i in range(la):\n        for j in range(lb):\n            res1[i+j] = min(res1[i+j], d1a[i]+d1b[j], d1a[i]+d2b[j], d2a[i]+d1b[j])\n            res2[i+j] = min(res2[i+j], d2a[i]+d2b[j])\n    \n    for j in range(lb):\n        if d1b[j] < 0:\n            for i in range(la):\n                res1[i+j+1] = min(res1[i+j+1], d1a[i])\n                res2[i+j+1] = min(res2[i+j+1], d2a[i])\n        if d2b[j] < inf:\n            for i in range(la):\n                res1[i+j+1] = min(res1[i+j+1], d1a[i])\n                res2[i+j+1] = min(res2[i+j+1], d2a[i])                \n    return res1, res2\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0]*N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return par, order\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for i, v in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\n\nN = int(readline())\nA = list(map(int, readline().split()))\nEdge = [[] for _ in range(N)]\nfor _ in range(N-1):\n    a, b = map(int, readline().split())\n    a -= 1\n    b -= 1\n    Edge[a].append(b)\n    Edge[b].append(a)\n\nP, L = parorder(Edge, 0)\n#C = getcld(P)\n\ndp1 = [[A[i] if A[i] < 0 else inf] for i in range(N)]\ndp2 = [[A[i] if A[i] > 0 else inf] for i in range(N)]\n\nfor l in L[:0:-1]:\n    p = P[l]\n    dp1[p], dp2[p] = merge(dp1[p], dp2[p], dp1[l], dp2[l])\n    \n    \nans = inf\nfor i in range(N):\n    if dp1[0][i] < 0 or dp2[0][i] < inf:\n        ans = i\n        break\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\nN=int(input())\nA=list(map(int,input().split()))\nedge=[[] for i in range(N)]\nfor _ in range(N-1):\n    u,v=map(int,input().split())\n    edge[u-1].append(v-1)\n    edge[v-1].append(u-1)\n\nans=[0]\nparent=[-1]*N\nque=deque([(0,-1)])\nwhile que:\n    v,pv=que.popleft()\n    for nv in edge[v]:\n        if nv!=pv:\n            parent[nv]=v\n            ans.append(nv)\n            que.append((nv,v))\nans=ans[::-1]\n\n\ndpc=[[] for i in range(N)]\ndpn=[[] for i in range(N)]\nsz=[0]*N\nfor v in ans:\n    sz[v]=1\n    if A[v]<0:\n        dpc[v]=[float(\"inf\"),A[v]]\n        for nv in edge[v]:\n            if nv!=parent[v]:\n                merged=[float(\"inf\")]*(sz[v]+sz[nv]+1)\n                for i in range(1,1+sz[v]):\n                    for j in range(1,1+sz[nv]):\n                        merged[i+j-1]=min(merged[i+j-1],dpc[v][i]+dpc[nv][j])\n                        if dpn[nv][j]!=float(\"inf\"):\n                            merged[i+j]=min(merged[i+j],dpc[v][i])\n                        merged[i+j-1]=min(merged[i+j-1],dpc[v][i]+dpn[nv][j])\n                dpc[v]=merged\n                sz[v]+=sz[nv]\n        dpn[v]=[float(\"inf\")]*(sz[v]+1)\n    else:\n        dpn[v]=[float(\"inf\"),A[v]]\n        for nv in edge[v]:\n            if nv!=parent[v]:\n                merged=[float(\"inf\")]*(sz[v]+sz[nv]+1)\n                for i in range(1,1+sz[v]):\n                    for j in range(1,1+sz[nv]):\n                        if dpc[nv][j]<0:\n                            merged[i+j]=min(merged[i+j],dpn[v][i])\n                        merged[i+j-1]=min(merged[i+j-1],dpn[v][i]+dpn[nv][j])\n                        if dpn[nv][j]!=float(\"inf\"):\n                            merged[i+j]=min(merged[i+j],dpn[v][i])\n                dpn[v]=merged\n                sz[v]+=sz[nv]\n\n        sz[v]=1\n        dpc[v]=[float(\"inf\"),A[v]]\n        for nv in edge[v]:\n            if nv!=parent[v]:\n                merged=[float(\"inf\")]*(sz[v]+sz[nv]+1)\n                for i in range(1+sz[v]):\n                    for j in range(1+sz[nv]):\n                        merged[i+j-1]=min(merged[i+j-1],dpc[v][i]+dpc[nv][j])\n                        if dpn[nv][j]!=float(\"inf\"):\n                            merged[i+j]=min(merged[i+j],dpc[v][i])\n                        merged[i+j-1]=min(merged[i+j-1],dpc[v][i]+dpn[nv][j])\n                dpc[v]=merged\n                sz[v]+=sz[nv]\n\nans=N\nfor i in range(1,N+1):\n    if dpc[0][i]<0 or dpn[0][i]!=float(\"inf\"):\n        ans=i\n        break\n\nprint(ans-1)\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\nsys.setrecursionlimit(5005)\nSENTINEL = 10 ** 13\n\nn = int(input())\naaa = list(map(int, input().split()))\nlinks = [set() for _ in [0] * n]\nfor line in sys.stdin.readlines():\n    u, v = map(int, line.split())\n    u -= 1\n    v -= 1\n    links[u].add(v)\n    links[v].add(u)\n\n\ndef dfs(v, p):\n    a = aaa[v]\n    ret1 = [a]\n    ret2 = [a]\n    if a < 0:\n        ret1[0] = SENTINEL\n\n    for u in links[v]:\n        if u == p:\n            continue\n        res1, res2 = dfs(u, v)\n        new1 = [SENTINEL] * (len(ret1) + len(res1))\n        new2 = [SENTINEL] * (len(ret2) + len(res2))\n        for i, t in enumerate(ret1):\n            for j, s in enumerate(res1):\n                new1[i + j] = min(new1[i + j], t + s)\n                if s < SENTINEL:\n                    new1[i + j + 1] = min(new1[i + j + 1], t)\n            for j, s in enumerate(res2):\n                new2[i + j] = min(new2[i + j], t + s)\n                if s < 0:\n                    new1[i + j + 1] = min(new1[i + j + 1], t)\n        for i, t in enumerate(ret2):\n            for j, s in enumerate(res1):\n                new2[i + j] = min(new2[i + j], t + s)\n                if s < SENTINEL:\n                    new2[i + j + 1] = min(new2[i + j + 1], t)\n            for j, s in enumerate(res2):\n                new2[i + j] = min(new2[i + j], t + s)\n                if s < 0:\n                    new2[i + j + 1] = min(new2[i + j + 1], t)\n\n        # print(' ', '1', p, v, u, ret1, res1, new1)\n        # print(' ', '2', p, v, u, ret2, res2, new2)\n        ret1, ret2 = new1, new2\n\n    return ret1, ret2\n\n\nres1, res2 = dfs(0, -1)\nans1, ans2 = 0, 0\nfor ans1, s in enumerate(res1):\n    if s < SENTINEL:\n        break\nfor ans2, s in enumerate(res2):\n    if s < 0:\n        break\nprint(min(ans1, ans2))\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\nsys.setrecursionlimit(5005)\nSENTINEL = 10 ** 13\n\nn = int(input())\naaa = list(map(int, input().split()))\nlinks = [set() for _ in [0] * n]\nfor line in sys.stdin.readlines():\n    u, v = map(int, line.split())\n    u -= 1\n    v -= 1\n    links[u].add(v)\n    links[v].add(u)\n\n\ndef dfs(v, p):\n    a = aaa[v]\n    ret1 = [a]\n    ret2 = [a]\n    if a < 0:\n        ret1[0] = SENTINEL\n\n    for u in links[v]:\n        if u == p:\n            continue\n        res1, res2 = dfs(u, v)\n        new1 = [SENTINEL] * (len(ret1) + len(res1))\n        new2 = [SENTINEL] * (len(ret2) + len(res2))\n        for i, t in enumerate(ret1):\n            for j, s in enumerate(res1):\n                new1[i + j] = min(new1[i + j], t + s)\n                if s < SENTINEL:\n                    new1[i + j + 1] = min(new1[i + j + 1], t)\n            for j, s in enumerate(res2):\n                new2[i + j] = min(new2[i + j], t + s)\n                if s < 0:\n                    new1[i + j + 1] = min(new1[i + j + 1], t)\n        for i, t in enumerate(ret2):\n            for j, s in enumerate(res1):\n                new2[i + j] = min(new2[i + j], t + s)\n                if s < SENTINEL:\n                    new2[i + j + 1] = min(new2[i + j + 1], t)\n            for j, s in enumerate(res2):\n                new2[i + j] = min(new2[i + j], t + s)\n                if s < 0:\n                    new2[i + j + 1] = min(new2[i + j + 1], t)\n\n        # print(' ', '1', p, v, u, ret1, res1, new1)\n        # print(' ', '2', p, v, u, ret2, res2, new2)\n        ret1, ret2 = new1, new2\n\n    return ret1, ret2\n\n\nres1, res2 = dfs(0, -1)\nans1, ans2 = 0, 0\nfor ans1, s in enumerate(res1):\n    if s < SENTINEL:\n        break\nfor ans2, s in enumerate(res2):\n    if s < 0:\n        break\nprint(min(ans1, ans2))\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10**5)\ndef input():\n\treturn sys.stdin.buffer.readline()[:-1]\nINF = 10**14\n\nn = int(input())\na = list(map(int, input().split()))\nadj = [[] for _ in range(n)]\nfor _ in range(n-1):\n\tu, v = map(int, input().split())\n\tadj[u-1].append(v-1)\n\tadj[v-1].append(u-1)\n\ndp = [[[INF for _ in range(2)] for _ in range(n)] for _ in range(n)]\nedges = [0 for _ in range(n)]\n\ndef dfs_pre(x, p):\n\tif x != 0 and len(adj[x]) == 1:\n\t\treturn 0\n\tfor v in adj[x]:\n\t\tif v == p:\n\t\t\tcontinue\n\t\telse:\n\t\t\tedges[x] += dfs_pre(v, x) + 1\n\treturn edges[x]\n\ndfs_pre(0, -1)\n\ndef dfs(x, p):\n\tfor v in adj[x]:\n\t\tif v != p:\n\t\t\tdfs(v, x)\n\tsub = [[[INF for _ in range(2)] for _ in range(n)] for _ in range(n)]\n\tsub[0][0][1] = a[x]\n\tif a[x] > 0:\n\t\tsub[0][0][0] = a[x]\n\ti = 0\n\te_cnt = 0\n\tfor v in adj[x]:\n\t\tif v == p:\n\t\t\tcontinue\n\t\tfor j1 in range(e_cnt+1):\n\t\t\tfor j2 in range(edges[v]+1):\n\t\t\t\tsub[i+1][j1+j2][1] = min(sub[i+1][j1+j2][1], sub[i][j1][0] + dp[v][j2][1], sub[i][j1][1] + dp[v][j2][1], sub[i][j1][1] + dp[v][j2][0])\n\t\t\t\tif a[x] > 0:\n\t\t\t\t\tsub[i+1][j1+j2][0] = min(sub[i+1][j1+j2][0], sub[i][j1][0] + dp[v][j2][0])\n\n\t\t\t\tif dp[v][j2][0] < INF//2 or dp[v][j2][1] < 0:\n\t\t\t\t\tsub[i+1][j1+j2+1][1] = min(sub[i+1][j1+j2+1][1], sub[i][j1][1])\n\t\t\t\t\tif a[x] > 0:\n\t\t\t\t\t\tsub[i+1][j1+j2+1][0] = min(sub[i+1][j1+j2+1][0], sub[i][j1][0])\n\n\t\te_cnt += edges[v] + 1\n\t\ti += 1\n\n\tfor j in range(edges[x]+1):\n\t\tdp[x][j][0] = sub[i][j][0]\n\t\tdp[x][j][1] = sub[i][j][1]\n\n\tdel sub\n\treturn\n\ndfs(0, -1)\n\nfor j in range(n):\n\tif dp[0][j][0] < INF//2 or dp[0][j][1] < 0:\n\t\tans = j\n\t\tbreak\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10**5)\ndef input():\n\treturn sys.stdin.buffer.readline()[:-1]\nINF = 10**14\n\nn = int(input())\na = list(map(int, input().split()))\nadj = [[] for _ in range(n)]\nfor _ in range(n-1):\n\tu, v = map(int, input().split())\n\tadj[u-1].append(v-1)\n\tadj[v-1].append(u-1)\n\ndp = [[[INF for _ in range(2)] for _ in range(n)] for _ in range(n)]\nedges = [0 for _ in range(n)]\n\ndef dfs_pre(x, p):\n\tif x != 0 and len(adj[x]) == 1:\n\t\treturn 0\n\tfor v in adj[x]:\n\t\tif v == p:\n\t\t\tcontinue\n\t\telse:\n\t\t\tedges[x] += dfs_pre(v, x) + 1\n\treturn edges[x]\n\ndfs_pre(0, -1)\n\ndef dfs(x, p):\n\tfor v in adj[x]:\n\t\tif v != p:\n\t\t\tdfs(v, x)\n\tsub = [[[INF for _ in range(2)] for _ in range(n)] for _ in range(n)]\n\tsub[0][0][1] = a[x]\n\tif a[x] > 0:\n\t\tsub[0][0][0] = a[x]\n\ti = 0\n\te_cnt = 0\n\tfor v in adj[x]:\n\t\tif v == p:\n\t\t\tcontinue\n\t\tfor j1 in range(e_cnt+1):\n\t\t\tfor j2 in range(edges[v]+1):\n\t\t\t\tsub[i+1][j1+j2][1] = min(sub[i+1][j1+j2][1], sub[i][j1][0] + dp[v][j2][1], sub[i][j1][1] + dp[v][j2][1], sub[i][j1][1] + dp[v][j2][0])\n\t\t\t\tif a[x] > 0:\n\t\t\t\t\tsub[i+1][j1+j2][0] = min(sub[i+1][j1+j2][0], sub[i][j1][0] + dp[v][j2][0])\n\n\t\t\t\tif dp[v][j2][0] < INF//2 or dp[v][j2][1] < 0:\n\t\t\t\t\tsub[i+1][j1+j2+1][1] = min(sub[i+1][j1+j2+1][1], sub[i][j1][1])\n\t\t\t\t\tif a[x] > 0:\n\t\t\t\t\t\tsub[i+1][j1+j2+1][0] = min(sub[i+1][j1+j2+1][0], sub[i][j1][0])\n\n\t\te_cnt += edges[v] + 1\n\t\ti += 1\n\n\tfor j in range(edges[x]+1):\n\t\tdp[x][j][0] = sub[i][j][0]\n\t\tdp[x][j][1] = sub[i][j][1]\n\n\tdel sub\n\treturn\n\ndfs(0, -1)\n\nfor j in range(n):\n\tif dp[0][j][0] < INF//2 or dp[0][j][1] < 0:\n\t\tans = j\n\t\tbreak\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\n\ninf = 10**18+3\ndef merge(d1a, d2a, d1b, d2b):\n    la = len(d1a)\n    lb = len(d1b)\n    k = la+lb\n    res1 = [inf]*k\n    res2 = [inf]*k\n    for i in range(la):\n        for j in range(lb):\n            res1[i+j] = min(res1[i+j], d1a[i]+d1b[j], d1a[i]+d2b[j], d2a[i]+d1b[j])\n            res2[i+j] = min(res2[i+j], d2a[i]+d2b[j])\n    \n    for j in range(lb):\n        if d1b[j] < 0 or d2b[j] < inf:\n            for i in range(la):\n                res1[i+j+1] = min(res1[i+j+1], d1a[i])\n                res2[i+j+1] = min(res2[i+j+1], d2a[i])\n    return res1, res2\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0]*N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return par, order\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for i, v in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\n\nN = int(readline())\nA = list(map(int, readline().split()))\nEdge = [[] for _ in range(N)]\nfor _ in range(N-1):\n    a, b = map(int, readline().split())\n    a -= 1\n    b -= 1\n    Edge[a].append(b)\n    Edge[b].append(a)\n\nP, L = parorder(Edge, 0)\n#C = getcld(P)\n\ndp1 = [[A[i] if A[i] < 0 else inf] for i in range(N)]\ndp2 = [[A[i] if A[i] > 0 else inf] for i in range(N)]\n\nfor l in L[:0:-1]:\n    p = P[l]\n    dp1[p], dp2[p] = merge(dp1[p], dp2[p], dp1[l], dp2[l])\n    \n    \nans = N-1\nfor i in range(N):\n    if dp1[0][i] < 0 or dp2[0][i] < inf:\n        ans = i\n        break\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "n=int(input())\nl=list(map(int,input().split()))\ncnt=0\nfor i in range(n-1):\n    a,b=map(int,input().split())\n    if (l[a-1]<0 or l[b-1]<0) and l[a-1]+l[b-1]>=0:\n        cnt+=1\nprint(cnt)"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10**5)\ndef input():\n\treturn sys.stdin.buffer.readline()[:-1]\nINF = 10**14\n\nn = int(input())\na = list(map(int, input().split()))\nadj = [[] for _ in range(n)]\nfor _ in range(n-1):\n\tu, v = map(int, input().split())\n\tadj[u-1].append(v-1)\n\tadj[v-1].append(u-1)\n\ndp = [[[INF for _ in range(2)] for _ in range(n)] for _ in range(n)]\nedges = [0 for _ in range(n)]\n\ndef dfs_pre(x, p):\n\tif x != 0 and len(adj[x]) == 1:\n\t\treturn 0\n\tfor v in adj[x]:\n\t\tif v == p:\n\t\t\tcontinue\n\t\telse:\n\t\t\tedges[x] += dfs_pre(v, x) + 1\n\treturn edges[x]\n\ndfs_pre(0, -1)\n\ndef dfs(x, p):\n\tfor v in adj[x]:\n\t\tif v != p:\n\t\t\tdfs(v, x)\n\tsub = [[[INF for _ in range(2)] for _ in range(n)] for _ in range(n)]\n\tsub[0][0][1] = a[x]\n\tif a[x] > 0:\n\t\tsub[0][0][0] = a[x]\n\ti = 0\n\te_cnt = 0\n\tfor v in adj[x]:\n\t\tif v == p:\n\t\t\tcontinue\n\t\tfor j1 in range(e_cnt+1):\n\t\t\tfor j2 in range(edges[v]+1):\n\t\t\t\tsub[i+1][j1+j2][1] = min(sub[i+1][j1+j2][1], sub[i][j1][0] + dp[v][j2][1], sub[i][j1][1] + dp[v][j2][1], sub[i][j1][1] + dp[v][j2][0])\n\t\t\t\tif a[x] > 0:\n\t\t\t\t\tsub[i+1][j1+j2][0] = min(sub[i+1][j1+j2][0], sub[i][j1][0] + dp[v][j2][0])\n\n\t\t\t\tif dp[v][j2][0] < INF//2 or dp[v][j2][1] < 0:\n\t\t\t\t\tsub[i+1][j1+j2+1][1] = min(sub[i+1][j1+j2+1][1], sub[i][j1][1])\n\t\t\t\t\tif a[x] > 0:\n\t\t\t\t\t\tsub[i+1][j1+j2+1][0] = min(sub[i+1][j1+j2+1][0], sub[i][j1][0])\n\n\t\te_cnt += edges[v] + 1\n\t\ti += 1\n\n\tfor j in range(edges[x]+1):\n\t\tdp[x][j][0] = sub[i][j][0]\n\t\tdp[x][j][1] = sub[i][j][1]\n\n\treturn\n\ndfs(0, -1)\n\nfor j in range(n):\n\tif dp[0][j][0] < INF//2 or dp[0][j][1] < 0:\n\t\tans = j\n\t\tbreak\n\nprint(ans)"
  },
  {
    "language": "Rust",
    "code": "// ---------- begin Tree DP ----------\nstruct TreeDP<Edge, Value, Init, Merge> {\n    size: usize,\n    graph: Vec<Vec<(usize, Edge)>>,\n    init: Init,\n    merge: Merge,\n    phantom: std::marker::PhantomData<Value>,\n}\n\nimpl<Edge, Value, Init, Merge> TreeDP<Edge, Value, Init, Merge>\nwhere Edge: Clone,\n      Value: Clone,\n      Init: Fn(usize) -> Value,\n      Merge: Fn(Value, Value, &Edge) -> Value,\n{\n    fn new(size: usize, init: Init, merge: Merge) -> Self {\n        TreeDP {\n            size: size,\n            graph: vec![vec![]; size],\n            init: init,\n            merge: merge,\n            phantom: std::marker::PhantomData,\n        }\n    }\n    fn add_edge(&mut self, a: usize, b: usize, c: Edge) {\n        assert!(a < self.size && b < self.size && a != b);\n        self.graph[a].push((b, c.clone()));\n        self.graph[b].push((a, c));\n    }\n    fn solve(&self, root: usize) -> Value {\n        let size = self.size;\n        let graph = &self.graph;\n        let mut topo = vec![];\n        let mut parent = vec![root; size];\n        let mut stack = vec![root];\n        while let Some(v) = stack.pop() {\n            topo.push(v);\n            for e in graph[v].iter() {\n                if e.0 != parent[v] {\n                    parent[e.0] = v;\n                    stack.push(e.0);\n                }\n            }\n        }\n        assert!(topo.len() == size);\n        let mut dp: Vec<Option<Value>> = (0..size).map(|_| None).collect();\n        for &v in topo.iter().rev() {\n            let mut now = (self.init)(v);\n            for u in graph[v].iter() {\n                if u.0 == parent[v] {\n                    continue;\n                }\n                let b = dp[u.0].take().unwrap();\n                now = (self.merge)(now, b, &u.1);\n            }\n            dp[v] = Some(now);\n        }\n        dp[root].take().unwrap()\n    }\n}\n// ---------- end Tree DP ----------\n//https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8 より\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n//\n\nuse std::cmp::min;\n\nfn run() {\n    input! {\n        n: usize,\n        a: [i64; n],\n        e: [(usize1, usize1); n - 1],\n    }\n    type Value = Vec<(i64, i64)>;// バッテリーのみ、コンピュータあり、のmin\n    type Edge = ();\n    let inf = 1_000_000_000i64 * 5000 + 1;\n    let init = |v: usize| -> Value {\n        if a[v] > 0 {\n            vec![(a[v], a[v])]\n        } else {\n            vec![(2 * inf, a[v])]\n        }\n    };\n    let merge = |a: Value, b: Value, _c: &Edge| -> Value {\n        let mut res = vec![(inf, inf); a.len() + b.len()];\n        for (i, a) in a.iter().enumerate() {\n            for (j, b) in b.iter().enumerate() {\n                // 切らない\n                {\n                    let p = &mut res[i + j];\n                    p.1 = min(p.1, min(a.0, a.1) + min(b.0, b.1));\n                    p.0 = min(p.0, a.0 + b.0);\n                }\n                // 切る\n                {\n                    let p = &mut res[i + j + 1];\n                    if b.1 < 0 {\n                        p.0 = min(p.0, a.0);\n                        p.1 = min(p.1, a.1);\n                    }\n                    if b.0 < inf {\n                        p.0 = min(p.0, a.0);\n                        p.1 = min(p.1, a.1);\n                    }\n                }\n            }\n        }\n        res\n    };\n    let mut solver = TreeDP::new(n, init, merge);\n    for (a, b) in e {\n        solver.add_edge(a, b, ());\n    }\n    let dp = solver.solve(0);\n    let mut ans = 0;\n    while dp[ans].0 >= inf && dp[ans].1 >= 0 {\n        ans += 1;\n    }\n    println!(\"{}\", ans);\n}\n\nfn main() {\n    run();\n}\n"
  },
  {
    "language": "Rust",
    "code": "const INF: i64 = 1e16 as i64;\nfn main() {\n    let s = std::io::stdin();\n    let mut sc = Scanner { stdin: s.lock() };\n    let n: usize = sc.read();\n    let a: Vec<i64> = sc.vec(n);\n    let mut graph = vec![vec![]; n];\n    for _ in 1..n {\n        let u = sc.read::<usize>() - 1;\n        let v = sc.read::<usize>() - 1;\n        graph[u].push(v);\n        graph[v].push(u);\n    }\n\n    let mut power_dp = vec![vec![]; n];\n    let mut min_dp = vec![vec![]; n];\n    dfs(0, 0, &a, &graph, &mut power_dp, &mut min_dp);\n\n    for cut in 0.. {\n        if power_dp[0][cut] < INF || min_dp[0][cut] < 0 {\n            println!(\"{}\", cut);\n            return;\n        }\n    }\n}\n\nfn dfs(\n    v: usize,\n    p: usize,\n    a: &Vec<i64>,\n    graph: &Vec<Vec<usize>>,\n    power_dp: &mut Vec<Vec<i64>>,\n    min_dp: &mut Vec<Vec<i64>>,\n) {\n    power_dp[v].push(if a[v] > 0 { a[v] } else { INF });\n    min_dp[v].push(a[v]);\n    for &child in graph[v].iter() {\n        if p == child {\n            continue;\n        }\n        dfs(child, v, a, graph, power_dp, min_dp);\n        power_dp[v] = connect(&power_dp[v], &power_dp[child], &min_dp[child], true);\n        min_dp[v] = connect(&min_dp[v], &power_dp[child], &min_dp[child], false);\n    }\n}\n\nfn connect(\n    dp: &Vec<i64>,\n    power_child: &Vec<i64>,\n    min_child: &Vec<i64>,\n    is_power: bool,\n) -> Vec<i64> {\n    let mut next = vec![INF; dp.len() + power_child.len() + 1];\n    for cut in 0..dp.len() {\n        if dp[cut] >= INF {\n            continue;\n        }\n        for child_cut in 0..power_child.len() {\n            let total_cut = cut + child_cut;\n            if !is_power {\n                chmin(&mut next[total_cut], dp[cut] + min_child[child_cut]);\n            }\n            if power_child[child_cut] < INF {\n                chmin(&mut next[total_cut], dp[cut] + power_child[child_cut]);\n            }\n            if min_child[child_cut] < 0 || power_child[child_cut] < INF {\n                chmin(&mut next[total_cut + 1], dp[cut]);\n            }\n        }\n    }\n    next\n}\n\nfn chmin<T: Ord>(a: &mut T, b: T) {\n    if *a > b {\n        *a = b;\n    }\n}\n\npub struct Scanner<R> {\n    stdin: R,\n}\n\nimpl<R: std::io::Read> Scanner<R> {\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .stdin\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n' || b == b'\\r')\n            .take_while(|&b| b != b' ' && b != b'\\n' && b != b'\\r')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_macros)]\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, bytes) => {\n        read_value!($next, String).into_bytes()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\nmod inf {\n    use std::cmp::min;\n    use std::ops::Add;\n\n    #[derive(PartialEq, Eq, PartialOrd, Ord, Clone, Copy)]\n    pub enum Inf<T> {\n        NotInf(T),\n        Inf,\n    }\n\n    impl<T> From<T> for Inf<T> {\n        fn from(v: T) -> Self {\n            Inf::NotInf(v)\n        }\n    }\n\n    impl<T: Add<Output = T>> Add for Inf<T> {\n        type Output = Inf<T>;\n        fn add(self, rhs: Self) -> Self {\n            use self::Inf::*;\n            match (self, rhs) {\n                (NotInf(a), NotInf(b)) => NotInf(a + b),\n                _ => Inf,\n            }\n        }\n    }\n\n    impl<T: Clone + Ord> Inf<T> {\n        pub fn min_assign(&mut self, rhs: Self) {\n            *self = min(self.clone(), rhs);\n        }\n    }\n}\n\n// fn min_assign<T: Ord + Clone>(l: &mut T, r: T) {\n//     *l = std::cmp::min((*l).clone(), r);\n// }\n\nuse inf::Inf;\nuse inf::Inf::*;\n\nfn main() {\n    input! {\n        n: usize,\n        a: [i64; n],\n        es: [(usize1, usize1); n-1],\n    }\n\n    let mut g = vec![vec![]; n];\n    for &(u, v) in es.iter() {\n        g[u].push(v);\n        g[v].push(u);\n    }\n\n    let ans = solve(0, None, &a, &g)\n        .iter()\n        .enumerate()\n        .find(|&(_, e)| e.0 != Inf || e.1 < 0.into())\n        .unwrap()\n        .0;\n\n    println!(\"{}\", ans);\n}\n\nfn solve(\n    v: usize,\n    prev: Option<usize>,\n    a: &Vec<i64>,\n    g: &Vec<Vec<usize>>,\n) -> Vec<(Inf<i64>, Inf<i64>)> {\n    let mut ret = vec![(if a[v] < 0 { Inf } else { a[v].into() }, a[v].into())];\n\n    for &u in g[v].iter().filter(|&&u| Some(u) != prev) {\n        let utbl = solve(u, Some(v), a, g);\n\n        let mut next = vec![(Inf, Inf); ret.len() + utbl.len()];\n        for i in 0..ret.len() {\n            for j in 0..utbl.len() {\n                if utbl[j].0 != Inf || utbl[j].1 < 0.into() {\n                    next[i + j + 1].0.min_assign(ret[i].0);\n                    next[i + j + 1].1.min_assign(ret[i].1);\n                }\n                next[i + j].0.min_assign(ret[i].0 + utbl[j].0);\n                next[i + j].1.min_assign(ret[i].1 + utbl[j].1);\n            }\n        }\n        ret = next;\n    }\n\n    ret\n}\n"
  },
  {
    "language": "Rust",
    "code": "macro_rules !read_value {($iter :expr ,($($t :tt ) ,*) ) =>{($(read_value !($iter ,$t ) ) ,*) } ;($iter :expr ,[$t :tt ;$len :expr ] ) =>{(0 ..$len ) .map (|_ |read_value !($iter ,$t ) ) .collect ::<Vec <_ >>() } ;($iter :expr ,{chars :$base :expr } ) =>{read_value !($iter ,String ) .chars () .map (|c |(c as u8 -$base as u8 ) as usize ) .collect ::<Vec <usize >>() } ;($iter :expr ,{char :$base :expr } ) =>{read_value !($iter ,{chars :$base } ) [0 ] } ;($iter :expr ,chars ) =>{read_value !($iter ,String ) .chars () .collect ::<Vec <char >>() } ;($iter :expr ,char ) =>{read_value !($iter ,chars ) [0 ] } ;($iter :expr ,usize1 ) =>{read_value !($iter ,usize ) -1 } ;($iter :expr ,$t :ty ) =>{$iter .next () .unwrap () .parse ::<$t >() .unwrap () } ;}\nmacro_rules !input_inner {($iter :expr ) =>{} ;($iter :expr ,) =>{} ;($iter :expr ,mut $var :ident :$t :tt $($r :tt ) *) =>{let mut $var =read_value !($iter ,$t ) ;input_inner !{$iter $($r ) *} } ;($iter :expr ,mut $var :ident $($r :tt ) *) =>{input_inner !{$iter ,mut $var :usize $($r ) *} } ;($iter :expr ,$var :ident :$t :tt $($r :tt ) *) =>{let $var =read_value !($iter ,$t ) ;input_inner !{$iter $($r ) *} } ;($iter :expr ,$var :ident $($r :tt ) *) =>{input_inner !{$iter ,$var :usize $($r ) *} } ;}\nmacro_rules !input {(source =$s :expr ,$($r :tt ) *) =>{let mut iter =$s .split_whitespace () ;input_inner !{iter ,$($r ) *} } ;(iter =$iter :ident ,$($r :tt ) *) =>{let s ={use std ::io ::Read ;let mut s =String ::new () ;std ::io ::stdin () .read_to_string (&mut s ) .unwrap () ;s } ;let mut $iter =s .split_whitespace () ;input_inner !{$iter ,$($r ) *} } ;($($r :tt ) *) =>{let s ={use std ::io ::Read ;let mut s =String ::new () ;std ::io ::stdin () .read_to_string (&mut s ) .unwrap () ;s } ;let mut iter =s .split_whitespace () ;input_inner !{iter ,$($r ) *} } ;}\n#[derive(Clone, Copy, Debug, Default, PartialEq, Eq)]\npub struct Adjacent {\n    pub to: usize,\n    pub id: usize,\n}\nimpl Adjacent {\n    pub fn new(to: usize, id: usize) -> Adjacent {\n        Adjacent { to: to, id: id }\n    }\n}\n#[derive(Clone, Debug, Default)]\npub struct Graph {\n    pub vsize: usize,\n    pub esize: usize,\n    pub graph: Vec<Vec<Adjacent>>,\n}\nimpl Graph {\n    pub fn new(vsize: usize) -> Graph {\n        Graph {\n            vsize: vsize,\n            esize: 0,\n            graph: vec![vec![]; vsize],\n        }\n    }\n    pub fn add_edge(&mut self, from: usize, to: usize) {\n        self.graph[from].push(Adjacent::new(to, self.esize));\n        self.esize += 1;\n    }\n    pub fn add_undirected_edge(&mut self, u: usize, v: usize) {\n        self.graph[u].push(Adjacent::new(v, self.esize));\n        self.graph[v].push(Adjacent::new(u, self.esize));\n        self.esize += 1;\n    }\n    pub fn vertices(&self) -> std::ops::Range<usize> {\n        0..self.vsize\n    }\n    pub fn adjacency(&self, from: usize) -> &Vec<Adjacent> {\n        &self.graph[from]\n    }\n}\nimpl Graph {\n    fn size_dfs(&self, u: usize, p: usize, size: &mut Vec<u64>) {\n        size[u] = 1;\n        for a in self.adjacency(u) {\n            if a.to != p {\n                self.size_dfs(a.to, u, size);\n                size[u] += size[a.to];\n            }\n        }\n    }\n    pub fn tree_size(&self, root: usize) -> Vec<u64> {\n        let n = self.vsize;\n        let mut size = vec![0; n];\n        self.size_dfs(root, n, &mut size);\n        size\n    }\n}\n#[derive(Debug)]\npub struct TreeRec {\n    n: usize,\n    a: Vec<i64>,\n}\nimpl TreeRec {\n    pub fn new(n: usize, a: Vec<i64>) -> TreeRec {\n        TreeRec { n: n, a: a }\n    }\n    pub fn dfs(&mut self, u: usize, p: usize, graph: &Graph) -> (Vec<i64>, Option<usize>) {\n        let mut dp = vec![self.a[u]];\n        let mut z = 0;\n        for a in graph.adjacency(u) {\n            if a.to != p {\n                let (v, opt) = self.dfs(a.to, u, graph);\n                let mut ep = vec![std::i64::MAX; dp.len() + v.len()];\n                for i in 0..dp.len() {\n                    for j in 0..v.len() {\n                        if v[j] < 0 || opt.map(|x| x == j).unwrap_or(false) {\n                            ep[i + j + 1] = min(ep[i + j + 1], dp[i]);\n                        }\n                        ep[i + j] = min(ep[i + j], dp[i].saturating_add(v[j]));\n                    }\n                }\n                let mut y = find_minus(&v) + 1;\n                if let Some(x) = opt {\n                    y = min(y, x);\n                }\n                z += y;\n                dp = ep;\n            }\n        }\n        let opt = if self.a[u] > 0 { Some(z) } else { None };\n        (dp, opt)\n    }\n}\npub fn find_minus(v: &[i64]) -> usize {\n    for i in 0..v.len() {\n        if v[i] < 0 {\n            return i;\n        }\n    }\n    return v.len();\n}\nuse std::cmp::min;\nfn main() {\n    input! { n, a:[i64;n], uv:[(usize1,usize1);n-1] };\n    let mut g = Graph::new(n);\n    for &(u, v) in &uv {\n        g.add_undirected_edge(u, v);\n    }\n    let mut r = TreeRec::new(n, a);\n    let (v, opt) = r.dfs(0, n, &g);\n    let mut ans = find_minus(&v);\n    if let Some(x) = opt {\n        ans = min(ans, x);\n    }\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "#![allow(unused_imports, non_snake_case)]\nuse std::cmp::{max, min, Ordering};\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n\n// {{{ input!\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n//}}}\n\n//{{{ read!\nmacro_rules! read {\n\t($($t:tt),*; $n:expr) => {{\n\t\tlet stdin = ::std::io::stdin();\n\t\tlet ret = ::std::io::BufRead::lines(stdin.lock()).take($n).map(|line| {\n\t\t\tlet line = line.unwrap();\n\t\t\tlet mut it = line.split_whitespace();\n\t\t\t_read!(it; $($t),*)\n\t\t}).collect::<Vec<_>>();\n\t\tret\n\t}};\n\t($($t:tt),*) => {{\n\t\tlet line = readln();\n\t\tlet mut it = line.split_whitespace();\n\t\t_read!(it; $($t),*)\n\t}};\n}\n\nmacro_rules! _read {\n\t($it:ident; [char]) => {\n\t\t_read!($it; String).chars().collect::<Vec<_>>()\n\t};\n\t($it:ident; [u8]) => {\n\t\tVec::from(_read!($it; String).into_bytes())\n\t};\n\t($it:ident; [$t:ty]) => {\n\t\t$it.map(|s| s.parse::<$t>().unwrap_or_else(|e| panic!(\"{}\", e))).collect::<Vec<_>>()\n\t};\n\t($it:ident; $t:ty) => {\n\t\t$it.next().unwrap_or_else(|| panic!(\"input mismatch\")).parse::<$t>().unwrap_or_else(|e| panic!(\"{}\", e))\n\t};\n\t($it:ident; $($t:ty),+) => {\n\t\t($(_read!($it; $t)),*)\n\t};\n}\n//}}}\n\n//{{{ utility macros missing in 1.15.1\n// https://atcoder.jp/contests/nikkei2019-qual/submissions/4098548\nmacro_rules! eprint {\n\t($($t:tt)*) => {{\n            use ::std::io::Write;\n            let _ = write!(::std::io::stderr(), $($t)*);\n\t}};\n}\nmacro_rules! eprintln {\n\t() => { eprintln!(\"\"); };\n\t($($t:tt)*) => {{\n\t    use ::std::io::Write;\n            let _ = writeln!(::std::io::stderr(), $($t)*);\n\t}};\n}\nmacro_rules! dbg {\n    ($val:expr) => {\n        match $val {\n            tmp => {\n                eprintln!(\n                    \"[{}:{}] {} = {:#?}\",\n                    file!(),\n                    line!(),\n                    stringify!($val),\n                    &tmp\n                );\n                tmp\n            }\n        }\n    };\n}\n//}}}\n\nstruct Solve {\n    a: Vec<isize>,\n    g: Vec<Vec<usize>>,\n    memo1: HashMap<(usize, usize), isize>,\n    memo2: HashMap<(usize, usize), isize>,\n}\n\nconst inf: isize = 1_000_000_000_000_000;\n\nimpl Solve {\n    // all +. minimum sum\n    fn rec1(&mut self, u: usize, p: usize, k: usize) -> isize {\n        if self.a[u] < 0 {\n            return inf;\n        }\n        let key = (u, k);\n        if let Some(&res) = self.memo1.get(&key) {\n            return res;\n        }\n\n        let children = self.g[u]\n            .iter()\n            .cloned()\n            .filter(|&v| v != p)\n            .collect::<Vec<_>>();\n        let mut dp = vec![inf; k + 1];\n        dp[0] = self.a[u];\n        for v in children {\n            let mut next_dp = vec![inf; k + 1];\n            for i in 0..k + 1 {\n                let d1 = self.rec1(v, u, i);\n                if d1 != inf {\n                    for j in 0..k + 1 - i {\n                        next_dp[i + j].set_min(d1 + dp[j]);\n                    }\n                    for j in 0..k + 1 - i - 1 {\n                        next_dp[i + j + 1].set_min(0 + dp[j]);\n                    }\n                }\n                let d2 = self.rec2(v, u, i);\n                if d2 < 0 {\n                    for j in 0..k + 1 - i - 1 {\n                        next_dp[i + j + 1].set_min(0 + dp[j]);\n                    }\n                }\n            }\n            dp = next_dp;\n        }\n        self.memo1.insert(key, dp[k]);\n        self.memo1[&key]\n    }\n\n    // can use -\n    fn rec2(&mut self, u: usize, p: usize, k: usize) -> isize {\n        let key = (u, k);\n        if let Some(&res) = self.memo2.get(&key) {\n            return res;\n        }\n\n        let children = self.g[u]\n            .iter()\n            .cloned()\n            .filter(|&v| v != p)\n            .collect::<Vec<_>>();\n        let mut dp = vec![inf; k + 1];\n        dp[0] = self.a[u];\n        for v in children {\n            let mut next_dp = vec![inf; k + 1];\n            for i in 0..k + 1 {\n                let d1 = self.rec1(v, u, i);\n                let d2 = self.rec2(v, u, i);\n                if d1 != inf {\n                    for j in 0..k + 1 - i - 1 {\n                        next_dp[i + j + 1].set_min(0 + dp[j]);\n                    }\n                }\n                if d2 != inf {\n                    for j in 0..k + 1 - i {\n                        next_dp[i + j].set_min(d2 + dp[j]);\n                    }\n                }\n                if d2 < 0 {\n                    for j in 0..k + 1 - i - 1 {\n                        next_dp[i + j + 1].set_min(0 + dp[j]);\n                    }\n                }\n            }\n            dp = next_dp;\n        }\n        self.memo2.insert(key, dp[k]);\n        self.memo2[&key]\n    }\n}\n\nfn run() {\n    input! {\n        n: usize,\n        a: [isize; n],\n        edges: [(usize1, usize1); n-1],\n    }\n    let mut g = vec![Vec::new(); n];\n    for (u, v) in edges {\n        g[u].push(v);\n        g[v].push(u);\n    }\n    let mut solve = Solve {\n        a: a,\n        g: g,\n        memo1: HashMap::new(),\n        memo2: HashMap::new(),\n    };\n    let answer = (0..n)\n        .filter(|&k| {\n            solve.rec1(0, usize::max_value(), k) != inf || solve.rec2(0, usize::max_value(), k) < 0\n        })\n        .min()\n        .unwrap();\n    println!(\"{}\", answer);\n}\n\n//{{{ template\nfn main() {\n    let _ = ::std::thread::Builder::new()\n        .name(\"run\".to_string())\n        .stack_size(256 * 1024 * 1024)\n        .spawn(run)\n        .unwrap()\n        .join()\n        .unwrap();\n}\n\npub trait SetMinMax {\n    fn set_min(&mut self, v: Self) -> bool;\n    fn set_max(&mut self, v: Self) -> bool;\n}\n\nimpl<T> SetMinMax for T\nwhere\n    T: PartialOrd,\n{\n    fn set_min(&mut self, v: T) -> bool {\n        *self > v && {\n            *self = v;\n            true\n        }\n    }\n    fn set_max(&mut self, v: T) -> bool {\n        *self < v && {\n            *self = v;\n            true\n        }\n    }\n}\n\n#[derive(PartialEq, Eq, Debug, Copy, Clone, Default, Hash)]\npub struct Reverse<T>(pub T);\n\nimpl<T: PartialOrd> PartialOrd for Reverse<T> {\n    #[inline]\n    fn partial_cmp(&self, other: &Reverse<T>) -> Option<Ordering> {\n        other.0.partial_cmp(&self.0)\n    }\n\n    #[inline]\n    fn lt(&self, other: &Self) -> bool {\n        other.0 < self.0\n    }\n    #[inline]\n    fn le(&self, other: &Self) -> bool {\n        other.0 <= self.0\n    }\n    #[inline]\n    fn ge(&self, other: &Self) -> bool {\n        other.0 >= self.0\n    }\n    #[inline]\n    fn gt(&self, other: &Self) -> bool {\n        other.0 > self.0\n    }\n}\n\nimpl<T: Ord> Ord for Reverse<T> {\n    #[inline]\n    fn cmp(&self, other: &Reverse<T>) -> Ordering {\n        other.0.cmp(&self.0)\n    }\n}\n\n#[allow(unused)] // This is defined for read! macro\nfn readln() -> String {\n    let mut line = String::new();\n    ::std::io::stdin()\n        .read_line(&mut line)\n        .unwrap_or_else(|e| panic!(\"{}\", e));\n    line\n}\n//}}}\n\n//{{{ https://github.com/ichyo/rust-algorithms.git\npub mod algonium {\n    #![doc = \" This library provides a collection of classic algorithms,\"]\n    #![doc = \" focusing on programming contests such as codeforces and atcoder.\"]\n    pub mod data_structure {\n        mod bit {\n            #[doc = \" Binary Indexed Tree (0-indexed)\"]\n            #[doc = \"\"]\n            #[doc = \" This data structure supports these two queries in O(log n)\"]\n            #[doc = \"\"]\n            #[doc = \" 1. add w to v[at]\"]\n            #[doc = \" 2. the sum of v[begin], v[begin+1], .., v[end-1]\"]\n            pub struct BIT {\n                tree: Vec<i64>,\n            }\n            #[doc = \" Binary Indexed Tree (range-version) (0-indexed)\"]\n            #[doc = \"\"]\n            #[doc = \" This data structure two queries in O(log n)\"]\n            #[doc = \"\"]\n            #[doc = \" 1. add w to v[begin], v[begin+1], ..., v[end-1]\"]\n            #[doc = \" 2. get the sum of v[begin], v[begin+1], ..., v[end-1]\"]\n            pub struct BITRange {\n                bit0: BIT,\n                bit1: BIT,\n            }\n            impl BIT {\n                #[doc = \" Constructs a new BIT of length `len`.\"]\n                #[doc = \" All values are initialized zero.\"]\n                #[doc = \"\"]\n                #[doc = \" # Examples\"]\n                #[doc = \" ```\"]\n                #[doc = \" use algonium::data_structure::BIT;\"]\n                #[doc = \" # #[warn(unused_mut)]\"]\n                #[doc = \" let mut bit = BIT::new(100);\"]\n                #[doc = \" ```\"]\n                pub fn new(len: usize) -> BIT {\n                    BIT { tree: vec![0; len] }\n                }\n                #[doc = \" Returns the number of elements in the BIT.\"]\n                #[doc = \"\"]\n                #[doc = \" # Examples\"]\n                #[doc = \"\"]\n                #[doc = \" ```\"]\n                #[doc = \" use algonium::data_structure::BIT;\"]\n                #[doc = \" let mut bit = BIT::new(100);\"]\n                #[doc = \" assert_eq!(bit.len(), 100);\"]\n                #[doc = \" ```\"]\n                pub fn len(&self) -> usize {\n                    self.tree.len()\n                }\n                #[doc = \" Add a value `value` to a element of index `index`.\"]\n                #[doc = \" v[index] += value\"]\n                #[doc = \"\"]\n                #[doc = \" # Panics\"]\n                #[doc = \"\"]\n                #[doc = \" Panics if `index > len`\"]\n                #[doc = \"\"]\n                #[doc = \" # Examples\"]\n                #[doc = \"\"]\n                #[doc = \" ```\"]\n                #[doc = \" use algonium::data_structure::BIT;\"]\n                #[doc = \" let mut bit = BIT::new(10);\"]\n                #[doc = \" bit.add(5, 100);\"]\n                #[doc = \" assert_eq!(bit.get(3, 6), 100);\"]\n                #[doc = \" bit.add(5, 10);\"]\n                #[doc = \" assert_eq!(bit.get(3, 6), 110);\"]\n                #[doc = \" ```\"]\n                pub fn add(&mut self, index: usize, value: i64) {\n                    assert!(index < self.tree.len());\n                    let mut idx = index;\n                    while idx < self.tree.len() {\n                        self.tree[idx] += value;\n                        idx |= idx + 1;\n                    }\n                }\n                #[doc = \" sum of v[idx] such that begin <= idx < end\"]\n                pub fn get(&self, begin: usize, end: usize) -> i64 {\n                    if begin >= end {\n                        return 0;\n                    }\n                    let a = if end > 0 { self.cum(end - 1) } else { 0 };\n                    let b = if begin > 0 { self.cum(begin - 1) } else { 0 };\n                    a - b\n                }\n                #[doc = \" v[0] + ... + v[last]\"]\n                fn cum(&self, last: usize) -> i64 {\n                    assert!(last < self.tree.len());\n                    let mut res = 0;\n                    let mut idx = last as i64;\n                    while idx >= 0 {\n                        res += self.tree[idx as usize];\n                        idx = (idx & (idx + 1)) - 1;\n                    }\n                    res\n                }\n            }\n            impl BITRange {\n                pub fn new(n: usize) -> BITRange {\n                    BITRange {\n                        bit0: BIT::new(n + 1),\n                        bit1: BIT::new(n + 1),\n                    }\n                }\n                #[doc = \" v[begin], v[begin+1], ..., v[end-1] += by\"]\n                pub fn add(&mut self, begin: usize, end: usize, by: i64) {\n                    if begin >= end {\n                        return;\n                    }\n                    let a = begin as i64;\n                    let b = end as i64;\n                    self.bit0.add(begin, -by * a);\n                    self.bit0.add(end, by * b);\n                    self.bit1.add(begin, by);\n                    self.bit1.add(end, -by);\n                }\n                #[doc = \" v[begin] + ... + v[end-1]\"]\n                pub fn get(&self, begin: usize, end: usize) -> i64 {\n                    if begin >= end {\n                        return 0;\n                    }\n                    self.cum(end) - self.cum(begin)\n                }\n                #[doc = \" v[0] + ... + v[end-1]\"]\n                fn cum(&self, end: usize) -> i64 {\n                    let a = self.bit0.get(0, end);\n                    let b = self.bit1.get(0, end);\n                    a + b * end as i64\n                }\n            }\n            #[cfg(test)]\n            mod tests {\n                use super::*;\n                #[test]\n                #[should_panic]\n                fn test_out_of_bound_add() {\n                    let mut bit = BIT::new(10);\n                    bit.add(100, 1);\n                }\n                #[test]\n                #[should_panic]\n                fn test_out_of_bound_range_add() {\n                    let mut bit = BITRange::new(10);\n                    bit.add(5, 100, 1);\n                }\n                #[test]\n                #[should_panic]\n                fn test_out_of_bound_get() {\n                    let bit = BIT::new(10);\n                    bit.get(0, 1000);\n                }\n                #[test]\n                fn test_empty_range() {\n                    let mut bit = BITRange::new(10);\n                    bit.add(9, 0, 100);\n                    bit.add(7, 3, 100);\n                    assert_eq!(0, bit.get(0, 9));\n                    assert_eq!(0, bit.get(0, 5));\n                    assert_eq!(0, bit.get(2, 5));\n                }\n                #[test]\n                fn test_simple() {\n                    let mut bit = BIT::new(10);\n                    bit.add(2, 1);\n                    bit.add(3, 3);\n                    bit.add(5, 10);\n                    bit.add(0, -4);\n                    bit.add(9, -5);\n                    assert_eq!(5, bit.get(0, 10));\n                    assert_eq!(4, bit.get(2, 4));\n                    assert_eq!(1, bit.get(2, 3));\n                    assert_eq!(0, bit.get(2, 2));\n                    assert_eq!(0, bit.get(2, 0));\n                    assert_eq!(-4, bit.get(0, 1));\n                    assert_eq!(5, bit.get(5, 10));\n                    let mut bit = BITRange::new(10);\n                    bit.add(1, 3, 1);\n                    bit.add(2, 5, 2);\n                    assert_eq!(1, bit.get(1, 2));\n                    assert_eq!(4, bit.get(1, 3));\n                    assert_eq!(6, bit.get(1, 4));\n                    assert_eq!(6, bit.get(0, 4));\n                }\n            }\n        }\n        mod union_find {\n            #[doc = \" Disjoint-set data structure\"]\n            #[doc = \"\"]\n            #[doc = \" This provides operations for disjoint sets.\"]\n            #[doc = \" They runs in nearly constatant time.\"]\n            #[doc = \" (the actual time is `O(A(n))` where `A(n)` is the inverse of ackermann function.)\"]\n            #[doc = \"\"]\n            #[doc = \" 1. unite(x, y) - unite a set including x and another set including y into one.\"]\n            #[doc = \" 2. same(x, y) - determine if x and y are in the same set.\"]\n            #[doc = \" 3. size(x) - calculate the number of elements of the set including x.\"]\n            #[doc = \"\"]\n            #[doc = \" [`UnionFind::new(n)`](#method.new) creates n disjoint sets. `i`-th set contains single element `i` (0-indexed).\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::data_structure::UnionFind;\"]\n            #[doc = \"\"]\n            #[doc = \" let mut uf = UnionFind::new(4);\"]\n            #[doc = \" assert!(!uf.same(0, 1));\"]\n            #[doc = \"\"]\n            #[doc = \" uf.unite(0, 1);\"]\n            #[doc = \" assert!(uf.same(0, 1));\"]\n            #[doc = \" assert_eq!(uf.size(0), 2);\"]\n            #[doc = \"\"]\n            #[doc = \" uf.unite(1, 2);\"]\n            #[doc = \" assert!(uf.same(0, 2));\"]\n            #[doc = \" assert_eq!(uf.size(0), 3);\"]\n            #[doc = \" ```\"]\n            #[doc = \"\"]\n            #[doc = \" # Panics\"]\n            #[doc = \" panics if `x` or `y` is not less than number of elements given in the initialization method.\"]\n            #[doc = \"\"]\n            pub struct UnionFind {\n                data: Vec<i32>,\n            }\n            impl UnionFind {\n                #[doc = \" Creates a object with n disjoint sets. `i`-th set is `{ i }`.\"]\n                pub fn new(n: usize) -> UnionFind {\n                    UnionFind { data: vec![-1; n] }\n                }\n                #[doc = \" Unite a set including `x` and another set including y into one.\"]\n                #[doc = \" Returns `true` only if they were in different set.\"]\n                pub fn unite(&mut self, x: usize, y: usize) -> bool {\n                    let x = self.root(x);\n                    let y = self.root(y);\n                    if x != y {\n                        let (x, y) = if self.data[x] <= self.data[y] {\n                            (x, y)\n                        } else {\n                            (y, x)\n                        };\n                        self.data[x] += self.data[y];\n                        self.data[y] = x as i32;\n                    }\n                    x != y\n                }\n                #[doc = \" Returns `true` only if `x` and `y` are in a same set.\"]\n                pub fn same(&mut self, x: usize, y: usize) -> bool {\n                    self.root(x) == self.root(y)\n                }\n                #[doc = \" Returns the number of elements of a set including `x`.\"]\n                pub fn size(&mut self, x: usize) -> u32 {\n                    let r = self.root(x);\n                    (-self.data[r]) as u32\n                }\n                #[doc = \" internal method to return representative element of a set including `x`.\"]\n                pub fn root(&mut self, x: usize) -> usize {\n                    if self.data[x] < 0 {\n                        x\n                    } else {\n                        let nx = self.data[x] as usize;\n                        let r = self.root(nx);\n                        self.data[x] = r as i32;\n                        r\n                    }\n                }\n            }\n            #[cfg(test)]\n            mod tests {\n                use super::*;\n                #[test]\n                fn test_simple() {\n                    let mut uf = UnionFind::new(3);\n                    assert_eq!(1, uf.size(0));\n                    assert_eq!(1, uf.size(1));\n                    assert_eq!(1, uf.size(2));\n                    assert_eq!(0, uf.root(0));\n                    assert_eq!(1, uf.root(1));\n                    assert_eq!(2, uf.root(2));\n                    assert!(!uf.same(1, 2));\n                    uf.unite(1, 2);\n                    assert_ne!(uf.root(0), uf.root(2));\n                    assert_eq!(uf.root(1), uf.root(2));\n                    assert_eq!(1, uf.size(0));\n                    assert_eq!(2, uf.size(1));\n                    assert_eq!(2, uf.size(2));\n                    assert!(uf.same(1, 2));\n                    uf.unite(0, 1);\n                    assert_eq!(uf.root(0), uf.root(2));\n                    assert_eq!(uf.root(1), uf.root(2));\n                    assert_eq!(3, uf.size(0));\n                    assert_eq!(3, uf.size(1));\n                    assert_eq!(3, uf.size(2));\n                    assert!(uf.same(1, 2));\n                    assert!(uf.same(0, 2));\n                }\n            }\n        }\n        pub use self::bit::{BITRange, BIT};\n        pub use self::union_find::UnionFind;\n    }\n    pub mod math {\n        mod comb {\n            use super::mint::{Mint, Module};\n            #[doc = \" Useful struct to compute combinations\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::math::{Comb, Mod107, Mint107};\"]\n            #[doc = \" let comb: Comb<Mod107> = Comb::new(100);\"]\n            #[doc = \" assert_eq!(Mint107::from(24), comb.fact(4));\"]\n            #[doc = \" assert_eq!(Mint107::from(1), comb.fact(4) * comb.factinv(4));\"]\n            #[doc = \" assert_eq!(Mint107::from(12), comb.perm(4, 2));\"]\n            #[doc = \" assert_eq!(Mint107::from(6), comb.comb(4, 2));\"]\n            #[doc = \" assert_eq!(Mint107::from(10), comb.multi_comb(4, 2));\"]\n            #[doc = \" ```\"]\n            pub struct Comb<M: Module> {\n                fact: Vec<Mint<M>>,\n                factinv: Vec<Mint<M>>,\n            }\n            impl<M: Module> Comb<M> {\n                #[doc = \" Create a object that provides effiecint computation of combinations\"]\n                #[doc = \" for input smaller than `n`.\"]\n                #[doc = \"\"]\n                #[doc = \" This requires `O(n)` time.\"]\n                pub fn new(n: usize) -> Comb<M> {\n                    let mut fact: Vec<Mint<M>> = vec![0.into(); n + 1];\n                    let mut factinv: Vec<Mint<M>> = vec![0.into(); n + 1];\n                    fact[0] = 1.into();\n                    for i in 0..n {\n                        fact[i + 1] = fact[i] * (i + 1);\n                    }\n                    factinv[n] = fact[n].inv();\n                    for i in (0..n).rev() {\n                        factinv[i] = factinv[i + 1] * (i + 1);\n                    }\n                    Comb {\n                        fact: fact,\n                        factinv: factinv,\n                    }\n                }\n                #[doc = \" `n! = 1 * 2 * ... * n`\"]\n                #[doc = \"\"]\n                #[doc = \" `O(1)` if n is smaller than input in `new` method.\"]\n                pub fn fact(&self, n: u64) -> Mint<M> {\n                    if let Some(x) = self.fact.get(n as usize) {\n                        *x\n                    } else if n >= M::module() as u64 {\n                        Mint::from(0)\n                    } else {\n                        let mut res = 1.into();\n                        for a in 1..(n + 1) {\n                            res *= a;\n                        }\n                        res\n                    }\n                }\n                #[doc = \" returns `y` such that `n! * y == 1`.\"]\n                #[doc = \"\"]\n                #[doc = \" `O(1)` if n is smaller than input in `new` method.\"]\n                pub fn factinv(&self, n: u64) -> Mint<M> {\n                    if let Some(x) = self.factinv.get(n as usize) {\n                        *x\n                    } else {\n                        self.fact(n).inv()\n                    }\n                }\n                #[doc = \" `nPr = n! / (n - r)!`\"]\n                #[doc = \"\"]\n                #[doc = \" `O(1)` if n and r are smaller than input in `new` method.\"]\n                pub fn perm(&self, n: u64, r: u64) -> Mint<M> {\n                    if n >= r {\n                        self.fact(n) * self.factinv((n - r) as u64)\n                    } else {\n                        0.into()\n                    }\n                }\n                #[doc = \" `nCr = n! / (n - r)! / r!`.\"]\n                #[doc = \"\"]\n                #[doc = \" `O(1)` if n and r are smaller than input in `new` method.\"]\n                pub fn comb(&self, n: u64, r: u64) -> Mint<M> {\n                    let m = M::module() as u64;\n                    if n >= m {\n                        self.comb(n % m, r % m) * self.comb(n / m, r / m)\n                    } else if n >= r {\n                        self.fact(n) * self.factinv(n - r) * self.factinv(r)\n                    } else {\n                        Mint::from(0)\n                    }\n                }\n                #[doc = \" `(n + k - 1)! / k!`.\"]\n                #[doc = \"\"]\n                #[doc = \" `O(1)` if n and r are smaller than input in `new` method.\"]\n                pub fn multi_comb(&self, n: u64, r: u64) -> Mint<M> {\n                    if r == 0 {\n                        Mint::from(1)\n                    } else {\n                        self.comb(n + r - 1, r)\n                    }\n                }\n            }\n            #[cfg(test)]\n            mod tests {\n                use super::*;\n                #[test]\n                fn test_simple() {\n                    #[derive(Clone, Copy, Debug)]\n                    struct Mod;\n                    impl Module for Mod {\n                        fn module() -> u32 {\n                            1000000007\n                        }\n                    }\n                    let c = Comb::<Mod>::new(100);\n                    assert_eq!(Mint::from(336), c.perm(8, 3));\n                    assert_eq!(Mint::from(56), c.comb(8, 3));\n                    assert_eq!(Mint::from(10), c.multi_comb(3, 3));\n                }\n                #[test]\n                fn test_fact() {\n                    #[derive(Clone, Copy, Debug)]\n                    struct Mod;\n                    impl Module for Mod {\n                        fn module() -> u32 {\n                            1000000007\n                        }\n                    }\n                    let c = Comb::<Mod>::new(100);\n                    let p = 8721234;\n                    let mut f = Mint::from(1);\n                    for i in 1..(p + 1) {\n                        f *= i;\n                    }\n                    assert_eq!(f, c.fact(p));\n                }\n            }\n        }\n        mod mint {\n            use std::fmt;\n            use std::marker::PhantomData;\n            use std::mem;\n            use std::ops;\n            #[doc = \" Trait for `Mint`. `module()` should return prime number.\"]\n            pub trait Module: Copy + Clone {\n                fn module() -> u32;\n            }\n            #[doc = \" One of famous numbers in programming contest. `10^9 + 7`\"]\n            pub const MOD_107: u32 = 1_000_000_007;\n            #[doc = \" One of famous numbers in programming contest. `10^9 + 9`\"]\n            pub const MOD_109: u32 = 1_000_000_009;\n            #[doc = \" One of famous numbers in programming contest. `998_244_353`\"]\n            pub const MOD_998: u32 = 998_244_353;\n            #[doc = \" struct to implement Module trait. it returns `MOD_107`.\"]\n            #[derive(Debug, Copy, Clone)]\n            pub struct Mod107;\n            impl Module for Mod107 {\n                fn module() -> u32 {\n                    MOD_107\n                }\n            }\n            #[doc = \" struct to implement Module trait. it returns `MOD_109`.\"]\n            #[derive(Debug, Copy, Clone)]\n            pub struct Mod109;\n            impl Module for Mod109 {\n                fn module() -> u32 {\n                    MOD_109\n                }\n            }\n            #[doc = \" struct to implement Module trait. it returns `MOD_998`.\"]\n            #[derive(Debug, Copy, Clone)]\n            pub struct Mod998;\n            impl Module for Mod998 {\n                fn module() -> u32 {\n                    MOD_998\n                }\n            }\n            #[doc = \" Wrapper class to compute mod `1_000_000_007` automatically.\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::math::{Mint107, MOD_107};\"]\n            #[doc = \" let x: Mint107 = 1234567.into();\"]\n            #[doc = \" let y: Mint107 = 2345678.into();\"]\n            #[doc = \" let z = x * y;\"]\n            #[doc = \" # // TODO: implement convert to u64\"]\n            #[doc = \" assert_eq!(z.val as u64, 1234567u64 * 2345678u64 % MOD_107 as u64);\"]\n            #[doc = \" ```\"]\n            #[doc = \"\"]\n            pub type Mint107 = Mint<Mod107>;\n            #[doc = \" Wrapper class to compute mod `1_000_000_009` automatically.\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::math::{Mint109, MOD_109};\"]\n            #[doc = \" let x: Mint109 = 1234567.into();\"]\n            #[doc = \" let y: Mint109 = 2345678.into();\"]\n            #[doc = \" let z = x * y;\"]\n            #[doc = \" assert_eq!(z.val as u64, 1234567u64 * 2345678u64 % MOD_109 as u64);\"]\n            #[doc = \" ```\"]\n            #[doc = \"\"]\n            pub type Mint109 = Mint<Mod109>;\n            #[doc = \" Wrapper class to compute mod `998_244_353` automatically.\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::math::{Mint998, MOD_998};\"]\n            #[doc = \" let x: Mint998 = 1234567.into();\"]\n            #[doc = \" let y: Mint998 = 2345678.into();\"]\n            #[doc = \" let z = x * y;\"]\n            #[doc = \" assert_eq!(z.val as u64, 1234567u64 * 2345678u64 % MOD_998 as u64);\"]\n            #[doc = \" ```\"]\n            #[doc = \"\"]\n            pub type Mint998 = Mint<Mod998>;\n            #[doc = \" Wrapper class to compute modulo operation.\"]\n            #[doc = \" See examples\"]\n            #[doc = \" [`Mint107`](type.Mint107.html),\"]\n            #[doc = \" [`Mint109`](type.Mint109.html),\"]\n            #[doc = \" [`Mint998`](type.Mint998.html)\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::math::{Mint107, MOD_107};\"]\n            #[doc = \" let x: Mint107 = 1234567.into();\"]\n            #[doc = \" let y: Mint107 = 2345678.into();\"]\n            #[doc = \" let z = x * y;\"]\n            #[doc = \" assert_eq!(z.val as u64, 1234567u64 * 2345678u64 % MOD_107 as u64);\"]\n            #[doc = \" ```\"]\n            #[derive(Debug, Copy, Clone, Eq)]\n            pub struct Mint<M: Module> {\n                #[doc = \" internal value. this is always less than `self.module()`.\"]\n                pub val: u32,\n                m: PhantomData<M>,\n            }\n            impl<M: Module> Mint<M> {\n                fn module(self) -> u32 {\n                    M::module()\n                }\n                fn new(val: u32) -> Mint<M> {\n                    assert!(val < M::module());\n                    Mint {\n                        val: val,\n                        m: PhantomData,\n                    }\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::Add<T> for Mint<M> {\n                type Output = Mint<M>;\n                fn add(self, other: T) -> Mint<M> {\n                    let nval = self.val + other.into().val;\n                    Mint::new(if nval >= self.module() {\n                        nval - self.module()\n                    } else {\n                        nval\n                    })\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::Sub<T> for Mint<M> {\n                type Output = Mint<M>;\n                fn sub(self, other: T) -> Mint<M> {\n                    let nval = self.val + self.module() - other.into().val;\n                    Mint::new(if nval >= self.module() {\n                        nval - self.module()\n                    } else {\n                        nval\n                    })\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::Mul<T> for Mint<M> {\n                type Output = Mint<M>;\n                fn mul(self, other: T) -> Mint<M> {\n                    let nval = self.val as u64 * other.into().val as u64;\n                    Mint::new((nval % (self.module() as u64)) as u32)\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::Div<T> for Mint<M> {\n                type Output = Mint<M>;\n                fn div(self, other: T) -> Mint<M> {\n                    self * other.into().inv()\n                }\n            }\n            impl<M: Module> Mint<M> {\n                #[doc = \" Returns number `y` that satisfies `x * y == 1` where `x` is the original value.\"]\n                #[doc = \"\"]\n                #[doc = \" This assumes `module()` returns prime number.\"]\n                pub fn inv(self) -> Mint<M> {\n                    let mut a = self.val as i32;\n                    let mut b = self.module() as i32;\n                    let mut u = 1 as i32;\n                    let mut v = 0 as i32;\n                    while b != 0 {\n                        let t = a / b;\n                        a -= t * b;\n                        mem::swap(&mut a, &mut b);\n                        u -= t * v;\n                        mem::swap(&mut u, &mut v);\n                    }\n                    Mint::new(if u < 0 { u + self.module() as i32 } else { u } as u32)\n                }\n            }\n            impl<M: Module> PartialEq for Mint<M> {\n                fn eq(&self, other: &Mint<M>) -> bool {\n                    self.val == other.val\n                }\n            }\n            impl<M: Module> fmt::Display for Mint<M> {\n                fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n                    self.val.fmt(f)\n                }\n            }\n            macro_rules ! impl_signed_mint { ( $ ( $ t : ty ) * ) => ( $ ( impl < M : Module > From <$ t > for Mint < M > { # [ inline ] fn from ( x : $ t ) -> Mint < M > { let t = ( x as i64 ) % ( M :: module ( ) as i64 ) ; if x >= 0 { Mint { val : t as u32 , m : PhantomData } } else { Mint { val : ( M :: module ( ) as i64 + t ) as u32 , m : PhantomData } } } } ) * ) }\n            macro_rules ! impl_unsigned_mint { ( $ ( $ t : ty ) * ) => ( $ ( impl < M : Module > From <$ t > for Mint < M > { # [ inline ] fn from ( x : $ t ) -> Mint < M > { let t = x as u64 % M :: module ( ) as u64 ; Mint :: new ( t as u32 ) } } ) * ) }\n            impl_signed_mint! { i8 i16 i32 i64 isize }\n            impl_unsigned_mint! { u8 u16 u32 u64 usize }\n            impl<T: Into<Mint<M>>, M: Module> ops::AddAssign<T> for Mint<M> {\n                fn add_assign(&mut self, other: T) {\n                    *self = *self + other.into();\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::SubAssign<T> for Mint<M> {\n                fn sub_assign(&mut self, other: T) {\n                    *self = *self - other.into();\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::MulAssign<T> for Mint<M> {\n                fn mul_assign(&mut self, other: T) {\n                    *self = *self * other.into();\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::DivAssign<T> for Mint<M> {\n                fn div_assign(&mut self, other: T) {\n                    *self = *self / other.into();\n                }\n            }\n            #[cfg(test)]\n            mod tests {\n                use super::*;\n                #[test]\n                fn test_simple() {\n                    let a: Mint<Mod107> = Mint::from(3);\n                    let b: Mint<Mod107> = Mint::from(1000000000);\n                    assert_eq!(Mint::from(3000000000u64 % Mod107::module() as u64), a * b);\n                }\n            }\n        }\n        pub use self::comb::Comb;\n        pub use self::mint::{Mint, Module};\n        pub use self::mint::{Mint107, Mint109, Mint998};\n        pub use self::mint::{Mod107, Mod109, Mod998};\n        pub use self::mint::{MOD_107, MOD_109, MOD_998};\n    }\n    pub mod util {\n        mod permutation {\n            #[doc = \" It contains same methods as `std::next_permutaion` in C++.\"]\n            #[doc = \" these methods should rearrange the elements into the next/prev lexicographically greater permutation.\"]\n            #[doc = \"\"]\n            #[doc = \" This is implemented in [T] where T is Ord.\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::util::Permutation;\"]\n            #[doc = \"\"]\n            #[doc = \" let mut perm = [5, 0, 9, 2];\"]\n            #[doc = \" assert!(perm.next_permutation());\"]\n            #[doc = \" assert_eq!(perm, [5, 2, 0, 9]);\"]\n            #[doc = \" assert!(perm.next_permutation());\"]\n            #[doc = \" assert_eq!(perm, [5, 2, 9, 0]);\"]\n            #[doc = \" assert!(perm.prev_permutation());\"]\n            #[doc = \" assert_eq!(perm, [5, 2, 0, 9]);\"]\n            #[doc = \"\"]\n            #[doc = \" let mut perm = [4, 3, 2, 1, 0];\"]\n            #[doc = \" assert!(!perm.next_permutation());\"]\n            #[doc = \" assert_eq!(perm, [4, 3, 2, 1, 0]);\"]\n            #[doc = \" ```\"]\n            pub trait Permutation {\n                #[doc = \" It rearranges the elements into the next lexicographically greater permutation.\"]\n                #[doc = \"\"]\n                #[doc = \" Returns `false` without modifying any state only if current is the last permutation.\"]\n                fn next_permutation(&mut self) -> bool;\n                #[doc = \" It rearranges the elements into the previous lexicographically greater permutation.\"]\n                #[doc = \"\"]\n                #[doc = \" Returns `false` without modifying any state only if current is the first permutation.\"]\n                fn prev_permutation(&mut self) -> bool;\n            }\n            impl<T> Permutation for [T]\n            where\n                T: Ord,\n            {\n                fn next_permutation(&mut self) -> bool {\n                    if self.len() <= 1 {\n                        return false;\n                    }\n                    let mut i = self.len() - 1;\n                    while i > 0 && self[i - 1] >= self[i] {\n                        i -= 1;\n                    }\n                    if i == 0 {\n                        return false;\n                    }\n                    let mut j = self.len() - 1;\n                    while self[j] <= self[i - 1] {\n                        j -= 1;\n                    }\n                    self.swap(j, i - 1);\n                    self[i..].reverse();\n                    true\n                }\n                fn prev_permutation(&mut self) -> bool {\n                    if self.len() <= 1 {\n                        return false;\n                    }\n                    let mut i = self.len() - 1;\n                    while i > 0 && self[i - 1] <= self[i] {\n                        i -= 1;\n                    }\n                    if i == 0 {\n                        return false;\n                    }\n                    self[i..].reverse();\n                    let mut j = self.len() - 1;\n                    while self[j - 1] < self[i - 1] {\n                        j -= 1;\n                    }\n                    self.swap(i - 1, j);\n                    true\n                }\n            }\n            #[cfg(test)]\n            mod tests {\n                use super::*;\n                #[test]\n                fn test_simple() {\n                    let mut data = [0, 0, 1, 1, 2];\n                    data.next_permutation();\n                    assert_eq!(&data, &[0, 0, 1, 2, 1]);\n                    data.next_permutation();\n                    assert_eq!(&data, &[0, 0, 2, 1, 1]);\n                    data.next_permutation();\n                    assert_eq!(&data, &[0, 1, 0, 1, 2]);\n                    data.next_permutation();\n                    assert_eq!(&data, &[0, 1, 0, 2, 1]);\n                    data.next_permutation();\n                    assert_eq!(&data, &[0, 1, 1, 0, 2]);\n                    data.prev_permutation();\n                    assert_eq!(&data, &[0, 1, 0, 2, 1]);\n                    data.prev_permutation();\n                    assert_eq!(&data, &[0, 1, 0, 1, 2]);\n                    data.prev_permutation();\n                    assert_eq!(&data, &[0, 0, 2, 1, 1]);\n                    data.prev_permutation();\n                    assert_eq!(&data, &[0, 0, 1, 2, 1]);\n                    data.prev_permutation();\n                    assert_eq!(&data, &[0, 0, 1, 1, 2]);\n                    assert!(!data.prev_permutation());\n                }\n            }\n        }\n        mod random {\n            use std::num::Wrapping;\n            #[doc = \" Not secure but fast random generator.\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::util::XorShift;\"]\n            #[doc = \" let mut xorshift = XorShift::new();\"]\n            #[doc = \" assert_eq!(3701687786, xorshift.next_u32());\"]\n            #[doc = \" assert_eq!(458299110, xorshift.next_u32());\"]\n            #[doc = \" ```\"]\n            #[derive(Clone, Debug, Default)]\n            pub struct XorShift {\n                x: Wrapping<u32>,\n                y: Wrapping<u32>,\n                z: Wrapping<u32>,\n                w: Wrapping<u32>,\n            }\n            impl XorShift {\n                #[doc = \" Create object with default seed.\"]\n                pub fn new() -> XorShift {\n                    XorShift {\n                        x: Wrapping(123_456_789),\n                        y: Wrapping(362_436_069),\n                        z: Wrapping(521_288_629),\n                        w: Wrapping(88_675_123),\n                    }\n                }\n                #[doc = \" Get next random u32 number.\"]\n                pub fn next_u32(&mut self) -> u32 {\n                    let x = self.x;\n                    let t = x ^ (x << 11);\n                    self.x = self.y;\n                    self.y = self.z;\n                    self.z = self.w;\n                    let v = self.w;\n                    self.w = v ^ (v >> 19) ^ (t ^ (t >> 8));\n                    self.w.0\n                }\n            }\n            #[cfg(test)]\n            mod tests {\n                use super::XorShift;\n                #[test]\n                fn test_basic() {\n                    let mut xorshift = XorShift::new();\n                    assert_eq!(3701687786, xorshift.next_u32());\n                    assert_eq!(458299110, xorshift.next_u32());\n                }\n            }\n        }\n        pub use self::permutation::Permutation;\n        pub use self::random::XorShift;\n    }\n}\n\n//}}}\n"
  },
  {
    "language": "Rust",
    "code": "use std::cmp;\n\nconst INF: i64 = 1e17 as i64;\n\nfn main() {\n    let s = std::io::stdin();\n    let mut sc = Scanner { reader: s.lock() };\n    let n: usize = sc.read();\n    let a: Vec<i64> = sc.read_vec(n);\n    let mut graph = vec![vec![]; n];\n    for _ in 0..(n - 1) {\n        let v = sc.read::<usize>() - 1;\n        let u = sc.read::<usize>() - 1;\n        graph[v].push(u);\n        graph[u].push(v);\n    }\n\n    let mut dp1 = vec![vec![]; n];\n    let mut dp2 = vec![vec![]; n];\n    dfs(0, 0, &graph, &a, &mut dp1, &mut dp2);\n\n    for i in 0..n {\n        if dp1[0][i] < INF {\n            println!(\"{}\", i);\n            return;\n        }\n        if dp2[0][i] < 0 {\n            println!(\"{}\", i);\n            return;\n        }\n    }\n}\n\nfn dfs(\n    v: usize,\n    p: usize,\n    graph: &Vec<Vec<usize>>,\n    a: &Vec<i64>,\n    dp1: &mut Vec<Vec<i64>>,\n    dp2: &mut Vec<Vec<i64>>,\n) {\n    dp1[v].push(if a[v] > 0 { a[v] } else { INF });\n    dp2[v].push(a[v]);\n    for &next in graph[v].iter() {\n        if next == p { continue; }\n        dfs(next, v, graph, a, dp1, dp2);\n\n        dp1[v] = connect(&dp1[v], &dp1[next], &dp2[next], true);\n        dp2[v] = connect(&dp2[v], &dp1[next], &dp2[next], false);\n    }\n}\n\nfn connect(dp: &Vec<i64>, child1: &Vec<i64>, child2: &Vec<i64>, power_only: bool) -> Vec<i64> {\n    let mut ans = vec![INF; dp.len() + child1.len() + 1];\n    for cuts in 0..dp.len() {\n        if dp[cuts] == INF { continue; }\n        for child_cuts in 0..child1.len() {\n            let total_cuts = cuts + child_cuts + 1;\n\n            if child1[child_cuts] != INF {\n                ch_min(&mut ans[total_cuts - 1], dp[cuts] + child1[child_cuts]);\n            }\n            if child2[child_cuts] != INF && !power_only {\n                ch_min(&mut ans[total_cuts - 1], dp[cuts] + child2[child_cuts]);\n            }\n            if child1[child_cuts] != INF || child2[child_cuts] < 0 {\n                ch_min(&mut ans[total_cuts], dp[cuts]);\n            }\n        }\n    }\n    ans\n}\n\nfn ch_min<T: PartialOrd>(a: &mut T, b: T) {\n    if *a > b {\n        *a = b;\n    }\n}\n\npub struct Scanner<R> {\n    reader: R,\n}\n\nimpl<R: std::io::Read> Scanner<R> {\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .reader\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n')\n            .take_while(|&b| b != b' ' && b != b'\\n')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn read_vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::cmp;\n\nconst INF: i64 = 1 << 50;\n\nfn main() {\n    let s = std::io::stdin();\n    let mut sc = Scanner { stdin: s.lock() };\n\n    let n = sc.read();\n    let a: Vec<i64> = sc.vec(n);\n    let mut graph = vec![vec![]; n];\n    for _ in 1..n {\n        let u = sc.read::<usize>() - 1;\n        let v = sc.read::<usize>() - 1;\n        graph[u].push(v);\n        graph[v].push(u);\n    }\n\n    let mut power_dp = vec![vec![]; n];\n    let mut min_dp = vec![vec![]; n];\n    dfs(0, 0, &a, &graph, &mut min_dp, &mut power_dp);\n    for i in 0..n {\n        if power_dp[0][i] < INF || min_dp[0][i] < 0 {\n            println!(\"{}\", i);\n            return;\n        }\n    }\n}\n\nfn dfs(\n    v: usize,\n    p: usize,\n    a: &Vec<i64>,\n    graph: &Vec<Vec<usize>>,\n    min_dp: &mut Vec<Vec<i64>>,\n    power_dp: &mut Vec<Vec<i64>>,\n) {\n    power_dp[v].push(if a[v] > 0 { a[v] } else { INF });\n    min_dp[v].push(a[v]);\n    for &child in graph[v].iter() {\n        if child == p {\n            continue;\n        }\n        dfs(child, v, a, graph, min_dp, power_dp);\n        power_dp[v] = connect(&power_dp[v], &power_dp[child], &min_dp[child], true);\n        min_dp[v] = connect(&min_dp[v], &power_dp[child], &min_dp[child], false);\n    }\n}\n\nfn connect(dp: &Vec<i64>, power: &Vec<i64>, min: &Vec<i64>, is_power: bool) -> Vec<i64> {\n    let mut next = vec![INF; dp.len() + power.len() + 1];\n    for parent_cut in 0..dp.len() {\n        for child_cut in 0..power.len() {\n            let total_cut = parent_cut + child_cut;\n            if power[child_cut] < INF {\n                chmin(&mut next[total_cut], dp[parent_cut] + power[child_cut]);\n            }\n            if min[child_cut] < INF && !is_power {\n                chmin(&mut next[total_cut], dp[parent_cut] + min[child_cut]);\n            }\n            if power[child_cut] < INF || min[child_cut] < 0 {\n                chmin(&mut next[total_cut + 1], dp[parent_cut]);\n            }\n        }\n    }\n    next\n}\n\nfn chmin<T: Ord>(a: &mut T, b: T) {\n    if *a > b {\n        *a = b;\n    }\n}\n\npub struct Scanner<R> {\n    stdin: R,\n}\n\nimpl<R: std::io::Read> Scanner<R> {\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .stdin\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n' || b == b'\\r')\n            .take_while(|&b| b != b' ' && b != b'\\n' && b != b'\\r')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::cmp;\n\nconst INF: i64 = 1e17 as i64;\n\nfn main() {\n    let s = std::io::stdin();\n    let mut sc = Scanner { reader: s.lock() };\n    let n: usize = sc.read();\n    let a: Vec<i64> = sc.read_vec(n);\n    let mut graph = vec![vec![]; n];\n    for _ in 0..(n - 1) {\n        let v = sc.read::<usize>() - 1;\n        let u = sc.read::<usize>() - 1;\n        graph[v].push(u);\n        graph[u].push(v);\n    }\n\n    let mut dp1 = vec![vec![]; n];\n    let mut dp2 = vec![vec![]; n];\n    dfs(0, 0, &graph, &a, &mut dp1, &mut dp2);\n\n    for i in 1..(n + 1) {\n        if dp1[0][i] < INF {\n            println!(\"{}\", i - 1);\n            return;\n        }\n        if dp2[0][i] < 0 {\n            println!(\"{}\", i - 1);\n            return;\n        }\n    }\n}\n\nfn dfs(\n    v: usize,\n    p: usize,\n    graph: &Vec<Vec<usize>>,\n    a: &Vec<i64>,\n    dp1: &mut Vec<Vec<i64>>,\n    dp2: &mut Vec<Vec<i64>>,\n) {\n    dp1[v].push(INF);\n    dp1[v].push(if a[v] > 0 { a[v] } else { INF });\n    dp2[v].push(INF);\n    dp2[v].push(a[v]);\n    for &next in graph[v].iter() {\n        if next == p {\n            continue;\n        }\n        dfs(next, v, graph, a, dp1, dp2);\n\n        dp1[v] = tr(&dp1[v], &dp1[next], &dp2[next], true);\n        dp2[v] = tr(&dp2[v], &dp1[next], &dp2[next], false);\n    }\n}\n\nfn tr(dp: &Vec<i64>, ch1: &Vec<i64>, ch2: &Vec<i64>, flag: bool) -> Vec<i64> {\n    let child_cuts = ch1.len();\n    assert_eq!(child_cuts, ch2.len());\n    let mut ans = vec![INF; dp.len() + child_cuts - 1];\n    for i in 0..dp.len() {\n        if dp[i] == INF {\n            continue;\n        }\n        for j in 0..child_cuts {\n            if i + j >= 1 {\n                if ch1[j] != INF {\n                    ans[i + j - 1] = cmp::min(ans[i + j - 1], dp[i] + ch1[j]);\n                }\n                if ch2[j] != INF && !flag {\n                    ans[i + j - 1] = cmp::min(ans[i + j - 1], dp[i] + ch2[j]);\n                }\n            }\n            if ch1[j] != INF || ch2[j] < 0 {\n                ans[i + j] = cmp::min(ans[i + j], dp[i]);\n            }\n        }\n    }\n    ans\n}\n\npub struct Scanner<R> {\n    reader: R,\n}\n\nimpl<R: std::io::Read> Scanner<R> {\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .reader\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n')\n            .take_while(|&b| b != b' ' && b != b'\\n')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn read_vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_macros)]\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, bytes) => {\n        read_value!($next, String).into_bytes()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\nmod inf {\n    use std::cmp::min;\n    use std::ops::Add;\n\n    #[derive(PartialEq, Eq, PartialOrd, Ord, Clone, Copy)]\n    pub enum Inf<T> {\n        NotInf(T),\n        Inf,\n    }\n\n    impl<T> From<T> for Inf<T> {\n        fn from(v: T) -> Self {\n            Inf::NotInf(v)\n        }\n    }\n\n    impl<T: Add<Output = T>> Add for Inf<T> {\n        type Output = Inf<T>;\n        fn add(self, rhs: Self) -> Self {\n            use self::Inf::*;\n            match (self, rhs) {\n                (NotInf(a), NotInf(b)) => NotInf(a + b),\n                _ => Inf,\n            }\n        }\n    }\n\n    impl<T: Clone + Ord> Inf<T> {\n        pub fn min_assign(&mut self, rhs: Self) {\n            *self = min(self.clone(), rhs);\n        }\n    }\n}\n\n// fn min_assign<T: Ord + Clone>(l: &mut T, r: T) {\n//     *l = std::cmp::min((*l).clone(), r);\n// }\n\nuse inf::Inf::{self, *};\n\nfn main() {\n    input! {\n        n: usize,\n        a: [i64; n],\n        es: [(usize1, usize1); n-1],\n    }\n\n    let mut g = vec![vec![]; n];\n    for &(u, v) in es.iter() {\n        g[u].push(v);\n        g[v].push(u);\n    }\n\n    let ans = solve(0, None, &a, &g)\n        .iter()\n        .enumerate()\n        .find(|&(_, e)| e.0 != Inf || e.1 < 0.into())\n        .unwrap()\n        .0;\n\n    println!(\"{}\", ans);\n}\n\nfn solve(\n    v: usize,\n    prev: Option<usize>,\n    a: &Vec<i64>,\n    g: &Vec<Vec<usize>>,\n) -> Vec<(Inf<i64>, Inf<i64>)> {\n    let mut ret = vec![(if a[v] < 0 { Inf } else { a[v].into() }, a[v].into())];\n\n    for &u in g[v].iter().filter(|&&u| Some(u) != prev) {\n        let utbl = solve(u, Some(v), a, g);\n\n        let mut next = vec![(Inf, Inf); ret.len() + utbl.len()];\n        for i in 0..ret.len() {\n            for j in 0..utbl.len() {\n                if utbl[j].0 != Inf || utbl[j].1 < 0.into() {\n                    next[i + j + 1].0.min_assign(ret[i].0);\n                    next[i + j + 1].1.min_assign(ret[i].1);\n                }\n                next[i + j].0.min_assign(ret[i].0 + utbl[j].0);\n                next[i + j].1.min_assign(ret[i].1 + utbl[j].1);\n            }\n        }\n        ret = next;\n    }\n\n    ret\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::cmp;\n\nconst INF: i64 = 1e17 as i64;\n\nfn main() {\n    let s = std::io::stdin();\n    let mut sc = Scanner { reader: s.lock() };\n    let n: usize = sc.read();\n    let a: Vec<i64> = sc.read_vec(n);\n    let mut graph = vec![vec![]; n];\n    for _ in 0..(n - 1) {\n        let v = sc.read::<usize>() - 1;\n        let u = sc.read::<usize>() - 1;\n        graph[v].push(u);\n        graph[u].push(v);\n    }\n\n    let mut dp1 = vec![vec![]; n];\n    let mut dp2 = vec![vec![]; n];\n    dfs(0, 0, &graph, &a, &mut dp1, &mut dp2);\n\n    for i in 1..(n + 1) {\n        if dp1[0][i] < INF {\n            println!(\"{}\", i - 1);\n            return;\n        }\n        if dp2[0][i] < 0 {\n            println!(\"{}\", i - 1);\n            return;\n        }\n    }\n}\n\nfn dfs(\n    v: usize,\n    p: usize,\n    graph: &Vec<Vec<usize>>,\n    a: &Vec<i64>,\n    dp1: &mut Vec<Vec<i64>>,\n    dp2: &mut Vec<Vec<i64>>,\n) {\n    dp1[v].push(INF);\n    dp1[v].push(if a[v] > 0 { a[v] } else { INF });\n    dp2[v].push(INF);\n    dp2[v].push(a[v]);\n    for &next in graph[v].iter() {\n        if next == p { continue; }\n        dfs(next, v, graph, a, dp1, dp2);\n\n        dp1[v] = connect(&dp1[v], &dp1[next], &dp2[next], true);\n        dp2[v] = connect(&dp2[v], &dp1[next], &dp2[next], false);\n    }\n}\n\nfn connect(dp: &Vec<i64>, child1: &Vec<i64>, child2: &Vec<i64>, flag: bool) -> Vec<i64> {\n    assert_eq!(child1.len(), child2.len());\n    let child_cuts = child1.len() - 1;\n    let mut ans = vec![INF; dp.len() + child_cuts];\n    for i in 0..dp.len() {\n        if dp[i] == INF { continue; }\n        for j in 0..child1.len() {\n            if i + j >= 1 {\n                if child1[j] != INF {\n                    ans[i + j - 1] = cmp::min(ans[i + j - 1], dp[i] + child1[j]);\n                }\n                if child2[j] != INF && !flag {\n                    ans[i + j - 1] = cmp::min(ans[i + j - 1], dp[i] + child2[j]);\n                }\n            }\n            if child1[j] != INF || child2[j] < 0 {\n                ans[i + j] = cmp::min(ans[i + j], dp[i]);\n            }\n        }\n    }\n    ans\n}\n\nfn ch_min<T: PartialOrd>(a: &mut T, b: T) {\n    if *a > b {\n        *a = b;\n    }\n}\n\npub struct Scanner<R> {\n    reader: R,\n}\n\nimpl<R: std::io::Read> Scanner<R> {\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .reader\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n')\n            .take_while(|&b| b != b' ' && b != b'\\n')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn read_vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_macros)]\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, bytes) => {\n        read_value!($next, String).into_bytes()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\nuse std::cmp::min;\n\nfn main() {\n    input! {\n        n: usize,\n        a: [i64; n],\n        es: [(usize1, usize1); n-1],\n    }\n\n    let mut g = vec![vec![]; n];\n    for &(u, v) in es.iter() {\n        g[u].push(v);\n        g[v].push(u);\n    }\n\n    let mut tbl = vec![vec![]; n + 1];\n    solve(0, None, &a, &g, &mut tbl);\n\n    let mut ans = INF;\n    for i in 0..n + 1 {\n        if tbl[0][i].0 != INF || tbl[0][i].1 < 0 {\n            ans = i as i64;\n            break;\n        }\n    }\n\n    println!(\"{}\", ans);\n}\n\nconst INF: i64 = 1_000_000_000_000_000;\n\nfn solve(\n    v: usize,\n    prev: Option<usize>,\n    a: &Vec<i64>,\n    g: &Vec<Vec<usize>>,\n    tbl: &mut Vec<Vec<(i64, i64)>>,\n) {\n    let mut ret = vec![(INF, INF); g.len() + 1];\n    ret[0] = if a[v] < 0 { (INF, a[v]) } else { (a[v], a[v]) };\n\n    for &u in g[v].iter() {\n        if Some(u) == prev {\n            continue;\n        }\n\n        solve(u, Some(v), a, g, tbl);\n\n        let mut next = vec![(INF, INF); ret.len()];\n        for i in 0..ret.len() {\n            for j in 0..ret.len() {\n                if i + j + 1 < ret.len() {\n                    if tbl[u][j].0 != INF || tbl[u][j].1 < 0 {\n                        next[i + j + 1].0 = min(next[i + j + 1].0, ret[i].0);\n                        next[i + j + 1].1 = min(next[i + j + 1].1, ret[i].1);\n                    }\n                }\n\n                if i + j < ret.len() {\n                    if ret[i].0 != INF && tbl[u][j].0 != INF {\n                        next[i + j].0 = min(next[i + j].0, ret[i].0 + tbl[u][j].0);\n                    }\n                    if ret[i].1 != INF && tbl[u][j].1 != INF {\n                        next[i + j].1 = min(next[i + j].1, ret[i].1 + tbl[u][j].1);\n                    }\n                }\n            }\n        }\n\n        ret = next;\n    }\n\n    tbl[v] = ret;\n}\n"
  },
  {
    "language": "Rust",
    "code": "const INF: i64 = 1e15 as i64;\nfn main() {\n    let s = std::io::stdin();\n    let mut sc = Scanner { stdin: s.lock() };\n\n    let n: usize = sc.read();\n    let a: Vec<i64> = sc.vec(n);\n    let mut tree = vec![vec![]; n];\n    for _ in 1..n {\n        let u = sc.read::<usize>() - 1;\n        let v = sc.read::<usize>() - 1;\n        tree[u].push(v);\n        tree[v].push(u);\n    }\n\n    let mut power_dp = vec![vec![]; n];\n    let mut dp = vec![vec![]; n];\n    dfs(0, 0, &tree, &mut power_dp, &mut dp, &a);\n\n    for i in 0..power_dp[0].len() {\n        if power_dp[0][i] > 0 && power_dp[0][i] < INF {\n            println!(\"{}\", i);\n            return;\n        }\n        if dp[0][i] < 0 {\n            println!(\"{}\", i);\n            return;\n        }\n    }\n}\n\nfn dfs(\n    v: usize,\n    p: usize,\n    tree: &Vec<Vec<usize>>,\n    power_dp: &mut Vec<Vec<i64>>,\n    dp: &mut Vec<Vec<i64>>,\n    a: &[i64],\n) {\n    power_dp[v] = if a[v] > 0 { vec![a[v]] } else { vec![INF] };\n    dp[v] = vec![a[v]];\n    for &next in tree[v].iter() {\n        if p == next {\n            continue;\n        }\n        dfs(next, v, tree, power_dp, dp, a);\n        power_dp[v] = connect(&power_dp[v], &power_dp[next], &dp[next], true);\n        dp[v] = connect(&dp[v], &power_dp[next], &dp[next], false);\n    }\n}\n\nfn connect(cur: &[i64], power: &[i64], dp: &[i64], for_power: bool) -> Vec<i64> {\n    let main_cuts = cur.len();\n    let child_cuts = power.len();\n    let mut next = vec![INF; main_cuts + child_cuts + 1];\n    for main_cut in 0..main_cuts {\n        let main_top = cur[main_cut];\n        if main_top >= INF {\n            continue;\n        }\n        for child_cut in 0..child_cuts {\n            let child_power_top = power[child_cut];\n            let child_top = dp[child_cut];\n            if child_power_top < INF {\n                apply_min(&mut next[child_cut + main_cut], main_top + child_power_top);\n            }\n            if !for_power && child_top < INF {\n                apply_min(&mut next[child_cut + main_cut], main_top + child_top);\n            }\n\n            if child_top < 0 || (child_power_top > 0 && child_power_top < INF) {\n                if !for_power {\n                    apply_min(&mut next[child_cut + main_cut + 1], main_top);\n                } else if main_top > 0 {\n                    apply_min(&mut next[child_cut + main_cut + 1], main_top);\n                }\n            }\n        }\n    }\n    next\n}\n\nfn apply_min<T: Ord>(x: &mut T, y: T) {\n    if *x > y {\n        *x = y;\n    }\n}\n\npub struct Scanner<R> {\n    stdin: R,\n}\n\nimpl<R: std::io::Read> Scanner<R> {\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .stdin\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n')\n            .take_while(|&b| b != b' ' && b != b'\\n')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "macro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String {\n            bytes\n                .by_ref()\n                .map(|r| r.unwrap() as char)\n                .skip_while(|c| c.is_whitespace())\n                .take_while(|c| !c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n    ($next:expr, mut $var:ident : $t:tt $($r:tt)*) => {\n        let mut $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\nuse std::cmp::min;\n\nfn main() {\n    input!{\n        n: usize,\n        a: [i64; n],\n        uv: [[usize1; 2]; n - 1]\n    }\n    let mut tr: Vec<Vec<usize>> = vec![Vec::new(); n];\n    for e in uv {\n        tr[e[0]].push(e[1]);\n        tr[e[1]].push(e[0]);\n    }\n    rem_dfs(0, 0, &mut tr);\n    let mut tab1: Vec<Vec<i64>> = vec![vec![i64::max_value(); n]; n];\n    let mut tab2: Vec<Vec<i64>> = vec![vec![i64::max_value(); n]; n];\n    dfs(&tr, &a, 0, &mut tab1, &mut tab2);\n    for i in 0..n {\n        if tab1[0][i] < i64::max_value() || tab2[0][i] < 0 {\n            println!(\"{}\", i);\n            return;\n        }\n    }\n}\n\nfn rem_dfs(r: usize, p: usize, t: &mut Vec<Vec<usize>>) {\n    let mut remi = None;\n    for i in 0..t[r].len() {\n        if t[r][i] == p {\n            remi = Some(i);\n        } else {\n            rem_dfs(t[r][i], r, t);\n        }\n    }\n    if let Some(i) = remi {\n        t[r].remove(i);\n    }\n}\n\nfn dfs(t: &Vec<Vec<usize>>, a: &Vec<i64>, r: usize, tab1: &mut Vec<Vec<i64>>, tab2: &mut Vec<Vec<i64>>) {\n    let n = t.len();\n    if t[r].len() == 0 {\n        if a[r] > 0 {\n            tab1[r][0] = a[r];\n        }\n        tab2[r][0] = a[r];\n        return;\n    }\n    let nc = t[r].len();\n    let mut tab3: Vec<Vec<i64>> = vec![vec![i64::max_value(); n]; nc];\n    let mut tab4: Vec<Vec<i64>> = vec![vec![i64::max_value(); n]; nc];\n    for i in 0..nc {\n        let c = t[r][i];\n        dfs(t, a, c, tab1, tab2);\n        if i == 0 {\n            for j in 0..n {\n                if a[r] > 0 && tab1[c][j] < i64::max_value() {\n                    tab3[0][j] = min(tab3[0][j], tab1[c][j] + a[r]);\n                }\n                if tab2[c][j] < i64::max_value() {\n                    tab4[0][j] = min(tab4[0][j], tab2[c][j] + a[r]);\n                }\n                if tab1[c][j] < i64::max_value() || tab2[c][j] < 0 {\n                    if a[r] > 0 {\n                        tab3[0][j + 1] = min(tab3[0][j + 1], a[r]);\n                    }\n                    tab4[0][j + 1] = min(tab4[0][j + 1], a[r]);\n                }\n            }\n            continue;\n        }\n        for j in 0..n {\n            if a[r] > 0 && tab1[c][j] < i64::max_value() {\n                for k in 0..n - j {\n                    if tab3[i - 1][k] < i64::max_value() {\n                        tab3[i][j + k] = min(tab3[i][j + k], tab1[c][j] + tab3[i - 1][k]);\n                    }\n                }\n            }\n            if tab2[c][j] < i64::max_value() {\n                for k in 0..n - j {\n                    if tab4[i - 1][k] < i64::max_value() {\n                        tab4[i][j + k] = min(tab4[i][j + k], tab2[c][j] + tab4[i - 1][k]);\n                    }\n                }\n            }\n            if tab1[c][j] < i64::max_value() || tab2[c][j] < 0 {\n                if a[r] > 0 {\n                    for k in 0..n - j - 1 {\n                        tab3[i][j + k + 1] = min(tab3[i][j + k + 1], tab3[i - 1][k]);\n                    }\n                }\n                for k in 0..n - j - 1{\n                    tab4[i][j + k + 1] = min(tab4[i][j + k + 1], tab4[i - 1][k]);\n                }\n            }\n        }\n    }\n    for i in 0..n {\n        tab1[r][i] = tab3[nc - 1][i];\n        tab2[r][i] = tab4[nc - 1][i];\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "const INF: i64 = 1 << 50;\nfn main() {\n    let s = std::io::stdin();\n    let mut sc = Scanner { stdin: s.lock() };\n\n    let n = sc.read();\n    let a: Vec<i64> = sc.vec(n);\n    let mut graph = vec![vec![]; n];\n    for _ in 1..n {\n        let u = sc.read::<usize>() - 1;\n        let v = sc.read::<usize>() - 1;\n        graph[v].push(u);\n        graph[u].push(v);\n    }\n\n    let mut min_dp = vec![vec![]; n];\n    let mut power_dp = vec![vec![]; n];\n    dfs(0, 0, &a, &graph, &mut min_dp, &mut power_dp);\n    for i in 0..n {\n        if min_dp[0][i] < 0 || power_dp[0][i] < INF {\n            println!(\"{}\", i);\n            return;\n        }\n    }\n}\n\nfn dfs(\n    v: usize,\n    p: usize,\n    a: &Vec<i64>,\n    graph: &Vec<Vec<usize>>,\n    min_dp: &mut Vec<Vec<i64>>,\n    power_dp: &mut Vec<Vec<i64>>,\n) {\n    min_dp[v].push(a[v]);\n    power_dp[v].push(if a[v] > 0 { a[v] } else { INF });\n    for &child in graph[v].iter() {\n        if p == child {\n            continue;\n        }\n        dfs(child, v, a, graph, min_dp, power_dp);\n        power_dp[v] = connect(&power_dp[v], &power_dp[child], &min_dp[child], true);\n        min_dp[v] = connect(&min_dp[v], &power_dp[child], &min_dp[child], false);\n    }\n}\n\nfn connect(dp: &Vec<i64>, power: &Vec<i64>, min: &Vec<i64>, is_power: bool) -> Vec<i64> {\n    let mut next = vec![INF; power.len() + dp.len() + 1];\n    for parent_cut in 0..dp.len() {\n        for child_cut in 0..power.len() {\n            let total_cut = parent_cut + child_cut;\n            if !is_power {\n                chmin(&mut next[total_cut], dp[parent_cut] + min[child_cut]);\n            }\n            if power[child_cut] < INF {\n                chmin(&mut next[total_cut], dp[parent_cut] + power[child_cut]);\n            }\n            if power[child_cut] < INF || min[child_cut] < 0 {\n                chmin(&mut next[total_cut + 1], dp[parent_cut]);\n            }\n        }\n    }\n    next\n}\n\nfn chmin<T: Ord>(a: &mut T, b: T) {\n    if *a > b {\n        *a = b;\n    }\n}\n\npub struct Scanner<R> {\n    stdin: R,\n}\n\nimpl<R: std::io::Read> Scanner<R> {\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .stdin\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n' || b == b'\\r')\n            .take_while(|&b| b != b' ' && b != b'\\n' && b != b'\\r')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::cmp;\n\nconst INF: i64 = 1e17 as i64;\n\nfn main() {\n    let s = std::io::stdin();\n    let mut sc = Scanner { stdin: s.lock() };\n\n    let n = sc.read();\n    let a: Vec<i64> = sc.vec(n);\n    let mut graph = vec![vec![]; n];\n    for _ in 1..n {\n        let u = sc.read::<usize>() - 1;\n        let v = sc.read::<usize>() - 1;\n        graph[v].push(u);\n        graph[u].push(v);\n    }\n\n    let mut dp = vec![vec![vec![INF; n]; n + 1]; n + 1];\n    let mut sub = vec![vec![INF; 2]; n];\n    let mut num = vec![0; n];\n    dfs(0, 0, &graph, &mut dp, &a, &mut num, &mut sub);\n\n    let mut ans = n - 1;\n    for i in 0..n {\n        if dp[0][i][0] < INF { ans = cmp::min(ans, i); }\n        if dp[0][i][1] < 0 { ans = cmp::min(ans, i); }\n    }\n    println!(\"{}\", ans);\n}\n\nfn dfs(i: usize,\n       p: usize,\n       graph: &Vec<Vec<usize>>,\n       dp: &mut Vec<Vec<Vec<i64>>>,\n       a: &Vec<i64>,\n       num: &mut Vec<usize>,\n       sub: &mut Vec<Vec<i64>>) {\n    for &j in graph[i].iter() {\n        if j != p {\n            dfs(j, i, graph, dp, a, num, sub);\n        }\n    }\n\n    let mut sum = 1;\n    dp[i][0][if a[i] < 0 { 1 } else { 0 }] = a[i];\n    for &j in graph[i].iter() {\n        if j == p { continue; }\n        for n1 in 0..sum {\n            for n2 in 0..num[j] {\n                for k1 in 0..2 {\n                    for k2 in 0..2 {\n                        sub[n1 + n2][k1 | k2] = cmp::min(sub[n1 + n2][k1 | k2], dp[i][n1][k1] + dp[j][n2][k2]);\n                        if (k2 == 0 && dp[j][n2][k2] < INF) || dp[j][n2][k2] < 0 {\n                            sub[n1 + n2 + 1][k1] = cmp::min(sub[n1 + n2 + 1][k1], dp[i][n1][k1]);\n                        }\n                    }\n                }\n            }\n        }\n\n        sum += num[j];\n        for n in 0..sum {\n            for k in 0..2 {\n                dp[i][n][k] = sub[n][k];\n                sub[n][k] = INF;\n            }\n        }\n    }\n    num[i] = sum;\n}\n\npub struct Scanner<R> {\n    stdin: R,\n}\n\nimpl<R: std::io::Read> Scanner<R> {\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .stdin\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n')\n            .take_while(|&b| b != b' ' && b != b'\\n')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_macros)]\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, bytes) => {\n        read_value!($next, String).into_bytes()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\nuse std::cmp::min;\n\nfn main() {\n    input! {\n        n: usize,\n        a: [i64; n],\n        es: [(usize1, usize1); n-1],\n    }\n\n    let mut g = vec![vec![]; n];\n    for &(u, v) in es.iter() {\n        g[u].push(v);\n        g[v].push(u);\n    }\n\n    let mut tbl = vec![vec![]; n + 1];\n    solve(0, None, &a, &g, &mut tbl);\n\n    let mut ans = INF;\n    for i in 0..n + 1 {\n        if tbl[0][i].0 != INF || tbl[0][i].1 < 0 {\n            ans = i as i64;\n            break;\n        }\n    }\n\n    println!(\"{}\", ans);\n}\n\nconst INF: i64 = 1_000_000_000_000_000;\n\nfn solve(\n    v: usize,\n    prev: Option<usize>,\n    a: &Vec<i64>,\n    g: &Vec<Vec<usize>>,\n    tbl: &mut Vec<Vec<(i64, i64)>>,\n) {\n    let mut ret = vec![if a[v] < 0 { (INF, a[v]) } else { (a[v], a[v]) }];\n\n    for &u in g[v].iter() {\n        if Some(u) == prev {\n            continue;\n        }\n\n        solve(u, Some(v), a, g, tbl);\n\n        let mut next = vec![(INF, INF); ret.len() + tbl[u].len() + 1];\n        for i in 0..ret.len() {\n            for j in 0..tbl[u].len() {\n                if tbl[u][j].0 != INF || tbl[u][j].1 < 0 {\n                    next[i + j + 1].0 = min(next[i + j + 1].0, ret[i].0);\n                    next[i + j + 1].1 = min(next[i + j + 1].1, ret[i].1);\n                }\n\n                if ret[i].0 != INF && tbl[u][j].0 != INF {\n                    next[i + j].0 = min(next[i + j].0, ret[i].0 + tbl[u][j].0);\n                }\n                if ret[i].1 != INF && tbl[u][j].1 != INF {\n                    next[i + j].1 = min(next[i + j].1, ret[i].1 + tbl[u][j].1);\n                }\n            }\n        }\n\n        ret = next;\n    }\n\n    tbl[v] = ret;\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, [ $t:tt ]) => {{\n        let len = read_value!($next, usize);\n        (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    }};\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\nconst INF: i64 = 1 << 50;\n\nfn dfs(v: usize, par: usize, g: &[Vec<usize>], a: &[i64],\n       dp: &mut [Vec<i64>], ep: &mut [Vec<i64>]) -> usize {\n    let n = g.len();\n    let mut sz = 1;\n    // init\n    if a[v] < 0 {\n        dp[v][0] = a[v];\n    } else {\n        ep[v][0] = a[v]; // power source only\n    }\n    for &w in g[v].iter() {\n        if par == w { continue; }\n        let mut dp2 = vec![INF; n + 1];\n        let mut ep2 = vec![INF; n + 1];\n        let sub = dfs(w, v, g, a, dp, ep);\n        for i in 0 .. sz + 1 {\n            if dp[v][i] > INF / 2 { continue; }\n            for j in 0 .. sub + 1 {\n                if dp[w][j] < INF / 2 {\n                    dp2[i + j] = min(dp2[i + j], dp[v][i] + dp[w][j]);\n                    if dp[w][j] < 0 {\n                        dp2[i + j + 1] = min(dp2[i + j + 1], dp[v][i]);\n                    }\n                }\n                if ep[w][j] < INF / 2 {\n                    dp2[i + j] = min(dp2[i + j], dp[v][i] + ep[w][j]);\n                        dp2[i + j + 1] = min(dp2[i + j + 1], dp[v][i]);\n                }\n            }\n        }\n        for i in 0 .. sz + 1 {\n            if ep[v][i] > INF / 2 { continue; }\n            for j in 0 .. sub + 1 {\n                if dp[w][j] < INF / 2 {\n                    dp2[i + j] = min(dp2[i + j], ep[v][i] + dp[w][j]);\n                    if dp[w][j] < 0 {\n                        ep2[i + j + 1] = min(ep2[i + j + 1], ep[v][i]);\n                    }\n                }\n                if ep[w][j] < INF / 2 {\n                    ep2[i + j] = min(ep2[i + j], ep[v][i] + ep[w][j]);\n                    ep2[i + j + 1] = min(ep2[i + j + 1], ep[v][i]);\n                }\n            }\n        }\n        dp[v] = dp2;\n        ep[v] = ep2;\n        sz += sub;\n    }\n    // eprintln!(\"v = {}, dp = {:?}, ep = {:?}\", v, dp[v], ep[v]);\n    sz\n}\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($($format:tt)*) => (write!(out,$($format)*).unwrap());\n    }\n    input! {\n        n: usize,\n        a: [i64; n],\n        xy: [(usize1, usize1); n - 1],\n    }\n    let mut g = vec![Vec::new(); n];\n    for (x, y) in xy {\n        g[x].push(y);\n        g[y].push(x);\n    }\n    let mut dp = vec![vec![INF; n + 1]; n];\n    let mut ep = vec![vec![INF; n + 1]; n];\n    dfs(0, n, &g, &a, &mut dp, &mut ep);\n    let mut mi = n;\n    for i in 0 .. n + 1 {\n        if dp[0][i] < 0 || ep[0][i] < INF / 2 {\n            mi = i;\n            break;\n        }\n    }\n    puts!(\"{}\\n\", mi);\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::cmp;\n\nconst INF: i64 = 1e17 as i64;\n\nfn main() {\n    let s = std::io::stdin();\n    let mut sc = Scanner { reader: s.lock() };\n    let n: usize = sc.read();\n    let a: Vec<i64> = sc.read_vec(n);\n    let mut graph = vec![vec![]; n];\n    for _ in 0..(n - 1) {\n        let v = sc.read::<usize>() - 1;\n        let u = sc.read::<usize>() - 1;\n        graph[v].push(u);\n        graph[u].push(v);\n    }\n\n    let mut dp1 = vec![vec![]; n];\n    let mut dp2 = vec![vec![]; n];\n    dfs(0, 0, &graph, &a, &mut dp1, &mut dp2);\n\n    for i in 1..(n + 1) {\n        if dp1[0][i] < INF {\n            println!(\"{}\", i - 1);\n            return;\n        }\n        if dp2[0][i] < 0 {\n            println!(\"{}\", i - 1);\n            return;\n        }\n    }\n}\n\nfn dfs(\n    v: usize,\n    p: usize,\n    graph: &Vec<Vec<usize>>,\n    a: &Vec<i64>,\n    dp1: &mut Vec<Vec<i64>>,\n    dp2: &mut Vec<Vec<i64>>,\n) {\n    dp1[v].push(INF);\n    dp1[v].push(if a[v] > 0 { a[v] } else { INF });\n    dp2[v].push(INF);\n    dp2[v].push(a[v]);\n    for &next in graph[v].iter() {\n        if next == p { continue; }\n        dfs(next, v, graph, a, dp1, dp2);\n\n        dp1[v] = connect(&dp1[v], &dp1[next], &dp2[next], true);\n        dp2[v] = connect(&dp2[v], &dp1[next], &dp2[next], false);\n    }\n}\n\nfn connect(dp: &Vec<i64>, child1: &Vec<i64>, child2: &Vec<i64>, power_only: bool) -> Vec<i64> {\n    let mut ans = vec![INF; dp.len() + child1.len() - 1];\n    assert_eq!(dp[0], INF);\n    assert_eq!(child1[0], INF);\n    assert_eq!(child2[0], INF);\n    for groups in 0..dp.len() {\n        if dp[groups] == INF { continue; }\n        for child_groups in 0..child1.len() {\n            let total_groups = groups + child_groups;\n\n            if total_groups >= 1 {\n                if child1[child_groups] != INF {\n                    ch_min(&mut ans[total_groups - 1], dp[groups] + child1[child_groups]);\n                }\n                if child2[child_groups] != INF && !power_only {\n                    ch_min(&mut ans[total_groups - 1], dp[groups] + child2[child_groups]);\n                }\n            }\n            if child1[child_groups] != INF || child2[child_groups] < 0 {\n                ch_min(&mut ans[total_groups], dp[groups]);\n            }\n        }\n    }\n    ans\n}\n\nfn ch_min<T: PartialOrd>(a: &mut T, b: T) {\n    if *a > b {\n        *a = b;\n    }\n}\n\npub struct Scanner<R> {\n    reader: R,\n}\n\nimpl<R: std::io::Read> Scanner<R> {\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .reader\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n')\n            .take_while(|&b| b != b' ' && b != b'\\n')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn read_vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::cmp;\n\nconst INF: i64 = 1e17 as i64;\n\nfn main() {\n    let s = std::io::stdin();\n    let mut sc = Scanner { reader: s.lock() };\n    let n: usize = sc.read();\n    let a: Vec<i64> = sc.read_vec(n);\n    let mut graph = vec![vec![]; n];\n    for _ in 0..(n - 1) {\n        let v = sc.read::<usize>() - 1;\n        let u = sc.read::<usize>() - 1;\n        graph[v].push(u);\n        graph[u].push(v);\n    }\n\n    let mut dp1 = vec![vec![]; n];\n    let mut dp2 = vec![vec![]; n];\n    dfs(0, 0, &graph, &a, &mut dp1, &mut dp2);\n\n    for groups in 1..(n + 1) {\n        if dp1[0][groups] < INF {\n            println!(\"{}\", groups - 1);\n            return;\n        }\n        if dp2[0][groups] < 0 {\n            println!(\"{}\", groups - 1);\n            return;\n        }\n    }\n}\n\nfn dfs(\n    v: usize,\n    p: usize,\n    graph: &Vec<Vec<usize>>,\n    a: &Vec<i64>,\n    dp1: &mut Vec<Vec<i64>>,\n    dp2: &mut Vec<Vec<i64>>,\n) {\n    dp1[v].push(INF);\n    dp1[v].push(if a[v] > 0 { a[v] } else { INF });\n    dp2[v].push(INF);\n    dp2[v].push(a[v]);\n    for &next in graph[v].iter() {\n        if next == p { continue; }\n        dfs(next, v, graph, a, dp1, dp2);\n\n        dp1[v] = connect(&dp1[v], &dp1[next], &dp2[next], true);\n        dp2[v] = connect(&dp2[v], &dp1[next], &dp2[next], false);\n    }\n}\n\nfn connect(dp: &Vec<i64>, child1: &Vec<i64>, child2: &Vec<i64>, power_only: bool) -> Vec<i64> {\n    assert_eq!(child1.len(), child2.len());\n    let mut ans = vec![INF; dp.len() + child1.len() - 1];\n    for groups in 0..dp.len() {\n        if dp[groups] == INF { continue; }\n        for child_groups in 0..child1.len() {\n            let child_power = child1[child_groups];\n            let child_group = child2[child_groups];\n\n            let group_num = groups + child_groups;\n\n            if group_num >= 1 {\n                if child_power != INF {\n                    ch_min(&mut ans[group_num - 1], dp[groups] + child_power);\n                }\n                if child_group != INF && !power_only {\n                    ch_min(&mut ans[group_num - 1], dp[groups] + child_group);\n                }\n            }\n            if child_power != INF || child_group < 0 {\n                ch_min(&mut ans[group_num], dp[groups]);\n            }\n        }\n    }\n    ans\n}\n\nfn ch_min<T: PartialOrd>(a: &mut T, b: T) {\n    if *a > b {\n        *a = b;\n    }\n}\n\npub struct Scanner<R> {\n    reader: R,\n}\n\nimpl<R: std::io::Read> Scanner<R> {\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .reader\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n')\n            .take_while(|&b| b != b' ' && b != b'\\n')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn read_vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::cmp;\n\nconst INF: i64 = 1e17 as i64;\n\nfn main() {\n    let s = std::io::stdin();\n    let mut sc = Scanner { reader: s.lock() };\n    let n: usize = sc.read();\n    let a: Vec<i64> = sc.read_vec(n);\n    let mut graph = vec![vec![]; n];\n    for _ in 0..(n - 1) {\n        let v = sc.read::<usize>() - 1;\n        let u = sc.read::<usize>() - 1;\n        graph[v].push(u);\n        graph[u].push(v);\n    }\n\n    let mut dp1 = vec![vec![]; n];\n    let mut dp2 = vec![vec![]; n];\n    dfs(0, 0, &graph, &a, &mut dp1, &mut dp2);\n\n    for i in 1..(n + 1) {\n        if dp1[0][i] < INF {\n            println!(\"{}\", i - 1);\n            return;\n        }\n        if dp2[0][i] < 0 {\n            println!(\"{}\", i - 1);\n            return;\n        }\n    }\n}\n\nfn dfs(\n    v: usize,\n    p: usize,\n    graph: &Vec<Vec<usize>>,\n    a: &Vec<i64>,\n    dp1: &mut Vec<Vec<i64>>,\n    dp2: &mut Vec<Vec<i64>>,\n) {\n    dp1[v].push(INF);\n    dp1[v].push(if a[v] > 0 { a[v] } else { INF });\n    dp2[v].push(INF);\n    dp2[v].push(a[v]);\n    for &next in graph[v].iter() {\n        if next == p { continue; }\n        dfs(next, v, graph, a, dp1, dp2);\n\n        dp1[v] = connect(&dp1[v], &dp1[next], &dp2[next], true);\n        dp2[v] = connect(&dp2[v], &dp1[next], &dp2[next], false);\n    }\n}\n\nfn connect(dp: &Vec<i64>, child1: &Vec<i64>, child2: &Vec<i64>, power_only: bool) -> Vec<i64> {\n    let mut ans = vec![INF; dp.len() + child1.len() - 1];\n    for groups in 0..dp.len() {\n        if dp[groups] == INF { continue; }\n        for child_groups in 0..child1.len() {\n            let total_groups = groups + child_groups;\n\n            if total_groups >= 1 {\n                if child1[child_groups] != INF {\n                    ch_min(&mut ans[total_groups - 1], dp[groups] + child1[child_groups]);\n                }\n                if child2[child_groups] != INF && !power_only {\n                    ch_min(&mut ans[total_groups - 1], dp[groups] + child2[child_groups]);\n                }\n            }\n            if child1[child_groups] != INF || child2[child_groups] < 0 {\n                ch_min(&mut ans[total_groups], dp[groups]);\n            }\n        }\n    }\n    ans\n}\n\nfn ch_min<T: PartialOrd>(a: &mut T, b: T) {\n    if *a > b {\n        *a = b;\n    }\n}\n\npub struct Scanner<R> {\n    reader: R,\n}\n\nimpl<R: std::io::Read> Scanner<R> {\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .reader\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n')\n            .take_while(|&b| b != b' ' && b != b'\\n')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn read_vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "const INF: i64 = 1 << 60;\n\nfn main() {\n    let (r, w) = (std::io::stdin(), std::io::stdout());\n    let mut sc = IO::new(r.lock(), w.lock());\n    let n: usize = sc.read();\n    let a: Vec<i64> = sc.vec(n);\n    let mut graph = vec![vec![]; n];\n    for _ in 1..n {\n        let u = sc.read::<usize>() - 1;\n        let v = sc.read::<usize>() - 1;\n        graph[u].push(v);\n        graph[v].push(u);\n    }\n\n    let (power, dp) = dfs(0, 0, &graph, &a);\n    // eprintln!(\"{:?}\", power);\n    // eprintln!(\"{:?}\", dp);\n\n    let mut ans = n - 1;\n    for i in 0..power.len() {\n        if power[i] < INF {\n            update_min(&mut ans, i);\n        }\n    }\n    for i in 0..dp.len() {\n        if dp[i] < 0 {\n            update_min(&mut ans, i);\n        }\n    }\n\n    println!(\"{}\", ans);\n}\n\nfn dfs(v: usize, p: usize, graph: &Vec<Vec<usize>>, a: &Vec<i64>) -> (Vec<i64>, Vec<i64>) {\n    let power = a[v];\n    let mut power_top = vec![];\n    if power > 0 {\n        power_top.push(power);\n    }\n    let mut dp = vec![power];\n    for &next in graph[v].iter().filter(|&&next| next != p) {\n        let (child_power, child_dp) = dfs(next, v, graph, a);\n\n        let mut next_dp = vec![INF; child_dp.len() + dp.len()];\n        let mut next_power = vec![INF; child_dp.len() + power_top.len()];\n\n        for child_dp_cut in 0..child_dp.len() {\n            for dp_cut in 0..dp.len() {\n                update_min(\n                    &mut next_dp[child_dp_cut + dp_cut],\n                    child_dp[child_dp_cut] + dp[dp_cut],\n                );\n                if child_dp[child_dp_cut] < 0 {\n                    update_min(&mut next_dp[child_dp_cut + dp_cut + 1], dp[dp_cut]);\n                }\n            }\n            for power_cut in 0..power_top.len() {\n                if child_dp[child_dp_cut] < 0 {\n                    update_min(\n                        &mut next_power[power_cut + child_dp_cut + 1],\n                        power_top[power_cut],\n                    );\n                }\n            }\n        }\n\n        for child_power_cut in 0..child_power.len() {\n            for dp_cut in 0..dp.len() {\n                update_min(\n                    &mut next_dp[child_power_cut + dp_cut],\n                    child_power[child_power_cut] + dp[dp_cut],\n                );\n\n                if child_power[child_power_cut] < INF {\n                    update_min(&mut next_dp[child_power_cut + dp_cut + 1], dp[dp_cut]);\n                }\n            }\n            for power_cut in 0..power_top.len() {\n                update_min(\n                    &mut next_power[power_cut + child_power_cut],\n                    child_power[child_power_cut] + power_top[power_cut],\n                );\n                if child_power[child_power_cut] < INF {\n                    update_min(\n                        &mut next_power[power_cut + child_power_cut + 1],\n                        power_top[power_cut],\n                    );\n                }\n            }\n        }\n\n        power_top = next_power;\n        dp = next_dp;\n    }\n\n    // eprintln!(\"v={} power={:?} dp={:?}\", v, power_top, dp);\n    (power_top, dp)\n}\n\nfn update_min<T: PartialOrd>(a: &mut T, b: T) {\n    if *a > b {\n        *a = b;\n    }\n}\n\npub struct IO<R, W: std::io::Write>(R, std::io::BufWriter<W>);\n\nimpl<R: std::io::Read, W: std::io::Write> IO<R, W> {\n    pub fn new(r: R, w: W) -> Self {\n        Self(r, std::io::BufWriter::new(w))\n    }\n    pub fn write<S: ToString>(&mut self, s: S) {\n        use std::io::Write;\n        self.1.write(s.to_string().as_bytes()).unwrap();\n    }\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .0\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n' || b == b'\\r' || b == b'\\t')\n            .take_while(|&b| b != b' ' && b != b'\\n' && b != b'\\r' && b != b'\\t')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::cmp;\nconst INF: i64 = 1e18 as i64;\n\nfn main() {\n    let s = std::io::stdin();\n    let mut sc = Scanner { stdin: s.lock() };\n    let n = sc.read();\n    let a: Vec<i64> = sc.vec(n);\n    let mut graph = vec![vec![]; n];\n    for _ in 1..n {\n        let u = sc.read::<usize>() - 1;\n        let v = sc.read::<usize>() - 1;\n        graph[u].push(v);\n        graph[v].push(u);\n    }\n\n    let mut dp1 = vec![vec![]; n];\n    let mut dp2 = vec![vec![]; n];\n    dp(0, 0, &mut dp1, &mut dp2, &a, &graph);\n\n    for i in 0..n {\n        if dp1[0][i] < INF || dp2[0][i] < 0 {\n            println!(\"{}\", i);\n            return;\n        }\n    }\n}\n\nfn dp(\n    v: usize,\n    p: usize,\n    dp1: &mut Vec<Vec<i64>>,\n    dp2: &mut Vec<Vec<i64>>,\n    a: &Vec<i64>,\n    graph: &Vec<Vec<usize>>,\n) {\n    dp1[v].push(if a[v] > 0 { a[v] } else { INF });\n    dp2[v].push(a[v]);\n    for &next in graph[v].iter() {\n        if next == p {\n            continue;\n        }\n        dp(next, v, dp1, dp2, a, graph);\n        dp1[v] = connect(&dp1[v], &dp1[next], &dp2[next], true);\n        dp2[v] = connect(&dp2[v], &dp1[next], &dp2[next], false);\n    }\n}\n\nfn connect(dp: &Vec<i64>, child1: &Vec<i64>, child2: &Vec<i64>, is_power: bool) -> Vec<i64> {\n    let mut next = vec![INF; dp.len() + child1.len() + 1];\n    for parent_cut in 0..dp.len() {\n        for child_cut in 0..child1.len() {\n            let total_cut = parent_cut + child_cut;\n\n            if child1[child_cut] < INF {\n                next[total_cut] = cmp::min(next[total_cut], dp[parent_cut] + child1[child_cut]);\n            }\n            if child2[child_cut] < INF && !is_power {\n                next[total_cut] = cmp::min(next[total_cut], dp[parent_cut] + child2[child_cut]);\n            }\n            if child1[child_cut] < INF || child2[child_cut] < 0 {\n                next[total_cut + 1] = cmp::min(next[total_cut + 1], dp[parent_cut]);\n            }\n        }\n    }\n    next\n}\n\npub struct Scanner<R> {\n    stdin: R,\n}\n\nimpl<R: std::io::Read> Scanner<R> {\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .stdin\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n')\n            .take_while(|&b| b != b' ' && b != b'\\n')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_macros)]\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, bytes) => {\n        read_value!($next, String).into_bytes()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\nmod inf {\n    #[derive(PartialEq, Eq, PartialOrd, Ord, Clone, Copy)]\n    pub enum Inf<T> {\n        NotInf(T),\n        Inf,\n    }\n\n    impl<T> From<T> for Inf<T> {\n        fn from(v: T) -> Self {\n            Inf::NotInf(v)\n        }\n    }\n\n    use std::ops::Add;\n\n    impl<T: Add<Output = T>> Add for Inf<T> {\n        type Output = Inf<T>;\n        fn add(self, rhs: Self) -> Self {\n            use self::Inf::*;\n            match (self, rhs) {\n                (NotInf(a), NotInf(b)) => NotInf(a + b),\n                _ => Inf,\n            }\n        }\n    }\n}\n\nuse inf::*;\nuse std::cmp::min;\n\nfn main() {\n    input! {\n        n: usize,\n        a: [i64; n],\n        es: [(usize1, usize1); n-1],\n    }\n\n    let mut g = vec![vec![]; n];\n    for &(u, v) in es.iter() {\n        g[u].push(v);\n        g[v].push(u);\n    }\n\n    let mut tbl = vec![vec![]; n + 1];\n    solve(0, None, &a, &g, &mut tbl);\n\n    let ans = tbl[0]\n        .iter()\n        .enumerate()\n        .find(|&(_, e)| e.0 != Inf::Inf || e.1 < 0.into())\n        .unwrap()\n        .0;\n\n    println!(\"{}\", ans);\n}\n\nfn solve(\n    v: usize,\n    prev: Option<usize>,\n    a: &Vec<i64>,\n    g: &Vec<Vec<usize>>,\n    tbl: &mut Vec<Vec<(Inf<i64>, Inf<i64>)>>,\n) {\n    use Inf::*;\n\n    let mut ret = vec![if a[v] < 0 {\n        (Inf, a[v].into())\n    } else {\n        (a[v].into(), a[v].into())\n    }];\n\n    for &u in g[v].iter() {\n        if Some(u) == prev {\n            continue;\n        }\n\n        solve(u, Some(v), a, g, tbl);\n\n        let mut next = vec![(Inf, Inf); ret.len() + tbl[u].len() + 1];\n        for i in 0..ret.len() {\n            for j in 0..tbl[u].len() {\n                if tbl[u][j].0 != Inf || tbl[u][j].1 < 0.into() {\n                    next[i + j + 1].0 = min(next[i + j + 1].0, ret[i].0);\n                    next[i + j + 1].1 = min(next[i + j + 1].1, ret[i].1);\n                }\n                next[i + j].0 = min(next[i + j].0, ret[i].0 + tbl[u][j].0);\n                next[i + j].1 = min(next[i + j].1, ret[i].1 + tbl[u][j].1);\n            }\n        }\n\n        ret = next;\n    }\n\n    tbl[v] = ret;\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::cmp;\n\nconst INF: i64 = 1e17 as i64;\n\nfn main() {\n    let s = std::io::stdin();\n    let mut sc = Scanner { reader: s.lock() };\n    let n: usize = sc.read();\n    let a: Vec<i64> = sc.read_vec(n);\n    let mut graph = vec![vec![]; n];\n    for _ in 0..(n - 1) {\n        let v = sc.read::<usize>() - 1;\n        let u = sc.read::<usize>() - 1;\n        graph[v].push(u);\n        graph[u].push(v);\n    }\n\n    let mut dp1 = vec![vec![]; n];\n    let mut dp2 = vec![vec![]; n];\n    dfs(0, 0, &graph, &a, &mut dp1, &mut dp2);\n\n    for i in 1..(n + 1) {\n        if dp1[0][i] < INF {\n            println!(\"{}\", i - 1);\n            return;\n        }\n        if dp2[0][i] < 0 {\n            println!(\"{}\", i - 1);\n            return;\n        }\n    }\n}\n\nfn dfs(\n    v: usize,\n    p: usize,\n    graph: &Vec<Vec<usize>>,\n    a: &Vec<i64>,\n    dp1: &mut Vec<Vec<i64>>,\n    dp2: &mut Vec<Vec<i64>>,\n) {\n    dp1[v].push(INF);\n    dp1[v].push(if a[v] > 0 { a[v] } else { INF });\n    dp2[v].push(INF);\n    dp2[v].push(a[v]);\n    for &next in graph[v].iter() {\n        if next == p { continue; }\n        dfs(next, v, graph, a, dp1, dp2);\n\n        dp1[v] = connect(&dp1[v], &dp1[next], &dp2[next], true);\n        dp2[v] = connect(&dp2[v], &dp1[next], &dp2[next], false);\n    }\n}\n\nfn connect(dp: &Vec<i64>, child1: &Vec<i64>, child2: &Vec<i64>, power_only: bool) -> Vec<i64> {\n    assert_eq!(child1.len(), child2.len());\n    let mut ans = vec![INF; dp.len() + child1.len() - 1];\n    for cut_num in 0..dp.len() {\n        if dp[cut_num] == INF { continue; }\n        for child_cut_num in 0..child1.len() {\n            let child_power = child1[child_cut_num];\n            let child_group = child2[child_cut_num];\n\n            let group_num = cut_num + child_cut_num;\n\n            if group_num >= 1 {\n                if child_power != INF {\n                    ch_min(&mut ans[group_num - 1], dp[cut_num] + child_power);\n                }\n                if child_group != INF && !power_only {\n                    ch_min(&mut ans[group_num - 1], dp[cut_num] + child_group);\n                }\n            }\n            if child_power != INF || child_group < 0 {\n                ch_min(&mut ans[group_num], dp[cut_num]);\n            }\n        }\n    }\n    ans\n}\n\nfn ch_min<T: PartialOrd>(a: &mut T, b: T) {\n    if *a > b {\n        *a = b;\n    }\n}\n\npub struct Scanner<R> {\n    reader: R,\n}\n\nimpl<R: std::io::Read> Scanner<R> {\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .reader\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n')\n            .take_while(|&b| b != b' ' && b != b'\\n')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn read_vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_macros)]\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, bytes) => {\n        read_value!($next, String).into_bytes()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\nmod inf {\n    #[derive(PartialEq, Eq, PartialOrd, Ord, Clone, Copy)]\n    pub enum Inf<T> {\n        NotInf(T),\n        Inf,\n    }\n\n    impl<T> From<T> for Inf<T> {\n        fn from(v: T) -> Self {\n            Inf::NotInf(v)\n        }\n    }\n\n    use std::ops::Add;\n\n    impl<T: Add<Output = T>> Add for Inf<T> {\n        type Output = Inf<T>;\n        fn add(self, rhs: Self) -> Self {\n            use self::Inf::*;\n            match (self, rhs) {\n                (NotInf(a), NotInf(b)) => NotInf(a + b),\n                _ => Inf,\n            }\n        }\n    }\n}\n\nuse inf::*;\nuse std::cmp::min;\n\nfn main() {\n    input! {\n        n: usize,\n        a: [i64; n],\n        es: [(usize1, usize1); n-1],\n    }\n\n    let mut g = vec![vec![]; n];\n    for &(u, v) in es.iter() {\n        g[u].push(v);\n        g[v].push(u);\n    }\n\n    let mut tbl = vec![vec![]; n + 1];\n    solve(0, None, &a, &g, &mut tbl);\n\n    let ans = tbl[0]\n        .iter()\n        .enumerate()\n        .find(|(_, e)| e.0 != Inf::Inf || e.1 < 0.into())\n        .unwrap()\n        .0;\n\n    println!(\"{}\", ans);\n}\n\nfn solve(\n    v: usize,\n    prev: Option<usize>,\n    a: &Vec<i64>,\n    g: &Vec<Vec<usize>>,\n    tbl: &mut Vec<Vec<(Inf<i64>, Inf<i64>)>>,\n) {\n    use Inf::*;\n\n    let mut ret = vec![if a[v] < 0 {\n        (Inf, a[v].into())\n    } else {\n        (a[v].into(), a[v].into())\n    }];\n\n    for &u in g[v].iter() {\n        if Some(u) == prev {\n            continue;\n        }\n\n        solve(u, Some(v), a, g, tbl);\n\n        let mut next = vec![(Inf, Inf); ret.len() + tbl[u].len() + 1];\n        for i in 0..ret.len() {\n            for j in 0..tbl[u].len() {\n                if tbl[u][j].0 != Inf || tbl[u][j].1 < 0.into() {\n                    next[i + j + 1].0 = min(next[i + j + 1].0, ret[i].0);\n                    next[i + j + 1].1 = min(next[i + j + 1].1, ret[i].1);\n                }\n                next[i + j].0 = min(next[i + j].0, ret[i].0 + tbl[u][j].0);\n                next[i + j].1 = min(next[i + j].1, ret[i].1 + tbl[u][j].1);\n            }\n        }\n\n        ret = next;\n    }\n\n    tbl[v] = ret;\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_macros)]\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, bytes) => {\n        read_value!($next, String).into_bytes()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\nmod inf {\n    use std::cmp::min;\n    use std::ops::Add;\n\n    #[derive(PartialEq, Eq, PartialOrd, Ord, Clone, Copy)]\n    pub enum Inf<T> {\n        NotInf(T),\n        Inf,\n    }\n\n    impl<T> From<T> for Inf<T> {\n        fn from(v: T) -> Self {\n            Inf::NotInf(v)\n        }\n    }\n\n    impl<T: Add<Output = T>> Add for Inf<T> {\n        type Output = Inf<T>;\n        fn add(self, rhs: Self) -> Self {\n            use self::Inf::*;\n            match (self, rhs) {\n                (NotInf(a), NotInf(b)) => NotInf(a + b),\n                _ => Inf,\n            }\n        }\n    }\n\n    impl<T: Clone + Ord> Inf<T> {\n        pub fn min_assign(&mut self, rhs: Self) {\n            *self = min(self.clone(), rhs);\n        }\n    }\n}\n\n// fn min_assign<T: Ord + Clone>(l: &mut T, r: T) {\n//     *l = std::cmp::min((*l).clone(), r);\n// }\n\nuse inf::*;\n\nfn main() {\n    input! {\n        n: usize,\n        a: [i64; n],\n        es: [(usize1, usize1); n-1],\n    }\n\n    let mut g = vec![vec![]; n];\n    for &(u, v) in es.iter() {\n        g[u].push(v);\n        g[v].push(u);\n    }\n\n    // let mut tbl = vec![vec![]; n + 1];\n    let ans = solve(0, None, &a, &g)\n        .iter()\n        .enumerate()\n        .find(|&(_, e)| e.0 != Inf::Inf || e.1 < 0.into())\n        .unwrap()\n        .0;\n\n    println!(\"{}\", ans);\n}\n\nfn solve(\n    v: usize,\n    prev: Option<usize>,\n    a: &Vec<i64>,\n    g: &Vec<Vec<usize>>,\n) -> Vec<(Inf<i64>, Inf<i64>)> {\n    use Inf::*;\n\n    let mut ret = vec![if a[v] < 0 {\n        (Inf, a[v].into())\n    } else {\n        (a[v].into(), a[v].into())\n    }];\n\n    for &u in g[v].iter() {\n        if Some(u) == prev {\n            continue;\n        }\n\n        let utbl = solve(u, Some(v), a, g);\n\n        let mut next = vec![(Inf, Inf); ret.len() + utbl.len() + 1];\n        for i in 0..ret.len() {\n            for j in 0..utbl.len() {\n                if utbl[j].0 != Inf || utbl[j].1 < 0.into() {\n                    next[i + j + 1].0.min_assign(ret[i].0);\n                    next[i + j + 1].1.min_assign(ret[i].1);\n                }\n                next[i + j].0.min_assign(ret[i].0 + utbl[j].0);\n                next[i + j].1.min_assign(ret[i].1 + utbl[j].1);\n            }\n        }\n\n        ret = next;\n    }\n\n    ret\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_macros)]\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, bytes) => {\n        read_value!($next, String).into_bytes()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\nmod inf {\n    use std::ops::Add;\n\n    #[derive(PartialEq, Eq, PartialOrd, Ord, Clone, Copy)]\n    pub enum Inf<T> {\n        NotInf(T),\n        Inf,\n    }\n\n    impl<T> From<T> for Inf<T> {\n        fn from(v: T) -> Self {\n            Inf::NotInf(v)\n        }\n    }\n\n    impl<T: Add<Output = T>> Add for Inf<T> {\n        type Output = Inf<T>;\n        fn add(self, rhs: Self) -> Self {\n            use self::Inf::*;\n            match (self, rhs) {\n                (NotInf(a), NotInf(b)) => NotInf(a + b),\n                _ => Inf,\n            }\n        }\n    }\n\n    impl<T: Clone + Ord> Inf<T> {\n        pub fn min_assign(&mut self, rhs: Self) {\n            *self = std::cmp::min(self.clone(), rhs);\n        }\n    }\n}\n\nfn min_assign<T: Ord + Clone>(l: &mut T, r: T) {\n    *l = std::cmp::min((*l).clone(), r);\n}\n\nuse inf::*;\n\nfn main() {\n    input! {\n        n: usize,\n        a: [i64; n],\n        es: [(usize1, usize1); n-1],\n    }\n\n    let mut g = vec![vec![]; n];\n    for &(u, v) in es.iter() {\n        g[u].push(v);\n        g[v].push(u);\n    }\n\n    // let mut tbl = vec![vec![]; n + 1];\n    let ans = solve(0, None, &a, &g)\n        .iter()\n        .enumerate()\n        .find(|&(_, e)| e.0 != Inf::Inf || e.1 < 0.into())\n        .unwrap()\n        .0;\n\n    println!(\"{}\", ans);\n}\n\nfn solve(\n    v: usize,\n    prev: Option<usize>,\n    a: &Vec<i64>,\n    g: &Vec<Vec<usize>>,\n) -> Vec<(Inf<i64>, Inf<i64>)> {\n    use Inf::*;\n\n    let mut ret = vec![if a[v] < 0 {\n        (Inf, a[v].into())\n    } else {\n        (a[v].into(), a[v].into())\n    }];\n\n    for &u in g[v].iter() {\n        if Some(u) == prev {\n            continue;\n        }\n\n        let utbl = solve(u, Some(v), a, g);\n\n        let mut next = vec![(Inf, Inf); ret.len() + utbl.len() + 1];\n        for i in 0..ret.len() {\n            for j in 0..utbl.len() {\n                if utbl[j].0 != Inf || utbl[j].1 < 0.into() {\n                    next[i + j + 1].0.min_assign(ret[i].0);\n                    next[i + j + 1].1.min_assign(ret[i].1);\n                }\n                next[i + j].0.min_assign(ret[i].0 + utbl[j].0);\n                next[i + j].1.min_assign(ret[i].1 + utbl[j].1);\n            }\n        }\n\n        ret = next;\n    }\n\n    ret\n}\n"
  },
  {
    "language": "Rust",
    "code": "macro_rules !read_value {($iter :expr ,($($t :tt ) ,*) ) =>{($(read_value !($iter ,$t ) ) ,*) } ;($iter :expr ,[$t :tt ;$len :expr ] ) =>{(0 ..$len ) .map (|_ |read_value !($iter ,$t ) ) .collect ::<Vec <_ >>() } ;($iter :expr ,{chars :$base :expr } ) =>{read_value !($iter ,String ) .chars () .map (|c |(c as u8 -$base as u8 ) as usize ) .collect ::<Vec <usize >>() } ;($iter :expr ,{char :$base :expr } ) =>{read_value !($iter ,{chars :$base } ) [0 ] } ;($iter :expr ,chars ) =>{read_value !($iter ,String ) .chars () .collect ::<Vec <char >>() } ;($iter :expr ,char ) =>{read_value !($iter ,chars ) [0 ] } ;($iter :expr ,usize1 ) =>{read_value !($iter ,usize ) -1 } ;($iter :expr ,$t :ty ) =>{$iter .next () .unwrap () .parse ::<$t >() .unwrap () } ;}\nmacro_rules !input_inner {($iter :expr ) =>{} ;($iter :expr ,) =>{} ;($iter :expr ,mut $var :ident :$t :tt $($r :tt ) *) =>{let mut $var =read_value !($iter ,$t ) ;input_inner !{$iter $($r ) *} } ;($iter :expr ,mut $var :ident $($r :tt ) *) =>{input_inner !{$iter ,mut $var :usize $($r ) *} } ;($iter :expr ,$var :ident :$t :tt $($r :tt ) *) =>{let $var =read_value !($iter ,$t ) ;input_inner !{$iter $($r ) *} } ;($iter :expr ,$var :ident $($r :tt ) *) =>{input_inner !{$iter ,$var :usize $($r ) *} } ;}\nmacro_rules !input {(source =$s :expr ,$($r :tt ) *) =>{let mut iter =$s .split_whitespace () ;input_inner !{iter ,$($r ) *} } ;(iter =$iter :ident ,$($r :tt ) *) =>{let s ={use std ::io ::Read ;let mut s =String ::new () ;std ::io ::stdin () .read_to_string (&mut s ) .unwrap () ;s } ;let mut $iter =s .split_whitespace () ;input_inner !{$iter ,$($r ) *} } ;($($r :tt ) *) =>{let s ={use std ::io ::Read ;let mut s =String ::new () ;std ::io ::stdin () .read_to_string (&mut s ) .unwrap () ;s } ;let mut iter =s .split_whitespace () ;input_inner !{iter ,$($r ) *} } ;}\npub trait Bisect: Copy {\n    fn halve(self, other: Self) -> Self;\n    fn section_end(self, other: Self) -> bool;\n}\nimpl Bisect for usize {\n    fn halve(self, other: Self) -> Self {\n        if self > other {\n            other + (self - other) / 2\n        } else {\n            self + (other - self) / 2\n        }\n    }\n    fn section_end(self, other: Self) -> bool {\n        (if self > other {\n            self - other\n        } else {\n            other - self\n        }) <= 1\n    }\n}\nimpl Bisect for i64 {\n    fn halve(self, other: Self) -> Self {\n        (self + other) / 2\n    }\n    fn section_end(self, other: Self) -> bool {\n        (self - other).abs() <= 1\n    }\n}\nimpl Bisect for f64 {\n    fn halve(self, other: Self) -> Self {\n        (self + other) / 2.\n    }\n    fn section_end(self, other: Self) -> bool {\n        (self - other).abs() <= 1e-8\n    }\n}\npub fn binary_search<T: Bisect, F: Fn(T) -> bool>(f: F, ok: T, err: T) -> T {\n    let mut ok = ok;\n    let mut err = err;\n    while !ok.section_end(err) {\n        let m = ok.halve(err);\n        if f(m) {\n            ok = m;\n        } else {\n            err = m;\n        }\n    }\n    ok\n}\npub fn lower_bound<T: Bisect + Ord>(v: &[T], x: T) -> usize {\n    binary_search(|i| v[i as usize] >= x, v.len() as i64, -1) as usize\n}\npub fn upper_bound<T: Bisect + Ord>(v: &[T], x: T) -> usize {\n    binary_search(|i| v[i as usize] > x, v.len() as i64, -1) as usize\n}\npub fn find_minus(v: &[i64]) -> usize {\n    binary_search(|i| v[i as usize] < 0, v.len() as i64, -1) as usize\n}\n#[derive(Clone, Copy, Debug, Default, PartialEq, Eq)]\npub struct Adjacent {\n    pub to: usize,\n    pub id: usize,\n}\nimpl Adjacent {\n    pub fn new(to: usize, id: usize) -> Adjacent {\n        Adjacent { to: to, id: id }\n    }\n}\n#[derive(Clone, Debug, Default)]\npub struct Graph {\n    pub vsize: usize,\n    pub esize: usize,\n    pub graph: Vec<Vec<Adjacent>>,\n}\nimpl Graph {\n    pub fn new(vsize: usize) -> Graph {\n        Graph {\n            vsize: vsize,\n            esize: 0,\n            graph: vec![vec![]; vsize],\n        }\n    }\n    pub fn add_edge(&mut self, from: usize, to: usize) {\n        self.graph[from].push(Adjacent::new(to, self.esize));\n        self.esize += 1;\n    }\n    pub fn add_undirected_edge(&mut self, u: usize, v: usize) {\n        self.graph[u].push(Adjacent::new(v, self.esize));\n        self.graph[v].push(Adjacent::new(u, self.esize));\n        self.esize += 1;\n    }\n    pub fn vertices(&self) -> std::ops::Range<usize> {\n        0..self.vsize\n    }\n    pub fn adjacency(&self, from: usize) -> &Vec<Adjacent> {\n        &self.graph[from]\n    }\n}\nimpl Graph {\n    fn size_dfs(&self, u: usize, p: usize, size: &mut Vec<u64>) {\n        size[u] = 1;\n        for a in self.adjacency(u) {\n            if a.to != p {\n                self.size_dfs(a.to, u, size);\n                size[u] += size[a.to];\n            }\n        }\n    }\n    pub fn tree_size(&self, root: usize) -> Vec<u64> {\n        let n = self.vsize;\n        let mut size = vec![0; n];\n        self.size_dfs(root, n, &mut size);\n        size\n    }\n}\n#[derive(Debug)]\npub struct TreeRec {\n    n: usize,\n    a: Vec<i64>,\n}\nimpl TreeRec {\n    pub fn new(n: usize, a: Vec<i64>) -> TreeRec {\n        TreeRec { n: n, a: a }\n    }\n    pub fn dfs(&mut self, u: usize, p: usize, graph: &Graph) -> (Vec<i64>, Option<usize>) {\n        let mut dp = vec![self.a[u]];\n        let mut z = 0;\n        for a in graph.adjacency(u) {\n            if a.to != p {\n                let (v, opt) = self.dfs(a.to, u, graph);\n                let mut ep = vec![std::i64::MAX; dp.len() + v.len()];\n                for i in 0..dp.len() {\n                    for j in 0..v.len() {\n                        if v[j] < 0 || opt.map(|x| x == j).unwrap_or(false) {\n                            ep[i + j + 1] = min(ep[i + j + 1], dp[i]);\n                        }\n                        ep[i + j] = min(ep[i + j], dp[i].saturating_add(v[j]));\n                    }\n                }\n                let mut y = find_minus(&v) + 1;\n                if let Some(x) = opt {\n                    y = min(y, x);\n                }\n                z += y;\n                dp = ep;\n            }\n        }\n        let opt = if self.a[u] > 0 { Some(z) } else { None };\n        (dp, opt)\n    }\n}\nuse std::cmp::min;\nfn main() {\n    input! { n, a:[i64;n], uv:[(usize1,usize1);n-1] };\n    let mut g = Graph::new(n);\n    for &(u, v) in &uv {\n        g.add_undirected_edge(u, v);\n    }\n    let mut r = TreeRec::new(n, a);\n    let (v, opt) = r.dfs(0, n, &g);\n    let mut ans = find_minus(&v);\n    if let Some(x) = opt {\n        ans = min(ans, x);\n    }\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::cmp;\n\nconst INF: i64 = 1e17 as i64;\n\nfn main() {\n    let s = std::io::stdin();\n    let mut sc = Scanner { reader: s.lock() };\n    let n: usize = sc.read();\n    let a: Vec<i64> = sc.read_vec(n);\n    let mut graph = vec![vec![]; n];\n    for _ in 0..(n - 1) {\n        let v = sc.read::<usize>() - 1;\n        let u = sc.read::<usize>() - 1;\n        graph[v].push(u);\n        graph[u].push(v);\n    }\n\n    let mut dp1 = vec![vec![]; n];\n    let mut dp2 = vec![vec![]; n];\n    dfs(0, 0, &graph, &a, &mut dp1, &mut dp2);\n\n    for i in 1..(n + 1) {\n        if dp1[0][i] < INF {\n            println!(\"{}\", i - 1);\n            return;\n        }\n        if dp2[0][i] < 0 {\n            println!(\"{}\", i - 1);\n            return;\n        }\n    }\n}\n\nfn dfs(\n    v: usize,\n    p: usize,\n    graph: &Vec<Vec<usize>>,\n    a: &Vec<i64>,\n    dp1: &mut Vec<Vec<i64>>,\n    dp2: &mut Vec<Vec<i64>>,\n) {\n    dp1[v].push(INF);\n    dp1[v].push(if a[v] > 0 { a[v] } else { INF });\n    dp2[v].push(INF);\n    dp2[v].push(a[v]);\n    for &next in graph[v].iter() {\n        if next == p { continue; }\n        dfs(next, v, graph, a, dp1, dp2);\n\n        dp1[v] = connect(&dp1[v], &dp1[next], &dp2[next], true);\n        dp2[v] = connect(&dp2[v], &dp1[next], &dp2[next], false);\n    }\n}\n\nfn connect(dp: &Vec<i64>, child1: &Vec<i64>, child2: &Vec<i64>, power_only: bool) -> Vec<i64> {\n    let mut ans = vec![INF; dp.len() + child1.len() - 1];\n    assert_eq!(dp[0], INF);\n    for groups in 0..dp.len() {\n        if dp[groups] == INF { continue; }\n        for child_groups in 0..child1.len() {\n            let total_groups = groups + child_groups;\n\n            if total_groups >= 1 {\n                if child1[child_groups] != INF {\n                    ch_min(&mut ans[total_groups - 1], dp[groups] + child1[child_groups]);\n                }\n                if child2[child_groups] != INF && !power_only {\n                    ch_min(&mut ans[total_groups - 1], dp[groups] + child2[child_groups]);\n                }\n            }\n            if child1[child_groups] != INF || child2[child_groups] < 0 {\n                ch_min(&mut ans[total_groups], dp[groups]);\n            }\n        }\n    }\n    ans\n}\n\nfn ch_min<T: PartialOrd>(a: &mut T, b: T) {\n    if *a > b {\n        *a = b;\n    }\n}\n\npub struct Scanner<R> {\n    reader: R,\n}\n\nimpl<R: std::io::Read> Scanner<R> {\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .reader\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n')\n            .take_while(|&b| b != b' ' && b != b'\\n')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn read_vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "const INF: i64 = 1 << 50;\nfn main() {\n    let s = std::io::stdin();\n    let mut sc = Scanner { stdin: s.lock() };\n\n    let n = sc.read();\n    let a: Vec<i64> = sc.vec(n);\n    let mut graph = vec![vec![]; n];\n    for _ in 1..n {\n        let u = sc.read::<usize>() - 1;\n        let v = sc.read::<usize>() - 1;\n        graph[v].push(u);\n        graph[u].push(v);\n    }\n\n    let mut min_dp = vec![vec![]; n];\n    let mut power_dp = vec![vec![]; n];\n    dfs(0, 0, &a, &graph, &mut min_dp, &mut power_dp);\n    for i in 0..n {\n        if min_dp[0][i] < 0 || power_dp[0][i] < INF {\n            println!(\"{}\", i);\n            return;\n        }\n    }\n}\n\nfn dfs(\n    v: usize,\n    p: usize,\n    a: &Vec<i64>,\n    graph: &Vec<Vec<usize>>,\n    min_dp: &mut Vec<Vec<i64>>,\n    power_dp: &mut Vec<Vec<i64>>,\n) {\n    min_dp[v].push(a[v]);\n    power_dp[v].push(if a[v] > 0 { a[v] } else { INF });\n    for &child in graph[v].iter() {\n        if p == child {\n            continue;\n        }\n        dfs(child, v, a, graph, min_dp, power_dp);\n        power_dp[v] = connect(&power_dp[v], &power_dp[child], &min_dp[child], true);\n        min_dp[v] = connect(&min_dp[v], &power_dp[child], &min_dp[child], false);\n    }\n}\n\nfn connect(dp: &Vec<i64>, power: &Vec<i64>, min: &Vec<i64>, is_power: bool) -> Vec<i64> {\n    let mut next = vec![INF; power.len() + dp.len() + 1];\n    for parent_cut in 0..dp.len() {\n        for child_cut in 0..power.len() {\n            let total_cut = parent_cut + child_cut;\n            if min[child_cut] < 0 && !is_power {\n                chmin(&mut next[total_cut], dp[parent_cut] + min[child_cut]);\n            }\n            if power[child_cut] < INF {\n                chmin(&mut next[total_cut], dp[parent_cut] + power[child_cut]);\n            }\n            if power[child_cut] < INF || min[child_cut] < 0 {\n                chmin(&mut next[total_cut + 1], dp[parent_cut]);\n            }\n        }\n    }\n    next\n}\n\nfn chmin<T: Ord>(a: &mut T, b: T) {\n    if *a > b {\n        *a = b;\n    }\n}\n\npub struct Scanner<R> {\n    stdin: R,\n}\n\nimpl<R: std::io::Read> Scanner<R> {\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .stdin\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n' || b == b'\\r')\n            .take_while(|&b| b != b' ' && b != b'\\n' && b != b'\\r')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::cmp;\n\nconst INF: i64 = 1e17 as i64;\n\nfn main() {\n    let s = std::io::stdin();\n    let mut sc = Scanner { reader: s.lock() };\n    let n: usize = sc.read();\n    let a: Vec<i64> = sc.read_vec(n);\n    let mut graph = vec![vec![]; n];\n    for _ in 0..(n - 1) {\n        let v = sc.read::<usize>() - 1;\n        let u = sc.read::<usize>() - 1;\n        graph[v].push(u);\n        graph[u].push(v);\n    }\n\n    let mut dp1 = vec![vec![]; n];\n    let mut dp2 = vec![vec![]; n];\n    dfs(0, 0, &graph, &a, &mut dp1, &mut dp2);\n\n    for i in 1..(n + 1) {\n        if dp1[0][i] < INF {\n            println!(\"{}\", i - 1);\n            return;\n        }\n        if dp2[0][i] < 0 {\n            println!(\"{}\", i - 1);\n            return;\n        }\n    }\n}\n\nfn dfs(\n    v: usize,\n    p: usize,\n    graph: &Vec<Vec<usize>>,\n    a: &Vec<i64>,\n    dp1: &mut Vec<Vec<i64>>,\n    dp2: &mut Vec<Vec<i64>>,\n) {\n    dp1[v].push(INF);\n    dp1[v].push(if a[v] > 0 { a[v] } else { INF });\n    dp2[v].push(INF);\n    dp2[v].push(a[v]);\n    for &next in graph[v].iter() {\n        if next == p { continue; }\n        dfs(next, v, graph, a, dp1, dp2);\n\n        dp1[v] = connect(&dp1[v], &dp1[next], &dp2[next], true);\n        dp2[v] = connect(&dp2[v], &dp1[next], &dp2[next], false);\n    }\n}\n\nfn connect(dp: &Vec<i64>, child1: &Vec<i64>, child2: &Vec<i64>, power_only: bool) -> Vec<i64> {\n    let mut ans = vec![INF; dp.len() + child1.len() - 1];\n    assert_eq!(dp[0], INF);\n    assert_eq!(child1[0], INF);\n    assert_eq!(child2[0], INF);\n    for groups in 1..dp.len() {\n        if dp[groups] == INF { continue; }\n        for child_groups in 0..child1.len() {\n            let total_groups = groups + child_groups;\n\n            if child1[child_groups] != INF {\n                ch_min(&mut ans[total_groups - 1], dp[groups] + child1[child_groups]);\n            }\n            if child2[child_groups] != INF && !power_only {\n                ch_min(&mut ans[total_groups - 1], dp[groups] + child2[child_groups]);\n            }\n            if child1[child_groups] != INF || child2[child_groups] < 0 {\n                ch_min(&mut ans[total_groups], dp[groups]);\n            }\n        }\n    }\n    ans\n}\n\nfn ch_min<T: PartialOrd>(a: &mut T, b: T) {\n    if *a > b {\n        *a = b;\n    }\n}\n\npub struct Scanner<R> {\n    reader: R,\n}\n\nimpl<R: std::io::Read> Scanner<R> {\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .reader\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n')\n            .take_while(|&b| b != b' ' && b != b'\\n')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn read_vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::cmp;\n\nconst INF: i64 = 1e17 as i64;\n\nfn main() {\n    let s = std::io::stdin();\n    let mut sc = Scanner { reader: s.lock() };\n    let n: usize = sc.read();\n    let a: Vec<i64> = sc.read_vec(n);\n    let mut graph = vec![vec![]; n];\n    for _ in 0..(n - 1) {\n        let v = sc.read::<usize>() - 1;\n        let u = sc.read::<usize>() - 1;\n        graph[v].push(u);\n        graph[u].push(v);\n    }\n\n    let mut dp1 = vec![vec![]; n];\n    let mut dp2 = vec![vec![]; n];\n    dfs(0, 0, &graph, &a, &mut dp1, &mut dp2);\n\n    for i in 1..(n + 1) {\n        if dp1[0][i] < INF {\n            println!(\"{}\", i - 1);\n            return;\n        }\n        if dp2[0][i] < 0 {\n            println!(\"{}\", i - 1);\n            return;\n        }\n    }\n}\n\nfn dfs(\n    v: usize,\n    p: usize,\n    graph: &Vec<Vec<usize>>,\n    a: &Vec<i64>,\n    dp1: &mut Vec<Vec<i64>>,\n    dp2: &mut Vec<Vec<i64>>,\n) {\n    dp1[v].push(INF);\n    dp1[v].push(if a[v] > 0 { a[v] } else { INF });\n    dp2[v].push(INF);\n    dp2[v].push(a[v]);\n    for &next in graph[v].iter() {\n        if next == p { continue; }\n        dfs(next, v, graph, a, dp1, dp2);\n\n        dp1[v] = connect(&dp1[v], &dp1[next], &dp2[next], true);\n        dp2[v] = connect(&dp2[v], &dp1[next], &dp2[next], false);\n    }\n}\n\nfn connect(dp: &Vec<i64>, child1: &Vec<i64>, child2: &Vec<i64>, flag: bool) -> Vec<i64> {\n    assert_eq!(child1.len(), child2.len());\n    let child_cuts = child1.len() - 1;\n    let mut ans = vec![INF; dp.len() + child_cuts];\n    for i in 0..dp.len() {\n        if dp[i] == INF { continue; }\n        for j in 0..child1.len() {\n            if i + j >= 1 {\n                if child1[j] != INF {\n//                    ans[i + j - 1] = cmp::min(ans[i + j - 1], dp[i] + child1[j]);\n                    ch_min(&mut ans[i + j - 1], dp[i] + child1[j]);\n                }\n                if child2[j] != INF && !flag {\n//                    ans[i + j - 1] = cmp::min(ans[i + j - 1], dp[i] + child2[j]);\n                    ch_min(&mut ans[i + j - 1], dp[i] + child2[j]);\n                }\n            }\n            if child1[j] != INF || child2[j] < 0 {\n                ans[i + j] = cmp::min(ans[i + j], dp[i]);\n            }\n        }\n    }\n    ans\n}\n\nfn ch_min<T: PartialOrd>(a: &mut T, b: T) {\n    if *a > b {\n        *a = b;\n    }\n}\n\npub struct Scanner<R> {\n    reader: R,\n}\n\nimpl<R: std::io::Read> Scanner<R> {\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .reader\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n')\n            .take_while(|&b| b != b' ' && b != b'\\n')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn read_vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::Read;\nuse std::cmp::min;\n\nfn run() {\n    let mut s = String::new();\n    std::io::stdin().read_to_string(&mut s).unwrap();\n    let mut it = s.trim().split_whitespace();\n    let n: usize = it.next().unwrap().parse().unwrap();\n    let a: Vec<i64> = (0..n).map(|_| it.next().unwrap().parse().unwrap()).collect();\n    let mut g = vec![vec![]; n];\n    for _ in 1..n {\n        let a = it.next().unwrap().parse::<usize>().unwrap() - 1;\n        let b = it.next().unwrap().parse::<usize>().unwrap() - 1;\n        g[a].push(b);\n        g[b].push(a);\n    }\n    let mut q = vec![];\n    let mut stack = vec![(0, 0)];\n    while let Some((v, p)) = stack.pop() {\n        q.push(v);\n        let g = &mut g[v];\n        for i in (0..g.len()).rev() {\n            if g[i] == p {\n                g.swap_remove(i);\n                break;\n            }\n        }\n        for &u in g.iter() {\n            stack.push((u, v));\n        }\n    }\n    let inf = 10_000_000_000_000i64;\n    let mut dp1 = vec![vec![]; n];\n    let mut dp2 = vec![vec![]; n];\n    for &v in q.iter().rev() {\n        dp1[v] = vec![a[v]];\n        dp2[v] = vec![a[v]];\n        if a[v] < 0 {\n            dp1[v][0] = inf;\n        }\n        for &u in &g[v] {\n            let mut next1 = vec![inf; dp1[v].len() + dp1[u].len()];\n            let mut next2 = vec![inf; dp2[v].len() + dp2[u].len()];\n            for i in 0..dp1[v].len() {\n                for j in 0..dp1[u].len() {\n                    next1[i + j] = min(next1[i + j], dp1[v][i] + dp1[u][j]);\n                    next2[i + j] = min(next2[i + j], dp1[v][i] + dp2[u][j]);\n                    next2[i + j] = min(next2[i + j], dp2[v][i] + dp1[u][j]);\n                    next2[i + j] = min(next2[i + j], dp2[v][i] + dp2[u][j]);\n                    if dp2[u][j] < 0 || dp1[u][j] < inf {\n                        next1[i + j + 1] = min(next1[i + j + 1], dp1[v][i]);\n                        next2[i + j + 1] = min(next2[i + j + 1], dp2[v][i]);\n                    }\n                }\n            }\n            dp1[v] = next1;\n            dp2[v] = next2;\n            dp1[u].clear();\n            dp1[u].shrink_to_fit();\n            dp2[u].clear();\n            dp2[u].shrink_to_fit();\n        }\n    }\n    for i in 0..n {\n        if dp1[0][i] < inf || dp2[0][i] < 0 {\n            println!(\"{}\", i);\n            return;\n        }\n    }\n}\n\nfn main() {\n    run();\n}\n"
  },
  {
    "language": "Rust",
    "code": "#![allow(unused_imports, non_snake_case)]\nuse std::cmp::{max, min, Ordering};\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n\n// {{{ input!\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n//}}}\n\n//{{{ read!\nmacro_rules! read {\n\t($($t:tt),*; $n:expr) => {{\n\t\tlet stdin = ::std::io::stdin();\n\t\tlet ret = ::std::io::BufRead::lines(stdin.lock()).take($n).map(|line| {\n\t\t\tlet line = line.unwrap();\n\t\t\tlet mut it = line.split_whitespace();\n\t\t\t_read!(it; $($t),*)\n\t\t}).collect::<Vec<_>>();\n\t\tret\n\t}};\n\t($($t:tt),*) => {{\n\t\tlet line = readln();\n\t\tlet mut it = line.split_whitespace();\n\t\t_read!(it; $($t),*)\n\t}};\n}\n\nmacro_rules! _read {\n\t($it:ident; [char]) => {\n\t\t_read!($it; String).chars().collect::<Vec<_>>()\n\t};\n\t($it:ident; [u8]) => {\n\t\tVec::from(_read!($it; String).into_bytes())\n\t};\n\t($it:ident; [$t:ty]) => {\n\t\t$it.map(|s| s.parse::<$t>().unwrap_or_else(|e| panic!(\"{}\", e))).collect::<Vec<_>>()\n\t};\n\t($it:ident; $t:ty) => {\n\t\t$it.next().unwrap_or_else(|| panic!(\"input mismatch\")).parse::<$t>().unwrap_or_else(|e| panic!(\"{}\", e))\n\t};\n\t($it:ident; $($t:ty),+) => {\n\t\t($(_read!($it; $t)),*)\n\t};\n}\n//}}}\n\n//{{{ utility macros missing in 1.15.1\n// https://atcoder.jp/contests/nikkei2019-qual/submissions/4098548\nmacro_rules! eprint {\n\t($($t:tt)*) => {{\n            use ::std::io::Write;\n            let _ = write!(::std::io::stderr(), $($t)*);\n\t}};\n}\nmacro_rules! eprintln {\n\t() => { eprintln!(\"\"); };\n\t($($t:tt)*) => {{\n\t    use ::std::io::Write;\n            let _ = writeln!(::std::io::stderr(), $($t)*);\n\t}};\n}\nmacro_rules! dbg {\n    ($val:expr) => {\n        match $val {\n            tmp => {\n                eprintln!(\n                    \"[{}:{}] {} = {:#?}\",\n                    file!(),\n                    line!(),\n                    stringify!($val),\n                    &tmp\n                );\n                tmp\n            }\n        }\n    };\n}\n//}}}\n\nstatic inf: isize = 1_000_000_000_000_000_000;\n\nfn run() {\n    input! {\n        n: usize,\n        a: [isize; n],\n        edges: [(usize1, usize1); n-1],\n    }\n    let mut g = vec![Vec::new(); n];\n    for (u, v) in edges {\n        g[u].push(v);\n        g[v].push(u);\n    }\n\n    let mut order = Vec::new();\n    let mut parent = vec![usize::max_value(); n];\n    order.push(0);\n    for i in 0..n {\n        let u = order[i];\n        for &v in &g[u] {\n            if parent[u] == v {\n                continue;\n            }\n            parent[v] = u;\n            order.push(v);\n        }\n    }\n\n    let mut dp1 = vec![vec![inf; 2 * n]; 2 * n];\n    let mut dp2 = vec![vec![inf; 2 * n]; 2 * n];\n    let mut next1 = vec![inf; 2 * n];\n    let mut next2 = vec![inf; 2 * n];\n    let mut size = vec![0; n];\n    for &u in order.iter().rev() {\n        size[u] = 1;\n        if a[u] > 0 {\n            dp1[u][0] = a[u];\n        }\n        dp2[u][0] = a[u];\n\n        for &v in &g[u] {\n            if v == parent[u] {\n                continue;\n            }\n            for j in 0..size[u] + size[v] {\n                next1[j] = inf;\n                next2[j] = inf;\n            }\n\n            for i in 0..size[u] {\n                let cur = dp1[u][i];\n                for j in 0..size[v] {\n                    if dp1[v][j] != inf {\n                        next1[i + j].set_min(cur + dp1[v][j]);\n                    }\n                    if dp1[v][j] != inf || dp2[v][j] < 0 {\n                        next1[i + j + 1].set_min(cur);\n                    }\n                }\n                let cur = dp2[u][i];\n                for j in 0..size[v] {\n                    if dp2[v][j] != inf {\n                        next2[i + j].set_min(cur + dp2[v][j]);\n                    }\n                    if dp1[v][j] != inf || dp2[v][j] < 0 {\n                        next2[i + j + 1].set_min(cur);\n                    }\n                }\n            }\n\n            for j in 0..size[u] + size[v] {\n                dp1[u][j] = next1[j];\n                dp2[u][j] = next2[j];\n            }\n            size[u] += size[v];\n        }\n    }\n    for k in 0..n {\n        if dp1[0][k] != inf || dp2[0][k] < 0 {\n            println!(\"{}\", k);\n            break;\n        }\n    }\n}\n\n//{{{ template\nfn main() {\n    let _ = ::std::thread::Builder::new()\n        .name(\"run\".to_string())\n        .stack_size(256 * 1024 * 1024)\n        .spawn(run)\n        .unwrap()\n        .join()\n        .unwrap();\n}\n\npub trait SetMinMax {\n    fn set_min(&mut self, v: Self) -> bool;\n    fn set_max(&mut self, v: Self) -> bool;\n}\n\nimpl<T> SetMinMax for T\nwhere\n    T: PartialOrd,\n{\n    fn set_min(&mut self, v: T) -> bool {\n        *self > v && {\n            *self = v;\n            true\n        }\n    }\n    fn set_max(&mut self, v: T) -> bool {\n        *self < v && {\n            *self = v;\n            true\n        }\n    }\n}\n\n#[derive(PartialEq, Eq, Debug, Copy, Clone, Default, Hash)]\npub struct Reverse<T>(pub T);\n\nimpl<T: PartialOrd> PartialOrd for Reverse<T> {\n    #[inline]\n    fn partial_cmp(&self, other: &Reverse<T>) -> Option<Ordering> {\n        other.0.partial_cmp(&self.0)\n    }\n\n    #[inline]\n    fn lt(&self, other: &Self) -> bool {\n        other.0 < self.0\n    }\n    #[inline]\n    fn le(&self, other: &Self) -> bool {\n        other.0 <= self.0\n    }\n    #[inline]\n    fn ge(&self, other: &Self) -> bool {\n        other.0 >= self.0\n    }\n    #[inline]\n    fn gt(&self, other: &Self) -> bool {\n        other.0 > self.0\n    }\n}\n\nimpl<T: Ord> Ord for Reverse<T> {\n    #[inline]\n    fn cmp(&self, other: &Reverse<T>) -> Ordering {\n        other.0.cmp(&self.0)\n    }\n}\n\n#[allow(unused)] // This is defined for read! macro\nfn readln() -> String {\n    let mut line = String::new();\n    ::std::io::stdin()\n        .read_line(&mut line)\n        .unwrap_or_else(|e| panic!(\"{}\", e));\n    line\n}\n//}}}\n\n//{{{ https://github.com/ichyo/rust-algorithms.git\npub mod algonium {\n    #![doc = \" This library provides a collection of classic algorithms,\"]\n    #![doc = \" focusing on programming contests such as codeforces and atcoder.\"]\n    pub mod data_structure {\n        mod bit {\n            #[doc = \" Binary Indexed Tree (0-indexed)\"]\n            #[doc = \"\"]\n            #[doc = \" This data structure supports these two queries in O(log n)\"]\n            #[doc = \"\"]\n            #[doc = \" 1. add w to v[at]\"]\n            #[doc = \" 2. the sum of v[begin], v[begin+1], .., v[end-1]\"]\n            pub struct BIT {\n                tree: Vec<i64>,\n            }\n            #[doc = \" Binary Indexed Tree (range-version) (0-indexed)\"]\n            #[doc = \"\"]\n            #[doc = \" This data structure two queries in O(log n)\"]\n            #[doc = \"\"]\n            #[doc = \" 1. add w to v[begin], v[begin+1], ..., v[end-1]\"]\n            #[doc = \" 2. get the sum of v[begin], v[begin+1], ..., v[end-1]\"]\n            pub struct BITRange {\n                bit0: BIT,\n                bit1: BIT,\n            }\n            impl BIT {\n                #[doc = \" Constructs a new BIT of length `len`.\"]\n                #[doc = \" All values are initialized zero.\"]\n                #[doc = \"\"]\n                #[doc = \" # Examples\"]\n                #[doc = \" ```\"]\n                #[doc = \" use algonium::data_structure::BIT;\"]\n                #[doc = \" # #[warn(unused_mut)]\"]\n                #[doc = \" let mut bit = BIT::new(100);\"]\n                #[doc = \" ```\"]\n                pub fn new(len: usize) -> BIT {\n                    BIT { tree: vec![0; len] }\n                }\n                #[doc = \" Returns the number of elements in the BIT.\"]\n                #[doc = \"\"]\n                #[doc = \" # Examples\"]\n                #[doc = \"\"]\n                #[doc = \" ```\"]\n                #[doc = \" use algonium::data_structure::BIT;\"]\n                #[doc = \" let mut bit = BIT::new(100);\"]\n                #[doc = \" assert_eq!(bit.len(), 100);\"]\n                #[doc = \" ```\"]\n                pub fn len(&self) -> usize {\n                    self.tree.len()\n                }\n                #[doc = \" Add a value `value` to a element of index `index`.\"]\n                #[doc = \" v[index] += value\"]\n                #[doc = \"\"]\n                #[doc = \" # Panics\"]\n                #[doc = \"\"]\n                #[doc = \" Panics if `index > len`\"]\n                #[doc = \"\"]\n                #[doc = \" # Examples\"]\n                #[doc = \"\"]\n                #[doc = \" ```\"]\n                #[doc = \" use algonium::data_structure::BIT;\"]\n                #[doc = \" let mut bit = BIT::new(10);\"]\n                #[doc = \" bit.add(5, 100);\"]\n                #[doc = \" assert_eq!(bit.get(3, 6), 100);\"]\n                #[doc = \" bit.add(5, 10);\"]\n                #[doc = \" assert_eq!(bit.get(3, 6), 110);\"]\n                #[doc = \" ```\"]\n                pub fn add(&mut self, index: usize, value: i64) {\n                    assert!(index < self.tree.len());\n                    let mut idx = index;\n                    while idx < self.tree.len() {\n                        self.tree[idx] += value;\n                        idx |= idx + 1;\n                    }\n                }\n                #[doc = \" sum of v[idx] such that begin <= idx < end\"]\n                pub fn get(&self, begin: usize, end: usize) -> i64 {\n                    if begin >= end {\n                        return 0;\n                    }\n                    let a = if end > 0 { self.cum(end - 1) } else { 0 };\n                    let b = if begin > 0 { self.cum(begin - 1) } else { 0 };\n                    a - b\n                }\n                #[doc = \" v[0] + ... + v[last]\"]\n                fn cum(&self, last: usize) -> i64 {\n                    assert!(last < self.tree.len());\n                    let mut res = 0;\n                    let mut idx = last as i64;\n                    while idx >= 0 {\n                        res += self.tree[idx as usize];\n                        idx = (idx & (idx + 1)) - 1;\n                    }\n                    res\n                }\n            }\n            impl BITRange {\n                pub fn new(n: usize) -> BITRange {\n                    BITRange {\n                        bit0: BIT::new(n + 1),\n                        bit1: BIT::new(n + 1),\n                    }\n                }\n                #[doc = \" v[begin], v[begin+1], ..., v[end-1] += by\"]\n                pub fn add(&mut self, begin: usize, end: usize, by: i64) {\n                    if begin >= end {\n                        return;\n                    }\n                    let a = begin as i64;\n                    let b = end as i64;\n                    self.bit0.add(begin, -by * a);\n                    self.bit0.add(end, by * b);\n                    self.bit1.add(begin, by);\n                    self.bit1.add(end, -by);\n                }\n                #[doc = \" v[begin] + ... + v[end-1]\"]\n                pub fn get(&self, begin: usize, end: usize) -> i64 {\n                    if begin >= end {\n                        return 0;\n                    }\n                    self.cum(end) - self.cum(begin)\n                }\n                #[doc = \" v[0] + ... + v[end-1]\"]\n                fn cum(&self, end: usize) -> i64 {\n                    let a = self.bit0.get(0, end);\n                    let b = self.bit1.get(0, end);\n                    a + b * end as i64\n                }\n            }\n            #[cfg(test)]\n            mod tests {\n                use super::*;\n                #[test]\n                #[should_panic]\n                fn test_out_of_bound_add() {\n                    let mut bit = BIT::new(10);\n                    bit.add(100, 1);\n                }\n                #[test]\n                #[should_panic]\n                fn test_out_of_bound_range_add() {\n                    let mut bit = BITRange::new(10);\n                    bit.add(5, 100, 1);\n                }\n                #[test]\n                #[should_panic]\n                fn test_out_of_bound_get() {\n                    let bit = BIT::new(10);\n                    bit.get(0, 1000);\n                }\n                #[test]\n                fn test_empty_range() {\n                    let mut bit = BITRange::new(10);\n                    bit.add(9, 0, 100);\n                    bit.add(7, 3, 100);\n                    assert_eq!(0, bit.get(0, 9));\n                    assert_eq!(0, bit.get(0, 5));\n                    assert_eq!(0, bit.get(2, 5));\n                }\n                #[test]\n                fn test_simple() {\n                    let mut bit = BIT::new(10);\n                    bit.add(2, 1);\n                    bit.add(3, 3);\n                    bit.add(5, 10);\n                    bit.add(0, -4);\n                    bit.add(9, -5);\n                    assert_eq!(5, bit.get(0, 10));\n                    assert_eq!(4, bit.get(2, 4));\n                    assert_eq!(1, bit.get(2, 3));\n                    assert_eq!(0, bit.get(2, 2));\n                    assert_eq!(0, bit.get(2, 0));\n                    assert_eq!(-4, bit.get(0, 1));\n                    assert_eq!(5, bit.get(5, 10));\n                    let mut bit = BITRange::new(10);\n                    bit.add(1, 3, 1);\n                    bit.add(2, 5, 2);\n                    assert_eq!(1, bit.get(1, 2));\n                    assert_eq!(4, bit.get(1, 3));\n                    assert_eq!(6, bit.get(1, 4));\n                    assert_eq!(6, bit.get(0, 4));\n                }\n            }\n        }\n        mod union_find {\n            #[doc = \" Disjoint-set data structure\"]\n            #[doc = \"\"]\n            #[doc = \" This provides operations for disjoint sets.\"]\n            #[doc = \" They runs in nearly constatant time.\"]\n            #[doc = \" (the actual time is `O(A(n))` where `A(n)` is the inverse of ackermann function.)\"]\n            #[doc = \"\"]\n            #[doc = \" 1. unite(x, y) - unite a set including x and another set including y into one.\"]\n            #[doc = \" 2. same(x, y) - determine if x and y are in the same set.\"]\n            #[doc = \" 3. size(x) - calculate the number of elements of the set including x.\"]\n            #[doc = \"\"]\n            #[doc = \" [`UnionFind::new(n)`](#method.new) creates n disjoint sets. `i`-th set contains single element `i` (0-indexed).\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::data_structure::UnionFind;\"]\n            #[doc = \"\"]\n            #[doc = \" let mut uf = UnionFind::new(4);\"]\n            #[doc = \" assert!(!uf.same(0, 1));\"]\n            #[doc = \"\"]\n            #[doc = \" uf.unite(0, 1);\"]\n            #[doc = \" assert!(uf.same(0, 1));\"]\n            #[doc = \" assert_eq!(uf.size(0), 2);\"]\n            #[doc = \"\"]\n            #[doc = \" uf.unite(1, 2);\"]\n            #[doc = \" assert!(uf.same(0, 2));\"]\n            #[doc = \" assert_eq!(uf.size(0), 3);\"]\n            #[doc = \" ```\"]\n            #[doc = \"\"]\n            #[doc = \" # Panics\"]\n            #[doc = \" panics if `x` or `y` is not less than number of elements given in the initialization method.\"]\n            #[doc = \"\"]\n            pub struct UnionFind {\n                data: Vec<i32>,\n            }\n            impl UnionFind {\n                #[doc = \" Creates a object with n disjoint sets. `i`-th set is `{ i }`.\"]\n                pub fn new(n: usize) -> UnionFind {\n                    UnionFind { data: vec![-1; n] }\n                }\n                #[doc = \" Unite a set including `x` and another set including y into one.\"]\n                #[doc = \" Returns `true` only if they were in different set.\"]\n                pub fn unite(&mut self, x: usize, y: usize) -> bool {\n                    let x = self.root(x);\n                    let y = self.root(y);\n                    if x != y {\n                        let (x, y) = if self.data[x] <= self.data[y] {\n                            (x, y)\n                        } else {\n                            (y, x)\n                        };\n                        self.data[x] += self.data[y];\n                        self.data[y] = x as i32;\n                    }\n                    x != y\n                }\n                #[doc = \" Returns `true` only if `x` and `y` are in a same set.\"]\n                pub fn same(&mut self, x: usize, y: usize) -> bool {\n                    self.root(x) == self.root(y)\n                }\n                #[doc = \" Returns the number of elements of a set including `x`.\"]\n                pub fn size(&mut self, x: usize) -> u32 {\n                    let r = self.root(x);\n                    (-self.data[r]) as u32\n                }\n                #[doc = \" internal method to return representative element of a set including `x`.\"]\n                pub fn root(&mut self, x: usize) -> usize {\n                    if self.data[x] < 0 {\n                        x\n                    } else {\n                        let nx = self.data[x] as usize;\n                        let r = self.root(nx);\n                        self.data[x] = r as i32;\n                        r\n                    }\n                }\n            }\n            #[cfg(test)]\n            mod tests {\n                use super::*;\n                #[test]\n                fn test_simple() {\n                    let mut uf = UnionFind::new(3);\n                    assert_eq!(1, uf.size(0));\n                    assert_eq!(1, uf.size(1));\n                    assert_eq!(1, uf.size(2));\n                    assert_eq!(0, uf.root(0));\n                    assert_eq!(1, uf.root(1));\n                    assert_eq!(2, uf.root(2));\n                    assert!(!uf.same(1, 2));\n                    uf.unite(1, 2);\n                    assert_ne!(uf.root(0), uf.root(2));\n                    assert_eq!(uf.root(1), uf.root(2));\n                    assert_eq!(1, uf.size(0));\n                    assert_eq!(2, uf.size(1));\n                    assert_eq!(2, uf.size(2));\n                    assert!(uf.same(1, 2));\n                    uf.unite(0, 1);\n                    assert_eq!(uf.root(0), uf.root(2));\n                    assert_eq!(uf.root(1), uf.root(2));\n                    assert_eq!(3, uf.size(0));\n                    assert_eq!(3, uf.size(1));\n                    assert_eq!(3, uf.size(2));\n                    assert!(uf.same(1, 2));\n                    assert!(uf.same(0, 2));\n                }\n            }\n        }\n        pub use self::bit::{BITRange, BIT};\n        pub use self::union_find::UnionFind;\n    }\n    pub mod math {\n        mod comb {\n            use super::mint::{Mint, Module};\n            #[doc = \" Useful struct to compute combinations\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::math::{Comb, Mod107, Mint107};\"]\n            #[doc = \" let comb: Comb<Mod107> = Comb::new(100);\"]\n            #[doc = \" assert_eq!(Mint107::from(24), comb.fact(4));\"]\n            #[doc = \" assert_eq!(Mint107::from(1), comb.fact(4) * comb.factinv(4));\"]\n            #[doc = \" assert_eq!(Mint107::from(12), comb.perm(4, 2));\"]\n            #[doc = \" assert_eq!(Mint107::from(6), comb.comb(4, 2));\"]\n            #[doc = \" assert_eq!(Mint107::from(10), comb.multi_comb(4, 2));\"]\n            #[doc = \" ```\"]\n            pub struct Comb<M: Module> {\n                fact: Vec<Mint<M>>,\n                factinv: Vec<Mint<M>>,\n            }\n            impl<M: Module> Comb<M> {\n                #[doc = \" Create a object that provides effiecint computation of combinations\"]\n                #[doc = \" for input smaller than `n`.\"]\n                #[doc = \"\"]\n                #[doc = \" This requires `O(n)` time.\"]\n                pub fn new(n: usize) -> Comb<M> {\n                    let mut fact: Vec<Mint<M>> = vec![0.into(); n + 1];\n                    let mut factinv: Vec<Mint<M>> = vec![0.into(); n + 1];\n                    fact[0] = 1.into();\n                    for i in 0..n {\n                        fact[i + 1] = fact[i] * (i + 1);\n                    }\n                    factinv[n] = fact[n].inv();\n                    for i in (0..n).rev() {\n                        factinv[i] = factinv[i + 1] * (i + 1);\n                    }\n                    Comb {\n                        fact: fact,\n                        factinv: factinv,\n                    }\n                }\n                #[doc = \" `n! = 1 * 2 * ... * n`\"]\n                #[doc = \"\"]\n                #[doc = \" `O(1)` if n is smaller than input in `new` method.\"]\n                pub fn fact(&self, n: u64) -> Mint<M> {\n                    if let Some(x) = self.fact.get(n as usize) {\n                        *x\n                    } else if n >= M::module() as u64 {\n                        Mint::from(0)\n                    } else {\n                        let mut res = 1.into();\n                        for a in 1..(n + 1) {\n                            res *= a;\n                        }\n                        res\n                    }\n                }\n                #[doc = \" returns `y` such that `n! * y == 1`.\"]\n                #[doc = \"\"]\n                #[doc = \" `O(1)` if n is smaller than input in `new` method.\"]\n                pub fn factinv(&self, n: u64) -> Mint<M> {\n                    if let Some(x) = self.factinv.get(n as usize) {\n                        *x\n                    } else {\n                        self.fact(n).inv()\n                    }\n                }\n                #[doc = \" `nPr = n! / (n - r)!`\"]\n                #[doc = \"\"]\n                #[doc = \" `O(1)` if n and r are smaller than input in `new` method.\"]\n                pub fn perm(&self, n: u64, r: u64) -> Mint<M> {\n                    if n >= r {\n                        self.fact(n) * self.factinv((n - r) as u64)\n                    } else {\n                        0.into()\n                    }\n                }\n                #[doc = \" `nCr = n! / (n - r)! / r!`.\"]\n                #[doc = \"\"]\n                #[doc = \" `O(1)` if n and r are smaller than input in `new` method.\"]\n                pub fn comb(&self, n: u64, r: u64) -> Mint<M> {\n                    let m = M::module() as u64;\n                    if n >= m {\n                        self.comb(n % m, r % m) * self.comb(n / m, r / m)\n                    } else if n >= r {\n                        self.fact(n) * self.factinv(n - r) * self.factinv(r)\n                    } else {\n                        Mint::from(0)\n                    }\n                }\n                #[doc = \" `(n + k - 1)! / k!`.\"]\n                #[doc = \"\"]\n                #[doc = \" `O(1)` if n and r are smaller than input in `new` method.\"]\n                pub fn multi_comb(&self, n: u64, r: u64) -> Mint<M> {\n                    if r == 0 {\n                        Mint::from(1)\n                    } else {\n                        self.comb(n + r - 1, r)\n                    }\n                }\n            }\n            #[cfg(test)]\n            mod tests {\n                use super::*;\n                #[test]\n                fn test_simple() {\n                    #[derive(Clone, Copy, Debug)]\n                    struct Mod;\n                    impl Module for Mod {\n                        fn module() -> u32 {\n                            1000000007\n                        }\n                    }\n                    let c = Comb::<Mod>::new(100);\n                    assert_eq!(Mint::from(336), c.perm(8, 3));\n                    assert_eq!(Mint::from(56), c.comb(8, 3));\n                    assert_eq!(Mint::from(10), c.multi_comb(3, 3));\n                }\n                #[test]\n                fn test_fact() {\n                    #[derive(Clone, Copy, Debug)]\n                    struct Mod;\n                    impl Module for Mod {\n                        fn module() -> u32 {\n                            1000000007\n                        }\n                    }\n                    let c = Comb::<Mod>::new(100);\n                    let p = 8721234;\n                    let mut f = Mint::from(1);\n                    for i in 1..(p + 1) {\n                        f *= i;\n                    }\n                    assert_eq!(f, c.fact(p));\n                }\n            }\n        }\n        mod mint {\n            use std::fmt;\n            use std::marker::PhantomData;\n            use std::mem;\n            use std::ops;\n            #[doc = \" Trait for `Mint`. `module()` should return prime number.\"]\n            pub trait Module: Copy + Clone {\n                fn module() -> u32;\n            }\n            #[doc = \" One of famous numbers in programming contest. `10^9 + 7`\"]\n            pub const MOD_107: u32 = 1_000_000_007;\n            #[doc = \" One of famous numbers in programming contest. `10^9 + 9`\"]\n            pub const MOD_109: u32 = 1_000_000_009;\n            #[doc = \" One of famous numbers in programming contest. `998_244_353`\"]\n            pub const MOD_998: u32 = 998_244_353;\n            #[doc = \" struct to implement Module trait. it returns `MOD_107`.\"]\n            #[derive(Debug, Copy, Clone)]\n            pub struct Mod107;\n            impl Module for Mod107 {\n                fn module() -> u32 {\n                    MOD_107\n                }\n            }\n            #[doc = \" struct to implement Module trait. it returns `MOD_109`.\"]\n            #[derive(Debug, Copy, Clone)]\n            pub struct Mod109;\n            impl Module for Mod109 {\n                fn module() -> u32 {\n                    MOD_109\n                }\n            }\n            #[doc = \" struct to implement Module trait. it returns `MOD_998`.\"]\n            #[derive(Debug, Copy, Clone)]\n            pub struct Mod998;\n            impl Module for Mod998 {\n                fn module() -> u32 {\n                    MOD_998\n                }\n            }\n            #[doc = \" Wrapper class to compute mod `1_000_000_007` automatically.\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::math::{Mint107, MOD_107};\"]\n            #[doc = \" let x: Mint107 = 1234567.into();\"]\n            #[doc = \" let y: Mint107 = 2345678.into();\"]\n            #[doc = \" let z = x * y;\"]\n            #[doc = \" # // TODO: implement convert to u64\"]\n            #[doc = \" assert_eq!(z.val as u64, 1234567u64 * 2345678u64 % MOD_107 as u64);\"]\n            #[doc = \" ```\"]\n            #[doc = \"\"]\n            pub type Mint107 = Mint<Mod107>;\n            #[doc = \" Wrapper class to compute mod `1_000_000_009` automatically.\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::math::{Mint109, MOD_109};\"]\n            #[doc = \" let x: Mint109 = 1234567.into();\"]\n            #[doc = \" let y: Mint109 = 2345678.into();\"]\n            #[doc = \" let z = x * y;\"]\n            #[doc = \" assert_eq!(z.val as u64, 1234567u64 * 2345678u64 % MOD_109 as u64);\"]\n            #[doc = \" ```\"]\n            #[doc = \"\"]\n            pub type Mint109 = Mint<Mod109>;\n            #[doc = \" Wrapper class to compute mod `998_244_353` automatically.\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::math::{Mint998, MOD_998};\"]\n            #[doc = \" let x: Mint998 = 1234567.into();\"]\n            #[doc = \" let y: Mint998 = 2345678.into();\"]\n            #[doc = \" let z = x * y;\"]\n            #[doc = \" assert_eq!(z.val as u64, 1234567u64 * 2345678u64 % MOD_998 as u64);\"]\n            #[doc = \" ```\"]\n            #[doc = \"\"]\n            pub type Mint998 = Mint<Mod998>;\n            #[doc = \" Wrapper class to compute modulo operation.\"]\n            #[doc = \" See examples\"]\n            #[doc = \" [`Mint107`](type.Mint107.html),\"]\n            #[doc = \" [`Mint109`](type.Mint109.html),\"]\n            #[doc = \" [`Mint998`](type.Mint998.html)\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::math::{Mint107, MOD_107};\"]\n            #[doc = \" let x: Mint107 = 1234567.into();\"]\n            #[doc = \" let y: Mint107 = 2345678.into();\"]\n            #[doc = \" let z = x * y;\"]\n            #[doc = \" assert_eq!(z.val as u64, 1234567u64 * 2345678u64 % MOD_107 as u64);\"]\n            #[doc = \" ```\"]\n            #[derive(Debug, Copy, Clone, Eq)]\n            pub struct Mint<M: Module> {\n                #[doc = \" internal value. this is always less than `self.module()`.\"]\n                pub val: u32,\n                m: PhantomData<M>,\n            }\n            impl<M: Module> Mint<M> {\n                fn module(self) -> u32 {\n                    M::module()\n                }\n                fn new(val: u32) -> Mint<M> {\n                    assert!(val < M::module());\n                    Mint {\n                        val: val,\n                        m: PhantomData,\n                    }\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::Add<T> for Mint<M> {\n                type Output = Mint<M>;\n                fn add(self, other: T) -> Mint<M> {\n                    let nval = self.val + other.into().val;\n                    Mint::new(if nval >= self.module() {\n                        nval - self.module()\n                    } else {\n                        nval\n                    })\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::Sub<T> for Mint<M> {\n                type Output = Mint<M>;\n                fn sub(self, other: T) -> Mint<M> {\n                    let nval = self.val + self.module() - other.into().val;\n                    Mint::new(if nval >= self.module() {\n                        nval - self.module()\n                    } else {\n                        nval\n                    })\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::Mul<T> for Mint<M> {\n                type Output = Mint<M>;\n                fn mul(self, other: T) -> Mint<M> {\n                    let nval = self.val as u64 * other.into().val as u64;\n                    Mint::new((nval % (self.module() as u64)) as u32)\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::Div<T> for Mint<M> {\n                type Output = Mint<M>;\n                fn div(self, other: T) -> Mint<M> {\n                    self * other.into().inv()\n                }\n            }\n            impl<M: Module> Mint<M> {\n                #[doc = \" Returns number `y` that satisfies `x * y == 1` where `x` is the original value.\"]\n                #[doc = \"\"]\n                #[doc = \" This assumes `module()` returns prime number.\"]\n                pub fn inv(self) -> Mint<M> {\n                    let mut a = self.val as i32;\n                    let mut b = self.module() as i32;\n                    let mut u = 1 as i32;\n                    let mut v = 0 as i32;\n                    while b != 0 {\n                        let t = a / b;\n                        a -= t * b;\n                        mem::swap(&mut a, &mut b);\n                        u -= t * v;\n                        mem::swap(&mut u, &mut v);\n                    }\n                    Mint::new(if u < 0 { u + self.module() as i32 } else { u } as u32)\n                }\n            }\n            impl<M: Module> PartialEq for Mint<M> {\n                fn eq(&self, other: &Mint<M>) -> bool {\n                    self.val == other.val\n                }\n            }\n            impl<M: Module> fmt::Display for Mint<M> {\n                fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n                    self.val.fmt(f)\n                }\n            }\n            macro_rules ! impl_signed_mint { ( $ ( $ t : ty ) * ) => ( $ ( impl < M : Module > From <$ t > for Mint < M > { # [ inline ] fn from ( x : $ t ) -> Mint < M > { let t = ( x as i64 ) % ( M :: module ( ) as i64 ) ; if x >= 0 { Mint { val : t as u32 , m : PhantomData } } else { Mint { val : ( M :: module ( ) as i64 + t ) as u32 , m : PhantomData } } } } ) * ) }\n            macro_rules ! impl_unsigned_mint { ( $ ( $ t : ty ) * ) => ( $ ( impl < M : Module > From <$ t > for Mint < M > { # [ inline ] fn from ( x : $ t ) -> Mint < M > { let t = x as u64 % M :: module ( ) as u64 ; Mint :: new ( t as u32 ) } } ) * ) }\n            impl_signed_mint! { i8 i16 i32 i64 isize }\n            impl_unsigned_mint! { u8 u16 u32 u64 usize }\n            impl<T: Into<Mint<M>>, M: Module> ops::AddAssign<T> for Mint<M> {\n                fn add_assign(&mut self, other: T) {\n                    *self = *self + other.into();\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::SubAssign<T> for Mint<M> {\n                fn sub_assign(&mut self, other: T) {\n                    *self = *self - other.into();\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::MulAssign<T> for Mint<M> {\n                fn mul_assign(&mut self, other: T) {\n                    *self = *self * other.into();\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::DivAssign<T> for Mint<M> {\n                fn div_assign(&mut self, other: T) {\n                    *self = *self / other.into();\n                }\n            }\n            #[cfg(test)]\n            mod tests {\n                use super::*;\n                #[test]\n                fn test_simple() {\n                    let a: Mint<Mod107> = Mint::from(3);\n                    let b: Mint<Mod107> = Mint::from(1000000000);\n                    assert_eq!(Mint::from(3000000000u64 % Mod107::module() as u64), a * b);\n                }\n            }\n        }\n        pub use self::comb::Comb;\n        pub use self::mint::{Mint, Module};\n        pub use self::mint::{Mint107, Mint109, Mint998};\n        pub use self::mint::{Mod107, Mod109, Mod998};\n        pub use self::mint::{MOD_107, MOD_109, MOD_998};\n    }\n    pub mod util {\n        mod permutation {\n            #[doc = \" It contains same methods as `std::next_permutaion` in C++.\"]\n            #[doc = \" these methods should rearrange the elements into the next/prev lexicographically greater permutation.\"]\n            #[doc = \"\"]\n            #[doc = \" This is implemented in [T] where T is Ord.\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::util::Permutation;\"]\n            #[doc = \"\"]\n            #[doc = \" let mut perm = [5, 0, 9, 2];\"]\n            #[doc = \" assert!(perm.next_permutation());\"]\n            #[doc = \" assert_eq!(perm, [5, 2, 0, 9]);\"]\n            #[doc = \" assert!(perm.next_permutation());\"]\n            #[doc = \" assert_eq!(perm, [5, 2, 9, 0]);\"]\n            #[doc = \" assert!(perm.prev_permutation());\"]\n            #[doc = \" assert_eq!(perm, [5, 2, 0, 9]);\"]\n            #[doc = \"\"]\n            #[doc = \" let mut perm = [4, 3, 2, 1, 0];\"]\n            #[doc = \" assert!(!perm.next_permutation());\"]\n            #[doc = \" assert_eq!(perm, [4, 3, 2, 1, 0]);\"]\n            #[doc = \" ```\"]\n            pub trait Permutation {\n                #[doc = \" It rearranges the elements into the next lexicographically greater permutation.\"]\n                #[doc = \"\"]\n                #[doc = \" Returns `false` without modifying any state only if current is the last permutation.\"]\n                fn next_permutation(&mut self) -> bool;\n                #[doc = \" It rearranges the elements into the previous lexicographically greater permutation.\"]\n                #[doc = \"\"]\n                #[doc = \" Returns `false` without modifying any state only if current is the first permutation.\"]\n                fn prev_permutation(&mut self) -> bool;\n            }\n            impl<T> Permutation for [T]\n            where\n                T: Ord,\n            {\n                fn next_permutation(&mut self) -> bool {\n                    if self.len() <= 1 {\n                        return false;\n                    }\n                    let mut i = self.len() - 1;\n                    while i > 0 && self[i - 1] >= self[i] {\n                        i -= 1;\n                    }\n                    if i == 0 {\n                        return false;\n                    }\n                    let mut j = self.len() - 1;\n                    while self[j] <= self[i - 1] {\n                        j -= 1;\n                    }\n                    self.swap(j, i - 1);\n                    self[i..].reverse();\n                    true\n                }\n                fn prev_permutation(&mut self) -> bool {\n                    if self.len() <= 1 {\n                        return false;\n                    }\n                    let mut i = self.len() - 1;\n                    while i > 0 && self[i - 1] <= self[i] {\n                        i -= 1;\n                    }\n                    if i == 0 {\n                        return false;\n                    }\n                    self[i..].reverse();\n                    let mut j = self.len() - 1;\n                    while self[j - 1] < self[i - 1] {\n                        j -= 1;\n                    }\n                    self.swap(i - 1, j);\n                    true\n                }\n            }\n            #[cfg(test)]\n            mod tests {\n                use super::*;\n                #[test]\n                fn test_simple() {\n                    let mut data = [0, 0, 1, 1, 2];\n                    data.next_permutation();\n                    assert_eq!(&data, &[0, 0, 1, 2, 1]);\n                    data.next_permutation();\n                    assert_eq!(&data, &[0, 0, 2, 1, 1]);\n                    data.next_permutation();\n                    assert_eq!(&data, &[0, 1, 0, 1, 2]);\n                    data.next_permutation();\n                    assert_eq!(&data, &[0, 1, 0, 2, 1]);\n                    data.next_permutation();\n                    assert_eq!(&data, &[0, 1, 1, 0, 2]);\n                    data.prev_permutation();\n                    assert_eq!(&data, &[0, 1, 0, 2, 1]);\n                    data.prev_permutation();\n                    assert_eq!(&data, &[0, 1, 0, 1, 2]);\n                    data.prev_permutation();\n                    assert_eq!(&data, &[0, 0, 2, 1, 1]);\n                    data.prev_permutation();\n                    assert_eq!(&data, &[0, 0, 1, 2, 1]);\n                    data.prev_permutation();\n                    assert_eq!(&data, &[0, 0, 1, 1, 2]);\n                    assert!(!data.prev_permutation());\n                }\n            }\n        }\n        mod random {\n            use std::num::Wrapping;\n            #[doc = \" Not secure but fast random generator.\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::util::XorShift;\"]\n            #[doc = \" let mut xorshift = XorShift::new();\"]\n            #[doc = \" assert_eq!(3701687786, xorshift.next_u32());\"]\n            #[doc = \" assert_eq!(458299110, xorshift.next_u32());\"]\n            #[doc = \" ```\"]\n            #[derive(Clone, Debug, Default)]\n            pub struct XorShift {\n                x: Wrapping<u32>,\n                y: Wrapping<u32>,\n                z: Wrapping<u32>,\n                w: Wrapping<u32>,\n            }\n            impl XorShift {\n                #[doc = \" Create object with default seed.\"]\n                pub fn new() -> XorShift {\n                    XorShift {\n                        x: Wrapping(123_456_789),\n                        y: Wrapping(362_436_069),\n                        z: Wrapping(521_288_629),\n                        w: Wrapping(88_675_123),\n                    }\n                }\n                #[doc = \" Get next random u32 number.\"]\n                pub fn next_u32(&mut self) -> u32 {\n                    let x = self.x;\n                    let t = x ^ (x << 11);\n                    self.x = self.y;\n                    self.y = self.z;\n                    self.z = self.w;\n                    let v = self.w;\n                    self.w = v ^ (v >> 19) ^ (t ^ (t >> 8));\n                    self.w.0\n                }\n            }\n            #[cfg(test)]\n            mod tests {\n                use super::XorShift;\n                #[test]\n                fn test_basic() {\n                    let mut xorshift = XorShift::new();\n                    assert_eq!(3701687786, xorshift.next_u32());\n                    assert_eq!(458299110, xorshift.next_u32());\n                }\n            }\n        }\n        pub use self::permutation::Permutation;\n        pub use self::random::XorShift;\n    }\n}\n\n//}}}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_macros)]\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, bytes) => {\n        read_value!($next, String).into_bytes()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n// fn min_assign<T: Ord + Clone>(l: &mut T, r: T) {\n//     *l = std::cmp::min((*l).clone(), r);\n// }\n\nmod inf {\n    use std::cmp::min;\n    use std::ops::Add;\n\n    #[derive(PartialEq, Eq, PartialOrd, Ord, Clone, Copy)]\n    pub enum Inf<T> {\n        NotInf(T),\n        Inf,\n    }\n\n    impl<T> From<T> for Inf<T> {\n        fn from(v: T) -> Self {\n            Inf::NotInf(v)\n        }\n    }\n\n    impl<T: Add<Output = T>> Add for Inf<T> {\n        type Output = Inf<T>;\n        fn add(self, rhs: Self) -> Self {\n            use self::Inf::*;\n            match (self, rhs) {\n                (NotInf(a), NotInf(b)) => NotInf(a + b),\n                _ => Inf,\n            }\n        }\n    }\n\n    impl<T: Clone + Ord> Inf<T> {\n        pub fn min_assign(&mut self, rhs: Self) {\n            *self = min(self.clone(), rhs);\n        }\n    }\n}\n\nuse inf::Inf;\nuse inf::Inf::*;\n\nfn main() {\n    input! {\n        n: usize,\n        a: [i64; n],\n        es: [(usize1, usize1); n-1],\n    }\n\n    let mut g = vec![vec![]; n];\n    for &(u, v) in es.iter() {\n        g[u].push(v);\n        g[v].push(u);\n    }\n\n    let ans = solve(0, None, &a, &g)\n        .iter()\n        .position(|e| e.0 != Inf || e.1 < 0.into())\n        .unwrap();\n\n    println!(\"{}\", ans);\n}\n\nfn solve(\n    v: usize,\n    prev: Option<usize>,\n    a: &Vec<i64>,\n    g: &Vec<Vec<usize>>,\n) -> Vec<(Inf<i64>, Inf<i64>)> {\n    let mut ret = vec![(if a[v] < 0 { Inf } else { a[v].into() }, a[v].into())];\n\n    for &u in g[v].iter().filter(|&&u| Some(u) != prev) {\n        let utbl = solve(u, Some(v), a, g);\n\n        let mut next = vec![(Inf, Inf); ret.len() + utbl.len()];\n        for i in 0..ret.len() {\n            for j in 0..utbl.len() {\n                if utbl[j].0 != Inf || utbl[j].1 < 0.into() {\n                    next[i + j + 1].0.min_assign(ret[i].0);\n                    next[i + j + 1].1.min_assign(ret[i].1);\n                }\n                next[i + j].0.min_assign(ret[i].0 + utbl[j].0);\n                next[i + j].1.min_assign(ret[i].1 + utbl[j].1);\n            }\n        }\n        ret = next;\n    }\n\n    ret\n}\n"
  },
  {
    "language": "Rust",
    "code": "macro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String {\n            bytes\n                .by_ref()\n                .map(|r| r.unwrap() as char)\n                .skip_while(|c| c.is_whitespace())\n                .take_while(|c| !c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n    ($next:expr, mut $var:ident : $t:tt $($r:tt)*) => {\n        let mut $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\nuse std::cmp::min;\n\nfn main() {\n    input!{\n        n: usize,\n        a: [i64; n],\n        uv: [[usize1; 2]; n - 1]\n    }\n    let mut tr: Vec<Vec<usize>> = vec![Vec::new(); n];\n    for e in uv {\n        tr[e[0]].push(e[1]);\n        tr[e[1]].push(e[0]);\n    }\n    let mut tab1: Vec<Vec<i64>> = vec![vec![i64::max_value(); n]; n];\n    let mut tab2: Vec<Vec<i64>> = vec![vec![i64::max_value(); n]; n];\n    dfs(&tr, &a, 0, 0, &mut tab1, &mut tab2);\n    for i in 0..n {\n        if tab1[0][i] < i64::max_value() || tab2[0][i] < 0 {\n            println!(\"{}\", i);\n            return;\n        }\n    }\n}\n\nfn dfs(t: &Vec<Vec<usize>>, a: &Vec<i64>, r: usize, p: usize, tab1: &mut Vec<Vec<i64>>, tab2: &mut Vec<Vec<i64>>) -> usize {\n    let n = t.len();\n    let mut nc = 1;\n    if a[r] > 0 {\n        tab1[r][0] = a[r];\n    }\n    tab2[r][0] = a[r];\n    for &c in t[r].iter() {\n        if c == p {\n            continue;\n        }\n        let mut tab3: Vec<i64> = vec![i64::max_value(); n];\n        let mut tab4: Vec<i64> = vec![i64::max_value(); n];\n        let ncs = dfs(t, a, c, r, tab1, tab2);\n        for i in 0..nc {\n            if tab1[r][i] == i64::max_value() {\n                continue;\n            }\n            for j in 0..ncs {\n                if tab1[c][j] < i64::max_value() {\n                    tab3[i + j] = min(tab3[i + j], tab1[r][i] + tab1[c][j]);\n                    tab3[i + j + 1] = min(tab3[i + j + 1], tab1[r][i]);\n                }\n                if tab2[c][j] < i64::max_value() {\n                    tab4[i + j] = min(tab4[i + j], tab1[r][i] + tab2[c][j]);\n                    if tab2[c][j] < 0 {\n                        tab3[i + j + 1] = min(tab3[i + j + 1], tab1[r][i]);\n                    }\n                }\n            }\n        }\n        for i in 0..nc {\n            if tab2[r][i] == i64::max_value() {\n                continue;\n            }\n            for j in 0..ncs {\n                if tab1[c][j] < i64::max_value() {\n                    tab4[i + j] = min(tab4[i + j], tab2[r][i] + tab1[c][j]);\n                    tab4[i + j + 1] = min(tab4[i + j + 1], tab2[r][i]);\n                }\n                if tab2[c][j] < i64::max_value() {\n                    tab4[i + j] = min(tab4[i + j], tab2[r][i] + tab2[c][j]);\n                    if tab2[c][j] < 0 {\n                        tab4[i + j + 1] = min(tab4[i + j + 1], tab2[r][i]);\n                    }\n                }\n            }\n        }\n        nc += ncs;\n        tab1[r] = tab3;\n        tab2[r] = tab4;\n    }\n    nc\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::cmp;\n\nconst INF: i64 = 1e17 as i64;\n\nfn main() {\n    let s = std::io::stdin();\n    let mut sc = Scanner { reader: s.lock() };\n    let n: usize = sc.read();\n    let a: Vec<i64> = sc.read_vec(n);\n    let mut graph = vec![vec![]; n];\n    for _ in 0..(n - 1) {\n        let v = sc.read::<usize>() - 1;\n        let u = sc.read::<usize>() - 1;\n        graph[v].push(u);\n        graph[u].push(v);\n    }\n\n    let mut dp1 = vec![vec![]; n];\n    let mut dp2 = vec![vec![]; n];\n    dfs(0, 0, &graph, &a, &mut dp1, &mut dp2);\n\n    for i in 1..(n + 1) {\n        if dp1[0][i] < INF {\n            println!(\"{}\", i - 1);\n            return;\n        }\n        if dp2[0][i] < 0 {\n            println!(\"{}\", i - 1);\n            return;\n        }\n    }\n}\n\nfn dfs(\n    v: usize,\n    p: usize,\n    graph: &Vec<Vec<usize>>,\n    a: &Vec<i64>,\n    dp1: &mut Vec<Vec<i64>>,\n    dp2: &mut Vec<Vec<i64>>,\n) {\n    dp1[v].push(INF);\n    dp1[v].push(if a[v] > 0 { a[v] } else { INF });\n    dp2[v].push(INF);\n    dp2[v].push(a[v]);\n    for &next in graph[v].iter() {\n        if next == p { continue; }\n        dfs(next, v, graph, a, dp1, dp2);\n\n        dp1[v] = connect(&dp1[v], &dp1[next], &dp2[next], true);\n        dp2[v] = connect(&dp2[v], &dp1[next], &dp2[next], false);\n    }\n}\n\nfn connect(dp: &Vec<i64>, child1: &Vec<i64>, child2: &Vec<i64>, power_only: bool) -> Vec<i64> {\n    assert_eq!(child1.len(), child2.len());\n    let mut ans = vec![INF; dp.len() + child1.len() - 1];\n    for groups in 0..dp.len() {\n        if dp[groups] == INF { continue; }\n        for child_groups in 0..child1.len() {\n            let child_power = child1[child_groups];\n            let child_group = child2[child_groups];\n\n            let total_groups = groups + child_groups;\n\n            if total_groups >= 1 {\n                if child_power != INF {\n                    ch_min(&mut ans[total_groups - 1], dp[groups] + child_power);\n                }\n                if child_group != INF && !power_only {\n                    ch_min(&mut ans[total_groups - 1], dp[groups] + child_group);\n                }\n            }\n            if child_power != INF || child_group < 0 {\n                ch_min(&mut ans[total_groups], dp[groups]);\n            }\n        }\n    }\n    ans\n}\n\nfn ch_min<T: PartialOrd>(a: &mut T, b: T) {\n    if *a > b {\n        *a = b;\n    }\n}\n\npub struct Scanner<R> {\n    reader: R,\n}\n\nimpl<R: std::io::Read> Scanner<R> {\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .reader\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n')\n            .take_while(|&b| b != b' ' && b != b'\\n')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn read_vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "#![allow(unused_imports, non_snake_case)]\nuse std::cmp::{max, min, Ordering};\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n\n// {{{ input!\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n//}}}\n\n//{{{ read!\nmacro_rules! read {\n\t($($t:tt),*; $n:expr) => {{\n\t\tlet stdin = ::std::io::stdin();\n\t\tlet ret = ::std::io::BufRead::lines(stdin.lock()).take($n).map(|line| {\n\t\t\tlet line = line.unwrap();\n\t\t\tlet mut it = line.split_whitespace();\n\t\t\t_read!(it; $($t),*)\n\t\t}).collect::<Vec<_>>();\n\t\tret\n\t}};\n\t($($t:tt),*) => {{\n\t\tlet line = readln();\n\t\tlet mut it = line.split_whitespace();\n\t\t_read!(it; $($t),*)\n\t}};\n}\n\nmacro_rules! _read {\n\t($it:ident; [char]) => {\n\t\t_read!($it; String).chars().collect::<Vec<_>>()\n\t};\n\t($it:ident; [u8]) => {\n\t\tVec::from(_read!($it; String).into_bytes())\n\t};\n\t($it:ident; [$t:ty]) => {\n\t\t$it.map(|s| s.parse::<$t>().unwrap_or_else(|e| panic!(\"{}\", e))).collect::<Vec<_>>()\n\t};\n\t($it:ident; $t:ty) => {\n\t\t$it.next().unwrap_or_else(|| panic!(\"input mismatch\")).parse::<$t>().unwrap_or_else(|e| panic!(\"{}\", e))\n\t};\n\t($it:ident; $($t:ty),+) => {\n\t\t($(_read!($it; $t)),*)\n\t};\n}\n//}}}\n\n//{{{ utility macros missing in 1.15.1\n// https://atcoder.jp/contests/nikkei2019-qual/submissions/4098548\nmacro_rules! eprint {\n\t($($t:tt)*) => {{\n            use ::std::io::Write;\n            let _ = write!(::std::io::stderr(), $($t)*);\n\t}};\n}\nmacro_rules! eprintln {\n\t() => { eprintln!(\"\"); };\n\t($($t:tt)*) => {{\n\t    use ::std::io::Write;\n            let _ = writeln!(::std::io::stderr(), $($t)*);\n\t}};\n}\nmacro_rules! dbg {\n    ($val:expr) => {\n        match $val {\n            tmp => {\n                eprintln!(\n                    \"[{}:{}] {} = {:#?}\",\n                    file!(),\n                    line!(),\n                    stringify!($val),\n                    &tmp\n                );\n                tmp\n            }\n        }\n    };\n}\n//}}}\n\nstatic inf: isize = 1_000_000_000_000_000_000;\n\nfn run() {\n    input! {\n        n: usize,\n        a: [isize; n],\n        edges: [(usize1, usize1); n-1],\n    }\n    let mut g = vec![Vec::new(); n];\n    for (u, v) in edges {\n        g[u].push(v);\n        g[v].push(u);\n    }\n\n    let mut order = Vec::new();\n    let mut parent = vec![usize::max_value(); n];\n    order.push(0);\n    for i in 0..n {\n        let u = order[i];\n        for &v in &g[u] {\n            if parent[u] == v {\n                continue;\n            }\n            parent[v] = u;\n            order.push(v);\n        }\n    }\n\n    let mut dp1 = vec![vec![inf; n]; n];\n    let mut dp2 = vec![vec![inf; n]; n];\n    let mut next1 = vec![inf; n];\n    let mut next2 = vec![inf; n];\n    let mut size = vec![0; n];\n    for &u in order.iter().rev() {\n        size[u] = 1;\n        if a[u] > 0 {\n            dp1[u][0] = a[u];\n        }\n        dp2[u][0] = a[u];\n\n        for &v in &g[u] {\n            if v == parent[u] {\n                continue;\n            }\n            for j in 0..size[u] + size[v] {\n                next1[j] = inf;\n                next2[j] = inf;\n            }\n\n            for i in 0..size[u] {\n                let cur = dp1[u][i];\n                for j in 0..size[v] {\n                    if dp1[v][j] != inf {\n                        next1[i + j].set_min(cur + dp1[v][j]);\n                    }\n                    if dp1[v][j] != inf || dp2[v][j] < 0 {\n                        next1[i + j + 1].set_min(cur);\n                    }\n                }\n                let cur = dp2[u][i];\n                for j in 0..size[v] {\n                    if dp2[v][j] != inf {\n                        next2[i + j].set_min(cur + dp2[v][j]);\n                    }\n                    if dp1[v][j] != inf || dp2[v][j] < 0 {\n                        next2[i + j + 1].set_min(cur);\n                    }\n                }\n            }\n\n            for j in 0..size[u] + size[v] {\n                dp1[u][j] = next1[j];\n                dp2[u][j] = next2[j];\n            }\n            size[u] += size[v];\n        }\n    }\n    for k in 0..n {\n        if dp1[0][k] != inf || dp2[0][k] < 0 {\n            println!(\"{}\", k);\n            break;\n        }\n    }\n}\n\n//{{{ template\nfn main() {\n    let _ = ::std::thread::Builder::new()\n        .name(\"run\".to_string())\n        .stack_size(256 * 1024 * 1024)\n        .spawn(run)\n        .unwrap()\n        .join()\n        .unwrap();\n}\n\npub trait SetMinMax {\n    fn set_min(&mut self, v: Self) -> bool;\n    fn set_max(&mut self, v: Self) -> bool;\n}\n\nimpl<T> SetMinMax for T\nwhere\n    T: PartialOrd,\n{\n    fn set_min(&mut self, v: T) -> bool {\n        *self > v && {\n            *self = v;\n            true\n        }\n    }\n    fn set_max(&mut self, v: T) -> bool {\n        *self < v && {\n            *self = v;\n            true\n        }\n    }\n}\n\n#[derive(PartialEq, Eq, Debug, Copy, Clone, Default, Hash)]\npub struct Reverse<T>(pub T);\n\nimpl<T: PartialOrd> PartialOrd for Reverse<T> {\n    #[inline]\n    fn partial_cmp(&self, other: &Reverse<T>) -> Option<Ordering> {\n        other.0.partial_cmp(&self.0)\n    }\n\n    #[inline]\n    fn lt(&self, other: &Self) -> bool {\n        other.0 < self.0\n    }\n    #[inline]\n    fn le(&self, other: &Self) -> bool {\n        other.0 <= self.0\n    }\n    #[inline]\n    fn ge(&self, other: &Self) -> bool {\n        other.0 >= self.0\n    }\n    #[inline]\n    fn gt(&self, other: &Self) -> bool {\n        other.0 > self.0\n    }\n}\n\nimpl<T: Ord> Ord for Reverse<T> {\n    #[inline]\n    fn cmp(&self, other: &Reverse<T>) -> Ordering {\n        other.0.cmp(&self.0)\n    }\n}\n\n#[allow(unused)] // This is defined for read! macro\nfn readln() -> String {\n    let mut line = String::new();\n    ::std::io::stdin()\n        .read_line(&mut line)\n        .unwrap_or_else(|e| panic!(\"{}\", e));\n    line\n}\n//}}}\n\n//{{{ https://github.com/ichyo/rust-algorithms.git\npub mod algonium {\n    #![doc = \" This library provides a collection of classic algorithms,\"]\n    #![doc = \" focusing on programming contests such as codeforces and atcoder.\"]\n    pub mod data_structure {\n        mod bit {\n            #[doc = \" Binary Indexed Tree (0-indexed)\"]\n            #[doc = \"\"]\n            #[doc = \" This data structure supports these two queries in O(log n)\"]\n            #[doc = \"\"]\n            #[doc = \" 1. add w to v[at]\"]\n            #[doc = \" 2. the sum of v[begin], v[begin+1], .., v[end-1]\"]\n            pub struct BIT {\n                tree: Vec<i64>,\n            }\n            #[doc = \" Binary Indexed Tree (range-version) (0-indexed)\"]\n            #[doc = \"\"]\n            #[doc = \" This data structure two queries in O(log n)\"]\n            #[doc = \"\"]\n            #[doc = \" 1. add w to v[begin], v[begin+1], ..., v[end-1]\"]\n            #[doc = \" 2. get the sum of v[begin], v[begin+1], ..., v[end-1]\"]\n            pub struct BITRange {\n                bit0: BIT,\n                bit1: BIT,\n            }\n            impl BIT {\n                #[doc = \" Constructs a new BIT of length `len`.\"]\n                #[doc = \" All values are initialized zero.\"]\n                #[doc = \"\"]\n                #[doc = \" # Examples\"]\n                #[doc = \" ```\"]\n                #[doc = \" use algonium::data_structure::BIT;\"]\n                #[doc = \" # #[warn(unused_mut)]\"]\n                #[doc = \" let mut bit = BIT::new(100);\"]\n                #[doc = \" ```\"]\n                pub fn new(len: usize) -> BIT {\n                    BIT { tree: vec![0; len] }\n                }\n                #[doc = \" Returns the number of elements in the BIT.\"]\n                #[doc = \"\"]\n                #[doc = \" # Examples\"]\n                #[doc = \"\"]\n                #[doc = \" ```\"]\n                #[doc = \" use algonium::data_structure::BIT;\"]\n                #[doc = \" let mut bit = BIT::new(100);\"]\n                #[doc = \" assert_eq!(bit.len(), 100);\"]\n                #[doc = \" ```\"]\n                pub fn len(&self) -> usize {\n                    self.tree.len()\n                }\n                #[doc = \" Add a value `value` to a element of index `index`.\"]\n                #[doc = \" v[index] += value\"]\n                #[doc = \"\"]\n                #[doc = \" # Panics\"]\n                #[doc = \"\"]\n                #[doc = \" Panics if `index > len`\"]\n                #[doc = \"\"]\n                #[doc = \" # Examples\"]\n                #[doc = \"\"]\n                #[doc = \" ```\"]\n                #[doc = \" use algonium::data_structure::BIT;\"]\n                #[doc = \" let mut bit = BIT::new(10);\"]\n                #[doc = \" bit.add(5, 100);\"]\n                #[doc = \" assert_eq!(bit.get(3, 6), 100);\"]\n                #[doc = \" bit.add(5, 10);\"]\n                #[doc = \" assert_eq!(bit.get(3, 6), 110);\"]\n                #[doc = \" ```\"]\n                pub fn add(&mut self, index: usize, value: i64) {\n                    assert!(index < self.tree.len());\n                    let mut idx = index;\n                    while idx < self.tree.len() {\n                        self.tree[idx] += value;\n                        idx |= idx + 1;\n                    }\n                }\n                #[doc = \" sum of v[idx] such that begin <= idx < end\"]\n                pub fn get(&self, begin: usize, end: usize) -> i64 {\n                    if begin >= end {\n                        return 0;\n                    }\n                    let a = if end > 0 { self.cum(end - 1) } else { 0 };\n                    let b = if begin > 0 { self.cum(begin - 1) } else { 0 };\n                    a - b\n                }\n                #[doc = \" v[0] + ... + v[last]\"]\n                fn cum(&self, last: usize) -> i64 {\n                    assert!(last < self.tree.len());\n                    let mut res = 0;\n                    let mut idx = last as i64;\n                    while idx >= 0 {\n                        res += self.tree[idx as usize];\n                        idx = (idx & (idx + 1)) - 1;\n                    }\n                    res\n                }\n            }\n            impl BITRange {\n                pub fn new(n: usize) -> BITRange {\n                    BITRange {\n                        bit0: BIT::new(n + 1),\n                        bit1: BIT::new(n + 1),\n                    }\n                }\n                #[doc = \" v[begin], v[begin+1], ..., v[end-1] += by\"]\n                pub fn add(&mut self, begin: usize, end: usize, by: i64) {\n                    if begin >= end {\n                        return;\n                    }\n                    let a = begin as i64;\n                    let b = end as i64;\n                    self.bit0.add(begin, -by * a);\n                    self.bit0.add(end, by * b);\n                    self.bit1.add(begin, by);\n                    self.bit1.add(end, -by);\n                }\n                #[doc = \" v[begin] + ... + v[end-1]\"]\n                pub fn get(&self, begin: usize, end: usize) -> i64 {\n                    if begin >= end {\n                        return 0;\n                    }\n                    self.cum(end) - self.cum(begin)\n                }\n                #[doc = \" v[0] + ... + v[end-1]\"]\n                fn cum(&self, end: usize) -> i64 {\n                    let a = self.bit0.get(0, end);\n                    let b = self.bit1.get(0, end);\n                    a + b * end as i64\n                }\n            }\n            #[cfg(test)]\n            mod tests {\n                use super::*;\n                #[test]\n                #[should_panic]\n                fn test_out_of_bound_add() {\n                    let mut bit = BIT::new(10);\n                    bit.add(100, 1);\n                }\n                #[test]\n                #[should_panic]\n                fn test_out_of_bound_range_add() {\n                    let mut bit = BITRange::new(10);\n                    bit.add(5, 100, 1);\n                }\n                #[test]\n                #[should_panic]\n                fn test_out_of_bound_get() {\n                    let bit = BIT::new(10);\n                    bit.get(0, 1000);\n                }\n                #[test]\n                fn test_empty_range() {\n                    let mut bit = BITRange::new(10);\n                    bit.add(9, 0, 100);\n                    bit.add(7, 3, 100);\n                    assert_eq!(0, bit.get(0, 9));\n                    assert_eq!(0, bit.get(0, 5));\n                    assert_eq!(0, bit.get(2, 5));\n                }\n                #[test]\n                fn test_simple() {\n                    let mut bit = BIT::new(10);\n                    bit.add(2, 1);\n                    bit.add(3, 3);\n                    bit.add(5, 10);\n                    bit.add(0, -4);\n                    bit.add(9, -5);\n                    assert_eq!(5, bit.get(0, 10));\n                    assert_eq!(4, bit.get(2, 4));\n                    assert_eq!(1, bit.get(2, 3));\n                    assert_eq!(0, bit.get(2, 2));\n                    assert_eq!(0, bit.get(2, 0));\n                    assert_eq!(-4, bit.get(0, 1));\n                    assert_eq!(5, bit.get(5, 10));\n                    let mut bit = BITRange::new(10);\n                    bit.add(1, 3, 1);\n                    bit.add(2, 5, 2);\n                    assert_eq!(1, bit.get(1, 2));\n                    assert_eq!(4, bit.get(1, 3));\n                    assert_eq!(6, bit.get(1, 4));\n                    assert_eq!(6, bit.get(0, 4));\n                }\n            }\n        }\n        mod union_find {\n            #[doc = \" Disjoint-set data structure\"]\n            #[doc = \"\"]\n            #[doc = \" This provides operations for disjoint sets.\"]\n            #[doc = \" They runs in nearly constatant time.\"]\n            #[doc = \" (the actual time is `O(A(n))` where `A(n)` is the inverse of ackermann function.)\"]\n            #[doc = \"\"]\n            #[doc = \" 1. unite(x, y) - unite a set including x and another set including y into one.\"]\n            #[doc = \" 2. same(x, y) - determine if x and y are in the same set.\"]\n            #[doc = \" 3. size(x) - calculate the number of elements of the set including x.\"]\n            #[doc = \"\"]\n            #[doc = \" [`UnionFind::new(n)`](#method.new) creates n disjoint sets. `i`-th set contains single element `i` (0-indexed).\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::data_structure::UnionFind;\"]\n            #[doc = \"\"]\n            #[doc = \" let mut uf = UnionFind::new(4);\"]\n            #[doc = \" assert!(!uf.same(0, 1));\"]\n            #[doc = \"\"]\n            #[doc = \" uf.unite(0, 1);\"]\n            #[doc = \" assert!(uf.same(0, 1));\"]\n            #[doc = \" assert_eq!(uf.size(0), 2);\"]\n            #[doc = \"\"]\n            #[doc = \" uf.unite(1, 2);\"]\n            #[doc = \" assert!(uf.same(0, 2));\"]\n            #[doc = \" assert_eq!(uf.size(0), 3);\"]\n            #[doc = \" ```\"]\n            #[doc = \"\"]\n            #[doc = \" # Panics\"]\n            #[doc = \" panics if `x` or `y` is not less than number of elements given in the initialization method.\"]\n            #[doc = \"\"]\n            pub struct UnionFind {\n                data: Vec<i32>,\n            }\n            impl UnionFind {\n                #[doc = \" Creates a object with n disjoint sets. `i`-th set is `{ i }`.\"]\n                pub fn new(n: usize) -> UnionFind {\n                    UnionFind { data: vec![-1; n] }\n                }\n                #[doc = \" Unite a set including `x` and another set including y into one.\"]\n                #[doc = \" Returns `true` only if they were in different set.\"]\n                pub fn unite(&mut self, x: usize, y: usize) -> bool {\n                    let x = self.root(x);\n                    let y = self.root(y);\n                    if x != y {\n                        let (x, y) = if self.data[x] <= self.data[y] {\n                            (x, y)\n                        } else {\n                            (y, x)\n                        };\n                        self.data[x] += self.data[y];\n                        self.data[y] = x as i32;\n                    }\n                    x != y\n                }\n                #[doc = \" Returns `true` only if `x` and `y` are in a same set.\"]\n                pub fn same(&mut self, x: usize, y: usize) -> bool {\n                    self.root(x) == self.root(y)\n                }\n                #[doc = \" Returns the number of elements of a set including `x`.\"]\n                pub fn size(&mut self, x: usize) -> u32 {\n                    let r = self.root(x);\n                    (-self.data[r]) as u32\n                }\n                #[doc = \" internal method to return representative element of a set including `x`.\"]\n                pub fn root(&mut self, x: usize) -> usize {\n                    if self.data[x] < 0 {\n                        x\n                    } else {\n                        let nx = self.data[x] as usize;\n                        let r = self.root(nx);\n                        self.data[x] = r as i32;\n                        r\n                    }\n                }\n            }\n            #[cfg(test)]\n            mod tests {\n                use super::*;\n                #[test]\n                fn test_simple() {\n                    let mut uf = UnionFind::new(3);\n                    assert_eq!(1, uf.size(0));\n                    assert_eq!(1, uf.size(1));\n                    assert_eq!(1, uf.size(2));\n                    assert_eq!(0, uf.root(0));\n                    assert_eq!(1, uf.root(1));\n                    assert_eq!(2, uf.root(2));\n                    assert!(!uf.same(1, 2));\n                    uf.unite(1, 2);\n                    assert_ne!(uf.root(0), uf.root(2));\n                    assert_eq!(uf.root(1), uf.root(2));\n                    assert_eq!(1, uf.size(0));\n                    assert_eq!(2, uf.size(1));\n                    assert_eq!(2, uf.size(2));\n                    assert!(uf.same(1, 2));\n                    uf.unite(0, 1);\n                    assert_eq!(uf.root(0), uf.root(2));\n                    assert_eq!(uf.root(1), uf.root(2));\n                    assert_eq!(3, uf.size(0));\n                    assert_eq!(3, uf.size(1));\n                    assert_eq!(3, uf.size(2));\n                    assert!(uf.same(1, 2));\n                    assert!(uf.same(0, 2));\n                }\n            }\n        }\n        pub use self::bit::{BITRange, BIT};\n        pub use self::union_find::UnionFind;\n    }\n    pub mod math {\n        mod comb {\n            use super::mint::{Mint, Module};\n            #[doc = \" Useful struct to compute combinations\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::math::{Comb, Mod107, Mint107};\"]\n            #[doc = \" let comb: Comb<Mod107> = Comb::new(100);\"]\n            #[doc = \" assert_eq!(Mint107::from(24), comb.fact(4));\"]\n            #[doc = \" assert_eq!(Mint107::from(1), comb.fact(4) * comb.factinv(4));\"]\n            #[doc = \" assert_eq!(Mint107::from(12), comb.perm(4, 2));\"]\n            #[doc = \" assert_eq!(Mint107::from(6), comb.comb(4, 2));\"]\n            #[doc = \" assert_eq!(Mint107::from(10), comb.multi_comb(4, 2));\"]\n            #[doc = \" ```\"]\n            pub struct Comb<M: Module> {\n                fact: Vec<Mint<M>>,\n                factinv: Vec<Mint<M>>,\n            }\n            impl<M: Module> Comb<M> {\n                #[doc = \" Create a object that provides effiecint computation of combinations\"]\n                #[doc = \" for input smaller than `n`.\"]\n                #[doc = \"\"]\n                #[doc = \" This requires `O(n)` time.\"]\n                pub fn new(n: usize) -> Comb<M> {\n                    let mut fact: Vec<Mint<M>> = vec![0.into(); n + 1];\n                    let mut factinv: Vec<Mint<M>> = vec![0.into(); n + 1];\n                    fact[0] = 1.into();\n                    for i in 0..n {\n                        fact[i + 1] = fact[i] * (i + 1);\n                    }\n                    factinv[n] = fact[n].inv();\n                    for i in (0..n).rev() {\n                        factinv[i] = factinv[i + 1] * (i + 1);\n                    }\n                    Comb {\n                        fact: fact,\n                        factinv: factinv,\n                    }\n                }\n                #[doc = \" `n! = 1 * 2 * ... * n`\"]\n                #[doc = \"\"]\n                #[doc = \" `O(1)` if n is smaller than input in `new` method.\"]\n                pub fn fact(&self, n: u64) -> Mint<M> {\n                    if let Some(x) = self.fact.get(n as usize) {\n                        *x\n                    } else if n >= M::module() as u64 {\n                        Mint::from(0)\n                    } else {\n                        let mut res = 1.into();\n                        for a in 1..(n + 1) {\n                            res *= a;\n                        }\n                        res\n                    }\n                }\n                #[doc = \" returns `y` such that `n! * y == 1`.\"]\n                #[doc = \"\"]\n                #[doc = \" `O(1)` if n is smaller than input in `new` method.\"]\n                pub fn factinv(&self, n: u64) -> Mint<M> {\n                    if let Some(x) = self.factinv.get(n as usize) {\n                        *x\n                    } else {\n                        self.fact(n).inv()\n                    }\n                }\n                #[doc = \" `nPr = n! / (n - r)!`\"]\n                #[doc = \"\"]\n                #[doc = \" `O(1)` if n and r are smaller than input in `new` method.\"]\n                pub fn perm(&self, n: u64, r: u64) -> Mint<M> {\n                    if n >= r {\n                        self.fact(n) * self.factinv((n - r) as u64)\n                    } else {\n                        0.into()\n                    }\n                }\n                #[doc = \" `nCr = n! / (n - r)! / r!`.\"]\n                #[doc = \"\"]\n                #[doc = \" `O(1)` if n and r are smaller than input in `new` method.\"]\n                pub fn comb(&self, n: u64, r: u64) -> Mint<M> {\n                    let m = M::module() as u64;\n                    if n >= m {\n                        self.comb(n % m, r % m) * self.comb(n / m, r / m)\n                    } else if n >= r {\n                        self.fact(n) * self.factinv(n - r) * self.factinv(r)\n                    } else {\n                        Mint::from(0)\n                    }\n                }\n                #[doc = \" `(n + k - 1)! / k!`.\"]\n                #[doc = \"\"]\n                #[doc = \" `O(1)` if n and r are smaller than input in `new` method.\"]\n                pub fn multi_comb(&self, n: u64, r: u64) -> Mint<M> {\n                    if r == 0 {\n                        Mint::from(1)\n                    } else {\n                        self.comb(n + r - 1, r)\n                    }\n                }\n            }\n            #[cfg(test)]\n            mod tests {\n                use super::*;\n                #[test]\n                fn test_simple() {\n                    #[derive(Clone, Copy, Debug)]\n                    struct Mod;\n                    impl Module for Mod {\n                        fn module() -> u32 {\n                            1000000007\n                        }\n                    }\n                    let c = Comb::<Mod>::new(100);\n                    assert_eq!(Mint::from(336), c.perm(8, 3));\n                    assert_eq!(Mint::from(56), c.comb(8, 3));\n                    assert_eq!(Mint::from(10), c.multi_comb(3, 3));\n                }\n                #[test]\n                fn test_fact() {\n                    #[derive(Clone, Copy, Debug)]\n                    struct Mod;\n                    impl Module for Mod {\n                        fn module() -> u32 {\n                            1000000007\n                        }\n                    }\n                    let c = Comb::<Mod>::new(100);\n                    let p = 8721234;\n                    let mut f = Mint::from(1);\n                    for i in 1..(p + 1) {\n                        f *= i;\n                    }\n                    assert_eq!(f, c.fact(p));\n                }\n            }\n        }\n        mod mint {\n            use std::fmt;\n            use std::marker::PhantomData;\n            use std::mem;\n            use std::ops;\n            #[doc = \" Trait for `Mint`. `module()` should return prime number.\"]\n            pub trait Module: Copy + Clone {\n                fn module() -> u32;\n            }\n            #[doc = \" One of famous numbers in programming contest. `10^9 + 7`\"]\n            pub const MOD_107: u32 = 1_000_000_007;\n            #[doc = \" One of famous numbers in programming contest. `10^9 + 9`\"]\n            pub const MOD_109: u32 = 1_000_000_009;\n            #[doc = \" One of famous numbers in programming contest. `998_244_353`\"]\n            pub const MOD_998: u32 = 998_244_353;\n            #[doc = \" struct to implement Module trait. it returns `MOD_107`.\"]\n            #[derive(Debug, Copy, Clone)]\n            pub struct Mod107;\n            impl Module for Mod107 {\n                fn module() -> u32 {\n                    MOD_107\n                }\n            }\n            #[doc = \" struct to implement Module trait. it returns `MOD_109`.\"]\n            #[derive(Debug, Copy, Clone)]\n            pub struct Mod109;\n            impl Module for Mod109 {\n                fn module() -> u32 {\n                    MOD_109\n                }\n            }\n            #[doc = \" struct to implement Module trait. it returns `MOD_998`.\"]\n            #[derive(Debug, Copy, Clone)]\n            pub struct Mod998;\n            impl Module for Mod998 {\n                fn module() -> u32 {\n                    MOD_998\n                }\n            }\n            #[doc = \" Wrapper class to compute mod `1_000_000_007` automatically.\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::math::{Mint107, MOD_107};\"]\n            #[doc = \" let x: Mint107 = 1234567.into();\"]\n            #[doc = \" let y: Mint107 = 2345678.into();\"]\n            #[doc = \" let z = x * y;\"]\n            #[doc = \" # // TODO: implement convert to u64\"]\n            #[doc = \" assert_eq!(z.val as u64, 1234567u64 * 2345678u64 % MOD_107 as u64);\"]\n            #[doc = \" ```\"]\n            #[doc = \"\"]\n            pub type Mint107 = Mint<Mod107>;\n            #[doc = \" Wrapper class to compute mod `1_000_000_009` automatically.\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::math::{Mint109, MOD_109};\"]\n            #[doc = \" let x: Mint109 = 1234567.into();\"]\n            #[doc = \" let y: Mint109 = 2345678.into();\"]\n            #[doc = \" let z = x * y;\"]\n            #[doc = \" assert_eq!(z.val as u64, 1234567u64 * 2345678u64 % MOD_109 as u64);\"]\n            #[doc = \" ```\"]\n            #[doc = \"\"]\n            pub type Mint109 = Mint<Mod109>;\n            #[doc = \" Wrapper class to compute mod `998_244_353` automatically.\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::math::{Mint998, MOD_998};\"]\n            #[doc = \" let x: Mint998 = 1234567.into();\"]\n            #[doc = \" let y: Mint998 = 2345678.into();\"]\n            #[doc = \" let z = x * y;\"]\n            #[doc = \" assert_eq!(z.val as u64, 1234567u64 * 2345678u64 % MOD_998 as u64);\"]\n            #[doc = \" ```\"]\n            #[doc = \"\"]\n            pub type Mint998 = Mint<Mod998>;\n            #[doc = \" Wrapper class to compute modulo operation.\"]\n            #[doc = \" See examples\"]\n            #[doc = \" [`Mint107`](type.Mint107.html),\"]\n            #[doc = \" [`Mint109`](type.Mint109.html),\"]\n            #[doc = \" [`Mint998`](type.Mint998.html)\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::math::{Mint107, MOD_107};\"]\n            #[doc = \" let x: Mint107 = 1234567.into();\"]\n            #[doc = \" let y: Mint107 = 2345678.into();\"]\n            #[doc = \" let z = x * y;\"]\n            #[doc = \" assert_eq!(z.val as u64, 1234567u64 * 2345678u64 % MOD_107 as u64);\"]\n            #[doc = \" ```\"]\n            #[derive(Debug, Copy, Clone, Eq)]\n            pub struct Mint<M: Module> {\n                #[doc = \" internal value. this is always less than `self.module()`.\"]\n                pub val: u32,\n                m: PhantomData<M>,\n            }\n            impl<M: Module> Mint<M> {\n                fn module(self) -> u32 {\n                    M::module()\n                }\n                fn new(val: u32) -> Mint<M> {\n                    assert!(val < M::module());\n                    Mint {\n                        val: val,\n                        m: PhantomData,\n                    }\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::Add<T> for Mint<M> {\n                type Output = Mint<M>;\n                fn add(self, other: T) -> Mint<M> {\n                    let nval = self.val + other.into().val;\n                    Mint::new(if nval >= self.module() {\n                        nval - self.module()\n                    } else {\n                        nval\n                    })\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::Sub<T> for Mint<M> {\n                type Output = Mint<M>;\n                fn sub(self, other: T) -> Mint<M> {\n                    let nval = self.val + self.module() - other.into().val;\n                    Mint::new(if nval >= self.module() {\n                        nval - self.module()\n                    } else {\n                        nval\n                    })\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::Mul<T> for Mint<M> {\n                type Output = Mint<M>;\n                fn mul(self, other: T) -> Mint<M> {\n                    let nval = self.val as u64 * other.into().val as u64;\n                    Mint::new((nval % (self.module() as u64)) as u32)\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::Div<T> for Mint<M> {\n                type Output = Mint<M>;\n                fn div(self, other: T) -> Mint<M> {\n                    self * other.into().inv()\n                }\n            }\n            impl<M: Module> Mint<M> {\n                #[doc = \" Returns number `y` that satisfies `x * y == 1` where `x` is the original value.\"]\n                #[doc = \"\"]\n                #[doc = \" This assumes `module()` returns prime number.\"]\n                pub fn inv(self) -> Mint<M> {\n                    let mut a = self.val as i32;\n                    let mut b = self.module() as i32;\n                    let mut u = 1 as i32;\n                    let mut v = 0 as i32;\n                    while b != 0 {\n                        let t = a / b;\n                        a -= t * b;\n                        mem::swap(&mut a, &mut b);\n                        u -= t * v;\n                        mem::swap(&mut u, &mut v);\n                    }\n                    Mint::new(if u < 0 { u + self.module() as i32 } else { u } as u32)\n                }\n            }\n            impl<M: Module> PartialEq for Mint<M> {\n                fn eq(&self, other: &Mint<M>) -> bool {\n                    self.val == other.val\n                }\n            }\n            impl<M: Module> fmt::Display for Mint<M> {\n                fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n                    self.val.fmt(f)\n                }\n            }\n            macro_rules ! impl_signed_mint { ( $ ( $ t : ty ) * ) => ( $ ( impl < M : Module > From <$ t > for Mint < M > { # [ inline ] fn from ( x : $ t ) -> Mint < M > { let t = ( x as i64 ) % ( M :: module ( ) as i64 ) ; if x >= 0 { Mint { val : t as u32 , m : PhantomData } } else { Mint { val : ( M :: module ( ) as i64 + t ) as u32 , m : PhantomData } } } } ) * ) }\n            macro_rules ! impl_unsigned_mint { ( $ ( $ t : ty ) * ) => ( $ ( impl < M : Module > From <$ t > for Mint < M > { # [ inline ] fn from ( x : $ t ) -> Mint < M > { let t = x as u64 % M :: module ( ) as u64 ; Mint :: new ( t as u32 ) } } ) * ) }\n            impl_signed_mint! { i8 i16 i32 i64 isize }\n            impl_unsigned_mint! { u8 u16 u32 u64 usize }\n            impl<T: Into<Mint<M>>, M: Module> ops::AddAssign<T> for Mint<M> {\n                fn add_assign(&mut self, other: T) {\n                    *self = *self + other.into();\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::SubAssign<T> for Mint<M> {\n                fn sub_assign(&mut self, other: T) {\n                    *self = *self - other.into();\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::MulAssign<T> for Mint<M> {\n                fn mul_assign(&mut self, other: T) {\n                    *self = *self * other.into();\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::DivAssign<T> for Mint<M> {\n                fn div_assign(&mut self, other: T) {\n                    *self = *self / other.into();\n                }\n            }\n            #[cfg(test)]\n            mod tests {\n                use super::*;\n                #[test]\n                fn test_simple() {\n                    let a: Mint<Mod107> = Mint::from(3);\n                    let b: Mint<Mod107> = Mint::from(1000000000);\n                    assert_eq!(Mint::from(3000000000u64 % Mod107::module() as u64), a * b);\n                }\n            }\n        }\n        pub use self::comb::Comb;\n        pub use self::mint::{Mint, Module};\n        pub use self::mint::{Mint107, Mint109, Mint998};\n        pub use self::mint::{Mod107, Mod109, Mod998};\n        pub use self::mint::{MOD_107, MOD_109, MOD_998};\n    }\n    pub mod util {\n        mod permutation {\n            #[doc = \" It contains same methods as `std::next_permutaion` in C++.\"]\n            #[doc = \" these methods should rearrange the elements into the next/prev lexicographically greater permutation.\"]\n            #[doc = \"\"]\n            #[doc = \" This is implemented in [T] where T is Ord.\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::util::Permutation;\"]\n            #[doc = \"\"]\n            #[doc = \" let mut perm = [5, 0, 9, 2];\"]\n            #[doc = \" assert!(perm.next_permutation());\"]\n            #[doc = \" assert_eq!(perm, [5, 2, 0, 9]);\"]\n            #[doc = \" assert!(perm.next_permutation());\"]\n            #[doc = \" assert_eq!(perm, [5, 2, 9, 0]);\"]\n            #[doc = \" assert!(perm.prev_permutation());\"]\n            #[doc = \" assert_eq!(perm, [5, 2, 0, 9]);\"]\n            #[doc = \"\"]\n            #[doc = \" let mut perm = [4, 3, 2, 1, 0];\"]\n            #[doc = \" assert!(!perm.next_permutation());\"]\n            #[doc = \" assert_eq!(perm, [4, 3, 2, 1, 0]);\"]\n            #[doc = \" ```\"]\n            pub trait Permutation {\n                #[doc = \" It rearranges the elements into the next lexicographically greater permutation.\"]\n                #[doc = \"\"]\n                #[doc = \" Returns `false` without modifying any state only if current is the last permutation.\"]\n                fn next_permutation(&mut self) -> bool;\n                #[doc = \" It rearranges the elements into the previous lexicographically greater permutation.\"]\n                #[doc = \"\"]\n                #[doc = \" Returns `false` without modifying any state only if current is the first permutation.\"]\n                fn prev_permutation(&mut self) -> bool;\n            }\n            impl<T> Permutation for [T]\n            where\n                T: Ord,\n            {\n                fn next_permutation(&mut self) -> bool {\n                    if self.len() <= 1 {\n                        return false;\n                    }\n                    let mut i = self.len() - 1;\n                    while i > 0 && self[i - 1] >= self[i] {\n                        i -= 1;\n                    }\n                    if i == 0 {\n                        return false;\n                    }\n                    let mut j = self.len() - 1;\n                    while self[j] <= self[i - 1] {\n                        j -= 1;\n                    }\n                    self.swap(j, i - 1);\n                    self[i..].reverse();\n                    true\n                }\n                fn prev_permutation(&mut self) -> bool {\n                    if self.len() <= 1 {\n                        return false;\n                    }\n                    let mut i = self.len() - 1;\n                    while i > 0 && self[i - 1] <= self[i] {\n                        i -= 1;\n                    }\n                    if i == 0 {\n                        return false;\n                    }\n                    self[i..].reverse();\n                    let mut j = self.len() - 1;\n                    while self[j - 1] < self[i - 1] {\n                        j -= 1;\n                    }\n                    self.swap(i - 1, j);\n                    true\n                }\n            }\n            #[cfg(test)]\n            mod tests {\n                use super::*;\n                #[test]\n                fn test_simple() {\n                    let mut data = [0, 0, 1, 1, 2];\n                    data.next_permutation();\n                    assert_eq!(&data, &[0, 0, 1, 2, 1]);\n                    data.next_permutation();\n                    assert_eq!(&data, &[0, 0, 2, 1, 1]);\n                    data.next_permutation();\n                    assert_eq!(&data, &[0, 1, 0, 1, 2]);\n                    data.next_permutation();\n                    assert_eq!(&data, &[0, 1, 0, 2, 1]);\n                    data.next_permutation();\n                    assert_eq!(&data, &[0, 1, 1, 0, 2]);\n                    data.prev_permutation();\n                    assert_eq!(&data, &[0, 1, 0, 2, 1]);\n                    data.prev_permutation();\n                    assert_eq!(&data, &[0, 1, 0, 1, 2]);\n                    data.prev_permutation();\n                    assert_eq!(&data, &[0, 0, 2, 1, 1]);\n                    data.prev_permutation();\n                    assert_eq!(&data, &[0, 0, 1, 2, 1]);\n                    data.prev_permutation();\n                    assert_eq!(&data, &[0, 0, 1, 1, 2]);\n                    assert!(!data.prev_permutation());\n                }\n            }\n        }\n        mod random {\n            use std::num::Wrapping;\n            #[doc = \" Not secure but fast random generator.\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::util::XorShift;\"]\n            #[doc = \" let mut xorshift = XorShift::new();\"]\n            #[doc = \" assert_eq!(3701687786, xorshift.next_u32());\"]\n            #[doc = \" assert_eq!(458299110, xorshift.next_u32());\"]\n            #[doc = \" ```\"]\n            #[derive(Clone, Debug, Default)]\n            pub struct XorShift {\n                x: Wrapping<u32>,\n                y: Wrapping<u32>,\n                z: Wrapping<u32>,\n                w: Wrapping<u32>,\n            }\n            impl XorShift {\n                #[doc = \" Create object with default seed.\"]\n                pub fn new() -> XorShift {\n                    XorShift {\n                        x: Wrapping(123_456_789),\n                        y: Wrapping(362_436_069),\n                        z: Wrapping(521_288_629),\n                        w: Wrapping(88_675_123),\n                    }\n                }\n                #[doc = \" Get next random u32 number.\"]\n                pub fn next_u32(&mut self) -> u32 {\n                    let x = self.x;\n                    let t = x ^ (x << 11);\n                    self.x = self.y;\n                    self.y = self.z;\n                    self.z = self.w;\n                    let v = self.w;\n                    self.w = v ^ (v >> 19) ^ (t ^ (t >> 8));\n                    self.w.0\n                }\n            }\n            #[cfg(test)]\n            mod tests {\n                use super::XorShift;\n                #[test]\n                fn test_basic() {\n                    let mut xorshift = XorShift::new();\n                    assert_eq!(3701687786, xorshift.next_u32());\n                    assert_eq!(458299110, xorshift.next_u32());\n                }\n            }\n        }\n        pub use self::permutation::Permutation;\n        pub use self::random::XorShift;\n    }\n}\n\n//}}}\n"
  },
  {
    "language": "Rust",
    "code": "use std::cmp;\n\nconst INF: i64 = 1e17 as i64;\n\nfn main() {\n    let s = std::io::stdin();\n    let mut sc = Scanner { reader: s.lock() };\n    let n: usize = sc.read();\n    let a: Vec<i64> = sc.read_vec(n);\n    let mut graph = vec![vec![]; n];\n    for _ in 0..(n - 1) {\n        let v = sc.read::<usize>() - 1;\n        let u = sc.read::<usize>() - 1;\n        graph[v].push(u);\n        graph[u].push(v);\n    }\n\n    let mut dp1 = vec![vec![]; n];\n    let mut dp2 = vec![vec![]; n];\n    dfs(0, 0, &graph, &a, &mut dp1, &mut dp2);\n\n    for i in 1..(n + 1) {\n        if dp1[0][i] < INF {\n            println!(\"{}\", i - 1);\n            return;\n        }\n        if dp2[0][i] < 0 {\n            println!(\"{}\", i - 1);\n            return;\n        }\n    }\n}\n\nfn dfs(\n    v: usize,\n    p: usize,\n    graph: &Vec<Vec<usize>>,\n    a: &Vec<i64>,\n    dp1: &mut Vec<Vec<i64>>,\n    dp2: &mut Vec<Vec<i64>>,\n) {\n    dp1[v].push(INF);\n    dp1[v].push(if a[v] > 0 { a[v] } else { INF });\n    dp2[v].push(INF);\n    dp2[v].push(a[v]);\n    for &next in graph[v].iter() {\n        if next == p { continue; }\n        dfs(next, v, graph, a, dp1, dp2);\n\n        dp1[v] = connect(&dp1[v], &dp1[next], &dp2[next], true);\n        dp2[v] = connect(&dp2[v], &dp1[next], &dp2[next], false);\n    }\n}\n\nfn connect(dp: &Vec<i64>, child1: &Vec<i64>, child2: &Vec<i64>, power_only: bool) -> Vec<i64> {\n    let mut ans = vec![INF; dp.len() + child1.len() - 1];\n    assert_eq!(dp[0], INF);\n    assert_eq!(child1[0], INF);\n    assert_eq!(child2[0], INF);\n    for groups in 1..dp.len() {\n        if dp[groups] == INF { continue; }\n        for child_groups in 1..child1.len() {\n            let total_groups = groups + child_groups;\n\n            if child1[child_groups] != INF {\n                ch_min(&mut ans[total_groups - 1], dp[groups] + child1[child_groups]);\n            }\n            if child2[child_groups] != INF && !power_only {\n                ch_min(&mut ans[total_groups - 1], dp[groups] + child2[child_groups]);\n            }\n            if child1[child_groups] != INF || child2[child_groups] < 0 {\n                ch_min(&mut ans[total_groups], dp[groups]);\n            }\n        }\n    }\n    ans\n}\n\nfn ch_min<T: PartialOrd>(a: &mut T, b: T) {\n    if *a > b {\n        *a = b;\n    }\n}\n\npub struct Scanner<R> {\n    reader: R,\n}\n\nimpl<R: std::io::Read> Scanner<R> {\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .reader\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n')\n            .take_while(|&b| b != b' ' && b != b'\\n')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn read_vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  }
]