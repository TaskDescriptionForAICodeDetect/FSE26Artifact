[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 100005\n\nint parent[MAX_N];\nint power[MAX_N];\nint size[MAX_N];\nint is_computer[MAX_N];\n\nint find(int x) {\n    if (parent[x] != x)\n        parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nvoid unite(int x, int y) {\n    int px = find(x);\n    int py = find(y);\n    \n    if (px == py) return;\n    \n    if (size[px] < size[py]) {\n        int temp = px;\n        px = py;\n        py = temp;\n    }\n    \n    parent[py] = px;\n    size[px] += size[py];\n    power[px] += power[py];\n    is_computer[px] |= is_computer[py];\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n    \n    for (int i = 1; i <= N; i++) {\n        scanf(\"%d\", &power[i]);\n        parent[i] = i;\n        size[i] = 1;\n        is_computer[i] = power[i] < 0;\n    }\n    \n    int cables[MAX_N][2];\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d %d\", &cables[i][0], &cables[i][1]);\n    }\n    \n    int min_disconnected = M;\n    \n    for (int mask = 0; mask < (1 << M); mask++) {\n        for (int i = 1; i <= N; i++) {\n            parent[i] = i;\n            size[i] = 1;\n            is_computer[i] = power[i] < 0;\n        }\n        \n        int disconnected = 0;\n        for (int i = 0; i < M; i++) {\n            if (!(mask & (1 << i))) {\n                unite(cables[i][0], cables[i][1]);\n            } else {\n                disconnected++;\n            }\n        }\n        \n        int valid = 1;\n        for (int i = 1; i <= N; i++) {\n            if (parent[i] == i) {\n                int root = find(i);\n                if (is_computer[root] && power[root] >= 0) {\n                    valid = 0;\n                    break;\n                }\n            }\n        }\n        \n        if (valid) {\n            min_disconnected = (disconnected < min_disconnected) ? disconnected : min_disconnected;\n        }\n    }\n    \n    printf(\"%d\\n\", min_disconnected);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:57:31"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int to;\n    int next;\n} Edge;\n\nEdge edges[200010];\nint head[100010];\nint A[100010];\nint edge_count = 0;\nint answer = 0;\n\nvoid add_edge(int u, int v) {\n    edges[edge_count].to = v;\n    edges[edge_count].next = head[u];\n    head[u] = edge_count++;\n}\n\ntypedef struct {\n    int total;\n    int has_computer;\n} Result;\n\nResult dfs(int u, int parent) {\n    Result res = {A[u], (A[u] < 0)};\n    for (int i = head[u]; i != -1; i = edges[i].next) {\n        int v = edges[i].to;\n        if (v == parent) continue;\n        Result child = dfs(v, u);\n        res.total += child.total;\n        res.has_computer |= child.has_computer;\n        if (child.has_computer && child.total >= 0) {\n            answer++;\n        }\n    }\n    return res;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    for (int i = 1; i <= N; i++) {\n        scanf(\"%d\", &A[i]);\n        head[i] = -1;\n    }\n    for (int i = 0; i < N - 1; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        add_edge(u, v);\n        add_edge(v, u);\n    }\n    dfs(1, -1);\n    printf(\"%d\\n\", answer);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:58:23"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<int> A;\nvector<bool> visited;\nint total_cuts = 0;\n\npair<int, int> dfs(int v, int parent) {\n    visited[v] = true;\n    int sum = A[v];\n    int computers = (A[v] < 0) ? 1 : 0;\n    \n    for (int u : adj[v]) {\n        if (u == parent) continue;\n        auto [child_sum, child_computers] = dfs(u, v);\n        sum += child_sum;\n        computers += child_computers;\n    }\n    \n    if (sum < 0 || computers == 0) {\n        total_cuts++;\n        return {0, 0};\n    }\n    \n    return {sum, computers};\n}\n\nint main() {\n    int N;\n    cin >> N;\n    A.resize(N + 1);\n    adj.resize(N + 1);\n    visited.resize(N + 1, false);\n    \n    for (int i = 1; i <= N; ++i) {\n        cin >> A[i];\n    }\n    \n    for (int i = 0; i < N - 1; ++i) {\n        int U, V;\n        cin >> U >> V;\n        adj[U].push_back(V);\n        adj[V].push_back(U);\n    }\n    \n    dfs(1, -1);\n    cout << total_cuts - 1 << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:58:37"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    static List<List<Integer>> tree;\n    static int[] A;\n    static int res;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        A = new int[N + 1];\n        tree = new ArrayList<>();\n        for (int i = 0; i <= N; i++) {\n            tree.add(new ArrayList<>());\n        }\n        for (int i = 1; i <= N; i++) {\n            A[i] = sc.nextInt();\n        }\n        for (int i = 0; i < N - 1; i++) {\n            int u = sc.nextInt();\n            int v = sc.nextInt();\n            tree.get(u).add(v);\n            tree.get(v).add(u);\n        }\n        res = 0;\n        dfs(1, -1);\n        System.out.println(res);\n    }\n\n    static int[] dfs(int node, int parent) {\n        int sum = A[node];\n        int comp = (A[node] < 0) ? 1 : 0;\n        for (int neighbor : tree.get(node)) {\n            if (neighbor == parent) continue;\n            int[] child = dfs(neighbor, node);\n            sum += child[0];\n            comp += child[1];\n        }\n        if (sum < 0 || comp == 0) {\n            res++;\n            return new int[]{0, 0};\n        }\n        return new int[]{sum, comp};\n    }\n}",
    "timestamp": "2025-08-05 22:58:51"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    private List<List<Integer>> graph;\n    private int[] power;\n    private boolean[] visited;\n\n    public int minimumCablesToDisable(int N, int[] U, int[] V, int[] A) {\n        graph = new ArrayList<>(N + 1);\n        for (int i = 0; i < N + 1; i++) {\n            graph.add(new ArrayList<>());\n        }\n        power = new int[N + 1];\n        System.arraycopy(A, 0, power, 1, N);\n\n        for (int i = 0; i < N - 1; i++) {\n            graph.get(U[i]).add(V[i]);\n            graph.get(V[i]).add(U[i]);\n        }\n\n        int minCables = Integer.MAX_VALUE;\n        for (int i = 0; i < N - 1; i++) {\n            int[] tempPower = power.clone();\n            int cables = solveDisconnect(U[i], V[i], N);\n            if (canDisableServer(N)) {\n                minCables = Math.min(minCables, cables);\n            }\n            power = tempPower;\n        }\n\n        return minCables == Integer.MAX_VALUE ? -1 : minCables;\n    }\n\n    private int solveDisconnect(int u, int v, int N) {\n        graph.get(u).remove(Integer.valueOf(v));\n        graph.get(v).remove(Integer.valueOf(u));\n        return 1;\n    }\n\n    private boolean canDisableServer(int N) {\n        visited = new boolean[N + 1];\n        for (int i = 1; i <= N; i++) {\n            if (!visited[i]) {\n                if (!checkComponent(i)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    private boolean checkComponent(int start) {\n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(start);\n        visited[start] = true;\n        int totalPower = power[start];\n        boolean hasComputer = power[start] < 0;\n\n        while (!queue.isEmpty()) {\n            int node = queue.poll();\n            for (int neighbor : graph.get(node)) {\n                if (!visited[neighbor]) {\n                    queue.offer(neighbor);\n                    visited[neighbor] = true;\n                    totalPower += power[neighbor];\n                    hasComputer |= power[neighbor] < 0;\n                }\n            }\n        }\n\n        return !hasComputer || totalPower >= 0;\n    }\n}",
    "timestamp": "2025-08-05 22:59:00"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 1e5 + 5;\n\nvector<int> graph[MAXN];\nint power[MAXN];\nint parent[MAXN];\nbool visited[MAXN];\n\nint find(int x) {\n    if (parent[x] != x) parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nvoid unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x != y) parent[y] = x;\n}\n\nbool canDisableComponent(vector<int>& component) {\n    int totalPower = 0;\n    bool hasComputer = false;\n\n    for (int node : component) {\n        if (power[node] < 0) hasComputer = true;\n        totalPower += power[node];\n    }\n\n    return !hasComputer || totalPower < 0;\n}\n\nint solve(int N, vector<pair<int, int>>& edges) {\n    for (int i = 1; i <= N; i++) {\n        parent[i] = i;\n        visited[i] = false;\n    }\n\n    for (auto& edge : edges) {\n        unite(edge.first, edge.second);\n    }\n\n    unordered_map<int, vector<int>> components;\n    for (int i = 1; i <= N; i++) {\n        int root = find(i);\n        components[root].push_back(i);\n    }\n\n    int minCablesToRemove = 0;\n    for (auto& [root, component] : components) {\n        if (!canDisableComponent(component)) {\n            minCablesToRemove += component.size() - 1;\n        }\n    }\n\n    return minCablesToRemove;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    for (int i = 1; i <= N; i++) {\n        cin >> power[i];\n    }\n\n    vector<pair<int, int>> edges(M);\n    for (int i = 0; i < M; i++) {\n        cin >> edges[i].first >> edges[i].second;\n        graph[edges[i].first].push_back(edges[i].second);\n        graph[edges[i].second].push_back(edges[i].first);\n    }\n\n    int result = solve(N, edges);\n    cout << result << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:59:09"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def dfs(node, parent, graph, A, dp):\n    dp[node] = A[node - 1]\n    for neighbor in graph[node]:\n        if neighbor == parent:\n            continue\n        dfs(neighbor, node, graph, A, dp)\n        dp[node] += max(0, dp[neighbor])\n\ndef min_cuts_to_disable_server(N, cables, A):\n    from collections import defaultdict\n    graph = defaultdict(list)\n    \n    for U, V in cables:\n        graph[U].append(V)\n        graph[V].append(U)\n\n    dp = [0] * (N + 1)\n    dfs(1, -1, graph, A, dp)\n    \n    count = 0\n    for U, V in cables:\n        if dp[U] <= 0 or dp[V] <= 0:\n            count += 1\n    \n    return count\n\n# Example usage:\nN = 5\ncables = [(1, 2), (1, 3), (2, 4), (2, 5)]\nA = [-1, 2, 3, -2, -3]\nprint(min_cuts_to_disable_server(N, cables, A))  # Output should be the minimum number of cables to cut",
    "timestamp": "2025-08-13 13:09:53"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class ServerDisabler {\n    private static List<List<Integer>> adjList;\n    private static int[] power;\n    private static boolean[] visited;\n    private static int disconnectCount;\n\n    public static int disableServer(int N, int[] A, int[][] cables) {\n        adjList = new ArrayList<>();\n        power = new int[N + 1];\n        visited = new boolean[N + 1];\n        disconnectCount = 0;\n\n        for (int i = 0; i <= N; i++) {\n            adjList.add(new ArrayList<>());\n            power[i] = A[i - 1];\n        }\n\n        for (int[] cable : cables) {\n            adjList.get(cable[0]).add(cable[1]);\n            adjList.get(cable[1]).add(cable[0]);\n        }\n\n        for (int i = 1; i <= N; i++) {\n            if (!visited[i]) {\n                dfs(i);\n            }\n        }\n\n        return disconnectCount;\n    }\n\n    private static int dfs(int node) {\n        visited[node] = true;\n        int totalPower = power[node];\n        boolean hasComputer = power[node] < 0;\n\n        for (int neighbor : adjList.get(node)) {\n            if (!visited[neighbor]) {\n                int componentPower = dfs(neighbor);\n                if (componentPower <= 0 || totalPower + componentPower <= 0) {\n                    disconnectCount++;\n                }\n                totalPower += componentPower;\n                hasComputer |= power[neighbor] < 0;\n            }\n        }\n\n        if (!hasComputer) {\n            return Integer.MAX_VALUE; // This component can be separately disabled\n        }\n\n        return totalPower;\n    }\n\n    public static void main(String[] args) {\n        int N = 5;\n        int[] A = {-1, 2, -3, 4, 5};\n        int[][] cables = {{1, 2}, {2, 3}, {3, 4}, {4, 5}};\n\n        int result = disableServer(N, A, cables);\n        System.out.println(result); // Output the minimum number of cables needed\n    }\n}",
    "timestamp": "2025-08-13 13:10:00"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAXN 100000\n\ntypedef struct {\n    int v, next;\n} Edge;\n\nEdge edges[MAXN * 2];\nint head[MAXN + 1], edge_count;\nint A[MAXN + 1];\nint N;\n\nvoid add_edge(int u, int v) {\n    edges[edge_count] = (Edge){v, head[u]};\n    head[u] = edge_count++;\n    edges[edge_count] = (Edge){u, head[v]};\n    head[v] = edge_count++;\n}\n\nint visited[MAXN + 1];\nint dp[MAXN + 1];\n\nint dfs(int node) {\n    visited[node] = 1;\n    dp[node] = A[node];\n    for (int i = head[node]; i != -1; i = edges[i].next) {\n        int v = edges[i].v;\n        if (!visited[v]) {\n            dp[node] += dfs(v);\n        }\n    }\n    return dp[node];\n}\n\nint disable_server() {\n    memset(visited, 0, sizeof(visited));\n    dfs(1);\n    int cuts = 0;\n    for (int i = 1; i <= N; i++) {\n        if (dp[i] == 0 || dp[i] > 0) cuts++;\n    }\n    return cuts - 1;\n}\n\nint main() {\n    memset(head, -1, sizeof(head));\n    edge_count = 0;\n\n    scanf(\"%d\", &N);\n    for (int i = 1; i <= N; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    for (int i = 1; i < N; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        add_edge(u, v);\n    }\n\n    printf(\"%d\\n\", disable_server());\n    return 0;\n}",
    "timestamp": "2025-08-13 13:10:07"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function minCablesToDisconnect(N, cables, power) {\n    const adjList = Array.from({ length: N + 1 }, () => []);\n    cables.forEach(([u, v]) => {\n        adjList[u].push(v);\n        adjList[v].push(u);\n    });\n\n    let componentSum = 0;\n    let computersCount = 0;\n    const visited = new Array(N + 1).fill(false);\n    let result = 0;\n\n    const dfs = (node) => {\n        visited[node] = true;\n        componentSum += power[node - 1];\n        if (power[node - 1] < 0) computersCount++;\n        for (const neighbor of adjList[node]) {\n            if (!visited[neighbor]) {\n                dfs(neighbor);\n            }\n        }\n    };\n\n    for (let i = 1; i <= N; i++) {\n        if (!visited[i]) {\n            componentSum = 0;\n            computersCount = 0;\n            dfs(i);\n            if (computersCount > 0 && componentSum >= 0) {\n                result++;\n            }\n        }\n    }\n    \n    return result;\n}\n\n// Example usage:\n// const N = 3;\n// const cables = [[1, 2], [2, 3]];\n// const power = [1, -2, 1];\n// console.log(minCablesToDisconnect(N, cables, power)); // Output: 1",
    "timestamp": "2025-08-13 13:10:13"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from typing import List, Tuple\nimport sys\n\ndef find(parent: List[int], x: int) -> int:\n    if parent[x] != x:\n        parent[x] = find(parent, parent[x])\n    return parent[x]\n\ndef union(parent: List[int], rank: List[int], x: int, y: int) -> None:\n    px, py = find(parent, x), find(parent, y)\n    if px == py:\n        return\n    if rank[px] < rank[py]:\n        px, py = py, px\n    parent[py] = px\n    if rank[px] == rank[py]:\n        rank[px] += 1\n\ndef solve_server_disable(N: int, cables: List[Tuple[int, int]], power: List[int]) -> int:\n    sys.setrecursionlimit(N + 10)\n    \n    parent = list(range(N + 1))\n    rank = [0] * (N + 1)\n    \n    for u, v in cables:\n        union(parent, rank, u, v)\n    \n    components = {}\n    for v in range(1, N + 1):\n        root = find(parent, v)\n        if root not in components:\n            components[root] = []\n        components[root].append(v)\n    \n    cables_to_remove = 0\n    \n    for comp_devices in components.values():\n        comp_power_sum = sum(power[v-1] for v in comp_devices)\n        has_computer = any(power[v-1] < 0 for v in comp_devices)\n        \n        if has_computer and comp_power_sum < 0:\n            cables_to_remove += len(comp_devices) - 1\n    \n    return cables_to_remove\n\n# Example usage\nN = 5\ncables = [(1, 2), (2, 3), (3, 4), (4, 5)]\npower = [-2, 3, -1, 2, 1]\nresult = solve_server_disable(N, cables, power)\nprint(result)",
    "timestamp": "2025-08-13 13:10:21"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solveServerDisabling(N, connections, powerConsumption) {\n    const graph = Array.from({ length: N + 1 }, () => []);\n    const visited = new Array(N + 1).fill(false);\n    \n    // Build adjacency list\n    for (const [u, v] of connections) {\n        graph[u].push(v);\n        graph[v].push(u);\n    }\n    \n    function findComponent(node) {\n        const component = [];\n        const componentVisited = new Array(N + 1).fill(false);\n        \n        function dfs(curr) {\n            componentVisited[curr] = true;\n            visited[curr] = true;\n            component.push(curr);\n            \n            for (const neighbor of graph[curr]) {\n                if (!componentVisited[neighbor]) {\n                    dfs(neighbor);\n                }\n            }\n        }\n        \n        dfs(node);\n        return component;\n    }\n    \n    function canDisableComponent(component) {\n        let totalPower = 0;\n        let hasComputer = false;\n        \n        for (const node of component) {\n            if (powerConsumption[node] < 0) {\n                hasComputer = true;\n            }\n            totalPower += powerConsumption[node];\n        }\n        \n        return !hasComputer || totalPower < 0;\n    }\n    \n    let minCablesToDisconnect = 0;\n    \n    for (let i = 1; i <= N; i++) {\n        if (!visited[i]) {\n            const component = findComponent(i);\n            \n            if (!canDisableComponent(component)) {\n                minCablesToDisconnect += component.length - 1;\n            }\n        }\n    }\n    \n    return minCablesToDisconnect;\n}",
    "timestamp": "2025-08-13 13:10:28"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N = int(input[ptr])\n    ptr += 1\n    A = list(map(int, input[ptr:ptr+N]))\n    ptr += N\n    A = [0] + A  # 1-based indexing\n\n    adj = [[] for _ in range(N+1)]\n    for _ in range(N-1):\n        u, v = map(int, input[ptr:ptr+2])\n        ptr += 2\n        adj[u].append(v)\n        adj[v].append(u)\n\n    parent = [0] * (N + 1)\n    children = [[] for _ in range(N + 1)]\n    root = 1\n    q = deque([root])\n    parent[root] = 0\n\n    # Build the tree with parent and children\n    while q:\n        u = q.popleft()\n        for v in adj[u]:\n            if parent[v] == 0 and v != parent[u]:\n                parent[v] = u\n                children[u].append(v)\n                q.append(v)\n\n    # Post-order processing\n    res = 0\n    sum_a = [0] * (N + 1)\n    has_computer = [False] * (N + 1)\n\n    stack = [(root, False)]\n    while stack:\n        node, processed = stack.pop()\n        if not processed:\n            stack.append((node, True))\n            for child in reversed(children[node]):\n                stack.append((child, False))\n        else:\n            sum_a[node] = A[node]\n            has_computer[node] = (A[node] < 0)\n            for child in children[node]:\n                sum_a[node] += sum_a[child]\n                has_computer[node] |= has_computer[child]\n            if has_computer[node] and sum_a[node] >= 0:\n                res += 1\n    print(res)\n\nsolve()",
    "timestamp": "2025-08-13 13:10:39"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const fs = require('fs');\nconst input = fs.readFileSync(0, 'utf-8').trim().split('\\n');\n\nfunction main() {\n    let ptr = 0;\n    const N = parseInt(input[ptr++], 10);\n    const A = input[ptr++].split(' ').map(Number);\n    const adj = Array.from({ length: N + 1 }, () => []);\n    \n    for (let i = 0; i < N - 1; i++) {\n        const [u, v] = input[ptr++].split(' ').map(Number);\n        adj[u].push(v);\n        adj[v].push(u);\n    }\n    \n    let res = 0;\n    \n    function dfs(u, parent) {\n        let sum = A[u - 1];\n        let hasComputer = A[u - 1] < 0;\n        \n        for (const v of adj[u]) {\n            if (v === parent) continue;\n            const [childSum, childHasComputer] = dfs(v, u);\n            sum += childSum;\n            hasComputer = hasComputer || childHasComputer;\n        }\n        \n        if (sum < 0 || !hasComputer) {\n            res++;\n            return [0, false];\n        }\n        \n        return [sum, hasComputer];\n    }\n    \n    dfs(1, -1);\n    console.log(res - 1);\n}\n\nmain();",
    "timestamp": "2025-08-13 13:10:47"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int MAXN = 100005;\n\nvector<int> adj[MAXN];\nint A[MAXN], parent[MAXN], subtreeSum[MAXN];\n\nint dfs(int node, int par) {\n    parent[node] = par;\n    subtreeSum[node] = A[node];\n    for (int neighbor : adj[node]) {\n        if (neighbor == par) continue;\n        subtreeSum[node] += dfs(neighbor, node);\n    }\n    return subtreeSum[node];\n}\n\nint main() {\n    int N;\n    cin >> N;\n    for (int i = 1; i <= N; ++i) {\n        cin >> A[i];\n    }\n    for (int i = 0; i < N - 1; ++i) {\n        int U, V;\n        cin >> U >> V;\n        adj[U].push_back(V);\n        adj[V].push_back(U);\n    }\n\n    dfs(1, -1);\n\n    int disconnects = 0;\n    for (int i = 2; i <= N; ++i) {\n        if (subtreeSum[i] < 0) {\n            disconnects++;\n        }\n    }\n\n    cout << disconnects << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 14:38:21"
  }
]