[
  {
    "language": "Scala",
    "code": "import scala.annotation.tailrec\nimport scala.collection.mutable\nimport scala.collection.mutable.ArrayBuffer\nimport scala.reflect.ClassTag\n\nobject Main extends App {\n\n  import scala.io.StdIn._\n  solve\n  def solve: Unit = {\n    val Array(n, m, s, t) = readLine.trim.split(' ').map(_.toInt)\n    if (n == 0) return\n    val edges = Array.tabulate(m){_ ⇒\n      val Array(a, b) = readLine.trim.split(' ').map(_.toInt - 1)\n      (a, b)\n    }\n    val (flow, graph) = maxFlowWithUniCapacityEdge(s - 1, t - 1, n, edges)\n    //sからのパスがあれば1、tからのパスがあれば-1\n    val sortedGraph = graph.sorted(Ordering.fromLessThan[(Int, Int)]{case ((a, b), (c, d)) ⇒ if (a == c) b < d else a < c})\n    val memo = Array.tabulate(n){_ ⇒ 0}\n    val nodes = Array.tabulate(n){_ ⇒ ArrayBuffer[Int]()}.let{n ⇒\n      for ((from, to) ← graph){\n        n(from).append(to)\n      }\n      n.map{_.toArray}\n    }\n    val revNodes = Array.tabulate(n){_ ⇒ ArrayBuffer[Int]()}.let{n ⇒\n      for ((from, to) ← graph){\n        n(to).append(from)\n      }\n      n.map{_.toArray}\n    }\n    searchPath(revNodes, memo, t - 1, -1)\n    searchPath(nodes, memo, s - 1, 1)\n    val initEdge = edges.filter{\n      case p ⇒\n        val i = lowerBound(sortedGraph, p)\n        if (i < sortedGraph.length) sortedGraph(i) == p\n        else false\n    }\n    val count = initEdge.count{case (from, to) ⇒ memo(from) == -1 && memo(to) == 1}\n    if (count == 0) println(s\"$flow $count\")\n    else println(s\"${flow + 1} $count\")\n    solve\n  }\n\n  def searchPath(graph: Array[Array[Int]], memo: Array[Int], from: Int, marker: Int): Unit = {\n    val queue = mutable.Queue[Int](from)\n    memo(from) = marker\n    while (queue.nonEmpty){\n      for (to ← graph(queue.dequeue()) if memo(to) != marker){\n        memo(to) = marker\n        queue.enqueue(to)\n      }\n    }\n  }\n  def lowerBound(array: Array[(Int, Int)], target: (Int, Int)): Int = {\n    var left = 0\n    var right = array.length\n    while (left < right){\n      val mid = (left + right) / 2\n      if (array(mid)._1 < target._1 || (array(mid)._1 == target._1 && array(mid)._2 < target._2)) {\n        left = mid + 1\n      }else {\n        right = mid\n      }\n    }\n    right\n  }\n  implicit class Extend[T](value: T){\n    def let[R](func: T ⇒ R): R = func(value)\n    def also(func: T ⇒ Unit): T = {func(value); value}\n  }\n  def maxFlowWithUniCapacityEdge(source: Int, drain: Int, size: Int, edges: Array[(Int, Int)]): (Int, Array[(Int, Int)]) = {\n    val nodes = makeGraph(size, edges)\n    val levels = Array.tabulate(size){_ ⇒ -1}\n    val searching = Array.tabulate(size){_ => 0}\n    def bfs = {\n      searching.indices.foreach(i ⇒ searching(i) = 0)\n      levels.indices.foreach(i ⇒ levels(i) = -1)\n      levels(source) = 0\n      val queue = mutable.Queue[Int](source)\n      while (queue.nonEmpty){\n        val prev = queue.dequeue()\n        for (Edge(to, _, b) ← nodes(prev) if b && levels(to) == -1){\n          levels(to) = levels(prev) + 1\n          queue.enqueue(to)\n        }\n      }\n    }\n    def dfs(from: Int): Boolean = {\n      if (from == drain) true\n      else {\n        (searching(from) until nodes(from).length).find{i ⇒\n          nodes(from)(i).flow && levels(from) < levels(nodes(from)(i).to) && dfs(nodes(from)(i).to)\n        } match {\n          case Some(i) ⇒\n            searching(from) = i + 1\n            val Edge(to, pair, _) = nodes(from)(i)\n            nodes(to)(pair) = nodes(to)(pair).copy(flow = true)\n            nodes(from)(i) = Edge(to, pair, false)\n            true\n          case None ⇒\n            searching(from) = nodes(from).length\n            false\n        }\n      }\n    }\n    var count = 0\n    var matching = true\n    while (matching){\n      bfs\n      matching = levels(drain) != -1\n      if (matching){\n        while(dfs(source)){count += 1}\n      }\n    }\n    (count, nodes.indices.flatMap{from ⇒ nodes(from).withFilter(_.flow).map{e ⇒ (from, e.to)}}.toArray)\n  }\n  private case class Edge(to: Int, pair: Int, flow: Boolean)\n  private def makeGraph(size: Int, edges: Array[(Int, Int)]): Array[Array[Edge]] = {\n    val result = Array.tabulate(size){_ ⇒ ArrayBuffer[Edge]()}\n    for ((from, to) ← edges){\n      result(from).append(Edge(to, result(to).length, true))\n      result(to).append(Edge(from, result(from).length - 1, false))\n    }\n    result.map(_.toArray)\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\n#define MAX_V 10000\nusing namespace std;\n\n/*?????§?????¢?????´?????????(Ford_Fulerson????????¨)???O(F|E|)*/\n\n//????????¨????§???????(???????????????????????????)\nstruct edge{int to, cap, rev, s;};\n\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size(),0});\n  G[to].push_back((edge){from,0,(int)G[from].size()-1,1});  \n}\n\n//?¢?????????????DFS??§??¢???\nint dfs(int v,int t,int f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs(e.to ,t , min(f,e.cap));\n      if(d > 0){\n\te.cap -= d;\n\tG[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\n//s??????t???????????§???????±???????\nint max_flow(int s,int t,int maxf){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s, t, maxf);\n    if(maxf==0||f == 0)return flow;\n    maxf-=f;\n    flow += f;\n  }\n}\n\nint n, m, s, t;\n\nvoid solve(){\n  \n  int r = max_flow(s, t, INF);\n  int maxflow=r, cnt=0;\n    \n  for(int i=1;i<=n;i++){\n    \n    for(int j=0;j<G[i].size();j++){\n      \n      edge &s1 = G[i][j];\n      edge &t1 = G[s1.to][s1.rev];\n      \n      if(s1.s) continue;\n      if(t1.cap==1) continue;\n      \n      s1.cap=0;\n      \n      int f1=max_flow(s,s1.to,1);\n      \n      int f2=max_flow(i,t,1);\n      \n      if(f1&&f2){\n\tmaxflow=r+1;\n\tcnt++;\n      }\n      \n      if(f1) max_flow(s1.to,s,1);\n      \n      if(f2) max_flow(t,i,1);\n      \n      s1.cap=1;\n    }\n    \n  }\n\n  int revcnt=0;\n\n  if(r<maxflow) revcnt=cnt;\n  \n  cout<<maxflow<<' '<<revcnt<<endl;\n  \n}\n\nvoid init(){\n  for(int i=0;i<MAX_V;i++) G[i].clear();\n}\n\nint main(){\n\n  while(1){\n    \n    cin>>n>>m>>s>>t;\n    if(!n&&!m&&!s&&!t) break;\n\n    init();\n    \n    for(int i=0;i<m;i++){\n      int a, b;\n      cin>>a>>b;\n      add_edge(a,b,1);\n    }\n  \n    solve();\n  }\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\nstruct edge{int to,cap,rev;};\nconst int MAX_V=1000,inf=1e8;\nvector<edge> G[MAX_V];\nint level[MAX_V],iter[MAX_V],ord[MAX_V];\nint N,M,S,T,a[10000],b[10000];\nvoid add_edge(int from,int to,int cap,int i){\n\tedge e1={to,cap,G[to].size()},e2={from,0,G[from].size()};\n\tG[from].pb(e1);\n\tG[to].pb(e2);\n\tord[i]=G[from].size()-1;\n}\nvoid bfs(int s){\n\tmemset(level,-1,sizeof(level));\n\tqueue<int> que;\n\tlevel[s]=0;\n\tque.push(s);\n\twhile(!que.empty()){\n\t\tint v=que.front();\n\t\tque.pop();\n\t\trep(i,G[v].size()){\n\t\t\tedge &e=G[v][i];\n\t\t\tif(e.cap>0&&level[e.to]<0){\n\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\nint dfs(int v,int t,int f){\n\tif(v==t) return f;\n\tfor(int &i=iter[v];i<G[v].size();i++){\n\t\tedge &e=G[v][i];\n\t\tif(e.cap>0&&level[v]<level[e.to]){\n\t\t\tint d=dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0){\n\t\t\t\te.cap-=d;\n\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s,int t){\n\tint flow=0;\n\twhile(true){\n\t\tbfs(s);\n\t\tif(level[t]<0) return flow;\n\t\tmemset(iter,0,sizeof(iter));\n\t\tint f;\n\t\twhile((f=dfs(s,t,inf))>0) flow+=f;\n\t}\n}\nbool froms[MAX_V],tot[MAX_V];\nvoid dfs1(int v){//from s\n\tfroms[v]=1;\n\tfor(auto e:G[v]){\n\t\tif(e.cap<=0) continue;\n\t\tif(froms[e.to]) continue;\n\t\tdfs1(e.to);\n\t}\n}\nvoid dfs2(int v){//to t\n\ttot[v]=1;\n\tfor(auto e:G[v]){\n\t\tif(e.cap>0) continue;\n\t\tif(tot[e.to]) continue;\n\t\tdfs2(e.to);\n\t}\n}\nint main(){\n\twhile(true){\n\t\tcin>>N>>M>>S>>T;\n\t\tif(N==0) break;\n\t\trep(i,N) G[i].clear();\n\t\tS--,T--;\n\t\trep(i,M) cin>>a[i]>>b[i];\n\t\trep(i,M){\n\t\t\ta[i]--,b[i]--;\n\t\t\tadd_edge(a[i],b[i],1,i);\n\t\t}\n\t\tint f=max_flow(S,T);\n\t\tint cnt=0;\n\t\trep(i,N) froms[i]=0,tot[i]=0;\n\t\tdfs1(S);\n\t\tdfs2(T);\n\t\trep(i,M){\n\t\t\tif(G[a[i]][ord[i]].cap<1) continue;\n\t\t\tif(froms[b[i]]&&tot[a[i]]) cnt++;\n\t\t}\n\t\tif(cnt>0) f++;\n\t\tcout<<f<<\" \"<<cnt<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_V 1005\n#define INF 1e9\nusing namespace std;\n\n/*最大流(Dinic法) O(|E||V|^2)*/\n//辺を表す構造体(行き先、容量、逆辺)\nstruct edge{int to, cap, rev, s;};\nvector<edge> G[MAX_V]; //グラフの隣接リスト表現\nint level[MAX_V];      //sからの距離\nint iter[MAX_V];       //どこまで調べ終わったか\n//辺を表す構造体(行き先、容量、逆辺)\n\n//fromからtoへ向かう容量capの辺をグラフに追加する\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size(),0});\n  G[to].push_back((edge){from,0,(int)G[from].size()-1,1});  \n}\n\n//sからの最短距離をBFSで計算する\nvoid bfs(int s){\n  memset(level,-1,sizeof(level));\n  queue<int> que;\n  level[s] = 0;\n  que.push(s);\n  while(!que.empty()){\n    int v = que.front(); que.pop();\n    for(int i=0; i<G[v].size(); i++){\n      edge &e = G[v][i];\n      if(e.cap > 0 && level[e.to] < 0){\n\tlevel[e.to] = level[v] + 1;\n\tque.push(e.to);\n      }\n    }\n  }\n}\n\n//増加パスをDFSで探す。\nint dfs(int v,int t,int f){\n  if(v==t) return f;\n  for(int &i= iter[v]; i<G[v].size(); i++){\n    edge &e = G[v][i];\n    if(e.cap > 0 && level[v] < level[e.to]){\n      int d = dfs(e.to, t, min(f, e.cap));\n      if(d > 0){\n\te.cap -= d;\n\tG[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\n//sからtへの最大流を求める\nint max_flow(int s,int t,int maxf){\n  int flow=0;\n  for(;;){\n    bfs(s);\n    if(maxf==0||level[t] < 0) return flow;\n    memset(iter,0,sizeof(iter));\n    int f;\n    while((f=dfs(s ,t ,maxf)) > 0 ) flow += f, maxf-=f;\n  }\n}\n\nint n, m, s, t;\n\nvoid solve(){\n  \n  int r = max_flow(s, t, INF);\n  int maxflow=r;\n  \n  unordered_map<int,int> cnt;\n  \n  for(int i=1;i<=n;i++){\n    \n    for(int j=0;j<G[i].size();j++){\n      \n      edge &s1 = G[i][j];\n      edge &t1 = G[s1.to][s1.rev];\n      \n      if(s1.s) continue;\n      if(t1.cap==1) continue;\n      \n      s1.cap=0;\n      \n      int f1=max_flow(s,s1.to,1);\n\n      int f2=max_flow(i,t,1);\n      \n      int f=r;\n      \n      if(f1&&f2) f=r+1;\n      \n      if(f1) max_flow(s1.to,s,1);\n      \n      if(f2) max_flow(t,i,1);\n      \n      if(maxflow<f) maxflow=f;\n\n      cnt[f]++;\n\n      s1.cap=1;\n    }\n    \n  }\n\n  int revcnt=0;\n\n  if(r<maxflow){\n    for(pair<int,int> d : cnt)\n      if(maxflow==d.first) revcnt+=d.second;\n  }\n  \n  cout<<maxflow<<' '<<revcnt<<endl;\n  \n}\n\nvoid init(){\n  for(int i=0;i<MAX_V;i++) G[i].clear();\n}\n\nint main(){\n\n  while(1){\n    \n    cin>>n>>m>>s>>t;\n    if(!n&&!m&&!s&&!t) break;\n\n    init();\n    \n    for(int i=0;i<m;i++){\n      int a, b;\n      cin>>a>>b;\n      add_edge(a,b,1);\n    }\n  \n    solve();\n  }\n    \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\nstruct Dinic{\n  const int INF=1<<28;\n  \n  struct edge {\n    int to,cap,rev;\n    edge(){}\n    edge(int to,int cap,int rev):to(to),cap(cap),rev(rev){}\n  };\n\n  int n;\n  vector<vector<edge> > G;\n  vector<map<int,int> > M;\n  vector<int> level,iter;\n\n  Dinic(){}\n  Dinic(int sz):n(sz),G(n),M(n),level(n),iter(n){}\n  \n  void add_edge(int from,int to,int cap){\n    M[from][to]=G[from].size();\n    M[to][from]=G[to].size();\n    G[from].push_back(edge(to,cap,G[to].size()));\n    // undirected\n    //G[to].push_back(edge(from,cap,G[from].size()-1));\n    // directed\n    G[to].push_back(edge(from,0,G[from].size()-1));\n  }\n  \n  void bfs(int s){\n    fill(level.begin(),level.end(),-1);\n    queue<int> que;\n    level[s]=0;\n    que.push(s);\n    while(!que.empty()){\n      int v=que.front();que.pop();\n      for(int i=0;i<(int)G[v].size();i++){\n        edge &e = G[v][i];\n        if(e.cap>0&&level[e.to]<0){\n          level[e.to]=level[v]+1;\n          que.push(e.to);\n        }\n      }\n    }\n  }\n  \n  int dfs(int v,int t,int f){\n    if(v==t) return f;\n    for(int &i=iter[v];i<(int)G[v].size();i++){\n      edge &e=G[v][i];\n      if(e.cap>0&&level[v]<level[e.to]){\n        int d = dfs(e.to,t,min(f,e.cap));\n        if(d>0){\n          e.cap-=d;\n          G[e.to][e.rev].cap+=d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n  \n  int flow(int s,int t,int lim){\n    int fl=0;\n    for(;;){\n      bfs(s);\n      if(level[t]<0||lim==0) return fl;\n      fill(iter.begin(),iter.end(),0);\n      int f;\n      while((f=dfs(s,t,lim))>0){\n        fl+=f;\n        lim-=f;\n      }\n    }\n  }\n\n  int flow(int s,int t){\n    return flow(s,t,INF);\n  }\n\n  //cap==1 only\n  bool back_edge(int s,int t,int from, int to){\n    for(int i=0;i<(int)G[from].size();i++) {\n      edge& e=G[from][i];\n      if(e.to==to) {\n        if(e.cap==0&&flow(from,to,1)==0) {\n          flow(from,s,1);\n          flow(t,to,1);\n          return 1;\n        }\n      }\n    }\n    return 0;\n  }\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  int n,m,s,t;\n  while(cin>>n>>m>>s>>t,n){\n    vector<int> a(m),b(m);\n    for(int i=0;i<m;i++) cin>>a[i]>>b[i];\n    s--;t--;\n    for(int i=0;i<m;i++) a[i]--,b[i]--;\n\n    Dinic flow(n);\n    for(int i=0;i<m;i++)\n      flow.add_edge(a[i],b[i],1);\n    \n    int cur=flow.flow(s,t),res=cur,cnt=0;\n    auto &G=flow.G;\n    auto &M=flow.M;\n    \n    auto bfs=[&](int v,vector<int> &dp,int k){\n               dp.assign(n,0);\n               queue<int> q;\n               q.emplace(v);\n               dp[v]=1;\n               while(!q.empty()){\n                 v=q.front();q.pop();\n                 for(auto &e:G[v]){\n                   if(e.cap!=k||dp[e.to]) continue;\n                   dp[e.to]=1;\n                   q.emplace(e.to);\n                 }\n               }\n             };\n\n    vector<int> dp1,dp2;\n    bfs(s,dp1,1);\n    bfs(t,dp2,0);\n    \n    for(int i=0;i<m;i++){\n      int k=M[a[i]][b[i]];\n      //cout<<G[a[i]][k].cap<<\" \"<<dp1[b[i]]<<\" \"<<dp2[a[i]]<<endl;\n      if(G[a[i]][k].cap==0) continue;\n      if(dp1[b[i]]&&dp2[a[i]]) res=cur+1,cnt++;\n    }\n    \n    cout<<res<<\" \"<<cnt<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define INF 1e9\n#define MAX_V 10000\nusing namespace std;\n\ntypedef pair<int,int> P;\n\n//辺を表す構造体(行き先、容量、逆辺)\nstruct edge{int to, cap, rev, num;};\n\nvector<edge> G[MAX_V]; //グラフの隣接リスト\nbool used[MAX_V];      //DFSですでに調べたかのフラグ\n\nint t_idx[MAX_V];\n\n//fromからtoへ向かう容量capの辺をグラフに追加する\nvoid add_edge(int from,int to,int cap,int num){\n  t_idx[num] = to;\n  G[from].push_back((edge){to,cap,(int)G[to].size(),num});\n  G[to].push_back((edge){from,0,(int)G[from].size()-1,num});  \n}\n\n//増加パスをDFSで探す\nint dfs(int v,int t,int f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs(e.to ,t , min(f,e.cap));\n      if(d > 0){\n\te.cap -= d;\n\tG[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\n//sからtへの最大流を求める\nint max_flow(int s,int t){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s, t, INF);\n    if(f == 0)return flow;\n    flow += f;\n  }\n}\n\nint N, M, S, T;\nint used1[MAX_V], used2[MAX_V];\n\nvoid dfs1(int x){\n  \n  if( used1[x] ) return;\n  used1[x] = 1;\n  \n  for(edge nx : G[x] ){\n    \n    if( t_idx[nx.num] == x && nx.cap == 1 ) dfs1( nx.to );\n    \n    if( t_idx[nx.num] == nx.to && nx.cap == 1 ) dfs1( nx.to );\n    \n  }\n  \n}\n\nvoid dfs2(int x){\n  \n  if( used2[x] ) return;\n  used2[x] = 1;\n\n  for(edge nx : G[x] ){\n    \n    if( t_idx[nx.num] == x && nx.cap == 0 ) dfs2( nx.to );\n    \n    if( t_idx[nx.num] == nx.to && nx.cap == 0 ) dfs2( nx.to );\n    \n  }\n  \n}\n\nsigned main(){\n\n  while(1){\n  \n    cin>>N>>M>>S>>T;\n    if( !N && !M && !S && !T ) break;\n    \n    S--, T--;\n    \n    for(int i=0;i<N;i++) G[i].clear();\n    \n    for(int i=0;i<M;i++){\n      int a, b;\n      cin>>a>>b;\n      add_edge( a-1, b-1, 1, i );\n    }\n    \n    int ans = max_flow( S, T ), cnt = 0;\n    \n    memset( used1, 0, sizeof(used1) );\n    memset( used2, 0, sizeof(used2) );\n    \n    dfs1(S);\n  \n    dfs2(T);\n  \n    for(int i=0;i<N;i++){\n    \n      for(edge ni : G[i] ){\n      \n\tif( used2[i] && used1[ni.to] && t_idx[ni.num] == ni.to && ni.cap == 1 ) cnt++;\n      \n      }\n    \n    }\n  \n    if( cnt ) ans++;\n  \n    cout<<ans<<' '<<cnt<<endl;\n  \n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\n#define MAX_V 10000\nusing namespace std;\n\n/*?????§?????¢?????´?????????(Ford_Fulerson????????¨)???O(F|E|)*/\n\n//????????¨????§???????(???????????????????????????)\nstruct edge{int to, cap, rev, s;};\n\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size(),0});\n  G[to].push_back((edge){from,0,(int)G[from].size()-1,1});  \n}\n\n//?¢?????????????DFS??§??¢???\nint dfs(int v,int t,int f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs(e.to ,t , min(f,e.cap));\n      if(d > 0){\n\te.cap -= d;\n\tG[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\n//s??????t???????????§???????±???????\nint max_flow(int s,int t,int maxf){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s, t, maxf);\n    if(f == 0)return flow;\n    maxf-=f;\n    flow += f;\n  }\n}\n\nint n, m, s, t;\n\nvoid solve(){\n  \n  int r = max_flow(s, t, INF);\n  int maxflow=r;\n  \n  unordered_map<int,int> cnt;\n  \n  for(int i=1;i<=n;i++){\n    \n    for(int j=0;j<G[i].size();j++){\n      \n      edge &s1 = G[i][j];\n      edge &t1 = G[s1.to][s1.rev];\n      \n      if(s1.s) continue;\n      if(t1.cap==1) continue;\n      \n      int f1=max_flow(s,s1.to,1);\n      \n      int f2=max_flow(i,t,1);\n      \n      int f=r;\n      \n      if(f1&&f2) f=r+1;\n      \n      if(f1) max_flow(s1.to,s,1);\n      \n      if(f2) max_flow(t,i,1);\n      \n      if(maxflow<f) maxflow=f;\n      \n      cnt[f]++;\n      \n    }\n    \n  }\n\n  int revcnt=0;\n\n  if(r<maxflow){\n    for(pair<int,int> d : cnt)\n      if(maxflow==d.first) revcnt+=d.second;\n  }\n  \n  cout<<maxflow<<' '<<revcnt<<endl;\n  \n}\n\nvoid init(){\n  for(int i=0;i<MAX_V;i++) G[i].clear();\n}\n\nint main(){\n\n  while(1){\n    \n    cin>>n>>m>>s>>t;\n    if(!n&&!m&&!s&&!t) break;\n\n    init();\n    \n    for(int i=0;i<m;i++){\n      int a, b;\n      cin>>a>>b;\n      add_edge(a,b,1);\n    }\n  \n    solve();\n  }\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) cerr << #x << \" = \" << (x) << endl\nusing namespace std;\nconstexpr int INF = 1 << 30;\ntemplate <typename Functor>\nstruct fix_type\n{\n    Functor functor;\n    template <typename... Args>\n    decltype(auto) operator()(Args&&... args) const& { return functor(functor, std::forward<Args>(args)...); }\n};\ntemplate <typename Functor>\nfix_type<typename std::decay<Functor>::type> fix(Functor&& functor) { return {std::forward<Functor>(functor)}; }\nclass Flow\n{\npublic:\n    struct Edge\n    {\n        int from, to, reverse, capacity, flow;\n        const bool is_reverse;\n    };\n    Flow(const int v) : V{v}, edge(v) {}\n    void addEdge(const int from, const int to, const int capacity)\n    {\n        edge[from].push_back(Edge{from, to, (int)edge[to].size(), capacity, 0, false});\n        edge[to].push_back(Edge{to, from, (int)edge[from].size() - 1, capacity, capacity, true});\n    }\n    int FordFulkerson(const int s, const int t)\n    {\n        vector<bool> checked(V);\n        auto dfs = fix([&](auto&& self, const int pos, const int flow) -> int {\n            if (pos == t) { return flow; }\n            checked[pos] = true;\n            for (auto& e : edge[pos]) {\n                if (not checked[e.to]) {\n                    const int res = e.capacity - e.flow;\n                    if (res > 0) {\n                        const int d = self(self, e.to, min(flow, res));\n                        if (d > 0) {\n                            e.flow += min(d, res);\n                            edge[e.to][e.reverse].flow -= min(d, res);\n                            return d;\n                        }\n                    }\n                }\n            }\n            return 0;\n        });\n        int flow = 0;\n        while (true) {\n            for (int i = 0; i < V; i++) { checked[i] = false; }\n            const int f = dfs(s, INF);\n            if (f == 0) { break; }\n            flow += f;\n        }\n        return flow;\n    }\n    const int V;\n    vector<vector<Edge>> edge;\n};\nstruct Graph\n{\n    Graph(const int v) : V{v}, edge(v), rev_edge(v) {}\n    void addEdge(const int from, const int to)\n    {\n        edge[from].push_back(to);\n        rev_edge[to].push_back(from);\n    }\n    const int V;\n    vector<vector<int>> edge;\n    vector<vector<int>> rev_edge;\n};\n\nint main()\n{\n    while (true) {\n        int N, M, S, T;\n        cin >> N >> M >> S >> T;\n        if (N == 0 and M == 0 and S == 0 and T == 0) { break; }\n        Flow f(N);\n        using P = pair<int, int>;\n        for (int i = 0; i < M; i++) {\n            int a, b;\n            cin >> a >> b;\n            f.addEdge(a - 1, b - 1, 1);\n        }\n        const int F = f.FordFulkerson(S - 1, T - 1);\n        Graph g(N);\n        vector<P> E;\n        for (int i = 0; i < N; i++) {\n            for (const auto& e : f.edge[i]) {\n                if (not e.is_reverse) {\n                    e.flow == 0 ? g.addEdge(e.from, e.to) : g.addEdge(e.to, e.from);\n                    if (e.flow == 0) { E.push_back({e.from, e.to}); }\n                }\n            }\n        }\n        vector<bool> U(N, false), V(N, false);\n        queue<int> q1;\n        q1.push(S - 1), U[S - 1] = true;\n        while (not q1.empty()) {\n            const int p = q1.front();\n            q1.pop();\n            for (const int to : g.edge[p]) {\n                if (U[to]) { continue; }\n                U[to] = true, q1.push(to);\n            }\n        }\n        queue<int> q2;\n        q2.push(T - 1), V[T - 1] = true;\n        while (not q2.empty()) {\n            const int p = q2.front();\n            q2.pop();\n            for (const int to : g.rev_edge[p]) {\n                if (V[to]) { continue; }\n                V[to] = true, q2.push(to);\n            }\n        }\n\n        int ans = 0;\n        for (const auto& e : E) {\n            if (U[e.second] and V[e.first]) { ans++; }\n        }\n        cout << (F + (ans > 0 ? 1 : 0)) << \" \" << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\n#define MAX_V 10000\nusing namespace std;\n\n/*?????§?????¢?????´?????????(Ford_Fulerson????????¨)???O(F|E|)*/\n\n//????????¨????§???????(???????????????????????????)\nstruct edge{int to, cap, rev, s;};\n\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size(),0});\n  G[to].push_back((edge){from,0,(int)G[from].size()-1,1});  \n}\n\n//?¢?????????????DFS??§??¢???\nint dfs(int v,int t,int f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs(e.to ,t , min(f,e.cap));\n      if(d > 0){\n\te.cap -= d;\n\tG[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\n//s??????t???????????§???????±???????\nint max_flow(int s,int t,int maxf){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s, t, maxf);\n    if(f == 0)return flow;\n    maxf-=f;\n    flow += f;\n  }\n}\n\nint n, m, s, t;\n\nvoid solve(){\n  \n  int r = max_flow(s, t, INF);\n  int maxflow=r;\n  \n  map<int,int> cnt;\n  \n  for(int i=1;i<=n;i++){\n    \n    for(int j=0;j<G[i].size();j++){\n      \n      edge &s1 = G[i][j];\n      edge &t1 = G[s1.to][s1.rev];\n      \n      if(s1.s) continue;\n      \n      int rev=t1.cap, f=r-rev;\n      \n      s1.cap=t1.cap=0;\n      \n      max_flow(t,s1.to,rev);\n\n      max_flow(i,s,rev);\n\n      t1.cap=1;\n      \n      f+=max_flow(s,t,1);\n      \n      if(maxflow<f) maxflow=f;\n      \n      cnt[f]++;\n      \n      rev=max(0,f-r);\n      \n      s1.cap=t1.cap=0;\n      \n      max_flow(s1.to,s,rev);\n      \n      max_flow(t,i,rev);\n      \n      s1.cap=1;\n            \n      max_flow(s,t,1);\n      \n    }\n    \n  }\n\n  int revcnt=0;\n\n  if(r<maxflow){\n    for(pair<int,int> d : cnt)\n      if(maxflow==d.first) revcnt+=d.second;\n  }\n  \n  cout<<maxflow<<' '<<revcnt<<endl;\n  \n}\n\nvoid init(){\n  for(int i=0;i<MAX_V;i++) G[i].clear();\n}\n\nint main(){\n\n  while(1){\n    \n    cin>>n>>m>>s>>t;\n    if(!n&&!m&&!s&&!t) break;\n\n    init();\n    \n    for(int i=0;i<m;i++){\n      int a, b;\n      cin>>a>>b;\n      add_edge(a,b,1);\n    }\n  \n    solve();\n  }\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) cerr << #x << \" = \" << (x) << endl\nusing namespace std;\nconstexpr int INF = 1 << 30;\ntemplate <typename Functor>\nstruct fix_type\n{\n    Functor functor;\n    template <typename... Args>\n    decltype(auto) operator()(Args&&... args) const& { return functor(functor, std::forward<Args>(args)...); }\n};\ntemplate <typename Functor>\nfix_type<typename std::decay<Functor>::type> fix(Functor&& functor) { return {std::forward<Functor>(functor)}; }\nclass Flow\n{\npublic:\n    struct Edge\n    {\n        int from, to, reverse, capacity, flow;\n        const bool is_reverse;\n    };\n    Flow(const int v) : V{v}, edge(v) {}\n    void addEdge(const int from, const int to, const int capacity)\n    {\n        edge[from].push_back(Edge{from, to, (int)edge[to].size(), capacity, 0, false});\n        edge[to].push_back(Edge{to, from, (int)edge[from].size() - 1, capacity, capacity, true});\n    }\n    int FordFulkerson(const int s, const int t)\n    {\n        vector<bool> checked(V);\n        auto dfs = fix([&](auto&& self, const int pos, const int flow) -> int {\n            if (pos == t) { return flow; }\n            checked[pos] = true;\n            for (auto& e : edge[pos]) {\n                if (not checked[e.to]) {\n                    const int res = e.capacity - e.flow;\n                    if (res > 0) {\n                        const int d = self(self, e.to, min(flow, res));\n                        if (d > 0) {\n                            e.flow += min(d, res);\n                            edge[e.to][e.reverse].flow -= min(d, res);\n                            return d;\n                        }\n                    }\n                }\n            }\n            return 0;\n        });\n        int flow = 0;\n        while (true) {\n            for (int i = 0; i < V; i++) { checked[i] = false; }\n            const int f = dfs(s, INF);\n            if (f == 0) { break; }\n            flow += f;\n        }\n        return flow;\n    }\n    const int V;\n    vector<vector<Edge>> edge;\n};\nstruct Graph\n{\n    Graph(const int v) : V{v}, edge(v), rev_edge(v) {}\n    void addEdge(const int from, const int to)\n    {\n        edge[from].push_back(to);\n        rev_edge[to].push_back(from);\n    }\n    const int V;\n    vector<vector<int>> edge;\n    vector<vector<int>> rev_edge;\n};\n\nint main()\n{\n    while (true) {\n        int N, M, S, T;\n        cin >> N >> M >> S >> T;\n        if (N == 0 and M == 0 and S == 0 and T == 0) { break; }\n        Flow f(N);\n        using P = pair<int, int>;\n        for (int i = 0; i < M; i++) {\n            int a, b;\n            cin >> a >> b;\n            f.addEdge(a - 1, b - 1, 1);\n        }\n        const int F = f.FordFulkerson(S - 1, T - 1);\n        Graph g(N);\n        vector<P> E;\n        for (int i = 0; i < N; i++) {\n            for (const auto& e : f.edge[i]) {\n                if (not e.is_reverse) {\n                    e.flow == 0 ? g.addEdge(e.from, e.to) : g.addEdge(e.to, e.from);\n                    if (e.flow == 0) { E.push_back({e.from, e.to}); }\n                }\n            }\n        }\n        vector<bool> U(N, false), V(N, false);\n        queue<int> q1;\n        q1.push(S - 1), U[S - 1] = true;\n        while (not q1.empty()) {\n            const int p = q1.front();\n            for (const int to : g.edge[p]) {\n                if (U[to]) { continue; }\n                U[to] = true, q1.push(to);\n            }\n        }\n        queue<int> q2;\n        q2.push(T - 1), V[T - 1] = true;\n        while (not q2.empty()) {\n            const int p = q2.front();\n            for (const int to : g.rev_edge[p]) {\n                if (V[to]) { continue; }\n                V[to] = true, q2.push(to);\n            }\n        }\n\n        int ans = 0;\n        for (const auto& e : E) {\n            if (U[e.second] and V[e.first]) { ans++; }\n        }\n        cout << (F + (ans > 0 ? 1 : 0)) << \" \" << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\n#define MAX_V 10000\nusing namespace std;\n\n/*?????§?????¢?????´?????????(Ford_Fulerson????????¨)???O(F|E|)*/\n\n//????????¨????§???????(???????????????????????????)\nstruct edge{int to, cap, rev, s;};\n\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size(),0});\n  G[to].push_back((edge){from,0,(int)G[from].size()-1,1});  \n}\n\n//?¢?????????????DFS??§??¢???\nint dfs(int v,int t,int f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs(e.to ,t , min(f,e.cap));\n      if(d > 0){\n\te.cap -= d;\n\tG[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\n//s??????t???????????§???????±???????\nint max_flow(int s,int t,int maxf){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s, t, maxf);\n    if(f == 0)return flow;\n    maxf-=f;\n    flow += f;\n  }\n}\n\nint n, m, s, t;\n\nvoid solve(){\n  \n  int r = max_flow(s, t, INF);\n  int maxflow=r;\n  \n  map<int,int> cnt;\n  \n  for(int i=1;i<=n;i++){\n    \n    for(int j=0;j<G[i].size();j++){\n      \n      edge &s1 = G[i][j];\n      edge &t1 = G[s1.to][s1.rev];\n      \n      if(s1.s) continue;\n      \n      int rev=t1.cap, f=r-rev;\n      \n      s1.cap=t1.cap=0;\n      \n      max_flow(t,s1.to,rev);\n\n      max_flow(i,s,rev);\n\n      t1.cap=1;\n      \n      f+=max_flow(s,t,INF);\n      \n      if(maxflow<f) maxflow=f;\n      \n      cnt[f]++;\n      \n      rev=max(0,f-r);\n      \n      s1.cap=t1.cap=0;\n      \n      max_flow(s1.to,s,rev);\n      \n      max_flow(t,i,rev);\n      \n      s1.cap=1;\n            \n      max_flow(s,t,INF);\n      \n    }\n    \n  }\n\n  int revcnt=0;\n\n  if(r<maxflow){\n    for(pair<int,int> d : cnt)\n      if(maxflow==d.first) revcnt+=d.second;\n  }\n  \n  cout<<maxflow<<' '<<revcnt<<endl;\n  \n}\n\nvoid init(){\n  for(int i=0;i<MAX_V;i++) G[i].clear();\n}\n\nint main(){\n\n  while(1){\n    \n    cin>>n>>m>>s>>t;\n    if(!n&&!m&&!s&&!t) break;\n\n    init();\n    \n    for(int i=0;i<m;i++){\n      int a, b;\n      cin>>a>>b;\n      add_edge(a,b,1);\n    }\n  \n    solve();\n  }\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) cerr << #x << \" = \" << (x) << endl\nusing namespace std;\nusing ll = long long;\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 16;\ntemplate <typename Functor>\nstruct fix_type\n{\n    Functor functor;\n    template <typename... Args>\n    decltype(auto) operator()(Args&&... args) const& { return functor(functor, std::forward<Args>(args)...); }\n};\ntemplate <typename Functor>\nfix_type<typename std::decay<Functor>::type> fix(Functor&& functor) { return {std::forward<Functor>(functor)}; }\nclass Flow\n{\npublic:\n    using T = ll;\n    struct Edge\n    {\n        int from;\n        int to;\n        int reverse;\n        T capacity;\n        T flow;\n        const bool is_reverse;\n    };\n    Flow(const int v) : V{v}, edge(v) {}\n    void addEdge(const int from, const int to, const T capacity)\n    {\n        edge[from].push_back(Edge{from, to, (int)edge[to].size(), capacity, 0, false});\n        edge[to].push_back(Edge{to, from, (int)edge[from].size() - 1, capacity, capacity, true});\n    }\n    T FordFulkerson(const int s, const int t)\n    {\n        vector<bool> checked(V);\n        auto dfs = fix([&](auto&& self, const int pos, const T& flow) -> T {\n            if (pos == t) { return flow; }\n            checked[pos] = true;\n            for (auto& e : edge[pos]) {\n                if (not checked[e.to]) {\n                    const T res = e.capacity - e.flow;\n                    if (res > 0) {\n                        const T d = self(self, e.to, min(flow, res));\n                        if (d > 0) {\n                            e.flow += min(d, res);\n                            edge[e.to][e.reverse].flow -= min(d, res);\n                            return d;\n                        }\n                    }\n                }\n            }\n            return 0;\n        });\n        T flow = 0;\n        while (true) {\n            for (int i = 0; i < V; i++) { checked[i] = false; }\n            const T f = dfs(s, INF<T>);\n            if (f == 0) { break; }\n            flow += f;\n        }\n        return flow;\n    }\n    const int V;\n    vector<vector<Edge>> edge;\n};\nstruct Graph\n{\n    Graph(const int v) : V{v}, edge(v), rev_edge(v) {}\n    void addEdge(const int from, const int to)\n    {\n        edge[from].push_back(to);\n        rev_edge[to].push_back(from);\n    }\n    const int V;\n    vector<vector<int>> edge;\n    vector<vector<int>> rev_edge;\n};\n\nint main()\n{\n    while (true) {\n        int N, M, S, T;\n        cin >> N >> M >> S >> T;\n        if (N == 0 and M == 0 and S == 0 and T == 0) { break; }\n        Flow f(N);\n        using P = pair<int, int>;\n        for (int i = 0; i < M; i++) {\n            int a, b;\n            cin >> a >> b;\n            f.addEdge(a - 1, b - 1, 1);\n        }\n        const int F = f.FordFulkerson(S - 1, T - 1);\n        Graph g(N);\n        vector<P> E;\n        for (int i = 0; i < N; i++) {\n            for (const auto& e : f.edge[i]) {\n                if (not e.is_reverse) {\n                    e.flow == 0 ? g.addEdge(e.from, e.to) : g.addEdge(e.to, e.from);\n                    if (e.flow == 0) { E.push_back({e.from, e.to}); }\n                }\n            }\n        }\n        auto dijk = [&](const int s, const bool rev) -> vector<int> {\n            vector<int> ans(N, INF<int>);\n            priority_queue<P, vector<P>, greater<P>> q;\n            ans[s] = 0;\n            q.push(make_pair(0, s));\n            while (not q.empty()) {\n                const P& p = q.top();\n                const int cost = p.first;\n                const int v = p.second;\n                q.pop();\n                if (ans[v] < cost) { continue; }\n                for (const int to : (rev ? g.rev_edge[v] : g.edge[v])) {\n                    if (ans[to] > ans[v] + 1) {\n                        ans[to] = ans[v] + 1;\n                        q.push(make_pair(ans[to], to));\n                    }\n                }\n            }\n            return ans;\n        };\n        const auto d = dijk(S - 1, false);\n        const auto revd = dijk(T - 1, true);\n        int ans = 0;\n        for (const auto& e : E) {\n            if (d[e.second] != INF<int> and revd[e.first] != INF<int>) { ans++; }\n        }\n        cout << (F + (ans > 0 ? 1 : 0)) << \" \" << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\n#define MAX_V 1001\nusing namespace std;\ntypedef map<int,int> M;\nM G[MAX_V],rG[MAX_V],g[MAX_V];\nbool used[MAX_V];  \nvoid add_edge(int from,int to,int cap){G[from][to]+=cap;}\n\nint dfs(int v,int t,int f){\n  if(v == t)return f;\n  used[v]=true;\n  \n  for(M::iterator it=G[v].begin();it!=G[v].end() ;it++){\n    int to=it->first;\n    int &cap=it->second;\n    if(!used[to] && cap > 0){\n      int d = dfs(to ,t , min(f,cap));\n      if(d > 0){\n\tcap -= d;\n\tG[to][v]+=d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s, t, INF);\n    if(f == 0)return flow;\n    flow += f;\n  }\n}\n\n\nint visited[MAX_V];\nvoid visit(int pos){\n  if(visited[pos])return;\n  visited[pos]=1;\n  for(M::iterator it=rG[pos].begin();it!=rG[pos].end() ;it++){\n    int to=it->first,cap=it->second;\n    if(cap)visit(to);\n  }\n}\n\nint check2(int pos,int t){\n  if(used[pos]++) return 0;\n  int res=0; \n  for(M::iterator it=G[pos].begin();it!=G[pos].end() ;it++){\n    int to=it->first,cap=it->second;\n    if(cap)res+=check2(to,t);\n  }\n  \n  for(M::iterator it=g[pos].begin();it!=g[pos].end() ;it++){\n    int to=it->first,cap=it->second;\n    if(cap) res+=cap*visited[to];\n  }\n  return res;\n}\n\nint main(){\n  while(1){\n    int n,m,s,t;\n    cin>>n>>m>>s>>t;\n    if(!n&&!m&&!s&&!t)break;\n    s--,t--;\n    for(int i=0;i<MAX_V;i++) rG[i].clear(),G[i].clear(),g[i].clear();\n    \n    int A[10000],B[10000];\n    for(int i=0;i<m;i++){\n      cin>>A[i]>>B[i];\n      A[i]--,B[i]--;\n      G[A[i]][B[i]]++;\n      g[B[i]][A[i]]++;\n    }\n\n    int mx=max_flow(s,t);\n    \n    memset(visited,0,sizeof(visited));\n    memset(used,0,sizeof(used));\n    for(int i=0;i<n;i++)\n      for(M::iterator it=G[i].begin();it!=G[i].end() ;it++){\n\tint to=it->first,cap=it->second;\n\trG[to][i]=cap;\n      }\n    \n    visit(t);\n    int cnt=check2(s,t);\n    cout<<mx+(cnt>0)<<\" \"<<cnt<<endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<int(n);++i)\n#define MAX_V 10000\nint V;\n\nusing Weight = int;\n\nconst Weight INF = 1000000000;\n// const Weight eps = 1e-8;\n\nstruct Edge{\n  int src, dest;\n  int cap, rev;\n  bool isReal;\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\nint d[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(Graph &g, int src, int dest, int cap) {\n  g[src].push_back((Edge){src, dest, cap, (int)g[dest].size(),true});\n  g[dest].push_back((Edge){dest, src, 0, (int)g[src].size() - 1,false});\n}\n\nvoid bfs(Graph &g, int s) {\n  memset(d, -1, sizeof(d));\n  queue<int> que;\n  d[s] = 0;\n  que.push(s);\n  while(!que.empty()) {\n    int v = que.front(); que.pop();\n    REP(i, g[v].size()) {\n      Edge &e = g[v][i];\n      if (e.cap > 0 && d[e.dest] < 0) {\n        d[e.dest] = d[v] + 1;\n        que.push(e.dest);\n      }\n    }\n  }\n}\n\nint dfs(Graph &g, int v, int t, int f) {\n  if (v == t) return f;\n  for (int &i = iter[v]; i < g[v].size(); i++) {\n    Edge &e = g[v][i];\n    if (e.cap > 0 && d[v] < d[e.dest]) {\n      int d = dfs(g, e.dest, t, min(f, e.cap));\n      if (d > 0) {\n        e.cap -= d;\n        g[e.dest][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(Graph& g, int s, int t) {\n  int flow = 0;\n  for (;;) {\n    bfs(g, s);\n    if (d[t] < 0) return flow;\n    memset(iter, 0, sizeof(iter));\n    int f;\n    while ((f = dfs(g, s, t, INF)) > 0) flow += f;\n  }\n}\nint main(){\n  int n,m,s,t;\n  while(cin>>n>>m>>s>>t,n){\n    s--,t--;\n    vector<int> a(m),b(m);\n    for(int i=0;i<m;i++){\n      cin>>a[i]>>b[i];\n      a[i]--,b[i]--;\n    }\n    Graph g(n);\n    for(int i=0;i<m;i++){\n      add_edge(g,a[i],b[i],1);\n    }\n\n    int f=max_flow(g,s,t);\n\n    vector<int> ca,cb;\n\n    \n    function<void(int,Graph&,vector<int>&)> mydfs=[&](int v,Graph &graph,vector<int>& used){\n      if(used[v]) return;\n      used[v]=true;\n      for(int i=0;i<graph[v].size();i++) if(graph[v][i].cap>0) mydfs(graph[v][i].dest,graph,used);\n      return;\n    };\n    vector<int> sside(n);\n    mydfs(s,g,sside);\n\n    for(int i=0;i<n;i++){\n      for(int j=0;j<g[i].size();j++){\n\tif(!g[i][j].isReal) continue;\n\tif(!sside[i] && sside[g[i][j].dest]){\n\t  ca.push_back(g[i][j].dest);\n\t  cb.push_back(i);\n\t}\n      }\n    }\n    int res=0;\n    for(int i=0;i<ca.size();i++){\n      int aa=ca[i],bb=cb[i];\n\tGraph newg=g;\n\tadd_edge(newg,aa,bb,1);\n\tint f2=max_flow(newg,s,t);\n\tif(f2>0) res++;\n    }\n    if(res==0){\n      cout<<f<<\" \"<<0<<endl;\n    }\n    else{\n      cout<<f+1<<\" \"<<res<<endl;\n    }\n    \n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\nstruct Dinic{\n  const int INF=1<<28;\n  \n  struct edge {\n    int to,cap,rev;\n    edge(){}\n    edge(int to,int cap,int rev):to(to),cap(cap),rev(rev){}\n  };\n\n  int n;\n  vector<vector<edge> > G;\n  vector<map<int,int> > M;\n  vector<int> level,iter;\n\n  Dinic(){}\n  Dinic(int sz):n(sz),G(n),M(n),level(n),iter(n){}\n  \n  void add_edge(int from,int to,int cap){\n    M[from][to]=G[from].size();\n    M[to][from]=G[to].size();\n    G[from].push_back(edge(to,cap,G[to].size()));\n    // undirected\n    //G[to].push_back(edge(from,cap,G[from].size()-1));\n    // directed\n    G[to].push_back(edge(from,0,G[from].size()-1));\n  }\n  \n  void bfs(int s){\n    fill(level.begin(),level.end(),-1);\n    queue<int> que;\n    level[s]=0;\n    que.push(s);\n    while(!que.empty()){\n      int v=que.front();que.pop();\n      for(int i=0;i<(int)G[v].size();i++){\n        edge &e = G[v][i];\n        if(e.cap>0&&level[e.to]<0){\n          level[e.to]=level[v]+1;\n          que.push(e.to);\n        }\n      }\n    }\n  }\n  \n  int dfs(int v,int t,int f){\n    if(v==t) return f;\n    for(int &i=iter[v];i<(int)G[v].size();i++){\n      edge &e=G[v][i];\n      if(e.cap>0&&level[v]<level[e.to]){\n        int d = dfs(e.to,t,min(f,e.cap));\n        if(d>0){\n          e.cap-=d;\n          G[e.to][e.rev].cap+=d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n  \n  int flow(int s,int t,int lim){\n    int fl=0;\n    for(;;){\n      bfs(s);\n      if(level[t]<0||lim==0) return fl;\n      fill(iter.begin(),iter.end(),0);\n      int f;\n      while((f=dfs(s,t,lim))>0){\n        fl+=f;\n        lim-=f;\n      }\n    }\n  }\n\n  int flow(int s,int t){\n    return flow(s,t,INF);\n  }\n\n  //cap==1 only\n  bool back_edge(int s,int t,int from, int to){\n    for(int i=0;i<(int)G[from].size();i++) {\n      edge& e=G[from][i];\n      if(e.to==to) {\n        if(e.cap==0&&flow(from,to,1)==0) {\n          flow(from,s,1);\n          flow(t,to,1);\n          return 1;\n        }\n      }\n    }\n    return 0;\n  }\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  int n,m,s,t;\n  while(cin>>n>>m>>s>>t,n){\n    vector<int> a(m),b(m);\n    for(int i=0;i<m;i++) cin>>a[i]>>b[i];\n    s--;t--;\n    for(int i=0;i<m;i++) a[i]--,b[i]--;\n\n    auto calc=[&](int k)->int{\n                Dinic G(n);\n                for(int i=0;i<m;i++){\n                  if(i==k) G.add_edge(b[i],a[i],1);\n                  else G.add_edge(a[i],b[i],1);\n                }\n                return G.flow(s,t);\n              };\n    \n    int cur=calc(-1),res=cur,cnt=0;\n    for(int i=0;i<m;i++){\n      int tmp=calc(i);\n      if(tmp>cur){\n        res=tmp;\n        cnt++;\n      }\n    }\n    cout<<res<<\" \"<<cnt<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\nstruct edge{int to,cap,rev;};\nconst int MAX_V=1000,inf=1e8;\nvector<edge> G[MAX_V];\nint level[MAX_V],iter[MAX_V],ord[MAX_V];\nint N,M,S,T,a[10000],b[10000];\nvoid add_edge(int from,int to,int cap,int i){\n\tedge e1=edge{to,cap,G[to].size()},e2=edge{from,0,G[from].size()};\n\tG[from].pb(e1);\n\tG[to].pb(e2);\n\tord[i]=G[from].size()-1;\n}\nvoid bfs(int s){\n\tmemset(level,-1,sizeof(level));\n\tqueue<int> que;\n\tlevel[s]=0;\n\tque.push(s);\n\twhile(!que.empty()){\n\t\tint v=que.front();\n\t\tque.pop();\n\t\trep(i,G[v].size()){\n\t\t\tedge &e=G[v][i];\n\t\t\tif(e.cap>0&&level[e.to]<0){\n\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\nint dfs(int v,int t,int f){\n\tif(v==t) return f;\n\tfor(int &i=iter[v];i<G[v].size();i++){\n\t\tedge &e=G[v][i];\n\t\tif(e.cap>0&&level[v]<level[e.to]){\n\t\t\tint d=dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0){\n\t\t\t\te.cap-=d;\n\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s,int t){\n\tint flow=0;\n\twhile(true){\n\t\tbfs(s);\n\t\tif(level[t]<0) return flow;\n\t\tmemset(iter,0,sizeof(iter));\n\t\tint f;\n\t\twhile((f=dfs(s,t,inf))>0) flow+=f;\n\t}\n}\nbool froms[MAX_V],tot[MAX_V];\nvoid dfs1(int v){//from s\n\tfroms[v]=1;\n\tfor(auto e:G[v]){\n\t\tif(e.cap<=0) continue;\n\t\tif(froms[e.to]) continue;\n\t\tdfs1(e.to);\n\t}\n}\nvoid dfs2(int v){//to t\n\ttot[v]=1;\n\tfor(auto e:G[v]){\n\t\tif(e.cap>0) continue;\n\t\tif(tot[e.to]) continue;\n\t\tdfs2(e.to);\n\t}\n}\nint main(){\n\twhile(true){\n\t\tcin>>N>>M>>S>>T;\n\t\tif(N==0) break;\n\t\trep(i,N) G[i].clear();\n\t\tS--,T--;\n\t\trep(i,M) cin>>a[i]>>b[i];\n\t\trep(i,M){\n\t\t\ta[i]--,b[i]--;\n\t\t\tadd_edge(a[i],b[i],1,i);\n\t\t}\n\t\tint f=max_flow(S,T);\n\t\tint cnt=0;\n\t\trep(i,N) froms[i]=0,tot[i]=0;\n\t\tdfs1(S);\n\t\tdfs2(T);\n\t\trep(i,M){\n\t\t\tif(G[a[i]][ord[i]].cap<1) continue;\n\t\t\tif(froms[b[i]]&&tot[a[i]]) cnt++;\n\t\t}\n\t\tif(cnt>0) f++;\n\t\tcout<<f<<\" \"<<cnt<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\n#define MAX_V 10000\nusing namespace std;\n\n/*?????§?????¢?????´?????????(Ford_Fulerson????????¨)???O(F|E|)*/\n\n//????????¨????§???????(???????????????????????????)\nstruct edge{int to, cap, rev, s;};\n\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size(),0});\n  G[to].push_back((edge){from,0,(int)G[from].size()-1,1});  \n}\n\n//?¢?????????????DFS??§??¢???\nint dfs(int v,int t,int f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs(e.to ,t , min(f,e.cap));\n      if(d > 0){\n\te.cap -= d;\n\tG[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\n//s??????t???????????§???????±???????\nint max_flow(int s,int t,int maxf){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s, t, maxf);\n    if(f == 0)return flow;\n    maxf-=f;\n    flow += f;\n  }\n}\n\nint n, m, s, t;\n\nvoid solve(){\n  \n  int r = max_flow(s, t, INF);\n  int maxflow=r;\n  \n  map<int,int> cnt;\n  \n  for(int i=1;i<=n;i++){\n    \n    for(int j=0;j<G[i].size();j++){\n      \n      edge &s1 = G[i][j];\n      edge &t1 = G[s1.to][s1.rev];\n      \n      if(s1.s) continue;\n      \n      int rev=t1.cap, f=r-rev;\n      \n      s1.cap=t1.cap=0;\n      \n      max_flow(t,s1.to,rev);\n\n      max_flow(i,s,rev);\n\n      t1.cap=1;\n      \n      f+=max_flow(s,t,INF);\n      \n      if(maxflow<f) maxflow=f;\n      \n      cnt[f]++;\n      \n      rev=max(0,f-r);\n      \n      s1.cap=t1.cap=0;\n      \n      max_flow(s1.to,s,rev);\n      \n      max_flow(t,i,rev);\n      \n      s1.cap=1;\n            \n      max_flow(s,t,INF);\n      \n    }\n    \n  }\n\n  int revcnt=0;\n\n  if(r<maxflow){\n    for(pair<int,int> d : cnt)\n      if(maxflow==d.first) revcnt+=d.second;\n  }\n  \n  cout<<maxflow<<' '<<revcnt<<endl;\n  \n}\n\nvoid init(){\n  for(int i=0;i<MAX_V;i++) G[i].clear();\n}\n\nint main(){\n\n  while(1){\n    \n    cin>>n>>m>>s>>t;\n    if(!n&&!m&&!s&&!t) break;\n\n    init();\n    \n    for(int i=0;i<m;i++){\n      int a, b;\n      cin>>a>>b;\n      add_edge(a,b,1);\n    }\n  \n    solve();\n  }\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_V 10000\n#define INF 1e9\nusing namespace std;\n\n/*????°??????¨???(???????????£????????????????????¨) O(F|V||E|)*/\n\n//????????¨????§???????(???????????????????????????????????????)\nstruct edge{int to, cap,cost,rev;};\nint V;                         //????????°\nvector<edge> G[MAX_V];         //??°???????????£??\\???????????¨???\nint dist[MAX_V];               //???????????¢\nint prevv[MAX_V],preve[MAX_V]; //??´??????????????¨???\n\n// from??????to??????????????????cap????????????cost???????????°????????????????????????\nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back((edge){to,cap,cost,G[to].size()});\n  G[to].push_back((edge){from,0,-cost,G[from].size()-1});\n}\n\n//s??????t????????????f???????°??????¨???????±???????\n//??????????????´???-1?????????\nint min_cost_flow(int s,int t,int f){\n  int res=0;\n  while(f>0){\n    //????????????????????????????????????,s-t????????????????±???????\n    fill(dist,dist+V,INF);\n    dist[s]=0;\n    bool update = true;\n    while(update){\n      update = false;\n      for(int v=0; v<V ;v++){\n\tif(dist[v]==INF) continue;\n\tfor(int i=0; i<G[v].size(); i++){\n\t  edge &e = G[v][i];\n\t  if(e.cap > 0 && dist[e.to] > dist[v]+e.cost) {\n\t    dist[e.to] = dist[v] + e.cost;\n\t    prevv[e.to] = v;\n\t    preve[e.to] = i;\n\t    update = true;\n\t  }\n\t}\n      }\n    }\n    if(dist[t]==INF) return -1; //????????\\??????????????????\n    \n    //s???t?????????????????£??????????????????\n    int d = f;\n    for(int v=t; v!=s; v=prevv[v])d=min(d,G[prevv[v]][preve[v]].cap);\n    f -= d;\n    res += d*dist[t];\n    for(int v=t; v!=s; v=prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\ntypedef pair<int,int> P;\nint main(){\n  while(1){\n  int n,m,s,t;\n  cin>>n>>m>>s>>t;\n  if(!n&&!m&&!s&&!t)break;\n  V=n;\n  s--,t--;\n  for(int i=0;i<MAX_V;i++) G[i].clear();\n  \n  for(int i=0,a,b;i<m;i++){\n    cin>>a>>b;\n    a--,b--;\n    add_edge(a,b,1,0);\n    add_edge(b,a,1,1);\n  }\n  \n  int cost,mx=0,cnt=0;\n  while(!(cost=min_cost_flow(s,t,1)))mx++;\n  if(cost==1)mx++;\n  \n  while(cost==1){\n    cnt++;\n    int i,j;\n    for(int v=t; v!=s; v=prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      if(e.cost>0)i=prevv[v],j=preve[v];\n    }\n    min_cost_flow(t,s,1);\n    edge &e=G[i][j];\n    e.cap = 0;\n    G[e.to][e.rev].cap=0;\n    cost=min_cost_flow(s,t,1);\n  }  \n  cout<<mx<<\" \"<<cnt<<endl;\n  }  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_V 1005\n#define INF 1e9\nusing namespace std;\n\n/*最大流(Dinic法) O(|E||V|^2)*/\n//辺を表す構造体(行き先、容量、逆辺)\nstruct edge{int to, cap, rev, s;};\nvector<edge> G[MAX_V]; //グラフの隣接リスト表現\nint level[MAX_V];      //sからの距離\nint iter[MAX_V];       //どこまで調べ終わったか\n//辺を表す構造体(行き先、容量、逆辺)\n\n//fromからtoへ向かう容量capの辺をグラフに追加する\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size(),0});\n  G[to].push_back((edge){from,0,(int)G[from].size()-1,1});  \n}\n\n//sからの最短距離をBFSで計算する\nvoid bfs(int s){\n  memset(level,-1,sizeof(level));\n  queue<int> que;\n  level[s] = 0;\n  que.push(s);\n  while(!que.empty()){\n    int v = que.front(); que.pop();\n    for(int i=0; i<G[v].size(); i++){\n      edge &e = G[v][i];\n      if(e.cap > 0 && level[e.to] < 0){\n\tlevel[e.to] = level[v] + 1;\n\tque.push(e.to);\n      }\n    }\n  }\n}\n\n//増加パスをDFSで探す。\nint dfs(int v,int t,int f){\n  if(v==t) return f;\n  for(int &i= iter[v]; i<G[v].size(); i++){\n    edge &e = G[v][i];\n    if(e.cap > 0 && level[v] < level[e.to]){\n      int d = dfs(e.to, t, min(f, e.cap));\n      if(d > 0){\n\te.cap -= d;\n\tG[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\n//sからtへの最大流を求める\nint max_flow(int s,int t,int maxf){\n  int flow=0;\n  for(;;){\n    bfs(s);\n    if(maxf==0||level[t] < 0) return flow;\n    memset(iter,0,sizeof(iter));\n    int f;\n    while((f=dfs(s ,t ,maxf)) > 0 ) flow += f, maxf-=f;\n  }\n}\n\nint n, m, s, t;\n\nvoid solve(){\n  \n  int r = max_flow(s, t, INF);\n  int maxflow=r;\n  \n  unordered_map<int,int> cnt;\n  \n  for(int i=1;i<=n;i++){\n    \n    for(int j=0;j<G[i].size();j++){\n      \n      edge &s1 = G[i][j];\n      edge &t1 = G[s1.to][s1.rev];\n      \n      if(s1.s) continue;\n      if(t1.cap==1) continue;\n      \n      s1.cap=0;\n      \n      int f1=max_flow(s,s1.to,1);\n\n      int f2=max_flow(i,t,1);\n      \n      int f=r;\n      \n      if(f1&&f2) f=r+1;\n      \n      if(f1) max_flow(s1.to,s,1);\n      \n      if(f2) max_flow(t,i,1);\n      \n      if(maxflow<f) maxflow=f;\n\n      cnt[f]++;\n\n      s1.cap=1;\n    }\n    \n  }\n\n  int revcnt=0;\n\n  if(r<maxflow){\n    for(pair<int,int> d : cnt)\n      if(maxflow==d.first) revcnt+=d.second;\n  }\n  \n  cout<<maxflow<<' '<<revcnt<<endl;\n  \n}\n\nvoid init(){\n  for(int i=0;i<MAX_V;i++) G[i].clear();\n}\n\nint main(){\n\n  while(1){\n    \n    cin>>n>>m>>s>>t;\n    if(!n&&!m&&!s&&!t) break;\n\n    init();\n    \n    for(int i=0;i<m;i++){\n      int a, b;\n      cin>>a>>b;\n      add_edge(a,b,1);\n    }\n  \n    solve();\n  }\n    \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int MAX_V = 3000;\nconst int IINF = INT_MAX;\ntypedef pair<int,int> ii;\n\nmap<ii,int> mp; /////////\n\nstruct Edge{ int to,cap,rev; bool isRev; };\n\nvector<Edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((Edge){to,cap,G[to].size(),false});\n  G[to].push_back((Edge){from,0,G[from].size()-1,true});\n}\n\nint dfs(int v,int t,int f){\n  if( v == t ) return f;\n  used[v] = true;\n  for(int i=0;i<G[v].size();i++){\n    Edge &e = G[v][i];\n    if( !used[e.to] && e.cap > 0 ){\n      int d = dfs(e.to,t,min(f,e.cap));\n      if( d > 0 ){\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s,t,IINF);\n    if( f == 0 ) return flow;\n    flow += f;\n  }\n}\n\nvector<int> G2[MAX_V],rG2[MAX_V];\nbool visited[2][MAX_V];\n\nvoid init(int _size=MAX_V){ rep(i,_size) G[i].clear(), G2[i].clear(), rG2[i].clear(); }\n\nint V,E;\n\nvoid icompute(int s,bool used[MAX_V],int type){\n  used[s] = true;\n  deque<int> deq;\n  deq.push_back(s);\n  while( !deq.empty() ){\n    int cur = deq.front(); deq.pop_front();\n    rep(i,(int)(type?G2[cur].size():rG2[cur].size())){\n      int next = type?G2[cur][i]:rG2[cur][i];\n      if( !used[next] ) {\n\tused[next] = true;\n\tdeq.push_back(next);\n      }\n    }\n  }\n}\n\nvoid compute(int let,int go){\n  int maxi = max_flow(let,go);\n  rep(i,V) {\n    int s = i;\n    rep(j,(int)G[i].size()) if( G[i][j].cap ) {\n      int t = G[i][j].to, c = G[i][j].cap;\n      G2[s].push_back(t), rG2[t].push_back(s);\n    }\n  }\n\n  memset(visited,false,sizeof(visited));\n  icompute(let,visited[0],1);\n  icompute(go ,visited[1],0);\n\n  int cnt = 0;\n  rep(i,V) rep(j,(int)G[i].size()) if( G[i][j].cap && !G[i][j].isRev ) {\n    if( visited[0][G[i][j].to] && visited[1][i] ) ++cnt;\n  }\n  cout << maxi + ( cnt > 0 ) << \" \" << cnt << endl;\n}\n\nint main(){\n  int s,t;\n  while( cin >> V >> E >> s >> t, V|E|s|t ) {\n    --s, --t;\n    init(V);\n    set<ii> S;\n    rep(i,E) {\n      int a,b;\n      scanf(\"%d %d\",&a,&b);\n      --a, --b;\n      add_edge(a,b,1);\n    }\n    compute(s,t);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\nstruct edge{int to,cap,rev;};\nconst int MAX_V=1000,inf=1e8;\nvector<edge> G[MAX_V];\nint level[MAX_V],iter[MAX_V],ord[10000];\nint N,M,S,T,a[10000],b[10000];\nvoid add_edge(int from,int to,int cap,int i){\n\tedge e1={to,cap,(int)G[to].size()},e2={from,0,(int)G[from].size()};\n\tG[from].pb(e1);\n\tG[to].pb(e2);\n\tord[i]=G[from].size()-1;\n}\nvoid bfs(int s){\n\tmemset(level,-1,sizeof(level));\n\tqueue<int> que;\n\tlevel[s]=0;\n\tque.push(s);\n\twhile(!que.empty()){\n\t\tint v=que.front();\n\t\tque.pop();\n\t\trep(i,G[v].size()){\n\t\t\tedge &e=G[v][i];\n\t\t\tif(e.cap>0&&level[e.to]<0){\n\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\nint dfs(int v,int t,int f){\n\tif(v==t) return f;\n\tfor(int &i=iter[v];i<G[v].size();i++){\n\t\tedge &e=G[v][i];\n\t\tif(e.cap>0&&level[v]<level[e.to]){\n\t\t\tint d=dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0){\n\t\t\t\te.cap-=d;\n\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s,int t){\n\tint flow=0;\n\twhile(true){\n\t\tbfs(s);\n\t\tif(level[t]<0) return flow;\n\t\tmemset(iter,0,sizeof(iter));\n\t\tint f;\n\t\twhile((f=dfs(s,t,inf))>0) flow+=f;\n\t}\n}\nbool froms[MAX_V],tot[MAX_V];\nvoid dfs1(int v){//from s\n\tfroms[v]=1;\n\tfor(auto e:G[v]){\n\t\tif(e.cap<=0) continue;\n\t\tif(froms[e.to]) continue;\n\t\tdfs1(e.to);\n\t}\n}\nvoid dfs2(int v){//to t\n\ttot[v]=1;\n\tfor(auto e:G[v]){\n\t\tif(e.cap>0) continue;\n\t\tif(tot[e.to]) continue;\n\t\tdfs2(e.to);\n\t}\n}\nint main(){\n\twhile(true){\n\t\tcin>>N>>M>>S>>T;\n\t\tif(N==0) break;\n\t\trep(i,N) G[i].clear();\n\t\tS--,T--;\n\t\trep(i,M) cin>>a[i]>>b[i];\n\t\trep(i,M){\n\t\t\ta[i]--,b[i]--;\n\t\t\tadd_edge(a[i],b[i],1,i);\n\t\t}\n\t\tint f=max_flow(S,T);\n\t\tint cnt=0;\n\t\trep(i,N) froms[i]=0,tot[i]=0;\n\t\tdfs1(S);\n\t\tdfs2(T);\n\t\trep(i,M){\n\t\t\tif(G[a[i]][ord[i]].cap<1) continue;\n\t\t\tif(froms[b[i]]&&tot[a[i]]) cnt++;\n\t\t}\n\t\tif(cnt>0) f++;\n\t\tcout<<f<<\" \"<<cnt<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nstruct edge{\n  int to,cap,org,rev;\n};\n\nvector<edge> G[1234];\nbool used[1234];\n\nvoid add_edge(int from,int to){\n  G[from].push_back({to,1,1,(int)G[to].size()});\n  G[to].push_back({from,0,0,(int)G[from].size()-1});\n}\n\nint dfs(int v,int t,int f){\n  if(v==t)return f;\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    edge &e=G[v][i];\n    if(!used[e.to]&&e.cap>0){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n\te.cap-=d;\n\tG[e.to][e.rev].cap+=d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow=0;\n  for(;;){\n    fill(begin(used),end(used),false);\n    int f=dfs(s,t,1e9);\n    if(f==0)return flow;\n    flow+=f;\n  }\n}\n\nbool u1[1234],u2[1234];\n\nvoid dfsr(int v){\n  if(u1[v]++)return;\n  for(auto e:G[v]){\n    if(e.cap){\n      dfsr(e.to);\n    }\n  }\n}\n\nvoid rdfsr(int v){\n  if(u2[v]++)return;\n  for(auto e:G[v]){\n    if(!e.cap){\n      rdfsr(e.to);\n    }\n  }\n}\n\nint main(){\n  for(int N,M,S,T;cin>>N>>M>>S>>T,N|M|S|T;){\n    for(auto &e:G){\n      e.clear();\n    }\n    fill(begin(u1),end(u1),false);\n    fill(begin(u2),end(u2),false);\n    for(int i=0;i<M;i++){\n      int a,b;\n      cin>>a>>b;\n      add_edge(a,b);\n    }\n    int f=max_flow(S,T);\n    dfsr(S);\n    rdfsr(T);\n    int c=0;\n    for(int i=1;i<=N;i++){\n      for(auto e:G[i]){\n\tif(e.cap&&e.org&&u1[e.to]&&u2[i]){\n\t  c++;\n\t}\n      }\n    }\n    cout<<f+!!c<<' '<<c<<endl;\n  }\n}\n\n    "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\n#include <map>\n#include <unordered_set>\nusing namespace std;\n\nusing Weight = int;\nusing Capacity = int;\nstruct Edge {\n\tint src, dst; Weight weight; Capacity cap;\n\tEdge(int s, int d, Weight w, Capacity c) : src(s), dst(d), weight(w), cap(c) {}\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\nstruct Dinic {\n\tint n, s, t;\n\tvector<int> level, prog, que;\n\tvector<vector<Capacity>> cap, flow;\n\tvector<vector<int>> g;\n\tCapacity inf;\n\tDinic(const Graph &graph)\n\t\t: n(graph.size()),\n\t\tcap(n, vector<Capacity>(n)), flow(n, vector<Capacity>(n)),\n\t\tg(n, vector<int>()), inf(numeric_limits<Capacity>::max() / 8) {\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tfor(auto &e : graph[i]) {\n\t\t\t\tint u = e.src, v = e.dst;\n\t\t\t\tCapacity c = e.cap;\n\t\t\t\tcap[u][v] += c; cap[v][u] += c; flow[v][u] += c;\n\t\t\t\tg[u].push_back(v); g[v].push_back(u);\n\t\t\t}\n\t\t}\n\t}\n\tinline Capacity residue(int u, int v) { return cap[u][v] - flow[u][v]; }\n\tCapacity solve(int s_, int t_) {\n\t\tthis->t = t_, this->s = s_;\n\t\tque.resize(n + 1);\n\t\tCapacity res = 0;\n\t\twhile(levelize()) { prog.assign(n, 0); res += augment(s, inf); }\n\t\treturn res;\n\t}\n\tbool levelize() {\n\t\tint l = 0, r = 0;\n\t\tlevel.assign(n, -1); level[s] = 0; que[r++] = s;\n\t\twhile(l != r) {\n\t\t\tint v = que[l++]; if(v == t) break;\n\t\t\tfor(const int &d : g[v]) if(level[d] == -1 && residue(v, d) != 0) {\n\t\t\t\tlevel[d] = level[v] + 1; que[r++] = d;\n\t\t\t}\n\t\t}\n\t\treturn level[t] != -1;\n\t}\n\tCapacity augment(int v, Capacity lim) {\n\t\tCapacity res = 0;\n\t\tif(v == t) return lim;\n\t\tfor(int &i = prog[v]; i < (int)g[v].size(); i++) {\n\t\t\tconst int &d = g[v][i];\n\t\t\tif(residue(v, d) == 0 || level[v] >= level[d]) continue;\n\t\t\tconst Capacity aug = augment(d, min(lim, residue(v, d)));\n\t\t\tflow[v][d] += aug; flow[d][v] -= aug;\n\t\t\tres += aug; lim -= aug;\n\t\t\tif(lim == 0) break;\n\t\t}\n\t\treturn res;\n\t}\n};\n\ntypedef pair<int, int> Pii;\n\nvector<int> RG[2][1010];\nunordered_set<int> visit[2];\n\nint a[10010];\nint b[10010];\nbool used[1010];\n\nvoid dfs(int v, int p, int gi) {\n\tused[v] = true;\n\tvisit[gi].insert(v);\n\tfor(int c : RG[gi][v]) {\n\t\tif(c == p) continue;\n\t\tif(!used[c]) dfs(c, v, gi);\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, M, S, T;\n\twhile(cin >> N >> M >> S >> T, N) {\n\t\tGraph G(N + 1);\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tcin >> a[i] >> b[i];\n\t\t\tG[a[i]].push_back(Edge(a[i], b[i], 1, 1));\n\t\t}\n\n\t\tDinic dinic(G);\n\t\tint flow = dinic.solve(S, T);\n\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tRG[0][i].clear();\n\t\t\tRG[1][i].clear();\n\t\t}\n\t\tvisit[0].clear();\n\t\tvisit[1].clear();\n\n\t\tfor(int u = 1; u <= N; u++) {\n\t\t\tfor(int v : dinic.g[u]) {\n\t\t\t\tif(dinic.residue(u, v) != 0) {\n\t\t\t\t\tRG[0][u].push_back(v);\n\t\t\t\t\tRG[1][v].push_back(u);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmemset(used, 0, sizeof used);\n\t\tdfs(S, -1, 0);\n\t\tmemset(used, 0, sizeof used);\n\t\tdfs(T, -1, 1);\n\n\t\tint num = 0;\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tif(visit[0].find(b[i]) != visit[0].end() && visit[1].find(a[i]) != visit[1].end()) {\n\t\t\t\tnum++;\n\t\t\t}\n\t\t}\n\n\t\tcout << flow + (num > 0) << \" \" << num << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nstruct edge{\n\tint to;\n\tint cap;\n\tint rev;\n};\n\nstruct flow{\n\tvector<edge> G[1002];\n\tbool used[1002];\n\tvoid add_edge(int from,int to,int cap){\n\t\tedge a = {to,cap,G[to].size()};\n\t\tedge b = {from,0,G[from].size()};\n\t\tG[from].push_back(a);\n\t\tG[to].push_back(b);\n\t}\n\tint dfs(int v,int t,int f){\n\t\tif(v == t)return f;\n\t\tused[v] = true;\n\t\tfor(int i = 0 ; i < G[v].size() ; i ++){\n\t\t\tedge &e = G[v][i];\n\t\t\tif(!used[e.to] && e.cap > 0){\n\t\t\t\tint d = dfs(e.to,t,min(f,e.cap));\n\t\t\t\tif(d > 0){\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s,int t){\n\t\tint flow = 0;\n\t\twhile(1){\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tint f = dfs(s,t,INF);\n\t\t\tif(f == 0)return flow;\n\t\t\tflow += f;\n\t\t}\n\t}\n\tvoid init(){\n\t\trep(i,1002)G[i].clear();\n\t}\n}F;\n\nint flag[1002];\nvoid dfs(int v){\n\tif(flag[v] == 1)return;\n\tflag[v] = 1;\n\trep(i,F.G[v].size()){\n\t\tedge ed = F.G[v][i];\n\t\tif(ed.cap > 0)dfs(ed.to);\n\t}\n}\nvoid dfs_rev(int v){\n\tif(flag[v] == -1)return;\n\tflag[v] = -1;\n\trep(i,F.G[v].size()){\n\t\tedge ed = F.G[v][i];\n\t\tif(ed.cap == 0)dfs_rev(ed.to);\n\t}\n}\n\nint main(){\n\twhile(1){\n\t\tint n,m,s,t;\n\t\tcin >> n >> m >> s >> t;\n\t\tif(n == 0)return 0;\n\t\tint a[10002],b[10002];\n\t\trep(i,m){\n\t\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t\t}\n\t\t\n\t\tF.init();\n\t\trep(i,m){\n\t\t\tF.add_edge(a[i],b[i],1);\n\t\t}\n\t\tint ret = F.max_flow(s,t);\n\t\trep1(i,n)flag[i] = 0;\n\t\tdfs(s);\n\t\tdfs_rev(t);\n\t\tint cnt = 0;\n\t\trep(i,m){\n\t\t\tif(flag[a[i]] == -1 && flag[b[i]] == 1)cnt ++;\n\t\t}\n\t\tprintf(\"%d %d\\n\",ret+(cnt==0?0:1),cnt);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<tuple>\n\nusing namespace std;\n\nstruct edge{int to,cap,rev;};\n\nvector<edge>G[1234];\nint level[1234];\nint iter[1234];\n\nvector<tuple<int,int,int,int> > edges;\n\nvoid add_edge(int from,int to,int cap=1){\n  edges.emplace_back(from,(int)G[from].size(),to,(int)G[to].size());\n  G[from].push_back({to,cap,(int)G[to].size()});\n  G[to].push_back({from,0,(int)G[from].size()-1});\n}\n\nvoid bfs(int s){\n  fill(begin(level),end(level),-1);\n  queue<int> que;\n  level[s]=0;\n  que.push(s);\n  while(!que.empty()){\n    int v=que.front();que.pop();\n    for(int i=0;i<G[v].size();i++){\n      edge &e=G[v][i];\n      if(e.cap>0&&level[e.to]<0){\n\tlevel[e.to]=level[v]+1;\n\tque.push(e.to);\n      }\n    }\n  }\n}\n\nint dfs(int v,int t,int f){\n  if(v==t)return f;\n  for(int &i=iter[v];i<G[v].size();i++){\n    edge &e=G[v][i];\n    if(e.cap>0&&level[v]<level[e.to]){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n\te.cap-=d;\n\tG[e.to][e.rev].cap+=d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t,int mf=1e9){\n  int flow=0;\n  for(;;){\n    bfs(s);\n    if(level[t]<0)return flow;\n    fill(begin(iter),end(iter),0);\n    int f;\n    while((f=dfs(s,t,mf))>0){\n      flow+=f;\n      if(flow==mf)return flow;\n    }\n  }\n}\n\nint main(){\n  for(int N,M,S,T;cin>>N>>M>>S>>T,N|M|S|T;){\n    edges.clear();\n    for(auto &e:G){\n      e.clear();\n    }\n    for(int i=0;i<M;i++){\n      int a,b;\n      cin>>a>>b;\n      add_edge(a,b);\n    }\n    int df=max_flow(S,T);\n    int nr=0;\n    for(int i=0;i<M;i++){\n      int f,fx,t,tx;\n      tie(f,fx,t,tx)=edges[i];\n      bool rev=false;\n      if(G[f][fx].cap==0){\n\trev=true;\n\tmax_flow(f,S,1);\n\tmax_flow(T,t,1);\n      }\n      G[f][fx].cap=0;\n      G[t][tx].cap=1;\n      if(max_flow(S,T)>rev){\n\tnr++;\n      }\n      if(G[t][tx].cap==0){\n\tmax_flow(T,f,1);\n\tmax_flow(t,S,1);\n      }\n      G[f][fx].cap=1;\n      G[t][tx].cap=0;\n      max_flow(S,T);\n    }\n    cout<<df+!!nr<<' '<<nr<<endl;\n  }\n}\n\n\t  \n\t"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define INIT(a) memset(a,0,sizeof(a))\n\n#define fs first\n#define sc second\n#define pb push_back\n#define sz size()\n\nusing namespace std;\n\nconst int MAX_V = 1000;\nconst int INF = 1e8;\n\nint level[MAX_V];\nint iter[MAX_V];\n\nstruct edge{ int from,to,cost,cap,rev; };\n\nvector<edge> G[MAX_V];\n\nvoid AddEdge(int s,int g,int c,int p){\n  G[s].pb((edge){s,g,c,p,(int)G[g].sz});\n  G[g].pb((edge){g,s,-c,0,(int)G[s].sz-1});\n}\n\nvoid bfs(int s){\n  memset(level,-1,sizeof(level));\n  level[s] = 0;\n  queue<int> q; q.push(s);\n  while(q.sz){\n    int u = q.front(); q.pop();\n    rep(i,G[u].sz){\n      edge &e = G[u][i];\n      if(e.cap > 0 && level[e.to] < 0){\n\tlevel[e.to] = level[u] + 1;\n\tq.push(e.to);\n      }\n    }\n  }\n}\n\nint dfs(int u, int t, int f){\n  if(u==t)return f;\n  for(int &i = iter[u];i<(int)G[u].sz;i++){\n    edge &e = G[u][i];\n    if(e.cap > 0 && level[u] < level[e.to]){\n      int d = dfs(e.to,t,min(f,e.cap));\n      if(d > 0){\n\te.cap -= d;\n\tG[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint dinic(int s, int t){\n  int res = 0;\n  for(;;){\n    bfs(s);\n    if(level[t]<0)return res;\n    INIT(iter);\n    int f;\n    while((f=dfs(s,t,INF))>0)res += f;\n  }\n}\n\nvoid visible(int v, const vector< vector<int> > &graph,\n\t     vector<int> &vis){\n  if(vis[v])return;\n  vis[v] = true;\n\n  for(int u : graph[v]){\n    visible(u,graph,vis);\n  }\n}\n\nint main(){\n  int n,m,a,b,s,t;\n  while(cin >> n >> m){\n    if(n==0 && m==0)break;\n    cin >> s >> t; s--; t--;\n\n    rep(i,n)G[i].clear();\n    rep(i,m){\n      cin >> a >> b; a--; b--;\n      AddEdge(a,b,1,1);\n    }\n\n    int f = dinic(s,t);\n\n    vector< vector<int> > fg(n), rg(n);\n    rep(i,n){\n      for(edge e : G[i]){\n\tif(e.cap>0){\n\t  fg[i].pb(e.to);\n\t  rg[e.to].pb(i);\n\t}\n      }\n    }\n\n    vector<int> visS(n), visT(n);\n    visible(s,fg,visS);\n    visible(t,rg,visT);\n\n    int ans = 0;\n    rep(i,n){\n      for(edge e : G[i]){\n\tif(e.cost>0 && visS[e.to] && visT[e.from])ans++;\n      }\n    }\n\n    cout << f + (ans>0?1:0) << \" \" << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T>\nstruct FordFulkerson{\n\tstruct Edge{\n\t\tint to,rev;\n\t\tT cap;\n\t\tEdge(int to,T cap,int rev) : to(to),rev(rev),cap(cap){}\n\t};\n\n\tvector<vector<Edge>> G;\n\tvector<bool> used;\n\n\tFordFulkerson(int n) : G(n),used(n){}\n\n\tvoid addEdge(int from,int to,T cap,bool isDirected = true){\n\t\tG[from].emplace_back(to,cap,G[to].size());\n\t\tG[to].emplace_back(from,isDirected ? 0 : cap,G[from].size() - 1);\n\t}\n\n\tT dfs(int v,int t,T f){\n\t\tif(v == t) return f;\n\t\tused[v] = true;\n\t\tfor(auto &e : G[v]){\n\t\t\tif(!used[e.to] && e.cap){\n\t\t\t\tT d = dfs(e.to,t,min(f,e.cap));\n\t\t\t\tif(d){\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tT flow(int s,int t){\n\t\tT ret = 0;\n\t\twhile(1){\n\t\t\tfill(used.begin(),used.end(),0);\n\t\t\tT f = dfs(s,t,numeric_limits<T>::max());\n\t\t\tif(!f) return ret;\n\t\t\tret += f;\n\t\t}\n\t}\n};\n\nvoid dfs(int v,bool *visit,FordFulkerson<int> &ff,bool isRev){\n\tvisit[v] = true;\n\tfor(auto &e : ff.G[v]){\n\t\tif((isRev ^ e.cap) && !visit[e.to]) dfs(e.to,visit,ff,isRev);\n\t}\n}\n\nint n,m,s,t;\n\nvoid solve(){\n\tbool visits[2][1010] = {};\n\ts--; t--;\n\tFordFulkerson<int> ff(n);\n\tint a[10010],b[10010];\n\tfor(int i = 0;i < m;i++){\n\t\tcin >> a[i] >> b[i]; a[i]--;b[i]--;\n\t\tff.addEdge(a[i],b[i],1);\n\t}\n\tint flow = ff.flow(s,t),ans = 0;\n\tdfs(s,visits[0],ff,false);\n\tdfs(t,visits[1],ff,true);\n\tfor(int i = 0;i < m;i++){\n\t\tif(visits[1][a[i]] && visits[0][b[i]]) ans++; \n\t}\n\tcout << flow + !!ans << \" \" << ans << endl;\n}\n\nsigned main(){\n\twhile(cin >> n >> m >> s >> t,n) solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<typename T> T inf() { assert(false); }\ntemplate<> constexpr int inf<int>() { return 1e9; }\ntemplate<> constexpr ll inf<ll>() { return 1e18; }\ntemplate<> constexpr ld inf<ld>() { return 1e30; }\n/*--------------------template--------------------*/\n\ntemplate <typename Flow>\nstruct FEdge {\n\tint from, to;\n\tFlow cap; int rev;\n\tFEdge(int s, int t, Flow f, int r) : from(s), to(t), cap(f), rev(r) {}\n};\n\ntemplate<typename Flow> using FGraph = vector<vector<FEdge<Flow>>>;\n\ntemplate <typename Flow>\nvoid add_edge(FGraph<Flow> &g, int from, int to, Flow cap) {\n\tg[from].emplace_back(from, to, cap, (int)g[to].size());\n\tg[to].emplace_back(to, from, 0, (int)g[from].size() - 1);\n}\n\ntemplate <typename Flow>\nFlow augment(FGraph<Flow> &g, vector<Flow> &d, vector<int> &iter,\n\tint v, int t, const Flow &f) {\n\tif (v == t) return f;\n\tfor (int &i = iter[v]; i < (int)g[v].size(); i++) {\n\t\tauto &e = g[v][i];\n\t\tif (e.cap > 0 && d[v] < d[e.to]) {\n\t\t\tFlow ff = augment(g, d, iter, e.to, t, min(f, e.cap));\n\t\t\tif (ff > 0) {\n\t\t\t\te.cap -= ff;\n\t\t\t\tg[e.to][e.rev].cap += ff;\n\t\t\t\treturn ff;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\ntemplate <typename Flow>\nFlow max_flow(FGraph<Flow> &g, int s, int t, Flow zero = 0) {\n\tconst int V = g.size();\n\tFlow flow = zero;\n\tfor (;;) {\n\t\tvector<Flow> d(V, -1);\n\t\tqueue<int> que;\n\t\td[s] = zero;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (const auto &e : g[v]) {\n\t\t\t\tif (e.cap <= zero || d[e.to] >= zero) continue;\n\t\t\t\td[e.to] = d[v] + 1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t\tif (d[t] < zero) return flow;\n\t\tvector<int> iter(V, 0);\n\t\tFlow f;\n\t\twhile ((f = augment(g, d, iter, s, t, inf<Flow>())) > 0) flow += f;\n\t}\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint n, m, s, t;\n\twhile (cin >> n >> m >> s >> t, n)\n\t{\n\t\ts--; t--;\n\t\tFGraph<int> g(n);\n\t\tset<pii> st;\n\t\tREP(i, m)\n\t\t{\n\t\t\tint a, b; cin >> a >> b;\n\t\t\ta--; b--;\n\t\t\tadd_edge(g, a, b, 1);\n\t\t\tst.emplace(a, b);\n\t\t}\n\t\tint fl = max_flow(g, s, t);\n\t\tvi vis(n);\n\t\tvis[s] = 1;\n\t\tqueue<int> que;\n\t\tque.push(s);\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tint t = que.front();\n\t\t\tque.pop();\n\t\t\tfor (auto e : g[t])\n\t\t\t{\n\t\t\t\tif (e.cap == 0) continue;\n\t\t\t\tint nx = e.to;\n\t\t\t\tif (vis[nx]) continue;\n\t\t\t\tvis[nx] = 1;\n\t\t\t\tque.push(nx);\n\t\t\t}\n\t\t}\n\t\twhile (!que.empty()) que.pop();\n\t\tvis[t] = -1;\n\t\tque.push(t);\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tint t = que.front();\n\t\t\tque.pop();\n\t\t\tfor (auto e : g[t])\n\t\t\t{\n\t\t\t\tif (e.cap == 1) continue;\n\t\t\t\tint nx = e.to;\n\t\t\t\tif (vis[nx]) continue;\n\t\t\t\tvis[nx] = -1;\n\t\t\t\tque.push(nx);\n\t\t\t}\n\t\t}\n\t\tvi v1, v2;\n\t\tREP(i, n)\n\t\t{\n\t\t\tif (vis[i] == 1) v1.push_back(i);\n\t\t\telse if(vis[i] == -1) v2.push_back(i);\n\t\t}\n\t\tint add = 0;\n\t\tfor (auto i : v1)for (auto j : v2)\n\t\t{\n\t\t\tif (st.count(pii(j, i))) add++;\n\t\t}\n\t\tif (add) fl++;\n\t\tcout << fl << \" \" << add << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 1005\n#define INF (1<<26)\n \nint N,M,S,T;\nint G[MAX_N][MAX_N];\nint g[MAX_N][MAX_N];\nint base;\nint visited[MAX_N];\n \nint AS[MAX_N],AT[MAX_N];\n \nbool check(int a,int b){\n  if(AT[a]&&AS[b])return true;\n  else return false;\n}\n \nvoid dfsS(int pos){\n  AS[pos]=true;\n  for(int i=0;i<N;i++){\n    if(G[pos][i]==0)continue;\n    if(AS[i])continue;\n    dfsS(i);\n  }\n}\n \nvoid dfsT(int pos){\n  AT[pos]=true;\n  for(int i=0;i<N;i++){\n    if(G[i][pos]==0)continue;\n    if(AT[i])continue;\n    dfsT(i);\n  }\n}\n \nvoid solve(){\n  /*\n  \n  cout<<endl;\n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      cout<<g[i][j]<<' ';\n    }\n    cout<<endl;\n  }\n  cout<<endl;\n\n  cout<<endl;\n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      cout<<G[i][j]<<' ';\n    }\n    cout<<endl;\n  }\n  cout<<endl;\n  */\n  \n  for(int i=0;i<N;i++)\n    AS[i]=AT[i]=false;\n   \n  dfsS(S);\n  dfsT(T);\n \n  /*\n  for(int i=0;i<N;i++){\n    cout<<AS[i]<<' ';\n  }\n  cout<<endl;\n \n  for(int i=0;i<N;i++){\n    cout<<AT[i]<<' ';\n  }\n  cout<<endl;\n  */\n \n  int cnt=0;\n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      if(i==j)continue;\n      if(g[i][j]==0)continue;\n      if(G[i][j]==0)continue;\n      int dist=g[j][i]-G[j][i];\n      if(dist<0)continue;\n      \n      if(check(i,j)){\n        cnt+=(G[i][j]-dist);\n      }\n\n    }\n  }\n \n  if(base==0&&cnt==0)cout<<\"0 0\"<<endl;\n  else if(cnt==0)cout<<base<<\" 0\"<<endl;\n  else cout<<base+1<<\" \"<<cnt<<endl;\n}\n \nint dfs(int pos,int f){\n  if(pos==T)return f;\n  visited[pos]=true;\n  for(int i=0;i<N;i++){\n    if(visited[i])continue;\n    if(G[pos][i]==0)continue;\n    int d=dfs(i,min(f,G[pos][i]));\n    if(d>0){\n      G[pos][i]-=d;\n      G[i][pos]+=d;\n      return d;\n    }\n  }\n  return 0;\n}\n \nvoid calc(){\n  base=0;\n  while(1){\n    for(int i=0;i<N;i++)visited[i]=false;\n    int f=dfs(S,INF);\n    if(f==0)break;\n    base+=f;\n  }\n}\n \nvoid init(){\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      G[i][j]=0;\n}\n \nint main(){\n  int a,b;\n  while(1){\n    scanf(\"%d %d %d %d\",&N,&M,&S,&T);\n    if(N==0&&M==0&&S==0&&T==0)break;\n    S--,T--;\n    init();\n    for(int i=0;i<M;i++){\n      scanf(\"%d %d\",&a,&b);\n      a--,b--;\n      G[a][b]++;\n    }\n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++)\n        g[i][j]=G[i][j];\n    calc();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nconst int maxn = 1000 + 10;\nconst int maxe = 20000 + 100;\n\n#define REP(i, a, b) for(int i = a; i < b; i++)\n#define FOR(i, a, b) for(int i = a; i <= b; i++)\n#define CLR(a, x) memset(a, x, sizeof a)\n#define CPY(a, x) memcpy(a, x, sizeof a)\n\nconst int INF = 1e9;\n\nstruct Edge{\n    int u, v, c, f;\n    int next;\n    Edge() {}\n    Edge(int u, int v, int c, int f, int next) : u(u), v(v), c(c), f(f), next(next) {}\n};\n\nstruct ISAP{\n    int vis_edge[maxe];\n    int vis_node[maxn];\n    int n, s, t;\n    int num[maxn], cur[maxn], d[maxn], p[maxn];\n    int Head[maxn], cntE;\n    int Q[maxn], head, tail;\n    Edge edge[maxe];\n    void Init(int n){\n        this -> n = n;\n        cntE = 0;\n        CLR(Head, -1);\n        CLR(vis_edge, 0);\n        CLR(vis_node, 0);\n    }\n    void add(int u, int v, int c){\n        edge[cntE] = Edge(u, v, c, 0, Head[u]);\n        Head[u] = cntE++;\n        edge[cntE] = Edge(v, u, 0, 0, Head[v]);\n        Head[v] = cntE++;\n    }\n\n    void bfs(){\n        CLR(d, -1);\n        CLR(num, 0);\n        d[t] = 0;\n        head = tail = 0;\n        Q[tail++] = t;\n        num[0] = 1;\n        while(head != tail){\n            int u = Q[head++];\n            for(int i = Head[u]; ~i; i = edge[i].next){\n                Edge &e = edge[i];\n                if(~d[e.v]) continue;\n                d[e.v] = d[u] + 1;\n                Q[tail++] = e.v;\n                num[d[e.v]]++;\n            }\n        }\n    }\n    int maxflow(int s, int t){\n        this -> s = s;\n        this -> t = t;\n        CPY(cur, Head);\n        bfs();\n        int flow = 0, u = p[s] = s;\n        while(d[s] < n){\n            if(u == t){\n                int f = INF, neck;\n                for(int i = s; i != t; i = edge[cur[i]].v){\n                    if(f > edge[cur[i]].c - edge[cur[i]].f){\n                        f = edge[cur[i]].c - edge[cur[i]].f;\n                        neck = i;\n                    }\n                }\n                for(int i = s; i != t; i = edge[cur[i]].v){\n                    edge[cur[i]].f += f;\n                    edge[cur[i]^1].f -= f;\n                }\n                flow += f;\n                u = neck;\n            }\n            int ok = 0;\n            for(int i = cur[u]; ~i; i = edge[i].next){\n                Edge &e = edge[i];\n                if(e.c > e.f && d[e.v] + 1 == d[u]){\n                    ok = 1;\n                    cur[u] = i;\n                    p[e.v] = u;\n                    u = e.v;\n                    break;\n                }\n            }\n            if(!ok){\n                int m = n - 1;\n                if(--num[d[u]] == 0) break;\n                for(int i = Head[u]; ~i; i =  edge[i].next){\n                    Edge &e = edge[i];\n                    if(e.c - e.f > 0 && m > d[e.v]){\n                        cur[u] = i;\n                        m = d[e.v];\n                    }\n                }\n                ++num[d[u] = m+1];\n                u = p[u];\n            }\n        }\n        return flow;\n    }\n\n    void dfs(int u){\n        if(vis_node[u]) return;\n        vis_node[u] = 1;\n        for(int i = Head[u]; ~i; i = edge[i].next){\n            Edge &e = edge[i];\n            if(e.f == 1 && e.c == 1){\n                vis_edge[i] = 1;\n                dfs(e.v);\n            }\n        }\n    }\n\n    void work(){\n        dfs(s);\n    }\n}solver;\n\nint n, m, s, t;\n\nEdge S[maxe], T[maxe];\nint Heads[maxn], cntEs;\nint Headt[maxn], cntEt;\nint viss[maxn], vist[maxn];\nvoid init(){\n    CLR(Heads, -1);\n    CLR(Headt, -1);\n    CLR(viss, 0);\n    CLR(vist, 0);\n    cntEs = cntEt = 0;\n}\nvoid Adds(int u, int v){\n    S[cntEs] = Edge(u, v, 0, 0, Heads[u]);\n    Heads[u] = cntEs++;\n}\n\nvoid Addt(int u, int v){\n    T[cntEt] = Edge(u, v, 0, 0, Headt[u]);\n    Headt[u] = cntEt++;\n}\n\nvoid dfss(int u){\n    if(viss[u]) return;\n    viss[u] = 1;\n    for(int i = Heads[u]; ~i; i = S[i].next){\n        dfss(S[i].v);\n    }\n}\n\nvoid dfst(int u){\n    if(vist[u]) return;\n    vist[u] = 1;\n    for(int i = Headt[u]; ~i; i = T[i].next){\n        dfst(T[i].v);\n    }\n}\n\nvoid solve(){\n    solver.Init(n + 1);\n    s--; t--;\n    for(int i = 0; i < m; i++){\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        --u; --v;\n        solver.add(u, v, 1);\n    }\n    int ans = solver.maxflow(s, t);\n    solver.work();\n    init();\n    for(int i = 0; i < solver.cntE; i++){\n        if(!solver.edge[i].c || solver.vis_edge[i]) continue;\n        int u = solver.edge[i].u;\n        int v = solver.edge[i].v;\n        Adds(u, v);\n        Addt(v, u);\n    }\n    dfss(s);\n    dfst(t);\n    int add_edge = 0;\n    for(int i = 0; i < solver.cntE; i++){\n        if(!solver.edge[i].c || solver.vis_edge[i]) continue;\n        int u = solver.edge[i].u;\n        int v = solver.edge[i].v;\n//        printf(\"%d %d.....\\n\", u, v);\n        if(viss[u] && vist[v]) add_edge++;\n        if(viss[v] && vist[u]) add_edge++;\n    }\n    if(add_edge == 0){\n        printf(\"%d 0\\n\", ans);\n    }\n    else printf(\"%d %d\\n\", ans+1, add_edge);\n}\n\nint main()\n{\n    while(scanf(\"%d%d%d%d\", &n, &m, &s, &t) && n) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing weight = int;\n\nstruct edge {\n    int to;\n    weight cap;\n    int rev;\n    bool is_rev;\n};\n\nusing edges = std::vector<edge>;\nusing graph = std::vector<edges>;\n\nvoid add_edge(graph& g, int from, int to, weight cap) {\n    g[from].push_back(edge{to, cap, static_cast<int>(g[to].size()), false});\n    g[to].push_back(edge{from, 0, static_cast<int>(g[from].size()-1), true});\n}\n\nvoid bfs(graph& g, std::vector<int>& level, int s) {\n    for(int i=0; i<level.size(); ++i) {\n        level[i] = -1;\n    }\n    level[s] = 0;\n    std::queue<weight> que;\n    que.push(s);\n    while(!que.empty()) {\n        int v = que.front(); que.pop();\n        for(int i=0; i<g[v].size(); ++i) {\n            edge& e = g[v][i];\n            if(e.cap > 0 && level[e.to] < 0) {\n                level[e.to] = level[v] + 1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\nweight dfs(graph& g, std::vector<int>& level, std::vector<int>& iter, int v, int t, weight f) {\n    if(v == t) {\n        return f;\n    }\n    for(int& i=iter[v]; i<g[v].size(); ++i) {\n        edge& e = g[v][i];\n        if(e.cap > 0 && level[v] < level[e.to]) {\n            int d = dfs(g, level, iter, e.to, t, std::min(f, e.cap));\n            if(d > 0) {\n                e.cap -= d;\n                g[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\n// verified\nweight max_flow(graph& g, int s, int t) {\n    weight flow = 0;\n    std::vector<int> level(g.size(), -1);\n    std::vector<int> iter(g.size(), 0);\n    int INF = 1e9;\n    while(true) {\n        bfs(g, level, s);\n        if(level[t] < 0) {\n            return flow;\n        }\n        for(int i=0; i<iter.size(); ++i) {\n            iter[i] = 0;\n        }\n        weight f;\n        while((f = dfs(g, level, iter, s, t, INF)) > 0) {\n            flow += f;\n        }\n    }\n}\n\nvoid dfs(graph& g, int v, vector<int>& vis, int type) {\n    vis[v] = 1;\n    for(auto& e : g[v]) {\n        if(vis[e.to] == 1) {\n            continue;\n        }\n        if(type == 1 && e.cap == 1 || type == 2 && e.cap == 0) {\n            dfs(g, e.to, vis, type);\n        }\n    }\n}\n\nint main() {\n    int N, M, S, T;\n    while(cin >> N >> M >> S >> T, N) {\n        S--; T--;\n        graph g(N);\n        for(int i = 0; i < M; ++i) {\n            int a, b;\n            cin >> a >> b;\n            a--; b--;\n            add_edge(g, a, b, 1);\n        }\n        int flow = max_flow(g, S, T);\n        vector<int> v(N), w(N);\n        dfs(g, S, v, 1);\n        dfs(g, T, w, 2);\n        int cnt = 0;\n        for(int i = 0; i < N; ++i) {\n            for(auto& e : g[i]) {\n                if(!e.is_rev && e.cap == 1 && w[i] && v[e.to]) {\n                    cnt++;\n                }\n            }\n        }\n        flow += cnt > 0;\n        cout << flow << ' ' << cnt << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\nconst int D_MAX_V=2002;\nconst int D_v_size=2002;\nstruct D_wolf{\n\tint t,c,r;\n\tD_wolf(){t=c=r=0;}\n\tD_wolf(int t1,int c1,int r1){\n\t\tt=t1;c=c1;r=r1;\n\t}\n};\nvector<D_wolf>D_G[D_MAX_V];\nint D_level[D_MAX_V];\nint D_iter[D_MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n\tfor(int i=0;i<D_G[from].size();i++){\n\t\tif(to==D_G[from][i].t){\n\t\t\tD_G[from][i].c+=cap;\n\t\t\treturn;\n\t\t}\n\t}\n\tD_G[from].push_back(D_wolf(to,cap,D_G[to].size()));\n\tD_G[to].push_back(D_wolf(from,0,D_G[from].size()-1));\n}\nvoid D_bfs(int s){\n\tfor(int i=0;i<D_v_size;i++)D_level[i]=-1;\n\tqueue<int> Q;\n\tD_level[s]=0;\n\tQ.push(s);\n\twhile(Q.size()){\n\t\tint v=Q.front();\n\t\tQ.pop();\n\t\tfor(int i=0;i<D_G[v].size();i++){\n\t\t\tif(D_G[v][i].c>0&&D_level[D_G[v][i].t]<0){\n\t\t\t\tD_level[D_G[v][i].t]=D_level[v]+1;\n\t\t\t\tQ.push(D_G[v][i].t);\n\t\t\t}\n\t\t}\n\t}\n}\nint D_dfs(int v,int t,int f){\n\tif(v==t)return f;\n\tfor(;D_iter[v]<D_G[v].size();D_iter[v]++){\n\t\tint i=D_iter[v];\n\t\tif(D_G[v][i].c>0&&D_level[v]<D_level[D_G[v][i].t]){\n\t\t\tint d=D_dfs(D_G[v][i].t,t,min(f,D_G[v][i].c));\n\t\t\tif(d>0){\n\t\t\t\tD_G[v][i].c-=d;\n\t\t\t\tD_G[D_G[v][i].t][D_G[v][i].r].c+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s,int t){\n\tint flow=0;\n\tfor(;;){\n\t\tD_bfs(s);\n\t\tif(D_level[t]<0)return flow;\n\t\tfor(int i=0;i<D_v_size;i++)D_iter[i]=0;\n\t\tint f;\n\t\twhile((f=D_dfs(s,t,99999999))>0){flow+=f;}\n\t}\n\treturn 0;\n}\nint c,d;\nint vis[1100];\nint dfs(int u,int v){\n\tif(u==v){\n\t\treturn 1;\n\t}\n\tvis[u]=1;\n\tfor(int i=0;i<D_G[u].size();i++){\n\t\tif(vis[D_G[u][i].t])continue;\n\t\tif(!D_G[u][i].c)continue;\n\t\tif(dfs(D_G[u][i].t,v)){\n\t\t\tD_G[u][i].c--;\n\t\t\tD_G[D_G[u][i].t][D_G[u][i].r].c++;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint Minus(int s,int t){\n\tfor(int i=0;i<D_G[s].size();i++){\n\t\tif(D_G[s][i].t==t){\n\t\t\tif(D_G[s][i].c){\n\t\t\t\tD_G[s][i].c--;return 0;\n\t\t\t}else{\n\t\t\t\tfor(int j=0;j<1100;j++)vis[j]=0;\n\t\t\t\tif(dfs(s,t))return 0;\n\t\t\t\tfor(int j=0;j<1100;j++)vis[j]=0;\n\t\t\t\tdfs(d,t);\n\t\t\t\tfor(int j=0;j<1100;j++)vis[j]=0;\n\t\t\t\tdfs(s,c);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n}\nint Plus(int s,int t){\n\tfor(int i=0;i<D_G[s].size();i++){\n\t\tif(D_G[s][i].t==t){D_G[s][i].c++;break;}\n\t}\n\tfor(int j=0;j<1100;j++)vis[j]=0;\n\treturn dfs(c,d);\n}\nint p[11000];\nint q[11000];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d%d%d\",&a,&b,&c,&d),a){\n\t\tc--;d--;\n\t\tfor(int i=0;i<2002;i++){\n\t\t\tD_G[i].clear();\n\t\t\tD_level[i]=D_iter[i]=0;\n\t\t}\n\t\tfor(int i=0;i<b;i++){\n\t\t\tscanf(\"%d%d\",p+i,q+i);\n\t\t\tp[i]--;q[i]--;\n\t\t\tadd_edge(p[i],q[i],1);\n\t\t}\n\t\tint v=max_flow(c,d);\n\t\tint ret=0;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint t1=Minus(p[i],q[i]);\n\t\t\tint t2=Plus(q[i],p[i]);\n\t\t//\tprintf(\"%d %d: %d %d\\n\",p[i],q[i],t1,t2);\n\t\t\tif(t1==0&&t2){\n\t\t\t\t\n\t\t\t\tret++;\n\t\t\t}\n\t\t\tMinus(q[i],p[i]);\n\t\t\tPlus(p[i],q[i]);\n\t\t}\n\t\tif(ret==0)printf(\"%d %d\\n\",v,ret);\n\t\telse printf(\"%d %d\\n\",v+1,ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconstexpr ll mod = 998244353;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acos(-1.0);\n\nll mod_pow(ll x, ll n, ll m) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * x % m;\n\t\tx = x * x % m; n >>= 1;\n\t}\n\treturn res;\n}\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n % mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint& a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint& a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint& a, modint b) { a.n = ((ll)a.n * b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, ll n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a * a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 22;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nll gcd(ll a, ll b) {\n\tif (a < b)swap(a, b);\n\twhile (b) {\n\t\tll r = a % b; a = b; b = r;\n\t}\n\treturn a;\n}\n\n#include<cstring>\nstruct edge { int to, cap, rev; bool isrev; };\nvector<edge> G[1000];\nbool used[1000];\nvoid add_edge(int from, int to, int cap) {\n\tG[from].push_back(edge{ to, cap, (int)G[to].size(),false });\n\tG[to].push_back(edge{ from, 0, (int)G[from].size() - 1,true });\n}\nint dfs(int v, int t, int f) {\n\tif (v == t)return f;\n\tused[v] = true;\n\tfor (int i = 0; i < (int)G[v].size(); i++) {\n\t\tedge& e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint n, m;\nint max_flow(int s, int t, int sup = mod) {\n\tint flow = 0;\n\trep(i, sup) {\n\t\tfill(used, used + n, false);\n\t\tint f = dfs(s, t, mod);\n\t\tif (f == 0)return flow;\n\t\tflow += f;\n\t}\n\treturn flow;\n}\n\n\n\nbool visited[1000];\nint s, t;\nvoid solve() {\n\ts--; t--;\n\trep(i, n) {\n\t\tG[i].clear();\n\t}\n\trep(i, m) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tadd_edge(a, b, 1);\n\t}\n\tint f = max_flow(s, t);\n\n\tint cnt = 0;\n\t/*rep(x, n)for (edge e : G[x]) {\n\t\tif (!e.isrev && e.cap == 0) {\n\t\t\tcout << x << \" \" << e.to << \"\\n\";\n\t\t}\n\t}*/\n\tvector<vector<int>> g(n), rg(n);\n\trep(i, n)for (edge e : G[i]) {\n\t\tif (e.isrev) {\n\t\t\tif (e.cap) {\n\t\t\t\tg[i].push_back(e.to);\n\t\t\t\trg[e.to].push_back(i);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (e.cap) {\n\t\t\t\tg[i].push_back(e.to);\n\t\t\t\trg[e.to].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tvector<bool> cans(n, false), cant(n, false);\n\tqueue<int> q;\n\tcans[s] = true; q.push(s);\n\twhile (!q.empty()) {\n\t\tint id = q.front(); q.pop();\n\t\tfor (int to : g[id]) {\n\t\t\tif (!cans[to]) {\n\t\t\t\tcans[to] = true;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t}\n\tcant[t] = true; q.push(t);\n\twhile (!q.empty()) {\n\t\tint id = q.front(); q.pop();\n\t\tfor (int to : rg[id]) {\n\t\t\tif (!cant[to]) {\n\t\t\t\tcant[to] = true;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, n)for (edge e : G[i]) {\n\t\tif (!e.isrev && e.cap) {\n\t\t\tif (cans[e.to] && cant[i])cnt++;\n\t\t}\n\t}\n\n\tif (cnt==0) {\n\t\tcout << f << \" \" << 0 << \"\\n\";\n\t}\n\telse {\n\t\tcout << f+1 << \" \" << cnt << \"\\n\";\n\t}\n}\n\n\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//init_f();\n\t//expr();\n\t//int t; cin >> t; rep(i, t)\n\twhile (cin >> n >> m >> s >> t, n)\n\t\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\n#define MAX_V 1001\nusing namespace std;\ntypedef map<int,int> M;\ntypedef M::iterator Mit;\nM G[MAX_V],rG[MAX_V],g[MAX_V];\nint used[MAX_V];  \n\nint dfs(int v,int t,int f){\n  if(v == t)return f;\n  used[v]=true;\n  \n  for(Mit it=G[v].begin();it!=G[v].end() ;it++){\n    int to=it->first;\n    int &cap=it->second;\n    if(!used[to] && cap > 0){\n      int d = dfs(to ,t , min(f,cap));\n      if(d > 0){\n\tcap -= d;\n\tG[to][v]+=d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s, t, INF);\n    if(f == 0)return flow;\n    flow += f;\n  }\n}\n\nbool visited[MAX_V];\nvoid visit(int pos){\n  if(visited[pos])return;\n  visited[pos]=1;\n  for(Mit it=rG[pos].begin();it!=rG[pos].end() ;it++)visit(it->first);\n}\n\nint check2(int pos){\n  if(used[pos]++) return 0;\n  int res=0; \n  for(Mit it=G[pos].begin();it!=G[pos].end() ;it++)\n    if(it->second)res+=check2(it->first);\n  \n  for(Mit it=g[pos].begin();it!=g[pos].end() ;it++)\n    res+=(it->second)*visited[it->first];\n  \n  return res;\n}\n\nint main(){\n  while(1){\n    int n,m,s,t;\n    cin>>n>>m>>s>>t;\n    if(!n&&!m&&!s&&!t)break;\n    s--,t--;\n    for(int i=0;i<n;i++) rG[i].clear(),G[i].clear(),g[i].clear();\n    \n    for(int i=0,a,b;i<m;i++){\n      cin>>a>>b;\n      a--,b--;\n      G[a][b]++;\n      g[b][a]++;\n    }\n\n    int mx=max_flow(s,t);\n    for(int i=0;i<n;i++)\n      for(Mit it=G[i].begin();it!=G[i].end() ;it++){\n\tint to=it->first,cap=it->second;\n\tif(cap)rG[to][i]=cap;\n      }\n    \n    memset(visited,0,sizeof(visited));\n    memset(used,0,sizeof(used));\n    visit(t);\n    int cnt=check2(s);\n    cout<<mx+(cnt>0)<<\" \"<<cnt<<endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 1005\n\nenum Type{\n\tFROM_S,\n\tFROM_T,\n};\n\n\n//辺を表す構造体(行先、容量、逆辺のインデックス)\nstruct Edge{\n\tEdge(int arg_to,int arg_capacity,int arg_rev_index,bool arg_is_rev){\n\t\tto = arg_to;\n\t\tcapacity = arg_capacity;\n\t\trev_index = arg_rev_index;\n\t\tis_rev = arg_is_rev;\n\t}\n\tint to,capacity,rev_index;\n\tbool is_rev;\n};\n\nint V,E;\nint N,M,S,T;\n\nvector<Edge> G[NUM]; //グラフの隣接リスト表現\nint dist[NUM]; //sourceからの距離\nint cheked_index[NUM]; //どこまで調べ終わったか\nbool can_reach[2][NUM]; //S,Tから各点へ到達できるかのチェック\n\n//fromからtoへ向かう容量capacityの辺をグラフに追加する\nvoid add_edge(int from,int to,int capacity){\n\tG[from].push_back(Edge(to,capacity,G[to].size(),false));\n\tG[to].push_back(Edge(from,0,G[from].size()-1,true)); //逆辺の、初期容量は0\n}\n\n//sourceからの最短距離をBFSで計算する\nvoid bfs(int source){\n\tfor(int i = 0; i < V; i++)dist[i] = -1;\n\tqueue<int> Q;\n\tdist[source] = 0;\n\tQ.push(source);\n\n\twhile(!Q.empty()){\n\t\tint node_id = Q.front();\n\t\tQ.pop();\n\t\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\t\tEdge &e = G[node_id][i];\n\t\t\tif(e.capacity > 0 && dist[e.to] < 0){ //辺の容量が正で、かつエッジの行先に未訪問の場合\n\t\t\t\tdist[e.to] = dist[node_id]+1;\n\t\t\t\tQ.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\n//増加パスをDFSで探す\nint dfs(int node_id,int sink,int flow){\n\tif(node_id == sink)return flow; //終点についたらflowをreturn\n\n\tfor(int &i = cheked_index[node_id]; i < G[node_id].size(); i++){ //node_idから出ているエッジを調査\n\t\tEdge &e = G[node_id][i];\n\t\tif(e.capacity > 0 && dist[node_id] < dist[e.to]){ //流せる余裕があり、かつsourceからの距離が増加する方法である場合\n\t\t\tint tmp_flow = dfs(e.to,sink,min(flow,e.capacity)); //流せるだけ流す\n\t\t\tif(tmp_flow > 0){ //流せた場合\n\t\t\t\te.capacity -= tmp_flow; //流した分、エッジの容量を削減する\n\t\t\t\tG[e.to][e.rev_index].capacity += tmp_flow; //逆辺の容量を、流した分だけ増加させる\n\t\t\t\treturn tmp_flow;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n//sourceからsinkへの最大流を求める\nint max_flow(int source,int sink){ //source:始点 sink:終点\n\tint flow = 0,add;\n\twhile(true){ //増加パスが存在する限り、流量を追加し続ける\n\t\tbfs(source);\n\t\tif(dist[sink] < 0)break; //sourceからsinkへと辿り着く残余グラフがない、つまり増加パスが無くなった場合、break\n\t\tfor(int i = 0; i < V; i++)cheked_index[i] = 0;\n\t\twhile((add = dfs(source,sink,BIG_NUM)) > 0){ //増加パスが見つかる間、加算\n\t\t\tflow += add;\n\t\t}\n\t}\n\treturn flow;\n}\n\n\n\n//あらかじめ、S,Tから行けないノードを特定しておく\nvoid reach_check(Type type,int node_id){\n\n\tcan_reach[type][node_id] = true;\n\tint base;\n\n\tif(type == FROM_S){\n\t\tbase = 1;\n\t}else{\n\t\tbase = 0; //★逆向きに進めれば良いため★\n\t}\n\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\tif(G[node_id][i].capacity == base && can_reach[type][G[node_id][i].to] == false){\n\t\t\treach_check(type,G[node_id][i].to);\n\t\t}\n\t}\n}\n\n\n\nvoid func(){\n\n\tfor(int i = 0; i < N; i++){\n\t\tG[i].clear();\n\t\tcan_reach[FROM_S][i] = false;\n\t\tcan_reach[FROM_T][i] = false;\n\t}\n\n\tS--;\n\tT--;\n\n\tint from,to;\n\tfor(int loop = 0; loop < M; loop++){\n\t\tscanf(\"%d %d\",&from,&to);\n\t\tfrom--;\n\t\tto--;\n\t\tadd_edge(from,to,1);\n\t}\n\n\tV = N;\n\n\tint FLOW = max_flow(S,T);\n\tint MAX_FLOW = FLOW;\n\n\treach_check(FROM_S,S);\n\treach_check(FROM_T,T);\n\n\tint num_edge = 0,diff;\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < G[i].size(); k++){\n\t\t\tif(G[i][k].is_rev == true || G[i][k].capacity == 0 ||\n\t\t\t\t\tcan_reach[FROM_S][G[i][k].to] == false || can_reach[FROM_T][i] == false)continue; //逆辺または、最大流達成のために使用した辺はSKIP\n\n\t\t\t//★★経路に重なりがあるかも知れないので、仮にcan_reachが両方trueでも、流量が1増えるとは限らない★★\n\n\t\t\t//最大流達成の際に使用していない辺のみ、向きを逆転させれば、総経路が1増える可能性がある\n\n\t\t\t//辺の向きを逆転させる\n\t\t\tG[i][k].capacity = 0;\n\t\t\tG[G[i][k].to][G[i][k].rev_index].capacity = 1;\n\n\t\t\t//S→T方向に流す\n\t\t\tdiff = max_flow(S,T);\n\n\t\t\tif(diff == 1){ //流量が増加した場合\n\t\t\t\tnum_edge++;\n\t\t\t\tMAX_FLOW = FLOW+1;\n\n\t\t\t\tif(i != T){\n\t\t\t\t\tmax_flow(T,i); //T→iに押し戻す\n\t\t\t\t}\n\t\t\t\tif(G[i][k].to != S){\n\t\t\t\t\tmax_flow(G[i][k].to,S); //G[i][k].to→Sに押し戻す\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//辺の向きを元に戻す\n\t\t\tG[i][k].capacity = 1;\n\t\t\tG[G[i][k].to][G[i][k].rev_index].capacity = 0;\n\t\t}\n\t}\n\n\tprintf(\"%d %d\\n\",MAX_FLOW,num_edge);\n}\n\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d %d %d\",&N,&M,&S,&T);\n\t\tif(N == 0 && M == 0 && S == 0 && T == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_V 1005\n#define INF 1e9\nusing namespace std;\n\n/*?????§???(Dinic???) O(|E||V|^2)*/\n//????????¨????§???????(???????????????????????????)\nstruct edge{int to, cap, rev, s;};\nvector<edge> G[MAX_V]; //??°???????????£??\\???????????¨???\nint level[MAX_V];      //s??????????????¢\nint iter[MAX_V];       //???????????§??????????????£??????\n//????????¨????§???????(???????????????????????????)\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size(),0});\n  G[to].push_back((edge){from,0,(int)G[from].size()-1,1});  \n}\n\n//s????????????????????¢???BFS??§?¨??????????\nvoid bfs(int s){\n  memset(level,-1,sizeof(level));\n  queue<int> que;\n  level[s] = 0;\n  que.push(s);\n  while(!que.empty()){\n    int v = que.front(); que.pop();\n    for(int i=0; i<G[v].size(); i++){\n      edge &e = G[v][i];\n      if(e.cap > 0 && level[e.to] < 0){\n\tlevel[e.to] = level[v] + 1;\n\tque.push(e.to);\n      }\n    }\n  }\n}\n\n//?¢?????????????DFS??§??¢??????\nint dfs(int v,int t,int f){\n  if(v==t) return f;\n  for(int &i= iter[v]; i<G[v].size(); i++){\n    edge &e = G[v][i];\n    if(e.cap > 0 && level[v] < level[e.to]){\n      int d = dfs(e.to, t, min(f, e.cap));\n      if(d > 0){\n\te.cap -= d;\n\tG[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\n//s??????t???????????§???????±???????\nint max_flow(int s,int t,int maxf){\n  int flow=0;\n  for(;;){\n    bfs(s);\n    if(maxf==0||level[t] < 0) return flow;\n    memset(iter,0,sizeof(iter));\n    int f;\n    while((f=dfs(s ,t ,maxf)) > 0 ) flow += f, maxf-=f;\n  }\n}\n\nint n, m, s, t;\n\nvoid solve(){\n  \n  int r = max_flow(s, t, INF);\n  int maxflow=r;\n  \n  unordered_map<int,int> cnt;\n  \n  for(int i=1;i<=n;i++){\n    \n    for(int j=0;j<G[i].size();j++){\n      \n      edge &s1 = G[i][j];\n      edge &t1 = G[s1.to][s1.rev];\n      \n      if(s1.s) continue;\n      if(t1.cap==1) continue;\n\n      int f1=max_flow(s,s1.to,1);\n\n      int f2=max_flow(i,t,1);\n      \n      int f=r;\n      \n      if(f1&&f2) f=r+1;\n      \n      if(f1) max_flow(s1.to,s,1);\n      \n      if(f2) max_flow(t,i,1);\n      \n      if(maxflow<f) maxflow=f;\n      \n      cnt[f]++;\n      \n    }\n    \n  }\n\n  int revcnt=0;\n\n  if(r<maxflow){\n    for(pair<int,int> d : cnt)\n      if(maxflow==d.first) revcnt+=d.second;\n  }\n  \n  cout<<maxflow<<' '<<revcnt<<endl;\n  \n}\n\nvoid init(){\n  for(int i=0;i<MAX_V;i++) G[i].clear();\n}\n\nint main(){\n\n  while(1){\n    \n    cin>>n>>m>>s>>t;\n    if(!n&&!m&&!s&&!t) break;\n\n    init();\n    \n    for(int i=0;i<m;i++){\n      int a, b;\n      cin>>a>>b;\n      add_edge(a,b,1);\n    }\n  \n    solve();\n  }\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\nconst double EPS = 1e-9;\nconst ll mod = 1000000007;\nconst int inf = 1 << 30;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n\n#define MAX_V 2000\n\nstruct edge{int to, cap, rev; bool ori;};\n\nvector<edge> G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\nbool reach[2][MAX_V];\n\nvoid add_edge(int from, int to, int cap){\n    G[from].push_back((edge){to, cap, G[to].size(), true});\n    G[to].push_back((edge){from, 0, G[from].size()-1, false});\n}\n\nvoid bfs(int s){\n    memset(level,-1,sizeof(level));\n    queue<int> que;\n    level[s] = 0;\n    que.push(s);\n    while(!que.empty()){\n        int v = que.front(); que.pop();\n        for(int i = 0; i < G[v].size(); i++){\n            edge &e = G[v][i];\n            if(e.cap > 0 && level[e.to] < 0){\n                level[e.to] = level[v]+1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\nint dfs(int v, int t, int f){\n    if(v == t) return f;\n    for(int &i = iter[v]; i < G[v].size(); i++){\n        edge &e = G[v][i];\n        if(e.cap > 0 && level[v] < level[e.to]){\n            int d = dfs(e.to, t, min(f,e.cap));\n            if(d > 0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t){\n    int flow = 0;\n    for(;;){\n        bfs(s);\n        if(level[t] < 0) return flow;\n        memset(iter,0, sizeof(iter));\n        int f;\n        while((f = dfs(s, t, inf)) > 0){\n            flow += f;\n        }\n    }\n}\n\nvoid reachbfs(int s, int ind){\n    queue<int> que;\n    que.push(s);\n    reach[ind][s] = true;\n    while(!que.empty()){\n        int v = que.front(); que.pop();\n        for(int i = 0; i < G[v].size(); i++){\n            edge &e = G[v][i];\n            if(e.cap != ind && !reach[ind][e.to]) {\n                reach[ind][e.to] = true;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\nint n, m, s, t;\n\nvoid solve() {\n    rep(i,MAX_V) G[i].clear();\n    s--; t--;\n    rep(i,m) {\n        int a, b; cin >> a >> b;\n        a--; b--;\n        add_edge(a, b, 1);\n    }\n    int f = max_flow(s,t);\n    memset(reach, 0, sizeof(reach));\n    reachbfs(s, 0);\n    reachbfs(t, 1);\n\n    int cnt = 0;\n    rep(i,n) {\n        rep(j,G[i].size()) {\n            if (G[i][j].ori) continue;\n            if (reach[0][i] && reach[1][G[i][j].to]) cnt++;\n        }\n    }\n    if (cnt == 0) cout << f << \" \" << 0 << endl;\n    else cout << f+1 << \" \" << cnt << endl;\n}\n\nint main() {\n#ifndef LOCAL\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n    cout.precision(20);\n    cerr << fixed;\n    cerr.precision(6);\n#ifdef LOCAL\n    //freopen(\"in.txt\", \"wt\", stdout); //for tester\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif  \n    while (cin >> n >> m >> s >> t) {\n        if (n == 0 && m == 0 && s == 0 && t == 0) break;\n        solve();\n    }\n    //cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n// (行き先,容量,逆辺)\nstruct edge{ int to,cap,rev; };\n\nconst int MAX_V = 1000; // TODO:initialize\nconst int F_INF = 1234567; // TODO:initialize\nvector<edge> G[MAX_V];\nint level[MAX_V]; // sからの距離\nint iter[MAX_V]; // どこまで調べ終わったか\n\nvoid add_edge(int from, int to, int cap){\n    G[from].pb({to,cap,(int)G[to].size()});\n    G[to].pb({from,0,(int)G[from].size()-1});\n}\n\nvoid dinic_bfs(int s){\n    memset(level,-1,sizeof(level));\n    queue<int> que;\n    level[s]=0;\n    que.push(s);\n    while(!que.empty()){\n        int v = que.front();\n        que.pop();\n        rep(i,G[v].size()){\n            edge &e = G[v][i];\n            if(e.cap>0 && level[e.to]<0){\n                level[e.to] = level[v]+1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\n// 増加パスをdfsで探す\nint dinic_dfs(int v, int t, int f){\n    if(v==t) return f;\n    for(int &i=iter[v]; i<(int)G[v].size(); ++i){\n        edge &e=G[v][i];\n        if(e.cap>0 && level[v]<level[e.to]){\n            int d = dinic_dfs(e.to,t,min(f,e.cap));\n            if(d>0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\n// sからtへの最大流\nint max_flow(int s, int t){\n    int flow = 0;\n    while(1){\n        dinic_bfs(s);\n        if(level[t]<0) return flow;\n        memset(iter,0,sizeof(iter));\n        int f;\n        while((f=dinic_dfs(s,t,F_INF))>0) flow+=f;\n    }\n}\n\n\nbool vs[MAX_V],vt[MAX_V];\nvoid dfs_s(int x){\n    vs[x] = true;\n    for(const auto &e:G[x]){\n        if(e.cap>0 && !vs[e.to]) dfs_s(e.to);\n    }\n}\nvoid dfs_t(int x){\n    vt[x] = true;\n    for(const auto &e:G[x]){\n        if(e.cap==0 && !vt[e.to]) dfs_t(e.to);\n    }\n}\n\nint main(){\n    int n,m,s,t;\n    while(scanf(\" %d %d %d %d\", &n, &m, &s, &t),n){\n        rep(i,MAX_V) G[i].clear();\n        fill(vs,vs+MAX_V,false);\n        fill(vt,vt+MAX_V,false);\n\n        --s;\n        --t;\n\n        vector<int> a(m),b(m);\n        rep(i,m){\n            scanf(\" %d %d\", &a[i], &b[i]);\n            --a[i];\n            --b[i];\n            add_edge(a[i],b[i],1);\n        }\n\n        int f = max_flow(s,t);\n\n        dfs_s(s);\n        dfs_t(t);\n\n        int num = 0;\n        rep(i,m){\n            if(vs[b[i]] && vt[a[i]]) ++num;\n        }\n        if(num) ++f;\n\n        printf(\"%d %d\\n\", f,num);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\n#define MAX_V 1001\nusing namespace std;\ntypedef map<int,int> M;\ntypedef M::iterator Mit;\nM G[MAX_V],rG[MAX_V],g[MAX_V];\nint used[MAX_V];  \n\nint dfs(int v,int t,int f){\n  if(v == t)return f;\n  used[v]=true;\n  \n  for(Mit it=G[v].begin();it!=G[v].end() ;it++){\n    int to=it->first;\n    int &cap=it->second;\n    if(!used[to] && cap > 0){\n      int d = dfs(to ,t , min(f,cap));\n      if(d > 0){\n\tcap -= d;\n\tG[to][v]+=d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s, t, INF);\n    if(f == 0)return flow;\n    flow += f;\n  }\n}\n\nbool visited[MAX_V];\nvoid visit(int pos){\n  visited[pos]=1;\n  for(Mit it=rG[pos].begin();it!=rG[pos].end() ;it++)\n    if(!visited[it->first])visit(it->first);\n}\n\nint check2(int pos){\n  if(used[pos]++) return 0;\n  int res=0; \n  for(Mit it=G[pos].begin();it!=G[pos].end() ;it++)\n    if(it->second)res+=check2(it->first);\n  \n  for(Mit it=g[pos].begin();it!=g[pos].end() ;it++)\n    res+=(it->second)*visited[it->first];\n  \n  return res;\n}\n\nint main(){\n  while(1){\n    int n,m,s,t;\n    cin>>n>>m>>s>>t;\n    if(!n&&!m&&!s&&!t)break;\n    s--,t--;\n    for(int i=0;i<n;i++) rG[i].clear(),G[i].clear(),g[i].clear();\n    \n    for(int i=0,a,b;i<m;i++){\n      cin>>a>>b;\n      a--,b--;\n      G[a][b]++;\n      g[b][a]++;\n    }\n\n    int mx=max_flow(s,t);\n    for(int i=0;i<n;i++)\n      for(Mit it=G[i].begin();it!=G[i].end() ;it++){\n\tint to=it->first,cap=it->second;\n\tif(cap)rG[to][i]=cap;\n      }\n    \n    memset(visited,0,sizeof(visited));\n    memset(used,0,sizeof(used));\n    visit(t);\n    int cnt=check2(s);\n    cout<<mx+(cnt>0)<<\" \"<<cnt<<endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_V 10000\n#define INF 1e9\nusing namespace std;\n\n/*????°??????¨???(???????????£????????????????????¨) O(F|V||E|)*/\n\n//????????¨????§???????(???????????????????????????????????????)\nstruct edge{int to, cap,cost,rev;};\nint V;                         //????????°\nvector<edge> G[MAX_V];         //??°???????????£??\\???????????¨???\nint dist[MAX_V];               //???????????¢\nint prevv[MAX_V],preve[MAX_V]; //??´??????????????¨???\n\n// from??????to??????????????????cap????????????cost???????????°????????????????????????\nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back((edge){to,cap,cost,G[to].size()});\n  G[to].push_back((edge){from,0,-cost,G[from].size()-1});\n}\n\n//s??????t????????????f???????°??????¨???????±???????\n//??????????????´???-1?????????\nint min_cost_flow(int s,int t,int f){\n  int res=0;\n  while(f>0){\n    //????????????????????????????????????,s-t????????????????±???????\n    fill(dist,dist+V,INF);\n    dist[s]=0;\n    bool update = true;\n    while(update){\n      update = false;\n      for(int v=0; v<V ;v++){\n\tif(dist[v]==INF) continue;\n\tfor(int i=0; i<G[v].size(); i++){\n\t  edge &e = G[v][i];\n\t  if(e.cap > 0 && dist[e.to] > dist[v]+e.cost) {\n\t    dist[e.to] = dist[v] + e.cost;\n\t    prevv[e.to] = v;\n\t    preve[e.to] = i;\n\t    update = true;\n\t  }\n\t}\n      }\n    }\n    if(dist[t]==INF) return -1; //????????\\??????????????????\n    \n    //s???t?????????????????£??????????????????\n    int d = f;\n    for(int v=t; v!=s; v=prevv[v])d=min(d,G[prevv[v]][preve[v]].cap);\n    f -= d;\n    res += d*dist[t];\n    for(int v=t; v!=s; v=prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\ntypedef pair<int,int> P;\nint main(){\n  while(1){\n  int n,m,s,t;\n  cin>>n>>m>>s>>t;\n  if(!n&&!m&&!s&&!t)break;\n  V=n;\n  s--,t--;\n  for(int i=0;i<MAX_V;i++) G[i].clear();\n  \n  for(int i=0,a,b;i<m;i++){\n    cin>>a>>b;\n    a--,b--;\n    add_edge(a,b,1,0);\n    add_edge(b,a,1,1);\n  }\n  \n  int cost,mx=0,cnt=0;\n  while(!(cost=min_cost_flow(s,t,1)))mx++;\n  if(cost==1)mx++;\n  \n  while(cost==1){\n    cnt++;\n    int i,j;\n    for(int v=t; v!=s; v=prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      if(e.cost>0)i=prevv[v],j=preve[v];\n    }\n    min_cost_flow(t,s,1);\n    edge &e=G[i][j];\n    e.cap = 0;\n    G[e.to][e.rev].cap=0;\n    cost=min_cost_flow(s,t,1);\n  }  \n  cout<<mx<<\" \"<<cnt<<endl;\n  }  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<typename T> T inf() { assert(false); }\ntemplate<> constexpr int inf<int>() { return 1e9; }\ntemplate<> constexpr ll inf<ll>() { return 1e18; }\ntemplate<> constexpr ld inf<ld>() { return 1e30; }\n/*--------------------template--------------------*/\n\ntemplate <typename Flow>\nstruct FEdge {\n\tint from, to;\n\tFlow cap; int rev;\n\tFEdge(int s, int t, Flow f, int r) : from(s), to(t), cap(f), rev(r) {}\n};\n\ntemplate<typename Flow> using FGraph = vector<vector<FEdge<Flow>>>;\n\ntemplate <typename Flow>\nvoid add_edge(FGraph<Flow> &g, int from, int to, Flow cap) {\n\tg[from].emplace_back(from, to, cap, (int)g[to].size());\n\tg[to].emplace_back(to, from, 0, (int)g[from].size() - 1);\n}\n\ntemplate <typename Flow>\nFlow augment(FGraph<Flow> &g, vector<Flow> &d, vector<int> &iter,\n\tint v, int t, const Flow &f) {\n\tif (v == t) return f;\n\tfor (int &i = iter[v]; i < (int)g[v].size(); i++) {\n\t\tauto &e = g[v][i];\n\t\tif (e.cap > 0 && d[v] < d[e.to]) {\n\t\t\tFlow ff = augment(g, d, iter, e.to, t, min(f, e.cap));\n\t\t\tif (ff > 0) {\n\t\t\t\te.cap -= ff;\n\t\t\t\tg[e.to][e.rev].cap += ff;\n\t\t\t\treturn ff;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\ntemplate <typename Flow>\nFlow max_flow(FGraph<Flow> &g, int s, int t, Flow zero = 0) {\n\tconst int V = g.size();\n\tFlow flow = zero;\n\tfor (;;) {\n\t\tvector<Flow> d(V, -1);\n\t\tqueue<int> que;\n\t\td[s] = zero;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (const auto &e : g[v]) {\n\t\t\t\tif (e.cap <= zero || d[e.to] >= zero) continue;\n\t\t\t\td[e.to] = d[v] + 1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t\tif (d[t] < zero) return flow;\n\t\tvector<int> iter(V, 0);\n\t\tFlow f;\n\t\twhile ((f = augment(g, d, iter, s, t, inf<Flow>())) > 0) flow += f;\n\t}\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint n, m, s, t;\n\twhile (cin >> n >> m >> s >> t, n)\n\t{\n\t\ts--; t--;\n\t\tFGraph<int> g(n);\n\t\tmap<pii, int> st;\n\t\tREP(i, m)\n\t\t{\n\t\t\tint a, b; cin >> a >> b;\n\t\t\ta--; b--;\n\t\t\tadd_edge(g, a, b, 1);\n\t\t\tst[pii(a, b)]++;\n\t\t}\n\t\tint fl = max_flow(g, s, t);\n\t\tvi vis(n);\n\t\tvis[s] = 1;\n\t\tqueue<int> que;\n\t\tque.push(s);\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tint t = que.front();\n\t\t\tque.pop();\n\t\t\tfor (auto e : g[t])\n\t\t\t{\n\t\t\t\tif (e.cap == 0) continue;\n\t\t\t\tint nx = e.to;\n\t\t\t\tif (vis[nx]) continue;\n\t\t\t\tvis[nx] = 1;\n\t\t\t\tque.push(nx);\n\t\t\t}\n\t\t}\n\t\twhile (!que.empty()) que.pop();\n\t\tvis[t] = -1;\n\t\tque.push(t);\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tint t = que.front();\n\t\t\tque.pop();\n\t\t\tfor (auto e : g[t])\n\t\t\t{\n\t\t\t\tif (e.cap == 1) continue;\n\t\t\t\tint nx = e.to;\n\t\t\t\tif (vis[nx]) continue;\n\t\t\t\tvis[nx] = -1;\n\t\t\t\tque.push(nx);\n\t\t\t}\n\t\t}\n\t\tvi v1, v2;\n\t\tREP(i, n)\n\t\t{\n\t\t\tif (vis[i] == 1) v1.push_back(i);\n\t\t\telse if(vis[i] == -1) v2.push_back(i);\n\t\t}\n\t\tint add = 0;\n\t\tfor (auto i : v1)for (auto j : v2)\n\t\t{\n\t\t\tadd += st[pii(j, i)];\n\t\t}\n\t\tif (add) fl++;\n\t\tcout << fl << \" \" << add << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n\n\n#define _GLIBCXX_DEBUG\n\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(auto i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\n\n//const int INF = 2147483647;\n//const long long int L_INF = 9223372036854775807;\n\ntypedef int Weight;\n\nconst Weight INF = INT_MAX;\nconst Weight ZERO = 0;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n#define RESIDUE(s,t) (capacity[s][t]-flow[s][t])\n\n//??????0??????????????????????????¨??£???????±??????????????????§??¨???\n\nint a = 0;\nvector<vector<int>>froms(2);\nWeight maximumFlow(const Graph &ag, int s, int t) {\n\n\tGraph g(ag);\n\tfor (int i = 0; i < ag.size(); ++i) {\n\t\tfor (int j = 0; j < ag[i].size(); ++j) {\n\t\t\tint d = ag[i][j].dst;\n\t\t\tint s = ag[i][j].src;\n\n\t\t\tbool ok = false;\n\t\t\tfor (int k = 0; k < ag[d].size(); ++k) {\n\t\t\t\tif (ag[d][k].src == s) {\n\t\t\t\t\tok = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!ok) {\n\t\t\t\tg[d].push_back(Edge(d, s, ZERO));\n\t\t\t}\n\t\t}\n\t}\n\tint n = g.size();\n\tMatrix flow(n, Array(n,ZERO)), capacity(n, Array(n,ZERO));\n\tREP(u, n) FOR(e, g[u]) capacity[e->src][e->dst] =capacity[e->src][e->dst]+ e->weight;\n\n\n\tWeight total = ZERO;\n\twhile (1) {\n\t\tqueue<int> Q; Q.push(s);\n\t\tvector<int> prev(n, -1); prev[s] = s;\n\t\twhile (!Q.empty() && prev[t] < 0) {\n\t\t\tint u = Q.front(); Q.pop();\n\t\t\tFOR(e, g[u]) if (prev[e->dst] < 0 && RESIDUE(u, e->dst) > ZERO) {\n\t\t\t\tprev[e->dst] = u;\n\t\t\t\tQ.push(e->dst);\n\t\t\t}\n\t\t}\n\t\tif (prev[t] < 0)break; // prev[x] == -1 <=> t-side\n\t\tWeight inc = INF;\n\t\tfor (int j = t; prev[j] != j; j = prev[j]){\n\t\t\tauto v(RESIDUE(prev[j], j));\n\t\t\tif (inc > v) {\n\t\t\t\tinc = v;\n\t\t\t}\n\t\t}\n\t\tfor (int j = t; prev[j] != j; j = prev[j])\n\t\t\tflow[prev[j]][j] =flow[prev[j]][j]+inc, flow[j][prev[j]] =flow[j][prev[j]]- inc;;\n\t\ttotal += inc;\n\t}\n\t\n\t{\n\t\tfroms[a][s] = true;\n\t\tqueue<int>que;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint n = que.front();\n\t\t\tque.pop();\n\t\t\tfor (auto e : g[n]) {\n\t\t\t\tif (RESIDUE(e.src, e.dst) > 0&&!froms[a][e.dst]) {\n\t\t\t\t\tfroms[a][e.dst] = true;\n\t\t\t\t\tque.push(e.dst);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\ta++;\n\ta %= 2;\n\treturn total;\n}\n\nint main() {\n\twhile (1) {\n\t\tint N, M, S, T; cin >> N >> M >> S >> T;\n\t\tif (!N)break;\n\t\tfroms.clear();\n\t\tfroms.resize(2);\n\t\tfor (int i = 0; i < 2; ++i)froms[i].resize(N);\n\t\tS--; T--;\n\t\tfor (int i = 0; i < N; ++i) {\n\n\t\t}\n\t\tGraph g(N);\n\t\tGraph revg(N);\n\t\tvector<vector<int>>anums(2,vector<int>(N));\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint a, b; cin >> a >> b; a--; b--;\n\t\t\tanums[0][a]++;\n\t\t\tanums[1][b]++;\n\t\t\tauto it=find_if(g[a].begin(), g[a].end(), [=](const Edge&l) {\n\t\t\t\treturn l.dst == b;\n\t\t\t});\n\t\t\tauto revit = find_if(revg[b].begin(), revg[b].end(), [=](const Edge&l) {\n\t\t\t\treturn l.dst == a;\n\t\t\t});\n\t\t\tif(it==g[a].end()){\n\n\n\t\t\t\tg[a].push_back(Edge(a, b, 1));\n\t\t\t\trevg[b].push_back(Edge(b, a, 1));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tit->weight++;\n\t\t\t\trevit->weight++;\n\t\t\t}\n\t\t}\n\t\tint nf = maximumFlow(g, S, T);\n\t\tmaximumFlow(revg, T, S);\n\t\tint num=0;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor(auto e:revg[i]){\n\n\t\t\t\tif (froms[0][e.src] && froms[1][e.dst]) {\n\t\t\t\t\tnum += e.weight;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (num)nf++;\n\t\tcout << nf << \" \" << num << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <complex>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << (x) << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 10010\n\nstruct Dinic{\n  \n  struct edge {\n    int to, cap, rev;\n    edge(int a, int b, int c):to(a),cap(b),rev(c){}\n  };\n  \n  vector<vector<edge> > G;\n  vector<int> level, iter;\n  int MAX_V;\n  \n  Dinic(int max_v):G(max_v,vector<edge>()),MAX_V(max_v){}\n  \n  int add_edge(int from,int to,int cap){\n    int id = G[from].size();\n    \n    G[from].push_back(edge(to,cap,G[to].size()));\n    G[to].push_back(edge(from,0,G[from].size() - 1));\n    \n    return id;\n  }\n  \n  void bfs(int s){\n    level.assign(MAX_V,-1);\n    queue<int> q;\n    level[s] = 0;\n    q.push(s);\n    while(q.size()){\n      int v = q.front(); q.pop();\n      for(int i=0;i<G[v].size();i++){\n        edge &e = G[v][i];\n        if(e.cap > 0 && level[e.to] < 0){\n          level[e.to] = level[v] + 1;\n          q.push(e.to);\n        }\n      }\n    }\n  }\n  \n  int dfs(int v, int t, int f){\n    if(v == t) return f;\n    for(int &i = iter[v];i < G[v].size(); i++){\n      edge &e = G[v][i];\n      if(e.cap > 0 && level[v] < level[e.to]){\n        int d = dfs(e.to, t, min(f,e.cap));\n        if(d > 0){\n          e.cap -= d;\n          G[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n  \n  int solve(int s, int t){\n    int flow = 0;\n    while(1){\n      bfs(s);\n      if(level[t] < 0) return flow;\n      iter.assign(MAX_V,0);\n      int f;\n      while((f = dfs(s, t, INF)) > 0) flow += f;\n    }\n  }\n  \n};\n\nvoid BFS(vector<int> *G, int s, bool *visited){\n  queue<int> q;\n  q.push(s);\n\n  while(q.size()){\n    int p = q.front();\n    q.pop();\n\n    if(visited[p]) continue;\n    visited[p] = true;\n\n    for(int i=0;i<G[p].size();i++)\n      q.push(G[p][i]);\n  }\n}\n\nvoid solve(int n, int m, int s, int t){\n  int a[SIZE], b[SIZE];\n  int id[SIZE];\n  s--; t--;\n\n  vector<int> G[SIZE];\n  vector<int> rev[SIZE];\n  \n  Dinic dinic(n);\n\n  for(int i=0;i<m;i++){\n    scanf(\"%d%d\",a+i, b+i);\n    a[i]--; b[i]--;\n    id[i] = dinic.add_edge(a[i], b[i], 1);\n  }\n\n  int value = dinic.solve(s, t);\n\n  for(int i=0;i<m;i++){\n    if(dinic.G[a[i]][id[i]].cap){\n      G[a[i]].push_back(b[i]);\n      rev[b[i]].push_back(a[i]);\n    }else{\n      rev[a[i]].push_back(b[i]);\n      G[b[i]].push_back(a[i]);\n    }\n  }\n\n  bool visited1[SIZE] = {};\n  bool visited2[SIZE] = {};\n  int counter = 0;\n  \n  BFS(G, s, visited1);\n  BFS(rev, t, visited2);\n\n  for(int i=0;i<m;i++){\n    if(dinic.G[a[i]][id[i]].cap){\n      if(visited1[b[i]] && visited2[a[i]]){\n        counter++;\n      }\n    }\n  }\n\n  if(counter)\n    printf(\"%d %d\\n\",value+1, counter);\n  else\n    printf(\"%d %d\\n\",value, 0);\n  \n  return;\n}\n\nint main(){\n  int n,m,s,t;\n\n  while(1){\n    scanf(\"%d%d%d%d\",&n,&m,&s,&t);\n    if(n == 0) break;\n    solve(n,m,s,t);\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 1005\n\n\nstruct Edge{\n\tEdge(int arg_to,int arg_capacity,int arg_rev_index,bool arg_is_rev){\n\t\tto = arg_to;\n\t\tcapacity = arg_capacity;\n\t\trev_index = arg_rev_index;\n\t\tis_rev = arg_is_rev;\n\t}\n\tint to,capacity,rev_index;\n\tbool is_rev;\n};\n\nint V,E;\nint N,M,S,T;\n\nvector<Edge> G[NUM]; //グラフの隣接リスト表現\nbool used[NUM]; //DFSですでに調べたかのフラグ\n\n//fromからtoへ向かう容量capacityの辺をグラフに追加する\nvoid add_edge(int from,int to,int capacity){\n\tG[from].push_back(Edge(to,capacity,G[to].size(),false));\n\tG[to].push_back(Edge(from,0,G[from].size()-1,true)); //逆辺の、初期容量は0\n}\n\n//増加パスをDFSで探す\nint dfs(int node_id,int sink,int flow){\n\tif(node_id == sink)return flow; //終点についたらflowをreturn\n\tused[node_id] = true;\n\n\tfor(int i = 0; i < G[node_id].size(); i++){ //node_idから出ているエッジを調査\n\t\tEdge &e = G[node_id][i];\n\t\tif(used[e.to] == false && e.capacity > 0){ //エッジの先のノードに未訪問で、かつエッジに流す余裕がある場合\n\t\t\tint tmp_flow = dfs(e.to,sink,min(flow,e.capacity)); //流せるだけ流す\n\t\t\tif(tmp_flow > 0){ //流せた場合\n\t\t\t\te.capacity -= tmp_flow; //流した分、エッジの容量を削減する\n\t\t\t\tG[e.to][e.rev_index].capacity += tmp_flow; //逆辺の容量を、流した分だけ増加させる\n\t\t\t\treturn tmp_flow;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n//sourceからsinkへの最大流を求める\nint max_flow(int source,int sink){ //source:始点 sink:終点\n\tint flow = 0,add;\n\twhile(true){ //増加パスが存在する限り、流量を追加し続ける\n\t\tfor(int i = 0; i < V; i++)used[i] = false;\n\t\tadd = dfs(source,sink,BIG_NUM);\n\t\tif(add == 0)break;\n\t\tflow += add;\n\t}\n\treturn flow;\n}\n\nvoid func(){\n\n\tfor(int i = 0; i < N; i++){\n\t\tG[i].clear();\n\t}\n\n\tS--;\n\tT--;\n\n\tint from,to;\n\tfor(int loop = 0; loop < M; loop++){\n\t\tscanf(\"%d %d\",&from,&to);\n\t\tfrom--;\n\t\tto--;\n\t\tadd_edge(from,to,1);\n\t}\n\n\tV = N;\n\n\tint FLOW = max_flow(S,T);\n\tint MAX_FLOW = FLOW,diff;\n\n\tint num_edge = 0;\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < G[i].size(); k++){\n\t\t\tif(G[i][k].is_rev == true || G[i][k].capacity == 0)continue; //逆辺または、最大流達成のために使用した辺はSKIP\n\n\t\t\t//最大流達成の際に使用していない辺のみ、向きを逆転させれば、総経路が1増える可能性がある\n\n\t\t\t//辺の向きを逆転させる\n\t\t\tG[i][k].capacity = 0;\n\t\t\tG[G[i][k].to][G[i][k].rev_index].capacity = 1;\n\n\t\t\t//S→T方向に流す\n\t\t\tdiff = max_flow(S,T);\n\n\t\t\tif(diff == 1){ //流量が増加した場合\n\t\t\t\tnum_edge++;\n\t\t\t\tMAX_FLOW = FLOW+1;\n\n\t\t\t\tif(i != T){\n\t\t\t\t\tmax_flow(T,i); //T→iに押し戻す\n\t\t\t\t}\n\t\t\t\tif(G[i][k].to != S){\n\t\t\t\t\tmax_flow(G[i][k].to,S); //G[i][k].to→Sに押し戻す\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//辺の向きを元に戻す\n\t\t\tG[i][k].capacity = 1;\n\t\t\tG[G[i][k].to][G[i][k].rev_index].capacity = 0;\n\n\t\t\t//★★元々i→G[i][k].to間には流れがなかったので、流しなおす必要はない★★\n\t\t}\n\t}\n\n\tprintf(\"%d %d\\n\",MAX_FLOW,num_edge);\n}\n\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d %d %d\",&N,&M,&S,&T);\n\t\tif(N == 0 && M == 0 && S == 0 && T == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(kbrni,n)cout<<\" \"<<a[kbrni];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(kbrni,v)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 1005;\n\nstruct edge{\n    int to;\n    int cap;\n    int rev;\n};\n\ntemplate<typename T> class Dinic {\npublic:\n    vector<vector<edge> > G;\n    vector<int> level,iter;\n    int n;\n    Dinic(int node_size){\n        n = node_size;\n        G.resize(node_size),level.resize(node_size),iter.resize(node_size);\n    }\n    //辺を張る\n    int add_edge(int from,int to,T cap)\n    {\n    \tG[from].push_back((edge){to,cap,(int)G[to].size()});\n    \tG[to].push_back((edge){from,(T)0,(int)G[from].size()-1});\n        return len(G[from])-1;\n    }\n    void bfs(int s)\n    {\n    \tfill(level.begin(),level.end(),-1);\n    \tqueue<int> que;\n    \tlevel[s] = 0;\n    \tque.push(s);\n    \twhile(!que.empty()){\n    \t\tint v = que.front();\n    \t\tque.pop();\n    \t\trep(i,G[v].size()){\n    \t\t\tedge &e = G[v][i];\n    \t\t\tif(e.cap > 0 && level[e.to] < 0){\n    \t\t\t\tlevel[e.to] = level[v] + 1;\n    \t\t\t\tque.push(e.to);\n    \t\t\t}\n    \t\t}\n    \t}\n    }\n    T dfs(int v,int t,T f)\n    {\n    \tif(v==t){\n    \t\treturn f;\n    \t}\n    \tfor(int &i = iter[v];i<(int)G[v].size();i++){\n    \t\tedge &e = G[v][i];\n    \t\tif(e.cap > 0 && level[v] < level[e.to]){\n    \t\t\tT d = dfs(e.to,t,min(f,e.cap));\n    \t\t\tif(d>0){\n    \t\t\t\te.cap -= d;\n    \t\t\t\tG[e.to][e.rev].cap += d;\n    \t\t\t\treturn d;\n    \t\t\t}\n    \t\t}\n    \t}\n    \treturn 0;\n    }\n    //最大流を計算\n    T max_flow(int s,int t)\n    {\n    \tT flow = 0;\n    \tfor(;;){\n    \t\tbfs(s);\n    \t\tif(level[t]<0){\n    \t\t\treturn flow;\n    \t\t}\n    \t\tfill(iter.begin(),iter.end(),0);\n    \t\tT f;\n    \t\twhile((f=dfs(s,t,numeric_limits<T>::max())) > 0){\n    \t\t\tflow += f;\n    \t\t}\n    \t}\n    }\n};\n\nint d1[MAX_N],d2[MAX_N];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1){\n        int n,m,s,t;\n        cin >> n >> m >> s >> t;\n        if(n == 0){\n            break;\n        }\n        --s,--t;\n        Dinic<int> dn(n);\n        vp vec(m);\n        rep(i,m){\n            int x,y;\n            cin >> x >> y;\n            --x,--y;\n            y = dn.add_edge(x,y,1);\n            vec[i] = P(x,y);\n        }\n        int res = dn.max_flow(s,t);\n        vector<vector<edge> >& G = dn.G;\n        rep(i,n){\n            d1[i] = d2[i] = INF;\n        }\n        queue<int> q1,q2;\n        q1.push(s);\n        d1[s] = 0;\n        while(!q1.empty()){\n            int p = q1.front();\n            q1.pop();\n            each(e,G[p]){\n                int v = e.to;\n                int c = e.cap;\n                if(c > 0 && d1[v] > d1[p] + 1){\n                    d1[v] = d1[p] + 1;\n                    q1.push(v);\n                }\n            }\n        }\n        q2.push(t);\n        d2[t] = 0;\n        while(!q2.empty()){\n            int p = q2.front();\n            q2.pop();\n            each(e,G[p]){\n                int v = e.to;\n                int r = e.rev;\n                int c = G[v][r].cap;\n                if(c > 0 && d2[v] > d2[p] + 1){\n                    d2[v] = d2[p] + 1;\n                    q2.push(v);\n                }\n            }\n        }\n        int cnt = 0;\n        rep(i,m){\n            int a = vec[i].fi,b = vec[i].se;\n            if(G[a][b].cap == 1){\n                if(d1[G[a][b].to] != INF && d2[a] != INF){\n                    cnt++;\n                }\n            }\n        }\n        if(cnt){\n            cout << res+1 << \" \" << cnt << \"\\n\";\n        }else{\n            cout << res << \" 0\\n\";\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\nconst int MAX_V=1010;\nstruct edge\n{\n    int to,cap,rev;\n    edge(int to,int cap,int rev):to(to),cap(cap),rev(rev){}\n};\nvector<edge> G[MAX_V];\nbool used[MAX_V];\nbool sr[MAX_V],tr[MAX_V];\nint a[10010],b[10010];\nvector<int> v;\nvoid add_edge(int from,int to,int cap)\n{\n\tv.pb(G[from].size());\n    edge new_edge1(to,cap,G[to].size());\n    G[from].pb(new_edge1);\n    edge new_edge2(from,0,G[from].size()-1);\n    G[to].pb(new_edge2);\n}\nint dfs(int v,int t,int f)\n{\n    if(v==t)return f;\n    used[v]=true;\n    for(int i=0;i<G[v].size();i++)\n    {\n        edge &e=G[v][i];\n        if(!used[e.to]&&e.cap>0)\n        {\n            int d=dfs(e.to,t,min(f,e.cap));\n            if(d>0)\n            {\n                e.cap-=d;\n                G[e.to][e.rev].cap+=d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\nvoid dfs1(int v)\n{\n    sr[v]=true;\n    for(int i=0;i<G[v].size();i++)\n    {\n        edge &e=G[v][i];\n        if(!sr[e.to]&&e.cap>0)dfs1(e.to);\n    }\n    return;\n}\nvoid dfs2(int v)\n{\n    tr[v]=true;\n    for(int i=0;i<G[v].size();i++)\n    {\n        edge &e=G[v][i];\n        if(!tr[e.to]&&e.cap==0)dfs2(e.to);\n    }\n    return;\n}\nint flow=0;\nint N,M,S,T;\nint max_flow(int s,int t)\n{\n    for(;;)\n    {\n        memset(used,0,sizeof(used));\n        int f=dfs(s,t,INF);\n        if(f==0)return flow;\n        flow+=f;\n    }\n}\n\nint main()\n{\n\twhile(1)\n\t{\n\t\tflow = 0;\n\t\tv.clear();\n\t\tfor(int i=0;i<1010;i++)G[i].clear();\n\t\tmemset(sr,false,sizeof(sr));\n\t\tmemset(tr,false,sizeof(tr));\n\t\tscanf(\"%d %d %d %d\",&N,&M,&S,&T);\n\t\tif(N==0&&M==0&&S==0&&T==0)break;\n\t\tS--;T--;\n\t\tfor(int i=0;i<M;i++)\n\t\t{\n\t\t    scanf(\"%d %d\",&a[i],&b[i]);\n\t\t    a[i]--;b[i]--;\n\t\t    add_edge(a[i],b[i],1);\n\t\t}\n\t\tmax_flow(S,T);\n\t\tdfs1(S);\n\t\tdfs2(T);\n\t\t//for(int i=0;i<N;i++)printf(\"%d %d\\n\",sr[i],tr[i]);\n\t\tint ans = 0;\n\t\tfor(int i=0;i<M;i++)\n\t\t{\n\t\t    if(G[a[i]][v[i]].cap==0)continue;\n\t\t    if(sr[b[i]]&&tr[a[i]])ans++;\n\t\t}\n\t\tif(ans>0)flow++;\n\t\tprintf(\"%d %d\\n\",flow,ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\nstruct Edge{\n    int dst, cap, rev, ori;\n};\ntypedef vector<Edge> Node;\ntypedef vector<Node> Graph;\n\nbool used[1010];\nint N, M, S, T;\nGraph G;\n\nbool dfs(int v, bool mode=true) {\n    if(v == T) {\n        return true;\n    }\n    if(used[v]) return 0;\n    used[v] = true;\n    for(Edge& e : G[v]) if(e.cap) {\n        if(dfs(e.dst, mode)) {\n            if(mode) {\n                e.cap = 0;\n                G[e.dst][e.rev].cap = 1;\n            }\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid rec(int v, int c, bool used_rec[1010]) {\n    if(used_rec[v]) return;\n    used_rec[v] = true;\n    for(const Edge &e : G[v]) if(e.cap == c) {\n        rec(e.dst, c, used_rec);\n    }\n}\n\n\nint main(){\n    while(cin >> N >> M >> S >> T && N > 0) {\n        S--; T--;\n        G.assign(N, Node());\n        REP(i, M) {\n            int a, b;\n            cin >> a >> b;\n            a--; b--;\n            G[a].push_back({b, 1, (int)G[b].size(), 1});\n            G[b].push_back({a, 0, (int)G[a].size() - 1, 0});\n        }\n\n        int flow = 0;\n        while(true) {\n            memset(used, 0, sizeof(bool) * N);\n            bool f = dfs(S);\n            if(!f) break;\n            flow ++;\n        }\n\n        bool A[1010] = {};\n        rec(S, 1, A);\n        bool B[1010] = {};\n        rec(T, 0, B);\n\n        int ans = 0;\n        REP(i, N) for(Edge& e : G[i]) {\n            if(e.ori && e.cap) {\n                if(A[e.dst] && B[i]){\n                    ans++;\n                }\n            }\n        }\n\n        if(ans != 0) {\n            flow++;\n        }\n\n        cout << flow << \" \" << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 1005\n\n\nstruct Edge{\n\tEdge(int arg_to,int arg_capacity,int arg_rev_index,bool arg_is_rev){\n\t\tto = arg_to;\n\t\tcapacity = arg_capacity;\n\t\trev_index = arg_rev_index;\n\t\tis_rev = arg_is_rev;\n\t}\n\tint to,capacity,rev_index;\n\tbool is_rev;\n};\n\nint V,E;\nint N,M,S,T;\n\nvector<Edge> G[NUM]; //グラフの隣接リスト表現\nbool used[NUM]; //DFSですでに調べたかのフラグ\n\nint dist[NUM]; //sourceからの距離\nint cheked_index[NUM]; //どこまで調べ終わったか\n\n//fromからtoへ向かう容量capacityの辺をグラフに追加する\nvoid add_edge(int from,int to,int capacity){\n\tG[from].push_back(Edge(to,capacity,G[to].size(),false));\n\tG[to].push_back(Edge(from,0,G[from].size()-1,true)); //逆辺の、初期容量は0\n}\n\n//増加パスをDFSで探す\nint dfs(int node_id,int sink,int flow){\n\tif(node_id == sink)return flow; //終点についたらflowをreturn\n\tused[node_id] = true;\n\n\tfor(int i = 0; i < G[node_id].size(); i++){ //node_idから出ているエッジを調査\n\t\tEdge &e = G[node_id][i];\n\t\tif(used[e.to] == false && e.capacity > 0){ //エッジの先のノードに未訪問で、かつエッジに流す余裕がある場合\n\t\t\tint tmp_flow = dfs(e.to,sink,min(flow,e.capacity)); //流せるだけ流す\n\t\t\tif(tmp_flow > 0){ //流せた場合\n\t\t\t\te.capacity -= tmp_flow; //流した分、エッジの容量を削減する\n\t\t\t\tG[e.to][e.rev_index].capacity += tmp_flow; //逆辺の容量を、流した分だけ増加させる\n\t\t\t\treturn tmp_flow;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n//sourceからsinkへの最大流を求める\nint max_flow(int source,int sink){ //source:始点 sink:終点\n\tint flow = 0,add;\n\twhile(true){ //増加パスが存在する限り、流量を追加し続ける\n\t\tfor(int i = 0; i < V; i++)used[i] = false;\n\t\tadd = dfs(source,sink,BIG_NUM);\n\t\tif(add == 0)break;\n\t\tflow += add;\n\t}\n\treturn flow;\n}\n\n//sourceからの最短距離をBFSで計算する\nvoid bfs(int source){\n\tfor(int i = 0; i < V; i++)dist[i] = -1;\n\tqueue<int> Q;\n\tdist[source] = 0;\n\tQ.push(source);\n\n\twhile(!Q.empty()){\n\t\tint node_id = Q.front();\n\t\tQ.pop();\n\t\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\t\tEdge &e = G[node_id][i];\n\t\t\tif(e.capacity > 0 && dist[e.to] < 0){ //辺の容量が正で、かつエッジの行先に未訪問の場合\n\t\t\t\tdist[e.to] = dist[node_id]+1;\n\t\t\t\tQ.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\n//増加パスをDFSで探す\nint dfs_dinic(int node_id,int sink,int flow){\n\tif(node_id == sink)return flow; //終点についたらflowをreturn\n\n\tfor(int &i = cheked_index[node_id]; i < G[node_id].size(); i++){ //node_idから出ているエッジを調査\n\t\tEdge &e = G[node_id][i];\n\t\tif(e.capacity > 0 && dist[node_id] < dist[e.to]){ //流せる余裕があり、かつsourceからの距離が増加する方法である場合\n\t\t\tint tmp_flow = dfs_dinic(e.to,sink,min(flow,e.capacity)); //流せるだけ流す\n\t\t\tif(tmp_flow > 0){ //流せた場合\n\t\t\t\te.capacity -= tmp_flow; //流した分、エッジの容量を削減する\n\t\t\t\tG[e.to][e.rev_index].capacity += tmp_flow; //逆辺の容量を、流した分だけ増加させる\n\t\t\t\treturn tmp_flow;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n//sourceからsinkへの最大流を求める\nint max_flow_dinic(int source,int sink){ //source:始点 sink:終点\n\tint flow = 0,add;\n\twhile(true){ //増加パスが存在する限り、流量を追加し続ける\n\t\tbfs(source);\n\t\tif(dist[sink] < 0)break; //sourceからsinkへと辿り着く残余グラフがない、つまり増加パスが無くなった場合、break\n\t\tfor(int i = 0; i < V; i++)cheked_index[i] = 0;\n\t\twhile((add = dfs_dinic(source,sink,BIG_NUM)) > 0){ //増加パスが見つかる間、加算\n\t\t\tflow += add;\n\t\t}\n\t}\n\treturn flow;\n}\n\nvoid func(){\n\n\tfor(int i = 0; i < N; i++){\n\t\tG[i].clear();\n\t}\n\n\tS--;\n\tT--;\n\n\tint from,to;\n\tfor(int loop = 0; loop < M; loop++){\n\t\tscanf(\"%d %d\",&from,&to);\n\t\tfrom--;\n\t\tto--;\n\t\tadd_edge(from,to,1);\n\t}\n\n\tV = N;\n\n\tint FLOW = max_flow_dinic(S,T);\n\tint MAX_FLOW = FLOW,diff;\n\n\tint num_edge = 0;\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < G[i].size(); k++){\n\t\t\tif(G[i][k].is_rev == true || G[i][k].capacity == 0)continue; //逆辺または、最大流達成のために使用した辺はSKIP\n\n\t\t\t//最大流達成の際に使用していない辺のみ、向きを逆転させれば、総経路が1増える可能性がある\n\n\t\t\t//辺の向きを逆転させる\n\t\t\tG[i][k].capacity = 0;\n\t\t\tG[G[i][k].to][G[i][k].rev_index].capacity = 1;\n\n\t\t\t//S→T方向に流す\n\t\t\tdiff = max_flow(S,T);\n\n\t\t\tif(diff == 1){ //流量が増加した場合\n\t\t\t\tnum_edge++;\n\t\t\t\tMAX_FLOW = FLOW+1;\n\n\t\t\t\tif(i != T){\n\t\t\t\t\tmax_flow(T,i); //T→iに押し戻す\n\t\t\t\t}\n\t\t\t\tif(G[i][k].to != S){\n\t\t\t\t\tmax_flow(G[i][k].to,S); //G[i][k].to→Sに押し戻す\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//辺の向きを元に戻す\n\t\t\tG[i][k].capacity = 1;\n\t\t\tG[G[i][k].to][G[i][k].rev_index].capacity = 0;\n\n\t\t\t//★★元々i→G[i][k].to間には流れがなかったので、流しなおす必要はない★★\n\t\t}\n\t}\n\n\tprintf(\"%d %d\\n\",MAX_FLOW,num_edge);\n}\n\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d %d %d\",&N,&M,&S,&T);\n\t\tif(N == 0 && M == 0 && S == 0 && T == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<58;\nconst double pi=acos(-1);\nconst double eps=1e-7;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nclass Network{\n\tprivate:\n\tint V;\n\tstruct edge{\n\t\tint to,cap,rev;\n\t};\n\tvector<vector<edge> > g;\n\tint DFS(int v,int t,int f,vi& iter,vi level){\n\t\tif(v==t) return f;\n\t\tfor(int &i=iter[v];i<g[v].size();i++){\n\t\t\tedge &e=g[v][i];\n\t\t\tif(e.cap>0&&level[v]<level[e.to]){\n\t\t\t\tint d=DFS(e.to,t,min(f,e.cap),iter,level);\n\t\t\t\tif(d>0){\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tg[e.to][e.rev].cap+=d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tvoid BFS(int s,vi& level){\n\t\tlevel=vi(V,-1);\n\t\tqueue<int> que;\n\t\tlevel[s]=0;\n\t\tque.push(s);\n\t\twhile(!que.empty()){\n\t\t\tint v=que.front();\n\t\t\tque.pop();\n\t\t\tfor(int i=0;i<g[v].size();i++){\n\t\t\t\tedge &e=g[v][i];\n\t\t\t\tif(e.cap>0&&level[e.to]<0){\n\t\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpublic:\n\tNetwork(int v){\n\t\tV=v;\n\t\tg=vector<vector<edge> >(v);\n\t}\n\tvoid add_edge(int s,int t,int c){\n\t\tg[s].push_back(edge{t,c,(int)g[t].size()});\n\t\tg[t].push_back(edge{s,0,(int)g[s].size()-1});\n\t}\n\tint Dinic(int s,int t){\n\t\tint res=0;\n\t\twhile(1){\n\t\t\tvi iter(V),level;\n\t\t\tBFS(s,level);\n\t\t\tif(level[t]<0) return res;\n\t\t\tint f;\n\t\t\twhile((f=DFS(s,t,inf,iter,level))>0) res+=f;\n\t\t}\n\t}\n\tvoid dfs(int v,int c,vi& a){\n\t\ta[v]=1;\n\t\tfor(int i=0;i<g[v].size();i++){\n\t\t\tedge &e=g[v][i];\n\t\t\tif(!a[e.to]&&e.cap==c) dfs(e.to,c,a);\n\t\t}\n\t}\n\tvi f(int v,int c){\n\t\tvi a(V);\n\t\tdfs(v,c,a);\n\t\treturn a;\n\t}\n};\n\nint n,m,s,t;\n\nint main(){\n\twhile(1){\n\t\tcin>>n>>m>>s>>t;\n\t\ts--;t--;\n\t\tif(!n) break;\n\t\tNetwork nt(n);\n\t\tvi u,v;\n\t\tu=v=vi(m);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>u[i]>>v[i];\n\t\t\tu[i]--;\n\t\t\tv[i]--;\n\t\t\tnt.add_edge(u[i],v[i],1);\n\t\t}\n\t\tint f=nt.Dinic(s,t);\n\t\tvi a=nt.f(s,1),b=nt.f(t,0);\n\t\tint cnt=0,F=1;\n\t\tfor(int i=0;i<m;i++) if(a[v[i]]&&b[u[i]]){\n\t\t\tcnt++;\n\t\t\tf+=F;\n\t\t\tF=0;\n\t\t}\n\t\tcout<<f<<' '<<cnt<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_V 10000\n#define INF 1e9\nusing namespace std;\n\n/*????°??????¨???(???????????£????????????????????¨) O(F|V||E|)*/\n\n//????????¨????§???????(???????????????????????????????????????)\nstruct edge{int to, cap,cost,rev;};\nint V;                         //????????°\nvector<edge> G[MAX_V];         //??°???????????£??\\???????????¨???\nint dist[MAX_V];               //???????????¢\nint prevv[MAX_V],preve[MAX_V]; //??´??????????????¨???\n\n// from??????to??????????????????cap????????????cost???????????°????????????????????????\nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back((edge){to,cap,cost,G[to].size()});\n  G[to].push_back((edge){from,0,-cost,G[from].size()-1});\n}\n\n//s??????t????????????f???????°??????¨???????±???????\n//??????????????´???-1?????????\nint min_cost_flow(int s,int t,int f){\n  int res=0;\n  while(f>0){\n    //????????????????????????????????????,s-t????????????????±???????\n    fill(dist,dist+V,INF);\n    dist[s]=0;\n    bool update = true;\n    while(update){\n      update = false;\n      for(int v=0; v<V ;v++){\n\tif(dist[v]==INF) continue;\n\tfor(int i=0; i<G[v].size(); i++){\n\t  edge &e = G[v][i];\n\t  if(e.cap > 0 && dist[e.to] > dist[v]+e.cost) {\n\t    dist[e.to] = dist[v] + e.cost;\n\t    prevv[e.to] = v;\n\t    preve[e.to] = i;\n\t    update = true;\n\t  }\n\t}\n      }\n    }\n    if(dist[t]==INF) return -1; //????????\\??????????????????\n    \n    //s???t?????????????????£??????????????????\n    int d = f;\n    for(int v=t; v!=s; v=prevv[v])d=min(d,G[prevv[v]][preve[v]].cap);\n    f -= d;\n    res += d*dist[t];\n    for(int v=t; v!=s; v=prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\ntypedef pair<int,int> P;\nint main(){\n  while(1){\n  int n,m,s,t;\n  cin>>n>>m>>s>>t;\n  if(!n&&!m&&!s&&!t)break;\n  V=n;\n  s--,t--;\n  for(int i=0;i<MAX_V;i++) G[i].clear();\n  \n  for(int i=0,a,b;i<m;i++){\n    cin>>a>>b;\n    a--,b--;\n    add_edge(a,b,1,0);\n    add_edge(b,a,1,1);\n  }\n  \n  int cost,mx=0,cnt=0;\n  while(!(cost=min_cost_flow(s,t,1)))mx++;\n  if(cost==1)mx++;\n  \n  while(cost==1){\n    cnt++;\n    int i,j;\n    for(int v=t; v!=s; v=prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      if(e.cost>0)i=prevv[v],j=preve[v];\n    }\n    min_cost_flow(t,s,1);\n    edge &e=G[i][j];\n    e.cap = 0;\n    G[e.to][e.rev].cap=0;\n    cost=min_cost_flow(s,t,1);\n  }  \n  cout<<mx<<\" \"<<cnt<<endl;\n  }  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\n#define MAX_V 10000\nusing namespace std;\n\n/*?????§?????¢?????´?????????(Ford_Fulerson????????¨)???O(F|E|)*/\n\n//????????¨????§???????(???????????????????????????)\nstruct edge{int to, cap, rev, s;};\n\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size(),0});\n  G[to].push_back((edge){from,0,(int)G[from].size()-1,1});  \n}\n\n//?¢?????????????DFS??§??¢???\nint dfs(int v,int t,int f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs(e.to ,t , min(f,e.cap));\n      if(d > 0){\n\te.cap -= d;\n\tG[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\n//s??????t???????????§???????±???????\nint max_flow(int s,int t,int maxf){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s, t, maxf);\n    if(f == 0)return flow;\n    maxf-=f;\n    flow += f;\n  }\n}\n\nint n, m, s, t;\n\nvoid solve(){\n  \n  int r = max_flow(s, t, INF);\n  int maxflow=r;\n  \n  map<int,int> cnt;\n  \n  for(int i=1;i<=n;i++){\n    \n    for(int j=0;j<G[i].size();j++){\n      \n      edge &s1 = G[i][j];\n      edge &t1 = G[s1.to][s1.rev];\n      \n      if(s1.s) continue;\n      \n      int rev=t1.cap, f=r-rev;\n      \n      s1.cap=t1.cap=0;\n      \n      max_flow(t,s1.to,rev);\n\n      max_flow(i,s,rev);\n\n      t1.cap=1;\n      \n      f+=max_flow(s,t,INF);\n      \n      if(maxflow<f) maxflow=f;\n      \n      cnt[f]++;\n      \n      rev=max(0,f-r);\n      \n      s1.cap=t1.cap=0;\n      \n      max_flow(s1.to,s,rev);\n      \n      max_flow(t,i,rev);\n      \n      s1.cap=1;\n            \n      max_flow(s,t,INF);\n      \n    }\n    \n  }\n\n  int revcnt=0;\n\n  if(r<maxflow){\n    for(pair<int,int> d : cnt)\n      if(maxflow==d.first) revcnt+=d.second;\n  }\n  \n  cout<<maxflow<<' '<<revcnt<<endl;\n  \n}\n\nvoid init(){\n  for(int i=0;i<MAX_V;i++) G[i].clear();\n}\n\nint main(){\n\n  while(1){\n    \n    cin>>n>>m>>s>>t;\n    if(!n&&!m&&!s&&!t) break;\n\n    init();\n    \n    for(int i=0;i<m;i++){\n      int a, b;\n      cin>>a>>b;\n      add_edge(a,b,1);\n    }\n  \n    solve();\n  }\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mod 998244353\n#define MOD 1000000007\n#define inf 0x3f3f3f3f\n#define linf 0x3f3f3f3f3f3f3f3fll\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef unsigned long long ull;\nconst int maxn=1100;\nconst int maxm=10100;\nstruct Edge\n{\n\tint to,cap,rev,tag;\n\tEdge(){}\n\tEdge(int to,int cap,int rev,int tag):to(to),cap(cap),rev(rev),tag(tag){}\n};\nvector<Edge> g[maxn];\nint lvl[maxn],iter[maxn];\nqueue<int> que;\ninline void bfs(int x)\n{\n\tmemset(lvl,0x3f,sizeof(lvl));\n\tlvl[x]=0;\n\tque.push(x);\n\twhile(!que.empty())\n\t{\n\t\tx=que.front();\n\t\tque.pop();\n\t\tfor(int i=0;i<g[x].size();i++)\n\t\t{\n\t\t\tEdge &e=g[x][i];\n\t\t\tif(e.cap>0&&lvl[e.to]==inf)\n\t\t\t{\n\t\t\t\tlvl[e.to]=lvl[x]+1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\ninline int dfs(int x,int tar,int f)\n{\n\tif(x==tar)return f;\n\tfor(int &i=iter[x];i<g[x].size();i++)\n\t{\n\t\tEdge &e=g[x][i];\n\t\tif(e.cap>0&&(lvl[e.to]==lvl[x]+1))\n\t\t{\n\t\t\tint d=dfs(e.to,tar,min(e.cap,f));\n\t\t\tif(d>0)\n\t\t\t{\n\t\t\t\te.cap-=d;\n\t\t\t\tg[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\ninline void addedge(int a,int b,int c,int d)\n{\n\tg[a].push_back(Edge(b,c,g[b].size(),d));\n\tg[b].push_back(Edge(a,0,g[a].size()-1,-1));\n}\nint maxflow(int s,int t)\n{\n\tint flow=0;\n\tfor(;;)\n\t{\n\t\tbfs(s);\n\t//\tcout<<\"bfs \"<<lvl[t]<<endl;\n\t\tif(lvl[t]==inf)return flow;\n\t\tmemset(iter,0,sizeof(iter));\n\t\tint f=0;\n\t\twhile((f=dfs(s,t,inf))>0)flow+=f;\n\t}\n}\nbool reachS[maxn],reachT[maxn];\nint n,m,s,t;\nint ia[maxm],ib[maxm];\nint main()\n{\n\twhile(~scanf(\"%d%d%d%d\",&n,&m,&s,&t)&&n)\n\t{\n\t\tfor(int i=1;i<=n;i++)g[i].clear();\n\t\tfor(int i=1;i<=m;i++)\n\t\t{\n\t\t\tscanf(\"%d%d\",&ia[i],&ib[i]);\n\t\t\taddedge(ia[i],ib[i],1,i);\n\t\t}\n\t\tint ans=maxflow(s,t);\n\t\tint cnt=0;\n\t\tbfs(s);\n\t\tmemset(reachS,0,sizeof(reachS));\n\t\tmemset(reachT,0,sizeof(reachT));\n\t\treachS[s]=1;\n\t\tque.push(s);\n\t\twhile(!que.empty())\n\t\t{\n\t\t\tint x=que.front();\n\t\t\tque.pop();\n\t\t\tfor(int i=0;i<g[x].size();i++)\n\t\t\t{\n\t\t\t\tEdge &e=g[x][i];\n\t\t\t\tif(e.cap>0&&!reachS[e.to])\n\t\t\t\t{\n\t\t\t\t\treachS[e.to]=1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treachT[t]=1;\n\t\tque.push(t);\n\t\twhile(!que.empty())\n\t\t{\n\t\t\tint x=que.front();\n\t\t\tque.pop();\n\t\t\tfor(int i=0;i<g[x].size();i++)\n\t\t\t{\n\t\t\t\tEdge &e=g[x][i];\n\t\t\t\tif(g[e.to][e.rev].cap>0&&!reachT[e.to])\n\t\t\t\t{\n\t\t\t\t\treachT[e.to]=1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int x=1;x<=n;x++)if(reachT[x])\n\t\t{\n\t\t\tfor(int i=0;i<g[x].size();i++)\n\t\t\t{\n\t\t\t\tEdge &e=g[x][i];\n\t\t\t\tif(e.tag>0&&reachS[e.to]&&e.cap>0)\n\t\t\t\t{\n\t\t\t\t\tif(!cnt)ans++;\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\",ans,cnt);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int MAX_V = 3000;\nconst int IINF = INT_MAX;\ntypedef pair<int,int> ii;\n\nmap<ii,int> mp; /////////\n\nstruct Edge{ int to,cap,rev; bool isRev; };\n\nvector<Edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((Edge){to,cap,G[to].size(),false});\n  G[to].push_back((Edge){from,0,G[from].size()-1,true});\n}\n\nint dfs(int v,int t,int f){\n  if( v == t ) return f;\n  used[v] = true;\n  for(int i=0;i<G[v].size();i++){\n    Edge &e = G[v][i];\n    if( !used[e.to] && e.cap > 0 ){\n      int d = dfs(e.to,t,min(f,e.cap));\n      if( d > 0 ){\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s,t,IINF);\n    if( f == 0 ) return flow;\n    flow += f;\n  }\n}\n\nvector<int> G2[MAX_V],rG2[MAX_V];\nbool visited[2][MAX_V];\n\nvoid init(int _size=MAX_V){ rep(i,_size) G[i].clear(), G2[i].clear(), rG2[i].clear(); }\n\nint V,E;\n\nvoid icompute(int s,bool used[MAX_V],int type){\n  used[s] = true;\n  deque<int> deq;\n  deq.push_back(s);\n  while( !deq.empty() ){\n    int cur = deq.front(); deq.pop_front();\n    rep(i,(int)(type?G2[cur].size():rG2[cur].size())){\n      int next = type?G2[cur][i]:rG2[cur][i];\n      if( !used[next] ) {\n\tused[next] = true;\n\tdeq.push_back(next);\n      }\n    }\n  }\n}\n\nvoid compute(int let,int go){\n  int maxi = max_flow(let,go);\n  rep(i,V) {\n    int s = i;\n    rep(j,(int)G[i].size()) if( G[i][j].cap ) {\n      int t = G[i][j].to, c = G[i][j].cap;\n      G2[s].push_back(t), rG2[t].push_back(s);\n    }\n  }\n\n  memset(visited,false,sizeof(visited));\n  icompute(let,visited[0],1);\n  icompute(go ,visited[1],0);\n  /*\n  rep(i,V) {\n    cout << i+1 << \"-th : \" << visited[0][i] << \" \";\n  } cout << endl << endl;\n\n  rep(i,V) {\n    cout << i+1 << \"-th : \" << visited[1][i] << \" \";\n  } cout << endl << endl;\n  */\n  int cnt = 0;\n  rep(i,V) rep(j,(int)G[i].size()) if( G[i][j].cap && !G[i][j].isRev ) {\n    if( visited[0][G[i][j].to] && visited[1][i] ) ++cnt;\n  }\n  cout << maxi + ( cnt > 0 ) << \" \" << cnt << endl;\n}\n\nint main(){\n  int s,t;\n  while( cin >> V >> E >> s >> t, V|E|s|t ) {\n    --s, --t;\n    init(V);\n    set<ii> S;\n    rep(i,E) {\n      int a,b;\n      scanf(\"%d %d\",&a,&b);\n      --a, --b;\n      add_edge(a,b,1);\n    }\n    compute(s,t);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\n#include<string.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nstruct edge{\n\tint to;\n\tint cap;\n\tint rev;\n};\n\nstruct flow{\n\tvector<edge> G[1002];\n\tbool used[1002];\n\tvoid add_edge(int from,int to,int cap){\n\t\t\tedge a = {to,cap,(int)G[to].size()};\n\t\t\tedge b = {from,0,(int)G[from].size()};\n\t\tG[from].push_back(a);\n\t\tG[to].push_back(b);\n\t}\n\tint dfs(int v,int t,int f){\n\t\tif(v == t)return f;\n\t\tused[v] = true;\n\t\tfor(int i = 0 ; i < G[v].size() ; i ++){\n\t\t\tedge &e = G[v][i];\n\t\t\tif(!used[e.to] && e.cap > 0){\n\t\t\t\tint d = dfs(e.to,t,min(f,e.cap));\n\t\t\t\tif(d > 0){\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s,int t){\n\t\tint flow = 0;\n\t\twhile(1){\n\t\t\trep(i,1002)used[i] = false;\n\t\t\tint f = dfs(s,t,INF);\n\t\t\tif(f == 0)return flow;\n\t\t\tflow += f;\n\t\t}\n\t}\n\tvoid init(){\n\t\trep(i,1002)G[i].clear();\n\t}\n}F;\n\nint flag[1002];\nvoid dfs(int v){\n\tif(flag[v] == 1)return;\n\tflag[v] = 1;\n\trep(i,F.G[v].size()){\n\t\tedge ed = F.G[v][i];\n\t\tif(ed.cap > 0)dfs(ed.to);\n\t}\n}\nvoid dfs_rev(int v){\n\tif(flag[v] == -1)return;\n\tflag[v] = -1;\n\trep(i,F.G[v].size()){\n\t\tedge ed = F.G[v][i];\n\t\tif(ed.cap == 0)dfs_rev(ed.to);\n\t}\n}\n\nint main(){\n\twhile(1){\n\t\tint n,m,s,t;\n\t\tcin >> n >> m >> s >> t;\n\t\tif(n == 0)return 0;\n\t\tint a[10002],b[10002];\n\t\trep(i,m){\n\t\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t\t}\n\t\t\n\t\tF.init();\n\t\trep(i,m){\n\t\t\tF.add_edge(a[i],b[i],1);\n\t\t}\n\t\tint ret = F.max_flow(s,t);\n\t\trep1(i,n)flag[i] = 0;\n\t\tdfs(s);\n\t\tdfs_rev(t);\n\t\tint cnt = 0;\n\t\trep(i,m){\n\t\t\tif(flag[a[i]] == -1 && flag[b[i]] == 1)cnt ++;\n\t\t}\n\t\tprintf(\"%d %d\\n\",ret+(cnt==0?0:1),cnt);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 1005\n#define INF (1<<26)\n\nint N,M,S,T;\nint G[MAX_N][MAX_N];\nint g[MAX_N][MAX_N];\nint base;\nint visited[MAX_N];\n\nint AS[MAX_N],AT[MAX_N];\n\nbool check(int a,int b){\n  if(AT[a]&&AS[b])return true;\n  else return false;\n}\n\nvoid dfsS(int pos){\n  AS[pos]=true;\n  for(int i=0;i<N;i++){\n    if(G[pos][i]==0)continue;\n    if(AS[i])continue;\n    dfsS(i);\n  }\n}\n\nvoid dfsT(int pos){\n  AT[pos]=true;\n  for(int i=0;i<N;i++){\n    if(G[i][pos]==0)continue;\n    if(AT[i])continue;\n    dfsT(i);\n  }\n}\n\nvoid solve(){\n\n/*\n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      cout<<G[i][j]<<' ';\n    }\n    cout<<endl;\n  }\n*/\n\n  for(int i=0;i<N;i++)\n    AS[i]=AT[i]=false;\n  \n  dfsS(S);\n  dfsT(T);\n\n  /*\n  for(int i=0;i<N;i++){\n    cout<<AS[i]<<' ';\n  }\n  cout<<endl;\n\n  for(int i=0;i<N;i++){\n    cout<<AT[i]<<' ';\n  }\n  cout<<endl;\n  */\n\n  int cnt=0;\n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      if(i==j)continue;\n      if(G[i][j]==g[i][j]&&G[i][j]>0){\n        //cout<<\"# \"<<i<<' '<<j<<endl;\n        if(check(i,j))cnt++;\n      }\n    }\n  }\n\n  if(base==0&&cnt==0)cout<<\"0 0\"<<endl;\n  else if(cnt==0)cout<<base<<\" 0\"<<endl;\n  else cout<<base+1<<\" \"<<cnt<<endl;\n}\n\nint dfs(int pos,int f){\n  if(pos==T)return f;\n  visited[pos]=true;\n  for(int i=0;i<N;i++){\n    if(visited[i])continue;\n    if(G[pos][i]==0)continue;\n    int d=dfs(i,min(f,G[pos][i]));\n    if(d>0){\n      G[pos][i]-=d;\n      G[i][pos]+=d;\n      return d;\n    }\n  }\n  return 0;\n}\n\nvoid calc(){\n  base=0;\n  while(1){\n    for(int i=0;i<N;i++)visited[i]=false;\n    int f=dfs(S,INF);\n    if(f==0)break;\n    base+=f;\n  }\n}\n\nvoid init(){\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      G[i][j]=0;\n}\n\nint main(){\n  int a,b;\n  while(1){\n    scanf(\"%d %d %d %d\",&N,&M,&S,&T);\n    if(N==0&&M==0&&S==0&&T==0)break;\n    S--,T--;\n    init();\n    for(int i=0;i<M;i++){\n      scanf(\"%d %d\",&a,&b);\n      a--,b--;\n      G[a][b]++;\n    }\n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++)\n        g[i][j]=G[i][j];\n    calc();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 1005\n\nenum Type{\n\tFROM_S,\n\tFROM_T,\n};\n\n\n//辺を表す構造体(行先、容量、逆辺のインデックス)\nstruct Edge{\n\tEdge(int arg_to,int arg_capacity,int arg_rev_index,bool arg_is_rev){\n\t\tto = arg_to;\n\t\tcapacity = arg_capacity;\n\t\trev_index = arg_rev_index;\n\t\tis_rev = arg_is_rev;\n\t}\n\tint to,capacity,rev_index;\n\tbool is_rev;\n};\n\nint V,E;\nint N,M,S,T;\n\nvector<Edge> G[NUM]; //グラフの隣接リスト表現\nbool used[NUM]; //DFSですでに調べたかのフラグ\nbool can_reach[2][NUM]; //S,Tから各点へ到達できるかのチェック\n\n//fromからtoへ向かう容量capacityの辺をグラフに追加する\nvoid add_edge(int from,int to,int capacity){\n\tG[from].push_back(Edge(to,capacity,G[to].size(),false));\n\tG[to].push_back(Edge(from,0,G[from].size()-1,true)); //逆辺の、初期容量は0\n}\n\n//増加パスをDFSで探す\nint dfs(int node_id,int sink,int flow){\n\tif(node_id == sink)return flow; //終点についたらflowをreturn\n\tused[node_id] = true;\n\n\tfor(int i = 0; i < G[node_id].size(); i++){ //node_idから出ているエッジを調査\n\t\tEdge &e = G[node_id][i];\n\t\tif(used[e.to] == false && e.capacity > 0){ //エッジの先のノードに未訪問で、かつエッジに流す余裕がある場合\n\t\t\tint tmp_flow = dfs(e.to,sink,min(flow,e.capacity)); //流せるだけ流す\n\t\t\tif(tmp_flow > 0){ //流せた場合\n\t\t\t\te.capacity -= tmp_flow; //流した分、エッジの容量を削減する\n\t\t\t\tG[e.to][e.rev_index].capacity += tmp_flow; //逆辺の容量を、流した分だけ増加させる\n\t\t\t\treturn tmp_flow;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid reach_check(Type type,int node_id){\n\n\tcan_reach[type][node_id] = true;\n\tint base;\n\n\tif(type == FROM_S){\n\t\tbase = 1;\n\t}else{\n\t\tbase = 0; //★逆向きに進めれば良いため★\n\t}\n\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\tif(G[node_id][i].capacity == base && can_reach[type][G[node_id][i].to] == false){\n\t\t\treach_check(type,G[node_id][i].to);\n\t\t}\n\t}\n}\n\n\n//sourceからsinkへの最大流を求める\nint max_flow(int source,int sink){ //source:始点 sink:終点\n\tint flow = 0,add;\n\twhile(true){ //増加パスが存在する限り、流量を追加し続ける\n\t\tfor(int i = 0; i < V; i++)used[i] = false;\n\t\tadd = dfs(source,sink,BIG_NUM);\n\t\tif(add == 0)break;\n\t\tflow += add;\n\t}\n\treturn flow;\n}\n\nvoid func(){\n\n\tfor(int i = 0; i < N; i++){\n\t\tG[i].clear();\n\t\tcan_reach[FROM_S][i] = false;\n\t\tcan_reach[FROM_T][i] = false;\n\t}\n\n\tS--;\n\tT--;\n\n\tint from,to;\n\tfor(int loop = 0; loop < M; loop++){\n\t\tscanf(\"%d %d\",&from,&to);\n\t\tfrom--;\n\t\tto--;\n\t\tadd_edge(from,to,1);\n\t}\n\n\tV = N;\n\n\tint FLOW = max_flow(S,T);\n\t//printf(\"FLOW:%d\\n\",FLOW);\n\t//return;\n\tint MAX_FLOW = FLOW;\n\n\treach_check(FROM_S,S);\n\treach_check(FROM_T,T);\n\n\tint num_edge = 0,diff;\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < G[i].size(); k++){\n\t\t\tif(G[i][k].is_rev == true || G[i][k].capacity == 0 ||\n\t\t\t\t\tcan_reach[FROM_S][G[i][k].to] == false || can_reach[FROM_T][i] == false)continue; //逆辺または、最大流達成のために使用した辺はSKIP\n\n\t\t\t//経路に重なりはないと仮定してみる\n\t\t\tnum_edge++;\n\t\t\tMAX_FLOW = FLOW+1;\n\n\t\t}\n\t}\n\n\tprintf(\"%d %d\\n\",MAX_FLOW,num_edge);\n}\n\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d %d %d\",&N,&M,&S,&T);\n\t\tif(N == 0 && M == 0 && S == 0 && T == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) cerr << #x << \" = \" << (x) << endl\nusing namespace std;\nusing ll = long long;\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 16;\ntemplate <typename Functor>\nstruct fix_type\n{\n    Functor functor;\n    template <typename... Args>\n    decltype(auto) operator()(Args&&... args) const& { return functor(functor, std::forward<Args>(args)...); }\n};\ntemplate <typename Functor>\nfix_type<typename std::decay<Functor>::type> fix(Functor&& functor) { return {std::forward<Functor>(functor)}; }\nclass Flow\n{\npublic:\n    using T = ll;\n    struct Edge\n    {\n        int from;\n        int to;\n        int reverse;\n        T capacity;\n        T flow;\n        const bool is_reverse;\n    };\n    Flow(const int v) : V{v}, edge(v) {}\n    void addEdge(const int from, const int to, const T capacity)\n    {\n        edge[from].push_back(Edge{from, to, (int)edge[to].size(), capacity, 0, false});\n        edge[to].push_back(Edge{to, from, (int)edge[from].size() - 1, capacity, capacity, true});\n    }\n    T FordFulkerson(const int s, const int t)\n    {\n        vector<bool> checked(V);\n        auto dfs = fix([&](auto&& self, const int pos, const T& flow) -> T {\n            if (pos == t) { return flow; }\n            checked[pos] = true;\n            for (auto& e : edge[pos]) {\n                if (not checked[e.to]) {\n                    const T res = e.capacity - e.flow;\n                    if (res > 0) {\n                        const T d = self(self, e.to, min(flow, res));\n                        if (d > 0) {\n                            e.flow += min(d, res);\n                            edge[e.to][e.reverse].flow -= min(d, res);\n                            return d;\n                        }\n                    }\n                }\n            }\n            return 0;\n        });\n        T flow = 0;\n        while (true) {\n            for (int i = 0; i < V; i++) { checked[i] = false; }\n            const T f = dfs(s, INF<T>);\n            if (f == 0) { break; }\n            flow += f;\n        }\n        return flow;\n    }\n    const int V;\n    vector<vector<Edge>> edge;\n};\nstruct Graph\n{\n    Graph(const int v) : V{v}, edge(v), rev_edge(v) {}\n    void addEdge(const int from, const int to)\n    {\n        edge[from].push_back(to);\n        rev_edge[to].push_back(from);\n    }\n    const int V;\n    vector<vector<int>> edge;\n    vector<vector<int>> rev_edge;\n};\n\nint main()\n{\n    while (true) {\n        int N, M, S, T;\n        cin >> N >> M >> S >> T;\n        if (N == 0 and M == 0 and S == 0 and T == 0) { break; }\n        Flow f(N);\n        using P = pair<int, int>;\n        for (int i = 0; i < M; i++) {\n            int a, b;\n            cin >> a >> b;\n            f.addEdge(a - 1, b - 1, 1);\n        }\n        const int F = f.FordFulkerson(S - 1, T - 1);\n        Graph g(N);\n        vector<P> E;\n        for (int i = 0; i < N; i++) {\n            for (const auto& e : f.edge[i]) {\n                if (not e.is_reverse) {\n                    e.flow == 0 ? g.addEdge(e.from, e.to) : g.addEdge(e.to, e.from);\n                    if (e.flow == 0) { E.push_back({e.from, e.to}); }\n                }\n            }\n        }\n        auto dijk = [&](const int s, const bool rev) -> vector<int> {\n            vector<int> ans(N, INF<int>);\n            priority_queue<P, vector<P>, greater<P>> q;\n            ans[s] = 0;\n            q.push(make_pair(0, s));\n            while (not q.empty()) {\n                const P& p = q.top();\n                const int cost = p.first;\n                const int v = p.second;\n                q.pop();\n                if (ans[v] < cost) { continue; }\n                for (const int to : (rev ? g.rev_edge[v] : g.edge[v])) {\n                    if (ans[to] > ans[v] + 1) {\n                        ans[to] = ans[v] + 1;\n                        q.push(make_pair(ans[to], to));\n                    }\n                }\n            }\n            return ans;\n        };\n        const auto d = dijk(S - 1, false);\n        const auto revd = dijk(T - 1, true);\n        int ans = 0;\n        for (const auto& e : E) {\n            if (d[e.second] != INF<int> and revd[e.first] != INF<int>) { ans++; }\n        }\n        cout << (F + (ans > 0 ? 1 : 0)) << \" \" << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<queue>\nusing namespace std;\nconst int D_MAX_V=2002;\nconst int D_v_size=2002;\nstruct D_wolf{\n\tint t,c,r;\n\tD_wolf(){t=c=r=0;}\n\tD_wolf(int t1,int c1,int r1){\n\t\tt=t1;c=c1;r=r1;\n\t}\n};\nvector<D_wolf>D_G[D_MAX_V];\nint D_level[D_MAX_V];\nint D_iter[D_MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n\tfor(int i=0;i<D_G[from].size();i++){\n\t\tif(to==D_G[from][i].t){\n\t\t\tD_G[from][i].c+=cap;\n\t\t\treturn;\n\t\t}\n\t}\n\tD_G[from].push_back(D_wolf(to,cap,D_G[to].size()));\n\tD_G[to].push_back(D_wolf(from,0,D_G[from].size()-1));\n}\nvoid D_bfs(int s){\n\tfor(int i=0;i<D_v_size;i++)D_level[i]=-1;\n\tqueue<int> Q;\n\tD_level[s]=0;\n\tQ.push(s);\n\twhile(Q.size()){\n\t\tint v=Q.front();\n\t\tQ.pop();\n\t\tfor(int i=0;i<D_G[v].size();i++){\n\t\t\tif(D_G[v][i].c>0&&D_level[D_G[v][i].t]<0){\n\t\t\t\tD_level[D_G[v][i].t]=D_level[v]+1;\n\t\t\t\tQ.push(D_G[v][i].t);\n\t\t\t}\n\t\t}\n\t}\n}\nint D_dfs(int v,int t,int f){\n\tif(v==t)return f;\n\tfor(;D_iter[v]<D_G[v].size();D_iter[v]++){\n\t\tint i=D_iter[v];\n\t\tif(D_G[v][i].c>0&&D_level[v]<D_level[D_G[v][i].t]){\n\t\t\tint d=D_dfs(D_G[v][i].t,t,min(f,D_G[v][i].c));\n\t\t\tif(d>0){\n\t\t\t\tD_G[v][i].c-=d;\n\t\t\t\tD_G[D_G[v][i].t][D_G[v][i].r].c+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s,int t){\n\tint flow=0;\n\tfor(;;){\n\t\tD_bfs(s);\n\t\tif(D_level[t]<0)return flow;\n\t\tfor(int i=0;i<D_v_size;i++)D_iter[i]=0;\n\t\tint f;\n\t\twhile((f=D_dfs(s,t,99999999))>0){flow+=f;}\n\t}\n\treturn 0;\n}\nint c,d;\nint vis[1100];\nint dfs(int u,int v){\n\tif(u==v){\n\t\treturn 1;\n\t}\n\tvis[u]=1;\n\tfor(int i=0;i<D_G[u].size();i++){\n\t\tif(vis[D_G[u][i].t])continue;\n\t\tif(!D_G[u][i].c)continue;\n\t\tif(dfs(D_G[u][i].t,v)){\n\t\t\tD_G[u][i].c--;\n\t\t\tD_G[D_G[u][i].t][D_G[u][i].r].c++;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint N;\nint Minus(int s,int t){\n\tfor(int i=0;i<D_G[s].size();i++){\n\t\tif(D_G[s][i].t==t){\n\t\t\tif(D_G[s][i].c){\n\t\t\t\tD_G[s][i].c--;return 0;\n\t\t\t}else{\n\t\t\t\tfor(int j=0;j<N;j++)vis[j]=0;\n\t\t\t\tif(dfs(s,t))return 0;\n\t\t\t\tfor(int j=0;j<N;j++)vis[j]=0;\n\t\t\t\tdfs(d,t);\n\t\t\t\tfor(int j=0;j<N;j++)vis[j]=0;\n\t\t\t\tdfs(s,c);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n}\nint Plus(int s,int t){\n\tfor(int i=0;i<D_G[s].size();i++){\n\t\tif(D_G[s][i].t==t){D_G[s][i].c++;break;}\n\t}\n\tfor(int j=0;j<N;j++)vis[j]=0;\n\treturn dfs(c,d);\n}\nint p[11000];\nint q[11000];\n\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d%d%d\",&a,&b,&c,&d),a){\n\t\tc--;d--;\n\t\tN=a;\n\t\tfor(int i=0;i<2002;i++){\n\t\t\tD_G[i].clear();\n\t\t\tD_level[i]=D_iter[i]=0;\n\t\t}\n\t\tmap<pair<int,int>,int>m;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tscanf(\"%d%d\",p+i,q+i);\n\t\t\tp[i]--;q[i]--;\n\t\t\tif(m.count(make_pair(p[i],q[i])))m[make_pair(p[i],q[i])]++;\n\t\t\telse m[make_pair(p[i],q[i])]=1;\n\t\t\tadd_edge(p[i],q[i],1);\n\t\t}\n\t\tint v=max_flow(c,d);\n\t\t\n\t\tint ret=0;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tbool ok=false;\n\t\t\tfor(int j=0;j<D_G[p[i]].size();j++){\n\t\t\t\tif(D_G[p[i]][j].t==q[i]){\n\t\t\t\t\tif(D_G[p[i]][j].c<m[make_pair(p[i],q[i])]){\n\t\t\t\t\t\tok=true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok)continue;\n\t\t\tint t2=Plus(q[i],p[i]);\n\t\t\tif(!t2){\n\t\t\t\tMinus(q[i],p[i]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint t1=Minus(p[i],q[i]);\n\t\t//\tprintf(\"%d %d: %d %d\\n\",p[i],q[i],t1,t2);\n\t\t\tif(t1==0&&t2){\n\t\t\t\tret++;\n\t\t\t}\n\t\t\tMinus(q[i],p[i]);\n\t\t\tPlus(p[i],q[i]);\n\t\t}\n\t\tif(ret==0)printf(\"%d %d\\n\",v,ret);\n\t\telse printf(\"%d %d\\n\",v+1,ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<tuple>\n\nusing namespace std;\n\nstruct edge{int to,cap,rev;};\n\nvector<edge>G[1234];\nbool used[1234];\n\nvector<tuple<int,int,int,int> > edges;\n\nint dfs(int v,int t,int f){\n  if(v==t)return f;\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    edge &e=G[v][i];\n    if(!used[e.to]&&e.cap>0){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n\te.cap-=d;\n\tG[e.to][e.rev].cap+=d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t,int mf=1e9){\n  if(s==t)return 0;\n  int flow=0;\n  for(;;){\n    fill(begin(used),end(used),false);\n    int f=dfs(s,t,mf);\n    if(f==0)return flow;\n    flow+=f;\n    if(flow==mf)return flow;\n  }\n} \n\nvoid add_edge(int from,int to,int cap=1){\n  edges.emplace_back(from,(int)G[from].size(),to,(int)G[to].size());\n  G[from].push_back({to,cap,G[to].size()});\n  G[to].push_back({from,0,G[from].size()-1});\n}\n\nint main(){\n  for(int N,M,S,T;cin>>N>>M>>S>>T,N|M|S|T;){\n    edges.clear();\n    for(auto &e:G){\n      e.clear();\n    }\n    for(int i=0;i<M;i++){\n      int a,b;\n      cin>>a>>b;\n      add_edge(a,b);\n    }\n    int df=max_flow(S,T);\n    int nr=0;\n    for(int i=0;i<M;i++){\n      int f,fx,t,tx;\n      tie(f,fx,t,tx)=edges[i];\n      bool rev=false;\n      if(G[f][fx].cap==0){\n\trev=true;\n\tmax_flow(f,S,1);\n\tmax_flow(T,t,1);\n      }\n      G[f][fx].cap=0;\n      G[t][tx].cap=1;\n      if(max_flow(S,T)>rev){\n\tnr++;\n      }\n      if(G[t][tx].cap==0){\n\tmax_flow(T,f,1);\n\tmax_flow(t,S,1);\n      }\n      G[f][fx].cap=1;\n      G[t][tx].cap=0;\n      max_flow(S,T);\n    }\n    cout<<df+!!nr<<' '<<nr<<endl;\n  }\n}\n\n\t  \n\t"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 1005\n\nenum Type{\n\tFROM_S,\n\tFROM_T,\n};\n\nstruct Edge{\n\tEdge(int arg_to,int arg_capacity,int arg_rev_index,bool arg_is_rev){\n\t\tto = arg_to;\n\t\tcapacity = arg_capacity;\n\t\trev_index = arg_rev_index;\n\t\tis_rev = arg_is_rev;\n\t}\n\tint to,capacity,rev_index;\n\tbool is_rev;\n};\n\nint V,E;\nint N,M,S,T;\n\nvector<Edge> G[NUM];\nbool used[NUM];\nbool can_reach[2][NUM];\n\nvoid add_edge(int from,int to,int capacity){\n\tG[from].push_back(Edge(to,capacity,G[to].size(),false));\n\tG[to].push_back(Edge(from,0,G[from].size()-1,true));\n}\n\nint dfs(int node_id,int sink,int flow){\n\tif(node_id == sink)return flow;\n\tused[node_id] = true;\n\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\tEdge &e = G[node_id][i];\n\t\tif(used[e.to] == false && e.capacity > 0){\n\t\t\tint tmp_flow = dfs(e.to,sink,min(flow,e.capacity));\n\t\t\tif(tmp_flow > 0){\n\t\t\t\te.capacity -= tmp_flow;\n\t\t\t\tG[e.to][e.rev_index].capacity += tmp_flow;\n\t\t\t\treturn tmp_flow;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid reach_check(Type type,int node_id){\n\n\tcan_reach[type][node_id] = true;\n\tint base;\n\n\tif(type == FROM_S){\n\t\tbase = 1;\n\t}else{\n\t\tbase = 0;\n\t}\n\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\tif(G[node_id][i].capacity == base && can_reach[type][G[node_id][i].to] == false){\n\t\t\treach_check(type,G[node_id][i].to);\n\t\t}\n\t}\n}\n\nint max_flow(int source,int sink){\n\tint flow = 0,add;\n\twhile(true){\n\t\tfor(int i = 0; i < V; i++)used[i] = false;\n\t\tadd = dfs(source,sink,BIG_NUM);\n\t\tif(add == 0)break;\n\t\tflow += add;\n\t}\n\treturn flow;\n}\n\nvoid func(){\n\n\tfor(int i = 0; i < N; i++){\n\t\tG[i].clear();\n\t\tcan_reach[FROM_S][i] = false;\n\t\tcan_reach[FROM_T][i] = false;\n\t}\n\n\tS--;\n\tT--;\n\n\tint from,to;\n\tfor(int loop = 0; loop < M; loop++){\n\t\tscanf(\"%d %d\",&from,&to);\n\t\tfrom--;\n\t\tto--;\n\t\tadd_edge(from,to,1);\n\t}\n\n\tV = N;\n\n\tint FLOW = max_flow(S,T);\n\tint MAX_FLOW = FLOW;\n\n\treach_check(FROM_S,S);\n\treach_check(FROM_T,T);\n\n\tint num_edge = 0,diff;\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < G[i].size(); k++){\n\t\t\tif(G[i][k].is_rev == true || G[i][k].capacity == 0 ||\n\t\t\t\t\tcan_reach[FROM_S][G[i][k].to] == false || can_reach[FROM_T][i] == false)continue;\n\n\t\t\tnum_edge++;\n\t\t\tMAX_FLOW = FLOW+1;\n\n\t\t}\n\t}\n\n\tprintf(\"%d %d\\n\",MAX_FLOW,num_edge);\n}\n\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d %d %d\",&N,&M,&S,&T);\n\t\tif(N == 0 && M == 0 && S == 0 && T == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define inf 1e9\n\nusing namespace std;\n\nstruct edge{\n\tint to, cap, rev, dir;\n\tedge(int a, int b, int c, int d){\n\t\tto = a, cap = b, rev = c, dir = d;\n\t}\n};\n\nint N, M, S, T;\nvector<edge> G[1005];\nbool reachS[1005], reachT[1005];\nbool used[1005];\n\nint dfs(int v, int f)\n{\n\tused[v] = true;\n\tif(v == T) return f;\n\t\n\tint ret;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(used[G[v][i].to] || G[v][i].cap <= 0) continue;\n\t\tret = dfs(G[v][i].to, min(f, G[v][i].cap));\n\t\tif(ret > 0){\n\t\t\tG[v][i].cap -= ret;\n\t\t\tG[G[v][i].to][G[v][i].rev].cap += ret;\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid add_edge(int s, int t, int cap)\n{\n\tG[s].push_back(edge(t, cap, G[t].size(), 0));\n\tG[t].push_back(edge(s, 0, G[s].size()-1, 1));\n}\n\nvoid reachdfsS(int v)\n{\n\treachS[v] = true;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(reachS[G[v][i].to]) continue;\n\t\tif(G[v][i].cap == 0) continue;\n\t\treachdfsS(G[v][i].to);\n\t}\n}\nvoid reachdfsT(int v)\n{\n\treachT[v] = true;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(reachT[G[v][i].to]) continue;\n\t\tif(G[v][i].cap == 1) continue;\n\t\treachdfsT(G[v][i].to);\n\t}\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> N >> M >> S >> T;\n\t\tif(!N && !M && !S && !T) break;\n\t\t\n\t\tfor(int i = 1; i <= N; i++) G[i].clear();\n\t\tint a, b;\n\t\tfor(int i = 1; i <= M; i++){\n\t\t\tcin >> a >> b;\n\t\t\tadd_edge(a, b, 1);\n\t\t}\n\t\t\n\t\tint ans = 0, flow;\n\t\twhile(1){\n\t\t\tfor(int i = 1; i <= N; i++) used[i] = false;\n\t\t\tflow = dfs(S, inf);\n\t\t\tif(flow <= 0) break;\n\t\t\tans += flow;\n\t\t}\n\t\t\n\t\tfor(int i = 1; i <= N; i++) reachS[i] = reachT[i] = false;\n\t\treachdfsS(S), reachdfsT(T);\n\t\t\n\t\tint ans2 = 0;\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tfor(int j = 0; j < G[i].size(); j++){\n\t\t\t\tif(G[i][j].cap == 0 || G[i][j].dir == 1) continue;\n\t\t\t\tif(reachS[G[i][j].to] && reachT[i]) ans2++;\n\t\t\t}\n\t\t}\n\t\tif(ans2) ans++;\n\t\t\n\t\tcout << ans << \" \" << ans2 << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\n#define MAX_V 1001\nusing namespace std;\ntypedef map<int,int> M;\nM G[MAX_V],rG[MAX_V],g[MAX_V];\nbool used[MAX_V];  \n\nint dfs(int v,int t,int f){\n  if(v == t)return f;\n  used[v]=true;\n  \n  for(M::iterator it=G[v].begin();it!=G[v].end() ;it++){\n    int to=it->first;\n    int &cap=it->second;\n    if(!used[to] && cap > 0){\n      int d = dfs(to ,t , min(f,cap));\n      if(d > 0){\n\tcap -= d;\n\tG[to][v]+=d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s, t, INF);\n    if(f == 0)return flow;\n    flow += f;\n  }\n}\n\nint visited[MAX_V];\nvoid visit(int pos){\n  if(visited[pos])return;\n  visited[pos]=1;\n  for(M::iterator it=rG[pos].begin();it!=rG[pos].end() ;it++)visit(it->first);\n}\n\nint check2(int pos){\n  if(used[pos]++) return 0;\n  int res=0; \n  for(M::iterator it=G[pos].begin();it!=G[pos].end() ;it++)\n    if(it->second)res+=check2(it->first);\n  \n  for(M::iterator it=g[pos].begin();it!=g[pos].end() ;it++)\n    res+=it->second*visited[it->first];\n  \n  return res;\n}\n\nint main(){\n  while(1){\n    int n,m,s,t;\n    cin>>n>>m>>s>>t;\n    if(!n&&!m&&!s&&!t)break;\n    s--,t--;\n    for(int i=0;i<n;i++) rG[i].clear(),G[i].clear(),g[i].clear();\n    \n    for(int i=0,a,b;i<m;i++){\n      cin>>a>>b;\n      a--,b--;\n      G[a][b]++;\n      g[b][a]++;\n    }\n\n    int mx=max_flow(s,t);\n    for(int i=0;i<n;i++)\n      for(M::iterator it=G[i].begin();it!=G[i].end() ;it++){\n\tint to=it->first,cap=it->second;\n\tif(cap)rG[to][i]=cap;\n      }\n    \n    memset(visited,0,sizeof(visited));\n    memset(used,0,sizeof(used));\n    visit(t);\n    int cnt=check2(s);\n    cout<<mx+(cnt>0)<<\" \"<<cnt<<endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\nint cap[1010][1010];\nint flow[1010][1010];\n\nbool used[1010];\nvector<int> G[1010];\nint N;\n\nint dfs(int v,int t,int f){\n//\tprintf(\"%d %d %d\\n\",v,t,f);\n\tif(v==t) return f;\n\tused[v]=true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tint u=G[v][i];\n\t\tif(used[u]) continue;\n\t\tint x=(cap[v][u]-flow[v][u])+flow[u][v];\n\t\tint nf=min(f,x);\n\t\tif(nf==0) continue;\n\t\tint ret=dfs(u,t,nf);\n\t\tif(ret>0){\n\t\t\tint tmp=cap[v][u]-flow[v][u];\n\t\t\tif(ret<=tmp){\n\t\t\t\tflow[v][u]+=ret;\n\t\t\t}else{\n\t\t\t\tflow[v][u]=cap[v][u];\n\t\t\t\tflow[u][v]-=(ret-tmp);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nbool can_reach[2][1010];\n\nqueue<int> que;\nvoid bfs(int s,bool *res,bool rev){\n\twhile(!que.empty()) que.pop();\n\tfor(int i=0;i<1010;i++) res[i]=false;\n\tque.push(s);\n\tres[s]=true;\n\twhile(!que.empty()){\n\t\tint v=que.front();\n\t\tque.pop();\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tint u=G[v][i];\n\t\t\tif(res[u]) continue;\n\t\t\tif(!rev){\n\t\t\t\tint x=(cap[v][u]-flow[v][u])+flow[u][v];\n\t\t\t\tif(x<=0) continue;\n\t\t\t}else{\n\t\t\t\tint x=(cap[u][v]-flow[u][v])+flow[v][u];\n\t\t\t\tif(x<=0) continue;\n\t\t\t}\n\t\t\tres[u]=true;\n\t\t\tque.push(u);\n\t\t}\n\t}\n}\n\nint maxFlow(int s,int t){\n\tint res=0;\n\twhile(true){\n\t\tfor(int i=0;i<1010;i++) used[i]=false;\n\t\tint f=dfs(s,t,100100);\n\t\tif(f==0) return res;\n\t\tres+=f;\n\t}\n\treturn -1;\n}\n\nint S,T;\n\nint count(){\n\tbfs(S,can_reach[0],false);\n\tbfs(T,can_reach[1],true);\n\tint res=0;\n\tfor(int i=0;i<N;i++) for(int j=0;j<N;j++){\n\t\tif(i==j) continue;\n\t\tif(can_reach[0][i]&&can_reach[1][j]){\n\t\t\tres+=cap[j][i];\n\t\t}\n\t}\n\tif(res>0) return res;\n\telse return -1;\n}\n\nvoid solve(){\n\tint flow=maxFlow(S,T);\n\tint num=count();\n\tif(num>0){\n\t\tprintf(\"%d %d\\n\",flow+1,num);\n\t}else{\n\t\tprintf(\"%d %d\\n\",flow,0);\n\t}\n}\n\nvoid init(){\n\tfor(int i=0;i<N;i++) for(int j=0;j<N;j++){\n\t\tcap[i][j]=0;\n\t\tflow[i][j]=0;\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tG[i].clear();\n\t}\n}\n\nvoid input(){\n\tinit();\n\tint M;\n\tscanf(\"%d%d\",&N,&M);\n\tscanf(\"%d%d\",&S,&T);\n\tif(S==0&&T==0) exit(0);\n\tS--;T--;\n\tfor(int i=0;i<M;i++){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tu--;v--;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t\tcap[u][v]++;\n\t}\n}\n\nint main(){\n\twhile(true){\n\t\tinput();\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\n\n\nconst int MAX_V = 5000;\nconst int INF = 1<<29;\n\nstruct Edge {\n    int rev, from, to, cap, icap;\n    Edge(int r, int f, int t, int c) : rev(r), from(f), to(t), cap(c), icap(c) {}\n};\n\nstruct Graph {\n    int V;\n    vector<Edge> list[MAX_V];\n    \n    Graph(int n = 0) : V(n) {for (int i = 0; i < MAX_V; ++i) list[i].clear();}\n    void init(int n = 0) {V = n; for (int i = 0; i < MAX_V; ++i) list[i].clear();}\n\tvoid resize(int n = 0) {V = n;}\n    void reset() {for (int i = 0; i < V; ++i) for (int j = 0; j < list[i].size(); ++j) list[i][j].cap = list[i][j].icap;}\n    inline vector<Edge>& operator [] (int i) {return list[i];}\n    \n    Edge &redge(Edge e) {\n        if (e.from != e.to) return list[e.to][e.rev];\n        else return list[e.to][e.rev+1];\n    }\n    \n    void addedge(int from, int to, int cap) {\n        list[from].push_back(Edge(list[to].size(), from, to, cap));\n        list[to].push_back(Edge(list[from].size()-1, to, from, 0));\n    }\n};\n\nGraph G;\n\n\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid dibfs(Graph &G, int s) {\n    memset(level, -1, sizeof(level));\n    level[s] = 0;\n    queue<int> que;\n    que.push(s);\n    while (!que.empty()) {\n        int v = que.front();\n        que.pop();\n        for (int i = 0; i < G[v].size(); ++i) {\n            Edge &e = G[v][i];\n            if (level[e.to] < 0 && e.cap > 0) {\n                level[e.to] = level[v] + 1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\nint didfs(Graph &G, int v, int t, int f) {\n    if (v == t) return f;\n    for(int &i = iter[v]; i < G[v].size(); ++i) {\n        Edge &e = G[v][i], &re = G.redge(e);\n        if (level[v] < level[e.to] && e.cap > 0) {\n            int d = didfs(G, e.to, t, min(f, e.cap));\n            if (d > 0) {\n                e.cap -= d;\n                re.cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint Dinic(Graph &G, int s, int t) {\n    int res = 0;\n    while (true) {\n        dibfs(G, s);\n        if (level[t] < 0) return res;\n        memset(iter, 0, sizeof(iter));\n        int flow;\n        while ((flow = didfs(G, s, t, INF)) > 0) {\n            res += flow;\n        }\n    }\n}\n\n\n\nint n, m, a, b, s, t;\nbool sreach[MAX_V], treach[MAX_V];\n\nvoid sdfs(Graph &G, int v) {\n    sreach[v] = true;\n    for (int i = 0; i < G[v].size(); ++i) \n        if (G[v][i].cap == 1 && !sreach[G[v][i].to]) \n            sdfs(G, G[v][i].to);\n}\n\nvoid tdfs(Graph &G, int v) {\n    treach[v] = true;\n    for (int i = 0; i < G[v].size(); ++i) \n        if (G[v][i].cap == 0 && !treach[G[v][i].to]) \n            tdfs(G, G[v][i].to);\n}\n\nint main() {\n    while (cin >> n >> m >> s >> t) {\n        if (n == 0) break;\n        \n        G.init(n);\n        for (int i = 0; i < m; ++i) {\n            cin >> a >> b;\n            --a; --b;\n            G.addedge(a, b, 1);\n        }\n        --s; --t;\n        \n        int res = Dinic(G, s, t);\n        int num = 0;\n        \n        memset(sreach, 0, sizeof(sreach)); sdfs(G, s);\n        memset(treach, 0, sizeof(treach)); tdfs(G, t);\n        \n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < G[i].size(); ++j) {\n                int from = i, to = G[i][j].to;\n                if (G[i][j].cap == 1 && G[i][j].icap == 1 && treach[from] && sreach[to]) {\n                    ++num;\n                }\n            }\n        }\n        \n        if (num > 0) ++res;\n        cout << res << \" \" << num << endl;\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct edge{\n\tint to,cap,rev;\n\tedge(){}\n\tedge(int tt,int cc,int rr){\n\t\tto=tt;\n\t\tcap=cc;\n\t\trev=rr;\n\t}\n};\n\nclass dinic{\npublic:\n\tconst int INF=100000;\n\tvector<edge> G[2001];\n\tint level[2001];\n\tint iter[2001];\n\tvoid add_edge(int from,int to,int cap){\n\t\tG[from].push_back(edge(to,cap,G[to].size()));\n\t\tG[to].push_back(edge(from,0,G[from].size()-1));\n\t}\n\n\tvoid bfs(int s){\n\t\tmemset(level,-1,sizeof(level));\n\t\tqueue<int> que;\n\t\tlevel[s]=0;\n\t\tque.push(s);\n\t\twhile(que.size()){\n\t\t\tint v=que.front();\n\t\t\tque.pop();\n\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\tedge &e=G[v][i];\n\t\t\t\tif(e.cap>0 && level[e.to]<0){\n\t\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint dfs(int v,int t,int f){\n\t\tif(v==t)return f;\n\t\tfor(int &i=iter[v];i<G[v].size();i++){\n\t\t\tedge &e=G[v][i];\n\t\t\tif(e.cap>0 && level[v]<level[e.to]){\n\t\t\t\tint d=dfs(e.to,t,min(e.cap,f));\n\t\t\t\tif(d>0){\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tint max_flow(int s,int t){\n\t\tint flow=0;\n\t\twhile(1){\n\t\t\tbfs(s);\n\t\t\tif(level[t]<0)return flow;\n\t\t\tmemset(iter,0,sizeof(iter));\n\t\t\tint f;\n\t\t\twhile((f=dfs(s,t,INF))>0){\n\t\t\t\tflow+=f;\n\t\t\t}\n\t\t}\n\t}\n};\n\nint n,m,s,t;\ndinic di;\nint a[10001],b[10001];\nbool ok[2][2001];\n\nvoid dfs(int v,int t){\n\tok[t][v]=true;\n\tfor(int i=0;i<di.G[v].size();i++){\n\t\tedge e=di.G[v][i];\n\t\tif(!ok[t][e.to]){\n\t\t\tif((t==1 && e.cap>0)){\n\t\t\t\tdfs(e.to,t);\n\t\t\t}\n\t\t\tif(t==0 && (v==(n+1) || e.cap==0)){\n\t\t\t\tdfs(e.to,t);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tint S=n,T=n+1;\n\tfor(int i=0;i<=T;i++){\n\t\tdi.G[i].clear();\n\t}\n\ts--;\n\tt--;\n\tdi.add_edge(S,s,114514);\n\tdi.add_edge(t,T,114514);\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t\ta[i]--;\n\t\tb[i]--;\n\t\tdi.add_edge(a[i],b[i],1);\n\t}\n\tint val=di.max_flow(S,T);\n\tmemset(ok,false,sizeof(ok));\n\tdfs(S,1);\n\tdfs(T,0);\n\tbool flag=false;\n\tint cnt=0;\n\tfor(int i=0;i<m;i++){\n\t\tif(ok[1][b[i]] && ok[0][a[i]]){\n\t\t\tcnt++;\n\t\t}\n\t}\n\tif(cnt>0)val++;\n\tprintf(\"%d %d\\n\",val,cnt);\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d%d%d\",&n,&m,&s,&t);\n\t\tif(n==0 && m==0)break;\n\t\tsolve();\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\nconst int INF = (1LL<<30);\nconst ll LLINF = (1LL<<60);\nconst double PI = 3.14159265359;\nconst double EPS = 1e-12;\nconst int MOD = 1000000007;\n//#define int ll\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\n#define MAX_N 10000\nstruct edge{ int to, cap, rev; };\n\nvector<edge> G[MAX_N];\nint level[MAX_N]; // s??????????????¢\nint iter[MAX_N];  // ???????????§??????????????£??????\n\nvoid add_edge(int from, int to, int cap) {\n  G[from].PB({to, cap, (int)G[to].size()});\n  G[to].PB({from, 0, (int)G[from].size()-1});\n}\n\nvoid bfs(int s) {\n  memset(level, -1, sizeof(level));\n  queue<int> que;\n  level[s] = 0;\n  que.push(s);\n  while(que.size()) {\n    int v = que.front(); que.pop();\n    for(auto i: G[v]) {\n      if(i.cap > 0 && level[i.to] < 0) {\n        level[i.to] = level[v] + 1;\n        que.push(i.to);\n      }\n    }\n  }\n}\n\nint dfs(int v, int t, int f) {\n  if(v == t) return f;\n  for(int &i = iter[v]; i<(int)G[v].size(); ++i) {\n    edge &e = G[v][i];\n    if(e.cap > 0 && level[v] < level[e.to]) {\n      int d = dfs(e.to, t, min(f, e.cap));\n      if(d > 0) {\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s, int t) {\n  int flow = 0;\n  while(1) {\n    bfs(s);\n    if(level[t] < 0) return flow;\n    memset(iter, 0, sizeof(iter));\n    int f;\n    while((f = dfs(s, t, INF)) > 0) flow += f;\n  }\n}\n\nint a[10010], b[10010];\nsigned main(void)\n{\n  while(true) {\n    int n, m, s, t;\n    cin >> n >> m >> s >> t, s--, t--;\n    if(!n) break;\n    REP(i, m) cin >> a[i] >> b[i], a[i]--, b[i]--;\n\n    //????????????\n    REP(i, n) G[i].clear();\n    REP(i, m) add_edge(a[i], b[i], 1);\n    int ma = max_flow(s, t), cnt = 1;\n\n    bool update = false;\n    //i?????????????????????\n    REP(i, m) {\n      REP(j, n) G[i].clear();\n      REP(j, m) {\n        if(i == j) add_edge(b[j], a[j], 1);\n        else add_edge(a[j], b[j], 1);\n      }\n      int ret = max_flow(s, t);\n      if(ret > ma) {\n        update = true;\n        ma = ret;\n        cnt = 1;\n      } else if(ret == ma) {\n        cnt++;\n      }\n    }\n    if(!update) cnt = 0;\n\n    cout << ma << \" \" << cnt << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\n#include <map>\n#include <unordered_set>\nusing namespace std;\n\nusing Weight = int;\nusing Capacity = int;\nstruct Edge {\n\tint src, dst; Weight weight; Capacity cap;\n\tEdge(int s, int d, Weight w, Capacity c) : src(s), dst(d), weight(w), cap(c) {}\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\nstruct Dinic {\n\tint n, s, t;\n\tvector<int> level, prog, que;\n\tvector<vector<Capacity>> cap, flow;\n\tvector<vector<int>> g;\n\tCapacity inf;\n\tDinic(const Graph &graph)\n\t\t: n(graph.size()),\n\t\tcap(n, vector<Capacity>(n)), flow(n, vector<Capacity>(n)),\n\t\tg(n, vector<int>()), inf(numeric_limits<Capacity>::max() / 8) {\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tfor(auto &e : graph[i]) {\n\t\t\t\tint u = e.src, v = e.dst;\n\t\t\t\tCapacity c = e.cap;\n\t\t\t\tcap[u][v] += c; cap[v][u] += c; flow[v][u] += c;\n\t\t\t\tg[u].push_back(v); g[v].push_back(u);\n\t\t\t}\n\t\t}\n\t}\n\tinline Capacity residue(int u, int v) { return cap[u][v] - flow[u][v]; }\n\tCapacity solve(int s_, int t_) {\n\t\tthis->t = t_, this->s = s_;\n\t\tque.resize(n + 1);\n\t\tCapacity res = 0;\n\t\twhile(levelize()) { prog.assign(n, 0); res += augment(s, inf); }\n\t\treturn res;\n\t}\n\tbool levelize() {\n\t\tint l = 0, r = 0;\n\t\tlevel.assign(n, -1); level[s] = 0; que[r++] = s;\n\t\twhile(l != r) {\n\t\t\tint v = que[l++]; if(v == t) break;\n\t\t\tfor(const int &d : g[v]) if(level[d] == -1 && residue(v, d) != 0) {\n\t\t\t\tlevel[d] = level[v] + 1; que[r++] = d;\n\t\t\t}\n\t\t}\n\t\treturn level[t] != -1;\n\t}\n\tCapacity augment(int v, Capacity lim) {\n\t\tCapacity res = 0;\n\t\tif(v == t) return lim;\n\t\tfor(int &i = prog[v]; i < (int)g[v].size(); i++) {\n\t\t\tconst int &d = g[v][i];\n\t\t\tif(residue(v, d) == 0 || level[v] >= level[d]) continue;\n\t\t\tconst Capacity aug = augment(d, min(lim, residue(v, d)));\n\t\t\tflow[v][d] += aug; flow[d][v] -= aug;\n\t\t\tres += aug; lim -= aug;\n\t\t\tif(lim == 0) break;\n\t\t}\n\t\treturn res;\n\t}\n};\n\ntypedef pair<int, int> Pii;\n\nvector<int> RG[2][1010];\nunordered_set<int> visit[2];\n\nint a[10010];\nint b[10010];\nbool used[1010];\n\nvoid dfs(int v, int p, int gi) {\n\tused[v] = true;\n\tvisit[gi].insert(v);\n\tfor(int c : RG[gi][v]) {\n\t\tif(c == p) continue;\n\t\tif(!used[c]) dfs(c, v, gi);\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, M, S, T;\n\twhile(cin >> N >> M >> S >> T, N) {\n\t\tGraph G(N + 1);\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tcin >> a[i] >> b[i];\n\t\t\tG[a[i]].push_back(Edge(a[i], b[i], 1, 1));\n\t\t}\n\n\t\tDinic dinic(G);\n\t\tint flow = dinic.solve(S, T);\n\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tRG[0][i].clear();\n\t\t\tRG[1][i].clear();\n\t\t}\n\t\tvisit[0].clear();\n\t\tvisit[1].clear();\n\n\t\tfor(int u = 0; u < N; u++) {\n\t\t\tfor(int v : dinic.g[u]) {\n\t\t\t\tif(dinic.residue(u, v) != 0) {\n\t\t\t\t\tRG[0][u].push_back(v);\n\t\t\t\t\tRG[1][v].push_back(u);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmemset(used, 0, sizeof used);\n\t\tdfs(S, -1, 0);\n\t\tmemset(used, 0, sizeof used);\n\t\tdfs(T, -1, 1);\n\n\t\tint num = 0;\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tif(visit[0].find(b[i]) != visit[0].end() && visit[1].find(a[i]) != visit[1].end()) {\n\t\t\t\tnum++;\n\t\t\t}\n\t\t}\n\n\t\tcout << flow + (num > 0) << \" \" << num << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<queue>\nusing namespace std;\nconst int D_MAX_V=2002;\nconst int D_v_size=2002;\nstruct D_wolf{\n\tint t,c,r;\n\tD_wolf(){t=c=r=0;}\n\tD_wolf(int t1,int c1,int r1){\n\t\tt=t1;c=c1;r=r1;\n\t}\n};\nvector<D_wolf>D_G[D_MAX_V];\nint D_level[D_MAX_V];\nint D_iter[D_MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n/*\tfor(int i=0;i<D_G[from].size();i++){\n\t\tif(to==D_G[from][i].t){\n\t\t\tD_G[from][i].c+=cap;\n\t\t\treturn;\n\t\t}\n\t}*/\n\tD_G[from].push_back(D_wolf(to,cap,D_G[to].size()));\n\tD_G[to].push_back(D_wolf(from,0,D_G[from].size()-1));\n}\nvoid D_bfs(int s){\n\tfor(int i=0;i<D_v_size;i++)D_level[i]=-1;\n\tqueue<int> Q;\n\tD_level[s]=0;\n\tQ.push(s);\n\twhile(Q.size()){\n\t\tint v=Q.front();\n\t\tQ.pop();\n\t\tfor(int i=0;i<D_G[v].size();i++){\n\t\t\tif(D_G[v][i].c>0&&D_level[D_G[v][i].t]<0){\n\t\t\t\tD_level[D_G[v][i].t]=D_level[v]+1;\n\t\t\t\tQ.push(D_G[v][i].t);\n\t\t\t}\n\t\t}\n\t}\n}\nint D_dfs(int v,int t,int f){\n\tif(v==t)return f;\n\tfor(;D_iter[v]<D_G[v].size();D_iter[v]++){\n\t\tint i=D_iter[v];\n\t\tif(D_G[v][i].c>0&&D_level[v]<D_level[D_G[v][i].t]){\n\t\t\tint d=D_dfs(D_G[v][i].t,t,min(f,D_G[v][i].c));\n\t\t\tif(d>0){\n\t\t\t\tD_G[v][i].c-=d;\n\t\t\t\tD_G[D_G[v][i].t][D_G[v][i].r].c+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s,int t){\n\tint flow=0;\n\tfor(;;){\n\t\tD_bfs(s);\n\t\tif(D_level[t]<0)return flow;\n\t\tfor(int i=0;i<D_v_size;i++)D_iter[i]=0;\n\t\tint f;\n\t\twhile((f=D_dfs(s,t,99999999))>0){flow+=f;}\n\t}\n\treturn 0;\n}\nint c,d;\nint x[1100];\nint y[1100];\n\nint N;\n\nint p[11000];\nint q[11000];\nint at[11000];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d%d%d\",&a,&b,&c,&d),a){\n\t\tc--;d--;\n\t\tN=a;\n\t\tfor(int i=0;i<2002;i++){\n\t\t\tD_G[i].clear();\n\t\t\tD_level[i]=D_iter[i]=0;\n\t\t}\n\t\tfor(int i=0;i<b;i++){\n\t\t\tscanf(\"%d%d\",p+i,q+i);\n\t\t\tp[i]--;q[i]--;\n\t\t\tat[i]=D_G[p[i]].size();\n\t\t\tadd_edge(p[i],q[i],1);\n\t\t}\n\t\tint v=max_flow(c,d);\n\t\tqueue<int>Q;\n\t\tfor(int i=0;i<a;i++)x[i]=y[i]=0;\n\t\tx[c]=1;\n\t\tQ.push(c);\n\t\twhile(Q.size()){\n\t\t\tint now=Q.front();Q.pop();\n\t\t\tfor(int i=0;i<D_G[now].size();i++){\n\t\t\t\tif(!x[D_G[now][i].t]&&D_G[now][i].c){\n\t\t\t\t\tx[D_G[now][i].t]=1;\n\t\t\t\t\tQ.push(D_G[now][i].t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ty[d]=1;\n\t\tQ.push(d);\n\t\twhile(Q.size()){\n\t\t\tint now=Q.front();Q.pop();\n\t\t\tfor(int i=0;i<D_G[now].size();i++){\n\t\t\t\tif(!y[D_G[now][i].t]&&D_G[D_G[now][i].t][D_G[now][i].r].c){\n\t\t\t\t\ty[D_G[now][i].t]=1;\n\t\t\t\t\tQ.push(D_G[now][i].t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=0;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tif(D_G[p[i]][at[i]].c==0)continue;\n\t\t\tif(x[q[i]]&&y[p[i]])ret++;\n\t\t}\n\t\tif(ret==0)printf(\"%d %d\\n\",v,ret);\n\t\telse printf(\"%d %d\\n\",v+1,ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\nstruct edge{int to,cap,rev;};\nconst int MAX_V=1000,inf=1e8;\nvector<edge> G[MAX_V];\nint level[MAX_V],iter[MAX_V],ord[MAX_V];\nint N,M,S,T,a[10000],b[10000];\nvoid add_edge(int from,int to,int cap,int i){\n\tedge e1={to,cap,(int)G[to].size()},e2={from,0,(int)G[from].size()};\n\tG[from].pb(e1);\n\tG[to].pb(e2);\n\tord[i]=G[from].size()-1;\n}\nvoid bfs(int s){\n\tmemset(level,-1,sizeof(level));\n\tqueue<int> que;\n\tlevel[s]=0;\n\tque.push(s);\n\twhile(!que.empty()){\n\t\tint v=que.front();\n\t\tque.pop();\n\t\trep(i,G[v].size()){\n\t\t\tedge &e=G[v][i];\n\t\t\tif(e.cap>0&&level[e.to]<0){\n\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\nint dfs(int v,int t,int f){\n\tif(v==t) return f;\n\tfor(int &i=iter[v];i<G[v].size();i++){\n\t\tedge &e=G[v][i];\n\t\tif(e.cap>0&&level[v]<level[e.to]){\n\t\t\tint d=dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0){\n\t\t\t\te.cap-=d;\n\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s,int t){\n\tint flow=0;\n\twhile(true){\n\t\tbfs(s);\n\t\tif(level[t]<0) return flow;\n\t\tmemset(iter,0,sizeof(iter));\n\t\tint f;\n\t\twhile((f=dfs(s,t,inf))>0) flow+=f;\n\t}\n}\nbool froms[MAX_V],tot[MAX_V];\nvoid dfs1(int v){//from s\n\tfroms[v]=1;\n\tfor(auto e:G[v]){\n\t\tif(e.cap<=0) continue;\n\t\tif(froms[e.to]) continue;\n\t\tdfs1(e.to);\n\t}\n}\nvoid dfs2(int v){//to t\n\ttot[v]=1;\n\tfor(auto e:G[v]){\n\t\tif(e.cap>0) continue;\n\t\tif(tot[e.to]) continue;\n\t\tdfs2(e.to);\n\t}\n}\nint main(){\n\twhile(true){\n\t\tcin>>N>>M>>S>>T;\n\t\tif(N==0) break;\n\t\trep(i,N) G[i].clear();\n\t\tS--,T--;\n\t\trep(i,M) cin>>a[i]>>b[i];\n\t\trep(i,M){\n\t\t\ta[i]--,b[i]--;\n\t\t\tadd_edge(a[i],b[i],1,i);\n\t\t}\n\t\tint f=max_flow(S,T);\n\t\tint cnt=0;\n\t\trep(i,N) froms[i]=0,tot[i]=0;\n\t\tdfs1(S);\n\t\tdfs2(T);\n\t\trep(i,M){\n\t\t\tif(G[a[i]][ord[i]].cap<1) continue;\n\t\t\tif(froms[b[i]]&&tot[a[i]]) cnt++;\n\t\t}\n\t\tif(cnt>0) f++;\n\t\tcout<<f<<\" \"<<cnt<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\n#define MAX_V 10000\nusing namespace std;\n\n/*?????§?????¢?????´?????????(Ford_Fulerson????????¨)???O(F|E|)*/\n\n//????????¨????§???????(???????????????????????????)\nstruct edge{int to, cap, rev, s;};\n\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size(),0});\n  G[to].push_back((edge){from,0,(int)G[from].size()-1,1});  \n}\n\n//?¢?????????????DFS??§??¢???\nint dfs(int v,int t,int f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs(e.to ,t , min(f,e.cap));\n      if(d > 0){\n\te.cap -= d;\n\tG[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\n//s??????t???????????§???????±???????\nint max_flow(int s,int t,int maxf){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s, t, maxf);\n    if(f == 0)return flow;\n    maxf-=f;\n    flow += f;\n  }\n}\n\nint n, m, s, t;\n\nvoid solve(){\n  \n  int r = max_flow(s, t, INF);\n  int maxflow=r;\n  \n  unordered_map<int,int> cnt;\n  \n  for(int i=1;i<=n;i++){\n    \n    for(int j=0;j<G[i].size();j++){\n      \n      edge &s1 = G[i][j];\n      edge &t1 = G[s1.to][s1.rev];\n      \n      if(s1.s) continue;\n      if(t1.cap==1) continue;\n      \n      int rev=t1.cap, f=r-rev;\n      \n      s1.cap=t1.cap=0;\n      \n      max_flow(t,s1.to,rev);\n\n      max_flow(i,s,rev);\n      \n      t1.cap=1;\n      \n      f+=max_flow(s,t,1);\n      \n      if(maxflow<f) maxflow=f;\n      \n      cnt[f]++;\n      \n      rev=max(0,f-r);\n      \n      s1.cap=t1.cap=0;\n      \n      max_flow(s1.to,s,rev);\n      \n      max_flow(t,i,rev);\n      \n      s1.cap=1;\n            \n      max_flow(s,t,1);\n      \n    }\n    \n  }\n\n  int revcnt=0;\n\n  if(r<maxflow){\n    for(pair<int,int> d : cnt)\n      if(maxflow==d.first) revcnt+=d.second;\n  }\n  \n  cout<<maxflow<<' '<<revcnt<<endl;\n  \n}\n\nvoid init(){\n  for(int i=0;i<MAX_V;i++) G[i].clear();\n}\n\nint main(){\n\n  while(1){\n    \n    cin>>n>>m>>s>>t;\n    if(!n&&!m&&!s&&!t) break;\n\n    init();\n    \n    for(int i=0;i<m;i++){\n      int a, b;\n      cin>>a>>b;\n      add_edge(a,b,1);\n    }\n  \n    solve();\n  }\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) cerr << #x << \" = \" << (x) << endl\nusing namespace std;\nconstexpr int INF = 1 << 30;\ntemplate <typename Functor>\nstruct fix_type\n{\n    Functor functor;\n    template <typename... Args>\n    decltype(auto) operator()(Args&&... args) const& { return functor(functor, std::forward<Args>(args)...); }\n};\ntemplate <typename Functor>\nfix_type<typename std::decay<Functor>::type> fix(Functor&& functor) { return {std::forward<Functor>(functor)}; }\nclass Flow\n{\npublic:\n    struct Edge\n    {\n        int from, to, reverse, capacity, flow;\n        const bool is_reverse;\n    };\n    Flow(const int v) : V{v}, edge(v) {}\n    void addEdge(const int from, const int to, const int capacity)\n    {\n        edge[from].push_back(Edge{from, to, (int)edge[to].size(), capacity, 0, false});\n        edge[to].push_back(Edge{to, from, (int)edge[from].size() - 1, capacity, capacity, true});\n    }\n    int FordFulkerson(const int s, const int t)\n    {\n        vector<bool> checked(V);\n        auto dfs = fix([&](auto&& self, const int pos, const int flow) -> int {\n            if (pos == t) { return flow; }\n            checked[pos] = true;\n            for (auto& e : edge[pos]) {\n                if (not checked[e.to]) {\n                    const int res = e.capacity - e.flow;\n                    if (res > 0) {\n                        const int d = self(self, e.to, min(flow, res));\n                        if (d > 0) {\n                            e.flow += min(d, res);\n                            edge[e.to][e.reverse].flow -= min(d, res);\n                            return d;\n                        }\n                    }\n                }\n            }\n            return 0;\n        });\n        int flow = 0;\n        while (true) {\n            for (int i = 0; i < V; i++) { checked[i] = false; }\n            const int f = dfs(s, INF);\n            if (f == 0) { break; }\n            flow += f;\n        }\n        return flow;\n    }\n    const int V;\n    vector<vector<Edge>> edge;\n};\nstruct Graph\n{\n    Graph(const int v) : V{v}, edge(v), rev_edge(v) {}\n    void addEdge(const int from, const int to)\n    {\n        edge[from].push_back(to);\n        rev_edge[to].push_back(from);\n    }\n    const int V;\n    vector<vector<int>> edge;\n    vector<vector<int>> rev_edge;\n};\n\nint main()\n{\n    while (true) {\n        int N, M, S, T;\n        cin >> N >> M >> S >> T;\n        if (N == 0 and M == 0 and S == 0 and T == 0) { break; }\n        Flow f(N);\n        using P = pair<int, int>;\n        for (int i = 0; i < M; i++) {\n            int a, b;\n            cin >> a >> b;\n            f.addEdge(a - 1, b - 1, 1);\n        }\n        const int F = f.FordFulkerson(S - 1, T - 1);\n        Graph g(N);\n        vector<P> E;\n        for (int i = 0; i < N; i++) {\n            for (const auto& e : f.edge[i]) {\n                if (not e.is_reverse) {\n                    e.flow == 0 ? g.addEdge(e.from, e.to) : g.addEdge(e.to, e.from);\n                    if (e.flow == 0) { E.push_back({e.from, e.to}); }\n                }\n            }\n        }\n        auto dijk = [&](const int s, const bool rev) -> vector<int> {\n            vector<int> ans(N, INF);\n            priority_queue<P, vector<P>, greater<P>> q;\n            ans[s] = 0;\n            q.push(make_pair(0, s));\n            while (not q.empty()) {\n                const P& p = q.top();\n                const int cost = p.first;\n                const int v = p.second;\n                q.pop();\n                if (ans[v] < cost) { continue; }\n                for (const int to : (rev ? g.rev_edge[v] : g.edge[v])) {\n                    if (ans[to] > ans[v] + 1) {\n                        ans[to] = ans[v] + 1;\n                        q.push(make_pair(ans[to], to));\n                    }\n                }\n            }\n            return ans;\n        };\n        const auto d = dijk(S - 1, false);\n        const auto revd = dijk(T - 1, true);\n        int ans = 0;\n        for (const auto& e : E) {\n            if (d[e.second] != INF and revd[e.first] != INF) { ans++; }\n        }\n        cout << (F + (ans > 0 ? 1 : 0)) << \" \" << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\nconst int D_MAX_V=2002;\nconst int D_v_size=2002;\nstruct D_wolf{\n\tint t,c,r;\n\tD_wolf(){t=c=r=0;}\n\tD_wolf(int t1,int c1,int r1){\n\t\tt=t1;c=c1;r=r1;\n\t}\n};\nvector<D_wolf>D_G[D_MAX_V];\nint D_level[D_MAX_V];\nint D_iter[D_MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n\tfor(int i=0;i<D_G[from].size();i++){\n\t\tif(to==D_G[from][i].t){\n\t\t\tD_G[from][i].c+=cap;\n\t\t\treturn;\n\t\t}\n\t}\n\tD_G[from].push_back(D_wolf(to,cap,D_G[to].size()));\n\tD_G[to].push_back(D_wolf(from,0,D_G[from].size()-1));\n}\nvoid D_bfs(int s){\n\tfor(int i=0;i<D_v_size;i++)D_level[i]=-1;\n\tqueue<int> Q;\n\tD_level[s]=0;\n\tQ.push(s);\n\twhile(Q.size()){\n\t\tint v=Q.front();\n\t\tQ.pop();\n\t\tfor(int i=0;i<D_G[v].size();i++){\n\t\t\tif(D_G[v][i].c>0&&D_level[D_G[v][i].t]<0){\n\t\t\t\tD_level[D_G[v][i].t]=D_level[v]+1;\n\t\t\t\tQ.push(D_G[v][i].t);\n\t\t\t}\n\t\t}\n\t}\n}\nint D_dfs(int v,int t,int f){\n\tif(v==t)return f;\n\tfor(;D_iter[v]<D_G[v].size();D_iter[v]++){\n\t\tint i=D_iter[v];\n\t\tif(D_G[v][i].c>0&&D_level[v]<D_level[D_G[v][i].t]){\n\t\t\tint d=D_dfs(D_G[v][i].t,t,min(f,D_G[v][i].c));\n\t\t\tif(d>0){\n\t\t\t\tD_G[v][i].c-=d;\n\t\t\t\tD_G[D_G[v][i].t][D_G[v][i].r].c+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s,int t){\n\tint flow=0;\n\tfor(;;){\n\t\tD_bfs(s);\n\t\tif(D_level[t]<0)return flow;\n\t\tfor(int i=0;i<D_v_size;i++)D_iter[i]=0;\n\t\tint f;\n\t\twhile((f=D_dfs(s,t,99999999))>0){flow+=f;}\n\t}\n\treturn 0;\n}\nint c,d;\nint vis[1100];\nint dfs(int u,int v){\n\tif(u==v){\n\t\treturn 1;\n\t}\n\tvis[u]=1;\n\tfor(int i=0;i<D_G[u].size();i++){\n\t\tif(vis[D_G[u][i].t])continue;\n\t\tif(!D_G[u][i].c)continue;\n\t\tif(dfs(D_G[u][i].t,v)){\n\t\t\tD_G[u][i].c--;\n\t\t\tD_G[D_G[u][i].t][D_G[u][i].r].c++;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint N;\nint Minus(int s,int t){\n\tfor(int i=0;i<D_G[s].size();i++){\n\t\tif(D_G[s][i].t==t){\n\t\t\tif(D_G[s][i].c){\n\t\t\t\tD_G[s][i].c--;return 0;\n\t\t\t}else{\n\t\t\t\tfor(int j=0;j<N;j++)vis[j]=0;\n\t\t\t\tif(dfs(s,t))return 0;\n\t\t\t\tfor(int j=0;j<N;j++)vis[j]=0;\n\t\t\t\tdfs(d,t);\n\t\t\t\tfor(int j=0;j<N;j++)vis[j]=0;\n\t\t\t\tdfs(s,c);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n}\nint Plus(int s,int t){\n\tfor(int i=0;i<D_G[s].size();i++){\n\t\tif(D_G[s][i].t==t){D_G[s][i].c++;break;}\n\t}\n\tfor(int j=0;j<N;j++)vis[j]=0;\n\treturn dfs(c,d);\n}\nint p[11000];\nint q[11000];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d%d%d\",&a,&b,&c,&d),a){\n\t\tc--;d--;\n\t\tN=a;\n\t\tfor(int i=0;i<2002;i++){\n\t\t\tD_G[i].clear();\n\t\t\tD_level[i]=D_iter[i]=0;\n\t\t}\n\t\tfor(int i=0;i<b;i++){\n\t\t\tscanf(\"%d%d\",p+i,q+i);\n\t\t\tp[i]--;q[i]--;\n\t\t\tadd_edge(p[i],q[i],1);\n\t\t}\n\t\tint v=max_flow(c,d);\n\t\tint ret=0;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint t2=Plus(q[i],p[i]);\n\t\t\tif(!t2){\n\t\t\t\tMinus(q[i],p[i]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint t1=Minus(p[i],q[i]);\n\t\t//\tprintf(\"%d %d: %d %d\\n\",p[i],q[i],t1,t2);\n\t\t\tif(t1==0&&t2){\n\t\t\t\tret++;\n\t\t\t}\n\t\t\tMinus(q[i],p[i]);\n\t\t\tPlus(p[i],q[i]);\n\t\t}\n\t\tif(ret==0)printf(\"%d %d\\n\",v,ret);\n\t\telse printf(\"%d %d\\n\",v+1,ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct I{I(){ios::sync_with_stdio(false);cin.tie(0);}}init;\n\nstruct edge{\n    int flow,to,rev;\n};\n\ntypedef vector<edge> E;\ntypedef vector<E> Graph;\ntypedef vector<int> VI;\ntypedef vector<VI> VV;\nvoid addedge(Graph &g,int s,int t,int f,int rf){\n    int n=g[s].size();\n    int m=g[t].size();\n    g[s].push_back(edge{f,t,m});\n    g[t].push_back(edge{rf,s,n});\n}\nVI bfs(Graph &G,int s){\n    int N=G.size();\n    queue<int> que;\n    VI dist(N,-1);\n    dist[s]=0;\n    que.push(s);\n    for(;!que.empty();que.pop()){\n        auto v=que.front();\n        for(auto &e:G[v])\n            if(e.flow>0&&dist[e.to]==-1){\n                dist[e.to]=dist[v]+1;\n                que.push(e.to);\n            }\n    }\n    return dist;\n}\n\nint maxflow(Graph& G,int s,int t){\n    int res=0;\n    int N=G.size();\n    while(true){\n        auto dist=bfs(G,s);\n        if(dist[t]<0)break;\n        vector<size_t> iter(N,0);\n        std::function<int(int,int)> dfs=[&](int v,int f){\n            if(v==s)return f;\n            for(auto &i=iter[v];i<G[v].size();i++){\n                edge &e=G[v][i];\n                edge &re=G[e.to][e.rev];\n                if(re.flow>0&&dist[v]>dist[e.to]){\n                    int d=dfs(e.to,min(f,re.flow));\n                    if(d>0){e.flow+=d;re.flow-=d;return d;}\n                }\n            }\n            return 0;\n        };\n        int f;\n        while((f=dfs(t,114514))>0)res+=f;\n      \n    }\n    return res;\n}\n\nint main(){\n    for(int N,M,S,T;cin>>N>>M>>S>>T,N+M+S+T;){\n        S--;T--;\n        VV edge(N,VI(N,0));\n        Graph G(N);\n        for(int i=0;i<M;i++){\n            int a,b;cin>>a>>b;\n            edge[a-1][b-1]++;\n        }\n        for(int a=0;a<N;a++)\n            for(int b=a+1;b<N;b++)\n                if(edge[a][b]>0||edge[b][a]>0)\n                    addedge(G,a,b,edge[a][b],edge[b][a]);\n        int flow=maxflow(G,S,T);\n        int add=0;\n        int cnt=0;\n        queue<int> que;\n        VI color(N,-1);\n        que.push(S);\n        color[S]=0;\n        while(que.size()){\n            int v=que.front();que.pop();\n            for(auto &e:G[v]){\n                if(e.flow>0&&color[e.to]==-1){\n                    color[e.to]=color[v];\n                    que.push(e.to);\n                }\n            }\n        }\n        que.push(T);\n        color[T]=1;\n        while(que.size()){\n            int v=que.front();que.pop();\n            for(auto &e:G[v]){\n                auto &re=G[e.to][e.rev];\n                if(re.flow>0&&color[e.to]==-1){\n                    color[e.to]=color[v];\n                    que.push(e.to);\n                }\n            }\n        }\n        for(int a=0;a<N;a++)\n            for(int b=0;b<N;b++)\n                if(color[a]==1&&color[b]==0&&edge[a][b]>0)\n                    cnt+=edge[a][b],add=1;\n        cout<<flow+add<<\" \"<<cnt<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\n#include<string.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nstruct edge{\n\tint to;\n\tint cap;\n\tint rev;\n};\n\nstruct flow{\n\tvector<edge> G[1002];\n\tbool used[1002];\n\tvoid add_edge(int from,int to,int cap){\n\t\tedge a = {to,cap,G[to].size()};\n\t\tedge b = {from,0,G[from].size()};\n\t\tG[from].push_back(a);\n\t\tG[to].push_back(b);\n\t}\n\tint dfs(int v,int t,int f){\n\t\tif(v == t)return f;\n\t\tused[v] = true;\n\t\tfor(int i = 0 ; i < G[v].size() ; i ++){\n\t\t\tedge &e = G[v][i];\n\t\t\tif(!used[e.to] && e.cap > 0){\n\t\t\t\tint d = dfs(e.to,t,min(f,e.cap));\n\t\t\t\tif(d > 0){\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s,int t){\n\t\tint flow = 0;\n\t\twhile(1){\n\t\t\trep(i,1002)used[i] = false;\n\t\t\tint f = dfs(s,t,INF);\n\t\t\tif(f == 0)return flow;\n\t\t\tflow += f;\n\t\t}\n\t}\n\tvoid init(){\n\t\trep(i,1002)G[i].clear();\n\t}\n}F;\n\nint flag[1002];\nvoid dfs(int v){\n\tif(flag[v] == 1)return;\n\tflag[v] = 1;\n\trep(i,F.G[v].size()){\n\t\tedge ed = F.G[v][i];\n\t\tif(ed.cap > 0)dfs(ed.to);\n\t}\n}\nvoid dfs_rev(int v){\n\tif(flag[v] == -1)return;\n\tflag[v] = -1;\n\trep(i,F.G[v].size()){\n\t\tedge ed = F.G[v][i];\n\t\tif(ed.cap == 0)dfs_rev(ed.to);\n\t}\n}\n\nint main(){\n\twhile(1){\n\t\tint n,m,s,t;\n\t\tcin >> n >> m >> s >> t;\n\t\tif(n == 0)return 0;\n\t\tint a[10002],b[10002];\n\t\trep(i,m){\n\t\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t\t}\n\t\t\n\t\tF.init();\n\t\trep(i,m){\n\t\t\tF.add_edge(a[i],b[i],1);\n\t\t}\n\t\tint ret = F.max_flow(s,t);\n\t\trep1(i,n)flag[i] = 0;\n\t\tdfs(s);\n\t\tdfs_rev(t);\n\t\tint cnt = 0;\n\t\trep(i,m){\n\t\t\tif(flag[a[i]] == -1 && flag[b[i]] == 1)cnt ++;\n\t\t}\n\t\tprintf(\"%d %d\\n\",ret+(cnt==0?0:1),cnt);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef _WIN32\n#define scanfll(x) scanf(\"%I64d\", x)\n#define printfll(x) printf(\"%I64d\", x)\n#else\n#define scanfll(x) scanf(\"%lld\", x)\n#define printfll(x) printf(\"%lld\", x)\n#endif\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using ld = long double; using vll = vector<ll>; using vvll = vector<vll>; using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>;\nvll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\nusing P = pair<ll, ll>;\n\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; cout << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const unordered_map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvoid printbits(ll mask, ll n) { rep(i, n) { cout << !!(mask & (1ll << i)); } cout << endl; }\n#define ldout fixed << setprecision(40) \n\nstatic const double EPS = 1e-14;\nstatic const long long mo = 1e9+7;\n\n/***********************/\n// ??±?????¨???\n/***********************/\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntypedef long long Weight;\nconst Weight INF = 1e18;\n\nstruct Edge {\n    ll src, dst;\n    ll cap = 1;\n    Weight weight;\n    ll rev; // ????????°?????????????????¨\n    bool rev_flag = false; // rev??????1\n    Edge() {};\n    Edge(ll src, ll dst, Weight weight) :\n        src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n    return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n        e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid addDirected(Graph& g, ll src, ll dst, Weight weight, ll cap) {\n    assert(src < g.size() && src >= 0 && dst < g.size() && dst >= 0);\n    Edge e = Edge(src, dst, weight);\n    e.cap = cap;\n    g[src].push_back(e); \n}\nvoid addDirected(Graph& g, ll src, ll dst, Weight weight) { assert(src < g.size() && src >= 0 && dst < g.size() && dst >= 0); g[src].push_back(Edge(src, dst, weight)); }\nvoid addUndirected(Graph& g, ll src, ll dst, Weight weight) { assert(src < g.size() && src >= 0 && dst < g.size() && dst >= 0); g[src].push_back(Edge(src, dst, weight)); g[dst].push_back(Edge(dst, src, weight)); }\nvoid addDirected(Graph& g, ll src, ll dst) { addDirected(g, src, dst, 1); }\nvoid addUndirected(Graph& g, ll src, ll dst) { addUndirected(g, src, dst, 1); }\n\nvoid printGraph(Graph& g) {\n    rep(i, g.size()) {\n        if (!g[i].size())\n            continue;\n        rep(j, g[i].size()) \n            cout << \"(\" << i << \", \" << g[i][j].dst << \"), \";\n        cout << endl;\n    }\n}\nvoid printGraphCap(Graph& g) {\n    rep(i, g.size()) {\n        if (!g[i].size())\n            continue;\n        rep(j, g[i].size()) \n            cout << \"(\" << i << \", \" << g[i][j].dst << \" : \" << g[i][j].cap << \", \" << (g[i][j].rev_flag ? \"rev\" : \"for\") << \"), \";\n        cout << endl;\n    }\n}\n\n/***********************/\n// ??±?????¨????????????\n/***********************/\n// ???????????°???????????????\nvoid reverseGraph(Graph& g_dst, Graph& g_src) { /*g_dst??????graph?????????*/\n    g_dst = Graph(g_src.size());\n    rep(i, g_src.size()) {\n        rep(j, g_src[i].size()) {\n            addDirected(g_dst, g_src[i][j].dst, g_src[i][j].src, g_src[i][j].weight);\n        }\n    }\n}\n// ??°???????????±???????????¢?´¢??????????????¬??????\n// O(V)\n// g?????°??????, visited???g.size()?????????, s?????´????????????(?????????-1), t??????????????????????????????\nvoid dfs(Graph& g, bool* visited, ll s, ll t) {\n    visited[t] = true;\n    rep(j, g[t].size()) {\n        ll dst = g[t][j].dst;\n        if (dst == s) continue;\n        if (visited[dst]) continue;\n        dfs(g, visited, t, dst); \n    }\n}\n\n// ??¨?????±???????????¢?´¢??????????????¬??????\n// O(V)\n// g?????°??????, visited???g.size()?????????, s?????´????????????(?????????-1), t??????????????????????????????\nll dfs(Graph& g, ll s, ll t) {\n    ll ret = 0;\n    rep(j, g[t].size()) {\n        ll dst = g[t][j].dst;\n        if (dst == s) continue;\n        ret += g[t][j].weight;\n        ret += dfs(g, t, dst); \n    }\n    return ret;\n}\n\n// ????????°??????????????????\n// O(V)\n// dfs(g, visited, -1, root)??§???root???????????£??????visit?????¨???????????????????????????????????°1?????????\n// visited???g.size()?????????\nbool detectClosedCircuit(Graph& g, bool* visited, ll s, ll t) { // ????????????s(???????????°-1)->t??¨??\\?????????????????????\n    visited[t] = true;\n    bool ret = false;\n    rep(j, g[t].size()) {\n        ll dst = g[t][j].dst;\n        if (dst == s) continue;\n        if (visited[dst]) { ret = true; continue; }\n        ret |= detectClosedCircuit(g, visited, t, dst); \n    }\n    return ret;\n}\n\n// TODO ?¨???????????????£????????????\nclass FordFulkerson {\npublic:\n    Graph g; // ????????????????????????\n    int s, t; // ?§????, ??????\n    int n; // ????????°\n    ll flow = 0; // ?????§????????????????????????????????????????????????????????¨?????±?????????\n\n    // ???????????????????????????????????????\n    // O(E ret)\n    FordFulkerson(Graph& input, int s_, int t_) : s(s_), t(t_) {\n        n = input.size();\n        g.resize(n);\n        used.resize(n);\n        for (auto&& from : input) {\n            for (auto&& e_for : from) {\n                addEdge(e_for);\n            }\n        }\n\n        flow = 0;\n        revise();\n    }\n    // ??????????????????src, dst, cap????????±?????????\n    // ????????°?????????????????????????????????\n    void addEdge(Edge& e_for) {\n        Edge e_rev;\n        e_rev.src = e_for.dst; \n        e_rev.dst = e_for.src;\n        e_rev.cap = 0;\n\n        e_for.rev = g[e_rev.src].size();\n        e_rev.rev = g[e_for.src].size(); // ?????????????????????\n        e_rev.rev_flag = true;\n        g[e_for.src].push_back(e_for);\n        g[e_rev.src].push_back(e_rev);\n    }\n    // ????????°???????????????????????????????????´???????????????\n    // flow???????¨??????????\n    //\n    // O(V ret)\n    ll revise(void) {\n        while (1) {\n            ll f = update(INF);\n            if (!f) { // ????????°????????????????????????\n                break;\n            }\n            flow += f;\n        }\n        return flow;\n    }\n\n    // ???????????????\n    // ????????°????????§???v??????t????????£??????????????¢?????????????????°???????????????\n    //\n    // s??????t????§???????????????????????????????????????§?????????????????????????????????0????????????\n    // f??????????????¨??????????????????\n    //\n    // O(V)\n    vector<bool> used;\n    int dfs(int v/*from*/, int to, ll f) {\n        rep(i, n) {\n            used[i] = 0;\n        }\n        return dfs_rec(v, to, f);\n    }\n    int dfs_rec(int v/*from*/, int to, ll f) {\n        if (v == to)\n            return f;\n        used[v] = true;\n        for (int i = 0; i < g[v].size(); i++) {\n            Edge &e = g[v][i];\n            if (used[e.dst] || e.cap <= 0) \n                continue;\n            // ?????£???????????£????????£?????????????????¢??? \n            int d = dfs_rec(e.dst, to, min(f, e.cap)); // ???????????¨???????????????????????£???????????£??????????°??????????????¬???????????????¨??????\n            if (d > 0) {\n                e.cap -= d; // ????????°?????????????????´??°\n                g[e.dst][e.rev].cap += d; // ????????°????????????????????´??°\n                return d;\n            }\n        }\n        return 0;\n    }\n\n    // ????????????DFS??????????????¢??°???\n    // s, t????????????????????????????????????????????£???????????£?????????????°????\n    //\n    // O(V)\n    int update(ll f) {\n        return update(f, t);\n    }\n    int update(ll f, int to) {\n        return dfs(s, to, f);\n    }\n\n    // s??????t???????????§??????????????????\n    // s == t??????INF?????????, ???????????????0?????????\n    ll get(void) {\n        return flow;\n    }\n\n    // O(V) \n    // from??????to??????????????????cap???????????????????????????????????§???????????????\n    // ???????????????????????¨?????¨???????????£????????????????????????\n    int add(int from, int to, ll cap) {\n        bool found = false;\n        rep(i, g[from].size()) {\n            Edge& e = g[from][i];\n            if (e.rev_flag) continue;\n            if (e.dst == to) { // ?????¨?????¨?????£??????\n                e.cap += cap;\n                found = true;\n                break;\n            }\n        }\n        if (found == false) {\n            Edge e;\n            e.src = from;\n            e.dst = to;\n            e.cap = cap;\n            this->addEdge(e);\n        }\n        revise();\n        return flow;\n    }\n\n    //  ??? ??§ ??? ??? ??? ??? ??? ??? ??? ??????from->to???????????????????°????????????°???????????????????????????\n    //\n    // from??????to?????????????????????=to->from??????????????????????????£?????????=from->to??????????????¢????????¨??§????????§???????????????????????¶?????§??????????????????????????????\n    // from->to????????????????????£??????????????????????????????????????¨??§from->to????????????????°??????°???????????¨g?????????????????????\n    //\n    // from->??????->to->from??§????????????????????\\???????????°???\n    // from->to????????????????????????????????????????????????????????¨?????§?????????\n    // ?????????????????????????????????????????¨?????????????????????????????¨????????\\??????\n    //\n    // O(V ret)\n    ll minimizeFlowOfEdgePreservingMaxFlow(int from, int to) {\n        ll sum = 0;\n        rep(i, g[from].size()) {\n            Edge& e = g[from][i];\n            if (e.rev_flag) continue;\n            if (e.dst != to) continue;\n            if (g[e.dst][e.rev].cap == 0) continue;\n            // ???????????????????????????from??????to???????????????????????¨??????\n\n            Edge& e_rev = g[e.dst][e.rev];\n            // ?¶????????????????????????????????????£?????¨??¨?????????????????¨??????\n            // ??????????????????????????£???????????¨??§?????????\n            ll ret = 0;\n            while (1) { // TODO ?????????????????????????????°??????\n                // e.src?????????????????°??????????????????????????°???????????????\n                bool used[n];\n                rep(i, n) {\n                    used[i] = false;\n                }\n                function<ll(ll, ll)> dfs_lam = [&](ll v, ll c) {\n                    if (v == e.dst) {\n                        return c;\n                    }\n                    used[v] = true;\n                    for (auto&& tmp : g[v]) if (used[tmp.dst] == false && tmp.cap) {\n                        ll f = dfs_lam(tmp.dst, min(c, tmp.cap));\n                        if (f) {\n                            tmp.cap -= f;\n                            g[tmp.dst][tmp.rev].cap += f;\n                            return f;\n                        }\n                    }\n                    return 0ll;\n                };\n                ll can_erase = dfs_lam(e.src, e_rev.cap);\n                ret += can_erase;\n                sum += can_erase;\n                e_rev.cap -= can_erase;\n\n                if (can_erase == 0) { // ????????§????¶????????????????\n                    // TODO ??¬?????????????????\\???????????§?????¨??¨??????????¢??????????????????????????¬????????????§???????????????\n                    break;\n                }\n            }\n            e.cap += ret;\n        }\n        return sum;\n    }\n\n    // from??????to?????????????????????cap???????????????????????????????????§???????????????\n    // cap???0????????£?????????????????°????????????????????????????¶??????????\n    //\n    // O(V ret)\n    int erase(int from, int to, ll cap) {\n        // ???????????¨????????????????????????????¶????????????????????????£???????????????????¢????\n        ll cap_sum = 0;\n        rep(i, g[from].size()) if (g[from][i].dst == to) {\n            Edge& e = g[from][i];\n            if (e.rev_flag) continue;\n            // ?????????????????¨??????\n\n            cap_sum += e.cap + g[e.dst][e.rev].cap;\n        }\n        if (cap > cap_sum) {\n            cap = cap_sum;\n        }\n\n        // (1) ?????£????????????????????£???????°????????????????\n        rep(i, g[from].size()) {\n            Edge& e = g[from][i];\n            if (e.rev_flag) continue;\n            if (e.dst != to) continue;\n            if (g[e.dst][e.rev].cap != 0) continue;\n            // ??????????????????????????????from??????to??????????????????????????¨??????\n\n            ll to_erase = min(e.cap, cap);\n            e.cap -= to_erase;\n            cap -= to_erase;\n        }\n        if (cap == 0) { // ???????¶??????????????????????????????????\n            return flow;\n        }\n\n        // (2) ?????£????????????????????????????????????????????????????????????????????????????????§?????????????????????\n        minimizeFlowOfEdgePreservingMaxFlow(from, to); // ????????§from->to???????????????cap???????????????\n        // ??????????????????????¶????\n        rep(i, g[from].size()) {\n            Edge& e = g[from][i];\n            if (e.rev_flag) continue;\n            if (e.dst != to) continue;\n            ll m = min(cap, e.cap);\n            cap -= m;\n            e.cap -= m;\n        }\n        if (cap == 0) { // ???????¶??????????????????????????????????\n            return flow;\n        }\n \n        // (2) ?????????????????????????????????????????§????????????????????¶?????????????????????????????????????????§?????????????????????\n        //\n        // ????????°????????§???t->s???????¢???§??????cap???????????????????????????????????????flow???????°??????????\n        // ????°????????????????????????????????????????????????????????????¨???????????§??????????????¨???????????????????????????\n        ll sum = 0;\n        while (1) {\n            ll f = dfs(t, s, cap);\n            if (!f) break;\n            flow -= f;\n            cap -= f;\n            sum += f;\n        }\n        assert(cap == 0);\n        minimizeFlowOfEdgePreservingMaxFlow(from, to); // ????????§from->to???????????????????????????cap???????????????\n\n        // ??????????????????????¶????\n        rep(i, g[from].size()) {\n            Edge& e = g[from][i];\n            if (e.rev_flag) continue;\n            if (e.dst != to) continue;\n            ll m = min(sum, e.cap);\n            sum -= m;\n            e.cap -= m;\n        }\n        return flow;\n    }\n\n    // from??????to??????????????¨?????? \n    //\n    // O(V ret)\n    int erase(int from, int to) {\n        return erase(from, to, INF);\n    }\n};\n\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    ll n, m, s, t;\n    while (cin >> n >> m >> s >> t && n) { s--; t--;\n        Graph g = Graph(n);\n        vector<int> us, vs;\n        rep(i, m) {\n            ll u, v; cin >> u >> v; u--, v--;\n            us.pb(u), vs.pb(v);\n            addDirected(g, u, v, 0, 1);\n        }\n        FordFulkerson ff(g, s, t);\n        ll initial = ff.get();\n        ll ret = 0;\n        rep(i, m) {\n            ll u = us[i], v = vs[i];\n            ff.erase(u, v);\n            ff.add(v, u, 1);\n            if (initial < ff.get()) ret++;\n            ff.erase(v, u);\n            ff.add(u, v, 1);\n        }\n        cout << initial + !!ret << \" \" << ret << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\n#define MAX_V 1001\nusing namespace std;\ntypedef map<int,int> M;\nM G[MAX_V],rG[MAX_V],g[MAX_V];\nbool used[MAX_V];  \n\nint dfs(int v,int t,int f){\n  if(v == t)return f;\n  used[v]=true;\n  \n  for(M::iterator it=G[v].begin();it!=G[v].end() ;it++){\n    int to=it->first;\n    int &cap=it->second;\n    if(!used[to] && cap > 0){\n      int d = dfs(to ,t , min(f,cap));\n      if(d > 0){\n\tcap -= d;\n\tG[to][v]+=d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s, t, INF);\n    if(f == 0)return flow;\n    flow += f;\n  }\n}\n\nint visited[MAX_V];\nvoid visit(int pos){\n  if(visited[pos])return;\n  visited[pos]=1;\n  for(M::iterator it=rG[pos].begin();it!=rG[pos].end() ;it++){\n    int to=it->first,cap=it->second;\n    if(cap)visit(to);\n  }\n}\n\nint check2(int pos){\n  if(used[pos]++) return 0;\n  int res=0; \n  for(M::iterator it=G[pos].begin();it!=G[pos].end() ;it++){\n    int to=it->first,cap=it->second;\n    if(cap)res+=check2(to);\n  }\n  \n  for(M::iterator it=g[pos].begin();it!=g[pos].end() ;it++){\n    int to=it->first,cap=it->second;\n    if(cap)res+=cap*visited[to];\n  }\n  return res;\n}\n\nint main(){\n  while(1){\n    int n,m,s,t;\n    cin>>n>>m>>s>>t;\n    if(!n&&!m&&!s&&!t)break;\n    s--,t--;\n    for(int i=0;i<MAX_V;i++) rG[i].clear(),G[i].clear(),g[i].clear();\n    \n    for(int i=0,a,b;i<m;i++){\n      cin>>a>>b;\n      a--,b--;\n      G[a][b]++;\n      g[b][a]++;\n    }\n\n    int mx=max_flow(s,t);\n    for(int i=0;i<n;i++)\n      for(M::iterator it=G[i].begin();it!=G[i].end() ;it++){\n\tint to=it->first,cap=it->second;\n\trG[to][i]=cap;\n      }\n    \n    memset(visited,0,sizeof(visited));\n    memset(used,0,sizeof(used));\n    visit(t);\n    int cnt=check2(s);\n    cout<<mx+(cnt>0)<<\" \"<<cnt<<endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\n#define MAX_V 10000\nusing namespace std;\n\n/*?????§?????¢?????´?????????(Ford_Fulerson????????¨)???O(F|E|)*/\n\n//????????¨????§???????(???????????????????????????)\nstruct edge{int to, cap, rev, s;};\n\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size(),0});\n  G[to].push_back((edge){from,0,(int)G[from].size()-1,1});  \n}\n\n//?¢?????????????DFS??§??¢???\nint dfs(int v,int t,int f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs(e.to ,t , min(f,e.cap));\n      if(d > 0){\n\te.cap -= d;\n\tG[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\n//s??????t???????????§???????±???????\nint max_flow(int s,int t,int maxf){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s, t, maxf);\n    if(f == 0)return flow;\n    maxf-=f;\n    flow += f;\n  }\n}\n\nint n, m, s, t;\n\nvoid solve(){\n  \n  int r = max_flow(s, t, INF);\n  int maxflow=r, cnt=0;\n    \n  for(int i=1;i<=n;i++){\n    \n    for(int j=0;j<G[i].size();j++){\n      \n      edge &s1 = G[i][j];\n      edge &t1 = G[s1.to][s1.rev];\n      \n      if(s1.s) continue;\n      if(t1.cap==1) continue;\n      \n      int f1=max_flow(s,s1.to,1);\n      \n      int f2=max_flow(i,t,1);\n      \n      if(f1&&f2){\n\tmaxflow=r+1;\n\tcnt++;\n      }\n      \n      if(f1) max_flow(s1.to,s,1);\n      \n      if(f2) max_flow(t,i,1);\n      \n    }\n    \n  }\n\n  int revcnt=0;\n\n  if(r<maxflow) revcnt=cnt;\n  \n  cout<<maxflow<<' '<<revcnt<<endl;\n  \n}\n\nvoid init(){\n  for(int i=0;i<MAX_V;i++) G[i].clear();\n}\n\nint main(){\n\n  while(1){\n    \n    cin>>n>>m>>s>>t;\n    if(!n&&!m&&!s&&!t) break;\n\n    init();\n    \n    for(int i=0;i<m;i++){\n      int a, b;\n      cin>>a>>b;\n      add_edge(a,b,1);\n    }\n  \n    solve();\n  }\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\n#include <map>\n#include <unordered_set>\nusing namespace std;\n\nusing Weight = int;\nusing Capacity = int;\nstruct Edge {\n\tint src, dst; Weight weight; Capacity cap;\n\tEdge(int s, int d, Weight w, Capacity c) : src(s), dst(d), weight(w), cap(c) {}\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\nstruct Dinic {\n\tint n, s, t;\n\tvector<int> level, prog, que;\n\tvector<vector<Capacity>> cap, flow;\n\tvector<vector<int>> g;\n\tCapacity inf;\n\tDinic(const Graph &graph)\n\t\t: n(graph.size()),\n\t\tcap(n, vector<Capacity>(n)), flow(n, vector<Capacity>(n)),\n\t\tg(n, vector<int>()), inf(numeric_limits<Capacity>::max() / 8) {\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tfor(auto &e : graph[i]) {\n\t\t\t\tint u = e.src, v = e.dst;\n\t\t\t\tCapacity c = e.cap;\n\t\t\t\tcap[u][v] += c; cap[v][u] += c; flow[v][u] += c;\n\t\t\t\tg[u].push_back(v); g[v].push_back(u);\n\t\t\t}\n\t\t}\n\t}\n\tinline Capacity residue(int u, int v) { return cap[u][v] - flow[u][v]; }\n\tCapacity solve(int s_, int t_) {\n\t\tthis->t = t_, this->s = s_;\n\t\tque.resize(n + 1);\n\t\tCapacity res = 0;\n\t\twhile(levelize()) { prog.assign(n, 0); res += augment(s, inf); }\n\t\treturn res;\n\t}\n\tbool levelize() {\n\t\tint l = 0, r = 0;\n\t\tlevel.assign(n, -1); level[s] = 0; que[r++] = s;\n\t\twhile(l != r) {\n\t\t\tint v = que[l++]; if(v == t) break;\n\t\t\tfor(const int &d : g[v]) if(level[d] == -1 && residue(v, d) != 0) {\n\t\t\t\tlevel[d] = level[v] + 1; que[r++] = d;\n\t\t\t}\n\t\t}\n\t\treturn level[t] != -1;\n\t}\n\tCapacity augment(int v, Capacity lim) {\n\t\tCapacity res = 0;\n\t\tif(v == t) return lim;\n\t\tfor(int &i = prog[v]; i < (int)g[v].size(); i++) {\n\t\t\tconst int &d = g[v][i];\n\t\t\tif(residue(v, d) == 0 || level[v] >= level[d]) continue;\n\t\t\tconst Capacity aug = augment(d, min(lim, residue(v, d)));\n\t\t\tflow[v][d] += aug; flow[d][v] -= aug;\n\t\t\tres += aug; lim -= aug;\n\t\t\tif(lim == 0) break;\n\t\t}\n\t\treturn res;\n\t}\n};\n\ntypedef pair<int, int> Pii;\n\nvector<int> RG[2][1010];\nunordered_set<int> visit[2];\n\nint a[10010];\nint b[10010];\nbool used[1010];\n\nvoid dfs(int v, int gi) {\n\tused[v] = true;\n\tvisit[gi].insert(v);\n\tfor(int c : RG[gi][v]) {\n\t\tif(!used[c]) dfs(c, gi);\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, M, S, T;\n\twhile(cin >> N >> M >> S >> T, N) {\n\t\tS--, T--;\n\t\tGraph G(N);\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tcin >> a[i] >> b[i];\n\t\t\ta[i]--, b[i]--;\n\t\t\tG[a[i]].push_back(Edge(a[i], b[i], 1, 1));\n\t\t}\n\n\t\tDinic dinic(G);\n\t\tint flow = dinic.solve(S, T);\n\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tRG[0][i].clear();\n\t\t\tRG[1][i].clear();\n\t\t}\n\t\tvisit[0].clear();\n\t\tvisit[1].clear();\n\n\t\tfor(int u = 0; u < N; u++) {\n\t\t\tfor(int v : dinic.g[u]) {\n\t\t\t\tif(dinic.residue(u, v) != 0) {\n\t\t\t\t\tRG[0][u].push_back(v);\n\t\t\t\t\tRG[1][v].push_back(u);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmemset(used, 0, sizeof used);\n\t\tdfs(S, 0);\n\t\tmemset(used, 0, sizeof used);\n\t\tdfs(T, 1);\n\n\t\tint num = 0;\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tif(visit[0].find(b[i]) != visit[0].end() && visit[1].find(a[i]) != visit[1].end()) {\n\t\t\t\tnum++;\n\t\t\t}\n\t\t}\n\n\t\tcout << flow + (num > 0) << \" \" << num << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\ntypedef pair<int, int> Pi;\ntypedef tuple<int, int, int> Ti;\ntypedef vector<int> vint;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nstruct edge {\n  int to, cap, rev;\n  edge(){}\n  edge(int to, int cap, int rev)\n    :to(to), cap(cap), rev(rev){}\n};\n\nstruct Dinic {\n  vector< vector<edge> > graph;\n  vector<int> iter, level;\n  Dinic(){}\n  Dinic(int V):graph(V), iter(V), level(V){}\n  void add_edge(int from, int to, int cap) {\n    graph[from].emplace_back(to, cap, graph[to].size());\n    graph[to].emplace_back(from, 0, graph[from].size()-1);\n  }\n  bool bfs(int s, int t) {\n    fill(all(level), -1);\n    queue<int> que;\n    que.push(s);\n    level[s] = 0;\n    while(!que.empty()) {\n      int v = que.front(); que.pop();\n      for(edge &e : graph[v]) {\n\tif(e.cap > 0 && level[e.to] < 0) {\n\t  level[e.to] = level[v]+1;\n\t  que.push(e.to);\n\t}\n      }\n    }\n    return level[t] >= 0;\n  }\n  int dfs(int v, int t, int f) {\n    if(v == t) return f;\n    for(int &i = iter[v]; i < (int)graph[v].size(); i++) {\n      edge &e = graph[v][i];\n      if(e.cap > 0 && level[e.to] > level[v]) {\n\tint d = dfs(e.to, t, min(f, e.cap));\n\tif(d > 0) {\n\t  e.cap -= d;\n\t  graph[e.to][e.rev].cap += d;\n\t  return d;\n\t}\n      }\n    }\n    return 0;\n  }\n  int max_flow(int s, int t) {\n    int flow = 0;\n    while(bfs(s, t)) {\n      fill(all(iter), 0);\n      int f; while((f = dfs(s, t, inf)) > 0) flow += f;\n    }\n    return flow;\n  }\n};\n\nvoid bfs(vector< vector<int> >& G, vector<int>& vis, int s) {\n  queue<int> que;\n  que.push(s);\n  vis[s] = 0;\n  while(!que.empty()) {\n    int v = que.front(); que.pop();\n    for(int to : G[v]) {\n      if(vis[to] < 0) {\n\tvis[to] = vis[v] + 1;\n\tque.push(to);\n      }\n    }\n  }\n}\n\nint N, M, S, T;\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(cin >> N >> M >> S >> T, N || M || S || T) {\n    --S, --T;\n    vector<Pi> vec;\n    Dinic graph(N);\n    rep(i, M) {\n      int a, b;\n      cin >> a >> b;\n      --a, --b;\n      vec.emplace_back(a, b);\n      graph.add_edge(a, b, 1);\n    }\n    int flow = graph.max_flow(S, T);\n    vector<int> visS(N, -1);\n    vector<int> visT(N, -1);\n    auto& rgraph = graph.graph;\n    {\n      vector< vector<int> > G(N);\n      rep(i, N) {\n\tfor(edge& e : rgraph[i]) {\n\t  if(e.cap > 0) G[i].push_back(e.to);\n\t}\n      }\n      bfs(G, visS, S);\n    }\n    {\n      vector< vector<int> > G(N);\n      rep(i, N) {\n\tfor(edge& e : rgraph[i]) {\n\t  if(e.cap > 0) G[e.to].push_back(i);\n\t}\n      }\n      bfs(G, visT, T);\n    }\n    int cnt = 0;\n    for(Pi p : vec) {\n      if(visS[p.second] >= 0 && visT[p.first] >= 0) cnt++;\n    }\n    cout << flow+(cnt>0) << \" \" << cnt << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MAXM = 200000 + 10, MAXN = 1000 + 10, inf = 1e9;\nnamespace NF {\n  struct Edge {\n    int v, c, f, nx;\n    Edge() {}\n    Edge(int v, int c, int f, int nx):\n      v(v), c(c), f(f), nx(nx) {}\n  } E[MAXM];\n  int G[MAXN], lev[MAXN], cur[MAXN];\n  int sz, N;\n  void init(int n) {\n    N = n; sz = 0;\n    memset(G, -1, sizeof(G));\n  }\n  void link(int u, int v, int c) {\n    E[sz] = Edge(v, c, 0, G[u]); G[u] = sz ++;\n    E[sz] = Edge(u, 0, 0, G[v]); G[v] = sz ++;\n  }\n  bool bfs(int S, int T) {\n    static int Q[MAXN];\n    for (int i = 0; i < N; ++ i) lev[i] = -1;\n    Q[0] = S; lev[S] = 0;\n    for (int h = 0, t = 1; h < t; ++ h) {\n      int u = Q[h], v;\n      for (int now = G[u]; ~now; now = E[now].nx) {\n        if (lev[v = E[now].v] == -1 && E[now].c > E[now].f) {\n          lev[v] = lev[u] + 1; Q[t ++] = v;\n        }\n      }\n    }\n    return lev[T] != -1;\n  }\n  int dfs(int u, int T, int low) {\n    if (u == T) return low;\n    int ret = 0, tmp, v;\n    for (int &now = cur[u]; ~now && ret < low; now = E[now].nx) {\n      if (lev[v = E[now].v] == lev[u] + 1 && E[now].c > E[now].f) {\n        tmp = dfs(v, T, min(low - ret, E[now].c - E[now].f));\n        ret += tmp; E[now].f += tmp; E[now ^ 1].f -= tmp;\n      }\n    }\n    if (!ret) lev[u] = -1; return ret;\n  }\n  int dinic(int S, int T) {\n    int ret = 0;\n    while (bfs(S, T)) {\n      memcpy(cur, G, sizeof(G[0]) * N);\n      ret += dfs(S, T, inf);\n    }\n    return ret;\n  }\n  static bool mark[MAXN];\n  int solve(int S, int T) {\n    bfs(S, T); int ret = 0;\n    memset(mark, 0, sizeof(mark));\n    queue<int> Q; Q.push(T); mark[T] = true;\n    while (!Q.empty()) {\n      int u = Q.front(); Q.pop();\n      for (int now = G[u]; ~now; now = E[now].nx) {\n        int v = E[now].v;\n        if (E[now ^ 1].c > E[now ^ 1].f) {\n          if (!mark[v]) mark[v] = true, Q.push(v);\n        }\n        else ret += (lev[v] != -1 && E[now].c > 0);\n      }\n    }\n    return ret;\n  }\n}\n\nint main() {\n  int n, m, s, t; \n  while (scanf(\"%d%d%d%d\", &n, &m, &s, &t) == 4 && n) {\n    NF::init(n); -- s; -- t;\n    for (int i = 0, u, v; i < m; ++ i) {\n      scanf(\"%d%d\", &u, &v); -- u, -- v;\n      NF::link(u, v, 1);\n    }\n    int maxflow = NF::dinic(s, t);\n    int ret = NF::solve(s, t);\n    if (ret != 0) maxflow ++;\n    printf(\"%d %d\\n\", maxflow, ret);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\n#define MAX_V 10000\nusing namespace std;\n\n/*?????§?????¢?????´?????????(Ford_Fulerson????????¨)???O(F|E|)*/\n\n//????????¨????§???????(???????????????????????????)\nstruct edge{int to, cap, rev, s;};\n\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size(),0});\n  G[to].push_back((edge){from,0,(int)G[from].size()-1,1});  \n}\n\n//?¢?????????????DFS??§??¢???\nint dfs(int v,int t,int f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs(e.to ,t , min(f,e.cap));\n      if(d > 0){\n\te.cap -= d;\n\tG[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\n//s??????t???????????§???????±???????\nint max_flow(int s,int t,int maxf){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s, t, maxf);\n    if(maxf==0||f == 0)return flow;\n    maxf-=f;\n    flow += f;\n  }\n}\n\nint n, m, s, t;\n\nvoid solve(){\n  \n  int r = max_flow(s, t, INF);\n  int maxflow=r, cnt=0;\n    \n  for(int i=1;i<=n;i++){\n    \n    for(int j=0;j<G[i].size();j++){\n      \n      edge &s1 = G[i][j];\n      edge &t1 = G[s1.to][s1.rev];\n      \n      if(s1.s) continue;\n      if(t1.cap==1) continue;\n      \n      int f1=max_flow(s,s1.to,1);\n      \n      int f2=max_flow(i,t,1);\n      \n      if(f1&&f2){\n\tmaxflow=r+1;\n\tcnt++;\n      }\n      \n      if(f1) max_flow(s1.to,s,1);\n      \n      if(f2) max_flow(t,i,1);\n      \n    }\n    \n  }\n\n  int revcnt=0;\n\n  if(r<maxflow) revcnt=cnt;\n  \n  cout<<maxflow<<' '<<revcnt<<endl;\n  \n}\n\nvoid init(){\n  for(int i=0;i<MAX_V;i++) G[i].clear();\n}\n\nint main(){\n\n  while(1){\n    \n    cin>>n>>m>>s>>t;\n    if(!n&&!m&&!s&&!t) break;\n\n    init();\n    \n    for(int i=0;i<m;i++){\n      int a, b;\n      cin>>a>>b;\n      add_edge(a,b,1);\n    }\n  \n    solve();\n  }\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 1005\n\nenum Type{\n\tFROM_S,\n\tFROM_T,\n};\n\n\n//辺を表す構造体(行先、容量、逆辺のインデックス)\nstruct Edge{\n\tEdge(int arg_to,int arg_capacity,int arg_rev_index,bool arg_is_rev){\n\t\tto = arg_to;\n\t\tcapacity = arg_capacity;\n\t\trev_index = arg_rev_index;\n\t\tis_rev = arg_is_rev;\n\t}\n\tint to,capacity,rev_index;\n\tbool is_rev;\n};\n\nint V,E;\nint N,M,S,T;\n\nvector<Edge> G[NUM]; //グラフの隣接リスト表現\nbool used[NUM]; //DFSですでに調べたかのフラグ\nbool can_reach[2][NUM]; //S,Tから各点へ到達できるかのチェック\n\n//fromからtoへ向かう容量capacityの辺をグラフに追加する\nvoid add_edge(int from,int to,int capacity){\n\tG[from].push_back(Edge(to,capacity,G[to].size(),false));\n\tG[to].push_back(Edge(from,0,G[from].size()-1,true)); //逆辺の、初期容量は0\n}\n\n//増加パスをDFSで探す\nint dfs(int node_id,int sink,int flow){\n\tif(node_id == sink)return flow; //終点についたらflowをreturn\n\tused[node_id] = true;\n\n\tfor(int i = 0; i < G[node_id].size(); i++){ //node_idから出ているエッジを調査\n\t\tEdge &e = G[node_id][i];\n\t\tif(used[e.to] == false && e.capacity > 0){ //エッジの先のノードに未訪問で、かつエッジに流す余裕がある場合\n\t\t\tint tmp_flow = dfs(e.to,sink,min(flow,e.capacity)); //流せるだけ流す\n\t\t\tif(tmp_flow > 0){ //流せた場合\n\t\t\t\te.capacity -= tmp_flow; //流した分、エッジの容量を削減する\n\t\t\t\tG[e.to][e.rev_index].capacity += tmp_flow; //逆辺の容量を、流した分だけ増加させる\n\t\t\t\treturn tmp_flow;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n//あらかじめ、S,Tから行けないノードを特定しておく\nvoid reach_check(Type type,int node_id){\n\n\tcan_reach[type][node_id] = true;\n\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\tif(G[node_id][i].capacity == 1 && can_reach[type][G[node_id][i].to] == false){\n\t\t\treach_check(type,G[node_id][i].to);\n\t\t}\n\t}\n}\n\n\n//sourceからsinkへの最大流を求める\nint max_flow(int source,int sink){ //source:始点 sink:終点\n\tint flow = 0,add;\n\twhile(true){ //増加パスが存在する限り、流量を追加し続ける\n\t\tfor(int i = 0; i < V; i++)used[i] = false;\n\t\tadd = dfs(source,sink,BIG_NUM);\n\t\tif(add == 0)break;\n\t\tflow += add;\n\t}\n\treturn flow;\n}\n\nvoid func(){\n\n\tfor(int i = 0; i < N; i++){\n\t\tG[i].clear();\n\t\tcan_reach[FROM_S][i] = false;\n\t\tcan_reach[FROM_T][i] = false;\n\t}\n\n\tS--;\n\tT--;\n\n\tint from,to;\n\tfor(int loop = 0; loop < M; loop++){\n\t\tscanf(\"%d %d\",&from,&to);\n\t\tfrom--;\n\t\tto--;\n\t\tadd_edge(from,to,1);\n\t}\n\n\tV = N;\n\n\tint FLOW = max_flow(S,T);\n\tint MAX_FLOW = FLOW;\n\n\treach_check(FROM_S,S);\n\treach_check(FROM_T,T);\n\n\tint num_edge = 0,diff;\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < G[i].size(); k++){\n\t\t\tif(G[i][k].is_rev == true || G[i][k].capacity == 0 ||\n\t\t\t\t\tcan_reach[FROM_S][G[i][k].to] == false || can_reach[FROM_T][i] == false)continue; //逆辺または、最大流達成のために使用した辺はSKIP\n\n\t\t\t//★★経路に重なりがあるかも知れないので、仮にcan_reachが両方trueでも、流量が1増えるとは限らない★★\n\n\t\t\t//最大流達成の際に使用していない辺のみ、向きを逆転させれば、総経路が1増える可能性がある\n\n\t\t\t//辺の向きを逆転させる\n\t\t\tG[i][k].capacity = 0;\n\t\t\tG[G[i][k].to][G[i][k].rev_index].capacity = 1;\n\n\t\t\t//S→T方向に流す\n\t\t\tdiff = max_flow(S,T);\n\n\t\t\tif(diff == 1){ //流量が増加した場合\n\t\t\t\tnum_edge++;\n\t\t\t\tMAX_FLOW = FLOW+1;\n\n\t\t\t\tif(i != T){\n\t\t\t\t\tmax_flow(T,i); //T→iに押し戻す\n\t\t\t\t}\n\t\t\t\tif(G[i][k].to != S){\n\t\t\t\t\tmax_flow(G[i][k].to,S); //G[i][k].to→Sに押し戻す\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//辺の向きを元に戻す\n\t\t\tG[i][k].capacity = 1;\n\t\t\tG[G[i][k].to][G[i][k].rev_index].capacity = 0;\n\t\t}\n\t}\n\n\tprintf(\"%d %d\\n\",MAX_FLOW,num_edge);\n}\n\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d %d %d\",&N,&M,&S,&T);\n\t\tif(N == 0 && M == 0 && S == 0 && T == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;++i)\nusing namespace std;\n\nconst int inf=1<<20;\nconst int vmax=1010;\nstruct edge{int to,cap,rev;};\nvector<edge> graph[vmax];\n\nvoid add_edge(int f,int t){\n\tgraph[f].push_back({t,1,(int)graph[t].size()});\n\tgraph[t].push_back({f,0,(int)graph[f].size()-1});\n}\n\nbool visited[vmax];\nint dfs(int v,int t,int f){\n\tif(v==t) return f;\n\tvisited[v]=true;\n\n\tfor(auto &e:graph[v]){\n\t\tif(visited[e.to]) continue;\n\t\tif(e.cap==0) continue;\n\t\tint d=dfs(e.to,t,min(f,e.cap));\n\t\tif(d>0){\n\t\t\te.cap-=d;\n\t\t\tgraph[e.to][e.rev].cap+=d;\n\t\t\treturn d;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s,int t){\n\tint ret=0;\n\twhile(1){\n\t\tmemset(visited,0,sizeof(visited));\n\t\tint f=dfs(s,t,inf);\n\t\tif(f==0) break;\n\t\tret+=f;\n\t}\n\treturn ret;\n}\n\nbool sreach[vmax],treach[vmax];\nvoid bfs(int s,bool reach[vmax],int can){\n\n\n\tqueue<int> q;\n\treach[s]=true;\n\tq.push(s);\n\n\twhile(!q.empty()){\n\t\tint cur=q.front();q.pop();\n\t\tfor(auto &e:graph[cur]){\n\t\t\tif(e.cap==(can^1)) continue;\n\t\t\tif(reach[e.to]==false){\n\t\t\t\treach[e.to]=true;\n\t\t\t\tq.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn;\n}\n\nint a[10010],b[10010];\n\nint main(void){\n\tint n,m,s,t;\n\twhile(cin >> n >> m >> s >> t,n){\n\t\trep(i,vmax) graph[i].clear();\n\n\t\ts--,t--;\n\t\trep(i,m){\n\t\t\tcin >> a[i] >> b[i];\n\t\t\ta[i]--,b[i]--;\n\t\t\tadd_edge(a[i],b[i]);\n\t\t}\n\n\t\tint ans=max_flow(s,t);\n\t\tmemset(sreach,false,sizeof(sreach));\n\t\tmemset(treach,false,sizeof(treach));\n\t\tbfs(s,sreach,1),bfs(t,treach,0);\n\n\t\tint num=0;\n\t\trep(i,m){\n\t\t\tbool ok=false,ok2=false;\n\t\t\tfor(auto &e:graph[a[i]]) if(e.to==b[i]&&e.cap==1) ok=true;\n\t\t\tif((sreach[a[i]]&&treach[b[i]])||(sreach[b[i]]&&treach[a[i]]))\n\t\t\t\tok2=true;\n\t\t\tif(ok&&ok2) num++;\n\t\t}\n\n\t\tif(num) ans++;\n\t\tcout << ans << \" \" << num << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 1005\n#define INF (1<<26)\n\nint N,M,S,T;\nint G[MAX_N][MAX_N];\nint g[MAX_N][MAX_N];\nint base;\nint visited[MAX_N];\n\nint AS[MAX_N],AT[MAX_N];\n\nbool check(int a,int b){\n  if(AT[a]&&AS[b])return true;\n  else return false;\n}\n\nvoid dfsS(int pos){\n  AS[pos]=true;\n  for(int i=0;i<N;i++){\n    if(G[pos][i]==0)continue;\n    if(AS[i])continue;\n    dfsS(i);\n  }\n}\n\nvoid dfsT(int pos){\n  AT[pos]=true;\n  for(int i=0;i<N;i++){\n    if(G[i][pos]==0)continue;\n    if(AT[i])continue;\n    dfsT(i);\n  }\n}\n\nvoid solve(){\n\n  /*\n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      cout<<G[i][j]<<' ';\n    }\n    cout<<endl;\n  }\n  */\n\n  for(int i=0;i<N;i++)\n    AS[i]=AT[i]=false;\n  \n  dfsS(S);\n  dfsT(T);\n\n  /*\n  for(int i=0;i<N;i++){\n    cout<<AS[i]<<' ';\n  }\n  cout<<endl;\n\n  for(int i=0;i<N;i++){\n    cout<<AT[i]<<' ';\n  }\n  cout<<endl;\n  */\n\n  int cnt=0;\n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      if(i==j)continue;\n      if(G[i][j]>0&&g[i][j]>0){\n        //cout<<\"# \"<<i<<' '<<j<<endl;\n        if(check(i,j))cnt++;\n      }\n    }\n  }\n\n  if(base==0&&cnt==0)cout<<\"0 0\"<<endl;\n  else if(cnt==0)cout<<base<<\" 0\"<<endl;\n  else cout<<base+1<<\" \"<<cnt<<endl;\n}\n\nint dfs(int pos,int f){\n  if(pos==T)return f;\n  visited[pos]=true;\n  for(int i=0;i<N;i++){\n    if(visited[i])continue;\n    if(G[pos][i]==0)continue;\n    int d=dfs(i,min(f,G[pos][i]));\n    if(d>0){\n      G[pos][i]-=d;\n      G[i][pos]+=d;\n      return d;\n    }\n  }\n  return 0;\n}\n\nvoid calc(){\n  base=0;\n  while(1){\n    for(int i=0;i<N;i++)visited[i]=false;\n    int f=dfs(S,INF);\n    if(f==0)break;\n    base+=f;\n  }\n}\n\nvoid init(){\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      G[i][j]=0;\n}\n\nint main(){\n  int a,b;\n  while(1){\n    scanf(\"%d %d %d %d\",&N,&M,&S,&T);\n    if(N==0&&M==0&&S==0&&T==0)break;\n    S--,T--;\n    init();\n    for(int i=0;i<M;i++){\n      scanf(\"%d %d\",&a,&b);\n      a--,b--;\n      G[a][b]++;\n    }\n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++)\n        g[i][j]=G[i][j];\n    calc();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nstruct edge{\n\tint to;\n\tint cap;\n\tint rev;\n};\n\nstruct flow{\n\tvector<edge> G[1002];\n\tbool used[1002];\n\tvoid add_edge(int from,int to,int cap){\n\t\tedge a = {to,cap,G[to].size()};\n\t\tedge b = {from,0,G[from].size()};\n\t\tG[from].push_back(a);\n\t\tG[to].push_back(b);\n\t}\n\tint dfs(int v,int t,int f){\n\t\tif(v == t)return f;\n\t\tused[v] = true;\n\t\tfor(int i = 0 ; i < G[v].size() ; i ++){\n\t\t\tedge &e = G[v][i];\n\t\t\tif(!used[e.to] && e.cap > 0){\n\t\t\t\tint d = dfs(e.to,t,min(f,e.cap));\n\t\t\t\tif(d > 0){\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s,int t){\n\t\tint flow = 0;\n\t\twhile(1){\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tint f = dfs(s,t,INF);\n\t\t\tif(f == 0)return flow;\n\t\t\tflow += f;\n\t\t}\n\t}\n\tvoid init(){\n\t\trep(i,1002)G[i].clear();\n\t}\n}F;\n\nint flag[1002];\nvoid dfs(int v){\n\tif(flag[v] == 1)return;\n\tflag[v] = 1;\n\trep(i,F.G[v].size()){\n\t\tedge ed = F.G[v][i];\n\t\tif(ed.cap > 0)dfs(ed.to);\n\t}\n}\nvoid dfs_rev(int v){\n\tif(flag[v] == -1)return;\n\tflag[v] = -1;\n\trep(i,F.G[v].size()){\n\t\tedge ed = F.G[v][i];\n\t\tif(ed.cap == 0)dfs_rev(ed.to);\n\t}\n}\n\nint main(){\n\twhile(1){\n\t\tint n,m,s,t;\n\t\tcin >> n >> m >> s >> t;\n\t\tif(n == 0)return 0;\n\t\tint a[10002],b[10002];\n\t\trep(i,m){\n\t\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t\t}\n\t\t\n\t\tF.init();\n\t\trep(i,m){\n\t\t\tF.add_edge(a[i],b[i],1);\n\t\t}\n\t\tint ret = F.max_flow(s,t);\n\t\trep1(i,n)flag[i] = 0;\n\t\tdfs(s);\n\t\tdfs_rev(t);\n\t\tint cnt = 0;\n\t\trep(i,m){\n\t\t\tif(flag[a[i]] == -1 && flag[b[i]] == 1)cnt ++;\n\t\t}\n\t\tprintf(\"%d %d\\n\",ret+(cnt==0?0:1),cnt);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\n#define MAX_V 10000\nusing namespace std;\n\n/*?????§?????¢?????´?????????(Ford_Fulerson????????¨)???O(F|E|)*/\n\n//????????¨????§???????(???????????????????????????)\nstruct edge{int to, cap, rev, s;};\n\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size(),0});\n  G[to].push_back((edge){from,0,(int)G[from].size()-1,1});  \n}\n\n//?¢?????????????DFS??§??¢???\nint dfs(int v,int t,int f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs(e.to ,t , min(f,e.cap));\n      if(d > 0){\n\te.cap -= d;\n\tG[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\n//s??????t???????????§???????±???????\nint max_flow(int s,int t,int maxf){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s, t, maxf);\n    if(maxf==0||f == 0)return flow;\n    maxf-=f;\n    flow += f;\n  }\n}\n\nint n, m, s, t;\n\nvoid solve(){\n  \n  int r = max_flow(s, t, INF);\n  int maxflow=r, cnt=0;\n    \n  for(int i=1;i<=n;i++){\n    \n    for(int j=0;j<G[i].size();j++){\n      \n      edge &s1 = G[i][j];\n      edge &t1 = G[s1.to][s1.rev];\n      \n      if(s1.s) continue;\n      if(t1.cap==1) continue;\n      \n      s1.cap=0;\n      \n      int f1=max_flow(s,s1.to,1);\n      \n      int f2=max_flow(i,t,1);\n      \n      if(f1&&f2){\n\tmaxflow=r+1;\n\tcnt++;\n      }\n      \n      if(f1) max_flow(s1.to,s,1);\n      \n      if(f2) max_flow(t,i,1);\n      \n      s1.cap=1;\n    }\n    \n  }\n\n  int revcnt=0;\n\n  if(r<maxflow) revcnt=cnt;\n  \n  cout<<maxflow<<' '<<revcnt<<endl;\n  \n}\n\nvoid init(){\n  for(int i=0;i<MAX_V;i++) G[i].clear();\n}\n\nint main(){\n\n  while(1){\n    \n    cin>>n>>m>>s>>t;\n    if(!n&&!m&&!s&&!t) break;\n\n    init();\n    \n    for(int i=0;i<m;i++){\n      int a, b;\n      scanf(\"%d %d\", &a, &b);\n      add_edge(a,b,1);\n    }\n  \n    solve();\n  }\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<tuple>\n\nusing namespace std;\n\nstruct edge{int to,cap,rev;};\n\nvector<edge>G[1234];\nbool used[1234];\n\nvector<tuple<int,int,int,int> > edges;\n\nint dfs(int v,int t,int f){\n  if(v==t)return f;\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    edge &e=G[v][i];\n    if(!used[e.to]&&e.cap>0){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n\te.cap-=d;\n\tG[e.to][e.rev].cap+=d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t,int mf=1e9){\n  if(s==t)return 0;\n  int flow=0;\n  for(;;){\n    fill(begin(used),end(used),false);\n    int f=dfs(s,t,mf);\n    if(f==0)return flow;\n    flow+=f;\n    if(flow==mf)return flow;\n  }\n} \n\nvoid add_edge(int from,int to,int cap=1){\n  edges.emplace_back(from,(int)G[from].size(),to,(int)G[to].size());\n  G[from].push_back({to,cap,(int)G[to].size()});\n  G[to].push_back({from,0,(int)G[from].size()-1});\n}\n\nint main(){\n  for(int N,M,S,T;cin>>N>>M>>S>>T,N|M|S|T;){\n    edges.clear();\n    for(auto &e:G){\n      e.clear();\n    }\n    for(int i=0;i<M;i++){\n      int a,b;\n      cin>>a>>b;\n      add_edge(a,b);\n    }\n    int df=max_flow(S,T);\n    int nr=0;\n    for(int i=0;i<M;i++){\n      int f,fx,t,tx;\n      tie(f,fx,t,tx)=edges[i];\n      bool rev=false;\n      if(G[f][fx].cap==0){\n\trev=true;\n\tmax_flow(f,S,1);\n\tmax_flow(T,t,1);\n      }\n      G[f][fx].cap=0;\n      G[t][tx].cap=1;\n      if(max_flow(S,T)>rev){\n\tnr++;\n      }\n      if(G[t][tx].cap==0){\n\tmax_flow(T,f,1);\n\tmax_flow(t,S,1);\n      }\n      G[f][fx].cap=1;\n      G[t][tx].cap=0;\n      max_flow(S,T);\n    }\n    cout<<df+!!nr<<' '<<nr<<endl;\n  }\n}\n\n\t  \n\t"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\ntypedef int weight;\n\nstruct edge {\n\tint to;\n\tweight cap;\n\tint rev;\n\tbool is_rev;\n\tedge(int to_, weight cap_, int rev_, bool is_rev_):to(to_), cap(cap_), rev(rev_), is_rev(is_rev_){}\n};\n\nconstexpr weight INF = (1 << 29);\n\nvector<vector<edge> > G;\nvector<int> level;\nvector<int> iter;\n\nvoid init(int V) {\n\tG.assign(V, vector<edge>());\n\tlevel.resize(V);\n\titer.resize(V);\n}\n\nvoid add_edge(int from, int to, weight cap) {\n\tG[from].emplace_back(to, cap, G[to].size(), false);\n\tG[to].emplace_back(from, 0, G[from].size() - 1, true);\n}\n\nvoid bfs(int s) {\n\tfill(level.begin(), level.end(), -1);\n\tqueue<int> que;\n\tlevel[s] = 0;\n\tque.push(s);\n\n\twhile(!que.empty()) {\n\t\tconst int v = que.front();\n\t\tque.pop();\n\n\t\tfor(const auto &e : G[v]) {\n\t\t\tif(e.cap > 0 && level[e.to] < 0) {\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nweight dfs(int v, int t, weight f) {\n\tif(v == t) return f;\n\n\tfor(int &i = iter[v]; i < static_cast<int>(G[v].size()); ++i) {\n\t\tedge &e = G[v][i];\n\t\tif(e.cap > 0 && level[v] < level[e.to]) {\n\t\t\tconst weight d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif(d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nweight max_flow(int s, int t) {\n\tweight flow = 0;\n\n\tfor(;;) {\n\t\tbfs(s);\n\t\tif(level[t] < 0) return flow;\n\n\t\tfill(iter.begin(), iter.end(), 0);\n\t\tfor(weight f; (f = dfs(s, t, INF)) > 0; flow += f);\n\t}\n}\n\nvector<bool> calc_reach(int s, int ok) {\n\tconst int n = G.size();\n\n\tqueue<int> que;\n\tvector<bool> visited(n, false);\n\n\tque.push(s);\n\tvisited[s] = true;\n\n\twhile(!que.empty()) {\n\t\tconst int v = que.front();\n\t\tque.pop();\n\n\t\tfor(const auto &e : G[v]) {\n\t\t\tif(e.cap == ok && !visited[e.to]) {\n\t\t\t\tque.push(e.to);\n\t\t\t\tvisited[e.to] = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn visited;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tfor(int n, m, s, t; cin >> n >> m >> s >> t && n;) {\n\t\t--s; --t;\n\t\tinit(n);\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\t--a; --b;\n\t\t\tadd_edge(a, b, 1);\n\t\t}\n\n\t\tconst int f = max_flow(s, t);\n\t\tconst auto reach_s = calc_reach(s, 1);\n\t\tconst auto reach_t = calc_reach(t, 0);\n\n\t\tint num = 0;\n\t\tfor(int v = 0; v < n; ++v) {\n\t\t\tif(!reach_t[v]) continue;\n\n\t\t\tfor(const auto &e : G[v]) {\n\t\t\t\tif(e.cap == 1 && !e.is_rev && reach_s[e.to]) ++num;\n\t\t\t}\n\t\t}\n\n\t\tcout << (num ? f + 1 : f) << ' ' << num << endl;\n\t}\n\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(kbrni,n)cout<<\" \"<<a[kbrni];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(kbrni,v)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 1005;\n\nbool used[MAX_N];\n\ntemplate<typename T> class FordFulkerson\n{\npublic:\n    vvi G;\n    int V;\n    FordFulkerson(int node_size)\n    {\n        V = node_size;\n        G.resize(V,vi(V,0));\n    }\n    void add_edge(int from, int to, int cap){\n        G[from][to] += cap;\n    }\n    int dfs(int v,int t,int f){\n        if(v == t) return f;\n        used[v] = true;\n        rep(i,V){\n            int& cap = G[v][i];\n            if(!used[i] && cap > 0){\n                int d = dfs(i,t,min(f,cap));\n                if(d > 0){\n                    cap -= d;\n                    G[i][v] += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    int max_flow(int s,int t){\n        int flow = 0;\n        while(true){\n            memset(used,0,sizeof(used));\n            int f = dfs(s,t,INF);\n            if(f == 0) return flow;\n            flow += f;\n        }\n    }\n    int update(int s,int t,int f){\n        memset(used,0,sizeof(used));\n        return dfs(s,t,f);\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1){\n        int n,m,s,t;\n        cin >> n >> m >> s >> t;\n        --s,--t;\n        if(n == 0){\n            break;\n        }\n        FordFulkerson<int> ff(n);\n        vp path(m);\n        rep(i,m){\n            int a,b;\n            cin >> a >> b;\n            --a,--b;\n            ff.add_edge(a,b,1);\n            path[i] = P(a,b);\n        }\n        int res = ff.max_flow(s,t);\n        int ans = res;\n        int ans2 = -1;\n        vvi G = ff.G;\n        rep(i,m){\n            int u = path[i].fi,v = path[i].se;\n            if(G[v][u] == 0){\n                G[u][v]--;\n                int k = ff.update(s,v,1);\n                int l = ff.update(u,t,1);\n                if(min(k,l) == 1){\n                    ans = res+1;\n                    ans2 = i;\n                    break;\n                }\n                if(k) ff.update(v,s,1);\n                if(l) ff.update(t,u,1);\n                G[u][v]++;\n            }\n        }\n        if(ans == res){\n            cout << ans << \" \" << \"0\\n\";\n        }else{\n            cout << ans << \" \" << ans2+1 << \"\\n\";\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 1005\n\nenum Type{\n\tFROM_S,\n\tFROM_T,\n};\n\n\n//辺を表す構造体(行先、容量、逆辺のインデックス)\nstruct Edge{\n\tEdge(int arg_to,int arg_capacity,int arg_rev_index,bool arg_is_rev){\n\t\tto = arg_to;\n\t\tcapacity = arg_capacity;\n\t\trev_index = arg_rev_index;\n\t\tis_rev = arg_is_rev;\n\t}\n\tint to,capacity,rev_index;\n\tbool is_rev;\n};\n\nint V,E;\nint N,M,S,T;\n\nvector<Edge> G[NUM]; //グラフの隣接リスト表現\nint dist[NUM]; //sourceからの距離\nint cheked_index[NUM]; //どこまで調べ終わったか\nbool can_reach[2][NUM]; //S,Tから各点へ到達できるかのチェック\n\n//fromからtoへ向かう容量capacityの辺をグラフに追加する\nvoid add_edge(int from,int to,int capacity){\n\tG[from].push_back(Edge(to,capacity,G[to].size(),false));\n\tG[to].push_back(Edge(from,0,G[from].size()-1,true)); //逆辺の、初期容量は0\n}\n\n//sourceからの最短距離をBFSで計算する\nvoid bfs(int source){\n\tfor(int i = 0; i < V; i++)dist[i] = -1;\n\tqueue<int> Q;\n\tdist[source] = 0;\n\tQ.push(source);\n\n\twhile(!Q.empty()){\n\t\tint node_id = Q.front();\n\t\tQ.pop();\n\t\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\t\tEdge &e = G[node_id][i];\n\t\t\tif(e.capacity > 0 && dist[e.to] < 0){ //辺の容量が正で、かつエッジの行先に未訪問の場合\n\t\t\t\tdist[e.to] = dist[node_id]+1;\n\t\t\t\tQ.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\n//増加パスをDFSで探す\nint dfs(int node_id,int sink,int flow){\n\tif(node_id == sink)return flow; //終点についたらflowをreturn\n\n\tfor(int &i = cheked_index[node_id]; i < G[node_id].size(); i++){ //node_idから出ているエッジを調査\n\t\tEdge &e = G[node_id][i];\n\t\tif(e.capacity > 0 && dist[node_id] < dist[e.to]){ //流せる余裕があり、かつsourceからの距離が増加する方法である場合\n\t\t\tint tmp_flow = dfs(e.to,sink,min(flow,e.capacity)); //流せるだけ流す\n\t\t\tif(tmp_flow > 0){ //流せた場合\n\t\t\t\te.capacity -= tmp_flow; //流した分、エッジの容量を削減する\n\t\t\t\tG[e.to][e.rev_index].capacity += tmp_flow; //逆辺の容量を、流した分だけ増加させる\n\t\t\t\treturn tmp_flow;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n//sourceからsinkへの最大流を求める\nint max_flow(int source,int sink){ //source:始点 sink:終点\n\tint flow = 0,add;\n\twhile(true){ //増加パスが存在する限り、流量を追加し続ける\n\t\tbfs(source);\n\t\tif(dist[sink] < 0)break; //sourceからsinkへと辿り着く残余グラフがない、つまり増加パスが無くなった場合、break\n\t\tfor(int i = 0; i < V; i++)cheked_index[i] = 0;\n\t\twhile((add = dfs(source,sink,BIG_NUM)) > 0){ //増加パスが見つかる間、加算\n\t\t\tflow += add;\n\t\t}\n\t}\n\treturn flow;\n}\n\n\n\n//あらかじめ、S,Tから行けないノードを特定しておく\nvoid reach_check(Type type,int node_id){\n\n\tcan_reach[type][node_id] = true;\n\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\tif(G[node_id][i].capacity == 1 && can_reach[type][G[node_id][i].to] == false){\n\t\t\treach_check(type,G[node_id][i].to);\n\t\t}\n\t}\n}\n\n\n\nvoid func(){\n\n\tfor(int i = 0; i < N; i++){\n\t\tG[i].clear();\n\t\tcan_reach[FROM_S][i] = false;\n\t\tcan_reach[FROM_T][i] = false;\n\t}\n\n\tS--;\n\tT--;\n\n\tint from,to;\n\tfor(int loop = 0; loop < M; loop++){\n\t\tscanf(\"%d %d\",&from,&to);\n\t\tfrom--;\n\t\tto--;\n\t\tadd_edge(from,to,1);\n\t}\n\n\tV = N;\n\n\tint FLOW = max_flow(S,T);\n\tint MAX_FLOW = FLOW;\n\n\treach_check(FROM_S,S);\n\treach_check(FROM_T,T);\n\n\tint num_edge = 0,diff;\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < G[i].size(); k++){\n\t\t\tif(G[i][k].is_rev == true || G[i][k].capacity == 0 ||\n\t\t\t\t\tcan_reach[FROM_S][G[i][k].to] == false || can_reach[FROM_T][i] == false)continue; //逆辺または、最大流達成のために使用した辺はSKIP\n\n\t\t\t//★★経路に重なりがあるかも知れないので、仮にcan_reachが両方trueでも、流量が1増えるとは限らない★★\n\n\t\t\t//最大流達成の際に使用していない辺のみ、向きを逆転させれば、総経路が1増える可能性がある\n\n\t\t\t//辺の向きを逆転させる\n\t\t\tG[i][k].capacity = 0;\n\t\t\tG[G[i][k].to][G[i][k].rev_index].capacity = 1;\n\n\t\t\t//S→T方向に流す\n\t\t\tdiff = max_flow(S,T);\n\n\t\t\tif(diff == 1){ //流量が増加した場合\n\t\t\t\tnum_edge++;\n\t\t\t\tMAX_FLOW = FLOW+1;\n\n\t\t\t\tif(i != T){\n\t\t\t\t\tmax_flow(T,i); //T→iに押し戻す\n\t\t\t\t}\n\t\t\t\tif(G[i][k].to != S){\n\t\t\t\t\tmax_flow(G[i][k].to,S); //G[i][k].to→Sに押し戻す\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//辺の向きを元に戻す\n\t\t\tG[i][k].capacity = 1;\n\t\t\tG[G[i][k].to][G[i][k].rev_index].capacity = 0;\n\t\t}\n\t}\n\n\tprintf(\"%d %d\\n\",MAX_FLOW,num_edge);\n}\n\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d %d %d\",&N,&M,&S,&T);\n\t\tif(N == 0 && M == 0 && S == 0 && T == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\nconst int D_MAX_V=2002;\nconst int D_v_size=2002;\nstruct D_wolf{\n\tint t,c,r;\n\tD_wolf(){t=c=r=0;}\n\tD_wolf(int t1,int c1,int r1){\n\t\tt=t1;c=c1;r=r1;\n\t}\n};\nvector<D_wolf>D_G[D_MAX_V];\nint D_level[D_MAX_V];\nint D_iter[D_MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n\tfor(int i=0;i<D_G[from].size();i++){\n\t\tif(to==D_G[from][i].t){\n\t\t\tD_G[from][i].c+=cap;\n\t\t\treturn;\n\t\t}\n\t}\n\tD_G[from].push_back(D_wolf(to,cap,D_G[to].size()));\n\tD_G[to].push_back(D_wolf(from,0,D_G[from].size()-1));\n}\nvoid D_bfs(int s){\n\tfor(int i=0;i<D_v_size;i++)D_level[i]=-1;\n\tqueue<int> Q;\n\tD_level[s]=0;\n\tQ.push(s);\n\twhile(Q.size()){\n\t\tint v=Q.front();\n\t\tQ.pop();\n\t\tfor(int i=0;i<D_G[v].size();i++){\n\t\t\tif(D_G[v][i].c>0&&D_level[D_G[v][i].t]<0){\n\t\t\t\tD_level[D_G[v][i].t]=D_level[v]+1;\n\t\t\t\tQ.push(D_G[v][i].t);\n\t\t\t}\n\t\t}\n\t}\n}\nint D_dfs(int v,int t,int f){\n\tif(v==t)return f;\n\tfor(;D_iter[v]<D_G[v].size();D_iter[v]++){\n\t\tint i=D_iter[v];\n\t\tif(D_G[v][i].c>0&&D_level[v]<D_level[D_G[v][i].t]){\n\t\t\tint d=D_dfs(D_G[v][i].t,t,min(f,D_G[v][i].c));\n\t\t\tif(d>0){\n\t\t\t\tD_G[v][i].c-=d;\n\t\t\t\tD_G[D_G[v][i].t][D_G[v][i].r].c+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s,int t){\n\tint flow=0;\n\tfor(;;){\n\t\tD_bfs(s);\n\t\tif(D_level[t]<0)return flow;\n\t\tfor(int i=0;i<D_v_size;i++)D_iter[i]=0;\n\t\tint f;\n\t\twhile((f=D_dfs(s,t,99999999))>0){flow+=f;}\n\t}\n\treturn 0;\n}\nint c,d;\nint vis[1100];\nint dfs(int u,int v){\n\tif(u==v){\n\t\treturn 1;\n\t}\n\tvis[u]=1;\n\tfor(int i=0;i<D_G[u].size();i++){\n\t\tif(vis[D_G[u][i].t])continue;\n\t\tif(!D_G[u][i].c)continue;\n\t\tif(dfs(D_G[u][i].t,v)){\n\t\t\tD_G[u][i].c--;\n\t\t\tD_G[D_G[u][i].t][D_G[u][i].r].c++;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint Minus(int s,int t){\n\tfor(int i=0;i<D_G[s].size();i++){\n\t\tif(D_G[s][i].t==t){\n\t\t\tif(D_G[s][i].c){\n\t\t\t\tD_G[s][i].c--;return 0;\n\t\t\t}else{\n\t\t\t\tfor(int j=0;j<1100;j++)vis[j]=0;\n\t\t\t\tif(dfs(s,t))return 0;\n\t\t\t\tfor(int j=0;j<1100;j++)vis[j]=0;\n\t\t\t\tdfs(d,t);\n\t\t\t\tfor(int j=0;j<1100;j++)vis[j]=0;\n\t\t\t\tdfs(s,c);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n}\nint Plus(int s,int t){\n\tfor(int i=0;i<D_G[s].size();i++){\n\t\tif(D_G[s][i].t==t){D_G[s][i].c++;break;}\n\t}\n\treturn max_flow(c,d);\n}\nint p[11000];\nint q[11000];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d%d%d\",&a,&b,&c,&d),a){\n\t\tc--;d--;\n\t\tfor(int i=0;i<2002;i++){\n\t\t\tD_G[i].clear();\n\t\t\tD_level[i]=D_iter[i]=0;\n\t\t}\n\t\tfor(int i=0;i<b;i++){\n\t\t\tscanf(\"%d%d\",p+i,q+i);\n\t\t\tp[i]--;q[i]--;\n\t\t\tadd_edge(p[i],q[i],1);\n\t\t}\n\t\tint v=max_flow(c,d);\n\t\tint ret=0;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint t1=Minus(p[i],q[i]);\n\t\t\tint t2=Plus(q[i],p[i]);\n\t\t//\tprintf(\"%d %d: %d %d\\n\",p[i],q[i],t1,t2);\n\t\t\tif(t1==0&&t2){\n\t\t\t\t\n\t\t\t\tret++;\n\t\t\t}\n\t\t\tMinus(q[i],p[i]);\n\t\t\tPlus(p[i],q[i]);\n\t\t}\n\t\tif(ret==0)printf(\"%d %d\\n\",v,ret);\n\t\telse printf(\"%d %d\\n\",v+1,ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<int(n);++i)\n#define MAX_V 10000\nint V;\n\nusing Weight = int;\n\nconst Weight INF = 1000000000;\n// const Weight eps = 1e-8;\n\nstruct Edge{\n  int src, dest;\n  int cap, rev;\n  bool isReal;\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\nint d[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(Graph &g, int src, int dest, int cap) {\n  g[src].push_back((Edge){src, dest, cap, (int)g[dest].size(),true});\n  g[dest].push_back((Edge){dest, src, 0, (int)g[src].size() - 1,false});\n}\n\nvoid bfs(Graph &g, int s) {\n  memset(d, -1, sizeof(d));\n  queue<int> que;\n  d[s] = 0;\n  que.push(s);\n  while(!que.empty()) {\n    int v = que.front(); que.pop();\n    REP(i, g[v].size()) {\n      Edge &e = g[v][i];\n      if (e.cap > 0 && d[e.dest] < 0) {\n        d[e.dest] = d[v] + 1;\n        que.push(e.dest);\n      }\n    }\n  }\n}\n\nint dfs(Graph &g, int v, int t, int f) {\n  if (v == t) return f;\n  for (int &i = iter[v]; i < g[v].size(); i++) {\n    Edge &e = g[v][i];\n    if (e.cap > 0 && d[v] < d[e.dest]) {\n      int d = dfs(g, e.dest, t, min(f, e.cap));\n      if (d > 0) {\n        e.cap -= d;\n        g[e.dest][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(Graph& g, int s, int t) {\n  int flow = 0;\n  for (;;) {\n    bfs(g, s);\n    if (d[t] < 0) return flow;\n    memset(iter, 0, sizeof(iter));\n    int f;\n    while ((f = dfs(g, s, t, INF)) > 0) flow += f;\n  }\n}\nint main(){\n  int n,m,s,t;\n  while(cin>>n>>m>>s>>t){\n    s--,t--;\n    vector<int> a(m),b(m);\n    for(int i=0;i<m;i++){\n      cin>>a[i]>>b[i];\n      a[i]--,b[i]--;\n    }\n    Graph g(n);\n    for(int i=0;i<m;i++){\n      add_edge(g,a[i],b[i],1);\n    }\n\n    int f=max_flow(g,s,t);\n\n    vector<int> ca,cb;\n    Graph gr(n);\n    Graph rgr(n);\n    for(int i=0;i<n;i++){\n      for(int j=0;j<g[i].size();j++){\n\tif(!g[i][j].isReal || g[i][j].cap==0) continue;\n\tgr[i].push_back(Edge{i,g[i][j].dest,0,0});\n\trgr[g[i][j].dest].push_back(Edge{g[i][j].dest,i,0,0});\n      }\n    }\n    \n    function<void(int,Graph&,vector<int>&)> mydfs=[&](int v,Graph &graph,vector<int>& used){\n      if(used[v]) return;\n      used[v]=true;\n      for(int i=0;i<graph[v].size();i++) mydfs(graph[v][i].dest,graph,used);\n      return;\n    };\n    /*\n    vector<int> used(n,false),rused(n,false);\n    mydfs(s,gr,used);\n    mydfs(t,rgr,rused);\n    for(int i=0;i<n;i++) cerr<<used[i];\n    cerr<<endl;\n\n    for(int i=0;i<n;i++) cerr<<rused[i];\n    cerr<<endl;\n\n   for(int i=0;i<gr.size();i++){\n      for(int j=0;j<gr[i].size();j++){\n\tint to=gr[i][j].dest;\n\tif(!used[i] && used[to] && rused[i] && !rused[to]){\n\t  ca.push_back(i);\n\t  cb.push_back(to);\n\t}\n      }\n    }\n    */   \n    int res=0;\n    for(int i=0;i<gr.size();i++)for(int j=0;j<gr[i].size();j++){\n\tint aa=i,bb=gr[i][j].dest;\n      Graph newg=g;\n      add_edge(newg,bb,aa,1);\n      int f2=max_flow(newg,s,t);\n      if(f2>0) res++;\n    }\n    if(res==0){\n      cout<<f<<\" \"<<0<<endl;\n    }\n    else{\n      cout<<f+1<<\" \"<<res<<endl;\n    }\n    \n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_V 1005\n#define INF 1e9\nusing namespace std;\n\n/*?????§???(Dinic???) O(|E||V|^2)*/\n//????????¨????§???????(???????????????????????????)\nstruct edge{int to, cap, rev, s;};\nvector<edge> G[MAX_V]; //??°???????????£??\\???????????¨???\nint level[MAX_V];      //s??????????????¢\nint iter[MAX_V];       //???????????§??????????????£??????\n//????????¨????§???????(???????????????????????????)\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size(),0});\n  G[to].push_back((edge){from,0,(int)G[from].size()-1,1});  \n}\n\n//s????????????????????¢???BFS??§?¨??????????\nvoid bfs(int s){\n  memset(level,-1,sizeof(level));\n  queue<int> que;\n  level[s] = 0;\n  que.push(s);\n  while(!que.empty()){\n    int v = que.front(); que.pop();\n    for(int i=0; i<G[v].size(); i++){\n      edge &e = G[v][i];\n      if(e.cap > 0 && level[e.to] < 0){\n\tlevel[e.to] = level[v] + 1;\n\tque.push(e.to);\n      }\n    }\n  }\n}\n\n//?¢?????????????DFS??§??¢??????\nint dfs(int v,int t,int f){\n  if(v==t) return f;\n  for(int &i= iter[v]; i<G[v].size(); i++){\n    edge &e = G[v][i];\n    if(e.cap > 0 && level[v] < level[e.to]){\n      int d = dfs(e.to, t, min(f, e.cap));\n      if(d > 0){\n\te.cap -= d;\n\tG[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\n//s??????t???????????§???????±???????\nint max_flow(int s,int t,int maxf){\n  int flow=0;\n  for(;;){\n    bfs(s);\n    if(maxf==0||level[t] < 0) return flow;\n    memset(iter,0,sizeof(iter));\n    int f;\n    while((f=dfs(s ,t ,maxf)) > 0 ) flow += f, maxf-=f;\n  }\n}\n\nint n, m, s, t;\n\nvoid solve(){\n  \n  int r = max_flow(s, t, INF);\n  int maxflow=r;\n  \n  unordered_map<int,int> cnt;\n  \n  for(int i=1;i<=n;i++){\n    \n    for(int j=0;j<G[i].size();j++){\n      \n      edge &s1 = G[i][j];\n      edge &t1 = G[s1.to][s1.rev];\n      \n      if(s1.s) continue;\n      if(t1.cap==1) continue;\n      \n      s1.cap=0;\n      \n      int f1=max_flow(s,s1.to,1);\n\n      int f2=max_flow(i,t,1);\n      \n      int f=r;\n      \n      if(f1&&f2) f=r+1;\n      \n      if(f1) max_flow(s1.to,s,1);\n      \n      if(f2) max_flow(t,i,1);\n      \n      if(maxflow<f) maxflow=f;\n\n      cnt[f]++;\n\n      s1.cap=1;\n    }\n    \n  }\n\n  int revcnt=0;\n\n  if(r<maxflow){\n    for(pair<int,int> d : cnt)\n      if(maxflow==d.first) revcnt+=d.second;\n  }\n  \n  cout<<maxflow<<' '<<revcnt<<endl;\n  \n}\n\nvoid init(){\n  for(int i=0;i<MAX_V;i++) G[i].clear();\n}\n\nint main(){\n\n  while(1){\n    \n    cin>>n>>m>>s>>t;\n    if(!n&&!m&&!s&&!t) break;\n\n    init();\n    \n    for(int i=0;i<m;i++){\n      int a, b;\n      cin>>a>>b;\n      add_edge(a,b,1);\n    }\n  \n    solve();\n  }\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 1005\n\nenum Type{\n\tFROM_S,\n\tFROM_T,\n};\n\n\n//辺を表す構造体(行先、容量、逆辺のインデックス)\nstruct Edge{\n\tEdge(int arg_to,int arg_capacity,int arg_rev_index,bool arg_is_rev){\n\t\tto = arg_to;\n\t\tcapacity = arg_capacity;\n\t\trev_index = arg_rev_index;\n\t\tis_rev = arg_is_rev;\n\t}\n\tint to,capacity,rev_index;\n\tbool is_rev;\n};\n\nint V,E;\nint N,M,S,T;\n\nvector<Edge> G[NUM]; //グラフの隣接リスト表現\nbool used[NUM]; //DFSですでに調べたかのフラグ\nbool can_reach[2][NUM]; //S,Tから各点へ到達できるかのチェック\n\n//fromからtoへ向かう容量capacityの辺をグラフに追加する\nvoid add_edge(int from,int to,int capacity){\n\tG[from].push_back(Edge(to,capacity,G[to].size(),false));\n\tG[to].push_back(Edge(from,0,G[from].size()-1,true)); //逆辺の、初期容量は0\n}\n\n//増加パスをDFSで探す\nint dfs(int node_id,int sink,int flow){\n\tif(node_id == sink)return flow; //終点についたらflowをreturn\n\tused[node_id] = true;\n\n\tfor(int i = 0; i < G[node_id].size(); i++){ //node_idから出ているエッジを調査\n\t\tEdge &e = G[node_id][i];\n\t\tif(used[e.to] == false && e.capacity > 0){ //エッジの先のノードに未訪問で、かつエッジに流す余裕がある場合\n\t\t\tint tmp_flow = dfs(e.to,sink,min(flow,e.capacity)); //流せるだけ流す\n\t\t\tif(tmp_flow > 0){ //流せた場合\n\t\t\t\te.capacity -= tmp_flow; //流した分、エッジの容量を削減する\n\t\t\t\tG[e.to][e.rev_index].capacity += tmp_flow; //逆辺の容量を、流した分だけ増加させる\n\t\t\t\treturn tmp_flow;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid reach_check(Type type,int node_id){\n\n\tcan_reach[type][node_id] = true;\n\tint base;\n\n\tif(type == FROM_S){\n\t\tbase = 1;\n\t}else{\n\t\tbase = 0; //★逆向きに進めれば良いため★\n\t}\n\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\tif(G[node_id][i].capacity == base && can_reach[type][G[node_id][i].to] == false){\n\t\t\treach_check(type,G[node_id][i].to);\n\t\t}\n\t}\n}\n\n\n//sourceからsinkへの最大流を求める\nint max_flow(int source,int sink){ //source:始点 sink:終点\n\tint flow = 0,add;\n\twhile(true){ //増加パスが存在する限り、流量を追加し続ける\n\t\tfor(int i = 0; i < V; i++)used[i] = false;\n\t\tadd = dfs(source,sink,BIG_NUM);\n\t\tif(add == 0)break;\n\t\tflow += add;\n\t}\n\treturn flow;\n}\n\nvoid func(){\n\n\tfor(int i = 0; i < N; i++){\n\t\tG[i].clear();\n\t\tcan_reach[FROM_S][i] = false;\n\t\tcan_reach[FROM_T][i] = false;\n\t}\n\n\tS--;\n\tT--;\n\n\tint from,to;\n\tfor(int loop = 0; loop < M; loop++){\n\t\tscanf(\"%d %d\",&from,&to);\n\t\tfrom--;\n\t\tto--;\n\t\tadd_edge(from,to,1);\n\t}\n\n\tV = N;\n\n\tint FLOW = max_flow(S,T);\n\t//printf(\"FLOW:%d\\n\",FLOW);\n\t//return;\n\tint MAX_FLOW = FLOW;\n\n\treach_check(FROM_S,S);\n\treach_check(FROM_T,T);\n\n\tint num_edge = 0,diff;\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < G[i].size(); k++){\n\t\t\tif(G[i][k].is_rev == true || G[i][k].capacity == 0 ||\n\t\t\t\t\tcan_reach[FROM_S][G[i][k].to] == false || can_reach[FROM_T][i] == false)continue; //逆辺または、最大流達成のために使用した辺はSKIP\n\n\t\t\t//★★経路に重なりがあるかも知れないので、仮にcan_reachが両方trueでも、流量が1増えるとは限らない★★\n\n\t\t\t//最大流達成の際に使用していない辺のみ、向きを逆転させれば、総経路が1増える可能性がある\n\n\t\t\t//辺の向きを逆転させる\n\t\t\tG[i][k].capacity = 0;\n\t\t\tG[G[i][k].to][G[i][k].rev_index].capacity = 1;\n\n\t\t\t//printf(\"%d-%dを逆転\\n\",i,G[i][k].to);\n\t\t\t//S→T方向に流す\n\t\t\tdiff = max_flow(S,T);\n\n\t\t\t//printf(\"diff:%d\\n\",diff);\n\t\t\t//return;\n\n\t\t\tif(diff == 1){ //流量が増加した場合\n\t\t\t\tnum_edge++;\n\t\t\t\tMAX_FLOW = FLOW+1;\n\n\t\t\t\tif(i != T){\n\t\t\t\t\tmax_flow(T,i); //T→iに押し戻す\n\t\t\t\t}\n\t\t\t\tif(G[i][k].to != S){\n\t\t\t\t\tmax_flow(G[i][k].to,S); //G[i][k].to→Sに押し戻す\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//辺の向きを元に戻す\n\t\t\tG[i][k].capacity = 1;\n\t\t\tG[G[i][k].to][G[i][k].rev_index].capacity = 0;\n\t\t}\n\t}\n\n\tprintf(\"%d %d\\n\",MAX_FLOW,num_edge);\n}\n\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d %d %d\",&N,&M,&S,&T);\n\t\tif(N == 0 && M == 0 && S == 0 && T == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n\tEACH(x,vec) is >> x;\n\treturn is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << \" \";\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << endl;\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\n\nstruct Edge {\n\tint to, cap, rev;\n};\nvector< vector<Edge> > G;\n\nvoid add_edge(int from, int to, int cap) {\n\tG[from].pb({to, cap, (int)G[to].size()});\n\tG[to].pb({from, 0, (int)G[from].size()-1});\n};\n\nvector<int> bfs(int s) {\n\tint N = G.size();\n\tvector<int> res(N, inf);\n\tqueue<int> Q; Q.push(s); res[s] = 0;\n\twhile ( !Q.empty() ) {\n\t\tint v = Q.front(); Q.pop();\n\t\tEACH(e, G[v]) {\n\t\t\tif (e.cap > 0 && res[v]+1 < res[e.to]) {\n\t\t\t\tres[e.to] = res[v]+1;\n\t\t\t\tQ.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint max_flow(int s, int t) {\n\tint N = G.size();\n\tint res = 0;\n\twhile (1) {\n\t\tvector<int> dist = bfs(s);\n\t\tif (dist[t] == inf) break;\n\t\tint f = 0;\n\t\twhile (1) {\n\t\t\tvector<bool> used(N, false);\n\t\t\tvector<int> prevV(N), prevE(N);\n\t\t\tqueue<int> Q; Q.push(s); used[s] = true;\n\t\t\twhile ( !Q.empty() ) {\n\t\t\t\tint v = Q.front(); Q.pop();\n\t\t\t\tREP(i, G[v].size()) {\n\t\t\t\t\tEdge& e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[v]+1 == dist[e.to] && !used[e.to]) {\n\t\t\t\t\t\tused[e.to] = true;\n\t\t\t\t\t\tprevV[e.to] = v;\n\t\t\t\t\t\tprevE[e.to] = i;\n\t\t\t\t\t\tQ.push(e.to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!used[t]) break;\n\t\t\tfor (int v = t; v != s; v = prevV[v]) {\n\t\t\t\tEdge& e = G[prevV[v]][prevE[v]];\n\t\t\t\t--e.cap;\n\t\t\t\t++G[e.to][e.rev].cap;\n\t\t\t}\n\t\t\t++f;\n\t\t}\n\t\tres += f;\n\t}\n\treturn res;\n}\n\nvector<bool> reach(vector< vector<int> >& g, int s) {\n\tint N = g.size();\n\tvector<bool> res(N, false); res[s] = true;\n\tqueue<int> Q; Q.push(s);\n\twhile ( !Q.empty() ) {\n\t\tint v = Q.front(); Q.pop();\n\t\tEACH(to, g[v]) {\n\t\t\tif ( !res[to] ) {\n\t\t\t\tres[to] = true;\n\t\t\t\tQ.push(to);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint N, M, s, t;\n\twhile ( cin >> N >> M >> s >> t, N || M || s || t ) {\n\t\t--s, --t;\n\t\tG = vector< vector<Edge> >(N);\n\t\tvector< vector<int> > gr(N);\n\t\tREP(i, M) {\n\t\t\tint a, b; cin >> a >> b; --a, --b;\n\t\t\tgr[b].pb(a);\n\t\t\tadd_edge(a, b, 1);\n\t\t}\n\t\tint flow = max_flow(s, t);\n\t\tvector< vector<int> > gs(N), gt(N);\n\t\tREP(i, N) EACH(e, G[i]) {\n\t\t\tif (e.cap > 0) {\n\t\t\t\tgs[i].pb(e.to);\n\t\t\t\tgt[e.to].pb(i);\n\t\t\t}\n\t\t}\n\t\tvector<bool> rs = reach(gs, s);\n\t\tvector<bool> rt = reach(gt, t);\n\t\tint ans = 0;\n\t\tREP(i, N) EACH(to, gr[i]) {\n\t\t\tif (rs[i] && rt[to]) {\n\t\t\t\t++ans;\n\t\t\t}\n\t\t}\n\t\tif (ans > 0) ++flow;\n\t\tcout << flow << \" \" << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\n#define MAX_V 10000\nusing namespace std;\n\n/*?????§?????¢?????´?????????(Ford_Fulerson????????¨)???O(F|E|)*/\n\n//????????¨????§???????(???????????????????????????)\nstruct edge{int to, cap, rev, s;};\n\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size(),0});\n  G[to].push_back((edge){from,0,(int)G[from].size()-1,1});  \n}\n\n//?¢?????????????DFS??§??¢???\nint dfs(int v,int t,int f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs(e.to ,t , min(f,e.cap));\n      if(d > 0){\n\te.cap -= d;\n\tG[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\n//s??????t???????????§???????±???????\nint max_flow(int s,int t,int maxf){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s, t, maxf);\n    if(maxf==0||f == 0)return flow;\n    maxf-=f;\n    flow += f;\n  }\n}\n\nint n, m, s, t;\n\nvoid solve(){\n  \n  int r = max_flow(s, t, INF);\n  int maxflow=r, cnt=0;\n    \n  for(int i=1;i<=n;i++){\n    \n    for(int j=0;j<G[i].size();j++){\n      \n      edge &s1 = G[i][j];\n      edge &t1 = G[s1.to][s1.rev];\n      \n      if(s1.s) continue;\n      if(t1.cap==1) continue;\n      \n      s1.cap=0;\n      \n      int f1=max_flow(s,s1.to,1);\n      \n      int f2=max_flow(i,t,1);\n      \n      if(f1&&f2){\n\tmaxflow=r+1;\n\tcnt++;\n      }\n      \n      if(f1) max_flow(s1.to,s,1);\n      \n      if(f2) max_flow(t,i,1);\n      \n      s1.cap=1;\n    }\n    \n  }\n\n  int revcnt=0;\n\n  if(r<maxflow) revcnt=cnt;\n  \n  cout<<maxflow<<' '<<revcnt<<endl;\n  \n}\n\nvoid init(){\n  for(int i=0;i<MAX_V;i++) G[i].clear();\n}\n\nint main(){\n\n  while(1){\n    \n    cin>>n>>m>>s>>t;\n    if(!n&&!m&&!s&&!t) break;\n\n    init();\n    \n    for(int i=0;i<m;i++){\n      int a, b;\n      cin>>a>>b;\n      add_edge(a,b,1);\n    }\n  \n    solve();\n  }\n    \n  return 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();// the number of cities\n\t\t\tint m = sc.nextInt();// the number of roads\n\t\t\tint s = sc.nextInt() - 1;\n\t\t\tint t = sc.nextInt() - 1;\n\t\t\tif (n == 0 && m == 0 && s == 0 && t == 0)\n\t\t\t\tbreak;\n\t\t\tArrayList<Edge>[] g = new ArrayList[n];\n\t\t\tArrayList<Edge>[] g_rev = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t\tg_rev[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tint[] A = new int[m];\n\t\t\tint[] B = new int[m];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint a = sc.nextInt() - 1;\n\t\t\t\tint b = sc.nextInt() - 1;\n\t\t\t\tA[i] = a;\n\t\t\t\tB[i] = b;\n\t\t\t\tg[a].add(new Edge(a, b, 1));\n\t\t\t\tg_rev[b].add(new Edge(b, a, 1));\n\t\t\t}\n\t\t\tPreflow_Relabel pr = new Preflow_Relabel(s, t, g);\n\t\t\tlong tmp = pr.calc();\n\t\t\tboolean[] reachble_from_s = new boolean[n];\n\t\t\tboolean[] reachble_from_t = new boolean[n];\n\t\t\tArrayDeque<Integer> S = new ArrayDeque<>();\n\t\t\tArrayDeque<Integer> T = new ArrayDeque<>();\n\t\t\tS.add(s);\n\t\t\tT.add(t);\n\t\t\twhile (!S.isEmpty()) {\n\t\t\t\tint v = S.poll();\n\t\t\t\tif (reachble_from_s[v]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\treachble_from_s[v] = true;\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tint u = e.dst;\n\t\t\t\t\tif (pr.residue(v, u) > 0)\n\t\t\t\t\t\tS.add(u);\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (!T.isEmpty()) {\n\t\t\t\tint v = T.poll();\n\t\t\t\tif (reachble_from_t[v]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\treachble_from_t[v] = true;\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tint u = e.dst;\n\t\t\t\t\tif (pr.residue(u, v) > 0)\n\t\t\t\t\t\tT.add(u);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tif (reachble_from_s[B[i]] && reachble_from_t[A[i]]) {\n\t\t\t\t\tSystem.out.println((tmp + 1) + \" \" + (i + 1));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(tmp + \" \" + 0);\n\t\t}\n\t}\n\n\tclass Preflow_Relabel {\n\t\tint n;\n\t\tint s;\n\t\tint t;\n\t\tArrayList<Edge>[] g;\n\t\tint[][] flow;\n\t\tint[][] capacity;\n\t\tint[] excess;\n\t\tint[] height;\n\t\tArrayDeque<Integer>[] B;\n\n\t\tvoid global_relabeling() {\n\t\t\tArrayDeque<Integer> que = new ArrayDeque<>();\n\t\t\tboolean[] arrived = new boolean[n];\n\t\t\tque.add(t);\n\t\t\twhile (!que.isEmpty()) {\n\t\t\t\tint v = que.poll();\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tif (residue(e.dst, v) > 0 && (height[v] + 1 < height[e.dst] || !arrived[e.dst])) {\n\t\t\t\t\t\theight[e.dst] = height[v] + 1;\n\t\t\t\t\t\tarrived[e.dst] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic Preflow_Relabel(int s, int t, ArrayList<Edge>[] g) {\n\t\t\tthis.g = g;\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t\tn = g.length;\n\t\t\tflow = new int[n][n];\n\t\t\tcapacity = new int[n][n];\n\t\t\theight = new int[n];\n\t\t\theight[s] = n;\n\t\t\texcess = new int[n];\n\t\t\tB = new ArrayDeque[n + 1];\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tB[i] = new ArrayDeque<>();\n\t\t\t}\n\t\t\tB[height[s]].add(s);\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (Edge e : g[i]) {\n\t\t\t\t\tif (e.weight > 0) {\n\t\t\t\t\t\tg[e.dst].add(new Edge(e.dst, e.src, 0));\n\t\t\t\t\t\tcapacity[e.src][e.dst] += e.weight;\n\t\t\t\t\t} else if (e.weight == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint b = 0;\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tint calc() {\n\t\t\tint count = 0;\n\t\t\tfor (Edge e : g[s]) {\n\t\t\t\texcess[s] += e.weight;\n\t\t\t\tpush(s, e.dst);\n\t\t\t\tB[height[e.dst]].add(e.dst);\n\t\t\t}\n\t\t\tglobal_relabeling();\n\t\t\tfor (b = height[s]; b >= 0;) {\n\t\t\t\tif (B[b].isEmpty()) {\n\t\t\t\t\tb--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint v = B[b].poll();\n\t\t\t\tif (excess[v] == 0 || v == t || v == s || height[v] > n) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tif (height[e.src] == height[e.dst] + 1) {\n\t\t\t\t\t\tif (residue(e.src, e.dst) > 0) {\n\t\t\t\t\t\t\tpush(e.src, e.dst);\n\t\t\t\t\t\t\tif (excess[v] == 0)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (excess[v] > 0) {\n\t\t\t\t\tint min = 1 << 30;\n\t\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\t\tif (residue(e.src, e.dst) > 0) {\n\t\t\t\t\t\t\tmin = Math.min(min, height[e.dst]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\theight[v] = min + 1;\n\t\t\t\t\tif (height[v] < n) {\n\t\t\t\t\t\tB[height[v]].add(v);\n\t\t\t\t\t\tif (height[v] > b)\n\t\t\t\t\t\t\tb = height[v];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (++count % n == 0) {\n\t\t\t\t\tglobal_relabeling();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn excess[t];\n\t\t}\n\n\t\tint residue(int s, int t) {\n\t\t\treturn capacity[s][t] - flow[s][t];\n\t\t}\n\n\t\tvoid push(int u, int v) {\n\t\t\tint delta = Math.min(excess[u], residue(u, v));\n\t\t\tflow[u][v] += delta;\n\t\t\tflow[v][u] -= delta;\n\t\t\texcess[v] += delta;\n\t\t\texcess[u] -= delta;\n\t\t\tif (v != t && v != s && height[v] < n) {\n\t\t\t\tB[height[v]].add(v);\n\t\t\t\tif (b < height[v]) {\n\t\t\t\t\tb = height[v];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tclass Edge {\n\t\tint src;\n\t\tint dst;\n\t\tint weight;\n\n\t\tEdge(int src, int dst, int weight) {\n\t\t\tthis.src = src;\n\t\t\tthis.dst = dst;\n\t\t\tthis.weight = weight;\n\t\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();// the number of cities\n\t\t\tint m = sc.nextInt();// the number of roads\n\t\t\tint s = sc.nextInt() - 1;\n\t\t\tint t = sc.nextInt() - 1;\n\t\t\tif (n == 0 && m == 0 && s + 1 == 0 && t + 1 == 0)\n\t\t\t\tbreak;\n\t\t\tArrayList<Edge>[] g = new ArrayList[n];\n\t\t\tArrayList<Edge>[] g_rev = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t\tg_rev[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tint[] A = new int[m];\n\t\t\tint[] B = new int[m];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint a = sc.nextInt() - 1;\n\t\t\t\tint b = sc.nextInt() - 1;\n\t\t\t\tA[i] = a;\n\t\t\t\tB[i] = b;\n\t\t\t\tg[a].add(new Edge(a, b, 1));\n\t\t\t\tg_rev[b].add(new Edge(b, a, 1));\n\t\t\t}\n\t\t\tPreflow_Relabel mf=new Preflow_Relabel(s, t, g);\n\t\t\tlong tmp = mf.calc();\n\t\t\tboolean[] reachble_from_s = new boolean[n];\n\t\t\tboolean[] reachble_from_t = new boolean[n];\n\t\t\tArrayDeque<Integer> S = new ArrayDeque<>();\n\t\t\tArrayDeque<Integer> T = new ArrayDeque<>();\n\t\t\tS.add(s);\n\t\t\tT.add(t);\n\t\t\twhile (!S.isEmpty()) {\n\t\t\t\tint v = S.poll();\n\t\t\t\tif (reachble_from_s[v]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\treachble_from_s[v] = true;\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tint u = e.dst;\n\t\t\t\t\tif (mf.residue(v, u) > 0)\n\t\t\t\t\t\tS.add(u);\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (!T.isEmpty()) {\n\t\t\t\tint v = T.poll();\n\t\t\t\tif (reachble_from_t[v]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\treachble_from_t[v] = true;\n\t\t\t\tfor (Edge e : g_rev[v]) {\n\t\t\t\t\tint u = e.dst;\n\t\t\t\t\tif (mf.residue(u, v) > 0)\n\t\t\t\t\t\tT.add(u);\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean flag = false;\n\t\t\tint count = 0;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tif (reachble_from_s[B[i]] && reachble_from_t[A[i]]) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println((tmp + (count > 0 ? 1 : 0)) + \" \" + count);\n\t\t}\n\t}\n\n\tclass Preflow_Relabel {\n\t\tint n;\n\t\tint s;\n\t\tint t;\n\t\tArrayList<Edge>[] g;\n\t\tint[][] flow;\n\t\tint[][] capacity;\n\t\tint[] excess;\n\t\tint[] height;\n\t\tArrayDeque<Integer>[] B;\n\n\t\tvoid global_relabeling() {\n\t\t\tArrayDeque<Integer> que = new ArrayDeque<>();\n\t\t\tboolean[] arrived = new boolean[n];\n\t\t\tque.add(t);\n\t\t\twhile (!que.isEmpty()) {\n\t\t\t\tint v = que.poll();\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tif (residue(e.dst, v) > 0 && (height[v] + 1 < height[e.dst] || !arrived[e.dst])) {\n\t\t\t\t\t\theight[e.dst] = height[v] + 1;\n\t\t\t\t\t\tarrived[e.dst] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic Preflow_Relabel(int s, int t, ArrayList<Edge>[] g) {\n\t\t\tthis.g = g;\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t\tn = g.length;\n\t\t\tflow = new int[n][n];\n\t\t\tcapacity = new int[n][n];\n\t\t\theight = new int[n];\n\t\t\theight[s] = n;\n\t\t\texcess = new int[n];\n\t\t\tB = new ArrayDeque[n + 1];\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tB[i] = new ArrayDeque<>();\n\t\t\t}\n\t\t\tB[height[s]].add(s);\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (Edge e : g[i]) {\n\t\t\t\t\tif (e.weight > 0) {\n\t\t\t\t\t\tg[e.dst].add(new Edge(e.dst, e.src, 0));\n\t\t\t\t\t\tcapacity[e.src][e.dst] += e.weight;\n\t\t\t\t\t} else if (e.weight == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint b = 0;\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tint calc() {\n\t\t\tint count = 0;\n\t\t\tfor (Edge e : g[s]) {\n\t\t\t\texcess[s] += e.weight;\n\t\t\t\tpush(s, e.dst);\n\t\t\t\tB[height[e.dst]].add(e.dst);\n\t\t\t}\n\t\t\tglobal_relabeling();\n\t\t\tfor (b = height[s]; b >= 0;) {\n\t\t\t\tif (B[b].isEmpty()) {\n\t\t\t\t\tb--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint v = B[b].poll();\n\t\t\t\tif (excess[v] == 0 || v == t || v == s || height[v] > n) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tif (height[e.src] == height[e.dst] + 1) {\n\t\t\t\t\t\tif (residue(e.src, e.dst) > 0) {\n\t\t\t\t\t\t\tpush(e.src, e.dst);\n\t\t\t\t\t\t\tif (excess[v] == 0)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (excess[v] > 0) {\n\t\t\t\t\tint min = 1 << 30;\n\t\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\t\tif (residue(e.src, e.dst) > 0) {\n\t\t\t\t\t\t\tmin = Math.min(min, height[e.dst]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\theight[v] = min + 1;\n\t\t\t\t\tif (height[v] < n) {\n\t\t\t\t\t\tB[height[v]].add(v);\n\t\t\t\t\t\tif (height[v] > b)\n\t\t\t\t\t\t\tb = height[v];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (++count % n == 0) {\n\t\t\t\t\tglobal_relabeling();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn excess[t];\n\t\t}\n\n\t\tint residue(int s, int t) {\n\t\t\treturn capacity[s][t] - flow[s][t];\n\t\t}\n\n\t\tvoid push(int u, int v) {\n\t\t\tint delta = Math.min(excess[u], residue(u, v));\n\t\t\tflow[u][v] += delta;\n\t\t\tflow[v][u] -= delta;\n\t\t\texcess[v] += delta;\n\t\t\texcess[u] -= delta;\n\t\t\tif (v != t && v != s && height[v] < n) {\n\t\t\t\tB[height[v]].add(v);\n\t\t\t\tif (b < height[v]) {\n\t\t\t\t\tb = height[v];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tclass Edge {\n\t\tint src;\n\t\tint dst;\n\t\tint weight;\n\n\t\tEdge(int src, int dst, int weight) {\n\t\t\tthis.src = src;\n\t\t\tthis.dst = dst;\n\t\t\tthis.weight = weight;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();// the number of cities\n\t\t\tint m = sc.nextInt();// the number of roads\n\t\t\tint s = sc.nextInt() - 1;\n\t\t\tint t = sc.nextInt() - 1;\n\t\t\tif (n == 0 && m == 0 && s == 0 && t == 0)\n\t\t\t\tbreak;\n\t\t\tArrayList<Edge>[] g = new ArrayList[n];\n\t\t\tArrayList<Edge>[] g_rev = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t\tg_rev[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tint[] A = new int[m];\n\t\t\tint[] B = new int[m];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint a = sc.nextInt() - 1;\n\t\t\t\tint b = sc.nextInt() - 1;\n\t\t\t\tA[i] = a;\n\t\t\t\tB[i] = b;\n\t\t\t\tg[a].add(new Edge(a, b, 1));\n\t\t\t\tg_rev[b].add(new Edge(b, a, 1));\n\t\t\t}\n\t\t\tPreflow_Relabel pr = new Preflow_Relabel(s, t, g);\n\t\t\tlong tmp = pr.calc();\n\t\t\tboolean[] reachble_from_s = new boolean[n];\n\t\t\tboolean[] reachble_from_t = new boolean[n];\n\t\t\tArrayDeque<Integer> S = new ArrayDeque<>();\n\t\t\tArrayDeque<Integer> T = new ArrayDeque<>();\n\t\t\tS.add(s);\n\t\t\tT.add(t);\n\t\t\twhile (!S.isEmpty()) {\n\t\t\t\tint v = S.poll();\n\t\t\t\tif (reachble_from_s[v]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\treachble_from_s[v] = true;\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tint u = e.dst;\n\t\t\t\t\tif (pr.residue(v, u) > 0)\n\t\t\t\t\t\tS.add(u);\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (!T.isEmpty()) {\n\t\t\t\tint v = T.poll();\n\t\t\t\tif (reachble_from_t[v]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\treachble_from_t[v] = true;\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tint u = e.dst;\n\t\t\t\t\tif (pr.residue(u, v) > 0)\n\t\t\t\t\t\tT.add(u);\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean flag = false;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tif (reachble_from_s[B[i]] && reachble_from_t[A[i]]) {\n\t\t\t\t\tSystem.out.println((tmp + 1) + \" \" + (i + 1));\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!flag)\n\t\t\t\tSystem.out.println(tmp + \" \" + 0);\n\t\t}\n\t}\n\n\tclass Preflow_Relabel {\n\t\tint n;\n\t\tint s;\n\t\tint t;\n\t\tArrayList<Edge>[] g;\n\t\tint[][] flow;\n\t\tint[][] capacity;\n\t\tint[] excess;\n\t\tint[] height;\n\t\tArrayDeque<Integer>[] B;\n\n\t\tvoid global_relabeling() {\n\t\t\tArrayDeque<Integer> que = new ArrayDeque<>();\n\t\t\tboolean[] arrived = new boolean[n];\n\t\t\tque.add(t);\n\t\t\twhile (!que.isEmpty()) {\n\t\t\t\tint v = que.poll();\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tif (residue(e.dst, v) > 0 && (height[v] + 1 < height[e.dst] || !arrived[e.dst])) {\n\t\t\t\t\t\theight[e.dst] = height[v] + 1;\n\t\t\t\t\t\tarrived[e.dst] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic Preflow_Relabel(int s, int t, ArrayList<Edge>[] g) {\n\t\t\tthis.g = g;\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t\tn = g.length;\n\t\t\tflow = new int[n][n];\n\t\t\tcapacity = new int[n][n];\n\t\t\theight = new int[n];\n\t\t\theight[s] = n;\n\t\t\texcess = new int[n];\n\t\t\tB = new ArrayDeque[n + 1];\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tB[i] = new ArrayDeque<>();\n\t\t\t}\n\t\t\tB[height[s]].add(s);\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (Edge e : g[i]) {\n\t\t\t\t\tif (e.weight > 0) {\n\t\t\t\t\t\tg[e.dst].add(new Edge(e.dst, e.src, 0));\n\t\t\t\t\t\tcapacity[e.src][e.dst] += e.weight;\n\t\t\t\t\t} else if (e.weight == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint b = 0;\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tint calc() {\n\t\t\tint count = 0;\n\t\t\tfor (Edge e : g[s]) {\n\t\t\t\texcess[s] += e.weight;\n\t\t\t\tpush(s, e.dst);\n\t\t\t\tB[height[e.dst]].add(e.dst);\n\t\t\t}\n\t\t\tglobal_relabeling();\n\t\t\tfor (b = height[s]; b >= 0;) {\n\t\t\t\tif (B[b].isEmpty()) {\n\t\t\t\t\tb--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint v = B[b].poll();\n\t\t\t\tif (excess[v] == 0 || v == t || v == s || height[v] > n) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tif (height[e.src] == height[e.dst] + 1) {\n\t\t\t\t\t\tif (residue(e.src, e.dst) > 0) {\n\t\t\t\t\t\t\tpush(e.src, e.dst);\n\t\t\t\t\t\t\tif (excess[v] == 0)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (excess[v] > 0) {\n\t\t\t\t\tint min = 1 << 30;\n\t\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\t\tif (residue(e.src, e.dst) > 0) {\n\t\t\t\t\t\t\tmin = Math.min(min, height[e.dst]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\theight[v] = min + 1;\n\t\t\t\t\tif (height[v] < n) {\n\t\t\t\t\t\tB[height[v]].add(v);\n\t\t\t\t\t\tif (height[v] > b)\n\t\t\t\t\t\t\tb = height[v];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (++count % n == 0) {\n\t\t\t\t\tglobal_relabeling();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn excess[t];\n\t\t}\n\n\t\tint residue(int s, int t) {\n\t\t\treturn capacity[s][t] - flow[s][t];\n\t\t}\n\n\t\tvoid push(int u, int v) {\n\t\t\tint delta = Math.min(excess[u], residue(u, v));\n\t\t\tflow[u][v] += delta;\n\t\t\tflow[v][u] -= delta;\n\t\t\texcess[v] += delta;\n\t\t\texcess[u] -= delta;\n\t\t\tif (v != t && v != s && height[v] < n) {\n\t\t\t\tB[height[v]].add(v);\n\t\t\t\tif (b < height[v]) {\n\t\t\t\t\tb = height[v];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tclass Edge {\n\t\tint src;\n\t\tint dst;\n\t\tint weight;\n\n\t\tEdge(int src, int dst, int weight) {\n\t\t\tthis.src = src;\n\t\t\tthis.dst = dst;\n\t\t\tthis.weight = weight;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();// the number of cities\n\t\t\tint m = sc.nextInt();// the number of roads\n\t\t\tint s = sc.nextInt() - 1;\n\t\t\tint t = sc.nextInt() - 1;\n\t\t\tif (n == 0 && m == 0 && s + 1 == 0 && t + 1 == 0)\n\t\t\t\tbreak;\n\t\t\tArrayList<Edge>[] g = new ArrayList[n];\n\t\t\tArrayList<Edge>[] g_rev = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t\tg_rev[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tint[] A = new int[m];\n\t\t\tint[] B = new int[m];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint a = sc.nextInt() - 1;\n\t\t\t\tint b = sc.nextInt() - 1;\n\t\t\t\tA[i] = a;\n\t\t\t\tB[i] = b;\n\t\t\t\tg[a].add(new Edge(a, b, 1));\n\t\t\t\tg_rev[b].add(new Edge(b, a, 1));\n\t\t\t}\n\t\t\tEdmonds_Kerp_MaxFlow mf = new Edmonds_Kerp_MaxFlow(s, t, g);\n\t\t\tlong tmp = mf.MaxFlow();\n\t\t\tboolean[] reachble_from_s = new boolean[n];\n\t\t\tboolean[] reachble_from_t = new boolean[n];\n\t\t\tArrayDeque<Integer> S = new ArrayDeque<>();\n\t\t\tArrayDeque<Integer> T = new ArrayDeque<>();\n\t\t\tS.add(s);\n\t\t\tT.add(t);\n\t\t\twhile (!S.isEmpty()) {\n\t\t\t\tint v = S.poll();\n\t\t\t\tif (reachble_from_s[v]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\treachble_from_s[v] = true;\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tint u = e.dst;\n\t\t\t\t\tif (mf.residue(v, u) > 0)\n\t\t\t\t\t\tS.add(u);\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (!T.isEmpty()) {\n\t\t\t\tint v = T.poll();\n\t\t\t\tif (reachble_from_t[v]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\treachble_from_t[v] = true;\n\t\t\t\tfor (Edge e : g_rev[v]) {\n\t\t\t\t\tint u = e.dst;\n\t\t\t\t\tif (mf.residue(u, v) > 0)\n\t\t\t\t\t\tT.add(u);\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean flag = false;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tif (reachble_from_s[B[i]] && reachble_from_t[A[i]]) {\n\t\t\t\t\tSystem.out.println((tmp + 1) + \" \" + (i + 1));\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!flag)\n\t\t\t\tSystem.out.println(tmp + \" \" + 0);\n\t\t}\n\t}\n\n\tclass Edmonds_Kerp_MaxFlow {\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tint n;\n\t\tint s;\n\t\tint t;\n\t\tArrayList<Edge>[] g;\n\t\tint[][] flow;\n\t\tint[][] capacity;\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic Edmonds_Kerp_MaxFlow(int s, int t, ArrayList<Edge>[] g) {\n\t\t\tthis.g = g;\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t\tn = g.length;\n\t\t\tflow = new int[n][n];\n\t\t\tcapacity = new int[n][n];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (Edge e : g[i]) {\n\t\t\t\t\tif (e.weight > 0) {\n\t\t\t\t\t\tg[e.dst].add(new Edge(e.dst, e.src, 0));\n\t\t\t\t\t\tcapacity[e.src][e.dst] += e.weight;\n\t\t\t\t\t} else if (e.weight == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tint MaxFlow() {\n\t\t\tint total = 0;\n\t\t\twhile (true) {\n\t\t\t\tint[] prev = bfs();\n\t\t\t\tif (prev[t] == -1)\n\t\t\t\t\treturn total;\n\t\t\t\tint inc = 1 << 30;\n\t\t\t\tfor (int i = t; prev[i] != -1; i = prev[i]) {\n\t\t\t\t\tinc = Math.min(inc, residue(prev[i], i));\n\t\t\t\t}\n\t\t\t\tfor (int i = t; prev[i] != -1; i = prev[i]) {\n\t\t\t\t\tpush(prev[i], i, inc);\n\t\t\t\t}\n\t\t\t\ttotal += inc;\n\t\t\t}\n\t\t}\n\n\t\tint residue(int s, int t) {\n\t\t\treturn capacity[s][t] - flow[s][t];\n\t\t}\n\n\t\tint[] bfs() {\n\t\t\tint[] prev = new int[n];\n\t\t\tArrays.fill(prev, -1);\n\t\t\tArrayDeque<Integer> que = new ArrayDeque<>();\n\t\t\tque.add(s);\n\t\t\tout: while (!que.isEmpty()) {\n\t\t\t\tint v = que.poll();\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tif (prev[e.dst] == -1 && e.dst != s && residue(v, e.dst) > 0) {\n\t\t\t\t\t\tprev[e.dst] = v;\n\t\t\t\t\t\tque.add(e.dst);\n\t\t\t\t\t\tif (e.dst == t)\n\t\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn prev;\n\t\t}\n\n\t\tvoid push(int s, int t, int inc) {\n\t\t\tflow[s][t] += inc;\n\t\t\tflow[t][s] -= inc;\n\t\t}\n\t}\n\n\tclass Edge {\n\t\tint src;\n\t\tint dst;\n\t\tint weight;\n\n\t\tEdge(int src, int dst, int weight) {\n\t\t\tthis.src = src;\n\t\t\tthis.dst = dst;\n\t\t\tthis.weight = weight;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();// the number of cities\n\t\t\tint m = sc.nextInt();// the number of roads\n\t\t\tint s = sc.nextInt() - 1;\n\t\t\tint t = sc.nextInt() - 1;\n\t\t\tif (n == 0 && m == 0 && s + 1 == 0 && t + 1 == 0)\n\t\t\t\tbreak;\n\t\t\tArrayList<Edge>[] g = new ArrayList[n];\n\t\t\tArrayList<Edge>[] g_rev = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t\tg_rev[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tint[] A = new int[m];\n\t\t\tint[] B = new int[m];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint a = sc.nextInt() - 1;\n\t\t\t\tint b = sc.nextInt() - 1;\n\t\t\t\tA[i] = a;\n\t\t\t\tB[i] = b;\n\t\t\t\tg[a].add(new Edge(a, b, 1));\n\t\t\t\tg_rev[b].add(new Edge(b, a, 1));\n\t\t\t}\n\t\t\tEdmonds_Kerp_MaxFlow mf = new Edmonds_Kerp_MaxFlow(s, t, g);\n\t\t\tlong tmp = mf.MaxFlow();\n\t\t\tboolean[] reachble_from_s = new boolean[n];\n\t\t\tboolean[] reachble_from_t = new boolean[n];\n\t\t\tArrayDeque<Integer> S = new ArrayDeque<>();\n\t\t\tArrayDeque<Integer> T = new ArrayDeque<>();\n\t\t\tS.add(s);\n\t\t\tT.add(t);\n\t\t\twhile (!S.isEmpty()) {\n\t\t\t\tint v = S.poll();\n\t\t\t\tif (reachble_from_s[v]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\treachble_from_s[v] = true;\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tint u = e.dst;\n\t\t\t\t\tif (mf.residue(v, u) == 1)\n\t\t\t\t\t\tS.add(u);\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (!T.isEmpty()) {\n\t\t\t\tint v = T.poll();\n\t\t\t\tif (reachble_from_t[v]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\treachble_from_t[v] = true;\n\t\t\t\tfor (Edge e : g_rev[v]) {\n\t\t\t\t\tint u = e.dst;\n\t\t\t\t\tif (mf.residue(u, v) == 1)\n\t\t\t\t\t\tT.add(u);\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean flag = false;\n\t\t\tint count = 0;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tif (reachble_from_s[B[i]] && reachble_from_t[A[i]]) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println((tmp + (count > 0 ? 1 : 0)) + \" \" + count);\n\t\t}\n\t}\n\n\tclass Edmonds_Kerp_MaxFlow {\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tint n;\n\t\tint s;\n\t\tint t;\n\t\tArrayList<Edge>[] g;\n\t\tint[][] flow;\n\t\tint[][] capacity;\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic Edmonds_Kerp_MaxFlow(int s, int t, ArrayList<Edge>[] g) {\n\t\t\tthis.g = g;\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t\tn = g.length;\n\t\t\tflow = new int[n][n];\n\t\t\tcapacity = new int[n][n];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (Edge e : g[i]) {\n\t\t\t\t\tif (e.weight > 0) {\n\t\t\t\t\t\tg[e.dst].add(new Edge(e.dst, e.src, 0));\n\t\t\t\t\t\tcapacity[e.src][e.dst] += e.weight;\n\t\t\t\t\t} else if (e.weight == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tint MaxFlow() {\n\t\t\tint total = 0;\n\t\t\twhile (true) {\n\t\t\t\tint[] prev = bfs();\n\t\t\t\tif (prev[t] == -1)\n\t\t\t\t\treturn total;\n\t\t\t\tint inc = 1 << 30;\n\t\t\t\tfor (int i = t; prev[i] != -1; i = prev[i]) {\n\t\t\t\t\tinc = Math.min(inc, residue(prev[i], i));\n\t\t\t\t}\n\t\t\t\tfor (int i = t; prev[i] != -1; i = prev[i]) {\n\t\t\t\t\tpush(prev[i], i, inc);\n\t\t\t\t}\n\t\t\t\ttotal += inc;\n\t\t\t}\n\t\t}\n\n\t\tint residue(int s, int t) {\n\t\t\treturn capacity[s][t] - flow[s][t];\n\t\t}\n\n\t\tint[] bfs() {\n\t\t\tint[] prev = new int[n];\n\t\t\tArrays.fill(prev, -1);\n\t\t\tArrayDeque<Integer> que = new ArrayDeque<>();\n\t\t\tque.add(s);\n\t\t\tout: while (!que.isEmpty()) {\n\t\t\t\tint v = que.poll();\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tif (prev[e.dst] == -1 && e.dst != s && residue(v, e.dst) > 0) {\n\t\t\t\t\t\tprev[e.dst] = v;\n\t\t\t\t\t\tque.add(e.dst);\n\t\t\t\t\t\tif (e.dst == t)\n\t\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn prev;\n\t\t}\n\n\t\tvoid push(int s, int t, int inc) {\n\t\t\tflow[s][t] += inc;\n\t\t\tflow[t][s] -= inc;\n\t\t}\n\t}\n\n\tclass Edge {\n\t\tint src;\n\t\tint dst;\n\t\tint weight;\n\n\t\tEdge(int src, int dst, int weight) {\n\t\t\tthis.src = src;\n\t\t\tthis.dst = dst;\n\t\t\tthis.weight = weight;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();// the number of cities\n\t\t\tint m = sc.nextInt();// the number of roads\n\t\t\tint s = sc.nextInt() - 1;\n\t\t\tint t = sc.nextInt() - 1;\n\t\t\tif (n == 0 && m == 0 && s + 1 == 0 && t + 1 == 0)\n\t\t\t\tbreak;\n\t\t\tArrayList<Edge>[] g = new ArrayList[n];\n\t\t\tArrayList<Edge>[] g_rev = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t\tg_rev[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tint[] A = new int[m];\n\t\t\tint[] B = new int[m];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint a = sc.nextInt() - 1;\n\t\t\t\tint b = sc.nextInt() - 1;\n\t\t\t\tA[i] = a;\n\t\t\t\tB[i] = b;\n\t\t\t\tg[a].add(new Edge(a, b, 1));\n\t\t\t\tg_rev[b].add(new Edge(b, a, 1));\n\t\t\t}\n\t\t\tEdmonds_Kerp_MaxFlow mf = new Edmonds_Kerp_MaxFlow(s, t, g);\n\t\t\tlong tmp = mf.MaxFlow();\n\t\t\tboolean[] reachble_from_s = new boolean[n];\n\t\t\tboolean[] reachble_from_t = new boolean[n];\n\t\t\tArrayDeque<Integer> S = new ArrayDeque<>();\n\t\t\tArrayDeque<Integer> T = new ArrayDeque<>();\n\t\t\tS.add(s);\n\t\t\tT.add(t);\n\t\t\twhile (!S.isEmpty()) {\n\t\t\t\tint v = S.poll();\n\t\t\t\tif (reachble_from_s[v]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\treachble_from_s[v] = true;\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tint u = e.dst;\n\t\t\t\t\tif (mf.residue(v, u) == 1)\n\t\t\t\t\t\tS.add(u);\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (!T.isEmpty()) {\n\t\t\t\tint v = T.poll();\n\t\t\t\tif (reachble_from_t[v]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\treachble_from_t[v] = true;\n\t\t\t\tfor (Edge e : g_rev[v]) {\n\t\t\t\t\tint u = e.dst;\n\t\t\t\t\tif (mf.residue(u, v) == 1)\n\t\t\t\t\t\tT.add(u);\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean flag = false;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tif (reachble_from_s[B[i]] && reachble_from_t[A[i]] && mf.residue(A[i], B[i]) == 1) {\n\t\t\t\t\tSystem.out.println((tmp + 1) + \" \" + (i + 1));\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!flag)\n\t\t\t\tSystem.out.println(tmp + \" \" + 0);\n\t\t}\n\t}\n\n\tclass Edmonds_Kerp_MaxFlow {\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tint n;\n\t\tint s;\n\t\tint t;\n\t\tArrayList<Edge>[] g;\n\t\tint[][] flow;\n\t\tint[][] capacity;\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic Edmonds_Kerp_MaxFlow(int s, int t, ArrayList<Edge>[] g) {\n\t\t\tthis.g = g;\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t\tn = g.length;\n\t\t\tflow = new int[n][n];\n\t\t\tcapacity = new int[n][n];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (Edge e : g[i]) {\n\t\t\t\t\tif (e.weight > 0) {\n\t\t\t\t\t\tg[e.dst].add(new Edge(e.dst, e.src, 0));\n\t\t\t\t\t\tcapacity[e.src][e.dst] += e.weight;\n\t\t\t\t\t} else if (e.weight == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tint MaxFlow() {\n\t\t\tint total = 0;\n\t\t\twhile (true) {\n\t\t\t\tint[] prev = bfs();\n\t\t\t\tif (prev[t] == -1)\n\t\t\t\t\treturn total;\n\t\t\t\tint inc = 1 << 30;\n\t\t\t\tfor (int i = t; prev[i] != -1; i = prev[i]) {\n\t\t\t\t\tinc = Math.min(inc, residue(prev[i], i));\n\t\t\t\t}\n\t\t\t\tfor (int i = t; prev[i] != -1; i = prev[i]) {\n\t\t\t\t\tpush(prev[i], i, inc);\n\t\t\t\t}\n\t\t\t\ttotal += inc;\n\t\t\t}\n\t\t}\n\n\t\tint residue(int s, int t) {\n\t\t\treturn capacity[s][t] - flow[s][t];\n\t\t}\n\n\t\tint[] bfs() {\n\t\t\tint[] prev = new int[n];\n\t\t\tArrays.fill(prev, -1);\n\t\t\tArrayDeque<Integer> que = new ArrayDeque<>();\n\t\t\tque.add(s);\n\t\t\tout: while (!que.isEmpty()) {\n\t\t\t\tint v = que.poll();\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tif (prev[e.dst] == -1 && e.dst != s && residue(v, e.dst) > 0) {\n\t\t\t\t\t\tprev[e.dst] = v;\n\t\t\t\t\t\tque.add(e.dst);\n\t\t\t\t\t\tif (e.dst == t)\n\t\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn prev;\n\t\t}\n\n\t\tvoid push(int s, int t, int inc) {\n\t\t\tflow[s][t] += inc;\n\t\t\tflow[t][s] -= inc;\n\t\t}\n\t}\n\n\tclass Edge {\n\t\tint src;\n\t\tint dst;\n\t\tint weight;\n\n\t\tEdge(int src, int dst, int weight) {\n\t\t\tthis.src = src;\n\t\t\tthis.dst = dst;\n\t\t\tthis.weight = weight;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();// the number of cities\n\t\t\tint m = sc.nextInt();// the number of roads\n\t\t\tint s = sc.nextInt() - 1;\n\t\t\tint t = sc.nextInt() - 1;\n\t\t\tif (n == 0 && m == 0 && s + 1 == 0 && t + 1 == 0)\n\t\t\t\tbreak;\n\t\t\tSystem.out.println(n + \" \" + m + \" \" + s + \" \" + t);\n\t\t\tArrayList<Edge>[] g = new ArrayList[n];\n\t\t\tArrayList<Edge>[] g_rev = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t\tg_rev[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tint[] A = new int[m];\n\t\t\tint[] B = new int[m];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint a = sc.nextInt() - 1;\n\t\t\t\tint b = sc.nextInt() - 1;\n\t\t\t\tA[i] = a;\n\t\t\t\tB[i] = b;\n\t\t\t\tg[a].add(new Edge(a, b, 1));\n\t\t\t\tg_rev[b].add(new Edge(b, a, 1));\n\t\t\t}\n\t\t\tPreflow_Relabel pr = new Preflow_Relabel(s, t, g);\n\t\t\tlong tmp = pr.calc();\n\t\t\tboolean[] reachble_from_s = new boolean[n];\n\t\t\tboolean[] reachble_from_t = new boolean[n];\n\t\t\tArrayDeque<Integer> S = new ArrayDeque<>();\n\t\t\tArrayDeque<Integer> T = new ArrayDeque<>();\n\t\t\tS.add(s);\n\t\t\tT.add(t);\n\t\t\twhile (!S.isEmpty()) {\n\t\t\t\tint v = S.poll();\n\t\t\t\tif (reachble_from_s[v]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\treachble_from_s[v] = true;\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tint u = e.dst;\n\t\t\t\t\tif (pr.residue(v, u) > 0)\n\t\t\t\t\t\tS.add(u);\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (!T.isEmpty()) {\n\t\t\t\tint v = T.poll();\n\t\t\t\tif (reachble_from_t[v]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\treachble_from_t[v] = true;\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tint u = e.dst;\n\t\t\t\t\tif (pr.residue(u, v) > 0)\n\t\t\t\t\t\tT.add(u);\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean flag = false;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tif (reachble_from_s[B[i]] && reachble_from_t[A[i]]) {\n\t\t\t\t\tSystem.out.println((tmp + 1) + \" \" + (i + 1));\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!flag)\n\t\t\t\tSystem.out.println(tmp + \" \" + 0);\n\t\t}\n\t}\n\n\tclass Preflow_Relabel {\n\t\tint n;\n\t\tint s;\n\t\tint t;\n\t\tArrayList<Edge>[] g;\n\t\tint[][] flow;\n\t\tint[][] capacity;\n\t\tint[] excess;\n\t\tint[] height;\n\t\tArrayDeque<Integer>[] B;\n\n\t\tvoid global_relabeling() {\n\t\t\tArrayDeque<Integer> que = new ArrayDeque<>();\n\t\t\tboolean[] arrived = new boolean[n];\n\t\t\tque.add(t);\n\t\t\twhile (!que.isEmpty()) {\n\t\t\t\tint v = que.poll();\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tif (residue(e.dst, v) > 0 && (height[v] + 1 < height[e.dst] || !arrived[e.dst])) {\n\t\t\t\t\t\theight[e.dst] = height[v] + 1;\n\t\t\t\t\t\tarrived[e.dst] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic Preflow_Relabel(int s, int t, ArrayList<Edge>[] g) {\n\t\t\tthis.g = g;\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t\tn = g.length;\n\t\t\tflow = new int[n][n];\n\t\t\tcapacity = new int[n][n];\n\t\t\theight = new int[n];\n\t\t\theight[s] = n;\n\t\t\texcess = new int[n];\n\t\t\tB = new ArrayDeque[n + 1];\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tB[i] = new ArrayDeque<>();\n\t\t\t}\n\t\t\tB[height[s]].add(s);\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (Edge e : g[i]) {\n\t\t\t\t\tif (e.weight > 0) {\n\t\t\t\t\t\tg[e.dst].add(new Edge(e.dst, e.src, 0));\n\t\t\t\t\t\tcapacity[e.src][e.dst] += e.weight;\n\t\t\t\t\t} else if (e.weight == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint b = 0;\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tint calc() {\n\t\t\tint count = 0;\n\t\t\tfor (Edge e : g[s]) {\n\t\t\t\texcess[s] += e.weight;\n\t\t\t\tpush(s, e.dst);\n\t\t\t\tB[height[e.dst]].add(e.dst);\n\t\t\t}\n\t\t\tglobal_relabeling();\n\t\t\tfor (b = height[s]; b >= 0;) {\n\t\t\t\tif (B[b].isEmpty()) {\n\t\t\t\t\tb--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint v = B[b].poll();\n\t\t\t\tif (excess[v] == 0 || v == t || v == s || height[v] > n) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tif (height[e.src] == height[e.dst] + 1) {\n\t\t\t\t\t\tif (residue(e.src, e.dst) > 0) {\n\t\t\t\t\t\t\tpush(e.src, e.dst);\n\t\t\t\t\t\t\tif (excess[v] == 0)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (excess[v] > 0) {\n\t\t\t\t\tint min = 1 << 30;\n\t\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\t\tif (residue(e.src, e.dst) > 0) {\n\t\t\t\t\t\t\tmin = Math.min(min, height[e.dst]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\theight[v] = min + 1;\n\t\t\t\t\tif (height[v] < n) {\n\t\t\t\t\t\tB[height[v]].add(v);\n\t\t\t\t\t\tif (height[v] > b)\n\t\t\t\t\t\t\tb = height[v];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (++count % n == 0) {\n\t\t\t\t\tglobal_relabeling();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn excess[t];\n\t\t}\n\n\t\tint residue(int s, int t) {\n\t\t\treturn capacity[s][t] - flow[s][t];\n\t\t}\n\n\t\tvoid push(int u, int v) {\n\t\t\tint delta = Math.min(excess[u], residue(u, v));\n\t\t\tflow[u][v] += delta;\n\t\t\tflow[v][u] -= delta;\n\t\t\texcess[v] += delta;\n\t\t\texcess[u] -= delta;\n\t\t\tif (v != t && v != s && height[v] < n) {\n\t\t\t\tB[height[v]].add(v);\n\t\t\t\tif (b < height[v]) {\n\t\t\t\t\tb = height[v];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tclass Edge {\n\t\tint src;\n\t\tint dst;\n\t\tint weight;\n\n\t\tEdge(int src, int dst, int weight) {\n\t\t\tthis.src = src;\n\t\t\tthis.dst = dst;\n\t\t\tthis.weight = weight;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\t}\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();// the number of cities\n\t\t\tint m = sc.nextInt();// the number of roads\n\t\t\tint s = sc.nextInt() - 1;\n\t\t\tint t = sc.nextInt() - 1;\n\t\t\tif (n == 0 && m == 0 && s == 0 && t == 0)\n\t\t\t\tbreak;\n\t\t\tArrayList<Edge>[] g = new ArrayList[n];\n\t\t\tArrayList<Edge>[] g_rev = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t\tg_rev[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tint[] A = new int[m];\n\t\t\tint[] B = new int[m];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint a = sc.nextInt() - 1;\n\t\t\t\tint b = sc.nextInt() - 1;\n\t\t\t\tA[i] = a;\n\t\t\t\tB[i] = b;\n\t\t\t\tg[a].add(new Edge(a, b, 1));\n\t\t\t\tg_rev[b].add(new Edge(b, a, 1));\n\t\t\t}\n\t\t\tPreflow_Relabel pr = new Preflow_Relabel(s, t, g);\n\t\t\tlong tmp = pr.calc();\n\t\t\tboolean[] reachble_from_s = new boolean[n];\n\t\t\tboolean[] reachble_from_t = new boolean[n];\n\t\t\tArrayDeque<Integer> S = new ArrayDeque<>();\n\t\t\tArrayDeque<Integer> T = new ArrayDeque<>();\n\t\t\tS.add(s);\n\t\t\tT.add(t);\n\t\t\twhile (!S.isEmpty()) {\n\t\t\t\tint v = S.poll();\n\t\t\t\tif (reachble_from_s[v]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\treachble_from_s[v] = true;\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tint u = e.dst;\n\t\t\t\t\tif (pr.residue(v, u) > 0)\n\t\t\t\t\t\tS.add(u);\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (!T.isEmpty()) {\n\t\t\t\tint v = T.poll();\n\t\t\t\tif (reachble_from_t[v]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\treachble_from_t[v] = true;\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tint u = e.dst;\n\t\t\t\t\tif (pr.residue(u, v) > 0)\n\t\t\t\t\t\tT.add(u);\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean flag = false;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tif (reachble_from_s[B[i]] && reachble_from_t[A[i]]) {\n\t\t\t\t\tSystem.out.println((tmp + 1) + \" \" + (i + 1));\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!flag)\n\t\t\t\tSystem.out.println(tmp + \" \" + 0);\n\t\t}\n\t}\n\n\tclass Preflow_Relabel {\n\t\tint n;\n\t\tint s;\n\t\tint t;\n\t\tArrayList<Edge>[] g;\n\t\tint[][] flow;\n\t\tint[][] capacity;\n\t\tint[] excess;\n\t\tint[] height;\n\t\tArrayDeque<Integer>[] B;\n\n\t\tvoid global_relabeling() {\n\t\t\tArrayDeque<Integer> que = new ArrayDeque<>();\n\t\t\tboolean[] arrived = new boolean[n];\n\t\t\tque.add(t);\n\t\t\twhile (!que.isEmpty()) {\n\t\t\t\tint v = que.poll();\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tif (residue(e.dst, v) > 0 && (height[v] + 1 < height[e.dst] || !arrived[e.dst])) {\n\t\t\t\t\t\theight[e.dst] = height[v] + 1;\n\t\t\t\t\t\tarrived[e.dst] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic Preflow_Relabel(int s, int t, ArrayList<Edge>[] g) {\n\t\t\tthis.g = g;\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t\tn = g.length;\n\t\t\tflow = new int[n][n];\n\t\t\tcapacity = new int[n][n];\n\t\t\theight = new int[n];\n\t\t\theight[s] = n;\n\t\t\texcess = new int[n];\n\t\t\tB = new ArrayDeque[n + 1];\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tB[i] = new ArrayDeque<>();\n\t\t\t}\n\t\t\tB[height[s]].add(s);\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (Edge e : g[i]) {\n\t\t\t\t\tif (e.weight > 0) {\n\t\t\t\t\t\tg[e.dst].add(new Edge(e.dst, e.src, 0));\n\t\t\t\t\t\tcapacity[e.src][e.dst] += e.weight;\n\t\t\t\t\t} else if (e.weight == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint b = 0;\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tint calc() {\n\t\t\tint count = 0;\n\t\t\tfor (Edge e : g[s]) {\n\t\t\t\texcess[s] += e.weight;\n\t\t\t\tpush(s, e.dst);\n\t\t\t\tB[height[e.dst]].add(e.dst);\n\t\t\t}\n\t\t\tglobal_relabeling();\n\t\t\tfor (b = height[s]; b >= 0;) {\n\t\t\t\tif (B[b].isEmpty()) {\n\t\t\t\t\tb--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint v = B[b].poll();\n\t\t\t\tif (excess[v] == 0 || v == t || v == s || height[v] > n) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tif (height[e.src] == height[e.dst] + 1) {\n\t\t\t\t\t\tif (residue(e.src, e.dst) > 0) {\n\t\t\t\t\t\t\tpush(e.src, e.dst);\n\t\t\t\t\t\t\tif (excess[v] == 0)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (excess[v] > 0) {\n\t\t\t\t\tint min = 1 << 30;\n\t\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\t\tif (residue(e.src, e.dst) > 0) {\n\t\t\t\t\t\t\tmin = Math.min(min, height[e.dst]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\theight[v] = min + 1;\n\t\t\t\t\tif (height[v] < n) {\n\t\t\t\t\t\tB[height[v]].add(v);\n\t\t\t\t\t\tif (height[v] > b)\n\t\t\t\t\t\t\tb = height[v];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (++count % n == 0) {\n\t\t\t\t\tglobal_relabeling();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn excess[t];\n\t\t}\n\n\t\tint residue(int s, int t) {\n\t\t\treturn capacity[s][t] - flow[s][t];\n\t\t}\n\n\t\tvoid push(int u, int v) {\n\t\t\tint delta = Math.min(excess[u], residue(u, v));\n\t\t\tflow[u][v] += delta;\n\t\t\tflow[v][u] -= delta;\n\t\t\texcess[v] += delta;\n\t\t\texcess[u] -= delta;\n\t\t\tif (v != t && v != s && height[v] < n) {\n\t\t\t\tB[height[v]].add(v);\n\t\t\t\tif (b < height[v]) {\n\t\t\t\t\tb = height[v];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tclass Edge {\n\t\tint src;\n\t\tint dst;\n\t\tint weight;\n\n\t\tEdge(int src, int dst, int weight) {\n\t\t\tthis.src = src;\n\t\t\tthis.dst = dst;\n\t\t\tthis.weight = weight;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();// the number of cities\n\t\t\tint m = sc.nextInt();// the number of roads\n\t\t\tint s = sc.nextInt() - 1;\n\t\t\tint t = sc.nextInt() - 1;\n\t\t\tif (n == 0 && m == 0 && s + 1 == 0 && t + 1 == 0)\n\t\t\t\tbreak;\n\t\t\tArrayList<Edge>[] g = new ArrayList[n];\n\t\t\tArrayList<Edge>[] g_rev = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t\tg_rev[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tint[] A = new int[m];\n\t\t\tint[] B = new int[m];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint a = sc.nextInt() - 1;\n\t\t\t\tint b = sc.nextInt() - 1;\n\t\t\t\tA[i] = a;\n\t\t\t\tB[i] = b;\n\t\t\t\tg[a].add(new Edge(a, b, 1));\n\t\t\t\tg_rev[b].add(new Edge(b, a, 1));\n\t\t\t}\n\t\t\tEdmonds_Kerp_MaxFlow mf = new Edmonds_Kerp_MaxFlow(s, t, g);\n\t\t\tlong tmp = mf.MaxFlow();\n\t\t\tboolean[] reachble_from_s = new boolean[n];\n\t\t\tboolean[] reachble_from_t = new boolean[n];\n\t\t\tArrayDeque<Integer> S = new ArrayDeque<>();\n\t\t\tArrayDeque<Integer> T = new ArrayDeque<>();\n\t\t\tS.add(s);\n\t\t\tT.add(t);\n\t\t\twhile (!S.isEmpty()) {\n\t\t\t\tint v = S.poll();\n\t\t\t\tif (reachble_from_s[v]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\treachble_from_s[v] = true;\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tint u = e.dst;\n\t\t\t\t\tif (mf.residue(v, u) > 0)\n\t\t\t\t\t\tS.add(u);\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (!T.isEmpty()) {\n\t\t\t\tint v = T.poll();\n\t\t\t\tif (reachble_from_t[v]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\treachble_from_t[v] = true;\n\t\t\t\tfor (Edge e : g_rev[v]) {\n\t\t\t\t\tint u = e.dst;\n\t\t\t\t\tif (mf.residue(u, v) > 0)\n\t\t\t\t\t\tT.add(u);\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean flag = false;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tif (reachble_from_s[B[i]] && reachble_from_t[A[i]]) {\n\t\t\t\t\tSystem.out.println((tmp + 1) + \" \" + (i + 1));\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!flag)\n\t\t\t\tSystem.out.println(tmp + \" \" + 0);\n\t\t}\n\t}\n\n\tclass Edmonds_Kerp_MaxFlow {\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tint n;\n\t\tint s;\n\t\tint t;\n\t\tArrayList<Edge>[] g;\n\t\tint[][] flow;\n\t\tint[][] capacity;\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic Edmonds_Kerp_MaxFlow(int s, int t, ArrayList<Edge>[] g) {\n\t\t\tthis.g = g;\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t\tn = g.length;\n\t\t\tflow = new int[n][n];\n\t\t\tcapacity = new int[n][n];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (Edge e : g[i]) {\n\t\t\t\t\tif (e.weight > 0) {\n\t\t\t\t\t\tg[e.dst].add(new Edge(e.dst, e.src, 0));\n\t\t\t\t\t\tcapacity[e.src][e.dst] += e.weight;\n\t\t\t\t\t} else if (e.weight == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tint MaxFlow() {\n\t\t\tint total = 0;\n\t\t\twhile (true) {\n\t\t\t\tint[] prev = bfs();\n\t\t\t\tif (prev[t] == -1)\n\t\t\t\t\treturn total;\n\t\t\t\tint inc = 1 << 30;\n\t\t\t\tfor (int i = t; prev[i] != -1; i = prev[i]) {\n\t\t\t\t\tinc = Math.min(inc, residue(prev[i], i));\n\t\t\t\t}\n\t\t\t\tfor (int i = t; prev[i] != -1; i = prev[i]) {\n\t\t\t\t\tpush(prev[i], i, inc);\n\t\t\t\t}\n\t\t\t\ttotal += inc;\n\t\t\t}\n\t\t}\n\n\t\tint residue(int s, int t) {\n\t\t\treturn capacity[s][t] - flow[s][t];\n\t\t}\n\n\t\tint[] bfs() {\n\t\t\tint[] prev = new int[n];\n\t\t\tArrays.fill(prev, -1);\n\t\t\tArrayDeque<Integer> que = new ArrayDeque<>();\n\t\t\tque.add(s);\n\t\t\tout: while (!que.isEmpty()) {\n\t\t\t\tint v = que.poll();\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tif (prev[e.dst] == -1 && e.dst != s && residue(v, e.dst) > 0) {\n\t\t\t\t\t\tprev[e.dst] = v;\n\t\t\t\t\t\tque.add(e.dst);\n\t\t\t\t\t\tif (e.dst == t)\n\t\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn prev;\n\t\t}\n\n\t\tvoid push(int s, int t, int inc) {\n\t\t\tflow[s][t] += inc;\n\t\t\tflow[t][s] -= inc;\n\t\t}\n\t}\n\n\tclass Edge {\n\t\tint src;\n\t\tint dst;\n\t\tint weight;\n\n\t\tEdge(int src, int dst, int weight) {\n\t\t\tthis.src = src;\n\t\t\tthis.dst = dst;\n\t\t\tthis.weight = weight;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();// the number of cities\n\t\t\tint m = sc.nextInt();// the number of roads\n\t\t\tint s = sc.nextInt() - 1;\n\t\t\tint t = sc.nextInt() - 1;\n\t\t\tif (n == 0 && m == 0 && s + 1 == 0 && t + 1 == 0)\n\t\t\t\tbreak;\n\t\t\tArrayList<Edge>[] g = new ArrayList[n];\n\t\t\tArrayList<Edge>[] g_rev = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t\tg_rev[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tint[] A = new int[m];\n\t\t\tint[] B = new int[m];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint a = sc.nextInt() - 1;\n\t\t\t\tint b = sc.nextInt() - 1;\n\t\t\t\tA[i] = a;\n\t\t\t\tB[i] = b;\n\t\t\t\tg[a].add(new Edge(a, b, 1));\n\t\t\t\tg_rev[b].add(new Edge(b, a, 1));\n\t\t\t}\n\t\t\tEdmonds_Kerp_MaxFlow mf = new Edmonds_Kerp_MaxFlow(s, t, g);\n\t\t\tlong tmp = mf.MaxFlow();\n\t\t\tboolean[] reachble_from_s = new boolean[n];\n\t\t\tboolean[] reachble_from_t = new boolean[n];\n\t\t\tArrayDeque<Integer> S = new ArrayDeque<>();\n\t\t\tArrayDeque<Integer> T = new ArrayDeque<>();\n\t\t\tS.add(s);\n\t\t\tT.add(t);\n\t\t\twhile (!S.isEmpty()) {\n\t\t\t\tint v = S.poll();\n\t\t\t\tif (reachble_from_s[v]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\treachble_from_s[v] = true;\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tint u = e.dst;\n\t\t\t\t\tif (mf.residue(v, u) > 0)\n\t\t\t\t\t\tS.add(u);\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (!T.isEmpty()) {\n\t\t\t\tint v = T.poll();\n\t\t\t\tif (reachble_from_t[v]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\treachble_from_t[v] = true;\n\t\t\t\tfor (Edge e : g_rev[v]) {\n\t\t\t\t\tint u = e.dst;\n\t\t\t\t\tif (mf.residue(u, v) > 0)\n\t\t\t\t\t\tT.add(u);\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean flag = false;\n\t\t\tint count = 0;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tif (reachble_from_s[B[i]] && reachble_from_t[A[i]]) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println((tmp + (count > 0 ? 1 : 0)) + \" \" + count);\n\t\t}\n\t}\n\n\tclass Edmonds_Kerp_MaxFlow {\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tint n;\n\t\tint s;\n\t\tint t;\n\t\tArrayList<Edge>[] g;\n\t\tint[][] flow;\n\t\tint[][] capacity;\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic Edmonds_Kerp_MaxFlow(int s, int t, ArrayList<Edge>[] g) {\n\t\t\tthis.g = g;\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t\tn = g.length;\n\t\t\tflow = new int[n][n];\n\t\t\tcapacity = new int[n][n];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (Edge e : g[i]) {\n\t\t\t\t\tif (e.weight > 0) {\n\t\t\t\t\t\tg[e.dst].add(new Edge(e.dst, e.src, 0));\n\t\t\t\t\t\tcapacity[e.src][e.dst] += e.weight;\n\t\t\t\t\t} else if (e.weight == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tint MaxFlow() {\n\t\t\tint total = 0;\n\t\t\twhile (true) {\n\t\t\t\tint[] prev = bfs();\n\t\t\t\tif (prev[t] == -1)\n\t\t\t\t\treturn total;\n\t\t\t\tint inc = 1 << 30;\n\t\t\t\tfor (int i = t; prev[i] != -1; i = prev[i]) {\n\t\t\t\t\tinc = Math.min(inc, residue(prev[i], i));\n\t\t\t\t}\n\t\t\t\tfor (int i = t; prev[i] != -1; i = prev[i]) {\n\t\t\t\t\tpush(prev[i], i, inc);\n\t\t\t\t}\n\t\t\t\ttotal += inc;\n\t\t\t}\n\t\t}\n\n\t\tint residue(int s, int t) {\n\t\t\treturn capacity[s][t] - flow[s][t];\n\t\t}\n\n\t\tint[] bfs() {\n\t\t\tint[] prev = new int[n];\n\t\t\tArrays.fill(prev, -1);\n\t\t\tArrayDeque<Integer> que = new ArrayDeque<>();\n\t\t\tque.add(s);\n\t\t\tout: while (!que.isEmpty()) {\n\t\t\t\tint v = que.poll();\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tif (prev[e.dst] == -1 && e.dst != s && residue(v, e.dst) > 0) {\n\t\t\t\t\t\tprev[e.dst] = v;\n\t\t\t\t\t\tque.add(e.dst);\n\t\t\t\t\t\tif (e.dst == t)\n\t\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn prev;\n\t\t}\n\n\t\tvoid push(int s, int t, int inc) {\n\t\t\tflow[s][t] += inc;\n\t\t\tflow[t][s] -= inc;\n\t\t}\n\t}\n\n\tclass Edge {\n\t\tint src;\n\t\tint dst;\n\t\tint weight;\n\n\t\tEdge(int src, int dst, int weight) {\n\t\t\tthis.src = src;\n\t\t\tthis.dst = dst;\n\t\t\tthis.weight = weight;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();// the number of cities\n\t\t\tint m = sc.nextInt();// the number of roads\n\t\t\tint s = sc.nextInt() - 1;\n\t\t\tint t = sc.nextInt() - 1;\n\t\t\tif (n == 0 && m == 0 && s + 1 == 0 && t + 1 == 0)\n\t\t\t\tbreak;\n\t\t\tArrayList<Edge>[] g = new ArrayList[n];\n\t\t\tArrayList<Edge>[] g_rev = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t\tg_rev[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tint[] A = new int[m];\n\t\t\tint[] B = new int[m];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint a = sc.nextInt() - 1;\n\t\t\t\tint b = sc.nextInt() - 1;\n\t\t\t\tA[i] = a;\n\t\t\t\tB[i] = b;\n\t\t\t\tg[a].add(new Edge(a, b, 1));\n\t\t\t\tg_rev[b].add(new Edge(b, a, 1));\n\t\t\t}\n\t\t\tEdmonds_Kerp_MaxFlow mf = new Edmonds_Kerp_MaxFlow(s, t, g);\n\t\t\tlong tmp = mf.MaxFlow();\n\t\t\tboolean[] reachble_from_s = new boolean[n];\n\t\t\tboolean[] reachble_from_t = new boolean[n];\n\t\t\tArrayDeque<Integer> S = new ArrayDeque<>();\n\t\t\tArrayDeque<Integer> T = new ArrayDeque<>();\n\t\t\tS.add(s);\n\t\t\tT.add(t);\n\t\t\twhile (!S.isEmpty()) {\n\t\t\t\tint v = S.poll();\n\t\t\t\tif (reachble_from_s[v]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\treachble_from_s[v] = true;\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tint u = e.dst;\n\t\t\t\t\tif (mf.residue(v, u) == 1)\n\t\t\t\t\t\tS.add(u);\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (!T.isEmpty()) {\n\t\t\t\tint v = T.poll();\n\t\t\t\tif (reachble_from_t[v]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\treachble_from_t[v] = true;\n\t\t\t\tfor (Edge e : g_rev[v]) {\n\t\t\t\t\tint u = e.dst;\n\t\t\t\t\tif (mf.residue(u, v) == 1)\n\t\t\t\t\t\tT.add(u);\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean flag = false;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tif (reachble_from_s[B[i]] && reachble_from_t[A[i]] && mf.residue(A[i], B[i]) == 1) {\n\t\t\t\t\tSystem.out.println((tmp + 1) + \" \" + (i + 1));\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!flag)\n\t\t\t\tSystem.out.println(tmp + \" \" + 0);\n\t\t}\n\t}\n\n\tclass Edmonds_Kerp_MaxFlow {\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tint n;\n\t\tint s;\n\t\tint t;\n\t\tArrayList<Edge>[] g;\n\t\tint[][] flow;\n\t\tint[][] capacity;\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic Edmonds_Kerp_MaxFlow(int s, int t, ArrayList<Edge>[] g) {\n\t\t\tthis.g = g;\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t\tn = g.length;\n\t\t\tflow = new int[n][n];\n\t\t\tcapacity = new int[n][n];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (Edge e : g[i]) {\n\t\t\t\t\tif (e.weight > 0) {\n\t\t\t\t\t\tg[e.dst].add(new Edge(e.dst, e.src, 0));\n\t\t\t\t\t\tcapacity[e.src][e.dst] += e.weight;\n\t\t\t\t\t} else if (e.weight == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tint MaxFlow() {\n\t\t\tint total = 0;\n\t\t\twhile (true) {\n\t\t\t\tint[] prev = bfs();\n\t\t\t\tif (prev[t] == -1)\n\t\t\t\t\treturn total;\n\t\t\t\tint inc = 1 << 30;\n\t\t\t\tfor (int i = t; prev[i] != -1; i = prev[i]) {\n\t\t\t\t\tinc = Math.min(inc, residue(prev[i], i));\n\t\t\t\t}\n\t\t\t\tfor (int i = t; prev[i] != -1; i = prev[i]) {\n\t\t\t\t\tpush(prev[i], i, inc);\n\t\t\t\t}\n\t\t\t\ttotal += inc;\n\t\t\t}\n\t\t}\n\n\t\tint residue(int s, int t) {\n\t\t\treturn capacity[s][t] - flow[s][t];\n\t\t}\n\n\t\tint[] bfs() {\n\t\t\tint[] prev = new int[n];\n\t\t\tArrays.fill(prev, -1);\n\t\t\tArrayDeque<Integer> que = new ArrayDeque<>();\n\t\t\tque.add(s);\n\t\t\tout: while (!que.isEmpty()) {\n\t\t\t\tint v = que.poll();\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tif (prev[e.dst] == -1 && e.dst != s && residue(v, e.dst) > 0) {\n\t\t\t\t\t\tprev[e.dst] = v;\n\t\t\t\t\t\tque.add(e.dst);\n\t\t\t\t\t\tif (e.dst == t)\n\t\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn prev;\n\t\t}\n\n\t\tvoid push(int s, int t, int inc) {\n\t\t\tflow[s][t] += inc;\n\t\t\tflow[t][s] -= inc;\n\t\t}\n\t}\n\n\tclass Edge {\n\t\tint src;\n\t\tint dst;\n\t\tint weight;\n\n\t\tEdge(int src, int dst, int weight) {\n\t\t\tthis.src = src;\n\t\t\tthis.dst = dst;\n\t\t\tthis.weight = weight;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();// the number of cities\n\t\t\tint m = sc.nextInt();// the number of roads\n\t\t\tint s = sc.nextInt() - 1;\n\t\t\tint t = sc.nextInt() - 1;\n\t\t\tif (n == 0 && m == 0 && s + 1 == 0 && t + 1 == 0)\n\t\t\t\tbreak;\n\t\t\tArrayList<Edge>[] g = new ArrayList[n];\n\t\t\tArrayList<Edge>[] g_rev = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t\tg_rev[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tint[] A = new int[m];\n\t\t\tint[] B = new int[m];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint a = sc.nextInt() - 1;\n\t\t\t\tint b = sc.nextInt() - 1;\n\t\t\t\tA[i] = a;\n\t\t\t\tB[i] = b;\n\t\t\t\tg[a].add(new Edge(a, b, 1));\n\t\t\t\tg_rev[b].add(new Edge(b, a, 1));\n\t\t\t}\n\t\t\tEdmonds_Kerp_MaxFlow mf = new Edmonds_Kerp_MaxFlow(s, t, g);\n\t\t\tlong tmp = mf.MaxFlow();\n\t\t\tboolean[] reachble_from_s = new boolean[n];\n\t\t\tboolean[] reachble_from_t = new boolean[n];\n\t\t\tArrayDeque<Integer> S = new ArrayDeque<>();\n\t\t\tArrayDeque<Integer> T = new ArrayDeque<>();\n\t\t\tS.add(s);\n\t\t\tT.add(t);\n\t\t\twhile (!S.isEmpty()) {\n\t\t\t\tint v = S.poll();\n\t\t\t\tif (reachble_from_s[v]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\treachble_from_s[v] = true;\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tint u = e.dst;\n\t\t\t\t\tif (mf.residue(v, u) == 1)\n\t\t\t\t\t\tS.add(u);\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (!T.isEmpty()) {\n\t\t\t\tint v = T.poll();\n\t\t\t\tif (reachble_from_t[v]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\treachble_from_t[v] = true;\n\t\t\t\tfor (Edge e : g_rev[v]) {\n\t\t\t\t\tint u = e.dst;\n\t\t\t\t\tif (mf.residue(u, v) == 1)\n\t\t\t\t\t\tT.add(u);\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean flag = false;\n\t\t\tint count = 0;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tif (reachble_from_s[B[i]] && reachble_from_t[A[i]] ) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println((tmp + (count > 0 ? 1 : 0)) + \" \" + count);\n\t\t}\n\t}\n\n\tclass Edmonds_Kerp_MaxFlow {\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tint n;\n\t\tint s;\n\t\tint t;\n\t\tArrayList<Edge>[] g;\n\t\tint[][] flow;\n\t\tint[][] capacity;\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic Edmonds_Kerp_MaxFlow(int s, int t, ArrayList<Edge>[] g) {\n\t\t\tthis.g = g;\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t\tn = g.length;\n\t\t\tflow = new int[n][n];\n\t\t\tcapacity = new int[n][n];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (Edge e : g[i]) {\n\t\t\t\t\tif (e.weight > 0) {\n\t\t\t\t\t\tg[e.dst].add(new Edge(e.dst, e.src, 0));\n\t\t\t\t\t\tcapacity[e.src][e.dst] += e.weight;\n\t\t\t\t\t} else if (e.weight == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tint MaxFlow() {\n\t\t\tint total = 0;\n\t\t\twhile (true) {\n\t\t\t\tint[] prev = bfs();\n\t\t\t\tif (prev[t] == -1)\n\t\t\t\t\treturn total;\n\t\t\t\tint inc = 1 << 30;\n\t\t\t\tfor (int i = t; prev[i] != -1; i = prev[i]) {\n\t\t\t\t\tinc = Math.min(inc, residue(prev[i], i));\n\t\t\t\t}\n\t\t\t\tfor (int i = t; prev[i] != -1; i = prev[i]) {\n\t\t\t\t\tpush(prev[i], i, inc);\n\t\t\t\t}\n\t\t\t\ttotal += inc;\n\t\t\t}\n\t\t}\n\n\t\tint residue(int s, int t) {\n\t\t\treturn capacity[s][t] - flow[s][t];\n\t\t}\n\n\t\tint[] bfs() {\n\t\t\tint[] prev = new int[n];\n\t\t\tArrays.fill(prev, -1);\n\t\t\tArrayDeque<Integer> que = new ArrayDeque<>();\n\t\t\tque.add(s);\n\t\t\tout: while (!que.isEmpty()) {\n\t\t\t\tint v = que.poll();\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tif (prev[e.dst] == -1 && e.dst != s && residue(v, e.dst) > 0) {\n\t\t\t\t\t\tprev[e.dst] = v;\n\t\t\t\t\t\tque.add(e.dst);\n\t\t\t\t\t\tif (e.dst == t)\n\t\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn prev;\n\t\t}\n\n\t\tvoid push(int s, int t, int inc) {\n\t\t\tflow[s][t] += inc;\n\t\t\tflow[t][s] -= inc;\n\t\t}\n\t}\n\n\tclass Edge {\n\t\tint src;\n\t\tint dst;\n\t\tint weight;\n\n\t\tEdge(int src, int dst, int weight) {\n\t\t\tthis.src = src;\n\t\t\tthis.dst = dst;\n\t\t\tthis.weight = weight;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tnew Reverse_a_Road_2().solver();\n\t}\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();// the number of cities\n\t\t\tint m = sc.nextInt();// the number of roads\n\t\t\tint s = sc.nextInt() - 1;\n\t\t\tint t = sc.nextInt() - 1;\n\t\t\tif (n == 0 && m == 0 && s == 0 && t == 0)\n\t\t\t\tbreak;\n\t\t\tArrayList<Edge>[] g = new ArrayList[n];\n\t\t\tArrayList<Edge>[] g_rev = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t\tg_rev[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tint[] A = new int[m];\n\t\t\tint[] B = new int[m];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint a = sc.nextInt() - 1;\n\t\t\t\tint b = sc.nextInt() - 1;\n\t\t\t\tA[i] = a;\n\t\t\t\tB[i] = b;\n\t\t\t\tg[a].add(new Edge(a, b, 1));\n\t\t\t\tg_rev[b].add(new Edge(b, a, 1));\n\t\t\t}\n\t\t\tPreflow_Relabel pr = new Preflow_Relabel(s, t, g);\n\t\t\tlong tmp = pr.calc();\n\t\t\tboolean[] reachble_from_s = new boolean[n];\n\t\t\tboolean[] reachble_from_t = new boolean[n];\n\t\t\tArrayDeque<Integer> S = new ArrayDeque<>();\n\t\t\tArrayDeque<Integer> T = new ArrayDeque<>();\n\t\t\tS.add(s);\n\t\t\tT.add(t);\n\t\t\twhile (!S.isEmpty()) {\n\t\t\t\tint v = S.poll();\n\t\t\t\tif (reachble_from_s[v]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\treachble_from_s[v] = true;\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tint u = e.dst;\n\t\t\t\t\tif (pr.residue(v, u) > 0)\n\t\t\t\t\t\tS.add(u);\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (!T.isEmpty()) {\n\t\t\t\tint v = T.poll();\n\t\t\t\tif (reachble_from_t[v]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\treachble_from_t[v] = true;\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tint u = e.dst;\n\t\t\t\t\tif (pr.residue(u, v) > 0)\n\t\t\t\t\t\tT.add(u);\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean flag = false;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tif (reachble_from_s[B[i]] && reachble_from_t[A[i]]) {\n\t\t\t\t\tSystem.out.println((tmp + 1) + \" \" + (i + 1));\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!flag)\n\t\t\t\tSystem.out.println(tmp + \" \" + 0);\n\t\t}\n\t}\n\n\tclass Preflow_Relabel {\n\t\tint n;\n\t\tint s;\n\t\tint t;\n\t\tArrayList<Edge>[] g;\n\t\tint[][] flow;\n\t\tint[][] capacity;\n\t\tint[] excess;\n\t\tint[] height;\n\t\tArrayDeque<Integer>[] B;\n\n\t\tvoid global_relabeling() {\n\t\t\tArrayDeque<Integer> que = new ArrayDeque<>();\n\t\t\tboolean[] arrived = new boolean[n];\n\t\t\tque.add(t);\n\t\t\twhile (!que.isEmpty()) {\n\t\t\t\tint v = que.poll();\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tif (residue(e.dst, v) > 0 && (height[v] + 1 < height[e.dst] || !arrived[e.dst])) {\n\t\t\t\t\t\theight[e.dst] = height[v] + 1;\n\t\t\t\t\t\tarrived[e.dst] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic Preflow_Relabel(int s, int t, ArrayList<Edge>[] g) {\n\t\t\tthis.g = g;\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t\tn = g.length;\n\t\t\tflow = new int[n][n];\n\t\t\tcapacity = new int[n][n];\n\t\t\theight = new int[n];\n\t\t\theight[s] = n;\n\t\t\texcess = new int[n];\n\t\t\tB = new ArrayDeque[n + 1];\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tB[i] = new ArrayDeque<>();\n\t\t\t}\n\t\t\tB[height[s]].add(s);\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (Edge e : g[i]) {\n\t\t\t\t\tif (e.weight > 0) {\n\t\t\t\t\t\tg[e.dst].add(new Edge(e.dst, e.src, 0));\n\t\t\t\t\t\tcapacity[e.src][e.dst] += e.weight;\n\t\t\t\t\t} else if (e.weight == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint b = 0;\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tint calc() {\n\t\t\tint count = 0;\n\t\t\tfor (Edge e : g[s]) {\n\t\t\t\texcess[s] += e.weight;\n\t\t\t\tpush(s, e.dst);\n\t\t\t\tB[height[e.dst]].add(e.dst);\n\t\t\t}\n\t\t\tglobal_relabeling();\n\t\t\tfor (b = height[s]; b >= 0;) {\n\t\t\t\tif (B[b].isEmpty()) {\n\t\t\t\t\tb--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint v = B[b].poll();\n\t\t\t\tif (excess[v] == 0 || v == t || v == s || height[v] > n) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tif (height[e.src] == height[e.dst] + 1) {\n\t\t\t\t\t\tif (residue(e.src, e.dst) > 0) {\n\t\t\t\t\t\t\tpush(e.src, e.dst);\n\t\t\t\t\t\t\tif (excess[v] == 0)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (excess[v] > 0) {\n\t\t\t\t\tint min = 1 << 30;\n\t\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\t\tif (residue(e.src, e.dst) > 0) {\n\t\t\t\t\t\t\tmin = Math.min(min, height[e.dst]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\theight[v] = min + 1;\n\t\t\t\t\tif (height[v] < n) {\n\t\t\t\t\t\tB[height[v]].add(v);\n\t\t\t\t\t\tif (height[v] > b)\n\t\t\t\t\t\t\tb = height[v];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (++count % n == 0) {\n\t\t\t\t\tglobal_relabeling();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn excess[t];\n\t\t}\n\n\t\tint residue(int s, int t) {\n\t\t\treturn capacity[s][t] - flow[s][t];\n\t\t}\n\n\t\tvoid push(int u, int v) {\n\t\t\tint delta = Math.min(excess[u], residue(u, v));\n\t\t\tflow[u][v] += delta;\n\t\t\tflow[v][u] -= delta;\n\t\t\texcess[v] += delta;\n\t\t\texcess[u] -= delta;\n\t\t\tif (v != t && v != s && height[v] < n) {\n\t\t\t\tB[height[v]].add(v);\n\t\t\t\tif (b < height[v]) {\n\t\t\t\t\tb = height[v];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tclass Edge {\n\t\tint src;\n\t\tint dst;\n\t\tint weight;\n\n\t\tEdge(int src, int dst, int weight) {\n\t\t\tthis.src = src;\n\t\t\tthis.dst = dst;\n\t\t\tthis.weight = weight;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main{\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();// the number of cities\n\t\t\tint m = sc.nextInt();// the number of roads\n\t\t\tint s = sc.nextInt() - 1;\n\t\t\tint t = sc.nextInt() - 1;\n\t\t\tif (n == 0 && m == 0 && s == 0 && t == 0)\n\t\t\t\tbreak;\n\t\t\tArrayList<Edge>[] g = new ArrayList[n];\n\t\t\tArrayList<Edge>[] g_rev = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t\tg_rev[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tint[] A = new int[m];\n\t\t\tint[] B = new int[m];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint a = sc.nextInt() - 1;\n\t\t\t\tint b = sc.nextInt() - 1;\n\t\t\t\tA[i] = a;\n\t\t\t\tB[i] = b;\n\t\t\t\tg[a].add(new Edge(a, b, 1));\n\t\t\t\tg_rev[b].add(new Edge(b, a, 1));\n\t\t\t}\n\t\t\tPreflow_Relabel pr = new Preflow_Relabel(s, t, g);\n\t\t\tlong tmp = pr.calc();\n\t\t\tboolean[] reachble_from_s = new boolean[n];\n\t\t\tboolean[] reachble_from_t = new boolean[n];\n\t\t\tArrayDeque<Integer> S = new ArrayDeque<>();\n\t\t\tArrayDeque<Integer> T = new ArrayDeque<>();\n\t\t\tS.add(s);\n\t\t\tT.add(t);\n\t\t\twhile (!S.isEmpty()) {\n\t\t\t\tint v = S.poll();\n\t\t\t\tif (reachble_from_s[v]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\treachble_from_s[v] = true;\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tint u = e.dst;\n\t\t\t\t\tif (pr.residue(v, u) > 0)\n\t\t\t\t\t\tS.add(u);\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (!T.isEmpty()) {\n\t\t\t\tint v = T.poll();\n\t\t\t\tif (reachble_from_t[v]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\treachble_from_t[v] = true;\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tint u = e.dst;\n\t\t\t\t\tif (pr.residue(u, v) > 0)\n\t\t\t\t\t\tT.add(u);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tif (reachble_from_s[B[i]] && reachble_from_t[A[i]]) {\n\t\t\t\t\tSystem.out.println((tmp + 1) + \" \" + (i + 1));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(tmp + \" \" + 0);\n\t\t}\n\t}\n\n\tclass Preflow_Relabel {\n\t\tint n;\n\t\tint s;\n\t\tint t;\n\t\tArrayList<Edge>[] g;\n\t\tint[][] flow;\n\t\tint[][] capacity;\n\t\tint[] excess;\n\t\tint[] height;\n\t\tArrayDeque<Integer>[] B;\n\n\t\tvoid global_relabeling() {\n\t\t\tArrayDeque<Integer> que = new ArrayDeque<>();\n\t\t\tboolean[] arrived = new boolean[n];\n\t\t\tque.add(t);\n\t\t\twhile (!que.isEmpty()) {\n\t\t\t\tint v = que.poll();\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tif (residue(e.dst, v) > 0 && (height[v] + 1 < height[e.dst] || !arrived[e.dst])) {\n\t\t\t\t\t\theight[e.dst] = height[v] + 1;\n\t\t\t\t\t\tarrived[e.dst] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic Preflow_Relabel(int s, int t, ArrayList<Edge>[] g) {\n\t\t\tthis.g = g;\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t\tn = g.length;\n\t\t\tflow = new int[n][n];\n\t\t\tcapacity = new int[n][n];\n\t\t\theight = new int[n];\n\t\t\theight[s] = n;\n\t\t\texcess = new int[n];\n\t\t\tB = new ArrayDeque[n + 1];\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tB[i] = new ArrayDeque<>();\n\t\t\t}\n\t\t\tB[height[s]].add(s);\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (Edge e : g[i]) {\n\t\t\t\t\tif (e.weight > 0) {\n\t\t\t\t\t\tg[e.dst].add(new Edge(e.dst, e.src, 0));\n\t\t\t\t\t\tcapacity[e.src][e.dst] += e.weight;\n\t\t\t\t\t} else if (e.weight == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint b = 0;\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tint calc() {\n\t\t\tint count = 0;\n\t\t\tfor (Edge e : g[s]) {\n\t\t\t\texcess[s] += e.weight;\n\t\t\t\tpush(s, e.dst);\n\t\t\t\tB[height[e.dst]].add(e.dst);\n\t\t\t}\n\t\t\tglobal_relabeling();\n\t\t\tfor (b = height[s]; b >= 0;) {\n\t\t\t\tif (B[b].isEmpty()) {\n\t\t\t\t\tb--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint v = B[b].poll();\n\t\t\t\tif (excess[v] == 0 || v == t || v == s || height[v] > n) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tif (height[e.src] == height[e.dst] + 1) {\n\t\t\t\t\t\tif (residue(e.src, e.dst) > 0) {\n\t\t\t\t\t\t\tpush(e.src, e.dst);\n\t\t\t\t\t\t\tif (excess[v] == 0)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (excess[v] > 0) {\n\t\t\t\t\tint min = 1 << 30;\n\t\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\t\tif (residue(e.src, e.dst) > 0) {\n\t\t\t\t\t\t\tmin = Math.min(min, height[e.dst]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\theight[v] = min + 1;\n\t\t\t\t\tif (height[v] < n) {\n\t\t\t\t\t\tB[height[v]].add(v);\n\t\t\t\t\t\tif (height[v] > b)\n\t\t\t\t\t\t\tb = height[v];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (++count % n == 0) {\n\t\t\t\t\tglobal_relabeling();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn excess[t];\n\t\t}\n\n\t\tint residue(int s, int t) {\n\t\t\treturn capacity[s][t] - flow[s][t];\n\t\t}\n\n\t\tvoid push(int u, int v) {\n\t\t\tint delta = Math.min(excess[u], residue(u, v));\n\t\t\tflow[u][v] += delta;\n\t\t\tflow[v][u] -= delta;\n\t\t\texcess[v] += delta;\n\t\t\texcess[u] -= delta;\n\t\t\tif (v != t && v != s && height[v] < n) {\n\t\t\t\tB[height[v]].add(v);\n\t\t\t\tif (b < height[v]) {\n\t\t\t\t\tb = height[v];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tclass Edge {\n\t\tint src;\n\t\tint dst;\n\t\tint weight;\n\n\t\tEdge(int src, int dst, int weight) {\n\t\t\tthis.src = src;\n\t\t\tthis.dst = dst;\n\t\t\tthis.weight = weight;\n\t\t}\n\n}"
  },
  {
    "language": "Ruby",
    "code": "module Graphical\n\trequire 'set'\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\n\tdef bfs(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treached = Set[*start.to_a]\n\t\tqueue = []\n\t\tstart.each{|s| queue << s}\n\t\tdist = {}\n\t\tloop.with_index {|_, depth|\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\treturn depth if block_given? && yield(u, depth)\n\t\t\t\tdist[u] = depth\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t}\n\t\treturn dist\n\tend\n\n\tdef dijkstra(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\th = Heap.new\n\t\treached = Set[*start.to_a]\n\t\tstart.each{|s| h.add(s, 0)}\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\t\td = f_dist[u] + l\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_in_connection_of(u){|v, l|\n\t\t\t\t\td = b_dist[u] + l\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\n\tdef a_star(start)\n\t\traise \"a_star need termination condition\" unless block_given?\n\t\th = Heap.new\n\t\treached = Set[start]\n\t\th.add(start, [a_star_heuristic(start), 0])\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, (e, d) = h.del_min\n\t\t\treturn d if yield(u, dist)\n\t\t\tdist[u] = d\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\te = d + a_star_heuristic(v)\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, [e, d])\n\t\t\t\telse\n\t\t\t\t\th.add(v, [e, d])\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\t#make_variations :bidir_dijkstra\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\n\n\tdef each_layer_from(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treturn enum_for(__method__, start) unless block_given?\n\t\treached = Set[*start]\n\t\tcurrent_layer = start\n\n\t\tloop {\n\t\t\tyield current_layer\n\t\t\tnext_layer = []\n\t\t\tcurrent_layer.each{|u|\n\t\t\t\teach_out_connection_of(u){|v|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_layer << v\n\t\t\t\t}\n\t\t\t}\t\n\n\t\t\treturn if next_layer.empty?\n\t\t\tcurrent_layer = next_layer\n\t\t}\n\tend\nend\n\nclass Graph\n\tinclude Graphical\n\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.opposite.keys\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tdef out_edges\n\t\t\t@edges\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\n\t\tdef to\n\t\t\t@opposite.keys[1]\n\t\tend\n\n\t\tdef from\n\t\t\t@opposite.keys[0]\n\t\tend\n\n\t\tdef flow\n\t\t\t@property[:flow] ||= {:to => to, :amount => 0}\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield(e.opposite[u], e.length)\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\n\n\tdef get_path_by_bfs(s, t)\n\t\tpath_edge = {}\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\twhile !queue.empty? \n\t\t\tu = queue.shift\n\t\t\tu.out_edges.each{|e|\n\t\t\t\tv = e.opposite[u]\n\t\t\t\tnext if reached.include?(v)\t\n\t\t\t\treached << v\n\t\t\t\tqueue << v\n\t\t\t\tpath_edge[v] = e\n\n\t\t\t\tif v == t\n\t\t\t\t\tpath = []\n\t\t\t\t\twhile e = path_edge[v]\n\t\t\t\t\t\tpath.unshift e\n\t\t\t\t\t\tv = e.opposite[v]\n\t\t\t\t\tend\n\t\t\t\t\tpath.unshift s\n\t\t\t\t\treturn path\n\t\t\t\tend\n\t\t\t}\n\t\tend\t\n\t\treturn nil\n\tend\n\n\tdef get_augment_path(s, t)\n\t\tpath_edge = {}\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\twhile !queue.empty? \n\t\t\tu = queue.shift\n\t\t\tu.out_edges.each{|e|\n\t\t\t\tv = e.opposite[u]\n\t\t\t\tnext if reached.include?(v)\t\n\t\t\t\tnext if e.flow[:to] == v && e.flow[:amount] == 1\n\t\n\t\t\t\treached << v\n\t\t\t\tqueue << v\n\t\t\t\tpath_edge[v] = e\n\t\n\t\t\t\tif v == t\n\t\t\t\t\tpath = []\n\t\t\t\t\twhile e = path_edge[v]\n\t\t\t\t\t\tpath.unshift e\n\t\t\t\t\t\tv = e.opposite[v]\n\t\t\t\t\tend\n\t\t\t\t\tpath.unshift s\n\t\t\t\t\treturn path\n\t\t\t\tend\n\t\t\t}\n\t\tend\t\n\t\treturn nil\n\tend\n\t\n\tdef send_flow_along(path)\n\t\tu, *edges = path\n\t\tedges.each{|e|\n\t\t\tv = e.opposite[u]\n\t\t\tf = e.flow\n\t\t\tif f[:to] == v\n\t\t\t\tf[:amount] += 1\n\t\t\telsif f[:amount] == 0\n\t\t\t\tf[:to] = v\n\t\t\t\tf[:amount] = 1\n\t\t\telse\n\t\t\t\tf[:amount] -= 1\n\t\t\tend\n\t\t\tu = v\n\t\t}\n\tend\n\n\tdef residual_reachable_from(s)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\twhile !queue.empty? \n\t\t\tu = queue.shift\n\t\t\tu.out_edges.each{|e|\n\t\t\t\tv = e.opposite[u]\n\t\t\t\tnext if reached.include?(v)\t\n\t\t\t\tnext if e.flow[:to] == v && e.flow[:amount] == 1\n\t\n\t\t\t\treached << v\n\t\t\t\tqueue << v\n\t\t\t}\n\n\t\t\tu.in_edges.each{|e|\n\t\t\t\tv = e.opposite[u]\n\t\t\t\tnext if reached.include?(v)\t\n\t\t\t\tnext if e.flow[:to] == u && e.flow[:amount] == 0\n\t\n\t\t\t\treached << v\n\t\t\t\tqueue << v\n\t\t\t}\n\t\tend\t\n\t\treturn reached\n\tend\n\n\tdef residual_reachable_to(t)\n\t\treached = Set[t]\n\t\tqueue = [t]\n\t\twhile !queue.empty? \n\t\t\tv = queue.shift\n\t\t\tv.in_edges.each{|e|\n\t\t\t\tu = e.opposite[v]\n\t\t\t\tnext if reached.include?(u)\t\n\t\t\t\tnext if e.flow[:to] == v && e.flow[:amount] == 1\n\t\n\t\t\t\treached << u\n\t\t\t\tqueue << u\n\t\t\t}\n\t\t\tv.out_edges.each{|e|\n\t\t\t\tu = e.opposite[v]\n\t\t\t\tnext if reached.include?(u)\t\n\t\t\t\tnext if e.flow[:to] == u && e.flow[:amount] == 0\n\t\n\t\t\t\treached << u\n\t\t\t\tqueue << u\n\t\t\t}\n\t\tend\t\n\t\treturn reached\n\tend\nend\n\nclass Digraph < Graph\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_out_edge(e)\n\t\tv.add_in_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.from, e.to\n\t\tu.out_edges.delete(e)\n\t\tv.in_edges.delete(e)\n\t\te\n\tend\n\n\tclass Node < Graph::Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@out_edges = Set.new\n\t\t\t@in_edges = Set.new\n\t\tend\n\n\t\tdef add_out_edge(e)\n\t\t\t@out_edges << e\n\t\tend\n\n\t\tdef del_out_edge(e)\n\t\t\t@out_edges.delete(e)\n\t\tend\n\n\t\tdef add_in_edge(e)\n\t\t\t@in_edges << e\n\t\tend\n\n\t\tdef del_in_edge(e)\n\t\t\t@in_edges.delete(e)\n\t\tend\n\n\t\tattr_reader :in_edges, :out_edges\n\tend\n\n\tclass Edge < Graph::Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@from = u\t\n\t\t\t@to = v\n\t\t\t@property = property\n\t\tend\n\n\t\tdef opposite\n\t\t\t{@from => @to, @to => @from}\n\t\tend\n\n\t\tattr_reader :from, :to\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.out_edges.each{|e|\n\t\t\tyield [e.to, e.length]\n\t\t}\n\tend\n\n\tdef each_in_connection_of(v)\n\t\tv.in_edges.each{|e|\n\t\t\tyield [e.from, e.length]\n\t\t}\n\tend\n\n#----------------------------------------------------------\n\n\tdef get_path_dfs(s, t, reached = Set.new)\n\t\treached << s\t\n\t\ts.outgoings.each{|e|\n\t\t\tv = e.to\n\t\t\tnext if reached.include?(v)\n\t\t\treturn [e] if v == t\n\t\t\t\n\t\t\tpath = get_path_dfs(v, t, reached) \n\t\t\treturn [e] + path if path\n\t\t}\n\t\tnil\n\tend\nend\n\nloop {\n\tn, m, s, t = gets.split.map &:to_i\n\tbreak if n == 0\n\t\n\tg = Digraph.new\n\tnodes = (0..n).map{|i| g.add_node({:name => i})}\n\tedges = []\n\t\n\torig_dest = {}\n\t(1..m).each{|k|\n\t\ti, j = gets.split.map &:to_i\n\t\te = g.add_edge(nodes[i], nodes[j] , {:name => k})\n\t\tedges << e\n\t}\n\n\tc = 0\n\twhile path = g.get_augment_path(nodes[s], nodes[t])\n\t\tg.send_flow_along(path)\n\t\tc += 1\n\tend\n\n\ta = g.residual_reachable_from(nodes[s])\n\tb = g.residual_reachable_to(nodes[t])\n\t\n\tr = 0\n\tedges.each{|e|\n\t\tif a.include?(e.to) && b.include?(e.from)\n\t\t\tr += 1\t\n\t\tend\n\t}\n\n\tputs \"#{r > 0 ? c+1 : c} #{r}\"\n}"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\n\nfrom collections import deque\nclass Dinic:\n    def __init__(self, N):\n        self.N = N\n        self.G = [[] for i in range(N)]\n        self.D = {}\n\n    def add_edge(self, fr, to, cap):\n        forward = [to, cap, None]\n        forward[2] = backward = [fr, 0, forward]\n        self.G[fr].append(forward)\n        self.G[to].append(backward)\n        self.D[fr, to] = forward\n\n    def bfs(self, s, t):\n        self.level = level = [None]*self.N\n        deq = deque([s])\n        level[s] = 0\n        G = self.G\n        while deq:\n            v = deq.popleft()\n            lv = level[v] + 1\n            for w, cap, _ in G[v]:\n                if cap and level[w] is None:\n                    level[w] = lv\n                    deq.append(w)\n        return level[t] is not None\n\n    def dfs(self, v, t, f):\n        if v == t:\n            return f\n        level = self.level\n        for e in self.it[v]:\n            w, cap, rev = e\n            if cap and level[v] < level[w]:\n                d = self.dfs(w, t, min(f, cap))\n                if d:\n                    e[1] -= d\n                    rev[1] += d\n                    return d\n        return 0\n\n    def flow(self, s, t):\n        flow = 0\n        INF = 10**9 + 7\n        G = self.G\n        while self.bfs(s, t):\n            *self.it, = map(iter, self.G)\n            f = INF\n            while f:\n                f = self.dfs(s, t, INF)\n                flow += f\n        return flow\n\ndef solve():\n    N, M, S, T = map(int, readline().split())\n    if N == M == 0:\n        return False\n    S -= 1; T -= 1\n    E = []\n    INF = 10**9\n    dinic = Dinic(N)\n    for i in range(M):\n        a, b = map(int, readline().split()); a -= 1; b -= 1\n        dinic.add_edge(a, b, 1)\n        E.append((a, b))\n    f = dinic.flow(S, T)\n\n    used = [0]*N\n    que = deque([S])\n    used[S] = 1\n    while que:\n        v = que.popleft()\n        for w, cap, _ in dinic.G[v]:\n            if cap == 0 or used[w]:\n                continue\n            used[w] = 1\n            que.append(w)\n    que = deque([T])\n    used[T] = 2\n    while que:\n        v = que.popleft()\n        for w, cap, _ in dinic.G[v]:\n            if cap > 0 or used[w]:\n                continue\n            used[w] = 2\n            que.append(w)\n    cnt = 0\n    for a, b in E:\n        if used[a] == 2 and used[b] == 1:\n            cnt += 1\n    if cnt:\n        write(\"%d %d\\n\" % (f+1, cnt))\n    else:\n        write(\"%d %d\\n\" % (f, 0))\n    return True\nwhile solve():\n    ...\n"
  }
]