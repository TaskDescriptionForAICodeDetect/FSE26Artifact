[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_CITIES 500\n#define MAX_ROADS 1000\n\ntypedef struct {\n    int from, to, capacity;\n} Road;\n\nint N, M, S, T;\nRoad roads[MAX_ROADS];\nint adj[MAX_CITIES][MAX_CITIES];\nint flow[MAX_CITIES][MAX_CITIES];\nint parent[MAX_CITIES];\nbool visited[MAX_CITIES];\n\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\nbool bfs() {\n    memset(visited, 0, sizeof(visited));\n    memset(parent, -1, sizeof(parent));\n    \n    int queue[MAX_CITIES], front = 0, rear = 0;\n    queue[rear++] = S;\n    visited[S] = true;\n    \n    while (front < rear) {\n        int u = queue[front++];\n        \n        for (int v = 0; v < N; v++) {\n            if (!visited[v] && adj[u][v] > flow[u][v]) {\n                queue[rear++] = v;\n                parent[v] = u;\n                visited[v] = true;\n            }\n        }\n    }\n    \n    return visited[T];\n}\n\nint max_flow() {\n    int max_flow = 0;\n    memset(flow, 0, sizeof(flow));\n    \n    while (bfs()) {\n        int path_flow = INT_MAX;\n        \n        for (int v = T; v != S; v = parent[v]) {\n            int u = parent[v];\n            path_flow = min(path_flow, adj[u][v] - flow[u][v]);\n        }\n        \n        for (int v = T; v != S; v = parent[v]) {\n            int u = parent[v];\n            flow[u][v] += path_flow;\n            flow[v][u] -= path_flow;\n        }\n        \n        max_flow += path_flow;\n    }\n    \n    return max_flow;\n}\n\nint solve() {\n    int original_flow = max_flow();\n    int max_roads_reversed = 0;\n    int max_flow_after_reversal = original_flow;\n    \n    for (int i = 0; i < M; i++) {\n        int u = roads[i].from, v = roads[i].to;\n        \n        adj[u][v]--;\n        adj[v][u]++;\n        \n        int new_flow = max_flow();\n        if (new_flow > max_flow_after_reversal) {\n            max_flow_after_reversal = new_flow;\n            max_roads_reversed = 1;\n        } else if (new_flow == max_flow_after_reversal) {\n            max_roads_reversed++;\n        }\n        \n        adj[u][v]++;\n        adj[v][u]--;\n    }\n    \n    return max_roads_reversed;\n}\n\nint main() {\n    scanf(\"%d %d %d %d\", &N, &M, &S, &T);\n    S--; T--;\n    \n    memset(adj, 0, sizeof(adj));\n    \n    for (int i = 0; i < M; i++) {\n        int u, v, capacity;\n        scanf(\"%d %d %d\", &u, &v, &capacity);\n        u--; v--;\n        \n        roads[i].from = u;\n        roads[i].to = v;\n        roads[i].capacity = capacity;\n        \n        adj[u][v] += capacity;\n    }\n    \n    printf(\"%d\\n\", solve());\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:47:26"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAXN 1000\n#define MAXM 10000\n\ntypedef struct {\n    int to, next, rev, cap;\n} Edge;\n\nEdge edge[MAXM * 2];\nint head[MAXN], level[MAXN], queue[MAXN], edge_cnt;\n\nvoid add_edge(int u, int v, int cap) {\n    edge[edge_cnt].to = v;\n    edge[edge_cnt].cap = cap;\n    edge[edge_cnt].next = head[u];\n    edge[edge_cnt].rev = edge_cnt + 1;\n    head[u] = edge_cnt++;\n\n    edge[edge_cnt].to = u;\n    edge[edge_cnt].cap = 0;\n    edge[edge_cnt].next = head[v];\n    edge[edge_cnt].rev = edge_cnt - 1;\n    head[v] = edge_cnt++;\n}\n\nint bfs(int s, int t) {\n    memset(level, -1, sizeof(level));\n    int front = 0, rear = 0;\n    level[s] = 0;\n    queue[rear++] = s;\n    while (front < rear) {\n        int u = queue[front++];\n        for (int i = head[u]; i != -1; i = edge[i].next) {\n            int v = edge[i].to;\n            if (edge[i].cap > 0 && level[v] == -1) {\n                level[v] = level[u] + 1;\n                queue[rear++] = v;\n            }\n        }\n    }\n    return level[t] != -1;\n}\n\nint dfs(int u, int t, int flow) {\n    if (u == t) return flow;\n    for (int i = head[u]; i != -1; i = edge[i].next) {\n        int v = edge[i].to;\n        if (edge[i].cap > 0 && level[v] == level[u] + 1) {\n            int d = dfs(v, t, flow < edge[i].cap ? flow : edge[i].cap);\n            if (d > 0) {\n                edge[i].cap -= d;\n                edge[edge[i].rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t) {\n    int flow = 0;\n    while (bfs(s, t)) {\n        int f;\n        while ((f = dfs(s, t, INT_MAX)) > 0) {\n            flow += f;\n        }\n    }\n    return flow;\n}\n\nint main() {\n    int N, M, S, T;\n    scanf(\"%d %d %d %d\", &N, &M, &S, &T);\n    S--; T--;\n\n    memset(head, -1, sizeof(head));\n    edge_cnt = 0;\n\n    int u[MAXM], v[MAXM];\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d %d\", &u[i], &v[i]);\n        u[i]--; v[i]--;\n        add_edge(u[i], v[i], 1);\n    }\n\n    int original_flow = max_flow(S, T);\n    int new_max = original_flow;\n    int count = 0;\n\n    for (int i = 0; i < M; i++) {\n        memset(head, -1, sizeof(head));\n        edge_cnt = 0;\n        for (int j = 0; j < M; j++) {\n            if (i == j) {\n                add_edge(v[j], u[j], 1);\n            } else {\n                add_edge(u[j], v[j], 1);\n            }\n        }\n        int current_flow = max_flow(S, T);\n        if (current_flow > new_max) {\n            new_max = current_flow;\n            count = 1;\n        } else if (current_flow == new_max) {\n            count++;\n        }\n    }\n\n    if (new_max > original_flow) {\n        printf(\"%d %d\\n\", new_max, count);\n    } else {\n        printf(\"%d %d\\n\", original_flow, 0);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:48:05"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nstruct Edge {\n    int to, rev, cap, flow;\n    Edge(int to, int rev, int cap) : to(to), rev(rev), cap(cap), flow(0) {}\n};\n\nclass MaxFlow {\n    int N;\n    vector<vector<Edge>> G;\n    vector<int> level, iter;\n\n    bool bfs(int s, int t) {\n        fill(level.begin(), level.end(), -1);\n        queue<int> q;\n        level[s] = 0;\n        q.push(s);\n        while (!q.empty()) {\n            int v = q.front(); q.pop();\n            for (auto &e : G[v]) {\n                if (e.cap - e.flow > 0 && level[e.to] == -1) {\n                    level[e.to] = level[v] + 1;\n                    if (e.to == t) return true;\n                    q.push(e.to);\n                }\n            }\n        }\n        return false;\n    }\n\n    int dfs(int v, int t, int f) {\n        if (v == t) return f;\n        for (int &i = iter[v]; i < G[v].size(); ++i) {\n            Edge &e = G[v][i];\n            if (e.cap - e.flow > 0 && level[v] < level[e.to]) {\n                int d = dfs(e.to, t, min(f, e.cap - e.flow));\n                if (d > 0) {\n                    e.flow += d;\n                    G[e.to][e.rev].flow -= d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\npublic:\n    MaxFlow(int N) : N(N), G(N), level(N), iter(N) {}\n\n    void add_edge(int from, int to, int cap) {\n        G[from].emplace_back(to, G[to].size(), cap);\n        G[to].emplace_back(from, G[from].size() - 1, 0);\n    }\n\n    int max_flow(int s, int t) {\n        int flow = 0;\n        while (bfs(s, t)) {\n            fill(iter.begin(), iter.end(), 0);\n            int f;\n            while ((f = dfs(s, t, INT_MAX)) > 0) {\n                flow += f;\n            }\n        }\n        return flow;\n    }\n\n    vector<vector<Edge>> get_graph() {\n        return G;\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int N, M, S, T;\n    cin >> N >> M >> S >> T;\n    S--; T--;\n\n    vector<pair<int, int>> roads(M);\n    MaxFlow mf(N);\n    for (int i = 0; i < M; ++i) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        roads[i] = {u, v};\n        mf.add_edge(u, v, 1);\n    }\n\n    int original_flow = mf.max_flow(S, T);\n    auto G = mf.get_graph();\n\n    vector<int> reachable_S(N, false);\n    queue<int> q;\n    reachable_S[S] = true;\n    q.push(S);\n    while (!q.empty()) {\n        int u = q.front(); q.pop();\n        for (auto &e : G[u]) {\n            if (e.cap - e.flow > 0 && !reachable_S[e.to]) {\n                reachable_S[e.to] = true;\n                q.push(e.to);\n            }\n        }\n    }\n\n    vector<int> reachable_T(N, false);\n    reachable_T[T] = true;\n    q.push(T);\n    while (!q.empty()) {\n        int u = q.front(); q.pop();\n        for (auto &e : G[u]) {\n            if (G[e.to][e.rev].cap - G[e.to][e.rev].flow > 0 && !reachable_T[e.to]) {\n                reachable_T[e.to] = true;\n                q.push(e.to);\n            }\n        }\n    }\n\n    int count = 0;\n    for (int i = 0; i < M; ++i) {\n        int u = roads[i].first;\n        int v = roads[i].second;\n        if (reachable_S[u] && reachable_T[v] && !(reachable_S[v] && reachable_T[u])) {\n            count++;\n        }\n    }\n\n    if (count > 0) {\n        cout << original_flow + 1 << \" \" << count << endl;\n    } else {\n        cout << original_flow << \" \" << 0 << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:50:11"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    static class Edge {\n        int to, rev;\n        boolean original;\n        Edge(int to, int rev, boolean original) {\n            this.to = to;\n            this.rev = rev;\n            this.original = original;\n        }\n    }\n\n    static List<List<Edge>> g;\n    static int[] level, iter;\n\n    static void addEdge(int from, int to) {\n        g.get(from).add(new Edge(to, g.get(to).size(), true));\n        g.get(to).add(new Edge(from, g.get(from).size() - 1, false));\n    }\n\n    static void bfs(int s) {\n        Arrays.fill(level, -1);\n        Queue<Integer> q = new LinkedList<>();\n        level[s] = 0;\n        q.add(s);\n        while (!q.isEmpty()) {\n            int v = q.poll();\n            for (Edge e : g.get(v)) {\n                if (e.original && level[e.to] < 0) {\n                    level[e.to] = level[v] + 1;\n                    q.add(e.to);\n                }\n            }\n        }\n    }\n\n    static int dfs(int v, int t, int f) {\n        if (v == t) return f;\n        for (; iter[v] < g.get(v).size(); iter[v]++) {\n            Edge e = g.get(v).get(iter[v]);\n            if (e.original && level[v] < level[e.to]) {\n                int d = dfs(e.to, t, Math.min(f, 1));\n                if (d > 0) {\n                    e.original = false;\n                    g.get(e.to).get(e.rev).original = true;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    static int maxFlow(int s, int t) {\n        int flow = 0;\n        level = new int[g.size()];\n        iter = new int[g.size()];\n        while (true) {\n            bfs(s);\n            if (level[t] < 0) return flow;\n            Arrays.fill(iter, 0);\n            int f;\n            while ((f = dfs(s, t, Integer.MAX_VALUE)) > 0) {\n                flow += f;\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int M = sc.nextInt();\n        int S = sc.nextInt() - 1;\n        int T = sc.nextInt() - 1;\n\n        g = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            g.add(new ArrayList<>());\n        }\n\n        int[][] edges = new int[M][2];\n        for (int i = 0; i < M; i++) {\n            int a = sc.nextInt() - 1;\n            int b = sc.nextInt() - 1;\n            edges[i][0] = a;\n            edges[i][1] = b;\n            addEdge(a, b);\n        }\n\n        int originalFlow = maxFlow(S, T);\n        int maxNewFlow = originalFlow;\n        int count = 0;\n\n        for (int i = 0; i < M; i++) {\n            int a = edges[i][0];\n            int b = edges[i][1];\n\n            g = new ArrayList<>();\n            for (int j = 0; j < N; j++) {\n                g.add(new ArrayList<>());\n            }\n\n            for (int j = 0; j < M; j++) {\n                if (i == j) {\n                    addEdge(edges[j][1], edges[j][0]);\n                } else {\n                    addEdge(edges[j][0], edges[j][1]);\n                }\n            }\n\n            int newFlow = maxFlow(S, T);\n            if (newFlow > maxNewFlow) {\n                maxNewFlow = newFlow;\n                count = 1;\n            } else if (newFlow == maxNewFlow) {\n                count++;\n            }\n        }\n\n        if (maxNewFlow > originalFlow) {\n            System.out.println(maxNewFlow + \" \" + count);\n        } else {\n            System.out.println(originalFlow + \" \" + 0);\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:50:48"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class JagKingdomTransport {\n    private int n;\n    private List<List<Edge>> graph;\n    private int s, t;\n\n    private class Edge {\n        int to, capacity;\n        Edge reverse;\n\n        Edge(int to, int capacity) {\n            this.to = to;\n            this.capacity = capacity;\n        }\n    }\n\n    public int[] findMaxTrucks() {\n        int maxFlow = fordFulkerson(graph, s, t);\n        int[] result = new int[]{maxFlow, 0};\n\n        for (int u = 0; u < n; u++) {\n            for (Edge edge : graph.get(u)) {\n                if (edge.capacity == 0) {\n                    // Try reversing this road\n                    edge.capacity = 1;\n                    int newFlow = fordFulkerson(graph, s, t);\n                    \n                    if (newFlow > maxFlow) {\n                        maxFlow = newFlow;\n                        result[0] = maxFlow;\n                        result[1]++;\n                    } else {\n                        // Revert back\n                        edge.capacity = 0;\n                    }\n                }\n            }\n        }\n\n        return result;\n    }\n\n    private int fordFulkerson(List<List<Edge>> graph, int source, int sink) {\n        int maxFlow = 0;\n        int[] parent = new int[n];\n\n        while (bfs(graph, source, sink, parent)) {\n            int pathFlow = Integer.MAX_VALUE;\n            for (int v = sink; v != source; v = parent[v]) {\n                Edge edge = findEdge(graph.get(parent[v]), v);\n                pathFlow = Math.min(pathFlow, edge.capacity);\n            }\n\n            for (int v = sink; v != source; v = parent[v]) {\n                Edge edge = findEdge(graph.get(parent[v]), v);\n                edge.capacity -= pathFlow;\n                edge.reverse.capacity += pathFlow;\n            }\n\n            maxFlow += pathFlow;\n        }\n\n        return maxFlow;\n    }\n\n    private boolean bfs(List<List<Edge>> graph, int source, int sink, int[] parent) {\n        boolean[] visited = new boolean[n];\n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(source);\n        visited[source] = true;\n        parent[source] = -1;\n\n        while (!queue.isEmpty()) {\n            int u = queue.poll();\n\n            for (Edge edge : graph.get(u)) {\n                int v = edge.to;\n                if (!visited[v] && edge.capacity > 0) {\n                    queue.offer(v);\n                    parent[v] = u;\n                    visited[v] = true;\n\n                    if (v == sink) {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    private Edge findEdge(List<Edge> edges, int to) {\n        for (Edge edge : edges) {\n            if (edge.to == to) {\n                return edge;\n            }\n        }\n        return null;\n    }\n}",
    "timestamp": "2025-08-05 21:50:58"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <limits>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int findMaxTrucks(int N, int S, int T, vector<vector<int>>& roads) {\n        vector<vector<pair<int, int>>> graph(N + 1);\n        for (auto& road : roads) {\n            graph[road[0]].push_back({road[1], road[2]});\n        }\n        \n        int maxTrucks = networkFlow(N, S, T, graph);\n        \n        int maxTrucksAfterReverse = maxTrucks;\n        vector<int> possibleReverses;\n        \n        for (auto& road : roads) {\n            vector<vector<pair<int, int>>> modifiedGraph = graph;\n            \n            // Remove original road\n            auto& originRoads = modifiedGraph[road[0]];\n            originRoads.erase(\n                remove_if(originRoads.begin(), originRoads.end(), \n                    [&](const pair<int, int>& p) { return p.first == road[1]; }),\n                originRoads.end()\n            );\n            \n            // Add reversed road\n            modifiedGraph[road[1]].push_back({road[0], road[2]});\n            \n            int trucksAfterReverse = networkFlow(N, S, T, modifiedGraph);\n            \n            if (trucksAfterReverse > maxTrucksAfterReverse) {\n                maxTrucksAfterReverse = trucksAfterReverse;\n                possibleReverses = {road[0] * N + road[1]};\n            } else if (trucksAfterReverse == maxTrucksAfterReverse) {\n                possibleReverses.push_back(road[0] * N + road[1]);\n            }\n        }\n        \n        return maxTrucksAfterReverse;\n    }\n    \nprivate:\n    int networkFlow(int N, int source, int sink, vector<vector<pair<int, int>>>& graph) {\n        vector<int> parent(N + 1);\n        int maxFlow = 0;\n        \n        while (bfs(source, sink, graph, parent)) {\n            int pathFlow = numeric_limits<int>::max();\n            \n            for (int v = sink; v != source; v = parent[v]) {\n                int u = parent[v];\n                auto& edges = graph[u];\n                auto it = find_if(edges.begin(), edges.end(), \n                    [&](const pair<int, int>& p) { return p.first == v; });\n                \n                pathFlow = min(pathFlow, it->second);\n            }\n            \n            for (int v = sink; v != source; v = parent[v]) {\n                int u = parent[v];\n                auto& edges = graph[u];\n                auto it = find_if(edges.begin(), edges.end(), \n                    [&](const pair<int, int>& p) { return p.first == v; });\n                \n                it->second -= pathFlow;\n                \n                bool found = false;\n                for (auto& edge : graph[v]) {\n                    if (edge.first == u) {\n                        edge.second += pathFlow;\n                        found = true;\n                        break;\n                    }\n                }\n                \n                if (!found) {\n                    graph[v].push_back({u, pathFlow});\n                }\n            }\n            \n            maxFlow += pathFlow;\n        }\n        \n        return maxFlow;\n    }\n    \n    bool bfs(int source, int sink, vector<vector<pair<int, int>>>& graph, vector<int>& parent) {\n        vector<bool> visited(graph.size(), false);\n        queue<int> q;\n        \n        q.push(source);\n        visited[source] = true;\n        parent[source] = -1;\n        \n        while (!q.empty()) {\n            int u = q.front();\n            q.pop();\n            \n            for (auto& edge : graph[u]) {\n                int v = edge.first;\n                int capacity = edge.second;\n                \n                if (!visited[v] && capacity > 0) {\n                    q.push(v);\n                    parent[v] = u;\n                    visited[v] = true;\n                    \n                    if (v == sink) return true;\n                }\n            }\n        }\n        \n        return false;\n    }\n};\n\nint main() {\n    int N, M, S, T;\n    cin >> N >> M >> S >> T;\n    \n    vector<vector<int>> roads(M, vector<int>(3));\n    for (int i = 0; i < M; i++) {\n        cin >> roads[i][0] >> roads[i][1] >> roads[i][2];\n    }\n    \n    Solution solution;\n    int maxTrucks = solution.findMaxTrucks(N, S, T, roads);\n    \n    cout << maxTrucks << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:51:14"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict, deque\n\ndef bfs(n, capacity, src, sink, parent):\n    visited = [False] * n\n    queue = deque([src])\n    visited[src] = True\n\n    while queue:\n        u = queue.popleft()\n        \n        for v in range(n):\n            if not visited[v] and capacity[u][v] - flow[u][v] > 0:\n                queue.append(v)\n                visited[v] = True\n                parent[v] = u\n                if v == sink:\n                    return True\n    return False\n\ndef edmonds_karp(n, capacity, src, sink):\n    global flow\n    flow = [[0] * n for _ in range(n)]\n    parent = [-1] * n\n    max_flow = 0\n\n    while bfs(n, capacity, src, sink, parent):\n        path_flow = float('Inf')\n        s = sink\n        while s != src:\n            path_flow = min(path_flow, capacity[parent[s]][s] - flow[parent[s]][s])\n            s = parent[s]\n\n        v = sink\n        while v != src:\n            u = parent[v]\n            flow[u][v] += path_flow\n            flow[v][u] -= path_flow\n            v = parent[v]\n\n        max_flow += path_flow\n\n    return max_flow\n\ndef calculate_max_flow_with_reversal(n, roads, source, sink):\n    capacity = [[0] * n for _ in range(n)]\n    \n    for u, v in roads:\n        capacity[u][v] += 1\n\n    initial_max_flow = edmonds_karp(n, capacity, source, sink)\n    reversal_count = 0\n    \n    for u, v in roads:\n        if capacity[u][v] > 0 and flow[u][v] == capacity[u][v]:\n            capacity[u][v] -= 1\n            capacity[v][u] += 1\n\n            new_max_flow = edmonds_karp(n, capacity, source, sink)\n            if new_max_flow > initial_max_flow:\n                reversal_count += 1\n\n            capacity[u][v] += 1\n            capacity[v][u] -= 1\n\n    return initial_max_flow, reversal_count\n\n# Input: N cities, list of roads, source S, target T\ndef jag_kingdom_problem(n, roads, s, t):\n    initial_max_flow, reversals = calculate_max_flow_with_reversal(n, roads, s, t)\n    return initial_max_flow + (1 if reversals else 0), reversals\n\n# Example usage\nn = 4\nroads = [(0, 1), (1, 2), (1, 3), (3, 2)]\ns = 0\nt = 2\nresult = jag_kingdom_problem(n, roads, s, t)\nprint(result)",
    "timestamp": "2025-08-13 07:32:12"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class Transportation {\n    private static class Edge {\n        int from, to;\n\n        Edge(int from, int to) {\n            this.from = from;\n            this.to = to;\n        }\n    }\n\n    private static int findMaxFlow(int n, int[][] capacity, int source, int sink) {\n        int flow = 0;\n        int[] parent = new int[n];\n        int[] maxFlow = new int[n];\n\n        while (true) {\n            Arrays.fill(parent, -1);\n            Arrays.fill(maxFlow, 0);\n            maxFlow[source] = Integer.MAX_VALUE;\n\n            Queue<Integer> queue = new LinkedList<>();\n            queue.add(source);\n\n            while (!queue.isEmpty()) {\n                int current = queue.poll();\n                for (int next = 0; next < n; next++) {\n                    if (parent[next] == -1 && capacity[current][next] > 0) {\n                        parent[next] = current;\n                        maxFlow[next] = Math.min(maxFlow[current], capacity[current][next]);\n                        if (next == sink) {\n                            break;\n                        }\n                        queue.add(next);\n                    }\n                }\n            }\n\n            if (parent[sink] == -1) {\n                break;\n            }\n\n            flow += maxFlow[sink];\n            int curNode = sink;\n            while (curNode != source) {\n                int prevNode = parent[curNode];\n                capacity[prevNode][curNode] -= maxFlow[sink];\n                capacity[curNode][prevNode] += maxFlow[sink];\n                curNode = prevNode;\n            }\n        }\n\n        return flow;\n    }\n\n    public static int[] maxTrucks(int n, int s, int t, List<Edge> edges) {\n        int[][] capacity = new int[n][n];\n        for (Edge edge : edges) {\n            capacity[edge.from][edge.to]++;\n        }\n\n        int maxFlow = findMaxFlow(n, capacity, s, t);\n        int maxFlowAfterReverse = maxFlow;\n        int reversibleRoads = 0;\n\n        for (Edge edge : edges) {\n            if (capacity[edge.from][edge.to] > 0) {\n                capacity[edge.from][edge.to]--;\n                capacity[edge.to][edge.from]++;\n                \n                int currentFlow = findMaxFlow(n, capacity, s, t);\n                if (currentFlow > maxFlowAfterReverse) {\n                    maxFlowAfterReverse = currentFlow;\n                    reversibleRoads = 1;\n                } else if (currentFlow == maxFlowAfterReverse) {\n                    reversibleRoads++;\n                }\n                \n                capacity[edge.from][edge.to]++;\n                capacity[edge.to][edge.from]--;\n            }\n        }\n\n        return new int[] { maxFlowAfterReverse, reversibleRoads };\n    }\n\n    public static void main(String[] args) {\n        int n = 4; \n        int s = 0, t = 3;\n        List<Edge> edges = new ArrayList<>();\n        edges.add(new Edge(0, 1));\n        edges.add(new Edge(1, 2));\n        edges.add(new Edge(2, 3));\n        edges.add(new Edge(1, 3));\n\n        int[] result = maxTrucks(n, s, t, edges);\n        System.out.println(\"Max trucks: \" + result[0] + \", Reversible roads: \" + result[1]);\n    }\n}",
    "timestamp": "2025-08-13 07:32:25"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX 1000\n\ntypedef struct {\n    int to, next;\n} Edge;\n\nEdge edges[MAX * 2];\nint head[MAX], dis[MAX], visited[MAX], in_queue[MAX];\nint n, m, edge_count;\n\nvoid init_graph() {\n    edge_count = 0;\n    memset(head, -1, sizeof(head));\n}\n\nvoid add_edge(int u, int v) {\n    edges[edge_count].to = v;\n    edges[edge_count].next = head[u];\n    head[u] = edge_count++;\n}\n\nint bfs(int s, int t) {\n    memset(visited, 0, sizeof(visited));\n    int queue[MAX], front = 0, back = 0;\n    queue[back++] = s;\n    visited[s] = 1;\n    dis[s] = 0;\n\n    while (front < back) {\n        int u = queue[front++];\n        for (int i = head[u]; i != -1; i = edges[i].next) {\n            int v = edges[i].to;\n            if (!visited[v]) {\n                visited[v] = 1;\n                dis[v] = dis[u] + 1;\n                queue[back++] = v;\n                if (v == t) return 1;\n            }\n        }\n    }\n    return 0;\n}\n\nint dfs(int u, int t, int min_flow) {\n    if (u == t) return min_flow;\n\n    for (int i = head[u]; i != -1; i = edges[i].next) {\n        int v = edges[i].to;\n        if (dis[v] == dis[u] + 1) {\n            int flow = dfs(v, t, min_flow);\n            if (flow > 0) return flow;\n        }\n    }\n    return 0;\n}\n\nint edmonds_karp(int s, int t) {\n    int max_flow = 0;\n    while (bfs(s, t)) {\n        memset(in_queue, 0, sizeof(in_queue));\n        int flow;\n        while ((flow = dfs(s, t, INT_MAX)) > 0) {\n            max_flow += flow;\n        }\n    }\n    return max_flow;\n}\n\nint reverse_and_calc(int u, int v, int s, int t) {\n    // Try reverse edge u -> v and calculate new max flow\n    head[u] = edges[head[u]].next; // Remove forward edge\n    add_edge(v, u); // Add reversed edge\n    int new_max_flow = edmonds_karp(s, t);\n    head[v] = edges[head[v]].next; // Remove reversed edge\n    add_edge(u, v); // Restore original edge\n\n    return new_max_flow;\n}\n\nint main() {\n    // Read input\n    int s, t;\n    scanf(\"%d%d%d\", &n, &m, &s, &t);\n    init_graph();\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        add_edge(u, v);\n    }\n\n    int original_max_flow = edmonds_karp(s, t);\n    int max_flow = original_max_flow;\n    int reverse_count = 0;\n\n    for (int u = 0; u < n; u++) {\n        for (int i = head[u]; i != -1; i = edges[i].next) {\n            int v = edges[i].to;\n            int new_flow = reverse_and_calc(u, v, s, t);\n            if (new_flow > max_flow) {\n                max_flow = new_flow;\n                reverse_count = 1;\n            } else if (new_flow == max_flow) {\n                reverse_count++;\n            }\n        }\n    }\n\n    printf(\"%d %d\\n\", max_flow, reverse_count);\n    return 0;\n}",
    "timestamp": "2025-08-13 07:32:44"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict, deque\n\ndef solve_transportation_problem(N, roads, S, T):\n    def max_flow_with_reversed_road(graph, source, sink):\n        def bfs(graph, source, sink):\n            parent = [-1] * (N + 1)\n            visited = [False] * (N + 1)\n            queue = deque([source])\n            visited[source] = True\n\n            while queue:\n                curr = queue.popleft()\n                for neighbor, capacity in graph[curr].items():\n                    if not visited[neighbor] and capacity > 0:\n                        queue.append(neighbor)\n                        visited[neighbor] = True\n                        parent[neighbor] = curr\n\n            return parent if visited[sink] else None\n\n        def ford_fulkerson(graph, source, sink):\n            max_flow = 0\n            while True:\n                path = bfs(graph, source, sink)\n                if not path:\n                    break\n\n                flow = float('inf')\n                curr = sink\n                while curr != source:\n                    parent_node = path[curr]\n                    flow = min(flow, graph[parent_node][curr])\n                    curr = parent_node\n\n                max_flow += flow\n                curr = sink\n                while curr != source:\n                    parent_node = path[curr]\n                    graph[parent_node][curr] -= flow\n                    graph[curr][parent_node] += flow\n                    curr = parent_node\n\n            return max_flow\n\n        graph = defaultdict(lambda: defaultdict(int))\n        for u, v, c in roads:\n            graph[u][v] += c\n\n        return ford_fulkerson(graph, source, sink)\n\n    max_trucks = 0\n    optimal_reversal = []\n\n    for road_index, (u, v, c) in enumerate(roads):\n        # Create a copy of roads and reverse the current road\n        reversed_roads = roads.copy()\n        reversed_roads[road_index] = (v, u, c)\n\n        # Build graph and calculate max flow with reversed road\n        current_flow = max_flow_with_reversed_road(defaultdict(lambda: defaultdict(int)), S, T)\n\n        if current_flow > max_trucks:\n            max_trucks = current_flow\n            optimal_reversal = [road_index]\n        elif current_flow == max_trucks:\n            optimal_reversal.append(road_index)\n\n    return max_trucks, len(optimal_reversal)\n\n# Example usage\nN, S, T = map(int, input().split())\nroads = []\nfor _ in range(M := int(input())):\n    u, v, c = map(int, input().split())\n    roads.append((u, v, c))\n\nresult = solve_transportation_problem(N, roads, S, T)\nprint(result[0], result[1])",
    "timestamp": "2025-08-13 07:33:05"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    N, M, S, T = map(int, sys.stdin.readline().split())\n    S -= 1\n    T -= 1\n    adj = [[] for _ in range(N)]\n    adj_rev = [[] for _ in range(N)]\n    edges = []\n    for _ in range(M):\n        u, v = map(int, sys.stdin.readline().split())\n        u -= 1\n        v -= 1\n        adj[u].append(v)\n        adj_rev[v].append(u)\n        edges.append((u, v))\n    \n    # BFS for levels from S\n    level = [-1] * N\n    q = deque()\n    level[S] = 0\n    q.append(S)\n    while q:\n        u = q.popleft()\n        for v in adj[u]:\n            if level[v] == -1:\n                level[v] = level[u] + 1\n                q.append(v)\n    \n    if level[T] == -1:\n        print(0)\n        return\n    \n    # BFS for levels from T in reversed graph\n    level_rev = [-1] * N\n    q = deque()\n    level_rev[T] = 0\n    q.append(T)\n    while q:\n        u = q.popleft()\n        for v in adj_rev[u]:\n            if level_rev[v] == -1:\n                level_rev[v] = level_rev[u] + 1\n                q.append(v)\n    \n    original_flow = 0\n    # Find original max flow (number of edge-disjoint paths)\n    # Using BFS and blocking flow approach (Ford-Fulkerson with BFS)\n    def max_flow(s, t, adj):\n        flow = 0\n        while True:\n            parent = [-1] * N\n            q = deque()\n            q.append(s)\n            parent[s] = s\n            found = False\n            while q and not found:\n                u = q.popleft()\n                for v in adj[u]:\n                    if parent[v] == -1:\n                        parent[v] = u\n                        if v == t:\n                            found = True\n                            break\n                        q.append(v)\n            if not found:\n                break\n            # Augment path\n            flow += 1\n            v = t\n            while v != s:\n                u = parent[v]\n                adj[u].remove(v)\n                adj[v].append(u)\n                v = u\n        return flow\n    \n    original_adj = [lst.copy() for lst in adj]\n    original_flow = max_flow(S, T, original_adj)\n    \n    # Now check for each edge (u, v) if level[u] + level_rev[v] + 1 == level[T]\n    # and reversing it would create a new path of length level[T]\n    count = 0\n    for u, v in edges:\n        if level[u] != -1 and level_rev[v] != -1 and level[u] + level_rev[v] + 1 == level[T]:\n            # Check if reversing this edge can increase the flow\n            # The new edge is (v, u)\n            # We need to see if there's a path S -> ... -> v -> u -> ... -> T\n            # So level[v] + 1 + level_rev[u] == level[T]?\n            if level[v] != -1 and level_rev[u] != -1 and level[v] + level_rev[u] + 1 == level[T]:\n                count += 1\n    \n    if count > 0:\n        print(original_flow + 1, count)\n    else:\n        print(original_flow)\n\nsolve()",
    "timestamp": "2025-08-13 07:33:38"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\nconst int MAXN = 500;\nconst int INF = 1e9;\n\nstruct Edge {\n    int to, capacity, flow, rev;\n};\n\nvector<Edge> adj[MAXN];\nint level[MAXN], start[MAXN];\nint n, s, t;\n\nvoid addEdge(int u, int v, int cap) {\n    Edge a = {v, cap, 0, adj[v].size()};\n    Edge b = {u, 0, 0, adj[u].size()};\n    adj[u].push_back(a);\n    adj[v].push_back(b);\n}\n\nbool bfs() {\n    fill(level, level + n, -1);\n    level[s] = 0;\n    queue<int> q;\n    q.push(s);\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for (auto &e : adj[u]) {\n            if (level[e.to] < 0 && e.flow < e.capacity) {\n                level[e.to] = level[u] + 1;\n                q.push(e.to);\n            }\n        }\n    }\n    return level[t] >= 0;\n}\n\nint dfs(int u, int flow) {\n    if (u == t) return flow;\n    for (; start[u] < adj[u].size(); ++start[u]) {\n        Edge &e = adj[u][start[u]];\n        if (level[e.to] == level[u] + 1 && e.flow < e.capacity) {\n            int curr_flow = min(flow, e.capacity - e.flow);\n            int temp_flow = dfs(e.to, curr_flow);\n            if (temp_flow > 0) {\n                e.flow += temp_flow;\n                adj[e.to][e.rev].flow -= temp_flow;\n                return temp_flow;\n            }\n        }\n    }\n    return 0;\n}\n\nint dinic() {\n    int total_flow = 0;\n    while (bfs()) {\n        fill(start, start + n, 0);\n        while (int flow = dfs(s, INF)) {\n            total_flow += flow;\n        }\n    }\n    return total_flow;\n}\n\nint main() {\n    int m;\n    cin >> n >> m >> s >> t;\n    vector<pair<int, int>> edges;\n    for (int i = 0; i < m; ++i) {\n        int u, v;\n        cin >> u >> v;\n        addEdge(u, v, 1);\n        edges.push_back({u, v});\n    }\n\n    int original_max_flow = dinic();\n    int max_new_flow = original_max_flow;\n    int count_ways = 0;\n\n    for (int i = 0; i < m; ++i) {\n        int u = edges[i].first;\n        int v = edges[i].second;\n\n        // Temporarily reverse the edge\n        adj[u].clear();\n        adj[v].clear();\n        for (pair<int, int> &e : edges) {\n            if (e == make_pair(u, v)) {\n                addEdge(v, u, 1); // Reversed edge\n            } else {\n                addEdge(e.first, e.second, 1);\n            }\n        }\n\n        int new_flow = dinic();\n\n        if (new_flow > max_new_flow) {\n            max_new_flow = new_flow;\n            count_ways = 1;\n        } else if (new_flow == max_new_flow) {\n            count_ways++;\n        }\n\n        // Reset flow for next iteration\n        for (int j = 0; j < n; ++j) adj[j].clear();\n        for (pair<int, int> &e : edges) {\n            addEdge(e.first, e.second, 1);\n        }\n    }\n\n    cout << max_new_flow << \" \" << (max_new_flow > original_max_flow ? count_ways : 0) << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:39:37"
  }
]