[
  {
    "language": "Crystal",
    "code": "B=1000000000000000003_i64\nP=1000000000000000031_i64\ndef mul(x,y,m)\n\tz=0_i64\n\twhile y>0\n\t\t(z+=x;z>=m&&(z-=m)) if y%2>0\n\t\tx+=x;x>=m&&(x-=m)\n\t\ty/=2\n\tend\n\tz\nend\ndef pow(x,y,m)\n\tz=1_i64\n\twhile y>0\n\t\tz=mul(z,x,m) if y%2>0\n\t\tx=mul(x,x,m)\n\t\ty/=2\n\tend\n\tz\nend\nBrev=pow(B,P-2,P)\nn=gets.not_nil!.to_i\ns=gets.not_nil!.chomp\no=Array(Int64).new(n+1,0_i64)\np=Array(Int64).new(n+1,0_i64)\np[0]=1_i64\n1.upto(n){|i|\n\tp[i]=p[i-1];o[i]=o[i-1]\n\tif s[i-1]=='>'\n\t\tp[i]=mul(p[i],B,P)\n\telsif s[i-1]=='<'\n\t\tp[i]=mul(p[i],Brev,P)\n\telsif s[i-1]=='+'\n\t\to[i]=(o[i]+p[i])%P\n\telsif s[i-1]=='-'\n\t\to[i]=(o[i]-p[i]+P)%P\n\tend\n}\nm=Hash(Int64,Int32).new(0)\nr=0_i64\nn.downto(1){|i|\n\tm[o[i]]+=1\n\tr+=m[(mul(o[n],p[i-1],P)+o[i-1])%P]\n}\nputs r"
  },
  {
    "language": "Crystal",
    "code": "B=1000000000000000003_i64\nP=1000000000000000031_i64\ndef mul(x,y,m)\n\tz=0_i64\n\twhile y>0\n\t\t(z+=x;z>=m&&(z-=m)) if y%2>0\n\t\tx+=x;x>=m&&(x-=m)\n\t\ty/=2\n\tend\n\tz\nend\ndef pow(x,y,m)\n\tz=1_i64\n\twhile y>0\n\t\tz=mul(z,x,m) if y%2>0\n\t\tx=mul(x,x,m)\n\t\ty/=2\n\tend\n\tz\nend\nBrev=pow(B,P-2,P)\nn=gets.not_nil!.to_i\ns=gets.not_nil!.chomp\no=Array(Int64).new(n+1,0)\np=Array(Int64).new(n+1,0)\np[0]=1\n1.upto(n){|i|\n\tp[i]=p[i-1];o[i]=o[i-1]\n\tif s[i-1]=='>'\n\t\tp[i]=mul(p[i],B,P)\n\telsif s[i-1]=='<'\n\t\tp[i]=mul(p[i],Brev,P)\n\telsif s[i-1]=='+'\n\t\to[i]=(o[i]+p[i])%P\n\telsif s[i-1]=='-'\n\t\to[i]=(o[i]-p[i]+P)%P\n\tend\n}\nm=Hash(Int64,Int32).new(0)\nr=0_i64\nn.downto(1){|i|\n\tm[o[i]]+=1\n\tr+=m[(mul(o[n],p[i-1],P)+o[i-1])%P]\n}\nputs r"
  },
  {
    "language": "C++",
    "code": "// This amazing code is by Eric Sunli Chen.\n#include<bits/stdc++.h>\nusing namespace std;\ntemplate<typename T> bool get_int(T &x)\n{\n\tchar t=getchar();\n\tbool neg=false;\n\tx=0;\n\tfor(; (t>'9'||t<'0')&&t!='-'&&t!=EOF; t=getchar());\n\tif(t=='-')neg=true,t=getchar();if(t==EOF)return false;\n\tfor(; t<='9'&&t>='0'; t=getchar())x=x*10+t-'0';\n\tif(neg)x=-x;return true;\n}\ntemplate<typename T> void print_int(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tshort a[20]= {},sz=0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1; i>=0; i--)putchar('0'+a[i]);\n}\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\n#define get1(a) get_int(a)\n#define get2(a,b) (get1(a)&&get1(b))\n#define get3(a,b,c) (get1(a)&&get2(b,c))\n#define printendl(a) print_int(a),puts(\"\")\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef pair<int,int> pii;\nconst int inf=0x3f3f3f3f;\nconst LL Linf=1ll<<61;\nconst double pi=acos(-1.0);\n\nconst int mod=998244353;\nint power(int x,int y,const int&mod=::mod)\n{\n\tint ret=1;\n\twhile(y)\n\t{\n\t\tif(y&1)ret=1ll*ret*x%mod;\n\t\tx=1ll*x*x%mod;\n\t\ty>>=1;\n\t}\n\treturn ret;\n}\nconst int base=23333333,rbase=power(base,mod-2);\n\nchar s[300111];\n\nint n;\npii tran[300111];\npii merge(const pii&a,const pii&b){return mp(1ll*a.ff*b.ff%mod,(1ll*a.ff*b.ss+a.ss)%mod);}\n\nint main()\n{\n\tscanf(\"%d%s\",&n,s+1);\n\t\n\ttran[n+1]=mp(1,0);\n\tint cur=0;\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tif(s[i]=='+')\n\t\t{\n\t\t\ttran[i]=merge(tran[i+1],mp(1,1));\n\t\t\tcur--;if(cur<0)cur+=mod;\n\t\t}\n\t\telse if(s[i]=='-')\n\t\t{\n\t\t\ttran[i]=merge(tran[i+1],mp(1,mod-1));\n\t\t\tcur++;if(cur>=mod)cur-=mod;\n\t\t}\n\t\telse if(s[i]=='<')\n\t\t{\n\t\t\ttran[i]=merge(tran[i+1],mp(base,0));\n\t\t\tcur=1ll*cur*rbase%mod;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttran[i]=merge(tran[i+1],mp(rbase,0));\n\t\t\tcur=1ll*cur*base%mod;\n\t\t}\n\t}\n\t\n\tLL ans=0;\n\tmap<int,int> cnt;\n\tcnt[0]++;\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tans+=cnt[(1ll*cur*tran[i].ff+tran[i].ss)%mod];\n\t\tcnt[tran[i].ss]++;\n\t}\n\tprintendl(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define N 250052\n#define o 226324926\n#define p 1000000007\n#define q 19260817\ninline int mod(int x){return x<p?x:x-p;}\nchar s[N];int A[q],B[N],C[N],D[N],T,a[N],b[N],i,j,n;long long z;\ninline int Hash(int x)\n{\n    int y=x%q;\n    for(j=A[y];j;j=B[j])if(C[j]==x)return j;\n    return 0;\n}\ninline void add(int x)\n{\n    int y=Hash(x);\n    !y?B[++T]=A[y=x%q],C[A[y]=T]=x,D[T]=1:D[y]++;\n}\nint main()\n{\n    scanf(\"%d%s\",&n,s+1);\n    for(*a=i=1;i<=n;i++)\n    if(s[i]=='+')a[i]=a[i-1],b[i]=mod(a[i-1]+b[i-1]);\n    else if(s[i]=='-')a[i]=a[i-1],b[i]=mod(p+b[i-1]-a[i-1]);\n    else if(s[i]=='>')a[i]=(long long)a[i-1]*N%p,b[i]=b[i-1];\n    else a[i]=(long long)a[i-1]*o%p,b[i]=b[i-1];\n    for(i=1;i<=n;i++)add(((long long)b[n]*a[i-1]+b[i-1])%p),z+=D[Hash(b[i])];\n    return 0*printf(\"%lld\\n\",z);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\n#include <deque>\n#include <queue>\n#include <vector>\n#include <map>\nusing namespace std;\nmap<unsigned long long,int>M;\nconst unsigned long long key=1e9+7,N=260000;\nunsigned long long invkey;\nchar ch[N+10];\nint n;\nunsigned long long quick(unsigned long long k1,unsigned long long k2){\n\tunsigned long long k3=1;\n\twhile (k2){\n\t\tif (k2&1) k3*=k1;\n\t\tk1*=k1; k2>>=1;\n\t}\n\treturn k3;\n}\nunsigned long long mul=0,add=0;\nunsigned long long getall(){\n\tunsigned long long k1=1,ans=0;\n\tfor (int i=1;i<=n;i++)\n\t\tif (ch[i]=='+') ans+=k1;\n\t\telse if (ch[i]=='-') ans-=k1;\n\t\telse if (ch[i]=='>') k1*=key;\n\t\telse k1*=invkey;\n\treturn ans;\n}\nunsigned long long getb(unsigned long long ke,unsigned long long a,unsigned long long b){\n\treturn (ke-b)*quick(a,(1ull<<63)-1);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",ch+1);\n\tinvkey=quick(key,(1ull<<63)-1);\n\tunsigned long long ke=getall();\n\tunsigned long long a=1,b=0;\n\tlong long ans=0;\n\tfor (int i=n;i;i--){\n\t\tans+=M[getb(ke,a,b)];\n\t\tM[getb(0,a,b)]++;\n\t\tif (ch[i]=='+') b++;\n\t\telse if (ch[i]=='-') b--;\n\t\telse if (ch[i]=='>') b*=key,a*=key;\n\t\telse if (ch[i]=='<') b*=invkey,a*=invkey;\n\t}\n\tans+=M[getb(ke,a,b)];\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll MOD = 998244353;\nconst int MX = 250005;\nconst ll R = 1231231;\nconst ll IR = 981323583;\n\nll qpow(ll x, ll t)\n{\n\tll ans = 1;\n\twhile(t)\n\t{\n\t\tif(t & 1) ans = ans*x % MOD;\n\t\tx = x*x % MOD;\n\t\tt >>= 1;\n\t}\n\treturn ans;\n}\n\nll inv(ll x)\n{\n\treturn qpow(x, MOD-2);\n}\n\nint n;\nchar str[MX];\n\nvoid input()\n{\n\tscanf(\"%d\", &n);\n\tscanf(\"%s\", str+1);\n}\n\nll con[MX], sum[MX];\nmap<ll, int> hav;\n\nvoid work()\n{\n\tll p = 1;\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tif(str[i] == '+') con[i] = p;\n\t\telse if(str[i] == '-') con[i] = (MOD-p) % MOD;\n\t\telse if(str[i] == '>') p = p*R % MOD;\n\t\telse p = p*IR % MOD;\n\t\tsum[i] = (sum[i-1] + con[i]) % MOD;\n\t\thav[sum[i]]++;\n\t}\n\tll ans = 0, t = 1;\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tans += hav[(sum[n]*t+sum[i-1]) % MOD];\n\t\tif(str[i] == '>') t = t*R % MOD;\n\t\telse if(str[i] == '<') t = t*IR % MOD;\n\t\thav[sum[i]]--;\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main()\n{\n\tinput();\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//khodaya khodet komak kon\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define all(x) x.begin(), x.end()\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#define int long long\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int N = 6;\nconst ll MOD = 1000000000 + 7;\nconst ll INF = 1000000010;\nconst ll LOG = 25;\nconst int H = 786433;\n\nint a[2 * N], n, M, S, inv, Hash;\nmap<int, int> cnt;\nstring s;\n\nint mul(int a, int b){\n\treturn (a * 1ll * b) % MOD;\n}\n\nint add(int a, int b){\n\ta += b;\n\ta %= MOD;\n\ta += MOD;\n\ta %= MOD;\n\treturn a;\n}\n\nint minu(int a, int b){\n\ta -= b;\n\ta %= MOD;\n\ta += MOD;\n\ta %= MOD;\n\treturn a;\n}\n\nint POW(int a, int b){\n\tint res = 1;\n\twhile (b){\n\t\tif (b & 1) res = mul(res, a);\n\t\tb >>= 1;\n\t\ta = mul(a, a);\n\t}\n\treturn res;\n}\n\nint Solve(int x){\n\tint res = minu(x, S);\n\tres = mul(res, POW(M, MOD - 2));\n\treturn res;\n}\n\nint32_t main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> n;\n\tcin >> s;\n\tint pnt = N;\n\tfor (int i = 1; i <= n; i++){\n\t\tif (s[i - 1] == '>') pnt++;\n\t\telse if(s[i - 1] == '<') pnt--;\n\t\telse if(s[i - 1] == '+') a[pnt]++;\n\t\telse a[pnt]--;\n\t}\n//\tcout << a[N + 1] << ' ' << a[N] << '\\n';\n\tfor (int i = 2 * N - 1; i >= 0; i--){\n\t\tHash = add(mul(Hash, H), a[i]);\t\n//\t\tcout << Hash << '\\n';\n\t}\n//\tcout << Hash << '\\n';\n\tinv = POW(H, MOD - 2);\n\tM = 1;\n\tint ans = 0;\n//\tcnt[0] ++;\n//\tcout << POW(H, N + 1) << '\\n';\n\tfor (int i = n; i >= 1; i--){\n\t\tint now = 0;\n\t\tif (s[i - 1] == '>'){\n\t\t\tM = mul(M, H);\n\t\t\tS = mul(S, H);\n\t\t}else if(s[i - 1] == '<'){\n\t\t\tM = mul(M, inv);\n\t\t\tS = mul(S, inv);\n\t\t}else if(s[i - 1] == '+'){\n\t\t\tS = add(S, POW(H, N));\n\t\t\tnow = POW(H, N);\n\t\t}else if(s[i - 1] == '-'){\n\t\t\tS = minu(S, POW(H, N));\n\t\t\tnow = minu(0, POW(H, N));\n\t\t}\n\t\tint x = Solve(now);\n\t\tcnt[x]++;\n\t\tx = Solve(Hash);\n\t\tans = add(ans, cnt[x]);\n\t}\n\tcout << ans;\n\n\n\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 280005;\nconst int mod = 1e9 + 123;\n\nint pw[N + N];\nint e[N];\nint h[N];\nint n;\nstring s;\n\nint inverse(int a) {\n\tint b = mod - 2;\n\tint ret = 1;\n\twhile(b) {\n\t\tif (b & 1) ret = 1LL * ret * a % mod; a = 1LL * a * a % mod;\n\t\tb >>= 1;\n\t}\n\treturn ret;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> n >> s;\n\ts = ' ' + s;\n\n\tpw[0] = 1;\n\tfor (int i = 1; i < N + N; ++i) {\n\t\tpw[i] = 1LL * pw[i - 1] * N % mod;\n\t}\n\n\te[0] = N;\n\th[0] = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\th[i] = h[i - 1];\n\t\te[i] = e[i - 1];\n\t\tif (s[i] == '<' || s[i] == '>') {\n\t\t\te[i] += (s[i] == '>' ? +1 : -1);\n\t\t}\n\t\telse {\n\t\t\th[i] = (h[i] + (s[i] == '+' ? +1 : -1) * pw[e[i]]) % mod;\n\t\t\tif (h[i] < 0) h[i] += mod;\n\t\t}\n\t}\n\n\tlong long res = 0;\n\tint t = 1LL * h[n] * inverse(pw[N]) % mod;\n\tmap <int, int> mp;\n\tmp[1LL * t * pw[N] % mod]++;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tres += mp[h[i]];\n\t\tmp[(1LL * t * pw[e[i]] + h[i]) % mod]++;\n\t}\n\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 250001,M = 1e9 + 7,b = 11;\nint cs[N],p[N],n;\nmap<int,int>mp;\nvoid add(int &a,int b){\n\ta+=b;\n\tif(a >= M)a-=M;\n\tif(a < 0)a+=M;\n}\nint power(int base,int to){\n\tint ret = 1;\n\twhile(to){\n\t\tif(to&1)ret = ret*1LL*base%M;\n\t\tto>>=1;\n\t\tbase = base*1LL*base%M;\n\t}\n\treturn ret;\n}\nint main(){\n\t//freopen(\"readin.txt\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tp[0] = 1;\n\tchar c;\n\tint inv = power(b,M - 2);\n\tfor(int i = 1;i <= n;i++){\n\t\tscanf(\" %c\",&c);\n\t\tcs[i] = cs[i - 1];\n\t\tp[i] = p[i - 1];\n\t\tif(c == '+')add(cs[i],p[i]);\n\t\telse if(c == '-')add(cs[i],-p[i]);\n\t\telse if(c == '>')p[i] = p[i]*1LL*b%M;\n\t\telse if(c == '<')p[i] = p[i]*1LL*inv%M;\n\t}\n\tlong long ans = 0;\n\tmp[cs[n]] = 1;\n\tfor(int i = 1;i <= n;i++){\n\t\tans+=mp[cs[i]];\n\t\tmp[(cs[n]*1LL*p[i] + cs[i])%M]++;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,ans;\nunsigned long long x1=1,x2=521,xx=521;\nlong long a[2500010],b[2500010];\nstring st;\nmap<unsigned long long,int>k;\nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<=63;i++)\n\t{\n\t\tx1=x1*x2;\n\t\tx2=x2*x2;\n\t}\n\tcin>>st;\n\tst=' '+st;\n\tb[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\ta[i]=a[i-1];\n\t\tb[i]=b[i-1];\n\t\tif(st[i]=='+')a[i]=a[i]+b[i];\n\t\tif(st[i]=='-')a[i]=a[i]-b[i];\n\t\tif(st[i]=='<')b[i]=b[i]*x1;\n\t\tif(st[i]=='>')b[i]=b[i]*xx;\n\t\tk[a[i]]++;\n\t} \n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tans+=k[a[n]*b[i-1]+a[i-1]];\n\t\tk[a[i]]--;\n\t}\n\tcout<<ans;\n\treturn 0; \n} "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\nusing namespace std;\n\n#define P1 1000000007LL\n#define P2 1000000009LL\ntypedef long long Int;\nmap<Int, Int> cs;\nInt sum[250001];\nInt pos[250001];\nInt res;\nInt n;\nstring str;\nInt pow(Int x, Int y, Int M){\n\tif(y == 0)return 1;\n\tInt res = pow(x, y/2, M);\n\tres = res * res % M;\n\tif(y % 2)res *= x;\n\treturn x % M;\n}\n\nInt rev(Int x, Int M){\n\treturn pow(x, M-2, M);\n}\n\nint main(){\n\tInt p = 0;\n\tInt tmp = 0;\n\tcin >> n;\n\tcin >> str;\n\tfor(int i = 0;i < n;i++){\n\t\tif(str[i] == '+')tmp = (tmp + pow(1000000, p, P1))%P1;\n\t\tif(str[i] == '-')tmp = (tmp - pow(1000000, p, P1))%P1;\n\t\tif(str[i] == '>')p++;\n\t\tif(str[i] == '<')p--;\n\t\tsum[i+1] = tmp;\n\t\tpos[i+1] = p;\n\n\t}\n\tInt last = sum[n];\n\tfor(int i = n;i >= 0;i--){\n\t\tInt tmp = ((last - last * pow(1000000, pos[i], P1) % P1) % P1 + P1)% P1;\n\t\tres += cs[(tmp - sum[i] + P1) % P1];\n\t\tInt c = (last - sum[i] +P1) % P1;\n\t\tif(cs.count(c) == 0)cs[c] = 0;\n\t\tcs[c]++;\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint ungigned\n#define db double\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pli pair<ll,int>\n#define vi vector<int>\n#define vpi vector<pii >\n#define IT iterator\n\n#define PB push_back\n#define MK make_pair\n#define LB lower_bound\n#define UB upper_bound\n#define BG begin\n#define ED end\n\n#define For(i,j,k) for (int i=(j);i<=(int)k;i++)\n#define Rep(i,j,k) for (int i=(j);i>=(int)k;i++)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n\n#define LS3 k*2,l,mid\n#define RS3 k*2+1,mid+1,r\n#define LS5 k*2,l,mid,x,y\n#define RS5 k*2+1,mid+1,r,x,y\n#define GET pushdown(k);int mid=(l+r)/2\nusing namespace std;\n\nconst int BAS[5]={233,666,1234,19260817,2017};\nconst int mo=998244353;\nconst int N=250005;\nstruct wzp{\n\tint a[5];\n\tbool operator <(const wzp &x)const{\n\t\tFor(i,0,4)\n\t\t\tif (a[i]!=x.a[i])\n\t\t\t\treturn a[i]<x.a[i];\n\t\treturn 0;\n\t}\n\tbool operator ==(const wzp &x)const{\n\t\tFor(i,0,4)\n\t\t\tif (a[i]!=x.a[i])\n\t\t\t\treturn 0;\n\t\treturn 1;\n\t}\n};\nint P[5][N*2];\nwzp hsh[N*2];\nint pos[N*2];\nlong long ans;\nmap<wzp,int> mp;\nchar s[N];\nint power(int x,int y){\n\tint s=1;\n\tfor (;y;y/=2,x=1ll*x*x%mo)\n\t\tif (y&1) s=1ll*s*x%mo;\n\treturn s;\n}\nint main(){\n\tFor(i,0,4){\n\t\tP[i][0]=1;\n\t\tFor(j,1,2*N-1)\n\t\t\tP[i][j]=1ll*P[i][j-1]*BAS[i]%mo;\n\t}\n\tint beg=N,l; pos[0]=N;\n\tscanf(\"%d%s\",&l,s+1);\n\tfor (int i=1;i<=l;i++){\n\t\thsh[i]=hsh[i-1];\n\t\tif (s[i]=='+') For(j,0,4) hsh[i].a[j]=(hsh[i].a[j]+P[j][beg])%mo;\n\t\tif (s[i]=='-') For(j,0,4) hsh[i].a[j]=(hsh[i].a[j]+mo-P[j][beg])%mo;\n\t\tif (s[i]=='<') beg--; if (s[i]=='>') beg++;\n\t}\n\tfor (int i=0;i<=l;i++)\n\t\tmp[hsh[i]]++;\n\tfor (int i=0;i<l;i++){\n\t\twzp rpos=hsh[l]; mp[hsh[i]]--;\n\t\tFor(j,0,4) rpos.a[j]=1ll*rpos.a[j]*power(BAS[j],(mo-1)+pos[i]-pos[0])%mo;\n\t\tFor(j,0,4) rpos.a[j]=(rpos.a[j]+hsh[i].a[j])%mo;\n\t\tans+=mp[rpos];\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 250001,M = 1e9 + 9,M1 = 1e9 + 7,b = 103,b1 = 107;\nint cs[N],cs1[N],p[N],p1[N],n;\nmap<pair<int,int>,int>mp;\nvoid add(int &a,int b){\n\ta+=b;\n\tif(a >= M)a-=M;\n\tif(a < 0)a+=M;\n}\nvoid add1(int &a,int b){\n\ta+=b;\n\tif(a >= M)a-=M;\n\tif(a < 0)a+=M;\n}\nint power(int base,int to){\n\tint ret = 1;\n\twhile(to){\n\t\tif(to&1)ret = ret*1LL*base%M;\n\t\tto>>=1;\n\t\tbase = base*1LL*base%M;\n\t}\n\treturn ret;\n}\nint main(){\n\t//freopen(\"readin.txt\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tp[0] = p1[0] = 1;\n\tchar c;\n\tint inv = power(b,M - 2),inv1 = power(b1,M1 - 2);\n\tfor(int i = 1;i <= n;i++){\n\t\tscanf(\" %c\",&c);\n\t\tcs[i] = cs[i - 1];\n\t\tp[i] = p[i - 1];\n\t\tcs1[i] = cs1[i - 1];\n\t\tp1[i] = p1[i - 1];\n\t\tif(c == '+')add(cs[i],p[i]),add1(cs1[i],p1[i]);\n\t\telse if(c == '-')add(cs[i],-p[i]),add1(cs1[i],-p1[i]);\n\t\telse if(c == '>')p[i] = p[i]*1LL*b%M,p1[i] = p1[i]*1LL*b1%M1;\n\t\telse if(c == '<')p[i] = p[i]*1LL*inv%M,p1[i] = p1[i]*1LL*inv1%M1;\n\t}\n\tlong long ans = 0;\n\tfor(int i = 0;i <= n;i++){\n\t\tans+=mp[{cs[i],cs1[i]}];\n\t\tmp[{(cs[n]*1LL*p[i] + cs[i] + M)%M,(cs1[n]*1LL*p1[i] + cs1[i] + M1)%M1}]++;\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n\nll mod=(ll)1e18+9, bas=1e9;\n\nll mul(ll x,ll y){\n    ll t=0;\n    for (;y;y>>=3,x=x*8%mod)\n        t=(t+x*(y&7))%mod;\n    return t;\n}\n\nll K(ll x,ll y=mod-2){\n    if (y<0) return K(K(x),-y);\n    ll t=1;\n    for (;y;y>>=1,x=mul(x,x))\n        if (y&1) t=mul(t,x);\n    return t;\n}\n\nll n, ans, p[505000], f[505000];\nchar s[505000];\nmap<ll,ll>mp;\n\nint main(){\n    cin>>n>>s+1;\n    for (int i=1;i<=n;++i){\n        p[i]=p[i-1]; f[i]=f[i-1];\n        if (s[i]=='<') --p[i];\n        if (s[i]=='>') ++p[i];\n        if (s[i]=='+') f[i]=(f[i]+K(bas,p[i]))%mod;\n        if (s[i]=='-') f[i]=(f[i]-K(bas,p[i])+mod)%mod;\n        ++mp[f[i]];\n    }\n    for (int i=0;i<n;++i){\n        ans+=mp[(mul(f[n],K(bas,p[i])) + f[i])%mod];\n        --mp[f[i+1]];\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                         `!!!;'                                                                 `\n                                                           '%$@########################&&%:.                                                    `\n                                                       .%###################################%.                                                  `\n                                                    .`|######################################%                                                  `\n                                                 .!@###############################################$'                                           `\n                                              .!@#########################@@@#########################&;.                                       `\n                                             :@##################@@@&&@@@$!!%&@@@@@@@###################&'                                      `\n                                          :&################@@@&$%%||||!!:'':;!!||%|!%&@@#################%`                                    `\n                                         |###############@@&&$%|!;;::::':'''':::;;!!|%%%$&&@###############$`                                   `\n                                      :&#############@&$%||||!;'````````````'''```'':::'':!|$@@###############;                                 `\n                                    :@#############@$$%|!;;;;:'``````...```...`...`'':::''';|%$$$&############&'                                `\n                                   |##############&$$$%||!!;:'`````..````....`...```''::::;!!||$&&@@###########&'                               `\n                                 !##############@$%|!!!;::'''`````...``.....`````````'''::::;;::!|%$&############|                              `\n                                :@##########@&%!:'`::;;:'``....```.......  .``....````````````'':;!|%$@############;                            `\n                               ;##########@%;```...`'''`...  .....    ................   .`.    `:!!!!%%%&#########|                            `\n                              ;##########&|:.`'`. ..`...   .......   .....  ..  .....   ...   .'':!!:.`''!@#########|.                          `\n                              !##########|'`.;!`       .  ......          ..    .      ....  .::'`. .. .`'|@########@:                          `\n                              ;##########%'`'%!    ..       .  .                ..    .```.   ';:`..``.`':|@########@:                          `\n                              !##########$:;$&;                     . `|%;.  `;||;::`.``';;.  .;!: `;:`';|$#########@!.                         `\n                              !##########@$&@|. ...... .`':!|;` !$|%%'!##$' `|####$:`:;:!&$:. '$&!';!!||%&############;                         `\n                             `$#############&:  `!!'`:;;;||%@&!'!&&$;.|##%`.|#####%`'$@$&##%` .:||;;;;%@##############!                         `\n                             :@#############|. .!&@|;%@@@@@&@@#@&@#@&@############@@#####@:   .`'%@%!!&###############!                         `\n                             :@############@;   :&@!;$###@|%|!$@@######################@%`    .;|!;!|%@###############!                         `\n                             :@############@:   `$#$%#@@##&@################@$$$&$%|!'       `%#@|;':|&###############!                         `\n                              !##########@$%:    |####@&######$;.                          ..`'`      ;@##############!                         `\n                              !##########!       ;#########|.                             `;`         ;###############!                         `\n                              ;##########;       `%######;                           '$###&:          `%@############&'                         `\n                               !########@:       .'.       .:;`                   .|%:                   !##########&'                          `\n                               !########@:                                                               ;#########@:                           `\n                                !######%.     !##&;.        .                  `%&!`             '&###&' !#########!                            `\n                                |#######;.%###!                 `!&###@|;;%@###%.    ';;|&$:;;`     |#%. .%###%$###!                            `\n                               !#######|  `%#&'    |##&$####&:     !##########;    `%#####%.!#|.   .%@:   ;###;`%##!                            `\n                                !#$!$##!   :@#!        .|###$'.    ;##|.  :&#@;    .``::`          ;@|.   :@#@: `$#|                            `\n                                :&&|&##;   :&#!                   :&##;    .%##!                   !&'    ;@##!  |#!                            `\n                                 |@@##@;  .`%#!                  '$##;      ;##$`                 :@!    .|##@; :&!                             `\n                                 !&|&##%:'.  :&!                :@#%.        .%##;               |&!.   `|@!   `$!                              `\n                                 '$%%###&;.   '&&'            `%##&'           |##@&:    ...;&&&@;     .;&#|':;$&:                              `\n                                 .|######&;        '$@@@@@@@@#|                                        :&######%`                               `\n                                   !#####&:                                                           '$#####@:                                 `\n                                   '$#####@:                                                          ;#####$`                                  `\n                                     '&####%.                 ``                                     '$#####;                                   `\n                                      !#####$'                |@:  .:%|;;;;!$#####@#|               '&###$:                                     `\n                                       :&####&:               ;####################@:    ':`       `%###@:                                      `\n                                         ;#####@%:.                                         `'';|@######$`                                      `\n                                         `$######@|`                                        !#&||@#####$`                                       `\n                                          :&######@%'.                        .`''''` .';!|%@#@$$@####&:                                        `\n                                           |######@|'.   ;##$!!%@##########################@:   '$####;                                         `\n                                           :&#####$;''.`%#########&'             `|@$:         .%###@;                                          `\n                                            :@####@;          |#@##&$;         `|%'           .|####!                                           `\n                                              !####@;                                .        |####!                                            `\n                                               :@###@|`         .                 `|!.       |####%.                                            `\n                                                .|####!          `;$@%|!!!!!%&&@#$;.        !#####|                                             `\n                                                .%####&:              '%&@@@|`             '&#####|                                             `\n                                                .%#####|.                                 :&######%`                                            `\n                                       :|||;`    !#######;                              .%#####@@#####@$;.                                      `\n                                   `$#############&%!%#####|.                         :@####%:..'!&######@;                                     `\n                                  `$#############|`..'%#######!                      ;####&;.    .'%#######!                                    `\n                                .|##############@!`    .'%#########%'.          '%#####%`           :@#######@%;:.                              `\n                          ;%|;. !############%::;'        `!&############@&&@#######@%'               !###########&'                            `\n                         !################$'   .:'         '|&######################$:.               :@#############@@@@@@;                    `\n                      ';$##&;:&###########$`                  :|$@################%:.                 !#####################@;                  `\n                   '%####@$!:.  `%#########!                    .:!%&@#######@%!;'.                   |##############%!$@####!                  `\n                .|#######&;'. .    |#######%.                      .':;!!!!!!;`...                   .|############|. :$@@####%.                `\n                !####&$&@#@!:'.       ;#####%`                  .`';;'... ..''``.                    !##########%`    ''':$######$`             `\n                ;#####@$$;`%&:.         `%####;                   .:;;:'':;||!:`                    !#########!          :&#@@####!             `\n          '%######@######!   !!            :$@$`                    ...`.'::`..                   '$######@!`         '|$$&!!@#######@!.        `\n     '$#########@&$$@######@:    ;: . `'    ....                      ...``.                    `$######&'           '!;`'!@######&&########$'  `\n  ;############@#@@@@@$|%@###$`  `!!.;' .     :!.                                             .%#####!.            .;::&####|`..`  ..;@########!'\n  |########&|;'``..`:'    ..!##%:.    ;;      `.                                            .|###|`             `'|###@&$|`  ..   .`|&&@#######%:\n  |###@#@@#&|:`.`';;:;!!!;:;''!$##&;'.  .'%; .;&###&|$!                                     '$; .|$:;|`   ...;&###$'    ....      :||%&########%:\n  |#######@$;!%%:```           .!@###&|`   :|'!########@#!                                ;@! :@####%'. `|@###&:         ..`:::%$$&$$$&@##@@@##|:\n  |########$;::'`         .`.     `%#####%!: .. !#####%` !#%.                        !; '%; !#############&:          `::`.```. .':.  :$@&&&###|:\n  !####@%:::;;:::::` .........            '.  !#######%;;';; `%#&'             ;&: `;``$@!%########&&##&|::::'.             ':.     `!%@@######|:\n  !#####%;;::.       ...... ....`..  ..  '::!|&########$';%`.'` .;%:        !#$';$%|&$!&##########$'        `';;;;!&##&%||||||%;`   .:|&###@###|:\n  |#######|`...      `|$&&$$!`....           ;$:  :&#@:     `'''``.   .%########&'  .%#@&$%$#####$`     ....`:%&@@@@@@&&@@!`.      .`'%@#######|'\n  |######@@$:       .`..`!@&$&&&&:                ;@#######@@#$%@######&$;    '%@##%!@###@&&@####%.     `!&@@@@@$:..`..``.``...     `|&####@@##!'\n  ;###&|;::!&#&%%%%:         .'::::;|$&&$%|'..;%%&#######%;$########@&#####%`   '|@###;    '%####$;::::::`            '!|%%%%%%%%%&#$:'::.'%###|'\n  `%###@|;|%$%$@#&|;::::`          '|%%%%%$%|%|;';$##@|'.   |######&'     .:|$%: :&@|'.     !####%.              `::;:!$@######&%%%%%!'  ':;&##|:\n  '$##%:.    :&##@####@$;.  ..                    `$|     :; !#####|      '|%:  ``    ...   !####!          .  ..:&#@@@@##@&||$;         :&####|'\n  !####&@@&;        ...`.'%@##@@#@@&!`            :&&!.       !###&'  :||:.`   !%'     ``:$######@@@&&@@@&@##$;``....             |@@@@########!'\n  !#######@$||!:          ';!;;;!&###&|||||||||||%&##@!`.     !###&||%!!!:   .:;`        `;;%####$;:;;;;;;;;;;;::.         '||||||&#####%!;;$##!`\n  `%#&:.`:!||||||%@#@%;::;;;'                     ;@@:    .. .%###|.   `:::'  .:!;'`':'`   `$####!             ':;;;;!%@@&%%%|;`        `;%&###|:\n  .%##|..       '$##@@@@@@#&:...`..              `$#$'        !##%`   ..`.`:%@@! '%@$:''. .`|####|... .........`:%###@#@@@|`        ....`%#####|:\n  !###@&!       .`.```':!&##@&&&&$:              '&#%.        !#&'     ````.    .```:%&&&&&@#####@!':|$&&$&&&&&&&&&@##|`````.       !@@@#######!'\n  :&#########@$||||:            `::::;;;;;!!;;;:;$###$'  .'`  |#@|.  .:;;:.                `%####%:''':::::`               `!||&##$;;;:::.  ;##|:\n  .%#@$%$%%%%%$@###$::::::'.           ...`;|!::!&##@$%|||!' .%##&%%$%'        `'.         :&####!                  .':::'::%@&$%%!` .!!':;$###%:\n  :&#############@|.              .  '$##################&;..!@###@#######%'.             .!#####!          .              `$#####@|``;&|!&####|:\n  |####&%'   .''''':|@###@$$$$$$%;.             |####%`      .|#@;.         .;$$$%$&$$$$$$&######$:..:|%$$$$$$$&&&&@######&;'''.    ;$&########|:\n  |#######@%;;`    '!|!||$#######&|!!!;;;!!!;`.!#####@: .;|!!|&#$'   `:'':;;$######################################%!|!!!!!;.  .`;|&######@####%:\n  |############$!''''..';$&&&&@########################$;'!;`:@#&:``'|$@######@@@@&&&&&&&@#######@&&&&&&&&&&&@@&&&&$|:.    .`''$########@&@####%:\n  |###&%$&#################@%;'  ..      `|@############$: `%@###########$`  `%%:.     . :@######|         !#####################@$%&##########%:\n  |#######################################@&&@######################@@&@#######################################################################%:\n*/\n\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <map>\n#include <set>\n#include <stack>\n#include <ctime>\n#include <cmath>\n#include <queue>\n#include <cstdio>\n#include <cctype>\n#include <vector>\n#include <bitset>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <fstream>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ninline char gc() {\n    static const int L = 233333;\n    static char sxd[L], *sss = sxd, *ttt = sxd;\n    if (sss == ttt) {\n        ttt = (sss = sxd) + fread(sxd, 1, L, stdin);\n        if (sss == ttt) {\n            return EOF;\n        }\n    }\n    return *sss++;\n}\n\n#ifndef _AT_HOME\n#define dd c = gc()\n#else\n#define dd c = getchar()\n#endif\ninline char readalpha() {\n    char dd;\n    for (; !isalpha(c); dd);\n    return c;\n}\n\ninline char readchar() {\n    char dd;\n    for (; c == ' '; dd);\n    return c;\n}\n\ntemplate <class T>\ninline bool read(T& x) {\n    bool flg = false;\n    char dd;\n    x = 0;\n    for (; !isdigit(c); dd) {\n        if (c == '-') {\n            flg = true;\n        } else if(c == EOF) {\n            return false;\n        }\n    }\n    for (; isdigit(c); dd) {\n        x = (x * 10) + (c ^ 48);\n    }\n    if (flg) {\n        x = -x;\n    }\n    return true;\n}\n#undef dd\n\ntemplate <class T>\ninline void write(T x) {\n    if (x < 0) {\n        putchar('-');\n        x = -x;\n    }\n    if (x < 10) {\n        putchar(x | 48);\n        return;\n    }\n    write(x / 10);\n    putchar((x % 10) | 48);\n}\n\ntemplate <class T>\ninline void writesp(T x) {\n    write(x);\n    putchar(' ');\n}\n\ntemplate <class T>\ninline void writeln(T x) {\n    write(x);\n    puts(\"\");\n}\n\n#define lowbit(x) (x & -x)\n\nnamespace dfcmd {\n\n    typedef long long LL;\n    typedef unsigned long long ULL;\n\n    const int maxn = 250005;\n    const ULL bse = 233;\n\n    int n;\n    char s[maxn];\n    map<ULL, int> mp;\n    ULL f[maxn];\n    unsigned g[maxn];\n\n    int Main() {\n        scanf(\"%d%s\", &n, s + 1);\n        ULL inv = 1, xx = bse;\n        for (int i = 1; i <= 63; ++i) {\n            inv = inv * xx;\n            xx = xx * xx;\n        }\n        mp.clear();\n        // cout << bse << ' ' << inv << ' ' << bse * inv << endl;\n        f[0] = 0, g[0] = 1;\n        for (int i = 1; i <= n; ++i) {\n            f[i] = f[i - 1], g[i] = g[i - 1];\n            switch (s[i]) {\n                case '+':\n                    f[i] += g[i];\n                    break;\n                case '-':\n                    f[i] -= g[i];\n                    break;\n                case '<':\n                    g[i] *= inv;\n                    break;\n                case '>':\n                    g[i] *= bse;\n                    break;\n                default:\n                    puts(\"dfcmd\");\n            }\n            mp[f[i]]++;\n        }\n        LL ans = 0;\n        for (int i = 1; i <= n; ++i) {\n            ans += mp[f[n] * g[i - 1] + f[i - 1]];\n            mp[f[i]]--;\n        }\n        writeln(ans);\n        return 0;\n    }\n}\n\nint main() {\n    return dfcmd::Main();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//khodaya khodet komak kon\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define all(x) x.begin(), x.end()\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#define int long long\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int N = 250000 + 10;\nconst ll MOD = 1000000000 + 7;\nconst ll INF = 1000000010;\nconst ll LOG = 25;\nconst int H = 786433, H2 = 12582917;\n\nint a[2 * N], n, M, S, inv, Hash, Hash2, inv2, M2, S2;\nmap<pii, int> cnt;\nstring s;\n\nint mul(int a, int b){\n\treturn (a * 1ll * b) % MOD;\n}\n\nint add(int a, int b){\n\ta += b;\n\ta %= MOD;\n\ta += MOD;\n\ta %= MOD;\n\treturn a;\n}\n\nint minu(int a, int b){\n\ta -= b;\n\ta %= MOD;\n\ta += MOD;\n\ta %= MOD;\n\treturn a;\n}\n\nint POW(int a, int b){\n\tint res = 1;\n\twhile (b){\n\t\tif (b & 1) res = mul(res, a);\n\t\tb >>= 1;\n\t\ta = mul(a, a);\n\t}\n\treturn res;\n}\n\nint Solve(int x){\n\tint res = minu(x, S);\n\tres = mul(res, POW(M, MOD - 2));\n\treturn res;\n}\n\nint Solve2(int x){\n\tint res = minu(x, S2);\n\tres = mul(res, POW(M2, MOD - 2));\n\treturn res;\n}\n\nint32_t main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> n;\n\tcin >> s;\n\tint pnt = N;\n\tfor (int i = 1; i <= n; i++){\n\t\tif (s[i - 1] == '>') pnt++;\n\t\telse if(s[i - 1] == '<') pnt--;\n\t\telse if(s[i - 1] == '+') a[pnt]++;\n\t\telse a[pnt]--;\n\t}\n//\tcout << a[N + 1] << ' ' << a[N] << '\\n';\n\tfor (int i = 2 * N - 1; i >= 0; i--){\n\t\tHash = add(mul(Hash, H), a[i]);\t\n\t\tHash2 = add(mul(Hash2, H2), a[i]);\n//\t\tcout << Hash << '\\n';\n\t}\n//\tcout << Hash << '\\n';\n\tinv = POW(H, MOD - 2);\n\tinv2 = POW(H2, MOD - 2);\n\tM = 1;\n\tM2 = 1;\n\tint ans = 0;\n//\tcnt[0] ++;\n//\tcout << POW(H, N + 1) << '\\n';\n\tfor (int i = n; i >= 1; i--){\n\t\tint now = 0, now2 = 0;\n\t\tif (s[i - 1] == '>'){\n\t\t\tM = mul(M, H);\n\t\t\tS = mul(S, H);\n\t\t\tM2 = mul(M2, H2);\n\t\t\tS2 = mul(S2, H2);\n\t\t}else if(s[i - 1] == '<'){\n\t\t\tM = mul(M, inv);\n\t\t\tM2 = mul(M2, inv2);\n\t\t\tS = mul(S, inv);\n\t\t\tS2 = mul(S2, inv2);\n\t\t}else if(s[i - 1] == '+'){\n\t\t\tS = add(S, POW(H, N));\n\t\t\tS2 = add(S2, POW(H2, N));\n\t\t\tnow = POW(H, N);\n\t\t\tnow2 = POW(H2, N);\n\t\t}else if(s[i - 1] == '-'){\n\t\t\tS = minu(S, POW(H, N));\n\t\t\tS2 = minu(S2, POW(H2, N));\n\t\t\tnow = minu(0, POW(H, N));\n\t\t\tnow2 = minu(0, POW(H2, N));\n\t\t}\n\t\tint xx = Solve2(now2);\n\t\tint x = Solve(now);\n\t\tcnt[{x, xx}]++;\n\t\tx = Solve(Hash);\n\t\txx = Solve2(Hash2);\n\t\tans = add(ans, cnt[{x, xx}]);\n\t}\n\tcout << ans;\n\n\n\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\nusing namespace std;\n#define N 500200\n#define mod1 1000000009\n#define mod2 1000000007\n#define ch1 131\n#define ch2 233\nmap<long long,int> tp;\nint pw1[N],pw2[N],n,su[N],vl[N],ha1[N],ha2[N],as1,as2;\nlong long as;\nchar s[N];\nint pw(int a,int p,int mod){int as=1;while(p){if(p&1)as=1ll*as*a%mod;a=1ll*a*a%mod;p>>=1;}return as;}\nint main()\n{\n\tscanf(\"%d%s\",&n,s+1);\n\tsu[0]=n;\n\tpw1[0]=pw2[0]=1;\n\tfor(int i=1;i<=n*2;i++)pw1[i]=1ll*pw1[i-1]*ch1%mod1,pw2[i]=1ll*pw2[i-1]*ch2%mod2;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tsu[i]=su[i-1];\n\t\tif(s[i]=='<')su[i]--;\n\t\tif(s[i]=='>')su[i]++;\n\t\tif(s[i]=='+')as1=(as1+pw1[su[i]])%mod1,as2=(as2+pw2[su[i]])%mod2;\n\t\tif(s[i]=='-')as1=(as1-pw1[su[i]]+mod1)%mod1,as2=(as2-pw2[su[i]]+mod2)%mod2;\n\t}\n\tfor(int i=n;i>=1;i--)ha1[i]=(ha1[i+1]+mod1+(s[i]=='+'?1ll:(s[i]=='-'?-1ll:0))*pw1[su[i]])%mod1,ha2[i]=(ha2[i+1]+mod2+(s[i]=='+'?1ll:(s[i]=='-'?-1ll:0))*pw2[su[i]])%mod2;\n\ttp[0]=1;\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tint nas1,nas2;\n\t\tif(su[i-1]>=su[0])nas1=1ll*as1*pw1[su[i-1]-su[0]]%mod1,nas2=1ll*as2*pw2[su[i-1]-su[0]]%mod2;\n\t\telse nas1=1ll*as1*pw(pw(ch1,mod1-2,mod1),su[0]-su[i-1],mod1)%mod1,nas2=1ll*as2*pw(pw(ch2,mod2-2,mod2),su[0]-su[i-1],mod2)%mod2;\n\t\tnas1=(ha1[i]-nas1+mod1)%mod1,nas2=(ha2[i]-nas2+mod2)%mod2;\n\t\tas+=tp[nas1*10000000000ll+nas2];\n\t\ttp[ha1[i]*10000000000ll+ha2[i]]++;\n\t}\n\tprintf(\"%lld\\n\",as);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef complex<double> point;\n#define xx real()\n#define yy imag()\n\n#define REP(i, a, b) for(int i = (a); i < (int)(b); i++)\n#define REPN(i, a, b) for(int i = (a); i <= (int)(b); i++)\n#define FA(it, x) for(__typeof((x).begin()) it = (x).begin(); it != (x).end(); it++)\n#define SZ(x) (int)(x).size()\n#define BE(x) (x).begin(), (x).end()\n#define SORT(x) sort(BE(x))\n#define _1 first\n#define _2 second\n\n#define x1 gray_cat_x1\n#define y1 gray_cat_y1\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\n#define file \"I1\"\n\nconst double EPS = 1e-9;\nconst double PI = acos(-1.);\nconst int INF = 1e9;\n\nll mod[2];\n\nconst int MAXN = 5e5 + 5;\n\nint v[MAXN];\n\nchar s[MAXN];\n\nll p[2];\nll stp[MAXN][2];\n\npair<ll, ll> hh[MAXN];\n\nmap<pair<ll, ll>, int> cnt;\n\nint arr[MAXN];\n\nvoid correct_pair(pair<ll, ll> &h, int ind, int add){\n\th._1 = (h._1 - arr[ind] * stp[ind][0]) % mod[0];\n\tif (h._1 < 0){\n\t\th._1 += mod[0];\n\t}\n\th._2 = (h._2 - arr[ind] * stp[ind][1]) % mod[2];\n\tif (h._2 < 0){\n\t\th._2 += mod[1];\n\t}\n\tarr[ind] += add;\n\th._1 = (h._1 + arr[ind] * stp[ind][0]) % mod[0];\n\th._2 = (h._2 + arr[ind] * stp[ind][1]) % mod[2];\n}\n\nvoid solve(){\n\tint n;\n\tscanf(\"%d%s\", &n, &s[1]);\n\tp[0] = 1e6 + 3;\n\tp[1] = 1e6 + 7;\n\tmod[0] = 1e9 + 7;\n\tmod[1] = 1e9 + 9;\n\tREP(j, 0, 2){\n\t\tstp[0][j] = 1;\n\t\tREPN(i, 1, 2 * n){\n\t\t\tstp[i][j] = (stp[i - 1][j] * p[j]) % mod[j];\n\t\t}\n\t}\n\tint offset = n;\n\tREPN(i, 1, n){\n\t\tif (s[i] == '>'){\n\t\t\toffset++;\n\t\t\thh[i] = hh[i - 1];\n\t\t} else if (s[i] == '<'){\n\t\t\toffset--;\n\t\t\thh[i] = hh[i - 1];\n\t\t} else if (s[i] == '+'){\n\t\t\thh[i] = hh[i - 1];\n\t\t\tcorrect_pair(hh[i], offset, 1);\n\t\t} else if (s[i] == '-'){\n\t\t\thh[i] = hh[i - 1];\n\t\t\tcorrect_pair(hh[i], offset, -1);\n\t\t}\n\t}\n\t\n\tll ans = 1ll;\n\tpair <ll, ll> hp = hh[n];\n\toffset = 0;\n\tREPN(i, 1, n){\n\t\tif (s[i] == '>'){\n\t\t\toffset++;\n\t\t} else if (s[i] == '<'){\n\t\t\toffset--;\n\t\t} else if (s[i] == '+'){\n\t\t\thh[i] = hh[i - 1];\n\t\t\tcorrect_pair(hp, offset, -1);\n\t\t} else if (s[i] == '-'){\n\t\t\tcorrect_pair(hp, offset, 1);\n\t\t}\n\t\t\n\t\tpair<ll, ll> dd = mp((hh[n]._1 + mod[0] - hp._1) %  mod[0], (hh[n]._2 + mod[1] - hp._2) %  mod[1]);\n\t\tans += cnt[dd];\n\t\t\n\t\tcnt[hh[i]]++;\n\t}\n\t\n\tcout << ans << endl;\n}   \n\nint main(){\n\n    //freopen(file\".in\", \"r\", stdin); freopen(file\".out\", \"w\", stdout);\n    int t = 1;\n    //cin >> t;\n    while(t--){\n        solve();    \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\n#define N 500001\n#define mod 1000000007\nusing namespace std;\nlong long thn[N],ans,qz[N],a[N];\nchar st[N];\nint where[N];\nint n;\nmap<long long,long long>maps;\nlong long ksmi(long long x,long long y)\n{\n\tlong long total=1,ab=x,p=y;\n\twhile (p)\n\t{\n\t\tif (p%2==1) total=total*ab%mod;\n\t\tab=ab*ab%mod;\n\t\tp/=2;\n\t}\n\treturn total;\n}\nlong long abs(long long x)\n{\n\tif (x<0) return -x;\n\treturn x;\n}\nint main()\n{\n\tscanf(\"%d\\n\",&n);\n\tthn[0]=1;\n\tfor (int i=1;i<=2*n;i++) thn[i]=thn[i-1]*(2*n)%mod;\n\tscanf(\"%s\",st+1);\n\tint nowp=n;\n\twhere[0]=n;\n\tqz[0]=0;\n\tfor (int i=1;i<=2*n;i++)\n\t\tqz[0]=(qz[0]+thn[i-1]*n%mod)%mod;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tqz[i]=qz[i-1];\n\t\tif (st[i]=='+')\n\t\t{\n\t\t\ta[nowp]++;\n\t\t\tqz[i]=(qz[i]+thn[nowp-1])%mod;\n\t\t}\n\t\tif (st[i]=='-')\n\t\t{\n\t\t\ta[nowp]--;\n\t\t\tqz[i]=(qz[i]-thn[nowp-1]+mod)%mod;\n\t\t}\n\t\tif (st[i]=='>') nowp++;\n\t\tif (st[i]=='<') nowp--;\n\t\twhere[i]=nowp;\n\t}\n\tunsigned long long a_hash=0;\n\tfor (int i=1;i<=n*2;i++) a_hash=(a_hash+(a[i]+n)*thn[i-1])%mod;\n\tfor (int i=n;i>=1;i--)\n\t{\n\t\tlong long target=(a_hash-qz[0]+mod)%mod;\n\t\tif (where[i-1]<where[0])\n\t\t\ttarget=target*ksmi(thn[abs(where[i-1]-where[0])],mod-2)%mod;\n\t\telse\ttarget=target*thn[abs(where[0]-where[i-1])]%mod;\n\t\tmaps[qz[i]]++;\n\t\ttarget+=qz[i-1];\n\t\ttarget%=mod;\n\t\tans=(ans+maps[target]);\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<map>\n\ntypedef long long ll;\n\nconst int N=250010,MOD=1000000007,g=500002;\n\nll inv(int x){return (x==1 || x==-1)?x:(-(MOD/x)*inv(MOD%x)%MOD);}\n\nint t0[N*2],*pow;\n\nvoid initialize()\n{\n\tpow=t0+N;\n\n\tpow[0]=1;\n\tfor(int i=1;i<N;i++)\n\t\tpow[i]=(ll)pow[i-1]*g%MOD;\n\n\tint ig=(inv(g)+MOD)%MOD;\n\tfor(int i=0;i<N;i++)\n\t\tpow[-i-1]=(ll)pow[-i]*ig%MOD;\n}\n\nchar s[N];\nint ind[N],val[N],sum[N];\nint n;\n\nll ans;\n\nvoid prework()\n{\n\tint p=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tind[i]=p,val[i]=0;\n\n\t\tif(s[i]=='<')p--;\n\t\telse if(s[i]=='>')p++;\n\t\telse if(s[i]=='+')val[i]=pow[p];\n\t\telse val[i]=-pow[p];\n\t}\n\n\tfor(int i=1;i<=n;i++)\n\t\tsum[i]=((sum[i-1]+val[i])%MOD+MOD)%MOD;\n}\n\nstd::map<int,int> G;\n\nvoid solve()\n{\n\tans=0;\n\tfor(int i=n,x,y;i;i--)\n\t{\n\t\tG[sum[i]]++;\n\n\t\tx=((ll)sum[n]*pow[ind[i]]%MOD+MOD)%MOD;\n\t\ty=((x+sum[i-1])%MOD+MOD)%MOD;\n\n\t\tans+=G[y];\n\t}\n}\n\nint main()\n{\n\tinitialize();\n\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",s+1);\n\n\tprework();\n\tsolve();\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "    #include \"bits/stdc++.h\"\n            using namespace std;\n             \n            #define MAX 600012\n             \n            int n;\n            char buf[MAX];\n            string s;\n            valarray<long long int> MOD1;\n            valarray<long long int> MOD2;\n            vector<valarray<long long int> > p2;\n            vector<valarray<long long int> > vv;\n            vector<int> ps;\n            map<pair<long long int,long long int>, long long int> mp;\n            long long int ppow(long long int i, long long int j, long long int MOD) {\n\t\t\t\tif(i>MOD)exit(1);\n            \tlong long int ret = 1;\n            \twhile (j) {\n            \t\tif (j & 1LL)ret *= i;\n            \t\tif (ret >= MOD)ret %= MOD;\n            \t\tj >>= 1LL;\n            \t}\n            \treturn ret;\n            }\n             \n            valarray<long long int> calc(int dif) {\n            \tvalarray<long long int> ret;\n            \tret.resize(2, 0);\n            \tfor (int j = 0; j < 2; j++) {\n            \t\tif (dif < 0) {\n            \t\t\tret[j]=ppow(ppow(MOD1[j],MOD2[j]-2,MOD2[j]),-dif,MOD2[j]);\n            \t\t}\n            \t\telse {\n            \t\t\tret[j] = ppow(MOD1[j],dif, MOD2[j]);\n            \t\t}\n            \t}\n            \treturn ret;\n            }\n             \n            int main() {\n\t\t\t\tcin >> n;\n            \tscanf(\"%s\", buf);\n            \ts = buf;\n            \tMOD1.resize(2);\n            \tMOD2.resize(2);\n            \tp2.push_back(valarray<long long int>());\n            \tp2.back().resize(2);\n            \tp2.back()[0] = p2.back()[1] = 1;\n            \tMOD2[1] = 1000000007;\n            \tMOD1[0] = 555522277;\n            \tMOD1[1] = 895612783;\n            \tMOD2[0] = 998244353;\n            \tp2[0] %= MOD2;\n            \tfor (int i = 1; i < MAX; i++) p2.push_back((p2.back()*MOD1)%MOD2);\n            \tint pos = MAX/2;\n            \tvalarray<long long int> hs;\n            \ths.resize(2,0);\n            \tvv.push_back(hs);\n            \tps.push_back(pos);\n            \tfor (int i = 0; i < s.size(); i++) {\n            \t\tif (s[i] == '<') pos--;\n            \t\telse if (s[i] == '>') pos++;\n            \t\telse if (s[i] == '+') hs += p2[pos];\n            \t\telse if (s[i] == '-') hs += MOD2-p2[pos];\n            \t\ths %= MOD2;\n            \t\tif(hs[0]<0LL||hs[1]<0LL||p2[pos][0]<0LL||p2[pos][1]<0LL)return 1;\n            \t\tvv.push_back(hs);\n            \t\tps.push_back(pos);\n            \t}\n            \tlong long int way = 0;\n            \tfor (int i = vv.size() - 1; i >= 0; i--) {\n            \t\tvalarray<long long int> want = (vv[i] + ((vv.back()*calc(-MAX/2+ps[i]))%MOD2)%MOD2)%MOD2;\n            \t\tway += mp[make_pair(want[0], want[1])];\n            \t\tif(want[0]<0LL||want[1]<0LL)return 1;\n            \t\tmp[make_pair(vv[i][0],vv[i][1])]++;\n            \t}\n            \tprintf(\"%lld\\n\", way);\n            \treturn 0;\n            }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MAXN 250000\n#define ll long long\n#define rint register int\ninline int read(){int r;int s=0,c;for(;!isdigit(c=getchar());s=c);for(r=c^48;isdigit(c=getchar());(r*=10)+=c^48);return s^45?r:-r;}\n#define BS 998244353\n#define EV1 669690699\n#define EV2 679604188\n#define MOD1 1004535809\n#define MOD2 1061109589\nstruct Hash\n{\n\tint h1,h2; Hash(){} Hash(int _h1, int _h2){h1=_h1;h2=_h2;} inline Hash operator + (Hash b){return Hash((h1+b.h1)%MOD1,(h2+b.h2)%MOD2);} inline ll v(){return (ll)h1<<32|h2;}\n\tinline Hash operator - (Hash b){return Hash((h1+MOD1-b.h1)%MOD1,(h2+MOD2-b.h2)%MOD2);} inline Hash operator * (Hash b){return Hash(1ll*h1*b.h1%MOD1,1ll*h2*b.h2%MOD2);}\n}P[MAXN+5], H[MAXN+5], B(BS,BS), E(EV1,EV2), I(1,1), _; char s[MAXN+5]; int n; unordered_map<ll,int> G; ll Ans;\nint main()\n{\n\tn = read(); scanf(\"%s\",s+1); P[0] = I; for(rint i = 1; i <= n; i++) switch(P[i]=P[i-1],H[i]=H[i-1],s[i]){case'<':P[i]=P[i]*E;break;case'>':P[i]=P[i]*B;break;case'+':H[i]=H[i]+P[i];break;case'-':H[i]=H[i]-P[i];break;}\n\tfor(rint i = n; i; ++G[H[i].v()], Ans += G[(H[n]*P[i-1]+H[i-1]).v()], i--); return !printf(\"%lld\\n\",Ans);\n}"
  },
  {
    "language": "C++",
    "code": "/*\n    _____\n  .'     '.\n /  0   0  \\\n|     ^     |\n|  \\     /  |\n \\  '---'  /\n  '._____.'\n*/\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\nstruct chash\n{\n\tint operator()(int x) const\n\t{\n\t\tx ^= (x >> 20) ^ (x >> 12);\n\t\treturn x ^ (x >> 7) ^ (x >> 4);\n\t}\n};\n\ntemplate<typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename U> using hashtable = gp_hash_table<T, U, chash>;\nrandom_device(rd);\nmt19937 rng(rd());\n\ntemplate<class T>\nvoid readi(T &x)\n{\n\tT input = 0;\n\tbool negative = false;\n\tchar c = ' ';\n\twhile (c < '-')\n\t{\n\t\tc = getchar();\n\t}\n\tif (c == '-')\n\t{\n\t\tnegative = true;\n\t\tc = getchar();\n\t}\n\twhile (c >= '0')\n\t{\n\t\tinput = input * 10 + (c - '0');\n\t\tc = getchar();\n\t}\n\tif (negative)\n\t{\n\t\tinput = -input;\n\t}\n\tx = input;\n}\ntemplate<class T>\nvoid printi(T output)\n{\n\tif (output == 0)\n\t{\n\t\tputchar('0');\n\t\treturn;\n\t}\n\tif (output < 0)\n\t{\n\t\tputchar('-');\n\t\toutput = -output;\n\t}\n\tint aout[20];\n\tint ilen = 0;\n\twhile(output)\n\t{\n\t\taout[ilen] = ((output % 10));\n\t\toutput /= 10;\n\t\tilen++;\n\t}\n\tfor (int i = ilen - 1; i >= 0; i--)\n\t{\n\t\tputchar(aout[i] + '0');\n\t}\n\treturn;\n}\ntemplate<class T>\nvoid ckmin(T &a, T b)\n{\n\ta = min(a, b);\n}\ntemplate<class T>\nvoid ckmax(T &a, T b)\n{\n\ta = max(a, b);\n}\ntemplate<class T, class U>\nT nmod(T &x, U mod)\n{\n\tif (x >= mod) x -= mod;\n}\ntemplate<class T>\nT randomize(T mod)\n{\n\treturn (uniform_int_distribution<T>(0, mod - 1))(rng);\n}\n\n#define y0 ___y0\n#define y1 ___y1\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fi first\n#define se second\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\nconst long double PI = 4.0 * atan(1.0);\nconst long double EPS = 1e-10;\n\n#define MAGIC 347\n#define SINF 10007\n#define CO 1000007\n#define INV 124982126\n#define INF 1000000007\n#define BIG 1000000931\n#define LARGE 1696969696967ll\n#define GIANT 2564008813937411ll\n#define LLINF 2696969696969696969ll\n#define MAXN 500013\n\ntypedef __int128_t ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ld, ld> pdd;\n\nint N;\nint arr[MAXN];\nll S;\nlong long ans;\nmap<ll, int> freq, need;\n\nll expo(ll a, ll e)\n{\n\tif (e == 0)\n\t{\n\t\treturn 1;\n\t}\n\tll was = expo(a, e / 2);\n\tif (e % 2)\n\t{\n\t\treturn was * was % INF * a % INF;\n\t}\n\treturn was * was % INF;\n}\nll modinv(ll a)\n{\n\treturn expo(a, INF - 2);\n}\nvoid solve(int L, int R)\n{\n\tif (L == R)\n\t{\n\t\treturn;\n\t}\n\tfreq.clear(); need.clear();\n\tint mid = (L + R) >> 1;\n\t//start from L...mid, end at mid + 1....R\n\tpll trans = MP(1, 0);\n\tfor (int i = mid + 1; i <= R; i++)\n\t{\n\t\tif (arr[i] == 0)\n\t\t{\n\t\t\ttrans.fi *= INV;\n\t\t\ttrans.se *= INV;\n\t\t}\n\t\tif (arr[i] == 1)\n\t\t{\n\t\t\ttrans.fi *= CO;\n\t\t\ttrans.se *= CO;\n\t\t}\n\t\tif (arr[i] == 2)\n\t\t{\n\t\t\ttrans.se++;\n\t\t}\n\t\tif (arr[i] == 3)\n\t\t{\n\t\t\ttrans.se--; trans.se += INF;\n\t\t}\n\t\ttrans.fi %= INF;\n\t\ttrans.se %= INF;\n\t\t// cerr << \"from \" << mid + 1 << \" to \" << i << \" is \" << trans.fi << \"x + \" << trans.se << endl;\n\t\tll dif = S - trans.se + INF;\n\t\tnmod(dif, INF);\n\t\tdif *= modinv(trans.fi);\n\t\tdif %= INF;\n\t\tneed[dif]++;\n\t}\n\ttrans = MP(1, 0);\n\tfor (int i = mid; i >= L; i--)\n\t{\n\t\tif (arr[i] == 0)\n\t\t{\n\t\t\ttrans.fi *= INV;\n\t\t}\n\t\tif (arr[i] == 1)\n\t\t{\n\t\t\ttrans.fi *= CO;\n\t\t}\n\t\tif (arr[i] == 2)\n\t\t{\n\t\t\t//(x+1)*a+b = a * x + a + b\n\t\t\ttrans.se += trans.fi;\n\t\t}\n\t\tif (arr[i] == 3)\n\t\t{\n\t\t\t//(x - 1)*a + b = a*x - a + b\n\t\t\ttrans.se -= trans.fi;\n\t\t\ttrans.se += INF;\n\t\t}\n\t\ttrans.fi %= INF;\n\t\ttrans.se %= INF;\n\t\tfreq[trans.se]++;\n\t}\n\tfor (auto p : need)\n\t{\n\t\tll x = p.fi; int c = p.se;\n\t\tans += 1ll * c * freq[x];\n\t}\n\tsolve(L, mid);\n\tsolve(mid + 1, R);\n}\n\nint32_t main()\n{\n\tios_base::sync_with_stdio(0);\n\t// cout << fixed << setprecision(10);\n\t// cerr << fixed << setprecision(10);\n\t// freopen (\"file.in\", \"r\", stdin);\n\t// freopen (\"file.out\", \"w\", stdout);\n\tcin >> N;\n\tstring temps;\n\tcin >> temps;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (temps[i] == '<')\n\t\t{\n\t\t\tarr[i] = 0;\n\t\t}\n\t\tif (temps[i] == '>')\n\t\t{\n\t\t\tarr[i] = 1;\n\t\t}\n\t\tif (temps[i] == '+')\n\t\t{\n\t\t\tarr[i] = 2;\n\t\t}\n\t\tif (temps[i] == '-')\n\t\t{\n\t\t\tarr[i] = 3;\n\t\t}\n\t}\n\treverse(arr, arr + N);\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (arr[i] == 0)\n\t\t{\n\t\t\tS *= INV; S %= INF;\n\t\t\t// cerr << \"times \" << INV << endl;\n\t\t}\n\t\tif (arr[i] == 1)\n\t\t{\n\t\t\tS *= CO; S %= INF;\n\t\t\t// cerr << \"times \" << CO << endl;\n\t\t}\n\t\tif (arr[i] == 2)\n\t\t{\n\t\t\tS++; nmod(S, INF);\n\t\t\t// cerr << \"add 1\\n\";\n\t\t}\n\t\tif (arr[i] == 3)\n\t\t{\n\t\t\tS--; S += INF; nmod(S, INF);\n\t\t\t// cerr << \"add -1\\n\";\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (arr[i] == 0)\n\t\t{\n\t\t\tif (S == 0) ans++;\n\t\t}\n\t\tif (arr[i] == 1)\n\t\t{\n\t\t\tif (S == 0) ans++;\n\t\t}\n\t\tif (arr[i] == 2)\n\t\t{\n\t\t\tif (S == 1) ans++;\n\t\t}\n\t\tif (arr[i] == 3)\n\t\t{\n\t\t\tif (S == INF - 1) ans++;\n\t\t}\n\t}\n\t// for (int i = 0; i < N; i++)\n\t// {\n\t// \tll val = 0;\n\t// \tfor (int j = i; j < N; j++)\n\t// \t{\n\t// \t\tif (arr[j] == 0)\n\t// \t\t{\n\t// \t\t\tval *= INV; val %= INF;\n\t// \t\t}\n\t// \t\tif (arr[j] == 1)\n\t// \t\t{\n\t// \t\t\tval *= CO; val %= INF;\n\t// \t\t}\n\t// \t\tif (arr[j] == 2)\n\t// \t\t{\n\t// \t\t\tval++; nmod(val, INF);\n\t// \t\t}\n\t// \t\tif (arr[j] == 3)\n\t// \t\t{\n\t// \t\t\tval--; val += INF; nmod(val, INF);\n\t// \t\t}\n\t// \t\tif (val == S)\n\t// \t\t{\n\t// \t\t\tans++;\n\t// \t\t}\n\t// \t}\n\t// }\n\tsolve(0, N - 1);\n\tcout << ans << '\\n';\n\t//when u <, the # divides by co\n\t//when u >, the # mults by co\n\t//when u +, u add the #\n\t//when u -, u subtract the #\n\t// cerr << \"time elapsed = \" << (clock() / (CLOCKS_PER_SEC / 1000)) << \" ms\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=500005;\ntypedef long long ll;\nll base1=27,ms1=73939133,inv1;\nll base2=63,ms2=998244353,inv2;\nll h1[N],h2[N],m1[N],im1[N],p[N],m2[N],im2[N];\nmap<pair<int,int>,int>mp;\nchar s[N];\nll ksm(ll x,ll k,ll ms){\n\tll t=1;\n\tfor (;k;k>>=1){\n\t\tif (k&1) t=(t*x)%ms;\n\t\tx=(x*x)%ms;\n\t}\n\treturn t;\n}\nint main(){\n\tinv1=ksm(base1,ms1-2,ms1);\n\tinv2=ksm(base2,ms2-2,ms2);\n\tint n; \n\tscanf(\"%d\",&n);\n\tm1[0]=m2[0]=im1[0]=im2[0]=1;\n\tfor (int i=1;i<=n*2;i++){\n\t\tm1[i]=m1[i-1]*base1%ms1;\n\t\tm2[i]=m2[i-1]*base2%ms2;\n\t\tim1[i]=im1[i-1]*inv1%ms1;\n\t\tim2[i]=im2[i-1]*inv2%ms2;\n\t}\n\tp[0]=n;\n\tscanf(\"%s\",s+1);\n\tfor (int i=1;i<=n;i++){\n\t\tif (s[i]=='+'){\n\t\t\tp[i]=p[i-1]; \n\t\t\th1[i]=(h1[i-1]+m1[p[i]])%ms1;\n\t\t\th2[i]=(h2[i-1]+m2[p[i]])%ms2;\n\t\t}else if (s[i]=='-'){\n\t\t\tp[i]=p[i-1];\n\t\t\th1[i]=(h1[i-1]+ms1-m1[p[i]])%ms1;\n\t\t\th2[i]=(h2[i-1]+ms2-m2[p[i]])%ms2;\n\t\t}else if (s[i]=='>'){\n\t\t\tp[i]=p[i-1]+1;\n\t\t\th1[i]=h1[i-1]; h2[i]=h2[i-1];\n\t\t}else{\n\t\t\tp[i]=p[i-1]-1;\n\t\t\th1[i]=h1[i-1]; h2[i]=h2[i-1];\n\t\t}\n\t\tmp[make_pair(h1[i],h2[i])]++;\n\t}\n\tll ans=0;\n\tfor (int i=1;i<=n;i++){\n\t\tint d=p[i-1]-n;\n\t    ll t1=h1[n],t2=h2[n];\n\t\tif (d>=0){ t1=t1*m1[d]%ms1; t2=t2*m2[d]%ms2;}\n\t\telse t1=t1*im1[-d]%ms1,t2=t2*im2[-d]%ms2;\n\t\tt1=(t1+h1[i-1])%ms1; t2=(t2+h2[i-1])%ms2;\n\t\tans+=mp[make_pair(t1,t2)];\n\t\tmp[make_pair(h1[i],h2[i])]--;\t\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll    =long long;    using dd   =double;        using pll    =pair<ll, ll>;  using tll    =tuple<ll,ll,ll>;\nusing vll   =vector<ll>;   using vdd  =vector<dd>;    using vpll   =vector<pll>;   using vtll   =vector<tll>;\nusing vvll  =vector<vll>;  using vvdd =vector<vdd>;   using vvpll  =vector<vpll>;  using vvtll  =vector<vtll>;\nusing vvvll =vector<vvll>; using vvvdd=vector<vvdd>;  using vvvpll =vector<vvpll>; using vvvtll =vector<vvtll>;\nusing vvvvll=vector<vvvll>;using vvvvdd=vector<vvvdd>;using vvvvpll=vector<vvvpll>;using vvvvtll=vector<vvvtll>;\n\nconstexpr ll INF = 1LL << 60;\nconstexpr dd EPS = 1e-11;\n\n//cin,cout高速化のおまじない＋桁数指定\nstruct Fast{\n\tFast(){\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(std::numeric_limits<double>::max_digits10);\n\t}\n} fast;\n\n#define REPS(i, S, E) for (ll i = (S); i <= (E); i++)\n#define REP(i, N) REPS(i, 0, (N)-1)\n#define DEPS(i, S, E) for (ll i = (E); i >= (S); i--)\n#define DEP(i, N) DEPS(i, 0, (N)-1)\n#define EACH(e, v) for (auto&& e : v)\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\ntemplate<class T> inline T MaxE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmax(m,v[i]); return m;}//v[S]～v[E]の最大値\ntemplate<class T> inline T MinE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmin(m,v[i]); return m;}//v[S]～v[E]の最小値\ntemplate<class T> inline T MaxE(vector<T> &v, ll N) { return MaxE(v, 0, N - 1); } //先頭N個中の最大値\ntemplate<class T> inline T MinE(vector<T> &v, ll N) { return MinE(v, 0, N - 1); }\ntemplate<class T> inline T MaxE(vector<T> &v) { return MaxE(v, (ll)v.size()); }\ntemplate<class T> inline T MinE(vector<T> &v) { return MinE(v, (ll)v.size()); }\ntemplate<class T> inline ll MaxI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]>v[m])m=i;} return m;}\ntemplate<class T> inline ll MinI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]<v[m])m=i;} return m;}\ntemplate<class T> inline ll MaxI(vector<T> &v, ll N) { return MaxI(v, 0, N - 1); }\ntemplate<class T> inline ll MinI(vector<T> &v, ll N) { return MinI(v, 0, N - 1); }\ntemplate<class T> inline ll MaxI(vector<T> &v) { return MaxI(v, (ll)v.size()); }\ntemplate<class T> inline ll MinI(vector<T> &v) { return MinI(v, (ll)v.size()); }\ntemplate<class T> inline T Sum(vector<T> &v, ll S,ll E){ T s=v[S]; REPS(i,S+1,E)s+=v[i]; return s; }\ntemplate<class T> inline T Sum(vector<T> &v, ll N) { return Sum(v, 0, N - 1); }\ntemplate<class T> inline T Sum(vector<T> &v) { return Sum(v, v.size()); }\ntemplate<class T> inline T POW(T a, ll n){ T r=1; for (; n>0; n>>=1, a*=a){ if (n&1)r*=a; } return r; }\ninline ll POW(int a, ll n){ return POW((ll)a, n); }\ninline ll MSB(ll a){for(ll o=63,x=-1;;){ll m=(o+x)/2; if(a<(1LL<<m))o=m; else x=m; if(o-x==1)return x;}}\ninline ll CEIL(ll a, ll b){ return (a+b-1)/b; }\nll Gcd(ll a, ll b){ return (b==0) ? a : Gcd(b, a%b); }\nll Lcm(ll a, ll b){ return a * b / Gcd(a, b); }\ninline vll Mask2Idx(ll m){vll v; for(ll i=0;m;m>>=1,i++) if(m&1)v.push_back(i); return move(v);}\ninline ll BitNum(ll m){ for (ll c=0;; m>>=1){ c+=m&1; if (!m)return c; } }\ninline ll Bit(ll s, ll i){ return (s>>i)&1; } //sの第ibit i=0-63\ninline ll BitOn(ll s, ll i){ return s|(1LL<<i); } //sの第ibitON i=0-63\ninline ll BitOff(ll s, ll i){ return s&~(1LL<<i); } //sの第ibitOFF i=0-63\ntemplate<class T> inline ll UnderNumOf(vector<T> &v, T x){ //sort済vのx以下の個数を得る\n\treturn upper_bound(v.begin(), v.end(), x) - v.begin(); }\ntemplate<class T, class Pr> inline ll UnderNumOf(vector<T> &v, T x, Pr pred){ //x以下個数\n\treturn upper_bound(v.begin(), v.end(), x, pred) - v.begin(); }\ntemplate<class T> inline ll OverNumOf(vector<T> &v, T x){ //sort済vのx以上の個数を得る\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x) - v.begin()); }\ntemplate<class T, class Pr> inline ll OverNumOf(vector<T> &v, T x, Pr pred){ //x以上の個数\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x, pred) - v.begin()); }\n\ntemplate<class T=ll> inline vector<T> cinv(ll N){ vector<T> v(N); REP(i, N)cin>>v[i]; return move(v);}\ntemplate<class T=ll, class S=ll> inline vector<pair<T, S>> cinv2(ll N){\n\tvector<pair<T, S>> v(N); REP(i,N){cin>>v[i].first>>v[i].second;} return move(v); }\ntemplate<class T=ll,class S=ll,class R=ll> inline vector<tuple<T, S, R>> cinv3(ll N){\n\tvector<tuple<T,S,R>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i]);} return move(v);}\ntemplate<class T=ll,class S=ll,class R=ll,class Q=ll> inline vector<tuple<T,S,R,Q>> cinv4(ll N){\n\tvector<tuple<T,S,R,Q>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i])>>get<3>(v[i]);} return move(v);}\ntemplate<class T=ll> inline vector<vector<T>> cinvv(ll N, ll M){\n\tvector<vector<T>> vv(N); REP(i, N) vv[i] = cinv(M); return move(vv);}\ntemplate<class T> inline void coutv(vector<T> &v, char deli=' '){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?'\\n':deli);} }\ntemplate<class T> void bye(T a){cout << a << '\\n'; exit(0);}\n\n#if defined(_DEBUG)\ntemplate<class T> void Dump(vector<T> &v){\n\tREP(i, (ll)v.size()) { cerr << ((i==0)?\"[\":\" \") << setw(5) << v[i]; }  cerr << \"]\";\n}\nvoid Dump(vll &v){\n\tREP(i, (ll)v.size()) {\n\t\tcerr << ((i==0)?\"[\":\" \") << setw(4);\n\t\tif       (v[i] == INF) cerr << \"INF\";\n\t\telse if (v[i] == -INF) cerr << \"-INF\";\n\t\telse                   cerr << v[i];\n\t}  cerr << \"]\";\n}\ntemplate<class T> void Dump(vector<vector<T>> &v){\n\tll N=(ll)v.size();  string d[2][2]={{\" \", \"[\"},  {\"\\n\", \"]\\n\"}};\n\tREP(i, N) { cerr << d[0][i==0];  Dump(v[i]);  cerr << d[1][i==N-1]; }\n}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  <\", \"[ <\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ---<\", \"[ ---<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">---\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ======<\", \"[ ======<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">======\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\n#else\ntemplate<class T> void Dump(vector<T> &v){}\ntemplate<class T> void Dump(vector<vector<T>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){}\n#endif\n\nstruct mll{\n\tstatic ll MOD;\n\tll val;\n\tmll(ll v = 0): val(v % MOD){ if (val < 0) val += MOD; }\n\tmll operator - () const { return -val; }\n\tmll operator + (const mll &b) const { return val + b.val; }\n\tmll operator - (const mll &b) const { return val - b.val; }\n\tmll operator * (const mll &b) const { return val * b.val; }\n\tmll operator / (const mll &b) const { return mll(*this) /= b; }\n\tmll operator + (ll b) const { return *this + mll(b); }\n\tmll operator - (ll b) const { return *this - mll(b); }\n\tmll operator * (ll b) const { return *this * mll(b); }\n\tfriend mll operator + (ll a, const mll &b) { return b + a; }\n\tfriend mll operator - (ll a, const mll &b) { return -b + a; }\n\tfriend mll operator * (ll a, const mll &b) { return b * a; }\n\tfriend mll operator / (ll a, const mll &b) { return mll(a)/b; }\n\tmll &operator += (const mll &b) { val=(val+b.val)%MOD; return *this; }\n\tmll &operator -= (const mll &b) { val=(val+MOD-b.val)%MOD; return *this; }\n\tmll &operator *= (const mll &b) { val=(val*b.val)%MOD; return *this; }\n\tmll &operator /= (const mll &b) {\n\t\tll c=b.val, d=MOD, u=1, v=0;\n\t\twhile (d){\n\t\t\tll t = c / d;\n\t\t\tc -= t * d; swap(c, d);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tmll &operator += (ll b) { return *this += mll(b); }\n\tmll &operator -= (ll b) { return *this -= mll(b); }\n\tmll &operator *= (ll b) { return *this *= mll(b); }\n\tmll &operator /= (ll b) { return *this /= mll(b); }\n\tbool operator == (const mll &b) { return val == b.val; }\n\tbool operator != (const mll &b) { return val != b.val; }\n\tbool operator == (ll b) { return *this == mll(b); }\n\tbool operator != (ll b) { return *this != mll(b); }\n\tfriend bool operator == (ll a, const mll &b) { return mll(a) == b.val; }\n\tfriend bool operator != (ll a, const mll &b) { return mll(a) != b.val; }\n\tfriend ostream &operator << (ostream &os, const mll &a) { return os << a.val; }\n\tfriend istream &operator >> (istream &is, mll &a) { return is >> a.val; }\n\tstatic mll Combination(ll a, ll b){\n\t\tchmin(b, a-b);\n\t\tif (b<0) return mll(0);\n\t\tmll c = 1;\n\t\tREP(i, b) c *= a-i;\n\t\tREP(i, b) c /= i+1;\n\t\treturn c;\n\t}\n};\nll mll::MOD = 2099999999LL;// 998244353LL;//1000000007LL;\nusing vmll = std::vector<mll>;\nusing vvmll = std::vector<vmll>;\nusing vvvmll = std::vector<vvmll>;\nusing vvvvmll = std::vector<vvvmll>;\nusing vvvvvmll = std::vector<vvvvmll>;\n\nusing Data = tuple<mll, ll, mll>;\n\nData prod(Data a, Data b){\n\tmll ha; ll pa; mll qpa; tie(ha, pa, qpa) = a;\n\tmll hb; ll pb; mll qpb; tie(hb, pb, qpb) = b;\n\treturn Data(ha+qpa*hb, pa+pb, qpa*qpb);\n}\n\nvoid solve()\n{\n\tll N; string S;  cin >> N >> S;\n\tmll q = 999983;\n\tmll qq = 250007;\n\tmll qinv = mll(1) / q;\n\tmll qqinv = mll(1) / qq;\n\n\tData plus  = Data( 1, 0, 1);\n\tData minus = Data(-1, 0, 1);\n\tData right = Data( 0, 1, q);\n\tData left  = Data( 0,-1, qinv);\n\tData pplus  = Data( 1, 0, 1);\n\tData mminus = Data(-1, 0, 1);\n\tData rright = Data( 0, 1, qq);\n\tData lleft  = Data( 0,-1, qqinv);\n\n\t//W求める\n\tData W = Data(0, 0, 1);\n\tData WW = Data(0,0,1);\n\tDEPS(i, 0, N-1){\n\t\tData si;\n\t\tData ssi;\n\t\tif      (S[i] == '+') si = plus;\n\t\telse if (S[i] == '-') si = minus;\n\t\telse if (S[i] == '>') si = right;\n\t\telse                  si = left;\n\t\tif      (S[i] == '+') ssi = pplus;\n\t\telse if (S[i] == '-') ssi = mminus;\n\t\telse if (S[i] == '>') ssi = rright;\n\t\telse                  ssi = lleft;\n\t\tW  = prod( si, W);\n\t\tWW = prod(ssi, WW);\n\t}\n\tmll hW = get<0>(W);\n\tmll hWW = get<0>(WW);\n\n\tunordered_map<ll, ll> CinvMap;\n\tunordered_map<ll, ll> CCinvMap;\n\tData X    = Data(0, 0, 1);\n\tData Xinv = Data(0, 0, 1);\n\tData XX    = Data(0, 0, 1);\n\tData XXinv = Data(0, 0, 1);\n\tll ans = 0;\n\tDEPS(i, 0, N-1){\n\t\t//現在のXinvをCinvバッファに入れる\n\t\tll h  = get<0>( Xinv).val;\n\t\tll hh = get<0>(XXinv).val;\n\t\tCinvMap [h] ++;\n\t\tCCinvMap[hh]++;\n\t\t//Xを伸ばす\n\t\tData si;\n\t\tData ssi;\n\t\tif      (S[i] == '+') si = plus;\n\t\telse if (S[i] == '-') si = minus;\n\t\telse if (S[i] == '>') si = right;\n\t\telse                  si = left;\n\t\tif      (S[i] == '+') ssi = pplus;\n\t\telse if (S[i] == '-') ssi = mminus;\n\t\telse if (S[i] == '>') ssi = rright;\n\t\telse                  ssi = lleft;\n\t\tX  = prod( si, X);\n\t\tXX = prod(ssi, XX);\n\t\t//Xinvを伸ばす\n\t\tData siinv;\n\t\tData ssiinv;\n\t\tif      (S[i] == '+') siinv = minus;\n\t\telse if (S[i] == '-') siinv = plus;\n\t\telse if (S[i] == '>') siinv = left;\n\t\telse                  siinv = right;\n\t\tif      (S[i] == '+') ssiinv = mminus;\n\t\telse if (S[i] == '-') ssiinv = pplus;\n\t\telse if (S[i] == '>') ssiinv = lleft;\n\t\telse                  ssiinv = rright;\n\t\tXinv =  prod(Xinv,  siinv);\n\t\tXXinv = prod(XXinv, ssiinv);\n\t\t\n\t\t//C^-1のh成分を計算\n\t\tmll hX =  get<0>(X);\n\t\tmll hXX = get<0>(XX);\n\t\tmll qpXinv  = get<2>(Xinv);\n\t\tmll qpXXinv = get<2>(XXinv);\n\t\tmll hCinv  = (hW -hX)  * qpXinv;\n\t\tmll hCCinv = (hWW-hXX) * qpXXinv;\n\t\tif (CinvMap.count(hCinv.val) == 1 && CCinvMap.count(hCCinv.val) == 1){\n\t\t\tll c1 =  CinvMap[ hCinv.val];\n\t\t\tll c2 = CCinvMap[hCCinv.val];\n\t\t\tans += min(c1, c2);\n\t\t}\n\t}\n\tcout << ans << '\\n';\n}\n\n\nint main(){\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <map>\n#include <set>\n#include <stack>\n#include <ctime>\n#include <cmath>\n#include <queue>\n#include <cstdio>\n#include <cctype>\n#include <vector>\n#include <bitset>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <fstream>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ninline char gc() {\n    static const int L = 233333;\n    static char sxd[L], *sss = sxd, *ttt = sxd;\n    if (sss == ttt) {\n        ttt = (sss = sxd) + fread(sxd, 1, L, stdin);\n        if (sss == ttt) {\n            return EOF;\n        }\n    }\n    return *sss++;\n}\n\n#ifndef _AT_HOME\n#define dd c = gc()\n#else\n#define dd c = getchar()\n#endif\ninline char readalpha() {\n    char dd;\n    for (; !isalpha(c); dd);\n    return c;\n}\n\ninline char readchar() {\n    char dd;\n    for (; c == ' '; dd);\n    return c;\n}\n\ntemplate <class T>\ninline bool read(T& x) {\n    bool flg = false;\n    char dd;\n    x = 0;\n    for (; !isdigit(c); dd) {\n        if (c == '-') {\n            flg = true;\n        } else if(c == EOF) {\n            return false;\n        }\n    }\n    for (; isdigit(c); dd) {\n        x = (x * 10) + (c ^ 48);\n    }\n    if (flg) {\n        x = -x;\n    }\n    return true;\n}\n#undef dd\n\ntemplate <class T>\ninline void write(T x) {\n    if (x < 0) {\n        putchar('-');\n        x = -x;\n    }\n    if (x < 10) {\n        putchar(x | 48);\n        return;\n    }\n    write(x / 10);\n    putchar((x % 10) | 48);\n}\n\ntemplate <class T>\ninline void writesp(T x) {\n    write(x);\n    putchar(' ');\n}\n\ntemplate <class T>\ninline void writeln(T x) {\n    write(x);\n    puts(\"\");\n}\n\n#define lowbit(x) (x & -x)\n\nnamespace dfcmd {\n\n    typedef long long LL;\n    typedef unsigned long long ULL;\n\n    const int maxn = 250005;\n    const ULL bse = 233;\n\n    int n;\n    char s[maxn];\n    map<ULL, int> mp;\n    ULL f[maxn], g[maxn];\n\n    int Main() {\n        scanf(\"%d%s\", &n, s + 1);\n        ULL inv = 1, xx = bse;\n        for (int i = 1; i <= 63; ++i) {\n            inv = inv * xx;\n            xx = xx * xx;\n        }\n        mp.clear();\n        // cout << bse << ' ' << inv << ' ' << bse * inv << endl;\n        f[0] = 0, g[0] = 1;\n        for (int i = 1; i <= n; ++i) {\n            f[i] = f[i - 1], g[i] = g[i - 1];\n            switch (s[i]) {\n                case '+':\n                    f[i] += g[i];\n                    break;\n                case '-':\n                    f[i] -= g[i];\n                    break;\n                case '<':\n                    g[i] *= inv;\n                    break;\n                case '>':\n                    g[i] *= bse;\n                    break;\n                default:\n                    puts(\"dfcmd\");\n            }\n            mp[f[i]]++;\n        }\n        LL ans = 0;\n        for (int i = 1; i <= n; ++i) {\n            ans += mp[f[n] * g[i - 1] + f[i - 1]];\n            mp[f[i]]--;\n        }\n        writeln(ans);\n        return 0;\n    }\n}\n\nint main() {\n    return dfcmd::Main();\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"trapv\")\n#include<bits/stdc++.h>\n#define pb push_back\n#define all(x) x.begin(), x.end()\nusing namespace std;\nusing ll = long long;\nconst int maxn = 1<<20, mod = 119<<23|1;\nconst int B = 1000007;\nint n, pw[maxn], F[maxn], ps = 0, ans = 0;\nstring s;\nmap<int, int> cnt;\nvoid add(int &a, int b) {\n\ta = a+b>=mod?a+b-mod:a+b;\n}\nll bp(ll a, ll p) {\n\tll r = 1;\n\twhile(p) {\n\t\tif(p&1) r = r*a%mod;\n\t\ta = a*a%mod, p>>=1;\n\t}\n\treturn r;\n} \nsigned main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> n >> s;\n\tpw[0] = 1;\n\tfor(int i = 1; i < maxn; i++) pw[i] = pw[i-1]*1ll*B%mod;\n\tcnt[0]++;\n\tint cur = 0;\n\tfor(int i = 0; i < n; i++) {\n\t\tif(s[i] == '>') ps++;\n\t\tif(s[i] == '<') ps--;\n\t\tif(s[i] == '+') add(cur, pw[(maxn/2) + ps]);\n\t\tif(s[i] == '-') add(cur, mod-pw[(maxn/2) + ps]);\n\t\tF[i+1] = cur;\n\t\tcnt[cur]++;\n\t}\n\tps = 0;\n\tfor(int ccur = 0, ps = 0, i = 0; i <= n; i++) {\n\t\tcnt[F[i]]--;\n\t\tans += cnt[(bp(B, mod-1+ps)*1ll*cur + ccur)%mod];\n\t\tif(i == n) continue;\n\t\tif(s[i] == '>') ps++;\n\t\tif(s[i] == '<') ps--;\n\t\tif(s[i] == '+') add(ccur, pw[(maxn/2) + ps]);\n\t\tif(s[i] == '-') add(ccur, mod-pw[(maxn/2) + ps]);\n\t}\n\tcout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define FOR(a, b, c) for(int a = b; a <= c; ++a)\n#define pb push_back\n#define int long long\n\nconst int N = 250000;\nconst int MOD = 1e9 + 7;\nconst int MOD2 = 1e9 + 9;\nconst int base = 250000;\nconst int oo = 1e9;\ntypedef pair<int, int> ii;\nint n, wb0, wb1, pos = 250000, curpos[N], bpw[2][N + N];\nint has[2][N + N];\nstring s;\n\nvoid add(int &x, int val, int mod)  {  x = (x + val + 1ll * mod * mod) % mod;  }\nvoid mul(int &x, int y, int mod) { x = x * y % mod; x = (x + 1ll * mod * mod) % mod;}\nint pw(int x, int y, int mod)    {\n    int res = 1ll;\n    while(y)    {\n        if(y % 2 == 1) mul(res, x, mod);\n        mul(x, x, mod);\n        y /= 2;\n    }\n    return res;\n}\n\nmap<ii, int> cnt;\n\nsigned main()\n{\n    //freopen(\"test.inp\", \"r\", stdin);\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    cin >> n >> s;\n    //memset\n    bpw[0][0] = bpw[1][0] = 1ll;\n    FOR(i, 1, N + N - 1) {\n        bpw[0][i] = bpw[0][i - 1] * base % MOD;\n        bpw[1][i] = bpw[1][i - 1] * base % MOD2;\n    }\n    //cout << pw(base, N + 1, MOD) << '\\n';\n    //cout << bpw[0][N + 1] << ' ' << bpw[1][N + 1] << '\\n';\n    // we need to hash all the value of x\n    FOR(i, 1, n)    {\n        if(s[i - 1] == '+' || s[i - 1] == '-') {\n            add(has[0][i], has[0][i - 1] + ((s[i - 1] == '+') ? +1 : -1) * bpw[0][pos], MOD);\n            add(has[1][i], has[1][i - 1] + ((s[i - 1] == '-') ? -1 : +1 ) * bpw[1][pos], MOD2);\n        } else     {\n            pos += ((s[i - 1] == '>') ? 1 : -1);\n            has[0][i] = has[0][i - 1];\n            has[1][i] = has[1][i - 1];\n        }\n        //cout << has[0][i] << ' ' << has[1][i] << ' ' << pos << '\\n';\n        curpos[i] = pos - 250000;\n    } //cout << '\\n';\n\n    int s1 = 1ll * has[0][n] % MOD;\n    int s2 = 1ll * has[1][n] % MOD2;\n    //cout << has[0][3] << ' ' << (bpw[0][curpos[1]] * s1 + has[0][1]) % MOD << '\\n';\n    cnt[ ii(s1, s2) ] = 1;\n    int ans = 0;\n    FOR(i, 1, n)    {\n        ans += cnt[ ii(has[0][i], has[1][i]) ];\n        int n1 = (s1 * bpw[0][ curpos[i] ] + has[0][i] ) % MOD;\n        int n2 = (s2 * bpw[1][ curpos[i] ] + has[1][i]) % MOD2;\n        //cout << n1 << ' ' << n2 << '\\n';\n        cnt[ ii(n1, n2) ] ++;\n    }\n\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=250010;\ntypedef long long ll;\nconst ll mod=1000000000000000031ll,base=131,inv_base=68702290076335880ll;\n\nint n;\nll p[N],q[N];\nchar s[N];\nmap<ll,int> cnt;\n\nll add(ll a,ll b) {\n\treturn a+b>=mod?a+b-mod:a+b;\n}\n\nll mul(ll a,ll b) {\n\treturn (__int128)a*b%mod;\n}\n\nll qpow(ll a,ll b) {\n\tll ret=1;\n\twhile(b) {\n\t\tif(b&1) ret=mul(ret,a);\n\t\ta=mul(a,a),b>>=1;\n\t}\n\treturn ret;\n}\n\nint main() {\n\tcin>>n;scanf(\"%s\",s+1);\n\tp[0]=1;//cerr<<qpow(base,mod-2)<<endl;\n\tfor(int i=1;i<=n;i++) {\n\t\tp[i]=p[i-1],q[i]=q[i-1];\n\t\tif(s[i]=='+') q[i]=add(q[i],p[i]);\n\t\telse if(s[i]=='-') q[i]=add(q[i],mod-p[i]);\n\t\telse if(s[i]=='>') p[i]=mul(p[i],base);\n\t\telse p[i]=mul(p[i],inv_base);\n\t}\n\tll ans=0;\n\tfor(int i=n;i;i--) {\n\t\t++cnt[q[i]];\n\t\tans+=cnt[add(mul(q[n],p[i-1]),q[i-1])];\n\t}\n\tcout<<ans;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 100001;\n\npi operator+(const pi& l, const pi& r) {\n    return {(l.f+r.f)%MOD,(l.s+r.s)%MOD};\n}\n\npi operator-(const pi& l, const pi& r) {\n    return {(l.f-r.f+MOD)%MOD,(l.s-r.s+MOD)%MOD};\n}\n\npi operator*(const pi& l, const pi& r) {\n    return {(ll)l.f*r.f%MOD,(ll)l.s*r.s%MOD};\n}\n\npi base = mp(948392576,573928192), invbase = mp(499499562,829828935);\n\nll modpow(ll b, ll p) {\n    return !p?1:modpow(b*b%MOD,p/2)*(p&1?b:1)%MOD;\n}\n\nll inv(ll x) {\n    return modpow(x,MOD-2);\n}\n\nint N;\nstring S;\npi sum[250001], cur[250001];\nmap<pi,int> tmp;\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> N >> S;\n    \n    cur[0] = {1,1};\n    F0R(i,sz(S)) {\n        char c = S[i];\n        sum[i+1] = sum[i], cur[i+1] = cur[i];\n        if (c == '+') sum[i+1] = sum[i]+cur[i];\n        else if (c == '-') sum[i+1] = sum[i]-cur[i];\n        else if (c == '<') cur[i+1] = cur[i]*base;\n        else cur[i+1] = cur[i]*invbase;\n    }\n    ll ans = 0;\n    F0Rd(y,sz(S)+1) {\n        pi des = sum[sz(S)]*cur[y]+sum[y];\n        if (tmp.count(des)) ans += tmp[des];\n        tmp[sum[y]] ++;\n    }\n    cout << ans;\n    // sum[x] = sum[sz(S)]*cur[y]+sum[y]\n}\n\n// read the question correctly (is y a vowel? what are the exact constraints?)\n// look out for SPECIAL CASES (n=1?) and overflow (ll vs int?) ARRAY OUT OF BOUNDSS"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long lint;\n\nlint modpow(lint x, lint y, lint mod) {\n  lint ret = 1 % mod, x2p = x;\n  while (y > 0) {\n    if (y % 2) ret = (__int128)ret * x2p % mod;\n    y /= 2;\n    x2p = (__int128)x2p * x2p % mod;\n  }\n  return ret;\n}\nconstexpr int nmods = 2;\nconstexpr lint mod[] = {1152921504609811141LL, 4611676018431352883LL,\n                        4611676018431352883LL};\nconstexpr lint base[] = {102999959LL, 1073741663LL, 599831LL};\nlint inv_base[nmods];\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  string seq(n, ' ');\n  for (int i = 0; i < n; ++i)\n    scanf(\" %c\", &seq[i]);\n\n  vector<int> pos_before(n);\n\n  vector<vector<lint>> base_pow(nmods, vector<lint>(n + 1));\n  vector<vector<lint>> inv_base_pow(nmods, vector<lint>(n + 1));\n  vector<vector<lint>> hash_diff(nmods, vector<lint>(n, 0));\n  vector<vector<lint>> suffix(nmods, vector<lint>(n + 1));\n  vector<lint> full_seq_hash(nmods);\n  for (int k = 0; k < nmods; ++k) {\n    base_pow[k][0] = 1;\n    for (int i = 1; i <= n; ++i)\n      base_pow[k][i] = (__int128)base[k] * base_pow[k][i - 1] % mod[k];\n\n    inv_base[k] = modpow(base[k], mod[k] - 2, mod[k]);\n    assert((__int128)base[k] * inv_base[k] % mod[k] == 1);\n\n    inv_base_pow[k][0] = 1;\n    for (int i = 1; i <= n; ++i)\n      inv_base_pow[k][i] = (__int128)inv_base[k] * inv_base_pow[k][i - 1] % mod[k];\n\n    int pos = 0;\n    for (int i = 0; i < n; ++i) {\n      pos_before[i] = pos;\n      if (seq[i] == '>') ++pos;\n      else if (seq[i] == '<') --pos;\n      else {\n        lint base_pow_pos;\n        if (pos >= 0) base_pow_pos = base_pow[k][pos];\n        else base_pow_pos = inv_base_pow[k][-pos];\n        if (seq[i] == '+') hash_diff[k][i] = base_pow_pos;\n        else if (seq[i] == '-') {\n          hash_diff[k][i] = mod[k] - base_pow_pos;\n          assert(0 <= hash_diff[k][i]);\n          assert(hash_diff[k][i] < mod[k]);\n        } else assert(0);\n      }\n    }\n    full_seq_hash[k] = 0;\n    for (int i = 0; i < n; ++i) {\n      full_seq_hash[k] += hash_diff[k][i];\n      if (full_seq_hash[k] >= mod[k]) full_seq_hash[k] -= mod[k];\n    }\n\n    suffix[k][n] = 0;\n    for (int i = n - 1; i >= 0; --i) {\n      suffix[k][i] = hash_diff[k][i] + suffix[k][i + 1];\n      if (suffix[k][i] >= mod[k]) suffix[k][i] -= mod[k];\n    }\n  }\n\n  lint result = 0;\n  map<vector<lint>, int> count;\n  count[vector<lint>(nmods, 0LL)] += 1;\n  for (int i = n - 1; i >= 0; --i) {\n    vector<lint> shifted_full(nmods);\n    for (int k = 0; k < nmods; ++k) {\n      if (pos_before[i] >= 0) {\n        shifted_full[k] = (__int128)full_seq_hash[k] * base_pow[k][pos_before[i]] % mod[k];\n      } else {\n        shifted_full[k] = (__int128)full_seq_hash[k] * inv_base_pow[k][-pos_before[i]] % mod[k];\n      }\n    }\n\n    vector<lint> target(nmods);\n    for (int k = 0; k < nmods; ++k) {\n      target[k] = suffix[k][i] - shifted_full[k];\n      if (target[k] < 0) target[k] += mod[k];\n    }\n\n    auto it = count.find(target);\n    if (it != count.end())\n      result += it->second;\n\n    vector<lint> suffix_vec(nmods);\n    for (int k = 0; k < nmods; ++k)\n      suffix_vec[k] = suffix[k][i];\n\n    count[suffix_vec] += 1;\n  }\n  printf(\"%lld\\n\", result);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define Maxn 250007\n#define modp 998244353\n#define g Maxn\nusing namespace std;\nint n;\nchar s[Maxn];\nint a[Maxn*2],b[Maxn*2];\nint x,y;\nint bin[Maxn*2];\nmap<int,int> mp;\nint power(int a,int b)\n{\n\tint res=1,now=a,left=b;\n\twhile (left>0)\n\t{\n\t\tif (left%2==1) res=(1LL*res*now)%modp;\n\t\tleft/=2;\n\t\tnow=(1LL*now*now)%modp;\n\t}\n\treturn res;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",s+1);\n\tbin[0]=1;\n\tfor (int i=1;i<=2*n;i++)\n\t\tbin[i]=(1LL*bin[i-1]*g)%modp;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\ta[i]=a[i-1];\n\t\tb[i]=b[i-1];\n\t\tif (s[i]=='+') a[i]=(a[i]+bin[b[i]+n])%modp;\n\t\telse if (s[i]=='-') a[i]=(a[i]+modp-bin[b[i]+n])%modp;\n\t\telse if (s[i]=='>') ++b[i];\n\t\telse --b[i];\n\t}\n\tx=a[n];\n\tlong long ans=0;\n\tfor (int i=n;i;i--)\n\t{\n\t\tint now=(1LL*x*power(bin[b[i]+n],modp-2))%modp;\n\t\tnow=(now+a[i])%modp;\n\t\tans+=mp[now];\n\t\tmp[a[i]]++;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod=1012200221;\nint ran(){return rand()%1000*1000000+rand()%1000*1000+rand()%1000+1;}\n\nlong long ans;\nint n,v[9],inv[9];\nchar s[250010];\nstruct node{int nw[9];}c,fk[250010],fb[250010],O;\n\nbool operator <(node a,node b)\n{\n\tfor (int i=0; i<9; i++)\n\t{\n\t\tif (a.nw[i]<b.nw[i]) return 1;\n\t\tif (a.nw[i]>b.nw[i]) return 0;\n\t}\n\treturn 0;\n}\n\nmap<node,int> ma;\n\nnode f1(node x) \n{\n\tfor (int i=0; i<9; i++) x.nw[i]=(x.nw[i]==mod-1?0:x.nw[i]+1);\n\treturn x;\n}\n\nnode f2(node x)\n{\n\tfor (int i=0; i<9; i++) x.nw[i]=(x.nw[i]==0?mod-1:x.nw[i]-1);\n\treturn x;\n}\n\nnode f3(node x)\n{\n\tfor (int i=0; i<9; i++) x.nw[i]=1ll*x.nw[i]*v[i]%mod;\n\treturn x;\n}\n\nnode f4(node x)\n{\n\tfor (int i=0; i<9; i++) x.nw[i]=1ll*x.nw[i]*inv[i]%mod;\n\treturn x;\n}\n\nnode operator +(node a,node b)\n{\n\tfor (int i=0; i<9; i++) a.nw[i]=(a.nw[i]+b.nw[i]>=mod?a.nw[i]+b.nw[i]-mod:a.nw[i]+b.nw[i]);\n\treturn a;\n}\n\nnode operator -(node a,node b)\n{\n\tfor (int i=0; i<9; i++) a.nw[i]=(a.nw[i]<b.nw[i]?a.nw[i]-b.nw[i]+mod:a.nw[i]-b.nw[i]);\n\treturn a;\n}\n\nnode operator *(node a,node b)\n{\n\tfor (int i=0; i<9; i++) a.nw[i]=1ll*a.nw[i]*b.nw[i]%mod;\n\treturn a;\n}\n\nint quickmi(int a,int b)\n{\n\tint t=1;\n\tfor (; b; b>>=1,a=1ll*a*a%mod)\n\t\tif (b&1) t=1ll*t*a%mod;\n\treturn t;\n}\n\nint main()\n{\n\tsrand(114514),O=(node){{0,0,0,0,0,0,0,0,0}};\n\tfor (int i=0; i<9; i++) v[i]=ran(),inv[i]=quickmi(v[i],mod-2);\n\tscanf(\"%d%s\",&n,s+1),c=O;\n\tfor (int i=n; i; i--)\n\t\tif (s[i]=='+') c=f1(c); else\n\t\tif (s[i]=='-') c=f2(c); else\n\t\tif (s[i]=='>') c=f3(c); else\n\t\tif (s[i]=='<') c=f4(c);\n\tfk[n+1]=f1(O),fb[n+1]=O;\n\tfor (int i=n; i; i--)\n\t\tif (s[i]=='+') fb[i]=(fb[i+1]-fk[i+1]),fk[i]=fk[i+1]; else\n\t\tif (s[i]=='-') fb[i]=(fb[i+1]+fk[i+1]),fk[i]=fk[i+1]; else\n\t\tif (s[i]=='>') fb[i]=fb[i+1],fk[i]=f4(fk[i+1]); else\n\t\tif (s[i]=='<') fb[i]=fb[i+1],fk[i]=f3(fk[i+1]);\n\tma.clear(),ans=0;\n\tfor (int i=n; i; i--)\n\t{\n\t\tma[fb[i+1]]++;\n\t\tans+=ma[(fk[i]*c)+fb[i]];\n\t}\n\treturn printf(\"%lld\\n\",ans),0;\n}"
  },
  {
    "language": "C++",
    "code": "// AtCoder Regular Contest 099\n// Problem F - Eating Symbols Hard\n#include <cstdio>\n#include <cstring>\n#include <iostream>\nusing std::cin; using std::cout; using std::endl;\n#include <algorithm>\nusing std::sort;\n#include <vector>\nusing std::vector;\n#include <queue>\nusing std::queue; using std::priority_queue;\n#include <map>\nusing std::map;\n#include <utility>\nusing std::pair;\ntypedef pair<int, int> pii;\ntypedef long long LL;\n#define pass printf(\"%s : Line.%d\\n\", __FUNCTION__, __LINE__);\nconst int maxN = 250000 + 233; // 2.5e5\nint n;\nchar opt[maxN];\nint d[maxN], df; LL h1[maxN], hf1, h2[maxN], hf2;\n//const LL P = 1e9 + 7;\nbool isp(LL x) {\n\tfor(int i = 2; i*i <= x; ++i)\n\t\tif(x % i == 0) return false;\n\treturn true;\n}\nconst LL p1 = 1000000007;\nconst LL p2 = 1000000123;\nconst LL b1 = 109;\nconst LL b2 = 101;\nLL buc1[maxN*2], buc2[maxN*2];\nLL *pow1 = &buc1[maxN], *pow2 = &buc2[maxN];\nLL inv(LL x, LL p1) {\n\treturn x == 1 ? x : (p1 - (p1 / x) * inv(p1 % x, p1)) % p1;\n}\nLL inc(LL &a, LL b1, LL p1) { return (a += b1) >= p1 ? a -= p1 : a; }\nLL dec(LL &a, LL b1, LL p1) { return (a -= b1) < 0 ? a += p1 : a; }\nmap<pii, int> M;\n\nvoid init() {\n\tpow1[0] = 1; pow2[0] = 1;\n\tpow1[1] = b1; pow1[-1] = inv(b1, p1); pow2[1] = b2; pow2[-1] = inv(b2, p2);\n\tfor(int i = 1; i <= n; ++i) pow1[i] = pow1[i-1] * b1 % p1, pow2[i] = pow2[i-1] * b2 % p2;\n\tfor(int i = -1; i >= -n; --i) pow1[i] = pow1[i+1]* pow1[-1] % p1, pow2[i] = pow2[i+1]* pow2[-1] % p2;\n\thf1 = hf2 = df = 0;\n\tfor(int i = 1; i <= n; ++i) {\n\t\tswitch(opt[i]) {\n\t\t\tcase '+':\n\t\t\t\tinc(hf1, pow1[df], p1);\n\t\t\t\tinc(hf2, pow2[df], p2);\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tdec(hf1, pow1[df], p1);\n\t\t\t\tdec(hf2, pow2[df], p2);\n\t\t\t\tbreak;\n\t\t\tcase '>':\n\t\t\t\t++df;\n\t\t\t\tbreak;\n\t\t\tcase '<':\n\t\t\t\t--df;\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main() {\n//\tfor(int i = (int)1e9; ; ++i) if(isp(i)) printf(\"%d\\n\", i), getchar();\n//\tprintf(\"%.3lfMB\\n\", sizeof(buc1)*6/1000.0/1000.0);\n\tscanf(\"%d%s\", &n, opt + 1);\n\tinit();\n\tLL cnt = 0;\n\tM.clear();\n\th1[0] = h2[0] = d[0] = 0;\n\tM[pii((h1[0] + hf1 * pow1[d[0]]) % p1, (h2[0] + hf2 * pow2[d[0]]) % p2)] = 1;\n\tfor(int i = 1; i <= n; ++i) {\n\t\td[i] = d[i-1]; h1[i] = h1[i-1]; h2[i] = h2[i-1];\n\t\tswitch(opt[i]) {\n\t\t\tcase '+':\n\t\t\t\tinc(h1[i], pow1[d[i]], p1);\n\t\t\t\tinc(h2[i], pow2[d[i]], p2);\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tdec(h1[i], pow1[d[i]], p1);\n\t\t\t\tdec(h2[i], pow2[d[i]], p2);\n\t\t\t\tbreak;\n\t\t\tcase '>':\n\t\t\t\t++d[i];\n\t\t\t\tbreak;\n\t\t\tcase '<':\n\t\t\t\t--d[i];\n\t\t\t\tbreak;\n\t\t}\n\t\tpii c(h1[i], h2[i]), ins((h1[i] + hf1 * pow1[d[i]]) % p1, (h2[i] + hf2 * pow2[d[i]]) % p2);\n\t\tif(M.find(c) != M.end()) cnt += M[c]/*, printf(\"i = %d, cnt += %d\\n\", i, M[h1[i]])*/;\n\t\tif(M.find(ins) == M.end()) M[ins] = 1; else ++M[ins];\n\t}\n\tprintf(\"%lld\\n\", cnt);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "    #include \"bits/stdc++.h\"\n    using namespace std;\n     \n    #define MAX 500012\n     \n    int n;\n    char buf[MAX];\n     \n     \n    string s;\n     \n     \n    //#define MOD1 1000000007\n    //#define MOD2 1000000009\n     \n    valarray<long long int> MOD1;\n    valarray<long long int> MOD2;\n    vector<valarray<long long int> > p2;\n    vector<valarray<long long int> > vv;\n    vector<int> ps;\n    map<pair<long long int,long long int>, int> mp;\n    long long int ppow(long long int i, long long int j, long long int MOD) {\n    \tlong long int ret = 1;\n    \twhile (j) {\n    \t\tif (j & 1LL)ret *= i;\n    \t\tif (ret >= MOD)ret %= MOD;\n    \t\tj >>= 1LL;\n    \t}\n    \treturn ret;\n    }\n     \n    valarray<long long int> calc(int dif) {\n    \tvalarray<long long int> ret;\n    \tret.resize(2, 0);\n    \tfor (int j = 0; j < 2; j++) {\n    \t\tif (dif < 0) {\n    \t\t\tret[j]=ppow(ppow(MOD1[j], abs(dif),MOD2[j]), MOD2[j] - 2,MOD2[j]);\n    \t\t}\n    \t\telse {\n    \t\t\tret[j] = ppow(MOD1[j], abs(dif), MOD2[j]);\n    \t\t}\n    \t}\n    \treturn ret;\n    }\n     \n    int main() {\n    \tMOD1.resize(2);\n    \tMOD2.resize(2);\n    \tp2.push_back(valarray<long long int>());\n    \tp2.back().resize(2);\n    \tp2.back()[0] = p2.back()[1] = 1;\n    \tMOD2[0] = 1000000007;\n    \tMOD1[0] = 998244353;\n    \tMOD1[1] = 555522277;\n    \tMOD2[1] = 1000000009;\n    \tp2[0] %= MOD2;\n    \tfor (int i = 1; i < MAX; i++) {\n    \t\tp2.push_back(p2.back());\n    \t\tp2[i] *= MOD1;\n    \t\tp2[i] %= MOD2;\n    \t}\n    \tcin >> n;\n    \tscanf(\"%s\", buf);\n    \ts = buf;\n    \tint pos = MAX/2;\n    \tvalarray<long long int> hs;\n    \ths.resize(2);\n    \ths[0] = hs[1] = 0;\n    \tvv.push_back(hs);\n    \tps.push_back(pos);\n    \tfor (int i = 0; i < s.size(); i++) {\n    \t\tif (s[i] == '<') {\n    \t\t\tpos--;\n    \t\t}\n    \t\tif (s[i] == '>') {\n    \t\t\tpos++;\n    \t\t}\n    \t\tif (s[i] == '+') {\n    \t\t\ths += p2[pos];\n    \t\t}\n    \t\tif (s[i] == '-') {\n    \t\t\ths -= p2[pos];\n    \t\t\ths += MOD2;\n    \t\t}\n    \t\ths %= MOD2;\n    \t\tvv.push_back(hs);\n    \t\tps.push_back(pos);\n    \t}\n    \tlong long int way = 0;\n    \tfor (int i = vv.size() - 1; i >= 0; i--) {\n    \t\tvalarray<long long int> want = vv[i] + vv.back()*calc(-MAX/2+ps[i]);\n    \t\twant = want%MOD2;\n    \t\tway += mp[make_pair(want[0], want[1])];\n    \t\t//cerr << \"dbg \" << way << endl;\n    \t\tif(want[0]<0LL||want[1]<0LL)exit(1);\n    \t\tif(vv[i][0]<0LL||want[1]<0LL)exit(1);\n    \t\tmp[make_pair(vv[i][0],vv[i][1])]++;\n    \t}\n    \tprintf(\"%lld\\n\", way);\n    \treturn 0;\n    }"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<iostream>\n#define LL long long\n#define MP make_pair\nusing namespace std;\nconst LL mod=1e9+7;\nLL base[8],pre[8][500010],inv[8];\nstruct node{LL a,b;}op[8][250010];\nmap<\n\tpair<\n\tpair<pair<LL,LL>,pair<LL,LL> >,\n\tpair<pair<LL,LL>,pair<LL,LL> > >\n,LL> mp;\nLL pow(LL a,LL b)\n{\n\tLL ans=1;\n\twhile(b)\n\t{\n\t\tif(b&1) ans=ans*a%mod;\n\t\ta=a*a%mod;b>>=1;\n\t}\n\treturn ans;\n}\nLL n,p=0,t[500010],c[8],a[8][250010],b[8][250010];\nchar s[250010];\nvoid Pre()\n{\n\tfor(int k=0;k<8;k++)\n\t{\n\t\tLL cnt=1;op[k][n+1].a=1;\n\t\tfor(LL i=n;i>=1;i--)\n\t\t{\n\t\t\top[k][i]=op[k][i+1];\n\t\t\tif(s[i]=='<') cnt=cnt*base[k]%mod,(op[k][i].a*=base[k])%=mod;\n\t\t\tif(s[i]=='>') cnt=cnt*inv[k]%mod,(op[k][i].a*=inv[k])%=mod;\n\t\t\tif(s[i]=='-') (op[k][i].b+=cnt*pre[k][n]%mod)%=mod;\n\t\t\tif(s[i]=='+') op[k][i].b=((op[k][i].b-cnt*pre[k][n]%mod)%mod+mod)%mod;\n\t\t}\n\t}\n}\nvoid solve(LL *a,LL c,LL k) {for(LL i=1;i<=n;i++) a[i]=(c*op[k][i].a%mod+op[k][i].b)%mod;}\nint main()\n{\n\tbase[0]=12281;base[1]=92083;base[2]=12255871;base[3]=998244353;\n\tbase[4]=291143;base[5]=16341163;base[6]=9209;base[7]=113;\n\tfor(int i=0;i<8;i++) inv[i]=pow(base[i],mod-2);\n\tscanf(\"%lld\",&n);getchar();\n\tscanf(\"%s\",s+1);\n\tfor(LL k=0;k<8;k++)\n\t{\n\t\tpre[k][0]=1;for(LL i=1;i<=2*n;i++) pre[k][i]=pre[k][i-1]*base[k]%mod;\n\t}\n\tfor(LL i=1;i<=n;i++)\n\t{\n\t\tif(s[i]=='<') p--;if(s[i]=='>') p++;\n\t\tif(s[i]=='-') t[p+n]--;if(s[i]=='+') t[p+n]++;\n\t}\n\tfor(int k=0;k<8;k++)\n\t\tfor(LL i=-n;i<=n;i++) (c[k]+=pre[k][i+n]*t[i+n]%mod)%=mod;\n\tPre();\n\tfor(int i=0;i<8;i++) solve(a[i],0,i);\n\tfor(int i=0;i<8;i++) solve(b[i],c[i],i);\n\tLL ans=0;\n\tfor(LL i=2;i<=n+1;i++)\n\t{\n\t\tmp[\n\t\tMP(\n\t\tMP(MP(b[0][i-1],b[1][i-1]),MP(b[2][i-1],b[3][i-1])),\n\t\tMP(MP(b[4][i-1],b[5][i-1]),MP(b[6][i-1],b[7][i-1]))\n\t\t)]++;\n\t\tans+=mp[\n\t\tMP(\n\t\tMP(MP(a[0][i],a[1][i]),MP(a[2][i],a[3][i])),\n\t\tMP(MP(a[4][i],a[5][i]),MP(a[6][i],a[7][i]))\n\t\t)];\n\t}\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<map>\ntypedef long long ll;\ntypedef double dd;\ntypedef __int128 I;\n#define For(i,j,k) for (int i=(int)j;i<=(int)k;++i)\n#define Forr(i,j,k) for (int i=(int)j;i>=(int)k;--i)\n#define Set(a,p) memset(a,p,sizeof(a))\nusing namespace std;\n\ntemplate<typename T>bool chkmax(T &a,T b) { return a<b?a=b,1:0; }\ntemplate<typename T>bool chkmin(T &a,T b) { return a>b?a=b,1:0; }\n\nconst int maxn=250000+100;\nconst ll modd=1000000000000000031ll;\nconst ll p1=1000000000000000003ll;\nconst ll p2=821428571428571454ll;\nint n;\nint Ans;\nll p[maxn],a[maxn];\nchar s[maxn];\nmap<ll,int>ma;\n\ninline void file() {\n\tfreopen(\"ARC099F.in\",\"r\",stdin);\n\tfreopen(\"ARC099F.out\",\"w\",stdout);\n}\n\nint main() {\n//\tfile();\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",s+1);\n\tp[0]=1;\n\tFor (i,1,n) {\n\t\tp[i]=p[i-1]; a[i]=a[i-1];\n\t\tif (s[i]=='+') (a[i]+=p[i])%=modd;\n\t\tif (s[i]=='-') (a[i]+=modd-p[i])%=modd;\n\t\tif (s[i]=='>') p[i]=(I)p[i]*p1%modd;\n\t\tif (s[i]=='<') p[i]=(I)p[i]*p2%modd;\n\t}\n\tForr (i,n,1) {\n\t\t++ma[a[i]];\n\t\tAns+=ma[((I)a[n]*p[i-1]%modd+a[i-1])%modd];\n\t}\n\tprintf(\"%d\",Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\nconst ull base=998244353ull;\nconst ull invr=996491785301655553ull;\nconst int maxn=2.5e5+3;\nconst int maxl=5e5+10;\nnamespace num {\n\tull _mi[maxl],*mi=_mi+maxn;\n\tvoid init() {\n\t\tmi[0]=1;\n\t\tfor (int i=1;i<maxn;++i) mi[i]=mi[i-1]*base;\n\t\tfor (int i=1;i<maxn;++i) mi[-i]=mi[-i+1]*invr;\n\t}\n\tint __initer__=(init(),0);\n}\nint n;\nchar s[maxn];\nmap<ull,int> mp;\nnamespace has {\n\tull val[maxn],cur=0;\n\tint pos[maxn];\n\tvoid deal(int &p,char c) {\n\t\tif (c=='<') --p; else\n\t\tif (c=='>') ++p; else\n\t\tif (c=='+') cur+=num::mi[p]; else\n\t\tif (c=='-') cur-=num::mi[p]; else\n\t\tassert(false);\n\t}\n\tull work() {\n\t\tint p=0;\n\t\tfor (int i=1;i<=n;++i) {\n\t\t\tdeal(p,s[i]);\n\t\t\tval[i]=cur;\n\t\t\tpos[i]=p;\n\t\t}\n\t\treturn cur;\n\t}\n}\nint main() {\n\tscanf(\"%d%s\",&n,s+1);\n\tull all=has::work(),ans=0;\n\tfor (int i=n;i>=0;--i) {\n\t\tull tmp=all*num::mi[has::pos[i]]+has::val[i];\n\t\tans+=mp[tmp];\n\t\t++mp[has::val[i]];\n\t}\n\tprintf(\"%llu\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MN 250000\n#define mod 1004535809\n#define mod2 1000000007\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nchar s[MN+5];\nmap<int,int> mp,mp2;long long ans;\nint n,pw[MN*2+5],invpw[MN*2+5],pw2[MN*2+5],invpw2[MN*2+5];\nint Ha[MN+5],pos[MN+5],ha[MN+5];\ninline int PW(int x){return x>=0?pw[x]:invpw[-x];}\ninline int PW2(int x){return x>=0?pw2[x]:invpw2[-x];}\nint main()\n{\n\tn=read();scanf(\"%s\",s+1);pw[0]=invpw[0]=pw2[0]=invpw2[0]=1;\n\tfor(int i=1;i<=n*2;++i) \n\t\tpw[i]=786433LL*pw[i-1]%mod,invpw[i]=317967460LL*invpw[i-1]%mod,\n\t\tpw2[i]=5767169LL*pw2[i-1]%mod2,invpw[i]=170959791LL*invpw2[i-1]%mod2;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tif(s[i]=='<'||s[i]=='>') \n\t\t\tpos[i]=pos[i-1]+(s[i]=='<'?-1:1),\n\t\t\tha[i]=ha[i-1],Ha[i]=Ha[i-1];\n\t\telse pos[i]=pos[i-1],\n\t\t\tha[i]=(ha[i-1]+1LL*(s[i]=='+'?1:mod-1)*pw[pos[i]+n])%mod,\n\t\t\tHa[i]=(Ha[i-1]+1LL*(s[i]=='+'?1:mod2-1)*pw2[pos[i]+n])%mod2;\n\t}\n\tfor(int i=n;i;--i)\n\t{\n\t\t++mp[(ha[n]-ha[i]+mod)%mod];\n\t\t++mp2[(Ha[n]-Ha[i]+mod2)%mod2];\n\t\tans+=min(mp[(1LL*ha[n]*(mod+1-PW(pos[i-1]))+mod-ha[i-1])%mod],\n\t\t\t     mp2[(1LL*Ha[n]*(mod2+1-PW2(pos[i-1]))+mod2-Ha[i-1])%mod2]);\n\t}\n\tcout<<ans;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\n\ntypedef long long LL;\nconst int Mod[2] = {999988679, 999988609};\nconst int B[2] = {370728, 370732};\nconst int iB[2] = {396903752, 462741403};\nconst int MN = 250005;\n\ninline void Add(int &x, int y, int i) { x -= (x += y) >= Mod[i] ? Mod[i] : 0; }\n\nint N;\nchar S[MN];\nint A[2][MN], D[2][MN];\nstd::map<std::pair<int, int>, int> Buk;\nLL Ans;\n\nint main() {\n\tscanf(\"%d%s\", &N, S + 1);\n\tfor (int j = 0; j < 2; ++j) A[j][0] = 0, D[j][0] = 1;\n\tfor (int i = 1, V[2] = {1, 1}; i <= N; ++i) {\n\t\tfor (int j = 0; j < 2; ++j) {\n\t\t\tA[j][i] = A[j][i - 1];\n\t\t\tif (S[i] == '+') Add(A[j][i], V[j], j);\n\t\t\tif (S[i] == '-') Add(A[j][i], Mod[j] - V[j], j);\n\t\t\tif (S[i] == '>') V[j] = (LL)V[j] * B[j] % Mod[j];\n\t\t\tif (S[i] == '<') V[j] = (LL)V[j] * iB[j] % Mod[j];\n\t\t\tD[j][i] = V[j];\n\t\t}\n\t}\n\tfor (int i = N; i >= 0; --i) {\n\t\tAns += Buk[{\n\t\t\t(A[0][i] + (LL)A[0][N] * D[0][i]) % Mod[0],\n\t\t\t(A[1][i] + (LL)A[1][N] * D[1][i]) % Mod[1]\n\t\t}];\n\t\t++Buk[{A[0][i], A[1][i]}];\n\t}\n\tprintf(\"%lld\\n\", Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=1e9+7;\nint qpow(int x,int k)\n{\n    int r=1;\n    while(k)\n    {\n        if(k&1)r=1ll*r*x%mod;\n        k>>=1;x=1ll*x*x%mod;\n    }\n    return r;\n}\nint add(int x,int y){return x+y<mod?x+y:x+y-mod;}\nint n;\nchar s[300300];\n\nint X[6]={233,1919,114514,817,1001,9527};\nint inv[6];\nstruct Node {\n    int v[6];\n    bool operator < (const Node &o)const{\n        for(int i=0;i<6;++i)\n            if(v[i]!=o.v[i])return v[i]<o.v[i];\n        return 0;\n    }\n    void clear(){memset(v,0,sizeof(v));}\n    void f(char c)\n    {\n        if(c=='+') for(int i=0;i<6;++i)v[i]=add(v[i],1);\n        else if(c=='-') for(int i=0;i<6;++i)v[i]=add(v[i],mod-1);\n        else if(c=='>') for(int i=0;i<6;++i)v[i]=1ll*v[i]*X[i]%mod;\n        else if(c=='<') for(int i=0;i<6;++i)v[i]=1ll*v[i]*inv[i]%mod;\n    }\n};\nmap<Node,int>mp;\nstruct PNN{\n    Node k,b;\n    void clear() { for(int i=0;i<6;++i)k.v[i]=1,b.v[i]=0; }\n    void f(char c)\n    {\n        if(c=='+')for(int i=0;i<6;++i)b.v[i]=add(b.v[i],mod-k.v[i]);\n        else if(c=='-')for(int i=0;i<6;++i)b.v[i]=add(b.v[i],k.v[i]);\n        else if(c=='>')for(int i=0;i<6;++i)k.v[i]=1ll*k.v[i]*inv[i]%mod;\n        else if(c=='<')for(int i=0;i<6;++i)k.v[i]=1ll*k.v[i]*X[i]%mod;\n    }\n    Node calc(Node x)\n    {\n        Node res;\n        for(int i=0;i<6;++i)\n            res.v[i]=add(1ll*k.v[i]*x.v[i]%mod,b.v[i])%mod;\n        return res;\n    }\n};\nint main()\n{\n    for(int i=0;i<6;++i)inv[i]=qpow(X[i],mod-2);\n    scanf(\"%d\",&n);\n    scanf(\"%s\",s+1);\n    Node C;C.clear();\n    for(int i=n;i;--i)C.f(s[i]);\n    Node o;o.clear();\n    mp[o]++;\n    PNN cur;cur.clear();\n    long long ans=0;\n    for(int i=n;i;--i)\n    {\n        cur.f(s[i]);\n        Node tt=cur.calc(C);\n        ans+=mp[cur.calc(C)];\n        mp[cur.calc(o)]++;\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nint mod_pow(int a, ll b)\n{\n    int res = 1;\n    while(b){\n        if(b & 1){\n            res = (ll)res * a % MOD;\n        }\n        a = (ll)a * a % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nint add(int x,int y)\n{\n    return (x + y)%MOD;\n}\n\nint sub(int x,int y)\n{\n    return (x+MOD-y)%MOD;\n}\n\nint mul(int x,int y)\n{\n    return (ll)x*y%MOD;\n}\n\n#define mul0 10009\nstruct RollingHash {\n\tstatic vector<int> pmo;\n\tint n, sz, res; vector<int> hash;\n    RollingHash(int _n) : n(_n), sz(2*n+2), res(0){\n        hash.resize(sz+1,0), hash[0] = 1;\n\t\tif(pmo.empty()) pmo.pb(1);\n\t\trep(i,sz) hash[i+1]=((ll)hash[i]*mul0)%MOD;\n    }\n    int calc(int id, bool pl){\n        if(pl) res = add(res, hash[id+n+1]);\n        else res = sub(res, hash[id+n+1]);\n        return res;\n    }\n};\nvector<int> RollingHash::pmo;\n\nmap<int, int> mp;\nvector<int> vec;\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    string s;\n    cin >> s;\n    RollingHash rh(n);\n    int p = 0;\n    rep(i,n){\n        if(s[i] == '+'){\n            vec.pb(rh.calc(p, true));\n        }else if(s[i] == '-'){\n            vec.pb(rh.calc(p, false));\n        }else if(s[i] == '>'){\n            vec.pb(vec.back());\n            p++;\n        }else{\n            vec.pb(vec.back());\n            p--;\n        }\n        mp[vec.back()]++;\n    }\n    int val = vec.back();\n    ll ans = 0;\n    int A = 1, B = 0;\n    auto& hash = rh.hash;\n    rep(i,n){\n        ans += mp[mul(sub(val, B), mod_pow(A, MOD-2))];\n        mp[vec[i]]--;\n        if(s[i] == '+'){\n            B = sub(B, hash[n+1]);\n        }else if(s[i] == '-'){\n            B = add(B, hash[n+1]);\n        }else if(s[i] == '>'){\n            int hoge = mod_pow(mul0, MOD-2);\n            A = mul(A, hoge), B = mul(B, hoge);\n        }else{\n            A = mul(A, mul0), B = mul(B, mul0);\n        }\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<map>\nusing namespace std;\nconst int MAXN=250005,MOD1=1000000007,MOD2=1000000009,BASE=10007,INV1=820925358,INV2=74148097;\n\nint PowMod(int a,int b,int P)\n{\n\tint ret=1;\n\twhile(b)\n\t{\n\t\tif(b&1)\n\t\t\tret=(1LL*ret*a)%P;\n\t\tb>>=1;\n\t\ta=(1LL*a*a)%P;\n\t}\n\treturn ret;\n}\n\nstruct Hash\n{\n\tint a,b;\n\tHash(){}\n\tHash(int a,int b):a(a),b(b){}\n\tHash operator + (Hash y)\n\t{return Hash((a+y.a)%MOD1,(b+y.b)%MOD2);}\n\tHash operator - (Hash y)\n\t{return Hash((a-y.a+MOD1)%MOD1,(b-y.b+MOD2)%MOD2);}\n\tHash operator * (Hash y)\n\t{return Hash((1LL*a*y.a)%MOD1,(1LL*b*y.b)%MOD2);}\n\tbool operator < (Hash y)const\n\t{return a<y.a||(a==y.a&&b<y.b);}\n};\n\nint N;\nchar S[MAXN];\nHash P[MAXN],op[MAXN];\n\nmap<Hash,int> cnt;\n\nint main()\n{\n\t//printf(\"%d\\n\",PowMod(BASE,MOD1-2,MOD1));\n\t//printf(\"%d\\n\",PowMod(BASE,MOD2-2,MOD2));\n\tscanf(\"%d%s\",&N,S+1);\n\tP[0]=Hash(1,1);\n\tfor(int i=1;i<=N;i++)\n\t{\n\t\tP[i]=P[i-1];op[i]=op[i-1];\n\t\tif(S[i]=='<')\n\t\t\tP[i]=P[i]*Hash(INV1,INV2);\n\t\tif(S[i]=='>')\n\t\t\tP[i]=P[i]*Hash(BASE,BASE);\n\t\tif(S[i]=='+')\n\t\t\top[i]=op[i]+P[i];\n\t\tif(S[i]=='-')\n\t\t\top[i]=op[i]-P[i];\n\t}\n\t\n\tlong long ans=0;\n\tfor(int i=N;i>=1;i--)\n\t{\n\t\tcnt[op[i]]++;\n\t\tans+=cnt[op[N]*P[i-1]+op[i-1]];\n\t}\n\t\n\tprintf(\"%lld\\n\",ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define MAX 250002\nint n;\n\nchar buf[MAX];\n\n__int128 mod1=1000000007LL;\n__int128 mod2=1000000000000000003LL;\n\ninline __int128 mul(__int128 a,__int128 b){\n\treturn a*b%mod2;\n}\ninline __int128 add(__int128 a,__int128 b){\n\tauto f=a+b;\n\tif(f>=mod2)f-=mod2;\n\treturn f;\n}\ninline __int128 sub(__int128 a,__int128 b){\n\tauto f=a-b;\n\tif(f<0)f+=mod2;\n\treturn f;\n}\n__int128 ppow(__int128 a,__int128 b){\n\t__int128 res=1;\n\twhile(b){\n\t\tif(b&1LL)res*=a;\n\t\tif(res>=mod2)res%=mod2;\n\t\tb>>=1LL;\n\t}\n\treturn res;\n}\nunordered_map<long long int,int> cnt;\nvector<pair<__int128,__int128> > v;\nint main() {\n\tcin>>n;\n\tscanf(\"%s\",buf);\n\tauto inv=ppow(mod1,mod2-2);\n\t__int128 cur=1;\n\t__int128 cinv=1;\n\t__int128 hs=0;\n\tint sz=strlen(buf);\n\tv.push_back(make_pair(0,1));\n\tfor(int i=0;i<sz;i++){\n\t\tif(buf[i]=='<'){\n\t\t\tcur=mul(cur,inv);\n\t\t\tcinv=mul(cur,mod1);\n\t\t}\n\t\tif(buf[i]=='>'){\n\t\t\tcur=mul(cur,mod1);\n\t\t\tcinv=mul(cur,inv);\n\t\t}\n\t\tif(buf[i]=='+'){\n\t\t\ths=add(hs,cur);\n\t\t}\n\t\tif(buf[i]=='-'){\n\t\t\ths=sub(hs,cur);\n\t\t}\n\t\tv.push_back(make_pair(hs,cur));\n\t}\n\t__int128 acieve=mul(v.back().first,cinv);\n\t//(c-x)*second=acieve\n\t//c-x=acieve/second\n\t//c-acieve/second=x\n\tlong long int way=0;\n\tfor(int i=0;i<v.size();i++){\n\t\t__int128 want=sub(v[i].first,mul(acieve,v[i].second));\n\t\tway+=cnt[want];\n\t\tcnt[v[i].first]++;\n\t}\n\tprintf(\"%lld\\n\",way);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define fst first\n#define snd second\n#define SZ(u) ((int) (u).size())\n#define ALL(u) (u).begin(), (u).end()\n\ninline void proc_status()\n{\n    ifstream t(\"/proc/self/status\");\n    cerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline T read()\n{\n\tregister T sum(0), fg(1);\n\tregister char ch(getchar());\n\tfor(; !isdigit(ch); ch = getchar()) if(ch == '-') fg = -1;\n\tfor(;  isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) - '0' + ch;\n\treturn sum * fg;\n}\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int, int> pii;\n\nconst int MAXN = (int) 2.5e5;\n\nint n;\n\nchar s[MAXN + 5];\n\ninline void input()\n{\n\tn = read<int>();\n\tscanf(\"%s\", s + 1);\n}\n\nconst int MOD = 998244353, B = (int) 233;\n\ninline int fpm(int x, int y)\n{\n\tint res = 1;\n\tfor(; y; y >>= 1, x = (LL) x * x % MOD) if(y & 1) res = (LL) res * x % MOD;\n\treturn res;\n}\n\ninline void solve()\n{\n\t// Thanks to zhou888\n\n\tstatic int p[MAXN + 5], prefix[MAXN + 5], p_pow[MAXN * 2 + 5];\n\n\tp_pow[0 + n] = 1;\n\tfor(int i = 1, invB = fpm(B, MOD - 2); i <= n; ++i)\n\t{\n\t\tp_pow[ i + n] = (LL) p_pow[ i - 1 + n] *\tB % MOD;\n\t\tp_pow[-i + n] = (LL) p_pow[-i + 1 + n] * invB % MOD;\n\t}\n\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tp[i] = p[i - 1], prefix[i] = prefix[i - 1];\n\t\tif(s[i] == '<') --p[i];\n\t\tif(s[i] == '>') ++p[i];\n\t\tif(s[i] == '+') (prefix[i] += p_pow[p[i] + n]) %= MOD;\n\t\tif(s[i] == '-') (prefix[i] -= p_pow[p[i] + n]) %= MOD;\n\t}\n\tfor(int i = 1; i <= n; ++i) (prefix[i] += MOD) %= MOD;\n\n\tstatic unordered_map<int, int> cnt;\n\n\tLL ans = 0;\n\tfor(int i = 1; i <= n; ++i) ans += prefix[i] == prefix[n];\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tans += cnt[prefix[i]];\n\t\tint res = (prefix[i] + (LL) p_pow[p[i] + n] * prefix[n] % MOD) % MOD;\n\t\t++cnt[res];\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main()\n{\n//\tfreopen(\"F.in\", \"r\", stdin);\n//\tfreopen(\"F.out\", \"w\", stdout);\n\n\tinput();\n\tsolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e6+5;\nconst int mod=1e9+7;\nconst int P=19260817;\n#define ll long long\nll fsp(ll x,int y){\n\tll ans=1;\n\twhile(y){\n\t\tif(y&1)\tans=ans*x%mod;\n\t\tx=x*x%mod,y>>=1;\n\t}\n\treturn ans;\n}\nchar s[N];\nmap<int,int>ma;\nll n,l1,l2=1,ans,res,add,inv,b[N];\nint main(){\n\tscanf(\"%lld%s\",&n,s+1),add=fsp(P,n);\n\tb[0]=1,inv=fsp(P,mod-2);\n\tfor(int i=n;i;i--){\n\t\tif(s[i]=='-')\tres=(res-add+mod)%mod;\n\t\tif(s[i]=='+')\tres=(res+add)%mod;\n\t\tif(s[i]=='<')\tres=res*inv%mod;\n\t\tif(s[i]=='>')\tres=res*P%mod;\n\t}\n\tfor(int i=n;i;i--){\n\t\tll k=0;\n\t\tif(s[i]=='-')\tl1=(l1-add+mod)%mod,k=mod-add;\n\t\tif(s[i]=='<')\tl1=l1*inv%mod,l2=l2*inv%mod;\n\t\tif(s[i]=='>')\tl1=l1*P%mod,l2=l2*P%mod;\n\t\tif(s[i]=='+')\tl1=(l1+add)%mod,k=add;\n\t\t++ma[(k-l1+mod)*fsp(l2,mod-2)%mod];\n\t\tans+=ma[(res-l1+mod)*fsp(l2,mod-2)%mod];\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define pb emplace_back\n#define mr make_pair\n#define base1 397063\n#define base2 301501\n#define mo1 19260817\n#define mo2 998244353\n#define N 500010\nusing namespace std;\nstruct Info{ll n1;int ne,qu;}a[N];\nint n,b[20000010],num;\nstring s;\nll p2[N],p1[N],n1[N],n2[N],q1[N],q2[N],no[N],ans;\nll po(ll x,ll y,ll mo){ll z=1;while(y){if (y%2)z=x*z%mo;x=x*x%mo;y/=2;}return z;}\nvoid add(int x,int z){\n\tfor (int y=b[x];y;y=a[y].ne)if (a[y].n1==z){a[y].qu++;return ;}\n\ta[++num].qu=1;a[num].n1=z;a[num].ne=b[x];b[x]=num;\n}\nvoid que(int x,int z){\n\tfor (int y=b[x];y;y=a[y].ne)if (a[y].n1==z)ans+=a[y].qu;\n}\nint main(){\n\tcin>>n;\n\tp2[0]=1,p1[0]=1;\n\tfor (int i=1;i<=n*2;i++)p1[i]=p1[i-1]*base1%mo1,p2[i]=p2[i-1]*base2%mo2;\n\tn1[0]=po(po(base1,mo1-2,mo1),n,mo1);n2[0]=po(po(base2,mo2-2,mo2),n,mo2);\n\tfor (int i=1;i<=n*2;i++)n1[i]=n1[i-1]*base1%mo1,n2[i]=n2[i-1]*base2%mo2;\n\tcin>>s;\n\tno[0]=n;\n\tfor (int i=0;i<n;i++){\n\t\tq1[i+1]=q1[i];q2[i+1]=q2[i];no[i+1]=no[i];\n\t\tif (s[i]=='>')no[i+1]++;\n\t\tif (s[i]=='<')no[i+1]--;\n\t\tif (s[i]=='+')q1[i+1]=(q1[i+1]+p1[no[i]])%mo1,q2[i+1]=(q2[i+1]+p2[no[i]])%mo2;\n\t\tif (s[i]=='-')q1[i+1]=(q1[i+1]-p1[no[i]]+mo1)%mo1,q2[i+1]=(q2[i+1]-p2[no[i]]+mo2)%mo2;\n\t}\n\tfor (int i=n;i>0;i--){add(q1[i],q2[i]);que((q1[i-1]+q1[n]*n1[no[i-1]])%mo1,(q2[i-1]+q2[n]*n2[no[i-1]])%mo2);}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\nll mod[2] = {1000000007, 998244353};\nll base[2] = {532345034, 783920481};\n//ll base[2] = {2, 3};\nll N;\nstring S;\nll pos[260000];\nll rh[260000][2];\nmap<l_l, ll> mp;\n\nll beki(ll a, ll b, ll mod) {\n    if(b == 0) return 1;\n    if(b < 0) {\n        ll INV = beki(a, -b, mod);\n        return beki(INV, mod - 2, mod);\n    }\n    ll ret = beki(a, b / 2, mod);\n    ret = ret * ret % mod;\n    if(b % 2 == 1) {\n        ret = ret * a % mod;\n    }\n    return ret;\n}\n\nint main() {\n    //cout.precision(10);\n    cin >> N;\n    cin >> S;\n    S = \"#\" + S;\n    for(int index = 0; index <= 1; index++) {\n        for(int i = 1; i <= N; i++) {\n            pos[i] = pos[i - 1];\n            rh[i][index] = rh[i - 1][index];\n            if(S[i] == '<') {\n                pos[i]--;\n            }\n            if(S[i] == '>') {\n                pos[i]++;\n            }\n            if(S[i] == '+') {\n                rh[i][index] = (rh[i][index] + beki(base[index], pos[i], mod[index])) % mod[index];\n            }\n            if(S[i] == '-') {\n                rh[i][index] = (mod[index] + rh[i][index] - beki(base[index], pos[i], mod[index])) % mod[index];\n            }\n            //cerr << i << \" \" << pos[i] << \" \" << rh[i][index] << endl;\n        }\n    }\n    for(int i = 0; i <= N; i++) {\n        //cerr << i << \" \" << rh[i][0] << \" \" << rh[i][1] << endl;\n    }\n    ll ans = 0;\n    for(int i = N - 1; i >= 0; i--) {\n        ll HASH[2];\n        for(int j = 0; j <= 1; j++) {\n            //HASH[j] = (rh[N][j] - rh[i + 1][j] + mod[j]) % mod[j];\n            HASH[j] = rh[i + 1][j];\n        }\n        mp[{HASH[0], HASH[1]}]++;\n        //cerr << \"ADDED \" << HASH[0] << \" \" << HASH[1] << endl;\n        for(int j = 0; j <= 1; j++) {\n            HASH[j] = rh[i][j] + beki(base[j], pos[i], mod[j]) * rh[N][j];\n            HASH[j] %= mod[j];\n            //HASH[j] = (mod[j] - HASH[j]) % mod[j];\n        }\n        //cerr << \"SEARCHING \" << HASH[0] << \" \" << HASH[1] << endl;\n        ans += mp[{HASH[0], HASH[1]}];\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nint mod_pow(int a, ll b, int MOD)\n{\n    int res = 1;\n    while(b){\n        if(b & 1){\n            res = (ll)res * a % MOD;\n        }\n        a = (ll)a * a % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nint add(int x,int y, int MOD)\n{\n    return (x + y)%MOD;\n}\n\nint sub(int x,int y, int MOD)\n{\n    return (x+MOD-y)%MOD;\n}\n\nint mul(int x,int y, int MOD)\n{\n    return (ll)x*y%MOD;\n}\n\n#define mul0 10009\n#define mul1 10007\n#define MOD0 1000000007\n#define MOD1 1000000007\n\n\nstruct RollingHash {\n\tint n, sz, res0, res1; vector<int> hash0, hash1;\n    RollingHash(int _n) : n(_n), sz(2*n+2), res0(0), res1(0){\n        hash0.resize(sz+1,0), hash0[0] = 1;\n        hash1.resize(sz+1,0), hash1[0] = 1;\n\t\trep(i,sz) hash0[i+1]=((ll)hash0[i]*mul0)%MOD0;\n        rep(i,sz) hash1[i+1]=((ll)hash1[i]*mul1)%MOD1;\n    }\n    P calc(int id, bool pl){\n        if(pl) res0 = add(res0, hash0[id+n+1], MOD0), res1 = add(res1, hash1[id+n+1], MOD1);\n        else res0 = sub(res0, hash0[id+n+1], MOD0), res1 = sub(res1, hash1[id+n+1], MOD1);\n        return P(res0, res1);\n    }\n};\n\nmap<P, int> mp;\nvector<P> vec;\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    string s;\n    cin >> s;\n    RollingHash rh(n);\n    int p = 0;\n    rep(i,n){\n        if(s[i] == '+'){\n            vec.pb(rh.calc(p, true));\n        }else if(s[i] == '-'){\n            vec.pb(rh.calc(p, false));\n        }else if(s[i] == '>'){\n            if(len(vec)){\n                vec.pb(vec.back());\n            }else{\n                vec.pb(P(0,0));\n            }\n            p++;\n        }else{\n            if(len(vec)){\n                vec.pb(vec.back());\n            }else{\n                vec.pb(P(0,0));\n            }\n            p--;\n        }\n        mp[vec.back()]++;\n    }\n    P val = vec.back();\n    ll ans = 0;\n    int A0 = 1, A1 = 1, B0 = 0, B1 = 0;\n    int hoge0 = mod_pow(mul0, MOD0-2, MOD0), hoge1 = mod_pow(mul1, MOD1-2, MOD1);\n    auto& hash0 = rh.hash0;\n    auto& hash1 = rh.hash1;\n    rep(i,n){\n        ans += mp[P(mul(sub(val.fi, B0, MOD0), mod_pow(A0, MOD0-2, MOD0), MOD0), mul(sub(val.se, B1, MOD1), mod_pow(A1, MOD1-2, MOD1), MOD1))];\n        mp[vec[i]]--;\n        if(s[i] == '+'){\n            B0 = sub(B0, hash0[n+1], MOD0), B1 = sub(B1, hash1[n+1], MOD1);\n        }else if(s[i] == '-'){\n            B0 = add(B0, hash0[n+1], MOD0), B1 = add(B1, hash1[n+1], MOD1);\n        }else if(s[i] == '>'){\n            A0 = mul(A0, hoge0, MOD0), B0 = mul(B0, hoge0, MOD0);\n            A1 = mul(A1, hoge1, MOD1), B1 = mul(B1, hoge1, MOD1);\n        }else{\n            A0 = mul(A0, mul0, MOD0), B0 = mul(B0, mul0, MOD0);\n            A1 = mul(A1, mul1, MOD1), B1 = mul(B1, mul1, MOD1);\n        }\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define N 250052\n#define p 1000000007\n#define q 19260817\ninline int mod(int x){return x<p?x:x-p;}\nchar s[N];int A[q],B[N],D[N],T,a[N],b[N],c[N],d[N],i,j,n;long long C[N],z;\ninline int Hash(long long x)\n{\n    int y=x%q;\n    for(j=A[y];j;j=B[j])if(C[j]==x)return j;\n    return 0;\n}\ninline void add(long long x)\n{\n    int y=Hash(x);\n    !y?B[++T]=A[y=x%q],C[A[y]=T]=x,D[T]=1:D[y]++;\n}\nint main()\n{\n    scanf(\"%d%s\",&n,s+1);\n    for(*a=*c=i=1;i<=n;i++)\n    if(s[i]=='+')a[i]=a[i-1],b[i]=mod(a[i-1]+b[i-1]),c[i]=c[i-1],d[i]=mod(c[i-1]+d[i-1]);\n    else if(s[i]=='-')a[i]=a[i-1],b[i]=mod(p+b[i-1]-a[i-1]),c[i]=c[i-1],d[i]=mod(p+d[i-1]-c[i-1]);\n    else if(s[i]=='>')a[i]=998244353ll*a[i-1]%p,b[i]=b[i-1],c[i]=499122177ll*c[i-1]%p,d[i]=d[i-1];\n    else a[i]=4924091ll*a[i-1]%p,b[i]=b[i-1],c[i]=229537957ll*c[i-1]%p,d[i]=d[i-1];\n    for(i=1;i<=n;i++)add(((long long)b[n]*a[i-1]+b[i-1])%p*p+((long long)d[n]*c[i-1]+d[i-1])%p),z+=D[Hash((long long)b[i]*p+d[i])];\n    return 0*printf(\"%lld\\n\",z);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<map>\nusing namespace std;\nconst int N=250005;\nconst int base=20020415;\nint n;char str[N];long long ans;\nmap<pair<int,int>,int>Map;\nstruct hash{\n\tint mod,pw[N],ipw[N],pos[N],val[N];\n\tint fastpow(int x,int y){\n\t\tint res=1;\n\t\twhile(y){if(y&1)res=1ll*res*x%mod;x=1ll*x*x%mod;y>>=1;}\n\t\treturn res;\n\t}\n\tint cal(int x){\n\t\treturn x>0?pw[x]:ipw[-x];\n\t}\n\tvoid init(){\n\t\tpw[0]=ipw[0]=1;pw[1]=base;ipw[1]=fastpow(base,mod-2);\n\t\tfor(int i=2;i<=n;++i){\n\t\t\tpw[i]=1ll*pw[i-1]*pw[1]%mod;\n\t\t\tipw[i]=1ll*ipw[i-1]*ipw[1]%mod;\n\t\t}\n\t\tfor(int i=1;i<=n;++i){\n\t\t\tif(str[i]=='+'){\n\t\t\t\tpos[i]=pos[i-1];\n\t\t\t\tval[i]=(val[i-1]+cal(pos[i]))%mod;\n\t\t\t}\n\t\t\tif(str[i]=='-'){\n\t\t\t\tpos[i]=pos[i-1];\n\t\t\t\tval[i]=(val[i-1]+mod-cal(pos[i]))%mod;\n\t\t\t}\n\t\t\tif(str[i]=='>'){\n\t\t\t\tpos[i]=pos[i-1]+1;\n\t\t\t\tval[i]=val[i-1];\n\t\t\t}\n\t\t\tif(str[i]=='<'){\n\t\t\t\tpos[i]=pos[i-1]-1;\n\t\t\t\tval[i]=val[i-1];\n\t\t\t}\n\t\t}\n\t}\n\tint get(int i){\n\t\treturn (1ll*val[n]*cal(pos[i-1])+val[i-1])%mod;\n\t}\n}S1,S2;\nint main(){\n\tscanf(\"%d%s\",&n,str+1);\n\tS1.mod=998244353;S1.init();\n\tS2.mod=998244853;S2.init();\n\tfor(int i=1;i<=n;++i)++Map[{S1.val[i],S2.val[i]}];\n\tfor(int i=1;i<=n;++i){\n\t\tint x=S1.get(i),y=S2.get(i);\n\t\tans+=Map[{x,y}];--Map[{S1.val[i],S2.val[i]}];\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<map>\nusing namespace std;\nstruct node{long long g1,g2,g3,g4,g5,g6/*,g7,g8*/;int p;};\nconst int p1=1000000007,p2=1000000009,p3=1000000021;\nlong long x1p1[510000],x1p2[510000],x1p3[510000],x2p1[510000],x2p2[510000],x2p3[510000]/*,x3p1[510000],x3p2[510000],x4p1[510000],x4p2[510000]*/;\ninline node operator+(node x,node y){return {(x.g1+y.g1*x1p1[x.p+250000])%p1,(x.g2+y.g2*x1p2[x.p+250000])%p2,(x.g3+y.g3*x1p3[x.p+250000])%p3,(x.g4+y.g4*x2p1[x.p+250000])%p1,(x.g5+y.g5*x2p2[x.p+250000])%p2,(x.g6+y.g6*x2p3[x.p+250000])%p3/*,(x.g5+y.g5*x3p1[x.p+250000])%p1,(x.g6+y.g6*x3p2[x.p+250000])%p2,(x.g7+y.g7*x4p1[x.p+250000])%p1,(x.g8+y.g8*x4p2[x.p+250000])%p2*/,x.p+y.p};}\nchar s[260000];\nmap<long long,map<long long,map<long long,map<long long,map<long long,map<long long/*,map<long long,map<long long*/,int/*>>*/>>>>>> M;\nint main()\n{\n\tx1p1[249999]=500000004;x1p1[250000]=1;x1p1[250001]=2;\n\tx1p2[249999]=500000005;x1p2[250000]=1;x1p2[250001]=2;\n\tx2p1[249999]=666666671;x2p1[250000]=1;x2p1[250001]=3;\n\tx2p2[249999]=333333336;x2p2[250000]=1;x2p2[250001]=3;\n\t/*x3p1[249999]=600000004;x3p1[250000]=1;x3p1[250001]=5;\n\tx3p2[249999]=800000007;x3p2[250000]=1;x3p2[250001]=5;\n\tx4p1[249999]=857142863;x4p1[250000]=1;x4p1[250001]=7;\n\tx4p2[249999]=142857144;x4p2[250000]=1;x4p2[250001]=7;*/\n\tfor(int i=249998;i>=0;i--)x1p1[i]=x1p1[i+1]*x1p1[249999]%p1,x1p2[i]=x1p2[i+1]*x1p2[249999]%p2,x1p3[i]=x1p3[i+1]*x1p3[249999]%p3,x2p1[i]=x2p1[i+1]*x2p1[249999]%p1,x2p2[i]=x2p2[i+1]*x2p2[249999]%p2,x2p3[i]=x2p3[i+1]*x2p3[249999]%p3/*,x3p1[i]=x3p1[i+1]*x3p1[249999]%p1,x3p2[i]=x3p2[i+1]*x3p2[249999]%p2,x4p1[i]=x4p1[i+1]*x4p1[249999]%p1,x4p2[i]=x4p2[i+1]*x4p2[249999]%p2*/;\n\tfor(int i=250002;i<=500000;i++)x1p1[i]=x1p1[i-1]*x1p1[250001]%p1,x1p2[i]=x1p2[i-1]*x1p2[250001]%p2,x1p3[i]=x1p3[i-1]*x1p3[250001]%p3,x2p1[i]=x2p1[i-1]*x2p1[250001]%p1,x2p2[i]=x2p2[i-1]*x2p2[250001]%p2,x2p3[i]=x2p3[i-1]*x2p3[250001]%p3/*,x3p1[i]=x3p1[i-1]*x3p1[250001]%p1,x3p2[i]=x3p2[i-1]*x3p2[250001]%p2,x4p1[i]=x4p1[i-1]*x4p1[250001]%p1,x4p2[i]=x4p2[i-1]*x4p2[250001]%p2*/;\n\tint n;scanf(\"%d%s\",&n,s+1);\n\tnode gs={0,0,0,0,0,0,0/*,0,0*/},pr={0,0,0,0,0,0,0/*,0,0*/};\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(s[i]=='+')gs.g1=(gs.g1+x1p1[gs.p+250000])%p1,gs.g2=(gs.g2+x1p2[gs.p+250000])%p2,gs.g3=(gs.g3+x1p3[gs.p+250000])%p3,gs.g4=(gs.g4+x2p1[gs.p+250000])%p1,gs.g5=(gs.g5+x2p2[gs.p+250000])%p2,gs.g6=(gs.g6+x2p3[gs.p+250000])%p3/*,gs.g5=(gs.g5+x3p1[gs.p+250000])%p1,gs.g6=(gs.g6+x3p2[gs.p+250000])%p2,gs.g7=(gs.g7+x4p1[gs.p+250000])%p1,gs.g8=(gs.g8+x4p2[gs.p+250000])%p2*/;\n\t\telse if(s[i]=='-')gs.g1=(gs.g1-x1p1[gs.p+250000]+p1)%p1,gs.g2=(gs.g2-x1p2[gs.p+250000]+p2)%p2,gs.g3=(gs.g3-x1p3[gs.p+250000]+p3)%p3,gs.g4=(gs.g4-x2p1[gs.p+250000]+p1)%p1,gs.g5=(gs.g5-x2p2[gs.p+250000]+p2)%p2,gs.g6=(gs.g6-x2p3[gs.p+250000]+p3)%p3/*,gs.g5=(gs.g5-x3p1[gs.p+250000]+p1)%p1,gs.g6=(gs.g6-x3p2[gs.p+250000]+p2)%p2,gs.g7=(gs.g7-x4p1[gs.p+250000]+p1)%p1,gs.g8=(gs.g8-x4p2[gs.p+250000]+p2)%p2*/;\n\t\telse if(s[i]=='>')gs.p++;\n\t\telse gs.p--;\n\t}\n\tlong long ss=0;\n\tnode rg=pr+gs;\n\tM[rg.g1][rg.g2][rg.g3][rg.g4][rg.g5][rg.g6]/*[rg.g7][rg.g8]*/++;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(s[i]=='+')pr.g1=(pr.g1+x1p1[pr.p+250000])%p1,pr.g2=(pr.g2+x1p2[pr.p+250000])%p2,pr.g3=(pr.g3+x1p3[pr.p+250000])%p3,pr.g4=(pr.g4+x2p1[pr.p+250000])%p1,pr.g5=(pr.g5+x2p2[pr.p+250000])%p2,pr.g6=(pr.g6+x2p3[pr.p+250000])%p3/*,pr.g5=(pr.g5+x3p1[pr.p+250000])%p1,pr.g6=(pr.g6+x3p2[pr.p+250000])%p2,pr.g7=(pr.g7+x4p1[pr.p+250000])%p1,pr.g8=(pr.g8+x4p2[pr.p+250000])%p2*/;\n\t\telse if(s[i]=='-')pr.g1=(pr.g1-x1p1[pr.p+250000]+p1)%p1,pr.g2=(pr.g2-x1p2[pr.p+250000]+p2)%p2,pr.g3=(pr.g3-x1p3[pr.p+250000]+p3)%p3,pr.g4=(pr.g4-x2p1[pr.p+250000]+p1)%p1,pr.g5=(pr.g5-x2p2[pr.p+250000]+p2)%p2,pr.g6=(pr.g6-x2p3[pr.p+250000]+p3)%p3/*,pr.g5=(pr.g5-x3p1[pr.p+250000]+p1)%p1,pr.g6=(pr.g6-x3p2[pr.p+250000]+p2)%p2,pr.g7=(pr.g7-x4p1[pr.p+250000]+p1)%p1,pr.g8=(pr.g8-x4p2[pr.p+250000]+p2)%p2*/;\n\t\telse if(s[i]=='>')pr.p++;\n\t\telse pr.p--;\n\t\tss=ss+M[pr.g1][pr.g2][pr.g3][pr.g4][pr.g5][pr.g6]/*[pr.g7][pr.g8]*/;\n\t\trg=pr+gs;\n\t\tM[rg.g1][rg.g2][rg.g3][rg.g4][rg.g5][rg.g6]/*[rg.g7][rg.g8]*/++;\n\t}\n\tprintf(\"%lld\\n\",ss);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\n\nconst int mod = 1e9 + 7;\nconst int base = 10007;\n\nint64_t power(int64_t x, int64_t n, int64_t mod) {\n  int64_t ret = 1;\n  while(n > 0) {\n    if(n & 1) (ret *= x) %= mod;\n    (x *= x) %= mod;\n    n >>= 1;\n  }\n  return ret;\n}\n\n\nint64 h[550001], g[550001];\n\nint main() {\n\n  h[0] = 1;\n  for(int i = 1; i < 550001; i++) {\n    h[i] = h[i - 1] * base % mod;\n  }\n  g[550000] = power(h[550000], mod - 2, mod);\n  for(int i = 549999; i >= 0; i--) {\n    g[i] = g[i + 1] * (i + 1) % mod;\n  }\n\n  int N;\n  string S;\n\n  cin >> N;\n  cin >> S;\n\n  vector< int64 > latte, malta;\n  int64 beet = 0, pos = 250001;\n  latte.push_back(pos), malta.push_back(beet);\n  for(int i = 0; i < N; i++) {\n    char c = S[i];\n    if(c == '+') (beet += h[pos]) %= mod;\n    else if(c == '-') (beet += mod - h[pos]) %= mod;\n    else if(c == '<') --pos;\n    else ++pos;\n    latte.push_back(pos), malta.push_back(beet);\n  }\n\n  map< int64, int > mp;\n  int64 ret = 0;\n  for(int i = N; i >= 0; i--) {\n    int64 dx = latte[i] - latte[0];\n    int64 mul;\n    if(dx >= 0) mul = h[dx];\n    else mul = g[-dx];\n    ret += mp[(malta[i] + malta[N] * mul) % mod];\n    ++mp[malta[i]];\n  }\n  cout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\n#define N 500001\n#define mod 998244353\nusing namespace std;\nlong long thn[N],ans,qz[N],a[N];\nchar st[N];\nint where[N];\nint n;\nmap<long long,long long>maps;\nlong long ksmi(long long x,long long y)\n{\n\tlong long total=1,ab=x,p=y;\n\twhile (p)\n\t{\n\t\tif (p%2==1) total=total*ab%mod;\n\t\tab=ab*ab%mod;\n\t\tp/=2;\n\t}\n\treturn total;\n}\nlong long abs(long long x)\n{\n\tif (x<0) return -x;\n\treturn x;\n}\nint main()\n{\n\tscanf(\"%d\\n\",&n);\n\tthn[0]=1;\n\tfor (int i=1;i<=2*n;i++) thn[i]=thn[i-1]*(2*n)%mod;\n\tscanf(\"%s\",st+1);\n\tint nowp=n;\n\twhere[0]=n;\n\tqz[0]=0;\n\tfor (int i=1;i<=2*n;i++)\n\t\tqz[0]=(qz[0]+thn[i-1]*n%mod)%mod;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tqz[i]=qz[i-1];\n\t\tif (st[i]=='+')\n\t\t{\n\t\t\ta[nowp]++;\n\t\t\tqz[i]=(qz[i]+thn[nowp-1])%mod;\n\t\t}\n\t\tif (st[i]=='-')\n\t\t{\n\t\t\ta[nowp]--;\n\t\t\tqz[i]=(qz[i]-thn[nowp-1])%mod;\n\t\t}\n\t\tif (st[i]=='>') nowp++;\n\t\tif (st[i]=='<') nowp--;\n\t\twhere[i]=nowp;\n\t}\n\tunsigned long long a_hash=0;\n\tfor (int i=1;i<=n*2;i++) a_hash=(a_hash+(a[i]+n)*thn[i-1])%mod;\n\tfor (int i=n;i>=1;i--)\n\t{\n\t\tlong long target=(a_hash-qz[0]+mod)%mod;\n\t\tif (where[i-1]<where[0])\n\t\t\ttarget=target*ksmi(thn[abs(where[i-1]-where[0])],mod-2)%mod;\n\t\telse\ttarget=target*thn[abs(where[0]-where[i-1])]%mod;\n\t\tmaps[qz[i]]++;\n\t\ttarget+=qz[i-1];\n\t\ttarget%=mod;\n\t\tans=(ans+maps[target]);\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <map>\n#include <vector>\n\nconst int MOD = (int)1e9 + 9;\nconst int kN = 250000 + 5;\nusing LL = long long;\nint n;\nchar s[kN];\nstd::vector<int> primes{13}; //(int)1e9 + 7, (int)1e8 + 7, 233333, (int)1e6 + 7, 13};\n\nint inv(int x) {\n  return x == 1 ? 1 : (MOD - MOD / x) * 1LL * inv(MOD % x) % MOD;\n}\n\nLL solve() {\n  int seed = primes[rand() % primes.size()];\n  int inv_seed = inv(seed);\n  int a = 1, b = 0;\n  LL ret = 0;\n  std::map<int, int> map;\n  map[0] = 1;\n  int c = 0;\n  for (int i = n; i >= 1; -- i) {\n    char ch = s[i - 1];\n    if (ch == '+')\n      c = (c + 1) % MOD;\n    else if (ch == '-')\n      c = (c + MOD - 1) % MOD;\n    else if (ch == '>')\n      c = c * 1LL * seed % MOD;\n    else\n      c = c * 1LL * inv_seed % MOD;\n  }\n  for (int i = n; i >= 1; -- i) {\n    char ch = s[i - 1];\n    if (ch == '-')\n      b = (b + a) % MOD;\n    else if (ch == '+')\n      b = (b + MOD - a) % MOD;\n    else if (ch == '<')\n      a = a * 1LL * seed % MOD;\n    else\n      a = a * 1LL * inv_seed % MOD;\n    auto it = map.find((a * 1LL * c % MOD + b) % MOD);\n    if (it != map.end())\n      ret += it->second;\n    map[b] ++;\n  }\n  return ret;\n}\n\nint main() {\n  srand(time(NULL));\n  scanf(\"%d%s\", &n, s);\n  printf(\"%lld\\n\", solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 200000;\n\nconstexpr int inv(int a, int m) {\n  return a == 1 ? 1 : 1LL * (m - m / a) * inv(m % a, m) % m;\n}\n\ntemplate <int BASE, int... INTS> struct HashT {\n  static constexpr int M = sizeof...(INTS);\n  static constexpr std::array<int, M> MODS = {INTS...};\n\n  explicit HashT(int a) {\n    for (int i = 0; i < M; ++i) {\n      h[i] = a;\n    }\n  }\n\n  explicit HashT(const HashT &a, const HashT &b) {\n    for (int i = 0; i < M; ++i) {\n      h[i] = 1LL * a.h[i] * b.h[i] % MODS[i];\n    }\n  }\n\n  explicit HashT(const HashT &k, const HashT &b, const HashT &bf) {\n    for (int i = 0; i < M; ++i) {\n      h[i] = 1LL * k.h[i] * (b.h[i] + MODS[i] - bf.h[i]) % MODS[i];\n    }\n  }\n\n  template <int a> void add() {\n    for (int i = 0; i < M; ++i) {\n      h[i] += a >= 0 ? a : MODS[i] + a;\n      if (h[i] >= MODS[i]) {\n        h[i] -= MODS[i];\n      }\n    }\n  }\n\n  void multiplyB() {\n    for (int i = 0; i < M; ++i) {\n      h[i] = 1LL * h[i] * BASE % MODS[i];\n    }\n  }\n\n  void divideB() {\n    for (int i = 0; i < M; ++i) {\n      h[i] = 1LL * h[i] * inv(BASE, MODS[i]) % MODS[i];\n    }\n  }\n\n  int h[M];\n};\n\ntemplate <int BASE, int... INTS>\nbool operator<(const HashT<BASE, INTS...> &a, const HashT<BASE, INTS...> &b) {\n  for (int i = 0; i < HashT<BASE, INTS...>::M; ++i) {\n    if (a.h[i] != b.h[i]) {\n      return a.h[i] < b.h[i];\n    }\n  }\n  return false;\n}\n\nint n;\nchar s[N];\n\nusing Hash = HashT<3, 1000000007, 1000000009>;\n\nstruct Set {\n  Set() : k{1}, b{0} {}\n\n  void add(int c) {\n    if (c == '+') {\n      b.add<-1>();\n    } else if (c == '-') {\n      b.add<1>();\n    } else if (c == '>') {\n      b.multiplyB();\n      k.divideB();\n    } else {\n      k.multiplyB();\n      b.divideB();\n    }\n  }\n\n  Hash zero() const { return Hash{k, b}; }\n  Hash inverse(const Hash &kb) const { return Hash{k, b, kb}; }\n\n  Hash k, b;\n};\n\nint main() {\n  while (scanf(\"%d%s\", &n, s) == 2) {\n    Set setf;\n    for (int i = n - 1; i >= 0; --i) {\n      setf.add(s[i]);\n    }\n    Set set;\n    long long result = 0;\n    std::map<Hash, int> cnt;\n    for (int i = n - 1; i >= 0; --i) {\n      cnt[set.zero()]++;\n      set.add(s[i]);\n      result += cnt[set.inverse(setf.b)];\n    }\n    printf(\"%lld\\n\", result);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cerr << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcerr<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 500010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = (1 << 30) - 1;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\nmt19937 rng; //use it by rng() % mod, shuffle(all(vec), rng)\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nll mod_pow(ll a, ll n) {\n\tif(n == 0) return 1;\n\tll res = mod_pow(a, n / 2);\n\tif(n % 2 == 0) return res * res % mod;\n\telse return a * res % mod * res % mod;\n}\n\nll invf(ll a) {\n\treturn mod_pow(a, mod - 2);\n}\n\nint N;\nstring S;\n\nll A[MAX_N];\nint B[MAX_N];\n\nvoid solve() {\n\tcin >> N;\n\tcin >> S;\n\tint base = uniform_int_distribution<int>(0, mod - 1)(rng);\n\tint inv = invf(base);\n\n\tint at = 0;\n\tll tmp = 1;\n\tll res = 0;\n\trep(i, 0, N) {\n\t\tif(S[i] == '<') {\n\t\t\tMUL(tmp, inv);\n\t\t\tat--;\n\t\t}\n\t\telse if(S[i] == '>') {\n\t\t\tMUL(tmp, base);\n\t\t\tat++;\n\t\t}\n\t\telse if(S[i] == '+') ADD(res, tmp);\n\t\telse ADD(res, mod - tmp);\n\t\tA[i + 1] = res;\n\t\tB[i + 1] = at;\n\t\t// debug(res, at, tmp);\n\t}\n\tmap<ll, int> D;\n\tD[A[N]]++;\n\n\tll ans = 0;\n\trer(i, N, 0) {\n\t\tint at = B[i];\n\t\tll coef = 1;\n\t\tif(at < 0) coef = mod_pow(inv, -at);\n\t\telse coef = mod_pow(base, at);\n\t\tll target = (A[N] * coef % mod + A[i]) % mod;\n\t\tif(D.count(target)) ans += D[target];\n\t\tD[A[i]]++;\n\t\t// debug(target, A[N]);\n\t}\n\tcout << ans << \"\\n\";\n}\n\nuint32_t rd() {\n\tuint32_t res;\n#ifdef __MINGW32__\n\tasm volatile(\"rdrand %0\" :\"=a\"(res) ::\"cc\");\n#else\n\tres = std::random_device()();\n#endif\n\treturn res;\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n    cerr << fixed;\n\tcerr.precision(6);\n\trng.seed(rd());\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n\tif(!freopen(\"in.txt\", \"rt\", stdin)) return 1;\n#endif\t\n\tsolve();\n    cerr << \"Time: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\nconst pid_t pid = getpid();\n// Problem Specific Parameter:\n\ntemplate<unsigned MOD>  class ModInt {\npublic:\n\tModInt(): x(0) {}\n\tModInt(signed y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n\tModInt(signed long long y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n\n\n\t// Arithmetic Oprators\n\tModInt &operator+=(ModInt that) {\n\t\tif ((x += that.x) >= MOD) x -= MOD; \n\t\treturn *this;\n\t}\n\tModInt &operator-=(ModInt that) {\n\t\tif ((x += MOD - that.x) >= MOD) x -= MOD; \n\t\treturn *this;\n\t}\n\tModInt &operator*=(ModInt that) {\n\t\tx = 1LL * x * that.x % MOD;\n\t\treturn *this;\n\t}\n\tModInt &operator/=(ModInt that) {\n\t\treturn *this *= ModInt(get<1>(extgcd(that.x, int(MOD))));\n\t}\n\tModInt &operator%=(ModInt that) {\n\t\tx %= that.x;\n\t\treturn *this;\n\t}\n\n\tModInt &operator+=(const int that) { return *this += ModInt(that);}\n\tModInt &operator-=(const int that) { return *this -= ModInt(that);}\n\tModInt &operator*=(const int that) { return *this *= ModInt(that);}\n\tModInt &operator/=(const int that) { return *this /= ModInt(that);}\n\tModInt &operator%=(const int that) { return *this %= ModInt(that);}\n\n\t// Comparators\n\tbool operator <(ModInt that) const { return x < that.x; }\n\tbool operator >(ModInt that) const { return x > that.x; }\n\tbool operator<=(ModInt that) const { return x <= that.x; }\n\tbool operator>=(ModInt that) const { return x >= that.x; }\n\tbool operator!=(ModInt that) const { return x != that.x; }\n\tbool operator==(ModInt that) const { return x == that.x; }\n\n\t// Utilities\n\tunsigned getval() const { return x;}\n\tModInt operator+(ModInt that) const { return ModInt(*this) += that;}\n\tModInt operator-(ModInt that) const { return ModInt(*this) -= that;}\n\tModInt operator*(ModInt that) const { return ModInt(*this) *= that;}\n\tModInt operator/(ModInt that) const { return ModInt(*this) /= that;}\n\tModInt operator%(ModInt that) const { return ModInt(*this) %= that;}\n\tModInt operator+(const int that) const { return ModInt(*this) += that;}\n\tModInt operator-(const int that) const { return ModInt(*this) -= that;}\n\tModInt operator*(const int that) const { return ModInt(*this) *= that;}\n\tModInt operator/(const int that) const { return ModInt(*this) /= that;}\n\tModInt operator%(const int that) const { return ModInt(*this) %= that;}\n\tModInt operator=(const int that) { return *this = ModInt(that);}\n\tfriend istream &operator>>(istream& is, ModInt &that) {ll tmp; is >> tmp; that = ModInt(tmp);return is;}\n\tfriend ostream &operator<<(ostream& os, const ModInt &that) { return os << that.x; }\n\t\n\tModInt power(ll n) const {\n\t\tif(n < 0) return ModInt(1) / power(-n);\n\t\tll b = 1LL, a = x;\n\t\twhile(n){\n\t\t\tif(n & 1) b = b * a % MOD;\n\t\t\ta = a * a % MOD;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn ModInt(b);\n\t}\nprivate:\n\tunsigned x;\n\t\n\tinline auto extgcd(int a, int b) {\n\t\tif (b == 0) return make_tuple(a, 1, 0);\n\t\ttuple<int, int, int> ret = extgcd(b, a % b);\n\t\tswap(get<1>(ret), get<2>(ret));\n\t\tget<2>(ret) -= a / b * get<1>(ret);\n\t\treturn ret;\n\t}\n};\n\nusing mint = ModInt<1000000007>;\nusing mint2 = ModInt<1000000009>;\nusing mint3 = ModInt<1000000021>;\nusing mint4 = ModInt<1000000033>;\nusing mint5 = ModInt<1000000087>;\nusing mint6 = ModInt<1000000093>;\n\n\nuniform_int_distribution<int> rng(1 << 20, 1 << 28); // [lower,upper] \nmt19937 mt(pid);\n\nconst int limit = 500010;\nconst int offset = 250000;\n\nusing H = tuple<mint,mint2,mint3,mint4,mint5,mint6>;\nconst H B = H(mint(rng(mt)),mint2(rng(mt)),mint3(rng(mt)),mint4(rng(mt)),mint5(rng(mt)),mint6(rng(mt)));\nconst H ZERO = H(mint(0),mint2(0),mint3(0),mint4(0),mint5(0),mint6(0));\nconst H ONE = H(mint(1),mint2(1),mint3(1),mint4(1),mint5(1),mint6(1));\n\n\nvoid add(H &cur,H tar){\n\tget<0>(cur) += get<0>(tar);  \n\tget<1>(cur) += get<1>(tar);  \n\tget<2>(cur) += get<2>(tar);  \n\tget<3>(cur) += get<3>(tar);  \n\tget<4>(cur) += get<4>(tar);  \n\tget<5>(cur) += get<5>(tar);  \n}\n\nvoid sub(H &cur,H tar){\n\tget<0>(cur) -= get<0>(tar);  \n\tget<1>(cur) -= get<1>(tar);  \n\tget<2>(cur) -= get<2>(tar);  \n\tget<3>(cur) -= get<3>(tar);  \n\tget<4>(cur) -= get<4>(tar);  \n\tget<5>(cur) -= get<5>(tar);  \n}\n\nvoid mul(H &cur,H tar){\n\tget<0>(cur) *= get<0>(tar);  \n\tget<1>(cur) *= get<1>(tar);  \n\tget<2>(cur) *= get<2>(tar);  \n\tget<3>(cur) *= get<3>(tar);  \n\tget<4>(cur) *= get<4>(tar);  \n\tget<5>(cur) *= get<5>(tar);  \n}\n\nH power(H cur,int n){\n\tH ret;\n\tget<0>(ret) = get<0>(B).power(n);  \n\tget<1>(ret) = get<1>(B).power(n);\n\tget<2>(ret) = get<2>(B).power(n);\n\tget<3>(ret) = get<3>(B).power(n);\n\tget<4>(ret) = get<4>(B).power(n);\n\tget<5>(ret) = get<5>(B).power(n);\n\treturn ret;\n}\n\nH shash[limit],csum[limit];\nint cpos[limit];\n\n\nint main(void){\n\tint n;\n\tstring s;\n\tcin >> n >> s;\n\n\tshash[0] = ONE;\n\trep(i,1,limit){\n\t\tshash[i] = ONE;\n\t\tmul(shash[i],shash[i-1]);\n\t\tmul(shash[i],B);\n\t}\n\n\tH cur = ZERO;\n\tint pos = 0;\n\trep(i,n+1){\n\t\tcpos[i] = pos;\n\t\tcsum[i] = cur;\n\t\tif(i == n) break;\n\n\t\tif(s[i] == '+') add(cur,shash[pos + offset]);\n\t\tif(s[i] == '-') sub(cur,shash[pos + offset]);\n\t\tif(s[i] == '>') pos++;\n\t\tif(s[i] == '<') pos--;\n\t}\n\n\tmap<H,int> num;\n\tnum[csum[n]]++;\n\n\tll ans = 0LL;\n\trrep(i,n){\n\t\tH tar = csum[n];\n\t\tmul(tar,power(B,-cpos[i])); \n\t\tadd(tar,csum[i]);\n\t\tif(num.find(tar) != end(num)) ans += num[tar];\n\t\tnum[csum[i]]++;\n\t}\n\n\tcout << ans << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 998244353\n#define lim 300000\nusing namespace std;\nint n;\nchar s[300005];\nlong long A, base[600005], lsp, p, suf[300005], pre;\nmap<long long, int> cnt;\nint fsp(long long bs, int p) {\n    int rt = 1;\n    while (p) {\n        if (p & 1) rt = bs * rt % mod;\n        bs = bs * bs % mod, p >>= 1;\n    }\n    return rt;\n}\n\nlong long bs(int p) { return base[p + lim]; }\n\nint main() {\n    for (int i = base[lim] = 1; i <= lim; ++i)\n        base[lim + i] = base[lim + i - 1] * 250007 % mod;\n    for (int i = 1, ny = fsp(250007, mod - 2); i <= lim; ++i)\n        base[lim - i] = base[lim - i + 1] * ny % mod;\n    scanf(\"%d%s\", &n, s + 1), p = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (s[i] == '>') ++p;\n        if (s[i] == '<') --p;\n        if (s[i] == '+') (A += bs(p)) %= mod;\n        if (s[i] == '-') (A += mod - bs(p)) % mod;\n    }\n    ++cnt[suf[n + 1] = 0];\n    for (int i = n; i > 1; --i) {\n        suf[i] = suf[i + 1];\n        if (s[i] == '>') --p;\n        if (s[i] == '<') ++p;\n        if (s[i] == '+') (suf[i] += bs(p)) %= mod;\n        if (s[i] == '-') (suf[i] += mod - bs(p)) %= mod;\n        ++cnt[suf[i]];\n    }\n\n    long long res = cnt[0];\n    p = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (s[i] == '>') ++p;\n        if (s[i] == '<') --p;\n        if (s[i] == '+') (pre += bs(p)) %= mod;\n        if (s[i] == '-') (pre += mod - bs(p)) % mod;\n        --cnt[suf[i + 1]];\n        res += cnt[((A - pre - A * bs(p) % mod) % mod + mod) % mod];\n    }\n    printf(\"%lld\\n\", res);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <string>\n#include <cstdlib>\n#include <utility>\n#include <cctype>\n#include <algorithm>\n#include <bitset>\n#include <set>\n#include <map>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <cmath>\n#define LL long long\n#define LB long double\n#define x first\n#define y second\n#define Pair pair<int,int>\n#define pLL pair<LL,LL>\n#define pii pair<double,double>\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define LOWBIT(x) x & (-x)\nusing namespace std;\n\nconst int MOD=1e9+9;\nconst LL LINF=2e16;\nconst int INF=2e9;\nconst int magic=348;\nconst double eps=1e-10;\nconst double pi=3.14159265;\n\ninline int getint()\n{\n    char ch;int res;bool f;\n    while (!isdigit(ch=getchar()) && ch!='-') {}\n    if (ch=='-') f=false,res=0; else f=true,res=ch-'0';\n    while (isdigit(ch=getchar())) res=res*10+ch-'0';\n    return f?res:-res;\n}\n\nint n;\nchar s[300048];\n\ninline LL mod(LL x,int MO) {while (x>=MO) x-=MO;while (x<0) x+=MO;return x;}\ninline LL quick_pow(LL x,LL y,int MO)\n{\n\tLL res=1;x%=MO;\n\twhile (y)\n\t{\n\t\tif (y&1) res=(res*x)%MO,y--;\n\t\tx=(x*x)%MO;y>>=1;\n\t}\n\treturn res;\n}\nconst int p1=19260817,p2=998244353,m1=1e9+7,m2=1e9+9;\nLL inv1,inv2;\nLL f1[300048],f2[300048];LL K,B;\nmap<pLL,int> Mp;\n\nint main ()\n{\n\tint i;n=getint();scanf(\"%s\",s+1);\n\tinv1=quick_pow(p1,m1-2,m1);inv2=quick_pow(p2,m2-2,m2);\n\tK=1;B=0;\n\tfor (i=1;i<=n;i++)\n\t{\n\t\tif (s[i]=='+') B=mod(B+K,m1);\n\t\tif (s[i]=='-') B=mod(B-K,m1);\n\t\tif (s[i]=='<') K=(K*inv1)%m1;\n\t\tif (s[i]=='>') K=(K*p1)%m1;\n\t\tf1[i]=B;\n\t}\n\tK=1;B=0;\n\tfor (i=1;i<=n;i++)\n\t{\n\t\tif (s[i]=='+') B=mod(B+K,m2);\n\t\tif (s[i]=='-') B=mod(B-K,m2);\n\t\tif (s[i]=='<') K=(K*inv2)%m2;\n\t\tif (s[i]=='>') K=(K*p2)%m2;\n\t\tf2[i]=B;\n\t}\n\tMp.clear();for (i=1;i<=n;i++) Mp[mp(f1[i],f2[i])]++;\n\tLL c1=0,c2=0;\n\tfor (i=n;i>=1;i--)\n\t{\n\t\tif (s[i]=='+') c1=mod(c1+1,m1),c2=mod(c2+1,m2);\n\t\tif (s[i]=='-') c1=mod(c1-1,m1),c2=mod(c2-1,m2);\n\t\tif (s[i]=='<') c1=(c1*inv1)%m1,c2=(c2*inv2)%m2;\n\t\tif (s[i]=='>') c1=(c1*p1)%m1,c2=(c2*p2)%m2;\n\t}\n\tLL k1=1,b1=0,k2=1,b2=0,need1,need2,ans=0;\n\tfor (i=1;i<=n;i++)\n\t{\n\t\tneed1=(mod(c1-b1,m1)*quick_pow(k1,m1-2,m1))%m1;\n\t\tneed2=(mod(c2-b2,m2)*quick_pow(k2,m2-2,m2))%m2;\n\t\tans+=Mp[mp(need1,need2)];\n\t\tMp[mp(f1[i],f2[i])]--;\n\t\tif (s[i]=='+') b1=mod(b1-1,m1),b2=mod(b2-1,m2);\n\t\tif (s[i]=='-') b1=mod(b1+1,m1),b2=mod(b2+1,m2);\n\t\tif (s[i]=='<') k1=(k1*p1)%m1,b1=(b1*p1)%m1,k2=(k2*p2)%m2,b2=(b2*p2)%m2;\n\t\tif (s[i]=='>') k1=(k1*inv1)%m1,b1=(b1*inv1)%m1,k2=(k2*inv2)%m2,b2=(b2*inv2)%m2;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<array>\n#include<map>\n\nint powMod(int base,int exp,int mod){\n\tif(exp<0)exp+=mod-1;\n\tint ans=1;\n\tfor(;;){\n\t\tif(exp&1)ans=(int64_t)ans*base%mod;\n\t\texp>>=1;if(exp==0)return ans;\n\t\tbase=(int64_t)base*base%mod;\n\t}\n}\nstruct prg{\n\tstatic int constexpr NPRIME=3;\n\tusing value_t=std::array<int,NPRIME>;\n\tstatic std::array<int,NPRIME> constexpr PRIMES{{1073741789,1073741783,1073741741}};\n\tstatic int constexpr BASE=250007;\n\n\tvalue_t value;\n\tint offset;\n\tconstexpr prg():value{},offset{}{}\n\n\tstatic prg const left,right,inc,dec;\nprivate:\n\tconstexpr prg(value_t v,int o):value(v),offset(o){}\n};\n\nprg operator*(prg A,prg B){\n\tprg AB;\n\tAB.offset=A.offset+B.offset;\n\tfor(int p=0;p<prg::NPRIME;++p){\n\t\tAB.value[p]=A.value[p]+powMod(prg::BASE,A.offset,prg::PRIMES[p])*B.value[p];\n\t}\n\treturn AB;\n}\n\nstd::ostream& operator<<(std::ostream& stream,prg p){\n\treturn stream<<p.value[0]<<'|'<<p.offset;\n}\n\nstd::array<int,prg::NPRIME> constexpr prg::PRIMES;\nprg const prg::left {{ 0, 0, 0},-1};\nprg const prg::right{{ 0, 0, 0}, 1};\nprg const prg::inc  {{ 1, 1, 1}, 0};\nprg const prg::dec  {{-1,-1,-1}, 0};\n\nint main(){auto&O=std::cout;\n#ifdef _GLIBCXX_DEBUG\nstd::stringstream I(R\"(\n48\n-+><<><><><>>>+-<<>->>><<><<-+<>><+<<>+><-+->><<\n)\");\n#else\nauto&I=std::cin;std::ios::sync_with_stdio(0);I.tie(0);\n#endif\n\nint n;I>>n;\nstd::string st;st.reserve(n);I>>st;\nstd::vector<prg> prefix(n+1);\nfor(int i=0;i<n;++i){\n\tprefix[i+1]=prefix[i]*(\n\t\tst[i]=='<'?prg::left:\n\t\tst[i]=='>'?prg::right:\n\t\tst[i]=='+'?prg::inc:\n\t\tst[i]=='-'?prg::dec:throw 0\n\t);\n}\nstd::map<prg::value_t,int> value_count;\nvalue_count.emplace(prefix[n].value,1);\nint64_t ans=0;\nfor(int i=n;i--;){\n\t// consider programs B starting at (i) have the same value as whole program\n\t// so (AB) = (A)*(B) = prefix[i]*(B)\n\tauto it=value_count.find((prefix[i]*prefix[n]).value);\n\tif(it!=value_count.end()){\n\t\tans+=it->second;\n\t}\n\t++value_count[prefix[i].value];\n}\nO<<ans<<'\\n';\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\nusing namespace std;\n\n#define i64 long long int\n#define u64 unsigned long long int\n#define mod 10000019\n#define inv 8343730571309479835LLU\nint n, M;\nu64 mu[555555],iv[555555],H;\nchar s[255555];\ni64 res;\n\nmap<u64, int> Map;\nvoid rec(int L, int R) {\n\tif (L == R) {\n\t\ti64 h = (s[L] == '+' ? mu[n] : s[L] == '-' ? 0 - mu[n] : 0);\n\t\tif (h == H)\n\t\t\tres++;\n\t\treturn;\n\t}\n\tint M = (L + R) / 2;\n\n\tint cur = n;\n\tu64 h = 0;\n\tMap.clear();\n\tfor (int i = M + 1; i <= R; i++) {\n\t\tif (s[i] == '+')\n\t\t\th += mu[cur];\n\t\telse\n\t\t\tif (s[i] == '-')\n\t\t\t\th -= mu[cur];\n\t\t\telse\n\t\t\tif (s[i] == '>')\n\t\t\t\t\tcur++;\n\t\t\t\telse\n\t\t\t\t\tcur--;\n\t\tMap[h] ++;\n\t}\n\th = 0;\n\tcur = n;\n\tfor (int i = M; i >= L; i--) {\n\t\tif (s[i] == '+')\n\t\t\th += mu[n];\n\t\telse {\n\t\t\tif (s[i] == '-')\n\t\t\t\th -= mu[n];\n\t\t\telse\n\t\t\t\tif (s[i] == '>') {\n\t\t\t\t\tcur++;\n\t\t\t\t\th *= mod;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcur--;\n\t\t\t\t\th *= inv;\n\t\t\t\t}\n\t\t}\n\t\tu64 h2 = H - h;\n\t\tif (cur > n)h2 *= iv[cur - n];else\n\t\t\th2 *= mu[n - cur];\n\t\tif (Map.count(h2))\n\t\t\tres += Map[h2];\n\t}\n\n\trec(L, M);\n\trec(M + 1, R);\n}\n\nint main() {\n\tscanf(\"%d%s\", &n,s);\n\n\tM = 2 * n + 1;\n\tmu[0] = iv[0] = 1;\n\tfor (int i = 1; i < M; i++) {\n\t\tmu[i] = mu[i - 1] * mod;\n\t\tiv[i] = iv[i - 1] * inv;\n\t}\n\t\n\tint cur = n;\n\n\tu64 h = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (s[i] == '+')\n\t\t\th += mu[cur];\n\t\telse\n\t\t\tif (s[i] == '-')\n\t\t\t\th -= mu[cur];\n\t\t\telse\n\t\t\t\tif (s[i] == '>')\n\t\t\t\t\tcur++;\n\t\t\t\telse\n\t\t\t\t\tcur--;\n\t}\n\tH = h;\n\n\trec(0, n-1);\n\n\tprintf(\"%lld\\n\", res);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nlong long modinv(long long a, long long mod) {\n    long long b = mod, u = 1, v = 0;\n    while (b) {\n        long long t = a/b;\n        a -= t*b; swap(a, b);\n        u -= t*v; swap(u, v);\n    }\n    u %= mod;\n    if (u < 0) u += mod;\n    return u;\n}\n\nlong long modpow(long long a, long long n, long long mod) {\n    long long res = 1;\n    if (n < 0) {\n        a = modinv(a, mod);\n        n = -n;\n        return modpow(a, n, mod);\n    }\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nconst vector<long long> MOD = {1000000009, 1000000007};\nconst vector<long long> BASE = {17, 1009};\n\nlong long solve(int N, const string &S) {\n    vector<vector<long long>> hash(2, vector<long long>(N+1, 0));\n    vector<vector<long long>> pval(2, vector<long long>(N+1, 0));\n    map<pair<long long, long long>, vector<int>> pos;\n\n    for (int i = 0; i < N; ++i) {\n        for (int it = 0; it < 2; ++it) {\n            if (S[i] == '>') {\n                hash[it][i+1] = hash[it][i];\n                pval[it][i+1] = pval[it][i] + 1;\n            }\n            else if (S[i] == '<') {\n                hash[it][i+1] = hash[it][i];\n                pval[it][i+1] = pval[it][i] - 1;\n            }\n            else if (S[i] == '+') {\n                pval[it][i+1] = pval[it][i];\n                long long add = modpow(BASE[it], pval[it][i], MOD[it]);\n                hash[it][i+1] = (hash[it][i] + add) % MOD[it];\n            }\n            else if (S[i] == '-') {\n                pval[it][i+1] = pval[it][i];\n                long long add = modpow(BASE[it], pval[it][i], MOD[it]);\n                hash[it][i+1] = (hash[it][i] - add + MOD[it]) % MOD[it];\n            }\n        }\n        pos[{hash[0][i+1], hash[1][i+1]}].push_back(i+1);\n    }\n\n    long long res = 0;\n    for (int i = 0; i <= N; ++i) {\n        vector<long long> risou_add(2), risou(2);\n        for (int it = 0; it < 2; ++it) {\n            risou_add[it] = hash[it][N] * modpow(BASE[it], pval[it][i], MOD[it]) % MOD[it];\n            risou[it] = (hash[it][i] + risou_add[it]) % MOD[it];\n        }\n        auto &v = pos[{risou[0], risou[1]}];\n        int it = upper_bound(v.begin(), v.end(), i) - v.begin();\n        res += (int)v.size() - it;  \n    }\n    return res;\n}\n\nint main() {\n    int N; string S;\n    while (cin >> N >> S) cout << solve(N, S) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fo(i,a,b)for(int i=a,_e=b;i<=_e;++i)\n#define fd(i,a,b)for(int i=b,_e=a;i>=_e;--i)\n#define get(x)((x)>=0?_A[x]:_A2[-(x)])\n#define ll long long\nusing namespace std;\nconst int N=2.5e5+5;\nconst ll mo=23333333333333333LL;\nint n;\nll Z,A,_A[N],_A2[N],Y,ans;\nmap<ll,int>h;\nchar c[N];\ninline ll mult(ll x,ll y){\n\tZ=x*y-(ll)((long double)x*y/mo)*mo;\n\treturn (Z<0?Z+mo:Z<mo?Z:Z-mo);\n}\nll ksm(ll x,ll y){\n\tll t=1;\n\tfor(;y;y>>=1,x=mult(x,x))if(y&1)t=mult(t,x);\n\treturn t;\n}\nstruct P{\n\tint x;ll y;\n\tP(int _x=0,ll _y=0){x=_x;y=_y;}\n\tP operator+(const P &b){\n\t\treturn P(x+b.x,(y+mult(get(x),b.y))%mo);\n\t}\n}a[N];\nint main(){\n\tscanf(\"%d\\n%s\",&n,c+1);\n\tA=1e6+7;\n\t_A[0]=1;\n\tfo(i,1,n)_A[i]=mult(_A[i-1],A);\n\t_A2[0]=1;_A2[1]=ksm(A,mo-2);\n\tfo(i,2,n)_A2[i]=mult(_A2[i-1],_A2[1]);\n\tfd(i,1,n){\n\t\tif(c[i]=='>')a[i]=P(1,0);\n\t\tif(c[i]=='<')a[i]=P(-1,0);\n\t\tif(c[i]=='+')a[i]=P(0,1);\n\t\tif(c[i]=='-')a[i]=P(0,-1);\n\t\ta[i]=a[i]+a[i+1];\n\t}\n\tY=a[1].y;\n\tfd(i,1,n+1){\n\t\tll b=mult((a[i].y-Y+mo)%mo,get(-a[i].x));\n\t\tans+=h[b];\n\t\tb=mult(a[i].y,get(-a[i].x));\n\t\t++h[b];\n\t}\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n        using namespace std;\n         \n        #define MAX 600012\n         \n        int n;\n        char buf[MAX];\n        string s;\n        valarray<long long int> MOD1;\n        valarray<long long int> MOD2;\n        vector<valarray<long long int> > p2;\n        vector<valarray<long long int> > vv;\n        vector<int> ps;\n        map<pair<long long int,long long int>, int> mp;\n        long long int ppow(long long int i, long long int j, long long int MOD) {\n        \tlong long int ret = 1;\n        \twhile (j) {\n        \t\tif (j & 1LL)ret *= i;\n        \t\tif (ret >= MOD)ret %= MOD;\n        \t\tj >>= 1LL;\n        \t}\n        \treturn ret;\n        }\n         \n        valarray<long long int> calc(int dif) {\n        \tvalarray<long long int> ret;\n        \tret.resize(2, 0);\n        \tfor (int j = 0; j < 2; j++) {\n        \t\tif (dif < 0) {\n        \t\t\tret[j]=ppow(ppow(MOD1[j],MOD2[j]-2,MOD2[j]),-dif,MOD2[j]);\n        \t\t}\n        \t\telse {\n        \t\t\tret[j] = ppow(MOD1[j],dif, MOD2[j]);\n        \t\t}\n        \t}\n        \treturn ret;\n        }\n         \n        int main() {\n        \tMOD1.resize(2);\n        \tMOD2.resize(2);\n        \tp2.push_back(valarray<long long int>(2,1));\n        \tMOD2[1] = 1000000007;\n        \tMOD1[0] = 555522277;\n        \tMOD1[1] = 895612782;\n        \tMOD2[0] = 998244353;\n        \tp2[0] %= MOD2;\n        \tfor (int i = 1; i < MAX; i++) p2.push_back((p2.back()*MOD1)%MOD2);\n        \tcin >> n;\n        \tscanf(\"%s\", buf);\n        \ts = buf;\n        \tint pos = MAX/2;\n        \tvalarray<long long int> hs;\n        \ths.resize(2,0);\n        \tvv.push_back(hs);\n        \tps.push_back(pos);\n        \tfor (int i = 0; i < s.size(); i++) {\n        \t\tif (s[i] == '<') pos--;\n        \t\telse if (s[i] == '>') pos++;\n        \t\telse if (s[i] == '+') hs += p2[pos];\n        \t\telse if (s[i] == '-') hs += MOD2-p2[pos];\n        \t\tif(hs[0]<0LL||hs[1]<0LL||p2[0]<0LL||p2[1]<0LL)return 1;\n        \t\ths %= MOD2;\n        \t\tvv.push_back(hs);\n        \t\tps.push_back(pos);\n        \t}\n        \tlong long int way = 0;\n        \tfor (int i = vv.size() - 1; i >= 0; i--) {\n        \t\tvalarray<long long int> want = (vv[i] + ((vv.back()*calc(-MAX/2+ps[i]))%MOD2))%MOD2;\n        \t\tway += mp[make_pair(want[0], want[1])];\n        \t\tmp[make_pair(vv[i][0],vv[i][1])]++;\n        \t}\n        \tprintf(\"%lld\\n\", way);\n        \treturn 0;\n        }\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int N=250005,mu=1000000021,P=2333329;\nvoid reduce(int &x){ x+=x>>31&mu; } \nint n,f[N],g[N],pm[N],mx;\nlong long ans;\nchar s[N];\nstd::map<int,int> mp;\nint main(){\n\tscanf(\"%d%s\",&n,s);\n\tint p=0;\n\tfor (int i=0;i<n;i++){\n\t\tif (s[i]=='<') p--;\n\t\t\telse if (s[i]=='>') p++;\n\t\tmx=std::min(mx,p);\n\t}\n\tp=abs(mx);\n\tpm[0]=1;\n\tfor (int i=1;i<=n+p;i++) pm[i]=1ll*pm[i-1]*P%mu;\n\tfor (int i=0;i<n;i++){\n\t\tg[i]=p;\n\t\tif (i) f[i]=f[i-1];\n\t\tswitch (s[i]){\n\t\t\tcase '+':reduce(f[i]+=pm[p]-mu);break;\n\t\t\tcase '-':reduce(f[i]-=pm[p]);break;\n\t\t\tcase '<':p--;break;\n\t\t\tdefault:p++;\n\t\t} \n\t}\n\tint t=f[n-1];\n\tmp[t]=1;\n\tfor (int i=0;i<n;i++){\n\t\tans+=mp[f[i]];\n\t\tmp[(t*1ll*pm[g[i]]+f[i])%mu]++;\n\t} \n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\nconst int   N   = 5e5 + 1;\nconst int   B   = 1e8 + 1;\n\ntypedef pair<int,int>   ii;\n\nint qpow(int a,int exp,int mod) {\n    if(exp < 0) exp = mod - 1 + exp;\n    int ans = 1;\n    while (exp) {\n        if(exp & 1) ans = ans * a % mod;\n        a = a * a % mod;  exp >>= 1;\n    }\n    return ans;\n}\n\nvoid add(int &a,int b,int mod) {\n    a += b;\n    if(a >= mod)a -= mod;\n    if(a < 0)   a += mod;\n}\n\nint mod[2];\nint n, f[N];\nint H[N][2];\nstring S;\n\nvoid process(int t)   {\n    for(int i = 1 ; i <= n ; ++i)   {\n        H[i][t] = H[i - 1][t];\n        if(S[i - 1] == '+') add(H[i][t], qpow(B,f[i],mod[t]),mod[t]);\n        if(S[i - 1] == '-') add(H[i][t],-qpow(B,f[i],mod[t]),mod[t]);\n    }\n}\n\nmap<ii,int> mp;\n\nsigned main()   {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    cin >> n >> S;\n\n    for(int i = 0 ; i < n ; ++i)    {\n        f[i + 1] = f[i];\n        if(S[i] == '>') f[i + 1]++;\n        if(S[i] == '<') f[i + 1]--;\n    }\n\n    mod[0] = 1e9 + 7;\n    mod[1] = 1e9 + 9;\n\n    process(0);\n    process(1);\n\n    mp[ii(H[n][0],H[n][1])] = 1;\n\n    int ans = 0;\n\n    for(int i = 1 ; i <= n ; ++i)   {\n        ans += mp[ii(H[i][0],H[i][1])];\n        int res0 = H[n][0] * qpow(B,f[i],mod[0]) + H[i][0];\n        int res1 = H[n][1] * qpow(B,f[i],mod[1]) + H[i][1];\n        res0 %= mod[0]; res1 %= mod[1];\n        mp[ii(res0,res1)]++;\n    }\n\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define eb emplace_back\nusing namespace std;\ntypedef long long ll;\nmt19937 rdf(time(0));\nint rd(int s, int e) { return rdf() % (e-s+1) + s; }\n\nconst int MOD = 1000009399;\nconst int MAXN = 250055;\n\nll pw(ll n, ll k) {\n\tll r = 1; for(; k; k >>= 1) {\n\t\tif(k & 1) r = r * n % MOD;\n\t\tn = n * n % MOD;\n\t}\n\treturn r;\n}\nll inv(ll n) { return pw(n, MOD-2); }\n\nstruct NOD {\n\tNOD(int a = 1, int b = 0) : a(a), b(b) {}\n\tint a, b;\n\n\tint operator () (int t) const {\n\t\treturn (ll(a)*t + b) % MOD;\n\t}\n\tNOD operator * (const NOD &t) const {\n\t\treturn NOD(ll(a)*t.a % MOD, (ll(a)*t.b + b) % MOD);\n\t}\n} nod[6][MAXN], gma[6][4];\n\nmap<vector<int>, int> MP;\n\nint X[6], RX[6], C[6];\n\nchar A[MAXN];\n\nll Ans;\nint N;\n\nint f(char c) {\n\tif('+' == c) return 0;\n\tif('-' == c) return 1;\n\treturn '>' == c ? 2 : 3;\n}\n\nint main() {\n\tscanf(\"%d %s\", &N, A+1);\n\n\tfor(int i = 0; i < 6; i++) {\n\t\tX[i] = rd(40148, 957370123);\n\t\tRX[i] = inv(X[i]);\n\n\t\tgma[i][0] = NOD(1, MOD-1);\n\t\tgma[i][1] = NOD(1, 1);\n\t\tgma[i][2] = NOD(RX[i], 0);\n\t\tgma[i][3] = NOD(X[i], 0);\n\n\t\tfor(int j = N; j; j--) {\n\t\t\tnod[i][j] = nod[i][j+1] * gma[i][f(A[j])];\n\t\t\tC[i] = gma[i][f(A[j])^1](C[i]);\n\t\t}\n\t}\n\n\tfor(int i = N; i; i--) {\n\t\tvector<int> V(6);\n\t\tfor(int j = 0; j < 6; j++) V[j] = nod[j][i+1](0);\n\t\tMP[V]++;\n\t\tfor(int j = 0; j < 6; j++) V[j] = nod[j][i](C[j]);\n\t\tauto it = MP.find(V);\n\t\tif(MP.end() != it) Ans += it -> second;\n\t}\n\n\tcout << Ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <vector>\n#include <map>\nusing namespace std;\ntypedef long long LL;\nconst LL mo1=998244353;\nconst LL mo2=1e9+7;\nconst LL Base=20011119;\nconst int N=1e6;\nint len,cnt=0,num[N+10];\nchar s[N+10];\nLL ans;\nLL mul(LL x,LL y,LL mo) {\n    x%=mo;\n    LL z=1;\n    while (y) {\n        if (y&1) z=z*x%mo;\n        y>>=1;\n        x=x*x%mo;\n    }\n    return z;\n}\nstruct data {\n    LL h1,h2;\n    data operator + (const data &p) {\n        data now;\n        now.h1=(h1+p.h1)%mo1;\n        now.h2=(h2+p.h2)%mo2;\n        return now;\n    }\n    data operator - (const data &p) {\n        data now;\n        now.h1=((h1-p.h1)%mo1+mo1)%mo1;\n        now.h2=((h2-p.h2)%mo2+mo2)%mo2;\n        return now;\n    }\n    data operator * (const data &p) {\n        data now;\n        now.h1=(h1*p.h1)%mo1;\n        now.h2=(h2*p.h2)%mo2;\n        return now;\n    }\n    data operator * (LL x) {\n        data now;\n        now.h1=(h1*x%mo1+mo1)%mo1;\n        now.h2=(h2*x%mo2+mo2)%mo2;\n        return now;\n    }\n    bool operator < (const data &p) const {\n        if (h1!=p.h1) return h1<p.h1;\n        return h2<p.h2;\n    }\n}f[N+10],fac[N*2+10],invn;\nvector <int> v[N+10];\nmap <data,int> mp;\ndata make(LL x,LL y) {\n    data now;\n    now.h1=x;\n    now.h2=y;\n    return now;\n}\nvoid Pre_Hash() {\n    data now=make(0,0);\n    int vx=N;\n    f[0]=make(0,0);\n    fac[0]=make(1,1);\n    for (int i=1;i<=N*2;i++) fac[i]=fac[i-1]*Base;\n    num[0]=vx;\n    for (int i=1;i<=len;i++) {\n        if (s[i]=='<') vx--;\n        else if (s[i]=='>') vx++;\n        else if (s[i]=='+') now=now+fac[vx];\n        else now=now-fac[vx];\n        num[i]=vx;\n        f[i]=now;\n        if (mp.find(f[i])==mp.end()) {\n            mp[f[i]]=++cnt;\n            v[cnt].push_back(i);\n        }\n        else v[mp[f[i]]].push_back(i);\n    }\n    invn=make(1,1);\n    data invx=make(mul(Base,mo1-2,mo1),mul(Base,mo2-2,mo2));\n    for (int i=1;i<=N;i++) invn=invn*invx;\n}\nvoid Calc(int x,int loc) {\n    int l=0,r=v[loc].size();\n    while (l<r) {\n        int mid=(l+r)/2;\n        if (v[loc][mid]>=x) r=mid;\n        else l=mid+1;\n    }\n    ans+=v[loc].size()-l;\n}\nvoid work() {\n    for (int i=1;i<=len;i++) {\n        data now=f[len];\n        now=now*fac[num[i-1]]*invn;\n        now=now+f[i-1];\n        if (mp.find(now)==mp.end()) continue;\n        Calc(i,mp[now]);\n    }\n}\nint main() {\n    scanf(\"%d\",&len);\n    scanf(\"%s\",s+1);\n    Pre_Hash();\n    work();\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define R register\n\ntypedef long long ll;\ntypedef std::pair<int, int> pii;\n\nint n;\nstd::string s;\n\ninline int pw(int, int);\n\nconst int P = 998244353, p2 = 97, p3 = 37, invp2 = pw(p2, P - 2);\n\ninline int pw(int x, int k) {\n\tR int res = 1;\n\tfor (; k; k >>= 1, x = (ll)x * x % P)\n\t\tif (k & 1) res = (ll)res * x % P;\n\treturn res;\n}\n\n\nstd::unordered_map<int, int> mp;\n\nll ans;\n\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\n\tstd::cin >> n >> s;\n\n\tR ll res = 0;\n\tR int cnt = 0;\n\n\tfor (R int i = 0; i < n; ++i) {\n\t\tswitch(s[i]) {\n\t\t\tcase '+' : res += p3; res >= P ? res -= P : 0; break;\n\t\t\tcase '-' : res -= p3; res < 0 ? res += P : 0; break;\n\t\t\tcase '>' : res *= p2; ++cnt; res %= P; break;\n\t\t\tcase '<' : res *= invp2; --cnt; res %= P; break;\n\t\t}\n\t\tR int k = res * pw(cnt > 0 ? invp2 : p2, cnt < 0 ? -cnt : cnt) % P;\n\t//\tprintf(\"%d %d \", k, cnt);\n\t\t++mp[k];\n\t//\tprintf(\"%lld\\n\", res);\n\t}\n\t\n\tR ll res2 = 0;\n\tR int cnt2 = 0;\n\tans += mp[res];\n\tfor (R int i = 0; i < n; ++i) {\n\t\tswitch(s[i]) {\n\t\t\tcase '+' : res2 += p3; res2 >= P ? res2 -= P : 0;break;\n\t\t\tcase '-' : res2 -= p3; res2 < 0 ? res2 += P : 0; break;\n\t\t\tcase '>' : res2 *= p2; ++cnt2; res2 %= P; break;\n\t\t\tcase '<' : res2 *= invp2; --cnt2; res2 %= P; break;\n\t\t}\n\t\tR int k = res2 * pw(cnt2 > 0 ? invp2 : p2, cnt2 < 0 ? -cnt2 : cnt2) % P ;\n\t\t--mp[k];\n\t\tk = (res2 * pw(cnt < 0 ? invp2 : p2, cnt < 0 ? -cnt : cnt) % P + res) % P ;\n\t//\tprintf(\"%lld %d %d \",res2, k, cnt + cnt2);\n\t\tk = (ll)k * pw(cnt + cnt2 > 0 ? invp2 : p2, cnt + cnt2 < 0 ? -cnt-cnt2 : cnt+cnt2) % P;\n\t\tif (mp.find(k) != mp.end())\n\t\t\tans += mp[k]; \n\t//\tprintf(\"%d\\n\", k);\n\t}\n\t\n\tstd::cout << ans << std::endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2e5 + 5;\nconst int mod = 1e9 + 7;\nconst int modd = 1e9 + 9;\nconst int X = 1000003;\nconst int XX = 1000007;\ntypedef long long ll;\n#define mp make_pair\n\n\nstruct hash{\n    int x,y;\n};\n\nchar c;\nstring s;\nll n,i,t,tt,a,b,aa,bb,x,xx,bol=1,boll=1,ans;\nmap < pair < int , int > , int > M;\n\nint main(){\n    cin >> n >> s;\n    for(t=X,i=mod-2; i ; i>>=1){\n        if(i & 1) bol = bol*t % mod;\n        t = t*t % mod;\n    }\n    for(t=XX,i=modd-2; i ; i>>=1){\n        if(i & 1) boll = boll*t % modd;\n        t = t*t % modd;\n    }\n\n    for(i=n-1; i>=0 ;i--){\n        c = s[i];\n        if(c == '+') xx++;\n        if(c == '-') xx--;\n        if(c == '>') xx *= XX;\n        if(c == '<') xx *= boll;\n        xx = (xx % modd + modd) % modd;\n        if(c == '-') x--;\n        if(c == '+') x++;\n        if(c == '>') x *= X;\n        if(c == '<') x *= bol;\n        x = (x % mod + mod) % mod;\n    }\n\n    a = 1; b = 0;\n    aa = 1;\n    M[mp(x,xx)] = 1;\n    for(i=0; i<n; i++){\n        c = s[i];\n        if(c == '-') b -= a, bb -= aa;\n        if(c == '+') b += a, bb += aa;\n        if(c == '<') a *= bol, aa *= boll;\n        if(c == '>') a *= X, aa *= XX;\n        a = (a % mod + mod) % mod;\n        b = (b % mod + mod) % mod;\n        aa = (aa % modd + modd) % modd;\n        bb = (bb % modd + modd) % modd;\n\n\n        t = (a*x + b) % mod;\n        tt = (aa*xx + bb) % modd;\n\n        ans += M[mp(b,bb)];\n        M[mp(t,tt)]++;\n    }\n\n    cout << ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define pb push_back\n#define eb emplace_back\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\n    os<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\n    os<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\ntemplate<class S, class T> pair<S,T> operator*(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first*t.first, s.second*t.second);}\ntemplate<class S, class T> pair<S,T> operator%(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first%t.first, s.second%t.second);}\n\ninline ll mod_inverse(ll a, ll m){\n    ll b = m, u = 1, v = 0;\n    while (b) {\n        ll t = a / b;\n        swap(a -= t * b, b);\n        swap(u -= t * v, v);\n    }\n    return (u % m + m) % m;\n}\n\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst pll MOD = pii(1000000021, 1000000009);\n\nconst pll B = pll(10007, 10007);\nconst ll iB = pll(mod_inverse(10007, 1000000021), mod_inverse(10007, 1000000009));\n\nint T, n, m;\nstring s;\nint main(int argc, char *argv[]){\n    ios::sync_with_stdio(false);\n    cin >> n >> s;\n    pll h = pll(0, 0), b = pll(1, 1);\n    for (char c : s) {\n        if (c == '+') h = (h + b) % MOD;\n        if (c == '-') h = (h + MOD - b) % MOD;\n        if (c == '>') b = b * B % MOD;\n        if (c == '<') b = b * iB % MOD;\n    }\n    const pll target = h;\n    ll ans = 0;\n    map<pll, ll> mp;\n    mp[pll(0, 0)] = 1;\n    h = pll(0, 0), b = pll(1, 1);\n    for (char c : s) {\n        if (c == '+') h = (h + b) % MOD;\n        if (c == '-') h = (h + MOD - b) % MOD;\n        if (c == '>') b = b * B % MOD;\n        if (c == '<') b = b * iB % MOD;\n\n        ans += mp[(h + MOD - target) % MOD];\n        mp[(h + target * b + MOD - target) % MOD] ++;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 250005;\nconst int mod = 998244353;\nstruct Num {\n\tint v[6];\n\tinline Num(int v0 = 0, int v1 = 0, int v2 = 0, int v3 = 0, int v4 = 0, int v5 = 0) {\n\t\tv[0] = v0, v[1] = v1, v[2] = v2, v[3] = v3, v[4] = v4, v[5] = v5;\n\t}\n\tinline bool operator < (const Num &oth) const {\n\t\tif (v[0] != oth.v[0]) return v[0] < oth.v[0];\n\t\tif (v[1] != oth.v[1]) return v[1] < oth.v[1];\n\t\tif (v[2] != oth.v[2]) return v[2] < oth.v[2];\n\t\tif (v[3] != oth.v[3]) return v[3] < oth.v[3];\n\t\tif (v[4] != oth.v[4]) return v[4] < oth.v[4];\n\t\tif (v[5] != oth.v[5]) return v[5] < oth.v[5];\n\t\treturn false;\n\t}\n};\nconst int X[6] = {1145141, 1919810, 2333333, 4456787, 9901231, 9374317};\nconst int invX[6] = {54107771, 595887626, 222430835, 659760181, 892625991, 232131244};\nint n, C[6], f[6][N], g[6][N], h[6][N];\nchar S[N];\nmap<Num, int> mp;\nint main() {\n\tscanf(\"%d %s\", &n, S + 1);\n\tfor (int k = 0; k < 6; k++) {\n\t\tC[k] = 0;\n\t\tfor (int i = n; i >= 1; i--) {\n\t\t\tif (S[i] == '+') C[k] = (C[k] + 1) % mod;\n\t\t\telse if (S[i] == '-') C[k] = (C[k] + mod - 1) % mod;\n\t\t\telse if (S[i] == '>') C[k] = 1ll * C[k] * X[k] % mod;\n\t\t\telse C[k] = 1ll * C[k] * invX[k] % mod;\n\t\t}\n\t\tf[k][n + 1] = 0;\n\t\tg[k][n + 1] = C[k];\n\t\th[k][n + 1] = 1;\n\t\tfor (int i = n; i >= 1; i--) {\n\t\t\tif (S[i] == '+') {\n\t\t\t\tf[k][i] = (f[k][i + 1] + mod - h[k][i + 1]) % mod;\n\t\t\t\tg[k][i] = (g[k][i + 1] + mod - h[k][i + 1]) % mod;\n\t\t\t\th[k][i] = h[k][i + 1];\n\t\t\t} else if (S[i] == '-') {\n\t\t\t\tf[k][i] = (f[k][i + 1] + h[k][i + 1]) % mod;\n\t\t\t\tg[k][i] = (g[k][i + 1] + h[k][i + 1]) % mod;\n\t\t\t\th[k][i] = h[k][i + 1];\n\t\t\t} else if (S[i] == '>') {\n\t\t\t\tf[k][i] = f[k][i + 1];\n\t\t\t\th[k][i] = 1ll * h[k][i + 1] * invX[k] % mod;\n\t\t\t\tg[k][i] = (g[k][i + 1] + 1ll * C[k] * (h[k][i] - h[k][i + 1] + mod)) % mod;\n\t\t\t} else {\n\t\t\t\tf[k][i] = f[k][i + 1];\n\t\t\t\th[k][i] = 1ll * h[k][i + 1] * X[k] % mod;\n\t\t\t\tg[k][i] = (g[k][i + 1] + 1ll * C[k] * (h[k][i] - h[k][i + 1] + mod)) % mod;\n\t\t\t}\n\t\t}\n\t}\n\tlong long ans = 0;\n\tfor (int i = n; i >= 1; i--) {\n\t\t++mp[Num(f[0][i + 1], f[1][i + 1], f[2][i + 1], f[3][i + 1], f[4][i + 1], f[5][i + 1])];\n\t\tauto it = mp.find(Num(g[0][i], g[1][i], g[2][i], g[3][i], g[4][i], g[5][i]));\n\t\tif (it != mp.end()) ans += it -> second;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define N 250052\n#define p 1000000007\n#define q 19260817\ninline int mod(int x){return x<p?x:x-p;}\nchar s[N];int A[q],B[N],C[N],D[N],T,a[N],b[N],i,j,n;long long z;\ninline int Hash(int x)\n{\n    int y=x%q;\n    for(j=A[y];j;j=B[j])if(C[j]==x)return j;\n    return 0;\n}\ninline void add(int x)\n{\n    int y=Hash(x);\n    !y?B[++T]=A[y=x%q],C[A[y]=T]=x,D[T]=1:D[y]++;\n}\nint main()\n{\n    scanf(\"%d%s\",&n,s+1);\n    for(*a=i=1;i<=n;i++)\n    if(s[i]=='+')a[i]=a[i-1],b[i]=mod(a[i-1]+b[i-1]);\n    else if(s[i]=='-')a[i]=a[i-1],b[i]=mod(p+b[i-1]-a[i-1]);\n    else if(s[i]=='>')a[i]=499122177ll*a[i-1]%p,b[i]=b[i-1];\n    else a[i]=229537957ll*a[i-1]%p,b[i]=b[i-1];\n    for(i=1;i<=n;i++)add(((long long)b[n]*a[i-1]+b[i-1])%p),z+=D[Hash(b[i])];\n    return 0*printf(\"%lld\\n\",z);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\n#include <deque>\n#include <queue>\n#include <vector>\n#include <map>\nusing namespace std;\nmap<unsigned long long,int>M;\nconst unsigned long long key=1e9+7,N=110000;\nunsigned long long invkey;\nchar ch[N+10];\nint n;\nunsigned long long quick(unsigned long long k1,unsigned long long k2){\n\tunsigned long long k3=1;\n\twhile (k2){\n\t\tif (k2&1) k3*=k1;\n\t\tk1*=k1; k2>>=1;\n\t}\n\treturn k3;\n}\nunsigned long long mul=0,add=0;\nunsigned long long getall(){\n\tunsigned long long k1=1,ans=0;\n\tfor (int i=1;i<=n;i++)\n\t\tif (ch[i]=='+') ans+=k1;\n\t\telse if (ch[i]=='-') ans-=k1;\n\t\telse if (ch[i]=='>') k1*=key;\n\t\telse k1*=invkey;\n\treturn ans;\n}\nunsigned long long getb(unsigned long long ke,unsigned long long a,unsigned long long b){\n\treturn (ke-b)*quick(a,(1ull<<63)-1);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",ch+1);\n\tinvkey=quick(key,(1ull<<63)-1);\n\tunsigned long long ke=getall();\n\tunsigned long long a=1,b=0;\n\tlong long ans=0;\n\tfor (int i=n;i;i--){\n\t\tans+=M[getb(ke,a,b)];\n\t\tM[getb(0,a,b)]++;\n\t\tif (ch[i]=='+') b++;\n\t\telse if (ch[i]=='-') b--;\n\t\telse if (ch[i]=='>') b*=key,a*=key;\n\t\telse if (ch[i]=='<') b*=invkey,a*=invkey;\n\t}\n\tans+=M[getb(ke,a,b)];\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int mod=1e9+7;\nmt19937 ran(time(nullptr));\ninline int get_mod(int x){\n\treturn x<mod?x:x-mod;\n}\nstruct Hasher{\n\tint v,v2;\n\tHasher(int _v=0,int _v2=0):v(_v),v2(_v2){}\n\tinline Hasher operator+(const Hasher& rhs) const{\n\t\treturn Hasher(get_mod(v+rhs.v),get_mod(v2+rhs.v2));\n\t}\n\tinline Hasher operator-(const Hasher& rhs) const{\n\t\treturn Hasher(get_mod(v+mod-rhs.v),get_mod(v2+mod-rhs.v2));\n\t}\n\tinline Hasher operator*(const Hasher& rhs) const{\n\t\treturn Hasher((ll)v*rhs.v%mod,(ll)v2*rhs.v2%mod);\n\t}\n\tinline bool operator<(const Hasher& rhs) const{\n\t\treturn v!=rhs.v?v<rhs.v:v2<rhs.v2;\n\t}\n\tinline bool operator==(const Hasher& rhs) const{\n\t\treturn v==rhs.v && v2==rhs.v2;\n\t}\n} mul_pow[500010],inv_pow[500010],mul=Hasher(ran()%mod,ran()%mod),hash_v[250010];\nmap<Hasher,int> dic;\nchar str[250010];\ninline Hasher qpow(Hasher base,int pw){\n\tHasher res=Hasher(1,1);\n\twhile(pw){\n\t\tif(pw&1) res=res*base;\n\t\tbase=base*base;\n\t\tpw>>=1;\n\t}\n\treturn res;\n}\nint main(){\n\tint n;\n\tscanf(\"%d%s\",&n,str+1);\n\tmul_pow[0]=Hasher(1,1);\n\tinv_pow[0]=Hasher(1,1);\n\tHasher mul_inv=qpow(mul,mod-2);\n\tfor(int i=1;i<=2*n;i++){\n\t\tmul_pow[i]=mul_pow[i-1]*mul;\n\t\tinv_pow[i]=inv_pow[i-1]*mul_inv;\n\t}\n\tint pos=n;\n\tll ans=0;\n\tfor(int i=1;i<=n;i++){\n\t\tif(str[i]=='+'){\n\t\t\thash_v[i]=hash_v[i-1]+mul_pow[pos];\n\t\t}else if(str[i]=='-'){\n\t\t\thash_v[i]=hash_v[i-1]-mul_pow[pos];\n\t\t}else if(str[i]=='>'){\n\t\t\tpos++;\n\t\t\thash_v[i]=hash_v[i-1];\n\t\t}else if(str[i]=='<'){\n\t\t\tpos--;\n\t\t\thash_v[i]=hash_v[i-1];\n\t\t}\n\t}\n\tpos=n;\n\tfor(int i=1;i<=n;i++){\n\t\tif(hash_v[i]==hash_v[n]) ans++;\n\t\tif(str[i]=='>') pos++;\n\t\telse if(str[i]=='<') pos--;\n\t\tans+=dic[hash_v[i]];\n\t\tif(pos<n)\n\t\t\tdic[hash_v[n]*inv_pow[n-pos]+hash_v[i]]++;\n\t\telse\n\t\t\tdic[hash_v[n]*mul_pow[pos-n]+hash_v[i]]++;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a % b); }\nll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\nll extgcd(ll a, ll b, ll &x, ll &y) { ll d; return b == 0 ? (x = 1, y = 0, a) : (d = extgcd(b, a % b, y, x), y -= a / b * x, d); }\nll modinv(ll a, ll mod = 1e9 + 7) { ll x = 0, y = 0; extgcd(a, mod, x, y); return (x + mod) % mod; }\nll modpow(ll a, ll b, ll mod = 1e9 + 7) { ll r = 1; a %= mod; while(b) { if(b & 1) r = r * a % mod; a = a * a % mod; b >>= 1; } return r; }\n\nconst int N = 250000 + 10;\nconst ll mod = 1e9 + 7;\nvector<ll> gen{114514, 1919};\nvector<map<ll, int>> Bex(gen.size());\nint n;\nstring s;\nint ms[N];\nll calc(int i, int c, ll x) {\n  if(i == 0) {\n    // A\n    if(c <= 1) return 1;\n    if(c == 2) return modinv(x, mod);\n    return x;\n  } else {\n    if(c == 0) return 1;\n    if(c == 1) return -1;\n    return 0;\n  }\n}\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  cin >> n >> s;\n  vector<vector<ll>> A(gen.size(), vector<ll>(n+2)), B = A;\n  for(int i = 0; i < n; i++) {\n    if(s[i] == '+') ms[i] = 0;\n    else if(s[i] == '-') ms[i] = 1;\n    else if(s[i] == '>') ms[i] = 2;\n    else ms[i] = 3;\n  }\n  for(int k = 0; k < gen.size(); k++) {\n    gen[k] = ((gen[k] % mod + mod) % mod);\n    ll x = gen[k];\n    A[k][1] = 1;\n    B[k][1] = 0;\n    for(int i = 0; i < n; i++) {\n      A[k][i+2] = A[k][i+1] * calc(0, ms[i], x) % mod;\n      B[k][i+2] = A[k][i+1] * calc(1, ms[i], x) % mod + B[k][i+1];\n      B[k][i+2] = ((B[k][i+2] % mod + mod) % mod);\n      Bex[k][B[k][i+2]]++;\n    }\n  }\n  ll ans = 0;\n  for(int i = 0; i < n; i++) {\n    ll mi = 1e18;\n    for(int k = 0; k < gen.size(); k++) {\n      ll c = A[k][i+1] * B[k][n+1] % mod;\n      c += B[k][i+1];\n      c %= mod;\n      ll cnt = Bex[k][c];\n      mi = min(mi, cnt);\n      // if(cnt != mi) mi = min(mi, cnt);\n      // else break;\n    }\n    for(int k = 0; k < gen.size(); k++) Bex[k][B[k][i+2]]--;\n    ans += mi;\n  }\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int mod = 1e9 + 9;\nconst int MN = 250010;\nconst int P = 1e6 + 7;\n\nint exp(int x, int n) {\n    int ret = 1;\n    while(n) {\n        if(n & 1) ret = 1LL * ret * x % mod;\n        x = 1LL * x * x % mod;\n        n >>= 1;\n    }\n    return ret;\n}\nint inv(int x) {\n    return exp(x, mod - 2);\n}\nint po[MN << 1];\n\nint N;\nchar S[MN];\nint A[MN << 1];\nunordered_map<int, int> cnt;\n\nint main() {\n    po[0] = 1;\n    for(int i = 1; i < (MN << 1); i++) {\n        po[i] = 1LL * po[i - 1] * P % mod;\n    }\n\n    scanf(\"%d\", &N);\n\n    scanf(\"\\n\");\n    for(int i = 0; i < N; i++) {\n        scanf(\"%c\", &S[i]);\n    }\n\n    int pos = MN;\n    for(int i = 0; i < N; i++) {\n        if(S[i] == '+') A[pos]++;\n        if(S[i] == '-') A[pos]--;\n        if(S[i] == '<') pos--;\n        if(S[i] == '>') pos++;\n    }\n\n    int hval = 0;\n    for(int i = 0; i < (MN << 1); i++) {\n        hval += 1LL * (A[i] + mod) % mod * po[i] % mod;\n        hval %= mod;\n    }\n\n    int a = 1, b = 0;\n    ll ans = 0;\n    for(int i = N - 1; i >= 0; i--) {\n\n        cnt[ 1LL * (mod - b) * inv(a) % mod ]++;\n\n        if(S[i] == '+') {\n            b += po[MN];\n            b %= mod;\n        }\n        if(S[i] == '-') {\n            b += mod - po[MN];\n            b %= mod;\n        }\n        if(S[i] == '<') {\n            a = 1LL * a * inv(P) % mod;\n            b = 1LL * b * inv(P) % mod;\n        }\n        if(S[i] == '>') {\n            a = 1LL * a * P % mod;\n            b = 1LL * b * P % mod;\n        }\n\n        ans += cnt[ 1LL * (hval + mod - b) % mod * inv(a) % mod ];\n    }\n\n    printf(\"%lld\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<iostream>\n#define LL long long\n#define MP make_pair\nusing namespace std;\nconst LL mod=1e9+7;\nLL base[2],pre[2][500010],inv[2];\nstruct node{LL a,b;}op[2][250010];\nmap<pair<LL,LL>,LL> mp;\nLL pow(LL a,LL b)\n{\n\tLL ans=1;\n\twhile(b)\n\t{\n\t\tif(b&1) ans=ans*a%mod;\n\t\ta=a*a%mod;b>>=1;\n\t}\n\treturn ans;\n}\nLL n,p=0,t[500010],c[2],a[2][250010],b[2][250010];\nchar s[250010];\nvoid Pre()\n{\n\tfor(int k=0;k<2;k++)\n\t{\n\t\tLL cnt=1;op[k][n+1].a=1;\n\t\tfor(LL i=n;i>=1;i--)\n\t\t{\n\t\t\top[k][i]=op[k][i+1];\n\t\t\tif(s[i]=='<') cnt=cnt*base[k]%mod,(op[k][i].a*=base[k])%=mod;\n\t\t\tif(s[i]=='>') cnt=cnt*inv[k]%mod,(op[k][i].a*=inv[k])%=mod;\n\t\t\tif(s[i]=='-') (op[k][i].b+=cnt*pre[k][n]%mod)%=mod;\n\t\t\tif(s[i]=='+') op[k][i].b=((op[k][i].b-cnt*pre[k][n]%mod)%mod+mod)%mod;\n\t\t}\n\t}\n}\nvoid solve(LL *a,LL c,LL k) {for(LL i=1;i<=n;i++) a[i]=(c*op[k][i].a%mod+op[k][i].b)%mod;}\nint main()\n{\n\tbase[0]=2333;base[1]=10037;\n\tinv[0]=pow(base[0],mod-2);inv[1]=pow(base[1],mod-2);\n\tscanf(\"%lld\",&n);getchar();\n\tscanf(\"%s\",s+1);\n\tfor(LL k=0;k<2;k++)\n\t{\n\t\tpre[k][0]=1;for(LL i=1;i<=2*n;i++) pre[k][i]=pre[k][i-1]*base[k]%mod;\n\t}\n\tfor(LL i=1;i<=n;i++)\n\t{\n\t\tif(s[i]=='<') p--;if(s[i]=='>') p++;\n\t\tif(s[i]=='-') t[p+n]--;if(s[i]=='+') t[p+n]++;\n\t}\n\tfor(int k=0;k<2;k++)\n\t\tfor(LL i=-n;i<=n;i++) (c[k]+=pre[k][i+n]*t[i+n]%mod)%=mod;\n\tPre();\n\tsolve(a[0],0,0);solve(a[1],0,0);solve(b[0],c[0],0);solve(b[1],c[1],1);\n\tLL ans=0;\n\t//printf(\"c:%lld\\n\",c);\n\t//for(int i=1;i<=n;i++) printf(\"op:%lld %lld\\n\",op[i].a,op[i].b);\n\t//for(LL i=-n;i<=n;i++) printf(\"%lld:%lld %lld\\n\",i,t[i+n],pre[i+n]);printf(\"\\n\");\n\t//printf(\"a:\");for(int i=1;i<=n;i++) printf(\"%lld \",a[i]);printf(\"\\n\");\n\t//printf(\"b:\");for(int i=1;i<=n;i++) printf(\"%lld \",b[i]);printf(\"\\n\");\n\t//mp[c]++;\n\tfor(LL i=2;i<=n;i++)\n\t{\n\t\tmp[MP(b[0][i-1],b[1][i-1])]++;\n\t\tans+=mp[MP(a[0][i],a[1][i])];\n\t}\n\tmp[MP(b[0][n],b[1][n])]++;\n\tans+=mp[MP(0,0)];\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \nconst int N = 2e5 + 5;\n//const int mod = 1e9 + 7;\ntypedef long long ll;\n#define mp make_pair\n \nchar c;\nstring s;\nll n,i,ans;\nmap < pair < int , int > , int > M;\n \n \nstruct hashh{\n    ll t,a,b,x,bol,X,mod;\n    hashh() { t=b=x=X=mod=0; a=bol=1; }\n    void f(){ \n        for(t=X,i=mod-2; i ; i>>=1){\n            if(i & 1) bol = bol*t % mod;\n            t = t*t % mod;\n        }\n        for(i=n-1; i>=0 ;i--){\n            c = s[i];\n            if(c == '-') x--;\n            if(c == '+') x++;\n            if(c == '>') x *= X;\n            if(c == '<') x *= bol;\n            x = (x % mod + mod) % mod;\n        }\n    }       \n                \n    void g(){               \n        if(c == '+') b -= a;                \n        if(c == '-') b += a;                            \n        if(c == '>') a *= bol;                                  \n        if(c == '<') a *= X;        \n        a = (a % mod + mod) % mod;                  \n        b = (b % mod + mod) % mod;                              \n        t = (a*x + b) % mod;                                                \n    }                                                                                   \n};                                                                                                  \n                                                                                                                \nint main(){                                                                                                             \n    cin >> n >> s;                      \n                                                                                                                            \n    hashh h1,h2;    \n    h1.mod = 1e9+7;  h1.X=10000003; h1.f();\n    h2.mod = 1e9+9;  h2.X=1000007; h2.f();\n                                                \n    M[mp(0,0)] = 1;                                     \n    for(i=n-1; i>=0 ;i--){                                      \n        c = s[i];                                                       \n        h1.g(); h2.g();                                                         \n                                                                                    \n        ans += M[mp(h1.t,h2.t)];                                                    \n        M[mp(h1.b,h2.b)]++;                                                             \n    }\n        \n    cout << ans;\n    return 0;\n}    "
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<map>\nusing namespace std;\ntypedef long long ll;\nconst ll mod=1000000000000000031ll,b=1000000000000000003ll,rb=821428571428571454ll;\nll mul(ll a,ll b){return(__int128)a*b%mod;}\nll ad(ll a,ll b){return(a+b)%mod;}\nll pow(ll a,ll b){\n\tll s=1;\n\twhile(b){\n\t\tif(b&1)s=mul(s,a);\n\t\ta=mul(a,a);\n\t\tb>>=1;\n\t}\n\treturn s;\n}\nchar s[250010];\nll p[250010],st[250010];\nmap<ll,int>m;\nint main(){\n\tint n,i;\n\tll ans;\n\tscanf(\"%d%s\",&n,s+1);\n\tp[0]=1;\n\tfor(i=1;i<=n;i++){\n\t\tp[i]=p[i-1];\n\t\tst[i]=st[i-1];\n\t\tswitch(s[i]){\n\t\t\tcase'+':st[i]=ad(st[i],p[i]);break;\n\t\t\tcase'-':st[i]=ad(st[i],mod-p[i]);break;\n\t\t\tcase'>':p[i]=mul(p[i],b);break;\n\t\t\tcase'<':p[i]=mul(p[i],rb);break;\n\t\t}\n\t}\n\tans=0;\n\tfor(i=n;i>0;i--){\n\t\tm[st[i]]++;\n\t\tans+=m[ad(mul(st[n],p[i-1]),st[i-1])];\n\t}\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int unsigned long long\nusing namespace std;\nint f[1001000],X,Y;\nlong long ans,n;\nchar S[1001000];\nmap<int,int>mp;\nsigned main(){\n\tscanf(\"%lld%s\",&n,S+1);\n\tX=1;\n\tint base=233,inv=7204522363551799129;\n\tfor(int i=1;i<=n;i++){\n\t\tif(S[i]=='+')f[i]=f[i-1]+X;\n\t\tif(S[i]=='-')f[i]=f[i-1]-X;\n\t\tif(S[i]=='<')f[i]=f[i-1],X=X*base;\n\t\tif(S[i]=='>')f[i]=f[i-1],X=X*inv;\n\t\tmp[f[i]]++;\t\t\n\t}\n\tX=1,Y=0;\n\tfor(int i=1;i<=n;i++){\n\t\tans=ans+mp[f[n]*X+Y];\n\t\tif(S[i]=='+')Y=Y+X;\n\t\tif(S[i]=='-')Y=Y-X;\n\t\tif(S[i]=='<')X=X*base;\n\t\tif(S[i]=='>')X=X*inv;\n\t\tmp[f[i]]--;\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ri rd<int>\n#define rep(i, a, b) for (int i = (a), _ = (b); i <= _; ++i)\n#define per(i, a, b) for (int i = (a), _ = (b); i >= _; --i)\n#define For(i, a, b) for (int i = (a), _ = (b); i < _; ++i)\nconst int O1 = 1004535809;\nconst int O2 = 998244353;\nint O, W, _W;\nconst int maxN = 250007;\ntypedef long long LL;\n\ntemplate<class T> inline T rd() {\n\tbool f = 1; char c = getchar(); for (; !isdigit(c); c = getchar()) if (c == '-') f = 0;\n\tT x = 0; for (; isdigit(c); c = getchar()) x = x * 10 + c - '0'; return f ? x : -x;\n}\n\nint pwr(int x, int t) {\n\tint res = 1;\n\tfor (; t > 0; t >>= 1, x = 1LL * x * x % O)\n\t\tif (t & 1) res = 1LL * res * x % O;\n\treturn res;\n}\n\ninline int inv(int x) { return pwr(x, O-2); }\n\nint n;\nchar s[maxN];\nint ps[2][maxN], hsh[2][maxN];\n\nvoid init(int *ps, int *hsh) {\n\thsh[0] = 0, ps[0] = 1;\n\trep (i, 1, n) {\n\t\tif (s[i] == '+') {\n\t\t\tps[i] = ps[i-1];\n\t\t\thsh[i] = (hsh[i-1] + ps[i]) % O;\n\t\t}\n\t\telse if (s[i] == '-') {\n\t\t\tps[i] = ps[i-1];\n\t\t\thsh[i] = (hsh[i-1] + O - ps[i]) % O;\n\t\t}\n\t\telse if (s[i] == '<') {\n\t\t\tps[i] = 1LL * ps[i-1] * _W % O;\n\t\t\thsh[i] = hsh[i-1];\n\t\t}\n\t\telse if (s[i] == '>') {\n\t\t\tps[i] = 1LL * ps[i-1] * W % O;\n\t\t\thsh[i] = hsh[i-1];\n\t\t}\n\t\telse assert(false);\n\t}\n}\n\nvoid solve() {\n\tmap<pair<int, int>, int> mp;\n\tLL res = 0;\n\trep (i, 0, n) {\n\t\tif (i > 0) res += mp[pair<int,int>(hsh[0][i], hsh[1][i])];\n\t\tif (i < n) ++mp[pair<int,int>((hsh[0][i] + 1LL * hsh[0][n] * ps[0][i]) % O1, (hsh[1][i] + 1LL * hsh[1][n] * ps[1][i]) % O2)];\n\t}\n\tprintf(\"%lld\\n\", res);\n}\n\nint main() {\n\n\tn = ri();\n\tscanf(\"%s\", s+1);\n\n\tO = O1, W = 131, _W = inv(W);\n\tinit(ps[0], hsh[0]);\n\tO = O2, W = 1000003, _W = inv(W);\n\tinit(ps[1], hsh[1]);\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author aajisaka\n */\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n#define SPEED ios_base::sync_with_stdio(false);cin.tie(nullptr)\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define all(v) v.begin(), v.end()\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing P = pair<ll, ll>;\n\nconstexpr long double PI = 3.14159265358979323846264338327950288L;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nconstexpr ll mod17 = 1e9+7;\nconstexpr ll mod19 = 1e9+9;\nconstexpr ll mod9 = 998244353;\nll mod = mod17;\n\n// Mod int libraries\ntemplate<typename T>\nT mod_pow(T a, ll x) {\n  T res = 1;\n  while(x > 0) {\n    if (x & 1) res *= a;\n    a *= a; x >>= 1;\n  }\n  return res;\n}\n\n// Mint32\nunordered_map<ll, ll> minvmap;\nll minv(ll a, ll m) {\n  auto k = a; auto p = minvmap[a]; if (p != 0) return p;\n  ll b = m, u = 1, v = 0;\n  while (b) { ll t = a/b; swap(a -= t*b, b); swap(u -= t*v, v); }\n  p = (u%m+m)%m; minvmap[k] = p; return p;\n}\n\nstruct mint {\n  ll x;\n  mint():x(0){}\n  mint(ll x):x((x%mod+mod)%mod){}\n  mint& fix() { x = (x%mod+mod)%mod; return *this;}\n  mint operator-() const { return mint(0) - *this;}\n  mint& operator+=(const mint& a){ if((x+=a.x)>=mod) x-=mod; return *this;}\n  mint& operator-=(const mint& a){ if((x+=mod-a.x)>=mod) x-=mod; return *this;}\n  mint& operator*=(const mint& a){ (x*=a.x)%=mod; return *this;}\n  mint& operator/=(const mint& a){ (x*=minv(a.x, mod))%=mod; return *this; }\n  mint operator+(const mint& a)const{ return mint(*this) += a;}\n  mint operator-(const mint& a)const{ return mint(*this) -= a;}\n  mint operator*(const mint& a)const{ return mint(*this) *= a;}\n  mint operator/(const mint& a)const{ return mint(*this) /= a;}\n  bool operator<(const mint& a)const{ return x < a.x;}\n  bool operator==(const mint& a)const{ return x == a.x;}\n};\n\n// Mint64\nstruct mint64 {\n    ull x;\n    static ull mod, inv, r2;\n    mint64(): x(0){}\n    mint64(ull x): x(init(x)) {}\n    static ull init(ull x) { return reduce(__uint128_t(x)*r2);}\n    static void set_mod(ull m) {\n      mod = inv = m;\n      for(int i=0; i<5; i++) inv *= 2 - inv*m;\n      r2 = -__uint128_t(m)%m;\n    }\n    static ull reduce(__uint128_t x) {\n      ull y = ull(x >> 64) - ull((__uint128_t(ull(x)*inv)*mod)>>64);\n      return ll(y) < 0 ? y+mod : y;\n    }\n    mint64& operator+=(mint64& a) { x+=a.x-mod; if(ll(x)<0) x+=mod; return *this; }\n    mint64 operator+(mint64& a) const{ return mint64(*this)+=a; }\n    mint64& operator*=(mint64& a) { x=reduce(__uint128_t(x)*a.x); return *this; }\n    mint64 operator*(mint64& a) const { return mint64(*this)*=a; }\n};\n\null mint64::mod, mint64::inv, mint64::r2;\n\n// Verify: https://yukicoder.me/submissions/472580\nstruct Miller {\n    const vector<ull> v = {2, 325, 9375, 28178, 450775, 9780504, 1795265022};\n    bool suspect(ull a, ull s, ull d, ull n) {\n      if (mint64::mod != n) mint64::set_mod(n);\n      mint64 one = 1, minusone = n-1, ma = a;\n      auto x = mod_pow(ma, d);\n      if (x.x == one.x) return true;\n      for(int r = 0; r < s; r++) {\n        if (x.x == minusone.x) return true;\n        x = x * x;\n      }\n      return false;\n    }\n\n    // check if n is prime\n    bool check(ull n) {\n      if (n < 2 || (n > 2 && n % 2 == 0)) return false;\n      ull d = n - 1;\n      ull s = 0;\n      while (!(d & 1)) {\n        d >>= 1;\n        s++;\n      }\n      for (auto a: v) {\n        if (a >= n) break;\n        if (!suspect(a, s, d, n)) return false;\n      }\n      return true;\n    }\n};\n\nclass combination {\n    // factorial\n    public: std::vector<mint> fact;\n    public: std::vector<mint> inv;\n\n    combination(int n) {\n      fact.resize(n + 1);\n      inv.resize(n + 1);\n      fact[0] = 1;\n      for (int i = 1; i <= n; i++) {\n        fact[i] = fact[i - 1] * i;\n      }\n      inv[n] = mint(1) / fact[n];\n      for (int i = n - 1; i >= 0; i--) {\n        inv[i] = inv[i + 1] * (i + 1);\n      }\n    }\n\n    // nCr\n    public: mint get(int n, int r) {\n      if (n < r || n < 0 || r < 0) return 0;\n      return fact[n]*inv[r]*inv[n-r];\n    }\n    // nPr\n    public: mint p(int n, int r) {\n      if (n < r || n < 0) return 0;\n      return fact[n]*inv[n-r];\n    }\n};\n\n\nclass FEatingSymbolsHard {\npublic:\n    void solve(istream& cin, ostream& cout) {\n      SPEED;\n      int n; cin >> n;\n      string s; cin >> s;\n      vector<mint> base = {983, 9059, 10009, 99991};\n      vector<mint> invBase(4);\n      rep(i, 4) {\n        invBase[i] = mint(1)/base[i];\n      }\n      vector<int> pos(n+1);\n      vector<vector<mint>> vec(4, vector<mint>(n+1));\n\n      rep(i, n) {\n        pos[i+1] = pos[i];\n        rep(k, 4) {\n          vec[k][i+1] = vec[k][i];\n        }\n        if (s[i] == '+') {\n          rep(k, 4) {\n            if (pos[i] < 0) {\n              vec[k][i+1] += mod_pow(invBase[k], -pos[i]);\n            } else {\n              vec[k][i+1] += mod_pow(base[k], pos[i]);\n            }\n          }\n        } else if (s[i] == '-') {\n          rep(k, 4) {\n            if (pos[i] < 0) {\n              vec[k][i+1] -= mod_pow(invBase[k], -pos[i]);\n            } else {\n              vec[k][i+1] -= mod_pow(base[k], pos[i]);\n            }\n          }\n        } else if (s[i] == '<') {\n          pos[i+1]--;\n        } else {\n          pos[i+1]++;\n        }\n      }\n\n      map<mint, ll> mp[4];\n      ll ans = 0;\n      for(int i=n; i>=0; i--) {\n        map<int, int> cnt;\n        rep(k, 4) {\n          mint r;\n          if (pos[i] < 0) {\n            r = mod_pow(invBase[k], -pos[i]);\n          } else {\n            r = mod_pow(base[k], pos[i]);\n          }\n          auto q = vec[k][i] + vec[k][n] * r;\n          if (mp[k].find(q) == mp[k].end()) {\n            cnt[0]++;\n          } else {\n            cnt[mp[k][q]]++;\n          }\n        }\n        bool flag = false;\n        for(auto e: cnt) {\n          if (e.second >= 3) {\n            ans += e.first;\n            flag = true;\n          }\n        }\n        assert(flag);\n        rep(k, 4) {\n          mp[k][vec[k][i]]++;\n        }\n      }\n\n      cout << ans << endl;\n\n    }\n};\n\nsigned main() {\n  FEatingSymbolsHard solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nAuthor: QAQAutomaton\nLang: C++\nCode: F.cpp\nMail: lk@qaq-am.com\nBlog: https://www.qaq-am.com/\n*/\n#include<bits/stdc++.h>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG printf(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define Debug debug(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define all(x) x.begin(),x.end()\n#define x first\n#define y second\nusing namespace std;\ntypedef unsigned uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef complex<double> cp;\ntypedef pair<int,int> pii;\nint inf;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\ntemplate<class T,class T2>int chkmin(T &a,T2 b){return a>b?a=b,1:0;}\ntemplate<class T,class T2>int chkmax(T &a,T2 b){return a<b?a=b,1:0;}\ntemplate<class T>T sqr(T a){return a*a;}\ntemplate<class T,class T2>T mmin(T a,T2 b){return a<b?a:b;}\ntemplate<class T,class T2>T mmax(T a,T2 b){return a>b?a:b;}\ntemplate<class T>T aabs(T a){return a<0?-a:a;}\ntemplate<class T>int dcmp(T a,T b){return a>b;}\ntemplate<int *a>int cmp_a(int x,int y){return a[x]<a[y];}\n#define min mmin\n#define max mmax\n#define abs aabs\nstruct __INIT__{\n\t__INIT__(){\n\t\tmemset(&inf,0x3f,sizeof(inf));\n\t\tfill((unsigned char*)&inf,(unsigned char*)&inf+sizeof(inf),0x3f);\n\t}\n}__INIT___;\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\ttemplate<typename A>\n\tinline bool read (A &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;else if(c==EOF)return 0;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t\treturn 1;\n\t}\n\tinline bool read (char &x) {\n\t\twhile((x=gc())==' '||x=='\\n' || x=='\\r');\n\t\treturn x!=EOF;\n\t}\n\tinline bool read(char *x){\n\t\twhile((*x=gc())=='\\n' || *x==' '||*x=='\\r');\n\t\tif(*x==EOF)return 0;\n\t\twhile(!(*x=='\\n'||*x==' '||*x=='\\r'||*x==EOF))*(++x)=gc();\n\t\t*x=0;\n\t\treturn 1;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool read(A &x,B &...y){\n\t\treturn read(x)&&read(y...);\n\t}\n\ttemplate<typename A>\n\tinline bool write (A x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t\treturn 0;\n\t}\n\tinline bool write (char x) {\n\t\tputc(x);\n\t\treturn 0;\n\t}\n\tinline bool write(const char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\tinline bool write(char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool write(A x,B ...y){\n\t\treturn write(x)||write(y...);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: read;\nusing io :: putc;\nusing io :: write;\nchar s[250005];\nconst int p=951274487,q=449117,iq=694385027;\nstruct Z{\n\tuint x;\n\tZ(){}\n\tZ(uint a){\n\t\tx=a;\n\t}\n};\ninline uint modp(const uint x){\n\treturn x<p?x:x-p;\n}\ninline Z operator+(const Z x1, const Z x2) { return modp(x1.x+x2.x);}\ninline Z operator-(const Z x1, const Z x2) { return modp(x1.x+p-x2.x);}\ninline Z operator-(const Z x) {return x.x?p-x.x:0;}\ninline Z operator*(const Z x1, const Z x2) { return static_cast<ull>(x1.x)*x2.x%p;}\nvoid exgcd(int a,int b,int &x,int &y){\n\tif(!b){x=1;y=0;return;}\n\texgcd(b,a%b,y,x);\n\ty-=(a/b)*x;\n}\ninline Z Inv(const Z a){\n\tint x,y;\n\texgcd(p,a.x,x,y);\n\treturn y<0?y+=p:y;\n}\ninline Z operator/(const Z x1, const Z x2) { return x1*Inv(x2);}\n\ninline Z &operator++(Z &x1){x1.x==p-1?x1.x=0:++x1.x;return x1;} \ninline Z &operator--(Z &x1){x1.x?--x1.x:x1.x=p-1;return x1;}\ninline Z &operator+=(Z &x1, const Z x2) { return x1 = x1 + x2; }\ninline Z &operator-=(Z &x1, const Z x2) { return x1 = x1 - x2; }\ninline Z &operator*=(Z &x1, const Z x2) { return x1 = x1 * x2; }\ninline Z &operator/=(Z &x1, const Z x2) { return x1 = x1 / x2; }\nZ xpw[500015],*pw=xpw+250005;\nmap<int,int> mp;\nsigned main(){\n#ifdef QAQAutoMaton \n\tfreopen(\"F.in\",\"r\",stdin);\n\tfreopen(\"F.out\",\"w\",stdout);\n#endif\n\tint n;\n\tread(n);\n\tread(s+1);\n\tZ cur=1,cnt=0;\n\tpw[0]=1;\n\tfor(int i=1;i<=n;++i){pw[i]=pw[i-1]*q;}\n\tfor(int i=1;i<=n;++i){pw[-i]=pw[1-i]*iq;}\n\tfor(int i=1;i<=n;++i){\n\t\tswitch(s[i]){\n\t\t\tcase '+':cnt+=cur;break;\n\t\t\tcase '-':cnt-=cur;break;\n\t\t\tcase '<':cur*=iq;break;\n\t\t\tcase '>':cur*=q;break;\n\t\t}\n\t}\n\t++mp[0];\n\tZ now=0;\n\tint c=0;\n\tZ w(1);\n\tll ans=0;\n\tfor(int i=n;i;--i){\n\t\tswitch(s[i]){\n\t\t\tcase '+': now+=w;break;\n\t\t\tcase '-': now-=w;break;\n\t\t\tcase '<': ++c;w*=q;break;\n\t\t\tcase '>': --c;w*=iq;break;\n\t\t}\n\t\tans+=mp[(now-cnt*pw[c]).x];\n\t\t++mp[now.x];\n\t}\n\twrite(ans,'\\n');\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fo(a,b,c) for (a=b; a<=c; a++)\n#define fd(a,b,c) for (a=b; a>=c; a--)\n#define mod 1000000007\n#define Mod 1000000005\n#define ll long long\n//#define file\nusing namespace std;\n\nll p[250001],P[250001],pp[250001],PP[250001],hs[250001],Hs[250001],s,S,p1,p2,p3,p4,ans;\nint sum[250001],n,i,j,k,l;\nchar st[250001];\nmap<pair<int,int>,int> mp;\nmap<pair<int,int>,int> :: iterator I;\n\nll qpower(ll a,int b) {ll ans=1; while (b) {if (b&1) ans=ans*a%mod;a=a*a%mod;b>>=1;} return ans;}\nll Pow(int t) {return (t>=0)?p[t]:P[-t];}\nll Pow2(int t) {return (t>=0)?pp[t]:PP[-t];}\n\nint main()\n{\n\t#ifdef file\n\tfreopen(\"arc099f.in\",\"r\",stdin);\n\t#endif\n\t\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",st+1);\n\tp1=123456789,p2=qpower(p1,Mod);\n\tp3=114514191,p4=qpower(p3,Mod);\n\tp[0]=P[0]=pp[0]=PP[0]=1;\n\tfo(i,1,n) p[i]=p[i-1]*p1%mod,P[i]=P[i-1]*p2%mod,pp[i]=pp[i-1]*p3%mod,PP[i]=PP[i-1]*p4%mod;\n\t\n\tfd(i,n,1)\n\t{\n\t\tswitch (st[i])\n\t\t{\n\t\t\tcase '>':{sum[i]=1,s=s*p1%mod;break;}\n\t\t\tcase '<':{sum[i]=-1,s=s*p2%mod;break;}\n\t\t\tcase '+':{s=(s+1)%mod;break;}\n\t\t\tcase '-':{s=(s-1)%mod;break;}\n\t\t}\n\t\ts=(s+mod)%mod;\n\t\ths[i]=s;\n\t}\n\ts=0;\n\tfd(i,n,1)\n\t{\n\t\tswitch (st[i])\n\t\t{\n\t\t\tcase '>':{sum[i]=1,s=s*p3%mod;break;}\n\t\t\tcase '<':{sum[i]=-1,s=s*p4%mod;break;}\n\t\t\tcase '+':{s=(s+1)%mod;break;}\n\t\t\tcase '-':{s=(s-1)%mod;break;}\n\t\t}\n\t\ts=(s+mod)%mod;\n\t\tHs[i]=s;\n\t}\n\tfo(i,1,n) sum[i]+=sum[i-1];\n\t\n\tmp[pair<int,int>(0,0)]=1;\n\tfd(i,n,1)\n\t{\n\t\ts=((hs[i]-hs[1])*Pow(sum[i-1])%mod+mod)%mod;\n\t\tS=((Hs[i]-Hs[1])*Pow2(sum[i-1])%mod+mod)%mod;\n\t\tI=mp.find(pair<int,int>(s,S));\n\t\tif (I!=mp.end())\n\t\tans+=I->second;\n\t\t++mp[pair<int,int>(hs[i]*Pow(sum[i-1])%mod,Hs[i]*Pow2(sum[i-1])%mod)];\n\t}\n\tprintf(\"%lld\\n\",ans);\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n\ntypedef pair<int, int> ii;\n\nconst int B = 1e6 + 7;\n\nconst int N = 250005;\n\nconst int mod1 = 1e9 + 7;\nconst int mod2 = 1e9 + 9;\n\nint cnt = N - 5, pw[2][2 * N], lmao[N], n, hs[2][N];\n\nlong long sum = 0;\n\nstring s;\n\nii type;\n\nmap<ii, int> mymap;\n\nint BinPow(int x, int m, int mod) {\n    if(m == 0)\n        return 1;\n    else if(m == 1)\n        return x % mod;\n    else {\n        int sum = BinPow(x, m >> 1, mod);\n        sum = (1ll * sum * sum) % mod;\n        if(m % 2)\n            sum = (1ll * sum * x) % mod;\n        return sum;\n    }\n}\n\nint main() {\n    cin.tie(0), ios::sync_with_stdio(0);\n    cin >> n;\n    cin >> s;\n    s = \"+\" + s;\n    pw[0][0] = pw[1][0] = 1;\n    for(int i = 1; i <= 2 * N - 10; i++) {\n        pw[0][i] = (1ll * pw[0][i - 1] * B) % mod1;\n        pw[1][i] = (1ll * pw[1][i - 1] * B) % mod2;\n    }\n    for(int i = 1; i <= n; i++) {\n        lmao[i] = cnt;\n        if(s[i] == '+') {\n            hs[0][i] = (1ll * hs[0][i - 1] + pw[0][cnt]) % mod1;\n            hs[1][i] = (1ll * hs[1][i - 1] + pw[1][cnt]) % mod2;\n        }\n        if(s[i] == '-') {\n            hs[0][i] = (1ll * hs[0][i - 1] - pw[0][cnt]) % mod1;\n            hs[1][i] = (1ll * hs[1][i - 1] - pw[1][cnt]) % mod2;\n            hs[0][i] = (1ll * hs[0][i] + mod1) % mod1;\n            hs[1][i] = (1ll * hs[1][i] + mod2) % mod2;\n        }\n        if(s[i] == '>'){\n            cnt++;\n            hs[0][i] = (1ll * hs[0][i - 1] + mod1) % mod1;\n            hs[1][i] = (1ll * hs[1][i - 1] + mod2) % mod2;\n        }\n        if(s[i] == '<'){\n            cnt--;\n            hs[0][i] = (1ll * hs[0][i - 1] + mod1) % mod1;\n            hs[1][i] = (1ll * hs[1][i - 1] + mod2) % mod2;\n        }\n    }\n    int x1 = (1ll * hs[0][n] * BinPow(pw[0][lmao[1]], mod1 - 2, mod1)) % mod1;\n    int x2 = (1ll * hs[1][n] * BinPow(pw[1][lmao[1]], mod2 - 2, mod2)) % mod2;\n    type = {x1, x2};\n    for(int i = n; i >= 1; i--) {\n        mymap[{hs[0][i], hs[1][i]}]++;\n        x1 = ((1ll * type.fi * pw[0][lmao[i]]) % mod1 + 1ll * hs[0][i - 1]) % mod1;\n        x2 = ((1ll * type.se * pw[1][lmao[i]]) % mod2 + 1ll * hs[1][i - 1]) % mod2;\n        sum += mymap[{x1, x2}];\n    }\n    cout << sum << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(a) begin(a), end(a)\n#define csz(a) (int) a.size()\n#define pb push_back\n#define epb emplace_back\n#define mp make_pair\n#define load(a, v) fill(begin(a), end(a), v)\n#define load_mem(a, v) memset(a, v, sizeof(a));\n#define iostream_optimize() ios::sync_with_stdio(false); cin.tie(0);\n#define long long long\nconst long MOD = 1e9+7, LINF = 1e18 + 1e16;\nconst int INF = 1e9+1;\nconst double EPS = 1e-10;\nconst int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<< END TEMPLATE >>>>>>>>>>>>>>>>>>>>>>>>>>> */\nconst int N = 2.5e5+1;\nlong P1, P2;\nseed_seq seq{\n\t(uint64_t) chrono::duration_cast<chrono::nanoseconds>(chrono::high_resolution_clock::now().time_since_epoch()).count(),\n  (uint64_t) __builtin_ia32_rdtsc(),\n  (uint64_t) (uintptr_t) make_unique<char>().get()\n};\n\nlong modPow(long b, long e) {\n\tif(!e) return 1;\n\tif(e == 1) return b;\n\treturn modPow(b*b % MOD, e >> 1) * modPow(b, e & 1) % MOD;\n}\n\nint n;\nchar s[N];\nlong ans, shift[N], h1[N], h2[N];\nmap<pair<long,long>, int> cnt;\n\nvoid gen_base() {\n\tmt19937 rng(seq);\n\tP1 = uniform_int_distribution<int>(n+1, MOD-1)(rng);\n\tP2 = uniform_int_distribution<int>(n+1, MOD-1)(rng);\n}\n\nint main() {\n\tiostream_optimize();\n\tcin >> n >> (s+1);\n\tgen_base();\n\tshift[0] = n;\n\tfor(int i = 1; i <= n; i++) {\n\t\tshift[i] = shift[i-1];\n\t\th1[i] = h1[i-1];\n\t\th2[i] = h2[i-1];\n\t\tif(s[i] == '>') --shift[i];\n\t\tif(s[i] == '<') ++shift[i];\n\t\tif(s[i] == '+') {\n\t\t\th1[i] = (h1[i] + modPow(P1, shift[i])) % MOD;\n\t\t\th2[i] = (h2[i] + modPow(P2, shift[i])) % MOD;\n\t\t}\n\t\tif(s[i] == '-') {\n\t\t\th1[i] = (h1[i] - modPow(P1, shift[i]) + MOD) % MOD;\n\t\t\th2[i] = (h2[i] - modPow(P2, shift[i]) + MOD) % MOD;\n\t\t}\n\t}\n\t++cnt[make_pair(h1[n], h2[n])];\n\tfor(int i = 1; i <= n; i++) {\n\t\tans += cnt[make_pair(h1[i], h2[i])];\n\t\tlong coeff1 = (n > shift[i] ? modPow(modPow(P1, n - shift[i]), MOD-2) : modPow(P1, shift[i] - n));\n\t\tlong coeff2 = (n > shift[i] ? modPow(modPow(P2, n - shift[i]), MOD-2) : modPow(P2, shift[i] - n));\n\t\t// cout << shift[i] << ' ' << h[i] << ' ' << (h[n] * coeff + h[i]) % MOD <<  ' ' << cnt[h[i]] << endl;\n\t\tpair<long,long> add = {(h1[n] * coeff1 + h1[i]) % MOD, (h2[n] * coeff2 + h2[i]) % MOD};\n\t\t++cnt[add];\n\t}\n\tcout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "//teja349\n#include <bits/stdc++.h>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <utility>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <iomanip> \n//setbase - cout << setbase (16); cout << 100 << endl; Prints 64\n//setfill -   cout << setfill ('x') << setw (5); cout << 77 << endl; prints xxx77\n//setprecision - cout << setprecision (14) << f << endl; Prints x.xxxx\n//cout.precision(x)  cout<<fixed<<val;  // prints x digits after decimal in val\n\nusing namespace std;\n#define f(i,a,b) for(i=a;i<b;i++)\n#define rep(i,n) f(i,0,n)\n#define fd(i,a,b) for(i=a;i>=b;i--)\n#define pb push_back\n#define mp make_pair\n#define vi vector< int >\n#define vl vector< ll >\n#define ss second\n#define ff first\n#define ll long long\n#define pii pair< int,int >\n#define pll pair< ll,ll >\n#define sz(a) a.size()\n#define inf (1000*1000*1000+5)\n#define all(a) a.begin(),a.end()\n#define tri pair<int,pii>\n#define vii vector<pii>\n#define vll vector<pll>\n#define viii vector<tri>\n#define mod (998244353)\n#define pqueue priority_queue< int >\n#define pdqueue priority_queue< int,vi ,greater< int > >\n\n//std::ios::sync_with_stdio(false);   \nll ans10[512345],ans13[512345],powe13[512345],powe10[512345],invpowe10[512345];\nll invpowe13[512345],inv[1234],p[512345];\nll extend_gcd(ll a,ll b,ll &x,ll &y){\n\tif(b==0){\n\t\tx=1;\n\t\ty=0;\n\t\treturn a;\n\t}\n\tll x1,y1;\n\tll ans =extend_gcd(b,a%b,x1,y1);\n\tx=y1;\n\ty=x1-(a/b)*y1;\n\n\treturn ans;\n}\nmap<ll,ll> seti10,seti13; \nint main(){\n    std::ios::sync_with_stdio(false);\n    ll n;\n    cin>>n;\n    string s;\n    cin>>s;\n    ll i;\n    ll initp=250003;\n    powe10[0]=1;\n    powe13[0]=1;\n    invpowe10[0]=1;\n    invpowe13[0]=1;\n    f(i,1,100){\n\t\tll x,y;\n\t\tll val=extend_gcd(mod,i,x,y);\n\t\tif(y>0)\n\t\t\tinv[i]=y%mod;\n\t\telse{\n\t\t\t\tinv[i]=(y+mod)%mod;\n\t\t}\n\t}\n\tll inv10=inv[19];\n\tll inv13=inv[37];\n    f(i,1,512345){\n    \tpowe13[i]=powe13[i-1]*37;\n    \tpowe10[i]=powe10[i-1]*19;\n    \tpowe10[i]%=mod;\n    \tpowe13[i]%=mod;\n    \tinvpowe10[i]=invpowe10[i-1]*inv10;\n    \tinvpowe10[i]%=mod;\n    \tinvpowe13[i]=invpowe13[i-1]*inv13;\n    \tinvpowe13[i]%=mod;\n    }\n    ans10[0]=0;\n    ans13[0]=0;\n    p[0]=initp;\n    \n    f(i,1,s.length()+1){\n    \tans10[i]=ans10[i-1];\n    \tans13[i]=ans13[i-1];\n    \tp[i]=p[i-1];\n    \tif(s[i-1]=='+'){\n    \t\tans10[i]=ans10[i-1]+powe10[p[i]];\n    \t\tans13[i]=ans13[i-1]+powe13[p[i]];\n\n    \t}\n    \telse if(s[i-1]=='-'){\n    \t\tans10[i]=ans10[i-1]-powe10[p[i]];\n    \t\tans13[i]=ans13[i-1]-powe13[p[i]];\n    \t}\n    \telse if(s[i-1]=='<'){\n    \t\tp[i]--;\n    \t}\n    \telse{\n    \t\tp[i]++;\n    \t}\n    \tans10[i]%=mod;\n    \tans10[i]+=mod;\n    \tans10[i]%=mod;\n    \tans13[i]%=mod;\n    \tans13[i]+=mod;\n    \tans13[i]%=mod;\n    \tseti13[ans13[i]]++;\n    \tseti10[ans10[i]]++;\n    \t//cout<<ans10[i]<<\" \"<<ans13[i]<<endl;\n    }\n    ll val,val1,j10,j13;\n    ll total=0;\n    f(i,1,n+1){\n    \tval=initp-p[i-1];\n    \tval*=-1;\n    \tif(val>=0){\n    \t\tval1=powe13[val];\n    \t\tval=powe10[val];\n    \t\t  \n    \t}\n    \telse{\n    \t\tval1=invpowe13[val];\n    \t\tval=invpowe10[val];\n    \t}\n    \tj10=ans10[n]*val;\n    \tj10%=mod;\n    \tj10+=ans10[i-1];\n    \tj13=ans13[n]*val1;\n    \tj13%=mod;\n    \tj13+=ans13[i-1];\n    \tj10%=mod;\n    \tj13%=mod;\n    \ttotal+=min(seti10[j10],seti13[j13]);\n        assert(seti10[j10]==seti13[j13]);\n    \tseti13[ans13[i]]--;\n    \tseti10[ans10[i]]--;\n    }\n    cout<<total<<endl;\n\n\n\n\n    return 0;  \n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<map>\n#define x first\n#define y second\n\ntypedef long long ll;\ntypedef std::pair<int,int> pii;\n\nconst int N=250010,MOD=1000000007,g0=500002,g1=500003;\n\npii operator * (pii A,pii B){return pii((ll)A.x*B.x%MOD,(ll)A.y*B.y%MOD);}\npii operator + (pii A,pii B){return pii(((A.x+B.x)%MOD+MOD)%MOD,((A.y+B.y)%MOD+MOD)%MOD);}\npii operator - (pii B){return pii(-B.x,-B.y);}\n\nll inv(int x){return (x==1 || x==-1)?x:(-(MOD/x)*inv(MOD%x)%MOD);}\n\npii t0[N*2],*pow;\n\nvoid initialize()\n{\n\tpow=t0+N;\n\n\tpii tmp=pii(g0,g1);\n\n\tpow[0]=pii(1,1);\n\tfor(int i=1;i<N;i++)\n\t\tpow[i]=pow[i-1]*tmp;\n\n\ttmp=pii((inv(g0)+MOD)%MOD,(inv(g1)+MOD)%MOD);\n\tfor(int i=0;i<N;i++)\n\t\tpow[-i-1]=pow[-i]*tmp;\n}\n\nchar s[N];\nint ind[N];\npii val[N],sum[N];\nint n;\n\nll ans;\n\nvoid prework()\n{\n\tint p=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tind[i]=p,val[i]=pii(0,0);\n\n\t\tif(s[i]=='<')p--;\n\t\telse if(s[i]=='>')p++;\n\t\telse if(s[i]=='+')val[i]=pow[p];\n\t\telse val[i]=-pow[p];\n\t}\n\n\tfor(int i=1;i<=n;i++)\n\t\tsum[i]=sum[i-1]+val[i];\n}\n\nstd::map<pii,int> G;\n\nvoid solve()\n{\n\tans=0;\n\n\tpii x,y;\n\n\tfor(int i=n;i;i--)\n\t{\n\t\tG[sum[i]]++;\n\n\t\tx=sum[n]*pow[ind[i]];\n\t\ty=sum[i-1]+x;\n\n\t\tans+=G[y];\n\t}\n}\n\nint main()\n{\n\tinitialize();\n\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",s+1);\n\n\tprework();\n\tsolve();\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define llu unsigned long long\n#define ld double\n#define llu unsigned long long\n#define rep(i,x,y)  for(ll i=x;i<y;++i)\n#define For(i,x,y)  for(ll i=x;i<=y;++i)\n#define FOr(i,x,y)  for(ll i=x;i>=y;--i)\n#define pi acos(-1)\n#define mk make_pair<ll,ll>\n#define pa pair<ll,ll>\n#define lf else if\n#define min(x,y)    ((x)<(y)?(x):(y))\n#define sqr(x)      ((x)*(x))\n#define abs(x)      ((x)>0?(x):-(x))\n#define Mul(x,y)    (x=(x)*(y)%mod)\n#define Add(x,y)    (x=(x+(y))%mod)\n#define E(x)        return writeln(x),0\n#define p(x)        printf(\"~%d~\\n\",x)\n#define pp(x,y)     printf(\"~~%d %d~~\\n\",x,y)\n#define ppp(x,y,z)  printf(\"~~~%d %d %d~~~\\n\",x,y,z)\n#define pppp(x,y,z,a)  printf(\"~~~%d %d %d %d~~~\\n\",x,y,z,a)\n#define f_in(x)     freopen(x\".in\",\"r\",stdin)\n#define f_out(x)    freopen(x\".out\",\"w\",stdout)\n#define open(x)     f_in(x),f_out(x)\n#define fi first\n#define se second\ntypedef complex<double> E;\nnamespace SHENZHEBEI{\n#ifdef LOCAL\n    struct _{_(){freopen(\"cf.in\",\"r\",stdin);}}_;\n#endif\n#define NEG 1\n    inline char gc(){   return getchar();   }\n#if NEG\n    inline ll read(){    ll x=0,f=1; char ch=gc();   for (;!isdigit(ch);ch=gc()) if (ch=='-') f=-1;  for (;isdigit(ch);ch=gc())  x=x*10-48+ch;   return x*f; }\n    inline void write(ll x){    if (x<0) putchar('-'),x=-x;  if (x>=10)   write(x/10);    putchar(x%10+'0');  }\n#else\n    inline ll read(){    ll x=0; char ch=gc();   for (;!isdigit(ch);ch=gc());    for (;isdigit(ch);ch=gc())  x=x*10-48+ch;   return x;   }\n    inline void write(ll x){    if (x>=10)   write(x/10);    putchar(x%10+'0');  }\n#endif\n    inline char readchar(){ char ch=gc();   for(;isspace(ch);ch=gc());  return ch;  }\n    inline ll readstr(char *s){ char ch=gc();   int cur=0;  for(;isspace(ch);ch=gc());      for(;!isspace(ch);ch=gc())  s[cur++]=ch;    s[cur]='\\0';    return cur; }\n    inline void writeln(ll x){  write(x);   puts(\"\");   }\n    inline ld getreal(){    static ld lbc;  scanf(\"%lf\",&lbc);  return lbc; }\n}using namespace SHENZHEBEI;\nconst ll N=1200000,mod=1e9+7,bas=233333;\nmap<ll,ll>mp;\nchar s[N];\nll sum[N],bin[N],Inv[N],now[N],Pos[N],n,Inv_bas,answ,start;\nll ppow(ll x,ll k){\n\tll ans=1;\n\tfor(;k;k>>=1,Mul(x,x))if (k&1)Mul(ans,x);\n\treturn ans;\n}\nll Query(ll l,ll r){\n\tmemset(sum,0,sizeof sum);\n\tll pos=2*n,zt=0;\n\tFor(i,l,r){\n\t\tif (s[i]=='+')++sum[pos];\n\t\tlf (s[i]=='-')--sum[pos];\n\t\tlf (s[i]=='>')\t++pos;\n\t\telse\t\t\t--pos;\n\t}\n\tFor(i,1,3*n)Add(zt,sum[i]*bin[i])%mod;\n\tAdd(zt,mod);\n\treturn zt;\n}\nvoid cdq(ll l,ll r){\n\tif (l>r)return ;\n\tif (l==r){\n\t\tif (s[l]=='+')answ+=bin[2*n]==start;\n\t\tlf (s[l]=='-')answ+=(mod-bin[2*n])%mod==start;\n\t\treturn ;\n\t}\n\tmp.clear();\n\tll mid=(l+r)>>1,ans=0,pos=2*n;\n\tFOr(i,mid,l){\n\t\tif (s[i]=='+')ans+=bin[pos];\n\t\tlf (s[i]=='-')ans-=bin[pos];\n\t\tlf (s[i]=='>')\t--pos;\n\t\telse\t\t\t++pos;\n\t\tif (pos<2*n)now[i]=ans*bin[2*n-pos]%mod,Pos[i]=Inv[2*n-pos];\n\t\telse\t\tnow[i]=ans*Inv[pos-2*n]%mod,Pos[i]=bin[pos-2*n];\n\t}\n\tpos=2*n;++mp[0];ans=0;\n\tFor(i,mid+1,r){\n\t\tif (s[i]=='+')ans+=bin[pos];\n\t\tlf (s[i]=='-')ans-=bin[pos];\n\t\tlf (s[i]=='>')\t++pos;\n\t\telse\t\t\t--pos;\n\t\tAdd(ans,mod);\n\t\tif (pos<2*n)++mp[ans];\n\t\telse\t\t++mp[ans];\n\t}\n//\twriteln(Query(1,3)*);\n\tFor(i,l,mid){\n\t\tansw+=mp[((start-now[i])*Pos[i]%mod+mod)%mod];\n\t}\n\tcdq(l,mid-1);\tcdq(mid+1,r);\n}\nint main(){\n\tn=read();readstr(s+1);Inv_bas=ppow(bas,mod-2);\n\tbin[0]=1;For(i,1,4*n)bin[i]=bin[i-1]*bas%mod;\n\tInv[0]=1;For(i,1,4*n)Inv[i]=Inv[i-1]*Inv_bas%mod;\n\tstart=Query(1,n);\n\tcdq(1,n);\n\twriteln(answ);\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN=250000;\nconst int HMOD=1000000007;\nconst int NHASH=1;\nint HMLT[NHASH];\nint HINV[NHASH];\nstruct Op { int a[NHASH],b[NHASH]; };\nint pw(int x,int n) { int ret=1; while(true) { if(n&1) ret=(ll)ret*x%HMOD; if((n>>=1)==0) return ret; x=(ll)x*x%HMOD; } }\n\nOp combine(const Op &p,const Op &q) { Op ret; REP(i,NHASH) { ret.a[i]=(ll)p.a[i]*q.a[i]%HMOD; ret.b[i]=((ll)p.a[i]*q.b[i]+p.b[i])%HMOD; } return ret; }\nvoid eval(const Op &p,const int q[NHASH],int ret[NHASH]) { REP(i,NHASH) ret[i]=((ll)p.a[i]*q[i]+p.b[i])%HMOD; }\n\nint n; char s[MAXN+1];\n\nOp opid;\nOp opgt,iopgt;\nOp oplt,ioplt;\nOp oppl,ioppl;\nOp opmn,iopmn;\nOp f[MAXN];\nOp g[MAXN];\n\nOp ff[MAXN+1]; // ff[i] is composition of f for suffix starting at i\nOp gg[MAXN+1]; // gg[i] is composition of g for suffix starting at i\n\nint id[NHASH];\nint fx[NHASH];\nint gx[MAXN+1][NHASH];\nint hx[MAXN+1][NHASH];\n\nmap<vector<int>,int> mp;\n\nvoid run() {\n\tscanf(\"%d%s\",&n,s);\n\n\tREP(i,n) switch(s[i]) {\n\t\tcase '>': f[i]=opgt,g[i]=iopgt; break;\n\t\tcase '<': f[i]=oplt,g[i]=ioplt; break;\n\t\tcase '+': f[i]=oppl,g[i]=ioppl; break;\n\t\tcase '-': f[i]=opmn,g[i]=iopmn; break;\n\t\tdefault: assert(false);\n\t}\n\n\tff[n]=opid; for(int i=n-1;i>=0;--i) ff[i]=combine(f[i],ff[i+1]);\n\tgg[n]=opid; for(int i=n-1;i>=0;--i) gg[i]=combine(gg[i+1],g[i]);\n\t\n\tmemset(id,0,sizeof(id));\n\teval(ff[0],id,fx);\n\tREPE(i,n) eval(gg[i],id,gx[i]);\n\tREPE(i,n) eval(gg[i],fx,hx[i]);\n\n\t//printf(\"fx:\"); printf(\" %d\\n\",fx[0]);\n\t//printf(\"gx:\"); REPE(i,n) printf(\" %10d\",gx[i][0]); puts(\"\");\n\t//printf(\"hx:\"); REPE(i,n) printf(\" %10d\",hx[i][0]); puts(\"\");\n\n\tll ret=0;\n\tfor(int i=n;i>=0;--i) {\n\t\tvector<int> vg(NHASH),vh(NHASH); REP(j,NHASH) vg[j]=gx[i][j],vh[j]=hx[i][j];\n\t\tret+=mp[vh]; ++mp[vg];\n\t}\n\tprintf(\"%lld\\n\",ret);\n}\n\nvoid init() {\n\tREP(i,NHASH) { int x=0; REP(j,100) x=((ll)x*1000+rand()%1000)%HMOD; HMLT[i]=x; HINV[i]=pw(x,HMOD-2); }\n\t//printf(\"HMLT:\"); REP(i,NHASH) printf(\" %d\",HMLT[i]); puts(\"\");\n\tREP(i,NHASH) {\n\t\topid.a[i]=1,opid.b[i]=0;\n\t\topgt.a[i]=HMLT[i],opgt.b[i]=0;\n\t\toplt.a[i]=HINV[i],oplt.b[i]=0;\n\t\toppl.a[i]=1,oppl.b[i]=1;\n\t\topmn.a[i]=1,opmn.b[i]=HMOD-1;\n\t\tiopgt=oplt,ioplt=opgt,ioppl=opmn,iopmn=oppl;\n\t}\n}\n\nint main() {\n\tinit();\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define int long long\n#define ull unsigned long long\n\nconst int Maxv = 500010; \nconst ull Prime1 = 239; \nconst ull Prime2 = 223372036854775763; \n                            \nint val[Maxv], idx[Maxv], ans, n; \null Hash[Maxv]; \nchar s[Maxv]; \n\nstd::unordered_map<ull, int> Map; \n\ninline void PreHandle() {\n    val[n] = 1; \n    for (int i = n + 1; i <= (n << 1); i++)\n        val[i] = val[i - 1] * Prime1; \n    for (int i = n - 1; i >= 0; i--)\n        val[i] = val[i + 1] * Prime2; \n}\n\nsigned main() {\n    scanf(\"%d\", &n); \n    scanf(\"%s\", s); \n\n    PreHandle(); \n\n    for (int i = 0; i < n; i++) {\n        Hash[i + 1] = Hash[i]; \n        idx[i + 1] = idx[i]; \n\n        if (s[i] == '>')\n            idx[i + 1]++; \n        if (s[i] == '<')\n            idx[i + 1]--;\n        if (s[i] == '+')\n            Hash[i + 1] += val[n + idx[i + 1]]; \n        if (s[i] == '-')\n            Hash[i + 1] -= val[n + idx[i + 1]]; \n    }\n    \n    for (int i = n; i >= 0; i--) {\n        ull tmp = Hash[i] + Hash[n] * val[n + idx[i]];\n        ans += Map[tmp]; \n        Map[ Hash[i] ]++;\n    }\n\n    printf(\"%lld\\n\", ans);\n\n    return 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) std::cerr << #x << \" = \" << (x) << std::endl\nusing ll = long long;\nstd::mt19937 mt{std::random_device{}()};\ntemplate <typename T>\nconstexpr std::pair<T, T> extgcd(const T a, const T b)\n{\n    if (b == 0) { return std::pair<T, T>{1, 0}; }\n    const auto p = extgcd(b, a % b);\n    return {p.second, p.first - p.second * (a / b)};\n}\ntemplate <typename T>\nconstexpr T inverse(const T a, const T mod) { return (mod + extgcd(a, mod).first % mod) % mod; }\nconstexpr int H = 10;  //関数値サンプルの個数\nconstexpr ll MOD1 = 1000000007LL, MOD2 = 1000000009LL;\nconstexpr ll X[H] = {2371983LL, 1231LL, 123123LL, 4329075LL, 134121LL, 231788LL, 12234LL, 9218739LL, 912380LL, 556LL};\nconstexpr ll XINV1[H] = {inverse(X[0], MOD1), inverse(X[1], MOD1), inverse(X[2], MOD1), inverse(X[3], MOD1), inverse(X[4], MOD1), inverse(X[5], MOD1), inverse(X[6], MOD1), inverse(X[7], MOD1), inverse(X[8], MOD1), inverse(X[9], MOD1)};\nconstexpr ll XINV2[H] = {inverse(X[0], MOD2), inverse(X[1], MOD2), inverse(X[2], MOD2), inverse(X[3], MOD2), inverse(X[4], MOD2), inverse(X[5], MOD2), inverse(X[6], MOD2), inverse(X[7], MOD2), inverse(X[8], MOD2), inverse(X[9], MOD2)};\ntemplate <typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, const std::pair<S, T>& p) { return (os << \"<\" << p.first << \",\" << p.second << \">\"); }\ntemplate <typename T, typename A>\nstd::ostream& operator<<(std::ostream& os, const std::vector<T, A>& v)\n{\n    os << \"[\";\n    for (const auto& p : v) { os << p << \",\"; }\n    return (os << \"]\\n\");\n}\nint main()\n{\n    int N;\n    std::string S;\n    std::cin >> N >> S;\n    using P = std::pair<ll, ll>;\n    std::vector<int> deg(N + 1, 0);\n    std::vector<std::vector<P>> value(N + 1, std::vector<P>(H, {0LL, 0LL}));\n    auto plus = [](const P& p1, const P& p2) { return P{(p1.first + p2.first) % MOD1, (p1.second + p2.second) % MOD2}; };\n    auto minus = [](const P& p1, const P& p2) { return P{(p1.first + MOD1 - p2.first) % MOD1, (p1.second + MOD2 - p2.second) % MOD2}; };\n    auto rshift = [](const P& p, const int i) { return P{p.first * X[i] % MOD1, p.second * X[i] % MOD2}; };\n    auto lshift = [](const P& p, const int i) { return P{p.first * XINV1[i] % MOD1, p.second * XINV2[i] % MOD2}; };\n    auto mul = [](const P& p1, const P& p2) { return P{p1.first * p2.first % MOD1, p1.second * p2.second % MOD2}; };\n    for (int i = N - 1; i >= 0; i--) {\n        if (S[i] == '-') {\n            deg[i] = deg[i + 1];\n            for (int j = 0; j < H; j++) { value[i][j] = minus(value[i + 1][j], {1, 1}); }\n        } else if (S[i] == '+') {\n            deg[i] = deg[i + 1];\n            for (int j = 0; j < H; j++) { value[i][j] = plus(value[i + 1][j], {1, 1}); }\n        } else if (S[i] == '>') {\n            deg[i] = deg[i + 1] + 1;\n            for (int j = 0; j < H; j++) { value[i][j] = rshift(value[i + 1][j], j); }\n        } else {\n            deg[i] = deg[i + 1] - 1;\n            for (int j = 0; j < H; j++) { value[i][j] = lshift(value[i + 1][j], j); }\n        }\n    }\n    // show(deg);\n    // show(value);\n    constexpr int L = 250000;\n    std::vector<std::vector<P>> power(L + 1, std::vector<P>(H, {1, 1}));\n    std::vector<std::vector<P>> invpower(L + 1, std::vector<P>(H, {1, 1}));\n    auto invp = [&](const int i, const int j) { return i >= 0 ? invpower[i][j] : power[-i][j]; };\n    for (int i = 1; i <= L; i++) {\n        for (int j = 0; j < H; j++) { power[i][j] = rshift(power[i - 1][j], j), invpower[i][j] = lshift(power[i - 1][j], j); }\n    }\n    std::vector<P> answer(H);\n    for (int i = 0; i < H; i++) { answer[i] = value[0][i]; }\n    //show(answer);\n    std::vector<std::vector<P>> hash(N + 1, std::vector<P>(H));\n    for (int i = 0; i <= N; i++) {\n        for (int j = 0; j < H; j++) { hash[i][j] = mul(minus(value[i][j], answer[j]), invp(deg[i], j)); }\n    }\n    //    show(hash);\n    using VP = std::vector<P>;\n    std::map<VP, ll> mp;\n    ll ans = 0;\n    for (int i = 0; i < N; i++) {\n        std::vector<P> obj(H);\n        for (int j = 0; j < H; j++) { obj[j] = plus(hash[i][j], mul(invp(deg[i], j), answer[j])); }\n        if (mp.find(obj) != mp.end()) { ans += mp[obj]; }\n        mp[hash[i]]++;\n    }\n    std::cout << ans << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nnamespace mine\n{\n    typedef long long ll;\n    #define pr pair<int,int>\n    #define FR first\n    #define SE second\n    #define MP make_pair\n    #define PB push_back\n    #define vc vector\n    #define all(x) (x).begin(),(x).end()\n    #define sz(x) ((int)(x).size())\n    #define bin(x) (1ll<<(x))\n    #define GG(x) if(x) {puts(\"error\");exit(666);}\n    #define fo(i,l,r) for(int i=(l),I=(r);i<=I;i++)\n    #define fd(i,r,l) for(int i=(r),I=(l);i>=I;i--)\n    ll qread()\n    {\n        ll ans=0,f=1;char c=getchar();\n        while(c<'0' or c>'9') {if(c=='-')f=-1;c=getchar();}\n        while('0'<=c and c<='9') ans=ans*10+c-'0',c=getchar();\n        return ans*f;\n    }\n    void write(ll num)\n    {\n        if(num<0) putchar('-'),num=-num;\n        if(num>=10) write(num/10);\n        putchar('0'+num%10);\n    }\n    void write1(ll num){write(num);putchar(' ');}\n    void write2(ll num){write(num);putchar('\\n');}\n    template<typename T> void chmax(T &x,const T y) {x=(x>y?x:y);}\n    template<typename T> void chmin(T &x,const T y) {x=(x<y?x:y);}\n    ll gcd(ll x,ll y){return y?gcd(y,x%y):x;}\n\n    const int INF=0x3f3f3f3f;\n    const int MOD=998244353;\n    inline int mm(const int x){return x>=MOD?x-MOD:x;}\n    template<typename T> inline void add(T &x,const T y){x=mm(x+y);}\n    inline ll qpower(ll x,ll e,int mod=MOD){ll ans=1;GG(e<0);while(e){if(e&1)ans=ans*x%mod;x=x*x%mod;e>>=1;}return ans;}\n    ll invm(ll x){return qpower(x,MOD-2);}\n    const int N=1e6+10;\n\n    const int base[5]={131,13331,131,13331,2333};\n    const int mod[5]={998244353,998244353,1000000007,993244853,1000000009};\n    struct Data\n    {\n        ll state[5],bs[5];\n        Data(){fo(i,0,4)state[i]=0,bs[i]=1;}\n        friend bool operator < (Data x,Data y)\n        {\n            fo(i,0,4) if(x.state[i]!=y.state[i]) return x.state[i]<y.state[i];\n            return 0;\n        }\n        void insert(char c)\n        {\n            if(c=='+' or c=='-')\n            {\n                fo(i,0,4) (state[i]+=bs[i]*(c=='+'?1:mod[i]-1) )%=mod[i];\n            } else\n            {\n                fo(i,0,4) (bs[i]*=(c=='>'?base[i]:qpower(base[i],mod[i]-2,mod[i])) )%=mod[i];\n            }\n        }\n        void output()\n        {\n            fo(i,0,4) printf(\"(%lld,%lld) \",state[i],bs[i]);\n            puts(\"\");\n        }\n    };\n    Data merg(Data left,Data right)\n    {\n        fo(i,0,4) (left.state[i]+=left.bs[i]*right.state[i])%=mod[i],(left.bs[i]*=right.bs[i])%=MOD;\n        return left;\n    }\n    map<Data,int> mp;\n\n    char str[N];\n    void main()\n    {\n        int n=qread();scanf(\"%s\",str+1);\n        Data all;fo(i,1,n) all.insert(str[i]);mp[all]++;all.output();\n        ll ans=0;Data now;\n        fo(r,1,n)\n        {\n            now.insert(str[r]);\n            // now.output();\n            ans+=mp[now];\n            mp[merg(now,all)]++;\n            // merg(now,all).output();\n            // puts(\"\");\n        }write(ans);\n    }\n};//(ans+MOD)%MOD\nsigned main()\n{\n    srand(time(0));\n    mine::main();\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n    _____\n  .'     '.\n /  0   0  \\\n|     ^     |\n|  \\     /  |\n \\  '---'  /\n  '._____.'\n*/\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\nstruct chash\n{\n\tint operator()(int x) const\n\t{\n\t\tx ^= (x >> 20) ^ (x >> 12);\n\t\treturn x ^ (x >> 7) ^ (x >> 4);\n\t}\n};\n\ntemplate<typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename U> using hashtable = gp_hash_table<T, U, chash>;\nrandom_device(rd);\nmt19937 rng(rd());\n\ntemplate<class T>\nvoid readi(T &x)\n{\n\tT input = 0;\n\tbool negative = false;\n\tchar c = ' ';\n\twhile (c < '-')\n\t{\n\t\tc = getchar();\n\t}\n\tif (c == '-')\n\t{\n\t\tnegative = true;\n\t\tc = getchar();\n\t}\n\twhile (c >= '0')\n\t{\n\t\tinput = input * 10 + (c - '0');\n\t\tc = getchar();\n\t}\n\tif (negative)\n\t{\n\t\tinput = -input;\n\t}\n\tx = input;\n}\ntemplate<class T>\nvoid printi(T output)\n{\n\tif (output == 0)\n\t{\n\t\tputchar('0');\n\t\treturn;\n\t}\n\tif (output < 0)\n\t{\n\t\tputchar('-');\n\t\toutput = -output;\n\t}\n\tint aout[20];\n\tint ilen = 0;\n\twhile(output)\n\t{\n\t\taout[ilen] = ((output % 10));\n\t\toutput /= 10;\n\t\tilen++;\n\t}\n\tfor (int i = ilen - 1; i >= 0; i--)\n\t{\n\t\tputchar(aout[i] + '0');\n\t}\n\treturn;\n}\ntemplate<class T>\nvoid ckmin(T &a, T b)\n{\n\ta = min(a, b);\n}\ntemplate<class T>\nvoid ckmax(T &a, T b)\n{\n\ta = max(a, b);\n}\ntemplate<class T, class U>\nT nmod(T &x, U mod)\n{\n\tif (x >= mod) x -= mod;\n}\ntemplate<class T>\nT randomize(T mod)\n{\n\treturn (uniform_int_distribution<T>(0, mod - 1))(rng);\n}\n\n#define y0 ___y0\n#define y1 ___y1\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fi first\n#define se second\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\nconst long double PI = 4.0 * atan(1.0);\nconst long double EPS = 1e-10;\n\n#define MAGIC 347\n#define SINF 10007\n#define CO 1000007\n#define INV 124982126\n#define INF 1000000007\n#define BIG 1000000931\n#define LARGE 1696969696967ll\n#define GIANT 2564008813937411ll\n#define LLINF 2696969696969696969ll\n#define MAXN 500013\n\ntypedef __int128_t ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ld, ld> pdd;\n\nint N;\nint arr[MAXN];\nll S;\nlong long ans;\nunordered_map<long long, int> freq, need;\n\nll expo(ll a, ll e)\n{\n\tif (e == 0)\n\t{\n\t\treturn 1;\n\t}\n\tll was = expo(a, e / 2);\n\tif (e % 2)\n\t{\n\t\treturn was * was % INF * a % INF;\n\t}\n\treturn was * was % INF;\n}\nll modinv(ll a)\n{\n\treturn expo(a, INF - 2);\n}\nvoid solve(int L, int R)\n{\n\tif (L == R)\n\t{\n\t\treturn;\n\t}\n\tfreq.clear(); need.clear();\n\tint mid = (L + R) >> 1;\n\t//start from L...mid, end at mid + 1....R\n\tpll trans = MP(1, 0);\n\tfor (int i = mid + 1; i <= R; i++)\n\t{\n\t\tif (arr[i] == 0)\n\t\t{\n\t\t\ttrans.fi *= INV;\n\t\t\ttrans.se *= INV;\n\t\t}\n\t\tif (arr[i] == 1)\n\t\t{\n\t\t\ttrans.fi *= CO;\n\t\t\ttrans.se *= CO;\n\t\t}\n\t\tif (arr[i] == 2)\n\t\t{\n\t\t\ttrans.se++;\n\t\t}\n\t\tif (arr[i] == 3)\n\t\t{\n\t\t\ttrans.se--; trans.se += INF;\n\t\t}\n\t\ttrans.fi %= INF;\n\t\ttrans.se %= INF;\n\t\t// cerr << \"from \" << mid + 1 << \" to \" << i << \" is \" << trans.fi << \"x + \" << trans.se << endl;\n\t\tll dif = S - trans.se + INF;\n\t\tnmod(dif, INF);\n\t\tdif *= modinv(trans.fi);\n\t\tdif %= INF;\n\t\tneed[dif % LLINF]++;\n\t}\n\ttrans = MP(1, 0);\n\tfor (int i = mid; i >= L; i--)\n\t{\n\t\tif (arr[i] == 0)\n\t\t{\n\t\t\ttrans.fi *= INV;\n\t\t}\n\t\tif (arr[i] == 1)\n\t\t{\n\t\t\ttrans.fi *= CO;\n\t\t}\n\t\tif (arr[i] == 2)\n\t\t{\n\t\t\t//(x+1)*a+b = a * x + a + b\n\t\t\ttrans.se += trans.fi;\n\t\t}\n\t\tif (arr[i] == 3)\n\t\t{\n\t\t\t//(x - 1)*a + b = a*x - a + b\n\t\t\ttrans.se -= trans.fi;\n\t\t\ttrans.se += INF;\n\t\t}\n\t\ttrans.fi %= INF;\n\t\ttrans.se %= INF;\n\t\tfreq[trans.se % LLINF]++;\n\t}\n\tfor (auto p : need)\n\t{\n\t\tll x = p.fi; int c = p.se;\n\t\tans += 1ll * c * freq[x];\n\t}\n\tsolve(L, mid);\n\tsolve(mid + 1, R);\n}\n\nint32_t main()\n{\n\tios_base::sync_with_stdio(0);\n\t// cout << fixed << setprecision(10);\n\t// cerr << fixed << setprecision(10);\n\t// freopen (\"file.in\", \"r\", stdin);\n\t// freopen (\"file.out\", \"w\", stdout);\n\tcin >> N;\n\tstring temps;\n\tcin >> temps;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (temps[i] == '<')\n\t\t{\n\t\t\tarr[i] = 0;\n\t\t}\n\t\tif (temps[i] == '>')\n\t\t{\n\t\t\tarr[i] = 1;\n\t\t}\n\t\tif (temps[i] == '+')\n\t\t{\n\t\t\tarr[i] = 2;\n\t\t}\n\t\tif (temps[i] == '-')\n\t\t{\n\t\t\tarr[i] = 3;\n\t\t}\n\t}\n\treverse(arr, arr + N);\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (arr[i] == 0)\n\t\t{\n\t\t\tS *= INV; S %= INF;\n\t\t\t// cerr << \"times \" << INV << endl;\n\t\t}\n\t\tif (arr[i] == 1)\n\t\t{\n\t\t\tS *= CO; S %= INF;\n\t\t\t// cerr << \"times \" << CO << endl;\n\t\t}\n\t\tif (arr[i] == 2)\n\t\t{\n\t\t\tS++; nmod(S, INF);\n\t\t\t// cerr << \"add 1\\n\";\n\t\t}\n\t\tif (arr[i] == 3)\n\t\t{\n\t\t\tS--; S += INF; nmod(S, INF);\n\t\t\t// cerr << \"add -1\\n\";\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (arr[i] == 0)\n\t\t{\n\t\t\tif (S == 0) ans++;\n\t\t}\n\t\tif (arr[i] == 1)\n\t\t{\n\t\t\tif (S == 0) ans++;\n\t\t}\n\t\tif (arr[i] == 2)\n\t\t{\n\t\t\tif (S == 1) ans++;\n\t\t}\n\t\tif (arr[i] == 3)\n\t\t{\n\t\t\tif (S == INF - 1) ans++;\n\t\t}\n\t}\n\t// for (int i = 0; i < N; i++)\n\t// {\n\t// \tll val = 0;\n\t// \tfor (int j = i; j < N; j++)\n\t// \t{\n\t// \t\tif (arr[j] == 0)\n\t// \t\t{\n\t// \t\t\tval *= INV; val %= INF;\n\t// \t\t}\n\t// \t\tif (arr[j] == 1)\n\t// \t\t{\n\t// \t\t\tval *= CO; val %= INF;\n\t// \t\t}\n\t// \t\tif (arr[j] == 2)\n\t// \t\t{\n\t// \t\t\tval++; nmod(val, INF);\n\t// \t\t}\n\t// \t\tif (arr[j] == 3)\n\t// \t\t{\n\t// \t\t\tval--; val += INF; nmod(val, INF);\n\t// \t\t}\n\t// \t\tif (val == S)\n\t// \t\t{\n\t// \t\t\tans++;\n\t// \t\t}\n\t// \t}\n\t// }\n\tsolve(0, N - 1);\n\tcout << ans << '\\n';\n\t//when u <, the # divides by co\n\t//when u >, the # mults by co\n\t//when u +, u add the #\n\t//when u -, u subtract the #\n\t// cerr << \"time elapsed = \" << (clock() / (CLOCKS_PER_SEC / 1000)) << \" ms\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cstdio>\n#include <iostream>\n\nusing namespace std ;\n\ntypedef long long LL ;\n\n\n#define mkp make_pair\n#define pll pair<LL, LL>\n\nconst LL B1 = 237ll ;\nconst LL B2 = 637ll ;\nconst int N = 200010 ;\nconst LL P1 = 998244353 ;\nconst LL P2 = 1004535809 ;\n\nint n ;\nLL ans ;\nchar s[N] ;\nLL I1, I2 ;\nLL S[N], T[N] ;\nmap <pll, LL> buc ;\n\nLL expow(LL a, LL b, LL p){\n    LL ret = 1 ;\n    while (b){\n        if (b & 1)\n            (ret *= a) %= p ;\n        (a *= a) %= p ; b >>= 1 ;\n    }\n    return ret ;\n}\nint main(){\n    cin >> n >> (s + 1) ;\n    I1 = expow(B1, P1 - 2, P1) ;\n    I2 = expow(B2, P2 - 2, P2) ;\n    for (int i = n ; i >= 1 ; -- i){\n        if (s[i] == '-'){\n            S[i] = (S[i + 1] - B1 + P1) % P1 ;\n            T[i] = (T[i + 1] - B2 + P2) % P2 ;\n        }\n        if (s[i] == '+'){\n            S[i] = (S[i + 1] + B1) % P1 ;\n            T[i] = (T[i + 1] + B2) % P2 ;\n        }\n        if (s[i] == '<'){\n            S[i] = (S[i + 1] * I1) % P1 ;\n            T[i] = (T[i + 1] * I2) % P2 ;\n        }\n        if (s[i] == '>'){\n            S[i] = (S[i + 1] * B1) % P1 ;\n            T[i] = (T[i + 1] * B2) % P2 ;\n        }\n        //cout << S[i] << \" \" << T[i] << endl ;\n    }\n    LL gs = 1, gt = 1 ;\n    for (int i = n ; i >= 1 ; -- i){\n        LL x, y ;\n        x = expow(gs, P1 - 2, P1) * (-S[i + 1] + P1) % P1 ;\n        y = expow(gt, P2 - 2, P2) * (-T[i + 1] + P2) % P2 ;\n        if (x < 0) x += P1 ; if (y < 0) y += P2 ; ++ buc[mkp(x, y)] ;\n        //cout << x << \" \" << y << endl ;\n        if (s[i] == '<') (gs *= I1) %= P1, (gt *= I2) %= P2 ;\n        if (s[i] == '>') (gs *= B1) %= P1, (gt *= B2) %= P2 ;\n        x = expow(gs, P1 - 2, P1) * (-S[i] + S[1]) % P1 ;\n        y = expow(gt, P2 - 2, P2) * (-T[i] + T[1]) % P2 ;\n        if (x < 0) x += P1 ; if (y < 0) y += P2 ; ans += buc[mkp(x, y)] ;\n    }\n    cout << ans << endl ; return 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n  \n#define ll long long\n#define all(aaa) aaa.begin(), aaa.end()\n\nconst int MOD = 1000000033, N = 6e5 + 5;\nconst ll X = 1234567;\n\nll bp(ll a, ll p) {\n    ll r = 1;\n    while (p > 0) {\n        if (p & 1)\n            r = r * a % MOD;\n        a = a * a % MOD;\n        p >>= 1;\n    }\n    return r;\n}\n\nll inv_X = bp(X, MOD - 2);\n\nll a[N], b[N];\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n;\n    string s;\n    cin >> n >> s;\n\n    ll h = 0;\n\n    for (int i = n - 1; i >= 0; i--) {\n        if (s[i] == '>')\n            h = h * X % MOD;\n        else if (s[i] == '<')\n            h = h * inv_X % MOD;\n        else if (s[i] == '+')\n            h = (h + 1) % MOD;\n        else\n            h = (h - 1 + MOD) % MOD;\n    }\n\n    map<ll, int> mp;\n\n    ll ans = 0;\n\n    a[n] = 1;\n\n    for (int i = n - 1; i >= 0; i--) {\n        mp[b[i + 1]]++;\n\n        if (s[i] == '>') {\n            a[i] = a[i + 1] * inv_X % MOD;\n            b[i] = b[i + 1];\n        }\n        else if (s[i] == '<') {\n            a[i] = a[i + 1] * X % MOD;\n            b[i] = b[i + 1];\n        }\n        else if (s[i] == '+') {\n            a[i] = a[i + 1];\n            b[i] = (b[i + 1] - a[i + 1] + MOD) % MOD;\n        }\n        else {\n            a[i] = a[i + 1];\n            b[i] = (b[i + 1] + a[i + 1]) % MOD;\n        }\n\n        // cout << b[i] << \"\\n\";\n\n        ans += mp[(a[i] * h + b[i]) % MOD];\n    }\n\n    assert((a[0] * h + b[0]) % MOD == 0);\n\n    // cout << (a[0] * h + b[0]) % MOD << \"\\n\";\n\n    cout << ans << \"\\n\";\n\n    return 0;   \n}"
  },
  {
    "language": "C++",
    "code": "//ΔARC099F\n#include<iostream>\n#include<cstdio>\n#include<fstream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<bitset>\n#include<cmath>\n#include<cstring>\n#include<cstdlib>\nusing namespace std;\ntypedef long long LL;\ntypedef double DB;\nconst int N = 266666;\nconst int B = N+1;\nconst int MO = 1e9+21;\nint fpow(int x,int y=MO-2){\n\tif(!y)\n\t\treturn 1;\n\tLL z=fpow(x,y>>1);\n\tz=z*z%MO;\n\tif(y&1)\n\t\tz=z*x%MO;\n\treturn z;\n}\nint invB=fpow(B);\nchar ch[N];\nint n,a[N],f[N],g[N];\nmap<int,int> M;\nint main()\n{\n\tint i,x,y;\n\tLL ans=0;\n\tcin>>n;\n\tscanf(\"%s\",ch+1);\n\tfor(i=1;i<=n;i=i+1){\n\t\tif(ch[i]=='-')\n\t\t\ta[i]=0;\n\t\tif(ch[i]=='+')\n\t\t\ta[i]=1;\n\t\tif(ch[i]=='<')\n\t\t\ta[i]=2;\n\t\tif(ch[i]=='>')\n\t\t\ta[i]=3;\n\t}\n\tx=0;\n\tfor(i=n;i;i=i-1){\n\t\tif(a[i]==0)\n\t\t\tx=(x-1+MO)%MO;\n\t\tif(a[i]==1)\n\t\t\tx=(x+1)%MO;\n\t\tif(a[i]==2)\n\t\t\tx=(LL)x*invB%MO;\n\t\tif(a[i]==3)\n\t\t\tx=(LL)x*B%MO;\n\t\tf[i]=x;\n\t}\n\tx=0,y=1;\n\tM[0]++;\n\tfor(i=n;i;i=i-1){\n\t\tif(a[i]==0)\n\t\t\tx=(x+y)%MO;\n\t\tif(a[i]==1)\n\t\t\tx=(x-y+MO)%MO;\n\t\tif(a[i]==2)\n\t\t\ty=(LL)y*B%MO;\n\t\tif(a[i]==3)\n\t\t\ty=(LL)y*invB%MO;\n\t\tg[i]=x;\n\t\tM[x]++;\n\t}\n\tfor(i=1;i<=n;i=i+1){\n\t\tM[g[i]]--;\n\t\tx=(f[1]-f[i]+MO)%MO;\n\t\tx=(LL)x*y%MO;\n\t\tans+=M[x];\n\t\tif(a[i]==2)\n\t\t\ty=(LL)y*invB%MO;\n\t\tif(a[i]==3)\n\t\t\ty=(LL)y*B%MO;\n\t}\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "    #include \"bits/stdc++.h\"\n    using namespace std;\n     \n    #define MAX 500012\n     \n    int n;\n    char buf[MAX];\n     \n     \n    string s;\n     \n     \n    //#define MOD1 1000000007\n    //#define MOD2 1000000009\n     \n    valarray<long long int> MOD1;\n    valarray<long long int> MOD2;\n    vector<valarray<long long int> > p2;\n    vector<valarray<long long int> > vv;\n    vector<int> ps;\n    map<pair<long long int,long long int>, int> mp;\n    long long int ppow(long long int i, long long int j, long long int MOD) {\n    \tlong long int ret = 1;\n    \twhile (j) {\n    \t\tif (j & 1LL)ret *= i;\n    \t\tif (ret >= MOD)ret %= MOD;\n    \t\tj >>= 1LL;\n    \t}\n    \treturn ret;\n    }\n     \n    valarray<long long int> calc(int dif) {\n    \tvalarray<long long int> ret;\n    \tret.resize(2, 0);\n    \tfor (int j = 0; j < 2; j++) {\n    \t\tif (dif < 0) {\n    \t\t\tret[j]=ppow(ppow(MOD1[j], abs(dif),MOD2[j]), MOD2[j] - 2,MOD2[j]);\n    \t\t}\n    \t\telse {\n    \t\t\tret[j] = ppow(MOD1[j], abs(dif), MOD2[j]);\n    \t\t}\n    \t}\n    \treturn ret;\n    }\n     \n    int main() {\n    \tMOD1.resize(2);\n    \tMOD2.resize(2);\n    \tp2.push_back(valarray<long long int>());\n    \tp2.back().resize(2);\n    \tp2.back()[0] = p2.back()[1] = 1;\n    \tMOD2[0] = 1000000007;\n    \tMOD1[0] = 998244353;\n    \tMOD1[1] = 555522277;\n    \tMOD2[1] = 895612782;\n    \tp2[0] %= MOD2;\n    \tfor (int i = 1; i < MAX; i++) {\n    \t\tp2.push_back(p2.back());\n    \t\tp2[i] *= MOD1;\n    \t\tp2[i] %= MOD2;\n    \t}\n    \tcin >> n;\n    \tscanf(\"%s\", buf);\n    \ts = buf;\n    \tint pos = MAX/2;\n    \tvalarray<long long int> hs;\n    \ths.resize(2);\n    \ths[0] = hs[1] = 0;\n    \tvv.push_back(hs);\n    \tps.push_back(pos);\n    \tfor (int i = 0; i < s.size(); i++) {\n    \t\tif (s[i] == '<') {\n    \t\t\tpos--;\n    \t\t}\n    \t\tif (s[i] == '>') {\n    \t\t\tpos++;\n    \t\t}\n    \t\tif (s[i] == '+') {\n    \t\t\ths += p2[pos];\n    \t\t}\n    \t\tif (s[i] == '-') {\n    \t\t\ths -= p2[pos];\n    \t\t\ths += MOD2;\n    \t\t}\n    \t\ths %= MOD2;\n    \t\tvv.push_back(hs);\n    \t\tps.push_back(pos);\n    \t}\n    \tlong long int way = 0;\n    \tfor (int i = vv.size() - 1; i >= 0; i--) {\n    \t\tvalarray<long long int> want = vv[i] + vv.back()*calc(-MAX/2+ps[i]);\n    \t\twant = want%MOD2;\n    \t\tway += mp[make_pair(want[0], want[1])];\n    \t\t//cerr << \"dbg \" << way << endl;\n    \t\tif(want[0]<0LL||want[1]<0LL)exit(1);\n    \t\tmp[make_pair(vv[i][0],vv[i][1])]++;\n    \t}\n    \tprintf(\"%lld\\n\", way);\n    \treturn 0;\n    }"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<climits>\n#include<bitset>\n#include<map>\n#define pii pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define int __int128\n#define mod1 10000000000037\n#define mod2 1000000000000000009\nusing namespace std;\ninline int read(){\n    int f=1,ans=0;char c=getchar();\n    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}\n    while(c>='0'&&c<='9'){ans=ans*10+c-'0';c=getchar();}\n    return f*ans;\n}\nconst int MAXN=5e5+11;\nint N;char str[MAXN];\nint h1[MAXN],s1[MAXN],xx=250001,res,h2[MAXN],s2[MAXN];\nint ksm1(int a,int b){\n    int ans=1;\n    while(b){if(b&1) ans*=a,ans%=mod1;a*=a,a%=mod1;b>>=1;}return ans;\n}\nint pw1(int a,int b){\n    if(b>=0) return ksm1(a,b);\n    int res=ksm1(a,-b);return ksm1(res,mod1-2);\n}\nint ksm2(int a,int b){\n    int ans=1;\n    while(b){if(b&1) ans*=a,ans%=mod2;a*=a,a%=mod2;b>>=1;}return ans;\n}\nint pw2(int a,int b){\n    if(b>=0) return ksm2(a,b);\n    int res=ksm2(a,-b);return ksm2(res,mod1-2);\n}\nmap<pii,int> M;\nvoid ins(int ps){M[mp( (h1[ps]+pw1(xx,s1[ps])*h1[N])%mod1 , (h2[ps]+pw2(xx,s2[ps])*h2[N])%mod2 )]++;return;}\ninline void print(int x){\n    if(x>9) print(x/10);\n    putchar(x%10+'0');\n}\nsigned main(){\n    //freopen(\"1.in\",\"r\",stdin);\n    N=read();scanf(\"%s\",str+1);\n    for(int i=1;i<=N;i++){\n        if(str[i]=='+') h1[i]=h1[i-1]+pw1(xx,s1[i-1]),s1[i]=s1[i-1],h1[i]%=mod1;\n        if(str[i]=='-') h1[i]=h1[i-1]-pw1(xx,s1[i-1])+mod1,s1[i]=s1[i-1],h1[i]%=mod1;\n        if(str[i]=='>') h1[i]=h1[i-1],s1[i]=s1[i-1]+1;\n        if(str[i]=='<') h1[i]=h1[i-1],s1[i]=s1[i-1]-1;\n        if(str[i]=='+') h2[i]=h2[i-1]+pw2(xx,s2[i-1]),s2[i]=s2[i-1],h2[i]%=mod2;\n        if(str[i]=='-') h2[i]=h2[i-1]-pw2(xx,s2[i-1])+mod2,s2[i]=s2[i-1],h2[i]%=mod2;\n        if(str[i]=='>') h2[i]=h2[i-1],s2[i]=s2[i-1]+1;\n        if(str[i]=='<') h2[i]=h2[i-1],s2[i]=s2[i-1]-1;\n    }\n    ins(0);\n    for(int i=1;i<=N;i++){\n        res+=M[mp(h1[i],h2[i])];\n        ins(i);\n    }print(res);printf(\"\\n\");return 0;\n}/*\n  5\n  +>+<-\n  */\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 250001,M = 1e9 + 9,M1 = 1e9 + 7,b = 103,b1 = 11;\nint cs[N],cs1[N],p[N],p1[N],n;\nmap<pair<int,int>,int>mp;\nvoid add(int &a,int b){\n\ta+=b;\n\tif(a >= M)a-=M;\n\tif(a < 0)a+=M;\n}\nvoid add1(int &a,int b){\n\ta+=b;\n\tif(a >= M)a-=M;\n\tif(a < 0)a+=M;\n}\nint power(int base,int to){\n\tint ret = 1;\n\twhile(to){\n\t\tif(to&1)ret = ret*1LL*base%M;\n\t\tto>>=1;\n\t\tbase = base*1LL*base%M;\n\t}\n\treturn ret;\n}\nint main(){\n//\tfreopen(\"readin.txt\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tp[0] = p1[0] = 1;\n\tchar c;\n\tint inv = power(b,M - 2),inv1 = power(b1,M1 - 2);\n\tfor(int i = 1;i <= n;i++){\n\t\tscanf(\" %c\",&c);\n\t\tcs[i] = cs[i - 1];\n\t\tp[i] = p[i - 1];\n\t\tcs1[i] = cs1[i - 1];\n\t\tp1[i] = p1[i - 1];\n\t\tif(c == '+')add(cs[i],p[i]),add1(cs1[i],p1[i]);\n\t\telse if(c == '-')add(cs[i],-p[i]),add1(cs1[i],-p1[i]);\n\t\telse if(c == '>')p[i] = p[i]*1LL*b%M,p1[i] = p1[i]*1LL*b1%M1;\n\t\telse if(c == '<')p[i] = p[i]*1LL*inv%M,p1[i] = p1[i]*1LL*inv1%M1;\n\t}\n\tlong long ans = 0;\n\tfor(int i = 0;i <= n;i++){\n\t\tans+=mp[{cs[i],cs1[i]}];\n\t\tmp[{(cs[n]*1LL*p[i] + cs[i] + M)%M,(cs1[n]*1LL*p1[i] + cs1[i] + M1)%M1}]++;\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 250010;\nconst int mod[] = {1000000007, 1000000009};\nconst int P[] = {131, 233};\n\ntypedef long long LL;\n\nint Pow[2][N * 2]; char s[N];\n\ninline int FUCK(int x, int y, int mod) {\n    int res = 1;\n    for (; y; y >>= 1, x = (LL)x * x % mod) if (y & 1) res = (LL)res * x % mod;\n    return res;\n}\n\nstruct Data {\n    int val[2];\n\n    Data(int a = 0, int b = 0) {val[0] = a, val[1] = b;} \n\n    Data operator + (const Data &b) {\n        Data res;\n        res.val[0] = (val[0] + b.val[0]) % mod[0];\n        res.val[1] = (val[1] + b.val[1]) % mod[1];\n        return res;\n    }\n\n    Data operator - (const Data &b) {\n        Data res;\n        res.val[0] = (val[0] - b.val[0] + mod[0]) % mod[0];\n        res.val[1] = (val[1] - b.val[1] + mod[1]) % mod[1]; \n        return res;\n    }\n\n    Data operator * (const int b) {\n        Data res = *this;\n        int a = b >= 0 ? Pow[0][b] : FUCK(P[0], (LL)(mod[0] - 2) * (-b) % (mod[0] - 1), mod[0]);\n        int c = b >= 0 ? Pow[1][b] : FUCK(P[1], (LL)(mod[1] - 2) * (-b) % (mod[1] - 1), mod[1]);\n        res.val[0] = (LL)res.val[0] * a % mod[0];\n        res.val[1] = (LL)res.val[1] * c % mod[1];\n        return res;\n    }\n\n    bool operator < (const Data &b) const {\n        if (val[0] != b.val[0]) return val[0] < b.val[0];\n        return val[1] < b.val[1];\n    }\n};\n\nmap<Data, int> mp;\n\ninline void increase(Data &a, int b) {\n    a = a + (Data){Pow[0][b], Pow[1][b]};\n}\n\ninline void decrease(Data &a, int b) {\n    a = a - (Data){Pow[0][b], Pow[1][b]};\n}\n\nint main() {\n    int n; scanf(\"%d%s\", &n, s + 1); Data all;\n    Pow[0][0] = Pow[1][0] = 1;\n    for (int i = 0; i <= 1; i++)\n        for (int j = 1; j <= n * 2; j++)\n            Pow[i][j] = (LL)Pow[i][j - 1] * P[i] % mod[i];\n    for (int i = 1, ls = 0; i <= n; i++) {\n        if (s[i] == '<') ls--;\n        else if (s[i] == '>') ls++;\n        else if (s[i] == '+') increase(all, ls + n);\n        else decrease(all, ls + n);\n    }\n    Data fuck; mp[all] = 1; LL res = 0;\n    for (int i = 1, ls = 0; i <= n; i++) {\n        if (s[i] == '<') ls--;\n        else if (s[i] == '>') ls++;\n        else if (s[i] == '+') increase(fuck, ls + n);\n        else decrease(fuck, ls + n);\n        res += mp[fuck], mp[fuck + all * ls]++;\n    }\n    printf(\"%lld\\n\", res);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <unordered_map>\n#define FILL(a, n, x) memset((a), (x), sizeof ((a)[0]) * (n))\n#define COPY(a, n, b) memcpy((b), (a), sizeof ((a)[0]) * (n))\nusing namespace std;\n\ntypedef long long li;\nconst li infl = ~0LLU >> 2;\n\n// template <class T>\n// inline void Min(T &x, T y) {\n//   if (y < x) x = y;\n// }\n// template <class T>\n// inline void Max(T &x, T y) {\n//   if (y > x) x = y;\n// }\n\nconst li mod = (li)1e18 + 9;\ninline li Add(li x) { return x >= mod ? x - mod : x; }\ninline void Add(li &x, li y) { x += y; if (x >= mod) x -= mod; }\ninline li Sub(li x) { return x < 0 ? x + mod : x; }\ninline void Sub(li &x, li y) { x -= y; if (x < 0) x += mod; }\n\nli Mul(li x, li y) {\n  return Sub((x * y - (li)(x / (long double)mod * y + 1e-3L) * mod) % mod);\n}\n\ninline li Mul(li x, li y, li z) { return Mul(x, Mul(y, z)); }\nli Pow(li x, li y) {\n  li z = 1;\n  for (; y; y >>= 1) {\n    if (y & 1) z = Mul(z, x);\n    x = Mul(x, x);\n  }\n  return z;\n}\nli Inv(li x) {\n  return Pow(x, mod - 2);\n}\n\n// ----------------------------------------\n\nconst int maxn = 2.5e5;\nconst li base = 1000037, invbase = Inv(base);\n\nli _pow[maxn * 2 + 1], *pow = _pow + maxn;\n\nvoid Init(int n) {\n  pow[0] = 1;\n  for (int i = 1; i <= n; ++i) {\n    pow[i] = Mul(pow[i - 1], base);\n    pow[-i] = Mul(pow[-i + 1], invbase);\n  }\n}\n\nint n;\nchar str[maxn + 1];\nint delta[maxn + 1];\nli sum[maxn + 1];\n\nint main(void) {\n  scanf(\"%d%s\", &n, str);\n  Init(n);\n  delta[0] = 0;\n  sum[0] = 0;\n  for (int i = 1; i <= n; ++i) {\n    switch (str[i - 1]) {\n    case '+':\n      delta[i] = delta[i - 1];\n      sum[i] = Add(sum[i - 1] + pow[delta[i]]);\n      break;\n    case '-':\n      delta[i] = delta[i - 1];\n      sum[i] = Sub(sum[i - 1] - pow[delta[i]]);\n      break;\n    case '<':\n      delta[i] = delta[i - 1] - 1;\n      sum[i] = sum[i - 1];\n      break;\n    case '>':\n      delta[i] = delta[i - 1] + 1;\n      sum[i] = sum[i - 1];\n      break;\n    }\n  }\n  unordered_map<li, int> cnt;\n  li ans = 0;\n  for (int i = n; i >= 0; --i) {\n    if (i < n) {\n      li target = Add(sum[i] + Mul(pow[delta[i]], sum[n]));\n      ans += cnt[target];\n    }\n    ++cnt[sum[i]];\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\n\nconst int mod0 = 1e9 + 7;\nconst int mod1 = 1e9 + 9;\nconst int mod2 = 1e9 + 21;\nconst int base = 133333;\n\nint64_t power(int64_t x, int64_t n, int64_t mod) {\n  int64_t ret = 1;\n  while(n > 0) {\n    if(n & 1) (ret *= x) %= mod;\n    (x *= x) %= mod;\n    n >>= 1;\n  }\n  return ret;\n}\n\n\nint64 h0[550001], g0[550001];\nint64 h1[550001], g1[550001];\nint64 h2[550001], g2[550001];\n\n\nint main() {\n\n  h0[0] = h1[0] = h2[0] = 1;\n  for(int i = 1; i < 550001; i++) {\n    h0[i] = h0[i - 1] * base % mod0;\n    h1[i] = h1[i - 1] * base % mod1;\n    h2[i] = h2[i - 1] * base % mod2;\n  }\n  g0[550000] = power(h0[550000], mod0 - 2, mod0);\n  g1[550000] = power(h1[550000], mod1 - 2, mod1);\n  g2[550000] = power(h2[550000], mod2 - 2, mod2);\n  for(int i = 549999; i >= 0; i--) {\n    g0[i] = g0[i + 1] * (i + 1) % mod0;\n    g1[i] = g1[i + 1] * (i + 1) % mod1;\n    g2[i] = g2[i + 1] * (i + 1) % mod2;\n  }\n\n  int N;\n  string S;\n\n  cin >> N;\n  cin >> S;\n\n  vector< int64 > latte0, malta0;\n  vector< int64 > latte1, malta1;\n  vector< int64 > latte2, malta2;\n  int64 beet = 0, pos = 250001;\n  latte0.push_back(pos), malta0.push_back(beet);\n  latte1.push_back(pos), malta1.push_back(beet);\n  latte2.push_back(pos), malta2.push_back(beet);\n  for(int i = 0; i < N; i++) {\n    char c = S[i];\n    if(c == '+') (beet += h0[pos]) %= mod0;\n    else if(c == '-') (beet += mod0 - h0[pos]) %= mod0;\n    else if(c == '<') --pos;\n    else ++pos;\n    latte0.push_back(pos), malta0.push_back(beet);\n  }\n  beet = 0, pos = 250001;\n  for(int i = 0; i < N; i++) {\n    char c = S[i];\n    if(c == '+') (beet += h1[pos]) %= mod1;\n    else if(c == '-') (beet += mod1 - h1[pos]) %= mod1;\n    else if(c == '<') --pos;\n    else ++pos;\n    latte1.push_back(pos), malta1.push_back(beet);\n  }\n  beet = 0, pos = 250001;\n\n  for(int i = 0; i < N; i++) {\n    char c = S[i];\n    if(c == '+') (beet += h2[pos]) %= mod2;\n    else if(c == '-') (beet += mod2 - h2[pos]) %= mod2;\n    else if(c == '<') --pos;\n    else ++pos;\n    latte2.push_back(pos), malta2.push_back(beet);\n  }\n\n\n  map< tuple< int64, int64, int64 >, int > mp;\n  int64 ret = 0;\n  for(int i = N; i >= 0; i--) {\n    int64 dx = latte0[i] - latte0[0];\n    int64 mul0, mul1, mul2;\n    if(dx >= 0) mul0 = h0[dx], mul1 = h1[dx], mul2 = h1[dx];\n    else mul0 = g0[-dx], mul1 = g1[-dx], mul2 = g2[-dx];\n    ret += mp[make_tuple((malta0[i] + malta0[N] * mul0) % mod0, (malta1[i] + malta1[N] * mul1) % mod1, (malta2[i] + malta2[N] * mul2) % mod2)];\n    ++mp[make_tuple(malta0[i], malta1[i], malta2[i])];\n  }\n  cout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,ans;\nunsigned long long x1=1,x2=521,xx=521,a[2500010],b[2500010],t[2500010];\nstring st;\nmap<unsigned long long,int>k;\nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<=63;i++)\n\t{\n\t\tx1=x1*x2;\n\t\tx2=x2*x2;\n\t}\n\tcin>>st;\n\tst=' '+st;\n\tb[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\ta[i]=a[i-1];\n\t\tb[i]=b[i-1];\n\t\tif(st[i]=='+')a[i]=a[i]+b[i];\n\t\tif(st[i]=='-')a[i]=a[i]-b[i];\n\t\tif(st[i]=='<')b[i]=b[i]*x1;\n\t\tif(st[i]=='>')b[i]=b[i]*xx;\n\t\tk[a[i]]++;\n\t} \n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tans+=k[a[n]*b[i-1]+a[i-1]];\n\t\tk[a[i]]--;\n\t}\n\tcout<<ans;\n\treturn 0; \n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nint gcd(int a, int b) { return b ? gcd(b, a % b) : a; }\ntemplate<typename T, typename U> inline bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> inline bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\nstruct Init {\n    Init() {\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n        cout << unitbuf;\n        cout << fixed << setprecision(20);\n    };\n} init;\n\n\nint N;\nstring S;\nint mod = 1e9 + 7;\n\n// 拡張ユークリッドの互除法\nint extgcd(int a, int b, int &x, int &y) {\n    int d = a;\n    if (b != 0) {\n        d = extgcd(b, a % b, y, x);\n        y -= (a / b) * x;\n    } else {\n        x = 1;\n        y = 0;\n    }\n    return d;\n}\n\n// mod逆元\nint mod_inverse(int a, int m) {\n    int x, y;\n    extgcd(a, m, x, y);\n    return (m + x % m) % m;\n}\n\npint f(pint ab, int i, int hash) {\n    if (S[i] == '+') { return pint(ab.first, (ab.second + 1) % mod); }\n    else if (S[i] == '-') { return pint(ab.first, (ab.second - 1 + mod) % mod); }\n    else if (S[i] == '>') { return pint(ab.first * hash % mod, ab.second * hash % mod); }\n    else if (S[i] == '<') {\n        return pint(ab.first * mod_inverse(hash, mod) % mod,\n                    ab.second * mod_inverse(hash, mod) % mod);\n    }\n}\n\npint finv(pint ab, int i, int hash) {\n    if (S[i] == '-') { return pint(ab.first, (ab.second + 1) % mod); }\n    else if (S[i] == '+') { return pint(ab.first, (ab.second - 1 + mod) % mod); }\n    else if (S[i] == '<') { return pint(ab.first * hash % mod, ab.second * hash % mod); }\n    else if (S[i] == '>') {\n        return pint(ab.first * mod_inverse(hash, mod) % mod,\n                    ab.second * mod_inverse(hash, mod) % mod);\n    }\n}\nsigned main() {\n    cin >> N >> S;\n    const int K = 3;\n    vint hash = {114514, 1919, 810};\n    map<int, int> mp[K];\n    pint b[K], c[K];\n    for (int i = 0; i < K; i++) {\n        int h = hash[i];\n        b[i] = c[i] = pint(1, 0);\n        for (int j = N - 1; j >= 0; j--) { b[i] = f(b[i], j, h), mp[i][0] = 1; }\n    }\n    int ans = 0;\n    for (int i = N - 1; i >= 0; i--) {\n        int cur = LLONG_MAX;\n        for (int j = 0; j < K; j++) {\n            int h = hash[j];\n            pint cc = finv(pint(1, 0), i, h);\n            c[j] = pint(c[j].first * cc.first % mod, (c[j].first * cc.second + c[j].second) % mod);\n            int fi = (c[j].first * b[j].second + c[j].second) % mod;\n            chmin(cur, mp[j][fi]);\n            mp[j][c[j].second]++;\n        }\n        ans += cur;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\nint modpow(int x, int k, int MOD) {\n  int a = 1;\n  while (k) {\n    if (k&1) a = (1LL*a*x)%MOD;\n    x = (1LL*x*x)%MOD;\n    k>>=1;\n  }\n  return a;\n}\nconst int NUM = 5;\nconst int B = 3213212;\nconst vector<int> hashes = {\n  1000000007,\n  1000000009,\n};\nstruct Hash {\n  vector<int> data;\n  Hash(int x) {\n    data.resize(hashes.size(), x);\n  }\n  Hash() {\n    data.resize(hashes.size(), 0);\n  }\n};\nHash add(Hash a, int b) {\n  rep(i, hashes.size()) a.data[i] = (0LL+a.data[i]+b) % hashes[i];\n  return a;\n}\nHash add(Hash a, Hash b) {\n  rep(i, hashes.size()) a.data[i] = (0LL+a.data[i]+b.data[i]) % hashes[i];\n  return a;\n}\nHash mul(Hash a, Hash b) {\n  rep(i, hashes.size()) a.data[i] = (1LL*a.data[i]*b.data[i]) % hashes[i];\n  return a;\n}\nHash inv(Hash a) {\n  Hash ret;\n  rep(i, hashes.size()) ret.data[i] = modpow(a.data[i], hashes[i]-2, hashes[i]);\n  return ret;\n}\n\n\nint N;\nstring S;\nHash pB[500001];\nHash memo[250000];\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  pB[0] = Hash(1);\n  for (int i=1; i<=500000; i++) pB[i] = mul(pB[i-1], B);\n  Hash minus1;\n  rep(i, hashes.size()) minus1.data[i] = hashes[i]-1;\n\n  cin >> N >> S;\n  int p = 250000;\n  Hash hash(0);\n  map<vector<int>, int> mp;\n  rep(i, N) {\n    if (S[i] == '+') hash = add(hash, pB[p]);\n    if (S[i] == '-') hash = add(hash, mul(pB[p], minus1));\n    if (S[i] == '>') p++;\n    if (S[i] == '<') p--;\n    memo[i] = hash;\n    mp[hash.data]++;\n  }\n\n  const Hash ONE = pB[250000];\n  Hash invB = inv(B);\n  long long sum = 0;\n\n  Hash a(1), b(0); // h -> h*a+b\n  rep(l, N) {\n    Hash h = add(mul(hash, a), b);\n    sum += mp[h.data];\n\n    if (S[l] == '+') b = add(b, mul(a, ONE)); // all -= ONE\n    if (S[l] == '-') b = add(b, mul(a, mul(ONE, minus1))); // all += ONE\n    if (S[l] == '>') a = mul(a, B); // all /= B\n    if (S[l] == '<') a = mul(a, invB); // all *= B\n    mp[memo[l].data]--;\n  }\n  cout << sum << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n  \n#define ll long long\n#define all(aaa) aaa.begin(), aaa.end()\n\nconst int MOD = 1e9 + 9, N = 3e5 + 5;\nconst ll X = 1234567;\n\nll bp(ll a, ll p) {\n    ll r = 1;\n    while (p > 0) {\n        if (p & 1) {\n            r = r * a % MOD;\n        }\n        a = a * a % MOD;\n        p >>= 1;\n    }\n    return r;\n}\n\nll inv_X = bp(X, MOD - 2);\n\nll a[N], b[N];\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n;\n    string s;\n    cin >> n >> s;\n\n    ll h = 0;\n\n    for (int i = n - 1; i >= 0; i--) {\n        if (s[i] == '>')\n            h = h * X % MOD;\n        else if (s[i] == '<')\n            h = h * inv_X % MOD;\n        else if (s[i] == '+')\n            h = (h + 1) % MOD;\n        else\n            h = (h - 1 + MOD) % MOD;\n    }\n\n    map<ll, int> mp;\n\n    ll ans = 0;\n\n    mp[0]++;\n\n    a[n] = 1;\n\n    for (int i = n - 1; i >= 0; i--) {\n        a[i] = a[i + 1];\n        b[i] = b[i + 1];\n\n        if (s[i] == '>') {\n            a[i] = a[i + 1] * inv_X % MOD;\n            b[i] = b[i + 1];\n        }\n        else if (s[i] == '<') {\n            a[i] = a[i + 1] * X % MOD;\n            b[i] = b[i + 1];\n        }\n        else if (s[i] == '+') {\n            a[i] = a[i + 1];\n            b[i] = (b[i] - a[i + 1] + MOD) % MOD;\n        }\n        else {\n            a[i] = a[i + 1];\n            b[i] = (b[i] + a[i + 1]) % MOD;\n        }\n\n        // cout << b[i] << \"\\n\";\n\n        ans += mp[(a[i] * h + b[i]) % MOD];\n        mp[b[i]]++;\n    }\n\n    // cout << (a[0] * h + b[0]) % MOD << \"\\n\";\n\n    cout << ans << \"\\n\";\n\n    return 0;   \n}"
  },
  {
    "language": "C++",
    "code": "// AtCoder Regular Contest 099\n// Problem F - Eating Symbols Hard\n#include <cstdio>\n#include <cstring>\n#include <iostream>\nusing std::cin; using std::cout; using std::endl;\n#include <algorithm>\nusing std::sort;\n#include <vector>\nusing std::vector;\n#include <queue>\nusing std::queue; using std::priority_queue;\n#include <map>\nusing std::map;\ntypedef long long LL;\n#define pass printf(\"%s : Line.%d\\n\", __FUNCTION__, __LINE__);\nconst int maxN = 250000 + 233; // 2.5e5\nint n;\nchar opt[maxN];\nint d[maxN], df; LL h[maxN], hf, h2[maxN], hf2;\n//const LL P = 1e9 + 7;\nbool isp(LL x) {\n\tfor(int i = 2; i*i <= x; ++i)\n\t\tif(x % i == 0) return false;\n\treturn true;\n}\nconst LL p = 1000000007;\nconst LL p2 = 1000000123;\nconst LL b = 107;\nconst LL b2 = 103;\nLL buc[maxN*2], buc2[maxN*2];\n#define pow powerpowe\nLL *pow = &buc[maxN], *pow2 = &buc2[maxN];\nLL inv(LL x, LL p) {\n\treturn x == 1 ? x : (p - (p / x) * inv(p % x, p)) % p;\n}\nLL inc(LL &a, LL b) { return (a += b) >= p ? a -= p : a; }\nLL dec(LL &a, LL b) { return (a -= b) < 0 ? a += p : a; }\nLL dif(LL a, LL b) { return a - b < 0 ? a - b + p : a - b; }\nmap<LL, int> M;\n\nvoid init() {\n\tpow[0] = 1;\n\tpow[1] = b; pow[-1] = inv(b, p);\n\tfor(int i = 1; i <= n; ++i) pow[i] = pow[i-1] * b % p;\n\tfor(int i = -1; i >= -n; --i) pow[i] = pow[i+1]* pow[-1] % p;\n\thf = df = 0;\n\tfor(int i = 1; i <= n; ++i) {\n\t\tswitch(opt[i]) {\n\t\t\tcase '+':\n\t\t\t\tinc(hf, pow[df]);\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tdec(hf, pow[df]);\n\t\t\t\tbreak;\n\t\t\tcase '>':\n\t\t\t\t++df;\n\t\t\t\tbreak;\n\t\t\tcase '<':\n\t\t\t\t--df;\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main() {\n//\tfor(int i = (int)1e9; ; ++i) if(isp(i)) printf(\"%d\\n\", i), getchar();\n//\tprintf(\"%.3lfMB\\n\", sizeof(buc)*6/1000.0/1000.0);\n\tscanf(\"%d%s\", &n, opt + 1);\n\tinit();\n\tLL cnt = 0;\n\tM.clear();\n\th[0] = d[0] = 0;\n\tM[(h[0] + hf * pow[d[0]]) % p] = 1;\n\tfor(int i = 1; i <= n; ++i) {\n\t\td[i] = d[i-1]; h[i] = h[i-1];\n\t\tswitch(opt[i]) {\n\t\t\tcase '+':\n\t\t\t\tinc(h[i], pow[d[i]]);\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tdec(h[i], pow[d[i]]);\n\t\t\t\tbreak;\n\t\t\tcase '>':\n\t\t\t\t++d[i];\n\t\t\t\tbreak;\n\t\t\tcase '<':\n\t\t\t\t--d[i];\n\t\t\t\tbreak;\n\t\t}\n\t\tif(M.find(h[i]) != M.end()) cnt += M[h[i]]/*, printf(\"i = %d, cnt += %d\\n\", i, M[h[i]])*/;\n\t\tint now = (h[i] + hf * pow[d[i]]) % p;\n\t\tif(M.find(now) == M.end()) M[now] = 1; else ++M[now];\n\t}\n\tprintf(\"%lld\\n\", cnt);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "const int N = 250005;\nconst int LG = 21;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nint n;\nstring s;\n\nconst ll M = 1;\nconst ll K[M] = {1000003};\nconst ll rK[M] = {rev(K[0])};\nmap<ll, ll> deg[M];\n\nvector<ll> ad(vector<ll> a)\n{\n    for (int i = 0; i < M; i++)\n    {\n        a[i]++;\n        if (a[i] >= MOD) a[i] -= MOD;\n    }\n    return a;\n}\n\nvector<ll> mi(vector<ll> a)\n{\n    for (int i = 0; i < M; i++)\n    {\n        a[i]--;\n        if (a[i]  < 0) a[i] += MOD;\n    }\n    return a;\n}\n\nvector<ll> mu(vector<ll> a)\n{\n    for (int i = 0; i < M; i++)\n    {\n        a[i] = a[i] * K[i] % MOD;\n    }\n    return a;\n}\n\nvector<ll> di(vector<ll> a)\n{\n    for (int i = 0; i < M; i++)\n    {\n        a[i] = a[i] * rK[i] % MOD;\n    }\n    return a;\n}\n\nsigned main()\n{\n    for (int i = 0; i < M; i++)\n    {\n        deg[i][0] = 1;\n        for (int j = 1; j < N; j++) deg[i][j] = deg[i][j - 1] * K[i] % MOD;\n        for (int j = 1; j < N; j++) deg[i][-j] = deg[i][-j + 1] * rK[i] % MOD;\n    }\n    srand(time(NULL));\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n    cin >> n >> s;\n    vector<ll> a(M);\n    for (int i = n - 1; i >= 0; i--)\n    {\n        if (s[i] == '+') a = mi(a);\n        if (s[i] == '-') a = ad(a);\n        if (s[i] == '>') a = mu(a);\n        if (s[i] == '<') a = di(a);\n    }\n    map<vector<ll>, int> cnt;\n    ll ans = 0;\n    ll cur_move = 0;\n    vector<ll> cur(M, 0);\n    cnt[cur]++;\n    for (int i = n - 1; i >= 0; i--)\n    {\n        if (s[i] == '+')\n        {\n            for (int j = 0; j < M; j++) cur[j] = (cur[j] + deg[j][cur_move]) % MOD;\n        }\n        if (s[i] == '-')\n        {\n            for (int j = 0; j < M; j++) cur[j] = (cur[j] + MOD - deg[j][cur_move]) % MOD;\n        }\n        if (s[i] == '<')\n        {\n            cur_move++;\n        }\n        if (s[i] == '>')\n        {\n            cur_move--;\n        }\n        vector<ll> ask = cur;\n        //for (int j = 0; j < M; j++) cout << cur[j] << \" \"; cout << \"\\n\";\n        for (int j = 0; j < M; j++) ask[j] = (ask[j] + a[j] * deg[j][cur_move]) % MOD;\n        //for (int j = 0; j < M; j++) cout << ask[j] << \" \"; cout << \"\\n\\n\";\n        ans += cnt[ask];\n        cnt[cur]++;\n    }\n    cout << ans;\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "\t#include <iostream>\n    #include <string>\n    #include <set>  \n    #include <stack>\n    #include <algorithm>\n    #include <vector>\n    #include <cmath>\n    #include <queue>\n    #include <deque>\n    #include <cstring>\n    #include <cstdio>\n    #include <map>\n    #include <numeric>\n    #include <cassert>\n    #include <iomanip>\n    #include <sstream>\n    #include <ctime>\nusing namespace std;\n#define for1(i,a,b) for(int i=(a);i<(int)(b);++i)\n#define rep(i,maxn) for1(i,0,maxn)\n#define ford(i,b,a) for(int i=(int)(b)-1;i>=a;--i)\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define st first\n#define nd second\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define dprintf(...) printf(__VA_ARGS__)\nconst int maxn=250100;\nll M=10001659;\nll X=22;\nll a[maxn],b[maxn],t[maxn],T[maxn];\nint n;\nchar s[maxn];\nll qp(ll base,int ind)\n{\n\tll ans=1;\n\tbase%=M;\n\twhile(ind)\n\t{\n\t\tif(ind&1)ans=ans*base%M;\n\t\tind>>=1;\n\t\tbase=base*base%M;\n\t}\n\treturn ans;\n}\nll inv(ll x)\n{\n\treturn qp(x,(int)(M-2));\n}\nmap<ll,int> trans;\nint main()\n{\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",s);\n\tll rev=inv(X);\n//\tcout<<rev<<endl;\n//\tsystem(\"pause\");\n\tmemset(t,0,sizeof(t));\n\tford(i,n,0)\n\t{\n\t\tt[i]=t[i+1];\n\t\tif(s[i]=='+')\n\t\t{\n\t\t\tt[i]++;\n\t\t\tt[i]%=M;\n\t\t}\n\t\telse if(s[i]=='-')\n\t\t{\n\t\t\tt[i]--;\n\t\t\tt[i]+=M;\n\t\t\tt[i]%=M;\n\t\t}\n\t\telse if(s[i]=='>')\n\t\t{\n\t\t\tt[i]*=rev;\n\t\t\tt[i]%=M;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tt[i]*=X;\n\t\t\tt[i]%=M;\n\t\t}\n//\t\tcout<<t[i]<<endl;\n//\t\tsystem(\"pause\");\n\t}\n\tll c=t[0];\n//\tprintf(\"%lld\\n\",c);\n//\tsystem(\"pause\");\n\tint multa=1,mina=0,multb=1,minb=0;\n\tford(i,n,0)\n\t{\n\t\tif(s[i]=='+')\n\t\t{\n\t\t\tmina-=multa,minb-=multb;\n\t\t\tmina+=M,minb+=M;\n\t\t\tmina%=M,minb%=M; \n\t\t}\n\t\telse if(s[i]=='-')\n\t\t{\n\t\t\tmina+=multa,minb+=multb;\n\t\t\tmina%=M,minb%=M;\n\t\t}\n\t\telse if(s[i]=='>')\n\t\t{\n\t\t\tmulta=multa*X%M;\n\t\t\tmultb=multb*X%M;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmulta=multa*rev%M;\n\t\t\tmultb=multb*rev%M;\n\t\t}\n\t\ta[i]=mina%M;\n\t\tb[i]=(c*multb%M+minb%M)%M;\n\t//\tcout<<a[i]<<\" \"<<b[i]<<endl;\n\t\ttrans[b[i]]++;\n\t//\tsystem(\"pause\");\n\t}\n\t\n\t//a(j+1)=b(i) j+1>i\n\tint ans=0;\n\tford(j,n-1,0)\n\t{\n\t//\tcout<<trans[a[j+1]]<<\" \"<<a[j+1]<<endl;\n\t//\tsystem(\"pause\");\n\t\ttrans[b[j+1]]--;\n\t\tans+=trans[a[j+1]];\n\t}\n\trep(i,n)\n\t\tif(a[i]==a[0])ans++;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<map>\n\ntypedef long long ll;\n\nconst int N=250010,MOD=1000000007,g=500003;\n\nll inv(int x){return (x==1 || x==-1)?x:(-(MOD/x)*inv(MOD%x)%MOD);}\n\nint t0[N*2],*pow;\n\nvoid initialize()\n{\n\tpow=t0+N;\n\n\tpow[0]=1;\n\tfor(int i=1;i<N;i++)\n\t\tpow[i]=(ll)pow[i-1]*g%MOD;\n\n\tint ig=(inv(g)+MOD)%MOD;\n\tfor(int i=0;i<N;i++)\n\t\tpow[-i-1]=(ll)pow[-i]*ig%MOD;\n}\n\nchar s[N];\nint ind[N],val[N],sum[N];\nint n;\n\nll ans;\n\nvoid prework()\n{\n\tint p=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tind[i]=p,val[i]=0;\n\n\t\tif(s[i]=='<')p--;\n\t\telse if(s[i]=='>')p++;\n\t\telse if(s[i]=='+')val[i]=pow[p];\n\t\telse val[i]=-pow[p];\n\t}\n\n\tfor(int i=1;i<=n;i++)\n\t\tsum[i]=((sum[i-1]+val[i])%MOD+MOD)%MOD;\n}\n\nstd::map<int,int> G;\n\nvoid solve()\n{\n\tans=0;\n\tfor(int i=n,x,y;i;i--)\n\t{\n\t\tG[sum[i]]++;\n\n\t\tx=((ll)sum[n]*pow[ind[i]]%MOD+MOD)%MOD;\n\t\ty=((x+sum[i-1])%MOD+MOD)%MOD;\n\n\t\tans+=G[y];\n\t}\n}\n\nint main()\n{\n\tinitialize();\n\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",s+1);\n\n\tprework();\n\tsolve();\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\nusing namespace std;\n#define N 500200\n#define mod1 1000000009\n#define mod2 1000000007\n#define ch1 131\n#define ch2 233\nmap<long long,int> tp;\nint pw1[N],pw2[N],n,su[N],vl[N],ha1[N],ha2[N],as1,as2;\nlong long as;\nchar s[N];\nint pw(int a,int p,int mod){int as=1;while(p){if(p&1)as=1ll*as*a%mod;a=1ll*a*a%mod;p>>=1;}return as;}\nint main()\n{\n\tscanf(\"%d%s\",&n,s+1);\n\tsu[0]=n;\n\tpw1[0]=pw2[0]=1;\n\tfor(int i=1;i<=n*2;i++)pw1[i]=1ll*pw1[i-1]*ch1%mod1,pw2[i]=1ll*pw2[i-1]*ch2%mod2;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tsu[i]=su[i-1];\n\t\tif(s[i]=='<')su[i]--;\n\t\tif(s[i]=='>')su[i]++;\n\t\tif(s[i]=='+')as1=(as1+pw1[su[i]])%mod1,as2=(as2+pw2[su[i]])%mod2;\n\t\tif(s[i]=='-')as1=(as1-pw1[su[i]]+mod1)%mod1,as2=(as2-pw2[su[i]]+mod2)%mod2;\n\t}\n\tfor(int i=n;i>=1;i--)ha1[i]=(ha1[i+1]+mod1+(s[i]=='+'?1ll:(s[i]=='-'?-1ll:0))*pw1[su[i]])%mod1,ha2[i]=(ha2[i+1]+mod2+(s[i]=='+'?1ll:(s[i]=='-'?-1ll:0))*pw2[su[i]])%mod2;\n\ttp[0]=1;\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tint nas1,nas2;\n\t\tif(su[i-1]>=su[0])nas1=1ll*as1*pw1[su[i-1]-su[0]]%mod1,nas2=1ll*as2*pw2[su[i-1]-su[0]]%mod2;\n\t\telse nas1=1ll*as1*pw(pw(ch1,mod1-2,mod1),su[0]-su[i-1],mod1)%mod1,nas2=1ll*as2*pw(pw(ch2,mod2-2,mod2),su[0]-su[i-1],mod2)%mod2;\n\t\tnas1=(ha1[i]-nas1+mod1)%mod1,nas2=(ha2[i]-nas2+mod2)%mod2;\n\t\tas+=tp[nas1*10000000000ll+nas2];\n\t\ttp[ha1[i]*10000000000ll+ha2[i]]++;\n\t}\n\tprintf(\"%lld\\n\",as);\n}//"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define LL long long\nint n;\nint powi(int a, int b, int m)\n{\n    int c = 1;\n    for (; b; b >>= 1, a = 1ll * a * a % m)\n        if (b & 1) c = 1ll * c * a % m;\n    return c;\n}\nconst int BAS = 233;\nconst int MOD1 = 1e9 + 7;\nconst int MOD2 = 1e9 + 9;\nconst int BIV1 = powi(BAS, MOD1 - 2, MOD1);\nconst int BIV2 = powi(BAS, MOD2 - 2, MOD2);\nconst int N = 500000;\nchar st[N];\npair <int, int> V[N], S[N];\nmap <pair <int, int>, int> C;\nLL res;\nint main()\n{\n    scanf(\"%d\", &n);\n    scanf(\"%s\", st + 1);\n    V[0] = make_pair(1, 1);\n    for (int i = 1; i <= n; ++ i)\n    {\n        if (st[i] == '>')\n            V[i] = make_pair(1ll * V[i - 1].first * BAS % MOD1, 1ll * V[i - 1].second * BAS % MOD2),\n            S[i] = S[i - 1];\n        else if (st[i] == '<')\n            V[i] = make_pair(1ll * V[i - 1].first * BIV1 % MOD1, 1ll * V[i - 1].second * BIV2 % MOD2),\n            S[i] = S[i - 1];\n        else if (st[i] == '+')\n            V[i] = V[i - 1],\n            S[i] = make_pair((S[i - 1].first + V[i].first) % MOD1, (S[i - 1].second + V[i].second) % MOD2);\n        else if (st[i] == '-')\n            V[i] = V[i - 1],\n            S[i] = make_pair((S[i - 1].first - V[i].first + MOD1) % MOD1, (S[i - 1].second - V[i].second + MOD2) % MOD2);\n    }\n    for (int i = n; ~i; -- i)\n    {\n        res += C[make_pair((1ll * S[n].first * V[i].first + S[i].first) % MOD1,\n            (1ll * S[n].second * V[i].second + S[i].second) % MOD2)];\n        C[S[i]] ++;\n    }\n    printf(\"%lld\\n\", res);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll=long long;\n\nconst ll R = 843823891, iR = 1040004855;\nconst ll M = 1637348371;\nll mpow(ll x, int64_t e) {\n    ll res = 1;\n    for (; e; e >>= 1) {\n        if (e & 1) res *= x, res %= M;\n        x *= x, x %= M;\n    }\n    return res;\n}\nll minv(ll x) {\n    return mpow(x, M-2);\n}\nstruct Lm {\n    ll k,b;\n    Lm() {}\n    Lm(ll _k,ll _b): k(_k),b(_b){}\n    Lm(char x) {\n        if (x == '+') k = 1, b = 1;\n        if (x == '-') k = 1, b = M-1;\n        if (x == '>') k = R, b = 0;\n        if (x == '<') k = iR,b = 0;\n    }\n    Lm(const Lm& _lm): k(_lm.k), b(_lm.b){}\n    Lm& operator*=(const Lm& _lm){\n        b += k*_lm.b%M; b %= M;\n        k *= _lm.k; k %= M;\n        return *this;\n    }\n    Lm inv(){\n        ll ik = minv(k);\n        ll ib = -ik*b; ib %= M; (ib+=M)%=M;\n        return {ik,ib};\n    }\n    ll eval(ll x) {\n        return (k*x%M+b)%M;\n    }\n};\nLm operator*(const Lm& _a, const Lm& _b) {\n    return Lm(_a) *= _b;\n}\n\nvoid solve() {\n    int n; cin >> n;\n    string s; cin >> s;\n    vector<Lm> a, ia(n);\n    for (int i = 0; i < n; i++) {\n        a.emplace_back(s[i]);\n        ia[i] = a[i].inv();\n    }\n    auto isuf = ia;\n    for (int i = n-2; i >= 0; i--) {\n        isuf[i] = isuf[i+1] * isuf[i];\n    }\n    ll c = isuf[0].inv().eval(0);\n    vector<ll> z(n+1), g(n); z[n] = 0;\n    for (int i = 0; i < n; i++) {\n        z[i] = isuf[i].eval(0);\n        g[i] = isuf[i].eval(c);\n    }\n    map<ll, int> cnt;\n    ll res = 0;\n    for (int i = 0; i < n; i++) {\n        cnt[g[i]]++;\n        res += cnt[z[i+1]];\n    }\n    cout << res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    solve();\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<climits>\n#include<bitset>\n#include<map>\n#define pii pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define int long long\n#define mod1 998244353\n#define mod2 1000000007\nusing namespace std;\ninline int read(){\n    int f=1,ans=0;char c=getchar();\n    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}\n    while(c>='0'&&c<='9'){ans=ans*10+c-'0';c=getchar();}\n    return f*ans;\n}\nconst int MAXN=5e5+11;\nint N;char str[MAXN];\nint h1[MAXN],s1[MAXN],xx=101,res,h2[MAXN],s2[MAXN];\nint ksm1(int a,int b){\n    int ans=1;\n    while(b){if(b&1) ans*=a,ans%=mod1;a*=a,a%=mod1;b>>=1;}return ans;\n}\nint pw1(int a,int b){\n    if(b>=0) return ksm1(a,b);\n    int res=ksm1(a,-b);return ksm1(res,mod1-2);\n}\nint ksm2(int a,int b){\n    int ans=1;\n    while(b){if(b&1) ans*=a,ans%=mod2;a*=a,a%=mod2;b>>=1;}return ans;\n}\nint pw2(int a,int b){\n    if(b>=0) return ksm2(a,b);\n    int res=ksm2(a,-b);return ksm2(res,mod1-2);\n}\nmap<pii,int> M;\nvoid ins(int ps){M[mp( (h1[ps]+pw1(xx,s1[ps])*h1[N])%mod1 , (h2[ps]+pw2(xx,s2[ps])*h2[N])%mod2 )]++;return;}\nsigned main(){\n    //freopen(\"1.in\",\"r\",stdin);\n    N=read();scanf(\"%s\",str+1);\n    for(int i=1;i<=N;i++){\n        if(str[i]=='+') h1[i]=h1[i-1]+pw1(xx,s1[i-1]),s1[i]=s1[i-1],h1[i]%=mod1;\n        if(str[i]=='-') h1[i]=h1[i-1]-pw1(xx,s1[i-1])+mod1,s1[i]=s1[i-1],h1[i]%=mod1;\n        if(str[i]=='>') h1[i]=h1[i-1],s1[i]=s1[i-1]+1;\n        if(str[i]=='<') h1[i]=h1[i-1],s1[i]=s1[i-1]-1;\n        if(str[i]=='+') h2[i]=h2[i-1]+pw2(xx,s2[i-1]),s2[i]=s2[i-1],h2[i]%=mod2;\n        if(str[i]=='-') h2[i]=h2[i-1]-pw2(xx,s2[i-1])+mod2,s2[i]=s2[i-1],h2[i]%=mod2;\n        if(str[i]=='>') h2[i]=h2[i-1],s2[i]=s2[i-1]+1;\n        if(str[i]=='<') h2[i]=h2[i-1],s2[i]=s2[i-1]-1;\n    }\n    //for(int i=1;i<=N;i++) printf(\"h:%lld s:%lld\\n\",h[i],s[i]);\n    /*for(int i=1;i<=N;i++)\n        for(int j=i;j<=N;j++){\n            if(((h1[i-1]+pw1(xx,s1[i-1])*h1[N])%mod1)==h1[j]&&((h2[i-1]+pw2(xx,s2[i-1])*h2[N])%mod2)==h2[j]){\n                res++;\n                //cerr<<i<<\" \"<<j<<endl;\n            }\n            //res+=(((h[i-1]+ksm(xx,s[i-1])*h[N])%mod)==h[j]);\n        }*/\n    ins(0);\n    for(int i=1;i<=N;i++){\n        res+=M[mp(h1[i],h2[i])];\n        ins(i);\n    }printf(\"%lld\\n\",res);return 0;\n}/*\n  5\n  +>+<-\n  */\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long lint;\n\nlint modpow(lint x, lint y, lint mod) {\n  lint ret = 1 % mod, x2p = x;\n  while (y > 0) {\n    if (y % 2) ret = (__int128)ret * x2p % mod;\n    y /= 2;\n    x2p = (__int128)x2p * x2p % mod;\n  }\n  return ret;\n}\n\nconst lint mod_1 = 1152921504609811141LL, mod_2 = 576460752312103501LL;\nconst lint base_1 = 102999959LL, base_2 = 1006199503LL;\nconst lint inv_base_1 = modpow(base_1, mod_1 - 2, mod_1);\nconst lint inv_base_2 = modpow(base_2, mod_2 - 2, mod_2);\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  string seq(n, ' ');\n  for (int i = 0; i < n; ++i)\n    scanf(\" %c\", &seq[i]);\n\n  vector<int> pos_before(n);\n\n  //\n  vector<lint> base_pow_1(n + 1);\n  base_pow_1[0] = 1;\n  for (int i = 1; i <= n; ++i)\n    base_pow_1[i] = (__int128)base_1 * base_pow_1[i - 1] % mod_1;\n\n  vector<lint> inv_base_pow_1(n + 1);\n  inv_base_pow_1[0] = 1;\n  for (int i = 1; i <= n; ++i)\n    inv_base_pow_1[i] = (__int128)inv_base_1 * inv_base_pow_1[i - 1] % mod_1;\n\n  vector<lint> hash_diff_1(n, 0);\n  int pos = 0;\n  for (int i = 0; i < n; ++i) {\n    pos_before[i] = pos;\n    if (seq[i] == '>') ++pos;\n    else if (seq[i] == '<') --pos;\n    else {\n      lint base_pow_1_pos;\n      if (pos >= 0) base_pow_1_pos = base_pow_1[pos];\n      else base_pow_1_pos = inv_base_pow_1[-pos];\n      if (seq[i] == '+') hash_diff_1[i] = base_pow_1_pos;\n      else if (seq[i] == '-') hash_diff_1[i] = mod_1 - base_pow_1_pos;\n      else assert(0);\n    }\n  }\n  lint full_seq_hash_1 = 0;\n  for (int i = 0; i < n; ++i) {\n    full_seq_hash_1 += hash_diff_1[i];\n    if (full_seq_hash_1 >= mod_1) full_seq_hash_1 -= mod_1;\n  }\n\n  vector<lint> suffix_1(n + 1);\n  suffix_1[n] = 0;\n  for (int i = n - 1; i >= 0; --i) {\n    suffix_1[i] = hash_diff_1[i] + suffix_1[i + 1];\n    if (suffix_1[i] >= mod_1) suffix_1[i] -= mod_1;\n  }\n\n  //\n  vector<lint> base_pow_2(n + 1);\n  base_pow_2[0] = 1;\n  for (int i = 1; i <= n; ++i)\n    base_pow_2[i] = (__int128)base_2 * base_pow_2[i - 1] % mod_2;\n\n  vector<lint> inv_base_pow_2(n + 1);\n  inv_base_pow_2[0] = 1;\n  for (int i = 1; i <= n; ++i)\n    inv_base_pow_2[i] = (__int128)inv_base_2 * inv_base_pow_2[i - 1] % mod_2;\n\n  vector<lint> hash_diff_2(n, 0);\n  pos = 0;\n  for (int i = 0; i < n; ++i) {\n    if (seq[i] == '>') ++pos;\n    else if (seq[i] == '<') --pos;\n    else {\n      lint base_pow_2_pos;\n      if (pos >= 0) base_pow_2_pos = base_pow_2[pos];\n      else base_pow_2_pos = inv_base_pow_2[-pos];\n      if (seq[i] == '+') hash_diff_2[i] = base_pow_2_pos;\n      else if (seq[i] == '-') hash_diff_2[i] = mod_2 - base_pow_2_pos;\n      else assert(0);\n    }\n  }\n  lint full_seq_hash_2 = 0;\n  for (int i = 0; i < n; ++i) {\n    full_seq_hash_2 += hash_diff_2[i];\n    if (full_seq_hash_2 >= mod_2) full_seq_hash_2 -= mod_2;\n  }\n\n  vector<lint> suffix_2(n + 1);\n  suffix_2[n] = 0;\n  for (int i = n - 1; i >= 0; --i) {\n    suffix_2[i] = hash_diff_2[i] + suffix_2[i + 1];\n    if (suffix_2[i] >= mod_2) suffix_2[i] -= mod_2;\n  }\n  //\n\n  lint result = 0;\n  map<pair<lint, lint>, int> count;\n  count[{suffix_1[n], suffix_2[n]}] += 1;\n  for (int i = n - 1; i >= 0; --i) {\n    lint shifted_full_1, shifted_full_2;\n    if (pos_before[i] >= 0) {\n      shifted_full_1 = (__int128)full_seq_hash_1 * base_pow_1[pos_before[i]] % mod_1;\n      shifted_full_2 = (__int128)full_seq_hash_2 * base_pow_2[pos_before[i]] % mod_2;\n    } else {\n      shifted_full_1 = (__int128)full_seq_hash_1 * inv_base_pow_1[-pos_before[i]] % mod_1;\n      shifted_full_2 = (__int128)full_seq_hash_2 * inv_base_pow_2[-pos_before[i]] % mod_2;\n    }\n\n    lint target_1 = suffix_1[i] - shifted_full_1;\n    if (target_1 < 0) target_1 += mod_1;\n\n    lint target_2 = suffix_2[i] - shifted_full_2;\n    if (target_2 < 0) target_2 += mod_2;\n\n    target_1 = (target_1 % mod_1 + mod_1) % mod_1;\n    target_2 = (target_2 % mod_2 + mod_2) % mod_2;\n\n    auto it = count.find({target_1, target_2});\n    if (it != count.end())\n      result += it->second;\n\n    suffix_1[i] = (suffix_1[i] % mod_1 + mod_1) % mod_1;\n    suffix_2[i] = (suffix_2[i] % mod_2 + mod_2) % mod_2;\n\n    count[{suffix_1[i], suffix_2[i]}] += 1;\n  }\n  printf(\"%lld\\n\", result);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#pragma GCC optimize(\"O3\")\n\ntypedef long long ll;\ntypedef long double ld;\nint lst;\nint sz = 0;\nconst int mod = 998244353;\nconst int maxN = 500000 + 40;\nconst int pt[2] = {228, 1337};\nint pw[2][maxN];\nint sum(int a, int b) {\n    int s = a + b;\n    if (s >= mod) s -= mod;\n    return s;\n}\nint mult(int a, int b) {\n    return (1LL * a * b) % mod;\n}\nint sub(int a, int b) {\n    int s = a - b;\n    if (s < 0) s += mod;\n    return s;\n}\nint pww(int a, int b) {\n    if (b == 0) return 1;\n    if (b & 1) return mult(a, pww(a, b - 1));\n    int res = pww(a, b / 2);\n    return mult(res, res);\n}\nint n;\nint hsh[2][maxN];\nchar c[maxN];\nint pos[maxN];\nint inv[2][maxN];\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cin >> n;\n    for (int i = 0; i < 2; i++) {\n        pw[i][0] = 1;\n        inv[i][0] = 1;\n        int inv_val = pww(pt[i], mod - 2);\n        for (int j = 1; j < maxN; j++) {\n            pw[i][j] = mult(pw[i][j - 1], pt[i]);\n            inv[i][j] = mult(inv[i][j - 1], inv_val);\n        }\n    }\n    const int SHIFT = maxN / 2;\n    int CUR = 0;\n    for (int i = 1; i <= n; i++) {\n        cin >> c[i];\n        for (int j = 0; j < 2; j++) {\n            hsh[j][i] = hsh[j][i - 1];\n        }\n        if (c[i] == '>') CUR++;\n        else if (c[i] == '<') CUR--;\n        else if (c[i] == '+') {\n            for (int j = 0; j < 2; j++) {\n                hsh[j][i] = sum(hsh[j][i], pw[j][CUR + SHIFT]);\n            }\n        }\n        else if (c[i] == '-') {\n            for (int j = 0; j < 2; j++) {\n                hsh[j][i] = sub(hsh[j][i], pw[j][CUR + SHIFT]);\n            }\n        }\n        else {\n            assert(false);\n        }\n        pos[i] = CUR;\n    }\n    //diff\n    map < pair < int, int >, int > mp;\n    ll ans = 0;\n    for (int suf = n; suf >= 1; suf--) {\n        mp[make_pair(hsh[0][suf], hsh[1][suf])]++;\n        int t[2] = {0, 0};\n        for (int j = 0; j < 2; j++) {\n            if (pos[suf - 1] >= 0) {\n                t[j] = sum(hsh[j][suf - 1], mult(hsh[j][n], pw[j][pos[suf - 1]]));\n            }\n            else {\n                t[j] = sum(hsh[j][suf - 1], mult(hsh[j][n], inv[j][-pos[suf - 1]]));\n            }\n        }\n        ans += mp[make_pair(t[0], t[1])];\n    }\n    cout << ans;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<map>\nusing namespace std;\nint k1[262144],b1[262144],k2[262144],b2[262144];\nchar s[262144];\nmap<long long,int> qaq;\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",s+1);\n\tk1[0]=1;\n\tb1[0]=0;\n\tk2[0]=1;\n\tb2[0]=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(s[i]=='+')\n\t\t{\n\t\t\tk1[i]=k1[i-1];\n\t\t\tb1[i]=b1[i-1]+k1[i-1];\n\t\t\tif(b1[i]>=998244353)\n\t\t\t{\n\t\t\t\tb1[i]-=998244353;\n\t\t\t}\n\t\t\tk2[i]=k2[i-1];\n\t\t\tb2[i]=b2[i-1]+k2[i-1];\n\t\t\tif(b2[i]>=1000000007)\n\t\t\t{\n\t\t\t\tb2[i]-=1000000007;\n\t\t\t}\n\t\t}\n\t\telse if(s[i]=='-')\n\t\t{\n\t\t\tk1[i]=k1[i-1];\n\t\t\tb1[i]=b1[i-1]-k1[i-1];\n\t\t\tif(b1[i]<0)\n\t\t\t{\n\t\t\t\tb1[i]+=998244353;\n\t\t\t}\n\t\t\tk2[i]=k2[i-1];\n\t\t\tb2[i]=b2[i-1]-k2[i-1];\n\t\t\tif(b2[i]<0)\n\t\t\t{\n\t\t\t\tb2[i]+=1000000007;\n\t\t\t}\n\t\t}\n\t\telse if(s[i]=='>')\n\t\t{\n\t\t\tk1[i]=(long long)k1[i-1]*19260817%998244353;\n\t\t\tb1[i]=b1[i-1];\n\t\t\tk2[i]=(long long)k2[i-1]*19491001%1000000007;\n\t\t\tb2[i]=b2[i-1];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tk1[i]=(long long)k1[i-1]*494863259%998244353;\n\t\t\tb1[i]=b1[i-1];\n\t\t\tk2[i]=(long long)k2[i-1]*301354971%1000000007;\n\t\t\tb2[i]=b2[i-1];\n\t\t}\n\t}\n\tlong long ans=0;\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tans+=qaq[(long long)b1[i]*1000000007+b2[i]];\n\t\tint val1=((long long)k1[i]*b1[n]+b1[i])%998244353;\n\t\tint val2=((long long)k2[i]*b2[n]+b2[i])%1000000007;\n\t\tqaq[(long long)val1*1000000007+val2]++;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\n\ntypedef long long LL;\nconst int Mod[3] = {999988679, 999988609, 999988589};\nconst int B[3] = {370728, 370732, 370729};\nconst int iB[3] = {396903752, 462741403, 834141573};\nconst int MN = 250005;\n\ninline void Add(int &x, int y, int i) { x -= (x += y) >= Mod[i] ? Mod[i] : 0; }\n\ntypedef std::tuple<int, int, int> i3;\n\nint N;\nchar S[MN];\nint A[3][MN], D[3][MN];\nstd::map<i3, int> Buk;\nLL Ans;\n\nint main() {\n\tscanf(\"%d%s\", &N, S + 1);\n\tfor (int j = 0; j < 3; ++j) A[j][0] = 0, D[j][0] = 1;\n\tfor (int i = 1, V[3] = {1, 1, 1}; i <= N; ++i) {\n\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\tA[j][i] = A[j][i - 1];\n\t\t\tif (S[i] == '+') Add(A[j][i], V[j], j);\n\t\t\tif (S[i] == '-') Add(A[j][i], Mod[j] - V[j], j);\n\t\t\tif (S[i] == '>') V[j] = (LL)V[j] * B[j] % Mod[j];\n\t\t\tif (S[i] == '<') V[j] = (LL)V[j] * iB[j] % Mod[j];\n\t\t\tD[j][i] = V[j];\n\t\t}\n\t}\n\tfor (int i = N; i >= 0; --i) {\n\t\tAns += Buk[std::make_tuple(\n\t\t\t(A[0][i] + (LL)A[0][N] * D[0][i]) % Mod[0],\n\t\t\t(A[1][i] + (LL)A[1][N] * D[1][i]) % Mod[1],\n\t\t\t(A[2][i] + (LL)A[2][N] * D[2][i]) % Mod[2]\n\t\t)];\n\t\t++Buk[std::make_tuple(A[0][i], A[1][i], A[2][i])];\n\t}\n\tprintf(\"%lld\\n\", Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\nusing namespace std;\ntypedef long long ll;\n#define GG puts(\"FUCK\")\n#define N 500050\n#define mr(x,y) make_pair(x,y)\ninline char nc() {\n\tstatic char buf[100000],*p1,*p2;\n\treturn p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\nint rd() {\n\tint x=0; char s=nc();\n\twhile(s<'0'||s>'9') s=nc();\n\twhile(s>='0'&&s<='9') x=(x<<3)+(x<<1)+s-'0',s=nc();\n\treturn x;\n}\nchar rc() {\n\tchar s=nc();\n\twhile(s!='+'&&s!='-'&&s!='>'&&s!='<') s=nc();\n\treturn s;\n}\nint mod1=998244353,base1=19260817,inv1;\nint mod2=353448299,base2=20000003,inv2;\nint h1[N],mi1[N],imi1[N],p[N],n,C;\nint h2[N],mi2[N],imi2[N];\nmap<pair<int,int>,int>mp;\nint qp(int x,int y,int p) {\n\tint re=1;\n\tfor(;y;y>>=1,x=ll(x)*x%p) if(y&1) re=ll(re)*x%p;\n\treturn re;\n}\nint main() {\n\tinv1=qp(base1,mod1-2,mod1);\n\tinv2=qp(base2,mod2-2,mod2);\n\tn=rd(); char str;\n\tint i;\n\tfor(mi1[0]=imi1[0]=mi2[0]=imi2[0]=i=1;i<=(n<<1);i++) {\n\t\tmi1[i]=ll(mi1[i-1])*base1%mod1;\n\t\timi1[i]=ll(imi1[i-1])*inv1%mod1;\n\t\tmi2[i]=ll(mi2[i-1])*base2%mod2;\n\t\timi2[i]=ll(imi2[i-1])*inv2%mod2;\n\t}\n\tp[0]=n;\n\tfor(i=1;i<=n;i++) {\n\t\tstr=rc();\n\t\tif(str=='+') {\n\t\t\tp[i]=p[i-1];\n\t\t\th1[i]=(h1[i-1]+mi1[p[i]])%mod1;\n\t\t\th2[i]=(h2[i-1]+mi2[p[i]])%mod2;\n\t\t}else if(str=='-') {\n\t\t\tp[i]=p[i-1];\n\t\t\th1[i]=(h1[i-1]-mi1[p[i]]+mod1)%mod1;\n\t\t\th2[i]=(h2[i-1]-mi2[p[i]]+mod2)%mod2;\n\t\t}else if(str=='>') {\n\t\t\tp[i]=p[i-1]+1;\n\t\t\th1[i]=h1[i-1]; h2[i]=h2[i-1];\n\t\t}else {\n\t\t\tp[i]=p[i-1]-1;\n\t\t\th1[i]=h1[i-1]; h2[i]=h2[i-1];\n\t\t}\n\t\tmp[mr(h1[i],h2[i])]++;\n\t}\n\tll ans=0;\n\tfor(i=1;i<=n;i++) {\n\t\tint d=p[i-1]-n,t1=h1[n],t2=h2[n];\n\t\tif(d>=0) t1=ll(t1)*mi1[d]%mod1,t2=ll(t2)*mi2[d]%mod2;\n\t\telse t1=ll(t1)*imi1[-d]%mod1,t2=ll(t2)*imi2[-d]%mod2;\n\t\tt1=(t1+h1[i-1])%mod1;\n\t\tt2=(t2+h2[i-1])%mod2;\n\t\tans+=mp[mr(t1,t2)];\n\t\tmp[mr(h1[i],h2[i])]--;\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << (x) << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\nusing P = pair<int,int>;\ntemplate<unsigned long long mod_>\nstruct ModInt{\n\tusing uint = unsigned long long;\n\tusing ll = __int128;\n\tusing ull =__int128;\n\n\tconstexpr static uint mod = mod_;\n\n\tuint v;\n\tModInt():v(0){}\n\tModInt(ll v):v(normS(v%mod+mod)){}\n\texplicit operator bool() const {return v!=0;}\n\tstatic uint normS(const uint &x){return (x<mod)?x:x-mod;}\t\t// [0 , 2*mod-1] -> [0 , mod-1]\n\tstatic ModInt make(const uint &x){ModInt m; m.v=x; return m;}\n\tModInt operator+(const ModInt& b) const { return make(normS(v+b.v));}\n\tModInt operator-(const ModInt& b) const { return make(normS(v+mod-b.v));}\n\tModInt operator-() const { return make(normS(mod-v)); }\n\tModInt operator*(const ModInt& b) const { return make((ull)v*b.v%mod);}\n\tModInt operator/(const ModInt& b) const { return *this*b.inv();}\n\tModInt& operator+=(const ModInt& b){ return *this=*this+b;}\n\tModInt& operator-=(const ModInt& b){ return *this=*this-b;}\n\tModInt& operator*=(const ModInt& b){ return *this=*this*b;}\n\tModInt& operator/=(const ModInt& b){ return *this=*this/b;}\n\tll extgcd(ll a,ll b,ll &x,ll &y) const{\n\t\tll u[]={a,1,0},v[]={b,0,1};\n\t\twhile(*v){\n\t\t\tll t=*u/ *v;\n\t\t\trep(i,3) swap(u[i]-=t*v[i],v[i]);\n\t\t}\n\t\tif(u[0]<0) rep(i,3) u[i]=-u[i];\n\t\tx=u[1],y=u[2];\n\t\treturn u[0];\n\t}\n\tModInt inv() const{\n\t\tll x,y;\n\t\textgcd(v,mod,x,y);\n\t\treturn make(normS(x+mod));\n\t}\n\tbool operator==(const ModInt& b) const { return v==b.v;}\n\tbool operator!=(const ModInt& b) const { return v!=b.v;}\n//\tfriend istream& operator>>(istream &o,ModInt& x){\n//\t\tll tmp;\n//\t\to>>tmp;\n//\t\tx=ModInt(tmp);\n//\t\treturn o;\n//\t}\n//\tfriend ostream& operator<<(ostream &o,const ModInt& x){ return o<<x.v;}\n};\nusing mint = ModInt<1000000000000000003ULL>;\nconst mint B = 998244353;\nmint ex(int p){\n\tbool m = 0;\n\tif(p<0){\n\t\tp = -p;\n\t\tm = 1;\n\t}\n\tmint a = 1;\n\tmint x = B;\n\twhile(p){\n\t\tif(p%2==1) a *= x;\n\t\tx *= x;\n\t\tp/=2;\n\t}\n\tif(m) a = (mint)1/a;\n\treturn a;\n}\n\nusing ll = long long;\nint N;\nstring s;\n\nint main(){\n\tcin>>N>>s;\n\tmint H = 0;\n\t{\n\t\tmap<int,int> cnt;\n\t\tint x = 0;\n\t\trep(i,N){\n\t\t\tif(s[i]=='+') cnt[x]++;\n\t\t\tif(s[i]=='-') cnt[x]--;\n\t\t\tif(s[i]=='<') x--;\n\t\t\tif(s[i]=='>') x++;\n\t\t}\n\t\tfor(P p:cnt){\n\t\t\tint x = p.fs, v = p.sc;\n\t\t\tH += ex(x) * v;\n\t\t}\n\t}\n\tmint a = 1, b = 0;\n\tll ans = 0;\n\t\n\tmap<long long,int> mp;\n\tmp[0] = 1;\n\tfor(int i=N-1;i>=0;i--){\n\t\tmint na,nb;\n\t\tif(s[i]=='+'){\n\t\t\tna = a, nb = b+1;\n\t\t}\n\t\tif(s[i]=='-'){\n\t\t\tna = a, nb = b-1;\n\t\t}\n\t\tif(s[i]=='<'){\n\t\t\tna = a/B, nb = b/B;\n\t\t}\n\t\tif(s[i]=='>'){\n\t\t\tna = a*B, nb = b*B;\n\t\t}\n\t\ta = na, b = nb;\n\t\tmint H_false = (H-b)/a;\n\t\tans += mp[H_false.v];\n\t\tmp[(-b/a).v]++;\n\t}\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//ΔARC099F\n#include<iostream>\n#include<cstdio>\n#include<fstream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<bitset>\n#include<cmath>\n#include<cstring>\n#include<cstdlib>\nusing namespace std;\ntypedef long long LL;\ntypedef double DB;\nconst int N = 266666;\nconst int B = 19260817;\nconst int MO = 1e9+21;\nconst int M2 = 998244353;\nint fpow(int x,int y,int mo){\n\tif(!y)\n\t\treturn 1;\n\tLL z=fpow(x,y>>1,mo);\n\tz=z*z%mo;\n\tif(y&1)\n\t\tz=z*x%mo;\n\treturn z;\n}\nint invB=fpow(B,MO-2,MO),invB2=fpow(B,M2-2,M2);\nchar ch[N];\nint n,a[N],f[N],f2[N],g[N],g2[N];\nmap<LL,int> M;\nint main()\n{\n\tint i,x,x2,y,y2;\n\tLL ans=0;\n\tcin>>n;\n\tscanf(\"%s\",ch+1);\n\tfor(i=1;i<=n;i=i+1){\n\t\tif(ch[i]=='-')\n\t\t\ta[i]=0;\n\t\tif(ch[i]=='+')\n\t\t\ta[i]=1;\n\t\tif(ch[i]=='<')\n\t\t\ta[i]=2;\n\t\tif(ch[i]=='>')\n\t\t\ta[i]=3;\n\t}\n\tx=0;\n\tfor(i=n;i;i=i-1){\n\t\tif(a[i]==0)\n\t\t\tx=(x-1+MO)%MO;\n\t\tif(a[i]==1)\n\t\t\tx=(x+1)%MO;\n\t\tif(a[i]==2)\n\t\t\tx=(LL)x*invB%MO;\n\t\tif(a[i]==3)\n\t\t\tx=(LL)x*B%MO;\n\t\tf[i]=x;\n\t}\n\tx=0;\n\tfor(i=n;i;i=i-1){\n\t\tif(a[i]==0)\n\t\t\tx=(x-1+M2)%M2;\n\t\tif(a[i]==1)\n\t\t\tx=(x+1)%M2;\n\t\tif(a[i]==2)\n\t\t\tx=(LL)x*invB2%M2;\n\t\tif(a[i]==3)\n\t\t\tx=(LL)x*B%M2;\n\t\tf2[i]=x;\n\t}\n\tx=0,y=1;\n\tfor(i=n;i;i=i-1){\n\t\tif(a[i]==0)\n\t\t\tx=(x+y)%MO;\n\t\tif(a[i]==1)\n\t\t\tx=(x-y+MO)%MO;\n\t\tif(a[i]==2)\n\t\t\ty=(LL)y*B%MO;\n\t\tif(a[i]==3)\n\t\t\ty=(LL)y*invB%MO;\n\t\tg[i]=x;\n\t}\n\tx=0,y2=1;\n\tfor(i=n;i;i=i-1){\n\t\tif(a[i]==0)\n\t\t\tx=(x+y2)%M2;\n\t\tif(a[i]==1)\n\t\t\tx=(x-y2+M2)%M2;\n\t\tif(a[i]==2)\n\t\t\ty2=(LL)y2*B%M2;\n\t\tif(a[i]==3)\n\t\t\ty2=(LL)y2*invB2%M2;\n\t\tg2[i]=x;\n\t}\n\tfor(i=0;i<=n;i=i+1)\n\t\tM[(LL)g[i]<<32|g2[i]]++;\n\tfor(i=1;i<=n;i=i+1){\n\t\tM[(LL)g[i]<<32|g2[i]]--;\n\t\tx=(f[1]-f[i]+MO)%MO;\n\t\tx=(LL)x*y%MO;\n\t\tx2=(f2[1]-f2[i]+M2)%M2;\n\t\tx2=(LL)x2*y2%M2;\n\t\tans+=M[(LL)x<<32|x2];\n\t\tif(a[i]==2)\n\t\t\ty=(LL)y*invB%MO;\n\t\tif(a[i]==3)\n\t\t\ty=(LL)y*B%MO;\n\t\tif(a[i]==3)\n\t\t\ty2=(LL)y2*B%M2;\n\t\tif(a[i]==2)\n\t\t\ty2=(LL)y2*invB2%M2;\n\t}\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\nconst int   N   = 5e5 + 1;\nconst int   B   = 1e8 + 1;\n\ntypedef pair<int,int>   ii;\ntypedef pair<ii,ii>     pii;\n\nint qpow(int a,int exp,int mod) {\n    if(exp < 0) exp = mod - 1 - exp;\n    int ans = 1;\n    while (exp) {\n        if(exp & 1) ans = ans * a % mod;\n        a = a * a % mod;  exp >>= 1;\n    }\n    return ans;\n}\n\nvoid add(int &a,int b,int mod) {\n    a += b;\n    if(a >= mod)a -= mod;\n    if(a < 0)   a += mod;\n}\n\nint mod[4];\nint n, f[N];\nint H[N][4];\nstring S;\n\nvoid process(int t)   {\n    for(int i = 1 ; i <= n ; ++i)   {\n        H[i][t] = H[i - 1][t];\n        if(S[i - 1] == '+') add(H[i][t], qpow(B,f[i],mod[t]),mod[t]);\n        if(S[i - 1] == '-') add(H[i][t],-qpow(B,f[i],mod[t]),mod[t]);\n    }\n}\n\nmap<pii,int> mp;\n\nsigned main()   {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    cin >> n >> S;\n\n    for(int i = 0 ; i < n ; ++i)    {\n        f[i + 1] = f[i];\n        if(S[i] == '>') f[i + 1]++;\n        if(S[i] == '<') f[i + 1]--;\n    }\n\n    mod[0] = 1e9 + 7;\n    mod[1] = 1e9 + 9;\n    mod[2] = 1e9 + 21;\n    mod[3] = 1e9 + 33;\n\n    process(0);\n    process(1);\n    process(2);\n    process(3);\n\n    mp[pii({H[n][0],H[n][1]},{H[n][2],H[n][3]})] = 1;\n\n    int ans = 0;\n\n    for(int i = 1 ; i <= n ; ++i)   {\n        ans += mp[pii({H[i][0],H[i][1]},{H[i][2],H[i][3]})];\n        int res0 = H[n][0] * qpow(B,f[i],mod[0]) + H[i][0];\n        int res1 = H[n][1] * qpow(B,f[i],mod[1]) + H[i][1];\n        int res2 = H[n][2] * qpow(B,f[i],mod[2]) + H[i][2];\n        int res3 = H[n][3] * qpow(B,f[i],mod[3]) + H[i][3];\n        res0 %= mod[0]; res1 %= mod[1];\n        res2 %= mod[2]; res3 %= mod[3];\n        mp[pii({res0,res1},{res2,res3})]++;\n    }\n\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <iostream>\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define debug(x) cout<<#x<<\" :: \"<<x<<endl;\n#define debug2(x,y) cout<<#x<<\" :: \"<<x<<\"\\t\"<<#y<<\" :: \"<<y<<endl;\n#define debug3(x,y,z) cout<<#x<<\" :: \"<<x<<\"\\t\"<<#y<<\" :: \"<<y<<\"\\t\"<<#z<<\" :: \"<<z<<endl;\n\n#define boost ios::sync_with_stdio(0); cin.tie(0)\n\n#define fi first\n#define se second\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double ld;\ntypedef pair<int, int> pii;\n\nconst int X = 250000 + 5;\nconst int N = 1e6 + 5;\nconst ull B = 545;\null invB;\n\n/***************************************************************************/\n\null power(ull a, ull n) {\n\tif(n == 0) return 1;\n\tull p = power(a, n>>1);\n\tp = p * p;\n\tif(n & 1) p = p * a;\n\treturn p;\n}\n\nstring S;\null powB[N];\n\ninline ull& pow(int n) {\n\tif(n < 0) n += N;\n\treturn powB[n];\n}\n\nmap<ull, int> M;\n\nint main() {\n\n\tboost;\n\tinvB = power(B, (ull(1)<<63)-1);\n\tassert(B * invB == 1);\n\n\tpow(0) = 1;\n\tfor(int i=1; i<X; i++) {\n\t\tpow(i) = pow(i-1) * B;\n\t\tpow(-i) = pow(-i+1) * invB;\n\t}\n\n\tint n; cin>>n;\n\tcin>>S;\n\n\tull phas = 0, chas = 0;\n\n\tint p = 0;\n\tfor(auto it : S) {\n\t\tif(it == '+') phas += pow(p);\n\t\telse if(it == '-') phas -= pow(p);\n\t\telse if(it == '>') p++;\n\t\telse p--;\n\t}\n\n\tll ans = 0;\n\tM[phas]++;\n\tp = 0;\n\n\tfor(auto it : S) {\n\t\tif(it == '+') chas += pow(p);\n\t\telse if(it == '-') chas -= pow(p);\n\t\telse if(it == '>') p++;\n\t\telse p--;\n\n\t\tans += M[chas];\n\t\tM[chas + pow(p) * phas]++;\n\t}\n\n\tcout<<ans<<\"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n\nLL inv(LL a , LL p){\n\tLL ret = 1;\n\tfor(LL i = p-2 ; i ; i /= 2){\n\t\tif(i&1) (ret *= a) %= p;\n\t\ta = a * a % p;\n\t}\n\treturn ret;\n}\n\nconst int RH_prime = 3;\nconst LL RH_mod[] = {1000000007,1000000021,1000000033};\nconst LL base = 314159;\n\nstruct RH{\n\tint n;\n\tvector<LL> hash[RH_prime];\n\tvector<LL> pw[RH_prime];\n\t\n\tRH(){n=0;}\n\tRH(const string &s){\n\t\tn = (int)s.size();\n\t\tfor(int i = 0 ; i < RH_prime ; ++i){\n\t\t\thash[i].push_back(0);\n\t\t\tpw[i].push_back(1);\n\t\t\tfor(int j = 0 ; j < n ; ++j){\n\t\t\t\tif(s[j] == '+' || s[j] == '-'){\n\t\t\t\t\thash[i].push_back((hash[i][j] + (s[j]=='-'?RH_mod[i]-pw[i][j]:pw[i][j])) % RH_mod[i]);\n\t\t\t\t\tpw[i].push_back(pw[i][j]);\n\t\t\t\t} else {\n\t\t\t\t\thash[i].push_back(hash[i][j]);\n\t\t\t\t\tpw[i].push_back(pw[i][j] * (s[j]=='>'?base:inv(base,RH_mod[i])) % RH_mod[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\nint main(){\n\tint N; cin >> N;\n\tstring S; cin >> S;\n\tRH rh(S);\n\tmap<tuple<LL,LL,LL>,int> M;\n\tLL ans = 0;\n\trepm(i,N,0){\n\t\t++M[{rh.hash[0][i],rh.hash[1][i],rh.hash[2][i]}];\n\t\ttuple<LL,LL,LL> z = {(rh.hash[0][N]*rh.pw[0][i-1]+rh.hash[0][i-1])%RH_mod[0],\n\t\t\t\t\t\t\t (rh.hash[1][N]*rh.pw[1][i-1]+rh.hash[1][i-1])%RH_mod[1],\n\t\t\t\t\t\t\t (rh.hash[2][N]*rh.pw[2][i-1]+rh.hash[2][i-1])%RH_mod[2]};\n\t\tans += M[z];\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nconstexpr int P = 998244353;\nconstexpr int BASE[] {19260817, 20030912, 19491001, 114514, 1919810};\nconstexpr int INV_BASE[] {494863259, 434508607, 157440299, 137043501, 595887626};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    string s;\n    cin >> n >> s;\n    vector<vector<int>> a(n + 1);\n    vector<vector<int>> b(n + 1);\n    for (int i = 0; i <= n; ++i) {\n        a[i].resize(5);\n        b[i].resize(5);\n    }\n    for (int j = 0; j < 5; ++j) {\n        int c = 0;\n        for (int i = n - 1; i >= 0; --i) {\n            switch (s[i]) {\n                case '+' :\n                    c = (c + 1) % P;\n                    break;\n                case '-':\n                    c = (c - 1 + P) % P;\n                    break;\n                case '>':\n                    c = 1LL * c * BASE[j] % P;\n                    break;\n                case '<':\n                    c = 1LL * c * INV_BASE[j] % P;\n                    break;\n            }\n        }\n        auto calc = [&](vector<vector<int>> &a, int c) {\n            a[n][j] = c;\n            int k = 1, b = 0;\n            for (int i = n - 1; i >= 0; --i) {\n                switch (s[i]) {\n                    case '+' :\n                        b = (b - k + P) % P;\n                        break;\n                    case '-':\n                        b = (b + k) % P;\n                        break;\n                    case '>':\n                        k = 1LL * k * INV_BASE[j] % P;\n                        break;\n                    case '<':\n                        k = 1LL * k * BASE[j] % P;\n                        break;\n                }\n                a[i][j] = (1LL * k * c + b) % P;\n            }\n        };\n        calc(a, c);\n        calc(b, 0);\n    }\n    LL ans = 0;\n    map<vector<int>, int> cnt;\n    for (int i = 0; i <= n; ++i) {\n        ans += cnt[b[i]];\n        ++cnt[a[i]];\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define p1 19260817\n#define p2 19491001\n#define m1 666623333\n#define m2 1004535809\nusing namespace std;\nint head[1048577],nxt[500005],tot=0;\nint w1[500005],w2[500005],w[500005];\nint a1[250005],b1[250005];\nint a2[250005],b2[250005];\nchar s[250005];\nll ans=0;\ninline int qpow(int a,int b,int mod)\n{int res=1,tp=a;\nwhile (b)\n{if (b&1) res=1ll*res*tp%mod;\ntp=1ll*tp*tp%mod;b>>=1;\n}\nreturn res;\n}\ninline void add(int v1,int v2)\n{int bel=((v1&1023)<<10)|(v2&1023),i;\nfor (i=head[bel];i;i=nxt[i])\n{if (w1[i]==v1&&w2[i]==v2) {w[i]++;return;}\n}\ntot++;nxt[tot]=head[bel];head[bel]=tot;\nw1[tot]=v1;w2[tot]=v2;w[tot]=1;\n}\ninline int ask(int v1,int v2)\n{int bel=((v1&1023)<<10)|(v2&1023),i;\nfor (i=head[bel];i;i=nxt[i])\n{if (w1[i]==v1&&w2[i]==v2) return w[i];\n}\nreturn 0;\n}\ninline int sub1(int a,int b)\n{return (a-b<0?a-b+m1:a-b);}\ninline int sub2(int a,int b)\n{return (a-b<0?a-b+m2:a-b);}\ninline int add1(int a,int b)\n{return (a+b>=m1?a+b-m1:a+b);}\ninline int add2(int a,int b)\n{return (a+b>=m2?a+b-m2:a+b);}\nint main (){\n\tint i,n,x1=0,x2=0;\n\tscanf (\"%d\",&n);\n\tscanf (\"%s\",s+1);\n\ta1[n+1]=1;b1[n+1]=0;\n\ta2[n+1]=1;b2[n+1]=0;\n\tint inv1=qpow(p1,m1-2,m1);\n\tint inv2=qpow(p2,m2-2,m2);\n\tfor (i=n;i>=1;i--)\n\t{if (s[i]=='<') \n\t{a1[i]=1ll*a1[i+1]*p1%m1;\n\ta2[i]=1ll*a2[i+1]*p2%m2;\n\tb1[i]=b1[i+1];b2[i]=b2[i+1];\n\tcontinue;\n\t}\n\tif (s[i]=='>')\n\t{a1[i]=1ll*a1[i+1]*inv1%m1;\n\ta2[i]=1ll*a2[i+1]*inv2%m2;\n\tb1[i]=b1[i+1];b2[i]=b2[i+1];\n\tcontinue;\n\t}\n\tif (s[i]=='+')\n\t{b1[i]=sub1(b1[i+1],a1[i+1]);\n\tb2[i]=sub2(b2[i+1],a2[i+1]);\n\ta1[i]=a1[i+1];a2[i]=a2[i+1];\n\tcontinue;\n\t}\n\tb1[i]=add1(b1[i+1],a1[i+1]);\n\tb2[i]=add2(b2[i+1],a2[i+1]);\n\ta1[i]=a1[i+1];a2[i]=a2[i+1];\n\t}\n\tfor (i=n;i>=1;i--)\n\t{if (s[i]=='+') {x1=add1(x1,1);x2=add2(x2,1);continue;}\n\tif (s[i]=='-') {x1=sub1(x1,1);x2=sub2(x2,1);continue;}\n\tif (s[i]=='<') {x1=1ll*x1*inv1%m1;x2=1ll*x2*inv2%m2;continue;}\n\tx1=1ll*x1*p1%m1;x2=1ll*x2*p2%m2;\n\t}\n\tadd(0,0);\n\tfor (i=n;i>=1;i--)\n\t{int r1=(1ll*a1[i]*x1+b1[i])%m1;\n\tint r2=(1ll*a2[i]*x2+b2[i])%m2;\n\tans+=ask(r1,r2);\n\tadd(b1[i],b2[i]);\n\t}\n\tprintf (\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n    _____\n  .'     '.\n /  0   0  \\\n|     ^     |\n|  \\     /  |\n \\  '---'  /\n  '._____.'\n*/\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\nstruct chash\n{\n\tint operator()(int x) const\n\t{\n\t\tx ^= (x >> 20) ^ (x >> 12);\n\t\treturn x ^ (x >> 7) ^ (x >> 4);\n\t}\n};\n\ntemplate<typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename U> using hashtable = gp_hash_table<T, U, chash>;\nrandom_device(rd);\nmt19937 rng(rd());\n\ntemplate<class T>\nvoid readi(T &x)\n{\n\tT input = 0;\n\tbool negative = false;\n\tchar c = ' ';\n\twhile (c < '-')\n\t{\n\t\tc = getchar();\n\t}\n\tif (c == '-')\n\t{\n\t\tnegative = true;\n\t\tc = getchar();\n\t}\n\twhile (c >= '0')\n\t{\n\t\tinput = input * 10 + (c - '0');\n\t\tc = getchar();\n\t}\n\tif (negative)\n\t{\n\t\tinput = -input;\n\t}\n\tx = input;\n}\ntemplate<class T>\nvoid printi(T output)\n{\n\tif (output == 0)\n\t{\n\t\tputchar('0');\n\t\treturn;\n\t}\n\tif (output < 0)\n\t{\n\t\tputchar('-');\n\t\toutput = -output;\n\t}\n\tint aout[20];\n\tint ilen = 0;\n\twhile(output)\n\t{\n\t\taout[ilen] = ((output % 10));\n\t\toutput /= 10;\n\t\tilen++;\n\t}\n\tfor (int i = ilen - 1; i >= 0; i--)\n\t{\n\t\tputchar(aout[i] + '0');\n\t}\n\treturn;\n}\ntemplate<class T>\nvoid ckmin(T &a, T b)\n{\n\ta = min(a, b);\n}\ntemplate<class T>\nvoid ckmax(T &a, T b)\n{\n\ta = max(a, b);\n}\ntemplate<class T, class U>\nT nmod(T &x, U mod)\n{\n\tif (x >= mod) x -= mod;\n}\ntemplate<class T>\nT randomize(T mod)\n{\n\treturn (uniform_int_distribution<T>(0, mod - 1))(rng);\n}\n\n#define y0 ___y0\n#define y1 ___y1\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fi first\n#define se second\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\nconst long double PI = 4.0 * atan(1.0);\nconst long double EPS = 1e-10;\n\n#define MAGIC 347\n#define SINF 10007\n#define CO 1000007\n#define INV 124982126\n#define INF 1000000007\n#define BIG 1000000931\n#define LARGE 1696969696967ll\n#define GIANT 2564008813937411ll\n#define LLINF 2696969696969696969ll\n#define MAXN 500013\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ld, ld> pdd;\n\nint N;\nint arr[MAXN];\nll S;\nll ans;\nmap<ll, int> freq, need;\n\nll expo(ll a, ll e)\n{\n\tif (e == 0)\n\t{\n\t\treturn 1;\n\t}\n\tll was = expo(a, e / 2);\n\tif (e % 2)\n\t{\n\t\treturn was * was % INF * a % INF;\n\t}\n\treturn was * was % INF;\n}\nll modinv(ll a)\n{\n\treturn expo(a, INF - 2);\n}\nvoid solve(int L, int R)\n{\n\tif (L == R)\n\t{\n\t\treturn;\n\t}\n\tfreq.clear(); need.clear();\n\tint mid = (L + R) >> 1;\n\t//start from L...mid, end at mid + 1....R\n\tpll trans = MP(1, 0);\n\tfor (int i = mid + 1; i <= R; i++)\n\t{\n\t\tif (arr[i] == 0)\n\t\t{\n\t\t\ttrans.fi *= INV;\n\t\t\ttrans.se *= INV;\n\t\t}\n\t\tif (arr[i] == 1)\n\t\t{\n\t\t\ttrans.fi *= CO;\n\t\t\ttrans.se *= CO;\n\t\t}\n\t\tif (arr[i] == 2)\n\t\t{\n\t\t\ttrans.se++;\n\t\t}\n\t\tif (arr[i] == 3)\n\t\t{\n\t\t\ttrans.se--; trans.se += INF;\n\t\t}\n\t\ttrans.fi %= INF;\n\t\ttrans.se %= INF;\n\t\t// cerr << \"from \" << mid + 1 << \" to \" << i << \" is \" << trans.fi << \"x + \" << trans.se << endl;\n\t\tll dif = S - trans.se + INF;\n\t\tnmod(dif, INF);\n\t\tdif *= modinv(trans.fi);\n\t\tdif %= INF;\n\t\tneed[dif]++;\n\t}\n\ttrans = MP(1, 0);\n\tfor (int i = mid; i >= L; i--)\n\t{\n\t\tif (arr[i] == 0)\n\t\t{\n\t\t\ttrans.fi *= INV;\n\t\t}\n\t\tif (arr[i] == 1)\n\t\t{\n\t\t\ttrans.fi *= CO;\n\t\t}\n\t\tif (arr[i] == 2)\n\t\t{\n\t\t\t//(x+1)*a+b = a * x + a + b\n\t\t\ttrans.se += trans.fi;\n\t\t}\n\t\tif (arr[i] == 3)\n\t\t{\n\t\t\t//(x - 1)*a + b = a*x - a + b\n\t\t\ttrans.se -= trans.fi;\n\t\t\ttrans.se += INF;\n\t\t}\n\t\ttrans.fi %= INF;\n\t\ttrans.se %= INF;\n\t\tfreq[trans.se]++;\n\t}\n\tfor (auto p : need)\n\t{\n\t\tll x = p.fi; int c = p.se;\n\t\tans += 1ll * c * freq[x];\n\t}\n\tsolve(L, mid);\n\tsolve(mid + 1, R);\n}\n\nint32_t main()\n{\n\tios_base::sync_with_stdio(0);\n\t// cout << fixed << setprecision(10);\n\t// cerr << fixed << setprecision(10);\n\t// freopen (\"file.in\", \"r\", stdin);\n\t// freopen (\"file.out\", \"w\", stdout);\n\tcin >> N;\n\tstring temps;\n\tcin >> temps;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (temps[i] == '<')\n\t\t{\n\t\t\tarr[i] = 0;\n\t\t}\n\t\tif (temps[i] == '>')\n\t\t{\n\t\t\tarr[i] = 1;\n\t\t}\n\t\tif (temps[i] == '+')\n\t\t{\n\t\t\tarr[i] = 2;\n\t\t}\n\t\tif (temps[i] == '-')\n\t\t{\n\t\t\tarr[i] = 3;\n\t\t}\n\t}\n\treverse(arr, arr + N);\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (arr[i] == 0)\n\t\t{\n\t\t\tS *= INV; S %= INF;\n\t\t\t// cerr << \"times \" << INV << endl;\n\t\t}\n\t\tif (arr[i] == 1)\n\t\t{\n\t\t\tS *= CO; S %= INF;\n\t\t\t// cerr << \"times \" << CO << endl;\n\t\t}\n\t\tif (arr[i] == 2)\n\t\t{\n\t\t\tS++; nmod(S, INF);\n\t\t\t// cerr << \"add 1\\n\";\n\t\t}\n\t\tif (arr[i] == 3)\n\t\t{\n\t\t\tS--; S += INF; nmod(S, INF);\n\t\t\t// cerr << \"add -1\\n\";\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (arr[i] == 0)\n\t\t{\n\t\t\tif (S == 0) ans++;\n\t\t}\n\t\tif (arr[i] == 1)\n\t\t{\n\t\t\tif (S == 0) ans++;\n\t\t}\n\t\tif (arr[i] == 2)\n\t\t{\n\t\t\tif (S == 1) ans++;\n\t\t}\n\t\tif (arr[i] == 3)\n\t\t{\n\t\t\tif (S == INF - 1) ans++;\n\t\t}\n\t}\n\t// for (int i = 0; i < N; i++)\n\t// {\n\t// \tll val = 0;\n\t// \tfor (int j = i; j < N; j++)\n\t// \t{\n\t// \t\tif (arr[j] == 0)\n\t// \t\t{\n\t// \t\t\tval *= INV; val %= INF;\n\t// \t\t}\n\t// \t\tif (arr[j] == 1)\n\t// \t\t{\n\t// \t\t\tval *= CO; val %= INF;\n\t// \t\t}\n\t// \t\tif (arr[j] == 2)\n\t// \t\t{\n\t// \t\t\tval++; nmod(val, INF);\n\t// \t\t}\n\t// \t\tif (arr[j] == 3)\n\t// \t\t{\n\t// \t\t\tval--; val += INF; nmod(val, INF);\n\t// \t\t}\n\t// \t\tif (val == S)\n\t// \t\t{\n\t// \t\t\tans++;\n\t// \t\t}\n\t// \t}\n\t// }\n\tsolve(0, N - 1);\n\tcout << ans << '\\n';\n\t//when u <, the # divides by co\n\t//when u >, the # mults by co\n\t//when u +, u add the #\n\t//when u -, u subtract the #\n\t// cerr << \"time elapsed = \" << (clock() / (CLOCKS_PER_SEC / 1000)) << \" ms\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//teja349\n#include <bits/stdc++.h>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <utility>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <iomanip> \n//setbase - cout << setbase (16); cout << 100 << endl; Prints 64\n//setfill -   cout << setfill ('x') << setw (5); cout << 77 << endl; prints xxx77\n//setprecision - cout << setprecision (14) << f << endl; Prints x.xxxx\n//cout.precision(x)  cout<<fixed<<val;  // prints x digits after decimal in val\n\nusing namespace std;\n#define f(i,a,b) for(i=a;i<b;i++)\n#define rep(i,n) f(i,0,n)\n#define fd(i,a,b) for(i=a;i>=b;i--)\n#define pb push_back\n#define mp make_pair\n#define vi vector< int >\n#define vl vector< ll >\n#define ss second\n#define ff first\n#define ll long long\n#define pii pair< int,int >\n#define pll pair< ll,ll >\n#define sz(a) a.size()\n#define inf (1000*1000*1000+5)\n#define all(a) a.begin(),a.end()\n#define tri pair<int,pii>\n#define vii vector<pii>\n#define vll vector<pll>\n#define viii vector<tri>\n#define mod (1000*1000*1000+9)\n#define mod1 (1000*1000*1000+7)\n#define pqueue priority_queue< int >\n#define pdqueue priority_queue< int,vi ,greater< int > >\n\n//std::ios::sync_with_stdio(false);   \nll ans10[512345],ans13[512345],powe13[512345],powe10[512345],invpowe10[512345];\nll invpowe13[512345],inv[1234],p[512345];\nll extend_gcd(ll a,ll b,ll &x,ll &y){\n\tif(b==0){\n\t\tx=1;\n\t\ty=0;\n\t\treturn a;\n\t}\n\tll x1,y1;\n\tll ans =extend_gcd(b,a%b,x1,y1);\n\tx=y1;\n\ty=x1-(a/b)*y1;\n\n\treturn ans;\n}\nmap<ll,ll> seti10,seti13; \nint main(){\n    std::ios::sync_with_stdio(false);\n    ll n;\n    cin>>n;\n    string s;\n    cin>>s;\n    ll i;\n    ll initp=250003;\n    powe10[0]=1;\n    powe13[0]=1;\n    invpowe10[0]=1;\n    invpowe13[0]=1;\n    ll inv10,inv13;\n\n            ll x,y;\n            i=503803;\n        ll val=extend_gcd(mod,i,x,y);\n        if(y>0)\n            inv13=y%mod;\n        else{\n                inv13=(y+mod)%mod;\n        }\n        x,y;\n            i=500167;\n        val=extend_gcd(mod1,i,x,y);\n        if(y>0)\n            inv10=y%mod1;\n        else{\n                inv10=(y+mod1)%mod1;\n        }    \n\tf(i,1,512345){\n    \tpowe13[i]=powe13[i-1]*503803;\n    \tpowe10[i]=powe10[i-1]*500167;\n    \tpowe10[i]%=mod1;\n    \tpowe13[i]%=mod;\n    \tinvpowe10[i]=invpowe10[i-1]*inv10;\n    \tinvpowe10[i]%=mod1;\n    \tinvpowe13[i]=invpowe13[i-1]*inv13;\n    \tinvpowe13[i]%=mod;\n    }\n    ans10[0]=0;\n    ans13[0]=0;\n    p[0]=initp;\n    \n    f(i,1,s.length()+1){\n    \tans10[i]=ans10[i-1];\n    \tans13[i]=ans13[i-1];\n    \tp[i]=p[i-1];\n    \tif(s[i-1]=='+'){\n    \t\tans10[i]=ans10[i-1]+powe10[p[i]];\n    \t\tans13[i]=ans13[i-1]+powe13[p[i]];\n\n    \t}\n    \telse if(s[i-1]=='-'){\n    \t\tans10[i]=ans10[i-1]-powe10[p[i]];\n    \t\tans13[i]=ans13[i-1]-powe13[p[i]];\n    \t}\n    \telse if(s[i-1]=='<'){\n    \t\tp[i]--;\n    \t}\n    \telse{\n    \t\tp[i]++;\n    \t}\n    \tans10[i]%=mod1;\n    \tans10[i]+=mod1;\n    \tans10[i]%=mod1;\n    \tans13[i]%=mod;\n    \tans13[i]+=mod;\n    \tans13[i]%=mod;\n    \tseti13[ans13[i]]++;\n    \tseti10[ans10[i]]++;\n    \t//cout<<ans10[i]<<\" \"<<ans13[i]<<endl;\n    }\n    ll val1,j10,j13;\n    ll total=0;\n    f(i,1,n+1){\n    \tval=initp-p[i-1];\n    \tval*=-1;\n    \tif(val>=0){\n    \t\tval1=powe13[val];\n    \t\tval=powe10[val];\n    \t\t  \n    \t}\n    \telse{\n    \t\tval1=invpowe13[val];\n    \t\tval=invpowe10[val];\n    \t}\n    \tj10=ans10[n]*val;\n    \tj10%=mod1;\n    \tj10+=ans10[i-1];\n    \tj13=ans13[n]*val1;\n    \tj13%=mod;\n    \tj13+=ans13[i-1];\n    \tj10%=mod1;\n    \tj13%=mod;\n    \ttotal+=min(seti10[j10],seti13[j13]);\n        //assert(seti10[j10]==seti13[j13]);\n    \tseti13[ans13[i]]--;\n    \tseti10[ans10[i]]--;\n    }\n    cout<<total<<endl;\n\n\n\n\n    return 0;  \n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int Mod = 1e9 + 7, Nmax = 5e5 + 5, Pow = 31;\ntypedef long long ll;\n\nint sP[Nmax], i, n, P, target;\nll Pw[Nmax], E[Nmax], R[Nmax], ans = 0, Inv, InvP[Nmax];\nmap<int, int> mp;\nchar a[Nmax];\n\n\nll power(ll a, int b)\n{\n    ll ans = 1;\n    while(b)\n    {\n        if(b&1) ans = ans * a % Mod;\n        b >>= 1; a = a*a%Mod;\n    }\n    return ans;\n}\n\nint main()\n{\n  //  freopen(\"input\", \"r\", stdin);\n //   freopen(\"output\", \"w\", stdout);\n    cin.sync_with_stdio(false);\n\n    cin >> n >> (a+1);\n\n    for(i=1; i<=n; ++i) sP[i] = sP[i-1] - (a[i] == '<') + (a[i] == '>');\n\n    Inv = power(Pow, Mod-2);\n    Pw[0] = 1; InvP[0] = 1;\n    for(i=1; i<=2*n; ++i) Pw[i] = Pw[i-1] * Pow % Mod, InvP[i] = InvP[i-1] * Inv % Mod;\n\n    P = n;\n    for(i=1; i<=n; ++i) /// for 1..,i\n    {\n        E[i] = E[i-1];\n        if(a[i] == '<')\n        {\n            --P;\n            continue;\n        }\n\n        if(a[i] == '>')\n        {\n            ++P;\n            continue;\n        }\n\n        if(a[i] == '-')\n            E[i] -= Pw[P];\n        else E[i] += Pw[P];\n\n        if(E[i] >= Mod) E[i] -= Mod;\n            else if(E[i] < 0) E[i] += Mod;\n    }\n\n    for(i=1; i<=n; ++i) /// reverse operations for 1...i, not signs\n    {\n        if(a[i] == '<')\n        {\n            R[i] = Pow * R[i-1] % Mod;\n            continue;\n        }\n\n        if(a[i] == '>')\n        {\n            R[i] = Inv * R[i-1] % Mod;\n            continue;\n        }\n\n        if(a[i] == '+') R[i] = R[i-1] + Pw[n];\n            else R[i] = R[i-1] - Pw[n];\n\n        if(R[i] >= Mod) R[i] -= Mod;\n            else if(R[i] < 0) R[i] += Mod;\n    }\n\n    for(i=n; i; --i)\n    {\n        ++mp[E[i]]; /// i becomes active\n\n        target = E[n] + R[i-1];\n        if(sP[i-1] >= 0) target = (ll) target * Pw[sP[i-1]] % Mod;\n            else target = (ll) target * InvP[-sP[i-1]] % Mod;\n\n        ans += mp[target];\n    }\n\n    cout << ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#include<map>\nusing namespace std;\nconst long long Mod=1000000007;\nconst long long base=1000003;\nint n;\nchar s[250010];\nlong long a[250010],b[250010];\nlong long fpow(long long a,long long b)\n{\n\tlong long ans=1,t=a;\n\twhile(b)\n\t{\n\t\tif(b&1)ans=ans*t%Mod;\n\t\tt=t*t%Mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nmap<long long,int>mp;\nint main()\n{\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",s+1);\n\tlong long x=0,y=0,invbase=fpow(base,Mod-2);\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tif(s[i]=='-')\n\t\t\tx=(x-1+Mod)%Mod;\n\t\telse if(s[i]=='+')\n\t\t\tx=(x+1)%Mod;\n\t\telse if(s[i]=='<')\n\t\t\tx=(x*base)%Mod;\n\t\telse x=x*invbase%Mod;\n\t}\n\tlong long c=x;\n\tx=1;y=0;\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tif(s[i]=='+')\n\t\t\ty=(y-x+Mod)%Mod;\n\t\telse if(s[i]=='-')\n\t\t\ty=(y+x)%Mod;\n\t\telse if(s[i]=='>')\n\t\t\tx=x*base%Mod;\n\t\telse x=x*invbase%Mod;\n\t\tb[i]=y;\n\t\ta[i]=(x*c+y)%Mod;\n\t}\n\tlong long ans=0;\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tmp[b[i+1]]++;\n\t\tans+=mp[a[i]];\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n// need\n#include <iostream>\n#include <algorithm>\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <unordered_map>\n#include <unordered_set>\n#include <array>\n// stream\n//#include <istream>\n#include <sstream>\n//#include <ostream>\n#include <fstream>\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest& ...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int w_=0; w_<n; ++w_){MACRO_VEC_ROW_Scan(w_, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest& ...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest& ...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& R:c)for(auto& w:R)std::cin>>w;\n// output\n#define OUT(dist) std::cout<<(dist);\n#define FOUT(n, dist) std::cout<<std::fixed<<std::setprecision(n)<<(dist);\n#define SOUT(n, c, dist) std::cout<<std::setw(n)<<std::setfill(c)<<(dist);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(w, n) std::cout<<(w + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(dist) {std::cerr << #dist << \"\\t:\" << (dist) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(w, a, n) for(int w=(a);w<(n);++w)\n#define RFOR(w, a, n) for(int w=(n)-1;w>=(a);--w)\n#define REP(w, n) for(int w=0;w<int(n);++w)\n#define RREP(w, n) for(int w=int(n)-1;w>=0;--w)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<class T> inline T CHMAX(T & a, const T b) { return a = (a < b) ? b : a; }\ntemplate<class T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\n//void CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n// test\ntemplate<class T> using V = std::vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n#define random_shuffle \"USE std::shuffle!\";\n\n// type/const\n//#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = (1 << 30) - 1;                    // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-10;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T & val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T & val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T> & a, const T & val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>> & a, const T & val) { for (auto& b : a) FILL(b, val); }\n// ------------>8------------------------------------->8------------\n\nll powMod(ll n, ll p, ll mod) {\n\tif (p < 0) p += mod - 1;\n\tn %= mod;\n\tll res = 1;\n\twhile (p) {\n\t\tif (p & 1) (res *= n) %= mod;\n\t\t(n *= n) %= mod;\n\t\tp >>= 1;\n\t}\n\treturn res;\n}\n\nconstexpr int N = 2;\nconstexpr ll M[N] = { 1000000009, 1000000021 };\nconstexpr ll B = 123457;\n\nstruct Hash {\n\tll val[N];\n\tHash& norm() {\n\t\tREP(i, N) if ((val[i] %= M[i]) < 0) val[i] += M[i];\n\t\treturn *this;\n\t}\n\n\tHash(ll x) { REP(i, N) val[i] = x; norm(); }\n\tHash() : Hash(0) {}\n\n\tstatic Hash makePow(ll n, ll p) {\n\t\tHash res;\n\t\tREP(i, N) res.val[i] = powMod(n, p, M[i]);\n\t\treturn res;\n\t}\n\n\tbool operator==(const Hash & r) const { return *this == r; }\n\tbool operator<(const Hash & r) const {\n\t\tREP(i, N) if (this->val[i] != r.val[i]) return this->val[i] < r.val[i];\n\t\treturn false;\n\t}\n\tHash& operator+=(const Hash & r) { REP(i, N) val[i] += r.val[i]; norm(); return *this; }\n\tHash& operator-=(const Hash & r) { REP(i, N) val[i] -= r.val[i]; norm(); return *this; }\n\tHash& operator*=(const Hash & r) { REP(i, N) val[i] *= r.val[i]; norm(); return *this; }\n};\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n);\n\tVAR(std::string, s);\n\n\tHash X;\n\t{\n\t\tint p = 0;\n\t\tREP(i, n) {\n\t\t\t/* */if (s[i] == '+') X += Hash::makePow(B, p);\n\t\t\telse if (s[i] == '-') X -= Hash::makePow(B, p);\n\t\t\telse if (s[i] == '>') ++p;\n\t\t\telse if (s[i] == '<') --p;\n\t\t}\n\t}\n\n\tstd::map<Hash, int> map;\n\t++map[X];\n\tll ans = 0;\n\tHash A;\n\t{\n\t\tint p = 0;\n\t\tREP(i, n) {\n\t\t\t/* */if (s[i] == '+') A += Hash::makePow(B, p);\n\t\t\telse if (s[i] == '-') A -= Hash::makePow(B, p);\n\t\t\telse if (s[i] == '>') ++p;\n\t\t\telse if (s[i] == '<') --p;\n\t\t\tans += map[A];\n\t\t\t{\n\t\t\t\tauto tX(X);\n\t\t\t\ttX *= Hash::makePow(B, p);\n\t\t\t\ttX += A;\n\t\t\t\t++map[tX];\n\t\t\t}\n\t\t}\n\t}\n\tOUT(ans)BR;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long D;\nconst int maxn=500005,mod1=1000000007,mod2=1000000009;\nint qpow(int x,int y,int mod){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1)ans=D(ans)*x%mod;\n\t\tx=D(x)*x%mod;\n\t\ty>>=1;\n\t}\n\treturn ans;\n}\nint n,temp[base+1];\nchar s[maxn];\nstruct H{\n\tint a,b;\n\tH():a(0),b(0){}\n\tH(int _a,int _b):a(_a),b(_b){}\n\tH operator+(const H &x)const{return H((a+x.a)%mod1,(b+x.b)%mod2);}\n\tH operator-(const H &x)const{return H((a-x.a+mod1)%mod1,(b-x.b+mod2)%mod2);}\n\tH operator*(const H &x)const{return H((D)a*x.a%mod1,(D)b*x.b%mod2);}\n\tbool operator<(const H &x)const{return a!=x.a?a<x.a:b<x.b;}\n}b,inv,f[maxn],g[maxn];\nmap<H,int> mp;\nint main(){\n\tb=H(23,29),inv=H(qpow(23,mod1-2,mod1),qpow(29,mod2-2,mod2));\n\tscanf(\"%d%s\",&n,s+1);\n\tg[0]=H(1,1);\n\tfor(int i=1;i<=n;i++){\n\t\tf[i]=f[i-1],g[i]=g[i-1];\n\t\tif(s[i]=='+')f[i]=f[i]+g[i];\n\t\tif(s[i]=='-')f[i]=f[i]-g[i];\n\t\tif(s[i]=='<')g[i]=g[i]*inv;\n\t\tif(s[i]=='>')g[i]=g[i]*b;\n\t\tmp[f[i]]++;\n\t}\n\tD ans=0;\n\tfor(int i=1;i<=n;i++){\n\t\tans+=mp[f[i-1]+g[i-1]*f[n]];\n\t\tmp[f[i]]--;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Love and Freedom.\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<map>\n#define ll long long\n#define inf 20021225\n#define N 250010\nusing namespace std;\nint read()\n{\n\tint s=0,t=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')\tt=-1; ch=getchar();}\n\twhile(ch>='0' && ch<='9')\ts=s*10+ch-'0',ch=getchar();\n\treturn s*t;\n}\nconst ll mdn = 1000000000000122571ll, bs = 2002122571ll, inv = 938258839498508531ll;\nll mul(ll a,ll b){return (__int128)a*b%mdn;}\nll add(ll a,ll b){return (__int128)(a+b)%mdn;}\nmap<ll,int> f; char ch[N]; ll ans,val[N],pos[N];\nint main()\n{\n\tint n=read(); scanf(\"%s\",ch+1); pos[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tpos[i]=pos[i-1],val[i]=val[i-1];\n\t\tif(ch[i]=='+')\tval[i]=add(val[i],pos[i]);\n\t\tif(ch[i]=='-')\tval[i]=add(val[i],mdn-pos[i]);\n\t\tif(ch[i]=='>')\tpos[i]=mul(pos[i],bs);\n\t\tif(ch[i]=='<')\tpos[i]=mul(pos[i],inv);\n\t}\n\tfor(int i=n;i;i--)\n\t{\n\t\tf[val[i]]++;\n\t\tans+=f[add(mul(val[n],pos[i-1]),val[i-1])];\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int N = 2e5 + 10;\nint mod1=998244353,base1=19260817,inv1;\nint mod2=353448299,base2=20000003,inv2;\nint s[N], pw1[N], pw2[N], rev1[N], rev2[N];\n\nint q_pow(int x, int y, int mod) {\n  int ans = 1;\n  for(; y; y >>= 1) {\n    if(y & 1) ans = 1ll * ans * x % mod;\n    x = 1ll * x * x % mod;\n  }\n  return ans;\n}\n\nint h1[N], h2[N];\ntypedef pair<int, int> P;\nmap<P, int> mp;\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  inv1 = q_pow(base1, mod1 - 2, mod1);\n  inv2 = q_pow(base2, mod2 - 2, mod2);\n  pw1[0] = pw2[0] = rev1[0] = rev2[0] = 1;\n  for(int i = 1; i <= (n << 1); ++i) {\n    pw1[i] = 1ll * pw1[i - 1] * base1 % mod1;\n    pw2[i] = 1ll * pw2[i - 1] * base2 % mod2;\n    rev1[i] = 1ll * rev1[i - 1] * inv1 % mod1;\n    rev2[i] = 1ll * rev2[i - 1] * inv2 % mod2;\n  }\n  s[0] = n;\n  for(int i = 1; i <= n; ++i) {\n    char ch; cin >> ch;\n    if(ch == '+') {\n      s[i] = s[i - 1];\n      h1[i] = (h1[i - 1] + pw1[s[i]]) % mod1;\n      h2[i] = (h2[i - 1] + pw2[s[i]]) % mod2;\n    } else if(ch == '-') {\n      s[i] = s[i - 1];\n      h1[i] = (h1[i - 1] - pw1[s[i]] + mod1) % mod1;\n      h2[i] = (h2[i - 1] - pw2[s[i]] + mod2) % mod2;\n    } else if(ch == '>') {\n      s[i] = s[i - 1] + 1;\n      h1[i] = h1[i - 1];\n      h2[i] = h2[i - 1];\n    } else {\n      s[i] = s[i - 1] - 1;\n      h1[i] = h1[i - 1];\n      h2[i] = h2[i - 1];\n    }\n    mp[P(h1[i], h2[i])]++;\n  }\n  ll ans = 0;\n  for(int i = 1; i <= n; ++i) {\n    int pos = h1[n], tmp = h2[n];\n    int sit = s[i - 1] - n;\n    if(sit >= 0) pos = 1ll * pos * pw1[sit] % mod1, tmp = 1ll * tmp * pw2[sit] % mod2;\n    else pos = 1ll * pos * rev1[-sit] % mod1, tmp = 1ll * tmp * rev2[-sit] % mod2;\n    pos = (pos + h1[i - 1]) % mod1;\n    tmp = (tmp + h2[i - 1]) % mod2;\n    ans += mp[P(pos, tmp)];\n    mp[P(h1[i], h2[i])]--;\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC target (\"avx2\")\n//#pragma GCC optimization (\"unroll-loops\")\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\nconst long double PI = 4*atan(1);\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<ld, ld> pd;\ntypedef complex<ld> cd;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<ld> vd;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\n#define f1r(i,a,b) for (int i = (a); i < (b); ++i)\n#define f0r(i,a) f1r(i,0,a)\n#define trav(a, x) for (auto& a : x)\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define sz(x) (int)(x).size()\n#define all(x) x.begin(), x.end()\n#define rall(x) rbegin(x), rend(x)\n#define resz resize\n#define rsz resize\n#define ins insert\n\ntemplate<typename A, typename B> ostream& operator<<(ostream &cout, pair<A, B> const &p) { return cout << \"(\" << p.f << \", \" << p.s << \")\"; }\ntemplate<typename A> ostream& operator<<(ostream &cout, vector<A> const &v) {\n  cout << \"[\"; for(int i = 0; i < v.size(); i++) {if (i) cout << \", \"; cout << v[i];} return cout << \"]\"; }\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return a > b ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n\nnamespace input {\n\ttemplate<class T> void re(complex<T>& x);\n\ttemplate<class T1, class T2> void re(pair<T1,T2>& p);\n\ttemplate<class T> void re(vector<T>& a);\n\ttemplate<class T, size_t SZ> void re(array<T,SZ>& a);\n\ttemplate<class T> void re(T& x) { cin >> x; }\n\tvoid re(double& x) { string t; re(t); x = stod(t); }\n\tvoid re(ld& x) { string t; re(t); x = stold(t); }\n\ttemplate<class T, class... Ts> void re(T& t, Ts&... ts) {\n\t\tre(t); re(ts...); }\n\ttemplate<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n\ttemplate<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n\ttemplate<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n\ttemplate<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n\tvoid pr(int x) { cout << x; }\n\tvoid pr(long x) { cout << x; }\n\tvoid pr(ll x) { cout << x; }\n\tvoid pr(unsigned x) { cout << x; }\n\tvoid pr(unsigned long x) { cout << x; }\n\tvoid pr(unsigned long long x) { cout << x; }\n\tvoid pr(float x) { cout << x; }\n\tvoid pr(double x) { cout << x; }\n\tvoid pr(ld x) { cout << x; }\n\tvoid pr(char x) { cout << x; }\n\tvoid pr(const char* x) { cout << x; }\n\tvoid pr(const string& x) { cout << x; }\n\tvoid pr(bool x) { pr(x ? \"true\" : \"false\"); }\n\ttemplate<class T> void pr(const complex<T>& x) { cout << x; }\n\ttemplate<class T1, class T2> void pr(const pair<T1,T2>& x);\n\ttemplate<class T> void pr(const T& x);\n\ttemplate<class T, class... Ts> void pr(const T& t, const Ts&... ts) {\n\t\tpr(t); pr(ts...); }\n\ttemplate<class T1, class T2> void pr(const pair<T1,T2>& x) {\n\t\tpr(\"{\",x.f,\", \",x.s,\"}\"); }\n\ttemplate<class T> void pr(const T& x) {\n\t\tpr(\"{\"); // const iterator needed for vector<bool>\n\t\tbool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0;\n\t\tpr(\"}\"); }\n\tvoid ps() { pr(\"\\n\"); } // print w/ spaces\n\ttemplate<class T, class... Ts> void ps(const T& t, const Ts&... ts) {\n\t\tpr(t); if (sizeof...(ts)) pr(\" \"); ps(ts...); }\n\tvoid pc() { pr(\"]\\n\"); } // debug w/ commas\n\ttemplate<class T, class... Ts> void pc(const T& t, const Ts&... ts) {\n\t\tpr(t); if (sizeof...(ts)) pr(\", \"); pc(ts...); }\n\t#ifdef TQIAN\n\t#define dbg(x...) pr(\"[\",#x,\"] = [\"), pc(x);\n\t#else\n\t#define dbg(x...) 0\n\t#endif\n}\n\nusing namespace output;\n\nnamespace io {\n\tvoid setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n\tvoid setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n\tvoid setIO(string s = \"\") {\n\t\tcin.sync_with_stdio(0); cin.tie(0); // fast I/O\n\t\t// cin.exceptions(cin.failbit); // ex. throws exception when you try to read letter into int\n\t\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n\t}\n}\n\nusing namespace io;\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());\n\nconst int MOD = 1e9 + 7;\n\ntypedef decay<decltype(MOD)>::type T;\nstruct mi {\n\tT val;\n\texplicit operator T() const { return val; }\n\tmi() { val = 0; }\n\tmi(const ll& v) {\n\t\tval = (-MOD <= v && v <= MOD) ? v : v % MOD;\n\t\tif (val < 0) val += MOD; }\n    friend ostream& operator<<(ostream& os, const mi& a) { return os << a.val; }\n\tfriend void pr(const mi& a) { pr(a.val); }\n\tfriend void re(mi& a) { ll x; re(x); a = mi(x); }\n\tfriend bool operator==(const mi& a, const mi& b) { return a.val == b.val; }\n\tfriend bool operator!=(const mi& a, const mi& b) { return !(a == b); }\n\tfriend bool operator<(const mi& a, const mi& b) { return a.val < b.val; }\n\tmi operator-() const { return mi(-val); }\n\tmi& operator+=(const mi& m) {\n\t\tif ((val += m.val) >= MOD) val -= MOD;\n\t\treturn *this; }\n\tmi& operator-=(const mi& m) {\n\t\tif ((val -= m.val) < 0) val += MOD;\n\t\treturn *this; }\n\tmi& operator*=(const mi& m) { val = (ll)val*m.val%MOD;\n\t\treturn *this; }\n\tfriend mi pow(mi a, ll p) {\n\t\tmi ans = 1; assert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans; }\n\tfriend mi inv(const mi& a) { assert(a != 0); return pow(a,MOD-2); }\n\tmi& operator/=(const mi& m) { return (*this) *= inv(m); }\n\tfriend mi operator+(mi a, const mi& b) { return a += b; }\n\tfriend mi operator-(mi a, const mi& b) { return a -= b; }\n\tfriend mi operator*(mi a, const mi& b) { return a *= b; }\n\tfriend mi operator/(mi a, const mi& b) { return a /= b; }\n};\n\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\nconst int MAX = 1e5 + 5;\nint n; vector<vi> par, adj; vi depth;\nvoid init(int _N) {\n    n = _N;\n    int d = 1; while ((1<<d) < n) d ++;\n    par.assign(d,vi(n)); adj.resz(n); depth.resz(n);\n}\nvoid ae(int x, int y) { adj[x].pb(y), adj[y].pb(x); }\nvoid dfs(int x = 0) {\n    FOR(i,1,sz(par)) par[i][x] = par[i-1][par[i-1][x]];\n    trav(y,adj[x]) if (y != par[0][x])\n        depth[y] = depth[par[0][y] = x]+1, dfs(y);\n}\nvoid gen(int R = 0) { par[0][R] = R; dfs(R); }\n\nint jmp(int x, int d) {\n    F0R(i,sz(par)) if ((d>>i)&1) x = par[i][x];\n    return x; }\nint lca(int x, int y) {\n    if (depth[x] < depth[y]) swap(x,y);\n    x = jmp(x,depth[x]-depth[y]); if (x == y) return x;\n    R0F(i,sz(par)) {\n        int X = par[i][x], Y = par[i][y];\n        if (X != Y) x = X, y = Y;\n    }\n    return par[0][x];\n}\nint dist(int x, int y) { // # edges on path\n    return depth[x]+depth[y]-2*depth[lca(x,y)]; }\n/// edges numbered 1 to n-1 inclusive\nbool vis[MAX];\nvi edges;\nint ans = 1;\nvoid dfs_vert(int src){\n    if(sz(adj[src])%2 == 1) return;\n    for(int nxt: adj[src]){\n        /// src to nxt\n        int val = (depth[src]<depth[nxt] ? nxt:src);\n        if(vis[val]) continue;\n        vis[val] = true;\n        edges.eb(val);\n        dfs_vert(nxt);\n    }\n}\nint dep[MAX];\nbool ok;\nbool check_even(vi& v, int rid, int mx){\n    int l = 0;\n    int r = sz(v) - 1;\n    while(l<=r){\n        if(l == rid) l++;\n        if(r == rid) r--;\n        if(l>r) return true;\n        if(v[l] + v[r]>mx) return false;\n        l++; r--;\n    }\n    return true;\n}\nint solve_even(vi & legs, int mx){\n    int lo = 0;\n    int hi = sz(legs) - 1;\n    while(hi-lo>1){\n        int mid = (lo+hi)/2;\n        if(check_even(legs, mid, mx)) hi = mid;\n        else lo = mid+1;\n    }\n    if(check_even(legs, lo, mx)) return legs[lo];\n    else if(check_even(legs, hi, mx)) return hi;\n    else{\n        ok = false;\n        return legs.back();\n    }\n}\nint solve_odd(vi & legs, int mx){\n    int l = 0;\n    int r = sz(legs) - 1;\n    bool good = true;\n    while(l<=r){\n        if(legs[l]+legs[r]>mx) {\n            good = false; break;\n        }\n        l++; r--;\n    }\n    if(good) return 0;\n    int id = -1;\n    f0r(i, sz(legs)) if(legs[i]<mx) id = i;\n    if(id == -1){\n        ok = false;\n        return legs.back();\n    }\n    legs.erase(legs.begin()+id);\n    return solve_even(legs, mx);\n}\nint dfs_solve(int src, int par, int mx){\n    if(sz(adj[src]) == 1) return 0;\n    vi legs;\n    for(int nxt: adj[src]){\n        if(nxt == par) continue;\n        legs.eb(dfs_solve(nxt, src, mx)+1);\n    }\n    sort(all(legs));\n    if(legs.back()>mx){\n        ok = false;\n        return legs.back();\n    }\n    if(src == 0){\n        if(sz(adj[src])%2 == 0){\n            int l = 0;\n            int r = sz(legs)-1;\n            while(l<=r){\n                if(legs[l]+legs[r]>mx){\n                    ok = false; break;\n                }\n                l++; r--;\n            }\n        }\n        else{\n            if(sz(adj[src]) == 1){\n                if(legs.back()>mx) ok = false;\n                return legs.back();\n            }\n            int id = -1;\n            f0r(i, sz(legs)) if(legs[i]<mx) id = i;\n            if(id == -1){\n                ok = false;\n                return legs.back();\n            }\n            legs.erase(legs.begin()+id);\n            int l = 0; int r = sz(legs)-1;\n            while(l<=r){\n                if(legs[l]+legs[r]>mx) {\n                    ok = false; break;\n                }\n                l++; r--;\n            }\n        }\n        return legs.back();\n\n    }\n    if(sz(adj[src])%2 == 0) return solve_even(legs, mx);\n    else return solve_odd(legs, mx);\n}\nint main(){\n    setIO(\"\");\n    re(n);\n    init(n);\n    f0r(i, n-1){\n        int u, v; re(u, v); u--; v--;\n        ae(u, v);\n    }\n    gen();\n    int ed = 0;\n    f0r(i, n) if(sz(adj[i])%2 == 1) ed++;\n    int a = ed/2;\n    int lo = 1;\n    int hi = MAX;\n    while(hi-lo>1){\n        int mid = (lo+hi)/2;\n        ok = true;\n        dfs_solve(0, -1, mid);\n        if(ok) hi = mid;\n        else lo = mid+1;\n    }\n    ok = true;\n    dfs_solve(0, -1, lo);\n    if(ok) ckmax(ans, lo);\n    else ckmax(ans, hi);\n    ps(a, ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 250001,M = 1e9 + 9,M1 = 1e9 + 7,b = 103,b1 = 11;\nint cs[N],cs1[N],p[N],p1[N],n;\nmap<pair<int,int>,int>mp;\nvoid add(int &a,int b){\n\ta+=b;\n\tif(a >= M)a-=M;\n\tif(a < 0)a+=M;\n}\nvoid add1(int &a,int b){\n\ta+=b;\n\tif(a >= M)a-=M1;\n\tif(a < 0)a+=M1;\n}\nint power(int base,int to){\n\tint ret = 1;\n\twhile(to){\n\t\tif(to&1)ret = ret*1LL*base%M;\n\t\tto>>=1;\n\t\tbase = base*1LL*base%M;\n\t}\n\treturn ret;\n}\nint power1(int base,int to){\n\tint ret = 1;\n\twhile(to){\n\t\tif(to&1)ret = ret*1LL*base%M1;\n\t\tto>>=1;\n\t\tbase = base*1LL*base%M1;\n\t}\n\treturn ret;\n}\nint main(){\n\t//freopen(\"readin.txt\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tp[0] = p1[0] = 1;\n\tchar c;\n\tint inv = power(b,M - 2),inv1 = power1(b1,M1 - 2);\n\tfor(int i = 1;i <= n;i++){\n\t\tscanf(\" %c\",&c);\n\t\tcs[i] = cs[i - 1];\n\t\tp[i] = p[i - 1];\n\t\tcs1[i] = cs1[i - 1];\n\t\tp1[i] = p1[i - 1];\n\t\tif(c == '+')add(cs[i],p[i]),add1(cs1[i],p1[i]);\n\t\telse if(c == '-')add(cs[i],-p[i]),add1(cs1[i],-p1[i]);\n\t\telse if(c == '>')p[i] = p[i]*1LL*b%M,p1[i] = p1[i]*1LL*b1%M1;\n\t\telse if(c == '<')p[i] = p[i]*1LL*inv%M,p1[i] = p1[i]*1LL*inv1%M1;\n\t}\n\tlong long ans = 0;\n\tfor(int i = 0;i <= n;i++){\n\t\tans+=mp[{cs[i],cs1[i]}];\n\t\tmp[{(cs[n]*1LL*p[i] + cs[i] + M)%M,(cs1[n]*1LL*p1[i] + cs1[i] + M1)%M1}]++;\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <set>\n\n#define MIN_INT -2147483648\n#define MAX_INT 2147483647\n#define MIN_LONG -9223372036854775808L\n#define MAX_LONG 9223372036854775807L\n#define PI 3.141592653589793238462643383279502884L\n\n#define long long long int\n\nusing std::vector;\nusing std::map;\nusing std::set;\nusing std::string;\nusing std::pair;\nusing std::cin;\nusing std::cout;\nusing std::cerr;\n\n// @author: pashka\n\n#define MAX 250000\n\nint main() {\n    std::ios::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n    string s;\n    cin >> s;\n\n    long MOD = 1758706867;\n    long X = 716447;\n\n    vector<long> pow(2 * MAX + 2);\n    pow[0] = 1;\n    for (int i = 1; i < pow.size(); i++) {\n        pow[i] = (pow[i - 1] * X) % MOD;\n    }\n\n    vector<long> h(n + 1);\n    vector<int> p(n + 1);\n    p[0] = MAX + 1;\n    for (int i = 0; i < n; i++) {\n        h[i + 1] = h[i];\n        p[i + 1] = p[i];\n        if (s[i] == '+') {\n            h[i + 1] += pow[p[i]];\n        } else if (s[i] == '-') {\n            h[i + 1] -= pow[p[i]];\n        } else if (s[i] == '>') {\n            p[i + 1]++;\n        } else if (s[i] == '<') {\n            p[i + 1]--;\n        }\n        h[i + 1] %= MOD;\n        while (h[i + 1] < 0) h[i + 1] += MOD;\n    }\n\n//    for (int i = 0; i <= n; i++) {\n//        cout << h[i] << \" \" << p[i] << \"\\n\";\n//    }\n\n    long H = h[n];\n    map<long, int> mp;\n    long res = 0;\n    for (int i = n; i >= 0; i--) {\n        int a = (h[i] * pow[MAX + 1]) % MOD;\n        int b = (a + H * pow[p[i]]) % MOD;\n        res += mp[b];\n        mp[a]++;\n    }\n    cout << res << \"\\n\";\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 250001,M = 1e9 + 7,b = 103;\nint cs[N],p[N],n;\nmap<int,int>mp;\nvoid add(int &a,int b){\n\ta+=b;\n\tif(a >= M)a-=M;\n\tif(a < 0)a+=M;\n}\nint power(int base,int to){\n\tint ret = 1;\n\twhile(to){\n\t\tif(to&1)ret = ret*1LL*base%M;\n\t\tto>>=1;\n\t\tbase = base*1LL*base%M;\n\t}\n\treturn ret;\n}\nint main(){\n//\tfreopen(\"readin.txt\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tp[0] = 1;\n\tchar c;\n\tint inv = power(b,M - 2);\n\tfor(int i = 1;i <= n;i++){\n\t\tscanf(\" %c\",&c);\n\t\tcs[i] = cs[i - 1];\n\t\tp[i] = p[i - 1];\n\t\tif(c == '+')add(cs[i],p[i]);\n\t\telse if(c == '-')add(cs[i],-p[i]);\n\t\telse if(c == '>')p[i] = p[i]*1LL*b%M;\n\t\telse if(c == '<')p[i] = p[i]*1LL*inv%M;\n\t\tmp[cs[i]]++;\n\t}\n\tmp[0]++;\n\tlong long ans = 0;\n\tfor(int i = 0;i <= n;i++){\n\t\tmp[cs[i]]--;\n\t\tans+=mp[(cs[n]*1LL*p[i] + cs[i] + M)%M]++;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define LL unsigned long long\n#define PII pair<int, int>\n#define PLL pair<LL, LL>\n#define f first\n#define s second \nusing namespace std;\nconst int MAXN = 200005;\nconst LL M1 = 1000000009;\nconst LL M2 = 1000000007;\n\nLL qpow(LL a, LL pw, LL mod) {\n\tLL res = 1;\n\twhile (pw) {\n\t\tif (pw & 1) res = res * a % mod;\n\t\tpw >>= 1;\n\t\ta = a * a % mod;\n\t}\n\treturn res;\n}\n\nPLL norm(PLL p) {\n\treturn PLL((p.f % M1 + M1) % M1, (p.s % M2 + M2) % M2);\n}\n\nPLL neg(PLL p) {\n\treturn PLL(M1 - p.f, M2 - p.s);\n}\n\nPLL get_inv(PLL p) {\n\treturn PLL(qpow(p.f, M1 - 2, M1), qpow(p.s, M2 - 2, M2));\n}\n\nPLL mul(PLL p, PLL q) {\n\treturn PLL(p.f * q.f % M1, p.s * q.s % M2);\n}\n\nPLL add(PLL p, PLL q) {\n\treturn PLL((p.f + q.f) % M1, (p.s + q.s) % M2);\n}\n\nint n;\nstring s;\nPLL pw[2*MAXN], pinv[2*MAXN], pref[MAXN];\nLL pos[MAXN];\n\nint main() { \n\tios_base::sync_with_stdio(0); cin.tie(0);\n\n\tPLL base = PLL(1234567, 7654321), inv = get_inv(base);\n\tpw[0] = pinv[0] = {1, 1};\n\tfor (int i = 1; i < 2 * MAXN; i++) {\n\t\tpw[i] = mul(pw[i - 1], base);\n\t\tpinv[i] = mul(pinv[i - 1], inv);\n\t}\n\n\tcin >> n >> s;\n\tpref[0] = PLL(0, 0);\n\tpos[0] = n;\n\tmap<PLL, int> cnt;\n\tfor (int i = 1; i <= n; i++) {\n\t\tchar t = s[i - 1];\n\t\tpos[i] = pos[i - 1];\n\t\tpref[i] = pref[i - 1];\n\t\tif (t == '<') pos[i]--;\n\t\tif (t == '>') pos[i]++;\n\t\tif (t == '+') pref[i] = add(pref[i], pw[pos[i]]);\n\t\tif (t == '-') pref[i] = add(pref[i], neg(pw[pos[i]]));\n\t\tcnt[pref[i]]++;\n\t}\n\t\n\tLL ans = 0; \n\tPLL tgt = pref[n], mulf = PLL(1, 1), addf = PLL(0, 0);\n\tfor (int i = 1; i <= n; i++) {\n\t\tans += cnt[add(mul(get_inv(mulf), tgt), neg(mul(get_inv(mulf), addf)))];\n//\t\tcout << \"At \" << i << ' ' << cnt[add(mul(tgt, mulf), addf)] << '\\n';\n\t\t\n\t\tchar t = s[i - 1];\n\t\tcnt[pref[i]]--;\n\t\tif (t == '<') {\n\t\t\t// a *= base, b *= base\n\t\t\tmulf = mul(mulf, pw[1]);\n\t\t\taddf = mul(addf, pw[1]);\n\t\t}\n\t\tif (t == '>') {\n\t\t\t// a /= base, b /= base\n\t\t\tmulf = mul(mulf, pinv[1]);\n\t\t\taddf = mul(addf, pinv[1]);\n\t\t}\n\t\tif (t == '+') {\n\t\t\t// b -= pw[n]\n\t\t\taddf = add(addf, neg(pw[n]));\n\t\t}\n\t\tif (t == '-') {\n\t\t\t// b += pw[n]\n\t\t\taddf = add(addf, pw[n]);\n\t\t}\n\t}\n\t\n\tcout << ans << '\\n';\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define db(x) cerr << #x << \"=\" << x << endl\n#define db2(x, y) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << endl\n#define db3(x, y, z) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << \",\" << #z << \"=\" << z << endl\n#define dbv(v) cerr << #v << \"=\"; for (auto x : v) cerr << x << \", \"; cerr << endl\n#define dba(a, n) cerr << #a << \"=\"; for (int i = 0; i < (n); ++i) cerr << a[i] << \", \"; cerr << endl\ntypedef long long ll;\ntypedef long double ld;\nchar S[250005];\nconst ll P = 998244353;\nconst ll Q = 400009;\nconst ll P2 = 1000000007;\nconst ll Q2 = 400033;\nll modex(ll a, ll p, ll m) {\n\tif (!p) return 1;\n\tif (p & 1) return a * modex(a, p - 1, m) % m;\n\tll v = modex(a, p >> 1, m);\n\treturn v * v % m;\n}\nint main() {\n\tint n;\n\tscanf(\"%d%s\", &n, S);\n\tll Qinv = modex(Q, P - 2, P);\n\tll Qinv2 = modex(Q2, P2 - 2, P2);\n\tll v = 0, v2 = 0;\n\tfor (int i = n - 1; i >= 0; --i) {\n\t\tif (S[i] == '+') v = (v + 1) % P;\n\t\telse if (S[i] == '-') v = (v - 1) % P;\n\t\telse if (S[i] == '>') v = v * Q % P;\n\t\telse if (S[i] == '<') v = v * Qinv % P;\n\t\tif (S[i] == '+') v2 = (v2 + 1) % P2;\n\t\telse if (S[i] == '-') v2 = (v2 - 1) % P2;\n\t\telse if (S[i] == '>') v2 = v2 * Q2 % P2;\n\t\telse if (S[i] == '<') v2 = v2 * Qinv2 % P2;\n\t}\n\tif (v < 0) v += P;\n\tif (v2 < 0) v2 += P2;\n\tmap<pair<ll, ll>, int> cnt;\n\tll mult = 1, add = 0, multinv = 1;\n\tll mult2 = 1, add2 = 0, multinv2 = 1;\n\tll ans = 0;\n\tfor (int i = n - 1; i >= 0; --i) {\n\t\t// add 0\n\t\t// x * mult + add = 0\n\t\tll zero = -add * multinv % P;\n\t\tif (zero < 0) zero += P;\n\t\tll zero2 = -add2 * multinv2 % P2;\n\t\tif (zero2 < 0) zero2 += P2;\n\t\t++cnt[{zero, zero2}];\n\t\tif (S[i] == '+') add = (add + 1) % P;\n\t\telse if (S[i] == '-') add = (add - 1) % P;\n\t\telse if (S[i] == '>') {\n\t\t\tmult = mult * Q % P;\n\t\t\tmultinv = multinv * Qinv % P;\n\t\t\tadd = add * Q % P;\n\t\t} else if (S[i] == '<') {\n\t\t\tmult = mult * Qinv % P;\n\t\t\tmultinv = multinv * Q % P;\n\t\t\tadd = add * Qinv % P;\t\n\t\t}\n\t\tif (S[i] == '+') add2 = (add2 + 1) % P2;\n\t\telse if (S[i] == '-') add2 = (add2 - 1) % P2;\n\t\telse if (S[i] == '>') {\n\t\t\tmult2 = mult2 * Q2 % P2;\n\t\t\tmultinv2 = multinv2 * Qinv2 % P2;\n\t\t\tadd2 = add2 * Q2 % P2;\n\t\t} else if (S[i] == '<') {\n\t\t\tmult2 = mult2 * Qinv2 % P2;\n\t\t\tmultinv2 = multinv2 * Q2 % P2;\n\t\t\tadd2 = add2 * Qinv2 % P2;\t\n\t\t}\n\t\t// query how many is equal to v\n\t\tll w = (v - add) * multinv % P;\n\t\tif (w < 0) w += P;\n\t\tll w2 = (v2 - add2) * multinv2 % P2;\n\t\tif (w2 < 0) w2 += P2;\n\t\tauto it = cnt.find(make_pair(w, w2));\n\t\tif (it != cnt.end()) ans += it->second;\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <vector>\n\nconst int DEBUG = 0;\n\n#define MOCK 1\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define DEBUGP(val) cerr << #val << \"=\" << val << \"\\n\"\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\ntypedef pair<ll, ll> PL;\n\n\nll powmod(ll a, ll e, ll mod) {\n  ll sum = 1;\n  ll cur = a;\n  while (e > 0) {\n    if (e % 2) {\n      sum = sum * cur % mod;\n    }\n    cur = cur * cur % mod;\n    e /= 2;\n  }\n  return sum;\n}\n\nconst int A = 20;\n\nint main(void) {\n  const ll mod = 1e9 + 7;\n  const ll mod2 = 1e9 + 9;\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  string s;\n  cin >> n >> s;\n  int p = 0;\n  VI pos(n + 1);\n  mt19937 mt;\n  VL b(A);\n  ll mods[A] = {};\n  REP(i, 0, A) mods[i] = 1e9 + 7;\n  \n  REP(c, 0, A) {\n    do {\n      b[c] = mt() % mods[c];\n    } while (b[c] == 0);\n  }\n  vector<VL> hsh(A, VL(n + 1));\n  ll inv[A] = { 0 };\n  REP(c, 0, A) inv[c] = powmod(b[c], mods[c] - 2, mods[c]);\n  REP(c, 0, A) {\n    p = 0;\n    ll cur = 1;\n    REP(i, 0, n) {\n      ll tmp = hsh[c][i];\n      if (s[i] == '>') {\n        p++;\n        cur = cur * b[c] % mods[c];\n      }\n      if (s[i] == '<') {\n        p--;\n        cur = cur * inv[c] % mods[c];\n      }\n      if (s[i] == '+') {\n        tmp = (tmp + cur) % mods[c];\n      }\n      if (s[i] == '-') {\n        tmp = (tmp + mods[c] - cur) % mods[c];\n      }\n      hsh[c][i + 1] = tmp;\n      pos[i + 1] = p;\n    }\n  }\n  if (DEBUG) {\n    REP(i, 0, n + 1) {\n      cerr << i << \" \" << hsh[0][i] << endl;\n    }\n  }\n  VL meguru(A);\n  REP(c, 0, A) meguru[c] = hsh[c][n];\n  map<VL, int> kirika;\n  kirika[meguru] = 1;\n  ll tot = 0;\n  VL cur(A);\n  REP(c, 0, A) cur[c] = powmod(b[c], pos[n], mods[c]);\n  for (int i = n - 1; i >= 0; --i) {\n    if (DEBUG) {\n      DEBUGP(i);\n      DEBUGP(pos[i]);\n    }\n    if (pos[i + 1] - pos[i] == 1) {\n      REP(c, 0, A) cur[c] = cur[c] * inv[c] % mods[c];\n    }\n    else if (pos[i + 1] - pos[i] == -1) {\n      REP(c, 0, A) cur[c] = cur[c] * b[c] % mods[c];\n    }\n    VL ken(A);\n    REP(c, 0, A) ken[c] = cur[c] * meguru[c] + hsh[c][i] % mods[c];\n    tot += kirika[ken];\n    VL tt(A);\n    REP(c, 0, A) tt[c] = hsh[c][i];\n    kirika[tt] += 1;\n  }\n  cout << tot << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n    _____\n  .'     '.\n /  0   0  \\\n|     ^     |\n|  \\     /  |\n \\  '---'  /\n  '._____.'\n*/\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\nstruct chash\n{\n\tint operator()(int x) const\n\t{\n\t\tx ^= (x >> 20) ^ (x >> 12);\n\t\treturn x ^ (x >> 7) ^ (x >> 4);\n\t}\n};\n\ntemplate<typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename U> using hashtable = gp_hash_table<T, U, chash>;\nrandom_device(rd);\nmt19937 rng(rd());\n\ntemplate<class T>\nvoid readi(T &x)\n{\n\tT input = 0;\n\tbool negative = false;\n\tchar c = ' ';\n\twhile (c < '-')\n\t{\n\t\tc = getchar();\n\t}\n\tif (c == '-')\n\t{\n\t\tnegative = true;\n\t\tc = getchar();\n\t}\n\twhile (c >= '0')\n\t{\n\t\tinput = input * 10 + (c - '0');\n\t\tc = getchar();\n\t}\n\tif (negative)\n\t{\n\t\tinput = -input;\n\t}\n\tx = input;\n}\ntemplate<class T>\nvoid printi(T output)\n{\n\tif (output == 0)\n\t{\n\t\tputchar('0');\n\t\treturn;\n\t}\n\tif (output < 0)\n\t{\n\t\tputchar('-');\n\t\toutput = -output;\n\t}\n\tint aout[20];\n\tint ilen = 0;\n\twhile(output)\n\t{\n\t\taout[ilen] = ((output % 10));\n\t\toutput /= 10;\n\t\tilen++;\n\t}\n\tfor (int i = ilen - 1; i >= 0; i--)\n\t{\n\t\tputchar(aout[i] + '0');\n\t}\n\treturn;\n}\ntemplate<class T>\nvoid ckmin(T &a, T b)\n{\n\ta = min(a, b);\n}\ntemplate<class T>\nvoid ckmax(T &a, T b)\n{\n\ta = max(a, b);\n}\ntemplate<class T, class U>\nT nmod(T &x, U mod)\n{\n\tif (x >= mod) x -= mod;\n}\ntemplate<class T>\nT randomize(T mod)\n{\n\treturn (uniform_int_distribution<T>(0, mod - 1))(rng);\n}\n\n#define y0 ___y0\n#define y1 ___y1\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fi first\n#define se second\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\nconst long double PI = 4.0 * atan(1.0);\nconst long double EPS = 1e-10;\n\n#define MAGIC 347\n#define SINF 10007\n#define CO 1000007\n#define INF 1000000007\n#define BIG 1000000931\n#define LARGE 1696969696967ll\n#define GIANT 2564008813937411ll\n#define LLINF 2696969696969696969ll\n#define MAXN 500013\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ld, ld> pdd;\n\nint N;\nint arr[MAXN];\npll S;\nlong long ans;\nvector<ll> freqs, needs;\nvector<pll> freq, need;\n\nll expo(ll a, ll e, ll mod)\n{\n\tif (e == 0)\n\t{\n\t\treturn 1;\n\t}\n\tll was = expo(a, e / 2, mod);\n\tif (e % 2)\n\t{\n\t\treturn was * was % mod * a % mod;\n\t}\n\treturn was * was % mod;\n}\nll modinv(ll a, ll e)\n{\n\treturn expo(a, e - 2, e);\n}\nvector<pll> process(vector<ll> v)\n{\n\t// cerr << \"hi\\n\";\n\tvector<pll> res;\n\tfor (int i = 0; i < v.size(); i++)\n\t{\n\t\tif (i == 0 || res.back().fi != v[i])\n\t\t{\n\t\t\tres.PB({v[i], 1});\n\t\t}\n\t\telse\n\t\t{\n\t\t\tres.back().se++;\n\t\t}\n\t}\n\t// cerr << \"bye\\n\";\n\treturn res;\n}\nll overlap(vector<pll> a, vector<pll> b)\n{\n\t// cerr << \"hi\\n\";\n\tint iter = 0; ll res = 0;\n\tfor (int i = 0; i < a.size(); i++)\n\t{\n\t\twhile(iter < b.size() && b[iter].fi < a[i].fi)\n\t\t{\n\t\t\titer++;\n\t\t}\n\t\tif (iter == b.size())\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tif (b[iter].fi == a[i].fi)\n\t\t{\n\t\t\tres += b[iter].se * a[i].se;\n\t\t}\n\t}\n\t// cerr << \"bye\\n\";\n\treturn res;\n}\npll INV = {modinv(CO, INF), modinv(CO, BIG)};\nvoid solve(int L, int R)\n{\n\t// cerr << \"solve \" << L << ' ' << R << endl;\n\tif (L == R)\n\t{\n\t\treturn;\n\t}\n\tneeds.clear(); freqs.clear();\n\tint mid = (L + R) >> 1;\n\t//start from L...mid, end at mid + 1....R\n\tpair<pll, pll> trans = MP(MP(1, 0), MP(1, 0));\n\tfor (int i = mid + 1; i <= R; i++)\n\t{\n\t\tif (arr[i] == 0)\n\t\t{\n\t\t\ttrans.fi.fi *= INV.fi; trans.fi.fi %= INF;\n\t\t\ttrans.fi.se *= INV.fi; trans.fi.se %= INF;\n\t\t\ttrans.se.fi *= INV.se; trans.se.fi %= BIG;\n\t\t\ttrans.se.se *= INV.se; trans.se.se %= BIG;\n\t\t}\n\t\tif (arr[i] == 1)\n\t\t{\n\t\t\ttrans.fi.fi *= CO; trans.fi.fi %= INF;\n\t\t\ttrans.fi.se *= CO; trans.fi.se %= INF;\n\t\t\ttrans.se.fi *= CO; trans.se.fi %= BIG;\n\t\t\ttrans.se.se *= CO; trans.se.se %= BIG;\n\t\t}\n\t\tif (arr[i] == 2)\n\t\t{\n\t\t\ttrans.fi.se++; nmod(trans.fi.se, INF);\n\t\t\ttrans.se.se++; nmod(trans.se.se, BIG);\n\t\t}\n\t\tif (arr[i] == 3)\n\t\t{\n\t\t\ttrans.fi.se--; trans.fi.se += INF; nmod(trans.fi.se, INF);\n\t\t\ttrans.se.se--; trans.se.se += BIG; nmod(trans.se.se, BIG);\n\t\t}\n\t\tpll dif = {(S.fi - trans.fi.se) * modinv(trans.fi.fi, INF), (S.se - trans.se.se) * modinv(trans.se.fi, BIG)};\n\t\tdif.fi %= INF; dif.fi += INF; nmod(dif.fi, INF);\n\t\tdif.se %= BIG; dif.se += BIG; nmod(dif.se, BIG);\n\t\tneeds.PB(dif.fi * BIG + dif.se);\n\t}\n\ttrans = MP(MP(1, 0), MP(1, 0));\n\tfor (int i = mid; i >= L; i--)\n\t{\n\t\tif (arr[i] == 0)\n\t\t{\n\t\t\ttrans.fi.fi *= INV.fi; trans.fi.fi %= INF;\n\t\t\ttrans.se.fi *= INV.se; trans.se.fi %= BIG;\n\t\t}\n\t\tif (arr[i] == 1)\n\t\t{\n\t\t\ttrans.fi.fi *= CO; trans.fi.fi %= INF;\n\t\t\ttrans.se.fi *= CO; trans.se.fi %= BIG;\n\t\t}\n\t\tif (arr[i] == 2)\n\t\t{\n\t\t\ttrans.fi.se += trans.fi.fi; nmod(trans.fi.se, INF);\n\t\t\ttrans.se.se += trans.se.fi; nmod(trans.se.se, BIG);\n\t\t}\n\t\tif (arr[i] == 3)\n\t\t{\n\t\t\ttrans.fi.se -= trans.fi.fi; trans.fi.se += INF; nmod(trans.fi.se, INF);\n\t\t\ttrans.se.se -= trans.se.fi;\ttrans.se.se += BIG; nmod(trans.se.se, BIG);\n\t\t}\n\t\tfreqs.PB(trans.fi.se * BIG + trans.se.se);\n\t}\n\tsort(needs.begin(), needs.end());\n\tsort(freqs.begin(), freqs.end());\n\tneed = process(needs);\n\tfreq = process(freqs);\n\tans += overlap(need, freq);\n\tsolve(L, mid);\n\tsolve(mid + 1, R);\n}\n\nint32_t main()\n{\n\tios_base::sync_with_stdio(0);\n\t// cout << fixed << setprecision(10);\n\t// cerr << fixed << setprecision(10);\n\t// freopen (\"file.in\", \"r\", stdin);\n\t// freopen (\"file.out\", \"w\", stdout);\n\tcin >> N;\n\tstring temps;\n\tcin >> temps;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (temps[i] == '<')\n\t\t{\n\t\t\tarr[i] = 0;\n\t\t}\n\t\tif (temps[i] == '>')\n\t\t{\n\t\t\tarr[i] = 1;\n\t\t}\n\t\tif (temps[i] == '+')\n\t\t{\n\t\t\tarr[i] = 2;\n\t\t}\n\t\tif (temps[i] == '-')\n\t\t{\n\t\t\tarr[i] = 3;\n\t\t}\n\t}\n\treverse(arr, arr + N);\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (arr[i] == 0)\n\t\t{\n\t\t\tS.fi *= INV.fi; S.fi %= INF;\n\t\t\tS.se *= INV.se; S.se %= BIG;\n\t\t\t// cerr << \"times \" << INV << endl;\n\t\t}\n\t\tif (arr[i] == 1)\n\t\t{\n\t\t\tS.fi *= CO; S.fi %= INF;\n\t\t\tS.se *= CO; S.se %= BIG;\n\t\t\t// cerr << \"times \" << CO << endl;\n\t\t}\n\t\tif (arr[i] == 2)\n\t\t{\n\t\t\tS.fi++; nmod(S.fi, INF);\n\t\t\tS.se++; nmod(S.se, BIG);\n\t\t\t// cerr << \"add 1\\n\";\n\t\t}\n\t\tif (arr[i] == 3)\n\t\t{\n\t\t\tS.fi--; S.fi += INF; nmod(S.fi, INF);\n\t\t\tS.se--; S.se += BIG; nmod(S.se, BIG);\n\t\t\t// cerr << \"add -1\\n\";\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (arr[i] == 0)\n\t\t{\n\t\t\tif (S == MP(0ll, 0ll)) ans++;\n\t\t}\n\t\tif (arr[i] == 1)\n\t\t{\n\t\t\tif (S == MP(0ll, 0ll)) ans++;\n\t\t}\n\t\tif (arr[i] == 2)\n\t\t{\n\t\t\tif (S == MP(1ll, 1ll)) ans++;\n\t\t}\n\t\tif (arr[i] == 3)\n\t\t{\n\t\t\tif (S == MP((ll) INF - 1, (ll) BIG - 1)) ans++;\n\t\t}\n\t}\n\tsolve(0, N - 1);\n\tcout << ans << '\\n';\n\t//when u <, the # divides by co\n\t//when u >, the # mults by co\n\t//when u +, u add the #\n\t//when u -, u subtract the #\n\t// cerr << \"time elapsed = \" << (clock() / (CLOCKS_PER_SEC / 1000)) << \" ms\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <chrono>\n#include <iostream>\n#include <map>\n#include <random>\n#include <string>\n#include <vector>\nusing namespace std;\n\n// Computes the inverse of `a` modulo 2^64.\nuint64_t mod_inv_2_64(uint64_t a) {\n    // https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Example\n    // https://www.di-mgt.com.au/euclidean.html#code-modinv\n    uint64_t g = 0, r = a, x = 0, y = 1;\n    int sign = -1;\n\n    // Do the first iteration manually to avoid overflow issues.\n    uint64_t u64_max = ((uint64_t) -1);\n    uint64_t q = u64_max / r + (u64_max % r == r - 1 ? 1 : 0);\n    g = u64_max % r == r - 1 ? 0 : u64_max % r + 1; swap(g, r);\n    x += q * y; swap(x, y);\n    sign = -sign;\n\n    while (r != 0) {\n        q = g / r;\n        g %= r; swap(g, r);\n        x += q * y; swap(x, y);\n        sign = -sign;\n    }\n\n    assert(g == 1);\n    assert(y == 0);\n    return sign > 0 ? x : -x;\n}\n\nauto random_address = [] { char *p = new char; delete p; return (uint64_t) p; };\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count() * (random_address() | 1));\n\nusing hash_t = uint64_t;\n\n// HASH_MULT is a random number 3 or 5 mod 8. This ensures the hash is reliable until comparing strings of length 1024.\nconst hash_t HASH_MULT = (rng() & ~7) + (rng() % 2 ? 3 : 5);\nconst hash_t HASH_MULT_INV = mod_inv_2_64(HASH_MULT);\n\nvector<hash_t> hash_pow = {1};\nvector<hash_t> inv_pow = {1};\n\n\nint N;\nstring S;\n\nstruct state {\n    vector<int> A;\n    int position;\n    hash_t hash;\n\n    state() {\n        A.assign(2 * N + 1, 0);\n        position = N;\n        hash = 0;\n    }\n\n    void modify(int change) {\n        assert(change == +1 || change == -1);\n        A[position] += change;\n        hash += change * hash_pow[position];\n    }\n\n    void move(int dir) {\n        assert(dir == +1 || dir == -1);\n        position += dir;\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    assert(HASH_MULT * HASH_MULT_INV == 1);\n    cin >> N >> S;\n\n    for (int i = 0; i < 2 * N; i++)\n        hash_pow.push_back(HASH_MULT * hash_pow.back());\n\n    for (int i = 0; i < 2 * N; i++)\n        inv_pow.push_back(HASH_MULT_INV * inv_pow.back());\n\n    state current;\n    vector<hash_t> prefix_hashes = {current.hash};\n\n    for (int i = 0; i < N; i++) {\n        if (S[i] == '+' || S[i] == '-')\n            current.modify(S[i] == '+' ? +1 : -1);\n        else\n            current.move(S[i] == '>' ? +1 : -1);\n\n        prefix_hashes.push_back(current.hash);\n    }\n\n    map<hash_t, int> freq;\n\n    for (hash_t h : prefix_hashes)\n        freq[h]++;\n\n    hash_t goal = prefix_hashes.back();\n    current = state();\n    long long total = 0;\n\n    for (int i = 0; i < N; i++) {\n        freq[prefix_hashes[i]]--;\n\n        hash_t mult = current.position >= N ? hash_pow[current.position - N] : inv_pow[N - current.position];\n        hash_t target = prefix_hashes[i] + goal * mult;\n        total += freq[target];\n\n        if (S[i] == '+' || S[i] == '-')\n            current.modify(S[i] == '+' ? +1 : -1);\n        else\n            current.move(S[i] == '>' ? +1 : -1);\n    }\n\n    cout << total << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long D;\nconst int maxn=500005,base=17,mod1=998244353,mod2=1000000009;\nint qpow(int x,int y,int mod){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1)ans=D(ans)*x%mod;\n\t\tx=D(x)*x%mod;\n\t\ty>>=1;\n\t}\n\treturn ans;\n}\nint n,temp[base+1];\nchar s[maxn];\nstruct H{\n\tint a,b;\n\tH():a(0),b(0){}\n\tH(int _a,int _b):a(_a),b(_b){}\n\tH operator+(const H &x)const{return H((a+x.a)%mod1,(b+x.b)%mod2);}\n\tH operator-(const H &x)const{return H((a-x.a+mod1)%mod1,(b-x.b+mod2)%mod2);}\n\tH operator*(const H &x)const{return H((D)a*x.a%mod1,(D)b*x.b%mod2);}\n\tbool operator<(const H &x)const{return a!=x.a?a<x.a:b<x.b;}\n}b,inv,f[maxn],g[maxn];\nmap<H,int> mp;\nint main(){\n\tb=H(base,base),inv=H(qpow(base,mod1-2,mod1),qpow(base,mod2-2,mod2));\n\tscanf(\"%d%s\",&n,s+1);\n\tg[0]=H(1,1);\n\tfor(int i=1;i<=n;i++){\n\t\tf[i]=f[i-1],g[i]=g[i-1];\n\t\tif(s[i]=='+')f[i]=f[i]+g[i];\n\t\tif(s[i]=='-')f[i]=f[i]-g[i];\n\t\tif(s[i]=='<')g[i]=g[i]*inv;\n\t\tif(s[i]=='>')g[i]=g[i]*b;\n\t\tmp[f[i]]++;\n\t}\n\tD ans=0;\n\tfor(int i=1;i<=n;i++){\n\t\tans+=mp[f[i-1]+g[i-1]*f[n]];\n\t\tmp[f[i]]--;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <math.h>\n#include <time.h>\n#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <fstream>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN = 250005;\nconst ll MOD1 = 998244353;\nconst ll MOD2 = 1000000007;\n\nint n;\nint p[MAXN];\n\nll inv1,inv2,ans;\n\npair<ll,ll> h[MAXN];\npair<ll,ll> pw[MAXN];\npair<ll,ll> rpw[MAXN];\n\nchar s[MAXN];\n\nmap<pair<ll,ll>,int> cnt;\n\nll power(ll a,ll b,ll p)\n{\n\tll res = 1;\n\twhile (b)\n\t{\n\t\tif (b & 1)\n\t\t\t(res *= a) %= p;\n\t\t(a *= a) %= p;\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\npair<ll,ll> getv(int t)\n{\n\treturn t >= 0 ? pw[t] : rpw[-t];\n}\n\npair<ll,ll> mul(pair<ll,ll> a,pair<ll,ll> b)\n{\n\treturn make_pair(a.first * b.first % MOD1,a.second * b.second % MOD2);\n}\n\npair<ll,ll> add(pair<ll,ll> a,pair<ll,ll> b)\n{\n\treturn make_pair((a.first + b.first) % MOD1,(a.second + b.second) % MOD2);\n}\n\npair<ll,ll> sub(pair<ll,ll> a,pair<ll,ll> b)\n{\n\treturn make_pair((a.first - b.first) % MOD1,(a.second - b.second) % MOD2);\n}\n\nint main()\n{\n\tscanf(\"%d%s\",&n,s + 1);\n\tinv1 = power(786433,MOD1 - 2,MOD1);\n\tinv2 = power(786433,MOD2 - 2,MOD2);\n\tpw[0] = make_pair(1,1);\n\tfor (int i = 1;i <= n;i++)\n\t\tpw[i] = mul(pw[i - 1],make_pair(786433,786433));\n\trpw[0] = make_pair(1,1);\n\tfor (int i = 1;i <= n;i++)\n\t\trpw[i] = mul(rpw[i - 1],make_pair(inv1,inv2));\n\tfor (int i = 1;i <= n;i++)\n\t{\n\t\tif (s[i] == '+')\n\t\t{\n\t\t\tp[i] = p[i - 1];\n\t\t\th[i] = add(h[i - 1],getv(p[i]));\n\t\t}\n\t\tif (s[i] == '-')\n\t\t{\n\t\t\tp[i] = p[i - 1];\n\t\t\th[i] = sub(h[i - 1],getv(p[i]));\n\t\t}\n\t\tif (s[i] == '<')\n\t\t{\n\t\t\th[i] = h[i - 1];\n\t\t\tp[i] = p[i - 1] - 1;\n\t\t}\n\t\tif (s[i] == '>')\n\t\t{\n\t\t\th[i] = h[i - 1];\n\t\t\tp[i] = p[i - 1] + 1;\n\t\t}\n\t}\n\tfor (int i = n;i >= 1;i--)\n\t{\n\t\t(h[i].first += MOD1) %= MOD1;\n\t\t(h[i].second += MOD2) %= MOD2;\n\t}\n\tfor (int i = n;i >= 1;i--)\n\t{\n\t\tcnt[h[i]]++;\n\t\tans += cnt[add(mul(h[n],getv(p[i - 1])),h[i - 1])];\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\n//const ll mod = 1000000087;\n//const ll INF = mod * mod;\ntypedef pair<int, int>P;\ntypedef pair<int, bool> sP;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef pair<ll, ll> LP;\ntypedef vector<ll> vec;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef vector<vector<ll>> mat;\ntypedef vector<ll> vec;\n\n\n\nvector<ll> mods;\nvector<ll> roots;\n\nbool isp(ll x) {\n\tRep1(i,2, 100000) {\n\t\tif (x%i == 0)return false;\n\t}\n\treturn true;\n}\nvoid genmods() {\n\tll sta = 1000010000;\n\twhile (mods.size() < 5) {\n\t\tif (isp(sta))mods.push_back(sta);\n\t\tsta++;\n\t}\n}\nvoid genroots() {\n\tll sta = 2000010000;\n\twhile (roots.size() < 2) {\n\t\tif (isp(sta))roots.push_back(sta);\n\t\tsta++;\n\t}\n}\nll mod_pow(ll x, ll n,ll mod) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n % 2)res = res * x%mod;\n\t\tx = x * x%mod; n >>= 1;\n\t}\n\treturn res;\n}\nvector<ll> invroots;\n\nvector<ll> tr[300000];\nvector<ll> invtr[300000];\nvoid init() {\n\tgenmods();\n\tgenroots();\n\trep(i, 300000) {\n\t\ttr[i].resize(mods.size()*roots.size());\n\t\tinvtr[i].resize(mods.size()*roots.size());\n\t}\n\trep(j, tr[0].size()) {\n\t\ttr[0][j] = invtr[0][j] = 1;\n\t}\n\trep(j, mods.size()) {\n\t\trep(k, roots.size()) {\n\t\t\tinvroots.push_back(mod_pow(roots[k], mods[j] - 2, mods[j]));\n\t\t}\n\t}\n\trep(i, 299999) {\n\t\trep(j, mods.size()) {\n\t\t\trep(k, roots.size()) {\n\t\t\t\tint id = j * roots.size() + k;\n\t\t\t\ttr[i + 1][id] = tr[i][id] * roots[k] % mods[j];\n\t\t\t\tinvtr[i + 1][id] = invtr[i][id] * invroots[id] % mods[j];\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve() {\n\tint n; cin >> n;\n\tstring s; cin >> s;\n\tvector<ll> sum(mods.size()*roots.size(),0); int loc = 0;\n\tvector<vector<ll>> memo(n);\n\trep(i, n)memo[i].resize(mods.size()*roots.size());\n\tvector<int> locs(n);\n\tint len = roots.size()*mods.size();\n\trep(i, n) {\n\t\tif (s[i] == '>')loc++;\n\t\telse if (s[i] == '<')loc--;\n\t\telse if (s[i] == '+') {\n\t\t\tif (loc >= 0) {\n\t\t\t\trep(j, len) {\n\t\t\t\t\tsum[j] += tr[loc][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\trep(j, len) {\n\t\t\t\t\tsum[j] += invtr[-loc][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (loc >= 0) {\n\t\t\t\trep(j, len) {\n\t\t\t\t\tsum[j] -= tr[loc][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\trep(j, len) {\n\t\t\t\t\tsum[j] -= invtr[-loc][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(j, len) {\n\t\t\tll mod = mods[j / roots.size()];\n\t\t\tsum[j] = (sum[j] % mod + mod) % mod;\n\t\t\tmemo[i][j] = sum[j];\n\t\t}\n\n\t\tlocs[i] = loc;\n\t}\n\tvector<ll> alls = sum;\n\tll ans = 0;\n\tvector<map<ll, int>> mp(len);\n\trep(i, len) {\n\t\tmp[i][alls[i]]++;\n\t}\n\trep(i, n) {\n\t\t//cout << mp[memo[i]] << endl;\n\t\tint mi = 2*n;\n\t\trep(j, len) {\n\t\t\tmi = min(mi, mp[j][memo[i][j]]);\n\t\t}\n\t\tans += mi;\n\t\tbool valid = true;\n\t\t\n\t\trep(j, len) {\n\t\t\tll nex = alls[j];\n\t\t\tll mod = mods[j / roots.size()];\n\t\t\tif (locs[i] >= 0) {\n\t\t\t\tnex = nex * tr[locs[i]][j] % mod;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnex = nex * invtr[-locs[i]][j] % mod;\n\t\t\t}\n\t\t\tnex += memo[i][j];\n\t\t\tnex %= mod;\n\t\t\tmp[j][nex]++;\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(7);\n\tinit();\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int C = 3e5 + 7;\nconst int N = C << 1;\nconst int BASE = C;\nconst int MOD = 1000 * 1000 * 1000 + 7;\nint mod(int n) {\n    return (n % MOD + MOD) % MOD;\n}   \nint x[N], pw[N];\nvoid add(int &a, int b) {\n    a = mod(a + b);\n}   \nint pref[N];\nint fp(int a, int p) {\n    int ans = 1, c = a;\n    for (int i = 0; (1ll << i) <= p; ++i) {\n        if ((p >> i) & 1) ans = mod(ans * c);\n        c = mod(c * c);\n    }   \n    return ans;\n}   \nint dv(int a, int b) {\n    return mod(a * fp(b, MOD - 2));\n}   \nsigned main() {\n    #ifdef HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    #else\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    #endif\n    pw[0] = 1;\n    for (int i = 1; i < N; ++i) pw[i] = mod(pw[i - 1] * BASE);\n    int n;\n    cin >> n;\n    string s;\n    cin >> s;\n    for (int i = 0; i < n; ++i) {\n        pref[i + 1] = pref[i];\n        x[i + 1] = x[i];\n        if (s[i] == '<') --x[i + 1];\n        else if (s[i] == '>') ++x[i + 1];\n        else if (s[i] == '+') add(pref[i + 1], pw[x[i + 1] + C]);\n        else add(pref[i + 1], -pw[x[i + 1] + C]);\n    }\n    int ans = 0;\n    map <int, int> d;\n    for (int i = n; i >= 0; --i) {\n        int w;\n        if (x[i] < 0) w = mod(pref[i] + dv(pref[n], fp(BASE, x[i])));\n        else w = mod(pref[i] + mod(pref[n] * fp(BASE, x[i])));\n        ans += d[w];\n        d[pref[i]]++;\n    }   \n    cout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing lint = long long int;\nusing P = pair<lint, lint>;\n\nconstexpr lint MOD = 1000000007;\n\nvector<lint> X{250007, 861743};\nvector<lint> Xinv(2);\n\nint N;\nstring S;\n\n// ax+by=gcd(a, b)\ntemplate <typename T>\nT extgcd(T a, T b, T &x, T &y)\n{\n    T d = a;\n    if (b != 0)\n    {\n        d = extgcd(b, a % b, y, x);\n        y -= a / b * x;\n    }\n    else\n    {\n        x = 1;\n        y = 0;\n    }\n    return d;\n}\n\nP nxt_hash(P prev_hash, lint x, lint xinv, char c)\n{\n    P res = prev_hash;\n    if (c == '+')\n    {\n        res.first++;\n    }\n    if (c == '-')\n    {\n        res.first += MOD - 1;\n    }\n    if (c == '>')\n    {\n        res.first *= x;\n        res.second *= x;\n    }\n    if (c == '<')\n    {\n        res.first *= xinv;\n        res.second *= xinv;\n    }\n    res.first %= MOD;\n    res.second %= MOD;\n    return res;\n}\n\nint main()\n{\n    for (int i = 0; i < 2; i++)\n    {\n        lint xinv, tmp;\n        extgcd(X[i], MOD, xinv, tmp);\n        Xinv[i] = (xinv + MOD) % MOD;\n    }\n\n    cin >> N >> S;\n\n    vector<vector<P> > hash(2, vector<P>(N+1, make_pair(0LL, 1LL)));\n\n    for (unsigned ix = 0; ix < 2; ix++)\n    {\n        lint x = X[ix];\n        lint xinv = Xinv[ix];\n        for (int i = N - 1; i>=0; i--) hash[ix][i] = nxt_hash(hash[ix][i + 1], x, xinv, S[i]);\n    }\n\n    for (int ix = 0; ix < 2; ix++)\n    {\n        for (int i = 0; i <= N; i++)\n        {\n            lint invh, tmp;\n            extgcd(hash[ix][i].second, MOD, invh, tmp);\n            hash[ix][i].second = (invh + MOD) % MOD;\n        }\n    }\n\n    map<P, vector<int>> hash_lst;\n    for (int i = 0; i <= N; i++)\n    {\n        P res;\n        res.first = hash[0][i].first * hash[0][i].second % MOD;\n        res.second = hash[1][i].first * hash[1][i].second % MOD;\n        hash_lst[res].push_back(i);\n    }\n\n    lint ans = 0;\n\n    for (int m = 0; m <= N; m++)\n    {\n        P phash;\n        phash.first = (hash[0][m].first - hash[0][0].first + MOD) * hash[0][m].second % MOD;\n        phash.second = (hash[1][m].first - hash[1][0].first + MOD) * hash[1][m].second % MOD;\n        vector<int> cand = hash_lst[phash];\n        ans += cand.end() - upper_bound(cand.begin(), cand.end(), m);\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "const int N = 400005;\nconst int LG = 21;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nint n;\nstring s;\nll sufa[N];\nll suf0[N];\nconst ll K = 1e6 + 3;\nconst ll K2 = 1791791;\nconst ll rK = rev(K);\nll pref0[N];\nll prefa[N];\nll moves[N];\nmap<int, ll> deg;\n\nsigned main()\n{\n    deg[0] = 1;\n    for (int i = 1; i < N; i++) deg[i] = deg[i - 1] * K % MOD;\n    for (int i = 1; i < N; i++) deg[-i] = deg[-i + 1] * rK % MOD;\n    srand(time(NULL));\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n    cin >> n >> s;\n    ll a = 0;\n    for (int i = n - 1; i >= 0; i--)\n    {\n        if (s[i] == '+')\n        {\n            a = (a + MOD - 1) % MOD;\n        }\n        if (s[i] == '-')\n        {\n            a = (a + 1) % MOD;\n        }\n        if (s[i] == '>')\n        {\n            a = (a * K) % MOD;\n        }\n        if (s[i] == '<')\n        {\n            a = (a * rK) % MOD;\n        }\n    }\n    pref0[0] = 0, prefa[0] = a, moves[0] = 0;\n    if (s[0] == '+') pref0[0] = (pref0[0] + 1) % MOD;\n    if (s[0] == '-') pref0[0] = (pref0[0] + MOD - 1) % MOD;\n    if (s[0] == '<') pref0[0] = (pref0[0] * K) % MOD;\n    if (s[0] == '>') pref0[0] = (pref0[0] * rK) % MOD;\n    if (s[0] == '+') prefa[0] = (prefa[0] + 1) % MOD;\n    if (s[0] == '-') prefa[0] = (prefa[0] + MOD - 1) % MOD;\n    if (s[0] == '<') prefa[0] = (prefa[0] * K) % MOD;\n    if (s[0] == '>') prefa[0] = (prefa[0] * rK) % MOD;\n    if (s[0] == '>') moves[0]++;\n    if (s[0] == '<') moves[0]--;\n    for (int i = 1; i < n; i++)\n    {\n        if (s[i] == '+') pref0[i] = (pref0[i - 1] + 1) % MOD;\n        if (s[i] == '-') pref0[i] = (pref0[i - 1] + MOD - 1) % MOD;\n        if (s[i] == '<') pref0[i] = (pref0[i - 1] * K) % MOD;\n        if (s[i] == '>') pref0[i] = (pref0[i - 1] * rK) % MOD;\n        if (s[i] == '+') prefa[i] = (prefa[i - 1] + 1) % MOD;\n        if (s[i] == '-') prefa[i] = (prefa[i - 1] + MOD - 1) % MOD;\n        if (s[i] == '<') prefa[i] = (prefa[i - 1] * K) % MOD;\n        if (s[i] == '>') prefa[i] = (prefa[i - 1] * rK) % MOD;\n        moves[i] = moves[i - 1];\n        if (s[i] == '>') moves[i]++;\n        if (s[i] == '<') moves[i]--;\n    }\n    for (int j = 0; j < n; j++)\n    {\n        if (s[j] == '+')\n        {\n            suf0[0] = (suf0[0] + 1) % MOD;\n        }\n        if (s[j] == '-')\n        {\n            suf0[0] = (suf0[0] + MOD - 1) % MOD;\n        }\n        if (s[j] == '<')\n        {\n            suf0[0] = (suf0[0] * K) % MOD;\n        }\n        if (s[j] == '>')\n        {\n            suf0[0] = (suf0[0] * rK) % MOD;\n        }\n    }\n    for (int i = 0; i < n; i++) suf0[i + 1] = (suf0[0] - pref0[i] * deg[moves[i]] + MOD * MOD) % MOD;\n    for (int i = 0; i < n; i++) sufa[i] = (suf0[i] + a * deg[(i > 0 ? moves[i - 1] : 0) - moves[n - 1]]) % MOD;\n    ll ans = 0;\n    map<vector<ll>, ll> cnt;\n    for (int i = n; i >= 0; i--)\n    {\n        ans += cnt[{sufa[i]}];\n        cnt[{suf0[i]}]++;\n    }\n    cout << ans;\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <string.h>\n//#include <unordered_set>\n//#include <unordered_map>\n//#include <bits/stdc++.h>\n\n#define MP(A,B) make_pair(A,B)\n#define PB(A) push_back(A)\n#define SIZE(A) ((int)A.size())\n#define LEN(A) ((int)A.length())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define fi first\n#define se second\n\nusing namespace std;\n\ntemplate<typename T>inline bool upmin(T &x,T y) { return y<x?x=y,1:0; }\ntemplate<typename T>inline bool upmax(T &x,T y) { return x<y?x=y,1:0; }\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double lod;\ntypedef pair<int,int> PR;\ntypedef vector<int> VI;\n\nconst lod eps=1e-11;\nconst lod pi=acos(-1);\nconst int oo=1<<30;\nconst ll loo=1ll<<62;\nconst int mods=998244353;\nconst int MAXN=1000005;\nconst int INF=0x3f3f3f3f;//1061109567\n/*--------------------------------------------------------------------*/\ninline int read()\n{\n\tint f=1,x=0; char c=getchar();\n\twhile (c<'0'||c>'9') { if (c=='-') f=-1; c=getchar(); }\n\twhile (c>='0'&&c<='9') { x=(x<<3)+(x<<1)+(c^48); c=getchar(); }\n\treturn x*f;\n}\nint upd(int x,int y) { return x+y>=mods?x+y-mods:x+y; }\nint quick_pow(int x,int y)\n{\n\tint ret=1;\n\tfor (;y;y>>=1)\n\t{\n\t\tif (y&1) ret=1ll*ret*x%mods;\n\t\tx=1ll*x*x%mods;\n\t}\n\treturn ret;\n}\n\nchar st[MAXN];\nint X[6]={37,667,233333,17,19,53},inv[6];\nstruct Node\n{\n\tint a[6]; \n\tNode() { for (int i=0;i<6;i++) a[i]=0; }\n};\nbool operator < (Node x,Node y) \n{\n\tfor (int i=0;i<6;i++) { if (x.a[i]==y.a[i]) continue; return x.a[i]<y.a[i]; }\n\treturn 0;\n}\nmap<Node,int> Map;\nNode operator + (Node x,int y) { for (int i=0;i<6;i++) x.a[i]=upd(x.a[i],y); return x; }\nNode operator - (Node x,int y) { for (int i=0;i<6;i++) x.a[i]=upd(x.a[i],mods-y); return x; }\nNode operator >> (Node x,int y) { while (y--) for (int i=0;i<6;i++) x.a[i]=1ll*x.a[i]*X[i]%mods; return x; }\nNode operator << (Node x,int y) { while (y--) for (int i=0;i<6;i++) x.a[i]=1ll*x.a[i]*inv[i]%mods; return x; }\n\nstruct fnode\n{\n\tNode k,b;\n\tfnode() { for (int i=0;i<6;i++) k.a[i]=1,b.a[i]=0; }\n};\nfnode operator + (fnode x,int y) { for (int i=0;i<6;i++) x.b.a[i]=upd(x.b.a[i],y*x.k.a[i]); return x; }\nfnode operator - (fnode x,int y) { for (int i=0;i<6;i++) x.b.a[i]=upd(x.b.a[i],mods-y*x.k.a[i]); return x; }\nfnode operator >> (fnode x,int y) { while (y--) for (int i=0;i<6;i++) x.k.a[i]=1ll*x.k.a[i]*X[i]%mods; return x; }\nfnode operator << (fnode x,int y) { while (y--) for (int i=0;i<6;i++) x.k.a[i]=1ll*x.k.a[i]*inv[i]%mods; return x; }\nNode operator * (Node x,fnode y) \n{\n\tNode ans;\n\tfor (int i=0;i<6;i++) ans.a[i]=upd(ans.a[i],(1ll*y.k.a[i]*x.a[i]+y.b.a[i])%mods);\n\treturn ans;\n}\nint main()\n{\n\tfor (int i=0;i<6;i++) inv[i]=quick_pow(X[i],mods-2);\n\tint n=read();\n\tscanf(\"%s\",st+1);\n\tNode c,p;\n\tfor (int i=n;i>=1;i--)\n\t{\n\t\tif (st[i]=='+') c=c+1;\n\t\tif (st[i]=='-') c=c-1;\n\t\tif (st[i]=='<') c=c<<1;\n\t\tif (st[i]=='>') c=c>>1;\n//\t\tfor (int j=0;j<6;j++) cout<<c.a[j]<<\" \";cout<<endl;\n\t}\n//\tcout<<endl;\n\tMap[p]++;\n\tfnode f;\n\tll ans=0;\n\tfor (int i=n;i>=1;i--)\n\t{\n\t\tif (st[i]=='+') f=f-1;\n\t\tif (st[i]=='-') f=f+1;\n\t\tif (st[i]=='<') f=f>>1;\n\t\tif (st[i]=='>') f=f<<1;\n\t\tans+=Map[c*f],Map[p*f]++;\n//\t\tfor (int j=0;j<6;j++) cout<<(p*f).a[j]<<\" \";cout<<endl;\n//\t\tfor (int j=0;j<6;j++) cout<<(c*f).a[j]<<\" \";cout<<endl<<endl;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEB\n#include<bits/stdc++.h>\n#define REP(i,m) for(int i=0;i<(m);++i)\n#define REPN(i,m,in) for(int i=(in);i<(m);++i)\n#define ALL(t) (t).begin(),(t).end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n\nusing namespace std;\n\n\n#ifdef DEB\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define prl cerr<<\"called:\"<< __LINE__<<endl\n#define dumpR(x) cerr<<\"\\x1b[31m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpY(x) cerr<<\"\\x1b[33m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpG(x) cerr<<\"\\x1b[32m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\ntemplate<class T> void debug(T a,T b){ for(;a!=b;++a) cerr<<*a<<' ';cerr<<endl;}\n#else\n#define dump(x) ;\n#define dumpR(x) ;\n#define dumpY(x) ;\n#define dumpG(x) ;\n#define prl ;\ntemplate<class T> void debug(T a,T b){ ;}\n#endif\n\ntemplate<class T> bool chmin(T& a,const T& b) {\n  if(a>b) {\n    a=b;\n    return true;\n  }\n  return false;\n}\ntemplate<class T> bool chmax(T& a,const T& b) {\n  if(a<b){\n    a=b;\n    return true;\n  }\n  return false;\n}\n\ntypedef long long int lint;\ntypedef pair<int,int> pi;\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fr<<','<<a.sc<<')';\n    return out;\n  }\n}\n\n//const int INF=5e8;\ntemplate<lint mod>\nstruct Int_{\n  unsigned x;\n  int mpow(Int_ a,int k){\n    Int_ res=1;\n    while(k){\n      if(k&1) res=res*a;\n      a=a*a;\n      k>>=1;\n    }\n    return res.x;\n  }\n  int inverse(Int_ a){\n    return mpow(a,mod-2);\n  }\n  Int_(): x(0) { }\n  Int_(long long sig) { int sigt = sig % mod; if(sigt < 0) sigt += mod; x = sigt; }\n  int get() const { return (int)x; }\n  \n  Int_ &operator+=(Int_ that) { if((x += that.x) >= mod) x -= mod; return *this; }\n  Int_ &operator-=(Int_ that) { if((x += mod - that.x) >= mod) x -= mod; return *this; }\n  Int_ &operator*=(Int_ that) { x = (unsigned long long)x * that.x % mod; return *this; }\n  Int_ &operator=(Int_ that) { x=that.x; return *this;}\n  Int_ &operator/=(Int_ that) { x=(unsigned long long) x * inverse(that.x)%mod; return *this;}\n  bool operator==(Int_ that) const { return x==that.x; }\n  bool operator!=(Int_ that) const { return x!=that.x; }\n\n\n  Int_ operator-() const { return Int_(0)-Int_(*this);}\n  Int_ operator+(Int_ that) const { return Int_(*this) += that; }\n  Int_ operator-(Int_ that) const { return Int_(*this) -= that; }\n  Int_ operator*(Int_ that) const { return Int_(*this) *= that; }\n  Int_ operator/(Int_ that) const { return Int_(*this) /= that; }\n\n};\n\ntypedef Int_<1000000021> Int_h;\n\nnamespace std{\n  template<lint mod>\n  ostream &operator <<(ostream& out,const Int_<mod>& a){\n    out<<a.get();\n    return out;\n  }\n  template<lint mod>\n  istream &operator >>(istream& in,Int_<mod>& a){\n    in>>a.x;\n    return in;\n  }\n};\nstruct Hash{\n  static const int MAX_N=550005;\n  static Int_h M1,M2;\n  static Int_h rev1,rev2;\n\n  static Int_h mul1[MAX_N],mul2[MAX_N],\n         div1[MAX_N],div2[MAX_N];\n\n  typedef pair<Int_h,Int_h>key;\n  static Hash pows[MAX_N];\n\n  key a;\n  static void init(){\n    M1=1000000007,M2=1000000009;\n    rev1=Int_h(1)/M1;\n    rev2=Int_h(1)/M2;\n\n    Int_h* ar[4]={mul1,mul2,div1,div2};\n    Int_h mult[4]={M1,M2,rev1,rev2};\n    REP(j,4){\n      ar[j][0]=1;\n      REP(i,MAX_N-1){\n        ar[j][i+1]=ar[j][i]*mult[j];\n      }\n    }\n    REP(i,MAX_N) pows[i].a=mp(mul1[i],mul2[i]);\n  }\n  Hash(lint val=0){\n    a=mp(val,val);\n  }\n  Hash &operator+=(const Hash& b) { \n    a.fr+=b.a.fr;\n    a.sc+=b.a.sc;\n\n    return *this;\n  }\n  Hash &operator-=(const Hash& b) {\n    a.fr-=b.a.fr;\n    a.sc-=b.a.sc;\n\n    return *this;\n  }\n  Hash &operator <<=(int k){\n    if(k<0) (*this)>>=(-k);\n    else{\n      a.fr*=mul1[k];\n      a.sc*=mul2[k];\n      return *this;\n    }\n  }\n  Hash &operator >>=(int k){\n    if(k<0) (*this)<<=(-k);\n    else{\n      a.fr*=div1[k];\n      a.sc*=div2[k];\n      return *this;\n    }\n  }\n  Hash &operator =(Hash b){\n    a=b.a;\n    return *this;\n  }\n  Hash &operator =(lint val){\n    a.fr=val;\n    a.sc=val;\n    return *this;\n  }\n  Hash operator -()const{\n    return Hash(0)-=Hash(*this);\n  }\n\n  Hash operator +(const Hash& b) const{\n    return Hash(*this)+=b;\n  }\n  Hash operator -(const Hash& b) const{\n    return Hash(*this)-=b;\n  }\n\n  Hash operator <<(int k) const{\n    return Hash(*this)<<=k;\n  }\n  Hash operator >>(int k) const{\n    return Hash(*this)>>=k;\n  }\n\n  bool operator==(const Hash& b) const { return (a==b.a); }\n  bool operator!=(const Hash& b) const { return (a!=b.a); }\n  bool operator<(const Hash& b) const {\n    return mp(a.fr.x,a.sc.x)<mp(b.a.fr.x,b.a.sc.x);\n  }\n};\n\nconst int Hash::MAX_N;\nInt_h Hash::M1,Hash::M2;\nInt_h Hash::rev1,Hash::rev2;\nInt_h Hash::mul1[MAX_N],Hash::mul2[MAX_N],\n         Hash::div1[MAX_N],Hash::div2[MAX_N];\n\nHash Hash::pows[MAX_N];\n//Hash::init();\n//don't forget initializing!\n\nint n;\nchar s[250005];\nint main(){\n  Hash::init();\n  cin>>n;\n  scanf(\"%s\",s);\n\n\n  map<Hash,int> cnt;\n  Hash cur=0;\n  int pos=0;\n  REP(i,n){\n    ++cnt[cur];\n    if(s[i]=='<') --pos;\n    else if(s[i]=='>') ++pos;\n    else if(s[i]=='+') cur+=Hash::pows[pos+n];\n    else cur-=Hash::pows[pos+n];\n  }\n  cnt[cur]++;\n\n  Hash target=cur;\n  cur=0;\n  pos=0;\n\n  lint res=0;\n  REP(i,n){\n    --cnt[cur];\n    Hash target2=(target<<pos)+cur;\n    res+=cnt[target2];\n    if(s[i]=='<') --pos;\n    else if(s[i]=='>') ++pos;\n    else if(s[i]=='+') cur+=Hash::pows[pos+n];\n    else cur-=Hash::pows[pos+n];\n  }\n\n  cout<<res<<endl;\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "// AtCoder Regular Contest 099\n// Problem F - Eating Symbols Hard\n#include <cstdio>\n#include <cstring>\n#include <iostream>\nusing std::cin; using std::cout; using std::endl;\n#include <algorithm>\nusing std::sort;\n#include <vector>\nusing std::vector;\n#include <queue>\nusing std::queue; using std::priority_queue;\n#include <map>\nusing std::map;\n#include <utility>\nusing std::pair;\ntypedef pair<int, int> pii;\ntypedef long long LL;\n#define pass printf(\"%s : Line.%d\\n\", __FUNCTION__, __LINE__);\nconst int maxN = 250000 + 233; // 2.5e5\nint n;\nchar opt[maxN];\nint d[maxN], df; LL h1[maxN], hf1, h2[maxN], hf2;\n//const LL P = 1e9 + 7;\nbool isp(LL x) {\n\tfor(int i = 2; i*i <= x; ++i)\n\t\tif(x % i == 0) return false;\n\treturn true;\n}\nconst LL p1 = 1000000007;\nconst LL p2 = 1000000123;\nconst LL b1 = 199;\nconst LL b2 = 211;\nLL buc1[maxN*2], buc2[maxN*2];\nLL *pow1 = &buc1[maxN], *pow2 = &buc2[maxN];\nLL inv(LL x, LL p1) {\n\treturn x == 1 ? x : (p1 - (p1 / x) * inv(p1 % x, p1)) % p1;\n}\nLL inc(LL &a, LL b1, LL p1) { return (a += b1) >= p1 ? a -= p1 : a; }\nLL dec(LL &a, LL b1, LL p1) { return (a -= b1) < 0 ? a += p1 : a; }\nmap<pii, int> M;\n\nvoid init() {\n\tpow1[0] = 1; pow2[0] = 1;\n\tpow1[1] = b1; pow1[-1] = inv(b1, p1); pow2[1] = b2; pow2[-1] = inv(b2, p2);\n\tfor(int i = 1; i <= n; ++i) pow1[i] = pow1[i-1] * b1 % p1, pow2[i] = pow2[i-1] * b2 % p2;\n\tfor(int i = -1; i >= -n; --i) pow1[i] = pow1[i+1]* pow1[-1] % p1, pow2[i] = pow2[i+1]* pow2[-1] % p2;\n\thf1 = hf2 = df = 0;\n\tfor(int i = 1; i <= n; ++i) {\n\t\tswitch(opt[i]) {\n\t\t\tcase '+':\n\t\t\t\tinc(hf1, pow1[df], p1);\n\t\t\t\tinc(hf2, pow2[df], p2);\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tdec(hf1, pow1[df], p1);\n\t\t\t\tdec(hf2, pow2[df], p2);\n\t\t\t\tbreak;\n\t\t\tcase '>':\n\t\t\t\t++df;\n\t\t\t\tbreak;\n\t\t\tcase '<':\n\t\t\t\t--df;\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main() {\n//\tfor(int i = (int)1e9; ; ++i) if(isp(i)) printf(\"%d\\n\", i), getchar();\n//\tprintf(\"%.3lfMB\\n\", sizeof(buc1)*6/1000.0/1000.0);\n\tscanf(\"%d%s\", &n, opt + 1);\n\tinit();\n\tLL cnt = 0;\n\tM.clear();\n\th1[0] = h2[0] = d[0] = 0;\n\tM[pii((h1[0] + hf1 * pow1[d[0]]) % p1, (h2[0] + hf2 * pow2[d[0]]) % p2)] = 1;\n\tfor(int i = 1; i <= n; ++i) {\n\t\td[i] = d[i-1]; h1[i] = h1[i-1]; h2[i] = h2[i-1];\n\t\tswitch(opt[i]) {\n\t\t\tcase '+':\n\t\t\t\tinc(h1[i], pow1[d[i]], p1);\n\t\t\t\tinc(h2[i], pow2[d[i]], p2);\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tdec(h1[i], pow1[d[i]], p1);\n\t\t\t\tdec(h2[i], pow2[d[i]], p2);\n\t\t\t\tbreak;\n\t\t\tcase '>':\n\t\t\t\t++d[i];\n\t\t\t\tbreak;\n\t\t\tcase '<':\n\t\t\t\t--d[i];\n\t\t\t\tbreak;\n\t\t}\n//\t\tprintf(\"[%d]: d = %d, h = {%lld, %lld}\\n\", i, d[i], h1[i], h2[i]);\n\t\tpii c(h1[i], h2[i]), ins((h1[i] + hf1 * pow1[d[i]]) % p1, (h2[i] + hf2 * pow2[d[i]]) % p2);\n\t\tif(M.find(c) != M.end()) cnt += M[c], printf(\"i = %d, cnt += %d\\n\", i, M[c]);\n\t\tif(M.find(ins) == M.end()) M[ins] = 1; else ++M[ins];\n\t}\n\tprintf(\"%lld\\n\", cnt);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <iostream>\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define debug(x) cout<<#x<<\" :: \"<<x<<endl;\n#define debug2(x,y) cout<<#x<<\" :: \"<<x<<\"\\t\"<<#y<<\" :: \"<<y<<endl;\n#define debug3(x,y,z) cout<<#x<<\" :: \"<<x<<\"\\t\"<<#y<<\" :: \"<<y<<\"\\t\"<<#z<<\" :: \"<<z<<endl;\n\n#define boost ios::sync_with_stdio(0); cin.tie(0)\n\n#define fi first\n#define se second\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double ld;\ntypedef pair<int, int> pii;\n\nconst int X = 250000 + 5;\nconst int N = 1e6 + 5;\nconst ull B = 259;\null invB;\n\n/***************************************************************************/\n\null power(ull a, ull n) {\n\tif(n == 0) return 1;\n\tull p = power(a, n>>1);\n\tp = p * p;\n\tif(n & 1) p = p * a;\n\treturn p;\n}\n\nstring S;\null powB[N];\n\ninline ull& pow(int n) {\n\tif(n < 0) n += N;\n\treturn powB[n];\n}\n\nmap<ull, int> M;\n\nint main() {\n\n\tboost;\n\tinvB = power(B, (ull(1)<<63)-1);\n\tassert(B * invB == 1);\n\n\tpow(0) = 1;\n\tfor(int i=1; i<X; i++) {\n\t\tpow(i) = pow(i-1) * B;\n\t\tpow(-i) = pow(-i+1) * invB;\n\t}\n\n\tint N; cin>>N;\n\tcin>>S;\n\n\tull phas = 0, chas = 0;\n\n\tint p = 0;\n\tfor(auto it : S) {\n\t\tif(it == '+') phas += pow(p);\n\t\telse if(it == '-') phas -= pow(p);\n\t\telse if(it == '>') p++;\n\t\telse p--;\n\t}\n\n\tll ans = 0;\n\tM[phas]++;\n\n\tfor(auto it : S) {\n\t\tif(it == '+') chas += pow(p);\n\t\telse if(it == '-') chas -= pow(p);\n\t\telse if(it == '>') p++;\n\t\telse p--;\n\n\t\tans += M[chas];\n\t\tM[chas + pow(p) * phas]++;\n\t}\n\n\tcout<<ans<<\"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define int long long\n#define ull unsigned long long\n#define Accepted 0;\n\n\nconst int Maxv = 500010; \nconst ull Prime1 = 239; \nconst ull Prime2 = 211238502252323207ll; \n                            \nint val[Maxv], idx[Maxv], ans, n; \null Hash[Maxv]; \nchar s[Maxv]; \n\nstd::unordered_map<ull, int> Map; \n\ninline void PreHandle() {\n    val[n] = 1; \n    for (int i = n + 1; i <= (n << 1); i++)\n        val[i] = val[i - 1] * Prime1; \n    for (int i = n - 1; i >= 0; i--)\n        val[i] = val[i + 1] * Prime2; \n}\n\nsigned main() {\n    scanf(\"%d\", &n); \n    scanf(\"%s\", s); \n\n    PreHandle(); \n\n    for (int i = 0; i < n; i++) {\n        Hash[i + 1] = Hash[i]; \n        idx[i + 1] = idx[i]; \n\n        if (s[i] == '>')\n            idx[i + 1]++; \n        if (s[i] == '<')\n            idx[i + 1]--;\n        if (s[i] == '+')\n            Hash[i + 1] += val[n + idx[i + 1]]; \n        if (s[i] == '-')\n            Hash[i + 1] -= val[n + idx[i + 1]]; \n    }\n    \n    for (int i = n; i >= 0; i--) {\n        ull tmp = Hash[i] + Hash[n] * val[n + idx[i]];\n        ans += Map[tmp]; \n        Map[ Hash[i] ]++;\n    }\n\n    printf(\"%lld\\n\", ans);\n\n    return Accepted\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <cmath>\n#include <cstdio>\n#include <cctype>\n#include <ctime>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <complex>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cwchar>\n#include <cwctype>\n#include <exception>\n#include <locale>\n#include <numeric>\n#include <new>\n#include <stdexcept>\n#include <limits>\n#include <valarray>\n#include <set>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <list>\n#include <utility>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int INF = 1e9 + 7;\n\nconst pair<LL, LL> HMOD = MP(998244353, 1004535809), HRAD = MP(243, 19683), HIRAD = MP(607984215, 858522653);\nmap<pair<LL, LL>, int> S;\nint n;\nchar ch[250005];\n\nint main()\n{\n\tscanf(\"%d%s\", &n, &ch);\n\tpair<LL, LL> cur = MP(1, 1), cnt = MP(0, 0);\n\trep(i, n) {\n\t\tif(ch[i] == '+') cnt.first = (cnt.first + cur.first) % HMOD.first;\n\t\tif(ch[i] == '-') cnt.first = (cnt.first - cur.first + HMOD.first) % HMOD.first;\n\t\tif(ch[i] == '<') cur.first = cur.first * HIRAD.first % HMOD.first;\n\t\tif(ch[i] == '>') cur.first = cur.first * HRAD.first % HMOD.first;\n\t\tif(ch[i] == '+') cnt.second = (cnt.second + cur.second) % HMOD.second;\n\t\tif(ch[i] == '-') cnt.second = (cnt.second - cur.second + HMOD.second) % HMOD.second;\n\t\tif(ch[i] == '<') cur.second = cur.second * HIRAD.second % HMOD.second;\n\t\tif(ch[i] == '>') cur.second = cur.second * HRAD.second % HMOD.second;\n\t\tS[cnt] ++;\n\t}\n\tpair<LL, LL> ss = cnt;\n\tLL ans = S[ss];\n\tcur = MP(1, 1); cnt = MP(0, 0);\n\trep(i, n) {\n\t\tif(ch[i] == '+') cnt.first = (cnt.first + cur.first) % HMOD.first;\n\t\tif(ch[i] == '-') cnt.first = (cnt.first - cur.first + HMOD.first) % HMOD.first;\n\t\tif(ch[i] == '<') cur.first = cur.first * HIRAD.first % HMOD.first;\n\t\tif(ch[i] == '>') cur.first = cur.first * HRAD.first % HMOD.first;\n\t\tif(ch[i] == '+') cnt.second = (cnt.second + cur.second) % HMOD.second;\n\t\tif(ch[i] == '-') cnt.second = (cnt.second - cur.second + HMOD.second) % HMOD.second;\n\t\tif(ch[i] == '<') cur.second = cur.second * HIRAD.second % HMOD.second;\n\t\tif(ch[i] == '>') cur.second = cur.second * HRAD.second % HMOD.second;\n\t\tS[cnt] --;\n\t\tans += S[MP((cnt.first + cur.first * ss.first) % HMOD.first, (cnt.second + cur.second * ss.second) % HMOD.second)];\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<array>\n#include<map>\n\nint powMod(int base,int exp,int mod){\n\tif(exp<0)exp+=mod-1;\n\tint ans=1;\n\tfor(;;){\n\t\tif(exp&1)ans=(int64_t)ans*base%mod;\n\t\texp>>=1;if(exp==0)return ans;\n\t\tbase=(int64_t)base*base%mod;\n\t}\n}\nstruct prg{\n\tstatic int constexpr NPRIME=3;\n\tusing value_t=std::array<int,NPRIME>;\n\tstatic std::array<int,NPRIME> constexpr PRIMES{{1073741789,1073741783,1073741741}};\n\tstatic int constexpr BASE=250007;\n\n\tvalue_t value;\n\tint offset;\n\tconstexpr prg():value{},offset{}{}\n\n\tstatic prg const left,right,inc,dec;\nprivate:\n\tconstexpr prg(value_t v,int o):value(v),offset(o){\n\t\tfor(int p=0;p<prg::NPRIME;++p){\n\t\t\tvalue[p]=value[p]%PRIMES[p];\n\t\t\tif(value[p]<0)value[p]+=PRIMES[p];\n\t\t}\n\t}\n};\n\nprg operator*(prg A,prg B){\n\tprg AB;\n\tAB.offset=A.offset+B.offset;\n\tfor(int p=0;p<prg::NPRIME;++p){\n\t\tAB.value[p]=(A.value[p]+1LL*powMod(prg::BASE,A.offset,prg::PRIMES[p])*B.value[p])%prg::PRIMES[p];\n\t}\n\treturn AB;\n}\n\nstd::ostream& operator<<(std::ostream& stream,prg p){\n\treturn stream<<p.value[0]<<'|'<<p.offset;\n}\n\nstd::array<int,prg::NPRIME> constexpr prg::PRIMES;\nprg const prg::left {{ 0, 0, 0},-1};\nprg const prg::right{{ 0, 0, 0}, 1};\nprg const prg::inc  {{ 1, 1, 1}, 0};\nprg const prg::dec  {{-1,-1,-1}, 0};\n\nint main(){auto&O=std::cout;\n#ifdef _GLIBCXX_DEBUG\nstd::stringstream I(R\"(\n48\n-+><<><><><>>>+-<<>->>><<><<-+<>><+<<>+><-+->><<\n)\");\n#else\nauto&I=std::cin;std::ios::sync_with_stdio(0);I.tie(0);\n#endif\n\nint n;I>>n;\nstd::string st;st.reserve(n);I>>st;\nstd::vector<prg> prefix(n+1);\nfor(int i=0;i<n;++i){\n\tprefix[i+1]=prefix[i]*(\n\t\tst[i]=='<'?prg::left:\n\t\tst[i]=='>'?prg::right:\n\t\tst[i]=='+'?prg::inc:\n\t\tst[i]=='-'?prg::dec:throw 0\n\t);\n}\nstd::map<prg::value_t,int> value_count;\nvalue_count.emplace(prefix[n].value,1);\nint64_t ans=0;\nfor(int i=n;i--;){\n\t// consider programs B starting at (i) have the same value as whole program\n\t// so (AB) = (A)*(B) = prefix[i]*(B)\n\tauto it=value_count.find((prefix[i]*prefix[n]).value);\n\tif(it!=value_count.end()){\n\t\tans+=it->second;\n\t}\n\t++value_count[prefix[i].value];\n}\nO<<ans<<'\\n';\n\n}"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                         `!!!;'                                                                 `\n                                                           '%$@########################&&%:.                                                    `\n                                                       .%###################################%.                                                  `\n                                                    .`|######################################%                                                  `\n                                                 .!@###############################################$'                                           `\n                                              .!@#########################@@@#########################&;.                                       `\n                                             :@##################@@@&&@@@$!!%&@@@@@@@###################&'                                      `\n                                          :&################@@@&$%%||||!!:'':;!!||%|!%&@@#################%`                                    `\n                                         |###############@@&&$%|!;;::::':'''':::;;!!|%%%$&&@###############$`                                   `\n                                      :&#############@&$%||||!;'````````````'''```'':::'':!|$@@###############;                                 `\n                                    :@#############@$$%|!;;;;:'``````...```...`...`'':::''';|%$$$&############&'                                `\n                                   |##############&$$$%||!!;:'`````..````....`...```''::::;!!||$&&@@###########&'                               `\n                                 !##############@$%|!!!;::'''`````...``.....`````````'''::::;;::!|%$&############|                              `\n                                :@##########@&%!:'`::;;:'``....```.......  .``....````````````'':;!|%$@############;                            `\n                               ;##########@%;```...`'''`...  .....    ................   .`.    `:!!!!%%%&#########|                            `\n                              ;##########&|:.`'`. ..`...   .......   .....  ..  .....   ...   .'':!!:.`''!@#########|.                          `\n                              !##########|'`.;!`       .  ......          ..    .      ....  .::'`. .. .`'|@########@:                          `\n                              ;##########%'`'%!    ..       .  .                ..    .```.   ';:`..``.`':|@########@:                          `\n                              !##########$:;$&;                     . `|%;.  `;||;::`.``';;.  .;!: `;:`';|$#########@!.                         `\n                              !##########@$&@|. ...... .`':!|;` !$|%%'!##$' `|####$:`:;:!&$:. '$&!';!!||%&############;                         `\n                             `$#############&:  `!!'`:;;;||%@&!'!&&$;.|##%`.|#####%`'$@$&##%` .:||;;;;%@##############!                         `\n                             :@#############|. .!&@|;%@@@@@&@@#@&@#@&@############@@#####@:   .`'%@%!!&###############!                         `\n                             :@############@;   :&@!;$###@|%|!$@@######################@%`    .;|!;!|%@###############!                         `\n                             :@############@:   `$#$%#@@##&@################@$$$&$%|!'       `%#@|;':|&###############!                         `\n                              !##########@$%:    |####@&######$;.                          ..`'`      ;@##############!                         `\n                              !##########!       ;#########|.                             `;`         ;###############!                         `\n                              ;##########;       `%######;                           '$###&:          `%@############&'                         `\n                               !########@:       .'.       .:;`                   .|%:                   !##########&'                          `\n                               !########@:                                                               ;#########@:                           `\n                                !######%.     !##&;.        .                  `%&!`             '&###&' !#########!                            `\n                                |#######;.%###!                 `!&###@|;;%@###%.    ';;|&$:;;`     |#%. .%###%$###!                            `\n                               !#######|  `%#&'    |##&$####&:     !##########;    `%#####%.!#|.   .%@:   ;###;`%##!                            `\n                                !#$!$##!   :@#!        .|###$'.    ;##|.  :&#@;    .``::`          ;@|.   :@#@: `$#|                            `\n                                :&&|&##;   :&#!                   :&##;    .%##!                   !&'    ;@##!  |#!                            `\n                                 |@@##@;  .`%#!                  '$##;      ;##$`                 :@!    .|##@; :&!                             `\n                                 !&|&##%:'.  :&!                :@#%.        .%##;               |&!.   `|@!   `$!                              `\n                                 '$%%###&;.   '&&'            `%##&'           |##@&:    ...;&&&@;     .;&#|':;$&:                              `\n                                 .|######&;        '$@@@@@@@@#|                                        :&######%`                               `\n                                   !#####&:                                                           '$#####@:                                 `\n                                   '$#####@:                                                          ;#####$`                                  `\n                                     '&####%.                 ``                                     '$#####;                                   `\n                                      !#####$'                |@:  .:%|;;;;!$#####@#|               '&###$:                                     `\n                                       :&####&:               ;####################@:    ':`       `%###@:                                      `\n                                         ;#####@%:.                                         `'';|@######$`                                      `\n                                         `$######@|`                                        !#&||@#####$`                                       `\n                                          :&######@%'.                        .`''''` .';!|%@#@$$@####&:                                        `\n                                           |######@|'.   ;##$!!%@##########################@:   '$####;                                         `\n                                           :&#####$;''.`%#########&'             `|@$:         .%###@;                                          `\n                                            :@####@;          |#@##&$;         `|%'           .|####!                                           `\n                                              !####@;                                .        |####!                                            `\n                                               :@###@|`         .                 `|!.       |####%.                                            `\n                                                .|####!          `;$@%|!!!!!%&&@#$;.        !#####|                                             `\n                                                .%####&:              '%&@@@|`             '&#####|                                             `\n                                                .%#####|.                                 :&######%`                                            `\n                                       :|||;`    !#######;                              .%#####@@#####@$;.                                      `\n                                   `$#############&%!%#####|.                         :@####%:..'!&######@;                                     `\n                                  `$#############|`..'%#######!                      ;####&;.    .'%#######!                                    `\n                                .|##############@!`    .'%#########%'.          '%#####%`           :@#######@%;:.                              `\n                          ;%|;. !############%::;'        `!&############@&&@#######@%'               !###########&'                            `\n                         !################$'   .:'         '|&######################$:.               :@#############@@@@@@;                    `\n                      ';$##&;:&###########$`                  :|$@################%:.                 !#####################@;                  `\n                   '%####@$!:.  `%#########!                    .:!%&@#######@%!;'.                   |##############%!$@####!                  `\n                .|#######&;'. .    |#######%.                      .':;!!!!!!;`...                   .|############|. :$@@####%.                `\n                !####&$&@#@!:'.       ;#####%`                  .`';;'... ..''``.                    !##########%`    ''':$######$`             `\n                ;#####@$$;`%&:.         `%####;                   .:;;:'':;||!:`                    !#########!          :&#@@####!             `\n          '%######@######!   !!            :$@$`                    ...`.'::`..                   '$######@!`         '|$$&!!@#######@!.        `\n     '$#########@&$$@######@:    ;: . `'    ....                      ...``.                    `$######&'           '!;`'!@######&&########$'  `\n  ;############@#@@@@@$|%@###$`  `!!.;' .     :!.                                             .%#####!.            .;::&####|`..`  ..;@########!'\n  |########&|;'``..`:'    ..!##%:.    ;;      `.                                            .|###|`             `'|###@&$|`  ..   .`|&&@#######%:\n  |###@#@@#&|:`.`';;:;!!!;:;''!$##&;'.  .'%; .;&###&|$!                                     '$; .|$:;|`   ...;&###$'    ....      :||%&########%:\n  |#######@$;!%%:```           .!@###&|`   :|'!########@#!                                ;@! :@####%'. `|@###&:         ..`:::%$$&$$$&@##@@@##|:\n  |########$;::'`         .`.     `%#####%!: .. !#####%` !#%.                        !; '%; !#############&:          `::`.```. .':.  :$@&&&###|:\n  !####@%:::;;:::::` .........            '.  !#######%;;';; `%#&'             ;&: `;``$@!%########&&##&|::::'.             ':.     `!%@@######|:\n  !#####%;;::.       ...... ....`..  ..  '::!|&########$';%`.'` .;%:        !#$';$%|&$!&##########$'        `';;;;!&##&%||||||%;`   .:|&###@###|:\n  |#######|`...      `|$&&$$!`....           ;$:  :&#@:     `'''``.   .%########&'  .%#@&$%$#####$`     ....`:%&@@@@@@&&@@!`.      .`'%@#######|'\n  |######@@$:       .`..`!@&$&&&&:                ;@#######@@#$%@######&$;    '%@##%!@###@&&@####%.     `!&@@@@@$:..`..``.``...     `|&####@@##!'\n  ;###&|;::!&#&%%%%:         .'::::;|$&&$%|'..;%%&#######%;$########@&#####%`   '|@###;    '%####$;::::::`            '!|%%%%%%%%%&#$:'::.'%###|'\n  `%###@|;|%$%$@#&|;::::`          '|%%%%%$%|%|;';$##@|'.   |######&'     .:|$%: :&@|'.     !####%.              `::;:!$@######&%%%%%!'  ':;&##|:\n  '$##%:.    :&##@####@$;.  ..                    `$|     :; !#####|      '|%:  ``    ...   !####!          .  ..:&#@@@@##@&||$;         :&####|'\n  !####&@@&;        ...`.'%@##@@#@@&!`            :&&!.       !###&'  :||:.`   !%'     ``:$######@@@&&@@@&@##$;``....             |@@@@########!'\n  !#######@$||!:          ';!;;;!&###&|||||||||||%&##@!`.     !###&||%!!!:   .:;`        `;;%####$;:;;;;;;;;;;;::.         '||||||&#####%!;;$##!`\n  `%#&:.`:!||||||%@#@%;::;;;'                     ;@@:    .. .%###|.   `:::'  .:!;'`':'`   `$####!             ':;;;;!%@@&%%%|;`        `;%&###|:\n  .%##|..       '$##@@@@@@#&:...`..              `$#$'        !##%`   ..`.`:%@@! '%@$:''. .`|####|... .........`:%###@#@@@|`        ....`%#####|:\n  !###@&!       .`.```':!&##@&&&&$:              '&#%.        !#&'     ````.    .```:%&&&&&@#####@!':|$&&$&&&&&&&&&@##|`````.       !@@@#######!'\n  :&#########@$||||:            `::::;;;;;!!;;;:;$###$'  .'`  |#@|.  .:;;:.                `%####%:''':::::`               `!||&##$;;;:::.  ;##|:\n  .%#@$%$%%%%%$@###$::::::'.           ...`;|!::!&##@$%|||!' .%##&%%$%'        `'.         :&####!                  .':::'::%@&$%%!` .!!':;$###%:\n  :&#############@|.              .  '$##################&;..!@###@#######%'.             .!#####!          .              `$#####@|``;&|!&####|:\n  |####&%'   .''''':|@###@$$$$$$%;.             |####%`      .|#@;.         .;$$$%$&$$$$$$&######$:..:|%$$$$$$$&&&&@######&;'''.    ;$&########|:\n  |#######@%;;`    '!|!||$#######&|!!!;;;!!!;`.!#####@: .;|!!|&#$'   `:'':;;$######################################%!|!!!!!;.  .`;|&######@####%:\n  |############$!''''..';$&&&&@########################$;'!;`:@#&:``'|$@######@@@@&&&&&&&@#######@&&&&&&&&&&&@@&&&&$|:.    .`''$########@&@####%:\n  |###&%$&#################@%;'  ..      `|@############$: `%@###########$`  `%%:.     . :@######|         !#####################@$%&##########%:\n  |#######################################@&&@######################@@&@#######################################################################%:\n*/\n\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <map>\n#include <set>\n#include <stack>\n#include <ctime>\n#include <cmath>\n#include <queue>\n#include <cstdio>\n#include <cctype>\n#include <vector>\n#include <bitset>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <fstream>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ninline char gc() {\n    static const int L = 233333;\n    static char sxd[L], *sss = sxd, *ttt = sxd;\n    if (sss == ttt) {\n        ttt = (sss = sxd) + fread(sxd, 1, L, stdin);\n        if (sss == ttt) {\n            return EOF;\n        }\n    }\n    return *sss++;\n}\n\n#ifndef _AT_HOME\n#define dd c = gc()\n#else\n#define dd c = getchar()\n#endif\ninline char readalpha() {\n    char dd;\n    for (; !isalpha(c); dd);\n    return c;\n}\n\ninline char readchar() {\n    char dd;\n    for (; c == ' '; dd);\n    return c;\n}\n\ntemplate <class T>\ninline bool read(T& x) {\n    bool flg = false;\n    char dd;\n    x = 0;\n    for (; !isdigit(c); dd) {\n        if (c == '-') {\n            flg = true;\n        } else if(c == EOF) {\n            return false;\n        }\n    }\n    for (; isdigit(c); dd) {\n        x = (x * 10) + (c ^ 48);\n    }\n    if (flg) {\n        x = -x;\n    }\n    return true;\n}\n#undef dd\n\ntemplate <class T>\ninline void write(T x) {\n    if (x < 0) {\n        putchar('-');\n        x = -x;\n    }\n    if (x < 10) {\n        putchar(x | 48);\n        return;\n    }\n    write(x / 10);\n    putchar((x % 10) | 48);\n}\n\ntemplate <class T>\ninline void writesp(T x) {\n    write(x);\n    putchar(' ');\n}\n\ntemplate <class T>\ninline void writeln(T x) {\n    write(x);\n    puts(\"\");\n}\n\n#define lowbit(x) (x & -x)\n\nnamespace dfcmd {\n\n    typedef long long LL;\n    typedef unsigned long long ULL;\n\n    const int maxn = 250005;\n    const ULL bse = 233;\n\n    int n;\n    char s[maxn];\n    map<ULL, int> mp;\n    ULL f[maxn];\n    int g[maxn];\n\n    int Main() {\n        scanf(\"%d%s\", &n, s + 1);\n        ULL inv = 1, xx = bse;\n        for (int i = 1; i <= 63; ++i) {\n            inv = inv * xx;\n            xx = xx * xx;\n        }\n        // cout << bse << ' ' << inv << ' ' << bse * inv << endl;\n        f[0] = 0, g[0] = 1;\n        for (int i = 1; i <= n; ++i) {\n            f[i] = f[i - 1], g[i] = g[i - 1];\n            switch (s[i]) {\n                case '+':\n                    f[i] += g[i];\n                    break;\n                case '-':\n                    f[i] -= g[i];\n                    break;\n                case '<':\n                    g[i] *= inv;\n                    break;\n                case '>':\n                    g[i] *= bse;\n                    break;\n                default:\n                    puts(\"dfcmd\");\n            }\n            mp[f[i]]++;\n        }\n        LL ans = 0;\n        for (int i = 1; i <= n; ++i) {\n            ans += mp[f[n] * g[i - 1] + f[i - 1]];\n            mp[f[i]]--;\n        }\n        writeln(ans);\n        return 0;\n    }\n}\n\nint main() {\n    return dfcmd::Main();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) std::cerr << #x << \" = \" << (x) << std::endl\nusing ll = long long;\nstd::mt19937 mt{std::random_device{}()};\ntemplate <typename T>\nconstexpr std::pair<T, T> extgcd(const T a, const T b)\n{\n    if (b == 0) { return std::pair<T, T>{1, 0}; }\n    const auto p = extgcd(b, a % b);\n    return {p.second, p.first - p.second * (a / b)};\n}\ntemplate <typename T>\nconstexpr T inverse(const T a, const T mod) { return (mod + extgcd(a, mod).first % mod) % mod; }\nconstexpr int H = 5;  //関数値サンプルの個数\nconstexpr ll MOD1 = 1000000007LL, MOD2 = 1000000009LL;\nconstexpr ll X[H] = {2371983LL, 1231LL, 123123LL, 4329075LL, 134121LL};\nconstexpr ll XINV1[H] = {inverse(X[0], MOD1), inverse(X[1], MOD1), inverse(X[2], MOD1), inverse(X[3], MOD1), inverse(X[4], MOD1)};\nconstexpr ll XINV2[H] = {inverse(X[0], MOD2), inverse(X[1], MOD2), inverse(X[2], MOD2), inverse(X[3], MOD2), inverse(X[4], MOD2)};\ntemplate <typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, const std::pair<S, T>& p) { return (os << \"<\" << p.first << \",\" << p.second << \">\"); }\ntemplate <typename T, typename A>\nstd::ostream& operator<<(std::ostream& os, const std::vector<T, A>& v)\n{\n    os << \"[\";\n    for (const auto& p : v) { os << p << \",\"; }\n    return (os << \"]\\n\");\n}\nint main()\n{\n    int N;\n    std::string S;\n    std::cin >> N >> S;\n    using P = std::pair<ll, ll>;\n    std::vector<int> deg(N + 1, 0);\n    std::vector<std::vector<P>> value(N + 1, std::vector<P>(H, {0LL, 0LL}));\n    auto plus = [](const P& p1, const P& p2) { return P{(p1.first + p2.first) % MOD1, (p1.second + p2.second) % MOD2}; };\n    auto minus = [](const P& p1, const P& p2) { return P{(p1.first + MOD1 - p2.first) % MOD1, (p1.second + MOD2 - p2.second) % MOD2}; };\n    auto rshift = [](const P& p, const int i) { return P{p.first * X[i] % MOD1, p.second * X[i] % MOD2}; };\n    auto lshift = [](const P& p, const int i) { return P{p.first * XINV1[i] % MOD1, p.second * XINV2[i] % MOD2}; };\n    auto mul = [](const P& p1, const P& p2) { return P{p1.first * p2.first % MOD1, p1.second * p2.second % MOD2}; };\n    for (int i = N - 1; i >= 0; i--) {\n        if (S[i] == '-') {\n            deg[i] = deg[i + 1];\n            for (int j = 0; j < H; j++) { value[i][j] = minus(value[i + 1][j], {1, 1}); }\n        } else if (S[i] == '+') {\n            deg[i] = deg[i + 1];\n            for (int j = 0; j < H; j++) { value[i][j] = plus(value[i + 1][j], {1, 1}); }\n        } else if (S[i] == '>') {\n            deg[i] = deg[i + 1] + 1;\n            for (int j = 0; j < H; j++) { value[i][j] = rshift(value[i + 1][j], j); }\n        } else {\n            deg[i] = deg[i + 1] - 1;\n            for (int j = 0; j < H; j++) { value[i][j] = lshift(value[i + 1][j], j); }\n        }\n    }\n    // show(deg);\n    // show(value);\n    constexpr int L = 250000;\n    std::vector<std::vector<P>> power(L + 1, std::vector<P>(H, {1, 1}));\n    std::vector<std::vector<P>> invpower(L + 1, std::vector<P>(H, {1, 1}));\n    auto invp = [&](const int i, const int j) { return i >= 0 ? invpower[i][j] : power[-i][j]; };\n    for (int i = 1; i <= L; i++) {\n        for (int j = 0; j < H; j++) { power[i][j] = rshift(power[i - 1][j], j), invpower[i][j] = lshift(power[i - 1][j], j); }\n    }\n    std::vector<P> answer(H);\n    for (int i = 0; i < H; i++) { answer[i] = value[0][i]; }\n    //show(answer);\n    std::vector<std::vector<P>> hash(N + 1, std::vector<P>(H));\n    for (int i = 0; i <= N; i++) {\n        for (int j = 0; j < H; j++) { hash[i][j] = mul(minus(value[i][j], answer[j]), invp(deg[i], j)); }\n    }\n    //    show(hash);\n    using VP = std::vector<P>;\n    std::map<VP, ll> mp;\n    ll ans = 0;\n    for (int i = 0; i <= N; i++) {\n        std::vector<P> obj(H);\n        for (int j = 0; j < H; j++) { obj[j] = plus(hash[i][j], mul(invp(deg[i], j), answer[j])); }\n        if (mp.find(obj) != mp.end()) { ans += mp[obj]; }\n        mp[hash[i]]++;\n    }\n    std::cout << ans << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n#define dbg(x...) do { cout << \"\\033[32;1m \" << #x << \" -> \"; err(x); } while (0)\nvoid err() { cout << \"\\033[39;0m\" << endl; }\ntemplate<template<typename...> class T, typename t, typename... A>\nvoid err(T<t> a, A... x) { for (auto v: a) cout << v << ' '; err(x...); }\ntemplate<typename T, typename... A>\nvoid err(T a, A... x) { cout << a << ' '; err(x...); }\n#else\n#define dbg(...)\n#endif\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef vector<int> vi;\ntemplate<class T> using vc=vector<T>;\ntemplate<class T> using vvc=vc<vc<T>>;\ntemplate<class T> void mkuni(vector<T>&v)\n{\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\ntemplate<class T>\nvoid print(T x,int suc=1)\n{\n    cout<<x;\n    if(suc==1) cout<<'\\n';\n    else cout<<' ';\n}\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1)\n{\n    for(int i=0;i<v.size();i++)\n    print(v[i],i==(int)(v.size())-1?suc:2);\n}\nconst int mod=1e9+7;\nconst int ptr=3;\nint c[ptr],r[ptr];\nll quick(ll a,ll b=mod-2)\n{\n    ll ret=1;\n    while(b)\n    {\n        if(b&1) ret=ret*a%mod;\n        a=a*a%mod;\n        b>>=1;\n    }\n    return ret;\n}\nint main()\n{\n    srand(time(NULL));\n    int n;\n    cin>>n;\n    string s;\n    cin>>s;\n    for(int i=0;i<ptr;i++)\n    {\n        c[i]=1000;\n        r[i]=quick(c[i]);\n    }\n    vc<ll> C(ptr);\n    reverse(s.begin(),s.end());\n    for(int i=0;i<n;i++)\n    {\n        for(int j=0;j<ptr;j++)\n        {\n            if(s[i]=='+')\n                C[j]=(C[j]+1)%mod;\n            else if(s[i]=='-')\n                C[j]=(C[j]-1+mod)%mod;\n            else if(s[i]=='>')\n                C[j]=C[j]*c[j]%mod;\n            else C[j]=C[j]*r[j]%mod;\n        }\n    }\n    map<vc<ll>,int> cnt;\n    vc<ll> A(ptr,1),cur(ptr);\n    ll ans=0;\n    cnt[cur]++;\n    for(int i=0;i<n;i++)\n    {\n        for(int j=0;j<ptr;j++)\n        {\n            if(s[i]=='+')\n            {\n                C[j]=(C[j]-A[j]+mod)%mod;\n                cur[j]=(cur[j]-A[j]+mod)%mod;\n            }\n            else if(s[i]=='-')\n            {\n                C[j]=(C[j]+A[j])%mod;\n                cur[j]=(cur[j]+A[j])%mod;\n            }\n            else if(s[i]=='>')\n            {\n                A[j]=A[j]*r[j]%mod;\n            }\n            else{\n                A[j]=A[j]*c[j]%mod;\n            }\n        }\n        //dbg(i,cur,C);\n        ans+=cnt[C];\n        cnt[cur]++;\n    }\n    print(ans);\n}"
  },
  {
    "language": "C++",
    "code": "//teja349\n#include <bits/stdc++.h>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <utility>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <iomanip> \n//setbase - cout << setbase (16); cout << 100 << endl; Prints 64\n//setfill -   cout << setfill ('x') << setw (5); cout << 77 << endl; prints xxx77\n//setprecision - cout << setprecision (14) << f << endl; Prints x.xxxx\n//cout.precision(x)  cout<<fixed<<val;  // prints x digits after decimal in val\n\nusing namespace std;\n#define f(i,a,b) for(i=a;i<b;i++)\n#define rep(i,n) f(i,0,n)\n#define fd(i,a,b) for(i=a;i>=b;i--)\n#define pb push_back\n#define mp make_pair\n#define vi vector< int >\n#define vl vector< ll >\n#define ss second\n#define ff first\n#define ll long long\n#define pii pair< int,int >\n#define pll pair< ll,ll >\n#define sz(a) a.size()\n#define inf (1000*1000*1000+5)\n#define all(a) a.begin(),a.end()\n#define tri pair<int,pii>\n#define vii vector<pii>\n#define vll vector<pll>\n#define viii vector<tri>\n#define mod (1000*1000*1000+7)\n#define pqueue priority_queue< int >\n#define pdqueue priority_queue< int,vi ,greater< int > >\n\n//std::ios::sync_with_stdio(false);   \nll ans10[512345],ans13[512345],powe13[512345],powe10[512345],invpowe10[512345];\nll invpowe13[512345],inv[1234],p[512345];\nll extend_gcd(ll a,ll b,ll &x,ll &y){\n\tif(b==0){\n\t\tx=1;\n\t\ty=0;\n\t\treturn a;\n\t}\n\tll x1,y1;\n\tll ans =extend_gcd(b,a%b,x1,y1);\n\tx=y1;\n\ty=x1-(a/b)*y1;\n\n\treturn ans;\n}\nmap<ll,ll> seti10,seti13; \nint main(){\n    std::ios::sync_with_stdio(false);\n    ll n;\n    cin>>n;\n    string s;\n    cin>>s;\n    ll i;\n    ll initp=250003;\n    powe10[0]=1;\n    powe13[0]=1;\n    invpowe10[0]=1;\n    invpowe13[0]=1;\n    f(i,1,200){\n\t\tll x,y;\n\t\tll val=extend_gcd(mod,i,x,y);\n\t\tif(y>0)\n\t\t\tinv[i]=y%mod;\n\t\telse{\n\t\t\t\tinv[i]=(y+mod)%mod;\n\t\t}\n\t}\n\tll inv10=inv[193];\n\tll inv13=inv[37];\n    f(i,1,512345){\n    \tpowe13[i]=powe13[i-1]*37;\n    \tpowe10[i]=powe10[i-1]*193;\n    \tpowe10[i]%=mod;\n    \tpowe13[i]%=mod;\n    \tinvpowe10[i]=invpowe10[i-1]*inv10;\n    \tinvpowe10[i]%=mod;\n    \tinvpowe13[i]=invpowe13[i-1]*inv13;\n    \tinvpowe13[i]%=mod;\n    }\n    ans10[0]=0;\n    ans13[0]=0;\n    p[0]=initp;\n    \n    f(i,1,s.length()+1){\n    \tans10[i]=ans10[i-1];\n    \tans13[i]=ans13[i-1];\n    \tp[i]=p[i-1];\n    \tif(s[i-1]=='+'){\n    \t\tans10[i]=ans10[i-1]+powe10[p[i]];\n    \t\tans13[i]=ans13[i-1]+powe13[p[i]];\n\n    \t}\n    \telse if(s[i-1]=='-'){\n    \t\tans10[i]=ans10[i-1]-powe10[p[i]];\n    \t\tans13[i]=ans13[i-1]-powe13[p[i]];\n    \t}\n    \telse if(s[i-1]=='<'){\n    \t\tp[i]--;\n    \t}\n    \telse{\n    \t\tp[i]++;\n    \t}\n    \tans10[i]%=mod;\n    \tans10[i]+=mod;\n    \tans10[i]%=mod;\n    \tans13[i]%=mod;\n    \tans13[i]+=mod;\n    \tans13[i]%=mod;\n    \tseti13[ans13[i]]++;\n    \tseti10[ans10[i]]++;\n    \t//cout<<ans10[i]<<\" \"<<ans13[i]<<endl;\n    }\n    ll val,val1,j10,j13;\n    ll total=0;\n    f(i,1,n+1){\n    \tval=initp-p[i-1];\n    \tval*=-1;\n    \tif(val>=0){\n    \t\tval1=powe13[val];\n    \t\tval=powe10[val];\n    \t\t  \n    \t}\n    \telse{\n    \t\tval1=invpowe13[val];\n    \t\tval=invpowe10[val];\n    \t}\n    \tj10=ans10[n]*val;\n    \tj10%=mod;\n    \tj10+=ans10[i-1];\n    \tj13=ans13[n]*val1;\n    \tj13%=mod;\n    \tj13+=ans13[i-1];\n    \tj10%=mod;\n    \tj13%=mod;\n    \ttotal+=min(seti10[j10],seti13[j13]);\n        //assert(seti10[j10]==seti13[j13]);\n    \tseti13[ans13[i]]--;\n    \tseti10[ans10[i]]--;\n    }\n    cout<<total<<endl;\n\n\n\n\n    return 0;  \n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long LL;\n\n#ifdef BTK\n#define DEBUG if(1)\n#else\n#define CIN_ONLY if(1)\nstruct cww {cww() {CIN_ONLY{ios::sync_with_stdio(false); cin.tie(0);}}\n}star;\n#define DEBUG if(0)\n#endif\n\n#define ALL(v) (v).begin(),(v).end()\n#define REC(ret, ...) std::function<ret (__VA_ARGS__)>\ntemplate <typename T>inline bool chmin(T &l, T r){bool a = l>r; if (a)l = r; return a;}\ntemplate <typename T>inline bool chmax(T &l, T r){bool a = l<r; if (a)l = r; return a;}\ntemplate <typename T>istream& operator>>(istream &is, vector<T> &v){for (auto &it : v)is >> it;return is;}\n\nclass range {private: struct I { int x; int operator*() { return x; }bool operator!=(I& lhs) { return x<lhs.x; }void operator++() { ++x; } }; I i, n;public:range(int n) :i({ 0 }), n({ n }) {}range(int i, int n) :i({ i }), n({ n }) {}I& begin() { return i; }I& end() { return n; }};\n\nint N;\nstring S;\nusing H = unsigned long long;\nnamespace RollHash {\n\tconstexpr int RANGE = 2123456;\n\tconstexpr int MID = 512345;\n\tconstexpr int num = 2;\n\tstruct pH {\n\t\tH v[num];\n\t\tH& operator[](int i) {\n\t\t\treturn v[i];\n\t\t}\n\t};\n\tconstexpr H h[num] = { 1000000007llu,1000000009llu };\n\tpH RS[RANGE];\n\tmap<pair<H, H>, LL> cnt;\n\tvoid init() {\n\t\tcnt.clear();\n\t\tfor (int i : range(num)) {\n\t\t\tRS[0][i] = 1;\n\t\t}\n\t\tfor (int i : range(1,RANGE)) {\n\t\t\tfor (int j : range(num)) {\n\t\t\t\tRS[i][j] = RS[i - 1][j] * h[j];\n\t\t\t}\n\t\t}\n\t}\n\tinline pH add(pH has, int pos) {\n\t\tfor (int i : range(num)) {\n\t\t\thas[i] += RS[MID + pos][i];\n\t\t}\n\t\treturn has;\n\t}\n\tinline pH sub(pH has, int pos) {\n\t\tfor (int i : range(num)) {\n\t\t\thas[i] -= RS[MID + pos][i];\n\t\t}\n\t\treturn has;\n\t}\n\tinline pH sub(pH l, pH r) {\n\t\tfor (int i : range(num)) {\n\t\t\tl[i] -= r[i];\n\t\t}\n\t\treturn l;\n\t}\n\n\tconstexpr int A = 512345;\n\tinline pH moveCenter(pH has, int nowCenter) {\n\t\tconst int movement = A - nowCenter;\n\t\tfor (int i : range(num)) {\n\t\t\thas[i] *= RS[movement][i];\n\t\t}\n\t\treturn has;\n\t}\n\tinline pH shift(pH has, int sft) {\n\t\tconst int movement = A +sft;\n\t\tfor (int i : range(num)) {\n\t\t\thas[i] *= RS[movement][i];\n\t\t}\n\t\treturn has;\n\t}\n\tinline void ins(pH has,int c) {\n\t\tcnt[{has[0], has[1]}] += c;\n\t}\n\tinline LL get(pH has) {\n\t\treturn cnt[{has[0], has[1]}];\n\t}\n}\nint main() {\n\tusing namespace RollHash;\n\twhile (cin >> N >> S) {\n\t\tinit();\n\t\tLL ret = 0;\n\n\t\tvector<pH> suf(N + 1);\n\t\tvector<int> sft(N + 1);\n\t\tsft[0] = 0;\n\t\tfor (int i : range(N)) {\n\t\t\tsft[i + 1] = sft[i];\n\t\t\tif (S[i] == '>')sft[i + 1]++;\n\t\t\tif (S[i] == '<')sft[i + 1]--;\n\t\t}\n\t\tpH now{ 0,0 };\n\t\tint center = 0;\n\t\tsuf[N] = shift(moveCenter(now, center), sft[N]);\n\t\tins(suf[N], 1);\n\t\tfor (int ri : range(N)) {\n\t\t\tconst int i = N - 1 - ri;\n\t\t\tif (S[i] == '+')now = add(now, center);\n\t\t\tif (S[i] == '-')now = sub(now, center);\n\t\t\tif (S[i] == '>')center--;\n\t\t\tif (S[i] == '<')center++;\n\t\t\tsuf[i]=shift(moveCenter(now, center),sft[i]);\n\t\t\tins(suf[i], 1);\n\t\t}\n\t\tnow = moveCenter(now, center);\n\t\tfor (int i : range(N)) {\n\t\t\tins(suf[i], -1);\n\t\t\tauto latte = suf[i];\n\t\t\tauto malta = shift(now, sft[i]);\n\t\t\tauto ei = sub(latte, malta);\n\t\t\tLL beet = get(ei);\n\t\t\tret += beet;\n\t\t}\n\n\t\tcout << ret << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<map>\nusing namespace std;\nconst int sed=233,mod=998244353,vsed=844009174;\ninline int kpow(int a,int b)\n{\n\tint s=1;\n\tfor(;b;b>>=1,a=1ll*a*a%mod)\n\t\tif(b&1)s=1ll*s*a%mod;\n\treturn s;\n}\nlong long ans;\nint n,c;\nchar s[250050];\npair<int,int>s1[250050],s2[250050];\nmap<int,int>mp;\npair<int,int>work1(pair<int,int>last,char cur)\n{\n\tif(cur=='>')last.first=1ll*last.first*vsed%mod;\n\telse if(cur=='<')last.first=1ll*last.first*sed%mod;\n\telse if(cur=='+')(last.second+=last.first)%=mod;\n\telse (last.second+=mod-last.first)%=mod;\n\treturn last;\n}\npair<int,int>work2(pair<int,int>last,char cur)\n{\n\tif(cur=='>')last.first=1ll*last.first*vsed%mod;\n\telse if(cur=='<')last.first=1ll*last.first*sed%mod;\n\telse if(cur=='+')(last.second+=last.first)%=mod;\n\telse (last.second+=mod-last.first)%=mod;\n\treturn last;\t\n}\nint main()\n{\n\tscanf(\"%d %s\",&n,s+1);\n\tfor(int i=n;i;--i)\n\t{\n\t\tif(s[i]=='>')c=1ll*c*vsed%mod;\n\t\telse if(s[i]=='<')c=1ll*c*sed%mod;\n\t\telse if(s[i]=='+')(c+=1)%=mod;\n\t\telse (c+=mod-1)%=mod;\n\t}\n//\tprintf(\"%d\\n\",c);\n\ts1[0].first=1;\n\ts2[0].first=1;\n\t++mp[c];\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\ts1[i]=work1(s1[i-1],s[i]);\n\t\ts2[i]=work2(s2[i-1],s[i]);\n\t\tans+=mp[s1[i].second];\n\t\t++mp[(1ll*c*s2[i].first+s2[i].second)%mod];\n\t//\tprintf(\"%d %d %d %d\\n\",s1[i].first,s1[i].second,s2[i].first,s2[i].second);\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//by kcz 1552920354@qq.com\n//if you find any bug in my code\n//please tell me\n#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate <typename T> void chmin(T&x,const T &y)\n{\n\tif(x>y)x=y;\n}\ntemplate <typename T> void chmax(T &x,const T &y)\n{\n\tif(x<y)x=y;\n}\ntypedef long long s64;\ntypedef unsigned long long u64;\ntypedef unsigned int u32;\ntypedef pair<int,int> pii;\n#define rep(i,l,r) for(int i=l;i<=r;++i)\n#define per(i,r,l) for(int i=r;i>=l;--i)\n#define pb push_back\n#define gc (c=getchar())\nint read()\n{\n\tchar c;\n\twhile(gc<'-');\n\tif(c=='-')\n\t{\n\t\tint x=gc-'0';\n\t\twhile(gc>='0')x=x*10+c-'0';\n\t\treturn -x;\n\t}\n\tint x=c-'0';\n\twhile(gc>='0')x=x*10+c-'0';\n\treturn x;\n}\n#undef gc\n\ns64 mi(s64 x,int y,int D)\n{\n\ts64 ans=1;\n\twhile(y)\n\t{\n\t\tif(y&1)ans=ans*x%D;\n\t\tx=x*x%D;y>>=1;\n\t}\n\treturn ans;\n}\ns64 niv(s64 x,int D)\n{\n\treturn mi(x,D-2,D);\n}\nconst int N=250000+5;\ntypedef pair<s64,s64> hash_t;\nconst int D1=998244353,D2=1e9+7;\nconst hash_t w=hash_t(N+5,N+7);\nhash_t operator +(const hash_t &a,const hash_t &b)\n{\n\treturn hash_t((a.first+b.first)%D1,(a.second+b.second)%D2);\n}\nhash_t operator -(const hash_t &a,const hash_t &b)\n{\n\treturn hash_t((a.first+D1-b.first)%D1,(a.second+D2-b.second)%D2);\n}\nhash_t operator /(const hash_t &a,const hash_t &b)\n{\n\treturn hash_t(a.first*niv(b.first,D1)%D1,a.second*niv(b.second,D2)%D2);\n}\nhash_t operator *(const hash_t &a,const hash_t &b)\n{\n\treturn hash_t(a.first*b.first%D1,a.second*b.second%D2);\n}\n\nint n;\nchar s[N];\nhash_t k[N],b[N];\n\nint main()\n{\n\t//freopen(\"1.in\",\"r\",stdin);//freopen(\"1.out\",\"w\",stdout);\n\tcin>>n;\n\tscanf(\"%s\",s+1);\n\tk[n+1]=hash_t(1,1);b[n+1]=hash_t(0,0);\n\tper(i,n,1)\n\tif(s[i]=='+')\n\t{\n\t\tk[i]=k[i+1];\n\t\tb[i]=b[i+1]+hash_t(1,1);\n\t}\n\telse\n\tif(s[i]=='-')\n\t{\n\t\tk[i]=k[i+1];\n\t\tb[i]=b[i+1]-hash_t(1,1);\n\t}\n\telse\n\tif(s[i]=='>')\n\t{\n\t\tk[i]=k[i+1]*w;\n\t\tb[i]=b[i+1]*w;\n\t}\n\telse\n\t{\n\t\tk[i]=k[i+1]/w;\n\t\tb[i]=b[i+1]/w;\n\t}\n\n\tmap<hash_t,int>mp;\n\ts64 ans=0;\n\tper(i,n,1)\n\t{\n\t\t++mp[b[i+1]/k[i+1]];\n\t\tans+=mp[(b[i]-b[1])/k[i]];\n\t}\n\tcout<<ans;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//Konrad Paluszek,University of Warsaw(former XIV LO Staszic)\n//#STAY AT HOME\n#ifndef LOCAL\n#pragma GCC optimize(\"O3\")\n#endif\n#define TIME (chrono::steady_clock::now().time_since_epoch().count())\n#include<bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n#define xfm(a,b)a##b\n#define xwb(a,b)xfm(a,b)\n#define _ xwb(nvj,__LINE__)\n#define __ xwb(kjy,__LINE__)\n#define ___ xwb(cjm,__LINE__)\n#define REP(i,n)for(urs(n)i=0;i<(n);++i)\n#define UNTIL(t)while(clock()<(t)*CLOCKS_PER_SEC)\n#define PER(r...)for(bool _=1;_||next_permutation(r);_=false)\n#define ALL(r)(r).begin(),(r).end()\n#define RALL(r)(r).rbegin(),(r).rend()\n#define FS(r)r.first,r.second\n#define SF(r)r.second,r.first\n#define M0(r) memset(r, 0, sizeof(r))\n#define sim template<class c\n#define ros return o\n#define rans return ans\n#define forbits(i,m)if(m)for(urs(m)i=ctz(m),i##nvj=m;i##nvj;i##nvj^=((urs(m))1<<i),i=ctz(i##nvj))\n#define fordbits(i,m)if(m)for(urs(m)i=8*sizeof(m)-clz(m)-1,i##nxd=m;i##nxd;i##nxd^=((urs(m))1<<i),i=8*sizeof(m)-clz(i##nxd)-1)\n#define ksets(t, m, k, n) for (t m = (((t)1 << (k)) - 1); m < ((t)1 << (n)); m = nux(m))\n#define urs(r...)typename decay<decltype(r)>::type\n#define hur(f,g,r)sim>int f(c a){if(sizeof(c)==16)return r;if(sizeof(c)==8)return g##ll(a);return g(a);}\n#define pwq(t,i) int clz(t x){return clz<int>(x)-i;}\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wconversion\"\nusing namespace __gnu_pbds;using namespace std;using ll=long long;using ld=long double;using ull=unsigned long long;using vi=vector<int>;using vll=vector<ll>;using pii=pair<int,int>;using pll=pair<ll,ll>;using vpii=vector<pii>;using spii=set<pii>;using mii=map<int,int>;using unt=unsigned int;sim>using min_queue=priority_queue<c,vector<c>,greater<c>>;sim,class b,class cmp=less<c> >using ordered_map=tree<c,b,cmp,rb_tree_tag,tree_order_statistics_node_update>;sim, class cmp=less<c>>using ordered_set = ordered_map<c,null_type,cmp>;hur(popc,__builtin_popcount,popc<ull>(a)+popc<ull>(a>>64))hur(ctz,__builtin_ctz,(ull)a?ctz<ull>(a):64+ctz<ull>(a>>64))hur(clz,__builtin_clz,a>>64?clz<ull>(a>>64):64+clz<ull>(a))pwq(short,16)pwq(uint16_t,16)pwq(char,24)pwq(int8_t,24)pwq(uint8_t,24)sim,class N>bool mini(c&o,const N&h){if(o>h)ros=h,1;return 0;}sim,class N>bool maxi(c&o,const N&h){if(o<h)ros=h,1;return 0;}sim,class n>using gyv=c;\n#if defined(LOCAL) // || defined(LOCAL2)\n#include </home/kjp/headers/debuglib.hpp>\n#else\n#define loc(...)\n#define onl(r...)r\n#define debug(...)\n#define print_stack(...)\n#define mark_stack(...)\n#define set_pre(...)\n#define reg_it(...)\n#define def_op(...) struct _{};\n#if !defined(LOCAL) && !defined(LOCAL2)\n#define exit my_exit\nvoid my_exit(int x) {fflush(stdout);_Exit(x);}\n#endif\n#endif\n#define next nexT\n#define prev preV\n#define tree trEE\n#define left lefT\n#define right righT\n#define div diV\n#define y1 y_1\n#define pow do not use cmath pow unless you know what you are doing\null mix(ull o){o+=0x9e3779b97f4a7c15;o=(o^(o>>30))*0xbf58476d1ce4e5b9;o=(o^(o>>27))*0x94d049bb133111eb;ros^(o>>31);}ull SALT=0x7a14a4b0881ebf9,tqu=0x7a14a4b0881ebf9;ull my_rand(){return tqu=mix(tqu);}void my_srand(ull x){SALT=tqu=x;}const int inf = 1023400000;const ll llinf=1234567890000000000ll;ll fix(ll o, ll m){o%=m;if(o<0)o+=m;ros;}\n#define rand my_rand\n#define srand my_srand\n#define random_shuffle(r...)random_shuffle(r,[](int _){return my_rand()%_;})\nsim>inline c nux(c m){if(!m)return numeric_limits<c>::max();c A=m&-m;c B=~((A-1)^m);c C=B&-B;c D=(C>>(1+ctz(A)))-1;return C|(m&~(C-1))|D;}__attribute__((no_sanitize_undefined))ll mul(ll a,ll b,ll m){ll q=(ll)(a*(ld)b/m);ll o=a*b-q*m;o%=m;if(o<0)o+=m;ros;}sim>void unq(c&x){x.resize(unique(ALL(x))-x.begin());}\n#pragma GCC diagnostic pop\n#if ((ULONG_MAX) != (UINT_MAX))\nnamespace std {template <> struct is_signed<__int128> : public true_type {};}\n#endif\nsim, class d> typename common_type<c,d>::type floor_div(c a, d b) {static_assert(is_signed<c>::value==is_signed<d>::value,\"using floor_div with different signedness\");if (b < 0) b = -b, a = -a;return a / b - (a % b < 0);}\nsim, class d> typename common_type<c,d>::type ceil_div(c a, d b) {static_assert(is_signed<c>::value==is_signed<d>::value,\"using ceil_div with different signedness\");if (b < 0) b = -b, a = -a;return a / b + (a % b > 0);}\nsim> struct REV {using value_type=typename c::value_type;c &x;using it=typename c::reverse_iterator;it begin(){return x.rbegin();}it end(){return x.rend();}};\nsim> struct CREV {using value_type=typename c::value_type;const c&x;using it=typename c::const_reverse_iterator;it begin(){return x.rbegin();}it end(){return x.rend();}};\nsim> REV<c> reversed(c&x) {return REV<c>{x};}sim> CREV<c> reversed(const c&x) {return CREV<c>{x};}\n#define done(r...) exit(0 * printf(r))\n#if defined(LOCAL) || defined(LOCAL2)\nvoid __tmi() {cerr << setprecision(6) << fixed << \"total time: \" << clock() / (ld)CLOCKS_PER_SEC << \"s\" << endl;}int _ = (atexit(__tmi), 0);\n#endif\n//#STAY AT HOME\nconst ll mod = ((ll) 1e18) + 3, nax = 250000 + 44;\ntemplate <size_t n, size_t m> using matr = array<array<ll, m>, n>;\ntemplate <size_t n, size_t m, size_t k> matr<n, k> operator*(const matr <n,m> &a, const matr<m,k> &b) {\n\tmatr<n, k> c = {};\n\tREP(i, n) REP(j, m) REP(x, k) c[i][x] = (c[i][x] + a[i][j] * (__int128)b[j][x]) % mod;\n\treturn c;\n}\nll inv(ll x) {\n\tll e = mod - 2, r = 1;\n\twhile (e) {\n\t\tif (e & 1) r = r * __int128(x) % mod;\n\t\tx = x * __int128(x) % mod;\n\t\te >>= 1;\n\t}\n\treturn r;\n}\n#define plus plUs\n#define minus minUs\nconst ll P = 998244353, Pin = inv(P);\nconst matr <2, 2> plus = {1, 1, 0, 1}, minus = {1, -1, 0, 1}, left = {1, 0, 0, Pin}, right = {1, 0, 0, P}, id = {1, 0, 0, 1};\nchar row[nax];\nmatr<2, 2> s[nax], sinv[nax];\nmatr<2, 2> get(char c) {\n\tif (c == '+') return plus;\n\tif (c == '-') return minus;\n\tif (c == '<') return left;\n\tif (c == '>') return right;\n\tdebug(imie(c));\n\tabort();\n}\nmatr<2, 2> get_inv(char c) {\n\tif (c == '-') return plus;\n\tif (c == '+') return minus;\n\tif (c == '>') return left;\n\tif (c == '<') return right;\n\tdebug(imie(c));\n\tabort();\n}\nmatr <1, 2> t = {1, 0};\nmatr <2, 1> v0 = {0, 1};\nint main() {\n\tint n;\n\tscanf(\"%d%s\", &n, row);\n\ts[0] = sinv[0] = id;\n\tREP(i, n) s[i + 1] = get(row[i]) * s[i];\n\tREP(i, n) sinv[i + 1] = sinv[i] * get_inv(row[i]);\n\tll Q = (t * s[n] * v0)[0][0];\n\tmap <ll, int> cou;\n\tll ans = 0;\n\tREP(i, n) {\n\t\tdebug(arr(sinv, i), imie(v0));\n\t\tauto cd = sinv[i] * v0;\n\t\tdebug(imie(cd));\n\t\tauto ab = t * s[i + 1];\n\t\tdebug(imie(ab));\n\t\tauto [a, b] = ab[0];\n\t\tauto [cc, dd] = cd;\n\t\tauto [c] = cc;\n\t\tauto [d] = dd;\n\t\tdebug(imie(a), imie(b), imie(c), imie(d));\n\t\tll v = (Q - c) * __int128(inv(d)) % mod;\n\t\tif (v < 0) v += mod;\n\t\tcou[v]++;\n\t\tans += cou[fix(b, mod)];\n\t}\n\tprintf(\"%lld\\n\", ans);\n\texit(0);\n}\n//#STAY AT HOME\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define mp make_pair\n#define PI pair<int,int>\n#define poly vector<ll>\n#define mem(a) memset((a),0,sizeof(a))\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\n#define pb push_back\n#define fi first\n#define se second\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst ull base=2333;\nconst int N=250005;\nchar ch[N];\null f[N];\nmap<ull,int> M;\nint main(){\n\tull zs=base,inv=1; For(i,1,63){inv=inv*zs; zs=zs*zs;}\n\tassert(base*inv==1);\n\t//cout<<inv<<endl;\n\tint n=read();\n\tscanf(\"%s\",ch+1);\n\tull dq=1;\n\tFor(i,1,n){\n\t\tf[i]=f[i-1];\n\t\tif(ch[i]=='+')f[i]+=dq;\n\t\tif(ch[i]=='-')f[i]-=dq;\n\t\tif(ch[i]=='>')dq*=base;\n\t\tif(ch[i]=='<')dq*=inv;\n\t\tM[f[i]]++;\n\t}\n\tll ans=0; dq=1;\n\tFor(i,1,n){\n\t\tans+=M[f[n]*dq+f[i-1]];\n\t\tif(ch[i]=='<')dq*=base;\n\t\tif(ch[i]=='>')dq*=inv;\n\t\tM[f[i]]--;\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \nusing namespace std;\n \n#define int unsigned int\n \nconst int   mod = 1e9 + 7;\nconst int   N   = 5e5 + 1;\nconst int   phi = 1ll << 30;\n \nint n, p[N], f[N];\nint H[N];\nstring S;\n \nint qpow(int a,int exp) {\n    int ans = 1;\n    for(; exp > 0 ; exp >>= 1)  {\n        if(exp & 1) ans = ans * a;\n        a = a * a;\n    }\n    return ans;\n}\n \nmap<int,int> mp;\n \nsigned main()   {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n \n    cin >> n >> S;\n \n    p[0] = 1;\n \n    for(int i = 1 ; i <= 2 * n ; ++i)\n        p[i] = p[i - 1] * mod;\n \n    f[0] = n;\n \n    for(int i = 0 ; i < n ; ++i)    {\n        f[i + 1] = f[i];\n        H[i + 1] = H[i];\n        if(S[i] == '>') f[i + 1]++;\n        if(S[i] == '<') f[i + 1]--;\n        if(S[i] == '+') H[i + 1] += p[f[i]];\n        if(S[i] == '-') H[i + 1] -= p[f[i]];\n    }\n \n    mp[H[n]] = 1;\n \n    long long ans = 0;\n \n    for(int i = 1 ; i <= n ; ++i)    {\n        ans += mp[H[i]];\n        int exp = f[i] - n;\n        int mul;\n        if(exp < 0) mul = qpow(p[-exp],mod - 2);\n        else        mul = p[exp];\n        mp[H[n] * mul + H[i]]++;\n    }\n \n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\n#define N 500001\n#define mod 998244353\nusing namespace std;\nlong long thn[N],ans,qz[N],a[N];\nchar st[N];\nint where[N];\nint n;\nmap<long long,long long>maps;\nlong long ksmi(long long x,long long y)\n{\n\tlong long total=1,ab=x,p=y;\n\twhile (p)\n\t{\n\t\tif (p%2==1) total=total*ab%mod;\n\t\tab=ab*ab%mod;\n\t\tp/=2;\n\t}\n\treturn total;\n}\nlong long abs(long long x)\n{\n\tif (x<0) return -x;\n\treturn x;\n}\nint main()\n{\n\tscanf(\"%d\\n\",&n);\n\tthn[0]=1;\n\tfor (int i=1;i<=2*n;i++) thn[i]=thn[i-1]*(2*n)%mod;\n\tscanf(\"%s\",st+1);\n\tint nowp=n;\n\twhere[0]=n;\n\tqz[0]=0;\n\tfor (int i=1;i<=2*n;i++)\n\t\tqz[0]=(qz[0]+thn[i-1]*n%mod)%mod;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tqz[i]=qz[i-1];\n\t\tif (st[i]=='+')\n\t\t{\n\t\t\ta[nowp]++;\n\t\t\tqz[i]=(qz[i]+thn[nowp-1])%mod;\n\t\t}\n\t\tif (st[i]=='-')\n\t\t{\n\t\t\ta[nowp]--;\n\t\t\tqz[i]=(qz[i]-thn[nowp-1]+mod)%mod;\n\t\t}\n\t\tif (st[i]=='>') nowp++;\n\t\tif (st[i]=='<') nowp--;\n\t\twhere[i]=nowp;\n\t}\n\tunsigned long long a_hash=0;\n\tfor (int i=1;i<=n*2;i++) a_hash=(a_hash+(a[i]+n)*thn[i-1])%mod;\n\tfor (int i=n;i>=1;i--)\n\t{\n\t\tlong long target=(a_hash-qz[0]+mod)%mod;\n\t\tif (where[i-1]<where[0])\n\t\t\ttarget=target*ksmi(thn[abs(where[i-1]-where[0])],mod-2)%mod;\n\t\telse\ttarget=target*thn[abs(where[0]-where[i-1])]%mod;\n\t\tmaps[qz[i]]++;\n\t\ttarget+=qz[i-1];\n\t\ttarget%=mod;\n\t\tans=(ans+maps[target]);\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <assert.h>\n#include <sys/time.h>\n#include <fstream>\n#include <iomanip>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  FOR(i,0,n)\n#define REP(i,n)  FOR(i,0,n)\n#define each(i,c) for(auto i=(c).begin(); i!=(c).end(); ++i)\n#define EACH(i,c) for(auto i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#define deb(x) cerr << #x << \" = \" << (x) << \" , \";\n#define debl cerr << \" (L\" << __LINE__ << \")\"<< endl;\n#define sz(s) (int)((s).size())\n\n\n#define clr(a) memset((a),0,sizeof(a))\n#define nclr(a) memset((a),-1,sizeof(a))\n#define pb push_back\n#define INRANGE(x,s,e) ((s)<=(x) && (x)<(e))\n#define MP(x,y) make_pair((x),(y))\n\ndouble pi=3.14159265358979323846;\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T> std::ostream& operator<<(std::ostream& os, const vector<T>& z){\n\tos << \"[ \";\n\tREP(i,z.size())os << z[i] << \", \" ;\n\treturn ( os << \"]\" << endl);\n}\n\ntemplate<typename T> std::ostream& operator<<(std::ostream& os, const set<T>& z){\n\tos << \"set( \";\n\tEACH(p,z)os << (*p) << \", \" ;\n\treturn ( os << \")\" << endl);\n}\n\ntemplate<typename T,typename U> std::ostream& operator<<(std::ostream& os, const map<T,U>& z){\n\tos << \"{ \";\n\tEACH(p,z)os << (p->first) << \": \" << (p->second) << \", \" ;\n\treturn ( os << \"}\" << endl);\n}\n\ntemplate<typename T,typename U> std::ostream& operator<<(std::ostream& os, const pair<T,U>& z){\n\treturn ( os << \"(\" << z.first << \", \" << z.second << \",)\" );\n}\n\ndouble get_time(){\n\tstruct timeval tv;\n\tgettimeofday(&tv, NULL);\n\treturn tv.tv_sec + tv.tv_usec*1e-6;\n}\n\ntypedef unsigned int uint32_t;\nstruct RND{\n\tuint32_t x;\n\tuint32_t y;\n\tuint32_t z;\n\tuint32_t w;\n\tRND(){\n\t\tx=123456789;\n\t\ty=362436069;\n\t\tz=521288629;\n\t\tw=88675123;\n\t}\n\tvoid init(int seed){\n\t\tx=123456789;\n\t\ty=362436069;\n\t\tz=521288629;\n\t\tw=seed+100;\n\t\tREP(i,10)get();\n\t}\n\tuint32_t get(){\n\t\tuint32_t t;\n\t\tt=x^(x<<11);\n\t\tx=y;y=z;z=w;\n\t\tw=(w^(w>>19))^(t^(t>>8));\n\t\treturn w;\n\t}\n};\nRND rnd;\n\nll mod=1000000007;\nstruct mint{\n\tll value;\n\tmint():value(0){}\n\tmint(ll v):value((v%mod+mod)%mod){}\n};\nmint& operator+=(mint&a, mint b){return a=a.value+b.value;}\nmint& operator-=(mint&a, mint b){return a=a.value-b.value;}\nmint& operator*=(mint&a, mint b){return a=a.value*b.value;}\nmint operator+(mint a, mint b){return a+=b;}\nmint operator-(mint a, mint b){return a-=b;}\nmint operator*(mint a, mint b){return a*=b;}\nmint operator-(mint a){return 0-a;}\nbool operator==(mint a, mint b){return a.value==b.value;}\nbool operator!=(mint a, mint b){return a.value!=b.value;}\n\n\nstd::ostream& operator<<(std::ostream& os, const mint& m){\nreturn ( os << m.value );}\nll extgcd(ll a, ll b, ll &x, ll &y){\n\tll d=a;\n\tif(b!=0){\n\t\td=extgcd(b, a%b, y, x);\n\t\ty-=(a/b)*x;\n\t}\n\telse{\n\t\tx=1,y=0;\n\t}\n\treturn d;\n}\nll modinverse(ll a, ll b){\n\tll x,y;\n\tll d=extgcd(a,b, x, y);\n\tassert(d==1);\n\treturn (x%b+b)%b;\n}\nmint& operator/=(mint&a, mint b){return a=a.value*modinverse(b.value,mod);}\nmint operator/(mint a, mint b){return a/=b;}\n\nvector<mint> f;\nvector<mint> pf;\nmint X = 10;\n\nvoid _main(istream &inp){\n\tint N;\n\tstring S;\n\tinp >> N >> S;\n\tf = vector<mint>(N+1);\n\tpf = vector<mint>(N+1);\n\tmint val = 0;\n\tmint u=1;\n\tf[0]=val;\n\tpf[0] = u;\n\trep(i,N){\n\t\tif(S[i]=='+')val += u;\n\t\tif(S[i]=='-')val -= u;\n\t\tif(S[i]=='>') u*=X;\n\t\tif(S[i]=='<')u/=X;\n\t\tf[i+1] = val;\n\t\tpf[i+1] = u;\n\t}\n//\tdebug(f);\n//\tdebug(pf);\n\tmap<ll,ll> cnt;\n\tll ret = 0;\n\tfor(int i=N;i>=0; i-- ){\n\t\tll tv = ( f[i] + pf[i]*f[N] ).value;\n\t\tif(exist(cnt, tv)){\n\t\t\tret += cnt[tv];\n\t\t}\n\t\tcnt[f[i].value]+=1;\n\t}\n\tcout << ret << endl;\n}\n\nint main(){\n\tif(0){\n\t\tifstream ifs(\"test.txt\");\n\t\t_main(ifs);\n\t}\n\telse{\n\t\t_main(cin);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define M1 1000000021\n#define M2 1000000033\n\nint n, at[250005];\npair< long long, long long > tmp;\npair< long long, long long > pp[600005];\npair< long long, long long > inv[600005];\npair< long long, long long > cur[250005];\nmap< pair< long long, long long >, int > mm;\nmap< pair< long long, long long >, int >::iterator it;\nlong long ans;\nchar x[250005];\n\npair< long long, long long > operator*(const pair< long long, long long > &a, const pair< long long, long long > &b) {\n\treturn {a.first * b.first % M1, a.second * b.second % M2};\n}\n\npair< long long, long long > operator+(const pair< long long, long long > &a, const pair< long long, long long > &b) {\n\tpair< long long, long long > re = {a.first + b.first, a.second + b.second};\n\tif (re.first >= M1)\n\t\tre.first -= M1;\n\tif (re.second >= M2)\n\t\tre.second -= M2;\n\treturn re;\n}\n\npair< long long, long long > operator-(const pair< long long, long long > &a, const pair< long long, long long > &b) {\n\tpair< long long, long long > re = {a.first + M1 - b.first, a.second + M2 - b.second};\n\tif (re.first >= M1)\n\t\tre.first -= M1;\n\tif (re.second >= M2)\n\t\tre.second -= M2;\n\treturn re;\n}\n\nlong long po(long long b, int p, long long m) {\n\tlong long re = 1;\n\twhile (p) {\n\t\tif (p & 1)\n\t\t\tre = re * b % m;\n\t\tb = b * b % m;\n\t\tp >>= 1;\n\t}\n\treturn re;\n}\n\nint main() {\n\tat[0] = 300000;\n\tscanf(\"%d%s\", &n, x);\n\tpp[0] = inv[0] = {1, 1};\n\tpp[1] = {600000, 600000};\n\tinv[1] = {po(600000, M1 - 2, M1), po(600000, M2 - 2, M2)};\n\tfor (int i = 2; i < 600005; i++) {\n\t\tpp[i] = pp[i - 1] * pp[1];\n\t\tinv[i] = inv[i - 1] * inv[1];\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tat[i + 1] = at[i];\n\t\tcur[i + 1] = cur[i];\n\t\tif (x[i] == '>')\n\t\t\tat[i + 1]++;\n\t\telse if (x[i] == '<')\n\t\t\tat[i + 1]--;\n\t\telse if (x[i] == '+')\n\t\t\tcur[i + 1] = cur[i + 1] + pp[at[i + 1]];\n\t\telse\n\t\t\tcur[i + 1] = cur[i + 1] - pp[at[i + 1]];\n\t}\n\t// for (int i = 0; i <= n; i++) printf(\"%d  %d  %lld %lld\\n\", i, at[i], cur[i].first, cur[i].second);\n\tfor (int i = n; i >= 0; i--) {\n\t\tif (at[i] > at[0])\n\t\t\ttmp = cur[n] * pp[at[i] - at[0]] + cur[i];\n\t\telse\n\t\t\ttmp = cur[n] * inv[at[0] - at[i]] + cur[i];\n\t\t// printf(\"%d  %lld %lld\\n\", i, tmp.first, tmp.second);\n\t\tit = mm.find(tmp);\n\t\tif (it != mm.end())\n\t\t\tans += it->second;\n\t\tit = mm.insert({cur[i], 0}).first;\n\t\tit->second++;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef unsigned long long ULL;\n\nconst int MAXN = 2.5e5 + 10;\nconst ULL P = 233ULL, iP = 7204522363551799129ULL;\n\nint n;\nULL hsh1[MAXN], hsh2[MAXN];\nchar s[MAXN];\nstd::map <ULL, int> mp;\n\nint main() {\n\tscanf(\"%d %s\", &n, s + 1), hsh2[0] = 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\thsh1[i] = hsh1[i - 1], hsh2[i] = hsh2[i - 1];\n\t\tif (s[i] == '+') hsh1[i] += hsh2[i];\n\t\telse if (s[i] == '-') hsh1[i] -= hsh2[i];\n\t\telse if (s[i] == '<') hsh2[i] *= iP;\n\t\telse hsh2[i] *= P;\n\t\t++mp[hsh1[i]];\n\t}\n\tULL ans = 0;\n\tfor (int i = 1; i <= n; ++i) ans += mp[hsh1[n] * hsh2[i - 1] + hsh1[i - 1]], --mp[hsh1[i]];\n\tprintf(\"%llu\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <vector>\n\nconst int DEBUG = 0;\n\n#define MOCK 1\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define DEBUGP(val) cerr << #val << \"=\" << val << \"\\n\"\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\ntypedef pair<ll, ll> PL;\n\n\nll powmod(ll a, ll e, ll mod) {\n  ll sum = 1;\n  ll cur = a;\n  while (e > 0) {\n    if (e % 2) {\n      sum = sum * cur % mod;\n    }\n    cur = cur * cur % mod;\n    e /= 2;\n  }\n  return sum;\n}\n\nconst int A = 20;\n\nint main(void) {\n  const ll mod = 1e9 + 7;\n  const ll mod2 = 1e9 + 9;\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  string s;\n  cin >> n >> s;\n  int p = 0;\n  VI pos(n + 1);\n  mt19937 mt;\n  VL b(A);\n  ll mods[A] = {};\n  REP(i, 0, A) mods[i] = 1e9 + 7;\n  \n  REP(c, 0, A) {\n    do {\n      b[c] = mt() % mods[c];\n    } while (b[c] == 0);\n  }\n  vector<VL> hsh(A, VL(n + 1));\n  ll inv[A] = { 0 };\n  REP(c, 0, A) inv[c] = powmod(b[c], mods[c] - 2, mods[c]);\n  REP(c, 0, A) {\n    p = 0;\n    ll cur = 1;\n    REP(i, 0, n) {\n      ll tmp = hsh[c][i];\n      if (s[i] == '>') {\n        p++;\n        cur = cur * b[c] % mods[c];\n      }\n      if (s[i] == '<') {\n        p--;\n        cur = cur * inv[c] % mods[c];\n      }\n      if (s[i] == '+') {\n        tmp = (tmp + cur) % mods[c];\n      }\n      if (s[i] == '-') {\n        tmp = (tmp + mods[c] - cur) % mods[c];\n      }\n      hsh[c][i + 1] = tmp;\n      pos[i + 1] = p;\n    }\n  }\n  if (DEBUG) {\n    REP(i, 0, n + 1) {\n      cerr << i << \" \" << hsh[0][i] << endl;\n    }\n  }\n  VL meguru(A);\n  REP(c, 0, A) meguru[c] = hsh[c][n];\n  map<VL, int> kirika;\n  kirika[meguru] = 1;\n  ll tot = 0;\n  VL cur(A);\n  REP(c, 0, A) cur[c] = powmod(b[c], pos[n], mods[c]);\n  for (int i = n - 1; i >= 0; --i) {\n    if (DEBUG) {\n      DEBUGP(i);\n      DEBUGP(pos[i]);\n    }\n    if (pos[i + 1] - pos[i] == 1) {\n      REP(c, 0, A) cur[c] = cur[c] * inv[c] % mods[c];\n    }\n    else if (pos[i + 1] - pos[i] == -1) {\n      REP(c, 0, A) cur[c] = cur[c] * b[c] % mods[c];\n    }\n    VL ken(A);\n    REP(c, 0, A) ken[c] = cur[c] * meguru[c] + hsh[c][i] % mods[c];\n    tot += kirika[ken];\n    VL tt(A);\n    REP(c, 0, A) tt[c] = hsh[c][i];\n    kirika[tt] += 1;\n  }\n  cout << tot << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<bits/stdc++.h>\nusing namespace std;\n \n#define MAX 250002\n\ntemplate<typename ty,typename ty2>\nstruct my_hash_map{\n\t#define hash_map_MX ((1<<20)-1)\n\tint head[hash_map_MX+2];\n\tint nex[hash_map_MX+2];\n\tty key[hash_map_MX+2];\n\tty2 assoc_val[hash_map_MX+2];\n\tint tot;\n\tmy_hash_map(){\n\t\ttot=0;\n\t\tmemset(head,-1,sizeof(head));\n\t\tmemset(nex,-1,sizeof(nex));\n\t}\n\tinline ty2* find(ty val){\n\t\tint km=(val&hash_map_MX);\n\t\tif(head[km]==-1){\n\t\t\thead[km]=tot++;\n\t\t\tkey[head[km]]=val;\n\t\t\treturn &assoc_val[tot-1];\n\t\t}\n\t\tfor(int i=head[km];;i=nex[i]){\n\t\t\tif(key[i]==val)return &assoc_val[i];\n\t\t\tif(nex[i]==-1){\n\t\t\t\tnex[i]=tot++;\n\t\t\t\tkey[nex[i]]=val;\n\t\t\t\treturn &assoc_val[tot-1];\n\t\t\t}\n\t\t}\n\t\treturn NULL;\n\t}\n};\n\nmy_hash_map<__int128,int> mp;\n\nint n;\n \nchar buf[MAX];\n \n__int128 mod1=1007ll;\n__int128 mod2=1000000000000000031LL;\n \ninline __int128 mul(__int128 a,__int128 b){\n\treturn (a*b)%mod2;\n}\ninline __int128 add(__int128 a,__int128 b){\n\tauto f=a+b;\n\tif(f>=mod2)f%=mod2;\n\treturn f;\n}\ninline __int128 sub(__int128 a,__int128 b){\n\tauto f=a-b;\n\tif(f<0)f+=mod2;\n\tf%=mod2;\n\treturn f;\n}\n__int128 ppow(__int128 a,__int128 b){\n\t__int128 res=1;\n\twhile(b){\n\t\tif(b&1LL)res*=a;\n\t\tif(res>=mod2)res%=mod2;\n\t\ta*=a;\n\t\ta%=mod2;\n\t\tb>>=1LL;\n\t}\n\treturn res;\n}\nvector<pair<__int128,__int128> > v;\nint main() {\n\tcin>>n;\n\tscanf(\"%s\",buf);\n\tauto inv = ppow(mod1,mod2-2);\n\t__int128 cur=1;\n\t__int128 hs=0;\n\tint sz=strlen(buf);\n\tv.push_back(make_pair(0,1));\n\tfor(int i=0;i<sz;i++){\n\t\tif(buf[i]=='<'){\n\t\t\tcur=mul(cur,inv);\n\t\t}\n\t\tif(buf[i]=='>'){\n\t\t\tcur=mul(cur,mod1);\n\t\t}\n\t\tif(buf[i]=='+'){\n\t\t\ths=add(hs,cur);\n\t\t}\n\t\tif(buf[i]=='-'){\n\t\t\ths=sub(hs,cur);\n\t\t}\n\t\tv.push_back(make_pair(hs,cur));\n\t}\n\t__int128 acieve=v.back().first;\n\t//(x-c)/second=acieve\n\t//x-c=acieve/second\n\t//x = c+ acieve/second\n\tlong long int way=0;\n\tfor(int i=v.size()-1;i>=0;i--){\n\t\t__int128 want=add(v[i].first,mul(acieve,v[i].second));\n\t\tway+=(*mp.find(want));\n\t\t(*mp.find(v[i].first))++;\n\t\t//cerr<<i<<\" \"<<way<<endl;\n\t}\n\tprintf(\"%lld\\n\",way);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <deque>\n#include <iomanip>\n#include <cstdio>\n#include <stack>\n#include <bitset>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(ll)(n);++i)\n\nlong long ruijo(long long  k,long long m, ll mod){\n\tif(m==0)return 1;\n\tif(m==1)return k%mod;\n\tlong long s = ruijo(k,m/2,mod);\n\tif(m%2==0){\n\t\treturn (s*s)%mod;\n\t}else{\n\t\tlong long ans;\n\t\tans = (s*s)%mod;\n\t\treturn (k*ans)%mod;\n\t}\n}\n\n\nint main(){\n    map<pair<ll,ll>,ll>mp;\n    ll n;\n    cin >> n;\n    string s;\n    cin >> s;\n    ll b[2]={4731,238973};\n    ll m[2]={inf,998244353};\n    ll inv[2]={ruijo(b[0],m[0]-2,m[0]),ruijo(b[1],m[1]-2,m[1])};\n    ll x[2]={};\n    ll q[2]={1,1};\n    rep(i,n){\n        rep(j,2){\n            if(s[i]=='+'){\n                x[j] += q[j];\n                x[j] %= m[j];\n            }else if(s[i]=='-'){\n                x[j] += (m[j]-q[j]);\n                x[j] %= m[j];\n            }else if(s[i]=='>'){\n                q[j] *=b[j];\n                q[j] %=m[j];\n            }else{\n                q[j] *=inv[j];\n                q[j] %=m[j];\n            }\n        }\n        // cerr << x[0] << \" \" << x[1] << endl;\n        mp[MP(x[0],x[1])]++;\n    }\n    ll ans = 0;\n    ans += mp[MP(x[0],x[1])];\n    //cerr << ans << endl;\n    q[0] =1;\n    q[1] =1;\n    ll c[2]={0,0};\n    ll d[2]={1,1};\n    rep(i,n){\n        rep(j,2){\n            if(s[i]=='+'){\n                c[j] += d[j];\n                c[j] %= m[j];\n            }else if(s[i]=='-'){\n                c[j] += (m[j]-d[j]);\n                c[j] %= m[j];\n            }else if(s[i]=='>'){\n                d[j] *=b[j];\n                d[j] %=m[j];\n            }else{\n                d[j] *=inv[j];\n                d[j] %=m[j];\n            }\n        }\n        ll aaa = (x[0]*d[0]+c[0])%m[0];\n        ll bbb = (x[1]*d[1]+c[1])%m[1];\n        //cerr << aaa << \" \" << bbb << endl;\n        mp[MP(c[0],c[1])]--;\n        if(mp.find(MP(aaa,bbb))!=mp.end()){\n            ans += mp[MP(aaa,bbb)];\n        }\n        \n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\nconst int N=250005,mo1=998244853,mo2=993244853;\nstruct pii{\n\tint x,y;\n\tinline void operator+=(const pii&rhs){x+=rhs.x-mo1;y+=rhs.y-mo2;x+=x>>31&mo1;y+=y>>31&mo2;}\n\tinline void operator-=(const pii&rhs){x-=rhs.x;y-=rhs.y;x+=x>>31&mo1;y+=y>>31&mo2;}\n\tinline pii operator*(const pii&rhs)const{return (pii){int(1ll*x*rhs.x%mo1),int(1ll*y*rhs.y%mo2)};}\n\tinline operator ll(){return (ll(x)<<30)|y;}\n}f[N],mi[N*2],t,nw;\nint n,i,p,pp[N];\nchar c[N];\nstd::unordered_map<ll,int>mp;\nll ans;\nint main(){\n\tmi[0]=(pii){487619673,250267803};for(i=1;i<N*2;++i)mi[i]=mi[i-1]*(pii){789322,989432};\n\tscanf(\"%d%s\",&n,c+1);\n\tfor(i=1;i<=n;++i){\n\t\tif(c[i]=='+')nw+=mi[p+N];\n\t\tif(c[i]=='-')nw-=mi[p+N];\n\t\tif(c[i]=='>')++p;\n\t\tif(c[i]=='<')--p;f[i]=nw;pp[i]=p;\n\t}\n\t++mp[f[n]];\n\tfor(i=1;i<=n;++i)ans+=mp[t=f[i]],t+=f[n]*mi[pp[i]+N],++mp[t];\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 250001,M = 1e9 + 7,b = 103;\nint cs[N],p[N],n;\nmap<int,int>mp;\nvoid add(int &a,int b){\n\ta+=b;\n\tif(a >= M)a-=M;\n\tif(a < 0)a+=M;\n}\nint power(int base,int to){\n\tint ret = 1;\n\twhile(to){\n\t\tif(to&1)ret = ret*1LL*base%M;\n\t\tto>>=1;\n\t\tbase = base*1LL*base%M;\n\t}\n\treturn ret;\n}\nint main(){\n\t//freopen(\"readin.txt\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tp[0] = 1;\n\tchar c;\n\tint inv = power(b,M - 2);\n\tfor(int i = 1;i <= n;i++){\n\t\tscanf(\" %c\",&c);\n\t\tcs[i] = cs[i - 1];\n\t\tp[i] = p[i - 1];\n\t\tif(c == '+')add(cs[i],p[i]);\n\t\telse if(c == '-')add(cs[i],-p[i]);\n\t\telse if(c == '>')p[i] = p[i]*1LL*b%M;\n\t\telse if(c == '<')p[i] = p[i]*1LL*inv%M;\n\t}\n\tlong long ans = 0;\n\tfor(int i = 0;i <= n;i++){\n\t\tans+=mp[cs[i]];\n\t\tmp[(cs[n]*1LL*p[i] + cs[i] + M)%M]++;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int M = 1;\nstruct hs {\n\tint v[M];\n\ths(){\n\t\tmemset(v, 0, sizeof(v));\n\t}\n};\nhs mods;\nint mds[] = {\n\t961'748'927,\n\t961'820'429,\n\t1'000'000'007,\n\t1'000'000'009,\n\t1'003'162'753,\n\t1'023'893'771\n};\nhs create(int x){\n\ths r;\n\tfor(int i = 0; i < M; i++){\n\t\tr.v[i] = x % mods.v[i];\n\t\tif(r.v[i] < 0) r.v[i] += mods.v[i];\n\t}\n\treturn r;\n}\nhs operator + (hs a, hs b){\n\ths r;\n\tfor(int i = 0; i < M; i++){\n\t\tr.v[i] = a.v[i] + b.v[i];\n\t\tif(r.v[i] >= mods.v[i]) r.v[i] -= mods.v[i];\n\t}\n\treturn r;\n}\nhs operator - (hs a, hs b){\n\ths r;\n\tfor(int i = 0; i < M; i++){\n\t\tr.v[i] = a.v[i] - b.v[i];\n\t\tif(r.v[i] < 0) r.v[i] += mods.v[i];\n\t}\n\treturn r;\n}\nhs operator * (hs a, hs b){\n\ths r;\n\tfor(int i = 0; i < M; i++){\n\t\tr.v[i] = 1ll * a.v[i] * b.v[i] % mods.v[i];\n\t}\n\treturn r;\n}\nbool operator < (hs a, hs b){\n\tfor(int i = 0; i < M; i++) if(a.v[i] != b.v[i]) return a.v[i] < b.v[i];\n\treturn false;\n}\nint pwr(int a, int b, int mod){\n\tint r = 1;\n\tfor(; b; b>>=1, a = 1ll * a * a % mod) if(b&1) r = 1ll * r * a % mod;\n\treturn r;\n}\nbool is_prime(int x){\n\tfor(int i = 2; i * i <= x; i++) if(x % i == 0) return false;\n\treturn true;\n}\nconst int maxn = 300300;\nusing Poly = pair<hs, hs>;\nhs eval(Poly f, hs x){\n\treturn f.first + (f.second * x);\n}\nPoly poly[maxn];\nint main(){\n\tsrand(time(NULL));\n\tmemcpy(mods.v, mds, sizeof(int) * M);\n\ths x, mx, minus = create(-1), plus = create(1);\n\tint xx;\n\tdo {\n\t\txx = 900'999'999 + 50;\n\t\txx += rand() % 1000;\n\t} while(!is_prime(xx));\n\tx = create(xx);\n\tfor(int i = 0; i < M; i++){\n\t\tmx.v[i] = pwr(x.v[i], mods.v[i] - 2, mods.v[i]);\t\n\t\tassert((1ll * mx.v[i] * x.v[i] % mods.v[i]) == 1);\n\t}\n\tint n; cin >> n;\n\tstring s; cin >> s;\n\tpoly[n] = {create(0), create(1)};\n\tfor(int i = n - 1; i >= 0; i--){\n\t\tpoly[i] = poly[i + 1];\n\t\tif(s[i] == '+'){\n\t\t\tpoly[i].first = poly[i].first - poly[i].second;\n\t\t} else if(s[i] == '-'){\n\t\t\tpoly[i].first = poly[i].first + poly[i].second;\n\t\t} else {\n\t\t\ths mul = x;\n\t\t\tif(s[i] == '<')\n\t\t\t\tmul = mx;\n\t\t\tpoly[i].second = poly[i].second * mul;\n\t\t}\n\t}\n\tPoly norm = poly[n];\n\tfor(int i = 0; i < n; i++){\n\t\tif(s[i] == '+'){\n\t\t\tnorm.first = norm.first + norm.second;\n\t\t} else if(s[i] == '-'){\n\t\t\tnorm.first = norm.first - norm.second;\n\t\t} else if(s[i] == '<'){\n\t\t\tnorm.second = norm.second * x;\n\t\t} else {\n\t\t\tnorm.second = norm.second * mx;\n\t\t}\n\t}\n\ths tot = norm.first;\n\tmap<hs, int> cnt;\n\tcnt[poly[n].first]++;\n\tlong long ans = 0;\n\tfor(int i = n - 1; i >= 0; i--){\n\t\tans += cnt[eval(poly[i], tot)];\n\t\tcnt[poly[i].first]++;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \nusing namespace std;\n \n#define int unsigned long long\n \nconst int   mod = 1e9 + 7;\nconst int   N   = 5e5 + 1;\nconst int   phi = 1ll << 63;\n \nint n, p[N], f[N];\nint H[N];\nstring S;\n \nint qpow(int a,int exp) {\n    int ans = 1;\n    for(; exp > 0 ; exp >>= 1)  {\n        if(exp & 1) ans = ans * a;\n        a = a * a;\n    }\n    return ans;\n}\n \nmap<int,int> mp;\n \nsigned main()   {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n \n    cin >> n >> S;\n \n    p[0] = 1;\n \n    for(int i = 1 ; i <= 2 * n ; ++i)\n        p[i] = p[i - 1] * mod;\n \n    f[0] = n;\n \n    for(int i = 0 ; i < n ; ++i)    {\n        f[i + 1] = f[i];\n        H[i + 1] = H[i];\n        if(S[i] == '>') f[i + 1]++;\n        if(S[i] == '<') f[i + 1]--;\n        if(S[i] == '+') H[i + 1] += p[f[i]];\n        if(S[i] == '-') H[i + 1] -= p[f[i]];\n    }\n \n    mp[H[n]] = 1;\n \n    int ans = 0;\n \n    for(int i = 1 ; i <= n ; ++i)    {\n        ans += mp[H[i]];\n        int exp = f[i] - n;\n        int mul;\n        if(exp < 0) mul = qpow(p[-exp],mod - 2);\n        else        mul = p[exp];\n        mp[H[n] * mul + H[i]]++;\n    }\n \n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <cstdio>\n\nusing namespace std;\n \n#define rep(i, n) for (int i = 0; i < (int) n; i ++)\n \nconst long long MOD = 1e9 + 7;\nconst long long MOD2 = 1e9 + 9;\nconst long long B = 23456789;\n\nlong long Pow(long long a, long long x, long long m) {\n        long long res = 1;\n        while (x > 0) {\n                if (x & 1) res = res * a % m;\n                a = a * a % m;\n                x >>= 1;\n        }\n        return res;\n}\n\nlong long Inv(long long a, long long m) { return Pow(a, m - 2, m); }\n \nint main() {\n\tint n;\n        scanf(\"%d\", &n);\n\tstring s;\n        cin >> s;\n\tint x = 250000;\n        int x2 = 250000;\n        long long h = 0;\n        long long h2 = 0;\n\tvector<int> xs(n + 1);\n\tvector<int> xs2(n + 1);\n        xs[0] = x;\n        xs2[0] = x2;\n\tvector<long long> hs(n + 1);\n\tvector<long long> hs2(n + 1);\n        hs[0] = h;\n        hs2[0] = h2;\n\trep(i, n) {\n\t\tchar c = s[i];\n\t\tif (c == '+') h = (h + Pow(B, x, MOD)) % MOD;\n\t\tif (c == '-') h = (h - Pow(B, x, MOD) + MOD) % MOD;\n\t\tif (c == '>') x ++;\n\t\tif (c == '<') x --;\n\t\txs[i + 1] = x;\n                hs[i + 1] = h;\n\t\tif (c == '+') h2 = (h2 + Pow(B, x2, MOD2)) % MOD2;\n\t\tif (c == '-') h2 = (h2 - Pow(B, x2, MOD2) + MOD2) % MOD2;\n\t\tif (c == '>') x2 ++;\n\t\tif (c == '<') x2 --;\n\t\txs2[i + 1] = x2;\n                hs2[i + 1] = h2;\n\t}\n\tmap<pair<long long, long long>, int> cnt;\n\tlong long ans = 0;\n\tfor (int i = n; i >= 0; i --) {\n\t\tint dx = xs[i] - xs[0];\n\t\tlong long coef = (dx >= 0 ? Pow(B, dx, MOD) : Inv(Pow(B, -dx, MOD), MOD));\n\t\tlong long hoge = (hs[i] + hs[n] * coef) % MOD;\n\t\tint dx2 = xs2[i] - xs2[0];\n\t\tlong long coef2 = (dx2 >= 0 ? Pow(B, dx2, MOD2) : Inv(Pow(B, -dx2, MOD2), MOD2));\n\t\tlong long hoge2 = (hs2[i] + hs2[n] * coef2) % MOD2;\n\t\tans += cnt[make_pair(hoge, hoge2)];\n\t\tcnt[make_pair(hs[i], hs2[i])] ++;\n\t}\n        printf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll    =long long;    using dd   =double;        using pll    =pair<ll, ll>;  using tll    =tuple<ll,ll,ll>;\nusing vll   =vector<ll>;   using vdd  =vector<dd>;    using vpll   =vector<pll>;   using vtll   =vector<tll>;\nusing vvll  =vector<vll>;  using vvdd =vector<vdd>;   using vvpll  =vector<vpll>;  using vvtll  =vector<vtll>;\nusing vvvll =vector<vvll>; using vvvdd=vector<vvdd>;  using vvvpll =vector<vvpll>; using vvvtll =vector<vvtll>;\nusing vvvvll=vector<vvvll>;using vvvvdd=vector<vvvdd>;using vvvvpll=vector<vvvpll>;using vvvvtll=vector<vvvtll>;\n\nconstexpr ll INF = 1LL << 60;\nconstexpr dd EPS = 1e-11;\n\n//cin,cout高速化のおまじない＋桁数指定\nstruct Fast{\n\tFast(){\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(std::numeric_limits<double>::max_digits10);\n\t}\n} fast;\n\n#define REPS(i, S, E) for (ll i = (S); i <= (E); i++)\n#define REP(i, N) REPS(i, 0, (N)-1)\n#define DEPS(i, S, E) for (ll i = (E); i >= (S); i--)\n#define DEP(i, N) DEPS(i, 0, (N)-1)\n#define EACH(e, v) for (auto&& e : v)\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\ntemplate<class T> inline T MaxE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmax(m,v[i]); return m;}//v[S]～v[E]の最大値\ntemplate<class T> inline T MinE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmin(m,v[i]); return m;}//v[S]～v[E]の最小値\ntemplate<class T> inline T MaxE(vector<T> &v, ll N) { return MaxE(v, 0, N - 1); } //先頭N個中の最大値\ntemplate<class T> inline T MinE(vector<T> &v, ll N) { return MinE(v, 0, N - 1); }\ntemplate<class T> inline T MaxE(vector<T> &v) { return MaxE(v, (ll)v.size()); }\ntemplate<class T> inline T MinE(vector<T> &v) { return MinE(v, (ll)v.size()); }\ntemplate<class T> inline ll MaxI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]>v[m])m=i;} return m;}\ntemplate<class T> inline ll MinI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]<v[m])m=i;} return m;}\ntemplate<class T> inline ll MaxI(vector<T> &v, ll N) { return MaxI(v, 0, N - 1); }\ntemplate<class T> inline ll MinI(vector<T> &v, ll N) { return MinI(v, 0, N - 1); }\ntemplate<class T> inline ll MaxI(vector<T> &v) { return MaxI(v, (ll)v.size()); }\ntemplate<class T> inline ll MinI(vector<T> &v) { return MinI(v, (ll)v.size()); }\ntemplate<class T> inline T Sum(vector<T> &v, ll S,ll E){ T s=v[S]; REPS(i,S+1,E)s+=v[i]; return s; }\ntemplate<class T> inline T Sum(vector<T> &v, ll N) { return Sum(v, 0, N - 1); }\ntemplate<class T> inline T Sum(vector<T> &v) { return Sum(v, v.size()); }\ntemplate<class T> inline T POW(T a, ll n){ T r=1; for (; n>0; n>>=1, a*=a){ if (n&1)r*=a; } return r; }\ninline ll POW(int a, ll n){ return POW((ll)a, n); }\ninline ll MSB(ll a){for(ll o=63,x=-1;;){ll m=(o+x)/2; if(a<(1LL<<m))o=m; else x=m; if(o-x==1)return x;}}\ninline ll CEIL(ll a, ll b){ return (a+b-1)/b; }\nll Gcd(ll a, ll b){ return (b==0) ? a : Gcd(b, a%b); }\nll Lcm(ll a, ll b){ return a * b / Gcd(a, b); }\ninline vll Mask2Idx(ll m){vll v; for(ll i=0;m;m>>=1,i++) if(m&1)v.push_back(i); return move(v);}\ninline ll BitNum(ll m){ for (ll c=0;; m>>=1){ c+=m&1; if (!m)return c; } }\ninline ll Bit(ll s, ll i){ return (s>>i)&1; } //sの第ibit i=0-63\ninline ll BitOn(ll s, ll i){ return s|(1LL<<i); } //sの第ibitON i=0-63\ninline ll BitOff(ll s, ll i){ return s&~(1LL<<i); } //sの第ibitOFF i=0-63\ntemplate<class T> inline ll UnderNumOf(vector<T> &v, T x){ //sort済vのx以下の個数を得る\n\treturn upper_bound(v.begin(), v.end(), x) - v.begin(); }\ntemplate<class T, class Pr> inline ll UnderNumOf(vector<T> &v, T x, Pr pred){ //x以下個数\n\treturn upper_bound(v.begin(), v.end(), x, pred) - v.begin(); }\ntemplate<class T> inline ll OverNumOf(vector<T> &v, T x){ //sort済vのx以上の個数を得る\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x) - v.begin()); }\ntemplate<class T, class Pr> inline ll OverNumOf(vector<T> &v, T x, Pr pred){ //x以上の個数\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x, pred) - v.begin()); }\n\ntemplate<class T=ll> inline vector<T> cinv(ll N){ vector<T> v(N); REP(i, N)cin>>v[i]; return move(v);}\ntemplate<class T=ll, class S=ll> inline vector<pair<T, S>> cinv2(ll N){\n\tvector<pair<T, S>> v(N); REP(i,N){cin>>v[i].first>>v[i].second;} return move(v); }\ntemplate<class T=ll,class S=ll,class R=ll> inline vector<tuple<T, S, R>> cinv3(ll N){\n\tvector<tuple<T,S,R>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i]);} return move(v);}\ntemplate<class T=ll,class S=ll,class R=ll,class Q=ll> inline vector<tuple<T,S,R,Q>> cinv4(ll N){\n\tvector<tuple<T,S,R,Q>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i])>>get<3>(v[i]);} return move(v);}\ntemplate<class T=ll> inline vector<vector<T>> cinvv(ll N, ll M){\n\tvector<vector<T>> vv(N); REP(i, N) vv[i] = cinv(M); return move(vv);}\ntemplate<class T> inline void coutv(vector<T> &v, char deli=' '){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?'\\n':deli);} }\ntemplate<class T> void bye(T a){cout << a << '\\n'; exit(0);}\n\n#if defined(_DEBUG)\ntemplate<class T> void Dump(vector<T> &v){\n\tREP(i, (ll)v.size()) { cerr << ((i==0)?\"[\":\" \") << setw(5) << v[i]; }  cerr << \"]\";\n}\nvoid Dump(vll &v){\n\tREP(i, (ll)v.size()) {\n\t\tcerr << ((i==0)?\"[\":\" \") << setw(4);\n\t\tif       (v[i] == INF) cerr << \"INF\";\n\t\telse if (v[i] == -INF) cerr << \"-INF\";\n\t\telse                   cerr << v[i];\n\t}  cerr << \"]\";\n}\ntemplate<class T> void Dump(vector<vector<T>> &v){\n\tll N=(ll)v.size();  string d[2][2]={{\" \", \"[\"},  {\"\\n\", \"]\\n\"}};\n\tREP(i, N) { cerr << d[0][i==0];  Dump(v[i]);  cerr << d[1][i==N-1]; }\n}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  <\", \"[ <\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ---<\", \"[ ---<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">---\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ======<\", \"[ ======<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">======\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\n#else\ntemplate<class T> void Dump(vector<T> &v){}\ntemplate<class T> void Dump(vector<vector<T>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){}\n#endif\n\nstruct mll{\n\tstatic ll MOD;\n\tll val;\n\tmll(ll v = 0): val(v % MOD){ if (val < 0) val += MOD; }\n\tmll operator - () const { return -val; }\n\tmll operator + (const mll &b) const { return val + b.val; }\n\tmll operator - (const mll &b) const { return val - b.val; }\n\tmll operator * (const mll &b) const { return val * b.val; }\n\tmll operator / (const mll &b) const { return mll(*this) /= b; }\n\tmll operator + (ll b) const { return *this + mll(b); }\n\tmll operator - (ll b) const { return *this - mll(b); }\n\tmll operator * (ll b) const { return *this * mll(b); }\n\tfriend mll operator + (ll a, const mll &b) { return b + a; }\n\tfriend mll operator - (ll a, const mll &b) { return -b + a; }\n\tfriend mll operator * (ll a, const mll &b) { return b * a; }\n\tfriend mll operator / (ll a, const mll &b) { return mll(a)/b; }\n\tmll &operator += (const mll &b) { val=(val+b.val)%MOD; return *this; }\n\tmll &operator -= (const mll &b) { val=(val+MOD-b.val)%MOD; return *this; }\n\tmll &operator *= (const mll &b) { val=(val*b.val)%MOD; return *this; }\n\tmll &operator /= (const mll &b) {\n\t\tll c=b.val, d=MOD, u=1, v=0;\n\t\twhile (d){\n\t\t\tll t = c / d;\n\t\t\tc -= t * d; swap(c, d);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tmll &operator += (ll b) { return *this += mll(b); }\n\tmll &operator -= (ll b) { return *this -= mll(b); }\n\tmll &operator *= (ll b) { return *this *= mll(b); }\n\tmll &operator /= (ll b) { return *this /= mll(b); }\n\tbool operator == (const mll &b) { return val == b.val; }\n\tbool operator != (const mll &b) { return val != b.val; }\n\tbool operator == (ll b) { return *this == mll(b); }\n\tbool operator != (ll b) { return *this != mll(b); }\n\tfriend bool operator == (ll a, const mll &b) { return mll(a) == b.val; }\n\tfriend bool operator != (ll a, const mll &b) { return mll(a) != b.val; }\n\tfriend ostream &operator << (ostream &os, const mll &a) { return os << a.val; }\n\tfriend istream &operator >> (istream &is, mll &a) { return is >> a.val; }\n\tstatic mll Combination(ll a, ll b){\n\t\tchmin(b, a-b);\n\t\tif (b<0) return mll(0);\n\t\tmll c = 1;\n\t\tREP(i, b) c *= a-i;\n\t\tREP(i, b) c /= i+1;\n\t\treturn c;\n\t}\n};\nll mll::MOD = 2099999999LL;// 998244353LL;//1000000007LL;\nusing vmll = std::vector<mll>;\nusing vvmll = std::vector<vmll>;\nusing vvvmll = std::vector<vvmll>;\nusing vvvvmll = std::vector<vvvmll>;\nusing vvvvvmll = std::vector<vvvvmll>;\n\nusing Data = tuple<mll, ll, mll>;\n\nData prod(Data a, Data b){\n\tmll ha; ll pa; mll qpa; tie(ha, pa, qpa) = a;\n\tmll hb; ll pb; mll qpb; tie(hb, pb, qpb) = b;\n\treturn Data(ha+qpa*hb, pa+pb, qpa*qpb);\n}\n\nvoid solve()\n{\n\tll N; string S;  cin >> N >> S;\n\tmll q = 999983;\n\tmll qinv = mll(1) / q;\n\n\tData plus  = Data( 1, 0, 1);\n\tData minus = Data(-1, 0, 1);\n\tData right = Data( 0, 1, q);\n\tData left  = Data( 0,-1, qinv);\n\n\t//W求める\n\tData W = Data(0,0,1);\n\tDEPS(i, 0, N-1){\n\t\tData si;\n\t\tif      (S[i] == '+') si = plus;\n\t\telse if (S[i] == '-') si = minus;\n\t\telse if (S[i] == '>') si = right;\n\t\telse                  si = left;\n\t\tW = prod(si, W);\n\t}\n\tmll hW = get<0>(W);\n\n\tunordered_map<ll, ll> CinvMap;\n\tData X    = Data(0,0,1);\n\tData Xinv = Data(0,0,1);\n\tll ans = 0;\n\tDEPS(i, 0, N-1){\n\t\t//現在のXinvをCinvバッファに入れる\n\t\tll h = get<0>(Xinv).val;\n\t\tCinvMap[h]++;\n\t\t//Xを伸ばす\n\t\tData si;\n\t\tif      (S[i] == '+') si = plus;\n\t\telse if (S[i] == '-') si = minus;\n\t\telse if (S[i] == '>') si = right;\n\t\telse                  si = left;\n\t\tX = prod(si, X);\n\t\t//Xinvを伸ばす\n\t\tData siinv;\n\t\tif      (S[i] == '+') siinv = minus;\n\t\telse if (S[i] == '-') siinv = plus;\n\t\telse if (S[i] == '>') siinv = left;\n\t\telse                  siinv = right;\n\t\tXinv = prod(Xinv, siinv);\n\t\t\n\t\t//C^-1のh成分を計算\n\t\tmll hX = get<0>(X);\n\t\tmll qpXinv = get<2>(Xinv);\n\t\tmll hCinv = (hW-hX) * qpXinv;\n\t\tif (CinvMap.count(hCinv.val) == 1){\n\t\t\tans += CinvMap[hCinv.val];\n\t\t}\n\t}\n\tcout << ans << '\\n';\n}\n\n\nint main(){\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <cstdio>\n\nusing namespace std;\n \n#define rep(i, n) for (int i = 0; i < (int) n; i++)\n \nconst int MOD = 1e9 + 7;\nconst int B = 123456;\n\nlong long Pow(long long a, long long x) {\n        long long res = 1;\n        while (x > 0) {\n                if (x & 1) res = res * a % MOD;\n                a = a * a % MOD;\n                x >>= 1;\n        }\n        return res;\n}\n\nlong long Inv(long long a) { return Pow(a, MOD - 2); }\n \nint main() {\n\tint n;\n        scanf(\"%d\", &n);\n\tstring s;\n        cin >> s;\n\tint x = 250000;\n        long long h = 0;\n\tvector<int> xs(n + 1);\n        xs[0] = x;\n\tvector<long long> hs(n + 1);\n        hs[0] = h;\n\trep(i, n) {\n\t\tchar c = s[i];\n\t\tif (c == '+') h = (h + Pow(B, x)) % MOD;\n\t\tif (c == '-') h = (h - Pow(B, x) + MOD) % MOD;\n\t\tif (c == '>') x ++;\n\t\tif (c == '<') x --;\n\t\txs[i + 1] = x;\n                hs[i + 1] = h;\n\t}\n\tmap<long long, int> mp;\n\tlong long ans = 0;\n\tfor (int i = n; i >= 0; i--) {\n\t\tint dx = xs[i] - xs[0];\n\t\tlong long coef = (dx >= 0 ? Pow(B, dx) : Inv(Pow(B, -dx)));\n\t\tlong long hoge = (hs[i] + hs[n] * coef) % MOD;\n\t\tans += mp[hoge];\n\t\tmp[hs[i]]++;\n\t}\n        printf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MN 250000\n#define mod 1004535809\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nchar s[MN+5];\nmap<int,int> mp;long long ans;\nint n,pw[MN*2+5],invpw[MN*2+5],pos[MN+5],ha[MN+5];\ninline int PW(int x){return x>=0?pw[x]:invpw[-x];} \nint main()\n{\n\tn=read();scanf(\"%s\",s+1);pw[0]=invpw[0]=1;\n\tfor(int i=1;i<=n*2;++i) pw[i]=37LL*pw[i-1]%mod,invpw[i]=352945014LL*invpw[i-1]%mod;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tif(s[i]=='<'||s[i]=='>') \n\t\t\tpos[i]=pos[i-1]+(s[i]=='<'?-1:1),\n\t\t\tha[i]=ha[i-1];\n\t\telse pos[i]=pos[i-1],ha[i]=(ha[i-1]+1LL*(s[i]=='+'?1:mod-1)*pw[pos[i]+n])%mod;\n\t}\n\tfor(int i=n;i;--i)\n\t{\n\t\t++mp[(ha[n]-ha[i]+mod)%mod];\n\t\tans+=mp[(1LL*ha[n]*(mod+1-PW(pos[i-1]))+mod-ha[i-1])%mod];\n\t}\n\tcout<<ans;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,\"Line:\",__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\nvoid print(ll x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nint mask(int i){\n\treturn (int(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n    static random_device rd;\n    static mt19937_64 gen(rd());\n    #endif\n    return uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\n//initfact();\n//const uint mod=998244353;\nconst uint mod=1000000007;\n//uint mod=1;\nstruct mint{\n\tuint v;\n\tmint(ll vv=0){s(vv%mod+mod);}\n\tmint& s(uint vv){\n\t\tv=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\tmint operator-()const{return mint()-*this;}\n\tmint& operator+=(const mint&rhs){return s(v+rhs.v);}\n\tmint&operator-=(const mint&rhs){return s(v+mod-rhs.v);}\n\tmint&operator*=(const mint&rhs){\n\t\tv=ull(v)*rhs.v%mod;\n\t\treturn *this;\n\t}\n\tmint&operator/=(const mint&rhs){return *this*=rhs.inv();}\n\tmint operator+(const mint&rhs)const{return mint(*this)+=rhs;}\n\tmint operator-(const mint&rhs)const{return mint(*this)-=rhs;}\n\tmint operator*(const mint&rhs)const{return mint(*this)*=rhs;}\n\tmint operator/(const mint&rhs)const{return mint(*this)/=rhs;}\n\tmint pow(int n)const{\n\t\tmint res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tmint inv()const{return pow(mod-2);}\n\t/*mint inv()const{\n\t\tint x,y;\n\t\tint g=extgcd(v,mod,x,y);\n\t\tassert(g==1);\n\t\tif(x<0)x+=mod;\n\t\treturn mint(x);\n\t}*/\n\tfriend ostream& operator<<(ostream&os,const mint&m){\n\t\treturn os<<m.v;\n\t}\n\tbool operator<(const mint&r)const{return v<r.v;}\n\tbool operator==(const mint&r)const{return v==r.v;}\n};\n\nconst int vmax=(1<<21)+10;\nmint fact[vmax],finv[vmax],invs[vmax];\nvoid initfact(){\n\tfact[0]=1;\n\trng(i,1,vmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[vmax-1]=fact[vmax-1].inv();\n\tfor(int i=vmax-2;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tfor(int i=vmax-1;i>=1;i--){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\nmint choose(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\nmint binom(int a,int b){\n\treturn fact[a+b]*finv[a]*finv[b];\n}\nmint catalan(int n){\n\treturn binom(n,n)-(n-1>=0?binom(n-1,n+1):0);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tinitfact();\n\t\n\tint n;cin>>n;\n\tstring s;cin>>s;\n\t\n\tconst int k=2;\n\t\n\tusing A=array<mint,k>;\n\t\n\tA w,winv;\n\trep(i,k){\n\t\tw[i]=rand_int(1,mod-1);\n\t\twinv[i]=w[i].inv();\n\t}\n\t\n\tmap<A,int> cnt;\n\tvc<A> h(n+1);\n\tA tar;\n\t{\n\t\tA a;\n\t\tA x{1,1};\n\t\trep(i,n){\n\t\t\tif(s[i]=='>'){\n\t\t\t\trep(t,k)\n\t\t\t\t\tx[t]*=w[t];\n\t\t\t}else if(s[i]=='<'){\n\t\t\t\trep(t,k)\n\t\t\t\t\tx[t]*=winv[t];\n\t\t\t}else if(s[i]=='+'){\n\t\t\t\trep(t,k)\n\t\t\t\t\ta[t]+=x[t];\n\t\t\t}else{\n\t\t\t\trep(t,k)\n\t\t\t\t\ta[t]-=x[t];\n\t\t\t}\n\t\t\th[i+1]=a;\n\t\t}\n\t\ttar=a;\n\t}\n\trep(i,n+1)\n\t\tcnt[h[i]]++;\n\tdmp(h);\n\tA a{1,1},b;\n\tint ans=0;\n\trep(i,n){\n\t\tdmp(ans);\n\t\tcnt[h[i]]--;\n\t\t{\n\t\t\tA x;\n\t\t\trep(t,k){\n\t\t\t\tx[t]=(tar[t]-b[t])*a[t];\n\t\t\t}\n\t\t\tans+=cnt[x];\n\t\t}\n\t\tif(s[i]=='>'){\n\t\t\trep(t,k){\n\t\t\t\ta[t]*=w[t];\n\t\t\t\tb[t]*=winv[t];\n\t\t\t}\n\t\t}else if(s[i]=='<'){\n\t\t\trep(t,k){\n\t\t\t\ta[t]*=winv[t];\n\t\t\t\tb[t]*=w[t];\n\t\t\t}\n\t\t}else if(s[i]=='+'){\n\t\t\trep(t,k)\n\t\t\t\tb[t]-=1;\n\t\t}else{\n\t\t\trep(t,k)\n\t\t\t\tb[t]+=1;\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"trapv\")\n#include<bits/stdc++.h>\n#define pb push_back\n#define all(x) x.begin(), x.end()\nusing namespace std;\nusing ll = long long;\nconst int maxn = 1<<20, mod = 119<<23|1;\nconst int B = 1000007;\nint n, pw[maxn], F[maxn], ps = 0, ans = 0;\nstring s;\nmap<int, int> cnt;\nvoid add(int &a, int b) {\n\ta = a+b>=mod?a+b-mod:a+b;\n}\nll bp(ll a, ll p) {\n\tint r = 1;\n\twhile(p) {\n\t\tif(p&1) r = r*a%mod;\n\t\ta = a*a%mod, p>>=1;\n\t}\n\treturn r;\n} \nsigned main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> n >> s;\n\tpw[0] = 1;\n\tfor(int i = 1; i < maxn; i++) pw[i] = pw[i-1]*1ll*B%mod;\n\tcnt[0]++;\n\tint cur = 0;\n\tfor(int i = 0; i < n; i++) {\n\t\tif(s[i] == '>') ps++;\n\t\tif(s[i] == '<') ps--;\n\t\tif(s[i] == '+') add(cur, pw[(maxn/2) + ps]);\n\t\tif(s[i] == '-') add(cur, mod-pw[(maxn/2) + ps]);\n\t\tF[i+1] = cur;\n\t\tcnt[cur]++;\n\t}\n\tps = 0;\n\tfor(int ccur = 0, ps = 0, i = 0; i <= n; i++) {\n\t\tcnt[F[i]]--;\n\t\tans += cnt[(ccur + bp(B, mod-1+ps)*1ll*cur)%mod];\n\t\tif(i == n) continue;\n\t\tif(s[i] == '>') ps++;\n\t\tif(s[i] == '<') ps--;\n\t\tif(s[i] == '+') add(ccur, pw[(maxn/2) + ps]);\n\t\tif(s[i] == '-') add(ccur, mod-pw[(maxn/2) + ps]);\n\t}\n\tcout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nint gcd(int a, int b) { return b ? gcd(b, a % b) : a; }\ntemplate<typename T, typename U> inline bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> inline bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\nstruct Init {\n    Init() {\n        cout << fixed << setprecision(20);\n    };\n} init;\n\nint N;\nstring S;\nint mod = 1e9 + 7;\n\n// 拡張ユークリッドの互除法\nint extgcd(int a, int b, int &x, int &y) {\n    int d = a;\n    if (b != 0) {\n        d = extgcd(b, a % b, y, x);\n        y -= (a / b) * x;\n    } else {\n        x = 1;\n        y = 0;\n    }\n    return d;\n}\n\n// mod逆元\nint mod_inverse(int a, int m) {\n    int x, y;\n    extgcd(a, m, x, y);\n    return (m + x % m) % m;\n}\n\npint f(pint ab, int i, int hash) {\n    if (S[i] == '+') { return pint(ab.first, (ab.second + 1) % mod); }\n    else if (S[i] == '-') { return pint(ab.first, (ab.second - 1 + mod) % mod); }\n    else if (S[i] == '>') { return pint(ab.first * hash % mod, ab.second * hash % mod); }\n    else if (S[i] == '<') {\n        return pint(ab.first * mod_inverse(hash, mod) % mod,\n                    ab.second * mod_inverse(hash, mod) % mod);\n    }\n}\n\npint finv(pint ab, int i, int hash) {\n    if (S[i] == '-') { return pint(ab.first, (ab.second + 1) % mod); }\n    else if (S[i] == '+') { return pint(ab.first, (ab.second - 1 + mod) % mod); }\n    else if (S[i] == '<') { return pint(ab.first * hash % mod, ab.second * hash % mod); }\n    else if (S[i] == '>') {\n        return pint(ab.first * mod_inverse(hash, mod) % mod,\n                    ab.second * mod_inverse(hash, mod) % mod);\n    }\n}\nsigned main() {\n    cin >> N >> S;\n    const int K = 2;\n    vint hash = {114514, 1919, 810};\n    map<int, int> mp[K];\n    pint b[K], c[K];\n    for (int i = 0; i < K; i++) {\n        int h = hash[i];\n        b[i] = c[i] = pint(1, 0);\n        for (int j = N - 1; j >= 0; j--) { b[i] = f(b[i], j, h), mp[i][0] = 1; }\n    }\n    int ans = 0;\n    for (int i = N - 1; i >= 0; i--) {\n        int cur = LLONG_MAX;\n        for (int j = 0; j < K; j++) {\n            int h = hash[j];\n            pint cc = finv(pint(1, 0), i, h);\n            c[j] = pint(c[j].first * cc.first % mod, (c[j].first * cc.second + c[j].second) % mod);\n            int fi = (c[j].first * b[j].second + c[j].second) % mod;\n            chmin(cur, mp[j][fi]);\n            mp[j][c[j].second]++;\n        }\n        ans += cur;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "const int N = 400005;\nconst int LG = 21;\nconst long long MOD = 1e9 + 7;\nconst int INF = 1e9;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nint n;\nstring s;\nll sufa[N];\nll suf0[N];\nconst ll K = 29;\nconst ll rK = rev(K);\nll pref0[N];\nll prefa[N];\nll moves[N];\nmap<int, int> deg;\n\nsigned main()\n{\n    deg[0] = 1;\n    for (int i = 1; i < N; i++) deg[i] = deg[i - 1] * K % MOD;\n    for (int i = 1; i < N; i++) deg[-i] = deg[-i + 1] * rK % MOD;\n    srand(time(NULL));\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n    cin >> n >> s;\n    ll a = 0;\n    for (int i = n - 1; i >= 0; i--)\n    {\n        if (s[i] == '+')\n        {\n            a = (a + MOD - 1) % MOD;\n        }\n        if (s[i] == '-')\n        {\n            a = (a + 1) % MOD;\n        }\n        if (s[i] == '>')\n        {\n            a = (a * K) % MOD;\n        }\n        if (s[i] == '<')\n        {\n            a = (a * rK) % MOD;\n        }\n    }\n    pref0[0] = 0, prefa[0] = a, moves[0] = 0;\n    if (s[0] == '+') pref0[0] = (pref0[0] + 1) % MOD;\n    if (s[0] == '-') pref0[0] = (pref0[0] + MOD - 1) % MOD;\n    if (s[0] == '<') pref0[0] = (pref0[0] * K) % MOD;\n    if (s[0] == '>') pref0[0] = (pref0[0] * rK) % MOD;\n    if (s[0] == '+') prefa[0] = (prefa[0] + 1) % MOD;\n    if (s[0] == '-') prefa[0] = (prefa[0] + MOD - 1) % MOD;\n    if (s[0] == '<') prefa[0] = (prefa[0] * K) % MOD;\n    if (s[0] == '>') prefa[0] = (prefa[0] * rK) % MOD;\n    if (s[0] == '>') moves[0]++;\n    if (s[0] == '<') moves[0]--;\n    for (int i = 1; i < n; i++)\n    {\n        if (s[i] == '+') pref0[i] = (pref0[i - 1] + 1) % MOD;\n        if (s[i] == '-') pref0[i] = (pref0[i - 1] + MOD - 1) % MOD;\n        if (s[i] == '<') pref0[i] = (pref0[i - 1] * K) % MOD;\n        if (s[i] == '>') pref0[i] = (pref0[i - 1] * rK) % MOD;\n        if (s[i] == '+') prefa[i] = (prefa[i - 1] + 1) % MOD;\n        if (s[i] == '-') prefa[i] = (prefa[i - 1] + MOD - 1) % MOD;\n        if (s[i] == '<') prefa[i] = (prefa[i - 1] * K) % MOD;\n        if (s[i] == '>') prefa[i] = (prefa[i - 1] * rK) % MOD;\n        moves[i] = moves[i - 1];\n        if (s[i] == '>') moves[i]++;\n        if (s[i] == '<') moves[i]--;\n    }\n    for (int j = 0; j < n; j++)\n    {\n        if (s[j] == '+')\n        {\n            suf0[0] = (suf0[0] + 1) % MOD;\n        }\n        if (s[j] == '-')\n        {\n            suf0[0] = (suf0[0] + MOD - 1) % MOD;\n        }\n        if (s[j] == '<')\n        {\n            suf0[0] = (suf0[0] * K) % MOD;\n        }\n        if (s[j] == '>')\n        {\n            suf0[0] = (suf0[0] * rK) % MOD;\n        }\n    }\n    for (int i = 0; i < n; i++) suf0[i + 1] = (suf0[0] - pref0[i] * deg[moves[i]] + MOD * MOD) % MOD;\n    for (int i = 0; i < n; i++) sufa[i] = (suf0[i] + a * deg[(i > 0 ? moves[i - 1] : 0) - moves[n - 1]]) % MOD;\n    #ifdef LOCAL\n    for (int i = 0; i < n; i++) cout << pref0[i] * deg[moves[i]] % MOD << \" \"; cout << \"\\n\";\n    for (int i = 0; i < n; i++) cout << prefa[i] * deg[moves[i]] % MOD << \" \"; cout << \"\\n\";\n    for (int i = 0; i < n; i++) cout << suf0[i] << \" \"; cout << \"\\n\";\n    for (int i = 0; i < n; i++) cout << -(moves[n - 1] - moves[i - 1]) << \" \"; cout << \"\\n\";\n    for (int i = 0; i < n; i++) cout << (sufa[i] + MOD - suf0[i]) % MOD << \" \"; cout << \"\\n\";\n    cout << \"This line\\n\";\n    for (int i = 0; i < n; i++) cout << (suf0[i] + a * deg[moves[i - 1] - moves[n - 1]]) % MOD << \" \"; cout << \"\\n\";\n    for (int i = 0; i < n; i++) cout << sufa[i] << \" \"; cout << \"\\n\";\n    cout << \"That line\\n\";\n    for (int i = 0; i < n; i++) cout << (pref0[i] * deg[moves[i]] + suf0[i + 1]) % MOD << \" \"; cout << \"\\n\";\n    for (int i = 0; i < n; i++) cout << (pref0[i] * deg[moves[i]] + sufa[i + 1]) % MOD << \" \"; cout << \"\\n\";\n    #endif // LOCAL\n    ll ans = 0;\n    map<vector<int>, int> cnt;\n    for (int i = n; i >= 0; i--)\n    {\n        ans += cnt[{sufa[i]}];\n        cnt[{suf0[i]}]++;\n    }\n    cout << ans;\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=300005,K=4,p=998244353;\nint read(){\n\tint f=1,g=0;\n\tchar ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-') f=-1;\n\tfor (;isdigit(ch);ch=getchar()) g=g*10+ch-'0';\n\treturn f*g;\n}\nint qpow(int x,int k){\n\tint t=1;\n\tfor (;k;k>>=1){\n\t\tif (k&1) t=(ll)t*x%p;\n\t\tx=(ll)x*x%p;\n\t}\n\treturn t;\n}\nstruct state{\n\tint a[K];\n\tint &operator[](int i){return a[i];}\n\tstate(){memset(a,0,sizeof(a));}\n}x,rx,s[N][2],c,e;\nbool operator==(state a,state b){\n\tfor (int i=0;i<K;i++)\n\tif (a[i]==b[i]) return false;\n\treturn true;\n}\nbool operator<(state a,state b){\n\tfor (int i=0;i<K;i++)\n\tif (a[i]!=b[i]) return a[i]<b[i];\n\treturn false;\n}\nstate operator*(state x,state y){for (int i=0;i<K;i++) x[i]=(ll)x[i]*y[i]%p;return x;}\nstate operator+(state x,state y){for (int i=0;i<K;i++) if((x[i]+=y[i])>=p) x[i]-=p;return x;}\nstate operator-(state x,state y){for (int i=0;i<K;i++) if((x[i]-=y[i])<0) x[i]+=p;return x;}\nstate operator+(state x,int k){for (int i=0;i<K;i++) if ((x[i]+=k)>=p) x[i]-=p;return x;}\nstate operator-(state x,int k){for (int i=0;i<K;i++) if ((x[i]-=k)<0) x[i]+=p;return x;}\nstate getval(state *a,state x){\n\tstate cur=a[0]+a[1]*x;\n\treturn cur;\n}\nint n,m;\nll ans;\nchar ch[N];\nmap<state,int> f;\nint main(){\n\tfor (int i=0;i<K;i++) x[i]=i+1,rx[i]=qpow(x[i],p-2);\n\tn=read();\n\tscanf(\" %s\",ch+1);\n\tfor (int i=0;i<K;i++) s[n+1][1][i]=1;\n\tfor (int i=n;i;i--)\n\tif (ch[i]=='+'){s[i][0]=s[i+1][0]+s[i+1][1];s[i][1]=s[i+1][1];c=c-1;}\n\telse if (ch[i]=='-'){s[i][0]=s[i+1][0]-s[i+1][1];s[i][1]=s[i+1][1];c=c+1;}\n\telse if (ch[i]=='>'){s[i][0]=s[i+1][0];s[i][1]=s[i+1][1]*x;c=c*rx;}\n\telse if (ch[i]=='<'){s[i][0]=s[i+1][0];s[i][1]=s[i+1][1]*rx;c=c*x;}\n\tfor (int i=n;i;i--){\n\t\tf[getval(s[i+1],e)]++;\n\t\tans+=f[getval(s[i],c)];\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <string>\n#include <vector>\n#include <iostream>\nusing namespace std;\ntypedef unsigned long long ull;\nconst ull verse = 259;\nconst ull inverse = 213668850274628011;\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tint n; string s;\n\tcin >> n >> s;\n\tvector<ull> pw(2 * n + 1); pw[n] = 1;\n\tfor (int i = n + 1; i <= 2 * n; ++i) pw[i] = verse * pw[i - 1];\n\tfor (int i = n - 1; i >= 0; --i) pw[i] = inverse * pw[i + 1];\n\tvector<ull> hs(n + 1);\n\tvector<int> dep(n + 1);\n\tfor (int i = 0; i < n; ++i) {\n\t\tdep[i + 1] = dep[i];\n\t\tif (s[i] == '>') ++dep[i + 1];\n\t\tif (s[i] == '<') --dep[i + 1];\n\t\ths[i + 1] = hs[i];\n\t\tif (s[i] == '+') hs[i + 1] += pw[n + dep[i + 1]];\n\t\tif (s[i] == '-') hs[i + 1] -= pw[n + dep[i + 1]];\n\t}\n\tmap<ull, int> cnt;\n\tlong long ret = 0;\n\tfor (int i = n; i >= 0; --i) {\n\t\tull tar = hs[n] * pw[n + dep[i]] + hs[i];\n\t\tret += cnt[tar];\n\t\t++cnt[hs[i]];\n\t}\n\tcout << ret << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\n#include <unordered_map>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\ntypedef __int128 bi;\nconst bi MOD=1000000000000000003LL;\nbi qp(bi a,bi b)\n{\n\tbi x=1; a%=MOD;\n\twhile(b)\n\t{\n\t\tif(b&1) x=x*a%MOD;\n\t\ta=a*a%MOD; b>>=1;\n\t}\n\treturn x;\n}\nconst bi g=233333,rg=qp(g,MOD-2);\npair<bi,bi> operator +\n(pair<bi,bi> a,pair<bi,bi> b)\n{return mp((a.fi+a.se*b.fi)%MOD,a.se*b.se%MOD);}\n#define SZ 666666\nint n; char str[SZ];\npair<bi,bi> sg[SZ],tg(0,1),qz[SZ];\nll ans=0;\nint main()\n{\n\tscanf(\"%d%s\",&n,str+1);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tif(str[i]=='+') sg[i]=mp(1,1);\n\t\telse if(str[i]=='-') sg[i]=mp(MOD-1,1);\n\t\telse if(str[i]=='>') sg[i]=mp(0,g);\n\t\telse sg[i]=mp(0,rg); tg=tg+sg[i];\n\t}\n\tqz[0]=mp(0,1);\n\tfor(int i=1;i<=n;++i) qz[i]=qz[i-1]+sg[i];\n\tmap<ll,int> ms;\n\tfor(int i=n;i>=0;--i)\n\t{ \n\t\t//A.fi+tg.fi*A.se=C.fi\n\t\tans+=ms[(qz[i].fi+tg.fi*qz[i].se)%MOD];\n\t\t++ms[qz[i].fi];\n\t}\n\tcout<<ans<<\"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll N=25e4+10,mo=23333333333333333,M=2e7+3;\nll pw[N],ny[N];\nll n,S,v[N],ans;\nchar s[N];\nll mul(ll a,ll b){\n\tll c=(long double)a*b/mo,z=a*b-c*mo;\n\treturn  z<0?z+mo:z<mo?z:z-mo;\n}\nll power(ll a,ll b=mo-2){\n\tll ans=1;\n\twhile (b){\n\t\tif (b&1)ans=mul(ans,a);\n\t\ta=mul(a,a);\n\t\tb>>=1;\n\t}return ans;\n}\nll base(int p){\n\treturn p<0?ny[-p]:pw[p];\n}\nmap<ll,int> h;\nint main(){\n\tcin>>n;\n\tpw[0]=ny[0]=1;\n\tpw[1]=(1e6+7),ny[1]=power(pw[1]);\n\tfor (int i=2;i<=n;i++)\n\t\tpw[i]=mul(pw[i-1],pw[1]),\n\t\tny[i]=mul(ny[i-1],ny[1]);\n\tint p=0;\n\tscanf(\"%s\",s+1);\n\tfor (int i=1;i<=n;i++){\n\t\tif (s[i]=='+')S=(S+base(p))%mo;\n\t\tif (s[i]=='-')S=(S-base(p)+mo)%mo;\n\t\tif (s[i]=='<')p--;\n\t\tif (s[i]=='>')p++;\n\t\th[S]++;\n\t\tv[i]=S;\n\t}\n//\tcout<<S<<endl;\n\tll a=1,b=0,ia=1;\n\tfor (int i=1;i<=n;i++){\n\t\tll s1=mul((S-b+mo)%mo,ia);\n\t\tans+=h[s1];\n\t\th[v[i]]--;\n\t\tif (s[i]=='+')b=(b-1+mo)%mo;\n\t\tif (s[i]=='-')b=(b+1)%mo;\n\t\tif (s[i]=='<')a=mul(a,pw[1]),b=mul(b,pw[1]),ia=mul(ia,ny[1]);\n\t\tif (s[i]=='>')a=mul(a,ny[1]),b=mul(b,ny[1]),ia=mul(ia,pw[1]);\n//\t\tcout<<ans<<endl;\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define pb push_back\n#define all(v) v.begin(), v.end()\n#define sz(v) int(v.size())\n#define pii pair<int, int>\n#define mp make_pair\n#define f first\n#define ll long long\n#define s second\n#define vec vector<int>\n\nusing namespace std;\n\nconst int N = (int) 770 + 10;\nconst int K = (int) N * N;\nconst int mod = (int) 1e9 + 7;\nconst int T = (int) 200017;\n\nint n;\nstring st;\n\npair<vec, int> get(int l, int r) {\n\tint pos = 2 * n;\n\tvector<int> a(4 * n, 0);\n\tfor (int i = l; i <= r; i++) {\n\t\tif (st[i] == '+') {\n\t\t\ta[pos]++;\n\t\t} else if (st[i] == '-') {\n\t\t\ta[pos]--;\n\t\t} else if (st[i] == '>') {\n\t\t\tpos++;\n\t\t} else {\n\t\t\tpos--;\n\t\t}\n\t}\n\treturn mp(a, pos);\n}\n\n// get(l,r)=(get(0,r)-get(0,l-1))<<pos(0, l-1)\n\nvoid add(int &x, int y) {\n\tx += y;\n\tif (x >= mod)\n\t\tx -= mod;\n\tif (x < 0) \n\t\tx += mod;\n}\n\nint mult(int x, int y) {\n\treturn x * 1ll * y % mod;\n}\n\nint p[N];\n\nint get_hash(vec v) {\n\tint ans = 0;\n\tfor (int i = 0; i < sz(v); i++) {\n\t\tadd(ans, mult(v[i], p[i]));\n\t}\n\treturn ans;\n}\n\nvec shift(vec x, int val) { // to the right\n\tif (val > 0) {\n\t\treverse(all(x));\n\t\twhile (val--) {\n\t\t\tx.pb(0);\n\t\t}\n\t\treverse(all(x));\n\t} else {\n\t\treverse(all(x));\n\t\tval *= -1;\n\t\twhile (val--) {\n\t\t\tx.pop_back();\n\t\t}\n\t\treverse(all(x));\n\t}\n\twhile (sz(x) < 4 * n) x.pb(0);\n\twhile (sz(x) > 4 * n) x.pop_back();\n\treturn x;\n}\n\nvec add(vec x, vec y) {\n\tassert(sz(x) == sz(y));\n\tfor (int i = 0; i < sz(x); i++) {\n\t\tx[i] += y[i];\n\t}\n\treturn x;\n}\n\nint main() {\n\t#ifdef sony\n\t\tfreopen(\"input.txt\", \"r\", stdin);\n\t\tfreopen(\"output.txt\", \"w\", stdout);\n\t#endif\n\tcin >> n >> st;\n\t//HASH(A) = {FOR I = [0...big_N] SUM OF A[I]*T^I % MODULO} WHERE T = PRIME > 2.5 * 10^5\n\tp[0] = 1;\n\tfor (int i = 1; i < N; i++) {\n\t\tp[i] = mult(p[i - 1], T);\n\t}\n\tvec x = get(0, n - 1).f;\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i; j < n; j++) {\n\t\t\tvec y = add(shift(x, get(0, i - 1).s - n), shift(get(0, i - 1).f, 0));\n\t\t\n\n\t\t\tvec z = shift(get(0, j).f, 0);\n\n\t\t\t//cout << \"~~~~~~~~~~~~~~~\\n\";\n\t\t\t//for (auto it : y) cout << it << ' ';\n\t\t\t//cout << endl;\n\t\t\t//for (auto it : z) cout << it << ' ';\n\t\t\t//cout << endl;\n\n\t\t\tif (z == y) {\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n    _____\n  .'     '.\n /  0   0  \\\n|     ^     |\n|  \\     /  |\n \\  '---'  /\n  '._____.'\n*/\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\nstruct chash\n{\n\tint operator()(int x) const\n\t{\n\t\tx ^= (x >> 20) ^ (x >> 12);\n\t\treturn x ^ (x >> 7) ^ (x >> 4);\n\t}\n};\n\ntemplate<typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename U> using hashtable = gp_hash_table<T, U, chash>;\nrandom_device(rd);\nmt19937 rng(rd());\n\ntemplate<class T>\nvoid readi(T &x)\n{\n\tT input = 0;\n\tbool negative = false;\n\tchar c = ' ';\n\twhile (c < '-')\n\t{\n\t\tc = getchar();\n\t}\n\tif (c == '-')\n\t{\n\t\tnegative = true;\n\t\tc = getchar();\n\t}\n\twhile (c >= '0')\n\t{\n\t\tinput = input * 10 + (c - '0');\n\t\tc = getchar();\n\t}\n\tif (negative)\n\t{\n\t\tinput = -input;\n\t}\n\tx = input;\n}\ntemplate<class T>\nvoid printi(T output)\n{\n\tif (output == 0)\n\t{\n\t\tputchar('0');\n\t\treturn;\n\t}\n\tif (output < 0)\n\t{\n\t\tputchar('-');\n\t\toutput = -output;\n\t}\n\tint aout[20];\n\tint ilen = 0;\n\twhile(output)\n\t{\n\t\taout[ilen] = ((output % 10));\n\t\toutput /= 10;\n\t\tilen++;\n\t}\n\tfor (int i = ilen - 1; i >= 0; i--)\n\t{\n\t\tputchar(aout[i] + '0');\n\t}\n\treturn;\n}\ntemplate<class T>\nvoid ckmin(T &a, T b)\n{\n\ta = min(a, b);\n}\ntemplate<class T>\nvoid ckmax(T &a, T b)\n{\n\ta = max(a, b);\n}\ntemplate<class T, class U>\nT nmod(T &x, U mod)\n{\n\tif (x >= mod) x -= mod;\n}\ntemplate<class T>\nT randomize(T mod)\n{\n\treturn (uniform_int_distribution<T>(0, mod - 1))(rng);\n}\n\n#define y0 ___y0\n#define y1 ___y1\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fi first\n#define se second\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\nconst long double PI = 4.0 * atan(1.0);\nconst long double EPS = 1e-10;\n\n#define MAGIC 347\n#define SINF 10007\n#define CO 1000007\n#define INF 1000000007\n#define BIG 1000000931\n#define LARGE 1696969696967ll\n#define GIANT 2564008813937411ll\n#define LLINF 2696969696969696969ll\n#define MAXN 250013\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ld, ld> pdd;\n\nint N;\nint arr[MAXN];\npll S;\nlong long ans;\nunordered_map<ll, int> need;\n\nll expo(ll a, ll e, ll mod)\n{\n\tif (e == 0)\n\t{\n\t\treturn 1;\n\t}\n\tll was = expo(a, e / 2, mod);\n\tif (e % 2)\n\t{\n\t\treturn was * was % mod * a % mod;\n\t}\n\treturn was * was % mod;\n}\nll modinv(ll a, ll e)\n{\n\treturn expo(a, e - 2, e);\n}\npll INV = {modinv(CO, INF), modinv(CO, BIG)};\nvoid solve(int L, int R)\n{\n\tif (L == R)\n\t{\n\t\treturn;\n\t}\n\tneed.clear();\n\tint mid = (L + R) >> 1;\n\t//start from L...mid, end at mid + 1....R\n\tpair<pll, pll> trans = MP(MP(1, 0), MP(1, 0));\n\tpll inv = MP(1, 1);\n\tfor (int i = mid + 1; i <= R; i++)\n\t{\n\t\tif (arr[i] == 0)\n\t\t{\n\t\t\ttrans.fi.fi *= INV.fi; trans.fi.fi %= INF;\n\t\t\ttrans.fi.se *= INV.fi; trans.fi.se %= INF;\n\t\t\ttrans.se.fi *= INV.se; trans.se.fi %= BIG;\n\t\t\ttrans.se.se *= INV.se; trans.se.se %= BIG;\n\t\t\tinv.fi *= CO; inv.fi %= INF;\n\t\t\tinv.se *= CO; inv.se %= BIG;\n\t\t}\n\t\tif (arr[i] == 1)\n\t\t{\n\t\t\ttrans.fi.fi *= CO; trans.fi.fi %= INF;\n\t\t\ttrans.fi.se *= CO; trans.fi.se %= INF;\n\t\t\ttrans.se.fi *= CO; trans.se.fi %= BIG;\n\t\t\ttrans.se.se *= CO; trans.se.se %= BIG;\n\t\t\tinv.fi *= INV.fi; inv.fi %= INF;\n\t\t\tinv.se *= INV.se; inv.se %= BIG;\n\t\t}\n\t\tif (arr[i] == 2)\n\t\t{\n\t\t\ttrans.fi.se++; nmod(trans.fi.se, INF);\n\t\t\ttrans.se.se++; nmod(trans.se.se, BIG);\n\t\t}\n\t\tif (arr[i] == 3)\n\t\t{\n\t\t\ttrans.fi.se--; trans.fi.se += INF; nmod(trans.fi.se, INF);\n\t\t\ttrans.se.se--; trans.se.se += BIG; nmod(trans.se.se, BIG);\n\t\t}\n\t\tpll dif = {(S.fi - trans.fi.se) * inv.fi, (S.se - trans.se.se) * inv.se};\n\t\tdif.fi %= INF; dif.fi += INF; nmod(dif.fi, INF);\n\t\tdif.se %= BIG; dif.se += BIG; nmod(dif.se, BIG);\n\t\tneed[dif.fi * BIG + dif.se]++;\n\t}\n\ttrans = MP(MP(1, 0), MP(1, 0));\n\tfor (int i = mid; i >= L; i--)\n\t{\n\t\tif (arr[i] == 0)\n\t\t{\n\t\t\ttrans.fi.fi *= INV.fi; trans.fi.fi %= INF;\n\t\t\ttrans.se.fi *= INV.se; trans.se.fi %= BIG;\n\t\t}\n\t\tif (arr[i] == 1)\n\t\t{\n\t\t\ttrans.fi.fi *= CO; trans.fi.fi %= INF;\n\t\t\ttrans.se.fi *= CO; trans.se.fi %= BIG;\n\t\t}\n\t\tif (arr[i] == 2)\n\t\t{\n\t\t\ttrans.fi.se += trans.fi.fi; nmod(trans.fi.se, INF);\n\t\t\ttrans.se.se += trans.se.fi; nmod(trans.se.se, BIG);\n\t\t}\n\t\tif (arr[i] == 3)\n\t\t{\n\t\t\ttrans.fi.se -= trans.fi.fi; trans.fi.se += INF; nmod(trans.fi.se, INF);\n\t\t\ttrans.se.se -= trans.se.fi;\ttrans.se.se += BIG; nmod(trans.se.se, BIG);\n\t\t}\n\t\tans += need[trans.fi.se * BIG + trans.se.se];\n\t}\n\tsolve(L, mid);\n\tsolve(mid + 1, R);\n}\n\nint32_t main()\n{\n\tios_base::sync_with_stdio(0);\n\t// cout << fixed << setprecision(10);\n\t// cerr << fixed << setprecision(10);\n\t// freopen (\"file.in\", \"r\", stdin);\n\t// freopen (\"file.out\", \"w\", stdout);\n\tcin >> N;\n\tstring temps;\n\tcin >> temps;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (temps[i] == '<')\n\t\t{\n\t\t\tarr[i] = 0;\n\t\t}\n\t\tif (temps[i] == '>')\n\t\t{\n\t\t\tarr[i] = 1;\n\t\t}\n\t\tif (temps[i] == '+')\n\t\t{\n\t\t\tarr[i] = 2;\n\t\t}\n\t\tif (temps[i] == '-')\n\t\t{\n\t\t\tarr[i] = 3;\n\t\t}\n\t}\n\treverse(arr, arr + N);\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (arr[i] == 0)\n\t\t{\n\t\t\tS.fi *= INV.fi; S.fi %= INF;\n\t\t\tS.se *= INV.se; S.se %= BIG;\n\t\t}\n\t\tif (arr[i] == 1)\n\t\t{\n\t\t\tS.fi *= CO; S.fi %= INF;\n\t\t\tS.se *= CO; S.se %= BIG;\n\t\t}\n\t\tif (arr[i] == 2)\n\t\t{\n\t\t\tS.fi++; nmod(S.fi, INF);\n\t\t\tS.se++; nmod(S.se, BIG);\n\t\t}\n\t\tif (arr[i] == 3)\n\t\t{\n\t\t\tS.fi--; S.fi += INF; nmod(S.fi, INF);\n\t\t\tS.se--; S.se += BIG; nmod(S.se, BIG);\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (arr[i] == 0)\n\t\t{\n\t\t\tif (S == MP(0ll, 0ll)) ans++;\n\t\t}\n\t\tif (arr[i] == 1)\n\t\t{\n\t\t\tif (S == MP(0ll, 0ll)) ans++;\n\t\t}\n\t\tif (arr[i] == 2)\n\t\t{\n\t\t\tif (S == MP(1ll, 1ll)) ans++;\n\t\t}\n\t\tif (arr[i] == 3)\n\t\t{\n\t\t\tif (S == MP((ll) INF - 1, (ll) BIG - 1)) ans++;\n\t\t}\n\t}\n\tsolve(0, N - 1);\n\tcout << ans << '\\n';\n\t//when u <, the # divides by co\n\t//when u >, the # mults by co\n\t//when u +, u add the #\n\t//when u -, u subtract the #\n\t// cerr << \"time elapsed = \" << (clock() / (CLOCKS_PER_SEC / 1000)) << \" ms\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ff first\n#define ss second\n#define mp make_pair\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL, LL> PLL;\n\nconst PLL M=mp(2147483647, 1088888881);   ///Should be large primes\nconst LL base=1135019;              ///Should be a prime larger than highest value\nconst int N = 1e6+7;            ///Highest length of string\n\nostream& operator<<(ostream& os, PLL hash) {\n    return os<<\"(\"<<hash.ff<<\", \"<<hash.ss<<\")\";\n}\n\nPLL operator+ (PLL a, LL x)     {return mp(a.ff + x, a.ss + x);}\nPLL operator- (PLL a, LL x)     {return mp(a.ff - x, a.ss - x);}\nPLL operator* (PLL a, LL x)     {return mp(a.ff * x, a.ss * x);}\nPLL operator+ (PLL a, PLL x)    {return mp(a.ff + x.ff, a.ss + x.ss);}\nPLL operator- (PLL a, PLL x)    {return mp(a.ff - x.ff, a.ss - x.ss);}\nPLL operator* (PLL a, PLL x)    {return mp(a.ff * x.ff, a.ss * x.ss);}\nPLL operator% (PLL a, PLL m)    {return mp(a.ff % m.ff, a.ss % m.ss);}\n\nPLL power (PLL a, LL p) {\n    if (p==0)   return mp(1,1);\n    PLL ans = power(a, p/2);\n    ans = (ans * ans)%M;\n    if (p%2)    ans = (ans*a)%M;\n    return ans;\n}\n\n///Magic!!!!!!!\nPLL inverse(PLL a)  {\n    return power(a, (M.ff-1)*(M.ss-1)-1);\n}\n\nPLL pb[N];      ///powers of base mod M\nPLL invb;\n\n///Call pre before everything\nvoid hashPre() {\n    pb[0] = mp(1,1);\n    for (int i=1; i<N; i++)\n        pb[i] = (pb[i-1] * base)%M;\n    invb = inverse(pb[1]);\n}\n\n///Calculates Hash of a string\nPLL Hash (string s) {\n    PLL ans = mp(0,0);\n    for (int i=0; i<s.size(); i++)\n        ans=(ans*base + s[i])%M;\n    return ans;\n}\n\n///replaces the i-th (0-indexed) character from right from a to b;\nPLL replace(PLL cur, int i, char a, char b) {\n    cur = (cur + pb[i] * (b-a))%M;\n    return (cur + M)%M;\n}\n\n///Erases c from the back of the string\nPLL pop_back(PLL hash, char c) {\n    return (((hash-c)*invb)%M+M)%M;\n}\n\n///Erases c from front of the string with size len\nPLL pop_front(PLL hash, int len, char c) {\n    return ((hash - pb[len-1]*c)%M+M)%M;\n}\n\n///concatenates two strings where length of the right is k\nPLL concat(PLL left, PLL right, int k) {\n    return (left*pb[k] + right)%M;\n}\n\n///Calculates hash of string with size len repeated cnt times\n///This is O(log n). For O(1), pre-calculate inverses\nPLL repeat(PLL hash, int len, LL cnt) {\n    PLL mul = (pb[len*cnt] - 1) * inverse(pb[len]-1);\n    mul = (mul%M+M)%M;\n    PLL ans = (hash*mul)%M;\n\n    if (pb[len].ff == 1)    ans.ff = hash.ff*cnt;\n    if (pb[len].ss == 1)    ans.ss = hash.ss*cnt;\n    return ans;\n}\n\n///Calculates hashes of all prefixes of s including empty prefix\nvector<PLL> hashList(string s) {\n    int n = s.size();\n    vector<PLL> ans(n+1);\n    ans[0] = mp(0,0);\n\n    for (int i=1; i<=n; i++)\n        ans[i] = (ans[i-1] * base + s[i-1])%M;\n    return ans;\n}\n\n///Calculates hash of substring s[l..r] (1 indexed)\nPLL substringHash(const vector<PLL> &hashlist, int l, int r) {\n    int len = (r-l+1);\n    return ((hashlist[r] - hashlist[l-1]*pb[len])%M+M)%M;\n}\n\nconst int MAXN = 5e5+7;\nPLL dan[MAXN];\n\nstruct lfunc {\n    PLL m, c;\n    lfunc(PLL m, PLL c): m(m), c(c) { }\n};\n\nlfunc compose(const lfunc &f, const lfunc &g) {\n    return lfunc((f.m*g.m)%M, (f.c*g.m+g.c)%M);\n}\n\nint main() {\n    hashPre();\n\n    int n; string s;\n    cin >> n >> s;\n\n    map< PLL , int >mp;\n\n    PLL total(0, 0);\n    PLL mal(1, 1);\n    for (int i = 0, p = 0; i < n; i++) {\n        if (s[i]=='>') {\n            p++;\n            mal = (mal*base)%M;\n        } else if (s[i]=='<') {\n            p--;\n            mal = (mal*invb)%M;\n        } else if (s[i]=='+') {\n            total = (total+mal)%M;\n        } else {\n            assert(s[i]=='-');\n            total = (total+M-mal)%M;\n        }\n        dan[i] = total;\n        mp[total]++;\n    }\n\n    PLL one(1, 1);\n    PLL zero(0, 0);\n    PLL _one = (zero+M-one)%M;\n\n    LL ans = 0;\n    lfunc b4(one, zero);\n    for (int i = 0; i < n; i++) {\n        PLL tmp = (total+M-b4.c)%M;\n        tmp = (tmp*inverse(b4.m))%M;\n        ans += mp[tmp];\n        mp[dan[i]]--;\n\n        if (s[i]=='>') {\n            b4 = compose(b4, lfunc(invb, zero));\n        } else if (s[i]=='<') {\n            b4 = compose(b4, lfunc(PLL(base, base), zero));\n        } else if (s[i]=='+') {\n            b4 = compose(b4, lfunc(one, _one));\n        } else {\n            assert(s[i]=='-');\n            b4 = compose(b4, lfunc(one, one));\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "    #include \"bits/stdc++.h\"\n            using namespace std;\n             \n            #define MAX 600012\n             \n            int n;\n            char buf[MAX];\n            string s;\n            valarray<long long int> MOD1;\n            valarray<long long int> MOD2;\n            vector<valarray<long long int> > p2;\n            vector<valarray<long long int> > vv;\n            vector<int> ps;\n            map<pair<long long int,long long int>, int> mp;\n            long long int ppow(long long int i, long long int j, long long int MOD) {\n            \tlong long int ret = 1;\n            \twhile (j) {\n            \t\tif (j & 1LL)ret *= i;\n            \t\tif (ret >= MOD)ret %= MOD;\n            \t\tj >>= 1LL;\n            \t}\n            \treturn ret;\n            }\n             \n            valarray<long long int> calc(int dif) {\n            \tvalarray<long long int> ret;\n            \tret.resize(2, 0);\n            \tfor (int j = 0; j < 2; j++) {\n            \t\tif (dif < 0) {\n            \t\t\tret[j]=ppow(ppow(MOD1[j],MOD2[j]-2,MOD2[j]),-dif,MOD2[j]);\n            \t\t}\n            \t\telse {\n            \t\t\tret[j] = ppow(MOD1[j],dif, MOD2[j]);\n            \t\t}\n            \t}\n            \treturn ret;\n            }\n             \n            int main() {\n            \tMOD1.resize(2);\n            \tMOD2.resize(2);\n            \tp2.push_back(valarray<long long int>());\n            \tp2.back().resize(2);\n            \tp2.back()[0] = p2.back()[1] = 1;\n            \tMOD2[1] = 1000000007;\n            \tMOD1[0] = 555522277;\n            \tMOD1[1] = 895612782;\n            \tMOD2[0] = 998244353;\n            \tp2[0] %= MOD2;\n            \tfor (int i = 1; i < MAX; i++) p2.push_back((p2.back()*MOD1)%MOD2);\n            \tcin >> n;\n            \tscanf(\"%s\", buf);\n            \ts = buf;\n            \tint pos = MAX/2;\n            \tvalarray<long long int> hs;\n            \ths.resize(2,0);\n            \tvv.push_back(hs);\n            \tps.push_back(pos);\n            \tfor (int i = 0; i < s.size(); i++) {\n            \t\tif (s[i] == '<') pos--;\n            \t\telse if (s[i] == '>') pos++;\n            \t\telse if (s[i] == '+') hs += p2[pos];\n            \t\telse if (s[i] == '-') hs += MOD2-p2[pos];\n            \t\ths %= MOD2;\n            \t\tif(hs[0]<0LL||hs[1]<0LL||p2[pos][0]<0LL||p2[pos][1]<0LL)return 1;\n            \t\tvv.push_back(hs);\n            \t\tps.push_back(pos);\n            \t}\n            \tlong long int way = 0;\n            \tfor (int i = vv.size() - 1; i >= 0; i--) {\n            \t\tvalarray<long long int> want = (vv[i] + ((vv.back()*calc(-MAX/2+ps[i]))%MOD2))%MOD2;\n            \t\tway += mp[make_pair(want[0], want[1])];\n            \t\tmp[make_pair(vv[i][0],vv[i][1])]++;\n            \t}\n            \tprintf(\"%lld\\n\", way);\n            \treturn 0;\n            }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 250010;\nconst int mod[] = {1004535809, 998244353};\nconst int P[] = {131, 233};\n\ntypedef long long LL;\n\nint Pow[2][N * 2]; char s[N];\n\ninline int FUCK(int x, int y, int mod) {\n    int res = 1;\n    for (; y; y >>= 1, x = (LL)x * x % mod) if (y & 1) res = (LL)res * x % mod;\n    return res;\n}\n\nstruct Data {\n    int val[2];\n\n    Data(int a = 0, int b = 0) {val[0] = a, val[1] = b;} \n\n    Data operator + (const Data &b) {\n        Data res;\n        res.val[0] = (val[0] + b.val[0]) % mod[0];\n        res.val[1] = (val[1] + b.val[1]) % mod[1];\n        return res;\n    }\n\n    Data operator - (const Data &b) {\n        Data res;\n        res.val[0] = (val[0] - b.val[0] + mod[0]) % mod[0];\n        res.val[1] = (val[1] - b.val[1] + mod[1]) % mod[1]; \n        return res;\n    }\n\n    Data operator * (const int b) {\n        Data res = *this;\n        int a = b >= 0 ? Pow[0][b] : FUCK(P[0], (LL)(mod[0] - 2) * (-b) % mod[0], mod[0]);\n        int c = b >= 0 ? Pow[1][b] : FUCK(P[1], (LL)(mod[1] - 2) * (-b) % mod[1], mod[1]);\n        res.val[0] = (LL)res.val[0] * a % mod[0];\n        res.val[1] = (LL)res.val[1] * c % mod[1];\n        return res;\n    }\n\n    bool operator < (const Data &b) const {\n        if (val[0] != b.val[0]) return val[0] < b.val[0];\n        return val[1] < b.val[1];\n    }\n};\n\nmap<Data, int> mp;\n\ninline void increase(Data &a, int b) {\n    a = a + (Data){Pow[0][b], Pow[1][b]};\n}\n\ninline void decrease(Data &a, int b) {\n    a = a - (Data){Pow[0][b], Pow[1][b]};\n}\n\nint main() {\n    int n; scanf(\"%d%s\", &n, s + 1); Data all;\n    Pow[0][0] = Pow[1][0] = 1;\n    for (int i = 0; i <= 1; i++)\n        for (int j = 1; j <= n * 2; j++)\n            Pow[i][j] = (LL)Pow[i][j - 1] * P[i] % mod[i];\n    for (int i = 1, ls = 0; i <= n; i++) {\n        if (s[i] == '<') ls--;\n        else if (s[i] == '>') ls++;\n        else if (s[i] == '+') increase(all, ls + n);\n        else decrease(all, ls + n);\n    }\n    Data fuck; mp[all] = 1; LL res = 0;\n    for (int i = 1, ls = 0; i <= n; i++) {\n        if (s[i] == '<') ls--;\n        else if (s[i] == '>') ls++;\n        else if (s[i] == '+') increase(fuck, ls + n);\n        else decrease(fuck, ls + n);\n        res += mp[fuck], mp[fuck + all * ls]++;\n    }\n    printf(\"%lld\\n\", res);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T1, typename T2>bool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>bool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>void ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>void debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++){cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++){for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>void debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];for(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>vector<vector<T>>vec(ll x, ll y, T w){vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,-1,0,0,1,1,-1,-1};vector<ll>dy={0,0,1,-1,1,-1,1,-1};\ntemplate<typename T>vector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>auto make_v(size_t a,Ts... ts){return vector<decltype(make_v(ts...))>(a,make_v(ts...));}\ntemplate<typename T1, typename T2>ostream &operator<<(ostream &os, const pair<T1, T2>&p){return os << p.first << \" \" << p.second;}\ntemplate<typename T>ostream &operator<<(ostream &os, const vector<T> &v){for(auto &z:v)os << z << \" \";cout<<\"|\"; return os;}\n//mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\ntemplate< int mod >\nstruct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while(n > 0) {\n      if(n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  friend ostream &operator<<(ostream &os, const ModInt &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n\n  static int get_mod() { return mod; }\n};\nusing modint = ModInt< MOD1 >;modint pow(ll n, ll x){return modint(n).pow(x);}modint pow(modint n, ll x){return n.pow(x);}\n//using modint=ld;\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll n;cin>>n;\n  string s;cin>>s;\n  modint mul=979418779;\n  modint div=modint(1)/mul;\n  vector<modint>a(n+1,1),b(n+1);\n  rep(i,0,n){\n    a[i+1]=a[i],b[i+1]=b[i];;\n    if(s[i]=='>')a[i+1]*=mul;\n    if(s[i]=='<')a[i+1]*=div;\n    if(s[i]=='+')b[i+1]+=a[i];\n    if(s[i]=='-')b[i+1]-=a[i];\n  }\n  map<ll,ll>mp;\n  modint all=b[n];\n  rrep(i,0,n+1){\n    //all=(b[to]-b[i])/a[i]\n    auto to=all*a[i]+b[i];\n    res+=mp[to.x];\n    mp[b[i].x]++;\n  }\n  cout<<res<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <map>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define ll long long\n\nll poww(ll a, ll b, ll mod) {\n    ll ans = 1;\n    while (b > 0) {\n        if (b & 1) ans = (ans * a) % mod;\n        b >>= 1;\n        a = (a * a) % mod;\n    }\n    return ans;\n}\n\nconst int maxN = 250011;\n\nconst ll mod = 1000000007;\nconst ll base = 500167;\nconst ll inv_base = poww(base, mod - 2, mod);\n\nconst ll mod2 = 1000000009;\nconst ll base2 = 503803; \nconst ll inv_base2 = poww(base2, mod2 - 2, mod2);\n\nstruct hash_key {\n    ll v1, v2;\n\n    hash_key() {v1 = v2 = 0;}\n    hash_key(ll _v1, ll _v2) {v1 = _v1; v2 = _v2;}\n\n    bool operator<(const hash_key &who) const {\n        return mp(v1, v2) < mp(who.v1, who.v2);\n    }\n    \n    bool operator==(const hash_key &who) const {\n        return mp(v1, v2) == mp(who.v1, who.v2);\n    }\n\n    void operator*=(const hash_key who) {\n        v1 = (v1 * who.v1) % mod;\n        v2 = (v2 * who.v2) % mod2;\n    }\n\n    void operator+=(ll v) {\n        v1 = (v1 + mod + v) % mod;\n        v2 = (v2 + mod2 + v) % mod2;\n    }\n\n    void operator+=(hash_key who) {\n        v1 = (v1 + who.v1) % mod;\n        v2 = (v2 + who.v2) % mod2;\n    }\n\n    hash_key get_inv()const {\n        return {poww(v1, mod - 2, mod), poww(v2, mod2 - 2, mod2)};\n    }\n};\n\nstruct smart_map {\n    map<hash_key, ll> M;\n    hash_key bonus;\n\n    smart_map() {\n        M.clear();\n        bonus = {1, 1};\n    }\n\n    void operator*=(hash_key who) {\n        bonus *= who;\n    }\n\n    void add(hash_key x) {\n        x *= bonus.get_inv();\n        M[x]++;\n    }\n\n    ll query(hash_key x) {\n        x *= bonus.get_inv();\n        return M[x];\n    }\n};\n\nll n, i;\nchar s[maxN];\nsmart_map data;\nll ans;\n\nhash_key act, full;\nconst hash_key to_left = {base, base2};\nconst hash_key to_right = {inv_base, inv_base2};\n\nint main()\n{\n   // freopen(\"test.in\",\"r\",stdin);\n\n    scanf(\"%d\\n%s\", &n, s + 1);\n\n    data.add(hash_key(0, 0));\n    act = {0, 0};\n\n    for (i = n; i >= 1; i--) {\n        if (s[i] == '+') act += 1;    \n        if (s[i] == '-') act += -1;\n        if (s[i] == '<') act *= to_left;\n        if (s[i] == '>') act *= to_right;\n    }\n\n    full = act;\n    act = {0, 0};\n\n    for (i = n; i >= 1; i--) {\n        if (s[i] == '+') act += 1;    \n        if (s[i] == '-') act += -1;\n        if (s[i] == '<') act *= to_left, data *= to_left;\n        if (s[i] == '>') act *= to_right, data *= to_right;\n    \n        hash_key src = act;\n        src += hash_key(mod - full.v1, mod2 - full.v2);\n        ans += data.query(src);\n\n        data.add(act);\n    }\n\n    printf(\"%lld\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// This amazing code is by Eric Sunli Chen.\n#include<bits/stdc++.h>\nusing namespace std;\ntemplate<typename T> bool get_int(T &x)\n{\n\tchar t=getchar();\n\tbool neg=false;\n\tx=0;\n\tfor(; (t>'9'||t<'0')&&t!='-'&&t!=EOF; t=getchar());\n\tif(t=='-')neg=true,t=getchar();if(t==EOF)return false;\n\tfor(; t<='9'&&t>='0'; t=getchar())x=x*10+t-'0';\n\tif(neg)x=-x;return true;\n}\ntemplate<typename T> void print_int(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tshort a[20]= {},sz=0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1; i>=0; i--)putchar('0'+a[i]);\n}\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\n#define get1(a) get_int(a)\n#define get2(a,b) (get1(a)&&get1(b))\n#define get3(a,b,c) (get1(a)&&get2(b,c))\n#define printendl(a) print_int(a),puts(\"\")\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef pair<int,int> pii;\nconst int inf=0x3f3f3f3f;\nconst LL Linf=1ll<<61;\nconst double pi=acos(-1.0);\n\nint qpow(int x,int y,int mod)\n{\n\tint ret=1;\n\twhile(y)\n\t{\n\t\tif(y&1)ret=(LL)ret*x%mod;\n\t\tx=(LL)x*x%mod;\n\t\ty>>=1;\n\t}\n\treturn ret;\n}\n\nconst int maxn=250111;\nconst int mod1=998244353;\nconst int mod2=1e9+7;\nconst int base=443;\nconst int inv1=qpow(base,mod1-2,mod1);\nconst int inv2=qpow(base,mod2-2,mod2);\n\npii merge1(const pii&a,const pii&b){return mp(1ll*a.ff*b.ff%mod1,(1ll*a.ff*b.ss+a.ss)%mod1);}\npii merge2(const pii&a,const pii&b){return mp(1ll*a.ff*b.ff%mod2,(1ll*a.ff*b.ss+a.ss)%mod2);}\npair<pii,pii> merge(const pair<pii,pii>&a,const pair<pii,pii>&b){return mp(merge1(a.ff,b.ff),merge2(a.ss,b.ss));}\nint eval1(const int&a,const pii&b){return ((LL)a*b.ff+b.ss)%mod1;}\nint eval2(const int&a,const pii&b){return ((LL)a*b.ff+b.ss)%mod2;}\npii eval(const pii&a,const pair<pii,pii>&b){return mp(eval1(a.ff,b.ff),eval2(a.ss,b.ss));}\n\nint n;\npair<pii,pii> tran[maxn];\nchar s[maxn];\n\nint main()\n{\n\tscanf(\"%d%s\",&n,s+1);\n\t\n\tpii cur=mp(0,0);\n\ttran[n+1]=mp(mp(1,0),mp(1,0));\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tif(s[i]=='+')\n\t\t{\n\t\t\ttran[i]=merge(tran[i+1],mp(mp(1,1),mp(1,1)));\n\t\t\tcur=eval(cur,mp(mp(1,mod1-1),mp(1,mod2-1)));\n\t\t}\n\t\telse if(s[i]=='-')\n\t\t{\n\t\t\ttran[i]=merge(tran[i+1],mp(mp(1,mod1-1),mp(1,mod2-1)));\n\t\t\tcur=eval(cur,mp(mp(1,1),mp(1,1)));\n\t\t}\n\t\telse if(s[i]=='<')\n\t\t{\n\t\t\ttran[i]=merge(tran[i+1],mp(mp(base,0),mp(base,0)));\n\t\t\tcur=eval(cur,mp(mp(inv1,0),mp(inv2,0)));\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttran[i]=merge(tran[i+1],mp(mp(inv1,0),mp(inv2,0)));\n\t\t\tcur=eval(cur,mp(mp(base,0),mp(base,0)));\n\t\t}\n\t}\n\t\n\tLL ans=0;\n\tmap<pii,int> cnt;\n\tcnt[mp(0,0)]++;\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tans+=cnt[eval(cur,tran[i])];\n\t\tcnt[mp(tran[i].ff.ss,tran[i].ss.ss)]++;\n\t}\n\tprintendl(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "        #include \"bits/stdc++.h\"\n        using namespace std;\n         \n        #define MAX 600012\n         \n        int n;\n        char buf[MAX];\n         \n         \n        string s;\n         \n         \n        //#define MOD1 1000000007\n        //#define MOD2 1000000009\n         \n        valarray<long long int> MOD1;\n        valarray<long long int> MOD2;\n        vector<valarray<long long int> > p2;\n        vector<valarray<long long int> > vv;\n        vector<int> ps;\n        map<pair<long long int,long long int>, int> mp;\n        long long int ppow(long long int i, long long int j, long long int MOD) {\n        \tlong long int ret = 1;\n        \twhile (j) {\n        \t\tif (j & 1LL)ret *= i;\n        \t\tif (ret >= MOD)ret %= MOD;\n        \t\tj >>= 1LL;\n        \t}\n        \treturn ret;\n        }\n         \n        valarray<long long int> calc(int dif) {\n        \tvalarray<long long int> ret;\n        \tret.resize(2, 0);\n        \tfor (int j = 0; j < 2; j++) {\n        \t\tif (dif < 0) {\n        \t\t\tret[j]=ppow(ppow(MOD1[j],MOD2[j]-2,MOD2[j]),-dif,MOD2[j]);\n        \t\t}\n        \t\telse {\n        \t\t\tret[j] = ppow(MOD1[j],dif, MOD2[j]);\n        \t\t}\n        \t}\n        \treturn ret;\n        }\n         \n        int main() {\n        \tMOD1.resize(2);\n        \tMOD2.resize(2);\n        \tp2.push_back(valarray<long long int>());\n        \tp2.back().resize(2);\n        \tp2.back()[0] = p2.back()[1] = 1;\n        \tMOD2[0] = 1000000007;\n        \tMOD1[0] = 555522277;\n        \tMOD1[1] = 895612782;\n        \tMOD2[1] = 998244353;\n        \tp2[0] %= MOD2;\n        \tfor (int i = 1; i < MAX; i++) {\n        \t\tp2.push_back((p2.back()*MOD1)%MOD2);\n\t\t\t}\n        \tcin >> n;\n        \tscanf(\"%s\", buf);\n        \ts = buf;\n        \tint pos = MAX/2;\n        \tvalarray<long long int> hs;\n        \ths.resize(2,0);\n        \tvv.push_back(hs);\n        \tps.push_back(pos);\n        \tfor (int i = 0; i < s.size(); i++) {\n        \t\tif (s[i] == '<') pos--;\n        \t\telse if (s[i] == '>') pos++;\n        \t\telse if (s[i] == '+') hs += p2[pos];\n        \t\telse if (s[i] == '-') hs += MOD2-p2[pos];\n        \t\ths %= MOD2;\n        \t\tvv.push_back(hs);\n        \t\tps.push_back(pos);\n        \t}\n        \tlong long int way = 0;\n        \tfor (int i = vv.size() - 1; i >= 0; i--) {\n        \t\tvalarray<long long int> want = (vv[i] + ((vv.back()*calc(-MAX/2+ps[i]))%MOD2))%MOD2;\n        \t\tway += mp[make_pair(want[0], want[1])];\n        \t\tmp[make_pair(vv[i][0],vv[i][1])]++;\n        \t}\n        \tprintf(\"%lld\\n\", way);\n        \treturn 0;\n        }\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int N=250005,M1=1000020221,M2=1000000009;\nusing namespace std;\nint n,now,a[N],b1[N],b2[N],w1,w2,tp,a1,a2;\nchar S[N];\nlong long ans;\nmap<pair<int,int>,int>mp;\ninline int pls(int x,int y,int M){\n\treturn ((x+y)%M+M)%M;\n}\ninline void sol(bool fl){\n\tnow=n,w1=w2=0;\n\tfor(int i=1;i<=n;i++){\n\t\t//cerr<<i<<\"===now:\"<<now<<endl;\n\t\tif(fl)mp[{pls(1ll*b1[now]*a1%M1,1ll*w1*b1[n]%M1,M1),\n\t\tpls(1ll*b2[now]*a2%M2,1ll*w2*b2[n]%M2,M2)}]++;\n\t\t//cerr<<\"ins \"<<pls(1ll*b1[now]*a1%M1,1ll*w1*b1[n]%M1,M1)<<','<<\n\t\t//pls(1ll*b2[now]*a2%M2,1ll*w2*b2[n]%M2,M2)<<endl;\n\t\tif(S[i]>59)now+=S[i]-61;\n\t\telse{\n\t\t\t//cerr<<S[i]<<\"?\";\n\t\t\ttp=44-S[i];\n\t\t\tw1=pls(w1,tp*b1[now],M1);\n\t\t\tw2=pls(w2,tp*b2[now],M2);\n\t\t}\n\t\tif(fl)ans+=mp[{1ll*w1*b1[n]%M1,1ll*w2*b2[n]%M2}];\n\t\t//cerr<<\"(\"<<w1<<','<<w2<<\")\\n\";\n\t}\n}\nint main(){\n\t//freopen(\"dat.txt\",\"r\",stdin);\n\t//cerr<<(int)'+'<<' '<<(int)'-'<<' '<<(int)'>'<<' '<<(int)'<'<<endl;\n\tscanf(\"%d%s\",&n,S+1);\n\tb1[1]=b2[1]=1;\n\tfor(int i=1;i<=2*n;i++)\n\t//b1[i+1]=1ll*b1[i]*7%M1,b2[i+1]=1ll*b2[i]*11%M2;\n\tb1[i+1]=1ll*b1[i]*524287%M1,b2[i+1]=1ll*b2[i]*998244353%M2;\n\tsol(0),a1=w1,a2=w2,//cerr<<\"INI:(\"<<a1<<','<<a2<<\")\\n\",\n\tsol(1);\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define mp make_pair\n#define PI pair<int,int>\n#define poly vector<ll>\n#define mem(a) memset((a),0,sizeof(a))\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\n#define pb push_back\n#define fi first\n#define se second\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst ull base=2333;\nconst int N=250005;\nchar ch[N];\null f[N];\nmap<ull,int> M;\nint main(){\n\tull zs=base; For(i,1,63)zs=zs*zs;\n\tconst ull inv=zs;  assert(zs*inv==1);\n\tint n=read();\n\tscanf(\"%s\",ch+1);\n\tull dq=1;\n\tFor(i,1,n){\n\t\tif(ch[i]=='+')f[i]+=dq;\n\t\tif(ch[i]=='-')f[i]-=dq;\n\t\tif(ch[i]=='>')dq*=base;\n\t\tif(ch[i]=='<')dq*=inv;\n\t\tM[f[i]]++;\n\t}\n\tll ans=0; dq=1;\n\tFor(i,1,n){\n\t\tans+=M[f[n]*dq+f[i-1]];\n\t\tif(ch[i]=='<')dq*=base;\n\t\tif(ch[i]=='>')dq*=inv;\n\t\tM[f[i]]--;\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pint = pair<int, int>;\n#define x first\n#define y second\n\nostream& operator<<(ostream &st, const pint p) {\n    st << \"(\" << p.x << \", \" << p.y << \")\";\n    return st;\n}\n\nconst int mod = 1610612741, x1 = 921, x2 = 1209;\n\nstring s;\nint n, a[250004];\npint p[250004];\n\nint add(int x, int y) { return (x+(long long)y+mod) % mod; }\nint mul(int x, int y) { return (x*(long long)y) % mod; }\nint power(int x, int k) {\n    if (k<0) k += mod-1;\n    if (k==0) return 1;\n    if (k%2) return mul(x, power(x, k-1));\n    int t = power(x, k/2);\n    return mul(t, t);\n}\n\nint main() {\n    cin >> n >> s;\n\n    s = \" \" + s;\n\n    for (int i=1; i<=n; i++) {\n        a[i] = a[i-1];\n        if (s[i] == '>') a[i]++;\n        if (s[i] == '<') a[i]--;\n    }\n\n    int k1 = 0, k2 = 0;\n    for (int i=1; i<=n; i++) {\n        if (s[i] == '+') k1 = add(k1, power(x1, a[i])), k2 = add(k2, power(x2, a[i]));\n        if (s[i] == '-') k1 = add(k1,-power(x1, a[i])), k2 = add(k2,-power(x2, a[i]));\n        p[i] = pint(k1, k2);\n    }\n\n    map<pint, int> m;\n    long long ans = 0;\n    for (int i=0; i<=n; i++) {\n        if (i) ans += m[p[i]];\n        m[pint(add(p[i].x, mul(p[n].x, power(x1, a[i]))), add(p[i].y, mul(p[n].y, power(x2, a[i]))))] += 1;\n    }\n\n    cout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"tune=native\")\n#pragma GCC target(\"avx\")\nusing ll = long long;\nconstexpr ll pow(const ll a, const ll b, const ll mod) { return b == 0 ? 1LL : b % 2 == 1 ? pow(a, b - 1, mod) * a % mod : pow(a * a % mod, b / 2, mod); }\nconstexpr ll inverse(const ll a, const ll mod) { return pow(a, mod - 2, mod); }\nconstexpr ll MOD0 = 1000000007LL, MOD1 = 1000000009LL, MOD2 = 1000000021;\nconstexpr ll X = 121234243;\nconstexpr ll XINV0 = inverse(X, MOD0), XINV1 = inverse(X, MOD1), XINV2 = inverse(X, MOD2);\nconstexpr int L = 250000;\nusing P = std::tuple<ll, ll, ll>;\nP power[L+1] = {P{1, 1, 1}}, invpower[L+1] = {P{1, 1, 1}};\nauto plus = [](const P& p1, const P& p2) { return P{(std::get<0>(p1) + std::get<0>(p2)) % MOD0, (std::get<1>(p1) + std::get<1>(p2)) % MOD1, (std::get<2>(p1) + std::get<2>(p2)) % MOD2}; };\nauto minus = [](const P& p1, const P& p2) { return P{(std::get<0>(p1) + MOD0 - std::get<0>(p2)) % MOD0, (std::get<1>(p1) + MOD1 - std::get<1>(p2)) % MOD1, (std::get<2>(p1) + MOD2 - std::get<2>(p2)) % MOD2}; };\nauto rshift = [](const P& p) { return P{std::get<0>(p) * X % MOD0, std::get<1>(p) * X % MOD1, std::get<2>(p) * X % MOD2}; };\nauto lshift = [](const P& p) { return P{std::get<0>(p) * XINV0 % MOD0, std::get<1>(p) * XINV1 % MOD1, std::get<2>(p) * XINV2 % MOD2}; };\nauto mul = [](const P& p1, const P& p2) { return P{std::get<0>(p1) * std::get<0>(p2) % MOD0, std::get<1>(p1) * std::get<1>(p2) % MOD1, std::get<2>(p1) * std::get<2>(p2) % MOD2}; };\nint main()\n{\n    for (int i = 1; i <= L; i++) { power[i] = rshift(power[i - 1]), invpower[i] = lshift(invpower[i - 1]); }\n    auto invp = [](const int i) { return i >= 0 ? invpower[i] : power[-i]; };\n    int N;\n    std::string S;\n    std::cin >> N >> S;\n    std::vector<int> deg(N + 1, 0);\n    std::vector<P> value(N + 1, P{0, 0, 0});\n    for (int i = N - 1; i >= 0; i--) {\n        if (S[i] == '-') {\n            deg[i] = deg[i + 1], value[i] = minus(value[i + 1], P{1, 1, 1});\n        } else if (S[i] == '+') {\n            deg[i] = deg[i + 1], value[i] = plus(value[i + 1], P{1, 1, 1});\n        } else if (S[i] == '>') {\n            deg[i] = deg[i + 1] + 1, value[i] = rshift(value[i + 1]);\n        } else {\n            deg[i] = deg[i + 1] - 1, value[i] = lshift(value[i + 1]);\n        }\n    }\n    const P answer = value[0];\n    for (int i = 0; i <= N; i++) { value[i] = mul(minus(value[i], answer), invp(deg[i])); }\n    std::map<P, ll> mp;\n    ll ans = 0;\n    for (int i = 0; i <= N; i++) {\n        const P obj = plus(value[i], mul(invp(deg[i]), answer));\n        if (mp.find(obj) != mp.end()) { ans += mp[obj]; }\n        mp[value[i]]++;\n    }\n    std::cout << ans << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2e5 + 5;\n//const int mod = 1e9 + 7;\ntypedef long long ll;\n#define mp make_pair\n\nchar c;\nstring s;\nint n,i,ans;\nmap < pair < int , int > , int > M;\n\n\nstruct hash{\n    ll t,a,b,x,bol,X,mod;\n    hash() { t=b=x=X=mod=0; a=bol=1; }\n    void f(){ \n        for(t=X,i=mod-2; i ; i>>=1){\n            if(i & 1) bol = bol*t % mod;\n            t = t*t % mod;\n        }\n        for(i=n-1; i>=0 ;i--){\n            c = s[i];\n            if(c == '-') x--;\n            if(c == '+') x++;\n            if(c == '>') x *= X;\n            if(c == '<') x *= bol; \n            x = (x % mod + mod) % mod;\n        }\n    }\n            \n    void g(){   \n        if(c == '+') b -= a;\n        if(c == '-') b += a;    \n        if(c == '>') a *= bol;                  \n        if(c == '<') a *= X;                                \n        a = (a % mod + mod) % mod;                                  \n        b = (b % mod + mod) % mod;      \n        t = (a*x + b) % mod;                            \n    }                                                               \n};                                                                              \n                                                                                            \nint main(){                                                                                             \n    cin >> n >> s;                                                                                                  \n                                                                                                                            \n    struct hash h1,h2;                      \n    h1.mod = 1e9+7;  h1.X=10000003; h1.f();\n    h2.mod = 1e9+9;  h2.X=1000007; h2.f();\n                                    \n    M[mp(0,0)] = 1;                         \n    for(i=n-1; i>=0 ;i--){                          \n        c = s[i];                                           \n        h1.g(); h2.g();                                             \n                                                                            \n        ans += M[mp(h1.t,h2.t)];                                                    \n        M[mp(h1.b,h2.b)]++;                                                             \n    }\n\n    cout << ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\n\nint N;\nstring S;\nll mo=1000000007;\nvector<ll> C,R;\nconst int PAT=5;\nvector<ll> A[PAT];\nvector<ll> B[PAT];\n\nll modpow(ll a, ll n = mo-2) {\n\tll r=1;a%=mo;\n\twhile(n) r=r*((n%2)?a:1)%mo,a=a*a%mo,n>>=1;\n\treturn r;\n}\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>S;\n\tsrand(time(NULL));\n\tFOR(i,PAT) {\n\t\tC.push_back(rand()%10000000+10000000);\n\t\tR.push_back(modpow(C.back()));\n\t\tA[i].push_back(1);\n\t\tB[i].push_back(0);\n\t}\n\treverse(ALL(S));\n\tFORR(c,S) {\n\t\tFOR(i,PAT) {\n\t\t\tif(c=='+') {\n\t\t\t\tA[i].push_back(A[i].back());\n\t\t\t\tB[i].push_back((B[i].back()+1)%mo);\n\t\t\t}\n\t\t\tif(c=='-') {\n\t\t\t\tA[i].push_back(A[i].back());\n\t\t\t\tB[i].push_back((B[i].back()+mo-1)%mo);\n\t\t\t}\n\t\t\tif(c=='>') {\n\t\t\t\tA[i].push_back(A[i].back()*R[i]%mo);\n\t\t\t\tB[i].push_back(B[i].back()*R[i]%mo);\n\t\t\t}\n\t\t\tif(c=='<') {\n\t\t\t\tA[i].push_back(A[i].back()*C[i]%mo);\n\t\t\t\tB[i].push_back(B[i].back()*C[i]%mo);\n\t\t\t}\n\t\t}\n\t}\n\tll ret=0;\n\tmap<vector<ll>,int> memo;\n\tmemo[vector<ll>(PAT,0)]++;\n\tFOR(j,N) {\n\t\tvector<ll> BA,BAS;\n\t\tFOR(i,PAT) {\n\t\t\tBA.push_back(B[i][j+1]*modpow(A[i][j+1])%mo);\n\t\t\tBAS.push_back((B[i][j+1]+mo-B[i].back())*modpow(A[i][j+1])%mo);\n\t\t}\n\t\tret+=memo[BAS];\n\t\tmemo[BA]++;\n\t}\n\tcout<<ret<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long giant;\nconst ull base0=998244353ull;\nconst ull invr0=996491785301655553ull;\nconst giant q=1e9+7;\nconst giant base1=1232351;\nconst giant invr1=547430890;\nconst int maxn=2.5e5+3;\nconst int maxl=5e5+10;\nstruct H {\n\tull x;\n\tgiant y;\n\texplicit H ():x(0),y(0) {}\n\texplicit H (ull _x,giant _y):x(_x),y(_y) {}\n\tinline H& operator = (const int &k) {\n\t\tx=k,y=k;\n\t\treturn *this;\n\t}\n\tinline H& operator *= (const H &h) {\n\t\tx*=h.x,y=(y*h.y)%q;\n\t\treturn *this;\n\t}\n\tinline H& operator += (const H &h) {\n\t\tx+=h.x,y=(y+h.y)%q;\n\t\treturn *this;\n\t}\n\tinline H& operator -= (const H &h) {\n\t\tx-=h.x,y=((y-h.y)%q+q)%q;\n\t\treturn *this;\n\t}\n\tinline friend H operator * (H a,const H &b) {\n\t\treturn a*=b;\n\t}\n\tinline friend H operator + (H a,const H &b) {\n\t\treturn a+=b;\n\t}\n\tinline bool operator < (const H &h) const {\n\t\treturn (x*y)<(h.x*h.y);\n\t}\n} base(base0,base1),invr(invr0,invr1);\nnamespace num {\n\tH _mi[maxl],*mi=_mi+maxn;\n\tvoid init() {\n\t\tmi[0]=1;\n\t\tfor (int i=1;i<maxn;++i) mi[i]=mi[i-1]*base;\n\t\tfor (int i=1;i<maxn;++i) mi[-i]=mi[-i+1]*invr;\n\t}\n\tint __initer__=(init(),0);\n}\nint n;\nchar s[maxn];\nmap<H,int> mp;\nnamespace has {\n\tH val[maxn],cur;\n\tint pos[maxn];\n\tvoid deal(int &p,char c) {\n\t\tif (c=='<') --p; else\n\t\tif (c=='>') ++p; else\n\t\tif (c=='+') cur+=num::mi[p]; else\n\t\tif (c=='-') cur-=num::mi[p]; else\n\t\tassert(false);\n\t}\n\tH work() {\n\t\tint p=0;\n\t\tfor (int i=1;i<=n;++i) {\n\t\t\tdeal(p,s[i]);\n\t\t\tval[i]=cur;\n\t\t\tpos[i]=p;\n\t\t}\n\t\treturn cur;\n\t}\n}\nint main() {\n\tscanf(\"%d%s\",&n,s+1);\n\tH all=has::work();\n\tgiant ans=0;\n\tfor (int i=n;i>=0;--i) {\n\t\tH tmp=all*num::mi[has::pos[i]]+has::val[i];\n\t\tans+=mp[tmp];\n\t\t++mp[has::val[i]];\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long giant;\nconst ull base0=998244353ull;\nconst ull invr0=996491785301655553ull;\nconst giant q=1e9+7;\nconst giant base1=1232351;\nconst giant invr1=547430890;\nconst int maxn=2.5e5+3;\nconst int maxl=5e5+10;\nstruct H {\n\tull x;\n\tgiant y;\n\texplicit H ():x(0),y(0) {}\n\texplicit H (ull _x,giant _y):x(_x),y(_y) {}\n\tinline H& operator = (const int &k) {\n\t\tx=k,y=k;\n\t\treturn *this;\n\t}\n\tinline H& operator *= (const H &h) {\n\t\tx*=h.x,y=(y*h.y)%q;\n\t\treturn *this;\n\t}\n\tinline H& operator += (const H &h) {\n\t\tx+=h.x,y=(y+h.y)%q;\n\t\treturn *this;\n\t}\n\tinline H& operator -= (const H &h) {\n\t\tx-=h.x,y=((y-h.y)%q+q)%q;\n\t\treturn *this;\n\t}\n\tinline friend H operator * (H a,const H &b) {\n\t\treturn a*=b;\n\t}\n\tinline friend H operator + (H a,const H &b) {\n\t\treturn a+=b;\n\t}\n\tinline bool operator < (const H &h) const {\n\t\treturn x!=h.x?(x<h.x):(y<h.y);\n\t}\n} base(base0,base1),invr(invr0,invr1);\nnamespace num {\n\tH _mi[maxl],*mi=_mi+maxn;\n\tvoid init() {\n\t\tmi[0]=1;\n\t\tfor (int i=1;i<maxn;++i) mi[i]=mi[i-1]*base;\n\t\tfor (int i=1;i<maxn;++i) mi[-i]=mi[-i+1]*invr;\n\t}\n\tint __initer__=(init(),0);\n}\nint n;\nchar s[maxn];\nmap<H,int> mp;\nnamespace has {\n\tH val[maxn],cur;\n\tint pos[maxn];\n\tvoid deal(int &p,char c) {\n\t\tif (c=='<') --p; else\n\t\tif (c=='>') ++p; else\n\t\tif (c=='+') cur+=num::mi[p]; else\n\t\tif (c=='-') cur-=num::mi[p]; else\n\t\tassert(false);\n\t}\n\tH work() {\n\t\tint p=0;\n\t\tfor (int i=1;i<=n;++i) {\n\t\t\tdeal(p,s[i]);\n\t\t\tval[i]=cur;\n\t\t\tpos[i]=p;\n\t\t}\n\t\treturn cur;\n\t}\n}\nint main() {\n\tscanf(\"%d%s\",&n,s+1);\n\tH all=has::work();\n\tgiant ans=0;\n\tfor (int i=n;i>=0;--i) {\n\t\tH tmp=all*num::mi[has::pos[i]]+has::val[i];\n\t\tans+=mp[tmp];\n\t\t++mp[has::val[i]];\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <list>\n#include <time.h>\n#include <math.h>\n#include <random>\n#include <deque>\n#include <queue>\n#include <cassert>\n#include <unordered_map>\n#include <unordered_set>\n#include <iomanip>\n#include <bitset>\n#include <sstream>\n\nusing namespace std;\n\ntypedef long long ll;\n\nmt19937 rnd(228);\n\nconst int M = 1791791791;\nconst int B = 239;\n\ninline int add(ll a, ll b)\n{\n    a += b;\n    if (a >= M) a -= M;\n    if (a < 0) a += M;\n    return a;\n}\n\ninline int mul(int a, int b)\n{\n    return (a * (ll) b) % M;\n}\n\ninline int bin(int a, int n)\n{\n    int res = 1;\n    while (n)\n    {\n        if (n % 2 == 0)\n        {\n            a = mul(a, a);\n            n /= 2;\n        }\n        else\n        {\n            res = mul(res, a);\n            n--;\n        }\n    }\n    return res;\n}\n\nconst int rev_B = bin(B, M - 2);\n\nstring s;\nint n;\n\nint main()\n{\n#ifdef ONPC\n    freopen(\"a.in\", \"r\", stdin);\n#endif\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cin >> n;\n    cin >> s;\n    int cur = 1;\n    int hsh = 0;\n    vector <int> p(n + 1);\n    vector <int> h(n + 1);\n    p[0] = 1;\n    h[0] = 0;\n    for (int i = 0; i < n; i++)\n    {\n        if (s[i] == '>')\n        {\n            cur = mul(cur, B);\n        }\n        else if (s[i] == '<')\n        {\n            cur = mul(cur, rev_B);\n        }\n        else if (s[i] == '+')\n        {\n            hsh = add(hsh, cur);\n        }\n        else\n        {\n            hsh = add(hsh, -cur);\n        }\n        p[i + 1] = cur;\n        h[i + 1] = hsh;\n    }\n    ll ans = 0;\n    map <int, int> ret;\n    for (int i = n; i >= 0; i--)\n    {\n        int need = add(mul(hsh, p[i]), h[i]);\n        ans += ret[need];\n        ret[h[i]]++;\n    }\n    cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<map>\n\nconst int mod1=998244353,g1=504510733,ig1=799218450;\nconst int mod2=1000000009,g2=486738396,ig2=567937635;\n\nint n;\nchar C[600000];\n\nint fha1,fha2,pw1[600000],pw2[600000],ipw1[600000],ipw2[600000];\ninline void chkinc(int &C,int P){C+=C>>31&P;}\nlong long ans;\n\nvoid solve(int L,int R){\n\tif (L==R){\n\t\tswitch (C[L]){\n\t\t\tcase '<':\n\t\t\t\tans+=!fha1&&!fha2;\n\t\t\t\tbreak;\n\t\t\tcase '>':\n\t\t\t\tans+=!fha1&&!fha2;\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tans+=(mod1-pw1[250000]==fha1&&mod2-pw2[250000]==fha2);\n\t\t\t\tbreak;\n\t\t\tcase '+':\n\t\t\t\tans+=(pw1[250000]==fha1&&pw2[250000]==fha2);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\telse{\n\t\tint mdl=(L+R)>>1;\n\t\tsolve(L,mdl);\n\t\tsolve(mdl+1,R);\n\t\tint ha1=0,ha2=0,pos=250000;\n\t\tstd::map<std::pair<int,int>,int> M;\n\t\tfor (int i=mdl+1;i<=R;i++){\n\t\t\tswitch (C[i]){\n\t\t\t\tcase '<':\n\t\t\t\t\tpos--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '>':\n\t\t\t\t\tpos++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '-':\n\t\t\t\t\tchkinc(ha1-=pw1[pos],mod1);\n\t\t\t\t\tchkinc(ha2-=pw2[pos],mod2);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '+':\n\t\t\t\t\tchkinc(ha1+=pw1[pos]-mod1,mod1);\n\t\t\t\t\tchkinc(ha2+=pw2[pos]-mod2,mod2);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tM[std::make_pair(ha1,ha2)]++;\n\t\t}\n\t\tha1=0,ha2=0,pos=0;\n\t\tfor (int i=mdl;i>=L;i--){\n\t\t\tswitch (C[i]){\n\t\t\t\tcase '<':\n\t\t\t\t\tpos--;\n\t\t\t\t\tha1=static_cast<long long>(ha1)*ig1%mod1;\n\t\t\t\t\tha2=static_cast<long long>(ha2)*ig2%mod2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '>':\n\t\t\t\t\tpos++;\n\t\t\t\t\tha1=static_cast<long long>(ha1)*g1%mod1;\n\t\t\t\t\tha2=static_cast<long long>(ha2)*g2%mod2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '-':\n\t\t\t\t\tchkinc(ha1-=pw1[250000],mod1);\n\t\t\t\t\tchkinc(ha2-=pw2[250000],mod2);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '+':\n\t\t\t\t\tchkinc(ha1+=pw1[250000]-mod1,mod1);\n\t\t\t\t\tchkinc(ha2+=pw2[250000]-mod2,mod2);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (pos>=0){\n\t\t\t\tint a1=static_cast<long long>(fha1-ha1+mod1)*ipw1[pos]%mod1;\n\t\t\t\tint a2=static_cast<long long>(fha2-ha2+mod2)*ipw2[pos]%mod2;\n\t\t\t\tans+=M[std::make_pair(a1,a2)];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint a1=static_cast<long long>(fha1-ha1+mod1)*pw1[-pos]%mod1;\n\t\t\t\tint a2=static_cast<long long>(fha2-ha2+mod2)*pw2[-pos]%mod2;\n\t\t\t\tans+=M[std::make_pair(a1,a2)];\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",C);\n\tpw1[0]=pw2[0]=ipw1[0]=ipw2[0]=1;\n\tfor (int i=1;i<=500000;i++){\n\t\tpw1[i]=static_cast<long long>(pw1[i-1])*g1%mod1;\n\t\tpw2[i]=static_cast<long long>(pw2[i-1])*g2%mod2;\n\t\tipw1[i]=static_cast<long long>(ipw1[i-1])*ig1%mod1;\n\t\tipw2[i]=static_cast<long long>(ipw2[i-1])*ig2%mod2;\n\t}\n\tfor (int i=0,P=250000;i<n;i++){\n\t\tswitch (C[i]){\n\t\t\tcase '<':\n\t\t\t\tP--;\n\t\t\t\tbreak;\n\t\t\tcase '>':\n\t\t\t\tP++;\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tchkinc(fha1-=pw1[P],mod1);\n\t\t\t\tchkinc(fha2-=pw2[P],mod2);\n\t\t\t\tbreak;\n\t\t\tcase '+':\n\t\t\t\tchkinc(fha1+=pw1[P]-mod1,mod1);\n\t\t\t\tchkinc(fha2+=pw2[P]-mod2,mod2);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tsolve(0,n-1);\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n * sto Qingyu orz\n * 感谢真神sqy无私的教诲。膜时队者处处阿克，只因大师sqy在他背后。不膜大师者违背了真神的旨意，真神必将降下天谴,\n * 使其天天爆零\n * 我不由自主地膜拜真神sqy。\n * Author: RainAir\n * Time: 2019-10-17 08:17:33\n */\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <climits>\n#include <cstdlib>\n#include <cstdio>\n#include <bitset>\n#include <vector>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#define fi first\n#define se second\n#define U unsigned\n#define P std::pair\n#define LL long long\n#define pb push_back\n#define MP std::make_pair\n#define all(x) x.begin(),x.end()\n#define CLR(i,a) memset(i,a,sizeof(i))\n#define FOR(i,a,b) for(int i = a;i <= b;++i)\n#define ROF(i,a,b) for(int i = a;i >= b;--i)\n#define DEBUG(x) std::cerr << #x << '=' << x << std::endl\n\nconst int MAXN = 250000 + 5;\nconst LL ha = 1000000000000000031;\nconst LL BASE = 1e9+7;\n\ninline LL mul(LL x,LL y){\n    __int128_t t = (__int128_t)x*y%ha;\n    return (LL)t;\n}\n\ninline LL add(LL x,LL y){\n    x += y;x %= ha;\n    return x;\n}\n\ninline LL qpow(LL a,LL n=ha-2){\n    LL res = 1;\n    while(n){\n        if(n & 1) res = mul(res,a);\n        a = mul(a,a);\n        n >>= 1;\n    }\n    return res;\n}\n\nchar str[MAXN];\nint n;\nLL hsh[MAXN],p[MAXN],inv;\nstd::map<LL,int> S;\n\nint main(){\n    scanf(\"%d\",&n);\n    scanf(\"%s\",str+1);inv = qpow(BASE);\n    p[0] = 1;//DEBUG(inv);\n//    DEBUG(mul(inv,BASE));\n    FOR(i,1,n){\n        hsh[i] = hsh[i-1];\n        p[i] = p[i-1];\n        if(str[i] == '+'){\n            hsh[i] = add(hsh[i],p[i]);\n        }\n        if(str[i] == '-'){\n            hsh[i] = add(hsh[i],ha-p[i]);\n        }\n        if(str[i] == '<'){\n            p[i] = mul(p[i],inv);\n        }\n        if(str[i] == '>'){\n            p[i] = mul(p[i],BASE);\n        }\n    }\n    LL ans = 0;\n    ROF(i,n,1){ // hsh[r]== hsh[n]*base[l-1]+hsh[l-1]\n        S[hsh[i]]++;\n        ans += S[add(mul(hsh[n],p[i-1]),hsh[i-1])];\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n    _____\n  .'     '.\n /  0   0  \\\n|     ^     |\n|  \\     /  |\n \\  '---'  /\n  '._____.'\n*/\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\nstruct chash\n{\n\tint operator()(int x) const\n\t{\n\t\tx ^= (x >> 20) ^ (x >> 12);\n\t\treturn x ^ (x >> 7) ^ (x >> 4);\n\t}\n};\n\ntemplate<typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename U> using hashtable = gp_hash_table<T, U, chash>;\nrandom_device(rd);\nmt19937 rng(rd());\n\ntemplate<class T>\nvoid readi(T &x)\n{\n\tT input = 0;\n\tbool negative = false;\n\tchar c = ' ';\n\twhile (c < '-')\n\t{\n\t\tc = getchar();\n\t}\n\tif (c == '-')\n\t{\n\t\tnegative = true;\n\t\tc = getchar();\n\t}\n\twhile (c >= '0')\n\t{\n\t\tinput = input * 10 + (c - '0');\n\t\tc = getchar();\n\t}\n\tif (negative)\n\t{\n\t\tinput = -input;\n\t}\n\tx = input;\n}\ntemplate<class T>\nvoid printi(T output)\n{\n\tif (output == 0)\n\t{\n\t\tputchar('0');\n\t\treturn;\n\t}\n\tif (output < 0)\n\t{\n\t\tputchar('-');\n\t\toutput = -output;\n\t}\n\tint aout[20];\n\tint ilen = 0;\n\twhile(output)\n\t{\n\t\taout[ilen] = ((output % 10));\n\t\toutput /= 10;\n\t\tilen++;\n\t}\n\tfor (int i = ilen - 1; i >= 0; i--)\n\t{\n\t\tputchar(aout[i] + '0');\n\t}\n\treturn;\n}\ntemplate<class T>\nvoid ckmin(T &a, T b)\n{\n\ta = min(a, b);\n}\ntemplate<class T>\nvoid ckmax(T &a, T b)\n{\n\ta = max(a, b);\n}\ntemplate<class T, class U>\nT nmod(T &x, U mod)\n{\n\tif (x >= mod) x -= mod;\n}\ntemplate<class T>\nT randomize(T mod)\n{\n\treturn (uniform_int_distribution<T>(0, mod - 1))(rng);\n}\n\n#define y0 ___y0\n#define y1 ___y1\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fi first\n#define se second\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\nconst long double PI = 4.0 * atan(1.0);\nconst long double EPS = 1e-10;\n\n#define MAGIC 347\n#define SINF 10007\n#define CO 1000007\n#define INF 1000000007\n#define BIG 1000000931\n#define LARGE 1696969696967ll\n#define GIANT 2564008813937411ll\n#define LLINF 2696969696969696969ll\n#define MAXN 500013\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ld, ld> pdd;\n\nint N;\nint arr[MAXN];\npll S;\nlong long ans;\nunordered_map<ll, int> need;\n\nll expo(ll a, ll e, ll mod)\n{\n\tif (e == 0)\n\t{\n\t\treturn 1;\n\t}\n\tll was = expo(a, e / 2, mod);\n\tif (e % 2)\n\t{\n\t\treturn was * was % mod * a % mod;\n\t}\n\treturn was * was % mod;\n}\nll modinv(ll a, ll e)\n{\n\treturn expo(a, e - 2, e);\n}\npll INV = {modinv(CO, INF), modinv(CO, BIG)};\nvoid solve(int L, int R)\n{\n\tif (L == R)\n\t{\n\t\treturn;\n\t}\n\tneed.clear();\n\tint mid = (L + R) >> 1;\n\t//start from L...mid, end at mid + 1....R\n\tpair<pll, pll> trans = MP(MP(1, 0), MP(1, 0));\n\tfor (int i = mid + 1; i <= R; i++)\n\t{\n\t\tif (arr[i] == 0)\n\t\t{\n\t\t\ttrans.fi.fi *= INV.fi; trans.fi.fi %= INF;\n\t\t\ttrans.fi.se *= INV.fi; trans.fi.se %= INF;\n\t\t\ttrans.se.fi *= INV.se; trans.se.fi %= BIG;\n\t\t\ttrans.se.se *= INV.se; trans.se.se %= BIG;\n\t\t}\n\t\tif (arr[i] == 1)\n\t\t{\n\t\t\ttrans.fi.fi *= CO; trans.fi.fi %= INF;\n\t\t\ttrans.fi.se *= CO; trans.fi.se %= INF;\n\t\t\ttrans.se.fi *= CO; trans.se.fi %= BIG;\n\t\t\ttrans.se.se *= CO; trans.se.se %= BIG;\n\t\t}\n\t\tif (arr[i] == 2)\n\t\t{\n\t\t\ttrans.fi.se++; nmod(trans.fi.se, INF);\n\t\t\ttrans.se.se++; nmod(trans.se.se, BIG);\n\t\t}\n\t\tif (arr[i] == 3)\n\t\t{\n\t\t\ttrans.fi.se--; trans.fi.se += INF; nmod(trans.fi.se, INF);\n\t\t\ttrans.se.se--; trans.se.se += BIG; nmod(trans.se.se, BIG);\n\t\t}\n\t\tpll dif = {(S.fi - trans.fi.se) * modinv(trans.fi.fi, INF), (S.se - trans.se.se) * modinv(trans.se.fi, BIG)};\n\t\tdif.fi %= INF; dif.fi += INF; nmod(dif.fi, INF);\n\t\tdif.se %= BIG; dif.se += BIG; nmod(dif.se, BIG);\n\t\tneed[dif.fi * BIG + dif.se]++;\n\t}\n\ttrans = MP(MP(1, 0), MP(1, 0));\n\tfor (int i = mid; i >= L; i--)\n\t{\n\t\tif (arr[i] == 0)\n\t\t{\n\t\t\ttrans.fi.fi *= INV.fi; trans.fi.fi %= INF;\n\t\t\ttrans.se.fi *= INV.se; trans.se.fi %= BIG;\n\t\t}\n\t\tif (arr[i] == 1)\n\t\t{\n\t\t\ttrans.fi.fi *= CO; trans.fi.fi %= INF;\n\t\t\ttrans.se.fi *= CO; trans.se.fi %= BIG;\n\t\t}\n\t\tif (arr[i] == 2)\n\t\t{\n\t\t\ttrans.fi.se += trans.fi.fi; nmod(trans.fi.se, INF);\n\t\t\ttrans.se.se += trans.se.fi; nmod(trans.se.se, BIG);\n\t\t}\n\t\tif (arr[i] == 3)\n\t\t{\n\t\t\ttrans.fi.se -= trans.fi.fi; trans.fi.se += INF; nmod(trans.fi.se, INF);\n\t\t\ttrans.se.se -= trans.se.fi;\ttrans.se.se += BIG; nmod(trans.se.se, BIG);\n\t\t}\n\t\tans += need[trans.fi.se * BIG + trans.se.se];\n\t}\n\tsolve(L, mid);\n\tsolve(mid + 1, R);\n}\n\nint32_t main()\n{\n\tios_base::sync_with_stdio(0);\n\t// cout << fixed << setprecision(10);\n\t// cerr << fixed << setprecision(10);\n\t// freopen (\"file.in\", \"r\", stdin);\n\t// freopen (\"file.out\", \"w\", stdout);\n\tcin >> N;\n\tstring temps;\n\tcin >> temps;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (temps[i] == '<')\n\t\t{\n\t\t\tarr[i] = 0;\n\t\t}\n\t\tif (temps[i] == '>')\n\t\t{\n\t\t\tarr[i] = 1;\n\t\t}\n\t\tif (temps[i] == '+')\n\t\t{\n\t\t\tarr[i] = 2;\n\t\t}\n\t\tif (temps[i] == '-')\n\t\t{\n\t\t\tarr[i] = 3;\n\t\t}\n\t}\n\treverse(arr, arr + N);\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (arr[i] == 0)\n\t\t{\n\t\t\tS.fi *= INV.fi; S.fi %= INF;\n\t\t\tS.se *= INV.se; S.se %= BIG;\n\t\t\t// cerr << \"times \" << INV << endl;\n\t\t}\n\t\tif (arr[i] == 1)\n\t\t{\n\t\t\tS.fi *= CO; S.fi %= INF;\n\t\t\tS.se *= CO; S.se %= BIG;\n\t\t\t// cerr << \"times \" << CO << endl;\n\t\t}\n\t\tif (arr[i] == 2)\n\t\t{\n\t\t\tS.fi++; nmod(S.fi, INF);\n\t\t\tS.se++; nmod(S.se, BIG);\n\t\t\t// cerr << \"add 1\\n\";\n\t\t}\n\t\tif (arr[i] == 3)\n\t\t{\n\t\t\tS.fi--; S.fi += INF; nmod(S.fi, INF);\n\t\t\tS.se--; S.se += BIG; nmod(S.se, BIG);\n\t\t\t// cerr << \"add -1\\n\";\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (arr[i] == 0)\n\t\t{\n\t\t\tif (S == MP(0ll, 0ll)) ans++;\n\t\t}\n\t\tif (arr[i] == 1)\n\t\t{\n\t\t\tif (S == MP(0ll, 0ll)) ans++;\n\t\t}\n\t\tif (arr[i] == 2)\n\t\t{\n\t\t\tif (S == MP(1ll, 1ll)) ans++;\n\t\t}\n\t\tif (arr[i] == 3)\n\t\t{\n\t\t\tif (S == MP((ll) INF - 1, (ll) BIG - 1)) ans++;\n\t\t}\n\t}\n\tsolve(0, N - 1);\n\tcout << ans << '\\n';\n\t//when u <, the # divides by co\n\t//when u >, the # mults by co\n\t//when u +, u add the #\n\t//when u -, u subtract the #\n\t// cerr << \"time elapsed = \" << (clock() / (CLOCKS_PER_SEC / 1000)) << \" ms\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing ll = long long;\ntemplate <typename T>\nconstexpr std::pair<T, T> extgcd(const T a, const T b)\n{\n    if (b == 0) { return std::pair<T, T>{1, 0}; }\n    const auto p = extgcd(b, a % b);\n    return {p.second, p.first - p.second * (a / b)};\n}\ntemplate <typename T>\nconstexpr T inverse(const T a, const T mod) { return (mod + extgcd(a, mod).first % mod) % mod; }\nconstexpr ll MOD1 = 1000000007LL, MOD2 = 1000000009LL;\nconstexpr int H = 5;  //関数値サンプルの個数\nconstexpr ll X[H] = {2371983LL, 1231LL, 123123LL, 4329075LL, 134121LL};\nconstexpr ll XINV1[H] = {inverse(X[0], MOD1), inverse(X[1], MOD1), inverse(X[2], MOD1), inverse(X[3], MOD1), inverse(X[4], MOD1)};\nconstexpr ll XINV2[H] = {inverse(X[0], MOD2), inverse(X[1], MOD2), inverse(X[2], MOD2), inverse(X[3], MOD2), inverse(X[4], MOD2)};\nint main()\n{\n    int N;\n    std::string S;\n    std::cin >> N >> S;\n    using P = std::pair<ll, ll>;\n    std::vector<int> deg(N + 1, 0);\n    std::vector<std::vector<P>> value(N + 1, std::vector<P>(H, {0LL, 0LL}));\n    auto plus = [](const P& p1, const P& p2) { return P{(p1.first + p2.first) % MOD1, (p1.second + p2.second) % MOD2}; };\n    auto minus = [](const P& p1, const P& p2) { return P{(p1.first + MOD1 - p2.first) % MOD1, (p1.second + MOD2 - p2.second) % MOD2}; };\n    auto rshift = [](const P& p, const int j) { return P{p.first * X[j] % MOD1, p.second * X[j] % MOD2}; };\n    auto lshift = [](const P& p, const int j) { return P{p.first * XINV1[j] % MOD1, p.second * XINV2[j] % MOD2}; };\n    auto mul = [](const P& p1, const P& p2) { return P{p1.first * p2.first % MOD1, p1.second * p2.second % MOD2}; };\n    for (int i = N - 1; i >= 0; i--) {\n        if (S[i] == '-') {\n            deg[i] = deg[i + 1];\n            for (int j = 0; j < H; j++) { value[i][j] = minus(value[i + 1][j], {1, 1}); }\n        } else if (S[i] == '+') {\n            deg[i] = deg[i + 1];\n            for (int j = 0; j < H; j++) { value[i][j] = plus(value[i + 1][j], {1, 1}); }\n        } else if (S[i] == '>') {\n            deg[i] = deg[i + 1] + 1;\n            for (int j = 0; j < H; j++) { value[i][j] = rshift(value[i + 1][j], j); }\n        } else {\n            deg[i] = deg[i + 1] - 1;\n            for (int j = 0; j < H; j++) { value[i][j] = lshift(value[i + 1][j], j); }\n        }\n    }\n    constexpr int L = 250000;\n    std::vector<std::vector<P>> power(L + 1, std::vector<P>(H, {1, 1}));\n    std::vector<std::vector<P>> invpower(L + 1, std::vector<P>(H, {1, 1}));\n    auto invp = [&](const int i, const int j) { return i >= 0 ? invpower[i][j] : power[-i][j]; };\n    for (int i = 1; i <= L; i++) {\n        for (int j = 0; j < H; j++) { power[i][j] = rshift(power[i - 1][j], j), invpower[i][j] = lshift(invpower[i - 1][j], j); }  //  invpower[i][j] = lshift(power[i - 1][j], j) じゃねんだよなぁまじで\n    }\n    std::vector<P> answer(H);\n    for (int i = 0; i < H; i++) { answer[i] = value[0][i]; }\n    std::vector<std::vector<P>> hash(N + 1, std::vector<P>(H));\n    for (int i = 0; i <= N; i++) {\n        for (int j = 0; j < H; j++) { hash[i][j] = mul(minus(value[i][j], answer[j]), invp(deg[i], j)); }\n    }\n    using VP = std::vector<P>;\n    std::map<VP, ll> mp;\n    ll ans = 0;\n    for (int i = 0; i <= N; i++) {\n        std::vector<P> obj(H);\n        for (int j = 0; j < H; j++) { obj[j] = plus(hash[i][j], mul(invp(deg[i], j), answer[j])); }\n        if (mp.find(obj) != mp.end()) { ans += mp[obj]; }\n        mp[hash[i]]++;\n    }\n    std::cout << ans << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <vector>\n\nconst int DEBUG = 0;\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define DEBUGP(val) cerr << #val << \"=\" << val << \"\\n\"\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\n\n\nconst ll mod = 1e9 + 9;\nll powmod(ll a, ll e) {\n  ll sum = 1;\n  ll cur = a;\n  while (e > 0) {\n    if (e % 2) {\n      sum = sum * cur % mod;\n    }\n    cur = cur * cur % mod;\n    e /= 2;\n  }\n  return sum;\n}\nvoid add(ll &x, ll y) {\n  x = (x + y) % mod;\n}\n\n\nmap<int, int> irn, bru;\n\n\n\nint ineq, ineq_init; \n\nvoid upd(int p, int c) {\n  int val = irn.count(p) ? irn[p] : 0;\n  if (val == bru[p]) {\n    ineq++;\n  }\n  bru[p] += c;\n  if (val == bru[p]) {\n    ineq--;\n  }\n}\n\nint ab_main(void) {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  string s;\n  cin >> n >> s;\n  int p = 0;\n  VI pos(n + 1);\n  REP(i, 0, n) {\n    if (s[i] == '>') p++;\n    if (s[i] == '<') p--;\n    if (s[i] == '+') irn[p]++;\n    if (s[i] == '-') irn[p]--;\n    pos[i] = p;\n  }\n  for (auto &e: irn) {\n    if (e.second != 0) ineq_init++;\n  }\n  // TODO O(n^2)\n  ll ans = 0;\n  REP(i, 0, n) {\n    p = 0;\n    bru.clear();\n    ineq = ineq_init;\n    REP(j, i, n) {\n      if (s[j] == '>') p++;\n      if (s[j] == '<') p--;\n      if (s[j] == '+') upd(p, 1);\n      if (s[j] == '-') upd(p, -1);\n      if (ineq == 0) ans++;\n    }\n  }\n  cout << ans << endl;\n}\n\nint main(void) {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  string s;\n  cin >> n >> s;\n  int p = 0;\n  VI pos(n + 1);\n  mt19937 mt;\n  ll b;\n  do {\n    b = mt() % mod;\n  } while (b == 0);\n  \n  VL hsh(n + 1);\n  ll invb = powmod(b, mod - 2);\n  ll cur = 1;\n  REP(i, 0, n) {\n    ll tmp = hsh[i];\n    if (s[i] == '>') {\n      p++;\n      cur = cur * b % mod;\n    }\n    if (s[i] == '<') {\n      p--;\n      cur = cur * invb % mod;\n    }\n    if (s[i] == '+') {\n      add(tmp, cur);\n    }\n    if (s[i] == '-') {\n      add(tmp, mod - cur);\n    }\n    hsh[i + 1] = tmp;\n    pos[i + 1] = p;\n  }\n  if (DEBUG) {\n    REP(i, 0, n + 1) {\n      cerr << i << \" \" << hsh[i] << endl;\n    }\n  }\n  ll meguru = hsh[n];\n  map<ll, int> kirika;\n  kirika[hsh[n]] = 1;\n  ll tot = 0;\n  cur = powmod(b, pos[n]);\n  for (int i = n - 1; i >= 0; --i) {\n    if (DEBUG) {\n      DEBUGP(i);\n      DEBUGP(pos[i]);\n    }\n    if (pos[i + 1] - pos[i] == 1) cur = cur * invb % mod;\n    else if (pos[i + 1] - pos[i] == -1) cur = cur * b % mod;\n    if (DEBUG) DEBUGP(cur);\n    ll ken = cur * meguru + hsh[i] % mod;\n    tot += kirika[ken];\n    kirika[hsh[i]] += 1;\n  }\n  cout << tot << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define all(x) x.begin(), x.end()\nusing namespace std;\nusing ll = long long;\nconst int maxn = 1<<19, mod = 119<<23|1;\nconst int B = 299977;\nint n, pw[maxn], F[maxn], ps = 0, ans = 0;\nstring s;\nmap<int, int> cnt;\nvoid add(int &a, int b) {\n\ta = a+b>=mod?a+b-mod:a+b;\n}\nll bp(ll a, ll p) {\n\tint r = 1;\n\twhile(p) {\n\t\tif(p&1) r = r*a%mod;\n\t\ta = a*a%mod, p>>=1;\n\t}\n\treturn r;\n} \nsigned main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> n >> s;\n\tpw[0] = 1;\n\tfor(int i = 1; i < maxn; i++) pw[i] = pw[i-1]*1ll*B%mod;\n\tcnt[0]++;\n\tint cur = 0;\n\tfor(int i = 0; i < n; i++) {\n\t\tif(s[i] == '>') ps++;\n\t\tif(s[i] == '<') ps--;\n\t\tif(s[i] == '+') add(cur, pw[(maxn/2) + ps]);\n\t\tif(s[i] == '-') add(cur, mod-pw[(maxn/2) + ps]);\n\t\tF[i+1] = cur;\n\t\tcnt[cur]++;\n\t}\n\tps = 0;\n\tfor(int ccur = 0, ps = 0, i = 0; i <= n; i++) {\n\t\tcnt[F[i]]--;\n\t\tans += cnt[(ccur + bp(B, mod-1+ps)*1ll*cur)%mod];\n\t\tif(i == n) continue;\n\t\tif(s[i] == '>') ps++;\n\t\tif(s[i] == '<') ps--;\n\t\tif(s[i] == '+') add(ccur, pw[(maxn/2) + ps]);\n\t\tif(s[i] == '-') add(ccur, mod-pw[(maxn/2) + ps]);\n\t}\n\tcout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long lint;\n\nlint modpow(lint x, lint y, lint mod) {\n  lint ret = 1 % mod, x2p = x;\n  while (y > 0) {\n    if (y % 2) ret = (__int128)ret * x2p % mod;\n    y /= 2;\n    x2p = (__int128)x2p * x2p % mod;\n  }\n  return ret;\n}\n\nconstexpr int nmods = 4;\n\nconstexpr lint mod[] = {1152921504609811141LL, 576460752312103501LL,\n                        4611676018431352883LL, 4611676018431352883LL};\nconstexpr lint base[] = {102999959LL, 1006199503LL, 1073741663LL, 599831LL};\nlint inv_base[nmods];\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  string seq(n, ' ');\n  for (int i = 0; i < n; ++i)\n    scanf(\" %c\", &seq[i]);\n\n  vector<int> pos_before(n);\n\n  vector<vector<lint>> base_pow(nmods, vector<lint>(n + 1));\n  vector<vector<lint>> inv_base_pow(nmods, vector<lint>(n + 1));\n  vector<vector<lint>> hash_diff(nmods, vector<lint>(n, 0));\n  vector<vector<lint>> suffix(nmods, vector<lint>(n + 1));\n  vector<lint> full_seq_hash(nmods);\n  for (int k = 0; k < nmods; ++k) {\n    base_pow[k][0] = 1;\n    for (int i = 1; i <= n; ++i)\n      base_pow[k][i] = (__int128)base[k] * base_pow[k][i - 1] % mod[k];\n\n    inv_base[k] = modpow(base[k], mod[k] - 2, mod[k]);\n    inv_base_pow[k][0] = 1;\n    for (int i = 1; i <= n; ++i)\n      inv_base_pow[k][i] = (__int128)inv_base[k] * inv_base_pow[k][i - 1] % mod[k];\n\n    int pos = 0;\n    for (int i = 0; i < n; ++i) {\n      pos_before[i] = pos;\n      if (seq[i] == '>') ++pos;\n      else if (seq[i] == '<') --pos;\n      else {\n        lint base_pow_pos;\n        if (pos >= 0) base_pow_pos = base_pow[k][pos];\n        else base_pow_pos = inv_base_pow[k][-pos];\n        if (seq[i] == '+') hash_diff[k][i] = base_pow_pos;\n        else if (seq[i] == '-') hash_diff[k][i] = mod[k] - base_pow_pos;\n        else assert(0);\n      }\n    }\n    full_seq_hash[k] = 0;\n    for (int i = 0; i < n; ++i) {\n      full_seq_hash[k] += hash_diff[k][i];\n      if (full_seq_hash[k] >= mod[k]) full_seq_hash[k] -= mod[k];\n    }\n\n    suffix[k][n] = 0;\n    for (int i = n - 1; i >= 0; --i) {\n      suffix[k][i] = hash_diff[k][i] + suffix[k][i + 1];\n      if (suffix[k][i] >= mod[k]) suffix[k][i] -= mod[k];\n    }\n  }\n\n  lint result = 0;\n  map<vector<lint>, int> count;\n  count[vector<lint>(nmods, 0LL)] += 1;\n  for (int i = n - 1; i >= 0; --i) {\n    vector<lint> shifted_full(nmods);\n    for (int k = 0; k < nmods; ++k) {\n      if (pos_before[i] >= 0) {\n        shifted_full[k] = (__int128)full_seq_hash[k] * base_pow[k][pos_before[i]] % mod[k];\n      } else {\n        shifted_full[k] = (__int128)full_seq_hash[k] * inv_base_pow[k][-pos_before[i]] % mod[k];\n      }\n    }\n\n    vector<lint> target(nmods);\n    for (int k = 0; k < nmods; ++k) {\n      target[k] = suffix[k][i] - shifted_full[k];\n      if (target[k] < 0) target[k] += mod[k];\n    }\n\n    auto it = count.find(target);\n    if (it != count.end())\n      result += it->second;\n\n    vector<lint> suffix_vec(nmods);\n    for (int k = 0; k < nmods; ++k)\n      suffix_vec[k] = suffix[k][i];\n\n    count[suffix_vec] += 1;\n  }\n  printf(\"%lld\\n\", result);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int N=250005,M1=1000020221,M2=1000000009;\nusing namespace std;\nint n,now,a[N],b1[N],b2[N],w1,w2,tp,a1,a2;\nchar S[N];\nlong long ans;\nmap<pair<int,int>,int>mp;\ninline int pls(int x,int y,int M){\n\treturn ((x+y)%M+M)%M;\n}\ninline void sol(bool fl){\n\tnow=n,w1=w2=0;\n\tfor(int i=1;i<=n;i++){\n\t\t//cerr<<i<<\"===now:\"<<now<<endl;\n\t\tif(fl)mp[{pls(1ll*b1[now]*a1%M1,1ll*w1*b1[n]%M1,M1),\n\t\tpls(1ll*b2[now]*a2%M2,1ll*w2*b2[n]%M2,M2)}]++;\n\t\t//cerr<<\"ins \"<<pls(1ll*b1[now]*a1%M1,1ll*w1*b1[n]%M1,M1)<<','<<\n\t\t//pls(1ll*b2[now]*a2%M2,1ll*w2*b2[n]%M2,M2)<<endl;\n\t\tif(S[i]>59)now+=S[i]-61;\n\t\telse{\n\t\t\t//cerr<<S[i]<<\"?\";\n\t\t\ttp=44-S[i];\n\t\t\tw1=pls(w1,tp*b1[now],M1);\n\t\t\tw2=pls(w2,tp*b2[now],M2);\n\t\t}\n\t\tif(fl)ans+=mp[{1ll*w1*b1[n]%M1,1ll*w2*b2[n]%M2}];\n\t\t//cerr<<\"(\"<<w1<<','<<w2<<\")\\n\";\n\t}\n}\nint main(){\n\t//freopen(\"dat.txt\",\"r\",stdin);\n\t//cerr<<(int)'+'<<' '<<(int)'-'<<' '<<(int)'>'<<' '<<(int)'<'<<endl;\n\tscanf(\"%d%s\",&n,S+1);\n\tb1[1]=b2[1]=1;\n\tfor(int i=1;i<=2*n;i++)\n\tb1[i+1]=1ll*b1[i]*7%M1,b2[i+1]=1ll*b2[i]*11%M2;\n\t//b1[i+1]=1ll*b1[i]*524287%M1,b2[i+1]=1ll*b2[i]*998244353%M2;\n\tsol(0),a1=w1,a2=w2,//cerr<<\"INI:(\"<<a1<<','<<a2<<\")\\n\",\n\tsol(1);\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000087;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\ntypedef pair<int, bool> sP;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef pair<ll, ll> LP;\ntypedef vector<ll> vec;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef vector<vector<ll>> mat;\ntypedef vector<ll> vec;\n\nll r = 998244853;\nll mod_pow(ll x, ll n) {\n  if(n<0){\n    return mod_pow(mod_pow(x,-n),mod-2));\n  }\n\tll res = 1;\n\twhile (n) {\n\t\tif (n % 2)res = res * x%mod;\n\t\tx = x * x%mod; n >>= 1;\n\t}\n\treturn res;\n}\nll invr = mod_pow(r, mod-2);\n\nll tr[300000];\nll invtr[300000];\nvoid init() {\n\ttr[0] = invtr[0] = 1;\n\trep(i, 299999) {\n\t\ttr[i + 1] = tr[i] * r%mod;\n\t\tinvtr[i + 1] = invtr[i] * invr%mod;\n\t}\n}\n\nvoid solve() {\n\tint n; cin >> n;\n\tstring s; cin >> s;\n\tll sum = 0; int loc = 0;\n\tvector<ll> memo(n);\n\tvector<int> locs(n);\n\trep(i, n) {\n\t\tif (s[i] == '>')loc++;\n\t\telse if (s[i] == '<')loc--;\n\t\telse if (s[i] == '+') {\n          sum+=mod_pow(r,loc);\n\t\t}\n\t\telse {\n          sum-=mod_pow(r,loc);\n\t\t}\n\t\tsum = (sum%mod + mod) % mod;\n\t\tmemo[i] = sum;\n\t\tlocs[i] = loc;\n\t}\n\tll all = sum;\n\t//cout << all << endl;\n\tll ans = 0;\n\tmap<ll, int> mp;\n\tmp[all]++;\n\trep(i, n) {\n\t\t//cout << mp[memo[i]] << endl;\n\t\tans += mp[memo[i]];\n\t\tll nex = all*mod_pow(r,locs[i])%mod;\n\t\tnex += memo[i];\n\t\tnex %= mod;\n\t\tmp[nex]++;\n\t}\n\tcout << ans << endl;\n}\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(7);\n\tinit();\n\t//output_tree(10);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef unsigned long long ull;\n#define mp make_pair\n\nconst int K = 4;\nll MODS[] = {(ll)1e9 + 7, (ll)1e9 + 9, (ll)1e9 + 21, (ll)1e9 + 33};\n\nll bin_pow(ll x, ll p, ll mm) {\n\tif (p == 0) return 1;\n\tif (p & 1) return (x * bin_pow(x, p - 1, mm)) % mm;\n\tll y = bin_pow(x, p / 2, mm);\n\treturn (y * y) % mm;\n}\n\nstruct PolyHash {\n\tll x[K];\n\n\tPolyHash() : x() {}\n\tPolyHash(ll Z) {\n\t\tfor (int i = 0; i < K; i++)\n\t\t\tx[i] = Z % MODS[i];\n\t}\n\n\tPolyHash operator + (const PolyHash &H) const {\n\t\tPolyHash res = PolyHash();\n\t\tfor (int i = 0; i < K; i++) {\n\t\t\tres.x[i] = (x[i] + H.x[i]) % MODS[i];\n\t\t}\n\t\treturn res;\n\t}\n\n\tPolyHash operator - (const PolyHash &H) const {\n\t\tPolyHash res = PolyHash();\n\t\tfor (int i = 0; i < K; i++) {\n\t\t\tres.x[i] = (x[i] - H.x[i]) % MODS[i];\n\t\t}\n\t\treturn res;\n\t}\n\n\tPolyHash operator * (const PolyHash &H) const {\n\t\tPolyHash res = PolyHash();\n\t\tfor (int i = 0; i < K; i++) {\n\t\t\tres.x[i] = (x[i] * H.x[i]) % MODS[i];\n\t\t}\n\t\treturn res;\n\t}\n\n\tbool operator < (const PolyHash &H) const {\n\t\tfor (int i = 0; i < K; i++) {\n\t\t\tif (x[i] != H.x[i])\n\t\t\t\treturn x[i] < H.x[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nconst int N = 500500;\nconst int M = N / 2;\nPolyHash pw[N];\nPolyHash a[N], b[N];\nint c[N];\nchar s[N];\nint L;\nmap<PolyHash, ll> mapchik;\n\nvoid precalc() {\n\tpw[M] = PolyHash(1);\n\tpw[M + 1] = PolyHash(1234567);\n\tpw[M - 1].x[0] = bin_pow(1234567, MODS[0] - 2, MODS[0]);\n\tpw[M - 1].x[1] = bin_pow(1234567, MODS[1] - 2, MODS[1]);\n\tfor (int i = M + 2; i < N; i++)\n\t\tpw[i] = pw[i - 1] * pw[M + 1];\n\tfor (int i = M - 2; i >= 0; i--)\n\t\tpw[i] = pw[i + 1] * pw[M - 1];\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tprecalc();\n\n\tscanf(\"%d %s\", &L, s);\n\tint pos = M;\n\ta[0] = 0;\n\tc[0] = pos;\n\tfor (int i = 0; i < L; i++) {\n\t\ta[i + 1] = a[i];\n\t\tif (s[i] == '+') {\n\t\t\ta[i + 1] = a[i + 1] + pw[pos];\n\t\t} else if (s[i] == '-') {\n\t\t\ta[i + 1] = a[i + 1] - pw[pos];\n\t\t} else if (s[i] == '>') {\n\t\t\tpos++;\n\t\t} else if (s[i] == '<') {\n\t\t\tpos--;\n\t\t} else throw;\n\t\tc[i + 1] = pos;\n\t}\n\tb[L] = 0;\n\tfor (int i = L - 1; i >= 0; i--) {\n\t\tb[i] = b[i + 1];\n\t\tif (s[i] == '+') {\n\t\t\tb[i] = b[i] + pw[pos];\n\t\t} else if (s[i] == '-') {\n\t\t\tb[i] = b[i] - pw[pos];\n\t\t} else if (s[i] == '>') {\n\t\t\tpos--;\n\t\t} else if (s[i] == '<') {\n\t\t\tpos++;\n\t\t} else throw;\n\t}\n\n\tPolyHash H = a[L];\n\n/*\n\tfor (int i = 0; i <= L; i++)\n\t\tprintf(\"%llu \", a[i]);\n\tprintf(\"\\n\");\n\tfor (int i = 0; i <= L; i++)\n\t\tprintf(\"%llu \", b[i]);\n\tprintf(\"\\n\");\n*/\n\tll ans = 0;\n\tfor (int i = L; i >= 0; i--) {\n\t\tPolyHash Z = H - H * pw[c[i]] - a[i];\n\t\tans += mapchik[Z];\n\t\tmapchik[b[i]]++;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int N=250005;\null p1=233,p2=1;\nint n;\nll ans;\null f[N],f2[N];\nchar s[N];\nmap<ull,int> mp;\nint main(){\n\tscanf(\"%d\",&n);\n\tull tmp=p1;\n\tfor(int i=1;i<=63;i++){\n\t\tp2*=tmp;\n\t\ttmp*=tmp;\n\t}\n\tscanf(\"%s\",s+1);\n\tf[0]=0,f2[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tf[i]=f[i-1],f2[i]=f2[i-1];\n\t\tif(s[i]=='+')f[i]+=f2[i];\n\t\telse if(s[i]=='-')f[i]-=f2[i];\n\t\telse if(s[i]=='>')f2[i]*=p1;\n\t\telse if(s[i]=='<')f2[i]*=p2;\n\t\tmp[f[i]]++;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tans+=mp[f[n]*f2[i-1]+f[i-1]];\n\t\tmp[f[i]]--;\n\t} \n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\n\nconst int MAXN = 250005;\nconst int mod = 1e9 + 7;\nconst int base = 993244853;\nint n, pos[MAXN];\nchar str[MAXN];\nlint pwr[MAXN * 2];\nlint inv[MAXN * 2];\n\nlint ipow(int x, int p){\n  lint ret = 1, piv = x;\n  while(p){\n    if(p & 1) ret = ret * piv % mod;\n    piv = piv * piv % mod;\n    p >>= 1;\n  }\n  return ret;\n}\n\nlint psum[MAXN];\n\nint main(){\n  cin >> n >> (str + 1);\n  pwr[0] = inv[0] = 1;\n  for(int i=1; i<MAXN * 2; i++){\n    pwr[i] = pwr[i-1] * base % mod;\n    inv[i] = ipow(pwr[i], mod - 2);\n  }\n  pos[0] = n;\n  for(int i=1; i<=n; i++){\n    pos[i] = pos[i-1];\n    psum[i] = psum[i-1];\n    if(str[i] == '<') pos[i]--;\n    if(str[i] == '>') pos[i]++;\n    if(str[i] == '+') psum[i] += pwr[pos[i]];\n    if(str[i] == '-') psum[i] += mod - pwr[pos[i]];\n    psum[i] %= mod;\n  }\n  lint H = psum[n];\n  lint ret = 0;\n  map<int, int> mp;\n  for(int i=n; i; i--){\n    mp[psum[i]]++;\n    lint Hv = H;\n    if(pos[0] <= pos[i-1]) Hv *= pwr[pos[i-1] - pos[0]];\n    else Hv *= inv[pos[0] - pos[i-1]];\n    Hv += psum[i-1];\n    Hv %= mod;\n    ret += mp[Hv];\n  }\n  cout << ret << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int mod1 = 998244353,mod2 = 1000000007;\n\nstruct Hsh\n{\n\tlong long m1,m2;\n\tHsh operator + (const Hsh &a) const\n\t{\n\t\treturn (Hsh){(m1 + a.m1) % mod1,(m2 + a.m2) % mod2};\n\t}\n\tHsh operator - (const Hsh &a) const\n\t{\n\t\treturn (Hsh){(m1 - a.m1 + mod1) % mod1,(m2 - a.m2 + mod2) % mod2};\n\t}\n\tHsh operator * (const Hsh &a) const\n\t{\n\t\treturn (Hsh){m1 * a.m1 % mod1,m2 * a.m2 % mod2};\n\t}\n\tbool operator < (const Hsh &a) const\n\t{\n\t\treturn m1 == a.m1 ? m2 < a.m2 : m1 < a.m1;\n\t}\n}ha[250050],pos[500050];\n\nmap<Hsh,int> mp;\nint N;\nconst int bas1 = 131,bas2 = 1331;\nchar s[250005];\n\nlong long qpow(long long base,int tms,int mod)\n{\n\tlong long tmp = 1;\n\twhile(tms)\n\t{\n\t\tif(tms & 1) tmp = tmp * base % mod;\n\t\tbase = base * base % mod;\n\t\ttms >>= 1;\n\t}\n\treturn tmp;\n}\n\nint main()\n{\n\tHsh x,inv;\n\tint n;\n\tx.m1 = bas1,x.m2 = bas2;\n\tinv.m1 = qpow(bas1,mod1 - 2,mod1),inv.m2 = qpow(bas2,mod2 - 2,mod2);\n\tpos[0].m1 = pos[0].m2 = 1; scanf(\"%d\",&n); scanf(\"%s\",s + 1);\n\tfor(int i = 1;i <= n; ++ i)\n\t{\n\t\tpos[i] = pos[i - 1];\n\t\tif(s[i] == '<') pos[i] = pos[i - 1] * inv;\n\t\telse if(s[i] == '>') pos[i] = pos[i - 1] * x;\n\t}\n\tfor(int i = n;i >= 1; -- i)\n\t{\n\t\tha[i] = ha[i + 1];\n\t\tif(s[i] == '+') ha[i] = ha[i] + pos[i];\n\t\telse if(s[i] == '-') ha[i] = ha[i] - pos[i];\n\t}\n\tmp[ha[n + 1]] = 1;\n\tlong long ans = 0;\n\tfor(int i = n;i >= 1; -- i)\n\t{\n\t\tHsh cur = ha[i] - ha[1] * pos[i - 1];\n\t\tans += mp[cur];\n\t\tmp[ha[i]] ++;\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ntemplate<class T> inline void read(T &x){\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ntemplate<class T> inline void umin(T &x, T y){x=x<y?x:y;}\ntemplate<class T> inline void umax(T &x, T y){x=x>y?x:y;}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 266666,mo=1e9+7,M=6;\ninline int power(int a, int n) {\n\tint res=1;\n\twhile (n) {\n\t\tif (n&1) res=1LL*res*a%mo;\n\t\ta=1LL*a*a%mo; n>>=1;\n\t}\n\treturn res;\n}\nint n;char s[N];\ninline void add(int &x, int y){x=x+y<mo?x+y:x+y-mo;}\nint pr[]={998244353,10,23336666,19260817,114514,993244853};\nint ni[10];\nstruct node{\n\tint v[M+1];\n\tbool operator<(const node&a)const{\n\t\trep(i,0,M-1)if(v[i]!=a.v[i])return v[i]<a.v[i];\n\t\treturn 0;\n\t}\n}c,a,k1,b1,k2,b2;map<node,int>Map;ll res;\nvoid nisolve(node &k,node &b,int i){\n\tif(i==n){\n\t\tif(s[i]=='+'){rep(j,0,M-1)b.v[j]=mo-1,k.v[j]=1;}\n\t\tif(s[i]=='-'){rep(j,0,M-1)b.v[j]=1,k.v[j]=1;}\n\t\tif(s[i]=='>'){rep(j,0,M-1)k.v[j]=1LL*ni[j]%mo,b.v[j]=0;}\n\t\tif(s[i]=='<'){rep(j,0,M-1)k.v[j]=1LL*pr[j]%mo,b.v[j]=0;}\n\t\treturn;\n\t}\n\t\tif(s[i]=='+'){rep(j,0,M-1)add(b.v[j],mo-k.v[j]);}\n\t\tif(s[i]=='-'){rep(j,0,M-1)add(b.v[j],k.v[j]);}\n\t\tif(s[i]=='>'){rep(j,0,M-1)k.v[j]=1LL*k.v[j]*ni[j]%mo;}\n\t\tif(s[i]=='<'){rep(j,0,M-1)k.v[j]=1LL*k.v[j]*pr[j]%mo;}\n}\nint main() {\n\trep(i,0,M-1)ni[i]=power(pr[i],mo-2);\n\tread(n);scanf(\"%s\",s+1);\n\tper(i,n,1){\n\t\tif(s[i]=='+'){rep(j,0,M-1)add(c.v[j],1);}\n\t\tif(s[i]=='-'){rep(j,0,M-1)add(c.v[j],mo-1);}\n\t\tif(s[i]=='>'){rep(j,0,M-1)c.v[j]=1LL*c.v[j]*pr[j]%mo;}\n\t\tif(s[i]=='<'){rep(j,0,M-1)c.v[j]=1LL*c.v[j]*ni[j]%mo;}\n\t}\n\tb2=c;\n\tcerr<<b2.v[1]<<endl;\n\tper(l,n,1){\n\t//\tcerr<<\"modify \"<<b1.v[1]<<endl;\n\t\tMap[b1]++;\n\t\tnisolve(k1,b1,l);nisolve(k2,b2,l);\n\t\tnode t;rep(j,0,M-1)t.v[j]=(1LL*k2.v[j]*c.v[j]+b2.v[j])%mo;\n\t\tcerr<<t.v[1]<<endl;res+=Map[t];\n\t}\n\tcout<<res;return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"tune=native\")\n#pragma GCC target(\"avx\")\nusing ll = long long;\nconstexpr ll pow(const ll a, const ll b, const ll mod) { return b == 0 ? 1LL : b % 2 == 1 ? pow(a, b - 1, mod) * a % mod : pow(a * a % mod, b / 2, mod); }\nconstexpr ll inverse(const ll a, const ll mod) { return pow(a, mod - 2, mod); }\nconstexpr ll MOD0 = 1000000007LL, MOD1 = 1000000009LL, MOD2 = 1000000021;\nconstexpr ll X = 121234243;\nconstexpr ll XINV0 = inverse(X, MOD0), XINV1 = inverse(X, MOD1), XINV2 = inverse(X, MOD2);\nconstexpr int L = 250000;\nusing P = std::tuple<ll, ll, ll>;\nP power[L] = {P{1, 1, 1}}, invpower[L] = {P{1, 1, 1}};\nauto plus = [](const P& p1, const P& p2) { return P{(std::get<0>(p1) + std::get<0>(p2)) % MOD0, (std::get<1>(p1) + std::get<1>(p2)) % MOD1, (std::get<2>(p1) + std::get<2>(p2)) % MOD2}; };\nauto minus = [](const P& p1, const P& p2) { return P{(std::get<0>(p1) + MOD0 - std::get<0>(p2)) % MOD0, (std::get<1>(p1) + MOD1 - std::get<1>(p2)) % MOD1, (std::get<2>(p1) + MOD2 - std::get<2>(p2)) % MOD2}; };\nauto rshift = [](const P& p) { return P{std::get<0>(p) * X % MOD0, std::get<1>(p) * X % MOD1, std::get<2>(p) * X % MOD2}; };\nauto lshift = [](const P& p) { return P{std::get<0>(p) * XINV0 % MOD0, std::get<1>(p) * XINV1 % MOD1, std::get<2>(p) * XINV2 % MOD2}; };\nauto mul = [](const P& p1, const P& p2) { return P{std::get<0>(p1) * std::get<0>(p2) % MOD0, std::get<1>(p1) * std::get<1>(p2) % MOD1, std::get<2>(p1) * std::get<2>(p2) % MOD2}; };\nint main()\n{\n    for (int i = 1; i <= L; i++) { power[i] = rshift(power[i - 1]), invpower[i] = lshift(invpower[i - 1]); }\n    auto invp = [](const int i) { return i >= 0 ? invpower[i] : power[-i]; };\n    int N;\n    std::string S;\n    std::cin >> N >> S;\n    std::vector<int> deg(N + 1, 0);\n    std::vector<P> value(N + 1, P{0, 0, 0});\n    for (int i = N - 1; i >= 0; i--) {\n        if (S[i] == '-') {\n            deg[i] = deg[i + 1], value[i] = minus(value[i + 1], P{1, 1, 1});\n        } else if (S[i] == '+') {\n            deg[i] = deg[i + 1], value[i] = plus(value[i + 1], P{1, 1, 1});\n        } else if (S[i] == '>') {\n            deg[i] = deg[i + 1] + 1, value[i] = rshift(value[i + 1]);\n        } else {\n            deg[i] = deg[i + 1] - 1, value[i] = lshift(value[i + 1]);\n        }\n    }\n    const P answer = value[0];\n    for (int i = 0; i <= N; i++) { value[i] = mul(minus(value[i], answer), invp(deg[i])); }\n    std::map<P, ll> mp;\n    ll ans = 0;\n    for (int i = 0; i <= N; i++) {\n        const P obj = plus(value[i], mul(invp(deg[i]), answer));\n        if (mp.find(obj) != mp.end()) { ans += mp[obj]; }\n        mp[value[i]]++;\n    }\n    std::cout << ans << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<map>\ntypedef unsigned long long ll;\ntypedef double dd;\ntypedef __int128 I;\n#define For(i,j,k) for (int i=(int)j;i<=(int)k;++i)\n#define Forr(i,j,k) for (int i=(int)j;i>=(int)k;--i)\n#define Set(a,p) memset(a,p,sizeof(a))\nusing namespace std;\n\ntemplate<typename T>bool chkmax(T &a,T b) { return a<b?a=b,1:0; }\ntemplate<typename T>bool chkmin(T &a,T b) { return a>b?a=b,1:0; }\n\nconst int maxn=250000+100;\nconst ll modd=1000000000000000031ll;\nconst ll p1=1000000000000000003ll;\nconst ll p2=821428571428571454ll;\nint n;\nll Ans;\nll p[maxn],a[maxn];\nchar s[maxn];\nmap<ll,int>ma;\n\ninline void file() {\n\tfreopen(\"ARC099F.in\",\"r\",stdin);\n\tfreopen(\"ARC099F.out\",\"w\",stdout);\n}\n\ninline ll quick(ll a,ll b) {\n\tll s=1;\n\twhile (b) {\n\t\tif (b%2==1) s=(I)s*a%modd;\n\t\ta=(I)a*a%modd; b/=2;\n\t}\n\treturn s;\n}\n\nint main() {\n//\tfile();\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",s+1);\n\tp[0]=1;\n\tFor (i,1,n) {\n\t\tp[i]=p[i-1]; a[i]=a[i-1];\n\t\tif (s[i]=='+') a[i]=((I)a[i]+p[i])%modd;\n\t\tif (s[i]=='-') a[i]=((I)a[i]+modd-p[i])%modd;\n\t\tif (s[i]=='>') p[i]=(I)p[i]*p1%modd;\n\t\tif (s[i]=='<') p[i]=(I)p[i]*p2%modd;\n\t}\n\tForr (i,n,1) {\n\t\t++ma[a[i]];\n\t\tAns+=ma[((I)a[n]*p[i-1]%modd+a[i-1])%modd];\n\t}\n\tprintf(\"%lld\",Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nint gcd(int a, int b) { return b ? gcd(b, a % b) : a; }\ntemplate<typename T, typename U> inline bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> inline bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\nstruct Init {\n    Init() {\n        cout << fixed << setprecision(20);\n    };\n} init;\n\nint N;\nstring S;\nint mod = 1e9 + 7;\n\n// 拡張ユークリッドの互除法\nint extgcd(int a, int b, int &x, int &y) {\n    int d = a;\n    if (b != 0) {\n        d = extgcd(b, a % b, y, x);\n        y -= (a / b) * x;\n    } else {\n        x = 1;\n        y = 0;\n    }\n    return d;\n}\n\n// mod逆元\nint mod_inverse(int a, int m) {\n    int x, y;\n    extgcd(a, m, x, y);\n    return (m + x % m) % m;\n}\n\npint f(pint ab, int i, int hash) {\n    if (S[i] == '+') { return pint(ab.first, (ab.second + 1) % mod); }\n    else if (S[i] == '-') { return pint(ab.first, (ab.second - 1 + mod) % mod); }\n    else if (S[i] == '>') { return pint(ab.first * hash % mod, ab.second * hash % mod); }\n    else if (S[i] == '<') {\n        return pint(ab.first * mod_inverse(hash, mod) % mod,\n                    ab.second * mod_inverse(hash, mod) % mod);\n    }\n}\n\npint finv(pint ab, int i, int hash) {\n    if (S[i] == '-') { return pint(ab.first, (ab.second + 1) % mod); }\n    else if (S[i] == '+') { return pint(ab.first, (ab.second - 1 + mod) % mod); }\n    else if (S[i] == '<') { return pint(ab.first * hash % mod, ab.second * hash % mod); }\n    else if (S[i] == '>') {\n        return pint(ab.first * mod_inverse(hash, mod) % mod,\n                    ab.second * mod_inverse(hash, mod) % mod);\n    }\n}\nsigned main() {\n    cin >> N >> S;\n    const int K = 3;\n    vint hash = {114514, 1919, 810};\n    map<int, int> mp[K];\n    pint b[K], c[K];\n    for (int i = 0; i < K; i++) {\n        int h = hash[i];\n        b[i] = c[i] = pint(1, 0);\n        for (int j = N - 1; j >= 0; j--) { b[i] = f(b[i], j, h), mp[i][0] = 1; }\n    }\n    int ans = 0;\n    for (int i = N - 1; i >= 0; i--) {\n        int cur = LLONG_MAX;\n        for (int j = 0; j < K; j++) {\n            int h = hash[j];\n            pint cc = finv(pint(1, 0), i, h);\n            c[j] = pint(c[j].first * cc.first % mod, (c[j].first * cc.second + c[j].second) % mod);\n            int fi = (c[j].first * b[j].second + c[j].second) % mod;\n            chmin(cur, mp[j][fi]);\n            mp[j][c[j].second]++;\n        }\n        ans += cur;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=1;i<=(n);i++)\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int maxn=500005;\nconst int hval[4]={12345678,23456781,34567812,45678123};\nconst int mod[4]={515880193,998244353,1e9+7,1e9+9};\nclass Hash{\npublic:\n\tint h[4];\n\tHash(){memset(h,0,sizeof(h));}\n\tbool operator < (const Hash &o)const{\n\t\tif(h[0]!=o.h[0])return h[0]<o.h[0];\n\t\tif(h[1]!=o.h[1])return h[1]<o.h[1];\n\t\tif(h[2]!=o.h[2])return h[2]<o.h[2];\n\t\treturn h[3]<o.h[3];\n\t}\n\tHash operator + (const Hash &o)const{\n\t\tHash res;\n\t\trep(i,4){\n\t\t\tres.h[i]=h[i]+o.h[i];\n\t\t\tif(res.h[i]>=mod[i])res.h[i]-=mod[i];\n\t\t}\n\t\treturn res;\n\t}\n\tHash operator - (const Hash &o)const{\n\t\tHash res;\n\t\trep(i,4){\n\t\t\tres.h[i]=h[i]-o.h[i];\n\t\t\tif(res.h[i]<0)res.h[i]+=mod[i];\n\t\t}\n\t\treturn res;\n\t}\n\tHash operator * (const Hash &o)const{\n\t\tHash res;\n\t\trep(i,4)res.h[i]=1LL*h[i]*o.h[i]%mod[i];\n\t\treturn res;\n\t}\n}H,iH,one,pw[maxn],ipw[maxn],sum[maxn];\nint n;\nint pos[maxn];\nmap<Hash,int>cnt;\nchar s[maxn];\n\nint power(int x,int pow,int mod){\n\tint res=1;\n\tfor(;pow;pow>>=1){\n\t\tif(pow&1)res=1LL*res*x%mod;\n\t\tx=1LL*x*x%mod;\n\t}\n\treturn res;\n}\n\nint main(){\n\tscanf(\"%d%s\",&n,s+1);\n\trep(i,4){\n\t\tH.h[i]=hval[i];\n\t\tiH.h[i]=power(hval[i],mod[i]-2,mod[i]);\n\t\tone.h[i]=1;\n\t}\n\tpw[0]=ipw[0]=one;\n\tREP(i,2*n){\n\t\tpw[i]=pw[i-1]*H;\n\t\tipw[i]=ipw[i-1]*iH;\n\t}\n\tREP(i,n){\n\t\tpos[i]=pos[i-1];\n\t\tsum[i]=sum[i-1];\n\t\tif(s[i]=='<')pos[i]--;\n\t\telse if(s[i]=='>')pos[i]++;\n\t\telse if(s[i]=='+')sum[i]=sum[i]+pw[pos[i]+n];\n\t\telse sum[i]=sum[i]-pw[pos[i]+n];\n\t}\n\tll ans=0;\n\tfor(int i=n;i>=1;i--){\n\t\tcnt[sum[i]]++;\n\t\tif(pos[i-1]<0)ans+=cnt[(sum[n]*ipw[-pos[i-1]])+sum[i-1]];\n\t\telse ans+=cnt[(sum[n]*pw[pos[i-1]])+sum[i-1]];\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll MOD = 998244353;\nconst ll MOD2 = 1000000009;\nconst int MX = 250005;\nconst ll R = 143489077;\nconst ll IR = 888352735;\n\nstruct NUM\n{\n\tll x, y;\n\n\tNUM (const ll &x0 = 0, const ll &y0 = 0) : x(x0), y(y0) {}\n\t//NUM operator + ()\n};\n\nll qpow(ll x, ll t)\n{\n\tll ans = 1;\n\twhile(t)\n\t{\n\t\tif(t & 1) ans = ans*x % MOD;\n\t\tx = x*x % MOD;\n\t\tt >>= 1;\n\t}\n\treturn ans;\n}\n\nll inv(ll x)\n{\n\treturn qpow(x, MOD-2);\n}\n\nint n;\nchar str[MX];\n\nvoid input()\n{\n\tcout << inv(R) << endl;\n\tscanf(\"%d\", &n);\n\tscanf(\"%s\", str+1);\n}\n\nll con[MX], sum[MX];\nmap<ll, int> hav;\n\nvoid work()\n{\n\tll p = 1;\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tif(str[i] == '+') con[i] = p;\n\t\telse if(str[i] == '-') con[i] = (MOD-p) % MOD;\n\t\telse if(str[i] == '>') p = p*R % MOD;\n\t\telse p = p*IR % MOD;\n\t\tsum[i] = (sum[i-1] + con[i]) % MOD;\n\t\thav[sum[i]]++;\n\t}\n\tll ans = 0, t = 1;\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tans += hav[(sum[n]*t+sum[i-1]) % MOD];\n\t\tif(str[i] == '>') t = t*R % MOD;\n\t\telse if(str[i] == '<') t = t*IR % MOD;\n\t\thav[sum[i]]--;\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main()\n{\n\tinput();\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define iinf 2000000000\n#define linf 1000000000000000000LL\n#define ulinf 10000000000000000000ull\n#define MOD1 1000000007LL\n#define MUL 541231LL\n#define mpr make_pair\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef unsigned long UL;\ntypedef unsigned short US;\ntypedef pair < int , int > pii;\nclock_t __stt;\ninline void TStart(){__stt=clock();}\ninline void TReport(){printf(\"\\nTaken Time : %.3lf sec\\n\",(double)(clock()-__stt)/CLOCKS_PER_SEC);}\ntemplate < typename T > T MIN(T a,T b){return a<b?a:b;}\ntemplate < typename T > T MAX(T a,T b){return a>b?a:b;}\ntemplate < typename T > T ABS(T a){return a>0?a:(-a);}\ntemplate < typename T > void UMIN(T &a,T b){if(b<a) a=b;}\ntemplate < typename T > void UMAX(T &a,T b){if(b>a) a=b;}\nint n,glob,mul[500005];\nLL cnt;\nchar s[250005];\nmap < int , int > mp;\nint pow(int val,int pw=MOD1-2){\n    int ret=1;\n    while(pw){\n        if(pw&1) ret=((LL)ret*(LL)val)%MOD1;\n        val=((LL)val*(LL)val)%MOD1;\n        pw>>=1;\n    }\n    return ret%MOD1;\n}\nvoid solve(int l,int r){\n\tmp.clear();\n\tif(l==r){\n\t\tif(s[l]=='+') cnt+=(LL)(glob==1);\n\t\telse if(s[l]=='-') cnt+=(LL)(glob==MOD1-1);\n\t\telse cnt+=(LL)(glob==0);\n\t\treturn;\n\t}\n\tint M=((l+r)>>1),i,ptr=0,cur=0,mtl=1;\n\tfor(i=M;i>=l;--i){\n\t\tif(s[i]=='<')\n\t\t\t--ptr;\n\t\telse if(s[i]=='>')\n\t\t\t++ptr;\n\t\telse if(s[i]=='+')\n\t\t\tcur=(cur+mul[ptr+n+1])%MOD1;\n\t\telse\n\t\t\tcur=(cur-mul[ptr+n+1]+MOD1)%MOD1;\n\t\t++mp[cur];\n\t}\n\tcur=0;\n\tfor(i=M+1;i<=r;++i){\n\t\tif(s[i]=='<'){\n\t\t\tcur=((LL)cur*(LL)pow(MUL))%MOD1;\n\t\t\tmtl=((LL)mtl*(LL)pow(MUL))%MOD1;\n\t\t}\n\t\telse if(s[i]=='>'){\n\t\t\tcur=((LL)cur*MUL)%MOD1;\n\t\t\tmtl=((LL)mtl*MUL)%MOD1;\n\t\t}\n\t\telse if(s[i]=='+'){\n\t\t\tcur=(cur+1)%MOD1;\n\t\t}\n\t\telse{\n\t\t\tcur=(cur-1+MOD1)%MOD1;\n\t\t}\n\t\tcnt+=(LL)mp[((LL)((glob-cur+MOD1)%MOD1)*(LL)pow(mtl))%MOD1];\n\t}\n\tsolve(l,M);\n\tsolve(M+1,r);\n}\nint main(){\n    // inputting start\n    // 数据结构记得初始化！ n，m别写反！\n    scanf(\"%d%s\",&n,s);\n    #ifdef LOCAL\n        TStart();\n    #endif\n    // calculation start\n    // 数据结构记得初始化！ n，m别写反！\n    reverse(s,s+n);\n\tint i,j,k;\n\tfor(i=0;i<n;++i){\n\t\tif(s[i]=='<')\n\t\t\tglob=((LL)glob*(LL)pow(MUL))%MOD1;\n\t\telse if(s[i]=='>')\n\t\t\tglob=((LL)glob*MUL)%MOD1;\n\t\telse if(s[i]=='+')\n\t\t\tglob=(glob+1)%MOD1;\n\t\telse\n\t\t\tglob=(glob-1+MOD1)%MOD1;\n\t}\n\tmul[n+1]=1;\n\tfor(i=1;i<=n;++i){\n\t\tmul[n+1+i]=((LL)mul[n+i]*MUL)%MOD1;\n\t}\n\tfor(i=-1;i>=-n;--i){\n\t\tmul[n+1+i]=((LL)mul[n+2+i]*(LL)pow(MUL))%MOD1;\n\t}\n\tsolve(0,n-1);\n\tprintf(\"%lld\\n\",cnt);\n    #ifdef LOCAL\n        TReport();\n    #endif\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int N = 250033, mod1 = 1000000007, mod2 = 1000109107;\nint qpow(int b, int p, int m) {\n  int r = 1;\n  for (; p; p >>= 1, b = (ll) b * b % m) if (p & 1) r = (ll) r * b % m;\n  return r;\n}\nstruct data {\n  int x, y;\n  data(int x = 0, int y = 0) : x(x), y(y) {}\n  data operator + (const data &d) const {return data((x + d.x) % mod1, (y + d.y) % mod2);}\n  data operator - (const data &d) const {return data((x + mod1 - d.x) % mod1, (y + mod2 - d.y) % mod2);};\n  data operator * (const data &d) const {return data((ll) x * d.x % mod1, (ll) y * d.y % mod2);}\n  data operator / (const data &d) const {return data((ll) x * qpow(d.x, mod1 - 2, mod1) % mod1, (ll) y * qpow(d.y, mod2 - 2, mod2) % mod2);}\n  ll get() {return (ll) x << 30 | y;}\n};\ndata X(159623, 102647), f[N], g[N], h[N], k(1, 1), b;\nint n;\nll ans;\nchar s[N];\nmap<ll, int> mp;\n\nint main() {\n  scanf(\"%d%s\", &n, s + 1);\n  for (int i = 1; i <= n; i++) {\n    if (s[i] == '+') b = b + k;\n    if (s[i] == '-') b = b - k;\n    if (s[i] == '>') k = k * X;\n    if (s[i] == '<') k = k / X;\n    f[i] = b;\n  }\n  g[0] = k = data(1, 1), h[0] = b = data(0, 0);\n  for (int i = 1; i <= n; i++) {\n    if (s[i] == '+') b = b - data(1, 1);\n    if (s[i] == '-') b = b + data(1, 1);\n    if (s[i] == '>') k = k / X, b = b / X;\n    if (s[i] == '<') k = k * X, b = b * X;\n    g[i] = k, h[i] = b;\n  }\n  for (int i = n; i >= 0; i--) {\n    data t = (f[n] - h[i]) / g[i];\n    ans += mp[t.get()];\n    mp[f[i].get()]++;\n  }\n  printf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n  \n#define ll long long\n#define all(aaa) aaa.begin(), aaa.end()\n\nconst int MOD = 1000000033, N = 6e5 + 5;\n\nll bp(ll a, ll p) {\n    ll r = 1;\n    while (p > 0) {\n        if (p & 1)\n            r = r * a % MOD;\n        a = a * a % MOD;\n        p >>= 1;\n    }\n    return r;\n}\n\nll inv_X[6], X[6];\n\nvector<ll> a[N], b[N];\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    mt19937 rnd(time(0));\n\n    for (int i = 0; i < 6; i++) {\n        X[i] = rnd() % 1000000 + 1000000;\n        inv_X[i] = bp(X[i], MOD - 2);\n    }\n\n    int n;\n    string s;\n    cin >> n >> s;\n\n    vector<ll> h(6, 0);\n\n    for (int i = n - 1; i >= 0; i--) {\n        if (s[i] == '>') {\n            for (int j = 0; j < 6; j++) {\n                h[j] = h[j] * X[j] % MOD;\n            }\n        }\n        else if (s[i] == '<') {\n            for (int j = 0; j < 6; j++) {\n                h[j] = h[j] * inv_X[j] % MOD;\n            }\n        }\n        else if (s[i] == '+') {\n            for (ll &x : h)\n                x = (x + 1) % MOD;\n        }\n        else {\n            for (ll &x : h)\n                x = (x - 1 + MOD) % MOD;\n        }\n    }\n\n    map<vector<ll>, int> mp;\n\n    ll ans = 0;\n\n    a[n] = vector<ll>(6, 1);\n    b[n] = vector<ll>(6, 0);\n\n    for (int i = n - 1; i >= 0; i--) {\n        mp[b[i + 1]]++;\n\n        a[i] = a[i + 1];\n        b[i] = b[i + 1];\n\n        if (s[i] == '>') {\n            for (int j = 0; j < 6; j++) {\n                a[i][j] = a[i][j] * inv_X[j] % MOD;\n            }\n        }\n        else if (s[i] == '<') {\n            for (int j = 0; j < 6; j++) {\n                a[i][j] = a[i][j] * X[j] % MOD;\n            }\n        }\n        else if (s[i] == '+') {\n            for (int j = 0; j < 6; j++) {\n                b[i][j] = (b[i][j] - a[i][j] + MOD) % MOD;\n            }\n        }\n        else {\n            for (int j = 0; j < 6; j++) {\n                b[i][j] = (b[i][j] + a[i][j]) % MOD;\n            }\n        }\n\n        vector<ll> qr;\n        for (int j = 0; j < 6; j++) {\n            qr.push_back((a[i][j] * h[j] + b[i][j]) % MOD);\n        }\n\n        ans += mp[qr];\n    }\n    \n    cout << ans << \"\\n\";\n\n    return 0;   \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\n#include <unordered_map>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\nconst ll MOD=998244353;\nll qp(ll a,ll b)\n{\n\tll x=1; a%=MOD;\n\twhile(b)\n\t{\n\t\tif(b&1) x=x*a%MOD;\n\t\ta=a*a%MOD; b>>=1;\n\t}\n\treturn x;\n}\nconst ll g=555555,rg=qp(g,MOD-2);\npair<ll,ll> operator +\n(pair<ll,ll> a,pair<ll,ll> b)\n{return mp((a.fi+a.se*b.fi)%MOD,a.se*b.se%MOD);}\n#define SZ 666666\nint n; char str[SZ];\npair<ll,ll> sg[SZ],tg(0,1);\nll ans=0;\nvoid fz(int l,int r)\n{\n\tif(l==r)\n\t{\n\t\tans+=sg[l].fi==tg.fi;\n\t\treturn;\n\t}\n\tint m=(l+r)>>1;\n\tfz(l,m); fz(m+1,r);\n\tunordered_map<ll,int> sb;\n\tpair<ll,ll> g(0,1);\n\tfor(int i=m+1;i<=r;++i)\n\t{\n\t\tg=g+sg[i]; ++sb[g.fi];\n\t}\n\tg=mp(0,1);\n\tfor(int i=m;i>=l;--i)\n\t{\n\t\tg=sg[i]+g;\n\t\t//g.fi+g.se*T=tg.fi\n\t\tll tr=(tg.fi-g.fi+MOD)%MOD*qp(g.se,MOD-2)%MOD;\n\t\tans+=sb[tr];\n\t}\n}\nint main()\n{\n\tscanf(\"%d%s\",&n,str+1);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tif(str[i]=='+') sg[i]=mp(1,1);\n\t\telse if(str[i]=='-') sg[i]=mp(MOD-1,1);\n\t\telse if(str[i]=='>') sg[i]=mp(0,g);\n\t\telse sg[i]=mp(0,rg); tg=tg+sg[i];\n\t}\n\tfz(1,n); cout<<ans<<\"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAX_N = 3e5 + 10, X_NUM = 2;\nconst ll MOD = 1e9 + 7;\n\nll sq(ll x) { return x * x % MOD; }\nll qpow(ll a, ll b) { return b ? sq(qpow(a, b / 2)) * (b & 1 ? a : 1) % MOD : 1; }\nll inv(ll x) { return qpow(x, MOD - 2); }\n\nvector<ll> values_x = {100, 10000};\nvector<ll> values_invx;\nvector<pair<ll, ll>> revert[MAX_N];\nvector<ll> digest[MAX_N];\n\nint N;\nchar S[MAX_N];\nmap<vector<ll>, int> occur;\nll ans;\n\nvoid init() {\n    scanf(\"%d\", &N); scanf(\"%s\", S + 1);\n    for (int i = 0; i < X_NUM; i++) values_invx.push_back(inv(values_x[i]));\n    for (int i = 0; i < X_NUM; i++) {\n        ll v = 0, px = 1;\n        for (int j = 1; j <= N; j++) {\n            switch (S[j]) {\n            case '<': {\n                (px *= values_invx[i]) %= MOD;\n            }; break;\n            case '>': {\n                (px *= values_x[i]) %= MOD;\n            }; break;\n            case '+': {\n                (v += px) %= MOD;\n            }; break;\n            case '-': {\n                (v += MOD - px) %= MOD;\n            }; break;\n            }\n            digest[j].push_back(v);\n        }\n    }\n    for (int i = 0; i < X_NUM; i++) {\n        ll a = 1, b = 0; // ax + b\n        revert[0].emplace_back(a, b);\n        for (int j = 1; j <= N; j++) {\n            switch (S[j]) {\n            case '<': {\n                (a *= values_x[i]) %= MOD;\n                (b *= values_x[i]) %= MOD;\n            }; break;\n            case '>': {\n                (a *= values_invx[i]) %= MOD;\n                (b *= values_invx[i]) %= MOD;\n            }; break;\n            case '+': {\n                (b += MOD - 1) %= MOD;\n            }; break;\n            case '-': {\n                (b += 1) %= MOD;\n            }; break;\n            }\n            revert[j].emplace_back(a, b);\n        }\n    }\n    for (int i = 1; i <= N; i++)\n        occur[digest[i]]++;\n}\n\nvoid solve() {\n    for (int i = 0; i < N; i++) {\n        vector<ll> target;\n        for (int j = 0; j < X_NUM; j++) {\n            ll t = (digest[N][j] - revert[i][j].second + MOD) * inv(revert[i][j].first) % MOD;\n            target.push_back(t);\n        }\n        ans += occur[target];\n        occur[digest[i + 1]]--;\n    }\n    printf(\"%lld\\n\", ans);\n}\n\nint main() {\n    init();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "const int N = 405;\nconst int LG = 21;\nconst long long MOD = 1e9 + 7;\nconst int INF = 1e9;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nint n;\nstring s;\nll sufa[N];\nll suf0[N];\nconst ll K = 29;\nconst ll rK = rev(K);\nll pref0[N];\nll prefa[N];\nll moves[N];\nmap<int, int> deg;\n\nsigned main()\n{\n    deg[0] = 1;\n    for (int i = 1; i < N; i++) deg[i] = deg[i - 1] * K % MOD;\n    for (int i = 1; i < N; i++) deg[-i] = deg[-i + 1] * rK % MOD;\n    srand(time(NULL));\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n    cin >> n >> s;\n    ll a = 0;\n    for (int i = n - 1; i >= 0; i--)\n    {\n        if (s[i] == '+')\n        {\n            a = (a + MOD - 1) % MOD;\n        }\n        if (s[i] == '-')\n        {\n            a = (a + 1) % MOD;\n        }\n        if (s[i] == '>')\n        {\n            a = (a * K) % MOD;\n        }\n        if (s[i] == '<')\n        {\n            a = (a * rK) % MOD;\n        }\n    }\n    pref0[0] = 0, prefa[0] = a, moves[0] = 0;\n    if (s[0] == '+') pref0[0] = (pref0[0] + 1) % MOD;\n    if (s[0] == '-') pref0[0] = (pref0[0] + MOD - 1) % MOD;\n    if (s[0] == '<') pref0[0] = (pref0[0] * K) % MOD;\n    if (s[0] == '>') pref0[0] = (pref0[0] * rK) % MOD;\n    if (s[0] == '+') prefa[0] = (prefa[0] + 1) % MOD;\n    if (s[0] == '-') prefa[0] = (prefa[0] + MOD - 1) % MOD;\n    if (s[0] == '<') prefa[0] = (prefa[0] * K) % MOD;\n    if (s[0] == '>') prefa[0] = (prefa[0] * rK) % MOD;\n    if (s[0] == '>') moves[0]++;\n    if (s[0] == '<') moves[0]--;\n    for (int i = 1; i < n; i++)\n    {\n        if (s[i] == '+') pref0[i] = (pref0[i - 1] + 1) % MOD;\n        if (s[i] == '-') pref0[i] = (pref0[i - 1] + MOD - 1) % MOD;\n        if (s[i] == '<') pref0[i] = (pref0[i - 1] * K) % MOD;\n        if (s[i] == '>') pref0[i] = (pref0[i - 1] * rK) % MOD;\n        if (s[i] == '+') prefa[i] = (prefa[i - 1] + 1) % MOD;\n        if (s[i] == '-') prefa[i] = (prefa[i - 1] + MOD - 1) % MOD;\n        if (s[i] == '<') prefa[i] = (prefa[i - 1] * K) % MOD;\n        if (s[i] == '>') prefa[i] = (prefa[i - 1] * rK) % MOD;\n        moves[i] = moves[i - 1];\n        if (s[i] == '>') moves[i]++;\n        if (s[i] == '<') moves[i]--;\n    }\n    for (int j = 0; j < n; j++)\n    {\n        if (s[j] == '+')\n        {\n            suf0[0] = (suf0[0] + 1) % MOD;\n        }\n        if (s[j] == '-')\n        {\n            suf0[0] = (suf0[0] + MOD - 1) % MOD;\n        }\n        if (s[j] == '<')\n        {\n            suf0[0] = (suf0[0] * K) % MOD;\n        }\n        if (s[j] == '>')\n        {\n            suf0[0] = (suf0[0] * rK) % MOD;\n        }\n    }\n    for (int i = 0; i < n; i++) suf0[i + 1] = (suf0[0] - pref0[i] * deg[moves[i]] + MOD * MOD) % MOD;\n    for (int i = 0; i < n; i++) sufa[i] = (suf0[i] + a * deg[(i > 0 ? moves[i - 1] : 0) - moves[n - 1]]) % MOD;\n    #ifdef LOCAL\n    for (int i = 0; i < n; i++) cout << pref0[i] * deg[moves[i]] % MOD << \" \"; cout << \"\\n\";\n    for (int i = 0; i < n; i++) cout << prefa[i] * deg[moves[i]] % MOD << \" \"; cout << \"\\n\";\n    for (int i = 0; i < n; i++) cout << suf0[i] << \" \"; cout << \"\\n\";\n    for (int i = 0; i < n; i++) cout << -(moves[n - 1] - moves[i - 1]) << \" \"; cout << \"\\n\";\n    for (int i = 0; i < n; i++) cout << (sufa[i] + MOD - suf0[i]) % MOD << \" \"; cout << \"\\n\";\n    cout << \"This line\\n\";\n    for (int i = 0; i < n; i++) cout << (suf0[i] + a * deg[moves[i - 1] - moves[n - 1]]) % MOD << \" \"; cout << \"\\n\";\n    for (int i = 0; i < n; i++) cout << sufa[i] << \" \"; cout << \"\\n\";\n    cout << \"That line\\n\";\n    for (int i = 0; i < n; i++) cout << (pref0[i] * deg[moves[i]] + suf0[i + 1]) % MOD << \" \"; cout << \"\\n\";\n    for (int i = 0; i < n; i++) cout << (pref0[i] * deg[moves[i]] + sufa[i + 1]) % MOD << \" \"; cout << \"\\n\";\n    #endif // LOCAL\n    ll ans = 0;\n    map<vector<int>, int> cnt;\n    for (int i = n; i >= 0; i--)\n    {\n        ans += cnt[{sufa[i]}];\n        cnt[{suf0[i]}]++;\n    }\n    cout << ans;\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\nconst pid_t pid = getpid();\n// Problem Specific Parameter:\n\ntemplate<unsigned MOD>  class ModInt {\npublic:\n\tModInt(): x(0) {}\n\tModInt(signed y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n\tModInt(signed long long y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n\n\n\t// Arithmetic Oprators\n\tModInt &operator+=(ModInt that) {\n\t\tif ((x += that.x) >= MOD) x -= MOD; \n\t\treturn *this;\n\t}\n\tModInt &operator-=(ModInt that) {\n\t\tif ((x += MOD - that.x) >= MOD) x -= MOD; \n\t\treturn *this;\n\t}\n\tModInt &operator*=(ModInt that) {\n\t\tx = 1LL * x * that.x % MOD;\n\t\treturn *this;\n\t}\n\tModInt &operator/=(ModInt that) {\n\t\treturn *this *= ModInt(get<1>(extgcd(that.x, int(MOD))));\n\t}\n\tModInt &operator%=(ModInt that) {\n\t\tx %= that.x;\n\t\treturn *this;\n\t}\n\n\tModInt &operator+=(const int that) { return *this += ModInt(that);}\n\tModInt &operator-=(const int that) { return *this -= ModInt(that);}\n\tModInt &operator*=(const int that) { return *this *= ModInt(that);}\n\tModInt &operator/=(const int that) { return *this /= ModInt(that);}\n\tModInt &operator%=(const int that) { return *this %= ModInt(that);}\n\n\t// Comparators\n\tbool operator <(ModInt that) const { return x < that.x; }\n\tbool operator >(ModInt that) const { return x > that.x; }\n\tbool operator<=(ModInt that) const { return x <= that.x; }\n\tbool operator>=(ModInt that) const { return x >= that.x; }\n\tbool operator!=(ModInt that) const { return x != that.x; }\n\tbool operator==(ModInt that) const { return x == that.x; }\n\n\t// Utilities\n\tunsigned getval() const { return x;}\n\tModInt operator+(ModInt that) const { return ModInt(*this) += that;}\n\tModInt operator-(ModInt that) const { return ModInt(*this) -= that;}\n\tModInt operator*(ModInt that) const { return ModInt(*this) *= that;}\n\tModInt operator/(ModInt that) const { return ModInt(*this) /= that;}\n\tModInt operator%(ModInt that) const { return ModInt(*this) %= that;}\n\tModInt operator+(const int that) const { return ModInt(*this) += that;}\n\tModInt operator-(const int that) const { return ModInt(*this) -= that;}\n\tModInt operator*(const int that) const { return ModInt(*this) *= that;}\n\tModInt operator/(const int that) const { return ModInt(*this) /= that;}\n\tModInt operator%(const int that) const { return ModInt(*this) %= that;}\n\tModInt operator=(const int that) { return *this = ModInt(that);}\n\tfriend istream &operator>>(istream& is, ModInt &that) {ll tmp; is >> tmp; that = ModInt(tmp);return is;}\n\tfriend ostream &operator<<(ostream& os, const ModInt &that) { return os << that.x; }\n\t\n\tModInt power(ll n) const {\n\t\tll b = 1LL, a = x;\n\t\twhile(n){\n\t\t\tif(n & 1) b = b * a % MOD;\n\t\t\ta = a * a % MOD;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn ModInt(b);\n\t}\nprivate:\n\tunsigned x;\n\t\n\tinline auto extgcd(int a, int b) {\n\t\tif (b == 0) return make_tuple(a, 1, 0);\n\t\ttuple<int, int, int> ret = extgcd(b, a % b);\n\t\tswap(get<1>(ret), get<2>(ret));\n\t\tget<2>(ret) -= a / b * get<1>(ret);\n\t\treturn ret;\n\t}\n};\n\nconst int mod = 1000000007;\nusing mint = ModInt<mod>;\nconst mint ZERO = mint(0);\nconst mint ONE = mint(1);\n\nuniform_int_distribution<int> rng(1 << 20,mod - 1); // [lower,upper] \nmt19937 mt(pid);\nconst mint B = rng(mt);\n\nconst int limit = 500010;\nconst int offset = 250000;\nmint shash[limit];\n\n\nmint csum[limit];\nint cpos[limit];\n\nint main(void){\n\tint n;\n\tstring s;\n\tcin >> n >> s;\n\n\tshash[0] = ONE;\n\trep(i,1,limit) shash[i] = shash[i-1] * B;\n\n\tmint cur = ZERO;\n\tint pos = 0;\n\trep(i,n+1){\n\t\tcpos[i] = pos;\n\t\tcsum[i] = cur;\n\t\tif(i == n) break;\n\n\t\tif(s[i] == '+') cur += shash[pos + offset];\n\t\tif(s[i] == '-') cur -= shash[pos + offset];\n\t\tif(s[i] == '>') pos++;\n\t\tif(s[i] == '<') pos--;\n\t}\n\n\tmap<mint,int> num;\n\tnum[csum[n]]++;\n\n\tll ans = 0LL;\n\trrep(i,n){\n\t\tmint tar = csum[n];\n\t\tif(cpos[i] < 0) tar /= B.power(abs(cpos[i])); \n\t\tif(cpos[i] > 0) tar *= B.power(abs(cpos[i])); \n\t\ttar += csum[i];\n\t\tif(num.find(tar) != end(num)) ans += num[tar];\n\t\tnum[csum[i]]++;\n\t}\n\n\tcout << ans << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define MAX 500012\n\nint n;\nchar buf[MAX];\n\n\nstring s;\n\n\n//#define MOD1 1000000007\n//#define MOD2 1000000009\n#define B 4\nvalarray<long long int> MOD1;\nvalarray<long long int> MOD2;\nvector<valarray<long long int> > p2;\nvector<valarray<long long int> > vv;\nvector<int> ps;\nmap<long long int, int> mp;\nlong long int ppow(long long int i, long long int j, long long int MOD) {\n\tlong long int ret = 1;\n\twhile (j) {\n\t\tif (j & 1LL)ret *= i;\n\t\tif (ret >= MOD)ret %= MOD;\n\t\tj >>= 1LL;\n\t}\n\treturn ret;\n}\n\nvalarray<long long int> calc(int dif) {\n\tvalarray<long long int> ret;\n\tret.resize(B, 0);\n\tfor (int j = 0; j < B; j++) {\n\t\tif (dif < 0) {\n\t\t\tret[j]=ppow(ppow(MOD1[j], abs(dif),MOD2[j]), MOD2[j] - 2,MOD2[j]);\n\t\t}\n\t\telse {\n\t\t\tret[j] = ppow(MOD1[j], abs(dif), MOD2[j]);\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main() {\n\tMOD1.resize(2);\n\tMOD2.resize(2);\n\tp2.push_back(valarray<long long int>());\n\tp2.back().resize(B, 1);\n\tMOD2[0] = 1000000007;\n\tMOD1[0] = 998244353;\n\tMOD1[2] = 1741231;\n\tMOD2[2] = 1000000009;\n\tMOD1[3] = 114514191;\n\tMOD2[3] = 1000000007;\n\tMOD1[1] = 555522277;\n\tMOD2[1] = 895612782;\n\tp2[0] %= MOD2;\n\tfor (int i = 1; i < MAX; i++) {\n\t\tp2.push_back(p2.back());\n\t\tp2[i] *= MOD1;\n\t\tp2[i] %= MOD2;\n\t}\n\tcin >> n;\n\tscanf(\"%s\", buf);\n\ts = buf;\n\tint pos = MAX/2;\n\tvalarray<long long int> hs;\n\ths.resize(B,0);\n\tvv.push_back(hs);\n\tps.push_back(pos);\n\tfor (int i = 0; i < s.size(); i++) {\n\t\tif (s[i] == '<') {\n\t\t\tpos--;\n\t\t}\n\t\tif (s[i] == '>') {\n\t\t\tpos++;\n\t\t}\n\t\tif (s[i] == '+') {\n\t\t\ths += p2[pos];\n\t\t}\n\t\tif (s[i] == '-') {\n\t\t\ths -= p2[pos];\n\t\t\ths += MOD2;\n\t\t}\n\t\ths %= MOD2;\n\t\tvv.push_back(hs);\n\t\tps.push_back(pos);\n\t}\n\tlong long int way = 0;\n\tfor (int i = vv.size() - 1; i >= 0; i--) {\n\t\tvalarray<long long int> want = vv[i] + vv.back()*calc(-MAX/2+ps[i]);\n\t\twant = want%MOD2;\n\t\tway += mp[want[0] * MOD1[0] + want[1]];\n\t\t//cerr << \"dbg \" << way << endl;\n\t\tmp[vv[i][0]*MOD1[0]+vv[i][1]]++;\n\t}\n\tprintf(\"%lld\\n\", way);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ri rd<int>\n#define rep(i, a, b) for (int i = (a), _ = (b); i <= _; ++i)\n#define per(i, a, b) for (int i = (a), _ = (b); i >= _; --i)\n#define For(i, a, b) for (int i = (a), _ = (b); i < _; ++i)\nconst int O = 1004535809;\nconst int W = 131;\nconst int _W = 352737765;\nconst int maxN = 250007;\ntypedef long long LL;\n\ntemplate<class T> inline T rd() {\n\tbool f = 1; char c = getchar(); for (; !isdigit(c); c = getchar()) if (c == '-') f = 0;\n\tT x = 0; for (; isdigit(c); c = getchar()) x = x * 10 + c - '0'; return f ? x : -x;\n}\n\nint n;\nchar s[maxN];\nint ps[maxN], hsh[maxN];\n\nvoid init() {\n\thsh[0] = 0, ps[0] = 1;\n\trep (i, 1, n) {\n\t\tif (s[i] == '+') {\n\t\t\tps[i] = ps[i-1];\n\t\t\thsh[i] = (hsh[i-1] + ps[i]) % O;\n\t\t}\n\t\telse if (s[i] == '-') {\n\t\t\tps[i] = ps[i-1];\n\t\t\thsh[i] = (hsh[i-1] + O - ps[i]) % O;\n\t\t}\n\t\telse if (s[i] == '<') {\n\t\t\tps[i] = 1LL * ps[i-1] * _W % O;\n\t\t\thsh[i] = hsh[i-1];\n\t\t}\n\t\telse if (s[i] == '>') {\n\t\t\tps[i] = 1LL * ps[i-1] * W % O;\n\t\t\thsh[i] = hsh[i-1];\n\t\t}\n\t\telse assert(false);\n\t}\n}\n\nvoid solve() {\n\tmap<int, int> mp;\n\tLL res = 0;\n\trep (i, 0, n) {\n\t\tif (i > 0) res += mp[hsh[i] % O];\n\t\tif (i < n) ++mp[(hsh[i] + 1LL * hsh[n] * ps[i]) % O];\n\t}\n\tprintf(\"%lld\\n\", res);\n}\n\nint main() {\n\n\tn = ri();\n\tscanf(\"%s\", s+1);\n\n\tinit();\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nmt19937 rd(time(0));\n#define int long long\nconst int M=1004535809;\n#define fi first\n#define se second\n#define mp make_pair\n#define pii pair<int,int>\nconst int N=250005;\npii f1[N],f2[N];\nchar s[N];\nint n;\nmap<pair<int,int>,int> Map;\nint ksm(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=x*x%M)\n\t\tif (y&1)(ans*=x)%=M;\n\treturn ans;\n}\npii fuhe(pii x,pii y){\n\treturn mp((x.fi*y.fi)%M,(x.fi*y.se+x.se)%M);\n}\nsigned main(){\n\tscanf(\"%lld\",&n);\n\tscanf(\"%s\",s+1);\n\tint x1=rd()%(M-1)+1,x2=rd()%(M-1)+1;\n\tint Inv1=ksm(x1,M-2),Inv2=ksm(x2,M-2);\n\tf1[0]=mp(1,0);f2[0]=mp(1,0);\n\tfor (int i=1;i<=n;i++){\n\t\tif (s[i]=='+')f1[i]=fuhe(f1[i-1],mp(1,1)),f2[i]=fuhe(f2[i-1],mp(1,1));\n\t\tif (s[i]=='-')f1[i]=fuhe(f1[i-1],mp(1,M-1)),f2[i]=fuhe(f2[i-1],mp(1,M-1));\n\t\tif (s[i]=='<')f1[i]=fuhe(f1[i-1],mp(x1,0)),f2[i]=fuhe(f2[i-1],mp(x2,0));\n\t\tif (s[i]=='>')f1[i]=fuhe(f1[i-1],mp(Inv1,0)),f2[i]=fuhe(f2[i-1],mp(Inv2,0));\n\t}\n\tint ans=0;\n\tfor (int i=1;i<=n;i++){\n\t\tMap[mp((fuhe(f1[i-1],f1[n])).se,(fuhe(f2[i-1],f2[n])).se)]++;\n\t\tans+=Map[mp(f1[i].se,f2[i].se)];\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nconst unsigned long long M=998244353;\nconst unsigned long long X=99469;\nunsigned long long R;\nconst int W=1500;\n \n \nunsigned long long ModPow(unsigned long long x, unsigned long long n, unsigned long long mod) {\n        unsigned long long ret = 1;\n        for (; n > 0; n /= 2, x = (x * x) % mod)\n            if ((n & 1) == 1) ret = (ret * x) % mod;\n        return ret;\n    }\n \nunsigned long long has=0,vec=1;\n \nint n;\nstring s;\nunordered_map<unsigned long long,int> B[550];\nlong long ans;\ninline void calc(char c, unsigned long long &u,unsigned long long &p){\n\tif(c=='+')u=(u+p)%M;\n\telse if(c=='-')u=(u+M-p)%M;\n\telse if(c=='>')p=(p*X)%M;\n\telse p=(p*R)%M;\n}\nint main(){\n\tR=ModPow(X,M-2,M);\n\tcin>>n>>s;\n    //n=250000;\n    //s=string(n,'+');\n\tfor(int i=0;i<n;i++)calc(s[i],has,vec);\n\tfor(int i=0;i<n;i++){\n\t\tif(i%W==0)continue;\n\t\tunsigned long long h=0,x=1;\n\t\tfor(int j=i;j<n;j++){\n\t\t\tif(j%W==0)break;\n\t\t\tcalc(s[j],h,x);\n\t\t\tif(h==has)ans++;\n\t\t}\n\t\tunsigned long long nh = (has+M-h)%M;\n\t\tnh = nh * ModPow(x,M-2,M)%M;\n\t\tB[i/W+1][nh]++;\n\t}\n\tfor(int i=0;i<n;i+=W){\n\t\tunsigned long long h=0,x=1;\n\t\tfor(int j=i;j<n;j++){\n\t\t\tcalc(s[j],h,x);\n\t\t\tif(h==has)ans++;\n\t\t\tauto it = B[i/W].find(h);\n\t\t\tif(it!=B[i/W].end())ans+=it->second;\n\t\t}\n\t}\n\t\n\tcout<<ans;\n \n \n}\n#include <bits/stdc++.h>\nusing namespace std;\n \nconst unsigned long long M=998244353;\nconst unsigned long long X=99497;\nunsigned long long R;\nconst int W=1500;\n \n \nunsigned long long ModPow(unsigned long long x, unsigned long long n, unsigned long long mod) {\n        unsigned long long ret = 1;\n        for (; n > 0; n /= 2, x = (x * x) % mod)\n            if ((n & 1) == 1) ret = (ret * x) % mod;\n        return ret;\n    }\n \nunsigned long long has=0,vec=1;\n \nint n;\nstring s;\nunordered_map<unsigned long long,int> B[550];\nlong long ans;\ninline void calc(char c, unsigned long long &u,unsigned long long &p){\n\tif(c=='+')u=(u+p)%M;\n\telse if(c=='-')u=(u+M-p)%M;\n\telse if(c=='>')p=(p*X)%M;\n\telse p=(p*R)%M;\n}\nint main(){\n\tR=ModPow(X,M-2,M);\n\tcin>>n>>s;\n    //n=250000;\n    //s=string(n,'+');\n\tfor(int i=0;i<n;i++)calc(s[i],has,vec);\n\tfor(int i=0;i<n;i++){\n\t\tif(i%W==0)continue;\n\t\tunsigned long long h=0,x=1;\n\t\tfor(int j=i;j<n;j++){\n\t\t\tif(j%W==0)break;\n\t\t\tcalc(s[j],h,x);\n\t\t\tif(h==has)ans++;\n\t\t}\n\t\tunsigned long long nh = (has+M-h)%M;\n\t\tnh = nh * ModPow(x,M-2,M)%M;\n\t\tB[i/W+1][nh]++;\n\t}\n\tfor(int i=0;i<n;i+=W){\n\t\tunsigned long long h=0,x=1;\n\t\tfor(int j=i;j<n;j++){\n\t\t\tcalc(s[j],h,x);\n\t\t\tif(h==has)ans++;\n\t\t\tauto it = B[i/W].find(h);\n\t\t\tif(it!=B[i/W].end())ans+=it->second;\n\t\t}\n\t}\n\t\n\tcout<<ans;\n \n \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define uLL unsigned long long\n#define db double\n\nusing namespace std;\nconst int N=250000+10;\nint rd()\n{\n    int x=0,w=1;char ch=0;\n    while(ch<'0'||ch>'9') {if(ch=='-') w=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9') {x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}\n    return x*w;\n}\nint fpow(int a,int b,int mod){int an=1;while(b){if(b&1) an=1ll*an*a%mod;a=1ll*a*a%mod,b>>=1;}return an;}\nint ginv(int a,int mod){return fpow(a,mod-2,mod);}\nstruct node\n{\n\tLL x,y,z;\n\tbool operator < (const node &bb) const {return x!=bb.x?x<bb.x:(y!=bb.y?y<bb.y:z<bb.z);}\n\tbool operator == (const node &bb) const {return x==bb.x&&y==bb.y&&z==bb.z;}\n};\nmap<node,int> mp;\nint m1=998244853,b1=233,iv1=ginv(b1,m1),m2=1e9+7,b2=677,iv2=ginv(b2,m2),m3=993244853,b3=149,iv3=ginv(b3,m3);\nchar cc[N];\nint n,a,b,c;\n\nint main()\n{\n\tn=rd();\n\tscanf(\"%s\",cc+1);\n\ta=b=c=0;\n\tfor(int i=n;i;--i)\n\t{\n\t\tif(cc[i]=='+') a=(a+1)%m1,b=(b+1)%m2,c=(c+1)%m3;\n\t\telse if(cc[i]=='-') a=(a-1+m1)%m1,b=(b-1+m2)%m2,c=(c-1+m3)%m3;\n\t\telse if(cc[i]=='<') a=1ll*a*b1%m1,b=1ll*b*b2%m2,c=1ll*c*b3%m3;\n\t\telse if(cc[i]=='>') a=1ll*a*iv1%m1,b=1ll*b*iv2%m2,c=1ll*c*iv3%m3;\n\t}\n\tint na=0,nb=0,nc=0;\n\tint xa=1,xb=1,xc=1;\n\tLL ans=0;\n\tmp[(node){1ll*na*xa%m1,1ll*nb*xb%m2,1ll*nc*xc%m3}]=1;\n\tfor(int i=n;i;--i)\n\t{\n\t\tif(cc[i]=='+') na=(na+1)%m1,nb=(nb+1)%m2,nc=(nc+1)%m3;\n\t\telse if(cc[i]=='-') na=(na-1+m1)%m1,nb=(nb-1+m2)%m2,nc=(nc-1+m3)%m3;\n\t\telse if(cc[i]=='<')\n\t\t{\n\t\t\tna=1ll*na*b1%m1,nb=1ll*nb*b2%m2,nc=1ll*nc*b3%m3;\n\t\t\txa=1ll*xa*iv1%m1,xb=1ll*xb*iv2%m2,xc=1ll*xc*iv3%m3;\n\t\t}\n\t\telse if(cc[i]=='>')\n\t\t{\n\t\t\tna=1ll*na*iv1%m1,nb=1ll*nb*iv2%m2,nc=1ll*nc*iv3%m3;\n\t\t\txa=1ll*xa*b1%m1,xb=1ll*xb*b2%m2,xc=1ll*xc*b3%m3;\n\t\t}\n\t\tans+=mp[(node){1ll*(na-a+m1)*xa%m1,1ll*(nb-b+m2)*xb%m2,1ll*(nc-c+m3)*xc%m3}];\n\t\t++mp[(node){1ll*na*xa%m1,1ll*nb*xb%m2,1ll*nc*xc%m3}];\n\t}\n\tprintf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<map>\n#define ll long long\n#define MN 250005\nusing namespace std;\ninline ll in(){\n    ll x=0;bool f=0;char c;\n    for (;(c=getchar())<'0'||c>'9';f=c=='-');\n    for (x=c-'0';(c=getchar())>='0'&&c<='9';x=(x<<3)+(x<<1)+c-'0');\n    return f?-x:x;\n}\nmap <ll,int> mp;\nconst ll mod=4172596182543704117ll;\nconst ll Mod=233;\nll h[MN];\nll n,x,y,sum,bt,res,tmp;\nchar s[MN];\ninline ll qmul(ll x,ll y){\n\tll res=0;\n\twhile (y){\n\t\tif (y&1) res=(res+x)%mod;\n\t\tx=(x+x)%mod;y>>=1; \n\t}return res;\n}\ninline ll qpow(ll x,ll y){\n\tll res=1;\n\twhile (y){\n\t\tif (y&1) res=qmul(res,x)%mod;\n\t\tx=qmul(x,x)%mod;y>>=1;\n\t}return res;\n}\nint main()\n{\n\tn=in();scanf(\"%s\",s);\n\tbt=1;x=Mod;y=qpow(x,mod-2);\n\tfor (int i=1;i<=n;++i){\n\t\th[i]=h[i-1];\n\t\tif (s[i-1]=='+') h[i]=(h[i]+bt)%mod;\n\t\telse if (s[i-1]=='-') h[i]=(h[i]+mod-bt)%mod;\n\t\telse if (s[i-1]=='<') bt=qmul(bt,x);\n\t\telse if (s[i-1]=='>') bt=qmul(bt,y);\n\t\t++mp[h[i]];\n\t}bt=1;\n\tfor (int i=1;i<=n;++i){\n\t\ttmp=qmul(h[n],bt);tmp=(tmp+sum)%mod;\n\t\tres+=mp[tmp];\n\t\tif (s[i-1]=='+') sum=(sum+bt)%mod;\n\t\telse if (s[i-1]=='-') sum=(sum+mod-bt)%mod;\n\t\telse if (s[i-1]=='<') bt=qmul(bt,x);\n\t\telse if (s[i-1]=='>') bt=qmul(bt,y);\n\t\t--mp[h[i]];\n\t}printf(\"%lld\",res);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\n#define fr first\n#define sc second\n\nconst ll MOD[2] = {1000000007,1000000009};\n\nll modpow(ll x,ll k,int t){\n\tif(k==0)return 1;\n\tll ret=modpow(x,k/2,t);\n\tret*=ret; ret%=MOD[t];\n\tif(k%2==1){\n\t\tret*=x; ret%=MOD[t];\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint n;\n\tstring s;\n\tcin>>n>>s;\n\t\n\tsrand((unsigned)time(NULL));\n\tll r[2]={rand()+n,rand()+n};\n\t\n\tP hash[250010],h=P(0,0);\n\tll loc[250010],p=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(s[i]=='+'){\n\t\t\th.fr+=modpow(r[0],p+MOD[0]-1,0);\n\t\t\tif(h.fr>=MOD[0])h.fr-=MOD[0];\n\t\t\th.sc+=modpow(r[1],p+MOD[1]-1,1);\n\t\t\tif(h.sc>=MOD[1])h.sc-=MOD[1];\n\t\t}\n\t\telse if(s[i]=='-'){\n\t\t\th.fr+=MOD[0]-modpow(r[0],p+MOD[0]-1,0);\n\t\t\tif(h.fr>=MOD[0])h.fr-=MOD[0];\n\t\t\th.sc+=MOD[1]-modpow(r[1],p+MOD[1]-1,1);\n\t\t\tif(h.sc>=MOD[1])h.sc-=MOD[1];\n\t\t}\n\t\telse if(s[i]=='>'){\n\t\t\tp++;\n\t\t}\n\t\telse {\n\t\t\tp--;\n\t\t}\n\t\thash[i]=h;\n\t\tloc[i]=p;\n\t}\n\t\n\tll ret=0;\n\tmap<P,ll> cnt;\n\tfor(int i=n-1;i>=0;i--){\n\t\tP nex=hash[i];\n\t\tP dif=hash[n-1];\n\t\tdif.fr*=modpow(r[0],loc[i]+MOD[0]-1,0); dif.fr%=MOD[0];\n\t\tdif.sc*=modpow(r[1],loc[i]+MOD[1]-1,1); dif.sc%=MOD[1];\n\t\tnex.fr+=dif.fr; nex.fr%=MOD[0];\n\t\tnex.sc+=dif.sc; nex.sc%=MOD[1];\n\t\tret+=cnt[nex];\n\t\tcnt[hash[i]]++;\n\t}\n\tcout<<ret+cnt[hash[n-1]]<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author aajisaka\n */\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n#define SPEED ios_base::sync_with_stdio(false);cin.tie(nullptr)\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define all(v) v.begin(), v.end()\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing P = pair<ll, ll>;\n\nconstexpr long double PI = 3.14159265358979323846264338327950288L;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nconstexpr ll mod17 = 1e9+7;\nconstexpr ll mod19 = 1e9+9;\nconstexpr ll mod9 = 998244353;\nll mod = mod17;\n\n// Mod int libraries\ntemplate<typename T>\nT mod_pow(T a, ll x) {\n  T res = 1;\n  while(x > 0) {\n    if (x & 1) res *= a;\n    a *= a; x >>= 1;\n  }\n  return res;\n}\n\n// Mint32\nunordered_map<ll, ll> minvmap;\nll minv(ll a, ll m) {\n  auto k = a; auto p = minvmap[a]; if (p != 0) return p;\n  ll b = m, u = 1, v = 0;\n  while (b) { ll t = a/b; swap(a -= t*b, b); swap(u -= t*v, v); }\n  p = (u%m+m)%m; minvmap[k] = p; return p;\n}\n\nstruct mint {\n  ll x;\n  mint():x(0){}\n  mint(ll x):x((x%mod+mod)%mod){}\n  mint& fix() { x = (x%mod+mod)%mod; return *this;}\n  mint operator-() const { return mint(0) - *this;}\n  mint& operator+=(const mint& a){ if((x+=a.x)>=mod) x-=mod; return *this;}\n  mint& operator-=(const mint& a){ if((x+=mod-a.x)>=mod) x-=mod; return *this;}\n  mint& operator*=(const mint& a){ (x*=a.x)%=mod; return *this;}\n  mint& operator/=(const mint& a){ (x*=minv(a.x, mod))%=mod; return *this; }\n  mint operator+(const mint& a)const{ return mint(*this) += a;}\n  mint operator-(const mint& a)const{ return mint(*this) -= a;}\n  mint operator*(const mint& a)const{ return mint(*this) *= a;}\n  mint operator/(const mint& a)const{ return mint(*this) /= a;}\n  bool operator<(const mint& a)const{ return x < a.x;}\n  bool operator==(const mint& a)const{ return x == a.x;}\n};\n\n// Mint64\nstruct mint64 {\n    ull x;\n    static ull mod, inv, r2;\n    mint64(): x(0){}\n    mint64(ull x): x(init(x)) {}\n    static ull init(ull x) { return reduce(__uint128_t(x)*r2);}\n    static void set_mod(ull m) {\n      mod = inv = m;\n      for(int i=0; i<5; i++) inv *= 2 - inv*m;\n      r2 = -__uint128_t(m)%m;\n    }\n    static ull reduce(__uint128_t x) {\n      ull y = ull(x >> 64) - ull((__uint128_t(ull(x)*inv)*mod)>>64);\n      return ll(y) < 0 ? y+mod : y;\n    }\n    mint64& operator+=(mint64& a) { x+=a.x-mod; if(ll(x)<0) x+=mod; return *this; }\n    mint64 operator+(mint64& a) const{ return mint64(*this)+=a; }\n    mint64& operator*=(mint64& a) { x=reduce(__uint128_t(x)*a.x); return *this; }\n    mint64 operator*(mint64& a) const { return mint64(*this)*=a; }\n};\n\null mint64::mod, mint64::inv, mint64::r2;\n\n// Verify: https://yukicoder.me/submissions/472580\nstruct Miller {\n    const vector<ull> v = {2, 325, 9375, 28178, 450775, 9780504, 1795265022};\n    bool suspect(ull a, ull s, ull d, ull n) {\n      if (mint64::mod != n) mint64::set_mod(n);\n      mint64 one = 1, minusone = n-1, ma = a;\n      auto x = mod_pow(ma, d);\n      if (x.x == one.x) return true;\n      for(int r = 0; r < s; r++) {\n        if (x.x == minusone.x) return true;\n        x = x * x;\n      }\n      return false;\n    }\n\n    // check if n is prime\n    bool check(ull n) {\n      if (n < 2 || (n > 2 && n % 2 == 0)) return false;\n      ull d = n - 1;\n      ull s = 0;\n      while (!(d & 1)) {\n        d >>= 1;\n        s++;\n      }\n      for (auto a: v) {\n        if (a >= n) break;\n        if (!suspect(a, s, d, n)) return false;\n      }\n      return true;\n    }\n};\n\nclass combination {\n    // factorial\n    public: std::vector<mint> fact;\n    public: std::vector<mint> inv;\n\n    combination(int n) {\n      fact.resize(n + 1);\n      inv.resize(n + 1);\n      fact[0] = 1;\n      for (int i = 1; i <= n; i++) {\n        fact[i] = fact[i - 1] * i;\n      }\n      inv[n] = mint(1) / fact[n];\n      for (int i = n - 1; i >= 0; i--) {\n        inv[i] = inv[i + 1] * (i + 1);\n      }\n    }\n\n    // nCr\n    public: mint get(int n, int r) {\n      if (n < r || n < 0 || r < 0) return 0;\n      return fact[n]*inv[r]*inv[n-r];\n    }\n    // nPr\n    public: mint p(int n, int r) {\n      if (n < r || n < 0) return 0;\n      return fact[n]*inv[n-r];\n    }\n};\n\n\nclass FEatingSymbolsHard {\npublic:\n    void solve(istream& cin, ostream& cout) {\n      SPEED;\n      int n; cin >> n;\n      string s; cin >> s;\n      vector<vector<mint>> v(6, vector<mint>(500001));\n      v[0][0] = mod9;\n      v[1][0] = 9999991;\n      v[2][0] = 9999973;\n      v[3][0] = 9999971;\n      v[4][0] = 9999943;\n      v[5][0] = 9999937;\n\n\n      rep(i, 6) {\n        for(int j=1; j<=500000; j++) {\n          v[i][j] = v[i][j-1] * v[i][0];\n        }\n      }\n\n      int pos = 250000;\n      map<mint, ll> mp[6];\n\n      vector<mint> now(6);\n      vector<vector<pair<mint, int>>> vec(6, vector<pair<mint, int>>(n+1));\n\n      rep(k, 6) {\n        vec[k][0] = {0, pos};\n      }\n\n      rep(k, 6) {\n        rep(i, n) {\n          if (s[i] == '+') {\n            now[k] += v[k][pos];\n          } else if (s[i] == '-') {\n            now[k] -= v[k][pos];\n          } else if (s[i] == '>') {\n            pos++;\n          } else if (s[i] == '<') {\n            pos--;\n          }\n          vec[k][i + 1] = {now[k], pos};\n        }\n      }\n      rep(k, 6) {\n        now[k] /= v[k][250000];\n      }\n\n      ll ans = 0;\n      for(int i=n; i>=0; i--) {\n        vector<ll> cnt;\n        rep(k, 6) {\n          auto q = vec[k][i].first + now[k] * v[k][vec[k][i].second];\n          if (mp[k].find(q) == mp[k].end()) {\n            cnt.push_back(0);\n          } else {\n            cnt.push_back(mp[k][q]);\n          }\n        }\n        sort(all(cnt));\n        ans += cnt[3];\n        rep(k, 6) {\n          mp[k][vec[k][i].first]++;\n        }\n      }\n\n      cout << ans << endl;\n\n    }\n};\n\nsigned main() {\n  FEatingSymbolsHard solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "    #include \"bits/stdc++.h\"\n    using namespace std;\n     \n    #define MAX 500012\n     \n    int n;\n    char buf[MAX];\n     \n     \n    string s;\n     \n     \n    //#define MOD1 1000000007\n    //#define MOD2 1000000009\n     \n    valarray<long long int> MOD1;\n    valarray<long long int> MOD2;\n    vector<valarray<long long int> > p2;\n    vector<valarray<long long int> > vv;\n    vector<int> ps;\n    map<pair<long long int,long long int>, int> mp;\n    long long int ppow(long long int i, long long int j, long long int MOD) {\n    \tlong long int ret = 1;\n    \twhile (j) {\n    \t\tif (j & 1LL)ret *= i;\n    \t\tif (ret >= MOD)ret %= MOD;\n    \t\tj >>= 1LL;\n    \t}\n    \treturn ret;\n    }\n     \n    valarray<long long int> calc(int dif) {\n    \tvalarray<long long int> ret;\n    \tret.resize(2, 0);\n    \tfor (int j = 0; j < 2; j++) {\n    \t\tif (dif < 0) {\n    \t\t\tret[j]=ppow(ppow(MOD1[j], abs(dif),MOD2[j]), MOD2[j] - 2,MOD2[j]);\n    \t\t}\n    \t\telse {\n    \t\t\tret[j] = ppow(MOD1[j], abs(dif), MOD2[j]);\n    \t\t}\n    \t}\n    \treturn ret;\n    }\n     \n    int main() {\n    \tMOD1.resize(2);\n    \tMOD2.resize(2);\n    \tp2.push_back(valarray<long long int>());\n    \tp2.back().resize(2);\n    \tp2.back()[0] = p2.back()[1] = 1;\n    \tMOD2[0] = 1000000007;\n    \tMOD1[0] = 998244353;\n    \tMOD1[1] = 555522277;\n    \tMOD2[1] = 895612782;\n    \tp2[0] %= MOD2;\n    \tfor (int i = 1; i < MAX; i++) {\n    \t\tp2.push_back(p2.back());\n    \t\tp2[i] *= MOD1;\n    \t\tp2[i] %= MOD2;\n    \t}\n    \tcin >> n;\n    \tscanf(\"%s\", buf);\n    \ts = buf;\n    \tint pos = MAX/2;\n    \tvalarray<long long int> hs;\n    \ths.resize(2);\n    \ths[0] = hs[1] = 0;\n    \tvv.push_back(hs);\n    \tps.push_back(pos);\n    \tfor (int i = 0; i < s.size(); i++) {\n    \t\tif (s[i] == '<') {\n    \t\t\tpos--;\n    \t\t}\n    \t\tif (s[i] == '>') {\n    \t\t\tpos++;\n    \t\t}\n    \t\tif (s[i] == '+') {\n    \t\t\ths += p2[pos];\n    \t\t}\n    \t\tif (s[i] == '-') {\n    \t\t\ths -= p2[pos];\n    \t\t\ths += MOD2;\n    \t\t}\n    \t\ths %= MOD2;\n    \t\tvv.push_back(hs);\n    \t\tps.push_back(pos);\n    \t}\n    \tlong long int way = 0;\n    \tfor (int i = vv.size() - 1; i >= 0; i--) {\n    \t\tvalarray<long long int> want = vv[i] + vv.back()*calc(-MAX/2+ps[i]);\n    \t\twant = want%MOD2;\n    \t\tway += mp[make_pair(want[0], want[1])];\n    \t\t//cerr << \"dbg \" << way << endl;\n    \t\tmp[make_pair(vv[i][0],vv[i][1])]++;\n    \t}\n    \tprintf(\"%lld\\n\", way);\n    \treturn 0;\n    }"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define all(x) x.begin(), x.end()\nusing namespace std;\nusing ll = long long;\nconst int maxn = 1<<20, mod = 119<<23|1;\nconst int B = 1000007;\nint n, pw[maxn], F[maxn], ps = 0, ans = 0;\nstring s;\nmap<int, int> cnt;\nvoid add(int &a, int b) {\n\ta = a+b>=mod?a+b-mod:a+b;\n}\nll bp(ll a, ll p) {\n\tint r = 1;\n\twhile(p) {\n\t\tif(p&1) r = r*a%mod;\n\t\ta = a*a%mod, p>>=1;\n\t}\n\treturn r;\n} \nsigned main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> n >> s;\n\tpw[0] = 1;\n\tfor(int i = 1; i < maxn; i++) pw[i] = pw[i-1]*1ll*B%mod;\n\tcnt[0]++;\n\tint cur = 0;\n\tfor(int i = 0; i < n; i++) {\n\t\tif(s[i] == '>') ps++;\n\t\tif(s[i] == '<') ps--;\n\t\tif(s[i] == '+') add(cur, pw[(maxn/2) + ps]);\n\t\tif(s[i] == '-') add(cur, mod-pw[(maxn/2) + ps]);\n\t\tF[i+1] = cur;\n\t\tcnt[cur]++;\n\t}\n\tps = 0;\n\tfor(int ccur = 0, ps = 0, i = 0; i <= n; i++) {\n\t\tcnt[F[i]]--;\n\t\tans += cnt[(ccur + bp(B, mod-1+ps)*1ll*cur)%mod];\n\t\tif(i == n) continue;\n\t\tif(s[i] == '>') ps++;\n\t\tif(s[i] == '<') ps--;\n\t\tif(s[i] == '+') add(ccur, pw[(maxn/2) + ps]);\n\t\tif(s[i] == '-') add(ccur, mod-pw[(maxn/2) + ps]);\n\t}\n\tcout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "//ΔARC099F\n#include<iostream>\n#include<cstdio>\n#include<fstream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<bitset>\n#include<cmath>\n#include<cstring>\n#include<cstdlib>\nusing namespace std;\ntypedef long long LL;\ntypedef double DB;\nconst int N = 266666;\nconst int B = 2333;\nconst int MO = 1e9+21;\nint fpow(int x,int y=MO-2){\n\tif(!y)\n\t\treturn 1;\n\tLL z=fpow(x,y>>1);\n\tz=z*z%MO;\n\tif(y&1)\n\t\tz=z*x%MO;\n\treturn z;\n}\nint invB=fpow(B);\nchar ch[N];\nint n,a[N],f[N],g[N];\nmap<int,int> M;\nint main()\n{\n\tint i,x,y;\n\tLL ans=0;\n\tcin>>n;\n\tscanf(\"%s\",ch+1);\n\tfor(i=1;i<=n;i=i+1){\n\t\tif(ch[i]=='-')\n\t\t\ta[i]=0;\n\t\tif(ch[i]=='+')\n\t\t\ta[i]=1;\n\t\tif(ch[i]=='<')\n\t\t\ta[i]=2;\n\t\tif(ch[i]=='>')\n\t\t\ta[i]=3;\n\t}\n\tx=0;\n\tfor(i=n;i;i=i-1){\n\t\tif(a[i]==0)\n\t\t\tx=(x-1+MO)%MO;\n\t\tif(a[i]==1)\n\t\t\tx=(x+1)%MO;\n\t\tif(a[i]==2)\n\t\t\tx=(LL)x*invB%MO;\n\t\tif(a[i]==3)\n\t\t\tx=(LL)x*B%MO;\n\t\tf[i]=x;\n\t}\n\tx=0,y=1;\n\tM[0]++;\n\tfor(i=n;i;i=i-1){\n\t\tif(a[i]==0)\n\t\t\tx=(x+y)%MO;\n\t\tif(a[i]==1)\n\t\t\tx=(x-y+MO)%MO;\n\t\tif(a[i]==2)\n\t\t\ty=(LL)y*B%MO;\n\t\tif(a[i]==3)\n\t\t\ty=(LL)y*invB%MO;\n\t\tg[i]=x;\n\t\tM[x]++;\n\t}\n\tfor(i=1;i<=n;i=i+1){\n\t\tM[g[i]]--;\n\t\tx=(f[1]-f[i]+MO)%MO;\n\t\tx=(LL)x*y%MO;\n\t\tans+=M[x];\n\t\tif(a[i]==2)\n\t\t\ty=(LL)y*invB%MO;\n\t\tif(a[i]==3)\n\t\t\ty=(LL)y*B%MO;\n\t}\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n    _____\n  .'     '.\n /  0   0  \\\n|     ^     |\n|  \\     /  |\n \\  '---'  /\n  '._____.'\n*/\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\nstruct chash\n{\n\tint operator()(int x) const\n\t{\n\t\tx ^= (x >> 20) ^ (x >> 12);\n\t\treturn x ^ (x >> 7) ^ (x >> 4);\n\t}\n};\n\ntemplate<typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename U> using hashtable = gp_hash_table<T, U, chash>;\nrandom_device(rd);\nmt19937 rng(rd());\n\ntemplate<class T>\nvoid readi(T &x)\n{\n\tT input = 0;\n\tbool negative = false;\n\tchar c = ' ';\n\twhile (c < '-')\n\t{\n\t\tc = getchar();\n\t}\n\tif (c == '-')\n\t{\n\t\tnegative = true;\n\t\tc = getchar();\n\t}\n\twhile (c >= '0')\n\t{\n\t\tinput = input * 10 + (c - '0');\n\t\tc = getchar();\n\t}\n\tif (negative)\n\t{\n\t\tinput = -input;\n\t}\n\tx = input;\n}\ntemplate<class T>\nvoid printi(T output)\n{\n\tif (output == 0)\n\t{\n\t\tputchar('0');\n\t\treturn;\n\t}\n\tif (output < 0)\n\t{\n\t\tputchar('-');\n\t\toutput = -output;\n\t}\n\tint aout[20];\n\tint ilen = 0;\n\twhile(output)\n\t{\n\t\taout[ilen] = ((output % 10));\n\t\toutput /= 10;\n\t\tilen++;\n\t}\n\tfor (int i = ilen - 1; i >= 0; i--)\n\t{\n\t\tputchar(aout[i] + '0');\n\t}\n\treturn;\n}\ntemplate<class T>\nvoid ckmin(T &a, T b)\n{\n\ta = min(a, b);\n}\ntemplate<class T>\nvoid ckmax(T &a, T b)\n{\n\ta = max(a, b);\n}\ntemplate<class T, class U>\nT nmod(T &x, U mod)\n{\n\tif (x >= mod) x -= mod;\n}\ntemplate<class T>\nT randomize(T mod)\n{\n\treturn (uniform_int_distribution<T>(0, mod - 1))(rng);\n}\n\n#define y0 ___y0\n#define y1 ___y1\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fi first\n#define se second\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\nconst long double PI = 4.0 * atan(1.0);\nconst long double EPS = 1e-10;\n\n#define MAGIC 347\n#define SINF 10007\n#define CO 1000007\n#define INF 1000000007\n#define BIG 1000000931\n#define LARGE 1696969696967ll\n#define GIANT 2564008813937411ll\n#define LLINF 2696969696969696969ll\n#define MAXN 500013\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ld, ld> pdd;\n\nint N;\nint arr[MAXN];\npll S;\nlong long ans;\nmap<pll, int> freq, need;\n\nll expo(ll a, ll e, ll mod)\n{\n\tif (e == 0)\n\t{\n\t\treturn 1;\n\t}\n\tll was = expo(a, e / 2, mod);\n\tif (e % 2)\n\t{\n\t\treturn was * was % mod * a % mod;\n\t}\n\treturn was * was % mod;\n}\nll modinv(ll a, ll e)\n{\n\treturn expo(a, e - 2, e);\n}\npll INV = {modinv(CO, INF), modinv(CO, BIG)};\nvoid solve(int L, int R)\n{\n\tif (L == R)\n\t{\n\t\treturn;\n\t}\n\tfreq.clear(); need.clear();\n\tint mid = (L + R) >> 1;\n\t//start from L...mid, end at mid + 1....R\n\tpair<pll, pll> trans = MP(MP(1, 0), MP(1, 0));\n\tfor (int i = mid + 1; i <= R; i++)\n\t{\n\t\tif (arr[i] == 0)\n\t\t{\n\t\t\ttrans.fi.fi *= INV.fi;\n\t\t\ttrans.fi.se *= INV.fi;\n\t\t\ttrans.se.fi *= INV.se;\n\t\t\ttrans.se.se *= INV.se;\n\t\t}\n\t\tif (arr[i] == 1)\n\t\t{\n\t\t\ttrans.fi.fi *= CO;\n\t\t\ttrans.fi.se *= CO;\n\t\t\ttrans.se.fi *= CO;\n\t\t\ttrans.se.se *= CO;\n\t\t}\n\t\tif (arr[i] == 2)\n\t\t{\n\t\t\ttrans.fi.se++;\n\t\t\ttrans.se.se++;\n\t\t}\n\t\tif (arr[i] == 3)\n\t\t{\n\t\t\ttrans.fi.se--; trans.fi.se += INF;\n\t\t\ttrans.se.se--; trans.se.se += BIG;\n\t\t}\n\t\ttrans.fi.fi %= INF; trans.fi.se %= INF;\n\t\ttrans.se.fi %= BIG; trans.se.se %= BIG;\n\t\t// cerr << \"from \" << mid + 1 << \" to \" << i << \" is \" << trans.fi << \"x + \" << trans.se << endl;\n\t\tpll dif = {S.fi - trans.fi.se + INF, S.se - trans.se.se + BIG};\n\t\tnmod(dif.fi, INF); nmod(dif.se, BIG);\n\t\tdif.fi *= modinv(trans.fi.fi, INF);\n\t\tdif.se *= modinv(trans.se.fi, BIG);\n\t\tdif.fi %= INF; dif.se %= BIG;\n\t\tneed[dif]++;\n\t}\n\ttrans = MP(MP(1, 0), MP(1, 0));\n\tfor (int i = mid; i >= L; i--)\n\t{\n\t\tif (arr[i] == 0)\n\t\t{\n\t\t\ttrans.fi.fi *= INV.fi;\n\t\t\ttrans.se.fi *= INV.se;\n\t\t}\n\t\tif (arr[i] == 1)\n\t\t{\n\t\t\ttrans.fi.fi *= CO;\n\t\t\ttrans.se.fi *= CO;\n\t\t}\n\t\tif (arr[i] == 2)\n\t\t{\n\t\t\t//(x+1)*a+b = a * x + a + b\n\t\t\ttrans.fi.se += trans.fi.fi;\n\t\t\ttrans.se.se += trans.se.fi;\n\t\t}\n\t\tif (arr[i] == 3)\n\t\t{\n\t\t\t//(x - 1)*a + b = a*x - a + b\n\t\t\ttrans.fi.se -= trans.fi.fi;\n\t\t\ttrans.fi.se += INF;\n\t\t\ttrans.se.se -= trans.se.fi;\n\t\t\ttrans.se.se += BIG;\n\t\t}\n\t\ttrans.fi.fi %= INF; trans.fi.se %= INF;\n\t\ttrans.se.fi %= BIG; trans.se.se %= BIG;\n\t\tfreq[{trans.fi.se, trans.se.se}]++;\n\t}\n\tfor (auto p : need)\n\t{\n\t\tpll x = p.fi; int c = p.se;\n\t\tans += 1ll * c * freq[x];\n\t}\n\tsolve(L, mid);\n\tsolve(mid + 1, R);\n}\n\nint32_t main()\n{\n\tios_base::sync_with_stdio(0);\n\t// cout << fixed << setprecision(10);\n\t// cerr << fixed << setprecision(10);\n\t// freopen (\"file.in\", \"r\", stdin);\n\t// freopen (\"file.out\", \"w\", stdout);\n\tcin >> N;\n\tstring temps;\n\tcin >> temps;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (temps[i] == '<')\n\t\t{\n\t\t\tarr[i] = 0;\n\t\t}\n\t\tif (temps[i] == '>')\n\t\t{\n\t\t\tarr[i] = 1;\n\t\t}\n\t\tif (temps[i] == '+')\n\t\t{\n\t\t\tarr[i] = 2;\n\t\t}\n\t\tif (temps[i] == '-')\n\t\t{\n\t\t\tarr[i] = 3;\n\t\t}\n\t}\n\treverse(arr, arr + N);\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (arr[i] == 0)\n\t\t{\n\t\t\tS.fi *= INV.fi; S.fi %= INF;\n\t\t\tS.se *= INV.se; S.se %= BIG;\n\t\t\t// cerr << \"times \" << INV << endl;\n\t\t}\n\t\tif (arr[i] == 1)\n\t\t{\n\t\t\tS.fi *= CO; S.fi %= INF;\n\t\t\tS.se *= CO; S.se %= BIG;\n\t\t\t// cerr << \"times \" << CO << endl;\n\t\t}\n\t\tif (arr[i] == 2)\n\t\t{\n\t\t\tS.fi++; nmod(S.fi, INF);\n\t\t\tS.se++; nmod(S.se, BIG);\n\t\t\t// cerr << \"add 1\\n\";\n\t\t}\n\t\tif (arr[i] == 3)\n\t\t{\n\t\t\tS.fi--; S.fi += INF; nmod(S.fi, INF);\n\t\t\tS.se--; S.se += BIG; nmod(S.se, BIG);\n\t\t\t// cerr << \"add -1\\n\";\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (arr[i] == 0)\n\t\t{\n\t\t\tif (S == MP(0ll, 0ll)) ans++;\n\t\t}\n\t\tif (arr[i] == 1)\n\t\t{\n\t\t\tif (S == MP(0ll, 0ll)) ans++;\n\t\t}\n\t\tif (arr[i] == 2)\n\t\t{\n\t\t\tif (S == MP(1ll, 1ll)) ans++;\n\t\t}\n\t\tif (arr[i] == 3)\n\t\t{\n\t\t\tif (S == MP((ll) INF - 1, (ll) BIG - 1)) ans++;\n\t\t}\n\t}\n\tsolve(0, N - 1);\n\tcout << ans << '\\n';\n\t//when u <, the # divides by co\n\t//when u >, the # mults by co\n\t//when u +, u add the #\n\t//when u -, u subtract the #\n\t// cerr << \"time elapsed = \" << (clock() / (CLOCKS_PER_SEC / 1000)) << \" ms\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int M = 6;\nstruct hs {\n\tint v[M];\n\ths(){\n\t\tmemset(v, 0, sizeof(v));\n\t}\n};\nhs mods;\nint mds[] = {\n\t961'748'927,\n\t961'820'429,\n\t1'000'000'007,\n\t1'000'000'009,\n\t1'003'162'753,\n\t1'023'893'771\n};\nhs create(int x){\n\ths r;\n\tfor(int i = 0; i < M; i++){\n\t\tr.v[i] = x % mods.v[i];\n\t\tif(r.v[i] < 0) r.v[i] += mods.v[i];\n\t}\n\treturn r;\n}\nhs operator + (hs a, hs b){\n\ths r;\n\tfor(int i = 0; i < M; i++){\n\t\tr.v[i] = a.v[i] + b.v[i];\n\t\tif(r.v[i] >= mods.v[i]) r.v[i] -= mods.v[i];\n\t}\n\treturn r;\n}\nhs operator - (hs a, hs b){\n\ths r;\n\tfor(int i = 0; i < M; i++){\n\t\tr.v[i] = a.v[i] - b.v[i];\n\t\tif(r.v[i] < 0) r.v[i] += mods.v[i];\n\t}\n\treturn r;\n}\nhs operator * (hs a, hs b){\n\ths r;\n\tfor(int i = 0; i < M; i++){\n\t\tr.v[i] = 1ll * a.v[i] * b.v[i] % mods.v[i];\n\t}\n\treturn r;\n}\nbool operator < (hs a, hs b){\n\tfor(int i = 0; i < M; i++) if(a.v[i] != b.v[i]) return a.v[i] < b.v[i];\n\treturn false;\n}\nint pwr(int a, int b, int mod){\n\tint r = 1;\n\tfor(; b; b>>=1, a = 1ll * a * a % mod) if(b&1) r = 1ll * r * a % mod;\n\treturn r;\n}\nbool is_prime(int x){\n\tfor(int i = 2; i * i <= x; i++) if(x % i == 0) return false;\n\treturn true;\n}\nconst int maxn = 300300;\nusing Poly = pair<hs, hs>;\nhs eval(Poly f, hs x){\n\treturn f.first + (f.second * x);\n}\nPoly poly[maxn];\nint main(){\n\tsrand(time(NULL));\n\tmemcpy(mods.v, mds, sizeof(int) * M);\n\ths x, mx, minus = create(-1), plus = create(1);\n\tint xx;\n\tdo {\n\t\txx = 900'999'999 + 50;\n\t\txx += rand() % 1000;\n\t} while(!is_prime(xx));\n\tx = create(xx);\n\tfor(int i = 0; i < M; i++){\n\t\tmx.v[i] = pwr(x.v[i], mods.v[i] - 2, mods.v[i]);\t\n\t\tassert((1ll * mx.v[i] * x.v[i] % mods.v[i]) == 1);\n\t}\n\tint n; cin >> n;\n\tstring s; cin >> s;\n\tpoly[n] = {create(0), create(1)};\n\tfor(int i = n - 1; i >= 0; i--){\n\t\tpoly[i] = poly[i + 1];\n\t\tif(s[i] == '+'){\n\t\t\tpoly[i].first = poly[i].first - poly[i].second;\n\t\t} else if(s[i] == '-'){\n\t\t\tpoly[i].first = poly[i].first + poly[i].second;\n\t\t} else {\n\t\t\ths mul = x;\n\t\t\tif(s[i] == '<')\n\t\t\t\tmul = mx;\n\t\t\tpoly[i].second = poly[i].second * mul;\n\t\t}\n\t}\n\tPoly norm = poly[n];\n\tfor(int i = 0; i < n; i++){\n\t\tif(s[i] == '+'){\n\t\t\tnorm.first = norm.first + norm.second;\n\t\t} else if(s[i] == '-'){\n\t\t\tnorm.first = norm.first - norm.second;\n\t\t} else if(s[i] == '<'){\n\t\t\tnorm.second = norm.second * x;\n\t\t} else {\n\t\t\tnorm.second = norm.second * mx;\n\t\t}\n\t}\n\ths tot = norm.first;\n\tmap<hs, int> cnt;\n\tcnt[poly[n].first]++;\n\tlong long ans = 0;\n\tfor(int i = n - 1; i >= 0; i--){\n\t\tans += cnt[eval(poly[i], tot)];\n\t\tcnt[poly[i].first]++;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,ans;\nunsigned long long x1=1,x2=233,xx=233,a[250010],b[250010],t[250010];\nstring st;\nmap<unsigned long long,int>k;\nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<=63;i++)\n\t{\n\t\tx1=x1*x2;\n\t\tx2=x2*x2;\n\t}\n\tcin>>st;\n\tst=' '+st;\n\tb[0]=1;\n\tfor(int i=1;i<st.size();i++)\n\t{\n\t\ta[i]=a[i-1];\n\t\tb[i]=b[i-1];\n\t\tif(st[i]=='+')a[i]=a[i]+b[i];\n\t\tif(st[i]=='-')a[i]=a[i]-b[i];\n\t\tif(st[i]=='<')b[i]=b[i]*x1;\n\t\tif(st[i]=='>')b[i]=b[i]*xx;\n\t\tk[a[i]]++;\n\t} \n\tfor(int i=1;i<st.size();i++)\n\t{\n\t\tans+=k[a[n]*b[i-1]+a[i-1]];\n\t\tk[a[i]]--;\n\t}\n\tcout<<ans;\n\treturn 0; \n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,ans;\nunsigned long long x1=1,x2=233,xx=233,a[250010],b[250010],t[250010];\nstring st;\nmap<unsigned long long,int>k;\nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<=63;i++)\n\t{\n\t\tx1=x1*x2;\n\t\tx2=x2*x2;\n\t}\n\tcin>>st;\n\tb[0]=1;\n\tfor(int i=0;i<st.size();i++)\n\t{\n\t\tif(i>0)a[i]=a[i-1];\n\t\tif(i>0)b[i]=b[i-1];\n\t\tif(st[i]=='+')a[i]=a[i]+b[i];\n\t\tif(st[i]=='-')a[i]=a[i]-b[i];\n\t\tif(st[i]=='<')a[i]=a[i]*x1;\n\t\tif(st[i]=='>')a[i]=a[i]*x2;\n\t\tk[a[i]]++;\n\t} \n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tans+=k[a[n]*b[i-1]+a[i-1]];\n\t\tk[a[i]]--;\n\t}\n\tcout<<ans;\n\treturn 0; \n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int N = 5e5 + 10;\nint mod1=998244353,base1=19260817,inv1;\nint mod2=353448299,base2=20000003,inv2;\nint s[N], pw1[N], pw2[N], rev1[N], rev2[N];\n\nint q_pow(int x, int y, int mod) {\n  int ans = 1;\n  for(; y; y >>= 1) {\n    if(y & 1) ans = 1ll * ans * x % mod;\n    x = 1ll * x * x % mod;\n  }\n  return ans;\n}\n\nint h1[N], h2[N];\ntypedef pair<int, int> P;\nmap<P, int> mp;\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  inv1 = q_pow(base1, mod1 - 2, mod1);\n  inv2 = q_pow(base2, mod2 - 2, mod2);\n  pw1[0] = pw2[0] = rev1[0] = rev2[0] = 1;\n  for(int i = 1; i <= (n << 1); ++i) {\n    pw1[i] = 1ll * pw1[i - 1] * base1 % mod1;\n    pw2[i] = 1ll * pw2[i - 1] * base2 % mod2;\n    rev1[i] = 1ll * rev1[i - 1] * inv1 % mod1;\n    rev2[i] = 1ll * rev2[i - 1] * inv2 % mod2;\n  }\n  s[0] = n;\n  for(int i = 1; i <= n; ++i) {\n    char ch; cin >> ch;\n    if(ch == '+') {\n      s[i] = s[i - 1];\n      h1[i] = (h1[i - 1] + pw1[s[i]]) % mod1;\n      h2[i] = (h2[i - 1] + pw2[s[i]]) % mod2;\n    } else if(ch == '-') {\n      s[i] = s[i - 1];\n      h1[i] = (h1[i - 1] - pw1[s[i]] + mod1) % mod1;\n      h2[i] = (h2[i - 1] - pw2[s[i]] + mod2) % mod2;\n    } else if(ch == '>') {\n      s[i] = s[i - 1] + 1;\n      h1[i] = h1[i - 1];\n      h2[i] = h2[i - 1];\n    } else {\n      s[i] = s[i - 1] - 1;\n      h1[i] = h1[i - 1];\n      h2[i] = h2[i - 1];\n    }\n    mp[P(h1[i], h2[i])]++;\n  }\n  ll ans = 0;\n  for(int i = 1; i <= n; ++i) {\n    int pos = h1[n], tmp = h2[n];\n    int sit = s[i - 1] - n;\n    if(sit >= 0) pos = 1ll * pos * pw1[sit] % mod1, tmp = 1ll * tmp * pw2[sit] % mod2;\n    else pos = 1ll * pos * rev1[-sit] % mod1, tmp = 1ll * tmp * rev2[-sit] % mod2;\n    pos = (pos + h1[i - 1]) % mod1;\n    tmp = (tmp + h2[i - 1]) % mod2;\n    ans += mp[P(pos, tmp)];\n    mp[P(h1[i], h2[i])]--;\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int N=250005,mu=1000000021,P=2333329;\nvoid reduce(int &x){ x+=x>>31&mu; } \nint n,f[N],g[N],pm[N],mx;\nlong long ans;\nchar s[N];\nstd::map<int,int> mp;\nint main(){\n\tscanf(\"%d%s\",&n,s);\n\tint p=0;\n\tfor (int i=0;i<n;i++){\n\t\tif (s[i]=='<') p--;\n\t\t\telse if (s[i]=='>') p++;\n\t\tmx=std::min(mx,p);\n\t}\n\tp=abs(mx);\n\tpm[0]=1;\n\tfor (int i=1;i<=n+p;i++) pm[i]=1ll*pm[i-1]*P%mu;\n\tfor (int i=0;i<n;i++){\n\t\tg[i]=p;\n\t\tif (i) f[i]=f[i-1];\n\t\tswitch (s[i]){\n\t\t\tcase '+':reduce(f[i]+=pm[p]-mu);break;\n\t\t\tcase '-':reduce(f[i]-=pm[p]);break;\n\t\t\tcase '<':p--;break;\n\t\t\tdefault:p++;\n\t\t} \n\t}\n\tint t=f[n-1];\n\tmp[t]=1;\n\tfor (int i=0;i<n;i++){\n\t\tans+=mp[f[i]];\n\t\tmp[(t*1ll*pm[g[i+1]]+f[i])%mu]++;\n\t} \n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 500005;\nconst int base1 = 12345678, ibase1 = 749734780, mod1 = 998244353;\nconst int base2 = 90123456, ibase2 = 314509124, mod2 = 1000000007;\ntypedef long long LL;\ntypedef std::pair<int, int> hashing;\n#define x first\n#define y second\n\nconst hashing base(base1, base2);\nconst hashing ibase(ibase1, ibase2);\n\nint add(int x, int y, int mod) { x += y - mod; return x + (x >> 31 & mod); }\nint minus(int x, int y, int mod) { x -= y; return x + (x >> 31 & mod); }\n\nhashing operator * (const hashing &lhs, const hashing &rhs) {\n\treturn {(LL) lhs.x * rhs.x % mod1, (LL) lhs.y * rhs.y % mod2};\n}\nhashing operator + (const hashing &lhs, const hashing &rhs) {\n\treturn {add(lhs.x, rhs.x, mod1), add(lhs.y, rhs.y, mod2)};\n}\nhashing operator - (const hashing &lhs, const hashing &rhs) {\n\treturn {minus(lhs.x, rhs.x, mod1), minus(lhs.y, rhs.y, mod2)};\n}\nhashing rshift(hashing h) { return h * base; }\nhashing lshift(hashing h) { return h * ibase; }\n\nhashing pow_[N], *power = pow_ + 250000, target, backup, prefix[N];\nstd::map<hashing, int> map;\n\nint n;\nstd::string s;\nLL ans = 0;\n\ntypedef std::pair<int, hashing> tag; // X <- base^x * X + y\n\ntag inv(tag t) { return {-t.x, hashing(0, 0) - power[-t.x] * t.y}; }\nhashing apply(tag t, hashing h) { return h * power[t.x] + t.y; }\n\ntag alltag;\n\nint main() {\n\tstd::ios::sync_with_stdio(0), std::cin.tie(0);\n\tstd::cin >> n >> s, power[0] = hashing(1, 1);\n\tfor (int i = 1; i <= n; ++i) power[i] = power[i - 1] * base;\n\tfor (int i = 1; i <= n; ++i) power[-i] = power[1 - i] * ibase;\n\tfor (int i = 0, p = 0; i < n; ++i) {\n\t\tif (s[i] & 1)\n\t\t\ttarget = s[i] == 43 ? target + power[p] : target - power[p];\n\t\telse\n\t\t\tp += s[i] == 60 ? -1 : 1;\n\t}\n\tfor (int i = n - 1; ~i; --i) {\n\t\t++map[apply(inv(alltag), hashing(0, 0))];\n\t\tif (s[i] & 1) alltag.y = alltag.y + (s[i] == 43 ? hashing(1, 1) : hashing(mod1 - 1, mod2 - 1));\n\t\telse alltag.y = alltag.y * (s[i] == 60 ? ibase : base), alltag.x += s[i] == 60 ? -1 : 1;\n\t\tans += map[apply(inv(alltag), target)];\n\t}\n\tstd::cout << ans << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MN 250000\n#define mod 1004535809\n#define mod2 1000000007\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nchar s[MN+5];\nmap<int,int> mp,mp2;long long ans;\nint n,pw[MN*2+5],invpw[MN*2+5],pw2[MN*2+5],invpw2[MN*2+5];\nint Ha[MN+5],pos[MN+5],ha[MN+5];\ninline int PW(int x){return x>=0?pw[x]:invpw[-x];}\ninline int PW2(int x){return x>=0?pw2[x]:invpw2[-x];}\nint main()\n{\n\tn=read();scanf(\"%s\",s+1);pw[0]=invpw[0]=pw2[0]=invpw2[0]=1;\n\tfor(int i=1;i<=n*2;++i) \n\t\tpw[i]=37LL*pw[i-1]%mod,invpw[i]=352945014LL*invpw[i-1]%mod,\n\t\tpw2[i]=37LL*pw2[i-1]%mod2,invpw[i]=621621626LL*invpw2[i-1]%mod2;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tif(s[i]=='<'||s[i]=='>') \n\t\t\tpos[i]=pos[i-1]+(s[i]=='<'?-1:1),\n\t\t\tha[i]=ha[i-1],Ha[i]=Ha[i-1];\n\t\telse pos[i]=pos[i-1],\n\t\t\tha[i]=(ha[i-1]+1LL*(s[i]=='+'?1:mod-1)*pw[pos[i]+n])%mod,\n\t\t\tHa[i]=(Ha[i-1]+1LL*(s[i]=='+'?1:mod2-1)*pw2[pos[i]+n])%mod2;\n\t}\n\tfor(int i=n;i;--i)\n\t{\n\t\t++mp[(ha[n]-ha[i]+mod)%mod];\n\t\t++mp2[(Ha[n]-Ha[i]+mod2)%mod2];\n\t\tans+=min(mp[(1LL*ha[n]*(mod+1-PW(pos[i-1]))+mod-ha[i-1])%mod],\n\t\t\t     mp2[(1LL*Ha[n]*(mod2+1-PW2(pos[i-1]))+mod2-Ha[i-1])%mod2]);\n\t}\n\tcout<<ans;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>pii;\nconst int MAXN=3e5+5;\nconst int BASE=3137;\nconst int MOD1=1e9+7;\nconst int MOD2=1e9+9;\nint N;\nchar s[MAXN];\npii pref[MAXN],pot[MAXN];\nmap<pii,int>cnt;\n\ninline int add(int x,int y,int mod){\n\tx+=y;\n\tif(x>=mod)\n\t\tx-=mod;\n\telse if(x<0)\n\t\tx+=mod;\n\treturn x;\n}\n\ninline int mul(int x,int y,int mod){\n\treturn (ll)x*y%mod;\n}\n\nint power(int x,int y,int mod){\n\tint res=1;\n\tfor(;y;y/=2){\n\t\tif(y%2)res=mul(res,x,mod);\n\t\tx=mul(x,x,mod);\n\t}\n\treturn res;\n}\n\npii operator +(const pii&l,const pii&r){\n\tint a=l.first,b=l.second;\n\tint c=r.first,d=r.second;\n\treturn{add(a,c,MOD1),add(b,d,MOD2)};\n}\n\npii operator*(const pii &l,const pii &r){\n\tint a=l.first,b=l.second;\n\tint c=r.first,d=r.second;\n\treturn{mul(a,c,MOD1),mul(b,d,MOD2)};\n}\n\nll solve(){\n\tint inv1=power(BASE,MOD1-2,MOD1);\n\tint inv2=power(BASE,MOD2-2,MOD2);\n\tpot[0]={1,1};\n\tfor(int i=1;i<=N;++i){\n\t\tpot[i]=pot[i-1];\n\t\tpref[i]=pref[i-1];\n\t\tif(s[i]=='>')\n\t\t\tpot[i]=pot[i]*pii(BASE,BASE);\n\t\telse if(s[i]=='<')\n\t\t\tpot[i]=pot[i]*pii(inv1,inv2);\n\t\telse if(s[i]=='+')\n\t\t\tpref[i]=pref[i]+pot[i];\n\t\telse{\n\t\t\tint a=pot[i].first;\n\t\t\tint b=pot[i].second;\n\t\t\tpref[i]=pref[i]+pii(-a,-b);\n\t\t}\n\t}\n\tll ans=0;\n\tfor(int i=N;i;--i){\n\t\t++cnt[pref[i]];\n\t\tpii a=pref[N];\n\t\tans+=cnt[(a*pot[i-1])+pref[i-1]];\n\t}\n\treturn ans;\n}\n\nint main(){\n\tscanf(\"%d%s\",&N,s+1);\n\tprintf(\"%lld\\n\",solve());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 250001,M = 1e9 + 9,b = 103,b1 = 107;\nint cs[N],cs1[N],p[N],p1[N],n;\nmap<pair<int,int>,int>mp;\nvoid add(int &a,int b){\n\ta+=b;\n\tif(a >= M)a-=M;\n\tif(a < 0)a+=M;\n}\nint power(int base,int to){\n\tint ret = 1;\n\twhile(to){\n\t\tif(to&1)ret = ret*1LL*base%M;\n\t\tto>>=1;\n\t\tbase = base*1LL*base%M;\n\t}\n\treturn ret;\n}\nint main(){\n\t//freopen(\"readin.txt\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tp[0] = p1[0] = 1;\n\tchar c;\n\tint inv = power(b,M - 2),inv1 = power(b1,M - 2);\n\tfor(int i = 1;i <= n;i++){\n\t\tscanf(\" %c\",&c);\n\t\tcs[i] = cs[i - 1];\n\t\tp[i] = p[i - 1];\n\t\tif(c == '+')add(cs[i],p[i]),add(cs1[i],p1[i]);\n\t\telse if(c == '-')add(cs[i],-p[i]),add(cs1[i],-p1[i]);\n\t\telse if(c == '>')p[i] = p[i]*1LL*b%M,p1[i] = p1[i]*1LL*b1%M;\n\t\telse if(c == '<')p[i] = p[i]*1LL*inv%M,p1[i] = p1[i]*1LL*inv1%M;\n\t}\n\tlong long ans = 0;\n\tfor(int i = 0;i <= n;i++){\n\t\tans+=mp[{cs[i],cs1[i]}];\n\t\tmp[{(cs[n]*1LL*p[i] + cs[i] + M)%M,(cs1[n]*1LL*p1[i] + cs1[i] + M)%M}]++;\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//I love armpit fetish\n\n#include <bits/stdc++.h>\nusing namespace std;\n \n#define debug(x) cerr << #x << \" = \" << x << '\\n';\n#define BP() cerr << \"OK!\\n\";\n#define PR(A, n) {cerr << #A << \" = \"; for (int _=1; _<=n; ++_) cerr << A[_] << ' '; cerr << '\\n';}\n#define PR0(A, n) {cerr << #A << \" = \"; for (int _=0; _<n; ++_) cerr << A[_] << ' '; cerr << '\\n';}\n#define FILE_NAME \"data\"\n\nconst int MAX_N = 500002;\nconst int offset = 250002;\nconst int T = 260000;\nconst int64_t MOD = 67280421310721;\n\nint n, cnt[MAX_N];\nstring s;\nint64_t pref_hash[MAX_N], suff_hash[MAX_N];\n\nint64_t mul(int64_t a, int64_t b) {\n\tint64_t res = 0;\n\twhile (b) {\n\t\tif (b%2)\n\t\t\tres = (res + a) % MOD;\n\t\ta = a * 2 % MOD;\n\t\tb = b / 2;\n\t}\n\treturn res;\n}\n\nvoid enter() {\n\tcin >> n >> s;\n}\n\nint64_t pw(int n, int k) {\n\tif (k==0)\n\t\treturn 1;\n\tint64_t tmp = pw(n, k/2);\n\tif (k%2)\n\t\treturn mul(mul(tmp, tmp), n);\n\treturn mul(tmp, tmp);\n}\n\nvoid init_pref() {\n\tint p = offset;\n\tint64_t H = 0;\n\tfor (int i=0; i<n; ++i) {\n\t\tif (s[i]=='<' || s[i]=='>') {\n\t\t\tp += (s[i]=='<' ? -1 : 1);\n\t\t\tcnt[i] = cnt[i-1] + (s[i]=='<' ? -1 : 1);\n\t\t}\n\t\telse {\n\t\t\tH = (H - pw(T, p) * (s[i]=='-' ? 1 : -1)) % MOD;\n\t\t}\n\t\tpref_hash[i] = (H + MOD) % MOD;\n\t}\n}\n\nvoid init_suff() {\n\tint64_t H = pref_hash[n-1];\n\tint p = offset;\n\tfor (int i=0; i<n; ++i) {\n\t\tif (s[i]=='>' || s[i]=='<')\n\t\t\tp += (s[i]=='>' ? 1 : -1);\n\t\telse\n\t\t\tH = (H + pw(T, p) * (s[i]=='+' ? -1 : 1)) % MOD;\n\t\tsuff_hash[i+1] = (H + MOD) % MOD;\n\t}\n}\n\nint64_t solve() {\n\tmap<int64_t, int> mp;\n\tint64_t H = pref_hash[n-1];\n\tint64_t res = 0;\n\tfor (int j=0; j<n; ++j) {\n\t\tif (j==0)\n\t\t\t++mp[0];\n\t\telse\n\t\t\t++mp[((H - pref_hash[j-1] - mul(H, pw(T, cnt[j-1]))) % MOD + MOD) % MOD];\n\t\tres += mp[suff_hash[j+1]];\n\t}\n\treturn res;\n}\n\nint main() {\n\t//#define OFFLINE_JUDGE doraemon\n\t#ifdef OFFLINE_JUDGE\n\t\tfreopen(FILE_NAME\".inp\", \"r\", stdin);\n\t\tfreopen(FILE_NAME\".out\", \"w\", stdout);\n\t#endif\n\tios::sync_with_stdio(0); cin.tie(0);\n\tenter();\n\tinit_pref();\n\tinit_suff();\n\tcout << solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst unsigned long long BASE=233,INV=7204522363551799129;\nconst int MAXN=250100;\nmap<unsigned long long,int> Map;\nchar s[MAXN];\nint n;\nunsigned long long f[MAXN],X=1,Y,ans;\nsigned main()\n{\n\tios::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tcin>>n>>(s+1);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(s[i]=='+') f[i]=f[i-1]+X;\n\t\tif(s[i]=='-') f[i]=f[i-1]-X;\n\t\tif(s[i]=='<') f[i]=f[i-1],X=X*BASE;\n\t\tif(s[i]=='>') f[i]=f[i-1],X=X*INV;\n\t\tMap[f[i]]++;\n\t}\n\tX=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tans=ans+Map[f[n]*X+Y];\n\t\tif(s[i]=='+') Y=Y+X;\n\t\tif(s[i]=='-') Y=Y-X;\n\t\tif(s[i]=='<') X=X*BASE;\n\t\tif(s[i]=='>') X=X*INV;\n\t\tMap[f[i]]--;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int N = 2e5 + 10;\nint mod1=998244353,base1=19260817,inv1;\nint mod2=353448299,base2=20000003,inv2;\nint s[N], pw1[N], pw2[N], rev1[N], rev2[N];\n\nint q_pow(int x, int y, int mod) {\n  int ans = 1;\n  for(; y; y >>= 1) {\n    if(y & 1) ans = 1ll * ans * x % mod;\n    x = 1ll * x * x % mod;\n  }\n  return ans;\n}\n\nint h1[N], h2[N];\ntypedef pair<int, int> P;\nmap<P, int> mp;\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  inv1 = q_pow(base1, mod1 - 2, mod1);\n  inv2 = q_pow(base2, mod2 - 2, mod2);\n  pw1[0] = pw2[0] = rev1[0] = rev2[0] = 1;\n  for(int i = 1; i <= (n << 1); ++i) {\n    pw1[i] = 1ll * pw1[i - 1] * base1 % mod1;\n    pw2[i] = 1ll * pw2[i - 1] * base2 % mod2;\n    rev1[i] = 1ll * rev1[i - 1] * inv1 % mod1;\n    rev2[i] = 1ll * rev2[i - 1] * inv2 % mod2;\n  }\n  s[0] = n;\n  for(int i = 1; i <= n; ++i) {\n    char ch; cin >> ch;\n    if(ch == '+') {\n      s[i] = s[i - 1];\n      h1[i] = (h1[i - 1] + pw1[s[i]]) % mod1;\n      h2[i] = (h2[i - 1] + pw2[s[i]]) % mod2;\n    } else if(ch == '-') {\n      s[i] = s[i - 1];\n      h1[i] = (h1[i - 1] - pw1[s[i]] + mod1) % mod1;\n      h2[i] = (h2[i - 1] - pw2[s[i]] + mod2) % mod2;\n    } else if(ch == '>') {\n      s[i] = s[i - 1] + 1;\n      h1[i] = h1[i - 1];\n      h2[i] = h2[i - 1];\n    } else {\n      s[i] = s[i - 1] - 1;\n      h1[i] = h1[i - 1];\n      h2[i] = h2[i - 1];\n    }\n    mp[P(h1[i], h2[i])]++;\n  }\n  ll ans = 0;\n  for(int i = 1; i <= n; ++i) {\n    int pos = h1[n], tmp = h2[n];\n    int sit = s[i - 1] - n;\n    if(sit >= 0) pos = 1ll * pos * pw1[sit] % mod1, tmp = 1ll * tmp * pw2[sit] % mod2;\n    else pos = 1ll * pos * rev1[-sit] % mod1, tmp = 1ll * tmp & rev2[-sit] % mod2;\n    pos = (pos + h1[i - 1]) % mod1;\n    tmp = (tmp + h2[i - 1]) % mod2;\n    ans += mp[P(pos, tmp)];\n    mp[P(h1[i], h2[i])]--;\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <functional>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <memory>\n#include <thread>\n#include <tuple>\n\nusing namespace std;\n\nint n;\nchar dat[260003];\n\nconst uint64_t p1 = 1288490207;\nconst uint64_t p2 = 1395864377;\nconst uint64_t p3 = 1417339213;\nconst uint64_t p4 = 1471026299;\n\n/* find a pair (c,d) s.t. ac + bd = gcd(a,b)\n* Dependencies: none */\npair<long long, long long> extended_gcd(long long a, long long b) {\n  if (b == 0) return make_pair(1, 0);\n  pair<long long, long long> t = extended_gcd(b, a % b);\n  return make_pair(t.second, t.first - t.second * (a / b));\n}\n\n/* Find x in [0,m) s.t. ax ≡ gcd(a, m) (mod m)\n* Dependencies: extended_gcd(a, b) */\nlong long modinverse(long long a, long long m) {\n  return (extended_gcd(a, m).first % m + m) % m;\n}\n\nstruct LinearFunction {\n  // Ax + B\n  long long A, B;\n  long long mod;\n  long long x, xinv;\n\n  LinearFunction(long long mod, long long x) : A(1), B(0), mod(mod), x(x) {\n    xinv = modinverse(x, mod);\n  }\n\n  long long evaluate(long long seed) const {\n    return (((A % mod) * (seed % mod) + B) % mod + mod) % mod;\n  }\n\n  long long evaluateInverse(long long seed) const {\n    // Ay + B = seed\n    // Ay = seed - B\n    // y = (seed - B) * A^-1\n    long long result = seed - B;\n    result *= modinverse(A, mod);\n    return (result % mod + mod) % mod;\n  }\n\n  void applyPlus() { B++; B %= mod; }\n  void applyMinus() { B += mod - 1; B %= mod; }\n  void applyLeft() { A = (A * xinv) % mod; B = (B * xinv) % mod; }\n  void applyRight() { A = (A * x) % mod; B = (B * x) % mod; }\n};\n\nint main() {\n  scanf(\"%d\", &n);\n  scanf(\"%s\", dat);\n\n  pair<long long, long long> abc;\n  {\n    LinearFunction ef1(p1, p2);\n    LinearFunction ef2(p3, p4);\n    for (int i = n - 1; i >= 0; i--) {\n      if (dat[i] == '+') {\n        ef1.applyPlus();\n        ef2.applyPlus();\n      }\n      else if (dat[i] == '-') {\n        ef1.applyMinus();\n        ef2.applyMinus();\n      }\n      else if (dat[i] == '<') {\n        ef1.applyLeft();\n        ef2.applyLeft();\n      }\n      else if (dat[i] == '>') {\n        ef1.applyRight();\n        ef2.applyRight();\n      }\n    }\n    abc = make_pair(ef1.evaluate(0), ef2.evaluate(0));\n  }\n  long long ans = 0;\n  {\n    map<pair<long long, long long>, int> suffix;\n    LinearFunction ef1(p1, p2);\n    LinearFunction ef2(p3, p4);\n    ++suffix[make_pair(ef1.evaluateInverse(0), ef2.evaluateInverse(0))];\n    for (int i = n - 1; i >= 0; i--) {\n      if (dat[i] == '+') {\n        ef1.applyPlus();\n        ef2.applyPlus();\n      }\n      else if (dat[i] == '-') {\n        ef1.applyMinus();\n        ef2.applyMinus();\n      }\n      else if (dat[i] == '<') {\n        ef1.applyLeft();\n        ef2.applyLeft();\n      }\n      else if (dat[i] == '>') {\n        ef1.applyRight();\n        ef2.applyRight();\n      }\n      ans += suffix[make_pair(\n        ef1.evaluateInverse(abc.first),\n        ef2.evaluateInverse(abc.second)\n      )];\n      ++suffix[make_pair(ef1.evaluateInverse(0), ef2.evaluateInverse(0))];\n    }\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ull unsigned long long\nusing namespace std;\nconst int N=3e5+5;\nchar s[N];\null base=233,inv=7204522363551799129,f[N],X=1,Y,ans=0;\nint n;\nmap<ull,int> mp;\nint main()\n{\n\tscanf(\"%d\",&n);getchar();\n\tscanf(\"%s\",s+1);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tf[i]=f[i-1];\n\t\tif(s[i]=='+') f[i]+=X;\n\t\tif(s[i]=='-') f[i]-=X;\n\t\tif(s[i]=='<') X*=base;\n\t\tif(s[i]=='>') X*=inv;\n\t\tmp[f[i]]++;\n\t}\n\tX=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tans+=mp[f[n]*X+Y];\n\t\tif(s[i]=='+') Y+=X;\n\t\tif(s[i]=='-') Y-=X;\n\t\tif(s[i]=='<') X*=base;\n\t\tif(s[i]=='>') X*=inv;\n\t\tmp[f[i]]--;\n\t}\n\tprintf(\"%llu\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n* C++11 code template for contests.\n* @author: Andrei Kalendarov\n* @e-mail: andreykalendarov@gmail.com\n*/\n\n//#define ANDREIKKAA_ALLOCATOR\nconst int _ML = 228;\n\nconst char _inpf[] =\n#if defined(ANDREIKKAA)\n    \"input.txt\"\n#else\n    \"\"\n#endif\n;\nconst char _outf[] =\n#if defined(ANDREIKKAA)\n    \"\"\n#else\n    \"\"\n#endif\n;\n\n#if defined(ANDREIKKAA)\n#undef NDEBUG\n#else\n#pragma GCC optimize(\"O3,no-stack-protector\")\n#endif\n#include <bits/stdc++.h>\n#if !defined(ANDREIKKAA)\n#define endl '\\n'\n#endif\n#define x first\n#define y second\nusing namespace std;\n#define rand abcdefghijklmnopqrstuvwxyz\n#define random_shuffle abcdefghijklmnopqrstuvwxyz\n#define all(x) (x).begin(), (x).end()\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef double ld;\nconst ld PI = 3.14159265358979323846;\nmt19937 rd(228);\n#if defined(ANDREIKKAA_ALLOCATOR)\nchar _mem[_ML * 1024 * 1024];\nsize_t _ptr = 0;\ninline void* operator new (size_t _x) { _ptr += _x; assert(_ptr < _ML * 1024 * 1024); return _mem + _ptr - _x; }\ninline void operator delete (void*) { }\n#endif\ntemplate<class T, class U> inline ostream &operator<< (ostream &, const pair<T, U> &);\ntemplate<class T, class U> inline istream &operator>> (istream &, pair<T, U> &);\ntemplate<class T> inline ostream &operator<< (ostream &, const vector<T> &);\ntemplate<class T> inline istream &operator>> (istream &, vector<T> &);\ntemplate<class T> inline ostream &operator<< (ostream &, const set<T> &);\ntemplate<class T> inline ostream &operator<< (ostream &, const multiset<T> &);\ntemplate<class T> inline ostream &operator<< (ostream &, const unordered_set<T> &);\ntemplate<class T> inline ostream &operator<< (ostream &, const unordered_multiset<T> &);\ntemplate<class T, class U> inline ostream &operator<< (ostream &, const map<T, U> &);\ntemplate<class T, class U> inline ostream &operator<< (ostream &, const unordered_map<T, U> &);\n\n/* ________ CODE ________ */\nconst int X = 229;\n\nstruct hasher {\n    vector<int> pw;\n    int M;\n    int val;\n\n    int add(int a, int b) {\n        return (a + b) % M;\n    }\n\n    int sub(int a, int b) {\n        return (a - b + M) % M;\n    }\n\n    int mul(int a, int b) {\n        return (int)(((ll)a * b) % M + M) % M;\n    }\n\n    int bp(int a, int b) {\n        int r = 1;\n        while(b) {\n            if(b & 1) {\n                r = mul(r, a);\n            }\n            a = mul(a, a);\n            b >>= 1;\n        }\n        return r;\n    }\n\n    int div(int a, int b) {\n        return mul(a, bp(b, M - 2));\n    }\n\n    hasher(int p, int m, int n) : M(m), val(0) {\n        pw.resize(n);\n        pw[0] = 1;\n        for(int i = 1; i < n; ++i) {\n            pw[i] = mul(pw[i - 1], p);\n        }\n    }\n\n    void ins(int p, int x) {\n        val = add(val, mul(pw[p], x));\n    }\n\n    void ers(int p, int x) {\n        val = sub(val, mul(pw[p], x));\n    }\n};\n\ninline void _main_function()\n{\n    int n;\n    cin >> n;\n\n    string s;\n    cin >> s;\n\n    vector<int> a(2 * n + 1);\n    int p = n;\n\n    hasher h(1000 * 1000 + 3, 1000 * 1000 * 1000 + 7, sz(a));\n\n    vector<int> ans = {0};\n\n    for(int i = 0; i < n; ++i) {\n        if(s[i] == '<') {\n            --p;\n        } else if(s[i] == '>') {\n            ++p;\n        } else {\n            h.ers(p, a[p]);\n            if(s[i] == '+') {\n                ++a[p];\n            } else if(s[i] == '-') {\n                --a[p];\n            } else {\n                assert(false);\n            }\n            h.ins(p, a[p]);\n        }\n\n        ans.push_back(h.val);\n    }\n\n    ll sum = 0;\n    map<int, int> cnt;\n    int sh = 0;\n\n    for(int i = 0; i <= n; ++i) {\n        sum += cnt[ans[i]];\n\n        if(i && s[i - 1] == '>') {\n            ++sh;\n        } else if(i && s[i - 1] == '<') {\n            --sh;\n        }\n\n        if(sh >= 0) {\n            int x = h.add(h.mul(ans.back(), h.pw[sh]), ans[i]);\n            ++cnt[x];\n        } else {\n            int x = h.add(h.div(ans.back(), h.pw[-sh]), ans[i]);\n            ++cnt[x];\n        }\n    }\n\n    cout << sum << endl;\n}\n\n/* ________ CODE ________ */\n\nint main()\n{\n#if defined(ANDREIKKAA)\n    time_t _start = clock();\n#endif\n    if (_inpf[0] != '\\0') assert(freopen(_inpf, \"r\", stdin) != nullptr);\n    if (_outf[0] != '\\0') assert(freopen(_outf, \"w\", stdout) != nullptr);\n    cin.tie(nullptr);\n    ios_base::sync_with_stdio(false);\n\n    cout << setprecision(20);\n    //cout << fixed;\n\n    _main_function();\n#if defined(ANDREIKKAA)\n    cout << \"Time: \" << (clock() - _start) / (ld)CLOCKS_PER_SEC << endl;\n#endif\n}\n\ntemplate<class T, class U> inline ostream &operator<< (ostream &_out, const pair<T, U> &_p)\n{\n    _out << _p.x << ' ' << _p.y;\n    return _out;\n}\ntemplate<class T, class U> inline istream &operator>> (istream &_in, pair<T, U> &_p)\n{\n    _in >> _p.x >> _p.y;\n    return _in;\n}\ntemplate<class T> inline ostream &operator<< (ostream &_out, const vector<T> &_v)\n{\n    if (_v.empty()) { return _out; }\n    _out << *_v.begin();\n    for (auto _it = ++_v.begin(); _it != _v.end(); ++_it) { _out << ' ' << *_it; }\n    return _out;\n}\ntemplate<class T> inline istream &operator>> (istream &_in, vector<T> &_v)\n{\n    for (auto &_i : _v) { _in >> _i; }\n    return _in;\n}\ntemplate<class T> inline ostream &operator<< (ostream &_out, const set<T> &_s)\n{\n    if (_s.empty()) { return _out; }\n    _out << *_s.begin();\n    for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; }\n    return _out;\n}\ntemplate<class T> inline ostream &operator<< (ostream &_out, const multiset<T> &_s)\n{\n    if (_s.empty()) { return _out; }\n    _out << *_s.begin();\n    for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; }\n    return _out;\n}\ntemplate<class T> inline ostream &operator<< (ostream &_out, const unordered_set<T> &_s)\n{\n    if (_s.empty()) { return _out; }\n    _out << *_s.begin();\n    for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; }\n    return _out;\n}\ntemplate<class T> inline ostream &operator<< (ostream &_out, const unordered_multiset<T> &_s)\n{\n    if (_s.empty()) { return _out; }\n    _out << *_s.begin();\n    for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; }\n    return _out;\n}\ntemplate<class T, class U> inline ostream &operator<< (ostream &_out, const map<T, U> &_m)\n{\n    if (_m.empty()) { return _out; }\n    _out << '(' << _m.begin()->x << \": \" << _m.begin()->y << ')';\n    for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) { _out << \", (\" << _it->x << \": \" << _it->y << ')'; }\n    return _out;\n}\ntemplate<class T, class U> inline ostream &operator<< (ostream &_out, const unordered_map<T, U> &_m)\n{\n    if (_m.empty()) { return _out; }\n    _out << '(' << _m.begin()->x << \": \" << _m.begin()->y << ')';\n    for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) { _out << \", (\" << _it->x << \": \" << _it->y << ')'; }\n    return _out;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1e9 + 7;\nconst int N = 2e5 + 5;\ntypedef long long ll;\n\nchar c;\nstring s;\nll n,i,t,a,b,x,bol=1,ans;\nmap < int , int > M;\n\nint main(){\n    cin >> n >> s;\n    for(t=177,i=mod-2; i ; i>>=1){\n        if(i & 1) bol = bol*t % mod;\n        t = t*t % mod;\n    }\n    for(i=n-1; i>=0 ;i--){\n        c = s[i];\n        if(c == '+') x++;\n        if(c == '-') x--;\n        if(c == '>') x *= 177;\n        if(c == '<') x *= bol;\n        x = (x % mod + mod) % mod;\n    }\n\n    a = 1; b = 0;\n    M[0] = 1;\n    for(i=n-1; i>=0 ;i--){\n        c = s[i];\n        if(c == '+') b -= a;\n        if(c == '-') b += a;\n        if(c == '>') a *= bol;\n        if(c == '<') a *= 177;\n        a = (a % mod + mod) % mod;\n        b = (b % mod + mod) % mod;\n        t = (a*x + b) % mod;\n        ans += M[t];\n        M[b]++;\n    }\n\n    cout << ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,NAME,...) NAME\n#define pr(...) cerr<< GET_MACRO(__VA_ARGS__,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__) <<endl\n#define pr1(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr2(a,b) pr1(a)<<pr1(b)\n#define pr3(a,b,c) pr1(a)<<pr2(b,c)\n#define pr4(a,b,c,d) pr1(a)<<pr3(b,c,d)\n#define pr5(a,b,c,d,e) pr1(a)<<pr4(b,c,d,e)\n#define pr6(a,b,c,d,e,f) pr1(a)<<pr5(b,c,d,e,f)\n#define pr7(a,b,c,d,e,f,g) pr1(a)<<pr6(b,c,d,e,f,g)\n#define pr8(a,b,c,d,e,f,g,h) pr1(a)<<pr7(b,c,d,e,f,g,h)\nusing namespace std;\nusing Int = long long;\nusing ll = long long;\nusing Double = long double;\nconst Int INF = (1LL<<55)+1e9; // ~ 3.6 * 1e16\nconst Double EPS = 1e-8;\nconst Double PI = 6.0 * asin((Double)0.5);\nusing P = pair<Int,Int>;\nusing T = tuple<Int,Int,Int>;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nostream& operator<<(ostream& o,T t){return o<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){Int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){Int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\nconst Int N = 300000;\n\nconstexpr ll mod_pow(ll x, ll n, Int mod){\n  return n == 0? 1:(n%2? x:1) * mod_pow((x*x)%mod,n/2, mod) % mod;\n}  \n\nconstexpr ll mod_inv(Int num,Int mod){return mod_pow(num, mod-2, mod);}\nconst ll mod[] = {1000000007,1000000009,1000000021};\nconst ll B[]= {1777771,10000019,10000079};\nconst ll inv[] = {mod_inv(B[0],mod[0]), mod_inv(B[1],mod[1]),mod_inv(B[2],mod[2])};\n\nclass Hash{\npublic:\n\n  ll num;\n  ll idx;\n  vector<ll> K;\n  Int b;\n  Hash(Int b):b(b){\n    K.resize(N);\n    K[0] = 1;\n    for(Int i=1;i<N;i++) K[i] = K[i-1] * B[b] % mod[b];\n    num = 0;\n    idx = K[N/2];\n  }\n\n  void inc(){num = (num + idx) % mod[b];}\n  void dec(){num = (num - idx + mod[b]) % mod[b];}\n  void moveLeft(){idx = idx * inv[b] % mod[b];}\n  void moveRight(){idx = idx * B[b] % mod[b];}\n  \n};\n\n\nsigned main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  Int n;\n  cin>>n;\n  string s;\n  cin>>s;\n\n  vector<map<ll,Int> > cnt(3);\n  vector<Hash> hash{Hash(0), Hash(1), Hash(2)};\n  vector<Hash> hash2 = hash;\n  \n  for(Int k = 0; k<n ; k++){\n    char ch = s[k];\n    for(Int i=0;i<3;i++){\n      auto &A = hash[i];\n      if(ch == '+') A.inc();\n      if(ch == '-') A.dec();\n      if(ch == '<') A.moveLeft();\n      if(ch == '>') A.moveRight();\n      cnt[i][A.num]++;\n    }\n  }\n\n  vector<ll> allHash(3);\n  vector<ll> Ofset(3,0);\n  for(Int i=0;i<3;i++) allHash[i] = hash[i].num;\n  \n  Int ans = 0;\n  for(Int k=0;k<n;k++){\n    \n    char ch = s[k];\n    Int mn = INF;\n    for(Int i=0;i<3;i++){\n      auto &A = hash2[i];\n      auto &U = allHash[i];\n      auto &X = Ofset[i];\n      ll val = (U - X + mod[i]) % mod[i];\n      Min(mn, cnt[i][val]);\n      pr(U, X, (U + X)%mod[i], A.num);\n      if(ch == '+') X = (X - A.idx + mod[i]) % mod[i], A.inc();\n      if(ch == '-') X = (X + A.idx + mod[i]) % mod[i], A.dec();\n      if(ch == '>') U = U * B[i] % mod[i], A.moveRight();\n      if(ch == '<') U = U * inv[i] % mod[i], A.moveLeft();\n      assert(cnt[i][A.num] != 0);\n      cnt[i][A.num]--;\n    }\n    ans += mn;\n  }\n  cout<<ans<<endl;\n  \n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n  \n#define ll long long\n#define all(aaa) aaa.begin(), aaa.end()\n\nconst int MOD = 1e9 + 9, N = 3e5 + 5;\nconst ll X = 1234567;\n\nll bp(ll a, ll p) {\n    ll r = 1;\n    while (p > 0) {\n        if (p & 1) {\n            r = r * a % MOD;\n        }\n        a = a * a % MOD;\n        p >>= 1;\n    }\n    return r;\n}\n\nll inv_X = bp(X, MOD - 2);\n\nll a[N], b[N];\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n;\n    string s;\n    cin >> n >> s;\n\n    ll h = 0;\n\n    for (int i = n - 1; i >= 0; i--) {\n        if (s[i] == '>')\n            h = h * X % MOD;\n        else if (s[i] == '<')\n            h = h * inv_X % MOD;\n        else if (s[i] == '+')\n            h = (h + 1) % MOD;\n        else\n            h = (h - 1 + MOD) % MOD;\n    }\n\n    map<ll, int> mp;\n\n    ll ans = 0;\n\n    mp[0]++;\n\n    a[n] = 1;\n\n    for (int i = n - 1; i >= 0; i--) {\n        a[i] = a[i + 1];\n        b[i] = b[i + 1];\n\n        if (s[i] == '>') {\n            a[i] = a[i + 1] * inv_X % MOD;\n            b[i] = b[i + 1];\n        }\n        else if (s[i] == '<') {\n            a[i] = a[i + 1] * X % MOD;\n            b[i] = b[i + 1];\n        }\n        else if (s[i] == '+') {\n            a[i] = a[i + 1];\n            b[i] = (b[i + 1] - a[i + 1] + MOD) % MOD;\n        }\n        else {\n            a[i] = a[i + 1];\n            b[i] = (b[i + 1] + a[i + 1]) % MOD;\n        }\n\n        // cout << b[i] << \"\\n\";\n\n        ans += mp[(a[i] * h + b[i]) % MOD];\n        mp[b[i]]++;\n    }\n\n    // cout << (a[0] * h + b[0]) % MOD << \"\\n\";\n\n    cout << ans << \"\\n\";\n\n    return 0;   \n}"
  },
  {
    "language": "C++",
    "code": "//Author:xht37\n#include <bits/stdc++.h>\n\n#define ui unsigned int\n#define ll long long\n#define ul unsigned ll\n#define ld long double\n\n#define pi pair <int, int>\n#define fi first\n#define se second\n#define mp make_pair\n\n#define ls (p << 1)\n#define rs (ls | 1)\n#define md ((t[p].l + t[p].r) >> 1)\n\n#define vi vector <int>\n#define pb push_back\n#define pq priority_queue\n\n#define dbg(x) cerr << #x\" = \" << x << endl\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#define fl(x) freopen(x\".in\", \"r\", stdin), freopen(x\".out\", \"w\", stdout)\n\nusing namespace std;\n\nnamespace io {\n\tconst int SI = 1 << 21 | 1;\n\tchar IB[SI], *IS, *IT, OB[SI], *OS = OB, *OT = OS + SI - 1, c, ch[100];\n\tint f, t;\n\t#define gc() (IS == IT ? (IT = (IS = IB) + fread(IB, 1, SI, stdin), IS == IT ? EOF : *IS++) : *IS++)\n\tinline void flush() {\n\t\tfwrite(OB, 1, OS - OB, stdout), OS = OB;\n\t}\n\tinline void pc(char x) {\n\t\t*OS++ = x;\n\t\tif (OS == OT) flush();\n\t}\n\n\ttemplate <class I>\n\tinline void rd(I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + (c & 15), c = gc());\n\t\tx *= f;\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y) {\n\t\trd(x), rd(y);\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y, I &z) {\n\t\trd(x), rd(y), rd(z);\n\t}\n\ttemplate <class I>\n\tinline void rda(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) rd(a[i]);\n\t}\n\tinline void rdc(char &c) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t}\n\tinline void rds(char *s, int &n) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (n = 0; c >= 33 && c <= 126; s[++n] = c, c = gc());\n\t\ts[n+1] = '\\0';\n\t}\n\tinline void rds(string &s) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (s.clear(); c >= 33 && c <= 126; s.pb(c), c = gc());\n\t}\n\n\ttemplate <class I>\n\tinline void print(I x, char k = '\\n') {\n\t\tif (!x) pc('0');\n\t\tif (x < 0) pc('-'), x = -x;\n\t\twhile (x) ch[++t] = x % 10 + '0', x /= 10;\n\t\twhile (t) pc(ch[t--]);\n\t\tpc(k);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y) {\n\t\tprint(x, ' '), print(y);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y, I z) {\n\t\tprint(x, ' '), print(y, ' '), print(z);\n\t}\n\ttemplate <class I>\n\tinline void printa(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) print(a[i], \" \\n\"[i==n]);\n\t}\n\tinline void printc(char c) {\n\t\tpc(c);\n\t}\n\tinline void prints(char *s, int n) {\n\t\tfor (int i = 1; i <= n; i++) pc(s[i]);\n\t\tpc('\\n');\n\t}\n\tinline void prints(string s) {\n\t\tint n = s.length();\n\t\twhile (t < n) pc(s[t++]);\n\t\tpc('\\n'), t = 0;\n\t}\n\tstruct Flush {\n\t\t~Flush() {\n\t\t\tflush();\n\t\t}\n\t} flusher;\n}\nusing io::rd;\nusing io::rda;\nusing io::rdc;\nusing io::rds;\nusing io::print;\nusing io::printa;\nusing io::printc;\nusing io::prints;\n\nconst int P = 1e9 + 7;\n\nstruct modint {\n    int x;\n    inline modint(int x = 0) : x(x) {}\n    inline modint &operator = (int o) { return x = o, *this; }\n    inline modint &operator += (modint o) { return (x += o.x) >= P && (x -= P), *this; }\n    inline modint &operator -= (modint o) { return (x -= o.x) < 0 && (x += P), *this; }\n    inline modint &operator *= (modint o) { return x = 1ll * x * o.x % P, *this; }\n    inline modint &operator ^= (ll b) {\n        modint a = *this, c;\n        if (!~b) b = P - 2;\n        c.x = 1 % P;\n        while (b) {\n            if (b & 1) c *= a;\n            a *= a, b >>= 1;\n        }\n        return x = c.x, *this;\n    }\n    inline modint &operator /= (modint o) { return *this *= o ^ -1; }\n    inline modint &operator += (int o) { return (x += o) >= P && (x -= P), *this; }\n    inline modint &operator -= (int o) { return (x -= o) < 0 && (x += P), *this; }\n    inline modint &operator *= (int o) { return x = 1ll * x * o % P, *this; }\n    inline modint &operator /= (int o) { return *this *= (modint)o ^ -1; }\n    template <class I>\n    inline friend modint operator + (modint a, I b) { return a += b; }\n    template <class I>\n    inline friend modint operator - (modint a, I b) { return a -= b; }\n    template <class I>\n    inline friend modint operator * (modint a, I b) { return a *= b; }\n    inline friend modint operator ^ (modint a, ll b) { return a ^= b; }\n    template <class I>\n    inline friend modint operator / (modint a, I b) { return a /= b; }\n    inline friend bool operator == (modint a, int b) { return a.x == b; }\n    inline friend bool operator != (modint a, int b) { return a.x != b; }\n    inline friend bool operator < (modint a, int b) { return a.x < b; }\n    inline friend bool operator <= (modint a, int b) { return a.x <= b; }\n    inline friend bool operator > (modint a, int b) { return a.x > b; }\n    inline friend bool operator >= (modint a, int b) { return a.x >= b; }\n    inline friend bool operator == (modint a, modint b) { return a.x == b.x; }\n    inline friend bool operator != (modint a, modint b) { return a.x != b.x; }\n    inline friend bool operator < (modint a, modint b) { return a.x < b.x; }\n    inline friend bool operator <= (modint a, modint b) { return a.x <= b.x; }\n    inline friend bool operator > (modint a, modint b) { return a.x > b.x; }\n    inline friend bool operator >= (modint a, modint b) { return a.x >= b.x; }\n    inline bool operator ! () { return !x; }\n    inline modint operator - () { return x ? P - x : 0; }\n};\ninline void rd(modint &x) { rd(x.x); }\ninline void print(modint x, char k = '\\n') { print(x.x, k); }\n\n//const int NP = 1e6 + 7;\n//modint p[NP], v[NP], vp[NP];\n//inline void init(int n) {\n//  p[0] = v[0] = 1;\n//  for (int i = 1; i <= n; i++) p[i] = p[i-1] * i;\n//  vp[n] = 1 / p[n];\n//  for (int i = n; i; i--) v[i] = vp[i] * p[i-1], vp[i-1] = vp[i] * i;\n//}\n//inline modint binom(int n, int m) {\n//  return n < m ? 0 : p[n] * vp[m] * vp[n-m];\n//}\n\nnamespace Rd {\n    inline bool gt() {\n        int a = rand(), b = rand();\n        while (a == b) a = rand(), b = rand();\n        return a < b;\n    }\n    template <class I>\n    inline I rd(I k) {\n        I w = 1;\n        while (w < k) w <<= 1;\n        while (w >= k) {\n            I o = 1, x = 0;\n            while (o < k) o <<= 1, x = x << 1 | gt();\n            w = x;\n        }\n        return w;\n    }\n    template <class I>\n    inline I rdm(I l, I r) {\n        return l == r ? l : l + rd(r - l + 1);\n    }\n    template <class I>\n    inline void rdms(I *a, int n) {\n        for (int i = n; i; i--) swap(a[i], a[rdm(1,i)]);\n    }\n}\nusing Rd::rdm;\nusing Rd::rdms;\n\nconst int N = 2.5e5 + 7, M = 2;\nint n;\nchar s[N];\nstruct H {\n\tvector<modint> a;\n\tinline H() { a.resize(M); }\n\tinline modint &operator [] (int i) { return a[i]; }\n\tinline friend bool operator < (H x, H y) { return x.a < y.a; }\n\tinline friend H operator + (H x, H y) {\n\t\tfor (int i = 0; i < M; i++) x[i] += y[i];\n\t\treturn x;\n\t}\n\tinline friend H operator - (H x, H y) {\n\t\tfor (int i = 0; i < M; i++) x[i] -= y[i];\n\t\treturn x;\n\t}\n\tinline friend H operator * (H x, H y) {\n\t\tfor (int i = 0; i < M; i++) x[i] *= y[i];\n\t\treturn x;\n\t}\n} a[N], x, y, h[N];\nmap<H, int> f;\nll ans;\n\nint main() {\n\tsrand(time(0));\n\trd(n), rds(s, n);\n\tfor (int i = 0; i < M; i++)\n\t\ta[0][i] = 1, x[i] = rdm(1, P - 1), y[i] = 1 / x[i];\n\tfor (int i = 1; i <= n; i++)\n\t\tswitch (s[i]) {\n\t\t\tcase '+' : h[i] = h[i-1] + (a[i] = a[i-1]); break;\n\t\t\tcase '-' : h[i] = h[i-1] - (a[i] = a[i-1]); break;\n\t\t\tcase '>' : h[i] = h[i-1], a[i] = a[i-1] * x; break;\n\t\t\tcase '<' : h[i] = h[i-1], a[i] = a[i-1] * y; break;\n\t\t}\n\tfor (int i = 1; i <= n; i++) ++f[h[i-1]+h[n]*a[i-1]], ans += f[h[i]];\n\tprint(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <map>\n#define llint long long\n#define mod 1000000007\n\nusing namespace std;\n\nllint n;\nstring s;\nllint a[6][250005], b[6][250005];\nmap<vector<llint>, llint> mp;\nconst llint p[] = {2, 1145143, 998244353, 101, 640099, 2172113};\nllint invp[6];\n\nllint modpow(llint a, llint n)\n{\n\tif(n == 0) return 1;\n\tif(n % 2){\n\t\treturn ((a%mod) * (modpow(a, n-1)%mod)) % mod;\n\t}\n\telse{\n\t\treturn modpow((a*a)%mod, n/2) % mod;\n\t}\n}\n\nint main(void)\n{\n\tcin >> n >> s;\n\treverse(s.begin(), s.end());\n\ts = \"#\" + s;\n\t\n\tfor(int i = 0; i < 6; i++){\n\t\tinvp[i] = modpow(p[i], mod-2);\n\t\ta[i][0] = 1, b[i][0] = 0;\n\t}\n\tfor(int z = 0; z < 6; z++){\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\ta[z][i] = a[z][i-1], b[z][i] = b[z][i-1];\n\t\t\tif(s[i] == '+') b[z][i]++, b[z][i] %= mod;\n\t\t\tif(s[i] == '-') b[z][i] += mod-1, b[z][i] %= mod;\n\t\t\tif(s[i] == '<'){\n\t\t\t\ta[z][i] *= p[z], a[z][i] %= mod;\n\t\t\t\tb[z][i] *= p[z], b[z][i] %= mod;\n\t\t\t}\n\t\t\tif(s[i] == '>'){\n\t\t\t\ta[z][i] *= invp[z], a[z][i] %= mod;\n\t\t\t\tb[z][i] *= invp[z], b[z][i] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tllint ans = 0;\n\tfor(int i = 0; i <= n; i++){\n\t\tvector<llint> vec;\n\t\tfor(int j = 0; j < 6; j++){\n\t\t\tllint tmp = (b[j][i]-b[j][n]+mod) % mod;\n\t\t\ttmp *= modpow(a[j][i], mod-2), tmp %= mod;\n\t\t\tvec.push_back(tmp);\n\t\t}\n\t\tans += mp[vec];\n\t\tvec.clear();\n\t\tfor(int j = 0; j < 6; j++) vec.push_back(b[j][i] * modpow(a[j][i], mod-2) % mod);\n\t\tmp[vec]++;\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <string.h>\n//#include <unordered_set>\n//#include <unordered_map>\n//#include <bits/stdc++.h>\n\n#define MP(A,B) make_pair(A,B)\n#define PB(A) push_back(A)\n#define SIZE(A) ((int)A.size())\n#define LEN(A) ((int)A.length())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define fi first\n#define se second\n\nusing namespace std;\n\ntemplate<typename T>inline bool upmin(T &x,T y) { return y<x?x=y,1:0; }\ntemplate<typename T>inline bool upmax(T &x,T y) { return x<y?x=y,1:0; }\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double lod;\ntypedef pair<int,int> PR;\ntypedef vector<int> VI;\n\nconst lod eps=1e-11;\nconst lod pi=acos(-1);\nconst int oo=1<<30;\nconst ll loo=1ll<<62;\nconst int mods=998244353;\nconst int MAXN=100000005;\nconst int INF=0x3f3f3f3f;//1061109567\n/*--------------------------------------------------------------------*/\ninline int read()\n{\n\tint f=1,x=0; char c=getchar();\n\twhile (c<'0'||c>'9') { if (c=='-') f=-1; c=getchar(); }\n\twhile (c>='0'&&c<='9') { x=(x<<3)+(x<<1)+(c^48); c=getchar(); }\n\treturn x*f;\n}\nint upd(int x,int y) { return x+y>=mods?x+y-mods:x+y; }\nint quick_pow(int x,int y)\n{\n\tint ret=1;\n\tfor (;y;y>>=1)\n\t{\n\t\tif (y&1) ret=1ll*ret*x%mods;\n\t\tx=1ll*x*x%mods;\n\t}\n\treturn ret;\n}\n\nchar st[MAXN];\nint X[6]={37,667,233333,17,19,53},inv[6];\nstruct Node\n{\n\tint a[6]; \n\tNode() { for (int i=0;i<6;i++) a[i]=0; }\n};\nbool operator < (Node x,Node y) \n{\n\tfor (int i=0;i<6;i++) { if (x.a[i]==y.a[i]) continue; return x.a[i]<y.a[i]; }\n\treturn 0;\n}\nmap<Node,int> Map;\nNode operator + (Node x,int y) { for (int i=0;i<6;i++) x.a[i]=upd(x.a[i],y); return x; }\nNode operator - (Node x,int y) { for (int i=0;i<6;i++) x.a[i]=upd(x.a[i],mods-y); return x; }\nNode operator >> (Node x,int y) { while (y--) for (int i=0;i<6;i++) x.a[i]=1ll*x.a[i]*X[i]%mods; return x; }\nNode operator << (Node x,int y) { while (y--) for (int i=0;i<6;i++) x.a[i]=1ll*x.a[i]*inv[i]%mods; return x; }\n\nstruct fnode\n{\n\tNode k,b;\n\tfnode() { for (int i=0;i<6;i++) k.a[i]=1,b.a[i]=0; }\n};\nfnode operator + (fnode x,int y) { for (int i=0;i<6;i++) x.b.a[i]=upd(x.b.a[i],y*x.k.a[i]); return x; }\nfnode operator - (fnode x,int y) { for (int i=0;i<6;i++) x.b.a[i]=upd(x.b.a[i],mods-y*x.k.a[i]); return x; }\nfnode operator >> (fnode x,int y) { while (y--) for (int i=0;i<6;i++) x.k.a[i]=1ll*x.k.a[i]*X[i]%mods; return x; }\nfnode operator << (fnode x,int y) { while (y--) for (int i=0;i<6;i++) x.k.a[i]=1ll*x.k.a[i]*inv[i]%mods; return x; }\nNode operator * (Node x,fnode y) \n{\n\tNode ans;\n\tfor (int i=0;i<6;i++) ans.a[i]=upd(ans.a[i],(1ll*y.k.a[i]*x.a[i]+y.b.a[i])%mods);\n\treturn ans;\n}\nint main()\n{\n\tfor (int i=0;i<6;i++) inv[i]=quick_pow(X[i],mods-2);\n\tint n=read(),ans=0;\n\tscanf(\"%s\",st+1);\n\tNode c,p;\n\tfor (int i=n;i>=1;i--)\n\t{\n\t\tif (st[i]=='+') c=c+1;\n\t\tif (st[i]=='-') c=c-1;\n\t\tif (st[i]=='<') c=c<<1;\n\t\tif (st[i]=='>') c=c>>1;\n//\t\tfor (int j=0;j<6;j++) cout<<c.a[j]<<\" \";cout<<endl;\n\t}\n//\tcout<<endl;\n\tMap[p]++;\n\tfnode f;\n\tfor (int i=n;i>=1;i--)\n\t{\n\t\tif (st[i]=='+') f=f-1;\n\t\tif (st[i]=='-') f=f+1;\n\t\tif (st[i]=='<') f=f>>1;\n\t\tif (st[i]=='>') f=f<<1;\n\t\tans+=Map[c*f],Map[p*f]++;\n//\t\tfor (int j=0;j<6;j++) cout<<(p*f).a[j]<<\" \";cout<<endl;\n//\t\tfor (int j=0;j<6;j++) cout<<(c*f).a[j]<<\" \";cout<<endl<<endl;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << (x) << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\nusing P = pair<int,int>;\ntemplate<unsigned int mod_>\nstruct ModInt{\n\tusing uint = unsigned long long;\n\tusing ll = __int128;\n\tusing ull =__int128;\n\n\tconstexpr static uint mod = mod_;\n\n\tuint v;\n\tModInt():v(0){}\n\tModInt(ll v):v(normS(v%mod+mod)){}\n\texplicit operator bool() const {return v!=0;}\n\tstatic uint normS(const uint &x){return (x<mod)?x:x-mod;}\t\t// [0 , 2*mod-1] -> [0 , mod-1]\n\tstatic ModInt make(const uint &x){ModInt m; m.v=x; return m;}\n\tModInt operator+(const ModInt& b) const { return make(normS(v+b.v));}\n\tModInt operator-(const ModInt& b) const { return make(normS(v+mod-b.v));}\n\tModInt operator-() const { return make(normS(mod-v)); }\n\tModInt operator*(const ModInt& b) const { return make((ull)v*b.v%mod);}\n\tModInt operator/(const ModInt& b) const { return *this*b.inv();}\n\tModInt& operator+=(const ModInt& b){ return *this=*this+b;}\n\tModInt& operator-=(const ModInt& b){ return *this=*this-b;}\n\tModInt& operator*=(const ModInt& b){ return *this=*this*b;}\n\tModInt& operator/=(const ModInt& b){ return *this=*this/b;}\n\tll extgcd(ll a,ll b,ll &x,ll &y) const{\n\t\tll u[]={a,1,0},v[]={b,0,1};\n\t\twhile(*v){\n\t\t\tll t=*u/ *v;\n\t\t\trep(i,3) swap(u[i]-=t*v[i],v[i]);\n\t\t}\n\t\tif(u[0]<0) rep(i,3) u[i]=-u[i];\n\t\tx=u[1],y=u[2];\n\t\treturn u[0];\n\t}\n\tModInt inv() const{\n\t\tll x,y;\n\t\textgcd(v,mod,x,y);\n\t\treturn make(normS(x+mod));\n\t}\n\tbool operator==(const ModInt& b) const { return v==b.v;}\n\tbool operator!=(const ModInt& b) const { return v!=b.v;}\n//\tfriend istream& operator>>(istream &o,ModInt& x){\n//\t\tll tmp;\n//\t\to>>tmp;\n//\t\tx=ModInt(tmp);\n//\t\treturn o;\n//\t}\n//\tfriend ostream& operator<<(ostream &o,const ModInt& x){ return o<<x.v;}\n};\nusing mint = ModInt<1000000000000000003ULL>;\nconst mint B = 998244353;\nmint ex(int p){\n\tbool m = 0;\n\tif(p<0){\n\t\tp = -p;\n\t\tm = 1;\n\t}\n\tmint a = 1;\n\tmint x = B;\n\twhile(p){\n\t\tif(p%2==1) a *= x;\n\t\tx *= x;\n\t\tp/=2;\n\t}\n\tif(m) a = (mint)1/a;\n\treturn a;\n}\n\nusing ll = long long;\nint N;\nstring s;\n\nint main(){\n\tcin>>N>>s;\n\tmint H = 0;\n\t{\n\t\tmap<int,int> cnt;\n\t\tint x = 0;\n\t\trep(i,N){\n\t\t\tif(s[i]=='+') cnt[x]++;\n\t\t\tif(s[i]=='-') cnt[x]--;\n\t\t\tif(s[i]=='<') x--;\n\t\t\tif(s[i]=='>') x++;\n\t\t}\n\t\tfor(P p:cnt){\n\t\t\tint x = p.fs, v = p.sc;\n\t\t\tH += ex(x) * v;\n\t\t}\n\t}\n\tmint a = 1, b = 0;\n\tll ans = 0;\n\t\n\tmap<long long,int> mp;\n\tmp[0] = 1;\n\tfor(int i=N-1;i>=0;i--){\n\t\tmint na,nb;\n\t\tif(s[i]=='+'){\n\t\t\tna = a, nb = b+1;\n\t\t}\n\t\tif(s[i]=='-'){\n\t\t\tna = a, nb = b-1;\n\t\t}\n\t\tif(s[i]=='<'){\n\t\t\tna = a/B, nb = b/B;\n\t\t}\n\t\tif(s[i]=='>'){\n\t\t\tna = a*B, nb = b*B;\n\t\t}\n\t\ta = na, b = nb;\n\t\tmint H_false = (H-b)/a;\n\t\tans += mp[H_false.v];\n\t\tmp[(-b/a).v]++;\n\t}\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<map>\nusing namespace std;\nconst int N=250005;\nconst int mod=1020020447;\nconst int base=131;\nint n,pw[N],ipw[N],pos[N],val[N];\nchar str[N];long long ans;\nmap<int,int>Map;\nint fastpow(int x,int y){\n\tint res=1;\n\twhile(y){if(y&1)res=1ll*res*x%mod;x=1ll*x*x%mod;y>>=1;}\n\treturn res;\n}\nint cal(int x){\n\treturn x>0?pw[x]:ipw[-x];\n}\nbool check(int p){\n\tfor(int i=2;i*i<=p;++i)\n\t\tif(p%i==0)\n\t\t\treturn false;\n\treturn true;\n}\nint main(){\n\t/*\n\tint x=1020020415;\n\twhile(!check(x))++x;\n\tprintf(\"x=%d\\n\",x);\n\treturn 0;\n\t*/\n\tscanf(\"%d%s\",&n,str+1);\n\tpw[0]=ipw[0]=1;pw[1]=base;ipw[1]=fastpow(base,mod-2);\n\tfor(int i=2;i<=n;++i){\n\t\tpw[i]=1ll*pw[i-1]*pw[1]%mod;\n\t\tipw[i]=1ll*ipw[i-1]*ipw[1]%mod;\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tif(str[i]=='+'){\n\t\t\tpos[i]=pos[i-1];\n\t\t\tval[i]=(val[i-1]+cal(pos[i]))%mod;\n\t\t}\n\t\tif(str[i]=='-'){\n\t\t\tpos[i]=pos[i-1];\n\t\t\tval[i]=(val[i-1]+mod-cal(pos[i]))%mod;\n\t\t}\n\t\tif(str[i]=='>'){\n\t\t\tpos[i]=pos[i-1]+1;\n\t\t\tval[i]=val[i-1];\n\t\t}\n\t\tif(str[i]=='<'){\n\t\t\tpos[i]=pos[i-1]-1;\n\t\t\tval[i]=val[i-1];\n\t\t}\n\t\t++Map[val[i]];\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tint x=(1ll*val[n]*cal(pos[i-1])+val[i-1])%mod;\n\t\tans+=Map[x];--Map[val[i]];\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "const int N = 250005;\nconst int LG = 21;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nint n;\nstring s;\n\nconst ll M = 2;\nconst ll K[M] = {1000003, 1791791};\nconst ll rK[M] = {rev(K[0]), rev(K[1])};\nll deg[M][2 * N];\n\nvector<ll> ad(vector<ll> a)\n{\n    for (int i = 0; i < M; i++)\n    {\n        a[i]++;\n        if (a[i] >= MOD) a[i] -= MOD;\n    }\n    return a;\n}\n\nvector<ll> mi(vector<ll> a)\n{\n    for (int i = 0; i < M; i++)\n    {\n        a[i]--;\n        if (a[i]  < 0) a[i] += MOD;\n    }\n    return a;\n}\n\nvector<ll> mu(vector<ll> a)\n{\n    for (int i = 0; i < M; i++) a[i] = a[i] * K[i] % MOD;\n    return a;\n}\n\nvector<ll> di(vector<ll> a)\n{\n    for (int i = 0; i < M; i++) a[i] = a[i] * rK[i] % MOD;\n    return a;\n}\n\nsigned main()\n{\n    for (int i = 0; i < M; i++)\n    {\n        deg[i][N] = 1;\n        for (int j = 1; j < N; j++) deg[i][N + j] = deg[i][N + j - 1] * K[i] % MOD;\n        for (int j = 1; j < N; j++) deg[i][N - j] = deg[i][N - j + 1] * rK[i] % MOD;\n    }\n    srand(time(NULL));\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n    cin >> n >> s;\n    vector<ll> a(M);\n    for (int i = n - 1; i >= 0; i--)\n    {\n        if (s[i] == '+') a = mi(a);\n        if (s[i] == '-') a = ad(a);\n        if (s[i] == '>') a = mu(a);\n        if (s[i] == '<') a = di(a);\n    }\n    map<vector<ll>, int> cnt;\n    ll ans = 0;\n    ll cur_move = 0;\n    vector<ll> cur(M, 0);\n    cnt[cur]++;\n    for (int i = n - 1; i >= 0; i--)\n    {\n        if (s[i] == '+') for (int j = 0; j < M; j++) cur[j] = (cur[j] + deg[j][N + cur_move]) % MOD;\n        if (s[i] == '-') for (int j = 0; j < M; j++) cur[j] = (cur[j] + MOD - deg[j][N + cur_move]) % MOD;\n        if (s[i] == '<') cur_move++;\n        if (s[i] == '>') cur_move--;\n        vector<ll> ask = cur;\n        for (int j = 0; j < M; j++) ask[j] = (ask[j] + a[j] * deg[j][N + cur_move]) % MOD;\n        ans += cnt[ask];\n        cnt[cur]++;\n    }\n    cout << ans;\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define FOR(a, b, c) for(int a = b; a <= c; ++a)\n#define pb push_back\n#define int long long\n\nconst int N = 250005;\nconst int MOD = 1e9 + 7;\nconst int MOD2 = 1e9 + 9;\nconst int base = 250000;\nconst int oo = 1e9;\ntypedef pair<int, int> ii;\nint n, wb0, wb1, pos = 250000, curpos[N], bpw[2][N + N];\nint has[2][N + N];\nstring s;\n\nvoid add(int &x, int val, int mod)  {  x = (x + val + 1ll * mod * mod) % mod;  }\nvoid mul(int &x, int y, int mod) { y %= mod; x = x * y % mod; x = (x + 1ll * mod * mod) % mod;}\nint pw(int x, int y, int mod)    {\n    int res = 1ll;\n    while(y)    {\n        if(y % 2 == 1) mul(res, x, mod);\n        mul(x, x, mod);\n        y /= 2;\n    }\n    return res;\n}\n\nmap<ii, int> cnt;\n\nsigned main()\n{\n    //freopen(\"test.inp\", \"r\", stdin);\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    cin >> n >> s;\n    //memset\n    bpw[0][0] = bpw[1][0] = 1ll;\n    FOR(i, 1, N + N - 1) {\n        bpw[0][i] = bpw[0][i - 1] * base % MOD;\n        bpw[1][i] = bpw[1][i - 1] * base % MOD2;\n    }\n    //cout << pw(base, N + 1, MOD) << '\\n';\n    //cout << bpw[0][N + 1] << ' ' << bpw[1][N + 1] << '\\n';\n    // we need to hash all the value of x\n    FOR(i, 1, n)    {\n        if(s[i - 1] == '+' || s[i - 1] == '-') {\n            add(has[0][i], has[0][i - 1] + ((s[i - 1] == '+') ? +1 : -1) * bpw[0][pos], MOD);\n            add(has[1][i], has[1][i - 1] + ((s[i - 1] == '-') ? -1 : +1 ) * bpw[1][pos], MOD2);\n        } else     {\n            pos += ((s[i - 1] == '>') ? 1 : -1);\n            has[0][i] = has[0][i - 1];\n            has[1][i] = has[1][i - 1];\n        }\n        //cout << has[0][i] << ' ' << has[1][i] << ' ' << pos << '\\n';\n        curpos[i] = pos - 250000;\n    } //cout << '\\n';\n\n    int s1 = 1ll * has[0][n] % MOD;\n    int s2 = 1ll * has[1][n] % MOD2;\n    //cout << has[0][3] << ' ' << (bpw[0][curpos[1]] * s1 + has[0][1]) % MOD << '\\n';\n    cnt[ ii(s1, s2) ] = 1;\n    int ans = 0;\n    FOR(i, 1, n)    {\n        ans += cnt[ ii(has[0][i], has[1][i]) ];\n        int n1 = (s1 * bpw[0][ curpos[i] ] + has[0][i] ) % MOD;\n        int n2 = (s2 * bpw[1][ curpos[i] ] + has[1][i]) % MOD2;\n        //cout << n1 << ' ' << n2 << '\\n';\n        cnt[ ii(n1, n2) ] ++;\n    }\n\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 250001;\nconst long long M = (long double)1e18 + 31,b = 1e9 + 7;\nlong long cs[N],p[N],n;\nmap<long long,int>mp;\nvoid add(long long &a,long long b){\n\ta+=b;\n\tif(a >= M)a-=M;\n\tif(a < 0)a+=M;\n}\nlong long power(long long base,long long to){\n\tlong long ret = 1;\n\twhile(to){\n\t\tif(to&1)ret = (__int128)ret*base%M;\n\t\tto>>=1;\n\t\tbase = (__int128)base*base%M;\n\t}\n\treturn ret;\n}\nint main(){\n//\tfreopen(\"readin.txt\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tp[0] = 1;\n\tchar c;\n\tlong long inv = power(b,M - 2);\n\tfor(int i = 1;i <= n;i++){\n\t\tscanf(\" %c\",&c);\n\t\tcs[i] = cs[i - 1];\n\t\tp[i] = p[i - 1];\n\t\tif(c == '+')add(cs[i],p[i]);\n\t\telse if(c == '-')add(cs[i],-p[i]);\n\t\telse if(c == '>')p[i] = (__int128)p[i]*b%M;\n\t\telse if(c == '<')p[i] = (__int128)p[i]*inv%M;\n\t}\n\tlong long ans = 0;\n\tfor(int i = 0;i <= n;i++){\n\t\tans+=mp[cs[i]];\n\t\tmp[((__int128)cs[n]*p[i]%M + cs[i] + M)%M]++;\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//teja349\n#include <bits/stdc++.h>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <utility>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <iomanip> \n//setbase - cout << setbase (16); cout << 100 << endl; Prints 64\n//setfill -   cout << setfill ('x') << setw (5); cout << 77 << endl; prints xxx77\n//setprecision - cout << setprecision (14) << f << endl; Prints x.xxxx\n//cout.precision(x)  cout<<fixed<<val;  // prints x digits after decimal in val\n\nusing namespace std;\n#define f(i,a,b) for(i=a;i<b;i++)\n#define rep(i,n) f(i,0,n)\n#define fd(i,a,b) for(i=a;i>=b;i--)\n#define pb push_back\n#define mp make_pair\n#define vi vector< int >\n#define vl vector< ll >\n#define ss second\n#define ff first\n#define ll long long\n#define pii pair< int,int >\n#define pll pair< ll,ll >\n#define sz(a) a.size()\n#define inf (1000*1000*1000+5)\n#define all(a) a.begin(),a.end()\n#define tri pair<int,pii>\n#define vii vector<pii>\n#define vll vector<pll>\n#define viii vector<tri>\n#define mod (1000*1000*1000+7)\n#define mod1 (1000*1000*1000+9)\n#define pqueue priority_queue< int >\n#define pdqueue priority_queue< int,vi ,greater< int > >\n\n//std::ios::sync_with_stdio(false);   \nll ans10[512345],ans13[512345],powe13[512345],powe10[512345],invpowe10[512345];\nll invpowe13[512345],inv[1234],p[512345];\nll extend_gcd(ll a,ll b,ll &x,ll &y){\n\tif(b==0){\n\t\tx=1;\n\t\ty=0;\n\t\treturn a;\n\t}\n\tll x1,y1;\n\tll ans =extend_gcd(b,a%b,x1,y1);\n\tx=y1;\n\ty=x1-(a/b)*y1;\n\n\treturn ans;\n}\nmap<ll,ll> seti10,seti13; \nint main(){\n    std::ios::sync_with_stdio(false);\n    ll n;\n    cin>>n;\n    if(n<1000)\n        assert(0);\n    string s;\n    cin>>s;\n    ll i;\n    ll initp=250003;\n    powe10[0]=1;\n    powe13[0]=1;\n    invpowe10[0]=1;\n    invpowe13[0]=1;\n    ll inv10,inv13;\n\n            ll x,y;\n            i=503803;\n        ll val=extend_gcd(mod,i,x,y);\n        if(y>0)\n            inv13=y%mod;\n        else{\n                inv13=(y+mod)%mod;\n        }\n        x,y;\n            i=500167;\n        val=extend_gcd(mod1,i,x,y);\n        if(y>0)\n            inv10=y%mod1;\n        else{\n                inv10=(y+mod1)%mod1;\n        }    \n\tf(i,1,512345){\n    \tpowe13[i]=powe13[i-1]*503803;\n    \tpowe10[i]=powe10[i-1]*500167;\n    \tpowe10[i]%=mod1;\n    \tpowe13[i]%=mod;\n    \tinvpowe10[i]=invpowe10[i-1]*inv10;\n    \tinvpowe10[i]%=mod1;\n    \tinvpowe13[i]=invpowe13[i-1]*inv13;\n    \tinvpowe13[i]%=mod;\n    }\n    ans10[0]=0;\n    ans13[0]=0;\n    p[0]=initp;\n    \n    f(i,1,s.length()+1){\n    \tans10[i]=ans10[i-1];\n    \tans13[i]=ans13[i-1];\n    \tp[i]=p[i-1];\n    \tif(s[i-1]=='+'){\n    \t\tans10[i]=ans10[i-1]+powe10[p[i]];\n    \t\tans13[i]=ans13[i-1]+powe13[p[i]];\n\n    \t}\n    \telse if(s[i-1]=='-'){\n    \t\tans10[i]=ans10[i-1]-powe10[p[i]];\n    \t\tans13[i]=ans13[i-1]-powe13[p[i]];\n    \t}\n    \telse if(s[i-1]=='<'){\n    \t\tp[i]--;\n    \t}\n    \telse{\n    \t\tp[i]++;\n    \t}\n    \tans10[i]%=mod1;\n    \tans10[i]+=mod1;\n    \tans10[i]%=mod1;\n    \tans13[i]%=mod;\n    \tans13[i]+=mod;\n    \tans13[i]%=mod;\n    \tseti13[ans13[i]]++;\n    \tseti10[ans10[i]]++;\n    \t//cout<<ans10[i]<<\" \"<<ans13[i]<<endl;\n    }\n    ll val1,j10,j13;\n    ll total=0;\n    f(i,1,n+1){\n    \tval=initp-p[i-1];\n    \tval*=-1;\n    \tif(val>=0){\n    \t\tval1=powe13[val];\n    \t\tval=powe10[val];\n    \t\t  \n    \t}\n    \telse{\n    \t\tval1=invpowe13[val];\n    \t\tval=invpowe10[val];\n    \t}\n    \tj10=ans10[n]*val;\n    \tj10%=mod1;\n    \tj10+=ans10[i-1];\n    \tj13=ans13[n]*val1;\n    \tj13%=mod;\n    \tj13+=ans13[i-1];\n    \tj10%=mod1;\n    \tj13%=mod;\n    \ttotal+=min(seti10[j10],seti13[j13]);\n        //assert(seti10[j10]==seti13[j13]);\n    \tseti13[ans13[i]]--;\n    \tseti10[ans10[i]]--;\n    }\n    cout<<total<<endl;\n\n\n\n\n    return 0;  \n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 250001,M = 1e9 + 7,b = 103;\nint cs[N],p[N],n;\nmap<int,int>mp;\nvoid add(int &a,int b){\n\ta+=b;\n\tif(a >= M)a-=M;\n\tif(a < 0)a+=M;\n}\nint power(int base,int to){\n\tint ret = 1;\n\twhile(to){\n\t\tif(to&1)ret = ret*1LL*base%M;\n\t\tto>>=1;\n\t\tbase = base*1LL*base%M;\n\t}\n\treturn ret;\n}\nint main(){\n\t//freopen(\"readin.txt\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tp[0] = 1;\n\tchar c;\n\tint inv = power(b,M - 2);\n\tfor(int i = 1;i <= n;i++){\n\t\tscanf(\" %c\",&c);\n\t\tcs[i] = cs[i - 1];\n\t\tp[i] = p[i - 1];\n\t\tif(c == '+')add(cs[i],p[i]);\n\t\telse if(c == '-')add(cs[i],-p[i]);\n\t\telse if(c == '>')p[i] = p[i]*1LL*b%M;\n\t\telse if(c == '<')p[i] = p[i]*1LL*inv%M;\n\t\tmp[cs[i]]++;\n\t}\n\tlong long ans = 0;\n\tfor(int i = 1;i <= n;i++){\n\t\tmp[cs[i]]--;\n\t\tans+=mp[(cs[n]*1LL*p[i] + cs[i] + M)%M]++;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 250001,M = 1e9 + 9,M1 = 1e9 + 7,b = 103,b1 = 11;\nint cs[N],cs1[N],p[N],p1[N],n;\nmap<pair<int,int>,int>mp;\nvoid add(int &a,int b){\n\ta+=b;\n\tif(a >= M)a-=M;\n\tif(a < 0)a+=M;\n}\nvoid add1(int &a,int b){\n\ta+=b;\n\tif(a >= M1)a-=M1;\n\tif(a < 0)a+=M1;\n}\nint power(int base,int to){\n\tint ret = 1;\n\twhile(to){\n\t\tif(to&1)ret = ret*1LL*base%M;\n\t\tto>>=1;\n\t\tbase = base*1LL*base%M;\n\t}\n\treturn ret;\n}\nint power1(int base,int to){\n\tint ret = 1;\n\twhile(to){\n\t\tif(to&1)ret = ret*1LL*base%M1;\n\t\tto>>=1;\n\t\tbase = base*1LL*base%M1;\n\t}\n\treturn ret;\n}\nint main(){\n//\tfreopen(\"readin.txt\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tp[0] = p1[0] = 1;\n\tchar c;\n\tint inv = power(b,M - 2),inv1 = power1(b1,M1 - 2);\n\tfor(int i = 1;i <= n;i++){\n\t\tscanf(\" %c\",&c);\n\t\tcs[i] = cs[i - 1];\n\t\tp[i] = p[i - 1];\n\t\tcs1[i] = cs1[i - 1];\n\t\tp1[i] = p1[i - 1];\n\t\tif(c == '+')add(cs[i],p[i]),add1(cs1[i],p1[i]);\n\t\telse if(c == '-')add(cs[i],-p[i]),add1(cs1[i],-p1[i]);\n\t\telse if(c == '>')p[i] = p[i]*1LL*b%M,p1[i] = p1[i]*1LL*b1%M1;\n\t\telse if(c == '<')p[i] = p[i]*1LL*inv%M,p1[i] = p1[i]*1LL*inv1%M1;\n\t}\n\tlong long ans = 0;\n\tfor(int i = 0;i <= n;i++){\n\t\tans+=mp[{cs[i],cs1[i]}];\n\t\tmp[{(cs[n]*1LL*p[i] + cs[i] + M)%M,(cs1[n]*1LL*p1[i] + cs1[i] + M1)%M1}]++;\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int Maxn=250005;\nconst int mod1=775731769,base1=551745917;\nconst int mod2=977783399,base2=537587201;\nconst int mod3=861044911,base3=571213603;\nint n;\nchar c[Maxn];\nconstexpr int ksm(int x,int k,int mod){\n\tint ret=1,tmp=x;\n\twhile(k){\n\t\tif(k&1)ret=1ll*ret*tmp%mod;\n\t\ttmp=1ll*tmp*tmp%mod;k>>=1;\n\t}\n\treturn ret;\n}\ntemplate<int mod,int base,int invbase=ksm(base,mod-2,mod)>\nstruct integer{\n\tint val;\n\tinteger(){val=0;}\n\tinteger(int v){val=(v%mod+mod)%mod;}\n\tint operator * (const int rhs){return 1ll*val*rhs%mod;}\n\tint operator + (const int rhs){return (val+rhs)%mod;}\n\tint operator - (const int rhs){return ((val-rhs)%mod+mod)%mod;}\n\toperator int(){return val;}\n\tvoid rf(){val=1ll*val*base%mod;}\n\tvoid rb(){val=1ll*val*invbase%mod;}\n};\ninteger<mod1,mod2,mod3>a;\ntemplate<class T>\nstruct node{\n\tT hash,cur;\n\tvoid init(){hash=0;cur=1;}\n\tvoid add(char c){\n\t\tif(c=='>')cur.rf();\n\t\tif(c=='<')cur.rb();\n\t\tif(c=='+')hash=hash+cur;\n\t\tif(c=='-')hash=hash-cur;\n\t}\n\tnode operator*(node rhs){\n\t\tnode result;\n\t\tresult.cur=cur*rhs.cur;\n\t\tresult.hash=rhs.hash*cur;\n\t\tresult.hash=result.hash+hash;\n\t\treturn result;\n\t}\n\tbool operator<(const node&rhs)const{\n\t\treturn hash.val<rhs.hash.val;\n\t}\n\tbool operator!=(const node&rhs)const{\n\t\treturn hash.val!=rhs.hash.val;\n\t}\n};\ntemplate<class T,class...args>\nstruct state{\n\tnode<T>a;\n\tstate<args...>b;\n\tvoid init(){a.init();b.init();}\n\tvoid add(char c){a.add(c);b.add(c);}\n\tbool operator<(const state&rhs)const{\n\t\tif(a!=rhs.a)return a<rhs.a;\n\t\treturn b<rhs.b;\n\t}\n\tstate operator*(const state&rhs){\n\t\tstate w;\n\t\tw.a=a*rhs.a;\n\t\tw.b=b*rhs.b;\n\t\treturn w;\n\t}\n};\ntemplate<class T>\nstruct state<T>{\n\tnode<T>a;\n\tvoid init(){a.init();}\n\tvoid add(char c){a.add(c);}\n\tbool operator<(const state&rhs)const{\n\t\treturn a<rhs.a;\n\t}\n\tstate operator*(const state&rhs){\n\t\tstate w;w.a=a*rhs.a;\n\t\treturn w;\n\t}\n};\ntypedef integer<mod1,base1> Integer1;\ntypedef integer<mod2,base2> Integer2;\ntypedef integer<mod3,base3> Integer3;\ntypedef state<Integer1,Integer2,Integer3> State;\nint main(){\n\tmap<State,int>cnt;\n\tlong long ans=0;\n\tscanf(\"%d%s\",&n,c+1);\n\tState full,prefix;\n\tfull.init();prefix.init();\n\tfor(int i=1;i<=n;i++)full.add(c[i]);\n\tfor(int i=1;i<=n;i++){\n\t\tcnt[prefix*full]++;\n\t\tprefix.add(c[i]);\n\t\tans+=cnt[prefix];\n\t}\n\tcout<<ans<<\"\\n\";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define y1 dmytxdy\n#define fi first\n#define se second\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef long double ld;\n\ntemplate <typename T> bool chkmin(T &x,T y){return x>y?x=y,1:0;}\ntemplate <typename T> bool chkmax(T &x,T y){return x<y?x=y,1:0;}\n\nint readint(){\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nconst int cys=1000000007,N=50;\nint n;\nll a[250005],b[250005],pw[250005],ipw[250005],ans[250005];\nunordered_map<ll,ll> bk;\nchar s[250005];\n\nll mod(ll x){return x>=cys?x-cys:x;}\n\nll qpow(ll x,ll p){\n\tll ret=1;\n\tfor(;p;p>>=1,x=x*x%cys) if(p&1) ret=ret*x%cys;\n\treturn ret;\n}\n\nint main(){\n\tn=readint();\n\tscanf(\"%s\",s+1);\n\tfor(int i=1;i<=n;i++) b[i]=b[i-1]+(s[i]=='>')-(s[i]=='<');\n\tmemset(ans,0x3f,sizeof(ans));\n\tfor(int ct=1;ct<=N;ct++){\n\t\tll ax=(1ll*rand()*RAND_MAX+rand())%cys,bx=qpow(ax,cys-2),p=1,now=0;\n\t\tpw[0]=ipw[0]=1;\n\t\tfor(int i=1;i<=n;i++) pw[i]=pw[i-1]*ax%cys;\n\t\tfor(int i=1;i<=n;i++) ipw[i]=ipw[i-1]*bx%cys;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(s[i]=='+') now=mod(now+p);\n\t\t\telse if(s[i]=='-') now=mod(now+cys-p);\n\t\t\telse if(s[i]=='<') p=p*bx%cys;\n\t\t\telse if(s[i]=='>') p=p*ax%cys;\n\t\t}\n\t\ta[n+1]=0;\n\t\tfor(int i=n;i>=1;i--){\n\t\t\tif(s[i]=='+') a[i]=mod(a[i+1]+1);\n\t\t\telse if(s[i]=='-') a[i]=mod(a[i+1]+cys-1);\n\t\t\telse if(s[i]=='<') a[i]=a[i+1]*bx%cys;\n\t\t\telse if(s[i]=='>') a[i]=a[i+1]*ax%cys;\n\t\t}\n\t\tfor(int i=1;i<=n;i++) a[i]=a[i]*(b[i-1]>0?pw[b[i-1]]:ipw[-b[i-1]])%cys;\n\t\tbk.clear();\n\t\tbk[0]++;\n\t\tfor(int i=n;i>=1;i--){\n\t\t\tchkmin(ans[i],bk[mod(a[i]+cys-now*(b[i-1]>0?pw[b[i-1]]:ipw[-b[i-1]])%cys)]);\n\t\t\tbk[a[i]]++;\n\t\t}\n\t}\n\tll res=0;\n\tfor(int i=1;i<=n;i++) res+=ans[i];\n\tprintf(\"%lld\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author aajisaka\n */\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n#define SPEED ios_base::sync_with_stdio(false);cin.tie(nullptr)\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define all(v) v.begin(), v.end()\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing P = pair<ll, ll>;\n\nconstexpr long double PI = 3.14159265358979323846264338327950288L;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nconstexpr ll mod17 = 1e9+7;\nconstexpr ll mod19 = 1e9+9;\nconstexpr ll mod9 = 998244353;\nll mod = mod17;\n\n// Mod int libraries\ntemplate<typename T>\nT mod_pow(T a, ll x) {\n  T res = 1;\n  while(x > 0) {\n    if (x & 1) res *= a;\n    a *= a; x >>= 1;\n  }\n  return res;\n}\n\n// Mint32\nunordered_map<ll, ll> minvmap;\nll minv(ll a, ll m) {\n  auto k = a; auto p = minvmap[a]; if (p != 0) return p;\n  ll b = m, u = 1, v = 0;\n  while (b) { ll t = a/b; swap(a -= t*b, b); swap(u -= t*v, v); }\n  p = (u%m+m)%m; minvmap[k] = p; return p;\n}\n\nstruct mint {\n  ll x;\n  mint():x(0){}\n  mint(ll x):x((x%mod+mod)%mod){}\n  mint& fix() { x = (x%mod+mod)%mod; return *this;}\n  mint operator-() const { return mint(0) - *this;}\n  mint& operator+=(const mint& a){ if((x+=a.x)>=mod) x-=mod; return *this;}\n  mint& operator-=(const mint& a){ if((x+=mod-a.x)>=mod) x-=mod; return *this;}\n  mint& operator*=(const mint& a){ (x*=a.x)%=mod; return *this;}\n  mint& operator/=(const mint& a){ (x*=minv(a.x, mod))%=mod; return *this; }\n  mint operator+(const mint& a)const{ return mint(*this) += a;}\n  mint operator-(const mint& a)const{ return mint(*this) -= a;}\n  mint operator*(const mint& a)const{ return mint(*this) *= a;}\n  mint operator/(const mint& a)const{ return mint(*this) /= a;}\n  bool operator<(const mint& a)const{ return x < a.x;}\n  bool operator==(const mint& a)const{ return x == a.x;}\n};\n\n// Mint64\nstruct mint64 {\n    ull x;\n    static ull mod, inv, r2;\n    mint64(): x(0){}\n    mint64(ull x): x(init(x)) {}\n    static ull init(ull x) { return reduce(__uint128_t(x)*r2);}\n    static void set_mod(ull m) {\n      mod = inv = m;\n      for(int i=0; i<5; i++) inv *= 2 - inv*m;\n      r2 = -__uint128_t(m)%m;\n    }\n    static ull reduce(__uint128_t x) {\n      ull y = ull(x >> 64) - ull((__uint128_t(ull(x)*inv)*mod)>>64);\n      return ll(y) < 0 ? y+mod : y;\n    }\n    mint64& operator+=(mint64& a) { x+=a.x-mod; if(ll(x)<0) x+=mod; return *this; }\n    mint64 operator+(mint64& a) const{ return mint64(*this)+=a; }\n    mint64& operator*=(mint64& a) { x=reduce(__uint128_t(x)*a.x); return *this; }\n    mint64 operator*(mint64& a) const { return mint64(*this)*=a; }\n};\n\null mint64::mod, mint64::inv, mint64::r2;\n\n// Verify: https://yukicoder.me/submissions/472580\nstruct Miller {\n    const vector<ull> v = {2, 325, 9375, 28178, 450775, 9780504, 1795265022};\n    bool suspect(ull a, ull s, ull d, ull n) {\n      if (mint64::mod != n) mint64::set_mod(n);\n      mint64 one = 1, minusone = n-1, ma = a;\n      auto x = mod_pow(ma, d);\n      if (x.x == one.x) return true;\n      for(int r = 0; r < s; r++) {\n        if (x.x == minusone.x) return true;\n        x = x * x;\n      }\n      return false;\n    }\n\n    // check if n is prime\n    bool check(ull n) {\n      if (n < 2 || (n > 2 && n % 2 == 0)) return false;\n      ull d = n - 1;\n      ull s = 0;\n      while (!(d & 1)) {\n        d >>= 1;\n        s++;\n      }\n      for (auto a: v) {\n        if (a >= n) break;\n        if (!suspect(a, s, d, n)) return false;\n      }\n      return true;\n    }\n};\n\nclass combination {\n    // factorial\n    public: std::vector<mint> fact;\n    public: std::vector<mint> inv;\n\n    combination(int n) {\n      fact.resize(n + 1);\n      inv.resize(n + 1);\n      fact[0] = 1;\n      for (int i = 1; i <= n; i++) {\n        fact[i] = fact[i - 1] * i;\n      }\n      inv[n] = mint(1) / fact[n];\n      for (int i = n - 1; i >= 0; i--) {\n        inv[i] = inv[i + 1] * (i + 1);\n      }\n    }\n\n    // nCr\n    public: mint get(int n, int r) {\n      if (n < r || n < 0 || r < 0) return 0;\n      return fact[n]*inv[r]*inv[n-r];\n    }\n    // nPr\n    public: mint p(int n, int r) {\n      if (n < r || n < 0) return 0;\n      return fact[n]*inv[n-r];\n    }\n};\n\n\nclass FEatingSymbolsHard {\npublic:\n    void solve(istream& cin, ostream& cout) {\n      SPEED;\n      int n; cin >> n;\n      string s; cin >> s;\n      vector<vector<mint>> v(6, vector<mint>(500001));\n      v[0][0] = 4;\n      v[1][0] = 11;\n      v[2][0] = 17;\n      v[3][0] = 99;\n      v[4][0] = 101;\n      v[5][0] = 1007;\n\n\n      rep(i, 6) {\n        for(int j=1; j<=500000; j++) {\n          v[i][j] = v[i][j-1] * v[i][0];\n        }\n      }\n\n      int pos = 250000;\n      map<mint, ll> mp[6];\n\n      vector<mint> now(6);\n      vector<vector<pair<mint, int>>> vec(6, vector<pair<mint, int>>(n+1));\n\n      rep(k, 6) {\n        vec[k][0] = {0, pos};\n      }\n\n      rep(k, 6) {\n        rep(i, n) {\n          if (s[i] == '+') {\n            now[k] += v[k][pos];\n          } else if (s[i] == '-') {\n            now[k] -= v[k][pos];\n          } else if (s[i] == '>') {\n            pos++;\n          } else if (s[i] == '<') {\n            pos--;\n          }\n          vec[k][i + 1] = {now[k], pos};\n        }\n      }\n      rep(k, 6) {\n        now[k] /= v[k][250000];\n      }\n\n      ll ans = 0;\n      for(int i=n; i>=0; i--) {\n        map<int, int> tmp;\n        rep(k, 6) {\n          auto q = vec[k][i].first + now[k] * v[k][vec[k][i].second];\n          if (mp[k].find(q) == mp[k].end()) {\n            tmp[0]++;\n          } else {\n            tmp[mp[k][q]]++;\n          }\n        }\n        bool flag = false;\n        for(auto e: tmp) {\n          if (e.second >= 3) {\n            ans += e.first;\n            flag = true;\n          }\n        }\n        assert(flag);\n        rep(k, 6) {\n          mp[k][vec[k][i].first]++;\n        }\n      }\n\n      cout << ans << endl;\n\n    }\n};\n\nsigned main() {\n  FEatingSymbolsHard solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<map>\nusing namespace std;\nconst int mod=998244353;\nint sed[6]={3,233,23,19260817,97,101};\nint vsed[6];\nstruct data\n{\n\tint a[6];\n\tfriend bool operator < (data a,data b)\n\t{\n\t\tfor(int i=0;i<6;++i)if(a.a[i]!=b.a[i])return a.a[i]<b.a[i];\n\t\treturn 0;\n\t}\n};\ninline int kpow(int a,int b)\n{\n\tint s=1;\n\tfor(;b;b>>=1,a=1ll*a*a%mod)\n\t\tif(b&1)s=1ll*s*a%mod;\n\treturn s;\n}\nlong long ans;\nint n,c[6],d[6];\nchar s[250050];\npair<int,int>s1[6];\nmap<data,int>mp;\nvoid work(char cur)\n{\n\tfor(int i=0;i<6;++i)\n\t{\n\t\tif(cur=='>')s1[i].first=1ll*s1[i].first*vsed[i]%mod;\n\t\telse if(cur=='<')s1[i].first=1ll*s1[i].first*sed[i]%mod;\n\t\telse if(cur=='+')(s1[i].second+=s1[i].first)%=mod;\n\t\telse (s1[i].second+=mod-s1[i].first)%=mod;\t\n\t}\n}\ndata get(int x[6])\n{\n\tstatic data now;\n\tfor(int i=0;i<6;++i)now.a[i]=(1ll*x[i]*s1[i].first+s1[i].second)%mod;\n\treturn now;\n}\nint main()\n{\n\tfor(int i=0;i<6;++i)vsed[i]=kpow(sed[i],mod-2);\n\tscanf(\"%d %s\",&n,s+1);\n\tfor(int i=n;i;--i)\n\t\tfor(int j=0;j<6;++j)\n\t\t{\n\t\t\tif(s[i]=='>')c[j]=1ll*c[j]*vsed[j]%mod;\n\t\t\telse if(s[i]=='<')c[j]=1ll*c[j]*sed[j]%mod;\n\t\t\telse if(s[i]=='+')(c[j]+=1)%=mod;\n\t\t\telse (c[j]+=mod-1)%=mod;\t\t\t\n\t\t}\n\tfor(int j=0;j<6;++j)s1[j].first=1;\n\t++mp[get(c)];\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\twork(s[i]);\n\t\tans+=mp[get(d)];\n\t\t++mp[get(c)];\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <map>\n#define MN 250005\n\nconst long long mod = 213668850274623167;\nconst long long base = 257;\nchar s[MN];\nlong long c[MN];\nlong long fac[MN], inv[MN];\nstd::map<long long, int> mp;\n\nlong long mul(long long a, long long b)\n{\n\ta = (a + mod) % mod;\n\tb = (b + mod) % mod;\n\treturn (a * b - (long long)((long double) a / mod * b) * mod + mod) % mod;\n}\n\nlong long qpow(long long x, long long p)\n{\n\tlong long ans = 1;\n\twhile(p)\n\t{\n\t\tif(p & 1) ans = mul(ans, x);\n\t\tx = mul(x, x); p >>= 1;\n\t}\n\treturn ans;\n}\n\nvoid add(int x, int o, long long &now)\n{\n\tlong long u;\n\tif(x < 0) u = inv[-x];\n\telse u = fac[x];\n\tnow = (mul(u, o) + now) % mod;\n}\n\nint main()\n{\n\tint n; scanf(\"%d\", &n);\n\tscanf(\"%s\", s);\n\tlong long p = 0, now = 0;\n\tinv[1] = qpow(base, mod - 2);\n\tfac[0] = 1; fac[1] = base;\n\tfor(int i = 2; i <= n; i++) inv[i] = mul(inv[i - 1], inv[1]), fac[i] = mul(fac[i - 1], fac[1]);\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif(s[i] == '<') p--;\n\t\tif(s[i] == '>') p++;\n\t\tif(s[i] == '+') add(p, 1, now);\n\t\tif(s[i] == '-') add(p, -1, now);\n\t}\n\tlong long e = now; p = 0; now = 0;\n\tmp[e]++;\n\tlong long ans = 0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif(s[i] == '<') p--;\n\t\tif(s[i] == '>') p++;\n\t\tif(s[i] == '+') add(p, 1, now);\n\t\tif(s[i] == '-') add(p, -1, now);\n\t\tlong long u;\n\t\tif(p < 0) u = inv[-p];\n\t\telse u = fac[p];\n\t\tans += mp[now];\n\t\tmp[(mul(e, u) + now ) % mod]++;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nnamespace mine\n{\n    typedef long long ll;\n    #define pr pair<int,int>\n    #define FR first\n    #define SE second\n    #define MP make_pair\n    #define PB push_back\n    #define vc vector\n    #define all(x) (x).begin(),(x).end()\n    #define sz(x) ((int)(x).size())\n    #define bin(x) (1ll<<(x))\n    #define GG(x) if(x) {puts(\"error\");exit(666);}\n    #define fo(i,l,r) for(int i=(l),I=(r);i<=I;i++)\n    #define fd(i,r,l) for(int i=(r),I=(l);i>=I;i--)\n    ll qread()\n    {\n        ll ans=0,f=1;char c=getchar();\n        while(c<'0' or c>'9') {if(c=='-')f=-1;c=getchar();}\n        while('0'<=c and c<='9') ans=ans*10+c-'0',c=getchar();\n        return ans*f;\n    }\n    void write(ll num)\n    {\n        if(num<0) putchar('-'),num=-num;\n        if(num>=10) write(num/10);\n        putchar('0'+num%10);\n    }\n    void write1(ll num){write(num);putchar(' ');}\n    void write2(ll num){write(num);putchar('\\n');}\n    template<typename T> void chmax(T &x,const T y) {x=(x>y?x:y);}\n    template<typename T> void chmin(T &x,const T y) {x=(x<y?x:y);}\n    ll gcd(ll x,ll y){return y?gcd(y,x%y):x;}\n\n    const int INF=0x3f3f3f3f;\n    const int MOD=998244353;\n    inline int mm(const int x){return x>=MOD?x-MOD:x;}\n    template<typename T> inline void add(T &x,const T y){x=mm(x+y);}\n    inline ll qpower(ll x,ll e,int mod=MOD){ll ans=1;GG(e<0);while(e){if(e&1)ans=ans*x%mod;x=x*x%mod;e>>=1;}return ans;}\n    ll invm(ll x){return qpower(x,MOD-2);}\n    const int N=1e6+10;\n\n    const int MM=9;\n    const int base[MM+1]={131,13331,131,13331,2333, 66666666,13331,131,13331,2333};\n    const int mod[MM+1]={998244353,998244353,1000000007,993244853,1000000009,1000000007,998244353,993244853,993244853,998244353};\n    struct Data\n    {\n        ll state[MM+1],bs[MM+1];\n        Data(){fo(i,0,MM)state[i]=0,bs[i]=1;}\n        friend bool operator < (Data x,Data y)\n        {\n            fo(i,0,MM) if(x.state[i]!=y.state[i]) return x.state[i]<y.state[i];\n            return 0;\n        }\n        void insert(char c)\n        {\n            if(c=='+' or c=='-')\n            {\n                fo(i,0,MM) (state[i]+=bs[i]*(c=='+'?1:mod[i]-1) )%=mod[i];\n            } else\n            {\n                fo(i,0,MM) (bs[i]*=(c=='>'?base[i]:qpower(base[i],mod[i]-2,mod[i])) )%=mod[i];\n            }\n        }\n        void output()\n        {\n            fo(i,0,MM) printf(\"(%lld,%lld) \",state[i],bs[i]);\n            puts(\"\");\n        }\n    };\n    Data merg(Data left,Data right)\n    {\n        fo(i,0,MM) (left.state[i]+=left.bs[i]*right.state[i])%=mod[i],(left.bs[i]*=right.bs[i])%=MOD;\n        return left;\n    }\n    map<Data,int> mp;\n\n    char str[N];\n    void main()\n    {\n        int n=qread();scanf(\"%s\",str+1);\n        Data all;fo(i,1,n) all.insert(str[i]);mp[all]++;//all.output();\n        ll ans=0;Data now;\n        fo(r,1,n)\n        {\n            now.insert(str[r]);\n            // now.output();\n            ans+=mp[now];\n            mp[merg(now,all)]++;\n            // merg(now,all).output();\n            // puts(\"\");\n        }write(ans);\n    }\n};//(ans+MOD)%MOD\nsigned main()\n{\n    srand(time(0));\n    mine::main();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n// #undef DEBUG\n// #define DEBUG\n/// {{{ DEBUG --- ///\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { if(&o == &cerr) { o << '{'; for(size_t i = 0; i < v.size(); i++) o << v[i] << (i + 1 != v.size() ? \", \" : \"\"); o << \"}\"; } else { for(size_t i = 0; i < v.size(); i++) o << v[i] << (i + 1 != v.size() ? \" \" : \"\"); } return o; }\n#ifdef DEBUG\n#ifdef USE_COUT\n#define dump(...) (cout<<\"[\"<<__LINE__<< \"] \"<<#__VA_ARGS__<<\" = \"<<make_tuple(__VA_ARGS__)<<\"\\n\")\n#else\n#define dump(...) (cerr<<\"[\"<<__LINE__<< \"] \"<<#__VA_ARGS__<<\" = \"<<make_tuple(__VA_ARGS__)<<\"\\n\")\n#endif\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\", \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream &o, tuple<T...> const &t){ o << \"(\"; _ot<0>(o, t); o << \")\"; return o; }\ntemplate<class T, class U> ostream & operator<<(ostream &o, pair<T, U> const &p) { o << \"(\" << p.first << \", \" << p.second << \")\"; return o; }\n#else\n#define dump(...) (0)\n#endif\n/// }}}--- ///\n\nll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a % b); }\nll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\nll extgcd(ll a, ll b, ll &x, ll &y) { ll d; return b == 0 ? (x = 1, y = 0, a) : (d = extgcd(b, a % b, y, x), y -= a / b * x, d); }\nll modinv(ll a, ll mod = 1e9 + 7) { ll x = 0, y = 0; extgcd(a, mod, x, y); return (x + mod) % mod; }\nll modpow(ll a, ll b, ll mod = 1e9 + 7) { ll r = 1; a %= mod; while(b) { if(b & 1) r = r * a % mod; a = a * a % mod; b >>= 1; } return r; }\n\nconst int N = 250000 + 10;\nconst ll mod = 1e9 + 7;\n// vector<ll> gen{114514, 1919, 810, -114514, -1919, -810};\nvector<ll> gen{114514, 1919};\nvector<map<ll, int>> Aex(gen.size()), Bex = Aex;\nint n;\nstring s;\nint ms[N];\nll calc(int i, int c, ll x) {\n  if(i == 0) {\n    // A\n    if(c <= 1) return 1;\n    if(c == 2) return modinv(x, mod);\n    return x;\n  } else {\n    if(c == 0) return 1;\n    if(c == 1) return -1;\n    return 0;\n  }\n}\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  cin >> n >> s;\n  vector<vector<ll>> A(gen.size(), vector<ll>(n+2)), B = A;\n  for(int i = 0; i < n; i++) {\n    if(s[i] == '+') ms[i] = 0;\n    else if(s[i] == '-') ms[i] = 1;\n    else if(s[i] == '>') ms[i] = 2;\n    else ms[i] = 3;\n  }\n  for(int k = 0; k < gen.size(); k++) {\n    gen[k] = ((gen[k] % mod + mod) % mod);\n    ll x = gen[k];\n    A[k][1] = 1;\n    B[k][1] = 0;\n    for(int i = 0; i < n; i++) {\n      A[k][i+2] = A[k][i+1] * calc(0, ms[i], x) % mod;\n      B[k][i+2] = A[k][i+1] * calc(1, ms[i], x) % mod + B[k][i+1];\n      B[k][i+2] = ((B[k][i+2] % mod + mod) % mod);\n      Bex[k][B[k][i+2]]++;\n    }\n  }\n  // dump(A[0]);\n  // dump(B[0]);\n  ll ans = 0;\n  for(int i = 0; i < n; i++) {\n    ll mi = -1;\n    for(int k = 0; k < gen.size(); k++) {\n      ll c = A[k][i+1] * B[k][n+1] % mod;\n      c += B[k][i+1];\n      c %= mod;\n      ll cnt = Bex[k][c];\n      // dump(i, c, cnt);\n      if(cnt != mi) mi = cnt;\n      else break;\n    }\n    for(int k = 0; k < gen.size(); k++) Bex[k][B[k][i+2]]--;\n    // dump(i, mi);\n    ans += mi;\n  }\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2)\n#include<bits/stdc++.h>\n#define ll long long\n#define maxn 500005\n#define inf 1e9\n#define eps 1e-10\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,w=1; char c=getchar();\n\twhile(c<'0'||c>'9') {if(c=='-') w=-1; c=getchar();}\n\twhile(c<='9'&&c>='0') {x=(x<<1)+(x<<3)+c-'0'; c=getchar();}\n\treturn w==1?x:-x;\n}\n\nmap <ll,int> p;\nll b[maxn],inv[maxn],ans;\nint len,n;\nchar s[maxn];\nconst ll mod=998244353;\nconst ll P=844009174;\n\ninline ll pw(ll a,ll b)\n{\n\tll ans=1,base=a;\n\twhile(b)\n\t{\n\t\tif(b&1) ans=(ans*base)%mod;\n\t\tbase=(base*base)%mod; b>>=1;\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\t//freopen(\"t1.out\",\"w\",stdout);\n\tn=read(); scanf(\"%s\",s+1); b[0]=1; inv[0]=1; len=strlen(s+1);\n\tfor(int i=1;i<=maxn-5;i++) b[i]=(b[i-1]*233)%mod,inv[i]=pw(b[i],mod-2);\n\t//cout<<571216159*inv[1]%mod<<endl;\n\tll ed=0,nw=250000;\n\t\n\t//cout<<b[nw-1]+b[nw+1]<<endl;\n\t\n\tfor(int i=1;i<=len;i++)\n\t{\n\t\tif(s[i]=='+') ed=(ed+b[nw])%mod;\n\t\telse if(s[i]=='-') ed=(ed-b[nw])%mod;\n\t\telse if(s[i]=='>') nw++;\n\t\telse if(s[i]=='<') nw--; p[ed]++;\n\t\t//cout<<s[i]<<\" \"<<ed<<\" \"<<nw<<endl;\n\t}\n\t//cout<<ed<<\" \"<<nw<<endl<<endl;\n\tll tmp=0; nw=250000; ans=0;\n\tfor(int i=1;i<=len;i++)\n\t{\n\t\tans+=p[(tmp+ed*b[nw-250000])%mod];\n\t\t//ans+=p[(tmp+ed*b[nw])%mod];\n\t\tif(s[i]=='+') tmp=(tmp+b[nw])%mod;\n\t\telse if(s[i]=='-') tmp=(tmp-b[nw])%mod;\n\t\telse if(s[i]=='>') nw++;\n\t\telse if(s[i]=='<') nw--;\n\t\tll p2=0;\n\t\tif(nw>=250000) p2=(p2*b[nw-250000])%mod;\n\t\telse p2=(p2*inv[250000-nw])%mod;\n\t\t//ans+=p[(tmp+ed*b[nw-250000])%mod];\n\t\t//cout<<(tmp+ed*b[nw-250000])%mod<<\" \"<<tmp<<\" \"<<nw<<\" \"<<ans<<endl;\n\t\tp[tmp]--;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int Maxn=250005;\nconst int mod1=1e9+7,base1=998244353,invbase1=4924091;\nconst int mod2=1e9+7,base2=998244353,invbase2=4924091;\nconst int mod3=1e9+7,base3=998244353,invbase3=4924091;\nint n;\nchar c[Maxn];\nconstexpr int ksm(int x,int k,int mod){\n\tint ret=1,tmp=x;\n\twhile(k){\n\t\tif(k&1)ret=1ll*ret*tmp%mod;\n\t\ttmp=1ll*tmp*tmp%mod;k>>=1;\n\t}\n\treturn ret;\n}\ntemplate<int mod,int base,int invbase=ksm(base,mod-2,mod)>\nstruct integer{\n\tint val;\n\tinteger(){val=0;}\n\tinteger(int v){val=(v%mod+mod)%mod;}\n\tint operator * (const int rhs){return 1ll*val*rhs%mod;}\n\tint operator + (const int rhs){return (val+rhs)%mod;}\n\tint operator - (const int rhs){return ((val-rhs)%mod+mod)%mod;}\n\toperator int(){return val;}\n\tvoid rf(){val=1ll*val*base%mod;}\n\tvoid rb(){val=1ll*val*invbase%mod;}\n};\ninteger<mod1,mod2,mod3>a;\ntemplate<class T>\nstruct node{\n\tT hash,cur;\n\tvoid init(){hash=0;cur=1;}\n\tvoid add(char c){\n\t\tif(c=='>')cur.rf();\n\t\tif(c=='<')cur.rb();\n\t\tif(c=='+')hash=hash+cur;\n\t\tif(c=='-')hash=hash-cur;\n\t}\n\tnode operator*(node rhs){\n\t\tnode result;\n\t\tresult.cur=cur*rhs.cur;\n\t\tresult.hash=rhs.hash*cur;\n\t\tresult.hash=result.hash+hash;\n\t\treturn result;\n\t}\n\tbool operator<(const node&rhs)const{\n\t\treturn hash.val<rhs.hash.val;\n\t}\n\tbool operator!=(const node&rhs)const{\n\t\treturn hash.val!=rhs.hash.val;\n\t}\n};\ntemplate<class T,class...args>\nstruct state{\n\tnode<T>a;\n\tstate<args...>b;\n\tvoid init(){a.init();b.init();}\n\tvoid add(char c){a.add(c);b.add(c);}\n\tbool operator<(const state&rhs)const{\n\t\tif(a!=rhs.a)return a<rhs.a;\n\t\treturn b<rhs.b;\n\t}\n\tstate operator*(const state&rhs){\n\t\tstate w;\n\t\tw.a=a*rhs.a;\n\t\tw.b=b*rhs.b;\n\t\treturn w;\n\t}\n};\ntemplate<class T>\nstruct state<T>{\n\tnode<T>a;\n\tvoid init(){a.init();}\n\tvoid add(char c){a.add(c);}\n\tbool operator<(const state&rhs)const{\n\t\treturn a<rhs.a;\n\t}\n\tstate operator*(const state&rhs){\n\t\tstate w;w.a=a*rhs.a;\n\t\treturn w;\n\t}\n};\ntypedef integer<mod1,base1> Integer1;\ntypedef integer<mod1,base1> Integer2;\ntypedef integer<mod1,base1> Integer3;\ntypedef state<Integer1,Integer2,Integer3> State;\nint main(){\n\tmap<State,int>cnt;\n\tlong long ans=0;\n\tscanf(\"%d%s\",&n,c+1);\n\tState full,prefix;\n\tfull.init();prefix.init();\n\tfor(int i=1;i<=n;i++)full.add(c[i]);\n\tfor(int i=1;i<=n;i++){\n\t\tcnt[prefix*full]++;\n\t\tprefix.add(c[i]);\n\t\tans+=cnt[prefix];\n\t}\n\tcout<<ans<<\"\\n\";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <random>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef unsigned long long ull;\nconst int med=250000;\null powmod(ull a, ll k){\n    if(a==0) return 0;\n    ull ap=a, ans=1;\n    while(k>0){\n        if(k%2==1){\n            ans*=ap;\n        }\n        ap=ap*ap;\n        k/=2;\n    }\n    return ans;\n}\null inv(ull a){\n\treturn powmod(a, (1ll<<63)-1);\n}\n\nint main()\n{\n\tint n;\n\tcin>>n;\n\t//char s[250000];\n  //for(int i=0; i<n; i++){\n    //if(i%4==0) s[i]='+';\n    //else if(i%4==1) s[i]='<';\n    //else if(i%4==2) s[i]='>';\n    //else s[i]='-';\n  //}\n  string s; cin>>s;\n    //random_device rnd;\n\t//mt19937_64 mt(rnd());\n\t//uniform_int_distribution<ll> rndn(2, MOD-2);\n\t//ll b=rndn(mt);\n  ull b=67;\n\tull binv=inv(b);\n\tull bp[500001];\n\tbp[med]=1;\n\tfor(int i=med+1; i<=med+n; i++) bp[i]=bp[i-1]*b;\n\tfor(int i=med-1; i>=med-n; i--) bp[i]=bp[i+1]*binv;\n\tull b0=0; int p=med;\n\tfor(int i=0; i<n; i++){\n\t\tif(s[i]=='+'){\n\t\t\tb0=b0+bp[p];\n\t\t}else if(s[i]=='-'){\n\t\t\tb0=b0-bp[p];\n\t\t}else if(s[i]=='>'){\n\t\t\tp++;\n\t\t}else{\n\t\t\tp--;\n\t\t}\n\t}\n\tll ans=0;\n\tull x[250000]={};\n\tunordered_map<ull, int> mp[500];\n\tint c1[500]={};\n\tull c0[500]={};\n\tint sq=2000;\n\tfor(int i=0; i<n; i++){\n\t\tif(s[n-1-i]=='+'){\n\t\t\tfor(int j=i/sq*sq; j<=i; j++){\n\t\t\t\tx[j]++;\n\t\t\t}\n\t\t\tfor(int j=0; j<i/sq; j++){\n\t\t\t\tc0[j]++;\n\t\t\t}\n\t\t}else if(s[n-1-i]=='-'){\n\t\t\tfor(int j=i/sq*sq; j<=i; j++){\n\t\t\t\tx[j]--;\n\t\t\t}\n\t\t\tfor(int j=0; j<i/sq; j++){\n\t\t\t\tc0[j]--;\n\t\t\t}\n\t\t}else if(s[n-1-i]=='>'){\n\t\t\tfor(int j=i/sq*sq; j<=i; j++){\n\t\t\t\tx[j]*=b;\n\t\t\t}\n\t\t\tfor(int j=0; j<i/sq; j++){\n\t\t\t\tc1[j]++;\n\t\t\t\tc0[j]*=b;\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int j=i/sq*sq; j<=i; j++){\n\t\t\t\tx[j]*=binv;\n\t\t\t}\n\t\t\tfor(int j=0; j<i/sq; j++){\n\t\t\t\tc1[j]--;\n\t\t\t\tc0[j]*=binv;\n\t\t\t}\n\t\t}\n\t\tfor(int j=0; j<i/sq; j++){\n\t\t\tull x0=(b0-c0[j])*bp[med-c1[j]];\n\t\t\tauto itr=mp[j].find(x0);\n          if(itr!=mp[j].end()) ans+=((ll)(itr->second));\n\t\t}\n\t\tfor(int j=i/sq*sq; j<=i; j++){\n\t\t\tif(b0==x[j]) ans++;\n\t\t}\n\t\tif((i+1)%sq==0){\n\t\t\tfor(int j=i/sq*sq; j<=i; j++){\n\t\t\t\tmp[i/sq][x[j]]++;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <list>\n#include <time.h>\n#include <math.h>\n#include <random>\n#include <deque>\n#include <queue>\n#include <cassert>\n#include <unordered_map>\n#include <unordered_set>\n#include <iomanip>\n#include <bitset>\n#include <sstream>\n\nusing namespace std;\n\ntypedef long long ll;\n\nmt19937 rnd(228);\n\nconst int M = 1791791791;\nconst int M1 = 1e9 + 7;\nconst int M2 = 1e9 + 9;\nconst int B = 239;\nconst int B1 = 228;\nconst int B2 = 337;\n\ninline int add(ll a, ll b, int M)\n{\n    a += b;\n    if (a >= M) a -= M;\n    if (a < 0) a += M;\n    return a;\n}\n\ninline int mul(int a, int b, int M)\n{\n    return (a * (ll) b) % M;\n}\n\ninline int bin(int a, int n, int M)\n{\n    int res = 1;\n    while (n)\n    {\n        if (n % 2 == 0)\n        {\n            a = mul(a, a, M);\n            n /= 2;\n        }\n        else\n        {\n            res = mul(res, a, M);\n            n--;\n        }\n    }\n    return res;\n}\n\nconst int rev_B = bin(B, M - 2, M);\nconst int rev_B1 = bin(B1, M1 - 2, M1);\nconst int rev_B2 = bin(B2, M2 - 2, M2);\n\nstring s;\nint n;\n\nint main()\n{\n#ifdef ONPC\n    freopen(\"a.in\", \"r\", stdin);\n#endif\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cin >> n;\n    cin >> s;\n    int cur = 1;\n    int hsh = 0;\n    vector <int> p(n + 1);\n    vector <int> p1(n + 1);\n    vector <int> p2(n + 1);\n    vector <int> h(n + 1);\n    vector <int> h1(n + 1);\n    vector <int> h2(n + 1);\n    p[0] = 1;\n    p1[0] = 1;\n    p2[0] = 1;\n    h[0] = 0;\n    h1[0] = 0;\n    h2[0] = 0;\n    int cur_1 = 1;\n    int hsh_1 = 0;\n    int cur_2 = 1;\n    int hsh_2 = 0;\n    for (int i = 0; i < n; i++)\n    {\n        if (s[i] == '>')\n        {\n            cur = mul(cur, B, M);\n            cur_1 = mul(cur_1, B1, M1);\n            cur_2 = mul(cur_2, B2, M2);\n        }\n        else if (s[i] == '<')\n        {\n            cur = mul(cur, rev_B, M);\n            cur_1 = mul(cur_1, rev_B1, M1);\n            cur_2 = mul(cur_2, rev_B2, M2);\n        }\n        else if (s[i] == '+')\n        {\n            hsh = add(hsh, cur, M);\n            hsh_1 = add(hsh_1, cur_1, M1);\n            hsh_2 = add(hsh_2, cur_2, M2);\n        }\n        else\n        {\n            hsh = add(hsh, -cur, M);\n            hsh_1 = add(hsh_1, -cur_1, M1);\n            hsh_2 = add(hsh_2, -cur_2, M2);\n        }\n        p[i + 1] = cur;\n        h[i + 1] = hsh;\n        p1[i + 1] = cur_1;\n        h1[i + 1] = hsh_1;\n        p2[i + 1] = cur_2;\n        h2[i + 1] = hsh_2;\n    }\n    ll ans = 0;\n    map <pair <int, pair <int, int> > , int> ret;\n    for (int i = n; i >= 0; i--)\n    {\n        int need = add(mul(hsh, p[i], M), h[i], M);\n        int need_1 = add(mul(hsh_1, p1[i], M1), h1[i], M1);\n        int need_2 = add(mul(hsh_2, p2[i], M2), h2[i], M2);\n        ans += ret[{need, {need_1, need_2}}];\n        ret[{h[i], {h1[i], h2[i]}}]++;\n    }\n    cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nconst Int MAX = 514514;\nconst Int MOD1 = 1e9+7;\nconst Int MOD2 = 1e9+9;\nconst Int MOD3 = 1e8+7;\nconst Int BASE = 1777771;\n\nInt po1[MAX],po2[MAX],po3[MAX];\nInt op1[MAX],op2[MAX],op3[MAX];\n\nInt mod_pow(Int x,Int n,Int mod){\n  Int res=1;\n  while(n){\n    if(n&1) (res*=x)%=mod;\n    (x*=x)%=mod;\n    n>>=1;\n  }\n  return res;\n}\n\nInt mod_inverse2(Int a,Int mod){\n  return mod_pow(a,mod-2,mod);\n}\n\nInt inv1,inv2,inv3;\n\nusing T = tuple<Int, Int, Int>;\nstruct HS{\n  T v;\n  HS():v(0,0,0){}\n  HS(T v):v(v){}\n  void inc(Int x){\n    get<0>(v)+=po1[x];\n    get<0>(v)%=MOD1;\n    get<1>(v)+=po2[x];\n    get<1>(v)%=MOD2;\n    get<2>(v)+=po3[x];\n    get<2>(v)%=MOD3;\n  }\n  void dec(Int x){\n    get<0>(v)+=MOD1-po1[x];\n    get<0>(v)%=MOD1;\n    get<1>(v)+=MOD2-po2[x];\n    get<1>(v)%=MOD2;\n    get<2>(v)+=MOD3-po3[x];\n    get<2>(v)%=MOD3;\n  }\n  void shl(Int k=1){\n    get<0>(v)*=op1[k];\n    get<0>(v)%=MOD1;\n    get<1>(v)*=op2[k];\n    get<1>(v)%=MOD2;\n    get<2>(v)*=op3[k];\n    get<2>(v)%=MOD3;\n  }\n  void shr(Int k=1){\n    get<0>(v)*=po1[k];\n    get<0>(v)%=MOD1;\n    get<1>(v)*=po2[k];\n    get<1>(v)%=MOD2;\n    get<2>(v)*=po3[k];\n    get<2>(v)%=MOD3;\n  }\n\n  HS mv(Int k){\n    HS a(v);\n    if(k<0) a.shl(-k);\n    else a.shr(k);\n    return a;\n  }\n\n  HS operator+(const HS a) const{\n    T x(v);\n    get<0>(x)+=get<0>(a.v);\n    get<0>(x)%=MOD1;\n    get<1>(x)+=get<1>(a.v);\n    get<1>(x)%=MOD2;\n    get<2>(x)+=get<2>(a.v);\n    get<2>(x)%=MOD3;\n\n    return HS(x);\n  }\n  \n  HS operator-(const HS a) const{\n    T x(v);\n    get<0>(x)+=MOD1-get<0>(a.v);\n    get<0>(x)%=MOD1;\n    get<1>(x)+=MOD2-get<1>(a.v);\n    get<1>(x)%=MOD2;\n    get<2>(x)+=MOD3-get<2>(a.v);\n    get<2>(x)%=MOD3;\n\n    return HS(x);\n  }\n  \n  void print(){\n    cout<<endl;\n    Int a,b,c;\n    tie(a,b,c)=v;\n    cout<<a<<\" \"<<b<<\" \"<<c<<endl;\n    cout<<endl;\n  }\n  \n};\n\nsigned main(){\n  Int n;\n  string s;\n  cin>>n>>s;\n\n  po1[0]=po2[0]=po3[0]=1;\n  op1[0]=op2[0]=op3[0]=1;\n  inv1=mod_inverse2(BASE,MOD1);\n  inv2=mod_inverse2(BASE,MOD2);\n  inv3=mod_inverse2(BASE,MOD3);\n  for(Int i=1;i<MAX;i++){\n    po1[i]=po1[i-1]*BASE%MOD1;\n    po2[i]=po2[i-1]*BASE%MOD2;\n    po3[i]=po3[i-1]*BASE%MOD3;  \n    op1[i]=op1[i-1]*inv1%MOD1;\n    op2[i]=op2[i-1]*inv2%MOD2;\n    op3[i]=op3[i-1]*inv3%MOD3;    \n  }\n  \n  Int p=MAX/2,q=p;\n  vector<Int> ps(n+1);\n  HS bs;\n  for(Int i=n;i>0;i--){\n    ps[i]=p;\n    if(s[i-1]=='+') bs.inc(q);\n    if(s[i-1]=='-') bs.dec(q);\n    if(s[i-1]=='>') bs.shr(),p--;\n    if(s[i-1]=='<') bs.shl(),p++;    \n  }\n  ps[0]=p;\n  \n  HS hs;\n  map<T, Int> vm;\n  for(Int i=n;i>0;i--){\n    vm[(hs-bs).mv(ps[i]).v]++;\n    //(hs-bs).mv(ps[i]).print();\n    if(s[i-1]=='+') hs.inc(q);\n    if(s[i-1]=='-') hs.dec(q);\n    if(s[i-1]=='>') hs.shr();\n    if(s[i-1]=='<') hs.shl();    \n  }\n  vm[(hs-bs).mv(ps[0]).v]++;\n  \n  Int ans=0;\n  HS dp;\n  for(Int i=n;i>0;i--){\n    vm[(dp-bs).mv(ps[i]).v]--;\n    ans+=vm[dp.mv(ps[i]).v];\n    //cout<<i<<\":\"<<vm[dp.mv(ps[i]).v]<<endl;\n    //dp.mv(ps[i]).print();\n    if(s[i-1]=='+') dp.inc(q);\n    if(s[i-1]=='-') dp.dec(q);\n    if(s[i-1]=='>') dp.shr();\n    if(s[i-1]=='<') dp.shl();\n  }\n  \n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#include<cmath>\n#define MN 250005\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long ll;\nconst ll M1=233;\nconst ll mod=4179340454199820289ll;\nvoid add(ll &x,ll y){(x+=y)>=mod?x-=mod:0;}\nvoid dec(ll &x,ll y){(x-=y)<0?x+=mod:0;}/*\null mul(ull x, ull y)\n{\n\tx = (x % mod + mod) % mod;\n\ty = (y % mod + mod) % mod;\n\treturn (x * y - (ll)((long double)x / mod * y) * mod + mod) % mod;\n}*/\nll mul(ll x,ll y){\n\tll tmp=0;\n\twhile(y){\n\t\tif(y&1)add(tmp,x);\n\t\tadd(x,x);y>>=1;\n\t}return tmp;\n}\nll qpow(ll x,ll y){\n\tll tmp=1;\n\twhile(y){\n\t\tif(y&1)tmp=mul(tmp,x);\n\t\tx=mul(x,x);y>>=1;\n\t}return tmp;\n}\nint n,pos[MN];char s[MN];\nmap<ll,int> mp;\nll lh[MN],rh[MN],fac[MN<<1],ans;\nint main(){\n\tscanf(\"%d%s\",&n,s+1);/*fac[0]=1;\n\tfor(int i=1;i<=2*n;i++)fac[i]=mul(fac[i-1],M1);\n\tfor(int i=1;i<=n;i++){\n\t\tpos[i]=pos[i-1],lh[i]=lh[i-1];\n\t\tif(s[i]=='<')pos[i]++;\n\t\telse if(s[i]=='>')pos[i]--;\n\t\telse if(s[i]=='+')add(lh[i],fac[n+pos[i]]);\n\t\telse if(s[i]=='-')dec(lh[i],fac[n+pos[i]]);\n\t\tmp[lh[i]]++;\n\t}ans+=mp[lh[n]];ull tmp=lh[n];\n\tfor(int i=1;i<=n;i++){\n\t\tif(s[i]=='<')tmp=mul(tmp,M1);\n\t\telse if(s[i]=='>')tmp=mul(tmp,inv);\n\t\telse if(s[i]=='+')add(tmp,fac[n+pos[i]]);\n\t\telse dec(tmp,fac[n+pos[i]]);\n\t\tans+=mp[tmp];mp[lh[i]]--;\n\t}*/ll X=1,Y=0,x=M1,y=qpow(x,mod-2);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tlh[i]=lh[i-1];\n\t\tif(s[i]=='+')add(lh[i],X);\n\t\tif(s[i]=='-')dec(lh[i],X);\n\t\tif(s[i]=='<')X=mul(X,x);\n\t\tif(s[i]=='>')X=mul(X,y);\n\t\t++mp[lh[i]];\n\t}X=1;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tll tmp=mul(lh[n],X);add(tmp,Y);\n\t\tans+=mp[tmp];\n\t\tif(s[i]=='+')add(Y,X);\n\t\tif(s[i]=='-')dec(Y,X);\n\t\tif(s[i]=='<')X=mul(X,x);\n\t\tif(s[i]=='>')X=mul(X,y);\n\t\t--mp[lh[i]];\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int mo = 998244353, X = 1e4 + 7;\nconst int N = 2.5e5 + 10;\nint n;\nll cnt[N], pre[N], X1;\nchar s[N];\nll ksm(ll x, ll y) {\n\tll ret = 1; for (; y; y >>= 1) {\n\t\tif (y & 1) ret = ret * x % mo;\n\t\tx = x * x % mo;\n\t}\n\treturn ret;\n}\n\nmap<ll,int> h;\nll tj(int x) {\n\treturn ((pre[n] * cnt[x] % mo + pre[x]) % mo + mo) % mo;\n}\n\nint main() {\n\tcin >> n;\n\tscanf(\"%s\", s + 1);\n\tcnt[0] = 1;\n\tX1 = ksm(X, mo - 2);\n\tfor(int i = 1; i <= n; i++) {\n\t\tcnt[i] = cnt[i - 1];\n\t\tpre[i] = pre[i - 1];\n\t\tif (s[i] == '>') {\n\t\t\tcnt[i] = cnt[i] * X % mo;\n\t\t} else if (s[i] == '<') {\n\t\t\tcnt[i] = cnt[i] * X1 % mo;\n\t\t} else if (s[i] == '+') {\n\t\t\tpre[i] = (pre[i] + cnt[i]) % mo;\n\t\t} else {\n\t\t\tpre[i] = (pre[i] - cnt[i]) % mo;\n\t\t}\n\t}\n\tll ans = 0;\n\th[tj(0)] = 1;\n\tfor(int i = 1; i <= n; i++) {\n\t\tpre[i] = (pre[i] + mo) % mo;\n\t\tans += h[pre[i]];\n\t\th[tj(i)] ++;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<iostream>\n#define LLu unsigned long long\nusing namespace std;\nchar s[250010];\nLLu base=233,inv=7204522363551799129,f[250010],X=1,Y,ans=0;\nint n;\nmap<LLu,int> mp;\nint main()\n{\n\tscanf(\"%d\",&n);getchar();\n\tscanf(\"%s\",s+1);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tf[i]=f[i-1];\n\t\tif(s[i]=='+') f[i]+=X;\n\t\tif(s[i]=='-') f[i]-=X;\n\t\tif(s[i]=='<') X*=base;\n\t\tif(s[i]=='>') X*=inv;\n\t\tmp[f[i]]++;\n\t}\n\tX=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tans+=mp[f[n]*X+Y];\n\t\tif(s[i]=='+') Y+=X;\n\t\tif(s[i]=='-') Y-=X;\n\t\tif(s[i]=='<') X*=base;\n\t\tif(s[i]=='>') X*=inv;\n\t\tmp[f[i]]--;\n\t}\n\tprintf(\"%llu\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <vector>\n\nconst int DEBUG = 0;\n\n#define MOCK 1\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define DEBUGP(val) cerr << #val << \"=\" << val << \"\\n\"\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\ntypedef pair<ll, ll> PL;\n\n\nconst ll mod = 1e9 + 7;\nconst ll mod2 = 1e9 + 9;\nll powmod(ll a, ll e) {\n  ll sum = 1;\n  ll cur = a;\n  while (e > 0) {\n    if (e % 2) {\n      sum = sum * cur % mod;\n    }\n    cur = cur * cur % mod;\n    e /= 2;\n  }\n  return sum;\n}\nvoid add(ll &x, ll y) {\n  x = (x + y) % mod;\n}\nll powmod(ll a, ll e, ll mod) {\n  ll sum = 1;\n  ll cur = a;\n  while (e > 0) {\n    if (e % 2) {\n      sum = sum * cur % mod;\n    }\n    cur = cur * cur % mod;\n    e /= 2;\n  }\n  return sum;\n}\nll powmod2(ll a, ll e) {\n  ll sum = 1;\n  ll cur = a;\n  while (e > 0) {\n    if (e % 2) {\n      sum = sum * cur % mod2;\n    }\n    cur = cur * cur % mod2;\n    e /= 2;\n  }\n  return sum;\n}\nvoid add2(ll &x, ll y) {\n  x = (x + y) % mod2;\n}\n\n\n\nint main(void) {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  string s;\n  cin >> n >> s;\n  int p = 0;\n  VI pos(n + 1);\n  mt19937 mt;\n  ll b;\n  do {\n    b = mt() % mod;\n  } while (b == 0);\n  \n  vector<VL> hsh(3, VL(n + 1));\n  ll invb = powmod(b, mod - 2);\n  ll invb2 = powmod2(b, mod2 - 2);\n  ll mods[3] = { mod, mod2, 998244353 };\n  ll inv[3] = {invb, invb2};\n  inv[2] = powmod(b, mods[2] - 2, mods[2]);\n  REP(c, 0, 3) {\n    p = 0;\n    ll cur = 1;\n    REP(i, 0, n) {\n      ll tmp = hsh[c][i];\n      if (s[i] == '>') {\n        p++;\n        cur = cur * b % mods[c];\n      }\n      if (s[i] == '<') {\n        p--;\n        cur = cur * inv[c] % mods[c];\n      }\n      if (s[i] == '+') {\n        tmp = (tmp + cur) % mods[c];\n      }\n      if (s[i] == '-') {\n        tmp = (tmp + mods[c] - cur) % mods[c];\n      }\n      hsh[c][i + 1] = tmp;\n      pos[i + 1] = p;\n    }\n  }\n  if (DEBUG) {\n    REP(i, 0, n + 1) {\n      cerr << i << \" \" << hsh[0][i] << endl;\n    }\n  }\n  VL meguru(3);\n  REP(c, 0, 3) meguru[c] = hsh[c][n];\n  map<VL, int> kirika;\n  kirika[meguru] = 1;\n  ll tot = 0;\n  VL cur(3);\n  REP(c, 0, 3) cur[c] = powmod(b, pos[n], mods[c]);\n  for (int i = n - 1; i >= 0; --i) {\n    if (DEBUG) {\n      DEBUGP(i);\n      DEBUGP(pos[i]);\n    }\n    if (pos[i + 1] - pos[i] == -1) {\n      REP(c, 0, 3) cur[c] = cur[c] * inv[c] % mods[c];\n    }\n    else if (pos[i + 1] - pos[i] == 1) {\n      REP(c, 0, 3) cur[c] = cur[c] * b % mods[c];\n    }\n    VL ken(3);\n    REP(c, 0, 3) ken[c] = cur[c] * meguru[c] + hsh[c][i] % mods[c];\n    tot += kirika[ken];\n    VL tt(3);\n    REP(c, 0, 3) tt[c] = hsh[c][i];\n    kirika[tt] += 1;\n  }\n  cout << tot << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int N = 501000,mod1 = 1000000007,mod2 = 998244353;\nll *p1,_p1[N],*p2,_p2[N],h1[N],h2[N];\nint W[N],n;\nchar s[N];\nmap<pair<ll,ll>,int> mp;\nll fp(ll a,ll k,ll mod){\n\tll ans=1;\n\tfor(;k;k>>=1,a=a*a%mod)\n\t\tif(k&1) ans=a*ans%mod;\n\treturn ans;\n}\nint main(){\n\tios::sync_with_stdio(0);\n\tcin>>n;\n\tcin>>s+1;\n\tp1=_p1+n+10;p1[-n]=1;\n\tfor(int i=-n+1;i<=n;i++) p1[i]=p1[i-1]*434783%mod1;\n\tp2=_p2+n+10;p2[-n]=1;\n\tfor(int i=-n+1;i<=n;i++) p2[i]=p2[i-1]*434783%mod2;\n\tll hsh1=0,hsh2=0;\n\tint w=0;\n\tfor(int i=1;i<=n;i++){\n\t\tif(s[i]=='<') w--;\n\t\tif(s[i]=='>') w++;\n\t\tW[i]=w;\n\t\tif(s[i]=='+'){\n\t\t\th1[i]=p1[w];h2[i]=p2[w];\n\t\t\thsh1=(hsh1+p1[w])%mod1;\n\t\t\thsh2=(hsh2+p2[w])%mod2;\n\t\t}\n\t\tif(s[i]=='-'){\n\t\t\th1[i]=mod1-p1[w];\n\t\t\th2[i]=mod2-p2[w];\n\t\t\thsh1=(hsh1-p1[w]+mod1)%mod1;\n\t\t\thsh2=(hsh2-p2[w]+mod2)%mod2;\n\t\t}\n\t\tmp[make_pair(hsh1,hsh2)]++;\n\t}\n\tll now1=0,now2=0,ans=0;\n\tfor(int i=1;i<=n;i++){\n\t\tif(W[i-1]>0) ans+=mp[make_pair((hsh1*fp(434783,W[i-1],mod1)+now1)%mod1,(hsh2*fp(434783,W[i-1],mod2)+now2)%mod2)];\n\t\telse ans+=mp[make_pair((hsh1*fp(743624691,-W[i-1],mod1)+now1)%mod1,(hsh2*fp(743624691,-W[i-1],mod2)+now2)%mod2)];\n\t\tif(s[i]=='-'||s[i]=='+') now1=(now1+h1[i])%mod1,now2=(now2+h2[i])%mod2;\n\t\tmp[make_pair(now1,now2)]--;\n\t}\n\tcout<<ans<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <map>\n#include <vector>\n\nconst int MOD = (int)1e9 + 9;\nconst int kN = 250000 + 5;\nusing LL = long long;\nint n;\nchar s[kN];\nstd::vector<int> primes{13}; //(int)1e9 + 7, (int)1e8 + 7, 233333, (int)1e6 + 7, 13};\n\nint inv(int x) {\n  return x == 1 ? 1 : (MOD - MOD / x) * 1LL * inv(MOD % x) % MOD;\n}\n\nLL solve() {\n  int seed = primes[rand() % primes.size()];\n  int inv_seed = inv(seed);\n  int a = 1, b = 0;\n  LL ret = 0;\n  std::map<int, int> map;\n  map[0] = 1;\n  int c = 0;\n  for (int i = n; i >= 1; -- i) {\n    char ch = s[i - 1];\n    if (ch == '+')\n      c = (c + 1) % MOD;\n    else if (ch == '-')\n      c = (c + MOD - 1) % MOD;\n    else if (ch == '>')\n      c = c * 1LL * seed % MOD;\n    else\n      c = c * 1LL * inv_seed % MOD;\n  }\n  for (int i = n; i >= 1; -- i) {\n    char ch = s[i - 1];\n    if (ch == '-')\n      b = (b + a) % MOD;\n    else if (ch == '+')\n      b = (b + MOD - a) % MOD;\n    else if (ch == '<')\n      a = a * 1LL * seed % MOD;\n    else\n      a = a * 1LL * inv_seed % MOD;\n    auto it = map.find((a * 1LL * c % MOD + b) % MOD);\n    if (it != map.end())\n      ret += it->second;\n    map[b] ++;\n  }\n  return ret;\n}\n\nint main() {\n  srand(time(NULL));\n  scanf(\"%d%s\", &n, s);\n  printf(\"%lld\\n\", solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n  \n#define ll long long\n#define all(aaa) aaa.begin(), aaa.end()\n\nconst int MOD = 1000000033, N = 6e5 + 5;\nconst ll X = 1234567;\n\nll bp(ll a, ll p) {\n    ll r = 1;\n    while (p > 0) {\n        if (p & 1)\n            r = r * a % MOD;\n        a = a * a % MOD;\n        p >>= 1;\n    }\n    return r;\n}\n\nll inv_X = bp(X, MOD - 2);\n\nll a[N], b[N];\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n;\n    string s;\n    cin >> n >> s;\n\n    ll h = 0;\n\n    for (int i = n - 1; i >= 0; i--) {\n        if (s[i] == '>')\n            h = h * X % MOD;\n        else if (s[i] == '<')\n            h = h * inv_X % MOD;\n        else if (s[i] == '+')\n            h = (h + 1) % MOD;\n        else\n            h = (h - 1 + MOD) % MOD;\n    }\n\n    map<ll, int> mp;\n\n    ll ans = 0;\n\n    a[n] = 1;\n\n    for (int i = n - 1; i >= 0; i--) {\n        mp[b[i + 1]]++;\n\n        if (s[i] == '>') {\n            a[i] = a[i + 1] * inv_X % MOD;\n            b[i] = b[i + 1];\n        }\n        else if (s[i] == '<') {\n            a[i] = a[i + 1] * X % MOD;\n            b[i] = b[i + 1];\n        }\n        else if (s[i] == '+') {\n            a[i] = a[i + 1];\n            b[i] = (b[i + 1] - a[i + 1] + MOD) % MOD;\n        }\n        else {\n            a[i] = a[i + 1];\n            b[i] = (b[i + 1] + a[i + 1]) % MOD;\n        }\n\n        // cout << b[i] << \"\\n\";\n\n        ans += mp[(a[i] * h + b[i]) % MOD];\n    }\n\n    // cout << (a[0] * h + b[0]) % MOD << \"\\n\";\n\n    cout << ans << \"\\n\";\n\n    return 0;   \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\n\nconst int MAXN = 250005;\nlint mod = 1e16 + 61;\nconst int base = 257;\nint n, pos[MAXN];\nchar str[MAXN];\nlint pwr[MAXN * 2];\nlint inv[MAXN * 2];\n\nlint ipow(lint x, lint p){\n  lint ret = 1, piv = x;\n  while(p){\n    if(p & 1) ret = (__int128) ret * piv % mod;\n    piv = (__int128) piv * piv % mod;\n    p >>= 1;\n  }\n  return ret;\n}\n\nlint psum[MAXN];\n\nint main(){\n  mod++;\n  cin >> n >> (str + 1);\n  pwr[0] = inv[0] = 1;\n  for(int i=1; i<MAXN * 2; i++){\n    pwr[i] = pwr[i-1] * base % mod;\n    inv[i] = ipow(pwr[i], mod - 2);\n  }\n  pos[0] = n;\n  for(int i=1; i<=n; i++){\n    pos[i] = pos[i-1];\n    psum[i] = psum[i-1];\n    if(str[i] == '<') pos[i]--;\n    if(str[i] == '>') pos[i]++;\n    if(str[i] == '+') psum[i] += pwr[pos[i]];\n    if(str[i] == '-') psum[i] += mod - pwr[pos[i]];\n    psum[i] %= mod;\n  }\n  lint H = psum[n];\n  lint ret = 0;\n  map<int, int> mp;\n  for(int i=n; i; i--){\n    mp[psum[i]]++;\n    __int128 Hv = H;\n    if(pos[0] <= pos[i-1]) Hv *= pwr[pos[i-1] - pos[0]];\n    else Hv *= inv[pos[0] - pos[i-1]];\n    Hv += psum[i-1];\n    Hv %= mod;\n    ret += mp[Hv];\n  }\n  cout << ret << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <iostream>\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define debug(x) cout<<#x<<\" :: \"<<x<<endl;\n#define debug2(x,y) cout<<#x<<\" :: \"<<x<<\"\\t\"<<#y<<\" :: \"<<y<<endl;\n#define debug3(x,y,z) cout<<#x<<\" :: \"<<x<<\"\\t\"<<#y<<\" :: \"<<y<<\"\\t\"<<#z<<\" :: \"<<z<<endl;\n\n#define boost ios::sync_with_stdio(0); cin.tie(0)\n\n#define fi first\n#define se second\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double ld;\ntypedef pair<int, int> pii;\n\nconst int X = 250000 + 5;\nconst int N = 1e6 + 5;\nconst ull B = 161;\null invB;\n\n/***************************************************************************/\n\null power(ull a, ull n) {\n\tif(n == 0) return 1;\n\tull p = power(a, n>>1);\n\tp = p * p;\n\tif(n & 1) p = p * a;\n\treturn p;\n}\n\nstring S;\null powB[N];\n\ninline ull& pow(int n) {\n\tif(n < 0) n += N;\n\treturn powB[n];\n}\n\ngp_hash_table<ull, int> M;\n\nint main() {\n\n\tboost;\n\tinvB = power(B, (ull(1)<<63)-1);\n\tassert(B * invB == 1);\n\n\tpow(0) = 1;\n\tfor(int i=1; i<X; i++) {\n\t\tpow(i) = pow(i-1) * B;\n\t\tpow(-i) = pow(-i+1) * invB;\n\t}\n\n\tint n; cin>>n;\n\tcin>>S;\n\n\tull phas = 0, chas = 0;\n\n\tint p = 0;\n\tfor(auto it : S) {\n\t\tif(it == '+') phas += pow(p);\n\t\telse if(it == '-') phas -= pow(p);\n\t\telse if(it == '>') p++;\n\t\telse p--;\n\t}\n\n\tll ans = 0;\n\tM[phas]++;\n\tp = 0;\n\n\tfor(auto it : S) {\n\t\tif(it == '+') chas += pow(p);\n\t\telse if(it == '-') chas -= pow(p);\n\t\telse if(it == '>') p++;\n\t\telse p--;\n\n\t\tans += M[chas];\n\t\tM[chas + pow(p) * phas]++;\n\t}\n\n\tcout<<ans<<\"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <map>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 999999937; \nconst int MAXN = 250005;\nconst int K = 6;\n\nchar s[MAXN];\n\nint n, X[MAXN][K], IX[MAXN][K], C[K], pos[MAXN];\n\nvector<int> a[MAXN], b[MAXN];\n\nmap<vector<int>, int> mp;\n\nchar rev(char x)\n{\n\tif (x == '<') return '>';\n\tif (x == '>') return '<';\n\tif (x == '+') return '-';\n\tif (x == '-') return '+';\t\n}\n\nint qpow(int a, int b)\n{\n\tint ret = 1;\n\twhile (b)\n\t{\n\t\tif (b & 1) ret = (long long)ret * a % MOD;\n\t\ta = (long long)a * a % MOD;\n\t\tb >>= 1;\t\n\t}\n\treturn ret;\n}\n\nvoid T(int &c, char x, int k)\n{\n\tif (x == '<') c = (long long)c * X[1][k] % MOD;\n\tif (x == '>') c = (long long)c * IX[1][k] % MOD;\n\tif (x == '+') c = (c + 1) % MOD;\n\tif (x == '-') c = (c - 1 + MOD) % MOD;\n}\n\nvoid init()\n{\n\tfor (int i = 0; i < K; i++)\n\t\tX[0][i] = 1;\n\tfor (int i = 0; i < K; i++)\n\t\tX[1][i] = rand() % MOD; // ***************\n\tfor (int i = 2; i < n; i++)\n\t\tfor (int j = 0; j < K; j++)\n\t\t\tX[i][j] = (long long)X[i - 1][j] * X[1][j] % MOD;\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < K; j++)\n\t\t\tIX[i][j] = qpow(X[i][j], MOD - 2);\n\tfor (int i = n; i >= 1; i--)\n\t\tfor (int j = 0; j < K; j++)\n\t\t\tT(C[j], s[i], j);\n//\tcout << \"C: \" << C[0] << endl;\n\tfor (int i = 0; i <= n + 1; i++)\n\t\ta[i].resize(K, 0), b[i].resize(K, 0);\n}\n\nint main()\n{\n\tsrand(2333);\n\tios::sync_with_stdio(false);\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++)\n\t\tcin >> s[i];\n\tinit();\n\tpos[n + 1] = 0;\n\tfor (int i = n; i >= 1; i--)\n\t{\n\t\tfor (int j = 0; j < K; j++)\n\t\t\tb[i][j] = b[i + 1][j];\n\t\tpos[i] = pos[i + 1];\n\t\tswitch (rev(s[i])) \n\t\t{\n\t\t\tcase '<':\n\t\t\t\tpos[i]++;\n\t\t\t\tbreak;\n\t\t\tcase '>':\n\t\t\t\tpos[i]--;\n\t\t\t\tbreak;\n\t\t\tcase '+':\n\t\t\t\tif (pos[i] >= 0)\n\t\t\t\t{\n\t\t\t\t\tfor (int j = 0; j < K; j++)\n\t\t\t\t\t\tb[i][j] = ((long long)b[i][j] + X[pos[i]][j]) % MOD;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfor (int j = 0; j < K; j++)\n\t\t\t\t\t\tb[i][j] = ((long long)b[i][j] + IX[-pos[i]][j]) % MOD;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tif (pos[i] >= 0)\n\t\t\t\t{\n\t\t\t\t\tfor (int j = 0; j < K; j++)\n\t\t\t\t\t\tb[i][j] = ((long long)b[i][j] - X[pos[i]][j] + MOD) % MOD;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfor (int j = 0; j < K; j++)\n\t\t\t\t\t\tb[i][j] = ((long long)b[i][j] - IX[-pos[i]][j] + MOD) % MOD;\n\t\t\t\t}\n\t\t\t\tbreak;\t\n\t\t}\n//\t\tcout << \"b[\" << i << \"]: \" << b[i][0] << endl;\n\t}\n\tfor (int i = n; i > 0; i--)\n\t{\n\t\tfor (int j = 0; j < K; j++)\n\t\t{\n\t\t\tif (pos[i] >= 0)\n\t\t\t\ta[i][j] = ((long long)C[j] * X[pos[i]][j] % MOD + b[i][j]) % MOD;\n\t\t\telse\n\t\t\t\ta[i][j] = ((long long)C[j] * IX[-pos[i]][j] % MOD + b[i][j]) % MOD;\n\t\t}\n//\t\tcout << \"b[\" << i << \"]: \" << b[i][0] << endl;\n\t\tmp[a[i]]++;\n\t}\n\tint res = 0;\n\tfor (int i = n; i > 0; i--)\n\t{\n\t\tres += mp[b[i + 1]];\n\t\tmp[a[i]]--;\n\t}\n\tcout << res << endl;\n\treturn 0;\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\n//const ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nll Pow(ll n,ll p,ll mod){\n\tll r=1;\n\tfor(;p>0;p>>=1){\n\t\tif(p&1) r=(r*n)%mod;\n\t\tn=(n*n)%mod;\n\t}\n\treturn r;\n}\n\nll Div(ll n,ll m,ll mod){\n\treturn n*Pow(m,mod-2,mod)%mod;\n}\n\nconst ll mod[2]={1000000007,1000000009},base[2]={1009,17};\nll inv[2];\n\npll f(vl a,vl b){\n\tpll p=make_pair(Div(b[0],a[0],mod[0]),Div(b[1],a[1],mod[1]));\n\treturn p;\n}\n\nll n,res=0;\nstring s;\nvvl a,b;\nmap<pll,ll> mp;\n\nint main(){\n\tinv[0]=Div(1,base[0],mod[0]);\n\tinv[1]=Div(1,base[1],mod[1]);\n\tcin>>n>>s;\n\ta=b=vvl(n+1,vl(2));\n\ta[n][0]=a[n][1]=1;\n\tfor(int i=n-1;i>=0;i--) for(int j=0;j<2;j++){\n\t\tif(s[i]=='+') a[i][j]=a[i+1][j],b[i][j]=b[i+1][j]+1;\n\t\tif(s[i]=='-') a[i][j]=a[i+1][j],b[i][j]=(b[i+1][j]-1+mod[j])%mod[j];\n\t\tif(s[i]=='>') a[i][j]=a[i+1][j]*base[j]%mod[j],b[i][j]=b[i+1][j]*base[j]%mod[j];\n\t\tif(s[i]=='<') a[i][j]=a[i+1][j]*inv[j]%mod[j],b[i][j]=b[i+1][j]*inv[j]%mod[j];\n\t}\n\tmp[f(a[n],b[n])]++;\n\tfor(int i=n-1;i>=0;i--){\n\t\tpll p;\n\t\tp.first =Div((b[i][0]-b[0][0]+mod[0])%mod[0],a[i][0],mod[0]);\n\t\tp.second=Div((b[i][1]-b[0][1]+mod[1])%mod[1],a[i][1],mod[1]);\n\t\tres+=mp[p];\n\t\tmp[f(a[i],b[i])]++;\n\t}\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nint mod_pow(int a, ll b)\n{\n    int res = 1;\n    while(b){\n        if(b & 1){\n            res = (ll)res * a % MOD;\n        }\n        a = (ll)a * a % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nint add(int x,int y)\n{\n    return (x + y)%MOD;\n}\n\nint sub(int x,int y)\n{\n    return (x+MOD-y)%MOD;\n}\n\nint mul(int x,int y)\n{\n    return (ll)x*y%MOD;\n}\n\n#define mul0 10009\nstruct RollingHash {\n\tint n, sz, res; vector<int> hash;\n    RollingHash(int _n) : n(_n), sz(2*n+2), res(0){\n        hash.resize(sz+1,0), hash[0] = 1;\n\t\trep(i,sz) hash[i+1]=((ll)hash[i]*mul0)%MOD;\n    }\n    int calc(int id, bool pl){\n        if(pl) res = add(res, hash[id+n+1]);\n        else res = sub(res, hash[id+n+1]);\n        return res;\n    }\n};\n\nmap<int, int> mp;\nvector<int> vec;\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    string s;\n    cin >> s;\n    RollingHash rh(n);\n    int p = 0;\n    rep(i,n){\n        if(s[i] == '+'){\n            vec.pb(rh.calc(p, true));\n        }else if(s[i] == '-'){\n            vec.pb(rh.calc(p, false));\n        }else if(s[i] == '>'){\n            if(len(vec)){\n                vec.pb(vec.back());\n            }else{\n                vec.pb(0);\n            }\n            p++;\n        }else{\n            if(len(vec)){\n                vec.pb(vec.back());\n            }else{\n                vec.pb(0);\n            }\n            p--;\n        }\n        mp[vec.back()]++;\n    }\n    int val = vec.back();\n    ll ans = 0;\n    int A = 1, B = 0;\n    auto& hash = rh.hash;\n    rep(i,n){\n        ans += mp[mul(sub(val, B), mod_pow(A, MOD-2))];\n        mp[vec[i]]--;\n        if(s[i] == '+'){\n            B = sub(B, hash[n+1]);\n        }else if(s[i] == '-'){\n            B = add(B, hash[n+1]);\n        }else if(s[i] == '>'){\n            int hoge = mod_pow(mul0, MOD-2);\n            A = mul(A, hoge), B = mul(B, hoge);\n        }else{\n            A = mul(A, mul0), B = mul(B, mul0);\n        }\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ninline int power(int a, int b, int mod) {\n    long long res = a, ans = 1;\n    for(; b; b >>= 1, res = res * res % mod) if(b & 1) ans = ans * res % mod;\n    return ans;\n}\nconst int mod1 = 1e9 + 7, mod2 = 1e9 + 9;\nconst int base1 = 19260817, base2 = 65537, base1Inv = power(base1, mod1 - 2, mod1), base2Inv = power(base2, mod2 - 2, mod2);\nint n;\ntemplate <class T, int L, int R>\nclass Array {\n    private:\n        T buf[R - L + 1];\n    public:\n        struct iterator {\n            T *p;\n            inline iterator& operator ++ () {\n                return ++p;\n            }\n            inline iterator& operator ++ (int) {\n                return p++;\n            }\n            inline iterator& operator -- () {\n                return --p;\n            }\n            inline iterator& operator -- (int) {\n                return p--;\n            }\n            inline T& operator * () {\n                return *p;\n            }\n            inline iterator operator + (int x) {\n                return p + x;\n            }\n            inline iterator& operator += (int x) {\n                return p += x;\n            }\n            inline iterator operator - (int x) {\n                return p - x;\n            }\n            inline iterator& operator -= (int x) {\n                return p -= x;\n            }\n            inline iterator& operator = (iterator b) {\n                return p = b.p;\n            }\n            inline bool operator == (iterator b) {\n                return p == b.p;\n            }\n            inline bool operator != (iterator b) {\n                return p != b.p;\n            }\n        };\n        inline iterator begin() {\n            return iterator {buf};\n        }\n        inline iterator end() {\n            return iterator {buf + R - L + 1};\n        }\n        inline T& operator [] (int x) {\n            return buf[x - L];\n        }\n        inline const T& operator [] (int x) const {\n            return buf[x - L];\n        }\n};\nArray <int, -250000, 250000> pw1, pw2;\npair <int, int> need, sum[250010];\nint pos[250010];\nchar opt[250010];\nmap < pair <int, int>, int > cnt;\nint main() {\n    scanf(\"%d%s\", &n, opt + 1);\n    pos[0] = 0;\n    pw1[0] = pw2[0] = 1;\n    for(int i = 0; i < 250000; i++) \n        pw1[i + 1] = 1ll * base1 * pw1[i] % mod1,\n        pw2[i + 1] = 1ll * base2 * pw2[i] % mod2,\n        pw1[-i - 1] = 1ll * base1Inv * pw1[-i] % mod1,\n        pw2[-i - 1] = 1ll * base2Inv * pw2[-i] % mod2;\n    for(int i = 1; i <= n; i++) {\n        switch (opt[i]) {\n        case '<': {\n            pos[i] = pos[i - 1] - 1;\n            sum[i] = sum[i - 1];\n            break;\n        }\n        case '>': {\n            pos[i] = pos[i - 1] + 1;\n            sum[i] = sum[i - 1];\n            break;\n        }\n        case '+': {\n            pos[i] = pos[i - 1];\n            sum[i] = sum[i - 1];\n            sum[i].first = (sum[i].first + pw1[pos[i]]) % mod1;\n            sum[i].second = (sum[i].second + pw2[pos[i]]) % mod2;\n            break;\n        }\n        case '-': {\n            pos[i] = pos[i - 1];\n            sum[i] = sum[i - 1];\n            sum[i].first = (sum[i].first + mod1 - pw1[pos[i]]) % mod1;\n            sum[i].second = (sum[i].second + mod2 - pw2[pos[i]]) % mod2;\n            break;\n        }\n        default:\n            assert(0);\n        }\n    }\n    long long ans = 0;\n    for(int i = n; i >= 0; i--) {\n        pair <int, int> tmp;\n        tmp = sum[n]; // sum[n] = (sum[r] - sum[l - 1]) >> pos[l - 1]\n        tmp.first = 1ll * tmp.first * pw1[pos[i]] % mod1;\n        tmp.second = 1ll * tmp.second * pw2[pos[i]] % mod2;\n        tmp.first = (tmp.first + sum[i].first) % mod1;\n        tmp.second = (tmp.second + sum[i].second) % mod2;\n        // cerr << i << ' ' << tmp.first << ' ' << tmp.second << endl;\n        if(cnt.count(tmp)) ans += cnt[tmp];\n        tmp = sum[i];\n        // cerr << i << ' ' << tmp.first << ' ' << tmp.second << endl;\n        if(cnt.count(tmp)) cnt[tmp]++;\n        else cnt[tmp] = 1;\n    }\n    return cout << ans << endl, 0;\n}"
  },
  {
    "language": "C++",
    "code": "const int N = 250005;\nconst int LG = 21;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nint n;\nstring s;\n\nconst ll M = 2;\nconst ll K[M] = {1000003, 1791791};\nconst ll rK[M] = {rev(K[0]), rev(K[1])};\nmap<ll, ll> deg[M];\n\nvector<ll> ad(vector<ll> a)\n{\n    for (int i = 0; i < M; i++)\n    {\n        a[i]++;\n        if (a[i] >= MOD) a[i] -= MOD;\n    }\n    return a;\n}\n\nvector<ll> mi(vector<ll> a)\n{\n    for (int i = 0; i < M; i++)\n    {\n        a[i]--;\n        if (a[i]  < 0) a[i] += MOD;\n    }\n    return a;\n}\n\nvector<ll> mu(vector<ll> a)\n{\n    for (int i = 0; i < M; i++)\n    {\n        a[i] = a[i] * K[i] % MOD;\n    }\n    return a;\n}\n\nvector<ll> di(vector<ll> a)\n{\n    for (int i = 0; i < M; i++)\n    {\n        a[i] = a[i] * rK[i] % MOD;\n    }\n    return a;\n}\n\nsigned main()\n{\n    for (int i = 0; i < M; i++)\n    {\n        deg[i][0] = 1;\n        for (int j = 1; j < N; j++) deg[i][j] = deg[i][j - 1] * K[i] % MOD;\n        for (int j = 1; j < N; j++) deg[i][-j] = deg[i][-j + 1] * rK[i] % MOD;\n    }\n    srand(time(NULL));\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n    cin >> n >> s;\n    vector<ll> a(M);\n    for (int i = n - 1; i >= 0; i--)\n    {\n        if (s[i] == '+') a = mi(a);\n        if (s[i] == '-') a = ad(a);\n        if (s[i] == '>') a = mu(a);\n        if (s[i] == '<') a = di(a);\n    }\n    map<vector<ll>, int> cnt;\n    ll ans = 0;\n    ll cur_move = 0;\n    vector<ll> cur(M, 0);\n    cnt[cur]++;\n    for (int i = n - 1; i >= 0; i--)\n    {\n        if (s[i] == '+')\n        {\n            for (int j = 0; j < M; j++) cur[j] = (cur[j] + deg[j][cur_move]) % MOD;\n        }\n        if (s[i] == '-')\n        {\n            for (int j = 0; j < M; j++) cur[j] = (cur[j] + MOD - deg[j][cur_move]) % MOD;\n        }\n        if (s[i] == '<')\n        {\n            cur_move++;\n        }\n        if (s[i] == '>')\n        {\n            cur_move--;\n        }\n        vector<ll> ask = cur;\n        //for (int j = 0; j < M; j++) cout << cur[j] << \" \"; cout << \"\\n\";\n        for (int j = 0; j < M; j++) ask[j] = (ask[j] + a[j] * deg[j][cur_move]) % MOD;\n        //for (int j = 0; j < M; j++) cout << ask[j] << \" \"; cout << \"\\n\\n\";\n        ans += cnt[ask];\n        cnt[cur]++;\n    }\n    cout << ans;\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "\t#include <iostream>\n    #include <string>\n    #include <set>  \n    #include <stack>\n    #include <algorithm>\n    #include <vector>\n    #include <cmath>\n    #include <queue>\n    #include <deque>\n    #include <cstring>\n    #include <cstdio>\n    #include <map>\n    #include <numeric>\n    #include <cassert>\n    #include <iomanip>\n    #include <sstream>\n    #include <ctime>\nusing namespace std;\n#define for1(i,a,b) for(int i=(a);i<(int)(b);++i)\n#define rep(i,maxn) for1(i,0,maxn)\n#define ford(i,b,a) for(int i=(int)(b)-1;i>=a;--i)\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define st first\n#define nd second\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define dprintf(...) printf(__VA_ARGS__)\nconst int maxn=250100;\nll M=10001659;\nll X=22;\nll a[maxn],b[maxn],t[maxn],T[maxn];\nint n;\nchar s[maxn];\nll qp(ll base,int ind)\n{\n\tll ans=1;\n\tbase%=M;\n\twhile(ind)\n\t{\n\t\tif(ind&1)ans=ans*base%M;\n\t\tind>>=1;\n\t\tbase=base*base%M;\n\t}\n\treturn ans;\n}\nll inv(ll x)\n{\n\treturn qp(x,(int)(M-2));\n}\nmap<ll,ll> trans;\nint main()\n{\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",s);\n\tll rev=inv(X);\n//\tcout<<rev<<endl;\n//\tsystem(\"pause\");\n\tmemset(t,0,sizeof(t));\n\tford(i,n,0)\n\t{\n\t\tt[i]=t[i+1];\n\t\tif(s[i]=='+')\n\t\t{\n\t\t\tt[i]++;\n\t\t\tt[i]%=M;\n\t\t}\n\t\telse if(s[i]=='-')\n\t\t{\n\t\t\tt[i]--;\n\t\t\tt[i]+=M;\n\t\t\tt[i]%=M;\n\t\t}\n\t\telse if(s[i]=='>')\n\t\t{\n\t\t\tt[i]*=rev;\n\t\t\tt[i]%=M;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tt[i]*=X;\n\t\t\tt[i]%=M;\n\t\t}\n//\t\tcout<<t[i]<<endl;\n//\t\tsystem(\"pause\");\n\t}\n\tll c=t[0];\n//\tprintf(\"%lld\\n\",c);\n//\tsystem(\"pause\");\n\tint multa=1,mina=0,multb=1,minb=0;\n\tford(i,n,0)\n\t{\n\t\tif(s[i]=='+')\n\t\t{\n\t\t\tmina-=multa,minb-=multb;\n\t\t\tmina+=M,minb+=M;\n\t\t\tmina%=M,minb%=M; \n\t\t}\n\t\telse if(s[i]=='-')\n\t\t{\n\t\t\tmina+=multa,minb+=multb;\n\t\t\tmina%=M,minb%=M;\n\t\t}\n\t\telse if(s[i]=='>')\n\t\t{\n\t\t\tmulta=multa*X%M;\n\t\t\tmultb=multb*X%M;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmulta=multa*rev%M;\n\t\t\tmultb=multb*rev%M;\n\t\t}\n\t\ta[i]=mina%M;\n\t\tb[i]=(c*multb%M+minb%M)%M;\n\t//\tcout<<a[i]<<\" \"<<b[i]<<endl;\n\t\ttrans[b[i]]++;\n\t//\tsystem(\"pause\");\n\t}\n\t\n\t//a(j+1)=b(i) j+1>i\n\tll ans=0;\n\tford(j,n-1,0)\n\t{\n\t//\tcout<<trans[a[j+1]]<<\" \"<<a[j+1]<<endl;\n\t//\tsystem(\"pause\");\n\t\ttrans[b[j+1]]--;\n\t\tans+=trans[a[j+1]];\n\t}\n\trep(i,n)\n\t\tif(a[i]==a[0])ans++;\n\tprintf(\"%I64d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int mod = 1e9 + 7;\nconst int MN = 250010;\nconst int P = 1e6 + 7;\n\nint exp(int x, int n) {\n    int ret = 1;\n    while(n) {\n        if(n & 1) ret = 1LL * ret * x % mod;\n        x = 1LL * x * x % mod;\n        n >>= 1;\n    }\n    return ret;\n}\nint inv(int x) {\n    return exp(x, mod - 2);\n}\nint po[MN << 1];\n\nint N;\nchar S[MN];\nint A[MN << 1];\nunordered_map<int, int> cnt;\n\nint main() {\n    po[0] = 1;\n    for(int i = 1; i < (MN << 1); i++) {\n        po[i] = 1LL * po[i - 1] * P % mod;\n    }\n\n    scanf(\"%d\", &N);\n\n    scanf(\"\\n\");\n    for(int i = 0; i < N; i++) {\n        scanf(\"%c\", &S[i]);\n    }\n\n    int pos = MN;\n    for(int i = 0; i < N; i++) {\n        if(S[i] == '+') A[pos]++;\n        if(S[i] == '-') A[pos]--;\n        if(S[i] == '<') pos--;\n        if(S[i] == '>') pos++;\n    }\n\n    int hval = 0;\n    for(int i = 0; i < (MN << 1); i++) {\n        hval += 1LL * (A[i] + mod) % mod * po[i] % mod;\n        hval %= mod;\n    }\n\n    int a = 1, b = 0;\n    ll ans = 0;\n    for(int i = N - 1; i >= 0; i--) {\n\n        cnt[ 1LL * (mod - b) * inv(a) % mod ]++;\n\n        if(S[i] == '+') {\n            b += po[MN];\n            b %= mod;\n        }\n        if(S[i] == '-') {\n            b += mod - po[MN];\n            b %= mod;\n        }\n        if(S[i] == '<') {\n            a = 1LL * a * inv(P) % mod;\n            b = 1LL * b * inv(P) % mod;\n        }\n        if(S[i] == '>') {\n            a = 1LL * a * P % mod;\n            b = 1LL * b * P % mod;\n        }\n\n        ans += cnt[ 1LL * (hval + mod - b) % mod * inv(a) % mod ];\n    }\n\n    printf(\"%lld\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#include<map>\nusing namespace std;\nconst long long Mod=1000000000039;\nconst long long base=1000003;\nint n;\nchar s[250010];\nlong long a[250010],b[250010];\nlong long mul(long long a,long long b)\n{\n\tlong long ans=0,t=a;\n\twhile(b)\n\t{\n\t\tif(b&1)ans=(ans+t)%Mod;\n\t\tt=(t+t)%Mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nlong long fpow(long long a,long long b)\n{\n\tlong long ans=1,t=a;\n\twhile(b)\n\t{\n\t\tif(b&1)ans=mul(ans,t);\n\t\tt=mul(t,t);\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nmap<long long,int>mp;\nint main()\n{\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",s+1);\n\tlong long x=0,y=0,invbase=fpow(base,Mod-2);\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tif(s[i]=='-')\n\t\t\tx=(x-1+Mod)%Mod;\n\t\telse if(s[i]=='+')\n\t\t\tx=(x+1)%Mod;\n\t\telse if(s[i]=='<')\n\t\t\tx=mul(x,base)%Mod;\n\t\telse x=mul(x,invbase)%Mod;\n\t}\n\tlong long c=x;\n\tx=1;y=0;\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tif(s[i]=='+')\n\t\t\ty=(y-x+Mod)%Mod;\n\t\telse if(s[i]=='-')\n\t\t\ty=(y+x)%Mod;\n\t\telse if(s[i]=='>')\n\t\t\tx=mul(x,base)%Mod;\n\t\telse x=mul(x,invbase)%Mod;\n\t\tb[i]=y;\n\t\ta[i]=(mul(x,c)+y)%Mod;\n\t}\n\tlong long ans=0;\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tmp[b[i+1]]++;\n\t\tans+=mp[a[i]];\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\nusing namespace std;\n\n#define P1 1000000007LL\n#define P2 1000000009LL\ntypedef long long Int;\nmap<Int, Int> cs;\nInt sum[250001];\nInt pos[250001];\nInt res;\nInt n;\nstring str;\nInt pow(Int x, Int y, Int M){\n\tif(y == 0)return 1;\n\tInt res = pow(x, y/2, M);\n\tres = res * res % M;\n\tif(y % 2)res *= x;\n\treturn x % M;\n}\n\nInt rev(Int x, Int M){\n\treturn pow(x, M-2, M);\n}\n\nint main(){\n\tInt rev10 = rev(10, P1);\n\tInt p = 0;\n\tInt tmp = 0;\n\tcin >> n;\n\tcin >> str;\n\tfor(int i = 0;i < n;i++){\n\t\tif(str[i] == '+')tmp = (tmp + pow(10, p, P1))%P1;\n\t\tif(str[i] == '-')tmp = (tmp - pow(10, p, P1))%P1;\n\t\tif(str[i] == '>')p++;\n\t\tif(str[i] == '<')p--;\n\t\tsum[i+1] = tmp;\n\t\tpos[i+1] = p;\n\t}\n\tInt last = sum[n];\n\tfor(int i = n;i >= 0;i--){\n\t\tInt tmp = ((last - last * pow(10, pos[i], P1) % P1) % P1 + P1)% P1;\n\t\tres += cs[tmp - sum[i]];\n\t\tInt c = last - sum[i];\n\t\tif(cs.count(c) == 0)cs[c] = 0;\n\t\tcs[c]++;\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <cmath>\n#include <map>\n#define enter putchar('\\n')\n#define space putchar(' ')\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define eps 1e-7\n#define MAXN 250005\n#define MOD 999999137\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef double db;\ntypedef vector<int> poly;\n\ntemplate<class T>\nvoid read(T &res) {\n\tres = 0;char c = getchar();T f = 1;\n\twhile(c < '0' || c > '9') {\n\t\tif(c == '-') f = -1;\n\t\tc = getchar();\n\t}\n\twhile(c >= '0' && c <= '9') {\n\t\tres = res * 10 + c - '0';\n\t\tc = getchar();\n\t}\n\tres *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n\tif(x < 0) {putchar('-');x = -x;}\n\tif(x >= 10) {\n\t\tout(x / 10);\n\t}\n\tputchar('0' + x % 10);\n}\nint B[] = {0,823,727,401,271,571};\nint InvB[10];\nint f[8][MAXN],g[8][MAXN],N,h[8][MAXN];\nchar s[MAXN];\nmap<int,int> MK[8];\n\n\nint mul(int a,int b) {\n\treturn 1LL * a * b % MOD;\n}\nint inc(int a,int b) {\n\treturn a + b >= MOD ? a + b - MOD : a + b;\n}\nvoid update(int &x,char c,int id) {\n\tif(c == '<') x = mul(x,InvB[id]);\n\telse if(c == '>') x = mul(x,B[id]);\n\telse if(c == '+') x = inc(x,1);\n\telse x = inc(x,MOD - 1);\n}\nint fpow(int x,int c) {\n\tint res = 1,t = x;\n\twhile(c) {\n\t\tif(c & 1) res = mul(res,t);\n\t\tt = mul(t,t);\n\t\tc >>= 1;\n\t}\n\treturn res;\n}\nvoid Solve() {\n\tfor(int i = 1 ; i <= 5 ; ++i) InvB[i] = fpow(B[i],MOD - 2);\n\tread(N);\n\tscanf(\"%s\",s + 1);\n\tint c[10] = {0};\n\tfor(int k = 1 ; k <= 5 ; ++k) {\n\t\tfor(int i = N ; i >= 1 ; --i) {\n\t\t\tupdate(c[k],s[i],k);\n\t\t}\n\t}\n\tfor(int k = 1 ; k <= 5 ; ++k) h[k][N + 1] = 1,g[k][N + 1] = c[k],MK[k][0] += 1;\n\tint64 ans = 0;\n\tfor(int i = N ; i >= 1 ; --i) {\n\t\tint add = N - i + 1;\n\t\tfor(int k = 1 ; k <= 5 ; ++k) {\n\t\t\tif(s[i] == '<') {\n\t\t\t\tg[k][i] = inc(g[k][i + 1],MOD - mul(h[k][i + 1],c[k]));\n\t\t\t\th[k][i] = mul(h[k][i + 1],B[k]);\n\t\t\t\tg[k][i] = inc(g[k][i],mul(h[k][i],c[k]));\n\t\t\t\tf[k][i] = f[k][i + 1];\t\t\n\t\t\t}\n\t\t\telse if(s[i] == '>') {\n\t\t\t\tg[k][i] = inc(g[k][i + 1],MOD - mul(h[k][i + 1],c[k]));\n\t\t\t\th[k][i] = mul(h[k][i + 1],InvB[k]);\n\t\t\t\tg[k][i] = inc(g[k][i],mul(h[k][i],c[k]));\n\t\t\t\tf[k][i] = f[k][i + 1];\n\t\t\t}\n\t\t\telse if(s[i] == '+') {\n\t\t\t\th[k][i] = h[k][i + 1];\n\t\t\t\tg[k][i] = inc(g[k][i + 1],MOD - h[k][i]);\n\t\t\t\tf[k][i] = inc(f[k][i + 1],MOD - h[k][i]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\th[k][i] = h[k][i + 1];\n\t\t\t\tg[k][i] = inc(g[k][i + 1],h[k][i]);\n\t\t\t\tf[k][i] = inc(f[k][i + 1],h[k][i]);\n\t\t\t}\n\t\t\tadd = min(add,MK[k][g[k][i]]);\n\t\t\tMK[k][f[k][i]] += 1;\n\t\t}\n\t\tans += add;\n\t}\n\tout(ans);enter;\t\n}\nint main() {\n#ifdef ivorysi\n\tfreopen(\"f1.in\",\"r\",stdin);\n#endif\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "const int N = 400005;\nconst int LG = 21;\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nint n;\nstring s;\nll sufa[N];\nll suf0[N];\nconst ll K = 29;\n\nsigned main()\n{\n    srand(time(NULL));\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n    cin >> n >> s;\n    ll a = 0;\n    for (int i = n - 1; i >= 0; i--)\n    {\n        if (s[i] == '+')\n        {\n            a = (a + MOD - 1) % MOD;\n        }\n        if (s[i] == '-')\n        {\n            a = (a + 1) % MOD;\n        }\n        if (s[i] == '>')\n        {\n            a = (a * K) % MOD;\n        }\n        if (s[i] == '<')\n        {\n            a = (a * rev(K)) % MOD;\n        }\n    }\n    for (int i = 0; i < n; i++)\n    {\n        sufa[i] = a;\n        for (int j = i; j < n; j++)\n        {\n            if (s[j] == '+')\n            {\n                suf0[i] = (suf0[i] + 1) % MOD;\n                sufa[i] = (sufa[i] + 1) % MOD;\n            }\n            if (s[j] == '-')\n            {\n                suf0[i] = (suf0[i] + MOD - 1) % MOD;\n                sufa[i] = (sufa[i] + MOD - 1) % MOD;\n            }\n            if (s[j] == '<')\n            {\n                suf0[i] = (suf0[i] * K) % MOD;\n                sufa[i] = (sufa[i] * K) % MOD;\n            }\n            if (s[j] == '>')\n            {\n                suf0[i] = (suf0[i] * rev(K)) % MOD;\n                sufa[i] = (sufa[i] * rev(K)) % MOD;\n            }\n        }\n    }\n    #ifdef LOCAL\n    for (int i = 0; i < n; i++) cout << suf0[i] << \" \"; cout << \"\\n\";\n    for (int i = 0; i < n; i++) cout << sufa[i] << \" \"; cout << \"\\n\";\n    #endif // LOCAL\n    ll ans = 0;\n    map<vector<int>, int> cnt;\n    for (int i = n; i >= 0; i--)\n    {\n        ans += cnt[{sufa[i]}];\n        cnt[{suf0[i]}]++;\n    }\n    cout << ans;\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define pb push_back\n#define all(v) v.begin(), v.end()\n#define sz(v) int(v.size())\n#define pii pair<int, int>\n#define mp make_pair\n#define f first\n#define ll long long\n#define s second\n#define vec vector<int>\n\nusing namespace std;\n\nconst int N = (int) 2e6 + 10;\nconst int K = (int) 1e7 + 10;\nconst int mod = (int) 1e9 + 7;\nconst int T = (int) 200017;\n\nint n;\nstring st;\nint p[N];\n\nvoid add(int &x, int y) {\n\tx += y;\n\tif (x >= mod)\n\t\tx -= mod;\n\tif (x < 0) \n\t\tx += mod;\n}\n\nint mult(int x, int y) {\n\treturn x * 1ll * y % mod;\n}\n\nint hsh[N], pos[N];\n\npair<int, int> get(int l, int r) {\n\treturn mp(hsh[r + 1], pos[r + 1]);\n}\n\nint inv(int x) {\n\tint pw = mod - 2;\n\tint ans = 1;\n\twhile (pw) {\n\t\tif (pw & 1) \n\t\t\tans = mult(ans, x);\n\t\tx = mult(x, x);\n\t\tpw /= 2;\n\t}\n\treturn ans;\n}\n\n// get(l,r)=(get(0,r)-get(0,l-1))<<pos(0, l-1)\n\nint shift(int x, int val) { // to the right\n\tif (val > 0) {\n\t\tx = mult(x, p[val]);\n\t} else {\n\t\tx = mult(x, inv(p[-val]));\n\t}\n\treturn x;\n}\n\nint sum(int x, int y) {\n\tadd(x, y);\n\treturn x;\n}\n\nint main() {\n\t#ifdef sony\n\t\tfreopen(\"input.txt\", \"r\", stdin);\n\t\tfreopen(\"output.txt\", \"w\", stdout);\n\t#endif\n\tcin >> n >> st;\n\t//HASH(A) = {FOR I = [0...big_N] SUM OF A[I]*T^I % MODULO} WHERE T = PRIME > 2.5 * 10^5\n\tp[0] = 1;\n\tfor (int i = 1; i < N; i++) {\n\t\tp[i] = mult(p[i - 1], T);\n\t}\n\tpos[0] = 2 * n;\n\thsh[0] = 0;\n\tvector<int> a(4 * n, 0);\n\tfor (int i = 0; i < n; i++) {\n\t\tpos[i + 1] = pos[i];\n\t\thsh[i + 1] = hsh[i];\n\t\tif (st[i] == '+') {\n\t\t\tadd(hsh[i + 1], p[pos[i + 1]]);\n\t\t} else if (st[i] == '-') {\n\t\t\tadd(hsh[i + 1], -p[pos[i + 1]]);\n\t\t} else if (st[i] == '>') {\n\t\t\tpos[i + 1]++;\n\t\t} else {\n\t\t\tpos[i + 1]--;\n\t\t}\n\t}\n\tint x = get(0, n - 1).f;\n\tll ans = 0;\n\tmap<int, int> cnt;\n\tfor (int i = 0; i < n; i++) {\n\t\tint y = sum(shift(x, get(0, i - 1).s - 2 * n), shift(get(0, i - 1).f, 0));\n\t\tcnt[y]++;\n\t\tint z = shift(get(0, i).f, 0);\n\t\tans += cnt[z];\n\t}\n\tcout << ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int C = 3e5 + 7;\nconst int N = C << 1;\nconst int BASE = C;\nconst int MOD1 = 1000 * 1000 * 1000 + 7;\nconst int MOD2 = 1000 * 1000 * 1000 + 9;\nint mod1(int n) {\n    return (n % MOD1 + MOD1) % MOD1;\n}   \nint mod2(int n) {\n    return (n % MOD2 + MOD2) % MOD2;\n}   \nint x[N], pw1[N], pw2[N];\nvoid add1(int &a, int b) {\n    a = mod1(a + b);\n}   \nvoid add2(int &a, int b) {\n    a = mod2(a + b);\n}   \nint fp1(int a, int p) {\n    int ans = 1, c = a;\n    for (int i = 0; (1ll << i) <= p; ++i) {\n        if ((p >> i) & 1) ans = mod1(ans * c);\n        c = mod1(c * c);\n    }   \n    return ans;\n}   \nint dv1(int a, int b) {\n    return mod1(a * fp1(b, MOD1 - 2));\n}   \nint fp2(int a, int p) {\n    int ans = 1, c = a;\n    for (int i = 0; (1ll << i) <= p; ++i) {\n        if ((p >> i) & 1) ans = mod2(ans * c);\n        c = mod2(c * c);\n    }   \n    return ans;\n}   \nint dv2(int a, int b) {\n    return mod2(a * fp2(b, MOD2 - 2));\n}   \nint pref1[N], pref2[N];\nsigned main() {\n    #ifdef HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    #else\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    #endif\n    pw1[0] = 1;\n    for (int i = 1; i < N; ++i) pw1[i] = mod1(pw1[i - 1] * BASE);\n    pw2[0] = 1;\n    for (int i = 1; i < N; ++i) pw2[i] = mod2(pw2[i - 1] * BASE);\n    int n;\n    cin >> n;\n    string s;\n    cin >> s;\n    for (int i = 0; i < n; ++i) {\n        pref1[i + 1] = pref1[i];\n        pref2[i + 1] = pref2[i];\n        x[i + 1] = x[i];\n        if (s[i] == '<') --x[i + 1];\n        else if (s[i] == '>') ++x[i + 1];\n        else if (s[i] == '+') {\n            add1(pref1[i + 1], pw1[x[i + 1] + C]);\n            add2(pref2[i + 1], pw2[x[i + 1] + C]);\n        }\n        else {\n            add1(pref1[i + 1], -pw1[x[i + 1] + C]);\n            add2(pref2[i + 1], -pw2[x[i + 1] + C]);\n        }\n    }\n    int ans = 0;\n    map <pair <int, int>, int> d;\n    for (int i = n; i >= 0; --i) {\n        pair <int, int> w;\n        if (x[i] < 0) {\n            w.first = mod1(pref1[i] + dv1(pref1[n], pw1[-x[i]]));\n            w.second = mod2(pref2[i] + dv2(pref2[n], pw2[-x[i]]));\n        }\n        else {\n            w.first = mod1(pref1[i] + mod1(pref1[n] * pw1[x[i]]));\n            w.second = mod2(pref2[i] + mod2(pref2[n] * pw2[x[i]]));\n        }\n        ans += d[w];\n        d[{pref1[i], pref2[i]}]++;\n    }   \n    cout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long ll;\nconst int maxn = 250002;\nchar buf[maxn];\nint n,sum,s[maxn];\ninline void reduce(int & x,const int & mod){ x += x >> 31 & mod; }\ninline int pow(int a,int b,const int & mod,int ret = 1){\n\tfor(b = b % (mod - 1) + mod - 1;b;b>>=1,a=ll(a) * a % mod)if(b & 1)\n\t\tret = ll(ret) * a % mod;\n\treturn ret;\n}\nconstexpr int m0 = 1192230913,b0 = 233333;\nconstexpr int m1 = 1085276161,b1 = 2333333;\nstruct Int{\n\tint a0,a1;\n\tinline Int(int x0 = 0,int x1 = 0){ a0 = x0,a1 = x1; }\n\tinline void add(){ reduce(a0 += b0 - m0,m0); reduce(a1 += b1 - m1,m1); }\n\tinline void dec(){ reduce(a0 -= b0,m0); reduce(a1 -= b1,m1); }\n\tinline void mul(int cnt){ a0 = pow(b0,cnt,m0,a0); a1 = pow(b1,cnt,m1,a1); }\n\tinline bool operator < (const Int & b) const { return * (ll*) this < * (ll*) & b; }\n} a[maxn], b[maxn];\n\nint main()\n{\n\tstd::ios::sync_with_stdio(false),std::cin.tie(0);\n\tstd::cin >> n >> buf + 1;\n\tfor(int i = 1;i <= n;++i){\n\t\ta[i] = a[i - 1];\n\t\tif(buf[i] == '+') a[i].add();\n\t\tif(buf[i] == '-') a[i].dec();\n\t\tif(buf[i] == '>') a[i].mul(1),--sum;\n\t\tif(buf[i] == '<') a[i].mul(-1),++sum;\n\t\ts[i] = sum;\n\t\t(b[i] = a[i]).mul(sum);\n\t}\n\tll ans = 0;\n\tstd::map<Int,int> map;\n\tfor(int i = n;i >= 0;--i){\n\t\tInt x = b[n]; x.mul(s[i]);\n\t\tans += map[Int(((ll)b[i].a0 + x.a0) % m0,(b[i].a1 + x.a1) % m1)];\n\t\t++map[b[i]];\n\t}\n\tstd::cout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int N = 501000,mod = 998244353;\nll *p,_p[N],h[N];\nint W[N],n;\nchar s[N];\nmap<ll,int> mp;\nll fp(ll a,ll k){\n\tll ans=1;\n\tfor(;k;k>>=1,a=a*a%mod)\n\t\tif(k&1) ans=a*ans%mod;\n\treturn ans;\n}\nint main(){\n\tios::sync_with_stdio(0);\n\tcin>>n;\n\tcin>>s+1;\n\tp=_p+n+10;p[-n]=1;\n\tfor(int i=-n+1;i<=n;i++) p[i]=p[i-1]*434783%mod;\n\tll Thsh=0;\n\tint w=0;\n\tfor(int i=1;i<=n;i++){\n\t\tif(s[i]=='<') w--;\n\t\tif(s[i]=='>') w++;\n\t\tW[i]=w;\n\t\tif(s[i]=='+'){\n\t\t\th[i]=p[w];\n\t\t\tThsh=(Thsh+p[w])%mod;\n\t\t}\n\t\tif(s[i]=='-'){\n\t\t\th[i]=mod-p[w];\n\t\t\tThsh=(Thsh-p[w]+mod)%mod;\n\t\t}\n\t\tmp[Thsh]++;\n\t}\n\tll now=0,ans=0;\n\tfor(int i=1;i<=n;i++){\n\t\tif(W[i-1]>0) ans+=mp[(Thsh*fp(434783,W[i-1])+now)%mod];\n\t\telse ans+=mp[(Thsh*fp(743624691,-W[i-1])+now)%mod];\n\t\tif(s[i]=='-'||s[i]=='+') now=(now+h[i])%mod;\n\t\tmp[now]--;\n\t}\n\tcout<<ans<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fo(i, n) for(int i = 1; i <= n; ++i)\n#define pb push_back\n\ntypedef long long ll;\n\nconst int N = 500050;\nconst int mod = 1e9 + 7;\nconst ll inf = 2e18;\nint n;\nstring s;\nvector<pair<int, int> > dp[500500];\nbitset<5005> pos[500500];\nint f[N];\nbitset<5005> can[10005];\n\nint main() {\n    ios::sync_with_stdio(0); cin.tie(0);\n    cin >> n >> s;\n    assert(n <= 5000);\n    int bal = 0;\n    for(int i = 0; i < n; ++i) {\n        if(s[i] == '>')\n            ++bal;\n        else if(s[i] == '<')\n            --bal;\n\n        if(s[i] == '+') dp[bal + n].pb({i + 1,  1});\n        else if(s[i] == '-') dp[bal + n].pb({i + 1, -1});\n    }\n    for(int i = 1; i <= n; ++i)\n        for(int j = 0; j < i; ++j)\n            can[i][j] = 1;\n\n    for(int bal = 0; bal <= n + n; ++bal) {\n        if(dp[bal].empty()) continue;\n        int must = 0;\n        for(auto &x : dp[bal]) must += x.second;\n        cerr<<bal - n << \"! \" << ' '<<must<< endl;\n        for(auto &x : dp[bal]) {\n            cerr<<x.first << ' '<<x.second << '\\n';\n        }\n        int cur = 0;\n        for(int i = 1; i <= n; ++i) f[i] = 0;\n        for(auto &x : dp[bal])\n            f[x.first] = x.second;\n        pos[0 + n][1] = 1;\n        for(int i = 1; i <= n; ++i) {\n            f[i] += f[i - 1];\n            can[i] &= pos[f[i] - must + n];\n            pos[f[i] + n][i + 1] = 1;\n        }\n        pos[0 + n].reset();\n        for(int i = 1; i <= n; ++i)\n            pos[f[i] + n].reset();\n\n    }\n    int ans = 0;\n    fo(i, n) {\n        ans += can[i].count();\n    }\n    cout << ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <map>\n#include <set>\n\ntypedef unsigned long long ull;\nconst ull H=300031;\nconst int SZ=300000;                // need SZ > n\n//const ull H=10;\n//const int SZ=6;\nconst int INF=0x3f3f3f3f;\n\null h0,h1,h2;\n\nint n;\nchar s[SZ];\n\null hashes[SZ*2+5];\null shash[SZ];\nint p;\n\n// if the interval [i,zerojump[i]) is eaten, then result is 0 everywhere\n// also zerojump[i]>=i and zerojump is minimal\nstd::map<ull,int> m;\nint zerojump[SZ];\nint extraans[SZ];\n\nstd::map<ull,int> m2;       // answer search\nstd::set<int> s2[SZ];\nstd::set<int>::iterator it;\n\nlong long ans=0;\n\nint main()\n{\n    #ifdef NOT_DMOJ\n    freopen(\"data.txt\",\"r\",stdin);\n    #endif // NOT_DMOJ\n    hashes[0]=1;\n    for (int i=1; i<=SZ*2; i++) {\n        hashes[i]=hashes[i-1]*H;\n    }\n    scanf(\"%d\",&n);\n    scanf(\" %s\",s);\n    // get zerojump\n    int p=0;\n    h1=h2=0;\n    memset(zerojump,0x3f,sizeof zerojump);\n    m2[0]=0;\n    s2[0].insert(0);\n    m[0]=0;\n    for (int i=0; i<n; i++) {\n        // do the action\n        if (s[i]=='<') p--;\n        else if (s[i]=='>') p++;\n        else if (s[i]=='+') {\n            h1+=hashes[p+SZ];\n        }\n        else {\n            h1-=hashes[p+SZ];\n        }\n        shash[i+1]=h1;\n        h2=h1*hashes[SZ];\n        // zerojump logic\n        if (m.count(h1)) {\n            zerojump[m[h1]]=i+1;\n            m[h1]=i+1;\n            s2[m2[h2]].insert(i+1);\n        }\n        else {\n            m[h1]=i+1;\n            m2[h2]=i+1;\n            s2[i+1].insert(i+1);\n        }\n        //printf(\"s2 %d insert %d\\n\",m2[h2],i+1);\n    }\n    // fill in extraans\n    extraans[n]=1;\n    for (int i=n-1; i>=0; i--) {\n        if (zerojump[i]==INF) extraans[i]=1;\n        else extraans[i]=1+extraans[zerojump[i]];\n    }\n    // get answer\n    // note: shash[n] is the final hash value wanted\n    for (int i=0; i<SZ; i++) {\n        if (s2[i].empty()) continue;\n        s2[i].insert(INF);\n    }\n    p=SZ;\n    //for (auto aa:m2) printf(\"h2      %lld %d\\n\",aa);\n    //for (int i=0; i<=n; i++) printf(\"sh %d %lld\\n\",i,shash[i]);\n    for (int i=0; i<n; i++) {\n        h2=(shash[n]*hashes[p]+shash[i]*hashes[SZ]);\n        //printf(\"go find %lld\\n\",h2);\n        if (m2.count(h2)) {\n            it=s2[m2[h2]].lower_bound(i+1);\n            //printf(\"index %d got %d\\n\",i,*it);\n            if ((*it)!=INF) {\n                //printf(\"extraans %d\\n\",extraans[*it]);\n                ans+=extraans[*it];\n            }\n        }\n        if (s[i]=='<') p--;\n        else if (s[i]=='>') p++;\n    }\n    printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "    #include \"bits/stdc++.h\"\n    using namespace std;\n     \n    #define MAX 500012\n     \n    int n;\n    char buf[MAX];\n     \n     \n    string s;\n     \n     \n    //#define MOD1 1000000007\n    //#define MOD2 1000000009\n     \n    valarray<long long int> MOD1;\n    valarray<long long int> MOD2;\n    vector<valarray<long long int> > p2;\n    vector<valarray<long long int> > vv;\n    vector<int> ps;\n    map<pair<long long int,long long int>, int> mp;\n    long long int ppow(long long int i, long long int j, long long int MOD) {\n    \tlong long int ret = 1;\n    \twhile (j) {\n    \t\tif (j & 1LL)ret *= i;\n    \t\tif (ret >= MOD)ret %= MOD;\n    \t\tj >>= 1LL;\n    \t}\n    \treturn ret;\n    }\n     \n    valarray<long long int> calc(int dif) {\n    \tvalarray<long long int> ret;\n    \tret.resize(2, 0);\n    \tfor (int j = 0; j < 2; j++) {\n    \t\tif (dif < 0) {\n    \t\t\tret[j]=ppow(ppow(MOD1[j], abs(dif),MOD2[j]), MOD2[j] - 2,MOD2[j]);\n    \t\t}\n    \t\telse {\n    \t\t\tret[j] = ppow(MOD1[j], abs(dif), MOD2[j]);\n    \t\t}\n    \t}\n    \treturn ret;\n    }\n     \n    int main() {\n    \tMOD1.resize(2);\n    \tMOD2.resize(2);\n    \tp2.push_back(valarray<long long int>());\n    \tp2.back().resize(2);\n    \tp2.back()[0] = p2.back()[1] = 1;\n    \tMOD2[0] = 1000000007;\n    \tMOD1[0] = 998244353;\n    \tMOD1[1] = 555522277;\n    \tMOD2[1] = 895612782;\n    \tp2[0] %= MOD2;\n    \tfor (int i = 1; i < MAX; i++) {\n    \t\tp2.push_back(p2.back());\n    \t\tp2[i] *= MOD1;\n    \t\tp2[i] %= MOD2;\n    \t}\n    \tcin >> n;\n    \tscanf(\"%s\", buf);\n    \ts = buf;\n    \tint pos = MAX/2;\n    \tvalarray<long long int> hs;\n    \ths.resize(2);\n    \ths[0] = hs[1] = 0;\n    \tvv.push_back(hs);\n    \tps.push_back(pos);\n    \tfor (int i = 0; i < s.size(); i++) {\n    \t\tif (s[i] == '<') {\n    \t\t\tpos--;\n    \t\t}\n    \t\tif (s[i] == '>') {\n    \t\t\tpos++;\n    \t\t}\n    \t\tif (s[i] == '+') {\n    \t\t\ths += p2[pos];\n    \t\t}\n    \t\tif (s[i] == '-') {\n    \t\t\ths -= p2[pos];\n    \t\t\ths += MOD2;\n    \t\t}\n    \t\ths %= MOD2;\n    \t\tvv.push_back(hs);\n    \t\tps.push_back(pos);\n    \t}\n    \tlong long int way = 0;\n    \tfor (int i = vv.size() - 1; i >= 0; i--) {\n    \t\tvalarray<long long int> want = vv[i] + vv.back()*calc(-MAX/2+ps[i]);\n    \t\twant = want%MOD2;\n    \t\tway += mp[make_pair(want[0], want[1])];\n    \t\t//cerr << \"dbg \" << way << endl;\n    \t\tif(want[0]<0LL||want[1]<0LL)exit(1);\n    \t\tif(vv[i][0]<0LL||want[1]<0LL)exit(1);\n    \t\tmp[make_pair(vv[i][0],vv[i][1])]++;\n    \t}\n    \tprintf(\"%lld\\n\", way);\n    \treturn 0;\n    }"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <vector>\n\nconst int DEBUG = 0;\n\n#define MOCK 1\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define DEBUGP(val) cerr << #val << \"=\" << val << \"\\n\"\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\ntypedef pair<ll, ll> PL;\n\n\nll powmod(ll a, ll e, ll mod) {\n  ll sum = 1;\n  ll cur = a;\n  while (e > 0) {\n    if (e % 2) {\n      sum = sum * cur % mod;\n    }\n    cur = cur * cur % mod;\n    e /= 2;\n  }\n  return sum;\n}\n\nconst int A = 7;\n\nint main(void) {\n  const ll mod = 1e9 + 7;\n  const ll mod2 = 1e9 + 9;\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  string s;\n  cin >> n >> s;\n  int p = 0;\n  VI pos(n + 1);\n  mt19937 mt;\n  VL b(A);\n  ll mods[A] = {};\n  REP(i, 0, A) mods[i] = 1e9 + 7;\n  \n  REP(c, 0, A) {\n    do {\n      b[c] = mt() % mods[c];\n    } while (b[c] == 0);\n  }\n  vector<VL> hsh(A, VL(n + 1));\n  ll inv[A] = { 0 };\n  REP(c, 0, A) inv[c] = powmod(b[c], mods[c] - 2, mods[c]);\n  REP(c, 0, A) {\n    p = 0;\n    ll cur = 1;\n    REP(i, 0, n) {\n      ll tmp = hsh[c][i];\n      if (s[i] == '>') {\n        p++;\n        cur = cur * b[c] % mods[c];\n      }\n      if (s[i] == '<') {\n        p--;\n        cur = cur * inv[c] % mods[c];\n      }\n      if (s[i] == '+') {\n        tmp = (tmp + cur) % mods[c];\n      }\n      if (s[i] == '-') {\n        tmp = (tmp + mods[c] - cur) % mods[c];\n      }\n      hsh[c][i + 1] = tmp;\n      pos[i + 1] = p;\n    }\n  }\n  if (DEBUG) {\n    REP(i, 0, n + 1) {\n      cerr << i << \" \" << hsh[0][i] << endl;\n    }\n  }\n  VL meguru(A);\n  REP(c, 0, A) meguru[c] = hsh[c][n];\n  map<VL, int> kirika;\n  kirika[meguru] = 1;\n  ll tot = 0;\n  VL cur(A);\n  REP(c, 0, A) cur[c] = powmod(b[c], pos[n], mods[c]);\n  for (int i = n - 1; i >= 0; --i) {\n    if (DEBUG) {\n      DEBUGP(i);\n      DEBUGP(pos[i]);\n    }\n    if (pos[i + 1] - pos[i] == 1) {\n      REP(c, 0, A) cur[c] = cur[c] * inv[c] % mods[c];\n    }\n    else if (pos[i + 1] - pos[i] == -1) {\n      REP(c, 0, A) cur[c] = cur[c] * b[c] % mods[c];\n    }\n    VL ken(A);\n    REP(c, 0, A) ken[c] = cur[c] * meguru[c] + hsh[c][i] % mods[c];\n    tot += kirika[ken];\n    VL tt(A);\n    REP(c, 0, A) tt[c] = hsh[c][i];\n    kirika[tt] += 1;\n  }\n  cout << tot << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <map>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define ll long long\n\nconst int maxN = 250011;\nconst ll mod = 1000000007;\nconst ll base = 2 * 250013 + 7;\n\nll poww(ll a, ll b) {\n    ll ans = 1;\n    while (b > 0) {\n        if (b & 1) ans = (ans * a) % mod;\n        b >>= 1;\n        a = (a * a) % mod;\n    }\n    return ans;\n}\n\nstruct smart_map {\n    map<ll, ll> M;\n    ll bonus;\n\n    smart_map() {\n        M.clear();\n        bonus = 1;\n    }\n\n    void operator*=(ll v) {\n        bonus = (bonus * v) % mod;\n    }\n\n    void add(ll x) {\n        x = (x * poww(bonus, mod - 2)) % mod;\n        M[x]++;\n    }\n\n    ll query(ll x) {\n        x = (x * poww(bonus, mod - 2)) % mod;\n        return M[x];\n    }\n};\n\nll n, i, act, full;\nchar s[maxN];\nsmart_map data;\nconst ll inv_base = poww(base, mod - 2);\nll ans;\n\nint main()\n{\n   // freopen(\"test.in\",\"r\",stdin);\n\n    scanf(\"%d\\n%s\", &n, s + 1);\n\n    data.add(0);\n    act = 0;\n\n    for (i = n; i >= 1; i--) {\n        if (s[i] == '+') act = (act + 1) % mod;    \n        if (s[i] == '-') act = (act + mod - 1) % mod;\n        if (s[i] == '<') act = (act * base) % mod;\n        if (s[i] == '>') act = (act * inv_base) % mod;\n    }\n\n    full = act;\n    act = 0;\n\n    for (i = n; i >= 1; i--) {\n        if (s[i] == '+') act = (act + 1) % mod;    \n        if (s[i] == '-') act = (act + mod - 1) % mod;\n        if (s[i] == '<') act = (act * base) % mod, data *= base;\n        if (s[i] == '>') act = (act * inv_base) % mod, data *= inv_base;\n    \n        ll src = (mod + act - full) % mod;\n        ans += data.query(src);\n\n        data.add(act);\n    }\n\n    printf(\"%lld\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nint gcd(int a, int b) { return b ? gcd(b, a % b) : a; }\ntemplate<typename T, typename U> inline bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> inline bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\nstruct Init {\n    Init() {\n        cout << fixed << setprecision(20);\n    };\n} init;\n\nint N;\nstring S;\nint mod = 1e9 + 7;\n\n// 拡張ユークリッドの互除法\nint extgcd(int a, int b, int &x, int &y) {\n    int d = a;\n    if (b != 0) {\n        d = extgcd(b, a % b, y, x);\n        y -= (a / b) * x;\n    } else {\n        x = 1;\n        y = 0;\n    }\n    return d;\n}\n\n// mod逆元\nint mod_inverse(int a, int m) {\n    int x, y;\n    extgcd(a, m, x, y);\n    return (m + x % m) % m;\n}\n\npint f(pint ab, int i, int hash) {\n    if (S[i] == '+') { return pint(ab.first, (ab.second + 1) % mod); }\n    else if (S[i] == '-') { return pint(ab.first, (ab.second - 1 + mod) % mod); }\n    else if (S[i] == '>') { return pint(ab.first * hash % mod, ab.second * hash % mod); }\n    else if (S[i] == '<') {\n        return pint(ab.first * mod_inverse(hash, mod) % mod,\n                    ab.second * mod_inverse(hash, mod) % mod);\n    }\n}\n\npint finv(pint ab, int i, int hash) {\n    if (S[i] == '-') { return pint(ab.first, (ab.second + 1) % mod); }\n    else if (S[i] == '+') { return pint(ab.first, (ab.second - 1 + mod) % mod); }\n    else if (S[i] == '<') { return pint(ab.first * hash % mod, ab.second * hash % mod); }\n    else if (S[i] == '>') {\n        return pint(ab.first * mod_inverse(hash, mod) % mod,\n                    ab.second * mod_inverse(hash, mod) % mod);\n    }\n}\nsigned main() {\n    cin >> N >> S;\n    const int K = 1;\n    vint hash = {114514, 1919, 810};\n    map<int, int> mp[K];\n    pint b[K], c[K];\n    for (int i = 0; i < K; i++) {\n        int h = hash[i];\n        b[i] = c[i] = pint(1, 0);\n        for (int j = N - 1; j >= 0; j--) { b[i] = f(b[i], j, h), mp[i][0] = 1; }\n    }\n    int ans = 0;\n    for (int i = N - 1; i >= 0; i--) {\n        int cur = LLONG_MAX;\n        for (int j = 0; j < K; j++) {\n            int h = hash[j];\n            pint cc = finv(pint(1, 0), i, h);\n            c[j] = pint(c[j].first * cc.first % mod, (c[j].first * cc.second + c[j].second) % mod);\n            int fi = (c[j].first * b[j].second + c[j].second) % mod;\n            chmin(cur, mp[j][fi]);\n            mp[j][c[j].second]++;\n        }\n        ans += cur;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\n\nconst int MAXN = 250005;\nconst lint mod = 1e15 + 37;\nconst int base = 257;\nint n, pos[MAXN];\nchar str[MAXN];\nlint pwr[MAXN * 2];\nlint inv[MAXN * 2];\n\nlint ipow(lint x, lint p){\n  lint ret = 1, piv = x;\n  while(p){\n    if(p & 1) ret = (__int128) ret * piv % mod;\n    piv = (__int128) piv * piv % mod;\n    p >>= 1;\n  }\n  return ret;\n}\n\nlint psum[MAXN];\n\nint main(){\n  cin >> n >> (str + 1);\n  pwr[0] = inv[0] = 1;\n  for(int i=1; i<MAXN * 2; i++){\n    pwr[i] = pwr[i-1] * base % mod;\n    inv[i] = ipow(pwr[i], mod - 2);\n  }\n  pos[0] = n;\n  for(int i=1; i<=n; i++){\n    pos[i] = pos[i-1];\n    psum[i] = psum[i-1];\n    if(str[i] == '<') pos[i]--;\n    if(str[i] == '>') pos[i]++;\n    if(str[i] == '+') psum[i] += pwr[pos[i]];\n    if(str[i] == '-') psum[i] += mod - pwr[pos[i]];\n    psum[i] %= mod;\n  }\n  lint H = psum[n];\n  lint ret = 0;\n  map<int, int> mp;\n  for(int i=n; i; i--){\n    mp[psum[i]]++;\n    __int128 Hv = H;\n    if(pos[0] <= pos[i-1]) Hv *= pwr[pos[i-1] - pos[0]];\n    else Hv *= inv[pos[0] - pos[i-1]];\n    Hv += psum[i-1];\n    Hv %= mod;\n    ret += mp[Hv];\n  }\n  cout << ret << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN=250000;\nconst int HMOD=1000000007;\nconst int NHASH=2;\nint HMLT[NHASH];\nint HINV[NHASH];\nstruct Op { int a[NHASH],b[NHASH]; };\nint pw(int x,int n) { int ret=1; while(true) { if(n&1) ret=(ll)ret*x%HMOD; if((n>>=1)==0) return ret; x=(ll)x*x%HMOD; } }\n\nOp combine(const Op &p,const Op &q) { Op ret; REP(i,NHASH) { ret.a[i]=(ll)p.a[i]*q.a[i]%HMOD; ret.b[i]=((ll)p.a[i]*q.b[i]+p.b[i])%HMOD; } return ret; }\nvoid eval(const Op &p,const int q[NHASH],int ret[NHASH]) { REP(i,NHASH) ret[i]=((ll)p.a[i]*q[i]+p.b[i])%HMOD; }\n\nint n; char s[MAXN+1];\n\nOp opid;\nOp opgt,iopgt;\nOp oplt,ioplt;\nOp oppl,ioppl;\nOp opmn,iopmn;\nOp f[MAXN];\nOp g[MAXN];\n\nOp ff[MAXN+1]; // ff[i] is composition of f for suffix starting at i\nOp gg[MAXN+1]; // gg[i] is composition of g for suffix starting at i\n\nint id[NHASH];\nint fx[NHASH];\nint gx[MAXN+1][NHASH];\nint hx[MAXN+1][NHASH];\n\nmap<vector<int>,int> mp;\n\nvoid run() {\n\tscanf(\"%d%s\",&n,s);\n\n\tREP(i,n) switch(s[i]) {\n\t\tcase '>': f[i]=opgt,g[i]=iopgt; break;\n\t\tcase '<': f[i]=oplt,g[i]=ioplt; break;\n\t\tcase '+': f[i]=oppl,g[i]=ioppl; break;\n\t\tcase '-': f[i]=opmn,g[i]=iopmn; break;\n\t\tdefault: assert(false);\n\t}\n\n\tff[n]=opid; for(int i=n-1;i>=0;--i) ff[i]=combine(f[i],ff[i+1]);\n\tgg[n]=opid; for(int i=n-1;i>=0;--i) gg[i]=combine(gg[i+1],g[i]);\n\t\n\tmemset(id,0,sizeof(id));\n\teval(ff[0],id,fx);\n\tREPE(i,n) eval(gg[i],id,gx[i]);\n\tREPE(i,n) eval(gg[i],fx,hx[i]);\n\n\t//printf(\"fx:\"); printf(\" %d\\n\",fx[0]);\n\t//printf(\"gx:\"); REPE(i,n) printf(\" %10d\",gx[i][0]); puts(\"\");\n\t//printf(\"hx:\"); REPE(i,n) printf(\" %10d\",hx[i][0]); puts(\"\");\n\n\tll ret=0;\n\tfor(int i=n;i>=0;--i) {\n\t\tvector<int> vg(NHASH),vh(NHASH); REP(j,NHASH) vg[j]=gx[i][j],vh[j]=hx[i][j];\n\t\tret+=mp[vh]; ++mp[vg];\n\t}\n\tprintf(\"%lld\\n\",ret);\n}\n\nvoid init() {\n\tREP(i,NHASH) { int x=0; REP(j,100) x=((ll)x*1000+rand()%1000)%HMOD; HMLT[i]=x; HINV[i]=pw(x,HMOD-2); }\n\t//printf(\"HMLT:\"); REP(i,NHASH) printf(\" %d\",HMLT[i]); puts(\"\");\n\tREP(i,NHASH) {\n\t\topid.a[i]=1,opid.b[i]=0;\n\t\topgt.a[i]=HMLT[i],opgt.b[i]=0;\n\t\toplt.a[i]=HINV[i],oplt.b[i]=0;\n\t\toppl.a[i]=1,oppl.b[i]=1;\n\t\topmn.a[i]=1,opmn.b[i]=HMOD-1;\n\t\tiopgt=oplt,ioplt=opgt,ioppl=opmn,iopmn=oppl;\n\t}\n}\n\nint main() {\n\tinit();\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 250001,long long M = (long double)1e18 + 31,b = 1e9 + 7;\nlong long cs[N],p[N],n;\nmap<long long,int>mp;\nvoid add(long long &a,long long b){\n\ta+=b;\n\tif(a >= M)a-=M;\n\tif(a < 0)a+=M;\n}\nlong long power(long long base,long long to){\n\tlong long ret = 1;\n\twhile(to){\n\t\tif(to&1)ret = (__int128)ret*base%M;\n\t\tto>>=1;\n\t\tbase = (__int128)base*base%M;\n\t}\n\treturn ret;\n}\nint main(){\n//\tfreopen(\"readin.txt\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tp[0] = 1;\n\tchar c;\n\tlong long inv = power(b,M - 2);\n\tfor(int i = 1;i <= n;i++){\n\t\tscanf(\" %c\",&c);\n\t\tcs[i] = cs[i - 1];\n\t\tp[i] = p[i - 1];\n\t\tif(c == '+')add(cs[i],p[i]);\n\t\telse if(c == '-')add(cs[i],-p[i]);\n\t\telse if(c == '>')p[i] = (__int128)p[i]*b%M;\n\t\telse if(c == '<')p[i] = (__int128)p[i]*inv%M;\n\t}\n\tlong long ans = 0;\n\tfor(int i = 0;i <= n;i++){\n\t\tans+=mp[cs[i]];\n\t\tmp[((__int128)cs[n]*p[i]%M + cs[i] + M)%M]++;\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000009;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\ntypedef pair<int, bool> sP;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef pair<ll, ll> LP;\ntypedef vector<ll> vec;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef vector<vector<ll>> mat;\ntypedef vector<ll> vec;\n\nll r = 998244353;\nll mod_pow(ll x, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n % 2)res = res * x%mod;\n\t\tx = x * x%mod; n >>= 1;\n\t}\n\treturn res;\n}\nll invr = mod_pow(r, mod-2);\n\nll tr[300000];\nll invtr[300000];\nvoid init() {\n\ttr[0] = invtr[0] = 1;\n\trep(i, 299999) {\n\t\ttr[i + 1] = tr[i] * r%mod;\n\t\tinvtr[i + 1] = invtr[i] * invr%mod;\n\t}\n}\n\nvoid solve() {\n\tint n; cin >> n;\n\tstring s; cin >> s;\n\tll sum = 0; int loc = 0;\n\tvector<ll> memo(n);\n\tvector<int> locs(n);\n\trep(i, n) {\n\t\tif (s[i] == '>')loc++;\n\t\telse if (s[i] == '<')loc--;\n\t\telse if (s[i] == '+') {\n\t\t\tif (loc >= 0) {\n\t\t\t\tsum += tr[loc];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsum += invtr[-loc];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (loc >= 0) {\n\t\t\t\tsum -= tr[loc];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsum -= invtr[-loc];\n\t\t\t}\n\t\t}\n\t\tsum = (sum%mod + mod) % mod;\n\t\tmemo[i] = sum;\n\t\tlocs[i] = loc;\n\t}\n\tll all = sum;\n\t//cout << all << endl;\n\tll ans = 0;\n\tmap<ll, int> mp;\n\tmp[all]++;\n\trep(i, n) {\n\t\t//cout << mp[memo[i]] << endl;\n\t\tans += mp[memo[i]];\n\t\tll nex = all;\n\t\tif (nex < 0)nex += mod;\n\t\tif (locs[i] >= 0) {\n\t\t\tnex = nex * tr[locs[i]] % mod;\n\t\t}\n\t\telse {\n\t\t\tnex = nex * invtr[-locs[i]] % mod;\n\t\t}\n\t\tnex += memo[i];\n\t\tnex %= mod;\n\t\tmp[nex]++;\n\t}\n\tcout << ans << endl;\n}\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(7);\n\tinit();\n\t//output_tree(10);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <unordered_map>\n#define FILL(a, n, x) memset((a), (x), sizeof ((a)[0]) * (n))\n#define COPY(a, n, b) memcpy((b), (a), sizeof ((a)[0]) * (n))\nusing namespace std;\n\ntypedef long long li;\nconst li infl = ~0LLU >> 2;\n\n// template <class T>\n// inline void Min(T &x, T y) {\n//   if (y < x) x = y;\n// }\n// template <class T>\n// inline void Max(T &x, T y) {\n//   if (y > x) x = y;\n// }\n\nconst int mod = 1e9 + 7;\ninline int Add(int x) { return x >= mod ? x - mod : x; }\ninline void Add(int &x, int y) { x += y; if (x >= mod) x -= mod; }\ninline int Sub(int x) { return x < 0 ? x + mod : x; }\ninline void Sub(int &x, int y) { x -= y; if (x < 0) x += mod; }\ninline int Mul(int x, int y) { return (int)((li)x * y % mod); }\ninline int Mul(int x, int y, int z) { return Mul(x, Mul(y, z)); }\nint Pow(int x, int y) {\n  int z = 1;\n  for (; y; y >>= 1) {\n    if (y & 1) z = Mul(z, x);\n    x = Mul(x, x);\n  }\n  return z;\n}\nint Inv(int x) {\n  return Pow(x, mod - 2);\n}\n\n// ----------------------------------------\n\nconst int maxn = 2.5e5;\nconst int base = 1000037, invbase = Inv(base);\n\nint _pow[maxn * 2 + 1], *pow = _pow + maxn;\n\nvoid Init(int n) {\n  pow[0] = 1;\n  for (int i = 1; i <= n; ++i) {\n    pow[i] = Mul(pow[i - 1], base);\n    pow[-i] = Mul(pow[-i + 1], invbase);\n  }\n}\n\nint n;\nchar str[maxn + 1];\nint delta[maxn + 1], sum[maxn + 1];\n\nint main(void) {\n  scanf(\"%d%s\", &n, str);\n  Init(n);\n  delta[0] = 0;\n  sum[0] = 0;\n  for (int i = 1; i <= n; ++i) {\n    switch (str[i - 1]) {\n    case '+':\n      delta[i] = delta[i - 1];\n      sum[i] = Add(sum[i - 1] + pow[delta[i]]);\n      break;\n    case '-':\n      delta[i] = delta[i - 1];\n      sum[i] = Sub(sum[i - 1] - pow[delta[i]]);\n      break;\n    case '<':\n      delta[i] = delta[i - 1] - 1;\n      sum[i] = sum[i - 1];\n      break;\n    case '>':\n      delta[i] = delta[i - 1] + 1;\n      sum[i] = sum[i - 1];\n      break;\n    }\n  }\n  unordered_map<int, int> cnt;\n  li ans = 0;\n  for (int i = n; i >= 0; --i) {\n    if (i < n) {\n      int target = Add(sum[i] + Mul(pow[delta[i]], sum[n]));\n      ans += cnt[target];\n    }\n    ++cnt[sum[i]];\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MN 250000\n#define mod 1004535809\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nchar s[MN+5];\nmap<int,int> mp;long long ans;\nint n,pw[MN*2+5],invpw[MN*2+5],pos[MN+5],ha[MN+5];\ninline int PW(int x){return x>=0?pw[x]:invpw[-x];} \nint main()\n{\n\tn=read();scanf(\"%s\",s+1);pw[0]=invpw[0]=1;\n\tfor(int i=1;i<=n*2;++i) pw[i]=255555LL*pw[i-1]%mod,invpw[i]=449471353LL*invpw[i-1]%mod;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tif(s[i]=='<'||s[i]=='>') \n\t\t\tpos[i]=pos[i-1]+(s[i]=='<'?-1:1),ha[i]=ha[i-1];\n\t\telse pos[i]=pos[i-1],ha[i]=(ha[i-1]+1LL*(s[i]=='+'?1:mod-1)*pw[pos[i]+n])%mod;\n\t}\n\tfor(int i=n;i;--i)\n\t{\n\t\t++mp[(ha[n]-ha[i]+mod)%mod];\n\t\tans+=mp[(1LL*ha[n]*(mod+1-PW(pos[i-1]))+mod-ha[i-1])%mod];\n\t}\n\tcout<<ans;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int mod = 1000000007;\nconst int arg1 = 1519153;\nconst int Maxn = 250005;\n\nint iarg1;\nint n;\nchar S[Maxn];\nint A[Maxn], B[Maxn];\nmap <int, int> M;\nll res;\n\nint toPower(int a, int p)\n{\n\tint res = 1;\n\twhile (p) {\n\t\tif (p & 1) res = ll(res) * a % mod;\n\t\tp >>= 1; a = ll(a) * a % mod;\n\t}\n\treturn res;\n}\n\nint Inv(int a) { return toPower(a, mod - 2); }\n\nint main()\n{\n\tiarg1 = Inv(arg1);\n\tscanf(\"%d\", &n);\n\tscanf(\"%s\", S + 1);\n\tA[0] = 1; B[0] = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (S[i] == '+') { A[i] = 1; B[i] = 1; }\n\t\telse if (S[i] == '-') { A[i] = 1; B[i] = mod - 1; }\n\t\telse if (S[i] == '>') { A[i] = arg1; B[i] = 0; }\n\t\telse if (S[i] == '<') { A[i] = iarg1; B[i] = 0; }\n\t\tB[i] = (ll(B[i - 1]) * A[i] + ll(B[i])) % mod;\n\t\tA[i] = ll(A[i - 1]) * A[i] % mod;\n\t}\n\tint X = ll(B[n]) * Inv(A[n]) % mod;\n\tM[X]++;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint ainv = Inv(A[i]);\n\t\tint need = ll(B[i]) * ainv % mod;\n\t\tauto it = M.find(need);\n\t\tif (it != M.end()) res += it->second;\n\t\tM[ll(X + B[i]) * ainv % mod]++;\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1e9 + 7;\nconst int N = 2e5 + 5;\nconst int X = 145331217;\ntypedef long long ll;\n\n\nchar c;\nstring s;\nll n,i,t,a,b,x,bol=1,ans;\nmap < int , int > M;\n\nint main(){\n    cin >> n >> s;\n    for(t=X,i=mod-2; i ; i>>=1){\n        if(i & 1) bol = bol*t % mod;\n        t = t*t % mod;\n    }\n    for(i=n-1; i>=0 ;i--){\n        c = s[i];\n        if(c == '+') x++;\n        if(c == '-') x--;\n        if(c == '>') x *= X;\n        if(c == '<') x *= bol;\n        x = (x % mod + mod) % mod;\n    }\n\n    a = 1; b = 0;\n    M[0] = 1;\n    for(i=n-1; i>=0 ;i--){\n        c = s[i];\n        if(c == '+') b -= a;\n        if(c == '-') b += a;\n        if(c == '>') a *= bol;\n        if(c == '<') a *= X;\n        a = (a % mod + mod) % mod;\n        b = (b % mod + mod) % mod;\n        t = (a*x + b) % mod;\n        ans += M[t];\n        M[b]++;\n    }\n\n    cout << ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint ungigned\n#define db double\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pli pair<ll,int>\n#define vi vector<int>\n#define vpi vector<pii >\n#define IT iterator\n\n#define PB push_back\n#define MK make_pair\n#define LB lower_bound\n#define UB upper_bound\n#define BG begin\n#define ED end\n\n#define For(i,j,k) for (int i=(j);i<=(int)k;i++)\n#define Rep(i,j,k) for (int i=(j);i>=(int)k;i++)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n\n#define LS3 k*2,l,mid\n#define RS3 k*2+1,mid+1,r\n#define LS5 k*2,l,mid,x,y\n#define RS5 k*2+1,mid+1,r,x,y\n#define GET pushdown(k);int mid=(l+r)/2\nusing namespace std;\n\nconst int BAS[5]={233,666,1234,19260817,2017};\nconst int mo=998244353;\nconst int N=250005;\nstruct wzp{\n\tint a[5];\n\tbool operator <(const wzp &x)const{\n\t\tFor(i,0,4)\n\t\t\tif (a[i]!=x.a[i])\n\t\t\t\treturn a[i]<x.a[i];\n\t\treturn 0;\n\t}\n\tbool operator ==(const wzp &x)const{\n\t\tFor(i,0,4)\n\t\t\tif (a[i]!=x.a[i])\n\t\t\t\treturn 0;\n\t\treturn 1;\n\t}\n};\nint P[5][N*2];\nwzp hsh[N];\nint pos[N];\nlong long ans;\nmap<wzp,int> mp;\nchar s[N];\nint power(int x,int y){\n\tint s=1;\n\tfor (;y;y/=2,x=1ll*x*x%mo)\n\t\tif (y&1) s=1ll*s*x%mo;\n\treturn s;\n}\nint main(){\n\tFor(i,0,4){\n\t\tP[i][0]=1;\n\t\tFor(j,1,2*N-1)\n\t\t\tP[i][j]=1ll*P[i][j-1]*BAS[i]%mo;\n\t}\n\tint beg=N,l; pos[0]=N;\n\tscanf(\"%d%s\",&l,s+1);\n\tfor (int i=1;i<=l;i++){\n\t\thsh[i]=hsh[i-1];\n\t\tif (s[i]=='+') For(j,0,4) hsh[i].a[j]=(hsh[i].a[j]+P[j][beg])%mo;\n\t\tif (s[i]=='-') For(j,0,4) hsh[i].a[j]=(hsh[i].a[j]+mo-P[j][beg])%mo;\n\t\tif (s[i]=='<') beg--; if (s[i]=='>') beg++; pos[i]=beg;\n\t}\n\tfor (int i=0;i<=l;i++)\n\t\tmp[hsh[i]]++;\n\tfor (int i=0;i<l;i++){\n\t\twzp rpos=hsh[l]; mp[hsh[i]]--;\n\t\tFor(j,0,4) rpos.a[j]=1ll*rpos.a[j]*power(BAS[j],(mo-1)+pos[i]-pos[0])%mo;\n\t\tFor(j,0,4) rpos.a[j]=(rpos.a[j]+hsh[i].a[j])%mo;\n\t\tans+=mp[rpos];\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "/*\n* C++11 code template for contests.\n* @author: Andrei Kalendarov\n* @e-mail: andreykalendarov@gmail.com\n*/\n\n//#define ANDREIKKAA_ALLOCATOR\nconst int _ML = 228;\n\nconst char _inpf[] =\n#if defined(ANDREIKKAA)\n    \"input.txt\"\n#else\n    \"\"\n#endif\n;\nconst char _outf[] =\n#if defined(ANDREIKKAA)\n    \"\"\n#else\n    \"\"\n#endif\n;\n\n#if defined(ANDREIKKAA)\n#undef NDEBUG\n#else\n#pragma GCC optimize(\"O3,no-stack-protector\")\n#endif\n#include <bits/stdc++.h>\n#if !defined(ANDREIKKAA)\n#define endl '\\n'\n#endif\n#define x first\n#define y second\nusing namespace std;\n#define rand abcdefghijklmnopqrstuvwxyz\n#define random_shuffle abcdefghijklmnopqrstuvwxyz\n#define all(x) (x).begin(), (x).end()\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef double ld;\nconst ld PI = 3.14159265358979323846;\nmt19937 rd(228);\n#if defined(ANDREIKKAA_ALLOCATOR)\nchar _mem[_ML * 1024 * 1024];\nsize_t _ptr = 0;\ninline void* operator new (size_t _x) { _ptr += _x; assert(_ptr < _ML * 1024 * 1024); return _mem + _ptr - _x; }\ninline void operator delete (void*) { }\n#endif\ntemplate<class T, class U> inline ostream &operator<< (ostream &, const pair<T, U> &);\ntemplate<class T, class U> inline istream &operator>> (istream &, pair<T, U> &);\ntemplate<class T> inline ostream &operator<< (ostream &, const vector<T> &);\ntemplate<class T> inline istream &operator>> (istream &, vector<T> &);\ntemplate<class T> inline ostream &operator<< (ostream &, const set<T> &);\ntemplate<class T> inline ostream &operator<< (ostream &, const multiset<T> &);\ntemplate<class T> inline ostream &operator<< (ostream &, const unordered_set<T> &);\ntemplate<class T> inline ostream &operator<< (ostream &, const unordered_multiset<T> &);\ntemplate<class T, class U> inline ostream &operator<< (ostream &, const map<T, U> &);\ntemplate<class T, class U> inline ostream &operator<< (ostream &, const unordered_map<T, U> &);\n\n/* ________ CODE ________ */\nconst int X = 229;\n\nstruct hasher {\n    vector<int> pw;\n    int M;\n    int val;\n\n    int add(int a, int b) {\n        return (a + b) % M;\n    }\n\n    int sub(int a, int b) {\n        return (a - b + M) % M;\n    }\n\n    int mul(int a, int b) {\n        return (int)(((ll)a * b) % M + M) % M;\n    }\n\n    int bp(int a, int b) {\n        int r = 1;\n        while(b) {\n            if(b & 1) {\n                r = mul(r, a);\n            }\n            a = mul(a, a);\n            b >>= 1;\n        }\n        return r;\n    }\n\n    int div(int a, int b) {\n        return mul(a, bp(b, M - 2));\n    }\n\n    hasher(int p, int m, int n) : M(m), val(0) {\n        pw.resize(n);\n        pw[0] = 1;\n        for(int i = 1; i < n; ++i) {\n            pw[i] = mul(pw[i - 1], p);\n        }\n    }\n\n    void ins(int p, int x) {\n        val = add(val, mul(pw[p], x));\n    }\n\n    void ers(int p, int x) {\n        val = sub(val, mul(pw[p], x));\n    }\n};\n\ninline void _main_function()\n{\n    int n;\n    cin >> n;\n\n    string s;\n    cin >> s;\n\n    vector<int> a(2 * n + 1);\n    int p = n;\n\n    hasher h(1000 * 1000 + 3, 1000 * 1000 * 1000 + 7, sz(a));\n    hasher g(1000 * 1000 + 33, 1000 * 1000 * 1000 + 9, sz(a));\n\n    vector<int> ah = {0}, ag = {0};\n\n    for(int i = 0; i < n; ++i) {\n        if(s[i] == '<') {\n            --p;\n        } else if(s[i] == '>') {\n            ++p;\n        } else {\n            h.ers(p, a[p]);\n            g.ers(p, a[p]);\n            if(s[i] == '+') {\n                ++a[p];\n            } else if(s[i] == '-') {\n                --a[p];\n            } else {\n                assert(false);\n            }\n            h.ins(p, a[p]);\n            g.ins(p, a[p]);\n        }\n\n        ah.push_back(h.val);\n        ag.push_back(g.val);\n    }\n\n    ll sum = 0;\n    map<pair<int, int>, int> cnt;\n    int sh = 0;\n\n    for(int i = 0; i <= n; ++i) {\n        sum += cnt[{ah[i], ag[i]}];\n\n        if(i && s[i - 1] == '>') {\n            ++sh;\n        } else if(i && s[i - 1] == '<') {\n            --sh;\n        }\n\n        if(sh >= 0) {\n            int x = h.add(h.mul(ah.back(), h.pw[sh]), ah[i]);\n            int y = g.add(g.mul(ag.back(), g.pw[sh]), ag[i]);\n            ++cnt[{x, y}];\n        } else {\n            int x = h.add(h.div(ah.back(), h.pw[-sh]), ah[i]);\n            int y = g.add(g.div(ag.back(), g.pw[-sh]), ag[i]);\n            ++cnt[{x, y}];\n        }\n    }\n\n    cout << sum << endl;\n}\n\n/* ________ CODE ________ */\n\nint main()\n{\n#if defined(ANDREIKKAA)\n    time_t _start = clock();\n#endif\n    if (_inpf[0] != '\\0') assert(freopen(_inpf, \"r\", stdin) != nullptr);\n    if (_outf[0] != '\\0') assert(freopen(_outf, \"w\", stdout) != nullptr);\n    cin.tie(nullptr);\n    ios_base::sync_with_stdio(false);\n\n    cout << setprecision(20);\n    //cout << fixed;\n\n    _main_function();\n#if defined(ANDREIKKAA)\n    cout << \"Time: \" << (clock() - _start) / (ld)CLOCKS_PER_SEC << endl;\n#endif\n}\n\ntemplate<class T, class U> inline ostream &operator<< (ostream &_out, const pair<T, U> &_p)\n{\n    _out << _p.x << ' ' << _p.y;\n    return _out;\n}\ntemplate<class T, class U> inline istream &operator>> (istream &_in, pair<T, U> &_p)\n{\n    _in >> _p.x >> _p.y;\n    return _in;\n}\ntemplate<class T> inline ostream &operator<< (ostream &_out, const vector<T> &_v)\n{\n    if (_v.empty()) { return _out; }\n    _out << *_v.begin();\n    for (auto _it = ++_v.begin(); _it != _v.end(); ++_it) { _out << ' ' << *_it; }\n    return _out;\n}\ntemplate<class T> inline istream &operator>> (istream &_in, vector<T> &_v)\n{\n    for (auto &_i : _v) { _in >> _i; }\n    return _in;\n}\ntemplate<class T> inline ostream &operator<< (ostream &_out, const set<T> &_s)\n{\n    if (_s.empty()) { return _out; }\n    _out << *_s.begin();\n    for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; }\n    return _out;\n}\ntemplate<class T> inline ostream &operator<< (ostream &_out, const multiset<T> &_s)\n{\n    if (_s.empty()) { return _out; }\n    _out << *_s.begin();\n    for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; }\n    return _out;\n}\ntemplate<class T> inline ostream &operator<< (ostream &_out, const unordered_set<T> &_s)\n{\n    if (_s.empty()) { return _out; }\n    _out << *_s.begin();\n    for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; }\n    return _out;\n}\ntemplate<class T> inline ostream &operator<< (ostream &_out, const unordered_multiset<T> &_s)\n{\n    if (_s.empty()) { return _out; }\n    _out << *_s.begin();\n    for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; }\n    return _out;\n}\ntemplate<class T, class U> inline ostream &operator<< (ostream &_out, const map<T, U> &_m)\n{\n    if (_m.empty()) { return _out; }\n    _out << '(' << _m.begin()->x << \": \" << _m.begin()->y << ')';\n    for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) { _out << \", (\" << _it->x << \": \" << _it->y << ')'; }\n    return _out;\n}\ntemplate<class T, class U> inline ostream &operator<< (ostream &_out, const unordered_map<T, U> &_m)\n{\n    if (_m.empty()) { return _out; }\n    _out << '(' << _m.begin()->x << \": \" << _m.begin()->y << ')';\n    for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) { _out << \", (\" << _it->x << \": \" << _it->y << ')'; }\n    return _out;\n}\n"
  },
  {
    "language": "C++",
    "code": "// バチャで貼る悪魔的行為\n#include <bits/stdc++.h>\nusing ll = long long;\nconstexpr ll pow(const ll a, const ll b, const ll mod) { return b == 0 ? 1LL : b % 2 == 1 ? pow(a, b - 1, mod) * a % mod : pow(a * a % mod, b / 2, mod); }\nconstexpr ll inverse(const ll a, const ll mod) { return pow(a, mod - 2, mod); }\nconstexpr ll MOD0 = 1000000007LL, MOD1 = 1000000009LL, MOD2 = 1000000021;\nconstexpr ll X = 121234243;\nconstexpr ll XINV0 = inverse(X, MOD0), XINV1 = inverse(X, MOD1), XINV2 = inverse(X, MOD2);\nconstexpr int L = 250000;\nusing P = std::tuple<ll, ll, ll>;\nP power[L + 1] = {P{1, 1, 1}}, invpower[L + 1] = {P{1, 1, 1}};\nauto plus = [](const P& p1, const P& p2) { return P{(std::get<0>(p1) + std::get<0>(p2)) % MOD0, (std::get<1>(p1) + std::get<1>(p2)) % MOD1, (std::get<2>(p1) + std::get<2>(p2)) % MOD2}; };\nauto minus = [](const P& p1, const P& p2) { return P{(std::get<0>(p1) + MOD0 - std::get<0>(p2)) % MOD0, (std::get<1>(p1) + MOD1 - std::get<1>(p2)) % MOD1, (std::get<2>(p1) + MOD2 - std::get<2>(p2)) % MOD2}; };\nauto rshift = [](const P& p) { return P{std::get<0>(p) * X % MOD0, std::get<1>(p) * X % MOD1, std::get<2>(p) * X % MOD2}; };\nauto lshift = [](const P& p) { return P{std::get<0>(p) * XINV0 % MOD0, std::get<1>(p) * XINV1 % MOD1, std::get<2>(p) * XINV2 % MOD2}; };\nauto mul = [](const P& p1, const P& p2) { return P{std::get<0>(p1) * std::get<0>(p2) % MOD0, std::get<1>(p1) * std::get<1>(p2) % MOD1, std::get<2>(p1) * std::get<2>(p2) % MOD2}; };\nint main()\n{\n    for (int i = 1; i <= L; i++) { power[i] = rshift(power[i - 1]), invpower[i] = lshift(invpower[i - 1]); }\n    auto invp = [](const int i) { return i >= 0 ? invpower[i] : power[-i]; };\n    int N;\n    std::string S;\n    std::cin >> N >> S;\n    std::vector<int> deg(N + 1, 0);\n    std::vector<P> value(N + 1, P{0, 0, 0});\n    for (int i = N - 1; i >= 0; i--) {\n        if (S[i] == '-') {\n            deg[i] = deg[i + 1], value[i] = minus(value[i + 1], P{1, 1, 1});\n        } else if (S[i] == '+') {\n            deg[i] = deg[i + 1], value[i] = plus(value[i + 1], P{1, 1, 1});\n        } else if (S[i] == '>') {\n            deg[i] = deg[i + 1] + 1, value[i] = rshift(value[i + 1]);\n        } else {\n            deg[i] = deg[i + 1] - 1, value[i] = lshift(value[i + 1]);\n        }\n    }\n    const P answer = value[0];\n    for (int i = 0; i <= N; i++) { value[i] = mul(minus(value[i], answer), invp(deg[i])); }\n    std::map<P, ll> mp;\n    ll ans = 0;\n    for (int i = 0; i <= N; i++) {\n        const P obj = plus(value[i], mul(invp(deg[i]), answer));\n        if (mp.find(obj) != mp.end()) { ans += mp[obj]; }\n        mp[value[i]]++;\n    }\n    std::cout << ans << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int Mod1 = 1e9 + 7, Mod2 = 1e9 + 9, Nmax = 5e5 + 5, Pow = 666013;\ntypedef long long ll;\n\nint sP[Nmax], i, n, P;\nll ans = 0;\nmap< pair<int,int> , int> mp;\nchar a[Nmax];\n\nll power(ll a, int b, int Mod)\n{\n    ll ans = 1;\n    while(b)\n    {\n        if(b&1) ans = ans * a % Mod;\n        b >>= 1; a = a*a%Mod;\n    }\n    return ans;\n}\n\nstruct number\n{\n    int x, y;\n};\n\nnumber Pw[Nmax], E[Nmax], R[Nmax], Inv, InvP[Nmax], target;\n\nnumber operator - (number a, number b)\n{\n    a.x -= b.x;\n    a.y -= b.y;\n    if(a.x<0) a.x += Mod1;\n    if(a.y<0) a.y += Mod2;\n    return a;\n}\n\nnumber operator + (number a, number b)\n{\n    a.x += b.x;\n    a.y += b.y;\n    if(a.x>=Mod1) a.x -= Mod1;\n    if(a.y>=Mod2) a.y -= Mod2;\n    return a;\n}\n\nnumber operator * (number a, number b)\n{\n    return {(ll)a.x*b.x%Mod1, (ll)a.y*b.y%Mod2};\n}\n\nnumber operator * (number a, int b)\n{\n    return {(ll)a.x*b%Mod1, (ll)a.y*b%Mod2};\n}\n\nint main()\n{\n //   freopen(\"input\", \"r\", stdin);\n //   freopen(\"output\", \"w\", stdout);\n    cin.sync_with_stdio(false);\n\n    cin >> n >> (a+1);\n\n    for(i=1; i<=n; ++i) sP[i] = sP[i-1] - (a[i] == '<') + (a[i] == '>');\n\n    Inv.x = power(Pow, Mod1-2, Mod1);\n    Inv.y = power(Pow, Mod2-2, Mod2);\n\n    Pw[0] = {1,1}; InvP[0] = {1,1};\n    for(i=1; i<=2*n; ++i) Pw[i] = Pw[i-1] * Pow, InvP[i] = InvP[i-1] * Inv;\n\n    P = n;\n    for(i=1; i<=n; ++i) /// for 1..,i\n    {\n        E[i] = E[i-1];\n        if(a[i] == '<')\n        {\n            --P;\n            continue;\n        }\n\n        if(a[i] == '>')\n        {\n            ++P;\n            continue;\n        }\n\n        if(a[i] == '-')\n            E[i] = E[i] - Pw[P];\n        else E[i] = E[i] + Pw[P];\n    }\n\n    for(i=1; i<=n; ++i) /// reverse operations for 1...i, not signs\n    {\n        if(a[i] == '<')\n        {\n            R[i] = R[i-1] * Pow;\n            continue;\n        }\n\n        if(a[i] == '>')\n        {\n            R[i] = Inv * R[i-1];\n            continue;\n        }\n\n        if(a[i] == '+') R[i] = R[i-1] + Pw[n];\n            else R[i] = R[i-1] - Pw[n];\n    }\n\n    for(i=n; i; --i)\n    {\n        ++mp[{ E[i].x, E[i].y }]; /// i becomes active\n\n        target = E[n] + R[i-1];\n        if(sP[i-1] >= 0) target = target * Pw[sP[i-1]];\n            else target = target * InvP[-sP[i-1]];\n\n        ans += mp[{ target.x, target.y }];\n    }\n\n    cout << ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2e5 + 5;\n//const int mod = 1e9 + 7;\ntypedef long long ll;\n#define mp make_pair\n\nchar c;\nstring s;\nint n,i,ans;\nmap < pair < int , int > , int > M;\n\n\nstruct hashh{\n    ll t,a,b,x,bol,X,mod;\n    hashh() { t=b=x=X=mod=0; a=bol=1; }\n    void f(){ \n        for(t=X,i=mod-2; i ; i>>=1){\n            if(i & 1) bol = bol*t % mod;\n            t = t*t % mod;\n        }\n        for(i=n-1; i>=0 ;i--){\n            c = s[i];\n            if(c == '-') x--;\n            if(c == '+') x++;\n            if(c == '>') x *= X;\n            if(c == '<') x *= bol;\n            x = (x % mod + mod) % mod;\n        }\n    }       \n                \n    void g(){               \n        if(c == '+') b -= a;                \n        if(c == '-') b += a;                            \n        if(c == '>') a *= bol;                                  \n        if(c == '<') a *= X;        \n        a = (a % mod + mod) % mod;                  \n        b = (b % mod + mod) % mod;                              \n        t = (a*x + b) % mod;                                                \n    }                                                                                   \n};                                                                                                  \n                                                                                                                \nint main(){                                                                                                             \n    cin >> n >> s;                      \n                                                                                                                            \n    hashh h1,h2;    \n    h1.mod = 1e9+7;  h1.X=10000003; h1.f();\n    h2.mod = 1e9+9;  h2.X=1000007; h2.f();\n                                                \n    M[mp(0,0)] = 1;                                     \n    for(i=n-1; i>=0 ;i--){                                      \n        c = s[i];                                                       \n        h1.g(); h2.g();                                                         \n                                                                                    \n        ans += M[mp(h1.t,h2.t)];                                                    \n        M[mp(h1.b,h2.b)]++;                                                             \n    }\n        \n    cout << ans;\n    return 0;\n}    "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\n#include<cassert>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 1000000007;\nconst ll MAX = 4000001;\nconst long double eps = 1E-14;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n\tlong long x;\npublic:\n\tmint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n\tmint operator-() const {\n\t\treturn mint(-x);\n\t}\n\tmint& operator+=(const mint& a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint& a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const  mint& a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint& a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\n\nmint pw(mint a, ll b) {\n\tif (b == 0) { return 1; }\n\tmint ret = pw(a, b >> 1);\n\tret *= ret;\n\tif (b & 1) { ret *= a; }\n\treturn ret;\n}\n\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<vector<vector<ll>>> vvvll;\n\ntypedef vector<mint> vmint;\ntypedef vector<vector<mint>> vvmint;\ntypedef vector<vector<vector<mint>>> vvvmint;\n\n/////////////////////////////////////\n\nvll mod = { 1000000007,998244353 };\n\nll pr = 20003;\n\nll iv(ll i,ll mod) {\n\tif (i == 1) { return 1; }\n\treturn mod - iv(mod % i,mod) * (mod / i) % mod;\n}\n\nll pw(ll a, ll mod) {\n\tif (a < 0) { return iv(pw(-a, mod), mod); }\n\n\tif (a == 0) { return 1; }\n\tll c = pw(a/2, mod);\n\tc = c * c % mod;\n\tif (a % 2 == 1) { c = c * pr % mod; }\n\treturn c;\n}\n\nint main() {\n\tll N;\n\tcin >> N;\n\tstring S;\n\tcin >> S;\n\n\tmap<pair<ll,ll>,set<ll>> mp;\n\n\tll P = 0;\n\n\tvll now(2, 0);\n\tmp[{0, 0}].insert(0);\n\n\tvector<pair<ll, ll>> val(N + 1, { 0,0 });\n\tvll cur(N + 1, P);\n\n\trepn(i, N) {\n\t\tif (S[i - 1] == '+') {\n\t\t\trep(j, 2) {\n\t\t\t\tnow[j] += pw(P, mod[j]);\n\t\t\t\tnow[j] %= mod[j];\n\t\t\t}\n\t\t}\n\t\telse if (S[i - 1] == '-') {\n\t\t\trep(j, 2) {\n\t\t\t\tnow[j] -= pw(P, mod[j]);\n\t\t\t\tnow[j] = ((now[j] % mod[j]) + mod[j]) % mod[j];\n\t\t\t}\n\t\t}\n\t\telse if (S[i - 1] == '>') { P++; }\n\t\telse { P--; }\n\n\t\t//cout << i << \" \" << now[0] << \" \" << now[1] << endl;\n\n\t\tmp[{now[0], now[1]}].insert(i);\n\n\t\tval[i] = { now[0],now[1] };\n\t\tcur[i] = P;\n\t}\n\n\tll ans = 0;\n\n\trep(i, N) {\n\t\tmp[val[i]].erase(i);\n\n\t\tll X = (val[i].first + val[N].first * pw(cur[i], mod[0])) % mod[0];\n\t\tll Y = (val[i].second + val[N].second * pw(cur[i], mod[1])) % mod[1];\n\t\t//cout << X << \" \" << Y << endl;\n\t\tans += mp[{X, Y}].size();\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author aajisaka\n */\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n#define SPEED ios_base::sync_with_stdio(false);cin.tie(nullptr)\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define all(v) v.begin(), v.end()\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing P = pair<ll, ll>;\n\nconstexpr long double PI = 3.14159265358979323846264338327950288L;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nconstexpr ll mod17 = 1e9+7;\nconstexpr ll mod19 = 1e9+9;\nconstexpr ll mod9 = 998244353;\nll mod = mod17;\n\n// Mod int libraries\ntemplate<typename T>\nT mod_pow(T a, ll x) {\n  T res = 1;\n  while(x > 0) {\n    if (x & 1) res *= a;\n    a *= a; x >>= 1;\n  }\n  return res;\n}\n\n// Mint32\nunordered_map<ll, ll> minvmap;\nll minv(ll a, ll m) {\n  auto k = a; auto p = minvmap[a]; if (p != 0) return p;\n  ll b = m, u = 1, v = 0;\n  while (b) { ll t = a/b; swap(a -= t*b, b); swap(u -= t*v, v); }\n  p = (u%m+m)%m; minvmap[k] = p; return p;\n}\n\nstruct mint {\n  ll x;\n  mint():x(0){}\n  mint(ll x):x((x%mod+mod)%mod){}\n  mint& fix() { x = (x%mod+mod)%mod; return *this;}\n  mint operator-() const { return mint(0) - *this;}\n  mint& operator+=(const mint& a){ if((x+=a.x)>=mod) x-=mod; return *this;}\n  mint& operator-=(const mint& a){ if((x+=mod-a.x)>=mod) x-=mod; return *this;}\n  mint& operator*=(const mint& a){ (x*=a.x)%=mod; return *this;}\n  mint& operator/=(const mint& a){ (x*=minv(a.x, mod))%=mod; return *this; }\n  mint operator+(const mint& a)const{ return mint(*this) += a;}\n  mint operator-(const mint& a)const{ return mint(*this) -= a;}\n  mint operator*(const mint& a)const{ return mint(*this) *= a;}\n  mint operator/(const mint& a)const{ return mint(*this) /= a;}\n  bool operator<(const mint& a)const{ return x < a.x;}\n  bool operator==(const mint& a)const{ return x == a.x;}\n};\n\n// Mint64\nstruct mint64 {\n    ull x;\n    static ull mod, inv, r2;\n    mint64(): x(0){}\n    mint64(ull x): x(init(x)) {}\n    static ull init(ull x) { return reduce(__uint128_t(x)*r2);}\n    static void set_mod(ull m) {\n      mod = inv = m;\n      for(int i=0; i<5; i++) inv *= 2 - inv*m;\n      r2 = -__uint128_t(m)%m;\n    }\n    static ull reduce(__uint128_t x) {\n      ull y = ull(x >> 64) - ull((__uint128_t(ull(x)*inv)*mod)>>64);\n      return ll(y) < 0 ? y+mod : y;\n    }\n    mint64& operator+=(mint64& a) { x+=a.x-mod; if(ll(x)<0) x+=mod; return *this; }\n    mint64 operator+(mint64& a) const{ return mint64(*this)+=a; }\n    mint64& operator*=(mint64& a) { x=reduce(__uint128_t(x)*a.x); return *this; }\n    mint64 operator*(mint64& a) const { return mint64(*this)*=a; }\n};\n\null mint64::mod, mint64::inv, mint64::r2;\n\n// Verify: https://yukicoder.me/submissions/472580\nstruct Miller {\n    const vector<ull> v = {2, 325, 9375, 28178, 450775, 9780504, 1795265022};\n    bool suspect(ull a, ull s, ull d, ull n) {\n      if (mint64::mod != n) mint64::set_mod(n);\n      mint64 one = 1, minusone = n-1, ma = a;\n      auto x = mod_pow(ma, d);\n      if (x.x == one.x) return true;\n      for(int r = 0; r < s; r++) {\n        if (x.x == minusone.x) return true;\n        x = x * x;\n      }\n      return false;\n    }\n\n    // check if n is prime\n    bool check(ull n) {\n      if (n < 2 || (n > 2 && n % 2 == 0)) return false;\n      ull d = n - 1;\n      ull s = 0;\n      while (!(d & 1)) {\n        d >>= 1;\n        s++;\n      }\n      for (auto a: v) {\n        if (a >= n) break;\n        if (!suspect(a, s, d, n)) return false;\n      }\n      return true;\n    }\n};\n\nclass combination {\n    // factorial\n    public: std::vector<mint> fact;\n    public: std::vector<mint> inv;\n\n    combination(int n) {\n      fact.resize(n + 1);\n      inv.resize(n + 1);\n      fact[0] = 1;\n      for (int i = 1; i <= n; i++) {\n        fact[i] = fact[i - 1] * i;\n      }\n      inv[n] = mint(1) / fact[n];\n      for (int i = n - 1; i >= 0; i--) {\n        inv[i] = inv[i + 1] * (i + 1);\n      }\n    }\n\n    // nCr\n    public: mint get(int n, int r) {\n      if (n < r || n < 0 || r < 0) return 0;\n      return fact[n]*inv[r]*inv[n-r];\n    }\n    // nPr\n    public: mint p(int n, int r) {\n      if (n < r || n < 0) return 0;\n      return fact[n]*inv[n-r];\n    }\n};\n\n\nclass FEatingSymbolsHard {\npublic:\n    void solve(istream& cin, ostream& cout) {\n      SPEED;\n      int n; cin >> n;\n      string s; cin >> s;\n      vector<mint> base = {11, 13, 17, 1007, 1009, 10007};\n      vector<mint> invBase(6);\n      rep(i, 6) {\n        invBase[i] = mint(1)/base[i];\n      }\n      vector<int> pos(n+1);\n      vector<vector<mint>> vec(6, vector<mint>(n+1));\n\n      rep(i, n) {\n        pos[i+1] = pos[i];\n        rep(k, 6) {\n          vec[k][i+1] = vec[k][i];\n        }\n        if (s[i] == '+') {\n          rep(k, 6) {\n            if (pos[i] < 0) {\n              vec[k][i+1] += mod_pow(invBase[k], -pos[i]);\n            } else {\n              vec[k][i+1] += mod_pow(base[k], pos[i]);\n            }\n          }\n        } else if (s[i] == '-') {\n          rep(k, 6) {\n            if (pos[i] < 0) {\n              vec[k][i+1] -= mod_pow(invBase[k], -pos[i]);\n            } else {\n              vec[k][i+1] -= mod_pow(base[k], pos[i]);\n            }\n          }\n        } else if (s[i] == '<') {\n          pos[i+1]--;\n        } else {\n          pos[i+1]++;\n        }\n      }\n\n      map<mint, ll> mp[6];\n      ll ans = 0;\n      for(int i=n; i>=0; i--) {\n        map<int, int> cnt;\n        rep(k, 6) {\n          mint r;\n          if (pos[i] < 0) {\n            r = mod_pow(invBase[k], -pos[i]);\n          } else {\n            r = mod_pow(base[k], pos[i]);\n          }\n          auto q = vec[k][i] + vec[k][n] * r;\n          if (mp[k].find(q) == mp[k].end()) {\n            cnt[0]++;\n          } else {\n            cnt[mp[k][q]]++;\n          }\n        }\n        for(auto e: cnt) {\n          if (e.second >= 4) {\n            ans += e.first;\n          }\n        }\n        rep(k, 6) {\n          mp[k][vec[k][i]]++;\n        }\n      }\n\n      cout << ans << endl;\n\n    }\n};\n\nsigned main() {\n  FEatingSymbolsHard solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cmath>\n#include<cstdlib>\n#include<set>\n#define LL long long\n#define LD long double\nusing namespace std;\nconst int NN=250000 +117;\nconst int MM= +117;\n#define mod1 998244353\n#define mod2 1004535809\nint read(){\n\tint fl=1,x;char c;\n\tfor(c=getchar();(c<'0'||c>'9')&&c!='-';c=getchar());\n\tif(c=='-'){fl=-1;c=getchar();}\n\tfor(x=0;c>='0'&&c<='9';c=getchar())\n\t\tx=(x<<3)+(x<<1)+c-'0';\n\treturn x*fl;\n}\nvoid open(){\n\tfreopen(\"99f.in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n}\nvoid close(){\n\tfclose(stdin);\n\tfclose(stdout);\n}\n\n\nint m,n;\nmultiset<LL> a;\nchar s[NN]={};\nLL ksm(LL a,LL b){\n\tLL ret=1;\n\twhile(b){\n\t\tif(b&1){\n\t\t\tret*=a;\n\t\t\tret%=mod1;\n\t\t}\n\t\ta*=a;\n\t\ta%=mod1;\n\t\tb>>=1;\n\t}\n\treturn ret;\n}\nint main(){\n\t//open();\n\tn=read();\n\tscanf(\"%s\",s);\n\tLL res=0;\n\tLL rev=ksm(mod2,mod1-2);\n\tLL p=1;\n\tfor(int i=0;i<n;++i){\n\t\tif(s[i]=='+'){\n\t\t\tres+=p;\n\t\t\tres%=mod1;\n\t\t}\n\t\tif(s[i]=='-'){\n\t\t\tres-=p;\n\t\t\tres%=mod1;\n\t\t}\n\t\tif(s[i]=='<'){\n\t\t\tp*=rev;\n\t\t\tp%=mod1;\n\t\t}\n\t\tif(s[i]=='>'){\n\t\t\tp*=mod2;\n\t\t\tp%=mod1;\n\t\t}\n\t}\n\tp=1;\n\tLL tp=0;\n\tLL ans=0;\n\tfor(int i=0;i<n;++i){\n\t\ta.insert((tp+p*res)%mod1);\n\t\tif(s[i]=='+'){\n\t\t\ttp+=p;\n\t\t\ttp%=mod1;\n\t\t}\n\t\tif(s[i]=='-'){\n\t\t\ttp-=p;\n\t\t\ttp%=mod1;\n\t\t}\n\t\tif(s[i]=='<'){\n\t\t\tp*=rev;\n\t\t\tp%=mod1;\n\t\t}\n\t\tif(s[i]=='>'){\n\t\t\tp*=mod2;\n\t\t\tp%=mod1;\n\t\t}\n\t\tans+=a.count(tp);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\tclose();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define R return\n#define rep(i,s,t) for(int i=s;i<=(t);++i)\n#define dec(i,s,t) for(int i=s;i>=(t);--i)\nusing namespace std;\nconst int N=2e5+50,P=1e9+7,X=7,I=142857144;\nint mul(int a,int b){ R 1ll*a*b%P; }\nint add(int a,int b){ a+=b; R a>=P?a-P:a; }\nint sub(int a,int b){ a-=b; R a<0?a+P:a; }\nchar s[N]; long long ans; int n,A[N],B[N],u;\nint f(char c,int x){\n\tif(c=='+')R add(x,1); \n\tif(c=='-')R sub(x,1); \n\tif(c=='<')R mul(x,I);\n\tif(c=='>')R mul(x,X); \n\texit(-1);\n}\nvoid g(char c,int &a,int &b){\n\tif(c=='+')b=sub(b,a);\n\tif(c=='-')b=add(b,a);\n\tif(c=='<')a=mul(a,X);\n\tif(c=='>')a=mul(a,I); \n}\nint F(int a,int b,int x){ R add(mul(a,x),b); }\nmap<int,int> M;\nint main(){\n\tscanf(\"%d%s\",&n,s+1); \n\tdec(i,n,1)u=f(s[i],u); \n\tA[n+1]=1,B[n+1]=0; dec(i,n,1)g(s[i],A[i]=A[i+1],B[i]=B[i+1]); \n\t++M[F(A[n+1],B[n+1],0)]; dec(i,n,1)ans+=M[F(A[i],B[i],u)],++M[F(A[i],B[i],0)];\n\tprintf(\"%lld\\n\",ans);\n\tR 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T1, typename T2>bool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>bool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>void ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>void debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++){cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++){for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>void debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];for(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>vector<vector<T>>vec(ll x, ll y, T w){vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,-1,0,0,1,1,-1,-1};vector<ll>dy={0,0,1,-1,1,-1,1,-1};\ntemplate<typename T>vector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>auto make_v(size_t a,Ts... ts){return vector<decltype(make_v(ts...))>(a,make_v(ts...));}\ntemplate<typename T1, typename T2>ostream &operator<<(ostream &os, const pair<T1, T2>&p){return os << p.first << \" \" << p.second;}\ntemplate<typename T>ostream &operator<<(ostream &os, const vector<T> &v){for(auto &z:v)os << z << \" \";cout<<\"|\"; return os;}\n//mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\ntemplate< int mod >\nstruct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while(n > 0) {\n      if(n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  friend ostream &operator<<(ostream &os, const ModInt &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n\n  static int get_mod() { return mod; }\n};\nusing modint = ModInt< MOD1 >;modint pow(ll n, ll x){return modint(n).pow(x);}modint pow(modint n, ll x){return n.pow(x);}\n//using modint=ld;\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  using m1=ModInt<MOD1>;\n  using m2=ModInt<MOD9>;\n  ll n;cin>>n;\n  string s;cin>>s;\n  m1 mul1=979418779;\n  m2 mul2=979418779;\n  m1 div1=m1(1)/mul1;\n  m2 div2=m2(1)/mul2;\n  vector<m1>a1(n+1,1),b1(n+1);\n  vector<m2>a2(n+1,1),b2(n+1);\n  rep(i,0,n){\n    a1[i+1]=a1[i],b1[i+1]=b1[i];;\n    a2[i+1]=a2[i],b2[i+1]=b2[i];;\n    if(s[i]=='>'){\n      a1[i+1]*=mul1;\n      a2[i+1]*=mul2;\n    }\n    if(s[i]=='<'){\n      a1[i+1]*=div1;\n      a2[i+1]*=div2;\n    }\n    if(s[i]=='+'){\n      b1[i+1]+=a1[i];\n      b2[i+1]+=a2[i];\n    }\n    if(s[i]=='-'){\n      b1[i+1]-=a1[i];\n      b2[i+1]-=a2[i];\n    }\n  }\n  map<P,ll>mp;\n  m1 all1=b1[n];\n  m2 all2=b2[n];\n  rrep(i,0,n+1){\n    //all=(b[to]-b[i])/a[i]\n    auto to1=all1*a1[i]+b1[i];\n    auto to2=all2*a2[i]+b2[i];\n    res+=mp[MP(to1.x,to2.x)];\n    mp[MP(b1[i].x,b2[i].x)]++;\n  }\n  cout<<res<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "    #include <iostream>\n    #include<bits/stdc++.h>\n    using namespace std;\n     \n    #define MAX 250002\n    int n;\n     \n    char buf[MAX];\n     \n    __int128 mod1=1000000000000000003ll;\n    __int128 mod2=1000000000000000031LL;\n     \n    inline __int128 mul(__int128 a,__int128 b){\n    \treturn (a*b)%mod2;\n    }\n    inline __int128 add(__int128 a,__int128 b){\n    \tauto f=a+b;\n    \tif(f>=mod2)f%=mod2;\n    \treturn f;\n    }\n    inline __int128 sub(__int128 a,__int128 b){\n    \tauto f=a-b;\n    \tif(f<0)f+=mod2;\n    \tf%=mod2;\n    \treturn f;\n    }\n    __int128 ppow(__int128 a,__int128 b){\n    \t__int128 res=1;\n    \twhile(b){\n    \t\tif(b&1LL)res*=a;\n    \t\tif(res>=mod2)res%=mod2;\n    \t\tb>>=1LL;\n    \t}\n    \treturn res;\n    }\n    unordered_map<long long int,int> cnt;\n    vector<pair<__int128,__int128> > v;\n    int main() {\n    \tcin>>n;\n    \tscanf(\"%s\",buf);\n    \tauto inv=821428571428571454ll;\n    \t//printf(\"%lld\\n\",inv);\n    \t__int128 cur=1;\n    \t__int128 hs=0;\n    \tint sz=strlen(buf);\n    \tv.push_back(make_pair(0,1));\n    \tfor(int i=0;i<sz;i++){\n    \t\tif(buf[i]=='<'){\n    \t\t\tcur=mul(cur,inv);\n    \t\t}\n    \t\tif(buf[i]=='>'){\n    \t\t\tcur=mul(cur,mod1);\n    \t\t}\n    \t\tif(buf[i]=='+'){\n    \t\t\ths=add(hs,cur);\n    \t\t}\n    \t\tif(buf[i]=='-'){\n    \t\t\ths=sub(hs,cur);\n    \t\t}\n    \t\tv.push_back(make_pair(hs,cur));\n    \t}\n    \t__int128 acieve=v.back().first;\n    \t//(x-c)/second=acieve\n    \t//x-c=acieve/second\n    \t//x = c+ acieve/second\n    \tlong long int way=0;\n    \tfor(int i=v.size()-1;i>=0;i--){\n    \t\t__int128 want=add(v[i].first,mul(acieve,v[i].second));\n    \t\tway+=cnt[want];\n    \t\tcnt[v[i].first]++;\n    \t\t//cerr<<i<<\" \"<<way<<endl;\n    \t}\n    \tprintf(\"%lld\\n\",way);\n    \treturn 0;\n    }\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\n//const ll mod = 1000000087;\n//const ll INF = mod * mod;\ntypedef pair<int, int>P;\ntypedef pair<int, bool> sP;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef pair<ll, ll> LP;\ntypedef vector<ll> vec;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef vector<vector<ll>> mat;\ntypedef vector<ll> vec;\n\n\n\nvector<ll> mods;\nvector<ll> roots;\n\nbool isp(ll x) {\n\tRep1(i,2, 100000) {\n\t\tif (x%i == 0)return false;\n\t}\n\treturn true;\n}\nvoid genmods() {\n\tll sta = 1000010000;\n\twhile (mods.size() < 5) {\n\t\tif (isp(sta))mods.push_back(sta);\n\t\tsta++;\n\t}\n}\nvoid genroots() {\n\tll sta = 2000010000;\n\twhile (roots.size() < 5) {\n\t\tif (isp(sta))roots.push_back(sta);\n\t\tsta++;\n\t}\n}\nll mod_pow(ll x, ll n,ll mod) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n % 2)res = res * x%mod;\n\t\tx = x * x%mod; n >>= 1;\n\t}\n\treturn res;\n}\nvector<ll> invroots;\n\nvector<ll> tr[300000];\nvector<ll> invtr[300000];\nvoid init() {\n\tgenmods();\n\tgenroots();\n\trep(i, 300000) {\n\t\ttr[i].resize(mods.size()*roots.size());\n\t\tinvtr[i].resize(mods.size()*roots.size());\n\t}\n\trep(j, tr[0].size()) {\n\t\ttr[0][j] = invtr[0][j] = 1;\n\t}\n\trep(j, mods.size()) {\n\t\trep(k, roots.size()) {\n\t\t\tinvroots.push_back(mod_pow(roots[k], mods[j] - 2, mods[j]));\n\t\t}\n\t}\n\trep(i, 299999) {\n\t\trep(j, mods.size()) {\n\t\t\trep(k, roots.size()) {\n\t\t\t\tint id = j * roots.size() + k;\n\t\t\t\ttr[i + 1][id] = tr[i][id] * roots[k] % mods[j];\n\t\t\t\tinvtr[i + 1][id] = invtr[i][id] * invroots[id] % mods[j];\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve() {\n\tint n; cin >> n;\n\tstring s; cin >> s;\n\tvector<ll> sum(mods.size()*roots.size(),0); int loc = 0;\n\tvector<vector<ll>> memo(n);\n\trep(i, n)memo[i].resize(mods.size()*roots.size());\n\tvector<int> locs(n);\n\tint len = roots.size()*mods.size();\n\trep(i, n) {\n\t\tif (s[i] == '>')loc++;\n\t\telse if (s[i] == '<')loc--;\n\t\telse if (s[i] == '+') {\n\t\t\tif (loc >= 0) {\n\t\t\t\trep(j, len) {\n\t\t\t\t\tsum[j] += tr[loc][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\trep(j, len) {\n\t\t\t\t\tsum[j] += invtr[-loc][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (loc >= 0) {\n\t\t\t\trep(j, len) {\n\t\t\t\t\tsum[j] -= tr[loc][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\trep(j, len) {\n\t\t\t\t\tsum[j] -= invtr[-loc][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(j, len) {\n\t\t\tll mod = mods[j / roots.size()];\n\t\t\tsum[j] = (sum[j] % mod + mod) % mod;\n\t\t\tmemo[i][j] = sum[j];\n\t\t}\n\n\t\tlocs[i] = loc;\n\t}\n\tvector<ll> alls = sum;\n\tll ans = 0;\n\tvector<map<ll, int>> mp(len);\n\trep(i, len) {\n\t\tmp[i][alls[i]]++;\n\t}\n\trep(i, n) {\n\t\t//cout << mp[memo[i]] << endl;\n\t\tint mi = 2*n;\n\t\trep(j, len) {\n\t\t\tmi = min(mi, mp[j][memo[i][j]]);\n\t\t}\n\t\tans += mi;\n\t\tbool valid = true;\n\t\t\n\t\trep(j, len) {\n\t\t\tll nex = alls[j];\n\t\t\tll mod = mods[j / roots.size()];\n\t\t\tif (locs[i] >= 0) {\n\t\t\t\tnex = nex * tr[locs[i]][j] % mod;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnex = nex * invtr[-locs[i]][j] % mod;\n\t\t\t}\n\t\t\tnex += memo[i][j];\n\t\t\tnex %= mod;\n\t\t\tmp[j][nex]++;\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(7);\n\tinit();\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <assert.h>\n#include <sys/time.h>\n#include <fstream>\n#include <iomanip>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  FOR(i,0,n)\n#define REP(i,n)  FOR(i,0,n)\n#define each(i,c) for(auto i=(c).begin(); i!=(c).end(); ++i)\n#define EACH(i,c) for(auto i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#define deb(x) cerr << #x << \" = \" << (x) << \" , \";\n#define debl cerr << \" (L\" << __LINE__ << \")\"<< endl;\n#define sz(s) (int)((s).size())\n\n\n#define clr(a) memset((a),0,sizeof(a))\n#define nclr(a) memset((a),-1,sizeof(a))\n#define pb push_back\n#define INRANGE(x,s,e) ((s)<=(x) && (x)<(e))\n#define MP(x,y) make_pair((x),(y))\n\ndouble pi=3.14159265358979323846;\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T> std::ostream& operator<<(std::ostream& os, const vector<T>& z){\n\tos << \"[ \";\n\tREP(i,z.size())os << z[i] << \", \" ;\n\treturn ( os << \"]\" << endl);\n}\n\ntemplate<typename T> std::ostream& operator<<(std::ostream& os, const set<T>& z){\n\tos << \"set( \";\n\tEACH(p,z)os << (*p) << \", \" ;\n\treturn ( os << \")\" << endl);\n}\n\ntemplate<typename T,typename U> std::ostream& operator<<(std::ostream& os, const map<T,U>& z){\n\tos << \"{ \";\n\tEACH(p,z)os << (p->first) << \": \" << (p->second) << \", \" ;\n\treturn ( os << \"}\" << endl);\n}\n\ntemplate<typename T,typename U> std::ostream& operator<<(std::ostream& os, const pair<T,U>& z){\n\treturn ( os << \"(\" << z.first << \", \" << z.second << \",)\" );\n}\n\ndouble get_time(){\n\tstruct timeval tv;\n\tgettimeofday(&tv, NULL);\n\treturn tv.tv_sec + tv.tv_usec*1e-6;\n}\n\ntypedef unsigned int uint32_t;\nstruct RND{\n\tuint32_t x;\n\tuint32_t y;\n\tuint32_t z;\n\tuint32_t w;\n\tRND(){\n\t\tx=123456789;\n\t\ty=362436069;\n\t\tz=521288629;\n\t\tw=88675123;\n\t}\n\tvoid init(int seed){\n\t\tx=123456789;\n\t\ty=362436069;\n\t\tz=521288629;\n\t\tw=seed+100;\n\t\tREP(i,10)get();\n\t}\n\tuint32_t get(){\n\t\tuint32_t t;\n\t\tt=x^(x<<11);\n\t\tx=y;y=z;z=w;\n\t\tw=(w^(w>>19))^(t^(t>>8));\n\t\treturn w;\n\t}\n};\nRND rnd;\n\nll mod=1LL<<58;\nstruct mint{\n\tll value;\n\tmint():value(0){}\n\tmint(ll v):value((v%mod+mod)%mod){}\n};\nmint& operator+=(mint&a, mint b){return a=a.value+b.value;}\nmint& operator-=(mint&a, mint b){return a=a.value-b.value;}\nmint& operator*=(mint&a, mint b){return a=a.value*b.value;}\nmint operator+(mint a, mint b){return a+=b;}\nmint operator-(mint a, mint b){return a-=b;}\nmint operator*(mint a, mint b){return a*=b;}\nmint operator-(mint a){return 0-a;}\nbool operator==(mint a, mint b){return a.value==b.value;}\nbool operator!=(mint a, mint b){return a.value!=b.value;}\n\n\nstd::ostream& operator<<(std::ostream& os, const mint& m){\nreturn ( os << m.value );}\nll extgcd(ll a, ll b, ll &x, ll &y){\n\tll d=a;\n\tif(b!=0){\n\t\td=extgcd(b, a%b, y, x);\n\t\ty-=(a/b)*x;\n\t}\n\telse{\n\t\tx=1,y=0;\n\t}\n\treturn d;\n}\nll modinverse(ll a, ll b){\n\tll x,y;\n\tll d=extgcd(a,b, x, y);\n\tassert(d==1);\n\treturn (x%b+b)%b;\n}\nmint& operator/=(mint&a, mint b){return a=a.value*modinverse(b.value,mod);}\nmint operator/(mint a, mint b){return a/=b;}\n\nvector<mint> f;\nvector<mint> pf;\nmint X = 123456789;\n\nvoid _main(istream &inp){\n\tint N;\n\tstring S;\n\tinp >> N >> S;\n\tf = vector<mint>(N+1);\n\tpf = vector<mint>(N+1);\n\tmint val = 0;\n\tmint u=1;\n\tf[0]=val;\n\tpf[0] = u;\n\trep(i,N){\n\t\tif(S[i]=='+')val += u;\n\t\tif(S[i]=='-')val -= u;\n\t\tif(S[i]=='>') u*=X;\n\t\tif(S[i]=='<')u/=X;\n\t\tf[i+1] = val;\n\t\tpf[i+1] = u;\n\t}\n//\tdebug(f);\n//\tdebug(pf);\n\tmap<ll,ll> cnt;\n\tll ret = 0;\n\tfor(int i=N;i>=0; i-- ){\n\t\tll tv = ( f[i] + pf[i]*f[N] ).value;\n\t\tif(exist(cnt, tv)){\n\t\t\tret += cnt[tv];\n\t\t}\n\t\tcnt[f[i].value]+=1;\n\t}\n\tcout << ret << endl;\n}\n\nint main(){\n\tif(0){\n\t\tifstream ifs(\"test.txt\");\n\t\t_main(ifs);\n\t}\n\telse{\n\t\t_main(cin);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<map>\n\ntypedef long long ll;\n\nconst int N=250010,MOD=1000000007,g=100000001;\n\nll inv(int x){return (x==1 || x==-1)?x:(-(MOD/x)*inv(MOD%x)%MOD);}\n\nint t0[N*2],*pow;\n\nvoid initialize()\n{\n\tpow=t0+N;\n\n\tpow[0]=1;\n\tfor(int i=1;i<N;i++)\n\t\tpow[i]=(ll)pow[i-1]*g%MOD;\n\n\tint ig=(inv(g)+MOD)%MOD;\n\tfor(int i=0;i<N;i++)\n\t\tpow[-i-1]=(ll)pow[-i]*ig%MOD;\n}\n\nchar s[N];\nint ind[N],val[N],sum[N];\nint n;\n\nll ans;\n\nvoid prework()\n{\n\tint p=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tind[i]=p,val[i]=0;\n\n\t\tif(s[i]=='<')p--;\n\t\telse if(s[i]=='>')p++;\n\t\telse if(s[i]=='+')val[i]=pow[p];\n\t\telse val[i]=-pow[p];\n\t}\n\n\tfor(int i=1;i<=n;i++)\n\t\tsum[i]=((sum[i-1]+val[i])%MOD+MOD)%MOD;\n}\n\nstd::map<int,int> G;\n\nvoid solve()\n{\n\tans=0;\n\tfor(int i=n,x,y;i;i--)\n\t{\n\t\tG[sum[i]]++;\n\n\t\tx=((ll)sum[n]*pow[ind[i]]%MOD+MOD)%MOD;\n\t\ty=((x+sum[i-1])%MOD+MOD)%MOD;\n\n\t\tans+=G[y];\n\t}\n}\n\nint main()\n{\n\tinitialize();\n\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",s+1);\n\n\tprework();\n\tsolve();\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<map>\nusing namespace std;\nstruct node{long long g1,g2,g3,g4,g5,g6/*,g7,g8*/;int p;};\nconst int p1=1000000007,p2=1000000009,p3=1000000021;\nlong long x1p1[510000],x1p2[510000],x1p3[510000],x2p1[510000],x2p2[510000],x2p3[510000]/*,x3p1[510000],x3p2[510000],x4p1[510000],x4p2[510000]*/;\ninline node operator+(node x,node y){return {(x.g1+y.g1*x1p1[x.p+250000])%p1,(x.g2+y.g2*x1p2[x.p+250000])%p2,(x.g3+y.g3*x1p3[x.p+250000])%p3,(x.g4+y.g4*x2p1[x.p+250000])%p1,(x.g5+y.g5*x2p2[x.p+250000])%p2,(x.g6+y.g6*x2p3[x.p+250000])%p3/*,(x.g5+y.g5*x3p1[x.p+250000])%p1,(x.g6+y.g6*x3p2[x.p+250000])%p2,(x.g7+y.g7*x4p1[x.p+250000])%p1,(x.g8+y.g8*x4p2[x.p+250000])%p2*/,x.p+y.p};}\nchar s[260000];\nmap<long long,map<long long,map<long long,map<long long,map<long long,map<long long/*,map<long long,map<long long*/,int/*>>*/>>>>>> M;\nint main()\n{\n\tx1p1[249999]=500000004;x1p1[250000]=1;x1p1[250001]=2;\n\tx1p2[249999]=500000005;x1p2[250000]=1;x1p2[250001]=2;\n\tx1p2[249999]=500000010;x1p2[250000]=1;x1p2[250001]=2;\n\tx2p1[249999]=666666671;x2p1[250000]=1;x2p1[250001]=3;\n\tx2p2[249999]=333333336;x2p2[250000]=1;x2p2[250001]=3;\n\tx2p2[249999]=333333340;x2p2[250000]=1;x2p2[250001]=3;\n\t/*x3p1[249999]=600000004;x3p1[250000]=1;x3p1[250001]=5;\n\tx3p2[249999]=800000007;x3p2[250000]=1;x3p2[250001]=5;\n\tx4p1[249999]=857142863;x4p1[250000]=1;x4p1[250001]=7;\n\tx4p2[249999]=142857144;x4p2[250000]=1;x4p2[250001]=7;*/\n\tfor(int i=249998;i>=0;i--)x1p1[i]=x1p1[i+1]*x1p1[249999]%p1,x1p2[i]=x1p2[i+1]*x1p2[249999]%p2,x1p3[i]=x1p3[i+1]*x1p3[249999]%p3,x2p1[i]=x2p1[i+1]*x2p1[249999]%p1,x2p2[i]=x2p2[i+1]*x2p2[249999]%p2,x2p3[i]=x2p3[i+1]*x2p3[249999]%p3/*,x3p1[i]=x3p1[i+1]*x3p1[249999]%p1,x3p2[i]=x3p2[i+1]*x3p2[249999]%p2,x4p1[i]=x4p1[i+1]*x4p1[249999]%p1,x4p2[i]=x4p2[i+1]*x4p2[249999]%p2*/;\n\tfor(int i=250002;i<=500000;i++)x1p1[i]=x1p1[i-1]*x1p1[250001]%p1,x1p2[i]=x1p2[i-1]*x1p2[250001]%p2,x1p3[i]=x1p3[i-1]*x1p3[250001]%p3,x2p1[i]=x2p1[i-1]*x2p1[250001]%p1,x2p2[i]=x2p2[i-1]*x2p2[250001]%p2,x2p3[i]=x2p3[i-1]*x2p3[250001]%p3/*,x3p1[i]=x3p1[i-1]*x3p1[250001]%p1,x3p2[i]=x3p2[i-1]*x3p2[250001]%p2,x4p1[i]=x4p1[i-1]*x4p1[250001]%p1,x4p2[i]=x4p2[i-1]*x4p2[250001]%p2*/;\n\tint n;scanf(\"%d%s\",&n,s+1);\n\tnode gs={0,0,0,0,0,0,0/*,0,0*/},pr={0,0,0,0,0,0,0/*,0,0*/};\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(s[i]=='+')gs.g1=(gs.g1+x1p1[gs.p+250000])%p1,gs.g2=(gs.g2+x1p2[gs.p+250000])%p2,gs.g3=(gs.g3+x1p3[gs.p+250000])%p3,gs.g4=(gs.g4+x2p1[gs.p+250000])%p1,gs.g5=(gs.g5+x2p2[gs.p+250000])%p2,gs.g6=(gs.g6+x2p3[gs.p+250000])%p3/*,gs.g5=(gs.g5+x3p1[gs.p+250000])%p1,gs.g6=(gs.g6+x3p2[gs.p+250000])%p2,gs.g7=(gs.g7+x4p1[gs.p+250000])%p1,gs.g8=(gs.g8+x4p2[gs.p+250000])%p2*/;\n\t\telse if(s[i]=='-')gs.g1=(gs.g1-x1p1[gs.p+250000]+p1)%p1,gs.g2=(gs.g2-x1p2[gs.p+250000]+p2)%p2,gs.g3=(gs.g3-x1p3[gs.p+250000]+p3)%p3,gs.g4=(gs.g4-x2p1[gs.p+250000]+p1)%p1,gs.g5=(gs.g5-x2p2[gs.p+250000]+p2)%p2,gs.g6=(gs.g6-x2p3[gs.p+250000]+p3)%p3/*,gs.g5=(gs.g5-x3p1[gs.p+250000]+p1)%p1,gs.g6=(gs.g6-x3p2[gs.p+250000]+p2)%p2,gs.g7=(gs.g7-x4p1[gs.p+250000]+p1)%p1,gs.g8=(gs.g8-x4p2[gs.p+250000]+p2)%p2*/;\n\t\telse if(s[i]=='>')gs.p++;\n\t\telse gs.p--;\n\t}\n\tlong long ss=0;\n\tnode rg=pr+gs;\n\tM[rg.g1][rg.g2][rg.g3][rg.g4][rg.g5][rg.g6]/*[rg.g7][rg.g8]*/++;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(s[i]=='+')pr.g1=(pr.g1+x1p1[pr.p+250000])%p1,pr.g2=(pr.g2+x1p2[pr.p+250000])%p2,pr.g3=(pr.g3+x1p3[pr.p+250000])%p3,pr.g4=(pr.g4+x2p1[pr.p+250000])%p1,pr.g5=(pr.g5+x2p2[pr.p+250000])%p2,pr.g6=(pr.g6+x2p3[pr.p+250000])%p3/*,pr.g5=(pr.g5+x3p1[pr.p+250000])%p1,pr.g6=(pr.g6+x3p2[pr.p+250000])%p2,pr.g7=(pr.g7+x4p1[pr.p+250000])%p1,pr.g8=(pr.g8+x4p2[pr.p+250000])%p2*/;\n\t\telse if(s[i]=='-')pr.g1=(pr.g1-x1p1[pr.p+250000]+p1)%p1,pr.g2=(pr.g2-x1p2[pr.p+250000]+p2)%p2,pr.g3=(pr.g3-x1p3[pr.p+250000]+p3)%p3,pr.g4=(pr.g4-x2p1[pr.p+250000]+p1)%p1,pr.g5=(pr.g5-x2p2[pr.p+250000]+p2)%p2,pr.g6=(pr.g6-x2p3[pr.p+250000]+p3)%p3/*,pr.g5=(pr.g5-x3p1[pr.p+250000]+p1)%p1,pr.g6=(pr.g6-x3p2[pr.p+250000]+p2)%p2,pr.g7=(pr.g7-x4p1[pr.p+250000]+p1)%p1,pr.g8=(pr.g8-x4p2[pr.p+250000]+p2)%p2*/;\n\t\telse if(s[i]=='>')pr.p++;\n\t\telse pr.p--;\n\t\tss=ss+M[pr.g1][pr.g2][pr.g3][pr.g4][pr.g5][pr.g6]/*[pr.g7][pr.g8]*/;\n\t\trg=pr+gs;\n\t\tM[rg.g1][rg.g2][rg.g3][rg.g4][rg.g5][rg.g6]/*[rg.g7][rg.g8]*/++;\n\t}\n\tprintf(\"%lld\\n\",ss);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll N=25e4,mo=23333333333333333,M=2e7+3;\nll pw[N],ny[N];\nll h[M],g[M],n,S,v[N],ans;\nchar s[N];\nll mul(ll a,ll b){\n\tll c=(long double)a*b/mo,z=a*b-c*mo;\n\treturn (z<0)?z+mo:(z-mo*(z>=mo));\n}\nll power(ll a,ll b=mo-2){\n\tll ans=1;\n\twhile (b){\n\t\tif (b&1)ans=mul(ans,a);\n\t\ta=mul(a,a);\n\t\tb>>=1;\n\t}return ans;\n}\nll base(int p){\n\treturn p<0?ny[-p]:pw[p];\n}\nint gethash(ll x){\n\tint a=x%M;\n\twhile (~h[a]&&h[a]!=x)a=(a+1)%M;\n\treturn a;\n}\nint main(){\n\tmemset(h,255,sizeof h);\n\tcin>>n;\n\tpw[0]=ny[0]=1;\n\tpw[1]=(1e7+19),ny[1]=power(pw[1]);\n\tfor (int i=2;i<=n;i++)\n\t\tpw[i]=mul(pw[i-1],pw[1]),\n\t\tny[i]=mul(ny[i-1],ny[1]);\n\tint p=0;\n\tscanf(\"%s\",s+1);\n\tfor (int i=1;i<=n;i++){\n\t\tif (s[i]=='+')S=(S+base(p))%mo;\n\t\tif (s[i]=='-')S=(S-base(p)+mo)%mo;\n\t\tif (s[i]=='<')p--;\n\t\tif (s[i]=='>')p++;\n\t\tint k=gethash(S);\n\t\th[k]=S,g[k]++;\n\t\tv[i]=S;\n\t}\n\tll a=1,b=0,ia=1;\n\tfor (int i=1;i<=n;i++){\n\t\tll s1=mul((S-b+mo)%mo,ia);\n\t\tans+=g[gethash(s1)];\n\t\tg[gethash(v[i])]--;\n\t\tif (s[i]=='+')b=(b-1+mo)%mo;\n\t\tif (s[i]=='-')b=(b+1)%mo;\n\t\tif (s[i]=='<')a=mul(a,pw[1]),b=mul(b,pw[1]),ia=mul(ia,ny[1]);\n\t\tif (s[i]=='>')a=mul(a,ny[1]),b=mul(b,ny[1]),ia=mul(ia,pw[1]);\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#include<map>\nusing namespace std;\nconst long long Mod=1000000009;\nconst long long base=1000003;\nint n;\nchar s[250010];\nlong long a[250010],b[250010];\nlong long fpow(long long a,long long b)\n{\n\tlong long ans=1,t=a;\n\twhile(b)\n\t{\n\t\tif(b&1)ans=ans*t%Mod;\n\t\tt=t*t%Mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nmap<long long,int>mp;\nint main()\n{\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",s+1);\n\tlong long x=0,y=0,invbase=fpow(base,Mod-2);\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tif(s[i]=='-')\n\t\t\tx=(x-1+Mod)%Mod;\n\t\telse if(s[i]=='+')\n\t\t\tx=(x+1)%Mod;\n\t\telse if(s[i]=='<')\n\t\t\tx=(x*base)%Mod;\n\t\telse x=x*invbase%Mod;\n\t}\n\tlong long c=x;\n\tx=1;y=0;\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tif(s[i]=='+')\n\t\t\ty=(y-x+Mod)%Mod;\n\t\telse if(s[i]=='-')\n\t\t\ty=(y+x)%Mod;\n\t\telse if(s[i]=='>')\n\t\t\tx=x*base%Mod;\n\t\telse x=x*invbase%Mod;\n\t\tb[i]=y;\n\t\ta[i]=(x*c+y)%Mod;\n\t}\n\tlong long ans=0;\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tmp[b[i+1]]++;\n\t\tans+=mp[a[i]];\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\n//const ll mod = 1000000087;\n//const ll INF = mod * mod;\ntypedef pair<int, int>P;\ntypedef pair<int, bool> sP;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef pair<ll, ll> LP;\ntypedef vector<ll> vec;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef vector<vector<ll>> mat;\ntypedef vector<ll> vec;\n\n\n\nvector<ll> mods;\nvector<ll> roots;\n\nbool isp(ll x) {\n\tRep1(i,2, 100000) {\n\t\tif (x%i == 0)return false;\n\t}\n\treturn true;\n}\nvoid genmods() {\n\tll sta = 1000010000;\n\twhile (mods.size() < 3) {\n\t\tif (isp(sta))mods.push_back(sta);\n\t\tsta++;\n\t}\n}\nvoid genroots() {\n\tll sta = 2000010000;\n\twhile (roots.size() < 2) {\n\t\tif (isp(sta))roots.push_back(sta);\n\t\tsta++;\n\t}\n}\nll mod_pow(ll x, ll n,ll mod) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n % 2)res = res * x%mod;\n\t\tx = x * x%mod; n >>= 1;\n\t}\n\treturn res;\n}\nvector<ll> invroots;\n\nvector<ll> tr[300000];\nvector<ll> invtr[300000];\nvoid init() {\n\tgenmods();\n\tgenroots();\n\trep(i, 300000) {\n\t\ttr[i].resize(mods.size()*roots.size());\n\t\tinvtr[i].resize(mods.size()*roots.size());\n\t}\n\trep(j, tr[0].size()) {\n\t\ttr[0][j] = invtr[0][j] = 1;\n\t}\n\trep(j, mods.size()) {\n\t\trep(k, roots.size()) {\n\t\t\tinvroots.push_back(mod_pow(roots[k], mods[j] - 2, mods[j]));\n\t\t}\n\t}\n\trep(i, 299999) {\n\t\trep(j, mods.size()) {\n\t\t\trep(k, roots.size()) {\n\t\t\t\tint id = j * roots.size() + k;\n\t\t\t\ttr[i + 1][id] = tr[i][id] * roots[k] % mods[j];\n\t\t\t\tinvtr[i + 1][id] = invtr[i][id] * invroots[id] % mods[j];\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve() {\n\tint n; cin >> n;\n\tstring s; cin >> s;\n\tvector<ll> sum(mods.size()*roots.size(),0); int loc = 0;\n\tvector<vector<ll>> memo(n);\n\trep(i, n)memo[i].resize(mods.size()*roots.size());\n\tvector<int> locs(n);\n\tint len = roots.size()*mods.size();\n\trep(i, n) {\n\t\tif (s[i] == '>')loc++;\n\t\telse if (s[i] == '<')loc--;\n\t\telse if (s[i] == '+') {\n\t\t\tif (loc >= 0) {\n\t\t\t\trep(j, len) {\n\t\t\t\t\tsum[j] += tr[loc][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\trep(j, len) {\n\t\t\t\t\tsum[j] += invtr[-loc][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (loc >= 0) {\n\t\t\t\trep(j, len) {\n\t\t\t\t\tsum[j] -= tr[loc][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\trep(j, len) {\n\t\t\t\t\tsum[j] -= invtr[-loc][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(j, len) {\n\t\t\tll mod = mods[j / roots.size()];\n\t\t\tsum[j] = (sum[j] % mod + mod) % mod;\n\t\t\tmemo[i][j] = sum[j];\n\t\t}\n\n\t\tlocs[i] = loc;\n\t}\n\tvector<ll> alls = sum;\n\tll ans = 0;\n\tvector<map<ll, int>> mp(len);\n\trep(i, len) {\n\t\tmp[i][alls[i]]++;\n\t}\n\trep(i, n) {\n\t\t//cout << mp[memo[i]] << endl;\n\t\tint mi = 2*n;\n\t\trep(j, len) {\n\t\t\tmi = min(mi, mp[j][memo[i][j]]);\n\t\t}\n\t\tans += mi;\n\t\tbool valid = true;\n\t\t\n\t\trep(j, len) {\n\t\t\tll nex = alls[j];\n\t\t\tll mod = mods[j / roots.size()];\n\t\t\tif (locs[i] >= 0) {\n\t\t\t\tnex = nex * tr[locs[i]][j] % mod;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnex = nex * invtr[-locs[i]][j] % mod;\n\t\t\t}\n\t\t\tnex += memo[i][j];\n\t\t\tnex %= mod;\n\t\t\tmp[j][nex]++;\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(7);\n\tinit();\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\n\nconst int MAXN = 250005;\nlint mod = 1e16 + 61;\nconst int base = 257;\nint n, pos[MAXN];\nchar str[MAXN];\nlint pwr[MAXN * 2];\nlint inv[MAXN * 2];\n\nlint ipow(lint x, lint p){\n  lint ret = 1, piv = x;\n  while(p){\n    if(p & 1) ret = (__int128) ret * piv % mod;\n    piv = (__int128) piv * piv % mod;\n    p >>= 1;\n  }\n  return ret;\n}\n\nlint psum[MAXN];\n\nint main(){\n  mod++;\n  cin >> n >> (str + 1);\n  pwr[0] = inv[0] = 1;\n  for(int i=1; i<MAXN * 2; i++){\n    pwr[i] = pwr[i-1] * base % mod;\n    inv[i] = ipow(pwr[i], mod - 2);\n  }\n  pos[0] = n;\n  for(int i=1; i<=n; i++){\n    pos[i] = pos[i-1];\n    psum[i] = psum[i-1];\n    if(str[i] == '<') pos[i]--;\n    if(str[i] == '>') pos[i]++;\n    if(str[i] == '+') psum[i] += pwr[pos[i]];\n    if(str[i] == '-') psum[i] += mod - pwr[pos[i]];\n    psum[i] %= mod;\n  }\n  lint H = psum[n];\n  lint ret = 0;\n  map<lint, int> mp;\n  for(int i=n; i; i--){\n    mp[psum[i]]++;\n    __int128 Hv = H;\n    if(pos[0] <= pos[i-1]) Hv *= pwr[pos[i-1] - pos[0]];\n    else Hv *= inv[pos[0] - pos[i-1]];\n    Hv += psum[i-1];\n    Hv %= mod;\n    ret += mp[Hv];\n  }\n  cout << ret << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nchar s[250002];\nint num[8000000],sl[8000000],sr[8000000],nodes;\nint newnode()\n{\n    sl[nodes]=-1;\n    sr[nodes]=-1;\n    return nodes++;\n}\nvoid update(int &id,int il,int ir,int pos)\n{\n    if (id==-1)\n        id=newnode();\n    if (ir-il==1)\n    {\n        ++num[id];\n        return;\n    }\n    int mid=(il+ir)>>1;\n    if (pos<mid)\n        update(sl[id],il,mid,pos);\n    else\n        update(sr[id],mid,ir,pos);\n    ++num[id];\n}\nint query(int id,int il,int ir,int pos)\n{\n    if (id==-1)\n        return 0;\n    if (ir-il==1)\n        return num[id];\n    int mid=(il+ir)>>1;\n    return pos<mid?query(sl[id],il,mid,pos):query(sr[id],mid,ir,pos);\n}\nint pw[500001],prefix[250001],pos[250001];\nconst int MOD=1000000007;\nint qpow(int a,int b)\n{\n    int ret=1;\n    for (;b;a=(long long)a*a%MOD,b>>=1)\n        if (b&1)\n            ret=(long long)ret*a%MOD;\n    return ret;\n}\nint main()\n{\n    int n;\n    scanf(\"%d%s\",&n,s+1);\n    pw[0]=1;\n    for (int i=1;i<=500000;++i)\n        pw[i]=(long long)pw[i-1]*19260817%MOD;\n    pos[0]=0;\n    for (int i=1;i<=n;++i)\n    {\n        prefix[i]=prefix[i-1];\n        pos[i]=pos[i-1];\n        if (s[i]=='<')\n            --pos[i];\n        else if (s[i]=='>')\n            ++pos[i];\n        else if (s[i]=='+')\n        {\n            prefix[i]+=pw[pos[i]+250000];\n            if (prefix[i]>=MOD)\n                prefix[i]-=MOD;\n        }\n        else\n        {\n            prefix[i]-=pw[pos[i]+250000];\n            if (prefix[i]<0)\n                prefix[i]+=MOD;\n        }\n    }\n    int rt=-1;\n    long long ans=0;\n    for (int i=n;i>=1;--i)\n    {\n        int tmp=prefix[n];\n        tmp-=prefix[i];\n        if (tmp<0)\n            tmp+=MOD;\n        update(rt,0,1073741824,tmp);\n        tmp=prefix[n];\n        if (pos[i-1])\n            tmp=(long long)tmp*pw[pos[i-1]]%MOD;\n        else if (pos[i-1]<0)\n            tmp=(long long)tmp*qpow(pw[-pos[i-1]],MOD-2);\n        tmp=prefix[n]-tmp;\n        if (tmp<0)\n            tmp+=MOD;\n        tmp-=prefix[i-1];\n        if (tmp<0)\n            tmp+=MOD;\n        ans+=query(rt,0,1073741824,tmp);\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define N 250052\n#define p 1000000007\n#define q 19260817\ninline int mod(int x){return x<p?x:x-p;}\ninline int div(int x){return x&1?x+p>>1:x>>1;}\nchar s[N];int A[q],B[N],C[N],D[N],T,a[N],b[N],i,j,n;long long z;\ninline int Hash(int x)\n{\n    int y=x%q;\n    for(j=A[y];j;j=B[j])if(C[j]==x)return j;\n    return 0;\n}\ninline void add(int x)\n{\n    int y=Hash(x);\n    !y?B[++T]=A[y=x%q],C[A[y]=T]=x,D[T]=1:D[y]++;\n}\nint main()\n{\n    scanf(\"%d%s\",&n,s+1);\n    for(*a=i=1;i<=n;i++)\n    if(s[i]=='+')a[i]=a[i-1],b[i]=mod(a[i-1]+b[i-1]);\n    else if(s[i]=='-')a[i]=a[i-1],b[i]=mod(p+b[i-1]-a[i-1]);\n    else if(s[i]=='>')a[i]=mod(a[i-1]<<1),b[i]=b[i-1];\n    else a[i]=div(a[i-1]),b[i]=b[i-1];\n    for(i=1;i<=n;i++)add(((long long)b[n]*a[i-1]+b[i-1])%p),z+=D[Hash(b[i])];\n    return 0*printf(\"%lld\\n\",z);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long int int64;\nstatic const int64 mod1 = 1290382391, mod2 = 1350983507;\nusing hash = std::pair<int,int>;\nhash x(139436098, 325878929);\nhash y(1142067043, 890079571);\nint64 exgcd(int64 a,int64 b,int64 &c,int64 &d)\n{\n\tif(b == 0) {\n\t\tc = 1, d = 0;\n\t\treturn a;\n\t}\n\tint64 k = exgcd(b,a%b,d,c);\n\td -= c * (a / b);\n\treturn k;\n}\nusing hash = std::pair<int,int>;\nhash operator +(const hash &a, const hash &b) {\n\treturn hash(((int64)a.first+b.first)%mod1,((int64)a.second+b.second)%mod2);\n}\nhash operator *(const hash &a, const hash &b) {\n\treturn hash((int64)a.first*b.first%mod1,(int64)a.second*b.second%mod2);\n}\nhash operator -(const hash &a, const hash &b) {\n\tint v1 = a.first-b.first, v2 = a.second-b.second;\n\tif(v1<0) v1+=mod1; if(v2<0) v2+=mod2;\n\treturn hash(v1,v2);\n}\nhash inv(const hash &x) {\n\tint64 v1,v2,v3,v4;\n\tassert(exgcd(mod1,x.first,v1,v2) == 1);\n\tassert(exgcd(mod2,x.second,v3,v4) == 1);\n\treturn hash(v2<0?v2+mod1:v2,v4<0?v4+mod2:v4);\n}\nhash operator /(const hash &a, const hash &b) {\n\treturn a*inv(b);\n}\nusing line = std::pair<hash,hash>;\n// b(a(x))\nline compose(const line &a,const line &b) {\n\treturn line(a.first*b.first,b.first*a.second+b.second);\n}\nint n;\nchar s[250003];\nline pre[250003],invpre[250003];\nint main()\n{\n\tscanf(\"%d %s\",&n,s+1);\n\tpre[n+1] = invpre[n+1] = line(hash(1,1),hash(0,0));\n\thash f(0,0);\n\tfor(int i = n;i >= 1;--i) {\n\t\tline l, invl;\n\t\tswitch(s[i]) {\n\t\tcase '+': {\n\t\t\tl = line(hash(1,1),hash(1,1));\n\t\t\tinvl = line(hash(1,1),hash(mod1-1,mod2-1));\n\t\t\tbreak;\n\t\t}\n\t\tcase '-': {\n\t\t\tl = line(hash(1,1),hash(mod1-1,mod2-1));\n\t\t\tinvl = line(hash(1,1),hash(1,1));\n\t\t\tbreak;\n\t\t}\n\t\tcase '>': {\n\t\t\tl = line(x,hash(0,0));\n\t\t\tinvl = line(y,hash(0,0));\n\t\t\tbreak;\n\t\t}\n\t\tcase '<': {\n\t\t\tl = line(y,hash(0,0));\n\t\t\tinvl = line(x,hash(0,0));\n\t\t\tbreak;\n\t\t}}\n\t\tpre[i] = compose(pre[i+1],l);\n\t\tinvpre[i] = compose(invl,invpre[i+1]);\n\t}\n\tf = pre[1].second;\n\tstd::map<hash,int> m;\n\tint64 ans = 0;\n\tfor(int i = n+1;i >= 1;--i) {\n\t\tans += m[f*invpre[i].first+invpre[i].second];\n\t\t++m[invpre[i].second];\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <string.h>\n//#include <unordered_set>\n//#include <unordered_map>\n//#include <bits/stdc++.h>\n\n#define MP(A,B) make_pair(A,B)\n#define PB(A) push_back(A)\n#define SIZE(A) ((int)A.size())\n#define LEN(A) ((int)A.length())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define fi first\n#define se second\n\nusing namespace std;\n\ntemplate<typename T>inline bool upmin(T &x,T y) { return y<x?x=y,1:0; }\ntemplate<typename T>inline bool upmax(T &x,T y) { return x<y?x=y,1:0; }\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double lod;\ntypedef pair<int,int> PR;\ntypedef vector<int> VI;\n\nconst lod eps=1e-11;\nconst lod pi=acos(-1);\nconst int oo=1<<30;\nconst ll loo=1ll<<62;\nconst int mods=998244353;\nconst int MAXN=100000005;\nconst int INF=0x3f3f3f3f;//1061109567\n/*--------------------------------------------------------------------*/\ninline int read()\n{\n\tint f=1,x=0; char c=getchar();\n\twhile (c<'0'||c>'9') { if (c=='-') f=-1; c=getchar(); }\n\twhile (c>='0'&&c<='9') { x=(x<<3)+(x<<1)+(c^48); c=getchar(); }\n\treturn x*f;\n}\nint upd(int x,int y) { return x+y>=mods?x+y-mods:x+y; }\nint quick_pow(int x,int y)\n{\n\tint ret=1;\n\tfor (;y;y>>=1)\n\t{\n\t\tif (y&1) ret=1ll*ret*x%mods;\n\t\tx=1ll*x*x%mods;\n\t}\n\treturn ret;\n}\n\nchar st[MAXN];\nint X[6]={37,667,233333,17,19,53},inv[6];\nstruct Node\n{\n\tint a[6]; \n\tNode() { for (int i=0;i<6;i++) a[i]=0; }\n};\nbool operator < (Node x,Node y) \n{\n\tfor (int i=0;i<6;i++) { if (x.a[i]==y.a[i]) continue; return x.a[i]<y.a[i]; }\n\treturn 0;\n}\nmap<Node,int> Map;\nNode operator + (Node x,int y) { for (int i=0;i<6;i++) x.a[i]=upd(x.a[i],y); return x; }\nNode operator - (Node x,int y) { for (int i=0;i<6;i++) x.a[i]=upd(x.a[i],mods-y); return x; }\nNode operator >> (Node x,int y) { while (y--) for (int i=0;i<6;i++) x.a[i]=1ll*x.a[i]*X[i]%mods; return x; }\nNode operator << (Node x,int y) { while (y--) for (int i=0;i<6;i++) x.a[i]=1ll*x.a[i]*inv[i]%mods; return x; }\n\nstruct fnode\n{\n\tNode k,b;\n\tfnode() { for (int i=0;i<6;i++) k.a[i]=1,b.a[i]=0; }\n};\nfnode operator + (fnode x,int y) { for (int i=0;i<6;i++) x.b.a[i]=upd(x.b.a[i],y*x.k.a[i]); return x; }\nfnode operator - (fnode x,int y) { for (int i=0;i<6;i++) x.b.a[i]=upd(x.b.a[i],mods-y*x.k.a[i]); return x; }\nfnode operator >> (fnode x,int y) { while (y--) for (int i=0;i<6;i++) x.k.a[i]=1ll*x.k.a[i]*X[i]%mods; return x; }\nfnode operator << (fnode x,int y) { while (y--) for (int i=0;i<6;i++) x.k.a[i]=1ll*x.k.a[i]*inv[i]%mods; return x; }\nNode operator * (Node x,fnode y) \n{\n\tNode ans;\n\tfor (int i=0;i<6;i++) ans.a[i]=upd(ans.a[i],(1ll*y.k.a[i]*x.a[i]+y.b.a[i])%mods);\n\treturn ans;\n}\nint main()\n{\n\tfor (int i=0;i<6;i++) inv[i]=quick_pow(X[i],mods-2),cout<<X[i]<<\":\"<<inv[i]<<endl;\n\tint n=read(),ans=0;\n\tscanf(\"%s\",st+1);\n\tNode c,p;\n\tfor (int i=n;i>=1;i--)\n\t{\n\t\tif (st[i]=='+') c=c+1;\n\t\tif (st[i]=='-') c=c-1;\n\t\tif (st[i]=='<') c=c<<1;\n\t\tif (st[i]=='>') c=c>>1;\n//\t\tfor (int j=0;j<6;j++) cout<<c.a[j]<<\" \";cout<<endl;\n\t}\n//\tcout<<endl;\n\tMap[p]++;\n\tfnode f;\n\tfor (int i=n;i>=1;i--)\n\t{\n\t\tif (st[i]=='+') f=f-1;\n\t\tif (st[i]=='-') f=f+1;\n\t\tif (st[i]=='<') f=f>>1;\n\t\tif (st[i]=='>') f=f<<1;\n\t\tans+=Map[c*f],Map[p*f]++;\n//\t\tfor (int j=0;j<6;j++) cout<<(p*f).a[j]<<\" \";cout<<endl;\n//\t\tfor (int j=0;j<6;j++) cout<<(c*f).a[j]<<\" \";cout<<endl<<endl;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 250005, MOD[2] = {1035534743, 1043802787};\n\nconstexpr int power(int a, int x, int P) {\n\tint ans = 1;\n\tfor (; x; x >>= 1, a = 1ll * a * a % P)\n\t\tif (x & 1) ans = 1ll * ans * a % P;\n\treturn ans;\n}\n\nconstexpr int B[2] = {327337, 329191}, C[2] = {power(B[0], MOD[0] - 2, MOD[0]), power(B[1], MOD[1] - 2, MOD[1])};\nint n;\nchar s[N];\narray<pair<int, int>, 2> f[N];\narray<int, 2> a[N], b[N];\nmap<array<int, 2>, int> buc;\n\nint main() {\n\tscanf(\"%d%s\", &n, s + 1);\n/*\t+ t + 1\n\t- t - 1\n\t> t / x\n\t< t * x*/\n\tf[n + 1][0] = f[n + 1][1] = {1, 0};\n\tarray<int, 2> c = {};\n\tfor (int i = n; i; --i)\n\t\tfor (int j = 0; j < 2; ++j)\n\t\t\tif (s[i] == '+')\n\t\t\t\t++c[j];\n\t\t\telse if (s[i] == '-')\n\t\t\t\t--c[j];\n\t\t\telse if (s[i] == '<')\n\t\t\t\tc[j] = 1ll * c[j] * B[j] % MOD[j];\n\t\t\telse\n\t\t\t\tc[j] = 1ll * c[j] * C[j] % MOD[j];\n\tc[0] = (c[0] + MOD[0]) % MOD[0];\n\tc[1] = (c[1] + MOD[1]) % MOD[1];\n\tf[n + 1][0] = f[n + 1][1] = {1, 0};\n\tfor (int i = n; i; --i)\n\t\tfor (int j = 0; j < 2; ++j) {\n\t\t\tf[i][j] = f[i + 1][j];\n\t\t\tif (s[i] == '-')\n\t\t\t\t(f[i][j].second += f[i][j].first) %= MOD[j];\n\t\t\telse if (s[i] == '+') {\n\t\t\t\tf[i][j].second -= f[i][j].first;\n\t\t\t\tif (f[i][j].second < 0) f[i][j].second += MOD[j];\n\t\t\t} else if (s[i] == '<')\n\t\t\t\tf[i][j].first = 1ll * f[i][j].first * C[j] % MOD[j];\n\t\t\telse\n\t\t\t\tf[i][j].first = 1ll * f[i][j].first * B[j] % MOD[j];\n\t\t}\n\tlong long ans = 0;\n\tfor (int i = n; i; --i) {\n\t\t++buc[{f[i + 1][0].second, f[i + 1][1].second}];\n\t\tans += buc[{int((1ll * f[i][0].first * c[0] + f[i][0].second) % MOD[0]), int((1ll * f[i][1].first * c[1] + f[i][1].second) % MOD[1])}];\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\n\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\n\n\n\nlong long modinv(long long a, long long mod) {\n    long long b = mod, u = 1, v = 0;\n    while (b) {\n        long long t = a/b;\n        a -= t*b; swap(a, b);\n        u -= t*v; swap(u, v);\n    }\n    u %= mod;\n    if (u < 0) u += mod;\n    return u;\n}\n\nlong long modpow(long long a, long long n, long long mod) {\n    long long res = 1;\n    if (n < 0) {\n        a = modinv(a, mod);\n        n = -n;\n        return modpow(a, n, mod);\n    }\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nconst vector<long long> MOD = {1000000009, 1000000007};\nconst vector<long long> BASE = {17, 1009};\n\nlong long solve(int N, const string &S) {\n    vector<vector<long long>> hash(2, vector<long long>(N+1, 0));\n    vector<vector<long long>> pval(2, vector<long long>(N+1, 0));\n    map<pair<long long, long long>, vector<int>> pos;\n\n    for (int i = 0; i < N; ++i) {\n        for (int it = 0; it < 2; ++it) {\n            if (S[i] == '>') {\n                hash[it][i+1] = hash[it][i];\n                pval[it][i+1] = pval[it][i] + 1;\n            }\n            else if (S[i] == '<') {\n                hash[it][i+1] = hash[it][i];\n                pval[it][i+1] = pval[it][i] - 1;\n            }\n            else if (S[i] == '+') {\n                pval[it][i+1] = pval[it][i];\n                long long add = modpow(BASE[it], pval[it][i], MOD[it]);\n                hash[it][i+1] = (hash[it][i] + add) % MOD[it];\n            }\n            else if (S[i] == '-') {\n                pval[it][i+1] = pval[it][i];\n                long long add = modpow(BASE[it], pval[it][i], MOD[it]);\n                hash[it][i+1] = (hash[it][i] - add + MOD[it]) % MOD[it];\n            }\n        }\n        pos[{hash[0][i+1], hash[1][i+1]}].push_back(i+1);\n\n        //cout << i+1 << \": \" << hash[i+1] << \", \" << pval[i+1] << endl;\n    }\n\n    long long res = 0;\n    for (int i = 0; i <= N; ++i) {\n        vector<long long> risou_add(2), risou(2);\n        for (int it = 0; it < 2; ++it) {\n            risou_add[it] = hash[it][N] * modpow(BASE[it], pval[it][i], MOD[it]) % MOD[it];\n            risou[it] = (hash[it][i] + risou_add[it]) % MOD[it];\n        }\n        /*\n        COUT(\"-----------------\");\n        COUT(i); COUT(pval[i]); COUT(pos[risou]);\n        cout << cur << \" + \" << risou_add << \" -> \" << risou << endl;\n        */\n        \n        auto &v = pos[{risou[0], risou[1]}];\n        int it = upper_bound(v.begin(), v.end(), i) - v.begin();\n        res += (int)v.size() - it;\n    }\n    return res;\n}\n\nint main() {\n    int N; string S;\n    while (cin >> N >> S) cout << solve(N, S) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pi 3.1415926535897932384626\nusing namespace std;\n      \nstruct P{\n  int x,y;\n  bool operator < (const P &a )const{\n    //if(y!=a.y)\n    return y>a.y;\n  };\n\n};\n\nint a,b,c,d,i,n,m,e,dx[10]={1,0,-1,0,1,1,-1,-1},dy[10]={0,1,0,-1,1,-1,1,-1};\nlong long o[251010];\nint l[251011];\nlong long s[251011],re[251010];\nlong long x,y,z,mod=1000000007,hf=(mod+1)/2;\n\n//string r,r1;\nchar r[251011];\n vector<int> v[1],v1;\nP u[1];\nqueue<int> q;\n//set<int> s[2];\n//stack<long long> s;\nmap<long long,int> p;\n//mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n//rng()\nbool as(P a,P b)\n{\n  return a.x<b.x;\n}\n\nlong long po(long long x,long long y)\n{\n  long long p=1;\n  for(;y;y/=2,x*=x,x%=z)\n  if(y%2)\n  {\n    p*=x,p%=z;\n  }\n  return p;\n}\n\nlong long f(int n)\n{\n  if(n<0) return re[abs(n)];\n  return s[n];\n}\n\nint main()\n{\n  scanf(\"%d %s\",&a,r+1);\n  z=1000000021;\n  s[0]=re[0]=1;\n  for(int t=1;t<=a;t++)\n    s[t]=s[t-1]*3*a%z,re[t]=po(s[t],z-2);\n  for(int t=1;t<=a;t++)\n  {\n    if(r[t]=='+') x+=f(n),x%=z;\n    else if(r[t]=='-') x+=(-f(n)+z),x%=z;\n    else if(r[t]=='>') n++;\n    else n--;\n    l[t]=n;\n    o[t]=x;\n  }\n  long long k=0;\n  y=x;\n  for(int t=a;t;t--)\n  {\n    p[o[t]]++;\n    k+=p[(o[t-1]+y*f(l[t-1])%z)%z];\n    //printf(\"%lld %lld %lld\\n\",k,o[t],(o[t-1]+y*f(l[t-1])%z)%z);\n  }\n  printf(\"%lld\",k);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\nconst ll p=1000000000000000009;\nconst int base=250001;\nunordered_map<ll,int> mp;\nint n,dig[250005];\n__int128 pw[250005]={1},hsh[250005];\nll ans;\nchar s[250005];\nll qpow(__int128 a,ll b){\n    ll res=1;\n    while(b){\n        if(b&1)\n            res=res*a%p;\n        a=a*a%p;\n        b>>=1;\n    }\n    return res;\n}\n__int128 power(int x){\n    return x>=0?pw[x]:qpow(pw[-x],p-2);\n}\nint main(){\n    ios::sync_with_stdio(false);\n    ll val;\n    int i;\n    cin>>n>>s+1;\n    for(i=1;i<=n;i++)\n        pw[i]=pw[i-1]*base%p;\n    for(i=1;i<=n;i++){\n        switch(s[i]){\n            case '+':\n                dig[i]=dig[i-1];\n                hsh[i]=(hsh[i-1]+power(dig[i]))%p;\n                break;\n            case '-':\n                dig[i]=dig[i-1];\n                hsh[i]=(hsh[i-1]-power(dig[i])+p)%p;\n                break;\n            case '<':\n                dig[i]=dig[i-1]+1;\n                hsh[i]=hsh[i-1];\n                break;\n            case '>':\n                dig[i]=dig[i-1]-1;\n                hsh[i]=hsh[i-1];\n        }\n    }\n    for(i=0;i<=n;i++){\n        if(mp.count(hsh[i]))\n            ans+=mp[hsh[i]];\n        val=(hsh[i]+hsh[n]*power(dig[i]))%p;\n        if(mp.count(val))\n            mp[val]++;\n        else\n            mp[val]=1;\n    }\n    cout<<ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef unsigned long long ull;\n#define mp make_pair\n\nconst int K = 4;\nll MODS[] = {(ll)1e9 + 7, (ll)1e9 + 9, (ll)1e9 + 21, (ll)1e9 + 33};\n\nll bin_pow(ll x, ll p, ll mm) {\n\tif (p == 0) return 1;\n\tif (p & 1) return (x * bin_pow(x, p - 1, mm)) % mm;\n\tll y = bin_pow(x, p / 2, mm);\n\treturn (y * y) % mm;\n}\n\nstruct PolyHash {\n\tll x[K];\n\n\tPolyHash() : x() {}\n\tPolyHash(ll Z) {\n\t\tfor (int i = 0; i < K; i++)\n\t\t\tx[i] = Z % MODS[i];\n\t}\n\n\tPolyHash operator + (const PolyHash &H) const {\n\t\tPolyHash res = PolyHash();\n\t\tfor (int i = 0; i < K; i++) {\n\t\t\tres.x[i] = (x[i] + H.x[i]) % MODS[i];\n\t\t}\n\t\treturn res;\n\t}\n\n\tPolyHash operator - (const PolyHash &H) const {\n\t\tPolyHash res = PolyHash();\n\t\tfor (int i = 0; i < K; i++) {\n\t\t\tres.x[i] = (x[i] - H.x[i] + MODS[i]) % MODS[i];\n\t\t}\n\t\treturn res;\n\t}\n\n\tPolyHash operator * (const PolyHash &H) const {\n\t\tPolyHash res = PolyHash();\n\t\tfor (int i = 0; i < K; i++) {\n\t\t\tres.x[i] = (x[i] * H.x[i]) % MODS[i];\n\t\t}\n\t\treturn res;\n\t}\n\n\tbool operator < (const PolyHash &H) const {\n\t\tfor (int i = 0; i < K; i++) {\n\t\t\tif (x[i] != H.x[i])\n\t\t\t\treturn x[i] < H.x[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nconst int N = 500500;\nconst int M = N / 2;\nPolyHash pw[N];\nPolyHash a[N], b[N];\nint c[N];\nchar s[N];\nint L;\nmap<PolyHash, ll> mapchik;\n\nvoid precalc() {\n\tpw[M] = PolyHash(1);\n\tll PP = 27554547;\n\tpw[M + 1] = PolyHash(PP);\n\tfor (int i = 0; i < K; i++) {\n\t\tpw[M - 1].x[i] = bin_pow(PP, MODS[i] - 2, MODS[i]);\n\t}\n\tfor (int i = M + 2; i < N; i++)\n\t\tpw[i] = pw[i - 1] * pw[M + 1];\n\tfor (int i = M - 2; i >= 0; i--)\n\t\tpw[i] = pw[i + 1] * pw[M - 1];\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tprecalc();\n\n\tscanf(\"%d %s\", &L, s);\n\tint pos = M;\n\ta[0] = 0;\n\tc[0] = pos;\n\tfor (int i = 0; i < L; i++) {\n\t\ta[i + 1] = a[i];\n\t\tif (s[i] == '+') {\n\t\t\ta[i + 1] = a[i + 1] + pw[pos];\n\t\t} else if (s[i] == '-') {\n\t\t\ta[i + 1] = a[i + 1] - pw[pos];\n\t\t} else if (s[i] == '>') {\n\t\t\tpos++;\n\t\t} else if (s[i] == '<') {\n\t\t\tpos--;\n\t\t} else throw;\n\t\tc[i + 1] = pos;\n\t}\n\tb[L] = 0;\n\tfor (int i = L - 1; i >= 0; i--) {\n\t\tb[i] = b[i + 1];\n\t\tif (s[i] == '+') {\n\t\t\tb[i] = b[i] + pw[pos];\n\t\t} else if (s[i] == '-') {\n\t\t\tb[i] = b[i] - pw[pos];\n\t\t} else if (s[i] == '>') {\n\t\t\tpos--;\n\t\t} else if (s[i] == '<') {\n\t\t\tpos++;\n\t\t} else throw;\n\t}\n\n\tPolyHash H = a[L];\n\n/*\n\tfor (int i = 0; i <= L; i++)\n\t\tprintf(\"%llu \", a[i]);\n\tprintf(\"\\n\");\n\tfor (int i = 0; i <= L; i++)\n\t\tprintf(\"%llu \", b[i]);\n\tprintf(\"\\n\");\n*/\n\tll ans = 0;\n\tfor (int i = L; i >= 0; i--) {\n\t\tPolyHash Z = H - H * pw[c[i]] - a[i];\n\t\tans += mapchik[Z];\n\t\tmapchik[b[i]]++;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define pb push_back\n#define all(v) v.begin(), v.end()\n#define sz(v) int(v.size())\n#define pii pair<int, int>\n#define mp make_pair\n#define f first\n#define ll long long\n#define s second\n#define vec vector<int>\n\nusing namespace std;\n\nconst int N = (int) 2e6 + 10;\nconst int K = (int) 1e7 + 10;\nconst int mod1 = (int) 1e9 + 7;\nconst int mod2 = (int) 1e9 + 9;\nconst int T = (int) 200017;\n\nint n;\nstring st;\npii p[N];\n\nvoid add(pii &x, pii y) {\n\t(x.f += y.f) %= mod1;\n\tif (x.f < 0) \n\t\tx.f += mod1;\n\t(x.s += y.s) %= mod2;\n\tif (x.s < 0)\n\t\tx.s += mod2;\n}\n\npii mult(pii x, pii y) {\n\treturn mp(x.f * 1ll * y.f % mod1, x.s * 1ll * y.s % mod2);\n}\n\npii hsh[N];\nint pos[N];\n\npair<pii, int> get(int l, int r) {\n\treturn mp(hsh[r + 1], pos[r + 1]);\n}\n\nint bp(int x, int mod) {\n\tint pw = mod - 2;\n\tint ans = 1;\n\twhile (pw) {\n\t\tif (pw & 1) \n\t\t\tans = (ans * 1ll * x) % mod;\n\t\tx = (x * 1ll * x) % mod;\n\t\tpw /= 2;\n\t}\n\treturn ans;\n}\n\npii inv(pii x) {\n\treturn mp(bp(x.f, mod1), bp(x.s, mod2));\n}\n\n// get(l,r)=(get(0,r)-get(0,l-1))<<pos(0, l-1)\n\npii shift(pii x, int val) { // to the right\n\tif (val > 0) {\n\t\tx = mult(x, p[val]);\n\t} else {\n\t\tx = mult(x, inv(p[-val]));\n\t}\n\treturn x;\n}\n\npii sum(pii x, pii y) {\n\tadd(x, y);\n\treturn x;\n}\n\nint main() {\n\t#ifdef sony\n\t\tfreopen(\"input.txt\", \"r\", stdin);\n\t\tfreopen(\"output.txt\", \"w\", stdout);\n\t#endif\n\tcin >> n >> st;\n\t//HASH(A) = {FOR I = [0...big_N] SUM OF A[I]*T^I % MODULO} WHERE T = PRIME > 2.5 * 10^5\n\tp[0] = mp(1, 1);\n\tfor (int i = 1; i < N; i++) {\n\t\tp[i] = mult(p[i - 1], mp(T, T));\n\t}\n\tpos[0] = 2 * n;\n\thsh[0] = mp(0, 0);\n\tvector<int> a(4 * n, 0);\n\tfor (int i = 0; i < n; i++) {\n\t\tpos[i + 1] = pos[i];\n\t\thsh[i + 1] = hsh[i];\n\t\tif (st[i] == '+') {\n\t\t\tadd(hsh[i + 1], p[pos[i + 1]]);\n\t\t} else if (st[i] == '-') {\n\t\t\tadd(hsh[i + 1], mp(-p[pos[i + 1]].f, -p[pos[i + 1]].s));\n\t\t} else if (st[i] == '>') {\n\t\t\tpos[i + 1]++;\n\t\t} else {\n\t\t\tpos[i + 1]--;\n\t\t}\n\t}\n\tpii x = get(0, n - 1).f;\n\tll ans = 0;\n\tmap<pii, int> cnt;\n\tfor (int i = 0; i < n; i++) {\n\t\tpii y = sum(shift(x, get(0, i - 1).s - 2 * n), shift(get(0, i - 1).f, 0));\n\t\tcnt[y]++;\n\t\tpii z = shift(get(0, i).f, 0);\n\t\tans += cnt[z];\n\t}\n\tcout << ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <map>\n#include <vector>\n\nconst int MOD = (int)1e9 + 9;\nconst int kN = 250000 + 5;\nusing LL = long long;\nint n;\nchar s[kN];\nstd::vector<int> primes{(int)1e9 + 7, (int)1e8 + 7, 233333, (int)1e6 + 7, 13};\n\nint inv(int x) {\n  return x == 1 ? 1 : (MOD - MOD / x) * 1LL * inv(MOD % x) % MOD;\n}\n\nLL solve() {\n  int seed = primes[rand() % primes.size()];\n  int inv_seed = inv(seed);\n  int a = 1, b = 0;\n  LL ret = 0;\n  std::map<int, int> map;\n  map[0] = 1;\n  int c = 0;\n  for (int i = n; i >= 1; -- i) {\n    char ch = s[i - 1];\n    if (ch == '+')\n      c = (c + 1) % MOD;\n    else if (ch == '-')\n      c = (c + MOD - 1) % MOD;\n    else if (ch == '>')\n      c = c * 1LL * seed % MOD;\n    else\n      c = c * 1LL * inv_seed % MOD;\n  }\n  for (int i = n; i >= 1; -- i) {\n    char ch = s[i - 1];\n    if (ch == '-')\n      b = (b + a) % MOD;\n    else if (ch == '+')\n      b = (b + MOD - a) % MOD;\n    else if (ch == '<')\n      a = a * 1LL * seed % MOD;\n    else\n      a = a * 1LL * inv_seed % MOD;\n    auto it = map.find((a * 1LL * c % MOD + b) % MOD);\n    if (it != map.end())\n      ret += it->second;\n    map[b] ++;\n  }\n  return ret;\n}\n\nint main() {\n  srand(time(NULL));\n  scanf(\"%d%s\", &n, s);\n  printf(\"%lld\\n\", solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define R return\n#define rep(i,s,t) for(int i=s;i<=(t);++i)\n#define dec(i,s,t) for(int i=s;i>=(t);--i)\nusing namespace std;\nconst int N=3e5+50,P=998244353,X=213,I=567077778;\nint mul(int a,int b){ R 1ll*a*b%P; }\nint add(int a,int b){ a+=b; R a>=P?a-P:a; }\nint sub(int a,int b){ a-=b; R a<0?a+P:a; }\nchar s[N]; long long ans; int n,A[N],B[N],u;\nint f(char c,int x){\n\tif(c=='+')R add(x,1); \n\tif(c=='-')R sub(x,1); \n\tif(c=='<')R mul(x,I);\n\tif(c=='>')R mul(x,X); \n\texit(-1);\n}\nvoid g(char c,int &a,int &b){\n\tif(c=='+')b=sub(b,a);\n\tif(c=='-')b=add(b,a);\n\tif(c=='<')a=mul(a,X);\n\tif(c=='>')a=mul(a,I); \n}\nint F(int a,int b,int x){ R add(mul(a,x),b); }\nmap<int,int> M;\nint main(){\n\tscanf(\"%d%s\",&n,s+1); \n\tdec(i,n,1)u=f(s[i],u); \n\tA[n+1]=1,B[n+1]=0; dec(i,n,1)g(s[i],A[i]=A[i+1],B[i]=B[i+1]); \n\t++M[F(A[n+1],B[n+1],0)]; dec(i,n,1)ans+=M[F(A[i],B[i],u)],++M[F(A[i],B[i],0)];\n\tprintf(\"%lld\\n\",ans);\n\tR 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2)\n#include<bits/stdc++.h>\n#define ll long long\n#define maxn 500005\n#define inf 1e9\n#define eps 1e-10\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,w=1; char c=getchar();\n\twhile(c<'0'||c>'9') {if(c=='-') w=-1; c=getchar();}\n\twhile(c<='9'&&c>='0') {x=(x<<1)+(x<<3)+c-'0'; c=getchar();}\n\treturn w==1?x:-x;\n}\n\nmap <ll,int> p;\nll b[maxn],inv[maxn],ans;\nint len,n;\nchar s[maxn];\nconst ll mod=998244353;\nconst ll P=844009174;\n\ninline ll pw(ll a,ll b)\n{\n\tll ans=1,base=a;\n\twhile(b)\n\t{\n\t\tif(b&1) ans=(ans*base)%mod;\n\t\tbase=(base*base)%mod; b>>=1;\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\t//freopen(\"t1.out\",\"w\",stdout);\n\tn=read(); scanf(\"%s\",s+1); b[0]=1; inv[0]=1; len=strlen(s+1);\n\tfor(int i=1;i<=maxn-5;i++) b[i]=(b[i-1]*233)%mod,inv[i]=pw(b[i],mod-2);\n\t//cout<<571216159*inv[1]%mod<<endl;\n\tll ed=0,nw=250000;\n\t\n\t//cout<<b[nw-1]+b[nw+1]<<endl;\n\t\n\tfor(int i=1;i<=len;i++)\n\t{\n\t\tif(s[i]=='+') ed=(ed+b[nw])%mod;\n\t\telse if(s[i]=='-') ed=(ed-b[nw])%mod;\n\t\telse if(s[i]=='>') nw++;\n\t\telse if(s[i]=='<') nw--; p[ed]++;\n\t\t//cout<<s[i]<<\" \"<<ed<<\" \"<<nw<<endl;\n\t}\n\t//cout<<ed<<\" \"<<nw<<endl<<endl;\n\tll tmp=0; nw=250000; ans=0;\n\tfor(int i=1;i<=len;i++)\n\t{\n\t\tll p2=ed;\n\t\tif(nw>=250000) p2=(p2*b[nw-250000])%mod;\n\t\telse p2=(p2*inv[250000-nw])%mod;\n\t\tans+=p[(tmp+p2)%mod];\n\t\t//ans+=p[(tmp+ed*b[nw])%mod];\n\t\tif(s[i]=='+') tmp=(tmp+b[nw])%mod;\n\t\telse if(s[i]=='-') tmp=(tmp-b[nw])%mod;\n\t\telse if(s[i]=='>') nw++;\n\t\telse if(s[i]=='<') nw--;\n\t\t//ans+=p[(tmp+ed*b[nw-250000])%mod];\n\t\t//cout<<(tmp+ed*b[nw-250000])%mod<<\" \"<<tmp<<\" \"<<nw<<\" \"<<ans<<endl;\n\t\tp[tmp]--;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcountll\n\n#define INF 1e16\n#define mod 1000000007\n\nll mod_pow(ll a,ll n){\n  ll res=1;\n  while(n>0){\n    if(n&1)res=res*a%mod;\n    a=a*a%mod;\n    n>>=1;\n  }\n  return res;\n}\n\nll N;\nstring S;\nconst ll K=6;\nll A[6][100010],B[6][100010];\nvector<ll> C[100010];\nmap<vector<ll>,ll> cnt;\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  vector<ll> xs{452,8112,5734,56343,8766754,64537};\n\n  cin>>N>>S;\n  ll res=0;\n  rep(k,K)A[k][N]=1;\n  rep(k,K)C[N].push_back(0);\n  for(ll j=N-1;j>=0;j--){\n    rep(i,K){\n      if(S[j]=='+'){\n        A[i][j]=A[i][j+1];\n        B[i][j]=(B[i][j+1]+1)%mod;\n      }else if(S[j]=='-'){\n        A[i][j]=A[i][j+1];\n        B[i][j]=(B[i][j+1]+mod-1)%mod;\n      }else if(S[j]=='>'){\n        A[i][j]=A[i][j+1]*mod_pow(xs[i],mod-2)%mod;\n        B[i][j]=B[i][j+1]*mod_pow(xs[i],mod-2)%mod;\n      }else if(S[j]=='<'){\n        A[i][j]=A[i][j+1]*xs[i]%mod;\n        B[i][j]=B[i][j+1]*xs[i]%mod;\n      }\n      C[j].push_back(B[i][j]*mod_pow(A[i][j],mod-2)%mod);\n    }\n  }\n\n  for(ll i=N;i>=0;i--){\n    vector<ll> nc;\n    rep(k,K){\n      nc.push_back(((B[k][i]-B[k][0]+mod)%mod)*mod_pow(A[k][i],mod-2)%mod);\n    }\n\n    res+=cnt[nc];\n    cnt[C[i]]++;\n  }\n\n  cout<<res<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long lint;\n\nlint modpow(lint x, lint y, lint mod) {\n  lint ret = 1 % mod, x2p = x;\n  while (y > 0) {\n    if (y % 2) ret = (__int128)ret * x2p % mod;\n    y /= 2;\n    x2p = (__int128)x2p * x2p % mod;\n  }\n  return ret;\n}\n\nconst lint mod_1 = 4511686018432017251LL, mod_2 = 4511686018432015967LL;\nconst lint base_1 = 549817, base_2 = 1006199503;\nconst lint inv_base_1 = modpow(base_1, mod_1 - 2, mod_1);\nconst lint inv_base_2 = modpow(base_2, mod_2 - 2, mod_2);\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  string seq(n, ' ');\n  for (int i = 0; i < n; ++i)\n    scanf(\" %c\", &seq[i]);\n\n  vector<int> pos_before(n);\n\n  //\n  vector<lint> base_pow_1(n + 1);\n  base_pow_1[0] = 1;\n  for (int i = 1; i <= n; ++i)\n    base_pow_1[i] = (__int128)base_1 * base_pow_1[i - 1] % mod_1;\n\n  vector<lint> inv_base_pow_1(n + 1);\n  inv_base_pow_1[0] = 1;\n  for (int i = 1; i <= n; ++i)\n    inv_base_pow_1[i] = (__int128)inv_base_1 * inv_base_pow_1[i - 1] % mod_1;\n\n  vector<lint> hash_diff_1(n, 0);\n  int pos = 0;\n  for (int i = 0; i < n; ++i) {\n    pos_before[i] = pos;\n    if (seq[i] == '>') ++pos;\n    else if (seq[i] == '<') --pos;\n    else {\n      lint base_pow_1_pos;\n      if (pos >= 0) base_pow_1_pos = base_pow_1[pos];\n      else base_pow_1_pos = inv_base_pow_1[-pos];\n      if (seq[i] == '+') hash_diff_1[i] = base_pow_1_pos;\n      else if (seq[i] == '-') hash_diff_1[i] = mod_1 - base_pow_1_pos;\n      else assert(0);\n    }\n  }\n  lint full_seq_hash_1 = 0;\n  for (int i = 0; i < n; ++i) {\n    full_seq_hash_1 += hash_diff_1[i];\n    if (full_seq_hash_1 >= mod_1) full_seq_hash_1 -= mod_1;\n  }\n\n  vector<lint> suffix_1(n + 1);\n  suffix_1[n] = 0;\n  for (int i = n - 1; i >= 0; --i) {\n    suffix_1[i] = hash_diff_1[i] + suffix_1[i + 1];\n    if (suffix_1[i] >= mod_1) suffix_1[i] -= mod_1;\n  }\n\n  //\n  vector<lint> base_pow_2(n + 1);\n  base_pow_2[0] = 1;\n  for (int i = 1; i <= n; ++i)\n    base_pow_2[i] = (__int128)base_2 * base_pow_2[i - 1] % mod_2;\n\n  vector<lint> inv_base_pow_2(n + 1);\n  inv_base_pow_2[0] = 1;\n  for (int i = 1; i <= n; ++i)\n    inv_base_pow_2[i] = (__int128)inv_base_2 * inv_base_pow_2[i - 1] % mod_2;\n\n  vector<lint> hash_diff_2(n, 0);\n  pos = 0;\n  for (int i = 0; i < n; ++i) {\n    if (seq[i] == '>') ++pos;\n    else if (seq[i] == '<') --pos;\n    else {\n      lint base_pow_2_pos;\n      if (pos >= 0) base_pow_2_pos = base_pow_2[pos];\n      else base_pow_2_pos = inv_base_pow_2[-pos];\n      if (seq[i] == '+') hash_diff_2[i] = base_pow_2_pos;\n      else if (seq[i] == '-') hash_diff_2[i] = mod_2 - base_pow_2_pos;\n      else assert(0);\n    }\n  }\n  lint full_seq_hash_2 = 0;\n  for (int i = 0; i < n; ++i) {\n    full_seq_hash_2 += hash_diff_2[i];\n    if (full_seq_hash_2 >= mod_2) full_seq_hash_2 -= mod_2;\n  }\n\n  vector<lint> suffix_2(n + 1);\n  suffix_2[n] = 0;\n  for (int i = n - 1; i >= 0; --i) {\n    suffix_2[i] = hash_diff_2[i] + suffix_2[i + 1];\n    if (suffix_2[i] >= mod_2) suffix_2[i] -= mod_2;\n  }\n  //\n\n  lint result = 0;\n  map<pair<lint, lint>, int> count;\n  count[{suffix_1[n], suffix_2[n]}] += 1;\n  for (int i = n - 1; i >= 0; --i) {\n    lint shifted_full_1, shifted_full_2;\n    if (pos_before[i] >= 0) {\n      shifted_full_1 = (__int128)full_seq_hash_1 * base_pow_1[pos_before[i]] % mod_1;\n      shifted_full_2 = (__int128)full_seq_hash_2 * base_pow_2[pos_before[i]] % mod_2;\n    } else {\n      shifted_full_1 = (__int128)full_seq_hash_1 * inv_base_pow_1[-pos_before[i]] % mod_1;\n      shifted_full_2 = (__int128)full_seq_hash_2 * inv_base_pow_2[-pos_before[i]] % mod_2;\n    }\n\n    lint target_1 = suffix_1[i] - shifted_full_1;\n    if (target_1 < 0) target_1 += mod_1;\n\n    lint target_2 = suffix_2[i] - shifted_full_2;\n    if (target_2 < 0) target_2 += mod_2;\n\n    auto it = count.find({target_1, target_2});\n    if (it != count.end())\n      result += it->second;\n\n    count[{suffix_1[i], suffix_2[i]}] += 1;\n  }\n  printf(\"%lld\\n\", result);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\ntemplate<unsigned P> struct ModInt {\n  using M = ModInt;\n  unsigned v;\n  ModInt() : v(0) {}\n  ModInt(auto x) : v(x >= 0 ? x % P : (P - -x % P) % P) {}\n  constexpr ModInt(unsigned v, int) : v(v) {}\n  static constexpr unsigned p() { return P; }\n  M operator+() const { return *this; }\n  M operator-() const { return {v ? P - v : 0, 0}; }\n  explicit operator bool() const noexcept { return v; }\n  bool operator!() const noexcept { return !(bool)*this; }\n  M operator*(M r) const { return M(*this) *= r; }\n  M operator/(M r) const { return M(*this) /= r; }\n  M operator+(M r) const { return M(*this) += r; }\n  M operator-(M r) const { return M(*this) -= r; }\n  bool operator==(M r) const { return v == r.v; }\n  bool operator!=(M r) const { return !(*this == r); }\n  M& operator*=(M r) { v = (uint64_t)v * r.v % P; return *this; }\n  M& operator/=(M r) { return *this *= r.inv(); }\n  M& operator+=(M r) { if ((v += r.v) >= P) v -= P; return *this; }\n  M& operator-=(M r) { if ((v += P - r.v) >= P) v -= P; return *this; }\n  M inv() const {\n    int a = v, b = P, x = 1, u = 0;\n    while (b) {\n      int q = a / b;\n      swap(a -= q * b, b);\n      swap(x -= q * u, u);\n    }\n    assert(a == 1);\n    return x;\n  }\n  M pow(auto n) const {\n    if (n < 0) return pow(-n).inv();\n    M res = 1;\n    for (M a = *this; n; a *= a, n >>= 1) if (n & 1) res *= a;\n    return res;\n  }\n  friend M operator*(auto l, M r) { return M(l) *= r; }\n  friend M operator/(auto l, M r) { return M(l) /= r; }\n  friend M operator+(auto l, M r) { return M(l) += r; }\n  friend M operator-(auto l, M r) { return M(l) -= r; }\n  friend ostream& operator<<(ostream& os, M r) { return os << r.v; }\n  friend istream& operator>>(istream& is, M& r) { lint x; is >> x; r = x; return is; }\n  friend bool operator==(auto l, M r) { return M(l) == r; }\n  friend bool operator!=(auto l, M r) { return !(l == r); }\n};\nusing M0 = ModInt<(unsigned)2e9 + 11>;\nusing M1 = ModInt<(unsigned)2e9 + 33>;\n\ntemplate<class Z> Z rng(Z a, Z b) {\n  static mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\n  return uniform_int_distribution<Z>(a, b - 1)(mt);\n}\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n; cin >> n;\n  string s; cin >> s;\n  M0 B0 = rng(1u, M0::p());\n  M1 B1 = rng(1u, M1::p());\n  V<M0> powB0{1};\n  V<M1> powB1{1};\n  for (int _ = 0; _ < 2 * n; ++_) {\n    powB0.push_back(powB0.back() * B0);\n    powB1.push_back(powB1.back() * B1);\n  }\n\n  map< pair<int, int>, int > mp;\n  int p = n;\n  V<M0> h0{0};\n  V<M1> h1{0};\n  for (int i = 0; i < n; ++i) {\n    h0.push_back(h0.back());\n    h1.push_back(h1.back());\n    if (s[i] == '>') ++p;\n    if (s[i] == '<') --p;\n    if (s[i] == '+') {\n      h0.back() += powB0[p];\n      h1.back() += powB1[p];\n    }\n    if (s[i] == '-') {\n      h0.back() -= powB0[p];\n      h1.back() -= powB1[p];\n    }\n    ++mp[{h0.back().v, h1.back().v}];\n  }\n\n  auto fn = [&](int i, int j) -> M0 {\n    M0 res;\n    int p = n;\n    for (int k = i; k <= j; ++k) {\n      if (s[k] == '>') ++p;\n      if (s[k] == '<') --p;\n      if (s[k] == '+') res += powB0[p];\n      if (s[k] == '-') res -= powB0[p];\n    }\n    return res;\n  };\n  for (int i = 0; i < n; ++i) for (int j = 0; j < n; ++j) {\n    // cout << setw(10) << fn(i, j) << \" \\n\"[!(n + ~j)];\n  }\n\n  lint res = 0;\n  for (int i = 0; i < n; ++i) {\n    M0 t0 = h0.back();\n    M1 t1 = h1.back();\n    for (int j = i - 1; j >= 0; --j) {\n      if (s[j] == '>') {\n        t0 *= B0;\n        t1 *= B1;\n      }\n      if (s[j] == '<') {\n        t0 /= B0;\n        t1 /= B1;\n      }\n      if (s[j] == '+') {\n        t0 += powB0[n];\n        t1 += powB1[n];\n      }\n      if (s[j] == '-') {\n        t0 -= powB0[n];\n        t1 -= powB1[n];\n      }\n    }\n    res += mp[{t0.v, t1.v}];\n    --mp[{h0[i + 1].v, h1[i + 1].v}];\n  }\n  cout << res << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define MAX 500012\n\nint n;\nchar buf[MAX];\n\n\nstring s;\n\n\n//#define MOD1 1000000007\n//#define MOD2 1000000009\n#define B 4\nvalarray<long long int> MOD1;\nvalarray<long long int> MOD2;\nvector<valarray<long long int> > p2;\nvector<valarray<long long int> > vv;\nvector<int> ps;\nmap<long long int, int> mp;\nlong long int ppow(long long int i, long long int j, long long int MOD) {\n\tlong long int ret = 1;\n\twhile (j) {\n\t\tif (j & 1LL)ret *= i;\n\t\tif (ret >= MOD)ret %= MOD;\n\t\tj >>= 1LL;\n\t}\n\treturn ret;\n}\n\nvalarray<long long int> calc(int dif) {\n\tvalarray<long long int> ret;\n\tret.resize(B, 0);\n\tfor (int j = 0; j < B; j++) {\n\t\tif (dif < 0) {\n\t\t\tret[j]=ppow(ppow(MOD1[j], abs(dif),MOD2[j]), MOD2[j] - 2,MOD2[j]);\n\t\t}\n\t\telse {\n\t\t\tret[j] = ppow(MOD1[j], abs(dif), MOD2[j]);\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main() {\n\tMOD1.resize(B);\n\tMOD2.resize(B);\n\tp2.push_back(valarray<long long int>());\n\tp2.back().resize(B, 1);\n\tMOD2[0] = 1000000007;\n\tMOD1[0] = 998244353;\n\tMOD1[2] = 1741231;\n\tMOD2[2] = 1000000009;\n\tMOD1[3] = 114514191;\n\tMOD2[3] = 1000000007;\n\tMOD1[1] = 555522277;\n\tMOD2[1] = 895612782;\n\tp2[0] %= MOD2;\n\tfor (int i = 1; i < MAX; i++) {\n\t\tp2.push_back(p2.back());\n\t\tp2[i] *= MOD1;\n\t\tp2[i] %= MOD2;\n\t}\n\tcin >> n;\n\tscanf(\"%s\", buf);\n\ts = buf;\n\tint pos = MAX/2;\n\tvalarray<long long int> hs;\n\ths.resize(B,0);\n\tvv.push_back(hs);\n\tps.push_back(pos);\n\tfor (int i = 0; i < s.size(); i++) {\n\t\tif (s[i] == '<') {\n\t\t\tpos--;\n\t\t}\n\t\tif (s[i] == '>') {\n\t\t\tpos++;\n\t\t}\n\t\tif (s[i] == '+') {\n\t\t\ths += p2[pos];\n\t\t}\n\t\tif (s[i] == '-') {\n\t\t\ths -= p2[pos];\n\t\t\ths += MOD2;\n\t\t}\n\t\ths %= MOD2;\n\t\tvv.push_back(hs);\n\t\tps.push_back(pos);\n\t}\n\tlong long int way = 0;\n\tfor (int i = vv.size() - 1; i >= 0; i--) {\n\t\tvalarray<long long int> want = vv[i] + vv.back()*calc(-MAX/2+ps[i]);\n\t\twant = want%MOD2;\n\t\tway += mp[want[0] *2000000000 + want[1]];\n\t\t//cerr << \"dbg \" << way << endl;\n\t\tmp[want[0] * 2000000000 + want[1]]++;\n\t}\n\tprintf(\"%lld\\n\", way);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//khodaya khodet komak kon\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define all(x) x.begin(), x.end()\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#define int long long\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int N = 500000 + 10;\nconst ll MOD = 1000000000 + 7;\nconst ll INF = 1000000010;\nconst ll LOG = 25;\nconst int H = 786433, H2 = 12582917;\n\nint a[2 * N], n, M, S, inv, Hash, Hash2, inv2, M2, S2;\nmap<pii, int> cnt;\nstring s;\n\nint mul(int a, int b){\n\treturn (a * 1ll * b) % MOD;\n}\n\nint add(int a, int b){\n\ta += b;\n\ta %= MOD;\n\ta += MOD;\n\ta %= MOD;\n\treturn a;\n}\n\nint minu(int a, int b){\n\ta -= b;\n\ta %= MOD;\n\ta += MOD;\n\ta %= MOD;\n\treturn a;\n}\n\nint POW(int a, int b){\n\tint res = 1;\n\twhile (b){\n\t\tif (b & 1) res = mul(res, a);\n\t\tb >>= 1;\n\t\ta = mul(a, a);\n\t}\n\treturn res;\n}\n\nint Solve(int x){\n\tint res = minu(x, S);\n\tres = mul(res, POW(M, MOD - 2));\n\treturn res;\n}\n\nint Solve2(int x){\n\tint res = minu(x, S2);\n\tres = mul(res, POW(M2, MOD - 2));\n\treturn res;\n}\n\nint32_t main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> n;\n\tcin >> s;\n\tint pnt = N;\n\tfor (int i = 1; i <= n; i++){\n\t\tif (s[i - 1] == '>') pnt++;\n\t\telse if(s[i - 1] == '<') pnt--;\n\t\telse if(s[i - 1] == '+') a[pnt]++;\n\t\telse a[pnt]--;\n\t}\n\tfor (int i = 2 * N - 1; i >= 0; i--){\n\t\ta[i] += N;\n\t\tS = add(mul(S, H), N);\n\t\tS2 = add(mul(S2, H2), N); \n\t\tHash = add(mul(Hash, H), a[i]);\t\n\t\tHash2 = add(mul(Hash2, H2), a[i]);\n\t}\n\tinv = POW(H, MOD - 2);\n\tinv2 = POW(H2, MOD - 2);\n\tM = 1;\n\tM2 = 1;\n\tint ans = 0;\n\tint SS = S, SS2 = S2;\n//\tcout << S << ' ' << minu(Hash, POW(H, N + 1)) << '\\n';\n\tfor (int i = n; i >= 1; i--){\n\t\tint now = 0, now2 = 0;\n\t\tif (s[i - 1] == '>'){\n\t\t\tM = mul(M, H);\n\t\t\tS = minu(S, mul(N, POW(H, 2 * N - 1)));\n\t\t\tS = mul(S, H);\n\t\t\tS = add(S, N);\n\t\t\tS2 = minu(S2, mul(N, POW(H2, 2 * N - 1)));\n\t\t\tM2 = mul(M2, H2);\n\t\t\tS2 = mul(S2, H2);\n\t\t\tS2 = add(S2, N);\n\t\t}else if(s[i - 1] == '<'){\n\t\t\tM = mul(M, inv);\n\t\t\tM2 = mul(M2, inv2);\n\t\t\tS = minu(S, N);\n\t\t\tS = mul(S, inv);\n\t\t\tS = add(S, mul(N, POW(H, 2 * N - 1)));\n\t\t\tS2 = minu(S2, N);\n\t\t\tS2 = mul(S2, inv2);\n\t\t\tS2 = add(S2, mul(N, POW(H2, 2 * N - 1)));\n\t\t}else if(s[i - 1] == '+'){\n\t\t\tS = add(S, POW(H, N));\n\t\t\tS2 = add(S2, POW(H2, N));\n\t\t\tnow = POW(H, N);\n\t\t\tnow2 = POW(H2, N);\n\t\t}else if(s[i - 1] == '-'){\n\t\t\tS = minu(S, POW(H, N));\n\t\t\tS2 = minu(S2, POW(H2, N));\n\t\t\tnow = minu(0, POW(H, N));\n\t\t\tnow2 = minu(0, POW(H2, N));\n\t\t}\n\t\tnow = add(now, SS);\n\t\tnow2 = add(now2, SS2);\n\t\tint xx = Solve2(now2);\n\t\tint x = Solve(now);\n\t\tcnt[{x, xx}]++;\n\t\tx = Solve(Hash);\n\t\txx = Solve2(Hash2);\n\t\tans = add(ans, cnt[{x, xx}]);\n\t}\n//\tcout << Hash << ' ' << S << '\\n';\n\tcout << ans;\n\n\n\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=1e9+7;\nint qpow(int x,int k)\n{\n    int r=1;\n    while(k)\n    {\n        if(k&1)r=1ll*r*x%mod;\n        k>>=1;x=1ll*x*x%mod;\n    }\n    return r;\n}\nint add(int x,int y){return x+y<mod?x+y:x+y-mod;}\nint n;\nchar s[300300];\n\n//int X[6] = {18, 40, 23, 2333333, 58, 720};\nint X[6]={233,1919,114514,817,1001,9527};\nint inv[6];\nstruct Node {\n    int v[6];\n    bool operator < (const Node &o)const{\n        for(int i=0;i<6;++i)\n            if(v[i]!=o.v[i])return v[i]<o.v[i];\n        return 0;\n    }\n    void clear(){memset(v,0,sizeof(v));}\n    void f(char c)\n    {\n        if(c=='+') for(int i=0;i<6;++i)v[i]=add(v[i],1);\n        else if(c=='-') for(int i=0;i<6;++i)v[i]=add(v[i],mod-1);\n        else if(c=='>') for(int i=0;i<6;++i)v[i]=1ll*v[i]*X[i]%mod;\n        else if(c=='<') for(int i=0;i<6;++i)v[i]=1ll*v[i]*inv[i]%mod;\n    }\n};\nmap<Node,int>mp;\nstruct PNN{\n    Node k,b;\n    void clear() { for(int i=0;i<6;++i)k.v[i]=1,b.v[i]=0; }\n    void f(char c)\n    {\n        if(c=='+')for(int i=0;i<6;++i)b.v[i]=add(b.v[i],mod-k.v[i]);\n        else if(c=='-')for(int i=0;i<6;++i)b.v[i]=add(b.v[i],k.v[i]);\n        else if(c=='>')for(int i=0;i<6;++i)k.v[i]=1ll*k.v[i]*inv[i]%mod;\n        else if(c=='<')for(int i=0;i<6;++i)k.v[i]=1ll*k.v[i]*X[i]%mod;\n    }\n    Node calc(Node x)\n    {\n        Node res;\n        for(int i=0;i<6;++i)\n            res.v[i]=add(1ll*k.v[i]*x.v[i]%mod,b.v[i])%mod;\n        return res;\n    }\n};\nint main()\n{\n    for(int i=0;i<6;++i)inv[i]=qpow(X[i],mod-2);\n    scanf(\"%d\",&n);\n    scanf(\"%s\",s+1);\n    Node C;C.clear();\n    for(int i=n;i;--i)C.f(s[i]);\n//    for(int i=0;i<6;++i)cout<<C.v[i]<<\" \";cout<<endl;\n    Node o;o.clear();\n    mp[o]++;\n    PNN cur;cur.clear();\n    long long ans=0;\n    for(int i=n;i;--i)\n    {\n        cur.f(s[i]);\n//        for(int j=0;j<6;++j)cout<<cur.k.v[j]<<\" \"<<cur.b.v[j]<<endl;cout<<endl;\n        Node tt=cur.calc(C);\n//        for(int j=0;j<6;++j)cout<<tt.v[j]<<\" \";cout<<endl;\n        ans+=mp[cur.calc(C)];\n        mp[cur.calc(o)]++;\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nchar s[250002];\nint num[8000000],sl[8000000],sr[8000000],nodes;\nint newnode()\n{\n    sl[nodes]=-1;\n    sr[nodes]=-1;\n    return nodes++;\n}\nvoid update(int &id,int il,int ir,int pos)\n{\n    if (id==-1)\n        id=newnode();\n    if (ir-il==1)\n    {\n        ++num[id];\n        return;\n    }\n    int mid=(il+ir)>>1;\n    if (pos<mid)\n        update(sl[id],il,mid,pos);\n    else\n        update(sr[id],mid,ir,pos);\n    ++num[id];\n}\nint query(int id,int il,int ir,int pos)\n{\n    if (id==-1)\n        return 0;\n    if (ir-il==1)\n        return num[id];\n    int mid=(il+ir)>>1;\n    return pos<mid?query(sl[id],il,mid,pos):query(sr[id],mid,ir,pos);\n}\nint pw[500001],prefix[250001],pos[250001];\nconst int MOD=1000000007;\nint qpow(int a,int b)\n{\n    int ret=1;\n    for (;b;a=(long long)a*a%MOD,b>>=1)\n        if (b&1)\n            ret=(long long)ret*a%MOD;\n    return ret;\n}\nint main()\n{\n    int n;\n    scanf(\"%d%s\",&n,s+1);\n    pw[0]=1;\n    for (int i=1;i<=500000;++i)\n        pw[i]=(long long)pw[i-1]*171%MOD;\n    pos[0]=0;\n    for (int i=1;i<=n;++i)\n    {\n        prefix[i]=prefix[i-1];\n        pos[i]=pos[i-1];\n        if (s[i]=='<')\n            --pos[i];\n        else if (s[i]=='>')\n            ++pos[i];\n        else if (s[i]=='+')\n        {\n            prefix[i]+=pw[pos[i]+250000];\n            if (prefix[i]>=MOD)\n                prefix[i]-=MOD;\n        }\n        else\n        {\n            prefix[i]-=pw[pos[i]+250000];\n            if (prefix[i]<0)\n                prefix[i]+=MOD;\n        }\n    }\n    int rt=-1;\n    long long ans=0;\n    for (int i=n;i>=1;--i)\n    {\n        int tmp=prefix[n];\n        tmp-=prefix[i];\n        if (tmp<0)\n            tmp+=MOD;\n        update(rt,0,1073741824,tmp);\n        tmp=prefix[n];\n        if (pos[i-1])\n            tmp=(long long)tmp*pw[pos[i-1]]%MOD;\n        else if (pos[i-1]<0)\n            tmp=(long long)tmp*qpow(pw[-pos[i-1]],MOD-2);\n        tmp=prefix[n]-tmp;\n        if (tmp<0)\n            tmp+=MOD;\n        tmp-=prefix[i-1];\n        if (tmp<0)\n            tmp+=MOD;\n        ans+=query(rt,0,1073741824,tmp);\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int WWW = 0;WWW < (n);WWW++)cerr << v[WWW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nconst ll mod1 = 1000000007;\nconst ll mod2 = 1000000009;\nconst ll seica1 = 114514;\nconst ll seica2 = 1919810;\n\n#define NODE 555555\npair<ll,ll> f[2][NODE];\nll mod[] = {1000000007,1000000009};\nll kake[] = {114514,1919810};\nint n;\nstring str;\nmap<pair<ll,ll>,ll> mp;\n\nll m_pow(ll a,ll b,ll p){\n\tll ret = 1;\n\tll tmp = a;\n\tfor(ll i = 0LL;i < 60;i++){\n\t\tif(b & (1LL < i)){\n\t\t\tret *= tmp;\n\t\t\tret %= p;\n\t\t}\n\t\ttmp *= tmp;\n\t\ttmp %= p;\n\t}\n}\n\nll m_inv(ll a,ll p){\n\treturn m_pow(a,p-2,p);\n}\n\nvoid get_f(int num,int type){\n\tpair<ll,ll> now = MP(1,0);\n\tpair<ll,ll> prev;\n\tif(num == n-1){\n\t\tprev = MP(0,0);\n\t}\n\telse{\n\t\tprev = f[type][num+1];\n\t}\n\t\n\tif(str[num] == '<'){\n\t\tnow.FI = kake[type];\n\t}\n\telse if(str[num] == '>'){\n\t\tnow.FI = m_inv(kake[type],mod[type]);\n\t}\n\telse if(str[num] == '+'){\n\t\tnow.SE--;\n\t}\n\telse{\n\t\tnow.SE++;\n\t}\n\t\n\tll fir = now.FI * prev.FI % mod[type];\n\tll sec = (now.SE * prev.FI % mod[type] + prev.SE) % mod[type];\n\tf[type][num] = MP(fir,sec);\n}\n\npair<ll,ll> dfs(int num,int type){\n\tpair<ll,ll> now = MP(1,0);\n\tpair<ll,ll> prev;\n\tif(num == n-1){\n\t\tprev = MP(0,0);\n\t}\n\telse{\n\t\tprev = dfs(num+1,type);\n\t}\n\t\n\tif(str[num] == '>'){\n\t\tnow.FI = kake[type];\n\t}\n\telse if(str[num] == '<'){\n\t\tnow.FI = m_inv(kake[type],mod[type]);\n\t}\n\telse if(str[num] == '-'){\n\t\tnow.SE--;\n\t}\n\telse{\n\t\tnow.SE++;\n\t}\n\t\n\tll fir = now.FI * prev.FI % mod[type];\n\tll sec = (now.SE * prev.FI % mod[type] + prev.SE) % mod[type];\n\treturn MP(fir,sec);\n}\n\nll get_x(ll x,ll num,ll type){\n\treturn (f[type][num].FI * x % mod[type] + f[type][num].SE) % mod[type];\n}\n\nint main(){\n\t\n\tcin >> n >> str;\n\tfor(int i = str.size()-1;i >= 0;i--){\n\t\tget_f(i,0);\n\t\tget_f(i,1);\n\t}\n\t\n\tll c[2] = {dfs(0,0).SE,dfs(0,1).SE};\n\t\n\tll ans = 0;\n\tfor(int i = str.size()-1;i >= 0;i--){\n\t\tans += mp[{get_x(c[0],i,0),get_x(c[1],i,1)}];\n\t\tmp[{get_x(0,i,0),get_x(0,i,1)}]++;\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<climits>\n#include<bitset>\n#include<map>\n#define pii pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define int long long\n#define mod1 998244353\n#define mod2 1000000007\nusing namespace std;\ninline int read(){\n    int f=1,ans=0;char c=getchar();\n    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}\n    while(c>='0'&&c<='9'){ans=ans*10+c-'0';c=getchar();}\n    return f*ans;\n}\nconst int MAXN=5e5+11;\nint N;char str[MAXN];\nint h1[MAXN],s1[MAXN],xx=101,res,h2[MAXN],s2[MAXN];\nint ksm1(int a,int b){\n    int ans=1;\n    while(b){if(b&1) ans*=a,ans%=mod1;a*=a,a%=mod1;b>>=1;}return ans;\n}\nint pw1(int a,int b){\n    if(b>=0) return ksm1(a,b);\n    int res=ksm1(a,-b);return ksm1(res,mod1-2);\n}\nint ksm2(int a,int b){\n    int ans=1;\n    while(b){if(b&1) ans*=a,ans%=mod2;a*=a,a%=mod2;b>>=1;}return ans;\n}\nint pw2(int a,int b){\n    if(b>=0) return ksm2(a,b);\n    int res=ksm2(a,-b);return ksm2(res,mod1-2);\n}\nmap<int,int> M[MAXN];\nsigned main(){\n    //freopen(\"1.in\",\"r\",stdin);\n    N=read();scanf(\"%s\",str+1);\n    for(int i=1;i<=N;i++){\n        if(str[i]=='+') h1[i]=h1[i-1]+pw1(xx,s1[i-1]),s1[i]=s1[i-1],h1[i]%=mod1;\n        if(str[i]=='-') h1[i]=h1[i-1]-pw1(xx,s1[i-1])+mod1,s1[i]=s1[i-1],h1[i]%=mod1;\n        if(str[i]=='>') h1[i]=h1[i-1],s1[i]=s1[i-1]+1;\n        if(str[i]=='<') h1[i]=h1[i-1],s1[i]=s1[i-1]-1;\n        if(str[i]=='+') h2[i]=h2[i-1]+pw2(xx,s2[i-1]),s2[i]=s2[i-1],h2[i]%=mod2;\n        if(str[i]=='-') h2[i]=h2[i-1]-pw2(xx,s2[i-1])+mod2,s2[i]=s2[i-1],h2[i]%=mod2;\n        if(str[i]=='>') h2[i]=h2[i-1],s2[i]=s2[i-1]+1;\n        if(str[i]=='<') h2[i]=h2[i-1],s2[i]=s2[i-1]-1;\n    }\n    //for(int i=1;i<=N;i++) printf(\"h:%lld s:%lld\\n\",h[i],s[i]);\n    for(int i=1;i<=N;i++)\n        for(int j=i;j<=N;j++){\n            if(((h1[i-1]+pw1(xx,s1[i-1])*h1[N])%mod1)==h1[j]&&((h2[i-1]+pw2(xx,s2[i-1])*h2[N])%mod2)==h2[j]){\n                res++;\n                //cerr<<i<<\" \"<<j<<endl;\n            }\n            //res+=(((h[i-1]+ksm(xx,s[i-1])*h[N])%mod)==h[j]);\n        }\n    printf(\"%lld\\n\",res);return 0;\n}/*\n  5\n  +>+<-\n  */\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n        using namespace std;\n         \n        #define MAX 600012\n         \n        int n;\n        char buf[MAX];\n        string s;\n        valarray<long long int> MOD1;\n        valarray<long long int> MOD2;\n        vector<valarray<long long int> > p2;\n        vector<valarray<long long int> > vv;\n        vector<int> ps;\n        map<pair<long long int,long long int>, int> mp;\n        long long int ppow(long long int i, long long int j, long long int MOD) {\n        \tlong long int ret = 1;\n        \twhile (j) {\n        \t\tif (j & 1LL)ret *= i;\n        \t\tif (ret >= MOD)ret %= MOD;\n        \t\tj >>= 1LL;\n        \t}\n        \treturn ret;\n        }\n         \n        valarray<long long int> calc(int dif) {\n        \tvalarray<long long int> ret;\n        \tret.resize(2, 0);\n        \tfor (int j = 0; j < 2; j++) {\n        \t\tif (dif < 0) {\n        \t\t\tret[j]=ppow(ppow(MOD1[j],MOD2[j]-2,MOD2[j]),-dif,MOD2[j]);\n        \t\t}\n        \t\telse {\n        \t\t\tret[j] = ppow(MOD1[j],dif, MOD2[j]);\n        \t\t}\n        \t}\n        \treturn ret;\n        }\n         \n        int main() {\n        \tMOD1.resize(2);\n        \tMOD2.resize(2);\n        \tp2.push_back(valarray<long long int>());\n        \tp2.back().resize(2);\n        \tp2.back()[0] = p2.back()[1] = 1;\n        \tMOD2[1] = 1000000007;\n        \tMOD1[0] = 555522277;\n        \tMOD1[1] = 895612782;\n        \tMOD2[0] = 998244353;\n        \tp2[0] %= MOD2;\n        \tfor (int i = 1; i < MAX; i++) p2.push_back((p2.back()*MOD1)%MOD2);\n        \tcin >> n;\n        \tscanf(\"%s\", buf);\n        \ts = buf;\n        \tint pos = MAX/2;\n        \tvalarray<long long int> hs;\n        \ths.resize(2,0);\n        \tvv.push_back(hs);\n        \tps.push_back(pos);\n        \tfor (int i = 0; i < s.size(); i++) {\n        \t\tif (s[i] == '<') pos--;\n        \t\telse if (s[i] == '>') pos++;\n        \t\telse if (s[i] == '+') hs += p2[pos];\n        \t\telse if (s[i] == '-') hs += MOD2-p2[pos];\n        \t\ths %= MOD2;\n        \t\tvv.push_back(hs);\n        \t\tps.push_back(pos);\n        \t}\n        \tlong long int way = 0;\n        \tfor (int i = vv.size() - 1; i >= 0; i--) {\n        \t\tvalarray<long long int> want = (vv[i] + ((vv.back()*calc(-MAX/2+ps[i]))%MOD2))%MOD2;\n        \t\tway += mp[make_pair(want[0], want[1])];\n        \t\tmp[make_pair(vv[i][0],vv[i][1])]++;\n        \t}\n        \tprintf(\"%lld\\n\", way);\n        \treturn 0;\n        }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int, int> ii;\n\nconst int mod1 = 1000000007;\nconst int mod2 = 1000000009; \nconst int arg1 = 1519153;\nconst int arg2 = 1057643;\nconst int Maxn = 250005;\n\nint iarg1, iarg2;\nint n;\nchar S[Maxn];\nii A[Maxn], B[Maxn];\nmap <ii, int> M;\nll res;\n\nint toPower(int a, int p, int mod)\n{\n\tint res = 1;\n\twhile (p) {\n\t\tif (p & 1) res = ll(res) * a % mod;\n\t\tp >>= 1; a = ll(a) * a % mod;\n\t}\n\treturn res;\n}\n\nint Inv(int a, int mod) { return toPower(a, mod - 2, mod); }\n\nint main()\n{\n\tiarg1 = Inv(arg1, mod1);\n\tiarg2 = Inv(arg2, mod2);\n\tscanf(\"%d\", &n);\n\tscanf(\"%s\", S + 1);\n\tA[0] = ii(1, 1); B[0] = ii(0, 0);\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (S[i] == '+') { A[i] = ii(1, 1); B[i] = ii(1, 1); }\n\t\telse if (S[i] == '-') { A[i] = ii(1, 1); B[i] = ii(mod1 - 1, mod2 - 1); }\n\t\telse if (S[i] == '>') { A[i] = ii(arg1, arg2); B[i] = ii(0, 0); }\n\t\telse if (S[i] == '<') { A[i] = ii(iarg1, iarg2); B[i] = ii(0, 0); }\n\t\tB[i].first = (ll(B[i - 1].first) * A[i].first + ll(B[i].first)) % mod1;\n\t\tB[i].second = (ll(B[i - 1].second) * A[i].second + ll(B[i].second)) % mod2;\n\t\tA[i].first = ll(A[i - 1].first) * A[i].first % mod1;\n\t\tA[i].second = ll(A[i - 1].second) * A[i].second % mod2;\n\t}\n\tii X;\n\tX.first = ll(B[n].first) * Inv(A[n].first, mod1) % mod1;\n\tX.second = ll(B[n].second) * Inv(A[n].second, mod2) % mod2;\n\tM[X]++;\n\tfor (int i = 1; i <= n; i++) {\n\t\tii ainv = ii(Inv(A[i].first, mod1), Inv(A[i].second, mod2));\n\t\tii need;\n\t\tneed.first = ll(B[i].first) * ainv.first % mod1;\n\t\tneed.second = ll(B[i].second) * ainv.second % mod2;\n\t\tauto it = M.find(need);\n\t\tif (it != M.end()) res += it->second;\n\t\tM[ii(ll(X.first + B[i].first) * ainv.first % mod1, ll(X.second + B[i].second) * ainv.second % mod2)]++;\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,ans;\nunsigned long long x1=1,x2=521,xx=521,a[250010],b[250010],t[250010];\nstring st;\nmap<unsigned long long,int>k;\nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<=63;i++)\n\t{\n\t\tx1=x1*x2;\n\t\tx2=x2*x2;\n\t}\n\tcin>>st;\n\tst=' '+st;\n\tb[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\ta[i]=a[i-1];\n\t\tb[i]=b[i-1];\n\t\tif(st[i]=='+')a[i]=a[i]+b[i];\n\t\tif(st[i]=='-')a[i]=a[i]-b[i];\n\t\tif(st[i]=='<')b[i]=b[i]*x1;\n\t\tif(st[i]=='>')b[i]=b[i]*xx;\n\t\tk[a[i]]++;\n\t} \n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tans+=k[a[n]*b[i-1]+a[i-1]];\n\t\tk[a[i]]--;\n\t}\n\tcout<<ans;\n\treturn 0; \n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ri register int\ntypedef long long ll;\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char y) {\n\t\t*oS ++ = y;\n\t\tif (oS == oT) flush ();\n\t}\n\t// input a signed integer\n\ttemplate <class I>\n\tinline void gi (I &y) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (y = 0; c <= '9' && c >= '0'; c = gc()) y = (y << 1) + (y << 3) + (c & 15); y *= f;\n\t}\n\t// print a signed integer\n\ttemplate <class I>\n\tinline void print (I y) {\n\t\tif (!y) putc ('0'); if (y < 0) putc ('-'), y = -y;\n\t\twhile (y) qu[++ qr] = y % 10 + '0',  y /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t}\n\t// no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n} \nusing io :: gi;\nusing io :: putc;\nusing io :: print;\nconst int N=25e4+5,mod=1e9+7;\nchar s[N];\nint x[6],power[6][N],xinv[6],powerinv[6][N];\ninline void add(int &x,ri y){\n\tx=(x+=y)>=mod?x-mod:x;\n}\ninline void del(int &x,ri y){\n\tx=(x-=y)<0?x+mod:x;\n}\nstruct node{\n\tint y[6];\n\tinline bool operator <(const node &rhs)const{\n\t\tfor(ri i=0;i^6;++i)\n\t\t\tif(y[i]!=rhs.y[i])\n\t\t\t\treturn y[i]<rhs.y[i];\n\t\treturn 0;\n\t}\n\tinline void upd(ri p,ri k){\n\t\tri i;\n\t\tif(p>=0){\n\t\t\tif(k==1){\n\t\t\t\tfor(i=0;i^6;++i)\n\t\t\t\t\tadd(y[i],power[i][p]);\n\t\t\t} \n\t\t\telse{\n\t\t\t\tfor(i=0;i^6;++i)\n\t\t\t\t\tdel(y[i],power[i][p]);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(k==1){\n\t\t\t\tfor(i=0;i^6;++i)\n\t\t\t\t\tadd(y[i],powerinv[i][-p]);\n\t\t\t} \n\t\t\telse{\n\t\t\t\tfor(i=0;i^6;++i)\n\t\t\t\t\tdel(y[i],powerinv[i][-p]);\n\t\t\t}\n\t\t}\n\t}\n}res,res0,now;\nstruct orz{\n\tint k,b;\n\tinline void operator +=(const int &rhs){\n\t\tadd(b,1);\n\t}\n\tinline void operator -=(const int &rhs){\n\t\tdel(b,1);\n\t}\n\tinline void operator *=(const int &rhs){\n\t\tk=(ll)k*rhs%mod;\n\t\tb=(ll)b*rhs%mod;\n\t}\n};\nstruct poly{\n\torz f[6];\n\tinline void upd1(){\n\t\tfor(ri i=0;i^6;++i)\n\t\t\tf[i]-=1;\n\t}\n\tinline void upd2(){\n\t\tfor(ri i=0;i^6;++i)\n\t\t\tf[i]+=1;\n\t}\n\tinline void upd3(){\n\t\tfor(ri i=0;i^6;++i)\n\t\t\tf[i]*=xinv[i];\n\t}\n\tinline void upd4(){\n\t\tfor(ri i=0;i^6;++i)\n\t\t\tf[i]*=x[i];\n\t}\n}resinv;\nmap<node,int> G;\ninline int fpow(ri a,ri b){\n\tri ans=1;\n\tfor(;b;b>>=1,a=(ll)a*a%mod)\n\t\tif(b&1) ans=(ll)ans*a%mod;\n\treturn ans;\n}\nint main(){\n//\tsrand(size_t(new char));\n\tri n,i,j,nowp,ans;\n\tscanf(\"%d%s\",&n,s+1);\n\tfor(i=0;i^6;++i){\n\t//\tx[i]=rand()*rand()%(mod-1)+1;\n\t\tx[i]=1;\n\t\tpower[i][0]=1;\n\t\tfor(j=1;j<=n;++j)\n\t\t\tpower[i][j]=(ll)power[i][j-1]*x[i]%mod;\n\t\txinv[i]=fpow(x[i],mod-2);\n\t\tpowerinv[i][0]=1;\n\t\tfor(j=1;j<=n;++j)\n\t\t\tpowerinv[i][j]=(ll)powerinv[i][j-1]*xinv[i]%mod;\n\t}\n\tnowp=0;\n\tfor(i=1;i<=n;++i)\n\t\tif(s[i]=='+')\n\t\t\tres0.upd(nowp,1);\n\t\telse if(s[i]=='-')\n\t\t\tres0.upd(nowp,-1);\n\t\telse if(s[i]=='>')\n\t\t\t++nowp;\n\t\telse\n\t\t\t--nowp;\n\tnowp=0;\n\tans=0;\n\tfor(i=0;i^6;++i) resinv.f[i].k=1;\n\t++G[res0];\n\tfor(i=1;i<=n;++i){\n\t\tif(s[i]=='+')\n\t\t\tres.upd(nowp,1),\n\t\t\tresinv.upd1();\n\t\telse if(s[i]=='-')\n\t\t\tres.upd(nowp,-1),\n\t\t\tresinv.upd2();\n\t\telse if(s[i]=='>')\n\t\t\t++nowp,\n\t\t\tresinv.upd3();\n\t\telse\n\t\t\t--nowp,\n\t\t\tresinv.upd4();\n\t\tans+=G[res];\n\t\tfor(j=0;j^6;++j)\n\t\t\tnow.y[j]=(ll)(res0.y[j]-resinv.f[j].b+mod)*fpow(resinv.f[j].k,mod-2)%mod;\n\t\t++G[now];\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\nusing namespace std;\ntypedef unsigned long long ULL;\nconst int N=500010;\nconst ULL MOD=1000000000000000031ull,B=1000000000000000003ull,REVB=821428571428571454ull;\nint n;\nchar str[N];\nULL f[N],p[N];\nULL mul(ULL x,ULL y){\n\treturn (ULL)((__int128)x*y%MOD);\n}\nvoid readData(){\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",str+1);\n}\nmap<ULL,int> mp;\nvoid solve(){\n\tp[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tf[i]=f[i-1];\n\t\tp[i]=p[i-1];\n\t\tif(str[i]=='<')\n\t\t\tp[i]=mul(p[i],B);\n\t\telse if(str[i]=='>')\n\t\t\tp[i]=mul(p[i],REVB);\n\t\telse if(str[i]=='+')\n\t\t\t(f[i]+=p[i])%=MOD;\n\t\telse\n\t\t\t(f[i]-=p[i])%=MOD;\n\t}\n\tULL ans=0;\n\tfor(int i=n;i>=1;i--){\n\t\tmp[f[i]]++;\n\t\tans+=mp[(mul(f[n],p[i-1])+f[i-1])%MOD];\n\t}\n\tprintf(\"%llu\\n\",ans);\n}\nint main(){\n\treadData();\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo1 1019260817\n#define mo2 1009260817\ntypedef long long ll;\nll gi(){\n\tll x=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch))f^=ch=='-',ch=getchar();\n\twhile(isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\treturn f?x:-x;\n}\nint pow(int x,int y,int mo){\n\tint ret=1;\n\twhile(y){\n\t\tif(y&1)ret=1ll*ret*x%mo;\n\t\tx=1ll*x*x%mo;y>>=1;\n\t}\n\treturn ret;\n}\nchar S[250010];\nint bs1=19260817,ibs1=966804715,bs2=19491001,ibs2=251190511;\nstd::unordered_map<ll,int>M;\nint main(){\n#ifdef XZZSB\n\tfreopen(\"in.in\",\"r\",stdin);\n\tfreopen(\"out.out\",\"w\",stdout);\n#endif\n\tint n=gi();scanf(\"%s\",S+1);\n\tint p1=1,p2=1,x1=0,x2=0;\n\tfor(int i=1;i<=n;++i){\n\t\tif(S[i]=='+'||S[i]=='-'){\n\t\t\tif(S[i]=='+')x1=(x1+p1)%mo1,x2=(x2+p2)%mo2;\n\t\t\telse x1=(x1+mo1-p1)%mo1,x2=(x2+mo2-p2)%mo2;\n\t\t}else{\n\t\t\tif(S[i]=='<')p1=1ll*p1*bs1%mo1,p2=1ll*p2*bs2%mo2;\n\t\t\telse p1=1ll*p1*ibs1%mo1,p2=1ll*p2*ibs2%mo2;\n\t\t}\n\t}\n\tint X1=x1,X2=x2;x1=x2=0;ll ans=0;\n\tfor(int i=1;i<=n;++i){\n\t\tint y1=(x1+1ll*X1*p1)%mo1,y2=(x2+1ll*X2*p2)%mo2;\n\t\t++M[(1ll*y1<<32)|y2];\n\t\tif(S[i]=='+'||S[i]=='-'){\n\t\t\tif(S[i]=='+')x1=(x1+p1)%mo1,x2=(x2+p2)%mo2;\n\t\t\telse x1=(x1+mo1-p1)%mo1,x2=(x2+mo2-p2)%mo2;\n\t\t}else{\n\t\t\tif(S[i]=='<')p1=1ll*p1*bs1%mo1,p2=1ll*p2*bs2%mo2;\n\t\t\telse p1=1ll*p1*ibs1%mo1,p2=1ll*p2*ibs2%mo2;\n\t\t}\n\t\tans+=M[(1ll*x1<<32)|x2];\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\n\nint N;\nstring S;\nll mo=1000000007;\nvector<ll> C,R;\nconst int PAT=5;\nvector<ll> A[PAT];\nvector<ll> B[PAT];\n\nll modpow(ll a, ll n = mo-2) {\n\tll r=1;a%=mo;\n\twhile(n) r=r*((n%2)?a:1)%mo,a=a*a%mo,n>>=1;\n\treturn r;\n}\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>S;\n\tsrand(time(NULL));\n\tFOR(i,PAT) {\n\t\tC.push_back(rand()%10000000+10000000);\n\t\tR.push_back(modpow(C.back()));\n\t\tA[i].push_back(1);\n\t\tB[i].push_back(0);\n\t}\n\treverse(ALL(S));\n\tFORR(c,S) {\n\t\tFOR(i,PAT) {\n\t\t\tif(c=='+') {\n\t\t\t\tA[i].push_back(A[i].back());\n\t\t\t\tB[i].push_back((B[i].back()+1)%mo);\n\t\t\t}\n\t\t\tif(c=='-') {\n\t\t\t\tA[i].push_back(A[i].back());\n\t\t\t\tB[i].push_back((B[i].back()+mo-1)%mo);\n\t\t\t}\n\t\t\tif(c=='>') {\n\t\t\t\tA[i].push_back(A[i].back()*C[i]%mo);\n\t\t\t\tB[i].push_back(B[i].back()*R[i]%mo);\n\t\t\t}\n\t\t\tif(c=='<') {\n\t\t\t\tA[i].push_back(A[i].back()*R[i]%mo);\n\t\t\t\tB[i].push_back(B[i].back()*C[i]%mo);\n\t\t\t}\n\t\t}\n\t}\n\tll ret=0;\n\tmap<vector<ll>,int> memo;\n\tmemo[vector<ll>(PAT,0)]++;\n\tFOR(j,N) {\n\t\tvector<ll> BA(PAT),BAS(PAT);\n\t\tFOR(i,PAT) {\n\t\t\tBA[i]=B[i][j+1]*A[i][j+1]%mo;\n\t\t\tBAS[i]=(B[i][j+1]+mo-B[i].back())*A[i][j+1]%mo;\n\t\t}\n\t\tret+=memo[BAS];\n\t\tmemo[BA]++;\n\t}\n\tcout<<ret<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<bitset>\nusing namespace std;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\nconst llint mod=998244353;\nconst llint big=2.19e18+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-15;\ntemplate <class T,class U>void mineq(T& a,U b){if(a>b){a=b;}}\ntemplate <class T,class U>void maxeq(T& a,U b){if(a<b){a=b;}}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint i,n;cin>>n;\n\tllint ans=0;\n\tstring str;cin>>str;\n\t/*\n\tローリングハッシュ\n\t+ ha+=P\n\t- hs-=P\n\t> P*=100;\n\t< P/=100;\n\t*/\n\tllint gya=1,bb=100;\n\tfor(int h=0;h<30;h++){\n\t\tif((mod-2)&(1<<h)){gya*=bb;gya%=mod;}\n\t\tbb*=bb;bb%=mod;\n\t}\n\tvector<llint>c(n+1);\n\tllint cp=1;\n\tfor(i=0;i<n;i++){\n\t\tif(str[i]=='>'){cp*=100;cp%=mod;}\n\t\tif(str[i]=='<'){cp*=gya;cp%=mod;}\n\t\tif(str[i]=='+'){c[i]=cp;}\n\t\tif(str[i]=='-'){c[i]=mod-cp;}\n\t}\n\tfor(i=n-1;i>=0;i--){c[i]+=c[i+1];c[i]%=mod;}\n\tmap<llint,int>ma;\n\tfor(i=0;i<=n;i++){ma[c[i]]++;}\n\tllint ap=1,ah=0;\n\tllint S=c[0];//全体のローリングハッシュ\n\tfor(i=0;i<n;i++){\n\t\tma[c[i]]--;\n\t\tllint ter=(S-ah-ap*S)%mod;\n\t\tif(ter<0){ter+=mod;}\n\t\tans+=ma[ter];\n\t\t//cerr<<ma[ter]<<endl;\n\t\tif(str[i]=='>'){ap*=100;ap%=mod;}\n\t\tif(str[i]=='<'){ap*=gya;ap%=mod;}\n\t\tif(str[i]=='+'){ah+=ap;ah%=mod;}\n\t\tif(str[i]=='-'){ah+=mod-ap;ah%=mod;}\n\t\t//pqc=s-a-ps;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define y1 dmytxdy\n#define fi first\n#define se second\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef long double ld;\n\ntemplate <typename T> bool chkmin(T &x,T y){return x>y?x=y,1:0;}\ntemplate <typename T> bool chkmax(T &x,T y){return x<y?x=y,1:0;}\n\nint readint(){\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nconst int cys=1000000007,N=50;\nint n;\nll a[250005],b[250005],pw[250005],ipw[250005],ans[250005];\nunordered_map<ll,ll> bk;\nchar s[250005];\n\nll mod(ll x){return x>=cys?x-cys:x;}\n\nll qpow(ll x,ll p){\n\tll ret=1;\n\tfor(;p;p>>=1,x=x*x%cys) if(p&1) ret=ret*x%cys;\n\treturn ret;\n}\n\nint main(){\n\tn=readint();\n\tscanf(\"%s\",s+1);\n\tfor(int i=1;i<=n;i++) b[i]=b[i-1]+(s[i]=='>')-(s[i]=='<');\n\tmemset(ans,0x3f,sizeof(ans));\n\tfor(int ct=1;ct<=N;ct++){\n\t\tll ax=(1ll*rand()*RAND_MAX+rand())%cys,bx=qpow(ax,cys-2),p=1,now=0;\n\t\tpw[0]=ipw[0]=1;\n\t\tfor(int i=1;i<=n;i++) pw[i]=pw[i-1]*ax%cys;\n\t\tfor(int i=1;i<=n;i++) ipw[i]=ipw[i-1]*bx%cys;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(s[i]=='+') now=mod(now+p);\n\t\t\telse if(s[i]=='-') now=mod(now+cys-p);\n\t\t\telse if(s[i]=='<') p=p*bx%cys;\n\t\t\telse if(s[i]=='>') p=p*ax%cys;\n\t\t}\n\t\ta[n+1]=0;\n\t\tfor(int i=n;i>=1;i--){\n\t\t\tif(s[i]=='+') a[i]=mod(a[i+1]+1);\n\t\t\telse if(s[i]=='-') a[i]=mod(a[i+1]+cys-1);\n\t\t\telse if(s[i]=='<') a[i]=a[i+1]*bx%cys;\n\t\t\telse if(s[i]=='>') a[i]=a[i+1]*ax%cys;\n\t\t}\n\t\tfor(int i=1;i<=n;i++) a[i]=a[i]*(b[i-1]>0?pw[b[i-1]]:ipw[-b[i-1]])%cys;\n\t\tbk.clear();\n\t\tbk[0]++;\n\t\tfor(int i=n;i>=1;i--){\n\t\t\tchkmin(ans[i],bk[mod(a[i]+cys-now*(b[i-1]>0?pw[b[i-1]]:ipw[-b[i-1]])%cys)]);\n\t\t\tbk[a[i]]++;\n\t\t}\n\t\tif(1.0*clock()/CLOCKS_PER_SEC>1.9) break;\n\t}\n\tll res=0;\n\tfor(int i=1;i<=n;i++) res+=ans[i];\n\tprintf(\"%lld\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll=long long;\n\nconst ll R = 843823891, iR = 1040004855;\nconst ll M = 1637348371;\nll mpow(ll x, int64_t e) {\n    ll res = 1;\n    for (; e; e >>= 1) {\n        if (e & 1) res *= x, res %= M;\n        x *= x, x %= M;\n    }\n    return res;\n}\nll minv(ll x) {\n    return mpow(x, M-2);\n}\nstruct Lm {\n    ll k,b;\n    Lm() {}\n    Lm(ll _k,ll _b): k(_k),b(_b){}\n    Lm(char x) {\n        if (x == '+') k = 1, b = 1;\n        if (x == '-') k = 1, b = M-1;\n        if (x == '>') k = R, b = 0;\n        if (x == '<') k = iR,b = 0;\n    }\n    Lm(const Lm& _lm): k(_lm.k), b(_lm.b){}\n    Lm& operator*=(const Lm& _lm){\n        b += k*_lm.b; b %= M;\n        k *= _lm.k; k %= M;\n        return *this;\n    }\n    Lm inv(){\n        ll ik = minv(k);\n        ll ib = -ik*b; ib %= M; (ib+=M)%=M;\n        return {ik,ib};\n    }\n    ll eval(ll x) {\n        return (k*x+b)%M;\n    }\n};\nLm operator*(const Lm& _a, const Lm& _b) {\n    return Lm(_a) *= _b;\n}\n\nvoid solve() {\n    int n; cin >> n;\n    string s; cin >> s;\n    vector<Lm> a, ia(n);\n    for (int i = 0; i < n; i++) {\n        a.emplace_back(s[i]);\n        ia[i] = a[i].inv();\n    }\n    auto isuf = ia;\n    for (int i = n-2; i >= 0; i--) {\n        isuf[i] = isuf[i+1] * isuf[i];\n    }\n    ll c = isuf[0].inv().eval(0);\n    vector<ll> z(n+1), g(n); z[n] = 0;\n    for (int i = 0; i < n; i++) {\n        z[i] = isuf[i].eval(0);\n        g[i] = isuf[i].eval(c);\n    }\n    map<ll, int> cnt;\n    ll res = 0;\n    for (int i = 0; i < n; i++) {\n        cnt[g[i]]++;\n        res += cnt[z[i+1]];\n    }\n    cout << res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    solve();\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef unsigned long long ull;\nconst ull M=998244353;\nconst ull N=1000000007; \nconst ull X=99431;\nconst ull Y=99487;\null R;\null L;\nconst int W=1000;\n \n \null ModPow(ull x, ull n, ull mod) {\n        ull ret = 1;\n        for (; n > 0; n /= 2, x = (x * x) % mod)\n            if ((n & 1) == 1) ret = (ret * x) % mod;\n        return ret;\n    }\n \null has=0,vec=1;\null has2=0,vec2=1;\n \nint n;\nstring s;\nunordered_map<ull,int> B[550];\nlong long ans;\ninline void calc(char c, ull &u,ull &p,ull &v,ull &q){\n\tif(c=='+'){u+=p;v+=q;}\n\telse if(c=='-'){u+=M-p;v+=N-q;}\n\telse if(c=='>'){p=(p*X)%M;q=(q*Y)%N;}\n\telse {p=(p*R)%M;q=(q*L)%N;}\n\tif(u>=M)u-=M;\n\tif(v>=N)v-=N;\n}\nint main(){\n\tR=ModPow(X,M-2,M);\n\tL=ModPow(Y,N-2,N);\n\tcin>>n>>s;\n    //n=250000;\n    //s=string(n,'+');\n\tfor(int i=0;i<n;i++)calc(s[i],has,vec,has2,vec2);\n\tfor(int i=0;i<n;i++){\n\t\tif(i%W==0)continue;\n\t\tull h=0,x=1,hh=0,y=1;\n\t\tfor(int j=i;j<n;j++){\n\t\t\tif(j%W==0)break;\n\t\t\tcalc(s[j],h,x,hh,y);\n\t\t\tif(h==has&&hh==has2)ans++;\n\t\t}\n\t\tull nh = (has+M-h)%M;\n\t\tnh = nh * ModPow(x,M-2,M)%M;\n\t\tull nh2 = (has2+N-hh)%N;\n\t\tnh2 = nh2 * ModPow(y,N-2,N)%N;\n\t\tB[i/W+1][nh*N+nh2]++;\n\t}\n\tfor(int i=0;i<n;i+=W){\n\t\tull h=0,x=1,hh=0,y=1;\n\t\tfor(int j=i;j<n;j++){\n\t\t\tcalc(s[j],h,x,hh,y);\n\t\t\tif(h==has&&hh==has2)ans++;\n\t\t\tauto it = B[i/W].find(h*N+hh);\n\t\t\tif(it!=B[i/W].end())ans+=it->second;\n\t\t}\n\t}\n\t\n\tcout<<ans;\n \n \n}"
  },
  {
    "language": "C++",
    "code": "//jinhaonan\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\ntemplate<class T>inline void read(T &x){\n\tx=0;char c=getchar();bool f=0;\n\tfor(;c>'9'||c<'0';f=c=='-',c=getchar());\n\tfor(;c>='0'&&c<='9';x=(x<<1)+(x<<3)+c-'0',c=getchar());\n\tx=f?-x:x;\n}\ntemplate<class T>inline void write(T x){\n\tif(x<0)putchar('-'),x=-x;\n\tif(x>=10)write(x/10);\n\tputchar(x%10+48);\n}\ntemplate<class T>inline bool chkmax(T &a,T const &b){\n\treturn a<b?a=b,1:0;\n}\ntemplate<class T>inline bool chkmin(T &a,T const &b){\n\treturn a>b?a=b,1:0;\n} \nlong long base=9901;\nlong long mo=1000000000000000031ll;\n \nlong long Mul(long long a,long long b){\n\treturn (__int128)a*b%mo;\n}\nlong long Add(long long a,long long b){\n\treturn (a+b)%mo;\n}\nlong long Pow(__int128 a,long long b){\n\t__int128 res=1;\n\tfor(;b;b>>=1,a=a*a%mo)\n\t\tif(b&1)\n\t\t\tres=res*a%mo;\n\treturn res;\n}\nvector<pair<long long,long long>> v;\nmap<long long,int> mp;\nint main(){\n\tstatic char s[250000+10];\n\tint n;\n\tscanf(\"%d%s\",&n,s);\n\tlong long inv=Pow(base,mo-2);\n\tlong long pos=1,val=0;\n\tv.push_back(make_pair(val,pos));\n\tfor(int i=0;i<n;++i){\n\t\tif(s[i]=='<'){\n\t\t\tpos=Mul(pos,inv);\n\t\t}else if(s[i]=='>'){\n\t\t\tpos=Mul(pos,base);\n\t\t}else if(s[i]=='+'){\n\t\t\tval=Add(val,pos);\n\t\t}else if(s[i]=='-'){\n\t\t\tval=Add(val,mo-pos);\n\t\t}\n\t\tv.push_back(make_pair(val,pos));\n\t}\n\tlong long V=v.back().first;\n\tlong long ans=0;\n\tfor(int i=v.size()-1;i>=0;--i){\n\t\tauto it=mp.find(Add(v[i].first,Mul(V,v[i].second)));\n\t\tif(it!=mp.end()){\n\t\t\tans+=it->second;\n\t\t}\n\t\t++mp[v[i].first];\n\t}\n\twrite(ans),putchar('\\n');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Author:xht37\n#include <bits/stdc++.h>\n\n#define ui unsigned int\n#define ll long long\n#define ul unsigned ll\n#define ld long double\n\n#define pi pair <int, int>\n#define fi first\n#define se second\n#define mp make_pair\n\n#define ls (p << 1)\n#define rs (ls | 1)\n#define md ((t[p].l + t[p].r) >> 1)\n\n#define vi vector <int>\n#define pb push_back\n#define pq priority_queue\n\n#define dbg(x) cerr << #x\" = \" << x << endl\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#define fl(x) freopen(x\".in\", \"r\", stdin), freopen(x\".out\", \"w\", stdout)\n\nusing namespace std;\n\nnamespace io {\n\tconst int SI = 1 << 21 | 1;\n\tchar IB[SI], *IS, *IT, OB[SI], *OS = OB, *OT = OS + SI - 1, c, ch[100];\n\tint f, t;\n\t#define gc() (IS == IT ? (IT = (IS = IB) + fread(IB, 1, SI, stdin), IS == IT ? EOF : *IS++) : *IS++)\n\tinline void flush() {\n\t\tfwrite(OB, 1, OS - OB, stdout), OS = OB;\n\t}\n\tinline void pc(char x) {\n\t\t*OS++ = x;\n\t\tif (OS == OT) flush();\n\t}\n\n\ttemplate <class I>\n\tinline void rd(I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + (c & 15), c = gc());\n\t\tx *= f;\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y) {\n\t\trd(x), rd(y);\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y, I &z) {\n\t\trd(x), rd(y), rd(z);\n\t}\n\ttemplate <class I>\n\tinline void rda(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) rd(a[i]);\n\t}\n\tinline void rdc(char &c) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t}\n\tinline void rds(char *s, int &n) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (n = 0; c >= 33 && c <= 126; s[++n] = c, c = gc());\n\t\ts[n+1] = '\\0';\n\t}\n\tinline void rds(string &s) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (s.clear(); c >= 33 && c <= 126; s.pb(c), c = gc());\n\t}\n\n\ttemplate <class I>\n\tinline void print(I x, char k = '\\n') {\n\t\tif (!x) pc('0');\n\t\tif (x < 0) pc('-'), x = -x;\n\t\twhile (x) ch[++t] = x % 10 + '0', x /= 10;\n\t\twhile (t) pc(ch[t--]);\n\t\tpc(k);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y) {\n\t\tprint(x, ' '), print(y);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y, I z) {\n\t\tprint(x, ' '), print(y, ' '), print(z);\n\t}\n\ttemplate <class I>\n\tinline void printa(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) print(a[i], \" \\n\"[i==n]);\n\t}\n\tinline void printc(char c) {\n\t\tpc(c);\n\t}\n\tinline void prints(char *s, int n) {\n\t\tfor (int i = 1; i <= n; i++) pc(s[i]);\n\t\tpc('\\n');\n\t}\n\tinline void prints(string s) {\n\t\tint n = s.length();\n\t\twhile (t < n) pc(s[t++]);\n\t\tpc('\\n'), t = 0;\n\t}\n\tstruct Flush {\n\t\t~Flush() {\n\t\t\tflush();\n\t\t}\n\t} flusher;\n}\nusing io::rd;\nusing io::rda;\nusing io::rdc;\nusing io::rds;\nusing io::print;\nusing io::printa;\nusing io::printc;\nusing io::prints;\n\nconst int P = 1e9 + 7;\n\nstruct modint {\n    int x;\n    inline modint(int x = 0) : x(x) {}\n    inline modint &operator = (int o) { return x = o, *this; }\n    inline modint &operator += (modint o) { return (x += o.x) >= P && (x -= P), *this; }\n    inline modint &operator -= (modint o) { return (x -= o.x) < 0 && (x += P), *this; }\n    inline modint &operator *= (modint o) { return x = 1ll * x * o.x % P, *this; }\n    inline modint &operator ^= (ll b) {\n        modint a = *this, c;\n        if (!~b) b = P - 2;\n        c.x = 1 % P;\n        while (b) {\n            if (b & 1) c *= a;\n            a *= a, b >>= 1;\n        }\n        return x = c.x, *this;\n    }\n    inline modint &operator /= (modint o) { return *this *= o ^ -1; }\n    inline modint &operator += (int o) { return (x += o) >= P && (x -= P), *this; }\n    inline modint &operator -= (int o) { return (x -= o) < 0 && (x += P), *this; }\n    inline modint &operator *= (int o) { return x = 1ll * x * o % P, *this; }\n    inline modint &operator /= (int o) { return *this *= (modint)o ^ -1; }\n    template <class I>\n    inline friend modint operator + (modint a, I b) { return a += b; }\n    template <class I>\n    inline friend modint operator - (modint a, I b) { return a -= b; }\n    template <class I>\n    inline friend modint operator * (modint a, I b) { return a *= b; }\n    inline friend modint operator ^ (modint a, ll b) { return a ^= b; }\n    template <class I>\n    inline friend modint operator / (modint a, I b) { return a /= b; }\n    inline friend bool operator == (modint a, int b) { return a.x == b; }\n    inline friend bool operator != (modint a, int b) { return a.x != b; }\n    inline friend bool operator < (modint a, int b) { return a.x < b; }\n    inline friend bool operator <= (modint a, int b) { return a.x <= b; }\n    inline friend bool operator > (modint a, int b) { return a.x > b; }\n    inline friend bool operator >= (modint a, int b) { return a.x >= b; }\n    inline friend bool operator == (modint a, modint b) { return a.x == b.x; }\n    inline friend bool operator != (modint a, modint b) { return a.x != b.x; }\n    inline friend bool operator < (modint a, modint b) { return a.x < b.x; }\n    inline friend bool operator <= (modint a, modint b) { return a.x <= b.x; }\n    inline friend bool operator > (modint a, modint b) { return a.x > b.x; }\n    inline friend bool operator >= (modint a, modint b) { return a.x >= b.x; }\n    inline bool operator ! () { return !x; }\n    inline modint operator - () { return x ? P - x : 0; }\n};\ninline void rd(modint &x) { rd(x.x); }\ninline void print(modint x, char k = '\\n') { print(x.x, k); }\n\n//const int NP = 1e6 + 7;\n//modint p[NP], v[NP], vp[NP];\n//inline void init(int n) {\n//  p[0] = v[0] = 1;\n//  for (int i = 1; i <= n; i++) p[i] = p[i-1] * i;\n//  vp[n] = 1 / p[n];\n//  for (int i = n; i; i--) v[i] = vp[i] * p[i-1], vp[i-1] = vp[i] * i;\n//}\n//inline modint binom(int n, int m) {\n//  return n < m ? 0 : p[n] * vp[m] * vp[n-m];\n//}\n\nnamespace Rd {\n    inline bool gt() {\n        int a = rand(), b = rand();\n        while (a == b) a = rand(), b = rand();\n        return a < b;\n    }\n    template <class I>\n    inline I rd(I k) {\n        I w = 1;\n        while (w < k) w <<= 1;\n        while (w >= k) {\n            I o = 1, x = 0;\n            while (o < k) o <<= 1, x = x << 1 | gt();\n            w = x;\n        }\n        return w;\n    }\n    template <class I>\n    inline I rdm(I l, I r) {\n        return l == r ? l : l + rd(r - l + 1);\n    }\n    template <class I>\n    inline void rdms(I *a, int n) {\n        for (int i = n; i; i--) swap(a[i], a[rdm(1,i)]);\n    }\n}\nusing Rd::rdm;\nusing Rd::rdms;\n\nconst int N = 2.5e5 + 7, M = 1;\nint n;\nchar s[N];\nstruct H {\n\tvector<modint> a;\n\tinline H() { a.resize(M); }\n\tinline modint &operator [] (int i) { return a[i]; }\n\tinline friend bool operator < (H x, H y) { return x.a < y.a; }\n\tinline friend H operator + (H x, H y) {\n\t\tfor (int i = 0; i < M; i++) x[i] += y[i];\n\t\treturn x;\n\t}\n\tinline friend H operator - (H x, H y) {\n\t\tfor (int i = 0; i < M; i++) x[i] -= y[i];\n\t\treturn x;\n\t}\n\tinline friend H operator * (H x, H y) {\n\t\tfor (int i = 0; i < M; i++) x[i] *= y[i];\n\t\treturn x;\n\t}\n} a[N], x, y, h[N];\nmap<H, int> f;\nll ans;\n\nint main() {\n\tsrand(time(0));\n\trd(n), rds(s, n);\n\tfor (int i = 0; i < M; i++)\n\t\ta[0][i] = 1, x[i] = rdm(1, P - 1), y[i] = 1 / x[i];\n\tfor (int i = 1; i <= n; i++)\n\t\tswitch (s[i]) {\n\t\t\tcase '+' : h[i] = h[i-1] + (a[i] = a[i-1]); break;\n\t\t\tcase '-' : h[i] = h[i-1] - (a[i] = a[i-1]); break;\n\t\t\tcase '>' : h[i] = h[i-1], a[i] = a[i-1] * x; break;\n\t\t\tcase '<' : h[i] = h[i-1], a[i] = a[i-1] * y; break;\n\t\t}\n\tfor (int i = 1; i <= n; i++) ++f[h[i-1]+h[n]*a[i-1]], ans += f[h[i]];\n\tprint(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "    #include \"bits/stdc++.h\"\n            using namespace std;\n             \n            #define MAX 600012\n             \n            int n;\n            char buf[MAX];\n            string s;\n            valarray<long long int> MOD1;\n            valarray<long long int> MOD2;\n            vector<valarray<long long int> > p2;\n            vector<valarray<long long int> > vv;\n            vector<int> ps;\n            map<pair<long long int,long long int>, int> mp;\n            long long int ppow(long long int i, long long int j, long long int MOD) {\n            \tlong long int ret = 1;\n            \twhile (j) {\n            \t\tif (j & 1LL)ret *= i;\n            \t\tif (ret >= MOD)ret %= MOD;\n            \t\tj >>= 1LL;\n            \t}\n            \treturn ret;\n            }\n             \n            valarray<long long int> calc(int dif) {\n            \tvalarray<long long int> ret;\n            \tret.resize(2, 0);\n            \tfor (int j = 0; j < 2; j++) {\n            \t\tif (dif < 0) {\n            \t\t\tret[j]=ppow(ppow(MOD1[j],MOD2[j]-2,MOD2[j]),-dif,MOD2[j]);\n            \t\t}\n            \t\telse {\n            \t\t\tret[j] = ppow(MOD1[j],dif, MOD2[j]);\n            \t\t}\n            \t}\n            \treturn ret;\n            }\n             \n            int main() {\n            \tMOD1.resize(2);\n            \tMOD2.resize(2);\n            \tp2.push_back(valarray<long long int>());\n            \tp2.back().resize(2);\n            \tp2.back()[0] = p2.back()[1] = 1;\n            \tMOD2[1] = 1000000007;\n            \tMOD1[0] = 555522277;\n            \tMOD1[1] = 895612782;\n            \tMOD2[0] = 998244353;\n            \tp2[0] %= MOD2;\n            \tfor (int i = 1; i < MAX; i++) p2.push_back((p2.back()*MOD1)%MOD2);\n            \tcin >> n;\n            \tscanf(\"%s\", buf);\n            \ts = buf;\n            \tint pos = MAX/2;\n            \tvalarray<long long int> hs;\n            \ths.resize(2,0);\n            \tvv.push_back(hs);\n            \tps.push_back(pos);\n            \tfor (int i = 0; i < s.size(); i++) {\n            \t\tif (s[i] == '<') pos--;\n            \t\telse if (s[i] == '>') pos++;\n            \t\telse if (s[i] == '+') hs += p2[pos];\n            \t\telse if (s[i] == '-') hs += MOD2-p2[pos];\n            \t\ths %= MOD2;\n            \t\tif(hs[0]<0LL||hs[1]<0LL||p2[pos][0]<0LL||p2[pos][1]<0LL)return 1;\n            \t\tvv.push_back(hs);\n            \t\tps.push_back(pos);\n            \t}\n            \tlong long int way = 0;\n            \tfor (int i = vv.size() - 1; i >= 0; i--) {\n            \t\tvalarray<long long int> want = (vv[i] + ((vv.back()*calc(-MAX/2+ps[i]))%MOD2)%MOD2)%MOD2;\n            \t\tway += mp[make_pair(want[0], want[1])];\n            \t\tif(want[0]<0LL||want[1]<0LL)return 1;\n            \t\tmp[make_pair(vv[i][0],vv[i][1])]++;\n            \t}\n            \tprintf(\"%lld\\n\", way);\n            \treturn 0;\n            }"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=(0);i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n \ntemplate<class T> inline void read(T &x){\n\tint f=0;x=0;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar())f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar())x=x*10+ch-'0';\n\tif(f)x=-x;\n}\n\nconst int N=500005;\nnamespace{\n\tconst int mod=1e9+7;\n\tint p[N],rp[N];\n\tint power(int x){\n\t\treturn x>=0?p[x]:rp[x];\n\t}\n\tint power(int x,int p){\n\t\tint res=1;\n\t\tfor(;p;p>>=1,x=(ll)x*x%mod)\n\t\t\tif(p&1)res=(ll)res*x%mod;\n\t\treturn res;\n\t}\n\tvoid init(int n){\n\t\tint A=2333,B=power(A,mod-2);\n\t\tp[0]=rp[0]=1;\n\t\trep(i,1,n){\n\t\t\tp[i]=(ll)p[i-1]*A%mod;\n\t\t\trp[i]=(ll)rp[i-1]*B%mod;\n\t\t}\n\t}\n}\n\nint v[N],d[N],n;\nmap<int,int> cnt;\nchar s[N];\nll ans;\n\nint main(){\n\tread(n),init(n);\n\tscanf(\"%s\",s+1);\n\trep(i,1,n){\n\t\tv[i]=v[i-1],d[i]=d[i-1];\n\t\tif(s[i]=='<')d[i]--;\n\t\telse if(s[i]=='>')d[i]++;\n\t\telse if(s[i]=='+')v[i]=(v[i]+power(d[i]))%mod;\n\t\telse v[i]=(v[i]+mod-power(d[i]))%mod;\n\t}\n\tper(i,n-1,0){\n\t\tcnt[v[i+1]]++;\n\t\tans+=cnt[(v[i]+(ll)power(d[i])*v[n])%mod];\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define MAX 500012\n\nint n;\nchar buf[MAX];\n\n\nstring s;\n\n\n//#define MOD1 1000000007\n//#define MOD2 1000000009\n#define B 4\nvalarray<long long int> MOD1;\nvalarray<long long int> MOD2;\nvector<valarray<long long int> > p2;\nvector<valarray<long long int> > vv;\nvector<int> ps;\nmap<long long int, int> mp;\nlong long int ppow(long long int i, long long int j, long long int MOD) {\n\tlong long int ret = 1;\n\twhile (j) {\n\t\tif (j & 1LL)ret *= i;\n\t\tif (ret >= MOD)ret %= MOD;\n\t\tj >>= 1LL;\n\t}\n\treturn ret;\n}\n\nvalarray<long long int> calc(int dif) {\n\tvalarray<long long int> ret;\n\tret.resize(B, 0);\n\tfor (int j = 0; j < B; j++) {\n\t\tif (dif < 0) {\n\t\t\tret[j]=ppow(ppow(MOD1[j], abs(dif),MOD2[j]), MOD2[j] - 2,MOD2[j]);\n\t\t}\n\t\telse {\n\t\t\tret[j] = ppow(MOD1[j], abs(dif), MOD2[j]);\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main() {\n\tMOD1.resize(B);\n\tMOD2.resize(B);\n\tp2.push_back(valarray<long long int>());\n\tp2.back().resize(B, 1);\n\tMOD2[0] = 1000000007;\n\tMOD1[0] = 998244353;\n\tMOD1[2] = 1741231;\n\tMOD2[2] = 1000000009;\n\tMOD1[3] = 114514191;\n\tMOD2[3] = 1000000007;\n\tMOD1[1] = 555522277;\n\tMOD2[1] = 895612782;\n\tp2[0] %= MOD2;\n\tfor (int i = 1; i < MAX; i++) {\n\t\tp2.push_back(p2.back());\n\t\tp2[i] *= MOD1;\n\t\tp2[i] %= MOD2;\n\t}\n\tcin >> n;\n\tscanf(\"%s\", buf);\n\ts = buf;\n\tint pos = MAX/2;\n\tvalarray<long long int> hs;\n\ths.resize(B,0);\n\tvv.push_back(hs);\n\tps.push_back(pos);\n\tfor (int i = 0; i < s.size(); i++) {\n\t\tif (s[i] == '<') {\n\t\t\tpos--;\n\t\t}\n\t\tif (s[i] == '>') {\n\t\t\tpos++;\n\t\t}\n\t\tif (s[i] == '+') {\n\t\t\ths += p2[pos];\n\t\t}\n\t\tif (s[i] == '-') {\n\t\t\ths -= p2[pos];\n\t\t\ths += MOD2;\n\t\t}\n\t\ths %= MOD2;\n\t\tvv.push_back(hs);\n\t\tps.push_back(pos);\n\t}\n\tlong long int way = 0;\n\tfor (int i = vv.size() - 1; i >= 0; i--) {\n\t\tvalarray<long long int> want = vv[i] + vv.back()*calc(-MAX/2+ps[i]);\n\t\twant = want%MOD2;\n\t\tway += mp[want[2]*MOD1[2]+want[3]*MOD1[3]+want[0] * MOD1[0] + want[1]];\n\t\t//cerr << \"dbg \" << way << endl;\n\t\tmp[want[2] * MOD1[2] + want[3] * MOD1[3] + want[0] * MOD1[0] + want[1]]++;\n\t}\n\tprintf(\"%lld\\n\", way);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for (int i = (a); i <= (b); ++ i)\n#define rrp(i,a,b) for (int i = (a); i >= (b); -- i)\n#define gc() getchar()\n#define fir first\n#define sec second\ntypedef pair<int,int> pii;\ntypedef long double db;\ntypedef long long ll;\ntemplate <typename tp>\ninline void read(tp& x) {\n  x = 0; char tmp; bool key = 0;\n  for (tmp = gc(); !isdigit(tmp); tmp = gc())\n    key = (tmp == '-');\n  for (; isdigit(tmp); tmp = gc())\n    x = (x << 3) + (x << 1) + (tmp ^ '0');\n  if (key) x = -x;\n}\ntemplate <typename tp>\ninline void ckmn(tp& x,tp y) {\n  x = x < y ? x : y;\n}\ntemplate <typename tp>\ninline void ckmx(tp& x,tp y) {\n  x = x < y ? y : x;\n}\n\nconst int N = 250010, MOD = 998244353, BAS = 233;\ninline void Add(int& x,int y) {\n  x = x + y >= MOD ? x + y - MOD : x + y;\n}\ninline void Sub(int& x,int y) {\n  x = x - y < 0 ? x - y + MOD : x - y;\n}\nint power(int a,int b) {\n  int ret = 1;\n  while (b) {\n    if (b&1) ret = 1ll * ret * a % MOD;\n    a = 1ll * a * a % MOD;\n    b >>= 1;\n  }\n  return ret;\n}\n\nchar str[N];\nint n, pw[N << 1], ipw[N << 1], rec, val[2][N], tmp[2][N];\nll ans;\nmap<int,int> mp;\nvoid solve(int l,int r) {\n  if (l == r) {\n    if (val[1][l] == rec)\n      ++ ans;\n    return;\n  }\n  int mid = (l + r) >> 1;\n  mp.clear();\n  tmp[0][mid] = val[0][mid], tmp[1][mid] = val[1][mid];\n  rrp (i, mid-1, l) {\n    tmp[0][i] = 1ll * val[0][i] * tmp[0][i+1] % MOD;\n    tmp[1][i] = (1ll * val[0][i] * tmp[1][i+1] + val[1][i]) % MOD;\n  }\n  tmp[0][mid+1] = val[0][mid+1], tmp[1][mid+1] = val[1][mid+1];\n  rep (i, mid+2, r) {\n    tmp[0][i] = 1ll * tmp[0][i-1] * val[0][i] % MOD;\n    tmp[1][i] = (1ll * tmp[0][i-1] * val[1][i] + tmp[1][i-1]) % MOD;\n  }\n  rep (i, mid+1, r) ++ mp[tmp[1][i]];\n  rep (i, l, mid) {\n    // tmp[0][i] * v + tmp[1][i] = rec\n    int v = rec;\n    Sub(v, tmp[1][i]);\n    v = 1ll * v * power(tmp[0][i], MOD - 2) % MOD;\n    ans += mp[v];\n  }\n  solve(l, mid);\n  solve(mid+1, r);\n}\nint main() {\n  read(n);\n  scanf(\"%s\", str+1);\n  pw[0] = ipw[0] = 1;\n  rep (i, 1, n * 2) pw[i] = 1ll * pw[i-1] * BAS % MOD;\n  ipw[1] = power(BAS, MOD - 2);\n  rep (i, 2, n*2) ipw[i] = 1ll * ipw[i-1] * ipw[1] % MOD;\n  rep (i, 1, n) {\n    if (str[i] == '+') val[0][i] = 1, val[1][i] = 1;\n    if (str[i] == '-') val[0][i] = 1, val[1][i] = MOD - 1;\n    if (str[i] == '<') val[0][i] = pw[1];\n    if (str[i] == '>') val[0][i] = ipw[1];\n  }\n  rrp (i, n, 1)\n    rec = (1ll * rec * val[0][i] + val[1][i]) % MOD;\n  solve(1, n);\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n// need\n#include <iostream>\n#include <algorithm>\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <unordered_map>\n#include <unordered_set>\n#include <array>\n// stream\n//#include <istream>\n#include <sstream>\n//#include <ostream>\n#include <fstream>\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest& ...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int w_=0; w_<n; ++w_){MACRO_VEC_ROW_Scan(w_, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest& ...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest& ...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& R:c)for(auto& w:R)std::cin>>w;\n// output\n#define OUT(dist) std::cout<<(dist);\n#define FOUT(n, dist) std::cout<<std::fixed<<std::setprecision(n)<<(dist);\n#define SOUT(n, c, dist) std::cout<<std::setw(n)<<std::setfill(c)<<(dist);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(w, n) std::cout<<(w + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(dist) {std::cerr << #dist << \"\\t:\" << (dist) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(w, a, n) for(int w=(a);w<(n);++w)\n#define RFOR(w, a, n) for(int w=(n)-1;w>=(a);--w)\n#define REP(w, n) for(int w=0;w<int(n);++w)\n#define RREP(w, n) for(int w=int(n)-1;w>=0;--w)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<class T> inline T CHMAX(T & a, const T b) { return a = (a < b) ? b : a; }\ntemplate<class T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\n//void CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n// test\ntemplate<class T> using V = std::vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n#define random_shuffle \"USE std::shuffle!\";\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = (1 << 30) - 1;                    // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-10;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T & val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T & val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T> & a, const T & val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>> & a, const T & val) { for (auto& b : a) FILL(b, val); }\n// ------------>8------------------------------------->8------------\n\nnamespace Test {\n\tsigned main() {\n\t\t//VAR(int, n);\n//VAR(std::string, s);\n\t\tstd::string S = \"+-<>\";\n\t\tconst int n = 50;\n\t\tauto system_now = std::chrono::system_clock::now();\n\t\tstd::mt19937 mt(std::chrono::duration_cast<std::chrono::microseconds>(system_now.time_since_epoch()).count());\n\t\tstd::uniform_int_distribution<> rand(/* min */0, /* max */3);\n\t\tstd::string s;\n\t\tREP(_, n) s += S[rand(mt)];\n\n\t\tauto get = [&](int l, int r) {\n\t\t\tstd::map<int, int> map;\n\t\t\tint p = 0;\n\t\t\tFOR(i, l, r) {\n\t\t\t\t/* */if (s[i] == '+') { if (++map[p] == 0) map.erase(p); }\n\t\t\t\telse if (s[i] == '-') { if (--map[p] == 0) map.erase(p); }\n\t\t\t\telse if (s[i] == '>') ++p;\n\t\t\t\telse if (s[i] == '<') --p;\n\t\t\t}\n\n\t\t\treturn map;\n\t\t};\n\n\t\tauto sub = [&](std::map<int, int> a, const std::map<int, int> b) {\n\t\t\tfor (auto& p : b) {\n\t\t\t\tif ((a[p.first] -= p.second) == 0) a.erase(p.first);\n\t\t\t}\n\t\t\treturn a;\n\t\t};\n\n\t\tauto print = [&](std::map<int, int> map) {\n\t\t\tFOR(i, -10, 20) {\n\t\t\t\tOUT(map[i])SPBR(i, 20);\n\t\t\t}\n\t\t};\n\n\t\tVAR(int, l, r);\n\n\t\tOUT(s)BR;\n\t\tREP(i, n) {\n\t\t\tchar c = ' ';\n\t\t\tif (IN(l, i, r)) c = '*';\n\t\t\tOUT(c);\n\t\t}BR;\n\t\tprint(get(l, r));\n\t\tprint(sub(get(0, r), get(0, l)));\n\t\treturn 0;\n\t}\n}\n\nll powMod(ll n, ll p, ll mod) {\n\tif (p < 0) p += mod - 1;\n\tn %= mod;\n\tll res = 1;\n\twhile (p) {\n\t\tif (p & 1) (res *= n) %= mod;\n\t\t(n *= n) %= mod;\n\t\tp >>= 1;\n\t}\n\treturn res;\n}\n\nconstexpr int N = 1;\nconstexpr int M[N] = { 1000000009 };\nconstexpr int B = 123457;\n\nstruct Hash {\n\tint val[N];\n\tHash& norm() {\n\t\tREP(i, N) if ((val[i] %= M[i]) < 0) val[i] += M[i];\n\t\treturn *this;\n\t}\n\n\tHash(int x) { REP(i, N) val[i] = x; norm(); }\n\tHash() : Hash(0) {}\n\n\tstatic Hash makePow(int n, int p) {\n\t\tHash res;\n\t\tREP(i, N) res.val[i] = powMod(n, p, M[i]);\n\t\treturn res;\n\t}\n\tstatic Hash makeInv(int x) {\n\t\tHash res;\n\t\tREP(i, N) res.val[i] = powMod(x, M[i] - 2, M[i]);\n\t\treturn res;\n\t}\n\n\tbool operator==(const Hash & r) const { return *this == r; }\n\tbool operator<(const Hash & r) const { \n\t\tREP(i, N) if(this->val[i] != r.val[i]) return this->val[i] < r.val[i];\n\t\treturn false;\n\t}\n\tHash& operator+=(const Hash & r) { REP(i, N) val[i] += r.val[i]; norm(); return *this; }\n\tHash& operator-=(const Hash & r) { REP(i, N) val[i] -= r.val[i]; norm(); return *this; }\n\tHash& operator*=(const Hash & r) { REP(i, N) val[i] *= r.val[i]; norm(); return *this; }\n\tHash& operator/=(const Hash & r) { \n\t\tREP(i, N) val[i] *= powMod(r.val[i], M[i] - 2, M[i]); \n\t\tnorm(); \n\t\treturn *this; \n\t}\n};\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n);\n\tVAR(std::string, s);\n\n\tHash X;\n\t{\n\t\tint p = 0;\n\t\tREP(i, n) {\n\t\t\t/* */if (s[i] == '+') X += Hash::makePow(B, p);\n\t\t\telse if (s[i] == '-') X -= Hash::makePow(B, p);\n\t\t\telse if (s[i] == '>') ++p;\n\t\t\telse if (s[i] == '<') --p;\n\t\t}\n\t}\n\n\tstd::map<Hash, int> map;\n\t++map[X];\n\tint ans = 0;\n\tHash A;\n\t{\n\t\tint p = 0;\n\t\tREP(i, n) {\n\t\t\t/* */if (s[i] == '+') A += Hash::makePow(B, p);\n\t\t\telse if (s[i] == '-') A -= Hash::makePow(B, p);\n\t\t\telse if (s[i] == '>') ++p;\n\t\t\telse if (s[i] == '<') --p;\n\t\t\tans += map[A];\n\t\t\t{\n\t\t\t\tauto tX(X);\n\t\t\t\ttX /= Hash::makePow(B, -p);\n\t\t\t\ttX += A;\n\t\t\t\t++map[tX];\n\t\t\t}\n\t\t}\n\t}\n\tOUT(ans)BR;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define pb push_back\n#define all(v) v.begin(), v.end()\n#define sz(v) int(v.size())\n#define pii pair<int, int>\n#define mp make_pair\n#define f first\n#define ll long long\n#define s second\n#define vec vector<int>\n\nusing namespace std;\n\nconst int N = (int) 770 + 10;\nconst int K = (int) N * N;\nconst int mod = (int) 1e9 + 7;\nconst int T = (int) 200017;\n\nint n;\nstring st;\n\npair<vec, int> get(int l, int r) {\n\tint pos = 2 * n;\n\tvector<int> a(4 * n, 0);\n\tfor (int i = l; i <= r; i++) {\n\t\tif (st[i] == '+') {\n\t\t\ta[pos]++;\n\t\t} else if (st[i] == '-') {\n\t\t\ta[pos]--;\n\t\t} else if (st[i] == '>') {\n\t\t\tpos++;\n\t\t} else {\n\t\t\tpos--;\n\t\t}\n\t}\n\treturn mp(a, pos);\n}\n\n// get(l,r)=(get(0,r)-get(0,l-1))<<pos(0, l-1)\n\nvoid add(int &x, int y) {\n\tx += y;\n\tif (x >= mod)\n\t\tx -= mod;\n\tif (x < 0) \n\t\tx += mod;\n}\n\nint mult(int x, int y) {\n\treturn x * 1ll * y % mod;\n}\n\nint p[N];\n\nint get_hash(vec v) {\n\tint ans = 0;\n\tfor (int i = 0; i < sz(v); i++) {\n\t\tadd(ans, mult(v[i], p[i]));\n\t}\n\treturn ans;\n}\n\nvec shift(vec x, int val) { // to the right\n\tif (val > 0) {\n\t\treverse(all(x));\n\t\twhile (val--) {\n\t\t\tx.pb(0);\n\t\t}\n\t\treverse(all(x));\n\t} else {\n\t\treverse(all(x));\n\t\tval *= -1;\n\t\twhile (val--) {\n\t\t\tx.pop_back();\n\t\t}\n\t\treverse(all(x));\n\t}\n\twhile (sz(x) < 4 * n) x.pb(0);\n\twhile (sz(x) > 4 * n) x.pop_back();\n\treturn x;\n}\n\nvec add(vec x, vec y) {\n\tassert(sz(x) == sz(y));\n\tfor (int i = 0; i < sz(x); i++) {\n\t\tx[i] += y[i];\n\t}\n\treturn x;\n}\n\nint main() {\n\t#ifdef sony\n\t\tfreopen(\"input.txt\", \"r\", stdin);\n\t\tfreopen(\"output.txt\", \"w\", stdout);\n\t#endif\n\tcin >> n >> st;\n\t//HASH(A) = {FOR I = [0...big_N] SUM OF A[I]*T^I % MODULO} WHERE T = PRIME > 2.5 * 10^5\n\tp[0] = 1;\n\tfor (int i = 1; i < N; i++) {\n\t\tp[i] = mult(p[i - 1], T);\n\t}\n\tvec x = get(0, n - 1).f;\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i; j < n; j++) {\n\t\t\tvec y = add(shift(x, get(0, i - 1).s - 2 * n), shift(get(0, i - 1).f, 0));\n\t\t\tvec z = shift(get(0, j).f, 0);\n\n\t\t\t//cout << \"~~~~~~~~~~~~~~~\\n\";\n\t\t\t//for (auto it : y) cout << it << ' ';\n\t\t\t//cout << endl;\n\t\t\t//for (auto it : z) cout << it << ' ';\n\t\t\t//cout << endl;\n\n\t\t\tif (z == y) {\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define fi first\n#define se second\n#define ll long long\n#define dbg(v) cerr<<#v<<\" = \"<<v<<'\\n'\n#define vi vector<int>\n#define vl vector <ll>\n#define pii pair<int,int>\n#define mp make_pair\n#define db long double\n#define pb push_back\n#define all(s) s.begin(),s.end()\n#include <x86intrin.h>\ntemplate < class T > T smin(T &a,T b) {if (a > b) a = b;return a;}\ntemplate < class T > T smax(T &a,T b) {if (a < b) a = b;return a;}\nconst int N = (1e6) + 5;\nchar str[N];\nint sum[N];\nconst int offset = 250005;\nint mod1,mod2;\nint prime(int k) {\n\tfor (int i = 2;1ll * i * i <= k;++i)\n\t\tif (!(k % i))\n\t\t\treturn 0;\n\treturn 1;\n}\nint P1[N];\nint P2[N];\nint pow(int a,int b,int mod) {\n\tint ans = 1;\n\twhile (b) {\n\t\tif (b & 1)\n\t\t\tans = (1ll * ans * a) % mod;\n\t\tb /= 2;\n\t\ta = (1ll * a * a) % mod;\n\t}\n\treturn ans;\n}\nconst int base1 = 1e6 + 3;\nconst int base2 = 666013;\nint pw1[N];\nint pw2[N];\nmap < pii , int > M;\nint main(void) {\n\tint n;\n\tsrand(__rdtsc());\n\tcin>>n;\n\tcin>>(str + 1);\n\tsum[0] = offset;\n\tfor (int i = 1;i <= n;++i) {\n\t\tsum[i] = sum[i - 1] + (str[i] == '<' ? -1 : str[i] == '>' ? 1 : 0);\n\t}\n\tdo {\t\n\t\tmod1 = ((1ll * rand() << 16) ^ rand()) & ((1ll << 30) - 1);\n\t\tif (mod1 < (1 << 29))\n\t\t\tmod1 += (1 << 29);\n\t} while (!prime(mod1));\n    do {\t\n\t\tmod2 = ((1ll * rand() << 16) ^ rand()) & ((1ll << 30) - 1);\n\t\tif (mod2 < (1 << 29))\n\t\t\tmod2 += (1 << 29);\n\t} while (!prime(mod2));\n\tconst int iv1 = pow(base1,mod1 - 2,mod1);\n\tconst int iv2 = pow(base2,mod2 - 2,mod2);\n\tpw1[offset] = pw2[offset] = 1;\n\tfor (int i = offset - 1;i >= 0;--i) {\n\t\tpw1[i] = (1ll * pw1[i + 1] * iv1) % mod1;\n\t\tpw2[i] = (1ll * pw2[i + 1] * iv2) % mod2;\n\t}\n\tfor (int i = offset + 1;i <= 2 * offset;++i) {\n\t\tpw1[i] = (1ll * pw1[i - 1] * base1) % mod1;\n\t\tpw2[i] = (1ll * pw2[i - 1] * base2) % mod2;\n\t}\n\tP1[0] = 0;\n\tP2[0] = 0;\n\tfor (int i = 1;i <= n;++i) {\n\t\tif (sum[i] != sum[i - 1])\n\t\t\tP1[i] = P1[i - 1],\n\t\t\tP2[i] = P2[i - 1];\n\t\telse {\n\t\t\tint cnt1 = pw1[sum[i]];\n\t\t\tif (str[i] == '-')\n\t\t\t\tcnt1 = (mod1 - cnt1) % mod1;\n\t\t\tP1[i] = (P1[i - 1] + cnt1) % mod1;\n\t\t\tint cnt2 = pw2[sum[i]];\n\t\t\tif (str[i] == '-')\n\t\t\t\tcnt2 = (mod2 - cnt2) % mod2;\n\t\t\tP2[i] = (P2[i - 1] + cnt2) % mod2;\n\t\t}\n\t}\n\tll ans = 0; \t\n\tfor (int i = n;i >= 0;--i) {\n \t\tint cnt1 = (P1[i] + 1ll * P1[n] * pw1[sum[i]]) % mod1;\n \t\tint cnt2 = (P2[i] + 1ll * P2[n] * pw2[sum[i]]) % mod2;\n \t\tif (M.count(mp(cnt1,cnt2)))\n \t\t\tans += M[mp(cnt1,cnt2)];\n \t\t++M[mp(P1[i],P2[i])];\n \t}\n \tcout << ans << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define fst first\n#define snd second\n#define SZ(u) ((int) (u).size())\n#define ALL(u) (u).begin(), (u).end()\n\ninline void proc_status()\n{\n    ifstream t(\"/proc/self/status\");\n    cerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline T read()\n{\n\tregister T sum(0), fg(1);\n\tregister char ch(getchar());\n\tfor(; !isdigit(ch); ch = getchar()) if(ch == '-') fg = -1;\n\tfor(;  isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) - '0' + ch;\n\treturn sum * fg;\n}\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int, int> pii;\n\nconst int MAXN = (int) 2.5e5;\n\nint n;\n\nchar s[MAXN + 5];\n\ninline void input()\n{\n\tn = read<int>();\n\tscanf(\"%s\", s + 1);\n}\n\nconst LL MOD = (1ll << 62) - 1, B = (int) 233;\n\ninline LL fpm(LL x, LL y)\n{\n\tLL res = 1;\n\tfor(; y; y >>= 1, x = (LL) x * x % MOD) if(y & 1) res = (LL) res * x % MOD;\n\treturn res;\n}\n\ninline void solve()\n{\n\t// Thanks to zhou888\n\n\tstatic LL p[MAXN + 5], prefix[MAXN + 5], p_pow[MAXN * 2 + 5];\n\n\tp_pow[0 + n] = 1;\n\tfor(int i = 1, invB = fpm(B, MOD - 2); i <= n; ++i)\n\t{\n\t\tp_pow[ i + n] = (LL) p_pow[ i - 1 + n] *\tB % MOD;\n\t\tp_pow[-i + n] = (LL) p_pow[-i + 1 + n] * invB % MOD;\n\t}\n\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tp[i] = p[i - 1], prefix[i] = prefix[i - 1];\n\t\tif(s[i] == '<') --p[i];\n\t\tif(s[i] == '>') ++p[i];\n\t\tif(s[i] == '+') (prefix[i] += p_pow[p[i] + n]) %= MOD;\n\t\tif(s[i] == '-') (prefix[i] -= p_pow[p[i] + n]) %= MOD;\n\t}\n\tfor(int i = 1; i <= n; ++i) (prefix[i] += MOD) %= MOD;\n\n\tstatic unordered_map<LL, int> cnt;\n\n\tLL ans = 0;\n\tfor(int i = 1; i <= n; ++i) ans += prefix[i] == prefix[n];\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tans += cnt[prefix[i]];\n\t\tLL res = (prefix[i] + (LL) p_pow[p[i] + n] * prefix[n] % MOD) % MOD;\n\t\t++cnt[res];\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main()\n{\n//\tfreopen(\"F.in\", \"r\", stdin);\n//\tfreopen(\"F.out\", \"w\", stdout);\n\n\tinput();\n\tsolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e6+5;\nconst int mod1=1e9+7;\nconst int P1=19260817;\nconst int P2=998244353;\nconst int mod2=1004535809;\n#define ll long long\ntypedef pair<ll,ll>Pi;\nll fsp(ll x,int y){\n\tll ans=1;\n\twhile(y){\n\t\tif(y&1)\tans=ans*x%mod1;\n\t\tx=x*x%mod1,y>>=1;\n\t}\n\treturn ans;\n}\nll ksm(ll x,int y){\n\tll ans=1;\n\twhile(y){\n\t\tif(y&1)\tans=ans*x%mod2;\n\t\tx=x*x%mod2,y>>=1;\n\t}\n\treturn ans;\n}\nchar s[N];\nmap<Pi,int>ma;\nll n,l1,l2=1,r1,r2=1,ans,res1,res2,add1,add2,inv1,inv2;\nint main(){\n\tscanf(\"%lld%s\",&n,s+1);\n\tadd1=fsp(P1,n);add2=ksm(P2,n);\n\tinv1=fsp(P1,mod1-2),inv2=ksm(P2,mod2-2);\n\tfor(int i=n;i;i--){\n\t\tif(s[i]=='-'){\n\t\t\tres1=(res1-add1+mod1)%mod1;\n\t\t\tres2=(res2-add2+mod2)%mod2;\n\t\t}\n\t\tif(s[i]=='+'){\n\t\t\tres1=(res1+add1)%mod1;\n\t\t\tres2=(res2+add2)%mod2;\n\t\t}\n\t\tif(s[i]=='<'){\n\t\t\tres1=res1*inv1%mod1;\n\t\t\tres2=res2*inv2%mod2;\n\t\t}\n\t\tif(s[i]=='>'){\n\t\t\tres1=res1*P1%mod1;\n\t\t\tres2=res2*P2%mod2;\n\t\t}\n\t}\n\tfor(int i=n;i;i--){\n\t\tll k1=0,k2=0;\n\t\tif(s[i]=='-'){\n\t\t\tl1=(l1-add1+mod1)%mod1,k1=mod1-add1;\n\t\t\tr1=(r1-add2+mod2)%mod2,k2=mod2-add2;\n\t\t}\n\t\tif(s[i]=='<'){\n\t\t\tl1=l1*inv1%mod1,l2=l2*inv1%mod1;\n\t\t\tr1=r1*inv2%mod2,r2=r2*inv2%mod2;\n\t\t}\n\t\tif(s[i]=='>'){\n\t\t\tl1=l1*P1%mod1,l2=l2*P1%mod1;\n\t\t\tr1=r1*P2%mod2,r2=r2*P2%mod2;\n\t\t}\n\t\tif(s[i]=='+'){\n\t\t\tl1=(l1+add1)%mod1,k1=add1;\n\t\t\tr1=(r1+add2)%mod2,k2=add2;\n\t\t}\n\t\t++ma[Pi((k1-l1+mod1)*fsp(l2,mod1-2)%mod1,(k2-r1+mod2)*ksm(r2,mod2-2)%mod2)];\n\t\tans+=ma[Pi((res1-l1+mod1)*fsp(l2,mod1-2)%mod1,(res2-r1+mod2)*ksm(r2,mod2-2)%mod2)];\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\nusing namespace std;\ntypedef long long LL;\nconst int N=250010;\nconst LL MOD=1000000000000000031ll,B=1000000000000000003ll,REVB=821428571428571454ll;\nint n;\nchar str[N];\nLL f[N],p[N];\nLL mul(LL x,LL y){\n\treturn (LL)((__int128)x*y%MOD);\n}\nvoid readData(){\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",str+1);\n}\nmap<LL,int> mp;\nvoid solve(){\n\tf[0]=0;\n\tp[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tf[i]=f[i-1];\n\t\tp[i]=p[i-1];\n\t\tif(str[i]=='>')\n\t\t\tp[i]=mul(p[i],B);\n\t\telse if(str[i]=='<')\n\t\t\tp[i]=mul(p[i],REVB);\n\t\telse if(str[i]=='+')\n\t\t\t(f[i]+=p[i])%=MOD;\n\t\telse\n\t\t\t(f[i]-=p[i])%=MOD;\n\t\tif(f[i]<0)\n\t\t\tf[i]+=MOD;\n\t}\n\tLL ans=0;\n\tfor(int i=n;i>=1;i--){\n\t\tmp[f[i]]++;\n\t\tans+=mp[(mul(f[n],p[i-1])+f[i-1])%MOD];\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\nint main(){\n\treadData();\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<climits>\n#include<bitset>\n#include<map>\n#define pii pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define int __int128\n#define mod1 1004535809\n#define mod2 1000000000000000009\nusing namespace std;\ninline int read(){\n    int f=1,ans=0;char c=getchar();\n    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}\n    while(c>='0'&&c<='9'){ans=ans*10+c-'0';c=getchar();}\n    return f*ans;\n}\nconst int MAXN=5e5+11;\nint N;char str[MAXN];\nint h1[MAXN],s1[MAXN],xx=250001,res,h2[MAXN],s2[MAXN];\nint ksm1(int a,int b){\n    int ans=1;\n    while(b){if(b&1) ans*=a,ans%=mod1;a*=a,a%=mod1;b>>=1;}return ans;\n}\nint pw1(int a,int b){\n    if(b>=0) return ksm1(a,b);\n    int res=ksm1(a,-b);return ksm1(res,mod1-2);\n}\nint ksm2(int a,int b){\n    int ans=1;\n    while(b){if(b&1) ans*=a,ans%=mod2;a*=a,a%=mod2;b>>=1;}return ans;\n}\nint pw2(int a,int b){\n    if(b>=0) return ksm2(a,b);\n    int res=ksm2(a,-b);return ksm2(res,mod1-2);\n}\nmap<pii,int> M;\nvoid ins(int ps){M[mp( (h1[ps]+pw1(xx,s1[ps])*h1[N])%mod1 , (h2[ps]+pw2(xx,s2[ps])*h2[N])%mod2 )]++;return;}\ninline void print(int x){\n    if(x>9) print(x/10);\n    putchar(x%10+'0');\n}\nsigned main(){\n    //freopen(\"1.in\",\"r\",stdin);\n    N=read();scanf(\"%s\",str+1);\n    for(int i=1;i<=N;i++){\n        if(str[i]=='+') h1[i]=h1[i-1]+pw1(xx,s1[i-1]),s1[i]=s1[i-1],h1[i]%=mod1;\n        if(str[i]=='-') h1[i]=h1[i-1]-pw1(xx,s1[i-1])+mod1,s1[i]=s1[i-1],h1[i]%=mod1;\n        if(str[i]=='>') h1[i]=h1[i-1],s1[i]=s1[i-1]+1;\n        if(str[i]=='<') h1[i]=h1[i-1],s1[i]=s1[i-1]-1;\n        if(str[i]=='+') h2[i]=h2[i-1]+pw2(xx,s2[i-1]),s2[i]=s2[i-1],h2[i]%=mod2;\n        if(str[i]=='-') h2[i]=h2[i-1]-pw2(xx,s2[i-1])+mod2,s2[i]=s2[i-1],h2[i]%=mod2;\n        if(str[i]=='>') h2[i]=h2[i-1],s2[i]=s2[i-1]+1;\n        if(str[i]=='<') h2[i]=h2[i-1],s2[i]=s2[i-1]-1;\n    }\n    ins(0);\n    for(int i=1;i<=N;i++){\n        res+=M[mp(h1[i],h2[i])];\n        ins(i);\n    }print(res);printf(\"\\n\");return 0;\n}/*\n  5\n  +>+<-\n  */\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nmt19937 rd(time(0));\n#define int long long\nconst int M=1e9+7;\n#define fi first\n#define se second\n#define mp make_pair\n#define pii pair<int,int>\nconst int N=250005;\npii f1[N],f2[N];\nchar s[N];\nint n;\nmap<pair<int,int>,int> Map;\nint ksm(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=x*x%M)\n\t\tif (y&1)(ans*=x)%=M;\n\treturn ans;\n}\npii fuhe(pii x,pii y){\n\treturn mp((x.fi*y.fi)%M,(x.fi*y.se+x.se)%M);\n}\nsigned main(){\n\tscanf(\"%lld\",&n);\n\tscanf(\"%s\",s+1);\n\tint x1=rd()%(M-1)+1,x2=rd()%(M-1)+1;\n\tint Inv1=ksm(x1,M-2),Inv2=ksm(x2,M-2);\n\tf1[0]=mp(1,0);f2[0]=mp(1,0);\n\tfor (int i=1;i<=n;i++){\n\t\tif (s[i]=='+')f1[i]=fuhe(f1[i-1],mp(1,1)),f2[i]=fuhe(f2[i-1],mp(1,1));\n\t\tif (s[i]=='-')f1[i]=fuhe(f1[i-1],mp(1,-1)),f2[i]=fuhe(f2[i-1],mp(1,-1));\n\t\tif (s[i]=='<')f1[i]=fuhe(f1[i-1],mp(x1,0)),f2[i]=fuhe(f2[i-1],mp(x2,0));\n\t\tif (s[i]=='>')f1[i]=fuhe(f1[i-1],mp(Inv1,0)),f2[i]=fuhe(f2[i-1],mp(Inv2,0));\n\t}\n\tint ans=0;\n\tfor (int i=1;i<=n;i++){\n\t\tMap[mp((fuhe(f1[i-1],f1[n])).se,(fuhe(f2[i-1],f2[n])).se)]++;\n\t\tans+=Map[mp(f1[i].se,f2[i].se)];\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int N=250005,M1=1000020221,M2=800000011;\nusing namespace std;\nint n,now,a[N],b1[N],b2[N],w1,w2,tp,a1,a2;\nchar S[N];\nlong long ans;\nmap<pair<int,int>,int>mp;\ninline int pls(int x,int y,int M){\n\treturn ((x+y)%M+M)%M;\n}\ninline void sol(bool fl){\n\tnow=n,w1=w2=0;\n\tfor(int i=1;i<=n;i++){\n\t\t//cerr<<i<<\"===now:\"<<now<<endl;\n\t\tif(fl)mp[{pls(1ll*b1[now]*a1%M1,1ll*w1*b1[n]%M1,M1),\n\t\tpls(1ll*b2[now]*a2%M2,1ll*w2*b2[n]%M2,M2)}]++;\n\t\t//cerr<<\"ins \"<<pls(1ll*b1[now]*a1%M1,1ll*w1*b1[n]%M1,M1)<<','<<\n\t\t//pls(1ll*b2[now]*a2%M2,1ll*w2*b2[n]%M2,M2)<<endl;\n\t\tif(S[i]>59)now+=S[i]-61;\n\t\telse{\n\t\t\t//cerr<<S[i]<<\"?\";\n\t\t\ttp=44-S[i];\n\t\t\tw1=pls(w1,tp*b1[now],M1);\n\t\t\tw2=pls(w2,tp*b2[now],M2);\n\t\t}\n\t\tif(fl)ans+=mp[{1ll*w1*b1[n]%M1,1ll*w2*b2[n]%M2}];\n\t\t//cerr<<\"(\"<<w1<<','<<w2<<\")\\n\";\n\t}\n}\nint main(){\n\t//freopen(\"dat.txt\",\"r\",stdin);\n\t//cerr<<(int)'+'<<' '<<(int)'-'<<' '<<(int)'>'<<' '<<(int)'<'<<endl;\n\tscanf(\"%d%s\",&n,S+1);\n\tb1[1]=b2[1]=1;\n\tfor(int i=1;i<=2*n;i++)\n\t//b1[i+1]=1ll*b1[i]*7%M1,b2[i+1]=1ll*b2[i]*11%M2;\n\tb1[i+1]=1ll*b1[i]*524287%M1,b2[i+1]=1ll*b2[i]*19260817%M2;\n\tsol(0),a1=w1,a2=w2,//cerr<<\"INI:(\"<<a1<<','<<a2<<\")\\n\",\n\tsol(1);\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<map>\n#define ll long long\n#define mid (l+r)/2\nusing namespace std;\nconst ll MOD=1e9+9,inv2=5e8+5;\nint n;\nchar s[250005];\nll v,v1[250005],p1[250005],v2[250005],ans;\nmap<ll,int>mp;\nvoid solve(int l,int r)\n{\n\tif(l==r)\n\t{\n\t\tif(s[l]=='+'&&v==1)ans++;\n\t\tif(s[l]=='-'&&v==MOD-1)ans++;\n\t\tif(s[l]=='<'&&v==0)ans++;\n\t\tif(s[l]=='>'&&v==0)ans++;\n\t\treturn;\n\t}\n\tsolve(l,mid);\n\tsolve(mid+1,r);\n\tv1[mid+1]=v2[mid]=0;\n\tp1[mid+1]=1;\n\tfor(int i=mid;i>=l;i--)\n\t{\n\t\tif(s[i]=='+')v1[i]=(v1[i+1]+1)%MOD,p1[i]=p1[i+1];\n\t\tif(s[i]=='-')v1[i]=(v1[i+1]-1+MOD)%MOD,p1[i]=p1[i+1];\n\t\tif(s[i]=='<')v1[i]=v1[i+1]*inv2%MOD,p1[i]=p1[i+1]*2%MOD;\n\t\tif(s[i]=='>')v1[i]=v1[i+1]*2%MOD,p1[i]=p1[i+1]*inv2%MOD;\n\t}\n\tll now=1;\n\tfor(int i=mid+1;i<=r;i++)\n\t{\n\t\tif(s[i]=='+')v2[i]=(v2[i-1]+now)%MOD;\n\t\tif(s[i]=='-')v2[i]=(v2[i-1]-now+MOD)%MOD;\n\t\tif(s[i]=='<')now=now*inv2%MOD,v2[i]=v2[i-1];\n\t\tif(s[i]=='>')now=now*2%MOD,v2[i]=v2[i-1];\n\t\tmp[v2[i]]++;\n\t}\n\tfor(int i=l;i<=mid;i++)ans+=mp[(v-v1[i]+MOD)*p1[i]%MOD];\n\tfor(int i=mid+1;i<=r;i++)mp[v2[i]]=0;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",s+1);\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tif(s[i]=='+')v=(v+1)%MOD;\n\t\tif(s[i]=='-')v=(v-1+MOD)%MOD;\n\t\tif(s[i]=='<')v=v*inv2%MOD;\n\t\tif(s[i]=='>')v=v*2%MOD;\n\t}\n\tsolve(1,n);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <map>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 999999937; \nconst int MAXN = 250005;\nconst int K = 6;\n\nchar s[MAXN];\n\nint n, X[MAXN][K], IX[MAXN][K], C[K], pos[MAXN];\n\nvector<int> a[MAXN], b[MAXN];\n\nmap<vector<int>, int> mp;\n\nchar rev(char x)\n{\n\tif (x == '<') return '>';\n\tif (x == '>') return '<';\n\tif (x == '+') return '-';\n\tif (x == '-') return '+';\t\n}\n\nint qpow(int a, int b)\n{\n\tint ret = 1;\n\twhile (b)\n\t{\n\t\tif (b & 1) ret = (long long)ret * a % MOD;\n\t\ta = (long long)a * a % MOD;\n\t\tb >>= 1;\t\n\t}\n\treturn ret;\n}\n\nvoid T(int &c, char x, int k)\n{\n\tif (x == '<') c = (long long)c * X[1][k] % MOD;\n\tif (x == '>') c = (long long)c * IX[1][k] % MOD;\n\tif (x == '+') c = (c + 1) % MOD;\n\tif (x == '-') c = (c - 1 + MOD) % MOD;\n}\n\nvoid init()\n{\n\tfor (int i = 0; i < K; i++)\n\t\tX[0][i] = 1;\n\tfor (int i = 0; i < K; i++)\n\t\tX[1][i] = rand() % MOD; // ***************\n\tfor (int i = 2; i < n; i++)\n\t\tfor (int j = 0; j < K; j++)\n\t\t\tX[i][j] = (long long)X[i - 1][j] * X[1][j] % MOD;\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < K; j++)\n\t\t\tIX[i][j] = qpow(X[i][j], MOD - 2);\n\tfor (int i = n; i >= 1; i--)\n\t\tfor (int j = 0; j < K; j++)\n\t\t\tT(C[j], s[i], j);\n//\tcout << \"C: \" << C[0] << endl;\n\tfor (int i = 0; i <= n + 1; i++)\n\t\ta[i].resize(K, 0), b[i].resize(K, 0);\n}\n\nint main()\n{\n\tsrand(2333);\n\tios::sync_with_stdio(false);\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++)\n\t\tcin >> s[i];\n\tinit();\n\tpos[n + 1] = 0;\n\tfor (int i = n; i >= 1; i--)\n\t{\n\t\tfor (int j = 0; j < K; j++)\n\t\t\tb[i][j] = b[i + 1][j];\n\t\tpos[i] = pos[i + 1];\n\t\tswitch (rev(s[i])) \n\t\t{\n\t\t\tcase '<':\n\t\t\t\tpos[i]++;\n\t\t\t\tbreak;\n\t\t\tcase '>':\n\t\t\t\tpos[i]--;\n\t\t\t\tbreak;\n\t\t\tcase '+':\n\t\t\t\tif (pos[i] >= 0)\n\t\t\t\t{\n\t\t\t\t\tfor (int j = 0; j < K; j++)\n\t\t\t\t\t\tb[i][j] = ((long long)b[i][j] + X[pos[i]][j]) % MOD;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfor (int j = 0; j < K; j++)\n\t\t\t\t\t\tb[i][j] = ((long long)b[i][j] + IX[-pos[i]][j]) % MOD;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tif (pos[i] >= 0)\n\t\t\t\t{\n\t\t\t\t\tfor (int j = 0; j < K; j++)\n\t\t\t\t\t\tb[i][j] = ((long long)b[i][j] - X[pos[i]][j] + MOD) % MOD;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfor (int j = 0; j < K; j++)\n\t\t\t\t\t\tb[i][j] = ((long long)b[i][j] - IX[-pos[i]][j] + MOD) % MOD;\n\t\t\t\t}\n\t\t\t\tbreak;\t\n\t\t}\n//\t\tcout << \"b[\" << i << \"]: \" << b[i][0] << endl;\n\t}\n\tfor (int i = n; i > 0; i--)\n\t{\n\t\tfor (int j = 0; j < K; j++)\n\t\t{\n\t\t\tif (pos[i] >= 0)\n\t\t\t\ta[i][j] = ((long long)C[j] * X[pos[i]][j] % MOD + b[i][j]) % MOD;\n\t\t\telse\n\t\t\t\ta[i][j] = ((long long)C[j] * IX[-pos[i]][j] % MOD + b[i][j]) % MOD;\n\t\t}\n//\t\tcout << \"b[\" << i << \"]: \" << b[i][0] << endl;\n\t\tmp[a[i]]++;\n\t}\n\tlong long res = 0;\n\tfor (int i = n; i > 0; i--)\n\t{\n\t\tres += mp[b[i + 1]];\n\t\tmp[a[i]]--;\n\t}\n\tcout << res << endl;\n\treturn 0;\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2)\n#include<bits/stdc++.h>\n#define ll long long\n#define maxn 500005\n#define inf 1e9\n#define eps 1e-10\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,w=1; char c=getchar();\n\twhile(c<'0'||c>'9') {if(c=='-') w=-1; c=getchar();}\n\twhile(c<='9'&&c>='0') {x=(x<<1)+(x<<3)+c-'0'; c=getchar();}\n\treturn w==1?x:-x;\n}\n\nmap <ll,int> p;\nll b[maxn],inv[maxn],ans;\nint len,n;\nchar s[maxn];\nconst ll mod=998244353;\nconst ll P=844009174;\n\ninline ll pw(ll a,ll b)\n{\n\tll ans=1,base=a;\n\twhile(b)\n\t{\n\t\tif(b&1) ans=(ans*base)%mod;\n\t\tbase=(base*base)%mod; b>>=1;\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\t//freopen(\"t1.out\",\"w\",stdout);\n\tn=read(); scanf(\"%s\",s+1); b[0]=1; inv[0]=1; len=strlen(s+1);\n\tfor(int i=1;i<=maxn-5;i++) b[i]=(b[i-1]*233)%mod,inv[i]=pw(b[i],mod-2);\n\t//cout<<571216159*inv[1]%mod<<endl;\n\tll ed=0,nw=250000;\n\t\n\t//cout<<b[nw-1]+b[nw+1]<<endl;\n\t\n\tfor(int i=1;i<=len;i++)\n\t{\n\t\tif(s[i]=='+') ed=(ed+b[nw])%mod;\n\t\telse if(s[i]=='-') ed=(ed-b[nw])%mod;\n\t\telse if(s[i]=='>') nw++;\n\t\telse if(s[i]=='<') nw--; p[ed]++;\n\t\t//cout<<s[i]<<\" \"<<ed<<\" \"<<nw<<endl;\n\t}\n\t//cout<<ed<<\" \"<<nw<<endl<<endl;\n\tll tmp=0; nw=250000; ans=0;\n\tfor(int i=1;i<=len;i++)\n\t{\n\t\tll p2=0;\n\t\tif(nw>=250000) p2=(p2*b[nw-250000])%mod;\n\t\telse p2=(p2*inv[250000-nw])%mod;\n\t\tans+=p[(tmp+ed*b[nw-250000])%mod];\n\t\t//ans+=p[(tmp+ed*b[nw])%mod];\n\t\tif(s[i]=='+') tmp=(tmp+b[nw])%mod;\n\t\telse if(s[i]=='-') tmp=(tmp-b[nw])%mod;\n\t\telse if(s[i]=='>') nw++;\n\t\telse if(s[i]=='<') nw--;\n\t\t//ans+=p[(tmp+ed*b[nw-250000])%mod];\n\t\t//cout<<(tmp+ed*b[nw-250000])%mod<<\" \"<<tmp<<\" \"<<nw<<\" \"<<ans<<endl;\n\t\tp[tmp]--;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Rint register int\nusing namespace std;\ntypedef long long LL;\ntypedef __int128 I128;\nconst int N = 250003;\nconst LL mod = 1000000000000000031ll, X = 1000000000000000003ll, inv = 821428571428571454ll;\nint n, a[N];\nLL ans, p[N], val[N];\nchar str[N];\nmap<LL, int> tong;\ninline void upd(LL &a, LL b){a += b; if(a >= mod) a -= mod;}\ninline LL add(LL a, LL b){return (a + b >= mod) ? (a + b - mod) : (a + b);}\nint main(){\n\tscanf(\"%d%s\", &n, str + 1);\n\tp[0] = 1;\n\tfor(Rint i = 1;i <= n;i ++){\n\t\tp[i] = p[i - 1]; val[i] = val[i - 1];\n\t\tif(str[i] == '+') upd(val[i], p[i]);\n\t\telse if(str[i] == '-') upd(val[i], mod - p[i]);\n\t\telse if(str[i] == '<') p[i] = (I128) p[i] * inv % mod;\n\t\telse if(str[i] == '>') p[i] = (I128) p[i] * X % mod;\n\t}\n\tfor(Rint i = n;i;i --){\n\t\t++ tong[val[i]];\n\t\tans += tong[add((I128) p[i - 1] * val[n] % mod, val[i - 1])];\n\t}\n\tprintf(\"%lld\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <map>\n#define MN 250005\n\nconst long long mod = 213668850274623167;\nconst long long base = 257;\nchar s[MN];\nlong long c[MN];\nlong long fac[MN], inv[MN];\nstd::map<long long, int> mp;\n\nlong long mul(long long a, long long b)\n{\n\ta = (a + mod) % mod;\n\tb = (b + mod) % mod;\n\treturn (a * b - (long long)((long double) a / mod * b) * mod + mod) % mod;\n}\n\nlong long qpow(long long x, long long p)\n{\n\tlong long ans = 1;\n\twhile(p)\n\t{\n\t\tif(p & 1) ans = mul(ans, x);\n\t\tx = mul(x, x); p >>= 1;\n\t}\n\treturn ans;\n}\n\nvoid add(int x, int o, long long &now)\n{\n\tlong long u;\n\tif(x < 0) u = inv[-x];\n\telse u = fac[x];\n\tnow = (mul(u, o) + now) % mod;\n}\n\nint main()\n{\n\tint n; scanf(\"%d\", &n);\n\tscanf(\"%s\", s);\n\tlong long p = 0, now = 0;\n\tinv[1] = qpow(base, mod - 2);\n\tfac[0] = 1; fac[1] = base;\n\tfor(int i = 2; i <= n; i++) inv[i] = mul(inv[i - 1], inv[1]), fac[i] = mul(fac[i - 1], fac[1]);\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif(s[i] == '<') p--;\n\t\tif(s[i] == '>') p++;\n\t\tif(s[i] == '+') add(p, 1, now);\n\t\tif(s[i] == '-') add(p, -1, now);\n\t}\n\tlong long e = now; p = 0; now = 0;\n\tmp[e]++;\n\tlong long ans = 0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif(s[i] == '<') p--;\n\t\tif(s[i] == '>') p++;\n\t\tif(s[i] == '+') add(p, 1, now);\n\t\tif(s[i] == '-') add(p, -1, now);\n\t\tlong long u;\n\t\tif(p < 0) u = inv[-p];\n\t\telse u = fac[p];\n\t\tans += mp[now];\n\t\tmp[(mul(e, u) + now ) % mod]++;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n// need\n#include <iostream>\n#include <algorithm>\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <unordered_map>\n#include <unordered_set>\n#include <array>\n// stream\n//#include <istream>\n#include <sstream>\n//#include <ostream>\n#include <fstream>\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest& ...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int w_=0; w_<n; ++w_){MACRO_VEC_ROW_Scan(w_, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest& ...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest& ...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& R:c)for(auto& w:R)std::cin>>w;\n// output\n#define OUT(dist) std::cout<<(dist);\n#define FOUT(n, dist) std::cout<<std::fixed<<std::setprecision(n)<<(dist);\n#define SOUT(n, c, dist) std::cout<<std::setw(n)<<std::setfill(c)<<(dist);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(w, n) std::cout<<(w + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(dist) {std::cerr << #dist << \"\\t:\" << (dist) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(w, a, n) for(int w=(a);w<(n);++w)\n#define RFOR(w, a, n) for(int w=(n)-1;w>=(a);--w)\n#define REP(w, n) for(int w=0;w<int(n);++w)\n#define RREP(w, n) for(int w=int(n)-1;w>=0;--w)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<class T> inline T CHMAX(T & a, const T b) { return a = (a < b) ? b : a; }\ntemplate<class T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\n//void CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n// test\ntemplate<class T> using V = std::vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n#define random_shuffle \"USE std::shuffle!\";\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = (1 << 30) - 1;                    // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-10;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T & val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T & val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T> & a, const T & val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>> & a, const T & val) { for (auto& b : a) FILL(b, val); }\n// ------------>8------------------------------------->8------------\n\nnamespace Test {\n\tsigned main() {\n\t\t//VAR(int, n);\n//VAR(std::string, s);\n\t\tstd::string S = \"+-<>\";\n\t\tconst int n = 50;\n\t\tauto system_now = std::chrono::system_clock::now();\n\t\tstd::mt19937 mt(std::chrono::duration_cast<std::chrono::microseconds>(system_now.time_since_epoch()).count());\n\t\tstd::uniform_int_distribution<> rand(/* min */0, /* max */3);\n\t\tstd::string s;\n\t\tREP(_, n) s += S[rand(mt)];\n\n\t\tauto get = [&](int l, int r) {\n\t\t\tstd::map<int, int> map;\n\t\t\tint p = 0;\n\t\t\tFOR(i, l, r) {\n\t\t\t\t/* */if (s[i] == '+') { if (++map[p] == 0) map.erase(p); }\n\t\t\t\telse if (s[i] == '-') { if (--map[p] == 0) map.erase(p); }\n\t\t\t\telse if (s[i] == '>') ++p;\n\t\t\t\telse if (s[i] == '<') --p;\n\t\t\t}\n\n\t\t\treturn map;\n\t\t};\n\n\t\tauto sub = [&](std::map<int, int> a, const std::map<int, int> b) {\n\t\t\tfor (auto& p : b) {\n\t\t\t\tif ((a[p.first] -= p.second) == 0) a.erase(p.first);\n\t\t\t}\n\t\t\treturn a;\n\t\t};\n\n\t\tauto print = [&](std::map<int, int> map) {\n\t\t\tFOR(i, -10, 20) {\n\t\t\t\tOUT(map[i])SPBR(i, 20);\n\t\t\t}\n\t\t};\n\n\t\tVAR(int, l, r);\n\n\t\tOUT(s)BR;\n\t\tREP(i, n) {\n\t\t\tchar c = ' ';\n\t\t\tif (IN(l, i, r)) c = '*';\n\t\t\tOUT(c);\n\t\t}BR;\n\t\tprint(get(l, r));\n\t\tprint(sub(get(0, r), get(0, l)));\n\t\treturn 0;\n\t}\n}\n\nll powMod(ll n, ll p, ll mod) {\n\tif (p < 0) p += mod - 1;\n\tn %= mod;\n\tll res = 1;\n\twhile (p) {\n\t\tif (p & 1) (res *= n) %= mod;\n\t\t(n *= n) %= mod;\n\t\tp >>= 1;\n\t}\n\treturn res;\n}\n\nconstexpr int N = 3;\nconstexpr int M[N] = { 1000000009, 1000000021, 1000000033 };\nconstexpr int B = 123457;\n\nstruct Hash {\n\tint val[N];\n\tHash& norm() {\n\t\tREP(i, N) if ((val[i] %= M[i]) < 0) val[i] += M[i];\n\t\treturn *this;\n\t}\n\n\tHash(int x) { REP(i, N) val[i] = x; norm(); }\n\tHash() : Hash(0) {}\n\n\tstatic Hash makePow(int n, int p) {\n\t\tHash res;\n\t\tREP(i, N) res.val[i] = powMod(n, p, M[i]);\n\t\treturn res;\n\t}\n\tstatic Hash makeInv(int x) {\n\t\tHash res;\n\t\tREP(i, N) res.val[i] = powMod(x, M[i] - 2, M[i]);\n\t\treturn res;\n\t}\n\n\tbool operator==(const Hash & r) const { return *this == r; }\n\tbool operator<(const Hash & r) const { \n\t\tREP(i, N) if(this->val[i] != r.val[i]) return this->val[i] < r.val[i];\n\t\treturn false;\n\t}\n\tHash& operator+=(const Hash & r) { REP(i, N) val[i] += r.val[i]; norm(); return *this; }\n\tHash& operator-=(const Hash & r) { REP(i, N) val[i] -= r.val[i]; norm(); return *this; }\n\tHash& operator*=(const Hash & r) { REP(i, N) val[i] *= r.val[i]; norm(); return *this; }\n\tHash& operator/=(const Hash & r) { \n\t\tREP(i, N) val[i] *= powMod(r.val[i], M[i] - 2, M[i]); \n\t\tnorm(); \n\t\treturn *this; \n\t}\n};\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n);\n\tVAR(std::string, s);\n\n\tHash X;\n\t{\n\t\tint p = 0;\n\t\tREP(i, n) {\n\t\t\t/* */if (s[i] == '+') X += Hash::makePow(B, p);\n\t\t\telse if (s[i] == '-') X -= Hash::makePow(B, p);\n\t\t\telse if (s[i] == '>') ++p;\n\t\t\telse if (s[i] == '<') --p;\n\t\t}\n\t}\n\n\tstd::map<Hash, int> map;\n\t++map[X];\n\tint ans = 0;\n\tHash A;\n\t{\n\t\tint p = 0;\n\t\tREP(i, n) {\n\t\t\t/* */if (s[i] == '+') A += Hash::makePow(B, p);\n\t\t\telse if (s[i] == '-') A -= Hash::makePow(B, p);\n\t\t\telse if (s[i] == '>') ++p;\n\t\t\telse if (s[i] == '<') --p;\n\t\t\tans += map[A];\n\t\t\t{\n\t\t\t\tauto tX(X);\n\t\t\t\ttX /= Hash::makePow(B, -p);\n\t\t\t\ttX += A;\n\t\t\t\t++map[tX];\n\t\t\t}\n\t\t}\n\t}\n\tOUT(ans)BR;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e6+5;\nconst int mod1=1e9+7;\nconst int P1=19260817;\nconst int P2=998244353;\nconst int mod2=1004535809;\n#define ll long long\ntypedef pair<ll,ll>Pi;\nll fsp(ll x,int y){\n\tll ans=1;\n\twhile(y){\n\t\tif(y&1)\tans=ans*x%mod1;\n\t\tx=x*x%mod1,y>>=1;\n\t}\n\treturn ans;\n}\nll ksm(ll x,int y){\n\tll ans=1;\n\twhile(y){\n\t\tif(y&1)\tans=ans*x%mod2;\n\t\tx=x*x%mod2,y>>=1;\n\t}\n\treturn ans;\n}\nchar s[N];\nmap<Pi,int>ma;\nll n,l1,l2=1,r1,r2=1,ans,res1,res2,add1,add2,inv1,inv2;\nint main(){\n\n\tscanf(\"%lld%s\",&n,s+1);\n\tadd1=fsp(P1,n);add2=ksm(P2,n);\n\tinv1=fsp(P1,mod1-2),inv2=ksm(P2,mod2-2);\n\tfor(int i=n;i;i--){\n\t\tif(s[i]=='-'){\n\t\t\tres1=(res1-add1+mod1)%mod1;\n\t\t\tres2=(res2-add2+mod2)%mod2;\n\t\t}\n\t\tif(s[i]=='+'){\n\t\t\tres1=(res1+add1)%mod1;\n\t\t\tres2=(res2+add2)%mod2;\n\t\t}\n\t\tif(s[i]=='<'){\n\t\t\tres1=res1*inv1%mod1;\n\t\t\tres2=res2*inv2%mod2;\n\t\t}\n\t\tif(s[i]=='>'){\n\t\t\tres1=res1*P1%mod1;\n\t\t\tres2=res2*P2%mod2;\n\t\t}\n\t}\n\tfor(int i=n;i;i--){\n\t\tll k1=0,k2=0;\n\t\tif(s[i]=='-'){\n\t\t\tl1=(l1-add1+mod1)%mod1,k1=mod1-add1;\n\t\t\tr1=(r1-add2+mod2)%mod2,k2=mod2-add2;\n\t\t}\n\t\tif(s[i]=='<'){\n\t\t\tl1=l1*inv1%mod1,l2=l2*inv1%mod1;\n\t\t\tr1=r1*inv2%mod2,r2=r2*inv2%mod2;\n\t\t}\n\t\tif(s[i]=='>'){\n\t\t\tl1=l1*P1%mod1,l2=l2*P1%mod1;\n\t\t\tr1=r1*P2%mod2,r2=r2*P2%mod2;\n\t\t}\n\t\tif(s[i]=='+'){\n\t\t\tl1=(l1+add1)%mod1,k1=add1;\n\t\t\tr1=(r1+add2)%mod2,k2=add2;\n\t\t}\n\t\t++ma[Pi((k1-l1+mod1)*fsp(l2,mod1-2)%mod1,(k2-r1+mod2)*ksm(r2,mod2-2)%mod2)];\n\t\tans+=ma[Pi((res1-l1+mod1)*fsp(l2,mod1-2)%mod1,(res2-r1+mod2)*ksm(r2,mod2-2)%mod2)];\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define p1 19260817\n#define p2 19491001\n#define m1 666623333\n#define m2 1004535809\nusing namespace std;\nint head[1048577],nxt[500005],tot=0;\nint w1[500005],w2[500005],w[500005];\nint a1[250005],b1[250005];\nint a2[250005],b2[250005];\nchar s[250005];\nll ans=0;\ninline int qpow(int a,int b,int mod)\n{int res=1,tp=a;\nwhile (b)\n{if (b&1) res=1ll*res*tp%mod;\ntp=1ll*tp*tp%mod;b>>=1;\n}\nreturn res;\n}\ninline void add(int v1,int v2)\n{int bel=(1ll*v1*p1+v2)&1048575,i;\nfor (i=head[bel];i;i=nxt[i])\n{if (w1[i]==v1&&w2[i]==v2) {w[i]++;return;}\n}\ntot++;nxt[tot]=head[bel];head[bel]=tot;\nw1[tot]=v1;w2[tot]=v2;w[tot]=1;\n}\ninline int ask(int v1,int v2)\n{int bel=(1ll*v1*p1+v2)&1048575,i;\nfor (i=head[bel];i;i=nxt[i])\n{if (w1[i]==v1&&w2[i]==v2) return w[i];\n}\nreturn 0;\n}\ninline int sub1(int a,int b)\n{return (a-b<0?a-b+m1:a-b);}\ninline int sub2(int a,int b)\n{return (a-b<0?a-b+m2:a-b);}\ninline int add1(int a,int b)\n{return (a+b>=m1?a+b-m1:a+b);}\ninline int add2(int a,int b)\n{return (a+b>=m2?a+b-m2:a+b);}\nint main (){\n\tint i,n,x1=0,x2=0;\n\tscanf (\"%d\",&n);\n\tscanf (\"%s\",s+1);\n\ta1[n+1]=1;b1[n+1]=0;\n\ta2[n+1]=1;b2[n+1]=0;\n\tint inv1=qpow(p1,m1-2,m1);\n\tint inv2=qpow(p2,m2-2,m2);\n\tfor (i=n;i>=1;i--)\n\t{if (s[i]=='<') \n\t{a1[i]=1ll*a1[i+1]*p1%m1;\n\ta2[i]=1ll*a2[i+1]*p2%m2;\n\tb1[i]=b1[i+1];b2[i]=b2[i+1];\n\tcontinue;\n\t}\n\tif (s[i]=='>')\n\t{a1[i]=1ll*a1[i+1]*inv1%m1;\n\ta2[i]=1ll*a2[i+1]*inv2%m2;\n\tb1[i]=b1[i+1];b2[i]=b2[i+1];\n\tcontinue;\n\t}\n\tif (s[i]=='+')\n\t{b1[i]=sub1(b1[i+1],a1[i+1]);\n\tb2[i]=sub2(b2[i+1],a2[i+1]);\n\ta1[i]=a1[i+1];a2[i]=a2[i+1];\n\tcontinue;\n\t}\n\tb1[i]=add1(b1[i+1],a1[i+1]);\n\tb2[i]=add2(b2[i+1],a2[i+1]);\n\ta1[i]=a1[i+1];a2[i]=a2[i+1];\n\t}\n\tfor (i=n;i>=1;i--)\n\t{if (s[i]=='+') {x1=add1(x1,1);x2=add2(x2,1);continue;}\n\tif (s[i]=='-') {x1=sub1(x1,1);x2=sub2(x2,1);continue;}\n\tif (s[i]=='<') {x1=1ll*x1*inv1%m1;x2=1ll*x2*inv2%m2;continue;}\n\tx1=1ll*x1*p1%m1;x2=1ll*x2*p2%m2;\n\t}\n\tadd(0,0);\n\tfor (i=n;i>=1;i--)\n\t{int r1=(1ll*a1[i]*x1+b1[i])%m1;\n\tint r2=(1ll*a2[i]*x2+b2[i])%m2;\n\tans+=ask(r1,r2);\n\tadd(b1[i],b2[i]);\n\t}\n\tprintf (\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 250010;\nconst int mod[] = {1000000007, 1000000009};\nconst int P[] = {131, 233};\n\ntypedef long long LL;\n\nint Pow[2][N * 2]; char s[N];\n\ninline int FUCK(int x, int y, int mod) {\n    int res = 1;\n    for (; y; y >>= 1, x = (LL)x * x % mod) if (y & 1) res = (LL)res * x % mod;\n    return res;\n}\n\nstruct Data {\n    int val[2];\n\n    Data(int a = 0, int b = 0) {val[0] = a, val[1] = b;} \n\n    Data operator + (const Data &b) {\n        Data res;\n        res.val[0] = (val[0] + b.val[0]) % mod[0];\n        res.val[1] = (val[1] + b.val[1]) % mod[1];\n        return res;\n    }\n\n    Data operator - (const Data &b) {\n        Data res;\n        res.val[0] = (val[0] - b.val[0] + mod[0]) % mod[0];\n        res.val[1] = (val[1] - b.val[1] + mod[1]) % mod[1]; \n        return res;\n    }\n\n    Data operator * (const int b) {\n        Data res = *this;\n        int a = b >= 0 ? Pow[0][b] : FUCK(P[0], (LL)(mod[0] - 2) * (-b) % (mod[0] - 1), mod[0]);\n        int c = b >= 0 ? Pow[1][b] : FUCK(P[1], (LL)(mod[1] - 2) * (-b) % (mod[1] - 1), mod[1]);\n        res.val[0] = (LL)res.val[0] * a % mod[0];\n        res.val[1] = (LL)res.val[1] * c % mod[1];\n        return res;\n    }\n\n    bool operator < (const Data &b) const {\n        if (val[0] != b.val[0]) return val[0] < b.val[0];\n        return val[1] < b.val[1];\n    }\n};\n\nmap<Data, int> mp;\n\ninline void increase(Data &a, int b) {\n    a = a + (Data){Pow[0][b], Pow[1][b]};\n}\n\ninline void decrease(Data &a, int b) {\n    a = a - (Data){Pow[0][b], Pow[1][b]};\n}\n\nint main() {\n    int n; scanf(\"%d%s\", &n, s + 1); Data all;\n    Pow[0][0] = Pow[1][0] = 1;\n    for (int i = 0; i <= 1; i++)\n        for (int j = 1; j <= n * 2; j++)\n            Pow[i][j] = (LL)Pow[i][j - 1] * P[i] % mod[i];\n    for (int i = 1, ls = 0; i <= n; i++) {\n        if (s[i] == '<') ls--;\n        else if (s[i] == '>') ls++;\n        else if (s[i] == '+') increase(all, ls + n);\n        else decrease(all, ls + n);\n    }\n    Data fuck; mp[all] = 1; LL res = 0;\n    for (int i = 1, ls = 0; i <= n; i++) {\n        if (s[i] == '<') ls--;\n        else if (s[i] == '>') ls++;\n        else if (s[i] == '+') increase(fuck, ls + n);\n        else decrease(fuck, ls + n);\n        res += mp[fuck], mp[fuck + all * ls]++;\n    }\n    printf(\"%lld\\n\", res);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define MAX 250002\n\nint n;\nchar buf[MAX];\n\n\nstring s;\n\nint ar[MAX * 2];\n\nint dif[MAX * 2];\n\nmap<int, int> mp;\n\nint main() {\n\tcin >> n;\n\tscanf(\"%s\", buf);\n\ts = buf;\n\tint pos = MAX;\n\tfor (int i = 0; i < s.size(); i++) {\n\t\tif (s[i] == '<') {\n\t\t\tpos--;\n\t\t}\n\t\tif (s[i] == '>') {\n\t\t\tpos++;\n\t\t}\n\t\tif (s[i] == '+') {\n\t\t\tar[pos]++;\n\t\t}\n\t\tif (s[i] == '-') {\n\t\t\tar[pos]--;\n\t\t}\n\t}\n\tfor (int i = s.size() - 1; i >= 0; i--) {\n\t\tif (s[i] == '<') {\n\t\t\tpos++;\n\t\t}\n\t\tif (s[i] == '>') {\n\t\t\tpos--;\n\t\t}\n\t\tif (s[i] == '+') {\n\t\t\tdif[pos]--;\n\t\t}\n\t\tif (s[i] == '-') {\n\t\t\tdif[pos]++;\n\t\t}\n\t\tif (dif[pos]) {\n\t\t\tmp[pos] = -dif[pos];\n\t\t}\n\t\telse {\n\t\t\tif (mp.count(pos))mp[pos] = 0;\n\t\t}\n\n\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int mo = 998244353, X = 1e4 + 7, Y = 1e7 + 7;\nconst int N = 2.5e5 + 10;\nint n;\nll cnt[N], pre[N], X1, cnt2[N], pre2[N], Y1;\nchar s[N];\nll ksm(ll x, ll y) {\n\tll ret = 1; for (; y; y >>= 1) {\n\t\tif (y & 1) ret = ret * x % mo;\n\t\tx = x * x % mo;\n\t}\n\treturn ret;\n}\n\nmap<pair<ll,ll>,int> h;\npair<ll,ll> tj(int x) {\n\treturn make_pair(((pre[n] * cnt[x] % mo + pre[x]) % mo + mo) % mo,\n\t\t((pre2[n] * cnt2[x] % mo + pre2[x]) % mo + mo) % mo);\n}\n\nint main() {\n\tcin >> n;\n\tscanf(\"%s\", s + 1);\n\tcnt[0] = 1;\n\tcnt2[0] = 1;\n\tX1 = ksm(X, mo - 2); Y1 = ksm(Y, mo - 2);\n\tfor(int i = 1; i <= n; i++) {\n\t\tcnt[i] = cnt[i - 1];\n\t\tpre[i] = pre[i - 1];\n\t\tcnt2[i] = cnt2[i - 1];\n\t\tpre2[i] = pre2[i - 1];\n\t\tif (s[i] == '>') {\n\t\t\tcnt[i] = cnt[i] * X % mo;\n\t\t\tcnt2[i] = cnt2[i] * Y % mo;\n\t\t} else if (s[i] == '<') {\n\t\t\tcnt[i] = cnt[i] * X1 % mo;\n\t\t\tcnt2[i] = cnt2[i] * Y1 % mo;\n\t\t} else if (s[i] == '+') {\n\t\t\tpre[i] = (pre[i] + cnt[i]) % mo;\n\t\t\tpre2[i] = (pre2[i] + cnt2[i]) % mo;\n\t\t} else {\n\t\t\tpre[i] = (pre[i] - cnt[i]) % mo;\n\t\t\tpre2[i] = (pre2[i] - cnt2[i]) % mo;\n\t\t}\n\t}\n\tll ans = 0;\n\th[tj(0)] = 1;\n\tfor(int i = 1; i <= n; i++) {\n\t\tpre[i] = (pre[i] + mo) % mo;\n\t\tpre2[i] = (pre2[i] + mo) % mo;\n\t\tans += h[make_pair(pre[i], pre2[i])];\n\t\th[tj(i)] ++;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mp make_pair\n#define fi first\n#define se second\nint n;\nstring s;\nlong long ans=0,prd[2][250007],cur1=1,cur2=1,cnt[250007];\nmap < pair<long long,long long> ,long long> val;\nconst long long mod1=1e9+7,mod2=1e9+9;\nconst long long base=500007;\nconst long long inv1=433573933, inv2=446715750;\nlong long pw(long long a,long long b,long long mod){\n\tif(b==0) return 1LL;\n\tif(b==1) return a;\n\tlong long ret=pw(a,b/2,mod);\n\tif(b%2==0) return ret*ret%mod;\n\treturn ret*ret%mod*a%mod;\n}\nint main(){\n\tios_base::sync_with_stdio(0);\n\t//cout<<pw(base,mod1-2,mod1)<<endl;\n\t//cout<<pw(base,mod2-2,mod2)<<endl;\n\tcin>>n;\n\tcin>>s;\n\tfor(int i=1;i<=n;i++){\n\t\tcnt[i]=cnt[i-1];\n\t\tprd[0][i]=prd[0][i-1];\n\t\tprd[1][i]=prd[1][i-1];\n\t\tif(s[i-1]=='>'){\n\t\t\tcur1=(cur1*base)%mod1;\n\t\t\tcur2=(cur2*base)%mod2;\n\t\t\tcnt[i]++;\n\t\t}\n\t\telse if(s[i-1]=='<'){\n\t\t\tcur1=(cur1*inv1)%mod1;\n\t\t\tcur2=(cur2*inv2)%mod2;\n\t\t\tcnt[i]--;\n\t\t}\n\t\telse if(s[i-1]=='+'){\n\t\t\tprd[0][i]=(prd[0][i]+cur1)%mod1;\n\t\t\tprd[1][i]=(prd[1][i]+cur2)%mod2;\n\t\t}\n\t\telse{\n\t\t\tprd[0][i]=(prd[0][i]-cur1+mod1)%mod1;\n\t\t\tprd[1][i]=(prd[1][i]-cur2+mod2)%mod2;\n\t\t}\n\t}\n\tfor(int i=n;i>=1;i--){\n\t\tval[mp(prd[0][i],prd[1][i])]++;\n\t\tlong long dif=cnt[0]-cnt[i-1];\n\t\tlong long val1=0,val2=0;\n\t\t//cout<<dif<<\" \";\n\t\tif(dif>=0){\n\t\t\tval1=(prd[0][i-1]+prd[0][n]*pw(inv1,dif,mod1)%mod1)%mod1;\n\t\t\tval2=(prd[1][i-1]+prd[1][n]*pw(inv2,dif,mod2)%mod2)%mod2;\n\t\t}\n\t\telse{\n\t\t\tval1=(prd[0][i-1]+prd[0][n]*pw(base,-dif,mod1)%mod1)%mod1;\n\t\t\tval2=(prd[1][i-1]+prd[1][n]*pw(base,-dif,mod2)%mod2)%mod2;\n\t\t}\n\t\tans+=val[mp(val1,val2)];\n\t\t//cout<<ans<<endl;\n\t}\n\tcout<<ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\n \nll pow_mod(ll x,int k,ll MOD) {\n  ll ans=1;\n  while (k) {\n  \tif (k&1) ans=ans*x%MOD;\n  \tx=x*x%MOD;\n  \tk>>=1;\n  }\n  return ans;\n}\n \nconst int prime[10]={998244353,998244353,998244353,998244353,998244353,998244353,998244353,998244353,998244353,998244353};\nconst ll H[10]={19260817,19260817,19260817,19260817,19260817,19260817,19260817,19260817,19260817,19260817};\n \nint powd[10][1000005],invd[10][1000005];\n \nvoid pre(int n) {\n  for(int i=0;i<10;i++) {\n    ll inv=pow_mod(H[i],prime[i]-2,prime[i]);\n    powd[i][0]=1;\n    for(int j=1;j<=n;j++) powd[i][j]=(ll)powd[i][j-1]*H[i]%prime[i];\n    invd[i][0]=1;\n    for(int j=1;j<=n;j++) invd[i][j]=(ll)invd[i][j-1]*inv%prime[i];\n  }\n}\n \nstruct Data {\n  int num[10];\n  Data() {memset(num,0,sizeof(num));}\n  Data operator + (Data b) {\n  \tData c;\n  \tfor(int i=0;i<10;i++) c.num[i]=(num[i]+b.num[i])%prime[i];\n  \treturn c;\n  }\n  void add(int x) {\n  \tfor(int i=0;i<10;i++) num[i]=(num[i]+powd[i][x])%prime[i];\n  }\n  void dec(int x) {\n  \tfor(int i=0;i<10;i++) num[i]=(num[i]-powd[i][x]+prime[i])%prime[i];\n  }\n  void rshift(int x) {\n  \tfor(int i=0;i<10;i++) num[i]=(ll)num[i]*powd[i][x]%prime[i];\n  }\n  void lshift(int x) {\n  \tfor(int i=0;i<10;i++) num[i]=(ll)num[i]*invd[i][x]%prime[i];\n  }\n  bool operator < (const Data & b) const {\n  \tfor(int i=0;i<10;i++)\n  \t  if (num[i]!=b.num[i]) return num[i]<b.num[i];\n  \treturn 0;\n  }\n};\n \nmap <Data,int> mp;\nData p[250005];\n \nchar str[250005];\n \nint main() {\n  int n;\n  scanf(\"%d%s\",&n,str+1);\n  pre(4*n);\n  int d=0;\n  for(int i=1;i<=n;i++) {\n  \tp[i]=p[i-1];\n    if (str[i]=='+') p[i].add(2*n+d);\n    else if (str[i]=='-') p[i].dec(2*n+d);\n    else if (str[i]=='>') d++;\n    else d--;\n    mp[p[i]]++;\n  }\n  ll ans=0;\n  d=0;\n  for(int i=1;i<=n;i++) {\n  \tData t=p[n];\n  \tif (d>=0) t.rshift(d); else t.lshift(-d);\n\tt=t+p[i-1];\n\tif (mp.count(t)) ans+=mp[t];\n\tif (str[i]=='>') d++;\n\telse if (str[i]=='<') d--;\n\tmp[p[i]]--;\n  }\n  printf(\"%lld\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\nconst int P=998244353;\ninline void upd(R int &x,R int y){(x+=y)>=P?x-=P:0;}\ninline int inc(R int x,R int y){return x+y>=P?x+y-P:x+y;}\ninline int dec(R int x,R int y){return x-y<0?x-y+P:x-y;}\ninline int mul(R int x,R int y){return 1ll*x*y-1ll*x*y/P*P;}\nint ksm(R int x,R int y){\n\tR int res=1;\n\tfor(;y;y>>=1,x=mul(x,x))(y&1)?res=mul(res,x):0;\n\treturn res;\n}\ntypedef long long ll;\nconst int N=5e5+5,M=2.5e5;\nconst int bas[6]={691,769,823,877,911,967};\nconst int ib[6]={37560569,983965175,992179685,349442436,115055606,356147158};\nstruct node{\n\tint a[6];\n\tinline int& operator [](const int &x){return a[x];}\n\tinline bool operator <(const node &b)const{\n\t\tfp(i,0,5)if(a[i]!=b.a[i])return a[i]<b.a[i];\n\t\treturn 0;\n\t}\n\tinline bool operator ==(const node &b)const{\n\t\tfp(i,0,5)if(a[i]!=b.a[i])return 0;\n\t\treturn 1;\n\t}\n}pr[N],bn[N],sm;\nchar s[N];int pos[N],n;\nmap<node,int>mp;ll res;\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin);\n\tscanf(\"%d%s\",&n,s+1);\n\tfp(j,0,5)bn[M][j]=1;\n\tfp(i,1,n)fp(j,0,5){\n\t\tbn[i+M][j]=mul(bn[i-1+M][j],bas[j]);\n\t\tbn[-i+M][j]=mul(bn[-i+1+M][j],ib[j]);\n\t}\n\tfor(R int p=0,i=1;i<=n;++i){\n\t\tswitch(s[i]){\n\t\t\tcase '>':++p;break;\n\t\t\tcase '<':--p;break;\n\t\t\tcase '+':{\n\t\t\t\tfp(j,0,5)upd(sm[j],bn[p+M][j]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase '-':{\n\t\t\t\tfp(j,0,5)upd(sm[j],P-bn[p+M][j]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfp(j,0,5)pr[i][j]=sm[j];\n\t\tpos[i]=p;\n\t}\n\t++mp[sm];\n\tfp(i,1,n){\n\t\tres+=mp[pr[i]];\n\t\tfp(j,0,5)upd(pr[i][j],mul(sm[j],bn[pos[i]+M][j]));\n\t\t++mp[pr[i]];\n\t}\n\tprintf(\"%lld\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define R register\n\ntypedef long long ll;\ntypedef std::pair<int, int> pii;\n\nint n;\nstd::string s;\n\ninline int pw(int, int);\n\nconst int P = 998244853, p2 = 233, p3 = 43, invp2 = pw(p2, P - 2);\n\ninline int pw(int x, int k) {\n\tR int res = 1;\n\tfor (; k; k >>= 1, x = (ll)x * x % P)\n\t\tif (k & 1) res = (ll)res * x % P;\n\treturn res;\n}\n\n\nstd::unordered_map<int, int> mp;\n\nll ans;\n\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\n\tstd::cin >> n >> s;\n\n\tR ll res = 0;\n\tR int cnt = 0;\n\n\tfor (R int i = 0; i < n; ++i) {\n\t\tswitch(s[i]) {\n\t\t\tcase '+' : res += p3; res >= P ? res -= P : 0; break;\n\t\t\tcase '-' : res -= p3; res < 0 ? res += P : 0; break;\n\t\t\tcase '>' : res *= p2; ++cnt; res %= P; break;\n\t\t\tcase '<' : res *= invp2; --cnt; res %= P; break;\n\t\t}\n\t\tR int k = res * pw(cnt > 0 ? invp2 : p2, cnt < 0 ? -cnt : cnt) % P;\n\t//\tprintf(\"%d %d \", k, cnt);\n\t\t++mp[k];\n\t//\tprintf(\"%lld\\n\", res);\n\t}\n\t\n\tR ll res2 = 0;\n\tR int cnt2 = 0;\n\tans += mp[res];\n\tfor (R int i = 0; i < n; ++i) {\n\t\tswitch(s[i]) {\n\t\t\tcase '+' : res2 += p3; res2 >= P ? res2 -= P : 0;break;\n\t\t\tcase '-' : res2 -= p3; res2 < 0 ? res2 += P : 0; break;\n\t\t\tcase '>' : res2 *= p2; ++cnt2; res2 %= P; break;\n\t\t\tcase '<' : res2 *= invp2; --cnt2; res2 %= P; break;\n\t\t}\n\t\tR int k = res2 * pw(cnt2 > 0 ? invp2 : p2, cnt2 < 0 ? -cnt2 : cnt2) % P ;\n\t\t--mp[k];\n\t\tk = (res2 * pw(cnt < 0 ? invp2 : p2, cnt < 0 ? -cnt : cnt) % P + res) % P ;\n\t//\tprintf(\"%lld %d %d \",res2, k, cnt + cnt2);\n\t\tk = (ll)k * pw(cnt + cnt2 > 0 ? invp2 : p2, cnt + cnt2 < 0 ? -cnt-cnt2 : cnt+cnt2) % P;\n\t\tif (mp.find(k) != mp.end())\n\t\t\tans += mp[k]; \n\t//\tprintf(\"%d\\n\", k);\n\t}\n\t\n\tstd::cout << ans << std::endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int mod = 1000000009;\nconst int arg1 = 1519153;\nconst int Maxn = 250005;\n\nint iarg1;\nint n;\nchar S[Maxn];\nint A[Maxn], B[Maxn];\nmap <int, int> M;\nll res;\n\nint toPower(int a, int p)\n{\n\tint res = 1;\n\twhile (p) {\n\t\tif (p & 1) res = ll(res) * a % mod;\n\t\tp >>= 1; a = ll(a) * a % mod;\n\t}\n\treturn res;\n}\n\nint Inv(int a) { return toPower(a, mod - 2); }\n\nint main()\n{\n\tiarg1 = Inv(arg1);\n\tscanf(\"%d\", &n);\n\tscanf(\"%s\", S + 1);\n\tA[0] = 1; B[0] = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (S[i] == '+') { A[i] = 1; B[i] = 1; }\n\t\telse if (S[i] == '-') { A[i] = 1; B[i] = mod - 1; }\n\t\telse if (S[i] == '>') { A[i] = arg1; B[i] = 0; }\n\t\telse if (S[i] == '<') { A[i] = iarg1; B[i] = 0; }\n\t\tB[i] = (ll(B[i - 1]) * A[i] + ll(B[i])) % mod;\n\t\tA[i] = ll(A[i - 1]) * A[i] % mod;\n\t}\n\tint X = ll(B[n]) * Inv(A[n]) % mod;\n\tM[X]++;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint ainv = Inv(A[i]);\n\t\tint need = ll(B[i]) * ainv % mod;\n\t\tauto it = M.find(need);\n\t\tif (it != M.end()) res += it->second;\n\t\tM[ll(X + B[i]) * ainv % mod]++;\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 250010;\nconst int mod[] = {1e9 + 7, 1e9 + 9};\nconst int P[] = {131, 233};\n\ntypedef long long LL;\n\nint Pow[2][N * 2]; char s[N];\n\ninline int FUCK(int x, int y, int mod) {\n    int res = 1;\n    for (; y; y >>= 1, x = (LL)x * x % mod) if (y & 1) res = (LL)res * x % mod;\n    return res;\n}\n\nstruct Data {\n    int val[2];\n\n    Data(int a = 0, int b = 0) {val[0] = a, val[1] = b;} \n\n    Data operator + (const Data &b) {\n        Data res;\n        res.val[0] = (val[0] + b.val[0]) % mod[0];\n        res.val[1] = (val[1] + b.val[1]) % mod[1];\n        return res;\n    }\n\n    Data operator - (const Data &b) {\n        Data res;\n        res.val[0] = (val[0] - b.val[0] + mod[0]) % mod[0];\n        res.val[1] = (val[1] - b.val[1] + mod[1]) % mod[1]; \n        return res;\n    }\n\n    Data operator * (const int b) {\n        Data res = *this;\n        int a = b >= 0 ? Pow[0][b] : FUCK(P[0], (LL)(mod[0] - 2) * (-b) % mod[0], mod[0]);\n        int c = b >= 0 ? Pow[1][b] : FUCK(P[1], (LL)(mod[1] - 2) * (-b) % mod[1], mod[1]);\n        res.val[0] = (LL)res.val[0] * a % mod[0];\n        res.val[1] = (LL)res.val[1] * c % mod[1];\n        return res;\n    }\n\n    bool operator < (const Data &b) const {\n        if (val[0] != b.val[0]) return val[0] < b.val[0];\n        return val[1] < b.val[1];\n    }\n};\n\nmap<Data, int> mp;\n\ninline void increase(Data &a, int b) {\n    a = a + (Data){Pow[0][b], Pow[1][b]};\n}\n\ninline void decrease(Data &a, int b) {\n    a = a - (Data){Pow[0][b], Pow[1][b]};\n}\n\nint main() {\n    int n; scanf(\"%d%s\", &n, s + 1); Data all;\n    Pow[0][0] = Pow[1][0] = 1;\n    for (int i = 0; i <= 1; i++)\n        for (int j = 1; j <= n * 2; j++)\n            Pow[i][j] = (LL)Pow[i][j - 1] * P[i] % mod[i];\n    for (int i = 1, ls = 0; i <= n; i++) {\n        if (s[i] == '<') ls--;\n        else if (s[i] == '>') ls++;\n        else if (s[i] == '+') increase(all, ls + n);\n        else decrease(all, ls + n);\n    }\n    Data fuck; mp[all] = 1; LL res = 0;\n    for (int i = 1, ls = 0; i <= n; i++) {\n        if (s[i] == '<') ls--;\n        else if (s[i] == '>') ls++;\n        else if (s[i] == '+') increase(fuck, ls + n);\n        else decrease(fuck, ls + n);\n        res += mp[fuck], mp[fuck + all * ls]++;\n    }\n    printf(\"%lld\\n\", res);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//teja349\n#include <bits/stdc++.h>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <utility>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <iomanip> \n//setbase - cout << setbase (16); cout << 100 << endl; Prints 64\n//setfill -   cout << setfill ('x') << setw (5); cout << 77 << endl; prints xxx77\n//setprecision - cout << setprecision (14) << f << endl; Prints x.xxxx\n//cout.precision(x)  cout<<fixed<<val;  // prints x digits after decimal in val\n\nusing namespace std;\n#define f(i,a,b) for(i=a;i<b;i++)\n#define rep(i,n) f(i,0,n)\n#define fd(i,a,b) for(i=a;i>=b;i--)\n#define pb push_back\n#define mp make_pair\n#define vi vector< int >\n#define vl vector< ll >\n#define ss second\n#define ff first\n#define ll long long\n#define pii pair< int,int >\n#define pll pair< ll,ll >\n#define sz(a) a.size()\n#define inf (1000*1000*1000+5)\n#define all(a) a.begin(),a.end()\n#define tri pair<int,pii>\n#define vii vector<pii>\n#define vll vector<pll>\n#define viii vector<tri>\n#define mod (1000*1000*1000+7)\n#define pqueue priority_queue< int >\n#define pdqueue priority_queue< int,vi ,greater< int > >\n\n//std::ios::sync_with_stdio(false);   \nll ans10[512345],ans13[512345],powe13[512345],powe10[512345],invpowe10[512345];\nll invpowe13[512345],inv[1234],p[512345];\nll extend_gcd(ll a,ll b,ll &x,ll &y){\n\tif(b==0){\n\t\tx=1;\n\t\ty=0;\n\t\treturn a;\n\t}\n\tll x1,y1;\n\tll ans =extend_gcd(b,a%b,x1,y1);\n\tx=y1;\n\ty=x1-(a/b)*y1;\n\n\treturn ans;\n}\nmap<ll,ll> seti10,seti13; \nint main(){\n    std::ios::sync_with_stdio(false);\n    ll n;\n    cin>>n;\n    string s;\n    cin>>s;\n    ll i;\n    ll initp=250003;\n    powe10[0]=1;\n    powe13[0]=1;\n    invpowe10[0]=1;\n    invpowe13[0]=1;\n    ll inv10,inv13;\n\n            ll x,y;\n            i=503803;\n        ll val=extend_gcd(mod,i,x,y);\n        if(y>0)\n            inv13=y%mod;\n        else{\n                inv13=(y+mod)%mod;\n        }\n        x,y;\n            i=500167;\n        val=extend_gcd(mod,i,x,y);\n        if(y>0)\n            inv10=y%mod;\n        else{\n                inv10=(y+mod)%mod;\n        }    \n\tf(i,1,512345){\n    \tpowe13[i]=powe13[i-1]*503803;\n    \tpowe10[i]=powe10[i-1]*500167;\n    \tpowe10[i]%=mod;\n    \tpowe13[i]%=mod;\n    \tinvpowe10[i]=invpowe10[i-1]*inv10;\n    \tinvpowe10[i]%=mod;\n    \tinvpowe13[i]=invpowe13[i-1]*inv13;\n    \tinvpowe13[i]%=mod;\n    }\n    ans10[0]=0;\n    ans13[0]=0;\n    p[0]=initp;\n    \n    f(i,1,s.length()+1){\n    \tans10[i]=ans10[i-1];\n    \tans13[i]=ans13[i-1];\n    \tp[i]=p[i-1];\n    \tif(s[i-1]=='+'){\n    \t\tans10[i]=ans10[i-1]+powe10[p[i]];\n    \t\tans13[i]=ans13[i-1]+powe13[p[i]];\n\n    \t}\n    \telse if(s[i-1]=='-'){\n    \t\tans10[i]=ans10[i-1]-powe10[p[i]];\n    \t\tans13[i]=ans13[i-1]-powe13[p[i]];\n    \t}\n    \telse if(s[i-1]=='<'){\n    \t\tp[i]--;\n    \t}\n    \telse{\n    \t\tp[i]++;\n    \t}\n    \tans10[i]%=mod;\n    \tans10[i]+=mod;\n    \tans10[i]%=mod;\n    \tans13[i]%=mod;\n    \tans13[i]+=mod;\n    \tans13[i]%=mod;\n    \tseti13[ans13[i]]++;\n    \tseti10[ans10[i]]++;\n    \t//cout<<ans10[i]<<\" \"<<ans13[i]<<endl;\n    }\n    ll val1,j10,j13;\n    ll total=0;\n    f(i,1,n+1){\n    \tval=initp-p[i-1];\n    \tval*=-1;\n    \tif(val>=0){\n    \t\tval1=powe13[val];\n    \t\tval=powe10[val];\n    \t\t  \n    \t}\n    \telse{\n    \t\tval1=invpowe13[val];\n    \t\tval=invpowe10[val];\n    \t}\n    \tj10=ans10[n]*val;\n    \tj10%=mod;\n    \tj10+=ans10[i-1];\n    \tj13=ans13[n]*val1;\n    \tj13%=mod;\n    \tj13+=ans13[i-1];\n    \tj10%=mod;\n    \tj13%=mod;\n    \ttotal+=min(seti10[j10],seti13[j13]);\n        //assert(seti10[j10]==seti13[j13]);\n    \tseti13[ans13[i]]--;\n    \tseti10[ans10[i]]--;\n    }\n    cout<<total<<endl;\n\n\n\n\n    return 0;  \n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <cstdio>\nusing namespace std;\n\nconst long long B=1000000000000000003LL;\nconst long long P=1000000000000000031LL;\n\nlong long mul(long long x,long long y,long long m){\n\tlong long z=0;\n\tfor(;y;y>>=1){\n\t\tif(y&1){z+=x;if(z>=m)z-=m;}\n\t\tx+=x;if(x>=m)x-=m;\n\t}\n\treturn z;\n}\n\nlong long pow_binary_mod(long long x,long long y,long long m){\n\tlong long z=1;\n\tfor(;y;y>>=1){\n\t\tif(y&1)z=mul(z,x,m);\n\t\tx=mul(x,x,m);\n\t}\n\treturn z;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N;\n\tstring s;\n\tcin>>N>>s;\n\tlong long Brev=pow_binary_mod(B,P-2,P);\n\tvector<long long> o(N+1),p(N+1);p[0]=1;\n\tfor(int i=1;i<=N;i++){\n\t\tp[i]=p[i-1];o[i]=o[i-1];\n\t\tif(s[i-1]=='>'){\n\t\t\tp[i]=mul(p[i],B,P);\n\t\t}else if(s[i-1]=='<'){\n\t\t\tp[i]=mul(p[i],Brev,P);\n\t\t}else if(s[i-1]=='+'){\n\t\t\to[i]=(o[i]+p[i])%P;\n\t\t}else if(s[i-1]=='-'){\n\t\t\to[i]=(o[i]-p[i]+P)%P;\n\t\t}\n\t}\n\tmap<long long,int>m;\n\tlong long r=0;\n\tfor(int i=N;i>=1;i--){\n\t\tm[o[i]]++;\n\t\tr+=m[(mul(o[N],p[i-1],P)+o[i-1])%P];\n\t}\n\tprintf(\"%lld\\n\",r);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T> void read(T &t) {\n\tt=0; char ch=getchar(); int f=1;\n\twhile (ch<'0'||ch>'9') { if (ch=='-') f=-1; ch=getchar(); }\n\tdo { (t*=10)+=ch-'0'; ch=getchar(); } while ('0'<=ch&&ch<='9'); t*=f;\n}\ntypedef long long ll;\nconst int maxn=(2e5)+10;\nconst ll mod=(1e9)+7;\nconst ll t1=998244353;\nconst ll t2=235723657;\nint n,pos[maxn];\nchar s[maxn];\nll h1[maxn],h2[maxn];\nll m1[maxn*2],m2[maxn*2],a[maxn*2],ans,s1,s2;\nll iv1[maxn],iv2[maxn];\nmap<pair<ll,ll> ,int> M;\nll MI1(int x) {\n\tif (x>=0) return m1[x];\n\treturn iv1[-x];\n}\nll MI2(int x) {\n\tif (x>=0) return m2[x];\n\treturn iv2[-x];\n}\nll get1(int x) {\n\treturn a[x+n]*MI1(x)%mod;\n}\nll get2(int x) {\n\treturn a[x+n]*MI2(x)%mod;\n}\nll ksm(ll x,ll y) {\n\tll res=1;\n\twhile (y) {\n\t\tif (y&1) res=res*x%mod;\n\t\tx=x*x%mod; y>>=1;\n\t} return res;\n}\nvoid F(ll &x) {\n\tx=(x%mod+mod)%mod;\n}\nint main() {\n\t//freopen(\"1.txt\",\"r\",stdin);\n\tread(n);\n\tscanf(\"%s\",s+1);\n\tm1[0]=m2[0]=1;\n\tfor (int i=1;i<=n*2;i++) m1[i]=m1[i-1]*t1%mod,m2[i]=m2[i-1]*t2%mod;\n\tiv1[0]=iv2[0]=1;\n\tiv1[1]=ksm(t1,mod-2);\n\tiv2[1]=ksm(t2,mod-2);\n\tfor (int i=2;i<=n*2;i++)\n\t\tiv1[i]=iv1[i-1]*iv1[1]%mod,\n\t\tiv2[i]=iv2[i-1]*iv2[1]%mod;\n\tfor (int i=1;i<=n;i++) {\n\t\th1[i]=h1[i-1]; h2[i]=h2[i-1]; pos[i]=pos[i-1];\n\t\tif (s[i]=='+') {\n\t\t\th1[i]-=get1(pos[i]);\n\t\t\th2[i]-=get2(pos[i]);\n\t\t\ta[pos[i]+n]++;\n\t\t\th1[i]+=get1(pos[i]);\n\t\t\th2[i]+=get2(pos[i]);\n\t\t} else if (s[i]=='-') {\n\t\t\th1[i]-=get1(pos[i]);\n\t\t\th2[i]-=get2(pos[i]);\n\t\t\ta[pos[i]+n]--;\n\t\t\th1[i]+=get1(pos[i]);\n\t\t\th2[i]+=get2(pos[i]);\n\t\t} else if (s[i]=='>') pos[i]++;\n\t\telse pos[i]--;\n\t\tF(h1[i]);\n\t\tF(h2[i]);\n\t}\n\tfor (int i=n-1;i>=0;i--) {\n\t\tM[make_pair(h1[i+1],h2[i+1])]++;\n\t\ts1=h1[n]*MI1(pos[i])%mod+h1[i];\n\t\ts2=h2[n]*MI2(pos[i])%mod+h2[i];\n\t\tF(s1); F(s2);\n\t\tans+=M[make_pair(s1,s2)];\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n/*\n  0. Enough array size? Enough array size? Enough array size? Interger overflow?\n  \n  1. Think TWICE, Code ONCE!\n  Are there any counterexamples to your algo?\n    \n  2. Be careful about the BOUNDARIES!\n  N=1? P=1? Something about 0?\n    \n  3. Do not make STUPID MISTAKES!\n  Time complexity? Memory usage? Precision error?\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long D;\nconst int maxn=500005,base=17,mod1=1000000007,mod2=1000000009;\nint qpow(int x,int y,int mod){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1)ans=D(ans)*x%mod;\n\t\tx=D(x)*x%mod;\n\t\ty>>=1;\n\t}\n\treturn ans;\n}\nint n,temp[base+1];\nchar s[maxn];\nstruct H{\n\tint a,b;\n\tH():a(0),b(0){}\n\tH(int _a,int _b):a(_a),b(_b){}\n\tH operator+(const H &x)const{return H((a+x.a)%mod1,(b+x.b)%mod2);}\n\tH operator-(const H &x)const{return H((a-x.a+mod1)%mod1,(b-x.b+mod2)%mod2);}\n\tH operator*(const H &x)const{return H((D)a*x.a%mod1,(D)b*x.b%mod2);}\n\tbool operator<(const H &x)const{return a!=x.a?a<x.a:b<x.b;}\n}b,inv,f[maxn],g[maxn];\nmap<H,int> mp;\nint main(){\n\tb=H(base,base),inv=H(qpow(base,mod1-2,mod1),qpow(base,mod2-2,mod2));\n\tscanf(\"%d%s\",&n,s+1);\n\tg[0]=H(1,1);\n\tfor(int i=1;i<=n;i++){\n\t\tf[i]=f[i-1],g[i]=g[i-1];\n\t\tif(s[i]=='+')f[i]=f[i]+g[i];\n\t\tif(s[i]=='-')f[i]=f[i]-g[i];\n\t\tif(s[i]=='<')g[i]=g[i]*inv;\n\t\tif(s[i]=='>')g[i]=g[i]*b;\n\t\tmp[f[i]]++;\n\t}\n\tD ans=0;\n\tfor(int i=1;i<=n;i++){\n\t\tans+=mp[f[i-1]+g[i-1]*f[n]];\n\t\tmp[f[i]]--;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1061109567\n#define int long long\n#define pb push_back\n#define in(s) freopen(s,\"r\",stdin);\n#define out(s) freopen(s,\"w\",stdout);\n#define fi first\n#define se second\n#define bw(i,r,l) for (int i=r-1;i>=l;i--)\n#define fw(i,l,r) for (int i=l;i<r;i++)\n#define fa(i,x) for (auto i:x)\nusing namespace std;\nconst int N = 5e5 + 10;\nconst int mod1 = 1e9 + 7, mod2 = 1e9 + 9, base = 121448;\ntypedef pair<int, int> ii;\nint n, h[N][2], pw[N][2];\nstring s;\nmap<ii, int> mp;\nvoid add(int &x, int y, int mod) {\n\tx += y;\n\tif (x >= mod) x -= mod;\n}\nvoid rem(int &x, int y, int mod) {\n\tx -= y;\n\tif (x < 0) x += mod;\n}\nint fpow(int a, int p, int mod) {\n\tif (!p) return 1;\n\tint ans = fpow(a, p >> 1, mod);\n\tans = ans * ans % mod;\n\tif (p & 1) ans = ans * a % mod;\n\treturn ans;\n}\nint inv(int x, int mod) {\n\treturn fpow(x, mod - 2, mod);\n}\nsigned main() {\n\t#ifdef aome\n\tin(\"aome.inp\");\t\n\t#endif\n\tios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tcin >> n >> s;\n\t//Hash 'em. Then for a range L -> R, if the pointer at L is P, it's (h[r] - h[l - 1]) / b ^ p\n\tpw[0][0] = pw[0][1] = 1;\n\tfw (i, 1, N) {\n\t\tpw[i][0] = pw[i - 1][0] * base % mod1;\n\t\tpw[i][1] = pw[i - 1][1] * base % mod2;\n\t}\n\tint cur = 25e4 + 5;\n\tfw (i, 0, n) {\n\t\th[i][0] = i ? h[i - 1][0] : 0;\n\t\th[i][1] = i ? h[i - 1][1] : 0;\n\t\tif (s[i] == '>') cur++;\n\t\telse if (s[i] == '<') cur--;\n\t\telse if (s[i] == '+') add(h[i][0], pw[cur][0], mod1), add(h[i][1], pw[cur][1], mod2);\n\t\telse rem(h[i][0], pw[cur][0], mod1), rem(h[i][1], pw[cur][1], mod2);\n\t\t//cout << \"h[\"<<i<<\"][0] = \" << h[i][0] << \", 1 = \" << h[i][1] << \" cur = \" << cur << \"\\n\";\n\t\tmp[ii(h[i][0], h[i][1])]++;\n\t}\n\tcur = 0;\n\tint ans = 0;\n\tans += mp[ii(h[n - 1][0], h[n - 1][1])]; //0 -> any good points\n\tfw (i, 0, n) {\n\t\tif (s[i] == '>') cur++;\n\t\telse if (s[i] == '<') cur--;\n\t\tmp[ii(h[i][0], h[i][1])]--;\n\t\tint pw0, pw1;\n\t\tif (cur >= 0) pw0 = pw[cur][0], pw1 = pw[cur][1];\n\t\telse pw0 = inv(pw[cur][0], mod1), pw1 = inv(pw[cur][1], mod2);\n\t\t//cout << (h[n - 1][0] * pw0 + h[i][0]) % mod1 << \" \" << (h[n - 1][1] * pw1 + h[i][1]) % mod2 << \"\\n\";\n\t\tans += mp[ii((h[n - 1][0] * pw0 + h[i][0]) % mod1, (h[n - 1][1] * pw1 + h[i][1]) % mod2)];\n\t}\n\tcout << ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<map>\nusing namespace std;\nconst int N=250005;\nconst int mod=998244853;\nconst int base=131;\nint n,pw[N],ipw[N],pos[N],val[N];\nchar str[N];long long ans;\nmap<int,int>Map;\nint fastpow(int x,int y){\n\tint res=1;\n\twhile(y){if(y&1)res=1ll*res*x%mod;x=1ll*x*x%mod;y>>=1;}\n\treturn res;\n}\nint cal(int x){\n\treturn x>0?pw[x]:ipw[-x];\n}\nint main(){\n\tscanf(\"%d%s\",&n,str+1);\n\tpw[0]=ipw[0]=1;pw[1]=base;ipw[1]=fastpow(base,mod-2);\n\tfor(int i=2;i<=n;++i){\n\t\tpw[i]=1ll*pw[i-1]*pw[1]%mod;\n\t\tipw[i]=1ll*ipw[i-1]*ipw[1]%mod;\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tif(str[i]=='+'){\n\t\t\tpos[i]=pos[i-1];\n\t\t\tval[i]=(val[i-1]+cal(pos[i]))%mod;\n\t\t}\n\t\tif(str[i]=='-'){\n\t\t\tpos[i]=pos[i-1];\n\t\t\tval[i]=(val[i-1]+mod-cal(pos[i]))%mod;\n\t\t}\n\t\tif(str[i]=='>'){\n\t\t\tpos[i]=pos[i-1]+1;\n\t\t\tval[i]=val[i-1];\n\t\t}\n\t\tif(str[i]=='<'){\n\t\t\tpos[i]=pos[i-1]-1;\n\t\t\tval[i]=val[i-1];\n\t\t}\n\t\t++Map[val[i]];\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tint x=(1ll*val[n]*cal(pos[i-1])+val[i-1])%mod;\n\t\tans+=Map[x];--Map[val[i]];\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n#define dump(x) cout << #x << \" = \" << (x) << endl\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\ntemplate<class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n\tos<<\"{\";\n\trep(i, v.size()) {\n\t\tif (i) os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\nll powmod(ll x, ll k, ll m) {\n\tll res = 1;\n\tfor (; k; x = x * x % m, k >>= 1) {\n\t\tif (k & 1) {\n\t\t\tres = res * x % m;\n\t\t}\n\t}\n\treturn res;\n}\n\nll invmod(ll x, ll m) {\n\treturn powmod(x, m - 2, m);\n}\n\nint main() {\n\tint N; string S;\n\tcin >> N >> S;\n\n\tconst int pnum = 3;\n\tconst vector<ll> vmod = {1000000007, 1000000009, 998244353}, vB = {100007, 100007, 100007};\n\tvector<ll> vinv(pnum);\n\trep(j, pnum) vinv[j] = invmod(vB[j], vmod[j]);\n\n\tusing pll = pair<ll,ll>;\n\n\tvector<ll> vall(pnum);\n\n\tfor (int i = N-1; i >= 0; --i) {\n\t\trep(j, pnum) {\n\t\t\tif (S[i] == '+') {\n\t\t\t\t(vall[j] += 1) %= vmod[j];\n\t\t\t} else if (S[i] == '-') {\n\t\t\t\t(vall[j] += vmod[j] - 1) %= vmod[j];\n\t\t\t} else if (S[i] == '>') {\n\t\t\t\t(vall[j] *= vinv[j]) %= vmod[j];\n\t\t\t} else {\n\t\t\t\t(vall[j] *= vB[j]) %= vmod[j];\n\t\t\t}\n\t\t}\n\t}\n\n\tmap<vector<ll>, int> MP;\n\tvector<vector<pll>> ivec(N + 1, vector<pll>(pnum));\n\n\trep(j, pnum) ivec[N][j] = mp(1ll, 0ll);\n\tvector<ll> initvec(pnum);\n\t++MP[initvec];\n\tll ans = 0;\n\n\tfor (int i = N-1; i >= 0; --i) {\n\t\tvector<ll> vec(pnum);\n\t\trep(j, pnum) {\n\t\t\tivec[i][j] = ivec[i+1][j];\n\t\t\tif (S[i] == '+') {\n\t\t\t\t(ivec[i][j].se += vmod[j] - ivec[i][j].fi) %= vmod[j];\n\t\t\t} else if (S[i] == '-') {\n\t\t\t\t(ivec[i][j].se += ivec[i][j].fi) %= vmod[j];\n\t\t\t} else if (S[i] == '>') {\n\t\t\t\t(ivec[i][j].fi *= vB[j]) %= vmod[j];\n\t\t\t} else {\n\t\t\t\t(ivec[i][j].fi *= vinv[j]) %= vmod[j];\n\t\t\t}\n\t\t\tvec[j] = (vall[j] * ivec[i][j].fi + ivec[i][j].se) % vmod[j];\n\t\t}\n\t\tif (MP.count(vec)) {\n\t\t\tans += MP[vec];\n\t\t}\n\t\trep(j, pnum) {\n\t\t\tvec[j] = ivec[i][j].se;\n\t\t}\n\t\t++MP[vec];\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "        #include \"bits/stdc++.h\"\n        using namespace std;\n         \n        #define MAX 600012\n         \n        int n;\n        char buf[MAX];\n         \n         \n        string s;\n         \n         \n        //#define MOD1 1000000007\n        //#define MOD2 1000000009\n         \n        valarray<long long int> MOD1;\n        valarray<long long int> MOD2;\n        vector<valarray<long long int> > p2;\n        vector<valarray<long long int> > vv;\n        vector<int> ps;\n        map<pair<long long int,long long int>, int> mp;\n        long long int ppow(long long int i, long long int j, long long int MOD) {\n        \tlong long int ret = 1;\n        \twhile (j) {\n        \t\tif (j & 1LL)ret *= i;\n        \t\tif (ret >= MOD)ret %= MOD;\n        \t\tj >>= 1LL;\n        \t}\n        \treturn ret;\n        }\n         \n        valarray<long long int> calc(int dif) {\n        \tvalarray<long long int> ret;\n        \tret.resize(2, 0);\n        \tfor (int j = 0; j < 2; j++) {\n        \t\tif (dif < 0) {\n        \t\t\tret[j]=ppow(ppow(MOD1[j],MOD2[j]-2,MOD2[j]),-dif,MOD2[j]);\n        \t\t}\n        \t\telse {\n        \t\t\tret[j] = ppow(MOD1[j], abs(dif), MOD2[j]);\n        \t\t}\n        \t}\n        \treturn ret;\n        }\n         \n        int main() {\n        \tMOD1.resize(2);\n        \tMOD2.resize(2);\n        \tp2.push_back(valarray<long long int>());\n        \tp2.back().resize(2);\n        \tp2.back()[0] = p2.back()[1] = 1;\n        \tMOD2[0] = 1000000007;\n        \tMOD1[0] = 555522277;\n        \tMOD1[1] = 895612782;\n        \tMOD2[1] = 998244353;\n        \tp2[0] %= MOD2;\n        \tfor (int i = 1; i < MAX; i++) {\n        \t\tp2.push_back((p2.back()*MOD1)%MOD2);\n\t\t\t}\n        \tcin >> n;\n        \tscanf(\"%s\", buf);\n        \ts = buf;\n        \tint pos = MAX/2;\n        \tvalarray<long long int> hs;\n        \ths.resize(2,0);\n        \tvv.push_back(hs);\n        \tps.push_back(pos);\n        \tfor (int i = 0; i < s.size(); i++) {\n        \t\tif (s[i] == '<') {\n        \t\t\tpos--;\n        \t\t}\n        \t\tif (s[i] == '>') {\n        \t\t\tpos++;\n        \t\t}\n        \t\tif (s[i] == '+') {\n        \t\t\ths += p2[pos];\n        \t\t}\n        \t\tif (s[i] == '-') {\n        \t\t\ths += MOD2-p2[pos];\n        \t\t}\n        \t\ths %= MOD2;\n        \t\tvv.push_back(hs);\n        \t\tps.push_back(pos);\n        \t}\n        \tlong long int way = 0;\n        \tfor (int i = vv.size() - 1; i >= 0; i--) {\n        \t\tvalarray<long long int> want = (vv[i] + ((vv.back()*calc(-MAX/2+ps[i]))%MOD2))%MOD2;\n        \t\tway += mp[make_pair(want[0], want[1])];\n        \t\tmp[make_pair(vv[i][0],vv[i][1])]++;\n        \t}\n        \tprintf(\"%lld\\n\", way);\n        \treturn 0;\n        }\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int mod1 = 998244353,mod2 = 1000000007;\n\nstruct Hsh\n{\n\tlong long m1,m2;\n\tHsh operator + (const Hsh &a) const\n\t{\n\t\treturn (Hsh){(m1 + a.m1) % mod1,(m2 + a.m2) % mod2};\n\t}\n\tHsh operator - (const Hsh &a) const\n\t{\n\t\treturn (Hsh){(m1 - a.m1 + mod1) % mod1,(m2 - a.m2 + mod2) % mod2};\n\t}\n\tHsh operator * (const Hsh &a) const\n\t{\n\t\treturn (Hsh){m1 * a.m1 % mod1,m2 * a.m2 % mod2};\n\t}\n\tbool operator < (const Hsh &a) const\n\t{\n\t\treturn m1 == a.m1 ? m2 < a.m2 : m1 < a.m1;\n\t}\n}ha[250050],pos[500050];\n\nmap<Hsh,int> mp;\nint N;\nconst int bas1 = 131,bas2 = 1331;\nchar s[250005];\n\nlong long qpow(long long base,int tms,int mod)\n{\n\tlong long tmp = 1;\n\twhile(tms)\n\t{\n\t\tif(tms & 1) tmp = tmp * base % mod;\n\t\tbase = base * base % mod;\n\t\ttms >>= 1;\n\t}\n\treturn tmp;\n}\n\nint main()\n{\n\tHsh x,inv;\n\tint n;\n\tx.m1 = bas1,x.m2 = bas2;\n\tinv.m1 = qpow(bas1,mod1 - 2,mod1),inv.m2 = qpow(bas2,mod2 - 2,mod2);\n\tpos[0].m1 = pos[0].m2 = 1; scanf(\"%d\",&n); scanf(\"%s\",s + 1);\n\tfor(int i = 1;i <= n; ++ i)\n\t{\n\t\tpos[i] = pos[i - 1];\n\t\tif(s[i] == '<') pos[i] = pos[i - 1] * inv;\n\t\telse if(s[i] == '>') pos[i] = pos[i - 1] * x;\n\t}\n\tfor(int i = n;i >= 1; -- i)\n\t{\n\t\tha[i] = ha[i + 1];\n\t\tif(s[i] == '+') ha[i] = ha[i] + pos[i];\n\t\telse if(s[i] == '-') ha[i] = ha[i] - pos[i];\n\t}\n\tmp[ha[n + 1]] = 1;\n\tlong long ans = 0;\n\tfor(int i = n;i >= 1; -- i)\n\t{\n\t\tHsh cur = ha[i] - ha[1] * pos[i - 1];\n\t\tans += mp[cur];\n\t\tmp[ha[i]] ++;\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\nconst int   N   = 5e5 + 1;\n\ntypedef pair<int,int>   ii;\n\nint qpow(int a,int exp,int mod) {\n    if(exp < 0) exp = mod - 1 - exp;\n    int ans = 1;\n    while (exp) {\n        if(exp & 1) ans = ans * a % mod;\n        a = a * a % mod;  exp >>= 1;\n    }\n    return ans;\n}\n\nvoid add(int &a,int b,int mod) {\n    a += b;\n    if(a >= mod)a -= mod;\n    if(a < 0)   a += mod;\n}\n\nint mod[2];\nint n, f[N];\nint H[N][2];\nstring S;\n\nvoid process(int t)   {\n    for(int i = 1 ; i <= n ; ++i)   {\n        H[i][t] = H[i - 1][t];\n        if(S[i - 1] == '+') add(H[i][t], qpow(N,f[i],mod[t]),mod[t]);\n        if(S[i - 1] == '-') add(H[i][t],-qpow(N,f[i],mod[t]),mod[t]);\n    }\n}\n\nmap<ii,int> mp;\n\nsigned main()   {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    cin >> n >> S;\n\n    for(int i = 0 ; i < n ; ++i)    {\n        f[i + 1] = f[i];\n        if(S[i] == '>') f[i + 1]++;\n        if(S[i] == '<') f[i + 1]--;\n    }\n\n    mod[0] = 1e9 + 7;\n    mod[1] = 1e9 + 9;\n\n    process(0);\n    process(1);\n\n    mp[ii(H[n][0],H[n][1])] = 1;\n\n    int ans = 0;\n\n    for(int i = 1 ; i <= n ; ++i)   {\n        ans += mp[ii(H[i][0],H[i][1])];\n        int mul0 = qpow(N,f[i],mod[0]);\n        int mul1 = qpow(N,f[i],mod[1]);\n        int res0 = H[n][0] * mul0 + H[i][0];\n        int res1 = H[n][1] * mul1 + H[i][1];\n        mp[ii(res0 % mod[0],res1 % mod[1])]++;\n    }\n\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < (int)(n); ++ (i))\nusing ll = long long;\nusing namespace std;\n\ntemplate <int32_t MOD>\nstruct mint {\n    int64_t data;  // faster than int32_t a little\n    mint() = default;  // data is not initialized\n    mint(int64_t value) : data(value) {}  // assume value is in proper range\n    inline mint<MOD> operator + (mint<MOD> other) const { int64_t c = this->data + other.data; return mint<MOD>(c >= MOD ? c - MOD : c); }\n    inline mint<MOD> operator - (mint<MOD> other) const { int64_t c = this->data - other.data; return mint<MOD>(c <    0 ? c + MOD : c); }\n    inline mint<MOD> operator * (mint<MOD> other) const { int64_t c = this->data * int64_t(other.data) % MOD; return mint<MOD>(c < 0 ? c + MOD : c); }\n    inline mint<MOD> & operator += (mint<MOD> other) { this->data += other.data; if (this->data >= MOD) this->data -= MOD; return *this; }\n    inline mint<MOD> & operator -= (mint<MOD> other) { this->data -= other.data; if (this->data <    0) this->data += MOD; return *this; }\n    inline mint<MOD> & operator *= (mint<MOD> other) { this->data = this->data * int64_t(other.data) % MOD; if (this->data < 0) this->data += MOD; return *this; }\n    inline mint<MOD> operator - () const { return mint<MOD>(this->data ? MOD - this->data : 0); }\n    mint<MOD> pow(uint64_t k) const {\n        mint<MOD> x = *this;\n        mint<MOD> y = 1;\n        for (uint64_t i = 1; i and (i <= k); i <<= 1) {\n            if (k & i) y *= x;\n            x *= x;\n        }\n        return y;\n    }\n    mint<MOD> inv() const {\n        return pow(MOD - 2);\n    }\n};\n\ntemplate <typename T, size_t H, size_t W>\nusing matrix = array<array<T, W>, H>;\ntemplate <typename T, size_t A, size_t B, size_t C>\nmatrix<T, A, C> operator * (matrix<T, A, B> const & a, matrix<T, B, C> const & b) {\n    matrix<T, A, C> c = {};\n    REP (y, A) REP (z, B) REP (x, C) c[y][x] += a[y][z] * b[z][x];\n    return c;\n}\ntemplate <typename T, size_t H, size_t W>\narray<T, H> operator * (matrix<T, H, W> const & a, array<T, W> const & b) {\n    array<T, H> c = {};\n    REP (y, H) REP (z, W) c[y] += a[y][z] * b[z];\n    return c;\n}\ntemplate <typename T, size_t N>\nmatrix<T, N, N> matrix_unit() {\n    matrix<T, N, N> a = {};\n    REP (i, N) a[i][i] = 1;\n    return a;\n}\n\nconstexpr int MOD = 1e9 + 7;\n\nconst mint<MOD> BASE = 10007;\nconst matrix<mint<MOD>, 2, 2> INCR = {{ {{ 1, +1 }}, {{ 0, 1 }} }};\nconst matrix<mint<MOD>, 2, 2> DECR = {{ {{ 1, -1 }}, {{ 0, 1 }} }};\nconst matrix<mint<MOD>, 2, 2> NEXT = {{ {{ 1,  0 }}, {{ 0, BASE }} }};\nconst matrix<mint<MOD>, 2, 2> PREV = {{ {{ 1,  0 }}, {{ 0, BASE.inv() }} }};\n\nll solve(int n, string const & s) {\n    vector<matrix<mint<MOD>, 2, 2> > f(n + 1);\n    f[0] = matrix_unit<mint<MOD>, 2>();\n    REP (i, n) {\n        auto const & g =\n            s[i] == '+' ? INCR :\n            s[i] == '-' ? DECR :\n            s[i] == '<' ? NEXT :\n            s[i] == '>' ? PREV :\n            *(matrix<mint<MOD>, 2, 2> *)nullptr;\n        f[i + 1] = g * f[i];\n    }\n    array<mint<MOD>, 2> v0 = {{ 0, 1 }};\n\n    unordered_map<int, int> cnt_a;\n    REP (i, n + 1) {\n        auto v = f[i] * v0;\n        int a = v[0].data;\n        cnt_a[a] += 1;\n    }\n\n    ll cnt = 0;\n    REP (l, n + 1) {\n        auto v = f[l] * v0;\n        int a = v[0].data;\n        cnt_a[a] -= 1;\n\n        auto v1 = f[n] * f[l] * v0;\n        int a1 = v1[0].data;\n        cnt += cnt_a[a1];\n    }\n    return cnt;\n}\n\nint main() {\n    int n; string s; cin >> n >> s;\n    cout << solve(n, s) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef unsigned long long ull;\nconst ull M=998244353;\nconst ull N=1000000007; \nconst ull X=99431;\nconst ull Y=99487;\null R;\null L;\nconst int W=800;\n \n \null ModPow(ull x, ull n, ull mod) {\n        ull ret = 1;\n        for (; n > 0; n /= 2, x = (x * x) % mod)\n            if ((n & 1) == 1) ret = (ret * x) % mod;\n        return ret;\n    }\n \null has=0,vec=1;\null has2=0,vec2=1;\n \nint n;\nstring s;\nunordered_map<ull,int> B[550];\nlong long ans;\ninline void calc(char c, ull &u,ull &p,ull &v,ull &q){\n\tif(c=='+'){u+=p;v+=q;}\n\telse if(c=='-'){u+=M-p;v+=N-q;}\n\telse if(c=='>'){p=(p*X)%M;q=(q*Y)%N;}\n\telse {p=(p*R)%M;q=(q*L)%N;}\n\tif(u>=M)u-=M;\n\tif(v>=N)v-=N;\n}\nint main(){\n\tR=ModPow(X,M-2,M);\n\tL=ModPow(Y,N-2,N);\n\tcin>>n>>s;\n    //n=250000;\n    //s=string(n,'+');\n\tfor(int i=0;i<n;i++)calc(s[i],has,vec,has2,vec2);\n\tfor(int i=0;i<n;i++){\n\t\tif(i%W==0)continue;\n\t\tull h=0,x=1,hh=0,y=1;\n\t\tfor(int j=i;j<n;j++){\n\t\t\tif(j%W==0)break;\n\t\t\tcalc(s[j],h,x,hh,y);\n\t\t\tif(h==has&&hh==has2)ans++;\n\t\t}\n\t\tull nh = (has+M-h)%M;\n\t\tnh = nh * ModPow(x,M-2,M)%M;\n\t\tull nh2 = (has2+N-hh)%N;\n\t\tnh2 = nh2 * ModPow(y,N-2,N)%N;\n\t\tB[i/W+1][nh*N+nh2]++;\n\t}\n\tfor(int i=0;i<n;i+=W){\n\t\tull h=0,x=1,hh=0,y=1;\n\t\tfor(int j=i;j<n;j++){\n\t\t\tcalc(s[j],h,x,hh,y);\n\t\t\tif(h==has&&hh==has2)ans++;\n\t\t\tauto it = B[i/W].find(h*N+hh);\n\t\t\tif(it!=B[i/W].end())ans+=it->second;\n\t\t}\n\t}\n\t\n\tcout<<ans;\n \n \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 200000;\n\nconstexpr int inv(int a, int m) {\n  return a == 1 ? 1 : 1LL * (m - m / a) * inv(m % a, m) % m;\n}\n\nconst int BASE = 2;\nconst int M = 2;\nconst int MODS[] = {1000000007, 1000000009};\n\n// template <int BASE, int... INTS> struct HashT {\nstruct HashT {\n  // static constexpr int M = sizeof...(INTS);\n  // static constexpr std::array<int, M> MODS = {INTS...};\n\n  explicit HashT(int a) {\n    for (int i = 0; i < M; ++i) {\n      h[i] = a;\n    }\n  }\n\n  explicit HashT(const HashT &a, const HashT &b) {\n    for (int i = 0; i < M; ++i) {\n      h[i] = 1LL * a.h[i] * b.h[i] % MODS[i];\n    }\n  }\n\n  explicit HashT(const HashT &k, const HashT &b, const HashT &bf) {\n    for (int i = 0; i < M; ++i) {\n      h[i] = 1LL * k.h[i] * (b.h[i] + MODS[i] - bf.h[i]) % MODS[i];\n    }\n  }\n\n  template <int a> void add() {\n    for (int i = 0; i < M; ++i) {\n      h[i] += a >= 0 ? a : MODS[i] + a;\n      if (h[i] >= MODS[i]) {\n        h[i] -= MODS[i];\n      }\n    }\n  }\n\n  void multiplyB() {\n    for (int i = 0; i < M; ++i) {\n      h[i] = 1LL * h[i] * BASE % MODS[i];\n    }\n  }\n\n  void divideB() {\n    for (int i = 0; i < M; ++i) {\n      h[i] = 1LL * h[i] * inv(BASE, MODS[i]) % MODS[i];\n    }\n  }\n\n  int h[M];\n};\n\n// template <int BASE, int... INTS>\n// bool operator<(const HashT<BASE, INTS...> &a, const HashT<BASE, INTS...> &b) {\n// bool operator<(const HashT<BASE, INTS...> &a, const HashT<BASE, INTS...> &b) {\n//   for (int i = 0; i < HashT<BASE, INTS...>::M; ++i) {\nbool operator<(const HashT &a, const HashT &b) {\n  for (int i = 0; i < M; ++i) {\n    if (a.h[i] != b.h[i]) {\n      return a.h[i] < b.h[i];\n    }\n  }\n  return false;\n}\n\nint n;\nchar s[N];\n\n// using Hash = HashT<3, 1000000007, 1000000009>;\nusing Hash = HashT;\n\nstruct Set {\n  Set() : k{1}, b{0} {}\n\n  void add(int c) {\n    if (c == '+') {\n      b.add<-1>();\n    } else if (c == '-') {\n      b.add<1>();\n    } else if (c == '>') {\n      b.multiplyB();\n      k.divideB();\n    } else {\n      k.multiplyB();\n      b.divideB();\n    }\n  }\n\n  Hash zero() const { return Hash{k, b}; }\n  Hash inverse(const Hash &kb) const { return Hash{k, b, kb}; }\n\n  Hash k, b;\n};\n\nint main() {\n  while (scanf(\"%d%s\", &n, s) == 2) {\n    Set setf;\n    for (int i = n - 1; i >= 0; --i) {\n      setf.add(s[i]);\n    }\n    Set set;\n    long long result = 0;\n    std::map<Hash, int> cnt;\n    for (int i = n - 1; i >= 0; --i) {\n      cnt[set.zero()]++;\n      set.add(s[i]);\n      result += cnt[set.inverse(setf.b)];\n    }\n    printf(\"%lld\\n\", result);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cstdio>\n#include <iostream>\n\nusing namespace std ;\n\ntypedef long long LL ;\n\n\n#define mkp make_pair\n#define pll pair<LL, LL>\n\nconst LL B1 = 237ll ;\nconst LL B2 = 637ll ;\nconst int N = 300010 ;\nconst LL P1 = 998244353 ;\nconst LL P2 = 1004535809 ;\n\nint n ;\nLL ans ;\nchar s[N] ;\nLL I1, I2 ;\nLL S[N], T[N] ;\nmap <pll, LL> buc ;\n\nLL expow(LL a, LL b, LL p){\n    LL ret = 1 ;\n    while (b){\n        if (b & 1)\n            (ret *= a) %= p ;\n        (a *= a) %= p ; b >>= 1 ;\n    }\n    return ret ;\n}\nint main(){\n    cin >> n >> (s + 1) ;\n    I1 = expow(B1, P1 - 2, P1) ;\n    I2 = expow(B2, P2 - 2, P2) ;\n    for (int i = n ; i >= 1 ; -- i){\n        if (s[i] == '-'){\n            S[i] = (S[i + 1] - B1 + P1) % P1 ;\n            T[i] = (T[i + 1] - B2 + P2) % P2 ;\n        }\n        if (s[i] == '+'){\n            S[i] = (S[i + 1] + B1) % P1 ;\n            T[i] = (T[i + 1] + B2) % P2 ;\n        }\n        if (s[i] == '<'){\n            S[i] = (S[i + 1] * I1) % P1 ;\n            T[i] = (T[i + 1] * I2) % P2 ;\n        }\n        if (s[i] == '>'){\n            S[i] = (S[i + 1] * B1) % P1 ;\n            T[i] = (T[i + 1] * B2) % P2 ;\n        }\n        //cout << S[i] << \" \" << T[i] << endl ;\n    }\n    LL gs = 1, gt = 1 ;\n    for (int i = n ; i >= 1 ; -- i){\n        LL x, y ;\n        x = expow(gs, P1 - 2, P1) * (-S[i + 1] + P1) % P1 ;\n        y = expow(gt, P2 - 2, P2) * (-T[i + 1] + P2) % P2 ;\n        if (x < 0) x += P1 ; if (y < 0) y += P2 ; ++ buc[mkp(x, y)] ;\n        //cout << x << \" \" << y << endl ;\n        if (s[i] == '<') (gs *= I1) %= P1, (gt *= I2) %= P2 ;\n        if (s[i] == '>') (gs *= B1) %= P1, (gt *= B2) %= P2 ;\n        x = expow(gs, P1 - 2, P1) * (-S[i] + S[1]) % P1 ;\n        y = expow(gt, P2 - 2, P2) * (-T[i] + T[1]) % P2 ;\n        if (x < 0) x += P1 ; if (y < 0) y += P2 ; ans += buc[mkp(x, y)] ;\n    }\n    cout << ans << endl ; return 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<map>\nusing namespace std;\nstruct node{long long g1,g2,g3,g4,g5,g6;int p;};\nconst int p1=1000000007,p2=1000000009;\nlong long x1p1[510000],x1p2[510000],x2p1[510000],x2p2[510000],x3p1[510000],x3p2[510000];\ninline node operator+(node x,node y){return {(x.g1+y.g1*x1p1[x.p+250000])%p1,(x.g2+y.g2*x1p2[x.p+250000])%p2,(x.g3+y.g3*x2p1[x.p+250000])%p1,(x.g4+y.g4*x2p2[x.p+250000])%p2,(x.g5+y.g5*x3p1[x.p+250000])%p1,(x.g6+y.g6*x3p2[x.p+250000])%p2,x.p+y.p};}\nchar s[260000];\nmap<long long,map<long long,map<long long,map<long long,map<long long,map<long long,int>>>>>> M;\nint main()\n{\n\tx1p1[249999]=500000004;x1p1[250000]=1;x1p1[250001]=2;\n\tx1p2[249999]=500000005;x1p2[250000]=1;x1p2[250001]=2;\n\tx2p1[249999]=666666671;x2p1[250000]=1;x2p1[250001]=3;\n\tx2p2[249999]=333333336;x2p2[250000]=1;x2p2[250001]=3;\n\tx3p1[249999]=857142863;x3p1[250000]=1;x3p1[250001]=7;\n\tx3p2[249999]=142857144;x3p2[250000]=1;x3p2[250001]=7;\n\tfor(int i=249998;i>=0;i--)x1p1[i]=x1p1[i+1]*x1p1[249999]%p1,x1p2[i]=x1p2[i+1]*x1p2[249999]%p2,x2p1[i]=x2p1[i+1]*x2p1[249999]%p1,x2p2[i]=x2p2[i+1]*x2p2[249999]%p2,x3p1[i]=x3p1[i+1]*x3p1[249999]%p1,x3p2[i]=x3p2[i+1]*x3p2[249999]%p2;\n\tfor(int i=250002;i<=500000;i++)x1p1[i]=x1p1[i-1]*x1p1[250001]%p1,x1p2[i]=x1p2[i-1]*x1p2[250001]%p2,x2p1[i]=x2p1[i-1]*x2p1[250001]%p1,x2p2[i]=x2p2[i-1]*x2p2[250001]%p2,x3p1[i]=x3p1[i-1]*x3p1[250001]%p1,x3p2[i]=x3p2[i-1]*x3p2[250001]%p2;\n\tint n;scanf(\"%d%s\",&n,s+1);\n\tnode gs={0,0,0,0,0,0,0},pr={0,0,0,0,0,0,0};\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(s[i]=='+')gs.g1=(gs.g1+x1p1[gs.p+250000])%p1,gs.g2=(gs.g2+x1p2[gs.p+250000])%p2,gs.g3=(gs.g3+x2p1[gs.p+250000])%p1,gs.g4=(gs.g4+x2p2[gs.p+250000])%p2,gs.g5=(gs.g5+x3p1[gs.p+250000])%p1,gs.g6=(gs.g6+x3p2[gs.p+250000])%p2;\n\t\telse if(s[i]=='-')gs.g1=(gs.g1-x1p1[gs.p+250000]+p1)%p1,gs.g2=(gs.g2-x1p2[gs.p+250000]+p2)%p2,gs.g3=(gs.g3-x2p1[gs.p+250000]+p1)%p1,gs.g4=(gs.g4-x2p2[gs.p+250000]+p2)%p2,gs.g5=(gs.g5-x3p1[gs.p+250000]+p1)%p1,gs.g6=(gs.g6-x3p2[gs.p+250000]+p2)%p2;\n\t\telse if(s[i]=='>')gs.p++;\n\t\telse gs.p--;\n\t}\n\tlong long ss=0;\n\tnode rg=pr+gs;\n\tM[rg.g1][rg.g2][rg.g3][rg.g4][rg.g5][rg.g6]++;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(s[i]=='+')pr.g1=(pr.g1+x1p1[pr.p+250000])%p1,pr.g2=(pr.g2+x1p2[pr.p+250000])%p2,pr.g3=(pr.g3+x2p1[pr.p+250000])%p1,pr.g4=(pr.g4+x2p2[pr.p+250000])%p2,pr.g5=(pr.g5+x3p1[pr.p+250000])%p1,pr.g6=(pr.g6+x3p2[pr.p+250000])%p2;\n\t\telse if(s[i]=='-')pr.g1=(pr.g1-x1p1[pr.p+250000]+p1)%p1,pr.g2=(pr.g2-x1p2[pr.p+250000]+p2)%p2,pr.g3=(pr.g3-x2p1[pr.p+250000]+p1)%p1,pr.g4=(pr.g4-x2p2[pr.p+250000]+p2)%p2,pr.g5=(pr.g5-x3p1[pr.p+250000]+p1)%p1,pr.g6=(pr.g6-x3p2[pr.p+250000]+p2)%p2;\n\t\telse if(s[i]=='>')pr.p++;\n\t\telse pr.p--;\n\t\tss=ss+M[pr.g1][pr.g2][pr.g3][pr.g4][pr.g5][pr.g6];\n\t\trg=pr+gs;\n\t\tM[rg.g1][rg.g2][rg.g3][rg.g4][rg.g5][rg.g6]++;\n\t}\n\tprintf(\"%lld\\n\",ss);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define REP(i,a,b) for(int i=(a),_end_=(b);i<=_end_;i++)\n#define DREP(i,a,b) for(int i=(a),_end_=(b);i>=_end_;i--)\n#define EREP(i,u) for(int i=start[u];i;i=e[i].next)\n#define fi first\n#define se second\n#define mkr(a,b) make_pair(a,b)\n#define SZ(A) ((int)A.size())\ntemplate<class T>inline void chkmin(T &a,T b){ if(a>b)a=b;}\ntemplate<class T>inline void chkmax(T &a,T b){ if(a<b)a=b;}\ninline void myassert(bool a,string s){ if(!a)cerr<<s<<endl,exit(0);}\ninline int read()\n{\n\tint s=0,f=1;char ch=getchar();\n\twhile(!isdigit(ch) && ch!='-')ch=getchar();\n\tif(ch=='-')ch=getchar(),f=-1;\n\twhile(isdigit(ch))s=s*10+ch-'0',ch=getchar();\n\treturn ~f?s:-s;\n}\n\ninline int power(int a,int b,const int mod)\n{\n\tint ans=1;\n\twhile(b)\n\t{\n\t\tif(b&1)ans=(ll)ans*a%mod;\n\t\tb>>=1;\n\t\ta=(ll)a*a%mod;\n\t}\n\treturn ans;\n}\n\nconst int maxn=2.5e5+20;\n\n#define pii pair<int,int>\n\nint n;\nint seed[3],inv[3],mod[3];\npii f[3][maxn],g[3][maxn];\nchar str[maxn];\n\ninline void init()\n{\n\tn=read();\n\tseed[1]=141937; mod[1]=1e9+7; inv[1]=power(seed[1],mod[1]-2,mod[1]);\n\tseed[2]=181; mod[2]=998244353; inv[2]=power(seed[2],mod[2]-2,mod[2]);\n\tscanf(\"%s\",str+1); \n}\n\nunordered_map<ll,int>mp;\n\ninline void doing()\n{\n\tll ans=0;\n\tREP(op,1,2)\n\t{\n\t\tfunction < pii (pii ,pii )> mult =[&](pii a,pii b) {\n\t\t\treturn mkr((a.fi+(ll)a.se*b.fi)%mod[op],(ll)a.se*b.se%mod[op]);\n\t\t};\n\t\tf[op][0]=mkr(0,1); g[op][0]=mkr(0,1);\n\t\tREP(i,1,n)\n\t\t{\n\t\t\tif(str[i]=='+')f[op][i]=mult(f[op][i-1],mkr(1,1)), g[op][i]=mult(mkr(mod[op]-1,1),g[op][i-1]);\n\t\t\telse if(str[i]=='-')f[op][i]=mult(f[op][i-1],mkr(mod[op]-1,1)),g[op][i]=mult(mkr(1,1),g[op][i-1]);\n\t\t\telse if(str[i]=='>')f[op][i]=mult(f[op][i-1],mkr(0,seed[op])),g[op][i]=mult(mkr(0,inv[op]),g[op][i-1]);\n\t\t\telse f[op][i]=mult(f[op][i-1],mkr(0,inv[op])),g[op][i]=mult(mkr(0,seed[op]),g[op][i-1]);\n\t\t}\n\t}\n\tll A=f[1][n].fi,B=f[2][n].fi;\n\tDREP(i,n,1)\n\t{\n\t\tll x=(ll)f[1][i].fi*mod[1]+f[2][i].fi;\n\t\tmp[x]++;\n\t\tll y=0;\n\t\tll a=(ll)(A-g[1][i-1].fi+mod[1])*power(g[1][i-1].se,mod[1]-2,mod[1])%mod[1];\n\t\tll b=(ll)(B-g[2][i-1].fi+mod[2])*power(g[2][i-1].se,mod[2]-2,mod[2])%mod[2];\n\t\ty=(ll)a*mod[1]+b;\n\t\tif(mp.count(y))ans+=mp[y];\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n\nint main()\n{\n\tinit();\n\tdoing();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll MOD1 = 998244353;\nconst ll MOD2 = 1000000009;\nconst int MX = 250005;\nconst ll R1 = 123123;\nconst ll IR1 = 981323583;\nconst ll R2 = 321321;\nconst ll IR2 = 234033881;\n\nll qpow(ll x, ll t, ll p)\n{\n\tll ans = 1;\n\twhile(t)\n\t{\n\t\tif(t & 1) ans = ans*x % p;\n\t\tx = x*x % p;\n\t\tt >>= 1;\n\t}\n\treturn ans;\n}\n\nll inv(ll x, ll p)\n{\n\treturn qpow(x, p-2, p);\n}\n\nstruct NUM\n{\n\tll x, y;\n\n\tNUM (const ll &x0 = 0, const ll &y0 = 0) : x(x0), y(y0) {}\n\tNUM operator + (const NUM &t) const {return NUM((x+t.x)%MOD1, (y+t.y)%MOD2);}\n\tNUM operator - (const NUM &t) const {return NUM((x-t.x+MOD1)%MOD1, (y-t.y+MOD2)%MOD2);}\n\tNUM operator * (const NUM &t) const {return NUM((x*t.x)%MOD1, (y*t.y)%MOD2);}\n\tbool operator == (const NUM &t) const {return x==t.x && y==t.y;}\n\tbool operator < (const NUM &t) const {return (x!=t.x) ? (x<t.x) : (y<t.y);}\n};\n\nint n;\nchar str[MX];\n\nvoid input()\n{\n\tscanf(\"%d\", &n);\n\tscanf(\"%s\", str+1);\n}\n\nNUM con[MX], sum[MX];\nmap<NUM, int> hav;\n\nvoid work()\n{\n\tNUM p(1, 1), t(1, 1), r(R1, R2), ir(IR1, IR2);\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tif(str[i] == '+') con[i] = p;\n\t\telse if(str[i] == '-') con[i] = NUM(0, 0) - p;\n\t\telse if(str[i] == '>') p = p * r;\n\t\telse p = p * ir;\n\t\tsum[i] = sum[i-1] + con[i];\n\t\thav[sum[i]]++;\n\t}\n\tll ans = 0;\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tans += hav[sum[n]*t+sum[i-1]];\n\t\tif(str[i] == '>') t = t * r;\n\t\telse if(str[i] == '<') t = t * ir;\n\t\thav[sum[i]]--;\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main()\n{\n\tinput();\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>  \n\n#pragma warning(disable:4996)  \n#pragma comment(linker, \"/STACK:336777216\")  \nusing namespace std;\n\n#define mp make_pair  \n#define Fi first  \n#define Se second  \n#define pb(x) push_back(x)  \n#define szz(x) ((int)(x).size())  \n#define rep(i, n) for(int i=0;i<n;i++)  \n#define all(x) (x).begin(), (x).end()  \n#define ldb ldouble  \n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 17;\nconst ll MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n\nll mul_inv(ll a, ll b) {\n\tll t1 = a, t2 = b, t3;\n\tll v1 = 1, v2 = 0, v3;\n\twhile (t2 != 1) {\n\t\tll x = t1 / t2;\n\t\tt3 = t1 - x*t2;\n\t\tv3 = v1 - x*v2;\n\t\tt1 = t2, t2 = t3;\n\t\tv1 = v2, v2 = v3;\n\t}\n\treturn (v2 + b) % b;\n}\nll mypow(ll a, ll b, ll m) {\n\tll rv = 1;\n\twhile (b) {\n\t\tif (b % 2) rv = rv*a%m;\n\t\ta = a*a%m;\n\t\tb /= 2;\n\t}\n\treturn rv;\n}\n\nll P[3] = { 1234577, 1234603, 1234613 };\nll Pinv[3];\nll MO[3] = { MOD, MOD + 2, MOD + 216 };\nll po[3][600050]; // po[i][j] = P[i] ** (j-300000) % MO[i]\n\nchar in[250050];\n\nll sum[250050][3];\nint pos[250050];\n\nint main() {\n\tint N, i, j;\n\tfor (i = 0; i < 3; i++) {\n\t\tPinv[i] = mul_inv(P[i], MO[i]);\n\t\tpo[i][300000] = 1;\n\t\tfor (j = 300001; j <= 600000; j++) po[i][j] = po[i][j - 1] * P[i] % MO[i];\n\t\tfor (j = 299999; j >= 0; j--) po[i][j] = po[i][j + 1] * Pinv[i] % MO[i];\n\t}\n\t\n\tscanf(\"%d %s\", &N, in + 1);\n\tpos[0] = 0;\n\tfor (i = 1; i <= N; i++) {\n\t\tpos[i] = pos[i - 1];\n\t\tif (in[i] == '>') pos[i]++;\n\t\tif (in[i] == '<') pos[i]--;\n\t\t\n\t\tfor (j = 0; j < 3; j++) {\n\t\t\tsum[i][j] = sum[i - 1][j];\n\t\t\tif (in[i] == '+') sum[i][j] = (sum[i][j] + po[j][pos[i] + 300000]) % MO[j];\n\t\t\tif (in[i] == '-') sum[i][j] = (sum[i][j] - po[j][pos[i] + 300000] + MO[j]) % MO[j];\n\t\t}\n\t}\n\n\tmap <pair<ll, pll>, int> Mx;\n\tll ans = 0;\n\tfor (i = N; i >= 1; i--) {\n\t\tMx[mp(sum[i][0], pll(sum[i][1], sum[i][2]))]++;\n\n\t\tll val[3] = { 0,0,0 };\n\t\tfor (j = 0; j < 3; j++) {\n\t\t\tval[j] = sum[N][j] * po[j][pos[i - 1] + 300000] % MO[j];\n\t\t\tval[j] = (val[j] + sum[i - 1][j]) % MO[j];\n\t\t}\n\t\tans += Mx[mp(val[0], pll(val[1], val[2]))];\n\t}\n\treturn !printf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "const int N = 400005;\nconst int LG = 21;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nint n;\nstring s;\nll sufa[N];\nll suf0[N];\nconst ll K = 29;\nconst ll rK = rev(K);\nll pref0[N];\nll prefa[N];\nll moves[N];\nmap<int, ll> deg;\n\nsigned main()\n{\n    deg[0] = 1;\n    for (int i = 1; i < N; i++) deg[i] = deg[i - 1] * K % MOD;\n    for (int i = 1; i < N; i++) deg[-i] = deg[-i + 1] * rK % MOD;\n    srand(time(NULL));\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n    cin >> n >> s;\n    ll a = 0;\n    for (int i = n - 1; i >= 0; i--)\n    {\n        if (s[i] == '+')\n        {\n            a = (a + MOD - 1) % MOD;\n        }\n        if (s[i] == '-')\n        {\n            a = (a + 1) % MOD;\n        }\n        if (s[i] == '>')\n        {\n            a = (a * K) % MOD;\n        }\n        if (s[i] == '<')\n        {\n            a = (a * rK) % MOD;\n        }\n    }\n    pref0[0] = 0, prefa[0] = a, moves[0] = 0;\n    if (s[0] == '+') pref0[0] = (pref0[0] + 1) % MOD;\n    if (s[0] == '-') pref0[0] = (pref0[0] + MOD - 1) % MOD;\n    if (s[0] == '<') pref0[0] = (pref0[0] * K) % MOD;\n    if (s[0] == '>') pref0[0] = (pref0[0] * rK) % MOD;\n    if (s[0] == '+') prefa[0] = (prefa[0] + 1) % MOD;\n    if (s[0] == '-') prefa[0] = (prefa[0] + MOD - 1) % MOD;\n    if (s[0] == '<') prefa[0] = (prefa[0] * K) % MOD;\n    if (s[0] == '>') prefa[0] = (prefa[0] * rK) % MOD;\n    if (s[0] == '>') moves[0]++;\n    if (s[0] == '<') moves[0]--;\n    for (int i = 1; i < n; i++)\n    {\n        if (s[i] == '+') pref0[i] = (pref0[i - 1] + 1) % MOD;\n        if (s[i] == '-') pref0[i] = (pref0[i - 1] + MOD - 1) % MOD;\n        if (s[i] == '<') pref0[i] = (pref0[i - 1] * K) % MOD;\n        if (s[i] == '>') pref0[i] = (pref0[i - 1] * rK) % MOD;\n        if (s[i] == '+') prefa[i] = (prefa[i - 1] + 1) % MOD;\n        if (s[i] == '-') prefa[i] = (prefa[i - 1] + MOD - 1) % MOD;\n        if (s[i] == '<') prefa[i] = (prefa[i - 1] * K) % MOD;\n        if (s[i] == '>') prefa[i] = (prefa[i - 1] * rK) % MOD;\n        moves[i] = moves[i - 1];\n        if (s[i] == '>') moves[i]++;\n        if (s[i] == '<') moves[i]--;\n    }\n    for (int j = 0; j < n; j++)\n    {\n        if (s[j] == '+')\n        {\n            suf0[0] = (suf0[0] + 1) % MOD;\n        }\n        if (s[j] == '-')\n        {\n            suf0[0] = (suf0[0] + MOD - 1) % MOD;\n        }\n        if (s[j] == '<')\n        {\n            suf0[0] = (suf0[0] * K) % MOD;\n        }\n        if (s[j] == '>')\n        {\n            suf0[0] = (suf0[0] * rK) % MOD;\n        }\n    }\n    for (int i = 0; i < n; i++) suf0[i + 1] = (suf0[0] - pref0[i] * deg[moves[i]] + MOD * MOD) % MOD;\n    for (int i = 0; i < n; i++) sufa[i] = (suf0[i] + a * deg[(i > 0 ? moves[i - 1] : 0) - moves[n - 1]]) % MOD;\n    ll ans = 0;\n    map<vector<ll>, ll> cnt;\n    for (int i = n; i >= 0; i--)\n    {\n        ans += cnt[{sufa[i]}];\n        cnt[{suf0[i]}]++;\n    }\n    cout << ans;\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(a) begin(a), end(a)\n#define csz(a) (int) a.size()\n#define pb push_back\n#define epb emplace_back\n#define mp make_pair\n#define load(a, v) fill(begin(a), end(a), v)\n#define load_mem(a, v) memset(a, v, sizeof(a));\n#define iostream_optimize() ios::sync_with_stdio(false); cin.tie(0);\n#define long long long\nconst long MOD = 1e9+7, LINF = 1e18 + 1e16;\nconst int INF = 1e9+1;\nconst double EPS = 1e-10;\nconst int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<< END TEMPLATE >>>>>>>>>>>>>>>>>>>>>>>>>>> */\nconst int N = 2.5e5+1;\nlong P;\nseed_seq seq{\n\t(uint64_t) chrono::duration_cast<chrono::nanoseconds>(chrono::high_resolution_clock::now().time_since_epoch()).count(),\n  (uint64_t) __builtin_ia32_rdtsc(),\n  (uint64_t) (uintptr_t) make_unique<char>().get()\n};\n\nlong modPow(long b, long e) {\n\tif(!e) return 1;\n\tif(e == 1) return b;\n\treturn modPow(b*b % MOD, e >> 1) * modPow(b, e & 1) % MOD;\n}\n\nint n;\nchar s[N];\nlong ans, shift[N], h[N];\nmap<long, int> cnt;\n\nvoid gen_base() {\n\tmt19937 rng(seq);\n\tP = uniform_int_distribution<int>(n+1, MOD-1)(rng);\n}\n\nint main() {\n\tiostream_optimize();\n\tcin >> n >> (s+1);\n\tgen_base();\n\tshift[0] = n;\n\tfor(int i = 1; i <= n; i++) {\n\t\tshift[i] = shift[i-1];\n\t\th[i] = h[i-1];\n\t\tif(s[i] == '>') --shift[i];\n\t\tif(s[i] == '<') ++shift[i];\n\t\tif(s[i] == '+') h[i] = (h[i] + modPow(P, shift[i])) % MOD;\n\t\tif(s[i] == '-') h[i] = (h[i] - modPow(P, shift[i]) + MOD) % MOD;\n\t}\n\t++cnt[h[n]];\n\tfor(int i = 1; i <= n; i++) {\n\t\tans += cnt[h[i]];\n\t\tlong coeff = (n > shift[i] ? modPow(modPow(P, n - shift[i]), MOD-2) : modPow(P, shift[i] - n));\n\t\t// cout << shift[i] << ' ' << h[i] << ' ' << (h[n] * coeff + h[i]) % MOD <<  ' ' << cnt[h[i]] << endl;\n\t\t++cnt[(h[n] * coeff + h[i]) % MOD];\n\t}\n\tcout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<climits>\n#include<bitset>\n#include<map>\n#define pii pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define int __int128\n#define mod1 10000000000037\n#define mod2 1000000000000000009\nusing namespace std;\ninline int read(){\n    int f=1,ans=0;char c=getchar();\n    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}\n    while(c>='0'&&c<='9'){ans=ans*10+c-'0';c=getchar();}\n    return f*ans;\n}\nconst int MAXN=5e5+11;\nint N;char str[MAXN];\nint h1[MAXN],s1[MAXN],x1=2,x2=3,res,h2[MAXN],s2[MAXN];\nint ksm1(int a,int b){\n    int ans=1;\n    while(b){if(b&1) ans*=a,ans%=mod1;a*=a,a%=mod1;b>>=1;}return ans;\n}\nint pw1(int a,int b){\n    if(b>=0) return ksm1(a,b);\n    int res=ksm1(a,-b);return ksm1(res,mod1-2);\n}\nint ksm2(int a,int b){\n    int ans=1;\n    while(b){if(b&1) ans*=a,ans%=mod2;a*=a,a%=mod2;b>>=1;}return ans;\n}\nint pw2(int a,int b){\n    if(b>=0) return ksm2(a,b);\n    int res=ksm2(a,-b);return ksm2(res,mod1-2);\n}\nmap<pii,int> M;\nvoid ins(int ps){M[mp( (h1[ps]+pw1(x1,s1[ps])*h1[N])%mod1 , (h2[ps]+pw2(x2,s2[ps])*h2[N])%mod2 )]++;return;}\ninline void print(int x){\n    if(x>9) print(x/10);\n    putchar(x%10+'0');\n}\nsigned main(){\n    //freopen(\"1.in\",\"r\",stdin);\n    srand(time(0));\n    x1=rand(),x2=rand();\n    N=read();scanf(\"%s\",str+1);\n    for(int i=1;i<=N;i++){\n        if(str[i]=='+') h1[i]=h1[i-1]+pw1(x1,s1[i-1]),s1[i]=s1[i-1],h1[i]%=mod1;\n        if(str[i]=='-') h1[i]=h1[i-1]-pw1(x1,s1[i-1])+mod1,s1[i]=s1[i-1],h1[i]%=mod1;\n        if(str[i]=='>') h1[i]=h1[i-1],s1[i]=s1[i-1]+1;\n        if(str[i]=='<') h1[i]=h1[i-1],s1[i]=s1[i-1]-1;\n        if(str[i]=='+') h2[i]=h2[i-1]+pw2(x2,s2[i-1]),s2[i]=s2[i-1],h2[i]%=mod2;\n        if(str[i]=='-') h2[i]=h2[i-1]-pw2(x2,s2[i-1])+mod2,s2[i]=s2[i-1],h2[i]%=mod2;\n        if(str[i]=='>') h2[i]=h2[i-1],s2[i]=s2[i-1]+1;\n        if(str[i]=='<') h2[i]=h2[i-1],s2[i]=s2[i-1]-1;\n    }\n    ins(0);\n    for(int i=1;i<=N;i++){\n        res+=M[mp(h1[i],h2[i])];\n        ins(i);\n    }print(res);printf(\"\\n\");return 0;\n}/*\n  5\n  +>+<-\n  */\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int mo = 998244353, X = 1e4 + 7;\nconst int N = 2.5e5 + 10;\nint n;\nll cnt[N], pre[N], X1;\nchar s[N];\nll ksm(ll x, ll y) {\n\tll ret = 1; for (; y; y >>= 1) {\n\t\tif (y & 1) ret = ret * x % mo;\n\t\tx = x * x % mo;\n\t}\n\treturn ret;\n}\n\nmap<ll,int> h;\nll tj(int x) {\n\treturn (pre[n] * cnt[x] % mo + pre[x]) % mo;\n}\n\nint main() {\n\tcin >> n;\n\tscanf(\"%s\", s + 1);\n\tcnt[0] = 1;\n\tX1 = ksm(X, mo - 2);\n\tfor(int i = 1; i <= n; i++) {\n\t\tcnt[i] = cnt[i - 1];\n\t\tpre[i] = pre[i - 1];\n\t\tif (s[i] == '>') {\n\t\t\tcnt[i] = cnt[i] * X % mo;\n\t\t} else if (s[i] == '<') {\n\t\t\tcnt[i] = cnt[i] * X1 % mo;\n\t\t} else if (s[i] == '+') {\n\t\t\tpre[i] = (pre[i] + cnt[i]) % mo;\n\t\t} else {\n\t\t\tpre[i] = (pre[i] - cnt[i]) % mo;\n\t\t}\n\t}\n\tll ans = 0;\n\th[tj(0)] = 1;\n\tfor(int i = 1; i <= n; i++) {\n\t\tpre[i] = (pre[i] + mo) % mo;\n\t\tans += h[pre[i]];\n\t\th[tj(i)] ++;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"trapv\")\n#include<bits/stdc++.h>\n#define int ll\n#define pb push_back\n#define all(x) x.begin(), x.end()\nusing namespace std;\nusing ll = long long;\nconst int maxn = 1<<20, mod = 119<<23|1;\nconst int B = 1000007;\nint n, pw[maxn], F[maxn], ps = 0, ans = 0;\nstring s;\nmap<int, int> cnt;\nvoid add(int &a, int b) {\n\ta = a+b>=mod?a+b-mod:a+b;\n}\nll bp(ll a, ll p) {\n\tll r = 1;\n\twhile(p) {\n\t\tif(p&1) r = r*a%mod;\n\t\ta = a*a%mod, p>>=1;\n\t}\n\treturn r;\n} \nsigned main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> n >> s;\n\tpw[0] = 1;\n\tfor(int i = 1; i < maxn; i++) pw[i] = pw[i-1]*1ll*B%mod;\n\tcnt[0]++;\n\tint cur = 0;\n\tfor(int i = 0; i < n; i++) {\n\t\tif(s[i] == '>') ps++;\n\t\tif(s[i] == '<') ps--;\n\t\tif(s[i] == '+') add(cur, pw[(maxn/2) + ps]);\n\t\tif(s[i] == '-') add(cur, mod-pw[(maxn/2) + ps]);\n\t\tF[i+1] = cur;\n\t\tcnt[cur]++;\n\t}\n\tps = 0;\n\tfor(int ccur = 0, ps = 0, i = 0; i <= n; i++) {\n\t\tcnt[F[i]]--;\n\t\tans += cnt[(bp(B, mod-1+ps)*1ll*cur + ccur)%mod];\n\t\tif(i == n) continue;\n\t\tif(s[i] == '>') ps++;\n\t\tif(s[i] == '<') ps--;\n\t\tif(s[i] == '+') add(ccur, pw[(maxn/2) + ps]);\n\t\tif(s[i] == '-') add(ccur, mod-pw[(maxn/2) + ps]);\n\t}\n\tcout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ll;\n#define MN 250000\nchar s[MN+5];\nll x=233,y=7204522363551799129,f[MN+5],X=1,Y;\nmap<ll,int> mp;\nint main()\n{\n\tint n,i;long long ans=0;\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",s+1);\n\tfor(i=1;i<=n;++i)\n\t{\n\t\tf[i]=f[i-1];\n\t\tif(s[i]=='+')f[i]+=X;\n\t\tif(s[i]=='-')f[i]-=X;\n\t\tif(s[i]=='<')X*=x;\n\t\tif(s[i]=='>')X*=y;\n\t\t++mp[f[i]];\n\t}\n\tfor(i=X=1;i<=n;++i)\n\t{\n\t\tans+=mp[f[n]*X+Y];\n\t\tif(s[i]=='+')Y+=X;\n\t\tif(s[i]=='-')Y-=X;\n\t\tif(s[i]=='<')X*=x;\n\t\tif(s[i]=='>')X*=y;\n\t\t--mp[f[i]];\n\t}\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <cstdio>\n\nusing namespace std;\n \n#define rep(i, n) for (int i = 0; i < (int) n; i++)\n \nconst int MOD = 1e9 + 7;\nconst int B = 23456789;\n\nlong long Pow(long long a, long long x) {\n        long long res = 1;\n        while (x > 0) {\n                if (x & 1) res = res * a % MOD;\n                a = a * a % MOD;\n                x >>= 1;\n        }\n        return res;\n}\n\nlong long Inv(long long a) { return Pow(a, MOD - 2); }\n \nint main() {\n\tint n;\n        scanf(\"%d\", &n);\n\tstring s;\n        cin >> s;\n\tint x = 250000;\n        long long h = 0;\n\tvector<int> xs(n + 1);\n        xs[0] = x;\n\tvector<long long> hs(n + 1);\n        hs[0] = h;\n\trep(i, n) {\n\t\tchar c = s[i];\n\t\tif (c == '+') h = (h + Pow(B, x)) % MOD;\n\t\tif (c == '-') h = (h - Pow(B, x) + MOD) % MOD;\n\t\tif (c == '>') x ++;\n\t\tif (c == '<') x --;\n\t\txs[i + 1] = x;\n                hs[i + 1] = h;\n\t}\n\tmap<long long, int> mp;\n\tlong long ans = 0;\n\tfor (int i = n; i >= 0; i--) {\n\t\tint dx = xs[i] - xs[0];\n\t\tlong long coef = (dx >= 0 ? Pow(B, dx) : Inv(Pow(B, -dx)));\n\t\tlong long hoge = (hs[i] + hs[n] * coef) % MOD;\n\t\tans += mp[hoge];\n\t\tmp[hs[i]]++;\n\t}\n        printf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define fst first\n#define snd second\n#define SZ(u) ((int) (u).size())\n#define ALL(u) (u).begin(), (u).end()\n\ninline void proc_status()\n{\n    ifstream t(\"/proc/self/status\");\n    cerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline T read()\n{\n\tregister T sum(0), fg(1);\n\tregister char ch(getchar());\n\tfor(; !isdigit(ch); ch = getchar()) if(ch == '-') fg = -1;\n\tfor(;  isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) - '0' + ch;\n\treturn sum * fg;\n}\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int, int> pii;\n\nconst int MAXN = (int) 2.5e5;\n\nint n;\n\nchar s[MAXN + 5];\n\ninline void input()\n{\n\tn = read<int>();\n\tscanf(\"%s\", s + 1);\n}\n\nconst int MOD = 1004535809, B = (int) 233;\n\ninline int fpm(int x, int y)\n{\n\tint res = 1;\n\tfor(; y; y >>= 1, x = (LL) x * x % MOD) if(y & 1) res = (LL) res * x % MOD;\n\treturn res;\n}\n\ninline void solve()\n{\n\t// Thanks to zhou888\n\n\tstatic int p[MAXN + 5], prefix[MAXN + 5], p_pow[MAXN * 2 + 5];\n\n\tp_pow[0 + n] = 1;\n\tfor(int i = 1, invB = fpm(B, MOD - 2); i <= n; ++i)\n\t{\n\t\tp_pow[ i + n] = (LL) p_pow[ i - 1 + n] *\tB % MOD;\n\t\tp_pow[-i + n] = (LL) p_pow[-i + 1 + n] * invB % MOD;\n\t}\n\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tp[i] = p[i - 1], prefix[i] = prefix[i - 1];\n\t\tif(s[i] == '<') --p[i];\n\t\tif(s[i] == '>') ++p[i];\n\t\tif(s[i] == '+') (prefix[i] += p_pow[p[i] + n]) %= MOD;\n\t\tif(s[i] == '-') (prefix[i] -= p_pow[p[i] + n]) %= MOD;\n\t}\n\n\tstatic unordered_map<int, int> cnt;\n\n\tLL ans = 0;\n\tfor(int i = 1; i <= n; ++i) ans += prefix[i] == prefix[n];\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tans += cnt[(prefix[i] + MOD) % MOD];\n\t\tint res = (prefix[i] + (LL) p_pow[p[i] + n] * prefix[n] % MOD) % MOD;\n\t\t++cnt[(res + MOD) % MOD];\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main()\n{\n//\tfreopen(\"F.in\", \"r\", stdin);\n//\tfreopen(\"F.out\", \"w\", stdout);\n\n\tinput();\n\tsolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MP make_pair\n#define fi first\n#define se second\n#define sz(x) (int)(x).size()\n//#define Local\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\nconst int N = 250005, P1 = 1e9 + 7, P2 = 1e9 + 9;\n\nll qpow(ll a, ll b, ll c) {\n    ll ans = 1;\n    while(b) {\n        if(b & 1) ans = ans * a % c;\n        a = a * a % c;\n        b >>= 1;\n    }\n    return ans;\n}\n\nchar s[N];\nint n;\n\nstruct rolling_hash{\n    ll a, b;\n    rolling_hash() {\n        a = b = 0;\n    }\n    rolling_hash(ll x) {\n        a = x % P1;\n        b = x % P2;\n    }\n    rolling_hash(ll x, ll y) {\n        a = x % P1;\n        b = y % P2;\n    }\n    rolling_hash operator + (const rolling_hash& A) const {\n        return rolling_hash(a + A.a, b + A.b);\n    }\n    rolling_hash operator - (const rolling_hash& A) const {\n        return rolling_hash(a - A.a + P1, b - A.b + P2);\n    }\n    rolling_hash operator * (const rolling_hash& A) const {\n        return rolling_hash(a * A.a, b * A.b);\n    }\n    ll get() {\n        return a * P2 + b;\n    }\n}hs[N], pos[N];\n\nrolling_hash X = 1000003;\nrolling_hash invX = rolling_hash(qpow(X.a, P1 - 2, P1), qpow(X.b, P2 - 2, P2));\n\nunordered_map <ll, int> mp;\n\nvoid run() {\n    mp.clear();\n    cin >> s + 1;\n    pos[0] = 1;\n    for(int i = 1; i <= n; i++) {\n        pos[i] = pos[i- 1];\n        if(s[i] == '>') {\n            pos[i] = pos[i - 1] * X;\n        } else if(s[i] == '<') {\n            pos[i] = pos[i - 1] * invX;\n        }\n    }\n    hs[n + 1] = 0;\n    for(int i = n; i >= 1; i--) {\n        hs[i] = hs[i + 1];\n        if(s[i] == '+') {\n            hs[i] = hs[i] + pos[i];\n        } else if(s[i] == '-') {\n            hs[i] = hs[i] - pos[i];\n        }\n    }\n    int ans = 0;\n    ++mp[hs[n + 1].get()];\n    for(int i = n; i >= 1; i--) {\n        rolling_hash now = hs[i] - hs[1] * pos[i - 1];\n        ans += mp[now.get()];\n        ++mp[hs[i].get()];\n//        cout << ans << '\\n';\n    }\n    cout << ans << '\\n';\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n    cout << fixed << setprecision(20);\n#ifdef Local\n    freopen(\"../input.in\", \"r\", stdin);\n    freopen(\"../output.out\", \"w\", stdout);\n#endif\n    while(cin >> n) run();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "    #include \"bits/stdc++.h\"\n            using namespace std;\n             \n            #define MAX 600012\n             \n            int n;\n            char buf[MAX];\n            string s;\n            valarray<long long int> MOD1;\n            valarray<long long int> MOD2;\n            vector<valarray<long long int> > p2;\n            vector<valarray<long long int> > vv;\n            vector<int> ps;\n            map<pair<long long int,long long int>, int> mp;\n            long long int ppow(long long int i, long long int j, long long int MOD) {\n            \tlong long int ret = 1;\n            \twhile (j) {\n            \t\tif (j & 1LL)ret *= i;\n            \t\tif (ret >= MOD)ret %= MOD;\n            \t\tj >>= 1LL;\n            \t}\n            \treturn ret;\n            }\n             \n            valarray<long long int> calc(int dif) {\n            \tvalarray<long long int> ret;\n            \tret.resize(2, 0);\n            \tfor (int j = 0; j < 2; j++) {\n            \t\tif (dif < 0) {\n            \t\t\tret[j]=ppow(ppow(MOD1[j],MOD2[j]-2,MOD2[j]),-dif,MOD2[j]);\n            \t\t}\n            \t\telse {\n            \t\t\tret[j] = ppow(MOD1[j],dif, MOD2[j]);\n            \t\t}\n            \t}\n            \treturn ret;\n            }\n             \n            int main() {\n            \tMOD1.resize(2);\n            \tMOD2.resize(2);\n            \tp2.push_back(valarray<long long int>());\n            \tp2.back().resize(2);\n            \tp2.back()[0] = p2.back()[1] = 1;\n            \tMOD2[1] = 1000000007;\n            \tMOD1[0] = 555522277;\n            \tMOD1[1] = 895612782;\n            \tMOD2[0] = 998244353;\n            \tp2[0] %= MOD2;\n            \tfor (int i = 1; i < MAX; i++) p2.push_back((p2.back()*MOD1)%MOD2);\n            \tcin >> n;\n            \tscanf(\"%s\", buf);\n            \ts = buf;\n            \tint pos = MAX/2;\n            \tvalarray<long long int> hs;\n            \ths.resize(2,0);\n            \tvv.push_back(hs);\n            \tps.push_back(pos);\n            \tfor (int i = 0; i < s.size(); i++) {\n            \t\tif (s[i] == '<') pos--;\n            \t\telse if (s[i] == '>') pos++;\n            \t\telse if (s[i] == '+') hs += p2[pos];\n            \t\telse if (s[i] == '-') hs += MOD2-p2[pos];\n            \t\ths %= MOD2;\n            \t\tif(hs[0]<0LL||hs[1]<0LL||p2[0]<0LL||p2[1]<0LL)return 1;\n            \t\tvv.push_back(hs);\n            \t\tps.push_back(pos);\n            \t}\n            \tlong long int way = 0;\n            \tfor (int i = vv.size() - 1; i >= 0; i--) {\n            \t\tvalarray<long long int> want = (vv[i] + ((vv.back()*calc(-MAX/2+ps[i]))%MOD2))%MOD2;\n            \t\tway += mp[make_pair(want[0], want[1])];\n            \t\tmp[make_pair(vv[i][0],vv[i][1])]++;\n            \t}\n            \tprintf(\"%lld\\n\", way);\n            \treturn 0;\n            }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll pow_mod(ll x,int k,ll MOD) {\n  ll ans=1;\n  while (k) {\n  \tif (k&1) ans=ans*x%MOD;\n  \tx=x*x%MOD;\n  \tk>>=1;\n  }\n  return ans;\n}\n\nconst int prime[10]={998244353,989390509,807943519,934784771,814294163,847763881,988501229,831312439,887199301,993514421};\nconst ll H[10]={19260817,760277961,602494845,909561729,536778743,682353612,738823132,631427472,848965391,984035289};\n\nint powd[10][1000005],invd[10][1000005];\n\nvoid pre(int n) {\n  for(int i=0;i<10;i++) {\n    ll inv=pow_mod(H[i],prime[i]-2,prime[i]);\n    assert(inv*H[i]%prime[i]==1);\n    powd[i][0]=1;\n    for(int j=1;j<=n;j++) powd[i][j]=(ll)powd[i][j-1]*H[i]%prime[i];\n    invd[i][0]=1;\n    for(int j=1;j<=n;j++) invd[i][j]=(ll)invd[i][j-1]*inv%prime[i];\n  }\n}\n\nstruct Data {\n  int num[10];\n  Data() {memset(num,0,sizeof(num));}\n  Data operator + (Data b) {\n  \tData c;\n  \tfor(int i=0;i<10;i++) c.num[i]=(num[i]+b.num[i])%prime[i];\n  \treturn c;\n  }\n  void add(int x) {\n  \tfor(int i=0;i<10;i++) num[i]=(num[i]+powd[i][x])%prime[i];\n  }\n  void dec(int x) {\n  \tfor(int i=0;i<10;i++) num[i]=(num[i]-powd[i][x]+prime[i])%prime[i];\n  }\n  void rshift(int x) {\n  \tfor(int i=0;i<10;i++) num[i]=(ll)num[i]*powd[i][x]%prime[i];\n  }\n  void lshift(int x) {\n  \tfor(int i=0;i<10;i++) num[i]=(ll)num[i]*invd[i][x]%prime[i];\n  }\n  bool operator < (const Data & b) const {\n  \tfor(int i=0;i<10;i++)\n  \t  if (num[i]!=b.num[i]) return num[i]<b.num[i];\n  \treturn 0;\n  }\n};\n\nmap <Data,int> mp;\nData p[250005];\n\nchar str[250005];\n\nint main() {\n  int n;\n  scanf(\"%d%s\",&n,str+1);\n  pre(4*n);\n  int d=0;\n  for(int i=1;i<=n;i++) {\n  \tp[i]=p[i-1];\n    if (str[i]=='+') p[i].add(2*n+d);\n    else if (str[i]=='-') p[i].dec(2*n+d);\n    else if (str[i]=='>') d++;\n    else d--;\n    mp[p[i]]++;\n  }\n  ll ans=0;\n  d=0;\n  for(int i=1;i<=n;i++) {\n  \tData t=p[n];\n  \tif (d>=0) t.rshift(d); else t.lshift(-d);\n\tt=t+p[i-1];\n\tif (mp.count(t)) ans+=mp[t];\n\tif (str[i]=='>') d++;\n\telse if (str[i]=='<') d--;\n\tmp[p[i]]--;\n  }\n  printf(\"%lld\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MAXN 250000\n#define ll long long\n#define rint register int\ninline int read(){int r;int s=0,c;for(;!isdigit(c=getchar());s=c);for(r=c^48;isdigit(c=getchar());(r*=10)+=c^48);return s^45?r:-r;}\n#define BS 998244353\n#define EV1 669690699\n#define EV2 679604188\n#define MOD1 1004535809\n#define MOD2 1061109589\nstruct Hash\n{\n\tint h1,h2; Hash(){} Hash(int _h1, int _h2){h1=_h1;h2=_h2;} inline Hash operator + (Hash b){return Hash((h1+b.h1)%MOD1,(h2+b.h2)%MOD2);} inline ll v(){return (ll)h1<<32|h2;}\n\tinline Hash operator - (Hash b){return Hash((h1+MOD1-b.h1)%MOD1,(h2+MOD2-b.h2)%MOD2);} inline Hash operator * (Hash b){return Hash(1ll*h1*b.h1%MOD1,1ll*h2*b.h2%MOD2);}\n}P[MAXN+5], H[MAXN+5], B(BS,BS), E(EV1,EV2), I(1,1), _; char s[MAXN+5]; int n; unordered_map<ll,int> G; ll Ans;\nint main()\n{\n\tn = read(); scanf(\"%s\",s+1); P[0] = I; for(rint i = 1; i <= n; i++) switch(P[i]=P[i-1],H[i]=H[i-1],s[i]){case'<':P[i]=P[i]*E;break;case'>':P[i]=P[i]*B;break;case'+':H[i]=H[i]+P[i];break;case'-':H[i]=H[i]-P[i];break;}\n\tfor(rint i = n; i; ++G[H[i].v()], Ans += G[(H[n]*P[i-1]+H[i-1]).v()], i--); return !printf(\"%lld\\n\",Ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<climits>\n#include<bitset>\n#include<map>\n#define pii pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define int __int128\n#define mod1 10000000000037\n#define mod2 1000000000000000009\nusing namespace std;\ninline int read(){\n    int f=1,ans=0;char c=getchar();\n    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}\n    while(c>='0'&&c<='9'){ans=ans*10+c-'0';c=getchar();}\n    return f*ans;\n}\nconst int MAXN=5e5+11;\nint N;char str[MAXN];\nint h1[MAXN],s1[MAXN],x1=250001,x2=1001,res,h2[MAXN],s2[MAXN];\nint ksm1(int a,int b){\n    int ans=1;\n    while(b){if(b&1) ans*=a,ans%=mod1;a*=a,a%=mod1;b>>=1;}return ans;\n}\nint pw1(int a,int b){\n    if(b>=0) return ksm1(a,b);\n    int res=ksm1(a,-b);return ksm1(res,mod1-2);\n}\nint ksm2(int a,int b){\n    int ans=1;\n    while(b){if(b&1) ans*=a,ans%=mod2;a*=a,a%=mod2;b>>=1;}return ans;\n}\nint pw2(int a,int b){\n    if(b>=0) return ksm2(a,b);\n    int res=ksm2(a,-b);return ksm2(res,mod1-2);\n}\nmap<pii,int> M;\nvoid ins(int ps){M[mp( (h1[ps]+pw1(x1,s1[ps])*h1[N])%mod1 , (h2[ps]+pw2(x2,s2[ps])*h2[N])%mod2 )]++;return;}\ninline void print(int x){\n    if(x>9) print(x/10);\n    putchar(x%10+'0');\n}\nsigned main(){\n    //freopen(\"1.in\",\"r\",stdin);\n    N=read();scanf(\"%s\",str+1);\n    for(int i=1;i<=N;i++){\n        if(str[i]=='+') h1[i]=h1[i-1]+pw1(x1,s1[i-1]),s1[i]=s1[i-1],h1[i]%=mod1;\n        if(str[i]=='-') h1[i]=h1[i-1]-pw1(x1,s1[i-1])+mod1,s1[i]=s1[i-1],h1[i]%=mod1;\n        if(str[i]=='>') h1[i]=h1[i-1],s1[i]=s1[i-1]+1;\n        if(str[i]=='<') h1[i]=h1[i-1],s1[i]=s1[i-1]-1;\n        if(str[i]=='+') h2[i]=h2[i-1]+pw2(x2,s2[i-1]),s2[i]=s2[i-1],h2[i]%=mod2;\n        if(str[i]=='-') h2[i]=h2[i-1]-pw2(x2,s2[i-1])+mod2,s2[i]=s2[i-1],h2[i]%=mod2;\n        if(str[i]=='>') h2[i]=h2[i-1],s2[i]=s2[i-1]+1;\n        if(str[i]=='<') h2[i]=h2[i-1],s2[i]=s2[i-1]-1;\n    }\n    ins(0);\n    for(int i=1;i<=N;i++){\n        res+=M[mp(h1[i],h2[i])];\n        ins(i);\n    }print(res);printf(\"\\n\");return 0;\n}/*\n  5\n  +>+<-\n  */\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int Maxn=250005,mod=1e9+7,base=998244353,invbase=4924091;\nint n;\nchar c[Maxn];\nstruct state{\n\tint hash,cur;\n\tstate(int _hash,int _cur){\n\t\thash=_hash;\n\t\tcur=_cur;\n\t}\n\tvoid add(char c){\n\t\tif(c=='>')cur=1ll*cur*base%mod;\n\t\tif(c=='<')cur=1ll*cur*invbase%mod;\n\t\tif(c=='+')hash=(hash+cur)%mod;\n\t\tif(c=='-')hash=(hash-cur)%mod;\n\t\tif(hash<0)hash+=mod;\n\t}\n\tstate operator*(state rhs){\n\t\treturn state((hash+1ll*rhs.hash*cur)%mod,1ll*cur*rhs.cur%mod);\n\t}\n\tbool operator<(const state&rhs)const{\n\t\treturn hash<rhs.hash;\n\t}\n};\nint main(){\n\tmap<state,int>cnt;\n\tlong long ans=0;\n\tscanf(\"%d%s\",&n,c+1);\n\tstate full(0,1),prefix(0,1);\n\tfor(int i=1;i<=n;i++)full.add(c[i]);\n\tfor(int i=1;i<=n;i++){\n\t\tstate tmp=full*prefix;\n\t\tcnt[prefix*full]++;\n\t\tprefix.add(c[i]);\n\t\tans+=cnt[prefix];\n\t}\n\tcout<<ans<<\"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <assert.h>\n#include <sys/time.h>\n#include <fstream>\n#include <iomanip>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  FOR(i,0,n)\n#define REP(i,n)  FOR(i,0,n)\n#define each(i,c) for(auto i=(c).begin(); i!=(c).end(); ++i)\n#define EACH(i,c) for(auto i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#define deb(x) cerr << #x << \" = \" << (x) << \" , \";\n#define debl cerr << \" (L\" << __LINE__ << \")\"<< endl;\n#define sz(s) (int)((s).size())\n\n\n#define clr(a) memset((a),0,sizeof(a))\n#define nclr(a) memset((a),-1,sizeof(a))\n#define pb push_back\n#define INRANGE(x,s,e) ((s)<=(x) && (x)<(e))\n#define MP(x,y) make_pair((x),(y))\n\ndouble pi=3.14159265358979323846;\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T> std::ostream& operator<<(std::ostream& os, const vector<T>& z){\n\tos << \"[ \";\n\tREP(i,z.size())os << z[i] << \", \" ;\n\treturn ( os << \"]\" << endl);\n}\n\ntemplate<typename T> std::ostream& operator<<(std::ostream& os, const set<T>& z){\n\tos << \"set( \";\n\tEACH(p,z)os << (*p) << \", \" ;\n\treturn ( os << \")\" << endl);\n}\n\ntemplate<typename T,typename U> std::ostream& operator<<(std::ostream& os, const map<T,U>& z){\n\tos << \"{ \";\n\tEACH(p,z)os << (p->first) << \": \" << (p->second) << \", \" ;\n\treturn ( os << \"}\" << endl);\n}\n\ntemplate<typename T,typename U> std::ostream& operator<<(std::ostream& os, const pair<T,U>& z){\n\treturn ( os << \"(\" << z.first << \", \" << z.second << \",)\" );\n}\n\ndouble get_time(){\n\tstruct timeval tv;\n\tgettimeofday(&tv, NULL);\n\treturn tv.tv_sec + tv.tv_usec*1e-6;\n}\n\ntypedef unsigned int uint32_t;\nstruct RND{\n\tuint32_t x;\n\tuint32_t y;\n\tuint32_t z;\n\tuint32_t w;\n\tRND(){\n\t\tx=123456789;\n\t\ty=362436069;\n\t\tz=521288629;\n\t\tw=88675123;\n\t}\n\tvoid init(int seed){\n\t\tx=123456789;\n\t\ty=362436069;\n\t\tz=521288629;\n\t\tw=seed+100;\n\t\tREP(i,10)get();\n\t}\n\tuint32_t get(){\n\t\tuint32_t t;\n\t\tt=x^(x<<11);\n\t\tx=y;y=z;z=w;\n\t\tw=(w^(w>>19))^(t^(t>>8));\n\t\treturn w;\n\t}\n};\nRND rnd;\n\nll mod=1000000007;\nstruct mint{\n\tll value;\n\tmint():value(0){}\n\tmint(ll v):value((v%mod+mod)%mod){}\n};\nmint& operator+=(mint&a, mint b){return a=a.value+b.value;}\nmint& operator-=(mint&a, mint b){return a=a.value-b.value;}\nmint& operator*=(mint&a, mint b){return a=a.value*b.value;}\nmint operator+(mint a, mint b){return a+=b;}\nmint operator-(mint a, mint b){return a-=b;}\nmint operator*(mint a, mint b){return a*=b;}\nmint operator-(mint a){return 0-a;}\nbool operator==(mint a, mint b){return a.value==b.value;}\nbool operator!=(mint a, mint b){return a.value!=b.value;}\n\n\nstd::ostream& operator<<(std::ostream& os, const mint& m){\nreturn ( os << m.value );}\nll extgcd(ll a, ll b, ll &x, ll &y){\n\tll d=a;\n\tif(b!=0){\n\t\td=extgcd(b, a%b, y, x);\n\t\ty-=(a/b)*x;\n\t}\n\telse{\n\t\tx=1,y=0;\n\t}\n\treturn d;\n}\nll modinverse(ll a, ll b){\n\tll x,y;\n\tll d=extgcd(a,b, x, y);\n\tassert(d==1);\n\treturn (x%b+b)%b;\n}\nmint& operator/=(mint&a, mint b){return a=a.value*modinverse(b.value,mod);}\nmint operator/(mint a, mint b){return a/=b;}\n\nvector<mint> f;\nvector<mint> pf;\nmint X = 1000000007;\n\nvoid _main(istream &inp){\n\tint N;\n\tstring S;\n\tinp >> N >> S;\n\tf = vector<mint>(N+1);\n\tpf = vector<mint>(N+1);\n\tmint val = 0;\n\tmint u=1;\n\tf[0]=val;\n\tpf[0] = u;\n\trep(i,N){\n\t\tif(S[i]=='+')val += u;\n\t\tif(S[i]=='-')val -= u;\n\t\tif(S[i]=='>') u*=X;\n\t\tif(S[i]=='<')u/=X;\n\t\tf[i+1] = val;\n\t\tpf[i+1] = u;\n\t}\n//\tdebug(f);\n//\tdebug(pf);\n\tmap<ll,ll> cnt;\n\tll ret = 0;\n\tfor(int i=N;i>=0; i-- ){\n\t\tll tv = ( f[i] + pf[i]*f[N] ).value;\n\t\tif(exist(cnt, tv)){\n\t\t\tret += cnt[tv];\n\t\t}\n\t\tcnt[f[i].value]+=1;\n\t}\n\tcout << ret << endl;\n}\n\nint main(){\n\tif(0){\n\t\tifstream ifs(\"test.txt\");\n\t\t_main(ifs);\n\t}\n\telse{\n\t\t_main(cin);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<iostream>\n#define LL long long\n#define MP make_pair\nusing namespace std;\nconst LL mod=1e9+7;\nLL base[4],pre[4][500010],inv[4];\nstruct node{LL a,b;}op[4][250010];\nmap<pair<pair<LL,LL>,pair<LL,LL> >,LL> mp;\nLL pow(LL a,LL b)\n{\n\tLL ans=1;\n\twhile(b)\n\t{\n\t\tif(b&1) ans=ans*a%mod;\n\t\ta=a*a%mod;b>>=1;\n\t}\n\treturn ans;\n}\nLL n,p=0,t[500010],c[4],a[4][250010],b[4][250010];\nchar s[250010];\nvoid Pre()\n{\n\tfor(int k=0;k<4;k++)\n\t{\n\t\tLL cnt=1;op[k][n+1].a=1;\n\t\tfor(LL i=n;i>=1;i--)\n\t\t{\n\t\t\top[k][i]=op[k][i+1];\n\t\t\tif(s[i]=='<') cnt=cnt*base[k]%mod,(op[k][i].a*=base[k])%=mod;\n\t\t\tif(s[i]=='>') cnt=cnt*inv[k]%mod,(op[k][i].a*=inv[k])%=mod;\n\t\t\tif(s[i]=='-') (op[k][i].b+=cnt*pre[k][n]%mod)%=mod;\n\t\t\tif(s[i]=='+') op[k][i].b=((op[k][i].b-cnt*pre[k][n]%mod)%mod+mod)%mod;\n\t\t}\n\t}\n}\nvoid solve(LL *a,LL c,LL k) {for(LL i=1;i<=n;i++) a[i]=(c*op[k][i].a%mod+op[k][i].b)%mod;}\nint main()\n{\n\tbase[0]=690163;base[1]=92083;base[2]=12255871;base[3]=998244353;\n\tfor(int i=0;i<4;i++) inv[i]=pow(base[i],mod-2);\n\tscanf(\"%lld\",&n);getchar();\n\tscanf(\"%s\",s+1);\n\tfor(LL k=0;k<4;k++)\n\t{\n\t\tpre[k][0]=1;for(LL i=1;i<=2*n;i++) pre[k][i]=pre[k][i-1]*base[k]%mod;\n\t}\n\tfor(LL i=1;i<=n;i++)\n\t{\n\t\tif(s[i]=='<') p--;if(s[i]=='>') p++;\n\t\tif(s[i]=='-') t[p+n]--;if(s[i]=='+') t[p+n]++;\n\t}\n\tfor(int k=0;k<4;k++)\n\t\tfor(LL i=-n;i<=n;i++) (c[k]+=pre[k][i+n]*t[i+n]%mod)%=mod;\n\tPre();\n\tfor(int i=0;i<4;i++) solve(a[i],0,i);\n\tfor(int i=0;i<4;i++) solve(b[i],c[i],i);\n\tLL ans=0;\n\t//printf(\"c:%lld\\n\",c);\n\t//for(int i=1;i<=n;i++) printf(\"op:%lld %lld\\n\",op[i].a,op[i].b);\n\t//for(LL i=-n;i<=n;i++) printf(\"%lld:%lld %lld\\n\",i,t[i+n],pre[i+n]);printf(\"\\n\");\n\t//printf(\"a:\");for(int i=1;i<=n;i++) printf(\"%lld \",a[i]);printf(\"\\n\");\n\t//printf(\"b:\");for(int i=1;i<=n;i++) printf(\"%lld \",b[i]);printf(\"\\n\");\n\t//mp[c]++;\n\tfor(LL i=2;i<=n+1;i++)\n\t{\n\t\tmp[MP(MP(b[0][i-1],b[1][i-1]),MP(b[2][i-1],b[3][i-1]))]++;\n\t\tans+=mp[MP(MP(a[0][i],a[1][i]),MP(a[2][i],a[3][i]))];\n\t}\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing ll = long long;\nconstexpr ll pow(const ll a, const ll b, const ll mod) { return b == 0 ? 1LL : b % 2 == 1 ? pow(a, b - 1, mod) * a % mod : pow(a * a % mod, b / 2, mod); }\nconstexpr ll inverse(const ll a, const ll mod) { return pow(a, mod - 2, mod); }\nconstexpr ll MOD0 = 1000000007LL, MOD1 = 1000000009LL, MOD2 = 1000000021;\nconstexpr ll X = 121234243;\nconstexpr ll XINV0 = inverse(X, MOD0), XINV1 = inverse(X, MOD1), XINV2 = inverse(X, MOD2);\nint main()\n{\n    int N;\n    std::string S;\n    std::cin >> N >> S;\n    using P = std::tuple<ll, ll, ll>;\n    std::vector<int> deg(N + 1, 0);\n    std::vector<P> value(N + 1, P{0, 0, 0});\n    auto plus = [](const P& p1, const P& p2) { return P{(std::get<0>(p1) + std::get<0>(p2)) % MOD0, (std::get<1>(p1) + std::get<1>(p2)) % MOD1, (std::get<2>(p1) + std::get<2>(p2)) % MOD2}; };\n    auto minus = [](const P& p1, const P& p2) { return P{(std::get<0>(p1) + MOD0 - std::get<0>(p2)) % MOD0, (std::get<1>(p1) + MOD1 - std::get<1>(p2)) % MOD1, (std::get<2>(p1) + MOD2 - std::get<2>(p2)) % MOD2}; };\n    auto rshift = [](const P& p) { return P{std::get<0>(p) * X % MOD0, std::get<1>(p) * X % MOD1, std::get<2>(p) * X % MOD2}; };\n    auto lshift = [](const P& p) { return P{std::get<0>(p) * XINV0 % MOD0, std::get<1>(p) * XINV1 % MOD1, std::get<2>(p) * XINV2 % MOD2}; };\n    auto mul = [](const P& p1, const P& p2) { return P{std::get<0>(p1) * std::get<0>(p2) % MOD0, std::get<1>(p1) * std::get<1>(p2) % MOD1, std::get<2>(p1) * std::get<2>(p2) % MOD2}; };\n    for (int i = N - 1; i >= 0; i--) {\n        if (S[i] == '-') {\n            deg[i] = deg[i + 1], value[i] = minus(value[i + 1], P{1, 1, 1});\n        } else if (S[i] == '+') {\n            deg[i] = deg[i + 1], value[i] = plus(value[i + 1], P{1, 1, 1});\n        } else if (S[i] == '>') {\n            deg[i] = deg[i + 1] + 1, value[i] = rshift(value[i + 1]);\n        } else {\n            deg[i] = deg[i + 1] - 1, value[i] = lshift(value[i + 1]);\n        }\n    }\n    constexpr int L = 250000;\n    std::vector<P> power(L + 1, P{1, 1, 1});\n    std::vector<P> invpower(L + 1, P{1, 1, 1});\n    auto invp = [&](const int i) { return i >= 0 ? invpower[i] : power[-i]; };\n    for (int i = 1; i <= L; i++) { power[i] = rshift(power[i - 1]), invpower[i] = lshift(invpower[i - 1]); }\n    const P answer = value[0];\n    for (int i = 0; i <= N; i++) { value[i] = mul(minus(value[i], answer), invp(deg[i])); }\n    std::map<P, ll> mp;\n    ll ans = 0;\n    for (int i = 0; i <= N; i++) {\n        const P obj = plus(value[i], mul(invp(deg[i]), answer));\n        if (mp.find(obj) != mp.end()) { ans += mp[obj]; }\n        mp[value[i]]++;\n    }\n    std::cout << ans << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long lint;\n\nint modpow(int x, int y, int mod) {\n  int ret = 1 % mod, x2p = x;\n  while (y > 0) {\n    if (y % 2) ret = (lint)ret * x2p % mod;\n    y /= 2;\n    x2p = (lint)x2p * x2p % mod;\n  }\n  return ret;\n}\n\nconst int mod = 1008176417, base = 549817;\nconst int inv_base = modpow(base, mod - 2, mod);\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  string seq(n, ' ');\n  for (int i = 0; i < n; ++i)\n    scanf(\" %c\", &seq[i]);\n\n  vector<int> base_pow(n + 1);\n  base_pow[0] = 1;\n  for (int i = 1; i <= n; ++i)\n    base_pow[i] = (lint)base * base_pow[i - 1] % mod;\n\n  vector<int> inv_base_pow(n + 1);\n  inv_base_pow[0] = 1;\n  for (int i = 1; i <= n; ++i)\n    inv_base_pow[i] = (lint)inv_base * inv_base_pow[i - 1] % mod;\n\n  vector<int> hash_diff(n, 0);\n  vector<int> pos_before(n);\n  int pos = 0;\n  for (int i = 0; i < n; ++i) {\n    pos_before[i] = pos;\n    if (seq[i] == '>') ++pos;\n    else if (seq[i] == '<') --pos;\n    else {\n      int base_pow_pos;\n      if (pos >= 0) base_pow_pos = base_pow[pos];\n      else base_pow_pos = inv_base_pow[-pos];\n      if (seq[i] == '+') hash_diff[i] = base_pow_pos;\n      else if (seq[i] == '-') hash_diff[i] = mod - base_pow_pos;\n      else assert(0);\n    }\n  }\n  int full_seq_hash = 0;\n  for (int i = 0; i < n; ++i) {\n    full_seq_hash += hash_diff[i];\n    if (full_seq_hash >= mod) full_seq_hash -= mod;\n  }\n\n  vector<int> suffix(n + 1);\n  suffix[n] = 0;\n  for (int i = n - 1; i >= 0; --i) {\n    suffix[i] = hash_diff[i] + suffix[i + 1];\n    if (suffix[i] >= mod) suffix[i] -= mod;\n  }\n\n  lint result = 0;\n  map<int, int> count;\n  count[suffix[n]] += 1;\n  for (int i = n - 1; i >= 0; --i) {\n    int shifted_full;\n    if (pos_before[i] >= 0)\n      shifted_full = (lint)full_seq_hash * base_pow[pos_before[i]] % mod;\n    else\n      shifted_full = (lint)full_seq_hash * inv_base_pow[-pos_before[i]] % mod;\n\n    int target = suffix[i] - shifted_full;\n    if (target < 0) target += mod;\n\n    auto it = count.find(target);\n    if (it != count.end())\n      result += it->second;\n\n    count[suffix[i]] += 1;\n  }\n  printf(\"%lld\\n\", result);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <map>\n#include <list>\n#include <iterator>\n#include <set>\n#include <queue>\n#include <iostream>\n#include <sstream>\n#include <stack>\n#include <deque>\n#include <cmath>\n#include <memory.h>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <algorithm>\n#include <utility>\n#include <time.h>\n#include <bitset>\n#include <assert.h>\n#include <complex.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(int i=(a)-1;i>=(b);--i)\n#define FILL(A,val) memset(A,val,sizeof(A))\n\n#define ALL(V) V.begin(),V.end()\n#define SZ(V) (int)V.size()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long Int;\ntypedef unsigned long long UInt;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double Pi = acos(-1.0);\nconst int INF = 1000000000;\nconst Int INF2 = Int(INF) * 5000;\nconst Int INF3 = Int(INF) * INF;\nconst int MAX = 510007;\nconst int MAXE = 2007000;\nconst int MAXV = 5000;\nconst int BASE = 1000000000;\nconst int ST = 1000000007;\n\nconst int MOD = 1000000007;\n\nint p = 1000003;\n\nInt H[MAX];\nint delta[MAX];\n\n\nInt pw[MAX];\n\nint main()\n{\n    //freopen(\"in.txt\", \"r\", stdin);\n    \n    pw[0] = 1;\n    FOR(i,1,MAX)\n    {\n        pw[i] = pw[i - 1] * p;\n    }\n    \n    int n;\n    cin >> n;\n    string s;\n    cin >> s;\n    \n    H[0] = 0;\n    delta[0] = n + 1;\n    \n    FOR(i,0,n)\n    {\n        H[i + 1] = H[i];\n        delta[i + 1] += delta[i];\n        \n        if (s[i] == '<')\n        {\n            delta[i + 1] --;\n        }\n        if (s[i] == '>')\n        {\n            delta[i + 1] ++;\n        }\n        \n        if (s[i] == '+')\n        {\n            H[i + 1] += pw[delta[i + 1]];\n        }\n        \n        if (s[i] == '-')\n        {\n            H[i + 1] -= pw[delta[i + 1]];\n        }\n        \n    }\n    \n    int res = 0;\n    \n    map<Int, int> M;\n   \n    \n    \n    \n    RFOR(i,n,0)\n    {\n        M[H[i + 1] * pw[n]] ++;\n        Int h = H[n] * pw[delta[i] - delta[0] + n] + H[i] * pw[n];\n        \n        res += M[h];\n    }\n    \n    cout << res << endl;\n    \n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "/**\n * File    : F.cpp\n * Author  : Kazune Takahashi\n * Created : 2018-7-2 20:45:55\n * Powered by Visual Studio Code\n */\n\n#include <iostream>\n#include <iomanip>   // << fixed << setprecision(xxx)\n#include <algorithm> // do { } while ( next_permutation(A, A+xxx) ) ;\n#include <vector>\n#include <string> // to_string(nnn) // substr(m, n) // stoi(nnn)\n#include <complex>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <map> // if (M.find(key) != M.end()) { }\n#include <set>\n#include <random> // random_device rd; mt19937 mt(rd());\n#include <chrono> // std::chrono::system_clock::time_point start_time, end_time;\n// start = std::chrono::system_clock::now();\n// double elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(end_time-start_time).count();\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\n#define DEBUG 0 // change 0 -> 1 if we need debug.\n\ntypedef long long ll;\n\n// const int dx[4] = {1, 0, -1, 0};\n// const int dy[4] = {0, 1, 0, -1};\n\n// const int C = 1e6+10;\nconst ll MOD = 1000000007;\nconst ll M = 250010;\nrandom_device rd;\nmt19937 mt(rd());\ntypedef tuple<ll, ll> D;\n\nint N;\nstring S;\nmap<ll, int> ans;\nll X;\nll X_inv;\nll C;\nll a[500100];\nD g[250010];\nmap<ll, ll> G;\n\nll power2(int i)\n{\n  if (i == 0)\n  {\n    return 1;\n  }\n  else if (i % 2 == 0)\n  {\n    ll half = power2(i / 2);\n    return (half * half) % MOD;\n  }\n  else\n  {\n    return (power2(i - 1) * X) % MOD;\n  }\n}\n\nll power(int i)\n{\n  if (i == 0)\n  {\n    return 1;\n  }\n  else if (i < 0)\n  {\n    return power2(MOD + i - 1);\n  }\n  return power2(i);\n}\n\nll calc_hash()\n{\n  fill(a, a + 500100, 0);\n  int P = M;\n  for (auto e : S)\n  {\n    if (e == '+')\n    {\n      a[P]++;\n    }\n    else if (e == '-')\n    {\n      a[P]--;\n    }\n    else if (e == '>')\n    {\n      P++;\n    }\n    else\n    {\n      P--;\n    }\n  }\n  ll res = 0;\n  for (auto i = 0; i < 500100; i++)\n  {\n    res += (((MOD + a[i]) % MOD) * power(i - M)) % MOD;\n    res %= MOD;\n  }\n  return res;\n}\n\nvoid calc_g()\n{\n  g[N] = D(1, 0);\n  for (auto i = N - 1; i >= 0; i--)\n  {\n    ll A_prime = get<0>(g[i + 1]);\n    ll B_prime = get<1>(g[i + 1]);\n    ll A, B;\n    if (S[i] == '+')\n    {\n      A = 1, B = MOD - 1;\n    }\n    else if (S[i] == '-')\n    {\n      A = 1, B = 1;\n    }\n    else if (S[i] == '>')\n    {\n      A = X_inv, B = 0;\n    }\n    else\n    {\n      A = X, B = 0;\n    }\n    g[i] = D((A_prime * A) % MOD,\n             ((A_prime * B) % MOD + B_prime) % MOD);\n  }\n}\n\nll count_ans()\n{\n  ll res = 0;\n  G.clear();\n  for (int i = N; i >= 1; i--)\n  {\n    ll J = get<1>(g[i]);\n    if (G.find(J) == G.end())\n    {\n      G[J] = 1;\n    }\n    else\n    {\n      G[J]++;\n    }\n    ll I = ((get<0>(g[i - 1]) * C) % MOD + get<1>(g[i - 1])) % MOD;\n\n    if (G.find(I) != G.end())\n    {\n      // cerr << \"i = \" << i - 1 << \", cnt of j = \" << G[I] << endl;\n      res += G[I];\n    }\n  }\n  return res;\n}\n\nvoid solve()\n{\n  X = abs((ll)mt());\n  X_inv = power(-1);\n  C = calc_hash();\n  calc_g();\n  ll res = count_ans();\n  if (ans.find(res) == ans.end())\n  {\n    ans[res] = 1;\n  }\n  else\n  {\n    ans[res]++;\n  }\n}\n\nint main()\n{\n  cin >> N >> S;\n  for (auto i = 0; i < 6; i++)\n  {\n    solve();\n  }\n  ll res = 0;\n  int maxi = 0;\n  for (auto e : ans)\n  {\n    ll a = e.first;\n    int cnt = e.second;\n    if (cnt > maxi)\n    {\n      cnt = maxi;\n      res = a;\n    }\n  }\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\n#define fr first\n#define sc second\n\nconst ll MOD[2] = {1000000007,1000000009};\n\nll modpow(ll x,ll k,int t){\n\tif(k==0)return 1;\n\tll ret=modpow(x,k/2,t);\n\tret*=ret; ret%=MOD[t];\n\tif(k%2==1){\n\t\tret*=x; ret%=MOD[t];\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint n;\n\tstring s;\n\tcin>>n>>s;\n\t\n\tsrand((unsigned)time(NULL));\n\tll r[2]={rand()+n,rand()+n};\n\t\n\tP hash[250010],h=P(0,0);\n\tll loc[250010],p=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(s[i]=='+'){\n\t\t\th.fr+=modpow(r[0],p,0);\n\t\t\tif(h.fr>=MOD[0])h.fr-=MOD[0];\n\t\t\th.sc+=modpow(r[1],p,1);\n\t\t\tif(h.sc>=MOD[1])h.sc-=MOD[1];\n\t\t}\n\t\telse if(s[i]=='-'){\n\t\t\th.fr+=MOD[0]-modpow(r[0],p,0);\n\t\t\tif(h.fr>=MOD[0])h.fr-=MOD[0];\n\t\t\th.sc+=MOD[1]-modpow(r[1],p,1);\n\t\t\tif(h.sc>=MOD[1])h.sc-=MOD[1];\n\t\t}\n\t\telse if(s[i]=='>'){\n\t\t\tp++;\n\t\t}\n\t\telse {\n\t\t\tp--;\n\t\t}\n\t\thash[i]=h;\n\t\tloc[i]=p;\n\t}\n\t\n\tll ret=0;\n\tmap<P,ll> cnt;\n\tfor(int i=n-1;i>=0;i--){\n\t\tP nex=hash[i];\n\t\tP dif=hash[n-1];\n\t\tdif.fr*=modpow(r[0],loc[i]+MOD[0]-1,0); dif.fr%=MOD[0];\n\t\tdif.sc*=modpow(r[1],loc[i]+MOD[1]-1,1); dif.sc%=MOD[1];\n\t\tnex.fr+=dif.fr; nex.fr%=MOD[0];\n\t\tnex.sc+=dif.sc; nex.sc%=MOD[1];\n\t\tret+=cnt[nex];\n\t\tcnt[hash[i]]++;\n\t}\n\tcout<<ret+cnt[hash[n-1]]<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long lint;\n\nlint modpow(lint x, lint y, lint mod) {\n  lint ret = 1 % mod, x2p = x;\n  while (y > 0) {\n    if (y % 2) ret = (__int128)ret * x2p % mod;\n    y /= 2;\n    x2p = (__int128)x2p * x2p % mod;\n  }\n  return ret;\n}\n\nconst lint mod = 4511686018432017251LL, base = 549817;\nconst lint inv_base = modpow(base, mod - 2, mod);\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  string seq(n, ' ');\n  for (int i = 0; i < n; ++i)\n    scanf(\" %c\", &seq[i]);\n\n  vector<lint> base_pow(n + 1);\n  base_pow[0] = 1;\n  for (int i = 1; i <= n; ++i)\n    base_pow[i] = (__int128)base * base_pow[i - 1] % mod;\n\n  vector<lint> inv_base_pow(n + 1);\n  inv_base_pow[0] = 1;\n  for (int i = 1; i <= n; ++i)\n    inv_base_pow[i] = (__int128)inv_base * inv_base_pow[i - 1] % mod;\n\n  vector<lint> hash_diff(n, 0);\n  vector<int> pos_before(n);\n  int pos = 0;\n  for (int i = 0; i < n; ++i) {\n    pos_before[i] = pos;\n    if (seq[i] == '>') ++pos;\n    else if (seq[i] == '<') --pos;\n    else {\n      lint base_pow_pos;\n      if (pos >= 0) base_pow_pos = base_pow[pos];\n      else base_pow_pos = inv_base_pow[-pos];\n      if (seq[i] == '+') hash_diff[i] = base_pow_pos;\n      else if (seq[i] == '-') hash_diff[i] = mod - base_pow_pos;\n      else assert(0);\n    }\n  }\n  lint full_seq_hash = 0;\n  for (int i = 0; i < n; ++i) {\n    full_seq_hash += hash_diff[i];\n    if (full_seq_hash >= mod) full_seq_hash -= mod;\n  }\n\n  vector<lint> suffix(n + 1);\n  suffix[n] = 0;\n  for (int i = n - 1; i >= 0; --i) {\n    suffix[i] = hash_diff[i] + suffix[i + 1];\n    if (suffix[i] >= mod) suffix[i] -= mod;\n  }\n\n  lint result = 0;\n  map<lint, int> count;\n  count[suffix[n]] += 1;\n  for (int i = n - 1; i >= 0; --i) {\n    lint shifted_full;\n    if (pos_before[i] >= 0)\n      shifted_full = (__int128)full_seq_hash * base_pow[pos_before[i]] % mod;\n    else\n      shifted_full = (__int128)full_seq_hash * inv_base_pow[-pos_before[i]] % mod;\n\n    lint target = suffix[i] - shifted_full;\n    if (target < 0) target += mod;\n\n    auto it = count.find(target);\n    if (it != count.end())\n      result += it->second;\n\n    count[suffix[i]] += 1;\n  }\n  printf(\"%lld\\n\", result);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof x)\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outtag(x) cerr<<\"-----------------\"#x\"-----------------\\n\"\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n                    For(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair <int,int> pii;\nLL read(){\n    LL x=0,f=0;\n    char ch=getchar();\n    while (!isdigit(ch))\n        f=ch=='-',ch=getchar();\n    while (isdigit(ch))\n        x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n    return f?-x:x;\n}\nconst int N=250005,mod=998244353;\nint Pow(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=(LL)x*x%mod)\n\t\tif (y&1)\n\t\t\tans=(LL)ans*x%mod;\n\treturn ans;\n}\nvoid Add(int &x,int y){\n\tif ((x+=y)>=mod)\n\t\tx-=mod;\n}\nvoid Del(int &x,int y){\n\tif ((x-=y)<0)\n\t\tx+=mod;\n}\nint Add(int x){\n\treturn x>=mod?x-mod:x;\n}\nint Del(int x){\n\treturn x<0?x+mod:x;\n}\nconst int k=10;\nvector <int> bas(k),ibas(k);\nvoid prework(){\n\tsrand(1233);\n\tFor(i,0,k-1){\n\t\tbas[i]=rand()%10000+1;\n\t\tibas[i]=Pow(bas[i],mod-2);\n\t}\n}\nstruct cmp{\n\tbool operator () (vector <int> a,vector <int> b){\n\t\tassert((int)a.size()==k&&(int)b.size()==k);\n\t\tFor(i,0,k-1)\n\t\t\tif (a[i]!=b[i])\n\t\t\t\treturn a[i]<b[i];\n\t\treturn 0;\n\t}\n};\nmap <vector <int>,int,cmp> cnt;\nvoid Add(pair <int,int> &a,int b){\n\tAdd(a.se,(LL)b*a.fi%mod);\n}\nvoid Del(pair <int,int> &a,int b){\n\tDel(a.se,(LL)b*a.fi%mod);\n}\nvoid Mul(int &a,int b){\n\ta=(LL)a*b%mod;\n}\nvoid Mul(pair <int,int> &a,int b){\n\tMul(a.fi,b);\n}\ntemplate <typename T> vector <T> trans(vector <T> x,int op){\n\tvector <T> a=x;\n\tif (op==1||op==-2)\n\t\tFor(i,0,k-1)\n\t\t\tAdd(a[i],1);\n\telse if (op==2||op==-1)\n\t\tFor(i,0,k-1)\n\t\t\tDel(a[i],1);\n\telse if (op==3||op==-4)\n\t\tFor(i,0,k-1)\n\t\t\tMul(a[i],bas[i]);\n\telse if (op==4||op==-3)\n\t\tFor(i,0,k-1)\n\t\t\tMul(a[i],ibas[i]);\n\treturn a;\n}\nint n;\nchar s[N];\nmap <char,int> op;\nvector <int> all(k,0),zero(k,0);\nvector <pair <int,int> > a(k,mp(1,0)),b(k,mp(1,0));\nvector <int> Calc(vector <pair <int,int> > a,vector <int> x){\n\tvector <int> b(k);\n\tFor(i,0,k-1)\n\t\tb[i]=((LL)a[i].fi*x[i]+a[i].se)%mod;\n\treturn b;\n}\nint main(){\n\tprework();\n\top['+']=1,op['-']=2,op['>']=3,op['<']=4;\n\tn=read();\n\tcin>>(s+1);\n\tFod(i,n,1)\n\t\tall=trans(all,op[s[i]]);\n\tLL ans=0;\n\tcnt[Calc(a,zero)]++;\n\tFod(i,n,1){\n\t\ta=trans(a,-op[s[i]]);\n\t\tb=trans(b,-op[s[i]]);\n\t\tans+=cnt[Calc(b,all)];\n\t\tcnt[Calc(a,zero)]++;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << (x) << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\ntemplate<unsigned int mod_>\nstruct ModInt{\n\tusing uint = unsigned int;\n\tusing ll = long long;\n\tusing ull = unsigned long long;\n\n\tconstexpr static uint mod = mod_;\n\n\tuint v;\n\tModInt():v(0){}\n\tModInt(ll v):v(normS(v%mod+mod)){}\n\texplicit operator bool() const {return v!=0;}\n\tstatic uint normS(const uint &x){return (x<mod)?x:x-mod;}\t\t// [0 , 2*mod-1] -> [0 , mod-1]\n\tstatic ModInt make(const uint &x){ModInt m; m.v=x; return m;}\n\tModInt operator+(const ModInt& b) const { return make(normS(v+b.v));}\n\tModInt operator-(const ModInt& b) const { return make(normS(v+mod-b.v));}\n\tModInt operator-() const { return make(normS(mod-v)); }\n\tModInt operator*(const ModInt& b) const { return make((ull)v*b.v%mod);}\n\tModInt operator/(const ModInt& b) const { return *this*b.inv();}\n\tModInt& operator+=(const ModInt& b){ return *this=*this+b;}\n\tModInt& operator-=(const ModInt& b){ return *this=*this-b;}\n\tModInt& operator*=(const ModInt& b){ return *this=*this*b;}\n\tModInt& operator/=(const ModInt& b){ return *this=*this/b;}\n\tll extgcd(ll a,ll b,ll &x,ll &y) const{\n\t\tll u[]={a,1,0},v[]={b,0,1};\n\t\twhile(*v){\n\t\t\tll t=*u/ *v;\n\t\t\trep(i,3) swap(u[i]-=t*v[i],v[i]);\n\t\t}\n\t\tif(u[0]<0) rep(i,3) u[i]=-u[i];\n\t\tx=u[1],y=u[2];\n\t\treturn u[0];\n\t}\n\tModInt inv() const{\n\t\tll x,y;\n\t\textgcd(v,mod,x,y);\n\t\treturn make(normS(x+mod));\n\t}\n\tbool operator==(const ModInt& b) const { return v==b.v;}\n\tbool operator!=(const ModInt& b) const { return v!=b.v;}\n\tfriend istream& operator>>(istream &o,ModInt& x){\n\t\tll tmp;\n\t\to>>tmp;\n\t\tx=ModInt(tmp);\n\t\treturn o;\n\t}\n\tfriend ostream& operator<<(ostream &o,const ModInt& x){ return o<<x.v;}\n};\nusing mint = ModInt<1000000007>;\nconst mint B = 998244353;\nmint ex(int p){\n\tbool m = 0;\n\tif(p<0){\n\t\tp = -p;\n\t\tm = 1;\n\t}\n\tmint a = 1;\n\tmint x = B;\n\twhile(p){\n\t\tif(p%2==1) a *= x;\n\t\tx *= x;\n\t\tp/=2;\n\t}\n\tif(m) a = (mint)1/a;\n\treturn a;\n}\n\nusing ll = long long;\nint N;\nstring s;\n\nint main(){\n\tcin>>N>>s;\n\tmint H = 0;\n\t{\n\t\tmap<int,int> cnt;\n\t\tint x = 0;\n\t\trep(i,N){\n\t\t\tif(s[i]=='+') cnt[x]++;\n\t\t\tif(s[i]=='-') cnt[x]--;\n\t\t\tif(s[i]=='<') x--;\n\t\t\tif(s[i]=='>') x++;\n\t\t}\n\t\tusing P = pair<int,int>;\n\t\tfor(P p:cnt){\n\t\t\tint x = p.fs, v = p.sc;\n\t\t\tH += ex(x) * v;\n\t\t}\n\t}\n\tmint a = 1, b = 0;\n\tll ans = 0;\n\t\n\tmap<int,int> mp;\n\tmp[0] = 1;\n\tfor(int i=N-1;i>=0;i--){\n\t\tmint na,nb;\n\t\tif(s[i]=='+'){\n\t\t\tna = a, nb = b+1;\n\t\t}\n\t\tif(s[i]=='-'){\n\t\t\tna = a, nb = b-1;\n\t\t}\n\t\tif(s[i]=='<'){\n\t\t\tna = a/B, nb = b/B;\n\t\t}\n\t\tif(s[i]=='>'){\n\t\t\tna = a*B, nb = b*B;\n\t\t}\n\t\ta = na, b = nb;\n\t\tmint H_false = (H-b)/a;\n\t\tans += mp[H_false.v];\n\t\tmp[(-b/a).v]++;\n\t}\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <functional>\n#define fs first\n#define se second\n\nusing namespace std;\ntypedef long long llong;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<llong, llong> pll;\ntypedef pair<ld, ld> pdd;\n\nconst int mod = 1e9 + 7, p1 = 17, p2 = 998244353;\n\nint pw(int x, int p) {\n    int r = 1;\n    while (p) {\n        if (p & 1) r = (llong)r * x % mod;\n        x = (llong)x * x % mod;\n        p >>= 1;\n    }\n    return r;\n}\n\nint n;\nchar in[250002];\npii S[250001];\nint P[250001];\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> n >> in + 1;\n    for (int i = 1; i <= n; ++i) {\n        if (in[i] == '+') {\n            P[i] = P[i - 1];\n            S[i].fs = (S[i - 1].fs + pw(p1, P[i])) % mod;\n            S[i].se = (S[i - 1].se + pw(p2, P[i])) % mod;\n        }\n        else if (in[i] == '-') {\n            P[i] = P[i - 1];\n            S[i].fs = (S[i - 1].fs + mod - pw(p1, P[i])) % mod;\n            S[i].se = (S[i - 1].se + mod - pw(p2, P[i])) % mod;\n        }\n        else if (in[i] == '>') {\n            P[i] = (P[i - 1] + 1) % (mod - 1);\n            S[i] = S[i - 1];\n        }\n        else {\n            P[i] = (P[i - 1] + mod - 2) % (mod - 1);\n            S[i] = S[i - 1];\n        }\n    }\n    llong ans = 0;\n    map<pii, int> mp;\n    for (int i = 0; i <= n; ++i) {\n        ans += mp[S[i]];\n        pii v(((llong)pw(p1, P[i]) * S[n].fs + S[i].fs) % mod\n            , ((llong)pw(p2, P[i]) * S[n].se + S[i].se) % mod);\n        ++mp[v];\n    }\n    printf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                         `!!!;'                                                                 `\n                                                           '%$@########################&&%:.                                                    `\n                                                       .%###################################%.                                                  `\n                                                    .`|######################################%                                                  `\n                                                 .!@###############################################$'                                           `\n                                              .!@#########################@@@#########################&;.                                       `\n                                             :@##################@@@&&@@@$!!%&@@@@@@@###################&'                                      `\n                                          :&################@@@&$%%||||!!:'':;!!||%|!%&@@#################%`                                    `\n                                         |###############@@&&$%|!;;::::':'''':::;;!!|%%%$&&@###############$`                                   `\n                                      :&#############@&$%||||!;'````````````'''```'':::'':!|$@@###############;                                 `\n                                    :@#############@$$%|!;;;;:'``````...```...`...`'':::''';|%$$$&############&'                                `\n                                   |##############&$$$%||!!;:'`````..````....`...```''::::;!!||$&&@@###########&'                               `\n                                 !##############@$%|!!!;::'''`````...``.....`````````'''::::;;::!|%$&############|                              `\n                                :@##########@&%!:'`::;;:'``....```.......  .``....````````````'':;!|%$@############;                            `\n                               ;##########@%;```...`'''`...  .....    ................   .`.    `:!!!!%%%&#########|                            `\n                              ;##########&|:.`'`. ..`...   .......   .....  ..  .....   ...   .'':!!:.`''!@#########|.                          `\n                              !##########|'`.;!`       .  ......          ..    .      ....  .::'`. .. .`'|@########@:                          `\n                              ;##########%'`'%!    ..       .  .                ..    .```.   ';:`..``.`':|@########@:                          `\n                              !##########$:;$&;                     . `|%;.  `;||;::`.``';;.  .;!: `;:`';|$#########@!.                         `\n                              !##########@$&@|. ...... .`':!|;` !$|%%'!##$' `|####$:`:;:!&$:. '$&!';!!||%&############;                         `\n                             `$#############&:  `!!'`:;;;||%@&!'!&&$;.|##%`.|#####%`'$@$&##%` .:||;;;;%@##############!                         `\n                             :@#############|. .!&@|;%@@@@@&@@#@&@#@&@############@@#####@:   .`'%@%!!&###############!                         `\n                             :@############@;   :&@!;$###@|%|!$@@######################@%`    .;|!;!|%@###############!                         `\n                             :@############@:   `$#$%#@@##&@################@$$$&$%|!'       `%#@|;':|&###############!                         `\n                              !##########@$%:    |####@&######$;.                          ..`'`      ;@##############!                         `\n                              !##########!       ;#########|.                             `;`         ;###############!                         `\n                              ;##########;       `%######;                           '$###&:          `%@############&'                         `\n                               !########@:       .'.       .:;`                   .|%:                   !##########&'                          `\n                               !########@:                                                               ;#########@:                           `\n                                !######%.     !##&;.        .                  `%&!`             '&###&' !#########!                            `\n                                |#######;.%###!                 `!&###@|;;%@###%.    ';;|&$:;;`     |#%. .%###%$###!                            `\n                               !#######|  `%#&'    |##&$####&:     !##########;    `%#####%.!#|.   .%@:   ;###;`%##!                            `\n                                !#$!$##!   :@#!        .|###$'.    ;##|.  :&#@;    .``::`          ;@|.   :@#@: `$#|                            `\n                                :&&|&##;   :&#!                   :&##;    .%##!                   !&'    ;@##!  |#!                            `\n                                 |@@##@;  .`%#!                  '$##;      ;##$`                 :@!    .|##@; :&!                             `\n                                 !&|&##%:'.  :&!                :@#%.        .%##;               |&!.   `|@!   `$!                              `\n                                 '$%%###&;.   '&&'            `%##&'           |##@&:    ...;&&&@;     .;&#|':;$&:                              `\n                                 .|######&;        '$@@@@@@@@#|                                        :&######%`                               `\n                                   !#####&:                                                           '$#####@:                                 `\n                                   '$#####@:                                                          ;#####$`                                  `\n                                     '&####%.                 ``                                     '$#####;                                   `\n                                      !#####$'                |@:  .:%|;;;;!$#####@#|               '&###$:                                     `\n                                       :&####&:               ;####################@:    ':`       `%###@:                                      `\n                                         ;#####@%:.                                         `'';|@######$`                                      `\n                                         `$######@|`                                        !#&||@#####$`                                       `\n                                          :&######@%'.                        .`''''` .';!|%@#@$$@####&:                                        `\n                                           |######@|'.   ;##$!!%@##########################@:   '$####;                                         `\n                                           :&#####$;''.`%#########&'             `|@$:         .%###@;                                          `\n                                            :@####@;          |#@##&$;         `|%'           .|####!                                           `\n                                              !####@;                                .        |####!                                            `\n                                               :@###@|`         .                 `|!.       |####%.                                            `\n                                                .|####!          `;$@%|!!!!!%&&@#$;.        !#####|                                             `\n                                                .%####&:              '%&@@@|`             '&#####|                                             `\n                                                .%#####|.                                 :&######%`                                            `\n                                       :|||;`    !#######;                              .%#####@@#####@$;.                                      `\n                                   `$#############&%!%#####|.                         :@####%:..'!&######@;                                     `\n                                  `$#############|`..'%#######!                      ;####&;.    .'%#######!                                    `\n                                .|##############@!`    .'%#########%'.          '%#####%`           :@#######@%;:.                              `\n                          ;%|;. !############%::;'        `!&############@&&@#######@%'               !###########&'                            `\n                         !################$'   .:'         '|&######################$:.               :@#############@@@@@@;                    `\n                      ';$##&;:&###########$`                  :|$@################%:.                 !#####################@;                  `\n                   '%####@$!:.  `%#########!                    .:!%&@#######@%!;'.                   |##############%!$@####!                  `\n                .|#######&;'. .    |#######%.                      .':;!!!!!!;`...                   .|############|. :$@@####%.                `\n                !####&$&@#@!:'.       ;#####%`                  .`';;'... ..''``.                    !##########%`    ''':$######$`             `\n                ;#####@$$;`%&:.         `%####;                   .:;;:'':;||!:`                    !#########!          :&#@@####!             `\n          '%######@######!   !!            :$@$`                    ...`.'::`..                   '$######@!`         '|$$&!!@#######@!.        `\n     '$#########@&$$@######@:    ;: . `'    ....                      ...``.                    `$######&'           '!;`'!@######&&########$'  `\n  ;############@#@@@@@$|%@###$`  `!!.;' .     :!.                                             .%#####!.            .;::&####|`..`  ..;@########!'\n  |########&|;'``..`:'    ..!##%:.    ;;      `.                                            .|###|`             `'|###@&$|`  ..   .`|&&@#######%:\n  |###@#@@#&|:`.`';;:;!!!;:;''!$##&;'.  .'%; .;&###&|$!                                     '$; .|$:;|`   ...;&###$'    ....      :||%&########%:\n  |#######@$;!%%:```           .!@###&|`   :|'!########@#!                                ;@! :@####%'. `|@###&:         ..`:::%$$&$$$&@##@@@##|:\n  |########$;::'`         .`.     `%#####%!: .. !#####%` !#%.                        !; '%; !#############&:          `::`.```. .':.  :$@&&&###|:\n  !####@%:::;;:::::` .........            '.  !#######%;;';; `%#&'             ;&: `;``$@!%########&&##&|::::'.             ':.     `!%@@######|:\n  !#####%;;::.       ...... ....`..  ..  '::!|&########$';%`.'` .;%:        !#$';$%|&$!&##########$'        `';;;;!&##&%||||||%;`   .:|&###@###|:\n  |#######|`...      `|$&&$$!`....           ;$:  :&#@:     `'''``.   .%########&'  .%#@&$%$#####$`     ....`:%&@@@@@@&&@@!`.      .`'%@#######|'\n  |######@@$:       .`..`!@&$&&&&:                ;@#######@@#$%@######&$;    '%@##%!@###@&&@####%.     `!&@@@@@$:..`..``.``...     `|&####@@##!'\n  ;###&|;::!&#&%%%%:         .'::::;|$&&$%|'..;%%&#######%;$########@&#####%`   '|@###;    '%####$;::::::`            '!|%%%%%%%%%&#$:'::.'%###|'\n  `%###@|;|%$%$@#&|;::::`          '|%%%%%$%|%|;';$##@|'.   |######&'     .:|$%: :&@|'.     !####%.              `::;:!$@######&%%%%%!'  ':;&##|:\n  '$##%:.    :&##@####@$;.  ..                    `$|     :; !#####|      '|%:  ``    ...   !####!          .  ..:&#@@@@##@&||$;         :&####|'\n  !####&@@&;        ...`.'%@##@@#@@&!`            :&&!.       !###&'  :||:.`   !%'     ``:$######@@@&&@@@&@##$;``....             |@@@@########!'\n  !#######@$||!:          ';!;;;!&###&|||||||||||%&##@!`.     !###&||%!!!:   .:;`        `;;%####$;:;;;;;;;;;;;::.         '||||||&#####%!;;$##!`\n  `%#&:.`:!||||||%@#@%;::;;;'                     ;@@:    .. .%###|.   `:::'  .:!;'`':'`   `$####!             ':;;;;!%@@&%%%|;`        `;%&###|:\n  .%##|..       '$##@@@@@@#&:...`..              `$#$'        !##%`   ..`.`:%@@! '%@$:''. .`|####|... .........`:%###@#@@@|`        ....`%#####|:\n  !###@&!       .`.```':!&##@&&&&$:              '&#%.        !#&'     ````.    .```:%&&&&&@#####@!':|$&&$&&&&&&&&&@##|`````.       !@@@#######!'\n  :&#########@$||||:            `::::;;;;;!!;;;:;$###$'  .'`  |#@|.  .:;;:.                `%####%:''':::::`               `!||&##$;;;:::.  ;##|:\n  .%#@$%$%%%%%$@###$::::::'.           ...`;|!::!&##@$%|||!' .%##&%%$%'        `'.         :&####!                  .':::'::%@&$%%!` .!!':;$###%:\n  :&#############@|.              .  '$##################&;..!@###@#######%'.             .!#####!          .              `$#####@|``;&|!&####|:\n  |####&%'   .''''':|@###@$$$$$$%;.             |####%`      .|#@;.         .;$$$%$&$$$$$$&######$:..:|%$$$$$$$&&&&@######&;'''.    ;$&########|:\n  |#######@%;;`    '!|!||$#######&|!!!;;;!!!;`.!#####@: .;|!!|&#$'   `:'':;;$######################################%!|!!!!!;.  .`;|&######@####%:\n  |############$!''''..';$&&&&@########################$;'!;`:@#&:``'|$@######@@@@&&&&&&&@#######@&&&&&&&&&&&@@&&&&$|:.    .`''$########@&@####%:\n  |###&%$&#################@%;'  ..      `|@############$: `%@###########$`  `%%:.     . :@######|         !#####################@$%&##########%:\n  |#######################################@&&@######################@@&@#######################################################################%:\n*/\n\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <map>\n#include <set>\n#include <stack>\n#include <ctime>\n#include <cmath>\n#include <queue>\n#include <cstdio>\n#include <cctype>\n#include <vector>\n#include <bitset>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <fstream>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ninline char gc() {\n    static const int L = 233333;\n    static char sxd[L], *sss = sxd, *ttt = sxd;\n    if (sss == ttt) {\n        ttt = (sss = sxd) + fread(sxd, 1, L, stdin);\n        if (sss == ttt) {\n            return EOF;\n        }\n    }\n    return *sss++;\n}\n\n#ifndef _AT_HOME\n#define dd c = gc()\n#else\n#define dd c = getchar()\n#endif\ninline char readalpha() {\n    char dd;\n    for (; !isalpha(c); dd);\n    return c;\n}\n\ninline char readchar() {\n    char dd;\n    for (; c == ' '; dd);\n    return c;\n}\n\ntemplate <class T>\ninline bool read(T& x) {\n    bool flg = false;\n    char dd;\n    x = 0;\n    for (; !isdigit(c); dd) {\n        if (c == '-') {\n            flg = true;\n        } else if(c == EOF) {\n            return false;\n        }\n    }\n    for (; isdigit(c); dd) {\n        x = (x * 10) + (c ^ 48);\n    }\n    if (flg) {\n        x = -x;\n    }\n    return true;\n}\n#undef dd\n\ntemplate <class T>\ninline void write(T x) {\n    if (x < 0) {\n        putchar('-');\n        x = -x;\n    }\n    if (x < 10) {\n        putchar(x | 48);\n        return;\n    }\n    write(x / 10);\n    putchar((x % 10) | 48);\n}\n\ntemplate <class T>\ninline void writesp(T x) {\n    write(x);\n    putchar(' ');\n}\n\ntemplate <class T>\ninline void writeln(T x) {\n    write(x);\n    puts(\"\");\n}\n\n#define lowbit(x) (x & -x)\n\nnamespace dfcmd {\n\n    typedef long long LL;\n    typedef unsigned long long ULL;\n\n    const int maxn = 250005;\n    const ULL bse = 233;\n\n    int n;\n    char s[maxn];\n    map<ULL, int> mp;\n    ULL f[maxn], g[maxn];\n\n    int Main() {\n        scanf(\"%d%s\", &n, s + 1);\n        ULL inv = 1, xx = bse;\n        for (int i = 1; i <= 63; ++i) {\n            inv = inv * xx;\n            xx = xx * xx;\n        }\n        mp.clear();\n        // cout << bse << ' ' << inv << ' ' << bse * inv << endl;\n        f[0] = 0, g[0] = 1;\n        for (int i = 1; i <= n; ++i) {\n            f[i] = f[i - 1], g[i] = g[i - 1];\n            switch (s[i]) {\n                case '+':\n                    f[i] += g[i];\n                    break;\n                case '-':\n                    f[i] -= g[i];\n                    break;\n                case '<':\n                    g[i] *= inv;\n                    break;\n                case '>':\n                    g[i] *= bse;\n                    break;\n                default:\n                    puts(\"dfcmd\");\n            }\n            mp[f[i]]++;\n        }\n        LL ans = 0;\n        for (int i = 1; i <= n; ++i) {\n            ans += mp[f[n] * g[i - 1] + f[i - 1]];\n            mp[f[i]]--;\n        }\n        writeln(ans);\n        return 0;\n    }\n}\n\nint main() {\n    return dfcmd::Main();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define lim 300000\nusing namespace std;\nconst int mod[3] = {1000000007, 998244353, 1004535809};\nint n;\nchar s[300005];\nlong long A[3], base[3][600005], lsp, p, suf[3][300005], pre[3];\nmap<long long, int> cnt[3];\nint fsp(long long bs, int p, int mod) {\n    int rt = 1;\n    while (p) {\n        if (p & 1) rt = bs * rt % mod;\n        bs = bs * bs % mod, p >>= 1;\n    }\n    return rt;\n}\n\nlong long bs(int id, int p) { return base[id][p + lim]; }\n\nint main() {\n    for (int t = 0; t < 3; ++t) {\n        for (int i = base[t][lim] = 1; i <= lim; ++i)\n            base[t][lim + i] = base[t][lim + i - 1] * 250007 % mod[t];\n        for (int i = 1, ny = fsp(250007, mod[t] - 2, mod[t]); i <= lim; ++i)\n            base[t][lim - i] = base[t][lim - i + 1] * ny % mod[t];\n    }\n    scanf(\"%d%s\", &n, s + 1), p = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (s[i] == '>') ++p;\n        if (s[i] == '<') --p;\n        for (int t = 0; t < 3; ++t) {\n            if (s[i] == '+') (A[t] += bs(t, p)) %= mod[t];\n            if (s[i] == '-') (A[t] += mod[t] - bs(t, p)) % mod[t];\n        }\n    }\n\n    for (int t = 0; t < 3; ++t) ++cnt[t][suf[t][n + 1] = 0];\n    for (int i = n; i > 1; --i) {\n        for (int t = 0; t < 3; ++t) suf[t][i] = suf[t][i + 1];\n        if (s[i] == '>') --p;\n        if (s[i] == '<') ++p;\n        for (int t = 0; t < 3; ++t) {\n            if (s[i] == '+') (suf[t][i] += bs(t, p)) %= mod[t];\n            if (s[i] == '-') (suf[t][i] += mod[t] - bs(t, p)) %= mod[t];\n            ++cnt[t][suf[t][i]];\n        }\n    }\n\n    long long res = min(min(cnt[0][0], cnt[1][0]), cnt[2][0]);\n    p = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (s[i] == '>') ++p;\n        if (s[i] == '<') --p;\n        int tmp = 1000000;\n        for (int t = 0; t < 3; ++t) {\n            int m = mod[t];\n            if (s[i] == '+') (pre[t] += bs(t, p)) %= m;\n            if (s[i] == '-') (pre[t] += mod[t] - bs(t, p)) % m;\n            --cnt[t][suf[t][i + 1]];\n            tmp = min(\n                tmp,\n                cnt[t][((A[t] - pre[t] - A[t] * bs(t, p) % m) % m + m) % m]);\n        }\n        res += tmp;\n    }\n    printf(\"%lld\\n\", res);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\nint modpow(int x, int k, int MOD) {\n  int a = 1;\n  while (k) {\n    if (k&1) a = (1LL*a*x)%MOD;\n    x = (1LL*x*x)%MOD;\n    k>>=1;\n  }\n  return a;\n}\n#define MOD 1000000007\nconst int B = 3213212;\n\nint N;\nstring S;\nint pB[500001];\nint memo[250000];\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  pB[0] = 1;\n  for (int i=1; i<=500000; i++) pB[i] = (1LL*pB[i-1]*B)%MOD;\n\n  cin >> N >> S;\n  int p = 250000;\n  int hash = 0;\n  map<int, int> mp;\n  rep(i, N) {\n    if (S[i] == '+') hash = (hash + pB[p]) % MOD;\n    if (S[i] == '-') hash = (hash + MOD-pB[p]) % MOD;\n    if (S[i] == '>') p++;\n    if (S[i] == '<') p--;\n    memo[i] = hash;\n    mp[hash]++;\n  }\n\n  const int ONE = pB[250000];\n  int invB = modpow(B, MOD-2, MOD);\n  long long sum = 0;\n\n  int a = 1, b = 0; // h -> h*a+b\n  rep(l, N) {\n    int h = (1LL*hash*a+b)%MOD;\n    sum += mp[h];\n\n    if (S[l] == '+') b = (b+1LL*a*ONE)%MOD; // all -= ONE\n    if (S[l] == '-') b = (b+1LL*a*(MOD-ONE))%MOD; // all += ONE\n    if (S[l] == '>') a = (1LL*a*B)%MOD; // all /= B\n    if (S[l] == '<') a = (1LL*a*invB)%MOD; // all *= B\n    mp[memo[l]]--;\n  }\n  cout << sum << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing ll = long long;\nconstexpr ll pow(const ll a, const ll b, const ll mod) { return b == 0 ? 1LL : b % 2 == 1 ? pow(a, b - 1, mod) * a % mod : pow(a * a % mod, b / 2, mod); }\nconstexpr ll inverse(const ll a, const ll mod) { return pow(a, mod - 2, mod); }\nconstexpr ll MOD0 = 1000000007LL, MOD1 = 1000000009LL, MOD2 = 1000000021;\nconstexpr ll X = 121234243;\nconstexpr ll XINV0 = inverse(X, MOD0), XINV1 = inverse(X, MOD1), XINV2 = inverse(X, MOD2);\nint main()\n{\n    int N;\n    std::string S;\n    std::cin >> N >> S;\n    using P = std::tuple<ll, ll, ll>;\n    std::vector<int> deg(N + 1, 0);\n    std::vector<P> value(N + 1, {0, 0, 0});\n    auto plus = [](const P& p1, const P& p2) { return P{(std::get<0>(p1) + std::get<0>(p2)) % MOD0, (std::get<1>(p1) + std::get<1>(p2)) % MOD1, (std::get<2>(p1) + std::get<2>(p2)) % MOD2}; };\n    auto minus = [](const P& p1, const P& p2) { return P{(std::get<0>(p1) + MOD0 - std::get<0>(p2)) % MOD0, (std::get<1>(p1) + MOD1 - std::get<1>(p2)) % MOD1, (std::get<2>(p1) + MOD2 - std::get<2>(p2)) % MOD2}; };\n    auto rshift = [](const P& p) { return P{std::get<0>(p) * X % MOD0, std::get<1>(p) * X % MOD1, std::get<2>(p) * X % MOD2}; };\n    auto lshift = [](const P& p) { return P{std::get<0>(p) * XINV0 % MOD0, std::get<1>(p) * XINV1 % MOD1, std::get<2>(p) * XINV2 % MOD2}; };\n    auto mul = [](const P& p1, const P& p2) { return P{std::get<0>(p1) * std::get<0>(p2) % MOD0, std::get<1>(p1) * std::get<1>(p2) % MOD1, std::get<2>(p1) * std::get<2>(p2) % MOD2}; };\n    for (int i = N - 1; i >= 0; i--) {\n        if (S[i] == '-') {\n            deg[i] = deg[i + 1], value[i] = minus(value[i + 1], {1, 1, 1});\n        } else if (S[i] == '+') {\n            deg[i] = deg[i + 1], value[i] = plus(value[i + 1], {1, 1, 1});\n        } else if (S[i] == '>') {\n            deg[i] = deg[i + 1] + 1, value[i] = rshift(value[i + 1]);\n        } else {\n            deg[i] = deg[i + 1] - 1, value[i] = lshift(value[i + 1]);\n        }\n    }\n    constexpr int L = 250000;\n    std::vector<P> power(L + 1, {1, 1, 1});\n    std::vector<P> invpower(L + 1, {1, 1, 1});\n    auto invp = [&](const int i) { return i >= 0 ? invpower[i] : power[-i]; };\n    for (int i = 1; i <= L; i++) { power[i] = rshift(power[i - 1]), invpower[i] = lshift(invpower[i - 1]); }\n    const P answer = value[0];\n    for (int i = 0; i <= N; i++) { value[i] = mul(minus(value[i], answer), invp(deg[i])); }\n    std::map<P, ll> mp;\n    ll ans = 0;\n    for (int i = 0; i <= N; i++) {\n        const P obj = plus(value[i], mul(invp(deg[i]), answer));\n        if (mp.find(obj) != mp.end()) { ans += mp[obj]; }\n        mp[value[i]]++;\n    }\n    std::cout << ans << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>pii;\nconst int MAXN=3e5+5;\nconst int BASE=3137;\nconst int MOD1=1e9+7;\nconst int MOD2=1e9+9;\nint N;\nchar s[MAXN];\npii pref[MAXN],pot[MAXN];\nmap<pii,int>cnt;\n\ninline int add(int x,int y,int mod){\n\tx+=y;\n\tif(x>=mod)\n\t\tx-=mod;\n\telse if(x<0)\n\t\tx+=mod;\n\treturn x;\n}\n\ninline int mul(int x,int y,int mod){\n\treturn (ll)x*y%mod;\n}\n\nint power(int x,int y,int mod){\n\tint res=1;\n\tfor(;y;y/=2){\n\t\tif(y%2)res=mul(res,x,mod);\n\t\tx=mul(x,x,mod);\n\t}\n\treturn res;\n}\n\npii operator +(const pii&l,const pii&r){\n\tint a=l.first,b=l.second;\n\tint c=r.first,d=r.second;\n\treturn{add(a,c,MOD1),add(b,d,MOD2)};\n}\n\npii operator*(const pii &l,const pii &r){\n\tint a=l.first,b=l.second;\n\tint c=r.first,d=r.second;\n\treturn{mul(a,c,MOD1),mul(b,d,MOD2)};\n}\n\nll solve(){\n\tint inv1=power(BASE,MOD1-2,MOD1);\n\tint inv2=power(BASE,MOD2-2,MOD2);\n\tpot[0]={1,1};\n\tfor(int i=1;i<=N;++i){\n\t\tpot[i]=pot[i-1];\n\t\tpref[i]=pref[i-1];\n\t\tif(s[i]=='>')\n\t\t\tpot[i]=pot[i]*pii(BASE,BASE);\n\t\telse if(s[i]=='<')\n\t\t\tpot[i]=pot[i]*pii(inv1,inv2);\n\t\telse if(s[i]=='+')\n\t\t\tpref[i]=pref[i]+pot[i];\n\t\telse{\n\t\t\tint a=pot[i].first;\n\t\t\tint b=pot[i].second;\n\t\t\tpref[i]=pref[i]+pii(-a,-b);\n\t\t}\n\t}\n\tll ans=0;\n\tfor(int i=N;i;--i){\n\t\t++cnt[pref[i]];\n\t\tpii a=pref[N];\n\t\tans+=cnt[(a*pot[i-1])+pref[i-1]];\n\t}\n\treturn ans;\n}\n\nint main(){\n\tscanf(\"%d%s\",&N,s+1);\n\tprintf(\"%lld\\n\",solve());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n      \n#define FOR(i,a,b) for(ll i = (a); i < (ll)(b); i++)\n#define REP(i,n) FOR(i,0,n)\n#define YYS(x,arr) for(auto& x:arr)\n#define PW(x) (1LL<<(x))\n#define SZ(x) ((ll)(x).size())\n\n#define pb emplace_back\n#define fi first\n#define se second\n\nusing namespace std;\n\nusing ld = long double;\nusing ll = long long int;\n\nconst ll INF = (ll)1e9 + 10;\nconst ll INFLL = (ll)1e18 + 10;\nconst ll MOD = 1e9+7;\nconst ll MOD2 = 765876961;\n\ntemplate<class T> T &chmin( T &a , const T &b ){ return a = min(a,b); }\ntemplate<class T> T &chmax( T &a , const T &b ){ return a = max(a,b); }\ntemplate<class T> void UNIQUE(vector<T> &a){ a.erase(unique(a.begin(), a.end()), a.end()); }\n\ntemplate<class S, class T> ostream& operator << (ostream& os, const pair<S, T> v){\n  os << \"(\" << v.first << \", \" << v.second << \")\"; return os;\n}\ntemplate<class T> ostream& operator << (ostream& os, const vector<T> v){\n  for(int i = 0; i < v.size(); i++){if(i > 0){os << \" \";} os << v[i];} return os;\n}\ntemplate<class T> ostream& operator << (ostream& os, const vector<vector<T>> v){\n  for(int i = 0; i < v.size(); i++){if(i > 0){os << endl;} os << v[i];} return os;\n}\n\nll in(){long long int x; scanf(\"%lld\", &x); return x;}\nld fin(){double x; scanf(\"%lf\", &x); return x;}\nchar yuyushiki[1000010]; string stin(){scanf( \"%s\", yuyushiki ); return yuyushiki;}\n\n// head\n\n\nstruct Mod{\n  unsigned n;\n  Mod() : n(0){}\n  Mod( ll x ){\n    if( x < 0 ) n = x%MOD+MOD;\n    else n = x%MOD;\n  }\n};\nMod operator + ( Mod a  , Mod b ){ return Mod( a.n + b.n ); }\nMod operator +=( Mod &a , Mod b ){ return a = a + b; }\nMod operator - ( Mod a ){ return Mod( MOD - a.n ); }\nMod operator - ( Mod a  , Mod b ){ return Mod( a.n + MOD - b.n ); }\nMod operator -=( Mod &a , Mod b ){ return a = a - b; }\nMod operator * ( Mod a  , Mod b ){ return Mod( (ll)a.n * b.n ); }\nMod operator *=( Mod &a , Mod b ){ return a = a * b; }\nMod modpow( Mod x , ll k ){\n  Mod res = 1;\n  while( k ){\n    if( k & 1 ) res *= x;\n    k /= 2;\n    x *= x;\n  }\n  return res;\n}\nll extgcd( ll a , ll b , ll &x , ll &y ){\n  ll d = a;\n  if( b != 0 ){\n    d = extgcd( b , a % b , y , x );\n    y -= a / b * x;\n  } else {\n    x = 1, y = 0;\n  }\n  return d;\n}\nMod inv( Mod a ){ ll x, y; assert( extgcd( a.n , MOD , x , y ) == 1 ); return Mod( x ); }\nMod operator / ( Mod a  , Mod b ){ return Mod( (ll)a.n * inv(b).n ); }\nMod operator /=( Mod &a , Mod b ){ return a = a / b; }\n\n\nstruct Mod2{\n  unsigned n;\n  Mod2() : n(0){}\n  Mod2( ll x ){\n    if( x < 0 ) n = x%MOD2+MOD2;\n    else n = x%MOD2;\n  }\n};\nMod2 operator + ( Mod2 a  , Mod2 b ){ return Mod2( a.n + b.n ); }\nMod2 operator +=( Mod2 &a , Mod2 b ){ return a = a + b; }\nMod2 operator - ( Mod2 a ){ return Mod2( MOD2 - a.n ); }\nMod2 operator - ( Mod2 a  , Mod2 b ){ return Mod2( a.n + MOD2 - b.n ); }\nMod2 operator -=( Mod2 &a , Mod2 b ){ return a = a - b; }\nMod2 operator * ( Mod2 a  , Mod2 b ){ return Mod2( (ll)a.n * b.n ); }\nMod2 operator *=( Mod2 &a , Mod2 b ){ return a = a * b; }\nMod2 modpow( Mod2 x , ll k ){\n  Mod2 res = 1;\n  while( k ){\n    if( k & 1 ) res *= x;\n    k /= 2;\n    x *= x;\n  }\n  return res;\n}\nMod2 inv( Mod2 a ){ ll x, y; assert( extgcd( a.n , MOD2 , x , y ) == 1 ); return Mod2( x ); }\nMod2 operator / ( Mod2 a  , Mod2 b ){ return Mod2( (ll)a.n * inv(b).n ); }\nMod2 operator /=( Mod2 &a , Mod2 b ){ return a = a / b; }\n\n\n/*\nconst ll MUL[3] = { 72727 , 51419 , 79393  };\nconst ll RHMOD[3] = { 1000000007 , 765876961 , 727272727 };\n*/\n\nusing pl = pair<ll, ll>;\n\nconst ll B = 72727;\nconst ll B2 = 79393;\nconst ll N = 500020;\n\nint n;\nstring s;\n\nMod cur;\nMod2 cur2;\npl state[N];\nll ps[N];\n\nMod e[N];\nMod2 e2[N];\n\nint main(){\n\n  e[0] = 1;\n  FOR(i, 1, N){\n    e[i] = e[i-1] * B;\n  }\n\n  e2[0] = 1;\n  FOR(i, 1, N){\n    e2[i] = e2[i-1] * B2;\n  }\n  \n  n = in();\n  s = stin();\n\n  ll start = 250010;\n  ll p = start;\n\n  REP(i, n){\n    state[i] = pl(cur.n, cur2.n);\n    ps[i] = p;\n    if(s[i] == '+'){\n      cur += e[p];\n      cur2 += e2[p];\n    } else if(s[i] == '-'){\n      cur -= e[p];\n      cur2 -= e2[p];\n    } else if(s[i] == '>'){\n      p++;\n    } else if(s[i] == '<'){\n      p--;\n    }\n  }\n  state[n] = pl(cur.n, cur2.n);\n\n  map<pl, ll> cnt;\n  ll ans = 0;\n  \n  for(int i = n; i >= 1; i--){\n    if(cnt.find(state[i]) == cnt.end()){\n      cnt[state[i]] = 1;\n    } else {\n      cnt[state[i]] += 1;\n    }\n    ll j = i - 1;\n\n    Mod mokuhyo = 0;\n    Mod2 mokuhyo2 = 0;\n    if(ps[j] >= start){\n      mokuhyo = cur * e[ps[j]-start] + state[j].fi;\n      mokuhyo2 = cur2 * e2[ps[j]-start] + state[j].se;\n    } else {\n      mokuhyo = cur / e[start-ps[j]] + state[j].fi;\n      mokuhyo2 = cur2 / e2[start-ps[j]] + state[j].se;\n    }\n    ans += cnt[pl(mokuhyo.n, mokuhyo2.n)];\n  }\n\n  cout << ans << endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\t#include <iostream>\n    #include <string>\n    #include <set>  \n    #include <stack>\n    #include <algorithm>\n    #include <vector>\n    #include <cmath>\n    #include <queue>\n    #include <deque>\n    #include <cstring>\n    #include <cstdio>\n    #include <map>\n    #include <numeric>\n    #include <cassert>\n    #include <iomanip>\n    #include <sstream>\n    #include <ctime>\nusing namespace std;\n#define for1(i,a,b) for(int i=(a);i<(int)(b);++i)\n#define rep(i,maxn) for1(i,0,maxn)\n#define ford(i,b,a) for(int i=(int)(b)-1;i>=a;--i)\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define st first\n#define nd second\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define dprintf(...) printf(__VA_ARGS__)\nconst int maxn=250100;\nll M=10001659;\nll X=2246;\nll a[maxn],b[maxn],t[maxn],T[maxn];\nint n;\nchar s[maxn];\nll qp(ll base,int ind)\n{\n\tll ans=1;\n\tbase%=M;\n\twhile(ind)\n\t{\n\t\tif(ind&1)ans=ans*base%M;\n\t\tind>>=1;\n\t\tbase=base*base%M;\n\t}\n\treturn ans;\n}\nll inv(ll x)\n{\n\treturn qp(x,(int)(M-2));\n}\nmap<ll,int> trans;\nint main()\n{\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",s);\n\tll rev=inv(X);\n//\tcout<<rev<<endl;\n//\tsystem(\"pause\");\n\tmemset(t,0,sizeof(t));\n\tford(i,n,0)\n\t{\n\t\tt[i]=t[i+1];\n\t\tif(s[i]=='+')\n\t\t{\n\t\t\tt[i]++;\n\t\t\tt[i]%=M;\n\t\t}\n\t\telse if(s[i]=='-')\n\t\t{\n\t\t\tt[i]--;\n\t\t\tt[i]+=M;\n\t\t\tt[i]%=M;\n\t\t}\n\t\telse if(s[i]=='>')\n\t\t{\n\t\t\tt[i]*=rev;\n\t\t\tt[i]%=M;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tt[i]*=X;\n\t\t\tt[i]%=M;\n\t\t}\n//\t\tcout<<t[i]<<endl;\n//\t\tsystem(\"pause\");\n\t}\n\tll c=t[0];\n//\tprintf(\"%lld\\n\",c);\n//\tsystem(\"pause\");\n\tint multa=1,mina=0,multb=1,minb=0;\n\tford(i,n,0)\n\t{\n\t\tif(s[i]=='+')\n\t\t{\n\t\t\tmina-=multa,minb-=multb;\n\t\t\tmina+=M,minb+=M;\n\t\t\tmina%=M,minb%=M; \n\t\t}\n\t\telse if(s[i]=='-')\n\t\t{\n\t\t\tmina+=multa,minb+=multb;\n\t\t\tmina%=M,minb%=M;\n\t\t}\n\t\telse if(s[i]=='>')\n\t\t{\n\t\t\tmulta=multa*X%M;\n\t\t\tmultb=multb*X%M;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmulta=multa*rev%M;\n\t\t\tmultb=multb*rev%M;\n\t\t}\n\t\ta[i]=mina%M;\n\t\tb[i]=(c*multb%M+minb%M)%M;\n\t//\tcout<<a[i]<<\" \"<<b[i]<<endl;\n\t\ttrans[b[i]]++;\n\t//\tsystem(\"pause\");\n\t}\n\t\n\t//a(j+1)=b(i) j+1>i\n\tint ans=0;\n\tford(j,n-1,0)\n\t{\n\t//\tcout<<trans[a[j+1]]<<\" \"<<a[j+1]<<endl;\n\t//\tsystem(\"pause\");\n\t\ttrans[b[j+1]]--;\n\t\tans+=trans[a[j+1]];\n\t}\n\trep(i,n)\n\t\tif(a[i]==a[0])ans++;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MX 500000\nusing namespace std;\ntypedef long long lnt;\ntemplate <class T> inline void read(T &x) {\n\tx = 0; int c = getchar(), f = 1;\n\tfor (; !isdigit(c); c = getchar()) if (c == 45) f = -1;\n\tfor (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');\n}\nint n; char s[MX+5];\nlnt pw[MX+5], h[MX+5];\nmap <lnt, int> c; lnt cur, ans;\nlnt p = 233, q = 7204522363551799129;\nint main() {\n\tread(n), scanf(\"%s\", s+1), cur = 1;\n\tfor (int i = 1; i <= n; c[h[i++]]++) {\n\t\tif (s[i] ==\t'+') h[i] = h[i-1]+cur;\n\t\tif (s[i] == '-') h[i] = h[i-1]-cur;\n\t\tif (s[i] == '>') cur *= p, h[i] = h[i-1];\n\t\tif (s[i] == '<') cur *= q, h[i] = h[i-1];\n\t}\n\tcur = 1;\n\tfor (int i = 1; i <= n; c[h[i++]]--) {\n\t\tans += c[h[n]*cur+h[i-1]];\n\t\tif (s[i] == '>') cur *= p;\n\t\tif (s[i] == '<') cur *= q;\n\t}\n\treturn printf(\"%lld\\n\", ans), 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fo(a,b,c) for (a=b; a<=c; a++)\n#define fd(a,b,c) for (a=b; a>=c; a--)\n#define mod 1000000007\n#define Mod 1000000005\n#define ll long long\n//#define file\nusing namespace std;\n\nll p[250001],P[250001],hs[250001],s,p1,p2,ans;\nint sum[250001],n,i,j,k,l;\nchar st[250001];\nmap<int,int> mp;\nmap<int,int> :: iterator I;\n\nll qpower(ll a,int b) {ll ans=1; while (b) {if (b&1) ans=ans*a%mod;a=a*a%mod;b>>=1;} return ans;}\nll Pow(int t) {return (t>=0)?p[t]:P[-t];}\n\nint main()\n{\n\t#ifdef file\n\tfreopen(\"arc099f.in\",\"r\",stdin);\n\t#endif\n\t\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",st+1);\n\tp1=1234567,p2=qpower(p1,Mod);\n\tp[0]=P[0]=1;\n\tfo(i,1,n) p[i]=p[i-1]*p1%mod,P[i]=P[i-1]*p2%mod;\n\t\n\tfd(i,n,1)\n\t{\n\t\tswitch (st[i])\n\t\t{\n\t\t\tcase '>':{sum[i]=1,s=s*p1%mod;break;}\n\t\t\tcase '<':{sum[i]=-1,s=s*p2%mod;break;}\n\t\t\tcase '+':{s=(s+1)%mod;break;}\n\t\t\tcase '-':{s=(s-1)%mod;break;}\n\t\t}\n\t\ts=(s+mod)%mod;\n\t\ths[i]=s;\n\t}\n\tfo(i,1,n) sum[i]+=sum[i-1];\n\t\n\tmp[0]=1;\n\tfd(i,n,1)\n\t{\n\t\ts=((hs[i]-hs[1])*Pow(sum[i-1])%mod+mod)%mod;\n\t\tI=mp.find(s);\n\t\tif (I!=mp.end())\n\t\tans+=I->second;\n\t\t++mp[hs[i]*Pow(sum[i-1])%mod];\n\t}\n\tprintf(\"%lld\\n\",ans);\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//>> OI Solution Info <<//\n// Version: 2\n// State: Progress\n// Problem: Eating Symbols Hard\n// ID: AtCoder ARC099D\n// Time: ---\n// Timeline:\n//   --- ~ --- Initialize\n// Review:\n//   ---\n//>> End <<//\n#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#define y0 y_0\n#define y1 y_1\n#define yn y_n\n#include <assert.h>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\n\ninline int fpow(int x,int y,int mod){\n\tif(y==0)return 1;\n\tlong long res=fpow(x,y/2,mod);\n\t(res*=res)%=mod;\n\treturn y%2==0?int(res):int(res*x%mod);\n}\n\nstatic const int Mult=4;\nstatic const int Mod=1000000007;\nstatic const int Advance[4]={113,113113,233,23333333};\nstatic const int Offset=250005;\n\nstruct Hash{\n\tint a[4];\n\tstatic int pow[4][500010];\n\t\n\tHash(){\n\t\tfor(int i=0;i<Mult;i++)a[i]=0;\n\t}\n\t\n\tbool operator==(const Hash& r)const{\n\t\tfor(int i=0;i<Mult;i++)if(a[i]!=r.a[i])return false;\n\t\treturn true;\n\t}\n\t\n\tbool operator<(const Hash& r)const{\n\t\tfor(int i=0;i<Mult;i++)if(a[i]!=r.a[i])return a[i]<r.a[i];\n\t\treturn false;\n\t}\n\t\n\tHash operator-(const Hash& r)const{\n\t\tHash res;\n\t\tfor(int i=0;i<Mult;i++)res.a[i]=(a[i]+Mod-r.a[i])%Mod;\n\t\treturn res;\n\t}\n\t\n\tvoid inc(int pos,int x){\n\t\tx=(x+Mod)%Mod;\n\t\tfor(int i=0;i<Mult;i++){\n\t\t\t(a[i]+=int((long long)pow[i][pos+Offset]*x%Mod))%=Mod;\n\t\t\tassert(a[i]>=0);\n\t\t}\n\t}\n\t\n\tvoid shift(int x){\n\t\tfor(int i=0;i<Mult;i++){\n\t\t\ta[i]=int((long long)a[i]*pow[i][x+Offset]%Mod);\n\t\t\tassert(a[i]>=0);\n\t\t}\n\t}\n\t\n\tstatic void init(){\n\t\tfor(int i=0;i<Mult;i++){\n\t\t\tint inv=fpow(Advance[i],Mod-2,Mod);\n\t\t\tpow[i][Offset]=1;\n\t\t\tfor(int j=Offset-1;j>=0;j--)pow[i][j]=int((long long)pow[i][j+1]*inv%Mod);\n\t\t\tfor(int j=Offset+1;j<500010;j++)pow[i][j]=int((long long)pow[i][j-1]*Advance[i]%Mod);\n\t\t\tfor(int j=0;j<500010;j++)assert(pow[i][j]>=0);\n\t\t}\n\t}\n};\nint Hash::pow[4][500010];\n\nint n;\nchar s[250005];\nHash all;\n\n/*\nHash eval(int l,int r){\n\tint p=0;\n\tHash res;\n\tfor(int i=r;i>=l;i--){\n\t\tif(s[i]=='+')res.inc(0,1);\n\t\telse if(s[i]=='-')res.inc(0,-1);\n\t\telse if(s[i]=='<')res.shift(-1);\n\t\telse if(s[i]=='>')res.shift(1);\n\t}\n\treturn res;\n}\n*/\n\nlong long solve(int l,int r){\n\tif(l==r){\n\t\tHash curr;\n\t\tif(s[l]=='+')curr.inc(0,1);\n\t\telse if(s[l]=='-')curr.inc(0,-1);\n\t\treturn curr==all?1:0;\n\t}\n\t\n\tlong long res=0;\n\tint mid=(l+r)/2;\n\t\n\tHash right;\n\tint p=0;\n\tmap<Hash,int> cnt;\n\tfor(int i=mid+1;i<=r;i++){\n\t\tif(s[i]=='+')right.inc(p,1);\n\t\telse if(s[i]=='-')right.inc(p,-1);\n\t\telse if(s[i]=='<')p--;\n\t\telse if(s[i]=='>')p++;\n\t\tcnt[right]++;\n\t}\n\t\n\tHash left;\n\tp=0;\n\tfor(int i=mid;i>=l;i--){\n\t\tif(s[i]=='+')left.inc(0,1);\n\t\telse if(s[i]=='-')left.inc(0,-1);\n\t\telse if(s[i]=='<'){\n\t\t\tleft.shift(-1);\n\t\t\tp--;\n\t\t}\n\t\telse if(s[i]=='>'){\n\t\t\tleft.shift(1);\n\t\t\tp++;\n\t\t}\n\t\tHash curr=all-left;\n\t\tcurr.shift(-p);\n\t\tres+=cnt[curr];\n\t}\n\t\n//\tprintf(\"%d [%d] %d => %lld\\n\",l,mid,r,res);\n\t\n\tres+=solve(l,mid);\n\tres+=solve(mid+1,r);\n\treturn res;\n}\n\nint main(){\n\tHash::init();\n\tscanf(\"%d %s\",&n,s);\n\t\n\tint p=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(s[i]=='+')all.inc(p,1);\n\t\telse if(s[i]=='-')all.inc(p,-1);\n\t\telse if(s[i]=='<')p--;\n\t\telse if(s[i]=='>')p++;\n\t}\n\t\n\tprintf(\"%lld\\n\",solve(0,n-1));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long ll;\nconst int maxn = 250002;\nchar buf[maxn];\nint n,sum,s[maxn];\ninline void reduce(int & x,const int & mod){ x += x >> 31 & mod; }\ninline int pow(int a,int b,const int & mod,int ret = 1){\n\tfor(b = b % (mod - 1) + mod - 1;b;b>>=1,a=ll(a) * a % mod)if(b & 1)\n\t\tret = ll(ret) * a % mod;\n\treturn ret;\n}\nconstexpr int m0 = 1192230913,b0 = 233333;\nconstexpr int m1 = 1085276161,b1 = 2333333;\nstruct Int{\n\tint a0,a1;\n\tinline Int(int x0 = 0,int x1 = 0){ a0 = x0,a1 = x1; }\n\tinline void add(){ reduce(a0 += b0 - m0,m0); reduce(a1 += b1 - m1,m1); }\n\tinline void dec(){ reduce(a0 -= b0,m0); reduce(a1 -= b1,m1); }\n\tinline void mul(int cnt){ a0 = pow(b0,cnt,m0,a0); a1 = pow(b1,cnt,m1,a1); }\n\tinline bool operator < (const Int & b) const { return * (ll*) this < * (ll*) & b; }\n} a[maxn], b[maxn];\n\nint main()\n{\n\tstd::ios::sync_with_stdio(false),std::cin.tie(0);\n\tstd::cin >> n >> buf + 1;\n\tfor(int i = 1;i <= n;++i){\n\t\ta[i] = a[i - 1];\n\t\tif(buf[i] == '+') a[i].add();\n\t\tif(buf[i] == '-') a[i].dec();\n\t\tif(buf[i] == '>') a[i].mul(1),--sum;\n\t\tif(buf[i] == '<') a[i].mul(-1),++sum;\n\t\ts[i] = sum;\n\t\t(b[i] = a[i]).mul(sum);\n\t}\n\tll ans = 0;\n\tstd::map<Int,int> map;\n\tfor(int i = n;i >= 0;--i){\n\t\tInt x = b[n]; x.mul(s[i]);\n\t\tans += map[Int((b[i].a0 + x.a0) % m0,(b[i].a1 + x.a1) % m1)];\n\t\t++map[b[i]];\n\t}\n\tstd::cout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "        #include \"bits/stdc++.h\"\n        using namespace std;\n         \n        #define MAX 600012\n         \n        int n;\n        char buf[MAX];\n         \n         \n        string s;\n         \n         \n        //#define MOD1 1000000007\n        //#define MOD2 1000000009\n         \n        valarray<long long int> MOD1;\n        valarray<long long int> MOD2;\n        vector<valarray<long long int> > p2;\n        vector<valarray<long long int> > vv;\n        vector<int> ps;\n        map<pair<long long int,long long int>, int> mp;\n        long long int ppow(long long int i, long long int j, long long int MOD) {\n        \tlong long int ret = 1;\n        \twhile (j) {\n        \t\tif (j & 1LL)ret *= i;\n        \t\tif (ret >= MOD)ret %= MOD;\n        \t\tj >>= 1LL;\n        \t}\n        \treturn ret;\n        }\n         \n        valarray<long long int> calc(int dif) {\n        \tvalarray<long long int> ret;\n        \tret.resize(2, 0);\n        \tfor (int j = 0; j < 2; j++) {\n        \t\tif (dif < 0) {\n        \t\t\tret[j]=ppow(ppow(MOD1[j],MOD2[j]-2,MOD2[j]),-dif,MOD2[j]);\n        \t\t}\n        \t\telse {\n        \t\t\tret[j] = ppow(MOD1[j],dif, MOD2[j]);\n        \t\t}\n        \t}\n        \treturn ret;\n        }\n         \n        int main() {\n        \tMOD1.resize(2);\n        \tMOD2.resize(2);\n        \tp2.push_back(valarray<long long int>());\n        \tp2.back().resize(2);\n        \tp2.back()[0] = p2.back()[1] = 1;\n        \tMOD2[0] = 1000000007;\n        \tMOD1[0] = 555522277;\n        \tMOD1[1] = 895612782;\n        \tMOD2[1] = 998244353;\n        \tp2[0] %= MOD2;\n        \tfor (int i = 1; i < MAX; i++) p2.push_back((p2.back()*MOD1)%MOD2);\n        \tcin >> n;\n        \tscanf(\"%s\", buf);\n        \ts = buf;\n        \tint pos = MAX/2;\n        \tvalarray<long long int> hs;\n        \ths.resize(2,0);\n        \tvv.push_back(hs);\n        \tps.push_back(pos);\n        \tfor (int i = 0; i < s.size(); i++) {\n        \t\tif (s[i] == '<') pos--;\n        \t\telse if (s[i] == '>') pos++;\n        \t\telse if (s[i] == '+') hs += p2[pos];\n        \t\telse if (s[i] == '-') hs += MOD2-p2[pos];\n        \t\ths %= MOD2;\n        \t\tvv.push_back(hs);\n        \t\tps.push_back(pos);\n        \t}\n        \tlong long int way = 0;\n        \tfor (int i = vv.size() - 1; i >= 0; i--) {\n        \t\tvalarray<long long int> want = (vv[i] + ((vv.back()*calc(-MAX/2+ps[i]))%MOD2))%MOD2;\n        \t\tway += mp[make_pair(want[0], want[1])];\n        \t\tmp[make_pair(vv[i][0],vv[i][1])]++;\n        \t}\n        \tprintf(\"%lld\\n\", way);\n        \treturn 0;\n        }\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#define hash __hash\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long hash;\n\nconst hash BASE = 2340298430918231;\nconst hash INVBASE = 353531932664012135;\n\nconst int MAX_N = 3e5 + 5;\n\nhash _basepow [2 * MAX_N];\nhash& basepow (int idx) {\n  return _basepow[idx + MAX_N];\n}\n\nhash hash_at [MAX_N];\nint start_at [MAX_N];\n\nint main () {\n  ios::sync_with_stdio(false);\n\n  basepow(0) = 1;\n  for (int i = 1; i < MAX_N; i++) {\n    basepow(i) = basepow(i - 1) * BASE;\n  }\n  for (int i = -1; i > -MAX_N; i--) {\n    basepow(i) = basepow(i + 1) * INVBASE;\n  }\n  \n  int n;\n  cin >> n;\n  \n  string str;\n  cin >> str;\n\n  hash cur = 0;\n  hash pos = 1;\n  int start = 0;\n  for (int i = 0; i < (int) str.size(); i++) {\n    char c = str[i];\n    if (c == '+') cur += pos;\n    if (c == '-') cur -= pos;\n    if (c == '>') {\n      pos *= BASE;\n      start++;\n    }\n    if (c == '<') {\n      pos *= INVBASE;\n      start--;\n    }\n\n    hash_at[i + 1] = cur;\n    start_at[i + 1] = start;\n  }\n  \n  map<hash, int> cnt;\n  ll ans = 0;\n  for (int i = (int) str.size(); i >= 0; i--) {\n    hash target = cur * basepow(start_at[i]) + hash_at[i];\n    if (cnt.count(target) != 0) {\n      ans += cnt[target];\n    }\n\n    if (cnt.count(hash_at[i]) == 0) {\n      cnt[hash_at[i]] = 0;\n    }\n    cnt[hash_at[i]]++;\n  }\n\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n    _____\n  .'     '.\n /  0   0  \\\n|     ^     |\n|  \\     /  |\n \\  '---'  /\n  '._____.'\n*/\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\nstruct chash\n{\n\tint operator()(int x) const\n\t{\n\t\tx ^= (x >> 20) ^ (x >> 12);\n\t\treturn x ^ (x >> 7) ^ (x >> 4);\n\t}\n};\n\ntemplate<typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename U> using hashtable = gp_hash_table<T, U, chash>;\nrandom_device(rd);\nmt19937 rng(rd());\n\ntemplate<class T>\nvoid readi(T &x)\n{\n\tT input = 0;\n\tbool negative = false;\n\tchar c = ' ';\n\twhile (c < '-')\n\t{\n\t\tc = getchar();\n\t}\n\tif (c == '-')\n\t{\n\t\tnegative = true;\n\t\tc = getchar();\n\t}\n\twhile (c >= '0')\n\t{\n\t\tinput = input * 10 + (c - '0');\n\t\tc = getchar();\n\t}\n\tif (negative)\n\t{\n\t\tinput = -input;\n\t}\n\tx = input;\n}\ntemplate<class T>\nvoid printi(T output)\n{\n\tif (output == 0)\n\t{\n\t\tputchar('0');\n\t\treturn;\n\t}\n\tif (output < 0)\n\t{\n\t\tputchar('-');\n\t\toutput = -output;\n\t}\n\tint aout[20];\n\tint ilen = 0;\n\twhile(output)\n\t{\n\t\taout[ilen] = ((output % 10));\n\t\toutput /= 10;\n\t\tilen++;\n\t}\n\tfor (int i = ilen - 1; i >= 0; i--)\n\t{\n\t\tputchar(aout[i] + '0');\n\t}\n\treturn;\n}\ntemplate<class T>\nvoid ckmin(T &a, T b)\n{\n\ta = min(a, b);\n}\ntemplate<class T>\nvoid ckmax(T &a, T b)\n{\n\ta = max(a, b);\n}\ntemplate<class T, class U>\nT nmod(T &x, U mod)\n{\n\tif (x >= mod) x -= mod;\n}\ntemplate<class T>\nT randomize(T mod)\n{\n\treturn (uniform_int_distribution<T>(0, mod - 1))(rng);\n}\n\n#define y0 ___y0\n#define y1 ___y1\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fi first\n#define se second\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\nconst long double PI = 4.0 * atan(1.0);\nconst long double EPS = 1e-10;\n\n#define MAGIC 347\n#define SINF 10007\n#define CO 1000007\n#define INF 1000000007\n#define BIG 1000000931\n#define LARGE 1696969696967ll\n#define GIANT 2564008813937411ll\n#define LLINF 2696969696969696969ll\n#define MAXN 500013\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ld, ld> pdd;\n\nint N;\nint arr[MAXN];\npll S;\nlong long ans;\nunordered_map<ll, int> freq, need;\n\nll expo(ll a, ll e, ll mod)\n{\n\tif (e == 0)\n\t{\n\t\treturn 1;\n\t}\n\tll was = expo(a, e / 2, mod);\n\tif (e % 2)\n\t{\n\t\treturn was * was % mod * a % mod;\n\t}\n\treturn was * was % mod;\n}\nll modinv(ll a, ll e)\n{\n\treturn expo(a, e - 2, e);\n}\npll INV = {modinv(CO, INF), modinv(CO, BIG)};\nvoid solve(int L, int R)\n{\n\tif (L == R)\n\t{\n\t\treturn;\n\t}\n\tfreq.clear(); need.clear();\n\tint mid = (L + R) >> 1;\n\t//start from L...mid, end at mid + 1....R\n\tpair<pll, pll> trans = MP(MP(1, 0), MP(1, 0));\n\tfor (int i = mid + 1; i <= R; i++)\n\t{\n\t\tif (arr[i] == 0)\n\t\t{\n\t\t\ttrans.fi.fi *= INV.fi; trans.fi.fi %= INF;\n\t\t\ttrans.fi.se *= INV.fi; trans.fi.se %= INF;\n\t\t\ttrans.se.fi *= INV.se; trans.se.fi %= BIG;\n\t\t\ttrans.se.se *= INV.se; trans.se.se %= BIG;\n\t\t}\n\t\tif (arr[i] == 1)\n\t\t{\n\t\t\ttrans.fi.fi *= CO; trans.fi.fi %= INF;\n\t\t\ttrans.fi.se *= CO; trans.fi.se %= INF;\n\t\t\ttrans.se.fi *= CO; trans.se.fi %= BIG;\n\t\t\ttrans.se.se *= CO; trans.se.se %= BIG;\n\t\t}\n\t\tif (arr[i] == 2)\n\t\t{\n\t\t\ttrans.fi.se++; nmod(trans.fi.se, INF);\n\t\t\ttrans.se.se++; nmod(trans.se.se, BIG);\n\t\t}\n\t\tif (arr[i] == 3)\n\t\t{\n\t\t\ttrans.fi.se--; trans.fi.se += INF; nmod(trans.fi.se, INF);\n\t\t\ttrans.se.se--; trans.se.se += BIG; nmod(trans.se.se, BIG);\n\t\t}\n\t\t// cerr << \"from \" << mid + 1 << \" to \" << i << \" is \" << trans.fi << \"x + \" << trans.se << endl;\n\t\tpll dif = {(S.fi - trans.fi.se) * modinv(trans.fi.fi, INF), (S.se - trans.se.se) * modinv(trans.se.fi, BIG)};\n\t\tdif.fi %= INF; dif.fi += INF; nmod(dif.fi, INF);\n\t\tdif.se %= BIG; dif.se += BIG; nmod(dif.se, BIG);\n\t\tneed[dif.fi * BIG + dif.se]++;\n\t}\n\ttrans = MP(MP(1, 0), MP(1, 0));\n\tfor (int i = mid; i >= L; i--)\n\t{\n\t\tif (arr[i] == 0)\n\t\t{\n\t\t\ttrans.fi.fi *= INV.fi; trans.fi.fi %= INF;\n\t\t\ttrans.se.fi *= INV.se; trans.se.fi %= BIG;\n\t\t}\n\t\tif (arr[i] == 1)\n\t\t{\n\t\t\ttrans.fi.fi *= CO; trans.fi.fi %= INF;\n\t\t\ttrans.se.fi *= CO; trans.se.fi %= BIG;\n\t\t}\n\t\tif (arr[i] == 2)\n\t\t{\n\t\t\t//(x+1)*a+b = a * x + a + b\n\t\t\ttrans.fi.se += trans.fi.fi; nmod(trans.fi.se, INF);\n\t\t\ttrans.se.se += trans.se.fi; nmod(trans.se.se, BIG);\n\t\t}\n\t\tif (arr[i] == 3)\n\t\t{\n\t\t\t//(x - 1)*a + b = a*x - a + b\n\t\t\ttrans.fi.se -= trans.fi.fi; trans.fi.se += INF; nmod(trans.fi.se, INF);\n\t\t\ttrans.se.se -= trans.se.fi;\ttrans.se.se += BIG; nmod(trans.se.se, BIG);\n\t\t}\n\t\tfreq[trans.fi.se * BIG + trans.se.se]++;\n\t}\n\tfor (auto p : need)\n\t{\n\t\tans += 1ll * p.se * freq[p.fi];\n\t}\n\tsolve(L, mid);\n\tsolve(mid + 1, R);\n}\n\nint32_t main()\n{\n\tios_base::sync_with_stdio(0);\n\t// cout << fixed << setprecision(10);\n\t// cerr << fixed << setprecision(10);\n\t// freopen (\"file.in\", \"r\", stdin);\n\t// freopen (\"file.out\", \"w\", stdout);\n\tcin >> N;\n\tstring temps;\n\tcin >> temps;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (temps[i] == '<')\n\t\t{\n\t\t\tarr[i] = 0;\n\t\t}\n\t\tif (temps[i] == '>')\n\t\t{\n\t\t\tarr[i] = 1;\n\t\t}\n\t\tif (temps[i] == '+')\n\t\t{\n\t\t\tarr[i] = 2;\n\t\t}\n\t\tif (temps[i] == '-')\n\t\t{\n\t\t\tarr[i] = 3;\n\t\t}\n\t}\n\treverse(arr, arr + N);\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (arr[i] == 0)\n\t\t{\n\t\t\tS.fi *= INV.fi; S.fi %= INF;\n\t\t\tS.se *= INV.se; S.se %= BIG;\n\t\t\t// cerr << \"times \" << INV << endl;\n\t\t}\n\t\tif (arr[i] == 1)\n\t\t{\n\t\t\tS.fi *= CO; S.fi %= INF;\n\t\t\tS.se *= CO; S.se %= BIG;\n\t\t\t// cerr << \"times \" << CO << endl;\n\t\t}\n\t\tif (arr[i] == 2)\n\t\t{\n\t\t\tS.fi++; nmod(S.fi, INF);\n\t\t\tS.se++; nmod(S.se, BIG);\n\t\t\t// cerr << \"add 1\\n\";\n\t\t}\n\t\tif (arr[i] == 3)\n\t\t{\n\t\t\tS.fi--; S.fi += INF; nmod(S.fi, INF);\n\t\t\tS.se--; S.se += BIG; nmod(S.se, BIG);\n\t\t\t// cerr << \"add -1\\n\";\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (arr[i] == 0)\n\t\t{\n\t\t\tif (S == MP(0ll, 0ll)) ans++;\n\t\t}\n\t\tif (arr[i] == 1)\n\t\t{\n\t\t\tif (S == MP(0ll, 0ll)) ans++;\n\t\t}\n\t\tif (arr[i] == 2)\n\t\t{\n\t\t\tif (S == MP(1ll, 1ll)) ans++;\n\t\t}\n\t\tif (arr[i] == 3)\n\t\t{\n\t\t\tif (S == MP((ll) INF - 1, (ll) BIG - 1)) ans++;\n\t\t}\n\t}\n\tsolve(0, N - 1);\n\tcout << ans << '\\n';\n\t//when u <, the # divides by co\n\t//when u >, the # mults by co\n\t//when u +, u add the #\n\t//when u -, u subtract the #\n\t// cerr << \"time elapsed = \" << (clock() / (CLOCKS_PER_SEC / 1000)) << \" ms\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <vector>\n\nconst int DEBUG = 0;\n\n#define MOCK 1\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define DEBUGP(val) cerr << #val << \"=\" << val << \"\\n\"\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\ntypedef pair<ll, ll> PL;\n\n\nll powmod(ll a, ll e, ll mod) {\n  ll sum = 1;\n  ll cur = a;\n  while (e > 0) {\n    if (e % 2) {\n      sum = sum * cur % mod;\n    }\n    cur = cur * cur % mod;\n    e /= 2;\n  }\n  return sum;\n}\n\n\n\nint main(void) {\n  const ll mod = 1e9 + 7;\n  const ll mod2 = 1e9 + 9;\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  string s;\n  cin >> n >> s;\n  int p = 0;\n  VI pos(n + 1);\n  mt19937 mt;\n  ll b;\n  do {\n    b = mt() % mod;\n  } while (b == 0);\n  \n  vector<VL> hsh(3, VL(n + 1));\n  ll invb = powmod(b, mod - 2, mod);\n  ll invb2 = powmod(b, mod2 - 2, mod2);\n  ll mods[3] = { mod, mod2, 998244353 };\n  ll inv[3] = {invb, invb2};\n  REP(c, 0, 3) inv[c] = powmod(b, mods[c] - 2, mods[c]);\n  REP(c, 0, 3) {\n    p = 0;\n    ll cur = 1;\n    REP(i, 0, n) {\n      ll tmp = hsh[c][i];\n      if (s[i] == '>') {\n        p++;\n        cur = cur * b % mods[c];\n      }\n      if (s[i] == '<') {\n        p--;\n        cur = cur * inv[c] % mods[c];\n      }\n      if (s[i] == '+') {\n        tmp = (tmp + cur) % mods[c];\n      }\n      if (s[i] == '-') {\n        tmp = (tmp + mods[c] - cur) % mods[c];\n      }\n      hsh[c][i + 1] = tmp;\n      pos[i + 1] = p;\n    }\n  }\n  if (DEBUG) {\n    REP(i, 0, n + 1) {\n      cerr << i << \" \" << hsh[0][i] << endl;\n    }\n  }\n  VL meguru(3);\n  REP(c, 0, 3) meguru[c] = hsh[c][n];\n  map<VL, int> kirika;\n  kirika[meguru] = 1;\n  ll tot = 0;\n  VL cur(3);\n  REP(c, 0, 3) cur[c] = powmod(b, pos[n], mods[c]);\n  for (int i = n - 1; i >= 0; --i) {\n    if (DEBUG) {\n      DEBUGP(i);\n      DEBUGP(pos[i]);\n    }\n    if (pos[i + 1] - pos[i] == 1) {\n      REP(c, 0, 3) cur[c] = cur[c] * inv[c] % mods[c];\n    }\n    else if (pos[i + 1] - pos[i] == -1) {\n      REP(c, 0, 3) cur[c] = cur[c] * b % mods[c];\n    }\n    VL ken(3);\n    REP(c, 0, 3) ken[c] = cur[c] * meguru[c] + hsh[c][i] % mods[c];\n    tot += kirika[ken];\n    VL tt(3);\n    REP(c, 0, 3) tt[c] = hsh[c][i];\n    kirika[tt] += 1;\n  }\n  cout << tot << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\n\nconst int mod0 = 1e9 + 7;\nconst int mod1 = 1e9 + 9;\nconst int mod2 = 1e9 + 21;\nconst int base = 10007;\n\nint64_t power(int64_t x, int64_t n, int64_t mod) {\n  int64_t ret = 1;\n  while(n > 0) {\n    if(n & 1) (ret *= x) %= mod;\n    (x *= x) %= mod;\n    n >>= 1;\n  }\n  return ret;\n}\n\n\nint64 h0[550001], g0[550001];\nint64 h1[550001], g1[550001];\nint64 h2[550001], g2[550001];\n\n\nint main() {\n\n  h0[0] = h1[0] = h2[0] = 1;\n  for(int i = 1; i < 550001; i++) {\n    h0[i] = h0[i - 1] * base % mod0;\n    h1[i] = h1[i - 1] * base % mod1;\n    h2[i] = h2[i - 1] * base % mod2;\n  }\n  g0[550000] = power(h0[550000], mod0 - 2, mod0);\n  g1[550000] = power(h1[550000], mod1 - 2, mod1);\n  g2[550000] = power(h2[550000], mod2 - 2, mod2);\n  for(int i = 549999; i >= 0; i--) {\n    g0[i] = g0[i + 1] * (i + 1) % mod0;\n    g1[i] = g1[i + 1] * (i + 1) % mod1;\n    g2[i] = g2[i + 1] * (i + 1) % mod2;\n  }\n\n  int N;\n  string S;\n\n  cin >> N;\n  cin >> S;\n\n  vector< int64 > latte0, malta0;\n  vector< int64 > latte1, malta1;\n  vector< int64 > latte2, malta2;\n  int64 beet = 0, pos = 250001;\n  latte0.push_back(pos), malta0.push_back(beet);\n  latte1.push_back(pos), malta1.push_back(beet);\n  latte2.push_back(pos), malta2.push_back(beet);\n  for(int i = 0; i < N; i++) {\n    char c = S[i];\n    if(c == '+') (beet += h0[pos]) %= mod0;\n    else if(c == '-') (beet += mod0 - h0[pos]) %= mod0;\n    else if(c == '<') --pos;\n    else ++pos;\n    latte0.push_back(pos), malta0.push_back(beet);\n  }\n  beet = 0, pos = 250001;\n  for(int i = 0; i < N; i++) {\n    char c = S[i];\n    if(c == '+') (beet += h1[pos]) %= mod1;\n    else if(c == '-') (beet += mod1 - h1[pos]) %= mod1;\n    else if(c == '<') --pos;\n    else ++pos;\n    latte1.push_back(pos), malta1.push_back(beet);\n  }\n  beet = 0, pos = 250001;\n\n  for(int i = 0; i < N; i++) {\n    char c = S[i];\n    if(c == '+') (beet += h2[pos]) %= mod2;\n    else if(c == '-') (beet += mod2 - h2[pos]) %= mod2;\n    else if(c == '<') --pos;\n    else ++pos;\n    latte2.push_back(pos), malta2.push_back(beet);\n  }\n\n\n  map< tuple< int64, int64, int64 >, int > mp;\n  int64 ret = 0;\n  for(int i = N; i >= 0; i--) {\n    int64 dx = latte0[i] - latte0[0];\n    int64 mul0, mul1, mul2;\n    if(dx >= 0) mul0 = h0[dx], mul1 = h1[dx], mul2 = h1[dx];\n    else mul0 = power(h0[-dx], mod0 - 2, mod0), mul1 = power(h1[-dx], mod1 - 2, mod1), mul2 = power(h2[-dx], mod2 - 2, mod2);\n    ret += mp[make_tuple((malta0[i] + malta0[N] * mul0) % mod0, (malta1[i] + malta1[N] * mul1) % mod1, (malta2[i] + malta2[N] * mul2) % mod2)];\n    ++mp[make_tuple(malta0[i], malta1[i], malta2[i])];\n  }\n  cout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,i;\nchar c[500005];\nunsigned long long h,s[250005],ans,t;\nmap<unsigned long long,unsigned long long> m;\nunsigned long long qpow(unsigned long long a,unsigned long long b)\n{\n\tunsigned long long ans=1;\n\twhile(b)\n\t{\n\t\tif(b&1)\n\t\t\tans=ans*a;\n\t\ta=a*a;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",c+1);\n\tunsigned long long inv=qpow(250001,9223372036854775807ull);\n\ts[0]=1;\n\tfor(i=1;i<=n;++i)\n\t{\n\t\ts[i]=s[i-1];\n\t\tif(c[i]=='<')\n\t\t\ts[i]*=inv;\n\t\tif(c[i]=='>')\n\t\t\ts[i]*=250001;\n\t}\n\tfor(i=n;i>=1;--i)\n\t{\n\t\tif(c[i]=='+')\n\t\t\t++t;\n\t\tif(c[i]=='-')\n\t\t\t--t;\n\t\tif(c[i]=='<')\n\t\t\tt=t*inv;\n\t\tif(c[i]=='>')\n\t\t\tt=t*250001;\n\t}\n\t++m[0];\n\tfor(i=n;i>=1;--i)\n\t{\n\t\tif(c[i]=='+')\n\t\t\t++h;\n\t\tif(c[i]=='-')\n\t\t\t--h;\n\t\tif(c[i]=='<')\n\t\t\th=h*inv;\n\t\tif(c[i]=='>')\n\t\t\th=h*250001;\n\t\tans+=m[(h-t)*s[i-1]];\n\t\t++m[h*s[i-1]];\n\t}\n\tcout<<ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int unsigned long long\nusing namespace std;\nint f[1001000],X,Y;\nlong long ans,n;\nchar S[1001000];\nmap<int,int>mp;\nsigned main(){\n\tscanf(\"%lld%s\",&n,S+1);\n\tX=1;\n\tint base=233,inv=7204522363551799129;\n\tfor(int i=1;i<=n;i++){\n\t\tif(S[i]=='+')f[i]=f[i-1]+X;\n\t\tif(S[i]=='-')f[i]=f[i-1]-X;\n\t\tif(S[i]=='<')f[i]=f[i-1],X=X*base;\n\t\tif(S[i]=='>')f[i]=f[i-1],X=X*inv;\n\t\tmp[f[i]]++;\t\t\n\t}\n\tX=1,Y=0;\n\tfor(int i=1;i<=n;i++){\n\t\tans=ans+mp[f[n]*X+Y];\n\t\tif(S[i]=='+')Y=Y+X;\n\t\tif(S[i]=='-')Y=Y-X;\n\t\tif(S[i]=='<')X=X*base;\n\t\tif(S[i]=='>')X=X*inv;\n\t\tmp[f[i]]--;\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define F first\n#define S second\n#define int long long\n#define ll long long\n//#define int  unsigned long long\n#define pb push_back\n//#define double long double\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef  tree< int , null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\n//const int mod = 1e9 + 7;\nconst int N = 1200000;\nvector < int > v;\nint x[N], y[N];\nint prime(int x){\n    for (int i = 2; i * i <= x; i++){\n        if (x % i == 0) return 0;\n    }\n    return 1;\n}\nint binpow(int x, int y, int mod){\n    int res = 1;\n    while(y){\n        if (y % 2) res = res * x % mod;\n        x = x * x % mod;\n        y /= 2;\n    }\n    return res;\n}\nconst int K = 2;\nconst int base = 6495109;\nmap < vector < int >, int > t;\nint p[N][K], h[N][K], invp[N][K], m[K], d[N];\nmain(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    //freopen(\"input.txt\", \"r\", stdin);\n    int n;\n    cin >> n;\n    string s;\n    cin >> s;\n    int cnt = 0;\n    int x = 1e9 + 1e8 + 6537;\n    for (int i = x; cnt < K; i++){\n        if (prime(i)){\n            m[cnt] = i;\n            cnt++;\n        }\n    }\n    for (int i = 0; i < K; i++){\n        p[0][i] = 1;\n        invp[0][i] = 1;\n        int x = binpow(base, m[i] - 2, m[i]);\n        for (int j = 1; j < N; j++){\n            p[j][i] = p[j - 1][i] * base % m[i];\n            invp[j][i] = invp[j - 1][i] * x % m[i];\n        }\n    }\n    for (int j = 0; j < K; j++){\n        int c = 0;\n        for (int i = 0; i < n; i++){\n            if (s[i] == '<'){\n                c++;\n                h[i][j] = (i != 0) * h[i - 1][j];\n            }\n            else if(s[i] == '>'){\n                c--;\n                h[i][j] = (i != 0) * h[i - 1][j];\n            }\n            else if(s[i] == '+'){\n                if (c >= 0) h[i][j] = ((i != 0) * h[i - 1][j] + p[c][j]) % m[j];\n                else h[i][j] = ((i != 0) * h[i - 1][j] + invp[-c][j]) % m[j];\n            } else{\n                if (c >= 0) h[i][j] = ((i != 0) * h[i - 1][j] - p[c][j] + m[j]) % m[j];\n                else h[i][j] = ((i != 0) * h[i - 1][j] - invp[-c][j] + m[j]) % m[j];\n            }\n            d[i] = c;\n        }\n    }\n    vector < int > q1;\n    for (int j = 0; j < K; j++){\n        q1.pb(h[n - 1][j]);\n    }\n    int ans = 0;\n    t[q1]++;\n    for (int i = 0; i < n; i++){\n        vector < int > q2;\n        for (int j = 0; j < K; j++){\n            q2.pb(h[i][j]);\n        }\n        ans += t[q2];\n        for (int j = 0; j < K; j++){\n            int y;\n            if (d[i] > 0) y = p[d[i]][j];\n            else y = invp[-d[i]][j];\n            q2[j] = (q1[j] * y + q2[j] + m[j]) % m[j];\n        }\n        t[q2]++;\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing lint = long long int;\nusing P = pair<lint, lint>;\n\nconstexpr lint MOD = 1000000007;\n\nvector<lint> X{250007, 861743};\nvector<lint> Xinv(2);\n\nint N;\nstring S;\n\n// ax+by=gcd(a, b)\ntemplate <typename T>\nT extgcd(T a, T b, T &x, T &y)\n{\n    T d = a;\n    if (b != 0)\n    {\n        d = extgcd(b, a % b, y, x);\n        y -= a / b * x;\n    }\n    else\n    {\n        x = 1;\n        y = 0;\n    }\n    return d;\n}\n\nP nxt_hash(P prev_hash, lint x, lint xinv, char c)\n{\n    P res = prev_hash;\n    if (c == '+')\n    {\n        res.first++;\n    }\n    if (c == '-')\n    {\n        res.first += MOD - 1;\n    }\n    if (c == '>')\n    {\n        res.first *= x;\n        res.second *= x;\n    }\n    if (c == '<')\n    {\n        res.first *= xinv;\n        res.second *= xinv;\n    }\n    res.first %= MOD;\n    res.second %= MOD;\n    return res;\n}\n\nint main()\n{\n    for (int i = 0; i < 2; i++)\n    {\n        lint xinv, tmp;\n        extgcd(X[i], MOD, xinv, tmp);\n        Xinv[i] = (xinv + MOD) % MOD;\n    }\n\n    cin >> N >> S;\n\n    vector<vector<P> > hash(2, vector<P>(N+1, make_pair(0LL, 1LL)));\n\n    for (unsigned ix = 0; ix < 2; ix++)\n    {\n        lint x = X[ix];\n        lint xinv = Xinv[ix];\n        for (int i = N - 1; i>=0; i--) hash[ix][i] = nxt_hash(hash[ix][i + 1], x, xinv, S[i]);\n    }\n\n    for (int ix = 0; ix < 2; ix++)\n    {\n        for (int i = 0; i <= N; i++)\n        {\n            lint invh, tmp;\n            extgcd(hash[ix][i].second, MOD, invh, tmp);\n            hash[ix][i].second = (invh + MOD) % MOD;\n        }\n    }\n\n    lint ans = 0;\n    map<P, int> hash_lst;\n    for (int m = N; m >= 0; m--)\n    {\n        P h_query;\n        h_query.first = (hash[0][m].first - hash[0][0].first + MOD) * hash[0][m].second % MOD;\n        h_query.second = (hash[1][m].first - hash[1][0].first + MOD) * hash[1][m].second % MOD;\n\n        ans += hash_lst[h_query];\n\n        P h_append;\n        h_append.first = hash[0][m].first * hash[0][m].second % MOD;\n        h_append.second = hash[1][m].first * hash[1][m].second % MOD;\n        hash_lst[h_append]++;\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author aajisaka\n */\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n#define SPEED ios_base::sync_with_stdio(false);cin.tie(nullptr)\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define all(v) v.begin(), v.end()\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing P = pair<ll, ll>;\n\nconstexpr long double PI = 3.14159265358979323846264338327950288L;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nconstexpr ll mod17 = 1e9+7;\nconstexpr ll mod19 = 1e9+9;\nconstexpr ll mod9 = 998244353;\nll mod = mod17;\n\n// Mod int libraries\ntemplate<typename T>\nT mod_pow(T a, ll x) {\n  T res = 1;\n  while(x > 0) {\n    if (x & 1) res *= a;\n    a *= a; x >>= 1;\n  }\n  return res;\n}\n\n// Mint32\nunordered_map<ll, ll> minvmap;\nll minv(ll a, ll m) {\n  auto k = a; auto p = minvmap[a]; if (p != 0) return p;\n  ll b = m, u = 1, v = 0;\n  while (b) { ll t = a/b; swap(a -= t*b, b); swap(u -= t*v, v); }\n  p = (u%m+m)%m; minvmap[k] = p; return p;\n}\n\nstruct mint {\n  ll x;\n  mint():x(0){}\n  mint(ll x):x((x%mod+mod)%mod){}\n  mint& fix() { x = (x%mod+mod)%mod; return *this;}\n  mint operator-() const { return mint(0) - *this;}\n  mint& operator+=(const mint& a){ if((x+=a.x)>=mod) x-=mod; return *this;}\n  mint& operator-=(const mint& a){ if((x+=mod-a.x)>=mod) x-=mod; return *this;}\n  mint& operator*=(const mint& a){ (x*=a.x)%=mod; return *this;}\n  mint& operator/=(const mint& a){ (x*=minv(a.x, mod))%=mod; return *this; }\n  mint operator+(const mint& a)const{ return mint(*this) += a;}\n  mint operator-(const mint& a)const{ return mint(*this) -= a;}\n  mint operator*(const mint& a)const{ return mint(*this) *= a;}\n  mint operator/(const mint& a)const{ return mint(*this) /= a;}\n  bool operator<(const mint& a)const{ return x < a.x;}\n  bool operator==(const mint& a)const{ return x == a.x;}\n};\n\n// Mint64\nstruct mint64 {\n    ull x;\n    static ull mod, inv, r2;\n    mint64(): x(0){}\n    mint64(ull x): x(init(x)) {}\n    static ull init(ull x) { return reduce(__uint128_t(x)*r2);}\n    static void set_mod(ull m) {\n      mod = inv = m;\n      for(int i=0; i<5; i++) inv *= 2 - inv*m;\n      r2 = -__uint128_t(m)%m;\n    }\n    static ull reduce(__uint128_t x) {\n      ull y = ull(x >> 64) - ull((__uint128_t(ull(x)*inv)*mod)>>64);\n      return ll(y) < 0 ? y+mod : y;\n    }\n    mint64& operator+=(mint64& a) { x+=a.x-mod; if(ll(x)<0) x+=mod; return *this; }\n    mint64 operator+(mint64& a) const{ return mint64(*this)+=a; }\n    mint64& operator*=(mint64& a) { x=reduce(__uint128_t(x)*a.x); return *this; }\n    mint64 operator*(mint64& a) const { return mint64(*this)*=a; }\n};\n\null mint64::mod, mint64::inv, mint64::r2;\n\n// Verify: https://yukicoder.me/submissions/472580\nstruct Miller {\n    const vector<ull> v = {2, 325, 9375, 28178, 450775, 9780504, 1795265022};\n    bool suspect(ull a, ull s, ull d, ull n) {\n      if (mint64::mod != n) mint64::set_mod(n);\n      mint64 one = 1, minusone = n-1, ma = a;\n      auto x = mod_pow(ma, d);\n      if (x.x == one.x) return true;\n      for(int r = 0; r < s; r++) {\n        if (x.x == minusone.x) return true;\n        x = x * x;\n      }\n      return false;\n    }\n\n    // check if n is prime\n    bool check(ull n) {\n      if (n < 2 || (n > 2 && n % 2 == 0)) return false;\n      ull d = n - 1;\n      ull s = 0;\n      while (!(d & 1)) {\n        d >>= 1;\n        s++;\n      }\n      for (auto a: v) {\n        if (a >= n) break;\n        if (!suspect(a, s, d, n)) return false;\n      }\n      return true;\n    }\n};\n\nclass combination {\n    // factorial\n    public: std::vector<mint> fact;\n    public: std::vector<mint> inv;\n\n    combination(int n) {\n      fact.resize(n + 1);\n      inv.resize(n + 1);\n      fact[0] = 1;\n      for (int i = 1; i <= n; i++) {\n        fact[i] = fact[i - 1] * i;\n      }\n      inv[n] = mint(1) / fact[n];\n      for (int i = n - 1; i >= 0; i--) {\n        inv[i] = inv[i + 1] * (i + 1);\n      }\n    }\n\n    // nCr\n    public: mint get(int n, int r) {\n      if (n < r || n < 0 || r < 0) return 0;\n      return fact[n]*inv[r]*inv[n-r];\n    }\n    // nPr\n    public: mint p(int n, int r) {\n      if (n < r || n < 0) return 0;\n      return fact[n]*inv[n-r];\n    }\n};\n\n\nclass FEatingSymbolsHard {\npublic:\n    void solve(istream& cin, ostream& cout) {\n      SPEED;\n      int n; cin >> n;\n      string s; cin >> s;\n      vector<mint> base = {11, 13, 17, 1007, 1009};\n      vector<mint> invBase(5);\n      rep(i, 5) {\n        invBase[i] = mint(1)/base[i];\n      }\n      vector<int> pos(n+1);\n      vector<vector<mint>> vec(5, vector<mint>(n+1));\n\n      rep(i, n) {\n        pos[i+1] = pos[i];\n        rep(k, 5) {\n          vec[k][i+1] = vec[k][i];\n        }\n        if (s[i] == '+') {\n          rep(k, 5) {\n            if (pos[i] < 0) {\n              vec[k][i+1] += mod_pow(invBase[k], -pos[i]);\n            } else {\n              vec[k][i+1] += mod_pow(base[k], pos[i]);\n            }\n          }\n        } else if (s[i] == '-') {\n          rep(k, 5) {\n            if (pos[i] < 0) {\n              vec[k][i+1] -= mod_pow(invBase[k], -pos[i]);\n            } else {\n              vec[k][i+1] -= mod_pow(base[k], pos[i]);\n            }\n          }\n        } else if (s[i] == '<') {\n          pos[i+1]--;\n        } else {\n          pos[i+1]++;\n        }\n      }\n\n      map<mint, ll> mp[5];\n      ll ans = 0;\n      for(int i=n; i>=0; i--) {\n        map<int, int> cnt;\n        rep(k, 5) {\n          mint r;\n          if (pos[i] < 0) {\n            r = mod_pow(invBase[k], -pos[i]);\n          } else {\n            r = mod_pow(base[k], pos[i]);\n          }\n          auto q = vec[k][i] + vec[k][n] * r;\n          if (mp[k].find(q) == mp[k].end()) {\n            cnt[0]++;\n          } else {\n            cnt[mp[k][q]]++;\n          }\n        }\n        bool flag = false;\n        for(auto e: cnt) {\n          if (e.second >= 3) {\n            ans += e.first;\n            flag = true;\n          }\n        }\n        assert(flag);\n        rep(k, 5) {\n          mp[k][vec[k][i]]++;\n        }\n      }\n\n      cout << ans << endl;\n\n    }\n};\n\nsigned main() {\n  FEatingSymbolsHard solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef unsigned long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nll mod, modInv;\nll pw(ll n, ll m){\n\tll res = 1;\n\tfor(; m; m /= 2){\n\t\tif(m & 1) res = res * n;\n\t\tn = n * n;\n\t}\n\treturn res;\n}\nll h_[510000], *h = h_ + 255000;\n\nvoid init(int n, ll mod_){\n\tmod = mod_;\n\tmodInv = pw(mod, -1);\n\th[0] = 1;\n\tll x = 1, y = 1;\n\tfor(int i = 1; i <= n; i++){\n\t\tx *= mod;\n\t\ty *= modInv;\n\t\th[i] = x;\n\t\th[-i] = y;\n\t}\n}\n\nll solve(int n, const string &s, ll mod){\n\tinit(n, mod);\n\tint p = 0;\n\tll hash = 0;\n\tfor(char c : s){\n\t\tif(c == '<') p--;\n\t\tif(c == '>') p++;\n\t\tif(c == '+') hash += h[p];\n\t\tif(c == '-') hash -= h[p];\n\t}\n\t\n\tint p2 = p;\n\tll h2 = 0;\n\tmap<ll, vi> pos;\n\tfor(int i = n; i >= 0; i--){\n\t\tif(i < n){\n\t\t\tchar c = s[i];\n\t\t\tif(c == '<') p2++;\n\t\t\tif(c == '>') p2--;\n\t\t\tif(c == '+') h2 -= h[p2];\n\t\t\tif(c == '-') h2 += h[p2];\n\t\t}\n\t\tpos[h2].pb(i);\n\t}\n\tfor(auto &i: pos) reverse(all(i.second));\n\t\n\tint p3 = p;\n\tll h3 = hash, ans = 0;\n\trep(i, n){\n\t\tll diff = (hash - h3) * h[p - p3];\n\t\tif(pos.count(diff)) ans += pos[diff].end() - upper_bound(all(pos[diff]), i);\n\t\t\n\t\tchar c = s[i];\n\t\tif(c == '<') p3++, h3 *= mod;\n\t\tif(c == '>') p3--, h3 *= modInv;\n\t\tif(c == '+') h3--;\n\t\tif(c == '-') h3++;\n\t}\n\treturn ans;\n}\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\t\n\tint n; string s; cin >> n >> s;\n\tmap<ll,int> ans;\n\tvector<ll> mods;\n\tfor(ll p = 1e9 + 1; mods.size() < 5; p += 2){\n\t\tfor(ll i = 3; i * i <= p; i += 2) if(p % i == 0) goto NG;\n\t\tmods.pb(p); NG:;\n\t}\n\tfor(ll mod : mods) ++ans[solve(n, s, mod)];\n\t\n\tint mxc = 0; ll res = 0;\n\tfor(auto i : ans) if(i.second > mxc) mxc = i.second, res = i.first;\n\tcout << res << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <deque>\n#include <iomanip>\n#include <cstdio>\n#include <stack>\n#include <bitset>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(ll)(n);++i)\n\nlong long ruijo(long long  k,long long m, ll mod){\n\tif(m==0)return 1;\n\tif(m==1)return k%mod;\n\tlong long s = ruijo(k,m/2,mod);\n\tif(m%2==0){\n\t\treturn (s*s)%mod;\n\t}else{\n\t\tlong long ans;\n\t\tans = (s*s)%mod;\n\t\treturn (k*ans)%mod;\n\t}\n}\n\n\nint main(){\n    map<pair<ll,ll>,vector<ll> >mp;\n    ll n;\n    cin >> n;\n    string s;\n    cin >> s;\n    ll b[2]={4731,238973};\n    ll m[2]={inf,998244353};\n    ll inv[2]={ruijo(b[0],m[0]-2,m[0]),ruijo(b[1],m[1]-2,m[1])};\n    ll x[2]={};\n    ll q[2]={1,1};\n    rep(i,n){\n        rep(j,2){\n            if(s[i]=='+'){\n                x[j] += q[j];\n                x[j] %= m[j];\n            }else if(s[i]=='-'){\n                x[j] += (m[j]-q[j]);\n                x[j] %= m[j];\n            }else if(s[i]=='>'){\n                q[j] *=b[j];\n                q[j] %=m[j];\n            }else{\n                q[j] *=inv[j];\n                q[j] %=m[j];\n            }\n        }\n        // cerr << x[0] << \" \" << x[1] << endl;\n        mp[MP(x[0],x[1])].push_back(i);\n    }\n    ll ans = 0;\n    ans += mp[MP(x[0],x[1])].size();\n    //cerr << ans << endl;\n    q[0] =1;\n    q[1] =1;\n    ll c[2]={0,0};\n    ll d[2]={1,1};\n    rep(i,n){\n        rep(j,2){\n            if(s[i]=='+'){\n                c[j] += d[j];\n                c[j] %= m[j];\n            }else if(s[i]=='-'){\n                c[j] += (m[j]-d[j]);\n                c[j] %= m[j];\n            }else if(s[i]=='>'){\n                d[j] *=b[j];\n                d[j] %=m[j];\n            }else{\n                d[j] *=inv[j];\n                d[j] %=m[j];\n            }\n        }\n        ll aaa = (x[0]*d[0]+c[0])%m[0];\n        ll bbb = (x[1]*d[1]+c[1])%m[1];\n        //cerr << aaa << \" \" << bbb << endl;\n        if(mp.find(MP(aaa,bbb))!=mp.end()){\n            auto z = mp[MP(aaa,bbb)];\n            ll cnt = z.end()-upper_bound(z.begin(),z.end(),i);\n            ans += cnt;\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long lint;\n\nlint modpow(lint x, lint y, lint mod) {\n  lint ret = 1 % mod, x2p = x;\n  while (y > 0) {\n    if (y % 2) ret = (__int128)ret * x2p % mod;\n    y /= 2;\n    x2p = (__int128)x2p * x2p % mod;\n  }\n  return ret;\n}\nconstexpr int nmods = 1;\nconstexpr lint mod[] = {1008176417};\nconstexpr lint base[] = {549817};\nlint inv_base[nmods];\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  string seq(n, ' ');\n  for (int i = 0; i < n; ++i)\n    scanf(\" %c\", &seq[i]);\n\n  vector<int> pos_before(n);\n\n  vector<vector<lint>> base_pow(nmods, vector<lint>(n + 1));\n  vector<vector<lint>> inv_base_pow(nmods, vector<lint>(n + 1));\n  vector<vector<lint>> hash_diff(nmods, vector<lint>(n, 0));\n  vector<vector<lint>> suffix(nmods, vector<lint>(n + 1));\n  vector<lint> full_seq_hash(nmods);\n  for (int k = 0; k < nmods; ++k) {\n    base_pow[k][0] = 1;\n    for (int i = 1; i <= n; ++i)\n      base_pow[k][i] = (__int128)base[k] * base_pow[k][i - 1] % mod[k];\n\n    inv_base[k] = modpow(base[k], mod[k] - 2, mod[k]);\n    assert((__int128)base[k] * inv_base[k] % mod[k] == 1);\n\n    inv_base_pow[k][0] = 1;\n    for (int i = 1; i <= n; ++i)\n      inv_base_pow[k][i] = (__int128)inv_base[k] * inv_base_pow[k][i - 1] % mod[k];\n\n    int pos = 0;\n    for (int i = 0; i < n; ++i) {\n      pos_before[i] = pos;\n      if (seq[i] == '>') ++pos;\n      else if (seq[i] == '<') --pos;\n      else {\n        lint base_pow_pos;\n        if (pos >= 0) base_pow_pos = base_pow[k][pos];\n        else base_pow_pos = inv_base_pow[k][-pos];\n        if (seq[i] == '+') hash_diff[k][i] = base_pow_pos;\n        else if (seq[i] == '-') {\n          hash_diff[k][i] = mod[k] - base_pow_pos;\n          assert(0 <= hash_diff[k][i]);\n          assert(hash_diff[k][i] < mod[k]);\n        } else assert(0);\n      }\n    }\n    full_seq_hash[k] = 0;\n    for (int i = 0; i < n; ++i) {\n      full_seq_hash[k] += hash_diff[k][i];\n      if (full_seq_hash[k] >= mod[k]) full_seq_hash[k] -= mod[k];\n    }\n\n    suffix[k][n] = 0;\n    for (int i = n - 1; i >= 0; --i) {\n      suffix[k][i] = hash_diff[k][i] + suffix[k][i + 1];\n      if (suffix[k][i] >= mod[k]) suffix[k][i] -= mod[k];\n    }\n  }\n\n  lint result = 0;\n  map<vector<lint>, int> count;\n  count[vector<lint>(nmods, 0LL)] += 1;\n  for (int i = n - 1; i >= 0; --i) {\n    vector<lint> shifted_full(nmods);\n    for (int k = 0; k < nmods; ++k) {\n      if (pos_before[i] >= 0) {\n        shifted_full[k] = (__int128)full_seq_hash[k] * base_pow[k][pos_before[i]] % mod[k];\n      } else {\n        shifted_full[k] = (__int128)full_seq_hash[k] * inv_base_pow[k][-pos_before[i]] % mod[k];\n      }\n    }\n\n    vector<lint> target(nmods);\n    for (int k = 0; k < nmods; ++k) {\n      target[k] = suffix[k][i] - shifted_full[k];\n      if (target[k] < 0) target[k] += mod[k];\n    }\n\n    auto it = count.find(target);\n    if (it != count.end())\n      result += it->second;\n\n    vector<lint> suffix_vec(nmods);\n    for (int k = 0; k < nmods; ++k)\n      suffix_vec[k] = suffix[k][i];\n\n    count[suffix_vec] += 1;\n  }\n  printf(\"%lld\\n\", result);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n* C++11 code template for contests.\n* @author: Andrei Kalendarov\n* @e-mail: andreykalendarov@gmail.com\n*/\n\n//#define ANDREIKKAA_ALLOCATOR\nconst int _ML = 228;\n\nconst char _inpf[] =\n#if defined(ANDREIKKAA)\n    \"input.txt\"\n#else\n    \"\"\n#endif\n;\nconst char _outf[] =\n#if defined(ANDREIKKAA)\n    \"\"\n#else\n    \"\"\n#endif\n;\n\n#if defined(ANDREIKKAA)\n#undef NDEBUG\n#else\n#pragma GCC optimize(\"O3,no-stack-protector\")\n#endif\n#include <bits/stdc++.h>\n#if !defined(ANDREIKKAA)\n#define endl '\\n'\n#endif\n#define x first\n#define y second\nusing namespace std;\n#define rand abcdefghijklmnopqrstuvwxyz\n#define random_shuffle abcdefghijklmnopqrstuvwxyz\n#define all(x) (x).begin(), (x).end()\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef double ld;\nconst ld PI = 3.14159265358979323846;\nmt19937 rd(228);\n#if defined(ANDREIKKAA_ALLOCATOR)\nchar _mem[_ML * 1024 * 1024];\nsize_t _ptr = 0;\ninline void* operator new (size_t _x) { _ptr += _x; assert(_ptr < _ML * 1024 * 1024); return _mem + _ptr - _x; }\ninline void operator delete (void*) { }\n#endif\ntemplate<class T, class U> inline ostream &operator<< (ostream &, const pair<T, U> &);\ntemplate<class T, class U> inline istream &operator>> (istream &, pair<T, U> &);\ntemplate<class T> inline ostream &operator<< (ostream &, const vector<T> &);\ntemplate<class T> inline istream &operator>> (istream &, vector<T> &);\ntemplate<class T> inline ostream &operator<< (ostream &, const set<T> &);\ntemplate<class T> inline ostream &operator<< (ostream &, const multiset<T> &);\ntemplate<class T> inline ostream &operator<< (ostream &, const unordered_set<T> &);\ntemplate<class T> inline ostream &operator<< (ostream &, const unordered_multiset<T> &);\ntemplate<class T, class U> inline ostream &operator<< (ostream &, const map<T, U> &);\ntemplate<class T, class U> inline ostream &operator<< (ostream &, const unordered_map<T, U> &);\n\n/* ________ CODE ________ */\nconst int X = 229;\n\nstruct hasher {\n    vector<int> pw;\n    int M;\n    int val;\n\n    int add(int a, int b) {\n        return (a + b) % M;\n    }\n\n    int sub(int a, int b) {\n        return (a - b + M) % M;\n    }\n\n    int mul(int a, int b) {\n        return (int)(((ll)a * b) % M);\n    }\n\n    int bp(int a, int b) {\n        int r = 1;\n        while(b) {\n            if(b & 1) {\n                r = mul(r, a);\n            }\n            a = mul(a, a);\n            b >>= 1;\n        }\n        return r;\n    }\n\n    int div(int a, int b) {\n        return mul(a, bp(b, M - 2));\n    }\n\n    hasher(int p, int m, int n) : M(m), val(0) {\n        pw.resize(n);\n        pw[0] = 1;\n        for(int i = 1; i < n; ++i) {\n            pw[i] = (int)((ll)pw[i - 1] * p % m);\n        }\n    }\n\n    void ins(int p, int x) {\n        val = add(val, mul(pw[p], x));\n    }\n\n    void ers(int p, int x) {\n        val = sub(val, mul(pw[p], x));\n    }\n};\n\ninline void _main_function()\n{\n    int n;\n    cin >> n;\n\n    string s;\n    cin >> s;\n\n    vector<int> a(2 * n + 1);\n    int p = n;\n\n    hasher h(1000 * 1000 + 3, 1000 * 1000 * 1000 + 7, sz(a));\n    vector<int> ans = {0};\n\n    for(int i = 0; i < n; ++i) {\n        if(s[i] == '<') {\n            --p;\n        } else if(s[i] == '>') {\n            ++p;\n        } else {\n            h.ers(p, a[p]);\n            if(s[i] == '+') {\n                ++a[p];\n            } else if(s[i] == '-') {\n                --a[p];\n            } else {\n                assert(false);\n            }\n            h.ins(p, a[p]);\n        }\n\n        ans.push_back(h.val);\n    }\n\n    ll sum = 0;\n    map<int, int> cnt;\n    ++cnt[ans.back()];\n    int sh = 0;\n\n    for(int i = 1; i <= n; ++i) {\n        sum += cnt[ans[i]];\n\n        if(s[i - 1] == '>') {\n            ++sh;\n        } else if(s[i - 1] == '<') {\n            --sh;\n        }\n\n        if(sh >= 0) {\n            int x = h.add(h.mul(h.pw[sh], ans.back()), ans[i]);\n            ++cnt[x];\n        } else {\n            int x = h.div(h.add(h.pw[-sh], ans.back()), ans[i]);\n            ++cnt[x];\n        }\n    }\n\n    cout << sum << endl;\n}\n\n/* ________ CODE ________ */\n\nint main()\n{\n#if defined(ANDREIKKAA)\n    time_t _start = clock();\n#endif\n    if (_inpf[0] != '\\0') assert(freopen(_inpf, \"r\", stdin) != nullptr);\n    if (_outf[0] != '\\0') assert(freopen(_outf, \"w\", stdout) != nullptr);\n    cin.tie(nullptr);\n    ios_base::sync_with_stdio(false);\n\n    cout << setprecision(20);\n    //cout << fixed;\n\n    _main_function();\n#if defined(ANDREIKKAA)\n    cout << \"Time: \" << (clock() - _start) / (ld)CLOCKS_PER_SEC << endl;\n#endif\n}\n\ntemplate<class T, class U> inline ostream &operator<< (ostream &_out, const pair<T, U> &_p)\n{\n    _out << _p.x << ' ' << _p.y;\n    return _out;\n}\ntemplate<class T, class U> inline istream &operator>> (istream &_in, pair<T, U> &_p)\n{\n    _in >> _p.x >> _p.y;\n    return _in;\n}\ntemplate<class T> inline ostream &operator<< (ostream &_out, const vector<T> &_v)\n{\n    if (_v.empty()) { return _out; }\n    _out << *_v.begin();\n    for (auto _it = ++_v.begin(); _it != _v.end(); ++_it) { _out << ' ' << *_it; }\n    return _out;\n}\ntemplate<class T> inline istream &operator>> (istream &_in, vector<T> &_v)\n{\n    for (auto &_i : _v) { _in >> _i; }\n    return _in;\n}\ntemplate<class T> inline ostream &operator<< (ostream &_out, const set<T> &_s)\n{\n    if (_s.empty()) { return _out; }\n    _out << *_s.begin();\n    for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; }\n    return _out;\n}\ntemplate<class T> inline ostream &operator<< (ostream &_out, const multiset<T> &_s)\n{\n    if (_s.empty()) { return _out; }\n    _out << *_s.begin();\n    for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; }\n    return _out;\n}\ntemplate<class T> inline ostream &operator<< (ostream &_out, const unordered_set<T> &_s)\n{\n    if (_s.empty()) { return _out; }\n    _out << *_s.begin();\n    for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; }\n    return _out;\n}\ntemplate<class T> inline ostream &operator<< (ostream &_out, const unordered_multiset<T> &_s)\n{\n    if (_s.empty()) { return _out; }\n    _out << *_s.begin();\n    for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; }\n    return _out;\n}\ntemplate<class T, class U> inline ostream &operator<< (ostream &_out, const map<T, U> &_m)\n{\n    if (_m.empty()) { return _out; }\n    _out << '(' << _m.begin()->x << \": \" << _m.begin()->y << ')';\n    for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) { _out << \", (\" << _it->x << \": \" << _it->y << ')'; }\n    return _out;\n}\ntemplate<class T, class U> inline ostream &operator<< (ostream &_out, const unordered_map<T, U> &_m)\n{\n    if (_m.empty()) { return _out; }\n    _out << '(' << _m.begin()->x << \": \" << _m.begin()->y << ')';\n    for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) { _out << \", (\" << _it->x << \": \" << _it->y << ')'; }\n    return _out;\n}\n"
  },
  {
    "language": "C++",
    "code": "48\n-+><<><><><>>>+-<<>->>><<><<-+<>><+<<>+><-+->><<"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<map>\nusing namespace std;\nstruct node{long long g1,g2,g3,g4,g5,g6;int p;};\nconst int p1=1000000007,p2=1000000009;\nlong long x1p1[510000],x1p2[510000],x2p1[510000],x2p2[510000],x3p1[510000],x3p2[510000];\ninline node operator+(node x,node y){return {(x.g1+y.g1*x1p1[x.p+250000])%p1,(x.g2+y.g2*x1p2[x.p+250000])%p2,(x.g3+y.g3*x2p1[x.p+250000])%p1,(x.g4+y.g4*x2p2[x.p+250000])%p2,(x.g5+y.g5*x3p1[x.p+250000])%p1,(x.g6+y.g6*x3p2[x.p+250000])%p2,x.p+y.p};}\nchar s[260000];\nmap<long long,map<long long,map<long long,map<long long,map<long long,map<long long,int>>>>>> M;\nint main()\n{\n\tx1p1[249999]=500000004;x1p1[250000]=1;x1p1[250001]=2;\n\tx1p2[249999]=500000005;x1p2[250000]=1;x1p2[250001]=2;\n\tx2p1[249999]=666666671;x2p1[250000]=1;x2p1[250001]=3;\n\tx2p2[249999]=333333336;x2p2[250000]=1;x2p2[250001]=3;\n\tx3p1[249999]=600000004;x3p1[250000]=1;x3p1[250001]=5;\n\tx3p2[249999]=800000007;x3p2[250000]=1;x3p2[250001]=5;\n\tfor(int i=249998;i>=0;i--)x1p1[i]=x1p1[i+1]*x1p1[249999]%p1,x1p2[i]=x1p2[i+1]*x1p2[249999]%p2,x2p1[i]=x2p1[i+1]*x2p1[249999]%p1,x2p2[i]=x2p2[i+1]*x2p2[249999]%p2,x3p1[i]=x3p1[i+1]*x3p1[249999]%p1,x3p2[i]=x3p2[i+1]*x3p2[249999]%p2;\n\tfor(int i=250002;i<=500000;i++)x1p1[i]=x1p1[i-1]*x1p1[250001]%p1,x1p2[i]=x1p2[i-1]*x1p2[250001]%p2,x2p1[i]=x2p1[i-1]*x2p1[250001]%p1,x2p2[i]=x2p2[i-1]*x2p2[250001]%p2,x3p1[i]=x3p1[i-1]*x3p1[250001]%p1,x3p2[i]=x3p2[i-1]*x3p2[250001]%p2;\n\tint n;scanf(\"%d%s\",&n,s+1);\n\tnode gs={0,0,0,0,0,0,0},pr={0,0,0,0,0,0,0};\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(s[i]=='+')gs.g1=(gs.g1+x1p1[gs.p+250000])%p1,gs.g2=(gs.g2+x1p2[gs.p+250000])%p2,gs.g3=(gs.g3+x2p1[gs.p+250000])%p1,gs.g4=(gs.g4+x2p2[gs.p+250000])%p2,gs.g5=(gs.g5+x3p1[gs.p+250000])%p1,gs.g6=(gs.g6+x3p2[gs.p+250000])%p2;\n\t\telse if(s[i]=='-')gs.g1=(gs.g1-x1p1[gs.p+250000]+p1)%p1,gs.g2=(gs.g2-x1p2[gs.p+250000]+p2)%p2,gs.g3=(gs.g3-x2p1[gs.p+250000]+p1)%p1,gs.g4=(gs.g4-x2p2[gs.p+250000]+p2)%p2,gs.g5=(gs.g5-x3p1[gs.p+250000]+p1)%p1,gs.g6=(gs.g6-x3p2[gs.p+250000]+p2)%p2;\n\t\telse if(s[i]=='>')gs.p++;\n\t\telse gs.p--;\n\t}\n\tlong long ss=0;\n\tnode rg=pr+gs;\n\tM[rg.g1][rg.g2][rg.g3][rg.g4][rg.g5][rg.g6]++;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(s[i]=='+')pr.g1=(pr.g1+x1p1[pr.p+250000])%p1,pr.g2=(pr.g2+x1p2[pr.p+250000])%p2,pr.g3=(pr.g3+x2p1[pr.p+250000])%p1,pr.g4=(pr.g4+x2p2[pr.p+250000])%p2,pr.g5=(pr.g5+x3p1[pr.p+250000])%p1,pr.g6=(pr.g6+x3p2[pr.p+250000])%p2;\n\t\telse if(s[i]=='-')pr.g1=(pr.g1-x1p1[pr.p+250000]+p1)%p1,pr.g2=(pr.g2-x1p2[pr.p+250000]+p2)%p2,pr.g3=(pr.g3-x2p1[pr.p+250000]+p1)%p1,pr.g4=(pr.g4-x2p2[pr.p+250000]+p2)%p2,pr.g5=(pr.g5-x3p1[pr.p+250000]+p1)%p1,pr.g6=(pr.g6-x3p2[pr.p+250000]+p2)%p2;\n\t\telse if(s[i]=='>')pr.p++;\n\t\telse pr.p--;\n\t\tss=ss+M[pr.g1][pr.g2][pr.g3][pr.g4][pr.g5][pr.g6];\n\t\trg=pr+gs;\n\t\tM[rg.g1][rg.g2][rg.g3][rg.g4][rg.g5][rg.g6]++;\n\t}\n\tprintf(\"%lld\\n\",ss);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\n#include <unordered_map>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\ntypedef __int128 bi;\nconst bi MOD=1000000000000000003LL;\nbi qp(bi a,bi b)\n{\n\tbi x=1; a%=MOD;\n\twhile(b)\n\t{\n\t\tif(b&1) x=x*a%MOD;\n\t\ta=a*a%MOD; b>>=1;\n\t}\n\treturn x;\n}\nconst bi g=233,rg=qp(g,MOD-2);\npair<bi,bi> operator +\n(pair<bi,bi> a,pair<bi,bi> b)\n{return mp((a.fi+a.se*b.fi)%MOD,a.se*b.se%MOD);}\n#define SZ 666666\nint n; char str[SZ];\npair<bi,bi> sg[SZ],tg(0,1),qz[SZ];\nll ans=0;\nint main()\n{\n\tscanf(\"%d%s\",&n,str+1);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tif(str[i]=='+') sg[i]=mp(1,1);\n\t\telse if(str[i]=='-') sg[i]=mp(MOD-1,1);\n\t\telse if(str[i]=='>') sg[i]=mp(0,g);\n\t\telse sg[i]=mp(0,rg); tg=tg+sg[i];\n\t}\n\tqz[0]=mp(0,1);\n\tfor(int i=1;i<=n;++i) qz[i]=qz[i-1]+sg[i];\n\tmap<ll,int> ms;\n\tfor(int i=n;i>=0;--i)\n\t{ \n\t\t//A.fi+tg.fi*A.se=C.fi\n\t\tans+=ms[(qz[i].fi+tg.fi*qz[i].se)%MOD];\n\t\t++ms[qz[i].fi];\n\t}\n\tcout<<ans<<\"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcountll\n\n#define INF 1e16\n#define mod 1000000007\n\nll mod_pow(ll a,ll n){\n  ll res=1;\n  while(n>0){\n    if(n&1)res=res*a%mod;\n    a=a*a%mod;\n    n>>=1;\n  }\n  return res;\n}\n\nll N;\nstring S;\nconst ll K=6;\nll A[6][250010],B[6][250010];\nvector<ll> C[250010];\nmap<vector<ll>,ll> cnt;\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  vector<ll> xs{452,8112,5734,56343,8766754,64537};\n\n  cin>>N>>S;\n  ll res=0;\n  rep(k,K)A[k][N]=1;\n  rep(k,K)C[N].push_back(0);\n  for(ll j=N-1;j>=0;j--){\n    rep(i,K){\n      if(S[j]=='+'){\n        A[i][j]=A[i][j+1];\n        B[i][j]=(B[i][j+1]+1)%mod;\n      }else if(S[j]=='-'){\n        A[i][j]=A[i][j+1];\n        B[i][j]=(B[i][j+1]+mod-1)%mod;\n      }else if(S[j]=='>'){\n        A[i][j]=A[i][j+1]*mod_pow(xs[i],mod-2)%mod;\n        B[i][j]=B[i][j+1]*mod_pow(xs[i],mod-2)%mod;\n      }else if(S[j]=='<'){\n        A[i][j]=A[i][j+1]*xs[i]%mod;\n        B[i][j]=B[i][j+1]*xs[i]%mod;\n      }\n      C[j].push_back(B[i][j]*mod_pow(A[i][j],mod-2)%mod);\n    }\n  }\n\n  for(ll i=N;i>=0;i--){\n    vector<ll> nc;\n    rep(k,K){\n      nc.push_back(((B[k][i]-B[k][0]+mod)%mod)*mod_pow(A[k][i],mod-2)%mod);\n    }\n\n    res+=cnt[nc];\n    cnt[C[i]]++;\n  }\n\n  cout<<res<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,st,ed) for(register int i=st,i##end=ed;i<=i##end;++i)\n#define DREP(i,st,ed) for(register int i=st,i##end=ed;i>=i##end;--i)\ntypedef long long ll;\ntemplate<typename T>inline bool chkmin(T &x,T y){return (y<x)?(x=y,1):0;}\ntemplate<typename T>inline bool chkmax(T &x,T y){return (y>x)?(x=y,1):0;}\ninline int read(){\n\tint x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1)+(x<<3)+(c^'0');\n\treturn x*f;\n}\ninline ll readll(){\n\tll x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1ll)+(x<<3ll)+(c^'0');\n\treturn x*f;\n}\ntypedef unsigned long long ull;\nconst int maxn=250000+10;\nunordered_map<ull,int> mp;\nchar s[maxn];\null Pw[maxn<<1],sum[maxn];\nint p[maxn];\nint main(){\n\tint n=read();\n\tPw[0]=1;\n\tREP(i,1,maxn*2-10) Pw[i]=Pw[i-1]*101;\n\tscanf(\"%s\",s+1);\n\tp[0]=n+5;\n\tREP(i,1,n){\n\t\tsum[i]=sum[i-1],p[i]=p[i-1];\n\t\tif(s[i]=='>') ++p[i];\n\t\tif(s[i]=='<') --p[i];\n\t\tif(s[i]=='+') sum[i]+=Pw[p[i]];\n\t\tif(s[i]=='-') sum[i]-=Pw[p[i]];\n\t}\n\tll ans=0;\n\tREP(i,0,n){\n\t\tull val=sum[n]*Pw[p[i]]+sum[i]*Pw[n+5];\n\t\tans+=mp[sum[i]*Pw[n+5]];\n\t\tmp[val]++;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 250001,M = 1e9 + 7,b = 1007;\nint cs[N],p[N],n;\nmap<int,int>mp;\nvoid add(int &a,int b){\n\ta+=b;\n\tif(a >= M)a-=M;\n\tif(a < 0)a+=M;\n}\nint power(int base,int to){\n\tint ret = 1;\n\twhile(to){\n\t\tif(to&1)ret = ret*1LL*base%M;\n\t\tto>>=1;\n\t\tbase = base*1LL*base%M;\n\t}\n\treturn ret;\n}\nint main(){\n\t//freopen(\"readin.txt\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tp[0] = 1;\n\tchar c;\n\tint inv = power(b,M - 2);\n\tfor(int i = 1;i <= n;i++){\n\t\tscanf(\" %c\",&c);\n\t\tcs[i] = cs[i - 1];\n\t\tp[i] = p[i - 1];\n\t\tif(c == '+')add(cs[i],p[i]);\n\t\telse if(c == '-')add(cs[i],-p[i]);\n\t\telse if(c == '>')p[i] = p[i]*1LL*b%M;\n\t\telse if(c == '<')p[i] = p[i]*1LL*inv%M;\n\t}\n\tlong long ans = 0;\n\tfor(int i = 0;i <= n;i++){\n\t\tans+=mp[cs[i]];\n\t\tmp[(cs[n]*1LL*p[i] + cs[i] + M)%M]++;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <cmath>\n#include <cstdio>\n#include <cctype>\n#include <ctime>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <complex>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cwchar>\n#include <cwctype>\n#include <exception>\n#include <locale>\n#include <numeric>\n#include <new>\n#include <stdexcept>\n#include <limits>\n#include <valarray>\n#include <set>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <list>\n#include <utility>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int INF = 1e9 + 7;\n\nconst pair<LL, LL> HMOD = MP(998244353, 1004535809), HRAD = MP(243, 19683), HIRAD = MP(607984215, 858522653);\nmap<pair<LL, LL>, int> S;\nint n;\nchar ch[250005];\n\nint main()\n{\n\tscanf(\"%d%s\", &n, &ch);\n\tpair<LL, LL> cur = MP(1, 1), cnt = MP(0, 0);\n\trep(i, n) {\n\t\tif(ch[i] == '+') cnt.first = (cnt.first + cur.first) % HMOD.first;\n\t\tif(ch[i] == '-') cnt.first = (cnt.first - cur.first + HMOD.first) % HMOD.first;\n\t\tif(ch[i] == '<') cur.first = cur.first * HIRAD.first % HMOD.first;\n\t\tif(ch[i] == '>') cur.first = cur.first * HRAD.first % HMOD.first;\n\t\tif(ch[i] == '+') cnt.second = (cnt.second + cur.second) % HMOD.second;\n\t\tif(ch[i] == '-') cnt.second = (cnt.second - cur.second + HMOD.second) % HMOD.second;\n\t\tif(ch[i] == '<') cur.second = cur.second * HIRAD.second % HMOD.second;\n\t\tif(ch[i] == '>') cur.second = cur.second * HRAD.second % HMOD.second;\n\t\tS[cnt] ++;\n\t}\n\tpair<LL, LL> ss = cnt;\n\tLL ans = S[ss];\n\tcur = MP(1, 1); cnt = MP(0, 0);\n\trep(i, n) {\n\t\tif(ch[i] == '+') cnt.first = (cnt.first + cur.first) % HMOD.first;\n\t\tif(ch[i] == '-') cnt.first = (cnt.first - cur.first + HMOD.first) % HMOD.first;\n\t\tif(ch[i] == '<') cur.first = cur.first * HIRAD.first % HMOD.first;\n\t\tif(ch[i] == '>') cur.first = cur.first * HRAD.first % HMOD.first;\n\t\tif(ch[i] == '+') cnt.second = (cnt.second + cur.second) % HMOD.second;\n\t\tif(ch[i] == '-') cnt.second = (cnt.second - cur.second + HMOD.second) % HMOD.second;\n\t\tif(ch[i] == '<') cur.second = cur.second * HIRAD.second % HMOD.second;\n\t\tif(ch[i] == '>') cur.second = cur.second * HRAD.second % HMOD.second;\n\t\tS[cnt] --;\n\t\tans += S[MP((cnt.first + cur.first * ss.first) % HMOD.first, (cnt.second + cur.second * ss.second) % HMOD.second)];\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <vector>\n\nconst int DEBUG = 0;\n\n#define MOCK 1\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define DEBUGP(val) cerr << #val << \"=\" << val << \"\\n\"\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\ntypedef pair<ll, ll> PL;\n\n\nll powmod(ll a, ll e, ll mod) {\n  ll sum = 1;\n  ll cur = a;\n  while (e > 0) {\n    if (e % 2) {\n      sum = sum * cur % mod;\n    }\n    cur = cur * cur % mod;\n    e /= 2;\n  }\n  return sum;\n}\n\n\n\nint main(void) {\n  const ll mod = 1e9 + 7;\n  const ll mod2 = 1e9 + 9;\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  string s;\n  cin >> n >> s;\n  int p = 0;\n  VI pos(n + 1);\n  mt19937 mt;\n  VL b(3);\n  ll mods[3] = { mod, mod2, 998244353 };\n  REP(c, 0, 3) {\n    do {\n      b[c] = mt() % mods[c];\n    } while (b[c] == 0);\n  }\n  vector<VL> hsh(3, VL(n + 1));\n  ll inv[3] = { 0 };\n  REP(c, 0, 3) inv[c] = powmod(b[c], mods[c] - 2, mods[c]);\n  REP(c, 0, 3) {\n    p = 0;\n    ll cur = 1;\n    REP(i, 0, n) {\n      ll tmp = hsh[c][i];\n      if (s[i] == '>') {\n        p++;\n        cur = cur * b[c] % mods[c];\n      }\n      if (s[i] == '<') {\n        p--;\n        cur = cur * inv[c] % mods[c];\n      }\n      if (s[i] == '+') {\n        tmp = (tmp + cur) % mods[c];\n      }\n      if (s[i] == '-') {\n        tmp = (tmp + mods[c] - cur) % mods[c];\n      }\n      hsh[c][i + 1] = tmp;\n      pos[i + 1] = p;\n    }\n  }\n  if (DEBUG) {\n    REP(i, 0, n + 1) {\n      cerr << i << \" \" << hsh[0][i] << endl;\n    }\n  }\n  VL meguru(3);\n  REP(c, 0, 3) meguru[c] = hsh[c][n];\n  map<VL, int> kirika;\n  kirika[meguru] = 1;\n  ll tot = 0;\n  VL cur(3);\n  REP(c, 0, 3) cur[c] = powmod(b[c], pos[n], mods[c]);\n  for (int i = n - 1; i >= 0; --i) {\n    if (DEBUG) {\n      DEBUGP(i);\n      DEBUGP(pos[i]);\n    }\n    if (pos[i + 1] - pos[i] == 1) {\n      REP(c, 0, 3) cur[c] = cur[c] * inv[c] % mods[c];\n    }\n    else if (pos[i + 1] - pos[i] == -1) {\n      REP(c, 0, 3) cur[c] = cur[c] * b[c] % mods[c];\n    }\n    VL ken(3);\n    REP(c, 0, 3) ken[c] = cur[c] * meguru[c] + hsh[c][i] % mods[c];\n    tot += kirika[ken];\n    VL tt(3);\n    REP(c, 0, 3) tt[c] = hsh[c][i];\n    kirika[tt] += 1;\n  }\n  cout << tot << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\n#include <unordered_map>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\ntypedef __int128 bi;\nconst bi MOD=1000000000000000003LL;\nbi qp(bi a,bi b)\n{\n\tbi x=1; a%=MOD;\n\twhile(b)\n\t{\n\t\tif(b&1) x=x*a%MOD;\n\t\ta=a*a%MOD; b>>=1;\n\t}\n\treturn x;\n}\nconst bi g=233,rg=qp(g,MOD-2);\npair<bi,bi> operator +\n(pair<bi,bi> a,pair<bi,bi> b)\n{return mp((a.fi+a.se*b.fi)%MOD,a.se*b.se%MOD);}\n#define SZ 666666\nint n; char str[SZ];\npair<bi,bi> sg[SZ],tg(0,1);\nll ans=0;\nvoid fz(int l,int r)\n{\n\tif(l==r)\n\t{\n\t\tans+=sg[l].fi==tg.fi;\n\t\treturn;\n\t}\n\tint m=(l+r)>>1;\n\tfz(l,m); fz(m+1,r);\n\tunordered_map<ll,int> sb;\n\tpair<bi,bi> g(0,1);\n\tfor(int i=m+1;i<=r;++i)\n\t{\n\t\tg=g+sg[i]; ++sb[g.fi];\n\t}\n\tg=mp(0,1);\n\tfor(int i=m;i>=l;--i)\n\t{\n\t\tg=sg[i]+g;\n\t\t//g.fi+g.se*T=tg.fi\n\t\tbi tr=(tg.fi-g.fi+MOD)%MOD*qp(g.se,MOD-2)%MOD;\n\t\tans+=sb[tr];\n\t}\n}\nint main()\n{\n\tscanf(\"%d%s\",&n,str+1);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tif(str[i]=='+') sg[i]=mp(1,1);\n\t\telse if(str[i]=='-') sg[i]=mp(MOD-1,1);\n\t\telse if(str[i]=='>') sg[i]=mp(0,g);\n\t\telse sg[i]=mp(0,rg); tg=tg+sg[i];\n\t}\n\tfz(1,n); cout<<ans<<\"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\nusing namespace std;\ntypedef long long LL;\nconst int N=250010;\nconst LL MOD=1000000000000000031ll,B=1000000000000000003ll,REVB=821428571428571454ll;\nint n;\nchar str[N];\nLL f[N],p[N];\nLL mul(LL x,LL y){\n\treturn (LL)((__int128)x*y%MOD);\n}\nvoid readData(){\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",str+1);\n}\nmap<LL,int> mp;\nvoid solve(){\n\tf[0]=0;\n\tp[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tf[i]=f[i-1];\n\t\tp[i]=p[i-1];\n\t\tif(str[i]=='>')\n\t\t\tp[i]=mul(p[i],B);\n\t\telse if(str[i]=='<')\n\t\t\tp[i]=mul(p[i],REVB);\n\t\telse if(str[i]=='+')\n\t\t\t(f[i]+=p[i])%=MOD;\n\t\telse\n\t\t\t(f[i]-=p[i])%=MOD;\n\t}\n\tLL ans=0;\n\tfor(int i=n;i>=1;i--){\n\t\tmp[f[i]]++;\n\t\tans+=mp[(mul(f[n],p[i-1])+f[i-1])%MOD];\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\nint main(){\n\treadData();\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n// need\n#include <iostream>\n#include <algorithm>\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <unordered_map>\n#include <unordered_set>\n#include <array>\n// stream\n//#include <istream>\n#include <sstream>\n//#include <ostream>\n#include <fstream>\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest& ...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int w_=0; w_<n; ++w_){MACRO_VEC_ROW_Scan(w_, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest& ...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest& ...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& R:c)for(auto& w:R)std::cin>>w;\n// output\n#define OUT(dist) std::cout<<(dist);\n#define FOUT(n, dist) std::cout<<std::fixed<<std::setprecision(n)<<(dist);\n#define SOUT(n, c, dist) std::cout<<std::setw(n)<<std::setfill(c)<<(dist);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(w, n) std::cout<<(w + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(dist) {std::cerr << #dist << \"\\t:\" << (dist) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(w, a, n) for(int w=(a);w<(n);++w)\n#define RFOR(w, a, n) for(int w=(n)-1;w>=(a);--w)\n#define REP(w, n) for(int w=0;w<int(n);++w)\n#define RREP(w, n) for(int w=int(n)-1;w>=0;--w)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<class T> inline T CHMAX(T & a, const T b) { return a = (a < b) ? b : a; }\ntemplate<class T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\n//void CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n// test\ntemplate<class T> using V = std::vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n#define random_shuffle \"USE std::shuffle!\";\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = (1 << 30) - 1;                    // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-10;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T & val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T & val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T> & a, const T & val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>> & a, const T & val) { for (auto& b : a) FILL(b, val); }\n// ------------>8------------------------------------->8------------\n\nnamespace Test {\n\tsigned main() {\n\t\t//VAR(int, n);\n//VAR(std::string, s);\n\t\tstd::string S = \"+-<>\";\n\t\tconst int n = 50;\n\t\tauto system_now = std::chrono::system_clock::now();\n\t\tstd::mt19937 mt(std::chrono::duration_cast<std::chrono::microseconds>(system_now.time_since_epoch()).count());\n\t\tstd::uniform_int_distribution<> rand(/* min */0, /* max */3);\n\t\tstd::string s;\n\t\tREP(_, n) s += S[rand(mt)];\n\n\t\tauto get = [&](int l, int r) {\n\t\t\tstd::map<int, int> map;\n\t\t\tint p = 0;\n\t\t\tFOR(i, l, r) {\n\t\t\t\t/* */if (s[i] == '+') { if (++map[p] == 0) map.erase(p); }\n\t\t\t\telse if (s[i] == '-') { if (--map[p] == 0) map.erase(p); }\n\t\t\t\telse if (s[i] == '>') ++p;\n\t\t\t\telse if (s[i] == '<') --p;\n\t\t\t}\n\n\t\t\treturn map;\n\t\t};\n\n\t\tauto sub = [&](std::map<int, int> a, const std::map<int, int> b) {\n\t\t\tfor (auto& p : b) {\n\t\t\t\tif ((a[p.first] -= p.second) == 0) a.erase(p.first);\n\t\t\t}\n\t\t\treturn a;\n\t\t};\n\n\t\tauto print = [&](std::map<int, int> map) {\n\t\t\tFOR(i, -10, 20) {\n\t\t\t\tOUT(map[i])SPBR(i, 20);\n\t\t\t}\n\t\t};\n\n\t\tVAR(int, l, r);\n\n\t\tOUT(s)BR;\n\t\tREP(i, n) {\n\t\t\tchar c = ' ';\n\t\t\tif (IN(l, i, r)) c = '*';\n\t\t\tOUT(c);\n\t\t}BR;\n\t\tprint(get(l, r));\n\t\tprint(sub(get(0, r), get(0, l)));\n\t\treturn 0;\n\t}\n}\n\nll powMod(ll n, ll p, ll mod) {\n\tif (p < 0) p += mod - 1;\n\tn %= mod;\n\tll res = 1;\n\twhile (p) {\n\t\tif (p & 1) (res *= n) %= mod;\n\t\t(n *= n) %= mod;\n\t\tp >>= 1;\n\t}\n\treturn res;\n}\n\nconstexpr int N = 3;\nconstexpr int M[N] = { 1000000009, 1000000021, 1000000033 };\nconstexpr int B = 123457;\n\nstruct Hash {\n\tint val[N];\n\tHash& norm() {\n\t\tREP(i, N) if ((val[i] %= M[i]) < 0) val[i] += M[i];\n\t\treturn *this;\n\t}\n\n\tHash(int x) { REP(i, N) val[i] = x; norm(); }\n\tHash() : Hash(0) {}\n\n\tstatic Hash makePow(int n, int p) {\n\t\tHash res;\n\t\tREP(i, N) res.val[i] = powMod(n, p, M[i]);\n\t\treturn res;\n\t}\n\tstatic Hash makeInv(int x) {\n\t\tHash res;\n\t\tREP(i, N) res.val[i] = powMod(x, M[i] - 2, M[i]);\n\t\treturn res;\n\t}\n\n\tbool operator==(const Hash & r) const { return *this == r; }\n\tbool operator<(const Hash & r) const { \n\t\tREP(i, N) if(this->val[i] != r.val[i]) return this->val[i] < r.val[i];\n\t\treturn false;\n\t}\n\tHash& operator+=(const Hash & r) { REP(i, N) val[i] += r.val[i]; norm(); return *this; }\n\tHash& operator-=(const Hash & r) { REP(i, N) val[i] -= r.val[i]; norm(); return *this; }\n\tHash& operator*=(const Hash & r) { REP(i, N) val[i] *= r.val[i]; norm(); return *this; }\n\tHash& operator/=(const Hash & r) { \n\t\tREP(i, N) val[i] *= powMod(r.val[i], M[i] - 2, M[i]); \n\t\tnorm(); \n\t\treturn *this; \n\t}\n};\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n);\n\tVAR(std::string, s);\n\n\tHash X;\n\t{\n\t\tint p = 0;\n\t\tREP(i, n) {\n\t\t\t/* */if (s[i] == '+') X += Hash::makePow(B, p);\n\t\t\telse if (s[i] == '-') X -= Hash::makePow(B, p);\n\t\t\telse if (s[i] == '>') ++p;\n\t\t\telse if (s[i] == '<') --p;\n\t\t}\n\t}\n\n\tstd::map<Hash, int> map;\n\t++map[X];\n\tint ans = 0;\n\tHash A;\n\t{\n\t\tint p = 0;\n\t\tREP(i, n) {\n\t\t\t/* */if (s[i] == '+') A += Hash::makePow(B, p);\n\t\t\telse if (s[i] == '-') A -= Hash::makePow(B, p);\n\t\t\telse if (s[i] == '>') ++p;\n\t\t\telse if (s[i] == '<') --p;\n\t\t\t(ans += map[A]) %= MOD;\n\t\t\t{\n\t\t\t\tauto tX(X);\n\t\t\t\ttX /= Hash::makePow(B, -p);\n\t\t\t\ttX += A;\n\t\t\t\t++map[tX];\n\t\t\t}\n\t\t}\n\t}\n\tOUT(ans)BR;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\n\nconst int mod0 = 1e9 + 7;\nconst int mod1 = 1e9 + 9;\nconst int base = 10007;\n\nint64_t power(int64_t x, int64_t n, int64_t mod) {\n  int64_t ret = 1;\n  while(n > 0) {\n    if(n & 1) (ret *= x) %= mod;\n    (x *= x) %= mod;\n    n >>= 1;\n  }\n  return ret;\n}\n\n\nint64 h0[550001], g0[550001];\nint64 h1[550001], g1[550001];\n\n\nint main() {\n\n  h0[0] = h1[0] = 1;\n  for(int i = 1; i < 550001; i++) {\n    h0[i] = h0[i - 1] * base % mod0;\n    h1[i] = h1[i - 1] * base % mod1;\n  }\n  g0[550000] = power(h0[550000], mod0 - 2, mod0);\n  g1[550000] = power(h1[550000], mod1 - 2, mod1);\n  for(int i = 549999; i >= 0; i--) {\n    g0[i] = g0[i + 1] * (i + 1) % mod0;\n    g1[i] = g1[i + 1] * (i + 1) % mod1;\n  }\n\n  int N;\n  string S;\n\n  cin >> N;\n  cin >> S;\n\n  vector< int64 > latte0, malta0;\n  vector< int64 > latte1, malta1;\n  int64 beet = 0, pos = 250001;\n  latte0.push_back(pos), malta0.push_back(beet);\n  latte1.push_back(pos), malta1.push_back(beet);\n\n  for(int i = 0; i < N; i++) {\n    char c = S[i];\n    if(c == '+') (beet += h0[pos]) %= mod0;\n    else if(c == '-') (beet += mod0 - h0[pos]) %= mod0;\n    else if(c == '<') --pos;\n    else ++pos;\n    latte0.push_back(pos), malta0.push_back(beet);\n  }\n  beet = 0, pos = 250001;\n  for(int i = 0; i < N; i++) {\n    char c = S[i];\n    if(c == '+') (beet += h1[pos]) %= mod1;\n    else if(c == '-') (beet += mod1 - h1[pos]) %= mod1;\n    else if(c == '<') --pos;\n    else ++pos;\n    latte1.push_back(pos), malta1.push_back(beet);\n  }\n\n\n  map< pair< int64, int64 >, int > mp;\n  int64 ret = 0;\n  for(int i = N; i >= 0; i--) {\n    int64 dx = latte0[i] - latte0[0];\n    int64 mul0, mul1;\n    if(dx >= 0) mul0 = h0[dx], mul1 = h1[dx];\n    else mul0 = g0[-dx], mul1 = g1[-dx];\n    ret += mp[{(malta0[i] + malta0[N] * mul0) % mod0, (malta1[i] + malta1[N] * mul1) % mod1}];\n    ++mp[{malta0[i], malta1[i]}];\n  }\n  cout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,NAME,...) NAME\n#define pr(...) cerr<< GET_MACRO(__VA_ARGS__,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__) <<endl\n#define pr1(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr2(a,b) pr1(a)<<pr1(b)\n#define pr3(a,b,c) pr1(a)<<pr2(b,c)\n#define pr4(a,b,c,d) pr1(a)<<pr3(b,c,d)\n#define pr5(a,b,c,d,e) pr1(a)<<pr4(b,c,d,e)\n#define pr6(a,b,c,d,e,f) pr1(a)<<pr5(b,c,d,e,f)\n#define pr7(a,b,c,d,e,f,g) pr1(a)<<pr6(b,c,d,e,f,g)\n#define pr8(a,b,c,d,e,f,g,h) pr1(a)<<pr7(b,c,d,e,f,g,h)\nusing namespace std;\nusing Int = long long;\nusing ll = long long;\nusing Double = long double;\nconst Int INF = (1LL<<55)+1e9; // ~ 3.6 * 1e16\nconst Int mod = (1e9)+7;\nconst Double EPS = 1e-8;\nconst Double PI = 6.0 * asin((Double)0.5);\nusing P = pair<Int,Int>;\nusing T = tuple<Int,Int,Int>;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nostream& operator<<(ostream& o,T t){return o<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){Int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){Int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\nconst Int N = 300000;\n\nll mod_pow(ll x,ll n,Int mod){\n  ll res=1;\n  while(n){\n    if(n%2) res=res*x%mod;\n    x=x*x%mod;\n    n/=2;\n  }\n  return res;\n}\n\nll mod_inv(Int num,Int mod){return mod_pow(num, mod-2, mod);}\n\n\nclass Hash{\npublic:\n  ll B, inv, mod;\n  ll num;\n  ll idx;\n  vector<ll> K;\n  Hash(Int B,Int mod):B(B),mod(mod){\n    K.resize(N);\n    K[0] = 1;\n    for(Int i=1;i<N;i++) K[i] = K[i-1] * B % mod;\n\n    inv = mod_pow(B, mod-2, mod);\n    num = 0;\n    idx = K[N/2];\n  }\n\n  void inc(){num = (num + idx) % mod;}\n  void dec(){num = (num - idx + mod) % mod;}\n  void moveLeft(){idx = idx * inv % mod;}\n  void moveRight(){idx = idx * B % mod;}\n  \n};\n\n\nsigned main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  Int n;\n  cin>>n;\n  string s;\n  cin>>s;\n\n\n\n  vector<map<ll,Int> > cnt(3);\n  vector<Hash> hash({Hash(1777771, 1e9+7),Hash(10000019,1000000009),Hash(10000079,1000000021)});\n  vector<Hash> hash2 = hash;\n  \n  for(Int k = 0; k<n ; k++){\n    char ch = s[k];\n    for(Int i=0;i<3;i++){\n      auto &A = hash[i];\n      if(ch == '+') A.inc();\n      if(ch == '-') A.dec();\n      if(ch == '<') A.moveLeft();\n      if(ch == '>') A.moveRight();\n      cnt[i][A.num]++;\n    }\n  }\n\n  vector<ll> allHash(3);\n  vector<ll> Ofset(3,0);\n  for(Int i=0;i<3;i++) allHash[i] = hash[i].num;\n  \n  Int ans = 0;\n  for(Int k=0;k<n;k++){\n    \n    char ch = s[k];\n    Int mn = INF;\n    for(Int i=0;i<3;i++){\n      auto &A = hash2[i];\n      auto &U = allHash[i];\n      auto &X = Ofset[i];\n      \n      ll mod = A.mod;\n      ll B = A.B;\n      ll inv = A.inv;\n      ll val = ((U - X + mod)%mod) % mod;\n      \n      Min(mn, cnt[i][val]);\n      \n      if(ch == '+') X = (X - A.idx + mod) % mod, A.inc();\n      if(ch == '-') X = (X + A.idx + mod) % mod, A.dec();\n      if(ch == '>') U = U * B % mod, A.moveRight();\n      if(ch == '<') U = U * inv % mod, A.moveLeft();\n      assert(cnt[i][A.num] != 0);\n      cnt[i][A.num]--;\n    }\n    ans += mn;\n  }\n  cout<<ans<<endl;\n  \n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define maxn 250020\n#define rep(i,l,r) for(register int i = l ; i <= r ; i++)\n#define repd(i,r,l) for(register int i = r ; i >= l ; i--)\n#define rvc(i,S) for(register int i = 0 ; i < (int)S.size() ; i++)\n#define rvcd(i,S) for(register int i = ((int)S.size()) - 1 ; i >= 0 ; i--)\n#define fore(i,x)for (register int i = head[x] ; i ; i = e[i].next)\n#define pb push_back\n#define prev prev_\n#define stack stack_\n#define mp make_pair\n#define fi first\n#define se second\n#define inf 0x3f3f3f3f\ntypedef long long ll;\ntypedef pair<int,int> pr;\n\nconst ll mod = 1e9 + 7;\nconst ll p[7] = {19,37,59,97,107,109,91};\nll inv[7];\n\ninline ll add(ll x,ll y){ return (x + y + mod) % mod; }\nstruct node{\n\tll a[7];\n\tnode() { memset(a,0,sizeof(a)); }\n\tbool operator < (node x)const{\n\t\trep(i,0,6) if ( a[i] != x.a[i] ) return a[i] < x.a[i];\n\t\treturn 0;\t\n\t}\n\tnode operator + (node x){\n\t\tnode y;\n\t\trep(i,0,6) y.a[i] = add(a[i],x.a[i]);\n\t\treturn y;\n\t}\n\tnode operator - (node x){\n\t\tnode y;\n\t\trep(i,0,6) y.a[i] = add(a[i],-x.a[i]);\n\t\treturn y;\n\t}\n\tnode operator * (const ll p[]){\n\t\tnode y;\n\t\trep(i,0,6) y.a[i] = a[i] * p[i] % mod;\n\t\treturn y;\n\t}\n\tnode operator * (node x){\n\t\tnode y;\n\t\trep(i,0,6) y.a[i] = a[i] * x.a[i] % mod;\n\t\treturn y;\n\t}\n\tvoid print(){\n\t\trep(i,0,6) cout<<a[i]<<\" \";\n\t\tcout<<endl;\n\t}\n}hash_[maxn],pos[maxn];\nmap <node,int> num;\nchar s[maxn];\nint n;\nll ans;\n\ninline ll power(ll x,ll y){\n\tll res = 1;\n\twhile ( y ){\n\t\tif ( y & 1 ) res = res * x % mod;\n\t\tx = x * x % mod;\n\t\ty >>= 1;\n\t}\n\treturn res;\n}\nvoid init(){\n\trep(i,0,6) inv[i] = power(p[i],mod - 2);\n}\nvoid solve(){\n\trep(i,0,6) pos[0].a[i] = 1;\n\trep(i,1,n){\n\t\thash_[i] = hash_[i - 1] , pos[i] = pos[i - 1];\n\t\tif ( s[i] == '+' ) hash_[i] = hash_[i] + pos[i];\n\t\telse if ( s[i] == '-' ) hash_[i] = hash_[i] - pos[i];\n\t\telse if ( s[i] == '>' ) pos[i] = pos[i] * p;\n\t\telse if ( s[i] == '<' ) pos[i] = pos[i] * inv;\n\t}\n\trepd(i,n,1){\n\t\tnum[hash_[i]]++;\n\t\tnode cur = hash_[n] * pos[i - 1] + hash_[i - 1];\n\t\tans += num[cur];\n\t}\n\tcout<<ans<<endl;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",s + 1);\n\tinit();\n\tsolve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int Maxn=250005;\nconst int mod1=775731769,base1=551745917;\nconst int mod2=977783399,base2=537587201;\nconst int mod3=861044911,base3=571213603;\nint n;\nchar c[Maxn];\nconstexpr int ksm(int x,int k,int mod){\n\tint ret=1,tmp=x;\n\twhile(k){\n\t\tif(k&1)ret=1ll*ret*tmp%mod;\n\t\ttmp=1ll*tmp*tmp%mod;k>>=1;\n\t}\n\treturn ret;\n}\ntemplate<int mod,int base,int invbase=ksm(base,mod-2,mod)>\nstruct integer{\n\tint val;\n\tinteger(){val=0;}\n\tinteger(int v){val=(v%mod+mod)%mod;}\n\tint operator * (const int rhs){return 1ll*val*rhs%mod;}\n\tint operator + (const int rhs){return (val+rhs)%mod;}\n\tint operator - (const int rhs){return ((val-rhs)%mod+mod)%mod;}\n\toperator int(){return val;}\n\tvoid rf(){val=1ll*val*base%mod;}\n\tvoid rb(){val=1ll*val*invbase%mod;}\n};\ninteger<mod1,mod2,mod3>a;\ntemplate<class T>\nstruct node{\n\tT hash,cur;\n\tvoid init(){hash=0;cur=1;}\n\tvoid add(char c){\n\t\tif(c=='>')cur.rf();\n\t\tif(c=='<')cur.rb();\n\t\tif(c=='+')hash=hash+cur;\n\t\tif(c=='-')hash=hash-cur;\n\t}\n\tnode operator*(node rhs){\n\t\tnode result;\n\t\tresult.cur=cur*rhs.cur;\n\t\tresult.hash=rhs.hash*cur;\n\t\tresult.hash=result.hash+hash;\n\t\treturn result;\n\t}\n\tbool operator<(const node&rhs)const{\n\t\treturn hash.val<rhs.hash.val;\n\t}\n\tbool operator!=(const node&rhs)const{\n\t\treturn hash.val!=rhs.hash.val;\n\t}\n};\ntemplate<class T,class...args>\nstruct state{\n\tnode<T>a;\n\tstate<args...>b;\n\tvoid init(){a.init();b.init();}\n\tvoid add(char c){a.add(c);b.add(c);}\n\tbool operator<(const state&rhs)const{\n\t\tif(a!=rhs.a)return a<rhs.a;\n\t\treturn b<rhs.b;\n\t}\n\tstate operator*(const state&rhs){\n\t\tstate w;\n\t\tw.a=a*rhs.a;\n\t\tw.b=b*rhs.b;\n\t\treturn w;\n\t}\n};\ntemplate<class T>\nstruct state<T>{\n\tnode<T>a;\n\tvoid init(){a.init();}\n\tvoid add(char c){a.add(c);}\n\tbool operator<(const state&rhs)const{\n\t\treturn a<rhs.a;\n\t}\n\tstate operator*(const state&rhs){\n\t\tstate w;w.a=a*rhs.a;\n\t\treturn w;\n\t}\n};\ntypedef integer<mod1,base1> Integer1;\ntypedef integer<mod1,base1> Integer2;\ntypedef integer<mod1,base1> Integer3;\ntypedef state<Integer1,Integer2,Integer3> State;\nint main(){\n\tmap<State,int>cnt;\n\tlong long ans=0;\n\tscanf(\"%d%s\",&n,c+1);\n\tState full,prefix;\n\tfull.init();prefix.init();\n\tfor(int i=1;i<=n;i++)full.add(c[i]);\n\tfor(int i=1;i<=n;i++){\n\t\tcnt[prefix*full]++;\n\t\tprefix.add(c[i]);\n\t\tans+=cnt[prefix];\n\t}\n\tcout<<ans<<\"\\n\";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 280005;\nconst int mod1 = 1e9 + 123;\nconst int mod2 = 1e9 + 7;\n\nint pw1[N + N], pw2[N + N];\nint e[N];\nint h1[N], h2[N];\nint n;\nstring s;\n\nint inverse(int a, int m) {\n\tint b = m - 2;\n\tint ret = 1;\n\twhile(b) {\n\t\tif (b & 1) ret = 1LL * ret * a % m; a = 1LL * a * a % m;\n\t\tb >>= 1;\n\t}\n\treturn ret;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> n >> s;\n\ts = ' ' + s;\n\n\tpw1[0] = pw2[0] = 1;\n\tfor (int i = 1; i < N + N; ++i) {\n\t\tpw1[i] = 1LL * pw1[i - 1] * N % mod1;\n\t\tpw2[i] = 1LL * pw2[i - 1] * N % mod2;\n\t}\n\n\te[0] = N;\n\tfor (int i = 1; i <= n; ++i) {\n\t\th1[i] = h1[i - 1];\n\t\th2[i] = h2[i - 1];\n\t\te[i] = e[i - 1];\n\t\tif (s[i] == '<' || s[i] == '>') {\n\t\t\te[i] += (s[i] == '>' ? +1 : -1);\n\t\t}\n\t\telse {\n\t\t\th1[i] = (h1[i] + (s[i] == '+' ? +1 : -1) * pw1[e[i]]) % mod1;\n\t\t\tif (h1[i] < 0) h1[i] += mod1;\n\t\t\th2[i] = (h2[i] + (s[i] == '+' ? +1 : -1) * pw2[e[i]]) % mod2;\n\t\t\tif (h2[i] < 0) h2[i] += mod2;\n\t\t}\n\t}\n\n\tlong long res = 0;\n\tint t1 = 1LL * h1[n] * inverse(pw1[N], mod1) % mod1;\n\tint t2 = 1LL * h2[n] * inverse(pw2[N], mod2) % mod2;\n\tmap < pair<int, int>, int > mp;\n\tmp[{1LL * t1 * pw1[N] % mod1, 1LL * t2 * pw2[N] % mod2}]++;\n\n\tfor (int i = 1; i <= n; ++i) {\n\t\tres += mp[{h1[i], h2[i]}];\n\t\tint k1 = (1LL * t1 * pw1[e[i]] + h1[i]) % mod1;\n\t\tint k2 = (1LL * t2 * pw2[e[i]] + h2[i]) % mod2;\n\t\tmp[{k1, k2}]++;\n\t}\n\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n\nusing u64 = unsigned long long;\n\nconst u64 B = 998244353;\nconst int N = 500000 + 7;\n\nint n;\nchar s[N];\nu64 f[N];\nint g[N];\nstd::map<u64, u64> map;\nu64 cnt;\n\nu64 pow(u64 a, u64 k) {\n\tif (k < 0) k += (1llu << 63) - 1;\n\tu64 t = 1;\n\tfor (; k; a = a * a, k >>= 1)\n\t\tif (k & 1) t = t * a;\n\treturn t;\n}\n\nint main() {\n//\tfreopen(\"code.in\", \"r\", stdin);\n//\tfreopen(\"code.out\", \"w\", stdout);\n\n\tscanf(\"%d%s\", &n, s + 1);\n\tfor (int i = 1; i <= n; ++i)\n\t\tif (s[i] == '+' || s[i] == '-')\n\t\t\tf[i] = f[i - 1] + (s[i] == '+' ? 1 : -1) * pow(B, g[i] = g[i - 1]);\n\t\telse\n\t\t\tf[i] = f[i - 1], g[i] = g[i - 1] + (s[i] == '<' ? -1 : 1);\n\tfor (int i = n; i; --i)\n\t\t++map[f[i]], cnt += map[f[n] * pow(B, g[i - 1]) + f[i - 1]];\n\tprintf(\"%lld\\n\", cnt);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Rint register int\nusing namespace std;\ntypedef long long LL;\nconst int N = 250003, mod = 1004535809;\nint n, X, inv, c[6], a[6][N], b[6][N];\nLL ans;\nchar str[N];\nmap<vector<int>, int> tong;\ninline void upd(int &a, int b){a += b; if(a >= mod) a -= mod;}\ninline int add(int a, int b){return (a + b >= mod) ? (a + b - mod) : (a + b);}\ninline int kasumi(int a, int b){\n\tint res = 1;\n\twhile(b){\n\t\tif(b & 1) res = (LL) res * a % mod;\n\t\ta = (LL) a * a % mod; b >>= 1;\n\t}\n\treturn res;\n}\ninline void calc(int l){\n\tfor(Rint i = n;i;i --)\n\t\tif(str[i] == '+') ++ c[l];\n\t\telse if(str[i] == '-') -- c[l];\n\t\telse if(str[i] == '<') c[l] = (LL) c[l] * inv % mod;\n\t\telse if(str[i] == '>') c[l] = (LL) c[l] * X % mod;\n\tint k = 1, bb = 0;\n\tfor(Rint i = n;i;i --){\n\t\tif(str[i] == '+') upd(bb, mod - k);\n\t\telse if(str[i] == '-') upd(bb, k);\n\t\telse if(str[i] == '<') k = (LL) k * X % mod;\n\t\telse if(str[i] == '>') k = (LL) k * inv % mod;\n\t\ta[l][i] = bb; b[l][i] = add((LL) k * c[l] % mod, bb);\n\t}\n}\nint main(){\n\tsrand(time(0));\n\tscanf(\"%d%s\", &n, str + 1);\n\tfor(Rint i = 0;i < 6;i ++){\n\t\tinv = kasumi(X = (rand() << 15 | rand()) % mod, mod - 2); calc(i);\n\t}\n\tfor(Rint i = 1;i <= n;i ++){\n\t\tans += tong[{a[0][i], a[1][i], a[2][i], a[3][i], a[4][i], a[5][i]}];\n\t\t++ tong[{b[0][i], b[1][i], b[2][i], b[3][i], b[4][i], b[5][i]}];\n\t}\n\tans += tong[{0, 0, 0, 0, 0, 0}];\n\tprintf(\"%lld\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<bitset>\nusing namespace std;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\nconst llint mod=998244353;\nconst llint moe=998999971;\nconst llint big=2.19e18+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-15;\ntemplate <class T,class U>void mineq(T& a,U b){if(a>b){a=b;}}\ntemplate <class T,class U>void maxeq(T& a,U b){if(a<b){a=b;}}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint i,n;cin>>n;\n\tllint ans=0;\n\tstring str;cin>>str;\n\t/*\n\tローリングハッシュ\n\t+ ha+=P\n\t- hs-=P\n\t> P*=100;\n\t< P/=100;\n\t*/\n\tllint gya=1,gyb=1,bb=100;\n\tfor(int h=0;h<30;h++){\n\t\tif((mod-2)&(1<<h)){gya*=bb;gya%=mod;}\n\t\tbb*=bb;bb%=mod;\n\t}\n\tbb=100;\n\tfor(int h=0;h<30;h++){\n\t\tif((moe-2)&(1<<h)){gyb*=bb;gyb%=moe;}\n\t\tbb*=bb;bb%=moe;\n\t}\n\tvector<llint>cd(n+1);\n\tvector<llint>ce(n+1);\n\tllint cp=1,cq=1;\n\tfor(i=0;i<n;i++){\n\t\tif(str[i]=='>'){cp*=100;cq*=100;cp%=mod;cq%=moe;}\n\t\tif(str[i]=='<'){cp*=gya;cq*=gyb;cp%=mod;cq%=moe;}\n\t\tif(str[i]=='+'){cd[i]=cp;ce[i]=cq;}\n\t\tif(str[i]=='-'){cd[i]=mod-cp;ce[i]=moe-cq;}\n\t}\n\tfor(i=n-1;i>=0;i--){cd[i]+=cd[i+1];cd[i]%=mod;ce[i]+=ce[i+1];ce[i]%=moe;}\n\tmap<pair<llint,llint>,int>ma;\n\tfor(i=0;i<=n;i++){ma[mp(cd[i],ce[i])]++;}\n\tllint apd=1,ahd=0,ape=1,ahe=0;\n\tllint Sd=cd[0];//全体のローリングハッシュ\n\tllint Se=ce[0];\n\tfor(i=0;i<n;i++){\n\t\tma[mp(cd[i],ce[i])]--;\n\t\tllint tdr=(Sd-ahd-apd*Sd)%mod;\n\t\tllint ter=(Se-ahe-ape*Se)%moe;\n\t\tif(tdr<0){tdr+=mod;}\n\t\tif(ter<0){ter+=moe;}\n\t\tans+=ma[mp(tdr,ter)];\n\t\tif(str[i]=='>'){apd*=100;ape*=100;apd%=mod;ape%=moe;}\n\t\tif(str[i]=='<'){apd*=gya;ape*=gyb;apd%=mod;ape%=moe;}\n\t\tif(str[i]=='+'){ahd+=apd;ahe+=ape;ahd%=mod;ahe%=moe;}\n\t\tif(str[i]=='-'){ahd+=mod-apd;ahe+=moe-ape;ahd%=mod;ahe%=moe;}\n\t}\n\tcout<<ans<<endl;\n\t//ハッシュ衝突?\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=(0);i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n \ntemplate<class T> inline void read(T &x){\n\tint f=0;x=0;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar())f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar())x=x*10+ch-'0';\n\tif(f)x=-x;\n}\n\nconst int N=500005;\nnamespace{\n\tconst int mod[2]={19260817,998244353};\n\tint p[N][2],rp[N][2];\n\tint power(int x,int t){\n\t\treturn x>=0?p[x][t]:rp[-x][t];\n\t}\n\tint power(int x,int p,int mod){\n\t\tint res=1;\n\t\tfor(;p;p>>=1,x=(ll)x*x%mod)\n\t\t\tif(p&1)res=(ll)res*x%mod;\n\t\treturn res;\n\t}\n\tvoid init(int n){\n\t\tint A=2333,B=power(A,mod[0]-2,mod[0]);\n\t\tint C=19260817,D=power(C,mod[1]-2,mod[1]);\n\t\tp[0][0]=p[0][1]=rp[0][0]=rp[0][1]=1;\n\t\trep(i,1,n){\n\t\t\tp[i][0]=(ll)p[i-1][0]*A%mod[0];\n\t\t\trp[i][0]=(ll)rp[i-1][0]*B%mod[0];\n\t\t\tp[i][1]=(ll)p[i-1][1]*C%mod[1];\n\t\t\trp[i][1]=(ll)rp[i-1][1]*D%mod[1];\n\t\t}\n\t}\n}\n\nint v[N][2],d[N],n;\nmap<pii,int> cnt;\nchar s[N];\nll ans;\n\nint main(){\n\tread(n),init(n);\n\tscanf(\"%s\",s+1);\n\trep(i,1,n){\n\t\tv[i][0]=v[i-1][0];\n\t\tv[i][1]=v[i-1][1];\n\t\td[i]=d[i-1];\n\t\tif(s[i]=='<')d[i]--;\n\t\telse if(s[i]=='>')d[i]++;\n\t\telse if(s[i]=='+')\n\t\t\tREP(t,2)v[i][t]=(v[i][t]+power(d[i],t))%mod[t];\n\t\telse\n\t\t\tREP(t,2)v[i][t]=(v[i][t]+mod[t]-power(d[i],t))%mod[t];\n\t}\n\tper(i,n-1,0){\n\t\tcnt[mp(v[i+1][0],v[i+1][1])]++;\n\t\tint A=(v[i][0]+(ll)power(d[i],0)*v[n][0])%mod[0];\n\t\tint B=(v[i][1]+(ll)power(d[i],1)*v[n][1])%mod[1];\n\t\tans+=cnt[mp(A,B)];\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author aajisaka\n */\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n#define SPEED ios_base::sync_with_stdio(false);cin.tie(nullptr)\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define all(v) v.begin(), v.end()\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing P = pair<ll, ll>;\n\nconstexpr long double PI = 3.14159265358979323846264338327950288L;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nconstexpr ll mod17 = 1e9+7;\nconstexpr ll mod19 = 1e9+9;\nconstexpr ll mod9 = 998244353;\nll mod = mod17;\n\n// Mod int libraries\ntemplate<typename T>\nT mod_pow(T a, ll x) {\n  T res = 1;\n  while(x > 0) {\n    if (x & 1) res *= a;\n    a *= a; x >>= 1;\n  }\n  return res;\n}\n\n// Mint32\nunordered_map<ll, ll> minvmap;\nll minv(ll a, ll m) {\n  auto k = a; auto p = minvmap[a]; if (p != 0) return p;\n  ll b = m, u = 1, v = 0;\n  while (b) { ll t = a/b; swap(a -= t*b, b); swap(u -= t*v, v); }\n  p = (u%m+m)%m; minvmap[k] = p; return p;\n}\n\nstruct mint {\n  ll x;\n  mint():x(0){}\n  mint(ll x):x((x%mod+mod)%mod){}\n  mint& fix() { x = (x%mod+mod)%mod; return *this;}\n  mint operator-() const { return mint(0) - *this;}\n  mint& operator+=(const mint& a){ if((x+=a.x)>=mod) x-=mod; return *this;}\n  mint& operator-=(const mint& a){ if((x+=mod-a.x)>=mod) x-=mod; return *this;}\n  mint& operator*=(const mint& a){ (x*=a.x)%=mod; return *this;}\n  mint& operator/=(const mint& a){ (x*=minv(a.x, mod))%=mod; return *this; }\n  mint operator+(const mint& a)const{ return mint(*this) += a;}\n  mint operator-(const mint& a)const{ return mint(*this) -= a;}\n  mint operator*(const mint& a)const{ return mint(*this) *= a;}\n  mint operator/(const mint& a)const{ return mint(*this) /= a;}\n  bool operator<(const mint& a)const{ return x < a.x;}\n  bool operator==(const mint& a)const{ return x == a.x;}\n};\n\n// Mint64\nstruct mint64 {\n    ull x;\n    static ull mod, inv, r2;\n    mint64(): x(0){}\n    mint64(ull x): x(init(x)) {}\n    static ull init(ull x) { return reduce(__uint128_t(x)*r2);}\n    static void set_mod(ull m) {\n      mod = inv = m;\n      for(int i=0; i<5; i++) inv *= 2 - inv*m;\n      r2 = -__uint128_t(m)%m;\n    }\n    static ull reduce(__uint128_t x) {\n      ull y = ull(x >> 64) - ull((__uint128_t(ull(x)*inv)*mod)>>64);\n      return ll(y) < 0 ? y+mod : y;\n    }\n    mint64& operator+=(mint64& a) { x+=a.x-mod; if(ll(x)<0) x+=mod; return *this; }\n    mint64 operator+(mint64& a) const{ return mint64(*this)+=a; }\n    mint64& operator*=(mint64& a) { x=reduce(__uint128_t(x)*a.x); return *this; }\n    mint64 operator*(mint64& a) const { return mint64(*this)*=a; }\n};\n\null mint64::mod, mint64::inv, mint64::r2;\n\n// Verify: https://yukicoder.me/submissions/472580\nstruct Miller {\n    const vector<ull> v = {2, 325, 9375, 28178, 450775, 9780504, 1795265022};\n    bool suspect(ull a, ull s, ull d, ull n) {\n      if (mint64::mod != n) mint64::set_mod(n);\n      mint64 one = 1, minusone = n-1, ma = a;\n      auto x = mod_pow(ma, d);\n      if (x.x == one.x) return true;\n      for(int r = 0; r < s; r++) {\n        if (x.x == minusone.x) return true;\n        x = x * x;\n      }\n      return false;\n    }\n\n    // check if n is prime\n    bool check(ull n) {\n      if (n < 2 || (n > 2 && n % 2 == 0)) return false;\n      ull d = n - 1;\n      ull s = 0;\n      while (!(d & 1)) {\n        d >>= 1;\n        s++;\n      }\n      for (auto a: v) {\n        if (a >= n) break;\n        if (!suspect(a, s, d, n)) return false;\n      }\n      return true;\n    }\n};\n\nclass combination {\n    // factorial\n    public: std::vector<mint> fact;\n    public: std::vector<mint> inv;\n\n    combination(int n) {\n      fact.resize(n + 1);\n      inv.resize(n + 1);\n      fact[0] = 1;\n      for (int i = 1; i <= n; i++) {\n        fact[i] = fact[i - 1] * i;\n      }\n      inv[n] = mint(1) / fact[n];\n      for (int i = n - 1; i >= 0; i--) {\n        inv[i] = inv[i + 1] * (i + 1);\n      }\n    }\n\n    // nCr\n    public: mint get(int n, int r) {\n      if (n < r || n < 0 || r < 0) return 0;\n      return fact[n]*inv[r]*inv[n-r];\n    }\n    // nPr\n    public: mint p(int n, int r) {\n      if (n < r || n < 0) return 0;\n      return fact[n]*inv[n-r];\n    }\n};\n\n\nclass FEatingSymbolsHard {\npublic:\n    void solve(istream& cin, ostream& cout) {\n      SPEED;\n      int n; cin >> n;\n      string s; cin >> s;\n      set<mint> st;\n      vector<mint> v(500001);\n      v[0] = mod9;\n      for(int i=1; i<=500000; i++) {\n        v[i] = v[i-1] * mod9;\n      }\n      int pos = 250000;\n      map<mint, ll> mp;\n\n      mint now = 0;\n      vector<pair<mint, int>> vec(n+1);\n      vec[0] = {now, pos};\n      rep(i, n) {\n        if (s[i] == '+') {\n          now += v[pos];\n        } else if (s[i] == '-') {\n          now -= v[pos];\n        } else if (s[i] == '>') {\n          pos++;\n        } else if (s[i] == '<') {\n          pos--;\n        }\n        debug(i, now.x, pos);\n        vec[i+1] = {now, pos};\n      }\n\n      now /= v[250000];\n      debug(now.x);\n\n      ll ans = 0;\n      for(int i=n; i>=0; i--) {\n        auto d2 = vec[i].second;\n        auto q = vec[i].first + now * v[d2];\n        if (mp.find(q) != mp.end()) {\n          ans += mp[q];\n        }\n        mp[vec[i].first]++;\n      }\n\n      cout << ans << endl;\n\n    }\n};\n\nsigned main() {\n  FEatingSymbolsHard solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_map>\nusing namespace std;\n \ntypedef unsigned long long ull;\nconst ull M=998244353;\nconst ull N=1000000007; \nconst ull X=99431;\nconst ull Y=99487;\null R;\null L;\nconst int W=1000;\n \n \null ModPow(ull x, ull n, ull mod) {\n        ull ret = 1;\n        for (; n > 0; n /= 2, x = (x * x) % mod)\n            if ((n & 1) == 1) ret = (ret * x) % mod;\n        return ret;\n    }\n \null has=0,vec=1;\null has2=0,vec2=1;\n \nint n;\nstring s;\nunordered_map<ull,int> B[550];\nlong long ans;\ninline void calc(char c, ull &u,ull &p,ull &v,ull &q){\n\tif(c=='+'){u+=p;v+=q;}\n\telse if(c=='-'){u+=M-p;v+=N-q;}\n\telse if(c=='>'){p=(p*X)%M;q=(q*Y)%N;}\n\telse {p=(p*R)%M;q=(q*L)%N;}\n\tif(u>=M)u-=M;\n\tif(v>=N)v-=N;\n}\nint main(){\n\tR=ModPow(X,M-2,M);\n\tL=ModPow(Y,N-2,N);\n\tcin>>n>>s;\n    //n=250000;\n    //s=string(n,'+');\n\tfor(int i=0;i<n;i++)calc(s[i],has,vec,has2,vec2);\n\tfor(int i=0;i<n;i++){\n\t\tif(i%W==0)continue;\n\t\tull h=0,x=1,hh=0,y=1;\n\t\tfor(int j=i;j<n;j++){\n\t\t\tif(j%W==0)break;\n\t\t\tcalc(s[j],h,x,hh,y);\n\t\t\tif(h==has&&hh==has2)ans++;\n\t\t}\n\t\tull nh = (has+M-h)%M;\n\t\tnh = nh * ModPow(x,M-2,M)%M;\n\t\tull nh2 = (has2+N-hh)%N;\n\t\tnh2 = nh2 * ModPow(y,N-2,N)%N;\n\t\tB[i/W+1][nh*N+nh2]++;\n\t}\n\tfor(int i=0;i<n;i+=W){\n\t\tull h=0,x=1,hh=0,y=1;\n\t\tfor(int j=i;j<n;j++){\n\t\t\tcalc(s[j],h,x,hh,y);\n\t\t\tif(h==has&&hh==has2)ans++;\n\t\t\tauto it = B[i/W].find(h*N+hh);\n\t\t\tif(it!=B[i/W].end())ans+=it->second;\n\t\t}\n\t}\n\t\n\tcout<<ans;\n \n \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define pb push_back\n#define eb emplace_back\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\n    os<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\n    os<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\ntemplate<class S, class T> pair<S,T> operator*(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first*t.first, s.second*t.second);}\ntemplate<class S, class T> pair<S,T> operator%(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first%t.first, s.second%t.second);}\n\ninline ll mod_inverse(ll a, ll m){\n    ll b = m, u = 1, v = 0;\n    while (b) {\n        ll t = a / b;\n        swap(a -= t * b, b);\n        swap(u -= t * v, v);\n    }\n    return (u % m + m) % m;\n}\n\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst pll MOD = pii(1000000021, 1000000009);\n\nconst pll B = pll(10007, 10007);\nconst pll iB = pll(mod_inverse(10007, 1000000021), mod_inverse(10007, 1000000009));\n\nint T, n, m;\nstring s;\nint main(int argc, char *argv[]){\n    ios::sync_with_stdio(false);\n    cin >> n >> s;\n    pll h = pll(0, 0), b = pll(1, 1);\n    for (char c : s) {\n        if (c == '+') h = (h + b) % MOD;\n        if (c == '-') h = (h + MOD - b) % MOD;\n        if (c == '>') b = b * B % MOD;\n        if (c == '<') b = b * iB % MOD;\n    }\n    const pll target = h;\n    ll ans = 0;\n    map<pll, ll> mp;\n    mp[pll(0, 0)] = 1;\n    h = pll(0, 0), b = pll(1, 1);\n    for (char c : s) {\n        if (c == '+') h = (h + b) % MOD;\n        if (c == '-') h = (h + MOD - b) % MOD;\n        if (c == '>') b = b * B % MOD;\n        if (c == '<') b = b * iB % MOD;\n\n        ans += mp[(h + MOD - target) % MOD];\n        mp[(h + target * b + MOD - target) % MOD] ++;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int MOD = 1e9 + 7;\n\nint inv(int a)\n{\n    assert(a);\n    return a == 1 ? 1 : 1LL * (MOD - MOD / a) * inv(MOD % a) % MOD;\n}\n\nstruct Mat\n{\n    Mat()\n    {\n        memset(a, 0, sizeof(a));\n    }\n\n    Mat inv() const\n    {\n        int det = (1LL * a[0][0] * a[1][1] + MOD - 1LL * a[0][1] * a[1][0] % MOD) % MOD;\n        int inv_det = ::inv(det);\n        Mat b;\n        b[0][0] = 1LL * inv_det * a[1][1] % MOD;\n        b[0][1] = 1LL * inv_det * (MOD - a[0][1]) % MOD;\n        b[1][0] = 1LL * inv_det * (MOD - a[1][0]) % MOD;\n        b[1][1] = 1LL * inv_det * a[0][0] % MOD;\n        return b;\n    };\n\n    std::pair<int, int> get() const\n    {\n        return {a[0][0], a[1][0]};\n    }\n\n    int* operator[](int i) { return a[i]; }\n    const int* operator[](int i) const { return a[i]; }\n\n    int a[2][2];\n};\n\nMat operator * (const Mat& a, const Mat& b)\n{\n    Mat c;\n    for (int i = 0; i < 2; ++ i) {\n        for (int j = 0; j < 2; ++ j) {\n            c[i][j] = (1LL * a[i][0] * b[0][j] + 1LL * a[i][1] * b[1][j]) % MOD;\n        }\n    }\n    return c;\n}\n\nint main()\n{\n#ifdef LOCAL_JUDGE\n    freopen(\"D.in\", \"r\", stdin);\n#endif\n    int n;\n    scanf(\"%d\", &n);\n    std::vector<char> s(n + 1);\n    scanf(\"%s\", s.data());\n\n    const int z = 2;\n    const int inv_z = inv(z);\n\n    std::vector<Mat> prod(n + 1);\n    prod[n][0][0] = prod[n][1][1] = 1;\n    // 0 const\n    for (int i = n - 1; i >= 0; -- i) {\n        Mat e;\n        e[0][0] = e[1][1] = 1;\n        if (s[i] == '+') {\n            e[1][0] = 1;\n        } else if (s[i] == '-') {\n            e[1][0] = MOD - 1;\n        } else if (s[i] == '>') {\n            e[1][1] = z;\n        } else if (s[i] == '<') {\n            e[1][1] = inv_z;\n        }\n        prod[i] = e * prod[i + 1];\n    }\n    std::map<std::pair<int, int>, int> m;\n    long long result = 0;\n    for (int i = 0; i <= n; ++ i) {\n        auto I = prod[i].inv();\n        result += m[I.get()];\n        m[(I * prod[0]).get()] ++;\n    }\n    printf(\"%lld\\n\", result);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define int long long\n#define ull unsigned long long\n\nconst int Maxv = 1000010; \nconst ull Prime1 = 239; \nconst ull Prime2 = 213658850274627977; \n                            \nint idx[Maxv], ans, n; \null Hash[Maxv], val[Maxv]; \nchar s[Maxv]; \n\nstd::map<ull, int> Map; \n\ninline void PreHandle() {\n    val[n] = 1; \n    for (int i = n + 1; i <= (n << 1); i++)\n        val[i] = val[i - 1] * Prime1; \n    for (int i = n - 1; i >= 0; i--)\n        val[i] = val[i + 1] * Prime2; \n}\n\nsigned main() {\n    scanf(\"%lld\", &n); \n    scanf(\"%s\", s); \n\n    PreHandle(); \n\n    for (int i = 0; i < n; i++) {\n        Hash[i + 1] = Hash[i]; \n        idx[i + 1] = idx[i]; \n\n        if (s[i] == '>')\n            idx[i + 1]++; \n        if (s[i] == '<')\n            idx[i + 1]--;\n        if (s[i] == '+')\n            Hash[i + 1] += val[n + idx[i + 1]]; \n        if (s[i] == '-')\n            Hash[i + 1] -= val[n + idx[i + 1]]; \n    }\n    \n    for (int i = n; i >= 0; i--) {\n        ull tmp = Hash[i] + Hash[n] * val[n + idx[i]];\n        ans += Map[tmp]; \n        Map[ Hash[i] ]++;\n    }\n\n    printf(\"%lld\\n\", ans);\n\n    return 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,NAME,...) NAME\n#define pr(...) cerr<< GET_MACRO(__VA_ARGS__,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__) <<endl\n#define pr1(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr2(a,b) pr1(a)<<pr1(b)\n#define pr3(a,b,c) pr1(a)<<pr2(b,c)\n#define pr4(a,b,c,d) pr1(a)<<pr3(b,c,d)\n#define pr5(a,b,c,d,e) pr1(a)<<pr4(b,c,d,e)\n#define pr6(a,b,c,d,e,f) pr1(a)<<pr5(b,c,d,e,f)\n#define pr7(a,b,c,d,e,f,g) pr1(a)<<pr6(b,c,d,e,f,g)\n#define pr8(a,b,c,d,e,f,g,h) pr1(a)<<pr7(b,c,d,e,f,g,h)\nusing namespace std;\nusing Int = long long;\nusing ll = long long;\nusing Double = long double;\nconst Int INF = (1LL<<55)+1e9; // ~ 3.6 * 1e16\nconst Double EPS = 1e-8;\nconst Double PI = 6.0 * asin((Double)0.5);\nusing P = pair<Int,Int>;\nusing T = tuple<Int,Int,Int>;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nostream& operator<<(ostream& o,T t){return o<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){Int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){Int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\nconst Int N = 300000;\n\nconstexpr ll mod_pow(ll x, ll n, Int mod){\n  return n == 0? 1:(n%2? x:1) * mod_pow((x*x)%mod,n/2, mod) % mod;\n}  \n\nconstexpr ll mod_inv(Int num,Int mod){return mod_pow(num, mod-2, mod);}\nconst ll mod[] = {1000000007,1000000009,1000000021};\nconst ll B[]= {1777771,10000019,10000079};\nconst ll inv[] = {mod_inv(B[0],mod[0]), mod_inv(B[1],mod[1]),mod_inv(B[2],mod[2])};\n\nclass Hash{\npublic:\n\n  ll num;\n  ll idx;\n  vector<ll> K;\n  Int b;\n  Hash(Int b):b(b){\n    K.resize(N);\n    K[0] = 1;\n    for(Int i=1;i<N;i++) K[i] = K[i-1] * B[b] % mod[b];\n    num = 0;\n    idx = K[N/2];\n  }\n\n  void inc(){num = (num + idx) % mod[b];}\n  void dec(){num = (num - idx + mod[b]) % mod[b];}\n  void moveLeft(){idx = idx * inv[b] % mod[b];}\n  void moveRight(){idx = idx * B[b] % mod[b];}\n  \n};\n\n\nsigned main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  Int n;\n  cin>>n;\n  string s;\n  cin>>s;\n\n  vector<map<ll,Int> > cnt(3);\n  vector<Hash> hash{Hash(0), Hash(1), Hash(2)};\n  vector<Hash> hash2 = hash;\n  \n  for(Int k = 0; k<n ; k++){\n    char ch = s[k];\n    for(Int i=0;i<3;i++){\n      auto &A = hash[i];\n      if(ch == '+') A.inc();\n      if(ch == '-') A.dec();\n      if(ch == '<') A.moveLeft();\n      if(ch == '>') A.moveRight();\n      cnt[i][A.num]++;\n    }\n  }\n\n  vector<ll> allHash(3);\n  vector<ll> Ofset(3,0);\n  for(Int i=0;i<3;i++) allHash[i] = hash[i].num;\n  \n  Int ans = 0;\n  for(Int k=0;k<n;k++){\n    \n    char ch = s[k];\n    Int mn = INF;\n    for(Int i=0;i<3;i++){\n      auto &A = hash2[i];\n      auto &U = allHash[i];\n      auto &X = Ofset[i];\n      ll val = (U - X + mod[i]) % mod[i];\n      Min(mn, cnt[i][val]);\n      //pr(U, X, (U + X)%mod[i], A.num);\n      if(ch == '+') X = (X - A.idx + mod[i]) % mod[i], A.inc();\n      if(ch == '-') X = (X + A.idx + mod[i]) % mod[i], A.dec();\n      if(ch == '>') U = U * B[i] % mod[i], A.moveRight();\n      if(ch == '<') U = U * inv[i] % mod[i], A.moveLeft();\n      assert(cnt[i][A.num] != 0);\n      cnt[i][A.num]--;\n    }\n    ans += mn;\n  }\n  cout<<ans<<endl;\n  \n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int WWW = 0;WWW < (n);WWW++)cerr << v[WWW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nconst ll mod1 = 1000000007;\nconst ll mod2 = 1000000009;\nconst ll seica1 = 114514;\nconst ll seica2 = 1919810;\n\n#define NODE 555555\npair<ll,ll> f[2][NODE];\nll mod[] = {1000000007,1000000009};\nll kake[] = {114514,1919810};\nll inv[2];\nint n;\nstring str;\nmap<pair<ll,ll>,ll> mp;\n\nll m_pow(ll a,ll b,ll p){\n\tll ret = 1;\n\tll tmp = a;\n\tfor(ll i = 0LL;i < 60;i++){\n\t\tif(b & (1LL << i)){\n\t\t\tret *= tmp;\n\t\t\tret %= p;\n\t\t}\n\t\ttmp *= tmp;\n\t\ttmp %= p;\n\t}\n\treturn ret;\n}\n\nll m_inv(ll a,ll p){\n\treturn m_pow(a,p-2,p);\n}\n\nvoid get_f(int num,int type){\n\tpair<ll,ll> now = MP(1,0);\n\tpair<ll,ll> prev;\n\tif(num == n-1){\n\t\tprev = MP(1,0);\n\t}\n\telse{\n\t\tprev = f[type][num+1];\n\t}\n\t\n\tif(str[num] == '<'){\n\t\tnow.FI = kake[type];\n\t}\n\telse if(str[num] == '>'){\n\t\tnow.FI = inv[type];\n\t}\n\telse if(str[num] == '+'){\n\t\tnow.SE = mod[type] - 1;\n\t}\n\telse{\n\t\tnow.SE++;\n\t}\n\t\n\tll fir = now.FI * prev.FI % mod[type];\n\tll sec = (now.SE * prev.FI % mod[type] + prev.SE) % mod[type];\n\tf[type][num] = MP(fir,sec);\n}\n\npair<ll,ll> dfs(int num,int type){\n\tpair<ll,ll> now = MP(1,0);\n\tpair<ll,ll> prev;\n\tif(num == 0){\n\t\tprev = MP(1,0);\n\t}\n\telse{\n\t\tprev = dfs(num-1,type);\n\t}\n\t\n\tif(str[num] == '>'){\n\t\tnow.FI = kake[type];\n\t}\n\telse if(str[num] == '<'){\n\t\tnow.FI = inv[type];\n\t}\n\telse if(str[num] == '-'){\n\t\tnow.SE = mod[type] - 1;\n\t}\n\telse{\n\t\tnow.SE++;\n\t}\n\t\n\tll fir = now.FI * prev.FI % mod[type];\n\tll sec = (now.SE * prev.FI % mod[type] + prev.SE) % mod[type];\n\treturn MP(fir,sec);\n}\n\nll get_x(ll x,ll num,ll type){\n\treturn (f[type][num].FI * x % mod[type] + f[type][num].SE) % mod[type];\n}\n\nint main(){\n\t\n\tinv[0] = m_inv(kake[0],mod[0]);\n\tinv[1] = m_inv(kake[1],mod[1]);\n\t\n\tcin >> n >> str;\n\tfor(int i = str.size()-1;i >= 0;i--){\n\t\tget_f(i,0);\n\t\tget_f(i,1);\n\t}\n\t\n\tll c[2] = {dfs(n-1,0).SE,dfs(n-1,1).SE};\n\t\n\tll ans = 0;\n\tmp[{0,0}]++;\n\tfor(int i = str.size()-1;i >= 0;i--){\n\t\tans += mp[{get_x(c[0],i,0),get_x(c[1],i,1)}];\n\t\tmp[{get_x(0,i,0),get_x(0,i,1)}]++;\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n      \n#define FOR(i,a,b) for(ll i = (a); i < (ll)(b); i++)\n#define REP(i,n) FOR(i,0,n)\n#define YYS(x,arr) for(auto& x:arr)\n#define PW(x) (1LL<<(x))\n#define SZ(x) ((ll)(x).size())\n\n#define pb emplace_back\n#define fi first\n#define se second\n\nusing namespace std;\n\nusing ld = long double;\nusing ll = long long int;\n\nconst ll INF = (ll)1e9 + 10;\nconst ll INFLL = (ll)1e18 + 10;\nconst ll MOD = 1e9+7;\n     \ntemplate<class T> T &chmin( T &a , const T &b ){ return a = min(a,b); }\ntemplate<class T> T &chmax( T &a , const T &b ){ return a = max(a,b); }\ntemplate<class T> void UNIQUE(vector<T> &a){ a.erase(unique(a.begin(), a.end()), a.end()); }\n\ntemplate<class S, class T> ostream& operator << (ostream& os, const pair<S, T> v){\n  os << \"(\" << v.first << \", \" << v.second << \")\"; return os;\n}\ntemplate<class T> ostream& operator << (ostream& os, const vector<T> v){\n  for(int i = 0; i < v.size(); i++){if(i > 0){os << \" \";} os << v[i];} return os;\n}\ntemplate<class T> ostream& operator << (ostream& os, const vector<vector<T>> v){\n  for(int i = 0; i < v.size(); i++){if(i > 0){os << endl;} os << v[i];} return os;\n}\n\nll in(){long long int x; scanf(\"%lld\", &x); return x;}\nld fin(){double x; scanf(\"%lf\", &x); return x;}\nchar yuyushiki[1000010]; string stin(){scanf( \"%s\", yuyushiki ); return yuyushiki;}\n\n// head\n\n\nstruct Mod{\n  unsigned n;\n  Mod() : n(0){}\n  Mod( ll x ){\n    if( x < 0 ) n = x%MOD+MOD;\n    else n = x%MOD;\n  }\n};\nMod operator + ( Mod a  , Mod b ){ return Mod( a.n + b.n ); }\nMod operator +=( Mod &a , Mod b ){ return a = a + b; }\nMod operator - ( Mod a ){ return Mod( MOD - a.n ); }\nMod operator - ( Mod a  , Mod b ){ return Mod( a.n + MOD - b.n ); }\nMod operator -=( Mod &a , Mod b ){ return a = a - b; }\nMod operator * ( Mod a  , Mod b ){ return Mod( (ll)a.n * b.n ); }\nMod operator *=( Mod &a , Mod b ){ return a = a * b; }\nMod modpow( Mod x , ll k ){\n  Mod res = 1;\n  while( k ){\n    if( k & 1 ) res *= x;\n    k /= 2;\n    x *= x;\n  }\n  return res;\n}\nll extgcd( ll a , ll b , ll &x , ll &y ){\n  ll d = a;\n  if( b != 0 ){\n    d = extgcd( b , a % b , y , x );\n    y -= a / b * x;\n  } else {\n    x = 1, y = 0;\n  }\n  return d;\n}\nMod inv( Mod a ){ ll x, y; assert( extgcd( a.n , MOD , x , y ) == 1 ); return Mod( x ); }\nMod operator / ( Mod a  , Mod b ){ return Mod( (ll)a.n * inv(b).n ); }\nMod operator /=( Mod &a , Mod b ){ return a = a / b; }\n\n\n\n/*\nconst ll MUL[3] = { 72727 , 51419 , 79393  };\nconst ll RHMOD[3] = { 1000000007 , 765876961 , 727272727 };\n*/\n\nconst ll B = 72727;\nconst ll N = 500020;\n\nint n;\nstring s;\n\nMod cur;\nll state[N];\nll ps[N];\n\nMod e[N];\n\nint main(){\n\n  e[0] = 1;\n  FOR(i, 1, N){\n    e[i] = e[i-1] * B;\n  }\n\n  n = in();\n  s = stin();\n\n  ll start = 250010;\n  ll p = start;\n\n  REP(i, n){\n    state[i] = cur.n;\n    ps[i] = p;\n    // cout << state[i] << \" \" << ps[i] << endl;\n    if(s[i] == '+'){\n      cur += e[p];\n    } else if(s[i] == '-'){\n      cur -= e[p];\n    } else if(s[i] == '>'){\n      p++;\n    } else if(s[i] == '<'){\n      p--;\n    }\n  }\n  state[n] = cur.n;\n  // cout << state[n] << \" \" << p << endl;\n\n  map<ll, ll> cnt;\n  ll ans = 0;\n\n  /*\n  {\n    Mod hoge = Mod(state[3]) - state[1];\n    cout << hoge.n << \" \" << cur.n << endl;\n    cout << (cur + state[1]).n << \" \" << state[3] << endl;\n    return 0;\n  }\n  */\n\n  \n  for(int i = n; i >= 0; i--){\n    if(cnt.find(state[i]) == cnt.end()){\n      cnt[state[i]] = 1;\n    } else {\n      cnt[state[i]] += 1;\n    }\n    if(i > 0){\n      ll j = i - 1;\n\n      Mod mokuhyo = 0;\n      if(ps[j] >= start){\n        mokuhyo = cur * e[ps[j]-start] + state[j];\n      } else {\n        mokuhyo = cur / e[start-ps[j]] + state[j];\n      }\n      // cout << j << \" \" << ps[j] << \" \" << state[j] << \" \" << mokuhyo.n << endl;\n      ans += cnt[mokuhyo.n];\n    }\n  }\n\n  cout << ans << endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\n\nconst int mod0 = 1e9 + 7;\nconst int mod1 = 1e9 + 9;\nconst int mod2 = 1e9 + 21;\nconst int base = 10007;\n\nint64_t power(int64_t x, int64_t n, int64_t mod) {\n  int64_t ret = 1;\n  while(n > 0) {\n    if(n & 1) (ret *= x) %= mod;\n    (x *= x) %= mod;\n    n >>= 1;\n  }\n  return ret;\n}\n\n\nint64 h0[550001], g0[550001];\nint64 h1[550001], g1[550001];\nint64 h2[550001], g2[550001];\n\n\nint main() {\n\n  h0[0] = h1[0] = h2[0] = 1;\n  for(int i = 1; i < 550001; i++) {\n    h0[i] = h0[i - 1] * base % mod0;\n    h1[i] = h1[i - 1] * base % mod1;\n    h2[i] = h2[i - 1] * base % mod2;\n  }\n  g0[550000] = power(h0[550000], mod0 - 2, mod0);\n  g1[550000] = power(h1[550000], mod1 - 2, mod1);\n  g2[550000] = power(h2[550000], mod2 - 2, mod2);\n  for(int i = 549999; i >= 0; i--) {\n    g0[i] = g0[i + 1] * (i + 1) % mod0;\n    g1[i] = g1[i + 1] * (i + 1) % mod1;\n    g2[i] = g2[i + 1] * (i + 1) % mod2;\n  }\n\n  int N;\n  string S;\n\n  cin >> N;\n  cin >> S;\n\n  vector< int64 > latte0, malta0;\n  vector< int64 > latte1, malta1;\n  vector< int64 > latte2, malta2;\n  int64 beet = 0, pos = 250001;\n  latte0.push_back(pos), malta0.push_back(beet);\n  latte1.push_back(pos), malta1.push_back(beet);\n  latte2.push_back(pos), malta2.push_back(beet);\n  for(int i = 0; i < N; i++) {\n    char c = S[i];\n    if(c == '+') (beet += h0[pos]) %= mod0;\n    else if(c == '-') (beet += mod0 - h0[pos]) %= mod0;\n    else if(c == '<') --pos;\n    else ++pos;\n    latte0.push_back(pos), malta0.push_back(beet);\n  }\n  beet = 0, pos = 250001;\n  for(int i = 0; i < N; i++) {\n    char c = S[i];\n    if(c == '+') (beet += h1[pos]) %= mod1;\n    else if(c == '-') (beet += mod1 - h1[pos]) %= mod1;\n    else if(c == '<') --pos;\n    else ++pos;\n    latte1.push_back(pos), malta1.push_back(beet);\n  }\n  beet = 0, pos = 250001;\n\n  for(int i = 0; i < N; i++) {\n    char c = S[i];\n    if(c == '+') (beet += h2[pos]) %= mod2;\n    else if(c == '-') (beet += mod2 - h2[pos]) %= mod2;\n    else if(c == '<') --pos;\n    else ++pos;\n    latte2.push_back(pos), malta2.push_back(beet);\n  }\n\n\n  map< tuple< int64, int64, int64 >, int > mp;\n  int64 ret = 0;\n  for(int i = N; i >= 0; i--) {\n    int64 dx = latte0[i] - latte0[0];\n    int64 mul0, mul1, mul2;\n    if(dx >= 0) mul0 = h0[dx], mul1 = h1[dx], mul2 = h1[dx];\n    else mul0 = g0[-dx], mul1 = g1[-dx], mul2 = g2[-dx];\n    ret += mp[{(malta0[i] + malta0[N] * mul0) % mod0, (malta1[i] + malta1[N] * mul1) % mod1, (malta2[i] + malta2[N] * mul2) % mod2}];\n    ++mp[{malta0[i], malta1[i], malta2[i]}];\n  }\n  cout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long D;\nconst int maxn=500005,mod1=1000000007,mod2=1000000009;\nint qpow(int x,int y,int mod){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1)ans=D(ans)*x%mod;\n\t\tx=D(x)*x%mod;\n\t\ty>>=1;\n\t}\n\treturn ans;\n}\nint n;\nchar s[maxn];\nstruct H{\n\tint a,b;\n\tH():a(0),b(0){}\n\tH(int _a,int _b):a(_a),b(_b){}\n\tH operator+(const H &x)const{return H((a+x.a)%mod1,(b+x.b)%mod2);}\n\tH operator-(const H &x)const{return H((a-x.a+mod1)%mod1,(b-x.b+mod2)%mod2);}\n\tH operator*(const H &x)const{return H((D)a*x.a%mod1,(D)b*x.b%mod2);}\n\tbool operator<(const H &x)const{return a!=x.a?a<x.a:b<x.b;}\n}b,inv,f[maxn],g[maxn];\nmap<H,int> mp;\nint main(){\n\tb=H(23,29),inv=H(qpow(23,mod1-2,mod1),qpow(29,mod2-2,mod2));\n\tscanf(\"%d%s\",&n,s+1);\n\tg[0]=H(1,1);\n\tfor(int i=1;i<=n;i++){\n\t\tf[i]=f[i-1],g[i]=g[i-1];\n\t\tif(s[i]=='+')f[i]=f[i]+g[i];\n\t\tif(s[i]=='-')f[i]=f[i]-g[i];\n\t\tif(s[i]=='<')g[i]=g[i]*inv;\n\t\tif(s[i]=='>')g[i]=g[i]*b;\n\t\tmp[f[i]]++;\n\t}\n\tD ans=0;\n\tfor(int i=1;i<=n;i++){\n\t\tans+=mp[f[i-1]+g[i-1]*f[n]];\n\t\tmp[f[i]]--;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <vector>\n\nconst int DEBUG = 0;\n\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define DEBUGP(val) cerr << #val << \"=\" << val << \"\\n\"\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\ntypedef pair<ll, ll> PL;\n\n\nconst int A = 7;\n\nconst ll mod = 1e9 + 7;\n\ntemplate<ll mod = (ll)1e9 + 7>\nstruct ModInt {\n  ll x;\n  ModInt(void): x(0) {}\n  ModInt(ll x): x(x % mod){}\n  ModInt(const ModInt &x): x(x.x) {}\n  ModInt operator+(ModInt o) const {\n    ll y = x + o.x;\n    if (y >= mod) y -= mod;\n    return ModInt(y);\n  }\n  ModInt operator-(ModInt o) const {\n    ll y = x - o.x + mod;\n    if (y >= mod) y -= mod;\n    return ModInt(y);\n  }\n  ModInt operator*(ModInt o) const {\n    return ModInt((x * o.x) % mod);\n  }\n  ll to_ll() const {\n    return x;\n  }\n  bool operator<(ModInt o) const {\n    return x < o.x;\n  }\n  ModInt pow(ll e) {\n    assert (e >= 0);\n    ModInt sum = 1;\n    ModInt cur = *this;\n    while (e > 0) {\n      if (e % 2) {\n        sum = sum * cur;\n      }\n      cur = cur * cur;\n      e /= 2;\n    }\n    return sum;\n  }\n  ModInt inv(void) {\n    return pow(mod - 2);\n  }\n};\n\ntemplate<ll mod>\nostream &operator<<(ostream &os, ModInt<mod> mi) {\n  return os << mi.x;\n}\n\n\nint main(void) {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  string s;\n  cin >> n >> s;\n  int p = 0;\n  VI pos(n + 1);\n  mt19937 mt;\n  vector<ModInt<> > b(A);\n  \n  REP(c, 0, A) {\n    do {\n      b[c] = mt();\n    } while (b[c].to_ll() == 0);\n  }\n  vector<vector<ModInt<> > > hsh(A, vector<ModInt<> >(n + 1));\n  ModInt<> inv[A] = { 0 };\n  REP(c, 0, A) inv[c] = b[c].inv();\n  REP(c, 0, A) {\n    p = 0;\n    ModInt<> cur = 1;\n    REP(i, 0, n) {\n      ModInt<> tmp = hsh[c][i];\n      if (s[i] == '>') {\n        p++;\n        cur = cur * b[c];\n      }\n      if (s[i] == '<') {\n        p--;\n        cur = cur * inv[c];\n      }\n      if (s[i] == '+') {\n        tmp = tmp + cur;\n      }\n      if (s[i] == '-') {\n        tmp = tmp - cur;\n      }\n      hsh[c][i + 1] = tmp;\n      pos[i + 1] = p;\n    }\n  }\n  if (DEBUG) {\n    REP(i, 0, n + 1) {\n      cerr << i << \" \" << hsh[0][i] << endl;\n    }\n  }\n  vector<ModInt<> > meguru(A);\n  REP(c, 0, A) meguru[c] = hsh[c][n];\n  map<vector<ModInt<> >, int> kirika;\n  kirika[meguru] = 1;\n  ll tot = 0;\n  vector<ModInt<> > cur(A);\n  REP(c, 0, A) cur[c] = b[c].pow(mod - 1 + pos[n]);\n  for (int i = n - 1; i >= 0; --i) {\n    if (DEBUG) {\n      DEBUGP(i);\n      DEBUGP(pos[i]);\n    }\n    if (pos[i + 1] - pos[i] == 1) {\n      REP(c, 0, A) cur[c] = cur[c] * inv[c];\n    }\n    else if (pos[i + 1] - pos[i] == -1) {\n      REP(c, 0, A) cur[c] = cur[c] * b[c];\n    }\n    vector<ModInt<> > ken(A);\n    REP(c, 0, A) ken[c] = cur[c] * meguru[c] + hsh[c][i];\n    tot += kirika[ken];\n    vector<ModInt<> > tt(A);\n    REP(c, 0, A) tt[c] = hsh[c][i];\n    kirika[tt] += 1;\n  }\n  cout << tot << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <iostream>\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define debug(x) cout<<#x<<\" :: \"<<x<<endl;\n#define debug2(x,y) cout<<#x<<\" :: \"<<x<<\"\\t\"<<#y<<\" :: \"<<y<<endl;\n#define debug3(x,y,z) cout<<#x<<\" :: \"<<x<<\"\\t\"<<#y<<\" :: \"<<y<<\"\\t\"<<#z<<\" :: \"<<z<<endl;\n\n#define boost ios::sync_with_stdio(0); cin.tie(0)\n\n#define fi first\n#define se second\n\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\n\nconst int N = 1e6 + 5;\nconst int MOD1 = 1934559071;\nconst int MOD2 = 1544907697;\nconst int B = 257707;\n\n/***************************************************************************/\n\nll power(ll a, ll n, ll m) {\n\tif(n == 0) return 1;\n\tll p = power(a, n>>1, m);\n\tp = (p * p) % m;\n\tif(n & 1) p = (p * a) % m;\n\treturn p;\n}\n\nstring S;\npii powB[N];\n\ninline pii& pow(int n) {\n\tif(n < 0) n += N;\n\treturn powB[n];\n}\n\nmap<ll, int> M;\n\nint main() {\n\n\tboost;\n\tint N; cin>>N;\n\tcin>>S;\n\n\tpow(-B) = pii(power(power(B, B, MOD1), MOD1-2, MOD1), power(power(B, B, MOD2), MOD2-2, MOD2));\n\tfor(int i=-B+1; i<=B; i++) {\n\t\tpow(i) = pii((B * 1LL * pow(i-1).fi) % MOD1, (B * 1LL * pow(i-1).se) % MOD2);\n\t}\n\n\tll phas1, phas2, chas1, chas2;\n\tphas1 = phas2 = chas1 = chas2 = 0;\n\n\tint p = 0;\n\tfor(auto it : S) {\n\t\tif(it == '+') phas1 += pow(p).fi, phas2 += pow(p).se;\n\t\telse if(it == '-') phas1 -= pow(p).fi, phas2 -= pow(p).se;\n\t\telse if(it == '>') p++;\n\t\telse p--;\n\t}\n\n\tphas1 %= MOD1; if(phas1 < 0) phas1 += MOD1;\n\tphas2 %= MOD2; if(phas2 < 0) phas2 += MOD2;\n\n\tll ans = 0;\n\tM[(phas1 << 32) | phas2]++;\n\n\tfor(auto it : S) {\n\t\tif(it == '+') chas1 = (chas1 + pow(p).fi) % MOD1, chas2 = (chas2 + pow(p).se) % MOD2;\n\t\telse if(it == '-') chas1 = (chas1 - pow(p).fi + MOD1) % MOD1, chas2 = (chas2 - pow(p).se + MOD2) % MOD2;\n\t\telse if(it == '>') p++;\n\t\telse p--;\n\n\t\tans += M[(chas1 << 32) | chas2];\n\t\t\n\t\tll has1 = (chas1 + pow(p).fi * phas1) % MOD1;\n\t\tll has2 = (chas2 + pow(p).se * phas2) % MOD2;\n\n\t\tM[(has1 << 32) | has2]++;\n\t}\n\n\tcout<<ans<<\"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\nusing namespace std;\n\n#define P1 1000000007LL\n#define P2 1000000009LL\ntypedef long long Int;\nmap<Int, Int> cs;\nInt sum[250001];\nInt pos[250001];\nInt res;\nInt n;\nstring str;\nInt pow(Int x, Int y, Int M){\n\tif(y < 0){\n\t\ty %= M-1;\n\t\tif(y < 0);\n\t\ty += M-1;\n\t}\n\tif(y == 0)return 1;\n\tInt res = pow(x, y/2, M);\n\tres = res * res % M;\n\tif(y % 2)res *= x;\n\treturn x % M;\n}\n\nInt rev(Int x, Int M){\n\treturn pow(x, M-2, M);\n}\n\nint main(){\n\tInt p = 0;\n\tInt tmp = 0;\n\tcin >> n;\n\tcin >> str;\n\tfor(int i = 0;i < n;i++){\n\t\tif(str[i] == '+')tmp = (tmp + pow(1000000, p, P1))%P1;\n\t\tif(str[i] == '-')tmp = (tmp - pow(1000000, p, P1))%P1;\n\t\tif(str[i] == '>')p++;\n\t\tif(str[i] == '<')p--;\n\t\tsum[i+1] = tmp;\n\t\tpos[i+1] = p;\n\n\t}\n\tInt last = sum[n];\n\tfor(int i = n;i >= 0;i--){\n\t\tInt tmp = ((last - last * pow(1000000, pos[i], P1) % P1) % P1 + P1)% P1;\n\t\tres += cs[(tmp - sum[i] + P1) % P1];\n\t\tInt c = (last - sum[i] +P1) % P1;\n\t\tif(cs.count(c) == 0)cs[c] = 0;\n\t\tcs[c]++;\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\n\nint N;\nstring S;\nll mo=1000000007;\nvector<ll> C,R;\nconst int PAT=5;\nvector<ll> A[PAT];\nvector<ll> B[PAT];\n\nll modpow(ll a, ll n = mo-2) {\n\tll r=1;a%=mo;\n\twhile(n) r=r*((n%2)?a:1)%mo,a=a*a%mo,n>>=1;\n\treturn r;\n}\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>S;\n\tsrand(time(NULL));\n\tFOR(i,PAT) {\n\t\tC.push_back(rand()%10000000+10000000);\n\t\tR.push_back(modpow(C.back()));\n\t\tA[i].push_back(1);\n\t\tB[i].push_back(0);\n\t}\n\treverse(ALL(S));\n\tFORR(c,S) {\n\t\tFOR(i,PAT) {\n\t\t\tif(c=='+') {\n\t\t\t\tA[i].push_back(A[i].back());\n\t\t\t\tB[i].push_back((B[i].back()+1)%mo);\n\t\t\t}\n\t\t\tif(c=='-') {\n\t\t\t\tA[i].push_back(A[i].back());\n\t\t\t\tB[i].push_back((B[i].back()+mo-1)%mo);\n\t\t\t}\n\t\t\tif(c=='>') {\n\t\t\t\tA[i].push_back(A[i].back()*C[i]%mo);\n\t\t\t\tB[i].push_back(B[i].back()*C[i]%mo);\n\t\t\t}\n\t\t\tif(c=='<') {\n\t\t\t\tA[i].push_back(A[i].back()*R[i]%mo);\n\t\t\t\tB[i].push_back(B[i].back()*R[i]%mo);\n\t\t\t}\n\t\t}\n\t}\n\tll ret=0;\n\tmap<vector<ll>,int> memo;\n\tmemo[vector<ll>(PAT,0)]++;\n\tFOR(j,N) {\n\t\tvector<ll> BA(PAT),BAS(PAT);\n\t\tFOR(i,PAT) {\n\t\t\tBA[i]=B[i][j+1]*A[i][j+1]%mo;\n\t\t\tBAS[i]=(B[i][j+1]+mo-B[i].back())*A[i][j+1]%mo;\n\t\t}\n\t\tret+=memo[BAS];\n\t\tmemo[BA]++;\n\t}\n\tcout<<ret<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 1004535809\n#define lim 300000\nusing namespace std;\nint n;\nchar s[300005];\nlong long A, base[600005], lsp, p, suf[300005], pre;\nmap<long long, int> cnt;\nint fsp(long long bs, int p) {\n    int rt = 1;\n    while (p) {\n        if (p & 1) rt = bs * rt % mod;\n        bs = bs * bs % mod, p >>= 1;\n    }\n    return rt;\n}\n\nlong long bs(int p) { return base[p + lim]; }\n\nint main() {\n    for (int i = base[lim] = 1; i <= lim; ++i)\n        base[lim + i] = base[lim + i - 1] * 250007 % mod;\n    for (int i = 1, ny = fsp(250007, mod - 2); i <= lim; ++i)\n        base[lim - i] = base[lim - i + 1] * ny % mod;\n    scanf(\"%d%s\", &n, s + 1), p = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (s[i] == '>') ++p;\n        if (s[i] == '<') --p;\n        if (s[i] == '+') (A += bs(p)) %= mod;\n        if (s[i] == '-') (A += mod - bs(p)) % mod;\n    }\n    ++cnt[suf[n + 1] = 0];\n    for (int i = n; i > 1; --i) {\n        suf[i] = suf[i + 1];\n        if (s[i] == '>') --p;\n        if (s[i] == '<') ++p;\n        if (s[i] == '+') (suf[i] += bs(p)) %= mod;\n        if (s[i] == '-') (suf[i] += mod - bs(p)) %= mod;\n        ++cnt[suf[i]];\n    }\n\n    long long res = cnt[0];\n    p = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (s[i] == '>') ++p;\n        if (s[i] == '<') --p;\n        if (s[i] == '+') (pre += bs(p)) %= mod;\n        if (s[i] == '-') (pre += mod - bs(p)) % mod;\n        --cnt[suf[i + 1]];\n        res += cnt[((A - pre - A * bs(p) % mod) % mod + mod) % mod];\n    }\n    printf(\"%lld\\n\", res);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ARC099F.cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX_N = 501000, mod = 998244353;\n\nint fpow(int bas, int tim)\n{\n    int ret = 1;\n    while (tim)\n    {\n        if (tim & 1)\n            ret = 1LL * ret * bas % mod;\n        bas = 1LL * bas * bas % mod;\n        tim >>= 1;\n    }\n    return ret;\n}\n\nconst int base[4] = {133, 233, 911, 691}, base_inv[4] = {fpow(base[0], mod - 2), fpow(base[1], mod - 2), fpow(base[2], mod - 2), fpow(base[3], mod - 2)};\n\nstruct node\n{\n    int val[4];\n\n    bool operator<(const node &rhs) const\n    {\n        for (int i = 0; i < 4; i++)\n            if (val[i] != rhs.val[i])\n                return (val[i] < rhs.val[i]);\n        return false;\n    }\n\n    bool operator==(const node &rhs) const\n    {\n        for (int i = 0; i < 4; i++)\n            if (val[i] != rhs.val[i])\n                return false;\n        return true;\n    }\n} prefix[MAX_N], base_pre;\n\nmap<node, int> cnt;\nint n, base_pow[MAX_N][4], base_invs[MAX_N][4], pos[MAX_N];\nchar str[MAX_N];\n\nint getPow(int idx, int j) { return idx >= 0 ? base_pow[idx][j] : base_invs[-idx][j]; }\n\nnode calc(node x, node y, int idx)\n{\n    for (int i = 0; i < 4; i++)\n        x.val[i] = (0LL + x.val[i] + 1LL * y.val[i] * getPow(idx, i) % mod) % mod;\n    return x;\n}\n\nint main()\n{\n    scanf(\"%d%s\", &n, str + 1);\n    for (int j = 0; j < 4; j++)\n        for (int i = base_pow[0][j] = base_invs[0][j] = 1; i <= n; i++)\n            base_pow[i][j] = 1LL * base_pow[i - 1][j] * base[j] % mod, base_invs[i][j] = 1LL * base_invs[i - 1][j] * base_inv[j] % mod;\n    for (int j = 0; j < 4; j++)\n        for (int i = 1, ptr = 0; i <= n; i++)\n        {\n            if (str[i] == '+')\n                base_pre.val[j] = (0LL + base_pre.val[j] + getPow(ptr, j)) % mod;\n            else if (str[i] == '-')\n                base_pre.val[j] = (0LL + base_pre.val[j] + mod - getPow(ptr, j)) % mod;\n            else if (str[i] == '<')\n                ptr--;\n            else\n                ptr++;\n            prefix[i].val[j] = base_pre.val[j], pos[i] = ptr;\n        }\n    cnt[base_pre]++;\n    long long ans = 0;\n    for (int i = 1; i <= n; i++)\n        ans += cnt[prefix[i]], cnt[calc(prefix[i], base_pre, pos[i])]++;\n    printf(\"%lld\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define mp make_pair\n#define PI pair<int,int>\n#define poly vector<ll>\n#define mem(a) memset((a),0,sizeof(a))\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\n#define pb push_back\n#define fi first\n#define se second\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst ull base=233;\nconst int N=250005;\nchar ch[N];\null f[N],g[N];\nmap<ull,int> M;\nint main(){\n\tull zs=base,inv=1; For(i,1,63){inv=inv*zs; zs=zs*zs;}\n\tassert(base*inv==1);\n\t//cout<<inv<<endl;\n\tint n=read();\n\tscanf(\"%s\",ch+1);\n\tg[0]=1;\n\tFor(i,1,n){\n\t\tf[i]=f[i-1]; g[i]=g[i-1];\n\t\tif(ch[i]=='+')f[i]+=g[i];\n\t\tif(ch[i]=='-')f[i]-=g[i];\n\t\tif(ch[i]=='>')g[i]*=base;\n\t\tif(ch[i]=='<')g[i]*=inv;\n\t\tM[f[i]]++;\n\t}\n\tll ans=0;\n\tFor(i,1,n){\n\t\tans+=M[f[n]*g[i-1]+f[i-1]];\n\t\tM[f[i]]--;\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int WWW = 0;WWW < (n);WWW++)cerr << v[WWW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nconst ll mod1 = 1000000007;\nconst ll mod2 = 1000000009;\nconst ll seica1 = 114514;\nconst ll seica2 = 1919810;\n\n#define NODE 555555\npair<ll,ll> f[2][NODE];\nll mod[] = {1000000007,1000000009};\nll kake[] = {114514,1919810};\nint n;\nstring str;\nmap<pair<ll,ll>,ll> mp;\n\nll m_pow(ll a,ll b,ll p){\n\tll ret = 1;\n\tll tmp = a;\n\tfor(ll i = 0LL;i < 60;i++){\n\t\tif(b & (1LL << i)){\n\t\t\tret *= tmp;\n\t\t\tret %= p;\n\t\t}\n\t\ttmp *= tmp;\n\t\ttmp %= p;\n\t}\n\treturn ret;\n}\n\nll m_inv(ll a,ll p){\n\treturn m_pow(a,p-2,p);\n}\n\nvoid get_f(int num,int type){\n\tpair<ll,ll> now = MP(1,0);\n\tpair<ll,ll> prev;\n\tif(num == n-1){\n\t\tprev = MP(1,0);\n\t}\n\telse{\n\t\tprev = f[type][num+1];\n\t}\n\t\n\tif(str[num] == '<'){\n\t\tnow.FI = kake[type];\n\t}\n\telse if(str[num] == '>'){\n\t\tnow.FI = m_inv(kake[type],mod[type]);\n\t}\n\telse if(str[num] == '+'){\n\t\tnow.SE = mod[type] - 1;\n\t}\n\telse{\n\t\tnow.SE++;\n\t}\n\t\n\tll fir = now.FI * prev.FI % mod[type];\n\tll sec = (now.SE * prev.FI % mod[type] + prev.SE) % mod[type];\n\tf[type][num] = MP(fir,sec);\n}\n\npair<ll,ll> dfs(int num,int type){\n\tpair<ll,ll> now = MP(1,0);\n\tpair<ll,ll> prev;\n\tif(num == 0){\n\t\tprev = MP(1,0);\n\t}\n\telse{\n\t\tprev = dfs(num-1,type);\n\t}\n\t\n\tif(str[num] == '>'){\n\t\tnow.FI = kake[type];\n\t}\n\telse if(str[num] == '<'){\n\t\tnow.FI = m_inv(kake[type],mod[type]);\n\t}\n\telse if(str[num] == '-'){\n\t\tnow.SE = mod[type] - 1;\n\t}\n\telse{\n\t\tnow.SE++;\n\t}\n\t\n\tll fir = now.FI * prev.FI % mod[type];\n\tll sec = (now.SE * prev.FI % mod[type] + prev.SE) % mod[type];\n\treturn MP(fir,sec);\n}\n\nll get_x(ll x,ll num,ll type){\n\treturn (f[type][num].FI * x % mod[type] + f[type][num].SE) % mod[type];\n}\n\nint main(){\n\tcin >> n >> str;\n\tfor(int i = str.size()-1;i >= 0;i--){\n\t\tget_f(i,0);\n\t\tget_f(i,1);\n\t}\n\t\n\tll c[2] = {dfs(n-1,0).SE,dfs(n-1,1).SE};\n\t\n\tll ans = 0;\n\tmp[{0,0}]++;\n\tfor(int i = str.size()-1;i >= 0;i--){\n\t\tans += mp[{get_x(c[0],i,0),get_x(c[1],i,1)}];\n\t\tmp[{get_x(0,i,0),get_x(0,i,1)}]++;\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "using namespace std;\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define N 250010\n#define ll long long\nll qpow(ll x,ll y,ll p){\n\tll r=1;\n\tfor (;y;y>>=1,x=x*x%p)\n\t\tif (y&1)\n\t\t\tr=r*x%p;\n\treturn r;\n}\ntemplate<int x,int p>\n\tstruct hsh{\n\t\tint v;\n\t\thsh<x,p> operator<<(int n){return {v*qpow(x,p-1+n,p)%p};}\n\t\thsh<x,p> operator>>(int n){return {v*qpow(x,p-1-n,p)%p};}\n\t\thsh<x,p> operator+(hsh<x,p> o){return {(v+o.v+p)%p};}\n\t\thsh<x,p> operator-(hsh<x,p> o){return {(v-o.v+p)%p};}\n\t\thsh<x,p> operator+(int o){return {(v+o+p)%p};}\n\t\thsh<x,p> operator-(int o){return {(v-o+p)%p};}\n\t\tbool operator==(hsh<x,p> o){return v==o.v;}\n\t};\ntypedef hsh<89,1000000007> H1;\ntypedef hsh<91,1000000009> H2;\ntypedef hsh<97,19260817> H3;\nstruct Table{\n\tH1 key1;\n\tH2 key2;\n\tint cnt;\n} h[19260817];\nint n;\nchar s[N];\nint sum[N];\nH1 f1[N];\nH2 f2[N];\nH3 f3[N];\nint find(H1 key1,H2 key2,H3 key3){\n\tint i=key3.v;\n\tfor (;h[i].cnt && !(key1==h[i].key1 && key2==h[i].key2);++i==19260817?i=0:0);\n\treturn i;\n}\nvoid insert(H1 key1,H2 key2,H3 key3){\n\tint w=find(key1,key2,key3);\n\th[w].key1=key1,h[w].key2=key2;\n\th[w].cnt++;\n}\nint main(){\n\tscanf(\"%d%s\",&n,s+1);\t\n\tfor (int i=1;i<=n;++i)\n\t\tsum[i]=sum[i-1]+(s[i]=='<'?-1:s[i]=='>'?1:0);\n\tfor (int i=n;i>=1;--i)\n\t\tif (s[i]=='<')\n\t\t\tf1[i]=f1[i+1]>>1,f2[i]=f2[i+1]>>1,f3[i]=f3[i+1]>>1;\n\t\telse if (s[i]=='>')\n\t\t\tf1[i]=f1[i+1]<<1,f2[i]=f2[i+1]<<1,f3[i]=f3[i+1]<<1;\n\t\telse if (s[i]=='+')\n\t\t\tf1[i]=f1[i+1]+1,f2[i]=f2[i+1]+1,f3[i]=f3[i+1]+1;\n\t\telse\n\t\t\tf1[i]=f1[i+1]-1,f2[i]=f2[i+1]-1,f3[i]=f3[i+1]-1;\n\tll ans=0;\n\tfor (int i=1;i<=n;++i){\n\t\tinsert(f1[i]-f1[1]<<sum[i-1],f2[i]-f2[1]<<sum[i-1],f3[i]-f3[1]<<sum[i-1]);\n\t\tint w=find(f1[i+1]<<sum[i],f2[i+1]<<sum[i],f3[i+1]<<sum[i]);\n\t\tans+=h[w].cnt;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n    _____\n  .'     '.\n /  0   0  \\\n|     ^     |\n|  \\     /  |\n \\  '---'  /\n  '._____.'\n*/\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\nstruct chash\n{\n\tint operator()(int x) const\n\t{\n\t\tx ^= (x >> 20) ^ (x >> 12);\n\t\treturn x ^ (x >> 7) ^ (x >> 4);\n\t}\n};\n\ntemplate<typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename U> using hashtable = gp_hash_table<T, U, chash>;\nrandom_device(rd);\nmt19937 rng(rd());\n\ntemplate<class T>\nvoid readi(T &x)\n{\n\tT input = 0;\n\tbool negative = false;\n\tchar c = ' ';\n\twhile (c < '-')\n\t{\n\t\tc = getchar();\n\t}\n\tif (c == '-')\n\t{\n\t\tnegative = true;\n\t\tc = getchar();\n\t}\n\twhile (c >= '0')\n\t{\n\t\tinput = input * 10 + (c - '0');\n\t\tc = getchar();\n\t}\n\tif (negative)\n\t{\n\t\tinput = -input;\n\t}\n\tx = input;\n}\ntemplate<class T>\nvoid printi(T output)\n{\n\tif (output == 0)\n\t{\n\t\tputchar('0');\n\t\treturn;\n\t}\n\tif (output < 0)\n\t{\n\t\tputchar('-');\n\t\toutput = -output;\n\t}\n\tint aout[20];\n\tint ilen = 0;\n\twhile(output)\n\t{\n\t\taout[ilen] = ((output % 10));\n\t\toutput /= 10;\n\t\tilen++;\n\t}\n\tfor (int i = ilen - 1; i >= 0; i--)\n\t{\n\t\tputchar(aout[i] + '0');\n\t}\n\treturn;\n}\ntemplate<class T>\nvoid ckmin(T &a, T b)\n{\n\ta = min(a, b);\n}\ntemplate<class T>\nvoid ckmax(T &a, T b)\n{\n\ta = max(a, b);\n}\ntemplate<class T, class U>\nT nmod(T &x, U mod)\n{\n\tif (x >= mod) x -= mod;\n}\ntemplate<class T>\nT randomize(T mod)\n{\n\treturn (uniform_int_distribution<T>(0, mod - 1))(rng);\n}\n\n#define y0 ___y0\n#define y1 ___y1\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fi first\n#define se second\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\nconst long double PI = 4.0 * atan(1.0);\nconst long double EPS = 1e-10;\n\n#define MAGIC 347\n#define SINF 10007\n#define CO 1000007\n#define INF 1000000007\n#define BIG 1000000931\n#define LARGE 1696969696967ll\n#define GIANT 2564008813937411ll\n#define LLINF 2696969696969696969ll\n#define MAXN 250013\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ld, ld> pdd;\n\nint N;\nint arr[MAXN];\npll S;\nlong long ans;\nmap<ll, int> need;\n\nll expo(ll a, ll e, ll mod)\n{\n\tif (e == 0)\n\t{\n\t\treturn 1;\n\t}\n\tll was = expo(a, e / 2, mod);\n\tif (e % 2)\n\t{\n\t\treturn was * was % mod * a % mod;\n\t}\n\treturn was * was % mod;\n}\nll modinv(ll a, ll e)\n{\n\treturn expo(a, e - 2, e);\n}\npll INV = {modinv(CO, INF), modinv(CO, BIG)};\nvoid solve(int L, int R)\n{\n\tif (L == R)\n\t{\n\t\treturn;\n\t}\n\tneed.clear();\n\tint mid = (L + R) >> 1;\n\t//start from L...mid, end at mid + 1....R\n\tpair<pll, pll> trans = MP(MP(1, 0), MP(1, 0));\n\tpll inv = MP(1, 1);\n\tfor (int i = mid + 1; i <= R; i++)\n\t{\n\t\tif (arr[i] == 0)\n\t\t{\n\t\t\ttrans.fi.fi *= INV.fi; trans.fi.fi %= INF;\n\t\t\ttrans.fi.se *= INV.fi; trans.fi.se %= INF;\n\t\t\ttrans.se.fi *= INV.se; trans.se.fi %= BIG;\n\t\t\ttrans.se.se *= INV.se; trans.se.se %= BIG;\n\t\t\tinv.fi *= CO; inv.fi %= INF;\n\t\t\tinv.se *= CO; inv.se %= BIG;\n\t\t}\n\t\tif (arr[i] == 1)\n\t\t{\n\t\t\ttrans.fi.fi *= CO; trans.fi.fi %= INF;\n\t\t\ttrans.fi.se *= CO; trans.fi.se %= INF;\n\t\t\ttrans.se.fi *= CO; trans.se.fi %= BIG;\n\t\t\ttrans.se.se *= CO; trans.se.se %= BIG;\n\t\t\tinv.fi *= INV.fi; inv.fi %= INF;\n\t\t\tinv.se *= INV.se; inv.se %= BIG;\n\t\t}\n\t\tif (arr[i] == 2)\n\t\t{\n\t\t\ttrans.fi.se++; nmod(trans.fi.se, INF);\n\t\t\ttrans.se.se++; nmod(trans.se.se, BIG);\n\t\t}\n\t\tif (arr[i] == 3)\n\t\t{\n\t\t\ttrans.fi.se--; trans.fi.se += INF; nmod(trans.fi.se, INF);\n\t\t\ttrans.se.se--; trans.se.se += BIG; nmod(trans.se.se, BIG);\n\t\t}\n\t\tpll dif = {(S.fi - trans.fi.se) * inv.fi, (S.se - trans.se.se) * inv.se};\n\t\tdif.fi %= INF; dif.fi += INF; nmod(dif.fi, INF);\n\t\tdif.se %= BIG; dif.se += BIG; nmod(dif.se, BIG);\n\t\tneed[dif.fi * BIG + dif.se]++;\n\t}\n\ttrans = MP(MP(1, 0), MP(1, 0));\n\tfor (int i = mid; i >= L; i--)\n\t{\n\t\tif (arr[i] == 0)\n\t\t{\n\t\t\ttrans.fi.fi *= INV.fi; trans.fi.fi %= INF;\n\t\t\ttrans.se.fi *= INV.se; trans.se.fi %= BIG;\n\t\t}\n\t\tif (arr[i] == 1)\n\t\t{\n\t\t\ttrans.fi.fi *= CO; trans.fi.fi %= INF;\n\t\t\ttrans.se.fi *= CO; trans.se.fi %= BIG;\n\t\t}\n\t\tif (arr[i] == 2)\n\t\t{\n\t\t\ttrans.fi.se += trans.fi.fi; nmod(trans.fi.se, INF);\n\t\t\ttrans.se.se += trans.se.fi; nmod(trans.se.se, BIG);\n\t\t}\n\t\tif (arr[i] == 3)\n\t\t{\n\t\t\ttrans.fi.se -= trans.fi.fi; trans.fi.se += INF; nmod(trans.fi.se, INF);\n\t\t\ttrans.se.se -= trans.se.fi;\ttrans.se.se += BIG; nmod(trans.se.se, BIG);\n\t\t}\n\t\tans += need[trans.fi.se * BIG + trans.se.se];\n\t}\n\tsolve(L, mid);\n\tsolve(mid + 1, R);\n}\n\nint32_t main()\n{\n\tios_base::sync_with_stdio(0);\n\t// cout << fixed << setprecision(10);\n\t// cerr << fixed << setprecision(10);\n\tfreopen (\"file.in\", \"r\", stdin);\n\tfreopen (\"file.out\", \"w\", stdout);\n\tcin >> N;\n\tstring temps;\n\tcin >> temps;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (temps[i] == '<')\n\t\t{\n\t\t\tarr[i] = 0;\n\t\t}\n\t\tif (temps[i] == '>')\n\t\t{\n\t\t\tarr[i] = 1;\n\t\t}\n\t\tif (temps[i] == '+')\n\t\t{\n\t\t\tarr[i] = 2;\n\t\t}\n\t\tif (temps[i] == '-')\n\t\t{\n\t\t\tarr[i] = 3;\n\t\t}\n\t}\n\treverse(arr, arr + N);\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (arr[i] == 0)\n\t\t{\n\t\t\tS.fi *= INV.fi; S.fi %= INF;\n\t\t\tS.se *= INV.se; S.se %= BIG;\n\t\t}\n\t\tif (arr[i] == 1)\n\t\t{\n\t\t\tS.fi *= CO; S.fi %= INF;\n\t\t\tS.se *= CO; S.se %= BIG;\n\t\t}\n\t\tif (arr[i] == 2)\n\t\t{\n\t\t\tS.fi++; nmod(S.fi, INF);\n\t\t\tS.se++; nmod(S.se, BIG);\n\t\t}\n\t\tif (arr[i] == 3)\n\t\t{\n\t\t\tS.fi--; S.fi += INF; nmod(S.fi, INF);\n\t\t\tS.se--; S.se += BIG; nmod(S.se, BIG);\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (arr[i] == 0)\n\t\t{\n\t\t\tif (S == MP(0ll, 0ll)) ans++;\n\t\t}\n\t\tif (arr[i] == 1)\n\t\t{\n\t\t\tif (S == MP(0ll, 0ll)) ans++;\n\t\t}\n\t\tif (arr[i] == 2)\n\t\t{\n\t\t\tif (S == MP(1ll, 1ll)) ans++;\n\t\t}\n\t\tif (arr[i] == 3)\n\t\t{\n\t\t\tif (S == MP((ll) INF - 1, (ll) BIG - 1)) ans++;\n\t\t}\n\t}\n\tsolve(0, N - 1);\n\tcout << ans << '\\n';\n\t//when u <, the # divides by co\n\t//when u >, the # mults by co\n\t//when u +, u add the #\n\t//when u -, u subtract the #\n\tcerr << \"time elapsed = \" << (clock() / (CLOCKS_PER_SEC / 1000)) << \" ms\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1e9 + 7;\nconst int N = 2e5 + 5;\nconst int X = 1000003;\ntypedef long long ll;\n\n\nchar c;\nstring s;\nll n,i,t,a,b,x,bol=1,ans;\nmap < int , int > M;\n\nint main(){\n    cin >> n >> s;\n    for(t=X,i=mod-2; i ; i>>=1){\n        if(i & 1) bol = bol*t % mod;\n        t = t*t % mod;\n    }\n    for(i=n-1; i>=0 ;i--){\n        c = s[i];\n        if(c == '+') x++;\n        if(c == '-') x--;\n        if(c == '>') x *= X;\n        if(c == '<') x *= bol;\n        x = (x % mod + mod) % mod; \n    }\n\n    a = 1; b = 0;\n    M[0] = 1;\n    for(i=n-1; i>=0 ;i--){\n        c = s[i];\n        if(c == '+') b -= a;\n        if(c == '-') b += a;\n        if(c == '>') a *= bol;\n        if(c == '<') a *= X;\n        a = (a % mod + mod) % mod;\n        b = (b % mod + mod) % mod;\n        t = (a*x + b) % mod;\n        ans += M[t];\n        M[b]++;\n    }\n\n    cout << ans;\n    return 0;\n}   "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int M = 2;\nstruct hs {\n\tint v[M];\n\ths(){\n\t\tmemset(v, 0, sizeof(v));\n\t}\n};\nhs mods;\nint mds[] = {\n\t961'748'927,\n\t961'820'429,\n\t1'000'000'007,\n\t1'000'000'009,\n\t1'003'162'753,\n\t1'023'893'771\n};\nhs create(int x){\n\ths r;\n\tfor(int i = 0; i < M; i++){\n\t\tr.v[i] = x % mods.v[i];\n\t\tif(r.v[i] < 0) r.v[i] += mods.v[i];\n\t}\n\treturn r;\n}\nhs operator + (hs a, hs b){\n\ths r;\n\tfor(int i = 0; i < M; i++){\n\t\tr.v[i] = a.v[i] + b.v[i];\n\t\tif(r.v[i] >= mods.v[i]) r.v[i] -= mods.v[i];\n\t}\n\treturn r;\n}\nhs operator - (hs a, hs b){\n\ths r;\n\tfor(int i = 0; i < M; i++){\n\t\tr.v[i] = a.v[i] - b.v[i];\n\t\tif(r.v[i] < 0) r.v[i] += mods.v[i];\n\t}\n\treturn r;\n}\nhs operator * (hs a, hs b){\n\ths r;\n\tfor(int i = 0; i < M; i++){\n\t\tr.v[i] = 1ll * a.v[i] * b.v[i] % mods.v[i];\n\t}\n\treturn r;\n}\nbool operator < (hs a, hs b){\n\tfor(int i = 0; i < M; i++) if(a.v[i] != b.v[i]) return a.v[i] < b.v[i];\n\treturn false;\n}\nint pwr(int a, int b, int mod){\n\tint r = 1;\n\tfor(; b; b>>=1, a = 1ll * a * a % mod) if(b&1) r = 1ll * r * a % mod;\n\treturn r;\n}\nbool is_prime(int x){\n\tfor(int i = 2; i * i <= x; i++) if(x % i == 0) return false;\n\treturn true;\n}\nconst int maxn = 300300;\nusing Poly = pair<hs, hs>;\nhs eval(Poly f, hs x){\n\treturn f.first + (f.second * x);\n}\nPoly poly[maxn];\nint main(){\n\tsrand(time(NULL));\n\tmemcpy(mods.v, mds, sizeof(int) * M);\n\ths x, mx, minus = create(-1), plus = create(1);\n\tint xx;\n\tdo {\n\t\txx = 900'999'999 + 50;\n\t\txx += rand() % 1000;\n\t} while(!is_prime(xx));\n\tx = create(xx);\n\tfor(int i = 0; i < M; i++){\n\t\tmx.v[i] = pwr(x.v[i], mods.v[i] - 2, mods.v[i]);\t\n\t\tassert((1ll * mx.v[i] * x.v[i] % mods.v[i]) == 1);\n\t}\n\tint n; cin >> n;\n\tstring s; cin >> s;\n\tpoly[n] = {create(0), create(1)};\n\tfor(int i = n - 1; i >= 0; i--){\n\t\tpoly[i] = poly[i + 1];\n\t\tif(s[i] == '+'){\n\t\t\tpoly[i].first = poly[i].first - poly[i].second;\n\t\t} else if(s[i] == '-'){\n\t\t\tpoly[i].first = poly[i].first + poly[i].second;\n\t\t} else {\n\t\t\ths mul = x;\n\t\t\tif(s[i] == '<')\n\t\t\t\tmul = mx;\n\t\t\tpoly[i].second = poly[i].second * mul;\n\t\t}\n\t}\n\tPoly norm = poly[n];\n\tfor(int i = 0; i < n; i++){\n\t\tif(s[i] == '+'){\n\t\t\tnorm.first = norm.first + norm.second;\n\t\t} else if(s[i] == '-'){\n\t\t\tnorm.first = norm.first - norm.second;\n\t\t} else if(s[i] == '<'){\n\t\t\tnorm.second = norm.second * x;\n\t\t} else {\n\t\t\tnorm.second = norm.second * mx;\n\t\t}\n\t}\n\ths tot = norm.first;\n\tmap<hs, int> cnt;\n\tcnt[poly[n].first]++;\n\tlong long ans = 0;\n\tfor(int i = n - 1; i >= 0; i--){\n\t\tans += cnt[eval(poly[i], tot)];\n\t\tcnt[poly[i].first]++;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <unordered_map>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate <class T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (T& x : v)\n    is >> x;\n  return is;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\nconst int N = 250010, P = 998244353, B = 19260817;\n\ntypedef pair<int, int> pii;\n\nstruct NumberTheory {\n\n  typedef pair<int, int> _P2_Field;\n\n  mt19937 rng;\n\n  NumberTheory() : rng(chrono::steady_clock::now().time_since_epoch().count()) {}\n\n  void _exGcd(int a, int b, int& x, int& y) {\n    if (!b) {\n      x = 1;\n      y = 0;\n      return;\n    }\n    _exGcd(b, a % b, y, x);\n    y -= a / b * x;\n  }\n\n  int inv(int a, int p = P) {\n    int x = 0, y = 0;\n    _exGcd(a, p, x, y);\n    if (x < 0)\n      x += p;\n    return x;\n  }\n\n  template <class Integer>\n  bool quadRes(Integer a, Integer b) {\n    if (a <= 1)\n      return true;\n    while (a % 4 == 0)\n      a /= 4;\n    if (a % 2 == 0)\n      return (b % 8 == 1 || b % 8 == 7) == quadRes(a / 2, b);\n    return ((a - 1) % 4 == 0 || (b - 1) % 4 == 0) == quadRes(b % a, a);\n  }\n\n  // assume p in prime, x in quadratic residue\n  int sqrt(int x, int p = P) {\n    if (p == 2 || x <= 1)\n      return x;\n    int w, v, k = (p + 1) / 2;\n    do {\n      w = rng() % p;\n    } while (quadRes(v = int((w * (ll)w - x + p) % p), p));\n    _P2_Field res(1, 0), a(w, 1);\n    while (k) {\n      if (k & 1)\n        res = _P2_Field((res.first * (ll)a.first + res.second * (ll)a.second % p * v) % p, (res.first * (ll)a.second + res.second * (ll)a.first) % p);\n      if (k >>= 1)\n        a = _P2_Field((a.first * (ll)a.first + a.second * (ll)a.second % p * v) % p, (a.first * (ll)a.second << 1) % p);\n    }\n    return min(res.first, p - res.first);\n  }\n\n} nt;\n\npii unite(const pii& lhs, const pii& rhs) { return make_pair((lhs.first + rhs.first * (ll)lhs.second) % P, lhs.second * (ll)rhs.second % P); }\n\nconst pii LEFT(0, B), RIGHT(0, nt.inv(B)), PLUS(1, 1), MINUS(P - 1, 1);\n\nchar s[N];\npii op[256];\npii pref[N];\n\nunordered_map<int, int> mp;\n\nint main() {\n#ifdef LBT\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n;\n  cin >> n >> (s + 1);\n  op['<'] = LEFT;\n  op['>'] = RIGHT;\n  op['+'] = PLUS;\n  op['-'] = MINUS;\n  pref[0] = make_pair(0, 1);\n  for (int i = 1; i <= n; ++i)\n    pref[i] = unite(pref[i - 1], op[s[i]]);\n  ll ans = 0;\n  for (int i = 0; i <= n; ++i) {\n    ans += mp[pref[i].first];\n    ++mp[unite(pref[i], pref[n]).first];\n  }\n  cout << ans << '\\n';\n\n#ifdef LBT\n  LOG(\"Time: %dms\\n\", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <map>\n#include <vector>\n\nconst int MOD = (int)1e9 + 9;\nconst int kN = 250000 + 5;\nusing LL = long long;\nint n;\nchar s[kN];\nconst std::vector<int> primes{(int)1e9 + 7, (int)1e8 + 7, 233333, (int)1e6 + 7, 13};\nconst int kSize = primes.size();\nstd::vector<int> inv_primes(kSize);\n\n\nint inv(int x) {\n  return x == 1 ? 1 : (MOD - MOD / x) * 1LL * inv(MOD % x) % MOD;\n}\n\nstd::vector<int> calc(const int *a, const int *b, const int *c) {\n  std::vector<int> ret(kSize);\n  for (int i = 0; i < kSize; ++ i)\n    ret[i] = (a[i] * 1LL * c[i] % MOD + b[i]) % MOD;\n  return ret;\n}\n\nbool operator < (const std::vector<int>& lhs, const std::vector<int> &rhs) {\n  if (lhs.size() != rhs.size())\n    return lhs.size() < rhs.size();\n  for (int i = 0; i < lhs.size(); ++ i) {\n    if (lhs[i] < rhs[i])\n      return true;\n    else if (lhs[i] > rhs[i])\n      return false;\n  }\n  return false;\n}\n\nLL solve() {\n  for (int i = 0; i < kSize; ++ i)\n    inv_primes[i] = inv(primes[i]);\n  LL ret = 0;\n  std::map<std::vector<int>, int> map;\n  map[std::vector<int>(kSize, 0)] = 1;\n  int c[kSize] = {};\n  for (int i = n; i >= 1; -- i) {\n    char ch = s[i - 1];\n    for (int j = 0; j < kSize; ++ j) {\n      if (ch == '+')\n        c[j] = (c[j] + 1) % MOD;\n      else if (ch == '-')\n        c[j] = (c[j] + MOD - 1) % MOD;\n      else if (ch == '>')\n        c[j] = c[j] * 1LL * primes[j] % MOD;\n      else\n        c[j] = c[j] * 1LL * inv_primes[j] % MOD;\n    }\n  }\n  int a[kSize] = {}, b[kSize] = {};\n  for (int i = 0; i < kSize; ++ i)\n    a[i] = 1;\n  for (int i = n; i >= 1; -- i) {\n    char ch = s[i - 1];\n    for (int j = 0; j < kSize; ++ j) {\n      if (ch == '-')\n        b[j] = (b[j] + a[j]) % MOD;\n      else if (ch == '+')\n        b[j] = (b[j] + MOD - a[j]) % MOD;\n      else if (ch == '<')\n        a[j] = a[j] * 1LL * primes[j] % MOD;\n      else\n        a[j] = a[j] * 1LL * inv_primes[j] % MOD;\n    }\n    auto it = map.find(calc(a, b, c));\n    if (it != map.end())\n      ret += it->second;\n    map[std::vector<int>(b, b + kSize)] ++;\n  }\n  return ret;\n}\n\nint main() {\n  srand(time(NULL));\n  scanf(\"%d%s\", &n, s);\n  printf(\"%lld\\n\", solve());\n}"
  },
  {
    "language": "C++",
    "code": "// ===== 2018/06/30 01:18:04 =====\n\n// ../../../lib/template/includes.hpp\n\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <climits>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <string>\n#include <tuple>\n#include <vector>\n\n// ../../../lib/template/const_value.hpp\n\nnamespace sub {\ntemplate <typename T>\nconstexpr typename std::enable_if<std::is_integral<T>::value, T>::type\ninf_sub() {\n  return std::numeric_limits<T>::max() / 2 - 1000;\n}\n\ntemplate <typename T>\nconstexpr typename std::enable_if<std::is_floating_point<T>::value, T>::type\ninf_sub() {\n  return std::min(std::numeric_limits<T>::max() / 2 - 1000, T(1e50));\n}\n}  // namespace sub\n\ntemplate <typename T> constexpr T inf() {\n  static_assert(std::is_arithmetic<T>::value, \"T must be arithmetic value\");\n  return sub::inf_sub<T>();\n}\n\ntemplate <typename T> constexpr T zero() {\n  static_assert(std::is_arithmetic<T>::value, \"T must be arithmetic value\");\n  return T(0);\n}\n\nconst long double pi = acos(-1.0);\n\n// ../../../lib/template/initialize.cpp\n\nstruct yes_no : std::numpunct<char> {\n  string_type do_truename() const { return \"Yes\"; }\n  string_type do_falsename() const { return \"No\"; }\n};\n\nstruct Initialize {\n  Initialize() {\n    std::locale loc(std::locale(), new yes_no);\n    std::cout << std::boolalpha << std::setprecision(11) << std::fixed;\n    std::cout.imbue(loc);\n  }\n};\n\nconst Initialize initialize;\n\n// ../../../lib/template/macros.hpp\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define ALL(x) (x).begin(), (x).end()\n\n// ../../../lib/template/misc.hpp\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = std::min(a, b); }\n\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = std::max(a, b); }\n\n// ../../../lib/template/range.hpp\n\nclass range {\n  class index_type {\n    int x;\n\n  public:\n    index_type(int x_) : x(x_) {}\n    int operator*() const { return x; }\n    bool operator!=(index_type &r) { return x < r.x; }\n    void operator++() { ++x; }\n  };\n  index_type i, n;\n\npublic:\n  range(int n_) : i(0), n(n_) {}\n  range(int i_, int n_) : i(i_), n(n_) {}\n  index_type &begin() { return i; }\n  index_type &end() { return n; }\n};\n\n// ../../../lib/template/typedef.hpp\n\nusing ll = long long;\nusing ld = long double;\n\n// ../../../lib/template/template.cpp\n\nusing namespace std;\n\n// F.cpp\n\ntemplate<typename T>\nvector<T> table(int n, T v) { return vector<T>(n, v); }\n\ntemplate <class... Args>\nauto table(int n, Args... args) {\n  auto val = table(args...);\n  return vector<decltype(val)>(n, move(val));\n}\n\nstatic const ll moda = 1000000000000037LL;\nstatic const ll modb = 1000000000000091LL;\nstatic const ll pa = 17LL;\nstatic const ll pb = 19LL;\n\nll powa_raw[520000];\nll powb_raw[520000];\n\nll inv(ll a, ll p) {\n  return (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\n\nvoid solve(ll N, string S) {\n  const __int128 inv_pa = inv(pa, moda);\n  const __int128 inv_pb = inv(pb, modb);\n  ll *A = powa_raw + 260000;\n  ll *B = powb_raw + 260000;\n  A[0] = 1; B[0] = 1;\n  REP(i,255000) {\n    A[i+1] = (A[i] * pa) % moda;\n    A[-(i+1)] = (A[-i] * inv_pa) % moda;\n    B[i+1] = (B[i] * pb) % modb;\n    B[-(i+1)] = (B[-i] * inv_pb) % modb;\n  }\n  map<pair<ll,ll>,int> cnt;\n  cnt[make_pair(0LL, 0LL)] = 1;\n  ll suma = 0, sumb = 0, P = 0;\n  REP(i,N) {\n    if (S[i] == '+') { suma += A[P]; sumb += B[P]; }\n    if (S[i] == '-') { suma -= A[P]; sumb -= B[P]; }\n    suma = (suma + moda) % moda;\n    sumb = (sumb + modb) % modb;\n    if (S[i] == '>') ++P;\n    if (S[i] == '<') --P;\n    cnt[make_pair(suma, sumb)] += 1;\n  }\n  const ll ta = suma, tb = sumb;\n  ll res = 0;\n  suma = 0, sumb = 0, P = 0;\n  REP(i,N) {\n    cnt[make_pair(suma, sumb)] -= 1;\n    ll tta = (__int128(ta) * A[P] + suma) % moda;\n    ll ttb = (__int128(tb) * B[P] + sumb) % modb;\n    res += cnt[make_pair(tta, ttb)];\n    if (S[i] == '+') { suma += A[P]; sumb += B[P]; }\n    if (S[i] == '-') { suma -= A[P]; sumb -= B[P]; }\n    suma = (suma + moda) % moda;\n    sumb = (sumb + modb) % modb;\n    if (S[i] == '>') ++P;\n    if (S[i] == '<') --P;\n  }\n  cout << res << endl;\n}\n\nint main() {\n\tstring S;\n\tll N;\n\tscanf(\"%lld\", &N);\n\tcin >> S;\n\tsolve(N, S);\n\treturn 0;\n}\n// ===== 2018/06/30 01:18:04 =====\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <cstdio>\nusing namespace std;\n\nconst long long B=1000000000000000003LL;\nconst long long P=1000000000000000031LL;\n\nlong long pow_binary_mod(long long x,long long y,long long mod){\n\tlong long z=1;\n\tfor(;y;y>>=1){\n\t\tif((y&1)!=0)z=(__int128_t)z*x%mod;\n\t\tx=(__int128_t)x*x%mod;\n\t}\n\treturn z;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N;\n\tstring s;\n\tcin>>N>>s;\n\tlong long Brev=pow_binary_mod(B,P-2,P);\n\tvector<long long> o(N+1),p(N+1);p[0]=1;\n\tfor(int i=1;i<=N;i++){\n\t\tp[i]=p[i-1];o[i]=o[i-1];\n\t\tif(s[i-1]=='<'){\n\t\t\tp[i]=(__int128_t)p[i]*Brev%P;\n\t\t}else if(s[i-1]=='>'){\n\t\t\tp[i]=(__int128_t)p[i]*B%P;\n\t\t}else if(s[i-1]=='+'){\n\t\t\to[i]=(o[i]+p[i])%P;\n\t\t}else if(s[i-1]=='-'){\n\t\t\to[i]=(o[i]-p[i]+P)%P;\n\t\t}\n\t}\n\tmap<long long,int>m;\n\tlong long r=0;\n\tfor(int i=N;i>=1;i--){\n\t\tm[o[i]]++;\n\t\tr+=m[((__int128_t)o[N]*p[i-1]+o[i-1])%P];\n\t}\n\tprintf(\"%lld\\n\",r);\n}"
  },
  {
    "language": "C++",
    "code": "    #include \"bits/stdc++.h\"\n    using namespace std;\n     \n    #define MAX 600012\n     \n    int n;\n    char buf[MAX];\n     \n     \n    string s;\n     \n     \n    //#define MOD1 1000000007\n    //#define MOD2 1000000009\n     \n    valarray<long long int> MOD1;\n    valarray<long long int> MOD2;\n    vector<valarray<long long int> > p2;\n    vector<valarray<long long int> > vv;\n    vector<int> ps;\n    map<pair<long long int,long long int>, int> mp;\n    long long int ppow(long long int i, long long int j, long long int MOD) {\n    \tlong long int ret = 1;\n    \twhile (j) {\n    \t\tif (j & 1LL)ret *= i;\n    \t\tif (ret >= MOD)ret %= MOD;\n    \t\tj >>= 1LL;\n    \t}\n    \treturn ret;\n    }\n     \n    valarray<long long int> calc(int dif) {\n    \tvalarray<long long int> ret;\n    \tret.resize(2, 0);\n    \tfor (int j = 0; j < 2; j++) {\n    \t\tif (dif < 0) {\n    \t\t\tret[j]=ppow(ppow(MOD1[j],MOD2[j]-2,MOD2[j]),-dif,MOD2[j]);\n    \t\t}\n    \t\telse {\n    \t\t\tret[j] = ppow(MOD1[j], abs(dif), MOD2[j]);\n    \t\t}\n    \t}\n    \treturn ret;\n    }\n     \n    int main() {\n    \tMOD1.resize(2);\n    \tMOD2.resize(2);\n    \tp2.push_back(valarray<long long int>());\n    \tp2.back().resize(2);\n    \tp2.back()[0] = p2.back()[1] = 1;\n    \tMOD2[0] = 1000000007;\n    \tMOD1[0] = 998244353;\n    \tMOD1[1] = 555522277;\n    \tMOD2[1] = 1000000009;\n    \tp2[0] %= MOD2;\n    \tfor (int i = 1; i < MAX; i++) {\n    \t\tp2.push_back(p2.back());\n    \t\tp2[i] *= MOD1;\n    \t\tp2[i] %= MOD2;\n    \t}\n    \tcin >> n;\n    \tscanf(\"%s\", buf);\n    \ts = buf;\n    \tint pos = MAX/2;\n    \tvalarray<long long int> hs;\n    \ths.resize(2);\n    \ths[0] = hs[1] = 0;\n    \tvv.push_back(hs);\n    \tps.push_back(pos);\n    \tfor (int i = 0; i < s.size(); i++) {\n    \t\tif (s[i] == '<') {\n    \t\t\tpos--;\n    \t\t}\n    \t\tif (s[i] == '>') {\n    \t\t\tpos++;\n    \t\t}\n    \t\tif (s[i] == '+') {\n    \t\t\ths += p2[pos];\n    \t\t}\n    \t\tif (s[i] == '-') {\n    \t\t\ths -= p2[pos];\n    \t\t\ths += MOD2;\n    \t\t}\n    \t\ths %= MOD2;\n    \t\tvv.push_back(hs);\n    \t\tps.push_back(pos);\n    \t}\n    \tlong long int way = 0;\n    \tfor (int i = vv.size() - 1; i >= 0; i--) {\n    \t\tvalarray<long long int> want = vv[i] + ((vv.back()*calc(-MAX/2+ps[i]))%MOD2);\n    \t\twant = want%MOD2;\n    \t\tway += mp[make_pair(want[0], want[1])];\n    \t\t//cerr << \"dbg \" << way << endl;\n    \t\tif(want[0]<0LL||want[1]<0LL)exit(1);\n    \t\tif(vv[i][0]<0LL||want[1]<0LL)exit(1);\n    \t\tmp[make_pair(vv[i][0],vv[i][1])]++;\n    \t}\n    \tprintf(\"%lld\\n\", way);\n    \treturn 0;\n    }"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=1e9+7;\nint qpow(int x,int k)\n{\n    int r=1;\n    while(k)\n    {\n        if(k&1)r=1ll*r*x%mod;\n        k>>=1;x=1ll*x*x%mod;\n    }\n    return r;\n}\nint add(int x,int y){return x+y<mod?x+y:x+y-mod;}\nint n;\nchar s[300300];\n\nint X[6]={233,1919,114514,817,1001,9527};\nint inv[6];\nstruct Node {\n    int v[6];\n    bool operator < (const Node &o)const{\n        for(int i=0;i<6;++i)\n            if(v[i]!=o.v[i])return v[i]<o.v[i];\n        return 0;\n    }\n    void clear(){memset(v,0,sizeof(v));}\n    void f(char c)\n    {\n        if(c=='+') for(int i=0;i<6;++i)v[i]=add(v[i],1);\n        else if(c=='-') for(int i=0;i<6;++i)v[i]=add(v[i],mod-1);\n        else if(c=='>') for(int i=0;i<6;++i)v[i]=1ll*v[i]*X[i]%mod;\n        else if(c=='<') for(int i=0;i<6;++i)v[i]=1ll*v[i]*inv[i]%mod;\n    }\n};\nmap<Node,int>mp;\nstruct PNN{\n    Node k,b;\n    void clear() { for(int i=0;i<6;++i)k.v[i]=1,b.v[i]=0; }\n    void f(char c)\n    {\n        if(c=='+')for(int i=0;i<6;++i)b.v[i]=add(b.v[i],mod-k.v[i]);\n        else if(c=='-')for(int i=0;i<6;++i)b.v[i]=add(b.v[i],k.v[i]);\n        else if(c=='>')for(int i=0;i<6;++i)k.v[i]=1ll*k.v[i]*inv[i]%mod;\n        else if(c=='<')for(int i=0;i<6;++i)k.v[i]=1ll*k.v[i]*X[i]%mod;\n    }\n    Node calc(Node x)\n    {\n        Node res;\n        for(int i=0;i<6;++i)\n            res.v[i]=add(1ll*k.v[i]*x.v[i]%mod,b.v[i])%mod;\n        return res;\n    }\n};\nint main()\n{\n    for(int i=0;i<6;++i)inv[i]=qpow(X[i],mod-2);\n    scanf(\"%d\",&n);\n    scanf(\"%s\",s+1);\n    Node C;C.clear();\n    for(int i=n;i;--i)C.f(s[i]);\n    Node o;o.clear();\n    mp[o]++;\n    PNN cur;cur.clear();\n    long long ans=0;\n    for(int i=n;i;--i)\n    {\n        cur.f(s[i]);\n        Node tt=cur.calc(C);\n        ans+=mp[cur.calc(C)];\n        mp[cur.calc(o)]++;\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\nconst pid_t pid = getpid();\n// Problem Specific Parameter:\n\ntemplate<unsigned MOD>  class ModInt {\npublic:\n\tModInt(): x(0) {}\n\tModInt(signed y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n\tModInt(signed long long y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n\n\n\t// Arithmetic Oprators\n\tModInt &operator+=(ModInt that) {\n\t\tif ((x += that.x) >= MOD) x -= MOD; \n\t\treturn *this;\n\t}\n\tModInt &operator-=(ModInt that) {\n\t\tif ((x += MOD - that.x) >= MOD) x -= MOD; \n\t\treturn *this;\n\t}\n\tModInt &operator*=(ModInt that) {\n\t\tx = 1LL * x * that.x % MOD;\n\t\treturn *this;\n\t}\n\tModInt &operator/=(ModInt that) {\n\t\treturn *this *= ModInt(get<1>(extgcd(that.x, int(MOD))));\n\t}\n\tModInt &operator%=(ModInt that) {\n\t\tx %= that.x;\n\t\treturn *this;\n\t}\n\n\tModInt &operator+=(const int that) { return *this += ModInt(that);}\n\tModInt &operator-=(const int that) { return *this -= ModInt(that);}\n\tModInt &operator*=(const int that) { return *this *= ModInt(that);}\n\tModInt &operator/=(const int that) { return *this /= ModInt(that);}\n\tModInt &operator%=(const int that) { return *this %= ModInt(that);}\n\n\t// Comparators\n\tbool operator <(ModInt that) const { return x < that.x; }\n\tbool operator >(ModInt that) const { return x > that.x; }\n\tbool operator<=(ModInt that) const { return x <= that.x; }\n\tbool operator>=(ModInt that) const { return x >= that.x; }\n\tbool operator!=(ModInt that) const { return x != that.x; }\n\tbool operator==(ModInt that) const { return x == that.x; }\n\n\t// Utilities\n\tunsigned getval() const { return x;}\n\tModInt operator+(ModInt that) const { return ModInt(*this) += that;}\n\tModInt operator-(ModInt that) const { return ModInt(*this) -= that;}\n\tModInt operator*(ModInt that) const { return ModInt(*this) *= that;}\n\tModInt operator/(ModInt that) const { return ModInt(*this) /= that;}\n\tModInt operator%(ModInt that) const { return ModInt(*this) %= that;}\n\tModInt operator+(const int that) const { return ModInt(*this) += that;}\n\tModInt operator-(const int that) const { return ModInt(*this) -= that;}\n\tModInt operator*(const int that) const { return ModInt(*this) *= that;}\n\tModInt operator/(const int that) const { return ModInt(*this) /= that;}\n\tModInt operator%(const int that) const { return ModInt(*this) %= that;}\n\tModInt operator=(const int that) { return *this = ModInt(that);}\n\tfriend istream &operator>>(istream& is, ModInt &that) {ll tmp; is >> tmp; that = ModInt(tmp);return is;}\n\tfriend ostream &operator<<(ostream& os, const ModInt &that) { return os << that.x; }\n\t\n\tModInt power(ll n) const {\n\t\tll b = 1LL, a = x;\n\t\twhile(n){\n\t\t\tif(n & 1) b = b * a % MOD;\n\t\t\ta = a * a % MOD;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn ModInt(b);\n\t}\nprivate:\n\tunsigned x;\n\t\n\tinline auto extgcd(int a, int b) {\n\t\tif (b == 0) return make_tuple(a, 1, 0);\n\t\ttuple<int, int, int> ret = extgcd(b, a % b);\n\t\tswap(get<1>(ret), get<2>(ret));\n\t\tget<2>(ret) -= a / b * get<1>(ret);\n\t\treturn ret;\n\t}\n};\n\nconst int mod = 1000000087;\nusing mint = ModInt<mod>;\nconst mint ZERO = mint(0);\nconst mint ONE = mint(1);\n\nuniform_int_distribution<int> rng(1 << 20,mod - 1); // [lower,upper] \nmt19937 mt(pid);\nconst mint B = rng(mt);\n\nconst int limit = 500010;\nconst int offset = 250000;\nmint shash[limit];\n\n\nmint csum[limit];\nint cpos[limit];\n\nint main(void){\n\tint n;\n\tstring s;\n\tcin >> n >> s;\n\n\tshash[0] = ONE;\n\trep(i,1,limit) shash[i] = shash[i-1] * B;\n\n\tmint cur = ZERO;\n\tint pos = 0;\n\trep(i,n+1){\n\t\tcpos[i] = pos;\n\t\tcsum[i] = cur;\n\t\tif(i == n) break;\n\n\t\tif(s[i] == '+') cur += shash[pos + offset];\n\t\tif(s[i] == '-') cur -= shash[pos + offset];\n\t\tif(s[i] == '>') pos++;\n\t\tif(s[i] == '<') pos--;\n\t}\n\n\tmap<mint,int> num;\n\tnum[csum[n]]++;\n\n\tll ans = 0LL;\n\trrep(i,n){\n\t\tmint tar = csum[n];\n\t\tif(cpos[i] < 0) tar /= B.power(abs(cpos[i])); \n\t\tif(cpos[i] > 0) tar *= B.power(abs(cpos[i])); \n\t\ttar += csum[i];\n\t\tif(num.find(tar) != end(num)) ans += num[tar];\n\t\tnum[csum[i]]++;\n\t}\n\n\tcout << ans << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "    #include \"bits/stdc++.h\"\n    using namespace std;\n     \n    #define MAX 600012\n     \n    int n;\n    char buf[MAX];\n     \n     \n    string s;\n     \n     \n    //#define MOD1 1000000007\n    //#define MOD2 1000000009\n     \n    valarray<long long int> MOD1;\n    valarray<long long int> MOD2;\n    vector<valarray<long long int> > p2;\n    vector<valarray<long long int> > vv;\n    vector<int> ps;\n    map<pair<long long int,long long int>, int> mp;\n    long long int ppow(long long int i, long long int j, long long int MOD) {\n    \tlong long int ret = 1;\n    \twhile (j) {\n    \t\tif (j & 1LL)ret *= i;\n    \t\tif (ret >= MOD)ret %= MOD;\n    \t\tj >>= 1LL;\n    \t}\n    \treturn ret;\n    }\n     \n    valarray<long long int> calc(int dif) {\n    \tvalarray<long long int> ret;\n    \tret.resize(2, 0);\n    \tfor (int j = 0; j < 2; j++) {\n    \t\tif (dif < 0) {\n    \t\t\tret[j]=ppow(ppow(MOD1[j], abs(dif),MOD2[j]), MOD2[j] - 2,MOD2[j]);\n    \t\t}\n    \t\telse {\n    \t\t\tret[j] = ppow(MOD1[j], abs(dif), MOD2[j]);\n    \t\t}\n    \t}\n    \treturn ret;\n    }\n     \n    int main() {\n    \tMOD1.resize(2);\n    \tMOD2.resize(2);\n    \tp2.push_back(valarray<long long int>());\n    \tp2.back().resize(2);\n    \tp2.back()[0] = p2.back()[1] = 1;\n    \tMOD2[0] = 1000000007;\n    \tMOD1[0] = 998244353;\n    \tMOD1[1] = 555522277;\n    \tMOD2[1] = 1000000009;\n    \tp2[0] %= MOD2;\n    \tfor (int i = 1; i < MAX; i++) {\n    \t\tp2.push_back(p2.back());\n    \t\tp2[i] *= MOD1;\n    \t\tp2[i] %= MOD2;\n    \t}\n    \tcin >> n;\n    \tscanf(\"%s\", buf);\n    \ts = buf;\n    \tint pos = MAX/2;\n    \tvalarray<long long int> hs;\n    \ths.resize(2);\n    \ths[0] = hs[1] = 0;\n    \tvv.push_back(hs);\n    \tps.push_back(pos);\n    \tfor (int i = 0; i < s.size(); i++) {\n    \t\tif (s[i] == '<') {\n    \t\t\tpos--;\n    \t\t}\n    \t\tif (s[i] == '>') {\n    \t\t\tpos++;\n    \t\t}\n    \t\tif (s[i] == '+') {\n    \t\t\ths += p2[pos];\n    \t\t}\n    \t\tif (s[i] == '-') {\n    \t\t\ths -= p2[pos];\n    \t\t\ths += MOD2;\n    \t\t}\n    \t\ths %= MOD2;\n    \t\tvv.push_back(hs);\n    \t\tps.push_back(pos);\n    \t}\n    \tlong long int way = 0;\n    \tfor (int i = vv.size() - 1; i >= 0; i--) {\n    \t\tvalarray<long long int> want = vv[i] + vv.back()*calc(-MAX/2+ps[i]);\n    \t\twant = want%MOD2;\n    \t\tway += mp[make_pair(want[0], want[1])];\n    \t\t//cerr << \"dbg \" << way << endl;\n    \t\tif(want[0]<0LL||want[1]<0LL)exit(1);\n    \t\tif(vv[i][0]<0LL||want[1]<0LL)exit(1);\n    \t\tmp[make_pair(vv[i][0],vv[i][1])]++;\n    \t}\n    \tprintf(\"%lld\\n\", way);\n    \treturn 0;\n    }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <cmath>\n#include <cstdio>\n#include <cctype>\n#include <ctime>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <complex>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cwchar>\n#include <cwctype>\n#include <exception>\n#include <locale>\n#include <numeric>\n#include <new>\n#include <stdexcept>\n#include <limits>\n#include <valarray>\n#include <set>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <list>\n#include <utility>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int INF = 1e9 + 7;\n\nconst pair<LL, LL> HMOD = MP(998244353, 1004535809), HRAD = MP(243, 19683), HIRAD = MP(607984215, 858522653);\nmap<pair<LL, LL>, int> S;\nint n;\nchar ch[250005];\n\nint main()\n{\n\tcout << power(243, MOD - 2);\n\tscanf(\"%d%s\", &n, &ch);\n\tLL cur = MP(1, 1), cnt = MP(0, 0);\n\trep(i, n) {\n\t\tif(ch[i] == '+') cnt.first = (cnt.first + cur.first) % HMOD.first;\n\t\tif(ch[i] == '-') cnt.first = (cnt.first - cur.first + HMOD.first) % HMOD.first;\n\t\tif(ch[i] == '<') cur.first = cur.first * HIRAD.first % HMOD.first;\n\t\tif(ch[i] == '>') cur.first = cur.first * HRAD.first % HMOD.first;\n\t\tif(ch[i] == '+') cnt.second = (cnt.second + cur.second) % HMOD.second;\n\t\tif(ch[i] == '-') cnt.second = (cnt.second - cur.second + HMOD.second) % HMOD.second;\n\t\tif(ch[i] == '<') cur.second = cur.second * HIRAD.second % HMOD.second;\n\t\tif(ch[i] == '>') cur.second = cur.second * HRAD.second % HMOD.second;\n\t\tS[cnt] ++;\n\t}\n\tpair<LL, LL> ss = cnt;\n\tans = S[ss];\n\tcur = MP(1, 1); cnt = MP(0, 0);\n\trep(i, n) {\n\t\tif(ch[i] == '+') cnt.first = (cnt.first + cur.first) % HMOD.first;\n\t\tif(ch[i] == '-') cnt.first = (cnt.first - cur.first + HMOD.first) % HMOD.first;\n\t\tif(ch[i] == '<') cur.first = cur.first * HIRAD.first % HMOD.first;\n\t\tif(ch[i] == '>') cur.first = cur.first * HRAD.first % HMOD.first;\n\t\tif(ch[i] == '+') cnt.second = (cnt.second + cur.second) % HMOD.second;\n\t\tif(ch[i] == '-') cnt.second = (cnt.second - cur.second + HMOD.second) % HMOD.second;\n\t\tif(ch[i] == '<') cur.second = cur.second * HIRAD.second % HMOD.second;\n\t\tif(ch[i] == '>') cur.second = cur.second * HRAD.second % HMOD.second;\n\t\tS[cnt] --;\n\t\tans += S[MP((cnt.first + cur.first * ss.first) % HMOD.first, (cnt.second + cur.second * ss.second) % HMOD.second)];\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int N = 501000,mod2 = 1000000007,mod1 = 998244353;\nll *p1,_p1[N],*p2,_p2[N],h1[N],h2[N];\nint W[N],n;\nchar s[N];\nmap<pair<ll,ll>,int> mp;\nll fp(ll a,ll k,ll mod){\n\tll ans=1;\n\tfor(;k;k>>=1,a=a*a%mod)\n\t\tif(k&1) ans=a*ans%mod;\n\treturn ans;\n}\nint main(){\n\tios::sync_with_stdio(0);\n\tcin>>n;\n\tcin>>s+1;\n\tp1=_p1+n+10;p1[-n]=1;\n\tfor(int i=-n+1;i<=n;i++) p1[i]=p1[i-1]*434783%mod1;\n\tp2=_p2+n+10;p2[-n]=1;\n\tfor(int i=-n+1;i<=n;i++) p2[i]=p2[i-1]*434783%mod2;\n\tll hsh1=0,hsh2=0;\n\tint w=0;\n\tfor(int i=1;i<=n;i++){\n\t\tif(s[i]=='<') w--;\n\t\tif(s[i]=='>') w++;\n\t\tW[i]=w;\n\t\tif(s[i]=='+'){\n\t\t\th1[i]=p1[w];h2[i]=p2[w];\n\t\t\thsh1=(hsh1+p1[w])%mod1;\n\t\t\thsh2=(hsh2+p2[w])%mod2;\n\t\t}\n\t\tif(s[i]=='-'){\n\t\t\th1[i]=mod1-p1[w];\n\t\t\th2[i]=mod2-p2[w];\n\t\t\thsh1=(hsh1-p1[w]+mod1)%mod1;\n\t\t\thsh2=(hsh2-p2[w]+mod2)%mod2;\n\t\t}\n\t\tmp[make_pair(hsh1,hsh2)]++;\n\t}\n\tll now1=0,now2=0,ans=0;\n\tfor(int i=1;i<=n;i++){\n\t\tif(W[i-1]>0) ans+=mp[make_pair((hsh1*fp(434783,W[i-1],mod1)+now1)%mod1,(hsh2*fp(434783,W[i-1],mod2)+now2)%mod2)];\n\t\telse ans+=mp[make_pair((hsh1*fp(743624691,-W[i-1],mod1)+now1)%mod1,(hsh2*fp(620380746,-W[i-1],mod2)+now2)%mod2)];\n\t\tif(s[i]=='-'||s[i]=='+') now1=(now1+h1[i])%mod1,now2=(now2+h2[i])%mod2;\n\t\tmp[make_pair(now1,now2)]--;\n\t}\n\tcout<<ans<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define mod 10000723\nusing namespace std;\nint n,f[1001000],X,Y,ans;\nchar S[1001000];\nmap<int,int>mp;\nint quickpow(int x,int y){\n\tif(y==0)return 1;\n\tif(y%2==0)return quickpow(x*x%mod,y/2);\n\treturn quickpow(x*x%mod,y/2)*x%mod;\n}\nsigned main(){\n\tscanf(\"%lld%s\",&n,S+1);\n\tX=1;\n\tint base=10007,inv=quickpow(base,mod-2);\n\tfor(int i=1;i<=n;i++){\n\t\tif(S[i]=='+')f[i]=f[i-1]+X;\n\t\tif(S[i]=='-')f[i]=f[i-1]-X;\n\t\tif(S[i]=='<')f[i]=f[i-1],X=X*base%mod;\n\t\tif(S[i]=='>')f[i]=f[i-1],X=X*inv%mod;\n\t\tmp[f[i]]++;\t\t\n\t}\n\tX=1,Y=0;\n\tfor(int i=1;i<=n;i++){\n\t\tans=ans+mp[f[n]*X+Y];\n\t\tif(S[i]=='+')Y=Y+X;\n\t\tif(S[i]=='-')Y=Y-X;\n\t\tif(S[i]=='<')X=X*base%mod;\n\t\tif(S[i]=='>')X=X*inv%mod;\n\t\tmp[f[i]]--;\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define int long long\n#define ull unsigned long long\n\nconst int Maxv = 500010; \nconst ull Prime1 = 239; \nconst ull Prime2 = 223372036854775763; \n                            \nint idx[Maxv], ans, n; \null Hash[Maxv], val[Maxv]; \nchar s[Maxv]; \n\nstd::unordered_map<ull, int> Map; \n\ninline void PreHandle() {\n    val[n] = 1; \n    for (int i = n + 1; i <= (n << 1); i++)\n        val[i] = val[i - 1] * Prime1; \n    for (int i = n - 1; i >= 0; i--)\n        val[i] = val[i + 1] * Prime2; \n}\n\nsigned main() {\n    scanf(\"%d\", &n); \n    scanf(\"%s\", s); \n\n    PreHandle(); \n\n    for (int i = 0; i < n; i++) {\n        Hash[i + 1] = Hash[i]; \n        idx[i + 1] = idx[i]; \n\n        if (s[i] == '>')\n            idx[i + 1]++; \n        if (s[i] == '<')\n            idx[i + 1]--;\n        if (s[i] == '+')\n            Hash[i + 1] += val[n + idx[i + 1]]; \n        if (s[i] == '-')\n            Hash[i + 1] -= val[n + idx[i + 1]]; \n    }\n    \n    for (int i = n; i >= 0; i--) {\n        ull tmp = Hash[i] + Hash[n] * val[n + idx[i]];\n        ans += Map[tmp]; \n        Map[ Hash[i] ]++;\n    }\n\n    printf(\"%lld\\n\", ans);\n\n    return 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\nconst int   N   = 5e5 + 1;\nconst int   B   = 1e8 + 1;\n\ntypedef pair<int,int>   ii;\ntypedef pair<ii,ii>     pii;\n\nint qpow(int a,int exp,int mod) {\n    if(exp < 0) exp = mod - 1 + exp;\n    int ans = 1;\n    while (exp) {\n        if(exp & 1) ans = ans * a % mod;\n        a = a * a % mod;  exp >>= 1;\n    }\n    return ans;\n}\n\nvoid add(int &a,int b,int mod) {\n    a += b;\n    if(a >= mod)a -= mod;\n    if(a < 0)   a += mod;\n}\n\nint mod[4];\nint n, f[N];\nint H[N][4];\nstring S;\n\nvoid process(int t)   {\n    for(int i = 1 ; i <= n ; ++i)   {\n        H[i][t] = H[i - 1][t];\n        if(S[i - 1] == '+') add(H[i][t], qpow(B,f[i],mod[t]),mod[t]);\n        if(S[i - 1] == '-') add(H[i][t],-qpow(B,f[i],mod[t]),mod[t]);\n    }\n}\n\nmap<pii,int> mp;\n\nsigned main()   {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    cin >> n >> S;\n\n    for(int i = 0 ; i < n ; ++i)    {\n        f[i + 1] = f[i];\n        if(S[i] == '>') f[i + 1]++;\n        if(S[i] == '<') f[i + 1]--;\n    }\n\n    mod[0] = 1e9 + 7;\n    mod[1] = 1e9 + 9;\n    mod[2] = 1e9 + 21;\n    mod[3] = 1e9 + 33;\n\n    process(0);\n    process(1);\n    process(2);\n    process(3);\n\n    mp[pii({H[n][0],H[n][1]},{H[n][2],H[n][3]})] = 1;\n\n    int ans = 0;\n\n    for(int i = 1 ; i <= n ; ++i)   {\n        ans += mp[pii({H[i][0],H[i][1]},{H[i][2],H[i][3]})];\n        int res0 = H[n][0] * qpow(B,f[i],mod[0]) + H[i][0];\n        int res1 = H[n][1] * qpow(B,f[i],mod[1]) + H[i][1];\n        int res2 = H[n][2] * qpow(B,f[i],mod[2]) + H[i][2];\n        int res3 = H[n][3] * qpow(B,f[i],mod[3]) + H[i][3];\n        res0 %= mod[0]; res1 %= mod[1];\n        res2 %= mod[2]; res3 %= mod[3];\n        mp[pii({res0,res1},{res2,res3})]++;\n    }\n\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define LL long long\nint n;\nint powi(int a, int b, int m)\n{\n    int c = 1;\n    for (; b; b >>= 1, a = 1ll * a * a % m)\n        if (b & 1) c = 1ll * c * a % m;\n    return c;\n}\nconst int BAS = 233;\nconst int MOD1 = 1e9 + 7;\nconst int MOD2 = 1e9 + 9;\nconst int BIV1 = powi(BAS, MOD1 - 2, MOD1);\nconst int BIV2 = powi(BAS, MOD2 - 2, MOD2);\nconst int N = 200000;\nchar st[N];\npair <int, int> V[N], S[N];\nmap <pair <int, int>, int> C;\nLL res;\nint main()\n{\n    scanf(\"%d\", &n);\n    scanf(\"%s\", st + 1);\n    V[0] = make_pair(1, 1);\n    for (int i = 1; i <= n; ++ i)\n    {\n        if (st[i] == '>')\n            V[i] = make_pair(1ll * V[i - 1].first * BAS % MOD1, 1ll * V[i - 1].second * BAS % MOD2),\n            S[i] = S[i - 1];\n        else if (st[i] == '<')\n            V[i] = make_pair(1ll * V[i - 1].first * BIV1 % MOD1, 1ll * V[i - 1].second * BIV2 % MOD2),\n            S[i] = S[i - 1];\n        else if (st[i] == '+')\n            V[i] = V[i - 1],\n            S[i] = make_pair((S[i - 1].first + V[i].first) % MOD1, (S[i - 1].second + V[i].second) % MOD2);\n        else if (st[i] == '-')\n            V[i] = V[i - 1],\n            S[i] = make_pair((S[i - 1].first - V[i].first + MOD1) % MOD1, (S[i - 1].second - V[i].second + MOD2) % MOD2);\n    }\n    for (int i = n; ~i; -- i)\n    {\n        res += C[make_pair((1ll * S[n].first * V[i].first + S[i].first) % MOD1,\n            (1ll * S[n].second * V[i].second + S[i].second) % MOD2)];\n        C[S[i]] ++;\n    }\n    printf(\"%lld\\n\", res);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <list>\n#include <time.h>\n#include <math.h>\n#include <random>\n#include <deque>\n#include <queue>\n#include <cassert>\n#include <unordered_map>\n#include <unordered_set>\n#include <iomanip>\n#include <bitset>\n#include <sstream>\n\nusing namespace std;\n\ntypedef long long ll;\n\nmt19937 rnd(228);\n\nconst int M = 1791791791;\nconst int B = 239;\n\ninline int add(int a, int b)\n{\n    a += b;\n    if (a >= M) a -= M;\n    if (a < 0) a += M;\n    return a;\n}\n\ninline int mul(int a, int b)\n{\n    return (a * (ll) b) % M;\n}\n\ninline int bin(int a, int n)\n{\n    int res = 1;\n    while (n)\n    {\n        if (n % 2 == 0)\n        {\n            a = mul(a, a);\n            n /= 2;\n        }\n        else\n        {\n            res = mul(res, a);\n            n--;\n        }\n    }\n    return res;\n}\n\nconst int rev_B = bin(B, M - 2);\n\nstring s;\nint n;\n\nint main()\n{\n#ifdef ONPC\n    freopen(\"a.in\", \"r\", stdin);\n#endif\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cin >> n;\n    cin >> s;\n    int cur = 1;\n    int hsh = 0;\n    vector <int> p(n + 1);\n    vector <int> h(n + 1);\n    p[0] = 1;\n    h[0] = 0;\n    for (int i = 0; i < n; i++)\n    {\n        if (s[i] == '>')\n        {\n            cur = mul(cur, B);\n        }\n        else if (s[i] == '<')\n        {\n            cur = mul(cur, rev_B);\n        }\n        else if (s[i] == '+')\n        {\n            hsh = add(hsh, cur);\n        }\n        else\n        {\n            hsh = add(hsh, -cur);\n        }\n        p[i + 1] = cur;\n        h[i + 1] = hsh;\n    }\n    ll ans = 0;\n    map <int, int> ret;\n    for (int i = n; i >= 0; i--)\n    {\n        int need = add(mul(hsh, p[i]), h[i]);\n        ans += ret[need];\n        ret[h[i]]++;\n    }\n    cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll=long long;\n\n#define K 6 \n#define rep(i) for(int i=0;i<K;i++)\nusing Token=array<int,K>;\n\n//const ll R = 843823891, iR = 1040004855;\nconst ll R[K] = {3213,24289,34299,929923,438,42};\nconst ll iR[K] = {727200786, 1395409909, 1110851529, 35704193, 1005586100, 1598363886};\n\nconst ll M = 1637348371;\nll mpow(ll x, int64_t e) {\n    ll res = 1;\n    for (; e; e >>= 1) {\n        if (e & 1) res *= x, res %= M;\n        x *= x, x %= M;\n    }\n    return res;\n}\nll minv(ll x) {\n    return mpow(x, M-2);\n}\n\nstruct Lm {\n    ll k,b;\n    Lm() {}\n    Lm(ll _k,ll _b): k(_k),b(_b){}\n    Lm(char x, int i) {\n        if (x == '+') k = 1, b = 1;\n        if (x == '-') k = 1, b = M-1;\n        if (x == '>') k = R[i], b = 0;\n        if (x == '<') k = iR[i],b = 0;\n    }\n    Lm(const Lm& _lm): k(_lm.k), b(_lm.b){}\n    Lm& operator*=(const Lm& _lm){\n        b += k*_lm.b%M; b %= M;\n        k *= _lm.k; k %= M;\n        return *this;\n    }\n    Lm inv(){\n        ll ik = minv(k);\n        ll ib = -ik*b; ib %= M; (ib+=M)%=M;\n        return {ik,ib};\n    }\n    ll eval(ll x) {\n        return (k*x%M+b)%M;\n    }\n};\nLm operator*(const Lm& _a, const Lm& _b) {\n    return Lm(_a) *= _b;\n}\nvoid solve() {\n    int n; cin >> n;\n    string s; cin >> s;\n    vector<Lm> a[6], ia[6];\n    vector<Token> z(n+1), g(n);\n    rep(k) {\n    for (int i = 0; i < n; i++) {\n        a[k].emplace_back(s[i], k);\n        ia[k].emplace_back(a[k][i].inv());\n    }\n    auto isuf = ia;\n    for (int i = n-2; i >= 0; i--) {\n        isuf[k][i] = isuf[k][i+1] * isuf[k][i];\n    }\n    ll c = isuf[k][0].inv().eval(0);\n    z[n][k] = 0;\n    for (int i = 0; i < n; i++) {\n        z[i][k] = isuf[k][i].eval(0);\n        g[i][k] = isuf[k][i].eval(c);\n    }\n    }\n    map<Token, int> cnt;\n    ll res = 0;\n    for (int i = 0; i < n; i++) {\n        cnt[g[i]]++;\n        res += cnt[z[i+1]];\n    }\n    cout << res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    solve();\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <unordered_map>\n\ntypedef long long LL;\nconst int Mod[2] = {999988679, 999988609};\nconst int B[2] = {370728, 370732};\nconst int iB[2] = {396903752, 462741403};\nconst int MN = 250005;\n\ninline void Add(int &x, int y, int i) { x -= (x += y) >= Mod[i] ? Mod[i] : 0; }\n\nint N;\nchar S[MN];\nint A[2][MN], D[2][MN];\nstd::unordered_map<LL, int> Buk;\nLL Ans;\n\nint main() {\n\tscanf(\"%d%s\", &N, S + 1);\n\tfor (int j = 0; j < 2; ++j) A[j][0] = 0, D[j][0] = 1;\n\tfor (int i = 1, V[2] = {1, 1}; i <= N; ++i) {\n\t\tfor (int j = 0; j < 2; ++j) {\n\t\t\tA[j][i] = A[j][i - 1];\n\t\t\tif (S[i] == '+') Add(A[j][i], V[j], j);\n\t\t\tif (S[i] == '-') Add(A[j][i], Mod[j] - V[j], j);\n\t\t\tif (S[i] == '>') V[j] = (LL)V[j] * B[j] % Mod[j];\n\t\t\tif (S[i] == '<') V[j] = (LL)V[j] * iB[j] % Mod[j];\n\t\t\tD[j][i] = V[j];\n\t\t}\n\t}\n\tfor (int i = N; i >= 0; --i) {\n\t\tAns += Buk[\n\t\t\t(A[0][i] + (LL)A[0][N] * D[0][i]) % Mod[0] +\n\t\t\t(A[1][i] + (LL)A[1][N] * D[1][i]) % Mod[1] * Mod[0]\n\t\t];\n\t\t++Buk[A[0][i] + (LL)A[1][i] * Mod[0]];\n\t}\n\tprintf(\"%lld\\n\", Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ull unsigned long long\nusing namespace std;\nconst int N=3e5+5;\nchar s[N];\null base=233,inv=7204522363551799129,f[N];\null x=1,y,ans=0;\nint n;\nunordered_map<ull,int>mp;\nint main()\n{\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",s+1);\n\tfor(int i=1;i<=n;i++)\n    {\n        f[i]=f[i-1];\n        if(s[i]=='+') f[i]+=x;\n        if(s[i]=='-') f[i]-=x;\n        if(s[i]=='>') x*=base;\n        if(s[i]=='<') x*=inv;\n        mp[f[i]]++;\n    }\n    x=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tans+=mp[f[n]*x+y];\n\t\tif(s[i]=='+') y+=x;\n\t\tif(s[i]=='-') y-=x;\n\t\tif(s[i]=='>') x*=base;\n\t\tif(s[i]=='<') x*=inv;\n\t\tmp[f[i]]--;\n\t}\n\tprintf(\"%llu\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "const int N = 400005;\nconst int LG = 21;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nint n;\nstring s;\nll sufa[N];\nll suf0[N];\nll sufa2[N];\nll suf02[N];\nconst ll K = 1e6 + 3;\nconst ll K2 = 1791791;\nconst ll rK = rev(K);\nconst ll rK2 = rev(K2);\nll pref0[N];\nll pref02[N];\nll moves[N];\nmap<int, ll> deg, deg2;\n\nsigned main()\n{\n    deg[0] = 1;\n    deg2[0] = 1;\n    for (int i = 1; i < N; i++) deg[i] = deg[i - 1] * K % MOD;\n    for (int i = 1; i < N; i++) deg2[i] = deg2[i - 1] * K2 % MOD;\n    for (int i = 1; i < N; i++) deg[-i] = deg[-i + 1] * rK % MOD;\n    for (int i = 1; i < N; i++) deg2[-i] = deg2[-i + 1] * rK2 % MOD;\n    srand(time(NULL));\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n    cin >> n >> s;\n    ll a = 0, a2 = 0;\n    for (int i = n - 1; i >= 0; i--)\n    {\n        if (s[i] == '+')\n        {\n            a = (a + MOD - 1) % MOD;\n            a2 = (a2 + MOD - 1) % MOD;\n        }\n        if (s[i] == '-')\n        {\n            a = (a + 1) % MOD;\n            a2 = (a2 + 1) % MOD;\n        }\n        if (s[i] == '>')\n        {\n            a = (a * K) % MOD;\n            a2 = (a2 * K2) % MOD;\n        }\n        if (s[i] == '<')\n        {\n            a = (a * rK) % MOD;\n            a2 = (a2 * rK2) % MOD;\n        }\n    }\n    if (s[0] == '+') pref0[0] = (pref0[0] + 1) % MOD;\n    if (s[0] == '+') pref02[0] = (pref02[0] + 1) % MOD;\n    if (s[0] == '-') pref0[0] = (pref0[0] + MOD - 1) % MOD;\n    if (s[0] == '-') pref02[0] = (pref02[0] + MOD - 1) % MOD;\n    if (s[0] == '<') pref0[0] = (pref0[0] * K) % MOD;\n    if (s[0] == '<') pref02[0] = (pref02[0] * K2) % MOD;\n    if (s[0] == '>') pref0[0] = (pref0[0] * rK) % MOD;\n    if (s[0] == '>') pref02[0] = (pref02[0] * rK2) % MOD;\n    if (s[0] == '>') moves[0]++;\n    if (s[0] == '<') moves[0]--;\n    for (int i = 1; i < n; i++)\n    {\n        if (s[i] == '+') pref0[i] = (pref0[i - 1] + 1) % MOD;\n        if (s[i] == '+') pref02[i] = (pref02[i - 1] + 1) % MOD;\n        if (s[i] == '-') pref0[i] = (pref0[i - 1] + MOD - 1) % MOD;\n        if (s[i] == '-') pref02[i] = (pref02[i - 1] + MOD - 1) % MOD;\n        if (s[i] == '<') pref0[i] = (pref0[i - 1] * K) % MOD;\n        if (s[i] == '<') pref02[i] = (pref02[i - 1] * K2) % MOD;\n        if (s[i] == '>') pref0[i] = (pref0[i - 1] * rK) % MOD;\n        if (s[i] == '>') pref02[i] = (pref02[i - 1] * rK2) % MOD;\n        moves[i] = moves[i - 1];\n        if (s[i] == '>') moves[i]++;\n        if (s[i] == '<') moves[i]--;\n    }\n    for (int j = 0; j < n; j++)\n    {\n        if (s[j] == '+')\n        {\n            suf0[0] = (suf0[0] + 1) % MOD;\n            suf02[0] = (suf02[0] + 1) % MOD;\n        }\n        if (s[j] == '-')\n        {\n            suf0[0] = (suf0[0] + MOD - 1) % MOD;\n            suf02[0] = (suf02[0] + MOD - 1) % MOD;\n        }\n        if (s[j] == '<')\n        {\n            suf0[0] = (suf0[0] * K) % MOD;\n            suf02[0] = (suf02[0] * K2) % MOD;\n        }\n        if (s[j] == '>')\n        {\n            suf0[0] = (suf0[0] * rK) % MOD;\n            suf02[0] = (suf02[0] * rK2) % MOD;\n        }\n    }\n    for (int i = 0; i < n; i++) suf0[i + 1] = (suf0[0] - pref0[i] * deg[moves[i]] + MOD * MOD) % MOD;\n    for (int i = 0; i < n; i++) suf02[i + 1] = (suf02[0] - pref02[i] * deg2[moves[i]] + MOD * MOD) % MOD;\n    for (int i = 0; i < n; i++) sufa[i] = (suf0[i] + a * deg[(i > 0 ? moves[i - 1] : 0) - moves[n - 1]]) % MOD;\n    for (int i = 0; i < n; i++) sufa2[i] = (suf02[i] + a2 * deg2[(i > 0 ? moves[i - 1] : 0) - moves[n - 1]]) % MOD;\n    ll ans = 0;\n    map<vector<ll>, ll> cnt;\n    for (int i = n; i >= 0; i--)\n    {\n        ans += cnt[{sufa[i], sufa2[i]}];\n        cnt[{suf0[i], suf02[i]}]++;\n    }\n    cout << ans;\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\ntypedef long double louble;\n\ntemplate<typename T1,typename T2> inline T1 max(T1 a,T2 b){return a<b?b:a;}\ntemplate<typename T1,typename T2> inline T1 min(T1 a,T2 b){return a<b?a:b;}\n\nconst char lf = '\\n';\n\nnamespace ae86\n{\n\tconst int bufl = 1<<15;\n\n\tchar buf[bufl],*s=buf,*t=buf;\n\n\tinline int fetch()\n\t{\n\t\tif(s==t){t=(s=buf)+fread(buf,1,bufl,stdin);if(s==t)return EOF;}\n\t\treturn *s++;\n\t}\n\n\tinline int ty()\n\t{\n\t\tint a=0,b=1,c=fetch();\n\t\twhile(!isdigit(c))b^=c=='-',c=fetch();\n\t\twhile(isdigit(c))a=a*10+c-48,c=fetch();\n\t\treturn b?a:-a;\n\t}\n\n\ttemplate<typename T> inline int ts(T *s)\n\t{\n\t\tint a=0,c=fetch();\n\t\twhile(c<=32 && c!=EOF)c=fetch();\n\t\twhile(c>32 && c!=EOF)s[a++]=c,c=fetch();\n\t\ts[a]=0;\n\t\treturn a;\n\t}\n}\nusing ae86::ty;\nusing ae86::ts;\n\nconst int _ = 250007;\nconst lint bas = 250007 , mo = 10996608743;\n\ninline lint sfx(lint a,lint b)\n{\n\ta%=mo,b%=mo;\n\treturn (a*b-(lint)((louble)a/mo*b+0.5)*mo+mo)%mo;\n}\n\ninline lint powa(lint a,lint t)\n{\n\tlint b=1;\n\twhile(t){if(t&1)b=sfx(a,b);a=sfx(a,a),t>>=1;}\n\treturn b;\n}\n\ninline lint inva(lint a)\n{\n\treturn powa(a,mo-2);\n}\n\nconst lint ibas = inva(bas);\n\nint n;char s[_];\nlint loc[_];\nunordered_map<lint,int> cnt;\n\ninline lint trans(lint h,char op)\n{\n\tif(op=='<')return sfx(h,ibas);\n\tif(op=='>')return sfx(h,bas);\n\tif(op=='+')return (h+1)%mo;\n\tif(op=='-')return (h-1+mo)%mo;\n\tthrow \"fuck me\";\n}\n\nint main()\n{\n\tios::sync_with_stdio(0),cout.tie(nullptr);\n\n\tn=ty(),ts(s+1);\n\n\tloc[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tloc[i]=loc[i-1];\n\t\tif(s[i]=='<')loc[i]=sfx(loc[i],ibas);\n\t\tif(s[i]=='>')loc[i]=sfx(loc[i],bas);\n\t}\n\n\tlint tar=0;\n\tfor(int i=n;i>=1;i--)tar=trans(tar,s[i]);\n\tcnt[0]=1;\n\tlint ans=0,now=0;\n\tfor(int i=n;i>=1;i--)\n\t\tnow=trans(now,s[i]),ans+=cnt[sfx(now-tar+mo,loc[i-1])],cnt[sfx(now,loc[i-1])]++;\n\tcout<<ans<<lf;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000009;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\ntypedef pair<int, bool> sP;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef pair<ll, ll> LP;\ntypedef vector<ll> vec;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef vector<vector<ll>> mat;\ntypedef vector<ll> vec;\n\nll r = 998244353;\nll mod_pow(ll x, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n % 2)res = res * x%mod;\n\t\tx = x * x%mod; n >>= 1;\n\t}\n\treturn res;\n}\nll invr = mod_pow(r, mod-2);\n\nll tr[300000];\nll invtr[300000];\nvoid init() {\n\ttr[0] = invtr[0] = 1;\n\trep(i, 299999) {\n\t\ttr[i + 1] = tr[i] * r%mod;\n\t\tinvtr[i + 1] = invtr[i] * invr%mod;\n\t}\n}\n\nvoid solve() {\n\tint n; cin >> n;\n\tstring s; cin >> s;\n\tll sum = 0; int loc = 0;\n\tvector<ll> memo(n);\n\tvector<int> locs(n);\n\trep(i, n) {\n\t\tif (s[i] == '>')loc++;\n\t\telse if (s[i] == '<')loc--;\n\t\telse if (s[i] == '+') {\n\t\t\tif (loc >= 0) {\n\t\t\t\tsum += tr[loc];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsum += invtr[-loc];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (loc >= 0) {\n\t\t\t\tsum -= tr[loc];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsum -= invtr[-loc];\n\t\t\t}\n\t\t}\n\t\tsum = (sum%mod + mod) % mod;\n\t\tmemo[i] = sum;\n\t\tlocs[i] = loc;\n\t}\n\tll all = sum;\n\t//cout << all << endl;\n\tll ans = 0;\n\tmap<ll, int> mp;\n\tmp[all]++;\n\trep(i, n) {\n\t\tcout << mp[memo[i]] << endl;\n\t\tans += mp[memo[i]];\n\t\tll nex = all;\n\t\tif (nex < 0)nex += mod;\n\t\tif (locs[i] >= 0) {\n\t\t\tnex = nex * tr[locs[i]] % mod;\n\t\t}\n\t\telse {\n\t\t\tnex = nex * invtr[-locs[i]] % mod;\n\t\t}\n\t\tnex += memo[i];\n\t\tnex %= mod;\n\t\tmp[nex]++;\n\t}\n\tcout << ans << endl;\n}\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(7);\n\tinit();\n\t//output_tree(10);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 250001,M = 1e9 + 9,b = 1e9 + 7;\nint cs[N],p[N],n;\nmap<int,int>mp;\nvoid add(int &a,int b){\n\ta+=b;\n\tif(a >= M)a-=M;\n\tif(a < 0)a+=M;\n}\nint power(int base,int to){\n\tint ret = 1;\n\twhile(to){\n\t\tif(to&1)ret = ret*1LL*base%M;\n\t\tto>>=1;\n\t\tbase = base*1LL*base%M;\n\t}\n\treturn ret;\n}\nint main(){\n\t//freopen(\"readin.txt\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tp[0] = 1;\n\tchar c;\n\tint inv = power(b,M - 2);\n\tfor(int i = 1;i <= n;i++){\n\t\tscanf(\" %c\",&c);\n\t\tcs[i] = cs[i - 1];\n\t\tp[i] = p[i - 1];\n\t\tif(c == '+')add(cs[i],p[i]);\n\t\telse if(c == '-')add(cs[i],-p[i]);\n\t\telse if(c == '>')p[i] = p[i]*1LL*b%M;\n\t\telse if(c == '<')p[i] = p[i]*1LL*inv%M;\n\t}\n\tlong long ans = 0;\n\tfor(int i = 0;i <= n;i++){\n\t\tans+=mp[cs[i]];\n\t\tmp[(cs[n]*1LL*p[i] + cs[i] + M)%M]++;\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<map>\n#define ll long long\n#define mid (l+r)/2\nusing namespace std;\nconst ll MOD=1e9+9,b=1000003,invb=27749917;\nint n;\nchar s[250005];\nll v,v1[250005],p1[250005],v2[250005],ans;\nmap<ll,int>mp;\nvoid solve(int l,int r)\n{\n\tif(l==r)\n\t{\n\t\tif(s[l]=='+'&&v==1)ans++;\n\t\tif(s[l]=='-'&&v==MOD-1)ans++;\n\t\tif(s[l]=='<'&&v==0)ans++;\n\t\tif(s[l]=='>'&&v==0)ans++;\n\t\treturn;\n\t}\n\tsolve(l,mid);\n\tsolve(mid+1,r);\n\tv1[mid+1]=v2[mid]=0;\n\tp1[mid+1]=1;\n\tfor(int i=mid;i>=l;i--)\n\t{\n\t\tif(s[i]=='+')v1[i]=(v1[i+1]+1)%MOD,p1[i]=p1[i+1];\n\t\tif(s[i]=='-')v1[i]=(v1[i+1]-1+MOD)%MOD,p1[i]=p1[i+1];\n\t\tif(s[i]=='<')v1[i]=v1[i+1]*invb%MOD,p1[i]=p1[i+1]*b%MOD;\n\t\tif(s[i]=='>')v1[i]=v1[i+1]*b%MOD,p1[i]=p1[i+1]*invb%MOD;\n\t}\n\tll now=1;\n\tfor(int i=mid+1;i<=r;i++)\n\t{\n\t\tif(s[i]=='+')v2[i]=(v2[i-1]+now)%MOD;\n\t\tif(s[i]=='-')v2[i]=(v2[i-1]-now+MOD)%MOD;\n\t\tif(s[i]=='<')now=now*invb%MOD,v2[i]=v2[i-1];\n\t\tif(s[i]=='>')now=now*b%MOD,v2[i]=v2[i-1];\n\t\tmp[v2[i]]++;\n\t}\n\tfor(int i=l;i<=mid;i++)ans+=mp[(v-v1[i]+MOD)*p1[i]%MOD];\n\tfor(int i=mid+1;i<=r;i++)mp[v2[i]]=0;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",s+1);\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tif(s[i]=='+')v=(v+1)%MOD;\n\t\tif(s[i]=='-')v=(v-1+MOD)%MOD;\n\t\tif(s[i]=='<')v=v*invb%MOD;\n\t\tif(s[i]=='>')v=v*b%MOD;\n\t}\n\tsolve(1,n);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst ll MAX=250020;\nconst ll MOD1=1000000007;\nconst ll MOD2=1000000009;\nconst ll p=250007;\nll N,lux1[2*MAX],lux2[2*MAX],ptarr[MAX],ans;\nchar S[MAX];\nmap<pll,ll> cum;\nll power(ll x,ll y,ll m){\n    if(y==0) return 1;\n    ll t=power(x,y/2,m);\n    if(y%2) return t*t%m*x%m;\n    return t*t%m;\n}\nvoid dc(ll idx,ll mul,ll *pt,ll* val1,ll* val2){\n    switch(S[idx]){\n    case '<':\n        *pt-=1; break;\n    case '>':\n        *pt+=1; break;\n    case '+':\n        *val1+=mul*lux1[*pt];\n        *val2+=mul*lux2[*pt];\n        break;\n    case '-':\n        *val1-=mul*lux1[*pt];\n        *val2-=mul*lux2[*pt];\n        break;\n    }\n    *val1+=MOD1,*val1%=MOD1;\n    *val2+=MOD2,*val2%=MOD2;\n}\nint main(){\n    scanf(\" %lld %s\",&N,S);\n    lux1[N]=1,lux2[N]=1;\n    int inv_p1=power(p,MOD1-2,MOD1),inv_p2=power(p,MOD2-2,MOD2);\n    for(ll i=N;i<=2*N-1;i++) {\n        lux1[i+1]=lux1[i]*p%MOD1;\n        lux2[i+1]=lux2[i]*p%MOD2;\n    }\n    for(ll i=N;i>=1;i--) {\n        lux1[i-1]=lux1[i]*inv_p1%MOD1;\n        lux2[i-1]=lux2[i]*inv_p2%MOD2;\n    }\n    ll pt1=N,pt2=N;\n    pll val1(0,0),val2(0,0),val3(0,0);\n    for(ll i=0;i<N;i++) dc(i,1,&pt2,&val2.first,&val2.second);\n    pt2=N; val3=val2;\n    for(ll i=0;i<N;i++){\n        ll t1,t2;\n        t1=((val3.first-val3.first*lux1[pt1]-val1.first)%MOD1+MOD1)%MOD1;\n        t2=((val3.second-val3.second*lux2[pt1]-val1.second)%MOD2+MOD2)%MOD2;\n        cum[make_pair(t1,t2)]++;\n        dc(i,-1,&pt2,&val2.first,&val2.second);\n        //printf(\"val2: %lld %lld %lld\\n\",pt2,t1,t2);\n        //printf(\"val1: %lld %lld %lld\\n\",pt1,val1.first,val1.second);\n        ans+=cum[val2];\n        dc(i,1,&pt1,&val1.first,&val1.second);\n    }\n    printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int Mod = 1e9 + 7, Nmax = 5e5 + 5, Pow = 666013;\ntypedef long long ll;\n\nint sP[Nmax], i, n, P, target;\nll Pw[Nmax], E[Nmax], R[Nmax], ans = 0, Inv, InvP[Nmax];\nmap<int, int> mp;\nchar a[Nmax];\n\n\nll power(ll a, int b)\n{\n    ll ans = 1;\n    while(b)\n    {\n        if(b&1) ans = ans * a % Mod;\n        b >>= 1; a = a*a%Mod;\n    }\n    return ans;\n}\n\nint main()\n{\n  //  freopen(\"input\", \"r\", stdin);\n  //  freopen(\"output\", \"w\", stdout);\n    cin.sync_with_stdio(false);\n\n    cin >> n >> (a+1);\n\n    for(i=1; i<=n; ++i) sP[i] = sP[i-1] - (a[i] == '<') + (a[i] == '>');\n\n    Inv = power(Pow, Mod-2);\n    Pw[0] = 1; InvP[0] = 1;\n    for(i=1; i<=2*n; ++i) Pw[i] = Pw[i-1] * Pow % Mod, InvP[i] = InvP[i-1] * Inv % Mod;\n\n    P = n;\n    for(i=1; i<=n; ++i) /// for 1..,i\n    {\n        E[i] = E[i-1];\n        if(a[i] == '<')\n        {\n            --P;\n            continue;\n        }\n\n        if(a[i] == '>')\n        {\n            ++P;\n            continue;\n        }\n\n        if(a[i] == '-')\n            E[i] -= Pw[P];\n        else E[i] += Pw[P];\n\n        if(E[i] >= Mod) E[i] -= Mod;\n            else if(E[i] < 0) E[i] += Mod;\n    }\n\n    for(i=1; i<=n; ++i) /// reverse operations for 1...i, not signs\n    {\n        if(a[i] == '<')\n        {\n            R[i] = Pow * R[i-1] % Mod;\n            continue;\n        }\n\n        if(a[i] == '>')\n        {\n            R[i] = Inv * R[i-1] % Mod;\n            continue;\n        }\n\n        if(a[i] == '+') R[i] = R[i-1] + Pw[n];\n            else R[i] = R[i-1] - Pw[n];\n\n        if(R[i] >= Mod) R[i] -= Mod;\n            else if(R[i] < 0) R[i] += Mod;\n    }\n\n    for(i=n; i; --i)\n    {\n        ++mp[E[i]]; /// i becomes active\n\n        target = E[n] + R[i-1];\n        if(sP[i-1] >= 0) target = (ll) target * Pw[sP[i-1]] % Mod;\n            else target = (ll) target * InvP[-sP[i-1]] % Mod;\n\n        ans += mp[target];\n    }\n\n    cout << ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << (x) << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\nusing P = pair<int,int>;\ntemplate<unsigned int mod_>\nstruct ModInt{\n\tusing uint = unsigned long long;\n\tusing ll = __int128;\n\tusing ull =__int128;\n\n\tconstexpr static uint mod = mod_;\n\n\tuint v;\n\tModInt():v(0){}\n\tModInt(ll v):v(normS(v%mod+mod)){}\n\texplicit operator bool() const {return v!=0;}\n\tstatic uint normS(const uint &x){return (x<mod)?x:x-mod;}\t\t// [0 , 2*mod-1] -> [0 , mod-1]\n\tstatic ModInt make(const uint &x){ModInt m; m.v=x; return m;}\n\tModInt operator+(const ModInt& b) const { return make(normS(v+b.v));}\n\tModInt operator-(const ModInt& b) const { return make(normS(v+mod-b.v));}\n\tModInt operator-() const { return make(normS(mod-v)); }\n\tModInt operator*(const ModInt& b) const { return make((ull)v*b.v%mod);}\n\tModInt operator/(const ModInt& b) const { return *this*b.inv();}\n\tModInt& operator+=(const ModInt& b){ return *this=*this+b;}\n\tModInt& operator-=(const ModInt& b){ return *this=*this-b;}\n\tModInt& operator*=(const ModInt& b){ return *this=*this*b;}\n\tModInt& operator/=(const ModInt& b){ return *this=*this/b;}\n\tll extgcd(ll a,ll b,ll &x,ll &y) const{\n\t\tll u[]={a,1,0},v[]={b,0,1};\n\t\twhile(*v){\n\t\t\tll t=*u/ *v;\n\t\t\trep(i,3) swap(u[i]-=t*v[i],v[i]);\n\t\t}\n\t\tif(u[0]<0) rep(i,3) u[i]=-u[i];\n\t\tx=u[1],y=u[2];\n\t\treturn u[0];\n\t}\n\tModInt inv() const{\n\t\tll x,y;\n\t\textgcd(v,mod,x,y);\n\t\treturn make(normS(x+mod));\n\t}\n\tbool operator==(const ModInt& b) const { return v==b.v;}\n\tbool operator!=(const ModInt& b) const { return v!=b.v;}\n//\tfriend istream& operator>>(istream &o,ModInt& x){\n//\t\tll tmp;\n//\t\to>>tmp;\n//\t\tx=ModInt(tmp);\n//\t\treturn o;\n//\t}\n//\tfriend ostream& operator<<(ostream &o,const ModInt& x){ return o<<x.v;}\n};\nusing mint = ModInt<1000000000000000003ULL>;\nconst mint B = 998244353;\nmint ex(int p){\n\tbool m = 0;\n\tif(p<0){\n\t\tp = -p;\n\t\tm = 1;\n\t}\n\tmint a = 1;\n\tmint x = B;\n\twhile(p){\n\t\tif(p%2==1) a *= x;\n\t\tx *= x;\n\t\tp/=2;\n\t}\n\tif(m) a = (mint)1/a;\n\treturn a;\n}\n\nusing ll = long long;\nint N;\nstring s;\n\nint main(){\n\tcin>>N>>s;\n\tmint H = 0;\n\t{\n\t\tmap<int,int> cnt;\n\t\tint x = 0;\n\t\trep(i,N){\n\t\t\tif(s[i]=='+') cnt[x]++;\n\t\t\tif(s[i]=='-') cnt[x]--;\n\t\t\tif(s[i]=='<') x--;\n\t\t\tif(s[i]=='>') x++;\n\t\t}\n\t\tfor(P p:cnt){\n\t\t\tint x = p.fs, v = p.sc;\n\t\t\tH += ex(x) * v;\n\t\t}\n\t}\n\tmint a = 1, b = 0;\n\tll ans = 0;\n\t\n\tmap<int,int> mp;\n\tmp[0] = 1;\n\tfor(int i=N-1;i>=0;i--){\n\t\tmint na,nb;\n\t\tif(s[i]=='+'){\n\t\t\tna = a, nb = b+1;\n\t\t}\n\t\tif(s[i]=='-'){\n\t\t\tna = a, nb = b-1;\n\t\t}\n\t\tif(s[i]=='<'){\n\t\t\tna = a/B, nb = b/B;\n\t\t}\n\t\tif(s[i]=='>'){\n\t\t\tna = a*B, nb = b*B;\n\t\t}\n\t\ta = na, b = nb;\n\t\tmint H_false = (H-b)/a;\n\t\tans += mp[H_false.v];\n\t\tmp[(-b/a).v]++;\n\t}\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\ntypedef long double louble;\n\ntemplate<typename T1,typename T2> inline T1 max(T1 a,T2 b){return a<b?b:a;}\ntemplate<typename T1,typename T2> inline T1 min(T1 a,T2 b){return a<b?a:b;}\n\nconst char lf = '\\n';\n\nnamespace ae86\n{\n\tconst int bufl = 1<<15;\n\n\tchar buf[bufl],*s=buf,*t=buf;\n\n\tinline int fetch()\n\t{\n\t\tif(s==t){t=(s=buf)+fread(buf,1,bufl,stdin);if(s==t)return EOF;}\n\t\treturn *s++;\n\t}\n\n\tinline int ty()\n\t{\n\t\tint a=0,b=1,c=fetch();\n\t\twhile(!isdigit(c))b^=c=='-',c=fetch();\n\t\twhile(isdigit(c))a=a*10+c-48,c=fetch();\n\t\treturn b?a:-a;\n\t}\n\n\ttemplate<typename T> inline int ts(T *s)\n\t{\n\t\tint a=0,c=fetch();\n\t\twhile(c<=32 && c!=EOF)c=fetch();\n\t\twhile(c>32 && c!=EOF)s[a++]=c,c=fetch();\n\t\ts[a]=0;\n\t\treturn a;\n\t}\n}\nusing ae86::ty;\nusing ae86::ts;\n\nconst int _ = 250007;\nconst lint bas = 250007 , mo = 2059392230891;\n\ninline lint sfx(lint a,lint b)\n{\n\ta%=mo,b%=mo;\n\treturn (a*b-(lint)((louble)a/mo*b+0.5)*mo+mo)%mo;\n}\n\ninline lint powa(lint a,lint t)\n{\n\tlint b=1;\n\twhile(t){if(t&1)b=sfx(a,b);a=sfx(a,a),t>>=1;}\n\treturn b;\n}\n\ninline lint inva(lint a)\n{\n\treturn powa(a,mo-2);\n}\n\nconst lint ibas = inva(bas);\n\nint n;char s[_];\nlint loc[_];\nunordered_map<lint,int> cnt;\n\ninline lint trans(lint h,char op)\n{\n\tif(op=='<')return sfx(h,ibas);\n\tif(op=='>')return sfx(h,bas);\n\tif(op=='+')return (h+1)%mo;\n\tif(op=='-')return (h-1+mo)%mo;\n\tthrow \"fuck me\";\n}\n\nint main()\n{\n\tios::sync_with_stdio(0),cout.tie(nullptr);\n\t\n\tn=ty(),ts(s+1);\n\n\tloc[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tloc[i]=loc[i-1];\n\t\tif(s[i]=='<')loc[i]=sfx(loc[i],ibas);\n\t\tif(s[i]=='>')loc[i]=sfx(loc[i],bas);\n\t}\n\n\tlint tar=0;\n\tfor(int i=n;i>=1;i--)tar=trans(tar,s[i]);\n\tcnt[0]=1;\n\tlint ans=0,now=0;\n\tfor(int i=n;i>=1;i--)\n\t\tnow=trans(now,s[i]),ans+=cnt[sfx(now-tar+mo,loc[i-1])],cnt[sfx(now,loc[i-1])]++;\n\tcout<<ans<<lf;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T> void read(T &t) {\n\tt=0; char ch=getchar(); int f=1;\n\twhile (ch<'0'||ch>'9') { if (ch=='-') f=-1; ch=getchar(); }\n\tdo { (t*=10)+=ch-'0'; ch=getchar(); } while ('0'<=ch&&ch<='9'); t*=f;\n}\ntypedef long long ll;\nconst int maxn=(2.5e5)+10;\nconst ll mod=(1e9)+7;\nconst ll t1=998244353;\nconst ll t2=235723657;\nint n,pos[maxn];\nchar s[maxn];\nll h1[maxn],h2[maxn];\nll m1[maxn*2],m2[maxn*2],a[maxn*2],ans,s1,s2;\nll iv1[maxn*2],iv2[maxn*2];\nmap<pair<ll,ll> ,int> M;\nll MI1(int x) {\n\tif (x>=0) return m1[x];\n\treturn iv1[-x];\n}\nll MI2(int x) {\n\tif (x>=0) return m2[x];\n\treturn iv2[-x];\n}\nll get1(int x) {\n\treturn a[x+n]*MI1(x)%mod;\n}\nll get2(int x) {\n\treturn a[x+n]*MI2(x)%mod;\n}\nll ksm(ll x,ll y) {\n\tll res=1;\n\twhile (y) {\n\t\tif (y&1) res=res*x%mod;\n\t\tx=x*x%mod; y>>=1;\n\t} return res;\n}\nvoid F(ll &x) {\n\tx=(x%mod+mod)%mod;\n}\nint main() {\n\t//freopen(\"1.txt\",\"r\",stdin);\n\tread(n);\n\tscanf(\"%s\",s+1);\n\tm1[0]=m2[0]=1;\n\tfor (int i=1;i<=n*2;i++) m1[i]=m1[i-1]*t1%mod,m2[i]=m2[i-1]*t2%mod;\n\tiv1[0]=iv2[0]=1;\n\tiv1[1]=ksm(t1,mod-2);\n\tiv2[1]=ksm(t2,mod-2);\n\tfor (int i=2;i<=n*2;i++)\n\t\tiv1[i]=iv1[i-1]*iv1[1]%mod,\n\t\tiv2[i]=iv2[i-1]*iv2[1]%mod;\n\tfor (int i=1;i<=n;i++) {\n\t\th1[i]=h1[i-1]; h2[i]=h2[i-1]; pos[i]=pos[i-1];\n\t\tif (s[i]=='+') {\n\t\t\th1[i]-=get1(pos[i]);\n\t\t\th2[i]-=get2(pos[i]);\n\t\t\ta[pos[i]+n]++;\n\t\t\th1[i]+=get1(pos[i]);\n\t\t\th2[i]+=get2(pos[i]);\n\t\t} else if (s[i]=='-') {\n\t\t\th1[i]-=get1(pos[i]);\n\t\t\th2[i]-=get2(pos[i]);\n\t\t\ta[pos[i]+n]--;\n\t\t\th1[i]+=get1(pos[i]);\n\t\t\th2[i]+=get2(pos[i]);\n\t\t} else if (s[i]=='>') pos[i]++;\n\t\telse pos[i]--;\n\t\tF(h1[i]);\n\t\tF(h2[i]);\n\t}\n\tfor (int i=n-1;i>=0;i--) {\n\t\tM[make_pair(h1[i+1],h2[i+1])]++;\n\t\ts1=h1[n]*MI1(pos[i])%mod+h1[i];\n\t\ts2=h2[n]*MI2(pos[i])%mod+h2[i];\n\t\tF(s1); F(s2);\n\t\tans+=M[make_pair(s1,s2)];\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n/*\n  0. Enough array size? Enough array size? Enough array size? Interger overflow?\n  \n  1. Think TWICE, Code ONCE!\n  Are there any counterexamples to your algo?\n    \n  2. Be careful about the BOUNDARIES!\n  N=1? P=1? Something about 0?\n    \n  3. Do not make STUPID MISTAKES!\n  Time complexity? Memory usage? Precision error?\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 255000;\nconst int MOD_CNT = 2;\nconst int MOD[MOD_CNT] = {(int)1e9 + 7, (int)1e9 + 9};\nconst int Base = 998244353;\n\ninline int modExp(int a, int n, int mod) {\n\tint ret = 1;\n\twhile (n) {\n\t\tif (n & 1) ret = (long long)ret * a % mod;\n\t\ta = (long long)a * a % mod;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\n\nstruct Rab {\n\tint val[MOD_CNT];\n\tRab(long long x = 0, int inv = 0) {\n\t\tfor (int i = 0; i < MOD_CNT; i++) {\n\t\t\tif (inv) val[i] = modExp(x, MOD[i] - 2, MOD[i]);\n\t\t\telse val[i] = (x % MOD[i] + MOD[i]) % MOD[i];\n\t\t}\n\t}\n\tRab operator + (const Rab &d) const {\n\t\tRab ret;\n\t\tfor (int i = 0; i < MOD_CNT; i++) {\n\t\t\t(ret.val[i] = val[i] + d.val[i]) >= MOD[i] && (ret.val[i] -= MOD[i]);\n\t\t}\n\t\treturn ret;\n\t}\n\tRab operator - (const Rab &d) const {\n\t\tRab ret;\n\t\tfor (int i = 0; i < MOD_CNT; i++) {\n\t\t\t(ret.val[i] = val[i] - d.val[i]) < 0 && (ret.val[i] += MOD[i]);\n\t\t}\n\t\treturn ret;\n\t}\n\tRab operator * (const Rab &d) const {\n\t\tRab ret;\n\t\tfor (int i = 0; i < MOD_CNT; i++) {\n\t\t\tret.val[i] = (long long)val[i] * d.val[i] % MOD[i];\n\t\t}\n\t\treturn ret;\n\t}\n\tbool operator == (const Rab &d) const {\n\t\tfor (int i = 0; i < MOD_CNT; i++) if (val[i] != d.val[i]) return false;\n\t\treturn true;\n\t}\n\tbool operator != (const Rab &d) const {\n\t\tfor (int i = 0; i < MOD_CNT; i++) if (val[i] != d.val[i]) return true;\n\t\treturn false;\n\t}\n\tbool operator < (const Rab &d) const {\n\t\tfor (int i = 0; i < MOD_CNT; i++) {\n\t\t\tif (val[i] != d.val[i]) return val[i] < d.val[i];\n\t\t}\n\t\treturn false;\n\t}\n} wrk[N + N], *pw;\n\nchar s[N];\nmap<Rab, int> H;\n\nint main() {\n\t\n\tios::sync_with_stdio(0);\n\tcin.tie(0), cout.tie(0);\n\t\n\tint n; cin >> n >> s + 1;\n\tpw = wrk + N;\n\tpw[0] = 1;\n\tfor (int i = 1; i < N; i++) pw[i] = pw[i - 1] * Base;\n\tauto inv = Rab(Base, 1);\n\tfor (int i = -1; i > -N; i--) pw[i] = pw[i + 1] * inv;\n\t\n\tint p = 0;\n\tRab final = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (s[i] == '+') final = final + pw[p];\n\t\tif (s[i] == '-') final = final - pw[p];\n\t\tif (s[i] == '>') p++;\n\t\tif (s[i] == '<') p--;\n\t}\n\t\n\tfunction<long long(int, int)> calc = [&](int st, int en) {\n\t\tif (st == en) {\n\t\t\tRab cur = 0;\n\t\t\tif (s[st] == '+') cur = cur + pw[0];\n\t\t\tif (s[st] == '-') cur = cur - pw[0];\n\t\t\tif (cur == final) return 1LL;\n\t\t\telse return 0LL;\n\t\t}\n\t\tint mid = st + en >> 1;\n\t\tauto ret = calc(st, mid) + calc(mid + 1, en);\n\t\tH.clear();\n\t\tint p = 0;\n\t\tRab cur = 0;\n\t\tfor (int i = mid + 1; i <= en; i++) {\n\t\t\tif (s[i] == '+') cur = cur + pw[p];\n\t\t\tif (s[i] == '-') cur = cur - pw[p];\n\t\t\tif (s[i] == '>') p++;\n\t\t\tif (s[i] == '<') p--;\n\t\t\tH[cur]++;\n\t\t}\n\t\tcur = 0, p = 0;\n\t\tfor (int i = mid; i >= st; i--) {\n\t\t\tif (s[i] == '+') cur = cur + pw[0];\n\t\t\tif (s[i] == '-') cur = cur - pw[0];\n\t\t\tif (s[i] == '>') cur = cur * pw[1], p++;\n\t\t\tif (s[i] == '<') cur = cur * pw[-1], p--;\n\t\t\tauto now = (final - cur) * pw[-p];\n\t\t\tif (H.count(now)) ret += H[now];\n\t\t}\n\t\treturn ret;\n\t};\n\t\n\tcout << calc(1, n) << \"\\n\";\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,NAME,...) NAME\n#define pr(...) cerr<< GET_MACRO(__VA_ARGS__,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__) <<endl\n#define pr1(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr2(a,b) pr1(a)<<pr1(b)\n#define pr3(a,b,c) pr1(a)<<pr2(b,c)\n#define pr4(a,b,c,d) pr1(a)<<pr3(b,c,d)\n#define pr5(a,b,c,d,e) pr1(a)<<pr4(b,c,d,e)\n#define pr6(a,b,c,d,e,f) pr1(a)<<pr5(b,c,d,e,f)\n#define pr7(a,b,c,d,e,f,g) pr1(a)<<pr6(b,c,d,e,f,g)\n#define pr8(a,b,c,d,e,f,g,h) pr1(a)<<pr7(b,c,d,e,f,g,h)\nusing namespace std;\nusing Int = long long;\nusing ll = long long;\nusing Double = long double;\nconst Int INF = (1LL<<55)+1e9; // ~ 3.6 * 1e16\nconst Double EPS = 1e-8;\nconst Double PI = 6.0 * asin((Double)0.5);\nusing P = pair<Int,Int>;\nusing T = tuple<Int,Int,Int>;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nostream& operator<<(ostream& o,T t){return o<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){Int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){Int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\nconst Int N = 300000;\n\nconstexpr ll mod_pow(ll x, ll n, Int mod){\n  return n == 0? 1:(n%2? x:1) * mod_pow((x*x)%mod,n/2, mod) % mod;\n}  \n\nconstexpr ll mod_inv(Int num,Int mod){return mod_pow(num, mod-2, mod);}\nconst ll mod[] = {1000000007,1000000009,1000000021};\nconst ll B[]= {1777771,10000019,10000079};\nconst ll inv[] = {mod_inv(B[0],mod[0]), mod_inv(B[1],mod[1]),mod_inv(B[2],mod[2])};\n\nclass Hash{\npublic:\n\n  ll num;\n  ll idx;\n  vector<ll> K;\n  Int b;\n  Hash(Int b):b(b){\n    K.resize(N);\n    K[0] = 1;\n    for(Int i=1;i<N;i++) K[i] = K[i-1] * B[b] % mod[b];\n    num = 0;\n    idx = K[N/2];\n  }\n\n  void inc(){num = (num + idx) % mod[b];}\n  void dec(){num = (num - idx + mod[b]) % mod[b];}\n  void moveLeft(){idx = idx * inv[b] % mod[b];}\n  void moveRight(){idx = idx * B[b] % mod[b];}\n  \n};\n\n\nsigned main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  Int n;\n  cin>>n;\n  string s;\n  cin>>s;\n\n  vector<map<ll,Int> > cnt(3);\n  vector<Hash> hash{Hash(0), Hash(1), Hash(2)};\n  vector<Hash> hash2 = hash;\n  \n  for(Int k = 0; k<n ; k++){\n    char ch = s[k];\n    for(Int i=0;i<3;i++){\n      auto &A = hash[i];\n      if(ch == '+') A.inc();\n      if(ch == '-') A.dec();\n      if(ch == '<') A.moveLeft();\n      if(ch == '>') A.moveRight();\n      cnt[i][A.num]++;\n    }\n  }\n\n  vector<ll> allHash(3);\n  vector<ll> Ofset(3,0);\n  for(Int i=0;i<3;i++) allHash[i] = hash[i].num;\n  \n  Int ans = 0;\n  for(Int k=0;k<n;k++){\n    \n    char ch = s[k];\n    Int mn = INF;\n    for(Int i=0;i<3;i++){\n      auto &A = hash2[i];\n      auto &U = allHash[i];\n      auto &X = Ofset[i];\n      ll val = (U - X + mod[i]) % mod[i];\n      Min(mn, cnt[i][val]);\n      if(ch == '+') X = (X - A.idx + mod[i]) % mod[i], A.inc();\n      else if(ch == '-') X = (X + A.idx + mod[i]) % mod[i], A.dec();\n      else if(ch == '>') U = U * B[i] % mod[i], A.moveRight();\n      else if(ch == '<') U = U * inv[i] % mod[i], A.moveLeft();\n      cnt[i][A.num]--;\n    }\n    ans += mn;\n  }\n  cout<<ans<<endl;\n  \n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>  \n\n#pragma warning(disable:4996)  \n#pragma comment(linker, \"/STACK:336777216\")  \nusing namespace std;\n\n#define mp make_pair  \n#define Fi first  \n#define Se second  \n#define pb(x) push_back(x)  \n#define szz(x) ((int)(x).size())  \n#define rep(i, n) for(int i=0;i<n;i++)  \n#define all(x) (x).begin(), (x).end()  \n#define ldb ldouble  \n\ntypedef unsigned int uint;\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 19;\nconst ll MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n\nconst int MX = 250005;\nconst int P1 = 1000000223, P2 = 1000000433;\nconst int Q1 = 739777249, Q2 = 759391002;\nconst int R1 = 886220847, R2 = 804140220;\n\npii operator-(pii l, pii r){ return pii((l.first + P1 - r.first) % P1, (l.second + P2 - r.second) % P2); }\npii operator+(pii l, pii r){ return pii((l.first + r.first) % P1, (l.second + r.second) % P2); }\npii operator*(pii l, pii r){ return pii((ll)l.first * r.first % P1, (ll)l.second * r.second % P2); }\n\nchar D[MX];\npii DB[MX];\n\nint main()\n{\n\tint N;\n\tscanf(\"%d\", &N);\n\tscanf(\"%s\", D);\n\tpii v = pii(0, 0), u = pii(0, 0), w = pii(1, 1);\n\tpii cur = pii(1, 1);\n\tmap<pii, int> X;\n\tfor(int i = 0; i < N; i++){\n\t\tif(D[i] == '<') cur = cur * pii(R1, R2);\n\t\tif(D[i] == '>') cur = cur * pii(Q1, Q2);\n\t\tif(D[i] == '+') v = v + cur;\n\t\tif(D[i] == '-') v = v - cur;\n\t\tDB[i] = v;\n\t\tX[v] += 1;\n\t}\n\tll ans = 0;\n\tfor(int i = 0; i < N; i++){\n\t\tpii x = v*w+u;\n\t\tans += X[x];\n\t\tX[DB[i]] -= 1;\n\t\tif(D[i] == '<') w = w * pii(R1, R2);\n\t\tif(D[i] == '>') w = w * pii(Q1, Q2);\n\t\tif(D[i] == '+') u = u + w;\n\t\tif(D[i] == '-') u = u - w;\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll pow_mod(ll x,int k,ll MOD) {\n  ll ans=1;\n  while (k) {\n  \tif (k&1) ans=ans*x%MOD;\n  \tx=x*x%MOD;\n  \tk>>=1;\n  }\n  return ans;\n}\n\nconst int prime[10]={998244353,989390509,807943519,934784771,814294163,847763881,988501229,831312439,887199301,993514421};\nconst ll H[10]={19260817,760277961,602494845,909561729,536778743,682353612,738823132,631427472,848965391,984035289};\n\nint powd[10][1000005],invd[10][1000005];\n\nvoid pre(int n) {\n  for(int i=0;i<10;i++) {\n    ll inv=pow_mod(H[i],prime[i]-2,prime[i]);\n    assert(inv*H[i]%prime[i]==1);\n    powd[i][0]=1;\n    for(int j=1;j<=n;j++) powd[i][j]=(ll)powd[i][j-1]*H[i]%prime[i];\n    invd[i][0]=1;\n    for(int j=1;j<=n;j++) invd[i][j]=(ll)invd[i][j-1]*inv%prime[i];\n  }\n}\n\nstruct Data {\n  int num[10];\n  Data() {memset(num,0,sizeof(num));}\n  Data operator + (Data b) {\n  \tData c;\n  \tfor(int i=0;i<10;i++) c.num[i]=(num[i]+b.num[i])%prime[i];\n  \treturn c;\n  }\n  void add(int x) {\n  \tfor(int i=0;i<10;i++) num[i]=(num[i]+powd[i][x])%prime[i];\n  }\n  void dec(int x) {\n  \tfor(int i=0;i<10;i++) num[i]=(num[i]-powd[i][x]+prime[i])%prime[i];\n  }\n  void rshift(int x) {\n  \tfor(int i=0;i<10;i++) num[i]=(ll)num[i]*powd[i][x]%prime[i];\n  }\n  void lshift(int x) {\n  \tfor(int i=0;i<10;i++) num[i]=num[i]*invd[i][x]%prime[i];\n  }\n  bool operator < (const Data & b) const {\n  \tfor(int i=0;i<10;i++)\n  \t  if (num[i]!=b.num[i]) return num[i]<b.num[i];\n  \treturn 0;\n  }\n};\n\nmap <Data,int> mp;\nData p[250005];\n\nchar str[250005];\n\nint main() {\n  int n;\n  scanf(\"%d%s\",&n,str+1);\n  pre(4*n);\n  int d=0;\n  for(int i=1;i<=n;i++) {\n  \tp[i]=p[i-1];\n    if (str[i]=='+') p[i].add(2*n+d);\n    else if (str[i]=='-') p[i].dec(2*n+d);\n    else if (str[i]=='>') d++;\n    else d--;\n    mp[p[i]]++;\n  }\n  ll ans=0;\n  d=0;\n  for(int i=1;i<=n;i++) {\n  \tData t=p[n];\n  \tif (d>=0) t.rshift(d); else t.lshift(-d);\n\tt=t+p[i-1];\n\tif (mp.count(t)) ans+=mp[t];\n\tif (str[i]=='>') d++;\n\telse if (str[i]=='<') d--;\n\tmp[p[i]]--;\n  }\n  printf(\"%lld\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define pb push_back\n#define eb emplace_back\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\n    os<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\n    os<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\ninline ll mod_inverse(ll a, ll m){\n    ll b = m, u = 1, v = 0;\n    while (b) {\n        ll t = a / b;\n        swap(a -= t * b, b);\n        swap(u -= t * v, v);\n    }\n    return (u % m + m) % m;\n}\n\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nconst ll B = 10007;\nconst ll iB = mod_inverse(10007, MOD);\n\nint T, n, m;\nstring s;\nint main(int argc, char *argv[]){\n    ios::sync_with_stdio(false);\n    cin >> n >> s;\n    ll h = 0, b = 1;\n    for (char c : s) {\n        if (c == '+') h = (h + b) % MOD;\n        if (c == '-') h = (h + MOD - b) % MOD;\n        if (c == '>') b = b * B % MOD;\n        if (c == '<') b = b * iB % MOD;\n    }\n    const ll target = h;\n    ll ans = 0;\n    map<ll, ll> mp;\n    mp[0] = 1;\n    int p = 0;\n    h = 0; b = 1;\n    for (char c : s) {\n        if (c == '+') h = (h + b) % MOD;\n        if (c == '-') h = (h + MOD - b) % MOD;\n        if (c == '>') {\n            p ++;\n            b = b * B % MOD;\n        }\n        if (c == '<') {\n            p --;\n            b = b * iB % MOD;\n        }\n\n        auto it = mp.find((h + MOD - target) % MOD);\n        if (it != mp.end()) ans += it->second;\n\n        mp[(h + target * b + MOD - target) % MOD] ++;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//teja349\n#include <bits/stdc++.h>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <utility>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <iomanip> \n//setbase - cout << setbase (16); cout << 100 << endl; Prints 64\n//setfill -   cout << setfill ('x') << setw (5); cout << 77 << endl; prints xxx77\n//setprecision - cout << setprecision (14) << f << endl; Prints x.xxxx\n//cout.precision(x)  cout<<fixed<<val;  // prints x digits after decimal in val\n\nusing namespace std;\n#define f(i,a,b) for(i=a;i<b;i++)\n#define rep(i,n) f(i,0,n)\n#define fd(i,a,b) for(i=a;i>=b;i--)\n#define pb push_back\n#define mp make_pair\n#define vi vector< int >\n#define vl vector< ll >\n#define ss second\n#define ff first\n#define ll long long\n#define pii pair< int,int >\n#define pll pair< ll,ll >\n#define sz(a) a.size()\n#define inf (1000*1000*1000+5)\n#define all(a) a.begin(),a.end()\n#define tri pair<int,pii>\n#define vii vector<pii>\n#define vll vector<pll>\n#define viii vector<tri>\n#define mod (1000*1000*1000+7)\n#define pqueue priority_queue< int >\n#define pdqueue priority_queue< int,vi ,greater< int > >\n\n//std::ios::sync_with_stdio(false);   \nll ans10[512345],ans13[512345],powe13[512345],powe10[512345],invpowe10[512345];\nll invpowe13[512345],inv[1234],p[512345];\nll extend_gcd(ll a,ll b,ll &x,ll &y){\n\tif(b==0){\n\t\tx=1;\n\t\ty=0;\n\t\treturn a;\n\t}\n\tll x1,y1;\n\tll ans =extend_gcd(b,a%b,x1,y1);\n\tx=y1;\n\ty=x1-(a/b)*y1;\n\n\treturn ans;\n}\nmap<ll,ll> seti10,seti13; \nint main(){\n    std::ios::sync_with_stdio(false);\n    ll n;\n    cin>>n;\n    string s;\n    cin>>s;\n    ll i;\n    ll initp=250003;\n    powe10[0]=1;\n    powe13[0]=1;\n    invpowe10[0]=1;\n    invpowe13[0]=1;\n    f(i,1,200){\n\t\tll x,y;\n\t\tll val=extend_gcd(mod,i,x,y);\n\t\tif(y>0)\n\t\t\tinv[i]=y%mod;\n\t\telse{\n\t\t\t\tinv[i]=(y+mod)%mod;\n\t\t}\n\t}\n\tll inv10=inv[193];\n\tll inv13=inv[37];\n    f(i,1,512345){\n    \tpowe13[i]=powe13[i-1]*37;\n    \tpowe10[i]=powe10[i-1]*193;\n    \tpowe10[i]%=mod;\n    \tpowe13[i]%=mod;\n    \tinvpowe10[i]=invpowe10[i-1]*inv10;\n    \tinvpowe10[i]%=mod;\n    \tinvpowe13[i]=invpowe13[i-1]*inv13;\n    \tinvpowe13[i]%=mod;\n    }\n    ans10[0]=0;\n    ans13[0]=0;\n    p[0]=initp;\n    \n    f(i,1,s.length()+1){\n    \tans10[i]=ans10[i-1];\n    \tans13[i]=ans13[i-1];\n    \tp[i]=p[i-1];\n    \tif(s[i-1]=='+'){\n    \t\tans10[i]=ans10[i-1]+powe10[p[i]];\n    \t\tans13[i]=ans13[i-1]+powe13[p[i]];\n\n    \t}\n    \telse if(s[i-1]=='-'){\n    \t\tans10[i]=ans10[i-1]-powe10[p[i]];\n    \t\tans13[i]=ans13[i-1]-powe13[p[i]];\n    \t}\n    \telse if(s[i-1]=='<'){\n    \t\tp[i]--;\n    \t}\n    \telse{\n    \t\tp[i]++;\n    \t}\n    \tans10[i]%=mod;\n    \tans10[i]+=mod;\n    \tans10[i]%=mod;\n    \tans13[i]%=mod;\n    \tans13[i]+=mod;\n    \tans13[i]%=mod;\n    \tseti13[ans13[i]]++;\n    \tseti10[ans10[i]]++;\n    \t//cout<<ans10[i]<<\" \"<<ans13[i]<<endl;\n    }\n    ll val,val1,j10,j13;\n    ll total=0;\n    f(i,1,n+1){\n    \tval=initp-p[i-1];\n    \tval*=-1;\n    \tif(val>=0){\n    \t\tval1=powe13[val];\n    \t\tval=powe10[val];\n    \t\t  \n    \t}\n    \telse{\n    \t\tval1=invpowe13[val];\n    \t\tval=invpowe10[val];\n    \t}\n    \tj10=ans10[n]*val;\n    \tj10%=mod;\n    \tj10+=ans10[i-1];\n    \tj13=ans13[n]*val1;\n    \tj13%=mod;\n    \tj13+=ans13[i-1];\n    \tj10%=mod;\n    \tj13%=mod;\n    \ttotal+=min(seti10[j10],seti13[j13]);\n        assert(seti10[j10]==seti13[j13]);\n    \tseti13[ans13[i]]--;\n    \tseti10[ans10[i]]--;\n    }\n    cout<<total<<endl;\n\n\n\n\n    return 0;  \n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <set>\n\n#define MIN_INT -2147483648\n#define MAX_INT 2147483647\n#define MIN_LONG -9223372036854775808L\n#define MAX_LONG 9223372036854775807L\n#define PI 3.141592653589793238462643383279502884L\n\n#define long long long int\n\nusing std::vector;\nusing std::map;\nusing std::set;\nusing std::string;\nusing std::pair;\nusing std::cin;\nusing std::cout;\nusing std::cerr;\n\n// @author: pashka\n\n#define MAX 250000\n\nint main() {\n    std::ios::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n    string s;\n    cin >> s;\n\n    int x = 214123123;\n    vector<int> pow(2 * MAX + 2);\n    pow[0] = 1;\n    for (int i = 1; i < pow.size(); i++) {\n        pow[i] = pow[i - 1] * x;\n    }\n\n    vector<int> h(n + 1);\n    vector<int> p(n + 1);\n    p[0] = MAX + 1;\n    for (int i = 0; i < n; i++) {\n        h[i + 1] = h[i];\n        p[i + 1] = p[i];\n        if (s[i] == '+') {\n            h[i + 1] += pow[p[i]];\n        } else if (s[i] == '-') {\n            h[i + 1] -= pow[p[i]];\n        } else if (s[i] == '>') {\n            p[i + 1]++;\n        } else if (s[i] == '<') {\n            p[i + 1]--;\n        }\n    }\n\n//    for (int i = 0; i <= n; i++) {\n//        cout << h[i] << \" \" << p[i] << \"\\n\";\n//    }\n\n    int H = h[n];\n    map<int, int> mp;\n    long res = 0;\n    for (int i = n; i >= 0; i--) {\n        int a = h[i] * pow[MAX + 1];\n        int b = a + H * pow[p[i]];\n        res += mp[b];\n        mp[a]++;\n    }\n    cout << res << \"\\n\";\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <random>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\n\nconst ll MOD=1e9+7;\nconst int med=250000;\nll powmod(ll a, ll k){\n    ll ap=a, ans=1;\n    while(k>0){\n        if(k%2==1){\n            ans*=ap;\n            ans%=MOD;\n        }\n        ap=ap*ap;\n        ap%=MOD;\n        k/=2;\n    }\n    return ans;\n}\nll inv(ll a){\n\treturn powmod(a, MOD-2);\n}\n\nint main()\n{\n\tint n;\n\tcin>>n;\n\tstring s;\n\tcin>>s;\n\trandom_device rnd;\n\tmt19937_64 mt(rnd());\n\tuniform_int_distribution<ll> rndn(2, MOD-2);\n\tll b=rndn(mt);\n\tll binv=inv(b);\n\tll bp[500001];\n\tbp[med]=1;\n\tfor(int i=med+1; i<=med+n; i++) bp[i]=bp[i-1]*b%MOD;\n\tfor(int i=med-1; i>=med-n; i--) bp[i]=bp[i+1]*binv%MOD;\n\tll b0=0; int p=med;\n\tfor(int i=0; i<n; i++){\n\t\tif(s[i]=='+'){\n\t\t\tb0=(b0+bp[p])%MOD;\n\t\t}else if(s[i]=='-'){\n\t\t\tb0=(b0+MOD-bp[p])%MOD;\n\t\t}else if(s[i]=='>'){\n\t\t\tp++;\n\t\t}else{\n\t\t\tp--;\n\t\t}\n\t}\n\tll ans=0;\n\tll x[250000]={};\n\tvector<ll> v[500];\n\tint c1[500]={};\n\tll c0[500]={};\n\tint sq=1000;\n\tfor(int i=0; i<n; i++){\n\t\tif(s[n-1-i]=='+'){\n\t\t\tfor(int j=i/sq*sq; j<=i; j++){\n\t\t\t\tx[j]=(x[j]+1)%MOD;\n\t\t\t}\n\t\t\tfor(int j=0; j<i/sq; j++){\n\t\t\t\tc0[j]=(c0[j]+1)%MOD;\n\t\t\t}\n\t\t}else if(s[n-1-i]=='-'){\n\t\t\tfor(int j=i/sq*sq; j<=i; j++){\n\t\t\t\tx[j]=(x[j]+MOD-1)%MOD;\n\t\t\t}\n\t\t\tfor(int j=0; j<i/sq; j++){\n\t\t\t\tc0[j]=(c0[j]+MOD-1)%MOD;\n\t\t\t}\n\t\t}else if(s[n-1-i]=='>'){\n\t\t\tfor(int j=i/sq*sq; j<=i; j++){\n\t\t\t\tx[j]=x[j]*b%MOD;\n\t\t\t}\n\t\t\tfor(int j=0; j<i/sq; j++){\n\t\t\t\tc1[j]++;\n\t\t\t\tc0[j]=c0[j]*b%MOD;\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int j=i/sq*sq; j<=i; j++){\n\t\t\t\tx[j]=x[j]*binv%MOD;\n\t\t\t}\n\t\t\tfor(int j=0; j<i/sq; j++){\n\t\t\t\tc1[j]--;\n\t\t\t\tc0[j]=c0[j]*binv%MOD;\n\t\t\t}\n\t\t}\n\t\tfor(int j=0; j<i/sq; j++){\n\t\t\tll x0=(b0-c0[j]+MOD)*bp[med-c1[j]]%MOD;\n\t\t\tans+=((ll)(upper_bound(v[j].begin(), v[j].end(), x0)-lower_bound(v[j].begin(), v[j].end(), x0)));\n\t\t}\n\t\tfor(int j=i/sq*sq; j<=i; j++){\n\t\t\tif(b0==x[j]) ans++;\n\t\t}\n\t\tif((i+1)%sq==0){\n\t\t\tfor(int j=i/sq*sq; j<=i; j++){\n\t\t\t\tv[i/sq].push_back(x[j]);\n\t\t\t}\n\t\t\tsort(v[i/sq].begin(), v[i/sq].end());\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int B=131,P[2]={998244353,1000000007},MAXN=250010;\nint n,nw[MAXN],nt[2],INV[2];\nint hs[2][MAXN];\nll ans;\nchar s[MAXN];\nmap <int,int> mp[2];\nint qpow (int a,int b,int p) {\n\tif (b<0) {a=qpow(a,p-2,p),b=-b;}\n\tint res=1;\n\twhile (b) {\n\t\tif (b&1) {res=(1ll*res*a)%p;}\n\t\ta=(1ll*a*a)%p,b>>=1;\n\t}\n\treturn res;\n}\nint main () {\n\tINV[0]=qpow(B,P[0]-2,P[0]),INV[1]=qpow(B,P[1]-2,P[1]);\n\tnt[0]=qpow(B,n,P[0]),nt[1]=qpow(B,n,P[1]);\n\tscanf(\"%d%s\",&n,s+1);\n\tnw[0]=0;\n\tmp[0][0]++,mp[1][0]++;\n\tfor (int i=1;i<=n;i++) {\n\t\tif (s[i]=='+') {\n\t\t\ths[0][i]=(hs[0][i-1]+nt[0])%P[0];\n\t\t\ths[1][i]=(hs[1][i-1]+nt[1])%P[1];\n\t\t\tnw[i]=nw[i-1];\n\t\t} else if (s[i]=='-') {\n\t\t\ths[0][i]=(hs[0][i-1]-nt[0]+P[0])%P[0];\n\t\t\ths[1][i]=(hs[1][i-1]-nt[1]+P[1])%P[1];\n\t\t\tnw[i]=nw[i-1];\n\t\t} else if (s[i]=='<') {\n\t\t\tnt[0]=(1ll*nt[0]*INV[0])%P[0];\n\t\t\tnt[1]=(1ll*nt[1]*INV[1])%P[1];\n\t\t\ths[0][i]=hs[0][i-1],hs[1][i]=hs[1][i-1],nw[i]=nw[i-1]+1;\n\t\t} else {\n\t\t\tnt[0]=(1ll*nt[0]*B)%P[0];\n\t\t\tnt[1]=(1ll*nt[1]*B)%P[1];\n\t\t\ths[0][i]=hs[0][i-1],hs[1][i]=hs[1][i-1],nw[i]=nw[i-1]-1;\n\t\t}\n\t\tmp[0][hs[0][i]]++,mp[1][hs[1][i]]++;\n\t\t//cout << i << \"  \" << hs[0][i] << \"  \" << hs[1][i] << \"  \" << nw[i] << endl;\n\t}\n\tfor (int i=0;i<=n-1;i++) {\n\t\tmp[0][hs[0][i]]--,mp[1][hs[1][i]]--;\n\t\tint tmp0=(1ll*(hs[0][n]+(1ll*hs[0][i]*qpow(B,nw[i],P[0]))%P[0])*qpow(INV[0],nw[i],P[0]))%P[0];\n\t\tint tmp1=(1ll*(hs[1][n]+(1ll*hs[1][i]*qpow(B,nw[i],P[1]))%P[1])*qpow(INV[1],nw[i],P[1]))%P[1];\n\t\t//cout << i << \"  \" << tmp0 << \"  \" << tmp1 << endl;\n\t\tif (mp[0].find(tmp0)==mp[0].end()||mp[1].find(tmp1)==mp[1].end()) {continue;}\n\t\tans+=min(mp[0][tmp0],mp[1][tmp1]);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author aajisaka\n */\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n#define SPEED ios_base::sync_with_stdio(false);cin.tie(nullptr)\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define all(v) v.begin(), v.end()\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing P = pair<ll, ll>;\n\nconstexpr long double PI = 3.14159265358979323846264338327950288L;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nconstexpr ll mod17 = 1e9+7;\nconstexpr ll mod19 = 1e9+9;\nconstexpr ll mod9 = 998244353;\nll mod = mod17;\n\n// Mod int libraries\ntemplate<typename T>\nT mod_pow(T a, ll x) {\n  T res = 1;\n  while(x > 0) {\n    if (x & 1) res *= a;\n    a *= a; x >>= 1;\n  }\n  return res;\n}\n\n// Mint32\nunordered_map<ll, ll> minvmap;\nll minv(ll a, ll m) {\n  auto k = a; auto p = minvmap[a]; if (p != 0) return p;\n  ll b = m, u = 1, v = 0;\n  while (b) { ll t = a/b; swap(a -= t*b, b); swap(u -= t*v, v); }\n  p = (u%m+m)%m; minvmap[k] = p; return p;\n}\n\nstruct mint {\n  ll x;\n  mint():x(0){}\n  mint(ll x):x((x%mod+mod)%mod){}\n  mint& fix() { x = (x%mod+mod)%mod; return *this;}\n  mint operator-() const { return mint(0) - *this;}\n  mint& operator+=(const mint& a){ if((x+=a.x)>=mod) x-=mod; return *this;}\n  mint& operator-=(const mint& a){ if((x+=mod-a.x)>=mod) x-=mod; return *this;}\n  mint& operator*=(const mint& a){ (x*=a.x)%=mod; return *this;}\n  mint& operator/=(const mint& a){ (x*=minv(a.x, mod))%=mod; return *this; }\n  mint operator+(const mint& a)const{ return mint(*this) += a;}\n  mint operator-(const mint& a)const{ return mint(*this) -= a;}\n  mint operator*(const mint& a)const{ return mint(*this) *= a;}\n  mint operator/(const mint& a)const{ return mint(*this) /= a;}\n  bool operator<(const mint& a)const{ return x < a.x;}\n  bool operator==(const mint& a)const{ return x == a.x;}\n};\n\n// Mint64\nstruct mint64 {\n    ull x;\n    static ull mod, inv, r2;\n    mint64(): x(0){}\n    mint64(ull x): x(init(x)) {}\n    static ull init(ull x) { return reduce(__uint128_t(x)*r2);}\n    static void set_mod(ull m) {\n      mod = inv = m;\n      for(int i=0; i<5; i++) inv *= 2 - inv*m;\n      r2 = -__uint128_t(m)%m;\n    }\n    static ull reduce(__uint128_t x) {\n      ull y = ull(x >> 64) - ull((__uint128_t(ull(x)*inv)*mod)>>64);\n      return ll(y) < 0 ? y+mod : y;\n    }\n    mint64& operator+=(mint64& a) { x+=a.x-mod; if(ll(x)<0) x+=mod; return *this; }\n    mint64 operator+(mint64& a) const{ return mint64(*this)+=a; }\n    mint64& operator*=(mint64& a) { x=reduce(__uint128_t(x)*a.x); return *this; }\n    mint64 operator*(mint64& a) const { return mint64(*this)*=a; }\n};\n\null mint64::mod, mint64::inv, mint64::r2;\n\n// Verify: https://yukicoder.me/submissions/472580\nstruct Miller {\n    const vector<ull> v = {2, 325, 9375, 28178, 450775, 9780504, 1795265022};\n    bool suspect(ull a, ull s, ull d, ull n) {\n      if (mint64::mod != n) mint64::set_mod(n);\n      mint64 one = 1, minusone = n-1, ma = a;\n      auto x = mod_pow(ma, d);\n      if (x.x == one.x) return true;\n      for(int r = 0; r < s; r++) {\n        if (x.x == minusone.x) return true;\n        x = x * x;\n      }\n      return false;\n    }\n\n    // check if n is prime\n    bool check(ull n) {\n      if (n < 2 || (n > 2 && n % 2 == 0)) return false;\n      ull d = n - 1;\n      ull s = 0;\n      while (!(d & 1)) {\n        d >>= 1;\n        s++;\n      }\n      for (auto a: v) {\n        if (a >= n) break;\n        if (!suspect(a, s, d, n)) return false;\n      }\n      return true;\n    }\n};\n\nclass combination {\n    // factorial\n    public: std::vector<mint> fact;\n    public: std::vector<mint> inv;\n\n    combination(int n) {\n      fact.resize(n + 1);\n      inv.resize(n + 1);\n      fact[0] = 1;\n      for (int i = 1; i <= n; i++) {\n        fact[i] = fact[i - 1] * i;\n      }\n      inv[n] = mint(1) / fact[n];\n      for (int i = n - 1; i >= 0; i--) {\n        inv[i] = inv[i + 1] * (i + 1);\n      }\n    }\n\n    // nCr\n    public: mint get(int n, int r) {\n      if (n < r || n < 0 || r < 0) return 0;\n      return fact[n]*inv[r]*inv[n-r];\n    }\n    // nPr\n    public: mint p(int n, int r) {\n      if (n < r || n < 0) return 0;\n      return fact[n]*inv[n-r];\n    }\n};\n\n\nclass FEatingSymbolsHard {\npublic:\n    void solve(istream& cin, ostream& cout) {\n      SPEED;\n      int n; cin >> n;\n      string s; cin >> s;\n      vector<vector<mint>> v(6, vector<mint>(500001));\n      v[0][0] = mod9;\n      v[1][0] = 9999991;\n      v[2][0] = 9999973;\n      v[3][0] = 9999971;\n      v[4][0] = 9999943;\n      v[5][0] = 9999937;\n\n\n      rep(i, 6) {\n        for(int j=1; j<=500000; j++) {\n          v[i][j] = v[i][j-1] * v[i][0];\n        }\n      }\n\n      int pos = 250000;\n      map<mint, ll> mp[6];\n\n      vector<mint> now(6);\n      vector<vector<pair<mint, int>>> vec(6, vector<pair<mint, int>>(n+1));\n\n      rep(k, 6) {\n        vec[k][0] = {0, pos};\n      }\n\n      rep(k, 6) {\n        rep(i, n) {\n          if (s[i] == '+') {\n            now[k] += v[k][pos];\n          } else if (s[i] == '-') {\n            now[k] -= v[k][pos];\n          } else if (s[i] == '>') {\n            pos++;\n          } else if (s[i] == '<') {\n            pos--;\n          }\n          vec[k][i + 1] = {now[k], pos};\n        }\n      }\n      rep(k, 6) {\n        now[k] /= v[k][250000];\n      }\n\n      ll ans = 0;\n      for(int i=n; i>=0; i--) {\n        bool flag = true;\n        ll tmp = 0;\n        rep(k, 6) {\n          auto q = vec[k][i].first + now[k] * v[k][vec[k][i].second];\n          if (mp[k].find(q) == mp[k].end()) {\n            flag = false;\n            break;\n          } else {\n            tmp = mp[k][q];\n          }\n        }\n        if (flag) ans += tmp;\n        rep(k, 6) {\n          mp[k][vec[k][i].first]++;\n        }\n      }\n\n      cout << ans << endl;\n\n    }\n};\n\nsigned main() {\n  FEatingSymbolsHard solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\n\nconst int MAXN = 250005;\nconst lint mod = 1e12 + 39;\nconst int base = 257;\nint n, pos[MAXN];\nchar str[MAXN];\nlint pwr[MAXN * 2];\nlint inv[MAXN * 2];\n\nlint ipow(lint x, lint p){\n  lint ret = 1, piv = x;\n  while(p){\n    if(p & 1) ret = (__int128) ret * piv % mod;\n    piv = (__int128) piv * piv % mod;\n    p >>= 1;\n  }\n  return ret;\n}\n\nlint psum[MAXN];\n\nint main(){\n  cin >> n >> (str + 1);\n  pwr[0] = inv[0] = 1;\n  for(int i=1; i<MAXN * 2; i++){\n    pwr[i] = pwr[i-1] * base % mod;\n    inv[i] = ipow(pwr[i], mod - 2);\n  }\n  pos[0] = n;\n  for(int i=1; i<=n; i++){\n    pos[i] = pos[i-1];\n    psum[i] = psum[i-1];\n    if(str[i] == '<') pos[i]--;\n    if(str[i] == '>') pos[i]++;\n    if(str[i] == '+') psum[i] += pwr[pos[i]];\n    if(str[i] == '-') psum[i] += mod - pwr[pos[i]];\n    psum[i] %= mod;\n  }\n  lint H = psum[n];\n  lint ret = 0;\n  map<int, int> mp;\n  for(int i=n; i; i--){\n    mp[psum[i]]++;\n    __int128 Hv = H;\n    if(pos[0] <= pos[i-1]) Hv *= pwr[pos[i-1] - pos[0]];\n    else Hv *= inv[pos[0] - pos[i-1]];\n    Hv += psum[i-1];\n    Hv %= mod;\n    ret += mp[Hv];\n  }\n  cout << ret << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define pb push_back\n#define all(v) v.begin(), v.end()\n#define sz(v) int(v.size())\n#define pii pair<int, int>\n#define mp make_pair\n#define f first\n#define ll long long\n#define s second\n#define vec vector<int>\n\nusing namespace std;\n\nconst int N = (int) 770 + 10;\nconst int K = (int) N * N;\nconst int mod = (int) 1e9 + 7;\nconst int T = (int) 200017;\n\nint n;\nstring st;\nint p[N];\n\nvoid add(int &x, int y) {\n\tx += y;\n\tif (x >= mod)\n\t\tx -= mod;\n\tif (x < 0) \n\t\tx += mod;\n}\n\nint mult(int x, int y) {\n\treturn x * 1ll * y % mod;\n}\n\npair<int, int> get(int l, int r) {\n\tint pos = 2 * n;\n\tvector<int> a(4 * n, 0);\n\tfor (int i = l; i <= r; i++) {\n\t\tif (st[i] == '+') {\n\t\t\ta[pos]++;\n\t\t} else if (st[i] == '-') {\n\t\t\ta[pos]--;\n\t\t} else if (st[i] == '>') {\n\t\t\tpos++;\n\t\t} else {\n\t\t\tpos--;\n\t\t}\n\t}\n\tint hsh = 0;\n\tfor (int i = 0; i < sz(a); i++) {\n\t\tadd(hsh, mult(p[i], a[i]));\n\t}\n\treturn mp(hsh, pos);\n}\n\nint inv(int x) {\n\tint pw = mod - 2;\n\tint ans = 1;\n\twhile (pw) {\n\t\tif (pw & 1) \n\t\t\tans = mult(ans, x);\n\t\tx = mult(x, x);\n\t\tpw /= 2;\n\t}\n\treturn ans;\n}\n\n// get(l,r)=(get(0,r)-get(0,l-1))<<pos(0, l-1)\n\nint shift(int x, int val) { // to the right\n\tif (val > 0) {\n\t\tx = mult(x, p[val]);\n\t} else {\n\t\tx = mult(x, inv(p[-val]));\n\t}\n\treturn x;\n}\n\nint sum(int x, int y) {\n\tadd(x, y);\n\treturn x;\n}\n\nint main() {\n\t#ifdef sony\n\t\tfreopen(\"input.txt\", \"r\", stdin);\n\t\tfreopen(\"output.txt\", \"w\", stdout);\n\t#endif\n\tcin >> n >> st;\n\t//HASH(A) = {FOR I = [0...big_N] SUM OF A[I]*T^I % MODULO} WHERE T = PRIME > 2.5 * 10^5\n\tp[0] = 1;\n\tfor (int i = 1; i < N; i++) {\n\t\tp[i] = mult(p[i - 1], T);\n\t}\n\tint x = get(0, n - 1).f;\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i; j < n; j++) {\n\t\t\tint y = sum(shift(x, get(0, i - 1).s - 2 * n), shift(get(0, i - 1).f, 0));\n\t\t\tint z = shift(get(0, j).f, 0);\n\n\t\t\t//cout << \"~~~~~~~~~~~~~~~\\n\";\n\t\t\t//for (auto it : y) cout << it << ' ';\n\t\t\t//cout << endl;\n\t\t\t//for (auto it : z) cout << it << ' ';\n\t\t\t//cout << endl;\n\n\t\t\tif (z == y) {\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n\nLL inv(LL a , LL p){\n\tLL ret = 1;\n\tfor(LL i = p-2 ; i ; i /= 2){\n\t\tif(i&1) (ret *= a) %= p;\n\t\ta = a * a % p;\n\t}\n\treturn ret;\n}\n\nconst int RH_prime = 3;\nconst LL RH_mod[] = {1000000007,1000000021,1000000033};\nconst LL base = 314159;\n\nstruct RH{\n\tint n;\n\tvector<LL> hash[RH_prime];\n\tvector<LL> pw[RH_prime];\n\t\n\tRH(){n=0;}\n\tRH(const string &s){\n\t\tn = (int)s.size();\n\t\tfor(int i = 0 ; i < RH_prime ; ++i){\n\t\t\thash[i].push_back(0);\n\t\t\tpw[i].push_back(1);\n\t\t\tfor(int j = 0 ; j < n ; ++j){\n\t\t\t\tif(s[j] == '+' || s[j] == '-'){\n\t\t\t\t\thash[i].push_back((hash[i][j] + (s[j]=='-'?RH_mod[i]-pw[i][j]:pw[i][j])) % RH_mod[i]);\n\t\t\t\t\tpw[i].push_back(pw[i][j]);\n\t\t\t\t} else {\n\t\t\t\t\thash[i].push_back(hash[i][j]);\n\t\t\t\t\tpw[i].push_back(pw[i][j] * (s[j]=='>'?base:inv(base,RH_mod[i])) % RH_mod[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\nint main(){\n\tint N; cin >> N;\n\tstring S; cin >> S;\n\tRH rh(S);\n\tmap<tuple<LL,LL,LL>,int> M;\n\tLL ans = 0;\n\trepm(i,N,0){\n\t\t++M[make_tuple(rh.hash[0][i],rh.hash[1][i],rh.hash[2][i])];\n\t\ttuple<LL,LL,LL> z = make_tuple((rh.hash[0][N]*rh.pw[0][i-1]+rh.hash[0][i-1])%RH_mod[0],\n\t\t\t\t\t\t\t (rh.hash[1][N]*rh.pw[1][i-1]+rh.hash[1][i-1])%RH_mod[1],\n\t\t\t\t\t\t\t (rh.hash[2][N]*rh.pw[2][i-1]+rh.hash[2][i-1])%RH_mod[2]);\n\t\tans += M[z];\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <map>\nusing namespace std;\nchar s[250002];\npair<int,int> pw[500001],prefix[250001];\nint pos[250001];\nconst int MOD=1002068539;\nint qpow(int a,int b)\n{\n    int ret=1;\n    for (;b;a=(long long)a*a%MOD,b>>=1)\n        if (b&1)\n            ret=(long long)ret*a%MOD;\n    return ret;\n}\nvoid madd(int &a,int b)\n{\n    a+=b;\n    if (a>=MOD)\n        a-=MOD;\n}\nvoid madd(pair<int,int> &a,pair<int,int> b)\n{\n    madd(a.first,b.first);\n    madd(a.second,b.second);\n}\nvoid msubtract(int &a,int b)\n{\n    a-=b;\n    if (a<0)\n        a+=MOD;\n}\nvoid msubtract(pair<int,int> &a,pair<int,int> b)\n{\n    msubtract(a.first,b.first);\n    msubtract(a.second,b.second);\n}\nvoid mmultiply(pair<int,int> &a,pair<int,int> b)\n{\n    a.first=(long long)a.first*b.first%MOD;\n    a.second=(long long)a.second*b.second%MOD;\n}\nint main()\n{\n    int n;\n    scanf(\"%d%s\",&n,s+1);\n    pw[0]=make_pair(1,1);\n    for (int i=1;i<=500000;++i)\n    {\n        pw[i]=pw[i-1];\n        mmultiply(pw[i],make_pair(35748299,19260817));\n    }\n    pos[0]=0;\n    for (int i=1;i<=n;++i)\n    {\n        prefix[i]=prefix[i-1];\n        pos[i]=pos[i-1];\n        if (s[i]=='<')\n            --pos[i];\n        else if (s[i]=='>')\n            ++pos[i];\n        else if (s[i]=='+')\n            madd(prefix[i],pw[pos[i]+250000]);\n        else\n            msubtract(prefix[i],pw[pos[i]+250000]);\n    }\n    long long ans=0;\n    map<pair<int,int>,int> mp;\n    for (int i=n;i>=1;--i)\n    {\n        pair<int,int> tmp=prefix[n];\n        msubtract(tmp,prefix[i]);\n        ++mp[tmp];\n        tmp=prefix[n];\n        if (pos[i-1]>0)\n            mmultiply(tmp,make_pair(pw[pos[i-1]].first,pw[pos[i-1]].second));\n        else if (pos[i-1]<0)\n            mmultiply(tmp,make_pair(qpow(pw[-pos[i-1]].first,MOD-2),qpow(pw[-pos[i-1]].second,MOD-2)));\n        pair<int,int> search=prefix[n];\n        msubtract(search,tmp);\n        msubtract(search,prefix[i-1]);\n        ans+=mp[search];\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n    _____\n  .'     '.\n /  0   0  \\\n|     ^     |\n|  \\     /  |\n \\  '---'  /\n  '._____.'\n*/\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\nstruct chash\n{\n\tint operator()(int x) const\n\t{\n\t\tx ^= (x >> 20) ^ (x >> 12);\n\t\treturn x ^ (x >> 7) ^ (x >> 4);\n\t}\n};\n\ntemplate<typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename U> using hashtable = gp_hash_table<T, U, chash>;\nrandom_device(rd);\nmt19937 rng(rd());\n\ntemplate<class T>\nvoid readi(T &x)\n{\n\tT input = 0;\n\tbool negative = false;\n\tchar c = ' ';\n\twhile (c < '-')\n\t{\n\t\tc = getchar();\n\t}\n\tif (c == '-')\n\t{\n\t\tnegative = true;\n\t\tc = getchar();\n\t}\n\twhile (c >= '0')\n\t{\n\t\tinput = input * 10 + (c - '0');\n\t\tc = getchar();\n\t}\n\tif (negative)\n\t{\n\t\tinput = -input;\n\t}\n\tx = input;\n}\ntemplate<class T>\nvoid printi(T output)\n{\n\tif (output == 0)\n\t{\n\t\tputchar('0');\n\t\treturn;\n\t}\n\tif (output < 0)\n\t{\n\t\tputchar('-');\n\t\toutput = -output;\n\t}\n\tint aout[20];\n\tint ilen = 0;\n\twhile(output)\n\t{\n\t\taout[ilen] = ((output % 10));\n\t\toutput /= 10;\n\t\tilen++;\n\t}\n\tfor (int i = ilen - 1; i >= 0; i--)\n\t{\n\t\tputchar(aout[i] + '0');\n\t}\n\treturn;\n}\ntemplate<class T>\nvoid ckmin(T &a, T b)\n{\n\ta = min(a, b);\n}\ntemplate<class T>\nvoid ckmax(T &a, T b)\n{\n\ta = max(a, b);\n}\ntemplate<class T, class U>\nT nmod(T &x, U mod)\n{\n\tif (x >= mod) x -= mod;\n}\ntemplate<class T>\nT randomize(T mod)\n{\n\treturn (uniform_int_distribution<T>(0, mod - 1))(rng);\n}\n\n#define y0 ___y0\n#define y1 ___y1\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fi first\n#define se second\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\nconst long double PI = 4.0 * atan(1.0);\nconst long double EPS = 1e-10;\n\n#define MAGIC 347\n#define SINF 10007\n#define CO 1000007\n#define INF 1000000007\n#define BIG 1000000931\n#define LARGE 1696969696967ll\n#define GIANT 2564008813937411ll\n#define LLINF 2696969696969696969ll\n#define MAXN 250013\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ld, ld> pdd;\n\nint N;\nint arr[MAXN];\npll S;\nlong long ans;\nmap<ll, int> need;\n\nll expo(ll a, ll e, ll mod)\n{\n\tif (e == 0)\n\t{\n\t\treturn 1;\n\t}\n\tll was = expo(a, e / 2, mod);\n\tif (e % 2)\n\t{\n\t\treturn was * was % mod * a % mod;\n\t}\n\treturn was * was % mod;\n}\nll modinv(ll a, ll e)\n{\n\treturn expo(a, e - 2, e);\n}\npll INV = {modinv(CO, INF), modinv(CO, BIG)};\nvoid solve(int L, int R)\n{\n\tif (L == R)\n\t{\n\t\treturn;\n\t}\n\tneed.clear();\n\tint mid = (L + R) >> 1;\n\t//start from L...mid, end at mid + 1....R\n\tpair<pll, pll> trans = MP(MP(1, 0), MP(1, 0));\n\tpll inv = MP(1, 1);\n\tfor (int i = mid + 1; i <= R; i++)\n\t{\n\t\tif (arr[i] == 0)\n\t\t{\n\t\t\ttrans.fi.fi *= INV.fi; trans.fi.fi %= INF;\n\t\t\ttrans.fi.se *= INV.fi; trans.fi.se %= INF;\n\t\t\ttrans.se.fi *= INV.se; trans.se.fi %= BIG;\n\t\t\ttrans.se.se *= INV.se; trans.se.se %= BIG;\n\t\t\tinv.fi *= CO; inv.fi %= INF;\n\t\t\tinv.se *= CO; inv.se %= BIG;\n\t\t}\n\t\tif (arr[i] == 1)\n\t\t{\n\t\t\ttrans.fi.fi *= CO; trans.fi.fi %= INF;\n\t\t\ttrans.fi.se *= CO; trans.fi.se %= INF;\n\t\t\ttrans.se.fi *= CO; trans.se.fi %= BIG;\n\t\t\ttrans.se.se *= CO; trans.se.se %= BIG;\n\t\t\tinv.fi *= INV.fi; inv.fi %= INF;\n\t\t\tinv.se *= INV.se; inv.se %= BIG;\n\t\t}\n\t\tif (arr[i] == 2)\n\t\t{\n\t\t\ttrans.fi.se++; nmod(trans.fi.se, INF);\n\t\t\ttrans.se.se++; nmod(trans.se.se, BIG);\n\t\t}\n\t\tif (arr[i] == 3)\n\t\t{\n\t\t\ttrans.fi.se--; trans.fi.se += INF; nmod(trans.fi.se, INF);\n\t\t\ttrans.se.se--; trans.se.se += BIG; nmod(trans.se.se, BIG);\n\t\t}\n\t\tpll dif = {(S.fi - trans.fi.se) * inv.fi, (S.se - trans.se.se) * inv.se};\n\t\tdif.fi %= INF; dif.fi += INF; nmod(dif.fi, INF);\n\t\tdif.se %= BIG; dif.se += BIG; nmod(dif.se, BIG);\n\t\tneed[dif.fi * BIG + dif.se]++;\n\t}\n\ttrans = MP(MP(1, 0), MP(1, 0));\n\tfor (int i = mid; i >= L; i--)\n\t{\n\t\tif (arr[i] == 0)\n\t\t{\n\t\t\ttrans.fi.fi *= INV.fi; trans.fi.fi %= INF;\n\t\t\ttrans.se.fi *= INV.se; trans.se.fi %= BIG;\n\t\t}\n\t\tif (arr[i] == 1)\n\t\t{\n\t\t\ttrans.fi.fi *= CO; trans.fi.fi %= INF;\n\t\t\ttrans.se.fi *= CO; trans.se.fi %= BIG;\n\t\t}\n\t\tif (arr[i] == 2)\n\t\t{\n\t\t\ttrans.fi.se += trans.fi.fi; nmod(trans.fi.se, INF);\n\t\t\ttrans.se.se += trans.se.fi; nmod(trans.se.se, BIG);\n\t\t}\n\t\tif (arr[i] == 3)\n\t\t{\n\t\t\ttrans.fi.se -= trans.fi.fi; trans.fi.se += INF; nmod(trans.fi.se, INF);\n\t\t\ttrans.se.se -= trans.se.fi;\ttrans.se.se += BIG; nmod(trans.se.se, BIG);\n\t\t}\n\t\tans += need[trans.fi.se * BIG + trans.se.se];\n\t}\n\tsolve(L, mid);\n\tsolve(mid + 1, R);\n}\n\nint32_t main()\n{\n\tios_base::sync_with_stdio(0);\n\t// cout << fixed << setprecision(10);\n\t// cerr << fixed << setprecision(10);\n\t// freopen (\"file.in\", \"r\", stdin);\n\t// freopen (\"file.out\", \"w\", stdout);\n\tcin >> N;\n\tstring temps;\n\tcin >> temps;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (temps[i] == '<')\n\t\t{\n\t\t\tarr[i] = 0;\n\t\t}\n\t\tif (temps[i] == '>')\n\t\t{\n\t\t\tarr[i] = 1;\n\t\t}\n\t\tif (temps[i] == '+')\n\t\t{\n\t\t\tarr[i] = 2;\n\t\t}\n\t\tif (temps[i] == '-')\n\t\t{\n\t\t\tarr[i] = 3;\n\t\t}\n\t}\n\treverse(arr, arr + N);\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (arr[i] == 0)\n\t\t{\n\t\t\tS.fi *= INV.fi; S.fi %= INF;\n\t\t\tS.se *= INV.se; S.se %= BIG;\n\t\t}\n\t\tif (arr[i] == 1)\n\t\t{\n\t\t\tS.fi *= CO; S.fi %= INF;\n\t\t\tS.se *= CO; S.se %= BIG;\n\t\t}\n\t\tif (arr[i] == 2)\n\t\t{\n\t\t\tS.fi++; nmod(S.fi, INF);\n\t\t\tS.se++; nmod(S.se, BIG);\n\t\t}\n\t\tif (arr[i] == 3)\n\t\t{\n\t\t\tS.fi--; S.fi += INF; nmod(S.fi, INF);\n\t\t\tS.se--; S.se += BIG; nmod(S.se, BIG);\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (arr[i] == 0)\n\t\t{\n\t\t\tif (S == MP(0ll, 0ll)) ans++;\n\t\t}\n\t\tif (arr[i] == 1)\n\t\t{\n\t\t\tif (S == MP(0ll, 0ll)) ans++;\n\t\t}\n\t\tif (arr[i] == 2)\n\t\t{\n\t\t\tif (S == MP(1ll, 1ll)) ans++;\n\t\t}\n\t\tif (arr[i] == 3)\n\t\t{\n\t\t\tif (S == MP((ll) INF - 1, (ll) BIG - 1)) ans++;\n\t\t}\n\t}\n\tsolve(0, N - 1);\n\tcout << ans << '\\n';\n\t//when u <, the # divides by co\n\t//when u >, the # mults by co\n\t//when u +, u add the #\n\t//when u -, u subtract the #\n\tcerr << \"time elapsed = \" << (clock() / (CLOCKS_PER_SEC / 1000)) << \" ms\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long lint;\n\nlint modpow(lint x, lint y, lint mod) {\n  lint ret = 1 % mod, x2p = x;\n  while (y > 0) {\n    if (y % 2) ret = (__int128)ret * x2p % mod;\n    y /= 2;\n    x2p = (__int128)x2p * x2p % mod;\n  }\n  return ret;\n}\n\nconst lint mod_1 = 4511686018432017251LL, mod_2 = 4511686018432015967LL;\nconst lint base = 549817;\nconst lint inv_base_1 = modpow(base, mod_1 - 2, mod_1);\nconst lint inv_base_2 = modpow(base, mod_2 - 2, mod_2);\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  string seq(n, ' ');\n  for (int i = 0; i < n; ++i)\n    scanf(\" %c\", &seq[i]);\n\n  vector<int> pos_before(n);\n\n  //\n  vector<lint> base_pow_1(n + 1);\n  base_pow_1[0] = 1;\n  for (int i = 1; i <= n; ++i)\n    base_pow_1[i] = (__int128)base * base_pow_1[i - 1] % mod_1;\n\n  vector<lint> inv_base_pow_1(n + 1);\n  inv_base_pow_1[0] = 1;\n  for (int i = 1; i <= n; ++i)\n    inv_base_pow_1[i] = (__int128)inv_base_1 * inv_base_pow_1[i - 1] % mod_1;\n\n  vector<lint> hash_diff_1(n, 0);\n  int pos = 0;\n  for (int i = 0; i < n; ++i) {\n    pos_before[i] = pos;\n    if (seq[i] == '>') ++pos;\n    else if (seq[i] == '<') --pos;\n    else {\n      lint base_pow_1_pos;\n      if (pos >= 0) base_pow_1_pos = base_pow_1[pos];\n      else base_pow_1_pos = inv_base_pow_1[-pos];\n      if (seq[i] == '+') hash_diff_1[i] = base_pow_1_pos;\n      else if (seq[i] == '-') hash_diff_1[i] = mod_1 - base_pow_1_pos;\n      else assert(0);\n    }\n  }\n  lint full_seq_hash_1 = 0;\n  for (int i = 0; i < n; ++i) {\n    full_seq_hash_1 += hash_diff_1[i];\n    if (full_seq_hash_1 >= mod_1) full_seq_hash_1 -= mod_1;\n  }\n\n  vector<lint> suffix_1(n + 1);\n  suffix_1[n] = 0;\n  for (int i = n - 1; i >= 0; --i) {\n    suffix_1[i] = hash_diff_1[i] + suffix_1[i + 1];\n    if (suffix_1[i] >= mod_1) suffix_1[i] -= mod_1;\n  }\n\n  //\n  vector<lint> base_pow_2(n + 1);\n  base_pow_2[0] = 1;\n  for (int i = 1; i <= n; ++i)\n    base_pow_2[i] = (__int128)base * base_pow_2[i - 1] % mod_2;\n\n  vector<lint> inv_base_pow_2(n + 1);\n  inv_base_pow_2[0] = 1;\n  for (int i = 1; i <= n; ++i)\n    inv_base_pow_2[i] = (__int128)inv_base_2 * inv_base_pow_2[i - 1] % mod_2;\n\n  vector<lint> hash_diff_2(n, 0);\n  pos = 0;\n  for (int i = 0; i < n; ++i) {\n    if (seq[i] == '>') ++pos;\n    else if (seq[i] == '<') --pos;\n    else {\n      lint base_pow_2_pos;\n      if (pos >= 0) base_pow_2_pos = base_pow_2[pos];\n      else base_pow_2_pos = inv_base_pow_2[-pos];\n      if (seq[i] == '+') hash_diff_2[i] = base_pow_2_pos;\n      else if (seq[i] == '-') hash_diff_2[i] = mod_2 - base_pow_2_pos;\n      else assert(0);\n    }\n  }\n  lint full_seq_hash_2 = 0;\n  for (int i = 0; i < n; ++i) {\n    full_seq_hash_2 += hash_diff_2[i];\n    if (full_seq_hash_2 >= mod_2) full_seq_hash_2 -= mod_2;\n  }\n\n  vector<lint> suffix_2(n + 1);\n  suffix_2[n] = 0;\n  for (int i = n - 1; i >= 0; --i) {\n    suffix_2[i] = hash_diff_2[i] + suffix_2[i + 1];\n    if (suffix_2[i] >= mod_2) suffix_2[i] -= mod_2;\n  }\n  //\n\n  lint result = 0;\n  map<pair<lint, lint>, int> count;\n  count[{suffix_1[n], suffix_2[n]}] += 1;\n  for (int i = n - 1; i >= 0; --i) {\n    lint shifted_full_1, shifted_full_2;\n    if (pos_before[i] >= 0) {\n      shifted_full_1 = (__int128)full_seq_hash_1 * base_pow_1[pos_before[i]] % mod_1;\n      shifted_full_2 = (__int128)full_seq_hash_2 * base_pow_2[pos_before[i]] % mod_2;\n    } else {\n      shifted_full_1 = (__int128)full_seq_hash_1 * inv_base_pow_1[-pos_before[i]] % mod_1;\n      shifted_full_2 = (__int128)full_seq_hash_2 * inv_base_pow_2[-pos_before[i]] % mod_2;\n    }\n\n    lint target_1 = suffix_1[i] - shifted_full_1;\n    if (target_1 < 0) target_1 += mod_1;\n\n    lint target_2 = suffix_2[i] - shifted_full_2;\n    if (target_2 < 0) target_2 += mod_2;\n\n    auto it = count.find({target_1, target_2});\n    if (it != count.end())\n      result += it->second;\n\n    count[{suffix_1[i], suffix_2[i]}] += 1;\n  }\n  printf(\"%lld\\n\", result);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\n\nint N;\nstring S;\nll mo=1000000007;\nvector<ll> C,R;\nconst int PAT=4;\nvector<ll> A[PAT];\nvector<ll> B[PAT];\n\nll modpow(ll a, ll n = mo-2) {\n\tll r=1;a%=mo;\n\twhile(n) r=r*((n%2)?a:1)%mo,a=a*a%mo,n>>=1;\n\treturn r;\n}\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>S;\n\tsrand(time(NULL));\n\tFOR(i,PAT) {\n\t\tC.push_back(rand()%10000000+10000000);\n\t\tR.push_back(modpow(C.back()));\n\t\tA[i].push_back(1);\n\t\tB[i].push_back(0);\n\t}\n\treverse(ALL(S));\n\tFORR(c,S) {\n\t\tFOR(i,PAT) {\n\t\t\tif(c=='+') {\n\t\t\t\tA[i].push_back(A[i].back());\n\t\t\t\tB[i].push_back((B[i].back()+1)%mo);\n\t\t\t}\n\t\t\tif(c=='-') {\n\t\t\t\tA[i].push_back(A[i].back());\n\t\t\t\tB[i].push_back((B[i].back()+mo-1)%mo);\n\t\t\t}\n\t\t\tif(c=='>') {\n\t\t\t\tA[i].push_back(A[i].back()*R[i]%mo);\n\t\t\t\tB[i].push_back(B[i].back()*R[i]%mo);\n\t\t\t}\n\t\t\tif(c=='<') {\n\t\t\t\tA[i].push_back(A[i].back()*C[i]%mo);\n\t\t\t\tB[i].push_back(B[i].back()*C[i]%mo);\n\t\t\t}\n\t\t}\n\t}\n\tll ret=0;\n\tmap<vector<ll>,int> memo;\n\tmemo[vector<ll>(PAT,0)]++;\n\tFOR(j,N) {\n\t\tvector<ll> BA(PAT),BAS(PAT);\n\t\tFOR(i,PAT) {\n\t\t\tBA[i]=B[i][j+1]*modpow(A[i][j+1])%mo;\n\t\t\tBAS[i]=(B[i][j+1]+mo-B[i].back())*modpow(A[i][j+1])%mo;\n\t\t}\n\t\tret+=memo[BAS];\n\t\tmemo[BA]++;\n\t}\n\tcout<<ret<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=(0);i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n \ntemplate<class T> inline void read(T &x){\n\tint f=0;x=0;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar())f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar())x=x*10+ch-'0';\n\tif(f)x=-x;\n}\n\nconst int N=500005;\nnamespace{\n\tconst int mod=1e9+7;\n\tint p[N],rp[N];\n\tint power(int x){\n\t\treturn x>=0?p[x]:rp[-x];\n\t}\n\tint power(int x,int p){\n\t\tint res=1;\n\t\tfor(;p;p>>=1,x=(ll)x*x%mod)\n\t\t\tif(p&1)res=(ll)res*x%mod;\n\t\treturn res;\n\t}\n\tvoid init(int n){\n\t\tint A=2333,B=power(A,mod-2);\n\t\tp[0]=rp[0]=1;\n\t\trep(i,1,n){\n\t\t\tp[i]=(ll)p[i-1]*A%mod;\n\t\t\trp[i]=(ll)rp[i-1]*B%mod;\n\t\t}\n\t}\n}\n\nint v[N],d[N],n;\nmap<int,int> cnt;\nchar s[N];\nll ans;\n\nint main(){\n\tread(n),init(n);\n\tscanf(\"%s\",s+1);\n\trep(i,1,n){\n\t\tv[i]=v[i-1],d[i]=d[i-1];\n\t\tif(s[i]=='<')d[i]--;\n\t\telse if(s[i]=='>')d[i]++;\n\t\telse if(s[i]=='+')v[i]=(v[i]+power(d[i]))%mod;\n\t\telse v[i]=(v[i]+mod-power(d[i]))%mod;\n\t}\n\tper(i,n-1,0){\n\t\tcnt[v[i+1]]++;\n\t\tans+=cnt[(v[i]+(ll)power(d[i])*v[n])%mod];\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nAuthor: QAQAutomaton\nLang: C++\nCode: F.cpp\nMail: lk@qaq-am.com\nBlog: https://www.qaq-am.com/\n*/\n#include<bits/stdc++.h>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG printf(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define Debug debug(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define all(x) x.begin(),x.end()\n#define x first\n#define y second\nusing namespace std;\ntypedef unsigned uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef complex<double> cp;\ntypedef pair<int,int> pii;\nint inf;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\ntemplate<class T,class T2>int chkmin(T &a,T2 b){return a>b?a=b,1:0;}\ntemplate<class T,class T2>int chkmax(T &a,T2 b){return a<b?a=b,1:0;}\ntemplate<class T>T sqr(T a){return a*a;}\ntemplate<class T,class T2>T mmin(T a,T2 b){return a<b?a:b;}\ntemplate<class T,class T2>T mmax(T a,T2 b){return a>b?a:b;}\ntemplate<class T>T aabs(T a){return a<0?-a:a;}\ntemplate<class T>int dcmp(T a,T b){return a>b;}\ntemplate<int *a>int cmp_a(int x,int y){return a[x]<a[y];}\n#define min mmin\n#define max mmax\n#define abs aabs\nstruct __INIT__{\n\t__INIT__(){\n\t\tmemset(&inf,0x3f,sizeof(inf));\n\t\tfill((unsigned char*)&inf,(unsigned char*)&inf+sizeof(inf),0x3f);\n\t}\n}__INIT___;\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\ttemplate<typename A>\n\tinline bool read (A &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;else if(c==EOF)return 0;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t\treturn 1;\n\t}\n\tinline bool read (char &x) {\n\t\twhile((x=gc())==' '||x=='\\n' || x=='\\r');\n\t\treturn x!=EOF;\n\t}\n\tinline bool read(char *x){\n\t\twhile((*x=gc())=='\\n' || *x==' '||*x=='\\r');\n\t\tif(*x==EOF)return 0;\n\t\twhile(!(*x=='\\n'||*x==' '||*x=='\\r'||*x==EOF))*(++x)=gc();\n\t\t*x=0;\n\t\treturn 1;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool read(A &x,B &...y){\n\t\treturn read(x)&&read(y...);\n\t}\n\ttemplate<typename A>\n\tinline bool write (A x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t\treturn 0;\n\t}\n\tinline bool write (char x) {\n\t\tputc(x);\n\t\treturn 0;\n\t}\n\tinline bool write(const char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\tinline bool write(char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool write(A x,B ...y){\n\t\treturn write(x)||write(y...);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: read;\nusing io :: putc;\nusing io :: write;\nchar s[250005];\nconst int p1=951274487,q1=449117,iq1=694385027;\nconst int p2=917234839,q2=440941,iq2=9129892;\nstruct Z1{\n\tuint x;\n\tZ1(){}\n\tZ1(uint a){\n\t\tx=a;\n\t}\n};\ninline uint modp1(const uint x){\n\treturn x<p1?x:x-p1;\n}\ninline Z1 operator+(const Z1 x1, const Z1 x2) { return modp1(x1.x+x2.x);}\ninline Z1 operator-(const Z1 x1, const Z1 x2) { return modp1(x1.x+p1-x2.x);}\ninline Z1 operator-(const Z1 x) {return x.x?p1-x.x:0;}\ninline Z1 operator*(const Z1 x1, const Z1 x2) { return static_cast<ull>(x1.x)*x2.x%p1;}\nvoid exgcd(int a,int b,int &x,int &y){\n\tif(!b){x=1;y=0;return;}\n\texgcd(b,a%b,y,x);\n\ty-=(a/b)*x;\n}\ninline Z1 Inv(const Z1 a){\n\tint x,y;\n\texgcd(p1,a.x,x,y);\n\treturn y<0?y+=p1:y;\n}\ninline Z1 operator/(const Z1 x1, const Z1 x2) { return x1*Inv(x2);}\n\ninline Z1 &operator++(Z1 &x1){x1.x==p1-1?x1.x=0:++x1.x;return x1;} \ninline Z1 &operator--(Z1 &x1){x1.x?--x1.x:x1.x=p1-1;return x1;}\ninline Z1 &operator+=(Z1 &x1, const Z1 x2) { return x1 = x1 + x2; }\ninline Z1 &operator-=(Z1 &x1, const Z1 x2) { return x1 = x1 - x2; }\ninline Z1 &operator*=(Z1 &x1, const Z1 x2) { return x1 = x1 * x2; }\ninline Z1 &operator/=(Z1 &x1, const Z1 x2) { return x1 = x1 / x2; }\n\nstruct Z2{\n\tuint x;\n\tZ2(){}\n\tZ2(uint a){\n\t\tx=a;\n\t}\n};\ninline uint modp2(const uint x){\n\treturn x<p2?x:x-p2;\n}\ninline Z2 operator+(const Z2 x1, const Z2 x2) { return modp2(x1.x+x2.x);}\ninline Z2 operator-(const Z2 x1, const Z2 x2) { return modp2(x1.x+p2-x2.x);}\ninline Z2 operator-(const Z2 x) {return x.x?p2-x.x:0;}\ninline Z2 operator*(const Z2 x1, const Z2 x2) { return static_cast<ull>(x1.x)*x2.x%p2;}\ninline Z2 Inv(const Z2 a){\n\tint x,y;\n\texgcd(p2,a.x,x,y);\n\treturn y<0?y+=p2:y;\n}\ninline Z2 operator/(const Z2 x1, const Z2 x2) { return x1*Inv(x2);}\n\ninline Z2 &operator++(Z2 &x1){x1.x==p2-1?x1.x=0:++x1.x;return x1;} \ninline Z2 &operator--(Z2 &x1){x1.x?--x1.x:x1.x=p2-1;return x1;}\ninline Z2 &operator+=(Z2 &x1, const Z2 x2) { return x1 = x1 + x2; }\ninline Z2 &operator-=(Z2 &x1, const Z2 x2) { return x1 = x1 - x2; }\ninline Z2 &operator*=(Z2 &x1, const Z2 x2) { return x1 = x1 * x2; }\ninline Z2 &operator/=(Z2 &x1, const Z2 x2) { return x1 = x1 / x2; }\n\nZ1 xpw1[500015],*pw1=xpw1+250005;\nZ2 xpw2[500015],*pw2=xpw2+250005;\nmap<long long,int> mp;\nsigned main(){\n#ifdef QAQAutoMaton \n\tfreopen(\"F.in\",\"r\",stdin);\n\tfreopen(\"F.out\",\"w\",stdout);\n#endif\n\tint n;\n\tread(n);\n\tread(s+1);\n\tpw1[0]=1;\n\tfor(int i=1;i<=n;++i){pw1[i]=pw1[i-1]*q1;}\n\tfor(int i=1;i<=n;++i){pw1[-i]=pw1[1-i]*iq1;}\n\tpw2[0]=1;\n\tfor(int i=1;i<=n;++i){pw2[i]=pw2[i-1]*q2;}\n\tfor(int i=1;i<=n;++i){pw2[-i]=pw2[1-i]*iq2;}\n\n\tZ1 cur1=1,cnt1=0;\n\tZ2 cur2=1,cnt2=0;\n\tfor(int i=1;i<=n;++i){\n\t\tswitch(s[i]){\n\t\t\tcase '+':cnt1+=cur1;cnt2+=cur2;break;\n\t\t\tcase '-':cnt1-=cur1;cnt2-=cur2;break;\n\t\t\tcase '<':cur1*=iq1;cur2*=iq2;break;\n\t\t\tcase '>':cur1*=q1;cur2*=q2;break;\n\t\t}\n\t}\n\t++mp[0];\n\tint c=0;\n\tZ1 now1(0),w1(1);\n\tZ2 now2(0),w2(1);\n\tll ans=0;\n\tfor(int i=n;i;--i){\n\t\tswitch(s[i]){\n\t\t\tcase '+': now1+=w1;now2+=w2;break;\n\t\t\tcase '-': now1-=w1;now2-=w2;break;\n\t\t\tcase '<': ++c;w1*=q1;w2*=q2;break;\n\t\t\tcase '>': --c;w1*=iq1;w2*=iq2;break;\n\t\t}\n\t\tans+=mp[(ll)((now1-cnt1*pw1[c]).x)*p2+(now2-cnt2*pw2[c]).x];\n\t\t++mp[(ll)now1.x*p2+now2.x];\n\t}\n\twrite(ans,'\\n');\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <unordered_map>\n\ntypedef long long LL;\nconst int Mod[2] = {999988679, 999988609};\nconst int B[2] = {370728, 370732};\nconst int iB[2] = {396903752, 462741403};\nconst int MN = 250005;\n\ninline void Add(int &x, int y, int i) { x -= (x += y) >= Mod[i] ? Mod[i] : 0; }\n\nint N;\nchar S[MN];\nint A[2][MN], D[2][MN];\nstd::unordered_map<LL, int> Buk;\nLL Ans;\n\nint main() {\n\tscanf(\"%d%s\", &N, S + 1);\n\tfor (int j = 0; j < 2; ++j) A[j][0] = 0, D[j][0] = 1;\n\tfor (int i = 1, V[2] = {1, 1}; i <= N; ++i) {\n\t\tfor (int j = 0; j < 2; ++j) {\n\t\t\tA[j][i] = A[j][i - 1];\n\t\t\tif (S[i] == '+') Add(A[j][i], V[j], j);\n\t\t\tif (S[i] == '-') Add(A[j][i], Mod[j] - V[j], j);\n\t\t\tif (S[i] == '>') V[j] = (LL)V[j] * B[j] % Mod[j];\n\t\t\tif (S[i] == '<') V[j] = (LL)V[j] * iB[j] % Mod[j];\n\t\t\tD[j][i] = V[j];\n\t\t}\n\t}\n\tfor (int i = N; i >= 0; --i) {\n\t\tAns += Buk[\n\t\t\t(A[0][i] + (LL)A[0][N] * D[0][i]) % Mod[0] +\n\t\t\t(A[1][i] + (LL)A[1][N] * D[1][i]) % Mod[1] * Mod[0]\n\t\t];\n\t\t++Buk[A[0][i] + A[1][i] * Mod[0]];\n\t}\n\tprintf(\"%lld\\n\", Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <cmath>\n#include <map>\n#define enter putchar('\\n')\n#define space putchar(' ')\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define eps 1e-7\n#define MAXN 250005\n#define MOD 999999137\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef double db;\ntypedef vector<int> poly;\n\ntemplate<class T>\nvoid read(T &res) {\n\tres = 0;char c = getchar();T f = 1;\n\twhile(c < '0' || c > '9') {\n\t\tif(c == '-') f = -1;\n\t\tc = getchar();\n\t}\n\twhile(c >= '0' && c <= '9') {\n\t\tres = res * 10 + c - '0';\n\t\tc = getchar();\n\t}\n\tres *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n\tif(x < 0) {putchar('-');x = -x;}\n\tif(x >= 10) {\n\t\tout(x / 10);\n\t}\n\tputchar('0' + x % 10);\n}\nint B[] = {0,397,823,727,401,271,571};\nint InvB[10];\nint f[8][MAXN],g[8][MAXN],N,h[8][MAXN];\nchar s[MAXN];\nmap<int,int> MK[8];\n\n\nint mul(int a,int b) {\n\treturn 1LL * a * b % MOD;\n}\nint inc(int a,int b) {\n\treturn a + b >= MOD ? a + b - MOD : a + b;\n}\nvoid update(int &x,char c,int id) {\n\tif(c == '<') x = mul(x,InvB[id]);\n\telse if(c == '>') x = mul(x,B[id]);\n\telse if(c == '+') x = inc(x,1);\n\telse x = inc(x,MOD - 1);\n}\nint fpow(int x,int c) {\n\tint res = 1,t = x;\n\twhile(c) {\n\t\tif(c & 1) res = mul(res,t);\n\t\tt = mul(t,t);\n\t\tc >>= 1;\n\t}\n\treturn res;\n}\nvoid Solve() {\n\tfor(int i = 1 ; i <= 6 ; ++i) InvB[i] = fpow(B[i],MOD - 2);\n\tread(N);\n\tscanf(\"%s\",s + 1);\n\tint c[10] = {0};\n\tfor(int k = 1 ; k <= 6 ; ++k) {\n\t\tfor(int i = N ; i >= 1 ; --i) {\n\t\t\tupdate(c[k],s[i],k);\n\t\t}\n\t}\n\tfor(int k = 1 ; k <= 6 ; ++k) h[k][N + 1] = 1,g[k][N + 1] = c[k],MK[k][0] += 1;\n\tint64 ans = 0;\n\tfor(int i = N ; i >= 1 ; --i) {\n\t\tint add = N - i + 1;\n\t\tfor(int k = 1 ; k <= 6 ; ++k) {\n\t\t\tif(s[i] == '<') {\n\t\t\t\tg[k][i] = inc(g[k][i + 1],MOD - mul(h[k][i + 1],c[k]));\n\t\t\t\th[k][i] = mul(h[k][i + 1],B[k]);\n\t\t\t\tg[k][i] = inc(g[k][i],mul(h[k][i],c[k]));\n\t\t\t\tf[k][i] = f[k][i + 1];\t\t\n\t\t\t}\n\t\t\telse if(s[i] == '>') {\n\t\t\t\tg[k][i] = inc(g[k][i + 1],MOD - mul(h[k][i + 1],c[k]));\n\t\t\t\th[k][i] = mul(h[k][i + 1],InvB[k]);\n\t\t\t\tg[k][i] = inc(g[k][i],mul(h[k][i],c[k]));\n\t\t\t\tf[k][i] = f[k][i + 1];\n\t\t\t}\n\t\t\telse if(s[i] == '+') {\n\t\t\t\th[k][i] = h[k][i + 1];\n\t\t\t\tg[k][i] = inc(g[k][i + 1],MOD - h[k][i]);\n\t\t\t\tf[k][i] = inc(f[k][i + 1],MOD - h[k][i]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\th[k][i] = h[k][i + 1];\n\t\t\t\tg[k][i] = inc(g[k][i + 1],h[k][i]);\n\t\t\t\tf[k][i] = inc(f[k][i + 1],h[k][i]);\n\t\t\t}\n\t\t\tadd = min(add,MK[k][g[k][i]]);\n\t\t\tMK[k][f[k][i]] += 1;\n\t\t}\n\t\tans += add;\n\t}\n\tout(ans);enter;\t\n}\nint main() {\n#ifdef ivorysi\n\tfreopen(\"f1.in\",\"r\",stdin);\n#endif\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n    _____\n  .'     '.\n /  0   0  \\\n|     ^     |\n|  \\     /  |\n \\  '---'  /\n  '._____.'\n*/\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\nstruct chash\n{\n\tint operator()(int x) const\n\t{\n\t\tx ^= (x >> 20) ^ (x >> 12);\n\t\treturn x ^ (x >> 7) ^ (x >> 4);\n\t}\n};\n\ntemplate<typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename U> using hashtable = gp_hash_table<T, U, chash>;\nrandom_device(rd);\nmt19937 rng(rd());\n\ntemplate<class T>\nvoid readi(T &x)\n{\n\tT input = 0;\n\tbool negative = false;\n\tchar c = ' ';\n\twhile (c < '-')\n\t{\n\t\tc = getchar();\n\t}\n\tif (c == '-')\n\t{\n\t\tnegative = true;\n\t\tc = getchar();\n\t}\n\twhile (c >= '0')\n\t{\n\t\tinput = input * 10 + (c - '0');\n\t\tc = getchar();\n\t}\n\tif (negative)\n\t{\n\t\tinput = -input;\n\t}\n\tx = input;\n}\ntemplate<class T>\nvoid printi(T output)\n{\n\tif (output == 0)\n\t{\n\t\tputchar('0');\n\t\treturn;\n\t}\n\tif (output < 0)\n\t{\n\t\tputchar('-');\n\t\toutput = -output;\n\t}\n\tint aout[20];\n\tint ilen = 0;\n\twhile(output)\n\t{\n\t\taout[ilen] = ((output % 10));\n\t\toutput /= 10;\n\t\tilen++;\n\t}\n\tfor (int i = ilen - 1; i >= 0; i--)\n\t{\n\t\tputchar(aout[i] + '0');\n\t}\n\treturn;\n}\ntemplate<class T>\nvoid ckmin(T &a, T b)\n{\n\ta = min(a, b);\n}\ntemplate<class T>\nvoid ckmax(T &a, T b)\n{\n\ta = max(a, b);\n}\ntemplate<class T, class U>\nT nmod(T &x, U mod)\n{\n\tif (x >= mod) x -= mod;\n}\ntemplate<class T>\nT randomize(T mod)\n{\n\treturn (uniform_int_distribution<T>(0, mod - 1))(rng);\n}\n\n#define y0 ___y0\n#define y1 ___y1\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fi first\n#define se second\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\nconst long double PI = 4.0 * atan(1.0);\nconst long double EPS = 1e-10;\n\n#define MAGIC 347\n#define SINF 10007\n#define CO 1000007\n#define INF 1000000007\n#define BIG 1000000931\n#define LARGE 1696969696967ll\n#define GIANT 2564008813937411ll\n#define LLINF 2696969696969696969ll\n#define MAXN 250013\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ld, ld> pdd;\n\nint N;\nint arr[MAXN];\npll S;\nlong long ans;\nunordered_map<ll, int> need;\n\nll expo(ll a, ll e, ll mod)\n{\n\tif (e == 0)\n\t{\n\t\treturn 1;\n\t}\n\tll was = expo(a, e / 2, mod);\n\tif (e % 2)\n\t{\n\t\treturn was * was % mod * a % mod;\n\t}\n\treturn was * was % mod;\n}\nll modinv(ll a, ll e)\n{\n\treturn expo(a, e - 2, e);\n}\npll INV = {modinv(CO, INF), modinv(CO, BIG)};\nvoid solve(int L, int R)\n{\n\tif (L == R)\n\t{\n\t\treturn;\n\t}\n\tneed.clear();\n\tint mid = (L + R) >> 1;\n\t//start from L...mid, end at mid + 1....R\n\tpair<pll, pll> trans = MP(MP(1, 0), MP(1, 0));\n\tfor (int i = mid + 1; i <= R; i++)\n\t{\n\t\tif (arr[i] == 0)\n\t\t{\n\t\t\ttrans.fi.fi *= INV.fi; trans.fi.fi %= INF;\n\t\t\ttrans.fi.se *= INV.fi; trans.fi.se %= INF;\n\t\t\ttrans.se.fi *= INV.se; trans.se.fi %= BIG;\n\t\t\ttrans.se.se *= INV.se; trans.se.se %= BIG;\n\t\t}\n\t\tif (arr[i] == 1)\n\t\t{\n\t\t\ttrans.fi.fi *= CO; trans.fi.fi %= INF;\n\t\t\ttrans.fi.se *= CO; trans.fi.se %= INF;\n\t\t\ttrans.se.fi *= CO; trans.se.fi %= BIG;\n\t\t\ttrans.se.se *= CO; trans.se.se %= BIG;\n\t\t}\n\t\tif (arr[i] == 2)\n\t\t{\n\t\t\ttrans.fi.se++; nmod(trans.fi.se, INF);\n\t\t\ttrans.se.se++; nmod(trans.se.se, BIG);\n\t\t}\n\t\tif (arr[i] == 3)\n\t\t{\n\t\t\ttrans.fi.se--; trans.fi.se += INF; nmod(trans.fi.se, INF);\n\t\t\ttrans.se.se--; trans.se.se += BIG; nmod(trans.se.se, BIG);\n\t\t}\n\t\tpll dif = {(S.fi - trans.fi.se) * modinv(trans.fi.fi, INF), (S.se - trans.se.se) * modinv(trans.se.fi, BIG)};\n\t\tdif.fi %= INF; dif.fi += INF; nmod(dif.fi, INF);\n\t\tdif.se %= BIG; dif.se += BIG; nmod(dif.se, BIG);\n\t\tneed[dif.fi * BIG + dif.se]++;\n\t}\n\ttrans = MP(MP(1, 0), MP(1, 0));\n\tfor (int i = mid; i >= L; i--)\n\t{\n\t\tif (arr[i] == 0)\n\t\t{\n\t\t\ttrans.fi.fi *= INV.fi; trans.fi.fi %= INF;\n\t\t\ttrans.se.fi *= INV.se; trans.se.fi %= BIG;\n\t\t}\n\t\tif (arr[i] == 1)\n\t\t{\n\t\t\ttrans.fi.fi *= CO; trans.fi.fi %= INF;\n\t\t\ttrans.se.fi *= CO; trans.se.fi %= BIG;\n\t\t}\n\t\tif (arr[i] == 2)\n\t\t{\n\t\t\ttrans.fi.se += trans.fi.fi; nmod(trans.fi.se, INF);\n\t\t\ttrans.se.se += trans.se.fi; nmod(trans.se.se, BIG);\n\t\t}\n\t\tif (arr[i] == 3)\n\t\t{\n\t\t\ttrans.fi.se -= trans.fi.fi; trans.fi.se += INF; nmod(trans.fi.se, INF);\n\t\t\ttrans.se.se -= trans.se.fi;\ttrans.se.se += BIG; nmod(trans.se.se, BIG);\n\t\t}\n\t\tans += need[trans.fi.se * BIG + trans.se.se];\n\t}\n\tsolve(L, mid);\n\tsolve(mid + 1, R);\n}\n\nint32_t main()\n{\n\tios_base::sync_with_stdio(0);\n\t// cout << fixed << setprecision(10);\n\t// cerr << fixed << setprecision(10);\n\t// freopen (\"file.in\", \"r\", stdin);\n\t// freopen (\"file.out\", \"w\", stdout);\n\tcin >> N;\n\tstring temps;\n\tcin >> temps;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (temps[i] == '<')\n\t\t{\n\t\t\tarr[i] = 0;\n\t\t}\n\t\tif (temps[i] == '>')\n\t\t{\n\t\t\tarr[i] = 1;\n\t\t}\n\t\tif (temps[i] == '+')\n\t\t{\n\t\t\tarr[i] = 2;\n\t\t}\n\t\tif (temps[i] == '-')\n\t\t{\n\t\t\tarr[i] = 3;\n\t\t}\n\t}\n\treverse(arr, arr + N);\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (arr[i] == 0)\n\t\t{\n\t\t\tS.fi *= INV.fi; S.fi %= INF;\n\t\t\tS.se *= INV.se; S.se %= BIG;\n\t\t}\n\t\tif (arr[i] == 1)\n\t\t{\n\t\t\tS.fi *= CO; S.fi %= INF;\n\t\t\tS.se *= CO; S.se %= BIG;\n\t\t}\n\t\tif (arr[i] == 2)\n\t\t{\n\t\t\tS.fi++; nmod(S.fi, INF);\n\t\t\tS.se++; nmod(S.se, BIG);\n\t\t}\n\t\tif (arr[i] == 3)\n\t\t{\n\t\t\tS.fi--; S.fi += INF; nmod(S.fi, INF);\n\t\t\tS.se--; S.se += BIG; nmod(S.se, BIG);\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (arr[i] == 0)\n\t\t{\n\t\t\tif (S == MP(0ll, 0ll)) ans++;\n\t\t}\n\t\tif (arr[i] == 1)\n\t\t{\n\t\t\tif (S == MP(0ll, 0ll)) ans++;\n\t\t}\n\t\tif (arr[i] == 2)\n\t\t{\n\t\t\tif (S == MP(1ll, 1ll)) ans++;\n\t\t}\n\t\tif (arr[i] == 3)\n\t\t{\n\t\t\tif (S == MP((ll) INF - 1, (ll) BIG - 1)) ans++;\n\t\t}\n\t}\n\tsolve(0, N - 1);\n\tcout << ans << '\\n';\n\t//when u <, the # divides by co\n\t//when u >, the # mults by co\n\t//when u +, u add the #\n\t//when u -, u subtract the #\n\t// cerr << \"time elapsed = \" << (clock() / (CLOCKS_PER_SEC / 1000)) << \" ms\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int mod=1e9+7;\nmt19937 ran(time(nullptr));\ninline int get_mod(int x){\n\treturn x<mod?x:x-mod;\n}\nstruct Hasher{\n\tint v,v2;\n\tHasher(int _v=0,int _v2=0):v(_v),v2(_v2){}\n\tinline Hasher operator+(const Hasher& rhs) const{\n\t\treturn Hasher(get_mod(v+rhs.v),get_mod(v2+rhs.v2));\n\t}\n\tinline Hasher operator-(const Hasher& rhs) const{\n\t\treturn Hasher(get_mod(v+mod-rhs.v),get_mod(v2+mod-rhs.v2));\n\t}\n\tinline Hasher operator*(const Hasher& rhs) const{\n\t\treturn Hasher((ll)v*rhs.v%mod,(ll)v2*rhs.v2%mod);\n\t}\n\tinline bool operator<(const Hasher& rhs) const{\n\t\treturn v!=rhs.v?v<rhs.v:v2<rhs.v2;\n\t}\n\tinline bool operator==(const Hasher& rhs) const{\n\t\treturn v==rhs.v && v2==rhs.v2;\n\t}\n} mul_pow[500010],inv_pow[500010],mul=Hasher(ran()%mod,ran()%mod),hash_v[250010];\nmap<Hasher,int> dic;\nchar str[250010];\ninline Hasher qpow(Hasher base,int pw){\n\tHasher res=Hasher(1,1);\n\twhile(pw){\n\t\tif(pw&1) res=res*base;\n\t\tbase=base*base;\n\t\tpw>>=1;\n\t}\n\treturn res;\n}\nint main(){\n\tint n;\n\tscanf(\"%d%s\",&n,str+1);\n\tmul_pow[0]=Hasher(1,1);\n\tHasher mul_inv=qpow(mul,mod-2);\n\tfor(int i=1;i<=2*n;i++){\n\t\tmul_pow[i]=mul_pow[i-1]*mul;\n\t\tinv_pow[i]=inv_pow[i-1]*mul_inv;\n\t}\n\tint pos=n;\n\tll ans=0;\n\tfor(int i=1;i<=n;i++){\n\t\tif(str[i]=='+'){\n\t\t\thash_v[i]=hash_v[i-1]+mul_pow[pos];\n\t\t}else if(str[i]=='-'){\n\t\t\thash_v[i]=hash_v[i-1]-mul_pow[pos];\n\t\t}else if(str[i]=='>'){\n\t\t\tpos++;\n\t\t\thash_v[i]=hash_v[i-1];\n\t\t}else if(str[i]=='<'){\n\t\t\tpos--;\n\t\t\thash_v[i]=hash_v[i-1];\n\t\t}\n\t}\n\tpos=n;\n\tfor(int i=1;i<=n;i++){\n\t\tif(hash_v[i]==hash_v[n]) ans++;\n\t\tif(str[i]=='>') pos++;\n\t\telse if(str[i]=='<') pos--;\n\t\tans+=dic[hash_v[i]];\n\t\tif(pos<n)\n\t\t\tdic[hash_v[n]*inv_pow[n-pos]+hash_v[i]]++;\n\t\telse\n\t\t\tdic[hash_v[n]*mul_pow[pos-n]+hash_v[i]]++;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 250001,M = 1e9 + 9,M1 = 1e9 + 7,b = 103,b1 = 11;\nint cs[N],cs1[N],p[N],p1[N],n;\nmap<pair<int,int>,int>mp;\nvoid add(int &a,int b){\n\ta+=b;\n\tif(a >= M)a-=M;\n\tif(a < 0)a+=M;\n}\nvoid add1(int &a,int b){\n\ta+=b;\n\tif(a >= M)a-=M1;\n\tif(a < 0)a+=M1;\n}\nint power(int base,int to){\n\tint ret = 1;\n\twhile(to){\n\t\tif(to&1)ret = ret*1LL*base%M;\n\t\tto>>=1;\n\t\tbase = base*1LL*base%M;\n\t}\n\treturn ret;\n}\nint power(int base,int to){\n\tint ret = 1;\n\twhile(to){\n\t\tif(to&1)ret = ret*1LL*base%M1;\n\t\tto>>=1;\n\t\tbase = base*1LL*base%M1;\n\t}\n\treturn ret;\n}\nint main(){\n//\tfreopen(\"readin.txt\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tp[0] = p1[0] = 1;\n\tchar c;\n\tint inv = power(b,M - 2),inv1 = power1(b1,M1 - 2);\n\tfor(int i = 1;i <= n;i++){\n\t\tscanf(\" %c\",&c);\n\t\tcs[i] = cs[i - 1];\n\t\tp[i] = p[i - 1];\n\t\tcs1[i] = cs1[i - 1];\n\t\tp1[i] = p1[i - 1];\n\t\tif(c == '+')add(cs[i],p[i]),add1(cs1[i],p1[i]);\n\t\telse if(c == '-')add(cs[i],-p[i]),add1(cs1[i],-p1[i]);\n\t\telse if(c == '>')p[i] = p[i]*1LL*b%M,p1[i] = p1[i]*1LL*b1%M1;\n\t\telse if(c == '<')p[i] = p[i]*1LL*inv%M,p1[i] = p1[i]*1LL*inv1%M1;\n\t}\n\tlong long ans = 0;\n\tfor(int i = 0;i <= n;i++){\n\t\tans+=mp[{cs[i],cs1[i]}];\n\t\tmp[{(cs[n]*1LL*p[i] + cs[i] + M)%M,(cs1[n]*1LL*p1[i] + cs1[i] + M1)%M1}]++;\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 250001,M = 1e9 + 7,b = 103;\nint cs[N],p[N],n;\nmap<int,int>mp;\nvoid add(int &a,int b){\n\ta+=b;\n\tif(a >= M)a-=M;\n\tif(a < 0)a+=M;\n}\nint power(int base,int to){\n\tint ret = 1;\n\twhile(to){\n\t\tif(to&1)ret = ret*1LL*base%M;\n\t\tto>>=1;\n\t\tbase = base*1LL*base%M;\n\t}\n\treturn ret;\n}\nint main(){\n\t//freopen(\"readin.txt\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tp[0] = 1;\n\tchar c;\n\tint inv = power(b,M - 2);\n\tfor(int i = 1;i <= n;i++){\n\t\tscanf(\" %c\",&c);\n\t\tcs[i] = cs[i - 1];\n\t\tp[i] = p[i - 1];\n\t\tif(c == '+')add(cs[i],p[i]);\n\t\telse if(c == '-')add(cs[i],-p[i]);\n\t\telse if(c == '>')p[i] = p[i]*1LL*b%M;\n\t\telse if(c == '<')p[i] = p[i]*1LL*inv%M;\n\t}\n\tlong long ans = 0;\n\tmp[cs[n]] = 1;\n\tfor(int i = 1;i <= n;i++){\n\t\tans+=mp[cs[i]];\n\t\tmp[(cs[n]*1LL*p[i] + cs[i] + M)%M]++;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000087;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\ntypedef pair<int, bool> sP;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef pair<ll, ll> LP;\ntypedef vector<ll> vec;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef vector<vector<ll>> mat;\ntypedef vector<ll> vec;\n\nll r = 998244853;\nll mod_pow(ll x, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n % 2)res = res * x%mod;\n\t\tx = x * x%mod; n >>= 1;\n\t}\n\treturn res;\n}\nll invr = mod_pow(r, mod-2);\n\nll tr[300000];\nll invtr[300000];\nvoid init() {\n\ttr[0] = invtr[0] = 1;\n\trep(i, 299999) {\n\t\ttr[i + 1] = tr[i] * r%mod;\n\t\tinvtr[i + 1] = invtr[i] * invr%mod;\n\t}\n}\n\nvoid solve() {\n\tint n; cin >> n;\n\tstring s; cin >> s;\n\tll sum = 0; int loc = 0;\n\tvector<ll> memo(n);\n\tvector<int> locs(n);\n\trep(i, n) {\n\t\tif (s[i] == '>')loc++;\n\t\telse if (s[i] == '<')loc--;\n\t\telse if (s[i] == '+') {\n\t\t\tif (loc >= 0) {\n\t\t\t\tsum += tr[loc];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsum += invtr[-loc];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (loc >= 0) {\n\t\t\t\tsum -= tr[loc];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsum -= invtr[-loc];\n\t\t\t}\n\t\t}\n\t\tsum = (sum%mod + mod) % mod;\n\t\tmemo[i] = sum;\n\t\tlocs[i] = loc;\n\t}\n\tll all = sum;\n\t//cout << all << endl;\n\tll ans = 0;\n\tmap<ll, int> mp;\n\tmp[all]++;\n\trep(i, n) {\n\t\t//cout << mp[memo[i]] << endl;\n\t\tans += mp[memo[i]];\n\t\tll nex = all;\n\t\tif (nex < 0)nex += mod;\n\t\tif (locs[i] >= 0) {\n\t\t\tnex = nex * tr[locs[i]] % mod;\n\t\t}\n\t\telse {\n\t\t\tnex = nex * invtr[-locs[i]] % mod;\n\t\t}\n\t\tnex += memo[i];\n\t\tnex %= mod;\n\t\tmp[nex]++;\n\t}\n\tcout << ans << endl;\n}\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(7);\n\tinit();\n\t//output_tree(10);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<map>\nusing namespace std;\ntypedef long long ll;\nconst ll mod=1000000000000000031ll,b=1000000000000000003ll,rb=821428571428571454ll;\nll mul(ll a,ll b){return(__int128)a*b%mod;}\nll ad(ll a,ll b){return(a+b)%mod;}\nchar s[250010];\nll p[250010],st[250010];\nmap<ll,int>m;\nint main(){\n\tint n,i;\n\tll ans;\n\tscanf(\"%d%s\",&n,s+1);\n\tp[0]=1;\n\tfor(i=1;i<=n;i++){\n\t\tp[i]=p[i-1];\n\t\tst[i]=st[i-1];\n\t\tswitch(s[i]){\n\t\t\tcase'+':st[i]=ad(st[i],p[i]);break;\n\t\t\tcase'-':st[i]=ad(st[i],mod-p[i]);break;\n\t\t\tcase'>':p[i]=mul(p[i],b);break;\n\t\t\tcase'<':p[i]=mul(p[i],rb);break;\n\t\t}\n\t}\n\tans=0;\n\tfor(i=n;i>0;i--){\n\t\tm[st[i]]++;\n\t\tans+=m[ad(mul(st[n],p[i-1]),st[i-1])];\n\t}\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (rint i = 1; i <= (n); i ++)\n#define re0(i, n) for (rint i = 0; i < (int) n; i ++)\n#define travel(i, u) for (rint i = head[u]; i; i = e[i].nxt)\n#define rint register int\nusing namespace std;\n\ntypedef long long lo;\n\ntemplate<typename tp> inline void read(tp &x) {\n    x = 0; char c = getchar(); int f = 0;\n    for (; c < '0' || c > '9'; f |= c == '-', c = getchar());\n    for (; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar());\n    if (f) x = -x;\n}\n\nconst int MOD1 = 1e9 + 7;\nconst int MOD2 = 1e9 + 9;\nconst int base1 = 233;\nconst int base2 = 999;\nconst int N = 3e5 + 233;\nconst int DELTA = 1e7;\nint n, _pos[N];\nchar str[N]; \n\ninline int power(int a, int k, int MOD) {\n\tif (k < 0) k += MOD - 1;\n\tint ans = 1;\n\tfor (; k; k >>= 1, a = (lo) a * a % MOD)\n\t\tif (k & 1) ans = (lo) ans * a % MOD;\n\treturn ans;\n}\n\nstruct val_t {\n\tint w1, w2;\n\tval_t (int w1 = 0, int w2 = 0) : w1(w1), w2(w2) {}\n\tinline void Set(int x, int t) {\n\t\tx += DELTA;\n\t\t(w1 += (lo) power(base1, x, MOD1) * (MOD1 + t) % MOD1) %= MOD1;\n\t\t// (w2 += (lo) power(base2, x, MOD2) * (MOD2 + t) % MOD2) %= MOD2;\n\t}\n\tval_t rot(int d) {\n\t\tval_t a = *this;\n\t\ta.w1 = (lo) a.w1 * power(base1, d, MOD1) % MOD1;\n\t\t// a.w2 = (lo) a.w2 * power(base2, d, MOD2) % MOD2;\n\t\treturn a;\n\t}\n};\nval_t val[N];\nmap <val_t, int> mp;\n\nval_t operator + (val_t a, val_t b) {\n\treturn val_t((a.w1 + b.w1) % MOD1, (a.w2 + b.w2) % MOD2);\n}\n\nbool operator < (val_t a, val_t b) {\n\treturn make_pair(a.w1, a.w2) < make_pair(b.w1, b.w2);\n}\n\nint main(void) {\n\tread(n);\n\tscanf(\"%s\", str + 1);\n\tint pos = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tval[i] = val[i - 1];\n\t\tif (str[i] == '+' || str[i] == '-')\n\t\t\tval[i].Set(pos, str[i] == '+' ? 1 : -1);\n\t\telse \n\t\t\tpos += str[i] == '>' ? 1 : -1;\n\t\t_pos[i] = pos;\n\t}\n\tval_t S = val[n];\n\tlo ans = 0;\n\tfor (int i = n; i >= 0; i--) {\n\t\tval_t to = S.rot(_pos[i]) + val[i];\n\t\tif (mp.count(to)) ans += mp[to];\n\t\tmp[val[i]]++;\n\t}\n\tcout << ans << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<map>\nusing namespace std;\ntypedef long long ll;\nll m1 = 1000000007, m2 = 998244353;\nll t1 = 555522277, t2 = 895612782;\nll p1[505050], p2[505050];\nll ip1[505050], ip2[505050];\ntypedef pair<ll, ll>pii;\nll po(ll a, ll b, ll m)\n{\n\tif (b == 0)return 1;\n\tll z = po(a, b / 2, m);\n\tz = z*z%m;\n\tif (b & 1)z = z*a%m;\n\treturn z;\n}\nll inv(ll a, ll m)\n{\n\treturn po(a, m - 2, m);\n}\nint main()\n{\n\tint num;\n\tscanf(\"%d\", &num);\n\tstring s;\n\tcin >> s;\n\tp1[0] = p2[0] = ip1[0] = ip2[0] = 1;\n\tfor (int i = 0; i < 505000; i++)p1[i + 1] = p1[i] * t1%m1, p2[i + 1] = p2[i] * t2%m2;\n\tll it1 = inv(t1, m1), it2 = inv(t2, m2);\n\tfor (int i = 0; i < 505000; i++)ip1[i + 1] = ip1[i] * it1%m1, ip2[i + 1] = ip2[i] * it2%m2;\n\tll n1 = 0, n2 = 0;\n\tvector<pii>v;\n\tvector<int>pl;\n\tv.push_back(make_pair(0, 0));\n\tpl.push_back(num + 10);\n\tint now = num + 10;\n\tfor (int i = 0; i < num; i++)\n\t{\n\t\tif (s[i] == '+')n1 = (n1 + p1[now]) % m1, n2 = (n2 + p2[now]) % m2;\n\t\telse if (s[i] == '-')n1 = (n1 + m1 - p1[now]) % m1, n2 = (n2 + m2 - p2[now]) % m2;\n\t\telse if (s[i] == '>')now++;\n\t\telse now--;\n\t\tv.push_back(make_pair(n1, n2)), pl.push_back(now);\n\t}\n\tll ans = 0;\n\tmap<pii, int>ma;\n\tfor (int i = num; i >= 0; i--)\n\t{\n\t\tint dif = pl[i] - (num + 10);\n\t\tll mk1, mk2;\n\t\tif (dif >= 0)mk1 = (v[i].first + n1*p1[dif]) % m1, mk2 = (v[i].second + n2*p2[dif]) % m2;\n\t\telse mk1 = (v[i].first + n1*ip1[-dif]) % m1, mk2 = (v[i].second + n2*ip2[-dif]) % m2;\n\t\tans += ma[make_pair(mk1, mk2)];\n\t\tma[v[i]]++;\n\t}\n\tprintf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define dbg1(x) cerr<<#x<<\"=\"<<(x)<<\" \"\n#define dbg2(x) cerr<<#x<<\"=\"<<(x)<<\"\\n\"\n#define dbg3(x) cerr<<#x<<\"\\n\"\nusing namespace std;\n#define reg register\nconst int MN=250005;\nint N;\nchar s[MN];\nconst int P=998244353;\nint Add(int x,int y){return (x+y)%P;}\nint Mul(int x,int y){return (1ll*x*y)%P;}\nconst int B[]={691,769,823,877,911,967},\ninv[]={37560569,983965175,992179685,349442436,115055606,356147158};\nstruct node\n{\n\tint v[6];\n\tint& operator [](int x){return v[x];}\n\tbool operator <(const node o)const\n\t{\n\t\tfor(int i=0;i<6;++i)if(v[i]!=o.v[i])return v[i]<o.v[i];\n\t\treturn false;\n\t}\n\tbool operator ==(const node o)const\n\t{\n\t\tfor(int i=0;i<6;++i)if(v[i]!=o.v[i])return false;\n\t\treturn true;\n\t}\n}pre[MN],all;\nstd::map<node,int> Mp;\nint pos[MN],nm[6][MN<<1],cal[MN];\nnode get(node x,node y,int p)\n{\n\tfor(int j=0;j<6;++j)\n\t\tx[j]=Add(x[j],Mul(y[j],nm[j][p]));\n\treturn x;\n}\nint main()\n{\n\tscanf(\"%d%s\",&N,s+1);\n\treg int i,j,k;\n\tfor(j=0;j<6;++j)for(nm[j][MN]=i=1;i<=N;++i)\n\t\tnm[j][i+MN]=Mul(nm[j][i-1+MN],B[j]),\n\t\tnm[j][-i+MN]=Mul(nm[j][-i+1+MN],inv[j]);\n\tfor(k=j=0;j<6;++j,k=0)for(i=1;i<=N;++i)\n\t{\n\t\tswitch(s[i])\n\t\t{\n\t\t\tcase '<':--k;break;\n\t\t\tcase '>':++k;break;\n\t\t\tcase '+':all[j]=Add(all[j],nm[j][k+MN]);break;\n\t\t\tcase '-':all[j]=Add(all[j],P-nm[j][k+MN]);break;\n\t\t}\n\t\tpos[i]=k;pre[i][j]=all[j];\n\t}\n\t++Mp[all];\n\tfor(i=1;i<=N;++i)\n\t\tcal[i]=Mp[pre[i]],\n\t\t++Mp[get(pre[i],all,pos[i]+MN)];\n\tll ans=0;\n\tfor(i=1;i<=N;++i) ans+=cal[i];\n\treturn 0*printf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef unsigned long long ull;\n#define mp make_pair\n\nconst int K = 2;\nll MODS[K] = {(ll)1e9 + 7, (ll)1e9 + 9};\n\nll bin_pow(ll x, ll p, ll mm) {\n\tif (p == 0) return 1;\n\tif (p & 1) return (x * bin_pow(x, p - 1, mm)) % mm;\n\tll y = bin_pow(x, p / 2, mm);\n\treturn (y * y) % mm;\n}\n\nstruct PolyHash {\n\tll x[K];\n\n\tPolyHash() : x() {}\n\tPolyHash(ll Z) {\n\t\tfor (int i = 0; i < K; i++)\n\t\t\tx[i] = Z % MODS[i];\n\t}\n\n\tPolyHash operator + (const PolyHash &H) const {\n\t\tPolyHash res = PolyHash();\n\t\tfor (int i = 0; i < K; i++) {\n\t\t\tres.x[i] = (x[i] + H.x[i]) % MODS[i];\n\t\t}\n\t\treturn res;\n\t}\n\n\tPolyHash operator - (const PolyHash &H) const {\n\t\tPolyHash res = PolyHash();\n\t\tfor (int i = 0; i < K; i++) {\n\t\t\tres.x[i] = (x[i] - H.x[i]) % MODS[i];\n\t\t}\n\t\treturn res;\n\t}\n\n\tPolyHash operator * (const PolyHash &H) const {\n\t\tPolyHash res = PolyHash();\n\t\tfor (int i = 0; i < K; i++) {\n\t\t\tres.x[i] = (x[i] * H.x[i]) % MODS[i];\n\t\t}\n\t\treturn res;\n\t}\n\n\tbool operator < (const PolyHash &H) const {\n\t\tfor (int i = 0; i < K; i++) {\n\t\t\tif (x[i] != H.x[i])\n\t\t\t\treturn x[i] < H.x[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nconst int N = 500500;\nconst int M = N / 2;\nPolyHash pw[N];\nPolyHash a[N], b[N];\nint c[N];\nchar s[N];\nint L;\nmap<PolyHash, ll> mapchik;\n\nvoid precalc() {\n\tpw[M] = PolyHash(1);\n\tpw[M + 1] = PolyHash(1234567);\n\tpw[M - 1].x[0] = bin_pow(1234567, MODS[0] - 2, MODS[0]);\n\tpw[M - 1].x[1] = bin_pow(1234567, MODS[1] - 2, MODS[1]);\n\tfor (int i = M + 2; i < N; i++)\n\t\tpw[i] = pw[i - 1] * pw[M + 1];\n\tfor (int i = M - 2; i >= 0; i--)\n\t\tpw[i] = pw[i + 1] * pw[M - 1];\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tprecalc();\n\n\tscanf(\"%d %s\", &L, s);\n\tint pos = M;\n\ta[0] = 0;\n\tc[0] = pos;\n\tfor (int i = 0; i < L; i++) {\n\t\ta[i + 1] = a[i];\n\t\tif (s[i] == '+') {\n\t\t\ta[i + 1] = a[i + 1] + pw[pos];\n\t\t} else if (s[i] == '-') {\n\t\t\ta[i + 1] = a[i + 1] - pw[pos];\n\t\t} else if (s[i] == '>') {\n\t\t\tpos++;\n\t\t} else if (s[i] == '<') {\n\t\t\tpos--;\n\t\t} else throw;\n\t\tc[i + 1] = pos;\n\t}\n\tb[L] = 0;\n\tfor (int i = L - 1; i >= 0; i--) {\n\t\tb[i] = b[i + 1];\n\t\tif (s[i] == '+') {\n\t\t\tb[i] = b[i] + pw[pos];\n\t\t} else if (s[i] == '-') {\n\t\t\tb[i] = b[i] - pw[pos];\n\t\t} else if (s[i] == '>') {\n\t\t\tpos--;\n\t\t} else if (s[i] == '<') {\n\t\t\tpos++;\n\t\t} else throw;\n\t}\n\n\tPolyHash H = a[L];\n\n/*\n\tfor (int i = 0; i <= L; i++)\n\t\tprintf(\"%llu \", a[i]);\n\tprintf(\"\\n\");\n\tfor (int i = 0; i <= L; i++)\n\t\tprintf(\"%llu \", b[i]);\n\tprintf(\"\\n\");\n*/\n\tll ans = 0;\n\tfor (int i = L; i >= 0; i--) {\n\t\tPolyHash Z = H - H * pw[c[i]] - a[i];\n\t\tans += mapchik[Z];\n\t\tmapchik[b[i]]++;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define ull unsigned long long\n\nconst int Maxv = 1000010; \nconst ull Prime1 = 259; \nconst ull Prime2 = 213668850274628011; \n                            \nint idx[Maxv], n; \nlong long ans; \null Hash[Maxv], val[Maxv]; \nchar s[Maxv]; \n\nstd::map<ull, int> Map; \n\ninline void PreHandle() {\n    val[n] = 1; \n    for (int i = n + 1; i <= (n << 1); i++)\n        val[i] = val[i - 1] * Prime1; \n    for (int i = n - 1; i >= 0; i--)\n        val[i] = val[i + 1] * Prime2; \n}\n\nint main() {\n    scanf(\"%d\", &n); \n    scanf(\"%s\", s); \n\n    PreHandle(); \n\n    for (int i = 0; i < n; i++) {\n        Hash[i + 1] = Hash[i]; \n        idx[i + 1] = idx[i]; \n\n        if (s[i] == '>')\n            idx[i + 1]++; \n        if (s[i] == '<')\n            idx[i + 1]--;\n        if (s[i] == '+')\n            Hash[i + 1] += val[n + idx[i + 1]]; \n        if (s[i] == '-')\n            Hash[i + 1] -= val[n + idx[i + 1]]; \n    }\n    \n    for (int i = n; i >= 0; i--) {\n        ull tmp = Hash[i] + Hash[n] * val[n + idx[i]];\n        ans += Map[tmp]; \n        Map[ Hash[i] ]++;\n    }\n\n    printf(\"%lld\\n\", ans);\n\n    return 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\nconst ll p=10000000000037;\nconst int base=250001;\nunordered_map<ll,int> mp;\nint n,dig[250005];\nll pw[250005]={1},hsh[250005],ans;\nchar s[250005];\nll qpow(__int128 a,ll b){\n    ll res=1;\n    while(b){\n        if(b&1)\n            res=res*a%p;\n        a=a*a%p;\n        b>>=1;\n    }\n    return res;\n}\nll power(ll x){\n    return x>=0?pw[x]:qpow(pw[-x],p-2);\n}\nint main(){\n    ios::sync_with_stdio(false);\n    ll val;\n    int i;\n    cin>>n>>s+1;\n    for(i=1;i<=n;i++)\n        pw[i]=pw[i-1]*base%p;\n    for(i=1;i<=n;i++){\n        switch(s[i]){\n            case '+':\n                dig[i]=dig[i-1];\n                hsh[i]=(hsh[i-1]+power(dig[i]))%p;\n                break;\n            case '-':\n                dig[i]=dig[i-1];\n                hsh[i]=(hsh[i-1]-power(dig[i])+p)%p;\n                break;\n            case '<':\n                dig[i]=dig[i-1]+1;\n                hsh[i]=hsh[i-1];\n                break;\n            case '>':\n                dig[i]=dig[i-1]-1;\n                hsh[i]=hsh[i-1];\n        }\n    }\n    for(i=0;i<=n;i++){\n        if(mp.count(hsh[i]))\n            ans+=mp[hsh[i]];\n        val=(hsh[i]+hsh[n]*power(dig[i]))%p;\n        if(mp.count(val))\n            mp[val]++;\n        else\n            mp[val]=1;\n    }\n    cout<<ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define P(x) {if (debug) cout << x << endl;}\n#define H(x) P(#x << \": \" << (x))\n#define FR(i,a,b) for (int i=(a); i<(b); i++)\n#define F(i,n) FR(i,0,n)\n#define DR(i,a,b) for (int i=(b); i-->(a);)\n#define D(i,n) DR(i,0,n)\n#define S(s) (int)(s).size()\n#define ALL(v) v.begin(), v.end()\n#define MI(a,v) a = min(a,v)\n#define MA(a,v) a = max(a,v)\n#define V vector\n#define pb push_back\n#define mt make_tuple\nusing namespace std;\ntemplate<class T> ostream &operator<<(ostream &os, V<T> v) {\n    F(i,S(v)) os<<(i?\" \":\"\")<<v[i];\n    return os;\n}\nconst bool debug = 0;\n\nconst int A=92821, PHI=9223372036854775807, N=250005, OFF=N;\n\nint fp(int a, int b) {\n    if (b == 0) return 1;\n    int rt = fp(a, b/2);\n    if (b%2) return rt*rt*a;\n    else return rt*rt;\n}\n\nV<int> _mem(2*OFF);\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n    int B = fp(A, PHI);\n    H(B) H(A*B)\n    int n; cin>>n;\n    string s; cin>>s;\n    int *p = &_mem[OFF];\n    p[0] = 1;\n    F(i,n) {\n        p[i+1] = p[i]*A;\n        p[-i-1] = p[-i]*B;\n    }\n    V<int> pos(n+1), val(n+1);\n    pos[0] = val[0] = 0;\n    F(i,n) {\n        pos[i+1] = pos[i];\n        val[i+1] = val[i];\n        if (s[i] == '+') {\n            val[i+1] += p[pos[i]];\n        } else if (s[i] == '-') {\n            val[i+1] -= p[pos[i]];\n        } else if (s[i] == '>') {\n            pos[i+1]++;\n        } else {\n            pos[i+1]--;\n        }\n    }\n    map<int,int> occ;\n    occ[val[n]]++;\n    int tot = 0;\n    D(i,n) {\n        int goal = val[n] * p[pos[i]] + val[i];\n        tot += occ[goal];\n        occ[val[i]]++;\n    }\n    cout<<tot<<\"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <cstdio>\n\nusing namespace std;\n \n#define rep(i, n) for (int i = 0; i < (int) n; i++)\n \nconst int MOD = 1e9 + 7;\nconst int B = 3456789;\n\nlong long Pow(long long a, long long x) {\n        long long res = 1;\n        while (x > 0) {\n                if (x & 1) res = res * a % MOD;\n                a = a * a % MOD;\n                x >>= 1;\n        }\n        return res;\n}\n\nlong long Inv(long long a) { return Pow(a, MOD - 2); }\n \nint main() {\n\tint n;\n        scanf(\"%d\", &n);\n\tstring s;\n        cin >> s;\n\tint x = 250000;\n        long long h = 0;\n\tvector<int> xs(n + 1);\n        xs[0] = x;\n\tvector<long long> hs(n + 1);\n        hs[0] = h;\n\trep(i, n) {\n\t\tchar c = s[i];\n\t\tif (c == '+') h = (h + Pow(B, x)) % MOD;\n\t\tif (c == '-') h = (h - Pow(B, x) + MOD) % MOD;\n\t\tif (c == '>') x ++;\n\t\tif (c == '<') x --;\n\t\txs[i + 1] = x;\n                hs[i + 1] = h;\n\t}\n\tmap<long long, int> mp;\n\tlong long ans = 0;\n\tfor (int i = n; i >= 0; i--) {\n\t\tint dx = xs[i] - xs[0];\n\t\tlong long coef = (dx >= 0 ? Pow(B, dx) : Inv(Pow(B, -dx)));\n\t\tlong long hoge = (hs[i] + hs[n] * coef) % MOD;\n\t\tans += mp[hoge];\n\t\tmp[hs[i]]++;\n\t}\n        printf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconst int mod1 = 1e9 + 7, mod2 = 1e9 + 9;\nconst int MN = 250010;\nconst int P = 1e6 + 7;\n\nint exp(int x, int n, int mod) {\n    int ret = 1;\n    while(n) {\n        if(n & 1) ret = 1LL * ret * x % mod;\n        x = 1LL * x * x % mod;\n        n >>= 1;\n    }\n    return ret;\n}\nint inv(int x, int mod) {\n    return exp(x, mod - 2, mod);\n}\nint po1[MN << 1], po2[MN << 1];\n\nint N;\nchar S[MN];\nint A[MN << 1];\nmap<pii, int> cnt;\n\nint main() {\n    po1[0] = 1;\n    for(int i = 1; i < (MN << 1); i++) {\n        po1[i] = 1LL * po1[i - 1] * P % mod1;\n    }\n    po2[0] = 1;\n    for(int i = 1; i < (MN << 1); i++) {\n        po2[i] = 1LL * po2[i - 1] * P % mod2;\n    }\n\n    scanf(\"%d\", &N);\n\n    scanf(\"\\n\");\n    for(int i = 0; i < N; i++) {\n        scanf(\"%c\", &S[i]);\n    }\n\n    int pos = MN;\n    for(int i = 0; i < N; i++) {\n        if(S[i] == '+') A[pos]++;\n        if(S[i] == '-') A[pos]--;\n        if(S[i] == '<') pos--;\n        if(S[i] == '>') pos++;\n    }\n\n    int hval1 = 0;\n    int hval2 = 0;\n    for(int i = 0; i < (MN << 1); i++) {\n        hval1 += 1LL * (A[i] + mod1) % mod1 * po1[i] % mod1;\n        hval1 %= mod1;\n        hval2 += 1LL * (A[i] + mod2) % mod2 * po2[i] % mod2;\n        hval2 %= mod2;\n    }\n\n    int a1 = 1, b1 = 0;\n    int a2 = 1, b2 = 0;\n    ll ans = 0;\n    for(int i = N - 1; i >= 0; i--) {\n\n        int p1 = 1LL * (mod1 - b1) * inv(a1, mod1) % mod1;\n        int p2 = 1LL * (mod2 - b2) * inv(a2, mod2) % mod2;\n        cnt[ {p1, p2} ]++;\n\n        if(S[i] == '+') {\n            b1 += po1[MN];\n            b1 %= mod1;\n            b2 += po2[MN];\n            b2 %= mod2;\n        }\n        if(S[i] == '-') {\n            b1 += mod1 - po1[MN];\n            b1 %= mod1;\n            b2 += mod2 - po2[MN];\n            b2 %= mod2;\n        }\n        if(S[i] == '<') {\n            a1 = 1LL * a1 * inv(P, mod1) % mod1;\n            b1 = 1LL * b1 * inv(P, mod1) % mod1;\n            a2 = 1LL * a2 * inv(P, mod2) % mod2;\n            b2 = 1LL * b2 * inv(P, mod2) % mod2;\n        }\n        if(S[i] == '>') {\n            a1 = 1LL * a1 * P % mod1;\n            b1 = 1LL * b1 * P % mod1;\n            a2 = 1LL * a2 * P % mod2;\n            b2 = 1LL * b2 * P % mod2;\n        }\n\n        p1 = 1LL * (hval1 + mod1 - b1) * inv(a1, mod1) % mod1;\n        p2 = 1LL * (hval2 + mod2 - b2) * inv(a2, mod2) % mod2;\n        ans += cnt[ {p1, p2} ];\n    }\n\n    printf(\"%lld\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\n\nint N;\nstring S;\nll mo=1000000007;\nvector<ll> C,R;\nconst int PAT=5;\nvector<ll> A[PAT];\nvector<ll> B[PAT];\n\nll modpow(ll a, ll n = mo-2) {\n\tll r=1;a%=mo;\n\twhile(n) r=r*((n%2)?a:1)%mo,a=a*a%mo,n>>=1;\n\treturn r;\n}\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>S;\n\tsrand(time(NULL));\n\tFOR(i,PAT) {\n\t\tC.push_back(rand()%10000000+10000000);\n\t\tR.push_back(modpow(C.back()));\n\t\tA[i].push_back(1);\n\t\tB[i].push_back(0);\n\t}\n\treverse(ALL(S));\n\tFORR(c,S) {\n\t\tFOR(i,PAT) {\n\t\t\tif(c=='+') {\n\t\t\t\tA[i].push_back(A[i].back());\n\t\t\t\tB[i].push_back((B[i].back()+1)%mo);\n\t\t\t}\n\t\t\tif(c=='-') {\n\t\t\t\tA[i].push_back(A[i].back());\n\t\t\t\tB[i].push_back((B[i].back()+mo-1)%mo);\n\t\t\t}\n\t\t\tif(c=='>') {\n\t\t\t\tA[i].push_back(A[i].back()*R[i]%mo);\n\t\t\t\tB[i].push_back(B[i].back()*R[i]%mo);\n\t\t\t}\n\t\t\tif(c=='<') {\n\t\t\t\tA[i].push_back(A[i].back()*C[i]%mo);\n\t\t\t\tB[i].push_back(B[i].back()*C[i]%mo);\n\t\t\t}\n\t\t}\n\t}\n\tll ret=0;\n\tmap<vector<ll>,int> memo;\n\tmemo[vector<ll>(PAT,0)]++;\n\tFOR(j,N) {\n\t\tvector<ll> BA(PAT),BAS(PAT);\n\t\tFOR(i,PAT) {\n\t\t\tBA[i]=B[i][j+1]*modpow(A[i][j+1])%mo;\n\t\t\tBAS[i]=(B[i][j+1]+mo-B[i].back())*modpow(A[i][j+1])%mo;\n\t\t}\n\t\tret+=memo[BAS];\n\t\tmemo[BA]++;\n\t}\n\tcout<<ret<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define fst first\n#define snd second\n#define SZ(u) ((int) (u).size())\n#define ALL(u) (u).begin(), (u).end()\n\ninline void proc_status()\n{\n    ifstream t(\"/proc/self/status\");\n    cerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline T read()\n{\n\tregister T sum(0), fg(1);\n\tregister char ch(getchar());\n\tfor(; !isdigit(ch); ch = getchar()) if(ch == '-') fg = -1;\n\tfor(;  isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) - '0' + ch;\n\treturn sum * fg;\n}\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int, int> pii;\n\nconst int MAXN = (int) 2.5e5;\n\nint n;\n\nchar s[MAXN + 5];\n\ninline void input()\n{\n\tn = read<int>();\n\tscanf(\"%s\", s + 1);\n}\n\nconst int MOD = 998244353, B = (int) 233;\n\ninline int fpm(int x, int y)\n{\n\tint res = 1;\n\tfor(; y; y >>= 1, x = (LL) x * x % MOD) if(y & 1) res = (LL) res * x % MOD;\n\treturn res;\n}\n\ninline void solve()\n{\n\t// Thanks to zhou888\n\n\tstatic int p[MAXN + 5], prefix[MAXN + 5], p_pow[MAXN * 2 + 5];\n\n\tp_pow[0 + n] = 1;\n\tfor(int i = 1, invB = fpm(B, MOD - 2); i <= n; ++i)\n\t{\n\t\tp_pow[ i + n] = (LL) p_pow[ i - 1 + n] *\tB % MOD;\n\t\tp_pow[-i + n] = (LL) p_pow[-i + 1 + n] * invB % MOD;\n\t}\n\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tp[i] = p[i - 1], prefix[i] = prefix[i - 1];\n\t\tif(s[i] == '<') --p[i];\n\t\tif(s[i] == '>') ++p[i];\n\t\tif(s[i] == '+') (prefix[i] += p_pow[p[i] + n]) %= MOD;\n\t\tif(s[i] == '-') (prefix[i] -= p_pow[p[i] + n]) %= MOD;\n\t}\n\n\tstatic unordered_map<int, int> cnt;\n\n\tLL ans = 0;\n\tfor(int i = 1; i <= n; ++i) ans += prefix[i] == prefix[n];\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tans += cnt[(prefix[i] + MOD) % MOD];\n\t\tint res = (prefix[i] + (LL) p_pow[p[i] + n] * prefix[n] % MOD) % MOD;\n\t\t++cnt[(res + MOD) % MOD];\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main()\n{\n//\tfreopen(\"F.in\", \"r\", stdin);\n//\tfreopen(\"F.out\", \"w\", stdout);\n\n\tinput();\n\tsolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#ifndef BZ\n#pragma GCC optimize \"-O3\"\n#endif\n#include <bits/stdc++.h>\n\n#define FASTIO\n\n#ifdef FASTIO\n#define scanf abacaba\n#define printf abacaba\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\n\n\nll pw(ll a, ll b, ll MOD) {\n\tll ans = 1; while (b) {\n\t\twhile (!(b & 1)) b >>= 1, a = (a * a) % MOD;\n\t\tans = (ans * a) % MOD, --b;\n\t} return ans;\n}\nconst ll M1 = ll(1e9) + 7;\nconst ll M2 = ll(1e9) + 9;\n\nstruct hsh {\n\n\tll a, b;\n\thsh() {a = b = 0;}\n\thsh(ll x) {\n\t\ta = x % M1;\n\t\tb = x % M2;\n\t}\n\thsh(ll A, ll B) {\n\t\ta = A % M1;\n\t\tb = B % M2;\n\t}\n\thsh operator+(hsh x) {\n\t\treturn hsh(a + x.a, b + x.b);\n\t}\n\thsh operator-(hsh x) {\n\t\treturn hsh(a - x.a + M1, b - x.b + M2);\n\t}\n\thsh operator*(hsh x) {\n\t\treturn hsh(a * x.a % M1, b * x.b % M2);\n\t}\n\tll get() {\n\t\treturn a * M2 + b;\n\t}\n};\n\nhsh P = 1000003;\nhsh BP = hsh(pw(P.a, M1 - 2, M1), pw(P.b, M2 - 2, M2));\n\nint n;\nstring s;\n\nconst int MX = 3000000;\n\nint pos[MX];\n\nhsh hs[MX];\n\nhsh hst[MX];\n\nmap<ll, int> mm;\n\nint main() {\n#ifdef FASTIO\n\tios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n#endif\n\tcin >> n;\n\tcin >> s;\n\tpos[0] = 0;\n\thst[0] = 1;\n\tint cur = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\thst[i + 1] = hst[i];\n\t\tif (s[i] == '<')\n\t\t\t--cur, hst[i + 1] = hst[i + 1] * BP;\n\t\tif (s[i] == '>')\n\t\t\t++cur, hst[i + 1] = hst[i + 1] * P;\n\t\tpos[i + 1] = cur;\n\t}\n\ths[n] = 0;\n\tfor (int i = n - 1; i >= 0; --i) {\n\t\tif (s[i] == '+') {\n\t\t\ths[i] = hs[i + 1] + hst[i];\n\t\t}\n\t\telse if (s[i] == '-') {\n\t\t\ths[i] = hs[i + 1] - hst[i];\n\t\t}\n\t\telse {\n\t\t\ths[i] = hs[i + 1];\n\t\t}\n\t}\n\t++mm[hs[n].get()];\n\tll ans = 0;\n\tfor (int i = n - 1; i >= 0; --i) {\n\t\thsh rq = hs[i] - hs[0] * hst[i];\n\t\tans += mm[rq.get()];\n\t\t++mm[hs[i].get()];\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ri rd<int>\n#define rep(i, a, b) for (int i = (a), _ = (b); i <= _; ++i)\n#define per(i, a, b) for (int i = (a), _ = (b); i >= _; --i)\n#define For(i, a, b) for (int i = (a), _ = (b); i < _; ++i)\nconst int O1 = 1004535809;\nconst int O2 = 998244353;\nint O, W, _W;\nconst int maxN = 250007;\ntypedef long long LL;\n\ntemplate<class T> inline T rd() {\n\tbool f = 1; char c = getchar(); for (; !isdigit(c); c = getchar()) if (c == '-') f = 0;\n\tT x = 0; for (; isdigit(c); c = getchar()) x = x * 10 + c - '0'; return f ? x : -x;\n}\n\nint pwr(int x, int t) {\n\tint res = 1;\n\tfor (; t > 0; t >>= 1, x = 1LL * x * x % O)\n\t\tif (t & 1) res = 1LL * res * x % O;\n\treturn res;\n}\n\ninline int inv(int x) { return pwr(x, O-2); }\n\nint n;\nchar s[maxN];\nint ps[2][maxN], hsh[2][maxN];\n\nvoid init(int *ps, int *hsh) {\n\thsh[0] = 0, ps[0] = 1;\n\trep (i, 1, n) {\n\t\tif (s[i] == '+') {\n\t\t\tps[i] = ps[i-1];\n\t\t\thsh[i] = (hsh[i-1] + ps[i]) % O;\n\t\t}\n\t\telse if (s[i] == '-') {\n\t\t\tps[i] = ps[i-1];\n\t\t\thsh[i] = (hsh[i-1] + O - ps[i]) % O;\n\t\t}\n\t\telse if (s[i] == '<') {\n\t\t\tps[i] = 1LL * ps[i-1] * _W % O;\n\t\t\thsh[i] = hsh[i-1];\n\t\t}\n\t\telse if (s[i] == '>') {\n\t\t\tps[i] = 1LL * ps[i-1] * W % O;\n\t\t\thsh[i] = hsh[i-1];\n\t\t}\n\t\telse assert(false);\n\t}\n}\n\nvoid solve() {\n\tmap<pair<int, int>, int> mp;\n\tLL res = 0;\n\trep (i, 0, n) {\n\t\tif (i > 0) res += mp[pair<int,int>(hsh[0][i], hsh[1][i])];\n\t\tif (i < n) ++mp[pair<int,int>((hsh[0][i] + 1LL * hsh[0][n] * ps[0][i]) % O1, (hsh[1][i] + 1LL * hsh[1][n] * ps[1][i]) % O2)];\n\t}\n\tprintf(\"%lld\\n\", res);\n}\n\nint main() {\n\n\tn = ri();\n\tscanf(\"%s\", s+1);\n\n\tO = O1, W = 131, _W = inv(W);\n\tinit(ps[0], hsh[0]);\n\tO = O2, W = 1000003, _W = inv(W);\n\tinit(ps[1], hsh[1]);\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <unordered_map>\n#define int long long\nusing namespace std;\nconst int N = 3e5 + 5;\nconst int mod[2] = {999988679, 999988609}, b[2] = {370728, 370732}, ib[2] = {396903752, 462741403};\nint read() {\n\tint x = 0, f = 1; char ch;\n\twhile(! isdigit(ch = getchar())) (ch == '-') && (f = -f);\n\tfor(x = ch ^ 48; isdigit(ch = getchar()); x = (x << 3) + (x << 1) + (ch ^ 48));\n\treturn x * f;\n}\ntemplate <class T> T Max(T a, T b) { return a > b ? a : b; }\ntemplate <class T> T Min(T a, T b) { return a < b ? a : b; }\nchar s[N];\nint n, ans, a[2][N], d[2][N];\nunordered_map <int, int> t;\nsigned main() {\n\tn = read(); scanf(\"%s\", s + 1);\n\tfor(int j = 0; j <= 1; ++ j) a[j][0] = 0, d[j][0] = 1;\n\tfor(int i = 1, v[2] = {1, 1}; i <= n; ++ i) {\n\t\tfor(int j = 0; j <= 1; ++ j) {\n\t\t\ta[j][i] = a[j][i - 1];\n\t\t\tif(s[i] == '+') a[j][i] = (a[j][i] + v[j]) % mod[j];\n\t\t\tif(s[i] == '-') a[j][i] = (a[j][i] + mod[j] - v[j]) % mod[j];\n\t\t\tif(s[i] == '>') v[j] = v[j] * b[j] % mod[j];\n\t\t\tif(s[i] == '<') v[j] = v[j] * ib[j] % mod[j];\n\t\t\td[j][i] = v[j];\n\t\t}\n\t}\n\tfor(int i = n; i >= 0; -- i) {\n\t\tans += t[(a[0][i] + a[0][n] * d[0][i]) % mod[0] + (a[1][i] + a[1][n] * d[1][i]) % mod[1] * mod[0]];\n\t\t++ t[a[0][i] + a[1][i] * mod[0]];\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <map>\n#include <list>\n#include <iterator>\n#include <set>\n#include <queue>\n#include <iostream>\n#include <sstream>\n#include <stack>\n#include <deque>\n#include <cmath>\n#include <memory.h>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <algorithm>\n#include <utility>\n#include <time.h>\n#include <bitset>\n#include <assert.h>\n#include <complex.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(int i=(a)-1;i>=(b);--i)\n#define FILL(A,val) memset(A,val,sizeof(A))\n\n#define ALL(V) V.begin(),V.end()\n#define SZ(V) (int)V.size()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long Int;\ntypedef unsigned long long UInt;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double Pi = acos(-1.0);\nconst int INF = 1000000000;\nconst Int INF2 = Int(INF) * 5000;\nconst Int INF3 = Int(INF) * INF;\nconst int MAX = 510007;\nconst int MAXE = 2007000;\nconst int MAXV = 5000;\nconst int BASE = 1000000000;\nconst int ST = 1000000007;\n\nconst int MOD1 = 1000000007;\nconst int MOD2 = 1234567891;\n\nint p = 1000003;\n\nInt H1[MAX];\nInt H2[MAX];\nint delta[MAX];\n\n\nInt pw1[MAX];\nInt pw2[MAX];\n\nint main()\n{\n    //freopen(\"in.txt\", \"r\", stdin);\n    \n    pw1[0] = 1;\n    pw2[0] = 1;\n    FOR(i,1,MAX)\n    {\n        pw1[i] = pw1[i - 1] * p % MOD1;\n        pw2[i] = pw2[i - 1] * p % MOD2;\n    }\n    \n    int n;\n    cin >> n;\n    string s;\n    cin >> s;\n    \n    H1[0] = 0;\n    H2[0] = 0;\n    delta[0] = n + 1;\n    \n    FOR(i,0,n)\n    {\n        H1[i + 1] = H1[i];\n        H2[i + 1] = H2[i];\n        delta[i + 1] += delta[i];\n        \n        if (s[i] == '<')\n        {\n            delta[i + 1] --;\n        }\n        if (s[i] == '>')\n        {\n            delta[i + 1] ++;\n        }\n        \n        if (s[i] == '+')\n        {\n            H1[i + 1] += pw1[delta[i + 1]];\n            H1[i + 1] %= MOD1;\n            \n            H2[i + 1] += pw2[delta[i + 1]];\n            H2[i + 1] %= MOD2;\n        }\n        \n        if (s[i] == '-')\n        {\n            H1[i + 1] += MOD1 - pw1[delta[i + 1]];\n            H1[i + 1] %= MOD1;\n            \n            H2[i + 1] += MOD2 - pw2[delta[i + 1]];\n            H2[i + 1] %= MOD2;\n        }\n        \n    }\n    \n    int res = 0;\n    \n    map<pair<Int, Int> , int> M;\n   \n    \n    \n    \n    RFOR(i,n,0)\n    {\n        M[MP(H1[i + 1] * pw1[n] % MOD1 , H2[i + 1] * pw2[n] % MOD2)] ++;\n        Int h1 = (H1[n] * pw1[delta[i] - delta[0] + n] + H1[i] * pw1[n]) % MOD1;\n        Int h2 = (H2[n] * pw2[delta[i] - delta[0] + n] + H2[i] * pw2[n]) % MOD2;\n        res += M[MP(h1,h2)];\n    }\n    \n    cout << res << endl;\n    \n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000009;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\ntypedef pair<int, bool> sP;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef pair<ll, ll> LP;\ntypedef vector<ll> vec;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef vector<vector<ll>> mat;\ntypedef vector<ll> vec;\n\nll r = 998244353;\nll mod_pow(ll x, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n % 2)res = res * x%mod;\n\t\tx = x * x%mod; n >>= 1;\n\t}\n\treturn res;\n}\nll invr = mod_pow(r, mod);\n\nll tr[300000];\nll invtr[300000];\nvoid init() {\n\ttr[0] = invtr[0] = 1;\n\trep(i, 299999) {\n\t\ttr[i + 1] = tr[i] * r%mod;\n\t\tinvtr[i + 1] = invtr[i] * invr%mod;\n\t}\n}\n\nvoid solve() {\n\tint n; cin >> n;\n\tstring s; cin >> s;\n\tll sum = 0; int loc = 0;\n\tvector<ll> memo(n);\n\tvector<int> locs(n);\n\trep(i, n) {\n\t\tif (s[i] == '>')loc++;\n\t\telse if (s[i] == '<')loc--;\n\t\telse if (s[i] == '+') {\n\t\t\tif (loc >= 0) {\n\t\t\t\tsum += tr[loc];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsum += invtr[-loc];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (loc >= 0) {\n\t\t\t\tsum -= tr[loc];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsum -= invtr[-loc];\n\t\t\t}\n\t\t}\n\t\tsum = (sum%mod + mod) % mod;\n\t\tmemo[i] = sum;\n\t\tlocs[i] = loc;\n\t}\n\tll all = sum;\n\t//cout << all << endl;\n\tll ans = 0;\n\tmap<ll, int> mp;\n\tmp[all]++;\n\trep(i, n) {\n\t\t//cout << mp[memo[i]] << endl;\n\t\tans += mp[memo[i]];\n\t\tll nex = all;\n\t\tif (nex < 0)nex += mod;\n\t\tif (locs[i] >= 0) {\n\t\t\tnex = nex * tr[locs[i]] % mod;\n\t\t}\n\t\telse {\n\t\t\tnex = nex * invtr[-locs[i]] % mod;\n\t\t}\n\t\tnex += memo[i];\n\t\tnex %= mod;\n\t\tmp[nex]++;\n\t}\n\tcout << ans << endl;\n}\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(7);\n\tinit();\n\t//output_tree(10);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) std::cerr << #x << \" = \" << (x) << std::endl\nusing ll = long long;\nstd::mt19937 mt{std::random_device{}()};\ntemplate <typename T>\nconstexpr std::pair<T, T> extgcd(const T a, const T b)\n{\n    if (b == 0) { return std::pair<T, T>{1, 0}; }\n    const auto p = extgcd(b, a % b);\n    return {p.second, p.first - p.second * (a / b)};\n}\ntemplate <typename T>\nconstexpr T inverse(const T a, const T mod) { return (mod + extgcd(a, mod).first % mod) % mod; }\nconstexpr int H = 10;  //関数値サンプルの個数\nconstexpr ll MOD1 = 1000000007LL, MOD2 = 1000000009LL;\nconstexpr ll X[H] = {2371983LL, 1231LL, 123123LL, 4329075LL, 134121LL, 231788LL, 12234LL, 9218739LL, 912380LL, 556LL};\nconstexpr ll XINV1[H] = {inverse(X[0], MOD1), inverse(X[1], MOD1), inverse(X[2], MOD1), inverse(X[3], MOD1), inverse(X[4], MOD1), inverse(X[5], MOD1), inverse(X[6], MOD1), inverse(X[7], MOD1), inverse(X[8], MOD1), inverse(X[9], MOD1)};\nconstexpr ll XINV2[H] = {inverse(X[0], MOD2), inverse(X[1], MOD2), inverse(X[2], MOD2), inverse(X[3], MOD2), inverse(X[4], MOD2), inverse(X[5], MOD2), inverse(X[6], MOD2), inverse(X[7], MOD2), inverse(X[8], MOD2), inverse(X[9], MOD2)};\ntemplate <typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, const std::pair<S, T>& p) { return (os << \"<\" << p.first << \",\" << p.second << \">\"); }\ntemplate <typename T, typename A>\nstd::ostream& operator<<(std::ostream& os, const std::vector<T, A>& v)\n{\n    os << \"[\";\n    for (const auto& p : v) { os << p << \",\"; }\n    return (os << \"]\\n\");\n}\nint main()\n{\n    int N;\n    std::string S;\n    std::cin >> N >> S;\n    using P = std::pair<ll, ll>;\n    std::vector<int> deg(N + 1, 0);\n    std::vector<std::vector<P>> value(N + 1, std::vector<P>(H, {0LL, 0LL}));\n    auto plus = [](const P& p1, const P& p2) { return P{(p1.first + p2.first) % MOD1, (p1.second + p2.second) % MOD2}; };\n    auto minus = [](const P& p1, const P& p2) { return P{(p1.first + MOD1 - p2.first) % MOD1, (p1.second + MOD2 - p2.second) % MOD2}; };\n    auto rshift = [](const P& p, const int i) { return P{p.first * X[i] % MOD1, p.second * X[i] % MOD2}; };\n    auto lshift = [](const P& p, const int i) { return P{p.first * XINV1[i] % MOD1, p.second * XINV2[i] % MOD2}; };\n    auto mul = [](const P& p1, const P& p2) { return P{p1.first * p2.first % MOD1, p1.second * p2.second % MOD2}; };\n    for (int i = N - 1; i >= 0; i--) {\n        if (S[i] == '-') {\n            deg[i] = deg[i + 1];\n            for (int j = 0; j < H; j++) { value[i][j] = minus(value[i + 1][j], {1, 1}); }\n        } else if (S[i] == '+') {\n            deg[i] = deg[i + 1];\n            for (int j = 0; j < H; j++) { value[i][j] = plus(value[i + 1][j], {1, 1}); }\n        } else if (S[i] == '>') {\n            deg[i] = deg[i + 1] + 1;\n            for (int j = 0; j < H; j++) { value[i][j] = rshift(value[i + 1][j], j); }\n        } else {\n            deg[i] = deg[i + 1] - 1;\n            for (int j = 0; j < H; j++) { value[i][j] = lshift(value[i + 1][j], j); }\n        }\n    }\n    // show(deg);\n    // show(value);\n    constexpr int L = 250000;\n    std::vector<std::vector<P>> power(L + 1, std::vector<P>(H, {1, 1}));\n    std::vector<std::vector<P>> invpower(L + 1, std::vector<P>(H, {1, 1}));\n    auto invp = [&](const int i, const int j) { return i >= 0 ? invpower[i][j] : power[-i][j]; };\n    for (int i = 1; i <= L; i++) {\n        for (int j = 0; j < H; j++) { power[i][j] = rshift(power[i - 1][j], j), invpower[i][j] = lshift(power[i - 1][j], j); }\n    }\n    std::vector<P> answer(H);\n    for (int i = 0; i < H; i++) { answer[i] = value[0][i]; }\n    //show(answer);\n    std::vector<std::vector<P>> hash(N + 1, std::vector<P>(H));\n    for (int i = 0; i <= N; i++) {\n        for (int j = 0; j < H; j++) { hash[i][j] = mul(minus(value[i][j], answer[j]), invp(deg[i], j)); }\n    }\n    //    show(hash);\n    using VP = std::vector<P>;\n    std::map<VP, ll> mp;\n    ll ans = 0;\n    for (int i = 0; i <= N; i++) {\n        std::vector<P> obj(H);\n        for (int j = 0; j < H; j++) { obj[j] = plus(hash[i][j], mul(invp(deg[i], j), answer[j])); }\n        if (mp.find(obj) != mp.end()) { ans += mp[obj]; }\n        mp[hash[i]]++;\n    }\n    std::cout << ans << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define pb push_back\n#define eb emplace_back\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\n    os<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\n    os<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\ninline ll mod_inverse(ll a, ll m){\n    ll b = m, u = 1, v = 0;\n    while (b) {\n        ll t = a / b;\n        swap(a -= t * b, b);\n        swap(u -= t * v, v);\n    }\n    return (u % m + m) % m;\n}\n\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000021;\n\nconst ll B = 10007;\nconst ll iB = mod_inverse(10007, MOD);\n\nint T, n, m;\nstring s;\nint main(int argc, char *argv[]){\n    ios::sync_with_stdio(false);\n    cin >> n >> s;\n    ll h = 0, b = 1;\n    for (char c : s) {\n        if (c == '+') h = (h + b) % MOD;\n        if (c == '-') h = (h + MOD - b) % MOD;\n        if (c == '>') b = b * B % MOD;\n        if (c == '<') b = b * iB % MOD;\n    }\n    const ll target = h;\n    ll ans = 0;\n    map<ll, ll> mp;\n    mp[0] = 1;\n    h = 0; b = 1;\n    for (char c : s) {\n        if (c == '+') h = (h + b) % MOD;\n        if (c == '-') h = (h + MOD - b) % MOD;\n        if (c == '>') b = b * B % MOD;\n        if (c == '<') b = b * iB % MOD;\n\n        ans += mp[(h + MOD - target) % MOD];\n        mp[(h + target * b + MOD - target) % MOD] ++;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//teja349\n#include <bits/stdc++.h>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <utility>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <iomanip> \n//setbase - cout << setbase (16); cout << 100 << endl; Prints 64\n//setfill -   cout << setfill ('x') << setw (5); cout << 77 << endl; prints xxx77\n//setprecision - cout << setprecision (14) << f << endl; Prints x.xxxx\n//cout.precision(x)  cout<<fixed<<val;  // prints x digits after decimal in val\n\nusing namespace std;\n#define f(i,a,b) for(i=a;i<b;i++)\n#define rep(i,n) f(i,0,n)\n#define fd(i,a,b) for(i=a;i>=b;i--)\n#define pb push_back\n#define mp make_pair\n#define vi vector< int >\n#define vl vector< ll >\n#define ss second\n#define ff first\n#define ll long long\n#define pii pair< int,int >\n#define pll pair< ll,ll >\n#define sz(a) a.size()\n#define inf (1000*1000*1000+5)\n#define all(a) a.begin(),a.end()\n#define tri pair<int,pii>\n#define vii vector<pii>\n#define vll vector<pll>\n#define viii vector<tri>\n#define mod (1000*1000*1000+9)\n#define mod1 (1000*1000*1000+7)\n#define pqueue priority_queue< int >\n#define pdqueue priority_queue< int,vi ,greater< int > >\n\n//std::ios::sync_with_stdio(false);   \nll ans10[512345],ans13[512345],powe13[512345],powe10[512345],invpowe10[512345];\nll invpowe13[512345],inv[1234],p[512345];\nll extend_gcd(ll a,ll b,ll &x,ll &y){\n\tif(b==0){\n\t\tx=1;\n\t\ty=0;\n\t\treturn a;\n\t}\n\tll x1,y1;\n\tll ans =extend_gcd(b,a%b,x1,y1);\n\tx=y1;\n\ty=x1-(a/b)*y1;\n\n\treturn ans;\n}\nmap<ll,ll> seti10,seti13; \nint main(){\n    std::ios::sync_with_stdio(false);\n    ll n;\n    cin>>n;\n    string s;\n    cin>>s;\n    ll i;\n    ll initp=250003;\n    powe10[0]=1;\n    powe13[0]=1;\n    invpowe10[0]=1;\n    invpowe13[0]=1;\n    ll inv10,inv13;\n\n            ll x,y;\n            i=503803;\n        ll val=extend_gcd(mod,i,x,y);\n        if(y>0)\n            inv13=y%mod;\n        else{\n                inv13=(y+mod)%mod;\n        }\n        x,y;\n            i=500167;\n        val=extend_gcd(mod1,i,x,y);\n        if(y>0)\n            inv10=y%mod1;\n        else{\n                inv10=(y+mod1)%mod1;\n        }    \n\tf(i,1,512345){\n    \tpowe13[i]=powe13[i-1]*503803;\n    \tpowe10[i]=powe10[i-1]*500167;\n    \tpowe10[i]%=mod1;\n    \tpowe13[i]%=mod;\n    \tinvpowe10[i]=invpowe10[i-1]*inv10;\n    \tinvpowe10[i]%=mod1;\n    \tinvpowe13[i]=invpowe13[i-1]*inv13;\n    \tinvpowe13[i]%=mod;\n    }\n    ans10[0]=0;\n    ans13[0]=0;\n    p[0]=initp;\n    \n    f(i,1,s.length()+1){\n    \tans10[i]=ans10[i-1];\n    \tans13[i]=ans13[i-1];\n    \tp[i]=p[i-1];\n    \tif(s[i-1]=='+'){\n    \t\tans10[i]=ans10[i-1]+powe10[p[i]];\n    \t\tans13[i]=ans13[i-1]+powe13[p[i]];\n\n    \t}\n    \telse if(s[i-1]=='-'){\n    \t\tans10[i]=ans10[i-1]-powe10[p[i]];\n    \t\tans13[i]=ans13[i-1]-powe13[p[i]];\n    \t}\n    \telse if(s[i-1]=='<'){\n    \t\tp[i]--;\n    \t}\n    \telse{\n    \t\tp[i]++;\n    \t}\n    \tans10[i]%=mod1;\n    \tans10[i]+=mod1;\n    \tans10[i]%=mod1;\n    \tans13[i]%=mod;\n    \tans13[i]+=mod;\n    \tans13[i]%=mod;\n    \tseti13[ans13[i]]++;\n    \tseti10[ans10[i]]++;\n    \t//cout<<ans10[i]<<\" \"<<ans13[i]<<endl;\n    }\n    ll val1,j10,j13;\n    ll total=0;\n    f(i,1,n+1){\n    \tval=initp-p[i-1];\n    \tval*=-1;\n    \tif(val>=0){\n    \t\tval1=powe13[val];\n    \t\tval=powe10[val];\n    \t\t  \n    \t}\n    \telse{\n    \t\tval1=invpowe13[val];\n    \t\tval=invpowe10[val];\n    \t}\n    \tj10=ans10[n]*val;\n    \tj10%=mod1;\n    \tj10+=ans10[i-1];\n    \tj13=ans13[n]*val1;\n    \tj13%=mod;\n    \tj13+=ans13[i-1];\n    \tj10%=mod1;\n    \tj13%=mod;\n    \ttotal+=min(seti10[j10],seti13[j13]);\n        //assert(seti10[j10]==seti13[j13]);\n    \tseti13[ans13[i]]--;\n    \tseti10[ans10[i]]--;\n    }\n    cout<<total<<endl;\n\n\n\n\n    return 0;  \n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 250010;\nconst int mod[] = {1000000007, 1000000009};\nconst int P[] = {131, 233};\n\ntypedef long long LL;\n\nint Pow[2][N * 2]; char s[N];\n\ninline int FUCK(int x, int y, int mod) {\n    int res = 1;\n    for (; y; y >>= 1, x = (LL)x * x % mod) if (y & 1) res = (LL)res * x % mod;\n    return res;\n}\n\nstruct Data {\n    int val[2];\n\n    Data(int a = 0, int b = 0) {val[0] = a, val[1] = b;} \n\n    Data operator + (const Data &b) {\n        Data res;\n        res.val[0] = (val[0] + b.val[0]) % mod[0];\n        res.val[1] = (val[1] + b.val[1]) % mod[1];\n        return res;\n    }\n\n    Data operator - (const Data &b) {\n        Data res;\n        res.val[0] = (val[0] - b.val[0] + mod[0]) % mod[0];\n        res.val[1] = (val[1] - b.val[1] + mod[1]) % mod[1]; \n        return res;\n    }\n\n    Data operator * (const int b) {\n        Data res = *this;\n        int a = b >= 0 ? Pow[0][b] : FUCK(P[0], (LL)(mod[0] - 2) * (-b) % mod[0], mod[0]);\n        int c = b >= 0 ? Pow[1][b] : FUCK(P[1], (LL)(mod[1] - 2) * (-b) % mod[1], mod[1]);\n        res.val[0] = (LL)res.val[0] * a % mod[0];\n        res.val[1] = (LL)res.val[1] * c % mod[1];\n        return res;\n    }\n\n    bool operator < (const Data &b) const {\n        if (val[0] != b.val[0]) return val[0] < b.val[0];\n        return val[1] < b.val[1];\n    }\n};\n\nmap<Data, int> mp;\n\ninline void increase(Data &a, int b) {\n    a = a + (Data){Pow[0][b], Pow[1][b]};\n}\n\ninline void decrease(Data &a, int b) {\n    a = a - (Data){Pow[0][b], Pow[1][b]};\n}\n\nint main() {\n    int n; scanf(\"%d%s\", &n, s + 1); Data all;\n    Pow[0][0] = Pow[1][0] = 1;\n    for (int i = 0; i <= 1; i++)\n        for (int j = 1; j <= n * 2; j++)\n            Pow[i][j] = (LL)Pow[i][j - 1] * P[i] % mod[i];\n    for (int i = 1, ls = 0; i <= n; i++) {\n        if (s[i] == '<') ls--;\n        else if (s[i] == '>') ls++;\n        else if (s[i] == '+') increase(all, ls + n);\n        else decrease(all, ls + n);\n    }\n    Data fuck; mp[all] = 1; LL res = 0;\n    for (int i = 1, ls = 0; i <= n; i++) {\n        if (s[i] == '<') ls--;\n        else if (s[i] == '>') ls++;\n        else if (s[i] == '+') increase(fuck, ls + n);\n        else decrease(fuck, ls + n);\n        res += mp[fuck], mp[fuck + all * ls]++;\n    }\n    printf(\"%lld\\n\", res);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\nusing namespace std;\ntypedef unsigned long long ULL;\nconst int N=500010;\nconst ULL MOD=1000000000000000031ull,B=1000000000000000003ull,REVB=821428571428571454ull;\nint n;\nchar str[N];\nULL f[N],p[N];\nULL mul(ULL x,ULL y){\n\treturn (ULL)((__int128)x*y%MOD);\n}\nvoid readData(){\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",str+1);\n}\nmap<ULL,int> mp;\nvoid solve(){\n\tp[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tf[i]=f[i-1];\n\t\tp[i]=p[i-1];\n\t\tif(str[i]=='>')\n\t\t\tp[i]=mul(p[i],B);\n\t\telse if(str[i]=='<')\n\t\t\tp[i]=mul(p[i],REVB);\n\t\telse if(str[i]=='+')\n\t\t\t(f[i]+=p[i])%=MOD;\n\t\telse\n\t\t\t(f[i]-=p[i])%=MOD;\n\t}\n\tULL ans=0;\n\tfor(int i=n;i>=1;i--){\n\t\tmp[f[i]]++;\n\t\tans+=mp[(mul(f[n],p[i-1])+f[i-1])%MOD];\n\t}\n\tprintf(\"%llu\\n\",ans);\n}\nint main(){\n\treadData();\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define mod 998244353\nusing namespace std;\nint n,f[1001000],X,Y,ans;\nchar S[1001000];\nmap<int,int>mp;\nint quickpow(int x,int y){\n\tif(y==0)return 1;\n\tif(y%2==0)return quickpow(x*x%mod,y/2);\n\treturn quickpow(x*x%mod,y/2)*x%mod;\n}\nsigned main(){\n\tscanf(\"%lld%s\",&n,S+1);\n\tX=1;\n\tint base=10007,inv=quickpow(base,mod-2);\n\tfor(int i=1;i<=n;i++){\n\t\tif(S[i]=='+')f[i]=f[i-1]+X;\n\t\tif(S[i]=='-')f[i]=f[i-1]-X;\n\t\tif(S[i]=='<')f[i]=f[i-1],X=X*base%mod;\n\t\tif(S[i]=='>')f[i]=f[i-1],X=X*inv%mod;\n\t\tmp[f[i]]++;\t\t\n\t}\n\tX=1,Y=0;\n\tfor(int i=1;i<=n;i++){\n\t\tans=ans+mp[f[n]*X+Y];\n\t\tif(S[i]=='+')Y=Y+X;\n\t\tif(S[i]=='-')Y=Y-X;\n\t\tif(S[i]=='<')X=X*base%mod;\n\t\tif(S[i]=='>')X=X*inv%mod;\n\t\tmp[f[i]]--;\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cstdlib>\n#include <unordered_map>\nusing namespace std;\ntypedef long long ll;\n#define GG puts(\"FUCK\")\n#define N 500050\n#define mr(x,y) make_pair(x,y)\ninline char nc() {\n\tstatic char buf[100000],*p1,*p2;\n\treturn p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\nint rd() {\n\tint x=0; char s=nc();\n\twhile(s<'0'||s>'9') s=nc();\n\twhile(s>='0'&&s<='9') x=(x<<3)+(x<<1)+s-'0',s=nc();\n\treturn x;\n}\nchar rc() {\n\tchar s=nc();\n\twhile(s!='+'&&s!='-'&&s!='>'&&s!='<') s=nc();\n\treturn s;\n}\nint mod1=998244353,base1=19260817,inv1;\nint mod2=353448299,base2=20000003,inv2;\nint h1[N],mi1[N],imi1[N],p[N],n,C;\nint h2[N],mi2[N],imi2[N];\nunordered_map<pair<int,int>,int>mp;\nint qp(int x,int y,int p) {\n\tint re=1;\n\tfor(;y;y>>=1,x=ll(x)*x%p) if(y&1) re=ll(re)*x%p;\n\treturn re;\n}\nint main() {\n\tinv1=qp(base1,mod1-2,mod1);\n\tinv2=qp(base2,mod2-2,mod2);\n\tn=rd(); char str;\n\tint i;\n\tfor(mi1[0]=imi1[0]=mi2[0]=imi2[0]=i=1;i<=(n<<1);i++) {\n\t\tmi1[i]=ll(mi1[i-1])*base1%mod1;\n\t\timi1[i]=ll(imi1[i-1])*inv1%mod1;\n\t\tmi2[i]=ll(mi2[i-1])*base2%mod2;\n\t\timi2[i]=ll(imi2[i-1])*inv2%mod2;\n\t}\n\tp[0]=n;\n\tfor(i=1;i<=n;i++) {\n\t\tstr=rc();\n\t\tif(str=='+') {\n\t\t\tp[i]=p[i-1];\n\t\t\th1[i]=(h1[i-1]+mi1[p[i]])%mod1;\n\t\t\th2[i]=(h2[i-1]+mi2[p[i]])%mod2;\n\t\t}else if(str=='-') {\n\t\t\tp[i]=p[i-1];\n\t\t\th1[i]=(h1[i-1]-mi1[p[i]]+mod1)%mod1;\n\t\t\th2[i]=(h2[i-1]-mi2[p[i]]+mod2)%mod2;\n\t\t}else if(str=='>') {\n\t\t\tp[i]=p[i-1]+1;\n\t\t\th1[i]=h1[i-1]; h2[i]=h2[i-1];\n\t\t}else {\n\t\t\tp[i]=p[i-1]-1;\n\t\t\th1[i]=h1[i-1]; h2[i]=h2[i-1];\n\t\t}\n\t\tmp[mr(h1[i],h2[i])]++;\n\t}\n\tll ans=0;\n\tfor(i=1;i<=n;i++) {\n\t\tint d=p[i-1]-n,t1=h1[n],t2=h2[n];\n\t\tif(d>=0) t1=ll(t1)*mi1[d]%mod1,t2=ll(t2)*mi2[d]%mod2;\n\t\telse t1=ll(t1)*imi1[-d]%mod1,t2=ll(t2)*imi2[-d]%mod2;\n\t\tt1=(t1+h1[i-1])%mod1;\n\t\tt2=(t2+h2[i-1])%mod2;\n\t\tans+=mp[mr(t1,t2)];\n\t\tmp[mr(h1[i],h2[i])]--;\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<set>\n\ntypedef long long ll;\n\nconst int N=250010,MOD=1000000007,g=500002;\n\nll inv(int x){return (x==1 || x==-1)?x:(-(MOD/x)*inv(MOD%x)%MOD);}\n\nint t0[N*2],*pow;\n\nvoid initialize()\n{\n\tpow=t0+N;\n\n\tpow[0]=1;\n\tfor(int i=1;i<N;i++)\n\t\tpow[i]=(ll)pow[i-1]*g%MOD;\n\n\tint ig=(inv(g)+MOD)%MOD;\n\tfor(int i=0;i<N;i++)\n\t\tpow[-i-1]=(ll)pow[-i]*ig%MOD;\n}\n\nchar s[N];\nint ind[N],val[N],sum[N];\nint n;\n\nll ans;\n\nvoid prework()\n{\n\tint p=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tind[i]=p,val[i]=0;\n\n\t\tif(s[i]=='<')p--;\n\t\telse if(s[i]=='>')p++;\n\t\telse if(s[i]=='+')val[i]=pow[p];\n\t\telse val[i]=-pow[p];\n\t}\n\n\tfor(int i=1;i<=n;i++)\n\t\tsum[i]=((sum[i-1]+val[i])%MOD+MOD)%MOD;\n}\n\nstd::multiset<int> S;\n\nvoid solve()\n{\n\tans=0;\n\tfor(int i=n,x,y;i;i--)\n\t{\n\t\tS.insert(sum[i]);\n\n\t\tx=((ll)sum[n]*pow[ind[i]]%MOD+MOD)%MOD;\n\t\ty=((x+sum[i-1])%MOD+MOD)%MOD;\n\n\t\tans+=S.count(y);\n\t}\n}\n\nint main()\n{\n\tinitialize();\n\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",s+1);\n\n\tprework();\n\tsolve();\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nconst unsigned long long M=998244353;\nconst unsigned long long X=99469;\nunsigned long long R;\nconst int W=1500;\n \n \nunsigned long long ModPow(unsigned long long x, unsigned long long n, unsigned long long mod) {\n        unsigned long long ret = 1;\n        for (; n > 0; n /= 2, x = (x * x) % mod)\n            if ((n & 1) == 1) ret = (ret * x) % mod;\n        return ret;\n    }\n \nunsigned long long has=0,vec=1;\n \nint n;\nstring s;\nunordered_map<unsigned long long,int> B[550];\nlong long ans;\ninline void calc(char c, unsigned long long &u,unsigned long long &p){\n\tif(c=='+')u=(u+p)%M;\n\telse if(c=='-')u=(u+M-p)%M;\n\telse if(c=='>')p=(p*X)%M;\n\telse p=(p*R)%M;\n}\nint main(){\n\tR=ModPow(X,M-2,M);\n\tcin>>n>>s;\n    //n=250000;\n    //s=string(n,'+');\n\tfor(int i=0;i<n;i++)calc(s[i],has,vec);\n\tfor(int i=0;i<n;i++){\n\t\tif(i%W==0)continue;\n\t\tunsigned long long h=0,x=1;\n\t\tfor(int j=i;j<n;j++){\n\t\t\tif(j%W==0)break;\n\t\t\tcalc(s[j],h,x);\n\t\t\tif(h==has)ans++;\n\t\t}\n\t\tunsigned long long nh = (has+M-h)%M;\n\t\tnh = nh * ModPow(x,M-2,M)%M;\n\t\tB[i/W+1][nh]++;\n\t}\n\tfor(int i=0;i<n;i+=W){\n\t\tunsigned long long h=0,x=1;\n\t\tfor(int j=i;j<n;j++){\n\t\t\tcalc(s[j],h,x);\n\t\t\tif(h==has)ans++;\n\t\t\tauto it = B[i/W].find(h);\n\t\t\tif(it!=B[i/W].end())ans+=it->second;\n\t\t}\n\t}\n\t\n\tcout<<ans;\n \n \n}\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst unsigned long long M=998244353;\nconst unsigned long long X=99497;\nunsigned long long R;\nconst int W=1500;\n\n\nunsigned long long ModPow(unsigned long long x, unsigned long long n, unsigned long long mod) {\n        unsigned long long ret = 1;\n        for (; n > 0; n /= 2, x = (x * x) % mod)\n            if ((n & 1) == 1) ret = (ret * x) % mod;\n        return ret;\n    }\n\nunsigned long long has=0,vec=1;\n\nint n;\nstring s;\nunordered_map<unsigned long long,int> B[550];\nlong long ans;\ninline void calc(char c, unsigned long long &u,unsigned long long &p){\n\tif(c=='+')u=(u+p)%M;\n\telse if(c=='-')u=(u+M-p)%M;\n\telse if(c=='>')p=(p*X)%M;\n\telse p=(p*R)%M;\n}\nint main(){\n\tR=ModPow(X,M-2,M);\n\tcin>>n>>s;\n    //n=250000;\n    //s=string(n,'+');\n\tfor(int i=0;i<n;i++)calc(s[i],has,vec);\n\tfor(int i=0;i<n;i++){\n\t\tif(i%W==0)continue;\n\t\tunsigned long long h=0,x=1;\n\t\tfor(int j=i;j<n;j++){\n\t\t\tif(j%W==0)break;\n\t\t\tcalc(s[j],h,x);\n\t\t\tif(h==has)ans++;\n\t\t}\n\t\tunsigned long long nh = (has+M-h)%M;\n\t\tnh = nh * ModPow(x,M-2,M)%M;\n\t\tB[i/W+1][nh]++;\n\t}\n\tfor(int i=0;i<n;i+=W){\n\t\tunsigned long long h=0,x=1;\n\t\tfor(int j=i;j<n;j++){\n\t\t\tcalc(s[j],h,x);\n\t\t\tif(h==has)ans++;\n\t\t\tauto it = B[i/W].find(h);\n\t\t\tif(it!=B[i/W].end())ans+=it->second;\n\t\t}\n\t}\n\t\n\tcout<<ans;\n\n\n}\n提出情報\n提出日時"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<map>\nusing namespace std;\nstruct node{long long g1,g2,g3,g4,g5,g6/*,g7,g8*/;int p;};\nconst int p1=1000000007,p2=1000000009,p3=1000000021;\nlong long x1p1[510000],x1p2[510000],x1p3[510000],x2p1[510000],x2p2[510000],x2p3[510000]/*,x3p1[510000],x3p2[510000],x4p1[510000],x4p2[510000]*/;\ninline node operator+(node x,node y){return {(x.g1+y.g1*x1p1[x.p+250000])%p1,(x.g2+y.g2*x1p2[x.p+250000])%p2,(x.g3+y.g3*x1p3[x.p+250000])%p3,(x.g4+y.g4*x2p1[x.p+250000])%p1,(x.g5+y.g5*x2p2[x.p+250000])%p2,(x.g6+y.g6*x2p3[x.p+250000])%p3/*,(x.g5+y.g5*x3p1[x.p+250000])%p1,(x.g6+y.g6*x3p2[x.p+250000])%p2,(x.g7+y.g7*x4p1[x.p+250000])%p1,(x.g8+y.g8*x4p2[x.p+250000])%p2*/,x.p+y.p};}\nchar s[260000];\nmap<long long,map<long long,map<long long,map<long long,map<long long,map<long long/*,map<long long,map<long long*/,int/*>>*/>>>>>> M;\nint main()\n{\n\tx1p1[249999]=500000004;x1p1[250000]=1;x1p1[250001]=2;\n\tx1p2[249999]=500000005;x1p2[250000]=1;x1p2[250001]=2;\n\tx1p3[249999]=500000010;x1p3[250000]=1;x1p3[250001]=2;\n\tx2p1[249999]=666666671;x2p1[250000]=1;x2p1[250001]=3;\n\tx2p2[249999]=333333336;x2p2[250000]=1;x2p2[250001]=3;\n\tx2p3[249999]=333333340;x2p3[250000]=1;x2p3[250001]=3;\n\t/*x3p1[249999]=600000004;x3p1[250000]=1;x3p1[250001]=5;\n\tx3p2[249999]=800000007;x3p2[250000]=1;x3p2[250001]=5;\n\tx4p1[249999]=857142863;x4p1[250000]=1;x4p1[250001]=7;\n\tx4p2[249999]=142857144;x4p2[250000]=1;x4p2[250001]=7;*/\n\tfor(int i=249998;i>=0;i--)x1p1[i]=x1p1[i+1]*x1p1[249999]%p1,x1p2[i]=x1p2[i+1]*x1p2[249999]%p2,x1p3[i]=x1p3[i+1]*x1p3[249999]%p3,x2p1[i]=x2p1[i+1]*x2p1[249999]%p1,x2p2[i]=x2p2[i+1]*x2p2[249999]%p2,x2p3[i]=x2p3[i+1]*x2p3[249999]%p3/*,x3p1[i]=x3p1[i+1]*x3p1[249999]%p1,x3p2[i]=x3p2[i+1]*x3p2[249999]%p2,x4p1[i]=x4p1[i+1]*x4p1[249999]%p1,x4p2[i]=x4p2[i+1]*x4p2[249999]%p2*/;\n\tfor(int i=250002;i<=500000;i++)x1p1[i]=x1p1[i-1]*x1p1[250001]%p1,x1p2[i]=x1p2[i-1]*x1p2[250001]%p2,x1p3[i]=x1p3[i-1]*x1p3[250001]%p3,x2p1[i]=x2p1[i-1]*x2p1[250001]%p1,x2p2[i]=x2p2[i-1]*x2p2[250001]%p2,x2p3[i]=x2p3[i-1]*x2p3[250001]%p3/*,x3p1[i]=x3p1[i-1]*x3p1[250001]%p1,x3p2[i]=x3p2[i-1]*x3p2[250001]%p2,x4p1[i]=x4p1[i-1]*x4p1[250001]%p1,x4p2[i]=x4p2[i-1]*x4p2[250001]%p2*/;\n\tint n;scanf(\"%d%s\",&n,s+1);\n\tnode gs={0,0,0,0,0,0,0/*,0,0*/},pr={0,0,0,0,0,0,0/*,0,0*/};\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(s[i]=='+')gs.g1=(gs.g1+x1p1[gs.p+250000])%p1,gs.g2=(gs.g2+x1p2[gs.p+250000])%p2,gs.g3=(gs.g3+x1p3[gs.p+250000])%p3,gs.g4=(gs.g4+x2p1[gs.p+250000])%p1,gs.g5=(gs.g5+x2p2[gs.p+250000])%p2,gs.g6=(gs.g6+x2p3[gs.p+250000])%p3/*,gs.g5=(gs.g5+x3p1[gs.p+250000])%p1,gs.g6=(gs.g6+x3p2[gs.p+250000])%p2,gs.g7=(gs.g7+x4p1[gs.p+250000])%p1,gs.g8=(gs.g8+x4p2[gs.p+250000])%p2*/;\n\t\telse if(s[i]=='-')gs.g1=(gs.g1-x1p1[gs.p+250000]+p1)%p1,gs.g2=(gs.g2-x1p2[gs.p+250000]+p2)%p2,gs.g3=(gs.g3-x1p3[gs.p+250000]+p3)%p3,gs.g4=(gs.g4-x2p1[gs.p+250000]+p1)%p1,gs.g5=(gs.g5-x2p2[gs.p+250000]+p2)%p2,gs.g6=(gs.g6-x2p3[gs.p+250000]+p3)%p3/*,gs.g5=(gs.g5-x3p1[gs.p+250000]+p1)%p1,gs.g6=(gs.g6-x3p2[gs.p+250000]+p2)%p2,gs.g7=(gs.g7-x4p1[gs.p+250000]+p1)%p1,gs.g8=(gs.g8-x4p2[gs.p+250000]+p2)%p2*/;\n\t\telse if(s[i]=='>')gs.p++;\n\t\telse gs.p--;\n\t}\n\tlong long ss=0;\n\tnode rg=pr+gs;\n\tM[rg.g1][rg.g2][rg.g3][rg.g4][rg.g5][rg.g6]/*[rg.g7][rg.g8]*/++;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(s[i]=='+')pr.g1=(pr.g1+x1p1[pr.p+250000])%p1,pr.g2=(pr.g2+x1p2[pr.p+250000])%p2,pr.g3=(pr.g3+x1p3[pr.p+250000])%p3,pr.g4=(pr.g4+x2p1[pr.p+250000])%p1,pr.g5=(pr.g5+x2p2[pr.p+250000])%p2,pr.g6=(pr.g6+x2p3[pr.p+250000])%p3/*,pr.g5=(pr.g5+x3p1[pr.p+250000])%p1,pr.g6=(pr.g6+x3p2[pr.p+250000])%p2,pr.g7=(pr.g7+x4p1[pr.p+250000])%p1,pr.g8=(pr.g8+x4p2[pr.p+250000])%p2*/;\n\t\telse if(s[i]=='-')pr.g1=(pr.g1-x1p1[pr.p+250000]+p1)%p1,pr.g2=(pr.g2-x1p2[pr.p+250000]+p2)%p2,pr.g3=(pr.g3-x1p3[pr.p+250000]+p3)%p3,pr.g4=(pr.g4-x2p1[pr.p+250000]+p1)%p1,pr.g5=(pr.g5-x2p2[pr.p+250000]+p2)%p2,pr.g6=(pr.g6-x2p3[pr.p+250000]+p3)%p3/*,pr.g5=(pr.g5-x3p1[pr.p+250000]+p1)%p1,pr.g6=(pr.g6-x3p2[pr.p+250000]+p2)%p2,pr.g7=(pr.g7-x4p1[pr.p+250000]+p1)%p1,pr.g8=(pr.g8-x4p2[pr.p+250000]+p2)%p2*/;\n\t\telse if(s[i]=='>')pr.p++;\n\t\telse pr.p--;\n\t\tss=ss+M[pr.g1][pr.g2][pr.g3][pr.g4][pr.g5][pr.g6]/*[pr.g7][pr.g8]*/;\n\t\trg=pr+gs;\n\t\tM[rg.g1][rg.g2][rg.g3][rg.g4][rg.g5][rg.g6]/*[rg.g7][rg.g8]*/++;\n\t}\n\tprintf(\"%lld\\n\",ss);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cstdio>\n#include <iostream>\n\nusing namespace std ;\n\ntypedef long long LL ;\n\n\n#define mkp make_pair\n#define pll pair<LL, LL>\n\nconst LL B1 = 237ll ;\nconst LL B2 = 637ll ;\nconst int N = 300010 ;\nconst LL P1 = 998244353 ;\nconst LL P2 = 1004535809 ;\n\nint n ;\nLL ans ;\nchar s[N] ;\nLL I1, I2 ;\nLL g[N][2] ;\nLL S[N], T[N] ;\nmap <pll, LL> buc ;\n\nLL expow(LL a, LL b, LL p){\n    LL ret = 1 ;\n    while (b){\n        if (b & 1)\n            (ret *= a) %= p ;\n        (a *= a) %= p ; b >>= 1 ;\n    }\n    return ret ;\n}\nint main(){\n    cin >> n >> (s + 1) ;\n    g[0][0] = g[0][1] = 1ll ; \n    I1 = expow(B1, P1 - 2, P1) ;\n    I2 = expow(B2, P2 - 2, P2) ;\n    for (int i = 1 ; i <= n ; ++ i){\n        if (s[i] == '-'){\n            g[i][0] = g[i - 1][0] ;\n            g[i][1] = g[i - 1][1] ;\n            S[i] = (S[i - 1] - g[i][0] + P1) % P1 ;\n            T[i] = (T[i - 1] - g[i][1] + P2) % P2 ;\n        }\n        if (s[i] == '+'){\n            g[i][0] = g[i - 1][0] ;\n            g[i][1] = g[i - 1][1] ;\n            S[i] = (S[i - 1] + g[i][0]) % P1 ;\n            T[i] = (T[i - 1] + g[i][1]) % P2 ;\n        }\n        if (s[i] == '<'){\n            g[i][0] = g[i - 1][0] * I1 % P1 ;\n            g[i][1] = g[i - 1][1] * I2 % P2 ;\n            S[i] = S[i - 1] ; T[i] = T[i - 1] ;\n        }\n        if (s[i] == '>'){\n            g[i][0] = g[i - 1][0] * B1 % P1 ;\n            g[i][1] = g[i - 1][1] * B2 % P2 ;\n            S[i] = S[i - 1] ; T[i] = T[i - 1] ;\n        }\n\t\t++ buc[mkp(S[i], T[i])] ;\n    }\n    ++ buc[mkp(0, 0)] ; LL x, y ;\n    for (int i = 0 ; i < n ; ++ i){\n\t\tbuc[mkp(S[i] , T[i])] -- ; \n        x = (S[i] + S[n] * g[i][0] % P2) % P1 ; \n\t\ty = (T[i] + T[n] * g[i][1] % P2) % P2 ;\n        ans += buc[mkp(x, y)] ; \n    }\n    cout << ans << endl ; return 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N=2.5e5+5;\n\nint n;\nll h[3],w[3],ha[3],p[N][3],k[N][3],b[N][3];\nll base[3]={7,29,47},inv[3]={142857144,481911067,13933357},P[3]={1000000007,998244353,19260817};\nchar st[N];\n\nll pwr(ll x,ll y,ll P) {\n\tll z=1;\n\tfor(;y;y>>=1,x=x*x%P)\n\t\tif (y&1) z=z*x%P;\n\treturn z;\n}\n\nstruct Node{\n\tll h[3];\n\tfriend bool operator < (Node a,Node b) {\n\t\tfo(i,0,2) {\n\t\t\tif (a.h[i]<b.h[i]) return 1;\n\t\t\tif (a.h[i]>b.h[i]) return 0;\n\t\t}\n\t\treturn 0;\n\t}\n}a;\n\nmap<Node,int> mp;\n\nint main() {\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",st+1);\n\tfd(i,n,1) {\n\t\tfo(j,0,2) {\n\t\t\tif (st[i]=='+') h[j]=(h[j]+1)%P[j];\n\t\t\tif (st[i]=='-') h[j]=(h[j]+P[j]-1)%P[j];\n\t\t\tif (st[i]=='>') h[j]=h[j]*base[j]%P[j];\n\t\t\tif (st[i]=='<') h[j]=h[j]*inv[j]%P[j];\n\t\t}\n\t}\n\tfo(j,0,2) w[j]=1;\n\tfo(i,1,n) {\n\t\tfo(j,0,2) {\n\t\t\tp[i][j]=p[i-1][j];\n\t\t\tif (st[i]=='+') p[i][j]=(p[i][j]+w[j])%P[j];\n\t\t\tif (st[i]=='-') p[i][j]=(p[i][j]+P[j]-w[j])%P[j];\n\t\t\tif (st[i]=='>') w[j]=w[j]*base[j]%P[j];\n\t\t\tif (st[i]=='<') w[j]=w[j]*inv[j]%P[j];\n\t\t}\n\t}\n\tfo(j,0,2) k[0][j]=1;\n\tfo(i,1,n) {\n\t\tfo(j,0,2) {\n\t\t\tb[i][j]=b[i-1][j];k[i][j]=k[i-1][j];\n\t\t\tif (st[i]=='+') b[i][j]=(b[i][j]+P[j]-1)%P[j];\n\t\t\tif (st[i]=='-') b[i][j]=(b[i][j]+1)%P[j];\n\t\t\tif (st[i]=='>') b[i][j]=b[i][j]*inv[j]%P[j],k[i][j]=k[i][j]*base[j]%P[j];\n\t\t\tif (st[i]=='<') b[i][j]=b[i][j]*base[j]%P[j],k[i][j]=k[i][j]*inv[j]%P[j]; \n\t\t}\n\t}\n\tll ans=0;\n\tfd(i,n,1) {\n\t\tfo(j,0,2) a.h[j]=p[i][j];mp[a]++;\n\t\tfo(j,0,2) a.h[j]=(h[j]-b[i-1][j]+P[j])*k[i-1][j]%P[j];\n\t\tans+=mp[a];\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define LL long long\n#define PII pair<int, int>\n#define PLL pair<LL, LL>\n#define f first\n#define s second \nusing namespace std;\nconst int MAXN = 250005;\nconst LL M1 = 1000000009;\nconst LL M2 = 1000000007;\n\nLL qpow(LL a, LL pw, LL mod) {\n\tLL res = 1;\n\twhile (pw) {\n\t\tif (pw & 1) res = res * a % mod;\n\t\tpw >>= 1;\n\t\ta = a * a % mod;\n\t}\n\treturn res;\n}\n\nPLL norm(PLL p) {\n\treturn PLL((p.f % M1 + M1) % M1, (p.s % M2 + M2) % M2);\n}\n\nPLL neg(PLL p) {\n\treturn PLL(M1 - p.f, M2 - p.s);\n}\n\nPLL get_inv(PLL p) {\n\treturn PLL(qpow(p.f, M1 - 2, M1), qpow(p.s, M2 - 2, M2));\n}\n\nPLL mul(PLL p, PLL q) {\n\treturn PLL(p.f * q.f % M1, p.s * q.s % M2);\n}\n\nPLL add(PLL p, PLL q) {\n\treturn PLL((p.f + q.f) % M1, (p.s + q.s) % M2);\n}\n\nint n;\nstring s;\nPLL pw[2*MAXN], pinv[2*MAXN], pref[MAXN];\nLL pos[MAXN];\n\nint main() { \n\tios_base::sync_with_stdio(0); cin.tie(0);\n\n\tPLL base = PLL(1234567, 7654321), inv = get_inv(base);\n\tpw[0] = pinv[0] = {1, 1};\n\tfor (int i = 1; i < 2 * MAXN; i++) {\n\t\tpw[i] = mul(pw[i - 1], base);\n\t\tpinv[i] = mul(pinv[i - 1], inv);\n\t}\n\n\tcin >> n >> s;\n\tpref[0] = PLL(0, 0);\n\tpos[0] = n;\n\tmap<PLL, int> cnt;\n\tfor (int i = 1; i <= n; i++) {\n\t\tchar t = s[i - 1];\n\t\tpos[i] = pos[i - 1];\n\t\tpref[i] = pref[i - 1];\n\t\tif (t == '<') pos[i]--;\n\t\tif (t == '>') pos[i]++;\n\t\tif (t == '+') pref[i] = add(pref[i], pw[pos[i]]);\n\t\tif (t == '-') pref[i] = add(pref[i], neg(pw[pos[i]]));\n\t\tcnt[pref[i]]++;\n\t}\n\t\n\tLL ans = 0; \n\tPLL tgt = pref[n], mulf = PLL(1, 1), addf = PLL(0, 0);\n\tfor (int i = 1; i <= n; i++) {\n\t\tans += cnt[add(mul(get_inv(mulf), tgt), neg(mul(get_inv(mulf), addf)))];\n//\t\tcout << \"At \" << i << ' ' << cnt[add(mul(tgt, mulf), addf)] << '\\n';\n\t\t\n\t\tchar t = s[i - 1];\n\t\tcnt[pref[i]]--;\n\t\tif (t == '<') {\n\t\t\t// a *= base, b *= base\n\t\t\tmulf = mul(mulf, pw[1]);\n\t\t\taddf = mul(addf, pw[1]);\n\t\t}\n\t\tif (t == '>') {\n\t\t\t// a /= base, b /= base\n\t\t\tmulf = mul(mulf, pinv[1]);\n\t\t\taddf = mul(addf, pinv[1]);\n\t\t}\n\t\tif (t == '+') {\n\t\t\t// b -= pw[n]\n\t\t\taddf = add(addf, neg(pw[n]));\n\t\t}\n\t\tif (t == '-') {\n\t\t\t// b += pw[n]\n\t\t\taddf = add(addf, pw[n]);\n\t\t}\n\t}\n\t\n\tcout << ans << '\\n';\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n// #undef DEBUG\n// #define DEBUG\n/// {{{ DEBUG --- ///\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { if(&o == &cerr) { o << '{'; for(size_t i = 0; i < v.size(); i++) o << v[i] << (i + 1 != v.size() ? \", \" : \"\"); o << \"}\"; } else { for(size_t i = 0; i < v.size(); i++) o << v[i] << (i + 1 != v.size() ? \" \" : \"\"); } return o; }\n#ifdef DEBUG\n#ifdef USE_COUT\n#define dump(...) (cout<<\"[\"<<__LINE__<< \"] \"<<#__VA_ARGS__<<\" = \"<<make_tuple(__VA_ARGS__)<<\"\\n\")\n#else\n#define dump(...) (cerr<<\"[\"<<__LINE__<< \"] \"<<#__VA_ARGS__<<\" = \"<<make_tuple(__VA_ARGS__)<<\"\\n\")\n#endif\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\", \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream &o, tuple<T...> const &t){ o << \"(\"; _ot<0>(o, t); o << \")\"; return o; }\ntemplate<class T, class U> ostream & operator<<(ostream &o, pair<T, U> const &p) { o << \"(\" << p.first << \", \" << p.second << \")\"; return o; }\n#else\n#define dump(...) (0)\n#endif\n/// }}}--- ///\n\nll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a % b); }\nll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\nll extgcd(ll a, ll b, ll &x, ll &y) { ll d; return b == 0 ? (x = 1, y = 0, a) : (d = extgcd(b, a % b, y, x), y -= a / b * x, d); }\nll modinv(ll a, ll mod = 1e9 + 7) { ll x = 0, y = 0; extgcd(a, mod, x, y); return (x + mod) % mod; }\nll modpow(ll a, ll b, ll mod = 1e9 + 7) { ll r = 1; a %= mod; while(b) { if(b & 1) r = r * a % mod; a = a * a % mod; b >>= 1; } return r; }\n\nconst int N = 250000 + 10;\nconst ll mod = 1e9 + 7;\n// vector<ll> gen{114514, 1919, 810, -114514, -1919, -810};\nvector<ll> gen{114514, 1919, 810};\nvector<map<ll, int>> Aex(gen.size()), Bex = Aex;\nint n;\nstring s;\nint ms[N];\nll calc(int i, int c, ll x) {\n  if(i == 0) {\n    // A\n    if(c <= 1) return 1;\n    if(c == 2) return modinv(x, mod);\n    return x;\n  } else {\n    if(c == 0) return 1;\n    if(c == 1) return -1;\n    return 0;\n  }\n}\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  cin >> n >> s;\n  vector<vector<ll>> A(gen.size(), vector<ll>(n+2)), B = A;\n  for(int i = 0; i < n; i++) {\n    if(s[i] == '+') ms[i] = 0;\n    else if(s[i] == '-') ms[i] = 1;\n    else if(s[i] == '>') ms[i] = 2;\n    else ms[i] = 3;\n  }\n  for(int k = 0; k < gen.size(); k++) {\n    gen[k] = ((gen[k] % mod + mod) % mod);\n    ll x = gen[k];\n    A[k][1] = 1;\n    B[k][1] = 0;\n    for(int i = 0; i < n; i++) {\n      A[k][i+2] = A[k][i+1] * calc(0, ms[i], x) % mod;\n      B[k][i+2] = A[k][i+1] * calc(1, ms[i], x) % mod + B[k][i+1];\n      B[k][i+2] = ((B[k][i+2] % mod + mod) % mod);\n      Bex[k][B[k][i+2]]++;\n    }\n  }\n  // dump(A[0]);\n  // dump(B[0]);\n  ll ans = 0;\n  for(int i = 0; i < n; i++) {\n    ll mi = 1e18;\n    for(int k = 0; k < gen.size(); k++) {\n      ll c = A[k][i+1] * B[k][n+1] % mod;\n      c += B[k][i+1];\n      c %= mod;\n      ll cnt = Bex[k][c];\n      // dump(i, c, cnt);\n      // mi = min(mi, cnt);\n      if(cnt != mi) mi = min(mi, cnt);\n      else break;\n    }\n    for(int k = 0; k < gen.size(); k++) Bex[k][B[k][i+2]]--;\n    // dump(i, mi);\n    ans += mi;\n  }\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int mod=1e9+7;\nmt19937 ran(time(nullptr));\ninline int get_mod(int x){\n\treturn x<mod?x:x-mod;\n}\nstruct Hasher{\n\tint v,v2,v3,v4;\n\tHasher(int _v=0,int _v2=0,int _v3=0,int _v4=0):v(_v),v2(_v2),v3(_v3),v4(_v4){}\n\tinline Hasher operator+(const Hasher& rhs) const{\n\t\treturn Hasher(get_mod(v+rhs.v),get_mod(v2+rhs.v2),get_mod(v3+rhs.v3),get_mod(v4+rhs.v4));\n\t}\n\tinline Hasher operator-(const Hasher& rhs) const{\n\t\treturn Hasher(get_mod(v+mod-rhs.v),get_mod(v2+mod-rhs.v2),get_mod(v3+mod-rhs.v3),get_mod(v4+mod-rhs.v4));\n\t}\n\tinline Hasher operator*(const Hasher& rhs) const{\n\t\treturn Hasher((ll)v*rhs.v%mod,(ll)v2*rhs.v2%mod,(ll)v3*rhs.v3%mod,(ll)v4*rhs.v4%mod);\n\t}\n\tinline bool operator<(const Hasher& rhs) const{\n\t\treturn v!=rhs.v?v<rhs.v:(v2!=rhs.v2?v2<rhs.v2:(v3!=rhs.v3?v3<rhs.v3:v4<rhs.v4));\n\t}\n\tinline bool operator==(const Hasher& rhs) const{\n\t\treturn v==rhs.v && v2==rhs.v2 && v3==rhs.v3 && v4==rhs.v4;\n\t}\n} mul_pow[500010],inv_pow[500010],mul=Hasher(ran()%mod,ran()%mod,ran()%mod,ran()%mod),hash_v[250010];\nmap<Hasher,int> dic;\nchar str[250010];\ninline Hasher qpow(Hasher base,int pw){\n\tHasher res=Hasher(1,1);\n\twhile(pw){\n\t\tif(pw&1) res=res*base;\n\t\tbase=base*base;\n\t\tpw>>=1;\n\t}\n\treturn res;\n}\nint main(){\n\tint n;\n\tscanf(\"%d%s\",&n,str+1);\n\tmul_pow[0]=Hasher(1,1);\n\tinv_pow[0]=Hasher(1,1);\n\tHasher mul_inv=qpow(mul,mod-2);\n\tfor(int i=1;i<=2*n;i++){\n\t\tmul_pow[i]=mul_pow[i-1]*mul;\n\t\tinv_pow[i]=inv_pow[i-1]*mul_inv;\n\t}\n\tint pos=n;\n\tll ans=0;\n\tfor(int i=1;i<=n;i++){\n\t\tif(str[i]=='+'){\n\t\t\thash_v[i]=hash_v[i-1]+mul_pow[pos];\n\t\t}else if(str[i]=='-'){\n\t\t\thash_v[i]=hash_v[i-1]-mul_pow[pos];\n\t\t}else if(str[i]=='>'){\n\t\t\tpos++;\n\t\t\thash_v[i]=hash_v[i-1];\n\t\t}else if(str[i]=='<'){\n\t\t\tpos--;\n\t\t\thash_v[i]=hash_v[i-1];\n\t\t}\n\t}\n\tpos=n;\n\tfor(int i=1;i<=n;i++){\n\t\tif(hash_v[i]==hash_v[n]) ans++;\n\t\tif(str[i]=='>') pos++;\n\t\telse if(str[i]=='<') pos--;\n\t\tans+=dic[hash_v[i]];\n\t\tif(pos<n)\n\t\t\tdic[hash_v[n]*inv_pow[n-pos]+hash_v[i]]++;\n\t\telse\n\t\t\tdic[hash_v[n]*mul_pow[pos-n]+hash_v[i]]++;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2e5 + 5;\nconst int mod = 1e9 + 7;\nconst int modd = 1e9 + 9;\nconst int X = 1000003;\nconst int XX = 1000007;\ntypedef long long ll;\n#define mp make_pair\n\n\nchar c;\nstring s;\nll n,i,t,tt,a,b,aa,bb,x,xx,bol=1,boll=1,ans;\nmap < pair < int , int > , int > M;\n\nint main(){\n    cin >> n >> s;\n    for(t=X,i=mod-2; i ; i>>=1){\n        if(i & 1) bol = bol*t % mod;\n        t = t*t % mod;\n    }\n    for(t=XX,i=modd-2; i ; i>>=1){\n        if(i & 1) boll = boll*t % modd;\n        t = t*t % modd;\n    }\n\n    for(i=n-1; i>=0 ;i--){\n        c = s[i];\n        if(c == '+') xx++;\n        if(c == '-') xx--;\n        if(c == '>') xx *= XX;\n        if(c == '<') xx *= boll;\n        xx = (xx % modd + modd) % modd;\n        if(c == '-') x--;\n        if(c == '+') x++;\n        if(c == '>') x *= X;\n        if(c == '<') x *= bol;\n        x = (x % mod + mod) % mod;\n    }\n\n    a = 1; b = 0;\n    aa = 1;\n    M[mp(0,0)] = 1;\n    for(i=n-1; i>=0 ;i--){\n        c = s[i];\n        if(c == '+') b -= a, bb -= aa;\n        if(c == '-') b += a, bb += aa;\n        if(c == '>') a *= bol, aa *= boll;\n        if(c == '<') a *= X, aa *= XX;\n        a = (a % mod + mod) % mod;\n        b = (b % mod + mod) % mod;\n        aa = (aa % modd + modd) % modd;\n        bb = (bb % modd + modd) % modd;\n\n\n        t = (a*x + b) % mod;\n        tt = (aa*xx + bb) % modd;\n\n        ans += M[mp(t,tt)];\n        M[mp(b,bb)]++;\n    }\n\n    cout << ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 251000\n#define ll long long\n#define mp make_pair\nconst ll mod1=1e9+7,mod2=998244353;\nconst ll bas1=2333,bas2=4399,ibas1=461637380,ibas2=924039783;\n\nint n,ans;\nchar s[N];\nll h1[N],p1[N],h2[N],p2[N];\nmap<pair<ll,ll>,int> m;\n\nll add1(ll x,ll y) {return (x+y)%mod1;}\nll mul1(ll x,ll y) {return x*y%mod1;}\nll add2(ll x,ll y) {return (x+y)%mod2;}\nll mul2(ll x,ll y) {return x*y%mod2;}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",s+1);\n\tp1[0]=1;\n\tfor (int i=1;i<=n;i++) {\n\t\tp1[i]=p1[i-1]; h1[i]=h1[i-1];\n\t\tif (s[i]=='+') h1[i]=add1(h1[i],p1[i]);\n\t\tif (s[i]=='-') h1[i]=add1(h1[i],mod1-p1[i]);\n\t\tif (s[i]=='<') p1[i]=mul1(p1[i],ibas1);\n\t\tif (s[i]=='>') p1[i]=mul1(p1[i],bas1);\n\t}\n\t\n\tp2[0]=1;\n\tfor (int i=1;i<=n;i++) {\n\t\tp2[i]=p2[i-1]; h2[i]=h2[i-1];\n\t\tif (s[i]=='+') h2[i]=add2(h2[i],p2[i]);\n\t\tif (s[i]=='-') h2[i]=add2(h2[i],mod2-p2[i]);\n\t\tif (s[i]=='<') p2[i]=mul2(p2[i],ibas2);\n\t\tif (s[i]=='>') p2[i]=mul2(p2[i],bas2);\n\t}\n\t\n\tfor (int i=n;i;i--) {\n\t\tm[mp(h1[i],h2[i])]++;\n\t\tans+=m[mp(add1(mul1(h1[n],p1[i-1]),h1[i-1]),add2(mul2(h2[n],p2[i-1]),h2[i-1]))];\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing ll = long long;\ntemplate <typename T>\nconstexpr std::pair<T, T> extgcd(const T a, const T b)\n{\n    if (b == 0) { return std::pair<T, T>{1, 0}; }\n    const auto p = extgcd(b, a % b);\n    return {p.second, p.first - p.second * (a / b)};\n}\ntemplate <typename T>\nconstexpr T inverse(const T a, const T mod) { return (mod + extgcd(a, mod).first % mod) % mod; }\nconstexpr ll MOD1 = 1000000007LL, MOD2 = 1000000009LL;\nconstexpr int H = 10;  //関数値サンプルの個数\nconstexpr ll X[H] = {2371983LL, 1231LL, 123123LL, 4329075LL, 134121LL, 231788LL, 12234LL, 9218739LL, 912380LL, 1987LL};\nconstexpr ll XINV1[H] = {inverse(X[0], MOD1), inverse(X[1], MOD1), inverse(X[2], MOD1), inverse(X[3], MOD1), inverse(X[4], MOD1), inverse(X[5], MOD1), inverse(X[6], MOD1), inverse(X[7], MOD1), inverse(X[8], MOD1), inverse(X[9], MOD1)};\nconstexpr ll XINV2[H] = {inverse(X[0], MOD2), inverse(X[1], MOD2), inverse(X[2], MOD2), inverse(X[3], MOD2), inverse(X[4], MOD2), inverse(X[5], MOD2), inverse(X[6], MOD2), inverse(X[7], MOD2), inverse(X[8], MOD2), inverse(X[9], MOD2)};\nint main()\n{\n    int N;\n    std::string S;\n    std::cin >> N >> S;\n    using P = std::pair<ll, ll>;\n    std::vector<int> deg(N + 1, 0);\n    std::vector<std::vector<P>> value(N + 1, std::vector<P>(H, {0LL, 0LL}));\n    auto plus = [](const P& p1, const P& p2) { return P{(p1.first + p2.first) % MOD1, (p1.second + p2.second) % MOD2}; };\n    auto minus = [](const P& p1, const P& p2) { return P{(p1.first + MOD1 - p2.first) % MOD1, (p1.second + MOD2 - p2.second) % MOD2}; };\n    auto rshift = [](const P& p, const int j) { return P{p.first * X[j] % MOD1, p.second * X[j] % MOD2}; };\n    auto lshift = [](const P& p, const int j) { return P{p.first * XINV1[j] % MOD1, p.second * XINV2[j] % MOD2}; };\n    auto mul = [](const P& p1, const P& p2) { return P{p1.first * p2.first % MOD1, p1.second * p2.second % MOD2}; };\n    for (int i = N - 1; i >= 0; i--) {\n        if (S[i] == '-') {\n            deg[i] = deg[i + 1];\n            for (int j = 0; j < H; j++) { value[i][j] = minus(value[i + 1][j], {1, 1}); }\n        } else if (S[i] == '+') {\n            deg[i] = deg[i + 1];\n            for (int j = 0; j < H; j++) { value[i][j] = plus(value[i + 1][j], {1, 1}); }\n        } else if (S[i] == '>') {\n            deg[i] = deg[i + 1] + 1;\n            for (int j = 0; j < H; j++) { value[i][j] = rshift(value[i + 1][j], j); }\n        } else {\n            deg[i] = deg[i + 1] - 1;\n            for (int j = 0; j < H; j++) { value[i][j] = lshift(value[i + 1][j], j); }\n        }\n    }\n    constexpr int L = 250000;\n    std::vector<std::vector<P>> power(L + 1, std::vector<P>(H, {1, 1}));\n    std::vector<std::vector<P>> invpower(L + 1, std::vector<P>(H, {1, 1}));\n    auto invp = [&](const int i, const int j) { return i >= 0 ? invpower[i][j] : power[-i][j]; };\n    for (int i = 1; i <= L; i++) {\n        for (int j = 0; j < H; j++) { power[i][j] = rshift(power[i - 1][j], j), invpower[i][j] = lshift(invpower[i - 1][j], j); }  //  invpower[i][j] = lshift(power[i - 1][j], j) じゃねんだよなぁまじで\n    }\n    std::vector<P> answer(H);\n    for (int i = 0; i < H; i++) { answer[i] = value[0][i]; }\n    std::vector<std::vector<P>> hash(N + 1, std::vector<P>(H));\n    for (int i = 0; i <= N; i++) {\n        for (int j = 0; j < H; j++) { hash[i][j] = mul(minus(value[i][j], answer[j]), invp(deg[i], j)); }\n    }\n    using VP = std::vector<P>;\n    std::map<VP, ll> mp;\n    ll ans = 0;\n    for (int i = 0; i <= N; i++) {\n        std::vector<P> obj(H);\n        for (int j = 0; j < H; j++) { obj[j] = plus(hash[i][j], mul(invp(deg[i], j), answer[j])); }\n        if (mp.find(obj) != mp.end()) { ans += mp[obj]; }\n        mp[hash[i]]++;\n    }\n    std::cout << ans << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\nusing namespace std;\nconst int N=250005;\nconst int mo=998244353;\nconst int p[]={233,2333,23333,233333,2333333};\nint P[5][N*2];\nint posi[N];\nstruct node{\n\tint a[5];\n\tbool operator <(const node &b)const{\n\t\tFor(i,0,4)\n\t\t\tif (a[i]!=b.a[i])\n\t\t\t\treturn a[i]<b.a[i];\n\t\treturn 0;\n\t}\n\tbool operator ==(const node &b)const{\n\t\tFor(i,0,4)\n\t\t\tif (a[i]!=b.a[i])\n\t\t\t\treturn 0;\n\t\treturn 1;\n\t}\n}a[N];\nint n;\nll ans;\nchar s[N];\nmap<node,int> mp;\nint power(int x,int y){\n\tint s=1;\n\tfor (;y;y/=2,x=1ll*x*x%mo)\n\t\tif (y&1) s=1ll*s*x%mo;\n\treturn s;\n}\nint main(){\n\tscanf(\"%d%s\",&n,s+1);\n\tFor(i,0,4) P[i][0]=1;\n\tFor(i,1,N*2-1) For(j,0,4)\n\t\tP[j][i]=1ll*P[j][i-1]*p[j]%mo;\n\tint pos=N; posi[0]=N;\n\tFor(i,1,n){\n\t\ta[i]=a[i-1];\n\t\tif (s[i]=='+')\n\t\t\tFor(j,0,4)\n\t\t\t\ta[i].a[j]=(a[i].a[j]+P[j][pos])%mo;\n\t\tif (s[i]=='-')\n\t\t\tFor(j,0,4)\n\t\t\t\ta[i].a[j]=(a[i].a[j]+mo-P[j][pos])%mo;\n\t\tif (s[i]=='<') --pos;\n\t\tif (s[i]=='>') ++pos;\n\t\tposi[i]=pos;\n\t}\n\tFor(i,0,n) mp[a[i]]++;\n\tFor(i,0,n-1){\n\t\tnode tmp=a[n]; mp[a[i]]--;\n\t\tFor(j,0,4) tmp.a[j]=1ll*tmp.a[j]*power(p[j],mo-1+posi[i]-posi[0])%mo;\n\t\tFor(j,0,4) tmp.a[j]=(tmp.a[j]+a[i].a[j])%mo;\n\t\tans+=mp[tmp];\n\t}\n\tprintf(\"%lld\\n\",ans);\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 250001,M = 1e9 + 7,b = 11;\nint cs[N],p[N],n;\nmap<int,int>mp;\nvoid add(int &a,int b){\n\ta+=b;\n\tif(a >= M)a-=M;\n\tif(a < 0)a+=M;\n}\nint power(int base,int to){\n\tint ret = 1;\n\twhile(to){\n\t\tif(to&1)ret = ret*1LL*base%M;\n\t\tto>>=1;\n\t\tbase = base*1LL*base%M;\n\t}\n\treturn ret;\n}\nint main(){\n\t//freopen(\"readin.txt\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tp[0] = 1;\n\tchar c;\n\tint inv = power(b,M - 2);\n\tfor(int i = 1;i <= n;i++){\n\t\tscanf(\" %c\",&c);\n\t\tcs[i] = cs[i - 1];\n\t\tp[i] = p[i - 1];\n\t\tif(c == '+')add(cs[i],p[i]);\n\t\telse if(c == '-')add(cs[i],-p[i]);\n\t\telse if(c == '>')p[i] = p[i]*1LL*b%M;\n\t\telse if(c == '<')p[i] = p[i]*1LL*inv%M;\n\t}\n\tlong long ans = 0;\n\tmp[cs[n]] = 1;\n\tfor(int i = 1;i <= n;i++){\n\t\tans+=mp[cs[i]];\n\t\tmp[(cs[n]*1LL*p[i]%M + cs[i] + M)%M]++;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n// #undef DEBUG\n// #define DEBUG\n/// {{{ DEBUG --- ///\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { if(&o == &cerr) { o << '{'; for(size_t i = 0; i < v.size(); i++) o << v[i] << (i + 1 != v.size() ? \", \" : \"\"); o << \"}\"; } else { for(size_t i = 0; i < v.size(); i++) o << v[i] << (i + 1 != v.size() ? \" \" : \"\"); } return o; }\n#ifdef DEBUG\n#ifdef USE_COUT\n#define dump(...) (cout<<\"[\"<<__LINE__<< \"] \"<<#__VA_ARGS__<<\" = \"<<make_tuple(__VA_ARGS__)<<\"\\n\")\n#else\n#define dump(...) (cerr<<\"[\"<<__LINE__<< \"] \"<<#__VA_ARGS__<<\" = \"<<make_tuple(__VA_ARGS__)<<\"\\n\")\n#endif\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\", \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream &o, tuple<T...> const &t){ o << \"(\"; _ot<0>(o, t); o << \")\"; return o; }\ntemplate<class T, class U> ostream & operator<<(ostream &o, pair<T, U> const &p) { o << \"(\" << p.first << \", \" << p.second << \")\"; return o; }\n#else\n#define dump(...) (0)\n#endif\n/// }}}--- ///\n\nll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a % b); }\nll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\nll extgcd(ll a, ll b, ll &x, ll &y) { ll d; return b == 0 ? (x = 1, y = 0, a) : (d = extgcd(b, a % b, y, x), y -= a / b * x, d); }\nll modinv(ll a, ll mod = 1e9 + 7) { ll x = 0, y = 0; extgcd(a, mod, x, y); return (x + mod) % mod; }\nll modpow(ll a, ll b, ll mod = 1e9 + 7) { ll r = 1; a %= mod; while(b) { if(b & 1) r = r * a % mod; a = a * a % mod; b >>= 1; } return r; }\n\nconst int N = 250000 + 10;\nconst ll mod = 1e9 + 7;\nvector<ll> gen{114514, 1919, 810, -114514, -1919, -810};\nvector<map<ll, int>> Aex(gen.size()), Bex = Aex;\nint n;\nstring s;\nint ms[N];\nll calc(int i, int c, ll x) {\n  if(i == 0) {\n    // A\n    if(c <= 1) return 1;\n    if(c == 2) return modinv(x, mod);\n    return x;\n  } else {\n    if(c == 0) return 1;\n    if(c == 1) return -1;\n    return 0;\n  }\n}\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  cin >> n >> s;\n  vector<vector<ll>> A(gen.size(), vector<ll>(n+2)), B = A;\n  for(int i = 0; i < n; i++) {\n    if(s[i] == '+') ms[i] = 0;\n    else if(s[i] == '-') ms[i] = 1;\n    else if(s[i] == '>') ms[i] = 2;\n    else ms[i] = 3;\n  }\n  for(int k = 0; k < gen.size(); k++) {\n    gen[k] = ((gen[k] % mod + mod) % mod);\n    ll x = gen[k];\n    A[k][1] = 1;\n    B[k][1] = 0;\n    for(int i = 0; i < n; i++) {\n      A[k][i+2] = A[k][i+1] * calc(0, ms[i], x) % mod;\n      B[k][i+2] = A[k][i+1] * calc(1, ms[i], x) % mod + B[k][i+1];\n      B[k][i+2] = ((B[k][i+2] % mod + mod) % mod);\n      Bex[k][B[k][i+2]]++;\n    }\n  }\n  // dump(A[0]);\n  // dump(B[0]);\n  ll ans = 0;\n  for(int i = 0; i < n; i++) {\n    ll mi = 1e18;\n    for(int k = 0; k < gen.size(); k++) {\n      ll x = gen[k];\n      ll c = A[k][i+1] * B[k][n+1] % mod;\n      c += B[k][i+1];\n      c %= mod;\n      ll cnt = Bex[k][c];\n      // dump(i, c, cnt);\n      mi = min(mi, cnt);\n      Bex[k][B[k][i+2]]--;\n    }\n    // dump(i, mi);\n    ans += mi;\n  }\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,NAME,...) NAME\n#define pr(...) cerr<< GET_MACRO(__VA_ARGS__,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__) <<endl\n#define pr1(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr2(a,b) pr1(a)<<pr1(b)\n#define pr3(a,b,c) pr1(a)<<pr2(b,c)\n#define pr4(a,b,c,d) pr1(a)<<pr3(b,c,d)\n#define pr5(a,b,c,d,e) pr1(a)<<pr4(b,c,d,e)\n#define pr6(a,b,c,d,e,f) pr1(a)<<pr5(b,c,d,e,f)\n#define pr7(a,b,c,d,e,f,g) pr1(a)<<pr6(b,c,d,e,f,g)\n#define pr8(a,b,c,d,e,f,g,h) pr1(a)<<pr7(b,c,d,e,f,g,h)\nusing namespace std;\nusing Int = long long;\nusing ll = long long;\nusing Double = long double;\nconst Int INF = (1LL<<55)+1e9; // ~ 3.6 * 1e16\nconst Int mod = (1e9)+7;\nconst Double EPS = 1e-8;\nconst Double PI = 6.0 * asin((Double)0.5);\nusing P = pair<Int,Int>;\nusing T = tuple<Int,Int,Int>;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nostream& operator<<(ostream& o,T t){return o<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){Int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){Int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\nconst Int N = 300000;\n\nll mod_pow(ll x,ll n,Int mod){\n  ll res=1;\n  while(n){\n    if(n%2) res=res*x%mod;\n    x=x*x%mod;\n    n/=2;\n  }\n  return res;\n}\n\nll mod_inv(Int num,Int mod){return mod_pow(num, mod-2, mod);}\n\n\nclass Hash{\npublic:\n  ll B, inv, mod;\n  ll num;\n  ll idx;\n  vector<ll> K;\n  Hash(Int B,Int mod):B(B),mod(mod){\n    K.resize(N);\n    K[0] = 1;\n    for(Int i=1;i<N;i++) K[i] = K[i-1] * B % mod;\n\n    inv = mod_pow(B, mod-2, mod);\n    num = 0;\n    idx = K[N/2];\n  }\n\n  void inc(){num = (num + idx) % mod;}\n  void dec(){num = (num - idx + mod) % mod;}\n  void moveLeft(){idx = idx * inv % mod;}\n  void moveRight(){idx = idx * B % mod;}\n  \n};\n\n\nsigned main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  Int n;\n  cin>>n;\n  string s;\n  cin>>s;\n\n\n\n  vector<map<ll,Int> > cnt(3);\n  vector<Hash> hash({Hash(1777771, 1e9+7),Hash(10000019,1000000009),Hash(10000079,1000000021)});\n  vector<Hash> hash2 = hash;\n  \n  for(Int k = 0; k<n ; k++){\n    char ch = s[k];\n    for(Int i=0;i<1;i++){\n      auto &A = hash[i];\n      if(ch == '+') A.inc();\n      if(ch == '-') A.dec();\n      if(ch == '<') A.moveLeft();\n      if(ch == '>') A.moveRight();\n      cnt[i][A.num]++;\n    }\n  }\n\n  vector<ll> allHash(3);\n  vector<ll> Ofset(3,0);\n  for(Int i=0;i<3;i++) allHash[i] = hash[i].num;\n  \n  Int ans = 0;\n  for(Int k=0;k<n;k++){\n    \n    char ch = s[k];\n    Int mn = INF;\n    for(Int i=0;i<1;i++){\n      auto &A = hash2[i];\n      auto &U = allHash[i];\n      auto &X = Ofset[i];\n      \n      ll mod = A.mod;\n      ll B = A.B;\n      ll inv = A.inv;\n      ll val = ((U - X + mod)%mod) % mod;\n      \n      Min(mn, cnt[i][val]);\n      \n      if(ch == '+') X = (X - A.idx + mod) % mod, A.inc();\n      if(ch == '-') X = (X + A.idx + mod) % mod, A.dec();\n      if(ch == '>') U = U * B % mod, A.moveRight();\n      if(ch == '<') U = U * inv % mod, A.moveLeft();\n      assert(cnt[i][A.num] != 0);\n      cnt[i][A.num]--;\n    }\n    ans += mn;\n  }\n  cout<<ans<<endl;\n  \n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e6+5;\nconst int mod=1e9+7;\nconst int P=19260817;\n#define ll long long\nll fsp(ll x,int y){\n\tll ans=1;\n\twhile(y){\n\t\tif(y&1)\tans=ans*x%mod;\n\t\tx=x*x%mod,y>>=1;\n\t}\n\treturn ans;\n}\nchar s[N];\nmap<int,int>ma;\nll n,l1,l2=1,ans,res,add,inv,b[N];\nint main(){\n\n\tscanf(\"%lld%s\",&n,s+1),add=fsp(P,n);\n\tb[0]=1,inv=fsp(P,mod-2);\n\tfor(int i=n;i;i--){\n\t\tif(s[i]=='-')\tres=(res-add+mod)%mod;\n\t\tif(s[i]=='+')\tres=(res+add)%mod;\n\t\tif(s[i]=='<')\tres=res*inv%mod;\n\t\tif(s[i]=='>')\tres=res*P%mod;\n\t}\n\tfor(int i=n;i;i--){\n\t\tll k=0;\n\t\tif(s[i]=='-')\tl1=(l1-add+mod)%mod,k=mod-add;\n\t\tif(s[i]=='<')\tl1=l1*inv%mod,l2=l2*inv%mod;\n\t\tif(s[i]=='>')\tl1=l1*P%mod,l2=l2*P%mod;\n\t\tif(s[i]=='+')\tl1=(l1+add)%mod,k=add;\n\t\t++ma[(k-l1+mod)*fsp(l2,mod-2)%mod];\n\t\tans+=ma[(res-l1+mod)*fsp(l2,mod-2)%mod];\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\nconst int   N   = 5e5 + 1;\n\ntypedef pair<int,int>   ii;\ntypedef pair<ii,ii>     pii;\n\nint qpow(int a,int exp,int mod) {\n    if(exp < 0) exp = mod - 1 - exp;\n    int ans = 1;\n    while (exp) {\n        if(exp & 1) ans = ans * a % mod;\n        a = a * a % mod;  exp >>= 1;\n    }\n    return ans;\n}\n\nvoid add(int &a,int b,int mod) {\n    a += b;\n    if(a >= mod)a -= mod;\n    if(a < 0)   a += mod;\n}\n\nint mod[4];\nint n, f[N];\nint H[N][4];\nstring S;\n\nvoid process(int t)   {\n    for(int i = 1 ; i <= n ; ++i)   {\n        H[i][t] = H[i - 1][t];\n        if(S[i - 1] == '+') add(H[i][t], qpow(N,f[i],mod[t]),mod[t]);\n        if(S[i - 1] == '-') add(H[i][t],-qpow(N,f[i],mod[t]),mod[t]);\n    }\n}\n\nmap<pii,int> mp;\n\nsigned main()   {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    cin >> n >> S;\n\n    for(int i = 0 ; i < n ; ++i)    {\n        f[i + 1] = f[i];\n        if(S[i] == '>') f[i + 1]++;\n        if(S[i] == '<') f[i + 1]--;\n    }\n\n    mod[0] = 1e9 + 7;\n    mod[1] = 1e9 + 9;\n    mod[2] = 1e9 + 21;\n    mod[3] = 1e9 + 33;\n\n    process(0);\n    process(1);\n    process(2);\n    process(3);\n\n    mp[pii({H[n][0],H[n][1]},{H[n][2],H[n][3]})] = 1;\n\n    int ans = 0;\n\n    for(int i = 1 ; i <= n ; ++i)   {\n        ans += mp[pii({H[i][0],H[i][1]},{H[i][2],H[i][3]})];\n        int res0 = H[n][0] * qpow(N,f[i],mod[0]) + H[i][0];\n        int res1 = H[n][1] * qpow(N,f[i],mod[1]) + H[i][1];\n        int res2 = H[n][2] * qpow(N,f[i],mod[2]) + H[i][2];\n        int res3 = H[n][3] * qpow(N,f[i],mod[2]) + H[i][3];\n        res0 %= mod[0]; res1 %= mod[1];\n        res2 %= mod[2]; res3 %= mod[3];\n        mp[pii({res0,res1},{res2,res3})]++;\n    }\n\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define y1 dmytxdy\n#define fi first\n#define se second\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef long double ld;\n\ntemplate <typename T> bool chkmin(T &x,T y){return x>y?x=y,1:0;}\ntemplate <typename T> bool chkmax(T &x,T y){return x<y?x=y,1:0;}\n\nint readint(){\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nconst int cys=1000000007,N=10;\nint n;\nll a[250005],b[250005],pw[250005],ipw[250005];\nmap<ll,ll> bk,occ;\nchar s[250005];\n\nll mod(ll x){return x>=cys?x-cys:x;}\n\nll qpow(ll x,ll p){\n\tll ret=1;\n\tfor(;p;p>>=1,x=x*x%cys) if(p&1) ret=ret*x%cys;\n\treturn ret;\n}\n\nint main(){\n\tn=readint();\n\tscanf(\"%s\",s+1);\n\tfor(int i=1;i<=n;i++) b[i]=b[i-1]+(s[i]=='>')-(s[i]=='<');\n\tfor(int ct=1;ct<=N;ct++){\n\t\tll ax=(1ll*rand()*RAND_MAX+rand())%cys,bx=qpow(ax,cys-2),p=1,now=0;\n\t\tpw[0]=ipw[0]=1;\n\t\tfor(int i=1;i<=n;i++) pw[i]=pw[i-1]*ax%cys;\n\t\tfor(int i=1;i<=n;i++) ipw[i]=ipw[i-1]*bx%cys;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(s[i]=='+') now=mod(now+p);\n\t\t\telse if(s[i]=='-') now=mod(now+cys-p);\n\t\t\telse if(s[i]=='<') p=p*bx%cys;\n\t\t\telse if(s[i]=='>') p=p*ax%cys;\n\t\t}\n\t\ts[n+1]=0;\n\t\tfor(int i=n;i>=1;i--){\n\t\t\tif(s[i]=='+') a[i]=mod(a[i+1]+1);\n\t\t\telse if(s[i]=='-') a[i]=mod(a[i+1]+cys-1);\n\t\t\telse if(s[i]=='<') a[i]=a[i+1]*bx%cys;\n\t\t\telse if(s[i]=='>') a[i]=a[i+1]*ax%cys;\n\t\t}\n\t\tfor(int i=1;i<=n;i++) a[i]=a[i]*(b[i-1]>0?pw[b[i-1]]:ipw[-b[i-1]])%cys;\n\t\tll ans=0;\n\t\tbk.clear();\n\t\tbk[0]++;\n\t\tfor(int i=n;i>=1;i--){\n\t\t\tans+=bk[mod(a[i]+cys-now*(b[i-1]>0?pw[b[i-1]]:ipw[-b[i-1]])%cys)];\n\t\t\tbk[a[i]]++;\n\t\t}\n\t\tocc[ans]++;\n\t}\n\tll maxa=0,res=0;\n\tfor(auto x:occ) if(chkmax(maxa,x.se)) res=x.fi;\n\tprintf(\"%lld\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\nusing namespace std;\ntypedef long long ll;\n#define GG puts(\"FUCK\")\n#define N 500050\n#define mr(x,y) make_pair(x,y)\nint mod1=998244353,base1=19260817,inv1;\nint mod2=353448299,base2=20000003,inv2;\nint h1[N],mi1[N],imi1[N],p[N],n,C;\nint h2[N],mi2[N],imi2[N];\nchar str[N];\nmap<pair<int,int>,int>mp;\nint qp(int x,int y,int p) {\n\tint re=1;\n\tfor(;y;y>>=1,x=ll(x)*x%p) if(y&1) re=ll(re)*x%p;\n\treturn re;\n}\nint main() {\n\tinv1=qp(base1,mod1-2,mod1);\n\tinv2=qp(base2,mod2-2,mod2);\n\tscanf(\"%d%s\",&n,str+1);\n\tint i;\n\tfor(mi1[0]=imi1[0]=mi2[0]=imi2[0]=i=1;i<=(n<<1);i++) {\n\t\tmi1[i]=ll(mi1[i-1])*base1%mod1;\n\t\timi1[i]=ll(imi1[i-1])*inv1%mod1;\n\t\tmi2[i]=ll(mi2[i-1])*base2%mod2;\n\t\timi2[i]=ll(imi2[i-1])*inv2%mod2;\n\t}\n\tp[0]=n;\n\tfor(i=1;i<=n;i++) {\n\t\tif(str[i]=='+') {\n\t\t\tp[i]=p[i-1];\n\t\t\th1[i]=(h1[i-1]+mi1[p[i]])%mod1;\n\t\t\th2[i]=(h2[i-1]+mi2[p[i]])%mod2;\n\t\t}else if(str[i]=='-') {\n\t\t\tp[i]=p[i-1];\n\t\t\th1[i]=(h1[i-1]-mi1[p[i]]+mod1)%mod1;\n\t\t\th2[i]=(h2[i-1]-mi2[p[i]]+mod2)%mod2;\n\t\t}else if(str[i]=='>') {\n\t\t\tp[i]=p[i-1]+1;\n\t\t\th1[i]=h1[i-1]; h2[i]=h2[i-1];\n\t\t}else {\n\t\t\tp[i]=p[i-1]-1;\n\t\t\th1[i]=h1[i-1]; h2[i]=h2[i-1];\n\t\t}\n\t\tmp[mr(h1[i],h2[i])]++;\n\t}\n\tll ans=0;\n\tfor(i=1;i<=n;i++) {\n\t\tint d=p[i-1]-n,t1=h1[n],t2=h2[n];\n\t\tif(d>=0) t1=ll(t1)*mi1[d]%mod1,t2=ll(t2)*mi2[d]%mod2;\n\t\telse t1=ll(t1)*imi1[-d]%mod1,t2=ll(t2)*imi2[-d]%mod2;\n\t\tt1=(t1+h1[i-1])%mod1;\n\t\tt2=(t2+h2[i-1])%mod2;\n\t\tans+=mp[mr(t1,t2)];\n\t\tmp[mr(h1[i],h2[i])]--;\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define fst first\n#define snd second\n#define SZ(u) ((int) (u).size())\n#define ALL(u) (u).begin(), (u).end()\n\ninline void proc_status()\n{\n    ifstream t(\"/proc/self/status\");\n    cerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline T read()\n{\n\tregister T sum(0), fg(1);\n\tregister char ch(getchar());\n\tfor(; !isdigit(ch); ch = getchar()) if(ch == '-') fg = -1;\n\tfor(;  isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) - '0' + ch;\n\treturn sum * fg;\n}\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int, int> pii;\n\nconst int MAXN = (int) 2.5e5;\n\nint n;\n\nchar s[MAXN + 5];\n\ninline void input()\n{\n\tn = read<int>();\n\tscanf(\"%s\", s + 1);\n}\n\ninline int fpm(int x, int y, int MOD)\n{\n\tint res = 1;\n\tfor(; y; y >>= 1, x = (LL) x * x % MOD) if(y & 1) res = (LL) res * x % MOD;\n\treturn res;\n}\n\ninline void solve()\n{\n\t// Thanks to zhou888\n\n\tconst int MOD1 = 998244353, MOD2 = 1004535809, B = 233;\n\n\tstatic int p[MAXN + 5];\n\tstatic int prefix1[MAXN + 5], p1_pow[MAXN * 2 + 5];\n\tstatic int prefix2[MAXN + 5], p2_pow[MAXN * 2 + 5];\n\n\tp1_pow[0 + n] = 1;\n\tp2_pow[0 + n] = 1;\n\tfor(int i = 1, invB1 = fpm(B, MOD1 - 2, MOD1), invB2 = fpm(B, MOD2 - 2, MOD2); i <= n; ++i)\n\t{\n\t\tp1_pow[ i + n] = (LL) p1_pow[ i - 1 + n] *     B % MOD1;\n\t\tp1_pow[-i + n] = (LL) p1_pow[-i + 1 + n] * invB1 % MOD1;\n\t\tp2_pow[ i + n] = (LL) p2_pow[ i - 1 + n] *     B % MOD2;\n\t\tp2_pow[-i + n] = (LL) p2_pow[-i + 1 + n] * invB2 % MOD2;\n\t}\n\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tp[i] = p[i - 1];\n\t\tprefix1[i] = prefix1[i - 1];\n\t\tprefix2[i] = prefix2[i - 1];\n\t\tif(s[i] == '<') --p[i];\n\t\tif(s[i] == '>') ++p[i];\n\t\tif(s[i] == '+')\n\t\t{\n\t\t\t(prefix1[i] += p1_pow[p[i] + n]) %= MOD1;\n\t\t\t(prefix2[i] += p2_pow[p[i] + n]) %= MOD2;\n\t\t}\n\t\tif(s[i] == '-')\n\t\t{\n\t\t\t(prefix1[i] -= p1_pow[p[i] + n]) %= MOD1;\n\t\t\t(prefix2[i] -= p2_pow[p[i] + n]) %= MOD2;\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\t(prefix1[i] += MOD1) %= MOD1;\n\t\t(prefix2[i] += MOD2) %= MOD2;\n\t}\n\n\tstatic map<pii, int> cnt;\n\n\tLL ans = 0;\n\tfor(int i = 1; i <= n; ++i) ans += prefix1[i] == prefix1[n] && prefix2[i] == prefix2[n];\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tans += cnt[mp(prefix1[i], prefix2[i])];\n\t\tint res1 = (prefix1[i] + (LL) p1_pow[p[i] + n] * prefix1[n] % MOD1) % MOD1;\n\t\tint res2 = (prefix2[i] + (LL) p2_pow[p[i] + n] * prefix2[n] % MOD2) % MOD2;\n\t\t++cnt[mp(res1, res2)];\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main()\n{\n//\tfreopen(\"F.in\", \"r\", stdin);\n//\tfreopen(\"F.out\", \"w\", stdout);\n\n\tinput();\n\tsolve();\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint ungigned\n#define db double\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pli pair<ll,int>\n#define vi vector<int>\n#define vpi vector<pii >\n#define IT iterator\n\n#define PB push_back\n#define MK make_pair\n#define LB lower_bound\n#define UB upper_bound\n#define BG begin\n#define ED end\n\n#define For(i,j,k) for (int i=(j);i<=(int)k;i++)\n#define Rep(i,j,k) for (int i=(j);i>=(int)k;i++)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n\n#define LS3 k*2,l,mid\n#define RS3 k*2+1,mid+1,r\n#define LS5 k*2,l,mid,x,y\n#define RS5 k*2+1,mid+1,r,x,y\n#define GET pushdown(k);int mid=(l+r)/2\nusing namespace std;\n\nconst int BAS[5]={233,666,1234,19260817,2017};\nconst int mo=998244353;\nconst int N=250005;\nstruct wzp{\n\tint a[5];\n\tbool operator <(const wzp &x)const{\n\t\tFor(i,0,4)\n\t\t\tif (a[i]!=x.a[i])\n\t\t\t\treturn a[i]<x.a[i];\n\t\treturn 0;\n\t}\n\tbool operator ==(const wzp &x)const{\n\t\tFor(i,0,4)\n\t\t\tif (a[i]!=x.a[i])\n\t\t\t\treturn 0;\n\t\treturn 1;\n\t}\n};\nint P[5][N*2];\nwzp hsh[N];\nint pos[N];\nlong long ans;\nmap<wzp,int> mp;\nchar s[N];\nint power(int x,int y){\n\tint s=1;\n\tfor (;y;y/=2,x=1ll*x*x%mo)\n\t\tif (y&1) s=1ll*s*x%mo;\n\treturn s;\n}\nint main(){\n\tFor(i,0,4){\n\t\tP[i][0]=1;\n\t\tFor(j,1,2*N-1)\n\t\t\tP[i][j]=1ll*P[i][j-1]*BAS[i]%mo;\n\t}\n\tint beg=N,l; pos[0]=N;\n\tscanf(\"%d%s\",&l,s+1);\n\tfor (int i=1;i<=l;i++){\n\t\thsh[i]=hsh[i-1];\n\t\tif (s[i]=='+') For(j,0,4) hsh[i].a[j]=(hsh[i].a[j]+P[j][beg])%mo;\n\t\tif (s[i]=='-') For(j,0,4) hsh[i].a[j]=(hsh[i].a[j]+mo-P[j][beg])%mo;\n\t\tif (s[i]=='<') beg--; if (s[i]=='>') beg++; pos[i]=beg;\n\t}\n\tfor (int i=0;i<=l;i++)\n\t\tmp[hsh[i]]++;\n\tfor (int i=0;i<l;i++){\n\t\twzp rpos=hsh[l]; mp[hsh[i]]--;\n\t\tFor(j,0,4) rpos.a[j]=1ll*rpos.a[j]*power(BAS[j],(mo-1)+pos[i]-pos[0])%mo;\n\t\tFor(j,0,4) rpos.a[j]=(rpos.a[j]+hsh[i].a[j])%mo;\n\t\tans+=mp[rpos];\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define int long long\n#define Accepted 0;\n\nconst int Maxv = 500010; \nconst int Prime1 = 239; \nconst int Prime2 = 211238502252323207ll; \n                            \nint Hash[Maxv], val[Maxv], idx[Maxv], ans, n; \nchar s[Maxv]; \n\nstd::unordered_map<int, int> Map; \n\ninline void PreHandle() {\n    val[n] = 1; \n    for (int i = n + 1; i <= (n << 1); i++)\n        val[i] = val[i - 1] * Prime1; \n    for (int i = n - 1; i >= 0; i--)\n        val[i] = val[i + 1] * Prime2; \n}\n\nsigned main() {\n    scanf(\"%d\", &n); \n    scanf(\"%s\", s); \n\n    PreHandle(); \n\n    for (int i = 0; i < n; i++) {\n        Hash[i + 1] = Hash[i]; \n        idx[i + 1] = idx[i]; \n\n        if (s[i] == '>')\n            idx[i + 1]++; \n        if (s[i] == '<')\n            idx[i + 1]--;\n        if (s[i] == '+')\n            Hash[i + 1] += val[n + idx[i + 1]]; \n        if (s[i] == '-')\n            Hash[i + 1] -= val[n + idx[i + 1]]; \n    }\n    \n    for (int i = n; i >= 0; i--) {\n        int tmp = Hash[i] + Hash[n] * val[n + idx[i]];\n        ans += Map[tmp]; \n        Map[ Hash[i] ]++;\n    }\n\n    printf(\"%lld\\n\", ans);\n\n    return Accepted\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n  \n#define ll long long\n#define all(aaa) aaa.begin(), aaa.end()\n\nconst int MOD = 1000000033, N = 3e5 + 5;\nconst ll X = 1234567;\n\nll bp(ll a, ll p) {\n    ll r = 1;\n    while (p > 0) {\n        if (p & 1)\n            r = r * a % MOD;\n        a = a * a % MOD;\n        p >>= 1;\n    }\n    return r;\n}\n\nll inv_X = bp(X, MOD - 2);\n\nll a[N], b[N];\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n;\n    string s;\n    cin >> n >> s;\n\n    ll h = 0;\n\n    for (int i = n - 1; i >= 0; i--) {\n        if (s[i] == '>')\n            h = h * X % MOD;\n        else if (s[i] == '<')\n            h = h * inv_X % MOD;\n        else if (s[i] == '+')\n            h = (h + 1) % MOD;\n        else\n            h = (h - 1 + MOD) % MOD;\n    }\n\n    map<ll, int> mp;\n\n    ll ans = 0;\n\n    a[n] = 1;\n\n    for (int i = n - 1; i >= 0; i--) {\n        mp[b[i + 1]]++;\n\n        a[i] = a[i + 1];\n        b[i] = b[i + 1];\n\n        if (s[i] == '>') {\n            a[i] = a[i + 1] * inv_X % MOD;\n            b[i] = b[i + 1];\n        }\n        else if (s[i] == '<') {\n            a[i] = a[i + 1] * X % MOD;\n            b[i] = b[i + 1];\n        }\n        else if (s[i] == '+') {\n            a[i] = a[i + 1];\n            b[i] = (b[i + 1] - a[i + 1] + MOD) % MOD;\n        }\n        else {\n            a[i] = a[i + 1];\n            b[i] = (b[i + 1] + a[i + 1]) % MOD;\n        }\n\n        // cout << b[i] << \"\\n\";\n\n        ans += mp[(a[i] * h + b[i]) % MOD];\n    }\n\n    // cout << (a[0] * h + b[0]) % MOD << \"\\n\";\n\n    cout << ans << \"\\n\";\n\n    return 0;   \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define fi first\n#define se second\n\nconst int mod0 = 1e9 + 9, mod1 = 1e9 + 7, base = 500005;\nint n, pwbase[2][base], hashs[2][base], cur = 250000, ans, start[base];\nstring s;\nmap< pair<int, int>, int> cnt;\n\nint binpw (int aa, int mm, int mod) {\n    int ret = 1;\n    for (; mm; mm >>= 1, aa = (aa * aa) % mod) if (mm & 1) ret = (ret * aa) % mod;\n    return ret;\n}\n\nsigned main () {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    cin >> n >> s; s = '*' + s;\n    pwbase[0][0] = pwbase[1][0] = 1;\n    for (int i = 1; i < base; ++i) {\n        pwbase[0][i] = (pwbase[0][i - 1] * base) % mod0;\n        pwbase[1][i] = (pwbase[1][i - 1] * base) % mod1;\n    }\n    for (int i = 1; i <= n; ++i) {\n        start[i] = cur;\n        if(s[i] == '<') cur --;\n        else if(s[i] == '>') cur ++;\n        hashs[0][i] = hashs[0][i - 1];\n        hashs[1][i] = hashs[1][i - 1];\n        if (s[i] == '+') {\n            hashs[0][i] = (hashs[0][i] + pwbase[0][cur]) % mod0;\n            hashs[1][i] = (hashs[1][i] + pwbase[1][cur]) % mod1;\n        }\n        else if (s[i] == '-') {\n            hashs[0][i] = ( (hashs[0][i] - pwbase[0][cur]) % mod0 + mod0) % mod0;\n            hashs[1][i] = ( (hashs[1][i] - pwbase[1][cur]) % mod1 + mod1) % mod1;\n        }\n    }\n\n    pair<int, int> X = { (hashs[0][n] * binpw(pwbase[0][ start[1] ], mod0 - 2, mod0) ) % mod0,\n                        (hashs[1][n] * binpw(pwbase[1][ start[1] ], mod1 - 2, mod1)) % mod1 };\n\n    for (int i = n; i > 0; --i) {\n        cnt[ { hashs[0][i], hashs[1][i] } ] ++;\n        ans += cnt[ { (X.fi * pwbase[0][ start[i] ] + hashs[0][i - 1]) % mod0, (X.se * pwbase[1][ start[i] ] + hashs[1][i - 1]) % mod1 } ];\n    }\n\n    cout << ans;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int N=250005,mu=1000000021,P=2333;\nvoid reduce(int &x){ x+=x>>31&mu; } \nint n,f[N],g[N],pm[N],mx;\nlong long ans;\nchar s[N];\nstd::map<int,int> mp;\nint main(){\n\tscanf(\"%d%s\",&n,s);\n\tint p=0;\n\tfor (int i=0;i<n;i++){\n\t\tif (s[i]=='<') p--;\n\t\t\telse if (s[i]=='>') p++;\n\t\tmx=std::min(mx,p);\n\t}\n\tp=abs(mx);\n\tpm[0]=1;\n\tfor (int i=1;i<=n+p;i++) pm[i]=1ll*pm[i-1]*P%mu;\n\tfor (int i=0;i<n;i++){\n\t\tg[i]=p;\n\t\tif (i) f[i]=f[i-1];\n\t\tswitch (s[i]){\n\t\t\tcase '+':reduce(f[i]+=pm[p]-mu);break;\n\t\t\tcase '-':reduce(f[i]-=pm[p]);break;\n\t\t\tcase '<':p--;break;\n\t\t\tdefault:p++;\n\t\t} \n\t}\n\tint t=f[n-1];\n\tmp[t]=1;\n\tfor (int i=0;i<n;i++){\n\t\tans+=mp[f[i]];\n\t\tmp[(t*1ll*pm[g[i+1]]+f[i])%mu]++;\n\t} \n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <set>\n\n#define MIN_INT -2147483648\n#define MAX_INT 2147483647\n#define MIN_LONG -9223372036854775808L\n#define MAX_LONG 9223372036854775807L\n#define PI 3.141592653589793238462643383279502884L\n\n#define long long long int\n\nusing std::vector;\nusing std::map;\nusing std::set;\nusing std::string;\nusing std::pair;\nusing std::cin;\nusing std::cout;\nusing std::cerr;\n\n// @author: pashka\n\n#define MAX 250000\n\nint main() {\n    std::ios::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n    string s;\n    cin >> s;\n\n    long MOD[2] = {1758706867, 1299697759};\n    long X[2] = {716447, 656323};\n\n    vector<vector<long>> pow(2, vector<long>(2 * MAX + 2));\n    pow[0][0] = pow[1][0] = 1;\n    for (int k = 0; k < 2; k++) {\n        for (int i = 1; i < pow[k].size(); i++) {\n            pow[k][i] = (pow[k][i - 1] * X[k]) % MOD[k];\n        }\n    }\n\n    vector<vector<long>> h(2, vector<long>(n + 1));\n    vector<int> p(n + 1);\n    for (int k = 0; k < 2; k++) {\n        p[0] = MAX + 1;\n        for (int i = 0; i < n; i++) {\n            h[k][i + 1] = h[k][i];\n            p[i + 1] = p[i];\n            if (s[i] == '+') {\n                h[k][i + 1] += pow[k][p[i]];\n            } else if (s[i] == '-') {\n                h[k][i + 1] -= pow[k][p[i]];\n            } else if (s[i] == '>') {\n                p[i + 1]++;\n            } else if (s[i] == '<') {\n                p[i + 1]--;\n            }\n            h[k][i + 1] %= MOD[k];\n            while (h[k][i + 1] < 0) h[k][i + 1] += MOD[k];\n        }\n    }\n\n//    for (int i = 0; i <= n; i++) {\n//        cout << h[i] << \" \" << p[i] << \"\\n\";\n//    }\n\n    long H[2] = {h[0][n] % MOD[0], h[1][n] % MOD[1]};\n    map<pair<long, long>, int> mp;\n    long res = 0;\n    for (int i = n; i >= 0; i--) {\n        long a[2], b[2];\n        for (int k = 0; k < 2; k++) {\n            a[k] = (h[k][i] * pow[k][MAX + 1]) % MOD[k];\n            b[k] = (a[k] + H[k] * pow[k][p[i]]) % MOD[k];\n        }\n        res += mp[{b[0], b[1]}];\n        mp[{a[0], a[1]}]++;\n    }\n    cout << res << \"\\n\";\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef __INTMOD_H__\n#define __INTMOD_H__\n\n/* updated: 2020-06-24 */\n\n#include <iostream>\n#include <cassert>\n#include <vector>\n#include <cstdint>\n#include <functional>\n#include <unordered_map>\n\ntemplate <uint32_t Mod>\nclass IntMod {\n\tstatic_assert(Mod != 0, \"Mod must not be 0\");\n\tstatic_assert(Mod < 0x80000000, \"Mod must be less than 0x80000000\");\n\nprivate:\n\tuint32_t value_m;\n\npublic:\n\tIntMod();\n\tIntMod(int32_t value);\n\tIntMod(uint32_t value);\n\tIntMod(int64_t value);\n\tIntMod(uint64_t value);\n\n\tconst IntMod<Mod>& operator+() const;\n\tIntMod<Mod> operator-() const;\n\tIntMod<Mod>& operator++();\n\tIntMod<Mod>& operator--();\n\tIntMod<Mod> operator++(int dummy);\n\tIntMod<Mod> operator--(int dummy);\n\tIntMod<Mod>& operator+=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator-=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator*=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator/=(const IntMod<Mod>& right);\n\tIntMod<Mod> operator[](uint64_t exp) const;\n\n\tstatic IntMod<Mod> add(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> subtract(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> multiply(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> divide(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic int compare(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\n\tIntMod<Mod> inverse() const;\n\tIntMod<Mod> power(uint64_t exp) const;\n\tuint32_t get() const;\n\n\tstatic IntMod<Mod> fact(uint32_t num);\n\tstatic IntMod<Mod> invFact(uint32_t num);\n\tstatic IntMod<Mod> combi(uint32_t n, uint32_t r);\n\tstatic IntMod<Mod> homcombi(uint32_t n, uint32_t r);\n\tstatic IntMod<Mod> perm(uint32_t n, uint32_t r);\n\tstatic std::vector<IntMod<Mod>> calcInverseList(int max);\n};\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const Int& b);\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator+(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator-(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator*(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator/(const Int& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod>\nbool operator==(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator!=(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator<(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator<=(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator>(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator>=(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod, class Int>\nbool operator==(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nbool operator!=(const IntMod<Mod>& a, const Int& b);\n\ntemplate <uint32_t Mod>\nstd::istream& operator>>(std::istream& ist, IntMod<Mod>& object);\ntemplate <uint32_t Mod>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Mod>& object);\n\nusing MInt = IntMod<1000000007>;\nusing MF = IntMod<998244353>;\n\n// for unordered_set/map\nnamespace std {\n\ttemplate <uint32_t Mod>\n\tstruct hash<IntMod<Mod>> {\n\t\tsize_t operator() (const IntMod<Mod>& object) const {\n\t\t\treturn std::hash<uint32_t>()(object.get());\n\t\t}\n\t};\n}\n\n/*------------------------------------*/\n/*-------   Implementations   --------*/\n/*------------------------------------*/\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod() \n\t: value_m(0) {\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(int32_t value) {\n\tint32_t tmp = value % int32_t(Mod);\n\tvalue_m = tmp >= 0 ? tmp : Mod - uint32_t(-tmp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(uint32_t value)\n\t: value_m(value % Mod) {\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(int64_t value) {\n\tint32_t tmp = value % int64_t(Mod);\n\tvalue_m = tmp >= 0 ? tmp : Mod - uint32_t(-tmp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(uint64_t value)\n\t: value_m(value % Mod) {\n}\n\ntemplate <uint32_t Mod>\nconst IntMod<Mod>& IntMod<Mod>::operator+() const {\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator-() const {\n\tIntMod<Mod> ret;\n\tif (value_m == 0) {\n\t\tret.value_m = 0;\n\t} else {\n\t\tret.value_m = Mod - value_m;\n\t}\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator++() {\n\t++value_m;\n\tif (value_m == Mod) {\n\t\tvalue_m = 0;\n\t}\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator--() {\n\tif (value_m == 0) {\n\t\tvalue_m = Mod;\n\t}\n\t--value_m;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator++(int dummy) {\n\tIntMod ret(*this);\n\t++*this;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator--(int dummy) {\n\tIntMod ret(*this);\n\t--*this;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator+=(const IntMod<Mod>& right) {\n\tvalue_m += right.value_m;\t\t// note: value_m < 0x80000000\n\tif (value_m >= Mod) {\n\t\tvalue_m -= Mod;\n\t}\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator-=(const IntMod<Mod>& right) {\n\tif (value_m < right.value_m) {\n\t\tvalue_m += Mod;\t\t\t\t// note: value_m < 0x80000000\n\t}\n\tvalue_m -= right.value_m;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator*=(const IntMod<Mod>& right) {\n\tvalue_m = (uint64_t(value_m) * right.value_m) % Mod;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator/=(const IntMod<Mod>& right) {\n\t*this *= right.inverse();\n\treturn *this;\n}\n\n// for power\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator[](uint64_t exp) const {\n\treturn power(exp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::add(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret += b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::subtract(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret -= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::multiply(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret *= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::divide(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret /= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nint IntMod<Mod>::compare(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tif (a.value_m < b.value_m) return -1;\n\tif (a.value_m > b.value_m) return 1;\n\treturn 0;\n}\n\n/* Mod must be a prime. */\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::inverse() const {\n\tassert(value_m != 0);\n\treturn power(Mod - 2);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::power(uint64_t exp) const {\n\tIntMod<Mod> product(1);\n\tIntMod<Mod> factor(*this);\n\twhile (exp > 0) {\n\t\tif (exp & 1) {\n\t\t\tproduct *= factor;\n\t\t}\n\t\tfactor *= factor;\n\t\texp >>= 1;\n\t}\n\treturn product;\n}\n\ntemplate <uint32_t Mod>\nuint32_t IntMod<Mod>::get() const {\n\treturn value_m;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::fact(uint32_t num) {\n\tassert(num <= 0x80000000);\n\n\tstatic std::vector<IntMod<Mod>> table(1, 1);\n\tif (table.size() > num) return table[num];\n\n\tuint32_t old_size = table.size();\n\ttable.resize(num + 1);\n\tfor (uint32_t i = old_size; i <= num; ++i) {\n\t\ttable[i] = table[i - 1] * i;\n\t}\n\treturn table[num];\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::invFact(uint32_t num) {\n\tassert(num <= 0x80000000);\n\n\tstatic std::vector<IntMod<Mod>> table(1, 1);\n\tif (table.size() > num) return table[num];\n\n\tuint32_t old_size = table.size();\n\ttable.resize(num + 1);\n\ttable[num] = fact(num).inverse();\n\tfor (uint32_t i = num; i >= old_size; --i) {\n\t\ttable[i - 1] = table[i] * i;\n\t}\n\treturn table[num];\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::combi(uint32_t n, uint32_t r) {\n\tassert(n >= r);\n\treturn fact(n) * invFact(n - r) * invFact(r);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::homcombi(uint32_t n, uint32_t r) {\n\tassert(n != 0 || r == 0);\n\n\tif (n == 0 && r == 0) return IntMod<Mod>(1);\n\treturn combi(n + r - 1, r);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::perm(uint32_t n, uint32_t r) {\n\tassert(n >= r);\n\treturn fact(n) * invFact(n - r);\n}\n\ntemplate <uint32_t Mod>\nstd::vector<IntMod<Mod>> IntMod<Mod>::calcInverseList(int max) {\n\tassert(max < Mod);\n\n\tstd::vector<IntMod<Mod>> table(max + 1);\n\ttable[1] = 1;\n\tfor (int i = 2; i <= max; ++i) {\n\t\ttable[i] = (uint64_t(Mod - Mod / i) * table[Mod % i].get()) % Mod;\n\t}\n\treturn table;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::add(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::subtract(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::multiply(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::divide(a, b);\n}\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const Int& b) {\n\treturn a + IntMod<Mod>(b);\n}\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const Int& b) {\n\treturn a - IntMod<Mod>(b);\n}\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const Int& b) {\n\treturn a * IntMod<Mod>(b);\n}\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const Int& b) {\n\treturn a / IntMod<Mod>(b);\n}\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator+(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) + b;\n}\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator-(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) - b;\n}\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator*(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) * b;\n}\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator/(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) / b;\n}\n\ntemplate <uint32_t Mod>\nbool operator==(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) == 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator!=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) != 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator<(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) < 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator<=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) <= 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator>(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) > 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator>=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) >= 0;\n}\n\ntemplate <uint32_t Mod, class Int>\nbool operator==(const IntMod<Mod>& a, const Int& b) {\n\treturn a == IntMod<Mod>(b);\n}\n\ntemplate <uint32_t Mod, class Int>\nbool operator!=(const IntMod<Mod>& a, const Int& b) {\n\treturn a != IntMod<Mod>(b);\n}\n\ntemplate <uint32_t Mod>\nstd::istream& operator>>(std::istream& ist, IntMod<Mod>& object) {\n\tuint64_t value;\n\tist >> value;\n\tobject = IntMod<Mod>(value);\n\treturn ist;\n}\n\ntemplate <uint32_t Mod>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Mod>& object) {\n\tost << object.get();\n\treturn ost;\n}\n\n#endif\n\n#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\n\nusing namespace std;\nusing uint = uint32_t;\nusing LL = int64_t;\nusing ULL = uint64_t;\nusing PP = pair<LL, LL>;\ntemplate <typename T> using PriorityQ = priority_queue<T, vector<T>, greater<T> >;\n#define REP(i, a, n) for(LL i = (a), i##_max_ = (n); i < i##_max_; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##_min_ = (a); i >= i##_min_; --i)\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP { cin.tie(NULL); ios::sync_with_stdio(false); }\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U> istream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U> ostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N> void Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N> void Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate <class T> T Next() { T buf; cin >> buf; return buf; }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"Accumulator.h\"\n#include \"Algebraic.h\"\n#include \"BinaryMatrix.h\"\n#include \"BinaryTree.h\"\n#include \"Bipartite.h\"\n#include \"BIT.h\"\n#include \"Compressor.h\"\n#include \"Decompositions.h\"\n#include \"DiscreteLog.h\"\n#include \"DynamicMod.h\"\n#include \"Exponential.h\"\n#include \"Factorization.h\"\n#include \"FFT.h\"\n#include \"FlowSolver.h\"\n#include \"Graph.h\"\n#include \"GraphUtil.h\"\n#include \"Interpolation.h\"\n#include \"IntMod.h\"\n#include \"LazySegmentTree.h\"\n#include \"LIS.h\"\n#include \"Math.h\"\n#include \"MathUtil.h\"\n#include \"Matrix.h\"\n#include \"MinCostFlowSolver.h\"\n#include \"MinMax.h\"\n#include \"Numbers.h\"\n#include \"Optimize.h\"\n#include \"Permutation.h\"\n#include \"Polynomial.h\"\n#include \"Position.h\"\n#include \"Random.h\"\n#include \"Range.h\"\n#include \"Rational.h\"\n#include \"RuntimeMod.h\"\n#include \"SegmentTree.h\"\n#include \"SegmentTree2D.h\"\n#include \"Sets.h\"\n#include \"Shortest.h\"\n#include \"SlidingWindow.h\"\n#include \"SpanningTree.h\"\n#include \"StringSearching.h\"\n#include \"SuffixArray.h\"\n#include \"SwitchList.h\"\n#include \"Timer.h\"\n#include \"Tree.h\"\n#include \"TreeUtil.h\"\n#include \"UnionFind.h\"\n#include \"Util.h\"\n#include \"VectorUtil.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>>(istream& ist, __int128& val) { LL tmp; ist >> tmp; val = tmp; return ist; }\nostream& operator<<(ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n\n\nint N;\nstring S;\ntemplate <class T>\nvector<pair<T, T>> sub(T base) {\n\tvector<pair<T, T>> ret;\n\n\tpair<T, T> cur(T(1), T(0));\n\tret.push_back(cur);\n\n\tREM(i, 0, N) {\n\t\tswitch (S[i]) {\n\t\tcase '+':\n\t\t\t++cur.second;\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\t--cur.second;\n\t\t\tbreak;\n\t\tcase '<':\n\t\t\tcur.first *= base;\n\t\t\tcur.second *= base;\n\t\t\tbreak;\n\t\tcase '>':\n\t\t\tcur.first /= base;\n\t\t\tcur.second /= base;\n\t\t\tbreak;\n\t\t}\n\t\tret.push_back(cur);\n\t}\n\treturn ret;\n}\n\nint main() {\n\tcin >> N >> S;\n\n\n\tLL sum = 0;\n\tauto seq1 = sub(MInt(5));\n\tauto seq2 = sub(MF(7));\n\tauto p1 = seq1[N].second;\n\tauto p2 = seq2[N].second;\n\tmap<pair<MInt, MF>, LL> mp;\n\tREP(i, 0, N + 1) {\n\t\tauto a1 = seq1[i].first;\n\t\tauto b1 = seq1[i].second;\n\t\tauto v1 = b1 / a1;\n\t\tauto w1 = (b1 - p1) / a1;\n\n\t\tauto a2 = seq2[i].first;\n\t\tauto b2 = seq2[i].second;\n\t\tauto v2 = b2 / a2;\n\t\tauto w2 = (b2 - p2) / a2;\n\n\t\tsum += mp[make_pair(w1, w2)];\n\t\t++mp[make_pair(v1, v2)];\n\t}\n\tcout << sum << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define meow(args...) fprintf(stderr, args)\ntypedef unsigned u32;\ntypedef long long s64;\ntypedef unsigned long long u64;\ntypedef std::uniform_int_distribution<> randint;\ntemplate<class T1, class T2> inline bool cmin(T1 &a, const T2 &b) {return b<a?(a=b, true):false;}\ntemplate<class T1, class T2> inline bool cmax(T1 &a, const T2 &b) {return a<b?(a=b, true):false;}\n\nu32 P, Ha;\nu64 power(u64 a, int b) {\n\tu64 ans=1;\n\tfor(; b; a=a*a%P, b/=2) if(b&1) ans=ans*a%P;\n\treturn ans;\n}\n\nconst int N=250010, K=6;\n\nstruct Linear {\n\tu32 a[K], b[K];\n\tLinear operator()(const Linear &f) {\n\t\tLinear g;\n\t\tfor(int i=0; i<K; ++i) g.a[i]=(u64)a[i]*f.a[i]%P;\n\t\tfor(int i=0; i<K; ++i) g.b[i]=((u64)a[i]*f.b[i]+b[i])%P;\n\t\treturn g;\n\t}\n\tbool operator==(const Linear &o) {\n\t\treturn memcmp(b, o.b, sizeof(b))==0;\n\t}\n\tu32 hash() {\n\t\tu32 sum=0;\n\t\tfor(int i=0; i<K; ++i) sum=(sum*65536llu+b[i])%Ha;\n\t\treturn sum;\n\t}\n};\nint n, head[20000000], next[N], size[N];\nu32 x[K];\nchar s[N];\nLinear f[N], pink[N];\nstd::random_device randev;\nstd::mt19937 gen(randev());\nbool is_prime(int n) {\n\tif(n==1) return false;\n\tfor(int i=2; (s64)i*i<=n; ++i) if(n%i==0) return false;\n\treturn true;\n}\nint main() {\n\ts64 ans=0;\n\tassert(scanf(\"%d%s\", &n, s)==2);\n\tdo {\n\t\tP=randint(9e7, 11e7)(gen);\n\t} while(!is_prime(P));\n\tdo {\n\t\tHa=randint(1e7, 2e7)(gen);\n\t} while(!is_prime(Ha));\n\tfor(int i=0; i<K; ++i) x[i]=randint(1, P-1)(gen);\n\tfor(int i=0; i<n; ++i) {\n\t\tif(s[i]=='+') for(int j=0; j<K; ++j) f[i].a[j]=1, f[i].b[j]=1;\n\t\tif(s[i]=='-') for(int j=0; j<K; ++j) f[i].a[j]=1, f[i].b[j]=P-1;\n\t\tif(s[i]=='>') for(int j=0; j<K; ++j) f[i].a[j]=x[j];\n\t\tif(s[i]=='<') for(int j=0; j<K; ++j) f[i].a[j]=power(x[j], P-2);\n\t}\n\tfor(int j=0; j<K; ++j) pink[0].a[j]=1;\n\tfor(int i=0; i<n; ++i) pink[i+1]=pink[i](f[i]);\n\tfor(int i=n, j; i>=1; --i) {\n\t\tu32 key=pink[i].hash();\n\t\tfor(j=head[key]; j; j=next[j])\n\t\t\tif(pink[j]==pink[i]) {\n\t\t\t\t++size[j];\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif(j==0) {\n\t\t\tnext[i]=head[key];\n\t\t\thead[key]=i;\n\t\t\tsize[i]=1;\n\t\t}\n\t\tLinear f=pink[i-1](pink[n]);\n\t\tfor(int j=head[f.hash()]; j; j=next[j])\n\t\t\tif(f==pink[j]) {\n\t\t\t\tans+=size[j];\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nconstexpr int P = 998244353;\nconstexpr int BASE[] {19260817, 20030912, 19491001, 114514, 1919810};\nconstexpr int INV_BASE[] {494863259, 434508607, 157440299, 137043501, 595887626};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    string s;\n    cin >> n >> s;\n    vector<vector<int>> a(n + 1);\n    vector<vector<int>> b(n + 1);\n    for (int i = 0; i <= n; ++i) {\n        a[i].resize(5);\n        b[i].resize(5);\n    }\n    for (int j = 0; j < 5; ++j) {\n        int c = 0;\n        for (int i = n - 1; i >= 0; --i) {\n            switch (s[i]) {\n                case '+' :\n                    c = (c + 1) % P;\n                    break;\n                case '-':\n                    c = (c - 1 + P) % P;\n                    break;\n                case '>':\n                    c = 1LL * c * BASE[j] % P;\n                    break;\n                case '<':\n                    c = 1LL * c * INV_BASE[j] % P;\n                    break;\n            }\n        }\n        auto calc = [&](vector<vector<int>> &a, int c) {\n            a[n][j] = c;\n            int k = 1, b = 0;\n            for (int i = n - 1; i >= 0; --i) {\n                switch (s[i]) {\n                    case '+' :\n                        b = (b - k + P) % P;\n                        break;\n                    case '-':\n                        b = (b + k) % P;\n                        break;\n                    case '>':\n                        k = 1LL * k * INV_BASE[j] % P;\n                        break;\n                    case '<':\n                        k = 1LL * k * BASE[j] % P;\n                        break;\n                }\n                a[i][j] = (1LL * k * c + b) % P;\n            }\n        };\n        calc(a, c);\n        calc(b, 0);\n    }\n    LL ans = 0;\n    map<vector<int>, int> cnt;\n    for (int i = 0; i <= n; ++i) {\n        ans += cnt[b[i]];\n        ++cnt[a[i]];\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#define ll long long\n#define inf 0x3f3f3f3f\n#define mod 998244353\n#define maxn 300010\ninline ll read()\n{\n\tll x=0; char c=getchar(),f=1;\n\tfor(;c<'0'||'9'<c;c=getchar())if(c=='-')f=-1;\n\tfor(;'0'<=c&&c<='9';c=getchar())x=x*10+c-'0';\n\treturn x*f;\n}\ninline void write(ll x)\n{\n\tstatic char buf[20];\n\tint len=0;\n\tif(x<0)putchar('-'),x=-x;\n\tfor(;x;x/=10)buf[len++]=x%10+'0';\n\tif(!len)putchar('0');\n\telse while(len)putchar(buf[--len]);\n}\ninline void writesp(ll x){write(x); putchar(' ');}\ninline void writeln(ll x){write(x); putchar('\\n');}\nstruct Data{\n\tll k,b;\n\tfriend Data operator * (Data a,Data b){return (Data){a.k*b.k%mod,(a.k*b.b+a.b)%mod};}\n\tfriend int operator * (Data a,int b){return (a.k*b+a.b)%mod;}\n}a1[maxn],pre1[maxn],a2[maxn],pre2[maxn];\nchar s[maxn];\nint n,m;\nll power(ll a,ll b)\n{\n\tll ans=1;\n\tfor(;b;b>>=1,a=a*a%mod)\n\t\tif(b&1)ans=ans*a%mod;\n\treturn ans;\n}\nconst ll base1=233,inv1=power(base1,mod-2),base2=666,inv2=power(base2,mod-2);\nstd::map<std::pair<int,int>,int>cnt;\nint main()\n{\n\tn=read();\n\tscanf(\"%s\",s+1);\n\tfor(int i=1;i<=n;i++)\n\t\tif(s[i]=='<')a1[i]=(Data){inv1,0},a2[i]=(Data){inv2,0};\n\t\telse if(s[i]=='>')a1[i]=(Data){base1,0},a2[i]=(Data){base2,0};\n\t\telse if(s[i]=='+')a1[i]=a2[i]=(Data){1,1};\n\t\telse a1[i]=a2[i]=(Data){1,mod-1};\n\tll val1=0,val2=0;\n\tfor(int i=n;i;i--){\n\t\tval1=a1[i]*val1;\n\t\tval2=a2[i]*val2;\n\t}\n\tpre1[0]=pre2[0]=(Data){1,0};\n\tfor(int i=1;i<=n;i++){\n\t\tpre1[i]=pre1[i-1]*a1[i];\n\t\tpre2[i]=pre2[i-1]*a2[i];\n\t}\n\tll ans=0;\n\t++cnt[std::make_pair(val1,val2)];\n\tfor(int i=1;i<=n;i++){\n\t\tll goal1=pre1[i].b,cur1=pre1[i]*val1,goal2=pre2[i].b,cur2=pre2[i]*val2;\n\t\tif(cnt.count(std::make_pair(goal1,goal2)))ans+=cnt[std::make_pair(goal1,goal2)];\n\t\t++cnt[std::make_pair(cur1,cur2)];\n\t}\n\twriteln(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2e5 + 5;\nconst int mod = 1e9 + 7;\nconst int modd = 1e9 + 9;\nconst int X = 1000003;\nconst int XX = 1000007;\ntypedef long long ll;\n#define mp make_pair\n\n\nstruct hash{\n    int x,y;\n};\n\nchar c;\nstring s;\nll n,i,t,tt,a,b,aa,bb,x,xx,bol=1,boll=1,ans;\nmap < pair < int , int > , int > M;\n\nint main(){\n    cin >> n >> s;\n    for(t=X,i=mod-2; i ; i>>=1){\n        if(i & 1) bol = bol*t % mod;\n        t = t*t % mod;\n    }\n    for(t=XX,i=modd-2; i ; i>>=1){\n        if(i & 1) boll = boll*t % modd;\n        t = t*t % modd;\n    }\n\n    for(i=n-1; i>=0 ;i--){\n        c = s[i];\n        if(c == '+') xx++;\n        if(c == '-') xx--;\n        if(c == '>') xx *= XX;\n        if(c == '<') xx *= boll;\n        xx = (xx % modd + modd) % modd;\n        if(c == '-') x--;\n        if(c == '+') x++;\n        if(c == '>') x *= X;\n        if(c == '<') x *= bol;\n        x = (x % mod + mod) % mod;\n    }\n\n    a = 1; b = 0;\n    aa = 1;\n    M[mp(0,0)] = 1;\n    for(i=0; i<n; i++){\n        c = s[i];\n        if(c == '-') b -= a, bb -= aa;\n        if(c == '+') b += a, bb += aa;\n        if(c == '<') a *= bol, aa *= boll;\n        if(c == '>') a *= X, aa *= XX;\n        a = (a % mod + mod) % mod;\n        b = (b % mod + mod) % mod;\n        aa = (aa % modd + modd) % modd;\n        bb = (bb % modd + modd) % modd;\n\n\n        t = (a*x + b) % mod;\n        tt = (aa*xx + bb) % modd;\n\n        ans += M[mp(b,bb)];\n        M[mp(t,tt)]++;\n    }\n\n    cout << ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 250005;\nconst int P = 1e9 + 7;\nconst int Q = 998244353;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\ntemplate <typename T> void write(T x) {\n\tif (x < 0) x = -x, putchar('-');\n\tif (x > 9) write(x / 10);\n\tputchar(x % 10 + '0');\n}\ntemplate <typename T> void writeln(T x) {\n\twrite(x);\n\tputs(\"\");\n}\nmap <pair <int, int>, int> mp;\nint base, inv;\nchar s[MAXN];\npair <int, int> a[MAXN];\nint power(int x, int y) {\n\tif (y == 0) return 1;\n\tint tmp = power(x, y / 2);\n\tif (y % 2 == 0) return 1ll * tmp * tmp % P;\n\telse return 1ll * tmp * tmp % P * x % P;\n}\nint qower(int x, int y) {\n\tif (y == 0) return 1;\n\tint tmp = power(x, y / 2);\n\tif (y % 2 == 0) return 1ll * tmp * tmp % Q;\n\telse return 1ll * tmp * tmp % Q * x % Q;\n}\nconst int bp = 107;\nconst int ip = power(bp, P - 2);\nvoid pls(pair <int, int> &tmp) {\n\ttmp.first = (tmp.first + 1) % P;\n}\nvoid mns(pair <int, int> &tmp) {\n\ttmp.first = (tmp.first + P - 1) % P;\n}\nvoid rit(pair <int, int> &tmp) {\n\ttmp.first = (1ll * tmp.first * bp) % P;\n\ttmp.second++;\n}\nvoid lft(pair <int, int> &tmp) {\n\ttmp.first = (1ll * tmp.first * ip) % P;\n\ttmp.second--;\n}\nint main() {\n\tpair <int, int> now = make_pair(0, 0);\n\tint n; read(n);\n\tscanf(\"\\n%s\", s + 1);\n\tstrlen(s + 1); int delta = 0;\n\ta[0] = now; mp[now]++;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (s[i] == '+') pls(now);\n\t\tif (s[i] == '-') mns(now);\n\t\tif (s[i] == '>') rit(now);\n\t\tif (s[i] == '<') lft(now);\n\t\ta[i] = now;\n\t\tif (now.first == 0) {\n\t\t\tpair <int, int> tmp = now;\n\t\t\ttmp.second = 0;\n\t\t\tmp[tmp]++;\n\t\t} else mp[now]++;\n\t}\n\tnow = make_pair(0, delta);\n\tlong long ans = 0;\n\tfor (int i = n; i >= 1; i--) {\n\t\tif (a[i].first == 0) {\n\t\t\tpair <int, int> tmp = a[i];\n\t\t\ttmp.second = 0;\n\t\t\tmp[a[i]]--;\n\t\t} else mp[a[i]]--;\n\t\tif (now.first == 0) {\n\t\t\tpair <int, int> tmp = now;\n\t\t\ttmp.second = 0;\n\t\t\tans += mp[tmp];\n\t\t} else ans += mp[now];\n\t\tif (s[i] == '-') pls(now);\n\t\tif (s[i] == '+') mns(now);\n\t\tif (s[i] == '<') rit(now), delta++;\n\t\tif (s[i] == '>') lft(now), delta--;\n\t}\n\twriteln(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <map>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define inver(a,mod) power(a,mod-2,mod)\n#define idx(a,b) ((ll)(a)*mod[1]+(b))\nusing namespace std;\ntemplate<class T> void rd(T &x) {\n\tx=0; int f=1,ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=getchar();}\n\tx*=f;\n}\ntypedef long long ll;\nconst int mod[2]={998244353,1004535809};\nconst int maxn=250000+50;\nint bs[2],rb[2];\nint n; char s[maxn];\nint c[2];\nmap<ll,int> cnt;\nstruct func {\n\tint k,b;\n\tfunc(int k=1,int b=0):k(k),b(b){}\n\tinline int f(int x,int mod) {\n\t\treturn ((ll)k*x+b)%mod;\n\t}\n} a[maxn][2];\ninline func mer(func a,func b,int mod) {\n\treturn func((ll)a.k*b.k%mod,((ll)a.b*b.k+b.b)%mod);\n}\ninline int add(int x,int mod) {return x>=mod?x-mod:x;}\ninline int sub(int x,int mod) {return x<0?x+mod:x;}\nll power(ll x,ll y,int mod) {\n\tll re=1;\n\twhile(y) {\n\t\tif(y&1) re=re*x%mod;\n\t\tx=x*x%mod;\n\t\ty>>=1;\n\t}\n\treturn re;\n}\nvoid init() {\n\tsrand((unsigned long long)(new char));\n\tbs[0]=rand(),rb[0]=inver(bs[0],mod[0]);\n\tbs[1]=rand(),rb[1]=inver(bs[1],mod[1]);\n}\nint main() {\n\tinit();\n\trd(n);\n\tscanf(\"%s\",s+1);\n\tfor(int i=n;i>=1;--i) for(int k=0;k<2;++k) {\n\t\tfunc f; switch(s[i]) {\n\t\t\tcase '+': f=func(1,mod[k]-1),c[k]=add(c[k]+1,mod[k]); break;\n\t\t\tcase '-': f=func(1,1),c[k]=sub(c[k]-1,mod[k]); break;\n\t\t\tcase '>': f=func(rb[k],0),c[k]=(ll)c[k]*bs[k]%mod[k]; break;\n\t\t\tcase '<': f=func(bs[k],0),c[k]=(ll)c[k]*rb[k]%mod[k]; break;\n\t\t}\n\t\ta[i][k]=mer(f,a[i+1][k],mod[k]);\n\t}\n\tll an=0;\n\t++cnt[0];\n\tfor(int i=n;i>=1;--i) {\n\t\tan+=cnt[idx(a[i][0].f(c[0],mod[0]),a[i][1].f(c[1],mod[1]))];\n\t\t++cnt[idx(a[i][0].f(0,mod[0]),a[i][1].f(0,mod[1]))];\n\t}\n\tprintf(\"%lld\\n\",an);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define MAX 500012\n\nint n;\nchar buf[MAX];\n\n\nstring s;\n\n\n//#define MOD1 1000000007\n//#define MOD2 1000000009\n\nvalarray<long long int> MOD1;\nvalarray<long long int> MOD2;\nvector<valarray<long long int> > p2;\nvector<valarray<long long int> > vv;\nvector<int> ps;\nmap<long long int, int> mp;\nlong long int ppow(long long int i, long long int j, long long int MOD) {\n\tlong long int ret = 1;\n\twhile (j) {\n\t\tif (j & 1LL)ret *= i;\n\t\tif (ret >= MOD)ret %= MOD;\n\t\tj >>= 1LL;\n\t}\n\treturn ret;\n}\n\nvalarray<long long int> calc(int dif) {\n\tvalarray<long long int> ret;\n\tret.resize(2, 0);\n\tfor (int j = 0; j < 2; j++) {\n\t\tif (dif < 0) {\n\t\t\tret[j]=ppow(ppow(MOD1[j], abs(dif),MOD2[j]), MOD2[j] - 2,MOD2[j]);\n\t\t}\n\t\telse {\n\t\t\tret[j] = ppow(MOD1[j], abs(dif), MOD2[j]);\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main() {\n\tMOD1.resize(2);\n\tMOD2.resize(2);\n\tp2.push_back(valarray<long long int>());\n\tp2.back().resize(2);\n\tp2.back()[0] = p2.back()[1] = 1;\n\tMOD1[0] = 1000000007;\n\tMOD2[0] = 1000000009;\n\tMOD1[1] = 1000000009;\n\tMOD2[1] = 1000000007;\n\tp2[0] %= MOD2;\n\tfor (int i = 1; i < MAX; i++) {\n\t\tp2.push_back(p2.back());\n\t\tp2[i] *= MOD1;\n\t\tp2[i] %= MOD2;\n\t}\n\tcin >> n;\n\tscanf(\"%s\", buf);\n\ts = buf;\n\tint pos = MAX/2;\n\tvalarray<long long int> hs;\n\ths.resize(2);\n\ths[0] = hs[1] = 0;\n\tvv.push_back(hs);\n\tps.push_back(pos);\n\tfor (int i = 0; i < s.size(); i++) {\n\t\tif (s[i] == '<') {\n\t\t\tpos--;\n\t\t}\n\t\tif (s[i] == '>') {\n\t\t\tpos++;\n\t\t}\n\t\tif (s[i] == '+') {\n\t\t\ths += p2[pos];\n\t\t}\n\t\tif (s[i] == '-') {\n\t\t\ths -= p2[pos];\n\t\t\ths += MOD2;\n\t\t}\n\t\ths %= MOD2;\n\t\tvv.push_back(hs);\n\t\tps.push_back(pos);\n\t}\n\tlong long int way = 0;\n\tfor (int i = vv.size() - 1; i >= 0; i--) {\n\t\tvalarray<long long int> want = vv[i] + vv.back()*calc(-MAX/2+ps[i]);\n\t\twant = want%MOD2;\n\t\tway += mp[want[0] * MOD1[0] + want[1]];\n\t\t//cerr << \"dbg \" << way << endl;\n\t\tmp[vv[i][0]*MOD1[0]+vv[i][1]]++;\n\t}\n\tprintf(\"%lld\\n\", way);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <vector>\n\nconst int DEBUG = 0;\n\n#define MOCK 1\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define DEBUGP(val) cerr << #val << \"=\" << val << \"\\n\"\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\ntypedef pair<ll, ll> PL;\n\n\nconst ll mod = 1e9 + 7;\nconst ll mod2 = 1e9 + 9;\nll powmod(ll a, ll e) {\n  ll sum = 1;\n  ll cur = a;\n  while (e > 0) {\n    if (e % 2) {\n      sum = sum * cur % mod;\n    }\n    cur = cur * cur % mod;\n    e /= 2;\n  }\n  return sum;\n}\nvoid add(ll &x, ll y) {\n  x = (x + y) % mod;\n}\nll powmod(ll a, ll e, ll mod) {\n  ll sum = 1;\n  ll cur = a;\n  while (e > 0) {\n    if (e % 2) {\n      sum = sum * cur % mod;\n    }\n    cur = cur * cur % mod;\n    e /= 2;\n  }\n  return sum;\n}\nll powmod2(ll a, ll e) {\n  ll sum = 1;\n  ll cur = a;\n  while (e > 0) {\n    if (e % 2) {\n      sum = sum * cur % mod2;\n    }\n    cur = cur * cur % mod2;\n    e /= 2;\n  }\n  return sum;\n}\nvoid add2(ll &x, ll y) {\n  x = (x + y) % mod2;\n}\n\n\n\nint main(void) {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  string s;\n  cin >> n >> s;\n  int p = 0;\n  VI pos(n + 1);\n  mt19937 mt;\n  ll b;\n  do {\n    b = mt() % mod;\n  } while (b == 0);\n  \n  vector<VL> hsh(3, VL(n + 1));\n  ll invb = powmod(b, mod - 2);\n  ll invb2 = powmod2(b, mod2 - 2);\n  ll mods[3] = { mod, mod2, 998244353 };\n  ll inv[3] = {invb, invb2};\n  inv[2] = powmod(b, mods[2] - 2, mods[2]);\n  REP(c, 0, 3) {\n    p = 0;\n    ll cur = 1;\n    REP(i, 0, n) {\n      ll tmp = hsh[c][i];\n      if (s[i] == '>') {\n        p++;\n        cur = cur * b % mods[c];\n      }\n      if (s[i] == '<') {\n        p--;\n        cur = cur * inv[c] % mods[c];\n      }\n      if (s[i] == '+') {\n        tmp = (tmp + cur) % mods[c];\n      }\n      if (s[i] == '-') {\n        tmp = (tmp + mods[c] - cur) % mods[c];\n      }\n      hsh[c][i + 1] = tmp;\n      pos[i + 1] = p;\n    }\n  }\n  if (DEBUG) {\n    REP(i, 0, n + 1) {\n      cerr << i << \" \" << hsh[0][i] << endl;\n    }\n  }\n  VL meguru(3);\n  REP(c, 0, 3) meguru[c] = hsh[c][n];\n  map<VL, int> kirika;\n  kirika[meguru] = 1;\n  ll tot = 0;\n  VL cur(3);\n  REP(c, 0, 3) cur[c] = powmod(b, pos[n], mods[c]);\n  for (int i = n - 1; i >= 0; --i) {\n    if (DEBUG) {\n      DEBUGP(i);\n      DEBUGP(pos[i]);\n    }\n    if (pos[i + 1] - pos[i] == 1) {\n      REP(c, 0, 3) cur[c] = cur[c] * inv[c] % mods[c];\n    }\n    else if (pos[i + 1] - pos[i] == -1) {\n      REP(c, 0, 3) cur[c] = cur[c] * b % mods[c];\n    }\n    VL ken(3);\n    REP(c, 0, 3) ken[c] = cur[c] * meguru[c] + hsh[c][i] % mods[c];\n    tot += kirika[ken];\n    VL tt(3);\n    REP(c, 0, 3) tt[c] = hsh[c][i];\n    kirika[tt] += 1;\n  }\n  cout << tot << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <vector>\n\nconst int DEBUG = 0;\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define DEBUGP(val) cerr << #val << \"=\" << val << \"\\n\"\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\ntypedef pair<ll, ll> PL;\n\n\nconst ll mod = 1e9 + 7;\nconst ll mod2 = 1e9 + 9;\nll powmod(ll a, ll e) {\n  ll sum = 1;\n  ll cur = a;\n  while (e > 0) {\n    if (e % 2) {\n      sum = sum * cur % mod;\n    }\n    cur = cur * cur % mod;\n    e /= 2;\n  }\n  return sum;\n}\nvoid add(ll &x, ll y) {\n  x = (x + y) % mod;\n}\nll powmod2(ll a, ll e) {\n  ll sum = 1;\n  ll cur = a;\n  while (e > 0) {\n    if (e % 2) {\n      sum = sum * cur % mod2;\n    }\n    cur = cur * cur % mod2;\n    e /= 2;\n  }\n  return sum;\n}\nvoid add2(ll &x, ll y) {\n  x = (x + y) % mod2;\n}\n\n\n\nint main(void) {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  string s;\n  cin >> n >> s;\n  int p = 0;\n  VI pos(n + 1);\n  mt19937 mt;\n  ll b;\n  do {\n    b = mt() % mod;\n  } while (b == 0);\n  \n  vector<VL> hsh(2, VL(n + 1));\n  ll invb = powmod(b, mod - 2);\n  ll invb2 = powmod2(b, mod2 - 2);\n  ll cur = 1;\n  ll mods[2] = { mod, mod2 };\n  ll inv[2] = {invb, invb2};\n  REP(c, 0, 2) {\n    p = 0;\n    cur = 1;\n    REP(i, 0, n) {\n      ll tmp = hsh[c][i];\n      if (s[i] == '>') {\n        p++;\n        cur = cur * b % mods[c];\n      }\n      if (s[i] == '<') {\n        p--;\n        cur = cur * inv[c] % mods[c];\n      }\n      if (s[i] == '+') {\n        tmp = (tmp + cur) % mods[c];\n      }\n      if (s[i] == '-') {\n        tmp = (tmp + mods[c] - cur) % mods[c];\n      }\n      hsh[c][i + 1] = tmp;\n      pos[i + 1] = p;\n    }\n  }\n  if (DEBUG) {\n    REP(i, 0, n + 1) {\n      cerr << i << \" \" << hsh[0][i] << endl;\n    }\n  }\n  VL meguru(2);\n  REP(c, 0, 2) meguru[c] = hsh[c][n];\n  map<PL, int> kirika;\n  kirika[PL(meguru[0], meguru[1])] = 1;\n  ll tot = 0;\n  ll cur2 = 1;\n  cur = powmod(b, pos[n]);\n  cur2 = powmod2(b, pos[n]);\n  for (int i = n - 1; i >= 0; --i) {\n    if (DEBUG) {\n      DEBUGP(i);\n      DEBUGP(pos[i]);\n    }\n    if (pos[i + 1] - pos[i] == 1) {\n      cur = cur * invb % mod;\n      cur2 = cur2 * invb2 % mod2;\n    }\n    else if (pos[i + 1] - pos[i] == -1) {\n      cur = cur * b % mod;\n      cur2 = cur2 * b % mod2;\n    }\n    if (DEBUG) DEBUGP(cur);\n    PL ken(cur * meguru[0] + hsh[0][i] % mod, cur2 * meguru[1] + hsh[1][i] % mod2);\n    tot += kirika[ken];\n    kirika[PL(hsh[0][i], hsh[1][i])] += 1;\n  }\n  cout << tot << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n\n#define int long long\n\nconst int mod = 1e9 + 9, base = 500005;\nint n, pwbase[base], hashs[base], cur = 250000, ans, start[base];\nstring s;\nmap<int, int> cnt;\n\nint binpw (int aa, int mm) {\n    int ret = 1;\n    for (; mm; mm >>= 1, aa = (1LL * aa * aa) % mod) if (mm & 1) ret = (1LL * ret * aa) % mod;\n    return ret;\n}\n\nint gethash (int i, int j) { return ( (hashs[j] - hashs[i - 1]) % mod + mod) % mod; }\n\nsigned main () {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    cin >> n >> s; s = '*' + s;\n    pwbase[0] = 1;\n    for (int i = 1; i < base; ++i) pwbase[i] = (pwbase[i - 1] * base) % mod;\n    for (int i = 1; i <= n; ++i) {\n        start[i] = cur;\n        if(s[i] == '<') cur --;\n        else if(s[i] == '>') cur ++;\n        hashs[i] = hashs[i - 1];\n        if (s[i] == '+') hashs[i] = (hashs[i] + pwbase[cur]) % mod;\n        else if (s[i] == '-') hashs[i] = ( (hashs[i] - pwbase[cur]) % mod + mod) % mod;\n    }\n    int X = (gethash(1, n) * binpw(pwbase[ start[1] ], mod - 2) ) % mod;\n\n    for (int i = n; i > 0; --i) {\n        cnt[ hashs[i] ] ++;\n        ans += cnt[X * pwbase[ start[i] ] + hashs[i - 1] ];\n    }\n\n    cout << ans;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long lint;\n\nlint modpow(lint x, lint y, lint mod) {\n  lint ret = 1 % mod, x2p = x;\n  while (y > 0) {\n    if (y % 2) ret = (__int128)ret * x2p % mod;\n    y /= 2;\n    x2p = (__int128)x2p * x2p % mod;\n  }\n  return ret;\n}\nconstexpr int nmods = 1;\nconstexpr lint mod[] = {4511686018432017377};\nconstexpr lint base[] = {549817};\nlint inv_base[nmods];\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  string seq(n, ' ');\n  for (int i = 0; i < n; ++i)\n    scanf(\" %c\", &seq[i]);\n\n  vector<int> pos_before(n);\n\n  vector<vector<lint>> base_pow(nmods, vector<lint>(n + 1));\n  vector<vector<lint>> inv_base_pow(nmods, vector<lint>(n + 1));\n  vector<vector<lint>> hash_diff(nmods, vector<lint>(n, 0));\n  vector<vector<lint>> suffix(nmods, vector<lint>(n + 1));\n  vector<lint> full_seq_hash(nmods);\n  for (int k = 0; k < nmods; ++k) {\n    base_pow[k][0] = 1;\n    for (int i = 1; i <= n; ++i)\n      base_pow[k][i] = (__int128)base[k] * base_pow[k][i - 1] % mod[k];\n\n    inv_base[k] = modpow(base[k], mod[k] - 2, mod[k]);\n    assert((__int128)base[k] * inv_base[k] % mod[k] == 1);\n\n    inv_base_pow[k][0] = 1;\n    for (int i = 1; i <= n; ++i)\n      inv_base_pow[k][i] = (__int128)inv_base[k] * inv_base_pow[k][i - 1] % mod[k];\n\n    int pos = 0;\n    for (int i = 0; i < n; ++i) {\n      pos_before[i] = pos;\n      if (seq[i] == '>') ++pos;\n      else if (seq[i] == '<') --pos;\n      else {\n        lint base_pow_pos;\n        if (pos >= 0) base_pow_pos = base_pow[k][pos];\n        else base_pow_pos = inv_base_pow[k][-pos];\n        if (seq[i] == '+') hash_diff[k][i] = base_pow_pos;\n        else if (seq[i] == '-') {\n          hash_diff[k][i] = mod[k] - base_pow_pos;\n          assert(0 <= hash_diff[k][i]);\n          assert(hash_diff[k][i] < mod[k]);\n        } else assert(0);\n      }\n    }\n    full_seq_hash[k] = 0;\n    for (int i = 0; i < n; ++i) {\n      full_seq_hash[k] += hash_diff[k][i];\n      if (full_seq_hash[k] >= mod[k]) full_seq_hash[k] -= mod[k];\n    }\n\n    suffix[k][n] = 0;\n    for (int i = n - 1; i >= 0; --i) {\n      suffix[k][i] = hash_diff[k][i] + suffix[k][i + 1];\n      if (suffix[k][i] >= mod[k]) suffix[k][i] -= mod[k];\n    }\n  }\n\n  lint result = 0;\n  map<vector<lint>, int> count;\n  count[vector<lint>(nmods, 0LL)] += 1;\n  for (int i = n - 1; i >= 0; --i) {\n    vector<lint> shifted_full(nmods);\n    for (int k = 0; k < nmods; ++k) {\n      if (pos_before[i] >= 0) {\n        shifted_full[k] = (__int128)full_seq_hash[k] * base_pow[k][pos_before[i]] % mod[k];\n      } else {\n        shifted_full[k] = (__int128)full_seq_hash[k] * inv_base_pow[k][-pos_before[i]] % mod[k];\n      }\n    }\n\n    vector<lint> target(nmods);\n    for (int k = 0; k < nmods; ++k) {\n      target[k] = suffix[k][i] - shifted_full[k];\n      if (target[k] < 0) target[k] += mod[k];\n    }\n\n    auto it = count.find(target);\n    if (it != count.end())\n      result += it->second;\n\n    vector<lint> suffix_vec(nmods);\n    for (int k = 0; k < nmods; ++k)\n      suffix_vec[k] = suffix[k][i];\n\n    count[suffix_vec] += 1;\n  }\n  printf(\"%lld\\n\", result);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define FOR(a, b, c) for(int a = b; a <= c; ++a)\n#define pb push_back\n#define int long long\n\nconst int N = 250010;\nconst int MOD = 1e9 + 7;\nconst int MOD2 = 1e9 + 9;\nconst int base = 1e6;\nconst int oo = 1e9;\ntypedef pair<int, int> ii;\n\nint n, pos = N, curpos[N], bpw[2][N + N];\nint has[2][N + N], rev[2][N + N];\nstring s;\n\nvoid add(int &x, int val, int mod)  { val = (val % mod + 1ll * mod * mod) % mod;  x = (x + val) % mod;  }\nvoid mul(int &x, int y, int mod) { y = (y + 1ll * mod * mod) % mod; x = x * y % mod; }\nint pw(int x, int y, int mod)    {\n    int res = 1ll;\n    while(y)    {\n        if(y % 2 == 1) mul(res, x, mod);\n        mul(x, x, mod);\n        y /= 2;\n    }\n    return res;\n}\n\nmap<ii, int> cnt;\n\nsigned main()\n{\n    //freopen(\"test.inp\", \"r\", stdin);\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    cin >> n >> s;\n    bpw[0][0] = bpw[1][0] = 1ll;\n    FOR(i, 1, N + N - 1) {\n        bpw[0][i] = bpw[0][i - 1] * base % MOD;\n        bpw[1][i] = bpw[1][i - 1] * base % MOD2;\n        rev[0][i] = pw(bpw[0][i], MOD - 2, MOD);\n        rev[1][i] = pw(bpw[1][i], MOD2 - 2, MOD2);\n    }\n    //cout << pw(base, N + 1, MOD) << '\\n';\n    //cout << bpw[0][N + 1] << ' ' << bpw[1][N + 1] << '\\n';\n    // we need to hash all the value of x\n    FOR(i, 1, n)    {\n        if(s[i - 1] == '+' || s[i - 1] == '-') {\n            add(has[0][i], has[0][i - 1] + ((s[i - 1] == '+') ? +1 : -1) * bpw[0][pos], MOD);\n            add(has[1][i], has[1][i - 1] + ((s[i - 1] == '-') ? -1 : +1 ) * bpw[1][pos], MOD2);\n        } else     {\n            pos += ((s[i - 1] == '>') ? +1 : -1);\n            has[0][i] = has[0][i - 1];\n            has[1][i] = has[1][i - 1];\n        }\n        //cout << has[0][i] << ' ' << has[1][i] << ' ' << pos << '\\n';\n        curpos[i] = pos - N;\n    } //cout << '\\n';\n\n    int s1 = 1ll * has[0][n] % MOD;\n    int s2 = 1ll * has[1][n] % MOD2;\n    //cout << has[0][3] << ' ' << (bpw[0][curpos[1]] * s1 + has[0][1]) % MOD << '\\n';\n    cnt[ ii(s1, s2) ] ++;\n    int ans = 0ll;\n    FOR(i, 1, n)    {\n        ans += cnt[ ii(has[0][i], has[1][i]) ];\n        //if(cnt[ ii(has[0][i], has[1][i]) ] > 0) cout << i << ' ' << has[0][i] << ' ' << has[1][i] << '\\n';\n        int pw1 = ((curpos[i] >= 0) ? bpw[0][ curpos[i] ] : rev[0][-curpos[i]]);\n        int pw2 = ((curpos[i] >= 0) ? bpw[1][ curpos[i] ] : rev[1][-curpos[i]]);\n        int n1 = (s1 * pw1 % MOD + has[0][i] ) % MOD;\n        int n2 = (s2 * pw2 % MOD2 + has[1][i] ) % MOD2;\n        //cout << n1 << ' ' << n2 << '\\n';\n        cnt[ ii(n1, n2) ] ++;\n    }\n\n    cout << ans;\n}\n// limit\n// negetive number\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\n#include <unordered_map>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\nconst ll MOD=998244353;\nll qp(ll a,ll b)\n{\n\tll x=1; a%=MOD;\n\twhile(b)\n\t{\n\t\tif(b&1) x=x*a%MOD;\n\t\ta=a*a%MOD; b>>=1;\n\t}\n\treturn x;\n}\nconst ll g=233,rg=qp(g,MOD-2);\npair<ll,ll> operator +\n(pair<ll,ll> a,pair<ll,ll> b)\n{return mp((a.fi+a.se*b.fi)%MOD,a.se*b.se%MOD);}\n#define SZ 666666\nint n; char str[SZ];\npair<ll,ll> sg[SZ],tg(0,1);\nll ans=0;\nvoid fz(int l,int r)\n{\n\tif(l==r)\n\t{\n\t\tans+=sg[l].fi==tg.fi;\n\t\treturn;\n\t}\n\tint m=(l+r)>>1;\n\tfz(l,m); fz(m+1,r);\n\tunordered_map<ll,int> sb;\n\tpair<ll,ll> g(0,1);\n\tfor(int i=m+1;i<=r;++i)\n\t{\n\t\tg=g+sg[i]; ++sb[g.fi];\n\t}\n\tg=mp(0,1);\n\tfor(int i=m;i>=l;--i)\n\t{\n\t\tg=sg[i]+g;\n\t\t//g.fi+g.se*T=tg.fi\n\t\tll tr=(tg.fi-g.fi+MOD)%MOD*qp(g.se,MOD-2)%MOD;\n\t\tans+=sb[tr];\n\t}\n}\nint main()\n{\n\tscanf(\"%d%s\",&n,str+1);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tif(str[i]=='+') sg[i]=mp(1,1);\n\t\telse if(str[i]=='-') sg[i]=mp(MOD-1,1);\n\t\telse if(str[i]=='>') sg[i]=mp(0,g);\n\t\telse sg[i]=mp(0,rg); tg=tg+sg[i];\n\t}\n\tfz(1,n); cout<<ans<<\"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MN 250000\n#define mod 1004535809\n#define mod2 1000000007\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nchar s[MN+5];\nmap<int,int> mp,mp2;long long ans;\nint n,pw[MN*2+5],invpw[MN*2+5],pw2[MN*2+5],invpw2[MN*2+5];\nint Ha[MN+5],pos[MN+5],ha[MN+5];\ninline int PW(int x){return x>=0?pw[x]:invpw[-x];}\ninline int PW2(int x){return x>=0?pw2[x]:invpw2[-x];}\nint main()\n{\n\tn=read();scanf(\"%s\",s+1);pw[0]=invpw[0]=pw2[0]=invpw2[0]=1;\n\tfor(int i=1;i<=n*2;++i) \n\t\tpw[i]=786433LL*pw[i-1]%mod,invpw[i]=317967460LL*invpw[i-1]%mod,\n\t\tpw2[i]=5767169LL*pw2[i-1]%mod2,invpw2[i]=170959791LL*invpw2[i-1]%mod2;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tif(s[i]=='<'||s[i]=='>') \n\t\t\tpos[i]=pos[i-1]+(s[i]=='<'?-1:1),\n\t\t\tha[i]=ha[i-1],Ha[i]=Ha[i-1];\n\t\telse pos[i]=pos[i-1],\n\t\t\tha[i]=(ha[i-1]+1LL*(s[i]=='+'?1:mod-1)*pw[pos[i]+n])%mod,\n\t\t\tHa[i]=(Ha[i-1]+1LL*(s[i]=='+'?1:mod2-1)*pw2[pos[i]+n])%mod2;\n\t}\n\tfor(int i=n;i;--i)\n\t{\n\t\t++mp[(ha[n]-ha[i]+mod)%mod];++mp2[(Ha[n]-Ha[i]+mod2)%mod2];\n\t\tans+=min(mp[(1LL*ha[n]*(mod+1-PW(pos[i-1]))+mod-ha[i-1])%mod],\n\t\t\t     mp2[(1LL*Ha[n]*(mod2+1-PW2(pos[i-1]))+mod2-Ha[i-1])%mod2]);\n\t}\n\tcout<<ans;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\ntypedef long double louble;\n\ntemplate<typename T1,typename T2> inline T1 max(T1 a,T2 b){return a<b?b:a;}\ntemplate<typename T1,typename T2> inline T1 min(T1 a,T2 b){return a<b?a:b;}\n\nconst char lf = '\\n';\n\nnamespace ae86\n{\n\tconst int bufl = 1<<15;\n\n\tchar buf[bufl],*s=buf,*t=buf;\n\n\tinline int fetch()\n\t{\n\t\tif(s==t){t=(s=buf)+fread(buf,1,bufl,stdin);if(s==t)return EOF;}\n\t\treturn *s++;\n\t}\n\n\tinline int ty()\n\t{\n\t\tint a=0,b=1,c=fetch();\n\t\twhile(!isdigit(c))b^=c=='-',c=fetch();\n\t\twhile(isdigit(c))a=a*10+c-48,c=fetch();\n\t\treturn b?a:-a;\n\t}\n\n\ttemplate<typename T> inline int ts(T *s)\n\t{\n\t\tint a=0,c=fetch();\n\t\twhile(c<=32 && c!=EOF)c=fetch();\n\t\twhile(c>32 && c!=EOF)s[a++]=c,c=fetch();\n\t\ts[a]=0;\n\t\treturn a;\n\t}\n}\nusing ae86::ty;\nusing ae86::ts;\n\nconst int _ = 250007;\nconst lint bas = 250007 , mo = 998244853;\n\ninline lint powa(lint a,lint t,lint p=mo)\n{\n\tlint b=1;\n\twhile(t){if(t&1)b=b*a%p;a=a*a%p,t>>=1;}\n\treturn b;\n}\n\ninline lint inva(lint a,lint p=mo)\n{\n\treturn powa(a,p-2);\n}\n\nconst lint ibas = inva(bas);\n\nint n;char s[_];\nlint loc[_];\nunordered_map<lint,int> cnt;\n\ninline lint trans(lint h,char op)\n{\n\tif(op=='<')return h*ibas%mo;\n\tif(op=='>')return h*bas%mo;\n\tif(op=='+')return (h+1)%mo;\n\tif(op=='-')return (h-1+mo)%mo;\n\tthrow \"fuck me\";\n}\n\nint main()\n{\n\tios::sync_with_stdio(0),cout.tie(nullptr);\n\n\tn=ty(),ts(s+1);\n\n\tloc[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tloc[i]=loc[i-1];\n\t\tif(s[i]=='<')loc[i]=loc[i]*ibas%mo;\n\t\tif(s[i]=='>')loc[i]=loc[i]*bas%mo;\n\t}\n\n\tlint tar=0;\n\tfor(int i=n;i>=1;i--)tar=trans(tar,s[i]);\n\tcnt[0]=1;\n\tlint ans=0,now=0;\n\tfor(int i=n;i>=1;i--)\n\t\tnow=trans(now,s[i]),ans+=cnt[(now-tar+mo)%mo*loc[i-1]%mo],cnt[now*loc[i-1]%mo]++;\n\tcout<<ans<<lf;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst unsigned long long M=998244353;\nconst unsigned long long X=99469;\nunsigned long long R;\nconst int W=1500;\n\n\nunsigned long long ModPow(unsigned long long x, unsigned long long n, unsigned long long mod) {\n        unsigned long long ret = 1;\n        for (; n > 0; n /= 2, x = (x * x) % mod)\n            if ((n & 1) == 1) ret = (ret * x) % mod;\n        return ret;\n    }\n\nunsigned long long has=0,vec=1;\n\nint n;\nstring s;\nunordered_map<unsigned long long,int> B[550];\nlong long ans;\ninline void calc(char c, unsigned long long &u,unsigned long long &p){\n\tif(c=='+')u=(u+p)%M;\n\telse if(c=='-')u=(u+M-p)%M;\n\telse if(c=='>')p=(p*X)%M;\n\telse p=(p*R)%M;\n}\nint main(){\n\tR=ModPow(X,M-2,M);\n\tcin>>n>>s;\n    //n=250000;\n    //s=string(n,'+');\n\tfor(int i=0;i<n;i++)calc(s[i],has,vec);\n\tfor(int i=0;i<n;i++){\n\t\tif(i%W==0)continue;\n\t\tunsigned long long h=0,x=1;\n\t\tfor(int j=i;j<n;j++){\n\t\t\tif(j%W==0)break;\n\t\t\tcalc(s[j],h,x);\n\t\t\tif(h==has)ans++;\n\t\t}\n\t\tunsigned long long nh = (has+M-h)%M;\n\t\tnh = nh * ModPow(x,M-2,M)%M;\n\t\tB[i/W+1][nh]++;\n\t}\n\tfor(int i=0;i<n;i+=W){\n\t\tunsigned long long h=0,x=1;\n\t\tfor(int j=i;j<n;j++){\n\t\t\tcalc(s[j],h,x);\n\t\t\tif(h==has)ans++;\n\t\t\tauto it = B[i/W].find(h);\n\t\t\tif(it!=B[i/W].end())ans+=it->second;\n\t\t}\n\t}\n\t\n\tcout<<ans;\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\nusing namespace std;\n\ntypedef long long ll;\nconst int mo = 998244353, X = 1e4 + 7, Y = 1e7 + 7;\nconst int N = 2.5e5 + 10;\nint n;\nll cnt[N], pre[N], X1, cnt2[N], pre2[N], Y1;\nchar s[N];\n\nll ksm(ll x, ll y) {\n\tll ret = 1; for (; y; y >>= 1) {\n\t\tif (y & 1) ret = ret * x % mo;\n\t\tx = x * x % mo;\n\t}\n\treturn ret;\n}\n\nmap<pair<ll, ll>, int> h;\npair<ll, ll> tj(int x) {\n\treturn make_pair(((pre[n] * cnt[x] % mo + pre[x]) % mo + mo) % mo,\n\t\t((pre2[n] * cnt2[x] % mo + pre2[x]) % mo + mo) % mo);\n}\n\nint main() {\n\tcin >> n;\n\tscanf(\"%s\", s + 1);\n\tcnt[0] = 1; cnt2[0] = 1;\n\tX1 = ksm(X, mo - 2); Y1 = ksm(Y, mo - 2);\n\tfor (int i = 1; i <= n; i++) {\n\t\tcnt[i] = cnt[i - 1];\n\t\tpre[i] = pre[i - 1];\n\t\tcnt2[i] = cnt2[i - 1];\n\t\tpre2[i] = pre2[i - 1];\n\t\tif (s[i] == '>') {\n\t\t\tcnt[i] = cnt[i] * X % mo;\n\t\t\tcnt2[i] = cnt2[i] * Y % mo;\n\t\t}\n\t\telse if (s[i] == '<') {\n\t\t\tcnt[i] = cnt[i] * X1 % mo;\n\t\t\tcnt2[i] = cnt2[i] * Y1 % mo;\n\t\t}\n\t\telse if (s[i] == '+') {\n\t\t\tpre[i] = (pre[i] + cnt[i]) % mo;\n\t\t\tpre2[i] = (pre2[i] + cnt2[i]) % mo;\n\t\t}\n\t\telse {\n\t\t\tpre[i] = (pre[i] - cnt[i]) % mo;\n\t\t\tpre2[i] = (pre2[i] - cnt2[i]) % mo;\n\t\t}\n\t}\n\tll ans = 0;\n\th[tj(0)] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tpre[i] = (pre[i] + mo) % mo;\n\t\tpre2[i] = (pre2[i] + mo) % mo;\n\t\tans += h[make_pair(pre[i], pre2[i])];\n\t\th[tj(i)] ++;\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\nint modpow(int x, int k, int MOD) {\n  int a = 1;\n  while (k) {\n    if (k&1) a = (1LL*a*x)%MOD;\n    x = (1LL*x*x)%MOD;\n    k>>=1;\n  }\n  return a;\n}\nconst int B = 3213212;\n// <= INT_MAX/2\nconst vector<int> hashes = {\n  1000000007,\n  1000000009,\n};\nstruct Hash {\n  vector<int> data;\n  Hash(int x) {\n    data.resize(hashes.size(), 0);\n    rep(i, hashes.size()) data[i] = ((x%hashes[i])+hashes[i])%hashes[i];\n  }\n  Hash() : Hash(0) {}\n};\nHash operator+(const Hash &a, const Hash &b) {\n  Hash ret;\n  rep(i, hashes.size()) ret.data[i] = (0LL+a.data[i]+b.data[i]) % hashes[i];\n  return ret;\n}\nHash operator*(Hash a, Hash b) {\n  rep(i, hashes.size()) a.data[i] = (1LL*a.data[i]*b.data[i]) % hashes[i];\n  return a;\n}\nHash inv(Hash a) {\n  Hash ret;\n  rep(i, hashes.size()) ret.data[i] = modpow(a.data[i], hashes[i]-2, hashes[i]);\n  return ret;\n}\n\n\nint N;\nstring S;\nHash pB[500001];\nHash memo[250000];\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  pB[0] = Hash(1);\n  for (int i=1; i<=500000; i++) pB[i] = pB[i-1] * B;\n\n  cin >> N >> S;\n  int p = 250000;\n  Hash hash(0);\n  map<vector<int>, int> mp;\n  rep(i, N) {\n    if (S[i] == '+') hash = hash + pB[p];\n    if (S[i] == '-') hash = hash + pB[p] * Hash(-1);\n    if (S[i] == '>') p++;\n    if (S[i] == '<') p--;\n    memo[i] = hash;\n    mp[hash.data]++;\n  }\n\n  const Hash ONE = pB[250000];\n  Hash invB = inv(B);\n  long long sum = 0;\n\n  Hash a(1), b(0); // h -> h*a+b\n  rep(l, N) {\n    Hash h = hash*a + b;\n    sum += mp[h.data];\n\n    if (S[l] == '+') b = b + a*ONE; // all -= ONE\n    if (S[l] == '-') b = b + a*(ONE*Hash(-1)); // all += ONE\n    if (S[l] == '>') a = a * B; // all /= B\n    if (S[l] == '<') a = a * invB; // all *= B\n    mp[memo[l].data]--;\n  }\n  cout << sum << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define y1 dmytxdy\n#define fi first\n#define se second\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef long double ld;\n\ntemplate <typename T> bool chkmin(T &x,T y){return x>y?x=y,1:0;}\ntemplate <typename T> bool chkmax(T &x,T y){return x<y?x=y,1:0;}\n\nint readint(){\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nconst int cys=1000000007,N=50;\nint n;\nll a[250005],b[250005],pw[250005],ipw[250005];\nunordered_map<ll,int> bk;\nmap<ll,ll> occ;\nchar s[250005];\n\nll mod(ll x){return x>=cys?x-cys:x;}\n\nll qpow(ll x,ll p){\n\tll ret=1;\n\tfor(;p;p>>=1,x=x*x%cys) if(p&1) ret=ret*x%cys;\n\treturn ret;\n}\n\nint main(){\n\tn=readint();\n\tscanf(\"%s\",s+1);\n\tfor(int i=1;i<=n;i++) b[i]=b[i-1]+(s[i]=='>')-(s[i]=='<');\n\tfor(int ct=1;ct<=N;ct++){\n\t\tll ax=(1ll*rand()*RAND_MAX+rand())%cys,bx=qpow(ax,cys-2),p=1,now=0;\n\t\tpw[0]=ipw[0]=1;\n\t\tfor(int i=1;i<=n;i++) pw[i]=pw[i-1]*ax%cys;\n\t\tfor(int i=1;i<=n;i++) ipw[i]=ipw[i-1]*bx%cys;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(s[i]=='+') now=mod(now+p);\n\t\t\telse if(s[i]=='-') now=mod(now+cys-p);\n\t\t\telse if(s[i]=='<') p=p*bx%cys;\n\t\t\telse if(s[i]=='>') p=p*ax%cys;\n\t\t}\n\t\ta[n+1]=0;\n\t\tfor(int i=n;i>=1;i--){\n\t\t\tif(s[i]=='+') a[i]=mod(a[i+1]+1);\n\t\t\telse if(s[i]=='-') a[i]=mod(a[i+1]+cys-1);\n\t\t\telse if(s[i]=='<') a[i]=a[i+1]*bx%cys;\n\t\t\telse if(s[i]=='>') a[i]=a[i+1]*ax%cys;\n\t\t}\n\t\tfor(int i=1;i<=n;i++) a[i]=a[i]*(b[i-1]>0?pw[b[i-1]]:ipw[-b[i-1]])%cys;\n\t\tll ans=0;\n\t\tbk.clear();\n\t\tbk[0]++;\n\t\tfor(int i=n;i>=1;i--){\n\t\t\tans+=bk[mod(a[i]+cys-now*(b[i-1]>0?pw[b[i-1]]:ipw[-b[i-1]])%cys)];\n\t\t\tbk[a[i]]++;\n\t\t}\n\t\tocc[ans]++;\n\t}\n\tll maxa=0,res=0;\n\tfor(auto x:occ) if(chkmax(maxa,x.se)) res=x.fi;\n\tprintf(\"%lld\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<iostream>\n#define LL long long\nusing namespace std;\nconst LL mod=1e9+7;\nLL base=2333,pre[500010],inv;\nstruct node{LL a,b;}op[250010];\nmap<LL,LL> mp;\nLL pow(LL a,LL b)\n{\n\tLL ans=1;\n\twhile(b)\n\t{\n\t\tif(b&1) ans=ans*a%mod;\n\t\ta=a*a%mod;b>>=1;\n\t}\n\treturn ans;\n}\nLL n,p=0,t[500010],c=0,a[250010],b[250010];\nchar s[250010];\nvoid Pre()\n{\n\tLL cnt=1;op[n+1].a=1;\n\tfor(LL i=n;i>=1;i--)\n\t{\n\t\top[i]=op[i+1];\n\t\tif(s[i]=='<') cnt=cnt*base%mod,(op[i].a*=base)%=mod;\n\t\tif(s[i]=='>') cnt=cnt*inv%mod,(op[i].a*=inv)%=mod;\n\t\tif(s[i]=='-') (op[i].b+=cnt*pre[n]%mod)%=mod;\n\t\tif(s[i]=='+') op[i].b=((op[i].b-cnt*pre[n]%mod)%mod+mod)%mod;\n\t}\n}\nvoid solve(LL *a,LL c) {for(LL i=1;i<=n;i++) a[i]=(c*op[i].a%mod+op[i].b)%mod;}\nint main()\n{\n\tinv=pow(base,mod-2);\n\tscanf(\"%lld\",&n);getchar();\n\tscanf(\"%s\",s+1);\n\tpre[0]=1;for(LL i=1;i<=2*n;i++) pre[i]=pre[i-1]*base%mod;\n\tfor(LL i=1;i<=n;i++)\n\t{\n\t\tif(s[i]=='<') p--;if(s[i]=='>') p++;\n\t\tif(s[i]=='-') t[p+n]--;if(s[i]=='+') t[p+n]++;\n\t}\n\tfor(LL i=-n;i<=n;i++) (c+=pre[i+n]*t[i+n]%mod)%=mod;\n\tPre();\n\tsolve(a,0);solve(b,c);\n\tLL ans=0;\n\t//printf(\"c:%lld\\n\",c);\n\t//for(int i=1;i<=n;i++) printf(\"op:%lld %lld\\n\",op[i].a,op[i].b);\n\t//for(LL i=-n;i<=n;i++) printf(\"%lld:%lld %lld\\n\",i,t[i+n],pre[i+n]);printf(\"\\n\");\n\t//printf(\"a:\");for(int i=1;i<=n;i++) printf(\"%lld \",a[i]);printf(\"\\n\");\n\t//printf(\"b:\");for(int i=1;i<=n;i++) printf(\"%lld \",b[i]);printf(\"\\n\");\n\t//mp[c]++;\n\tfor(LL i=2;i<=n;i++)\n\t{\n\t\tmp[b[i-1]]++;\n\t\tans+=mp[a[i]];\n\t}\n\tmp[b[n]]++;\n\tans+=mp[0];\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\nconst ll p=1e9+9;\nconst int base=250001;\nunordered_map<ll,int> mp;\nint n,dig[250005];\nll pw[250005]={1},hsh[250005],ans;\nchar s[250005];\nll qpow(ll a,ll b){\n    ll res=1;\n    while(b){\n        if(b&1)\n            res=res*a%p;\n        a=a*a%p;\n        b>>=1;\n    }\n    return res;\n}\nll power(ll x){\n    return x>=0?pw[x]:qpow(pw[-x],p-2);\n}\nint main(){\n    ios::sync_with_stdio(false);\n    ll val;\n    int i;\n    cin>>n>>s+1;\n    for(i=1;i<=n;i++)\n        pw[i]=pw[i-1]*base%p;\n    for(i=1;i<=n;i++){\n        switch(s[i]){\n            case '+':\n                dig[i]=dig[i-1];\n                hsh[i]=(hsh[i-1]+power(dig[i]))%p;\n                break;\n            case '-':\n                dig[i]=dig[i-1];\n                hsh[i]=(hsh[i-1]-power(dig[i])+p)%p;\n                break;\n            case '<':\n                dig[i]=dig[i-1]+1;\n                hsh[i]=hsh[i-1];\n                break;\n            case '>':\n                dig[i]=dig[i-1]-1;\n                hsh[i]=hsh[i-1];\n        }\n    }\n    for(i=0;i<=n;i++){\n        if(mp.count(hsh[i]))\n            ans+=mp[hsh[i]];\n        val=(hsh[i]+hsh[n]*power(dig[i]))%p;\n        if(mp.count(val))\n            mp[val]++;\n        else\n            mp[val]=1;\n    }\n    cout<<ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nЗАПУСКАЕМ \n░ГУСЯ░▄▀▀▀▄░РАБОТЯГУ░░\n▄███▀░◐░░░▌░░░░░░░\n░░░░▌░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▌░░░░░▐▄▄░░░░░\n░░░░▌░░░░▄▀▒▒▀▀▀▀▄\n░░░▐░░░░▐▒▒▒▒▒▒▒▒▀▀▄\n░░░▐░░░░▐▄▒▒▒▒▒▒▒▒▒▒▀▄\n░░░░▀▄░░░░▀▄▒▒▒▒▒▒▒▒▒▒▀▄\n░░░░░░▀▄▄▄▄▄█▄▄▄▄▄▄▄▄▄▄▄▀▄\n░░░░░░░░░░░▌▌░▌▌░░░░░\n░░░░░░░░░░░▌▌░▌▌░░░░░\n░░░░░░░░░▄▄▌▌▄▌▌░░░░░ \n */\n#include <iostream>\n#include <complex>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <iomanip>\n#include <deque>\n    \n     \nusing namespace std;\ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; } \ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const pair<T, U> &_p) { _out << _p.first << ' ' << _p.second; return _out; }\ntemplate<typename T, typename U> inline istream &operator>> (istream &_in, pair<T, U> &_p) { _in >> _p.first >> _p.second; return _in; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const vector<T> &_v) { if (_v.empty()) { return _out; } _out << _v.front(); for (auto _it = ++_v.begin(); _it != _v.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline istream &operator>> (istream &_in, vector<T> &_v) { for (auto &_i : _v) { _in >> _i; } return _in; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const set<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const multiset<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const unordered_set<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const unordered_multiset<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const map<T, U> &_m) { if (_m.empty()) { return _out; } _out << '(' << _m.begin()->first << \": \" << _m.begin()->second << ')'; for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) { _out << \", (\" << _it->first << \": \" << _it->second << ')'; } return _out; }\ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const unordered_map<T, U> &_m) { if (_m.empty()) { return _out; } _out << '(' << _m.begin()->first << \": \" << _m.begin()->second << ')'; for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) { _out << \", (\" << _it->first << \": \" << _it->second << ')'; } return _out; }\n#define sz(c) (int)(c).size()\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define left left228\n#define right right228\n#define next next228\n#define rank rank228\n#define prev prev228\n#define y1 y1228                                                         \n#define read(FILENAME) freopen((FILENAME + \".in\").c_str(), \"r\", stdin)\n#define write(FILENAME) freopen((FILENAME + \".out\").c_str(), \"w\", stdout)\n#define files(FILENAME) read(FILENAME), write(FILENAME)\n#define pb push_back\n#define x first\n#define y second\nconst string FILENAME = \"input\";\nconst long long Mod = 1000000000000000031LL;\nconst long long b = 1000000000000000003LL;\nconst long long rb = 821428571428571454LL;\nconst int MAXN = 250228;\n\n\nlong long mul(long long a, long long b) {\n    return (__int128)a * b % Mod;\n}\n\n\nlong long sum(long long a, long long b){\n    return (a + b) % Mod;\n}\n\n\nlong long pow(long long a, long long b) {\n    long long s = 1;\n    while (b) {\n        if (b & 1) {\n            s = mul(s, a);\n        }\n        a = mul(a, a);\n        b >>= 1;\n    }\n    return s;\n}\n\n\nint n;\nstring s;\nlong long p[MAXN], st[MAXN];\nmap<long long, int> m;\n\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    //read(FILENAME);\n    cin >> n;\n    cin >> s;\n    s = \"#\" + s;\n    p[0] = 1;\n    for (int i = 1; i <= n; i++) {\n        p[i] = p[i - 1];\n        st[i] = st[i - 1];\n        switch(s[i]) {\n            case '+': st[i] = sum(st[i], p[i]); break;\n            case '-': st[i] = sum(st[i], Mod - p[i]); break;\n            case '>': p[i] = mul(p[i], b); break;\n            case '<': p[i] = mul(p[i],rb); break;\n        }\n    }\n    long long ans = 0;\n    for (int i = n; i > 0; i--) {\n        m[st[i]]++;\n        ans += m[sum(mul(st[n], p[i - 1]), st[i - 1])];\n    }\n    cout << ans << '\\n';\n    return 0;\n}        \n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000087;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\ntypedef pair<int, bool> sP;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef pair<ll, ll> LP;\ntypedef vector<ll> vec;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef vector<vector<ll>> mat;\ntypedef vector<ll> vec;\n\nll r = 998244853;\nll mod_pow(ll x, ll n) {\n  if(n<0){\n    return mod_pow(mod_pow(x,-n),mod-2);\n  }\n\tll res = 1;\n\twhile (n) {\n\t\tif (n % 2)res = res * x%mod;\n\t\tx = x * x%mod; n >>= 1;\n\t}\n\treturn res;\n}\nll invr = mod_pow(r, mod-2);\n\nll tr[300000];\nll invtr[300000];\nvoid init() {\n\ttr[0] = invtr[0] = 1;\n\trep(i, 299999) {\n\t\ttr[i + 1] = tr[i] * r%mod;\n\t\tinvtr[i + 1] = invtr[i] * invr%mod;\n\t}\n}\n\nvoid solve() {\n\tint n; cin >> n;\n\tstring s; cin >> s;\n\tll sum = 0; int loc = 0;\n\tvector<ll> memo(n);\n\tvector<int> locs(n);\n\trep(i, n) {\n\t\tif (s[i] == '>')loc++;\n\t\telse if (s[i] == '<')loc--;\n\t\telse if (s[i] == '+') {\n          sum+=mod_pow(r,loc);\n\t\t}\n\t\telse {\n          sum-=mod_pow(r,loc);\n\t\t}\n\t\tsum = (sum%mod + mod) % mod;\n\t\tmemo[i] = sum;\n\t\tlocs[i] = loc;\n\t}\n\tll all = sum;\n\t//cout << all << endl;\n\tll ans = 0;\n\tmap<ll, int> mp;\n\tmp[all]++;\n\trep(i, n) {\n\t\t//cout << mp[memo[i]] << endl;\n\t\tans += mp[memo[i]];\n\t\tll nex = all*mod_pow(r,locs[i])%mod;\n\t\tnex += memo[i];\n\t\tnex %= mod;\n\t\tmp[nex]++;\n\t}\n\tcout << ans << endl;\n}\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(7);\n\tinit();\n\t//output_tree(10);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for (int i = (a); i <= (b); ++ i)\n#define rrp(i,a,b) for (int i = (a); i >= (b); -- i)\n#define gc() getchar()\n#define fir first\n#define sec second\ntypedef pair<int,int> pii;\ntypedef long double db;\ntypedef long long ll;\ntemplate <typename tp>\ninline void read(tp& x) {\n  x = 0; char tmp; bool key = 0;\n  for (tmp = gc(); !isdigit(tmp); tmp = gc())\n    key = (tmp == '-');\n  for (; isdigit(tmp); tmp = gc())\n    x = (x << 3) + (x << 1) + (tmp ^ '0');\n  if (key) x = -x;\n}\ntemplate <typename tp>\ninline void ckmn(tp& x,tp y) {\n  x = x < y ? x : y;\n}\ntemplate <typename tp>\ninline void ckmx(tp& x,tp y) {\n  x = x < y ? y : x;\n}\n\nconst int N = 250010, MOD[2] = {(int)(1e9 + 7), 998244353}, BAS = 233;\ninline void Add(int& x,int y,int mod) {\n  x = x + y >= mod ? x + y - mod : x + y;\n}\ninline void Sub(int& x,int y,int mod) {\n  x = x - y < 0 ? x - y + mod : x - y;\n}\nint power(int a,int b,int mod) {\n  int ret = 1;\n  while (b) {\n    if (b&1) ret = 1ll * ret * a % mod;\n    a = 1ll * a * a % mod;\n    b >>= 1;\n  }\n  return ret;\n}\n\nchar str[N];\nint n, rec[2], val[2][N][2], tmp[2][N][2];\nll ans;\nmap<pii,int> mp;\nvoid solve(int l,int r) {\n  if (l == r) {\n    if (val[1][l][0] == rec[0] && val[1][l][1] == rec[1])\n      ++ ans;\n    return;\n  }\n  int mid = (l + r) >> 1;\n  mp.clear();\n  rep (k, 0, 1) {\n    tmp[0][mid][k] = val[0][mid][k], tmp[1][mid][k] = val[1][mid][k];\n    rrp (i, mid-1, l) {\n      tmp[0][i][k] = 1ll * val[0][i][k] * tmp[0][i+1][k] % MOD[k];\n      tmp[1][i][k] = (1ll * val[0][i][k] * tmp[1][i+1][k] + val[1][i][k]) % MOD[k];\n    }\n    tmp[0][mid+1][k] = val[0][mid+1][k], tmp[1][mid+1][k] = val[1][mid+1][k];\n    rep (i, mid+2, r) {\n      tmp[0][i][k] = 1ll * tmp[0][i-1][k] * val[0][i][k] % MOD[k];\n      tmp[1][i][k] = (1ll * tmp[0][i-1][k] * val[1][i][k] + tmp[1][i-1][k]) % MOD[k];\n    }\n  }\n  rep (i, mid+1, r) ++ mp[pii(tmp[1][i][0], tmp[1][i][1])];\n  rep (i, l, mid) {\n    // tmp[0][i] * v + tmp[1][i] = rec\n    int v0 = rec[0];\n    Sub(v0, tmp[1][i][0], MOD[0]);\n    v0 = 1ll * v0 * power(tmp[0][i][0], MOD[0] - 2, MOD[0]) % MOD[0];\n    int v1 = rec[1];\n    Sub(v1, tmp[1][i][1], MOD[1]);\n    v1 = 1ll * v1 * power(tmp[0][i][1], MOD[1] - 2, MOD[1]) % MOD[1];\n    ans += mp[pii(v0, v1)];\n  }\n  solve(l, mid);\n  solve(mid+1, r);\n}\nint main() {\n  read(n);\n  scanf(\"%s\", str+1);\n  rep (k, 0, 1) {\n    rep (i, 1, n) {\n      if (str[i] == '+') val[0][i][k] = 1, val[1][i][k] = 1;\n      if (str[i] == '-') val[0][i][k] = 1, val[1][i][k] = MOD[k] - 1;\n      if (str[i] == '<') val[0][i][k] = BAS;\n      if (str[i] == '>') val[0][i][k] = power(BAS, MOD[k] - 2, MOD[k]);\n    }\n    rrp (i, n, 1)\n      rec[k] = (1ll * rec[k] * val[0][i][k] + val[1][i][k]) % MOD[k];\n  }\n  solve(1, n);\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define inf 0x3f3f3f3f\n#define m_k make_pair\n#define p1 1000000007\n#define p2 91815541\n#define base 517619\n#define delta 250001\n#define ll long long\nusing namespace std;\nconst int N=250100;\nint n,pos,a[N*2],l,r;\nll ans;\nchar s[N];\nstruct Hash\n{\n\tll a,b;\n\tvoid print()\n\t{\n\t\tprintf(\"%lld %lld\\n\",a,b);\n\t}\n}z[N*2];\nHash h[N*2],now,add;\nmap <Hash,int> mp;\ninline ll m_pow(ll a,int b,int mod)\n{\n\tll ans=1;\n\twhile (b)\n\t{\n\t\tif (b&1) ans=(ans*a)%mod;\n\t\tb>>=1;\n\t\ta=(a*a)%mod;\n\t}\n\treturn ans;\n}\nbool operator <(Hash a,Hash b){return(a.a<b.a || (a.a==b.a && a.b<b.b));}\nHash operator -(Hash a,Hash b){a.a=(a.a-b.a+p1)%p1;a.b=(a.b-b.b+p2)%p2;return a;}\nHash operator +(Hash a,Hash b){a.a=(a.a+b.a)%p1;a.b=(a.b+b.b)%p2;return a;}\nHash operator *(Hash a,Hash b){a.a=(a.a*b.a)%p1;a.b=(a.b*b.b)%p2;return a;}\nHash operator *(Hash a,ll b){a.a=(a.a*b)%p1;a.b=(a.b*b)%p2;return a;}\nHash operator +(Hash a,ll b){a.a=(a.a+b%p1)%p1;a.b=(a.b+b%p2)%p2;return a;}\nHash operator -(Hash a,ll b){a.a=(a.a-b%p1+p1)%p1;a.b=(a.b-b%p2+p2)%p2;return a;}\nHash operator /(Hash a,Hash b)\n{\n\ta.a=(a.a*m_pow(b.a,p1-2,p1))%p1;\n\ta.b=(a.b*m_pow(b.b,p2-2,p2))%p2;\n\treturn a;\n}\nsigned main()\n{\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",s+1);\n\tpos=250000;l=inf;r=0;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tl=min(l,pos);r=max(r,pos);\n\t\tif (s[i]=='+') a[pos]++;\n\t\tif (s[i]=='-') a[pos]--;\n\t\tif (s[i]=='>') pos++;\n\t\tif (s[i]=='<') pos--;\n\t}\n\tz[0].a=1;z[0].b=1;\n\tfor (int i=1;i<=r;i++) z[i]=z[i-1]*base;\n\tpos=250000;\n//\tfor (int i=l;i<=r;i++) add=add+z[i]*delta;\n//\tfor (int i=l;i<=r;i++) h[0]=h[0]+z[i]*delta;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\th[i]=h[i-1];\n\t\tif (s[i]=='+') h[i]=h[i]+z[pos];\n\t\tif (s[i]=='-') h[i]=h[i]-z[pos];\n\t\tif (s[i]=='>') pos++;\n\t\tif (s[i]=='<') pos--;\n\t}\n\tnow=h[n];h[0].a=h[0].b=0;\n\tfor (int i=1;i<=n;i++) mp[h[i]]++;\n\tpos=250000;\n\tfor (int i=1;i<=n;i++)\n\t{\n//\t\t(now*z[pos-250000]+h[0]).print();\n\t\tif (pos>250000) ans+=mp[now*z[pos-250000]+h[0]];\n\t\telse ans+=mp[now/z[250000-pos]+h[0]];\n\t\tmp[h[i]]--;\n\t\tif (s[i]=='+') h[0]=h[0]+z[pos];\n\t\tif (s[i]=='-') h[0]=h[0]-z[pos];\n\t\tif (s[i]=='>') pos++;\n\t\tif (s[i]=='<') pos--;\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n// need\n#include <iostream>\n#include <algorithm>\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <unordered_map>\n#include <unordered_set>\n#include <array>\n// stream\n//#include <istream>\n#include <sstream>\n//#include <ostream>\n#include <fstream>\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest& ...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int w_=0; w_<n; ++w_){MACRO_VEC_ROW_Scan(w_, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest& ...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest& ...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& R:c)for(auto& w:R)std::cin>>w;\n// output\n#define OUT(dist) std::cout<<(dist);\n#define FOUT(n, dist) std::cout<<std::fixed<<std::setprecision(n)<<(dist);\n#define SOUT(n, c, dist) std::cout<<std::setw(n)<<std::setfill(c)<<(dist);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(w, n) std::cout<<(w + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(dist) {std::cerr << #dist << \"\\t:\" << (dist) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(w, a, n) for(int w=(a);w<(n);++w)\n#define RFOR(w, a, n) for(int w=(n)-1;w>=(a);--w)\n#define REP(w, n) for(int w=0;w<int(n);++w)\n#define RREP(w, n) for(int w=int(n)-1;w>=0;--w)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<class T> inline T CHMAX(T & a, const T b) { return a = (a < b) ? b : a; }\ntemplate<class T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\n//void CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n// test\ntemplate<class T> using V = std::vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n#define random_shuffle \"USE std::shuffle!\";\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = (1 << 30) - 1;                    // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-10;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T & val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T & val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T> & a, const T & val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>> & a, const T & val) { for (auto& b : a) FILL(b, val); }\n// ------------>8------------------------------------->8------------\n\nll powMod(ll n, ll p, ll mod) {\n\tif (p < 0) p += mod - 1;\n\tn %= mod;\n\tll res = 1;\n\twhile (p) {\n\t\tif (p & 1) (res *= n) %= mod;\n\t\t(n *= n) %= mod;\n\t\tp >>= 1;\n\t}\n\treturn res;\n}\n\nconstexpr int N = 2;\nconstexpr int M[N] = { 1000000009, 1000000021 };\nconstexpr int B = 123457;\n\nstruct Hash {\n\tint val[N];\n\tHash& norm() {\n\t\tREP(i, N) if ((val[i] %= M[i]) < 0) val[i] += M[i];\n\t\treturn *this;\n\t}\n\n\tHash(int x) { REP(i, N) val[i] = x; norm(); }\n\tHash() : Hash(0) {}\n\n\tstatic Hash makePow(int n, int p) {\n\t\tHash res;\n\t\tREP(i, N) res.val[i] = powMod(n, p, M[i]);\n\t\treturn res;\n\t}\n\tstatic Hash makeInv(int x) {\n\t\tHash res;\n\t\tREP(i, N) res.val[i] = powMod(x, M[i] - 2, M[i]);\n\t\treturn res;\n\t}\n\n\tbool operator==(const Hash & r) const { return *this == r; }\n\tbool operator<(const Hash & r) const {\n\t\tREP(i, N) if (this->val[i] != r.val[i]) return this->val[i] < r.val[i];\n\t\treturn false;\n\t}\n\tHash& operator+=(const Hash & r) { REP(i, N) val[i] += r.val[i]; norm(); return *this; }\n\tHash& operator-=(const Hash & r) { REP(i, N) val[i] -= r.val[i]; norm(); return *this; }\n\tHash& operator*=(const Hash & r) { REP(i, N) val[i] *= r.val[i]; norm(); return *this; }\n};\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n);\n\tVAR(std::string, s);\n\n\tHash X;\n\t{\n\t\tint p = 0;\n\t\tREP(i, n) {\n\t\t\t/* */if (s[i] == '+') X += Hash::makePow(B, p);\n\t\t\telse if (s[i] == '-') X -= Hash::makePow(B, p);\n\t\t\telse if (s[i] == '>') ++p;\n\t\t\telse if (s[i] == '<') --p;\n\t\t}\n\t}\n\n\tstd::map<Hash, int> map;\n\t++map[X];\n\tint ans = 0;\n\tHash A;\n\t{\n\t\tint p = 0;\n\t\tREP(i, n) {\n\t\t\t/* */if (s[i] == '+') A += Hash::makePow(B, p);\n\t\t\telse if (s[i] == '-') A -= Hash::makePow(B, p);\n\t\t\telse if (s[i] == '>') ++p;\n\t\t\telse if (s[i] == '<') --p;\n\t\t\tans += map[A];\n\t\t\t{\n\t\t\t\tauto tX(X);\n\t\t\t\ttX *= Hash::makePow(B, p);\n\t\t\t\ttX += A;\n\t\t\t\t++map[tX];\n\t\t\t}\n\t\t}\n\t}\n\tOUT(ans)BR;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//teja349\n#include <bits/stdc++.h>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <utility>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <iomanip> \n//setbase - cout << setbase (16); cout << 100 << endl; Prints 64\n//setfill -   cout << setfill ('x') << setw (5); cout << 77 << endl; prints xxx77\n//setprecision - cout << setprecision (14) << f << endl; Prints x.xxxx\n//cout.precision(x)  cout<<fixed<<val;  // prints x digits after decimal in val\n\nusing namespace std;\n#define f(i,a,b) for(i=a;i<b;i++)\n#define rep(i,n) f(i,0,n)\n#define fd(i,a,b) for(i=a;i>=b;i--)\n#define pb push_back\n#define mp make_pair\n#define vi vector< int >\n#define vl vector< ll >\n#define ss second\n#define ff first\n#define ll long long\n#define pii pair< int,int >\n#define pll pair< ll,ll >\n#define sz(a) a.size()\n#define inf (1000*1000*1000+5)\n#define all(a) a.begin(),a.end()\n#define tri pair<int,pii>\n#define vii vector<pii>\n#define vll vector<pll>\n#define viii vector<tri>\n#define mod (998244353)\n#define pqueue priority_queue< int >\n#define pdqueue priority_queue< int,vi ,greater< int > >\n\n//std::ios::sync_with_stdio(false);   \nll ans10[512345],ans13[512345],powe13[512345],powe10[512345],invpowe10[512345];\nll invpowe13[512345],inv[1234],p[512345];\nll extend_gcd(ll a,ll b,ll &x,ll &y){\n\tif(b==0){\n\t\tx=1;\n\t\ty=0;\n\t\treturn a;\n\t}\n\tll x1,y1;\n\tll ans =extend_gcd(b,a%b,x1,y1);\n\tx=y1;\n\ty=x1-(a/b)*y1;\n\n\treturn ans;\n}\nmap<ll,ll> seti10,seti13; \nint main(){\n    std::ios::sync_with_stdio(false);\n    ll n;\n    cin>>n;\n    string s;\n    cin>>s;\n    ll i;\n    ll initp=250003;\n    powe10[0]=1;\n    powe13[0]=1;\n    invpowe10[0]=1;\n    invpowe13[0]=1;\n    f(i,1,100){\n\t\tll x,y;\n\t\tll val=extend_gcd(mod,i,x,y);\n\t\tif(y>0)\n\t\t\tinv[i]=y%mod;\n\t\telse{\n\t\t\t\tinv[i]=(y+mod)%mod;\n\t\t}\n\t}\n\tll inv10=inv[10];\n\tll inv13=inv[13];\n    f(i,1,512345){\n    \tpowe13[i]=powe13[i-1]*13;\n    \tpowe10[i]=powe10[i-1]*10;\n    \tpowe10[i]%=mod;\n    \tpowe13[i]%=mod;\n    \tinvpowe10[i]=invpowe10[i-1]*inv10;\n    \tinvpowe10[i]%=mod;\n    \tinvpowe13[i]=invpowe13[i-1]*inv13;\n    \tinvpowe13[i]%=mod;\n    }\n    ans10[0]=0;\n    ans13[0]=0;\n    p[0]=initp;\n    \n    f(i,1,s.length()+1){\n    \tans10[i]=ans10[i-1];\n    \tans13[i]=ans13[i-1];\n    \tp[i]=p[i-1];\n    \tif(s[i-1]=='+'){\n    \t\tans10[i]=ans10[i-1]+powe10[p[i]];\n    \t\tans13[i]=ans13[i-1]+powe13[p[i]];\n\n    \t}\n    \telse if(s[i-1]=='-'){\n    \t\tans10[i]=ans10[i-1]-powe10[p[i]];\n    \t\tans13[i]=ans13[i-1]-powe13[p[i]];\n    \t}\n    \telse if(s[i-1]=='<'){\n    \t\tp[i]--;\n    \t}\n    \telse{\n    \t\tp[i]++;\n    \t}\n    \tans10[i]%=mod;\n    \tans10[i]+=mod;\n    \tans10[i]%=mod;\n    \tans13[i]%=mod;\n    \tans13[i]+=mod;\n    \tans13[i]%=mod;\n    \tseti13[ans13[i]]++;\n    \tseti10[ans10[i]]++;\n    \t//cout<<ans10[i]<<\" \"<<ans13[i]<<endl;\n    }\n    ll val,val1,j10,j13;\n    ll total=0;\n    f(i,1,n+1){\n    \tval=initp-p[i-1];\n    \tval*=-1;\n    \tif(val>=0){\n    \t\tval1=powe13[val];\n    \t\tval=powe10[val];\n    \t\t  \n    \t}\n    \telse{\n    \t\tval1=invpowe13[val];\n    \t\tval=invpowe10[val];\n    \t}\n    \tj10=ans10[n]*val;\n    \tj10%=mod;\n    \tj10+=ans10[i-1];\n    \tj13=ans13[n]*val1;\n    \tj13%=mod;\n    \tj13+=ans13[i-1];\n    \tj10%=mod;\n    \tj13%=mod;\n    \ttotal+=min(seti10[j10],seti13[j13]);\n        assert(seti10[j10]==seti13[j13]);\n    \tseti13[ans13[i]]--;\n    \tseti10[ans10[i]]--;\n    }\n    cout<<total<<endl;\n\n\n\n\n    return 0;  \n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <map>\n#include <list>\n#include <iterator>\n#include <set>\n#include <queue>\n#include <iostream>\n#include <sstream>\n#include <stack>\n#include <deque>\n#include <cmath>\n#include <memory.h>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <algorithm>\n#include <utility>\n#include <time.h>\n#include <bitset>\n#include <assert.h>\n#include <complex.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(int i=(a)-1;i>=(b);--i)\n#define FILL(A,val) memset(A,val,sizeof(A))\n\n#define ALL(V) V.begin(),V.end()\n#define SZ(V) (int)V.size()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long Int;\ntypedef unsigned long long UInt;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double Pi = acos(-1.0);\nconst int INF = 1000000000;\nconst int MAX = 510007;\nconst int MAXE = 2007000;\nconst int MAXV = 5000;\nconst int BASE = 1000000000;\nconst int ST = 1000000007;\n\nconst int MOD1 = 982450121;\nconst int MOD2 = 982453291;\n\nint p1 = 1000003;\nint p2 = 15484769;\n\nInt H1[MAX];\nInt H2[MAX];\nint delta[MAX];\n\n\nInt pw1[MAX];\nInt pw2[MAX];\n\nint main()\n{\n    //freopen(\"in.txt\", \"r\", stdin);\n    \n    pw1[0] = 1;\n    pw2[0] = 1;\n    FOR(i,1,MAX)\n    {\n        pw1[i] = pw1[i - 1] * p1 % MOD1;\n        pw2[i] = pw2[i - 1] * p2 % MOD2;\n    }\n    \n    int n;\n    cin >> n;\n    string s;\n    cin >> s;\n    \n    H1[0] = 0;\n    H2[0] = 0;\n    delta[0] = n + 1;\n    \n    FOR(i,0,n)\n    {\n        H1[i + 1] = H1[i];\n        H2[i + 1] = H2[i];\n        delta[i + 1] += delta[i];\n        \n        if (s[i] == '<')\n        {\n            delta[i + 1] --;\n        }\n        if (s[i] == '>')\n        {\n            delta[i + 1] ++;\n        }\n        \n        if (s[i] == '+')\n        {\n            H1[i + 1] += pw1[delta[i + 1]];\n            H1[i + 1] %= MOD1;\n            \n            H2[i + 1] += pw2[delta[i + 1]];\n            H2[i + 1] %= MOD2;\n        }\n        \n        if (s[i] == '-')\n        {\n            H1[i + 1] += MOD1 - pw1[delta[i + 1]];\n            H1[i + 1] %= MOD1;\n            \n            H2[i + 1] += MOD2 - pw2[delta[i + 1]];\n            H2[i + 1] %= MOD2;\n        }\n        \n    }\n    \n    int res = 0;\n    \n    map<pair<Int, Int> , int> M;\n   \n    \n    \n    \n    RFOR(i,n,0)\n    {\n        M[MP(H1[i + 1] * pw1[n] % MOD1 , H2[i + 1] * pw2[n] % MOD2)] ++;\n        Int h1 = (H1[n] * pw1[delta[i] - delta[0] + n] + H1[i] * pw1[n]) % MOD1;\n        Int h2 = (H2[n] * pw2[delta[i] - delta[0] + n] + H2[i] * pw2[n]) % MOD2;\n        res += M[MP(h1,h2)];\n    }\n    \n    cout << res << endl;\n    \n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\nconst int   N   = 5e5 + 1;\n\ntypedef pair<int,int>   ii;\ntypedef pair<ii,ii>     pii;\n\nint qpow(int a,int exp,int mod) {\n    if(exp < 0) exp = mod - 1 - exp;\n    int ans = 1;\n    while (exp) {\n        if(exp & 1) ans = ans * a % mod;\n        a = a * a % mod;  exp >>= 1;\n    }\n    return ans;\n}\n\nvoid add(int &a,int b,int mod) {\n    a += b;\n    if(a >= mod)a -= mod;\n    if(a < 0)   a += mod;\n}\n\nint mod[4];\nint n, f[N];\nint H[N][4];\nstring S;\n\nvoid process(int t)   {\n    for(int i = 1 ; i <= n ; ++i)   {\n        H[i][t] = H[i - 1][t];\n        if(S[i - 1] == '+') add(H[i][t], qpow(N,f[i],mod[t]),mod[t]);\n        if(S[i - 1] == '-') add(H[i][t],-qpow(N,f[i],mod[t]),mod[t]);\n    }\n}\n\nmap<pii,int> mp;\n\nsigned main()   {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    cin >> n >> S;\n\n    for(int i = 0 ; i < n ; ++i)    {\n        f[i + 1] = f[i];\n        if(S[i] == '>') f[i + 1]++;\n        if(S[i] == '<') f[i + 1]--;\n    }\n\n    mod[0] = 1e9 + 7;\n    mod[1] = 1e9 + 9;\n    mod[2] = 1e9 + 21;\n    mod[3] = 1e9 + 33;\n\n    process(0);\n    process(1);\n    process(2);\n    process(3);\n\n    mp[pii({H[n][0],H[n][1]},{H[n][2],H[n][3]})] = 1;\n\n    int ans = 0;\n\n    for(int i = 1 ; i <= n ; ++i)   {\n        ans += mp[pii({H[i][0],H[i][1]},{H[i][2],H[i][3]})];\n        int res0 = H[n][0] * qpow(N,f[i],mod[0]) + H[i][0];\n        int res1 = H[n][1] * qpow(N,f[i],mod[1]) + H[i][1];\n        int res2 = H[n][2] * qpow(N,f[i],mod[2]) + H[i][2];\n        int res3 = H[n][3] * qpow(N,f[i],mod[3]) + H[i][3];\n        res0 %= mod[0]; res1 %= mod[1];\n        res2 %= mod[2]; res3 %= mod[3];\n        mp[pii({res0,res1},{res2,res3})]++;\n    }\n\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "        #include \"bits/stdc++.h\"\n        using namespace std;\n         \n        #define MAX 600012\n         \n        int n;\n        char buf[MAX];\n         \n         \n        string s;\n         \n         \n        //#define MOD1 1000000007\n        //#define MOD2 1000000009\n         \n        valarray<long long int> MOD1;\n        valarray<long long int> MOD2;\n        vector<valarray<long long int> > p2;\n        vector<valarray<long long int> > vv;\n        vector<int> ps;\n        map<pair<long long int,long long int>, int> mp;\n        long long int ppow(long long int i, long long int j, long long int MOD) {\n        \tlong long int ret = 1;\n        \twhile (j) {\n        \t\tif (j & 1LL)ret *= i;\n        \t\tif (ret >= MOD)ret %= MOD;\n        \t\tj >>= 1LL;\n        \t}\n        \treturn ret;\n        }\n         \n        valarray<long long int> calc(int dif) {\n        \tvalarray<long long int> ret;\n        \tret.resize(2, 0);\n        \tfor (int j = 0; j < 2; j++) {\n        \t\tif (dif < 0) {\n        \t\t\tret[j]=ppow(ppow(MOD1[j],MOD2[j]-2,MOD2[j]),-dif,MOD2[j]);\n        \t\t}\n        \t\telse {\n        \t\t\tret[j] = ppow(MOD1[j], abs(dif), MOD2[j]);\n        \t\t}\n        \t}\n        \treturn ret;\n        }\n         \n        int main() {\n        \tMOD1.resize(2);\n        \tMOD2.resize(2);\n        \tp2.push_back(valarray<long long int>());\n        \tp2.back().resize(2);\n        \tp2.back()[0] = p2.back()[1] = 1;\n        \tMOD2[0] = 1000000007;\n        \tMOD1[0] = 555522277;\n        \tMOD1[1] = 895612782;\n        \tMOD2[1] = 998244353;\n        \tp2[0] %= MOD2;\n        \tfor (int i = 1; i < MAX; i++) {\n        \t\tp2.push_back((p2.back()*MOD1)%MOD2);\n        \tcin >> n;\n        \tscanf(\"%s\", buf);\n        \ts = buf;\n        \tint pos = MAX/2;\n        \tvalarray<long long int> hs;\n        \ths.resize(2);\n        \ths[0] = hs[1] = 0;\n        \tvv.push_back(hs);\n        \tps.push_back(pos);\n        \tfor (int i = 0; i < s.size(); i++) {\n        \t\tif (s[i] == '<') {\n        \t\t\tpos--;\n        \t\t}\n        \t\tif (s[i] == '>') {\n        \t\t\tpos++;\n        \t\t}\n        \t\tif (s[i] == '+') {\n        \t\t\ths += p2[pos];\n        \t\t}\n        \t\tif (s[i] == '-') {\n        \t\t\ths += MOD2-p2[pos];\n        \t\t}\n        \t\ths %= MOD2;\n        \t\tvv.push_back(hs);\n        \t\tps.push_back(pos);\n        \t}\n        \tlong long int way = 0;\n        \tfor (int i = vv.size() - 1; i >= 0; i--) {\n        \t\tvalarray<long long int> want = (vv[i] + ((vv.back()*calc(-MAX/2+ps[i]))%MOD2))%MOD2;\n        \t\tway += mp[make_pair(want[0], want[1])];\n        \t\tmp[make_pair(vv[i][0],vv[i][1])]++;\n        \t}\n        \tprintf(\"%lld\\n\", way);\n        \treturn 0;\n        }\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MN 250000\n#define mod 1004535809\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nchar s[MN+5];\nmap<int,int> mp;long long ans;\nint n,pw[MN*2+5],invpw[MN*2+5],pos[MN+5],ha[MN+5];\ninline int PW(int x){return x>=0?pw[x]:invpw[-x];} \nint main()\n{\n\tn=read();scanf(\"%s\",s+1);pw[0]=invpw[0]=1;\n\tfor(int i=1;i<=n*2;++i) pw[i]=255555LL*pw[i-1]%mod,invpw[i]=75157990LL*invpw[i-1]%mod;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tif(s[i]=='<'||s[i]=='>') \n\t\t\tpos[i]=pos[i-1]+(s[i]=='<'?-1:1),ha[i]=ha[i-1];\n\t\telse pos[i]=pos[i-1],ha[i]=(ha[i-1]+1LL*(s[i]=='+'?1:mod-1)*pw[pos[i]+n])%mod;\n\t}\n\tfor(int i=n;i;--i)\n\t{\n\t\t++mp[(ha[n]-ha[i]+mod)%mod];\n\t\tans+=mp[(1LL*ha[n]*(mod+1-PW(pos[i-1]))+mod-ha[i-1])%mod];\n\t}\n\tcout<<ans;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,a,b) for(int i=(a);i<(b);i++)\n#define pb push_back\n#define eb emplace_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n\nusing vint=vector<int>;\nusing pint=pair<int,int>;\nusing vpint=vector<pint>;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\ntemplate<class A,class B>\nostream& operator<<(ostream& ost,const pair<A,B>&p){\n    ost<<\"{\"<<p.first<<\",\"<<p.second<<\"}\";\n    return ost;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& ost,const vector<T>&v){\n    ost<<\"{\";\n    for(int i=0;i<v.size();i++){\n        if(i)ost<<\",\";\n        ost<<v[i];\n    }\n    ost<<\"}\";\n    return ost;\n}\n\nstruct ModX{\n    using ull=uint64_t;\n    static const ull mod=(1ll<<61)-1;\n    static const ull MASK30=(1ll<<30)-1;\n    static const ull MASK31=(1ll<<31)-1;\n\n    ull a;\n\n    ModX& s(ull vv){\n        a=vv<mod?vv:vv-mod;\n        return *this;\n    }\n    ModX(ull a=0):a(a%mod){}\n    \n    ModX& operator+=(const ModX& x){return s(a+x.a);}\n    ModX& operator-=(const ModX& x){return s(a+mod-x.a);}\n    ModX& operator*=(const ModX& x){\n        const ull au=a>>31;\n        const ull ad=a&MASK31;\n        const ull bu=x.a>>31;\n        const ull bd=x.a&MASK31;\n        const ull mid=ad*bu+au*bd;\n        const ull midu=mid>>30;\n        const ull midd=mid&MASK30;\n        const ull z=au*bu*2+midu+(midd<<31)+ad*bd;\n        return s((z&mod)+(z>>61));\n    }\n\n    ModX operator+(const ModX &x)const{return ModX(*this)+=x;}\n    ModX operator-(const ModX &x)const{return ModX(*this)-=x;}\n    ModX operator*(const ModX &x)const{return ModX(*this)*=x;}\n\n    bool operator==(const ModX &x)const{return a==x.a;}\n    bool operator!=(const ModX &x)const{return a!=x.a;}\n    bool operator<(const ModX &x)const{return a<x.a;}\n\n    ModX operator-()const{return ModX()-*this;}\n\n    ModX pow(int m){\n        ModX ret=1;\n        ModX n=*this;\n        while(m){\n            if(m&1)ret=ret*n;\n            n=n*n;\n            m>>=1;\n        }\n        return ret;\n    }\n    ModX inv(){\n        return pow(mod-2);\n    }\n};\n\nistream& operator>>(istream& in,const ModX& a){\n    return (in>>a.a);\n}\n\nostream& operator<<(ostream& out,const ModX& a){\n    return (out<<a.a);\n}\nusing xint=ModX;\nconst xint base(119);\nconst int RHSIZE=1111111;\nxint basepow[RHSIZE];\nstruct RHInit{\n    RHInit(){\n        basepow[0]=1;\n        for(int i=1;i<RHSIZE;i++)basepow[i]=basepow[i-1]*base;\n    }\n}RHInitDummy;\n\n\nint N;\nstring S;\nxint H[333333];\nint pos[333333];\n\ninline xint po(int k){\n    if(k>=0)return basepow[k];\n    return basepow[-k].inv();\n}\nsigned main(){\n    cin>>N>>S;\n    H[0]=0;\n    for(int i=0;i<N;i++){\n        if(S[i]=='+'){\n            H[i+1]=H[i]+po(pos[i]);\n            pos[i+1]=pos[i];\n        }\n        else if(S[i]=='-'){\n            H[i+1]=H[i]-po(pos[i]);\n            pos[i+1]=pos[i];\n        }\n        else if(S[i]=='>'){\n            H[i+1]=H[i];\n            pos[i+1]=pos[i]+1;\n        }\n        else{\n            H[i+1]=H[i];\n            pos[i+1]=pos[i]-1;\n        }\n    }\n\n    map<xint,int>cnt;\n    int ans=0;\n    cnt[H[N]]++;\n    for(int i=N-1;i>=0;i--){\n        // (b-a)*po[-pos[i]]==H[N];\n        ans+=cnt[H[N]*po(pos[i])+H[i]];\n        cnt[H[i]]++;\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nchar s[250002];\nint num[8000000],sl[8000000],sr[8000000],nodes;\nint newnode()\n{\n    sl[nodes]=-1;\n    sr[nodes]=-1;\n    return nodes++;\n}\nvoid update(int &id,int il,int ir,int pos)\n{\n    if (id==-1)\n        id=newnode();\n    if (ir-il==1)\n    {\n        ++num[id];\n        return;\n    }\n    int mid=(il+ir)>>1;\n    if (pos<mid)\n        update(sl[id],il,mid,pos);\n    else\n        update(sr[id],mid,ir,pos);\n    ++num[id];\n}\nint query(int id,int il,int ir,int pos)\n{\n    if (id==-1)\n        return 0;\n    if (ir-il==1)\n        return num[id];\n    int mid=(il+ir)>>1;\n    return pos<mid?query(sl[id],il,mid,pos):query(sr[id],mid,ir,pos);\n}\nint pw[500001],prefix[250001],pos[250001];\nconst int MOD=1002068539;\nint qpow(int a,int b)\n{\n    int ret=1;\n    for (;b;a=(long long)a*a%MOD,b>>=1)\n        if (b&1)\n            ret=(long long)ret*a%MOD;\n    return ret;\n}\nint main()\n{\n    int n;\n    scanf(\"%d%s\",&n,s+1);\n    pw[0]=1;\n    for (int i=1;i<=500000;++i)\n        pw[i]=(long long)pw[i-1]*35748299%MOD;\n    pos[0]=0;\n    for (int i=1;i<=n;++i)\n    {\n        prefix[i]=prefix[i-1];\n        pos[i]=pos[i-1];\n        if (s[i]=='<')\n            --pos[i];\n        else if (s[i]=='>')\n            ++pos[i];\n        else if (s[i]=='+')\n        {\n            prefix[i]+=pw[pos[i]+250000];\n            if (prefix[i]>=MOD)\n                prefix[i]-=MOD;\n        }\n        else\n        {\n            prefix[i]-=pw[pos[i]+250000];\n            if (prefix[i]<0)\n                prefix[i]+=MOD;\n        }\n    }\n    int rt=-1;\n    long long ans=0;\n    for (int i=n;i>=1;--i)\n    {\n        int tmp=prefix[n];\n        tmp-=prefix[i];\n        if (tmp<0)\n            tmp+=MOD;\n        update(rt,0,1073741824,tmp);\n        tmp=prefix[n];\n        if (pos[i-1])\n            tmp=(long long)tmp*pw[pos[i-1]]%MOD;\n        else if (pos[i-1]<0)\n            tmp=(long long)tmp*qpow(pw[-pos[i-1]],MOD-2);\n        tmp=prefix[n]-tmp;\n        if (tmp<0)\n            tmp+=MOD;\n        tmp-=prefix[i-1];\n        if (tmp<0)\n            tmp+=MOD;\n        ans+=query(rt,0,1073741824,tmp);\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\ntypedef long long ll; \ninline ll quick_pow(ll a, ll n, ll mod)\n{\n\tll res = 1; \n\twhile (n)\n\t{\n\t\tif (n & 1)\n\t\t\tres = res * a % mod; \n\t\ta = a * a % mod;\n\t\tn >>= 1; \n\t}\n\treturn res; \n}\nstruct data\n{\n\tll arr[5]; \n\tinline ll &operator [](const int &x)\n\t{\n\t\treturn arr[x]; \n\t}\n\tinline const ll &operator [](const int &x) const\n\t{\n\t\treturn arr[x]; \n\t}\n\tinline bool operator <(const data &x) const\n\t{\n\t\tfor (int i = 0; i < 5; i++)\n\t\t{\n\t\t\tif (arr[i] != x[i])\n\t\t\t\treturn arr[i] < x[i]; \n\t\t}\n\t\treturn false; \n\t}\n} hsh[300005], cur; \nconst ll bs[] = {500003, 250001, 250007, 1234567, 34252124}, md[] = {1000000007, 1000000009, 998244353, 1234567891, 2147483647}; \nll pw[5][600005], inv[5][600005]; \nint arr[300005]; \nstd::map<data, int> app; \nchar str[300005]; \nint main()\n{\n\t// freopen(\"ARC099-F.in\", \"r\", stdin); \n\tint n; \n\tscanf(\"%d%s\", &n, str); \n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tpw[i][0] = 1;\n\t\tfor (int j = 1; j < 600005; j++)\n\t\t\tpw[i][j] = pw[i][j - 1] * bs[i] % md[i]; \n\t\tinv[i][0] = 1; \n\t\tint x = quick_pow(bs[i], md[i] - 2, md[i]); \n\t\tfor (int j = 1; j < 600005; j++)\n\t\t\tinv[i][j] = inv[i][j - 1] * x % md[i]; \n\t}\n\tint pos = n + 5; \n\tfor (int i = 0; i <= n; i++)\n\t{\n\t\thsh[i] = cur;\n\t\tarr[i] = pos; \n\t\tswitch (str[i])\n\t\t{\n\t\tcase '+':\n\t\t\tfor (int j = 0; j < 5; j++)\n\t\t\t\tcur[j] = (cur[j] + pw[j][pos]) % md[j]; \n\t\t\tbreak; \n\t\tcase '-':\n\t\t\tfor (int j = 0; j < 5; j++)\n\t\t\t\tcur[j] = (cur[j] - pw[j][pos] + md[j]) % md[j]; \n\t\t\tbreak; \n\t\tcase '<':\n\t\t\tpos--; \n\t\t\tbreak; \n\t\tcase '>':\n\t\t\tpos++;\n\t\t}\n\t}\n\tll ans = 0; \n\tfor (int i = n; i >= 0; i--)\n\t{\n\t\tint diff = arr[i] - n - 5; \n\t\tdata x; \n\t\tif (diff >= 0)\n\t\t{\n\t\t\tfor (int j = 0; j < 5; j++)\n\t\t\t\tx[j] = (hsh[i][j] + cur[j] * pw[j][diff]) % md[j]; \n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (int j = 0; j < 5; j++)\n\t\t\t\tx[j] = (hsh[i][j] + cur[j] * inv[j][-diff]) % md[j];\n\t\t}\n\t\tans += app[x]; \n\t\tapp[hsh[i]]++; \n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define SZ(x) (int((x).size()))\n#define fi first\n#define se second\n#define pb push_back\n#define VI vector<int>\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int maxN=250005;\nconst int mod=1000*1000*1000+7;\nint n,root[5][2],f[5][maxN],g[5][maxN];\npii cof[5][maxN];\nchar str[maxN];\nmap<tuple<int,int,int,int,int>,int>map_cnt;\nint pw(int x,int y){\n  int t=1;\n  for(;y;y>>=1){\n    if(y&1)t=(ll)t*x%mod;\n    x=(ll)x*x%mod;\n  }\n  return t;\n}\nvoid trans(pii&x,pii y,char c,int sed[2]){\n  if(c=='+')x=pii(y.fi,(mod-y.fi+y.se)%mod);\n  if(c=='-')x=pii(y.fi,(y.fi+y.se)%mod);\n  if(c=='>')x=pii((ll)y.fi*sed[0]%mod,y.se);\n  if(c=='<')x=pii((ll)y.fi*sed[1]%mod,y.se);\n}\nint main(){\n  srand(time(0));\n  //freopen(\"aa.in\",\"r\",stdin);\n  int i,j;\n  scanf(\"%d%s\",&n,str+1);\n  for(i=0;i<5;++i){\n    root[i][0]=rand()%(1000*1000*1000);\n    root[i][1]=pw(root[i][0],mod-2);\n    //printf(\"root val %d %d\\n\",root[i][0],root[i][1]);\n    int bas=0;\n    for(j=n;j;--j){\n      if(str[j]=='+')bas=(bas+1)%mod;\n      if(str[j]=='-')bas=(bas+mod-1)%mod;\n      if(str[j]=='>')bas=(ll)bas*root[i][1]%mod;\n      if(str[j]=='<')bas=(ll)bas*root[i][0]%mod;\n    }\n    cof[i][n+1]=pii(1,0);\n    //printf(\"root %d\\n\",i);\n    for(j=n;j;--j){\n      trans(cof[i][j],cof[i][j+1],str[j],root[i]); \n      f[i][j]=cof[i][j].se;\n      g[i][j]=((ll)cof[i][j].fi*bas+cof[i][j].se)%mod;\n      //printf(\"f[%d] g[%d]\\n\",f[i][j],g[i][j]);\n    }\n    //printf(\"g %d %d\\n\",i,g[i][1]);\n  }\n  \n  ll ans=0;\n  map_cnt[make_tuple(0,0,0,0,0)]++;\n  for(i=n;i;--i){\n    //int pre=ans;\n    auto nowg=make_tuple(g[0][i],g[1][i],g[2][i],g[3][i],g[4][i]);\n    ans+=map_cnt[nowg];\n    //if(ans-pre)printf(\"ans %d %d\\n\",i,ans-pre);\n    auto nowf=make_tuple(f[0][i],f[1][i],f[2][i],f[3][i],f[4][i]);\n    map_cnt[nowf]++;\n  }\n  printf(\"%lld\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <cmath>\n#include <cstdio>\n#include <cctype>\n#include <ctime>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <complex>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cwchar>\n#include <cwctype>\n#include <exception>\n#include <locale>\n#include <numeric>\n#include <new>\n#include <stdexcept>\n#include <limits>\n#include <valarray>\n#include <set>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <list>\n#include <utility>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int INF = 1e9 + 7;\n\nconst LL HMOD = 1004535809, HRAD = 3, HIRAD = (HMOD + 1) / HRAD;\nmap<LL, int> S;\nint n;\nchar ch[250005];\nLL tot[250005];\n\nint main()\n{\n\tscanf(\"%d%s\", &n, &ch);\n\tLL cur = 1LL, cnt = 0LL;\n\trep(i, n) {\n\t\tif(ch[i] == '+') cnt = (cnt + cur) % HMOD;\n\t\tif(ch[i] == '-') cnt = (cnt - cur + HMOD) % HMOD;\n\t\tif(ch[i] == '<') cur = cur * HIRAD % HMOD;\n\t\tif(ch[i] == '>') cur = cur * HRAD % HMOD;\n\t\ttot[i] = cnt;\n\t\tS[cnt] ++;\n\t}\n\tLL ss = cnt, ans = S[ss];\n\tcur = 1LL; cnt = 0LL;\n\trep(i, n) {\n\t\tif(ch[i] == '+') cnt = (cnt + cur) % HMOD;\n\t\tif(ch[i] == '-') cnt = (cnt - cur + HMOD) % HMOD;\n\t\tif(ch[i] == '<') cur = cur * HIRAD % HMOD;\n\t\tif(ch[i] == '>') cur = cur * HRAD % HMOD;\n\t\tS[tot[i]] --;\n\t\tans += S[(cnt + cur * ss) % HMOD];\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MP make_pair\n#define fi first\n#define se second\n#define sz(x) (int)(x).size()\n//#define Local\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\nconst int N = 250005, P1 = 1e9 + 7, P2 = 1e9 + 9;\n\nll qpow(ll a, ll b, ll c) {\n    ll ans = 1;\n    while(b) {\n        if(b & 1) ans = ans * a % c;\n        a = a * a % c;\n        b >>= 1;\n    }\n    return ans;\n}\n\nchar s[N];\nint n;\n\nstruct rolling_hash{\n    ll a, b;\n    rolling_hash() {\n        a = b = 0;\n    }\n    rolling_hash(ll x) {\n        a = x % P1;\n        b = x % P2;\n    }\n    rolling_hash(ll x, ll y) {\n        a = x % P1;\n        b = y % P2;\n    }\n    rolling_hash operator + (const rolling_hash& A) const {\n        return rolling_hash(a + A.a, b + A.b);\n    }\n    rolling_hash operator - (const rolling_hash& A) const {\n        return rolling_hash(a - A.a + P1, b - A.b + P2);\n    }\n    rolling_hash operator * (const rolling_hash& A) const {\n        return rolling_hash(a * A.a, b * A.b);\n    }\n    ll get() {\n        return a * P2 + b;\n    }\n}hs[N], pos[N];\n\nrolling_hash X = 1000003;\nrolling_hash invX = rolling_hash(qpow(X.a, P1 - 2, P1), qpow(X.b, P2 - 2, P2));\n\nunordered_map <ll, int> mp;\n\nvoid run() {\n    mp.clear();\n    cin >> s + 1;\n    pos[0] = 1;\n    for(int i = 1; i <= n; i++) {\n        pos[i] = pos[i- 1];\n        if(s[i] == '>') {\n            pos[i] = pos[i - 1] * X;\n        } else if(s[i] == '<') {\n            pos[i] = pos[i - 1] * invX;\n        }\n    }\n    hs[n + 1] = 0;\n    for(int i = n; i >= 1; i--) {\n        hs[i] = hs[i + 1];\n        if(s[i] == '+') {\n            hs[i] = hs[i] + pos[i];\n        } else if(s[i] == '-') {\n            hs[i] = hs[i] - pos[i];\n        }\n    }\n    ll ans = 0;\n    ++mp[hs[n + 1].get()];\n    for(int i = n; i >= 1; i--) {\n        rolling_hash now = hs[i] - hs[1] * pos[i - 1];\n        ans += mp[now.get()];\n        ++mp[hs[i].get()];\n//        cout << ans << '\\n';\n    }\n    cout << ans << '\\n';\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n    cout << fixed << setprecision(20);\n#ifdef Local\n    freopen(\"../input.in\", \"r\", stdin);\n    freopen(\"../output.out\", \"w\", stdout);\n#endif\n    while(cin >> n) run();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define llu unsigned long long\nusing namespace std;\nconst int N=5e5,bas=37;\nint n;\nstruct hash{\n  int mo,ni,f[N],g[N];\n  int fap(int a,int b){\n    int s=1;\n    for (; b; b>>=1,a=1ll*a*a%mo)\n      if (b&1) s=1ll*s*a%mo;\n    return s;\n  }\n  void solve(int x,char c){\n    if (c=='+')\n      g[x]=g[x-1],f[x]=(f[x-1]+g[x])%mo;\n    else if (c=='-')\n      g[x]=g[x-1],f[x]=(f[x-1]+mo-g[x])%mo;\n    else if (c=='<')\n      f[x]=f[x-1],g[x]=1ll*g[x-1]*ni%mo;\n    else\n      f[x]=f[x-1],g[x]=1ll*g[x-1]*bas%mo;\n    return;\n  }\n  int calc(int x){\n    return (1ll*g[x]*f[n]+f[x])%mo;\n  }\n}T[5];\nchar s[N];\nint c[10];\nmap<llu,int>sum;\nint main(){\n  scanf(\"%d%s\",&n,s+1);\n  T[0].mo=998244353,T[0].g[0]=1;\n  T[1].mo=1000000097,T[1].g[0]=1;\n  T[2].mo=1000000007,T[2].g[0]=1;\n  T[3].mo=1000000009,T[3].g[0]=1;\n  T[4].mo=1049219317,T[4].g[0]=1;\n  for (int t=0; t<5; ++t){\n    T[t].ni=T[t].fap(bas,T[t].mo-2);\n    for (int i=1; i<=n; ++i)\n      T[t].solve(i,s[i]);\n  }\n  llu u,v,ans=0;\n  for (int i=n; i>=1; --i){\n    u=v=1;\n    for (int t=0; t<5; ++t)\n      v=v*T[t].f[i],u=u*T[t].calc(i-1);\n    ++sum[v],ans+=sum[u];\n  }\n  cout<<ans;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\n//const ll mod = 1000000087;\n//const ll INF = mod * mod;\ntypedef pair<int, int>P;\ntypedef pair<int, bool> sP;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef pair<ll, ll> LP;\ntypedef vector<ll> vec;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef vector<vector<ll>> mat;\ntypedef vector<ll> vec;\n\n\n\nvector<ll> mods;\nvector<ll> roots;\n\nbool isp(ll x) {\n\tRep1(i,2, 100000) {\n\t\tif (x%i == 0)return false;\n\t}\n\treturn true;\n}\nvoid genmods() {\n\tll sta = 1000010000;\n\twhile (mods.size() < 3) {\n\t\tif (isp(sta))mods.push_back(sta);\n\t\tsta++;\n\t}\n}\nvoid genroots() {\n\tll sta = 2000010000;\n\twhile (roots.size() < 2) {\n\t\tif (isp(sta))roots.push_back(sta);\n\t\tsta++;\n\t}\n}\nll mod_pow(ll x, ll n,ll mod) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n % 2)res = res * x%mod;\n\t\tx = x * x%mod; n >>= 1;\n\t}\n\treturn res;\n}\nvector<ll> invroots;\n\nvector<ll> tr[300000];\nvector<ll> invtr[300000];\nvoid init() {\n\tgenmods();\n\tgenroots();\n\trep(i, 300000) {\n\t\ttr[i].resize(mods.size()*roots.size());\n\t\tinvtr[i].resize(mods.size()*roots.size());\n\t}\n\trep(j, tr[0].size()) {\n\t\ttr[0][j] = invtr[0][j] = 1;\n\t}\n\trep(j, mods.size()) {\n\t\trep(k, roots.size()) {\n\t\t\tinvroots.push_back(mod_pow(roots[k], mods[j] - 2, mods[j]));\n\t\t}\n\t}\n\trep(i, 299999) {\n\t\trep(j, mods.size()) {\n\t\t\trep(k, roots.size()) {\n\t\t\t\tint id = j * roots.size() + k;\n\t\t\t\ttr[i + 1][id] = tr[i][id] * roots[k] % mods[j];\n\t\t\t\tinvtr[i + 1][id] = invtr[i][id] * invroots[id] % mods[j];\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve() {\n\tint n; cin >> n;\n\tstring s; cin >> s;\n\tvector<ll> sum(mods.size()*roots.size(),0); int loc = 0;\n\tvector<vector<ll>> memo(n);\n\trep(i, n)memo[i].resize(mods.size()*roots.size());\n\tvector<int> locs(n);\n\tint len = roots.size()*mods.size();\n\trep(i, n) {\n\t\tif (s[i] == '>')loc++;\n\t\telse if (s[i] == '<')loc--;\n\t\telse if (s[i] == '+') {\n\t\t\tif (loc >= 0) {\n\t\t\t\trep(j, len) {\n\t\t\t\t\tsum[j] += tr[loc][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\trep(j, len) {\n\t\t\t\t\tsum[j] += invtr[-loc][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (loc >= 0) {\n\t\t\t\trep(j, len) {\n\t\t\t\t\tsum[j] -= tr[loc][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\trep(j, len) {\n\t\t\t\t\tsum[j] -= invtr[-loc][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(j, len) {\n\t\t\tll mod = mods[j / roots.size()];\n\t\t\tif (sum[j] < 0)sum[j] += mod;\n\t\t\tif (sum[j] >= mod)sum[j] -= mod;\n\t\t\tmemo[i][j] = sum[j];\n\t\t}\n\n\t\tlocs[i] = loc;\n\t}\n\tvector<ll> alls = sum;\n\tll ans = 0;\n\tvector<unordered_map<ll, int>> mp(len);\n\trep(i, len) {\n\t\tmp[i][alls[i]]++;\n\t}\n\trep(i, n) {\n\t\t//cout << mp[memo[i]] << endl;\n\t\tint mi = 2*n;\n\t\trep(j, len) {\n\t\t\tmi = min(mi, mp[j][memo[i][j]]);\n\t\t}\n\t\tans += mi;\n\t\tbool valid = true;\n\t\t\n\t\trep(j, len) {\n\t\t\tll nex = alls[j];\n\t\t\tll mod = mods[j / roots.size()];\n\t\t\tif (locs[i] >= 0) {\n\t\t\t\tnex = nex * tr[locs[i]][j] % mod;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnex = nex * invtr[-locs[i]][j] % mod;\n\t\t\t}\n\t\t\tnex += memo[i][j];\n\t\t\tif (nex >= mod)nex -= mod;\n\t\t\tmp[j][nex]++;\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(7);\n\tinit();\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n* C++11 code template for contests.\n* @author: Andrei Kalendarov\n* @e-mail: andreykalendarov@gmail.com\n*/\n\n//#define ANDREIKKAA_ALLOCATOR\nconst int _ML = 228;\n\nconst char _inpf[] =\n#if defined(ANDREIKKAA)\n    \"input.txt\"\n#else\n    \"\"\n#endif\n;\nconst char _outf[] =\n#if defined(ANDREIKKAA)\n    \"\"\n#else\n    \"\"\n#endif\n;\n\n#if defined(ANDREIKKAA)\n#undef NDEBUG\n#else\n#pragma GCC optimize(\"O3,no-stack-protector\")\n#endif\n#include <bits/stdc++.h>\n#if !defined(ANDREIKKAA)\n#define endl '\\n'\n#endif\n#define x first\n#define y second\nusing namespace std;\n#define rand abcdefghijklmnopqrstuvwxyz\n#define random_shuffle abcdefghijklmnopqrstuvwxyz\n#define all(x) (x).begin(), (x).end()\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef double ld;\nconst ld PI = 3.14159265358979323846;\nmt19937 rd(228);\n#if defined(ANDREIKKAA_ALLOCATOR)\nchar _mem[_ML * 1024 * 1024];\nsize_t _ptr = 0;\ninline void* operator new (size_t _x) { _ptr += _x; assert(_ptr < _ML * 1024 * 1024); return _mem + _ptr - _x; }\ninline void operator delete (void*) { }\n#endif\ntemplate<class T, class U> inline ostream &operator<< (ostream &, const pair<T, U> &);\ntemplate<class T, class U> inline istream &operator>> (istream &, pair<T, U> &);\ntemplate<class T> inline ostream &operator<< (ostream &, const vector<T> &);\ntemplate<class T> inline istream &operator>> (istream &, vector<T> &);\ntemplate<class T> inline ostream &operator<< (ostream &, const set<T> &);\ntemplate<class T> inline ostream &operator<< (ostream &, const multiset<T> &);\ntemplate<class T> inline ostream &operator<< (ostream &, const unordered_set<T> &);\ntemplate<class T> inline ostream &operator<< (ostream &, const unordered_multiset<T> &);\ntemplate<class T, class U> inline ostream &operator<< (ostream &, const map<T, U> &);\ntemplate<class T, class U> inline ostream &operator<< (ostream &, const unordered_map<T, U> &);\n\n/* ________ CODE ________ */\nconst int X = 229;\n\nstruct hasher {\n    vector<int> pw;\n    int M;\n    int val;\n\n    int add(int a, int b) {\n        return (a + b) % M;\n    }\n\n    int sub(int a, int b) {\n        return (a - b + M) % M;\n    }\n\n    int mul(int a, int b) {\n        return (int)(((ll)a * b) % M);\n    }\n\n    int bp(int a, int b) {\n        int r = 1;\n        while(b) {\n            if(b & 1) {\n                r = mul(r, a);\n            }\n            a = mul(a, a);\n            b >>= 1;\n        }\n        return r;\n    }\n\n    int div(int a, int b) {\n        return mul(a, bp(b, M - 2));\n    }\n\n    hasher(int p, int m, int n) : M(m), val(0) {\n        pw.resize(n);\n        pw[0] = 1;\n        for(int i = 1; i < n; ++i) {\n            pw[i] = (int)((ll)pw[i - 1] * p % m);\n        }\n    }\n\n    void ins(int p, int x) {\n        val = add(val, mul(pw[p], x));\n    }\n\n    void ers(int p, int x) {\n        val = sub(val, mul(pw[p], x));\n    }\n};\n\ninline void _main_function()\n{\n    int n;\n    cin >> n;\n\n    string s;\n    cin >> s;\n\n    vector<int> a(2 * n + 1);\n    int p = n;\n\n    hasher h(1000 * 1000 + 3, 1000 * 1000 * 1000 + 7, sz(a));\n    vector<int> ans = {0};\n\n    for(int i = 0; i < n; ++i) {\n        if(s[i] == '<') {\n            --p;\n        } else if(s[i] == '>') {\n            ++p;\n        } else {\n            h.ers(p, a[p]);\n            if(s[i] == '+') {\n                ++a[p];\n            } else if(s[i] == '-') {\n                --a[p];\n            } else {\n                assert(false);\n            }\n            h.ins(p, a[p]);\n        }\n\n        ans.push_back(h.val);\n    }\n\n    ll sum = 0;\n    map<int, int> cnt;\n    int sh = 0;\n\n    for(int i = 0; i <= n; ++i) {\n        sum += cnt[ans[i]];\n\n        if(i && s[i - 1] == '>') {\n            ++sh;\n        } else if(i && s[i - 1] == '<') {\n            --sh;\n        }\n\n        if(sh >= 0) {\n            int x = h.add(h.mul(ans.back(), h.pw[sh]), ans[i]);\n            ++cnt[x];\n        } else {\n            int x = h.add(h.div(ans.back(), h.pw[-sh]), ans[i]);\n            ++cnt[x];\n        }\n    }\n\n    cout << sum << endl;\n}\n\n/* ________ CODE ________ */\n\nint main()\n{\n#if defined(ANDREIKKAA)\n    time_t _start = clock();\n#endif\n    if (_inpf[0] != '\\0') assert(freopen(_inpf, \"r\", stdin) != nullptr);\n    if (_outf[0] != '\\0') assert(freopen(_outf, \"w\", stdout) != nullptr);\n    cin.tie(nullptr);\n    ios_base::sync_with_stdio(false);\n\n    cout << setprecision(20);\n    //cout << fixed;\n\n    _main_function();\n#if defined(ANDREIKKAA)\n    cout << \"Time: \" << (clock() - _start) / (ld)CLOCKS_PER_SEC << endl;\n#endif\n}\n\ntemplate<class T, class U> inline ostream &operator<< (ostream &_out, const pair<T, U> &_p)\n{\n    _out << _p.x << ' ' << _p.y;\n    return _out;\n}\ntemplate<class T, class U> inline istream &operator>> (istream &_in, pair<T, U> &_p)\n{\n    _in >> _p.x >> _p.y;\n    return _in;\n}\ntemplate<class T> inline ostream &operator<< (ostream &_out, const vector<T> &_v)\n{\n    if (_v.empty()) { return _out; }\n    _out << *_v.begin();\n    for (auto _it = ++_v.begin(); _it != _v.end(); ++_it) { _out << ' ' << *_it; }\n    return _out;\n}\ntemplate<class T> inline istream &operator>> (istream &_in, vector<T> &_v)\n{\n    for (auto &_i : _v) { _in >> _i; }\n    return _in;\n}\ntemplate<class T> inline ostream &operator<< (ostream &_out, const set<T> &_s)\n{\n    if (_s.empty()) { return _out; }\n    _out << *_s.begin();\n    for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; }\n    return _out;\n}\ntemplate<class T> inline ostream &operator<< (ostream &_out, const multiset<T> &_s)\n{\n    if (_s.empty()) { return _out; }\n    _out << *_s.begin();\n    for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; }\n    return _out;\n}\ntemplate<class T> inline ostream &operator<< (ostream &_out, const unordered_set<T> &_s)\n{\n    if (_s.empty()) { return _out; }\n    _out << *_s.begin();\n    for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; }\n    return _out;\n}\ntemplate<class T> inline ostream &operator<< (ostream &_out, const unordered_multiset<T> &_s)\n{\n    if (_s.empty()) { return _out; }\n    _out << *_s.begin();\n    for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; }\n    return _out;\n}\ntemplate<class T, class U> inline ostream &operator<< (ostream &_out, const map<T, U> &_m)\n{\n    if (_m.empty()) { return _out; }\n    _out << '(' << _m.begin()->x << \": \" << _m.begin()->y << ')';\n    for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) { _out << \", (\" << _it->x << \": \" << _it->y << ')'; }\n    return _out;\n}\ntemplate<class T, class U> inline ostream &operator<< (ostream &_out, const unordered_map<T, U> &_m)\n{\n    if (_m.empty()) { return _out; }\n    _out << '(' << _m.begin()->x << \": \" << _m.begin()->y << ')';\n    for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) { _out << \", (\" << _it->x << \": \" << _it->y << ')'; }\n    return _out;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define mod 233\nint n;\nchar s[250005];\nmap<unsigned long long,int>a;\nunsigned long long f[250005],g[250005],inv=1,xx=mod;\nint main(){\n    scanf(\"%d%s\",&n,s+1);\n    for(int i=1;i<=63;i++){\n        inv=inv*xx;\n        xx=xx*xx;\n    }\n    f[0]=0;g[0]=1;\n    for(int i=1;i<=n;i++) {\n        f[i]=f[i-1];g[i]=g[i-1];\n        switch (s[i]){\n            case '+':f[i]+=g[i];break;\n            case '-':f[i]-=g[i];break;\n            case '<':g[i]*=inv;break;\n            case '>':g[i]*=mod;break;\n        }\n        a[f[i]]++;\n    }\n    long long ans=0;\n    for(int i=1;i<=n;i++){\n        ans+=a[f[n]*g[i-1]+f[i-1]];\n        a[f[i]]--;\n    }\n    printf(\"%lld\",ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,ans;\nunsigned long long x1=1,x2=233,xx=233,a[250010],b[250010],t[250010];\nstring st;\nmap<unsigned long long,int>k;\nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<=63;i++)\n\t{\n\t\tx1=x1*x2;\n\t\tx2=x2*x2;\n\t}\n\tcin>>st;\n\tb[0]=1;\n\tfor(int i=0;i<st.size();i++)\n\t{\n\t\tif(i>0)a[i]=a[i-1];\n\t\tif(i>0)b[i]=b[i-1];\n\t\tif(st[i]=='+')a[i]=a[i]+b[i];\n\t\tif(st[i]=='-')a[i]=a[i]-b[i];\n\t\tif(st[i]=='<')b[i]=b[i]*x1;\n\t\tif(st[i]=='>')b[i]=b[i]*x2;\n\t\tk[a[i]]++;\n\t} \n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tans+=k[a[n]*b[i-1]+a[i-1]];\n\t\tk[a[i]]--;\n\t}\n\tcout<<ans;\n\treturn 0; \n} "
  },
  {
    "language": "C++",
    "code": "    #include \"bits/stdc++.h\"\n    using namespace std;\n     \n    #define MAX 600012\n     \n    int n;\n    char buf[MAX];\n     \n     \n    string s;\n     \n     \n    //#define MOD1 1000000007\n    //#define MOD2 1000000009\n     \n    valarray<long long int> MOD1;\n    valarray<long long int> MOD2;\n    vector<valarray<long long int> > p2;\n    vector<valarray<long long int> > vv;\n    vector<int> ps;\n    map<pair<long long int,long long int>, int> mp;\n    long long int ppow(long long int i, long long int j, long long int MOD) {\n    \tlong long int ret = 1;\n    \twhile (j) {\n    \t\tif (j & 1LL)ret *= i;\n    \t\tif (ret >= MOD)ret %= MOD;\n    \t\tj >>= 1LL;\n    \t}\n    \treturn ret;\n    }\n     \n    valarray<long long int> calc(int dif) {\n    \tvalarray<long long int> ret;\n    \tret.resize(2, 0);\n    \tfor (int j = 0; j < 2; j++) {\n    \t\tif (dif < 0) {\n    \t\t\tret[j]=ppow(ppow(MOD1[j],MOD2[j]-2,MOD2[j]),-dif,MOD2[j]);\n    \t\t}\n    \t\telse {\n    \t\t\tret[j] = ppow(MOD1[j], abs(dif), MOD2[j]);\n    \t\t}\n    \t}\n    \treturn ret;\n    }\n     \n    int main() {\n    \tMOD1.resize(2);\n    \tMOD2.resize(2);\n    \tp2.push_back(valarray<long long int>());\n    \tp2.back().resize(2);\n    \tp2.back()[0] = p2.back()[1] = 1;\n    \tMOD2[0] = 1000000007;\n    \tMOD1[0] = 998244353;\n    \tMOD1[1] = 555522277;\n    \tMOD2[1] = 1000000009;\n    \tp2[0] %= MOD2;\n    \tfor (int i = 1; i < MAX; i++) {\n    \t\tp2.push_back(p2.back());\n    \t\tp2[i] *= MOD1;\n    \t\tp2[i] %= MOD2;\n    \t}\n    \tcin >> n;\n    \tscanf(\"%s\", buf);\n    \ts = buf;\n    \tint pos = MAX/2;\n    \tvalarray<long long int> hs;\n    \ths.resize(2);\n    \ths[0] = hs[1] = 0;\n    \tvv.push_back(hs);\n    \tps.push_back(pos);\n    \tfor (int i = 0; i < s.size(); i++) {\n    \t\tif (s[i] == '<') {\n    \t\t\tpos--;\n    \t\t}\n    \t\tif (s[i] == '>') {\n    \t\t\tpos++;\n    \t\t}\n    \t\tif (s[i] == '+') {\n    \t\t\ths += p2[pos];\n    \t\t}\n    \t\tif (s[i] == '-') {\n    \t\t\ths -= p2[pos];\n    \t\t\ths += MOD2;\n    \t\t}\n    \t\ths %= MOD2;\n    \t\tvv.push_back(hs);\n    \t\tps.push_back(pos);\n    \t}\n    \tlong long int way = 0;\n    \tfor (int i = vv.size() - 1; i >= 0; i--) {\n    \t\tvalarray<long long int> want = vv[i] + vv.back()*calc(-MAX/2+ps[i]);\n    \t\twant = want%MOD2;\n    \t\tway += mp[make_pair(want[0], want[1])];\n    \t\t//cerr << \"dbg \" << way << endl;\n    \t\tif(want[0]<0LL||want[1]<0LL)exit(1);\n    \t\tif(vv[i][0]<0LL||want[1]<0LL)exit(1);\n    \t\tmp[make_pair(vv[i][0],vv[i][1])]++;\n    \t}\n    \tprintf(\"%lld\\n\", way);\n    \treturn 0;\n    }"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n\nll mod=(ll)1e18+9, bas=1e9+7, inv;\n\nll mul(ll x,ll y){\n    ll t=0;\n    for (;y;y>>=3,x=x*8%mod)\n        t=(t+x*(y&7))%mod;\n    return t;\n}\n\nll K(ll x,ll y=mod-2){\n    if (y<0) return K(K(x),-y);\n    ll t=1;\n    for (;y;y>>=1,x=mul(x,x))\n        if (y&1) t=mul(t,x);\n    return t;\n}\n\nll n, ans, p[505000], f[505000];\nchar s[505000];\nmap<ll,ll>mp;\n\nint main(){\n    cin>>n>>s+1;\n    p[0]=1; inv=K(bas);\n    for (int i=1;i<=n;++i){\n        p[i]=p[i-1]; f[i]=f[i-1];\n        if (s[i]=='<') p[i]=mul(p[i],inv);\n        if (s[i]=='>') p[i]=mul(p[i],bas);\n        if (s[i]=='+') f[i]=(f[i]+p[i])%mod;\n        if (s[i]=='-') f[i]=(f[i]-p[i]+mod)%mod;\n        ++mp[f[i]];\n    }\n    for (int i=0;i<n;++i){\n        ans+=mp[(mul(f[n],p[i]) + f[i])%mod];\n        --mp[f[i+1]];\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll    =long long;    using dd   =double;        using pll    =pair<ll, ll>;  using tll    =tuple<ll,ll,ll>;\nusing vll   =vector<ll>;   using vdd  =vector<dd>;    using vpll   =vector<pll>;   using vtll   =vector<tll>;\nusing vvll  =vector<vll>;  using vvdd =vector<vdd>;   using vvpll  =vector<vpll>;  using vvtll  =vector<vtll>;\nusing vvvll =vector<vvll>; using vvvdd=vector<vvdd>;  using vvvpll =vector<vvpll>; using vvvtll =vector<vvtll>;\nusing vvvvll=vector<vvvll>;using vvvvdd=vector<vvvdd>;using vvvvpll=vector<vvvpll>;using vvvvtll=vector<vvvtll>;\n\nconstexpr ll INF = 1LL << 60;\nconstexpr dd EPS = 1e-11;\n\n//cin,cout高速化のおまじない＋桁数指定\nstruct Fast{\n\tFast(){\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(std::numeric_limits<double>::max_digits10);\n\t}\n} fast;\n\n#define REPS(i, S, E) for (ll i = (S); i <= (E); i++)\n#define REP(i, N) REPS(i, 0, (N)-1)\n#define DEPS(i, S, E) for (ll i = (E); i >= (S); i--)\n#define DEP(i, N) DEPS(i, 0, (N)-1)\n#define EACH(e, v) for (auto&& e : v)\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\ntemplate<class T> inline T MaxE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmax(m,v[i]); return m;}//v[S]～v[E]の最大値\ntemplate<class T> inline T MinE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmin(m,v[i]); return m;}//v[S]～v[E]の最小値\ntemplate<class T> inline T MaxE(vector<T> &v, ll N) { return MaxE(v, 0, N - 1); } //先頭N個中の最大値\ntemplate<class T> inline T MinE(vector<T> &v, ll N) { return MinE(v, 0, N - 1); }\ntemplate<class T> inline T MaxE(vector<T> &v) { return MaxE(v, (ll)v.size()); }\ntemplate<class T> inline T MinE(vector<T> &v) { return MinE(v, (ll)v.size()); }\ntemplate<class T> inline ll MaxI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]>v[m])m=i;} return m;}\ntemplate<class T> inline ll MinI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]<v[m])m=i;} return m;}\ntemplate<class T> inline ll MaxI(vector<T> &v, ll N) { return MaxI(v, 0, N - 1); }\ntemplate<class T> inline ll MinI(vector<T> &v, ll N) { return MinI(v, 0, N - 1); }\ntemplate<class T> inline ll MaxI(vector<T> &v) { return MaxI(v, (ll)v.size()); }\ntemplate<class T> inline ll MinI(vector<T> &v) { return MinI(v, (ll)v.size()); }\ntemplate<class T> inline T Sum(vector<T> &v, ll S,ll E){ T s=v[S]; REPS(i,S+1,E)s+=v[i]; return s; }\ntemplate<class T> inline T Sum(vector<T> &v, ll N) { return Sum(v, 0, N - 1); }\ntemplate<class T> inline T Sum(vector<T> &v) { return Sum(v, v.size()); }\ntemplate<class T> inline T POW(T a, ll n){ T r=1; for (; n>0; n>>=1, a*=a){ if (n&1)r*=a; } return r; }\ninline ll POW(int a, ll n){ return POW((ll)a, n); }\ninline ll MSB(ll a){for(ll o=63,x=-1;;){ll m=(o+x)/2; if(a<(1LL<<m))o=m; else x=m; if(o-x==1)return x;}}\ninline ll CEIL(ll a, ll b){ return (a+b-1)/b; }\nll Gcd(ll a, ll b){ return (b==0) ? a : Gcd(b, a%b); }\nll Lcm(ll a, ll b){ return a * b / Gcd(a, b); }\ninline vll Mask2Idx(ll m){vll v; for(ll i=0;m;m>>=1,i++) if(m&1)v.push_back(i); return move(v);}\ninline ll BitNum(ll m){ for (ll c=0;; m>>=1){ c+=m&1; if (!m)return c; } }\ninline ll Bit(ll s, ll i){ return (s>>i)&1; } //sの第ibit i=0-63\ninline ll BitOn(ll s, ll i){ return s|(1LL<<i); } //sの第ibitON i=0-63\ninline ll BitOff(ll s, ll i){ return s&~(1LL<<i); } //sの第ibitOFF i=0-63\ntemplate<class T> inline ll UnderNumOf(vector<T> &v, T x){ //sort済vのx以下の個数を得る\n\treturn upper_bound(v.begin(), v.end(), x) - v.begin(); }\ntemplate<class T, class Pr> inline ll UnderNumOf(vector<T> &v, T x, Pr pred){ //x以下個数\n\treturn upper_bound(v.begin(), v.end(), x, pred) - v.begin(); }\ntemplate<class T> inline ll OverNumOf(vector<T> &v, T x){ //sort済vのx以上の個数を得る\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x) - v.begin()); }\ntemplate<class T, class Pr> inline ll OverNumOf(vector<T> &v, T x, Pr pred){ //x以上の個数\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x, pred) - v.begin()); }\n\ntemplate<class T=ll> inline vector<T> cinv(ll N){ vector<T> v(N); REP(i, N)cin>>v[i]; return move(v);}\ntemplate<class T=ll, class S=ll> inline vector<pair<T, S>> cinv2(ll N){\n\tvector<pair<T, S>> v(N); REP(i,N){cin>>v[i].first>>v[i].second;} return move(v); }\ntemplate<class T=ll,class S=ll,class R=ll> inline vector<tuple<T, S, R>> cinv3(ll N){\n\tvector<tuple<T,S,R>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i]);} return move(v);}\ntemplate<class T=ll,class S=ll,class R=ll,class Q=ll> inline vector<tuple<T,S,R,Q>> cinv4(ll N){\n\tvector<tuple<T,S,R,Q>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i])>>get<3>(v[i]);} return move(v);}\ntemplate<class T=ll> inline vector<vector<T>> cinvv(ll N, ll M){\n\tvector<vector<T>> vv(N); REP(i, N) vv[i] = cinv(M); return move(vv);}\ntemplate<class T> inline void coutv(vector<T> &v, char deli=' '){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?'\\n':deli);} }\ntemplate<class T> void bye(T a){cout << a << '\\n'; exit(0);}\n\n#if defined(_DEBUG)\ntemplate<class T> void Dump(vector<T> &v){\n\tREP(i, (ll)v.size()) { cerr << ((i==0)?\"[\":\" \") << setw(5) << v[i]; }  cerr << \"]\";\n}\nvoid Dump(vll &v){\n\tREP(i, (ll)v.size()) {\n\t\tcerr << ((i==0)?\"[\":\" \") << setw(4);\n\t\tif       (v[i] == INF) cerr << \"INF\";\n\t\telse if (v[i] == -INF) cerr << \"-INF\";\n\t\telse                   cerr << v[i];\n\t}  cerr << \"]\";\n}\ntemplate<class T> void Dump(vector<vector<T>> &v){\n\tll N=(ll)v.size();  string d[2][2]={{\" \", \"[\"},  {\"\\n\", \"]\\n\"}};\n\tREP(i, N) { cerr << d[0][i==0];  Dump(v[i]);  cerr << d[1][i==N-1]; }\n}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  <\", \"[ <\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ---<\", \"[ ---<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">---\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ======<\", \"[ ======<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">======\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\n#else\ntemplate<class T> void Dump(vector<T> &v){}\ntemplate<class T> void Dump(vector<vector<T>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){}\n#endif\n\nstruct mll{\n\tstatic ll MOD;\n\tll val;\n\tmll(ll v = 0): val(v % MOD){ if (val < 0) val += MOD; }\n\tmll operator - () const { return -val; }\n\tmll operator + (const mll &b) const { return val + b.val; }\n\tmll operator - (const mll &b) const { return val - b.val; }\n\tmll operator * (const mll &b) const { return val * b.val; }\n\tmll operator / (const mll &b) const { return mll(*this) /= b; }\n\tmll operator + (ll b) const { return *this + mll(b); }\n\tmll operator - (ll b) const { return *this - mll(b); }\n\tmll operator * (ll b) const { return *this * mll(b); }\n\tfriend mll operator + (ll a, const mll &b) { return b + a; }\n\tfriend mll operator - (ll a, const mll &b) { return -b + a; }\n\tfriend mll operator * (ll a, const mll &b) { return b * a; }\n\tfriend mll operator / (ll a, const mll &b) { return mll(a)/b; }\n\tmll &operator += (const mll &b) { val=(val+b.val)%MOD; return *this; }\n\tmll &operator -= (const mll &b) { val=(val+MOD-b.val)%MOD; return *this; }\n\tmll &operator *= (const mll &b) { val=(val*b.val)%MOD; return *this; }\n\tmll &operator /= (const mll &b) {\n\t\tll c=b.val, d=MOD, u=1, v=0;\n\t\twhile (d){\n\t\t\tll t = c / d;\n\t\t\tc -= t * d; swap(c, d);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tmll &operator += (ll b) { return *this += mll(b); }\n\tmll &operator -= (ll b) { return *this -= mll(b); }\n\tmll &operator *= (ll b) { return *this *= mll(b); }\n\tmll &operator /= (ll b) { return *this /= mll(b); }\n\tbool operator == (const mll &b) { return val == b.val; }\n\tbool operator != (const mll &b) { return val != b.val; }\n\tbool operator == (ll b) { return *this == mll(b); }\n\tbool operator != (ll b) { return *this != mll(b); }\n\tfriend bool operator == (ll a, const mll &b) { return mll(a) == b.val; }\n\tfriend bool operator != (ll a, const mll &b) { return mll(a) != b.val; }\n\tfriend ostream &operator << (ostream &os, const mll &a) { return os << a.val; }\n\tfriend istream &operator >> (istream &is, mll &a) { return is >> a.val; }\n\tstatic mll Combination(ll a, ll b){\n\t\tchmin(b, a-b);\n\t\tif (b<0) return mll(0);\n\t\tmll c = 1;\n\t\tREP(i, b) c *= a-i;\n\t\tREP(i, b) c /= i+1;\n\t\treturn c;\n\t}\n};\nll mll::MOD = 2099999999LL;// 998244353LL;//1000000007LL;\nusing vmll = std::vector<mll>;\nusing vvmll = std::vector<vmll>;\nusing vvvmll = std::vector<vvmll>;\nusing vvvvmll = std::vector<vvvmll>;\nusing vvvvvmll = std::vector<vvvvmll>;\n\nusing Data = tuple<mll, ll, mll>;\n\nData prod(Data a, Data b){\n\tmll ha; ll pa; mll qpa; tie(ha, pa, qpa) = a;\n\tmll hb; ll pb; mll qpb; tie(hb, pb, qpb) = b;\n\treturn tuple(ha+qpa*hb, pa+pb, qpa*qpb);\n}\n\nvoid solve()\n{\n\tll N; string S;  cin >> N >> S;\n\tmll q = 999983;\n\tmll qinv = mll(1) / q;\n\n\tData plus  = { 1, 0, 1};\n\tData minus = {-1, 0, 1};\n\tData right = { 0, 1, q};\n\tData left  = { 0,-1, qinv};\n\n\t//W求める\n\tData W ={0,0,1};\n\tDEPS(i, 0, N-1){\n\t\tData si;\n\t\tif      (S[i] == '+') si = plus;\n\t\telse if (S[i] == '-') si = minus;\n\t\telse if (S[i] == '>') si = right;\n\t\telse                  si = left;\n\t\tW = prod(si, W);\n\t}\n\tmll hW = get<0>(W);\n\n\tunordered_map<ll, ll> CinvMap;\n\tData X ={0,0,1};\n\tData Xinv ={0,0,1};\n\tll ans = 0;\n\tDEPS(i, 0, N-1){\n\t\t//現在のXinvをCinvバッファに入れる\n\t\tll h = get<0>(Xinv).val;\n\t\tCinvMap[h]++;\n\t\t//Xを伸ばす\n\t\tData si;\n\t\tif      (S[i] == '+') si = plus;\n\t\telse if (S[i] == '-') si = minus;\n\t\telse if (S[i] == '>') si = right;\n\t\telse                  si = left;\n\t\tX = prod(si, X);\n\t\t//Xinvを伸ばす\n\t\tData siinv;\n\t\tif      (S[i] == '+') siinv = minus;\n\t\telse if (S[i] == '-') siinv = plus;\n\t\telse if (S[i] == '>') siinv = left;\n\t\telse                  siinv = right;\n\t\tXinv = prod(Xinv, siinv);\n\t\t\n\t\t//C^-1のh成分を計算\n\t\tmll hX = get<0>(X);\n\t\tmll qpXinv = get<2>(Xinv);\n\t\tmll hCinv = (hW-hX) * qpXinv;\n\t\tif (CinvMap.count(hCinv.val) == 1){\n\t\t\tans += CinvMap[hCinv.val];\n\t\t}\n\t}\n\tcout << ans << '\\n';\n}\n\n\nint main(){\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h> \nusing namespace std;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\nconst llint mod=998244353;\nconst llint moe=998999971;\nconst llint big=2.19e18+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-15;\ntemplate <class T,class U>void mineq(T& a,U b){if(a>b){a=b;}}\ntemplate <class T,class U>void maxeq(T& a,U b){if(a<b){a=b;}}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint i,n;cin>>n;\n\tllint ans=0;\n\tstring str;cin>>str;\n\tllint gya=1,gyb=1,bb=100;\n\tfor(int h=0;h<30;h++){\n\t\tif((mod-2)&(1<<h)){gya*=bb;gya%=mod;}\n\t\tbb*=bb;bb%=mod;\n\t}\n\tbb=100;\n\tfor(int h=0;h<30;h++){\n\t\tif((moe-2)&(1<<h)){gyb*=bb;gyb%=moe;}\n\t\tbb*=bb;bb%=moe;\n\t}\n\tvector<llint>cd(n+1);\n\tvector<llint>ce(n+1);\n\tllint cp=1,cq=1;\n\tfor(i=0;i<n;i++){\n\t\tif(str[i]=='>'){cp*=100;cq*=100;cp%=mod;cq%=moe;}\n\t\tif(str[i]=='<'){cp*=gya;cq*=gyb;cp%=mod;cq%=moe;}\n\t\tif(str[i]=='+'){cd[i]=cp;ce[i]=cq;}\n\t\tif(str[i]=='-'){cd[i]=mod-cp;ce[i]=moe-cq;}\n\t}\n\tfor(i=n-1;i>=0;i--){cd[i]+=cd[i+1];cd[i]%=mod;ce[i]+=ce[i+1];ce[i]%=moe;}\n\tmap<pair<llint,llint>,int>ma;\n\tfor(i=0;i<=n;i++){ma[mp(cd[i],ce[i])]++;}\n\tllint apd=1,ahd=0,ape=1,ahe=0;\n\tllint Sd=cd[0];\n\tllint Se=ce[0];\n\tfor(i=0;i<n;i++){\n\t\tma[mp(cd[i],ce[i])]--;\n\t\tllint tdr=(Sd-ahd-apd*Sd)%mod;\n\t\tllint ter=(Se-ahe-ape*Se)%moe;\n\t\tif(tdr<0){tdr+=mod;}\n\t\tif(ter<0){ter+=moe;}\n\t\tans+=ma[mp(tdr,ter)];\n\t\tif(str[i]=='>'){apd*=100;ape*=100;apd%=mod;ape%=moe;}\n\t\tif(str[i]=='<'){apd*=gya;ape*=gyb;apd%=mod;ape%=moe;}\n\t\tif(str[i]=='+'){ahd+=apd;ahe+=ape;ahd%=mod;ahe%=moe;}\n\t\tif(str[i]=='-'){ahd+=mod-apd;ahe+=moe-ape;ahd%=mod;ahe%=moe;}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\n\ntypedef long long LL;\nconst int Mod[4] = {999988679, 999988609, 999988589, 999988571};\nconst int B[4] = {370728, 370732, 370729, 370728};\nconst int iB[4] = {396903752, 462741403, 834141573, 238331041};\nconst int MN = 250005;\n\ninline void Add(int &x, int y, int i) { x -= (x += y) >= Mod[i] ? Mod[i] : 0; }\n\ntypedef std::tuple<int, int, int, int> i4;\n\nint N;\nchar S[MN];\nint A[4][MN], D[4][MN];\nstd::map<i4, int> Buk;\nLL Ans;\n\nint main() {\n\tscanf(\"%d%s\", &N, S + 1);\n\tfor (int j = 0; j < 4; ++j) A[j][0] = 0, D[j][0] = 1;\n\tfor (int i = 1, V[4] = {1, 1, 1, 1}; i <= N; ++i) {\n\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\tA[j][i] = A[j][i - 1];\n\t\t\tif (S[i] == '+') Add(A[j][i], V[j], j);\n\t\t\tif (S[i] == '-') Add(A[j][i], Mod[j] - V[j], j);\n\t\t\tif (S[i] == '>') V[j] = (LL)V[j] * B[j] % Mod[j];\n\t\t\tif (S[i] == '<') V[j] = (LL)V[j] * iB[j] % Mod[j];\n\t\t\tD[j][i] = V[j];\n\t\t}\n\t}\n\tfor (int i = N; i >= 0; --i) {\n\t\tAns += Buk[std::make_tuple(\n\t\t\t(A[0][i] + (LL)A[0][N] * D[0][i]) % Mod[0],\n\t\t\t(A[1][i] + (LL)A[1][N] * D[1][i]) % Mod[1],\n\t\t\t(A[2][i] + (LL)A[2][N] * D[2][i]) % Mod[2],\n\t\t\t(A[3][i] + (LL)A[3][N] * D[3][i]) % Mod[3]\n\t\t)];\n\t\t++Buk[std::make_tuple(A[0][i], A[1][i], A[2][i], A[3][i])];\n\t}\n\tprintf(\"%lld\\n\", Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define fi first\n#define se second\n\nconst int mod0 = 1e9 + 9, mod1 = 1e9 + 7, base = 500005;\nint n, pwbase[2][base], hashs[2][base], cur = 250000, ans, start[base];\nstring s;\nmap< pair<int, int>, int> cnt;\n\nint binpw (int aa, int mm, int mod) {\n    int ret = 1;\n    for (; mm; mm >>= 1, aa = (1LL * aa * aa) % mod) if (mm & 1) ret = (1LL * ret * aa) % mod;\n    return ret;\n}\n\nint gethash (bool type, int i, int j) {\n    if(!type) return ( (hashs[type][j] - hashs[type][i - 1]) % mod0 + mod0) % mod0;\n    else return ( (hashs[type][j] - hashs[type][i - 1]) % mod1 + mod1) % mod1;\n}\n\nsigned main () {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    cin >> n >> s; s = '*' + s;\n    pwbase[0][0] = pwbase[1][0] = 1;\n    for (int i = 1; i < base; ++i) {\n        pwbase[0][i] = (pwbase[0][i - 1] * base) % mod0;\n        pwbase[1][i] = (pwbase[1][i - 1] * base) % mod1;\n    }\n    for (int i = 1; i <= n; ++i) {\n        start[i] = cur;\n        if(s[i] == '<') cur --;\n        else if(s[i] == '>') cur ++;\n        hashs[0][i] = hashs[0][i - 1];\n        hashs[1][i] = hashs[1][i - 1];\n        if (s[i] == '+') {\n            hashs[0][i] = (hashs[0][i] + pwbase[0][cur]) % mod0;\n            hashs[1][i] = (hashs[1][i] + pwbase[1][cur]) % mod1;\n        }\n        else if (s[i] == '-') {\n            hashs[0][i] = ( (hashs[0][i] - pwbase[0][cur]) % mod0 + mod0) % mod0;\n            hashs[1][i] = ( (hashs[1][i] - pwbase[1][cur]) % mod1 + mod1) % mod1;\n        }\n    }\n    pair<int, int> X = { (gethash(0, 1, n) * binpw(pwbase[0][ start[1] ], mod0 - 2, mod0) ) % mod0,\n                        (gethash(1, 1, n) * binpw(pwbase[1][ start[1] ], mod1 - 2, mod1)) % mod1 };\n\n    for (int i = n; i > 0; --i) {\n        cnt[ { hashs[0][i], hashs[1][i] } ] ++;\n        ans += cnt[ { X.fi * pwbase[0][ start[i] ] + hashs[0][i - 1], X.se * pwbase[1][ start[i] ] + hashs[1][i - 1] } ];\n    }\n\n    cout << ans;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\n#include<cstring>\n#define N 500001\n#define mod1 1000000007\n#define mod2 998244353\nusing namespace std;\nlong long thn[N],ans,qz[N],a[N],target1[N],p1[N];\nchar st[N];\nint where[N];\nint n;\nstruct node\n{\n\tlong long x;long long y;\n};\nbool operator<(node x,node y)\n{\n\tif (x.x<y.x) return true;\n\tif (x.x>y.x) return false;\n\tif (x.y<y.y) return true;\n\treturn false;\n}\nmap< node ,long long > maps;\nlong long ksmi(long long x,long long y,long long mod)\n{\n\tlong long total=1,ab=x,p=y;\n\twhile (p)\n\t{\n\t\tif (p%2==1) total=total*ab%mod;\n\t\tab=ab*ab%mod;\n\t\tp/=2;\n\t}\n\treturn total;\n}\nlong long abs(long long x)\n{\n\tif (x<0) return -x;\n\treturn x;\n}\nint main()\n{\n\tscanf(\"%d\\n\",&n);\n\tthn[0]=1;\n\tfor (int i=1;i<=2*n;i++) thn[i]=thn[i-1]*(2*n)%mod1;\n\tscanf(\"%s\",st+1);\n\tint nowp=n;\n\twhere[0]=n;\n\tqz[0]=0;\n\tfor (int i=1;i<=2*n;i++)\n\t\tqz[0]=(qz[0]+thn[i-1]*n%mod1)%mod1;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tqz[i]=qz[i-1];\n\t\tif (st[i]=='+')\n\t\t{\n\t\t\ta[nowp]++;\n\t\t\tqz[i]=(qz[i]+thn[nowp-1])%mod1;\n\t\t}\n\t\tif (st[i]=='-')\n\t\t{\n\t\t\ta[nowp]--;\n\t\t\tqz[i]=(qz[i]-thn[nowp-1]+mod1)%mod1;\n\t\t}\n\t\tif (st[i]=='>') nowp++;\n\t\tif (st[i]=='<') nowp--;\n\t\twhere[i]=nowp;\n\t}\n\tunsigned long long a_hash=0;\n\tfor (int i=1;i<=n*2;i++) a_hash=(a_hash+(a[i]+n)*thn[i-1])%mod1;\n\tfor (int i=n;i>=1;i--)\n\t{\n\t\tlong long target=(a_hash-qz[0]+mod1)%mod1;\n\t\tif (where[i-1]<where[0])\n\t\t\ttarget=target*ksmi(thn[abs(where[i-1]-where[0])],mod1-2,mod1)%mod1;\n\t\telse\ttarget=target*thn[abs(where[0]-where[i-1])]%mod1;\n\t//\tmaps[qz[i]]++;\n\t\ttarget+=qz[i-1];\n\t\ttarget%=mod1;\n\t\ttarget1[i]=target;\n\t}\n\tfor (int i=1;i<=n;i++) p1[i]=qz[i];\n\t\n\tmemset(qz,0,sizeof(qz));\n\tthn[0]=1;\n\tfor (int i=1;i<=2*n;i++) thn[i]=thn[i-1]*(2*n)%mod2;\n\tnowp=n;\n\twhere[0]=n;\n\tqz[0]=0;\n\tfor (int i=1;i<=2*n;i++)\n\t\tqz[0]=(qz[0]+thn[i-1]*n%mod2)%mod2;\n\tmemset(a,0,sizeof(a));\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tqz[i]=qz[i-1];\n\t\tif (st[i]=='+')\n\t\t{\n\t\t\ta[nowp]++;\n\t\t\tqz[i]=(qz[i]+thn[nowp-1])%mod2;\n\t\t}\n\t\tif (st[i]=='-')\n\t\t{\n\t\t\ta[nowp]--;\n\t\t\tqz[i]=(qz[i]-thn[nowp-1]+mod2)%mod2;\n\t\t}\n\t\tif (st[i]=='>') nowp++;\n\t\tif (st[i]=='<') nowp--;\n\t\twhere[i]=nowp;\n\t}\n\ta_hash=0;\n\tfor (int i=1;i<=n*2;i++) a_hash=(a_hash+(a[i]+n)*thn[i-1])%mod2;\n\tfor (int i=n;i>=1;i--)\n\t{\n\t\tif (i==1)\n\t\t{\n\t\t\tn++;n--;\n\t\t}\n\t\tlong long target=(a_hash-qz[0]+mod2)%mod2;\n\t\tif (where[i-1]<where[0])\n\t\t\ttarget=target*ksmi(thn[abs(where[i-1]-where[0])],mod2-2,mod2)%mod2;\n\t\telse\ttarget=target*thn[abs(where[0]-where[i-1])]%mod2;\n\t\tnode s;\n\t\ts.x=p1[i];s.y=qz[i];\n\t\tmaps[s]++;\n\t\ttarget+=qz[i-1];\n\t\ttarget%=mod2;\n\t\ts.x=target1[i];s.y=target;\n\t\tans=(ans+maps[s]);\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl;\n#define mdebug(m) cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;}\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\nconst int mod = 1000000007;\n\ntemplate<long long MOD>\nstruct ModInt{\n\n    using ll = long long;\n    ll val;\n\n    void setval(ll v) { val = v % MOD; };\n    ModInt(): val(0) {}\n    ModInt(ll v) { setval(v); };\n\n    ModInt operator+(const ModInt &x) const { return ModInt(val + x.val); }\n    ModInt operator-(const ModInt &x) const { return ModInt(val - x.val + MOD); }\n    ModInt operator*(const ModInt &x) const { return ModInt(val * x.val); }\n    ModInt operator/(const ModInt &x) const { return *this * x.inv(); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator+=(const ModInt &x) { return *this = *this + x; }\n    ModInt operator-=(const ModInt &x) { return *this = *this - x; }\n    ModInt operator*=(const ModInt &x) { return *this = *this * x; }\n    ModInt operator/=(const ModInt &x) { return *this = *this / x; }\n\n    friend ostream& operator<<(ostream &os, const ModInt &x) { os << x.val; return os; }\n    friend istream& operator>>(istream &is, ModInt &x) { is >> x.val; x.val = (x.val % MOD + MOD) % MOD; return is; }\n\n    ModInt pow(ll n) const {\n        ModInt a = 1;\n        if(n == 0) return a;\n        int i0 = 64 - __builtin_clzll(n);\n        for(int i = i0 - 1; i >= 0; i--){\n            a = a * a;\n            if((n >> i) & 1) a *= (*this); \n        }\n        return a;\n    }\n    ModInt inv() const { return this->pow(MOD - 2); }\n};\n\nusing mint = ModInt<mod>; mint pow(mint x, long long n) { return x.pow(n); }\n//using mint = double; //for debug\nusing mvec = vector<mint>;\nusing mmat = vector<mvec>;\n\nstruct Combination{\n\n    vector<mint> fact, invfact;\n\n    Combination(int N){\n        fact = vector<mint>({mint(1)});\n        invfact = vector<mint>({mint(1)});\n        fact_initialize(N);\n    }\n\n    void fact_initialize(int N){\n        int i0 = fact.size();\n        if(i0 >= N + 1) return;\n        fact.resize(N + 1);\n        invfact.resize(N + 1);\n        for(int i = i0; i <= N; i++) fact[i] = fact[i - 1] * i;\n        invfact[N] = (mint)1 / fact[N];\n        for(int i = N - 1; i >= i0; i--) invfact[i] = invfact[i + 1] * (i + 1); \n    }\n\n    mint nCr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[r] * invfact[n - r];\n    }\n\n    mint nPr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[n - r];\n    }\n\n};\n\nsigned main(){\n\n    int N; cin >> N;\n    string S; cin >> S;\n\n    mint r[2] = {114514, 1919};\n    mint x[2] = {0, 0};\n    mint t[2] = {1, 1};\n    REP(i, N){\n        if(S[i] == '>'){\n            REP(k, 2) t[k] *= r[k];\n        }else if(S[i] == '<'){\n            REP(k, 2) t[k] /= r[k];\n        }else if(S[i] == '+'){\n            REP(k, 2) x[k] += t[k];\n        }else if(S[i] == '-'){\n            REP(k, 2) x[k] -= t[k];\n        }\n    }\n    Pii X(x[0].val, x[1].val);\n    \n    x[0] = 0, x[1] = 0;\n    t[0] = 1, t[1] = 1;\n    int ans = 0;\n    map<Pii, int> cnt;\n    cnt[X] += 1;\n\n    REP(i, N){\n        if(S[i] == '>'){\n            REP(k, 2) t[k] *= r[k];\n        }else if(S[i] == '<'){\n            REP(k, 2) t[k] /= r[k];\n        }else if(S[i] == '+'){\n            REP(k, 2) x[k] += t[k];\n        }else if(S[i] == '-'){\n            REP(k, 2) x[k] -= t[k];\n        }\n\n        ans += cnt[Pii(x[0].val, x[1].val)];\n        cnt[Pii((x[0] + t[0] * X.f).val, (x[1] + t[1] * X.s).val)] += 1;\n    }\n    Out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\n//const ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nll Pow(ll n,ll p,ll mod){\n\tll r=1;\n\tfor(;p>0;p>>=1){\n\t\tif(p&1) r=(r*n)%mod;\n\t\tn=(n*n)%mod;\n\t}\n\treturn r;\n}\n\nll Div(ll n,ll m,ll mod){\n\treturn n*Pow(m,mod-2,mod)%mod;\n}\n\nconst ll mod[2]={1000000007,1000000009},base[2]={2,3};\nll inv[2];\n\npll f(vl a,vl b){\n\tpll p=make_pair(Div(b[0],a[0],mod[0]),Div(b[1],a[1],mod[1]));\n\treturn p;\n}\n\nll n,res=0;\nstring s;\nvvl a,b;\nmap<pll,int> mp;\n\nint main(){\n\tinv[0]=Div(1,base[0],mod[0]);\n\tinv[1]=Div(1,base[1],mod[1]);\n\tcin>>n>>s;\n\ta=b=vvl(n+1,vl(2));\n\ta[n][0]=a[n][1]=1;\n\tfor(int i=n-1;i>=0;i--) for(int j=0;j<2;j++){\n\t\tif(s[i]=='+') a[i][j]=a[i+1][j],b[i][j]=b[i+1][j]+1;\n\t\tif(s[i]=='-') a[i][j]=a[i+1][j],b[i][j]=(b[i+1][j]-1+mod[j])%mod[j];\n\t\tif(s[i]=='>') a[i][j]=a[i+1][j]*base[j]%mod[j],b[i][j]=b[i+1][j]*base[j]%mod[j];\n\t\tif(s[i]=='<') a[i][j]=a[i+1][j]*inv[j]%mod[j],b[i][j]=b[i+1][j]*inv[j]%mod[j];\n\t}\n\tmp[f(a[n],b[n])]++;\n\tfor(int i=n-1;i>=0;i--){\n\t\tpll p;\n\t\tp.first =Div((b[i][0]-b[0][0]+mod[0])%mod[0],a[i][0],mod[0]);\n\t\tp.second=Div((b[i][1]-b[0][1]+mod[1])%mod[1],a[i][1],mod[1]);\n\t\tres+=mp[p];\n\t\tmp[f(a[i],b[i])]++;\n\t}\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author aajisaka\n */\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n#define SPEED ios_base::sync_with_stdio(false);cin.tie(nullptr)\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define all(v) v.begin(), v.end()\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing P = pair<ll, ll>;\n\nconstexpr long double PI = 3.14159265358979323846264338327950288L;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nconstexpr ll mod17 = 1e9+7;\nconstexpr ll mod19 = 1e9+9;\nconstexpr ll mod9 = 998244353;\nll mod = mod17;\n\n// Mod int libraries\ntemplate<typename T>\nT mod_pow(T a, ll x) {\n  T res = 1;\n  while(x > 0) {\n    if (x & 1) res *= a;\n    a *= a; x >>= 1;\n  }\n  return res;\n}\n\n// Mint32\nunordered_map<ll, ll> minvmap;\nll minv(ll a, ll m) {\n  auto k = a; auto p = minvmap[a]; if (p != 0) return p;\n  ll b = m, u = 1, v = 0;\n  while (b) { ll t = a/b; swap(a -= t*b, b); swap(u -= t*v, v); }\n  p = (u%m+m)%m; minvmap[k] = p; return p;\n}\n\nstruct mint {\n  ll x;\n  mint():x(0){}\n  mint(ll x):x((x%mod+mod)%mod){}\n  mint& fix() { x = (x%mod+mod)%mod; return *this;}\n  mint operator-() const { return mint(0) - *this;}\n  mint& operator+=(const mint& a){ if((x+=a.x)>=mod) x-=mod; return *this;}\n  mint& operator-=(const mint& a){ if((x+=mod-a.x)>=mod) x-=mod; return *this;}\n  mint& operator*=(const mint& a){ (x*=a.x)%=mod; return *this;}\n  mint& operator/=(const mint& a){ (x*=minv(a.x, mod))%=mod; return *this; }\n  mint operator+(const mint& a)const{ return mint(*this) += a;}\n  mint operator-(const mint& a)const{ return mint(*this) -= a;}\n  mint operator*(const mint& a)const{ return mint(*this) *= a;}\n  mint operator/(const mint& a)const{ return mint(*this) /= a;}\n  bool operator<(const mint& a)const{ return x < a.x;}\n  bool operator==(const mint& a)const{ return x == a.x;}\n};\n\n// Mint64\nstruct mint64 {\n    ull x;\n    static ull mod, inv, r2;\n    mint64(): x(0){}\n    mint64(ull x): x(init(x)) {}\n    static ull init(ull x) { return reduce(__uint128_t(x)*r2);}\n    static void set_mod(ull m) {\n      mod = inv = m;\n      for(int i=0; i<5; i++) inv *= 2 - inv*m;\n      r2 = -__uint128_t(m)%m;\n    }\n    static ull reduce(__uint128_t x) {\n      ull y = ull(x >> 64) - ull((__uint128_t(ull(x)*inv)*mod)>>64);\n      return ll(y) < 0 ? y+mod : y;\n    }\n    mint64& operator+=(mint64& a) { x+=a.x-mod; if(ll(x)<0) x+=mod; return *this; }\n    mint64 operator+(mint64& a) const{ return mint64(*this)+=a; }\n    mint64& operator*=(mint64& a) { x=reduce(__uint128_t(x)*a.x); return *this; }\n    mint64 operator*(mint64& a) const { return mint64(*this)*=a; }\n};\n\null mint64::mod, mint64::inv, mint64::r2;\n\n// Verify: https://yukicoder.me/submissions/472580\nstruct Miller {\n    const vector<ull> v = {2, 325, 9375, 28178, 450775, 9780504, 1795265022};\n    bool suspect(ull a, ull s, ull d, ull n) {\n      if (mint64::mod != n) mint64::set_mod(n);\n      mint64 one = 1, minusone = n-1, ma = a;\n      auto x = mod_pow(ma, d);\n      if (x.x == one.x) return true;\n      for(int r = 0; r < s; r++) {\n        if (x.x == minusone.x) return true;\n        x = x * x;\n      }\n      return false;\n    }\n\n    // check if n is prime\n    bool check(ull n) {\n      if (n < 2 || (n > 2 && n % 2 == 0)) return false;\n      ull d = n - 1;\n      ull s = 0;\n      while (!(d & 1)) {\n        d >>= 1;\n        s++;\n      }\n      for (auto a: v) {\n        if (a >= n) break;\n        if (!suspect(a, s, d, n)) return false;\n      }\n      return true;\n    }\n};\n\nclass combination {\n    // factorial\n    public: std::vector<mint> fact;\n    public: std::vector<mint> inv;\n\n    combination(int n) {\n      fact.resize(n + 1);\n      inv.resize(n + 1);\n      fact[0] = 1;\n      for (int i = 1; i <= n; i++) {\n        fact[i] = fact[i - 1] * i;\n      }\n      inv[n] = mint(1) / fact[n];\n      for (int i = n - 1; i >= 0; i--) {\n        inv[i] = inv[i + 1] * (i + 1);\n      }\n    }\n\n    // nCr\n    public: mint get(int n, int r) {\n      if (n < r || n < 0 || r < 0) return 0;\n      return fact[n]*inv[r]*inv[n-r];\n    }\n    // nPr\n    public: mint p(int n, int r) {\n      if (n < r || n < 0) return 0;\n      return fact[n]*inv[n-r];\n    }\n};\n\n\nclass FEatingSymbolsHard {\npublic:\n    void solve(istream& cin, ostream& cout) {\n      SPEED;\n      int n; cin >> n;\n      string s; cin >> s;\n      vector<vector<mint>> v(6, vector<mint>(500001));\n      v[0][0] = 4;\n      v[1][0] = 11;\n      v[2][0] = 17;\n      v[3][0] = 99;\n      v[4][0] = 101;\n      v[5][0] = 1007;\n\n\n      rep(i, 6) {\n        for(int j=1; j<=500000; j++) {\n          v[i][j] = v[i][j-1] * v[i][0];\n        }\n      }\n\n      int pos = 250000;\n      map<mint, ll> mp[6];\n\n      vector<mint> now(6);\n      vector<vector<pair<mint, int>>> vec(6, vector<pair<mint, int>>(n+1));\n\n      rep(k, 6) {\n        vec[k][0] = {0, pos};\n      }\n\n      rep(k, 6) {\n        rep(i, n) {\n          if (s[i] == '+') {\n            now[k] += v[k][pos];\n          } else if (s[i] == '-') {\n            now[k] -= v[k][pos];\n          } else if (s[i] == '>') {\n            pos++;\n          } else if (s[i] == '<') {\n            pos--;\n          }\n          vec[k][i + 1] = {now[k], pos};\n        }\n      }\n      rep(k, 6) {\n        now[k] /= v[k][250000];\n      }\n\n      ll ans = 0;\n      for(int i=n; i>=0; i--) {\n        vector<ll> cnt;\n        rep(k, 6) {\n          auto q = vec[k][i].first + now[k] * v[k][vec[k][i].second];\n          if (mp[k].find(q) == mp[k].end()) {\n            cnt.push_back(0);\n          } else {\n            cnt.push_back(mp[k][q]);\n          }\n        }\n        sort(all(cnt));\n        ans += cnt[3];\n        rep(k, 6) {\n          mp[k][vec[k][i].first]++;\n        }\n      }\n\n      cout << ans << endl;\n\n    }\n};\n\nsigned main() {\n  FEatingSymbolsHard solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\nusing namespace std;\n\n#define P2 1000000007LL\n#define P1 1000000009LL\ntypedef long long Int;\nmap<Int, Int> cs;\nInt sum[250001];\nInt pos[250001];\nInt res;\nInt n;\nstring str;\nInt pow(Int x, Int y, Int M){\n\tif(y == 0)return 1;\n\tInt res = pow(x, y/2, M);\n\tres = res * res % M;\n\tif(y % 2)res *= x;\n\treturn x % M;\n}\n\nInt rev(Int x, Int M){\n\treturn pow(x, M-2, M);\n}\n\nint main(){\n\tInt p = 0;\n\tInt tmp = 0;\n\tcin >> n;\n\tcin >> str;\n\tfor(int i = 0;i < n;i++){\n\t\tif(str[i] == '+')tmp = (tmp + pow(1000000, p, P1))%P1;\n\t\tif(str[i] == '-')tmp = (tmp - pow(1000000, p, P1))%P1;\n\t\tif(str[i] == '>')p++;\n\t\tif(str[i] == '<')p--;\n\t\tsum[i+1] = tmp;\n\t\tpos[i+1] = p;\n\n\t}\n\tInt last = sum[n];\n\tfor(int i = n;i >= 0;i--){\n\t\tInt tmp = ((last - last * pow(1000000, pos[i], P1) % P1) % P1 + P1)% P1;\n\t\tres += cs[(tmp - sum[i] + P1) % P1];\n\t\tInt c = (last - sum[i] +P1) % P1;\n\t\tif(cs.count(c) == 0)cs[c] = 0;\n\t\tcs[c]++;\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "    #include \"bits/stdc++.h\"\n            using namespace std;\n             \n            #define MAX 600012\n             \n            int n;\n            char buf[MAX];\n            string s;\n            valarray<long long int> MOD1;\n            valarray<long long int> MOD2;\n            vector<valarray<long long int> > p2;\n            vector<valarray<long long int> > vv;\n            vector<int> ps;\n            map<pair<long long int,long long int>, int> mp;\n            long long int ppow(long long int i, long long int j, long long int MOD) {\n            \tlong long int ret = 1;\n            \twhile (j) {\n            \t\tif (j & 1LL)ret *= i;\n            \t\tif (ret >= MOD)ret %= MOD;\n            \t\tj >>= 1LL;\n            \t}\n            \treturn ret;\n            }\n             \n            valarray<long long int> calc(int dif) {\n            \tvalarray<long long int> ret;\n            \tret.resize(2, 0);\n            \tfor (int j = 0; j < 2; j++) {\n            \t\tif (dif < 0) {\n            \t\t\tret[j]=ppow(ppow(MOD1[j],MOD2[j]-2,MOD2[j]),-dif,MOD2[j]);\n            \t\t}\n            \t\telse {\n            \t\t\tret[j] = ppow(MOD1[j],dif, MOD2[j]);\n            \t\t}\n            \t}\n            \treturn ret;\n            }\n             \n            int main() {\n\t\t\t\tcin >> n;\n            \tscanf(\"%s\", buf);\n            \ts = buf;\n            \tMOD1.resize(2);\n            \tMOD2.resize(2);\n            \tp2.push_back(valarray<long long int>());\n            \tp2.back().resize(2);\n            \tp2.back()[0] = p2.back()[1] = 1;\n            \tMOD2[1] = 1000000007;\n            \tMOD1[0] = 555522277;\n            \tMOD1[1] = 895612783;\n            \tMOD2[0] = 998244353;\n            \tp2[0] %= MOD2;\n            \tfor (int i = 1; i < MAX; i++) p2.push_back((p2.back()*MOD1)%MOD2);\n            \tint pos = MAX/2;\n            \tvalarray<long long int> hs;\n            \ths.resize(2,0);\n            \tvv.push_back(hs);\n            \tps.push_back(pos);\n            \tfor (int i = 0; i < s.size(); i++) {\n            \t\tif (s[i] == '<') pos--;\n            \t\telse if (s[i] == '>') pos++;\n            \t\telse if (s[i] == '+') hs += p2[pos];\n            \t\telse if (s[i] == '-') hs += MOD2-p2[pos];\n            \t\ths %= MOD2;\n            \t\tif(hs[0]<0LL||hs[1]<0LL||p2[pos][0]<0LL||p2[pos][1]<0LL)return 1;\n            \t\tvv.push_back(hs);\n            \t\tps.push_back(pos);\n            \t}\n            \tlong long int way = 0;\n            \tfor (int i = vv.size() - 1; i >= 0; i--) {\n            \t\tvalarray<long long int> want = (vv[i] + ((vv.back()*calc(-MAX/2+ps[i]))%MOD2)%MOD2)%MOD2;\n            \t\tway += mp[make_pair(want[0], want[1])];\n            \t\tif(want[0]<0LL||want[1]<0LL)return 1;\n            \t\tmp[make_pair(vv[i][0],vv[i][1])]++;\n            \t}\n            \tprintf(\"%lld\\n\", way);\n            \treturn 0;\n            }"
  },
  {
    "language": "C++",
    "code": "const int N = 250005;\nconst int LG = 21;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nint n;\nstring s;\nll sufa[N];\nll suf0[N];\nll sufa2[N];\nll suf02[N];\nconst ll K = 1e6 + 3;\nconst ll K2 = 1791791;\nconst ll rK = rev(K);\nconst ll rK2 = rev(K2);\nll pref0[N];\nll pref02[N];\nll moves[N];\nmap<int, ll> deg, deg2;\n\nsigned main()\n{\n    deg[0] = 1;\n    deg2[0] = 1;\n    for (int i = 1; i < N; i++) deg[i] = deg[i - 1] * K % MOD;\n    for (int i = 1; i < N; i++) deg2[i] = deg2[i - 1] * K2 % MOD;\n    for (int i = 1; i < N; i++) deg[-i] = deg[-i + 1] * rK % MOD;\n    for (int i = 1; i < N; i++) deg2[-i] = deg2[-i + 1] * rK2 % MOD;\n    srand(time(NULL));\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n    cin >> n >> s;\n    ll a = 0, a2 = 0;\n    for (int i = n - 1; i >= 0; i--)\n    {\n        if (s[i] == '+')\n        {\n            a = (a + MOD - 1) % MOD;\n            a2 = (a2 + MOD - 1) % MOD;\n        }\n        if (s[i] == '-')\n        {\n            a = (a + 1) % MOD;\n            a2 = (a2 + 1) % MOD;\n        }\n        if (s[i] == '>')\n        {\n            a = (a * K) % MOD;\n            a2 = (a2 * K2) % MOD;\n        }\n        if (s[i] == '<')\n        {\n            a = (a * rK) % MOD;\n            a2 = (a2 * rK2) % MOD;\n        }\n    }\n    if (s[0] == '+') pref0[0] = (pref0[0] + 1) % MOD;\n    if (s[0] == '+') pref02[0] = (pref02[0] + 1) % MOD;\n    if (s[0] == '-') pref0[0] = (pref0[0] + MOD - 1) % MOD;\n    if (s[0] == '-') pref02[0] = (pref02[0] + MOD - 1) % MOD;\n    if (s[0] == '<') pref0[0] = (pref0[0] * K) % MOD;\n    if (s[0] == '<') pref02[0] = (pref02[0] * K2) % MOD;\n    if (s[0] == '>') pref0[0] = (pref0[0] * rK) % MOD;\n    if (s[0] == '>') pref02[0] = (pref02[0] * rK2) % MOD;\n    if (s[0] == '>') moves[0]++;\n    if (s[0] == '<') moves[0]--;\n    for (int i = 1; i < n; i++)\n    {\n        if (s[i] == '+') pref0[i] = (pref0[i - 1] + 1) % MOD;\n        if (s[i] == '+') pref02[i] = (pref02[i - 1] + 1) % MOD;\n        if (s[i] == '-') pref0[i] = (pref0[i - 1] + MOD - 1) % MOD;\n        if (s[i] == '-') pref02[i] = (pref02[i - 1] + MOD - 1) % MOD;\n        if (s[i] == '<') pref0[i] = (pref0[i - 1] * K) % MOD;\n        if (s[i] == '<') pref02[i] = (pref02[i - 1] * K2) % MOD;\n        if (s[i] == '>') pref0[i] = (pref0[i - 1] * rK) % MOD;\n        if (s[i] == '>') pref02[i] = (pref02[i - 1] * rK2) % MOD;\n        moves[i] = moves[i - 1];\n        if (s[i] == '>') moves[i]++;\n        if (s[i] == '<') moves[i]--;\n    }\n    for (int j = 0; j < n; j++)\n    {\n        if (s[j] == '+')\n        {\n            suf0[0] = (suf0[0] + 1) % MOD;\n            suf02[0] = (suf02[0] + 1) % MOD;\n        }\n        if (s[j] == '-')\n        {\n            suf0[0] = (suf0[0] + MOD - 1) % MOD;\n            suf02[0] = (suf02[0] + MOD - 1) % MOD;\n        }\n        if (s[j] == '<')\n        {\n            suf0[0] = (suf0[0] * K) % MOD;\n            suf02[0] = (suf02[0] * K2) % MOD;\n        }\n        if (s[j] == '>')\n        {\n            suf0[0] = (suf0[0] * rK) % MOD;\n            suf02[0] = (suf02[0] * rK2) % MOD;\n        }\n    }\n    if (a != 0 && a2 != 0) return 1;\n    for (int i = 0; i < n; i++) suf0[i + 1] = (suf0[0] - pref0[i] * deg[moves[i]] + MOD * MOD) % MOD;\n    for (int i = 0; i < n; i++) suf02[i + 1] = (suf02[0] - pref02[i] * deg2[moves[i]] + MOD * MOD) % MOD;\n    for (int i = 0; i < n; i++) sufa[i] = (suf0[i] + a * deg[(i > 0 ? moves[i - 1] : 0) - moves[n - 1]]) % MOD;\n    for (int i = 0; i < n; i++) sufa2[i] = (suf02[i] + a2 * deg2[(i > 0 ? moves[i - 1] : 0) - moves[n - 1]]) % MOD;\n    ll ans = 0;\n    map<vector<ll>, ll> cnt;\n    for (int i = n; i >= 0; i--)\n    {\n        ans += cnt[{sufa[i], sufa2[i]}];\n        cnt[{suf0[i], suf02[i]}]++;\n    }\n    cout << ans;\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define pb push_back\n#define all(v) v.begin(), v.end()\n#define sz(v) int(v.size())\n#define pii pair<int, int>\n#define mp make_pair\n#define f first\n#define ll long long\n#define s second\n#define vec vector<int>\n\nusing namespace std;\n\nconst int N = (int) 2e6 + 10;\nconst int K = (int) 1e7 + 10;\nconst int mod = (int) 1e9 + 7;\nconst int T = (int) 200017;\n\nint n;\nstring st;\nint p[N];\n\nvoid add(int &x, int y) {\n\tx += y;\n\tif (x >= mod)\n\t\tx -= mod;\n\tif (x < 0) \n\t\tx += mod;\n}\n\nint mult(int x, int y) {\n\treturn x * 1ll * y % mod;\n}\n\nint hsh[N], pos[N];\n\npair<int, int> get(int l, int r) {\n\treturn mp(hsh[r + 1], pos[r + 1]);\n}\n\nint inv(int x) {\n\tint pw = mod - 2;\n\tint ans = 1;\n\twhile (pw) {\n\t\tif (pw & 1) \n\t\t\tans = mult(ans, x);\n\t\tx = mult(x, x);\n\t\tpw /= 2;\n\t}\n\treturn ans;\n}\n\n// get(l,r)=(get(0,r)-get(0,l-1))<<pos(0, l-1)\n\nint shift(int x, int val) { // to the right\n\tif (val > 0) {\n\t\tx = mult(x, p[val]);\n\t} else {\n\t\tx = mult(x, inv(p[-val]));\n\t}\n\treturn x;\n}\n\nint sum(int x, int y) {\n\tadd(x, y);\n\treturn x;\n}\n\nint main() {\n\t#ifdef sony\n\t\tfreopen(\"input.txt\", \"r\", stdin);\n\t\tfreopen(\"output.txt\", \"w\", stdout);\n\t#endif\n\tcin >> n >> st;\n\t//HASH(A) = {FOR I = [0...big_N] SUM OF A[I]*T^I % MODULO} WHERE T = PRIME > 2.5 * 10^5\n\tp[0] = 1;\n\tfor (int i = 1; i < N; i++) {\n\t\tp[i] = mult(p[i - 1], T);\n\t}\n\tpos[0] = 2 * n;\n\thsh[0] = 0;\n\tvector<int> a(4 * n, 0);\n\tfor (int i = 0; i < n; i++) {\n\t\tpos[i + 1] = pos[i];\n\t\thsh[i + 1] = hsh[i];\n\t\tif (st[i] == '+') {\n\t\t\tadd(hsh[i + 1], p[pos[i + 1]]);\n\t\t} else if (st[i] == '-') {\n\t\t\tadd(hsh[i + 1], -p[pos[i + 1]]);\n\t\t} else if (st[i] == '>') {\n\t\t\tpos[i + 1]++;\n\t\t} else {\n\t\t\tpos[i + 1]--;\n\t\t}\n\t}\n\tint x = get(0, n - 1).f;\n\tint ans = 0;\n\tmap<int, int> cnt;\n\tfor (int i = 0; i < n; i++) {\n\t\tint y = sum(shift(x, get(0, i - 1).s - 2 * n), shift(get(0, i - 1).f, 0));\n\t\tcnt[y]++;\n\t\tint z = shift(get(0, i).f, 0);\n\t\tans += cnt[z];\n\t}\n\tcout << ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n#define dbg(x...) do { cout << \"\\033[32;1m \" << #x << \" -> \"; err(x); } while (0)\nvoid err() { cout << \"\\033[39;0m\" << endl; }\ntemplate<template<typename...> class T, typename t, typename... A>\nvoid err(T<t> a, A... x) { for (auto v: a) cout << v << ' '; err(x...); }\ntemplate<typename T, typename... A>\nvoid err(T a, A... x) { cout << a << ' '; err(x...); }\n#else\n#define dbg(...)\n#endif\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef vector<int> vi;\ntemplate<class T> using vc=vector<T>;\ntemplate<class T> using vvc=vc<vc<T>>;\ntemplate<class T> void mkuni(vector<T>&v)\n{\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\ntemplate<class T>\nvoid print(T x,int suc=1)\n{\n    cout<<x;\n    if(suc==1) cout<<'\\n';\n    else cout<<' ';\n}\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1)\n{\n    for(int i=0;i<v.size();i++)\n    print(v[i],i==(int)(v.size())-1?suc:2);\n}\nconst int mod=1e9+7;\nconst int ptr=3;\nint c[ptr],r[ptr];\nll quick(ll a,ll b=mod-2)\n{\n    ll ret=1;\n    while(b)\n    {\n        if(b&1) ret=ret*a%mod;\n        a=a*a%mod;\n        b>>=1;\n    }\n    return ret;\n}\nint main()\n{\n    srand(time(NULL));\n    int n;\n    cin>>n;\n    string s;\n    cin>>s;\n    for(int i=0;i<ptr;i++)\n    {\n        c[i]=rand()%998244353+10000;\n        r[i]=quick(c[i]);\n    }\n    vc<ll> C(ptr);\n    reverse(s.begin(),s.end());\n    for(int i=0;i<n;i++)\n    {\n        for(int j=0;j<ptr;j++)\n        {\n            if(s[i]=='+')\n                C[j]=(C[j]+1)%mod;\n            else if(s[i]=='-')\n                C[j]=(C[j]-1+mod)%mod;\n            else if(s[i]=='>')\n                C[j]=C[j]*c[j]%mod;\n            else C[j]=C[j]*r[j]%mod;\n        }\n    }\n    map<vc<ll>,int> cnt;\n    vc<ll> A(ptr,1),cur(ptr);\n    ll ans=0;\n    cnt[cur]++;\n    for(int i=0;i<n;i++)\n    {\n        for(int j=0;j<ptr;j++)\n        {\n            if(s[i]=='+')\n                cur[j]=(cur[j]-A[j]+mod)%mod;\n            else if(s[i]=='-')\n                cur[j]=(cur[j]+A[j])%mod;\n            else if(s[i]=='>')\n            {\n                A[j]=A[j]*r[j]%mod;\n            }\n            else{\n                A[j]=A[j]*c[j]%mod;\n            }\n        }\n        vc<ll> tar=C;\n        for(int j=0;j<ptr;j++) tar[j]=(cur[j]+tar[j]*A[j]%mod)%mod;\n        ans+=cnt[tar];\n        //dbg(i,cur,tar);\n        cnt[cur]++;\n    }\n    print(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define N 500050\nint mod1=998244353,base1=19260817,inv1;\nint mod2=353448299,base2=20000003,inv2;\nint h1[N],mi1[N],imi1[N],p[N],n,C;\nint h2[N],mi2[N],imi2[N];\nmap<pair<int,int>,int>mp;\nint pw(int x,int y,int p){int r=1;for(;y;y>>=1,x=1ll*x*x%p)if(y&1)r=1ll*r*x%p;return r;}\nchar ss[N],str;\nint main()\n{\n\tinv1=pw(base1,mod1-2,mod1);\n\tinv2=pw(base2,mod2-2,mod2);\n\tscanf(\"%d\",&n);\n\tint i;\n\tfor(mi1[0]=imi1[0]=mi2[0]=imi2[0]=i=1;i<=(n<<1);i++)\n\t{\n\t\tmi1[i]=ll(mi1[i-1])*base1%mod1;\n\t\timi1[i]=ll(imi1[i-1])*inv1%mod1;\n\t\tmi2[i]=ll(mi2[i-1])*base2%mod2;\n\t\timi2[i]=ll(imi2[i-1])*inv2%mod2;\n\t}\n\tscanf(\"%s\",ss+1);\n\tp[0]=n;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tstr=ss[i];\n\t\tif(str=='+'){p[i]=p[i-1];h1[i]=(h1[i-1]+mi1[p[i]])%mod1;h2[i]=(h2[i-1]+mi2[p[i]])%mod2;}\n\t\telse if(str=='-'){p[i]=p[i-1];h1[i]=(h1[i-1]-mi1[p[i]]+mod1)%mod1;h2[i]=(h2[i-1]-mi2[p[i]]+mod2)%mod2;}\n\t\telse if(str=='>'){p[i]=p[i-1]+1;h1[i]=h1[i-1];h2[i]=h2[i-1];}\n\t\telse{p[i]=p[i-1]-1;h1[i]=h1[i-1];h2[i]=h2[i-1];}\n\t\tmp[make_pair(h1[i],h2[i])]++;\n\t}\n\tll ans=0;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tint d=p[i-1]-n,t1=h1[n],t2=h2[n];\n\t\tif(d>=0) t1=ll(t1)*mi1[d]%mod1,t2=ll(t2)*mi2[d]%mod2;\n\t\telse t1=ll(t1)*imi1[-d]%mod1,t2=ll(t2)*imi2[-d]%mod2;\n\t\tt1=(t1+h1[i-1])%mod1;t2=(t2+h2[i-1])%mod2;\n\t\tans+=mp[make_pair(t1,t2)];\n\t\tmp[make_pair(h1[i],h2[i])]--;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<map>\nusing namespace std;\nstruct node{long long g1,g2,g3,g4,g5,g6,g7,g8;int p;};\nconst int p1=1000000007,p2=1000000009;\nlong long x1p1[510000],x1p2[510000],x2p1[510000],x2p2[510000],x3p1[510000],x3p2[510000],x4p1[510000],x4p2[510000];\ninline node operator+(node x,node y){return {(x.g1+y.g1*x1p1[x.p+250000])%p1,(x.g2+y.g2*x1p2[x.p+250000])%p2,(x.g3+y.g3*x2p1[x.p+250000])%p1,(x.g4+y.g4*x2p2[x.p+250000])%p2,(x.g5+y.g5*x3p1[x.p+250000])%p1,(x.g6+y.g6*x3p2[x.p+250000])%p2,(x.g7+y.g7*x4p1[x.p+250000])%p1,(x.g8+y.g8*x4p2[x.p+250000])%p2,x.p+y.p};}\nchar s[260000];\nmap<long long,map<long long,map<long long,map<long long,map<long long,map<long long,map<long long,map<long long,int>>>>>>>> M;\nint main()\n{\n\tx1p1[249999]=500000004;x1p1[250000]=1;x1p1[250001]=2;\n\tx1p2[249999]=500000005;x1p2[250000]=1;x1p2[250001]=2;\n\tx2p1[249999]=666666671;x2p1[250000]=1;x2p1[250001]=3;\n\tx2p2[249999]=333333336;x2p2[250000]=1;x2p2[250001]=3;\n\tx3p1[249999]=600000004;x3p1[250000]=1;x3p1[250001]=5;\n\tx3p2[249999]=800000007;x3p2[250000]=1;x3p2[250001]=5;\n\tx4p1[249999]=857142863;x4p1[250000]=1;x4p1[250001]=7;\n\tx4p2[249999]=142857144;x4p2[250000]=1;x4p2[250001]=7;\n\tfor(int i=249998;i>=0;i--)x1p1[i]=x1p1[i+1]*x1p1[249999]%p1,x1p2[i]=x1p2[i+1]*x1p2[249999]%p2,x2p1[i]=x2p1[i+1]*x2p1[249999]%p1,x2p2[i]=x2p2[i+1]*x2p2[249999]%p2,x3p1[i]=x3p1[i+1]*x3p1[249999]%p1,x3p2[i]=x3p2[i+1]*x3p2[249999]%p2,x4p1[i]=x4p1[i+1]*x4p1[249999]%p1,x4p2[i]=x4p2[i+1]*x4p2[249999]%p2;\n\tfor(int i=250002;i<=500000;i++)x1p1[i]=x1p1[i-1]*x1p1[250001]%p1,x1p2[i]=x1p2[i-1]*x1p2[250001]%p2,x2p1[i]=x2p1[i-1]*x2p1[250001]%p1,x2p2[i]=x2p2[i-1]*x2p2[250001]%p2,x3p1[i]=x3p1[i-1]*x3p1[250001]%p1,x3p2[i]=x3p2[i-1]*x3p2[250001]%p2,x4p1[i]=x4p1[i-1]*x4p1[250001]%p1,x4p2[i]=x4p2[i-1]*x4p2[250001]%p2;\n\tint n;scanf(\"%d%s\",&n,s+1);\n\tnode gs={0,0,0,0,0,0,0,0,0},pr={0,0,0,0,0,0,0,0,0};\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(s[i]=='+')gs.g1=(gs.g1+x1p1[gs.p+250000])%p1,gs.g2=(gs.g2+x1p2[gs.p+250000])%p2,gs.g3=(gs.g3+x2p1[gs.p+250000])%p1,gs.g4=(gs.g4+x2p2[gs.p+250000])%p2,gs.g5=(gs.g5+x3p1[gs.p+250000])%p1,gs.g6=(gs.g6+x3p2[gs.p+250000])%p2,gs.g7=(gs.g7+x4p1[gs.p+250000])%p1,gs.g8=(gs.g8+x4p2[gs.p+250000])%p2;\n\t\telse if(s[i]=='-')gs.g1=(gs.g1-x1p1[gs.p+250000]+p1)%p1,gs.g2=(gs.g2-x1p2[gs.p+250000]+p2)%p2,gs.g3=(gs.g3-x2p1[gs.p+250000]+p1)%p1,gs.g4=(gs.g4-x2p2[gs.p+250000]+p2)%p2,gs.g5=(gs.g5-x3p1[gs.p+250000]+p1)%p1,gs.g6=(gs.g6-x3p2[gs.p+250000]+p2)%p2,gs.g7=(gs.g7-x4p1[gs.p+250000]+p1)%p1,gs.g8=(gs.g8-x4p2[gs.p+250000]+p2)%p2;\n\t\telse if(s[i]=='>')gs.p++;\n\t\telse gs.p--;\n\t}\n\tlong long ss=0;\n\tnode rg=pr+gs;\n\tM[rg.g1][rg.g2][rg.g3][rg.g4][rg.g5][rg.g6][rg.g7][rg.g8]++;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(s[i]=='+')pr.g1=(pr.g1+x1p1[pr.p+250000])%p1,pr.g2=(pr.g2+x1p2[pr.p+250000])%p2,pr.g3=(pr.g3+x2p1[pr.p+250000])%p1,pr.g4=(pr.g4+x2p2[pr.p+250000])%p2,pr.g5=(pr.g5+x3p1[pr.p+250000])%p1,pr.g6=(pr.g6+x3p2[pr.p+250000])%p2,pr.g7=(pr.g7+x4p1[pr.p+250000])%p1,pr.g8=(pr.g8+x4p2[pr.p+250000])%p2;\n\t\telse if(s[i]=='-')pr.g1=(pr.g1-x1p1[pr.p+250000]+p1)%p1,pr.g2=(pr.g2-x1p2[pr.p+250000]+p2)%p2,pr.g3=(pr.g3-x2p1[pr.p+250000]+p1)%p1,pr.g4=(pr.g4-x2p2[pr.p+250000]+p2)%p2,pr.g5=(pr.g5-x3p1[pr.p+250000]+p1)%p1,pr.g6=(pr.g6-x3p2[pr.p+250000]+p2)%p2,pr.g7=(pr.g7-x4p1[pr.p+250000]+p1)%p1,pr.g8=(pr.g8-x4p2[pr.p+250000]+p2)%p2;\n\t\telse if(s[i]=='>')pr.p++;\n\t\telse pr.p--;\n\t\tss=ss+M[pr.g1][pr.g2][pr.g3][pr.g4][pr.g5][pr.g6][pr.g7][pr.g8];\n\t\trg=pr+gs;\n\t\tM[rg.g1][rg.g2][rg.g3][rg.g4][rg.g5][rg.g6][rg.g7][rg.g8]++;\n\t}\n\tprintf(\"%lld\\n\",ss);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\nusing namespace std;\ntypedef unsigned long long ULL;\nconst int N=250010;\nconst ULL MOD=1000000000000000031ull,B=1000000000000000003ull,REVB=821428571428571454ull;\nint n;\nchar str[N];\nULL f[N],p[N];\nULL mul(ULL x,ULL y){\n\treturn (ULL)((__int128)x*y%MOD);\n}\nvoid readData(){\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",str+1);\n}\nmap<ULL,int> mp;\nvoid solve(){\n\tf[0]=0;\n\tp[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tf[i]=f[i-1];\n\t\tp[i]=p[i-1];\n\t\tif(str[i]=='>')\n\t\t\tp[i]=mul(p[i],B);\n\t\telse if(str[i]=='<')\n\t\t\tp[i]=mul(p[i],REVB);\n\t\telse if(str[i]=='+')\n\t\t\t(f[i]+=p[i])%=MOD;\n\t\telse\n\t\t\t(f[i]-=p[i])%=MOD;\n\t\tif(f[i]<0)\n\t\t\tf[i]+=MOD;\n\t}\n\tULL ans=0;\n\tfor(int i=n;i>=1;i--){\n\t\tmp[f[i]]++;\n\t\tans+=mp[(mul(f[n],p[i-1])+f[i-1])%MOD];\n\t}\n\tprintf(\"%llu\\n\",ans);\n}\nint main(){\n\treadData();\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <random>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\n\nconst ll MOD=1e9+7;\nconst int med=250000;\nll powmod(ll a, ll k){\n    ll ap=a, ans=1;\n    while(k>0){\n        if(k%2==1){\n            ans*=ap;\n            ans%=MOD;\n        }\n        ap=ap*ap;\n        ap%=MOD;\n        k/=2;\n    }\n    return ans;\n}\nll inv(ll a){\n\treturn powmod(a, MOD-2);\n}\n\nint main()\n{\n\tint n;\n\tcin>>n;\n\tstring s;\n\tcin>>s;\n\trandom_device rnd;\n\tmt19937_64 mt(rnd());\n\tuniform_int_distribution<ll> rndn(2, MOD-2);\n\tll b=rndn(mt);\n\tll binv=inv(b);\n\tll bp[500001];\n\tbp[med]=1;\n\tfor(int i=med+1; i<=med+n; i++) bp[i]=bp[i-1]*b%MOD;\n\tfor(int i=med-1; i>=med-n; i--) bp[i]=bp[i+1]*binv%MOD;\n\tll b0=0; int p=med;\n\tfor(int i=0; i<n; i++){\n\t\tif(s[i]=='+'){\n\t\t\tb0=(b0+bp[p])%MOD;\n\t\t}else if(s[i]=='-'){\n\t\t\tb0=(b0+MOD-bp[p])%MOD;\n\t\t}else if(s[i]=='>'){\n\t\t\tp++;\n\t\t}else{\n\t\t\tp--;\n\t\t}\n\t}\n\tll ans=0;\n\tll x[250000]={};\n\tvector<ll> v[500];\n\tint c1[500]={};\n\tll c0[500]={};\n\tint sq=500;\n\tfor(int i=0; i<n; i++){\n\t\tif(s[n-1-i]=='+'){\n\t\t\tfor(int j=i/sq*sq; j<=i; j++){\n\t\t\t\tx[j]=(x[j]+1)%MOD;\n\t\t\t}\n\t\t\tfor(int j=0; j<i/sq; j++){\n\t\t\t\tc0[j]=(c0[j]+1)%MOD;\n\t\t\t}\n\t\t}else if(s[n-1-i]=='-'){\n\t\t\tfor(int j=i/sq*sq; j<=i; j++){\n\t\t\t\tx[j]=(x[j]+MOD-1)%MOD;\n\t\t\t}\n\t\t\tfor(int j=0; j<i/sq; j++){\n\t\t\t\tc0[j]=(c0[j]+MOD-1)%MOD;\n\t\t\t}\n\t\t}else if(s[n-1-i]=='>'){\n\t\t\tfor(int j=i/sq*sq; j<=i; j++){\n\t\t\t\tx[j]=x[j]*b%MOD;\n\t\t\t}\n\t\t\tfor(int j=0; j<i/sq; j++){\n\t\t\t\tc1[j]++;\n\t\t\t\tc0[j]=c0[j]*b%MOD;\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int j=i/sq*sq; j<=i; j++){\n\t\t\t\tx[j]=x[j]*binv%MOD;\n\t\t\t}\n\t\t\tfor(int j=0; j<i/sq; j++){\n\t\t\t\tc1[j]--;\n\t\t\t\tc0[j]=c0[j]*binv%MOD;\n\t\t\t}\n\t\t}\n\t\tfor(int j=0; j<i/sq; j++){\n\t\t\tll x0=(b0-c0[j]+MOD)*bp[med-c1[j]]%MOD;\n\t\t\tans+=((ll)(upper_bound(v[j].begin(), v[j].end(), x0)-lower_bound(v[j].begin(), v[j].end(), x0)));\n\t\t}\n\t\tfor(int j=i/sq*sq; j<=i; j++){\n\t\t\tif(b0==x[j]) ans++;\n\t\t}\n\t\tif((i+1)%sq==0){\n\t\t\tfor(int j=i/sq*sq; j<=i; j++){\n\t\t\t\tv[i/sq].push_back(x[j]);\n\t\t\t}\n\t\t\tsort(v[i/sq].begin(), v[i/sq].end());\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ri register int\ntypedef long long ll;\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char y) {\n\t\t*oS ++ = y;\n\t\tif (oS == oT) flush ();\n\t}\n\t// input a signed integer\n\ttemplate <class I>\n\tinline void gi (I &y) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (y = 0; c <= '9' && c >= '0'; c = gc()) y = (y << 1) + (y << 3) + (c & 15); y *= f;\n\t}\n\t// print a signed integer\n\ttemplate <class I>\n\tinline void print (I y) {\n\t\tif (!y) putc ('0'); if (y < 0) putc ('-'), y = -y;\n\t\twhile (y) qu[++ qr] = y % 10 + '0',  y /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t}\n\t// no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n} \nusing io :: gi;\nusing io :: putc;\nusing io :: print;\nconst int N=25e4+5,mod=1e9+7;\nchar s[N];\nint x[6],power[6][N],xinv[6],powerinv[6][N];\ninline void add(int &x,ri y){\n\tx=(x+=y)>=mod?x-mod:x;\n}\ninline void del(int &x,ri y){\n\tx=(x-=y)<0?x+mod:x;\n}\nstruct node{\n\tint y[6];\n\tinline bool operator <(const node &rhs)const{\n\t\tfor(ri i=0;i^6;++i)\n\t\t\tif(y[i]!=rhs.y[i])\n\t\t\t\treturn y[i]<rhs.y[i];\n\t\treturn 0;\n\t}\n\tinline void upd(ri p,ri k){\n\t\tri i;\n\t\tif(p>=0){\n\t\t\tif(k==1){\n\t\t\t\tfor(i=0;i^6;++i)\n\t\t\t\t\tadd(y[i],power[i][p]);\n\t\t\t} \n\t\t\telse{\n\t\t\t\tfor(i=0;i^6;++i)\n\t\t\t\t\tdel(y[i],power[i][p]);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(k==1){\n\t\t\t\tfor(i=0;i^6;++i)\n\t\t\t\t\tadd(y[i],powerinv[i][-p]);\n\t\t\t} \n\t\t\telse{\n\t\t\t\tfor(i=0;i^6;++i)\n\t\t\t\t\tdel(y[i],powerinv[i][-p]);\n\t\t\t}\n\t\t}\n\t}\n}res,res0,now;\nstruct orz{\n\tint k,b;\n\tinline void operator +=(const int &rhs){\n\t\tadd(b,1);\n\t}\n\tinline void operator -=(const int &rhs){\n\t\tdel(b,1);\n\t}\n\tinline void operator *=(const int &rhs){\n\t\tk=(ll)k*rhs%mod;\n\t\tb=(ll)b*rhs%mod;\n\t}\n};\nstruct poly{\n\torz f[6];\n\tinline void upd1(){\n\t\tfor(ri i=0;i^6;++i)\n\t\t\tf[i]-=1;\n\t}\n\tinline void upd2(){\n\t\tfor(ri i=0;i^6;++i)\n\t\t\tf[i]+=1;\n\t}\n\tinline void upd3(){\n\t\tfor(ri i=0;i^6;++i)\n\t\t\tf[i]*=xinv[i];\n\t}\n\tinline void upd4(){\n\t\tfor(ri i=0;i^6;++i)\n\t\t\tf[i]*=x[i];\n\t}\n}resinv;\nmap<node,int> G;\ninline int fpow(ri a,ri b){\n\tri ans=1;\n\tfor(;b;b>>=1,a=(ll)a*a%mod)\n\t\tif(b&1) ans=(ll)ans*a%mod;\n\treturn ans;\n}\nint main(){\n\tsrand(size_t(new char));\n\tri n,i,j,nowp,ans;\n\tscanf(\"%d%s\",&n,s+1);\n\tfor(i=0;i^6;++i){\n\t\tx[i]=rand()%(mod-1)+1; // linux \n\t\tpower[i][0]=1;\n\t\tfor(j=1;j<=n;++j)\n\t\t\tpower[i][j]=(ll)power[i][j-1]*x[i]%mod;\n\t\txinv[i]=fpow(x[i],mod-2);\n\t\tpowerinv[i][0]=1;\n\t\tfor(j=1;j<=n;++j)\n\t\t\tpowerinv[i][j]=(ll)powerinv[i][j-1]*xinv[i]%mod;\n\t}\n\tnowp=0;\n\tfor(i=1;i<=n;++i)\n\t\tif(s[i]=='+')\n\t\t\tres0.upd(nowp,1);\n\t\telse if(s[i]=='-')\n\t\t\tres0.upd(nowp,-1);\n\t\telse if(s[i]=='>')\n\t\t\t++nowp;\n\t\telse\n\t\t\t--nowp;\n\tnowp=0;\n\tans=0;\n\tfor(i=0;i^6;++i) resinv.f[i].k=1;\n\t++G[res0];\n\tfor(i=1;i<=n;++i){\n\t\tif(s[i]=='+')\n\t\t\tres.upd(nowp,1),\n\t\t\tresinv.upd1();\n\t\telse if(s[i]=='-')\n\t\t\tres.upd(nowp,-1),\n\t\t\tresinv.upd2();\n\t\telse if(s[i]=='>')\n\t\t\t++nowp,\n\t\t\tresinv.upd3();\n\t\telse\n\t\t\t--nowp,\n\t\t\tresinv.upd4();\n\t\tans+=G[res];\n\t\tfor(j=0;j^6;++j)\n\t\t\tnow.y[j]=(ll)(res0.y[j]-resinv.f[j].b+mod)*fpow(resinv.f[j].k,mod-2)%mod;\n\t\t++G[now];\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \nusing namespace std;\n \n#define int unsigned int\n \nconst int   mod = 1e9 + 7;\nconst int   N   = 5e5 + 1;\nconst int   phi = 1ll << 30;\n \nint n, p[N], f[N];\nint H[N];\nstring S;\n \nint qpow(int a,int exp) {\n    int ans = 1;\n    for(; exp > 0 ; exp >>= 1)  {\n        if(exp & 1) ans = ans * a;\n        a = a * a;\n    }\n    return ans;\n}\n \nmap<int,int> mp;\n \nsigned main()   {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n \n    cin >> n >> S;\n \n    p[0] = 1;\n \n    for(int i = 1 ; i <= 2 * n ; ++i)\n        p[i] = p[i - 1] * mod;\n \n    f[0] = n;\n \n    for(int i = 0 ; i < n ; ++i)    {\n        f[i + 1] = f[i];\n        H[i + 1] = H[i];\n        if(S[i] == '>') f[i + 1]++;\n        if(S[i] == '<') f[i + 1]--;\n        if(S[i] == '+') H[i + 1] += p[f[i]];\n        if(S[i] == '-') H[i + 1] -= p[f[i]];\n    }\n \n    mp[H[n]] = 1;\n \n    long long ans = 0;\n \n    for(int i = 1 ; i <= n ; ++i)    {\n        ans += mp[H[i]];\n        int exp = f[i] - n;\n        int mul;\n        if(exp < 0) mul = qpow(p[-exp],mod - 2);\n        else        mul = p[exp];\n        mp[H[n] * mul + H[i]]++;\n    }\n \n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int mod = 1004535809;\ntypedef long long LL;\nvoid reduce(int & x) { x += x >> 31 & mod; }\nint mul(int a, int b) { return (LL) a * b % mod; }\nint fastpow(int a, int b, int res = 1) {\n\tfor (; b; b >>= 1, a = mul(a, a)) if (b & 1) res = mul(res, a);\n\treturn res;\n}\nstd::mt19937 rd(time(0) + (size_t) new char);\nconst int MAXN = 250010;\nstruct func {\n\tint a, b;\n\tfunc() { a = b = 0; }\n\tfunc(int x, int y) { a = x, b = y; }\n\tfriend func operator + (func x, func y){ // x(y())\n\t\treturn func(mul(x.a, y.a), ((LL) x.a * y.b + x.b) % mod);\n\t}\n\tint operator () (int x) {\n\t\treturn ((LL) x * a + b) % mod;\n\t}\n} pre[2][MAXN];\nint to[256];\nfunc fs[2][4];\nint n;\nchar buf[MAXN];\ntypedef std::pair<int, int> pi;\nstd::map<pi, int> S;\nint main() {\n\tstd::ios_base::sync_with_stdio(false), std::cin.tie(0);\n\tstd::cin >> n >> buf + 1;\n\tto['+'] = 0, to['-'] = 1, to['<'] = 2, to['>'] = 3;\n\tconst int x1 = rd() % (mod - 1) + 1, inv1 = fastpow(x1, mod - 2);\n\tconst int x2 = rd() % (mod - 1) + 1, inv2 = fastpow(x2, mod - 2);\n\tfs[0][0] = func(1, 1), fs[1][0] = func(1, 1);\n\tfs[0][1] = func(1, mod - 1), fs[1][1] = func(1, mod - 1);\n\tfs[0][2] = func(x1, 0), fs[1][2] = func(x2, 0);\n\tfs[0][3] = func(inv1, 0), fs[1][3] = func(inv2, 0);\n\tpre[0][0] = pre[1][0] = func(1, 0);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tint tar = to[buf[i]];\n\t\tpre[0][i] = pre[0][i - 1] + fs[0][tar];\n\t\tpre[1][i] = pre[1][i - 1] + fs[1][tar];\n\t}\n\tLL ans = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\t++S[pi((pre[0][i - 1] + pre[0][n])(0), (pre[1][i - 1] + pre[1][n])(0))];\n\t\tans += S[pi(pre[0][i](0), pre[1][i](0))];\n\t}\n\tstd::cout << ans << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <vector>\nusing namespace std;\n#define fst first\n#define snd second\nusing ll = long long;\nusing I = pair<int, int>;\n\nll mod_pow(ll x, ll e, ll M) {\n  ll v = 1;\n  for (; e > 0; e >>= 1) {\n    if (e & 1) {\n      v = v * x % M;\n    }\n    x = x * x % M;\n  }\n  return v;\n}\n\nll inverse(ll x, ll M) { return mod_pow(x, M - 2, M); }\n\nint main() {\n  int N;\n  string S;\n  while (cin >> N >> S) {\n    ll base = 9973ll;\n    vector<ll> mods = {ll(1e9 + 7), ll(1e9 + 9)};\n    vector<vector<ll>> pows(mods.size(), vector<ll>(2 * N + 1));\n    for (int i = 0; i < mods.size(); i++) {\n      for (int e = -N; e <= N; e++) {\n        ll p = mod_pow(base, (ll)abs(-e), mods[i]);\n        if (e < 0) {\n          p = inverse(p, mods[i]);\n        }\n        pows[i][e + N] = p;\n      }\n    }\n    vector<int> P(N + 1, 0);\n    vector<vector<ll>> H(N + 1, vector<ll>(mods.size(), 0));\n    for (int i = 0; i < N; i++) {\n      P[i + 1] = P[i];\n      H[i + 1] = H[i];\n      if (S[i] == '<') --P[i + 1];\n      if (S[i] == '>') ++P[i + 1];\n      if (S[i] == '+') {\n        for (int j = 0; j < mods.size(); j++)\n          H[i + 1][j] = (H[i + 1][j] + pows[j][P[i + 1] + N]) % mods[j];\n      }\n      if (S[i] == '-') {\n        for (int j = 0; j < mods.size(); j++)\n          H[i + 1][j] =\n              (H[i + 1][j] - pows[j][P[i + 1] + N] + mods[j]) % mods[j];\n      }\n    }\n    vector<ll> A = H[N];\n    map<vector<ll>, int> mp;\n    ll res = 0;\n    for (int i = N - 1; i >= 0; i--) {\n      ++mp[H[i + 1]];\n      vector<ll> Q(mods.size(), 0);\n      for (int j = 0; j < mods.size(); j++)\n        Q[j] = ((A[j] * pows[j][P[i] + N] % mods[j]) + H[i][j]) % mods[j];\n      res += mp[Q];\n    }\n    cout << res << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) std::cerr << #x << \" = \" << (x) << std::endl\nusing ll = long long;\nstd::mt19937 mt{std::random_device{}()};\ntemplate <typename T>\nconstexpr std::pair<T, T> extgcd(const T a, const T b)\n{\n    if (b == 0) { return std::pair<T, T>{1, 0}; }\n    const auto p = extgcd(b, a % b);\n    return {p.second, p.first - p.second * (a / b)};\n}\ntemplate <typename T>\nconstexpr T inverse(const T a, const T mod) { return (mod + extgcd(a, mod).first % mod) % mod; }\nconstexpr int H = 10;  //関数値サンプルの個数\nconstexpr ll MOD1 = 1000000007LL, MOD2 = 1000000009LL;\nconstexpr ll X[H] = {2371983LL, 1231LL, 123123LL, 4329075LL, 134121LL, 231788LL, 12234LL, 9218739LL, 912380LL, 556LL};\nconstexpr ll XINV1[H] = {inverse(X[0], MOD1), inverse(X[1], MOD1), inverse(X[2], MOD1), inverse(X[3], MOD1), inverse(X[4], MOD1)};\nconstexpr ll XINV2[H] = {inverse(X[0], MOD2), inverse(X[1], MOD2), inverse(X[2], MOD2), inverse(X[3], MOD2), inverse(X[4], MOD2)};\ntemplate <typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, const std::pair<S, T>& p) { return (os << \"<\" << p.first << \",\" << p.second << \">\"); }\ntemplate <typename T, typename A>\nstd::ostream& operator<<(std::ostream& os, const std::vector<T, A>& v)\n{\n    os << \"[\";\n    for (const auto& p : v) { os << p << \",\"; }\n    return (os << \"]\\n\");\n}\nint main()\n{\n    int N;\n    std::string S;\n    std::cin >> N >> S;\n    using P = std::pair<ll, ll>;\n    std::vector<int> deg(N + 1, 0);\n    std::vector<std::vector<P>> value(N + 1, std::vector<P>(H, {0LL, 0LL}));\n    auto plus = [](const P& p1, const P& p2) { return P{(p1.first + p2.first) % MOD1, (p1.second + p2.second) % MOD2}; };\n    auto minus = [](const P& p1, const P& p2) { return P{(p1.first + MOD1 - p2.first) % MOD1, (p1.second + MOD2 - p2.second) % MOD2}; };\n    auto rshift = [](const P& p, const int i) { return P{p.first * X[i] % MOD1, p.second * X[i] % MOD2}; };\n    auto lshift = [](const P& p, const int i) { return P{p.first * XINV1[i] % MOD1, p.second * XINV2[i] % MOD2}; };\n    auto mul = [](const P& p1, const P& p2) { return P{p1.first * p2.first % MOD1, p1.second * p2.second % MOD2}; };\n    for (int i = N - 1; i >= 0; i--) {\n        if (S[i] == '-') {\n            deg[i] = deg[i + 1];\n            for (int j = 0; j < H; j++) { value[i][j] = minus(value[i + 1][j], {1, 1}); }\n        } else if (S[i] == '+') {\n            deg[i] = deg[i + 1];\n            for (int j = 0; j < H; j++) { value[i][j] = plus(value[i + 1][j], {1, 1}); }\n        } else if (S[i] == '>') {\n            deg[i] = deg[i + 1] + 1;\n            for (int j = 0; j < H; j++) { value[i][j] = rshift(value[i + 1][j], j); }\n        } else {\n            deg[i] = deg[i + 1] - 1;\n            for (int j = 0; j < H; j++) { value[i][j] = lshift(value[i + 1][j], j); }\n        }\n    }\n    // show(deg);\n    // show(value);\n    constexpr int L = 250000;\n    std::vector<std::vector<P>> power(L + 1, std::vector<P>(H, {1, 1}));\n    std::vector<std::vector<P>> invpower(L + 1, std::vector<P>(H, {1, 1}));\n    auto invp = [&](const int i, const int j) { return i >= 0 ? invpower[i][j] : power[-i][j]; };\n    for (int i = 1; i <= L; i++) {\n        for (int j = 0; j < H; j++) { power[i][j] = rshift(power[i - 1][j], j), invpower[i][j] = lshift(power[i - 1][j], j); }\n    }\n    std::vector<P> answer(H);\n    for (int i = 0; i < H; i++) { answer[i] = value[0][i]; }\n    //show(answer);\n    std::vector<std::vector<P>> hash(N + 1, std::vector<P>(H));\n    for (int i = 0; i <= N; i++) {\n        for (int j = 0; j < H; j++) { hash[i][j] = mul(minus(value[i][j], answer[j]), invp(deg[i], j)); }\n    }\n    //    show(hash);\n    using VP = std::vector<P>;\n    std::map<VP, ll> mp;\n    ll ans = 0;\n    for (int i = 0; i <= N; i++) {\n        std::vector<P> obj(H);\n        for (int j = 0; j < H; j++) { obj[j] = plus(hash[i][j], mul(invp(deg[i], j), answer[j])); }\n        if (mp.find(obj) != mp.end()) { ans += mp[obj]; }\n        mp[hash[i]]++;\n    }\n    std::cout << ans << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef unsigned long long ull;\n#define mp make_pair\n\nconst int K = 4;\nll MODS[] = {(ll)1e9 + 7, (ll)1e9 + 9, (ll)1e9 + 21, (ll)1e9 + 33};\n\nll bin_pow(ll x, ll p, ll mm) {\n\tif (p == 0) return 1;\n\tif (p & 1) return (x * bin_pow(x, p - 1, mm)) % mm;\n\tll y = bin_pow(x, p / 2, mm);\n\treturn (y * y) % mm;\n}\n\nstruct PolyHash {\n\tll x[K];\n\n\tPolyHash() : x() {}\n\tPolyHash(ll Z) {\n\t\tfor (int i = 0; i < K; i++)\n\t\t\tx[i] = Z % MODS[i];\n\t}\n\n\tPolyHash operator + (const PolyHash &H) const {\n\t\tPolyHash res = PolyHash();\n\t\tfor (int i = 0; i < K; i++) {\n\t\t\tres.x[i] = (x[i] + H.x[i]) % MODS[i];\n\t\t}\n\t\treturn res;\n\t}\n\n\tPolyHash operator - (const PolyHash &H) const {\n\t\tPolyHash res = PolyHash();\n\t\tfor (int i = 0; i < K; i++) {\n\t\t\tres.x[i] = (x[i] - H.x[i] + MODS[i]) % MODS[i];\n\t\t}\n\t\treturn res;\n\t}\n\n\tPolyHash operator * (const PolyHash &H) const {\n\t\tPolyHash res = PolyHash();\n\t\tfor (int i = 0; i < K; i++) {\n\t\t\tres.x[i] = (x[i] * H.x[i]) % MODS[i];\n\t\t}\n\t\treturn res;\n\t}\n\n\tbool operator < (const PolyHash &H) const {\n\t\tfor (int i = 0; i < K; i++) {\n\t\t\tif (x[i] != H.x[i])\n\t\t\t\treturn x[i] < H.x[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nconst int N = 500500;\nconst int M = N / 2;\nPolyHash pw[N];\nPolyHash a[N], b[N];\nint c[N];\nchar s[N];\nint L;\nmap<PolyHash, ll> mapchik;\n\nvoid precalc() {\n\tpw[M] = PolyHash(1);\n\tpw[M + 1] = PolyHash(1234567);\n\tpw[M - 1].x[0] = bin_pow(1234567, MODS[0] - 2, MODS[0]);\n\tpw[M - 1].x[1] = bin_pow(1234567, MODS[1] - 2, MODS[1]);\n\tfor (int i = M + 2; i < N; i++)\n\t\tpw[i] = pw[i - 1] * pw[M + 1];\n\tfor (int i = M - 2; i >= 0; i--)\n\t\tpw[i] = pw[i + 1] * pw[M - 1];\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tprecalc();\n\n\tscanf(\"%d %s\", &L, s);\n\tint pos = M;\n\ta[0] = 0;\n\tc[0] = pos;\n\tfor (int i = 0; i < L; i++) {\n\t\ta[i + 1] = a[i];\n\t\tif (s[i] == '+') {\n\t\t\ta[i + 1] = a[i + 1] + pw[pos];\n\t\t} else if (s[i] == '-') {\n\t\t\ta[i + 1] = a[i + 1] - pw[pos];\n\t\t} else if (s[i] == '>') {\n\t\t\tpos++;\n\t\t} else if (s[i] == '<') {\n\t\t\tpos--;\n\t\t} else throw;\n\t\tc[i + 1] = pos;\n\t}\n\tb[L] = 0;\n\tfor (int i = L - 1; i >= 0; i--) {\n\t\tb[i] = b[i + 1];\n\t\tif (s[i] == '+') {\n\t\t\tb[i] = b[i] + pw[pos];\n\t\t} else if (s[i] == '-') {\n\t\t\tb[i] = b[i] - pw[pos];\n\t\t} else if (s[i] == '>') {\n\t\t\tpos--;\n\t\t} else if (s[i] == '<') {\n\t\t\tpos++;\n\t\t} else throw;\n\t}\n\n\tPolyHash H = a[L];\n\n/*\n\tfor (int i = 0; i <= L; i++)\n\t\tprintf(\"%llu \", a[i]);\n\tprintf(\"\\n\");\n\tfor (int i = 0; i <= L; i++)\n\t\tprintf(\"%llu \", b[i]);\n\tprintf(\"\\n\");\n*/\n\tll ans = 0;\n\tfor (int i = L; i >= 0; i--) {\n\t\tPolyHash Z = H - H * pw[c[i]] - a[i];\n\t\tans += mapchik[Z];\n\t\tmapchik[b[i]]++;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\ntemplate<unsigned P> struct ModInt {\n  using M = ModInt;\n  unsigned v;\n  ModInt() : v(0) {}\n  ModInt(auto x) : v(x >= 0 ? x % P : (P - -x % P) % P) {}\n  constexpr ModInt(unsigned v, int) : v(v) {}\n  static constexpr unsigned p() { return P; }\n  M operator+() const { return *this; }\n  M operator-() const { return {v ? P - v : 0, 0}; }\n  explicit operator bool() const noexcept { return v; }\n  bool operator!() const noexcept { return !(bool)*this; }\n  M operator*(M r) const { return M(*this) *= r; }\n  M operator/(M r) const { return M(*this) /= r; }\n  M operator+(M r) const { return M(*this) += r; }\n  M operator-(M r) const { return M(*this) -= r; }\n  bool operator==(M r) const { return v == r.v; }\n  bool operator!=(M r) const { return !(*this == r); }\n  M& operator*=(M r) { v = (uint64_t)v * r.v % P; return *this; }\n  M& operator/=(M r) { return *this *= r.inv(); }\n  M& operator+=(M r) { if ((v += r.v) >= P) v -= P; return *this; }\n  M& operator-=(M r) { if ((v += P - r.v) >= P) v -= P; return *this; }\n  M inv() const {\n    int a = v, b = P, x = 1, u = 0;\n    while (b) {\n      int q = a / b;\n      swap(a -= q * b, b);\n      swap(x -= q * u, u);\n    }\n    assert(a == 1);\n    return x;\n  }\n  M pow(auto n) const {\n    if (n < 0) return pow(-n).inv();\n    M res = 1;\n    for (M a = *this; n; a *= a, n >>= 1) if (n & 1) res *= a;\n    return res;\n  }\n  friend M operator*(auto l, M r) { return M(l) *= r; }\n  friend M operator/(auto l, M r) { return M(l) /= r; }\n  friend M operator+(auto l, M r) { return M(l) += r; }\n  friend M operator-(auto l, M r) { return M(l) -= r; }\n  friend ostream& operator<<(ostream& os, M r) { return os << r.v; }\n  friend istream& operator>>(istream& is, M& r) { lint x; is >> x; r = x; return is; }\n  friend bool operator==(auto l, M r) { return M(l) == r; }\n  friend bool operator!=(auto l, M r) { return !(l == r); }\n};\nusing M0 = ModInt<(unsigned)2e9 + 11>;\nusing M1 = ModInt<(unsigned)2e9 + 33>;\n\ntemplate<class Z> Z rng(Z a, Z b) {\n  static mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\n  return uniform_int_distribution<Z>(a, b - 1)(mt);\n}\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n; cin >> n;\n  string s; cin >> s;\n  M0 B0 = rng(1u, M0::p()), iB0 = B0.inv();\n  M1 B1 = rng(1u, M1::p()), iB1 = B1.inv();\n  V<M0> powB0{1};\n  V<M1> powB1{1};\n  for (int _ = 0; _ < 2 * n; ++_) {\n    powB0.push_back(powB0.back() * B0);\n    powB1.push_back(powB1.back() * B1);\n  }\n\n  map< pair<int, int>, int > mp;\n  int p = n;\n  V<M0> h0{0};\n  V<M1> h1{0};\n  for (int i = 0; i < n; ++i) {\n    h0.push_back(h0.back());\n    h1.push_back(h1.back());\n    if (s[i] == '>') ++p;\n    if (s[i] == '<') --p;\n    if (s[i] == '+') {\n      h0.back() += powB0[p];\n      h1.back() += powB1[p];\n    }\n    if (s[i] == '-') {\n      h0.back() -= powB0[p];\n      h1.back() -= powB1[p];\n    }\n    ++mp[{h0.back().v, h1.back().v}];\n  }\n\n  lint res = 0;\n  M0 a0 = 1, b0;\n  M1 a1 = 1, b1;\n  for (int i = 0; i < n; ++i) {\n    M0 t0 = a0 * h0.back() + b0;\n    M1 t1 = a1 * h1.back() + b1;\n    res += mp[{t0.v, t1.v}];\n    if (s[i] == '>') {\n      a0 *= B0;\n      a1 *= B1;\n    }\n    if (s[i] == '<') {\n      a0 *= iB0;\n      a1 *= iB1;\n    }\n    if (s[i] == '+') {\n      b0 += a0 * powB0[n];\n      b1 += a1 * powB1[n];\n    }\n    if (s[i] == '-') {\n      b0 -= a0 * powB0[n];\n      b1 -= a1 * powB1[n];\n    }\n    --mp[{h0[i + 1].v, h1[i + 1].v}];\n  }\n  cout << res << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 250010;\nconst int mod[] = {1000000007, 1000000009};\nconst int P[] = {131, 233};\n\ntypedef long long LL;\n\nint Pow[2][N * 2]; char s[N];\n\ninline int FUCK(int x, int y, int mod) {\n    int res = 1;\n    for (; y; y >>= 1, x = (LL)x * x % mod) if (y & 1) res = (LL)res * x % mod;\n    return res;\n}\n\nstruct Data {\n    int val[2];\n\n    Data(int a = 0, int b = 0) {val[0] = a, val[1] = b;} \n\n    Data operator + (const Data &b) {\n        Data res;\n        res.val[0] = (val[0] + b.val[0]) % mod[0];\n        res.val[1] = (val[1] + b.val[1]) % mod[1];\n        return res;\n    }\n\n    Data operator - (const Data &b) {\n        Data res;\n        res.val[0] = (val[0] - b.val[0] + mod[0]) % mod[0];\n        res.val[1] = (val[1] - b.val[1] + mod[1]) % mod[1]; \n        return res;\n    }\n\n    Data operator * (const int b) {\n        Data res = *this;\n        int a = b >= 0 ? Pow[0][b] : FUCK(P[0], (LL)(mod[0] - 2) * (-b) % (mod[0] - 1), mod[0]);\n        int c = b >= 0 ? Pow[1][b] : FUCK(P[1], (LL)(mod[1] - 2) * (-b) % (mod[1] - 1), mod[1]);\n        res.val[0] = (LL)res.val[0] * a % mod[0];\n        res.val[1] = (LL)res.val[1] * c % mod[1];\n        return res;\n    }\n\n    bool operator < (const Data &b) const {\n        if (val[0] != b.val[0]) return val[0] < b.val[0];\n        return val[1] < b.val[1];\n    }\n};\n\nmap<Data, int> mp;\n\ninline void increase(Data &a, int b) {\n    a = a + (Data){Pow[0][b], Pow[1][b]};\n}\n\ninline void decrease(Data &a, int b) {\n    a = a - (Data){Pow[0][b], Pow[1][b]};\n}\n\nint main() {\n    int n; scanf(\"%d%s\", &n, s + 1); Data all;\n    Pow[0][0] = Pow[1][0] = 1;\n    for (int i = 0; i <= 1; i++)\n        for (int j = 1; j <= n * 2; j++)\n            Pow[i][j] = (LL)Pow[i][j - 1] * P[i] % mod[i];\n    for (int i = 1, ls = 0; i <= n; i++) {\n        if (s[i] == '<') ls--;\n        else if (s[i] == '>') ls++;\n        else if (s[i] == '+') increase(all, ls + n);\n        else decrease(all, ls + n);\n    }\n    Data fuck; mp[all] = 1; LL res = 0;\n    for (int i = 1, ls = 0; i <= n; i++) {\n        if (s[i] == '<') ls--;\n        else if (s[i] == '>') ls++;\n        else if (s[i] == '+') increase(fuck, ls + n);\n        else decrease(fuck, ls + n);\n        res += mp[fuck], mp[fuck + all * ls]++;\n    }\n    printf(\"%lld\\n\", res);\n    return 0;\n}//"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\nconst ull base0=998244353ull;\nconst ull invr0=996491785301655553ull;\nconst ui base1=1e9+7;\nconst ui invr1=2068349879u;\nconst int maxn=2.5e5+3;\nconst int maxl=5e5+10;\nstruct H {\n\tull x;\n\tui y;\n\texplicit H ():x(0),y(0) {}\n\texplicit H (ull _x,ui _y):x(_x),y(_y) {}\n\tinline H& operator = (const int &k) {\n\t\tx=k,y=k;\n\t\treturn *this;\n\t}\n\tinline H& operator *= (const H &h) {\n\t\tx*=h.x,y*=h.y;\n\t\treturn *this;\n\t}\n\tinline H& operator += (const H &h) {\n\t\tx+=h.x,y+=h.y;\n\t\treturn *this;\n\t}\n\tinline H& operator -= (const H &h) {\n\t\tx-=h.x,y-=h.y;\n\t\treturn *this;\n\t}\n\tinline friend H operator * (H a,const H &b) {\n\t\treturn a*=b;\n\t}\n\tinline friend H operator + (H a,const H &b) {\n\t\treturn a+=b;\n\t}\n\tinline bool operator < (const H &h) const {\n\t\treturn (x*y)<(h.x*h.y);\n\t}\n} base(base0,base1),invr(invr0,invr1);\nnamespace num {\n\tH _mi[maxl],*mi=_mi+maxn;\n\tvoid init() {\n\t\tmi[0]=1;\n\t\tfor (int i=1;i<maxn;++i) mi[i]=mi[i-1]*base;\n\t\tfor (int i=1;i<maxn;++i) mi[-i]=mi[-i+1]*invr;\n\t}\n\tint __initer__=(init(),0);\n}\nint n;\nchar s[maxn];\nmap<H,int> mp;\nnamespace has {\n\tH val[maxn],cur;\n\tint pos[maxn];\n\tvoid deal(int &p,char c) {\n\t\tif (c=='<') --p; else\n\t\tif (c=='>') ++p; else\n\t\tif (c=='+') cur+=num::mi[p]; else\n\t\tif (c=='-') cur-=num::mi[p]; else\n\t\tassert(false);\n\t}\n\tH work() {\n\t\tint p=0;\n\t\tfor (int i=1;i<=n;++i) {\n\t\t\tdeal(p,s[i]);\n\t\t\tval[i]=cur;\n\t\t\tpos[i]=p;\n\t\t}\n\t\treturn cur;\n\t}\n}\nint main() {\n\tscanf(\"%d%s\",&n,s+1);\n\tH all=has::work();\n\tlong long ans=0;\n\tfor (int i=n;i>=0;--i) {\n\t\tH tmp=all*num::mi[has::pos[i]]+has::val[i];\n\t\tans+=mp[tmp];\n\t\t++mp[has::val[i]];\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define int unsigned long long\n\nconst int   mod = 1e9 + 7;\nconst int   N   = 5e5 + 1;\nconst int   phi = 1 << 30;\n\nint n, p[N], f[N];\nint H[N];\nstring S;\n\nint qpow(int a,int exp) {\n    int ans = 1;\n    for(; exp > 0 ; exp >>= 1)  {\n        if(exp & 1) ans = ans * a;\n        a = a * a;\n    }\n    return ans;\n}\n\nmap<int,int> mp;\n\nsigned main()   {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    cin >> n >> S;\n\n    p[0] = 1;\n\n    for(int i = 1 ; i <= 2 * n ; ++i)\n        p[i] = p[i - 1] * mod;\n\n    f[0] = n;\n\n    for(int i = 0 ; i < n ; ++i)    {\n        f[i + 1] = f[i];\n        H[i + 1] = H[i];\n        if(S[i] == '>') f[i + 1]++;\n        if(S[i] == '<') f[i + 1]--;\n        if(S[i] == '+') H[i + 1] += p[f[i]];\n        if(S[i] == '-') H[i + 1] -= p[f[i]];\n    }\n\n    mp[H[n]] = 1;\n\n    int ans = 0;\n\n    for(int i = 1 ; i <= n ; ++i)    {\n        ans += mp[H[i]];\n        int exp = f[i] - n;\n        int mul;\n        if(exp < 0) mul = qpow(p[-exp],mod - 2);\n        else        mul = p[exp];\n        mp[H[n] * mul + H[i]]++;\n    }\n\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define int long long\n#define ull unsigned long long\n\nconst int Maxv = 500010; \nconst ull Prime1 = 239; \nconst ull Prime2 = 223372036854775763; \n                            \nint idx[Maxv], ans, n; \null Hash[Maxv], val[Maxv]; \nchar s[Maxv]; \n\nstd::unordered_map<ull, int> Map; \n\ninline void PreHandle() {\n    val[n] = 1; \n    for (int i = n + 1; i <= (n << 1); i++)\n        val[i] = val[i - 1] * Prime1; \n    for (int i = n - 1; i >= 0; i--)\n        val[i] = val[i + 1] * Prime2; \n}\n\nsigned main() {\n    scanf(\"%lld\", &n); \n    scanf(\"%s\", s); \n\n    PreHandle(); \n\n    for (int i = 0; i < n; i++) {\n        Hash[i + 1] = Hash[i]; \n        idx[i + 1] = idx[i]; \n\n        if (s[i] == '>')\n            idx[i + 1]++; \n        if (s[i] == '<')\n            idx[i + 1]--;\n        if (s[i] == '+')\n            Hash[i + 1] += val[n + idx[i + 1]]; \n        if (s[i] == '-')\n            Hash[i + 1] -= val[n + idx[i + 1]]; \n    }\n    \n    for (int i = n; i >= 0; i--) {\n        ull tmp = Hash[i] + Hash[n] * val[n + idx[i]];\n        ans += Map[tmp]; \n        Map[ Hash[i] ]++;\n    }\n\n    printf(\"%lld\\n\", ans);\n\n    return 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<map>\n#define ll long long\n#define mid (l+r)/2\nusing namespace std;\nconst ll MOD1=1e9+9,b1=1000003,invb1=27749917;\nconst ll MOD2=1e9+7,b2=999983,invb2=496501444;\nconst ll MOD3=998244353,b3=999979,invb3=536166305;\nint n;\nchar s[250005];\nll v1,v2,v3,v11[250005],v12[250005],v13[250005],p1[250005],p2[250005],p3[250005],v21[250005],v22[250005],v23[250005],ans;\nmap<pair<ll,ll>,int>mp;\nvoid solve(int l,int r)\n{\n\tif(l==r)\n\t{\n\t\tif(s[l]=='+'&&v1==1&&v2==1&&v3==1)ans++;\n\t\tif(s[l]=='-'&&v1==MOD1-1&&v2==MOD2-1&&v3==MOD3-1)ans++;\n\t\tif(s[l]=='<'&&v1==0&&v2==0&&v3==0)ans++;\n\t\tif(s[l]=='>'&&v1==0&&v2==0&&v3==0)ans++;\n\t\treturn;\n\t}\n\tsolve(l,mid);\n\tsolve(mid+1,r);\n\tv11[mid+1]=v12[mid+1]=v13[mid+1]=0;\n\tv21[mid]=v22[mid]=v23[mid]=0;\n\tp1[mid+1]=p2[mid+1]=p3[mid+1]=1;\n\tfor(int i=mid;i>=l;i--)\n\t{\n\t\tif(s[i]=='+')\n\t\t{\n\t\t\tv11[i]=(v11[i+1]+1)%MOD1,p1[i]=p1[i+1];\n\t\t\tv12[i]=(v12[i+1]+1)%MOD2,p2[i]=p2[i+1];\n\t\t\tv13[i]=(v13[i+1]+1)%MOD3,p3[i]=p3[i+1];\n\t\t}\n\t\tif(s[i]=='-')\n\t\t{\n\t\t\tv11[i]=(v11[i+1]-1+MOD1)%MOD1,p1[i]=p1[i+1];\n\t\t\tv12[i]=(v12[i+1]-1+MOD2)%MOD2,p2[i]=p2[i+1];\n\t\t\tv13[i]=(v13[i+1]-1+MOD3)%MOD3,p3[i]=p3[i+1];\n\t\t}\n\t\tif(s[i]=='<')\n\t\t{\n\t\t\tv11[i]=v11[i+1]*invb1%MOD1,p1[i]=p1[i+1]*b1%MOD1;\n\t\t\tv12[i]=v12[i+1]*invb2%MOD2,p2[i]=p2[i+1]*b2%MOD2;\n\t\t\tv13[i]=v13[i+1]*invb3%MOD3,p3[i]=p3[i+1]*b3%MOD3;\n\t\t}\n\t\tif(s[i]=='>')\n\t\t{\n\t\t\tv11[i]=v11[i+1]*b1%MOD1,p1[i]=p1[i+1]*invb1%MOD1;\n\t\t\tv12[i]=v12[i+1]*b2%MOD2,p2[i]=p2[i+1]*invb2%MOD2;\n\t\t\tv13[i]=v13[i+1]*b3%MOD3,p3[i]=p3[i+1]*invb3%MOD3;\n\t\t}\n\t}\n\tll now1=1,now2=1,now3=1;\n\tfor(int i=mid+1;i<=r;i++)\n\t{\n\t\tif(s[i]=='+')\n\t\t{\n\t\t\tv21[i]=(v21[i-1]+now1)%MOD1;\n\t\t\tv22[i]=(v22[i-1]+now2)%MOD2;\n\t\t\tv23[i]=(v23[i-1]+now3)%MOD3;\n\t\t}\n\t\tif(s[i]=='-')\n\t\t{\n\t\t\tv21[i]=(v21[i-1]-now1+MOD1)%MOD1;\n\t\t\tv22[i]=(v22[i-1]-now2+MOD2)%MOD2;\n\t\t\tv23[i]=(v23[i-1]-now3+MOD3)%MOD3;\n\t\t}\n\t\tif(s[i]=='<')\n\t\t{\n\t\t\tnow1=now1*invb1%MOD1,v21[i]=v21[i-1];\n\t\t\tnow2=now2*invb2%MOD2,v22[i]=v22[i-1];\n\t\t\tnow3=now3*invb3%MOD3,v23[i]=v23[i-1];\n\t\t}\n\t\tif(s[i]=='>')\n\t\t{\n\t\t\tnow1=now1*b1%MOD1,v21[i]=v21[i-1];\n\t\t\tnow2=now2*b2%MOD2,v22[i]=v22[i-1];\n\t\t\tnow3=now3*b3%MOD3,v23[i]=v23[i-1];\n\t\t}\n\t\tmp[make_pair(v21[i]*1000000000+v22[i],v23[i])]++;\n\t}\n\tfor(int i=l;i<=mid;i++)\n\t{\n\t\tll x1=(v1-v11[i]+MOD1)*p1[i]%MOD1;\n\t\tll x2=(v2-v12[i]+MOD2)*p2[i]%MOD2;\n\t\tll x3=(v3-v13[i]+MOD3)*p3[i]%MOD3;\n\t\tans+=mp[make_pair(x1*1000000000+x2,x3)];\n\t}\n\tmp.clear();\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",s+1);\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tif(s[i]=='+')\n\t\t{\n\t\t\tv1=(v1+1)%MOD1;\n\t\t\tv2=(v2+1)%MOD2;\n\t\t\tv3=(v3+1)%MOD3;\n\t\t}\n\t\tif(s[i]=='-')\n\t\t{\n\t\t\tv1=(v1-1+MOD1)%MOD1;\n\t\t\tv2=(v2-1+MOD2)%MOD2;\n\t\t\tv3=(v3-1+MOD3)%MOD3;\n\t\t}\n\t\tif(s[i]=='<')\n\t\t{\n\t\t\tv1=v1*invb1%MOD1;\n\t\t\tv2=v2*invb2%MOD2;\n\t\t\tv3=v3*invb3%MOD3;\n\t\t}\n\t\tif(s[i]=='>')\n\t\t{\n\t\t\tv1=v1*b1%MOD1;\n\t\t\tv2=v2*b2%MOD2;\n\t\t\tv3=v3*b3%MOD3;\n\t\t}\n\t}\n\tsolve(1,n);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define R return\n#define rep(i,s,t) for(int i=s;i<=(t);++i)\n#define dec(i,s,t) for(int i=s;i>=(t);--i)\nusing namespace std;\ntypedef long long L;\nconst int N=3e5+50;\nconst L P=1000000000000000031LL,X=1000000000000000003LL;\nL add(L a,L b){ a+=b; R a>=P?a-P:a; }\nL sub(L a,L b){ a-=b; R a<0?a+P:a; }\nL mul(L a,L b){ L r=0LL;for(;b;b>>=1LL,a=add(a,a))if(b&1LL)r=add(r,a);return r;}\nL pw(L a,L k){  L r=1LL;for(;k;k>>=1LL,a=mul(a,a))if(k&1LL)r=mul(r,a);return r;}\nL I=pw(X,P-2); \n\nchar s[N]; \nL ans,n,A[N],B[N],u;\nL f(char c,L x){\n\tif(c=='+')R add(x,1); \n\tif(c=='-')R sub(x,1); \n\tif(c=='<')R mul(x,I);\n\tif(c=='>')R mul(x,X); \n\texit(-1);\n}\nvoid g(char c,L &a,L &b){\n\tif(c=='+')b=sub(b,a);\n\tif(c=='-')b=add(b,a);\n\tif(c=='<')a=mul(a,X);\n\tif(c=='>')a=mul(a,I); \n}\nL F(L a,L b,L x){ R add(mul(a,x),b); }\nmap<L,L> M;\nint main(){\n\tscanf(\"%lld%s\",&n,s+1); \n\tdec(i,n,1)u=f(s[i],u); \n\tA[n+1]=1,B[n+1]=0; dec(i,n,1)g(s[i],A[i]=A[i+1],B[i]=B[i+1]); \n\t++M[F(A[n+1],B[n+1],0)]; dec(i,n,1)ans+=M[F(A[i],B[i],u)],++M[F(A[i],B[i],0)];\n\tprintf(\"%lld\\n\",ans);\n\tR 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 250010;\nconst int mod[] = {1004535809, 998244353};\nconst int P[] = {23456781, 16541321};\n\ntypedef long long LL;\n\nint Pow[2][N * 2]; char s[N];\n\ninline int FUCK(int x, int y, int mod) {\n    int res = 1;\n    for (; y; y >>= 1, x = (LL)x * x % mod) if (y & 1) res = (LL)res * x % mod;\n    return res;\n}\n\nstruct Data {\n    int val[2];\n\n    Data(int a = 0, int b = 0) {val[0] = a, val[1] = b;} \n\n    Data operator + (const Data &b) {\n        Data res;\n        res.val[0] = (val[0] + b.val[0]) % mod[0];\n        res.val[1] = (val[1] + b.val[1]) % mod[1];\n        return res;\n    }\n\n    Data operator - (const Data &b) {\n        Data res;\n        res.val[0] = (val[0] - b.val[0] + mod[0]) % mod[0];\n        res.val[1] = (val[1] - b.val[1] + mod[1]) % mod[1]; \n        return res;\n    }\n\n    Data operator * (const int b) {\n        Data res = *this;\n        int a = b >= 0 ? Pow[0][b] : FUCK(P[0], (LL)(mod[0] - 2) * (-b) % mod[0], mod[0]);\n        int c = b >= 0 ? Pow[1][b] : FUCK(P[1], (LL)(mod[1] - 2) * (-b) % mod[1], mod[1]);\n        res.val[0] = (LL)res.val[0] * a % mod[0];\n        res.val[1] = (LL)res.val[1] * c % mod[1];\n        return res;\n    }\n\n    bool operator < (const Data &b) const {\n        if (val[0] != b.val[0]) return val[0] < b.val[0];\n        return val[1] < b.val[1];\n    }\n};\n\nmap<Data, int> mp;\n\ninline void increase(Data &a, int b) {\n    a = a + (Data){Pow[0][b], Pow[1][b]};\n}\n\ninline void decrease(Data &a, int b) {\n    a = a - (Data){Pow[0][b], Pow[1][b]};\n}\n\nint main() {\n    int n; scanf(\"%d%s\", &n, s + 1); Data all;\n    Pow[0][0] = Pow[1][0] = 1;\n    for (int i = 0; i <= 1; i++)\n        for (int j = 1; j <= n * 2; j++)\n            Pow[i][j] = (LL)Pow[i][j - 1] * P[i] % mod[i];\n    for (int i = 1, ls = 0; i <= n; i++) {\n        if (s[i] == '<') ls--;\n        else if (s[i] == '>') ls++;\n        else if (s[i] == '+') increase(all, ls + n);\n        else decrease(all, ls + n);\n    }\n    Data fuck; mp[all] = 1; LL res = 0;\n    for (int i = 1, ls = 0; i <= n; i++) {\n        if (s[i] == '<') ls--;\n        else if (s[i] == '>') ls++;\n        else if (s[i] == '+') increase(fuck, ls + n);\n        else decrease(fuck, ls + n);\n        res += mp[fuck], mp[fuck + all * ls]++;\n    }\n    printf(\"%lld\\n\", res);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<climits>\n#include<bitset>\n#include<map>\n#define pii pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define int long long\n#define mod 998244353\nusing namespace std;\ninline int read(){\n    int f=1,ans=0;char c=getchar();\n    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}\n    while(c>='0'&&c<='9'){ans=ans*10+c-'0';c=getchar();}\n    return f*ans;\n}\nconst int MAXN=5e5+11;\nint N;char str[MAXN];\nint h[MAXN],s[MAXN],xx=2,res;\nint ksm(int a,int b){\n    int ans=1;\n    while(b){if(b&1) ans*=a,ans%=mod;a*=a,a%=mod;b>>=1;}return ans;\n}\nint pw(int a,int b){\n    if(b>=0) return ksm(a,b);\n    int res=ksm(a,-b);return ksm(res,mod-2);\n}\nmap<int,int> M[MAXN];\nsigned main(){\n    //freopen(\"1.in\",\"r\",stdin);\n    N=read();scanf(\"%s\",str+1);s[0]=0,h[0]=0;\n    for(int i=1;i<=N;i++){\n        if(str[i]=='+') h[i]=h[i-1]+pw(xx,s[i-1]),s[i]=s[i-1],h[i]%=mod;\n        if(str[i]=='-') h[i]=h[i-1]-pw(xx,s[i-1])+mod,s[i]=s[i-1],h[i]%=mod;\n        if(str[i]=='>') h[i]=h[i-1],s[i]=s[i-1]+1;\n        if(str[i]=='<') h[i]=h[i-1],s[i]=s[i-1]-1;\n    }\n    //for(int i=1;i<=N;i++) printf(\"h:%lld s:%lld\\n\",h[i],s[i]);\n    for(int i=1;i<=N;i++)\n        for(int j=i;j<=N;j++){\n            if(((h[i-1]+pw(xx,s[i-1])*h[N])%mod)==h[j]){\n                res++;\n                //cerr<<i<<\" \"<<j<<endl;\n            }\n            //res+=(((h[i-1]+ksm(xx,s[i-1])*h[N])%mod)==h[j]);\n        }\n    printf(\"%lld\\n\",res);return 0;\n}/*\n  5\n  +>+<-\n  */\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int N=250005,mu=1000000021,P=2333329;\nvoid reduce(int &x){ x+=x>>31&mu; } \nint n,f[N],g[N],pm[N],mx;\nlong long ans;\nchar s[N];\nstd::map<int,int> mp;\nint main(){\n\tscanf(\"%d%s\",&n,s);\n\tint p=0;\n\tfor (int i=0;i<n;i++){\n\t\tif (s[i]=='<') p--;\n\t\t\telse if (s[i]=='>') p++;\n\t\tmx=std::min(mx,p);\n\t}\n\tp=abs(mx);\n\tpm[0]=1;\n\tfor (int i=1;i<=n+p;i++) pm[i]=1ll*pm[i-1]*P%mu;\n\tfor (int i=0;i<n;i++){\n\t\tg[i]=p;\n\t\tif (i) f[i]=f[i-1];\n\t\tswitch (s[i]){\n\t\t\tcase '+':reduce(f[i]+=pm[p]-mu);break;\n\t\t\tcase '-':reduce(f[i]-=pm[p]);break;\n\t\t\tcase '<':p--;g[i]--;break;\n\t\t\tdefault:p++;g[i]++;\n\t\t} \n\t}\n\tint t=f[n-1];\n\tmp[t]=1;\n\tfor (int i=0;i<n;i++){\n\t\tans+=mp[f[i]];\n\t\tmp[(t*1ll*pm[g[i]]+f[i])%mu]++;\n\t} \n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e6+5;\nconst int mod1=1e9+7;\nconst int P1=19260817;\nconst int P2=998244353;\nconst int mod2=1004535809;\n#define ll long long\ntypedef pair<ll,ll>Pi;\nll fsp(ll x,int y){\n    ll ans=1;\n    while(y){\n        if(y&1) ans=ans*x%mod1;\n        x=x*x%mod1,y>>=1;\n    }\n    return ans;\n}\nll ksm(ll x,int y){\n    ll ans=1;\n    while(y){\n        if(y&1) ans=ans*x%mod2;\n        x=x*x%mod2,y>>=1;\n    }\n    return ans;\n}\nchar s[N];\nmap<Pi,int>ma;\nll n,l1,l2=1,r1,r2=1,ans,res1,res2,add1,add2,inv1,inv2;\nint main(){\n    scanf(\"%lld%s\",&n,s+1);\n    add1=fsp(P1,n);add2=ksm(P2,n);\n    inv1=fsp(P1,mod1-2),inv2=ksm(P2,mod2-2);\n    for(int i=n;i;i--){\n        if(s[i]=='-'){\n            res1=(res1-add1+mod1)%mod1;\n            res2=(res2-add2+mod2)%mod2;\n        }\n        if(s[i]=='+'){\n            res1=(res1+add1)%mod1;\n            res2=(res2+add2)%mod2;\n        }\n        if(s[i]=='<'){\n            res1=res1*inv1%mod1;\n            res2=res2*inv2%mod2;\n        }\n        if(s[i]=='>'){\n            res1=res1*P1%mod1;\n            res2=res2*P2%mod2;\n        }\n    }\n    for(int i=n;i;i--){\n        ll k1=0,k2=0;\n        if(s[i]=='-'){\n            l1=(l1-add1+mod1)%mod1,k1=mod1-add1;\n            r1=(r1-add2+mod2)%mod2,k2=mod2-add2;\n        }\n        if(s[i]=='<'){\n            l1=l1*inv1%mod1,l2=l2*inv1%mod1;\n            r1=r1*inv2%mod2,r2=r2*inv2%mod2;\n        }\n        if(s[i]=='>'){\n            l1=l1*P1%mod1,l2=l2*P1%mod1;\n            r1=r1*P2%mod2,r2=r2*P2%mod2;\n        }\n        if(s[i]=='+'){\n            l1=(l1+add1)%mod1,k1=add1;\n            r1=(r1+add2)%mod2,k2=add2;\n        }\n        ++ma[Pi((k1-l1+mod1)*fsp(l2,mod1-2)%mod1,(k2-r1+mod2)*ksm(r2,mod2-2)%mod2)];\n        ans+=ma[Pi((res1-l1+mod1)*fsp(l2,mod1-2)%mod1,(res2-r1+mod2)*ksm(r2,mod2-2)%mod2)];\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\nusing namespace std;\n\ntypedef long long LL;\n\nstruct MyInt64 {\n\tLL X;\n\tMyInt64(LL X = 0LL): X(X) {}\n};\n\nconst LL Base = 1926081719260847LL, BaseInv = 696411651951639283LL, Mod = 999999999999999989LL;\n\ninline bool operator < (MyInt64 P1, MyInt64 P2) {\n\treturn P1.X < P2.X;\n}\n\ninline MyInt64 operator + (MyInt64 P1, MyInt64 P2) {\n\t\n\tP1.X += P2.X;\n\tif(P1.X >= Mod)\n\t\tP1.X -= Mod;\n\t\n\treturn P1;\n}\n\ninline MyInt64 operator - (MyInt64 P1, MyInt64 P2) {\n\t\n\tP1.X -= P2.X;\n\tif(P1.X < 0)\n\t\tP1.X += Mod;\n\t\n\treturn P1;\n}\n\ninline MyInt64& operator += (MyInt64&P1, MyInt64 P2) {\n\t\n\tP1.X += P2.X;\n\tif(P1.X >= Mod)\n\t\tP1.X -= Mod;\n\t\n\treturn P1;\n}\n\ninline MyInt64 operator * (MyInt64 P1, MyInt64 P2) {\n\t\n\tMyInt64 Ans;\n\t\n\twhile(P2.X) {\n\t\t\n\t\tif(P2.X & 1)\n\t\t\tAns += P1.X;\n\t\t\n\t\tP2.X >>= 1;\n\t\tP1.X <<= 1;\n\t\tif(P1.X >= Mod)\n\t\t\tP1.X -= Mod;\n\t\t\n\t}\n\t\n\treturn Ans;\n}\n\nint N;\nchar str[250005];\n\nMyInt64 H[250005], P[250005];\n\nmap<MyInt64, int> MyMap;\n\nLL Ans;\n\nint main() {\n\t\n\tscanf(\"%d\", &N);\n\tscanf(\"%s\", str + 1);\n\t\n\tH[0] = MyInt64(0), P[0] = MyInt64(1);\n\t\n\tfor(int i = 1; i <= N; ++i) {\n\t\t\n\t\tif(str[i] == '+')\n\t\t\tH[i] = H[i-1] + P[i-1],\n\t\t\tP[i] = P[i-1];\n\t\t\n\t\tif(str[i] == '-')\n\t\t\tH[i] = H[i-1] - P[i-1],\n\t\t\tP[i] = P[i-1];\n\t\t\n\t\tif(str[i] == '<')\n\t\t\tH[i] = H[i-1],\n\t\t\tP[i] = P[i-1] * BaseInv;\n\t\t\n\t\tif(str[i] == '>')\n\t\t\tH[i] = H[i-1],\n\t\t\tP[i] = P[i-1] * Base;\n\t\t\n//\t\tprintf(\"%lld %lld\\n\", H[i].X, P[i].X);\n\t\t\n\t}\n\t\n\tfor(int i = N; i >= 0; --i) {\n\t\t\n\t\tAns += MyMap[H[N] * P[i] + H[i]];\n\t\t\n\t\t++MyMap[H[i]];\n\t\t\n\t}\n\t\n\tprintf(\"%lld\\n\", Ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 250001,M = 1e9 + 9,b = 1e0 + 7;\nint cs[N],p[N],n;\nmap<int,int>mp;\nvoid add(int &a,int b){\n\ta+=b;\n\tif(a >= M)a-=M;\n\tif(a < 0)a+=M;\n}\nint power(int base,int to){\n\tint ret = 1;\n\twhile(to){\n\t\tif(to&1)ret = ret*1LL*base%M;\n\t\tto>>=1;\n\t\tbase = base*1LL*base%M;\n\t}\n\treturn ret;\n}\nint main(){\n\t//freopen(\"readin.txt\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tp[0] = 1;\n\tchar c;\n\tint inv = power(b,M - 2);\n\tfor(int i = 1;i <= n;i++){\n\t\tscanf(\" %c\",&c);\n\t\tcs[i] = cs[i - 1];\n\t\tp[i] = p[i - 1];\n\t\tif(c == '+')add(cs[i],p[i]);\n\t\telse if(c == '-')add(cs[i],-p[i]);\n\t\telse if(c == '>')p[i] = p[i]*1LL*b%M;\n\t\telse if(c == '<')p[i] = p[i]*1LL*inv%M;\n\t}\n\tlong long ans = 0;\n\tfor(int i = 0;i <= n;i++){\n\t\tans+=mp[cs[i]];\n\t\tmp[(cs[n]*1LL*p[i] + cs[i] + M)%M]++;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\n\nconst int mod0 = 1e9 + 7;\nconst int mod1 = 1e9 + 9;\nconst int mod2 = 1e9 + 21;\nconst int base = 133333;\n\nint64_t power(int64_t x, int64_t n, int64_t mod) {\n  int64_t ret = 1;\n  while(n > 0) {\n    if(n & 1) (ret *= x) %= mod;\n    (x *= x) %= mod;\n    n >>= 1;\n  }\n  return ret;\n}\n\n\nint64 h0[550001], g0[550001];\nint64 h1[550001], g1[550001];\nint64 h2[550001], g2[550001];\n\n\nint main() {\n\n  h0[0] = h1[0] = h2[0] = 1;\n  for(int i = 1; i < 550001; i++) {\n    h0[i] = h0[i - 1] * base % mod0;\n    h1[i] = h1[i - 1] * base % mod1;\n    h2[i] = h2[i - 1] * base % mod2;\n  }\n  g0[550000] = power(h0[550000], mod0 - 2, mod0);\n  g1[550000] = power(h1[550000], mod1 - 2, mod1);\n  g2[550000] = power(h2[550000], mod2 - 2, mod2);\n  for(int i = 549999; i >= 0; i--) {\n    g0[i] = g0[i + 1] * (i + 1) % mod0;\n    g1[i] = g1[i + 1] * (i + 1) % mod1;\n    g2[i] = g2[i + 1] * (i + 1) % mod2;\n  }\n\n  int N;\n  string S;\n\n  cin >> N;\n  cin >> S;\n\n  vector< int64 > latte0, malta0;\n  vector< int64 > latte1, malta1;\n  vector< int64 > latte2, malta2;\n  int64 beet = 0, pos = 250001;\n  latte0.push_back(pos), malta0.push_back(beet);\n  latte1.push_back(pos), malta1.push_back(beet);\n  latte2.push_back(pos), malta2.push_back(beet);\n  for(int i = 0; i < N; i++) {\n    char c = S[i];\n    if(c == '+') (beet += h0[pos]) %= mod0;\n    else if(c == '-') (beet += mod0 - h0[pos]) %= mod0;\n    else if(c == '<') --pos;\n    else ++pos;\n    latte0.push_back(pos), malta0.push_back(beet);\n  }\n  beet = 0, pos = 250001;\n  for(int i = 0; i < N; i++) {\n    char c = S[i];\n    if(c == '+') (beet += h1[pos]) %= mod1;\n    else if(c == '-') (beet += mod1 - h1[pos]) %= mod1;\n    else if(c == '<') --pos;\n    else ++pos;\n    latte1.push_back(pos), malta1.push_back(beet);\n  }\n  beet = 0, pos = 250001;\n\n  for(int i = 0; i < N; i++) {\n    char c = S[i];\n    if(c == '+') (beet += h2[pos]) %= mod2;\n    else if(c == '-') (beet += mod2 - h2[pos]) %= mod2;\n    else if(c == '<') --pos;\n    else ++pos;\n    latte2.push_back(pos), malta2.push_back(beet);\n  }\n\n\n  map< tuple< int64, int64, int64 >, int > mp;\n  int64 ret = 0;\n  for(int i = N; i >= 0; i--) {\n    int64 dx = latte0[i] - latte0[0];\n    int64 mul0, mul1, mul2;\n    if(dx >= 0) mul0 = h0[dx], mul1 = h1[dx], mul2 = h1[dx];\n    else mul0 = power(h0[-dx], mod0 - 2, mod0), mul1 = power(h1[-dx], mod1 - 2, mod1), mul2 = power(h2[-dx], mod2 - 2, mod2);\n    ret += mp[make_tuple((malta0[i] + malta0[N] * mul0) % mod0, (malta1[i] + malta1[N] * mul1) % mod1, (malta2[i] + malta2[N] * mul2) % mod2)];\n    ++mp[make_tuple(malta0[i], malta1[i], malta2[i])];\n  }\n  cout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n    _____\n  .'     '.\n /  0   0  \\\n|     ^     |\n|  \\     /  |\n \\  '---'  /\n  '._____.'\n*/\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\nstruct chash\n{\n\tint operator()(int x) const\n\t{\n\t\tx ^= (x >> 20) ^ (x >> 12);\n\t\treturn x ^ (x >> 7) ^ (x >> 4);\n\t}\n};\n\ntemplate<typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename U> using hashtable = gp_hash_table<T, U, chash>;\nrandom_device(rd);\nmt19937 rng(rd());\n\ntemplate<class T>\nvoid readi(T &x)\n{\n\tT input = 0;\n\tbool negative = false;\n\tchar c = ' ';\n\twhile (c < '-')\n\t{\n\t\tc = getchar();\n\t}\n\tif (c == '-')\n\t{\n\t\tnegative = true;\n\t\tc = getchar();\n\t}\n\twhile (c >= '0')\n\t{\n\t\tinput = input * 10 + (c - '0');\n\t\tc = getchar();\n\t}\n\tif (negative)\n\t{\n\t\tinput = -input;\n\t}\n\tx = input;\n}\ntemplate<class T>\nvoid printi(T output)\n{\n\tif (output == 0)\n\t{\n\t\tputchar('0');\n\t\treturn;\n\t}\n\tif (output < 0)\n\t{\n\t\tputchar('-');\n\t\toutput = -output;\n\t}\n\tint aout[20];\n\tint ilen = 0;\n\twhile(output)\n\t{\n\t\taout[ilen] = ((output % 10));\n\t\toutput /= 10;\n\t\tilen++;\n\t}\n\tfor (int i = ilen - 1; i >= 0; i--)\n\t{\n\t\tputchar(aout[i] + '0');\n\t}\n\treturn;\n}\ntemplate<class T>\nvoid ckmin(T &a, T b)\n{\n\ta = min(a, b);\n}\ntemplate<class T>\nvoid ckmax(T &a, T b)\n{\n\ta = max(a, b);\n}\ntemplate<class T, class U>\nT nmod(T &x, U mod)\n{\n\tif (x >= mod) x -= mod;\n}\ntemplate<class T>\nT randomize(T mod)\n{\n\treturn (uniform_int_distribution<T>(0, mod - 1))(rng);\n}\n\n#define y0 ___y0\n#define y1 ___y1\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fi first\n#define se second\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\nconst long double PI = 4.0 * atan(1.0);\nconst long double EPS = 1e-10;\n\n#define MAGIC 347\n#define SINF 10007\n#define CO 1000007\n#define INV 124982126\n#define INF 1000000007\n#define BIG 1000000931\n#define LARGE 1696969696967ll\n#define GIANT 2564008813937411ll\n#define LLINF 2696969696969696969ll\n#define MAXN 500013\n\ntypedef __int128_t ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ld, ld> pdd;\n\nint N;\nint arr[MAXN];\nll S;\nlong long ans;\nunordered_map<ll, int> freq, need;\n\nll expo(ll a, ll e)\n{\n\tif (e == 0)\n\t{\n\t\treturn 1;\n\t}\n\tll was = expo(a, e / 2);\n\tif (e % 2)\n\t{\n\t\treturn was * was % INF * a % INF;\n\t}\n\treturn was * was % INF;\n}\nll modinv(ll a)\n{\n\treturn expo(a, INF - 2);\n}\nvoid solve(int L, int R)\n{\n\tif (L == R)\n\t{\n\t\treturn;\n\t}\n\tfreq.clear(); need.clear();\n\tint mid = (L + R) >> 1;\n\t//start from L...mid, end at mid + 1....R\n\tpll trans = MP(1, 0);\n\tfor (int i = mid + 1; i <= R; i++)\n\t{\n\t\tif (arr[i] == 0)\n\t\t{\n\t\t\ttrans.fi *= INV;\n\t\t\ttrans.se *= INV;\n\t\t}\n\t\tif (arr[i] == 1)\n\t\t{\n\t\t\ttrans.fi *= CO;\n\t\t\ttrans.se *= CO;\n\t\t}\n\t\tif (arr[i] == 2)\n\t\t{\n\t\t\ttrans.se++;\n\t\t}\n\t\tif (arr[i] == 3)\n\t\t{\n\t\t\ttrans.se--; trans.se += INF;\n\t\t}\n\t\ttrans.fi %= INF;\n\t\ttrans.se %= INF;\n\t\t// cerr << \"from \" << mid + 1 << \" to \" << i << \" is \" << trans.fi << \"x + \" << trans.se << endl;\n\t\tll dif = S - trans.se + INF;\n\t\tnmod(dif, INF);\n\t\tdif *= modinv(trans.fi);\n\t\tdif %= INF;\n\t\tneed[dif]++;\n\t}\n\ttrans = MP(1, 0);\n\tfor (int i = mid; i >= L; i--)\n\t{\n\t\tif (arr[i] == 0)\n\t\t{\n\t\t\ttrans.fi *= INV;\n\t\t}\n\t\tif (arr[i] == 1)\n\t\t{\n\t\t\ttrans.fi *= CO;\n\t\t}\n\t\tif (arr[i] == 2)\n\t\t{\n\t\t\t//(x+1)*a+b = a * x + a + b\n\t\t\ttrans.se += trans.fi;\n\t\t}\n\t\tif (arr[i] == 3)\n\t\t{\n\t\t\t//(x - 1)*a + b = a*x - a + b\n\t\t\ttrans.se -= trans.fi;\n\t\t\ttrans.se += INF;\n\t\t}\n\t\ttrans.fi %= INF;\n\t\ttrans.se %= INF;\n\t\tfreq[trans.se]++;\n\t}\n\tfor (auto p : need)\n\t{\n\t\tll x = p.fi; int c = p.se;\n\t\tans += 1ll * c * freq[x];\n\t}\n\tsolve(L, mid);\n\tsolve(mid + 1, R);\n}\n\nint32_t main()\n{\n\tios_base::sync_with_stdio(0);\n\t// cout << fixed << setprecision(10);\n\t// cerr << fixed << setprecision(10);\n\t// freopen (\"file.in\", \"r\", stdin);\n\t// freopen (\"file.out\", \"w\", stdout);\n\tcin >> N;\n\tstring temps;\n\tcin >> temps;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (temps[i] == '<')\n\t\t{\n\t\t\tarr[i] = 0;\n\t\t}\n\t\tif (temps[i] == '>')\n\t\t{\n\t\t\tarr[i] = 1;\n\t\t}\n\t\tif (temps[i] == '+')\n\t\t{\n\t\t\tarr[i] = 2;\n\t\t}\n\t\tif (temps[i] == '-')\n\t\t{\n\t\t\tarr[i] = 3;\n\t\t}\n\t}\n\treverse(arr, arr + N);\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (arr[i] == 0)\n\t\t{\n\t\t\tS *= INV; S %= INF;\n\t\t\t// cerr << \"times \" << INV << endl;\n\t\t}\n\t\tif (arr[i] == 1)\n\t\t{\n\t\t\tS *= CO; S %= INF;\n\t\t\t// cerr << \"times \" << CO << endl;\n\t\t}\n\t\tif (arr[i] == 2)\n\t\t{\n\t\t\tS++; nmod(S, INF);\n\t\t\t// cerr << \"add 1\\n\";\n\t\t}\n\t\tif (arr[i] == 3)\n\t\t{\n\t\t\tS--; S += INF; nmod(S, INF);\n\t\t\t// cerr << \"add -1\\n\";\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (arr[i] == 0)\n\t\t{\n\t\t\tif (S == 0) ans++;\n\t\t}\n\t\tif (arr[i] == 1)\n\t\t{\n\t\t\tif (S == 0) ans++;\n\t\t}\n\t\tif (arr[i] == 2)\n\t\t{\n\t\t\tif (S == 1) ans++;\n\t\t}\n\t\tif (arr[i] == 3)\n\t\t{\n\t\t\tif (S == INF - 1) ans++;\n\t\t}\n\t}\n\t// for (int i = 0; i < N; i++)\n\t// {\n\t// \tll val = 0;\n\t// \tfor (int j = i; j < N; j++)\n\t// \t{\n\t// \t\tif (arr[j] == 0)\n\t// \t\t{\n\t// \t\t\tval *= INV; val %= INF;\n\t// \t\t}\n\t// \t\tif (arr[j] == 1)\n\t// \t\t{\n\t// \t\t\tval *= CO; val %= INF;\n\t// \t\t}\n\t// \t\tif (arr[j] == 2)\n\t// \t\t{\n\t// \t\t\tval++; nmod(val, INF);\n\t// \t\t}\n\t// \t\tif (arr[j] == 3)\n\t// \t\t{\n\t// \t\t\tval--; val += INF; nmod(val, INF);\n\t// \t\t}\n\t// \t\tif (val == S)\n\t// \t\t{\n\t// \t\t\tans++;\n\t// \t\t}\n\t// \t}\n\t// }\n\tsolve(0, N - 1);\n\tcout << ans << '\\n';\n\t//when u <, the # divides by co\n\t//when u >, the # mults by co\n\t//when u +, u add the #\n\t//when u -, u subtract the #\n\t// cerr << \"time elapsed = \" << (clock() / (CLOCKS_PER_SEC / 1000)) << \" ms\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<map>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef vector<long long> Vec;\n\nlong long mods[] = {1000000007, 100000007, 1000000009};\nlong long bs[] = {1000003, 1000033, 1000033};\nlong long is[3];\n\nVec ad(Vec v1, Vec v2, int coe){\n\tfor(int i = 0; i < 3; ++i) v1[i] += (coe * v2[i]);\n\tfor(int i = 0; i < 3; ++i){\n\t\tv1[i] %= mods[i];\n\t\tif(v1[i] < 0) v1[i] += mods[i];\n\t}\n\treturn v1;\n}\n\nlong long ex(long long a, long long e, long long m){\n\tif(e == 0) return 1;\n\tlong long tmp = ex(a, e / 2, m);\n\ttmp = (tmp * tmp) % m;\n\tif(e % 2 == 1) tmp *= a;\n\ttmp %= m;\n\treturn tmp;\n}\n\nvoid init(){\n\tfor(int i = 0; i < 3; ++i){\n\t\tis[i] = ex(bs[i], mods[i] - 2, mods[i]);\n\t}\n}\n\nVec cur;\n\nint N;\nchar ch[250200];\n\nvoid input(){\n\tscanf(\"%d\", &N);\n\tscanf(\"%s\", ch);\n}\n\nint ps[250200];\n\nVec vs[250200];\n\nmap<vector<long long>, vector<int> > mp;\n\nVec mv(Vec v, int e){\n\tif(e == 0) return v;\n\tfor(int i = 0; i < 3; ++i){\n\t\tlong long a = (e > 0) ? (bs[i]) : (is[i]);\n\t\tv[i] *= ex(a, e > 0 ? e : (-e), mods[i]);\n\t\tv[i] %= mods[i];\n\t\tif(v[i] < 0) v[i] += mods[i];\n\t}\n\treturn v;\n}\n\nlong long solve(){\n\tinit();\n\tVec v(3);\n\tps[0] = 0;\n\tmp[v].push_back(0);\n\tfor(int i = 0; i < 3; ++i){\n\t\tcur.push_back(1);\n\t}\n\tvs[0] = v;\n\tfor(int i = 0; i < N; ++i){\n\t\tif(ch[i] == '>'){\n\t\t\tps[i + 1] = ps[i] + 1;\n\t\t\tcur = mv(cur, 1);\n\t\t}else if(ch[i] == '<'){\n\t\t\tps[i + 1] = ps[i] - 1;\n\t\t\tcur = mv(cur, -1);\n\t\t}else if(ch[i] == '+'){\n\t\t\tps[i + 1] = ps[i];\n\t\t\tv = ad(v, cur, 1);\n\t\t}else{\n\t\t\tps[i + 1] = ps[i];\n\t\t\tv = ad(v, cur, -1);\n\t\t}\n\t\tfor(int j = 0; j < 3; ++j){\n\t\t\tv[j] %= mods[j];\n\t\t\tif(v[j] < 0) v[j] += mods[j];\n\t\t}\n\t\tmp[v].push_back(i + 1);\n\t\tvs[i + 1] = v;\n\t}\n/*\tprintf(\"----\\n\");\n\tfor(int i = 0; i < 3; ++i){\n\t\tprintf(\"%lld \", v[i]);\n\t}\n\tprintf(\"\\n\");*/\n\tlong long ans = 0;\n\tfor(int i = 0; i < N; ++i){\n\t\tVec tmp = mv(vs[N], ps[i]);\n\t\tVec v = ad(vs[i], tmp, 1);\n\t\tif(mp.count(v) == 0) continue;\n\t\tvector<int> &vec = mp[v];\n\t\tint id = distance(vec.begin(), lower_bound(vec.begin(), vec.end(), i + 1));\n\t\tans += (vec.size() - id);\n\t/*\tfor(int j = id; j < vec.size(); ++j){\n\t\t\tprintf(\"%d %d\\n\", i, vec[j]);\n\t\t}*/\n\t}\n\treturn ans;\n}\n\nint main(){\n\tinput();\n\tlong long ans = solve();\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\n\nconst int MAXN = 250005;\nconst lint mod = 1e16 + 61;\nconst int base = 257;\nint n, pos[MAXN];\nchar str[MAXN];\nlint pwr[MAXN * 2];\nlint inv[MAXN * 2];\n\nlint ipow(lint x, lint p){\n  lint ret = 1, piv = x;\n  while(p){\n    if(p & 1) ret = (__int128) ret * piv % mod;\n    piv = (__int128) piv * piv % mod;\n    p >>= 1;\n  }\n  return ret;\n}\n\nlint psum[MAXN];\n\nint main(){\n  mod++;\n  cin >> n >> (str + 1);\n  pwr[0] = inv[0] = 1;\n  for(int i=1; i<MAXN * 2; i++){\n    pwr[i] = pwr[i-1] * base % mod;\n    inv[i] = ipow(pwr[i], mod - 2);\n  }\n  pos[0] = n;\n  for(int i=1; i<=n; i++){\n    pos[i] = pos[i-1];\n    psum[i] = psum[i-1];\n    if(str[i] == '<') pos[i]--;\n    if(str[i] == '>') pos[i]++;\n    if(str[i] == '+') psum[i] += pwr[pos[i]];\n    if(str[i] == '-') psum[i] += mod - pwr[pos[i]];\n    psum[i] %= mod;\n  }\n  lint H = psum[n];\n  lint ret = 0;\n  map<int, int> mp;\n  for(int i=n; i; i--){\n    mp[psum[i]]++;\n    __int128 Hv = H;\n    if(pos[0] <= pos[i-1]) Hv *= pwr[pos[i-1] - pos[0]];\n    else Hv *= inv[pos[0] - pos[i-1]];\n    Hv += psum[i-1];\n    Hv %= mod;\n    ret += mp[Hv];\n  }\n  cout << ret << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\n\ntypedef long long ll;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<ll, ll> ll_ll;\n\nconst int MOD0 = 1e9 + 7;\nconst int MOD1 = 1e9 + 9;\n\nll INF = LLONG_MAX / 10;\n\nll pow_mod(ll x, ll n, int M) {\n\tll ans = 1;\n\tfor (; n; n>>=1) {\n\t\tif (n & 1) ans = ans * x % M;\n\t\tx = x * x % M;\n\t}\n\treturn ans;\n}\n\nint inv_mod(int x, int p) {\n\treturn pow_mod(x, p - 2, p);\n}\n\nint main() {\n\tint N; cin >> N;\n\tstring s; cin >> s;\n\tint x = 250000; ll h0 = 0, h1 = 0;\n\tvector<int> X(N + 1); X[0] = x;\n\tvector<ll> H0(N + 1); H0[0] = h0;\n\tvector<ll> H1(N + 1); H1[0] = h1;\n\trep(i, N) {\n\t\tchar c = s[i];\n\t\tif (c == '+') h0 = (h0 + pow_mod(345678, x, MOD0)) % MOD0;\n\t\tif (c == '-') h0 = (h0 - pow_mod(345678, x, MOD0) + MOD0) % MOD0;\n\t\tif (c == '+') h1 = (h1 + pow_mod(345678, x, MOD1)) % MOD1;\n\t\tif (c == '-') h1 = (h1 - pow_mod(345678, x, MOD1) + MOD1) % MOD1;\n\t\tif (c == '>') x++;\n\t\tif (c == '<') x--;\n\t\tX[i + 1] = x, H0[i + 1] = h0, H1[i + 1] = h1;\n\t}\n\tmap<ll_ll, int> mp;\n\tll ans = 0;\n\tfor (int i = N; i >= 0; i--) {\n\t\tint dx = X[i] - X[0];\n\t\tll coef0, coef1;\n\t\tif (dx >= 0) coef0 = pow_mod(345678, dx, MOD0);\n\t\telse coef0 = inv_mod(pow_mod(345678, -dx, MOD0), MOD0);\n\t\tif (dx >= 0) coef1 = pow_mod(345678, dx, MOD1);\n\t\telse coef1 = inv_mod(pow_mod(345678, -dx, MOD1), MOD1);\n\t\tll target0 = (H0[i] + H0[N] * coef0) % MOD0;\n\t\tll target1 = (H1[i] + H1[N] * coef1) % MOD1;\n\t\tans += mp[{target0, target1}];\n\t\tmp[{H0[i], H1[i]}]++;\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<map>\n#define maxn 250005\n#define ll long long \nusing namespace std;\n\nconst ll M=1000007,mo=998244353;\nint n,i,j,k,a[maxn];\nll s[maxn],c[maxn],mul[maxn],inv[maxn],invM,ans;\nmap<int,ll> S; \nchar ch;\n\nll ksm(ll x,ll y){\n\tll s=1;\n\tfor(;y;y/=2,x=x*x%mo) if (y&1)\n\t\ts=s*x%mo;\n\treturn s;\n}\n\nll cm(int k){return (k<0)?inv[-k]:mul[k];}\n\nint main(){\n\tscanf(\"%d\",&n),ch=getchar();\n\twhile (ch!='<'&&ch!='>'&&ch!='+'&&ch!='-') ch=getchar();\n\tfor(i=1;i<=n;i++) a[i]=ch,ch=getchar();\n\tmul[0]=1;for(i=1;i<=n;i++) mul[i]=mul[i-1]*M%mo;\n\tinv[0]=1,invM=ksm(M,mo-2);for(i=1;i<=n;i++) inv[i]=inv[i-1]*invM%mo; \n\tfor(i=n;i>=1;i--) {\n\t\tc[i]=c[i+1];\n\t\tif (a[i]=='<') s[i]=s[i+1]*M%mo,c[i]++; else \n\t\tif (a[i]=='>') s[i]=s[i+1]*invM%mo,c[i]--; else \n\t\tif (a[i]=='+') s[i]=(s[i+1]+1)%mo; else s[i]=(s[i+1]+mo-1)%mo;\n\t}\n//\tfor(i=1;i<=n;i++) for(j=i+1;j<=n+1;j++)\n//\t\tif (((s[i]-s[j]*cm(c[i]-c[j])%mo)%mo+mo)%mo==s[1])\n//\t\t\tans++;\n//\tprintf(\"%lld\\n\",ans),ans=0;\n\tS[0]=1;\n\tfor(i=n;i>=1;i--) {\n\t\tll v=(s[i]-s[1]+mo)*cm(-c[i])%mo;\n\t\tif (S.find(v)!=S.end()) \n\t\t\tans+=S[v];\n\t\tS[s[i]*cm(-c[i])%mo]++;\n\t}\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <cmath>\n#include <cstdio>\n#include <cctype>\n#include <ctime>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <complex>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cwchar>\n#include <cwctype>\n#include <exception>\n#include <locale>\n#include <numeric>\n#include <new>\n#include <stdexcept>\n#include <limits>\n#include <valarray>\n#include <set>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <list>\n#include <utility>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int INF = 1e9 + 7;\n\nconst LL HMOD = 998244353, HRAD = 3, HIRAD = (HMOD + 1) / HRAD;\nmap<LL, int> S;\nint n;\nchar ch[250005];\nLL tot[250005];\n\nint main()\n{\n\tscanf(\"%d%s\", &n, &ch);\n\tLL cur = 1LL, cnt = 0LL;\n\trep(i, n) {\n\t\tif(ch[i] == '+') cnt = (cnt + cur) % HMOD;\n\t\tif(ch[i] == '-') cnt = (cnt - cur + HMOD) % HMOD;\n\t\tif(ch[i] == '<') cur = cur * HIRAD % HMOD;\n\t\tif(ch[i] == '>') cur = cur * HRAD % HMOD;\n\t\ttot[i] = cnt;\n\t\tS[cnt] ++;\n\t}\n\tLL ss = cnt, ans = S[ss];\n\tcur = 1LL; cnt = 0LL;\n\trep(i, n) {\n\t\tif(ch[i] == '+') cnt = (cnt + cur) % HMOD;\n\t\tif(ch[i] == '-') cnt = (cnt - cur + HMOD) % HMOD;\n\t\tif(ch[i] == '<') cur = cur * HIRAD % HMOD;\n\t\tif(ch[i] == '>') cur = cur * HRAD % HMOD;\n\t\tS[tot[i]] --;\n\t\tans += S[(cnt + cur * ss) % HMOD];\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,l,r) for(int i = (l),i##end = (r);i <= i##end;i++)\n#define Fordown(i,r,l) for(int i = (r),i##end = (l);i >= i##end;i--)\n#define debug(x) cout << #x << \" = \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\ntemplate <typename T> inline bool chkmin(T &x,T y) { return y < x ? x = y,1 : 0; }\ntemplate <typename T> inline bool chkmax(T &x,T y) { return x < y ? x = y,1 : 0; }\n\nconst int INF = 0x3f3f3f3f;\nconst int N = 250000 + 10,Bs = 19260817;\n\nint Pos[N];\null Pw[N << 1],Val[N];\nchar str[N];\n\nunordered_map <ull,int> Map;\n\ninline int read() {\n\tint x = 0,flag = 1;\n\tchar ch = getchar();\n\twhile(!isdigit(ch) && ch != '-')ch = getchar();\n\tif(ch == '-')flag = -1,ch = getchar();\n\twhile(isdigit(ch))x = (x << 3) + (x << 1) + (ch - '0'),ch = getchar();\n\treturn x * flag;\n}\n\nint main() {\n\n\tint n = read(),Lim = (n << 1) + 10;\n\tscanf(\"%s\",str + 1);\n\tPw[0] = 1;\n\tFor(i,1,Lim) Pw[i] = Pw[i - 1] * Bs;\n\tint pos = n + 5;ull Sum = 0;\n\tFor(i,1,n) {\n\t\tif(str[i] == '>') pos++;\n\t\tif(str[i] == '<') pos--;\n\t\tif(str[i] == '+') Sum += Pw[pos];\n\t\tif(str[i] == '-') Sum -= Pw[pos];\n\t\tPos[i] = pos,Val[i] = Sum;\n\t}\n\n\tMap[Val[n] * Pw[n + 5]]++;\n\tll ans = 0;\n\tFordown(i,n - 1,1) {\n\t\tull val = Val[n] * Pw[Pos[i]] + Val[i] * Pw[n + 5];\n\t\tans += Map[val];\n\t\tMap[Val[i] * Pw[n + 5]]++;\n\t}\n\n\tFor(i,1,n) if(Val[i] == Val[n]) ans++;\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long lint;\n\nlint modpow(lint x, lint y, lint mod) {\n  lint ret = 1 % mod, x2p = x;\n  while (y > 0) {\n    if (y % 2) ret = (__int128)ret * x2p % mod;\n    y /= 2;\n    x2p = (__int128)x2p * x2p % mod;\n  }\n  return ret;\n}\n\nconstexpr int nmods = 15;\n\nconstexpr lint mod[] = {1152921504609811141LL, 576460752312103501LL,\n                        4611676018431352883LL, 4611676018431352883LL,\n                        288230376151711789LL,\n288230376151711793LL,\n288230376151711813LL,\n288230376151711843LL,\n288230376151711849LL,\n288230376151711879LL,\n288230376151711909LL,\n288230376151711919LL,\n288230376151711921LL,\n288230376151711933LL,\n288230376151711951LL};\n\nconstexpr lint base[] = {102999959LL, 1006199503LL, 1073741663LL, 599831LL,\n                         1300000003LL,\n                         1300000021LL,\n                         1300000049LL,\n                         1300000073LL,\n                         1300000087LL,\n                         1300000103LL,\n                         1300000151LL,\n                         1300000153LL,\n                         1300000187LL,\n                         1300000201LL,\n                         1300000231LL};\nlint inv_base[nmods];\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  string seq(n, ' ');\n  for (int i = 0; i < n; ++i)\n    scanf(\" %c\", &seq[i]);\n\n  vector<int> pos_before(n);\n\n  vector<vector<lint>> base_pow(nmods, vector<lint>(n + 1));\n  vector<vector<lint>> inv_base_pow(nmods, vector<lint>(n + 1));\n  vector<vector<lint>> hash_diff(nmods, vector<lint>(n, 0));\n  vector<vector<lint>> suffix(nmods, vector<lint>(n + 1));\n  vector<lint> full_seq_hash(nmods);\n  for (int k = 0; k < nmods; ++k) {\n    base_pow[k][0] = 1;\n    for (int i = 1; i <= n; ++i)\n      base_pow[k][i] = (__int128)base[k] * base_pow[k][i - 1] % mod[k];\n\n    inv_base[k] = modpow(base[k], mod[k] - 2, mod[k]);\n    inv_base_pow[k][0] = 1;\n    for (int i = 1; i <= n; ++i)\n      inv_base_pow[k][i] = (__int128)inv_base[k] * inv_base_pow[k][i - 1] % mod[k];\n\n    int pos = 0;\n    for (int i = 0; i < n; ++i) {\n      pos_before[i] = pos;\n      if (seq[i] == '>') ++pos;\n      else if (seq[i] == '<') --pos;\n      else {\n        lint base_pow_pos;\n        if (pos >= 0) base_pow_pos = base_pow[k][pos];\n        else base_pow_pos = inv_base_pow[k][-pos];\n        if (seq[i] == '+') hash_diff[k][i] = base_pow_pos;\n        else if (seq[i] == '-') hash_diff[k][i] = mod[k] - base_pow_pos;\n        else assert(0);\n      }\n    }\n    full_seq_hash[k] = 0;\n    for (int i = 0; i < n; ++i) {\n      full_seq_hash[k] += hash_diff[k][i];\n      if (full_seq_hash[k] >= mod[k]) full_seq_hash[k] -= mod[k];\n    }\n\n    suffix[k][n] = 0;\n    for (int i = n - 1; i >= 0; --i) {\n      suffix[k][i] = hash_diff[k][i] + suffix[k][i + 1];\n      if (suffix[k][i] >= mod[k]) suffix[k][i] -= mod[k];\n    }\n  }\n\n  lint result = 0;\n  map<vector<lint>, int> count;\n  count[vector<lint>(nmods, 0LL)] += 1;\n  for (int i = n - 1; i >= 0; --i) {\n    vector<lint> shifted_full(nmods);\n    for (int k = 0; k < nmods; ++k) {\n      if (pos_before[i] >= 0) {\n        shifted_full[k] = (__int128)full_seq_hash[k] * base_pow[k][pos_before[i]] % mod[k];\n      } else {\n        shifted_full[k] = (__int128)full_seq_hash[k] * inv_base_pow[k][-pos_before[i]] % mod[k];\n      }\n    }\n\n    vector<lint> target(nmods);\n    for (int k = 0; k < nmods; ++k) {\n      target[k] = suffix[k][i] - shifted_full[k];\n      if (target[k] < 0) target[k] += mod[k];\n    }\n\n    auto it = count.find(target);\n    if (it != count.end())\n      result += it->second;\n\n    vector<lint> suffix_vec(nmods);\n    for (int k = 0; k < nmods; ++k)\n      suffix_vec[k] = suffix[k][i];\n\n    count[suffix_vec] += 1;\n  }\n  printf(\"%lld\\n\", result);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define va first.first\n#define vb first.second\n#define vc second.first\n#define vd second.second\nusing namespace std;\n\nusing ll = unsigned long long;\nconst size_t mod = 1e9 + 7;\nconst size_t b[2] = {23, 29};\n\nsize_t Pow(size_t x, int n){\n    if(n < 0) n = mod - 1 + n;\n    size_t ret = 1, pv = x;\n    for(;n;n>>=1){\n        if(n & 1) ret = 1LL * ret * pv % mod;\n        pv = 1LL * pv * pv % mod;\n    }\n    return ret;\n}\n\nint P[250005];\nll V[250005][2];\nstring S, T;\nint n;\nunordered_map<ll,int> m;\n\nll H(size_t b1, size_t b2){\n    return ll(b1) << 32ll | b2;\n}\n\nint main(){\n    ios_base::sync_with_stdio(0);cin.tie(0);\n    cin >> n;\n    cin >> S;\n    T = \"*\";\n    T += S;\n    for(int i = 1; i <= n; i++){\n        switch(T[i]){\n        case '+':\n            P[i] = P[i-1];\n            for(int k = 0; k < 2; k++) V[i][k] = (V[i-1][k] + Pow(b[k], P[i])) % mod;\n            break;\n        case '-':\n            P[i] = P[i-1];\n            for(int k = 0; k < 2; k++) V[i][k] = (V[i-1][k] + mod - Pow(b[k], P[i])) % mod;\n            break;\n        case '>':\n            P[i] = P[i-1] + 1;\n            for(int k = 0; k < 2; k++) V[i][k] = V[i-1][k];\n            break;\n        case '<':\n            P[i] = P[i-1] - 1;\n            for(int k = 0; k < 2; k++) V[i][k] = V[i-1][k];\n            break;\n        }\n    }\n    ll ans = 0;\n    m[H(V[n][0],V[n][1])]++;\n    for(int i = 1; i <= n; i++){\n        ans += m[H(V[i][0],V[i][1])];\n        size_t v0 = (Pow(b[0],P[i]) * V[n][0] + V[i][0])%mod;\n        size_t v1 = (Pow(b[1],P[i]) * V[n][1] + V[i][1])%mod;\n        ll key = H(v0,v1);\n        //cout << \"i : \" << v0 << \" \" << v1 << '\\n';\n        m[H(v0,v1)]++;\n    }\n    cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n  \n#define ll long long\n#define all(aaa) aaa.begin(), aaa.end()\n\nconst int MOD = 1000000033, N = 3e5 + 5;\nconst ll X = 1234567;\n\nll bp(ll a, ll p) {\n    ll r = 1;\n    while (p > 0) {\n        if (p & 1) {\n            r = r * a % MOD;\n        }\n        a = a * a % MOD;\n        p >>= 1;\n    }\n    return r;\n}\n\nll inv_X = bp(X, MOD - 2);\n\nll a[N], b[N];\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n;\n    string s;\n    cin >> n >> s;\n\n    ll h = 0;\n\n    for (int i = n - 1; i >= 0; i--) {\n        if (s[i] == '>')\n            h = h * X % MOD;\n        else if (s[i] == '<')\n            h = h * inv_X % MOD;\n        else if (s[i] == '+')\n            h = (h + 1) % MOD;\n        else\n            h = (h - 1 + MOD) % MOD;\n    }\n\n    map<ll, int> mp;\n\n    ll ans = 0;\n\n    a[n] = 1;\n\n    for (int i = n - 1; i >= 0; i--) {\n        mp[b[i + 1]]++;\n\n        a[i] = a[i + 1];\n        b[i] = b[i + 1];\n\n        if (s[i] == '>') {\n            a[i] = a[i + 1] * inv_X % MOD;\n            b[i] = b[i + 1];\n        }\n        else if (s[i] == '<') {\n            a[i] = a[i + 1] * X % MOD;\n            b[i] = b[i + 1];\n        }\n        else if (s[i] == '+') {\n            a[i] = a[i + 1];\n            b[i] = (b[i + 1] - a[i + 1] + MOD) % MOD;\n        }\n        else {\n            a[i] = a[i + 1];\n            b[i] = (b[i + 1] + a[i + 1]) % MOD;\n        }\n\n        // cout << b[i] << \"\\n\";\n\n        ans += mp[(a[i] * h + b[i]) % MOD];\n    }\n\n    // cout << (a[0] * h + b[0]) % MOD << \"\\n\";\n\n    cout << ans << \"\\n\";\n\n    return 0;   \n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define MAX 500012\n\nint n;\nchar buf[MAX];\n\n\nstring s;\n\n\n//#define MOD1 1000000007\n//#define MOD2 1000000009\n\nvalarray<long long int> MOD1;\nvalarray<long long int> MOD2;\nvector<valarray<long long int> > p2;\nvector<valarray<long long int> > vv;\nvector<int> ps;\nmap<long long int, int> mp;\nlong long int ppow(long long int i, long long int j, long long int MOD) {\n\tlong long int ret = 1;\n\twhile (j) {\n\t\tif (j & 1LL)ret *= i;\n\t\tif (ret >= MOD)ret %= MOD;\n\t\tj >>= 1LL;\n\t}\n\treturn ret;\n}\n\nvalarray<long long int> calc(int dif) {\n\tvalarray<long long int> ret;\n\tret.resize(2, 0);\n\tfor (int j = 0; j < 2; j++) {\n\t\tif (dif < 0) {\n\t\t\tret[j]=ppow(ppow(MOD1[j], abs(dif),MOD2[j]), MOD2[j] - 2,MOD2[j]);\n\t\t}\n\t\telse {\n\t\t\tret[j] = ppow(MOD1[j], abs(dif), MOD2[j]);\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main() {\n\tMOD1.resize(2);\n\tMOD2.resize(2);\n\tp2.push_back(valarray<long long int>());\n\tp2.back().resize(2);\n\tp2.back()[0] = p2.back()[1] = 1;\n\tMOD1[0] = 1000000007;\n\tMOD2[0] = 1000000009;\n\tMOD1[1] = 1000000009;\n\tMOD2[1] = 1000000007;\n\tp2[0] %= MOD2;\n\tfor (int i = 1; i < MAX; i++) {\n\t\tp2.push_back(p2.back());\n\t\tp2[i] *= MOD1;\n\t\tp2[i] %= MOD2;\n\t}\n\tcin >> n;\n\tscanf(\"%s\", buf);\n\ts = buf;\n\tint pos = MAX/2;\n\tvalarray<long long int> hs;\n\ths.resize(2);\n\ths[0] = hs[1] = 0;\n\tvv.push_back(hs);\n\tps.push_back(pos);\n\tfor (int i = 0; i < s.size(); i++) {\n\t\tif (s[i] == '<') {\n\t\t\tpos--;\n\t\t}\n\t\tif (s[i] == '>') {\n\t\t\tpos++;\n\t\t}\n\t\tif (s[i] == '+') {\n\t\t\ths += p2[pos];\n\t\t}\n\t\tif (s[i] == '-') {\n\t\t\ths -= p2[pos];\n\t\t\ths += MOD2;\n\t\t}\n\t\ths %= MOD2;\n\t\tvv.push_back(hs);\n\t\tps.push_back(pos);\n\t}\n\tlong long int way = 0;\n\tfor (int i = vv.size() - 1; i >= 0; i--) {\n\t\tauto want = vv[i] + vv.back()*calc(-MAX/2+ps[i]);\n\t\twant = want%MOD2;\n\t\tway += mp[want[0] * MOD1[0] + want[1]];\n\t\t//cerr << \"dbg \" << way << endl;\n\t\tmp[vv[i][0]*MOD1[0]+vv[i][1]]++;\n\t}\n\tprintf(\"%lld\\n\", way);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"trapv\")\n#include<bits/stdc++.h>\n#define int ll\n#define pb push_back\n#define all(x) x.begin(), x.end()\nusing namespace std;\nusing ll = long long;\nconst int maxn = 1<<20, mod = 119<<23|1;\nconst int B = 299977, C = 1139123;\nint n, pw[maxn], pw2[maxn], ps = 0, ans = 0;\narray<ll, 2> F[maxn];\nstring s;\nmap<array<ll, 2>, int> cnt;\nvoid add(int &a, int b) {\n\ta = a+b>=mod?a+b-mod:a+b;\n}\nll bp(ll a, ll p) {\n\tll r = 1;\n\twhile(p) {\n\t\tif(p&1) r = r*a%mod;\n\t\ta = a*a%mod, p>>=1;\n\t}\n\treturn r;\n} \nsigned main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> n >> s;\n\tpw[0] = pw2[0] = 1;\n\tfor(int i = 1; i < maxn; i++) pw[i] = pw[i-1]*1ll*B%mod;\n\tfor(int i = 1; i < maxn; i++) pw2[i] = pw2[i-1]*1ll*C%mod;\n\tcnt[{0, 0}]++;\n\tarray<ll, 2> cur = {0, 0};\n\tfor(int i = 0; i < n; i++) {\n\t\tif(s[i] == '>') ps++;\n\t\tif(s[i] == '<') ps--;\n\t\tif(s[i] == '+') {\n\t\t\tadd(cur[0], pw[(maxn/2) + ps]);\n\t\t\tadd(cur[1], pw2[(maxn/2) + ps]);\n\t\t}\n\t\tif(s[i] == '-') {\n\t\t\tadd(cur[0], mod-pw[(maxn/2) + ps]);\n\t\t\tadd(cur[1], mod-pw2[(maxn/2) + ps]);\n\t\t}\n\t\tF[i+1] = cur;\n\t\tcnt[cur]++;\n\t}\n\tF[0] = {0, 0};\n\tps = 0;\n\tarray<ll, 2> ccur = {0, 0};\n\tfor(int ps = 0, i = 0; i <= n; i++) {\n\t\tcnt[F[i]]--;\n\t\tll X = (bp(B, mod-1+ps)*1ll*cur[0] + ccur[0])%mod;\n\t\tll Y = (bp(C, mod-1+ps)*1ll*cur[1] + ccur[1])%mod;\n\t\tans += cnt[{X, Y}];\n\t\tif(i == n) continue;\n\t\tif(s[i] == '>') ps++;\n\t\tif(s[i] == '<') ps--;\n\t\tif(s[i] == '+') {\n\t\t\tadd(ccur[0], pw[(maxn/2) + ps]);\n\t\t\tadd(ccur[1], pw2[(maxn/2) + ps]);\n\t\t}\n\t\tif(s[i] == '-') {\n\t\t\tadd(ccur[0], mod-pw[(maxn/2) + ps]);\n\t\t\tadd(ccur[1], mod-pw2[(maxn/2) + ps]);\n\t\t}\n\t}\n\tcout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < (int)(n); ++ (i))\nusing ll = long long;\nusing namespace std;\n\ntemplate <int32_t MOD>\nstruct mint {\n    int64_t data;  // faster than int32_t a little\n    mint() = default;  // data is not initialized\n    mint(int64_t value) : data(value) {}  // assume value is in proper range\n    inline mint<MOD> operator + (mint<MOD> other) const { int64_t c = this->data + other.data; return mint<MOD>(c >= MOD ? c - MOD : c); }\n    inline mint<MOD> operator - (mint<MOD> other) const { int64_t c = this->data - other.data; return mint<MOD>(c <    0 ? c + MOD : c); }\n    inline mint<MOD> operator * (mint<MOD> other) const { int64_t c = this->data * int64_t(other.data) % MOD; return mint<MOD>(c < 0 ? c + MOD : c); }\n    inline mint<MOD> & operator += (mint<MOD> other) { this->data += other.data; if (this->data >= MOD) this->data -= MOD; return *this; }\n    inline mint<MOD> & operator -= (mint<MOD> other) { this->data -= other.data; if (this->data <    0) this->data += MOD; return *this; }\n    inline mint<MOD> & operator *= (mint<MOD> other) { this->data = this->data * int64_t(other.data) % MOD; if (this->data < 0) this->data += MOD; return *this; }\n    inline mint<MOD> operator - () const { return mint<MOD>(this->data ? MOD - this->data : 0); }\n    mint<MOD> pow(uint64_t k) const {\n        mint<MOD> x = *this;\n        mint<MOD> y = 1;\n        for (uint64_t i = 1; i and (i <= k); i <<= 1) {\n            if (k & i) y *= x;\n            x *= x;\n        }\n        return y;\n    }\n    mint<MOD> inv() const {\n        return pow(MOD - 2);\n    }\n};\n\ntemplate <typename T, size_t H, size_t W>\nusing matrix = array<array<T, W>, H>;\ntemplate <typename T, size_t A, size_t B, size_t C>\nmatrix<T, A, C> operator * (matrix<T, A, B> const & a, matrix<T, B, C> const & b) {\n    matrix<T, A, C> c = {};\n    REP (y, A) REP (z, B) REP (x, C) c[y][x] += a[y][z] * b[z][x];\n    return c;\n}\ntemplate <typename T, size_t H, size_t W>\narray<T, H> operator * (matrix<T, H, W> const & a, array<T, W> const & b) {\n    array<T, H> c = {};\n    REP (y, H) REP (z, W) c[y] += a[y][z] * b[z];\n    return c;\n}\ntemplate <typename T, size_t N>\nmatrix<T, N, N> matrix_unit() {\n    matrix<T, N, N> a = {};\n    REP (i, N) a[i][i] = 1;\n    return a;\n}\n\nconstexpr int MOD[4] = { (int)1e9 + 7, (int)1e9 + 9, (int)1e9 + 21, (int)1e9 + 33 };\nconstexpr int BASE[4] = { 10007, 10009, 10037, 10039 };\ntemplate <int k> using mmat = matrix<mint<MOD[k]>, 2, 2>;\n\ntemplate <int k>\nvector<mmat<k> > get_cumulative_sum(int n, string const & s) {\n    const mmat<k> INCR = {{ {{ 1, +1 }}, {{ 0, 1 }} }};\n    const mmat<k> DECR = {{ {{ 1, -1 }}, {{ 0, 1 }} }};\n    const mmat<k> NEXT = {{ {{ 1,  0 }}, {{ 0, BASE[k] }} }};\n    const mmat<k> PREV = {{ {{ 1,  0 }}, {{ 0, mint<MOD[k]>(BASE[k]).inv() }} }};\n\n    vector<mmat<k> > f(n + 1);\n    f[0] = matrix_unit<mint<MOD[k]>, 2>();\n    REP (i, n) {\n        auto const & g =\n            s[i] == '+' ? INCR :\n            s[i] == '-' ? DECR :\n            s[i] == '<' ? NEXT :\n            s[i] == '>' ? PREV :\n            *(mmat<k> *)nullptr;\n        f[i + 1] = g * f[i];\n    }\n    return f;\n}\n\narray<int, 4> apply_matrices(mmat<0> const & f0, mmat<1> const & f1, mmat<2> const & f2, mmat<3> const & f3) {\n    const array<mint<MOD[0]>, 2> v0 = {{ 0, 1 }};\n    const array<mint<MOD[1]>, 2> v1 = {{ 0, 1 }};\n    const array<mint<MOD[2]>, 2> v2 = {{ 0, 1 }};\n    const array<mint<MOD[3]>, 2> v3 = {{ 0, 1 }};\n    int a0 = (f0 * v0)[0].data;\n    int a1 = (f1 * v1)[0].data;\n    int a2 = (f2 * v2)[0].data;\n    int a3 = (f3 * v3)[0].data;\n    array<int, 4> a = {{ a0, a1, a2, a3 }};\n    return a;\n}\n\nll solve(int n, string const & s) {\n    auto f0 = get_cumulative_sum<0>(n, s);\n    auto f1 = get_cumulative_sum<1>(n, s);\n    auto f2 = get_cumulative_sum<2>(n, s);\n    auto f3 = get_cumulative_sum<3>(n, s);\n\n    map<array<int, 4>, int> cnt_a;\n    REP (l, n + 1) {\n        auto a = apply_matrices(f0[l], f1[l], f2[l], f3[l]);\n        cnt_a[a] += 1;\n    }\n\n    ll cnt = 0;\n    REP (l, n + 1) {\n        auto a = apply_matrices(f0[l], f1[l], f2[l], f3[l]);\n        cnt_a[a] -= 1;\n\n        auto b = apply_matrices(f0[n] * f0[l], f1[n] * f1[l], f2[n] * f2[l], f3[n] * f3[l]);\n        cnt += cnt_a[b];\n    }\n    return cnt;\n}\n\nint main() {\n    int n; string s; cin >> n >> s;\n    cout << solve(n, s) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 250001,M = 1e9 + 9,M1 = 1e9 + 7,b = 103,b1 = 107;\nint cs[N],cs1[N],p[N],p1[N],n;\nmap<pair<int,int>,int>mp;\nvoid add(int &a,int b){\n\ta+=b;\n\tif(a >= M)a-=M;\n\tif(a < 0)a+=M;\n}\nvoid add1(int &a,int b){\n\ta+=b;\n\tif(a >= M)a-=M;\n\tif(a < 0)a+=M;\n}\nint power(int base,int to){\n\tint ret = 1;\n\twhile(to){\n\t\tif(to&1)ret = ret*1LL*base%M;\n\t\tto>>=1;\n\t\tbase = base*1LL*base%M;\n\t}\n\treturn ret;\n}\nint main(){\n\t//freopen(\"readin.txt\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tp[0] = p1[0] = 1;\n\tchar c;\n\tint inv = power(b,M - 2),inv1 = power(b1,M1 - 2);\n\tfor(int i = 1;i <= n;i++){\n\t\tscanf(\" %c\",&c);\n\t\tcs[i] = cs[i - 1];\n\t\tp[i] = p[i - 1];\n\t\tif(c == '+')add(cs[i],p[i]),add1(cs1[i],p1[i]);\n\t\telse if(c == '-')add(cs[i],-p[i]),add1(cs1[i],-p1[i]);\n\t\telse if(c == '>')p[i] = p[i]*1LL*b%M,p1[i] = p1[i]*1LL*b1%M1;\n\t\telse if(c == '<')p[i] = p[i]*1LL*inv%M,p1[i] = p1[i]*1LL*inv1%M1;\n\t}\n\tlong long ans = 0;\n\tfor(int i = 0;i <= n;i++){\n\t\tans+=mp[{cs[i],cs1[i]}];\n\t\tmp[{(cs[n]*1LL*p[i] + cs[i] + M)%M,(cs1[n]*1LL*p1[i] + cs1[i] + M1)%M1}]++;\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n\nll mod=(ll)1e18+9, bas=1e9;\n\nll mul(ll x,ll y){\n    ll t=0;\n    for (;y;y>>=1,x=(x+x)%mod)\n        if (y&1) t=(t+x)%mod;\n    return t;\n}\n\nll K(ll x,ll y=mod-2){\n    if (y<0) return K(K(x),-y);\n    ll t=1;\n    for (;y;y>>=1,x=mul(x,x))\n        if (y&1) t=mul(t,x);\n    return t;\n}\n\nll n, ans, p[505000], f[505000];\nchar s[505000];\nmap<ll,ll>mp;\n\nint main(){\n    cin>>n>>s+1;\n    for (int i=1;i<=n;++i){\n        p[i]=p[i-1]; f[i]=f[i-1];\n        if (s[i]=='<') --p[i];\n        if (s[i]=='>') ++p[i];\n        if (s[i]=='+') f[i]=(f[i]+K(bas,p[i]))%mod;\n        if (s[i]=='-') f[i]=(f[i]-K(bas,p[i])+mod)%mod;\n        ++mp[f[i]];\n    }\n    for (int i=0;i<n;++i){\n        ans+=mp[(mul(f[n],K(bas,p[i])) + f[i])%mod];\n        --mp[f[i+1]];\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <map>\n#include <list>\n#include <iterator>\n#include <set>\n#include <queue>\n#include <iostream>\n#include <sstream>\n#include <stack>\n#include <deque>\n#include <cmath>\n#include <memory.h>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <algorithm>\n#include <utility>\n#include <time.h>\n#include <bitset>\n#include <assert.h>\n#include <complex.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(int i=(a)-1;i>=(b);--i)\n#define FILL(A,val) memset(A,val,sizeof(A))\n\n#define ALL(V) V.begin(),V.end()\n#define SZ(V) (int)V.size()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long Int;\ntypedef unsigned long long UInt;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double Pi = acos(-1.0);\nconst int INF = 1000000000;\nconst int MAX = 510007;\nconst int MAXE = 2007000;\nconst int MAXV = 5000;\nconst int BASE = 1000000000;\nconst int ST = 1000000007;\n\nconst int MOD1 = 982450121;\nconst int MOD2 = 982453291;\n\nint p1 = 1000003;\nint p2 = 15484769;\n\nInt H1[MAX];\nInt H2[MAX];\nint delta[MAX];\n\n\nInt pw1[MAX];\nInt pw2[MAX];\n\nint main()\n{\n    //freopen(\"in.txt\", \"r\", stdin);\n    \n    pw1[0] = 1;\n    pw2[0] = 1;\n    FOR(i,1,MAX)\n    {\n        pw1[i] = pw1[i - 1] * p1 % MOD1;\n        pw2[i] = pw2[i - 1] * p2 % MOD2;\n    }\n    \n    int n;\n    cin >> n;\n    string s;\n    cin >> s;\n    \n    H1[0] = 0;\n    H2[0] = 0;\n    delta[0] = n + 1;\n    \n    FOR(i,0,n)\n    {\n        H1[i + 1] = H1[i];\n        H2[i + 1] = H2[i];\n        delta[i + 1] += delta[i];\n        \n        if (s[i] == '<')\n        {\n            delta[i + 1] --;\n        }\n        if (s[i] == '>')\n        {\n            delta[i + 1] ++;\n        }\n        \n        if (s[i] == '+')\n        {\n            H1[i + 1] += pw1[delta[i + 1]];\n            H1[i + 1] %= MOD1;\n            \n            H2[i + 1] += pw2[delta[i + 1]];\n            H2[i + 1] %= MOD2;\n        }\n        \n        if (s[i] == '-')\n        {\n            H1[i + 1] += MOD1 - pw1[delta[i + 1]];\n            H1[i + 1] %= MOD1;\n            \n            H2[i + 1] += MOD2 - pw2[delta[i + 1]];\n            H2[i + 1] %= MOD2;\n        }\n        \n    }\n    \n    Int res = 0;\n    \n    map<pair<Int, Int> , int> M;\n    \n    \n    \n    \n    RFOR(i,n,0)\n    {\n        M[MP(H1[i + 1] * pw1[n] % MOD1 , H2[i + 1] * pw2[n] % MOD2)] ++;\n        Int h1 = (H1[n] * pw1[delta[i] - delta[0] + n] + H1[i] * pw1[n]) % MOD1;\n        Int h2 = (H2[n] * pw2[delta[i] - delta[0] + n] + H2[i] * pw2[n]) % MOD2;\n        res += M[MP(h1,h2)];\n    }\n    \n    cout << res << endl;\n    \n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cstdio>\n#include <iostream>\n\nusing namespace std ;\n\ntypedef long long LL ;\n\n\n#define mkp make_pair\n#define pll pair<LL, LL>\n\nconst LL B1 = 237ll ;\nconst LL B2 = 637ll ;\nconst int N = 300010 ;\nconst LL P1 = 998244353 ;\nconst LL P2 = 1004535809 ;\n\nint n ;\nLL ans ;\nchar s[N] ;\nLL I1, I2 ;\nLL g[N][2] ;\nLL S[N], T[N] ;\nmap <pll, LL> buc ;\n\nLL expow(LL a, LL b, LL p){\n    LL ret = 1 ;\n    while (b){\n        if (b & 1)\n            (ret *= a) %= p ;\n        (a *= a) %= p ; b >>= 1 ;\n    }\n    return ret ;\n}\nint main(){\n    cin >> n >> (s + 1) ;\n    g[0][0] = g[0][1] = 1ll ; \n    I1 = expow(B1, P1 - 2, P1) ;\n    I2 = expow(B2, P2 - 2, P2) ;\n    for (int i = 1 ; i <= n ; ++ i){\n        if (s[i] == '-'){\n            g[i][0] = g[i - 1][0] ;\n            g[i][1] = g[i - 1][1] ;\n            S[i] = (S[i - 1] - g[i][0] + P1) % P1 ;\n            T[i] = (T[i - 1] - g[i][1] + P2) % P2 ;\n        }\n        if (s[i] == '+'){\n            g[i][0] = g[i - 1][0] ;\n            g[i][1] = g[i - 1][1] ;\n            S[i] = (S[i - 1] + g[i][0]) % P1 ;\n            T[i] = (T[i - 1] + g[i][1]) % P2 ;\n        }\n        if (s[i] == '<'){\n            g[i][0] = g[i - 1][0] * I1 % P1 ;\n            g[i][1] = g[i - 1][1] * I2 % P2 ;\n            S[i] = S[i - 1] ; T[i] = T[i - 1] ;\n        }\n        if (s[i] == '>'){\n            g[i][0] = g[i - 1][0] * B1 % P1 ;\n            g[i][1] = g[i - 1][1] * B2 % P2 ;\n            S[i] = S[i - 1] ; T[i] = T[i - 1] ;\n        }\n\t\t++ buc[mkp(S[i], T[i])] ;\n    }\n    ++ buc[mkp(0, 0)] ; LL x, y ;\n    for (int i = 0 ; i < n ; ++ i){\n\t\tbuc[mkp(S[i] , T[i])] -- ; \n        x = (S[i] + S[n] * g[i][0] % P1) % P1 ; \n\t\ty = (T[i] + T[n] * g[i][1] % P2) % P2 ;\n        ans += buc[mkp(x, y)] ; \n    }\n    cout << ans << endl ; return 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<map>\n#define maxn 250005\n#define ll long long \nusing namespace std;\n\nconst int M1=1000000007,mo1=998244353,M2=19260817,mo2=1000000007,maxh=19260817;\nint n,i,j,k,a[maxn];char ch;ll hs[maxh][3],ans;\nstruct hash{\n\tll M,mo,s[maxn],c[maxn],mul[maxn],inv[maxn],invM;\n\tll cm(int k){return (k<0)?inv[-k]:mul[k];}\n\tll ksm(ll x,ll y){\n\t\tll s=1;\n\t\tfor(;y;y/=2,x=x*x%mo) if (y&1)\n\t\t\ts=s*x%mo;\n\t\treturn s;\n\t}\n\tvoid prepare(){\n\t\tmul[0]=1;for(i=1;i<=n;i++) mul[i]=mul[i-1]*M%mo;\n\t\tinv[0]=1,invM=ksm(M,mo-2);for(i=1;i<=n;i++) inv[i]=inv[i-1]*invM%mo; \n\t\tfor(int i=n;i>=1;i--) {\n\t\t\tc[i]=c[i+1];\n\t\t\tif (a[i]=='<') s[i]=s[i+1]*M%mo,c[i]++; else \n\t\t\tif (a[i]=='>') s[i]=s[i+1]*invM%mo,c[i]--; else \n\t\t\tif (a[i]=='+') s[i]=(s[i+1]+1)%mo; else s[i]=(s[i+1]+mo-1)%mo;\n\t\t}\t\t\n\t}\n\tll get(int x){return (s[i]-s[1]+mo)*cm(-c[i])%mo;}\n\tll get2(int x){return s[i]*cm(-c[i])%mo;}\n} hs1,hs2;\n\nvoid add(ll x,ll y){\n\tll i=(x*23333333+y)%maxh;\n\twhile (hs[i][2]&&(hs[i][0]!=x||hs[i][1]!=y))\n\t\ti=(i+1)%maxh;\n\ths[i][0]=x,hs[i][1]=y,hs[i][2]++;\n}\nll sum(ll x,ll y){\n\tll i=(x*23333333+y)%maxh;\n\twhile (hs[i][2]&&(hs[i][0]!=x||hs[i][1]!=y))\n\t\ti=(i+1)%maxh;\n\treturn hs[i][2];\n}\n\nint main(){\n\tscanf(\"%d\",&n),ch=getchar();\n\twhile (ch!='<'&&ch!='>'&&ch!='+'&&ch!='-') ch=getchar();\n\tfor(i=1;i<=n;i++) a[i]=ch,ch=getchar();\n\ths1.M=M1,hs1.mo=mo1,hs2.M=M2,hs2.mo=mo2;\n\ths1.prepare(),hs2.prepare();\n\tadd(0,0);\n\tfor(i=n;i>=1;i--){\n\t\tll v1=hs1.get(i),v2=hs2.get(i);\n\t\tans+=sum(v1,v2);\n\t\tadd(hs1.get2(i),hs2.get2(i));\n\t}\n//\tfor(i=1;i<=n;i++) for(j=i+1;j<=n+1;j++)\n//\t\tif (((s[i]-s[j]*cm(c[i]-c[j])%mo)%mo+mo)%mo==s[1])\n//\t\t\tans++;\n//\tprintf(\"%lld\\n\",ans),ans=0;\n//\tfor(i=n;i>=1;i--) {\n//\t\tll v=(s[i]-s[1]+mo)*cm(-c[i])%mo;\n//\t\tif (S.find(v)!=S.end()) \n//\t\t\tans+=S[v];\n//\t\tS[s[i]*cm(-c[i])%mo]++;\n//\t}\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "const int N = 400005;\nconst int LG = 21;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nint n;\nstring s;\nll sufa[N];\nll suf0[N];\nll sufa2[N];\nll suf02[N];\nconst ll K = 1e6 + 3;\nconst ll K2 = 1791791;\nconst ll rK = rev(K);\nconst ll rK2 = rev(K2);\nll pref0[N];\nll pref02[N];\nll moves[N];\nmap<int, ll> deg, deg2;\n\nsigned main()\n{\n    deg[0] = 1;\n    deg2[0] = 1;\n    for (int i = 1; i < N; i++) deg[i] = deg[i - 1] * K % MOD;\n    for (int i = 1; i < N; i++) deg2[i] = deg2[i - 1] * K2 % MOD;\n    for (int i = 1; i < N; i++) deg[-i] = deg[-i + 1] * rK % MOD;\n    for (int i = 1; i < N; i++) deg2[-i] = deg2[-i + 1] * rK2 % MOD;\n    srand(time(NULL));\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n    cin >> n >> s;\n    ll a = 0, a2 = 0;\n    for (int i = n - 1; i >= 0; i--)\n    {\n        if (s[i] == '+')\n        {\n            a = (a + MOD - 1) % MOD;\n            a2 = (a2 + MOD - 1) % MOD;\n        }\n        if (s[i] == '-')\n        {\n            a = (a + 1) % MOD;\n            a2 = (a2 + 1) % MOD;\n        }\n        if (s[i] == '>')\n        {\n            a = (a * K) % MOD;\n            a2 = (a2 * K2) % MOD;\n        }\n        if (s[i] == '<')\n        {\n            a = (a * rK) % MOD;\n            a2 = (a2 * rK2) % MOD;\n        }\n    }\n    if (s[0] == '+') pref0[0] = (pref0[0] + 1) % MOD;\n    if (s[0] == '+') pref02[0] = (pref02[0] + 1) % MOD;\n    if (s[0] == '-') pref0[0] = (pref0[0] + MOD - 1) % MOD;\n    if (s[0] == '-') pref02[0] = (pref02[0] + MOD - 1) % MOD;\n    if (s[0] == '<') pref0[0] = (pref0[0] * K) % MOD;\n    if (s[0] == '<') pref02[0] = (pref02[0] * K2) % MOD;\n    if (s[0] == '>') pref0[0] = (pref0[0] * rK) % MOD;\n    if (s[0] == '>') pref02[0] = (pref02[0] * rK2) % MOD;\n    if (s[0] == '>') moves[0]++;\n    if (s[0] == '<') moves[0]--;\n    for (int i = 1; i < n; i++)\n    {\n        if (s[i] == '+') pref0[i] = (pref0[i - 1] + 1) % MOD;\n        if (s[i] == '+') pref02[i] = (pref02[i - 1] + 1) % MOD;\n        if (s[i] == '-') pref0[i] = (pref0[i - 1] + MOD - 1) % MOD;\n        if (s[i] == '-') pref02[i] = (pref02[i - 1] + MOD - 1) % MOD;\n        if (s[i] == '<') pref0[i] = (pref0[i - 1] * K) % MOD;\n        if (s[i] == '<') pref02[i] = (pref02[i - 1] * K2) % MOD;\n        if (s[i] == '>') pref0[i] = (pref0[i - 1] * rK) % MOD;\n        if (s[i] == '>') pref02[i] = (pref02[i - 1] * rK2) % MOD;\n        moves[i] = moves[i - 1];\n        if (s[i] == '>') moves[i]++;\n        if (s[i] == '<') moves[i]--;\n    }\n    for (int j = 0; j < n; j++)\n    {\n        if (s[j] == '+')\n        {\n            suf0[0] = (suf0[0] + 1) % MOD;\n            suf02[0] = (suf02[0] + 1) % MOD;\n        }\n        if (s[j] == '-')\n        {\n            suf0[0] = (suf0[0] + MOD - 1) % MOD;\n            suf02[0] = (suf02[0] + MOD - 1) % MOD;\n        }\n        if (s[j] == '<')\n        {\n            suf0[0] = (suf0[0] * K) % MOD;\n            suf02[0] = (suf02[0] * K2) % MOD;\n        }\n        if (s[j] == '>')\n        {\n            suf0[0] = (suf0[0] * rK) % MOD;\n            suf02[0] = (suf02[0] * rK2) % MOD;\n        }\n    }\n    for (int i = 0; i < n; i++) suf0[i + 1] = (suf0[0] - pref0[i] * deg[moves[i]] + MOD * MOD) % MOD;\n    for (int i = 0; i < n; i++) suf02[i + 1] = (suf02[0] - pref02[i] * deg2[moves[i]] + MOD * MOD) % MOD;\n    for (int i = 0; i < n; i++) sufa[i] = (suf0[i] + a * deg[(i > 0 ? moves[i - 1] : 0) - moves[n - 1]]) % MOD;\n    for (int i = 0; i < n; i++) sufa2[i] = (suf02[i] + a * deg2[(i > 0 ? moves[i - 1] : 0) - moves[n - 1]]) % MOD;\n    ll ans = 0;\n    map<vector<ll>, ll> cnt;\n    for (int i = n; i >= 0; i--)\n    {\n        ans += cnt[{sufa[i], sufa2[i]}];\n        cnt[{suf0[i], suf02[i]}]++;\n    }\n    cout << ans;\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define all(x) x.begin(), x.end()\nusing namespace std;\nusing ll = long long;\nconst int maxn = 1<<19, mod = 119<<23|1;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nconst int B = 299977 + (rng()%10000);\nint n, pw[maxn], F[maxn], ps = 0, ans = 0;\nstring s;\nmap<int, int> cnt;\nvoid add(int &a, int b) {\n\ta = a+b>=mod?a+b-mod:a+b;\n}\nll bp(ll a, ll p) {\n\tint r = 1;\n\twhile(p) {\n\t\tif(p&1) r = r*a%mod;\n\t\ta = a*a%mod, p>>=1;\n\t}\n\treturn r;\n} \nsigned main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> n >> s;\n\tpw[0] = 1;\n\tfor(int i = 1; i < maxn; i++) pw[i] = pw[i-1]*1ll*B%mod;\n\tcnt[0]++;\n\tint cur = 0;\n\tfor(int i = 0; i < n; i++) {\n\t\tif(s[i] == '>') ps++;\n\t\tif(s[i] == '<') ps--;\n\t\tif(s[i] == '+') add(cur, pw[(maxn/2) + ps]);\n\t\tif(s[i] == '-') add(cur, mod-pw[(maxn/2) + ps]);\n\t\tF[i+1] = cur;\n\t\tcnt[cur]++;\n\t}\n\tps = 0;\n\tfor(int ccur = 0, ps = 0, i = 0; i <= n; i++) {\n\t\tcnt[F[i]]--;\n\t\tans += cnt[(ccur + bp(B, mod-1+ps)*1ll*cur)%mod];\n\t\tif(i == n) continue;\n\t\tif(s[i] == '>') ps++;\n\t\tif(s[i] == '<') ps--;\n\t\tif(s[i] == '+') add(ccur, pw[(maxn/2) + ps]);\n\t\tif(s[i] == '-') add(ccur, mod-pw[(maxn/2) + ps]);\n\t}\n\tcout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define ull unsigned long long\n\nconst int Maxv = 1000010; \nconst ull Prime1 = 239; \nconst ull Prime2 = 213658850274627977; \n                            \nint idx[Maxv], n; \nlong long ans; \null Hash[Maxv], val[Maxv]; \nchar s[Maxv]; \n\nstd::map<ull, int> Map; \n\ninline void PreHandle() {\n    val[n] = 1; \n    for (int i = n + 1; i <= (n << 1); i++)\n        val[i] = val[i - 1] * Prime1; \n    for (int i = n - 1; i >= 0; i--)\n        val[i] = val[i + 1] * Prime2; \n}\n\nsigned main() {\n    scanf(\"%d\", &n); \n    scanf(\"%s\", s); \n\n    PreHandle(); \n\n    for (int i = 0; i < n; i++) {\n        Hash[i + 1] = Hash[i]; \n        idx[i + 1] = idx[i]; \n\n        if (s[i] == '>')\n            idx[i + 1]++; \n        if (s[i] == '<')\n            idx[i + 1]--;\n        if (s[i] == '+')\n            Hash[i + 1] += val[n + idx[i + 1]]; \n        if (s[i] == '-')\n            Hash[i + 1] -= val[n + idx[i + 1]]; \n    }\n    \n    for (int i = n; i >= 0; i--) {\n        ull tmp = Hash[i] + Hash[n] * val[n + idx[i]];\n        ans += Map[tmp]; \n        Map[ Hash[i] ]++;\n    }\n\n    printf(\"%lld\\n\", ans);\n\n    return 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\n\nconst int mod0 = 1e9 + 7;\nconst int mod1 = 1e9 + 9;\nconst int mod2 = 1e9 + 21;\nconst int base = 10007;\n\nint64_t power(int64_t x, int64_t n, int64_t mod) {\n  int64_t ret = 1;\n  while(n > 0) {\n    if(n & 1) (ret *= x) %= mod;\n    (x *= x) %= mod;\n    n >>= 1;\n  }\n  return ret;\n}\n\n\nint64 h0[550001], g0[550001];\nint64 h1[550001], g1[550001];\nint64 h2[550001], g2[550001];\n\n\nint main() {\n\n  h0[0] = h1[0] = h2[0] = 1;\n  for(int i = 1; i < 550001; i++) {\n    h0[i] = h0[i - 1] * base % mod0;\n    h1[i] = h1[i - 1] * base % mod1;\n    h2[i] = h2[i - 1] * base % mod2;\n  }\n  g0[550000] = power(h0[550000], mod0 - 2, mod0);\n  g1[550000] = power(h1[550000], mod1 - 2, mod1);\n  g2[550000] = power(h2[550000], mod2 - 2, mod2);\n  for(int i = 549999; i >= 0; i--) {\n    g0[i] = g0[i + 1] * (i + 1) % mod0;\n    g1[i] = g1[i + 1] * (i + 1) % mod1;\n    g2[i] = g2[i + 1] * (i + 1) % mod2;\n  }\n\n  int N;\n  string S;\n\n  cin >> N;\n  cin >> S;\n\n  vector< int64 > latte0, malta0;\n  vector< int64 > latte1, malta1;\n  vector< int64 > latte2, malta2;\n  int64 beet = 0, pos = 250001;\n  latte0.push_back(pos), malta0.push_back(beet);\n  latte1.push_back(pos), malta1.push_back(beet);\n  latte2.push_back(pos), malta2.push_back(beet);\n  for(int i = 0; i < N; i++) {\n    char c = S[i];\n    if(c == '+') (beet += h0[pos]) %= mod0;\n    else if(c == '-') (beet += mod0 - h0[pos]) %= mod0;\n    else if(c == '<') --pos;\n    else ++pos;\n    latte0.push_back(pos), malta0.push_back(beet);\n  }\n  beet = 0, pos = 250001;\n  for(int i = 0; i < N; i++) {\n    char c = S[i];\n    if(c == '+') (beet += h1[pos]) %= mod1;\n    else if(c == '-') (beet += mod1 - h1[pos]) %= mod1;\n    else if(c == '<') --pos;\n    else ++pos;\n    latte1.push_back(pos), malta1.push_back(beet);\n  }\n  beet = 0, pos = 250001;\n\n  for(int i = 0; i < N; i++) {\n    char c = S[i];\n    if(c == '+') (beet += h2[pos]) %= mod2;\n    else if(c == '-') (beet += mod2 - h2[pos]) %= mod2;\n    else if(c == '<') --pos;\n    else ++pos;\n    latte2.push_back(pos), malta2.push_back(beet);\n  }\n\n\n  map< tuple< int64, int64, int64 >, int > mp;\n  int64 ret = 0;\n  for(int i = N; i >= 0; i--) {\n    int64 dx = latte0[i] - latte0[0];\n    int64 mul0, mul1, mul2;\n    if(dx >= 0) mul0 = h0[dx], mul1 = h1[dx], mul2 = h1[dx];\n    else mul0 = g0[-dx], mul1 = g1[-dx], mul2 = g2[-dx];\n    ret += mp[make_tuple((malta0[i] + malta0[N] * mul0) % mod0, (malta1[i] + malta1[N] * mul1) % mod1, (malta2[i] + malta2[N] * mul2) % mod2)];\n    ++mp[make_tuple(malta0[i], malta1[i], malta2[i])];\n  }\n  cout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <vector>\n\nconst int DEBUG = 0;\n\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define DEBUGP(val) cerr << #val << \"=\" << val << \"\\n\"\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\ntypedef pair<ll, ll> PL;\n\n\nll powmod(ll a, ll e, ll mod) {\n  ll sum = 1;\n  ll cur = a;\n  while (e > 0) {\n    if (e % 2) {\n      sum = sum * cur % mod;\n    }\n    cur = cur * cur % mod;\n    e /= 2;\n  }\n  return sum;\n}\n\nconst int A = 7;\n\nconst ll mod = 1e9 + 7;\n\ntemplate<ll mod = (ll)1e9 + 7>\nstruct ModInt {\n  ll x;\n  ModInt(void): x(0) {}\n  ModInt(ll x): x(x % mod){}\n  ModInt(const ModInt &x): x(x.x) {}\n  ModInt operator+(ModInt o) const {\n    return ModInt((x + o.x) % mod);\n  }\n  ModInt operator-(ModInt o) const {\n    return ModInt((x - o.x + mod) % mod);\n  }\n  ModInt operator*(ModInt o) const {\n    return ModInt((x * o.x) % mod);\n  }\n  ll to_ll() const {\n    return x;\n  }\n  bool operator<(ModInt o) const {\n    return x < o.x;\n  }\n  ModInt pow(ll e) {\n    assert (e >= 0);\n    ModInt sum = 1;\n    ModInt cur = *this;\n    while (e > 0) {\n      if (e % 2) {\n        sum = sum * cur;\n      }\n      cur = cur * cur;\n      e /= 2;\n    }\n    return sum;\n  }\n};\n\ntemplate<ll mod>\nostream &operator<<(ostream &os, ModInt<mod> mi) {\n  return os << mi.x;\n}\n\n\nint main(void) {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  string s;\n  cin >> n >> s;\n  int p = 0;\n  VI pos(n + 1);\n  mt19937 mt;\n  vector<ModInt<> > b(A);\n  \n  REP(c, 0, A) {\n    do {\n      b[c] = mt();\n    } while (b[c].to_ll() == 0);\n  }\n  vector<vector<ModInt<> > > hsh(A, vector<ModInt<> >(n + 1));\n  ModInt<> inv[A] = { 0 };\n  REP(c, 0, A) inv[c] = b[c].pow(mod - 2);;\n  REP(c, 0, A) {\n    p = 0;\n    ModInt<> cur = 1;\n    REP(i, 0, n) {\n      ModInt<> tmp = hsh[c][i];\n      if (s[i] == '>') {\n        p++;\n        cur = cur * b[c];\n      }\n      if (s[i] == '<') {\n        p--;\n        cur = cur * inv[c];\n      }\n      if (s[i] == '+') {\n        tmp = tmp + cur;\n      }\n      if (s[i] == '-') {\n        tmp = tmp - cur;\n      }\n      hsh[c][i + 1] = tmp;\n      pos[i + 1] = p;\n    }\n  }\n  if (DEBUG) {\n    REP(i, 0, n + 1) {\n      cerr << i << \" \" << hsh[0][i] << endl;\n    }\n  }\n  vector<ModInt<> > meguru(A);\n  REP(c, 0, A) meguru[c] = hsh[c][n];\n  map<vector<ModInt<> >, int> kirika;\n  kirika[meguru] = 1;\n  ll tot = 0;\n  vector<ModInt<> > cur(A);\n  REP(c, 0, A) cur[c] = b[c].pow(mod - 1 + pos[n]);\n  for (int i = n - 1; i >= 0; --i) {\n    if (DEBUG) {\n      DEBUGP(i);\n      DEBUGP(pos[i]);\n    }\n    if (pos[i + 1] - pos[i] == 1) {\n      REP(c, 0, A) cur[c] = cur[c] * inv[c];\n    }\n    else if (pos[i + 1] - pos[i] == -1) {\n      REP(c, 0, A) cur[c] = cur[c] * b[c];\n    }\n    vector<ModInt<> > ken(A);\n    REP(c, 0, A) ken[c] = cur[c] * meguru[c] + hsh[c][i];\n    tot += kirika[ken];\n    vector<ModInt<> > tt(A);\n    REP(c, 0, A) tt[c] = hsh[c][i];\n    kirika[tt] += 1;\n  }\n  cout << tot << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define mp make_pair\n#define PI pair<int,int>\n#define poly vector<ll>\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\n#define pb push_back\n#define fi first\n#define se second\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst int M=200005,N=1005;\nint nxt[M],ed[M],ans[M];\nvector<int> v[N];\nint son[N],vis[N],ne,alb[M],lt[N][N];\nvoid ae(int a,int b){\n\tnxt[++ne]=son[a]; son[a]=ne; ed[ne]=b;\n}\nvoid dfs(int p){\n\tvis[p]=1;\n\tfor(auto i:v[p])if(!vis[i])dfs(i);\n}\nint main(){\n\tint n=read(),m=read();\n\tFor(i,1,m){\n\t\tint s=read(),t=read(); \n\t\tae(s,t); v[s].pb(t);\n\t}\n\tFor(i,1,n){\n\t\tmemset(vis,0,sizeof(vis)); \n\t\tvector<int> v; vis[i]=1;\n\t\tfor(int j=son[i];j;j=nxt[j]){\t\t\t\n\t\t\tif(vis[ed[j]]){\n\t\t\t\talb[j]=1; \n\t\t\t}else{\n\t\t\t\tdfs(ed[j]);\n\t\t\t}\n\t\t\tv.pb(j);\n\t\t}\n\t\tmemset(vis,0,sizeof(vis));  vis[i]=1;\n\t\tRep(o,v.size()-1,0){\n\t\t\tint j=v[o];\n\t\t\tif(vis[ed[j]]){\n\t\t\t\talb[j]=1; \n\t\t\t}else{\n\t\t\t\tdfs(ed[j]);\n\t\t\t}\n\t\t}\n\t\tFor(j,1,n)lt[i][j]=vis[j];\n\t}\n\tFor(i,1,n)for(int j=son[i];j;j=nxt[j])ans[j]=alb[j]==lt[ed[j]][i];\n\t//for(int i=son[3];i;i=nxt[i])if(ed[i]==4)cout<<alb[i]<<endl;\n\tFor(i,1,m)puts(ans[i]?\"same\":\"diff\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <unordered_map>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate <class T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (T& x : v)\n    is >> x;\n  return is;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\nconst int N = 250010, P = 998244353, P2 = 1000000007, B = 19260817, B2 = 1919810;\n\nstruct Int {\n  int a, b;\n\n  Int(int x = 0) : a(x), b(x) {}\n\n  Int(int x, int y) : a(x), b(y) {}\n\n  Int operator+(const Int& rhs) const { return Int((a + rhs.a) % P, (b + rhs.b) % P2); }\n\n  Int operator*(const Int& rhs) const { return Int((a * (ll)rhs.a) % P, (b * (ll)rhs.b) % P2); }\n\n  bool operator<(const Int &rhs) const {\n    if (a < rhs.a)\n      return true;\n    if (rhs.a < a)\n      return false;\n    return b < rhs.b;\n  }\n};\n\ntypedef pair<Int, Int> pii;\n\nstruct NumberTheory {\n\n  typedef pair<int, int> _P2_Field;\n\n  mt19937 rng;\n\n  NumberTheory() : rng(chrono::steady_clock::now().time_since_epoch().count()) {}\n\n  void _exGcd(int a, int b, int& x, int& y) {\n    if (!b) {\n      x = 1;\n      y = 0;\n      return;\n    }\n    _exGcd(b, a % b, y, x);\n    y -= a / b * x;\n  }\n\n  int inv(int a, int p = P) {\n    int x = 0, y = 0;\n    _exGcd(a, p, x, y);\n    if (x < 0)\n      x += p;\n    return x;\n  }\n\n  template <class Integer>\n  bool quadRes(Integer a, Integer b) {\n    if (a <= 1)\n      return true;\n    while (a % 4 == 0)\n      a /= 4;\n    if (a % 2 == 0)\n      return (b % 8 == 1 || b % 8 == 7) == quadRes(a / 2, b);\n    return ((a - 1) % 4 == 0 || (b - 1) % 4 == 0) == quadRes(b % a, a);\n  }\n\n  // assume p in prime, x in quadratic residue\n  int sqrt(int x, int p = P) {\n    if (p == 2 || x <= 1)\n      return x;\n    int w, v, k = (p + 1) / 2;\n    do {\n      w = rng() % p;\n    } while (quadRes(v = int((w * (ll)w - x + p) % p), p));\n    _P2_Field res(1, 0), a(w, 1);\n    while (k) {\n      if (k & 1)\n        res = _P2_Field((res.first * (ll)a.first + res.second * (ll)a.second % p * v) % p, (res.first * (ll)a.second + res.second * (ll)a.first) % p);\n      if (k >>= 1)\n        a = _P2_Field((a.first * (ll)a.first + a.second * (ll)a.second % p * v) % p, (a.first * (ll)a.second << 1) % p);\n    }\n    return min(res.first, p - res.first);\n  }\n\n} nt;\n\npii unite(const pii& lhs, const pii& rhs) { return make_pair(lhs.first + rhs.first * lhs.second, lhs.second * rhs.second); }\n\nconst pii LEFT(0, Int(B, B2)), RIGHT(0, Int(nt.inv(B), nt.inv(B2, P2))), PLUS(1, 1), MINUS(Int(P - 1, P2 - 1), 1);\n\nchar s[N];\npii op[256];\npii pref[N];\n\nmap<Int, int> mp;\n\nint main() {\n#ifdef LBT\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n;\n  cin >> n >> (s + 1);\n  op['<'] = LEFT;\n  op['>'] = RIGHT;\n  op['+'] = PLUS;\n  op['-'] = MINUS;\n  pref[0] = make_pair(0, 1);\n  for (int i = 1; i <= n; ++i)\n    pref[i] = unite(pref[i - 1], op[s[i]]);\n  ll ans = 0;\n  for (int i = 0; i <= n; ++i) {\n    ans += mp[pref[i].first];\n    ++mp[unite(pref[i], pref[n]).first];\n  }\n  cout << ans << '\\n';\n\n#ifdef LBT\n  LOG(\"Time: %dms\\n\", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <map>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define ll long long\n\nll poww(ll a, ll b, ll mod) {\n    ll ans = 1;\n    while (b > 0) {\n        if (b & 1) ans = (ans * a) % mod;\n        b >>= 1;\n        a = (a * a) % mod;\n    }\n    return ans;\n}\n\nconst int maxN = 250011;\n\nconst ll mod = 1000000007;\nconst ll base = 500167;\nconst ll inv_base = poww(base, mod - 2, mod);\n\nconst ll mod2 = 1000000009;\nconst ll base2 = 503803; \nconst ll inv_base2 = poww(base2, mod2 - 2, mod2);\n\nstruct hash_key {\n    ll v1, v2;\n\n    hash_key() {v1 = v2 = 0;}\n    hash_key(ll _v1, ll _v2) {v1 = _v1 % mod; v2 = _v2 % mod2;}\n    hash_key(ll x) { v1 = (mod + x) % mod, v2 = (mod2 + x) % mod2; }\n\n    bool operator<(const hash_key &who) const {\n        return mp(v1, v2) < mp(who.v1, who.v2);\n    }\n    \n    bool operator==(const hash_key &who) const {\n        return mp(v1, v2) == mp(who.v1, who.v2);\n    }\n\n    void operator*=(const hash_key who) {\n        v1 = (v1 * who.v1) % mod;\n        v2 = (v2 * who.v2) % mod2;\n    }\n\n    void operator+=(const hash_key who) {\n        v1 = (v1 + who.v1) % mod;\n        v2 = (v2 + who.v2) % mod2;\n    }\n\n    void operator-=(const hash_key who) {\n        v1 = (v1 + mod - who.v1) % mod;\n        v2 = (v2 + + mod2 - who.v2) % mod2;\n    }\n\n    hash_key get_inv()const {\n        return {poww(v1, mod - 2, mod), poww(v2, mod2 - 2, mod2)};\n    }\n};\n\nstruct smart_map {\n    map<hash_key, ll> M;\n    hash_key bonus;\n\n    smart_map() {\n        M.clear();\n        bonus = {1, 1};\n    }\n\n    void operator*=(hash_key who) {\n        bonus *= who;\n    }\n\n    void add(hash_key x) {\n        x *= bonus.get_inv();\n        M[x]++;\n    }\n\n    ll query(hash_key x) {\n        x *= bonus.get_inv();\n        return M[x];\n    }\n};\n\nll n, i;\nchar s[maxN];\nsmart_map data;\nll ans;\n\nhash_key act, full;\nconst hash_key to_left = {base, base2};\nconst hash_key to_right = {inv_base, inv_base2};\n\nint main()\n{\n   // freopen(\"test.in\",\"r\",stdin);\n\n    scanf(\"%d\\n%s\", &n, s + 1);\n\n    data.add(hash_key(0));\n    act = hash_key(0);\n\n    for (i = n; i >= 1; i--) {\n        if (s[i] == '+') act += 1;    \n        if (s[i] == '-') act += -1;\n        if (s[i] == '<') act *= to_left;\n        if (s[i] == '>') act *= to_right;\n    }\n\n    full = act;\n    act = hash_key(0);\n\n    for (i = n; i >= 1; i--) {\n        if (s[i] == '+') act += 1;    \n        if (s[i] == '-') act += -1;\n        if (s[i] == '<') act *= to_left, data *= to_left;\n        if (s[i] == '>') act *= to_right, data *= to_right;\n    \n        hash_key src = act;\n        src -= full;\n        ans += data.query(src);\n\n        data.add(act);\n    }\n\n    printf(\"%lld\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <set>\n\n#define MIN_INT -2147483648\n#define MAX_INT 2147483647\n#define MIN_LONG -9223372036854775808L\n#define MAX_LONG 9223372036854775807L\n#define PI 3.141592653589793238462643383279502884L\n\n#define long long long int\n\nusing std::vector;\nusing std::map;\nusing std::set;\nusing std::string;\nusing std::pair;\nusing std::cin;\nusing std::cout;\nusing std::cerr;\n\n// @author: pashka\n\n#define MAX 250000\n\nint main() {\n    std::ios::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n    string s;\n    cin >> s;\n\n    long X = 716447;\n\n    vector<long> pow(2 * MAX + 2);\n    pow[0] = 1;\n    for (int i = 1; i < pow.size(); i++) {\n        pow[i] = pow[i - 1] * X;\n    }\n\n    vector<long> h(n + 1);\n    vector<int> p(n + 1);\n    p[0] = MAX + 1;\n    for (int i = 0; i < n; i++) {\n        h[i + 1] = h[i];\n        p[i + 1] = p[i];\n        if (s[i] == '+') {\n            h[i + 1] += pow[p[i]];\n        } else if (s[i] == '-') {\n            h[i + 1] -= pow[p[i]];\n        } else if (s[i] == '>') {\n            p[i + 1]++;\n        } else if (s[i] == '<') {\n            p[i + 1]--;\n        }\n    }\n\n    long H = h[n];\n    map<long, int> mp;\n    long res = 0;\n    for (int i = n; i >= 0; i--) {\n        int a = h[i] * pow[MAX + 1];\n        int b = a + H * pow[p[i]];\n        res += mp[b];\n        mp[a]++;\n    }\n    cout << res << \"\\n\";\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define LL long long\n#define N 600000\n\nconst LL mod=998244353;\nLL n,B,iB,ans,pw[N],ipw[N],p[N],h[N];\nchar s[N];\nmap<LL,LL> mp;\n\nLL inv(LL x){return x==1?1:(mod-mod/x)*inv(mod%x)%mod;}\n\nint main(){\n\tscanf(\"%lld%s\",&n,s+1);\n\tpw[0]=1; ipw[0]=1; iB=inv(B=233);\n\tfor (LL i=1;i<=n*2;++i){\n\t\tpw[i]=pw[i-1]*B%mod;\n\t\tipw[i]=ipw[i-1]*iB%mod;\n\t}\n\tp[0]=n;\n\tfor (LL i=1;i<=n;++i){\n\t\tif (s[i]=='+'){p[i]=p[i-1]; h[i]=(h[i-1]+pw[p[i]])%mod;}\n\t\tif (s[i]=='-'){p[i]=p[i-1]; h[i]=(h[i-1]-pw[p[i]]+mod)%mod;}\n\t\tif (s[i]=='>'){p[i]=p[i-1]+1; h[i]=h[i-1];}\n\t\tif (s[i]=='<'){p[i]=p[i-1]-1; h[i]=h[i-1];}\n\t\t++mp[h[i]];\n\t}\n\tfor (LL i=1;i<=n;++i){\n \t\tLL d=p[i-1]-p[0],t=h[n];\n\t\tif (d>=0) t=t*pw[d]%mod;\n\t\telse t=t*ipw[-d]%mod;\n\t\tt=(t+h[i-1]+mod)%mod;\n\t\tans+=mp[t];\n\t\t--mp[h[i]];\n\t}\n\tprintf(\"%lld\\n\",ans);\n\t\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ull unsigned long long\n#define key 1000000007\n#define k 9223372036854775807ull\nusing namespace std;\nint n;\nchar s[250010];\nmap <ull, ull> M;\ninline ull power(ull x, ull y)\n{\n\tull Ans = 1;\n\twhile(y)\n\t{\n\t\tif(y & 1)\n\t\t\tAns *= x;\n\t\ty >>= 1;\n\t\tx *= x;\n\t}\n\treturn Ans;\n}\nmap <ull, ull> P;\nint main()\n{\n\tull ny = power(key, k);\n\tscanf(\"%d%s\", &n, s);\n\tull w = 0;\n\tull p = 0;\n\tfor(int i = 0; i < n; ++ i)\n\t{\n\t\tif(s[i] == '+')\n\t\t\t++ P[p];\n\t\telse if(s[i] == '-')\n\t\t\t-- P[p];\n\t\telse if(s[i] == '>')\n\t\t\t++ p;\n\t\telse -- p;\n\t}\n\tfor(int i = - n; i < 0; ++ i)\n\t\tw += power(ny, - i) * P[i];\n\tfor(int i = 0; i <= n; ++ i)\n\t\tw += power(key, i) * P[i];\n\tull a = 1, b = 0;\n\tull Ans = 0;\n\tfor(int i = n - 1; i >= 0; -- i)\n\t{\n\t\t++ M[-b * power(a, k)];\n\t\tif(s[i] == '+')\n\t\t\t++ b;\n\t\telse if(s[i] == '-')\n\t\t\t-- b;\n\t\telse if(s[i] == '>')\n\t\t\ta *= key, b *= key;\n\t\telse if(s[i] == '<')\n\t\t\ta *= ny, b *= ny;\n\t\tAns += M[(w - b) * power(a, k)];\n\t}\n\tprintf(\"%llu\", Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<climits>\n#include<bitset>\n#include<map>\n#define pii pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define int long long\n#define mod1 1004535809\n#define mod2 1000000007\nusing namespace std;\ninline int read(){\n    int f=1,ans=0;char c=getchar();\n    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}\n    while(c>='0'&&c<='9'){ans=ans*10+c-'0';c=getchar();}\n    return f*ans;\n}\nconst int MAXN=5e5+11;\nint N;char str[MAXN];\nint h1[MAXN],s1[MAXN],xx=997,res,h2[MAXN],s2[MAXN];\nint ksm1(int a,int b){\n    int ans=1;\n    while(b){if(b&1) ans*=a,ans%=mod1;a*=a,a%=mod1;b>>=1;}return ans;\n}\nint pw1(int a,int b){\n    if(b>=0) return ksm1(a,b);\n    int res=ksm1(a,-b);return ksm1(res,mod1-2);\n}\nint ksm2(int a,int b){\n    int ans=1;\n    while(b){if(b&1) ans*=a,ans%=mod2;a*=a,a%=mod2;b>>=1;}return ans;\n}\nint pw2(int a,int b){\n    if(b>=0) return ksm2(a,b);\n    int res=ksm2(a,-b);return ksm2(res,mod1-2);\n}\nmap<pii,int> M;\nvoid ins(int ps){M[mp( (h1[ps]+pw1(xx,s1[ps])*h1[N])%mod1 , (h2[ps]+pw2(xx,s2[ps])*h2[N])%mod2 )]++;return;}\nsigned main(){\n    //freopen(\"1.in\",\"r\",stdin);\n    N=read();scanf(\"%s\",str+1);\n    for(int i=1;i<=N;i++){\n        if(str[i]=='+') h1[i]=h1[i-1]+pw1(xx,s1[i-1]),s1[i]=s1[i-1],h1[i]%=mod1;\n        if(str[i]=='-') h1[i]=h1[i-1]-pw1(xx,s1[i-1])+mod1,s1[i]=s1[i-1],h1[i]%=mod1;\n        if(str[i]=='>') h1[i]=h1[i-1],s1[i]=s1[i-1]+1;\n        if(str[i]=='<') h1[i]=h1[i-1],s1[i]=s1[i-1]-1;\n        if(str[i]=='+') h2[i]=h2[i-1]+pw2(xx,s2[i-1]),s2[i]=s2[i-1],h2[i]%=mod2;\n        if(str[i]=='-') h2[i]=h2[i-1]-pw2(xx,s2[i-1])+mod2,s2[i]=s2[i-1],h2[i]%=mod2;\n        if(str[i]=='>') h2[i]=h2[i-1],s2[i]=s2[i-1]+1;\n        if(str[i]=='<') h2[i]=h2[i-1],s2[i]=s2[i-1]-1;\n    }\n    //for(int i=1;i<=N;i++) printf(\"h:%lld s:%lld\\n\",h[i],s[i]);\n    /*for(int i=1;i<=N;i++)\n        for(int j=i;j<=N;j++){\n            if(((h1[i-1]+pw1(xx,s1[i-1])*h1[N])%mod1)==h1[j]&&((h2[i-1]+pw2(xx,s2[i-1])*h2[N])%mod2)==h2[j]){\n                res++;\n                //cerr<<i<<\" \"<<j<<endl;\n            }\n            //res+=(((h[i-1]+ksm(xx,s[i-1])*h[N])%mod)==h[j]);\n        }*/\n    ins(0);\n    for(int i=1;i<=N;i++){\n        res+=M[mp(h1[i],h2[i])];\n        ins(i);\n    }printf(\"%lld\\n\",res);return 0;\n}/*\n  5\n  +>+<-\n  */\n\n"
  },
  {
    "language": "C++",
    "code": "//I love armpit fetish\n\n#include <bits/stdc++.h>\nusing namespace std;\n \n#define debug(x) cerr << #x << \" = \" << x << '\\n';\n#define BP() cerr << \"OK!\\n\";\n#define PR(A, n) {cerr << #A << \" = \"; for (int _=1; _<=n; ++_) cerr << A[_] << ' '; cerr << '\\n';}\n#define PR0(A, n) {cerr << #A << \" = \"; for (int _=0; _<n; ++_) cerr << A[_] << ' '; cerr << '\\n';}\n#define FILE_NAME \"data\"\n\nconst int MAX_N = 500002;\nconst int offset = 250002;\nconst int T = 260000;\nconst int64_t MOD = 1000000021;\n\nint n, cnt[MAX_N];\nstring s;\nint64_t pref_hash[MAX_N], suff_hash[MAX_N];\n\nvoid enter() {\n\tcin >> n >> s;\n}\n\nint64_t pw(int n, int k) {\n\tif (k==0)\n\t\treturn 1;\n\tint64_t tmp = pw(n, k/2);\n\tif (k%2)\n\t\treturn tmp * tmp % MOD * n % MOD;\n\treturn tmp * tmp % MOD;\n}\n\nvoid init_pref() {\n\tint p = offset;\n\tint64_t H = 0;\n\tfor (int i=0; i<n; ++i) {\n\t\tif (s[i]=='<' || s[i]=='>') {\n\t\t\tp += (s[i]=='<' ? -1 : 1);\n\t\t\tcnt[i] = cnt[i-1] + (s[i]=='<' ? -1 : 1);\n\t\t}\n\t\telse {\n\t\t\tH = (H - pw(T, p) * (s[i]=='-' ? 1 : -1)) % MOD;\n\t\t}\n\t\tpref_hash[i] = (H + MOD) % MOD;\n\t}\n}\n\nvoid init_suff() {\n\tint64_t H = pref_hash[n-1];\n\tint p = offset;\n\tfor (int i=0; i<n; ++i) {\n\t\tif (s[i]=='>' || s[i]=='<')\n\t\t\tp += (s[i]=='>' ? 1 : -1);\n\t\telse {\n\t\t\t// debug(i);\n\t\t\t// debug(p);\n\t\t\t// debug((s[i]=='+' ? -1 : 1));\n\t\t\tH = (H + pw(T, p) * (s[i]=='+' ? -1 : 1)) % MOD;\n\t\t}\n\t\tsuff_hash[i+1] = (H + MOD) % MOD;\n\t}\n}\n\nint64_t solve() {\n\tmap<int64_t, int> mp;\n\tint64_t H = pref_hash[n-1];\n\tint64_t res = 0;\n\tfor (int j=0; j<n; ++j) {\n\t\tif (j==0)\n\t\t\t++mp[0];\n\t\telse\n\t\t\t++mp[((H - pref_hash[j-1] - H * pw(T, cnt[j-1])) % MOD + MOD) % MOD];\n\t\tres += mp[suff_hash[j+1]];\n\t}\n\treturn res;\n}\n\nint main() {\n\t//#define OFFLINE_JUDGE doraemon\n\t#ifdef OFFLINE_JUDGE\n\t\tfreopen(FILE_NAME\".inp\", \"r\", stdin);\n\t\tfreopen(FILE_NAME\".out\", \"w\", stdout);\n\t#endif\n\tios::sync_with_stdio(0); cin.tie(0);\n\tenter();\n\tinit_pref();\n\tinit_suff();\n\tcout << solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (rint i = 1; i <= (n); i ++)\n#define re0(i, n) for (rint i = 0; i < (int) n; i ++)\n#define travel(i, u) for (rint i = head[u]; i; i = e[i].nxt)\n#define rint register int\nusing namespace std;\n\ntypedef long long lo;\n\ntemplate<typename tp> inline void read(tp &x) {\n    x = 0; char c = getchar(); int f = 0;\n    for (; c < '0' || c > '9'; f |= c == '-', c = getchar());\n    for (; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar());\n    if (f) x = -x;\n}\n\nconst int MOD1 = 1e9 + 7;\nconst int MOD2 = 1e9 + 9;\nconst int base1 = 233;\nconst int base2 = 999;\nconst int N = 3e5 + 233;\nconst int DELTA = 1e7;\nint n, _pos[N];\nchar str[N]; \n\ninline int power(int a, int k, int MOD) {\n\tif (k < 0) k += MOD - 1;\n\tint ans = 1;\n\tfor (; k; k >>= 1, a = (lo) a * a % MOD)\n\t\tif (k & 1) ans = (lo) ans * a % MOD;\n\treturn ans;\n}\n\nstruct val_t {\n\tint w1, w2;\n\tval_t (int w1 = 0, int w2 = 0) : w1(w1), w2(w2) {}\n\tinline void Set(int x, int t) {\n\t\tx += DELTA;\n\t\t(w1 += (lo) power(base1, x, MOD1) * (MOD1 + t) % MOD1) %= MOD1;\n\t\t(w2 += (lo) power(base2, x, MOD2) * (MOD2 + t) % MOD2) %= MOD2;\n\t}\n\tval_t rot(int d) {\n\t\tval_t a = *this;\n\t\ta.w1 = (lo) a.w1 * power(base1, d, MOD1) % MOD1;\n\t\ta.w2 = (lo) a.w2 * power(base2, d, MOD2) % MOD2;\n\t\treturn a;\n\t}\n};\nval_t val[N];\nmap <val_t, int> mp;\n\nval_t operator + (val_t a, val_t b) {\n\treturn val_t((a.w1 + b.w1) % MOD1, (a.w2 + b.w2) % MOD2);\n}\n\nbool operator < (val_t a, val_t b) {\n\treturn make_pair(a.w1, a.w2) < make_pair(b.w1, b.w2);\n}\n\nint main(void) {\n\tread(n);\n\tscanf(\"%s\", str + 1);\n\tint pos = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tval[i] = val[i - 1];\n\t\tif (str[i] == '+' || str[i] == '-')\n\t\t\tval[i].Set(pos, str[i] == '+' ? 1 : -1);\n\t\telse \n\t\t\tpos += str[i] == '>' ? 1 : -1;\n\t\t_pos[i] = pos;\n\t}\n\tval_t S = val[n];\n\tlo ans = 0;\n\tfor (int i = n; i >= 0; i--) {\n\t\tval_t to = S.rot(_pos[i]) + val[i];\n\t\tif (mp.count(to)) ans += mp[to];\n\t\tmp[val[i]]++;\n\t}\n\tcout << ans << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2)\n#include<bits/stdc++.h>\n#define ll long long\n#define maxn 500005\n#define inf 1e9\n#define eps 1e-10\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,w=1; char c=getchar();\n\twhile(c<'0'||c>'9') {if(c=='-') w=-1; c=getchar();}\n\twhile(c<='9'&&c>='0') {x=(x<<1)+(x<<3)+c-'0'; c=getchar();}\n\treturn w==1?x:-x;\n}\n\nmap <ll,int> p;\nll b[maxn],inv[maxn],ans;\nint len,n;\nchar s[maxn];\nconst ll mod=998244353;\nconst ll P=844009174;\n\ninline ll pw(ll a,ll b)\n{\n\tll ans=1,base=a;\n\twhile(b)\n\t{\n\t\tif(b&1) ans=(ans*base)%mod;\n\t\tbase=(base*base)%mod; b>>=1;\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\t//freopen(\"t1.out\",\"w\",stdout);\n\tn=read(); scanf(\"%s\",s+1); b[0]=1; inv[0]=1; len=strlen(s+1);\n\tfor(int i=1;i<=maxn-5;i++) b[i]=(b[i-1]*233)%mod,inv[i]=pw(b[i],mod-2);\n\t//cout<<571216159*inv[1]%mod<<endl;\n\tll ed=0,nw=250000;\n\t\n\t//cout<<b[nw-1]+b[nw+1]<<endl;\n\t\n\tfor(int i=1;i<=len;i++)\n\t{\n\t\tif(s[i]=='+') ed=(ed+b[nw])%mod;\n\t\telse if(s[i]=='-') ed=(ed-b[nw]+mod)%mod;\n\t\telse if(s[i]=='>') nw++;\n\t\telse if(s[i]=='<') nw--; p[ed]++;\n\t\t//cout<<s[i]<<\" \"<<ed<<\" \"<<nw<<endl;\n\t}\n\t//cout<<ed<<\" \"<<nw<<endl<<endl;\n\tll tmp=0; nw=250000; ans=0;\n\tfor(int i=1;i<=len;i++)\n\t{\n\t\tll p2=ed;\n\t\tif(nw>=250000) p2=(p2*b[nw-250000])%mod;\n\t\telse p2=(p2*inv[250000-nw])%mod;\n\t\tans+=p[(tmp+p2)%mod];\n\t\t//ans+=p[(tmp+ed*b[nw])%mod];\n\t\tif(s[i]=='+') tmp=(tmp+b[nw])%mod;\n\t\telse if(s[i]=='-') tmp=(tmp-b[nw]+mod)%mod;\n\t\telse if(s[i]=='>') nw++;\n\t\telse if(s[i]=='<') nw--;\n\t\t//ans+=p[(tmp+ed*b[nw-250000])%mod];\n\t\t//cout<<(tmp+ed*b[nw-250000])%mod<<\" \"<<tmp<<\" \"<<nw<<\" \"<<ans<<endl;\n\t\tp[tmp]--;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <iostream>\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define debug(x) cout<<#x<<\" :: \"<<x<<endl;\n#define debug2(x,y) cout<<#x<<\" :: \"<<x<<\"\\t\"<<#y<<\" :: \"<<y<<endl;\n#define debug3(x,y,z) cout<<#x<<\" :: \"<<x<<\"\\t\"<<#y<<\" :: \"<<y<<\"\\t\"<<#z<<\" :: \"<<z<<endl;\n\n#define boost ios::sync_with_stdio(0); cin.tie(0)\n\n#define fi first\n#define se second\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double ld;\ntypedef pair<int, int> pii;\n\nconst int X = 250000 + 5;\nconst int N = 1e6 + 5;\nconst ull B = 259;\null invB;\n\n/***************************************************************************/\n\null power(ull a, ull n) {\n\tif(n == 0) return 1;\n\tull p = power(a, n>>1);\n\tp = p * p;\n\tif(n & 1) p = p * a;\n\treturn p;\n}\n\nstring S;\null powB[N];\n\ninline ull& pow(int n) {\n\tif(n < 0) n += N;\n\treturn powB[n];\n}\n\ngp_hash_table<ull, int> M;\n\nint main() {\n\n\tboost;\n\tinvB = power(B, (ull(1)<<63)-1);\n\tassert(B * invB == 1);\n\n\tpow(0) = 1;\n\tfor(int i=1; i<X; i++) {\n\t\tpow(i) = pow(i-1) * B;\n\t\tpow(-i) = pow(-i+1) * invB;\n\t}\n\n\tint n; cin>>n;\n\tcin>>S;\n\n\tull phas = 0, chas = 0;\n\n\tint p = 0;\n\tfor(auto it : S) {\n\t\tif(it == '+') phas += pow(p);\n\t\telse if(it == '-') phas -= pow(p);\n\t\telse if(it == '>') p++;\n\t\telse p--;\n\t}\n\n\tll ans = 0;\n\tM[phas]++;\n\tp = 0;\n\n\tfor(auto it : S) {\n\t\tif(it == '+') chas += pow(p);\n\t\telse if(it == '-') chas -= pow(p);\n\t\telse if(it == '>') p++;\n\t\telse p--;\n\n\t\tans += M[chas];\n\t\tM[chas + pow(p) * phas]++;\n\t}\n\n\tcout<<ans<<\"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define fst first\n#define snd second\n#define SZ(u) ((int) (u).size())\n#define ALL(u) (u).begin(), (u).end()\n\ninline void proc_status()\n{\n    ifstream t(\"/proc/self/status\");\n    cerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline T read()\n{\n\tregister T sum(0), fg(1);\n\tregister char ch(getchar());\n\tfor(; !isdigit(ch); ch = getchar()) if(ch == '-') fg = -1;\n\tfor(;  isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) - '0' + ch;\n\treturn sum * fg;\n}\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int, int> pii;\n\nconst int MAXN = (int) 2.5e5;\n\nint n;\n\nchar s[MAXN + 5];\n\ninline void input()\n{\n\tn = read<int>();\n\tscanf(\"%s\", s + 1);\n}\n\nconst LL MOD = (1ll << 61) - 1, B = (int) 233;\n\ninline LL fpm(LL x, LL y)\n{\n\tLL res = 1;\n\tfor(; y; y >>= 1, x = (LL) x * x % MOD) if(y & 1) res = (LL) res * x % MOD;\n\treturn res;\n}\n\ninline void solve()\n{\n\t// Thanks to zhou888\n\n\tstatic LL p[MAXN + 5], prefix[MAXN + 5], p_pow[MAXN * 2 + 5];\n\n\tp_pow[0 + n] = 1;\n\tfor(int i = 1, invB = fpm(B, MOD - 2); i <= n; ++i)\n\t{\n\t\tp_pow[ i + n] = (LL) p_pow[ i - 1 + n] *\tB % MOD;\n\t\tp_pow[-i + n] = (LL) p_pow[-i + 1 + n] * invB % MOD;\n\t}\n\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tp[i] = p[i - 1], prefix[i] = prefix[i - 1];\n\t\tif(s[i] == '<') --p[i];\n\t\tif(s[i] == '>') ++p[i];\n\t\tif(s[i] == '+') (prefix[i] += p_pow[p[i] + n]) %= MOD;\n\t\tif(s[i] == '-') (prefix[i] -= p_pow[p[i] + n]) %= MOD;\n\t}\n\tfor(int i = 1; i <= n; ++i) (prefix[i] += MOD) %= MOD;\n\n\tstatic unordered_map<LL, int> cnt;\n\n\tLL ans = 0;\n\tfor(int i = 1; i <= n; ++i) ans += prefix[i] == prefix[n];\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tans += cnt[prefix[i]];\n\t\tLL res = (prefix[i] + (LL) p_pow[p[i] + n] * prefix[n] % MOD) % MOD;\n\t\t++cnt[res];\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main()\n{\n//\tfreopen(\"F.in\", \"r\", stdin);\n//\tfreopen(\"F.out\", \"w\", stdout);\n\n\tinput();\n\tsolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define LL long long\n#define N 600000\n\nconst LL mod1=998244353,mod2=353448299;\nLL n,B1,iB1,B2,iB2,ans,pw1[N],ipw1[N],h1[N],pw2[N],ipw2[N],h2[N],p[N];\nchar s[N];\nmap<LL,map<LL,LL> > mp;\n\nLL inv1(LL x){return x==1?1:(mod1-mod1/x)*inv1(mod1%x)%mod1;}\n\nLL inv2(LL x){return x==1?1:(mod2-mod2/x)*inv2(mod2%x)%mod2;}\n\nint main(){\n\tscanf(\"%lld%s\",&n,s+1);\n\tpw1[0]=ipw1[0]=1; iB1=inv1(B1=233);\n\tpw2[0]=ipw2[0]=1; iB2=inv2(B2=377);\n\tfor (LL i=1;i<=n*2;++i){\n\t\tpw1[i]=pw1[i-1]*B1%mod1;\n\t\tipw1[i]=ipw1[i-1]*iB1%mod1;\n\t\tpw2[i]=pw2[i-1]*B2%mod2;\n\t\tipw2[i]=ipw2[i-1]*iB2%mod2;\n\t}\n\tp[0]=n;\n\tfor (LL i=1;i<=n;++i){\n\t\tif (s[i]=='+'){\n\t\t\tp[i]=p[i-1];\n\t\t\th1[i]=(h1[i-1]+pw1[p[i]])%mod1;\n\t\t\th2[i]=(h2[i-1]+pw2[p[i]])%mod2;\n\t\t}\n\t\tif (s[i]=='-'){\n\t\t\tp[i]=p[i-1];\n\t\t\th1[i]=(h1[i-1]-pw1[p[i]]+mod1)%mod1;\n\t\t\th2[i]=(h2[i-1]-pw2[p[i]]+mod2)%mod2;\n\t\t}\n\t\tif (s[i]=='>'){\n\t\t\tp[i]=p[i-1]+1;\n\t\t\th1[i]=h1[i-1]; h2[i]=h2[i-1];\n\t\t}\n\t\tif (s[i]=='<'){\n\t\t\tp[i]=p[i-1]-1;\n\t\t\th1[i]=h1[i-1]; h2[i]=h2[i-1];\n\t\t}\n\t\t++mp[h1[i]][h2[i]];\n\t}\n\tfor (LL i=1;i<=n;++i){\n \t\tLL d=p[i-1]-p[0],t1=h1[n],t2=h2[n];\n\t\tif (d>=0){t1=t1*pw1[d]%mod1; t2=t2*pw2[d]%mod2;}\n\t\telse{t1=t1*ipw1[-d]%mod1; t2=t2*ipw2[-d]%mod2;}\n\t\tt1=(t1+h1[i-1]+mod1)%mod1; t2=(t2+h2[i-1]+mod2)%mod2;\n\t\tans+=mp[t1][t2];\n\t\t--mp[h1[i]][h2[i]];\n\t}\n\tprintf(\"%lld\\n\",ans);\n\t\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef unsigned long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nll mod, modInv;\nll pw(ll n, ll m){\n\tll res = 1;\n\tfor(; m; m /= 2){\n\t\tif(m & 1) res = res * n;\n\t\tn = n * n;\n\t}\n\treturn res;\n}\nmap<int, ll> h;\n\nvoid init(int n, ll mod_){\n\tmod = mod_;\n\tmodInv = pw(mod, -1);\n\th.clear();\n\th[0] = 1;\n\tll x = 1, y = 1;\n\tfor(int i = 1; i <= n; i++){\n\t\tx *= mod;\n\t\ty *= modInv;\n\t\th[i] = x;\n\t\th[-i] = y;\n\t}\n}\n\nll solve(int n, string s, ll mod){\n\tinit(n, mod);\n\tint p = 0;\n\tll hash = 0;\n\tfor(char c : s){\n\t\tif(c == '<') p--;\n\t\tif(c == '>') p++;\n\t\tif(c == '+') hash += h[p];\n\t\tif(c == '-') hash -= h[p];\n\t}\n\t\n\tint p2 = p;\n\tll h2 = 0;\n\tmap<ll, vi> pos;\n\tfor(int i = n; i >= 0; i--){\n\t\tif(i < n){\n\t\t\tchar c = s[i];\n\t\t\tif(c == '<') p2++;\n\t\t\tif(c == '>') p2--;\n\t\t\tif(c == '+') h2 -= h[p2];\n\t\t\tif(c == '-') h2 += h[p2];\n\t\t}\n\t\tpos[h2].pb(i);\n\t}\n\tfor(auto &i: pos) reverse(all(i.second));\n\t\n\tint p3 = p;\n\tll h3 = hash;\n\tll ans = 0;\n\trep(i, n){\n\t\tll diff = (hash - h3) * h[p - p3];\n\t\tif(pos.count(diff)){\n\t\t\tans += pos[diff].end() - upper_bound(all(pos[diff]), i);\n\t\t}\n\t\t\n\t\tchar c = s[i];\n\t\tif(c == '<') p3++, h3 *= mod;\n\t\tif(c == '>') p3--, h3 *= modInv;\n\t\tif(c == '+') h3--;\n\t\tif(c == '-') h3++;\n\t}\n\treturn ans;\n}\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\t\n\tint n; string s; cin >> n >> s; assert(n > 5);\n\tmap<ll,int> ans;\n\tvector<ll> mods;\n\tfor(ll p = 1e9 + 1; mods.size() < 10; p += 2){\n\t\tfor(ll i = 3; i * i <= p; i += 2) if(p % i == 0) goto NG;\n\t\tmods.pb(p); NG:;\n\t}\n\tfor(ll mod : mods) ++ans[solve(n, s, mod)];\n\t\n\tint mxc = 0; ll res = 0;\n\tfor(auto i : ans) if(i.second > mxc) mxc = i.second, res = i.first;\n\tcout << res << endl;\n\t\n\t//dbg(ans, mods);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=(0);i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n \ntemplate<class T> inline void read(T &x){\n\tint f=0;x=0;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar())f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar())x=x*10+ch-'0';\n\tif(f)x=-x;\n}\n\nconst int N=500005;\nnamespace{\n\tconst int mod[2]={19260817,998244353};\n\tint p[N][2],rp[N][2];\n\tint power(int x,int t){\n\t\treturn x>=0?p[x][t]:rp[x][t];\n\t}\n\tint power(int x,int p,int mod){\n\t\tint res=1;\n\t\tfor(;p;p>>=1,x=(ll)x*x%mod)\n\t\t\tif(p&1)res=(ll)res*x%mod;\n\t\treturn res;\n\t}\n\tvoid init(int n){\n\t\tint A=2333,B=power(A,mod[0]-2,mod[0]);\n\t\tint C=19260817,D=power(C,mod[1]-2,mod[1]);\n\t\tp[0][0]=p[0][1]=rp[0][0]=rp[0][1]=1;\n\t\trep(i,1,n){\n\t\t\tp[i][0]=(ll)p[i-1][0]*A%mod[0];\n\t\t\trp[i][0]=(ll)rp[i-1][0]*B%mod[0];\n\t\t\tp[i][1]=(ll)p[i-1][1]*C%mod[1];\n\t\t\trp[i][1]=(ll)rp[i-1][1]*D%mod[1];\n\t\t}\n\t}\n}\n\nint v[N][2],d[N],n;\nmap<pii,int> cnt;\nchar s[N];\nll ans;\n\nint main(){\n\tread(n),init(n);\n\tscanf(\"%s\",s+1);\n\trep(i,1,n){\n\t\tv[i][0]=v[i-1][0];\n\t\tv[i][1]=v[i-1][1];\n\t\td[i]=d[i-1];\n\t\tif(s[i]=='<')d[i]--;\n\t\telse if(s[i]=='>')d[i]++;\n\t\telse if(s[i]=='+')\n\t\t\tREP(t,2)v[i][t]=(v[i][t]+power(d[i],t))%mod[t];\n\t\telse\n\t\t\tREP(t,2)v[i][t]=(v[i][t]+mod[t]-power(d[i],t))%mod[t];\n\t}\n\tper(i,n-1,0){\n\t\tcnt[mp(v[i+1][0],v[i+1][1])]++;\n\t\tint A=(v[i][0]+(ll)power(d[i],0)*v[n][0])%mod[0];\n\t\tint B=(v[i][1]+(ll)power(d[i],1)*v[n][1])%mod[1];\n\t\tans+=cnt[mp(A,B)];\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define llu unsigned long long\n#define ld double\n#define llu unsigned long long\n#define rep(i,x,y)  for(ll i=x;i<y;++i)\n#define For(i,x,y)  for(ll i=x;i<=y;++i)\n#define FOr(i,x,y)  for(ll i=x;i>=y;--i)\n#define pi acos(-1)\n#define mk make_pair<ll,ll>\n#define pa pair<ll,ll>\n#define lf else if\n#define min(x,y)    ((x)<(y)?(x):(y))\n#define sqr(x)      ((x)*(x))\n#define abs(x)      ((x)>0?(x):-(x))\n#define Mul(x,y)    (x=(x)*(y)%mod)\n#define Add(x,y)    (x=(x+(y))%mod)\n#define E(x)        return writeln(x),0\n#define p(x)        printf(\"~%d~\\n\",x)\n#define pp(x,y)     printf(\"~~%d %d~~\\n\",x,y)\n#define ppp(x,y,z)  printf(\"~~~%d %d %d~~~\\n\",x,y,z)\n#define pppp(x,y,z,a)  printf(\"~~~%d %d %d %d~~~\\n\",x,y,z,a)\n#define f_in(x)     freopen(x\".in\",\"r\",stdin)\n#define f_out(x)    freopen(x\".out\",\"w\",stdout)\n#define open(x)     f_in(x),f_out(x)\n#define fi first\n#define se second\ntypedef complex<double> E;\nnamespace SHENZHEBEI{\n#ifdef LOCAL\n    struct _{_(){freopen(\"cf.in\",\"r\",stdin);}}_;\n#endif\n#define NEG 1\n    inline char gc(){   return getchar();   }\n#if NEG\n    inline ll read(){    ll x=0,f=1; char ch=gc();   for (;!isdigit(ch);ch=gc()) if (ch=='-') f=-1;  for (;isdigit(ch);ch=gc())  x=x*10-48+ch;   return x*f; }\n    inline void write(ll x){    if (x<0) putchar('-'),x=-x;  if (x>=10)   write(x/10);    putchar(x%10+'0');  }\n#else\n    inline ll read(){    ll x=0; char ch=gc();   for (;!isdigit(ch);ch=gc());    for (;isdigit(ch);ch=gc())  x=x*10-48+ch;   return x;   }\n    inline void write(ll x){    if (x>=10)   write(x/10);    putchar(x%10+'0');  }\n#endif\n    inline char readchar(){ char ch=gc();   for(;isspace(ch);ch=gc());  return ch;  }\n    inline ll readstr(char *s){ char ch=gc();   int cur=0;  for(;isspace(ch);ch=gc());      for(;!isspace(ch);ch=gc())  s[cur++]=ch;    s[cur]='\\0';    return cur; }\n    inline void writeln(ll x){  write(x);   puts(\"\");   }\n    inline ld getreal(){    static ld lbc;  scanf(\"%lf\",&lbc);  return lbc; }\n}using namespace SHENZHEBEI;\nconst ll N=1200000,mod=1e9+7,bas=233333;\nmap<ll,ll>mp;\nchar s[N];\nll sum[N],bin[N],Inv[N],now[N],Pos[N],n,Inv_bas,answ,start;\nll ppow(ll x,ll k){\n\tll ans=1;\n\tfor(;k;k>>=1,Mul(x,x))if (k&1)Mul(ans,x);\n\treturn ans;\n}\nll Query(ll l,ll r){\n\tmemset(sum,0,sizeof sum);\n\tll pos=2*n,zt=0;\n\tFor(i,l,r){\n\t\tif (s[i]=='+')++sum[pos];\n\t\tlf (s[i]=='-')--sum[pos];\n\t\tlf (s[i]=='>')\t++pos;\n\t\telse\t\t\t--pos;\n\t}\n\tFor(i,1,3*n)Add(zt,sum[i]*bin[i])%mod;\n\tAdd(zt,mod);\n\treturn zt;\n}\nvoid cdq(ll l,ll r){\n\tif (l>r)return ;\n\tif (l==r){\n\t\tif (s[l]=='+')answ+=bin[2*n]==start;\n\t\tlf (s[l]=='-')answ+=(mod-bin[2*n])%mod==start;\n\t\treturn ;\n\t}\n\tmp.clear();\n\tll mid=(l+r)>>1,ans=0,pos=2*n;\n\tFOr(i,mid,l){\n\t\tif (s[i]=='+')ans+=bin[pos];\n\t\tlf (s[i]=='-')ans-=bin[pos];\n\t\tlf (s[i]=='>')\t--pos;\n\t\telse\t\t\t++pos;\n\t\tif (pos<2*n)now[i]=ans*bin[2*n-pos]%mod,Pos[i]=Inv[2*n-pos];\n\t\telse\t\tnow[i]=ans*Inv[pos-2*n]%mod,Pos[i]=bin[pos-2*n];\n\t}\n\tpos=2*n;++mp[0];ans=0;\n\tFor(i,mid+1,r){\n\t\tif (s[i]=='+')ans+=bin[pos];\n\t\tlf (s[i]=='-')ans-=bin[pos];\n\t\tlf (s[i]=='>')\t++pos;\n\t\telse\t\t\t--pos;\n\t\tAdd(ans,mod);\n\t\tif (pos<2*n)++mp[ans];\n\t\telse\t\t++mp[ans];\n\t}\n//\twriteln(Query(1,3)*);\n\tFor(i,l,mid){\n\t\tansw+=mp[((start-now[i])*Pos[i]%mod+mod)%mod];\n\t}\n\tcdq(l,mid-1);\tcdq(mid+1,r);\n}\nint main(){\n\tn=read();readstr(s+1);Inv_bas=ppow(bas,mod-2);\n\tbin[0]=1;For(i,1,4*n)bin[i]=bin[i-1]*bas%mod;\n\tInv[0]=1;For(i,1,4*n)Inv[i]=Inv[i-1]*Inv_bas%mod;\n\tstart=Query(1,n);\n\tcdq(1,n);\n\twriteln(answ);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// template {{{\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#define f first\n#define s second\n#define resz resize\n\n#define sz(x) int((x).size())\n#define all(x) (x).begin(), (x).end()\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i, a, b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i, a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define sort_by(x, y) sort(all(x), [&](const auto& a, const auto& b) { return y; })\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vd = vector<double>;\nusing vs = vector<string>;\n\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pdd = pair<double, double>;\n\nusing vpii = vector<pii>;\nusing vvpii = vector<vpii>;\nusing vpll = vector<pll>;\nusing vvpll = vector<vpll>;\nusing vpdd = vector<pdd>;\nusing vvpdd = vector<vpdd>;\n\ntemplate<typename T> void ckmin(T& a, const T& b) { a = min(a, b); }\ntemplate<typename T> void ckmax(T& a, const T& b) { a = max(a, b); }\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nnamespace __input {\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {\n        re(first); re(rest...);\n    }\n\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\nusing namespace __input;\n\nnamespace __output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {\n        pr(first); pr(rest...);\n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) {\n        pr(\"{\",x.f,\", \",x.s,\"}\");\n    }\n    template<class T, bool pretty = true> void prContain(const T& x) {\n        if (pretty) pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?pretty?\", \":\" \":\"\",a), fst = 0;\n        if (pretty) pr(\"}\");\n    }\n    template<class T> void pc(const T& x) { prContain<T, false>(x); pr(\"\\n\"); }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n\n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) {\n        pr(first); ps();\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {\n        pr(first,\" \"); ps(rest...);\n    }\n}\nusing namespace __output;\n\n#define TRACE(x) x\n#define __pn(x) pr(#x, \" = \")\n#define pd(...) __pn((__VA_ARGS__)), ps(__VA_ARGS__), cout << flush\n\nnamespace __algorithm {\n    template<typename T> void dedup(vector<T>& v) {\n        sort(all(v)); v.erase(unique(all(v)), v.end());\n    }\n    template<typename T> typename vector<T>::iterator find(vector<T>& v, const T& x) {\n        auto it = lower_bound(all(v), x); return it != v.end() && *it == x ? it : v.end();\n    }\n    template<typename T> size_t index(vector<T>& v, const T& x) {\n        auto it = find(v, x); assert(it != v.end() && *it == x); return it - v.begin();\n    }\n}\nusing namespace __algorithm;\n\nstruct monostate {\n    friend istream& operator>>(istream& is, const __attribute__((unused))monostate& ms) { return is; }\n    friend ostream& operator<<(ostream& os, const __attribute__((unused))monostate& ms) { return os; }\n} ms;\n\ntemplate<typename W=monostate> struct wedge {\n    int u, v, i; W w;\n    wedge<W>(int _u=-1, int _v=-1, int _i=-1) : u(_u), v(_v), i(_i) {}\n    int operator[](int loc) const { return u ^ v ^ loc; }\n    friend void re(wedge& e) { re(e.u, e.v, e.w); --e.u, --e.v; }\n    friend void pr(const wedge& e) { pr(e.u, \"<-\", e.w, \"->\", e.v); }\n};\n\nnamespace __io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0);\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); }\n    }\n}\nusing namespace __io;\n// }}}\n\n// modnum {{{\ntemplate<int MOD> struct modnum {\n    int v;\n    modnum() : v(0) {}\n    modnum(ll _v) : v(_v % MOD) { if (v < 0) v += MOD; }\n    explicit operator int() const { return v; }\n    friend istream& operator >> (istream& i, modnum& n) { ll w; i >> w; n = modnum(w); return i; }\n    friend ostream& operator << (ostream& o, const modnum& n) { return o << n.v; }\n\n    friend bool operator < (const modnum& a, const modnum& b) { return a.v < b.v; }\n    friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n    friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n    modnum& operator += (const modnum& o) { v += o.v; if (v >= MOD) v -= MOD; return *this; }\n    modnum& operator -= (const modnum& o) { v -= o.v; if (v < 0) v += MOD; return *this; }\n    modnum& operator *= (const modnum& o) { v = int(ll(v) * ll(o.v) % MOD); return *this; }\n    modnum operator - () { modnum res; if (v) res.v = MOD - v; return res; }\n    friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n    friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n    friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\n    modnum pow(ll e) const {\n        if (e < 0) return 1 / this->pow(-e);\n        if (e == 0) return 1;\n        if (e & 1) return *this * this->pow(e-1);\n        return (*this * *this).pow(e/2);\n    }\n\n    modnum inv() const {\n        int g = MOD, x = 0, y = 1;\n        for (int r = v; r != 0; ) {\n            int q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n\n        assert(g == 1);\n        assert(y == MOD || y == -MOD);\n        return x < 0 ? x + MOD : x;\n    }\n    modnum& operator /= (const modnum& o) { return (*this) *= o.inv(); }\n    friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= modnum(b); }\n\n    static int totient() {\n        int tot = MOD, tmp = MOD;\n        for (int p = 2; p * p <= tmp; p++) if (tmp % p == 0) {\n            tot = tot / p * (p - 1);\n            while (tmp % p == 0) tmp /= p;\n        }\n        if (tmp > 1) tot = tot / tmp * (tmp - 1);\n        return tot;\n    }\n\n    static int primitive_root() {\n        if (MOD == 1) return 0;\n        if (MOD == 2) return 1;\n\n        int tot = totient(), tmp = tot;\n        vi tot_pr;\n        for (int p = 2; p * p <= tmp; p++) if (tot % p == 0) {\n            tot_pr.push_back(p);\n            while (tmp % p == 0) tmp /= p;\n        }\n        if (tmp > 1) tot_pr.push_back(tmp);\n\n        for (int r = 2; r < MOD; r++) if (__gcd(r, MOD) == 1) {\n            bool root = true;\n            for (int p : tot_pr) root &= modnum(r).pow(tot / p) != 1;\n            if (root) return r;\n        }\n        assert(false);\n    }\n\n    static modnum generator() { static modnum g = primitive_root(); return g; }\n    static int discrete_log(modnum v) {\n        static const int M = ceil(sqrt(MOD));\n        static unordered_map<int, int> table;\n        if (table.empty()) {\n            modnum e = 1;\n            for (int i = 0; i < M; i++) { table[e.v] = i; e *= generator(); }\n        }\n        static modnum f = generator().pow(totient() - M);\n\n        for (int i = 0; i < M; i++) {\n            if (table.count(v.v)) return table[v.v] + i * M;\n            v *= f;\n        }\n        assert(false);\n    }\n\n    static modnum unity_root(int deg) {\n        assert(totient() % deg == 0);\n        return generator().pow(totient() / deg);\n    }\n\n    static modnum fact(int n) {\n        static vector<modnum> fact = { 1 };\n        for (assert(n >= 0); fact.size() <= n; )\n            fact.push_back(fact.back() * fact.size());\n        return fact[n];\n    }\n\n    static modnum finv(int n) {\n        static vector<modnum> finv = { 1 };\n        for (assert(n >= 0); finv.size() <= n; )\n            finv.push_back(finv.back() / finv.size());\n        return finv[n];\n    }\n\n    static modnum ncr(int n, int r) {\n        assert(n >= 0);\n        if (r < 0 || n < r) return 0;\n        return fact(n) * finv(r) * finv(n - r);\n    }\n};\n// }}}\nusing mn = modnum<int(1e9 + 7)>;\nusing vmn = vector<mn>;\nusing vvmn = vector<vmn>;\n\nconst int B = 6, MAXV = 2 * 250001;\nconst array<mn, B> bases = { 69, 420, 42069, 6969, 696969 };\nusing state = array<array<mn, 2>, 6>;\n\nstate IDENTITY, LSHIFT, RSHIFT, INCR, DECR;\n\nvoid init() {\n    F0R (b, B) {\n        IDENTITY[b] = {1,0};\n        LSHIFT[b] = {bases[b]+MAXV, 0};\n        RSHIFT[b] = {1/(bases[b]+MAXV), 0};\n        INCR[b] = {1,1};\n        DECR[b] = {1,-1};\n    }\n}\nconst state& op(char c) {\n    return c=='<' ? LSHIFT : c=='>' ? RSHIFT : c=='+' ? INCR : DECR;\n}\nconst state& inv(char c) {\n    return c=='<' ? RSHIFT : c=='>' ? LSHIFT : c=='+' ? DECR : INCR;\n}\n\nstate compose(const state& f, const state& g) {\n    state fog;\n    F0R (b, B) fog[b] = {\n        f[b][0] * g[b][0],\n        f[b][1] + f[b][0] * g[b][1]\n    };\n    return fog;\n}\n\nint main() {\n    setIO();\n    init();\n\n    int N; re(N); string S; re(S);\n\n    vector<state> suff(N + 1);\n    suff[N] = IDENTITY;\n    F0Rd (i, N) suff[i] = compose(op(S[i]), suff[i+1]);\n\n    vector<state> sinv(N + 1);\n    sinv[N] = IDENTITY;\n    F0Rd (i, N) sinv[i] = compose(sinv[i+1], inv(S[i]));\n\n    ll ans = 0;\n    map<vmn, int> ct;\n\n    F0Rd (i, N) {\n        vmn tg(B);\n        F0R (b, B) tg[b] = sinv[i+1][b][1];\n        ++ct[tg];\n\n        vmn lk(B);\n        F0R (b, B) lk[b] = (suff[0][b][1] - suff[i][b][1]) / suff[i][b][0];\n        ans += ct[lk];\n    }\n\n    ps(ans);\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\n\nconst int mod0 = 1e9 + 7;\nconst int mod1 = 1e9 + 9;\nconst int mod2 = 1e9 + 21;\nconst int base = 10007;\n\nint64_t power(int64_t x, int64_t n, int64_t mod) {\n  int64_t ret = 1;\n  while(n > 0) {\n    if(n & 1) (ret *= x) %= mod;\n    (x *= x) %= mod;\n    n >>= 1;\n  }\n  return ret;\n}\n\n\nint64 h0[550001], g0[550001];\nint64 h1[550001], g1[550001];\nint64 h2[550001], g2[550001];\n\n\nint main() {\n\n  h0[0] = h1[0] = h2[0] = 1;\n  for(int i = 1; i < 550001; i++) {\n    h0[i] = h0[i - 1] * base % mod0;\n    h1[i] = h1[i - 1] * base % mod1;\n    h2[i] = h2[i - 1] * base % mod2;\n  }\n  g0[550000] = power(h0[550000], mod0 - 2, mod0);\n  g1[550000] = power(h1[550000], mod1 - 2, mod1);\n  g2[550000] = power(h2[550000], mod2 - 2, mod2);\n  for(int i = 549999; i >= 0; i--) {\n    g0[i] = g0[i + 1] * (i + 1) % mod0;\n    g1[i] = g1[i + 1] * (i + 1) % mod1;\n    g2[i] = g2[i + 1] * (i + 1) % mod2;\n  }\n\n  int N;\n  string S;\n\n  cin >> N;\n  cin >> S;\n\n  vector< int64 > latte0, malta0;\n  vector< int64 > latte1, malta1;\n  vector< int64 > latte2, malta2;\n  int64 beet = 0, pos = 250001;\n  latte0.push_back(pos), malta0.push_back(beet);\n  latte1.push_back(pos), malta1.push_back(beet);\n  latte2.push_back(pos), malta2.push_back(beet);\n  for(int i = 0; i < N; i++) {\n    char c = S[i];\n    if(c == '+') (beet += h0[pos]) %= mod0;\n    else if(c == '-') (beet += mod0 - h0[pos]) %= mod0;\n    else if(c == '<') --pos;\n    else ++pos;\n    latte0.push_back(pos), malta0.push_back(beet);\n  }\n  beet = 0, pos = 250001;\n  for(int i = 0; i < N; i++) {\n    char c = S[i];\n    if(c == '+') (beet += h1[pos]) %= mod1;\n    else if(c == '-') (beet += mod1 - h1[pos]) %= mod1;\n    else if(c == '<') --pos;\n    else ++pos;\n    latte1.push_back(pos), malta1.push_back(beet);\n  }\n  beet = 0, pos = 250001;\n\n  for(int i = 0; i < N; i++) {\n    char c = S[i];\n    if(c == '+') (beet += h2[pos]) %= mod2;\n    else if(c == '-') (beet += mod2 - h2[pos]) %= mod2;\n    else if(c == '<') --pos;\n    else ++pos;\n    latte2.push_back(pos), malta2.push_back(beet);\n  }\n\n\n  map< tuple< int64, int64, int64 >, int > mp;\n  int64 ret = 0;\n  for(int i = N; i >= 0; i--) {\n    int64 dx = latte0[i] - latte0[0];\n    int64 mul0, mul1, mul2;\n    if(dx >= 0) mul0 = h0[dx], mul1 = h1[dx], mul2 = h2[dx];\n    else mul0 = power(h0[-dx], mod0 - 2, mod0), mul1 = power(h1[-dx], mod1 - 2, mod1), mul2 = power(h2[-dx], mod2 - 2, mod2);\n    ret += mp[make_tuple((malta0[i] + malta0[N] * mul0) % mod0, (malta1[i] + malta1[N] * mul1) % mod1, (malta2[i] + malta2[N] * mul2) % mod2)];\n    ++mp[make_tuple(malta0[i], malta1[i], malta2[i])];\n  }\n  cout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<map>\nusing namespace std;\ntypedef long long ll;\nconst int mod=998244353,b=1000000007,rb=993328907;\nint mul(int a,int b){return a*(ll)b%mod;}\nint ad(int a,int b){return(a+b)%mod;}\nint pow(int a,int b){\n\tint s=1;\n\twhile(b){\n\t\tif(b&1)s=mul(s,a);\n\t\ta=mul(a,a);\n\t\tb>>=1;\n\t}\n\treturn s;\n}\nchar s[250010];\nint p[250010],st[250010];\nmap<int,int>m;\nint main(){\n\tint n,i;\n\tll ans;\n\tscanf(\"%d%s\",&n,s+1);\n\tp[0]=1;\n\tfor(i=1;i<=n;i++){\n\t\tp[i]=p[i-1];\n\t\tst[i]=st[i-1];\n\t\tswitch(s[i]){\n\t\t\tcase'+':st[i]=ad(st[i],p[i]);break;\n\t\t\tcase'-':st[i]=ad(st[i],mod-p[i]);break;\n\t\t\tcase'>':p[i]=mul(p[i],b);break;\n\t\t\tcase'<':p[i]=mul(p[i],rb);break;\n\t\t}\n\t}\n\tans=0;\n\tfor(i=n;i>0;i--){\n\t\tm[st[i]]++;\n\t\tans+=m[ad(mul(st[n],p[i-1]),st[i-1])];\n\t}\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "//ΔARC099F\n#include<iostream>\n#include<cstdio>\n#include<fstream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<bitset>\n#include<cmath>\n#include<cstring>\n#include<cstdlib>\nusing namespace std;\ntypedef long long LL;\ntypedef double DB;\nconst int N = 266666;\nconst int B = 19260817;\nconst int MO = 1e9+21;\nint fpow(int x,int y=MO-2){\n\tif(!y)\n\t\treturn 1;\n\tLL z=fpow(x,y>>1);\n\tz=z*z%MO;\n\tif(y&1)\n\t\tz=z*x%MO;\n\treturn z;\n}\nint invB=fpow(B);\nchar ch[N];\nint n,a[N],f[N],g[N];\nmap<int,int> M;\nint main()\n{\n\tint i,x,y;\n\tLL ans=0;\n\tcin>>n;\n\tscanf(\"%s\",ch+1);\n\tfor(i=1;i<=n;i=i+1){\n\t\tif(ch[i]=='-')\n\t\t\ta[i]=0;\n\t\tif(ch[i]=='+')\n\t\t\ta[i]=1;\n\t\tif(ch[i]=='<')\n\t\t\ta[i]=2;\n\t\tif(ch[i]=='>')\n\t\t\ta[i]=3;\n\t}\n\tx=0;\n\tfor(i=n;i;i=i-1){\n\t\tif(a[i]==0)\n\t\t\tx=(x-1+MO)%MO;\n\t\tif(a[i]==1)\n\t\t\tx=(x+1)%MO;\n\t\tif(a[i]==2)\n\t\t\tx=(LL)x*invB%MO;\n\t\tif(a[i]==3)\n\t\t\tx=(LL)x*B%MO;\n\t\tf[i]=x;\n\t}\n\tx=0,y=1;\n\tM[0]++;\n\tfor(i=n;i;i=i-1){\n\t\tif(a[i]==0)\n\t\t\tx=(x+y)%MO;\n\t\tif(a[i]==1)\n\t\t\tx=(x-y+MO)%MO;\n\t\tif(a[i]==2)\n\t\t\ty=(LL)y*B%MO;\n\t\tif(a[i]==3)\n\t\t\ty=(LL)y*invB%MO;\n\t\tg[i]=x;\n\t\tM[x]++;\n\t}\n\tfor(i=1;i<=n;i=i+1){\n\t\tM[g[i]]--;\n\t\tx=(f[1]-f[i]+MO)%MO;\n\t\tx=(LL)x*y%MO;\n\t\tans+=M[x];\n\t\tif(((LL)f[i]*y%MO+g[i])%MO)\n\t\t\tcout<<1/0;\n\t\tif(a[i]==2)\n\t\t\ty=(LL)y*invB%MO;\n\t\tif(a[i]==3)\n\t\t\ty=(LL)y*B%MO;\n\t}\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define fst first\n#define snd second\n#define SZ(u) ((int) (u).size())\n#define ALL(u) (u).begin(), (u).end()\n\ninline void proc_status()\n{\n    ifstream t(\"/proc/self/status\");\n    cerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline T read()\n{\n\tregister T sum(0), fg(1);\n\tregister char ch(getchar());\n\tfor(; !isdigit(ch); ch = getchar()) if(ch == '-') fg = -1;\n\tfor(;  isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) - '0' + ch;\n\treturn sum * fg;\n}\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int, int> pii;\n\nconst int MAXN = (int) 2.5e5;\n\nint n;\n\nchar s[MAXN + 5];\n\ninline void input()\n{\n\tn = read<int>();\n\tscanf(\"%s\", s + 1);\n}\n\nconst LL MOD = (1ll << 60) - 1, B = (int) 233;\n\ninline LL fpm(LL x, LL y)\n{\n\tLL res = 1;\n\tfor(; y; y >>= 1, x = (LL) x * x % MOD) if(y & 1) res = (LL) res * x % MOD;\n\treturn res;\n}\n\ninline void solve()\n{\n\t// Thanks to zhou888\n\n\tstatic LL p[MAXN + 5], prefix[MAXN + 5], p_pow[MAXN * 2 + 5];\n\n\tp_pow[0 + n] = 1;\n\tfor(int i = 1, invB = fpm(B, MOD - 2); i <= n; ++i)\n\t{\n\t\tp_pow[ i + n] = (LL) p_pow[ i - 1 + n] *\tB % MOD;\n\t\tp_pow[-i + n] = (LL) p_pow[-i + 1 + n] * invB % MOD;\n\t}\n\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tp[i] = p[i - 1], prefix[i] = prefix[i - 1];\n\t\tif(s[i] == '<') --p[i];\n\t\tif(s[i] == '>') ++p[i];\n\t\tif(s[i] == '+') (prefix[i] += p_pow[p[i] + n]) %= MOD;\n\t\tif(s[i] == '-') (prefix[i] -= p_pow[p[i] + n]) %= MOD;\n\t}\n\tfor(int i = 1; i <= n; ++i) (prefix[i] += MOD) %= MOD;\n\n\tstatic unordered_map<LL, int> cnt;\n\n\tLL ans = 0;\n\tfor(int i = 1; i <= n; ++i) ans += prefix[i] == prefix[n];\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tans += cnt[prefix[i]];\n\t\tLL res = (prefix[i] + (LL) p_pow[p[i] + n] * prefix[n] % MOD) % MOD;\n\t\t++cnt[res];\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main()\n{\n//\tfreopen(\"F.in\", \"r\", stdin);\n//\tfreopen(\"F.out\", \"w\", stdout);\n\n\tinput();\n\tsolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fo(i, x, y) for(int i = x, B = y; i <= B; i ++)\n#define ff(i, x, y) for(int i = x, B = y; i <  B; i ++)\n#define fd(i, x, y) for(int i = x, B = y; i >= B; i --)\n#define ll long long\n#define pp printf\n#define hh pp(\"\\n\")\nusing namespace std;\n\nconst ll mo = 23333333333333333;\n\nll mul(ll x, ll y) {\n\tx %= mo, y %= mo;\n\tll z = (long double) x * y / mo;\n\tz = x * y - z * mo;\n\tif(z < 0) z += mo; else if(z >= mo) z -= mo;\n\treturn z;\n}\n\nll ksm(ll x, ll y) {\n\tll s = 1;\n\tfor(; y; y /= 2, x = mul(x, x))\n\t\tif(y & 1) s = mul(s, x);\n\treturn s;\n}\n\nconst ll w = 1e9 + 7;\n\nconst int N = 250005;\n\nll aw[N * 2], v[N * 2];\nint n; char s[N];\n\nmap<ll, int> cnt;\n\nll ans;\n\nint main() {\n\tscanf(\"%d\", &n);\n\tscanf(\"%s\", s + 1);\n\taw[0] = 1; fo(i, 1, n * 2) aw[i] = mul(aw[i - 1], w);\n\tv[0] = ksm(ksm(w, mo - 2), n); fo(i, 1, n * 2) v[i] = mul(v[i - 1], w);\n\tll p = n, sum = 0;\n\tfo(i, 1, n) {\n\t\tif(s[i] == '<') {\n\t\t\tp --;\n\t\t}\n\t\tif(s[i] == '>') {\n\t\t\tp ++;\n\t\t}\n\t\tif(s[i] == '+') {\n\t\t\tsum = (sum + aw[p]) % mo;\n\t\t}\n\t\tif(s[i] == '-') {\n\t\t\tsum = (sum - aw[p] + mo) % mo;\n\t\t}\n\t}\n\tll eds = sum;\n\tp = n, sum = 0;\n\tcnt[(mul(eds, v[p]) + sum) % mo] ++;\n\tfo(i, 1, n) {\n\t\tif(s[i] == '<') {\n\t\t\tp --;\n\t\t}\n\t\tif(s[i] == '>') {\n\t\t\tp ++;\n\t\t}\n\t\tif(s[i] == '+') {\n\t\t\tsum = (sum + aw[p]) % mo;\n\t\t}\n\t\tif(s[i] == '-') {\n\t\t\tsum = (sum - aw[p] + mo) % mo;\n\t\t}\n\t\tans += cnt[sum];\n\t\tcnt[(mul(eds, v[p]) + sum) % mo] ++;\n\t}\n\tpp(\"%lld\\n\", ans);\n\n}"
  },
  {
    "language": "C++",
    "code": "// No.190049041520\n#include <bits/stdc++.h>\nusing namespace std;\n#define pii pair<int, int>\n#define mk make_pair\n#define fi first\n#define se second\n#define N 500500\nconst int b1 = 7546823, m1 = 277425539;\nconst int b2 = 1000033, m2 = 277444379;\n\ninline void inc(int &x, const int &y, const int &Mod) {\n    x = (x + y) % Mod;\n}\n\ninline int fsp(int x, int k, int p) {\n    if (k < 0) k += p - 1;\n    int res = 1;\n    while (k) {\n        if (k & 1) res = 1ll * res * x % p;\n        x = 1ll * x * x % p, k >>= 1;\n    }\n    return res;\n}\n\nint n, po1[N], po2[N];\nchar s[N];\npii h[N];\nmap<pii, int> num;\n\nint main() {\n#ifdef isLOCAL\n    freopen(\".in\", \"r\", stdin);\n    freopen(\".out\", \"w\", stdout);\n#endif\n\n    cin >> n;\n    scanf(\"%s\", s + 1);\n\n    int p1 = po1[0] = 1, p2 = po2[0] = 1, c1 = 0, c2 = 0, i1, i2;\n    i1 = fsp(b1, -1, m1), i2 = fsp(b2, -1, m2);\n    for (int i = 1; i <= n; ++i) {\n        if (s[i] == '+') inc(c1, p1, m1), inc(c2, p2, m2);\n        if (s[i] == '-') inc(c1, m1 - p1, m1), inc(c2, m2 - p2, m2);\n        if (s[i] == '<') p1 = 1ll * p1 * i1 % m1, p2 = 1ll * p2 * i2 % m2;\n        if (s[i] == '>') p1 = 1ll * p1 * b1 % m1, p2 = 1ll * p2 * b2 % m2;\n        if (c1 < 0) c1 += m1;\n        if (c2 < 0) c2 += m2;\n        po1[i] = p1, po2[i] = p2;\n        h[i] = mk(c1, c2);\n    }\n\n    long long ans = 0; ++num[h[n]];\n    for (int i = n - 1, tc1, tc2; i >= 0; --i) {\n        tc1 = (h[i].fi + 1ll * po1[i] * h[n].fi) % m1;\n        tc2 = (h[i].se + 1ll * po2[i] * h[n].se) % m2;\n        ans += num[mk(tc1, tc2)], ++num[h[i]];\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define dbg1(x) cerr<<#x<<\"=\"<<(x)<<\" \"\n#define dbg2(x) cerr<<#x<<\"=\"<<(x)<<\"\\n\"\n#define dbg3(x) cerr<<#x<<\"\\n\"\nusing namespace std;\n#define reg register\nconst int MN=2e5+5;\nint N;\nchar s[MN];\nconst int P=998244353;\nint Add(int x,int y){return (x+y)%P;}\nint Mul(int x,int y){return (1ll*x*y)%P;}\nconst int B[]={691,769,823,877,911,967},\ninv[]={37560569,983965175,992179685,349442436,115055606,356147158};\nstruct node\n{\n\tint v[6];\n\tint& operator [](int x){return v[x];}\n\tbool operator <(const node o)const\n\t{\n\t\tfor(int i=0;i<6;++i)if(v[i]!=o.v[i])return v[i]<o.v[i];\n\t\treturn false;\n\t}\n\tbool operator ==(const node o)const\n\t{\n\t\tfor(int i=0;i<6;++i)if(v[i]!=o.v[i])return false;\n\t\treturn true;\n\t}\n}pre[MN],all;\nstd::map<node,int> Mp;\nint pos[MN],nm[6][MN<<1],cal[MN];\nnode get(node x,node y,int p)\n{\n\tfor(int j=0;j<6;++j)\n\t\tx[j]=Add(x[j],Mul(y[j],nm[j][p]));\n\treturn x;\n}\nint main()\n{\n\tscanf(\"%d%s\",&N,s+1);\n\treg int i,j,k;\n\tfor(j=0;j<6;++j)for(nm[j][MN]=i=1;i<=N;++i)\n\t\tnm[j][i+MN]=Mul(nm[j][i-1+MN],B[j]),\n\t\tnm[j][-i+MN]=Mul(nm[j][-i+1+MN],inv[j]);\n\tfor(k=j=0;j<6;++j,k=0)for(i=1;i<=N;++i)\n\t{\n\t\tswitch(s[i])\n\t\t{\n\t\t\tcase '<':--k;break;\n\t\t\tcase '>':++k;break;\n\t\t\tcase '+':all[j]=Add(all[j],nm[j][k+MN]);break;\n\t\t\tcase '-':all[j]=Add(all[j],P-nm[j][k+MN]);break;\n\t\t}\n\t\tpos[i]=k;pre[i][j]=all[j];\n\t}\n\t++Mp[all];\n\tfor(i=1;i<=N;++i)\n\t\tcal[i]=Mp[pre[i]],\n\t\t++Mp[get(pre[i],all,pos[i]+MN)];\n\tll ans=0;\n\tfor(i=1;i<=N;++i) ans+=cal[i];\n\treturn 0*printf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstdio>\n#include<map>\n#define mxn 1000010\nusing namespace std;\nconst int hs[]={13,29,53,71,103,1999,13577,50177,341569,992863},iv[]={11,87,57,2792,10759,284652,16312892,8982012,583800912,300380820},md[]={71,97,151,6007,23087,616489,19260817,19491001,998244353,1000000007};\nlong long ans;\nint n,sl,fh;\nchar s[mxn];\nstruct hsh\n{\n\tint s[10],X[10];\n}a[mxn];\nstruct vl\n{\n\tint s[10];\n\tbool operator <(const vl &x)const\n\t{\n\t\tfor(int i=0;i<10;++i)\n\t\t\tif(s[i]!=x.s[i])\n\t\t\t\treturn s[i]<x.s[i];\n\t\treturn 0;\n\t}\n}N,nw,tmp;\nmap<vl,int> mp;\nint rd()\n{\n\tsl=0;fh=1;\n\tchar ch=getchar();\n\twhile(ch<'0'||'9'<ch) {if(ch=='-') fh=-1; ch=getchar();}\n\twhile('0'<=ch&&ch<='9') sl=sl*10+ch-'0',ch=getchar();\n\treturn sl*fh;\n}\nvoid upd(int &x,int y,int mod) {x+=y; if(x>=mod) x-=mod;}\nvoid add(hsh &x) {for(int i=0;i<10;++i) upd(x.s[i],x.X[i],md[i]);}\nvoid plu(hsh &x) {for(int i=0;i<10;++i) upd(x.s[i],md[i]-x.X[i],md[i]);}\nvoid mul(hsh &x) {for(int i=0;i<10;++i) x.X[i]=1ll*hs[i]*x.X[i]%md[i];}\nvoid del(hsh &x) {for(int i=0;i<10;++i) x.X[i]=1ll*iv[i]*x.X[i]%md[i];}\nint main()\n{\n\tn=rd();scanf(\"%s\",s+1);\n\tfor(int i=0;i<10;++i) a[0].X[i]=1;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\ta[i]=a[i-1];\n\t\tif(s[i]=='+') add(a[i]);\n\t\telse if(s[i]=='-') plu(a[i]);\n\t\telse if(s[i]=='>') mul(a[i]);\n\t\telse del(a[i]);\n\t}\n\tfor(int j=0;j<10;++j) N.s[j]=a[n].s[j];\n\tfor(int i=n;i;--i)\n\t{\n\t\tfor(int j=0;j<10;++j)\n\t\t{\n\t\t\tnw.s[j]=a[i].s[j];\n\t\t\ttmp.s[j]=(a[i-1].s[j]+1ll*N.s[j]*a[i-1].X[j])%md[j];\n\t\t}\n\t\tmp[nw]++;ans+=mp[tmp];\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int N=500005,M1=900000011,M2=800000011;\nusing namespace std;\nint n,now,a[N],b1[N],b2[N],w1,w2,tp,a1,a2;\nchar S[N];\nlong long ans;\nmap<pair<int,int>,int>mp;\ninline int pls(int x,int y,int M){\n\treturn ((x+y)%M+M)%M;\n}\ninline void sol(bool fl){\n\tnow=n,w1=w2=0;\n\tfor(int i=1;i<=n;i++){\n\t\t//cerr<<i<<\"===now:\"<<now<<endl;\n\t\tif(fl)mp[{pls(1ll*b1[now]*a1%M1,1ll*w1*b1[n]%M1,M1),\n\t\tpls(1ll*b2[now]*a2%M2,1ll*w2*b2[n]%M2,M2)}]++;\n\t\t//cerr<<\"ins \"<<pls(1ll*b1[now]*a1%M1,1ll*w1*b1[n]%M1,M1)<<','<<\n\t\t//pls(1ll*b2[now]*a2%M2,1ll*w2*b2[n]%M2,M2)<<endl;\n\t\tif(S[i]>59)now+=S[i]-61;\n\t\telse{\n\t\t\t//cerr<<S[i]<<\"?\";\n\t\t\ttp=44-S[i];\n\t\t\tw1=pls(w1,tp*b1[now],M1);\n\t\t\tw2=pls(w2,tp*b2[now],M2);\n\t\t}\n\t\tif(fl)ans+=mp[{1ll*w1*b1[n]%M1,1ll*w2*b2[n]%M2}];\n\t\t//cerr<<\"(\"<<w1<<','<<w2<<\")\\n\";\n\t}\n}\nint main(){\n\t//freopen(\"dat.txt\",\"r\",stdin);\n\t//cerr<<(int)'+'<<' '<<(int)'-'<<' '<<(int)'>'<<' '<<(int)'<'<<endl;\n\tscanf(\"%d%s\",&n,S+1);\n\tb1[1]=b2[1]=1;\n\tfor(int i=1;i<=2*n;i++)\n\t//b1[i+1]=1ll*b1[i]*7%M1,b2[i+1]=1ll*b2[i]*11%M2;\n\tb1[i+1]=1ll*b1[i]*524287%M1,b2[i+1]=1ll*b2[i]*19260817%M2;\n\tsol(0),a1=w1,a2=w2,//cerr<<\"INI:(\"<<a1<<','<<a2<<\")\\n\",\n\tsol(1);\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cerr << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcerr<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 500010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = (1 << 30) - 1;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\nmt19937 rng; //use it by rng() % mod, shuffle(all(vec), rng)\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\ntemplate<int mod>\nstruct mint{\n  int x;\n  mint() : x(0) {}\n  mint(ll y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n  mint &operator+=(const mint &p) { if((x += p.x) >= mod) x -= mod; return *this; }\n  mint &operator-=(const mint &p) { if((x += mod - p.x) >= mod) x -= mod; return *this; }\n  mint &operator*=(const mint &p) { x = (int) (1LL * x * p.x % mod); return *this; }\n  mint &operator/=(const mint &p) { *this *= p.inverse(); return *this; }\n  mint &operator^=(ll n) {\n    int y = x; x = 1;\n    while(n > 0) {\n      if(n & 1) x = 1LL * x * y % mod; y = 1LL * y * y % mod; n /= 2; }\n    return *this; }\n  mint operator-() const { return mint(-x); }\n  mint operator+(const mint &p) const { return mint(*this) += p; }\n  mint operator-(const mint &p) const { return mint(*this) -= p; }\n  mint operator*(const mint &p) const { return mint(*this) *= p; }\n  mint operator/(const mint &p) const { return mint(*this) /= p; }\n  mint operator^(const ll n) const { return mint(*this) ^= n; }\n  bool operator==(const mint &p) const { return x == p.x; }\n  bool operator!=(const mint &p) const { return x != p.x; }\n  mint inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) { t = a / b; a -= t * b; swap(a, b); u -= t * v; swap(u, v); }\n    return mint(u); }\n  friend ostream &operator<<(ostream &os, const mint<mod> &p) { return os << p.x; }\n  friend istream &operator>>(istream &is, mint< mod > &a) { \n\t  ll t; is >> t; a = mint<mod>(t); return (is); }\n};\n\nstruct rhash { //don't forget to base_init()!!!!!\n\tmint<1000000007> v1;\n\tmint<1000000009> v2;\n\trhash() : v1(0), v2(0) {}\n\trhash(ll a) : v1(a), v2(a) {}\n\trhash(ll a, ll b) : v1(a), v2(b) {}\n\trhash &operator+=(const rhash &hs) { v1 += hs.v1; v2 += hs.v2; return *this; }\n\trhash &operator-=(const rhash &hs) { v1 -= hs.v1; v2 -= hs.v2; return *this; }\n\trhash &operator*=(const rhash &hs) { v1 *= hs.v1; v2 *= hs.v2; return *this; }\n\trhash &operator/=(const rhash &hs) { v1 /= hs.v1; v2 /= hs.v2; return *this; }\n\trhash &operator^=(ll n) { v1 ^= n; v2 ^= n; return *this; }\n\trhash operator-() const { rhash hs; hs.v1 = -v1; hs.v2 = -v2; return hs; }\n\trhash operator+(const rhash& hs) const { return rhash(*this) += hs; }\n\trhash operator-(const rhash& hs) const { return rhash(*this) -= hs; }\n\trhash operator*(const rhash& hs) const { return rhash(*this) *= hs; }\n\trhash operator/(const rhash& hs) const { return rhash(*this) /= hs; }\n\trhash operator^(ll n) const { return rhash(*this) ^= n; }\n\tbool operator<(const rhash &hs) const { return pi(v1.x, v2.x) < pi(hs.v1.x, hs.v2.x); }\n\tbool operator==(const rhash& hs) { return v1 == hs.v1 && v2 == hs.v2; }\n\tbool operator!=(const rhash& hs) { return v1 != hs.v1 || v2 != hs.v2; }\n\tfriend ostream &operator<<(ostream &os, const rhash &hs) { return os << pi(hs.v1.x, hs.v2.x); }\n};\n\n\nll mod_pow(ll a, ll n) {\n\tif(n == 0) return 1;\n\tll res = mod_pow(a, n / 2);\n\tif(n % 2 == 0) return res * res % mod;\n\telse return a * res % mod * res % mod;\n}\n\nll invf(ll a) {\n\treturn mod_pow(a, mod - 2);\n}\n\nint N;\nstring S;\n\nrhash A[MAX_N];\nint B[MAX_N];\n\nvoid solve() {\n\tcin >> N;\n\tcin >> S;\n\trhash base;\n\tint v1 = uniform_int_distribution<int>(0, 1000000007 - 1)(rng);\n\tint v2 = uniform_int_distribution<int>(0, 1000000009 - 1)(rng);\n\tbase = rhash(v1, v2);\n\trhash one = 1;\n\trhash inv = one / base;\n\n\tint at = 0;\n\trhash tmp = 1;\n\trhash res = 0;\n\trep(i, 0, N) {\n\t\tif(S[i] == '<') {\n\t\t\ttmp *= inv;\n\t\t\tat--;\n\t\t}\n\t\telse if(S[i] == '>') {\n\t\t\ttmp *= base;\n\t\t\tat++;\n\t\t}\n\t\telse if(S[i] == '+') res += tmp;\n\t\telse res -= tmp;\n\t\tA[i + 1] = res;\n\t\tB[i + 1] = at;\n\t\t// debug(res, at, tmp);\n\t}\n\tmap<rhash, int> D;\n\tD[A[N]]++;\n\n\tll ans = 0;\n\trer(i, N, 0) {\n\t\tint at = B[i];\n\t\trhash coef = 1;\n\t\tif(at < 0) coef = inv ^ (-at);\n\t\telse coef = base ^ at;\n\t\trhash target = (coef * A[N] + A[i]);\n\t\tif(D.count(target)) ans += D[target];\n\t\tD[A[i]]++;\n\t\t// debug(target, A[N]);\n\t}\n\tcout << ans << \"\\n\";\n}\n\nuint32_t rd() {\n\tuint32_t res;\n#ifdef __MINGW32__\n\tasm volatile(\"rdrand %0\" :\"=a\"(res) ::\"cc\");\n#else\n\tres = std::random_device()();\n#endif\n\treturn res;\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n    cerr << fixed;\n\tcerr.precision(6);\n\trng.seed(rd());\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n\tif(!freopen(\"in.txt\", \"rt\", stdin)) return 1;\n#endif\t\n\tsolve();\n    cerr << \"Time: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1061109567\n#define int long long\n#define pb push_back\n#define in(s) freopen(s,\"r\",stdin);\n#define out(s) freopen(s,\"w\",stdout);\n#define fi first\n#define se second\n#define bw(i,r,l) for (int i=r-1;i>=l;i--)\n#define fw(i,l,r) for (int i=l;i<r;i++)\n#define fa(i,x) for (auto i:x)\nusing namespace std;\nconst int N = 5e5 + 10;\nconst int mod1 = 1e9 + 7, mod2 = 1e9 + 9, base = 121448;\ntypedef pair<int, int> ii;\nint n, h[N][2], pw[N][2];\nstring s;\nmap<ii, int> mp;\nvoid add(int &x, int y, int mod) {\n\tx += y;\n\tif (x >= mod) x -= mod;\n}\nvoid rem(int &x, int y, int mod) {\n\tx -= y;\n\tif (x < 0) x += mod;\n}\nint fpow(int a, int p, int mod) {\n\tif (!p) return 1;\n\tint ans = fpow(a, p >> 1, mod);\n\tans = ans * ans % mod;\n\tif (p & 1) ans = ans * a % mod;\n\treturn ans;\n}\nint inv(int x, int mod) {\n\treturn fpow(x, mod - 2, mod);\n}\nsigned main() {\n\t#ifdef aome\n\tin(\"aome.inp\");\t\n\t#endif\n\tios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tcin >> n >> s;\n\t//Hash 'em. Then for a range L -> R, if the pointer at L is P, it's (h[r] - h[l - 1]) / b ^ p\n\tpw[0][0] = pw[0][1] = 1;\n\tfw (i, 1, N) {\n\t\tpw[i][0] = pw[i - 1][0] * base % mod1;\n\t\tpw[i][1] = pw[i - 1][1] * base % mod2;\n\t}\n\tint cur = 25e4 + 5;\n\tfw (i, 0, n) {\n\t\th[i][0] = i ? h[i - 1][0] : 0;\n\t\th[i][1] = i ? h[i - 1][1] : 0;\n\t\tif (s[i] == '>') cur++;\n\t\telse if (s[i] == '<') cur--;\n\t\telse if (s[i] == '+') add(h[i][0], pw[cur][0], mod1), add(h[i][1], pw[cur][1], mod2);\n\t\telse rem(h[i][0], pw[cur][0], mod1), rem(h[i][1], pw[cur][1], mod2);\n\t\t//cout << \"h[\"<<i<<\"][0] = \" << h[i][0] << \", 1 = \" << h[i][1] << \" cur = \" << cur << \"\\n\";\n\t\tmp[ii(h[i][0], h[i][1])]++;\n\t}\n\tcur = 0;\n\tint ans = 0;\n\tans += mp[ii(h[n - 1][0], h[n - 1][1])]; //0 -> any good points\n\tfw (i, 0, n) {\n\t\tif (s[i] == '>') cur++;\n\t\telse if (s[i] == '<') cur--;\n\t\tmp[ii(h[i][0], h[i][1])]--;\n\t\tint pw0, pw1;\n\t\tif (cur >= 0) pw0 = pw[cur][0], pw1 = pw[cur][1];\n\t\telse pw0 = inv(pw[-cur][0], mod1), pw1 = inv(pw[-cur][1], mod2);\n\t\t//cout << (h[n - 1][0] * pw0 + h[i][0]) % mod1 << \" \" << (h[n - 1][1] * pw1 + h[i][1]) % mod2 << \"\\n\";\n\t\tans += mp[ii((h[n - 1][0] * pw0 + h[i][0]) % mod1, (h[n - 1][1] * pw1 + h[i][1]) % mod2)];\n\t}\n\tcout << ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nlong long modinv(long long a, long long mod) {\n    long long b = mod, u = 1, v = 0;\n    while (b) {\n        long long t = a/b;\n        a -= t*b; swap(a, b);\n        u -= t*v; swap(u, v);\n    }\n    u %= mod;\n    if (u < 0) u += mod;\n    return u;\n}\n\nlong long modpow(long long a, long long n, long long mod) {\n    long long res = 1;\n    if (n < 0) {\n        a = modinv(a, mod);\n        n = -n;\n        return modpow(a, n, mod);\n    }\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nconst vector<long long> MOD = {1000000009, 1000000007};\nconst vector<long long> BASE = {17, 1009};\n\nlong long solve(int N, const string &S) {\n    vector<vector<long long>> hash(2, vector<long long>(N+1, 0));\n    vector<vector<long long>> pval(2, vector<long long>(N+1, 0));\n    map<pair<long long, long long>, vector<int>> pos;\n\n    for (int i = 0; i < N; ++i) {\n        for (int it = 0; it < 2; ++it) {\n            if (S[i] == '>') {\n                hash[it][i+1] = hash[it][i];\n                pval[it][i+1] = pval[it][i] + 1;\n            }\n            else if (S[i] == '<') {\n                hash[it][i+1] = hash[it][i];\n                pval[it][i+1] = pval[it][i] - 1;\n            }\n            else if (S[i] == '+') {\n                pval[it][i+1] = pval[it][i];\n                long long add = modpow(BASE[it], pval[it][i], MOD[it]);\n                hash[it][i+1] = (hash[it][i] + add) % MOD[it];\n            }\n            else if (S[i] == '-') {\n                pval[it][i+1] = pval[it][i];\n                long long add = modpow(BASE[it], pval[it][i], MOD[it]);\n                hash[it][i+1] = (hash[it][i] - add + MOD[it]) % MOD[it];\n            }\n        }\n        pos[{hash[0][i+1], hash[1][i+1]}].push_back(i+1);\n    }\n\n    long long res = 0;\n    for (int i = 0; i <= N; ++i) {\n        vector<long long> risou_add(2), risou(2);\n        for (int it = 0; it < 2; ++it) {\n            risou_add[it] = hash[it][N] * modpow(BASE[it], pval[it][i], MOD[it]) % MOD[it];\n            risou[it] = (hash[it][i] + risou_add[it]) % MOD[it];\n        }\n        auto &v = pos[{risou[0], risou[1]}];\n        int it = upper_bound(v.begin(), v.end(), i) - v.begin();\n        res += (int)v.size() - it;  \n    }\n    return res;\n}\n\nint main() {\n    int N; string S;\n    while (cin >> N >> S) cout << solve(N, S) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define pb push_back\n#define all(v) v.begin(), v.end()\n#define sz(v) int(v.size())\n#define pii pair<int, int>\n#define mp make_pair\n#define f first\n#define ll long long\n#define s second\n#define vec vector<int>\n\nusing namespace std;\n\nconst int N = (int) 2e6 + 10;\nconst int K = (int) 1e7 + 10;\nconst int mod = (int) 1e9 + 7;\nconst int T = (int) 200017;\n\nint n;\nstring st;\nint p[N];\n\nvoid add(int &x, int y) {\n\tx += y;\n\tif (x >= mod)\n\t\tx -= mod;\n\tif (x < 0) \n\t\tx += mod;\n}\n\nint mult(int x, int y) {\n\treturn x * 1ll * y % mod;\n}\n\nint hsh[N], pos[N];\n\npair<int, int> get(int l, int r) {\n\treturn mp(hsh[r + 1], pos[r + 1]);\n}\n\nint inv(int x) {\n\tint pw = mod - 2;\n\tint ans = 1;\n\twhile (pw) {\n\t\tif (pw & 1) \n\t\t\tans = mult(ans, x);\n\t\tx = mult(x, x);\n\t\tpw /= 2;\n\t}\n\treturn ans;\n}\n\n// get(l,r)=(get(0,r)-get(0,l-1))<<pos(0, l-1)\n\nint shift(int x, int val) { // to the right\n\tif (val > 0) {\n\t\tx = mult(x, p[val]);\n\t} else {\n\t\tx = mult(x, inv(p[-val]));\n\t}\n\treturn x;\n}\n\nint sum(int x, int y) {\n\tadd(x, y);\n\treturn x;\n}\n\nint main() {\n\t#ifdef sony\n\t\tfreopen(\"input.txt\", \"r\", stdin);\n\t\tfreopen(\"output.txt\", \"w\", stdout);\n\t#endif\n\tcin >> n >> st;\n\t//HASH(A) = {FOR I = [0...big_N] SUM OF A[I]*T^I % MODULO} WHERE T = PRIME > 2.5 * 10^5\n\tp[0] = 1;\n\tfor (int i = 1; i < N; i++) {\n\t\tp[i] = mult(p[i - 1], T);\n\t}\n\tpos[0] = 2 * n;\n\thsh[0] = 0;\n\tvector<int> a(4 * n, 0);\n\tfor (int i = 0; i < n; i++) {\n\t\tpos[i + 1] = pos[i];\n\t\thsh[i + 1] = hsh[i];\n\t\tif (st[i] == '+') {\n\t\t\tadd(hsh[i + 1], p[pos[i]]);\n\t\t} else if (st[i] == '-') {\n\t\t\tadd(hsh[i + 1], -p[pos[i]]);\n\t\t} else if (st[i] == '>') {\n\t\t\tpos[i]++;\n\t\t} else {\n\t\t\tpos[i]--;\n\t\t}\n\t}\n\tint x = get(0, n - 1).f;\n\tint ans = 0;\n\tmap<int, int> cnt;\n\tfor (int i = 0; i < n; i++) {\n\t\tint z = shift(get(0, i).f, 0);\n\t\tans += cnt[z];\n\t\tint y = sum(shift(x, get(0, i - 1).s - 2 * n), shift(get(0, i - 1).f, 0));\n\t\tcnt[y]++;\n\t}\n\tcout << ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <random>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\n\nconst ll MOD=1e9+7;\nconst int med=250000;\nll powmod(ll a, ll k){\n    ll ap=a, ans=1;\n    while(k>0){\n        if(k%2==1){\n            ans*=ap;\n            ans%=MOD;\n        }\n        ap=ap*ap;\n        ap%=MOD;\n        k/=2;\n    }\n    return ans;\n}\nll inv(ll a){\n\treturn powmod(a, MOD-2);\n}\n\nint main()\n{\n\tint n;\n\tcin>>n;\n\tstring s;\n\tcin>>s;\n\trandom_device rnd;\n\tmt19937_64 mt(rnd());\n\tuniform_int_distribution<ll> rndn(2, MOD-2);\n\tll b=rndn(mt);\n\tll binv=inv(b);\n\tll bp[500001];\n\tbp[med]=1;\n\tfor(int i=med+1; i<=med+n; i++) bp[i]=bp[i-1]*b%MOD;\n\tfor(int i=med-1; i>=med-n; i--) bp[i]=bp[i+1]*binv%MOD;\n\tll b0=0; int p=med;\n\tfor(int i=0; i<n; i++){\n\t\tif(s[i]=='+'){\n\t\t\tb0=(b0+bp[p])%MOD;\n\t\t}else if(s[i]=='-'){\n\t\t\tb0=(b0+MOD-bp[p])%MOD;\n\t\t}else if(s[i]=='>'){\n\t\t\tp++;\n\t\t}else{\n\t\t\tp--;\n\t\t}\n\t}\n\tll ans=0;\n\tll x[250000]={};\n\tvector<ll> v[500];\n\tint c1[500]={};\n\tll c0[500]={};\n\tint sq=600;\n\tfor(int i=0; i<n; i++){\n\t\tif(s[n-1-i]=='+'){\n\t\t\tfor(int j=i/sq*sq; j<=i; j++){\n\t\t\t\tx[j]=(x[j]+1)%MOD;\n\t\t\t}\n\t\t\tfor(int j=0; j<i/sq; j++){\n\t\t\t\tc0[j]=(c0[j]+1)%MOD;\n\t\t\t}\n\t\t}else if(s[n-1-i]=='-'){\n\t\t\tfor(int j=i/sq*sq; j<=i; j++){\n\t\t\t\tx[j]=(x[j]+MOD-1)%MOD;\n\t\t\t}\n\t\t\tfor(int j=0; j<i/sq; j++){\n\t\t\t\tc0[j]=(c0[j]+MOD-1)%MOD;\n\t\t\t}\n\t\t}else if(s[n-1-i]=='>'){\n\t\t\tfor(int j=i/sq*sq; j<=i; j++){\n\t\t\t\tx[j]=x[j]*b%MOD;\n\t\t\t}\n\t\t\tfor(int j=0; j<i/sq; j++){\n\t\t\t\tc1[j]++;\n\t\t\t\tc0[j]=c0[j]*b%MOD;\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int j=i/sq*sq; j<=i; j++){\n\t\t\t\tx[j]=x[j]*binv%MOD;\n\t\t\t}\n\t\t\tfor(int j=0; j<i/sq; j++){\n\t\t\t\tc1[j]--;\n\t\t\t\tc0[j]=c0[j]*binv%MOD;\n\t\t\t}\n\t\t}\n\t\tfor(int j=0; j<i/sq; j++){\n\t\t\tll x0=(b0-c0[j]+MOD)*bp[med-c1[j]]%MOD;\n\t\t\tans+=((ll)(upper_bound(v[j].begin(), v[j].end(), x0)-lower_bound(v[j].begin(), v[j].end(), x0)));\n\t\t}\n\t\tfor(int j=i/sq*sq; j<=i; j++){\n\t\t\tif(b0==x[j]) ans++;\n\t\t}\n\t\tif((i+1)%sq==0){\n\t\t\tfor(int j=i/sq*sq; j<=i; j++){\n\t\t\t\tv[i/sq].push_back(x[j]);\n\t\t\t}\n\t\t\tsort(v[i/sq].begin(), v[i/sq].end());\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<map>\ntypedef long long ll;\ntypedef double dd;\n#define For(i,j,k) for (int i=(int)j;i<=(int)k;++i)\n#define Forr(i,j,k) for (int i=(int)j;i>=(int)k;--i)\n#define Set(a,p) memset(a,p,sizeof(a))\nusing namespace std;\n\ntemplate<typename T>bool chkmax(T &a,T b) { return a<b?a=b,1:0; }\ntemplate<typename T>bool chkmin(T &a,T b) { return a>b?a=b,1:0; }\n\nconst int maxn=250000+100;\nconst int modd=1e9+7;\nint n;\nint p1,p2,Ans;\nint p[maxn],a[maxn];\nchar s[maxn];\nmap<ll,int>ma;\n\ninline void file() {\n\tfreopen(\"ARC099F.in\",\"r\",stdin);\n\tfreopen(\"ARC099F.out\",\"w\",stdout);\n}\n\ninline void Add(int &a,int b) {\n\ta+=b;\n\ta=(a>=modd?a-modd:a); a=(a<0?a+modd:a);\n}\n\ninline int quick(int a,int b) {\n\tint s=1;\n\twhile (b) {\n\t\tif (b%2==1) s=1ll*s*a%modd;\n\t\ta=1ll*a*a%modd; b/=2;\n\t}\n\treturn s;\n}\n\nint main() {\n//\tfile();\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",s+1);\n\tp1=998244353; p2=quick(p1,modd-2);\n\tp[0]=1;\n\tFor (i,1,n) {\n\t\tp[i]=p[i-1]; a[i]=a[i-1];\n\t\tif (s[i]=='+') Add(a[i],p[i]);\n\t\tif (s[i]=='-') Add(a[i],-p[i]);\n\t\tif (s[i]=='>') p[i]=1ll*p[i]*p1%modd;\n\t\tif (s[i]=='<') p[i]=1ll*p[i]*p2%modd;\n\t}\n//\tFor (i,1,n) cout << a[i] << \" \" ; cout << endl;\n//\tFor (i,1,n) cout << p[i] << \" \" ; cout << endl;\n\tForr (i,n,1) {\n\t\t++ma[a[i]];\n\t\tAdd(Ans,ma[(1ll*a[n]*p[i-1]%modd+a[i-1])%modd]);\n\t}\n\tprintf(\"%d\",Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long lint;\n\nlint modpow(lint x, lint y, lint mod) {\n  lint ret = 1 % mod, x2p = x;\n  while (y > 0) {\n    if (y % 2) ret = (__int128)ret * x2p % mod;\n    y /= 2;\n    x2p = (__int128)x2p * x2p % mod;\n  }\n  return ret;\n}\nconstexpr int nmods = 2;\nconstexpr lint mod[] = {1008176417, 1008176437};\nconstexpr lint base[] = {549817, 549817};\nlint inv_base[nmods];\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  string seq(n, ' ');\n  for (int i = 0; i < n; ++i)\n    scanf(\" %c\", &seq[i]);\n\n  vector<int> pos_before(n);\n\n  vector<vector<lint>> base_pow(nmods, vector<lint>(n + 1));\n  vector<vector<lint>> inv_base_pow(nmods, vector<lint>(n + 1));\n  vector<vector<lint>> hash_diff(nmods, vector<lint>(n, 0));\n  vector<vector<lint>> suffix(nmods, vector<lint>(n + 1));\n  vector<lint> full_seq_hash(nmods);\n  for (int k = 0; k < nmods; ++k) {\n    base_pow[k][0] = 1;\n    for (int i = 1; i <= n; ++i)\n      base_pow[k][i] = (__int128)base[k] * base_pow[k][i - 1] % mod[k];\n\n    inv_base[k] = modpow(base[k], mod[k] - 2, mod[k]);\n    assert((__int128)base[k] * inv_base[k] % mod[k] == 1);\n\n    inv_base_pow[k][0] = 1;\n    for (int i = 1; i <= n; ++i)\n      inv_base_pow[k][i] = (__int128)inv_base[k] * inv_base_pow[k][i - 1] % mod[k];\n\n    int pos = 0;\n    for (int i = 0; i < n; ++i) {\n      pos_before[i] = pos;\n      if (seq[i] == '>') ++pos;\n      else if (seq[i] == '<') --pos;\n      else {\n        lint base_pow_pos;\n        if (pos >= 0) base_pow_pos = base_pow[k][pos];\n        else base_pow_pos = inv_base_pow[k][-pos];\n        if (seq[i] == '+') hash_diff[k][i] = base_pow_pos;\n        else if (seq[i] == '-') {\n          hash_diff[k][i] = mod[k] - base_pow_pos;\n          assert(0 <= hash_diff[k][i]);\n          assert(hash_diff[k][i] < mod[k]);\n        } else assert(0);\n      }\n    }\n    full_seq_hash[k] = 0;\n    for (int i = 0; i < n; ++i) {\n      full_seq_hash[k] += hash_diff[k][i];\n      if (full_seq_hash[k] >= mod[k]) full_seq_hash[k] -= mod[k];\n    }\n\n    suffix[k][n] = 0;\n    for (int i = n - 1; i >= 0; --i) {\n      suffix[k][i] = hash_diff[k][i] + suffix[k][i + 1];\n      if (suffix[k][i] >= mod[k]) suffix[k][i] -= mod[k];\n    }\n  }\n\n  lint result = 0;\n  map<vector<lint>, int> count;\n  count[vector<lint>(nmods, 0LL)] += 1;\n  for (int i = n - 1; i >= 0; --i) {\n    vector<lint> shifted_full(nmods);\n    for (int k = 0; k < nmods; ++k) {\n      if (pos_before[i] >= 0) {\n        shifted_full[k] = (__int128)full_seq_hash[k] * base_pow[k][pos_before[i]] % mod[k];\n      } else {\n        shifted_full[k] = (__int128)full_seq_hash[k] * inv_base_pow[k][-pos_before[i]] % mod[k];\n      }\n    }\n\n    vector<lint> target(nmods);\n    for (int k = 0; k < nmods; ++k) {\n      target[k] = suffix[k][i] - shifted_full[k];\n      if (target[k] < 0) target[k] += mod[k];\n    }\n\n    auto it = count.find(target);\n    if (it != count.end())\n      result += it->second;\n\n    vector<lint> suffix_vec(nmods);\n    for (int k = 0; k < nmods; ++k)\n      suffix_vec[k] = suffix[k][i];\n\n    count[suffix_vec] += 1;\n  }\n  printf(\"%lld\\n\", result);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//teja349\n#include <bits/stdc++.h>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <utility>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <iomanip> \n//setbase - cout << setbase (16); cout << 100 << endl; Prints 64\n//setfill -   cout << setfill ('x') << setw (5); cout << 77 << endl; prints xxx77\n//setprecision - cout << setprecision (14) << f << endl; Prints x.xxxx\n//cout.precision(x)  cout<<fixed<<val;  // prints x digits after decimal in val\n\nusing namespace std;\n#define f(i,a,b) for(i=a;i<b;i++)\n#define rep(i,n) f(i,0,n)\n#define fd(i,a,b) for(i=a;i>=b;i--)\n#define pb push_back\n#define mp make_pair\n#define vi vector< int >\n#define vl vector< ll >\n#define ss second\n#define ff first\n#define ll long long\n#define pii pair< int,int >\n#define pll pair< ll,ll >\n#define sz(a) a.size()\n#define inf (1000*1000*1000+5)\n#define all(a) a.begin(),a.end()\n#define tri pair<int,pii>\n#define vii vector<pii>\n#define vll vector<pll>\n#define viii vector<tri>\n#define mod (998244353)\n#define pqueue priority_queue< int >\n#define pdqueue priority_queue< int,vi ,greater< int > >\n\n//std::ios::sync_with_stdio(false);   \nll ans10[512345],ans13[512345],powe13[512345],powe10[512345],invpowe10[512345];\nll invpowe13[512345],inv[1234],p[512345];\nll extend_gcd(ll a,ll b,ll &x,ll &y){\n\tif(b==0){\n\t\tx=1;\n\t\ty=0;\n\t\treturn a;\n\t}\n\tll x1,y1;\n\tll ans =extend_gcd(b,a%b,x1,y1);\n\tx=y1;\n\ty=x1-(a/b)*y1;\n\n\treturn ans;\n}\nmap<ll,ll> seti10,seti13; \nint main(){\n    std::ios::sync_with_stdio(false);\n    ll n;\n    cin>>n;\n    string s;\n    cin>>s;\n    ll i;\n    ll initp=250003;\n    powe10[0]=1;\n    powe13[0]=1;\n    invpowe10[0]=1;\n    invpowe13[0]=1;\n    f(i,1,100){\n\t\tll x,y;\n\t\tll val=extend_gcd(mod,i,x,y);\n\t\tif(y>0)\n\t\t\tinv[i]=y%mod;\n\t\telse{\n\t\t\t\tinv[i]=(y+mod)%mod;\n\t\t}\n\t}\n\tll inv10=inv[10];\n\tll inv13=inv[13];\n    f(i,1,512345){\n    \tpowe13[i]=powe13[i-1]*13;\n    \tpowe10[i]=powe10[i-1]*10;\n    \tpowe10[i]%=mod;\n    \tpowe13[i]%=mod;\n    \tinvpowe10[i]=invpowe10[i-1]*inv10;\n    \tinvpowe10[i]%=mod;\n    \tinvpowe13[i]=invpowe13[i-1]*inv13;\n    \tinvpowe13[i]%=mod;\n    }\n    ans10[0]=0;\n    ans13[0]=0;\n    p[0]=initp;\n    \n    f(i,1,s.length()+1){\n    \tans10[i]=ans10[i-1];\n    \tans13[i]=ans13[i-1];\n    \tp[i]=p[i-1];\n    \tif(s[i-1]=='+'){\n    \t\tans10[i]=ans10[i-1]+powe10[p[i]];\n    \t\tans13[i]=ans13[i-1]+powe13[p[i]];\n\n    \t}\n    \telse if(s[i-1]=='-'){\n    \t\tans10[i]=ans10[i-1]-powe10[p[i]];\n    \t\tans13[i]=ans13[i-1]-powe13[p[i]];\n    \t}\n    \telse if(s[i-1]=='<'){\n    \t\tp[i]--;\n    \t}\n    \telse{\n    \t\tp[i]++;\n    \t}\n    \tans10[i]%=mod;\n    \tans10[i]+=mod;\n    \tans10[i]%=mod;\n    \tans13[i]%=mod;\n    \tans13[i]+=mod;\n    \tans13[i]%=mod;\n    \tseti13[ans13[i]]++;\n    \tseti10[ans10[i]]++;\n    \t//cout<<ans10[i]<<\" \"<<ans13[i]<<endl;\n    }\n    ll val,val1,j10,j13;\n    ll total=0;\n    f(i,1,n+1){\n    \tval=initp-p[i-1];\n    \tval*=-1;\n    \tif(val>=0){\n    \t\tval1=powe13[val];\n    \t\tval=powe10[val];\n    \t\t  \n    \t}\n    \telse{\n    \t\tval1=invpowe13[val];\n    \t\tval=invpowe10[val];\n    \t}\n    \tj10=ans10[n]*val;\n    \tj10%=mod;\n    \tj10+=ans10[i-1];\n    \tj13=ans13[n]*val1;\n    \tj13%=mod;\n    \tj13+=ans13[i-1];\n    \tj10%=mod;\n    \tj13%=mod;\n    \ttotal+=min(seti10[j10],seti13[j13]);\n    \tseti13[ans13[i]]--;\n    \tseti10[ans10[i]]--;\n    }\n    cout<<total<<endl;\n\n\n\n\n    return 0;  \n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long lint;\n\nlint modpow(lint x, lint y, lint mod) {\n  lint ret = 1 % mod, x2p = x;\n  while (y > 0) {\n    if (y % 2) ret = (__int128)ret * x2p % mod;\n    y /= 2;\n    x2p = (__int128)x2p * x2p % mod;\n  }\n  return ret;\n}\n\nconstexpr int nmods = 3;\n\nconstexpr lint mod[] = {1152921504609811141LL, 576460752312103501LL,\n                        4611676018431352883LL};\nconstexpr lint base[] = {102999959LL, 1006199503LL, 1073741663};\nlint inv_base[nmods];\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  string seq(n, ' ');\n  for (int i = 0; i < n; ++i)\n    scanf(\" %c\", &seq[i]);\n\n  vector<int> pos_before(n);\n\n  vector<vector<lint>> base_pow(nmods, vector<lint>(n + 1));\n  vector<vector<lint>> inv_base_pow(nmods, vector<lint>(n + 1));\n  vector<vector<lint>> hash_diff(nmods, vector<lint>(n, 0));\n  vector<vector<lint>> suffix(nmods, vector<lint>(n + 1));\n  vector<lint> full_seq_hash(nmods);\n  for (int k = 0; k < nmods; ++k) {\n    base_pow[k][0] = 1;\n    for (int i = 1; i <= n; ++i)\n      base_pow[k][i] = (__int128)base[k] * base_pow[k][i - 1] % mod[k];\n\n    inv_base[k] = modpow(base[k], mod[k] - 2, mod[k]);\n    inv_base_pow[k][0] = 1;\n    for (int i = 1; i <= n; ++i)\n      inv_base_pow[k][i] = (__int128)inv_base[k] * inv_base_pow[k][i - 1] % mod[k];\n\n    int pos = 0;\n    for (int i = 0; i < n; ++i) {\n      pos_before[i] = pos;\n      if (seq[i] == '>') ++pos;\n      else if (seq[i] == '<') --pos;\n      else {\n        lint base_pow_pos;\n        if (pos >= 0) base_pow_pos = base_pow[k][pos];\n        else base_pow_pos = inv_base_pow[k][-pos];\n        if (seq[i] == '+') hash_diff[k][i] = base_pow_pos;\n        else if (seq[i] == '-') hash_diff[k][i] = mod[k] - base_pow_pos;\n        else assert(0);\n      }\n    }\n    full_seq_hash[k] = 0;\n    for (int i = 0; i < n; ++i) {\n      full_seq_hash[k] += hash_diff[k][i];\n      if (full_seq_hash[k] >= mod[k]) full_seq_hash[k] -= mod[k];\n    }\n\n    suffix[k][n] = 0;\n    for (int i = n - 1; i >= 0; --i) {\n      suffix[k][i] = hash_diff[k][i] + suffix[k][i + 1];\n      if (suffix[k][i] >= mod[k]) suffix[k][i] -= mod[k];\n    }\n  }\n\n  lint result = 0;\n  map<vector<lint>, int> count;\n  count[vector<lint>(nmods, 0LL)] += 1;\n  for (int i = n - 1; i >= 0; --i) {\n    vector<lint> shifted_full(nmods);\n    for (int k = 0; k < nmods; ++k) {\n      if (pos_before[i] >= 0) {\n        shifted_full[k] = (__int128)full_seq_hash[k] * base_pow[k][pos_before[i]] % mod[k];\n      } else {\n        shifted_full[k] = (__int128)full_seq_hash[k] * inv_base_pow[k][-pos_before[i]] % mod[k];\n      }\n    }\n\n    vector<lint> target(nmods);\n    for (int k = 0; k < nmods; ++k) {\n      target[k] = suffix[k][i] - shifted_full[k];\n      if (target[k] < 0) target[k] += mod[k];\n    }\n\n    auto it = count.find(target);\n    if (it != count.end())\n      result += it->second;\n\n    vector<lint> suffix_vec(nmods);\n    for (int k = 0; k < nmods; ++k)\n      suffix_vec[k] = suffix[k][i];\n\n    count[suffix_vec] += 1;\n  }\n  printf(\"%lld\\n\", result);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\n\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\n\n\n\nlong long modinv(long long a, long long mod) {\n    long long b = mod, u = 1, v = 0;\n    while (b) {\n        long long t = a/b;\n        a -= t*b; swap(a, b);\n        u -= t*v; swap(u, v);\n    }\n    u %= mod;\n    if (u < 0) u += mod;\n    return u;\n}\n\nlong long modpow(long long a, long long n, long long mod) {\n    long long res = 1;\n    if (n < 0) {\n        a = modinv(a, mod);\n        n = -n;\n        return modpow(a, n, mod);\n    }\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nconst long long MOD = 1000000009;\nconst long long BASE = 17;\n\nlong long solve(int N, const string &S) {\n    vector<long long> hash(N+1, 0), pval(N+1, 0);\n    map<long long, vector<int>> pos;\n\n    for (int i = 0; i < N; ++i) {\n        if (S[i] == '>') {\n            hash[i+1] = hash[i];\n            pval[i+1] = pval[i] + 1;\n        }\n        else if (S[i] == '<') {\n            hash[i+1] = hash[i];\n            pval[i+1] = pval[i] - 1;\n        }\n        else if (S[i] == '+') {\n            pval[i+1] = pval[i];\n            long long add = modpow(BASE, pval[i], MOD);\n            hash[i+1] = (hash[i] + add) % MOD;\n        }\n        else if (S[i] == '-') {\n            pval[i+1] = pval[i];\n            long long add = modpow(BASE, pval[i], MOD);\n            hash[i+1] = (hash[i] - add + MOD) % MOD;\n        }\n        pos[hash[i+1]].push_back(i+1);\n\n        //cout << i+1 << \": \" << hash[i+1] << \", \" << pval[i+1] << endl;\n    }\n\n    long long res = 0;\n    for (int i = 0; i <= N; ++i) {\n        long long cur = hash[i];\n        long long risou_add = hash[N] * modpow(BASE, pval[i], MOD) % MOD;\n        long long risou = (cur + risou_add) % MOD;\n\n        /*\n        COUT(\"-----------------\");\n        COUT(i); COUT(pval[i]); COUT(pos[risou]);\n        cout << cur << \" + \" << risou_add << \" -> \" << risou << endl;\n        */\n        \n        auto v = pos[risou];\n        int it = upper_bound(v.begin(), v.end(), i) - v.begin();\n        res += (int)v.size() - it;\n    }\n    return res;\n}\n\nint main() {\n    int N; string S;\n    while (cin >> N >> S) cout << solve(N, S) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define MAX 250002\nint n;\n\nchar buf[MAX];\n\n__int128 mod1=1000000007LL;\n__int128 mod2=1000000000000000003LL;\n\ninline __int128 mul(__int128 a,__int128 b){\n\treturn a*b%mod2;\n}\ninline __int128 add(__int128 a,__int128 b){\n\tauto f=a+b;\n\tif(f>=mod2)f-=mod2;\n\treturn f;\n}\ninline __int128 sub(__int128 a,__int128 b){\n\tauto f=a-b;\n\tif(f<0)f+=mod2;\n\treturn f;\n}\n__int128 ppow(__int128 a,__int128 b){\n\t__int128 res=1;\n\twhile(b){\n\t\tif(b&1LL)res*=a;\n\t\tif(res>=mod2)res%=mod2;\n\t\tb>>=1LL;\n\t}\n\treturn res;\n}\nunordered_map<__int128,int> cnt;\nvector<pair<__int128,__int128> > v;\nint main() {\n\tcin>>n;\n\tscanf(\"%s\",buf);\n\tauto inv=ppow(mod1,mod2-2);\n\t__int128 cur=1;\n\t__int128 cinv=1;\n\t__int128 hs=0;\n\tint sz=strlen(buf);\n\tv.push_back(make_pair(0,1));\n\tfor(int i=0;i<sz;i++){\n\t\tif(buf[i]=='<'){\n\t\t\tcur=mul(cur,inv);\n\t\t\tcinv=mul(cur,mod1);\n\t\t}\n\t\tif(buf[i]=='>'){\n\t\t\tcur=mul(cur,mod1);\n\t\t\tcinv=mul(cur,inv);\n\t\t}\n\t\tif(buf[i]=='+'){\n\t\t\ths=add(hs,cur);\n\t\t}\n\t\tif(buf[i]=='-'){\n\t\t\ths=sub(hs,cur);\n\t\t}\n\t\tv.push_back(make_pair(hs,cur));\n\t}\n\t__int128 acieve=mul(v.back().first,cinv);\n\t//(c-x)*second=acieve\n\t//c-x=acieve/second\n\t//c-acieve/second=x\n\tlong long int way=0;\n\tfor(int i=0;i<v.size();i++){\n\t\t__int128 want=sub(v[i].first,mul(acieve,v[i].second));\n\t\tway+=cnt[want];\n\t\tcnt[v[i].first]++;\n\t}\n\tprintf(\"%lld\\n\",way);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <cmath>\n#include <cstdio>\n#include <cctype>\n#include <ctime>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <complex>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cwchar>\n#include <cwctype>\n#include <exception>\n#include <locale>\n#include <numeric>\n#include <new>\n#include <stdexcept>\n#include <limits>\n#include <valarray>\n#include <set>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <list>\n#include <utility>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int INF = 1e9 + 7;\n\n\tconst LL MOD = 1004535809;\n\tLL power(LL x, int t)\n\t{\n\t\tif(t == 0) return 1LL;\n\t\tLL cc = power(x, t >> 1);\n\t\tcc = cc * cc % MOD;\n\t\tif(t & 1) cc = cc * x % MOD;\n\t\treturn cc;\n\t}\n\t\nconst LL HMOD = 1004535809, HRAD = 19683, HIRAD = 858522653;\nmap<LL, int> S;\nint n;\nchar ch[250005];\n\nint main()\n{\n\tscanf(\"%d%s\", &n, &ch);\n\tLL cur = 1LL, cnt = 0LL;\n\trep(i, n) {\n\t\tif(ch[i] == '+') cnt = (cnt + cur) % HMOD;\n\t\tif(ch[i] == '-') cnt = (cnt - cur + HMOD) % HMOD;\n\t\tif(ch[i] == '<') cur = cur * HIRAD % HMOD;\n\t\tif(ch[i] == '>') cur = cur * HRAD % HMOD;\n\t\tS[cnt] ++;\n\t}\n\tLL ss = cnt, ans = S[ss];\n\tcur = 1LL; cnt = 0LL;\n\trep(i, n) {\n\t\tif(ch[i] == '+') cnt = (cnt + cur) % HMOD;\n\t\tif(ch[i] == '-') cnt = (cnt - cur + HMOD) % HMOD;\n\t\tif(ch[i] == '<') cur = cur * HIRAD % HMOD;\n\t\tif(ch[i] == '>') cur = cur * HRAD % HMOD;\n\t\tS[cnt] --;\n\t\tans += S[(cnt + cur * ss) % HMOD];\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2e5 + 5;\n//const int mod = 1e9 + 7;\ntypedef long long ll;\n#define mp make_pair\n\nchar c;\nstring s;\nint n,i,ans;\nmap < pair < int , int > , int > M;\n\n\nstruct hash{\n    ll t,a,b,x,bol,X,mod;\n    hash() { t=b=x=X=mod=0; a=bol=1; }\n    void f(){\n        for(t=X,i=mod-2; i ; i>>=1){\n            if(i & 1) bol = bol*t % mod;\n            t = t*t % mod;\n        }\n        for(i=n-1; i>=0 ;i--){\n            c = s[i];\n            if(c == '-') x--;\n            if(c == '+') x++;\n            if(c == '>') x *= X;\n            if(c == '<') x *= bol;\n            x = (x % mod + mod) % mod;\n        }\n    }\n\n    void g(){\n        if(c == '+') b -= a;\n        if(c == '-') b += a;\n        if(c == '>') a *= bol;\n        if(c == '<') a *= X;\n        a = (a % mod + mod) % mod;\n        b = (b % mod + mod) % mod;\n        t = (a*x + b) % mod;\n    }\n};\n\nint main(){\n    cin >> n >> s;\n\n    hash h1,h2;\n    h1.mod = 1e9+7;  h1.X=10000003; h1.f();\n    h2.mod = 1e9+9;  h2.X=1000007; h2.f();\n\n    M[mp(0,0)] = 1;\n    for(i=n-1; i>=0 ;i--){\n        c = s[i];\n        h1.g(); h2.g();\n\n        ans += M[mp(h1.t,h2.t)];\n        M[mp(h1.b,h2.b)]++;\n    }\n\n    cout << ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>pii;\nconst int MAXN=3e5+5;\nconst int BASE=3137;\nconst int MOD1=1e9+7;\nconst int MOD2=1e9+9;\nint N;\nchar s[MAXN];\npii pref[MAXN],pot[MAXN];\nmap<pii,int>cnt;\n\ninline int add(int x,int y,int mod){\n\tx+=y;\n\tif(x>=mod)\n\t\tx-=mod;\n\telse if(x<0)\n\t\tx+=mod;\n\treturn x;\n}\n\ninline int mul(int x,int y,int mod){\n\treturn (ll)x*y%mod;\n}\n\nint power(int x,int y,int mod){\n\tint res=1;\n\tfor(;y;y/=2){\n\t\tif(y%2)res=mul(res,x,mod);\n\t\tx=mul(x,x,mod);\n\t}\n\treturn res;\n}\n\npii operator +(const pii&l,const pii&r){\n\tint a=l.first,b=l.second;\n\tint c=r.first,d=r.second;\n\treturn{add(a,c,MOD1),add(b,f,MOD2)};\n}\n\npii operator*(const pii &l,const pii &r){\n\tint a=l.first,b=l.second;\n\tint c=r.first,d=r.second;\n\treturn{mul(a,c,MOD1),mul(b,d,MOD2)};\n}\n\nll solve(){\n\tint inv1=power(BASE,MOD1-2,MOD1);\n\tint inv2=power(BASE,MOD2-2,MOD2);\n\tpot[0]={1,1};\n\tfor(int i=1;i<=N;++i){\n\t\tpot[i]=pot[i-1];\n\t\tpref[i]=pref[i-1];\n\t\tif(s[i]=='>')\n\t\t\tpot[i]=pot[i]*pii(BASE,BASE);\n\t\telse if(s[i]=='<')\n\t\t\tpot[i]=pot[i]*pii(inv1,inv2);\n\t\telse if(s[i]=='+')\n\t\t\tpref[i]=pref[i]+pot[i];\n\t\telse{\n\t\t\tint a=pot[i].first;\n\t\t\tpref[i]+=pii(-a,-pot[i].second);\n\t\t}\n\t}\n\tll ans=0;\n\tfor(int i=N;i;--i){\n\t\t++cnt[pref[i]];\n\t\tint a=pref[N];\n\t\tans+=cnt[(a*pot[i-1])+pref[i-1]];\n\t}\n\treturn ans;\n}\n\nint main(){\n\tscanf(\"%d%s\",&N,s+1);\n\tprintf(\"%lld\\n\",solve());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <map>\n#include <list>\n#include <iterator>\n#include <set>\n#include <queue>\n#include <iostream>\n#include <sstream>\n#include <stack>\n#include <deque>\n#include <cmath>\n#include <memory.h>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <algorithm>\n#include <utility>\n#include <time.h>\n#include <bitset>\n#include <assert.h>\n#include <complex.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(int i=(a)-1;i>=(b);--i)\n#define FILL(A,val) memset(A,val,sizeof(A))\n\n#define ALL(V) V.begin(),V.end()\n#define SZ(V) (int)V.size()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long Int;\ntypedef unsigned long long UInt;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double Pi = acos(-1.0);\nconst int INF = 1000000000;\nconst Int INF2 = Int(INF) * 5000;\nconst Int INF3 = Int(INF) * INF;\nconst int MAX = 510007;\nconst int MAXE = 2007000;\nconst int MAXV = 5000;\nconst int BASE = 1000000000;\nconst int ST = 1000000007;\n\nconst int MOD = 1000000007;\n\nint p = 1000003;\n\nInt H[MAX];\nint delta[MAX];\n\n\nInt pw[MAX];\n\nint main()\n{\n    //freopen(\"in.txt\", \"r\", stdin);\n    \n    pw[0] = 1;\n    FOR(i,1,MAX)\n    {\n        pw[i] = pw[i - 1] * p;\n    }\n    \n    int n;\n    cin >> n;\n    string s;\n    cin >> s;\n    \n    H[0] = 0;\n    delta[0] = n + 1;\n    \n    FOR(i,0,n)\n    {\n        H[i + 1] = H[i];\n        delta[i + 1] += delta[i];\n        \n        if (s[i] == '<')\n        {\n            delta[i + 1] --;\n        }\n        if (s[i] == '>')\n        {\n            delta[i + 1] ++;\n        }\n        \n        if (s[i] == '+')\n        {\n            H[i + 1] += pw[delta[i + 1]];\n        }\n        \n        if (s[i] == '-')\n        {\n            H[i + 1] -= pw[delta[i + 1]];\n        }\n        \n    }\n    \n    Int res = 0;\n    \n    map<Int, int> M;\n    \n    \n    \n    \n    RFOR(i,n,0)\n    {\n        M[H[i + 1] * pw[n]] ++;\n        Int h = H[n] * pw[delta[i] - delta[0] + n] + H[i] * pw[n];\n        \n        res += M[h];\n    }\n    \n    cout << res << endl;\n    \n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <random>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef unsigned long long ull;\nconst int med=250000;\null powmod(ull a, ll k){\n    if(a==0) return 0;\n    ull ap=a, ans=1;\n    while(k>0){\n        if(k%2==1){\n            ans*=ap;\n        }\n        ap=ap*ap;\n        k/=2;\n    }\n    return ans;\n}\null inv(ull a){\n\treturn powmod(a, (1ll<<63)-1);\n}\n\nint main()\n{\n\tint n;\n\tcin>>n;\n\t//char s[250000];\n  //for(int i=0; i<n; i++){\n    //if(i%4==0) s[i]='+';\n    //else if(i%4==1) s[i]='<';\n    //else if(i%4==2) s[i]='>';\n    //else s[i]='-';\n  //}\n  string s; cin>>s;\n    //random_device rnd;\n\t//mt19937_64 mt(rnd());\n\t//uniform_int_distribution<ll> rndn(2, MOD-2);\n\t//ll b=rndn(mt);\n  ull b=998244353;\n\tull binv=inv(b);\n\tull bp[500001];\n\tbp[med]=1;\n\tfor(int i=med+1; i<=med+n; i++) bp[i]=bp[i-1]*b;\n\tfor(int i=med-1; i>=med-n; i--) bp[i]=bp[i+1]*binv;\n\tull b0=0; int p=med;\n\tfor(int i=0; i<n; i++){\n\t\tif(s[i]=='+'){\n\t\t\tb0=b0+bp[p];\n\t\t}else if(s[i]=='-'){\n\t\t\tb0=b0-bp[p];\n\t\t}else if(s[i]=='>'){\n\t\t\tp++;\n\t\t}else{\n\t\t\tp--;\n\t\t}\n\t}\n\tll ans=0;\n\tull x[250000]={};\n\tunordered_map<ull, int> mp[500];\n\tint c1[500]={};\n\tull c0[500]={};\n\tint sq=2000;\n\tfor(int i=0; i<n; i++){\n\t\tif(s[n-1-i]=='+'){\n\t\t\tfor(int j=i/sq*sq; j<=i; j++){\n\t\t\t\tx[j]++;\n\t\t\t}\n\t\t\tfor(int j=0; j<i/sq; j++){\n\t\t\t\tc0[j]++;\n\t\t\t}\n\t\t}else if(s[n-1-i]=='-'){\n\t\t\tfor(int j=i/sq*sq; j<=i; j++){\n\t\t\t\tx[j]--;\n\t\t\t}\n\t\t\tfor(int j=0; j<i/sq; j++){\n\t\t\t\tc0[j]--;\n\t\t\t}\n\t\t}else if(s[n-1-i]=='>'){\n\t\t\tfor(int j=i/sq*sq; j<=i; j++){\n\t\t\t\tx[j]*=b;\n\t\t\t}\n\t\t\tfor(int j=0; j<i/sq; j++){\n\t\t\t\tc1[j]++;\n\t\t\t\tc0[j]*=b;\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int j=i/sq*sq; j<=i; j++){\n\t\t\t\tx[j]*=binv;\n\t\t\t}\n\t\t\tfor(int j=0; j<i/sq; j++){\n\t\t\t\tc1[j]--;\n\t\t\t\tc0[j]*=binv;\n\t\t\t}\n\t\t}\n\t\tfor(int j=0; j<i/sq; j++){\n\t\t\tull x0=(b0-c0[j])*bp[med-c1[j]];\n\t\t\tauto itr=mp[j].find(x0);\n          if(itr!=mp[j].end()) ans+=((ll)(itr->second));\n\t\t}\n\t\tfor(int j=i/sq*sq; j<=i; j++){\n\t\t\tif(b0==x[j]) ans++;\n\t\t}\n\t\tif((i+1)%sq==0){\n\t\t\tfor(int j=i/sq*sq; j<=i; j++){\n\t\t\t\tmp[i/sq][x[j]]++;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\nconst pid_t pid = getpid();\n// Problem Specific Parameter:\n\ntemplate<unsigned MOD>  class ModInt {\npublic:\n\tModInt(): x(0) {}\n\tModInt(signed y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n\tModInt(signed long long y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n\n\n\t// Arithmetic Oprators\n\tModInt &operator+=(ModInt that) {\n\t\tif ((x += that.x) >= MOD) x -= MOD; \n\t\treturn *this;\n\t}\n\tModInt &operator-=(ModInt that) {\n\t\tif ((x += MOD - that.x) >= MOD) x -= MOD; \n\t\treturn *this;\n\t}\n\tModInt &operator*=(ModInt that) {\n\t\tx = 1LL * x * that.x % MOD;\n\t\treturn *this;\n\t}\n\tModInt &operator/=(ModInt that) {\n\t\treturn *this *= ModInt(get<1>(extgcd(that.x, int(MOD))));\n\t}\n\tModInt &operator%=(ModInt that) {\n\t\tx %= that.x;\n\t\treturn *this;\n\t}\n\n\tModInt &operator+=(const int that) { return *this += ModInt(that);}\n\tModInt &operator-=(const int that) { return *this -= ModInt(that);}\n\tModInt &operator*=(const int that) { return *this *= ModInt(that);}\n\tModInt &operator/=(const int that) { return *this /= ModInt(that);}\n\tModInt &operator%=(const int that) { return *this %= ModInt(that);}\n\n\t// Comparators\n\tbool operator <(ModInt that) const { return x < that.x; }\n\tbool operator >(ModInt that) const { return x > that.x; }\n\tbool operator<=(ModInt that) const { return x <= that.x; }\n\tbool operator>=(ModInt that) const { return x >= that.x; }\n\tbool operator!=(ModInt that) const { return x != that.x; }\n\tbool operator==(ModInt that) const { return x == that.x; }\n\n\t// Utilities\n\tunsigned getval() const { return x;}\n\tModInt operator+(ModInt that) const { return ModInt(*this) += that;}\n\tModInt operator-(ModInt that) const { return ModInt(*this) -= that;}\n\tModInt operator*(ModInt that) const { return ModInt(*this) *= that;}\n\tModInt operator/(ModInt that) const { return ModInt(*this) /= that;}\n\tModInt operator%(ModInt that) const { return ModInt(*this) %= that;}\n\tModInt operator+(const int that) const { return ModInt(*this) += that;}\n\tModInt operator-(const int that) const { return ModInt(*this) -= that;}\n\tModInt operator*(const int that) const { return ModInt(*this) *= that;}\n\tModInt operator/(const int that) const { return ModInt(*this) /= that;}\n\tModInt operator%(const int that) const { return ModInt(*this) %= that;}\n\tModInt operator=(const int that) { return *this = ModInt(that);}\n\tfriend istream &operator>>(istream& is, ModInt &that) {ll tmp; is >> tmp; that = ModInt(tmp);return is;}\n\tfriend ostream &operator<<(ostream& os, const ModInt &that) { return os << that.x; }\n\t\n\tModInt power(ll n) const {\n\t\tif(n < 0) return ModInt(1) / power(-n);\n\t\tll b = 1LL, a = x;\n\t\twhile(n){\n\t\t\tif(n & 1) b = b * a % MOD;\n\t\t\ta = a * a % MOD;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn ModInt(b);\n\t}\nprivate:\n\tunsigned x;\n\t\n\tinline auto extgcd(int a, int b) {\n\t\tif (b == 0) return make_tuple(a, 1, 0);\n\t\ttuple<int, int, int> ret = extgcd(b, a % b);\n\t\tswap(get<1>(ret), get<2>(ret));\n\t\tget<2>(ret) -= a / b * get<1>(ret);\n\t\treturn ret;\n\t}\n};\n\nusing mint = ModInt<1000000007>;\nusing mint2 = ModInt<1000000009>;\nusing mint3 = ModInt<1000000021>;\nusing mint4 = ModInt<1000000033>;\nusing mint5 = ModInt<1000000087>;\nusing mint6 = ModInt<1000000093>;\n\n\nuniform_int_distribution<int> rng(1 << 20, 1 << 28); // [lower,upper] \nmt19937 mt(pid);\n\nconst int limit = 500010;\nconst int offset = 250000;\n\nusing H = tuple<mint,mint2,mint3,mint4,mint5,mint6>;\nconst H B = H(mint(rng(mt)),mint2(rng(mt)),mint3(rng(mt)),mint4(rng(mt)),mint5(rng(mt)),mint6(rng(mt)));\nconst H ZERO = H(mint(0),mint2(0),mint3(0),mint4(0),mint5(0),mint6(0));\nconst H ONE = H(mint(1),mint2(1),mint3(1),mint4(1),mint5(1),mint6(1));\n\n\nvoid add(H &cur,H tar){\n\tget<0>(cur) += get<0>(tar);  \n\tget<1>(cur) += get<1>(tar);  \n\tget<2>(cur) += get<2>(tar);  \n\tget<3>(cur) += get<3>(tar);  \n\tget<4>(cur) += get<4>(tar);  \n\tget<5>(cur) += get<5>(tar);  \n}\n\nvoid sub(H &cur,H tar){\n\tget<0>(cur) -= get<0>(tar);  \n\tget<1>(cur) -= get<1>(tar);  \n\tget<2>(cur) -= get<2>(tar);  \n\tget<3>(cur) -= get<3>(tar);  \n\tget<4>(cur) -= get<4>(tar);  \n\tget<5>(cur) -= get<5>(tar);  \n}\n\nvoid mul(H &cur,H tar){\n\tget<0>(cur) *= get<0>(tar);  \n\tget<1>(cur) *= get<1>(tar);  \n\tget<2>(cur) *= get<2>(tar);  \n\tget<3>(cur) *= get<3>(tar);  \n\tget<4>(cur) *= get<4>(tar);  \n\tget<5>(cur) *= get<5>(tar);  \n}\n\nH power(H cur,int n){\n\tH ret;\n\tget<0>(ret) = get<0>(B).power(n);  \n\tget<1>(ret) = get<1>(B).power(n);\n\tget<2>(ret) = get<2>(B).power(n);\n\tget<3>(ret) = get<3>(B).power(n);\n\tget<4>(ret) = get<4>(B).power(n);\n\tget<5>(ret) = get<5>(B).power(n);\n\treturn ret;\n}\n\nH shash[limit],csum[limit];\nint cpos[limit];\n\n\nint main(void){\n\tint n;\n\tstring s;\n\tcin >> n >> s;\n\n\tshash[0] = ONE;\n\trep(i,1,limit){\n\t\tshash[i] = ONE;\n\t\tmul(shash[i],shash[i-1]);\n\t\tmul(shash[i],B);\n\t}\n\n\tH cur = ZERO;\n\tint pos = 0;\n\trep(i,n+1){\n\t\tcpos[i] = pos;\n\t\tcsum[i] = cur;\n\t\tif(i == n) break;\n\n\t\tif(s[i] == '+') add(cur,shash[pos + offset]);\n\t\tif(s[i] == '-') sub(cur,shash[pos + offset]);\n\t\tif(s[i] == '>') pos++;\n\t\tif(s[i] == '<') pos--;\n\t}\n\n\tmap<H,int> num;\n\tnum[csum[n]]++;\n\n\tll ans = 0LL;\n\trrep(i,n){\n\t\tH tar = csum[n];\n\t\tmul(tar,power(B,cpos[i])); \n\t\tadd(tar,csum[i]);\n\t\tif(num.find(tar) != end(num)) ans += num[tar];\n\t\tnum[csum[i]]++;\n\t}\n\n\tcout << ans << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<map>\n#define maxn 250005\n#define ll long long \nusing namespace std;\n\nconst ll M=19260817,mo=998244353;\nint n,i,j,k,a[maxn];\nll s[maxn],c[maxn],mul[maxn],inv[maxn],invM,ans;\nmap<int,ll> S; \nchar ch;\n\nll ksm(ll x,ll y){\n\tll s=1;\n\tfor(;y;y/=2,x=x*x%mo) if (y&1)\n\t\ts=s*x%mo;\n\treturn s;\n}\n\nll cm(int k){return (k<0)?inv[-k]:mul[k];}\n\nint main(){\n\tscanf(\"%d\",&n),ch=getchar();\n\twhile (ch!='<'&&ch!='>'&&ch!='+'&&ch!='-') ch=getchar();\n\tfor(i=1;i<=n;i++) a[i]=ch,ch=getchar();\n\tmul[0]=1;for(i=1;i<=n;i++) mul[i]=mul[i-1]*M%mo;\n\tinv[0]=1,invM=ksm(M,mo-2);for(i=1;i<=n;i++) inv[i]=inv[i-1]*invM%mo; \n\tfor(i=n;i>=1;i--) {\n\t\tc[i]=c[i+1];\n\t\tif (a[i]=='<') s[i]=s[i+1]*M%mo,c[i]++; else \n\t\tif (a[i]=='>') s[i]=s[i+1]*invM%mo,c[i]--; else \n\t\tif (a[i]=='+') s[i]=(s[i+1]+1)%mo; else s[i]=(s[i+1]+mo-1)%mo;\n\t}\n//\tfor(i=1;i<=n;i++) for(j=i+1;j<=n+1;j++)\n//\t\tif (((s[i]-s[j]*cm(c[i]-c[j])%mo)%mo+mo)%mo==s[1])\n//\t\t\tans++;\n//\tprintf(\"%lld\\n\",ans),ans=0;\n\tS[0]=1;\n\tfor(i=n;i>=1;i--) {\n\t\tll v=(s[i]-s[1]+mo)*cm(-c[i])%mo;\n\t\tif (S.find(v)!=S.end()) \n\t\t\tans+=S[v];\n\t\tS[s[i]*cm(-c[i])%mo]++;\n\t}\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=1;i<=(n);i++)\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int maxn=500005;\nconst int hval[4]={12345678,23456781,34567812,45678123};\nconst int mod[4]={515880193,998244353,int(1e9+7),int(1e9+9)};\nclass Hash{\npublic:\n\tint h[4];\n\tHash(){memset(h,0,sizeof(h));}\n\tbool operator < (const Hash &o)const{\n\t\tif(h[0]!=o.h[0])return h[0]<o.h[0];\n\t\tif(h[1]!=o.h[1])return h[1]<o.h[1];\n\t\tif(h[2]!=o.h[2])return h[2]<o.h[2];\n\t\treturn h[3]<o.h[3];\n\t}\n\tHash operator + (const Hash &o)const{\n\t\tHash res;\n\t\trep(i,4){\n\t\t\tres.h[i]=h[i]+o.h[i];\n\t\t\tif(res.h[i]>=mod[i])res.h[i]-=mod[i];\n\t\t}\n\t\treturn res;\n\t}\n\tHash operator - (const Hash &o)const{\n\t\tHash res;\n\t\trep(i,4){\n\t\t\tres.h[i]=h[i]-o.h[i];\n\t\t\tif(res.h[i]<0)res.h[i]+=mod[i];\n\t\t}\n\t\treturn res;\n\t}\n\tHash operator * (const Hash &o)const{\n\t\tHash res;\n\t\trep(i,4)res.h[i]=1LL*h[i]*o.h[i]%mod[i];\n\t\treturn res;\n\t}\n}H,iH,one,pw[maxn],ipw[maxn],sum[maxn];\nint n;\nint pos[maxn];\nmap<Hash,int>cnt;\nchar s[maxn];\n\nint power(int x,int pow,int mod){\n\tint res=1;\n\tfor(;pow;pow>>=1){\n\t\tif(pow&1)res=1LL*res*x%mod;\n\t\tx=1LL*x*x%mod;\n\t}\n\treturn res;\n}\n\nint main(){\n\tscanf(\"%d%s\",&n,s+1);\n\trep(i,4){\n\t\tH.h[i]=hval[i];\n\t\tiH.h[i]=power(hval[i],mod[i]-2,mod[i]);\n\t\tone.h[i]=1;\n\t}\n\tpw[0]=ipw[0]=one;\n\tREP(i,2*n){\n\t\tpw[i]=pw[i-1]*H;\n\t\tipw[i]=ipw[i-1]*iH;\n\t}\n\tREP(i,n){\n\t\tpos[i]=pos[i-1];\n\t\tsum[i]=sum[i-1];\n\t\tif(s[i]=='<')pos[i]--;\n\t\telse if(s[i]=='>')pos[i]++;\n\t\telse if(s[i]=='+')sum[i]=sum[i]+pw[pos[i]+n];\n\t\telse sum[i]=sum[i]-pw[pos[i]+n];\n\t}\n\tll ans=0;\n\tfor(int i=n;i>=1;i--){\n\t\tcnt[sum[i]]++;\n\t\tif(pos[i-1]<0)ans+=cnt[(sum[n]*ipw[-pos[i-1]])+sum[i-1]];\n\t\telse ans+=cnt[(sum[n]*pw[pos[i-1]])+sum[i-1]];\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=300005,p=998244353;\nint read(){\n\tint f=1,g=0;\n\tchar ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-') f=-1;\n\tfor (;isdigit(ch);ch=getchar()) g=g*10+ch-'0';\n\treturn f*g;\n}\nint qpow(int x,int k){\n\tint t=1;\n\tfor (;k;k>>=1){\n\t\tif (k&1) t=(ll)t*x%p;\n\t\tx=(ll)x*x%p;\n\t}\n\treturn t;\n}\nstruct state{\n\tint a[6];\n\tint &operator[](int i){return a[i];}\n\tstate(){memset(a,0,sizeof(a));}\n}x,rx,s[N][2],c,e;\nbool operator==(state a,state b){\n\tfor (int i=0;i<6;i++)\n\tif (a[i]==b[i]) return false;\n\treturn true;\n}\nbool operator<(state a,state b){\n\tfor (int i=0;i<6;i++)\n\tif (a[i]!=b[i]) return a[i]<b[i];\n\treturn false;\n}\nstate operator*(state x,state y){for (int i=0;i<6;i++) x[i]=(ll)x[i]*y[i]%p;return x;}\nstate operator+(state x,state y){for (int i=0;i<6;i++) if((x[i]+=y[i])>=p) x[i]-=p;return x;}\nstate operator-(state x,state y){for (int i=0;i<6;i++) if((x[i]-=y[i])<0) x[i]+=p;return x;}\nstate operator+(state x,int k){for (int i=0;i<6;i++) if ((x[i]+=k)>=p) x[i]-=p;return x;}\nstate operator-(state x,int k){for (int i=0;i<6;i++) if ((x[i]-=k)<0) x[i]+=p;return x;}\nstate getval(state *a,state x){\n\tstate cur=a[0]+a[1]*x;\n\treturn cur;\n}\nint n,m;\nll ans;\nchar ch[N];\nmap<state,int> f;\nint main(){\n\tfor (int i=0;i<6;i++) x[i]=i+1,rx[i]=qpow(x[i],p-2);\n\tn=read();\n\tscanf(\" %s\",ch+1);\n\tfor (int i=0;i<6;i++) s[n+1][1][i]=1;\n\tfor (int i=n;i;i--)\n\tif (ch[i]=='+'){s[i][0]=s[i+1][0]+s[i+1][1];s[i][1]=s[i+1][1];c=c-1;}\n\telse if (ch[i]=='-'){s[i][0]=s[i+1][0]-s[i+1][1];s[i][1]=s[i+1][1];c=c+1;}\n\telse if (ch[i]=='>'){s[i][0]=s[i+1][0];s[i][1]=s[i+1][1]*x;c=c*rx;}\n\telse if (ch[i]=='<'){s[i][0]=s[i+1][0];s[i][1]=s[i+1][1]*rx;c=c*x;}\n\tfor (int i=n;i;i--){\n\t\tf[getval(s[i+1],e)]++;\n\t\tans+=f[getval(s[i],c)];\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<iostream>\n#define LL long long\n#define MP make_pair\nusing namespace std;\nconst LL mod=1e9+7;\nLL base[4],pre[4][500010],inv[4];\nstruct node{LL a,b;}op[4][250010];\nmap<pair<pair<LL,LL>,pair<LL,LL> >,LL> mp;\nLL pow(LL a,LL b)\n{\n\tLL ans=1;\n\twhile(b)\n\t{\n\t\tif(b&1) ans=ans*a%mod;\n\t\ta=a*a%mod;b>>=1;\n\t}\n\treturn ans;\n}\nLL n,p=0,t[500010],c[4],a[4][250010],b[4][250010];\nchar s[250010];\nvoid Pre()\n{\n\tfor(int k=0;k<4;k++)\n\t{\n\t\tLL cnt=1;op[k][n+1].a=1;\n\t\tfor(LL i=n;i>=1;i--)\n\t\t{\n\t\t\top[k][i]=op[k][i+1];\n\t\t\tif(s[i]=='<') cnt=cnt*base[k]%mod,(op[k][i].a*=base[k])%=mod;\n\t\t\tif(s[i]=='>') cnt=cnt*inv[k]%mod,(op[k][i].a*=inv[k])%=mod;\n\t\t\tif(s[i]=='-') (op[k][i].b+=cnt*pre[k][n]%mod)%=mod;\n\t\t\tif(s[i]=='+') op[k][i].b=((op[k][i].b-cnt*pre[k][n]%mod)%mod+mod)%mod;\n\t\t}\n\t}\n}\nvoid solve(LL *a,LL c,LL k) {for(LL i=1;i<=n;i++) a[i]=(c*op[k][i].a%mod+op[k][i].b)%mod;}\nint main()\n{\n\tbase[0]=2333;base[1]=10037;base[2]=19260817;base[3]=998244353;\n\tfor(int i=0;i<4;i++) inv[i]=pow(base[i],mod-2);\n\tscanf(\"%lld\",&n);getchar();\n\tscanf(\"%s\",s+1);\n\tfor(LL k=0;k<4;k++)\n\t{\n\t\tpre[k][0]=1;for(LL i=1;i<=2*n;i++) pre[k][i]=pre[k][i-1]*base[k]%mod;\n\t}\n\tfor(LL i=1;i<=n;i++)\n\t{\n\t\tif(s[i]=='<') p--;if(s[i]=='>') p++;\n\t\tif(s[i]=='-') t[p+n]--;if(s[i]=='+') t[p+n]++;\n\t}\n\tfor(int k=0;k<4;k++)\n\t\tfor(LL i=-n;i<=n;i++) (c[k]+=pre[k][i+n]*t[i+n]%mod)%=mod;\n\tPre();\n\tfor(int i=0;i<4;i++) solve(a[i],0,i);\n\tfor(int i=0;i<4;i++) solve(b[i],c[i],i);\n\tLL ans=0;\n\t//printf(\"c:%lld\\n\",c);\n\t//for(int i=1;i<=n;i++) printf(\"op:%lld %lld\\n\",op[i].a,op[i].b);\n\t//for(LL i=-n;i<=n;i++) printf(\"%lld:%lld %lld\\n\",i,t[i+n],pre[i+n]);printf(\"\\n\");\n\t//printf(\"a:\");for(int i=1;i<=n;i++) printf(\"%lld \",a[i]);printf(\"\\n\");\n\t//printf(\"b:\");for(int i=1;i<=n;i++) printf(\"%lld \",b[i]);printf(\"\\n\");\n\t//mp[c]++;\n\tfor(LL i=2;i<=n+1;i++)\n\t{\n\t\tmp[MP(MP(b[0][i-1],b[1][i-1]),MP(b[2][i-1],b[3][i-1]))]++;\n\t\tans+=mp[MP(MP(a[0][i],a[1][i]),MP(a[2][i],a[3][i]))];\n\t}\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "// This amazing code is by Eric Sunli Chen.\n#include<bits/stdc++.h>\nusing namespace std;\ntemplate<typename T> bool get_int(T &x)\n{\n\tchar t=getchar();\n\tbool neg=false;\n\tx=0;\n\tfor(; (t>'9'||t<'0')&&t!='-'&&t!=EOF; t=getchar());\n\tif(t=='-')neg=true,t=getchar();if(t==EOF)return false;\n\tfor(; t<='9'&&t>='0'; t=getchar())x=x*10+t-'0';\n\tif(neg)x=-x;return true;\n}\ntemplate<typename T> void print_int(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tshort a[20]= {},sz=0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1; i>=0; i--)putchar('0'+a[i]);\n}\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\n#define get1(a) get_int(a)\n#define get2(a,b) (get1(a)&&get1(b))\n#define get3(a,b,c) (get1(a)&&get2(b,c))\n#define printendl(a) print_int(a),puts(\"\")\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef pair<int,int> pii;\nconst int inf=0x3f3f3f3f;\nconst LL Linf=1ll<<61;\nconst double pi=acos(-1.0);\n\nint qpow(int x,int y,int mod)\n{\n\tint ret=1;\n\twhile(y)\n\t{\n\t\tif(y&1)ret=(LL)ret*x%mod;\n\t\tx=(LL)x*x%mod;\n\t\ty>>=1;\n\t}\n\treturn ret;\n}\n\nconst int maxn=250111;\nconst int mod1=998244353;\nconst int mod2=1e9+7;\nconst int base=443;\nconst int inv1=qpow(base,mod1-2,mod1);\nconst int inv2=qpow(base,mod2-2,mod2);\n\npii merge1(const pii&a,const pii&b){return mp(1ll*a.ff*b.ff%mod1,(1ll*a.ff*b.ss+a.ss)%mod1);}\npii merge2(const pii&a,const pii&b){return mp(1ll*a.ff*b.ff%mod2,(1ll*a.ff*b.ss+a.ss)%mod2);}\npair<pii,pii> merge(const pair<pii,pii>&a,const pair<pii,pii>&b){return mp(merge1(a.ff,b.ff),merge2(a.ss,b.ss));}\nint eval1(const int&a,const pii&b){return ((LL)a*b.ff+b.ss)%mod1;}\nint eval2(const int&a,const pii&b){return ((LL)a*b.ff+b.ss)%mod2;}\npii eval(const pii&a,const pair<pii,pii>&b){return mp(eval1(a.ff,b.ff),eval2(a.ss,b.ss));}\n\nint n;\npair<pii,pii> tran[maxn];\nchar s[maxn];\n\nint main()\n{\n\tscanf(\"%d%s\",&n,s+1);\n\t\n\tpii cur=mp(0,0);\n\ttran[n+1]=mp(mp(1,0),mp(1,0));\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tif(s[i]=='+')\n\t\t{\n\t\t\ttran[i]=merge(tran[i+1],mp(mp(1,1),mp(1,1)));\n\t\t\tcur=eval(cur,mp(mp(1,mod1-1),mp(1,mod2-1)));\n\t\t}\n\t\telse if(s[i]=='-')\n\t\t{\n\t\t\ttran[i]=merge(tran[i+1],mp(mp(1,mod1-1),mp(1,mod2-1)));\n\t\t\tcur=eval(cur,mp(mp(1,1),mp(1,1)));\n\t\t}\n\t\telse if(s[i]=='<')\n\t\t{\n\t\t\ttran[i]=merge(tran[i+1],mp(mp(base,0),mp(base,0)));\n\t\t\tcur=eval(cur,mp(mp(inv1,0),mp(inv2,0)));\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttran[i]=merge(tran[i+1],mp(mp(inv1,0),mp(inv2,0)));\n\t\t\tcur=eval(cur,mp(mp(base,0),mp(base,0)));\n\t\t}\n\t}\n\t\n\tLL ans=0;\n\tmap<pii,int> cnt;\n\tcnt[mp(0,0)]++;\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tans+=cnt[eval(cur,tran[i])];\n\t\tcnt[mp(tran[i].ff.ss,tran[i].ss.ss)]++;\n\t}\n\tprintendl(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AtCoder Regular Contest 099\n// Problem F - Eating Symbols Hard\n#include <cstdio>\n#include <cstring>\n#include <iostream>\nusing std::cin; using std::cout; using std::endl;\n#include <algorithm>\nusing std::sort;\n#include <vector>\nusing std::vector;\n#include <queue>\nusing std::queue; using std::priority_queue;\n#include <map>\nusing std::map;\n#include <utility>\nusing std::pair;\ntypedef pair<int, int> pii;\ntypedef long long LL;\n#define pass printf(\"%s : Line.%d\\n\", __FUNCTION__, __LINE__);\nconst int maxN = 250000 + 233; // 2.5e5\nint n;\nchar opt[maxN];\nint d[maxN], df; LL h1[maxN], hf1, h2[maxN], hf2;\n//const LL P = 1e9 + 7;\nbool isp(LL x) {\n\tfor(int i = 2; i*i <= x; ++i)\n\t\tif(x % i == 0) return false;\n\treturn true;\n}\nconst LL p1 = 1000000007;\nconst LL p2 = 1000000123;\nconst LL b1 = 107;\nconst LL b2 = 103;\nLL buc1[maxN*2], buc2[maxN*2];\nLL *pow1 = &buc1[maxN], *pow2 = &buc2[maxN];\nLL inv(LL x, LL p1) {\n\treturn x == 1 ? x : (p1 - (p1 / x) * inv(p1 % x, p1)) % p1;\n}\nLL inc(LL &a, LL b1, LL p1) { return (a += b1) >= p1 ? a -= p1 : a; }\nLL dec(LL &a, LL b1, LL p1) { return (a -= b1) < 0 ? a += p1 : a; }\nmap<pii, int> M;\n\nvoid init() {\n\tpow1[0] = 1; pow2[0] = 1;\n\tpow1[1] = b1; pow1[-1] = inv(b1, p1); pow2[1] = b2; pow2[-1] = inv(b2, p2);\n\tfor(int i = 1; i <= n; ++i) pow1[i] = pow1[i-1] * b1 % p1, pow2[i] = pow2[i-1] * b2 % p2;\n\tfor(int i = -1; i >= -n; --i) pow1[i] = pow1[i+1]* pow1[-1] % p1, pow2[i] = pow2[i+1]* pow2[-1] % p2;\n\thf1 = hf2 = df = 0;\n\tfor(int i = 1; i <= n; ++i) {\n\t\tswitch(opt[i]) {\n\t\t\tcase '+':\n\t\t\t\tinc(hf1, pow1[df], p1);\n\t\t\t\tinc(hf2, pow2[df], p2);\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tdec(hf1, pow1[df], p1);\n\t\t\t\tdec(hf2, pow2[df], p2);\n\t\t\t\tbreak;\n\t\t\tcase '>':\n\t\t\t\t++df;\n\t\t\t\tbreak;\n\t\t\tcase '<':\n\t\t\t\t--df;\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main() {\n//\tfor(int i = (int)1e9; ; ++i) if(isp(i)) printf(\"%d\\n\", i), getchar();\n//\tprintf(\"%.3lfMB\\n\", sizeof(buc1)*6/1000.0/1000.0);\n\tscanf(\"%d%s\", &n, opt + 1);\n\tinit();\n\tLL cnt = 0;\n\tM.clear();\n\th1[0] = h2[0] = d[0] = 0;\n\tM[pii((h1[0] + hf1 * pow1[d[0]]) % p1, (h2[0] + hf2 * pow2[d[0]]) % p2)] = 1;\n\tfor(int i = 1; i <= n; ++i) {\n\t\td[i] = d[i-1]; h1[i] = h1[i-1]; h2[i] = h2[i-1];\n\t\tswitch(opt[i]) {\n\t\t\tcase '+':\n\t\t\t\tinc(h1[i], pow1[d[i]], p1);\n\t\t\t\tinc(h2[i], pow2[d[i]], p2);\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tdec(h1[i], pow1[d[i]], p1);\n\t\t\t\tdec(h2[i], pow2[d[i]], p2);\n\t\t\t\tbreak;\n\t\t\tcase '>':\n\t\t\t\t++d[i];\n\t\t\t\tbreak;\n\t\t\tcase '<':\n\t\t\t\t--d[i];\n\t\t\t\tbreak;\n\t\t}\n\t\tpii c(h1[i], h2[i]), ins((h1[i] + hf1 * pow1[d[i]]) % p1, (h2[i] + hf2 * pow2[d[i]]) % p2);\n\t\tif(M.find(c) != M.end()) cnt += M[c]/*, printf(\"i = %d, cnt += %d\\n\", i, M[h1[i]])*/;\n\t\tif(M.find(ins) == M.end()) M[ins] = 1; else ++M[ins];\n\t}\n\tprintf(\"%lld\\n\", cnt);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<iostream>\n#define LL long long\n#define MP make_pair\nusing namespace std;\nconst LL mod=1e9+7;\nLL base[2],pre[2][500010],inv[2];\nstruct node{LL a,b;}op[2][250010];\nmap<pair<LL,LL>,LL> mp;\nLL pow(LL a,LL b)\n{\n\tLL ans=1;\n\twhile(b)\n\t{\n\t\tif(b&1) ans=ans*a%mod;\n\t\ta=a*a%mod;b>>=1;\n\t}\n\treturn ans;\n}\nLL n,p=0,t[500010],c[2],a[2][250010],b[2][250010];\nchar s[250010];\nvoid Pre()\n{\n\tfor(int k=0;k<2;k++)\n\t{\n\t\tLL cnt=1;op[k][n+1].a=1;\n\t\tfor(LL i=n;i>=1;i--)\n\t\t{\n\t\t\top[k][i]=op[k][i+1];\n\t\t\tif(s[i]=='<') cnt=cnt*base[k]%mod,(op[k][i].a*=base[k])%=mod;\n\t\t\tif(s[i]=='>') cnt=cnt*inv[k]%mod,(op[k][i].a*=inv[k])%=mod;\n\t\t\tif(s[i]=='-') (op[k][i].b+=cnt*pre[k][n]%mod)%=mod;\n\t\t\tif(s[i]=='+') op[k][i].b=((op[k][i].b-cnt*pre[k][n]%mod)%mod+mod)%mod;\n\t\t}\n\t}\n}\nvoid solve(LL *a,LL c,LL k) {for(LL i=1;i<=n;i++) a[i]=(c*op[k][i].a%mod+op[k][i].b)%mod;}\nint main()\n{\n\tbase[0]=2333;base[1]=10037;\n\tinv[0]=pow(base[0],mod-2);inv[1]=pow(base[1],mod-2);\n\tscanf(\"%lld\",&n);getchar();\n\tscanf(\"%s\",s+1);\n\tfor(LL k=0;k<2;k++)\n\t{\n\t\tpre[k][0]=1;for(LL i=1;i<=2*n;i++) pre[k][i]=pre[k][i-1]*base[k]%mod;\n\t}\n\tfor(LL i=1;i<=n;i++)\n\t{\n\t\tif(s[i]=='<') p--;if(s[i]=='>') p++;\n\t\tif(s[i]=='-') t[p+n]--;if(s[i]=='+') t[p+n]++;\n\t}\n\tfor(int k=0;k<2;k++)\n\t\tfor(LL i=-n;i<=n;i++) (c[k]+=pre[k][i+n]*t[i+n]%mod)%=mod;\n\tPre();\n\tsolve(a[0],0,0);solve(a[1],0,1);solve(b[0],c[0],0);solve(b[1],c[1],1);\n\tLL ans=0;\n\t//printf(\"c:%lld\\n\",c);\n\t//for(int i=1;i<=n;i++) printf(\"op:%lld %lld\\n\",op[i].a,op[i].b);\n\t//for(LL i=-n;i<=n;i++) printf(\"%lld:%lld %lld\\n\",i,t[i+n],pre[i+n]);printf(\"\\n\");\n\t//printf(\"a:\");for(int i=1;i<=n;i++) printf(\"%lld \",a[i]);printf(\"\\n\");\n\t//printf(\"b:\");for(int i=1;i<=n;i++) printf(\"%lld \",b[i]);printf(\"\\n\");\n\t//mp[c]++;\n\tfor(LL i=2;i<=n;i++)\n\t{\n\t\tmp[MP(b[0][i-1],b[1][i-1])]++;\n\t\tans+=mp[MP(a[0][i],a[1][i])];\n\t}\n\tmp[MP(b[0][n],b[1][n])]++;\n\tans+=mp[MP(0,0)];\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <unordered_map>\n#define FILL(a, n, x) memset((a), (x), sizeof ((a)[0]) * (n))\n#define COPY(a, n, b) memcpy((b), (a), sizeof ((a)[0]) * (n))\nusing namespace std;\n\ntypedef long long li;\nconst li infl = ~0LLU >> 2;\n\n// template <class T>\n// inline void Min(T &x, T y) {\n//   if (y < x) x = y;\n// }\n// template <class T>\n// inline void Max(T &x, T y) {\n//   if (y > x) x = y;\n// }\n\nconst int mod = 998244353;\ninline int Add(int x) { return x >= mod ? x - mod : x; }\ninline void Add(int &x, int y) { x += y; if (x >= mod) x -= mod; }\ninline int Sub(int x) { return x < 0 ? x + mod : x; }\ninline void Sub(int &x, int y) { x -= y; if (x < 0) x += mod; }\ninline int Mul(int x, int y) { return (int)((li)x * y % mod); }\ninline int Mul(int x, int y, int z) { return Mul(x, Mul(y, z)); }\nint Pow(int x, int y) {\n  int z = 1;\n  for (; y; y >>= 1) {\n    if (y & 1) z = Mul(z, x);\n    x = Mul(x, x);\n  }\n  return z;\n}\nint Inv(int x) {\n  return Pow(x, mod - 2);\n}\n\n// ----------------------------------------\n\nconst int maxn = 2.5e5;\nconst int base = 1000037, invbase = Inv(base);\n\nint _pow[maxn * 2 + 1], *pow = _pow + maxn;\n\nvoid Init(int n) {\n  pow[0] = 1;\n  for (int i = 1; i <= n; ++i) {\n    pow[i] = Mul(pow[i - 1], base);\n    pow[-i] = Mul(pow[-i + 1], invbase);\n  }\n}\n\nint n;\nchar str[maxn + 1];\nint delta[maxn + 1], sum[maxn + 1];\n\nint main(void) {\n  scanf(\"%d%s\", &n, str);\n  Init(n);\n  delta[0] = 0;\n  sum[0] = 0;\n  for (int i = 1; i <= n; ++i) {\n    switch (str[i - 1]) {\n    case '+':\n      delta[i] = delta[i - 1];\n      sum[i] = Add(sum[i - 1] + pow[delta[i]]);\n      break;\n    case '-':\n      delta[i] = delta[i - 1];\n      sum[i] = Sub(sum[i - 1] - pow[delta[i]]);\n      break;\n    case '<':\n      delta[i] = delta[i - 1] - 1;\n      sum[i] = sum[i - 1];\n      break;\n    case '>':\n      delta[i] = delta[i - 1] + 1;\n      sum[i] = sum[i - 1];\n      break;\n    }\n  }\n  unordered_map<int, int> cnt;\n  li ans = 0;\n  for (int i = n; i >= 0; --i) {\n    if (i < n) {\n      int target = Add(sum[i] + Mul(pow[delta[i]], sum[n]));\n      ans += cnt[target];\n    }\n    ++cnt[sum[i]];\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author aajisaka\n */\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n#define SPEED ios_base::sync_with_stdio(false);cin.tie(nullptr)\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define all(v) v.begin(), v.end()\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing P = pair<ll, ll>;\n\nconstexpr long double PI = 3.14159265358979323846264338327950288L;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nconstexpr ll mod17 = 1e9+7;\nconstexpr ll mod19 = 1e9+9;\nconstexpr ll mod9 = 998244353;\nll mod = mod17;\n\n// Mod int libraries\ntemplate<typename T>\nT mod_pow(T a, ll x) {\n  T res = 1;\n  while(x > 0) {\n    if (x & 1) res *= a;\n    a *= a; x >>= 1;\n  }\n  return res;\n}\n\n// Mint32\nunordered_map<ll, ll> minvmap;\nll minv(ll a, ll m) {\n  auto k = a; auto p = minvmap[a]; if (p != 0) return p;\n  ll b = m, u = 1, v = 0;\n  while (b) { ll t = a/b; swap(a -= t*b, b); swap(u -= t*v, v); }\n  p = (u%m+m)%m; minvmap[k] = p; return p;\n}\n\nstruct mint {\n  ll x;\n  mint():x(0){}\n  mint(ll x):x((x%mod+mod)%mod){}\n  mint& fix() { x = (x%mod+mod)%mod; return *this;}\n  mint operator-() const { return mint(0) - *this;}\n  mint& operator+=(const mint& a){ if((x+=a.x)>=mod) x-=mod; return *this;}\n  mint& operator-=(const mint& a){ if((x+=mod-a.x)>=mod) x-=mod; return *this;}\n  mint& operator*=(const mint& a){ (x*=a.x)%=mod; return *this;}\n  mint& operator/=(const mint& a){ (x*=minv(a.x, mod))%=mod; return *this; }\n  mint operator+(const mint& a)const{ return mint(*this) += a;}\n  mint operator-(const mint& a)const{ return mint(*this) -= a;}\n  mint operator*(const mint& a)const{ return mint(*this) *= a;}\n  mint operator/(const mint& a)const{ return mint(*this) /= a;}\n  bool operator<(const mint& a)const{ return x < a.x;}\n  bool operator==(const mint& a)const{ return x == a.x;}\n};\n\n// Mint64\nstruct mint64 {\n    ull x;\n    static ull mod, inv, r2;\n    mint64(): x(0){}\n    mint64(ull x): x(init(x)) {}\n    static ull init(ull x) { return reduce(__uint128_t(x)*r2);}\n    static void set_mod(ull m) {\n      mod = inv = m;\n      for(int i=0; i<5; i++) inv *= 2 - inv*m;\n      r2 = -__uint128_t(m)%m;\n    }\n    static ull reduce(__uint128_t x) {\n      ull y = ull(x >> 64) - ull((__uint128_t(ull(x)*inv)*mod)>>64);\n      return ll(y) < 0 ? y+mod : y;\n    }\n    mint64& operator+=(mint64& a) { x+=a.x-mod; if(ll(x)<0) x+=mod; return *this; }\n    mint64 operator+(mint64& a) const{ return mint64(*this)+=a; }\n    mint64& operator*=(mint64& a) { x=reduce(__uint128_t(x)*a.x); return *this; }\n    mint64 operator*(mint64& a) const { return mint64(*this)*=a; }\n};\n\null mint64::mod, mint64::inv, mint64::r2;\n\n// Verify: https://yukicoder.me/submissions/472580\nstruct Miller {\n    const vector<ull> v = {2, 325, 9375, 28178, 450775, 9780504, 1795265022};\n    bool suspect(ull a, ull s, ull d, ull n) {\n      if (mint64::mod != n) mint64::set_mod(n);\n      mint64 one = 1, minusone = n-1, ma = a;\n      auto x = mod_pow(ma, d);\n      if (x.x == one.x) return true;\n      for(int r = 0; r < s; r++) {\n        if (x.x == minusone.x) return true;\n        x = x * x;\n      }\n      return false;\n    }\n\n    // check if n is prime\n    bool check(ull n) {\n      if (n < 2 || (n > 2 && n % 2 == 0)) return false;\n      ull d = n - 1;\n      ull s = 0;\n      while (!(d & 1)) {\n        d >>= 1;\n        s++;\n      }\n      for (auto a: v) {\n        if (a >= n) break;\n        if (!suspect(a, s, d, n)) return false;\n      }\n      return true;\n    }\n};\n\nclass combination {\n    // factorial\n    public: std::vector<mint> fact;\n    public: std::vector<mint> inv;\n\n    combination(int n) {\n      fact.resize(n + 1);\n      inv.resize(n + 1);\n      fact[0] = 1;\n      for (int i = 1; i <= n; i++) {\n        fact[i] = fact[i - 1] * i;\n      }\n      inv[n] = mint(1) / fact[n];\n      for (int i = n - 1; i >= 0; i--) {\n        inv[i] = inv[i + 1] * (i + 1);\n      }\n    }\n\n    // nCr\n    public: mint get(int n, int r) {\n      if (n < r || n < 0 || r < 0) return 0;\n      return fact[n]*inv[r]*inv[n-r];\n    }\n    // nPr\n    public: mint p(int n, int r) {\n      if (n < r || n < 0) return 0;\n      return fact[n]*inv[n-r];\n    }\n};\n\n\nclass FEatingSymbolsHard {\npublic:\n    void solve(istream& cin, ostream& cout) {\n      SPEED;\n      int n; cin >> n;\n      string s; cin >> s;\n      vector<mint> base = {983, 9059, 10009, 99991};\n      vector<mint> invBase(4);\n      rep(i, 4) {\n        invBase[i] = mint(1)/base[i];\n      }\n      vector<int> pos(n+1);\n      vector<vector<mint>> vec(4, vector<mint>(n+1));\n\n      vector<vector<mint>> bm(4, vector<mint>(500001));\n      rep(i, 4) {\n        bm[i][250000] = 1;\n        for(int j=250001; j<=500000; j++) {\n          bm[i][j] = bm[i][j-1] * base[i];\n        }\n        for(int j=249999; j>=0; j--) {\n          bm[i][j] = bm[i][j+1] * invBase[i];\n        }\n      }\n      pos[0] = 250000;\n\n      rep(i, n) {\n        pos[i+1] = pos[i];\n        rep(k, 4) {\n          vec[k][i+1] = vec[k][i];\n        }\n        if (s[i] == '+') {\n          rep(k, 4) {\n            vec[k][i+1] += bm[k][pos[i]];\n          }\n        } else if (s[i] == '-') {\n          rep(k, 4) {\n            vec[k][i+1] -= bm[k][pos[i]];\n          }\n        } else if (s[i] == '<') {\n          pos[i+1]--;\n        } else {\n          pos[i+1]++;\n        }\n      }\n\n      map<mint, ll> mp[4];\n      ll ans = 0;\n      for(int i=n; i>=0; i--) {\n        map<int, int> cnt;\n        rep(k, 4) {\n          mint r = bm[k][pos[i]];\n          auto q = vec[k][i] + vec[k][n] * r;\n          if (mp[k].find(q) == mp[k].end()) {\n            cnt[0]++;\n          } else {\n            cnt[mp[k][q]]++;\n          }\n        }\n        bool flag = false;\n        for(auto e: cnt) {\n          if (e.second >= 3) {\n            ans += e.first;\n            flag = true;\n          }\n        }\n        assert(flag);\n        rep(k, 4) {\n          mp[k][vec[k][i]]++;\n        }\n      }\n\n      cout << ans << endl;\n\n    }\n};\n\nsigned main() {\n  FEatingSymbolsHard solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <random>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\n\nconst ll MOD=1e9+7;\nconst int med=250000;\nll powmod(ll a, ll k){\n    ll ap=a, ans=1;\n    while(k>0){\n        if(k%2==1){\n            ans*=ap;\n            ans%=MOD;\n        }\n        ap=ap*ap;\n        ap%=MOD;\n        k/=2;\n    }\n    return ans;\n}\nll inv(ll a){\n\treturn powmod(a, MOD-2);\n}\n\nint main()\n{\n\tint n;\n\tcin>>n;\n\tstring s; cin>>s;\n    random_device rnd;\n\tmt19937_64 mt(rnd());\n\tuniform_int_distribution<ll> rndn(2, MOD-2);\n\tll b=rndn(mt);\n\tll binv=inv(b);\n\tll bp[500001];\n\tbp[med]=1;\n\tfor(int i=med+1; i<=med+n; i++) bp[i]=bp[i-1]*b%MOD;\n\tfor(int i=med-1; i>=med-n; i--) bp[i]=bp[i+1]*binv%MOD;\n\tll b0=0; int p=med;\n\tfor(int i=0; i<n; i++){\n\t\tif(s[i]=='+'){\n\t\t\tb0=(b0+bp[p])%MOD;\n\t\t}else if(s[i]=='-'){\n\t\t\tb0=(b0+MOD-bp[p])%MOD;\n\t\t}else if(s[i]=='>'){\n\t\t\tp++;\n\t\t}else{\n\t\t\tp--;\n\t\t}\n\t}\n\tll ans=0;\n\tll x[250000]={};\n\tunordered_map<ll, int> mp[500];\n\tint c1[500]={};\n\tll c0[500]={};\n\tint sq=2000;\n\tfor(int i=0; i<n; i++){\n\t\tif(s[n-1-i]=='+'){\n\t\t\tfor(int j=i/sq*sq; j<=i; j++){\n\t\t\t\tx[j]=(x[j]+1)%MOD;\n\t\t\t}\n\t\t\tfor(int j=0; j<i/sq; j++){\n\t\t\t\tc0[j]=(c0[j]+1)%MOD;\n\t\t\t}\n\t\t}else if(s[n-1-i]=='-'){\n\t\t\tfor(int j=i/sq*sq; j<=i; j++){\n\t\t\t\tx[j]=(x[j]+MOD-1)%MOD;\n\t\t\t}\n\t\t\tfor(int j=0; j<i/sq; j++){\n\t\t\t\tc0[j]=(c0[j]+MOD-1)%MOD;\n\t\t\t}\n\t\t}else if(s[n-1-i]=='>'){\n\t\t\tfor(int j=i/sq*sq; j<=i; j++){\n\t\t\t\tx[j]=x[j]*b%MOD;\n\t\t\t}\n\t\t\tfor(int j=0; j<i/sq; j++){\n\t\t\t\tc1[j]++;\n\t\t\t\tc0[j]=c0[j]*b%MOD;\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int j=i/sq*sq; j<=i; j++){\n\t\t\t\tx[j]=x[j]*binv%MOD;\n\t\t\t}\n\t\t\tfor(int j=0; j<i/sq; j++){\n\t\t\t\tc1[j]--;\n\t\t\t\tc0[j]=c0[j]*binv%MOD;\n\t\t\t}\n\t\t}\n\t\tfor(int j=0; j<i/sq; j++){\n\t\t\tll x0=(b0-c0[j]+MOD)*bp[med-c1[j]]%MOD;\n\t\t\tauto itr=mp[j].find(x0);\n          if(itr!=mp[j].end()) ans+=((ll)(itr->second));\n\t\t}\n\t\tfor(int j=i/sq*sq; j<=i; j++){\n\t\t\tif(b0==x[j]) ans++;\n\t\t}\n\t\tif((i+1)%sq==0){\n\t\t\tfor(int j=i/sq*sq; j<=i; j++){\n\t\t\t\tmp[i/sq][x[j]]++;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n\nusing u64 = unsigned long long;\n\nconst u64 B = 13131;\nconst int N = 500000 + 7;\n\nint n;\nchar s[N];\nu64 f[N];\nint g[N];\nstd::map<u64, u64> map;\nu64 cnt;\n\nu64 pow(u64 a, u64 k) {\n\tif (k < 0) k += (1llu << 63) - 1;\n\tu64 t = 1;\n\tfor (; k; a = a * a, k >>= 1)\n\t\tif (k & 1) t = t * a;\n\treturn t;\n}\n\nint main() {\n//\tfreopen(\"code.in\", \"r\", stdin);\n//\tfreopen(\"code.out\", \"w\", stdout);\n\n\tscanf(\"%d%s\", &n, s + 1);\n\tfor (int i = 1; i <= n; ++i)\n\t\tif (s[i] == '+' || s[i] == '-')\n\t\t\tf[i] = f[i - 1] + (s[i] == '+' ? 1 : -1) * pow(B, g[i] = g[i - 1]);\n\t\telse\n\t\t\tf[i] = f[i - 1], g[i] = g[i - 1] + (s[i] == '<' ? -1 : 1);\n\tfor (int i = n; i; --i)\n\t\t++map[f[i]], cnt += map[f[n] * pow(B, g[i - 1]) + f[i - 1]];\n\tprintf(\"%lld\\n\", cnt);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define MAX 500012\n\nint n;\nchar buf[MAX];\n\n\nstring s;\n\n\n//#define MOD1 1000000007\n//#define MOD2 1000000009\n\nvalarray<long long int> MOD1;\nvalarray<long long int> MOD2;\nvector<valarray<long long int> > p2;\nvector<valarray<long long int> > vv;\nvector<int> ps;\nmap<long long int, int> mp;\nlong long int ppow(long long int i, long long int j, long long int MOD) {\n\tlong long int ret = 1;\n\twhile (j) {\n\t\tif (j & 1LL)ret *= i;\n\t\tif (ret >= MOD)ret %= MOD;\n\t\tj >>= 1LL;\n\t}\n\treturn ret;\n}\n\nvalarray<long long int> calc(int dif) {\n\tvalarray<long long int> ret;\n\tret.resize(2, 0);\n\tfor (int j = 0; j < 2; j++) {\n\t\tif (dif < 0) {\n\t\t\tret[j]=ppow(ppow(MOD1[j], abs(dif),MOD2[j]), MOD2[j] - 2,MOD2[j]);\n\t\t}\n\t\telse {\n\t\t\tret[j] = ppow(MOD1[j], abs(dif), MOD2[j]);\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main() {\n\tMOD1.resize(2);\n\tMOD2.resize(2);\n\tp2.push_back(valarray<long long int>());\n\tp2.back().resize(2);\n\tp2.back()[0] = p2.back()[1] = 1;\n\tMOD1[0] = 1000000007;\n\tMOD2[0] = 1000000009;\n\tMOD1[1] = 1000000009;\n\tMOD2[1] = 1000000007;\n\tp2[0] %= MOD2;\n\tfor (int i = 1; i < MAX; i++) {\n\t\tp2.push_back(p2.back());\n\t\tp2[i] *= MOD1;\n\t\tp2[i] %= MOD2;\n\t}\n\tcin >> n;\n\tscanf(\"%s\", buf);\n\ts = buf;\n\tint pos = MAX/2;\n\tvalarray<long long int> hs;\n\ths.resize(2);\n\ths[0] = hs[1] = 0;\n\tvv.push_back(hs);\n\tps.push_back(pos);\n\tfor (int i = 0; i < s.size(); i++) {\n\t\tif (s[i] == '<') {\n\t\t\tpos--;\n\t\t}\n\t\tif (s[i] == '>') {\n\t\t\tpos++;\n\t\t}\n\t\tif (s[i] == '+') {\n\t\t\ths += p2[pos];\n\t\t}\n\t\tif (s[i] == '-') {\n\t\t\ths -= p2[pos];\n\t\t\ths += MOD2;\n\t\t}\n\t\ths %= MOD2;\n\t\tvv.push_back(hs);\n\t\tps.push_back(pos);\n\t}\n\tlong long int way = 0;\n\tfor (int i = vv.size() - 1; i >= 0; i--) {\n\t\tauto want = vv[i] + vv.back()*calc(-MAX/2+ps[i]);\n\t\twant %= MOD2;\n\t\tway += mp[want[0] * MOD1[0] + want[1]];\n\t\t//cerr << \"dbg \" << way << endl;\n\t\tmp[vv[i][0]*MOD1[0]+vv[i][1]]++;\n\t}\n\tprintf(\"%lld\\n\", way);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 200000;\n\nconstexpr int inv(int a, int m) {\n  return a == 1 ? 1 : 1LL * (m - m / a) * inv(m % a, m) % m;\n}\n\nconst int BASE = 2;\nconst int M = 2;\nconst int MODS[] = {1000000007, 1000000009};\n\n// template <int BASE, int... INTS> struct HashT {\nstruct HashT {\n  // static constexpr int M = sizeof...(INTS);\n  // static constexpr std::array<int, M> MODS = {INTS...};\n\n  explicit HashT(int a) {\n    for (int i = 0; i < M; ++i) {\n      h[i] = a;\n    }\n  }\n\n  explicit HashT(const HashT &a, const HashT &b) {\n    for (int i = 0; i < M; ++i) {\n      h[i] = 1LL * a.h[i] * b.h[i] % MODS[i];\n    }\n  }\n\n  explicit HashT(const HashT &k, const HashT &b, const HashT &bf) {\n    for (int i = 0; i < M; ++i) {\n      h[i] = 1LL * k.h[i] * (b.h[i] + MODS[i] - bf.h[i]) % MODS[i];\n    }\n  }\n\n  template <int a> void add() {\n    for (int i = 0; i < M; ++i) {\n      h[i] += a >= 0 ? a : MODS[i] + a;\n      if (h[i] >= MODS[i]) {\n        h[i] -= MODS[i];\n      }\n    }\n  }\n\n  void multiplyB() {\n    for (int i = 0; i < M; ++i) {\n      h[i] = 1LL * h[i] * BASE % MODS[i];\n    }\n  }\n\n  void divideB() {\n    for (int i = 0; i < M; ++i) {\n      h[i] = 1LL * h[i] * inv(BASE, MODS[i]) % MODS[i];\n    }\n  }\n\n  int h[M];\n};\n\n// template <int BASE, int... INTS>\n// bool operator<(const HashT<BASE, INTS...> &a, const HashT<BASE, INTS...> &b) {\n// bool operator<(const HashT<BASE, INTS...> &a, const HashT<BASE, INTS...> &b) {\n//   for (int i = 0; i < HashT<BASE, INTS...>::M; ++i) {\nbool operator<(const HashT &a, const HashT &b) {\n  for (int i = 0; i < M; ++i) {\n    if (a.h[i] != b.h[i]) {\n      return a.h[i] < b.h[i];\n    }\n  }\n  return false;\n}\n\nint n;\nchar s[N + 1];\n\n// using Hash = HashT<3, 1000000007, 1000000009>;\nusing Hash = HashT;\n\nstruct Set {\n  Set() : k{1}, b{0} {}\n\n  void add(int c) {\n    if (c == '+') {\n      b.add<-1>();\n    } else if (c == '-') {\n      b.add<1>();\n    } else if (c == '>') {\n      b.multiplyB();\n      k.divideB();\n    } else {\n      k.multiplyB();\n      b.divideB();\n    }\n  }\n\n  Hash zero() const { return Hash{k, b}; }\n  Hash inverse(const Hash &kb) const { return Hash{k, b, kb}; }\n\n  Hash k, b;\n};\n\nint main() {\n  while (scanf(\"%d%s\", &n, s) == 2) {\n    Set setf;\n    for (int i = n - 1; i >= 0; --i) {\n      setf.add(s[i]);\n    }\n    Set set;\n    long long result = 0;\n    std::map<Hash, int> cnt;\n    for (int i = n - 1; i >= 0; --i) {\n      cnt[set.zero()]++;\n      set.add(s[i]);\n      result += cnt[set.inverse(setf.b)];\n    }\n    printf(\"%lld\\n\", result);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN=25010,MAXK=410,P=1e9+7;\nint n,m,k,cnt[MAXN],a[MAXN],las[MAXN],sum[MAXN][MAXK],sufsum[MAXN][MAXK],dp[MAXN][MAXK],suf[MAXN][MAXK];\nint qpow (int a,int b) {\n    int res=1;\n    while (b) {\n        if (b&1) {res=(1ll*res*a)%P;}\n        a=(1ll*a*a)%P,b>>=1;\n    }\n    return res;\n}\nint main () {\n //   freopen(\"f.in\",\"r\",stdin);\n   // freopen(\"f.out\",\"w\",stdout);\n    scanf(\"%d%d%d\",&n,&k,&m);\n    int kd=0;\n    for (int i=1;i<=m;i++) {\n        scanf(\"%d\",&a[i]);\n        if (cnt[a[i]]) {kd=1,las[i]=cnt[a[i]];}\n        cnt[a[i]]=i;\n    }\n    int tmp=0,flg=0;\n    for (int i=1;i<=m;i++) {\n        tmp=max(tmp,las[i]);\n        if (tmp<i-k+1) {flg=1;}\n    }\n    if (flg) {\n        int ans1=(1ll*(n-m+1)*qpow(k,n-m))%P;\n        printf(\"%d\\n\",ans1);\n        return 0;\n    }\n    if (kd) {\n        int cur=1;\n        memset(cnt,0,sizeof(cnt));\n        for (int i=1;i<=m;i++) {\n            if (cnt[a[i]]) {cur=i-1;break;}\n            cnt[a[i]]++;\n        }\n        sum[0][cur]=1;\n        for (int i=0;i<=cur;i++) {sufsum[0][i]=1;}\n        for (int i=1;i<=n;i++) {\n            for (int j=k-1;j>=1;j--) {\n                sum[i][j]=((1ll*sum[i-1][j-1]*(k-j+1))%P+sufsum[i-1][j])%P;\n                sufsum[i][j]=(sufsum[i][j+1]+sum[i][j])%P;\n            }\n        }\n        memset(cnt,0,sizeof(cnt));\n        for (int i=m;i>=1;i--) {\n            if (cnt[a[i]]) {cur=m-i;break;}\n            cnt[a[i]]++;\n        }\n        dp[0][cur]=1;\n        for (int i=0;i<=cur;i++) {suf[0][i]=1;}\n        for (int i=1;i<=n;i++) {\n            for (int j=k-1;j>=1;j--) {\n                dp[i][j]=((1ll*dp[i-1][j-1]*(k-j+1))%P+suf[i-1][j])%P;\n                suf[i][j]=(suf[i][j+1]+dp[i][j])%P;\n            }\n        }\n        int ans1=(1ll*(n-m+1)*qpow(k,n-m))%P,ans2=0;\n        for (int i=1;i<=n-m+1;i++) {\n            ans2=(ans2+(1ll*sufsum[i-1][1]*suf[n-(m+i-1)][1])%P)%P;\n        }\n        printf(\"%d\\n\",(ans1-ans2+P)%P);\n    } else {\n        int ans1=(1ll*(n-m+1)*qpow(k,n-m))%P,ans2=0;\n        if (m>=k) {printf(\"%d\\n\",ans1);return 0;}\n        dp[0][0]=suf[0][0]=1;\n        for (int i=1;i<=n;i++) {\n            for (int j=k-1;j>=1;j--) {\n                sum[i][j]=((1ll*sum[i-1][j-1]*(k-j+1))%P+sufsum[i-1][j])%P;\n                dp[i][j]=((1ll*dp[i-1][j-1]*(k-j+1))%P+suf[i-1][j])%P;\n                suf[i][j]=(suf[i][j+1]+dp[i][j])%P;\n                if (j>=m) {sum[i][j]=(sum[i][j]+dp[i][j])%P;}\n                sufsum[i][j]=(sufsum[i][j+1]+sum[i][j])%P;\n                //cout << i << \"  \" << j << \"  \" << dp[i][j] << \"  \" << sum[i][j] << endl;\n            }\n        }\n        ans2=sufsum[n][1];\n        //cout << ans2 << endl;\n        for (int i=k;i>=k-m+1;i--) {ans2=(1ll*ans2*qpow(i,P-2))%P;}\n        //cout << ans1 << \"  \" << ans2 << endl;\n        printf(\"%d\\n\",(ans1-ans2+P)%P);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nconst int pmod = 1e9 + 7;\nconst int qmod = 1e9 + 9;\n\nstruct hash_t {\n  int p, q;\n  hash_t() {\n    \n  }\n  hash_t(int x, int y) : p(x), q(y) {\n  } \n  \n  bool operator < (const hash_t &b) const {\n    return make_pair(p, q) < make_pair(b.p, b.q);\n  }\n};\n\nvoid exgcd(int a, int b, int &x, int &y) {\n  if (!b)\n    x = 1, y = 0;\n  else\n    exgcd(b, a % b, y, x), y -= (a / b) * x;\n}\n\nint mod_inv(int a, int p) {\n  int x, y;\n  exgcd(a, p, x, y);\n  assert((ll) (x % p + p) % p * a % p == 1);\n  return (x % p + p) % p;\n}\nhash_t operator + (hash_t x, hash_t y) {\n  return hash_t((x.p + y.p) % pmod, (x.q + y.q) % qmod);\n}\nhash_t operator - (hash_t x, hash_t y) {\n  return hash_t((x.p + pmod - y.p) % pmod, (x.q + qmod - y.q) % qmod);\n} \nhash_t operator * (hash_t x, hash_t y) {\n  return hash_t((ll) x.p * y.p % pmod, (ll) x.q * y.q % qmod);\n}\nhash_t operator / (hash_t x, hash_t y) {\n  return hash_t((ll) x.p * mod_inv(y.p, pmod) % pmod, (ll) x.q * mod_inv(y.q, qmod) % qmod);\n}\n\nconst int MaxN = 250010;\n\nint n; char s[MaxN];\nhash_t a[MaxN], b[MaxN];\nhash_t x = hash_t(20010403, 20010423);\n\nint main() {\n  scanf(\"%d%s\", &n, s + 1);\n  a[n + 1] = hash_t(1, 1);\n  for (int i = n; i; i--) {\n    char c = s[i];\n    if (c == '+') {\n      a[i] = a[i + 1];\n      b[i] = b[i + 1] + hash_t(1, 1);\n    }\n    if (c == '-') {\n      a[i] = a[i + 1];\n      b[i] = b[i + 1] - hash_t(1, 1);\n    }\n    if (c == '>') {\n      a[i] = a[i + 1] * x;\n      b[i] = b[i + 1] * x;\n    } \n    if (c == '<') {\n      a[i] = a[i + 1] / x;\n      b[i] = b[i + 1] / x;\n    }\n  } \n  \n  map<hash_t, int> h;\n  \n  ll ans = 0;\n  for (int i = n; i; i--) {\n    ++h[b[i + 1] / a[i + 1]];\n    ans += h[(b[i] - b[1]) / a[i]];\n  }\n  cout << ans << \"\\n\";\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=300005,p=998244353;\nint read(){\n\tint f=1,g=0;\n\tchar ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-') f=-1;\n\tfor (;isdigit(ch);ch=getchar()) g=g*10+ch-'0';\n\treturn f*g;\n}\nint qpow(int x,int k){\n\tint t=1;\n\tfor (;k;k>>=1){\n\t\tif (k&1) t=(ll)t*x%p;\n\t\tx=(ll)x*x%p;\n\t}\n\treturn t;\n}\nstruct state{\n\tint a[6];\n\tint &operator[](int i){return a[i];}\n\tstate(){memset(a,0,sizeof(a));}\n}x,rx,s[N][2],c,e;\nbool operator==(state a,state b){\n\tfor (int i=0;i<6;i++)\n\tif (a[i]==b[i]) return false;\n\treturn true;\n}\nbool operator<(state a,state b){\n\tfor (int i=0;i<6;i++)\n\tif (a[i]!=b[i]) return a[i]<b[i];\n\treturn false;\n}\nstate operator*(state x,state y){for (int i=0;i<6;i++) x[i]=(ll)x[i]*y[i]%p;return x;}\nstate operator+(state x,state y){for (int i=0;i<6;i++) if((x[i]+=y[i])>=p) x[i]-=p;return x;}\nstate operator-(state x,state y){for (int i=0;i<6;i++) if((x[i]-=y[i])<0) x[i]+=p;return x;}\nstate operator+(state x,int k){for (int i=0;i<6;i++) if ((x[i]+=k)>=p) x[i]-=p;return x;}\nstate operator-(state x,int k){for (int i=0;i<6;i++) if ((x[i]-=k)<0) x[i]+=p;return x;}\nstate getval(state *a,state x){\n\tstate cur=a[0]+a[1]*x;\n\treturn cur;\n}\nint n,m;\nll ans;\nchar ch[N];\nmap<state,int> f;\nint main(){\n\tfor (int i=0;i<6;i++) x[i]=i+1,rx[i]=qpow(x[i],p-2);\n\tn=read();\n\tscanf(\" %s\",ch+1);\n\tfor (int i=0;i<6;i++) s[n+1][1][i]=1;\n\tfor (int i=n;i;i--)\n\tif (ch[i]=='+'){s[i][0]=s[i+1][0]+s[i+1][1];s[i][1]=s[i+1][1];c=c-1;}\n\telse if (ch[i]=='-'){s[i][0]=s[i+1][0]-s[i+1][1];s[i][1]=s[i+1][1];c=c+1;}\n\telse if (ch[i]=='>'){s[i][0]=s[i+1][0];s[i][1]=s[i+1][1]*x;c=c*rx;}\n\telse if (ch[i]=='<'){s[i][0]=s[i+1][0];s[i][1]=s[i+1][1]*rx;c=c*x;}\n\tfor (int i=n;i;i--){\n\t\tf[getval(s[i+1],e)]++;\n\t\tans+=f[getval(s[i],c)];\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<map>\nusing namespace std;\nconst int N=250005;\nconst int mod=998244853;\nconst int base=20020415;\nint n,pw[N],ipw[N],pos[N],val[N];\nchar str[N];long long ans;\nmap<int,int>Map;\nint fastpow(int x,int y){\n\tint res=1;\n\twhile(y){if(y&1)res=1ll*res*x%mod;x=1ll*x*x%mod;y>>=1;}\n\treturn res;\n}\nint cal(int x){\n\treturn x>0?pw[x]:ipw[-x];\n}\nint main(){\n\tscanf(\"%d%s\",&n,str+1);\n\tpw[0]=ipw[0]=1;pw[1]=base;ipw[1]=fastpow(base,mod-2);\n\tfor(int i=2;i<=n;++i){\n\t\tpw[i]=1ll*pw[i-1]*pw[1]%mod;\n\t\tipw[i]=1ll*ipw[i-1]*ipw[1]%mod;\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tif(str[i]=='+'){\n\t\t\tpos[i]=pos[i-1];\n\t\t\tval[i]=(val[i-1]+cal(pos[i]))%mod;\n\t\t}\n\t\tif(str[i]=='-'){\n\t\t\tpos[i]=pos[i-1];\n\t\t\tval[i]=(val[i-1]+mod-cal(pos[i]))%mod;\n\t\t}\n\t\tif(str[i]=='>'){\n\t\t\tpos[i]=pos[i-1]+1;\n\t\t\tval[i]=val[i-1];\n\t\t}\n\t\tif(str[i]=='<'){\n\t\t\tpos[i]=pos[i-1]-1;\n\t\t\tval[i]=val[i-1];\n\t\t}\n\t\t++Map[val[i]];\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tint x=(1ll*val[n]*cal(pos[i-1])+val[i-1])%mod;\n\t\tans+=Map[x];--Map[val[i]];\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define fst first\n#define snd second\n#define SZ(u) ((int) (u).size())\n#define ALL(u) (u).begin(), (u).end()\n\ninline void proc_status()\n{\n    ifstream t(\"/proc/self/status\");\n    cerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline T read()\n{\n\tregister T sum(0), fg(1);\n\tregister char ch(getchar());\n\tfor(; !isdigit(ch); ch = getchar()) if(ch == '-') fg = -1;\n\tfor(;  isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) - '0' + ch;\n\treturn sum * fg;\n}\n\ntypedef unsigned long long LL;\ntypedef long double LD;\ntypedef pair<int, int> pii;\n\nconst int MAXN = (int) 2.5e5;\n\nint n;\n\nchar s[MAXN + 5];\n\ninline void input()\n{\n\tn = read<int>();\n\tscanf(\"%s\", s + 1);\n}\n\nconst LL MOD = ULLONG_MAX, B = (int) 233;\n\ninline LL fpm(LL x, LL y)\n{\n\tLL res = 1;\n\tfor(; y; y >>= 1, x = (LL) x * x % MOD) if(y & 1) res = (LL) res * x % MOD;\n\treturn res;\n}\n\ninline void solve()\n{\n\t// Thanks to zhou888\n\n\tstatic LL p[MAXN + 5], prefix[MAXN + 5], p_pow[MAXN * 2 + 5];\n\n\tp_pow[0 + n] = 1;\n\tfor(int i = 1, invB = fpm(B, MOD - 2); i <= n; ++i)\n\t{\n\t\tp_pow[ i + n] = (LL) p_pow[ i - 1 + n] *\tB % MOD;\n\t\tp_pow[-i + n] = (LL) p_pow[-i + 1 + n] * invB % MOD;\n\t}\n\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tp[i] = p[i - 1], prefix[i] = prefix[i - 1];\n\t\tif(s[i] == '<') --p[i];\n\t\tif(s[i] == '>') ++p[i];\n\t\tif(s[i] == '+') (prefix[i] += p_pow[p[i] + n]) %= MOD;\n\t\tif(s[i] == '-') (prefix[i] -= p_pow[p[i] + n]) %= MOD;\n\t}\n\tfor(int i = 1; i <= n; ++i) (prefix[i] += MOD) %= MOD;\n\n\tstatic unordered_map<LL, int> cnt;\n\n\tLL ans = 0;\n\tfor(int i = 1; i <= n; ++i) ans += prefix[i] == prefix[n];\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tans += cnt[prefix[i]];\n\t\tLL res = (prefix[i] + (LL) p_pow[p[i] + n] * prefix[n] % MOD) % MOD;\n\t\t++cnt[res];\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main()\n{\n//\tfreopen(\"F.in\", \"r\", stdin);\n//\tfreopen(\"F.out\", \"w\", stdout);\n\n\tinput();\n\tsolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int, int> pii;\n\nconst int MAXN = 2e5 + 5;\nconst int BASE = 3137;\nconst int MOD1 = 1e9 + 7;\nconst int MOD2 = 1e9 + 9;\n\nint N;\nchar s[MAXN];\npii pref[MAXN], pot[MAXN];\nmap <pii, int> cnt;\n\nvoid load() {\n\tscanf(\"%d%s\", &N, s + 1);\n}\n\ninline int add(int x, int y, int mod) {\n\tx += y;\n\tif (x >= mod)\n\t\tx -= mod;\n\telse if (x < 0)\n\t\tx += mod;\n\treturn x;\n}\n\ninline int mul(int x, int y, int mod) {\n\treturn (ll)x * y % mod;\n}\n\nint power(int x, int y, int mod) {\n\tint res = 1;\n\tfor (; y; y /= 2) {\n\t\tif (y % 2)\n\t\t\tres = mul(res, x, mod);\n\t\tx = mul(x, x, mod);\n\t}\n\treturn res;\n}\n\npii operator +(const pii &l, const pii &r) {\n\treturn {add(l.first, r.first, MOD1), add(l.second, r.second, MOD2)};\n}\n\npii operator *(const pii &l, const pii &r) {\n\treturn {mul(l.first, r.first, MOD1), mul(l.second, r.second, MOD2)};\n}\n\nll solve() {\n\tint inv1 = power(BASE, MOD1 - 2, MOD1);\n\tint inv2 = power(BASE, MOD2 - 2, MOD2);\n\tpot[0] = {1, 1};\n\tfor (int i = 1; i <= N; i++) {\n\t\tpot[i] = pot[i - 1];\n\t\tpref[i] = pref[i - 1];\n\t\tif (s[i] == '>')\n\t\t\tpot[i] = pot[i] * pii(BASE, BASE);\n\t\telse if (s[i] == '<')\n\t\t\tpot[i] = pot[i] * pii(inv1, inv2);\n\t\telse if (s[i] == '+') \n\t\t\tpref[i] = pref[i] + pot[i];\n\t\telse \n\t\t\tpref[i] = pref[i] + pii(-pot[i].first, -pot[i].second);\n\t}\n\t\n\tll ans = 0;\n\tfor (int i = N; i; i--) {\n\t\tcnt[pref[i]]++;\n\t\tans += cnt[(pref[N] * pot[i - 1]) + pref[i - 1]];\n\t}\n\t\n\treturn ans;\n}\n\nint main() {\n\tload();\n\tprintf(\"%lld\\n\", solve());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<climits>\n#include<bitset>\n#include<map>\n#define pii pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define int __int128\n#define mod1 10000000000037\n#define mod2 1000000000000000009\nusing namespace std;\ninline int read(){\n    int f=1,ans=0;char c=getchar();\n    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}\n    while(c>='0'&&c<='9'){ans=ans*10+c-'0';c=getchar();}\n    return f*ans;\n}\nconst int MAXN=5e5+11;\nint N;char str[MAXN];\nint h1[MAXN],s1[MAXN],x1=2,x2=3,res,h2[MAXN],s2[MAXN];\nint ksm1(int a,int b){\n    int ans=1;\n    while(b){if(b&1) ans*=a,ans%=mod1;a*=a,a%=mod1;b>>=1;}return ans;\n}\nint pw1(int a,int b){\n    if(b>=0) return ksm1(a,b);\n    int res=ksm1(a,-b);return ksm1(res,mod1-2);\n}\nint ksm2(int a,int b){\n    int ans=1;\n    while(b){if(b&1) ans*=a,ans%=mod2;a*=a,a%=mod2;b>>=1;}return ans;\n}\nint pw2(int a,int b){\n    if(b>=0) return ksm2(a,b);\n    int res=ksm2(a,-b);return ksm2(res,mod1-2);\n}\nmap<pii,int> M;\nvoid ins(int ps){M[mp( (h1[ps]+pw1(x1,s1[ps])*h1[N])%mod1 , (h2[ps]+pw2(x2,s2[ps])*h2[N])%mod2 )]++;return;}\ninline void print(int x){\n    if(x>9) print(x/10);\n    putchar(x%10+'0');\n}\nsigned main(){\n    //freopen(\"1.in\",\"r\",stdin);\n    N=read();scanf(\"%s\",str+1);\n    for(int i=1;i<=N;i++){\n        if(str[i]=='+') h1[i]=h1[i-1]+pw1(x1,s1[i-1]),s1[i]=s1[i-1],h1[i]%=mod1;\n        if(str[i]=='-') h1[i]=h1[i-1]-pw1(x1,s1[i-1])+mod1,s1[i]=s1[i-1],h1[i]%=mod1;\n        if(str[i]=='>') h1[i]=h1[i-1],s1[i]=s1[i-1]+1;\n        if(str[i]=='<') h1[i]=h1[i-1],s1[i]=s1[i-1]-1;\n        if(str[i]=='+') h2[i]=h2[i-1]+pw2(x2,s2[i-1]),s2[i]=s2[i-1],h2[i]%=mod2;\n        if(str[i]=='-') h2[i]=h2[i-1]-pw2(x2,s2[i-1])+mod2,s2[i]=s2[i-1],h2[i]%=mod2;\n        if(str[i]=='>') h2[i]=h2[i-1],s2[i]=s2[i-1]+1;\n        if(str[i]=='<') h2[i]=h2[i-1],s2[i]=s2[i-1]-1;\n    }\n    ins(0);\n    for(int i=1;i<=N;i++){\n        res+=M[mp(h1[i],h2[i])];\n        ins(i);\n    }print(res);printf(\"\\n\");return 0;\n}/*\n  5\n  +>+<-\n  */\n\n"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <iostream>\n#include <bits/stdc++.h>\nusing namespace std;\n \n#define debug(x) cout<<#x<<\" :: \"<<x<<endl;\n#define debug2(x,y) cout<<#x<<\" :: \"<<x<<\"\\t\"<<#y<<\" :: \"<<y<<endl;\n#define debug3(x,y,z) cout<<#x<<\" :: \"<<x<<\"\\t\"<<#y<<\" :: \"<<y<<\"\\t\"<<#z<<\" :: \"<<z<<endl;\n \n#define boost ios::sync_with_stdio(0); cin.tie(0)\n \n#define fi first\n#define se second\n \ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\n \nconst int N = 1e6 + 5;\nconst int MOD1 = 1934559071;\nconst int MOD2 = 1544907697;\nconst int B = 257707;\n \n/***************************************************************************/\n \nll power(ll a, ll n, ll m) {\n\tif(n == 0) return 1;\n\tll p = power(a, n>>1, m);\n\tp = (p * p) % m;\n\tif(n & 1) p = (p * a) % m;\n\treturn p;\n}\n \nstring S;\npii powB[N];\n \ninline pii& pow(int n) {\n\tif(n < 0) n += N;\n\treturn powB[n];\n}\n \nmap<ll, int> M;\n \nint main() {\n \n\tboost;\n\tint N; cin>>N;\n\tcin>>S;\n \n\tpow(-B) = pii(power(power(B, B, MOD1), MOD1-2, MOD1), power(power(B, B, MOD2), MOD2-2, MOD2));\n\tfor(int i=-B+1; i<=B; i++) {\n\t\tpow(i) = pii((B * 1LL * pow(i-1).fi) % MOD1, (B * 1LL * pow(i-1).se) % MOD2);\n\t}\n \n\tll phas1, phas2, chas1, chas2;\n\tphas1 = phas2 = chas1 = chas2 = 0;\n \n\tint p = 0;\n\tfor(auto it : S) {\n\t\tif(it == '+') phas1 += pow(p).fi, phas2 += pow(p).se;\n\t\telse if(it == '-') phas1 -= pow(p).fi, phas2 -= pow(p).se;\n\t\telse if(it == '>') p++;\n\t\telse p--;\n\t}\n \n\tphas1 %= MOD1; if(phas1 < 0) phas1 += MOD1;\n\tphas2 %= MOD2; if(phas2 < 0) phas2 += MOD2;\n \n\tll ans = 0;\n\tM[(phas1 << 32) | phas2]++;\n    p = 0;\n \n\tfor(auto it : S) {\n\t\tif(it == '+') chas1 = (chas1 + pow(p).fi) % MOD1, chas2 = (chas2 + pow(p).se) % MOD2;\n\t\telse if(it == '-') chas1 = (chas1 - pow(p).fi + MOD1) % MOD1, chas2 = (chas2 - pow(p).se + MOD2) % MOD2;\n\t\telse if(it == '>') p++;\n\t\telse p--;\n \n\t\tans += M[(chas1 << 32) | chas2];\n\t\t\n\t\tll has1 = (chas1 + pow(p).fi * phas1) % MOD1;\n\t\tll has2 = (chas2 + pow(p).se * phas2) % MOD2;\n \n\t\tM[(has1 << 32) | has2]++;\n\t}\n \n\tcout<<ans<<\"\\n\";\n \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <map>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define ll long long\n\nconst int maxN = 250011;\nconst ll mod = 1000000007;\nconst ll base = 500167;\n\nll poww(ll a, ll b) {\n    ll ans = 1;\n    while (b > 0) {\n        if (b & 1) ans = (ans * a) % mod;\n        b >>= 1;\n        a = (a * a) % mod;\n    }\n    return ans;\n}\n\nstruct smart_map {\n    map<ll, ll> M;\n    ll bonus;\n\n    smart_map() {\n        M.clear();\n        bonus = 1;\n    }\n\n    void operator*=(ll v) {\n        bonus = (bonus * v) % mod;\n    }\n\n    void add(ll x) {\n        x = (x * poww(bonus, mod - 2)) % mod;\n        M[x]++;\n    }\n\n    ll query(ll x) {\n        x = (x * poww(bonus, mod - 2)) % mod;\n        return M[x];\n    }\n};\n\nll n, i, act, full;\nchar s[maxN];\nsmart_map data;\nconst ll inv_base = poww(base, mod - 2);\nll ans;\n\nint main()\n{\n    //freopen(\"test.in\",\"r\",stdin);\n\n    scanf(\"%d\\n%s\", &n, s + 1);\n\n    data.add(0);\n    act = 0;\n\n    for (i = n; i >= 1; i--) {\n        if (s[i] == '+') act = (act + 1) % mod;    \n        if (s[i] == '-') act = (act + mod - 1) % mod;\n        if (s[i] == '<') act = (act * base) % mod;\n        if (s[i] == '>') act = (act * inv_base) % mod;\n    }\n\n    full = act;\n    act = 0;\n\n    for (i = n; i >= 1; i--) {\n        if (s[i] == '+') act = (act + 1) % mod;    \n        if (s[i] == '-') act = (act + mod - 1) % mod;\n        if (s[i] == '<') act = (act * base) % mod, data *= base;\n        if (s[i] == '>') act = (act * inv_base) % mod, data *= inv_base;\n    \n        ll src = (mod + act - full) % mod;\n        ans += data.query(src);\n\n        data.add(act);\n    }\n\n    printf(\"%lld\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cmath>\n#include<cstdlib>\n#include<set>\n#define LL long long\n#define LD long double\nusing namespace std;\nconst int NN=250000 +117;\nconst int MM= +117;\nint read(){\n\tint fl=1,x;char c;\n\tfor(c=getchar();(c<'0'||c>'9')&&c!='-';c=getchar());\n\tif(c=='-'){fl=-1;c=getchar();}\n\tfor(x=0;c>='0'&&c<='9';c=getchar())\n\t\tx=(x<<3)+(x<<1)+c-'0';\n\treturn x*fl;\n}\nvoid open(){\n\tfreopen(\"99f.in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n}\nvoid close(){\n\tfclose(stdin);\n\tfclose(stdout);\n}\n\n\nint m,n;\nmultiset<pair<LL,LL>> a;\nchar s[NN]={};\nLL mod[2]={998244353,2281701377};\nLL ksm(LL a,LL b,LL mod){\n\tLL ret=1;\n\twhile(b){\n\t\tif(b&1){\n\t\t\tret*=a;\n\t\t\tret%=mod;\n\t\t}\n\t\ta*=a;\n\t\ta%=mod;\n\t\tb>>=1;\n\t}\n\treturn ret;\n}\nint main(){\n\t//open();\n\tn=read();\n\tscanf(\"%s\",s);\n\tLL res[2]={0,0};\n\tLL rev[2];\n\trev[0]=ksm(mod[0],mod[1]-2,mod[1]);\n\trev[1]=ksm(mod[1],mod[0]-2,mod[0]);\n\tLL p[2]={1,1};\n\tfor(int i=0;i<n;++i){\n\t\tif(s[i]=='+'){\n\t\t\tfor(int i=0;i<2;++i){\n\t\t\t\tres[i]+=p[i];\n\t\t\t\tres[i]%=mod[i];\n\t\t\t}\n\t\t}\n\t\tif(s[i]=='-'){\n\t\t\tfor(int i=0;i<2;++i){\n\t\t\t\tres[i]+=mod[i]-p[i];\n\t\t\t\tres[i]%=mod[i];\n\t\t\t}\n\t\t}\n\t\tif(s[i]=='<'){\n\t\t\tfor(int i=0;i<2;++i){\n\t\t\t\tp[i]*=rev[i^1];\n\t\t\t\tp[i]%=mod[i];\n\t\t\t}\n\t\t}\n\t\tif(s[i]=='>'){\n\t\t\tfor(int i=0;i<2;++i){\n\t\t\t\tp[i]*=mod[i^1];\n\t\t\t\tp[i]%=mod[i];\n\t\t\t}\n\t\t}\n\t}\n\tp[0]=1;\n\tp[1]=1;\n\tLL tp[2]={0,0};\n\tLL ans=0;\n\tfor(int i=0;i<n;++i){\n\t\ta.insert(make_pair((tp[0]+p[0]*res[0])%mod[0],(tp[1]+p[1]*res[1])%mod[1]));\n\t\tif(s[i]=='+'){\n\t\t\tfor(int i=0;i<2;++i){\n\t\t\t\ttp[i]+=p[i];\n\t\t\t\ttp[i]%=mod[i];\n\t\t\t}\n\t\t}\n\t\tif(s[i]=='-'){\n\t\t\tfor(int i=0;i<2;++i){\n\t\t\t\ttp[i]+=mod[i]-p[i];\n\t\t\t\ttp[i]%=mod[i];\n\t\t\t}\n\t\t}\n\t\tif(s[i]=='<'){\n\t\t\tfor(int i=0;i<2;++i){\n\t\t\t\tp[i]*=rev[i^1];\n\t\t\t\tp[i]%=mod[i];\n\t\t\t}\n\t\t}\n\t\tif(s[i]=='>'){\n\t\t\tfor(int i=0;i<2;++i){\n\t\t\t\tp[i]*=mod[i^1];\n\t\t\t\tp[i]%=mod[i];\n\t\t\t}\n\t\t}\n\t\tans+=a.count(make_pair(tp[0],tp[1]));\n\t}\n\tprintf(\"%lld\\n\",ans);\n\tclose();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nint mod_pow(int a, ll b)\n{\n    int res = 1;\n    while(b){\n        if(b & 1){\n            res = (ll)res * a % MOD;\n        }\n        a = (ll)a * a % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nint add(int x,int y)\n{\n    return (x + y)%MOD;\n}\n\nint sub(int x,int y)\n{\n    return (x+MOD-y)%MOD;\n}\n\nint mul(int x,int y)\n{\n    return (ll)x*y%MOD;\n}\n\n#define mul0 10009\nstruct RollingHash {\n\tint n, sz, res; vector<int> hash;\n    RollingHash(int _n) : n(_n), sz(2*n+2), res(0){\n        hash.resize(sz+1,0), hash[0] = 1;\n\t\trep(i,sz) hash[i+1]=((ll)hash[i]*mul0)%MOD;\n    }\n    int calc(int id, bool pl){\n        if(pl) res = add(res, hash[id+n+1]);\n        else res = sub(res, hash[id+n+1]);\n        return res;\n    }\n};\n\nmap<int, int> mp;\nvector<int> vec;\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    string s;\n    cin >> s;\n    RollingHash rh(n);\n    int p = 0;\n    rep(i,n){\n        if(s[i] == '+'){\n            vec.pb(rh.calc(p, true));\n        }else if(s[i] == '-'){\n            vec.pb(rh.calc(p, false));\n        }else if(s[i] == '>'){\n            vec.pb(vec.back());\n            p++;\n        }else{\n            vec.pb(vec.back());\n            p--;\n        }\n        mp[vec.back()]++;\n    }\n    assert(false);\n    int val = vec.back();\n    ll ans = 0;\n    int A = 1, B = 0;\n    auto& hash = rh.hash;\n    rep(i,n){\n        ans += mp[mul(sub(val, B), mod_pow(A, MOD-2))];\n        mp[vec[i]]--;\n        if(s[i] == '+'){\n            B = sub(B, hash[n+1]);\n        }else if(s[i] == '-'){\n            B = add(B, hash[n+1]);\n        }else if(s[i] == '>'){\n            int hoge = mod_pow(mul0, MOD-2);\n            A = mul(A, hoge), B = mul(B, hoge);\n        }else{\n            A = mul(A, mul0), B = mul(B, mul0);\n        }\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<climits>\n#include<bitset>\n#include<map>\n#define pii pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define int long long\n#define mod1 1004535809\n#define mod2 1000000007\nusing namespace std;\ninline int read(){\n    int f=1,ans=0;char c=getchar();\n    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}\n    while(c>='0'&&c<='9'){ans=ans*10+c-'0';c=getchar();}\n    return f*ans;\n}\nconst int MAXN=5e5+11;\nint N;char str[MAXN];\nint h1[MAXN],s1[MAXN],xx=250001,res,h2[MAXN],s2[MAXN];\nint ksm1(int a,int b){\n    int ans=1;\n    while(b){if(b&1) ans*=a,ans%=mod1;a*=a,a%=mod1;b>>=1;}return ans;\n}\nint pw1(int a,int b){\n    if(b>=0) return ksm1(a,b);\n    int res=ksm1(a,-b);return ksm1(res,mod1-2);\n}\nint ksm2(int a,int b){\n    int ans=1;\n    while(b){if(b&1) ans*=a,ans%=mod2;a*=a,a%=mod2;b>>=1;}return ans;\n}\nint pw2(int a,int b){\n    if(b>=0) return ksm2(a,b);\n    int res=ksm2(a,-b);return ksm2(res,mod1-2);\n}\nmap<pii,int> M;\nvoid ins(int ps){M[mp( (h1[ps]+pw1(xx,s1[ps])*h1[N])%mod1 , (h2[ps]+pw2(xx,s2[ps])*h2[N])%mod2 )]++;return;}\nsigned main(){\n    //freopen(\"1.in\",\"r\",stdin);\n    N=read();scanf(\"%s\",str+1);\n    for(int i=1;i<=N;i++){\n        if(str[i]=='+') h1[i]=h1[i-1]+pw1(xx,s1[i-1]),s1[i]=s1[i-1],h1[i]%=mod1;\n        if(str[i]=='-') h1[i]=h1[i-1]-pw1(xx,s1[i-1])+mod1,s1[i]=s1[i-1],h1[i]%=mod1;\n        if(str[i]=='>') h1[i]=h1[i-1],s1[i]=s1[i-1]+1;\n        if(str[i]=='<') h1[i]=h1[i-1],s1[i]=s1[i-1]-1;\n        if(str[i]=='+') h2[i]=h2[i-1]+pw2(xx,s2[i-1]),s2[i]=s2[i-1],h2[i]%=mod2;\n        if(str[i]=='-') h2[i]=h2[i-1]-pw2(xx,s2[i-1])+mod2,s2[i]=s2[i-1],h2[i]%=mod2;\n        if(str[i]=='>') h2[i]=h2[i-1],s2[i]=s2[i-1]+1;\n        if(str[i]=='<') h2[i]=h2[i-1],s2[i]=s2[i-1]-1;\n    }\n    ins(0);\n    for(int i=1;i<=N;i++){\n        res+=M[mp(h1[i],h2[i])];\n        ins(i);\n    }printf(\"%lld\\n\",res);return 0;\n}/*\n  5\n  +>+<-\n  */\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<climits>\n#include<bitset>\n#include<map>\n#define pii pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define int long long\n#define mod 998244353\nusing namespace std;\ninline int read(){\n    int f=1,ans=0;char c=getchar();\n    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}\n    while(c>='0'&&c<='9'){ans=ans*10+c-'0';c=getchar();}\n    return f*ans;\n}\nconst int MAXN=5e5+11;\nint N;char str[MAXN];\nint h[MAXN],s[MAXN],xx=2,res;\nint ksm(int a,int b){\n    int ans=1;\n    while(b){if(b&1) ans*=a,ans%=mod;a*=a,a%=mod;b>>=1;}return ans;\n}\nint pw(int a,int b){\n    if(b>=0) return ksm(a,b);\n    int res=ksm(a,-b);return ksm(res,mod-2);\n}\nmap<int,int> M[MAXN];\nsigned main(){\n    //freopen(\"1.in\",\"r\",stdin);\n    N=read();scanf(\"%s\",str+1);s[0]=0,h[0]=0;\n    for(int i=1;i<=N;i++){\n        if(str[i]=='+') h[i]=h[i-1]+pw(xx,s[i-1]),s[i]=s[i-1],h[i]%=mod;\n        if(str[i]=='-') h[i]=h[i-1]-pw(xx,s[i-1])+mod,s[i]=s[i-1],h[i]%=mod;\n        if(str[i]=='>') h[i]=h[i-1],s[i]=s[i-1]+1;\n        if(str[i]=='<') h[i]=h[i-1],s[i]=s[i-1]-1;\n    }\n    //for(int i=1;i<=N;i++) printf(\"h:%lld s:%lld\\n\",h[i],s[i]);\n    for(int i=1;i<=N;i++)\n        for(int j=i;j<=N;j++){\n            if(((h[i-1]+ksm(xx,s[i-1])*h[N])%mod)==h[j]){\n                res++;\n                cerr<<i<<\" \"<<j<<endl;\n            }\n            //res+=(((h[i-1]+ksm(xx,s[i-1])*h[N])%mod)==h[j]);\n        }\n    printf(\"%lld\\n\",res);return 0;\n}/*\n  5\n  +>+<-\n  */\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2)\n#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned long long\n#define maxn 500005\n#define inf 1e9\n#define eps 1e-10\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,w=1; char c=getchar();\n\twhile(c<'0'||c>'9') {if(c=='-') w=-1; c=getchar();}\n\twhile(c<='9'&&c>='0') {x=(x<<1)+(x<<3)+c-'0'; c=getchar();}\n\treturn w==1?x:-x;\n}\n\nmap <ull,int> p;\null b[maxn],inv[maxn],ans;\nint len,n;\nchar s[maxn];\n\ninline ull pw(ull a,ull b)\n{\n\tull ans=1,base=a;\n\twhile(b)\n\t{\n\t\tif(b&1) ans=(ans*base);\n\t\tbase=(base*base); b>>=1;\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\t//freopen(\"t1.out\",\"w\",stdout);\n\tull x=0-1; ull y=pw(233,x-1); //cout<<x*y<<endl;\n\tn=read(); scanf(\"%s\",s+1); b[0]=1; inv[0]=1; inv[1]=7204522363551799129; len=strlen(s+1);\n\tfor(int i=1;i<=maxn-5;i++) b[i]=b[i-1]*233;\n\tfor(int i=2;i<=maxn-5;i++) inv[i]=inv[i-1]*7204522363551799129;\n\tll ed=0,nw=250000;\n\tfor(int i=1;i<=len;i++)\n\t{\n\t\tif(s[i]=='+') ed=(ed+b[nw]);\n\t\telse if(s[i]=='-') ed=(ed-b[nw]);\n\t\telse if(s[i]=='>') nw++;\n\t\telse if(s[i]=='<') nw--; p[ed]++;\n\t}\n\tll tmp=0; nw=250000; ans=0;\n\tfor(int i=1;i<=len;i++)\n\t{\n\t\tll p2=ed;\n\t\tif(nw>=250000) p2=(p2*b[nw-250000]);\n\t\telse p2=(p2*inv[250000-nw]);\n\t\tans+=p[(tmp+p2)];\n\t\tif(s[i]=='+') tmp=(tmp+b[nw]);\n\t\telse if(s[i]=='-') tmp=(tmp-b[nw]);\n\t\telse if(s[i]=='>') nw++;\n\t\telse if(s[i]=='<') nw--;\n\t\tp[tmp]--;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEB\n#include<bits/stdc++.h>\n#define REP(i,m) for(int i=0;i<(m);++i)\n#define REPN(i,m,in) for(int i=(in);i<(m);++i)\n#define ALL(t) (t).begin(),(t).end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n\nusing namespace std;\n\n\n#ifdef DEB\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define prl cerr<<\"called:\"<< __LINE__<<endl\n#define dumpR(x) cerr<<\"\\x1b[31m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpY(x) cerr<<\"\\x1b[33m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpG(x) cerr<<\"\\x1b[32m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\ntemplate<class T> void debug(T a,T b){ for(;a!=b;++a) cerr<<*a<<' ';cerr<<endl;}\n#else\n#define dump(x) ;\n#define dumpR(x) ;\n#define dumpY(x) ;\n#define dumpG(x) ;\n#define prl ;\ntemplate<class T> void debug(T a,T b){ ;}\n#endif\n\ntemplate<class T> bool chmin(T& a,const T& b) {\n  if(a>b) {\n    a=b;\n    return true;\n  }\n  return false;\n}\ntemplate<class T> bool chmax(T& a,const T& b) {\n  if(a<b){\n    a=b;\n    return true;\n  }\n  return false;\n}\n\ntypedef long long int lint;\ntypedef pair<int,int> pi;\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fr<<','<<a.sc<<')';\n    return out;\n  }\n}\n\n//const int INF=5e8;\ntemplate<lint mod>\nstruct Int_{\n  unsigned x;\n  int mpow(Int_ a,int k){\n    Int_ res=1;\n    while(k){\n      if(k&1) res=res*a;\n      a=a*a;\n      k>>=1;\n    }\n    return res.x;\n  }\n  int inverse(Int_ a){\n    return mpow(a,mod-2);\n  }\n  Int_(): x(0) { }\n  Int_(long long sig) { int sigt = sig % mod; if(sigt < 0) sigt += mod; x = sigt; }\n  int get() const { return (int)x; }\n  \n  Int_ &operator+=(Int_ that) { if((x += that.x) >= mod) x -= mod; return *this; }\n  Int_ &operator-=(Int_ that) { if((x += mod - that.x) >= mod) x -= mod; return *this; }\n  Int_ &operator*=(Int_ that) { x = (unsigned long long)x * that.x % mod; return *this; }\n  Int_ &operator=(Int_ that) { x=that.x; return *this;}\n  Int_ &operator/=(Int_ that) { x=(unsigned long long) x * inverse(that.x)%mod; return *this;}\n  bool operator==(Int_ that) const { return x==that.x; }\n  bool operator!=(Int_ that) const { return x!=that.x; }\n\n\n  Int_ operator-() const { return Int_(0)-Int_(*this);}\n  Int_ operator+(Int_ that) const { return Int_(*this) += that; }\n  Int_ operator-(Int_ that) const { return Int_(*this) -= that; }\n  Int_ operator*(Int_ that) const { return Int_(*this) *= that; }\n  Int_ operator/(Int_ that) const { return Int_(*this) /= that; }\n\n};\n\ntypedef Int_<1000000021> Int_h;\n\nnamespace std{\n  template<lint mod>\n  ostream &operator <<(ostream& out,const Int_<mod>& a){\n    out<<a.get();\n    return out;\n  }\n  template<lint mod>\n  istream &operator >>(istream& in,Int_<mod>& a){\n    in>>a.x;\n    return in;\n  }\n};\nstruct Hash{\n  static const int MAX_N=550005;\n  static Int_h M1,M2;\n  static Int_h rev1,rev2;\n\n  static Int_h mul1[MAX_N],mul2[MAX_N],\n         div1[MAX_N],div2[MAX_N];\n\n  typedef pair<Int_h,Int_h>key;\n  static Hash pows[MAX_N];\n\n  key a;\n  static void init(){\n    M1=2,M2=3;\n    rev1=Int_h(1)/M1;\n    rev2=Int_h(1)/M2;\n\n    Int_h* ar[4]={mul1,mul2,div1,div2};\n    Int_h mult[4]={M1,M2,rev1,rev2};\n    REP(j,4){\n      ar[j][0]=1;\n      REP(i,MAX_N-1){\n        ar[j][i+1]=ar[j][i]*mult[j];\n      }\n    }\n    REP(i,MAX_N) pows[i].a=mp(mul1[i],mul2[i]);\n  }\n  Hash(lint val=0){\n    a=mp(val,val);\n  }\n  Hash &operator+=(const Hash& b) { \n    a.fr+=b.a.fr;\n    a.sc+=b.a.sc;\n\n    return *this;\n  }\n  Hash &operator-=(const Hash& b) {\n    a.fr-=b.a.fr;\n    a.sc-=b.a.sc;\n\n    return *this;\n  }\n  Hash &operator <<=(int k){\n    if(k<0) (*this)>>=(-k);\n    else{\n      a.fr*=mul1[k];\n      a.sc*=mul2[k];\n      return *this;\n    }\n  }\n  Hash &operator >>=(int k){\n    if(k<0) (*this)<<=(-k);\n    else{\n      a.fr*=div1[k];\n      a.sc*=div2[k];\n      return *this;\n    }\n  }\n  Hash &operator =(Hash b){\n    a=b.a;\n    return *this;\n  }\n  Hash &operator =(lint val){\n    a.fr=val;\n    a.sc=val;\n    return *this;\n  }\n  Hash operator -()const{\n    return Hash(0)-=Hash(*this);\n  }\n\n  Hash operator +(const Hash& b) const{\n    return Hash(*this)+=b;\n  }\n  Hash operator -(const Hash& b) const{\n    return Hash(*this)-=b;\n  }\n\n  Hash operator <<(int k) const{\n    return Hash(*this)<<=k;\n  }\n  Hash operator >>(int k) const{\n    return Hash(*this)>>=k;\n  }\n\n  bool operator==(const Hash& b) const { return (a==b.a); }\n  bool operator!=(const Hash& b) const { return (a!=b.a); }\n  bool operator<(const Hash& b) const {\n    return mp(a.fr.x,a.sc.x)<mp(b.a.fr.x,b.a.sc.x);\n  }\n};\n\nconst int Hash::MAX_N;\nInt_h Hash::M1,Hash::M2;\nInt_h Hash::rev1,Hash::rev2;\nInt_h Hash::mul1[MAX_N],Hash::mul2[MAX_N],\n         Hash::div1[MAX_N],Hash::div2[MAX_N];\n\nHash Hash::pows[MAX_N];\n//Hash::init();\n//don't forget initializing!\n\nint n;\nchar s[250005];\nint main(){\n  Hash::init();\n  cin>>n;\n  scanf(\"%s\",s);\n\n\n  map<Hash,int> cnt;\n  Hash cur=0;\n  int pos=0;\n  REP(i,n){\n    ++cnt[cur];\n    if(s[i]=='<') --pos;\n    else if(s[i]=='>') ++pos;\n    else if(s[i]=='+') cur+=Hash::pows[pos+n];\n    else cur-=Hash::pows[pos+n];\n  }\n  cnt[cur]++;\n\n  Hash target=cur;\n  cur=0;\n  pos=0;\n\n  lint res=0;\n  REP(i,n){\n    --cnt[cur];\n    Hash target2=(target<<pos)+cur;\n    res+=cnt[target2];\n    if(s[i]=='<') --pos;\n    else if(s[i]=='>') ++pos;\n    else if(s[i]=='+') cur+=Hash::pows[pos+n];\n    else cur-=Hash::pows[pos+n];\n  }\n\n  cout<<res<<endl;\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define iinf 2000000000\n#define linf 1000000000000000000LL\n#define ulinf 10000000000000000000ull\n#define MOD1 998244353LL\n#define MUL 999983LL\n#define mpr make_pair\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef unsigned long UL;\ntypedef unsigned short US;\ntypedef pair < int , int > pii;\nclock_t __stt;\ninline void TStart(){__stt=clock();}\ninline void TReport(){printf(\"\\nTaken Time : %.3lf sec\\n\",(double)(clock()-__stt)/CLOCKS_PER_SEC);}\ntemplate < typename T > T MIN(T a,T b){return a<b?a:b;}\ntemplate < typename T > T MAX(T a,T b){return a>b?a:b;}\ntemplate < typename T > T ABS(T a){return a>0?a:(-a);}\ntemplate < typename T > void UMIN(T &a,T b){if(b<a) a=b;}\ntemplate < typename T > void UMAX(T &a,T b){if(b>a) a=b;}\nint n,glob,mul[500005];\nLL cnt;\nchar s[250005];\nmap < int , int > mp;\nint pow(int val,int pw=MOD1-2){\n    int ret=1;\n    while(pw){\n        if(pw&1) ret=((LL)ret*(LL)val)%MOD1;\n        val=((LL)val*(LL)val)%MOD1;\n        pw>>=1;\n    }\n    return ret%MOD1;\n}\nvoid solve(int l,int r){\n\tmp.clear();\n\tif(l==r){\n\t\tif(s[l]=='+') cnt+=(LL)(glob==1);\n\t\telse if(s[l]=='-') cnt+=(LL)(glob==MOD1-1);\n\t\telse cnt+=(LL)(glob==0);\n\t\treturn;\n\t}\n\tint M=((l+r)>>1),i,ptr=0,cur=0,mtl=1;\n\tfor(i=M;i>=l;--i){\n\t\tif(s[i]=='<')\n\t\t\t--ptr;\n\t\telse if(s[i]=='>')\n\t\t\t++ptr;\n\t\telse if(s[i]=='+')\n\t\t\tcur=(cur+mul[ptr+n+1])%MOD1;\n\t\telse\n\t\t\tcur=(cur-mul[ptr+n+1]+MOD1)%MOD1;\n\t\t++mp[cur];\n\t}\n\tcur=0;\n\tfor(i=M+1;i<=r;++i){\n\t\tif(s[i]=='<'){\n\t\t\tcur=((LL)cur*(LL)pow(MUL))%MOD1;\n\t\t\tmtl=((LL)mtl*(LL)pow(MUL))%MOD1;\n\t\t}\n\t\telse if(s[i]=='>'){\n\t\t\tcur=((LL)cur*MUL)%MOD1;\n\t\t\tmtl=((LL)mtl*MUL)%MOD1;\n\t\t}\n\t\telse if(s[i]=='+'){\n\t\t\tcur=(cur+1)%MOD1;\n\t\t}\n\t\telse{\n\t\t\tcur=(cur-1+MOD1)%MOD1;\n\t\t}\n\t\tcnt+=(LL)mp[((LL)((glob-cur+MOD1)%MOD1)*(LL)pow(mtl))%MOD1];\n\t}\n\tsolve(l,M);\n\tsolve(M+1,r);\n}\nint main(){\n    // inputting start\n    // 数据结构记得初始化！ n，m别写反！\n    scanf(\"%d%s\",&n,s);\n    #ifdef LOCAL\n        TStart();\n    #endif\n    // calculation start\n    // 数据结构记得初始化！ n，m别写反！\n    reverse(s,s+n);\n\tint i,j,k;\n\tfor(i=0;i<n;++i){\n\t\tif(s[i]=='<')\n\t\t\tglob=((LL)glob*(LL)pow(MUL))%MOD1;\n\t\telse if(s[i]=='>')\n\t\t\tglob=((LL)glob*MUL)%MOD1;\n\t\telse if(s[i]=='+')\n\t\t\tglob=(glob+1)%MOD1;\n\t\telse\n\t\t\tglob=(glob-1+MOD1)%MOD1;\n\t}\n\tmul[n+1]=1;\n\tfor(i=1;i<=n;++i){\n\t\tmul[n+1+i]=((LL)mul[n+i]*MUL)%MOD1;\n\t}\n\tfor(i=-1;i>=-n;--i){\n\t\tmul[n+1+i]=((LL)mul[n+2+i]*(LL)pow(MUL))%MOD1;\n\t}\n\tsolve(0,n-1);\n\tprintf(\"%lld\\n\",cnt);\n    #ifdef LOCAL\n        TReport();\n    #endif\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n\ntypedef pair<int, int> ii;\n\nconst int B = 1e6 + 7;\n\nconst int N = 250005;\n\nconst int mod1 = 1e9 + 7;\nconst int mod2 = 1e9 + 9;\n\nint cnt = N - 5, pw[2][2 * N], lmao[N], n, hs[2][N];\n\nlong long sum = 0;\n\nstring s;\n\nii type;\n\nmap<ii, int> mymap;\n\nint BinPow(int x, int m, int mod) {\n    if(m == 0)\n        return 1;\n    else if(m == 1)\n        return x % mod;\n    else {\n        int sum = BinPow(x, m >> 1, mod);\n        sum = (1ll * sum * sum) % mod;\n        if(m % 2)\n            sum = (1ll * sum * x) % mod;\n        return sum;\n    }\n}\n\nint main() {\n    cin.tie(0), ios::sync_with_stdio(0);\n    cin >> n;\n    cin >> s;\n    s = \"+\" + s;\n    pw[0][0] = pw[1][0] = 1;\n    for(int i = 1; i <= 2 * N - 10; i++) {\n        pw[0][i] = (1ll * pw[0][i - 1] * B) % mod1;\n        pw[1][i] = (1ll * pw[1][i - 1] * B) % mod2;\n    }\n    for(int i = 1; i <= n; i++) {\n        lmao[i] = cnt;\n        if(s[i] == '+') {\n            hs[0][i] = (1ll * hs[0][i - 1] + pw[0][cnt]) % mod1;\n            hs[1][i] = (1ll * hs[1][i - 1] + pw[1][cnt]) % mod2;\n        }\n        if(s[i] == '-') {\n            hs[0][i] = (1ll * hs[0][i - 1] - pw[0][cnt]) % mod1;\n            hs[1][i] = (1ll * hs[1][i - 1] - pw[1][cnt]) % mod2;\n            hs[0][i] = (1ll * hs[0][i] + mod1) % mod1;\n            hs[1][i] = (1ll * hs[1][i] + mod2) % mod2;\n        }\n        if(s[i] == '>'){\n            cnt++;\n            hs[0][i] = (1ll * hs[0][i - 1] + mod1) % mod1;\n            hs[1][i] = (1ll * hs[1][i - 1] + mod2) % mod2;\n        }\n        if(s[i] == '<'){\n            cnt--;\n            hs[0][i] = (1ll * hs[0][i - 1] + mod1) % mod1;\n            hs[1][i] = (1ll * hs[1][i - 1] + mod2) % mod2;\n        }\n    }\n    int x1 = (1ll * hs[0][n] * BinPow(pw[0][lmao[1]], mod1 - 2, mod1)) % mod1;\n    int x2 = (1ll * hs[1][n] * BinPow(pw[1][lmao[1]], mod2 - 2, mod2)) % mod2;\n    type = {x1, x2};\n    for(int i = n; i >= 1; i--) {\n        mymap[{hs[0][i], hs[1][i]}]++;\n        x1 = ((1ll * type.fi * pw[0][lmao[i]]) % mod1 + 1ll * hs[0][i - 1]) % mod1;\n        x2 = ((1ll * type.se * pw[1][lmao[i]]) % mod2 + 1ll * hs[1][i - 1]) % mod2;\n        sum += mymap[{x1, x2}];\n    }\n    cout << sum << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define Set(a, b) memset(a, b, sizeof (a))\n#define For(i, j, k) for (int i = j; i <= k; ++ i)\n#define Forr(i, j, k) for (int i = j; i >= k; -- i)\n\nusing namespace std;\n\ntypedef long long ll;\n\ninline void File() {\n\tfreopen(\"f.in\", \"r\", stdin);\n\tfreopen(\"f.out\", \"w\", stdout);\n}\n\nconst int N = 2e5 + 10;\nint n; char s[N];\nll st[N], p[N];\n\nconst ll mod = 1000000000000000031ll;\nconst ll gkk = 1000000000000000003ll;\nconst ll hany01 = 821428571428571454ll;\n\nll mul(ll a, ll b) { return (__int128) a * b % mod; }\nll add(ll a, ll b) { return (a += b) >= mod ? a - mod : a; }\n\nunordered_map<ll, int> mp;\n\nint main() {\n\n\tcin >> n, scanf(\"%s\", s + 1);\n\n\tp[0] = 1;\n\tFor(i, 1, n) {\n\t\tst[i] = st[i - 1], p[i] = p[i - 1];\n\t\tif (s[i] == '+') st[i] = add(st[i], p[i]);\n\t\tif (s[i] == '-') st[i] = add(st[i], mod - p[i]);\n\t\tif (s[i] == '>') p[i] = mul(p[i], gkk);\n\t\tif (s[i] == '<') p[i] = mul(p[i], hany01);\n\t}\n\n\tll ans = 0;\n\tForr(i, n, 1) {\n\t\t++ mp[st[i]];\n\t\tans += mp[add(mul(st[n], p[i - 1]), st[i - 1])];\n\t}\n\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define MAX 500012\n\nint n;\nchar buf[MAX];\n\n\nstring s;\n\n\n//#define MOD1 1000000007\n//#define MOD2 1000000009\n\nvalarray<long long int> MOD1;\nvalarray<long long int> MOD2;\nvector<valarray<long long int> > p2;\nvector<valarray<long long int> > vv;\nvector<int> ps;\nmap<long long int, int> mp;\nlong long int ppow(long long int i, long long int j, long long int MOD) {\n\tlong long int ret = 1;\n\twhile (j) {\n\t\tif (j & 1LL)ret *= i;\n\t\tif (ret >= MOD)ret %= MOD;\n\t\tj >>= 1LL;\n\t}\n\treturn ret;\n}\n\nvalarray<long long int> calc(int dif) {\n\tvalarray<long long int> ret;\n\tret.resize(2, 0);\n\tfor (int j = 0; j < 2; j++) {\n\t\tif (dif < 0) {\n\t\t\tret[j]=ppow(ppow(MOD1[j], abs(dif),MOD2[j]), MOD2[j] - 2,MOD2[j]);\n\t\t}\n\t\telse {\n\t\t\tret[j] = ppow(MOD1[j], abs(dif), MOD2[j]);\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main() {\n\tMOD1.resize(2);\n\tMOD2.resize(2);\n\tp2.push_back(valarray<long long int>());\n\tp2.back().resize(2);\n\tp2.back()[0] = p2.back()[1] = 1;\n\tMOD1[0] = 1007;\n\tMOD2[0] = 10009;\n\tMOD1[1] = 1000000009;\n\tMOD2[1] = 1001110007;\n\tp2[0] %= MOD2;\n\tfor (int i = 1; i < MAX; i++) {\n\t\tp2.push_back(p2.back());\n\t\tp2[i] *= MOD1;\n\t\tp2[i] %= MOD2;\n\t}\n\tcin >> n;\n\tscanf(\"%s\", buf);\n\ts = buf;\n\tint pos = MAX/2;\n\tvalarray<long long int> hs;\n\ths.resize(2);\n\ths[0] = hs[1] = 0;\n\tvv.push_back(hs);\n\tps.push_back(pos);\n\tfor (int i = 0; i < s.size(); i++) {\n\t\tif (s[i] == '<') {\n\t\t\tpos--;\n\t\t}\n\t\tif (s[i] == '>') {\n\t\t\tpos++;\n\t\t}\n\t\tif (s[i] == '+') {\n\t\t\ths += p2[pos];\n\t\t}\n\t\tif (s[i] == '-') {\n\t\t\ths -= p2[pos];\n\t\t\ths += MOD2;\n\t\t}\n\t\ths %= MOD2;\n\t\tvv.push_back(hs);\n\t\tps.push_back(pos);\n\t}\n\tlong long int way = 0;\n\tfor (int i = vv.size() - 1; i >= 0; i--) {\n\t\tvalarray<long long int> want = vv[i] + vv.back()*calc(-MAX/2+ps[i]);\n\t\twant = want%MOD2;\n\t\tway += mp[want[0] * MOD1[0] + want[1]];\n\t\t//cerr << \"dbg \" << way << endl;\n\t\tmp[vv[i][0]*MOD1[0]+vv[i][1]]++;\n\t}\n\tprintf(\"%lld\\n\", way);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof x)\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outtag(x) cerr<<\"-----------------\"#x\"-----------------\\n\"\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n                    For(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair <int,int> pii;\nLL read(){\n    LL x=0,f=0;\n    char ch=getchar();\n    while (!isdigit(ch))\n        f=ch=='-',ch=getchar();\n    while (isdigit(ch))\n        x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n    return f?-x:x;\n}\nconst int N=250005,mod=998244353;\nint Pow(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=(LL)x*x%mod)\n\t\tif (y&1)\n\t\t\tans=(LL)ans*x%mod;\n\treturn ans;\n}\nvoid Add(int &x,int y){\n\tif ((x+=y)>=mod)\n\t\tx-=mod;\n}\nvoid Del(int &x,int y){\n\tif ((x-=y)<0)\n\t\tx+=mod;\n}\nint Add(int x){\n\treturn x>=mod?x-mod:x;\n}\nint Del(int x){\n\treturn x<0?x+mod:x;\n}\nconst int k=10;\nvector <int> bas(k),ibas(k);\nvoid prework(){\n\tsrand(1233);\n\tFor(i,0,k-1){\n\t\tbas[i]=rand()%10000+1;\n\t\tibas[i]=Pow(bas[i],mod-2);\n\t}\n}\nstruct cmp{\n\tbool operator () (vector <int> a,vector <int> b){\n\t\tassert((int)a.size()==k&&(int)b.size()==k);\n\t\tFor(i,0,k-1)\n\t\t\tif (a[i]!=b[i])\n\t\t\t\treturn a[i]<b[i];\n\t\treturn 0;\n\t}\n};\nmap <vector <int>,int,cmp> cnt;\nvoid Add(pair <int,int> &a,int b){\n\tAdd(a.se,(LL)b*a.fi%mod);\n}\nvoid Del(pair <int,int> &a,int b){\n\tDel(a.se,(LL)b*a.fi%mod);\n}\nvoid Mul(int &a,int b){\n\ta=(LL)a*b%mod;\n}\nvoid Mul(pair <int,int> &a,int b){\n\tMul(a.fi,b);\n}\ntemplate <typename T> vector <T> trans(vector <T> x,int op){\n\tvector <T> a=x;\n\tif (op==1||op==-2)\n\t\tFor(i,0,k-1)\n\t\t\tAdd(a[i],1);\n\telse if (op==2||op==-1)\n\t\tFor(i,0,k-1)\n\t\t\tDel(a[i],1);\n\telse if (op==3||op==-4)\n\t\tFor(i,0,k-1)\n\t\t\tMul(a[i],bas[i]);\n\telse if (op==4||op==-3)\n\t\tFor(i,0,k-1)\n\t\t\tMul(a[i],ibas[i]);\n\treturn a;\n}\nint n;\nchar s[N];\nmap <char,int> op;\nvector <int> all(k,0),zero(k,0);\nvector <pair <int,int> > a(k,mp(1,0)),b(k,mp(1,0));\nvector <int> Calc(vector <pair <int,int> > a,vector <int> x){\n\tvector <int> b(k);\n\tFor(i,0,k-1)\n\t\tb[i]=((LL)a[i].fi*x[i]+a[i].se)%mod;\n\treturn b;\n}\nint main(){\n\tprework();\n\top['+']=1,op['-']=2,op['>']=3,op['<']=4;\n\tn=read();\n\tcin>>(s+1);\n//\toutarr(bas,0,k-1);\n//\toutarr(ibas,0,k-1);\n\tFod(i,n,1)\n\t\tall=trans(all,op[s[i]]);\n//\toutarr(all,0,k-1);\n\tLL ans=0;\n\tcnt[Calc(a,zero)]++;\n\tFod(i,n,1){\n\t\ta=trans(a,-op[s[i]]);\n\t\tb=trans(b,-op[s[i]]);\n\t\tans+=cnt[Calc(b,all)];\n\t\tcnt[Calc(a,zero)]++;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<set>\n\ntypedef long long ll;\n\nconst int N=250010,MOD=1000000007,g=500002;\n\nll inv(int x){return (x==1 || x==-1)?x:(-(MOD/x)*inv(MOD%x)%MOD);}\n\nint t0[N*2],*pow;\n\nvoid initialize()\n{\n\tpow=t0+N;\n\n\tpow[0]=1;\n\tfor(int i=1;i<N;i++)\n\t\tpow[i]=(ll)pow[i-1]*g%MOD;\n\n\tint ig=(inv(g)+MOD)%MOD;\n\tfor(int i=0;i<N;i++)\n\t\tpow[-i-1]=(ll)pow[-i]*ig%MOD;\n}\n\nchar s[N];\nint ind[N],val[N],sum[N];\nint n;\n\nll ans;\n\nvoid prework()\n{\n\tint p=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tind[i]=p,val[i]=0;\n\n\t\tif(s[i]=='<')p--;\n\t\telse if(s[i]=='>')p++;\n\t\telse if(s[i]=='+')val[i]=pow[p];\n\t\telse val[i]=-pow[p];\n\t}\n\n\tfor(int i=1;i<=n;i++)\n\t\tsum[i]=((sum[i-1]+val[i])%MOD+MOD)%MOD;\n}\n\nstd::multiset<int> S;\n\nvoid solve()\n{\n\tans=0;\n\tfor(int i=n,x,y;i;i--)\n\t{\n\t\tS.insert(sum[i]);\n\n\t\tx=((ll)sum[n]*pow[ind[i]]%MOD+MOD)%MOD;\n\t\ty=x+sum[i-1];\n\n\t\tans+=S.count(y);\n\t}\n}\n\nint main()\n{\n\tinitialize();\n\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",s+1);\n\n\tprework();\n\tsolve();\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 500005\nusing namespace std;\ntypedef long long ll;\nconst int mod1=1e9+7,mod2=1e9+9,C=200017;\nint n;\nll bin[2][N],a[N];\nchar s[N];\nmap<pair<ll,ll>,int> mp;\npair<ll,ll> g[N];\nll quick_pow(ll a,ll b,const ll mod){\n\tll ans=1;\n\tfor(;b;b>>=1,a=a*a%mod)\n\t\tif(b&1) ans=ans*a%mod;\n\treturn ans;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",s+1);\n\tbin[0][0]=bin[1][0]=1;\n\tfor(int i=1;i<=n+n;i++){\n\t\tbin[0][i]=bin[0][i-1]*C%mod1;\n\t\tbin[1][i]=bin[1][i-1]*C%mod2;\n\t}\n\tll now1=0,now2=0;\n\tpair<ll,ll> w;\n\tfor(int i=1,pos=n;i<=n;i++){\n\t\tif(s[i]=='<') pos--;\n\t\tif(s[i]=='>') pos++;\n\t\tif(s[i]=='-'){\n\t\t\ta[pos]--;\n\t\t\tnow1=(now1-bin[0][pos])%mod1;\n\t\t\tnow2=(now2-bin[1][pos])%mod2;\n\t\t}\n\t\tif(s[i]=='+'){\n\t\t\ta[pos]++;\n\t\t\tnow1=(now1+bin[0][pos])%mod1;\n\t\t\tnow2=(now2+bin[1][pos])%mod2;\n\t\t}\n\t\tnow1=(now1+mod1)%mod1;\n\t\tnow2=(now2+mod2)%mod2;\n\t\tw=make_pair(now1,now2);\n\t\tg[i]=w;\n\t\tif(mp.find(w)==mp.end()) mp[w]=0;\n\t\tmp[w]++;\n\t}\n\tll ans=mp[w];\n\tll inv1=quick_pow(C,mod1-2,mod1),inv2=quick_pow(C,mod2-2,mod2);\n\tll w1=1,w2=1,add1=0,add2=0;\n\tfor(int i=1;i<n;i++){\n\t\tif(s[i]=='<'){\n\t\t\tw1=w1*inv1%mod1;\n\t\t\tw2=w2*inv2%mod2;\n\t\t\t//add1=add1%mod1;\n\t\t\t//add2=add2*inv2%mod2;\n\t\t}\n\t\tif(s[i]=='>'){\n\t\t\tw1=w1*C%mod1;\n\t\t\tw2=w2*C%mod2;\n\t\t\t//add1=add1*C%mod1;\n\t\t\t//add2=add2*C%mod2;\n\t\t}\n\t\tif(s[i]=='+'){\n\t\t\tadd1=(add1+bin[0][n]*w1)%mod1;\n\t\t\tadd2=(add2+bin[1][n]*w2)%mod2;\n\t\t}\n\t\tif(s[i]=='-'){\n\t\t\tadd1=(add1-bin[0][n]*w1)%mod1;\n\t\t\tadd2=(add2-bin[1][n]*w2)%mod2;\n\t\t}\n\t\tw.first=(g[n].first*w1+add1)%mod1;\n\t\tw.second=(g[n].second*w2+add2)%mod2;\n\t\tw.first=(w.first+mod1)%mod1;\n\t\tw.second=(w.second+mod2)%mod2;\n\t\tmp[g[i]]--;\n\t\tif(mp.find(w)!=mp.end()) ans+=mp[w];\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#define mod1 998244353\n#define base1 19260817\n#define mod2 998244853\n#define base2 666623333\n#define M 1000005\ntypedef long long ll;\nint n,G[M];\nstd::pair <int,int> F[M];\nstd::map <std::pair <int,int>,int> Map;\nll ans;\nint read(){\n\tchar c=getchar();int ans=0;\n\twhile (c<'0'||c>'9') c=getchar();\n\twhile (c>='0'&&c<='9') ans=ans*10+c-'0',c=getchar();\n\treturn ans;\n}\nint read_opt(){\n\tchar c=getchar();\n\twhile (c!='<'&&c!='>'&&c!='+'&&c!='-') c=getchar();\n\treturn c=='<'?1:(c=='>'?2:(c=='+'?3:4));\n}\nvoid Write(ll x){\n\tif (x<10) putchar(x^48);\n\telse Write(x/10),putchar((x%10)^48);\n\treturn;\n}\nint power(ll x,int y,int mod){\n\tll ans=1;if (y<0) y+=mod-1;\n\tfor (;y;y>>=1,x=x*x%mod)\n\t\tif (y&1) ans=ans*x%mod;\n\treturn ans;\n}\nint add(int x,int y,int mod){return (x+=y)>=mod?x-mod:x;}\nint sub(int x,int y,int mod){return (x-=y)<0?x+mod:x;}\nint main(){\n\tn=read();\n\tfor (register int i=1;i<=n;i++)\n\t\tswitch (read_opt()){\n\t\t\tcase 1:F[i]=F[i-1],G[i]=G[i-1]-1;break;\n\t\t\tcase 2:F[i]=F[i-1],G[i]=G[i-1]+1;break;\n\t\t\tcase 3:G[i]=G[i-1],F[i]=std::make_pair(add(F[i-1].first,power(base1,G[i],mod1),mod1),add(F[i-1].second,power(base2,G[i],mod2),mod2));break;\n\t\t\tcase 4:G[i]=G[i-1],F[i]=std::make_pair(sub(F[i-1].first,power(base1,G[i],mod1),mod1),sub(F[i-1].second,power(base2,G[i],mod2),mod2));break;\n\t\t}\n\tfor (register int i=n,X,Y;i>=0;++Map[F[i--]])\n\t\tX=((F[n].first+0ll)*power(base1,G[i],mod1)+F[i].first)%mod1,\n\t\tY=((F[n].second+0ll)*power(base2,G[i],mod2)+F[i].second)%mod2,\n\t\tans+=Map[std::make_pair(X,Y)];\n\tWrite(ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 250000;\n\nconstexpr int inv(int a, int m) {\n  return a == 1 ? 1 : 1LL * (m - m / a) * inv(m % a, m) % m;\n}\n\nconst int BASE = 1000003;\nconst int M = 2;\nconst int MODS[] = {1000000007, 1000000009};\n\n// template <int BASE, int... INTS> struct HashT {\nstruct HashT {\n  // static constexpr int M = sizeof...(INTS);\n  // static constexpr std::array<int, M> MODS = {INTS...};\n\n  explicit HashT(int a) {\n    for (int i = 0; i < M; ++i) {\n      h[i] = a;\n    }\n  }\n\n  explicit HashT(const HashT &a, const HashT &b) {\n    for (int i = 0; i < M; ++i) {\n      h[i] = 1LL * a.h[i] * b.h[i] % MODS[i];\n    }\n  }\n\n  explicit HashT(const HashT &k, const HashT &b, const HashT &bf) {\n    for (int i = 0; i < M; ++i) {\n      h[i] = 1LL * k.h[i] * (b.h[i] + MODS[i] - bf.h[i]) % MODS[i];\n    }\n  }\n\n  template <int a> void add() {\n    for (int i = 0; i < M; ++i) {\n      h[i] += a >= 0 ? a : MODS[i] + a;\n      if (h[i] >= MODS[i]) {\n        h[i] -= MODS[i];\n      }\n    }\n  }\n\n  void multiplyB() {\n    for (int i = 0; i < M; ++i) {\n      h[i] = 1LL * h[i] * BASE % MODS[i];\n    }\n  }\n\n  void divideB() {\n    for (int i = 0; i < M; ++i) {\n      h[i] = 1LL * h[i] * inv(BASE, MODS[i]) % MODS[i];\n    }\n  }\n\n  int h[M];\n};\n\n// template <int BASE, int... INTS>\n// bool operator<(const HashT<BASE, INTS...> &a, const HashT<BASE, INTS...> &b) {\n// bool operator<(const HashT<BASE, INTS...> &a, const HashT<BASE, INTS...> &b) {\n//   for (int i = 0; i < HashT<BASE, INTS...>::M; ++i) {\nbool operator<(const HashT &a, const HashT &b) {\n  for (int i = 0; i < M; ++i) {\n    if (a.h[i] != b.h[i]) {\n      return a.h[i] < b.h[i];\n    }\n  }\n  return false;\n}\n\nint n;\nchar s[N + 1];\n\n// using Hash = HashT<3, 1000000007, 1000000009>;\nusing Hash = HashT;\n\nstruct Set {\n  Set() : k{1}, b{0} {}\n\n  void add(int c) {\n    if (c == '+') {\n      b.add<-1>();\n    } else if (c == '-') {\n      b.add<1>();\n    } else if (c == '>') {\n      b.multiplyB();\n      k.divideB();\n    } else {\n      k.multiplyB();\n      b.divideB();\n    }\n  }\n\n  Hash zero() const { return Hash{k, b}; }\n  Hash inverse(const Hash &kb) const { return Hash{k, b, kb}; }\n\n  Hash k, b;\n};\n\nint main() {\n  while (scanf(\"%d%s\", &n, s) == 2) {\n    Set setf;\n    for (int i = n - 1; i >= 0; --i) {\n      setf.add(s[i]);\n    }\n    Set set;\n    long long result = 0;\n    std::map<Hash, int> cnt;\n    for (int i = n - 1; i >= 0; --i) {\n      cnt[set.zero()]++;\n      set.add(s[i]);\n      result += cnt[set.inverse(setf.b)];\n    }\n    printf(\"%lld\\n\", result);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef xay5421\n#define D(...) fprintf(stderr,__VA_ARGS__)\n#else\n#define D(...) ((void)0)\n#define NDEBUG\n#endif\n#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\n#define per(i,a,b) for(int i=(a);i>=(b);--i)\nusing namespace std;\ntypedef long long LL;\nconst int N=250005,K=6,P=1e9+9,X[K]={137,197,101,103,107,109};\nint n,key[K],iX[K],k[N][K],b[N][K];\nLL ans;\nmap<vector<int>,int>mp;\nint fpow(int k1,int k2){\n\tint k3=1;\n\tfor(;k2;k2>>=1,k1=1LL*k1*k1%P)if(k2&1)k3=1LL*k3*k1%P;\n\treturn k3;\n}\nvoid pt(const vector<int>&a){\n\tfor(auto x:a)D(\"%d \",x);\n\tD(\"\\n\");\n}\nchar s[N];\nint main(){\n#ifdef xay5421\n\tfreopen(\"a.in\",\"r\",stdin);\n#endif\n\trep(i,0,K-1)iX[i]=fpow(X[i],P-2);\n\tscanf(\"%d%s\",&n,s+1);\n\tper(i,n,1){\n\t\trep(j,0,K-1){\n\t\t\tswitch(s[i]){\n\t\t\t\tcase'<':\n\t\t\t\t\tkey[j]=1LL*key[j]*iX[j]%P;\n\t\t\t\t\tbreak;\n\t\t\t\tcase'>':\n\t\t\t\t\tkey[j]=1LL*key[j]*X[j]%P;\n\t\t\t\t\tbreak;\n\t\t\t\tcase'+':\n\t\t\t\t\tkey[j]=(key[j]+1)%P;\n\t\t\t\t\tbreak;\n\t\t\t\tcase'-':\n\t\t\t\t\tkey[j]=(key[j]+P-1)%P;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\trep(j,0,K-1)k[n+1][j]=1;\n\tper(i,n,1){\n\t\trep(j,0,K-1){\n\t\t\tk[i][j]=k[i+1][j];\n\t\t\tb[i][j]=b[i+1][j];\n\t\t\tswitch(s[i]){\n\t\t\t\tcase'<':\n\t\t\t\t\tk[i][j]=1LL*k[i][j]*X[j]%P;\n\t\t\t\t\tbreak;\n\t\t\t\tcase'>':\n\t\t\t\t\tk[i][j]=1LL*k[i][j]*iX[j]%P;\n\t\t\t\t\tbreak;\n\t\t\t\tcase'+':\n\t\t\t\t\tb[i][j]=(b[i][j]+P-k[i][j])%P;\n\t\t\t\t\tbreak;\n\t\t\t\tcase'-':\n\t\t\t\t\tb[i][j]=(b[i][j]+k[i][j])%P;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tauto get0=[&](int i){\n\t\treturn vector<int>(b[i],b[i]+K);\n\t};\n\tauto get=[&](int i){\n\t\tvector<int>res(K);\n\t\trep(j,0,K-1)res[j]=(1LL*k[i][j]*key[j]+b[i][j])%P;\n\t\treturn res;\n\t};\n\tmp[get0(n+1)]=1;\n\tper(i,n,1){\n\t\tauto now=get(i);\n\t\t//pt(now);\n\t\tif(mp.count(now)){\n\t\t\tD(\"ans[%d]=%d\\n\",i,mp[now]);\n\t\t\tans+=mp[now];\n\t\t}\n\t\t++mp[get0(i)];\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<iostream>\n#define LL long long\n#define MP make_pair\nusing namespace std;\nconst LL mod=1e9+7;\nLL base[4],pre[4][500010],inv[4];\nstruct node{LL a,b;}op[4][250010];\nmap<pair<pair<LL,LL>,pair<LL,LL> >,LL> mp;\nLL pow(LL a,LL b)\n{\n\tLL ans=1;\n\twhile(b)\n\t{\n\t\tif(b&1) ans=ans*a%mod;\n\t\ta=a*a%mod;b>>=1;\n\t}\n\treturn ans;\n}\nLL n,p=0,t[500010],c[4],a[4][250010],b[4][250010];\nchar s[250010];\nvoid Pre()\n{\n\tfor(int k=0;k<4;k++)\n\t{\n\t\tLL cnt=1;op[k][n+1].a=1;\n\t\tfor(LL i=n;i>=1;i--)\n\t\t{\n\t\t\top[k][i]=op[k][i+1];\n\t\t\tif(s[i]=='<') cnt=cnt*base[k]%mod,(op[k][i].a*=base[k])%=mod;\n\t\t\tif(s[i]=='>') cnt=cnt*inv[k]%mod,(op[k][i].a*=inv[k])%=mod;\n\t\t\tif(s[i]=='-') (op[k][i].b+=cnt*pre[k][n]%mod)%=mod;\n\t\t\tif(s[i]=='+') op[k][i].b=((op[k][i].b-cnt*pre[k][n]%mod)%mod+mod)%mod;\n\t\t}\n\t}\n}\nvoid solve(LL *a,LL c,LL k) {for(LL i=1;i<=n;i++) a[i]=(c*op[k][i].a%mod+op[k][i].b)%mod;}\nint main()\n{\n\tbase[0]=12281;base[1]=92083;base[2]=12255871;base[3]=998244353;\n\tfor(int i=0;i<4;i++) inv[i]=pow(base[i],mod-2);\n\tscanf(\"%lld\",&n);getchar();\n\tscanf(\"%s\",s+1);\n\tfor(LL k=0;k<4;k++)\n\t{\n\t\tpre[k][0]=1;for(LL i=1;i<=2*n;i++) pre[k][i]=pre[k][i-1]*base[k]%mod;\n\t}\n\tfor(LL i=1;i<=n;i++)\n\t{\n\t\tif(s[i]=='<') p--;if(s[i]=='>') p++;\n\t\tif(s[i]=='-') t[p+n]--;if(s[i]=='+') t[p+n]++;\n\t}\n\tfor(int k=0;k<4;k++)\n\t\tfor(LL i=-n;i<=n;i++) (c[k]+=pre[k][i+n]*t[i+n]%mod)%=mod;\n\tPre();\n\tfor(int i=0;i<4;i++) solve(a[i],0,i);\n\tfor(int i=0;i<4;i++) solve(b[i],c[i],i);\n\tLL ans=0;\n\tfor(LL i=2;i<=n+1;i++)\n\t{\n\t\tmp[MP(MP(b[0][i-1],b[1][i-1]),MP(b[2][i-1],b[3][i-1]))]++;\n\t\tans+=mp[MP(MP(a[0][i],a[1][i]),MP(a[2][i],a[3][i]))];\n\t}\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for (int i = (a); i <= (b); ++ i)\n#define rrp(i,a,b) for (int i = (a); i >= (b); -- i)\n#define gc() getchar()\n#define fir first\n#define sec second\ntypedef pair<int,int> pii;\ntypedef long double db;\ntypedef long long ll;\ntemplate <typename tp>\ninline void read(tp& x) {\n  x = 0; char tmp; bool key = 0;\n  for (tmp = gc(); !isdigit(tmp); tmp = gc())\n    key = (tmp == '-');\n  for (; isdigit(tmp); tmp = gc())\n    x = (x << 3) + (x << 1) + (tmp ^ '0');\n  if (key) x = -x;\n}\ntemplate <typename tp>\ninline void ckmn(tp& x,tp y) {\n  x = x < y ? x : y;\n}\ntemplate <typename tp>\ninline void ckmx(tp& x,tp y) {\n  x = x < y ? y : x;\n}\n\nconst int N = 250010, MOD = (int)(1e9 + 7), BAS = 233;\ninline void Add(int& x,int y) {\n  x = x + y >= MOD ? x + y - MOD : x + y;\n}\ninline void Sub(int& x,int y) {\n  x = x - y < 0 ? x - y + MOD : x - y;\n}\nint power(int a,int b) {\n  int ret = 1;\n  while (b) {\n    if (b&1) ret = 1ll * ret * a % MOD;\n    a = 1ll * a * a % MOD;\n    b >>= 1;\n  }\n  return ret;\n}\n\nchar str[N];\nint n, pw[N << 1], ipw[N << 1], rec, val[2][N], tmp[2][N];\nll ans;\nmap<int,int> mp;\nvoid solve(int l,int r) {\n  if (l == r) {\n    if (val[1][l] == rec)\n      ++ ans;\n    return;\n  }\n  int mid = (l + r) >> 1;\n  mp.clear();\n  tmp[0][mid] = val[0][mid], tmp[1][mid] = val[1][mid];\n  rrp (i, mid-1, l) {\n    tmp[0][i] = 1ll * val[0][i] * tmp[0][i+1] % MOD;\n    tmp[1][i] = (1ll * val[0][i] * tmp[1][i+1] + val[1][i]) % MOD;\n  }\n  tmp[0][mid+1] = val[0][mid+1], tmp[1][mid+1] = val[1][mid+1];\n  rep (i, mid+2, r) {\n    tmp[0][i] = 1ll * tmp[0][i-1] * val[0][i] % MOD;\n    tmp[1][i] = (1ll * tmp[0][i-1] * val[1][i] + tmp[1][i-1]) % MOD;\n  }\n  rep (i, mid+1, r) ++ mp[tmp[1][i]];\n  rep (i, l, mid) {\n    // tmp[0][i] * v + tmp[1][i] = rec\n    int v = rec;\n    Sub(v, tmp[1][i]);\n    v = 1ll * v * power(tmp[0][i], MOD - 2) % MOD;\n    ans += mp[v];\n  }\n  solve(l, mid);\n  solve(mid+1, r);\n}\nint main() {\n  read(n);\n  scanf(\"%s\", str+1);\n  pw[0] = ipw[0] = 1;\n  rep (i, 1, n * 2) pw[i] = 1ll * pw[i-1] * BAS % MOD;\n  ipw[1] = power(BAS, MOD - 2);\n  rep (i, 2, n*2) ipw[i] = 1ll * ipw[i-1] * ipw[1] % MOD;\n  rep (i, 1, n) {\n    if (str[i] == '+') val[0][i] = 1, val[1][i] = 1;\n    if (str[i] == '-') val[0][i] = 1, val[1][i] = MOD - 1;\n    if (str[i] == '<') val[0][i] = pw[1];\n    if (str[i] == '>') val[0][i] = ipw[1];\n  }\n  rrp (i, n, 1)\n    rec = (1ll * rec * val[0][i] + val[1][i]) % MOD;\n  solve(1, n);\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long n,x2=1,ans,x1=131,xx=x1,a1[1000001],a2[1000001];\nmap<unsigned long long,int>t;\nstring st,s;\ninline long long read()\n{\n   long long sum=0,x=1;\n   char ch=getchar();\n   while (ch<'0'||ch>'9')\n   {\n       if (ch=='-')\n\t     x=-1;\n\t   ch=getchar();\n   }\n   while (ch>='0'&&ch<='9')\n   {\n   \t   sum=sum*10+ch-'0';\n\t   ch=getchar();\n   }\n   return sum*x;\n}\ninline void write(long long x)\n{\n    if (x<0)\n\t{\n        putchar('-');\n        x=-x;\n    }\n    if (x>9)\n      write(x/10);\n    putchar(x%10+'0');\n    return;\n}\nint main()\n{\n\tn=read();\n\tfor (register int i=1;i<64;++i)\n\t{\n\t\tx2*=xx;\n\t\txx*=xx;\n\t}\n\tcin>>st;s=' '+st;\n\ta2[0]=1;\n\tfor (register int i=1;i<=n;++i)\n\t{\n\t\ta1[i]=a1[i-1];a2[i]=a2[i-1];\n\t\tif (s[i]=='+')\n\t\t  a1[i]+=a2[i];else\n\t\tif (s[i]=='-')\n\t\t  a1[i]-=a2[i];else\n\t\tif (s[i]=='<')\n\t\t  a2[i]*=x2;else\n\t\t  a2[i]*=x1;\n\t\t++t[a1[i]];\n\t}\n\tfor (register int i=1;i<=n;++i)\n\t{\n\t\tans+=t[a1[n]*a2[i-1]+a1[i-1]];\n\t\t--t[a1[i]];\n\t}\n\twrite(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=3e5+5,mod1=998244353,mod2=1000000007,mod3=2333;\nint n,x=799633,invx1,invx2,invx3;\nll sum1=1,sum2=1,sum3=1;\nll s1[N],s2[N],s3[N];\nchar s[N];\nll inv(ll x,ll mod){return x==1?x:(mod-mod/x)*inv(mod%x,mod)%mod;}\nstruct node\n{\n    ll s1,s2,s3;\n    node(ll s1=0,ll s2=0,ll s3=0):s1(s1),s2(s2),s3(s3){}\n    void add()\n    { s1=(s1+sum1)%mod1;s2=(s2+sum2)%mod2;s3=(s3+sum3)%mod3;}\n    void sub()\n    { s1=(s1+mod1-sum1)%mod1;s2=(s2+mod2-sum2)%mod2;s3=(s3+mod3-sum3)%mod3;}\n    bool operator<(const node&o)const\n    {\n        if(s1==o.s1&&s2==o.s2) return s3<o.s3;\n        if(s1==o.s1) return s2<o.s2;\n        return s1<o.s1;\n    }\n};\nvoid div()\n{\n    sum1=sum1*invx1%mod1;\n    sum2=sum2*invx2%mod2;\n    sum3=sum3*invx3%mod3;\n}\nvoid mul()\n{\n    sum1=sum1*x%mod1;\n    sum2=sum2*x%mod2;\n    sum3=sum3*x%mod3;\n}\nnode f[N];\nmap<node,int>mp;\nint main()\n{\n    invx1=inv(x%mod1,mod1);\n    invx2=inv(x%mod2,mod2);\n    invx3=inv(x%mod3,mod3);\n    scanf(\"%d\",&n);\n    scanf(\"%s\",s+1);\n    for(int i=1;i<=n;i++)\n    {\n        f[i]=f[i-1];\n        if(s[i]=='>') div();\n        if(s[i]=='<') mul();\n        if(s[i]=='+') f[i].add();\n        if(s[i]=='-') f[i].sub();\n        mp[f[i]]++;\n    }\n    sum1=sum2=sum3=1;\n    node now;\n    ll ans=mp[f[n]];\n    for(int i=1;i<=n;i++)\n    {\n        mp[f[i]]--;\n        if(s[i]=='>') div();\n        if(s[i]=='<') mul();\n        if(s[i]=='+') now.add();\n        if(s[i]=='-') now.sub();\n        node p=now;\n        p.s1=(p.s1+f[n].s1*sum1)%mod1;\n        p.s2=(p.s2+f[n].s2*sum2)%mod2;\n        p.s3=(p.s3+f[n].s3*sum3)%mod3;\n        ans+=mp[p];\n    }\n    printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define mod 1000000007\nusing namespace std;\nint n,f[1001000],X,Y,ans;\nchar S[1001000];\nmap<int,int>mp;\nint quickpow(int x,int y){\n\tif(y==0)return 1;\n\tif(y%2==0)return quickpow(x*x%mod,y/2);\n\treturn quickpow(x*x%mod,y/2)*x%mod;\n}\nsigned main(){\n\tscanf(\"%lld%s\",&n,S+1);\n\tX=1;\n\tint base=10007,inv=quickpow(base,mod-2);\n\tfor(int i=1;i<=n;i++){\n\t\tif(S[i]=='+')f[i]=f[i-1]+X;\n\t\tif(S[i]=='-')f[i]=f[i-1]-X;\n\t\tif(S[i]=='<')f[i]=f[i-1],X=X*base%mod;\n\t\tif(S[i]=='>')f[i]=f[i-1],X=X*inv%mod;\n\t\tmp[f[i]]++;\t\t\n\t}\n\tX=1,Y=0;\n\tfor(int i=1;i<=n;i++){\n\t\tans=ans+mp[f[n]*X+Y];\n\t\tif(S[i]=='+')Y=Y+X;\n\t\tif(S[i]=='-')Y=Y-X;\n\t\tif(S[i]=='<')X=X*base%mod;\n\t\tif(S[i]=='>')X=X*inv%mod;\n\t\tmp[f[i]]--;\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 3e5, mod = 1e9 + 9;\nint sd[6], isd[6];\nint n, res[6];\nchar s[maxn + 10];\nmap<ll, int> mp;\nll ans;\n\nint fpow(int x, int y) {\n\tint ans = 1;\n\twhile (y) {\n\t\tif (y & 1) ans = 1ll * ans * x % mod;\n\t\ty >>= 1; x = 1ll * x * x % mod;\n\t}\n\treturn ans;\n}\n\nstruct data {\n\tint k[6], b[6];\n\n\tll getans() {\n\t\tll x = 0, y = 0;\n\t\tfor (int i = 0; i < 6; ++i) {\n\t\t\tint w = 1ll * (res[i] - b[i] + mod) * fpow(k[i], mod - 2) % mod;\n\t\t\tif (i < 3)\n\t\t\t\t(x += 1ll * w * (i + 1) % mod) %= mod;\n\t\t\telse\n\t\t\t\t(y += 1ll * w * (i + 1) % mod) %= mod;\n\t\t}\n\t\treturn x | (y << 32ll);\n\t}\n\n\tll hsh() {\n\t\tll x = 0, y = 0;\n\t\tfor (int i = 0; i < 6; ++i) {\n\t\t\tif (i < 3) \n\t\t\t\t(x += 1ll * b[i] * (i + 1) % mod) %= mod;\n\t\t\telse \n\t\t\t\t(y += 1ll * b[i] * (i + 1) % mod) %= mod;\n\t\t}\n\t\treturn x | (y << 32ll);\n\t}\n\n\tvoid init() {\n\t\tfor (int i = 0; i < 6; ++i) {\n\t\t\tk[i] = 1; b[i] = 0;\n\t\t}\n\t}\n\n}s1[maxn + 10], s2[maxn + 10];\n\ndata operator + (const data &a, const data &b) {\n\tdata ans;\n\tfor (int i = 0; i < 6; ++i) {\n\t\tans.k[i] = 1ll * a.k[i] * b.k[i] % mod;\n\t\tans.b[i] = (b.b[i] + 1ll * a.b[i] * b.k[i]) % mod;\n\t}\n\treturn ans;\n}\n\ndata inv(const data &a) {\n\tdata ans;\n\tfor (int i = 0; i < 6; ++i) {\n\t\tans.k[i] = fpow(a.k[i], mod - 2);\n\t\tans.b[i] = (mod - 1ll * ans.k[i] * a.b[i] % mod) % mod;\n\t}\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tscanf(\"%s\", s + 1);\n\tfor (int i = 0; i < 6; ++i) {\n\t\tsd[i] = rand() % mod;\n\t\tisd[i] = fpow(sd[i], mod - 2);\n\t}\n\ts1[0].init(); s2[0].init();\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 0; j < 6; ++j)\n\t\t\tif (s[i] == '+') {\n\t\t\t\ts1[i].k[j] = 1;\n\t\t\t\ts1[i].b[j] = 1;\n\t\t\t} else if (s[i] == '-') {\n\t\t\t\ts1[i].k[j] = 1;\n\t\t\t\ts1[i].b[j] = mod - 1;\n\t\t\t} else if (s[i] == '>') {\n\t\t\t\ts1[i].k[j] = sd[j];\n\t\t\t\ts1[i].b[j] = 0;\n\t\t\t} else if (s[i] == '<') {\n\t\t\t\ts1[i].k[j] = isd[j];\n\t\t\t\ts1[i].b[j] = 0;\n\t\t\t}\n\t\ts2[i] = inv(s1[i]);\n\t\ts1[i] = s1[i] + s1[i - 1];\n\t\ts2[i] = s2[i - 1] + s2[i];\n\t}\n\tfor (int i = 0; i < 6; ++i) res[i] = s1[n].b[i];\n\tfor (int i = 1; i <= n; ++i) {\n\t\t++mp[s2[i - 1].getans()];\n\t\tans += mp[s1[i].hsh()];\n\t}\n\tprintf(\"%lld\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "//khodaya khodet komak kon\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define all(x) x.begin(), x.end()\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#define int long long\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int N = 250000 + 10;\nconst ll MOD = 1000000000 + 7;\nconst ll INF = 1000000010;\nconst ll LOG = 25;\nconst int H = 786433;\n\nint a[2 * N], n, M, S, inv, Hash;\nmap<int, int> cnt;\nstring s;\n\nint mul(int a, int b){\n\treturn (a * 1ll * b) % MOD;\n}\n\nint add(int a, int b){\n\ta += b;\n\ta %= MOD;\n\ta += MOD;\n\ta %= MOD;\n\treturn a;\n}\n\nint minu(int a, int b){\n\ta -= b;\n\ta %= MOD;\n\ta += MOD;\n\ta %= MOD;\n\treturn a;\n}\n\nint POW(int a, int b){\n\tint res = 1;\n\twhile (b){\n\t\tif (b & 1) res = mul(res, a);\n\t\tb >>= 1;\n\t\ta = mul(a, a);\n\t}\n\treturn res;\n}\n\nint Solve(int x){\n\tint res = minu(x, S);\n\tres = mul(res, POW(M, MOD - 2));\n\treturn res;\n}\n\nint32_t main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> n;\n\tcin >> s;\n\tint pnt = N;\n\tfor (int i = 1; i <= n; i++){\n\t\tif (s[i - 1] == '>') pnt++;\n\t\telse if(s[i - 1] == '<') pnt--;\n\t\telse if(s[i - 1] == '+') a[pnt]++;\n\t\telse a[pnt]--;\n\t}\n//\tcout << a[N + 1] << ' ' << a[N] << '\\n';\n\tfor (int i = 2 * N - 1; i >= 0; i--){\n\t\tHash = add(mul(Hash, H), a[i]);\t\n//\t\tcout << Hash << '\\n';\n\t}\n//\tcout << Hash << '\\n';\n\tinv = POW(H, MOD - 2);\n\tM = 1;\n\tint ans = 0;\n//\tcnt[0] ++;\n//\tcout << POW(H, N + 1) << '\\n';\n\tfor (int i = n; i >= 1; i--){\n\t\tint now = 0;\n\t\tif (s[i - 1] == '>'){\n\t\t\tM = mul(M, H);\n\t\t\tS = mul(S, H);\n\t\t}else if(s[i - 1] == '<'){\n\t\t\tM = mul(M, inv);\n\t\t\tS = mul(S, inv);\n\t\t}else if(s[i - 1] == '+'){\n\t\t\tS = add(S, POW(H, N));\n\t\t\tnow = POW(H, N);\n\t\t}else if(s[i - 1] == '-'){\n\t\t\tS = minu(S, POW(H, N));\n\t\t\tnow = minu(0, POW(H, N));\n\t\t}\n\t\tint x = Solve(now);\n\t\tcnt[x]++;\n\t\tx = Solve(Hash);\n\t\tans = add(ans, cnt[x]);\n\t}\n\tcout << ans;\n\n\n\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "const int N = 250005;\nconst int LG = 21;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nint n;\nstring s;\nll sufa[N];\nll suf0[N];\nll sufa2[N];\nll suf02[N];\nconst ll K = 1e6 + 3;\nconst ll K2 = 1791791;\nconst ll rK = rev(K);\nconst ll rK2 = rev(K2);\nll pref0[N];\nll pref02[N];\nll moves[N];\nmap<int, ll> deg, deg2;\n\nsigned main()\n{\n    deg[0] = 1;\n    deg2[0] = 1;\n    for (int i = 1; i < N; i++) deg[i] = deg[i - 1] * K % MOD;\n    for (int i = 1; i < N; i++) deg2[i] = deg2[i - 1] * K2 % MOD;\n    for (int i = 1; i < N; i++) deg[-i] = deg[-i + 1] * rK % MOD;\n    for (int i = 1; i < N; i++) deg2[-i] = deg2[-i + 1] * rK2 % MOD;\n    srand(time(NULL));\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n    cin >> n >> s;\n    ll a = 0, a2 = 0;\n    for (int i = n - 1; i >= 0; i--)\n    {\n        if (s[i] == '+')\n        {\n            a = (a + MOD - 1) % MOD;\n            a2 = (a2 + MOD - 1) % MOD;\n        }\n        if (s[i] == '-')\n        {\n            a = (a + 1) % MOD;\n            a2 = (a2 + 1) % MOD;\n        }\n        if (s[i] == '>')\n        {\n            a = (a * K) % MOD;\n            a2 = (a2 * K2) % MOD;\n        }\n        if (s[i] == '<')\n        {\n            a = (a * rK) % MOD;\n            a2 = (a2 * rK2) % MOD;\n        }\n    }\n    if (s[0] == '+') pref0[0] = (pref0[0] + 1) % MOD;\n    if (s[0] == '+') pref02[0] = (pref02[0] + 1) % MOD;\n    if (s[0] == '-') pref0[0] = (pref0[0] + MOD - 1) % MOD;\n    if (s[0] == '-') pref02[0] = (pref02[0] + MOD - 1) % MOD;\n    if (s[0] == '<') pref0[0] = (pref0[0] * K) % MOD;\n    if (s[0] == '<') pref02[0] = (pref02[0] * K2) % MOD;\n    if (s[0] == '>') pref0[0] = (pref0[0] * rK) % MOD;\n    if (s[0] == '>') pref02[0] = (pref02[0] * rK2) % MOD;\n    if (s[0] == '>') moves[0]++;\n    if (s[0] == '<') moves[0]--;\n    for (int i = 1; i < n; i++)\n    {\n        if (s[i] == '+') pref0[i] = (pref0[i - 1] + 1) % MOD;\n        if (s[i] == '+') pref02[i] = (pref02[i - 1] + 1) % MOD;\n        if (s[i] == '-') pref0[i] = (pref0[i - 1] + MOD - 1) % MOD;\n        if (s[i] == '-') pref02[i] = (pref02[i - 1] + MOD - 1) % MOD;\n        if (s[i] == '<') pref0[i] = (pref0[i - 1] * K) % MOD;\n        if (s[i] == '<') pref02[i] = (pref02[i - 1] * K2) % MOD;\n        if (s[i] == '>') pref0[i] = (pref0[i - 1] * rK) % MOD;\n        if (s[i] == '>') pref02[i] = (pref02[i - 1] * rK2) % MOD;\n        moves[i] = moves[i - 1];\n        if (s[i] == '>') moves[i]++;\n        if (s[i] == '<') moves[i]--;\n    }\n    for (int j = 0; j < n; j++)\n    {\n        if (s[j] == '+')\n        {\n            suf0[0] = (suf0[0] + 1) % MOD;\n            suf02[0] = (suf02[0] + 1) % MOD;\n        }\n        if (s[j] == '-')\n        {\n            suf0[0] = (suf0[0] + MOD - 1) % MOD;\n            suf02[0] = (suf02[0] + MOD - 1) % MOD;\n        }\n        if (s[j] == '<')\n        {\n            suf0[0] = (suf0[0] * K) % MOD;\n            suf02[0] = (suf02[0] * K2) % MOD;\n        }\n        if (s[j] == '>')\n        {\n            suf0[0] = (suf0[0] * rK) % MOD;\n            suf02[0] = (suf02[0] * rK2) % MOD;\n        }\n    }\n    if (a != 0 || a2 != 0) return 1;\n    for (int i = 0; i < n; i++) suf0[i + 1] = (suf0[0] - pref0[i] * deg[moves[i]] + MOD * MOD) % MOD;\n    for (int i = 0; i < n; i++) suf02[i + 1] = (suf02[0] - pref02[i] * deg2[moves[i]] + MOD * MOD) % MOD;\n    for (int i = 0; i < n; i++) sufa[i] = (suf0[i] + a * deg[(i > 0 ? moves[i - 1] : 0) - moves[n - 1]]) % MOD;\n    for (int i = 0; i < n; i++) sufa2[i] = (suf02[i] + a2 * deg2[(i > 0 ? moves[i - 1] : 0) - moves[n - 1]]) % MOD;\n    ll ans = 0;\n    map<vector<ll>, ll> cnt;\n    for (int i = n; i >= 0; i--)\n    {\n        ans += cnt[{sufa[i], sufa2[i]}];\n        cout << cnt[{sufa[i], sufa2[i]}] << \" \";\n        cnt[{suf0[i], suf02[i]}]++;\n    }\n    cout << ans;\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long lint;\n\nlint modpow(lint x, lint y, lint mod) {\n  lint ret = 1 % mod, x2p = x;\n  while (y > 0) {\n    if (y % 2) ret = (__int128)ret * x2p % mod;\n    y /= 2;\n    x2p = (__int128)x2p * x2p % mod;\n  }\n  return ret;\n}\nconstexpr int nmods = 3;\nconstexpr lint mod[] = {1152921504609811141LL, 4611676018431352883LL,\n                        4611676018431352883LL};\nconstexpr lint base[] = {102999959LL, 1073741663LL, 599831LL};\nlint inv_base[nmods];\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  string seq(n, ' ');\n  for (int i = 0; i < n; ++i)\n    scanf(\" %c\", &seq[i]);\n\n  vector<int> pos_before(n);\n\n  vector<vector<lint>> base_pow(nmods, vector<lint>(n + 1));\n  vector<vector<lint>> inv_base_pow(nmods, vector<lint>(n + 1));\n  vector<vector<lint>> hash_diff(nmods, vector<lint>(n, 0));\n  vector<vector<lint>> suffix(nmods, vector<lint>(n + 1));\n  vector<lint> full_seq_hash(nmods);\n  for (int k = 0; k < nmods; ++k) {\n    base_pow[k][0] = 1;\n    for (int i = 1; i <= n; ++i)\n      base_pow[k][i] = (__int128)base[k] * base_pow[k][i - 1] % mod[k];\n\n    inv_base[k] = modpow(base[k], mod[k] - 2, mod[k]);\n    assert((__int128)base[k] * inv_base[k] % mod[k] == 1);\n\n    inv_base_pow[k][0] = 1;\n    for (int i = 1; i <= n; ++i)\n      inv_base_pow[k][i] = (__int128)inv_base[k] * inv_base_pow[k][i - 1] % mod[k];\n\n    int pos = 0;\n    for (int i = 0; i < n; ++i) {\n      pos_before[i] = pos;\n      if (seq[i] == '>') ++pos;\n      else if (seq[i] == '<') --pos;\n      else {\n        lint base_pow_pos;\n        if (pos >= 0) base_pow_pos = base_pow[k][pos];\n        else base_pow_pos = inv_base_pow[k][-pos];\n        if (seq[i] == '+') hash_diff[k][i] = base_pow_pos;\n        else if (seq[i] == '-') {\n          hash_diff[k][i] = mod[k] - base_pow_pos;\n          assert(0 <= hash_diff[k][i]);\n          assert(hash_diff[k][i] < mod[k]);\n        } else assert(0);\n      }\n    }\n    full_seq_hash[k] = 0;\n    for (int i = 0; i < n; ++i) {\n      full_seq_hash[k] += hash_diff[k][i];\n      if (full_seq_hash[k] >= mod[k]) full_seq_hash[k] -= mod[k];\n    }\n\n    suffix[k][n] = 0;\n    for (int i = n - 1; i >= 0; --i) {\n      suffix[k][i] = hash_diff[k][i] + suffix[k][i + 1];\n      if (suffix[k][i] >= mod[k]) suffix[k][i] -= mod[k];\n    }\n  }\n\n  lint result = 0;\n  map<vector<lint>, int> count;\n  count[vector<lint>(nmods, 0LL)] += 1;\n  for (int i = n - 1; i >= 0; --i) {\n    vector<lint> shifted_full(nmods);\n    for (int k = 0; k < nmods; ++k) {\n      if (pos_before[i] >= 0) {\n        shifted_full[k] = (__int128)full_seq_hash[k] * base_pow[k][pos_before[i]] % mod[k];\n      } else {\n        shifted_full[k] = (__int128)full_seq_hash[k] * inv_base_pow[k][-pos_before[i]] % mod[k];\n      }\n    }\n\n    vector<lint> target(nmods);\n    for (int k = 0; k < nmods; ++k) {\n      target[k] = suffix[k][i] - shifted_full[k];\n      if (target[k] < 0) target[k] += mod[k];\n    }\n\n    auto it = count.find(target);\n    if (it != count.end())\n      result += it->second;\n\n    vector<lint> suffix_vec(nmods);\n    for (int k = 0; k < nmods; ++k)\n      suffix_vec[k] = suffix[k][i];\n\n    count[suffix_vec] += 1;\n  }\n  printf(\"%lld\\n\", result);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e6+5;\nconst int mod1=1e9+7;\nconst int P1=19260817;\nconst int P2=998244353;\nconst int mod2=1004535809;\n#define ll long long\ntypedef pair<ll,ll>Pi;\nll fsp(ll x,int y){\n    ll ans=1;\n    while(y){\n        if(y&1) ans=ans*x%mod1;\n        x=x*x%mod1,y>>=1;\n    }\n    return ans;\n}\nll ksm(ll x,int y){\n    ll ans=1;\n    while(y){\n        if(y&1) ans=ans*x%mod2;\n        x=x*x%mod2,y>>=1;\n    }\n    return ans;\n}\nchar s[N];\nmap<Pi,int>ma;\nll n,l1,l2=1,r1,r2=1,ans,res1,res2,add1,add2,inv1,inv2;\nint main(){\n    scanf(\"%lld%s\",&n,s+1);\n    add1=fsp(P1,n);add2=ksm(P2,n);\n    inv1=fsp(P1,mod1-2),inv2=ksm(P2,mod2-2);\n    for(int i=n;i;i--){\n        if(s[i]=='-'){\n            res1=(res1-add1+mod1)%mod1;\n            res2=(res2-add2+mod2)%mod2;\n        }\n        if(s[i]=='+'){\n            res1=(res1+add1)%mod1;\n            res2=(res2+add2)%mod2;\n        }\n        if(s[i]=='<'){\n            res1=res1*inv1%mod1;\n            res2=res2*inv2%mod2;\n        }\n        if(s[i]=='>'){\n            res1=res1*P1%mod1;\n            res2=res2*P2%mod2;\n        }\n    }\n    for(int i=n;i;i--){\n        ll k1=0,k2=0;\n        if(s[i]=='-'){\n            l1=(l1-add1+mod1)%mod1,k1=mod1-add1;\n            r1=(r1-add2+mod2)%mod2,k2=mod2-add2;\n        }\n        if(s[i]=='<'){\n            l1=l1*inv1%mod1,l2=l2*inv1%mod1;\n            r1=r1*inv2%mod2,r2=r2*inv2%mod2;\n        }\n        if(s[i]=='>'){\n            l1=l1*P1%mod1,l2=l2*P1%mod1;\n            r1=r1*P2%mod2,r2=r2*P2%mod2;\n        }\n        if(s[i]=='+'){\n            l1=(l1+add1)%mod1,k1=add1;\n            r1=(r1+add2)%mod2,k2=add2;\n        }\n        ++ma[Pi((k1-l1+mod1)*fsp(l2,mod1-2)%mod1,(k2-r1+mod2)*ksm(r2,mod2-2)%mod2)];\n        ans+=ma[Pi((res1-l1+mod1)*fsp(l2,mod1-2)%mod1,(res2-r1+mod2)*ksm(r2,mod2-2)%mod2)];\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "const int N = 250005;\nconst int LG = 21;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nint n;\nstring s;\nll sufa[N];\nll suf0[N];\nll sufa2[N];\nll suf02[N];\nconst ll K = 1e6 + 3;\nconst ll K2 = 1791791;\nconst ll rK = rev(K);\nconst ll rK2 = rev(K2);\nll pref0[N];\nll pref02[N];\nll moves[N];\nmap<int, ll> deg, deg2;\n\nsigned main()\n{\n    deg[0] = 1;\n    deg2[0] = 1;\n    for (int i = 1; i < N; i++) deg[i] = deg[i - 1] * K % MOD;\n    for (int i = 1; i < N; i++) deg2[i] = deg2[i - 1] * K2 % MOD;\n    for (int i = 1; i < N; i++) deg[-i] = deg[-i + 1] * rK % MOD;\n    for (int i = 1; i < N; i++) deg2[-i] = deg2[-i + 1] * rK2 % MOD;\n    srand(time(NULL));\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n    cin >> n >> s;\n    ll a = 0, a2 = 0;\n    for (int i = n - 1; i >= 0; i--)\n    {\n        if (s[i] == '+')\n        {\n            a = (a + MOD - 1) % MOD;\n            a2 = (a2 + MOD - 1) % MOD;\n        }\n        if (s[i] == '-')\n        {\n            a = (a + 1) % MOD;\n            a2 = (a2 + 1) % MOD;\n        }\n        if (s[i] == '>')\n        {\n            a = (a * K) % MOD;\n            a2 = (a2 * K2) % MOD;\n        }\n        if (s[i] == '<')\n        {\n            a = (a * rK) % MOD;\n            a2 = (a2 * rK2) % MOD;\n        }\n    }\n    if (s[0] == '+') pref0[0] = (pref0[0] + 1) % MOD;\n    if (s[0] == '+') pref02[0] = (pref02[0] + 1) % MOD;\n    if (s[0] == '-') pref0[0] = (pref0[0] + MOD - 1) % MOD;\n    if (s[0] == '-') pref02[0] = (pref02[0] + MOD - 1) % MOD;\n    if (s[0] == '<') pref0[0] = (pref0[0] * K) % MOD;\n    if (s[0] == '<') pref02[0] = (pref02[0] * K2) % MOD;\n    if (s[0] == '>') pref0[0] = (pref0[0] * rK) % MOD;\n    if (s[0] == '>') pref02[0] = (pref02[0] * rK2) % MOD;\n    if (s[0] == '>') moves[0]++;\n    if (s[0] == '<') moves[0]--;\n    for (int i = 1; i < n; i++)\n    {\n        if (s[i] == '+') pref0[i] = (pref0[i - 1] + 1) % MOD;\n        if (s[i] == '+') pref02[i] = (pref02[i - 1] + 1) % MOD;\n        if (s[i] == '-') pref0[i] = (pref0[i - 1] + MOD - 1) % MOD;\n        if (s[i] == '-') pref02[i] = (pref02[i - 1] + MOD - 1) % MOD;\n        if (s[i] == '<') pref0[i] = (pref0[i - 1] * K) % MOD;\n        if (s[i] == '<') pref02[i] = (pref02[i - 1] * K2) % MOD;\n        if (s[i] == '>') pref0[i] = (pref0[i - 1] * rK) % MOD;\n        if (s[i] == '>') pref02[i] = (pref02[i - 1] * rK2) % MOD;\n        moves[i] = moves[i - 1];\n        if (s[i] == '>') moves[i]++;\n        if (s[i] == '<') moves[i]--;\n    }\n    for (int j = 0; j < n; j++)\n    {\n        if (s[j] == '+')\n        {\n            suf0[0] = (suf0[0] + 1) % MOD;\n            suf02[0] = (suf02[0] + 1) % MOD;\n        }\n        if (s[j] == '-')\n        {\n            suf0[0] = (suf0[0] + MOD - 1) % MOD;\n            suf02[0] = (suf02[0] + MOD - 1) % MOD;\n        }\n        if (s[j] == '<')\n        {\n            suf0[0] = (suf0[0] * K) % MOD;\n            suf02[0] = (suf02[0] * K2) % MOD;\n        }\n        if (s[j] == '>')\n        {\n            suf0[0] = (suf0[0] * rK) % MOD;\n            suf02[0] = (suf02[0] * rK2) % MOD;\n        }\n    }\n    if (a == 0 || a2 == 0) return 1;\n    for (int i = 0; i < n; i++) suf0[i + 1] = (suf0[0] - pref0[i] * deg[moves[i]] + MOD * MOD) % MOD;\n    for (int i = 0; i < n; i++) suf02[i + 1] = (suf02[0] - pref02[i] * deg2[moves[i]] + MOD * MOD) % MOD;\n    for (int i = 0; i < n; i++) sufa[i] = (suf0[i] + a * deg[(i > 0 ? moves[i - 1] : 0) - moves[n - 1]]) % MOD;\n    for (int i = 0; i < n; i++) sufa2[i] = (suf02[i] + a2 * deg2[(i > 0 ? moves[i - 1] : 0) - moves[n - 1]]) % MOD;\n    ll ans = 0;\n    map<vector<ll>, ll> cnt;\n    for (int i = n; i >= 0; i--)\n    {\n        ans += cnt[{sufa[i], sufa2[i]}];\n        cout << cnt[{sufa[i], sufa2[i]}] << \" \";\n        cnt[{suf0[i], suf02[i]}]++;\n    }\n    cout << ans;\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "// AtCoder Regular Contest 099\n// Problem F - Eating Symbols Hard\n#include <cstdio>\n#include <cstring>\n#include <iostream>\nusing std::cin; using std::cout; using std::endl;\n#include <algorithm>\nusing std::sort;\n#include <vector>\nusing std::vector;\n#include <queue>\nusing std::queue; using std::priority_queue;\n#include <map>\nusing std::map;\n#include <utility>\nusing std::pair;\ntypedef pair<int, int> pii;\ntypedef long long LL;\n#define pass printf(\"%s : Line.%d\\n\", __FUNCTION__, __LINE__);\nconst int maxN = 250000 + 233; // 2.5e5\nint n;\nchar opt[maxN];\nint d[maxN], df; LL h1[maxN], hf1, h2[maxN], hf2;\n//const LL P = 1e9 + 7;\nbool isp(LL x) {\n\tfor(int i = 2; i*i <= x; ++i)\n\t\tif(x % i == 0) return false;\n\treturn true;\n}\nconst LL p1 = 1000000007;\nconst LL p2 = 1000000123;\nconst LL b1 = 199;\nconst LL b2 = 211;\nLL buc1[maxN*2], buc2[maxN*2];\nLL *pow1 = &buc1[maxN], *pow2 = &buc2[maxN];\nLL inv(LL x, LL p1) {\n\treturn x == 1 ? x : (p1 - (p1 / x) * inv(p1 % x, p1)) % p1;\n}\nLL inc(LL &a, LL b1, LL p1) { return (a += b1) >= p1 ? a -= p1 : a; }\nLL dec(LL &a, LL b1, LL p1) { return (a -= b1) < 0 ? a += p1 : a; }\nmap<pii, int> M;\n\nvoid init() {\n\tpow1[0] = 1; pow2[0] = 1;\n\tpow1[1] = b1; pow1[-1] = inv(b1, p1); pow2[1] = b2; pow2[-1] = inv(b2, p2);\n\tfor(int i = 1; i <= n; ++i) pow1[i] = pow1[i-1] * b1 % p1, pow2[i] = pow2[i-1] * b2 % p2;\n\tfor(int i = -1; i >= -n; --i) pow1[i] = pow1[i+1]* pow1[-1] % p1, pow2[i] = pow2[i+1]* pow2[-1] % p2;\n\thf1 = hf2 = df = 0;\n\tfor(int i = 1; i <= n; ++i) {\n\t\tswitch(opt[i]) {\n\t\t\tcase '+':\n\t\t\t\tinc(hf1, pow1[df], p1);\n\t\t\t\tinc(hf2, pow2[df], p2);\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tdec(hf1, pow1[df], p1);\n\t\t\t\tdec(hf2, pow2[df], p2);\n\t\t\t\tbreak;\n\t\t\tcase '>':\n\t\t\t\t++df;\n\t\t\t\tbreak;\n\t\t\tcase '<':\n\t\t\t\t--df;\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main() {\n//\tfor(int i = (int)1e9; ; ++i) if(isp(i)) printf(\"%d\\n\", i), getchar();\n//\tprintf(\"%.3lfMB\\n\", sizeof(buc1)*6/1000.0/1000.0);\n\tscanf(\"%d%s\", &n, opt + 1);\n\tinit();\n\tLL cnt = 0;\n\tM.clear();\n\th1[0] = h2[0] = d[0] = 0;\n\tM[pii((h1[0] + hf1 * pow1[d[0]]) % p1, (h2[0] + hf2 * pow2[d[0]]) % p2)] = 1;\n\tfor(int i = 1; i <= n; ++i) {\n\t\td[i] = d[i-1]; h1[i] = h1[i-1]; h2[i] = h2[i-1];\n\t\tswitch(opt[i]) {\n\t\t\tcase '+':\n\t\t\t\tinc(h1[i], pow1[d[i]], p1);\n\t\t\t\tinc(h2[i], pow2[d[i]], p2);\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tdec(h1[i], pow1[d[i]], p1);\n\t\t\t\tdec(h2[i], pow2[d[i]], p2);\n\t\t\t\tbreak;\n\t\t\tcase '>':\n\t\t\t\t++d[i];\n\t\t\t\tbreak;\n\t\t\tcase '<':\n\t\t\t\t--d[i];\n\t\t\t\tbreak;\n\t\t}\n//\t\tprintf(\"[%d]: d = %d, h = {%lld, %lld}\\n\", i, d[i], h1[i], h2[i]);\n\t\tpii c(h1[i], h2[i]), ins((h1[i] + hf1 * pow1[d[i]]) % p1, (h2[i] + hf2 * pow2[d[i]]) % p2);\n\t\tif(M.find(c) != M.end()) cnt += M[c]/*, printf(\"i = %d, cnt += %d\\n\", i, M[c])*/;\n\t\tif(M.find(ins) == M.end()) M[ins] = 1; else ++M[ins];\n\t}\n\tprintf(\"%lld\\n\", cnt);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) std::cerr << #x << \" = \" << (x) << std::endl\nusing ll = long long;\nstd::mt19937 mt{std::random_device{}()};\ntemplate <typename T>\nconstexpr std::pair<T, T> extgcd(const T a, const T b)\n{\n    if (b == 0) { return std::pair<T, T>{1, 0}; }\n    const auto p = extgcd(b, a % b);\n    return {p.second, p.first - p.second * (a / b)};\n}\ntemplate <typename T>\nconstexpr T inverse(const T a, const T mod) { return (mod + extgcd(a, mod).first % mod) % mod; }\nconstexpr int H = 5;  //関数値サンプルの個数\nconstexpr ll MOD1 = 1000000007LL, MOD2 = 1000000009LL;\nconstexpr ll X[H] = {2371983LL, 1231LL, 123123LL, 4329075LL, 134121LL};\nconstexpr ll XINV1[H] = {inverse(X[0], MOD1), inverse(X[1], MOD1), inverse(X[2], MOD1), inverse(X[3], MOD1), inverse(X[4], MOD1)};\nconstexpr ll XINV2[H] = {inverse(X[0], MOD2), inverse(X[1], MOD2), inverse(X[2], MOD2), inverse(X[3], MOD2), inverse(X[4], MOD2)};\ntemplate <typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, const std::pair<S, T>& p) { return (os << \"<\" << p.first << \",\" << p.second << \">\"); }\ntemplate <typename T, typename A>\nstd::ostream& operator<<(std::ostream& os, const std::vector<T, A>& v)\n{\n    os << \"[\";\n    for (const auto& p : v) { os << p << \",\"; }\n    return (os << \"]\\n\");\n}\nint main()\n{\n    int N;\n    std::string S;\n    std::cin >> N >> S;\n    using P = std::pair<ll, ll>;\n    std::vector<int> deg(N + 1, 0);\n    std::vector<std::vector<P>> value(N + 1, std::vector<P>(H, {0LL, 0LL}));\n    auto plus = [](const P& p1, const P& p2) { return P{(p1.first + p2.first) % MOD1, (p1.second + p2.second) % MOD2}; };\n    auto minus = [](const P& p1, const P& p2) { return P{(p1.first + MOD1 - p2.first) % MOD1, (p1.second + MOD2 - p2.second) % MOD2}; };\n    auto rshift = [](const P& p, const int i) { return P{p.first * X[i] % MOD1, p.second * X[i] % MOD2}; };\n    auto lshift = [](const P& p, const int i) { return P{p.first * XINV1[i] % MOD1, p.second * XINV2[i] % MOD2}; };\n    auto mul = [](const P& p1, const P& p2) { return P{p1.first * p2.first % MOD1, p1.second * p2.second % MOD2}; };\n    for (int i = N - 1; i >= 0; i--) {\n        if (S[i] == '-') {\n            deg[i] = deg[i + 1];\n            for (int j = 0; j < H; j++) { value[i][j] = minus(value[i + 1][j], {1, 1}); }\n        } else if (S[i] == '+') {\n            deg[i] = deg[i + 1];\n            for (int j = 0; j < H; j++) { value[i][j] = plus(value[i + 1][j], {1, 1}); }\n        } else if (S[i] == '>') {\n            deg[i] = deg[i + 1] + 1;\n            for (int j = 0; j < H; j++) { value[i][j] = rshift(value[i + 1][j], j); }\n        } else {\n            deg[i] = deg[i + 1] - 1;\n            for (int j = 0; j < H; j++) { value[i][j] = lshift(value[i + 1][j], j); }\n        }\n    }\n    constexpr int L = 250000;\n    std::vector<std::vector<P>> power(L + 1, std::vector<P>(H, {1, 1}));\n    std::vector<std::vector<P>> invpower(L + 1, std::vector<P>(H, {1, 1}));\n    auto invp = [&](const int i, const int j) { return i >= 0 ? invpower[i][j] : power[-i][j]; };\n    for (int i = 1; i <= L; i++) {\n        for (int j = 0; j < H; j++) { power[i][j] = rshift(power[i - 1][j], j), invpower[i][j] = lshift(power[i - 1][j], j); }\n    }\n    std::vector<P> answer(H);\n    for (int i = 0; i < H; i++) { answer[i] = value[0][i]; }\n    std::vector<std::vector<P>> hash(N + 1, std::vector<P>(H));\n    for (int i = 0; i <= N; i++) {\n        for (int j = 0; j < H; j++) { hash[i][j] = mul(value[i][j], invp(deg[i], j)); }\n    }\n    using VP = std::vector<P>;\n    std::map<VP, ll> mp;\n    ll ans = 0;\n    for (int i = 0; i <= N; i++) {\n        std::vector<P> obj(H);\n        for (int j = 0; j < H; j++) { obj[j] = plus(hash[i][j], mul(invp(deg[i], j), answer[j])); }\n        if (mp.find(obj) != mp.end()) { ans += mp[obj]; }\n        mp[hash[i]]++;\n    }\n    std::cout << ans << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * File    : F.cpp\n * Author  : Kazune Takahashi\n * Created : 2018-7-2 20:45:55\n * Powered by Visual Studio Code\n */\n\n#include <iostream>\n#include <iomanip>   // << fixed << setprecision(xxx)\n#include <algorithm> // do { } while ( next_permutation(A, A+xxx) ) ;\n#include <vector>\n#include <string> // to_string(nnn) // substr(m, n) // stoi(nnn)\n#include <complex>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <map> // if (M.find(key) != M.end()) { }\n#include <set>\n#include <random> // random_device rd; mt19937 mt(rd()); uniform_int_distribution<int> ra(0, 99); ra(mt);\n#include <chrono> // std::chrono::system_clock::time_point start_time, end_time;\n// start = std::chrono::system_clock::now();\n// double elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(end_time-start_time).count();\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\n#define DEBUG 0 // change 0 -> 1 if we need debug.\n\ntypedef long long ll;\n\n// const int dx[4] = {1, 0, -1, 0};\n// const int dy[4] = {0, 1, 0, -1};\n\n// const int C = 1e6+10;\nconst ll MOD = 1000000007;\nconst ll M = 250010;\nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<ll> ra(1, MOD - 1);\ntypedef tuple<ll, ll> D;\n\nint N;\nstring S;\nmap<ll, int> ans;\nll X;\nll X_inv;\nll C;\nll a[500100];\nD g[250010];\nmap<ll, ll> G;\n\nll power2(int i)\n{\n  if (i == 0)\n  {\n    return 1;\n  }\n  else if (i % 2 == 0)\n  {\n    ll half = power2(i / 2);\n    return (half * half) % MOD;\n  }\n  else\n  {\n    return (power2(i - 1) * X) % MOD;\n  }\n}\n\nll power(int i)\n{\n  if (i == 0)\n  {\n    return 1;\n  }\n  else if (i < 0)\n  {\n    return power2(MOD + i - 1);\n  }\n  return power2(i);\n}\n\nll calc_hash()\n{\n  fill(a, a + 500100, 0);\n  int P = M;\n  for (auto e : S)\n  {\n    if (e == '+')\n    {\n      a[P]++;\n    }\n    else if (e == '-')\n    {\n      a[P]--;\n    }\n    else if (e == '>')\n    {\n      P++;\n    }\n    else\n    {\n      P--;\n    }\n  }\n  ll res = 0;\n  for (auto i = 0; i < 500100; i++)\n  {\n    res += (((MOD + a[i]) % MOD) * power(i - M)) % MOD;\n    res %= MOD;\n  }\n  return res;\n}\n\nvoid calc_g()\n{\n  g[N] = D(1, 0);\n  for (auto i = N - 1; i >= 0; i--)\n  {\n    ll A_prime = get<0>(g[i + 1]);\n    ll B_prime = get<1>(g[i + 1]);\n    ll A, B;\n    if (S[i] == '+')\n    {\n      A = 1, B = MOD - 1;\n    }\n    else if (S[i] == '-')\n    {\n      A = 1, B = 1;\n    }\n    else if (S[i] == '>')\n    {\n      A = X_inv, B = 0;\n    }\n    else\n    {\n      A = X, B = 0;\n    }\n    g[i] = D((A_prime * A) % MOD,\n             ((A_prime * B) % MOD + B_prime) % MOD);\n  }\n}\n\nll count_ans()\n{\n  ll res = 0;\n  G.clear();\n  for (int i = N; i >= 1; i--)\n  {\n    ll J = get<1>(g[i]);\n    if (G.find(J) == G.end())\n    {\n      G[J] = 1;\n    }\n    else\n    {\n      G[J]++;\n    }\n    ll I = ((get<0>(g[i - 1]) * C) % MOD + get<1>(g[i - 1])) % MOD;\n\n    if (G.find(I) != G.end())\n    {\n      // cerr << \"i = \" << i - 1 << \", cnt of j = \" << G[I] << endl;\n      res += G[I];\n    }\n  }\n  return res;\n}\n\nvoid solve()\n{\n  X = ra(mt);\n  X_inv = power(-1);\n  C = calc_hash();\n  calc_g();\n  ll res = count_ans();\n  if (ans.find(res) == ans.end())\n  {\n    ans[res] = 1;\n  }\n  else\n  {\n    ans[res]++;\n  }\n}\n\nint main()\n{\n  cin >> N >> S;\n  for (auto i = 0; i < 4; i++)\n  {\n    solve();\n  }\n  ll res = 0;\n  int maxi = 0;\n  for (auto e : ans)\n  {\n    ll a = e.first;\n    int cnt = e.second;\n    if (cnt > maxi)\n    {\n      cnt = maxi;\n      res = a;\n    }\n  }\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define MAX 500012\n\nint n;\nchar buf[MAX];\n\n\nstring s;\n\n\n//#define MOD1 1000000007\n//#define MOD2 1000000009\n\nvalarray<long long int> MOD1;\nvalarray<long long int> MOD2;\nvector<valarray<long long int> > p2;\nvector<valarray<long long int> > vv;\nvector<int> ps;\nmap<long long int, int> mp;\nlong long int ppow(long long int i, long long int j, long long int MOD) {\n\tlong long int ret = 1;\n\twhile (j) {\n\t\tif (j & 1LL)ret *= i;\n\t\tif (ret >= MOD)ret %= MOD;\n\t\tj >>= 1LL;\n\t}\n\treturn ret;\n}\n\nvalarray<long long int> calc(int dif) {\n\tvalarray<long long int> ret;\n\tret.resize(2, 0);\n\tfor (int j = 0; j < 2; j++) {\n\t\tif (dif < 0) {\n\t\t\tret[j]=ppow(ppow(MOD1[j], abs(dif),MOD2[j]), MOD2[j] - 2,MOD2[j]);\n\t\t}\n\t\telse {\n\t\t\tret[j] = ppow(MOD1[j], abs(dif), MOD2[j]);\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main() {\n\tMOD1.resize(2);\n\tMOD2.resize(2);\n\tp2.push_back(valarray<long long int>());\n\tp2.back().resize(2);\n\tp2.back()[0] = p2.back()[1] = 1;\n\tMOD2[0] = 1000000007;\n\tMOD1[0] = 998244353;\n\tMOD1[1] = 555522277;\n\tMOD2[1] = 895612782;\n\tp2[0] %= MOD2;\n\tfor (int i = 1; i < MAX; i++) {\n\t\tp2.push_back(p2.back());\n\t\tp2[i] *= MOD1;\n\t\tp2[i] %= MOD2;\n\t}\n\tcin >> n;\n\tscanf(\"%s\", buf);\n\ts = buf;\n\tint pos = MAX/2;\n\tvalarray<long long int> hs;\n\ths.resize(2);\n\ths[0] = hs[1] = 0;\n\tvv.push_back(hs);\n\tps.push_back(pos);\n\tfor (int i = 0; i < s.size(); i++) {\n\t\tif (s[i] == '<') {\n\t\t\tpos--;\n\t\t}\n\t\tif (s[i] == '>') {\n\t\t\tpos++;\n\t\t}\n\t\tif (s[i] == '+') {\n\t\t\ths += p2[pos];\n\t\t}\n\t\tif (s[i] == '-') {\n\t\t\ths -= p2[pos];\n\t\t\ths += MOD2;\n\t\t}\n\t\ths %= MOD2;\n\t\tvv.push_back(hs);\n\t\tps.push_back(pos);\n\t}\n\tlong long int way = 0;\n\tfor (int i = vv.size() - 1; i >= 0; i--) {\n\t\tvalarray<long long int> want = vv[i] + vv.back()*calc(-MAX/2+ps[i]);\n\t\twant = want%MOD2;\n\t\tway += mp[want[0] * MOD1[0] + want[1]];\n\t\t//cerr << \"dbg \" << way << endl;\n\t\tmp[vv[i][0]*MOD1[0]+vv[i][1]]++;\n\t}\n\tprintf(\"%lld\\n\", way);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 250001;\nlong long M = 1e18 + 31,b = 1e9 + 7;\nint cs[N],p[N],n;\nmap<int,int>mp;\nvoid add(int &a,int b){\n\ta+=b;\n\tif(a >= M)a-=M;\n\tif(a < 0)a+=M;\n}\nint power(int base,int to){\n\tint ret = 1;\n\twhile(to){\n\t\tif(to&1)ret = (__int128)ret*base%M;\n\t\tto>>=1;\n\t\tbase = (__int128)base*base%M;\n\t}\n\treturn ret;\n}\nint main(){\n//\tfreopen(\"readin.txt\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tp[0] = 1;\n\tchar c;\n\tint inv = power(b,M - 2);\n\tfor(int i = 1;i <= n;i++){\n\t\tscanf(\" %c\",&c);\n\t\tcs[i] = cs[i - 1];\n\t\tp[i] = p[i - 1];\n\t\tif(c == '+')add(cs[i],p[i]);\n\t\telse if(c == '-')add(cs[i],-p[i]);\n\t\telse if(c == '>')p[i] = (__int128)p[i]*b%M;\n\t\telse if(c == '<')p[i] = (__int128)p[i]*inv%M;\n\t}\n\tlong long ans = 0;\n\tfor(int i = 0;i <= n;i++){\n\t\tans+=mp[cs[i]];\n\t\tmp[((__int128)cs[n]*p[i]%M + cs[i] + M)%M]++;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <vector>\n\nconst int DEBUG = 0;\n\n#define MOCK 1\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define DEBUGP(val) cerr << #val << \"=\" << val << \"\\n\"\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\ntypedef pair<ll, ll> PL;\n\n\nll powmod(ll a, ll e, ll mod) {\n  ll sum = 1;\n  ll cur = a;\n  while (e > 0) {\n    if (e % 2) {\n      sum = sum * cur % mod;\n    }\n    cur = cur * cur % mod;\n    e /= 2;\n  }\n  return sum;\n}\n\nconst int A = 20;\n\nint main(void) {\n  const ll mod = 1e9 + 7;\n  const ll mod2 = 1e9 + 9;\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  string s;\n  cin >> n >> s;\n  int p = 0;\n  VI pos(n + 1);\n  mt19937 mt;\n  VL b(A);\n  ll mods[A] = {};\n  REP(i, 0, A) mods[i] = 1e9 + 7;\n  \n  REP(c, 0, A) {\n    do {\n      b[c] = mt() % mods[c];\n    } while (b[c] == 0);\n  }\n  vector<VL> hsh(A, VL(n + 1));\n  ll inv[A] = { 0 };\n  REP(c, 0, A) inv[c] = powmod(b[c], mods[c] - 2, mods[c]);\n  REP(c, 0, A) {\n    p = 0;\n    ll cur = 1;\n    REP(i, 0, n) {\n      ll tmp = hsh[c][i];\n      if (s[i] == '>') {\n        p++;\n        cur = cur * b[c] % mods[c];\n      }\n      if (s[i] == '<') {\n        p--;\n        cur = cur * inv[c] % mods[c];\n      }\n      if (s[i] == '+') {\n        tmp = (tmp + cur) % mods[c];\n      }\n      if (s[i] == '-') {\n        tmp = (tmp + mods[c] - cur) % mods[c];\n      }\n      hsh[c][i + 1] = tmp;\n      pos[i + 1] = p;\n    }\n  }\n  if (DEBUG) {\n    REP(i, 0, n + 1) {\n      cerr << i << \" \" << hsh[0][i] << endl;\n    }\n  }\n  VL meguru(A);\n  REP(c, 0, A) meguru[c] = hsh[c][n];\n  map<VL, int> kirika;\n  kirika[meguru] = 1;\n  ll tot = 0;\n  VL cur(A);\n  REP(c, 0, A) cur[c] = powmod(b[c], pos[n], mods[c]);\n  for (int i = n - 1; i >= 0; --i) {\n    if (DEBUG) {\n      DEBUGP(i);\n      DEBUGP(pos[i]);\n    }\n    if (pos[i + 1] - pos[i] == 1) {\n      REP(c, 0, A) cur[c] = cur[c] * inv[c] % mods[c];\n    }\n    else if (pos[i + 1] - pos[i] == -1) {\n      REP(c, 0, A) cur[c] = cur[c] * b[c] % mods[c];\n    }\n    VL ken(A);\n    REP(c, 0, A) ken[c] = (cur[c] * meguru[c] + hsh[c][i]) % mods[c];\n    tot += kirika[ken];\n    VL tt(A);\n    REP(c, 0, A) tt[c] = hsh[c][i];\n    kirika[tt] += 1;\n  }\n  cout << tot << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ri register int\ntypedef long long ll;\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char y) {\n\t\t*oS ++ = y;\n\t\tif (oS == oT) flush ();\n\t}\n\t// input a signed integer\n\ttemplate <class I>\n\tinline void gi (I &y) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (y = 0; c <= '9' && c >= '0'; c = gc()) y = (y << 1) + (y << 3) + (c & 15); y *= f;\n\t}\n\t// print a signed integer\n\ttemplate <class I>\n\tinline void print (I y) {\n\t\tif (!y) putc ('0'); if (y < 0) putc ('-'), y = -y;\n\t\twhile (y) qu[++ qr] = y % 10 + '0',  y /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t}\n\t// no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n} \nusing io :: gi;\nusing io :: putc;\nusing io :: print;\nconst int N=25e4+5,mod=1e9+7;\nchar s[N];\nint x[6],power[6][N],xinv[6],powerinv[6][N];\ninline void add(int &x,ri y){\n\tx=(x+=y)>=mod?x-mod:x;\n}\ninline void del(int &x,ri y){\n\tx=(x-=y)<0?x+mod:x;\n}\nstruct node{\n\tint y[6];\n\tinline bool operator <(const node &rhs)const{\n\t\tfor(ri i=0;i^6;++i)\n\t\t\tif(y[i]!=rhs.y[i])\n\t\t\t\treturn y[i]<rhs.y[i];\n\t\treturn 0;\n\t}\n\tinline bool operator ==(const node &rhs)const{\n\t\tfor(ri i=0;i^6;++i)\n\t\t\tif(y[i]!=rhs.y[i])\n\t\t\t\treturn false;\n\t\treturn true; \n\t}\n\tinline void upd(ri p,ri k){\n\t\tri i;\n\t\tif(p>=0){\n\t\t\tif(k==1){\n\t\t\t\tfor(i=0;i^6;++i)\n\t\t\t\t\tadd(y[i],power[i][p]);\n\t\t\t} \n\t\t\telse{\n\t\t\t\tfor(i=0;i^6;++i)\n\t\t\t\t\tdel(y[i],power[i][p]);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(k==1){\n\t\t\t\tfor(i=0;i^6;++i)\n\t\t\t\t\tadd(y[i],powerinv[i][-p]);\n\t\t\t} \n\t\t\telse{\n\t\t\t\tfor(i=0;i^6;++i)\n\t\t\t\t\tdel(y[i],powerinv[i][-p]);\n\t\t\t}\n\t\t}\n\t}\n}res,res0,now;\nstruct orz{\n\tint k,b;\n\tinline void operator +=(const int &rhs){\n\t\tadd(b,1);\n\t}\n\tinline void operator -=(const int &rhs){\n\t\tdel(b,1);\n\t}\n\tinline void operator *=(const int &rhs){\n\t\tk=(ll)k*rhs%mod;\n\t\tb=(ll)b*rhs%mod;\n\t}\n};\nstruct poly{\n\torz f[6];\n\tinline void upd1(){\n\t\tfor(ri i=0;i^6;++i)\n\t\t\tf[i]-=1;\n\t}\n\tinline void upd2(){\n\t\tfor(ri i=0;i^6;++i)\n\t\t\tf[i]+=1;\n\t}\n\tinline void upd3(){\n\t\tfor(ri i=0;i^6;++i)\n\t\t\tf[i]*=xinv[i];\n\t}\n\tinline void upd4(){\n\t\tfor(ri i=0;i^6;++i)\n\t\t\tf[i]*=x[i];\n\t}\n}resinv;\nmap<node,int> G;\ninline int fpow(ri a,ri b){\n\tri ans=1;\n\tfor(;b;b>>=1,a=(ll)a*a%mod)\n\t\tif(b&1) ans=(ll)ans*a%mod;\n\treturn ans;\n}\nint main(){\n\tsrand(size_t(new char));\n\tri n,i,j,nowp,ans;\n\tscanf(\"%d%s\",&n,s+1);\n\tfor(i=0;i^6;++i){\n\t\tx[i]=rand()*rand()%(mod-1)+1;\n\t\tpower[i][0]=1;\n\t\tfor(j=1;j<=n;++j)\n\t\t\tpower[i][j]=(ll)power[i][j-1]*x[i]%mod;\n\t\txinv[i]=fpow(x[i],mod-2);\n\t\tpowerinv[i][0]=1;\n\t\tfor(j=1;j<=n;++j)\n\t\t\tpowerinv[i][j]=(ll)powerinv[i][j-1]*xinv[i]%mod;\n\t}\n\tnowp=0;\n\tfor(i=1;i<=n;++i)\n\t\tif(s[i]=='+')\n\t\t\tres0.upd(nowp,1);\n\t\telse if(s[i]=='-')\n\t\t\tres0.upd(nowp,-1);\n\t\telse if(s[i]=='>')\n\t\t\t++nowp;\n\t\telse\n\t\t\t--nowp;\n\tnowp=0;\n\tans=0;\n\tfor(i=0;i^6;++i) resinv.f[i].k=1;\n\t++G[res0];\n\tfor(i=1;i<=n;++i){\n\t\tif(s[i]=='+')\n\t\t\tres.upd(nowp,1),\n\t\t\tresinv.upd1();\n\t\telse if(s[i]=='-')\n\t\t\tres.upd(nowp,-1),\n\t\t\tresinv.upd2();\n\t\telse if(s[i]=='>')\n\t\t\t++nowp,\n\t\t\tresinv.upd3();\n\t\telse\n\t\t\t--nowp,\n\t\t\tresinv.upd4();\n\t\tans+=G[res];\n\t\tfor(j=0;j^6;++j)\n\t\t\tnow.y[j]=(ll)(res0.y[j]-resinv.f[j].b+mod)*fpow(resinv.f[j].k,mod-2)%mod;\n\t\t++G[now];\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n\nint n;\nstring s;\nll pw[2][500005],rev[2][500005];\nll c[2] = {37,41}, mod[2] = {1000000007,1000000009};\nll modpow(ll x,ll n,ll modd){\n\tll res=1;\n\twhile(n>0){\n\t\tif(n&1) res=res*x%modd;\n\t\tx=x*x%modd;\n\t\tn>>=1;\n\t}\n\treturn res;\n}\nint pt[250005];\nll cur_hash[2][250005];\n\nint main(){\n\tcin >> n >> s;\n\trep(i,2){\n\t\tpw[i][0] = rev[i][0] = 1;\n\t\tll d = modpow(c[i],mod[i]-2,mod[i]);\n\t\t\n\t\trep(j,500000){\n\t\t\tpw[i][j+1] = pw[i][j] * c[i] % mod[i];\n\t\t\trev[i][j+1] = rev[i][j] * d % mod[i];\n\t\t}\n\t}\n\trep(i,n){\n\t\tpt[i+1] = pt[i];\n\t\trep(ii,2) cur_hash[ii][i+1] = cur_hash[ii][i];\n\t\tif(s[i] == '+'){\n\t\t\tif(pt[i+1] >= 0){\n\t\t\t\trep(ii,2) cur_hash[ii][i+1] += pw[ii][pt[i+1]];\n\t\t\t}\n\t\t\telse{\n\t\t\t\trep(ii,2) cur_hash[ii][i+1] += rev[ii][-pt[i+1]];\n\t\t\t}\n\t\t}\n\t\telse if(s[i] == '-'){\n\t\t\tif(pt[i+1] >= 0){\n\t\t\t\trep(ii,2) cur_hash[ii][i+1] -= pw[ii][pt[i+1]];\n\t\t\t}\n\t\t\telse{\n\t\t\t\trep(ii,2) cur_hash[ii][i+1] -= rev[ii][-pt[i+1]];\n\t\t\t}\n\t\t}\n\t\telse if(s[i] == '>') pt[i+1]++; else pt[i+1]--;\n\t}\n\t\n\trep(i,2) rep(j,250005){\n\t\tcur_hash[i][j] = (cur_hash[i][j]%mod[i]+mod[i])%mod[i];\n\t\t\n\t\t//if(j <= n) cout << cur_hash[0][j] << \" \" << pt[j] << endl;\n\t}\n\tmap<pair<ll,ll>,int>cnt;\n\tll ans = 0;\n\tfor(int i=n;i>=1;i--){\n\t\tcnt[mp(cur_hash[0][i],cur_hash[1][i])]++;\n\t\t\n\t\tll check[2];\n\t\trep(j,2) check[j] = cur_hash[j][i-1];\n\t\t\n\t\tif(pt[i-1] >= 0){\n\t\t\trep(j,2) check[j] += cur_hash[j][n] * pw[j][pt[i-1]];\n\t\t}\n\t\telse{\n\t\t\trep(j,2) check[j] += cur_hash[j][n] * rev[j][-pt[i-1]];\n\t\t}\n\t\t\n\t\trep(j,2) check[j] = (check[j]%mod[j]+mod[j])%mod[j];\n\t\t\n\t\tif(cnt.find(mp(check[0],check[1])) != cnt.end())\n\t\t\tans += cnt[mp(check[0],check[1])];\n\t\t\n\t}\n\t\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#include<cmath>\n#define MN 250005\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long ll;\nconst ull M1=233;\nconst ull mod=4179340454199820289ll;\nvoid add(ull &x,ull y){(x+=y);/*>=mod?x-=mod:0;*/}\nvoid dec(ull &x,ull y){(x-=y);/*<0?x+=mod:0;*/}/*\null mul(ull x, ull y)\n{\n\tx = (x % mod + mod) % mod;\n\ty = (y % mod + mod) % mod;\n\treturn (x * y - (ll)((long double)x / mod * y) * mod + mod) % mod;\n}\nll mul(ll x,ll y){\n\tll tmp=0;\n\twhile(y){\n\t\tif(y&1)add(tmp,x);\n\t\tadd(x,x);y>>=1;\n\t}return tmp;\n}\nll qpow(ll x,ll y){\n\tll tmp=1;\n\twhile(y){\n\t\tif(y&1)tmp=mul(tmp,x);\n\t\tx=mul(x,x);y>>=1;\n\t}return tmp;\n}*/\nint n,pos[MN];char s[MN];\nmap<int,int> mp;\null lh[MN],rh[MN],fac[MN<<1],ans;\nint main(){\n\tscanf(\"%d%s\",&n,s+1);ull X=1,Y=0,x=233,y=7204522363551799129;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tlh[i]=lh[i-1];\n\t\tif(s[i]=='+')add(lh[i],X);\n\t\tif(s[i]=='-')dec(lh[i],X);\n\t\tif(s[i]=='<')X*=x;\n\t\tif(s[i]=='>')X*=y;\n\t\t++mp[lh[i]];\n\t}X=1;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tans+=mp[lh[n]*X+Y];\n\t\tif(s[i]=='+')Y+=X;\n\t\tif(s[i]=='-')Y-=X;\n\t\tif(s[i]=='<')X*=x;\n\t\tif(s[i]=='>')X*=y;\n\t\t--mp[lh[i]];\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef unsigned long long ull;\nconst ull M=998244353;\nconst ull N=1000000007; \nconst ull X=99431;\nconst ull Y=99487;\null R;\null L;\nconst int W=1200;\n \n \null ModPow(ull x, ull n, ull mod) {\n        ull ret = 1;\n        for (; n > 0; n /= 2, x = (x * x) % mod)\n            if ((n & 1) == 1) ret = (ret * x) % mod;\n        return ret;\n    }\n \null has=0,vec=1;\null has2=0,vec2=1;\n \nint n;\nstring s;\nunordered_map<ull,int> B[550];\nlong long ans;\ninline void calc(char c, ull &u,ull &p,ull &v,ull &q){\n\tif(c=='+'){u+=p;v+=q;}\n\telse if(c=='-'){u+=M-p;v+=N-q;}\n\telse if(c=='>'){p=(p*X)%M;q=(q*Y)%N;}\n\telse {p=(p*R)%M;q=(q*L)%N;}\n\tif(u>=M)u-=M;\n\tif(v>=N)v-=N;\n}\nint main(){\n\tR=ModPow(X,M-2,M);\n\tL=ModPow(Y,N-2,N);\n\tcin>>n>>s;\n    //n=250000;\n    //s=string(n,'+');\n\tfor(int i=0;i<n;i++)calc(s[i],has,vec,has2,vec2);\n\tfor(int i=0;i<n;i++){\n\t\tif(i%W==0)continue;\n\t\tull h=0,x=1,hh=0,y=1;\n\t\tfor(int j=i;j<n;j++){\n\t\t\tif(j%W==0)break;\n\t\t\tcalc(s[j],h,x,hh,y);\n\t\t\tif(h==has&&hh==has2)ans++;\n\t\t}\n\t\tull nh = (has+M-h)%M;\n\t\tnh = nh * ModPow(x,M-2,M)%M;\n\t\tull nh2 = (has2+N-hh)%N;\n\t\tnh2 = nh2 * ModPow(y,N-2,N)%N;\n\t\tB[i/W+1][nh*N+nh2]++;\n\t}\n\tfor(int i=0;i<n;i+=W){\n\t\tull h=0,x=1,hh=0,y=1;\n\t\tfor(int j=i;j<n;j++){\n\t\t\tcalc(s[j],h,x,hh,y);\n\t\t\tif(h==has&&hh==has2)ans++;\n\t\t\tauto it = B[i/W].find(h*N+hh);\n\t\t\tif(it!=B[i/W].end())ans+=it->second;\n\t\t}\n\t}\n\t\n\tcout<<ans;\n \n \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<climits>\n#include<bitset>\n#include<map>\n#define pii pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define int long long\n#define mod1 998244353\n#define mod2 1000000007\nusing namespace std;\ninline int read(){\n    int f=1,ans=0;char c=getchar();\n    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}\n    while(c>='0'&&c<='9'){ans=ans*10+c-'0';c=getchar();}\n    return f*ans;\n}\nconst int MAXN=5e5+11;\nint N;char str[MAXN];\nint h1[MAXN],s1[MAXN],xx=997,res,h2[MAXN],s2[MAXN];\nint ksm1(int a,int b){\n    int ans=1;\n    while(b){if(b&1) ans*=a,ans%=mod1;a*=a,a%=mod1;b>>=1;}return ans;\n}\nint pw1(int a,int b){\n    if(b>=0) return ksm1(a,b);\n    int res=ksm1(a,-b);return ksm1(res,mod1-2);\n}\nint ksm2(int a,int b){\n    int ans=1;\n    while(b){if(b&1) ans*=a,ans%=mod2;a*=a,a%=mod2;b>>=1;}return ans;\n}\nint pw2(int a,int b){\n    if(b>=0) return ksm2(a,b);\n    int res=ksm2(a,-b);return ksm2(res,mod1-2);\n}\nmap<pii,int> M;\nvoid ins(int ps){M[mp( (h1[ps]+pw1(xx,s1[ps])*h1[N])%mod1 , (h2[ps]+pw2(xx,s2[ps])*h2[N])%mod2 )]++;return;}\nsigned main(){\n    //freopen(\"1.in\",\"r\",stdin);\n    N=read();scanf(\"%s\",str+1);\n    for(int i=1;i<=N;i++){\n        if(str[i]=='+') h1[i]=h1[i-1]+pw1(xx,s1[i-1]),s1[i]=s1[i-1],h1[i]%=mod1;\n        if(str[i]=='-') h1[i]=h1[i-1]-pw1(xx,s1[i-1])+mod1,s1[i]=s1[i-1],h1[i]%=mod1;\n        if(str[i]=='>') h1[i]=h1[i-1],s1[i]=s1[i-1]+1;\n        if(str[i]=='<') h1[i]=h1[i-1],s1[i]=s1[i-1]-1;\n        if(str[i]=='+') h2[i]=h2[i-1]+pw2(xx,s2[i-1]),s2[i]=s2[i-1],h2[i]%=mod2;\n        if(str[i]=='-') h2[i]=h2[i-1]-pw2(xx,s2[i-1])+mod2,s2[i]=s2[i-1],h2[i]%=mod2;\n        if(str[i]=='>') h2[i]=h2[i-1],s2[i]=s2[i-1]+1;\n        if(str[i]=='<') h2[i]=h2[i-1],s2[i]=s2[i-1]-1;\n    }\n    //for(int i=1;i<=N;i++) printf(\"h:%lld s:%lld\\n\",h[i],s[i]);\n    /*for(int i=1;i<=N;i++)\n        for(int j=i;j<=N;j++){\n            if(((h1[i-1]+pw1(xx,s1[i-1])*h1[N])%mod1)==h1[j]&&((h2[i-1]+pw2(xx,s2[i-1])*h2[N])%mod2)==h2[j]){\n                res++;\n                //cerr<<i<<\" \"<<j<<endl;\n            }\n            //res+=(((h[i-1]+ksm(xx,s[i-1])*h[N])%mod)==h[j]);\n        }*/\n    ins(0);\n    for(int i=1;i<=N;i++){\n        res+=M[mp(h1[i],h2[i])];\n        ins(i);\n    }printf(\"%lld\\n\",res);return 0;\n}/*\n  5\n  +>+<-\n  */\n\n"
  },
  {
    "language": "C++",
    "code": "    #include \"bits/stdc++.h\"\n            using namespace std;\n             \n            #define MAX 600012\n             \n            int n;\n            char buf[MAX];\n            string s;\n            valarray<long long int> MOD1;\n            valarray<long long int> MOD2;\n            vector<valarray<long long int> > p2;\n            vector<valarray<long long int> > vv;\n            vector<int> ps;\n            map<pair<long long int,long long int>, long long int> mp;\n            long long int ppow(long long int i, long long int j, long long int MOD) {\n            \tlong long int ret = 1;\n            \twhile (j) {\n            \t\tif (j & 1LL)ret *= i;\n            \t\tif (ret >= MOD)ret %= MOD;\n            \t\tj >>= 1LL;\n            \t}\n            \treturn ret;\n            }\n             \n            valarray<long long int> calc(int dif) {\n            \tvalarray<long long int> ret;\n            \tret.resize(2, 0);\n            \tfor (int j = 0; j < 2; j++) {\n            \t\tif (dif < 0) {\n            \t\t\tret[j]=ppow(ppow(MOD1[j],MOD2[j]-2,MOD2[j]),-dif,MOD2[j]);\n            \t\t}\n            \t\telse {\n            \t\t\tret[j] = ppow(MOD1[j],dif, MOD2[j]);\n            \t\t}\n            \t}\n            \treturn ret;\n            }\n             \n            int main() {\n\t\t\t\tcin >> n;\n            \tscanf(\"%s\", buf);\n            \ts = buf;\n            \tMOD1.resize(2);\n            \tMOD2.resize(2);\n            \tp2.push_back(valarray<long long int>());\n            \tp2.back().resize(2);\n            \tp2.back()[0] = p2.back()[1] = 1;\n            \tMOD2[1] = 1000000007;\n            \tMOD1[0] = 555522277;\n            \tMOD1[1] = 895612783;\n            \tMOD2[0] = 998244353;\n            \tp2[0] %= MOD2;\n            \tfor (int i = 1; i < MAX; i++) p2.push_back((p2.back()*MOD1)%MOD2);\n            \tint pos = MAX/2;\n            \tvalarray<long long int> hs;\n            \ths.resize(2,0);\n            \tvv.push_back(hs);\n            \tps.push_back(pos);\n            \tfor (int i = 0; i < s.size(); i++) {\n            \t\tif (s[i] == '<') pos--;\n            \t\telse if (s[i] == '>') pos++;\n            \t\telse if (s[i] == '+') hs += p2[pos];\n            \t\telse if (s[i] == '-') hs += MOD2-p2[pos];\n            \t\ths %= MOD2;\n            \t\tif(hs[0]<0LL||hs[1]<0LL||p2[pos][0]<0LL||p2[pos][1]<0LL)return 1;\n            \t\tvv.push_back(hs);\n            \t\tps.push_back(pos);\n            \t}\n            \tlong long int way = 0;\n            \tfor (int i = vv.size() - 1; i >= 0; i--) {\n            \t\tvalarray<long long int> want = (vv[i] + ((vv.back()*calc(-MAX/2+ps[i]))%MOD2)%MOD2)%MOD2;\n            \t\tway += mp[make_pair(want[0], want[1])];\n            \t\tif(want[0]<0LL||want[1]<0LL)return 1;\n            \t\tmp[make_pair(vv[i][0],vv[i][1])]++;\n            \t}\n            \tprintf(\"%lld\\n\", way);\n            \treturn 0;\n            }"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n// need\n#include <iostream>\n#include <algorithm>\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <unordered_map>\n#include <unordered_set>\n#include <array>\n// stream\n//#include <istream>\n#include <sstream>\n//#include <ostream>\n#include <fstream>\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest& ...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int w_=0; w_<n; ++w_){MACRO_VEC_ROW_Scan(w_, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest& ...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest& ...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& R:c)for(auto& w:R)std::cin>>w;\n// output\n#define OUT(dist) std::cout<<(dist);\n#define FOUT(n, dist) std::cout<<std::fixed<<std::setprecision(n)<<(dist);\n#define SOUT(n, c, dist) std::cout<<std::setw(n)<<std::setfill(c)<<(dist);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(w, n) std::cout<<(w + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(dist) {std::cerr << #dist << \"\\t:\" << (dist) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(w, a, n) for(int w=(a);w<(n);++w)\n#define RFOR(w, a, n) for(int w=(n)-1;w>=(a);--w)\n#define REP(w, n) for(int w=0;w<int(n);++w)\n#define RREP(w, n) for(int w=int(n)-1;w>=0;--w)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<class T> inline T CHMAX(T & a, const T b) { return a = (a < b) ? b : a; }\ntemplate<class T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\n//void CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n// test\ntemplate<class T> using V = std::vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n#define random_shuffle \"USE std::shuffle!\";\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = (1 << 30) - 1;                    // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-10;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T & val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T & val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T> & a, const T & val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>> & a, const T & val) { for (auto& b : a) FILL(b, val); }\n// ------------>8------------------------------------->8------------\n\nnamespace Test {\n\tsigned main() {\n\t\t//VAR(int, n);\n//VAR(std::string, s);\n\t\tstd::string S = \"+-<>\";\n\t\tconst int n = 50;\n\t\tauto system_now = std::chrono::system_clock::now();\n\t\tstd::mt19937 mt(std::chrono::duration_cast<std::chrono::microseconds>(system_now.time_since_epoch()).count());\n\t\tstd::uniform_int_distribution<> rand(/* min */0, /* max */3);\n\t\tstd::string s;\n\t\tREP(_, n) s += S[rand(mt)];\n\n\t\tauto get = [&](int l, int r) {\n\t\t\tstd::map<int, int> map;\n\t\t\tint p = 0;\n\t\t\tFOR(i, l, r) {\n\t\t\t\t/* */if (s[i] == '+') { if (++map[p] == 0) map.erase(p); }\n\t\t\t\telse if (s[i] == '-') { if (--map[p] == 0) map.erase(p); }\n\t\t\t\telse if (s[i] == '>') ++p;\n\t\t\t\telse if (s[i] == '<') --p;\n\t\t\t}\n\n\t\t\treturn map;\n\t\t};\n\n\t\tauto sub = [&](std::map<int, int> a, const std::map<int, int> b) {\n\t\t\tfor (auto& p : b) {\n\t\t\t\tif ((a[p.first] -= p.second) == 0) a.erase(p.first);\n\t\t\t}\n\t\t\treturn a;\n\t\t};\n\n\t\tauto print = [&](std::map<int, int> map) {\n\t\t\tFOR(i, -10, 20) {\n\t\t\t\tOUT(map[i])SPBR(i, 20);\n\t\t\t}\n\t\t};\n\n\t\tVAR(int, l, r);\n\n\t\tOUT(s)BR;\n\t\tREP(i, n) {\n\t\t\tchar c = ' ';\n\t\t\tif (IN(l, i, r)) c = '*';\n\t\t\tOUT(c);\n\t\t}BR;\n\t\tprint(get(l, r));\n\t\tprint(sub(get(0, r), get(0, l)));\n\t\treturn 0;\n\t}\n}\n\nll powMod(ll n, ll p, ll mod) {\n\tif (p < 0) p += mod - 1;\n\tn %= mod;\n\tll res = 1;\n\twhile (p) {\n\t\tif (p & 1) (res *= n) %= mod;\n\t\t(n *= n) %= mod;\n\t\tp >>= 1;\n\t}\n\treturn res;\n}\n\nconstexpr int N = 2;\nconstexpr int M[N] = { 1000000009, 1000000021 };\nconstexpr int B = 123457;\n\nstruct Hash {\n\tint val[N];\n\tHash& norm() {\n\t\tREP(i, N) if ((val[i] %= M[i]) < 0) val[i] += M[i];\n\t\treturn *this;\n\t}\n\n\tHash(int x) { REP(i, N) val[i] = x; norm(); }\n\tHash() : Hash(0) {}\n\n\tstatic Hash makePow(int n, int p) {\n\t\tHash res;\n\t\tREP(i, N) res.val[i] = powMod(n, p, M[i]);\n\t\treturn res;\n\t}\n\tstatic Hash makeInv(int x) {\n\t\tHash res;\n\t\tREP(i, N) res.val[i] = powMod(x, M[i] - 2, M[i]);\n\t\treturn res;\n\t}\n\n\tbool operator==(const Hash & r) const { return *this == r; }\n\tbool operator<(const Hash & r) const { \n\t\tREP(i, N) if(this->val[i] != r.val[i]) return this->val[i] < r.val[i];\n\t\treturn false;\n\t}\n\tHash& operator+=(const Hash & r) { REP(i, N) val[i] += r.val[i]; norm(); return *this; }\n\tHash& operator-=(const Hash & r) { REP(i, N) val[i] -= r.val[i]; norm(); return *this; }\n\tHash& operator*=(const Hash & r) { REP(i, N) val[i] *= r.val[i]; norm(); return *this; }\n\tHash& operator/=(const Hash & r) { \n\t\tREP(i, N) val[i] *= powMod(r.val[i], M[i] - 2, M[i]); \n\t\tnorm(); \n\t\treturn *this; \n\t}\n};\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n);\n\tVAR(std::string, s);\n\n\tHash X;\n\t{\n\t\tint p = 0;\n\t\tREP(i, n) {\n\t\t\t/* */if (s[i] == '+') X += Hash::makePow(B, p);\n\t\t\telse if (s[i] == '-') X -= Hash::makePow(B, p);\n\t\t\telse if (s[i] == '>') ++p;\n\t\t\telse if (s[i] == '<') --p;\n\t\t}\n\t}\n\n\tstd::map<Hash, int> map;\n\t++map[X];\n\tint ans = 0;\n\tHash A;\n\t{\n\t\tint p = 0;\n\t\tREP(i, n) {\n\t\t\t/* */if (s[i] == '+') A += Hash::makePow(B, p);\n\t\t\telse if (s[i] == '-') A -= Hash::makePow(B, p);\n\t\t\telse if (s[i] == '>') ++p;\n\t\t\telse if (s[i] == '<') --p;\n\t\t\tans += map[A];\n\t\t\t{\n\t\t\t\tauto tX(X);\n\t\t\t\ttX /= Hash::makePow(B, -p);\n\t\t\t\ttX += A;\n\t\t\t\t++map[tX];\n\t\t\t}\n\t\t}\n\t}\n\tOUT(ans)BR;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <unordered_map>\n\ntypedef long long LL;\nconst int Mod = 999988679, B = 370728, iB = 396903752;\nconst int MN = 250005;\n\ninline void Add(int &x, int y) { x -= (x += y) >= Mod ? Mod : 0; }\n\nint N;\nchar S[MN];\nint A[MN], D[MN];\nstd::unordered_map<int, int> Buk;\nLL Ans;\n\nint main() {\n\tscanf(\"%d%s\", &N, S + 1);\n\tA[0] = 0, D[0] = 1;\n\tfor (int i = 1, V = 1; i <= N; ++i) {\n\t\tA[i] = A[i - 1];\n\t\tif (S[i] == '+') Add(A[i], V);\n\t\tif (S[i] == '-') Add(A[i], Mod - V);\n\t\tif (S[i] == '>') V = (LL)V * B % Mod;\n\t\tif (S[i] == '<') V = (LL)V * iB % Mod;\n\t\tD[i] = V;\n\t}\n\tfor (int i = N; i >= 0; --i) {\n\t\tAns += Buk[(A[i] + (LL)A[N] * D[i]) % Mod];\n\t\t++Buk[A[i]];\n\t}\n\tprintf(\"%lld\\n\", Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 250001,M = 1e9 + 9,M1 = 1e9 + 7,b = 103,b1 = 11;\nint cs[N],cs1[N],p[N],p1[N],n;\nmap<pair<int,int>,int>mp;\nvoid add(int &a,int b){\n\ta+=b;\n\tif(a >= M)a-=M;\n\tif(a < 0)a+=M;\n}\nvoid add1(int &a,int b){\n\ta+=b;\n\tif(a >= M)a-=M1;\n\tif(a < 0)a+=M1;\n}\nint power(int base,int to){\n\tint ret = 1;\n\twhile(to){\n\t\tif(to&1)ret = ret*1LL*base%M;\n\t\tto>>=1;\n\t\tbase = base*1LL*base%M;\n\t}\n\treturn ret;\n}\nint power1(int base,int to){\n\tint ret = 1;\n\twhile(to){\n\t\tif(to&1)ret = ret*1LL*base%M1;\n\t\tto>>=1;\n\t\tbase = base*1LL*base%M1;\n\t}\n\treturn ret;\n}\nint main(){\n\t//freopen(\"readin.txt\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tp[0] = p1[0] = 1;\n\tchar c;\n\tint inv = power(b,M - 2),inv1 = power1(b1,M1 - 2);\n\tfor(int i = 1;i <= n;i++){\n\t\tscanf(\" %c\",&c);\n\t\tcs[i] = cs[i - 1];\n\t\tp[i] = p[i - 1];\n\t\tcs1[i] = cs1[i - 1];\n\t\tp1[i] = p1[i - 1];\n\t\tif(c == '+')add(cs[i],p[i]),add1(cs1[i],p1[i]);\n\t\telse if(c == '-')add(cs[i],-p[i]),add1(cs1[i],-p1[i]);\n\t\telse if(c == '>')p[i] = p[i]*1LL*b%M,p1[i] = p1[i]*1LL*b1%M1;\n\t\telse if(c == '<')p[i] = p[i]*1LL*inv%M,p1[i] = p1[i]*1LL*inv1%M1;\n\t}\n\tlong long ans = 0;\n\tfor(int i = 0;i <= n;i++){\n\t\tans+=mp[{cs[i],cs1[i]}];\n\t\tmp[{(cs[n]*1LL*p[i]%M + cs[i] + M)%M,(cs1[n]*1LL*p1[i]%M1 + cs1[i] + M1)%M1}]++;\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\n\n//短い版\n\n#include <algorithm>\n#include <array>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        int ceil_pow2(int n) {\n            int x = 0;\n            while ((1U << x) < (unsigned int)(n)) x++;\n            return x;\n        }\n        \n        int bsf(unsigned int n) {\n#ifdef _MSC_VER\n            unsigned long index;\n            _BitScanForward(&index, n);\n            return index;\n#else\n            return __builtin_ctz(n);\n#endif\n        }\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n\n\n#include <utility>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        constexpr long long safe_mod(long long x, long long m) {\n            x %= m;\n            if (x < 0) x += m;\n            return x;\n        }\n        \n        struct barrett {\n            unsigned int _m;\n            unsigned long long im;\n            \n            barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}\n            \n            unsigned int umod() const { return _m; }\n            \n            unsigned int mul(unsigned int a, unsigned int b) const {\n                \n                unsigned long long z = a;\n                z *= b;\n#ifdef _MSC_VER\n                unsigned long long x;\n                _umul128(z, im, &x);\n#else\n                unsigned long long x =\n                (unsigned long long)(((unsigned __int128)(z)*im) >> 64);\n#endif\n                unsigned int v = (unsigned int)(z - x * _m);\n                if (_m <= v) v += _m;\n                return v;\n            }\n        };\n        \n        constexpr long long pow_mod_constexpr(long long x, long long n, int m) {\n            if (m == 1) return 0;\n            unsigned int _m = (unsigned int)(m);\n            unsigned long long r = 1;\n            unsigned long long y = safe_mod(x, m);\n            while (n) {\n                if (n & 1) r = (r * y) % _m;\n                y = (y * y) % _m;\n                n >>= 1;\n            }\n            return r;\n        }\n        \n        constexpr bool is_prime_constexpr(int n) {\n            if (n <= 1) return false;\n            if (n == 2 || n == 7 || n == 61) return true;\n            if (n % 2 == 0) return false;\n            long long d = n - 1;\n            while (d % 2 == 0) d /= 2;\n            for (long long a : {2, 7, 61}) {\n                long long t = d;\n                long long y = pow_mod_constexpr(a, t, n);\n                while (t != n - 1 && y != 1 && y != n - 1) {\n                    y = y * y % n;\n                    t <<= 1;\n                }\n                if (y != n - 1 && t % 2 == 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        template <int n> constexpr bool is_prime = is_prime_constexpr(n);\n        \n        constexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {\n            a = safe_mod(a, b);\n            if (a == 0) return {b, 0};\n            \n            long long s = b, t = a;\n            long long m0 = 0, m1 = 1;\n            \n            while (t) {\n                long long u = s / t;\n                s -= t * u;\n                m0 -= m1 * u;  // |m1 * u| <= |m1| * s <= b\n                \n                \n                auto tmp = s;\n                s = t;\n                t = tmp;\n                tmp = m0;\n                m0 = m1;\n                m1 = tmp;\n            }\n            if (m0 < 0) m0 += b / s;\n            return {s, m0};\n        }\n        \n        constexpr int primitive_root_constexpr(int m) {\n            if (m == 2) return 1;\n            if (m == 167772161) return 3;\n            if (m == 469762049) return 3;\n            if (m == 754974721) return 11;\n            if (m == 998244353) return 3;\n            int divs[20] = {};\n            divs[0] = 2;\n            int cnt = 1;\n            int x = (m - 1) / 2;\n            while (x % 2 == 0) x /= 2;\n            for (int i = 3; (long long)(i)*i <= x; i += 2) {\n                if (x % i == 0) {\n                    divs[cnt++] = i;\n                    while (x % i == 0) {\n                        x /= i;\n                    }\n                }\n            }\n            if (x > 1) {\n                divs[cnt++] = x;\n            }\n            for (int g = 2;; g++) {\n                bool ok = true;\n                for (int i = 0; i < cnt; i++) {\n                    if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {\n                        ok = false;\n                        break;\n                    }\n                }\n                if (ok) return g;\n            }\n        }\n        template <int m> constexpr int primitive_root = primitive_root_constexpr(m);\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n#ifndef _MSC_VER\n        template <class T>\n        using is_signed_int128 =\n        typename std::conditional<std::is_same<T, __int128_t>::value ||\n        std::is_same<T, __int128>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using is_unsigned_int128 =\n        typename std::conditional<std::is_same<T, __uint128_t>::value ||\n        std::is_same<T, unsigned __int128>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using make_unsigned_int128 =\n        typename std::conditional<std::is_same<T, __int128_t>::value,\n        __uint128_t,\n        unsigned __int128>;\n        \n        template <class T>\n        using is_integral = typename std::conditional<std::is_integral<T>::value ||\n        is_signed_int128<T>::value ||\n        is_unsigned_int128<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using is_signed_int = typename std::conditional<(is_integral<T>::value &&\n                                                         std::is_signed<T>::value) ||\n        is_signed_int128<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using is_unsigned_int =\n        typename std::conditional<(is_integral<T>::value &&\n                                   std::is_unsigned<T>::value) ||\n        is_unsigned_int128<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using to_unsigned = typename std::conditional<\n        is_signed_int128<T>::value,\n        make_unsigned_int128<T>,\n        typename std::conditional<std::is_signed<T>::value,\n        std::make_unsigned<T>,\n        std::common_type<T>>::type>::type;\n        \n#else\n        \n        template <class T> using is_integral = typename std::is_integral<T>;\n        \n        template <class T>\n        using is_signed_int =\n        typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using is_unsigned_int =\n        typename std::conditional<is_integral<T>::value &&\n        std::is_unsigned<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using to_unsigned = typename std::conditional<is_signed_int<T>::value,\n        std::make_unsigned<T>,\n        std::common_type<T>>::type;\n        \n#endif\n        \n        template <class T>\n        using is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\n        \n        template <class T>\n        using is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\n        \n        template <class T> using to_unsigned_t = typename to_unsigned<T>::type;\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        struct modint_base {};\n        struct static_modint_base : modint_base {};\n        \n        template <class T> using is_modint = std::is_base_of<modint_base, T>;\n        template <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;\n        \n    }  // namespace internal\n    \n    template <int m, std::enable_if_t<(1 <= m)>* = nullptr>\n    struct static_modint : internal::static_modint_base {\n        using mint = static_modint;\n        \n    public:\n        static constexpr int mod() { return m; }\n        static mint raw(int v) {\n            mint x;\n            x._v = v;\n            return x;\n        }\n        \n        static_modint() : _v(0) {}\n        template <class T, internal::is_signed_int_t<T>* = nullptr>\n        static_modint(T v) {\n            long long x = (long long)(v % (long long)(umod()));\n            if (x < 0) x += umod();\n            _v = (unsigned int)(x);\n        }\n        template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n        static_modint(T v) {\n            _v = (unsigned int)(v % umod());\n        }\n        static_modint(bool v) { _v = ((unsigned int)(v) % umod()); }\n        \n        unsigned int val() const { return _v; }\n        \n        mint& operator++() {\n            _v++;\n            if (_v == umod()) _v = 0;\n            return *this;\n        }\n        mint& operator--() {\n            if (_v == 0) _v = umod();\n            _v--;\n            return *this;\n        }\n        mint operator++(int) {\n            mint result = *this;\n            ++*this;\n            return result;\n        }\n        mint operator--(int) {\n            mint result = *this;\n            --*this;\n            return result;\n        }\n        \n        mint& operator+=(const mint& rhs) {\n            _v += rhs._v;\n            if (_v >= umod()) _v -= umod();\n            return *this;\n        }\n        mint& operator-=(const mint& rhs) {\n            _v -= rhs._v;\n            if (_v >= umod()) _v += umod();\n            return *this;\n        }\n        mint& operator*=(const mint& rhs) {\n            unsigned long long z = _v;\n            z *= rhs._v;\n            _v = (unsigned int)(z % umod());\n            return *this;\n        }\n        mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n        \n        mint operator+() const { return *this; }\n        mint operator-() const { return mint() - *this; }\n        \n        mint pow(long long n) const {\n            assert(0 <= n);\n            mint x = *this, r = 1;\n            while (n) {\n                if (n & 1) r *= x;\n                x *= x;\n                n >>= 1;\n            }\n            return r;\n        }\n        mint inv() const {\n            if (prime) {\n                assert(_v);\n                return pow(umod() - 2);\n            } else {\n                auto eg = internal::inv_gcd(_v, m);\n                assert(eg.first == 1);\n                return eg.second;\n            }\n        }\n        \n        friend mint operator+(const mint& lhs, const mint& rhs) {\n            return mint(lhs) += rhs;\n        }\n        friend mint operator-(const mint& lhs, const mint& rhs) {\n            return mint(lhs) -= rhs;\n        }\n        friend mint operator*(const mint& lhs, const mint& rhs) {\n            return mint(lhs) *= rhs;\n        }\n        friend mint operator/(const mint& lhs, const mint& rhs) {\n            return mint(lhs) /= rhs;\n        }\n        friend bool operator==(const mint& lhs, const mint& rhs) {\n            return lhs._v == rhs._v;\n        }\n        friend bool operator!=(const mint& lhs, const mint& rhs) {\n            return lhs._v != rhs._v;\n        }\n        \n    private:\n        unsigned int _v;\n        static constexpr unsigned int umod() { return m; }\n        static constexpr bool prime = internal::is_prime<m>;\n    };\n    \n    template <int id> struct dynamic_modint : internal::modint_base {\n        using mint = dynamic_modint;\n        \n    public:\n        static int mod() { return (int)(bt.umod()); }\n        static void set_mod(int m) {\n            assert(1 <= m);\n            bt = internal::barrett(m);\n        }\n        static mint raw(int v) {\n            mint x;\n            x._v = v;\n            return x;\n        }\n        \n        dynamic_modint() : _v(0) {}\n        template <class T, internal::is_signed_int_t<T>* = nullptr>\n        dynamic_modint(T v) {\n            long long x = (long long)(v % (long long)(mod()));\n            if (x < 0) x += mod();\n            _v = (unsigned int)(x);\n        }\n        template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n        dynamic_modint(T v) {\n            _v = (unsigned int)(v % mod());\n        }\n        dynamic_modint(bool v) { _v = ((unsigned int)(v) % mod()); }\n        \n        unsigned int val() const { return _v; }\n        \n        mint& operator++() {\n            _v++;\n            if (_v == umod()) _v = 0;\n            return *this;\n        }\n        mint& operator--() {\n            if (_v == 0) _v = umod();\n            _v--;\n            return *this;\n        }\n        mint operator++(int) {\n            mint result = *this;\n            ++*this;\n            return result;\n        }\n        mint operator--(int) {\n            mint result = *this;\n            --*this;\n            return result;\n        }\n        \n        mint& operator+=(const mint& rhs) {\n            _v += rhs._v;\n            if (_v >= umod()) _v -= umod();\n            return *this;\n        }\n        mint& operator-=(const mint& rhs) {\n            _v += mod() - rhs._v;\n            if (_v >= umod()) _v -= umod();\n            return *this;\n        }\n        mint& operator*=(const mint& rhs) {\n            _v = bt.mul(_v, rhs._v);\n            return *this;\n        }\n        mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n        \n        mint operator+() const { return *this; }\n        mint operator-() const { return mint() - *this; }\n        \n        mint pow(long long n) const {\n            assert(0 <= n);\n            mint x = *this, r = 1;\n            while (n) {\n                if (n & 1) r *= x;\n                x *= x;\n                n >>= 1;\n            }\n            return r;\n        }\n        mint inv() const {\n            auto eg = internal::inv_gcd(_v, mod());\n            assert(eg.first == 1);\n            return eg.second;\n        }\n        \n        friend mint operator+(const mint& lhs, const mint& rhs) {\n            return mint(lhs) += rhs;\n        }\n        friend mint operator-(const mint& lhs, const mint& rhs) {\n            return mint(lhs) -= rhs;\n        }\n        friend mint operator*(const mint& lhs, const mint& rhs) {\n            return mint(lhs) *= rhs;\n        }\n        friend mint operator/(const mint& lhs, const mint& rhs) {\n            return mint(lhs) /= rhs;\n        }\n        friend bool operator==(const mint& lhs, const mint& rhs) {\n            return lhs._v == rhs._v;\n        }\n        friend bool operator!=(const mint& lhs, const mint& rhs) {\n            return lhs._v != rhs._v;\n        }\n        \n    private:\n        unsigned int _v;\n        static internal::barrett bt;\n        static unsigned int umod() { return bt.umod(); }\n    };\n    template <int id> internal::barrett dynamic_modint<id>::bt = 998244353;\n    \n    using modint998244353 = static_modint<998244353>;\n    using modint1000000007 = static_modint<1000000007>;\n    using modint = dynamic_modint<-1>;\n    \n    namespace internal {\n        \n        template <class T>\n        using is_static_modint = std::is_base_of<internal::static_modint_base, T>;\n        \n        template <class T>\n        using is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;\n        \n        template <class> struct is_dynamic_modint : public std::false_type {};\n        template <int id>\n        struct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {};\n        \n        template <class T>\n        using is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n#include <cassert>\n#include <type_traits>\n#include <vector>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        template <class mint, internal::is_static_modint_t<mint>* = nullptr>\n        void butterfly(std::vector<mint>& a) {\n            static constexpr int g = internal::primitive_root<mint::mod()>;\n            int n = int(a.size());\n            int h = internal::ceil_pow2(n);\n            \n            static bool first = true;\n            static mint sum_e[30];  // sum_e[i] = ies[0] * ... * ies[i - 1] * es[i]\n            if (first) {\n                first = false;\n                mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n                int cnt2 = bsf(mint::mod() - 1);\n                mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n                for (int i = cnt2; i >= 2; i--) {\n                    es[i - 2] = e;\n                    ies[i - 2] = ie;\n                    e *= e;\n                    ie *= ie;\n                }\n                mint now = 1;\n                for (int i = 0; i < cnt2 - 2; i++) {\n                    sum_e[i] = es[i] * now;\n                    now *= ies[i];\n                }\n            }\n            for (int ph = 1; ph <= h; ph++) {\n                int w = 1 << (ph - 1), p = 1 << (h - ph);\n                mint now = 1;\n                for (int s = 0; s < w; s++) {\n                    int offset = s << (h - ph + 1);\n                    for (int i = 0; i < p; i++) {\n                        auto l = a[i + offset];\n                        auto r = a[i + offset + p] * now;\n                        a[i + offset] = l + r;\n                        a[i + offset + p] = l - r;\n                    }\n                    now *= sum_e[bsf(~(unsigned int)(s))];\n                }\n            }\n        }\n        \n        template <class mint, internal::is_static_modint_t<mint>* = nullptr>\n        void butterfly_inv(std::vector<mint>& a) {\n            static constexpr int g = internal::primitive_root<mint::mod()>;\n            int n = int(a.size());\n            int h = internal::ceil_pow2(n);\n            \n            static bool first = true;\n            static mint sum_ie[30];  // sum_ie[i] = es[0] * ... * es[i - 1] * ies[i]\n            if (first) {\n                first = false;\n                mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n                int cnt2 = bsf(mint::mod() - 1);\n                mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n                for (int i = cnt2; i >= 2; i--) {\n                    es[i - 2] = e;\n                    ies[i - 2] = ie;\n                    e *= e;\n                    ie *= ie;\n                }\n                mint now = 1;\n                for (int i = 0; i < cnt2 - 2; i++) {\n                    sum_ie[i] = ies[i] * now;\n                    now *= es[i];\n                }\n            }\n            \n            for (int ph = h; ph >= 1; ph--) {\n                int w = 1 << (ph - 1), p = 1 << (h - ph);\n                mint inow = 1;\n                for (int s = 0; s < w; s++) {\n                    int offset = s << (h - ph + 1);\n                    for (int i = 0; i < p; i++) {\n                        auto l = a[i + offset];\n                        auto r = a[i + offset + p];\n                        a[i + offset] = l + r;\n                        a[i + offset + p] =\n                        (unsigned long long)(mint::mod() + l.val() - r.val()) *\n                        inow.val();\n                    }\n                    inow *= sum_ie[bsf(~(unsigned int)(s))];\n                }\n            }\n        }\n        \n    }  // namespace internal\n    \n    template <class mint, internal::is_static_modint_t<mint>* = nullptr>\n    std::vector<mint> convolution(std::vector<mint> a, std::vector<mint> b) {\n        int n = int(a.size()), m = int(b.size());\n        if (!n || !m) return {};\n        if (std::min(n, m) <= 60) {\n            if (n < m) {\n                std::swap(n, m);\n                std::swap(a, b);\n            }\n            std::vector<mint> ans(n + m - 1);\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ans[i + j] += a[i] * b[j];\n                }\n            }\n            return ans;\n        }\n        int z = 1 << internal::ceil_pow2(n + m - 1);\n        a.resize(z);\n        internal::butterfly(a);\n        b.resize(z);\n        internal::butterfly(b);\n        for (int i = 0; i < z; i++) {\n            a[i] *= b[i];\n        }\n        internal::butterfly_inv(a);\n        a.resize(n + m - 1);\n        mint iz = mint(z).inv();\n        for (int i = 0; i < n + m - 1; i++) a[i] *= iz;\n        return a;\n    }\n    \n    template <unsigned int mod = 998244353,\n    class T,\n    std::enable_if_t<internal::is_integral<T>::value>* = nullptr>\n    std::vector<T> convolution(const std::vector<T>& a, const std::vector<T>& b) {\n        int n = int(a.size()), m = int(b.size());\n        if (!n || !m) return {};\n        \n        using mint = static_modint<mod>;\n        std::vector<mint> a2(n), b2(m);\n        for (int i = 0; i < n; i++) {\n            a2[i] = mint(a[i]);\n        }\n        for (int i = 0; i < m; i++) {\n            b2[i] = mint(b[i]);\n        }\n        auto c2 = convolution(move(a2), move(b2));\n        std::vector<T> c(n + m - 1);\n        for (int i = 0; i < n + m - 1; i++) {\n            c[i] = c2[i].val();\n        }\n        return c;\n    }\n    \n    std::vector<long long> convolution_ll(const std::vector<long long>& a,\n                                          const std::vector<long long>& b) {\n        int n = int(a.size()), m = int(b.size());\n        if (!n || !m) return {};\n        \n        static constexpr unsigned long long MOD1 = 754974721;  // 2^24\n        static constexpr unsigned long long MOD2 = 167772161;  // 2^25\n        static constexpr unsigned long long MOD3 = 469762049;  // 2^26\n        static constexpr unsigned long long M2M3 = MOD2 * MOD3;\n        static constexpr unsigned long long M1M3 = MOD1 * MOD3;\n        static constexpr unsigned long long M1M2 = MOD1 * MOD2;\n        static constexpr unsigned long long M1M2M3 = MOD1 * MOD2 * MOD3;\n        \n        static constexpr unsigned long long i1 =\n        internal::inv_gcd(MOD2 * MOD3, MOD1).second;\n        static constexpr unsigned long long i2 =\n        internal::inv_gcd(MOD1 * MOD3, MOD2).second;\n        static constexpr unsigned long long i3 =\n        internal::inv_gcd(MOD1 * MOD2, MOD3).second;\n        \n        auto c1 = convolution<MOD1>(a, b);\n        auto c2 = convolution<MOD2>(a, b);\n        auto c3 = convolution<MOD3>(a, b);\n        \n        std::vector<long long> c(n + m - 1);\n        for (int i = 0; i < n + m - 1; i++) {\n            unsigned long long x = 0;\n            x += (c1[i] * i1) % MOD1 * M2M3;\n            x += (c2[i] * i2) % MOD2 * M1M3;\n            x += (c3[i] * i3) % MOD3 * M1M2;\n            long long diff =\n            c1[i] - internal::safe_mod((long long)(x), (long long)(MOD1));\n            if (diff < 0) diff += MOD1;\n            static constexpr unsigned long long offset[5] = {\n                0, 0, M1M2M3, 2 * M1M2M3, 3 * M1M2M3};\n            x -= offset[diff % 5];\n            c[i] = x;\n        }\n        \n        return c;\n    }\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    struct dsu {\n    public:\n        dsu() : _n(0) {}\n        dsu(int n) : _n(n), parent_or_size(n, -1) {}\n        \n        int merge(int a, int b) {\n            assert(0 <= a && a < _n);\n            assert(0 <= b && b < _n);\n            int x = leader(a), y = leader(b);\n            if (x == y) return x;\n            if (-parent_or_size[x] < -parent_or_size[y]) std::swap(x, y);\n            parent_or_size[x] += parent_or_size[y];\n            parent_or_size[y] = x;\n            return x;\n        }\n        \n        bool same(int a, int b) {\n            assert(0 <= a && a < _n);\n            assert(0 <= b && b < _n);\n            return leader(a) == leader(b);\n        }\n        \n        int leader(int a) {\n            assert(0 <= a && a < _n);\n            if (parent_or_size[a] < 0) return a;\n            return parent_or_size[a] = leader(parent_or_size[a]);\n        }\n        \n        int size(int a) {\n            assert(0 <= a && a < _n);\n            return -parent_or_size[leader(a)];\n        }\n        \n        std::vector<std::vector<int>> groups() {\n            std::vector<int> leader_buf(_n), group_size(_n);\n            for (int i = 0; i < _n; i++) {\n                leader_buf[i] = leader(i);\n                group_size[leader_buf[i]]++;\n            }\n            std::vector<std::vector<int>> result(_n);\n            for (int i = 0; i < _n; i++) {\n                result[i].reserve(group_size[i]);\n            }\n            for (int i = 0; i < _n; i++) {\n                result[leader_buf[i]].push_back(i);\n            }\n            result.erase(\n                         std::remove_if(result.begin(), result.end(),\n                                        [&](const std::vector<int>& v) { return v.empty(); }),\n                         result.end());\n            return result;\n        }\n        \n    private:\n        int _n;\n        std::vector<int> parent_or_size;\n    };\n    \n}  // namespace atcoder\n\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    template <class T> struct fenwick_tree {\n        using U = internal::to_unsigned_t<T>;\n        \n    public:\n        fenwick_tree() : _n(0) {}\n        fenwick_tree(int n) : _n(n), data(n) {}\n        \n        void add(int p, T x) {\n            assert(0 <= p && p < _n);\n            p++;\n            while (p <= _n) {\n                data[p - 1] += U(x);\n                p += p & -p;\n            }\n        }\n        \n        T sum(int l, int r) {\n            assert(0 <= l && l <= r && r <= _n);\n            return sum(r) - sum(l);\n        }\n        \n    private:\n        int _n;\n        std::vector<U> data;\n        \n        U sum(int r) {\n            U s = 0;\n            while (r > 0) {\n                s += data[r - 1];\n                r -= r & -r;\n            }\n            return s;\n        }\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nnamespace atcoder {\n    \n    template <class S,\n    S (*op)(S, S),\n    S (*e)(),\n    class F,\n    S (*mapping)(F, S),\n    F (*composition)(F, F),\n    F (*id)()>\n    struct lazy_segtree {\n    public:\n        lazy_segtree() : lazy_segtree(0) {}\n        lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}\n        lazy_segtree(const std::vector<S>& v) : _n(int(v.size())) {\n            log = internal::ceil_pow2(_n);\n            size = 1 << log;\n            d = std::vector<S>(2 * size, e());\n            lz = std::vector<F>(size, id());\n            for (int i = 0; i < _n; i++) d[size + i] = v[i];\n            for (int i = size - 1; i >= 1; i--) {\n                update(i);\n            }\n        }\n        \n        void set(int p, S x) {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--) push(p >> i);\n            d[p] = x;\n            for (int i = 1; i <= log; i++) update(p >> i);\n        }\n        \n        S get(int p) {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--) push(p >> i);\n            return d[p];\n        }\n        \n        S prod(int l, int r) {\n            assert(0 <= l && l <= r && r <= _n);\n            if (l == r) return e();\n            \n            l += size;\n            r += size;\n            \n            for (int i = log; i >= 1; i--) {\n                if (((l >> i) << i) != l) push(l >> i);\n                if (((r >> i) << i) != r) push(r >> i);\n            }\n            \n            S sml = e(), smr = e();\n            while (l < r) {\n                if (l & 1) sml = op(sml, d[l++]);\n                if (r & 1) smr = op(d[--r], smr);\n                l >>= 1;\n                r >>= 1;\n            }\n            \n            return op(sml, smr);\n        }\n        \n        S all_prod() { return d[1]; }\n        \n        void apply(int p, F f) {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--) push(p >> i);\n            d[p] = mapping(f, d[p]);\n            for (int i = 1; i <= log; i++) update(p >> i);\n        }\n        void apply(int l, int r, F f) {\n            assert(0 <= l && l <= r && r <= _n);\n            if (l == r) return;\n            \n            l += size;\n            r += size;\n            \n            for (int i = log; i >= 1; i--) {\n                if (((l >> i) << i) != l) push(l >> i);\n                if (((r >> i) << i) != r) push((r - 1) >> i);\n            }\n            \n            {\n                int l2 = l, r2 = r;\n                while (l < r) {\n                    if (l & 1) all_apply(l++, f);\n                    if (r & 1) all_apply(--r, f);\n                    l >>= 1;\n                    r >>= 1;\n                }\n                l = l2;\n                r = r2;\n            }\n            \n            for (int i = 1; i <= log; i++) {\n                if (((l >> i) << i) != l) update(l >> i);\n                if (((r >> i) << i) != r) update((r - 1) >> i);\n            }\n        }\n        \n        template <bool (*g)(S)> int max_right(int l) {\n            return max_right(l, [](S x) { return g(x); });\n        }\n        template <class G> int max_right(int l, G g) {\n            assert(0 <= l && l <= _n);\n            assert(g(e()));\n            if (l == _n) return _n;\n            l += size;\n            for (int i = log; i >= 1; i--) push(l >> i);\n            S sm = e();\n            do {\n                while (l % 2 == 0) l >>= 1;\n                if (!g(op(sm, d[l]))) {\n                    while (l < size) {\n                        push(l);\n                        l = (2 * l);\n                        if (g(op(sm, d[l]))) {\n                            sm = op(sm, d[l]);\n                            l++;\n                        }\n                    }\n                    return l - size;\n                }\n                sm = op(sm, d[l]);\n                l++;\n            } while ((l & -l) != l);\n            return _n;\n        }\n        \n        template <bool (*g)(S)> int min_left(int r) {\n            return min_left(r, [](S x) { return g(x); });\n        }\n        template <class G> int min_left(int r, G g) {\n            assert(0 <= r && r <= _n);\n            assert(g(e()));\n            if (r == 0) return 0;\n            r += size;\n            for (int i = log; i >= 1; i--) push((r - 1) >> i);\n            S sm = e();\n            do {\n                r--;\n                while (r > 1 && (r % 2)) r >>= 1;\n                if (!g(op(d[r], sm))) {\n                    while (r < size) {\n                        push(r);\n                        r = (2 * r + 1);\n                        if (g(op(d[r], sm))) {\n                            sm = op(d[r], sm);\n                            r--;\n                        }\n                    }\n                    return r + 1 - size;\n                }\n                sm = op(d[r], sm);\n            } while ((r & -r) != r);\n            return 0;\n        }\n        \n    private:\n        int _n, size, log;\n        std::vector<S> d;\n        std::vector<F> lz;\n        \n        void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n        void all_apply(int k, F f) {\n            d[k] = mapping(f, d[k]);\n            if (k < size) lz[k] = composition(f, lz[k]);\n        }\n        void push(int k) {\n            all_apply(2 * k, lz[k]);\n            all_apply(2 * k + 1, lz[k]);\n            lz[k] = id();\n        }\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <tuple>\n#include <vector>\n\nnamespace atcoder {\n    \n    long long pow_mod(long long x, long long n, int m) {\n        assert(0 <= n && 1 <= m);\n        if (m == 1) return 0;\n        internal::barrett bt((unsigned int)(m));\n        unsigned int r = 1, y = (unsigned int)(internal::safe_mod(x, m));\n        while (n) {\n            if (n & 1) r = bt.mul(r, y);\n            y = bt.mul(y, y);\n            n >>= 1;\n        }\n        return r;\n    }\n    \n    long long inv_mod(long long x, long long m) {\n        assert(1 <= m);\n        auto z = internal::inv_gcd(x, m);\n        assert(z.first == 1);\n        return z.second;\n    }\n    \n    std::pair<long long, long long> crt(const std::vector<long long>& r,\n                                        const std::vector<long long>& m) {\n        assert(r.size() == m.size());\n        int n = int(r.size());\n        long long r0 = 0, m0 = 1;\n        for (int i = 0; i < n; i++) {\n            assert(1 <= m[i]);\n            long long r1 = internal::safe_mod(r[i], m[i]), m1 = m[i];\n            if (m0 < m1) {\n                std::swap(r0, r1);\n                std::swap(m0, m1);\n            }\n            if (m0 % m1 == 0) {\n                if (r0 % m1 != r1) return {0, 0};\n                continue;\n            }\n            \n            \n            long long g, im;\n            std::tie(g, im) = internal::inv_gcd(m0, m1);\n            \n            long long u1 = (m1 / g);\n            if ((r1 - r0) % g) return {0, 0};\n            \n            long long x = (r1 - r0) / g % u1 * im % u1;\n            \n            r0 += x * m0;\n            m0 *= u1;  // -> lcm(m0, m1)\n            if (r0 < 0) r0 += m0;\n        }\n        return {r0, m0};\n    }\n    \n    long long floor_sum(long long n, long long m, long long a, long long b) {\n        long long ans = 0;\n        if (a >= m) {\n            ans += (n - 1) * n * (a / m) / 2;\n            a %= m;\n        }\n        if (b >= m) {\n            ans += n * (b / m);\n            b %= m;\n        }\n        \n        long long y_max = (a * n + b) / m, x_max = (y_max * m - b);\n        if (y_max == 0) return ans;\n        ans += (n - (x_max + a - 1) / a) * y_max;\n        ans += floor_sum(y_max, a, m, (a - x_max % a) % a);\n        return ans;\n    }\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n\n#include <vector>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        template <class T> struct simple_queue {\n            std::vector<T> payload;\n            int pos = 0;\n            void reserve(int n) { payload.reserve(n); }\n            int size() const { return int(payload.size()) - pos; }\n            bool empty() const { return pos == int(payload.size()); }\n            void push(const T& t) { payload.push_back(t); }\n            T& front() { return payload[pos]; }\n            void clear() {\n                payload.clear();\n                pos = 0;\n            }\n            void pop() { pos++; }\n        };\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\n\nnamespace atcoder {\n    \n    template <class Cap> struct mf_graph {\n    public:\n        mf_graph() : _n(0) {}\n        mf_graph(int n) : _n(n), g(n) {}\n        \n        int add_edge(int from, int to, Cap cap) {\n            assert(0 <= from && from < _n);\n            assert(0 <= to && to < _n);\n            assert(0 <= cap);\n            int m = int(pos.size());\n            pos.push_back({from, int(g[from].size())});\n            g[from].push_back(_edge{to, int(g[to].size()), cap});\n            g[to].push_back(_edge{from, int(g[from].size()) - 1, 0});\n            return m;\n        }\n        \n        struct edge {\n            int from, to;\n            Cap cap, flow;\n        };\n        \n        edge get_edge(int i) {\n            int m = int(pos.size());\n            assert(0 <= i && i < m);\n            auto _e = g[pos[i].first][pos[i].second];\n            auto _re = g[_e.to][_e.rev];\n            return edge{pos[i].first, _e.to, _e.cap + _re.cap, _re.cap};\n        }\n        std::vector<edge> edges() {\n            int m = int(pos.size());\n            std::vector<edge> result;\n            for (int i = 0; i < m; i++) {\n                result.push_back(get_edge(i));\n            }\n            return result;\n        }\n        void change_edge(int i, Cap new_cap, Cap new_flow) {\n            int m = int(pos.size());\n            assert(0 <= i && i < m);\n            assert(0 <= new_flow && new_flow <= new_cap);\n            auto& _e = g[pos[i].first][pos[i].second];\n            auto& _re = g[_e.to][_e.rev];\n            _e.cap = new_cap - new_flow;\n            _re.cap = new_flow;\n        }\n        \n        Cap flow(int s, int t) {\n            return flow(s, t, std::numeric_limits<Cap>::max());\n        }\n        Cap flow(int s, int t, Cap flow_limit) {\n            assert(0 <= s && s < _n);\n            assert(0 <= t && t < _n);\n            \n            std::vector<int> level(_n), iter(_n);\n            internal::simple_queue<int> que;\n            \n            auto bfs = [&]() {\n                std::fill(level.begin(), level.end(), -1);\n                level[s] = 0;\n                que.clear();\n                que.push(s);\n                while (!que.empty()) {\n                    int v = que.front();\n                    que.pop();\n                    for (auto e : g[v]) {\n                        if (e.cap == 0 || level[e.to] >= 0) continue;\n                        level[e.to] = level[v] + 1;\n                        if (e.to == t) return;\n                        que.push(e.to);\n                    }\n                }\n            };\n            auto dfs = [&](auto self, int v, Cap up) {\n                if (v == s) return up;\n                Cap res = 0;\n                int level_v = level[v];\n                for (int& i = iter[v]; i < int(g[v].size()); i++) {\n                    _edge& e = g[v][i];\n                    if (level_v <= level[e.to] || g[e.to][e.rev].cap == 0) continue;\n                    Cap d =\n                    self(self, e.to, std::min(up - res, g[e.to][e.rev].cap));\n                    if (d <= 0) continue;\n                    g[v][i].cap += d;\n                    g[e.to][e.rev].cap -= d;\n                    res += d;\n                    if (res == up) break;\n                }\n                return res;\n            };\n            \n            Cap flow = 0;\n            while (flow < flow_limit) {\n                bfs();\n                if (level[t] == -1) break;\n                std::fill(iter.begin(), iter.end(), 0);\n                while (flow < flow_limit) {\n                    Cap f = dfs(dfs, t, flow_limit - flow);\n                    if (!f) break;\n                    flow += f;\n                }\n            }\n            return flow;\n        }\n        \n        std::vector<bool> min_cut(int s) {\n            std::vector<bool> visited(_n);\n            internal::simple_queue<int> que;\n            que.push(s);\n            while (!que.empty()) {\n                int p = que.front();\n                que.pop();\n                visited[p] = true;\n                for (auto e : g[p]) {\n                    if (e.cap && !visited[e.to]) {\n                        visited[e.to] = true;\n                        que.push(e.to);\n                    }\n                }\n            }\n            return visited;\n        }\n        \n    private:\n        int _n;\n        struct _edge {\n            int to, rev;\n            Cap cap;\n        };\n        std::vector<std::pair<int, int>> pos;\n        std::vector<std::vector<_edge>> g;\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\n\nnamespace atcoder {\n    \n    template <class Cap, class Cost> struct mcf_graph {\n    public:\n        mcf_graph() {}\n        mcf_graph(int n) : _n(n), g(n) {}\n        \n        int add_edge(int from, int to, Cap cap, Cost cost) {\n            assert(0 <= from && from < _n);\n            assert(0 <= to && to < _n);\n            int m = int(pos.size());\n            pos.push_back({from, int(g[from].size())});\n            g[from].push_back(_edge{to, int(g[to].size()), cap, cost});\n            g[to].push_back(_edge{from, int(g[from].size()) - 1, 0, -cost});\n            return m;\n        }\n        \n        struct edge {\n            int from, to;\n            Cap cap, flow;\n            Cost cost;\n        };\n        \n        edge get_edge(int i) {\n            int m = int(pos.size());\n            assert(0 <= i && i < m);\n            auto _e = g[pos[i].first][pos[i].second];\n            auto _re = g[_e.to][_e.rev];\n            return edge{\n                pos[i].first, _e.to, _e.cap + _re.cap, _re.cap, _e.cost,\n            };\n        }\n        std::vector<edge> edges() {\n            int m = int(pos.size());\n            std::vector<edge> result(m);\n            for (int i = 0; i < m; i++) {\n                result[i] = get_edge(i);\n            }\n            return result;\n        }\n        \n        std::pair<Cap, Cost> flow(int s, int t) {\n            return flow(s, t, std::numeric_limits<Cap>::max());\n        }\n        std::pair<Cap, Cost> flow(int s, int t, Cap flow_limit) {\n            return slope(s, t, flow_limit).back();\n        }\n        std::vector<std::pair<Cap, Cost>> slope(int s, int t) {\n            return slope(s, t, std::numeric_limits<Cap>::max());\n        }\n        std::vector<std::pair<Cap, Cost>> slope(int s, int t, Cap flow_limit) {\n            assert(0 <= s && s < _n);\n            assert(0 <= t && t < _n);\n            assert(s != t);\n            std::vector<Cost> dual(_n, 0), dist(_n);\n            std::vector<int> pv(_n), pe(_n);\n            std::vector<bool> vis(_n);\n            auto dual_ref = [&]() {\n                std::fill(dist.begin(), dist.end(),\n                          std::numeric_limits<Cost>::max());\n                std::fill(pv.begin(), pv.end(), -1);\n                std::fill(pe.begin(), pe.end(), -1);\n                std::fill(vis.begin(), vis.end(), false);\n                struct Q {\n                    Cost key;\n                    int to;\n                    bool operator<(Q r) const { return key > r.key; }\n                };\n                std::priority_queue<Q> que;\n                dist[s] = 0;\n                que.push(Q{0, s});\n                while (!que.empty()) {\n                    int v = que.top().to;\n                    que.pop();\n                    if (vis[v]) continue;\n                    vis[v] = true;\n                    if (v == t) break;\n                    for (int i = 0; i < int(g[v].size()); i++) {\n                        auto e = g[v][i];\n                        if (vis[e.to] || !e.cap) continue;\n                        Cost cost = e.cost - dual[e.to] + dual[v];\n                        if (dist[e.to] - dist[v] > cost) {\n                            dist[e.to] = dist[v] + cost;\n                            pv[e.to] = v;\n                            pe[e.to] = i;\n                            que.push(Q{dist[e.to], e.to});\n                        }\n                    }\n                }\n                if (!vis[t]) {\n                    return false;\n                }\n                \n                for (int v = 0; v < _n; v++) {\n                    if (!vis[v]) continue;\n                    dual[v] -= dist[t] - dist[v];\n                }\n                return true;\n            };\n            Cap flow = 0;\n            Cost cost = 0, prev_cost = -1;\n            std::vector<std::pair<Cap, Cost>> result;\n            result.push_back({flow, cost});\n            while (flow < flow_limit) {\n                if (!dual_ref()) break;\n                Cap c = flow_limit - flow;\n                for (int v = t; v != s; v = pv[v]) {\n                    c = std::min(c, g[pv[v]][pe[v]].cap);\n                }\n                for (int v = t; v != s; v = pv[v]) {\n                    auto& e = g[pv[v]][pe[v]];\n                    e.cap -= c;\n                    g[v][e.rev].cap += c;\n                }\n                Cost d = -dual[s];\n                flow += c;\n                cost += c * d;\n                if (prev_cost == d) {\n                    result.pop_back();\n                }\n                result.push_back({flow, cost});\n                prev_cost = cost;\n            }\n            return result;\n        }\n        \n    private:\n        int _n;\n        \n        struct _edge {\n            int to, rev;\n            Cap cap;\n            Cost cost;\n        };\n        \n        std::vector<std::pair<int, int>> pos;\n        std::vector<std::vector<_edge>> g;\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n\n#include <algorithm>\n#include <utility>\n#include <vector>\n\nnamespace atcoder {\n    namespace internal {\n        \n        template <class E> struct csr {\n            std::vector<int> start;\n            std::vector<E> elist;\n            csr(int n, const std::vector<std::pair<int, E>>& edges)\n            : start(n + 1), elist(edges.size()) {\n                for (auto e : edges) {\n                    start[e.first + 1]++;\n                }\n                for (int i = 1; i <= n; i++) {\n                    start[i] += start[i - 1];\n                }\n                auto counter = start;\n                for (auto e : edges) {\n                    elist[counter[e.first]++] = e.second;\n                }\n            }\n        };\n        \n        struct scc_graph {\n        public:\n            scc_graph(int n) : _n(n) {}\n            \n            int num_vertices() { return _n; }\n            \n            void add_edge(int from, int to) { edges.push_back({from, {to}}); }\n            \n            std::pair<int, std::vector<int>> scc_ids() {\n                auto g = csr<edge>(_n, edges);\n                int now_ord = 0, group_num = 0;\n                std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n                visited.reserve(_n);\n                auto dfs = [&](auto self, int v) -> void {\n                    low[v] = ord[v] = now_ord++;\n                    visited.push_back(v);\n                    for (int i = g.start[v]; i < g.start[v + 1]; i++) {\n                        auto to = g.elist[i].to;\n                        if (ord[to] == -1) {\n                            self(self, to);\n                            low[v] = std::min(low[v], low[to]);\n                        } else {\n                            low[v] = std::min(low[v], ord[to]);\n                        }\n                    }\n                    if (low[v] == ord[v]) {\n                        while (true) {\n                            int u = visited.back();\n                            visited.pop_back();\n                            ord[u] = _n;\n                            ids[u] = group_num;\n                            if (u == v) break;\n                        }\n                        group_num++;\n                    }\n                };\n                for (int i = 0; i < _n; i++) {\n                    if (ord[i] == -1) dfs(dfs, i);\n                }\n                for (auto& x : ids) {\n                    x = group_num - 1 - x;\n                }\n                return {group_num, ids};\n            }\n            \n            std::vector<std::vector<int>> scc() {\n                auto ids = scc_ids();\n                int group_num = ids.first;\n                std::vector<int> counts(group_num);\n                for (auto x : ids.second) counts[x]++;\n                std::vector<std::vector<int>> groups(ids.first);\n                for (int i = 0; i < group_num; i++) {\n                    groups[i].reserve(counts[i]);\n                }\n                for (int i = 0; i < _n; i++) {\n                    groups[ids.second[i]].push_back(i);\n                }\n                return groups;\n            }\n            \n        private:\n            int _n;\n            struct edge {\n                int to;\n            };\n            std::vector<std::pair<int, edge>> edges;\n        };\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    struct scc_graph {\n    public:\n        scc_graph() : internal(0) {}\n        scc_graph(int n) : internal(n) {}\n        \n        void add_edge(int from, int to) {\n            int n = internal.num_vertices();\n            assert(0 <= from && from < n);\n            assert(0 <= to && to < n);\n            internal.add_edge(from, to);\n        }\n        \n        std::vector<std::vector<int>> scc() { return internal.scc(); }\n        \n    private:\n        internal::scc_graph internal;\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    template <class S, S (*op)(S, S), S (*e)()> struct segtree {\n    public:\n        segtree() : segtree(0) {}\n        segtree(int n) : segtree(std::vector<S>(n, e())) {}\n        segtree(const std::vector<S>& v) : _n(int(v.size())) {\n            log = internal::ceil_pow2(_n);\n            size = 1 << log;\n            d = std::vector<S>(2 * size, e());\n            for (int i = 0; i < _n; i++) d[size + i] = v[i];\n            for (int i = size - 1; i >= 1; i--) {\n                update(i);\n            }\n        }\n        \n        void set(int p, S x) {\n            assert(0 <= p && p < _n);\n            p += size;\n            d[p] = x;\n            for (int i = 1; i <= log; i++) update(p >> i);\n        }\n        \n        S get(int p) {\n            assert(0 <= p && p < _n);\n            return d[p + size];\n        }\n        \n        S prod(int l, int r) {\n            assert(0 <= l && l <= r && r <= _n);\n            S sml = e(), smr = e();\n            l += size;\n            r += size;\n            \n            while (l < r) {\n                if (l & 1) sml = op(sml, d[l++]);\n                if (r & 1) smr = op(d[--r], smr);\n                l >>= 1;\n                r >>= 1;\n            }\n            return op(sml, smr);\n        }\n        \n        S all_prod() { return d[1]; }\n        \n        template <bool (*f)(S)> int max_right(int l) {\n            return max_right(l, [](S x) { return f(x); });\n        }\n        template <class F> int max_right(int l, F f) {\n            assert(0 <= l && l <= _n);\n            assert(f(e()));\n            if (l == _n) return _n;\n            l += size;\n            S sm = e();\n            do {\n                while (l % 2 == 0) l >>= 1;\n                if (!f(op(sm, d[l]))) {\n                    while (l < size) {\n                        l = (2 * l);\n                        if (f(op(sm, d[l]))) {\n                            sm = op(sm, d[l]);\n                            l++;\n                        }\n                    }\n                    return l - size;\n                }\n                sm = op(sm, d[l]);\n                l++;\n            } while ((l & -l) != l);\n            return _n;\n        }\n        \n        template <bool (*f)(S)> int min_left(int r) {\n            return min_left(r, [](S x) { return f(x); });\n        }\n        template <class F> int min_left(int r, F f) {\n            assert(0 <= r && r <= _n);\n            assert(f(e()));\n            if (r == 0) return 0;\n            r += size;\n            S sm = e();\n            do {\n                r--;\n                while (r > 1 && (r % 2)) r >>= 1;\n                if (!f(op(d[r], sm))) {\n                    while (r < size) {\n                        r = (2 * r + 1);\n                        if (f(op(d[r], sm))) {\n                            sm = op(d[r], sm);\n                            r--;\n                        }\n                    }\n                    return r + 1 - size;\n                }\n                sm = op(d[r], sm);\n            } while ((r & -r) != r);\n            return 0;\n        }\n        \n    private:\n        int _n, size, log;\n        std::vector<S> d;\n        \n        void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <vector>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        std::vector<int> sa_naive(const std::vector<int>& s) {\n            int n = int(s.size());\n            std::vector<int> sa(n);\n            std::iota(sa.begin(), sa.end(), 0);\n            std::sort(sa.begin(), sa.end(), [&](int l, int r) {\n                if (l == r) return false;\n                while (l < n && r < n) {\n                    if (s[l] != s[r]) return s[l] < s[r];\n                    l++;\n                    r++;\n                }\n                return l == n;\n            });\n            return sa;\n        }\n        \n        std::vector<int> sa_doubling(const std::vector<int>& s) {\n            int n = int(s.size());\n            std::vector<int> sa(n), rnk = s, tmp(n);\n            std::iota(sa.begin(), sa.end(), 0);\n            for (int k = 1; k < n; k *= 2) {\n                auto cmp = [&](int x, int y) {\n                    if (rnk[x] != rnk[y]) return rnk[x] < rnk[y];\n                    int rx = x + k < n ? rnk[x + k] : -1;\n                    int ry = y + k < n ? rnk[y + k] : -1;\n                    return rx < ry;\n                };\n                std::sort(sa.begin(), sa.end(), cmp);\n                tmp[sa[0]] = 0;\n                for (int i = 1; i < n; i++) {\n                    tmp[sa[i]] = tmp[sa[i - 1]] + (cmp(sa[i - 1], sa[i]) ? 1 : 0);\n                }\n                std::swap(tmp, rnk);\n            }\n            return sa;\n        }\n        \n        template <int THRESHOLD_NAIVE = 10, int THRESHOLD_DOUBLING = 40>\n        std::vector<int> sa_is(const std::vector<int>& s, int upper) {\n            int n = int(s.size());\n            if (n == 0) return {};\n            if (n == 1) return {0};\n            if (n == 2) {\n                if (s[0] < s[1]) {\n                    return {0, 1};\n                } else {\n                    return {1, 0};\n                }\n            }\n            if (n < THRESHOLD_NAIVE) {\n                return sa_naive(s);\n            }\n            if (n < THRESHOLD_DOUBLING) {\n                return sa_doubling(s);\n            }\n            \n            std::vector<int> sa(n);\n            std::vector<bool> ls(n);\n            for (int i = n - 2; i >= 0; i--) {\n                ls[i] = (s[i] == s[i + 1]) ? ls[i + 1] : (s[i] < s[i + 1]);\n            }\n            std::vector<int> sum_l(upper + 1), sum_s(upper + 1);\n            for (int i = 0; i < n; i++) {\n                if (!ls[i]) {\n                    sum_s[s[i]]++;\n                } else {\n                    sum_l[s[i] + 1]++;\n                }\n            }\n            for (int i = 0; i <= upper; i++) {\n                sum_s[i] += sum_l[i];\n                if (i < upper) sum_l[i + 1] += sum_s[i];\n            }\n            \n            auto induce = [&](const std::vector<int>& lms) {\n                std::fill(sa.begin(), sa.end(), -1);\n                std::vector<int> buf(upper + 1);\n                std::copy(sum_s.begin(), sum_s.end(), buf.begin());\n                for (auto d : lms) {\n                    if (d == n) continue;\n                    sa[buf[s[d]]++] = d;\n                }\n                std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n                sa[buf[s[n - 1]]++] = n - 1;\n                for (int i = 0; i < n; i++) {\n                    int v = sa[i];\n                    if (v >= 1 && !ls[v - 1]) {\n                        sa[buf[s[v - 1]]++] = v - 1;\n                    }\n                }\n                std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n                for (int i = n - 1; i >= 0; i--) {\n                    int v = sa[i];\n                    if (v >= 1 && ls[v - 1]) {\n                        sa[--buf[s[v - 1] + 1]] = v - 1;\n                    }\n                }\n            };\n            \n            std::vector<int> lms_map(n + 1, -1);\n            int m = 0;\n            for (int i = 1; i < n; i++) {\n                if (!ls[i - 1] && ls[i]) {\n                    lms_map[i] = m++;\n                }\n            }\n            std::vector<int> lms;\n            lms.reserve(m);\n            for (int i = 1; i < n; i++) {\n                if (!ls[i - 1] && ls[i]) {\n                    lms.push_back(i);\n                }\n            }\n            \n            induce(lms);\n            \n            if (m) {\n                std::vector<int> sorted_lms;\n                sorted_lms.reserve(m);\n                for (int v : sa) {\n                    if (lms_map[v] != -1) sorted_lms.push_back(v);\n                }\n                std::vector<int> rec_s(m);\n                int rec_upper = 0;\n                rec_s[lms_map[sorted_lms[0]]] = 0;\n                for (int i = 1; i < m; i++) {\n                    int l = sorted_lms[i - 1], r = sorted_lms[i];\n                    int end_l = (lms_map[l] + 1 < m) ? lms[lms_map[l] + 1] : n;\n                    int end_r = (lms_map[r] + 1 < m) ? lms[lms_map[r] + 1] : n;\n                    bool same = true;\n                    if (end_l - l != end_r - r) {\n                        same = false;\n                    } else {\n                        while (l < end_l) {\n                            if (s[l] != s[r]) {\n                                break;\n                            }\n                            l++;\n                            r++;\n                        }\n                        if (l == n || s[l] != s[r]) same = false;\n                    }\n                    if (!same) rec_upper++;\n                    rec_s[lms_map[sorted_lms[i]]] = rec_upper;\n                }\n                \n                auto rec_sa =\n                sa_is<THRESHOLD_NAIVE, THRESHOLD_DOUBLING>(rec_s, rec_upper);\n                \n                for (int i = 0; i < m; i++) {\n                    sorted_lms[i] = lms[rec_sa[i]];\n                }\n                induce(sorted_lms);\n            }\n            return sa;\n        }\n        \n    }  // namespace internal\n    \n    std::vector<int> suffix_array(const std::vector<int>& s, int upper) {\n        assert(0 <= upper);\n        for (int d : s) {\n            assert(0 <= d && d <= upper);\n        }\n        auto sa = internal::sa_is(s, upper);\n        return sa;\n    }\n    \n    template <class T> std::vector<int> suffix_array(const std::vector<T>& s) {\n        int n = int(s.size());\n        std::vector<int> idx(n);\n        iota(idx.begin(), idx.end(), 0);\n        sort(idx.begin(), idx.end(), [&](int l, int r) { return s[l] < s[r]; });\n        std::vector<int> s2(n);\n        int now = 0;\n        for (int i = 0; i < n; i++) {\n            if (i && s[idx[i - 1]] != s[idx[i]]) now++;\n            s2[idx[i]] = now;\n        }\n        return internal::sa_is(s2, now);\n    }\n    \n    std::vector<int> suffix_array(const std::string& s) {\n        int n = int(s.size());\n        std::vector<int> s2(n);\n        for (int i = 0; i < n; i++) {\n            s2[i] = s[i];\n        }\n        return internal::sa_is(s2, 255);\n    }\n    \n    template <class T>\n    std::vector<int> lcp_array(const std::vector<T>& s,\n                               const std::vector<int>& sa) {\n        int n = int(s.size());\n        assert(n >= 1);\n        std::vector<int> rnk(n);\n        for (int i = 0; i < n; i++) {\n            rnk[sa[i]] = i;\n        }\n        std::vector<int> lcp(n - 1);\n        int h = 0;\n        for (int i = 0; i < n; i++) {\n            if (h > 0) h--;\n            if (rnk[i] == 0) continue;\n            int j = sa[rnk[i] - 1];\n            for (; j + h < n && i + h < n; h++) {\n                if (s[j + h] != s[i + h]) break;\n            }\n            lcp[rnk[i] - 1] = h;\n        }\n        return lcp;\n    }\n    \n    std::vector<int> lcp_array(const std::string& s, const std::vector<int>& sa) {\n        int n = int(s.size());\n        std::vector<int> s2(n);\n        for (int i = 0; i < n; i++) {\n            s2[i] = s[i];\n        }\n        return lcp_array(s2, sa);\n    }\n    \n    template <class T> std::vector<int> z_algorithm(const std::vector<T>& s) {\n        int n = int(s.size());\n        if (n == 0) return {};\n        std::vector<int> z(n);\n        z[0] = 0;\n        for (int i = 1, j = 0; i < n; i++) {\n            int& k = z[i];\n            k = (j + z[j] <= i) ? 0 : std::min(j + z[j] - i, z[i - j]);\n            while (i + k < n && s[k] == s[i + k]) k++;\n            if (j + z[j] < i + z[i]) j = i;\n        }\n        z[0] = n;\n        return z;\n    }\n    \n    std::vector<int> z_algorithm(const std::string& s) {\n        int n = int(s.size());\n        std::vector<int> s2(n);\n        for (int i = 0; i < n; i++) {\n            s2[i] = s[i];\n        }\n        return z_algorithm(s2);\n    }\n    \n}  // namespace atcoder\n\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    struct two_sat {\n    public:\n        two_sat() : _n(0), scc(0) {}\n        two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n        \n        void add_clause(int i, bool f, int j, bool g) {\n            assert(0 <= i && i < _n);\n            assert(0 <= j && j < _n);\n            scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n            scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n        }\n        bool satisfiable() {\n            auto id = scc.scc_ids().second;\n            for (int i = 0; i < _n; i++) {\n                if (id[2 * i] == id[2 * i + 1]) return false;\n                _answer[i] = id[2 * i] < id[2 * i + 1];\n            }\n            return true;\n        }\n        std::vector<bool> answer() { return _answer; }\n        \n    private:\n        int _n;\n        std::vector<bool> _answer;\n        internal::scc_graph scc;\n    };\n    \n}  // namespace atcoder\n\nconst int mod1=1000000007,mod2=1000000009,MAX=600005,D=300000,ha1=299993,ha2=300007;\nconst ll INF=1LL<<50;\n\nusing mint=atcoder::modint1000000007;\n\nmint rui[MAX][2];\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int N;cin>>N;\n    string S;cin>>S;\n    \n    map<pair<ll,ll>,int> MA;\n    \n    pair<mint,mint> ha=mp(0,0);\n    int now=D;\n    \n    rui[0][0]=rui[0][1]=1;\n    for(int i=1;i<MAX;i++){\n        rui[i][0]=rui[i-1][0]*ha1;\n        rui[i][1]=rui[i-1][1]*ha2;\n    }\n    \n    ll ans=0;\n    \n    for(int i=0;i<N;i++){\n        if(S[i]=='+'){\n            ha.fi+=rui[now][0];\n            ha.se+=rui[now][1];\n        }else if(S[i]=='-'){\n            ha.fi-=rui[now][0];\n            ha.se-=rui[now][1];\n        }else if(S[i]=='>'){\n            now++;\n        }else{\n            now--;\n        }\n        pair<ll,ll> x;\n        x.fi=ha.fi.val();\n        x.se=ha.se.val();\n        MA[x]++;\n        \n        if(i==N-1) ans+=MA[x];\n    }\n    \n    pair<mint,mint> la=ha;\n    \n    now=D;\n    ha=mp(0,0);\n    \n    //cout<<ans<<endl;\n    \n    for(int i=0;i<N;i++){\n        if(S[i]=='+'){\n            ha.fi+=rui[now][0];\n            ha.se+=rui[now][1];\n        }else if(S[i]=='-'){\n            ha.fi-=rui[now][0];\n            ha.se-=rui[now][1];\n        }else if(S[i]=='>'){\n            now++;\n        }else{\n            now--;\n        }\n        pair<mint,mint> save=ha;\n        \n        pair<ll,ll> x;\n        \n        x.fi=ha.fi.val();\n        x.se=ha.se.val();\n        \n        MA[x]--;\n        \n        ha.fi+=la.fi*rui[now][0]/rui[D][0];\n        ha.se+=la.se*rui[now][1]/rui[D][1];\n        \n        x.fi=ha.fi.val();\n        x.se=ha.se.val();\n        \n        if(MA.count(x)) ans+=MA[x];\n        \n        ha=save;\n        \n    }\n    \n    cout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll pow_mod(ll x,int k,ll MOD) {\n  ll ans=1;\n  while (k) {\n  \tif (k&1) ans=ans*x%MOD;\n  \tx=x*x%MOD;\n  \tk>>=1;\n  }\n  return ans;\n}\n\nconst int prime[10]={998244353,998244353,998244353,998244353,998244353,998244353,998244353,998244353,998244353,998244353};\nconst ll H[10]={19260817,19260817,19260817,19260817,19260817,19260817,19260817,19260817,19260817,19260817};\n\nint powd[10][1000005],invd[10][1000005];\n\nvoid pre(int n) {\n  for(int i=0;i<10;i++) {\n    ll inv=pow_mod(H[i],prime[i]-2,prime[i]);\n    powd[i][0]=1;\n    for(int j=1;j<=n;j++) powd[i][j]=(ll)powd[i][j-1]*H[i]%prime[i];\n    invd[i][0]=1;\n    for(int j=1;j<=n;j++) invd[i][j]=(ll)invd[i][j-1]*inv%prime[i];\n  }\n}\n\nstruct Data {\n  int num[10];\n  Data() {memset(num,0,sizeof(num));}\n  Data operator + (Data b) {\n  \tData c;\n  \tfor(int i=0;i<10;i++) c.num[i]=(num[i]+b.num[i])%prime[i];\n  \treturn c;\n  }\n  void add(int x) {\n  \tfor(int i=0;i<10;i++) num[i]=(num[i]+powd[i][x])%prime[i];\n  }\n  void dec(int x) {\n  \tfor(int i=0;i<10;i++) num[i]=(num[i]-powd[i][x]+prime[i])%prime[i];\n  }\n  void rshift(int x) {\n  \tfor(int i=0;i<10;i++) num[i]=(ll)num[i]*powd[i][x]%prime[i];\n  }\n  void lshift(int x) {\n  \tfor(int i=0;i<10;i++) num[i]=num[i]*invd[i][x]%prime[i];\n  }\n  bool operator < (const Data & b) const {\n  \tfor(int i=0;i<10;i++)\n  \t  if (num[i]!=b.num[i]) return num[i]<b.num[i];\n  \treturn 0;\n  }\n};\n\nmap <Data,int> mp;\nData p[250005];\n\nchar str[250005];\n\nint main() {\n  int n;\n  scanf(\"%d%s\",&n,str+1);\n  pre(4*n);\n  int d=0;\n  for(int i=1;i<=n;i++) {\n  \tp[i]=p[i-1];\n    if (str[i]=='+') p[i].add(2*n+d);\n    else if (str[i]=='-') p[i].dec(2*n+d);\n    else if (str[i]=='>') d++;\n    else d--;\n    mp[p[i]]++;\n  }\n  ll ans=0;\n  d=0;\n  for(int i=1;i<=n;i++) {\n  \tData t=p[n];\n  \tif (d>=0) t.rshift(d); else t.lshift(-d);\n\tt=t+p[i-1];\n\tif (mp.count(t)) ans+=mp[t];\n\tif (str[i]=='>') d++;\n\telse if (str[i]=='<') d--;\n\tmp[p[i]]--;\n  }\n  printf(\"%lld\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <string.h>\n//#include <unordered_set>\n//#include <unordered_map>\n//#include <bits/stdc++.h>\n\n#define MP(A,B) make_pair(A,B)\n#define PB(A) push_back(A)\n#define SIZE(A) ((int)A.size())\n#define LEN(A) ((int)A.length())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define fi first\n#define se second\n\nusing namespace std;\n\ntemplate<typename T>inline bool upmin(T &x,T y) { return y<x?x=y,1:0; }\ntemplate<typename T>inline bool upmax(T &x,T y) { return x<y?x=y,1:0; }\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double lod;\ntypedef pair<int,int> PR;\ntypedef vector<int> VI;\n\nconst lod eps=1e-11;\nconst lod pi=acos(-1);\nconst int oo=1<<30;\nconst ll loo=1ll<<62;\nconst int mods=998244353;\nconst int MAXN=1000005;\nconst int INF=0x3f3f3f3f;//1061109567\n/*--------------------------------------------------------------------*/\ninline int read()\n{\n\tint f=1,x=0; char c=getchar();\n\twhile (c<'0'||c>'9') { if (c=='-') f=-1; c=getchar(); }\n\twhile (c>='0'&&c<='9') { x=(x<<3)+(x<<1)+(c^48); c=getchar(); }\n\treturn x*f;\n}\nint upd(int x,int y) { return x+y>=mods?x+y-mods:x+y; }\nint quick_pow(int x,int y)\n{\n\tint ret=1;\n\tfor (;y;y>>=1)\n\t{\n\t\tif (y&1) ret=1ll*ret*x%mods;\n\t\tx=1ll*x*x%mods;\n\t}\n\treturn ret;\n}\n\nchar st[MAXN];\nint X[6]={37,667,233333,17,19,53},inv[6];\nstruct Node\n{\n\tint a[6]; \n\tNode() { for (int i=0;i<6;i++) a[i]=0; }\n};\nbool operator < (Node x,Node y) \n{\n\tfor (int i=0;i<6;i++) { if (x.a[i]==y.a[i]) continue; return x.a[i]<y.a[i]; }\n\treturn 0;\n}\nmap<Node,int> Map;\nNode operator + (Node x,int y) { for (int i=0;i<6;i++) x.a[i]=upd(x.a[i],y); return x; }\nNode operator - (Node x,int y) { for (int i=0;i<6;i++) x.a[i]=upd(x.a[i],mods-y); return x; }\nNode operator >> (Node x,int y) { while (y--) for (int i=0;i<6;i++) x.a[i]=1ll*x.a[i]*X[i]%mods; return x; }\nNode operator << (Node x,int y) { while (y--) for (int i=0;i<6;i++) x.a[i]=1ll*x.a[i]*inv[i]%mods; return x; }\n\nstruct fnode\n{\n\tNode k,b;\n\tfnode() { for (int i=0;i<6;i++) k.a[i]=1,b.a[i]=0; }\n};\nfnode operator + (fnode x,int y) { for (int i=0;i<6;i++) x.b.a[i]=upd(x.b.a[i],y*x.k.a[i]); return x; }\nfnode operator - (fnode x,int y) { for (int i=0;i<6;i++) x.b.a[i]=upd(x.b.a[i],mods-y*x.k.a[i]); return x; }\nfnode operator >> (fnode x,int y) { while (y--) for (int i=0;i<6;i++) x.k.a[i]=1ll*x.k.a[i]*X[i]%mods; return x; }\nfnode operator << (fnode x,int y) { while (y--) for (int i=0;i<6;i++) x.k.a[i]=1ll*x.k.a[i]*inv[i]%mods; return x; }\nNode operator * (Node x,fnode y) \n{\n\tNode ans;\n\tfor (int i=0;i<6;i++) ans.a[i]=upd(ans.a[i],(1ll*y.k.a[i]*x.a[i]+y.b.a[i])%mods);\n\treturn ans;\n}\nint main()\n{\n\tfor (int i=0;i<6;i++) inv[i]=quick_pow(X[i],mods-2);\n\tint n=read();\n\tscanf(\"%s\",st+1);\n\tNode c,p;\n\tfor (int i=n;i>=1;i--)\n\t{\n\t\tif (st[i]=='+') c=c+1;\n\t\tif (st[i]=='-') c=c-1;\n\t\tif (st[i]=='<') c=c<<1;\n\t\tif (st[i]=='>') c=c>>1;\n//\t\tfor (int j=0;j<6;j++) cout<<c.a[j]<<\" \";cout<<endl;\n\t}\n//\tcout<<endl;\n\tMap[p]++;\n\tfnode f;\n\tll ans=0;\n\tfor (int i=n;i>=1;i--)\n\t{\n\t\tif (st[i]=='+') f=f-1;\n\t\tif (st[i]=='-') f=f+1;\n\t\tif (st[i]=='<') f=f>>1;\n\t\tif (st[i]=='>') f=f<<1;\n\t\tans+=Map[c*f],Map[p*f]++;\n//\t\tfor (int j=0;j<6;j++) cout<<(p*f).a[j]<<\" \";cout<<endl;\n//\t\tfor (int j=0;j<6;j++) cout<<(c*f).a[j]<<\" \";cout<<endl<<endl;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<map>\nusing namespace std;\nstruct node{long long g1,g2,g3,g4;int p;};\nconst int p1=1000000007,p2=1000000009;\nlong long x1p1[510000],x1p2[510000],x2p1[510000],x2p2[510000];\ninline node operator+(node x,node y){return {(x.g1+y.g1*x1p1[x.p+250000])%p1,(x.g2+y.g2*x1p2[x.p+250000])%p2,(x.g3+y.g3*x2p1[x.p+250000])%p1,(x.g4+y.g4*x2p2[x.p+250000])%p2,x.p+y.p};}\nchar s[260000];\nmap<long long,map<long long,map<long long,map<long long,int>>>> M;\nint main()\n{\n\tx1p1[249999]=500000004;x1p1[250000]=1;x1p1[250001]=2;\n\tx1p2[249999]=500000005;x1p2[250000]=1;x1p2[250001]=2;\n\tx2p1[249999]=666666671;x2p1[250000]=1;x2p1[250001]=3;\n\tx2p2[249999]=333333336;x2p2[250000]=1;x2p2[250001]=3;\n\tfor(int i=249998;i>=0;i--)x1p1[i]=x1p1[i+1]*x1p1[249999]%p1,x1p2[i]=x1p2[i+1]*x1p2[249999]%p2,x2p1[i]=x2p1[i+1]*x2p1[249999]%p1,x2p2[i]=x2p2[i+1]*x2p2[249999]%p2;\n\tfor(int i=250002;i<=500000;i++)x1p1[i]=x1p1[i-1]*x1p1[250001]%p1,x1p2[i]=x1p2[i-1]*x1p2[250001]%p2,x2p1[i]=x2p1[i-1]*x2p1[250001]%p1,x2p2[i]=x2p2[i-1]*x2p2[250001]%p2;\n\tint n;scanf(\"%d%s\",&n,s+1);\n\tnode gs={0,0,0,0,0},pr={0,0,0,0,0};\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(s[i]=='+')gs.g1=(gs.g1+x1p1[gs.p+250000])%p1,gs.g2=(gs.g2+x1p2[gs.p+250000])%p2,gs.g3=(gs.g3+x2p1[gs.p+250000])%p1,gs.g4=(gs.g4+x2p2[gs.p+250000])%p2;\n\t\telse if(s[i]=='-')gs.g1=(gs.g1-x1p1[gs.p+250000]+p1)%p1,gs.g2=(gs.g2-x1p2[gs.p+250000]+p2)%p2,gs.g3=(gs.g3-x2p1[gs.p+250000]+p1)%p1,gs.g4=(gs.g4-x2p2[gs.p+250000]+p2)%p2;\n\t\telse if(s[i]=='>')gs.p++;\n\t\telse gs.p--;\n\t}\n\tlong long ss=0;\n\tnode rg=pr+gs;\n\tM[rg.g1][rg.g2][rg.g3][rg.g4]++;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(s[i]=='+')pr.g1=(pr.g1+x1p1[pr.p+250000])%p1,pr.g2=(pr.g2+x1p2[pr.p+250000])%p2,pr.g3=(pr.g3+x2p1[pr.p+250000])%p1,pr.g4=(pr.g4+x2p2[pr.p+250000])%p2;\n\t\telse if(s[i]=='-')pr.g1=(pr.g1-x1p1[pr.p+250000]+p1)%p1,pr.g2=(pr.g2-x1p2[pr.p+250000]+p2)%p2,pr.g3=(pr.g3-x2p1[pr.p+250000]+p1)%p1,pr.g4=(pr.g4-x2p2[pr.p+250000]+p2)%p2;\n\t\telse if(s[i]=='>')pr.p++;\n\t\telse pr.p--;\n\t\tss=ss+M[pr.g1][pr.g2][pr.g3][pr.g4];\n\t\trg=pr+gs;\n\t\tM[rg.g1][rg.g2][rg.g3][rg.g4]++;\n\t}\n\tprintf(\"%lld\\n\",ss);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int N = 4e5 + 10;\nint mod1=998244353,base1=19260817,inv1;\nint mod2=353448299,base2=20000003,inv2;\nint s[N], pw1[N], pw2[N], rev1[N], rev2[N];\n\nint q_pow(int x, int y, int mod) {\n  int ans = 1;\n  for(; y; y >>= 1) {\n    if(y & 1) ans = 1ll * ans * x % mod;\n    x = 1ll * x * x % mod;\n  }\n  return ans;\n}\n\nint h1[N], h2[N];\ntypedef pair<int, int> P;\nmap<P, int> mp;\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  inv1 = q_pow(base1, mod1 - 2, mod1);\n  inv2 = q_pow(base2, mod2 - 2, mod2);\n  pw1[0] = pw2[0] = rev1[0] = rev2[0] = 1;\n  for(int i = 1; i <= (n << 1); ++i) {\n    pw1[i] = 1ll * pw1[i - 1] * base1 % mod1;\n    pw2[i] = 1ll * pw2[i - 1] * base2 % mod2;\n    rev1[i] = 1ll * rev1[i - 1] * inv1 % mod1;\n    rev2[i] = 1ll * rev2[i - 1] * inv2 % mod2;\n  }\n  s[0] = n;\n  for(int i = 1; i <= n; ++i) {\n    char ch; cin >> ch;\n    if(ch == '+') {\n      s[i] = s[i - 1];\n      h1[i] = (h1[i - 1] + pw1[s[i]]) % mod1;\n      h2[i] = (h2[i - 1] + pw2[s[i]]) % mod2;\n    } else if(ch == '-') {\n      s[i] = s[i - 1];\n      h1[i] = (h1[i - 1] - pw1[s[i]] + mod1) % mod1;\n      h2[i] = (h2[i - 1] - pw2[s[i]] + mod2) % mod2;\n    } else if(ch == '>') {\n      s[i] = s[i - 1] + 1;\n      h1[i] = h1[i - 1];\n      h2[i] = h2[i - 1];\n    } else {\n      s[i] = s[i - 1] - 1;\n      h1[i] = h1[i - 1];\n      h2[i] = h2[i - 1];\n    }\n    mp[P(h1[i], h2[i])]++;\n  }\n  ll ans = 0;\n  for(int i = 1; i <= n; ++i) {\n    int pos = h1[n], tmp = h2[n];\n    int sit = s[i - 1] - n;\n    if(sit >= 0) pos = 1ll * pos * pw1[sit] % mod1, tmp = 1ll * tmp * pw2[sit] % mod2;\n    else pos = 1ll * pos * rev1[-sit] % mod1, tmp = 1ll * tmp * rev2[-sit] % mod2;\n    pos = (pos + h1[i - 1]) % mod1;\n    tmp = (tmp + h2[i - 1]) % mod2;\n    ans += mp[P(pos, tmp)];\n    mp[P(h1[i], h2[i])]--;\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1e9 + 7;\nconst int N = 2e5 + 5;\nconst int X = 1000003;\ntypedef long long ll;\n\n\nchar c,s[N];\nll n,i,t,a,b,x,bol=1,ans;\nmap < int , int > M;\n\nint main(){\n    cin >> n >> s;\n    for(t=X,i=mod-2; i ; i>>=1){\n        if(i & 1) bol = bol*t % mod;\n        t = t*t % mod;\n    }\n    for(i=n-1; i>=0 ;i--){\n        scanf(\" %c\", &c);\n        s[i] = c;\n        if(c == '+') x++;\n        if(c == '-') x--;\n        if(c == '>') x *= X;\n        if(c == '<') x *= bol;\n        x = (x % mod + mod) % mod; \n    }\n\n    a = 1; b = 0;\n    M[0] = 1;\n    for(i=n-1; i>=0 ;i--){\n        c = s[i];\n        if(c == '+') b -= a;\n        if(c == '-') b += a;\n        if(c == '>') a *= bol;\n        if(c == '<') a *= X;\n        a = (a % mod + mod) % mod;\n        b = (b % mod + mod) % mod;\n        t = (a*x + b) % mod;\n        ans += M[t];\n        M[b]++;\n    }\n\n    cout << ans;\n    return 0;\n}   "
  },
  {
    "language": "C++",
    "code": "    #include<stdio.h>\n    #include<vector>\n    #include<algorithm>\n    #include<string>\n    #include<iostream>\n    #include<map>\n    using namespace std;\n    typedef long long ll;\n    ll m1 = 1000000007, m2 = 1000000009;\n    ll t1 = 2, t2 = 1000000007;\n    ll p1[505050], p2[505050];\n    ll ip1[505050], ip2[505050];\n    typedef pair<ll, ll>pii;\n    ll po(ll a, ll b, ll m)\n    {\n    \tif (b == 0)return 1;\n    \tll z = po(a, b / 2, m);\n    \tz = z*z%m;\n    \tif (b & 1)z = z*a%m;\n    \treturn z;\n    }\n    ll inv(ll a, ll m)\n    {\n    \treturn po(a, m - 2, m);\n    }\n    int main()\n    {\n    \tint num;\n    \tscanf(\"%d\", &num);\n    \tstring s;\n    \tcin >> s;\n    \tp1[0] = p2[0] = ip1[0] = ip2[0] = 1;\n    \tfor (int i = 0; i < 505000; i++)p1[i + 1] = p1[i] * t1%m1, p2[i + 1] = p2[i] * t2%m2;\n    \tll it1 = inv(t1, m1), it2 = inv(t2, m2);\n    \tfor (int i = 0; i < 505000; i++)ip1[i + 1] = ip1[i] * it1%m1, ip2[i + 1] = ip2[i] * it2%m2;\n    \tll n1 = 0, n2 = 0;\n    \tvector<pii>v;\n    \tvector<int>pl;\n    \tv.push_back(make_pair(0, 0));\n    \tpl.push_back(num + 10);\n    \tint now = num + 10;\n    \tfor (int i = 0; i < num; i++)\n    \t{\n    \t\tif (s[i] == '+')n1 = (n1 + p1[now]) % m1, n2 = (n2 + p2[now]) % m2;\n    \t\telse if (s[i] == '-')n1 = (n1 + m1 - p1[now]) % m1, n2 = (n2 + m2 - p2[now]) % m2;\n    \t\telse if (s[i] == '>')now++;\n    \t\telse now--;\n    \t\tv.push_back(make_pair(n1, n2)), pl.push_back(now);\n    \t}\n    \tll ans = 0;\n    \tmap<pii, int>ma;\n    \tfor (int i = num; i >= 0; i--)\n    \t{\n    \t\tint dif = pl[i] - (num + 10);\n    \t\tll mk1, mk2;\n    \t\tif (dif >= 0)mk1 = (v[i].first + n1*p1[dif]) % m1, mk2 = (v[i].second + n2*p2[dif]) % m2;\n    \t\telse mk1 = (v[i].first + n1*ip1[-dif]) % m1, mk2 = (v[i].second + n2*ip2[-dif]) % m2;\n    \t\tans += ma[make_pair(mk1, mk2)];\n    \t\tma[v[i]]++;\n    \t}\n    \tprintf(\"%lld\\n\", ans);\n    }"
  },
  {
    "language": "C++",
    "code": "/*\n    _____\n  .'     '.\n /  0   0  \\\n|     ^     |\n|  \\     /  |\n \\  '---'  /\n  '._____.'\n*/\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\nstruct chash\n{\n\tint operator()(int x) const\n\t{\n\t\tx ^= (x >> 20) ^ (x >> 12);\n\t\treturn x ^ (x >> 7) ^ (x >> 4);\n\t}\n};\n\ntemplate<typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename U> using hashtable = gp_hash_table<T, U, chash>;\nrandom_device(rd);\nmt19937 rng(rd());\n\ntemplate<class T>\nvoid readi(T &x)\n{\n\tT input = 0;\n\tbool negative = false;\n\tchar c = ' ';\n\twhile (c < '-')\n\t{\n\t\tc = getchar();\n\t}\n\tif (c == '-')\n\t{\n\t\tnegative = true;\n\t\tc = getchar();\n\t}\n\twhile (c >= '0')\n\t{\n\t\tinput = input * 10 + (c - '0');\n\t\tc = getchar();\n\t}\n\tif (negative)\n\t{\n\t\tinput = -input;\n\t}\n\tx = input;\n}\ntemplate<class T>\nvoid printi(T output)\n{\n\tif (output == 0)\n\t{\n\t\tputchar('0');\n\t\treturn;\n\t}\n\tif (output < 0)\n\t{\n\t\tputchar('-');\n\t\toutput = -output;\n\t}\n\tint aout[20];\n\tint ilen = 0;\n\twhile(output)\n\t{\n\t\taout[ilen] = ((output % 10));\n\t\toutput /= 10;\n\t\tilen++;\n\t}\n\tfor (int i = ilen - 1; i >= 0; i--)\n\t{\n\t\tputchar(aout[i] + '0');\n\t}\n\treturn;\n}\ntemplate<class T>\nvoid ckmin(T &a, T b)\n{\n\ta = min(a, b);\n}\ntemplate<class T>\nvoid ckmax(T &a, T b)\n{\n\ta = max(a, b);\n}\ntemplate<class T, class U>\nT nmod(T &x, U mod)\n{\n\tif (x >= mod) x -= mod;\n}\ntemplate<class T>\nT randomize(T mod)\n{\n\treturn (uniform_int_distribution<T>(0, mod - 1))(rng);\n}\n\n#define y0 ___y0\n#define y1 ___y1\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fi first\n#define se second\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\nconst long double PI = 4.0 * atan(1.0);\nconst long double EPS = 1e-10;\n\n#define MAGIC 347\n#define SINF 10007\n#define CO 1000007\n#define INF 1000000007\n#define BIG 1000000931\n#define LARGE 1696969696967ll\n#define GIANT 2564008813937411ll\n#define LLINF 2696969696969696969ll\n#define MAXN 500013\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ld, ld> pdd;\n\nint N;\nint arr[MAXN];\npll S;\nlong long ans;\nunordered_map<ll, int> need;\n\nll expo(ll a, ll e, ll mod)\n{\n\tif (e == 0)\n\t{\n\t\treturn 1;\n\t}\n\tll was = expo(a, e / 2, mod);\n\tif (e % 2)\n\t{\n\t\treturn was * was % mod * a % mod;\n\t}\n\treturn was * was % mod;\n}\nll modinv(ll a, ll e)\n{\n\treturn expo(a, e - 2, e);\n}\npll INV = {modinv(CO, INF), modinv(CO, BIG)};\nvoid solve(int L, int R)\n{\n\tif (L == R)\n\t{\n\t\treturn;\n\t}\n\tfreq.clear(); need.clear();\n\tint mid = (L + R) >> 1;\n\t//start from L...mid, end at mid + 1....R\n\tpair<pll, pll> trans = MP(MP(1, 0), MP(1, 0));\n\tfor (int i = mid + 1; i <= R; i++)\n\t{\n\t\tif (arr[i] == 0)\n\t\t{\n\t\t\ttrans.fi.fi *= INV.fi; trans.fi.fi %= INF;\n\t\t\ttrans.fi.se *= INV.fi; trans.fi.se %= INF;\n\t\t\ttrans.se.fi *= INV.se; trans.se.fi %= BIG;\n\t\t\ttrans.se.se *= INV.se; trans.se.se %= BIG;\n\t\t}\n\t\tif (arr[i] == 1)\n\t\t{\n\t\t\ttrans.fi.fi *= CO; trans.fi.fi %= INF;\n\t\t\ttrans.fi.se *= CO; trans.fi.se %= INF;\n\t\t\ttrans.se.fi *= CO; trans.se.fi %= BIG;\n\t\t\ttrans.se.se *= CO; trans.se.se %= BIG;\n\t\t}\n\t\tif (arr[i] == 2)\n\t\t{\n\t\t\ttrans.fi.se++; nmod(trans.fi.se, INF);\n\t\t\ttrans.se.se++; nmod(trans.se.se, BIG);\n\t\t}\n\t\tif (arr[i] == 3)\n\t\t{\n\t\t\ttrans.fi.se--; trans.fi.se += INF; nmod(trans.fi.se, INF);\n\t\t\ttrans.se.se--; trans.se.se += BIG; nmod(trans.se.se, BIG);\n\t\t}\n\t\tpll dif = {(S.fi - trans.fi.se) * modinv(trans.fi.fi, INF), (S.se - trans.se.se) * modinv(trans.se.fi, BIG)};\n\t\tdif.fi %= INF; dif.fi += INF; nmod(dif.fi, INF);\n\t\tdif.se %= BIG; dif.se += BIG; nmod(dif.se, BIG);\n\t\tneed[dif.fi * BIG + dif.se]++;\n\t}\n\ttrans = MP(MP(1, 0), MP(1, 0));\n\tfor (int i = mid; i >= L; i--)\n\t{\n\t\tif (arr[i] == 0)\n\t\t{\n\t\t\ttrans.fi.fi *= INV.fi; trans.fi.fi %= INF;\n\t\t\ttrans.se.fi *= INV.se; trans.se.fi %= BIG;\n\t\t}\n\t\tif (arr[i] == 1)\n\t\t{\n\t\t\ttrans.fi.fi *= CO; trans.fi.fi %= INF;\n\t\t\ttrans.se.fi *= CO; trans.se.fi %= BIG;\n\t\t}\n\t\tif (arr[i] == 2)\n\t\t{\n\t\t\ttrans.fi.se += trans.fi.fi; nmod(trans.fi.se, INF);\n\t\t\ttrans.se.se += trans.se.fi; nmod(trans.se.se, BIG);\n\t\t}\n\t\tif (arr[i] == 3)\n\t\t{\n\t\t\ttrans.fi.se -= trans.fi.fi; trans.fi.se += INF; nmod(trans.fi.se, INF);\n\t\t\ttrans.se.se -= trans.se.fi;\ttrans.se.se += BIG; nmod(trans.se.se, BIG);\n\t\t}\n\t\tans += need[trans.fi.se * BIG + trans.se.se];\n\t}\n\tsolve(L, mid);\n\tsolve(mid + 1, R);\n}\n\nint32_t main()\n{\n\tios_base::sync_with_stdio(0);\n\t// cout << fixed << setprecision(10);\n\t// cerr << fixed << setprecision(10);\n\t// freopen (\"file.in\", \"r\", stdin);\n\t// freopen (\"file.out\", \"w\", stdout);\n\tcin >> N;\n\tstring temps;\n\tcin >> temps;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (temps[i] == '<')\n\t\t{\n\t\t\tarr[i] = 0;\n\t\t}\n\t\tif (temps[i] == '>')\n\t\t{\n\t\t\tarr[i] = 1;\n\t\t}\n\t\tif (temps[i] == '+')\n\t\t{\n\t\t\tarr[i] = 2;\n\t\t}\n\t\tif (temps[i] == '-')\n\t\t{\n\t\t\tarr[i] = 3;\n\t\t}\n\t}\n\treverse(arr, arr + N);\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (arr[i] == 0)\n\t\t{\n\t\t\tS.fi *= INV.fi; S.fi %= INF;\n\t\t\tS.se *= INV.se; S.se %= BIG;\n\t\t\t// cerr << \"times \" << INV << endl;\n\t\t}\n\t\tif (arr[i] == 1)\n\t\t{\n\t\t\tS.fi *= CO; S.fi %= INF;\n\t\t\tS.se *= CO; S.se %= BIG;\n\t\t\t// cerr << \"times \" << CO << endl;\n\t\t}\n\t\tif (arr[i] == 2)\n\t\t{\n\t\t\tS.fi++; nmod(S.fi, INF);\n\t\t\tS.se++; nmod(S.se, BIG);\n\t\t\t// cerr << \"add 1\\n\";\n\t\t}\n\t\tif (arr[i] == 3)\n\t\t{\n\t\t\tS.fi--; S.fi += INF; nmod(S.fi, INF);\n\t\t\tS.se--; S.se += BIG; nmod(S.se, BIG);\n\t\t\t// cerr << \"add -1\\n\";\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (arr[i] == 0)\n\t\t{\n\t\t\tif (S == MP(0ll, 0ll)) ans++;\n\t\t}\n\t\tif (arr[i] == 1)\n\t\t{\n\t\t\tif (S == MP(0ll, 0ll)) ans++;\n\t\t}\n\t\tif (arr[i] == 2)\n\t\t{\n\t\t\tif (S == MP(1ll, 1ll)) ans++;\n\t\t}\n\t\tif (arr[i] == 3)\n\t\t{\n\t\t\tif (S == MP((ll) INF - 1, (ll) BIG - 1)) ans++;\n\t\t}\n\t}\n\tsolve(0, N - 1);\n\tcout << ans << '\\n';\n\t//when u <, the # divides by co\n\t//when u >, the # mults by co\n\t//when u +, u add the #\n\t//when u -, u subtract the #\n\t// cerr << \"time elapsed = \" << (clock() / (CLOCKS_PER_SEC / 1000)) << \" ms\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <vector>\n\nconst int DEBUG = 0;\n\n#define MOCK 1\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define DEBUGP(val) cerr << #val << \"=\" << val << \"\\n\"\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\ntypedef pair<ll, ll> PL;\n\n\nll powmod(ll a, ll e, ll mod) {\n  ll sum = 1;\n  ll cur = a;\n  while (e > 0) {\n    if (e % 2) {\n      sum = sum * cur % mod;\n    }\n    cur = cur * cur % mod;\n    e /= 2;\n  }\n  return sum;\n}\n\nconst int A = 20;\n\nint main(void) {\n  const ll mod = 1e9 + 7;\n  const ll mod2 = 1e9 + 9;\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  string s;\n  cin >> n >> s;\n  int p = 0;\n  VI pos(n + 1);\n  mt19937 mt;\n  VL b(A);\n  ll mods[A] = {};\n  REP(i, 0, A) mods[i] = 1e9 + 7;\n  \n  REP(c, 0, A) {\n    do {\n      b[c] = mt() % mods[c];\n    } while (b[c] == 0);\n  }\n  vector<VL> hsh(A, VL(n + 1));\n  ll inv[A] = { 0 };\n  REP(c, 0, A) inv[c] = powmod(b[c], mods[c] - 2, mods[c]);\n  REP(c, 0, A) {\n    p = 0;\n    ll cur = 1;\n    REP(i, 0, n) {\n      ll tmp = hsh[c][i];\n      if (s[i] == '>') {\n        p++;\n        cur = cur * b[c] % mods[c];\n      }\n      if (s[i] == '<') {\n        p--;\n        cur = cur * inv[c] % mods[c];\n      }\n      if (s[i] == '+') {\n        tmp = (tmp + cur) % mods[c];\n      }\n      if (s[i] == '-') {\n        tmp = (tmp + mods[c] - cur) % mods[c];\n      }\n      hsh[c][i + 1] = tmp;\n      pos[i + 1] = p;\n    }\n  }\n  if (DEBUG) {\n    REP(i, 0, n + 1) {\n      cerr << i << \" \" << hsh[0][i] << endl;\n    }\n  }\n  VL meguru(A);\n  REP(c, 0, A) meguru[c] = hsh[c][n];\n  map<VL, int> kirika;\n  kirika[meguru] = 1;\n  ll tot = 0;\n  VL cur(A);\n  REP(c, 0, A) cur[c] = powmod(b[c], mods[c] - 1 + pos[n], mods[c]);\n  for (int i = n - 1; i >= 0; --i) {\n    if (DEBUG) {\n      DEBUGP(i);\n      DEBUGP(pos[i]);\n    }\n    if (pos[i + 1] - pos[i] == 1) {\n      REP(c, 0, A) cur[c] = cur[c] * inv[c] % mods[c];\n    }\n    else if (pos[i + 1] - pos[i] == -1) {\n      REP(c, 0, A) cur[c] = cur[c] * b[c] % mods[c];\n    }\n    VL ken(A);\n    REP(c, 0, A) ken[c] = (cur[c] * meguru[c] + hsh[c][i]) % mods[c];\n    tot += kirika[ken];\n    VL tt(A);\n    REP(c, 0, A) tt[c] = hsh[c][i];\n    kirika[tt] += 1;\n  }\n  cout << tot << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long LL;\n\n#ifdef BTK\n#define DEBUG if(1)\n#else\n#define CIN_ONLY if(1)\nstruct cww {cww() {CIN_ONLY{ios::sync_with_stdio(false); cin.tie(0);}}\n}star;\n#define DEBUG if(0)\n#endif\n\n#define ALL(v) (v).begin(),(v).end()\n#define REC(ret, ...) std::function<ret (__VA_ARGS__)>\ntemplate <typename T>inline bool chmin(T &l, T r){bool a = l>r; if (a)l = r; return a;}\ntemplate <typename T>inline bool chmax(T &l, T r){bool a = l<r; if (a)l = r; return a;}\ntemplate <typename T>istream& operator>>(istream &is, vector<T> &v){for (auto &it : v)is >> it;return is;}\n\nclass range {private: struct I { int x; int operator*() { return x; }bool operator!=(I& lhs) { return x<lhs.x; }void operator++() { ++x; } }; I i, n;public:range(int n) :i({ 0 }), n({ n }) {}range(int i, int n) :i({ i }), n({ n }) {}I& begin() { return i; }I& end() { return n; }};\n\nint N;\nstring S;\nusing H = unsigned long long;\nnamespace RollHash {\n\tconstexpr int RANGE = 2123456;\n\tconstexpr int MID = 512345;\n\tconstexpr int num = 2;\n\tstruct pH {\n\t\tH v[num];\n\t\tH& operator[](int i) {\n\t\t\treturn v[i];\n\t\t}\n\t};\n\tconstexpr H h[num] = { 1e9 + 7,1e9 + 9 };\n\tpH RS[RANGE];\n\tmap<pair<H, H>, LL> cnt;\n\tvoid init() {\n\t\tcnt.clear();\n\t\tfor (int i : range(num)) {\n\t\t\tRS[0][i] = 1;\n\t\t}\n\t\tfor (int i : range(1,RANGE)) {\n\t\t\tfor (int j : range(num)) {\n\t\t\t\tRS[i][j] = RS[i - 1][j] * h[j];\n\t\t\t}\n\t\t}\n\t}\n\tinline pH add(pH has, int pos) {\n\t\tfor (int i : range(num)) {\n\t\t\thas[i] += RS[MID + pos][i];\n\t\t}\n\t\treturn has;\n\t}\n\tinline pH sub(pH has, int pos) {\n\t\tfor (int i : range(num)) {\n\t\t\thas[i] -= RS[MID + pos][i];\n\t\t}\n\t\treturn has;\n\t}\n\tinline pH sub(pH l, pH r) {\n\t\tfor (int i : range(num)) {\n\t\t\tl[i] -= r[i];\n\t\t}\n\t\treturn l;\n\t}\n\n\tconstexpr int A = 512345;\n\tinline pH moveCenter(pH has, int nowCenter) {\n\t\tconst int movement = A - nowCenter;\n\t\tfor (int i : range(num)) {\n\t\t\thas[i] *= RS[movement][i];\n\t\t}\n\t\treturn has;\n\t}\n\tinline pH shift(pH has, int sft) {\n\t\tconst int movement = A +sft;\n\t\tfor (int i : range(num)) {\n\t\t\thas[i] *= RS[movement][i];\n\t\t}\n\t\treturn has;\n\t}\n\tinline void ins(pH has,int c) {\n\t\tcnt[{has[0], has[1]}] += c;\n\t}\n\tinline LL get(pH has) {\n\t\treturn cnt[{has[0], has[1]}];\n\t}\n}\nint main() {\n\tusing namespace RollHash;\n\twhile (cin >> N >> S) {\n\t\tinit();\n\t\tLL ret = 0;\n\n\t\tvector<pH> suf(N + 1);\n\t\tvector<int> sft(N + 1);\n\t\tsft[0] = 0;\n\t\tfor (int i : range(N)) {\n\t\t\tsft[i + 1] = sft[i];\n\t\t\tif (S[i] == '>')sft[i + 1]++;\n\t\t\tif (S[i] == '<')sft[i + 1]--;\n\t\t}\n\t\tpH now{ 0,0 };\n\t\tint center = 0;\n\t\tsuf[N] = shift(moveCenter(now, center), sft[N]);\n\t\tins(suf[N], 1);\n\t\tfor (int ri : range(N)) {\n\t\t\tconst int i = N - 1 - ri;\n\t\t\tif (S[i] == '+')now = add(now, center);\n\t\t\tif (S[i] == '-')now = sub(now, center);\n\t\t\tif (S[i] == '>')center--;\n\t\t\tif (S[i] == '<')center++;\n\t\t\tsuf[i]=shift(moveCenter(now, center),sft[i]);\n\t\t\tins(suf[i], 1);\n\t\t}\n\t\tnow = moveCenter(now, center);\n\t\tfor (int i : range(N)) {\n\t\t\tins(suf[i], -1);\n\t\t\tauto latte = suf[i];\n\t\t\tauto malta = shift(now, sft[i]);\n\t\t\tauto ei = sub(latte, malta);\n\t\t\tLL beet = get(ei);\n\t\t\tret += beet;\n\t\t}\n\n\t\tcout << ret << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<map>\n#include<iomanip>\n#define sqr(x) (x)*(x)\n#define fz1(i,n) for ((i)=1;(i)<=(n);(i)++)\n#define fd1(i,n) for ((i)=(n);(i)>=1;(i)--)\n#define fz0g(i,n) for ((i)=0;(i)<=(n);(i)++)\n#define fd0g(i,n) for ((i)=(n);(i)>=0;(i)--)\n#define fz0k(i,n) for ((i)=0;(i)<(n);(i)++)\n#define fd0k(i,n) for ((i)=(long long)((n)-1);(i)>=0;(i)--)\n#define fz(i,x,y) for ((i)=(x);(i)<=(y);(i)++)\n#define fd(i,y,x) for ((i)=(y);(i)>=(x);(i)--)\n#define ff(c,itr) for (__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n#define rdst(st,len){static char ss[len];scanf(\" %s\",ss);(st)=ss;}\n//#define T_ long long\nusing namespace std;\n//struct bit{T_ arr[1000005];int lowbit(int x){return x&(-x);}void add(int x,T_ y){for (int i=x;i<=n;i+=lowbit(i)) arr[i]+=y;}T_ query(int x){T_ s=0;for (int i=x;i>0;i-=lowbit(i)) s+=arr[i];return s;}};\n//struct seg{struct treedot{int l,r;T_ sum,add;void update(T_ x){sum+=(r-l+1)*x; add+=x;}}c[800005];void pushdown(int id){if (c[id].add){c[id*2].update(c[id].add);c[id*2+1].update(c[id].add);c[id].add=0;}}void pushup(int id){c[id].sum=c[id*2].sum+c[id*2+1].sum;}void build(int id,int l,int r){if (l>r) return;c[id].l=l;c[id].r=r;c[id].sum=0;c[id].add=0;if (l==r) c[id].sum=0;else{int mid=l+(r-l)/2;build(id*2,l,mid);build(id*2+1,mid+1,r);pushup(id);}}void update(int id,int le,int ri,T_ x){if (le>c[id].r||ri<c[id].l) return;if (le<=c[id].l&&c[id].r<=ri) c[id].update(x);else{pushdown(id);update(id*2,le,ri,x);update(id*2+1,le,ri,x);pushup(id);}}T_ query(int id,int le,int ri){if (ri<c[id].l||c[id].r<le) return 0;if (le<=c[id].l&&c[id].r<=ri) return c[id].sum;T_ ans=0;pushdown(id);ans+=query(id*2,le,ri);ans+=query(id*2+1,le,ri);pushup(id);return ans;}};\nlong long n,m,i,j,mod1=1e9+7,mod2=1e9+9,e=1e6+3,inv1,inv2,p1,p2,f1[250005],f2[250005],ans;\nstring st;\nmap<pair<long long,long long>,long long> mp;\nlong long qp(long long x,long long y,long long mod)\n{\n\tif (y==0) return 1;\n\tlong long z=qp(x,y/2,mod);\n\tz=z*z%mod;\n\tif (y&1) z=z*x%mod;\n\treturn z;\n}\nint main()\n{\n\tinv1=qp(e,mod1-2,mod1);\n\tinv2=qp(e,mod2-2,mod2);\n\tscanf(\"%lld\",&n);\n\trdst(st,250005);st=\" \"+st;\n\tp1=p2=1;\n\tfz1(i,n)\n\t{\n\t\tf1[i]=f1[i-1];f2[i]=f2[i-1];\n\t\tif (st[i]=='+')\n\t\t{\n\t\t\t(f1[i]+=p1)%=mod1;\n\t\t\t(f2[i]+=p2)%=mod2;\n\t\t}\n\t\tif (st[i]=='-')\n\t\t{\n\t\t\t(f1[i]+=mod1-p1)%=mod1;\n\t\t\t(f2[i]+=mod2-p2)%=mod2;\n\t\t}\n\t\tif (st[i]=='>')\n\t\t{\n\t\t\t(p1*=e)%=mod1;\n\t\t\t(p2*=e)%=mod2;\n\t\t}\n\t\tif (st[i]=='<')\n\t\t{\n\t\t\t(p1*=inv1)%=mod1;\n\t\t\t(p2*=inv2)%=mod2;\n\t\t}\n\t\tmp[make_pair(f1[i],f2[i])]++;\n\t}\n\tp1=p2=1;\n\tfz1(i,n)\n\t{\n\t\tans+=mp[make_pair((f1[n]*p1+f1[i-1])%mod1,(f2[n]*p2+f2[i-1])%mod2)];\n\t\tif (st[i]=='>')\n\t\t{\n\t\t\t(p1*=e)%=mod1;\n\t\t\t(p2*=e)%=mod2;\n\t\t}\n\t\tif (st[i]=='<')\n\t\t{\n\t\t\t(p1*=inv1)%=mod1;\n\t\t\t(p2*=inv2)%=mod2;\n\t\t}\n\t\tmp[make_pair(f1[i],f2[i])]--;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ull unsigned long long\n#define key 10000007\n#define ny 4822318634684403511\n#define k 9223372036854775807\nusing namespace std;\nint n;\nchar s[250010];\nmap <ull, ull> M;\ninline ull power(ull x, ull y)\n{\n\tull Ans = 1;\n\twhile(y)\n\t{\n\t\tif(y & 1)\n\t\t\tAns *= x;\n\t\ty >>= 1;\n\t\tx *= x;\n\t}\n\treturn Ans;\n}\nmap <ull, ull> P;\nint main()\n{\n\tscanf(\"%d%s\", &n, s);\n\tull w = 0;\n\tull p = 0;\n\tfor(int i = 0; i < n; ++ i)\n\t{\n\t\tif(s[i] == '+')\n\t\t\t++ P[p];\n\t\telse if(s[i] == '-')\n\t\t\t-- P[p];\n\t\telse if(s[i] == '>')\n\t\t\t++ p;\n\t\telse -- p;\n\t}\n\tfor(int i = - n; i < 0; ++ i)\n\t\tw += power(ny, - i) * P[i];\n\tfor(int i = 0; i <= n; ++ i)\n\t\tw += power(key, i) * P[i];\n\tull a = 1, b = 0;\n\tull Ans = 0;\n\tfor(int i = n - 1; i >= 0; -- i)\n\t{\n\t\t++ M[-b * power(a, k)];\n\t\tif(s[i] == '+')\n\t\t\t++ b;\n\t\telse if(s[i] == '-')\n\t\t\t-- b;\n\t\telse if(s[i] == '>')\n\t\t\ta *= key, b *= key;\n\t\telse if(s[i] == '<')\n\t\t\ta *= ny, b *= ny;\n\t\tAns += M[(w - b) * power(a, k)];\n\t}\n\tprintf(\"%d\", Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=3e5+5,mod1=998244353,mod2=1000000007,mod3=2333;\nint n,x=799633,invx1,invx2,invx3;\nll sum1=1,sum2=1,sum3=1;\nll s1[N],s2[N],s3[N];\nchar s[N];\nll inv(ll x,ll mod){return x==1?x:(mod-mod/x)*inv(mod%x,mod)%mod;}\nstruct node\n{\n    ll s1,s2,s3;\n    node(ll s1=0,ll s2=0,ll s3=0):s1(s1),s2(s2),s3(s3){}\n    void add()\n    { s1=(s1+sum1)%mod1;s2=(s2+sum2)%mod2;s3=(s3+sum3)%mod3;}\n    void sub()\n    { s1=(s1+mod1-sum1)%mod1;s2=(s2+mod2-sum2)%mod2;s3=(s3+mod3-sum3)%mod3;}\n    bool operator<(const node&o)const\n    {\n        if(s1==o.s1&&s2==o.s2) return s3<o.s3;\n        if(s1==o.s1) return s2<o.s2;\n        return s1<o.s1;\n    }\n};\nvoid div()\n{\n    sum1=sum1*invx1%mod1;\n    sum2=sum2*invx2%mod2;\n    sum3=sum3*invx3%mod3;\n}\nvoid mul()\n{\n    sum1=sum1*x%mod1;\n    sum2=sum2*x%mod2;\n    sum3=sum3*x%mod3;\n}\nnode f[N];\nmap<node,int>mp;\nint main()\n{\n    invx1=inv(x%mod1,mod1);\n    invx2=inv(x%mod2,mod2);\n    invx3=inv(x%mod3,mod3);\n    scanf(\"%d\",&n);\n    scanf(\"%s\",s+1);\n    for(int i=1;i<=n;i++)\n    {\n        f[i]=f[i-1];\n        if(s[i]=='>') div();\n        if(s[i]=='<') mul();\n        if(s[i]=='+') f[i].add();\n        if(s[i]=='-') f[i].sub();\n        mp[f[i]]++;\n    }\n    sum1=sum2=sum3=1;\n    node now;\n    ll ans=0;\n    for(int i=1;i<=n;i++)\n    {\n        node p=now;\n        p.s1=(p.s1+f[n].s1*sum1)%mod1;\n        p.s2=(p.s2+f[n].s2*sum2)%mod2;\n        p.s3=(p.s3+f[n].s3*sum3)%mod3;\n        ans+=mp[p];\n        mp[f[i]]--;\n        if(s[i]=='>') div();\n        if(s[i]=='<') mul();\n        if(s[i]=='+') now.add();\n        if(s[i]=='-') now.sub();\n    }\n    printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <assert.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n#define PB push_back\n#define MP make_pair\n#define MOD 1000000007LL\n#define endl \"\\n\"\n#define fst first\n#define snd second\nconst ll UNDEF = -1;\nconst ll INF=1e18;\ntemplate<typename T> inline bool chkmax(T &aa, T bb) { return aa < bb ? aa = bb, true : false; }\ntemplate<typename T> inline bool chkmin(T &aa, T bb) { return aa > bb ? aa = bb, true : false; }\ntypedef pair<ll,ll> pll;\ntypedef vector<ll> vll;\ntypedef unsigned long long ull;\nconst int mn=250001;\nint n;\nchar a[mn];\n// http://www.wolframalpha.com/input/?i=NextPrime%5B4294967296,-2%5D\nconst unsigned int P[]={4294967291U,4294967279U};\nconst unsigned int B[]={500009,500029};\nconst int PN=2;\nconst int MAXPOW=2*mn;\nunsigned int basepow[PN][MAXPOW];\nvoid init() {\n\tfor (int t=0;t<PN;t++) {\n\t\tunsigned int b=B[t],p=P[t];\n\t\tunsigned int now=1;\n\t\tfor (int i=0;i<MAXPOW;i++) {\n\t\t\tbasepow[t][i]=now;\n\t\t\tnow=(now*(unsigned long long)b)%p;\n\t\t}\n\t}\n}\n\nmap<ull,vector<int> > h;\n\nint vpos[mn];\n\n\nint bins(vector<int> &v, int key) {\n  int imin=0,imax=v.size();\n  while(imin<imax) {\n    int imid=(imin+imax)>>1;\n    if (v[imid]<key) imin=imid+1;\n    else imax=imid;\n  }\n  return imin; \n}\n\nint main(){\t\n\tios_base::sync_with_stdio(false); cin.tie(0);\n\tscanf(\"%d\\n%s\\n\",&n,a);\n\t{\n\t\tint pos=mn;\n\t\tfor (int i=0;i<n;i++) {\n\t\t\tif (a[i]=='<') --pos;\n\t\t\telse if (a[i]=='>') ++pos;\n\t\t\tvpos[i]=pos;\n\t\t}\n\t}\n\n\t{\n\t\tunsigned int vsig[2]; vsig[0]=vsig[1]=0;\n\t\th[0].PB(-1);\n\t\tfor (int i=0;i<n;i++) {\n\t\t\tint pos=vpos[i];\n\t\t\tif (a[i]=='+') {\n\t\t\t\tfor (int t=0;t<PN;t++) vsig[t]+=basepow[t][pos];\n\t\t\t}\n\t\t\telse if (a[i]=='-') {\n\t\t\t\tfor (int t=0;t<PN;t++) vsig[t]-=basepow[t][pos];\n\t\t\t}\n\t\t\tull sig=((ull)vsig[0]<<32)|vsig[1];\n\t\t\th[sig].PB(i);\n\t\t}\n\t}\n\n\tfor (auto &w:h) {\n\t\tsort(w.snd.begin(),w.snd.end());\n\t}\n\n\tll ans=0;\n\tans+=bins(h[0],n-2);\n\t{\n\t\tunsigned int vsig[2]; vsig[0]=vsig[1]=0;\n\t\tfor (int i=n-1;i>=0;i--) {\n\t\t\tint pos=vpos[i];\n\t\t\tif (a[i]=='+') {\n\t\t\t\tfor (int t=0;t<PN;t++) vsig[t]+=basepow[t][pos];\n\t\t\t}\n\t\t\telse if (a[i]=='-') {\n\t\t\t\tfor (int t=0;t<PN;t++) vsig[t]-=basepow[t][pos];\n\t\t\t}\n\t\t\tull sig=((ull)vsig[0]<<32)|vsig[1];\n\t\t\tint got=bins(h[sig],i-2);\n\t\t\tans+=got;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef unsigned long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nll mod, modInv;\nll pw(ll n, ll m){\n\tll res = 1;\n\tfor(; m; m /= 2){\n\t\tif(m & 1) res = res * n;\n\t\tn = n * n;\n\t}\n\treturn res;\n}\nll h_[510000], *h = h_ + 255000;\n\nvoid init(int n, ll mod_){\n\tmod = mod_;\n\tmodInv = pw(mod, -1);\n\th[0] = 1;\n\tll x = 1, y = 1;\n\tfor(int i = 1; i <= n; i++){\n\t\tx *= mod;\n\t\ty *= modInv;\n\t\th[i] = x;\n\t\th[-i] = y;\n\t}\n}\n\nll solve(int n, string s, ll mod){\n\tinit(n, mod);\n\tint p = 0;\n\tll hash = 0;\n\tfor(char c : s){\n\t\tif(c == '<') p--;\n\t\tif(c == '>') p++;\n\t\tif(c == '+') hash += h[p];\n\t\tif(c == '-') hash -= h[p];\n\t}\n\t\n\tint p2 = p;\n\tll h2 = 0;\n\tmap<ll, vi> pos;\n\tfor(int i = n; i >= 0; i--){\n\t\tif(i < n){\n\t\t\tchar c = s[i];\n\t\t\tif(c == '<') p2++;\n\t\t\tif(c == '>') p2--;\n\t\t\tif(c == '+') h2 -= h[p2];\n\t\t\tif(c == '-') h2 += h[p2];\n\t\t}\n\t\tpos[h2].pb(i);\n\t}\n\tfor(auto &i: pos) reverse(all(i.second));\n\t\n\tint p3 = p;\n\tll h3 = hash;\n\tll ans = 0;\n\trep(i, n){\n\t\tll diff = (hash - h3) * h[p - p3];\n\t\tif(pos.count(diff)){\n\t\t\tans += pos[diff].end() - upper_bound(all(pos[diff]), i);\n\t\t}\n\t\t\n\t\tchar c = s[i];\n\t\tif(c == '<') p3++, h3 *= mod;\n\t\tif(c == '>') p3--, h3 *= modInv;\n\t\tif(c == '+') h3--;\n\t\tif(c == '-') h3++;\n\t}\n\treturn ans;\n}\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\t\n\tint n; string s; cin >> n >> s; assert(n > 5);\n\tmap<ll,int> ans;\n\tvector<ll> mods;\n\tfor(ll p = 1e9 + 1; mods.size() < 5; p += 2){\n\t\tfor(ll i = 3; i * i <= p; i += 2) if(p % i == 0) goto NG;\n\t\tmods.pb(p); NG:;\n\t}\n\tfor(ll mod : mods) ++ans[solve(n, s, mod)];\n\t\n\tint mxc = 0; ll res = 0;\n\tfor(auto i : ans) if(i.second > mxc) mxc = i.second, res = i.first;\n\tcout << res << endl;\n\t\n\t//dbg(ans, mods);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fo(a,b,c) for (a=b; a<=c; a++)\n#define fd(a,b,c) for (a=b; a>=c; a--)\n#define mod 1000000007\n#define Mod 1000000005\n#define ll long long\n//#define file\nusing namespace std;\n\nll p[250001],P[250001],hs[250001],s,p1,p2,ans;\nint sum[250001],n,i,j,k,l;\nchar st[250001];\nmap<int,int> mp;\n\nll qpower(ll a,int b) {ll ans=1; while (b) {if (b&1) ans=ans*a%mod;a=a*a%mod;b>>=1;} return ans;}\nll Pow(int t) {return (t>=0)?p[t]:P[-t];}\n\nint main()\n{\n\t#ifdef file\n\tfreopen(\"arc099f.in\",\"r\",stdin);\n\t#endif\n\t\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",st+1);\n\tp1=n+1,p2=qpower(n+1,Mod);\n\tp[0]=P[0]=1;\n\tfo(i,1,n) p[i]=p[i-1]*p1%mod,P[i]=P[i-1]*p2%mod;\n\t\n\tfd(i,n,1)\n\t{\n\t\tswitch (st[i])\n\t\t{\n\t\t\tcase '>':{sum[i]=1,s=s*p1%mod;break;}\n\t\t\tcase '<':{sum[i]=-1,s=s*p2%mod;break;}\n\t\t\tcase '+':{s=(s+1)%mod;break;}\n\t\t\tcase '-':{s=(s-1)%mod;break;}\n\t\t}\n\t\ts=(s+mod)%mod;\n\t\ths[i]=s;\n\t}\n\tfo(i,1,n) sum[i]+=sum[i-1];\n\t\n\tmp[0]=1;\n\tfd(i,n,1)\n\t{\n\t\ts=((hs[i]-hs[1])*Pow(sum[i-1])%mod+mod)%mod;\n\t\tans+=mp[s];\n\t\t++mp[hs[i]*Pow(sum[i-1])%mod];\n\t}\n\tprintf(\"%lld\\n\",ans);\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int, int> pii;\n\nconst int MAXN = 3e5 + 5;\nconst int BASE = 3137;\nconst int MOD1 = 1e9 + 7;\nconst int MOD2 = 1e9 + 9;\n\nint N;\nchar s[MAXN];\npii pref[MAXN], pot[MAXN];\nmap <pii, int> cnt;\n\nvoid load() {\n\tscanf(\"%d%s\", &N, s + 1);\n}\n\ninline int add(int x, int y, int mod) {\n\tx += y;\n\tif (x >= mod)\n\t\tx -= mod;\n\telse if (x < 0)\n\t\tx += mod;\n\treturn x;\n}\n\ninline int mul(int x, int y, int mod) {\n\treturn (ll)x * y % mod;\n}\n\nint power(int x, int y, int mod) {\n\tint res = 1;\n\tfor (; y; y /= 2) {\n\t\tif (y % 2)\n\t\t\tres = mul(res, x, mod);\n\t\tx = mul(x, x, mod);\n\t}\n\treturn res;\n}\n\npii operator +(const pii &l, const pii &r) {\n\treturn {add(l.first, r.first, MOD1), add(l.second, r.second, MOD2)};\n}\n\npii operator *(const pii &l, const pii &r) {\n\treturn {mul(l.first, r.first, MOD1), mul(l.second, r.second, MOD2)};\n}\n\nll solve() {\n\tint inv1 = power(BASE, MOD1 - 2, MOD1);\n\tint inv2 = power(BASE, MOD2 - 2, MOD2);\n\tpot[0] = {1, 1};\n\tfor (int i = 1; i <= N; i++) {\n\t\tpot[i] = pot[i - 1];\n\t\tpref[i] = pref[i - 1];\n\t\tif (s[i] == '>')\n\t\t\tpot[i] = pot[i] * pii(BASE, BASE);\n\t\telse if (s[i] == '<')\n\t\t\tpot[i] = pot[i] * pii(inv1, inv2);\n\t\telse if (s[i] == '+') \n\t\t\tpref[i] = pref[i] + pot[i];\n\t\telse \n\t\t\tpref[i] = pref[i] + pii(-pot[i].first, -pot[i].second);\n\t}\n\t\n\tll ans = 0;\n\tfor (int i = N; i; i--) {\n\t\tcnt[pref[i]]++;\n\t\tans += cnt[(pref[N] * pot[i - 1]) + pref[i - 1]];\n\t}\n\t\n\treturn ans;\n}\n\nint main() {\n\tload();\n\tprintf(\"%lld\\n\", solve());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\n//const ll mod = 1000000087;\n//const ll INF = mod * mod;\ntypedef pair<int, int>P;\ntypedef pair<int, bool> sP;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef pair<ll, ll> LP;\ntypedef vector<ll> vec;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef vector<vector<ll>> mat;\ntypedef vector<ll> vec;\n\n\n\nvector<ll> mods;\nvector<ll> roots;\n\nbool isp(ll x) {\n\tRep1(i,2, 100000) {\n\t\tif (x%i == 0)return false;\n\t}\n\treturn true;\n}\nvoid genmods() {\n\tll sta = 1000010000;\n\twhile (mods.size() < 3) {\n\t\tif (isp(sta))mods.push_back(sta);\n\t\tsta++;\n\t}\n}\nvoid genroots() {\n\tll sta = 2000010000;\n\twhile (roots.size() < 2) {\n\t\tif (isp(sta))roots.push_back(sta);\n\t\tsta++;\n\t}\n}\nll mod_pow(ll x, ll n,ll mod) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n % 2)res = res * x%mod;\n\t\tx = x * x%mod; n >>= 1;\n\t}\n\treturn res;\n}\nvector<ll> invroots;\n\nvector<ll> tr[300000];\nvector<ll> invtr[300000];\nvoid init() {\n\tgenmods();\n\tgenroots();\n\trep(i, 300000) {\n\t\ttr[i].resize(mods.size()*roots.size());\n\t\tinvtr[i].resize(mods.size()*roots.size());\n\t}\n\trep(j, tr[0].size()) {\n\t\ttr[0][j] = invtr[0][j] = 1;\n\t}\n\trep(j, mods.size()) {\n\t\trep(k, roots.size()) {\n\t\t\tinvroots.push_back(mod_pow(roots[k], mods[j] - 2, mods[j]));\n\t\t}\n\t}\n\trep(i, 299999) {\n\t\trep(j, mods.size()) {\n\t\t\trep(k, roots.size()) {\n\t\t\t\tint id = j * roots.size() + k;\n\t\t\t\ttr[i + 1][id] = tr[i][id] * roots[k] % mods[j];\n\t\t\t\tinvtr[i + 1][id] = invtr[i][id] * invroots[id] % mods[j];\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve() {\n\tint n; cin >> n;\n\tstring s; cin >> s;\n\tvector<ll> sum(mods.size()*roots.size(),0); int loc = 0;\n\tvector<vector<ll>> memo(n);\n\trep(i, n)memo[i].resize(mods.size()*roots.size());\n\tvector<int> locs(n);\n\tint len = roots.size()*mods.size();\n\trep(i, n) {\n\t\tif (s[i] == '>')loc++;\n\t\telse if (s[i] == '<')loc--;\n\t\telse if (s[i] == '+') {\n\t\t\tif (loc >= 0) {\n\t\t\t\trep(j, len) {\n\t\t\t\t\tsum[j] += tr[loc][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\trep(j, len) {\n\t\t\t\t\tsum[j] += invtr[-loc][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (loc >= 0) {\n\t\t\t\trep(j, len) {\n\t\t\t\t\tsum[j] -= tr[loc][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\trep(j, len) {\n\t\t\t\t\tsum[j] -= invtr[-loc][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(j, len) {\n\t\t\tll mod = mods[j / roots.size()];\n\t\t\tif (sum[j] < 0)sum[j] += mod;\n\t\t\tif (sum[j] >= mod)sum[j] -= mod;\n\t\t\tmemo[i][j] = sum[j];\n\t\t}\n\n\t\tlocs[i] = loc;\n\t}\n\tvector<ll> alls = sum;\n\tll ans = 0;\n\tvector<map<ll, int>> mp(len);\n\trep(i, len) {\n\t\tmp[i][alls[i]]++;\n\t}\n\trep(i, n) {\n\t\t//cout << mp[memo[i]] << endl;\n\t\tint mi = 2*n;\n\t\trep(j, len) {\n\t\t\tmi = min(mi, mp[j][memo[i][j]]);\n\t\t}\n\t\tans += mi;\n\t\tbool valid = true;\n\t\t\n\t\trep(j, len) {\n\t\t\tll nex = alls[j];\n\t\t\tll mod = mods[j / roots.size()];\n\t\t\tif (locs[i] >= 0) {\n\t\t\t\tnex = nex * tr[locs[i]][j] % mod;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnex = nex * invtr[-locs[i]][j] % mod;\n\t\t\t}\n\t\t\tnex += memo[i][j];\n\t\t\tif (nex >= mod)nex -= mod;\n\t\t\tmp[j][nex]++;\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(7);\n\tinit();\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ri register int\ntypedef long long ll;\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char y) {\n\t\t*oS ++ = y;\n\t\tif (oS == oT) flush ();\n\t}\n\t// input a signed integer\n\ttemplate <class I>\n\tinline void gi (I &y) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (y = 0; c <= '9' && c >= '0'; c = gc()) y = (y << 1) + (y << 3) + (c & 15); y *= f;\n\t}\n\t// print a signed integer\n\ttemplate <class I>\n\tinline void print (I y) {\n\t\tif (!y) putc ('0'); if (y < 0) putc ('-'), y = -y;\n\t\twhile (y) qu[++ qr] = y % 10 + '0',  y /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t}\n\t// no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n} \nusing io :: gi;\nusing io :: putc;\nusing io :: print;\nconst int N=25e4+5,mod=1e9+7;\nchar s[N];\nint x[6],power[6][N],xinv[6],powerinv[6][N];\ninline void add(int &x,ri y){\n\tx=(x+=y)>=mod?x-mod:x;\n}\ninline void del(int &x,ri y){\n\tx=(x-=y)<0?x+mod:x;\n}\nstruct node{\n\tint y[6];\n\tinline bool operator <(const node &rhs)const{\n\t\tfor(ri i=0;i^6;++i)\n\t\t\tif(y[i]!=rhs.y[i])\n\t\t\t\treturn y[i]<rhs.y[i];\n\t\treturn 0;\n\t}\n\tinline void upd(ri p,ri k){\n\t\tri i;\n\t\tif(p>=0){\n\t\t\tif(k==1){\n\t\t\t\tfor(i=0;i^6;++i)\n\t\t\t\t\tadd(y[i],power[i][p]);\n\t\t\t} \n\t\t\telse{\n\t\t\t\tfor(i=0;i^6;++i)\n\t\t\t\t\tdel(y[i],power[i][p]);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(k==1){\n\t\t\t\tfor(i=0;i^6;++i)\n\t\t\t\t\tadd(y[i],powerinv[i][-p]);\n\t\t\t} \n\t\t\telse{\n\t\t\t\tfor(i=0;i^6;++i)\n\t\t\t\t\tdel(y[i],powerinv[i][-p]);\n\t\t\t}\n\t\t}\n\t}\n}res,res0,now;\nstruct orz{\n\tint k,b;\n\tinline void operator +=(const int &rhs){\n\t\tadd(b,1);\n\t}\n\tinline void operator -=(const int &rhs){\n\t\tdel(b,1);\n\t}\n\tinline void operator *=(const int &rhs){\n\t\tk=(ll)k*rhs%mod;\n\t\tb=(ll)b*rhs%mod;\n\t}\n};\nstruct poly{\n\torz f[6];\n\tinline void upd1(){\n\t\tfor(ri i=0;i^6;++i)\n\t\t\tf[i]-=1;\n\t}\n\tinline void upd2(){\n\t\tfor(ri i=0;i^6;++i)\n\t\t\tf[i]+=1;\n\t}\n\tinline void upd3(){\n\t\tfor(ri i=0;i^6;++i)\n\t\t\tf[i]*=xinv[i];\n\t}\n\tinline void upd4(){\n\t\tfor(ri i=0;i^6;++i)\n\t\t\tf[i]*=x[i];\n\t}\n}resinv;\nmap<node,int> G;\ninline int fpow(ri a,ri b){\n\tri ans=1;\n\tfor(;b;b>>=1,a=(ll)a*a%mod)\n\t\tif(b&1) ans=(ll)ans*a%mod;\n\treturn ans;\n}\nint main(){\n\tsrand(size_t(new char));\n\tri n,i,j,nowp;\n\tregister ll ans;\n\tscanf(\"%d%s\",&n,s+1);\n\tfor(i=0;i^6;++i){\n\t\tx[i]=rand()%(mod-1)+1; // linux \n\t\tpower[i][0]=1;\n\t\tfor(j=1;j<=n;++j)\n\t\t\tpower[i][j]=(ll)power[i][j-1]*x[i]%mod;\n\t\txinv[i]=fpow(x[i],mod-2);\n\t\tpowerinv[i][0]=1;\n\t\tfor(j=1;j<=n;++j)\n\t\t\tpowerinv[i][j]=(ll)powerinv[i][j-1]*xinv[i]%mod;\n\t}\n\tnowp=0;\n\tfor(i=1;i<=n;++i)\n\t\tif(s[i]=='+')\n\t\t\tres0.upd(nowp,1);\n\t\telse if(s[i]=='-')\n\t\t\tres0.upd(nowp,-1);\n\t\telse if(s[i]=='>')\n\t\t\t++nowp;\n\t\telse\n\t\t\t--nowp;\n\tnowp=0;\n\tans=0;\n\tfor(i=0;i^6;++i) resinv.f[i].k=1;\n\t++G[res0];\n\tfor(i=1;i<=n;++i){\n\t\tif(s[i]=='+')\n\t\t\tres.upd(nowp,1),\n\t\t\tresinv.upd1();\n\t\telse if(s[i]=='-')\n\t\t\tres.upd(nowp,-1),\n\t\t\tresinv.upd2();\n\t\telse if(s[i]=='>')\n\t\t\t++nowp,\n\t\t\tresinv.upd3();\n\t\telse\n\t\t\t--nowp,\n\t\t\tresinv.upd4();\n\t\tans+=G[res];\n\t\tfor(j=0;j^6;++j)\n\t\t\tnow.y[j]=(ll)(res0.y[j]-resinv.f[j].b+mod)*fpow(resinv.f[j].k,mod-2)%mod;\n\t\t++G[now];\n\t}\n\tprint(ans);putc('\\n');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN=250000;\nconst int HMOD=1000000007;\nconst int NHASH=10;\nint HMLT[NHASH];\nint HINV[NHASH];\nstruct Op { int a[NHASH],b[NHASH]; };\nint pw(int x,int n) { int ret=1; while(true) { if(n&1) ret=(ll)ret*x%HMOD; if((n>>=1)==0) return ret; x=(ll)x*x%HMOD; } }\n\nOp combine(const Op &p,const Op &q) { Op ret; REP(i,NHASH) { ret.a[i]=(ll)p.a[i]*q.a[i]%HMOD; ret.b[i]=((ll)p.a[i]*q.b[i]+p.b[i])%HMOD; } return ret; }\nvoid eval(const Op &p,const int q[NHASH],int ret[NHASH]) { REP(i,NHASH) ret[i]=((ll)p.a[i]*q[i]+p.b[i])%HMOD; }\n\nint n; char s[MAXN+1];\n\nOp opid;\nOp opgt,iopgt;\nOp oplt,ioplt;\nOp oppl,ioppl;\nOp opmn,iopmn;\nOp f[MAXN];\nOp g[MAXN];\n\nOp ff[MAXN+1]; // ff[i] is composition of f for suffix starting at i\nOp gg[MAXN+1]; // gg[i] is composition of g for suffix starting at i\n\nint id[NHASH];\nint fx[NHASH];\nint gx[MAXN+1][NHASH];\nint hx[MAXN+1][NHASH];\n\nmap<vector<int>,int> mp;\n\nvoid run() {\n\tscanf(\"%d%s\",&n,s);\n\n\tREP(i,n) switch(s[i]) {\n\t\tcase '>': f[i]=opgt,g[i]=iopgt; break;\n\t\tcase '<': f[i]=oplt,g[i]=ioplt; break;\n\t\tcase '+': f[i]=oppl,g[i]=ioppl; break;\n\t\tcase '-': f[i]=opmn,g[i]=iopmn; break;\n\t\tdefault: assert(false);\n\t}\n\n\tff[n]=opid; for(int i=n-1;i>=0;--i) ff[i]=combine(f[i],ff[i+1]);\n\tgg[n]=opid; for(int i=n-1;i>=0;--i) gg[i]=combine(gg[i+1],g[i]);\n\t\n\tmemset(id,0,sizeof(id));\n\teval(ff[0],id,fx);\n\tREPE(i,n) eval(gg[i],id,gx[i]);\n\tREPE(i,n) eval(gg[i],fx,hx[i]);\n\n\t//printf(\"fx:\"); printf(\" %d\\n\",fx[0]);\n\t//printf(\"gx:\"); REPE(i,n) printf(\" %10d\",gx[i][0]); puts(\"\");\n\t//printf(\"hx:\"); REPE(i,n) printf(\" %10d\",hx[i][0]); puts(\"\");\n\n\tll ret=0;\n\tfor(int i=n;i>=0;--i) {\n\t\tvector<int> vg(NHASH),vh(NHASH); REP(j,NHASH) vg[j]=gx[i][j],vh[j]=hx[i][j];\n\t\tret+=mp[vh]; ++mp[vg];\n\t}\n\tprintf(\"%lld\\n\",ret);\n}\n\nvoid init() {\n\tREP(i,NHASH) { int x=0; REP(j,100) x=((ll)x*1000+rand()%1000)%HMOD; HMLT[i]=x; HINV[i]=pw(x,HMOD-2); }\n\t//printf(\"HMLT:\"); REP(i,NHASH) printf(\" %d\",HMLT[i]); puts(\"\");\n\tREP(i,NHASH) {\n\t\topid.a[i]=1,opid.b[i]=0;\n\t\topgt.a[i]=HMLT[i],opgt.b[i]=0;\n\t\toplt.a[i]=HINV[i],oplt.b[i]=0;\n\t\toppl.a[i]=1,oppl.b[i]=1;\n\t\topmn.a[i]=1,opmn.b[i]=HMOD-1;\n\t\tiopgt=oplt,ioplt=opgt,ioppl=opmn,iopmn=oppl;\n\t}\n}\n\nint main() {\n\tinit();\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "    #include<map>\n    #include<cstdio>\n    #include<cstdlib>\n    #include<cstring>\n    #include<iostream>\n    #define LLu unsigned long long\n    using namespace std;\n    char s[250010];\n    LLu base=233,inv=7204522363551799129,f[250010],X=1,Y,ans=0;\n    int n;\n    map<LLu,int> mp;\n    int main()\n    {\n    \tscanf(\"%d\",&n);getchar();\n    \tscanf(\"%s\",s+1);\n    \tfor(int i=1;i<=n;i++)\n    \t{\n    \t\tf[i]=f[i-1];\n    \t\tif(s[i]=='+') f[i]+=X;\n    \t\tif(s[i]=='-') f[i]-=X;\n    \t\tif(s[i]=='<') X*=base;\n    \t\tif(s[i]=='>') X*=inv;\n    \t\tmp[f[i]]++;\n    \t}\n    \tX=1;\n    \tfor(int i=1;i<=n;i++)\n    \t{\n    \t\tans+=mp[f[n]*X+Y];\n    \t\tif(s[i]=='+') Y+=X;\n    \t\tif(s[i]=='-') Y-=X;\n    \t\tif(s[i]=='<') X*=base;\n    \t\tif(s[i]=='>') X*=inv;\n    \t\tmp[f[i]]--;\n    \t}\n    \tprintf(\"%llu\",ans);\n    }"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define X first\n#define Y second\n#define mp make_pair\n#define pb push_back\n#define il inline\n#define rg register\n#define lch(x) ((x)<<1)\n#define rch(x) ((x)<<1^1)\n#define rep(i,st,ed) for(rg int i=(st);i<=(ed);++i)\n#define per(i,ed,st) for(rg int i=(ed);i>=(st);--i)\n#define rep0(i,n) for(rg int i=0;i<(n);++i)\n#define per0(i,n) for(rg int i=(n)-1;i>=0;--i)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int uint;\ntypedef double dbl;\ntypedef long double ldb;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<typename T> il T qmin(const T &x,const T &y){return x<y?x:y;}\ntemplate<typename T> il T qmax(const T &x,const T &y){return x>y?x:y;}\ntemplate<typename T> il void getmin(T &x,const T &y){if(y<x) x=y;}\ntemplate<typename T> il void getmax(T &x,const T &y){if(y>x) x=y;}\nil void fileio(const string &s){\n\tfreopen((s+\".in\").c_str(),\"r\",stdin);\n\tfreopen((s+\".out\").c_str(),\"w\",stdout);\n}\n\nconst int inf=(int)1e9+7;\nconst ll linf=(ll)1e18+7;\nconst ull base=(ull)1e8+7,inv=5840524504965430455ull;\nconst int N=500005;\n\nchar s[N];\null pw[N],pwi[N];\nmap<ull,int> tot;\nint a[N],pos[N];\null val[N];\nint n;\n\nint main(){\n\tassert(base*inv==1);\n\tpw[0]=pwi[0]=1;\n\trep(i,1,N-1){\n\t\tpw[i]=pw[i-1]*base;\n\t\tpwi[i]=pwi[i-1]*inv;\n\t\tassert(pw[i]*pwi[i]==1);\n\t}\n//\tfileio(\"test\");\n\tscanf(\"%d%s\",&n,s+1);\n\tint st=250001,cur=st;\n\trep(i,1,n){\n\t\tif(s[i]=='<') --cur;\n\t\telse if(s[i]=='>') ++cur;\n\t\telse if(s[i]=='+') ++a[cur];\n\t\telse if(s[i]=='-') --a[cur];\n\t\telse assert(false);\n\t\tpos[i]=cur;\n\t}\n\tull des=0;\n\trep0(i,N) des+=a[i]*pw[i];\n\t++tot[0];\n\tper(i,n,1){\n\t\tval[i]=val[i+1];\n\t\tif(s[i]=='-') val[i]-=pw[pos[i]];\n\t\telse if(s[i]=='+') val[i]+=pw[pos[i]];\n\t\t++tot[val[i]];\n\t}\n\t--tot[val[1]];\n\tll ans=tot[0];\n//\tcerr<<0<<\" \"<<tot[0]<<endl;\n\tull sta=des;\n\trep(i,1,n){\n\t\t--tot[val[i+1]];\n\t\tif(s[i]=='-') sta+=pw[pos[i]];\n\t\telse if(s[i]=='+') sta-=pw[pos[i]];\n\t//\tcerr<<sta<<endl;\n\t\tans+=tot[sta-des*(pos[i]>=st?pw[pos[i]-st]:pwi[st-pos[i]])];\n\t//\tcerr<<i<<\" \"<<tot[sta-des*(pos[i]>=st?pw[pos[i]-st]:pwi[st-pos[i]])]<<endl;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//teja349\n#include <bits/stdc++.h>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <utility>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <iomanip> \n//setbase - cout << setbase (16); cout << 100 << endl; Prints 64\n//setfill -   cout << setfill ('x') << setw (5); cout << 77 << endl; prints xxx77\n//setprecision - cout << setprecision (14) << f << endl; Prints x.xxxx\n//cout.precision(x)  cout<<fixed<<val;  // prints x digits after decimal in val\n\nusing namespace std;\n#define f(i,a,b) for(i=a;i<b;i++)\n#define rep(i,n) f(i,0,n)\n#define fd(i,a,b) for(i=a;i>=b;i--)\n#define pb push_back\n#define mp make_pair\n#define vi vector< int >\n#define vl vector< ll >\n#define ss second\n#define ff first\n#define ll long long\n#define pii pair< int,int >\n#define pll pair< ll,ll >\n#define sz(a) a.size()\n#define inf (1000*1000*1000+5)\n#define all(a) a.begin(),a.end()\n#define tri pair<int,pii>\n#define vii vector<pii>\n#define vll vector<pll>\n#define viii vector<tri>\n#define mod (1000*1000*1000+9)\n#define pqueue priority_queue< int >\n#define pdqueue priority_queue< int,vi ,greater< int > >\n\n//std::ios::sync_with_stdio(false);   \nll ans10[512345],ans13[512345],powe13[512345],powe10[512345],invpowe10[512345];\nll invpowe13[512345],inv[1234],p[512345];\nll extend_gcd(ll a,ll b,ll &x,ll &y){\n\tif(b==0){\n\t\tx=1;\n\t\ty=0;\n\t\treturn a;\n\t}\n\tll x1,y1;\n\tll ans =extend_gcd(b,a%b,x1,y1);\n\tx=y1;\n\ty=x1-(a/b)*y1;\n\n\treturn ans;\n}\nmap<ll,ll> seti10,seti13; \nint main(){\n    std::ios::sync_with_stdio(false);\n    ll n;\n    cin>>n;\n    string s;\n    cin>>s;\n    ll i;\n    ll initp=250003;\n    powe10[0]=1;\n    powe13[0]=1;\n    invpowe10[0]=1;\n    invpowe13[0]=1;\n    ll inv10,inv13;\n\n            ll x,y;\n            i=503803;\n        ll val=extend_gcd(mod,i,x,y);\n        if(y>0)\n            inv13=y%mod;\n        else{\n                inv13=(y+mod)%mod;\n        }\n        x,y;\n            i=500167;\n        val=extend_gcd(mod,i,x,y);\n        if(y>0)\n            inv10=y%mod;\n        else{\n                inv10=(y+mod)%mod;\n        }    \n\tf(i,1,512345){\n    \tpowe13[i]=powe13[i-1]*503803;\n    \tpowe10[i]=powe10[i-1]*500167;\n    \tpowe10[i]%=mod;\n    \tpowe13[i]%=mod;\n    \tinvpowe10[i]=invpowe10[i-1]*inv10;\n    \tinvpowe10[i]%=mod;\n    \tinvpowe13[i]=invpowe13[i-1]*inv13;\n    \tinvpowe13[i]%=mod;\n    }\n    ans10[0]=0;\n    ans13[0]=0;\n    p[0]=initp;\n    \n    f(i,1,s.length()+1){\n    \tans10[i]=ans10[i-1];\n    \tans13[i]=ans13[i-1];\n    \tp[i]=p[i-1];\n    \tif(s[i-1]=='+'){\n    \t\tans10[i]=ans10[i-1]+powe10[p[i]];\n    \t\tans13[i]=ans13[i-1]+powe13[p[i]];\n\n    \t}\n    \telse if(s[i-1]=='-'){\n    \t\tans10[i]=ans10[i-1]-powe10[p[i]];\n    \t\tans13[i]=ans13[i-1]-powe13[p[i]];\n    \t}\n    \telse if(s[i-1]=='<'){\n    \t\tp[i]--;\n    \t}\n    \telse{\n    \t\tp[i]++;\n    \t}\n    \tans10[i]%=mod;\n    \tans10[i]+=mod;\n    \tans10[i]%=mod;\n    \tans13[i]%=mod;\n    \tans13[i]+=mod;\n    \tans13[i]%=mod;\n    \tseti13[ans13[i]]++;\n    \tseti10[ans10[i]]++;\n    \t//cout<<ans10[i]<<\" \"<<ans13[i]<<endl;\n    }\n    ll val1,j10,j13;\n    ll total=0;\n    f(i,1,n+1){\n    \tval=initp-p[i-1];\n    \tval*=-1;\n    \tif(val>=0){\n    \t\tval1=powe13[val];\n    \t\tval=powe10[val];\n    \t\t  \n    \t}\n    \telse{\n    \t\tval1=invpowe13[val];\n    \t\tval=invpowe10[val];\n    \t}\n    \tj10=ans10[n]*val;\n    \tj10%=mod;\n    \tj10+=ans10[i-1];\n    \tj13=ans13[n]*val1;\n    \tj13%=mod;\n    \tj13+=ans13[i-1];\n    \tj10%=mod;\n    \tj13%=mod;\n    \ttotal+=min(seti10[j10],seti13[j13]);\n        //assert(seti10[j10]==seti13[j13]);\n    \tseti13[ans13[i]]--;\n    \tseti10[ans10[i]]--;\n    }\n    cout<<total<<endl;\n\n\n\n\n    return 0;  \n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<climits>\n#include<bitset>\n#include<map>\n#define pii pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define int __int128\n#define mod1 10000000000037\n#define mod2 1000000000000000009\nusing namespace std;\ninline int read(){\n    int f=1,ans=0;char c=getchar();\n    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}\n    while(c>='0'&&c<='9'){ans=ans*10+c-'0';c=getchar();}\n    return f*ans;\n}\nconst int MAXN=5e5+11;\nint N;char str[MAXN];\nint h1[MAXN],s1[MAXN],x1=2,x2=3,res,h2[MAXN],s2[MAXN];\nint ksm1(int a,int b){\n    int ans=1;\n    while(b){if(b&1) ans*=a,ans%=mod1;a*=a,a%=mod1;b>>=1;}return ans;\n}\nint pw1(int a,int b){\n    if(b>=0) return ksm1(a,b);\n    int res=ksm1(a,-b);return ksm1(res,mod1-2);\n}\nint ksm2(int a,int b){\n    int ans=1;\n    while(b){if(b&1) ans*=a,ans%=mod2;a*=a,a%=mod2;b>>=1;}return ans;\n}\nint pw2(int a,int b){\n    if(b>=0) return ksm2(a,b);\n    int res=ksm2(a,-b);return ksm2(res,mod1-2);\n}\nmap<pii,int> M;\nvoid ins(int ps){M[mp( (h1[ps]+pw1(x1,s1[ps])*h1[N])%mod1 , (h2[ps]+pw2(x2,s2[ps])*h2[N])%mod2 )]++;return;}\ninline void print(int x){\n    if(x>9) print(x/10);\n    putchar(x%10+'0');\n}\nsigned main(){\n    //freopen(\"1.in\",\"r\",stdin);\n    srand(time(0));\n    x1=rand(),x2=rand();\n    N=read();scanf(\"%s\",str+1);\n    for(int i=1;i<=N;i++){\n        if(str[i]=='+') h1[i]=h1[i-1]+pw1(x1,s1[i-1]),s1[i]=s1[i-1],h1[i]%=mod1;\n        if(str[i]=='-') h1[i]=h1[i-1]-pw1(x1,s1[i-1])+mod1,s1[i]=s1[i-1],h1[i]%=mod1;\n        if(str[i]=='>') h1[i]=h1[i-1],s1[i]=s1[i-1]+1;\n        if(str[i]=='<') h1[i]=h1[i-1],s1[i]=s1[i-1]-1;\n        if(str[i]=='+') h2[i]=h2[i-1]+pw2(x2,s2[i-1]),s2[i]=s2[i-1],h2[i]%=mod2;\n        if(str[i]=='-') h2[i]=h2[i-1]-pw2(x2,s2[i-1])+mod2,s2[i]=s2[i-1],h2[i]%=mod2;\n        if(str[i]=='>') h2[i]=h2[i-1],s2[i]=s2[i-1]+1;\n        if(str[i]=='<') h2[i]=h2[i-1],s2[i]=s2[i-1]-1;\n    }\n    ins(0);\n    for(int i=1;i<=N;i++){\n        res+=M[mp(h1[i],h2[i])];\n        ins(i);\n    }print(res);printf(\"\\n\");return 0;\n}/*\n  5\n  +>+<-\n  */\n\n"
  },
  {
    "language": "C++",
    "code": "// AtCoder Regular Contest 099\n// Problem F - Eating Symbols Hard\n#include <cstdio>\n#include <cstring>\n#include <iostream>\nusing std::cin; using std::cout; using std::endl;\n#include <algorithm>\nusing std::sort;\n#include <vector>\nusing std::vector;\n#include <queue>\nusing std::queue; using std::priority_queue;\n#include <map>\nusing std::map;\n#include <utility>\nusing std::pair;\ntypedef pair<int, int> pii;\ntypedef long long LL;\n#define pass printf(\"%s : Line.%d\\n\", __FUNCTION__, __LINE__);\nconst int maxN = 250000 + 233; // 2.5e5\nint n;\nchar opt[maxN];\nint d[maxN], df; LL h1[maxN], hf1, h2[maxN], hf2;\n//const LL P = 1e9 + 7;\nbool isp(LL x) {\n\tfor(int i = 2; i*i <= x; ++i)\n\t\tif(x % i == 0) return false;\n\treturn true;\n}\nconst LL p1 = 1000000007;\nconst LL p2 = 1000000123;\nconst LL b1 = 107;\nconst LL b2 = 103;\nLL buc1[maxN*2], buc2[maxN*2];\nLL *pow1 = &buc1[maxN], *pow2 = &buc2[maxN];\nLL inv(LL x, LL p1) {\n\treturn x == 1 ? x : (p1 - (p1 / x) * inv(p1 % x, p1)) % p1;\n}\nLL inc(LL &a, LL b1, LL p1) { return (a += b1) >= p1 ? a -= p1 : a; }\nLL dec(LL &a, LL b1, LL p1) { return (a -= b1) < 0 ? a += p1 : a; }\nmap<pii, int> M;\n\nvoid init() {\n\tpow1[0] = 1; pow2[0] = 1;\n\tpow1[1] = b1; pow1[-1] = inv(b1, p1); pow2[1] = b2; pow2[-1] = inv(b2, p2);\n\tfor(int i = 1; i <= n; ++i) pow1[i] = pow1[i-1] * b1 % p1, pow2[i] = pow2[i-1] * b2 % p2;\n\tfor(int i = -1; i >= -n; --i) pow1[i] = pow1[i+1]* pow1[-1] % p1, pow2[i] = pow2[i+1]* pow2[-1] % p2;\n\thf1 = hf2 = df = 0;\n\tfor(int i = 1; i <= n; ++i) {\n\t\tswitch(opt[i]) {\n\t\t\tcase '+':\n\t\t\t\tinc(hf1, pow1[df], p1);\n\t\t\t\tinc(hf2, pow2[df], p2);\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tdec(hf1, pow1[df], p1);\n\t\t\t\tdec(hf2, pow2[df], p2);\n\t\t\t\tbreak;\n\t\t\tcase '>':\n\t\t\t\t++df;\n\t\t\t\tbreak;\n\t\t\tcase '<':\n\t\t\t\t--df;\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main() {\n//\tfor(int i = (int)1e9; ; ++i) if(isp(i)) printf(\"%d\\n\", i), getchar();\n//\tprintf(\"%.3lfMB\\n\", sizeof(buc1)*6/1000.0/1000.0);\n\tscanf(\"%d%s\", &n, opt + 1);\n\tinit();\n\tLL cnt = 0;\n\tM.clear();\n\th1[0] = h2[0] = d[0] = 0;\n\tM[pii((h1[0] + hf1 * pow1[d[0]]) % p1, (h2[0] + hf2 * pow2[d[0]]) % p2)] = 1;\n\tfor(int i = 1; i <= n; ++i) {\n\t\td[i] = d[i-1]; h1[i] = h1[i-1]; h2[i] = h2[i-1];\n\t\tswitch(opt[i]) {\n\t\t\tcase '+':\n\t\t\t\tinc(h1[i], pow1[d[i]], p1);\n\t\t\t\tinc(h2[i], pow2[d[i]], p2);\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tdec(h1[i], pow1[d[i]], p1);\n\t\t\t\tdec(h2[i], pow2[d[i]], p2);\n\t\t\t\tbreak;\n\t\t\tcase '>':\n\t\t\t\t++d[i];\n\t\t\t\tbreak;\n\t\t\tcase '<':\n\t\t\t\t--d[i];\n\t\t\t\tbreak;\n\t\t}\n\t\tpii c(h1[i], h2[i]), ins((h1[i] + hf1 * pow1[d[i]]) % p1, (h2[i] + hf2 * pow2[d[i]]) % p2);\n\t\tif(M.find(c) != M.end()) cnt += M[c]/*, printf(\"i = %d, cnt += %d\\n\", i, M[h1[i]])*/;\n\t\tif(M.find(ins) == M.end()) M[ins] = 1; else ++M[ins];\n\t}\n\tprintf(\"%lld\\n\", cnt);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 1000000007\n#define lim 300000\nusing namespace std;\nint n;\nchar s[300005];\nlong long A, base[600005], lsp, p, suf[300005], pre;\nmap<long long, int> cnt;\n\nlong long bs(int p) { return base[p + lim]; }\n\nint main() {\n    for (int i = base[lim] = 1; i <= lim; ++i)\n        base[lim + i] = base[lim + i - 1] * 250007 % mod;\n    for (int i = 1; i <= lim; ++i)\n        base[lim - i] = base[lim - i + 1] * 312435254 % mod;\n    scanf(\"%d%s\", &n, s + 1), p = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (s[i] == '>') ++p;\n        if (s[i] == '<') --p;\n        if (s[i] == '+') (A += bs(p)) %= mod;\n        if (s[i] == '-') (A += mod - bs(p)) % mod;\n    }\n    ++cnt[suf[n + 1] = 0];\n    for (int i = n; i > 1; --i) {\n        suf[i] = suf[i + 1];\n        if (s[i] == '>') --p;\n        if (s[i] == '<') ++p;\n        if (s[i] == '+') (suf[i] += bs(p)) %= mod;\n        if (s[i] == '-') (suf[i] += mod - bs(p)) %= mod;\n        ++cnt[suf[i]];\n    }\n\n    long long res = cnt[0];\n    p = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (s[i] == '>') ++p;\n        if (s[i] == '<') --p;\n        if (s[i] == '+') (pre += bs(p)) %= mod;\n        if (s[i] == '-') (pre += mod - bs(p)) % mod;\n        --cnt[suf[i + 1]];\n        res += cnt[((A - pre - A * bs(p) % mod) % mod + mod) % mod];\n    }\n    printf(\"%lld\\n\", res);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pi 3.1415926535897932384626\nusing namespace std;\n      \nstruct P{\n  int x,y;\n  bool operator < (const P &a )const{\n    //if(y!=a.y)\n    return y>a.y;\n  };\n\n};\n\nint a,b,c,d,i,n,m,e,dx[10]={1,0,-1,0,1,1,-1,-1},dy[10]={0,1,0,-1,1,-1,1,-1};\nlong long o[251010],o1[251010];\nint l[251011];\nlong long s[251011],re[251010];\nlong long s1[251011],re1[251010];\nlong long x,y,z,mod=1000000007,hf=(mod+1)/2;\n\n//string r,r1;\nchar r[251011];\n vector<int> v[1],v1;\nP u[1];\nqueue<int> q;\n//set<int> s[2];\n//stack<long long> s;\nmap<long long,int> p;\n//mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n//rng()\nbool as(P a,P b)\n{\n  return a.x<b.x;\n}\n\nlong long po1(long long x,long long y)\n{\n  long long p=1;\n  for(;y;y/=2,x*=x,x%=mod)\n  if(y%2)\n  {\n    p*=x,p%=mod;\n  }\n  return p;\n}\n\nlong long po(long long x,long long y)\n{\n  long long p=1;\n  for(;y;y/=2,x*=x,x%=z)\n  if(y%2)\n  {\n    p*=x,p%=z;\n  }\n  return p;\n}\n\nlong long f1(int n)\n{\n  if(n<0) return re1[abs(n)];\n  return s1[n];\n}\n\nlong long f(int n)\n{\n  if(n<0) return re[abs(n)];\n  return s[n];\n}\n\nint main()\n{\n  scanf(\"%d %s\",&a,r+1);\n  z=1000000021;\n  s[0]=re[0]=s1[0]=re1[0]=1;\n  for(int t=1;t<=a;t++)\n  {\n    s[t]=s[t-1]*3*a%z,re[t]=po(s[t],z-2);\n    s1[t]=s1[t-1]*3*a%mod,re1[t]=po1(s1[t],mod-2);\n  }\n  long long x1=0;\n  for(int t=1;t<=a;t++)\n  {\n    if(r[t]=='+') x+=f(n),x%=z,x1+=f1(n),x1%=mod;\n    else if(r[t]=='-') x+=(-f(n)+z),x%=z,x1+=(-f1(n)+mod),x1%=mod;\n    else if(r[t]=='>') n++;\n    else n--;\n    l[t]=n;\n    o[t]=x;\n    o1[t]=x1;\n  }\n  long long k=0,y1=x1;\n  y=x;\n  for(int t=a;t;t--)\n  {\n    p[o[t]*mod+o1[t]]++;\n    k+=p[(o[t-1]+y*f(l[t-1])%z)%z*mod+(o1[t-1]+y1*f1(l[t-1])%mod)%mod];\n    //printf(\"%lld %lld %lld\\n\",k,o1[t],(o1[t-1]+y1*f1(l[t-1])%mod)%mod);\n  }\n  printf(\"%lld\",k);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cmath>\n#include<cstdlib>\n#include<set>\n#define LL long long\n#define LD long double\nusing namespace std;\nconst int NN=250000 +117;\nconst int MM= +117;\nint read(){\n\tint fl=1,x;char c;\n\tfor(c=getchar();(c<'0'||c>'9')&&c!='-';c=getchar());\n\tif(c=='-'){fl=-1;c=getchar();}\n\tfor(x=0;c>='0'&&c<='9';c=getchar())\n\t\tx=(x<<3)+(x<<1)+c-'0';\n\treturn x*fl;\n}\nvoid open(){\n\tfreopen(\"99f.in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n}\nvoid close(){\n\tfclose(stdin);\n\tfclose(stdout);\n}\n\n\nint m,n;\nmultiset<pair<LL,LL>> a;\nchar s[NN]={};\nLL mod[2]={998244353,2281701377};\nLL ksm(LL a,LL b,LL mod){\n\tLL ret=1;\n\twhile(b){\n\t\tif(b&1){\n\t\t\tret*=a;\n\t\t\tret%=mod;\n\t\t}\n\t\ta*=a;\n\t\ta%=mod;\n\t\tb>>=1;\n\t}\n\treturn ret;\n}\ninline void mop(LL &x,LL y,LL mod){\n\tx=(x+y>=mod?x+y-mod:x+y);\n}\nint main(){\n\t//open();\n\tn=read();\n\tscanf(\"%s\",s);\n\tLL res[2]={0,0};\n\tLL rev[2];\n\trev[0]=ksm(mod[0],mod[1]-2,mod[1]);\n\trev[1]=ksm(mod[1],mod[0]-2,mod[0]);\n\tLL p[2]={1,1};\n\tfor(int i=0;i<n;++i){\n\t\tif(s[i]=='+'){\n\t\t\tfor(int i=0;i<2;++i){\n\t\t\t\tmop(res[i],p[i],mod[i]);\n\t\t\t}\n\t\t}\n\t\telse if(s[i]=='-'){\n\t\t\tfor(int i=0;i<2;++i){\n\t\t\t\t\n\t\t\t\tmop(res[i],mod[i]-p[i],mod[i]);\n\t\t\t}\n\t\t}\n\t\telse if(s[i]=='<'){\n\t\t\tfor(int i=0;i<2;++i){\n\t\t\t\tp[i]*=rev[i^1];\n\t\t\t\tp[i]%=mod[i];\n\t\t\t}\n\t\t}\n\t\telse if(s[i]=='>'){\n\t\t\tfor(int i=0;i<2;++i){\n\t\t\t\tp[i]*=mod[i^1];\n\t\t\t\tp[i]%=mod[i];\n\t\t\t}\n\t\t}\n\t}\n\tp[0]=1;\n\tp[1]=1;\n\tLL tp[2]={0,0};\n\tLL ans=0;\n\tfor(int i=0;i<n;++i){\n\t\ta.insert(make_pair((tp[0]+p[0]*res[0])%mod[0],(tp[1]+p[1]*res[1])%mod[1]));\n\t\tif(s[i]=='+'){\n\t\t\tfor(int i=0;i<2;++i){\n\t\t\t\tmop(tp[i],p[i],mod[i]);\n\t\t\t}\n\t\t}\n\t\telse if(s[i]=='-'){\n\t\t\tfor(int i=0;i<2;++i){\n\t\t\t\tmop(tp[i],mod[i]-p[i],mod[i]);\n\t\t\t}\n\t\t}\n\t\telse if(s[i]=='<'){\n\t\t\tfor(int i=0;i<2;++i){\n\t\t\t\tp[i]*=rev[i^1];\n\t\t\t\tp[i]%=mod[i];\n\t\t\t}\n\t\t}\n\t\telse if(s[i]=='>'){\n\t\t\tfor(int i=0;i<2;++i){\n\t\t\t\tp[i]*=mod[i^1];\n\t\t\t\tp[i]%=mod[i];\n\t\t\t}\n\t\t}\n\t\tans+=a.count(make_pair(tp[0],tp[1]));\n\t}\n\tprintf(\"%lld\\n\",ans);\n\tclose();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define Set(a, b) memset(a, b, sizeof (a))\n#define For(i, j, k) for (int i = j; i <= k; ++ i)\n#define Forr(i, j, k) for (int i = j; i >= k; -- i)\n\nusing namespace std;\n\ntypedef long long ll;\n\ninline void File() {\n\tfreopen(\"f.in\", \"r\", stdin);\n\tfreopen(\"f.out\", \"w\", stdout);\n}\n\nconst int N = 2.5e5 + 10;\nint n; char s[N];\nll st[N], p[N];\n\nconst ll mod = 1000000000000000031ll;\nconst ll gkk = 1000000000000000003ll;\nconst ll hany01 = 821428571428571454ll;\n\nll mul(ll a, ll b) { return (__int128) a * b % mod; }\nll add(ll a, ll b) { return (a += b) >= mod ? a - mod : a; }\n\nunordered_map<ll, int> mp;\n\nint main() {\n\n\tcin >> n, scanf(\"%s\", s + 1);\n\n\tp[0] = 1;\n\tFor(i, 1, n) {\n\t\tst[i] = st[i - 1], p[i] = p[i - 1];\n\t\tif (s[i] == '+') st[i] = add(st[i], p[i]);\n\t\tif (s[i] == '-') st[i] = add(st[i], mod - p[i]);\n\t\tif (s[i] == '>') p[i] = mul(p[i], gkk);\n\t\tif (s[i] == '<') p[i] = mul(p[i], hany01);\n\t}\n\n\tll ans = 0;\n\tForr(i, n, 1) {\n\t\t++ mp[st[i]];\n\t\tans += mp[add(mul(st[n], p[i - 1]), st[i - 1])];\n\t}\n\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<bits/stdc++.h>\nusing namespace std;\n \n#define MAX 250002\nint n;\n \nchar buf[MAX];\n \n__int128 mod1=1007ll;\n__int128 mod2=1000000000000000031LL;\n \ninline __int128 mul(__int128 a,__int128 b){\n\treturn (a*b)%mod2;\n}\ninline __int128 add(__int128 a,__int128 b){\n\tauto f=a+b;\n\tif(f>=mod2)f%=mod2;\n\treturn f;\n}\ninline __int128 sub(__int128 a,__int128 b){\n\tauto f=a-b;\n\tif(f<0)f+=mod2;\n\tf%=mod2;\n\treturn f;\n}\n__int128 ppow(__int128 a,__int128 b){\n\t__int128 res=1;\n\twhile(b){\n\t\tif(b&1LL)res*=a;\n\t\tif(res>=mod2)res%=mod2;\n\t\ta*=a;\n\t\ta%=mod2;\n\t\tb>>=1LL;\n\t}\n\treturn res;\n}\nunordered_map<long long int,int> cnt;\nvector<pair<__int128,__int128> > v;\nint main() {\n\tcin>>n;\n\tscanf(\"%s\",buf);\n\tauto inv = ppow(mod1,mod2-2);\n\tprintf(\"%lld\\n\",inv);\n\t__int128 cur=1;\n\t__int128 hs=0;\n\tint sz=strlen(buf);\n\tv.push_back(make_pair(0,1));\n\tfor(int i=0;i<sz;i++){\n\t\tif(buf[i]=='<'){\n\t\t\tcur=mul(cur,inv);\n\t\t}\n\t\tif(buf[i]=='>'){\n\t\t\tcur=mul(cur,mod1);\n\t\t}\n\t\tif(buf[i]=='+'){\n\t\t\ths=add(hs,cur);\n\t\t}\n\t\tif(buf[i]=='-'){\n\t\t\ths=sub(hs,cur);\n\t\t}\n\t\tv.push_back(make_pair(hs,cur));\n\t}\n\t__int128 acieve=v.back().first;\n\t//(x-c)/second=acieve\n\t//x-c=acieve/second\n\t//x = c+ acieve/second\n\tlong long int way=0;\n\tfor(int i=v.size()-1;i>=0;i--){\n\t\t__int128 want=add(v[i].first,mul(acieve,v[i].second));\n\t\tway+=cnt[want];\n\t\tcnt[v[i].first]++;\n\t\t//cerr<<i<<\" \"<<way<<endl;\n\t}\n\tprintf(\"%lld\\n\",way);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n// #include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <set>\n#include <map>\n#include <bitset>\nusing namespace std;\ntypedef long long LL;\ntypedef double db;\nconst int oo=2139063143;\nconst int N=1010000;\nconst db eps=1e-7;\n#define pritnf printf\n//char buf[1<<22],*p1=buf,*p2=buf,obuf[1<<22],*O=obuf;\n//#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)\ntemplate <typename T>\ninline void sc (T &x)\n{\n    x=0; static int p; p=1; static char c; c=getchar();\n    while (!isdigit(c)) { if (c=='-') p=-1; c=getchar(); }\n    while ( isdigit(c)) { x=(x<<1)+(x<<3)+(c-48); c=getchar(); }\n    x*=p;\n}\ntemplate <typename T>\ninline void print (T x)\n{\n    if (x< 0) putchar('-'),x=-x;\n    if (x>=10) print(x/10);\n    putchar(x%10+'0');\n}\ntemplate <typename T>\ninline void pr (T x) { print(x),putchar('\\n'); }\ntemplate <typename T1,typename T2>\nvoid chkmax (T1 &A,T2 B) { A=A>=B?A:B; }\ntemplate <typename T1,typename T2>\nvoid chkmin (T1 &A,T2 B) { A=A<=B?A:B; }\nint n;\nchar s[N];\nconst int P1=1e9+7,P2=1e9+9;\nstruct LY\n{\n\tint P;\n\tint del(int x) { return x>=P?x-P:x; }\n\tvoid add(int &x,int y) { x=del(x+y); }\n\tint ksm (int a,int b)\n\t{\n\t\tint ans=1;\n\t\twhile (b)\n\t\t{\n\t\t\tif (b&1) ans=(LL)ans*a%P;\n\t\t\ta=(LL)a*a%P,b>>=1;\n\t\t}\n\t\treturn ans;\n\t}\n}A,B;\nstruct pii\n{\n\tint x,y;\n\tpii (int xx=0,int yy=0) { x=xx,y=yy; }\n};\npii operator + (pii a,pii b) { return pii(A.del(a.x+b.x),B.del(a.y+b.y)); }\npii operator - (pii a,pii b) { return pii(A.del(a.x-b.x+P1),B.del(a.y-b.y+P2)); }\npii operator * (pii a,pii b) { return pii((LL)a.x*b.x%P1,(LL)a.y*b.y%P2); }\nbool operator < (pii a,pii b) { return a.x!=b.x?a.x< b.x:a.y< b.y; }\n\npii f[N],g[N],inv,Q=pii(233,233);\nvoid init ()\n{\n\tA.P=P1,B.P=P2;\n\tinv=pii(A.ksm (Q.x,P1-2),B.ksm (Q.y,P2-2));\n\tg[0]=pii(1,1);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tif (s[i]=='<') f[i]=f[i-1],g[i]=g[i-1]*inv;\n\t\telse if (s[i]=='>') f[i]=f[i-1],g[i]=g[i-1]*Q;\n\t\telse if (s[i]=='+') g[i]=g[i-1],f[i]=f[i-1]+g[i];\n\t\telse g[i]=g[i-1],f[i]=f[i-1]-g[i];\n\t}\n}\nmap <pii,int> p;\nLL solve ()\n{\n\tp.clear ();\n\t++p[f[n]];\n\tLL ans=0;\n\tfor (int i=n-1; i>=0; i--)\n\t\tans+=p[f[n]*g[i]+f[i]],++p[f[i]];\n\treturn ans;\n}\nint main ()\n{\n    // freopen (\".in\",\"r\",stdin);\n    // freopen (\".out\",\"w\",stdout);\n    sc(n),scanf (\"%s\",s+1);\n\tinit ();\n\tpr(solve ());\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo1 1019260817\n#define mo2 1009260817\ntypedef long long ll;\nll gi(){\n\tll x=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch))f^=ch=='-',ch=getchar();\n\twhile(isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\treturn f?x:-x;\n}\nint pow(int x,int y,int mo){\n\tint ret=1;\n\twhile(y){\n\t\tif(y&1)ret=1ll*ret*x%mo;\n\t\tx=1ll*x*x%mo;y>>=1;\n\t}\n\treturn ret;\n}\nchar S[250010];\nint bs1=19260817,ibs1=966804715,bs2=19491001,ibs2=251190511;\nstd::unordered_map<ll,int>M;\nint main(){\n#ifdef XZZSB\n\tfreopen(\"in.in\",\"r\",stdin);\n\tfreopen(\"out.out\",\"w\",stdout);\n#endif\n\tint n=gi();scanf(\"%s\",S+1);\n\tint p1=1,p2=1,x1=0,x2=0;\n\tfor(int i=1;i<=n;++i){\n\t\tif(S[i]=='+'||S[i]=='-'){\n\t\t\tif(S[i]=='+')x1=(x1+p1)%mo1,x2=(x2+p2)%mo2;\n\t\t\telse x1=(x1+mo1-p1)%mo1,x2=(x2+mo2-p2)%mo2;\n\t\t}else{\n\t\t\tif(S[i]=='<')p1=1ll*p1*bs1%mo1,p2=1ll*p2*bs2%mo2;\n\t\t\telse p1=1ll*p1*ibs1%mo1,p2=1ll*p2*ibs2%mo2;\n\t\t}\n\t}\n\tint X1=x1,X2=x2;x1=x2=0;ll ans=0;\n\tfor(int i=1;i<=n;++i){\n\t\tint y1=(x1+1ll*X1*p1)%mo1,y2=(x2+1ll*X2*p2)%mo2;\n\t\t++M[(1ll*y1<<32)|y2];\n\t\tif(S[i]=='+'||S[i]=='-'){\n\t\t\tif(S[i]=='+')x1=(x1+p1)%mo1,x2=(x2+p2)%mo2;\n\t\t\telse x1=(x1+mo1-p1)%mo1,x2=(x2+mo2-p2)%mo2;\n\t\t}else{\n\t\t\tif(S[i]=='<')p1=1ll*p1*bs1%mo1,p2=1ll*p2*bs2%mo2;\n\t\t\telse p1=1ll*p1*ibs1%mo1,p2=1ll*p2*ibs2%mo2;\n\t\t}\n\t\tans+=M[(1ll*x1<<32)|x2];\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//teja349\n#include <bits/stdc++.h>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <utility>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <iomanip> \n//setbase - cout << setbase (16); cout << 100 << endl; Prints 64\n//setfill -   cout << setfill ('x') << setw (5); cout << 77 << endl; prints xxx77\n//setprecision - cout << setprecision (14) << f << endl; Prints x.xxxx\n//cout.precision(x)  cout<<fixed<<val;  // prints x digits after decimal in val\n\nusing namespace std;\n#define f(i,a,b) for(i=a;i<b;i++)\n#define rep(i,n) f(i,0,n)\n#define fd(i,a,b) for(i=a;i>=b;i--)\n#define pb push_back\n#define mp make_pair\n#define vi vector< int >\n#define vl vector< ll >\n#define ss second\n#define ff first\n#define ll long long\n#define pii pair< int,int >\n#define pll pair< ll,ll >\n#define sz(a) a.size()\n#define inf (1000*1000*1000+5)\n#define all(a) a.begin(),a.end()\n#define tri pair<int,pii>\n#define vii vector<pii>\n#define vll vector<pll>\n#define viii vector<tri>\n#define mod (998244353)\n#define pqueue priority_queue< int >\n#define pdqueue priority_queue< int,vi ,greater< int > >\n\n//std::ios::sync_with_stdio(false);   \nll ans10[512345],ans13[512345],powe13[512345],powe10[512345],invpowe10[512345];\nll invpowe13[512345],inv[1234],p[512345];\nll extend_gcd(ll a,ll b,ll &x,ll &y){\n\tif(b==0){\n\t\tx=1;\n\t\ty=0;\n\t\treturn a;\n\t}\n\tll x1,y1;\n\tll ans =extend_gcd(b,a%b,x1,y1);\n\tx=y1;\n\ty=x1-(a/b)*y1;\n\n\treturn ans;\n}\nmap<ll,ll> seti10,seti13; \nint main(){\n    std::ios::sync_with_stdio(false);\n    ll n;\n    cin>>n;\n    string s;\n    cin>>s;\n    ll i;\n    ll initp=250003;\n    powe10[0]=1;\n    powe13[0]=1;\n    invpowe10[0]=1;\n    invpowe13[0]=1;\n    f(i,1,100){\n\t\tll x,y;\n\t\tll val=extend_gcd(mod,i,x,y);\n\t\tif(y>0)\n\t\t\tinv[i]=y%mod;\n\t\telse{\n\t\t\t\tinv[i]=(y+mod)%mod;\n\t\t}\n\t}\n\tll inv10=inv[10];\n\tll inv13=inv[13];\n    f(i,1,512345){\n    \tpowe13[i]=powe13[i-1]*13;\n    \tpowe10[i]=powe10[i-1]*10;\n    \tpowe10[i]%=mod;\n    \tpowe13[i]%=mod;\n    \tinvpowe10[i]=invpowe10[i-1]*inv10;\n    \tinvpowe10[i]%=mod;\n    \tinvpowe13[i]=invpowe13[i-1]*inv13;\n    \tinvpowe13[i]%=mod;\n    }\n    ans10[0]=0;\n    ans13[0]=0;\n    p[0]=initp;\n    \n    f(i,1,s.length()+1){\n    \tans10[i]=ans10[i-1];\n    \tans13[i]=ans13[i-1];\n    \tp[i]=p[i-1];\n    \tif(s[i-1]=='+'){\n    \t\tans10[i]=ans10[i-1]+powe10[p[i]];\n    \t\tans13[i]=ans13[i-1]+powe13[p[i]];\n\n    \t}\n    \telse if(s[i-1]=='-'){\n    \t\tans10[i]=ans10[i-1]-powe10[p[i]];\n    \t\tans13[i]=ans13[i-1]-powe13[p[i]];\n    \t}\n    \telse if(s[i-1]=='<'){\n    \t\tp[i]--;\n    \t}\n    \telse{\n    \t\tp[i]++;\n    \t}\n    \tans10[i]%=mod;\n    \tans10[i]+=mod;\n    \tans10[i]%=mod;\n    \tans13[i]%=mod;\n    \tans13[i]+=mod;\n    \tans13[i]%=mod;\n    \tseti13[ans13[i]]++;\n    \tseti10[ans10[i]]++;\n    \t//cout<<ans10[i]<<\" \"<<ans13[i]<<endl;\n    }\n    ll val,val1,j10,j13;\n    ll total=0;\n    f(i,1,n+1){\n    \tval=initp-p[i-1];\n    \tval*=-1;\n    \tif(val>=0){\n    \t\tval1=powe13[val];\n    \t\tval=powe10[val];\n    \t\t  \n    \t}\n    \telse{\n    \t\tval1=invpowe13[val];\n    \t\tval=invpowe10[val];\n    \t}\n    \tj10=ans10[n]*val;\n    \tj10%=mod;\n    \tj10+=ans10[i-1];\n    \tj13=ans13[n]*val;\n    \tj13%=mod;\n    \tj13+=ans13[i-1];\n    \tj10%=mod;\n    \tj13%=mod;\n    \t//cout<<j10<<\" \"<<j13<<endl;\n    \ttotal+=min(seti10[j10],seti13[j13]);\n    \tseti13[ans13[i]]--;\n    \tseti10[ans10[i]]--;\n    }\n    cout<<total<<endl;\n\n\n\n\n    return 0;  \n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\nusing namespace std;\n\nunsigned long long N, power[500009], inv[500009], L[500009]; int bx[500009]; string S;\nmap<unsigned long long, int>M;\n\nint main() {\n\tcin >> N >> S;\n\tpower[0] = 1; for (int i = 1; i <= 500000; i++) power[i] = (power[i - 1] * 1000000007LL);\n\tinv[0] = 1; for (int i = 1; i <= 500000; i++) inv[i] = (inv[i - 1] * 13499267949257065399ULL);\n\n\tL[0] = 0; int cx = 0;\n\tfor (int i = 0; i < S.size(); i++) {\n\t\tif (S[i] == '>') cx++;\n\t\tif (S[i] == '<') cx--;\n\t\tif (S[i] == '+') L[i + 1] += power[250000 + cx];\n\t\tif (S[i] == '-') L[i + 1] -= power[250000 + cx];\n\t\tL[i + 1] += L[i];\n\t\tbx[i + 1] = cx;\n\t}\n\n\tlong long cnt = 0;\n\tfor (int i = N - 1; i >= 0; i--) {\n\t\tM[L[i + 1]]++;\n\t\tunsigned long long I = L[N];\n\t\tif (bx[i] > 0) I *= power[bx[i]];\n\t\telse I *= inv[-bx[i]];\n\n\t\tunsigned long long J = I + L[i];\n\t\tcnt += M[J];\n\t}\n\tcout << cnt << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define llu unsigned long long\nusing namespace std;\nconst int N=5e5,bas=37;\nint n;\nstruct hash{\n  int mo,ni,f[N],g[N];\n  int fap(int a,int b){\n    int s=1;\n    for (; b; b>>=1,a=1ll*a*a%mo)\n      if (b&1) s=1ll*s*a%mo;\n    return s;\n  }\n  void solve(int x,char c){\n    if (c=='+')\n      g[x]=g[x-1],f[x]=(f[x-1]+g[x])%mo;\n    else if (c=='-')\n      g[x]=g[x-1],f[x]=(f[x-1]+mo-g[x])%mo;\n    else if (c=='<')\n      f[x]=f[x-1],g[x]=1ll*g[x-1]*ni%mo;\n    else\n      f[x]=f[x-1],g[x]=1ll*g[x-1]*bas%mo;\n    return;\n  }\n  int calc(int x){\n    return (1ll*g[x]*f[n]+f[x])%mo;\n  }\n}T[4];\nchar s[N];\nint c[10];\nmap<llu,int>sum;\nint main(){\n  scanf(\"%d%s\",&n,s+1);\n  T[0].mo=998244353,T[0].g[0]=1;\n  T[1].mo=1000000097,T[1].g[0]=1;\n  T[2].mo=1000000007,T[2].g[0]=1;\n  T[3].mo=1000000009,T[3].g[0]=1;\n  for (int t=0; t<4; ++t){\n    T[t].ni=T[t].fap(bas,T[t].mo-2);\n    for (int i=1; i<=n; ++i)\n      T[t].solve(i,s[i]);\n  }\n  llu u,v,ans=0;\n  for (int i=n; i>=1; --i){\n    u=v=1;\n    for (int t=0; t<4; ++t)\n      v=v*T[t].f[i],u=u*T[t].calc(i-1);\n    ++sum[v],ans+=sum[u];\n  }\n  cout<<ans;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\nconst ll p=10000000000037;\nconst int base=250001;\nunordered_map<ll,int> mp;\nint n,dig[250005];\nll pw[250005]={1},hsh[250005],ans;\nchar s[250005];\nll qpow(ll a,ll b){\n    ll res=1;\n    while(b){\n        if(b&1)\n            res=res*a%p;\n        a=a*a%p;\n        b>>=1;\n    }\n    return res;\n}\nll power(ll x){\n    return x>=0?pw[x]:qpow(pw[-x],p-2);\n}\nint main(){\n    ios::sync_with_stdio(false);\n    ll val;\n    int i;\n    cin>>n>>s+1;\n    for(i=1;i<=n;i++)\n        pw[i]=pw[i-1]*base%p;\n    for(i=1;i<=n;i++){\n        switch(s[i]){\n            case '+':\n                dig[i]=dig[i-1];\n                hsh[i]=(hsh[i-1]+power(dig[i]))%p;\n                break;\n            case '-':\n                dig[i]=dig[i-1];\n                hsh[i]=(hsh[i-1]-power(dig[i])+p)%p;\n                break;\n            case '<':\n                dig[i]=dig[i-1]+1;\n                hsh[i]=hsh[i-1];\n                break;\n            case '>':\n                dig[i]=dig[i-1]-1;\n                hsh[i]=hsh[i-1];\n        }\n    }\n    for(i=0;i<=n;i++){\n        if(mp.count(hsh[i]))\n            ans+=mp[hsh[i]];\n        val=(hsh[i]+hsh[n]*power(dig[i]))%p;\n        if(mp.count(val))\n            mp[val]++;\n        else\n            mp[val]=1;\n    }\n    cout<<ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <unordered_map>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate <class T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (T& x : v)\n    is >> x;\n  return is;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\nconst int N = 250010, P = 998244353, B = 19260817;\n\ntypedef pair<int, int> pii;\n\nstruct NumberTheory {\n\n  typedef pair<int, int> _P2_Field;\n\n  mt19937 rng;\n\n  NumberTheory() : rng(chrono::steady_clock::now().time_since_epoch().count()) {}\n\n  constexpr void _exGcd(int a, int b, int& x, int& y) {\n    if (!b) {\n      x = 1;\n      y = 0;\n      return;\n    }\n    _exGcd(b, a % b, y, x);\n    y -= a / b * x;\n  }\n\n  constexpr int inv(int a, int p = P) {\n    int x = 0, y = 0;\n    _exGcd(a, p, x, y);\n    if (x < 0)\n      x += p;\n    return x;\n  }\n\n  template <class Integer>\n  bool quadRes(Integer a, Integer b) {\n    if (a <= 1)\n      return true;\n    while (a % 4 == 0)\n      a /= 4;\n    if (a % 2 == 0)\n      return (b % 8 == 1 || b % 8 == 7) == quadRes(a / 2, b);\n    return ((a - 1) % 4 == 0 || (b - 1) % 4 == 0) == quadRes(b % a, a);\n  }\n\n  // assume p in prime, x in quadratic residue\n  int sqrt(int x, int p = P) {\n    if (p == 2 || x <= 1)\n      return x;\n    int w, v, k = (p + 1) / 2;\n    do {\n      w = rng() % p;\n    } while (quadRes(v = int((w * (ll)w - x + p) % p), p));\n    _P2_Field res(1, 0), a(w, 1);\n    while (k) {\n      if (k & 1)\n        res = _P2_Field((res.first * (ll)a.first + res.second * (ll)a.second % p * v) % p, (res.first * (ll)a.second + res.second * (ll)a.first) % p);\n      if (k >>= 1)\n        a = _P2_Field((a.first * (ll)a.first + a.second * (ll)a.second % p * v) % p, (a.first * (ll)a.second << 1) % p);\n    }\n    return min(res.first, p - res.first);\n  }\n\n} nt;\n\npii unite(const pii& lhs, const pii& rhs) { return make_pair((lhs.first + rhs.first * (ll)lhs.second) % P, lhs.second * (ll)rhs.second % P); }\n\nconstexpr pii LEFT(0, B), RIGHT(0, nt.inv(B)), PLUS(1, 1), MINUS(P - 1, 1);\n\nchar s[N];\npii op[256];\npii pref[N];\n\nunordered_map<int, int> mp;\n\nint main() {\n#ifdef LBT\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n;\n  cin >> n >> (s + 1);\n  op['<'] = LEFT;\n  op['>'] = RIGHT;\n  op['+'] = PLUS;\n  op['-'] = MINUS;\n  pref[0] = make_pair(0, 1);\n  for (int i = 1; i <= n; ++i)\n    pref[i] = unite(pref[i - 1], op[s[i]]);\n  ll ans = 0;\n  for (int i = 0; i <= n; ++i) {\n    ans += mp[pref[i].first];\n    ++mp[unite(pref[i], pref[n]).first];\n  }\n  cout << ans << '\\n';\n\n#ifdef LBT\n  LOG(\"Time: %dms\\n\", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <map>\n#define int long long\nusing namespace std;\nconst int N = 3e5 + 5;\nconst int B1 = 23711, B2 = 63711, P1 = 998244353, P2 = 1004535809;\nint n, S[N], T[N], f[N][2], inv1, inv2, ans;\nmap<pair<int, int>, int> t;\nchar s[N];\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}\n\treturn x * f;\n}\nint ksm(int x, int y, int mod)\n{\n\tint res = 1;\n\tfor(; y; y >>= 1, x = x * x % mod)\n\t\tif(y & 1) res = res * x % mod;\n\treturn res;\n}\nsigned main()\n{\n//\tfreopen(\".in\", \"r\", stdin);\n//\tfreopen(\".out\", \"w\", stdout);\n\tn = read(); scanf(\"%s\", s + 1); f[0][0] = f[0][1] = 1;\n\tinv1 = ksm(B1, P1 - 2, P1); inv2 = ksm(B2, P2 - 2, P2);\n\tfor(int i = 1; i <= n; i ++)\n\t{\n\t\tif(s[i] == '-')\n\t\t{\n\t\t\tf[i][0] = f[i - 1][0]; f[i][1] = f[i - 1][1];\n\t\t\tS[i] = (S[i - 1] - f[i][0] + P1) % P1;\n\t\t\tT[i] = (T[i - 1] - f[i][1] + P2) % P2;\n\t\t}\n\t\telse if(s[i] == '+')\n\t\t{\n\t\t\tf[i][0] = f[i - 1][0]; f[i][1] = f[i - 1][1];\n\t\t\tS[i] = (S[i - 1] + f[i][0]) % P1;\n\t\t\tT[i] = (T[i - 1] + f[i][1]) % P2;\n\t\t}\n\t\telse if(s[i] == '<')\n\t\t{\n\t\t\tf[i][0] = f[i - 1][0] * inv1 % P1;\n\t\t\tf[i][1] = f[i - 1][1] * inv2 % P2;\n\t\t\tS[i] = S[i - 1]; T[i] = T[i - 1];\n\t\t\t\n\t\t}\n\t\telse if(s[i] == '>')\n\t\t{\n\t\t\tf[i][0] = f[i - 1][0] * B1 % P1;\n\t\t\tf[i][1] = f[i - 1][1] * B2 % P2;\n\t\t\tS[i] = S[i - 1]; T[i] = T[i - 1];\n\t\t}\n\t\tt[make_pair(S[i], T[i])] ++;\n\t}\n\tt[make_pair(0, 0)] ++; int x, y;\n\tfor(int i = 0; i < n; i ++)\n\t{\n\t\tt[make_pair(S[i], T[i])] --;\n\t\tx = (S[i] + S[n] * f[i][0] % P1) % P1;\n\t\ty = (T[i] + T[n] * f[i][1] % P2) % P2;\n\t\tans += t[make_pair(x, y)];\n\t}\n\tprintf(\"%lld\\n\", ans);\n\tfclose(stdin);\n\tfclose(stdout);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\ntypedef long long ll; \ninline ll quick_pow(ll a, ll n, ll mod)\n{\n\tll res = 1; \n\twhile (n)\n\t{\n\t\tif (n & 1)\n\t\t\tres = res * a % mod; \n\t\ta = a * a % mod;\n\t\tn >>= 1; \n\t}\n\treturn res; \n}\nstruct data\n{\n\tll arr[5]; \n\tinline ll &operator [](const int &x)\n\t{\n\t\treturn arr[x]; \n\t}\n\tinline const ll &operator [](const int &x) const\n\t{\n\t\treturn arr[x]; \n\t}\n\tinline bool operator <(const data &x) const\n\t{\n\t\tfor (int i = 0; i < 5; i++)\n\t\t{\n\t\t\tif (arr[i] != x[i])\n\t\t\t\treturn arr[i] < x[i]; \n\t\t}\n\t\treturn false; \n\t}\n} hsh[300005], cur; \nstd::map<data, int> app; \nconst ll bs[] = {1234567, 500003, 500007, 800001, 19260817};\nconst ll md[] = {998244353, 1000000007, 1000000009, 998244353, 1234567891}; \nint idx[300005]; \nchar str[300005]; \nll pw[5][600005], inv[5][600005]; \nint main()\n{\n\t// freopen(\"ARC099-F.in\", \"r\", stdin); \n\tint n; \n\tscanf(\"%d%s\", &n, str);\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tpw[i][0] = 1; \n\t\tfor (int j = 1; j <= 6e5; j++)\n\t\t\tpw[i][j] = pw[i][j - 1] * bs[i] % md[i];\n\t\tinv[i][0] = 1; \n\t\tint x = quick_pow(bs[i], md[i] - 2, md[i]); \n\t\tfor (int j = 1; j <= 6e5; j++)\n\t\t\tinv[i][j] = inv[i][j - 1] * x % md[i]; \n\t}\n\tint pos = n + 5; \n\tfor (int i = 0; i <= n; i++)\n\t{\n\t\tidx[i] = pos; \n\t\thsh[i] = cur; \n\t\tif (str[i] == '+')\n\t\t{\n\t\t\tfor (int j = 0; j < 5; j++)\n\t\t\t\t(cur[j] += pw[j][pos]) %= md[j];\n\t\t}\n\t\telse if (str[i] == '-')\n\t\t{\n\t\t\tfor (int j = 0; j < 5; j++)\n\t\t\t\t(cur[j] += md[j] - pw[j][pos]) %= md[j];\n\t\t}\n\t\telse if (str[i] == '<')\n\t\t\tpos--;\n\t\telse\n\t\t\tpos++; \n\t}\n\tll ans = 0; \n\tfor (int i = n; i >= 0; i--)\n\t{\n\t\tdata x; \n\t\tint d = idx[i] - (n + 5); \n\t\tif (d >= 0)\n\t\t{\n\t\t\tfor (int j = 0; j < 5; j++)\n\t\t\t\tx[j] = (hsh[i][j] + cur[j] * pw[j][d]) % md[j]; \n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (int j = 0; j < 5; j++)\n\t\t\t\tx[j] = (hsh[i][j] + cur[j] * inv[j][-d]) % md[j];\n\t\t}\n\t\tans += app[x]; \n\t\tapp[hsh[i]]++; \n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<bits/stdc++.h>\nusing namespace std;\n \n#define MAX 250002\nint n;\n \nchar buf[MAX];\n \n__int128 mod1=1007ll;\n__int128 mod2=1000000000000000031LL;\n \ninline __int128 mul(__int128 a,__int128 b){\n\treturn (a*b)%mod2;\n}\ninline __int128 add(__int128 a,__int128 b){\n\tauto f=a+b;\n\tif(f>=mod2)f%=mod2;\n\treturn f;\n}\ninline __int128 sub(__int128 a,__int128 b){\n\tauto f=a-b;\n\tif(f<0)f+=mod2;\n\tf%=mod2;\n\treturn f;\n}\n__int128 ppow(__int128 a,__int128 b){\n\t__int128 res=1;\n\twhile(b){\n\t\tif(b&1LL)res*=a;\n\t\tif(res>=mod2)res%=mod2;\n\t\ta*=a;\n\t\ta%=mod2;\n\t\tb>>=1LL;\n\t}\n\treturn res;\n}\nunordered_map<long long int,int> cnt;\nvector<pair<__int128,__int128> > v;\nint main() {\n\tcin>>n;\n\tscanf(\"%s\",buf);\n\tauto inv = ppow(mod1,mod2-2);\n\t__int128 cur=1;\n\t__int128 hs=0;\n\tint sz=strlen(buf);\n\tv.push_back(make_pair(0,1));\n\tfor(int i=0;i<sz;i++){\n\t\tif(buf[i]=='<'){\n\t\t\tcur=mul(cur,inv);\n\t\t}\n\t\tif(buf[i]=='>'){\n\t\t\tcur=mul(cur,mod1);\n\t\t}\n\t\tif(buf[i]=='+'){\n\t\t\ths=add(hs,cur);\n\t\t}\n\t\tif(buf[i]=='-'){\n\t\t\ths=sub(hs,cur);\n\t\t}\n\t\tv.push_back(make_pair(hs,cur));\n\t}\n\t__int128 acieve=v.back().first;\n\t//(x-c)/second=acieve\n\t//x-c=acieve/second\n\t//x = c+ acieve/second\n\tlong long int way=0;\n\tfor(int i=v.size()-1;i>=0;i--){\n\t\t__int128 want=add(v[i].first,mul(acieve,v[i].second));\n\t\tway+=cnt[want];\n\t\tcnt[v[i].first]++;\n\t\t//cerr<<i<<\" \"<<way<<endl;\n\t}\n\tprintf(\"%lld\\n\",way);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx2\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst double EPS=1e-10;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 3121000;\nlong long fact[C_SIZE];\nlong long finv[C_SIZE];\nlong long inv[C_SIZE];\nlong long Comb(int a,int b){\n \tif(a<b||b<0)return 0;\n \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n}\nvoid init_C(int n){\n\tfact[0]=finv[0]=inv[1]=1;\n\tfor(int i=2;i<n;i++){\n\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t}\n\tfor(int i=1;i<n;i++){\n\t\tfact[i]=fact[i-1]*i%mod;\n\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t}\n}\nlong long pw(long long a,long long b){\n\tif(a<0LL)return 0;\n\tif(b<0LL)return 0;\n\tlong long ret=1;\n\twhile(b){\n\t\tif(b%2)ret=ret*a%mod;\n\t\ta=a*a%mod;\n\t\tb/=2;\n\t}\n\treturn ret;\n}\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\ndouble ABS(double a){return max(a,-a);}\nint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n// ここから編集しろ\nlong long M1=1000000007;\nlong long M2=1000000009;\nlong long M3=998244353;\nchar in[300000];\nstruct wolf{\n\tlong long a1,a2,a3;\n\twolf(){a1=a2=a3=0;}\n\twolf(long long A1,long long A2,long long A3){a1=A1;a2=A2;a3=A3;}\n};\ninline bool operator<(const wolf&a,const wolf&b){\n\tif(a.a1!=b.a1)return a.a1<b.a1;\n\tif(a.a2!=b.a2)return a.a2<b.a2;\n\tif(a.a3!=b.a3)return a.a3<b.a3;\n\treturn false;\n}\ninline wolf operator+(const wolf&a,const wolf&b){\n\treturn wolf((a.a1+b.a1)%M1,(a.a2+b.a2)%M2,(a.a3+b.a3)%M3);\n}\ninline wolf operator-(const wolf&a,const wolf&b){\n\treturn wolf((a.a1-b.a1+M1)%M1,(a.a2-b.a2+M2)%M2,(a.a3-b.a3+M3)%M3);\n}\nlong long modpw(long long a,long long b,long long M){\n\tlong long ret=1;\n\twhile(b){\n\t\tif(b%2)ret=ret*a%M;\n\t\ta=a*a%M;\n\t\tb/=2;\n\t}\n\treturn ret;\n}\ninline wolf operator<<(const wolf&a,const int&b){\n\treturn wolf((a.a1*modpw(114514,(M1-1+b)%(M1-1),M1))%M1,(a.a2*modpw(810514,(M2-1+b)%(M2-1),M2))%M2,(a.a3*modpw(1919810,(M3-1+b)%(M3-1),M3))%M3);\n}\ninline wolf operator>>(const wolf&a,const int&b){\n\treturn wolf((a.a1*modpw(114514,M1-1-b%(M1-1),M1))%M1,(a.a2*modpw(810514,M2-1-b%(M2-1),M2))%M2,(a.a3*modpw(1919810,M3-1-b%(M3-1),M3))%M3);\n}\nint bit[310000];\nint sum(int a,int b){\n\tif(a)return sum(0,b)-sum(0,a-1);\n\tint ret=0;\n\tfor(;b>=0;b=(b&(b+1))-1)ret+=bit[b];\n\treturn ret;\n}\nvoid add(int a,int b){\n\tfor(;a<310000;a|=a+1)bit[a]+=b;\n}\nwolf pool[300000];\nwolf at[300000];\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tscanf(\"%s\",in);\n\twolf now;\n\twolf ks(1,1,1);\n\tfor(int i=0;i<a;i++){\n\t\tif(in[i]=='+'){\n\t\t\tnow=now+ks;\n\t\t}else if(in[i]=='-'){\n\t\t\tnow=now-ks;\n\t\t}else if(in[i]=='<'){\n\t\t\tks=(ks<<1);\n\t\t}else{\n\t\t\tks=(ks>>1);\n\t\t}\n\n\t\tat[i+1]=now;\n\t}\n\tfor(int i=1;i<=a;i++)pool[i-1]=at[i];\n\tstd::sort(pool,pool+a);\n\tfor(int i=0;i<a;i++)add(i,1);\n\tlong long ret=0;\n\tint os=0;\n\tfor(int i=0;i<a;i++){\n\t\twolf tmp=now<<os;\n\t\ttmp=tmp+at[i];\n\t//\tprintf(\"%lld %lld %lld\\n\",tmp.a1,tmp.a2,tmp.a3);\n\t\tint R=upper_bound(pool,pool+a,tmp)-pool;\n\t\tint L=lower_bound(pool,pool+a,tmp)-pool;\n\t//\tprintf(\"%d %d\\n\",L,R);\n\t\t\n\t\tif(L<R){\n\t\t\tret+=sum(L,R-1);\n\t\t}\n\t\tadd(lower_bound(pool,pool+a,at[i+1])-pool,-1);\n\t\tif(in[i]=='<')os++;\n\t\telse if(in[i]=='>')os--;\n\t}\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\nconst int N = 254000;\n\nnamespace hasher {\n\ttypedef std::array <int, 6> num;\n\tconst int mod[6] = {900000011, 998244353, 1000000007, 1000000009, 1004535809, 1100000009};\n\n\tinline void add(int &x, const int y, const int mod) {x += y - mod, x += x >> 31 & mod;}\n\tinline void sub(int &x, const int y, const int mod) {x -= y, x += x >> 31 & mod;}\n\tinline void mul(int &x, const int y, const int mod) {x = (ll)x * y % mod;}\n\t#define DEF_OPERATOR(op, func) inline num operator op (const num &A, const num &B) {num C(A); return func(C[0], B[0], mod[0]), func(C[1], B[1], mod[1]), func(C[2], B[2], mod[2]), func(C[3], B[3], mod[3]), func(C[4], B[4], mod[4]), func(C[5], B[5], mod[5]), C;}\n\tDEF_OPERATOR(+, add)\n\tDEF_OPERATOR(-, sub)\n\tDEF_OPERATOR(*, mul)\n\n\tstruct _hash_ {inline size_t operator () (const num &x) const {return x[0] + 20030731ull * x[1] + 401230184394361ull * x[2] + 12600220620188154931ull * x[3] + 12293446969008436529ull * x[4] + 17407636028038340123ull * x[5];}};\n\n\tnum X, Xi, _0, _1, in;\n\tstd::mt19937 gen;\n\n\tll PowerMod(ll a, int n, ll mod, ll c = 1) {for (; n; n >>= 1, a = a * a % mod) if (n & 1) c = c * a % mod; return c;}\n\n\tinline int uniform(int l, int r) {return std::uniform_int_distribution <int> (l, r) (gen);}\n\n\tinline void init() {\n\t\tchar *_ = new char; gen.seed(time(NULL) + (size_t)_),delete _;\n\t\t_0.fill(0), _1.fill(1);\n\t\tfor (int i = 0, S; i < 6; ++i)\n\t\t\tS = sqrt(mod[i]), X[i] = uniform(S, mod[i] - S),\n\t\t\tXi[i] = PowerMod(X[i], mod[i] - 2, mod[i]);\n\t}\n}\nusing namespace hasher;\n\ntypedef std::unordered_map <num, int, _hash_> map;\n\nstruct linear {\n\tnum k, b;\n\tlinear () {}\n\tlinear (const num &_k, const num &_b) : k(_k), b(_b) {}\n\tinline linear operator * (const linear &B) const {return linear(k * B.k, k * B.b + b);}\n\tinline num operator () (const num &x) const {return k * x + b;}\n};\n\nint n;\nchar s[N];\nlinear f[N];\nmap M;\n\nint query(const num &x) {\n\tmap::iterator it = M.find(x);\n\treturn it == M.end() ? 0 : it->second;\n}\n\nint main() {\n\tint i; ll ans = 0; num in(_0);\n\tinit(), scanf(\"%d%s\", &n, s + 1);\n\tfor (i = 1; i <= n; ++i)\n\t\tswitch (s[i]) {\n\t\t\tcase 43: f[i] = linear(_1, _1); break;\n\t\t\tcase 45: f[i] = linear(_1, _0 - _1); break;\n\t\t\tcase 60: f[i] = linear(Xi, _0); break;\n\t\t\tcase 62: f[i] = linear(X, _0); break;\n\t\t}\n\tfor (in = _0, i = n; i; --i) in = f[i](in);\n\tlinear t(_1, _0); M.reserve(n + 1), M.rehash(20030731);\n\tfor (i = 0; i <= n; t = t * f[++i]) ans += query(t(_0)), ++M[t(in)];\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define fst first\n#define snd second\n#define SZ(u) ((int) (u).size())\n#define ALL(u) (u).begin(), (u).end()\n\ninline void proc_status()\n{\n    ifstream t(\"/proc/self/status\");\n    cerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline T read()\n{\n\tregister T sum(0), fg(1);\n\tregister char ch(getchar());\n\tfor(; !isdigit(ch); ch = getchar()) if(ch == '-') fg = -1;\n\tfor(;  isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) - '0' + ch;\n\treturn sum * fg;\n}\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int, int> pii;\n\nconst int MAXN = (int) 2.5e5;\n\nint n;\n\nchar s[MAXN + 5];\n\ninline void input()\n{\n\tn = read<int>();\n\tscanf(\"%s\", s + 1);\n}\n\nconst LL MOD = (1ll << 61) - 1, B = (int) 233;\n\ninline LL fpm(LL x, LL y)\n{\n\tLL res = 1;\n\tfor(; y; y >>= 1, x = (__int128) x * x % MOD) if(y & 1) res = (__int128) res * x % MOD;\n\treturn res;\n}\n\ninline void solve()\n{\n\tstatic LL p[MAXN + 5], prefix[MAXN + 5], p_pow[MAXN * 2 + 5];\n\n\tp_pow[0 + n] = 1;\n\tfor(int i = 1, invB = fpm(B, MOD - 2); i <= n; ++i)\n\t{\n\t\tp_pow[ i + n] = (__int128) p_pow[ i - 1 + n] *\tB % MOD;\n\t\tp_pow[-i + n] = (__int128) p_pow[-i + 1 + n] * invB % MOD;\n\t}\n\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tp[i] = p[i - 1], prefix[i] = prefix[i - 1];\n\t\tif(s[i] == '<') --p[i];\n\t\tif(s[i] == '>') ++p[i];\n\t\tif(s[i] == '+') (prefix[i] += p_pow[p[i] + n]) %= MOD;\n\t\tif(s[i] == '-') (prefix[i] -= p_pow[p[i] + n]) %= MOD;\n\t}\n\tfor(int i = 1; i <= n; ++i) (prefix[i] += MOD) %= MOD;\n\n\tstatic unordered_map<LL, int> cnt;\n\n\tLL ans = 0;\n\tfor(int i = 1; i <= n; ++i) ans += prefix[i] == prefix[n];\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tans += cnt[prefix[i]];\n\t\tLL res = (prefix[i] + (__int128) p_pow[p[i] + n] * prefix[n] % MOD) % MOD;\n\t\t++cnt[res];\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main()\n{\n//\tfreopen(\"F.in\", \"r\", stdin);\n//\tfreopen(\"F.out\", \"w\", stdout);\n\n\tinput();\n\tsolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//I love armpit fetish\n\n#include <bits/stdc++.h>\nusing namespace std;\n \n#define debug(x) cerr << #x << \" = \" << x << '\\n';\n#define BP() cerr << \"OK!\\n\";\n#define PR(A, n) {cerr << #A << \" = \"; for (int _=1; _<=n; ++_) cerr << A[_] << ' '; cerr << '\\n';}\n#define PR0(A, n) {cerr << #A << \" = \"; for (int _=0; _<n; ++_) cerr << A[_] << ' '; cerr << '\\n';}\n#define FILE_NAME \"data\"\n\nconst int MAX_N = 500002;\nconst int offset = 250002;\nconst int T = 260000;\nconst int64_t MOD = 1000000000000000031LL;\n\nint n, cnt[MAX_N];\nstring s;\nint64_t pref_hash[MAX_N], suff_hash[MAX_N];\n\nint64_t mul(int64_t a, int64_t b) {\n\tint64_t res = 0;\n\twhile (b) {\n\t\tif (b%2)\n\t\t\tres = (res + a) % MOD;\n\t\ta = a * 2 % MOD;\n\t\tb = b / 2;\n\t}\n\treturn res;\n}\n\nvoid enter() {\n\tcin >> n >> s;\n}\n\nint64_t pw(int n, int k) {\n\tif (k==0)\n\t\treturn 1;\n\tint64_t tmp = pw(n, k/2);\n\tif (k%2)\n\t\treturn mul(mul(tmp, tmp), n);\n\treturn mul(tmp, tmp);\n}\n\nvoid init_pref() {\n\tint p = offset;\n\tint64_t H = 0;\n\tfor (int i=0; i<n; ++i) {\n\t\tif (s[i]=='<' || s[i]=='>') {\n\t\t\tp += (s[i]=='<' ? -1 : 1);\n\t\t\tcnt[i] = cnt[i-1] + (s[i]=='<' ? -1 : 1);\n\t\t}\n\t\telse {\n\t\t\tH = (H - pw(T, p) * (s[i]=='-' ? 1 : -1)) % MOD;\n\t\t}\n\t\tpref_hash[i] = (H + MOD) % MOD;\n\t}\n}\n\nvoid init_suff() {\n\tint64_t H = pref_hash[n-1];\n\tint p = offset;\n\tfor (int i=0; i<n; ++i) {\n\t\tif (s[i]=='>' || s[i]=='<')\n\t\t\tp += (s[i]=='>' ? 1 : -1);\n\t\telse\n\t\t\tH = (H + pw(T, p) * (s[i]=='+' ? -1 : 1)) % MOD;\n\t\tsuff_hash[i+1] = (H + MOD) % MOD;\n\t}\n}\n\nint64_t solve() {\n\tmap<int64_t, int> mp;\n\tint64_t H = pref_hash[n-1];\n\tint64_t res = 0;\n\tfor (int j=0; j<n; ++j) {\n\t\tif (j==0)\n\t\t\t++mp[0];\n\t\telse\n\t\t\t++mp[((H - pref_hash[j-1] - mul(H, pw(T, cnt[j-1]))) % MOD + MOD) % MOD];\n\t\tres += mp[suff_hash[j+1]];\n\t}\n\treturn res;\n}\n\nint main() {\n\t//#define OFFLINE_JUDGE doraemon\n\t#ifdef OFFLINE_JUDGE\n\t\tfreopen(FILE_NAME\".inp\", \"r\", stdin);\n\t\tfreopen(FILE_NAME\".out\", \"w\", stdout);\n\t#endif\n\tios::sync_with_stdio(0); cin.tie(0);\n\tenter();\n\tinit_pref();\n\tinit_suff();\n\tcout << solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=300005,K=2,p=998244353;\nint read(){\n\tint f=1,g=0;\n\tchar ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-') f=-1;\n\tfor (;isdigit(ch);ch=getchar()) g=g*10+ch-'0';\n\treturn f*g;\n}\nint qpow(int x,int k){\n\tint t=1;\n\tfor (;k;k>>=1){\n\t\tif (k&1) t=(ll)t*x%p;\n\t\tx=(ll)x*x%p;\n\t}\n\treturn t;\n}\nstruct state{\n\tint a[K];\n\tint &operator[](int i){return a[i];}\n\tstate(){memset(a,0,sizeof(a));}\n}x,rx,s[N][2],c,e;\nbool operator==(state a,state b){\n\tfor (int i=0;i<K;i++)\n\tif (a[i]==b[i]) return false;\n\treturn true;\n}\nbool operator<(state a,state b){\n\tfor (int i=0;i<K;i++)\n\tif (a[i]!=b[i]) return a[i]<b[i];\n\treturn false;\n}\nstate operator*(state x,state y){for (int i=0;i<K;i++) x[i]=(ll)x[i]*y[i]%p;return x;}\nstate operator+(state x,state y){for (int i=0;i<K;i++) if((x[i]+=y[i])>=p) x[i]-=p;return x;}\nstate operator-(state x,state y){for (int i=0;i<K;i++) if((x[i]-=y[i])<0) x[i]+=p;return x;}\nstate operator+(state x,int k){for (int i=0;i<K;i++) if ((x[i]+=k)>=p) x[i]-=p;return x;}\nstate operator-(state x,int k){for (int i=0;i<K;i++) if ((x[i]-=k)<0) x[i]+=p;return x;}\nstate getval(state *a,state x){\n\tstate cur=a[0]+a[1]*x;\n\treturn cur;\n}\nint n,m;\nll ans;\nchar ch[N];\nmap<state,int> f;\nint main(){\n\tfor (int i=0;i<K;i++) x[i]=i+1,rx[i]=qpow(x[i],p-2);\n\tn=read();\n\tscanf(\" %s\",ch+1);\n\tfor (int i=0;i<K;i++) s[n+1][1][i]=1;\n\tfor (int i=n;i;i--)\n\tif (ch[i]=='+'){s[i][0]=s[i+1][0]+s[i+1][1];s[i][1]=s[i+1][1];c=c-1;}\n\telse if (ch[i]=='-'){s[i][0]=s[i+1][0]-s[i+1][1];s[i][1]=s[i+1][1];c=c+1;}\n\telse if (ch[i]=='>'){s[i][0]=s[i+1][0];s[i][1]=s[i+1][1]*x;c=c*rx;}\n\telse if (ch[i]=='<'){s[i][0]=s[i+1][0];s[i][1]=s[i+1][1]*rx;c=c*x;}\n\tfor (int i=n;i;i--){\n\t\tf[getval(s[i+1],e)]++;\n\t\tans+=f[getval(s[i],c)];\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n\ntypedef pair<int, int> ii;\n\nconst int B = 1e6 + 7;\n\nconst int N = 250005;\n\nconst int mod1 = 1e9 + 7;\nconst int mod2 = 1e9 + 9;\n\nint cnt = N - 5, pw[2][2 * N], lmao[N], n, hs[2][N];\n\nlong long sum = 0;\n\nstring s;\n\nii type;\n\nmap<ii, int> mymap;\n\nint BinPow(int x, int m, int mod) {\n    if(m == 0)\n        return 1;\n    else if(m == 1)\n        return x % mod;\n    else {\n        int sum = BinPow(x, m >> 1, mod);\n        sum = (1ll * sum * sum) % mod;\n        if(m % 2)\n            sum = (1ll * sum * x) % mod;\n        return sum;\n    }\n}\n\nint main() {\n    cin.tie(0), ios::sync_with_stdio(0);\n    cin >> n;\n    cin >> s;\n    s = \"+\" + s;\n    pw[0][0] = pw[1][0] = 1;\n    for(int i = 1; i <= 2 * N - 10; i++) {\n        pw[0][i] = (1ll * pw[0][i - 1] * B) % mod1;\n        pw[1][i] = (1ll * pw[1][i - 1] * B) % mod2;\n    }\n    for(int i = 1; i <= n; i++) {\n        lmao[i] = cnt;\n        if(s[i] == '+') {\n            hs[0][i] = (1ll * hs[0][i - 1] + pw[0][cnt]) % mod1;\n            hs[1][i] = (1ll * hs[1][i - 1] + pw[1][cnt]) % mod2;\n        }\n        if(s[i] == '-') {\n            hs[0][i] = (1ll * hs[0][i - 1] - pw[0][cnt]) % mod1;\n            hs[1][i] = (1ll * hs[1][i - 1] - pw[1][cnt]) % mod2;\n            hs[0][i] = (1ll * hs[0][i] + mod1) % mod1;\n            hs[1][i] = (1ll * hs[1][i] + mod2) % mod2;\n        }\n        if(s[i] == '>'){\n            cnt++;\n            hs[0][i] = (1ll * hs[0][i - 1] + mod1) % mod1;\n            hs[1][i] = (1ll * hs[1][i - 1] + mod2) % mod2;\n        }\n        if(s[i] == '<'){\n            cnt--;\n            hs[0][i] = (1ll * hs[0][i - 1] + mod1) % mod1;\n            hs[1][i] = (1ll * hs[1][i - 1] + mod2) % mod2;\n        }\n    }\n    int x1 = (1ll * hs[0][n] * BinPow(pw[0][lmao[1]], mod1 - 2, mod1)) % mod1;\n    int x2 = (1ll * hs[1][n] * BinPow(pw[1][lmao[1]], mod2 - 2, mod2)) % mod2;\n    type = {x1, x2};\n    for(int i = n; i >= 1; i--) {\n        mymap[{hs[0][i], hs[1][i]}]++;\n        x1 = ((1ll * type.fi * pw[0][lmao[i]]) % mod1 + 1ll * hs[0][i - 1]) % mod1;\n        x2 = ((1ll * type.fi * pw[1][lmao[i]]) % mod2 + 1ll * hs[1][i - 1]) % mod2;\n        sum += mymap[{x1, x2}];\n    }\n    cout << sum << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <cmath>\n#include <map>\n#define enter putchar('\\n')\n#define space putchar(' ')\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define eps 1e-7\n#define MAXN 250005\n#define MOD 999999137\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef double db;\ntypedef vector<int> poly;\n\ntemplate<class T>\nvoid read(T &res) {\n\tres = 0;char c = getchar();T f = 1;\n\twhile(c < '0' || c > '9') {\n\t\tif(c == '-') f = -1;\n\t\tc = getchar();\n\t}\n\twhile(c >= '0' && c <= '9') {\n\t\tres = res * 10 + c - '0';\n\t\tc = getchar();\n\t}\n\tres *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n\tif(x < 0) {putchar('-');x = -x;}\n\tif(x >= 10) {\n\t\tout(x / 10);\n\t}\n\tputchar('0' + x % 10);\n}\nint B[] = {0,397,823,727,401,271,983,571};\nint InvB[10];\nint f[8][MAXN],g[8][MAXN],N,h[8][MAXN];\nchar s[MAXN];\nmap<int,int> MK[8];\n\n\nint mul(int a,int b) {\n\treturn 1LL * a * b % MOD;\n}\nint inc(int a,int b) {\n\treturn a + b >= MOD ? a + b - MOD : a + b;\n}\nvoid update(int &x,char c,int id) {\n\tif(c == '<') x = mul(x,InvB[id]);\n\telse if(c == '>') x = mul(x,B[id]);\n\telse if(c == '+') x = inc(x,1);\n\telse x = inc(x,MOD - 1);\n}\nint fpow(int x,int c) {\n\tint res = 1,t = x;\n\twhile(c) {\n\t\tif(c & 1) res = mul(res,t);\n\t\tt = mul(t,t);\n\t\tc >>= 1;\n\t}\n\treturn res;\n}\nvoid Solve() {\n\tfor(int i = 1 ; i <= 7 ; ++i) InvB[i] = fpow(B[i],MOD - 2);\n\tread(N);\n\tscanf(\"%s\",s + 1);\n\tint c[10] = {0};\n\tfor(int k = 1 ; k <= 7 ; ++k) {\n\t\tfor(int i = N ; i >= 1 ; --i) {\n\t\t\tupdate(c[k],s[i],k);\n\t\t}\n\t}\n\tfor(int k = 1 ; k <= 7 ; ++k) h[k][N + 1] = 1,g[k][N + 1] = c[k],MK[k][0] += 1;\n\tint64 ans = 0;\n\tfor(int i = N ; i >= 1 ; --i) {\n\t\tint add = N - i + 1;\n\t\tfor(int k = 1 ; k <= 7 ; ++k) {\n\t\t\tif(s[i] == '<') {\n\t\t\t\tg[k][i] = inc(g[k][i + 1],MOD - mul(h[k][i + 1],c[k]));\n\t\t\t\th[k][i] = mul(h[k][i + 1],B[k]);\n\t\t\t\tg[k][i] = inc(g[k][i],mul(h[k][i],c[k]));\n\t\t\t\tf[k][i] = f[k][i + 1];\t\t\n\t\t\t}\n\t\t\telse if(s[i] == '>') {\n\t\t\t\tg[k][i] = inc(g[k][i + 1],MOD - mul(h[k][i + 1],c[k]));\n\t\t\t\th[k][i] = mul(h[k][i + 1],InvB[k]);\n\t\t\t\tg[k][i] = inc(g[k][i],mul(h[k][i],c[k]));\n\t\t\t\tf[k][i] = f[k][i + 1];\n\t\t\t}\n\t\t\telse if(s[i] == '+') {\n\t\t\t\th[k][i] = h[k][i + 1];\n\t\t\t\tg[k][i] = inc(g[k][i + 1],MOD - h[k][i]);\n\t\t\t\tf[k][i] = inc(f[k][i + 1],MOD - h[k][i]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\th[k][i] = h[k][i + 1];\n\t\t\t\tg[k][i] = inc(g[k][i + 1],h[k][i]);\n\t\t\t\tf[k][i] = inc(f[k][i + 1],h[k][i]);\n\t\t\t}\n\t\t\tadd = min(add,MK[k][g[k][i]]);\n\t\t\tMK[k][f[k][i]] += 1;\n\t\t}\n\t\tans += add;\n\t}\n\tout(ans);enter;\t\n}\nint main() {\n#ifdef ivorysi\n\tfreopen(\"f1.in\",\"r\",stdin);\n#endif\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\nusing namespace std;\n\n#define P1 1000000007LL\n#define P2 1000000009LL\ntypedef long long Int;\nmap<Int, Int> cs;\nInt sum[250001];\nInt pos[250001];\nInt res;\nInt n;\nstring str;\nInt pow(Int x, Int y, Int M){\n\tif(y < 0){\n\t\ty %= M-1;\n\t\tif(y < 0);\n\t\ty += M-1;\n\t}\n\tif(y == 0)return 1;\n\tInt res = pow(x, y/2, M);\n\tres = res * res % M;\n\tif(y % 2)res *= x;\n\treturn x % M;\n}\n\nInt rev(Int x, Int M){\n\treturn pow(x, M-2, M);\n}\n\nint main(){\n\tInt p = 0;\n\tInt tmp = 0;\n\tcin >> n;\n\tcin >> str;\n\tfor(int i = 0;i < n;i++){\n\t\tif(str[i] == '+')tmp = (tmp + pow(1000000, p, P1))%P1;\n\t\tif(str[i] == '-')tmp = (tmp - pow(1000000, p, P1))%P1;\n\t\tif(str[i] == '>')p++;\n\t\tif(str[i] == '<')p--;\n\t\tsum[i+1] = tmp;\n\t\tpos[i+1] = p;\n\n\t}\n\tInt last = sum[n];\n\tfor(int i = n;i >= 0;i--){\n\t\tInt tmp = ((last - last * pow(1000000, pos[i], P1) % P1) % P1 + P1)% P1;\n\t\tres += cs[((tmp - sum[i])%P1 + P1) % P1];\n\t\tInt c = ((last - sum[i] % P1) +P1) % P1;\n\t\tif(cs.count(c) == 0)cs[c] = 0;\n\t\tcs[c]++;\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2e5 + 5;\n//const int mod = 1e9 + 7;\ntypedef long long ll;\n#define mp make_pair\n\nchar c;\nstring s;\nint n,i,ans;\nmap < pair < int , int > , int > M;\n\n\nstruct hashh{\n    ll t,a,b,x,bol,X,mod;\n    hash() { t=b=x=X=mod=0; a=bol=1; }\n    void f(){ \n        for(t=X,i=mod-2; i ; i>>=1){\n            if(i & 1) bol = bol*t % mod;\n            t = t*t % mod;\n        }\n        for(i=n-1; i>=0 ;i--){\n            c = s[i];\n            if(c == '-') x--;\n            if(c == '+') x++;\n            if(c == '>') x *= X;\n            if(c == '<') x *= bol;\n            x = (x % mod + mod) % mod;\n        }\n    }       \n                \n    void g(){               \n        if(c == '+') b -= a;                \n        if(c == '-') b += a;                            \n        if(c == '>') a *= bol;                                  \n        if(c == '<') a *= X;        \n        a = (a % mod + mod) % mod;                  \n        b = (b % mod + mod) % mod;                              \n        t = (a*x + b) % mod;                                                \n    }                                                                                   \n};                                                                                                  \n                                                                                                                \nint main(){                                                                                                             \n    cin >> n >> s;                      \n                                                                                                                            \n    hashh h1,h2;    \n    h1.mod = 1e9+7;  h1.X=10000003; h1.f();\n    h2.mod = 1e9+9;  h2.X=1000007; h2.f();\n                                                \n    M[mp(0,0)] = 1;                                     \n    for(i=n-1; i>=0 ;i--){                                      \n        c = s[i];                                                       \n        h1.g(); h2.g();                                                         \n                                                                                    \n        ans += M[mp(h1.t,h2.t)];                                                    \n        M[mp(h1.b,h2.b)]++;                                                             \n    }\n        \n    cout << ans;\n    return 0;\n}    "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 250005;\nconst int P = 1e9 + 7;\nconst int val[6] = {18, 40, 23, 2333333, 58, 720};\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\ntemplate <typename T> void write(T x) {\n\tif (x < 0) x = -x, putchar('-');\n\tif (x > 9) write(x / 10);\n\tputchar(x % 10 + '0');\n}\ntemplate <typename T> void writeln(T x) {\n\twrite(x);\n\tputs(\"\");\n}\nstruct Hash {int val[6]; };\nstruct info {Hash k, b; };\nbool operator < (Hash a, Hash b) {\n\tfor (int i = 0; i <= 5; i++)\n\t\tif (a.val[i] != b.val[i]) return a.val[i] < b.val[i];\n\treturn false;\n}\nmap <Hash, int> mp;\nchar s[MAXN];\nint inv[6];\nHash unit() {\n\tHash ans;\n\tmemset(ans.val, 0, sizeof(ans.val));\n\treturn ans;\n}\ninfo unitinfo() {\n\tinfo ans;\n\tfor (int i = 0; i <= 5; i++) {\n\t\tans.b.val[i] = 0;\n\t\tans.k.val[i] = 1;\n\t}\n\treturn ans;\n}\nHash operator * (Hash x, info a) {\n\tHash ans;\n\tfor (int i = 0; i <= 5; i++)\n\t\tans.val[i] = (1ll * a.k.val[i] * x.val[i] + a.b.val[i]) % P;\n\treturn ans;\n}\nint power(int x, int y) {\n\tif (y == 0) return 1;\n\tint tmp = power(x, y / 2);\n\tif (y % 2 == 0) return 1ll * tmp * tmp % P;\n\telse return 1ll * tmp * tmp % P * x % P;\n}\nvoid pls(Hash &tmp) {\n\tfor (int i = 0; i <= 5; i++)\n\t\ttmp.val[i] = (tmp.val[i] + 1) % P;\n}\nvoid mns(Hash &tmp) {\n\tfor (int i = 0; i <= 5; i++)\n\t\ttmp.val[i] = (tmp.val[i] + P - 1) % P;\n}\nvoid rit(Hash &tmp) {\n\tfor (int i = 0; i <= 5; i++)\n\t\ttmp.val[i] = (1ll * tmp.val[i] * val[i]) % P;\n}\nvoid lft(Hash &tmp) {\n\tfor (int i = 0; i <= 5; i++)\n\t\ttmp.val[i] = (1ll * tmp.val[i] * inv[i]) % P;\n}\nvoid pls(info &tmp) {\n\tfor (int i = 0; i <= 5; i++)\n\t\ttmp.b.val[i] = (tmp.b.val[i] + tmp.k.val[i]) % P;\n}\nvoid mns(info &tmp) {\n\tfor (int i = 0; i <= 5; i++)\n\t\ttmp.b.val[i] = (tmp.b.val[i] + P - tmp.k.val[i]) % P;\n}\nvoid rit(info &tmp) {\n\tfor (int i = 0; i <= 5; i++)\n\t\ttmp.k.val[i] = (1ll * tmp.k.val[i] * val[i]) % P;\n}\nvoid lft(info &tmp) {\n\tfor (int i = 0; i <= 5; i++)\n\t\ttmp.k.val[i] = (1ll * tmp.k.val[i] * inv[i]) % P;\n}\nint main() {\n\tfor (int i = 0; i <= 5; i++)\n\t\tinv[i] = power(val[i], P - 2);\n\tint n; read(n);\n\tscanf(\"\\n%s\", s + 1);\n\tHash now = unit();\n\tfor (int i = n; i >= 1; i--) {\n\t\tif (s[i] == '+') pls(now);\n\t\tif (s[i] == '-') mns(now);\n\t\tif (s[i] == '>') rit(now);\n\t\tif (s[i] == '<') lft(now);\n\t}\n\tHash tmp = unit(); mp[tmp]++;\n\tinfo Now = unitinfo(), Tmp = unitinfo();\n\tlong long ans = 0;\n\tfor (int i = n; i >= 1; i--) {\n\t\tif (s[i] == '-') pls(Now), pls(Tmp);\n\t\tif (s[i] == '+') mns(Now), mns(Tmp);\n\t\tif (s[i] == '<') rit(Now), rit(Tmp);\n\t\tif (s[i] == '>') lft(Now), lft(Tmp);\n\t\tans += mp[now * Now];\n\t\tmp[tmp * Tmp]++;\n\t}\n\twriteln(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int N = 250033, mod1 = 1000000007, mod2 = 1000109107;\nint qpow(int b, int p, int m) {\n  int r = 1;\n  for (; p; p >>= 1, b = (ll) b * b % m) if (p & 1) r = (ll) r * b % m;\n  return r;\n}\nstruct data {\n  int x, y;\n  data(int x = 0, int y = 0) : x(x), y(y) {}\n  data operator + (const data &d) const {return data((x + d.x) % mod1, (y + d.y) % mod2);}\n  data operator - (const data &d) const {return data((x + mod1 - d.x) % mod1, (y + mod2 - d.y) % mod2);};\n  data operator * (const data &d) const {return data((ll) x * d.x % mod1, (ll) y * d.y % mod2);}\n  data operator / (const data &d) const {return data((ll) x * qpow(d.x, mod1 - 2, mod1) % mod1, (ll) y * qpow(d.y, mod2 - 2, mod2) % mod2);}\n  ll get() {return (ll) x << 30 | y;}\n};\ndata X(159623, 102647), f[N], g[N], h[N], k(1, 1), b;\nint n;\nll ans;\nchar s[N];\nmap<ll, int> mp;\n\nint main() {\n  scanf(\"%d%s\", &n, s + 1);\n  for (int i = 1; i <= n; i++) {\n    if (s[i] == '+') b = b + k;\n    if (s[i] == '-') b = b - k;\n    if (s[i] == '>') k = k * X;\n    if (s[i] == '<') k = k / X;\n    f[i] = b;\n  }\n  g[0] = k = data(1, 1), h[0] = b = data(0, 0);\n  for (int i = 1; i <= n; i++) {\n    if (s[i] == '+') b = b - data(1, 1);\n    if (s[i] == '-') b = b + data(1, 1);\n    if (s[i] == '>') k = k / X, b = b / X;\n    if (s[i] == '<') k = k * X, b = b * X;\n    g[i] = k, h[i] = b;\n  }\n  for (int i = n; i >= 0; i--) {\n    data t = (f[n] - h[i]) / g[i];\n    ans += mp[t.get()];\n    mp[f[i].get()]++;\n  }\n  printf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cmath>\n#include<cstdlib>\n#include<map>\n#define LL long long\n#define LD long double\nusing namespace std;\nconst int NN=250000 +117;\nconst int MM= +117;\nint read(){\n\tint fl=1,x;char c;\n\tfor(c=getchar();(c<'0'||c>'9')&&c!='-';c=getchar());\n\tif(c=='-'){fl=-1;c=getchar();}\n\tfor(x=0;c>='0'&&c<='9';c=getchar())\n\t\tx=(x<<3)+(x<<1)+c-'0';\n\treturn x*fl;\n}\nvoid open(){\n\tfreopen(\"99f.in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n}\nvoid close(){\n\tfclose(stdin);\n\tfclose(stdout);\n}\n\n\nint m,n;\nmap<pair<LL,LL>,int> a;\nchar s[NN]={};\nLL mod[2]={998244353,2281701377};\nLL ksm(LL a,LL b,LL mod){\n\tLL ret=1;\n\twhile(b){\n\t\tif(b&1){\n\t\t\tret*=a;\n\t\t\tret%=mod;\n\t\t}\n\t\ta*=a;\n\t\ta%=mod;\n\t\tb>>=1;\n\t}\n\treturn ret;\n}\ninline void mop(LL &x,LL y,LL mod){\n\tx=(x+y>=mod?x+y-mod:x+y);\n}\nint main(){\n\t//open();\n\tn=read();\n\tscanf(\"%s\",s);\n\tLL res[2]={0,0};\n\tLL rev[2];\n\trev[0]=ksm(mod[0],mod[1]-2,mod[1]);\n\trev[1]=ksm(mod[1],mod[0]-2,mod[0]);\n\tLL p[2]={1,1};\n\tfor(int i=0;i<n;++i){\n\t\tif(s[i]=='+'){\n\t\t\tfor(int i=0;i<2;++i){\n\t\t\t\tmop(res[i],p[i],mod[i]);\n\t\t\t}\n\t\t}\n\t\telse if(s[i]=='-'){\n\t\t\tfor(int i=0;i<2;++i){\n\t\t\t\t\n\t\t\t\tmop(res[i],mod[i]-p[i],mod[i]);\n\t\t\t}\n\t\t}\n\t\telse if(s[i]=='<'){\n\t\t\tfor(int i=0;i<2;++i){\n\t\t\t\tp[i]*=rev[i^1];\n\t\t\t\tp[i]%=mod[i];\n\t\t\t}\n\t\t}\n\t\telse if(s[i]=='>'){\n\t\t\tfor(int i=0;i<2;++i){\n\t\t\t\tp[i]*=mod[i^1];\n\t\t\t\tp[i]%=mod[i];\n\t\t\t}\n\t\t}\n\t}\n\tp[0]=1;\n\tp[1]=1;\n\tLL tp[2]={0,0};\n\tLL ans=0;\n\tfor(int i=0;i<n;++i){\n\t\ta[make_pair((tp[0]+p[0]*res[0])%mod[0],(tp[1]+p[1]*res[1])%mod[1])]++;;\n\t\tif(s[i]=='+'){\n\t\t\tfor(int i=0;i<2;++i){\n\t\t\t\tmop(tp[i],p[i],mod[i]);\n\t\t\t}\n\t\t}\n\t\telse if(s[i]=='-'){\n\t\t\tfor(int i=0;i<2;++i){\n\t\t\t\tmop(tp[i],mod[i]-p[i],mod[i]);\n\t\t\t}\n\t\t}\n\t\telse if(s[i]=='<'){\n\t\t\tfor(int i=0;i<2;++i){\n\t\t\t\tp[i]*=rev[i^1];\n\t\t\t\tp[i]%=mod[i];\n\t\t\t}\n\t\t}\n\t\telse if(s[i]=='>'){\n\t\t\tfor(int i=0;i<2;++i){\n\t\t\t\tp[i]*=mod[i^1];\n\t\t\t\tp[i]%=mod[i];\n\t\t\t}\n\t\t}\n\t\tans+=a[make_pair(tp[0],tp[1])];\n\t}\n\tprintf(\"%lld\\n\",ans);\n\tclose();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int C = 3e5 + 7;\nconst int N = C << 1;\nconst int BASE = C;\nconst int MOD1 = 1000 * 1000 * 1000 + 7;\nconst int MOD2 = 1000 * 1000 * 1000 + 9;\nint mod1(int n) {\n    return (n % MOD1 + MOD1) % MOD1;\n}   \nint mod2(int n) {\n    return (n % MOD2 + MOD2) % MOD2;\n}   \nint x[N], pw1[N], pw2[N];\nvoid add1(int &a, int b) {\n    a = mod1(a + b);\n}   \nvoid add2(int &a, int b) {\n    a = mod2(a + b);\n}   \nint fp1(int a, int p) {\n    int ans = 1, c = a;\n    for (int i = 0; (1ll << i) <= p; ++i) {\n        if ((p >> i) & 1) ans = mod1(ans * c);\n        c = mod1(c * c);\n    }   \n    return ans;\n}   \nint dv1(int a, int b) {\n    return mod1(a * fp1(b, MOD1 - 2));\n}   \nint fp2(int a, int p) {\n    int ans = 1, c = a;\n    for (int i = 0; (1ll << i) <= p; ++i) {\n        if ((p >> i) & 1) ans = mod2(ans * c);\n        c = mod2(c * c);\n    }   \n    return ans;\n}   \nint dv2(int a, int b) {\n    return mod2(a * fp2(b, MOD2 - 2));\n}   \nint pref1[N], pref2[N];\nsigned main() {\n    #ifdef HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    #else\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    #endif\n    pw1[0] = 1;\n    for (int i = 1; i < N; ++i) pw1[i] = mod1(pw1[i - 1] * BASE);\n    pw2[0] = 1;\n    for (int i = 1; i < N; ++i) pw2[i] = mod2(pw2[i - 1] * BASE);\n    int n;\n    cin >> n;\n    string s;\n    cin >> s;\n    for (int i = 0; i < n; ++i) {\n        pref1[i + 1] = pref1[i];\n        pref2[i + 1] = pref2[i];\n        x[i + 1] = x[i];\n        if (s[i] == '<') --x[i + 1];\n        else if (s[i] == '>') ++x[i + 1];\n        else if (s[i] == '+') {\n            add1(pref1[i + 1], pw1[x[i + 1] + C]);\n            add2(pref2[i + 1], pw2[x[i + 1] + C]);\n        }\n        else {\n            add1(pref1[i + 1], -pw1[x[i + 1] + C]);\n            add2(pref2[i + 1], -pw2[x[i + 1] + C]);\n        }\n    }\n    int ans = 0;\n    map <pair <int, int>, int> d;\n    for (int i = n; i >= 0; --i) {\n        pair <int, int> w;\n        if (x[i] < 0) {\n            w.first = mod1(pref1[i] + dv1(pref1[n], pw1[-x[i]]));\n            w.second = mod2(pref2[i] + dv2(pref2[n], pw2[-x[i]]));\n        }\n        else {\n            w.first = mod1(pref1[i] + mod1(pref1[n] * pw1[x[i]]));\n            w.second = mod2(pref2[i] + mod2(pref2[n] * pw2[x[i]]));\n        }\n        ans += d[w];\n        d[{pref1[i], pref2[i]}]++;\n    }   \n    cout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<random>\n#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\ntypedef unsigned long long ULL;\nusing HashMap = gp_hash_table<ULL, int>;\n\nULL add(ULL x, ULL y, ULL m) {\n    if ((x += y) >= m) x -= m;\n    return x;\n}\nULL mul(ULL x, ULL y, ULL m) {\n    (x *= y) %= m;\n    return x;\n}\n\nULL gcd(ULL x, ULL y) {\n    while (1) {\n\tif (x) y %= x; else return y;\n\tif (y) x %= y; else return x;\n    }\n}\n\n// xs + yt = gcd(x, y), xu + yv = 0\n// abs(s) < abs(y / gcd(x, y));\n// abs(t) < abs(x / gcd(x, y));\nLL extgcd(LL x, LL y, LL&s, LL&t) {\n    for (LL u=t=1, v=s=0; x; ) {\n\tLL q = y / x;\n\tswap(s -= q * u, u);\n\tswap(t -= q * v, v);\n\tswap(y -= q * x, x);\n    }\n    return y;\n}\n\nLL invMod(LL a, LL mod) {\n    LL x, y;\n    if (extgcd(a, mod, x, y) == 1) return (x + mod) % mod;\n    return 0; // unsolvable\n}\nint N;\nchar S[250011];\n\nconst int SIZE = 3;\nULL MOD[SIZE];\nULL B[SIZE];\nULL INV_B[SIZE];\nULL C[SIZE];\nULL VAL[SIZE];\nULL WHOLE[SIZE];\nHashMap mp[SIZE];\n\nmt19937 engine(285694);\n\nvoid MAIN() {\n    scanf(\"%d%s\", &N, S);\n\n    REP (t, SIZE) {\n\tC[t] = 1;\n\twhile (1) {\n\t    MOD[t] = engine() % 1000000009;\n\t    if (MOD[t] == 0) continue;\n\t    B[t] = engine() % MOD[t];\n\t    ULL g = gcd(MOD[t], B[t]);\n\t    MOD[t] /= g;\n\t    B[t] /= g;\n\t    if (B[t] <= 1 || B[t] == MOD[t]-1) continue;\n\t    INV_B[t] = invMod(B[t], MOD[t]);\n\t    break;\n\t}\n    }\n\n    REP (i, N) {\n\tREP (t, SIZE) {\n\t    ULL &val = VAL[t];\n\t    ULL &c = C[t];\n\t    const ULL mod = MOD[t];\n\t    const ULL b = B[t];\n\t    const ULL invB = INV_B[t];\n\n\t    if (false) {\n\t    } else if (S[i] == '>') {\n\t\tc = mul(c, b, mod);\n\t    } else if (S[i] == '<') {\n\t\tc = mul(c, invB, mod);\n\t    } else if (S[i] == '+') {\n\t\tval = add(val, c, mod);\n\t    } else if (S[i] == '-') {\n\t\tval = add(val, mod-c, mod);\n\t    }\n\t}\n    }\n\n    REP (t, SIZE) WHOLE[t] = VAL[t];\n\n    LL ans = 0;\n    for (int i=N; i--;) {\n\tint z = N;\n\tREP (t, SIZE) {\n\t    ULL &val = VAL[t];\n\t    ULL &c = C[t];\n\t    const ULL mod = MOD[t];\n\t    const ULL b = B[t];\n\t    const ULL invB = INV_B[t];\n\t    const ULL whole = WHOLE[t];\n\t    mp[t][val]++;\n\n\t    if (false) {\n\t    } else if (S[i] == '>') {\n\t\tc = mul(c, invB, mod);\n\t    } else if (S[i] == '<') {\n\t\tc = mul(c, b, mod);\n\t    } else if (S[i] == '+') {\n\t\tval = add(val, mod-c, mod);\n\t    } else if (S[i] == '-') {\n\t\tval = add(val, c, mod);\n\t    }\n\n\t    //EACH (e, mp[t]) {\n\t    //    eprintf(\"(%llu %d)\", e->first, e->second);\n\t    //}\n\t    ULL key = add(val, mul(c, whole, mod), mod);\n\t    //eprintf(\": %llu\\n\", key);\n\t    auto it = mp[t].find(key);\n\t    if (it == mp[t].end()) {\n\t\tz = 0;\n\t    } else {\n\t\tamin(z, it->second);\n\t    }\n\t}\n\n\tans += z;\n    }\n\n    printf(\"%lld\\n\", ans);\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "        #include \"bits/stdc++.h\"\n        using namespace std;\n         \n        #define MAX 600012\n         \n        int n;\n        char buf[MAX];\n         \n         \n        string s;\n         \n         \n        //#define MOD1 1000000007\n        //#define MOD2 1000000009\n         \n        valarray<long long int> MOD1;\n        valarray<long long int> MOD2;\n        vector<valarray<long long int> > p2;\n        vector<valarray<long long int> > vv;\n        vector<int> ps;\n        map<pair<long long int,long long int>, int> mp;\n        long long int ppow(long long int i, long long int j, long long int MOD) {\n        \tlong long int ret = 1;\n        \twhile (j) {\n        \t\tif (j & 1LL)ret *= i;\n        \t\tif (ret >= MOD)ret %= MOD;\n        \t\tj >>= 1LL;\n        \t}\n        \treturn ret;\n        }\n         \n        valarray<long long int> calc(int dif) {\n        \tvalarray<long long int> ret;\n        \tret.resize(2, 0);\n        \tfor (int j = 0; j < 2; j++) {\n        \t\tif (dif < 0) {\n        \t\t\tret[j]=ppow(ppow(MOD1[j],MOD2[j]-2,MOD2[j]),-dif,MOD2[j]);\n        \t\t}\n        \t\telse {\n        \t\t\tret[j] = ppow(MOD1[j], abs(dif), MOD2[j]);\n        \t\t}\n        \t}\n        \treturn ret;\n        }\n         \n        int main() {\n        \tMOD1.resize(2);\n        \tMOD2.resize(2);\n        \tp2.push_back(valarray<long long int>());\n        \tp2.back().resize(2);\n        \tp2.back()[0] = p2.back()[1] = 1;\n        \tMOD2[0] = 1000000007;\n        \tMOD1[0] = 555522277;\n        \tMOD1[1] = 895612782;\n        \tMOD2[1] = 998244353;\n        \tp2[0] %= MOD2;\n        \tfor (int i = 1; i < MAX; i++) {\n        \t\tp2.push_back(p2.back());\n        \t\tp2[i] *= MOD1;\n        \t\tp2[i] %= MOD2;\n        \t}\n        \tcin >> n;\n        \tscanf(\"%s\", buf);\n        \ts = buf;\n        \tint pos = MAX/2;\n        \tvalarray<long long int> hs;\n        \ths.resize(2);\n        \ths[0] = hs[1] = 0;\n        \tvv.push_back(hs);\n        \tps.push_back(pos);\n        \tfor (int i = 0; i < s.size(); i++) {\n        \t\tif (s[i] == '<') {\n        \t\t\tpos--;\n        \t\t}\n        \t\tif (s[i] == '>') {\n        \t\t\tpos++;\n        \t\t}\n        \t\tif (s[i] == '+') {\n        \t\t\ths += p2[pos];\n        \t\t}\n        \t\tif (s[i] == '-') {\n        \t\t\ths -= p2[pos];\n        \t\t\ths += MOD2;\n        \t\t}\n        \t\ths %= MOD2;\n        \t\tvv.push_back(hs);\n        \t\tps.push_back(pos);\n        \t}\n        \tlong long int way = 0;\n        \tfor (int i = vv.size() - 1; i >= 0; i--) {\n        \t\tvalarray<long long int> want = vv[i] + ((vv.back()*calc(-MAX/2+ps[i]))%MOD2);\n        \t\twant = want%MOD2;\n        \t\tway += mp[make_pair(want[0], want[1])];\n        \t\t//cerr << \"dbg \" << way << endl;\n        \t\tif(want[0]<0LL||want[1]<0LL)exit(1);\n        \t\tif(vv[i][0]<0LL||want[1]<0LL)exit(1);\n        \t\tmp[make_pair(vv[i][0],vv[i][1])]++;\n        \t}\n        \tprintf(\"%lld\\n\", way);\n        \treturn 0;\n        }\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define mp make_pair\n#define PI pair<int,int>\n#define poly vector<ll>\n#define mem(a) memset((a),0,sizeof(a))\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\n#define pb push_back\n#define fi first\n#define se second\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst ull base=2333;\nconst int N=250005;\nchar ch[N];\null f[N];\nmap<ull,int> M;\nint main(){\n\tull zs=base; For(i,1,63)zs=zs*zs;\n\tconst ull inv=zs;  assert(zs*inv==1);\n\tint n=read();\n\tscanf(\"%s\",ch+1);\n\tull dq=1;\n\tFor(i,1,n){\n\t\tf[i]=f[i-1];\n\t\tif(ch[i]=='+')f[i]+=dq;\n\t\tif(ch[i]=='-')f[i]-=dq;\n\t\tif(ch[i]=='>')dq*=base;\n\t\tif(ch[i]=='<')dq*=inv;\n\t\tM[f[i]]++;\n\t}\n\tll ans=0; dq=1;\n\tFor(i,1,n){\n\t\tans+=M[f[n]*dq+f[i-1]];\n\t\tif(ch[i]=='<')dq*=base;\n\t\tif(ch[i]=='>')dq*=inv;\n\t\tM[f[i]]--;\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nconst unsigned long long M=998244353;\nconst unsigned long long X=99431;\nunsigned long long R;\nconst int W=1000;\n \n \nunsigned long long ModPow(unsigned long long x, unsigned long long n, unsigned long long mod) {\n        unsigned long long ret = 1;\n        for (; n > 0; n /= 2, x = (x * x) % mod)\n            if ((n & 1) == 1) ret = (ret * x) % mod;\n        return ret;\n    }\n \nunsigned long long has=0,vec=1;\n \nint n;\nstring s;\nunordered_map<unsigned long long,int> B[550];\nlong long ans;\ninline void calc(char c, unsigned long long &u,unsigned long long &p){\n\tif(c=='+')u=(u+p)%M;\n\telse if(c=='-')u=(u+M-p)%M;\n\telse if(c=='>')p=(p*X)%M;\n\telse p=(p*R)%M;\n}\nint main(){\n\tR=ModPow(X,M-2,M);\n\tcin>>n>>s;\n    //n=250000;\n    //s=string(n,'+');\n\tfor(int i=0;i<n;i++)calc(s[i],has,vec);\n\tfor(int i=0;i<n;i++){\n\t\tif(i%W==0)continue;\n\t\tunsigned long long h=0,x=1;\n\t\tfor(int j=i;j<n;j++){\n\t\t\tif(j%W==0)break;\n\t\t\tcalc(s[j],h,x);\n\t\t\tif(h==has)ans++;\n\t\t}\n\t\tunsigned long long nh = (has+M-h)%M;\n\t\tnh = nh * ModPow(x,M-2,M)%M;\n\t\tB[i/W+1][nh]++;\n\t}\n\tfor(int i=0;i<n;i+=W){\n\t\tunsigned long long h=0,x=1;\n\t\tfor(int j=i;j<n;j++){\n\t\t\tcalc(s[j],h,x);\n\t\t\tif(h==has)ans++;\n\t\t\tauto it = B[i/W].find(h);\n\t\t\tif(it!=B[i/W].end())ans+=it->second;\n\t\t}\n\t}\n\t\n\tcout<<ans;\n \n \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int Mod = 1e9 + 7, Nmax = 5e5 + 5, Pow = 31;\ntypedef long long ll;\n\nint sP[Nmax], i, n, P, target;\nll Pw[Nmax], E[Nmax], R[Nmax], ans = 0, Inv;\nmap<int, int> mp;\nchar a[Nmax];\n\n\nll power(ll a, int b)\n{\n    ll ans = 1;\n    while(b)\n    {\n        if(b&1) ans = ans * a % Mod;\n        b >>= 1; a = a*a%Mod;\n    }\n    return ans;\n}\n\nint main()\n{\n  //  freopen(\"input\", \"r\", stdin);\n  //  freopen(\"output\", \"w\", stdout);\n    cin.sync_with_stdio(false);\n\n    cin >> n >> (a+1);\n\n    for(i=1; i<=n; ++i) sP[i] = sP[i-1] - (a[i] == '<') + (a[i] == '>');\n\n    Inv = power(Pow, Mod-2);\n    Pw[0] = 1;\n    for(i=1; i<=2*n; ++i) Pw[i] = Pw[i-1] * Pow % Mod;\n\n    P = n;\n    for(i=1; i<=n; ++i) /// for 1..,i\n    {\n        E[i] = E[i-1];\n        if(a[i] == '<')\n        {\n            --P;\n            continue;\n        }\n\n        if(a[i] == '>')\n        {\n            ++P;\n            continue;\n        }\n\n        if(a[i] == '-')\n            E[i] -= Pw[P];\n        else E[i] += Pw[P];\n\n        if(E[i] >= Mod) E[i] -= Mod;\n            else if(E[i] < 0) E[i] += Mod;\n    }\n\n    for(i=1; i<=n; ++i) /// reverse operations for 1...i, not signs\n    {\n        if(a[i] == '<')\n        {\n            R[i] = Pow * R[i-1] % Mod;\n            continue;\n        }\n\n        if(a[i] == '>')\n        {\n            R[i] = Inv * R[i-1] % Mod;\n            continue;\n        }\n\n        if(a[i] == '+') R[i] = R[i-1] + Pw[n];\n            else R[i] = R[i-1] - Pw[n];\n\n        if(R[i] >= Mod) R[i] -= Mod;\n            else if(R[i] < 0) R[i] += Mod;\n    }\n\n    for(i=n; i; --i)\n    {\n        ++mp[E[i]]; /// i becomes active\n        target = (E[n] + R[i-1]) * Pw[sP[i-1]] % Mod;\n        ans += mp[target];\n    }\n\n    cout << ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long lint;\n\nlint modpow(lint x, lint y, lint mod) {\n  lint ret = 1 % mod, x2p = x;\n  while (y > 0) {\n    if (y % 2) ret = (__int128)ret * x2p % mod;\n    y /= 2;\n    x2p = (__int128)x2p * x2p % mod;\n  }\n  return ret;\n}\n\nconstexpr int nmods = 15;\n\nconstexpr lint mod[] = {1152921504609811141LL, 576460752312103501LL,\n                        4611676018431352883LL, 4611676018431352883LL,\n                        288230376151711789,288230376151711793,288230376151711813,288230376151711843,288230376151711849,288230376151711879,288230376151711909,288230376151711919,288230376151711921,288230376151711933,288230376151711951};\n\nconstexpr lint base[] = {102999959LL, 1006199503LL, 1073741663LL, 599831LL,\n                         1300000003LL,\n                         1300000021LL,\n                         1300000049LL,\n                         1300000073LL,\n                         1300000087LL,\n                         1300000103LL,\n                         1300000151LL,\n                         1300000153LL,\n                         1300000187LL,\n                         1300000201LL,\n                         1300000231LL};\nlint inv_base[nmods];\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  string seq(n, ' ');\n  for (int i = 0; i < n; ++i)\n    scanf(\" %c\", &seq[i]);\n\n  vector<int> pos_before(n);\n\n  vector<vector<lint>> base_pow(nmods, vector<lint>(n + 1));\n  vector<vector<lint>> inv_base_pow(nmods, vector<lint>(n + 1));\n  vector<vector<lint>> hash_diff(nmods, vector<lint>(n, 0));\n  vector<vector<lint>> suffix(nmods, vector<lint>(n + 1));\n  vector<lint> full_seq_hash(nmods);\n  for (int k = 0; k < nmods; ++k) {\n    base_pow[k][0] = 1;\n    for (int i = 1; i <= n; ++i)\n      base_pow[k][i] = (__int128)base[k] * base_pow[k][i - 1] % mod[k];\n\n    inv_base[k] = modpow(base[k], mod[k] - 2, mod[k]);\n    inv_base_pow[k][0] = 1;\n    for (int i = 1; i <= n; ++i)\n      inv_base_pow[k][i] = (__int128)inv_base[k] * inv_base_pow[k][i - 1] % mod[k];\n\n    int pos = 0;\n    for (int i = 0; i < n; ++i) {\n      pos_before[i] = pos;\n      if (seq[i] == '>') ++pos;\n      else if (seq[i] == '<') --pos;\n      else {\n        lint base_pow_pos;\n        if (pos >= 0) base_pow_pos = base_pow[k][pos];\n        else base_pow_pos = inv_base_pow[k][-pos];\n        if (seq[i] == '+') hash_diff[k][i] = base_pow_pos;\n        else if (seq[i] == '-') hash_diff[k][i] = mod[k] - base_pow_pos;\n        else assert(0);\n      }\n    }\n    full_seq_hash[k] = 0;\n    for (int i = 0; i < n; ++i) {\n      full_seq_hash[k] += hash_diff[k][i];\n      if (full_seq_hash[k] >= mod[k]) full_seq_hash[k] -= mod[k];\n    }\n\n    suffix[k][n] = 0;\n    for (int i = n - 1; i >= 0; --i) {\n      suffix[k][i] = hash_diff[k][i] + suffix[k][i + 1];\n      if (suffix[k][i] >= mod[k]) suffix[k][i] -= mod[k];\n    }\n  }\n\n  lint result = 0;\n  map<vector<lint>, int> count;\n  count[vector<lint>(nmods, 0LL)] += 1;\n  for (int i = n - 1; i >= 0; --i) {\n    vector<lint> shifted_full(nmods);\n    for (int k = 0; k < nmods; ++k) {\n      if (pos_before[i] >= 0) {\n        shifted_full[k] = (__int128)full_seq_hash[k] * base_pow[k][pos_before[i]] % mod[k];\n      } else {\n        shifted_full[k] = (__int128)full_seq_hash[k] * inv_base_pow[k][-pos_before[i]] % mod[k];\n      }\n    }\n\n    vector<lint> target(nmods);\n    for (int k = 0; k < nmods; ++k) {\n      target[k] = suffix[k][i] - shifted_full[k];\n      if (target[k] < 0) target[k] += mod[k];\n    }\n\n    auto it = count.find(target);\n    if (it != count.end())\n      result += it->second;\n\n    vector<lint> suffix_vec(nmods);\n    for (int k = 0; k < nmods; ++k)\n      suffix_vec[k] = suffix[k][i];\n\n    count[suffix_vec] += 1;\n  }\n  printf(\"%lld\\n\", result);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1e9 + 7;\nconst int N = 2e5 + 5;\nconst int X = 1453;\ntypedef long long ll;\n\n\nchar c;\nstring s;\nll n,i,t,a,b,x,bol=1,ans;\nmap < int , int > M;\n\nint main(){\n    cin >> n >> s;\n    for(t=X,i=mod-2; i ; i>>=1){\n        if(i & 1) bol = bol*t % mod;\n        t = t*t % mod;\n    }\n    for(i=n-1; i>=0 ;i--){\n        c = s[i];\n        if(c == '+') x++;\n        if(c == '-') x--;\n        if(c == '>') x *= X;\n        if(c == '<') x *= bol;\n        x = (x % mod + mod) % mod;\n    }\n\n    a = 1; b = 0;\n    M[0] = 1;\n    for(i=n-1; i>=0 ;i--){\n        c = s[i];\n        if(c == '+') b -= a;\n        if(c == '-') b += a;\n        if(c == '>') a *= bol;\n        if(c == '<') a *= X;\n        a = (a % mod + mod) % mod;\n        b = (b % mod + mod) % mod;\n        t = (a*x + b) % mod;\n        ans += M[t];\n        M[b]++;\n    }\n\n    cout << ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing lint = long long int;\nusing P = pair<lint, lint>;\n\nconstexpr lint MOD = 1000000007;\n\n// vector<lint> X{250007, 861743};\nvector<lint> X{250007, 250007};\nvector<lint> Xinv(2);\n\nint N;\nstring S;\n\n// ax+by=gcd(a, b)\ntemplate <typename T>\nT extgcd(T a, T b, T &x, T &y)\n{\n    T d = a;\n    if (b != 0)\n    {\n        d = extgcd(b, a % b, y, x);\n        y -= a / b * x;\n    }\n    else\n    {\n        x = 1;\n        y = 0;\n    }\n    return d;\n}\n\nP nxt_hash(P prev_hash, lint x, lint xinv, char c)\n{\n    P res = prev_hash;\n    if (c == '+')\n    {\n        res.first++;\n    }\n    if (c == '-')\n    {\n        res.first += MOD - 1;\n    }\n    if (c == '>')\n    {\n        res.first *= x;\n        res.second *= x;\n    }\n    if (c == '<')\n    {\n        res.first *= xinv;\n        res.second *= xinv;\n    }\n    res.first %= MOD;\n    res.second %= MOD;\n    return res;\n}\n\nint main()\n{\n    for (int i = 0; i < 2; i++)\n    {\n        lint xinv, tmp;\n        extgcd(X[i], MOD, xinv, tmp);\n        Xinv[i] = (xinv + MOD) % MOD;\n    }\n\n    cin >> N >> S;\n\n    vector<vector<P> > hash(2, vector<P>(N+1, make_pair(0LL, 1LL)));\n\n    for (unsigned ix = 0; ix < 2; ix++)\n    {\n        lint x = X[ix];\n        lint xinv = Xinv[ix];\n        for (int i = N - 1; i>=0; i--) hash[ix][i] = nxt_hash(hash[ix][i + 1], x, xinv, S[i]);\n    }\n\n    for (int ix = 0; ix < 2; ix++)\n    {\n        for (int i = 0; i <= N; i++)\n        {\n            lint invh, tmp;\n            extgcd(hash[ix][i].second, MOD, invh, tmp);\n            hash[ix][i].second = (invh + MOD) % MOD;\n        }\n    }\n\n    lint ans = 0;\n    map<P, int> hash_lst;\n    for (int m = N; m >= 0; m--)\n    {\n        P h_query;\n        h_query.first = (hash[0][m].first - hash[0][0].first + MOD) * hash[0][m].second % MOD;\n        h_query.second = (hash[1][m].first - hash[1][0].first + MOD) * hash[1][m].second % MOD;\n\n        ans += hash_lst[h_query];\n\n        P h_append;\n        h_append.first = hash[0][m].first * hash[0][m].second % MOD;\n        h_append.second = hash[1][m].first * hash[1][m].second % MOD;\n        hash_lst[h_append]++;\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "const int N = 250005;\nconst int LG = 21;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nint n;\nstring s;\nll sufa[N];\nll suf0[N];\nll sufa2[N];\nll suf02[N];\nconst ll K = 1e6 + 3;\nconst ll K2 = 1791791;\nconst ll rK = rev(K);\nconst ll rK2 = rev(K2);\nll pref0[N];\nll pref02[N];\nll moves[N];\nmap<int, ll> deg, deg2;\n\nsigned main()\n{\n    deg[0] = 1;\n    deg2[0] = 1;\n    for (int i = 1; i < N; i++) deg[i] = deg[i - 1] * K % MOD;\n    for (int i = 1; i < N; i++) deg2[i] = deg2[i - 1] * K2 % MOD;\n    for (int i = 1; i < N; i++) deg[-i] = deg[-i + 1] * rK % MOD;\n    for (int i = 1; i < N; i++) deg2[-i] = deg2[-i + 1] * rK2 % MOD;\n    srand(time(NULL));\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n    cin >> n >> s;\n    ll a = 0, a2 = 0;\n    for (int i = n - 1; i >= 0; i--)\n    {\n        if (s[i] == '+')\n        {\n            a = (a + MOD - 1) % MOD;\n            a2 = (a2 + MOD - 1) % MOD;\n        }\n        if (s[i] == '-')\n        {\n            a = (a + 1) % MOD;\n            a2 = (a2 + 1) % MOD;\n        }\n        if (s[i] == '>')\n        {\n            a = (a * K) % MOD;\n            a2 = (a2 * K2) % MOD;\n        }\n        if (s[i] == '<')\n        {\n            a = (a * rK) % MOD;\n            a2 = (a2 * rK2) % MOD;\n        }\n    }\n    if (s[0] == '+') pref0[0] = (pref0[0] + 1) % MOD;\n    if (s[0] == '+') pref02[0] = (pref02[0] + 1) % MOD;\n    if (s[0] == '-') pref0[0] = (pref0[0] + MOD - 1) % MOD;\n    if (s[0] == '-') pref02[0] = (pref02[0] + MOD - 1) % MOD;\n    if (s[0] == '<') pref0[0] = (pref0[0] * K) % MOD;\n    if (s[0] == '<') pref02[0] = (pref02[0] * K2) % MOD;\n    if (s[0] == '>') pref0[0] = (pref0[0] * rK) % MOD;\n    if (s[0] == '>') pref02[0] = (pref02[0] * rK2) % MOD;\n    if (s[0] == '>') moves[0]++;\n    if (s[0] == '<') moves[0]--;\n    for (int i = 1; i < n; i++)\n    {\n        if (s[i] == '+') pref0[i] = (pref0[i - 1] + 1) % MOD;\n        if (s[i] == '+') pref02[i] = (pref02[i - 1] + 1) % MOD;\n        if (s[i] == '-') pref0[i] = (pref0[i - 1] + MOD - 1) % MOD;\n        if (s[i] == '-') pref02[i] = (pref02[i - 1] + MOD - 1) % MOD;\n        if (s[i] == '<') pref0[i] = (pref0[i - 1] * K) % MOD;\n        if (s[i] == '<') pref02[i] = (pref02[i - 1] * K2) % MOD;\n        if (s[i] == '>') pref0[i] = (pref0[i - 1] * rK) % MOD;\n        if (s[i] == '>') pref02[i] = (pref02[i - 1] * rK2) % MOD;\n        moves[i] = moves[i - 1];\n        if (s[i] == '>') moves[i]++;\n        if (s[i] == '<') moves[i]--;\n    }\n    for (int j = 0; j < n; j++)\n    {\n        if (s[j] == '+')\n        {\n            suf0[0] = (suf0[0] + 1) % MOD;\n            suf02[0] = (suf02[0] + 1) % MOD;\n        }\n        if (s[j] == '-')\n        {\n            suf0[0] = (suf0[0] + MOD - 1) % MOD;\n            suf02[0] = (suf02[0] + MOD - 1) % MOD;\n        }\n        if (s[j] == '<')\n        {\n            suf0[0] = (suf0[0] * K) % MOD;\n            suf02[0] = (suf02[0] * K2) % MOD;\n        }\n        if (s[j] == '>')\n        {\n            suf0[0] = (suf0[0] * rK) % MOD;\n            suf02[0] = (suf02[0] * rK2) % MOD;\n        }\n    }\n    if (a == 0 || a2 == 0) return 1;\n    for (int i = 0; i < n; i++) suf0[i + 1] = (suf0[0] - pref0[i] * deg[moves[i]] + MOD * MOD) % MOD;\n    for (int i = 0; i < n; i++) suf02[i + 1] = (suf02[0] - pref02[i] * deg2[moves[i]] + MOD * MOD) % MOD;\n    for (int i = 0; i < n; i++) sufa[i] = (suf0[i] + a * deg[(i > 0 ? moves[i - 1] : 0) - moves[n - 1]]) % MOD;\n    for (int i = 0; i < n; i++) sufa2[i] = (suf02[i] + a2 * deg2[(i > 0 ? moves[i - 1] : 0) - moves[n - 1]]) % MOD;\n    ll ans = 0;\n    map<vector<ll>, ll> cnt;\n    for (int i = n; i >= 0; i--)\n    {\n        ans += cnt[{sufa[i], sufa2[i]}];\n        cnt[{suf0[i], suf02[i]}]++;\n    }\n    cout << ans;\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nmt19937 rd(time(0));\n#define int long long\nconst int M=1004535809;\n#define fi first\n#define se second\n#define mp make_pair\n#define pii pair<int,int>\nconst int N=250005;\npii f1[N],f2[N];\nchar s[N];\nint n;\nmap<pair<int,int>,int> Map;\nint ksm(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=x*x%M)\n\t\tif (y&1)(ans*=x)%=M;\n\treturn ans;\n}\npii fuhe(pii x,pii y){\n\treturn mp((x.fi*y.fi)%M,(x.fi*y.se+x.se)%M);\n}\nsigned main(){\n\tscanf(\"%lld\",&n);\n\tscanf(\"%s\",s+1);\n\tint x1=rd()%(M-1)+1,x2=rd()%(M-1)+1;\n\tint Inv1=ksm(x1,M-2),Inv2=ksm(x2,M-2);\n\tf1[0]=mp(1,0);f2[0]=mp(1,0);\n\tfor (int i=1;i<=n;i++){\n\t\tif (s[i]=='+')f1[i]=fuhe(f1[i-1],mp(1,1)),f2[i]=fuhe(f2[i-1],mp(1,1));\n\t\tif (s[i]=='-')f1[i]=fuhe(f1[i-1],mp(1,-1)),f2[i]=fuhe(f2[i-1],mp(1,-1));\n\t\tif (s[i]=='<')f1[i]=fuhe(f1[i-1],mp(x1,0)),f2[i]=fuhe(f2[i-1],mp(x2,0));\n\t\tif (s[i]=='>')f1[i]=fuhe(f1[i-1],mp(Inv1,0)),f2[i]=fuhe(f2[i-1],mp(Inv2,0));\n\t}\n\tint ans=0;\n\tfor (int i=1;i<=n;i++){\n\t\tMap[mp((fuhe(f1[i-1],f1[n])).se,(fuhe(f2[i-1],f2[n])).se)]++;\n\t\tans+=Map[mp(f1[i].se,f2[i].se)];\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "//teja349\n#include <bits/stdc++.h>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <utility>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <iomanip> \n//setbase - cout << setbase (16); cout << 100 << endl; Prints 64\n//setfill -   cout << setfill ('x') << setw (5); cout << 77 << endl; prints xxx77\n//setprecision - cout << setprecision (14) << f << endl; Prints x.xxxx\n//cout.precision(x)  cout<<fixed<<val;  // prints x digits after decimal in val\n\nusing namespace std;\n#define f(i,a,b) for(i=a;i<b;i++)\n#define rep(i,n) f(i,0,n)\n#define fd(i,a,b) for(i=a;i>=b;i--)\n#define pb push_back\n#define mp make_pair\n#define vi vector< int >\n#define vl vector< ll >\n#define ss second\n#define ff first\n#define ll long long\n#define pii pair< int,int >\n#define pll pair< ll,ll >\n#define sz(a) a.size()\n#define inf (1000*1000*1000+5)\n#define all(a) a.begin(),a.end()\n#define tri pair<int,pii>\n#define vii vector<pii>\n#define vll vector<pll>\n#define viii vector<tri>\n#define mod (998244353)\n#define pqueue priority_queue< int >\n#define pdqueue priority_queue< int,vi ,greater< int > >\n\n//std::ios::sync_with_stdio(false);   \nll ans10[512345],ans13[512345],powe13[512345],powe10[512345],invpowe10[512345];\nll invpowe13[512345],inv[1234],p[512345];\nll extend_gcd(ll a,ll b,ll &x,ll &y){\n\tif(b==0){\n\t\tx=1;\n\t\ty=0;\n\t\treturn a;\n\t}\n\tll x1,y1;\n\tll ans =extend_gcd(b,a%b,x1,y1);\n\tx=y1;\n\ty=x1-(a/b)*y1;\n\n\treturn ans;\n}\nmap<ll,ll> seti10,seti13; \nint main(){\n    std::ios::sync_with_stdio(false);\n    ll n;\n    cin>>n;\n    string s;\n    cin>>s;\n    ll i;\n    ll initp=250003;\n    powe10[0]=1;\n    powe13[0]=1;\n    invpowe10[0]=1;\n    invpowe13[0]=1;\n    f(i,1,100){\n\t\tll x,y;\n\t\tll val=extend_gcd(mod,i,x,y);\n\t\tif(y>0)\n\t\t\tinv[i]=y%mod;\n\t\telse{\n\t\t\t\tinv[i]=(y+mod)%mod;\n\t\t}\n\t}\n\tll inv10=inv[10];\n\tll inv13=inv[13];\n    f(i,1,512345){\n    \tpowe13[i]=powe13[i-1]*13;\n    \tpowe10[i]=powe10[i-1]*10;\n    \tpowe10[i]%=mod;\n    \tpowe13[i]%=mod;\n    \tinvpowe10[i]=invpowe10[i-1]*inv10;\n    \tinvpowe10[i]%=mod;\n    \tinvpowe13[i]=invpowe13[i-1]*inv13;\n    \tinvpowe13[i]%=mod;\n    }\n    ans10[0]=0;\n    ans13[0]=0;\n    p[0]=initp;\n    \n    f(i,1,s.length()+1){\n    \tans10[i]=ans10[i-1];\n    \tans13[i]=ans13[i-1];\n    \tp[i]=p[i-1];\n    \tif(s[i-1]=='+'){\n    \t\tans10[i]=ans10[i-1]+powe10[p[i]];\n    \t\tans13[i]=ans13[i-1]+powe13[p[i]];\n\n    \t}\n    \telse if(s[i-1]=='-'){\n    \t\tans10[i]=ans10[i-1]-powe10[p[i]];\n    \t\tans13[i]=ans13[i-1]-powe13[p[i]];\n    \t}\n    \telse if(s[i-1]=='<'){\n    \t\tp[i]--;\n    \t}\n    \telse{\n    \t\tp[i]++;\n    \t}\n    \tans10[i]%=mod;\n    \tans10[i]+=mod;\n    \tans10[i]%=mod;\n    \tans13[i]%=mod;\n    \tans13[i]+=mod;\n    \tans13[i]%=mod;\n    \tseti13[ans13[i]]++;\n    \tseti10[ans10[i]]++;\n    \t//cout<<ans10[i]<<\" \"<<ans13[i]<<endl;\n    }\n    ll val,val1,j10,j13;\n    ll total=0;\n    f(i,1,n+1){\n    \tval=initp-p[i-1];\n    \tval*=-1;\n    \tif(val>=0){\n    \t\tval1=powe13[val];\n    \t\tval=powe10[val];\n    \t\t  \n    \t}\n    \telse{\n    \t\tval1=invpowe13[val];\n    \t\tval=invpowe10[val];\n    \t}\n    \tj10=ans10[n]*val;\n    \tj10%=mod;\n    \tj10+=ans10[i-1];\n    \tj13=ans13[n]*val1;\n    \tj13%=mod;\n    \tj13+=ans13[i-1];\n    \tj10%=mod;\n    \tj13%=mod;\n    \ttotal+=min(seti10[j10],seti13[j13]);\n    \tseti13[ans13[i]]--;\n    \tseti10[ans10[i]]--;\n    }\n    cout<<total<<endl;\n\n\n\n\n    return 0;  \n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "//I love armpit fetish\n\n#include <bits/stdc++.h>\nusing namespace std;\n \n#define debug(x) cerr << #x << \" = \" << x << '\\n';\n#define BP() cerr << \"OK!\\n\";\n#define PR(A, n) {cerr << #A << \" = \"; for (int _=1; _<=n; ++_) cerr << A[_] << ' '; cerr << '\\n';}\n#define PR0(A, n) {cerr << #A << \" = \"; for (int _=0; _<n; ++_) cerr << A[_] << ' '; cerr << '\\n';}\n#define FILE_NAME \"data\"\n\nconst int MAX_N = 500002;\nconst int offset = 250002;\nconst int T = 260000;\nconst int MOD = 1000000007;\n\nint n, cnt[MAX_N];\nstring s;\nint64_t pref_hash[MAX_N], suff_hash[MAX_N];\n\nvoid enter() {\n\tcin >> n >> s;\n}\n\nint64_t pw(int n, int k) {\n\tif (k==0)\n\t\treturn 1;\n\tint64_t tmp = pw(n, k/2);\n\tif (k%2)\n\t\treturn tmp * tmp % MOD * n % MOD;\n\treturn tmp * tmp % MOD;\n}\n\nvoid init_pref() {\n\tint p = offset;\n\tint64_t H = 0;\n\tfor (int i=0; i<n; ++i) {\n\t\tif (s[i]=='<' || s[i]=='>') {\n\t\t\tp += (s[i]=='<' ? -1 : 1);\n\t\t\tcnt[i] = cnt[i-1] + (s[i]=='<' ? -1 : 1);\n\t\t}\n\t\telse {\n\t\t\tH = (H - pw(T, p) * (s[i]=='-' ? 1 : -1)) % MOD;\n\t\t}\n\t\tpref_hash[i] = (H + MOD) % MOD;\n\t}\n}\n\nvoid init_suff() {\n\tint64_t H = pref_hash[n-1];\n\tint p = offset;\n\tfor (int i=0; i<n; ++i) {\n\t\tif (s[i]=='>' || s[i]=='<')\n\t\t\tp += (s[i]=='>' ? 1 : -1);\n\t\telse {\n\t\t\t// debug(i);\n\t\t\t// debug(p);\n\t\t\t// debug((s[i]=='+' ? -1 : 1));\n\t\t\tH = (H + pw(T, p) * (s[i]=='+' ? -1 : 1)) % MOD;\n\t\t}\n\t\tsuff_hash[i+1] = (H + MOD) % MOD;\n\t}\n}\n\nint64_t solve() {\n\tmap<int64_t, int> mp;\n\tint64_t H = pref_hash[n-1];\n\tint64_t res = 0;\n\tfor (int j=0; j<n; ++j) {\n\t\tif (j==0)\n\t\t\t++mp[0];\n\t\telse\n\t\t\t++mp[((H - pref_hash[j-1] - H * pw(T, cnt[j-1])) % MOD + MOD) % MOD];\n\t\tres += mp[suff_hash[j+1]];\n\t}\n\treturn res;\n}\n\nint main() {\n\t//#define OFFLINE_JUDGE doraemon\n\t#ifdef OFFLINE_JUDGE\n\t\tfreopen(FILE_NAME\".inp\", \"r\", stdin);\n\t\tfreopen(FILE_NAME\".out\", \"w\", stdout);\n\t#endif\n\tios::sync_with_stdio(0); cin.tie(0);\n\tenter();\n\tinit_pref();\n\tinit_suff();\n\tcout << solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\nll base = 23333 , MOD = 20190816170251;\nll mul(ll a , ll b){a %= MOD; b %= MOD; ll p = ((long double)a * b) / MOD , ans = a * b - MOD * p; return (ans + MOD) % MOD;}\nll upd(ll x){return x + (x >> 63 & MOD);}\nchar str[250003]; int N; unordered_map < ll , int > now; ll val , inv , ans , add , mrk;\n\nll poww(ll a , ll b){\n\tll tms = 1;\n\twhile(b){\n\t\tif(b & 1) tms = mul(tms , a);\n\t\ta = mul(a , a); b >>= 1;\n\t}\n\treturn tms;\n}\n\nint main(){\n\tscanf(\"%d %s\" , &N , str + 1); inv = poww(base , MOD - 2);\n\tfor(int i = N ; i ; --i)\n\t\tswitch(str[i]){\n\t\tcase '+': val = upd(val - MOD + 1); break;\n\t\tcase '-': val = upd(val - 1); break;\n\t\tcase '>': val = val * base % MOD; break;\n\t\tcase '<': val = mul(val , inv);\n\t\t}\n\tmrk = 1;\n\tfor(int i = N ; i ; --i){\n\t\t++now[mul(upd(-add) , mrk)];\n\t\tswitch(str[i]){\n\t\tcase '+': add = upd(add - MOD + 1); break;\n\t\tcase '-': add = upd(add - 1); break;\n\t\tcase '>': add = mul(add , base); mrk = mul(mrk , inv); break;\n\t\tcase '<': add = mul(add , inv); mrk = mul(mrk , base);\n\t\t}\n\t\tans += now[mul(upd(val - add) , mrk)];\n\t}\n\tcout << ans; return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 251000\n#define ll long long\n#define mp make_pair\nconst ll mod1=1e9+7,mod2=998244353,mod3=19260817;\nconst ll bas1=2333,bas2=4399,bas3=377,ibas1=461637380,ibas2=924039783,ibas3=18749920;\n\nint n;\nll ans;\nchar s[N];\nll h1[N],p1[N],h2[N],p2[N],p3[N],h3[N];\nmap<pair<pair<ll,ll>,ll>,int> m;\n\nll add1(ll x,ll y) {return (x+y)%mod1;}\nll mul1(ll x,ll y) {return x*y%mod1;}\nll add2(ll x,ll y) {return (x+y)%mod2;}\nll mul2(ll x,ll y) {return x*y%mod2;}\nll add3(ll x,ll y) {return (x+y)%mod3;}\nll mul3(ll x,ll y) {return x*y%mod3;}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",s+1);\n\tp1[0]=1;\n\tfor (int i=1;i<=n;i++) {\n\t\tp1[i]=p1[i-1]; h1[i]=h1[i-1];\n\t\tif (s[i]=='+') h1[i]=add1(h1[i],p1[i]);\n\t\tif (s[i]=='-') h1[i]=add1(h1[i],mod1-p1[i]);\n\t\tif (s[i]=='<') p1[i]=mul1(p1[i],ibas1);\n\t\tif (s[i]=='>') p1[i]=mul1(p1[i],bas1);\n\t}\n\t\n\tp2[0]=1;\n\tfor (int i=1;i<=n;i++) {\n\t\tp2[i]=p2[i-1]; h2[i]=h2[i-1];\n\t\tif (s[i]=='+') h2[i]=add2(h2[i],p2[i]);\n\t\tif (s[i]=='-') h2[i]=add2(h2[i],mod2-p2[i]);\n\t\tif (s[i]=='<') p2[i]=mul2(p2[i],ibas2);\n\t\tif (s[i]=='>') p2[i]=mul2(p2[i],bas2);\n\t}\n\n\tp3[0]=1;\n\tfor (int i=1;i<=n;i++) {\n\t\tp3[i]=p3[i-1]; h3[i]=h3[i-1];\n\t\tif (s[i]=='+') h3[i]=add3(h3[i],p3[i]);\n\t\tif (s[i]=='-') h3[i]=add3(h3[i],mod3-p3[i]);\n\t\tif (s[i]=='<') p3[i]=mul3(p3[i],ibas3);\n\t\tif (s[i]=='>') p3[i]=mul3(p3[i],bas3);\n\t}\n\t\n\tfor (int i=n;i;i--) {\n\t\tm[mp(mp(h1[i],h2[i]),h3[i])]++;\n\t\tll t1=add1(mul1(h1[n],p1[i-1]),h1[i-1]),t2=add2(mul2(h2[n],p2[i-1]),h2[i-1]),t3=add3(mul3(h3[n],p3[i-1]),h3[i-1]);\n\t\tans+=m[mp(mp(t1,t2),t3)];\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <iostream>\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define debug(x) cout<<#x<<\" :: \"<<x<<endl;\n#define debug2(x,y) cout<<#x<<\" :: \"<<x<<\"\\t\"<<#y<<\" :: \"<<y<<endl;\n#define debug3(x,y,z) cout<<#x<<\" :: \"<<x<<\"\\t\"<<#y<<\" :: \"<<y<<\"\\t\"<<#z<<\" :: \"<<z<<endl;\n\n#define boost ios::sync_with_stdio(0); cin.tie(0)\n\n#define fi first\n#define se second\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double ld;\ntypedef pair<int, int> pii;\n\nconst int X = 250000 + 5;\nconst int N = 1e6 + 5;\nconst ull B = 259;\null invB;\n\n/***************************************************************************/\n\null power(ull a, ull n) {\n\tif(n == 0) return 1;\n\tull p = power(a, n>>1);\n\tp = p * p;\n\tif(n & 1) p = p * a;\n\treturn p;\n}\n\nstring S;\null powB[N];\n\ninline ull& pow(int n) {\n\tif(n < 0) n += N;\n\treturn powB[n];\n}\n\nmap<ull, int> M;\n\nint main() {\n\n\tboost;\n\tinvB = power(B, (ull(1)<<63)-1);\n\tassert(B * invB == 1);\n\n\tpow(0) = 1;\n\tfor(int i=1; i<X; i++) {\n\t\tpow(i) = pow(i-1) * B;\n\t\tpow(-i) = pow(-i+1) * invB;\n\t}\n\n\tint n; cin>>n;\n\tcin>>S;\n\n\tull phas = 0, chas = 0;\n\n\tint p = 0;\n\tfor(auto it : S) {\n\t\tif(it == '+') phas += pow(p);\n\t\telse if(it == '-') phas -= pow(p);\n\t\telse if(it == '>') p++;\n\t\telse p--;\n\t}\n\n\tll ans = 0;\n\tM[phas]++;\n\tp = 0;\n\n\tfor(auto it : S) {\n\t\tif(it == '+') chas += pow(p);\n\t\telse if(it == '-') chas -= pow(p);\n\t\telse if(it == '>') p++;\n\t\telse p--;\n\n\t\tans += M[chas];\n\t\tM[chas + pow(p) * phas]++;\n\t}\n\n\tcout<<ans<<\"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <random>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\n\nconst ll MOD=1e9+9;\nconst int med=250000;\nll powmod(ll a, ll k){\n    ll ap=a, ans=1;\n    while(k>0){\n        if(k%2==1){\n            ans*=ap;\n            ans%=MOD;\n        }\n        ap=ap*ap;\n        ap%=MOD;\n        k/=2;\n    }\n    return ans;\n}\nll inv(ll a){\n\treturn powmod(a, MOD-2);\n}\n\nint main()\n{\n\tint n;\n\tcin>>n;\n\tstring s; cin>>s;\n\tll b=998244353;\n\tll binv=inv(b);\n\tll bp[500001];\n\tbp[med]=1;\n\tfor(int i=med+1; i<=med+n; i++) bp[i]=bp[i-1]*b%MOD;\n\tfor(int i=med-1; i>=med-n; i--) bp[i]=bp[i+1]*binv%MOD;\n\tll b0=0; int p=med;\n\tfor(int i=0; i<n; i++){\n\t\tif(s[i]=='+'){\n\t\t\tb0=(b0+bp[p])%MOD;\n\t\t}else if(s[i]=='-'){\n\t\t\tb0=(b0+MOD-bp[p])%MOD;\n\t\t}else if(s[i]=='>'){\n\t\t\tp++;\n\t\t}else{\n\t\t\tp--;\n\t\t}\n\t}\n\tll ans=0;\n\tll x[250000]={};\n\tunordered_map<ll, int> mp[500];\n\tint c1[500]={};\n\tll c0[500]={};\n\tint sq=2000;\n\tfor(int i=0; i<n; i++){\n\t\tif(s[n-1-i]=='+'){\n\t\t\tfor(int j=i/sq*sq; j<=i; j++){\n\t\t\t\tx[j]=(x[j]+1)%MOD;\n\t\t\t}\n\t\t\tfor(int j=0; j<i/sq; j++){\n\t\t\t\tc0[j]=(c0[j]+1)%MOD;\n\t\t\t}\n\t\t}else if(s[n-1-i]=='-'){\n\t\t\tfor(int j=i/sq*sq; j<=i; j++){\n\t\t\t\tx[j]=(x[j]+MOD-1)%MOD;\n\t\t\t}\n\t\t\tfor(int j=0; j<i/sq; j++){\n\t\t\t\tc0[j]=(c0[j]+MOD-1)%MOD;\n\t\t\t}\n\t\t}else if(s[n-1-i]=='>'){\n\t\t\tfor(int j=i/sq*sq; j<=i; j++){\n\t\t\t\tx[j]=x[j]*b%MOD;\n\t\t\t}\n\t\t\tfor(int j=0; j<i/sq; j++){\n\t\t\t\tc1[j]++;\n\t\t\t\tc0[j]=c0[j]*b%MOD;\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int j=i/sq*sq; j<=i; j++){\n\t\t\t\tx[j]=x[j]*binv%MOD;\n\t\t\t}\n\t\t\tfor(int j=0; j<i/sq; j++){\n\t\t\t\tc1[j]--;\n\t\t\t\tc0[j]=c0[j]*binv%MOD;\n\t\t\t}\n\t\t}\n\t\tfor(int j=0; j<i/sq; j++){\n\t\t\tll x0=(b0-c0[j]+MOD)*bp[med-c1[j]]%MOD;\n\t\t\tauto itr=mp[j].find(x0);\n          if(itr!=mp[j].end()) ans+=((ll)(itr->second));\n\t\t}\n\t\tfor(int j=i/sq*sq; j<=i; j++){\n\t\t\tif(b0==x[j]) ans++;\n\t\t}\n\t\tif((i+1)%sq==0){\n\t\t\tfor(int j=i/sq*sq; j<=i; j++){\n\t\t\t\tmp[i/sq][x[j]]++;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll    =long long;    using dd   =double;        using pll    =pair<ll, ll>;  using tll    =tuple<ll,ll,ll>;\nusing vll   =vector<ll>;   using vdd  =vector<dd>;    using vpll   =vector<pll>;   using vtll   =vector<tll>;\nusing vvll  =vector<vll>;  using vvdd =vector<vdd>;   using vvpll  =vector<vpll>;  using vvtll  =vector<vtll>;\nusing vvvll =vector<vvll>; using vvvdd=vector<vvdd>;  using vvvpll =vector<vvpll>; using vvvtll =vector<vvtll>;\nusing vvvvll=vector<vvvll>;using vvvvdd=vector<vvvdd>;using vvvvpll=vector<vvvpll>;using vvvvtll=vector<vvvtll>;\n\nconstexpr ll INF = 1LL << 60;\nconstexpr dd EPS = 1e-11;\n\n//cin,cout高速化のおまじない＋桁数指定\nstruct Fast{\n\tFast(){\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(std::numeric_limits<double>::max_digits10);\n\t}\n} fast;\n\n#define REPS(i, S, E) for (ll i = (S); i <= (E); i++)\n#define REP(i, N) REPS(i, 0, (N)-1)\n#define DEPS(i, S, E) for (ll i = (E); i >= (S); i--)\n#define DEP(i, N) DEPS(i, 0, (N)-1)\n#define EACH(e, v) for (auto&& e : v)\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\ntemplate<class T> inline T MaxE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmax(m,v[i]); return m;}//v[S]～v[E]の最大値\ntemplate<class T> inline T MinE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmin(m,v[i]); return m;}//v[S]～v[E]の最小値\ntemplate<class T> inline T MaxE(vector<T> &v, ll N) { return MaxE(v, 0, N - 1); } //先頭N個中の最大値\ntemplate<class T> inline T MinE(vector<T> &v, ll N) { return MinE(v, 0, N - 1); }\ntemplate<class T> inline T MaxE(vector<T> &v) { return MaxE(v, (ll)v.size()); }\ntemplate<class T> inline T MinE(vector<T> &v) { return MinE(v, (ll)v.size()); }\ntemplate<class T> inline ll MaxI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]>v[m])m=i;} return m;}\ntemplate<class T> inline ll MinI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]<v[m])m=i;} return m;}\ntemplate<class T> inline ll MaxI(vector<T> &v, ll N) { return MaxI(v, 0, N - 1); }\ntemplate<class T> inline ll MinI(vector<T> &v, ll N) { return MinI(v, 0, N - 1); }\ntemplate<class T> inline ll MaxI(vector<T> &v) { return MaxI(v, (ll)v.size()); }\ntemplate<class T> inline ll MinI(vector<T> &v) { return MinI(v, (ll)v.size()); }\ntemplate<class T> inline T Sum(vector<T> &v, ll S,ll E){ T s=v[S]; REPS(i,S+1,E)s+=v[i]; return s; }\ntemplate<class T> inline T Sum(vector<T> &v, ll N) { return Sum(v, 0, N - 1); }\ntemplate<class T> inline T Sum(vector<T> &v) { return Sum(v, v.size()); }\ntemplate<class T> inline T POW(T a, ll n){ T r=1; for (; n>0; n>>=1, a*=a){ if (n&1)r*=a; } return r; }\ninline ll POW(int a, ll n){ return POW((ll)a, n); }\ninline ll MSB(ll a){for(ll o=63,x=-1;;){ll m=(o+x)/2; if(a<(1LL<<m))o=m; else x=m; if(o-x==1)return x;}}\ninline ll CEIL(ll a, ll b){ return (a+b-1)/b; }\nll Gcd(ll a, ll b){ return (b==0) ? a : Gcd(b, a%b); }\nll Lcm(ll a, ll b){ return a * b / Gcd(a, b); }\ninline vll Mask2Idx(ll m){vll v; for(ll i=0;m;m>>=1,i++) if(m&1)v.push_back(i); return move(v);}\ninline ll BitNum(ll m){ for (ll c=0;; m>>=1){ c+=m&1; if (!m)return c; } }\ninline ll Bit(ll s, ll i){ return (s>>i)&1; } //sの第ibit i=0-63\ninline ll BitOn(ll s, ll i){ return s|(1LL<<i); } //sの第ibitON i=0-63\ninline ll BitOff(ll s, ll i){ return s&~(1LL<<i); } //sの第ibitOFF i=0-63\ntemplate<class T> inline ll UnderNumOf(vector<T> &v, T x){ //sort済vのx以下の個数を得る\n\treturn upper_bound(v.begin(), v.end(), x) - v.begin(); }\ntemplate<class T, class Pr> inline ll UnderNumOf(vector<T> &v, T x, Pr pred){ //x以下個数\n\treturn upper_bound(v.begin(), v.end(), x, pred) - v.begin(); }\ntemplate<class T> inline ll OverNumOf(vector<T> &v, T x){ //sort済vのx以上の個数を得る\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x) - v.begin()); }\ntemplate<class T, class Pr> inline ll OverNumOf(vector<T> &v, T x, Pr pred){ //x以上の個数\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x, pred) - v.begin()); }\n\ntemplate<class T=ll> inline vector<T> cinv(ll N){ vector<T> v(N); REP(i, N)cin>>v[i]; return move(v);}\ntemplate<class T=ll, class S=ll> inline vector<pair<T, S>> cinv2(ll N){\n\tvector<pair<T, S>> v(N); REP(i,N){cin>>v[i].first>>v[i].second;} return move(v); }\ntemplate<class T=ll,class S=ll,class R=ll> inline vector<tuple<T, S, R>> cinv3(ll N){\n\tvector<tuple<T,S,R>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i]);} return move(v);}\ntemplate<class T=ll,class S=ll,class R=ll,class Q=ll> inline vector<tuple<T,S,R,Q>> cinv4(ll N){\n\tvector<tuple<T,S,R,Q>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i])>>get<3>(v[i]);} return move(v);}\ntemplate<class T=ll> inline vector<vector<T>> cinvv(ll N, ll M){\n\tvector<vector<T>> vv(N); REP(i, N) vv[i] = cinv(M); return move(vv);}\ntemplate<class T> inline void coutv(vector<T> &v, char deli=' '){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?'\\n':deli);} }\ntemplate<class T> void bye(T a){cout << a << '\\n'; exit(0);}\n\n#if defined(_DEBUG)\ntemplate<class T> void Dump(vector<T> &v){\n\tREP(i, (ll)v.size()) { cerr << ((i==0)?\"[\":\" \") << setw(5) << v[i]; }  cerr << \"]\";\n}\nvoid Dump(vll &v){\n\tREP(i, (ll)v.size()) {\n\t\tcerr << ((i==0)?\"[\":\" \") << setw(4);\n\t\tif       (v[i] == INF) cerr << \"INF\";\n\t\telse if (v[i] == -INF) cerr << \"-INF\";\n\t\telse                   cerr << v[i];\n\t}  cerr << \"]\";\n}\ntemplate<class T> void Dump(vector<vector<T>> &v){\n\tll N=(ll)v.size();  string d[2][2]={{\" \", \"[\"},  {\"\\n\", \"]\\n\"}};\n\tREP(i, N) { cerr << d[0][i==0];  Dump(v[i]);  cerr << d[1][i==N-1]; }\n}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  <\", \"[ <\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ---<\", \"[ ---<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">---\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ======<\", \"[ ======<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">======\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\n#else\ntemplate<class T> void Dump(vector<T> &v){}\ntemplate<class T> void Dump(vector<vector<T>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){}\n#endif\n\nstruct mll{\n\tstatic ll MOD;\n\tll val;\n\tmll(ll v = 0): val(v % MOD){ if (val < 0) val += MOD; }\n\tmll operator - () const { return -val; }\n\tmll operator + (const mll &b) const { return val + b.val; }\n\tmll operator - (const mll &b) const { return val - b.val; }\n\tmll operator * (const mll &b) const { return val * b.val; }\n\tmll operator / (const mll &b) const { return mll(*this) /= b; }\n\tmll operator + (ll b) const { return *this + mll(b); }\n\tmll operator - (ll b) const { return *this - mll(b); }\n\tmll operator * (ll b) const { return *this * mll(b); }\n\tfriend mll operator + (ll a, const mll &b) { return b + a; }\n\tfriend mll operator - (ll a, const mll &b) { return -b + a; }\n\tfriend mll operator * (ll a, const mll &b) { return b * a; }\n\tfriend mll operator / (ll a, const mll &b) { return mll(a)/b; }\n\tmll &operator += (const mll &b) { val=(val+b.val)%MOD; return *this; }\n\tmll &operator -= (const mll &b) { val=(val+MOD-b.val)%MOD; return *this; }\n\tmll &operator *= (const mll &b) { val=(val*b.val)%MOD; return *this; }\n\tmll &operator /= (const mll &b) {\n\t\tll c=b.val, d=MOD, u=1, v=0;\n\t\twhile (d){\n\t\t\tll t = c / d;\n\t\t\tc -= t * d; swap(c, d);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tmll &operator += (ll b) { return *this += mll(b); }\n\tmll &operator -= (ll b) { return *this -= mll(b); }\n\tmll &operator *= (ll b) { return *this *= mll(b); }\n\tmll &operator /= (ll b) { return *this /= mll(b); }\n\tbool operator == (const mll &b) { return val == b.val; }\n\tbool operator != (const mll &b) { return val != b.val; }\n\tbool operator == (ll b) { return *this == mll(b); }\n\tbool operator != (ll b) { return *this != mll(b); }\n\tfriend bool operator == (ll a, const mll &b) { return mll(a) == b.val; }\n\tfriend bool operator != (ll a, const mll &b) { return mll(a) != b.val; }\n\tfriend ostream &operator << (ostream &os, const mll &a) { return os << a.val; }\n\tfriend istream &operator >> (istream &is, mll &a) { return is >> a.val; }\n\tstatic mll Combination(ll a, ll b){\n\t\tchmin(b, a-b);\n\t\tif (b<0) return mll(0);\n\t\tmll c = 1;\n\t\tREP(i, b) c *= a-i;\n\t\tREP(i, b) c /= i+1;\n\t\treturn c;\n\t}\n};\nll mll::MOD = 2099999999LL;// 998244353LL;//1000000007LL;\nusing vmll = std::vector<mll>;\nusing vvmll = std::vector<vmll>;\nusing vvvmll = std::vector<vvmll>;\nusing vvvvmll = std::vector<vvvmll>;\nusing vvvvvmll = std::vector<vvvvmll>;\n\nusing Data = tuple<mll, ll, mll>;\n\nData prod(Data a, Data b){\n\tmll ha; ll pa; mll qpa; tie(ha, pa, qpa) = a;\n\tmll hb; ll pb; mll qpb; tie(hb, pb, qpb) = b;\n\treturn Data(ha+qpa*hb, pa+pb, qpa*qpb);\n}\n\nvoid solve()\n{\n\tll N; string S;  cin >> N >> S;\n\tmll q = 999983;\n\tmll qinv = mll(1) / q;\n\n\tData plus  = Data( 1, 0, 1);\n\tData minus = Data(-1, 0, 1);\n\tData right = Data( 0, 1, q);\n\tData left  = Data( 0,-1, qinv);\n\n\t//W求める\n\tData W ={0,0,1};\n\tDEPS(i, 0, N-1){\n\t\tData si;\n\t\tif      (S[i] == '+') si = plus;\n\t\telse if (S[i] == '-') si = minus;\n\t\telse if (S[i] == '>') si = right;\n\t\telse                  si = left;\n\t\tW = prod(si, W);\n\t}\n\tmll hW = get<0>(W);\n\n\tunordered_map<ll, ll> CinvMap;\n\tData X ={0,0,1};\n\tData Xinv ={0,0,1};\n\tll ans = 0;\n\tDEPS(i, 0, N-1){\n\t\t//現在のXinvをCinvバッファに入れる\n\t\tll h = get<0>(Xinv).val;\n\t\tCinvMap[h]++;\n\t\t//Xを伸ばす\n\t\tData si;\n\t\tif      (S[i] == '+') si = plus;\n\t\telse if (S[i] == '-') si = minus;\n\t\telse if (S[i] == '>') si = right;\n\t\telse                  si = left;\n\t\tX = prod(si, X);\n\t\t//Xinvを伸ばす\n\t\tData siinv;\n\t\tif      (S[i] == '+') siinv = minus;\n\t\telse if (S[i] == '-') siinv = plus;\n\t\telse if (S[i] == '>') siinv = left;\n\t\telse                  siinv = right;\n\t\tXinv = prod(Xinv, siinv);\n\t\t\n\t\t//C^-1のh成分を計算\n\t\tmll hX = get<0>(X);\n\t\tmll qpXinv = get<2>(Xinv);\n\t\tmll hCinv = (hW-hX) * qpXinv;\n\t\tif (CinvMap.count(hCinv.val) == 1){\n\t\t\tans += CinvMap[hCinv.val];\n\t\t}\n\t}\n\tcout << ans << '\\n';\n}\n\n\nint main(){\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define R return\n#define rep(i,s,t) for(int i=s;i<=(t);++i)\n#define dec(i,s,t) for(int i=s;i>=(t);--i)\nusing namespace std;\nconst int N=3e5+50,P=1e9+7,X=7,I=142857144;\nint mul(int a,int b){ R 1ll*a*b%P; }\nint add(int a,int b){ a+=b; R a>=P?a-P:a; }\nint sub(int a,int b){ a-=b; R a<0?a+P:a; }\nchar s[N]; long long ans; int n,A[N],B[N],u;\nint f(char c,int x){\n\tif(c=='+')R add(x,1); \n\tif(c=='-')R sub(x,1); \n\tif(c=='<')R mul(x,I);\n\tif(c=='>')R mul(x,X); \n\texit(-1);\n}\nvoid g(char c,int &a,int &b){\n\tif(c=='+')b=sub(b,a);\n\tif(c=='-')b=add(b,a);\n\tif(c=='<')a=mul(a,X);\n\tif(c=='>')a=mul(a,I); \n}\nint F(int a,int b,int x){ R add(mul(a,x),b); }\nmap<int,int> M;\nint main(){\n\tscanf(\"%d%s\",&n,s+1); \n\tdec(i,n,1)u=f(s[i],u); \n\tA[n+1]=1,B[n+1]=0; dec(i,n,1)g(s[i],A[i]=A[i+1],B[i]=B[i+1]); \n\t++M[F(A[n+1],B[n+1],0)]; dec(i,n,1)ans+=M[F(A[i],B[i],u)],++M[F(A[i],B[i],0)];\n\tprintf(\"%lld\\n\",ans);\n\tR 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * File    : F.cpp\n * Author  : Kazune Takahashi\n * Created : 2018-7-2 20:45:55\n * Powered by Visual Studio Code\n */\n\n#include <iostream>\n#include <iomanip>   // << fixed << setprecision(xxx)\n#include <algorithm> // do { } while ( next_permutation(A, A+xxx) ) ;\n#include <vector>\n#include <string> // to_string(nnn) // substr(m, n) // stoi(nnn)\n#include <complex>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <map> // if (M.find(key) != M.end()) { }\n#include <set>\n#include <random> // random_device rd; mt19937 mt(rd());\n#include <chrono> // std::chrono::system_clock::time_point start_time, end_time;\n// start = std::chrono::system_clock::now();\n// double elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(end_time-start_time).count();\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\n#define DEBUG 0 // change 0 -> 1 if we need debug.\n\ntypedef long long ll;\n\n// const int dx[4] = {1, 0, -1, 0};\n// const int dy[4] = {0, 1, 0, -1};\n\n// const int C = 1e6+10;\nconst ll MOD = 1000000007;\nconst ll M = 250010;\nrandom_device rd;\nmt19937 mt(rd());\ntypedef tuple<ll, ll> D;\n\nint N;\nstring S;\nmap<ll, int> ans;\nll X;\nll X_inv;\nll C;\nll a[500100];\nD g[250010];\nmap<ll, ll> G;\n\nll power2(int i)\n{\n  if (i == 0)\n  {\n    return 1;\n  }\n  else if (i % 2 == 0)\n  {\n    ll half = power2(i / 2);\n    return (half * half) % MOD;\n  }\n  else\n  {\n    return (power2(i - 1) * X) % MOD;\n  }\n}\n\nll power(int i)\n{\n  if (i == 0)\n  {\n    return 1;\n  }\n  else if (i < 0)\n  {\n    return power2(MOD + i - 1);\n  }\n  return power2(i);\n}\n\nll calc_hash()\n{\n  fill(a, a + 500100, 0);\n  int P = M;\n  for (auto e : S)\n  {\n    if (e == '+')\n    {\n      a[P]++;\n    }\n    else if (e == '-')\n    {\n      a[P]--;\n    }\n    else if (e == '>')\n    {\n      P++;\n    }\n    else\n    {\n      P--;\n    }\n  }\n  ll res = 0;\n  for (auto i = 0; i < 500100; i++)\n  {\n    res += (((MOD + a[i]) % MOD) * power(i - M)) % MOD;\n    res %= MOD;\n  }\n  return res;\n}\n\nvoid calc_g()\n{\n  g[N] = D(1, 0);\n  for (auto i = N - 1; i >= 0; i--)\n  {\n    ll A_prime = get<0>(g[i + 1]);\n    ll B_prime = get<1>(g[i + 1]);\n    ll A, B;\n    if (S[i] == '+')\n    {\n      A = 1, B = MOD - 1;\n    }\n    else if (S[i] == '-')\n    {\n      A = 1, B = 1;\n    }\n    else if (S[i] == '>')\n    {\n      A = X_inv, B = 0;\n    }\n    else\n    {\n      A = X, B = 0;\n    }\n    g[i] = D((A_prime * A) % MOD,\n             ((A_prime * B) % MOD + B_prime) % MOD);\n  }\n}\n\nll count_ans()\n{\n  ll res = 0;\n  G.clear();\n  for (int i = N; i >= 1; i--)\n  {\n    ll J = get<1>(g[i]);\n    if (G.find(J) == G.end())\n    {\n      G[J] = 1;\n    }\n    else\n    {\n      G[J]++;\n    }\n    ll I = ((get<0>(g[i - 1]) * C) % MOD + get<1>(g[i - 1])) % MOD;\n\n    if (G.find(I) != G.end())\n    {\n      // cerr << \"i = \" << i - 1 << \", cnt of j = \" << G[I] << endl;\n      res += G[I];\n    }\n  }\n  return res;\n}\n\nvoid solve()\n{\n  X = abs((ll)mt());\n  X_inv = power(-1);\n  C = calc_hash();\n  calc_g();\n  ll res = count_ans();\n  if (ans.find(res) == ans.end())\n  {\n    ans[res] = 1;\n  }\n  else\n  {\n    ans[res]++;\n  }\n}\n\nint main()\n{\n  cin >> N >> S;\n  for (auto i = 0; i < 3; i++)\n  {\n    solve();\n  }\n  ll res = 0;\n  int maxi = 0;\n  for (auto e : ans)\n  {\n    ll a = e.first;\n    int cnt = e.second;\n    if (cnt > maxi)\n    {\n      cnt = maxi;\n      res = a;\n    }\n  }\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cmath>\n#include<cstdlib>\n#include<set>\n#define LL long long\n#define LD long double\nusing namespace std;\nconst int NN=250000 +117;\nconst int MM= +117;\n#define mod1 998244353\n#define mod2 1004535809\nint read(){\n\tint fl=1,x;char c;\n\tfor(c=getchar();(c<'0'||c>'9')&&c!='-';c=getchar());\n\tif(c=='-'){fl=-1;c=getchar();}\n\tfor(x=0;c>='0'&&c<='9';c=getchar())\n\t\tx=(x<<3)+(x<<1)+c-'0';\n\treturn x*fl;\n}\nvoid open(){\n\tfreopen(\"99f.in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n}\nvoid close(){\n\tfclose(stdin);\n\tfclose(stdout);\n}\n \n \nint m,n;\nmultiset<LL> a;\nchar s[NN]={};\nLL ksm(LL a,LL b){\n\tLL ret=1;\n\twhile(b){\n\t\tif(b&1){\n\t\t\tret*=a;\n\t\t\tret%=mod1;\n\t\t}\n\t\ta*=a;\n\t\ta%=mod1;\n\t\tb>>=1;\n\t}\n\treturn ret;\n}\nint main(){\n\t//open();\n\tn=read();\n\tscanf(\"%s\",s);\n\tLL res=0;\n\tLL rev=ksm(mod2,mod1-2);\n\tLL p=1;\n\tfor(int i=0;i<n;++i){\n\t\tif(s[i]=='+'){\n\t\t\tres+=p;\n\t\t\tres%=mod1;\n\t\t}\n\t\tif(s[i]=='-'){\n\t\t\tres+=mod1-p;\n\t\t\tres%=mod1;\n\t\t}\n\t\tif(s[i]=='<'){\n\t\t\tp*=rev;\n\t\t\tp%=mod1;\n\t\t}\n\t\tif(s[i]=='>'){\n\t\t\tp*=mod2;\n\t\t\tp%=mod1;\n\t\t}\n\t}\n\tp=1;\n\tLL tp=0;\n\tLL ans=0;\n\tfor(int i=0;i<n;++i){\n\t\ta.insert((tp+p*res)%mod1);\n\t\tif(s[i]=='+'){\n\t\t\ttp+=p;\n\t\t\ttp%=mod1;\n\t\t}\n\t\tif(s[i]=='-'){\n\t\t\ttp+=mod1-p;\n\t\t\ttp%=mod1;\n\t\t}\n\t\tif(s[i]=='<'){\n\t\t\tp*=rev;\n\t\t\tp%=mod1;\n\t\t}\n\t\tif(s[i]=='>'){\n\t\t\tp*=mod2;\n\t\t\tp%=mod1;\n\t\t}\n\t\tans+=a.count(tp);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\tclose();\n\treturn 0;\n}"
  },
  {
    "language": "Text",
    "code": "1333"
  },
  {
    "language": "Text",
    "code": "1333"
  },
  {
    "language": "Text",
    "code": "おわりじゃん"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <sys/time.h>\n\n#define N\t250000\n#define MD\t0x7fffffff\n\nint rand_(int n) {\n\treturn (rand() * 76543LL + rand()) % n;\n}\n\nint inv(int a) {\n\treturn a == 1 ? 1 : (long long) inv(a - MD % a) * (MD / a + 1) % MD; \n}\n\nint X, Y, IX, IY;\n\nvoid srand_() {\n\tstruct timeval tv;\n\n\tgettimeofday(&tv, NULL);\n\tsrand(tv.tv_sec ^ tv.tv_usec);\n\tX = rand_(MD - N * 2) + N * 2, IX = inv(X);\n\tY = rand_(MD - N * 2) + N * 2, IY = inv(Y);\n}\n\nlong long xy[N + 1];\n\nint compare(const void *a, const void *b) {\n\tint i = *(int *) a;\n\tint j = *(int *) b;\n\n\treturn xy[i] == xy[j] ? 0 : (xy[i] < xy[j] ? -1 : 1);\n}\n\nint find(long long *aa, int n, long long a) {\n\tint lower = -1, upper = n;\n\n\twhile (upper - lower > 1) {\n\t\tint i = (lower + upper) / 2;\n\n\t\tif (aa[i] <= a)\n\t\t\tlower = i;\n\t\telse\n\t\t\tupper = i;\n\t}\n\treturn lower == -1 || aa[lower] != a ? -1 : lower;\n}\n\nint main() {\n\tstatic char cc[N + 1];\n\tstatic long long xy_[N + 1];\n\tstatic int ii[N + 1], hh[N + 1], kk[N + 1];\n\tint n, n_, i;\n\tlong long x, y, px, py, ans;\n\n\tsrand_();\n\tscanf(\"%d%s\", &n, cc);\n\tx = y = 0, px = py = 1;\n\tfor (i = 0; i < n; i++) {\n\t\tif (cc[i] == '+')\n\t\t\tx = (x + px) % MD, y = (y + py) % MD;\n\t\telse if (cc[i] == '-')\n\t\t\tx = (x - px) % MD, y = (y - py) % MD;\n\t\telse if (cc[i] == '>')\n\t\t\tpx = px * X % MD, py = py * Y % MD;\n\t\telse\n\t\t\tpx = px * IX % MD, py = py * IY % MD;\n\t\tif (x < 0)\n\t\t\tx += MD;\n\t\tif (y < 0)\n\t\t\ty += MD;\n\t\txy[i + 1] = x * MD + y;\n\t}\n\tfor (i = 0; i <= n; i++)\n\t\tii[i] = i;\n\tqsort(ii, n + 1, sizeof *ii, compare);\n\tn_ = 0;\n\tfor (i = 0; i <= n; i++) {\n\t\tint i_ = ii[i];\n\n\t\tif (n_ == 0 || xy_[n_ - 1] != xy[i_])\n\t\t\txy_[n_++] = xy[i_];\n\t\thh[i_] = n_ - 1;\n\t}\n\tans = 0;\n\tfor (i = n; i >= 0; i--) {\n\t\tint h;\n\n\t\tif (cc[i] == '>')\n\t\t\tpx = px * IX % MD, py = py * IY % MD;\n\t\telse if (cc[i] == '<')\n\t\t\tpx = px * X % MD, py = py * Y % MD;\n\t\tx = (xy[n] / MD * px + xy[i] / MD) % MD;\n\t\ty = (xy[n] % MD * py + xy[i] % MD) % MD;\n\t\tif (x < 0)\n\t\t\tx += MD;\n\t\tif (y < 0)\n\t\t\ty += MD;\n\t\th = find(xy_, n_, x * MD + y);\n\t\tif (h != -1)\n\t\t\tans += kk[h];\n\t\tkk[hh[i]]++;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.Random;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\tstatic final int O = 260000;\n\t\n\tstatic long[][] ipowers;\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni();\n\t\tchar[] s = ns(n);\n\t\t\n\t\tRollingHashFactory rhf = new RollingHashFactory(2, 600000, new Random(114514));\n\t\tipowers = new long[2][];\n\t\tfor(int i = 0;i < 2;i++){\n\t\t\tipowers[i] = new long[rhf.powers[i].length];\n\t\t\tipowers[i][0] = 1;\n\t\t\tlong x = invl(rhf.muls[i], rhf.mods[i]);\n\t\t\tfor(int j = 1;j < ipowers[i].length;j++){\n\t\t\t\tipowers[i][j] = ipowers[i][j-1] * x % rhf.mods[i];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint pos = 0;\n\t\tlong hu = 0, hl = 0;\n\t\tfor(char c : s){\n\t\t\tif(c == '>'){\n\t\t\t\tpos++;\n\t\t\t}else if(c == '<'){\n\t\t\t\tpos--;\n\t\t\t}else if(c == '+'){\n\t\t\t\thu += rhf.powers[0][O+pos];\n\t\t\t\thu %= rhf.mods[0];\n\t\t\t\thl += rhf.powers[1][O+pos];\n\t\t\t\thl %= rhf.mods[1];\n\t\t\t}else if(c == '-'){\n\t\t\t\thu += rhf.mods[0] - rhf.powers[0][O+pos];\n\t\t\t\thu %= rhf.mods[0];\n\t\t\t\thl += rhf.mods[1] - rhf.powers[1][O+pos];\n\t\t\t\thl %= rhf.mods[1];\n\t\t\t}\n\t\t}\n\t\t\n\t\tans = 0;\n\t\tdfs(0, n, s, rhf, hu, hl);\n\t\tout.println(ans);\n\t}\n\t\n\tstatic long ans = 0;\n\t\n\tstatic void dfs(int l, int r, char[] s, RollingHashFactory rhf, long HU, long HL)\n\t{\n\t\tif(l >= r)return;\n\t\tint h = l+r>>1;\n\t\tlong rhu = 0, rhl = 0;\n\t\tlong[] hits = new long[r-h];\n\t\t{\n\t\t\tint p = 0;\n\t\t\tint pos = 0;\n\t\t\thits[p++] = 0;\n\t\t\tfor(int i = h+1;i < r;i++){\n\t\t\t\tchar c = s[i];\n\t\t\t\tif(c == '>'){\n\t\t\t\t\tpos++;\n\t\t\t\t}else if(c == '<'){\n\t\t\t\t\tpos--;\n\t\t\t\t}else if(c == '+'){\n\t\t\t\t\trhu += rhf.powers[0][O+pos];\n\t\t\t\t\trhu %= rhf.mods[0];\n\t\t\t\t\trhl += rhf.powers[1][O+pos];\n\t\t\t\t\trhl %= rhf.mods[1];\n\t\t\t\t}else if(c == '-'){\n\t\t\t\t\trhu += rhf.mods[0] - rhf.powers[0][O+pos];\n\t\t\t\t\trhu %= rhf.mods[0];\n\t\t\t\t\trhl += rhf.mods[1] - rhf.powers[1][O+pos];\n\t\t\t\t\trhl %= rhf.mods[1];\n\t\t\t\t}\n\t\t\t\tlong rh = rhu<<32|rhl;\n\t\t\t\thits[p++] = rh;\n\t\t\t}\n\t\t}\n\t\tArrays.sort(hits);\n//\t\ttr(h, r);\n\t\t\n\t\tlong lhu = 0, lhl = 0;\n\t\t\n\t\tint pos = 0;\n\t\tfor(int i = h;i >= l;i--){\n\t\t\tchar c = s[i];\n\t\t\tif(c == '<'){\n\t\t\t\tpos++;\n\t\t\t}else if(c == '>'){\n\t\t\t\tpos--;\n\t\t\t}else if(c == '+'){\n\t\t\t\tlhu += rhf.powers[0][O+pos];\n\t\t\t\tlhu %= rhf.mods[0];\n\t\t\t\tlhl += rhf.powers[1][O+pos];\n\t\t\t\tlhl %= rhf.mods[1];\n\t\t\t}else if(c == '-'){\n\t\t\t\tlhu += rhf.mods[0] - rhf.powers[0][O+pos];\n\t\t\t\tlhu %= rhf.mods[0];\n\t\t\t\tlhl += rhf.mods[1] - rhf.powers[1][O+pos];\n\t\t\t\tlhl %= rhf.mods[1];\n\t\t\t}\n\t\t\t// (L+R)*P^(-LS) = G?\n\t\t\tlong thu = HU*(pos < 0 ? ipowers[0][-pos] :\n\t\t\t\trhf.powers[0][pos]) - lhu;\n\t\t\tthu %= rhf.mods[0];\n\t\t\tif(thu < 0)thu += rhf.mods[0];\n\t\t\t\n\t\t\tlong thl = HL*(pos < 0 ? ipowers[1][-pos] :\n\t\t\t\trhf.powers[1][pos]) - lhl;\n\t\t\tthl %= rhf.mods[1];\n\t\t\tif(thl < 0)thl += rhf.mods[1];\n\t\t\t\n\t\t\tlong th = thu<<32|thl;\n//\t\t\tif(lowerBound(hits, th+1) - lowerBound(hits, th) > 0)tr(th, i, l, h, r);\n\t\t\tans += lowerBound(hits, th+1) - lowerBound(hits, th);\n\t\t}\n\t\t\n\t\tdfs(l, h, s, rhf, HU, HL);\n\t\tdfs(h+1, r, s, rhf, HU, HL);\n\t}\n\t\n\tpublic static int lowerBound(long[] a, long v)\n\t{\n\t\tint low = -1, high = a.length;\n\t\twhile(high-low > 1){\n\t\t\tint h = high+low>>>1;\n\t\t\tif(a[h] >= v){\n\t\t\t\thigh = h;\n\t\t\t}else{\n\t\t\t\tlow = h;\n\t\t\t}\n\t\t}\n\t\treturn high;\n\t}\n\n\t\n\tpublic static long invl(long a, long mod) {\n\t\tlong b = mod;\n\t\tlong p = 1, q = 0;\n\t\twhile (b > 0) {\n\t\t\tlong c = a / b;\n\t\t\tlong d;\n\t\t\td = a;\n\t\t\ta = b;\n\t\t\tb = d % b;\n\t\t\td = p;\n\t\t\tp = q;\n\t\t\tq = d - c * q;\n\t\t}\n\t\treturn p < 0 ? p + mod : p;\n\t}\n\n\tpublic static class RollingHashFactory\n\t{\n\t\tpublic int[] mods;\n\t\tpublic int[] muls;\n\t\tpublic long[][] powers;\n\t\tpublic int deg;\n\t\t\n\t\tpublic RollingHashFactory(int deg, int n, Random gen)\n\t\t{\n\t\t\tthis.deg = deg;\n\t\t\tmods = new int[deg];\n\t\t\tmuls = new int[deg];\n\t\t\tfor(int i = 0;i < deg;i++){\n\t\t\t\tmods[i] = BigInteger.probablePrime(30, gen).intValue();\n\t\t\t\tmuls[i] = BigInteger.probablePrime(30, gen).intValue();\n\t\t\t}\n\t\t\tpowers = new long[deg][n+1];\n\t\t\tfor(int i = 0;i < deg;i++){\n\t\t\t\tpowers[i][0] = 1;\n\t\t\t\tfor(int j = 1;j <= n;j++){\n\t\t\t\t\tpowers[i][j] = powers[i][j-1] * muls[i] % mods[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.Random;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\tstatic final int O = 300000;\n\t\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni();\n\t\tchar[] s = ns(n);\n\t\t\n\t\tRollingHashFactory rhf = new RollingHashFactory(2, 600000, new Random(114514));\n\t\t\n\t\tint pos = 0;\n\t\tlong hu = 0, hl = 0;\n\t\tfor(char c : s){\n\t\t\tif(c == '>'){\n\t\t\t\tpos++;\n\t\t\t}else if(c == '<'){\n\t\t\t\tpos--;\n\t\t\t}else if(c == '+'){\n\t\t\t\thu += rhf.powers[0][O+pos];\n\t\t\t\thu %= rhf.mods[0];\n\t\t\t\thl += rhf.powers[1][O+pos];\n\t\t\t\thl %= rhf.mods[1];\n\t\t\t}else if(c == '-'){\n\t\t\t\thu += rhf.mods[0] - rhf.powers[0][O+pos];\n\t\t\t\thu %= rhf.mods[0];\n\t\t\t\thl += rhf.mods[1] - rhf.powers[1][O+pos];\n\t\t\t\thl %= rhf.mods[1];\n\t\t\t}\n\t\t}\n\t\t\n\t\tans = 0;\n\t\tdfs(0, n, s, rhf, hu, hl);\n\t\tout.println(ans);\n\t}\n\t\n\tstatic long ans = 0;\n\t\n\tstatic void dfs(int l, int r, char[] s, RollingHashFactory rhf, long HU, long HL)\n\t{\n\t\tif(l >= r)return;\n\t\tint h = l+r>>1;\n\t\t// hを必ず通る(長さ2以上)\n\t\tlong rhu = 0, rhl = 0;\n\t\tlong[] hits = new long[r-h];\n\t\t{\n\t\t\tint p = 0;\n\t\t\tint pos = 0;\n\t\t\thits[p++] = 0;\n\t\t\tfor(int i = h+1;i < r;i++){\n\t\t\t\tchar c = s[i];\n\t\t\t\tif(c == '>'){\n\t\t\t\t\tpos++;\n\t\t\t\t}else if(c == '<'){\n\t\t\t\t\tpos--;\n\t\t\t\t}else if(c == '+'){\n\t\t\t\t\trhu += rhf.powers[0][O+pos];\n\t\t\t\t\trhu %= rhf.mods[0];\n\t\t\t\t\trhl += rhf.powers[1][O+pos];\n\t\t\t\t\trhl %= rhf.mods[1];\n\t\t\t\t}else if(c == '-'){\n\t\t\t\t\trhu += rhf.mods[0] - rhf.powers[0][O+pos];\n\t\t\t\t\trhu %= rhf.mods[0];\n\t\t\t\t\trhl += rhf.mods[1] - rhf.powers[1][O+pos];\n\t\t\t\t\trhl %= rhf.mods[1];\n\t\t\t\t}\n\t\t\t\tlong rh = rhu<<32|rhl;\n\t\t\t\thits[p++] = rh;\n\t\t\t}\n\t\t}\n\t\tArrays.sort(hits);\n//\t\ttr(h, r);\n\t\t\n\t\tlong lhu = 0, lhl = 0;\n\t\t\n\t\tint pos = 0;\n\t\tfor(int i = h;i >= l;i--){\n\t\t\tchar c = s[i];\n\t\t\tif(c == '<'){\n\t\t\t\tpos++;\n\t\t\t}else if(c == '>'){\n\t\t\t\tpos--;\n\t\t\t}else if(c == '+'){\n\t\t\t\tlhu += rhf.powers[0][O+pos];\n\t\t\t\tlhu %= rhf.mods[0];\n\t\t\t\tlhl += rhf.powers[1][O+pos];\n\t\t\t\tlhl %= rhf.mods[1];\n\t\t\t}else if(c == '-'){\n\t\t\t\tlhu += rhf.mods[0] - rhf.powers[0][O+pos];\n\t\t\t\tlhu %= rhf.mods[0];\n\t\t\t\tlhl += rhf.mods[1] - rhf.powers[1][O+pos];\n\t\t\t\tlhl %= rhf.mods[1];\n\t\t\t}\n\t\t\t// (L+R)*P^(-LS) = G?\n\t\t\tlong thu = HU*(pos < 0 ? invl(rhf.powers[0][-pos], rhf.mods[0]) :\n\t\t\t\trhf.powers[0][pos]) - lhu;\n\t\t\tthu %= rhf.mods[0];\n\t\t\tif(thu < 0)thu += rhf.mods[0];\n\t\t\t\n\t\t\tlong thl = HL*(pos < 0 ? invl(rhf.powers[1][-pos], rhf.mods[1]) :\n\t\t\t\trhf.powers[1][pos]) - lhl;\n\t\t\tthl %= rhf.mods[1];\n\t\t\tif(thl < 0)thl += rhf.mods[1];\n\t\t\t\n\t\t\tlong th = thu<<32|thl;\n//\t\t\tif(lowerBound(hits, th+1) - lowerBound(hits, th) > 0)tr(th, i, l, h, r);\n\t\t\tans += lowerBound(hits, th+1) - lowerBound(hits, th);\n\t\t}\n\t\t\n\t\tdfs(l, h, s, rhf, HU, HL);\n\t\tdfs(h+1, r, s, rhf, HU, HL);\n\t}\n\t\n\tpublic static int lowerBound(long[] a, long v)\n\t{\n\t\tint low = -1, high = a.length;\n\t\twhile(high-low > 1){\n\t\t\tint h = high+low>>>1;\n\t\t\tif(a[h] >= v){\n\t\t\t\thigh = h;\n\t\t\t}else{\n\t\t\t\tlow = h;\n\t\t\t}\n\t\t}\n\t\treturn high;\n\t}\n\n\t\n\tpublic static long invl(long a, long mod) {\n\t\tlong b = mod;\n\t\tlong p = 1, q = 0;\n\t\twhile (b > 0) {\n\t\t\tlong c = a / b;\n\t\t\tlong d;\n\t\t\td = a;\n\t\t\ta = b;\n\t\t\tb = d % b;\n\t\t\td = p;\n\t\t\tp = q;\n\t\t\tq = d - c * q;\n\t\t}\n\t\treturn p < 0 ? p + mod : p;\n\t}\n\n\t\n\tpublic static class RollingHash\n\t{\n\t\tpublic RollingHashFactory rhf;\n\t\tpublic long[][] buf;\n\t\tpublic int p;\n\t\t\n\t\tpublic RollingHash(int bufsize, RollingHashFactory rhf)\n\t\t{\n\t\t\tbuf = new long[rhf.deg][bufsize+1];\n\t\t\tthis.rhf = rhf;\n\t\t\tthis.p = 1;\n\t\t}\n\t\t\n\t\tpublic void add(int c)\n\t\t{\n\t\t\tfor(int i = 0;i < rhf.deg;i++)buf[i][p] = (buf[i][p-1]*rhf.muls[i]+c)%rhf.mods[i];\n\t\t\tp++;\n\t\t}\n\t\t\n\t\tpublic void addr(int c)\n\t\t{\n\t\t\tfor(int i = 0;i < rhf.deg;i++)buf[i][p] = (buf[i][p-1]+rhf.powers[i][p-1]*c)%rhf.mods[i];\n\t\t\tp++;\n\t\t}\n\t\t\n\t\tpublic long queryTwin(int r)\n\t\t{\n\t\t\treturn buf[0][r]<<32|buf[1][r];\n\t\t}\n\t\t\n\t\tpublic long queryTwin(int l, int r)\n\t\t{\n\t\t\tassert l > r;\n\t\t\tassert rhf.deg == 2;\n\t\t\tlong h = 0;\n\t\t\tfor(int i = 0;i < rhf.deg;i++){\n\t\t\t\tlong v = (buf[i][r] - buf[i][l] * rhf.powers[i][r-l]) % rhf.mods[i];\n\t\t\t\tif(v < 0)v += rhf.mods[i];\n\t\t\t\th = h<<32|v;\n\t\t\t}\n\t\t\treturn h;\n\t\t}\n\t\t\n\t\tpublic long[] query(int l, int r)\n\t\t{\n\t\t\tassert l > r;\n\t\t\tlong[] h = new long[rhf.deg];\n\t\t\tfor(int i = 0;i < rhf.deg;i++){\n\t\t\t\th[i] = (buf[i][r] - buf[i][l] * rhf.powers[i][r-l]) % rhf.mods[i];\n\t\t\t\tif(h[i] < 0)h[i] += rhf.mods[i];\n\t\t\t}\n\t\t\treturn h;\n\t\t}\n\t\t\n\t\tpublic static long add(long a, long b, int w, RollingHashFactory rhf)\n\t\t{\n\t\t\tassert rhf.deg == 2;\n\t\t\tlong high = ((a>>>32) * rhf.powers[0][w] + (b>>>32)) % rhf.mods[0];\n\t\t\tlong low = ((long)(int)a * rhf.powers[1][w] + (int)b) % rhf.mods[1];\n\t\t\treturn high<<32|low;\n\t\t}\n\t}\n\t\n\tpublic static class RollingHashFactory\n\t{\n\t\tpublic int[] mods;\n\t\tpublic int[] muls;\n\t\tpublic long[][] powers;\n\t\tpublic int deg;\n\t\t\n\t\tpublic RollingHashFactory(int deg, int n, Random gen)\n\t\t{\n\t\t\tthis.deg = deg;\n\t\t\tmods = new int[deg];\n\t\t\tmuls = new int[deg];\n\t\t\tfor(int i = 0;i < deg;i++){\n\t\t\t\tmods[i] = BigInteger.probablePrime(30, gen).intValue();\n\t\t\t\tmuls[i] = BigInteger.probablePrime(30, gen).intValue();\n\t\t\t}\n\t\t\tpowers = new long[deg][n+1];\n\t\t\tfor(int i = 0;i < deg;i++){\n\t\t\t\tpowers[i][0] = 1;\n\t\t\t\tfor(int j = 1;j <= n;j++){\n\t\t\t\t\tpowers[i][j] = powers[i][j-1] * muls[i] % mods[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            TaskF solver = new TaskF();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class TaskF {\n        Modular mod = new Modular(1e9 + 7);\n        Power power = new Power(mod);\n        int[] xs = new int[]{31, 61};\n        int[] invXs = new int[]{power.inverseByFermat(xs[0]), power.inverseByFermat(xs[1])};\n        Debug debug = new Debug(false);\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            char[] s = new char[n];\n            in.readString(s, 0);\n\n            LinearFunction[][] pos = new LinearFunction[2][n];\n            LinearFunction[][] neg = new LinearFunction[2][n];\n\n\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < 2; j++) {\n                    switch (s[i]) {\n                        case '+':\n                            pos[j][i] = new LinearFunction(1, 1);\n                            neg[j][i] = new LinearFunction(1, -1);\n                            break;\n                        case '-':\n                            pos[j][i] = new LinearFunction(1, -1);\n                            neg[j][i] = new LinearFunction(1, 1);\n                            break;\n                        case '>':\n                            pos[j][i] = new LinearFunction(xs[j], 0);\n                            neg[j][i] = new LinearFunction(invXs[j], 0);\n                            break;\n                        case '<':\n                            pos[j][i] = new LinearFunction(invXs[j], 0);\n                            neg[j][i] = new LinearFunction(xs[j], 0);\n                            break;\n                    }\n                }\n            }\n\n            debug.debug(\"pos\", pos);\n            debug.debug(\"neg\", neg);\n            for (int i = n - 2; i >= 0; i--) {\n                for (int j = 0; j < 2; j++) {\n                    pos[j][i] = LinearFunction.merge(pos[j][i], pos[j][i + 1], mod);\n                    neg[j][i] = LinearFunction.merge(neg[j][i + 1], neg[j][i], mod);\n                }\n            }\n\n\n            debug.debug(\"pos\", pos);\n            debug.debug(\"neg\", neg);\n\n            int[] cs = new int[2];\n            for (int i = 0; i < 2; i++) {\n                cs[i] = pos[i][0].apply(0, mod);\n            }\n\n            debug.debug(\"cs\", cs);\n\n            long ans = 0;\n            LongHashMap map = new LongHashMap(n, false);\n            map.put(0, 1);\n            for (int i = n - 1; i >= 0; i--) {\n                int c0 = neg[0][i].apply(cs[0], mod);\n                int c1 = neg[1][i].apply(cs[1], mod);\n                long c = DigitUtils.asLong(c0, c1);\n\n                long local = map.getOrDefault(c, 0);\n                ans += local;\n                if (local > 0) {\n                    debug.debug(\"i\", i);\n                    debug.debug(\"local\", local);\n                }\n\n                int d0 = neg[0][i].apply(0, mod);\n                int d1 = neg[1][i].apply(0, mod);\n                long d = DigitUtils.asLong(d0, d1);\n                map.put(d, map.getOrDefault(d, 0) + 1);\n            }\n\n            out.println(ans);\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput append(long c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput println(long c) {\n            return append(c).println();\n        }\n\n        public FastOutput println() {\n            cache.append(System.lineSeparator());\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static class Modular {\n        int m;\n\n        public Modular(int m) {\n            this.m = m;\n        }\n\n        public Modular(long m) {\n            this.m = (int) m;\n            if (this.m != m) {\n                throw new IllegalArgumentException();\n            }\n        }\n\n        public Modular(double m) {\n            this.m = (int) m;\n            if (this.m != m) {\n                throw new IllegalArgumentException();\n            }\n        }\n\n        public int valueOf(int x) {\n            x %= m;\n            if (x < 0) {\n                x += m;\n            }\n            return x;\n        }\n\n        public int valueOf(long x) {\n            x %= m;\n            if (x < 0) {\n                x += m;\n            }\n            return (int) x;\n        }\n\n        public String toString() {\n            return \"mod \" + m;\n        }\n\n    }\n\n    static class LongHashMap {\n        private int[] slot;\n        private int[] next;\n        private long[] keys;\n        private long[] values;\n        private int alloc;\n        private boolean[] removed;\n        private int mask;\n        private int size;\n        private boolean rehash;\n        private Hasher hasher = new Hasher();\n\n        public LongHashMap(int cap, boolean rehash) {\n            this.mask = (1 << (32 - Integer.numberOfLeadingZeros(cap - 1))) - 1;\n            slot = new int[mask + 1];\n            next = new int[cap + 1];\n            keys = new long[cap + 1];\n            values = new long[cap + 1];\n            removed = new boolean[cap + 1];\n            this.rehash = rehash;\n        }\n\n        private void doubleCapacity() {\n            int newSize = Math.max(next.length + 10, next.length * 2);\n            next = Arrays.copyOf(next, newSize);\n            keys = Arrays.copyOf(keys, newSize);\n            values = Arrays.copyOf(values, newSize);\n            removed = Arrays.copyOf(removed, newSize);\n        }\n\n        public void alloc() {\n            alloc++;\n            if (alloc >= next.length) {\n                doubleCapacity();\n            }\n            next[alloc] = 0;\n            removed[alloc] = false;\n            size++;\n        }\n\n        private void rehash() {\n            int[] newSlots = new int[Math.max(16, slot.length * 2)];\n            int newMask = newSlots.length - 1;\n            for (int i = 0; i < slot.length; i++) {\n                if (slot[i] == 0) {\n                    continue;\n                }\n                int head = slot[i];\n                while (head != 0) {\n                    int n = next[head];\n                    int s = hash(keys[head]) & newMask;\n                    next[head] = newSlots[s];\n                    newSlots[s] = head;\n                    head = n;\n                }\n            }\n            this.slot = newSlots;\n            this.mask = newMask;\n        }\n\n        private int hash(long x) {\n            return hasher.hash(x);\n        }\n\n        public void put(long x, long y) {\n            put(x, y, true);\n        }\n\n        public void put(long x, long y, boolean cover) {\n            int h = hash(x);\n            int s = h & mask;\n            if (slot[s] == 0) {\n                alloc();\n                slot[s] = alloc;\n                keys[alloc] = x;\n                values[alloc] = y;\n            } else {\n                int index = findIndexOrLastEntry(s, x);\n                if (keys[index] != x) {\n                    alloc();\n                    next[index] = alloc;\n                    keys[alloc] = x;\n                    values[alloc] = y;\n                } else if (cover) {\n                    values[index] = y;\n                }\n            }\n            if (rehash && size >= slot.length) {\n                rehash();\n            }\n        }\n\n        public long getOrDefault(long x, long def) {\n            int h = hash(x);\n            int s = h & mask;\n            if (slot[s] == 0) {\n                return def;\n            }\n            int index = findIndexOrLastEntry(s, x);\n            return keys[index] == x ? values[index] : def;\n        }\n\n        private int findIndexOrLastEntry(int s, long x) {\n            int iter = slot[s];\n            while (keys[iter] != x) {\n                if (next[iter] != 0) {\n                    iter = next[iter];\n                } else {\n                    return iter;\n                }\n            }\n            return iter;\n        }\n\n        public LongEntryIterator iterator() {\n            return new LongEntryIterator() {\n                int index = 1;\n                int readIndex = -1;\n\n\n                public boolean hasNext() {\n                    while (index <= alloc && removed[index]) {\n                        index++;\n                    }\n                    return index <= alloc;\n                }\n\n\n                public long getEntryKey() {\n                    return keys[readIndex];\n                }\n\n\n                public long getEntryValue() {\n                    return values[readIndex];\n                }\n\n\n                public void next() {\n                    if (!hasNext()) {\n                        throw new IllegalStateException();\n                    }\n                    readIndex = index;\n                    index++;\n                }\n            };\n        }\n\n        public String toString() {\n            LongEntryIterator iterator = iterator();\n            StringBuilder builder = new StringBuilder(\"{\");\n            while (iterator.hasNext()) {\n                iterator.next();\n                builder.append(iterator.getEntryKey()).append(\"->\").append(iterator.getEntryValue()).append(',');\n            }\n            if (builder.charAt(builder.length() - 1) == ',') {\n                builder.setLength(builder.length() - 1);\n            }\n            builder.append('}');\n            return builder.toString();\n        }\n\n    }\n\n    static class LinearFunction {\n        public final int a;\n        public final int b;\n\n        public LinearFunction(int a, int b) {\n            this.a = a;\n            this.b = b;\n        }\n\n        public int apply(int x, Modular mod) {\n            return mod.valueOf((long) a * x + b);\n        }\n\n        public static LinearFunction merge(LinearFunction a, LinearFunction b, Modular mod) {\n            return new LinearFunction(mod.valueOf((long) a.a * b.a), mod.valueOf((long) a.a * b.b + a.b));\n        }\n\n        public boolean equals(Object obj) {\n            if (!(obj instanceof LinearFunction)) {\n                return false;\n            }\n            LinearFunction function = (LinearFunction) obj;\n            return function.a == a && function.b == b;\n        }\n\n        public int hashCode() {\n            return a * 31 + b;\n        }\n\n        public String toString() {\n            if (b >= 0) {\n                return a + \"x+\" + b;\n            }\n            return a + \"x\" + b;\n        }\n\n    }\n\n    static class Debug {\n        private boolean offline;\n        private PrintStream out = System.err;\n        static int[] empty = new int[0];\n\n        public Debug(boolean enable) {\n            offline = enable && System.getSecurityManager() == null;\n        }\n\n        public Debug debug(String name, int x) {\n            if (offline) {\n                debug(name, \"\" + x);\n            }\n            return this;\n        }\n\n        public Debug debug(String name, long x) {\n            if (offline) {\n                debug(name, \"\" + x);\n            }\n            return this;\n        }\n\n        public Debug debug(String name, String x) {\n            if (offline) {\n                out.printf(\"%s=%s\", name, x);\n                out.println();\n            }\n            return this;\n        }\n\n        public Debug debug(String name, Object x) {\n            return debug(name, x, empty);\n        }\n\n        public Debug debug(String name, Object x, int... indexes) {\n            if (offline) {\n                if (x == null || !x.getClass().isArray()) {\n                    out.append(name);\n                    for (int i : indexes) {\n                        out.printf(\"[%d]\", i);\n                    }\n                    out.append(\"=\").append(\"\" + x);\n                    out.println();\n                } else {\n                    indexes = Arrays.copyOf(indexes, indexes.length + 1);\n                    if (x instanceof byte[]) {\n                        byte[] arr = (byte[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof short[]) {\n                        short[] arr = (short[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof boolean[]) {\n                        boolean[] arr = (boolean[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof char[]) {\n                        char[] arr = (char[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof int[]) {\n                        int[] arr = (int[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof float[]) {\n                        float[] arr = (float[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof double[]) {\n                        double[] arr = (double[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof long[]) {\n                        long[] arr = (long[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else {\n                        Object[] arr = (Object[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    }\n                }\n            }\n            return this;\n        }\n\n    }\n\n    static class Power {\n        final Modular modular;\n\n        public Power(Modular modular) {\n            this.modular = modular;\n        }\n\n        public int pow(int x, int n) {\n            if (n == 0) {\n                return modular.valueOf(1);\n            }\n            long r = pow(x, n >> 1);\n            r = modular.valueOf(r * r);\n            if ((n & 1) == 1) {\n                r = modular.valueOf(r * x);\n            }\n            return (int) r;\n        }\n\n        public int inverseByFermat(int x) {\n            return pow(x, modular.m - 2);\n        }\n\n    }\n\n    static class DigitUtils {\n        private static long mask32 = (1L << 32) - 1;\n\n        private DigitUtils() {\n        }\n\n        public static long asLong(int high, int low) {\n            return (((long) high) << 32) | (((long) low) & mask32);\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 20];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n        public int readString(char[] data, int offset) {\n            skipBlank();\n\n            int originalOffset = offset;\n            while (next > 32) {\n                data[offset++] = (char) next;\n                next = read();\n            }\n\n            return offset - originalOffset;\n        }\n\n    }\n\n    static interface LongEntryIterator {\n        boolean hasNext();\n\n        void next();\n\n        long getEntryKey();\n\n        long getEntryValue();\n\n    }\n\n    static class Hasher {\n        private long time = System.nanoTime() + System.currentTimeMillis();\n\n        private int shuffle(long x) {\n            x += time;\n            x += 0x9e3779b97f4a7c15L;\n            x = (x ^ (x >>> 30)) * 0xbf58476d1ce4e5b9L;\n            x = (x ^ (x >>> 27)) * 0x94d049bb133111ebL;\n            return (int) (x ^ (x >>> 31));\n        }\n\n        public int hash(long x) {\n            return shuffle(x);\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.InputStreamReader;\nimport java.util.Map;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyInput in = new MyInput(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        long X;\n        long invX;\n\n        public void solve(int testNumber, MyInput in, PrintWriter out) {\n            int n = in.nextInt();\n            char[] cs = in.nextChars();\n\n            final int mod = (int) 1e9 + 7;\n            X = (int) 1e9 + 3;\n            invX = powmod(X, mod - 2, mod);\n            final long[] pow = new long[2 * n + 1];\n            pow[0] = powmod(X, (mod - 2L) * n % (mod - 1), mod);\n            for (int i = 1; i < pow.length; i++) pow[i] = pow[i - 1] * X % mod;\n\n//        dump(pow);\n\n            int[] xs = new int[n + 1];\n            xs[n] = n;\n            long c = 0;\n            for (int i = n - 1; i >= 0; i--) {\n                xs[i] = xs[i + 1];\n                if (cs[i] == '+') {\n                    c = (c + pow[xs[i]]) % mod;\n                }\n                if (cs[i] == '-') {\n                    c = (c + mod - pow[xs[i]]) % mod;\n                }\n                if (cs[i] == '>') {\n                    xs[i]++;\n                }\n                if (cs[i] == '<') {\n                    xs[i]--;\n                }\n            }\n        /*\n        int[] ys = new int[n+1];\n        ys[0] = n;\n        long[] hash0 = new long[n+1];\n        long[] hash1 = new long[n+1];\n        hash1[0] = 0;\n        for (int i = 0; i < n; i++) {\n            ys[i+1] = ys[i];\n            hash0[i+1] = hash0[i];\n            hash1[i+1] = hash1[i];\n            if (cs[i] == '-') { hash0[i+1] = (hash0[i] + pow[ys[i]]) % mod; }\n            if (cs[i] == '+') { hash0[i+1] = (hash0[i] + mod - pow[ys[i]]) % mod; }\n            if (cs[i] == '-') { hash1[i+1] = (hash1[i] + pow[ys[i]]) % mod; }\n            if (cs[i] == '+') { hash1[i+1] = (hash1[i] + mod - pow[ys[i]]) % mod; }\n            if (cs[i] == '<') { ys[i+1]++; }\n            if (cs[i] == '>') { ys[i+1]--; }\n        }\n        */\n\n//        dump(c);\n//        dump(hash0);\n//        dump(hash1);\n            long[][] mat = new long[3][3];\n            for (int i = 0; i < 3; i++) mat[i][i] = 1;\n            long ans = 0;\n            Map<Long, Integer> mp = new HashMap<>();\n            long[][] v0 = transpose(new long[][]{new long[]{0, 0, 1}});\n            long[][] vc = transpose(new long[][]{new long[]{c, 0, 1}});\n            for (int i = 0; i <= n; i++) {\n                long[][] m0 = mulmat(mat, v0, mod);\n                long[][] mc = mulmat(mat, vc, mod);\n                long h0 = ((m0[0][0] + m0[1][0]) % mod + mod) % mod;\n                long hc = ((mc[0][0] + mc[1][0]) % mod + mod) % mod;\n//            ans += mp.getOrDefault(hc, 0);\n//            dump(i, h0, hc, mp.getOrDefault(hc, 0));\n                mp.put(h0, mp.getOrDefault(h0, 0) + 1);\n                if (i < n) mat = mulmat(mat, getMat(cs[i]), mod);\n            }\n\n            mat = new long[3][3];\n            for (int i = 0; i < 3; i++) mat[i][i] = 1;\n            for (int i = 0; i <= n; i++) {\n                long[][] m0 = mulmat(mat, v0, mod);\n                long[][] mc = mulmat(mat, vc, mod);\n                long h0 = ((m0[0][0] + m0[1][0]) % mod + mod) % mod;\n                long hc = ((mc[0][0] + mc[1][0]) % mod + mod) % mod;\n                mp.put(h0, mp.getOrDefault(h0, 0) - 1);\n                ans += mp.getOrDefault(hc, 0);\n//            dump(i, h0, hc, mp.getOrDefault(hc, 0));\n                if (i < n) mat = mulmat(mat, getMat(cs[i]), mod);\n            }\n            out.println(ans);\n        }\n\n        long[][] getMat(char c) {\n            if (c == '+') {\n                return new long[][]{\n                        new long[]{1, 0, 0},\n                        new long[]{0, 1, 1},\n                        new long[]{0, 0, 1},\n                };\n            }\n            if (c == '-') {\n                return new long[][]{\n                        new long[]{1, 0, 0},\n                        new long[]{0, 1, -1},\n                        new long[]{0, 0, 1},\n                };\n            }\n            if (c == '<') {\n                return new long[][]{\n                        new long[]{X, X, 0},\n                        new long[]{0, 0, 0},\n                        new long[]{0, 0, 1},\n                };\n            }\n            if (c == '>') {\n                return new long[][]{\n                        new long[]{invX, invX, 0},\n                        new long[]{0, 0, 0},\n                        new long[]{0, 0, 1},\n                };\n            }\n            throw new RuntimeException();\n        }\n\n        static long[][] transpose(long[][] mat) {\n            long[][] res = new long[mat[0].length][mat.length];\n            for (int i = 0; i < mat.length; i++) {\n                for (int j = 0; j < mat[i].length; j++) {\n                    res[j][i] = mat[i][j];\n                }\n            }\n            return res;\n        }\n\n        static long[][] mulmat(long[][] a, long[][] b, int mod) {\n            final long BIG = (2L * mod) * (2L * mod);\n\n            assert (a[0].length == b.length);\n\n            final int n = a.length;\n            final int v = b.length;\n            final int m = b[0].length;\n\n            long[][] res = new long[n][m];\n            for (int i = 0; i < n; i++)\n                for (int k = 0; k < v; k++) {\n                    final long aa = a[i][k];\n                    for (int j = 0; j < m; j++) {\n                        res[i][j] += aa * b[k][j];\n                        if (res[i][j] >= BIG) res[i][j] -= BIG;\n                    }\n                }\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < m; j++)\n                    res[i][j] %= mod;\n\n            return res;\n        }\n\n        static long powmod(long n, long r, int m) {\n            long res = 1;\n            for (; r != 0; r >>>= 1, n = n * n % m) {\n                if ((r & 1) == 1) {\n                    res = res * n;\n                    if (res >= m) {\n                        res %= m;\n                    }\n                }\n            }\n            return res;\n        }\n\n    }\n\n    static class MyInput {\n        private final BufferedReader in;\n        private static int pos;\n        private static int readLen;\n        private static final char[] buffer = new char[1024 * 8];\n        private static char[] str = new char[500 * 8 * 2];\n        private static boolean[] isDigit = new boolean[256];\n        private static boolean[] isSpace = new boolean[256];\n        private static boolean[] isLineSep = new boolean[256];\n\n        static {\n            for (int i = 0; i < 10; i++) {\n                isDigit['0' + i] = true;\n            }\n            isDigit['-'] = true;\n            isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n            isLineSep['\\r'] = isLineSep['\\n'] = true;\n        }\n\n        public MyInput(InputStream is) {\n            in = new BufferedReader(new InputStreamReader(is));\n        }\n\n        public int read() {\n            if (pos >= readLen) {\n                pos = 0;\n                try {\n                    readLen = in.read(buffer);\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n                if (readLen <= 0) {\n                    throw new MyInput.EndOfFileRuntimeException();\n                }\n            }\n            return buffer[pos++];\n        }\n\n        public int nextInt() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            int ret = 0;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n\n        public char nextChar() {\n            while (true) {\n                final int c = read();\n                if (!isSpace[c]) {\n                    return (char) c;\n                }\n            }\n        }\n\n        int reads(int len, boolean[] accept) {\n            try {\n                while (true) {\n                    final int c = read();\n                    if (accept[c]) {\n                        break;\n                    }\n                    if (str.length == len) {\n                        char[] rep = new char[str.length * 3 / 2];\n                        System.arraycopy(str, 0, rep, 0, str.length);\n                        str = rep;\n                    }\n                    str[len++] = (char) c;\n                }\n            } catch (MyInput.EndOfFileRuntimeException e) {\n            }\n            return len;\n        }\n\n        public char[] nextChars() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            return Arrays.copyOf(str, len);\n        }\n\n        static class EndOfFileRuntimeException extends RuntimeException {\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.BitSet;\nimport java.util.Collections;\nimport java.util.StringTokenizer;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author kessido\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskE solver = new TaskE();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskE {\n        BitSet currentGroup;\n        BitSet currentOtherGroup;\n        int maxMinSize = -1;\n        ArrayList<Integer> options;\n        int n;\n        BitSet[] edges;\n        long start;\n        PrintWriter out;\n        int p = 0;\n        int pMax = 10;\n\n        boolean stateIsValid() {\n            BitSet COG = new BitSet(n);\n            COG.or(currentOtherGroup);\n            int card = COG.cardinality();\n            for (int i = 0; i < n; i++) {\n                if (COG.get(i)) {\n                    COG.and(edges[i]);\n                    if (COG.cardinality() != card) return false;\n                    COG.or(currentOtherGroup);\n                }\n            }\n            return true;\n        }\n\n        void findOne() {\n            if (stateIsValid()) {\n                int card = currentGroup.cardinality();\n                maxMinSize = Math.max(maxMinSize, Math.min(card, n - card));\n                p++;\n                if (pMax < p) return;\n            }\n            for (int i1 = 0; i1 < n && p < pMax && checkTime(); i1++) {\n                int i = options.get(i1);\n                if (currentOtherGroup.get(i)) {\n                    for (int j1 = i1 + 1; j1 < n && p < pMax; j1++) {\n                        int j = options.get(j1);\n                        if (currentOtherGroup.get(j)) {\n                            if (!edges[i].get(j)) {\n                                BitSet x = (BitSet) edges[i].clone();\n                                x.and(currentGroup);\n                                boolean r1 = tryToContinue(i, x);\n                                x = (BitSet) edges[j].clone();\n                                x.and(currentGroup);\n                                r1 |= tryToContinue(j, x);\n                                if(!r1) return;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        boolean tryToContinue(int j, BitSet x) {\n            if (x.cardinality() == currentGroup.cardinality()) {\n                currentOtherGroup.flip(j);\n                currentGroup.flip(j);\n                findOne();\n                currentOtherGroup.flip(j);\n                currentGroup.flip(j);\n                return true;\n            }\n            return false;\n        }\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            start = System.nanoTime();\n            n = in.NextInt();\n            int m = in.NextInt();\n            edges = new BitSet[n];\n            for (int i = 0; i < n; i++) {\n                edges[i] = new BitSet(n);\n                edges[i].set(i, true);\n            }\n            for (int i = 0; i < m; i++) {\n                int u = in.NextInt() - 1;\n                int v = in.NextInt() - 1;\n                edges[u].set(v, true);\n                edges[v].set(u, true);\n            }\n\n            currentGroup = new BitSet(n);\n            currentOtherGroup = new BitSet(n);\n            currentOtherGroup.set(0, n, true);\n            options = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                options.add(i);\n            }\n            this.out = out;\n            while (checkTime()) {\n                Collections.shuffle(options);\n                p = 0;\n                findOne();\n            }\n            if (maxMinSize == -1) {\n                out.println(-1);\n            } else {\n                out.println(maxMinSize * (maxMinSize - 1) / 2 + (n - maxMinSize) * (n - maxMinSize - 1) / 2);\n            }\n        }\n\n        boolean checkTime() {\n            return (System.nanoTime() - start < 1_800_000_000L);\n        }\n\n    }\n\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine(), \" \\t\\n\\r\\f,\");\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int NextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.InputStreamReader;\nimport java.util.Map;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyInput in = new MyInput(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        long X;\n        long invX0;\n\n        public void solve(int testNumber, MyInput in, PrintWriter out) {\n            int n = in.nextInt();\n            char[] cs = in.nextChars();\n\n            final int mod0 = (int) 1e9 + 7;\n            final int mod1 = (int) 1e9 + 9;\n            X = (int) 1e9 + 3;\n            invX0 = powmod(X, mod0 - 2, mod0);\n            long invX1 = powmod(X, mod1 - 2, mod1);\n            final long[] pow0 = new long[2 * n + 1];\n            final long[] pow1 = new long[2 * n + 1];\n            pow0[0] = powmod(X, (mod0 - 2L) * n % (mod0 - 1), mod0);\n            pow1[0] = powmod(X, (mod1 - 2L) * n % (mod1 - 1), mod1);\n            for (int i = 1; i < pow0.length; i++) pow0[i] = pow0[i - 1] * X % mod0;\n            for (int i = 1; i < pow1.length; i++) pow1[i] = pow1[i - 1] * X % mod1;\n\n            long[] h0 = new long[n + 1];\n            long[] h1 = new long[n + 1];\n            int[] xs = new int[n + 1];\n            xs[n] = n;\n            for (int i = n - 1; i >= 0; i--) {\n                xs[i] = xs[i + 1];\n                h0[i] = h0[i + 1];\n                h1[i] = h1[i + 1];\n                if (cs[i] == '>') {\n                    xs[i]++;\n                }\n                if (cs[i] == '<') {\n                    xs[i]--;\n                }\n                if (cs[i] == '+') {\n                    h0[i] = round(h0[i] + 1, mod0);\n                }\n                if (cs[i] == '-') {\n                    h0[i] = round(h0[i] + mod0 - 1, mod0);\n                }\n                if (cs[i] == '>') {\n                    h0[i] = round(h0[i] * X, mod0);\n                }\n                if (cs[i] == '<') {\n                    h0[i] = round(h0[i] * invX0, mod0);\n                }\n                if (cs[i] == '+') {\n                    h1[i] = round(h1[i] + 1, mod1);\n                }\n                if (cs[i] == '-') {\n                    h1[i] = round(h1[i] + mod1 - 1, mod1);\n                }\n                if (cs[i] == '>') {\n                    h1[i] = round(h1[i] * X, mod1);\n                }\n                if (cs[i] == '<') {\n                    h1[i] = round(h1[i] * invX1, mod1);\n                }\n            }\n\n            long ans = 0;\n            Map<Long, Integer> mp = new HashMap<>();\n            for (int i = n; i >= 0; i--) {\n                long key01 = round((h0[i] - h0[0]) * pow0[n - (xs[i] - xs[n])], mod0);\n                long key02 = round(h0[i] * pow0[xs[n] - xs[i] + n], mod0);\n                long key11 = round((h1[i] - h1[0]) * pow1[n - (xs[i] - xs[n])], mod1);\n                long key12 = round(h1[i] * pow1[xs[n] - xs[i] + n], mod1);\n                long key1 = key01 << 32 | key11;\n                long key2 = key02 << 32 | key12;\n                ans += mp.getOrDefault(key1, 0);\n                mp.put(key2, mp.getOrDefault(key2, 0) + 1);\n            }\n\n            out.println(ans);\n        }\n\n        long round(long x, int mod) {\n            return (x % mod + mod) % mod;\n        }\n\n        static long powmod(long n, long r, int m) {\n            long res = 1;\n            for (; r != 0; r >>>= 1, n = n * n % m) {\n                if ((r & 1) == 1) {\n                    res = res * n;\n                    if (res >= m) {\n                        res %= m;\n                    }\n                }\n            }\n            return res;\n        }\n\n    }\n\n    static class MyInput {\n        private final BufferedReader in;\n        private static int pos;\n        private static int readLen;\n        private static final char[] buffer = new char[1024 * 8];\n        private static char[] str = new char[500 * 8 * 2];\n        private static boolean[] isDigit = new boolean[256];\n        private static boolean[] isSpace = new boolean[256];\n        private static boolean[] isLineSep = new boolean[256];\n\n        static {\n            for (int i = 0; i < 10; i++) {\n                isDigit['0' + i] = true;\n            }\n            isDigit['-'] = true;\n            isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n            isLineSep['\\r'] = isLineSep['\\n'] = true;\n        }\n\n        public MyInput(InputStream is) {\n            in = new BufferedReader(new InputStreamReader(is));\n        }\n\n        public int read() {\n            if (pos >= readLen) {\n                pos = 0;\n                try {\n                    readLen = in.read(buffer);\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n                if (readLen <= 0) {\n                    throw new MyInput.EndOfFileRuntimeException();\n                }\n            }\n            return buffer[pos++];\n        }\n\n        public int nextInt() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            int ret = 0;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n\n        public char nextChar() {\n            while (true) {\n                final int c = read();\n                if (!isSpace[c]) {\n                    return (char) c;\n                }\n            }\n        }\n\n        int reads(int len, boolean[] accept) {\n            try {\n                while (true) {\n                    final int c = read();\n                    if (accept[c]) {\n                        break;\n                    }\n                    if (str.length == len) {\n                        char[] rep = new char[str.length * 3 / 2];\n                        System.arraycopy(str, 0, rep, 0, str.length);\n                        str = rep;\n                    }\n                    str[len++] = (char) c;\n                }\n            } catch (MyInput.EndOfFileRuntimeException e) {\n            }\n            return len;\n        }\n\n        public char[] nextChars() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            return Arrays.copyOf(str, len);\n        }\n\n        static class EndOfFileRuntimeException extends RuntimeException {\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.InputStreamReader;\nimport java.util.Map;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyInput in = new MyInput(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        long X;\n        long invX;\n\n        public void solve(int testNumber, MyInput in, PrintWriter out) {\n            int n = in.nextInt();\n            char[] cs = in.nextChars();\n\n            final int mod = (int) 1e9 + 7;\n            X = (int) 1e9 + 3;\n            invX = powmod(X, mod - 2, mod);\n            final long[] pow = new long[2 * n + 1];\n            pow[0] = powmod(X, (mod - 2L) * n % (mod - 1), mod);\n            for (int i = 1; i < pow.length; i++) pow[i] = pow[i - 1] * X % mod;\n\n            long[] h0 = new long[n + 1];\n            int[] xs = new int[n + 1];\n            xs[n] = n;\n            for (int i = n - 1; i >= 0; i--) {\n                xs[i] = xs[i + 1];\n                h0[i] = h0[i + 1];\n                if (cs[i] == '+') {\n                    h0[i] = round(h0[i] + 1, mod);\n                }\n                if (cs[i] == '-') {\n                    h0[i] = round(h0[i] + mod - 1, mod);\n                }\n                if (cs[i] == '>') {\n                    xs[i]++;\n                    h0[i] = round(h0[i] * X, mod);\n                }\n                if (cs[i] == '<') {\n                    xs[i]--;\n                    h0[i] = round(h0[i] * invX, mod);\n                }\n            }\n\n            long ans = 0;\n            Map<Long, Integer> mp = new HashMap<>();\n            for (int i = n; i >= 0; i--) {\n                long key1 = round((h0[i] - h0[0]) * pow[n - (xs[i] - xs[n])], mod);\n                long key2 = round(h0[i] * pow[xs[n] - xs[i] + n], mod);\n                ans += mp.getOrDefault(key1, 0);\n                mp.put(key2, mp.getOrDefault(key2, 0) + 1);\n            }\n\n            out.println(ans);\n        }\n\n        long round(long x, int mod) {\n            return (x % mod + mod) % mod;\n        }\n\n        static long powmod(long n, long r, int m) {\n            long res = 1;\n            for (; r != 0; r >>>= 1, n = n * n % m) {\n                if ((r & 1) == 1) {\n                    res = res * n;\n                    if (res >= m) {\n                        res %= m;\n                    }\n                }\n            }\n            return res;\n        }\n\n    }\n\n    static class MyInput {\n        private final BufferedReader in;\n        private static int pos;\n        private static int readLen;\n        private static final char[] buffer = new char[1024 * 8];\n        private static char[] str = new char[500 * 8 * 2];\n        private static boolean[] isDigit = new boolean[256];\n        private static boolean[] isSpace = new boolean[256];\n        private static boolean[] isLineSep = new boolean[256];\n\n        static {\n            for (int i = 0; i < 10; i++) {\n                isDigit['0' + i] = true;\n            }\n            isDigit['-'] = true;\n            isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n            isLineSep['\\r'] = isLineSep['\\n'] = true;\n        }\n\n        public MyInput(InputStream is) {\n            in = new BufferedReader(new InputStreamReader(is));\n        }\n\n        public int read() {\n            if (pos >= readLen) {\n                pos = 0;\n                try {\n                    readLen = in.read(buffer);\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n                if (readLen <= 0) {\n                    throw new MyInput.EndOfFileRuntimeException();\n                }\n            }\n            return buffer[pos++];\n        }\n\n        public int nextInt() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            int ret = 0;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n\n        public char nextChar() {\n            while (true) {\n                final int c = read();\n                if (!isSpace[c]) {\n                    return (char) c;\n                }\n            }\n        }\n\n        int reads(int len, boolean[] accept) {\n            try {\n                while (true) {\n                    final int c = read();\n                    if (accept[c]) {\n                        break;\n                    }\n                    if (str.length == len) {\n                        char[] rep = new char[str.length * 3 / 2];\n                        System.arraycopy(str, 0, rep, 0, str.length);\n                        str = rep;\n                    }\n                    str[len++] = (char) c;\n                }\n            } catch (MyInput.EndOfFileRuntimeException e) {\n            }\n            return len;\n        }\n\n        public char[] nextChars() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            return Arrays.copyOf(str, len);\n        }\n\n        static class EndOfFileRuntimeException extends RuntimeException {\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\nimport java.util.BitSet;\nimport java.io.BufferedReader;\nimport java.util.Collections;\nimport java.io.InputStream;\n\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author kessido\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskE solver = new TaskE();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskE {\n        BitSet currentGroup;\n        BitSet currentOtherGroup;\n        int maxMinSize = -1;\n        ArrayList<Integer> options;\n        int n;\n        BitSet[] edges;\n        long start;\n        PrintWriter out;\n        int p = 0;\n        int pMax = 10;\n\n        boolean stateIsValid() {\n            BitSet COG = new BitSet(n);\n            COG.or(currentOtherGroup);\n            int card = COG.cardinality();\n            for (int i = 0; i < n; i++) {\n                if (COG.get(i)) {\n                    COG.and(edges[i]);\n                    if (COG.cardinality() != card) return false;\n                    COG.or(currentOtherGroup);\n                }\n            }\n            return true;\n        }\n\n        void findOne() {\n            if (stateIsValid()) {\n                int card = currentGroup.cardinality();\n                maxMinSize = Math.max(maxMinSize, Math.min(card, n - card));\n                p++;\n                if (pMax < p) return;\n            }\n            for (int i1 = 0; i1 < n && p < pMax && checkTime(); i1++) {\n                int i = options.get(i1);\n                if (currentOtherGroup.get(i)) {\n                    for (int j1 = i1 + 1; j1 < n && p < pMax; j1++) {\n                        int j = options.get(j1);\n                        if (currentOtherGroup.get(j)) {\n                            if (!edges[i].get(j)) {\n                                BitSet x = (BitSet) edges[i].clone();\n                                x.and(currentGroup);\n                                boolean r1 = tryToContinue(i, x);\n                                x = (BitSet) edges[j].clone();\n                                x.and(currentGroup);\n                                r1 |= tryToContinue(j, x);\n                                if(!r1) return;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        boolean tryToContinue(int j, BitSet x) {\n            if (x.cardinality() == currentGroup.cardinality()) {\n                currentOtherGroup.flip(j);\n                currentGroup.flip(j);\n                findOne();\n                currentOtherGroup.flip(j);\n                currentGroup.flip(j);\n                return true;\n            }\n            return false;\n        }\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            start = System.nanoTime();\n            n = in.NextInt();\n            int m = in.NextInt();\n            edges = new BitSet[n];\n            for (int i = 0; i < n; i++) {\n                edges[i] = new BitSet(n);\n                edges[i].set(i, true);\n            }\n            for (int i = 0; i < m; i++) {\n                int u = in.NextInt() - 1;\n                int v = in.NextInt() - 1;\n                edges[u].set(v, true);\n                edges[v].set(u, true);\n            }\n\n            currentGroup = new BitSet(n);\n            currentOtherGroup = new BitSet(n);\n            currentOtherGroup.set(0, n, true);\n            options = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                options.add(i);\n            }\n            this.out = out;\n            while (checkTime()) {\n                Collections.shuffle(options);\n                p = 0;\n                findOne();\n            }\n            if (maxMinSize == -1) {\n                out.println(-1);\n            } else {\n                out.println(maxMinSize * (maxMinSize - 1) / 2 + (n - maxMinSize) * (n - maxMinSize - 1) / 2);\n            }\n        }\n\n        boolean checkTime() {\n            return (System.nanoTime() - start < 1_800_000_000L);\n        }\n\n    }\n\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine(), \" \\t\\n\\r\\f,\");\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int NextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class Main {\n    FastScanner in;\n    PrintWriter out;\n\n    void solve() {\n        Random rnd = new Random(123);\n        final long p = (long) 1e9 + 7;\n        BigInteger MODULO = BigInteger.valueOf(2).pow(64);\n        final long pInv = BigInteger.valueOf(p).modInverse(MODULO).longValue();\n        final int MAX = 500010;\n        long[] vals = new long[MAX];\n        vals[MAX / 2] = 1;\n        for (int i = MAX / 2 + 1; i < MAX; i++) {\n            vals[i]= vals[i - 1] * p;\n        }\n        for (int i = MAX / 2 - 1; i >= 0; i--) {\n            vals[i] = vals[i + 1] * pInv;\n        }\n        in.nextInt();\n        String s = in.next();\n        long[] hashes = new long[s.length() + 1];\n        int curPos = MAX / 2;\n        int[] myPos = new int[s.length()];\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            myPos[i] = curPos - MAX / 2;\n            hashes[i + 1] = hashes[i];\n            if (c == '<') {\n                curPos--;\n            } else if (c == '>') {\n                curPos++;\n            } else if (c == '-') {\n                hashes[i + 1] -= vals[curPos];\n            } else {\n                hashes[i + 1] += vals[curPos];\n            }\n        }\n//        System.err.println(Arrays.toString(hashes));\n        long expectedHash = hashes[hashes.length - 1];\n        long mul = 1, add = 0;\n        int realPower = 0;\n        HashMap<Long, Integer> count = new HashMap<>();\n        long result = 0;\n        for (int i = s.length() - 1; i >= 0; i--) {\n            long nothingHash = -add * vals[MAX / 2 - realPower];\n            long check = nothingHash * mul + add;\n            if (check != 0) {\n                throw new AssertionError();\n            }\n            Integer now = count.get(nothingHash);\n            count.put(nothingHash, now == null ? 1 : (now + 1));\n            char c = s.charAt(i);\n            if (c == '<') {\n                mul *= pInv;\n                realPower--;\n                add *= pInv;\n            } else if (c == '>') {\n                mul *= p;\n                realPower++;\n                add *= p;\n            } else if (c == '-') {\n                add--;\n            } else {\n                add++;\n            }\n            long need = expectedHash;\n//            need *= vals[MAX / 2 - myPos[i]];\n            long inMap = (need - add) * vals[MAX / 2 - realPower];\n            Integer cou = count.get(inMap);\n            if (cou != null) {\n                result += cou;\n//                System.err.println(i + \"-> \" + cou);\n            }\n        }\n        out.println(result);\n    }\n\n    void run() {\n        try {\n            in = new FastScanner(new File(\"Main.in\"));\n            out = new PrintWriter(new File(\"Main.out\"));\n\n            solve();\n\n            out.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n\n    void runIO() {\n\n        in = new FastScanner(System.in);\n        out = new PrintWriter(System.out);\n\n        solve();\n\n        out.close();\n    }\n\n    class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(File f) {\n            try {\n                br = new BufferedReader(new FileReader(f));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        public FastScanner(InputStream f) {\n            br = new BufferedReader(new InputStreamReader(f));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                String s = null;\n                try {\n                    s = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                    return null;\n                st = new StringTokenizer(s);\n            }\n            return st.nextToken();\n        }\n\n        boolean hasMoreTokens() {\n            while (st == null || !st.hasMoreTokens()) {\n                String s = null;\n                try {\n                    s = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                    return false;\n                st = new StringTokenizer(s);\n            }\n            return true;\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n\n    public static void main(String[] args) {\n        new Main().runIO();\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Linq;\nclass Solve{\n    public Solve(){}\n    StringBuilder sb;\n    ReadData re;\n    public static int Main(){\n        new Solve().Run();\n        return 0;\n    }\n    void Run(){\n        sb = new StringBuilder();\n        re = new ReadData();\n        Calc();\n        Console.Write(sb.ToString());\n    }\n    void Calc(){\n        long[] X = new long[4];\n        long[] reX = new long[4];\n        X[0] = 118306800;\n        X[1] = 686550364;\n        X[2] = 218792700;\n        X[3] = 202607072;\n        for(int i=0;i<4;i++){\n            reX[i] = Pow(X[i],Define.mod-2);\n        }\n        int N = re.i();\n        string S = re.s();\n        //Si H(0) = Sj(0)\n        long[] Place = new long[4];\n        long[,] SJ = new long[N+1,4];\n        for(int i=0;i<4;i++){\n            Place[i] = 1;\n        }\n        for(int i=0;i<N;i++){\n            for(int j=0;j<4;j++){\n                if(S[i] == '+'){\n                    SJ[i+1,j] = (SJ[i,j] + Place[j]) % Define.mod; \n                }\n                if(S[i] == '-'){\n                    SJ[i+1,j] = (SJ[i,j] - Place[j] + Define.mod) % Define.mod;\n                }\n                if(S[i] == '<'){\n                    SJ[i+1,j] = SJ[i,j];\n                    Place[j] = Place[j] * reX[j] % Define.mod;\n                }\n                if(S[i] == '>'){\n                    SJ[i+1,j] = SJ[i,j];\n                    Place[j] = Place[j] * X[j] % Define.mod;\n                }\n            }\n        }\n        long[,] SiH = new long[N+1,4];\n        for(int i=0;i<4;i++){\n            Place[i] = 1;\n        }\n        for(int i=0;i<=N;i++){\n            for(int j=0;j<4;j++){\n                if(i != 0){\n                    if(S[i-1] == '<'){\n                        Place[j] = Place[j] * reX[j] % Define.mod;\n                    }\n                    if(S[i-1] == '>'){\n                        Place[j] = Place[j] * X[j] % Define.mod;\n                    }\n                }\n                SiH[i,j] = (SJ[i,j] + Place[j] * SJ[N,j]) % Define.mod;\n            }\n        }\n        int[] C = new int[N+1];\n        for(int i=0;i<=N;i++){\n            C[i] = i;\n        }\n        Array.Sort(C,(x,y)=>Compare(x,y,SJ));\n        long count = 0;\n        for(int i=0;i<N;i++){\n            int bf = 0;\n            int bl = N+1;\n            while(bf != bl){\n                int bc = (bf+bl)/2;\n                if(bc == N+1 || OK1(i,C[bc],SiH,SJ)){\n                    bl = bc;\n                }\n                else{\n                    bf = bc+1;\n                }\n            }\n            int min = bf;\n            bf = -1;\n            bl = N;\n            while(bf != bl){\n                int bc = (bf+bl+1)/2;\n                if(bc == -1 || OK2(i,C[bc],SiH,SJ)){\n                    bf = bc;\n                }\n                else{\n                    bl = bc-1;\n                }\n            }\n            int max = bf;\n            count += max - min + 1;\n        }\n        sb.Append(count+\"\\n\");\n    }\n    bool OK1(int i,int v,long[,] SiH,long[,] SJ){\n        for(int j=0;j<4;j++){\n            if(SiH[i,j] > SJ[v,j]){\n                return false;\n            }\n            if(SiH[i,j] < SJ[v,j]){\n                return true;\n            }\n        }\n        return i < v;\n    }\n    bool OK2(int i,int v,long[,] SiH,long[,] SJ){\n        for(int j=0;j<4;j++){\n            if(SiH[i,j] > SJ[v,j]){\n                return true;\n            }\n            if(SiH[i,j] < SJ[v,j]){\n                return false;\n            }\n        }\n        return true;\n    }\n    int Compare(int x,int y,long[,] S){\n        for(int i=0;i<4;i++){\n            if(S[x,i] > S[y,i]){\n                return 1;\n            }\n            if(S[x,i] < S[y,i]){\n                return -1;\n            }\n        }\n        return x - y;\n    }\n    long Pow(long x,long r){\n        if(r == 0){\n            return 1;\n        }\n        if(r % 2 == 0){\n            long t = Pow(x,r/2);\n            return t*t%Define.mod;\n        }\n        return Pow(x,r-1)*x%Define.mod;\n    }\n}\nclass ReadData{\n    string[] str;\n    int counter;\n    public ReadData(){\n        counter = 0;\n    }\n    public string s(){\n        if(counter == 0){\n            str = Console.ReadLine().Split(' ');\n            counter = str.Length;\n        }\n        counter--;\n        return str[str.Length-counter-1];\n    }\n    public int i(){\n        return int.Parse(s());\n    }\n    public long l(){\n        return long.Parse(s());\n    }\n    public double d(){\n        return double.Parse(s());\n    }\n    public int[] ia(int N){\n        int[] ans = new int[N];\n        for(int j=0;j<N;j++){\n            ans[j] = i();\n        }\n        return ans;\n    }\n    public int[] ia(){\n        str = Console.ReadLine().Split(' ');\n        counter = 0;\n        int[] ans = new int[str.Length];\n        for(int j=0;j<str.Length;j++){\n            ans[j] = int.Parse(str[j]);\n        }\n        return ans;\n    }\n    public long[] la(int N){\n        long[] ans = new long[N];\n        for(int j=0;j<N;j++){\n            ans[j] = l();\n        }\n        return ans;\n    }\n    public long[] la(){\n        str = Console.ReadLine().Split(' ');\n        counter = 0;\n        long[] ans = new long[str.Length];\n        for(int j=0;j<str.Length;j++){\n            ans[j] = long.Parse(str[j]);\n        }\n        return ans;\n    }\n    public double[] da(int N){\n        double[] ans = new double[N];\n        for(int j=0;j<N;j++){\n            ans[j] = d();\n        }\n        return ans;\n    }\n    public double[] da(){\n        str = Console.ReadLine().Split(' ');\n        counter = 0;\n        double[] ans = new double[str.Length];\n        for(int j=0;j<str.Length;j++){\n            ans[j] = double.Parse(str[j]);\n        }\n        return ans;\n    }\n    public List<int>[] g(int N,int[] f,int[] t){\n        List<int>[] ans = new List<int>[N];\n        for(int j=0;j<N;j++){\n            ans[j] = new List<int>();\n        }\n        for(int j=0;j<f.Length;j++){\n            ans[f[j]].Add(t[j]);\n            ans[t[j]].Add(f[j]);\n        }\n        return ans;\n    }\n    public List<int>[] g(int N,int M){\n        List<int>[] ans = new List<int>[N];\n        for(int j=0;j<N;j++){\n            ans[j] = new List<int>();\n        }\n        for(int j=0;j<M;j++){\n            int f = i()-1;\n            int t = i()-1;\n            ans[f].Add(t);\n            ans[t].Add(f);\n        }\n        return ans;\n    }\n    public List<int>[] g(){\n        int N = i();\n        int M = i();\n        List<int>[] ans = new List<int>[N];\n        for(int j=0;j<N;j++){\n            ans[j] = new List<int>();\n        }\n        for(int j=0;j<M;j++){\n            int f = i()-1;\n            int t = i()-1;\n            ans[f].Add(t);\n            ans[t].Add(f);\n        }\n        return ans;\n    }\n}\npublic static class Define{\n    public const long mod = 1000000007;\n}\npublic static class Debug{\n    public static void Print(double[,,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                for(int l=0;l<k.GetLength(2);l++){\n                    Console.Write(k[i,j,l]+\" \");\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(double[,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                Console.Write(k[i,j]+\" \");\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(double[] k){\n        for(int i=0;i<k.Length;i++){\n            Console.WriteLine(k[i]);\n        }\n    }\n    public static void Print(long[,,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                for(int l=0;l<k.GetLength(2);l++){\n                    Console.Write(k[i,j,l]+\" \");\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(long[,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                Console.Write(k[i,j]+\" \");\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(long[] k){\n        for(int i=0;i<k.Length;i++){\n            Console.WriteLine(k[i]);\n        }\n    }\n    public static void Print(int[,,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                for(int l=0;l<k.GetLength(2);l++){\n                    Console.Write(k[i,j,l]+\" \");\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(int[,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                Console.Write(k[i,j]+\" \");\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(int[] k){\n        for(int i=0;i<k.Length;i++){\n            Console.WriteLine(k[i]);\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\nusing System.Numerics;\nusing static System.Math;\nnamespace Program {\n    public class Solver {\n        Random rnd = new Random();\n        public void Solve() {\n            var n = ri;\n            var s = rs;\n            BigInteger MOD = (BigInteger)1e18 + 3;\n            BigInteger B = 99431;\n            BigInteger invB = BigInteger.ModPow(B, MOD - 2, MOD);\n            BigInteger h = 0;\n            BigInteger x = 1;\n            var hash = new List<BigInteger>() { 0 };\n            var vec = new List<BigInteger>() { 1 };\n            foreach (var c in s)\n            {\n                if (c == '+') h = (h + x) % MOD;\n                else if (c == '-') h = (h + MOD - x) % MOD;\n                else if (c == '>') x = x * B % MOD;\n                else x = x * invB % MOD;\n                hash.Add((long)h);\n                vec.Add((long)x);\n            }\n            var ans = 0L;\n            var map = new HashMap<long, int>();\n            map[(long)hash.Last()]++;\n            for (int i = n - 1; i >= 0; i--)\n            {\n                ans += map[(long)((hash.Last() * vec[i] + hash[i]) % MOD)];\n                map[(long)hash[i]]++;\n            }\n            Console.WriteLine(ans);\n\n        }\n\n        const long INF = 5L << 60;\n        static int[] dx = { -1, 0, 1, 0 };\n        static int[] dy = { 0, 1, 0, -1 };\n        int ri { get { return sc.Integer(); } }\n        long rl { get { return sc.Long(); } }\n        double rd { get { return sc.Double(); } }\n        string rs { get { return sc.Scan(); } }\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex {\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie);\n    }\n    static public void Main() {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        solver.Solve();\n        Console.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer: StreamWriter {\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len)\n            {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0)\n                {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n#region HashMap<K,V>\npublic class HashMap<K, V>: Dictionary<K, V>\n//where V : new()\n{\n    public HashMap() : base() { }\n    public HashMap(int cap) : base(cap) { }\n    new public V this[K i] {\n        get {\n            V v;\n            return TryGetValue(i, out v) ? v :\n                base[i] = default(V);\n            //base[i] = new V();\n        }\n        set { base[i] = value; }\n    }\n}\n#endregion"
  },
  {
    "language": "Ruby",
    "code": "n = gets.to_i\ns = gets.chomp.split('')\n\npoint = n/2+1\na = Array.new(n, 0)\n\ns.each do |i|\n  if i == '+'\n    a[point] += 1\n  elsif i == '-'\n    a[point] -= 1\n  elsif i == '>'\n    point += 1\n  else\n    point -= 1\n  end\nend\n\ncount = 0\nb = nil\n(0...n).each do |i|\n  point = 250000\n  b = Array.new(500000, 0)\n  s[i..-1].each do |j|\n    if j == '+'\n      b[point] += 1\n    elsif j == '-'\n      b[point] -= 1\n    elsif j == '>'\n      point += 1\n    else\n      point -= 1\n    end\n    count += 1 if a == b\n  end\nend\nputs count"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"F\"\n    dependency \"dunkelheit\" version=\">=0.9.0\"\n+/\n\nimport std.stdio, std.algorithm, std.range, std.conv;\n// import dkh.foundation, dkh.scanner;\nimmutable long Mod = 10L^^18 + 3;\nimmutable long B = 1145141919810L;\nimmutable long iB;\nimmutable int MN = 600_000;\n\nlong mul(long a, long b) {\n    if (b == 0) return 0;\n    if (b % 2 == 1) return (a + mul(a, b-1)) % Mod;\n    else return (2*mul(a, b/2)) % Mod;\n}\n/*long mul(long a, long b) {\n    assert(a < Mod && b < Mod);\n    return (a * b) % Mod;\n}*/\n\nlong pw(long a, long n) {\n    long b = 1;\n    while (n) {\n        if (n & 1) b = mul(b, a);\n        a = mul(a, a);\n        n >>= 1;\n    }\n    return b;\n}\n\nlong[] powB = new long[MN + 1];\nlong[] powiB = new long[MN + 1];\nstatic this() {\n    iB = pw(B, Mod-2);\n    assert(mul(iB, B) == 1);\n    powB[0] = 1;\n    foreach (i; 0..MN) {\n        powB[i+1] = mul(powB[i], B);\n    }\n    powiB[0] = 1;\n    foreach (i; 0..MN) {\n        powiB[i+1] = mul(powiB[i], iB);\n    }\n}\n\nlong getPB(long i) {\n    if (i < 0) return powiB[-i];\n    else return powB[i];\n}\n\nint main() {\n    Scanner sc = new Scanner(stdin);\n    int n;\n    string s;\n    sc.read(n, s);\n\n    long[] x = new long[n+1];\n    int p = 0;\n    x[0] = 0;\n    foreach (i, c; s) {\n        x[i+1] = x[i];\n        if (c == '+') {\n            x[i+1] += getPB(p);\n            x[i+1] %= Mod;\n        } else if (c == '-') {\n            x[i+1] += Mod - getPB(p);\n            x[i+1] %= Mod;\n        } else if (c == '>') {\n            p++;\n        } else {\n            p--;\n        }\n    }\n\n    debug writeln(x);\n    long ans = 0;\n    int[long] cnt;\n    cnt[x[n]] = 1;\n    long z = x[n];\n    foreach_reverse (i, c; s) {\n        if (c == '>') p--;\n        else if (c == '<') p++;\n        long w = (mul(z, getPB(p)) + x[i]) % Mod;\n        if (w in cnt) ans += cnt[w];\n        cnt[x[i]]++;\n    }\n    writeln(ans);\n    return 0;\n}\n/* IMPORT /Users/kohei/Programs/dunkelheit/source/dkh/scanner.d */\n// module dkh.scanner;\n\n// import dkh.container.stackpayload;\n\n \nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    char[512] lineBuf;\n    char[] line;\n    private bool succW() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (!line.empty && line.front.isWhite) {\n            line.popFront;\n        }\n        return !line.empty;\n    }\n    private bool succ() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (true) {\n            while (!line.empty && line.front.isWhite) {\n                line.popFront;\n            }\n            if (!line.empty) break;\n            line = lineBuf[];\n            f.readln(line);\n            if (!line.length) return false;\n        }\n        return true;\n    }\n\n    private bool readSingle(T)(ref T x) {\n        import std.algorithm : findSplitBefore;\n        import std.string : strip;\n        import std.conv : parse;\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                 \n                 \n                auto r = line.findSplitBefore(\" \");\n                x = r[0].strip.dup;\n                line = r[1];\n            } else static if (isStaticArray!T) {\n                foreach (i; 0..T.length) {\n                    bool f = succW();\n                    assert(f);\n                    x[i] = line.parse!E;\n                }\n            } else {\n                StackPayload!E buf;\n                while (succW()) {\n                    buf ~= line.parse!E;\n                }\n                x = buf.data;\n            }\n        } else {\n            x = line.parse!T;\n        }\n        return true;\n    }\n\n    int unsafeRead(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n    void read(bool enforceEOF = false, T, Args...)(ref T x, auto ref Args args) {\n        import std.exception;\n        enforce(readSingle(x));\n        static if (args.length == 0) {\n            enforce(enforceEOF == false || !succ());\n        } else {\n            read!enforceEOF(args);\n        }\n    }\n    void read(bool enforceEOF = false, Args...)(auto ref Args args) {\n        import std.exception;\n        static if (args.length == 0) {\n            enforce(enforceEOF == false || !succ());\n        } else {\n            enforce(readSingle(args[0]));\n            read!enforceEOF(args);\n        }\n    }\n}\n\n\n \n \n\n \n/* IMPORT /Users/kohei/Programs/dunkelheit/source/dkh/foundation.d */\n \n// module dkh.foundation;\n\n \nstatic if (__VERSION__ <= 2070) {\n    /*\n    Copied by https://github.com/dlang/phobos/blob/master/std/algorithm/iteration.d\n    Copyright: Andrei Alexandrescu 2008-.\n    License: $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).\n    */\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n     \n}\n/* IMPORT /Users/kohei/Programs/dunkelheit/source/dkh/container/stackpayload.d */\n// module dkh.container.stackpayload;\n\n \nstruct StackPayload(T, size_t MINCAP = 4) if (MINCAP >= 1) {\n    import core.exception : RangeError;\n\n    private T* _data;\n    private uint len, cap;\n\n    @property bool empty() const { return len == 0; }\n    @property size_t length() const { return len; }\n    alias opDollar = length;\n\n     \n    inout(T)[] data() inout { return (_data) ? _data[0..len] : null; }\n    \n    ref inout(T) opIndex(size_t i) inout {\n        version(assert) if (len <= i) throw new RangeError();\n        return _data[i];\n    }  \n    ref inout(T) front() inout { return this[0]; }  \n    ref inout(T) back() inout { return this[$-1]; }  \n\n    void reserve(size_t newCap) {\n        import core.memory : GC;\n        import core.stdc.string : memcpy;\n        import std.conv : to;\n        if (newCap <= cap) return;\n        void* newData = GC.malloc(newCap * T.sizeof);\n        cap = newCap.to!uint;\n        if (len) memcpy(newData, _data, len * T.sizeof);\n        _data = cast(T*)(newData);\n    }  \n    void free() {\n        import core.memory : GC;\n        GC.free(_data);\n    }  \n     \n    void clear() {\n        len = 0;\n    }\n\n    void insertBack(T item) {\n        import std.algorithm : max;\n        if (len == cap) reserve(max(cap * 2, MINCAP));\n        _data[len++] = item;\n    }  \n    alias opOpAssign(string op : \"~\") = insertBack;  \n    void removeBack() {\n        assert(!empty, \"StackPayload.removeBack: Stack is empty\");\n        len--;\n    }  \n}\n\n \n\n/*\nThis source code generated by dunkelheit and include dunkelheit's source code.\ndunkelheit's Copyright: Copyright (c) 2016- Kohei Morita. (https://github.com/yosupo06/dunkelheit)\ndunkelheit's License: MIT License(https://github.com/yosupo06/dunkelheit/blob/master/LICENSE.txt)\n*/\n"
  },
  {
    "language": "Nim",
    "code": "# {{{ header\n{.hints:off checks:off warnings:off assertions:on optimization:speed.}\nimport algorithm, sequtils, tables, macros, math, sets, strutils, strformat, sugar\nwhen defined(MYDEBUG):\n  import header\n\nimport streams\nproc scanf(formatstr: cstring){.header: \"<stdio.h>\", varargs.}\n#proc getchar(): char {.header: \"<stdio.h>\", varargs.}\nproc nextInt(): int = scanf(\"%lld\",addr result)\nproc nextFloat(): float = scanf(\"%lf\",addr result)\nproc nextString[F](f:F): string =\n  var get = false\n  result = \"\"\n  while true:\n#    let c = getchar()\n    let c = f.readChar\n    if c.int > ' '.int:\n      get = true\n      result.add(c)\n    elif get: return\nproc nextInt[F](f:F): int = parseInt(f.nextString)\nproc nextFloat[F](f:F): float = parseFloat(f.nextString)\nproc nextString():string = stdin.nextString()\n\ntemplate `max=`*(x,y:typed):void = x = max(x,y)\ntemplate `min=`*(x,y:typed):void = x = min(x,y)\ntemplate inf(T): untyped = \n  when T is SomeFloat: T(Inf)\n  elif T is SomeInteger: ((T(1) shl T(sizeof(T)*8-2)) - (T(1) shl T(sizeof(T)*4-1)))\n  else: assert(false)\n\nproc discardableId[T](x: T): T {.discardable.} =\n  return x\n\nmacro `:=`(x, y: untyped): untyped =\n  var strBody = \"\"\n  if x.kind == nnkPar:\n    for i,xi in x:\n      strBody &= fmt\"\"\"\n{xi.repr} := {y[i].repr}\n\"\"\"\n  else:\n    strBody &= fmt\"\"\"\nwhen declaredInScope({x.repr}):\n  {x.repr} = {y.repr}\nelse:\n  var {x.repr} = {y.repr}\n\"\"\"\n  strBody &= fmt\"discardableId({x.repr})\"\n  parseStmt(strBody)\n\n\nproc toStr[T](v:T):string =\n  proc `$`[T](v:seq[T]):string =\n    v.mapIt($it).join(\" \")\n  return $v\n\nproc print0(x: varargs[string, toStr]; sep:string):string{.discardable.} =\n  result = \"\"\n  for i,v in x:\n    if i != 0: addSep(result, sep = sep)\n    add(result, v)\n  result.add(\"\\n\")\n  stdout.write result\n\nvar print:proc(x: varargs[string, toStr])\nprint = proc(x: varargs[string, toStr]) =\n  discard print0(@x, sep = \" \")\n\ntemplate makeSeq(x:int; init):auto =\n  when init is typedesc: newSeq[init](x)\n  else: newSeqWith(x, init)\n\nmacro Seq(lens: varargs[int]; init):untyped =\n  var a = fmt\"{init.repr}\"\n  for i in countdown(lens.len - 1, 0): a = fmt\"makeSeq({lens[i].repr}, {a})\"\n  parseStmt(fmt\"\"\"\nblock:\n  {a}\"\"\")\n\ntemplate makeArray(x:int; init):auto =\n  var v:array[x, init.type]\n  when init isnot typedesc:\n    for a in v.mitems: a = init\n  v\n\nmacro Array(lens: varargs[typed], init):untyped =\n  var a = fmt\"{init.repr}\"\n  for i in countdown(lens.len - 1, 0):\n    a = fmt\"makeArray({lens[i].repr}, {a})\"\n  parseStmt(fmt\"\"\"\nblock:\n  {a}\"\"\")\n# }}}\n\n# {{{ Rolling Hash\nimport sequtils\n\n# {{{ RH\ntemplate MASK(n:static[int]):auto = (1'u shl n.uint) - 1\n\nconst base = 1000000007'u\n\ntype RH_Base[Mod:static[uint], base:static[uint]] = object\n  h:uint\n\ntype RH = RH_Base[(1'u shl 61) - 1, base]\n\nconverter toRH(t:SomeInteger or char):RH = RH(h:t.uint)\n\nproc multRaw(a, b:RH):RH =\n  let\n    au = a.h shr 31\n    ad = a.h and MASK(31)\n    bu = b.h shr 31\n    bd = b.h and MASK(31)\n    mid = ad * bu + au * bd\n    midu = mid shr 30\n    midd = mid and MASK(30)\n  RH(h:au * bu * 2 + midu + (midd shl 31) + ad * bd)\n\nproc calcMod[T:RH](x:T):T =\n  let\n    xu = x.h shr 61\n    xd = x.h and MASK(61)\n  result = RH(xu + xd)\n  if result.h >= T.Mod: result.h -= T.Mod\n\nproc `*=`(a: var RH, b:RH) =  a = calcMod(multRaw(a, b))\nproc `*`(a, b:RH):RH = result = a;result *= b\nproc `==`(a, b:RH):bool = a.h == b.h\nproc `+=`(a:var RH, b:RH) =\n  a.h += b.h\n  if a.h >= RH.Mod: a.h -= RH.Mod\nproc `+`(a, b:RH):RH = result = a;result += b\nproc `-=`(a:var RH, b:RH) =\n  a.h += RH.Mod - b.h\n  if a.h >= RH.Mod: a.h -= RH.Mod\nproc `-`(a, b:RH):RH = result = a;result -= b\nproc `&=`(a:var RH, c:SomeInteger or char) =\n  a = multRaw(a, RH(base))\n  a += RH(c)\n  a = a.calcMod()\nproc `&`(a:RH, c:SomeInteger or char):RH = result = a;result &= c\nproc `^=`(x:var RH, k:int) =\n  var\n    k = k\n    a = RH(1)\n  while k > 0:\n    if k mod 2 == 1: a *= x\n    x *= x\n    k = k shr 1\n  swap(a, x)\nproc `^`(x:RH, k:int):RH = result = x;result ^= k\n\nimport hashes\nproc hash(a:RH):Hash = a.h.hash\n# }}}\n\ntype RollingHash[RH] = object\n  hashed, power: seq[RH]\n\nproc initRollingHash(s:string):auto =\n  var\n    sz = s.len\n    hashed = newSeqWith(sz + 1, RH(0))\n    power = newSeqWith(sz + 1, RH(0))\n  power[0] = 1'u\n  for i in 0..<sz:\n    power[i + 1] = RH(power[i]) * RH(base)\n    hashed[i + 1] = calcMod(multRaw(hashed[i], RH(base)) + RH(s[i]))\n#    if hashed[i + 1] >= MOD: hashed[i + 1] -= MOD\n  return RollingHash[RH](hashed: hashed, power: power)\n\nproc `[]`(self: RollingHash; s:Slice[int]):RH =\n  result = RH(self.hashed[s.b+1].h + (RH.MOD shl 2) - multRaw(self.hashed[s.a], self.power[s.len]).h)\n  result = result.calcMod()\n\nproc connect(self: RollingHash; h1, h2:uint, h2len:int):RH =\n  result = multRaw(RH(h1), self.power[h2len]) + RH(h2)\n  result = result.calcMod\n\nproc LCP(self, b:RollingHash; p1, p2:Slice[int]):int =\n  var\n    len = min(p1.len, p2.len)\n    low = -1\n    high = len + 1\n  while high - low > 1:\n    let mid = (low + high) div 2\n    if self.get(p1.a..<p1.a + mid) == b.get(p2.a..<p2.a + mid): low = mid\n    else: high = mid\n  return low\n# }}}\n\nproc solve(N:int, S:string) =\n  const B = 260000\n  var p:array[-B..B, RH]\n  p[0] = 1\n  for i in 1..B:\n    p[i] = p[i - 1] * RH(base)\n  let invBase = RH(base)^(RH.Mod - 2)\n  for i in 1..B:\n    p[-i] = p[-i+1] * invBase\n  var\n    a = initTable[RH, int]()\n    h = RH(0)\n    ans = 0\n  block:\n    var\n      i = 0\n    a[h] = 0\n    a[h].inc\n    for s in S:\n      if s == '+':\n        h += p[i]\n      elif s == '-':\n        h -= p[i]\n      elif s == '>':i.inc\n      elif s == '<':i.dec\n      if h notin a: a[h] = 0\n      a[h].inc\n  let t = h\n  block:\n    var\n      h = RH(0)\n      i = 0\n    a[h].dec\n    ans += a[t]\n    for j,s in S:\n      if s == '+':\n        h += p[i]\n      elif s == '-':\n        h -= p[i]\n      elif s == '>':i.inc\n      elif s == '<':i.dec\n      let u = t * p[i] + h\n      a[h].dec\n      if u notin a:\n        a[u] = 0\n      ans += a[u]\n  echo ans\n  return\n\n#{{{ main function\nproc main() =\n  var N = 0\n  N = nextInt()\n  var S = \"\"\n  S = nextString()\n  solve(N, S);\n  return\n\nmain()\n#}}}\n"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nimport numpy as np\nfrom collections import defaultdict\n\nN = int(readline())\nS = np.frombuffer(read().rstrip(),'S1')\n\nMOD = 10**9 + 7\n\nSright = (S==b'>')\nSleft = (S==b'<')\nSadd = (S==b'+')\nSsub = (S==b'-')\n\ndef cumprod(arr,MOD):\n    L = len(arr); Lsq = int(L**.5+1)\n    arr = np.resize(arr,Lsq**2).reshape(Lsq,Lsq)\n    for n in range(1,Lsq):\n        arr[:,n] *= arr[:,n-1]; arr[:,n] %= MOD\n    for n in range(1,Lsq):\n        arr[n] *= arr[n-1,-1]; arr[n] %= MOD\n    return arr.ravel()[:L]\n\ndef calc_hash_data(MOD,base):\n    inv = pow(base,MOD-2,MOD)\n    x = np.ones(N+1,dtype=np.int64)\n    x[1:][Sright] = base\n    x[1:][Sleft] = inv\n    power = cumprod(x,MOD)\n    x = np.pad(power[1:] * Sadd - power[1:] * Ssub,(1,0),mode='constant')\n    np.cumsum(x,out=x); x %= MOD\n    return power,x\n\nb1 = 123450\nb2 = 314159\npow1,H1 = calc_hash_data(MOD,b1)\npow2,H2 = calc_hash_data(MOD,b2)\n\nX1 = (H1+H1[-1]*pow1)%MOD\nX2 = (H2+H2[-1]*pow2)%MOD\nX = (X1<<32)^X2\n\nH = (H1<<32)^H2\n\n# x[i] == H[j] となる i<j の個数を答える\n\nX = X.tolist(); H = H.tolist()\ncounter = defaultdict(int)\nfor h in H:\n    counter[h] += 1\n\nanswer = 0\nfor x,h in zip(X,H):\n    counter[h] -= 1\n    answer += counter[x]\n\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nS = str(input())\n\nall_eaten = [0] * (2 * N + 1)\np = N\nfor i in S:\n    if i == \">\":\n        p += 1\n    elif i == \"<\":\n        p -= 1\n    elif i == \"+\":\n        all_eaten[p] += 1\n    elif i == \"-\":\n        all_eaten[p] -= 1\n\ncounter = 0\nfor i in range(1, N+1):\n    for j in range(i, N+1):\n        part_eaten = [0] * (2 * N + 1)\n        p = N\n        s = S[i-1:j]\n        for k in s:\n            if k == \">\":\n                p += 1\n            elif k == \"<\":\n                p -= 1\n            elif k == \"+\":\n                part_eaten[p] += 1\n            elif k == \"-\":\n                part_eaten[p] -= 1\n        if part_eaten == all_eaten:\n            counter += 1\n\n\nprint(counter)\n"
  },
  {
    "language": "Python",
    "code": "import random\nfrom collections import defaultdict\n\n\ndef solve(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for i, c in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n\n        ideal = hashes[-1]\n        required = defaultdict(lambda: 0)\n        for i, (p, h) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n\n    return sum(ans)\n\n\nn = int(input())\ns = input()\n\nxs = random.sample(range(10 ** 9, 10 ** 10), 3)\nm = 2305843009213693951\nprint(solve(n, s, xs, m))\n"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nS = str(input())\n\nall_eaten = [0] * (2 * N + 1)\np = N\nfor i in S:\n    if i == \">\":\n        p += 1\n    elif i == \"<\":\n        p -= 1\n    elif i == \"+\":\n        all_eaten[p] += 1\n    elif i == \"-\":\n        all_eaten[p] -= 1\n\ncounter = 0\nfor i in range(1, N+1):\n    for j in range(i, N+1):\n        part_eaten = [0] * (2 * N + 1)\n        p = N\n        s = S[i-1:j]\n        for k in s:\n            if k == \">\":\n                p += 1\n            elif k == \"<\":\n                p -= 1\n            elif k == \"+\":\n                part_eaten[p] += 1\n            elif k == \"-\":\n                part_eaten[p] -= 1\n        if part_eaten == all_eaten:\n            counter += 1\n\n\nprint(counter)\n"
  },
  {
    "language": "Python",
    "code": "import random\nfrom collections import defaultdict\n\n\ndef solve(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for i, c in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp + 1):\n                pow_x.append(pow_x[-1] * x % m)\n\n        ideal = hashes[-1]\n        required = defaultdict(lambda: 0)\n        for i, (p, h) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n\n    return sum(ans)\n\n\nn = int(input())\ns = input()\n\nxs = random.sample(range(10 ** 9, 10 ** 10), 3)\nm = 2305843009213693951\nprint(solve(n, s, xs, m))\n"
  },
  {
    "language": "Python",
    "code": "import random\nfrom collections import defaultdict\n\n\ndef solve(n, s, x, m):\n    p = 0\n    h = 0\n    y = 1\n    r = pow(x, m - 2, m)\n    pos = [0] * (n + 1)\n    hashes = [0] * (n + 1)\n    for i, c in enumerate(s, start=1):\n        if c == '>':\n            p += 1\n            y = y * x % m\n        elif c == '<':\n            p -= 1\n            y = y * r % m\n        elif c == '+':\n            h = (h + y) % m\n        else:\n            h = (h - y) % m\n        pos[i] = p\n        hashes[i] = h\n\n    pow_x = [1]\n    for _ in range(max(pos)):\n        pow_x.append(pow_x[-1] * x % m)\n    mp = min(pos)\n    if mp < 0:\n        pow_x.append(pow(r, -mp, m))\n        for _ in range(-mp + 1):\n            pow_x.append(pow_x[-1] * x % m)\n\n    ans = 0\n    ideal = hashes[-1]\n    required = defaultdict(lambda: 0)\n    for p, h in zip(pos, hashes):\n        ans += required[h]\n        req = (ideal * pow_x[p] + h) % m\n        required[req] += 1\n    return ans\n\n\nn = int(input())\ns = input()\n\nxs = random.sample(range(10 ** 9, 10 ** 10), 5)\nm = 2305843009213693951\nans = min(solve(n, s, x, m) for x in xs)\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\ndef takahashi(s):\n    a = defaultdict(lambda: 0)\n    P = 0\n    for c in s:\n        if c == '+':\n            a[P] += 1\n        elif c == '-':\n            a[P] -= 1\n        elif c == '>':\n            P += 1\n        else:\n            P -= 1\n    keys = a.keys()\n    return {k:v for k, v in a.items() if v != 0}\n\ndef main():\n    N = int(input())\n    s = input()\n    ans = takahashi(s)\n    # print(ans)\n    n = 0\n    for i in range(N):\n        for j in range(i+1, N+1):\n            # print(s[i:j], takahashi(s[i:j]) == ans)\n            if takahashi(s[i:j]) == ans:\n                n += 1\n    print(n)\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\ndef takahashi(s):\n    a = defaultdict(lambda: 0)\n    P = 0\n    for c in s:\n        if c == '+':\n            a[P] += 1\n        elif c == '-':\n            a[P] -= 1\n        elif c == '>':\n            P += 1\n        else:\n            P -= 1\n    keys = a.keys()\n    return {k:v for k, v in a.items() if v != 0}\n\ndef main():\n    N = int(input())\n    s = input()\n    ans = takahashi(s)\n    # print(ans)\n    n = 0\n    for i in range(N):\n        for j in range(i+1, N+1):\n            # print(s[i:j], takahashi(s[i:j]) == ans)\n            if takahashi(s[i:j]) == ans:\n                n += 1\n    print(n)\n\nmain()\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::Read;\n#[allow(dead_code)]\nfn getline() -> String {\n    let mut ret = String::new();\n    std::io::stdin().read_line(&mut ret).ok().unwrap();\n    ret\n}\nfn get_word() -> String {\n    let mut stdin = std::io::stdin();\n    let mut u8b: [u8; 1] = [0];\n    loop {\n        let mut buf: Vec<u8> = Vec::with_capacity(16);\n        loop {\n            let res = stdin.read(&mut u8b);\n            if res.unwrap_or(0) == 0 || u8b[0] <= b' ' {\n                break;\n            } else {\n                buf.push(u8b[0]);\n            }\n        }\n        if buf.len() >= 1 {\n            let ret = String::from_utf8(buf).unwrap();\n            return ret;\n        }\n    }\n}\n\n#[allow(dead_code)]\nfn get<T: std::str::FromStr>() -> T { get_word().parse().ok().unwrap() }\n\nconst MOD: i64 = 1_000_000_007;\n\n/// Refers external ::MOD.\n/// Verified by: https://beta.atcoder.jp/contests/arc099/submissions/2893570\nmod mod_int {\n    use ::MOD;\n    use std::ops::*;\n    #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]\n    pub struct ModInt{pub x: i64}\n    impl ModInt {\n        fn check_integrity(self) {\n            debug_assert!(self.x >= 0);\n            debug_assert!(self.x < MOD);\n        }\n        // x >= 0\n        pub fn new(x: i64) -> Self { ModInt { x: x % MOD } }\n        #[allow(dead_code)]\n        pub fn mul_fast(self, other: Self) -> Self {\n            self.check_integrity();\n            other.check_integrity();\n            Self {x: self.x * other.x % MOD }\n        }\n        #[allow(dead_code)]\n        pub fn mul_slow(self, other: Self) -> Self {\n            // Naive multiplication in order to avoid overflow\n            self.check_integrity();\n            other.check_integrity();\n            let mut sum = ModInt::new(0);\n            let mut cur = self;\n            let mut e = other.x;\n            if self.x < other.x {\n                cur = other;\n                e = self.x;\n            }\n            while e > 0 {\n                if e % 2 == 1 {\n                    sum = sum + cur;\n                }\n                cur = cur + cur;\n                e /= 2;\n            }\n            sum\n        }\n        pub fn pow(self, mut e: i64) -> Self {\n            self.check_integrity();\n            debug_assert!(e >= 0);\n            let mut sum = ModInt::new(1);\n            let mut cur = ModInt::new(self.x);\n            while e > 0 {\n                if e % 2 != 0 {\n                    sum = sum * cur;\n                }\n                cur = cur * cur;\n                e /= 2;\n            }\n            sum\n        }\n        pub fn inv(self) -> Self { self.pow(MOD - 2) }\n    }\n    impl Add for ModInt {\n        type Output = Self;\n        fn add(self, other: Self) -> Self {\n            self.check_integrity();\n            other.check_integrity();\n            let mut sum = self.x + other.x;\n            if sum >= MOD { sum -= MOD; }\n            Self {x: sum }\n        }\n    }\n    impl Sub for ModInt {\n        type Output = Self;\n        fn sub(self, other: Self) -> Self {\n            self.check_integrity();\n            other.check_integrity();\n            let mut sum = self.x - other.x;\n            if sum < 0 { sum += MOD; }\n            Self {x: sum }\n        }\n    }\n    impl Mul for ModInt {\n        type Output = Self;\n        fn mul(self, other: Self) -> Self {\n            self.mul_fast(other)\n        }\n    }\n} // mod mod_int\n\n\nfn solve() {\n    use mod_int::*;\n    let n: usize = get();\n    let s: Vec<_> = get_word().chars().collect();\n    const A: usize = 3;\n    let b = [ModInt::new(41), ModInt::new(255), ModInt::new(36)];\n    let mut hsh = vec![vec![ModInt::new(0); n + 1]; A];\n    let mut inv = [ModInt::new(0); A];\n    for i in 0 .. A { inv[i] = b[i].inv(); }\n    let mut pos = vec![0; n + 1];\n    for c in 0 .. A {\n        let mut p = 0;\n        let mut cur = ModInt::new(1);\n        for (i, &ch) in s.iter().enumerate() {\n            let mut tmp = hsh[c][i];\n            match ch {\n                '>' => {\n                    p += 1;\n                    cur = cur * b[c];\n                },\n                '<' => {\n                    p -= 1;\n                    cur = cur * inv[c];\n                },\n                '+' => tmp = tmp + cur,\n                '-' => tmp = tmp - cur,\n                _ => panic!(),\n            }\n            hsh[c][i + 1] = tmp;\n            pos[i + 1] = p;\n        }\n    }\n    let mut meguru = [ModInt::new(0); A];\n    for c in 0 .. A { meguru[c] = hsh[c][n]; }\n    let mut kirika = HashMap::new();\n    kirika.insert(meguru, 1);\n    let mut tot = 0i64;\n    for i in (0 .. n).rev() {\n        let mut cur = [ModInt::new(0); A];\n        for c in 0 .. A { cur[c] = b[c].pow(MOD - 1 + pos[i]); }\n        let mut ken = [ModInt::new(0); A];\n        for c in 0 .. A { ken[c] = cur[c] * meguru[c] + hsh[c][i]; }\n        tot += kirika.get(&ken).cloned().unwrap_or(0);\n        let mut tt = [ModInt::new(0); A];\n        for c in 0 .. A { tt[c] = hsh[c][i]; }\n        *kirika.entry(tt).or_insert(0) += 1;\n    }\n    println!(\"{}\", tot);\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "use proconio::{input, marker::Chars};\n\n// modint{{{\nmod modint {\n    //! [`Mint`] 型を提供します。\n    //!\n    //! [`Mint`]: struct.Mint.html\n\n    /// [`Mint`] の中に入れる数値型が実装していないといけないトレイトをまとめました。\n    ///\n    /// どうやら普通の符号付き整数型ならば大丈夫そうですね。\n    ///\n    /// いかがでしたでしょうか？（真顔）\n    ///\n    /// [`Mint`]: struct.Mint.html\n    pub trait ModValue:\n        std::ops::Add<Output = Self>\n        + std::ops::Sub<Output = Self>\n        + std::ops::Mul<Output = Self>\n        + std::ops::Div<Output = Self>\n        + std::ops::Rem<Output = Self>\n        + std::ops::AddAssign\n        + std::ops::SubAssign\n        + std::ops::MulAssign\n        + std::ops::DivAssign\n        + std::ops::RemAssign\n        + std::ops::Neg\n        + std::cmp::Ord\n        + Clone\n        + Copy\n        + Sized\n        + std::fmt::Debug\n        + std::fmt::Display\n    {\n    }\n\n    impl<\n            Value: std::ops::Add<Output = Self>\n                + std::ops::Sub<Output = Self>\n                + std::ops::Mul<Output = Self>\n                + std::ops::Div<Output = Self>\n                + std::ops::Rem<Output = Self>\n                + std::ops::AddAssign\n                + std::ops::SubAssign\n                + std::ops::MulAssign\n                + std::ops::DivAssign\n                + std::ops::RemAssign\n                + std::ops::Neg\n                + std::cmp::Ord\n                + Clone\n                + Copy\n                + Sized\n                + std::fmt::Debug\n                + std::fmt::Display,\n        > ModValue for Value\n    {\n    }\n\n    /// mod に関数情報を [`Mint`] に伝えるための型引数だッピ！\n    ///\n    /// [`Mint`]: struct.Mint.html\n    pub trait Minfo: Clone + Copy + std::fmt::Debug {\n        /// 中身の型です。\n        type Value: ModValue;\n\n        /// mod の値を返します。\n        fn modulus() -> Self::Value;\n\n        /// 0 を返します。\n        fn zero() -> Self::Value;\n\n        /// 1 を返します。\n        fn one() -> Self::Value;\n    }\n\n    /// 自動で mod を取ってくれる整数型です。\n    ///\n    /// 型引数は、トレイト [`Minfo`] を実装している必要があります。\n    ///\n    /// # Examples\n    ///\n    /// [`from_value`] によって、`Mint<Mod>` が作れます。\n    /// 逆に、[`value`] によって、中身がとれます。\n    ///\n    /// ```\n    /// use modint::Mint1000000007;\n    /// type Mint = Mint1000000007;\n    ///\n    /// let x: Mint = Mint::from_value(2);\n    ///\n    /// assert_eq!(x.value(), 2);\n    /// ```\n    ///\n    /// 四則演算ができます。\n    ///\n    /// ```\n    /// use modint::Mint1000000007;\n    /// type Mint = Mint1000000007;\n    ///\n    /// let x: Mint = Mint::from_value(6);\n    /// let y: Mint = Mint::from_value(2);\n    ///\n    /// assert_eq!((x + y).value(), 8);\n    /// assert_eq!((x - y).value(), 4);\n    /// assert_eq!((x * y).value(), 12);\n    /// assert_eq!((x / y).value(), 3);\n    /// ```\n    ///\n    /// [`value`]: #method.value\n    /// [`from_value`]: #method.from_value\n    /// [`Minfo`]:trait.Minfo.html\n\n    #[derive(Clone, Copy, Debug)]\n    pub struct Mint<Mod: Minfo>(Mod::Value);\n\n    impl<Mod: Minfo> Mint<Mod> {\n        #[inline]\n        #[allow(dead_code)]\n        fn is_within_the_range(x: Mod::Value) -> bool {\n            Mod::zero() <= x && x < Mod::modulus()\n        }\n\n        #[inline]\n        #[allow(dead_code)]\n        fn normalize(x: Mod::Value) -> Mod::Value {\n            if Self::is_within_the_range(x) {\n                x\n            } else {\n                let x = x % Mod::modulus();\n                if x < Mod::zero() {\n                    x + Mod::modulus()\n                } else {\n                    x\n                }\n            }\n        }\n\n        /// 0 を構築します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::zero();\n        /// assert_eq!(x.value(), 0);\n        /// ```\n        #[allow(dead_code)]\n        pub fn zero() -> Self {\n            Self(Mod::zero())\n        }\n\n        /// 1 を構築します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::one();\n        /// assert_eq!(x.value(), 1);\n        /// ```\n        #[allow(dead_code)]\n        pub fn one() -> Self {\n            Self(Mod::one())\n        }\n\n        /// mod を取得します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::modulus();\n        /// assert_eq!(x, 998244353);\n        /// ```\n        #[allow(dead_code)]\n        pub fn modulus() -> Mod::Value {\n            Mod::modulus()\n        }\n\n        /// 0 であるときに `true` を返します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::zero();\n        /// assert!(x.is_zero());\n        ///\n        /// let x = Mint::one();\n        /// assert!(!x.is_zero());\n        /// ```\n        #[allow(dead_code)]\n        pub fn is_zero(&self) -> bool {\n            self.value() == Mod::zero()\n        }\n\n        /// 構築します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::from_value(4);\n        /// ```\n        #[allow(dead_code)]\n        pub fn from_value(x: Mod::Value) -> Self {\n            Self(Self::normalize(x))\n        }\n\n        /// 中身を取得します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::from_value(4);\n        /// assert_eq!(x.value(), 4);\n        /// ```\n        #[allow(dead_code)]\n        pub fn value(&self) -> Mod::Value {\n            self.0\n        }\n\n        /// mod 逆元を計算します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::from_value(2);\n        /// assert_eq!(x.inv().value(), 499122177);\n        /// ```\n        #[allow(dead_code)]\n        pub fn inv(&self) -> Self {\n            if self.is_zero() {\n                panic!(\"inv(0)\");\n            }\n            Self(Self::raw_inv(self.value()))\n        }\n\n        /// ユークリッドの互除法を用いて、pow を計算します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// let x = Mint17::from_value(2);\n        /// assert_eq!(x.pow(6).value(), 64 % 17);\n        /// ```\n        #[allow(dead_code)]\n        pub fn pow(&self, b: u64) -> Self {\n            Self(Self::raw_pow(self.value(), b))\n        }\n\n        fn raw_add(x: Mod::Value, y: Mod::Value) -> Mod::Value {\n            let z = x + y;\n            if Mod::modulus() <= z {\n                z - Mod::modulus()\n            } else {\n                z\n            }\n        }\n\n        fn raw_sub(x: Mod::Value, y: Mod::Value) -> Mod::Value {\n            let z = x - y;\n            if z < Mod::zero() {\n                z + Mod::modulus()\n            } else {\n                z\n            }\n        }\n\n        fn raw_neg(x: Mod::Value) -> Mod::Value {\n            if x == Mod::zero() {\n                Mod::zero()\n            } else {\n                Mod::modulus() - x\n            }\n        }\n\n        fn raw_mul(x: Mod::Value, y: Mod::Value) -> Mod::Value {\n            x * y % Mod::modulus()\n        }\n\n        fn raw_div(x: Mod::Value, y: Mod::Value) -> Mod::Value {\n            Self::raw_mul(x, Self::raw_inv(y))\n        }\n\n        #[allow(clippy::many_single_char_names)]\n        fn raw_inv(mut x: Mod::Value) -> Mod::Value {\n            let mut y = Mod::modulus();\n            let mut u = Mod::one();\n            let mut v = Mod::zero();\n            while x != Mod::zero() {\n                let q = y / x;\n                y -= x * q;\n                v -= u * q;\n                std::mem::swap(&mut x, &mut y);\n                std::mem::swap(&mut u, &mut v);\n            }\n            if v < Mod::zero() {\n                v + Mod::modulus()\n            } else {\n                v\n            }\n        }\n\n        fn raw_pow(mut a: Mod::Value, mut b: u64) -> Mod::Value {\n            let mut x = Mod::one();\n            while 0 < b {\n                if b % 2 == 1 {\n                    x = Self::raw_mul(x, a);\n                }\n                a = Self::raw_mul(a, a);\n                b /= 2\n            }\n            x\n        }\n    }\n\n    macro_rules! impl_biop {\n    (\n        $(\n            $biop_trait: ident::$biop_fn: ident,\n            $biop_assign_trait: ident::$biop_assign_fn: ident,\n            $biop_impl: ident;\n        )*\n    ) => {\n        $(\n            impl<Mod: Minfo> std::ops::$biop_trait for Mint<Mod> {\n                type Output = Self;\n                fn $biop_fn(self, rhs: Self) -> Self::Output {\n                    Mint(Self::$biop_impl(self.value(), rhs.value()))\n                }\n            }\n            impl<Mod: Minfo> std::ops::$biop_assign_trait for Mint<Mod>\n            where\n                Self: Copy\n            {\n                fn $biop_assign_fn(&mut self, rhs: Self) {\n                    use std::ops::$biop_trait;\n                    *self = Mint::$biop_fn(*self, rhs)\n                }\n            }\n        )*\n    };\n}\n\n    impl_biop! {\n        Add::add, AddAssign::add_assign, raw_add;\n        Sub::sub, SubAssign::sub_assign, raw_sub;\n        Mul::mul, MulAssign::mul_assign, raw_mul;\n        Div::div, DivAssign::div_assign, raw_div;\n    }\n\n    impl<Mod: Minfo> std::ops::Neg for Mint<Mod> {\n        type Output = Self;\n        fn neg(self) -> Self::Output {\n            Self(Self::raw_neg(self.value()))\n        }\n    }\n\n    impl<Mod: Minfo> std::cmp::PartialEq for Mint<Mod> {\n        /// 中身をそのまま 比較です。\n        /// 構築時に normalize され、それ以降も normalized な状態に保たれますから、\n        /// 結局あまりを比較しているのと同じことになります。\n        ///\n        /// # Example\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// assert_eq!(Mint17::from_value(3), Mint::from_value(-31));\n        /// assert_eq!(Mint17::from_value(3), Mint::from_value(-14));\n        /// assert_eq!(Mint17::from_value(3), Mint::from_value(3));\n        /// assert_eq!(Mint17::from_value(3), Mint::from_value(20));\n        /// assert_eq!(Mint17::from_value(3), Mint::from_value(37));\n        ///\n        /// assert_ne!(Mint17::from_value(3), Mint::from_value(31));\n        /// assert_ne!(Mint17::from_value(3), Mint::from_value(14));\n        /// assert_ne!(Mint17::from_value(3), Mint::from_value(-3));\n        /// assert_ne!(Mint17::from_value(3), Mint::from_value(-20));\n        /// assert_ne!(Mint17::from_value(3), Mint::from_value(-37));\n        /// ```\n        fn eq(&self, other: &Self) -> bool {\n            self.value().eq(&other.value())\n        }\n    }\n    impl<Mod: Minfo> std::cmp::Eq for Mint<Mod> {}\n\n    impl<Mod: Minfo> std::fmt::Display for Mint<Mod> {\n        /// 中身をそのまま Display です。\n        ///\n        /// # Example\n        ///\n        /// ```\n        /// println!(\"{}\", modint::Mint998244353::from_value(42));\n        /// ```\n        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n            write!(f, \"{}\", self.value())\n        }\n    }\n\n    impl<Mod: Minfo> std::iter::Sum<Self> for Mint<Mod> {\n        /// 総和を取ります。\n        ///\n        /// # Example\n        ///\n        /// ```\n        /// use modint::{define_mint, Minfo, Mint};\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        /// assert_eq!(\n        ///     vec![\n        ///         Mint17::from_value(2),\n        ///         Mint17::from_value(4),\n        ///         Mint17::from_value(6),\n        ///         Mint17::from_value(8),\n        ///     ]\n        ///     .into_iter()\n        ///     .sum::<Mint17>(),\n        ///     Mint17::from_value(3)\n        /// );\n        /// ```\n        fn sum<I: Iterator<Item = Self>>(iter: I) -> Self {\n            iter.fold(Mint::zero(), |acc, x| acc + x)\n        }\n    }\n\n    impl<Mod: Minfo> std::iter::Product<Self> for Mint<Mod> {\n        /// 総積を取ります。\n        ///\n        /// # Example\n        ///\n        /// ```\n        /// use modint::{define_mint, Minfo, Mint};\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        /// assert_eq!(\n        ///     vec![\n        ///         Mint17::from_value(1),\n        ///         Mint17::from_value(2),\n        ///         Mint17::from_value(3),\n        ///         Mint17::from_value(4),\n        ///     ]\n        ///     .into_iter()\n        ///     .product::<Mint17>(),\n        ///     Mint17::from_value(7)\n        /// );\n        /// ```\n        fn product<I: Iterator<Item = Self>>(iter: I) -> Self {\n            iter.fold(Mint::one(), |acc, x| acc * x)\n        }\n    }\n\n    /// 階乗とその逆元を前計算するマシーンです。\n    #[allow(dead_code)]\n    pub struct Factorial<Mod: Minfo> {\n        normal: Vec<Mint<Mod>>,\n        inverted: Vec<Mint<Mod>>,\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo> Factorial<Mod>\n    where\n        Mod::Value: std::convert::TryFrom<usize, Error = std::num::TryFromIntError>,\n    {\n        /// サイズを指定して初期化です。\n        /// 最大値は一つ小さくなりますから、注意です。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, Factorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        /// let fact = Factorial::<Minfo17>::new(16);\n        /// ```\n        pub fn new(n: usize) -> Self {\n            use std::convert::TryFrom;\n            let mut normal = vec![Mint::one(); n];\n            for i in 1..n {\n                normal[i] = normal[i - 1] * Mint::from_value(Mod::Value::try_from(i).unwrap());\n            }\n            let mut inverted = vec![Mint::one(); n];\n            inverted[n - 1] = normal[n - 1].inv();\n            for i in (1..n).rev() {\n                inverted[i - 1] = inverted[i] * Mint::from_value(Mod::Value::try_from(i).unwrap());\n            }\n            Self { normal, inverted }\n        }\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo> Factorial<Mod> {\n        /// 階乗の逆元を取得します。\n        ///\n        /// 逆元でなくて普通の階乗は、[`implementations`] をご覧いただけると幸いです。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, Factorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// let fact = Factorial::<Minfo17>::new(17);\n        ///\n        /// for i in 0..17 {\n        ///     assert_eq!(fact[i] * fact.inverted(i), Mint17::one());\n        /// }\n        /// ```\n        ///\n        /// [`implementations`]: #implementations\n        ///\n        pub fn inverted(&self, i: usize) -> Mint<Mod> {\n            self.inverted[i]\n        }\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo, I: std::slice::SliceIndex<[Mint<Mod>]>> std::ops::Index<I> for Factorial<Mod> {\n        type Output = I::Output;\n\n        /// Index でも取ることができます。\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, Factorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// let fact = Factorial::<Minfo17>::new(17);\n        ///\n        /// assert_eq!(fact[0], Mint17::from_value(1));\n        /// assert_eq!(fact[1], Mint17::from_value(1));\n        /// assert_eq!(fact[2], Mint17::from_value(2));\n        /// assert_eq!(fact[3], Mint17::from_value(6));\n        /// assert_eq!(fact[4], Mint17::from_value(24 % 17));\n        /// assert_eq!(fact[5], Mint17::from_value(120 % 17));\n        /// ```\n        #[inline]\n        fn index(&self, index: I) -> &Self::Output {\n            &self.normal[index]\n        }\n    }\n\n    /// 二重階乗とその逆元を前計算するマシーンです。\n    #[allow(dead_code)]\n    pub struct DoubleFactorial<Mod: Minfo> {\n        normal: Vec<Mint<Mod>>,\n        inverted: Vec<Mint<Mod>>,\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo> DoubleFactorial<Mod>\n    where\n        Mod::Value: std::convert::TryFrom<usize, Error = std::num::TryFromIntError>,\n    {\n        /// サイズを指定して初期化です。\n        /// 最大値は一つ小さくなりますから、注意です。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, DoubleFactorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        /// let fact = DoubleFactorial::<Minfo17>::new(16);\n        /// ```\n        pub fn new(n: usize) -> Self {\n            use std::convert::TryFrom;\n            let mut normal = vec![Mint::one(); n];\n            for i in 2..n {\n                normal[i] = normal[i - 2] * Mint::from_value(Mod::Value::try_from(i).unwrap());\n            }\n            let mut inverted = vec![Mint::one(); n];\n            inverted[n - 1] = normal[n - 1].inv();\n            inverted[n - 2] = normal[n - 2].inv();\n            for i in (2..n).rev() {\n                inverted[i - 2] = inverted[i] * Mint::from_value(Mod::Value::try_from(i).unwrap());\n            }\n            Self { normal, inverted }\n        }\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo> DoubleFactorial<Mod> {\n        /// 二重階乗の逆元を取得します。\n        ///\n        /// 逆元でなくて普通の二重階乗は、[`implementations`] をご覧いただけると幸いです。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, DoubleFactorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// let fact = DoubleFactorial::<Minfo17>::new(17);\n        ///\n        /// for i in 0..17 {\n        ///     assert_eq!(fact[i] * fact.inverted(i), Mint17::one());\n        /// }\n        /// ```\n        ///\n        /// [`implementations`]: #implementations\n        ///\n        pub fn inverted(&self, i: usize) -> Mint<Mod> {\n            self.inverted[i]\n        }\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo, I: std::slice::SliceIndex<[Mint<Mod>]>> std::ops::Index<I>\n        for DoubleFactorial<Mod>\n    {\n        type Output = I::Output;\n\n        /// Index でも取ることができます。\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, DoubleFactorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// let fact = DoubleFactorial::<Minfo17>::new(17);\n        ///\n        /// assert_eq!(fact[0], Mint17::from_value(1));\n        /// assert_eq!(fact[1], Mint17::from_value(1));\n        /// assert_eq!(fact[2], Mint17::from_value(2));\n        /// assert_eq!(fact[3], Mint17::from_value(3));\n        /// assert_eq!(fact[4], Mint17::from_value(8));\n        /// assert_eq!(fact[5], Mint17::from_value(15));\n        /// ```\n        #[inline]\n        fn index(&self, index: I) -> &Self::Output {\n            &self.normal[index]\n        }\n    }\n\n    /// Mint 型を定義するためのマクロです。\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use modint::{define_mint, Minfo, Mint};\n    ///\n    /// define_mint! {\n    ///     struct Mint17(Minfo17(17; i64));\n    /// }\n    ///\n    /// let x = Mint17::from_value(1);\n    /// let y = Mint17::from_value(2);\n    /// let z = x / y;\n    /// assert_eq!(z.value(), 9);\n    /// ```\n    #[macro_export]\n    macro_rules! define_mint {\n        (\n        struct $modint: ident ($modinfo: ident ($modvalue: expr; $modty: ty));\n    ) => {\n            #[allow(dead_code)]\n            #[derive(Clone, Copy, Debug)]\n            pub struct $modinfo {}\n            impl Minfo for $modinfo {\n                type Value = $modty;\n                fn modulus() -> Self::Value {\n                    $modvalue\n                }\n                fn zero() -> Self::Value {\n                    0\n                }\n                fn one() -> Self::Value {\n                    1\n                }\n            }\n            type $modint = Mint<$modinfo>;\n        };\n    }\n\n    /// Mod = 1000000007 なる Minfo です。\n    #[allow(dead_code)]\n    #[derive(Clone, Copy, Debug)]\n    pub struct Minfo1000000007 {}\n\n    impl Minfo for Minfo1000000007 {\n        type Value = i64;\n        fn modulus() -> Self::Value {\n            1_000_000_007\n        }\n        fn zero() -> Self::Value {\n            0\n        }\n        fn one() -> Self::Value {\n            1\n        }\n    }\n\n    /// Mod = 1000000007 なる Mint です。\n    #[allow(dead_code)]\n    pub type Mint1000000007 = Mint<Minfo1000000007>;\n\n    /// Mod = 998244353 なる Minfo です。\n    #[allow(dead_code)]\n    #[derive(Clone, Copy, Debug)]\n    pub struct Minfo998244353 {}\n\n    impl Minfo for Minfo998244353 {\n        type Value = i64;\n        fn modulus() -> Self::Value {\n            998_244_353\n        }\n        fn zero() -> Self::Value {\n            0\n        }\n        fn one() -> Self::Value {\n            1\n        }\n    }\n\n    /// Mod = 998244353 なる Mint です。\n    #[allow(dead_code)]\n    pub type Mint998244353 = Mint<Minfo998244353>;\n}\n//}}}\n\ntype Mint = modint::Mint998244353;\n\nfn main() {\n    input!(n: usize, mut s: Chars);\n    s.reverse();\n    let make = |x: Mint| -> Vec<(Mint, Mint)> {\n        let xinv = x.inv();\n        let mut ans = vec![(Mint::one(), Mint::zero()); n + 1];\n        for (i, &c) in s.iter().enumerate() {\n            let (a, b) = ans[i];\n            ans[i + 1] = match c {\n                '+' => (a, b + Mint::one()),\n                '-' => (a, b - Mint::one()),\n                '<' => (a * x, b * x),\n                '>' => (a * xinv, b * xinv),\n                _ => panic!(),\n            }\n        }\n        ans\n    };\n\n    let keys: Vec<_> = (1..12)\n        .map(|i| i * 10_000_000)\n        .map(Mint::from_value)\n        .collect();\n    let seqs: Vec<_> = keys.iter().copied().map(make).collect();\n    let mut hash_map = std::collections::HashMap::<Vec<_>, _>::new();\n    let mut ans = 0;\n    for i in 0..=n {\n        if let Some(x) = hash_map.get(\n            &(0..keys.len())\n                .map(|j| {\n                    let (a, b) = seqs[j][i];\n                    ((b - seqs[j][n].1) / a).value()\n                })\n                .collect::<Vec<_>>(),\n        ) {\n            ans += x;\n        }\n        *hash_map\n            .entry(\n                (0..keys.len())\n                    .map(|j| {\n                        let (a, b) = seqs[j][i];\n                        (b / a).value()\n                    })\n                    .collect(),\n            )\n            .or_insert(0) += 1;\n    }\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "use proconio::{input, marker::Chars};\n\n// modint{{{\nmod modint {\n    //! [`Mint`] 型を提供します。\n    //!\n    //! [`Mint`]: struct.Mint.html\n\n    /// [`Mint`] の中に入れる数値型が実装していないといけないトレイトをまとめました。\n    ///\n    /// どうやら普通の符号付き整数型ならば大丈夫そうですね。\n    ///\n    /// いかがでしたでしょうか？（真顔）\n    ///\n    /// [`Mint`]: struct.Mint.html\n    pub trait ModValue:\n        std::ops::Add<Output = Self>\n        + std::ops::Sub<Output = Self>\n        + std::ops::Mul<Output = Self>\n        + std::ops::Div<Output = Self>\n        + std::ops::Rem<Output = Self>\n        + std::ops::AddAssign\n        + std::ops::SubAssign\n        + std::ops::MulAssign\n        + std::ops::DivAssign\n        + std::ops::RemAssign\n        + std::ops::Neg\n        + std::cmp::Ord\n        + Clone\n        + Copy\n        + Sized\n        + std::fmt::Debug\n        + std::fmt::Display\n    {\n    }\n\n    impl<\n            Value: std::ops::Add<Output = Self>\n                + std::ops::Sub<Output = Self>\n                + std::ops::Mul<Output = Self>\n                + std::ops::Div<Output = Self>\n                + std::ops::Rem<Output = Self>\n                + std::ops::AddAssign\n                + std::ops::SubAssign\n                + std::ops::MulAssign\n                + std::ops::DivAssign\n                + std::ops::RemAssign\n                + std::ops::Neg\n                + std::cmp::Ord\n                + Clone\n                + Copy\n                + Sized\n                + std::fmt::Debug\n                + std::fmt::Display,\n        > ModValue for Value\n    {\n    }\n\n    /// mod に関数情報を [`Mint`] に伝えるための型引数だッピ！\n    ///\n    /// [`Mint`]: struct.Mint.html\n    pub trait Minfo: Clone + Copy + std::fmt::Debug {\n        /// 中身の型です。\n        type Value: ModValue;\n\n        /// mod の値を返します。\n        fn modulus() -> Self::Value;\n\n        /// 0 を返します。\n        fn zero() -> Self::Value;\n\n        /// 1 を返します。\n        fn one() -> Self::Value;\n    }\n\n    /// 自動で mod を取ってくれる整数型です。\n    ///\n    /// 型引数は、トレイト [`Minfo`] を実装している必要があります。\n    ///\n    /// # Examples\n    ///\n    /// [`from_value`] によって、`Mint<Mod>` が作れます。\n    /// 逆に、[`value`] によって、中身がとれます。\n    ///\n    /// ```\n    /// use modint::Mint1000000007;\n    /// type Mint = Mint1000000007;\n    ///\n    /// let x: Mint = Mint::from_value(2);\n    ///\n    /// assert_eq!(x.value(), 2);\n    /// ```\n    ///\n    /// 四則演算ができます。\n    ///\n    /// ```\n    /// use modint::Mint1000000007;\n    /// type Mint = Mint1000000007;\n    ///\n    /// let x: Mint = Mint::from_value(6);\n    /// let y: Mint = Mint::from_value(2);\n    ///\n    /// assert_eq!((x + y).value(), 8);\n    /// assert_eq!((x - y).value(), 4);\n    /// assert_eq!((x * y).value(), 12);\n    /// assert_eq!((x / y).value(), 3);\n    /// ```\n    ///\n    /// [`value`]: #method.value\n    /// [`from_value`]: #method.from_value\n    /// [`Minfo`]:trait.Minfo.html\n\n    #[derive(Clone, Copy, Debug)]\n    pub struct Mint<Mod: Minfo>(Mod::Value);\n\n    impl<Mod: Minfo> Mint<Mod> {\n        #[inline]\n        #[allow(dead_code)]\n        fn is_within_the_range(x: Mod::Value) -> bool {\n            Mod::zero() <= x && x < Mod::modulus()\n        }\n\n        #[inline]\n        #[allow(dead_code)]\n        fn normalize(x: Mod::Value) -> Mod::Value {\n            if Self::is_within_the_range(x) {\n                x\n            } else {\n                let x = x % Mod::modulus();\n                if x < Mod::zero() {\n                    x + Mod::modulus()\n                } else {\n                    x\n                }\n            }\n        }\n\n        /// 0 を構築します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::zero();\n        /// assert_eq!(x.value(), 0);\n        /// ```\n        #[allow(dead_code)]\n        pub fn zero() -> Self {\n            Self(Mod::zero())\n        }\n\n        /// 1 を構築します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::one();\n        /// assert_eq!(x.value(), 1);\n        /// ```\n        #[allow(dead_code)]\n        pub fn one() -> Self {\n            Self(Mod::one())\n        }\n\n        /// mod を取得します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::modulus();\n        /// assert_eq!(x, 998244353);\n        /// ```\n        #[allow(dead_code)]\n        pub fn modulus() -> Mod::Value {\n            Mod::modulus()\n        }\n\n        /// 0 であるときに `true` を返します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::zero();\n        /// assert!(x.is_zero());\n        ///\n        /// let x = Mint::one();\n        /// assert!(!x.is_zero());\n        /// ```\n        #[allow(dead_code)]\n        pub fn is_zero(&self) -> bool {\n            self.value() == Mod::zero()\n        }\n\n        /// 構築します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::from_value(4);\n        /// ```\n        #[allow(dead_code)]\n        pub fn from_value(x: Mod::Value) -> Self {\n            Self(Self::normalize(x))\n        }\n\n        /// 中身を取得します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::from_value(4);\n        /// assert_eq!(x.value(), 4);\n        /// ```\n        #[allow(dead_code)]\n        pub fn value(&self) -> Mod::Value {\n            self.0\n        }\n\n        /// mod 逆元を計算します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::from_value(2);\n        /// assert_eq!(x.inv().value(), 499122177);\n        /// ```\n        #[allow(dead_code)]\n        pub fn inv(&self) -> Self {\n            if self.is_zero() {\n                panic!(\"inv(0)\");\n            }\n            Self(Self::raw_inv(self.value()))\n        }\n\n        /// ユークリッドの互除法を用いて、pow を計算します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// let x = Mint17::from_value(2);\n        /// assert_eq!(x.pow(6).value(), 64 % 17);\n        /// ```\n        #[allow(dead_code)]\n        pub fn pow(&self, b: u64) -> Self {\n            Self(Self::raw_pow(self.value(), b))\n        }\n\n        fn raw_add(x: Mod::Value, y: Mod::Value) -> Mod::Value {\n            let z = x + y;\n            if Mod::modulus() <= z {\n                z - Mod::modulus()\n            } else {\n                z\n            }\n        }\n\n        fn raw_sub(x: Mod::Value, y: Mod::Value) -> Mod::Value {\n            let z = x - y;\n            if z < Mod::zero() {\n                z + Mod::modulus()\n            } else {\n                z\n            }\n        }\n\n        fn raw_neg(x: Mod::Value) -> Mod::Value {\n            if x == Mod::zero() {\n                Mod::zero()\n            } else {\n                Mod::modulus() - x\n            }\n        }\n\n        fn raw_mul(x: Mod::Value, y: Mod::Value) -> Mod::Value {\n            x * y % Mod::modulus()\n        }\n\n        fn raw_div(x: Mod::Value, y: Mod::Value) -> Mod::Value {\n            Self::raw_mul(x, Self::raw_inv(y))\n        }\n\n        #[allow(clippy::many_single_char_names)]\n        fn raw_inv(mut x: Mod::Value) -> Mod::Value {\n            let mut y = Mod::modulus();\n            let mut u = Mod::one();\n            let mut v = Mod::zero();\n            while x != Mod::zero() {\n                let q = y / x;\n                y -= x * q;\n                v -= u * q;\n                std::mem::swap(&mut x, &mut y);\n                std::mem::swap(&mut u, &mut v);\n            }\n            if v < Mod::zero() {\n                v + Mod::modulus()\n            } else {\n                v\n            }\n        }\n\n        fn raw_pow(mut a: Mod::Value, mut b: u64) -> Mod::Value {\n            let mut x = Mod::one();\n            while 0 < b {\n                if b % 2 == 1 {\n                    x = Self::raw_mul(x, a);\n                }\n                a = Self::raw_mul(a, a);\n                b /= 2\n            }\n            x\n        }\n    }\n\n    macro_rules! impl_biop {\n    (\n        $(\n            $biop_trait: ident::$biop_fn: ident,\n            $biop_assign_trait: ident::$biop_assign_fn: ident,\n            $biop_impl: ident;\n        )*\n    ) => {\n        $(\n            impl<Mod: Minfo> std::ops::$biop_trait for Mint<Mod> {\n                type Output = Self;\n                fn $biop_fn(self, rhs: Self) -> Self::Output {\n                    Mint(Self::$biop_impl(self.value(), rhs.value()))\n                }\n            }\n            impl<Mod: Minfo> std::ops::$biop_assign_trait for Mint<Mod>\n            where\n                Self: Copy\n            {\n                fn $biop_assign_fn(&mut self, rhs: Self) {\n                    use std::ops::$biop_trait;\n                    *self = Mint::$biop_fn(*self, rhs)\n                }\n            }\n        )*\n    };\n}\n\n    impl_biop! {\n        Add::add, AddAssign::add_assign, raw_add;\n        Sub::sub, SubAssign::sub_assign, raw_sub;\n        Mul::mul, MulAssign::mul_assign, raw_mul;\n        Div::div, DivAssign::div_assign, raw_div;\n    }\n\n    impl<Mod: Minfo> std::ops::Neg for Mint<Mod> {\n        type Output = Self;\n        fn neg(self) -> Self::Output {\n            Self(Self::raw_neg(self.value()))\n        }\n    }\n\n    impl<Mod: Minfo> std::cmp::PartialEq for Mint<Mod> {\n        /// 中身をそのまま 比較です。\n        /// 構築時に normalize され、それ以降も normalized な状態に保たれますから、\n        /// 結局あまりを比較しているのと同じことになります。\n        ///\n        /// # Example\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// assert_eq!(Mint17::from_value(3), Mint::from_value(-31));\n        /// assert_eq!(Mint17::from_value(3), Mint::from_value(-14));\n        /// assert_eq!(Mint17::from_value(3), Mint::from_value(3));\n        /// assert_eq!(Mint17::from_value(3), Mint::from_value(20));\n        /// assert_eq!(Mint17::from_value(3), Mint::from_value(37));\n        ///\n        /// assert_ne!(Mint17::from_value(3), Mint::from_value(31));\n        /// assert_ne!(Mint17::from_value(3), Mint::from_value(14));\n        /// assert_ne!(Mint17::from_value(3), Mint::from_value(-3));\n        /// assert_ne!(Mint17::from_value(3), Mint::from_value(-20));\n        /// assert_ne!(Mint17::from_value(3), Mint::from_value(-37));\n        /// ```\n        fn eq(&self, other: &Self) -> bool {\n            self.value().eq(&other.value())\n        }\n    }\n    impl<Mod: Minfo> std::cmp::Eq for Mint<Mod> {}\n\n    impl<Mod: Minfo> std::fmt::Display for Mint<Mod> {\n        /// 中身をそのまま Display です。\n        ///\n        /// # Example\n        ///\n        /// ```\n        /// println!(\"{}\", modint::Mint998244353::from_value(42));\n        /// ```\n        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n            write!(f, \"{}\", self.value())\n        }\n    }\n\n    impl<Mod: Minfo> std::iter::Sum<Self> for Mint<Mod> {\n        /// 総和を取ります。\n        ///\n        /// # Example\n        ///\n        /// ```\n        /// use modint::{define_mint, Minfo, Mint};\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        /// assert_eq!(\n        ///     vec![\n        ///         Mint17::from_value(2),\n        ///         Mint17::from_value(4),\n        ///         Mint17::from_value(6),\n        ///         Mint17::from_value(8),\n        ///     ]\n        ///     .into_iter()\n        ///     .sum::<Mint17>(),\n        ///     Mint17::from_value(3)\n        /// );\n        /// ```\n        fn sum<I: Iterator<Item = Self>>(iter: I) -> Self {\n            iter.fold(Mint::zero(), |acc, x| acc + x)\n        }\n    }\n\n    impl<Mod: Minfo> std::iter::Product<Self> for Mint<Mod> {\n        /// 総積を取ります。\n        ///\n        /// # Example\n        ///\n        /// ```\n        /// use modint::{define_mint, Minfo, Mint};\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        /// assert_eq!(\n        ///     vec![\n        ///         Mint17::from_value(1),\n        ///         Mint17::from_value(2),\n        ///         Mint17::from_value(3),\n        ///         Mint17::from_value(4),\n        ///     ]\n        ///     .into_iter()\n        ///     .product::<Mint17>(),\n        ///     Mint17::from_value(7)\n        /// );\n        /// ```\n        fn product<I: Iterator<Item = Self>>(iter: I) -> Self {\n            iter.fold(Mint::one(), |acc, x| acc * x)\n        }\n    }\n\n    /// 階乗とその逆元を前計算するマシーンです。\n    #[allow(dead_code)]\n    pub struct Factorial<Mod: Minfo> {\n        normal: Vec<Mint<Mod>>,\n        inverted: Vec<Mint<Mod>>,\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo> Factorial<Mod>\n    where\n        Mod::Value: std::convert::TryFrom<usize, Error = std::num::TryFromIntError>,\n    {\n        /// サイズを指定して初期化です。\n        /// 最大値は一つ小さくなりますから、注意です。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, Factorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        /// let fact = Factorial::<Minfo17>::new(16);\n        /// ```\n        pub fn new(n: usize) -> Self {\n            use std::convert::TryFrom;\n            let mut normal = vec![Mint::one(); n];\n            for i in 1..n {\n                normal[i] = normal[i - 1] * Mint::from_value(Mod::Value::try_from(i).unwrap());\n            }\n            let mut inverted = vec![Mint::one(); n];\n            inverted[n - 1] = normal[n - 1].inv();\n            for i in (1..n).rev() {\n                inverted[i - 1] = inverted[i] * Mint::from_value(Mod::Value::try_from(i).unwrap());\n            }\n            Self { normal, inverted }\n        }\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo> Factorial<Mod> {\n        /// 階乗の逆元を取得します。\n        ///\n        /// 逆元でなくて普通の階乗は、[`implementations`] をご覧いただけると幸いです。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, Factorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// let fact = Factorial::<Minfo17>::new(17);\n        ///\n        /// for i in 0..17 {\n        ///     assert_eq!(fact[i] * fact.inverted(i), Mint17::one());\n        /// }\n        /// ```\n        ///\n        /// [`implementations`]: #implementations\n        ///\n        pub fn inverted(&self, i: usize) -> Mint<Mod> {\n            self.inverted[i]\n        }\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo, I: std::slice::SliceIndex<[Mint<Mod>]>> std::ops::Index<I> for Factorial<Mod> {\n        type Output = I::Output;\n\n        /// Index でも取ることができます。\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, Factorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// let fact = Factorial::<Minfo17>::new(17);\n        ///\n        /// assert_eq!(fact[0], Mint17::from_value(1));\n        /// assert_eq!(fact[1], Mint17::from_value(1));\n        /// assert_eq!(fact[2], Mint17::from_value(2));\n        /// assert_eq!(fact[3], Mint17::from_value(6));\n        /// assert_eq!(fact[4], Mint17::from_value(24 % 17));\n        /// assert_eq!(fact[5], Mint17::from_value(120 % 17));\n        /// ```\n        #[inline]\n        fn index(&self, index: I) -> &Self::Output {\n            &self.normal[index]\n        }\n    }\n\n    /// 二重階乗とその逆元を前計算するマシーンです。\n    #[allow(dead_code)]\n    pub struct DoubleFactorial<Mod: Minfo> {\n        normal: Vec<Mint<Mod>>,\n        inverted: Vec<Mint<Mod>>,\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo> DoubleFactorial<Mod>\n    where\n        Mod::Value: std::convert::TryFrom<usize, Error = std::num::TryFromIntError>,\n    {\n        /// サイズを指定して初期化です。\n        /// 最大値は一つ小さくなりますから、注意です。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, DoubleFactorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        /// let fact = DoubleFactorial::<Minfo17>::new(16);\n        /// ```\n        pub fn new(n: usize) -> Self {\n            use std::convert::TryFrom;\n            let mut normal = vec![Mint::one(); n];\n            for i in 2..n {\n                normal[i] = normal[i - 2] * Mint::from_value(Mod::Value::try_from(i).unwrap());\n            }\n            let mut inverted = vec![Mint::one(); n];\n            inverted[n - 1] = normal[n - 1].inv();\n            inverted[n - 2] = normal[n - 2].inv();\n            for i in (2..n).rev() {\n                inverted[i - 2] = inverted[i] * Mint::from_value(Mod::Value::try_from(i).unwrap());\n            }\n            Self { normal, inverted }\n        }\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo> DoubleFactorial<Mod> {\n        /// 二重階乗の逆元を取得します。\n        ///\n        /// 逆元でなくて普通の二重階乗は、[`implementations`] をご覧いただけると幸いです。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, DoubleFactorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// let fact = DoubleFactorial::<Minfo17>::new(17);\n        ///\n        /// for i in 0..17 {\n        ///     assert_eq!(fact[i] * fact.inverted(i), Mint17::one());\n        /// }\n        /// ```\n        ///\n        /// [`implementations`]: #implementations\n        ///\n        pub fn inverted(&self, i: usize) -> Mint<Mod> {\n            self.inverted[i]\n        }\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo, I: std::slice::SliceIndex<[Mint<Mod>]>> std::ops::Index<I>\n        for DoubleFactorial<Mod>\n    {\n        type Output = I::Output;\n\n        /// Index でも取ることができます。\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, DoubleFactorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// let fact = DoubleFactorial::<Minfo17>::new(17);\n        ///\n        /// assert_eq!(fact[0], Mint17::from_value(1));\n        /// assert_eq!(fact[1], Mint17::from_value(1));\n        /// assert_eq!(fact[2], Mint17::from_value(2));\n        /// assert_eq!(fact[3], Mint17::from_value(3));\n        /// assert_eq!(fact[4], Mint17::from_value(8));\n        /// assert_eq!(fact[5], Mint17::from_value(15));\n        /// ```\n        #[inline]\n        fn index(&self, index: I) -> &Self::Output {\n            &self.normal[index]\n        }\n    }\n\n    /// Mint 型を定義するためのマクロです。\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use modint::{define_mint, Minfo, Mint};\n    ///\n    /// define_mint! {\n    ///     struct Mint17(Minfo17(17; i64));\n    /// }\n    ///\n    /// let x = Mint17::from_value(1);\n    /// let y = Mint17::from_value(2);\n    /// let z = x / y;\n    /// assert_eq!(z.value(), 9);\n    /// ```\n    #[macro_export]\n    macro_rules! define_mint {\n        (\n        struct $modint: ident ($modinfo: ident ($modvalue: expr; $modty: ty));\n    ) => {\n            #[allow(dead_code)]\n            #[derive(Clone, Copy, Debug)]\n            pub struct $modinfo {}\n            impl Minfo for $modinfo {\n                type Value = $modty;\n                fn modulus() -> Self::Value {\n                    $modvalue\n                }\n                fn zero() -> Self::Value {\n                    0\n                }\n                fn one() -> Self::Value {\n                    1\n                }\n            }\n            type $modint = Mint<$modinfo>;\n        };\n    }\n\n    /// Mod = 1000000007 なる Minfo です。\n    #[allow(dead_code)]\n    #[derive(Clone, Copy, Debug)]\n    pub struct Minfo1000000007 {}\n\n    impl Minfo for Minfo1000000007 {\n        type Value = i64;\n        fn modulus() -> Self::Value {\n            1_000_000_007\n        }\n        fn zero() -> Self::Value {\n            0\n        }\n        fn one() -> Self::Value {\n            1\n        }\n    }\n\n    /// Mod = 1000000007 なる Mint です。\n    #[allow(dead_code)]\n    pub type Mint1000000007 = Mint<Minfo1000000007>;\n\n    /// Mod = 998244353 なる Minfo です。\n    #[allow(dead_code)]\n    #[derive(Clone, Copy, Debug)]\n    pub struct Minfo998244353 {}\n\n    impl Minfo for Minfo998244353 {\n        type Value = i64;\n        fn modulus() -> Self::Value {\n            998_244_353\n        }\n        fn zero() -> Self::Value {\n            0\n        }\n        fn one() -> Self::Value {\n            1\n        }\n    }\n\n    /// Mod = 998244353 なる Mint です。\n    #[allow(dead_code)]\n    pub type Mint998244353 = Mint<Minfo998244353>;\n}\n//}}}\n\ntype Mint = modint::Mint1000000007;\n\nfn main() {\n    input!(n: usize, mut s: Chars);\n    s.reverse();\n    let make = |x: Mint| -> Vec<(Mint, Mint)> {\n        let mut ans = vec![(Mint::one(), Mint::zero()); n + 1];\n        for (i, &c) in s.iter().enumerate() {\n            let (a, b) = ans[i];\n            ans[i + 1] = match c {\n                '+' => (a, b + Mint::one()),\n                '-' => (a, b - Mint::one()),\n                '<' => (a * x, b * x),\n                '>' => (a / x, b / x),\n                _ => panic!(),\n            }\n        }\n        ans\n    };\n\n    let keys: Vec<_> = vec![\n        12534251,\n        141236,\n        5374676127,\n        865375627,\n        856738654763,\n        236542672547,\n    ]\n    .into_iter()\n    .map(Mint::from_value)\n    .collect();\n    let seqs: Vec<_> = keys.iter().copied().map(make).collect();\n    let mut btree_map = std::collections::BTreeMap::<Vec<_>, _>::new();\n    let mut ans = 0;\n    for i in 0..=n {\n        if let Some(x) = btree_map.get(\n            &(0..keys.len())\n                .map(|j| {\n                    let (a, b) = seqs[j][i];\n                    ((b - seqs[j][n].1) / a).value()\n                })\n                .collect::<Vec<_>>(),\n        ) {\n            ans += x;\n        }\n        *btree_map\n            .entry(\n                (0..keys.len())\n                    .map(|j| {\n                        let (a, b) = seqs[j][i];\n                        (b / a).value()\n                    })\n                    .collect(),\n            )\n            .or_insert(0) += 1;\n    }\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::Read;\n#[allow(dead_code)]\nfn getline() -> String {\n    let mut ret = String::new();\n    std::io::stdin().read_line(&mut ret).ok().unwrap();\n    ret\n}\nfn get_word() -> String {\n    let mut stdin = std::io::stdin();\n    let mut u8b: [u8; 1] = [0];\n    loop {\n        let mut buf: Vec<u8> = Vec::with_capacity(16);\n        loop {\n            let res = stdin.read(&mut u8b);\n            if res.unwrap_or(0) == 0 || u8b[0] <= b' ' {\n                break;\n            } else {\n                buf.push(u8b[0]);\n            }\n        }\n        if buf.len() >= 1 {\n            let ret = String::from_utf8(buf).unwrap();\n            return ret;\n        }\n    }\n}\n\n#[allow(dead_code)]\nfn get<T: std::str::FromStr>() -> T { get_word().parse().ok().unwrap() }\n\nconst MOD: i64 = 1_000_000_007;\n\n/// Refers external ::MOD.\nmod mod_int {\n    use ::MOD;\n    use std::ops::*;\n    #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]\n    pub struct ModInt {\n        pub x: i64,\n    }\n    impl ModInt {\n        fn check_integrity(self) {\n            debug_assert!(self.x >= 0);\n            debug_assert!(self.x < MOD);\n        }\n        pub fn new(x: i64) -> Self { ModInt { x: x % MOD } }\n        #[allow(dead_code)]\n        pub fn mul_fast(self, other: Self) -> Self {\n            self.check_integrity();\n            other.check_integrity();\n            Self::new(self.x * other.x % MOD)\n        }\n        #[allow(dead_code)]\n        pub fn mul_slow(self, other: Self) -> Self {\n            // Naive multiplication in order to avoid overflow\n            self.check_integrity();\n            other.check_integrity();\n            let mut sum = 0;\n            let mut cur = self.x;\n            let mut e = other.x;\n            if self.x < other.x {\n                cur = other.x;\n                e = self.x;\n            }\n            while e > 0 {\n                if e % 2 == 1 {\n                    sum += cur;\n                    if sum >= MOD {\n                        sum -= MOD;\n                    }\n                }\n                cur *= 2;\n                if cur >= MOD {\n                    cur -= MOD;\n                }\n                e /= 2;\n            }\n            Self::new(sum)\n        }\n        pub fn pow(self, mut e: i64) -> Self {\n            self.check_integrity();\n            let mut sum = ModInt::new(1);\n            let mut cur = ModInt::new(self.x);\n            while e > 0 {\n                if e % 2 != 0 {\n                    sum = sum * cur;\n                }\n                cur = cur * cur;\n                e /= 2;\n            }\n            sum\n        }\n        pub fn inv(self) -> Self {\n            self.pow(MOD - 2)\n        }\n    }\n    impl Add for ModInt {\n        type Output = Self;\n        fn add(self, other: Self) -> Self {\n            self.check_integrity();\n            other.check_integrity();\n            let mut sum = self.x + other.x;\n            if sum >= MOD {\n                sum -= MOD;\n            }\n            Self::new(sum)\n        }\n    }\n    impl Sub for ModInt {\n        type Output = Self;\n        fn sub(self, other: Self) -> Self {\n            self.check_integrity();\n            other.check_integrity();\n            let mut sum = self.x - other.x;\n            if sum < 0 {\n                sum += MOD;\n            }\n            Self::new(sum)\n        }\n    }\n    impl Mul for ModInt {\n        type Output = Self;\n        fn mul(self, other: Self) -> Self {\n            self.mul_fast(other)\n        }\n    }\n} // mod mod_int\n\n\nfn solve() {\n    use mod_int::*;\n    let n: usize = get();\n    let s: Vec<_> = get_word().chars().collect();\n    const A: usize = 6;\n    let b = [ModInt::new(41), ModInt::new(255), ModInt::new(36),\n             ModInt::new(17), ModInt::new(101), ModInt::new(1524526)];\n    let mut hsh = vec![vec![ModInt::new(0); n + 1]; A];\n    let mut inv = [ModInt::new(0); A];\n    for i in 0 .. A { inv[i] = b[i].inv(); }\n    let mut pos = vec![0; n + 1];\n    for c in 0 .. A {\n        let mut p = 0;\n        let mut cur = ModInt::new(1);\n        for (i, &ch) in s.iter().enumerate() {\n            let mut tmp = hsh[c][i];\n            match ch {\n                '>' => {\n                    p += 1;\n                    cur = cur * b[c];\n                },\n                '<' => {\n                    p -= 1;\n                    cur = cur * inv[c];\n                },\n                '+' => tmp = tmp + cur,\n                '-' => tmp = tmp - cur,\n                _ => panic!(),\n            }\n            hsh[c][i + 1] = tmp;\n            pos[i + 1] = p;\n        }\n    }\n    let mut meguru = [ModInt::new(0); A];\n    for c in 0 .. A { meguru[c] = hsh[c][n]; }\n    let mut kirika = HashMap::new();\n    kirika.insert(meguru, 1);\n    let mut tot = 0i64;\n    for i in (0 .. n).rev() {\n        let mut cur = [ModInt::new(0); A];\n        for c in 0 .. A { cur[c] = b[c].pow(MOD - 1 + pos[i]); }\n        let mut ken = [ModInt::new(0); A];\n        for c in 0 .. A { ken[c] = cur[c] * meguru[c] + hsh[c][i]; }\n        tot += kirika.get(&ken).cloned().unwrap_or(0);\n        let mut tt = [ModInt::new(0); A];\n        for c in 0 .. A { tt[c] = hsh[c][i]; }\n        *kirika.entry(tt).or_insert(0) += 1;\n    }\n    println!(\"{}\", tot);\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "use proconio::{input, marker::Chars};\n\n// modint{{{\nmod modint {\n    //! [`Mint`] 型を提供します。\n    //!\n    //! [`Mint`]: struct.Mint.html\n\n    /// [`Mint`] の中に入れる数値型が実装していないといけないトレイトをまとめました。\n    ///\n    /// どうやら普通の符号付き整数型ならば大丈夫そうですね。\n    ///\n    /// いかがでしたでしょうか？（真顔）\n    ///\n    /// [`Mint`]: struct.Mint.html\n    pub trait ModValue:\n        std::ops::Add<Output = Self>\n        + std::ops::Sub<Output = Self>\n        + std::ops::Mul<Output = Self>\n        + std::ops::Div<Output = Self>\n        + std::ops::Rem<Output = Self>\n        + std::ops::AddAssign\n        + std::ops::SubAssign\n        + std::ops::MulAssign\n        + std::ops::DivAssign\n        + std::ops::RemAssign\n        + std::ops::Neg\n        + std::cmp::Ord\n        + Clone\n        + Copy\n        + Sized\n        + std::fmt::Debug\n        + std::fmt::Display\n    {\n    }\n\n    impl<\n            Value: std::ops::Add<Output = Self>\n                + std::ops::Sub<Output = Self>\n                + std::ops::Mul<Output = Self>\n                + std::ops::Div<Output = Self>\n                + std::ops::Rem<Output = Self>\n                + std::ops::AddAssign\n                + std::ops::SubAssign\n                + std::ops::MulAssign\n                + std::ops::DivAssign\n                + std::ops::RemAssign\n                + std::ops::Neg\n                + std::cmp::Ord\n                + Clone\n                + Copy\n                + Sized\n                + std::fmt::Debug\n                + std::fmt::Display,\n        > ModValue for Value\n    {\n    }\n\n    /// mod に関数情報を [`Mint`] に伝えるための型引数だッピ！\n    ///\n    /// [`Mint`]: struct.Mint.html\n    pub trait Minfo: Clone + Copy + std::fmt::Debug {\n        /// 中身の型です。\n        type Value: ModValue;\n\n        /// mod の値を返します。\n        fn modulus() -> Self::Value;\n\n        /// 0 を返します。\n        fn zero() -> Self::Value;\n\n        /// 1 を返します。\n        fn one() -> Self::Value;\n    }\n\n    /// 自動で mod を取ってくれる整数型です。\n    ///\n    /// 型引数は、トレイト [`Minfo`] を実装している必要があります。\n    ///\n    /// # Examples\n    ///\n    /// [`from_value`] によって、`Mint<Mod>` が作れます。\n    /// 逆に、[`value`] によって、中身がとれます。\n    ///\n    /// ```\n    /// use modint::Mint1000000007;\n    /// type Mint = Mint1000000007;\n    ///\n    /// let x: Mint = Mint::from_value(2);\n    ///\n    /// assert_eq!(x.value(), 2);\n    /// ```\n    ///\n    /// 四則演算ができます。\n    ///\n    /// ```\n    /// use modint::Mint1000000007;\n    /// type Mint = Mint1000000007;\n    ///\n    /// let x: Mint = Mint::from_value(6);\n    /// let y: Mint = Mint::from_value(2);\n    ///\n    /// assert_eq!((x + y).value(), 8);\n    /// assert_eq!((x - y).value(), 4);\n    /// assert_eq!((x * y).value(), 12);\n    /// assert_eq!((x / y).value(), 3);\n    /// ```\n    ///\n    /// [`value`]: #method.value\n    /// [`from_value`]: #method.from_value\n    /// [`Minfo`]:trait.Minfo.html\n\n    #[derive(Clone, Copy, Debug)]\n    pub struct Mint<Mod: Minfo>(Mod::Value);\n\n    impl<Mod: Minfo> Mint<Mod> {\n        #[inline]\n        #[allow(dead_code)]\n        fn is_within_the_range(x: Mod::Value) -> bool {\n            Mod::zero() <= x && x < Mod::modulus()\n        }\n\n        #[inline]\n        #[allow(dead_code)]\n        fn normalize(x: Mod::Value) -> Mod::Value {\n            if Self::is_within_the_range(x) {\n                x\n            } else {\n                let x = x % Mod::modulus();\n                if x < Mod::zero() {\n                    x + Mod::modulus()\n                } else {\n                    x\n                }\n            }\n        }\n\n        /// 0 を構築します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::zero();\n        /// assert_eq!(x.value(), 0);\n        /// ```\n        #[allow(dead_code)]\n        pub fn zero() -> Self {\n            Self(Mod::zero())\n        }\n\n        /// 1 を構築します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::one();\n        /// assert_eq!(x.value(), 1);\n        /// ```\n        #[allow(dead_code)]\n        pub fn one() -> Self {\n            Self(Mod::one())\n        }\n\n        /// mod を取得します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::modulus();\n        /// assert_eq!(x, 998244353);\n        /// ```\n        #[allow(dead_code)]\n        pub fn modulus() -> Mod::Value {\n            Mod::modulus()\n        }\n\n        /// 0 であるときに `true` を返します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::zero();\n        /// assert!(x.is_zero());\n        ///\n        /// let x = Mint::one();\n        /// assert!(!x.is_zero());\n        /// ```\n        #[allow(dead_code)]\n        pub fn is_zero(&self) -> bool {\n            self.value() == Mod::zero()\n        }\n\n        /// 構築します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::from_value(4);\n        /// ```\n        #[allow(dead_code)]\n        pub fn from_value(x: Mod::Value) -> Self {\n            Self(Self::normalize(x))\n        }\n\n        /// 中身を取得します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::from_value(4);\n        /// assert_eq!(x.value(), 4);\n        /// ```\n        #[allow(dead_code)]\n        pub fn value(&self) -> Mod::Value {\n            self.0\n        }\n\n        /// mod 逆元を計算します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::from_value(2);\n        /// assert_eq!(x.inv().value(), 499122177);\n        /// ```\n        #[allow(dead_code)]\n        pub fn inv(&self) -> Self {\n            if self.is_zero() {\n                panic!(\"inv(0)\");\n            }\n            Self(Self::raw_inv(self.value()))\n        }\n\n        /// ユークリッドの互除法を用いて、pow を計算します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// let x = Mint17::from_value(2);\n        /// assert_eq!(x.pow(6).value(), 64 % 17);\n        /// ```\n        #[allow(dead_code)]\n        pub fn pow(&self, b: u64) -> Self {\n            Self(Self::raw_pow(self.value(), b))\n        }\n\n        fn raw_add(x: Mod::Value, y: Mod::Value) -> Mod::Value {\n            let z = x + y;\n            if Mod::modulus() <= z {\n                z - Mod::modulus()\n            } else {\n                z\n            }\n        }\n\n        fn raw_sub(x: Mod::Value, y: Mod::Value) -> Mod::Value {\n            let z = x - y;\n            if z < Mod::zero() {\n                z + Mod::modulus()\n            } else {\n                z\n            }\n        }\n\n        fn raw_neg(x: Mod::Value) -> Mod::Value {\n            if x == Mod::zero() {\n                Mod::zero()\n            } else {\n                Mod::modulus() - x\n            }\n        }\n\n        fn raw_mul(x: Mod::Value, y: Mod::Value) -> Mod::Value {\n            x * y % Mod::modulus()\n        }\n\n        fn raw_div(x: Mod::Value, y: Mod::Value) -> Mod::Value {\n            Self::raw_mul(x, Self::raw_inv(y))\n        }\n\n        #[allow(clippy::many_single_char_names)]\n        fn raw_inv(mut x: Mod::Value) -> Mod::Value {\n            let mut y = Mod::modulus();\n            let mut u = Mod::one();\n            let mut v = Mod::zero();\n            while x != Mod::zero() {\n                let q = y / x;\n                y -= x * q;\n                v -= u * q;\n                std::mem::swap(&mut x, &mut y);\n                std::mem::swap(&mut u, &mut v);\n            }\n            Self::normalize(v)\n        }\n\n        fn raw_pow(mut a: Mod::Value, mut b: u64) -> Mod::Value {\n            let mut x = Mod::one();\n            while 0 < b {\n                if b % 2 == 1 {\n                    x = Self::raw_mul(x, a);\n                }\n                a = Self::raw_mul(a, a);\n                b /= 2\n            }\n            x\n        }\n    }\n\n    macro_rules! impl_biop {\n    (\n        $(\n            $biop_trait: ident::$biop_fn: ident,\n            $biop_assign_trait: ident::$biop_assign_fn: ident,\n            $biop_impl: ident;\n        )*\n    ) => {\n        $(\n            impl<Mod: Minfo> std::ops::$biop_trait for Mint<Mod> {\n                type Output = Self;\n                fn $biop_fn(self, rhs: Self) -> Self::Output {\n                    Mint(Self::$biop_impl(self.value(), rhs.value()))\n                }\n            }\n            impl<Mod: Minfo> std::ops::$biop_assign_trait for Mint<Mod>\n            where\n                Self: Copy\n            {\n                fn $biop_assign_fn(&mut self, rhs: Self) {\n                    use std::ops::$biop_trait;\n                    *self = Mint::$biop_fn(*self, rhs)\n                }\n            }\n        )*\n    };\n}\n\n    impl_biop! {\n        Add::add, AddAssign::add_assign, raw_add;\n        Sub::sub, SubAssign::sub_assign, raw_sub;\n        Mul::mul, MulAssign::mul_assign, raw_mul;\n        Div::div, DivAssign::div_assign, raw_div;\n    }\n\n    impl<Mod: Minfo> std::ops::Neg for Mint<Mod> {\n        type Output = Self;\n        fn neg(self) -> Self::Output {\n            Self(Self::raw_neg(self.value()))\n        }\n    }\n\n    impl<Mod: Minfo> std::cmp::PartialEq for Mint<Mod> {\n        /// 中身をそのまま 比較です。\n        /// 構築時に normalize され、それ以降も normalized な状態に保たれますから、\n        /// 結局あまりを比較しているのと同じことになります。\n        ///\n        /// # Example\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// assert_eq!(Mint17::from_value(3), Mint::from_value(-31));\n        /// assert_eq!(Mint17::from_value(3), Mint::from_value(-14));\n        /// assert_eq!(Mint17::from_value(3), Mint::from_value(3));\n        /// assert_eq!(Mint17::from_value(3), Mint::from_value(20));\n        /// assert_eq!(Mint17::from_value(3), Mint::from_value(37));\n        ///\n        /// assert_ne!(Mint17::from_value(3), Mint::from_value(31));\n        /// assert_ne!(Mint17::from_value(3), Mint::from_value(14));\n        /// assert_ne!(Mint17::from_value(3), Mint::from_value(-3));\n        /// assert_ne!(Mint17::from_value(3), Mint::from_value(-20));\n        /// assert_ne!(Mint17::from_value(3), Mint::from_value(-37));\n        /// ```\n        fn eq(&self, other: &Self) -> bool {\n            self.value().eq(&other.value())\n        }\n    }\n    impl<Mod: Minfo> std::cmp::Eq for Mint<Mod> {}\n\n    impl<Mod: Minfo> std::fmt::Display for Mint<Mod> {\n        /// 中身をそのまま Display です。\n        ///\n        /// # Example\n        ///\n        /// ```\n        /// println!(\"{}\", modint::Mint998244353::from_value(42));\n        /// ```\n        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n            write!(f, \"{}\", self.value())\n        }\n    }\n\n    impl<Mod: Minfo> std::iter::Sum<Self> for Mint<Mod> {\n        /// 総和を取ります。\n        ///\n        /// # Example\n        ///\n        /// ```\n        /// use modint::{define_mint, Minfo, Mint};\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        /// assert_eq!(\n        ///     vec![\n        ///         Mint17::from_value(2),\n        ///         Mint17::from_value(4),\n        ///         Mint17::from_value(6),\n        ///         Mint17::from_value(8),\n        ///     ]\n        ///     .into_iter()\n        ///     .sum::<Mint17>(),\n        ///     Mint17::from_value(3)\n        /// );\n        /// ```\n        fn sum<I: Iterator<Item = Self>>(iter: I) -> Self {\n            iter.fold(Mint::zero(), |acc, x| acc + x)\n        }\n    }\n\n    impl<Mod: Minfo> std::iter::Product<Self> for Mint<Mod> {\n        /// 総積を取ります。\n        ///\n        /// # Example\n        ///\n        /// ```\n        /// use modint::{define_mint, Minfo, Mint};\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        /// assert_eq!(\n        ///     vec![\n        ///         Mint17::from_value(1),\n        ///         Mint17::from_value(2),\n        ///         Mint17::from_value(3),\n        ///         Mint17::from_value(4),\n        ///     ]\n        ///     .into_iter()\n        ///     .product::<Mint17>(),\n        ///     Mint17::from_value(7)\n        /// );\n        /// ```\n        fn product<I: Iterator<Item = Self>>(iter: I) -> Self {\n            iter.fold(Mint::one(), |acc, x| acc * x)\n        }\n    }\n\n    /// 階乗とその逆元を前計算するマシーンです。\n    #[allow(dead_code)]\n    pub struct Factorial<Mod: Minfo> {\n        normal: Vec<Mint<Mod>>,\n        inverted: Vec<Mint<Mod>>,\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo> Factorial<Mod>\n    where\n        Mod::Value: std::convert::TryFrom<usize, Error = std::num::TryFromIntError>,\n    {\n        /// サイズを指定して初期化です。\n        /// 最大値は一つ小さくなりますから、注意です。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, Factorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        /// let fact = Factorial::<Minfo17>::new(16);\n        /// ```\n        pub fn new(n: usize) -> Self {\n            use std::convert::TryFrom;\n            let mut normal = vec![Mint::one(); n];\n            for i in 1..n {\n                normal[i] = normal[i - 1] * Mint::from_value(Mod::Value::try_from(i).unwrap());\n            }\n            let mut inverted = vec![Mint::one(); n];\n            inverted[n - 1] = normal[n - 1].inv();\n            for i in (1..n).rev() {\n                inverted[i - 1] = inverted[i] * Mint::from_value(Mod::Value::try_from(i).unwrap());\n            }\n            Self { normal, inverted }\n        }\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo> Factorial<Mod> {\n        /// 階乗の逆元を取得します。\n        ///\n        /// 逆元でなくて普通の階乗は、[`implementations`] をご覧いただけると幸いです。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, Factorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// let fact = Factorial::<Minfo17>::new(17);\n        ///\n        /// for i in 0..17 {\n        ///     assert_eq!(fact[i] * fact.inverted(i), Mint17::one());\n        /// }\n        /// ```\n        ///\n        /// [`implementations`]: #implementations\n        ///\n        pub fn inverted(&self, i: usize) -> Mint<Mod> {\n            self.inverted[i]\n        }\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo, I: std::slice::SliceIndex<[Mint<Mod>]>> std::ops::Index<I> for Factorial<Mod> {\n        type Output = I::Output;\n\n        /// Index でも取ることができます。\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, Factorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// let fact = Factorial::<Minfo17>::new(17);\n        ///\n        /// assert_eq!(fact[0], Mint17::from_value(1));\n        /// assert_eq!(fact[1], Mint17::from_value(1));\n        /// assert_eq!(fact[2], Mint17::from_value(2));\n        /// assert_eq!(fact[3], Mint17::from_value(6));\n        /// assert_eq!(fact[4], Mint17::from_value(24 % 17));\n        /// assert_eq!(fact[5], Mint17::from_value(120 % 17));\n        /// ```\n        #[inline]\n        fn index(&self, index: I) -> &Self::Output {\n            &self.normal[index]\n        }\n    }\n\n    /// 二重階乗とその逆元を前計算するマシーンです。\n    #[allow(dead_code)]\n    pub struct DoubleFactorial<Mod: Minfo> {\n        normal: Vec<Mint<Mod>>,\n        inverted: Vec<Mint<Mod>>,\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo> DoubleFactorial<Mod>\n    where\n        Mod::Value: std::convert::TryFrom<usize, Error = std::num::TryFromIntError>,\n    {\n        /// サイズを指定して初期化です。\n        /// 最大値は一つ小さくなりますから、注意です。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, DoubleFactorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        /// let fact = DoubleFactorial::<Minfo17>::new(16);\n        /// ```\n        pub fn new(n: usize) -> Self {\n            use std::convert::TryFrom;\n            let mut normal = vec![Mint::one(); n];\n            for i in 2..n {\n                normal[i] = normal[i - 2] * Mint::from_value(Mod::Value::try_from(i).unwrap());\n            }\n            let mut inverted = vec![Mint::one(); n];\n            inverted[n - 1] = normal[n - 1].inv();\n            inverted[n - 2] = normal[n - 2].inv();\n            for i in (2..n).rev() {\n                inverted[i - 2] = inverted[i] * Mint::from_value(Mod::Value::try_from(i).unwrap());\n            }\n            Self { normal, inverted }\n        }\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo> DoubleFactorial<Mod> {\n        /// 二重階乗の逆元を取得します。\n        ///\n        /// 逆元でなくて普通の二重階乗は、[`implementations`] をご覧いただけると幸いです。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, DoubleFactorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// let fact = DoubleFactorial::<Minfo17>::new(17);\n        ///\n        /// for i in 0..17 {\n        ///     assert_eq!(fact[i] * fact.inverted(i), Mint17::one());\n        /// }\n        /// ```\n        ///\n        /// [`implementations`]: #implementations\n        ///\n        pub fn inverted(&self, i: usize) -> Mint<Mod> {\n            self.inverted[i]\n        }\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo, I: std::slice::SliceIndex<[Mint<Mod>]>> std::ops::Index<I>\n        for DoubleFactorial<Mod>\n    {\n        type Output = I::Output;\n\n        /// Index でも取ることができます。\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, DoubleFactorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// let fact = DoubleFactorial::<Minfo17>::new(17);\n        ///\n        /// assert_eq!(fact[0], Mint17::from_value(1));\n        /// assert_eq!(fact[1], Mint17::from_value(1));\n        /// assert_eq!(fact[2], Mint17::from_value(2));\n        /// assert_eq!(fact[3], Mint17::from_value(3));\n        /// assert_eq!(fact[4], Mint17::from_value(8));\n        /// assert_eq!(fact[5], Mint17::from_value(15));\n        /// ```\n        #[inline]\n        fn index(&self, index: I) -> &Self::Output {\n            &self.normal[index]\n        }\n    }\n\n    /// Mint 型を定義するためのマクロです。\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use modint::{define_mint, Minfo, Mint};\n    ///\n    /// define_mint! {\n    ///     struct Mint17(Minfo17(17; i64));\n    /// }\n    ///\n    /// let x = Mint17::from_value(1);\n    /// let y = Mint17::from_value(2);\n    /// let z = x / y;\n    /// assert_eq!(z.value(), 9);\n    /// ```\n    #[macro_export]\n    macro_rules! define_mint {\n        (\n        struct $modint: ident ($modinfo: ident ($modvalue: expr; $modty: ty));\n    ) => {\n            #[allow(dead_code)]\n            #[derive(Clone, Copy, Debug)]\n            pub struct $modinfo {}\n            impl Minfo for $modinfo {\n                type Value = $modty;\n                fn modulus() -> Self::Value {\n                    $modvalue\n                }\n                fn zero() -> Self::Value {\n                    0\n                }\n                fn one() -> Self::Value {\n                    1\n                }\n            }\n            type $modint = Mint<$modinfo>;\n        };\n    }\n\n    /// Mod = 1000000007 なる Minfo です。\n    #[allow(dead_code)]\n    #[derive(Clone, Copy, Debug)]\n    pub struct Minfo1000000007 {}\n\n    impl Minfo for Minfo1000000007 {\n        type Value = i64;\n        fn modulus() -> Self::Value {\n            1_000_000_007\n        }\n        fn zero() -> Self::Value {\n            0\n        }\n        fn one() -> Self::Value {\n            1\n        }\n    }\n\n    /// Mod = 1000000007 なる Mint です。\n    #[allow(dead_code)]\n    pub type Mint1000000007 = Mint<Minfo1000000007>;\n\n    /// Mod = 998244353 なる Minfo です。\n    #[allow(dead_code)]\n    #[derive(Clone, Copy, Debug)]\n    pub struct Minfo998244353 {}\n\n    impl Minfo for Minfo998244353 {\n        type Value = i64;\n        fn modulus() -> Self::Value {\n            998_244_353\n        }\n        fn zero() -> Self::Value {\n            0\n        }\n        fn one() -> Self::Value {\n            1\n        }\n    }\n\n    /// Mod = 998244353 なる Mint です。\n    #[allow(dead_code)]\n    pub type Mint998244353 = Mint<Minfo998244353>;\n}\n//}}}\n\ntype Mint = modint::Mint998244353;\n\nfn main() {\n    input!(n: usize, mut s: Chars);\n    s.reverse();\n    let make = |x: Mint| -> Vec<(Mint, Mint)> {\n        let xinv = x.inv();\n        let mut ans = vec![(Mint::one(), Mint::zero()); n + 1];\n        for (i, &c) in s.iter().enumerate() {\n            let (a, b) = ans[i];\n            ans[i + 1] = match c {\n                '+' => (a, b + Mint::one()),\n                '-' => (a, b - Mint::one()),\n                '<' => (a * x, b * x),\n                '>' => (a * xinv, b * xinv),\n                _ => panic!(),\n            }\n        }\n        ans\n    };\n\n    let keys: Vec<_> = (1..6)\n        .map(|i| i * 10_000_000)\n        .map(Mint::from_value)\n        .collect();\n    let seqs: Vec<_> = keys.iter().copied().map(make).collect();\n    let mut hash_map = std::collections::HashMap::<Vec<_>, _>::new();\n    let mut ans = 0;\n    for i in 0..=n {\n        if let Some(x) = hash_map.get(\n            &(0..keys.len())\n                .map(|j| {\n                    let (a, b) = seqs[j][i];\n                    if a.is_zero() {\n                        None\n                    } else {\n                        Some(((b - seqs[j][n].1) / a).value())\n                    }\n                })\n                .collect::<Vec<_>>(),\n        ) {\n            ans += x;\n        }\n        *hash_map\n            .entry(\n                (0..keys.len())\n                    .map(|j| {\n                        let (a, b) = seqs[j][i];\n                        if a.is_zero() {\n                            None\n                        } else {\n                            Some((b / a).value())\n                        }\n                    })\n                    .collect(),\n            )\n            .or_insert(0) += 1;\n    }\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::Read;\n#[allow(dead_code)]\nfn getline() -> String {\n    let mut ret = String::new();\n    std::io::stdin().read_line(&mut ret).ok().unwrap();\n    ret\n}\nfn get_word() -> String {\n    let mut stdin = std::io::stdin();\n    let mut u8b: [u8; 1] = [0];\n    loop {\n        let mut buf: Vec<u8> = Vec::with_capacity(16);\n        loop {\n            let res = stdin.read(&mut u8b);\n            if res.unwrap_or(0) == 0 || u8b[0] <= b' ' {\n                break;\n            } else {\n                buf.push(u8b[0]);\n            }\n        }\n        if buf.len() >= 1 {\n            let ret = String::from_utf8(buf).unwrap();\n            return ret;\n        }\n    }\n}\n\n#[allow(dead_code)]\nfn get<T: std::str::FromStr>() -> T { get_word().parse().ok().unwrap() }\n\nconst MOD: i64 = 1_000_000_007;\n\n/// Refers external ::MOD.\n/// Verified by: https://beta.atcoder.jp/contests/arc099/submissions/2893570\nmod mod_int {\n    use ::MOD;\n    use std::ops::*;\n    #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]\n    pub struct ModInt { pub x: i64 }\n    impl ModInt {\n        fn check_integrity(self) {\n            debug_assert!(self.x >= 0);\n            debug_assert!(self.x < MOD);\n        }\n        // x >= 0\n        pub fn new(x: i64) -> Self { ModInt { x: x % MOD } }\n        #[allow(dead_code)]\n        pub fn mul_fast(self, other: Self) -> Self {\n            self.check_integrity();\n            other.check_integrity();\n            ModInt { x: self.x * other.x % MOD }\n        }\n        #[allow(dead_code)]\n        pub fn mul_slow(self, other: Self) -> Self {\n            // Naive multiplication in order to avoid overflow\n            self.check_integrity();\n            other.check_integrity();\n            let mut sum = ModInt::new(0);\n            let mut cur = self;\n            let mut e = other.x;\n            if self.x < other.x {\n                cur = other;\n                e = self.x;\n            }\n            while e > 0 {\n                if e % 2 == 1 {\n                    sum = sum + cur;\n                }\n                cur = cur + cur;\n                e /= 2;\n            }\n            sum\n        }\n        pub fn pow(self, mut e: i64) -> Self {\n            self.check_integrity();\n            debug_assert!(e >= 0);\n            let mut sum = ModInt::new(1);\n            let mut cur = ModInt::new(self.x);\n            while e > 0 {\n                if e % 2 != 0 {\n                    sum = sum * cur;\n                }\n                cur = cur * cur;\n                e /= 2;\n            }\n            sum\n        }\n        pub fn inv(self) -> Self { self.pow(MOD - 2) }\n    }\n    impl Add for ModInt {\n        type Output = Self;\n        fn add(self, other: Self) -> Self {\n            self.check_integrity();\n            other.check_integrity();\n            let mut sum = self.x + other.x;\n            if sum >= MOD { sum -= MOD; }\n            ModInt { x: sum }\n        }\n    }\n    impl Sub for ModInt {\n        type Output = Self;\n        fn sub(self, other: Self) -> Self {\n            self.check_integrity();\n            other.check_integrity();\n            let mut sum = self.x - other.x;\n            if sum < 0 { sum += MOD; }\n            ModInt { x: sum }\n        }\n    }\n    impl Mul for ModInt {\n        type Output = Self;\n        fn mul(self, other: Self) -> Self {\n            self.mul_fast(other)\n        }\n    }\n} // mod mod_int\n\n\nfn solve() {\n    use mod_int::*;\n    let n: usize = get();\n    let s: Vec<_> = get_word().chars().collect();\n    const A: usize = 3;\n    let b = [ModInt::new(41), ModInt::new(255), ModInt::new(36)];\n    let mut hsh = vec![vec![ModInt::new(0); n + 1]; A];\n    let mut inv = [ModInt::new(0); A];\n    for i in 0 .. A { inv[i] = b[i].inv(); }\n    let mut pos = vec![0; n + 1];\n    for c in 0 .. A {\n        let mut p = 0;\n        let mut cur = ModInt::new(1);\n        for (i, &ch) in s.iter().enumerate() {\n            let mut tmp = hsh[c][i];\n            match ch {\n                '>' => {\n                    p += 1;\n                    cur = cur * b[c];\n                },\n                '<' => {\n                    p -= 1;\n                    cur = cur * inv[c];\n                },\n                '+' => tmp = tmp + cur,\n                '-' => tmp = tmp - cur,\n                _ => panic!(),\n            }\n            hsh[c][i + 1] = tmp;\n            pos[i + 1] = p;\n        }\n    }\n    let mut meguru = [ModInt::new(0); A];\n    for c in 0 .. A { meguru[c] = hsh[c][n]; }\n    let mut kirika = HashMap::new();\n    kirika.insert(meguru, 1);\n    let mut tot = 0i64;\n    for i in (0 .. n).rev() {\n        let mut cur = [ModInt::new(0); A];\n        for c in 0 .. A { cur[c] = b[c].pow(MOD - 1 + pos[i]); }\n        let mut ken = [ModInt::new(0); A];\n        for c in 0 .. A { ken[c] = cur[c] * meguru[c] + hsh[c][i]; }\n        tot += kirika.get(&ken).cloned().unwrap_or(0);\n        let mut tt = [ModInt::new(0); A];\n        for c in 0 .. A { tt[c] = hsh[c][i]; }\n        *kirika.entry(tt).or_insert(0) += 1;\n    }\n    println!(\"{}\", tot);\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::Read;\n#[allow(dead_code)]\nfn getline() -> String {\n    let mut ret = String::new();\n    std::io::stdin().read_line(&mut ret).ok().unwrap();\n    ret\n}\nfn get_word() -> String {\n    let mut stdin = std::io::stdin();\n    let mut u8b: [u8; 1] = [0];\n    loop {\n        let mut buf: Vec<u8> = Vec::with_capacity(16);\n        loop {\n            let res = stdin.read(&mut u8b);\n            if res.unwrap_or(0) == 0 || u8b[0] <= b' ' {\n                break;\n            } else {\n                buf.push(u8b[0]);\n            }\n        }\n        if buf.len() >= 1 {\n            let ret = String::from_utf8(buf).unwrap();\n            return ret;\n        }\n    }\n}\n\n#[allow(dead_code)]\nfn get<T: std::str::FromStr>() -> T { get_word().parse().ok().unwrap() }\n\nconst MOD: i64 = 1_000_000_007;\n\n/// Refers external ::MOD.\nmod mod_int {\n    use ::MOD;\n    use std::ops::*;\n    #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]\n    pub struct ModInt {\n        pub x: i64,\n    }\n    impl ModInt {\n        pub fn new(x: i64) -> Self { ModInt { x: x % MOD } }\n        #[allow(dead_code)]\n        pub fn mul_fast(self, other: Self) -> Self {\n            assert!(self.x >= 0);\n            assert!(other.x >= 0);\n            Self::new(self.x * other.x % MOD)\n        }\n        pub fn pow(self, mut e: i64) -> Self {\n            assert!(self.x >= 0);\n            assert!(e >= 0);\n            let mut sum = ModInt::new(1);\n            let mut cur = ModInt::new(self.x);\n            while e > 0 {\n                if e % 2 != 0 {\n                    sum = sum * cur;\n                }\n                cur = cur * cur;\n                e /= 2;\n            }\n            sum\n        }\n        pub fn inv(self) -> Self {\n            self.pow(MOD - 2)\n        }\n    }\n    impl Add for ModInt {\n        type Output = Self;\n        fn add(self, other: Self) -> Self {\n            assert!(self.x >= 0);\n            assert!(other.x >= 0);\n            let mut sum = self.x + other.x;\n            if sum >= MOD {\n                sum -= MOD;\n            }\n            Self::new(sum)\n        }\n    }\n    impl Sub for ModInt {\n        type Output = Self;\n        fn sub(self, other: Self) -> Self {\n            assert!(self.x >= 0);\n            assert!(other.x >= 0);\n            let mut sum = self.x - other.x;\n            if sum < 0 {\n                sum += MOD;\n            }\n            Self::new(sum)\n        }\n    }\n    impl Mul for ModInt {\n        type Output = Self;\n        fn mul(self, others: Self) -> Self {\n            self.mul_fast(others)\n        }\n    }\n} // mod mod_int\n\n\nfn solve() {\n    use mod_int::*;\n    let n: usize = get();\n    let s: Vec<_> = get_word().chars().collect();\n    const A: usize = 6;\n    let b = [ModInt::new(41), ModInt::new(255), ModInt::new(36),\n             ModInt::new(17), ModInt::new(101), ModInt::new(1524526)];\n    let mut hsh = vec![vec![ModInt::new(0); n + 1]; A];\n    let mut inv = [ModInt::new(0); A];\n    for i in 0 .. A { inv[i] = b[i].inv(); }\n    let mut pos = vec![0; n + 1];\n    for c in 0 .. A {\n        let mut p = 0;\n        let mut cur = ModInt::new(1);\n        for (i, &ch) in s.iter().enumerate() {\n            let mut tmp = hsh[c][i];\n            match ch {\n                '>' => {\n                    p += 1;\n                    cur = cur * b[c];\n                },\n                '<' => {\n                    p -= 1;\n                    cur = cur * inv[c];\n                },\n                '+' => tmp = tmp + cur,\n                '-' => tmp = tmp - cur,\n                _ => panic!(),\n            }\n            hsh[c][i + 1] = tmp;\n            pos[i + 1] = p;\n        }\n    }\n    let mut meguru = [ModInt::new(0); A];\n    for c in 0 .. A { meguru[c] = hsh[c][n]; }\n    let mut kirika = HashMap::new();\n    kirika.insert(meguru, 1);\n    let mut tot = 0i64;\n    for i in (0 .. n).rev() {\n        let mut cur = [ModInt::new(0); A];\n        for c in 0 .. A { cur[c] = b[c].pow(MOD - 1 + pos[i]); }\n        let mut ken = [ModInt::new(0); A];\n        for c in 0 .. A { ken[c] = cur[c] * meguru[c] + hsh[c][i]; }\n        tot += kirika.get(&ken).cloned().unwrap_or(0);\n        let mut tt = [ModInt::new(0); A];\n        for c in 0 .. A { tt[c] = hsh[c][i]; }\n        *kirika.entry(tt).or_insert(0) += 1;\n    }\n    println!(\"{}\", tot);\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::Read;\n#[allow(dead_code)]\nfn getline() -> String {\n    let mut ret = String::new();\n    std::io::stdin().read_line(&mut ret).ok().unwrap();\n    ret\n}\nfn get_word() -> String {\n    let mut stdin = std::io::stdin();\n    let mut u8b: [u8; 1] = [0];\n    loop {\n        let mut buf: Vec<u8> = Vec::with_capacity(16);\n        loop {\n            let res = stdin.read(&mut u8b);\n            if res.unwrap_or(0) == 0 || u8b[0] <= b' ' {\n                break;\n            } else {\n                buf.push(u8b[0]);\n            }\n        }\n        if buf.len() >= 1 {\n            let ret = String::from_utf8(buf).unwrap();\n            return ret;\n        }\n    }\n}\n\n#[allow(dead_code)]\nfn get<T: std::str::FromStr>() -> T { get_word().parse().ok().unwrap() }\n\nconst MOD: i64 = 1_000_000_007;\n\n/// Refers external ::MOD.\nmod mod_int {\n    use ::MOD;\n    use std::ops::*;\n    #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]\n    pub struct ModInt {\n        pub x: i64,\n    }\n    impl ModInt {\n        pub fn new(x: i64) -> Self { ModInt { x: x % MOD } }\n        #[allow(dead_code)]\n        pub fn mul_fast(self, others: Self) -> Self {\n            Self::new(self.x * others.x % MOD)\n        }\n        pub fn pow(self, mut e: i64) -> Self {\n            let mut sum = ModInt::new(1);\n            let mut cur = ModInt::new(self.x);\n            while e > 0 {\n                if e % 2 != 0 {\n                    sum = sum * cur;\n                }\n                cur = cur * cur;\n                e /= 2;\n            }\n            sum\n        }\n        pub fn inv(self) -> Self {\n            self.pow(MOD - 2)\n        }\n    }\n    impl Add for ModInt {\n        type Output = Self;\n        fn add(self, others: Self) -> Self {\n            let mut sum = self.x + others.x;\n            if sum >= MOD {\n                sum -= MOD;\n            }\n            Self::new(sum)\n        }\n    }\n    impl Sub for ModInt {\n        type Output = Self;\n        fn sub(self, others: Self) -> Self {\n            let mut sum = self.x - others.x;\n            if sum < 0 {\n                sum += MOD;\n            }\n            Self::new(sum)\n        }\n    }\n    impl Mul for ModInt {\n        type Output = Self;\n        fn mul(self, others: Self) -> Self {\n            self.mul_fast(others)\n        }\n    }\n} // mod mod_int\n\n\nfn solve() {\n    use mod_int::*;\n    let n: usize = get();\n    let s: Vec<_> = get_word().chars().collect();\n    const A: usize = 6;\n    let b = [ModInt::new(41), ModInt::new(255), ModInt::new(36),\n             ModInt::new(17), ModInt::new(101), ModInt::new(1524526)];\n    let mut hsh = vec![vec![ModInt::new(0); n + 1]; A];\n    let mut inv = [ModInt::new(0); A];\n    for i in 0 .. A { inv[i] = b[i].inv(); }\n    let mut pos = vec![0; n + 1];\n    for c in 0 .. A {\n        let mut p = 0;\n        let mut cur = ModInt::new(1);\n        for (i, &ch) in s.iter().enumerate() {\n            let mut tmp = hsh[c][i];\n            match ch {\n                '>' => {\n                    p += 1;\n                    cur = cur * b[c];\n                },\n                '<' => {\n                    p -= 1;\n                    cur = cur * inv[c];\n                },\n                '+' => tmp = tmp + cur,\n                '-' => tmp = tmp - cur,\n                _ => panic!(),\n            }\n            hsh[c][i + 1] = tmp;\n            pos[i + 1] = p;\n        }\n    }\n    let mut meguru = [ModInt::new(0); A];\n    for c in 0 .. A { meguru[c] = hsh[c][n]; }\n    let mut kirika = HashMap::new();\n    kirika.insert(meguru, 1);\n    let mut tot = 0;\n    for i in (0 .. n).rev() {\n        let mut cur = [ModInt::new(0); A];\n        for c in 0 .. A { cur[c] = b[c].pow(MOD - 1 + pos[i]); }\n        let mut ken = [ModInt::new(0); A];\n        for c in 0 .. A { ken[c] = cur[c] * meguru[c] + hsh[c][i]; }\n        tot += kirika.get(&ken).cloned().unwrap_or(0);\n        let mut tt = [ModInt::new(0); A];\n        for c in 0 .. A { tt[c] = hsh[c][i]; }\n        *kirika.entry(tt).or_insert(0) += 1;\n    }\n    println!(\"{}\", tot);\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "use proconio::{input, marker::Chars};\n\n// modint{{{\nmod modint {\n    //! [`Mint`] 型を提供します。\n    //!\n    //! [`Mint`]: struct.Mint.html\n\n    /// [`Mint`] の中に入れる数値型が実装していないといけないトレイトをまとめました。\n    ///\n    /// どうやら普通の符号付き整数型ならば大丈夫そうですね。\n    ///\n    /// いかがでしたでしょうか？（真顔）\n    ///\n    /// [`Mint`]: struct.Mint.html\n    pub trait ModValue:\n        std::ops::Add<Output = Self>\n        + std::ops::Sub<Output = Self>\n        + std::ops::Mul<Output = Self>\n        + std::ops::Div<Output = Self>\n        + std::ops::Rem<Output = Self>\n        + std::ops::AddAssign\n        + std::ops::SubAssign\n        + std::ops::MulAssign\n        + std::ops::DivAssign\n        + std::ops::RemAssign\n        + std::ops::Neg\n        + std::cmp::Ord\n        + Clone\n        + Copy\n        + Sized\n        + std::fmt::Debug\n        + std::fmt::Display\n    {\n    }\n\n    impl<\n            Value: std::ops::Add<Output = Self>\n                + std::ops::Sub<Output = Self>\n                + std::ops::Mul<Output = Self>\n                + std::ops::Div<Output = Self>\n                + std::ops::Rem<Output = Self>\n                + std::ops::AddAssign\n                + std::ops::SubAssign\n                + std::ops::MulAssign\n                + std::ops::DivAssign\n                + std::ops::RemAssign\n                + std::ops::Neg\n                + std::cmp::Ord\n                + Clone\n                + Copy\n                + Sized\n                + std::fmt::Debug\n                + std::fmt::Display,\n        > ModValue for Value\n    {\n    }\n\n    /// mod に関数情報を [`Mint`] に伝えるための型引数だッピ！\n    ///\n    /// [`Mint`]: struct.Mint.html\n    pub trait Minfo: Clone + Copy + std::fmt::Debug {\n        /// 中身の型です。\n        type Value: ModValue;\n\n        /// mod の値を返します。\n        fn modulus() -> Self::Value;\n\n        /// 0 を返します。\n        fn zero() -> Self::Value;\n\n        /// 1 を返します。\n        fn one() -> Self::Value;\n    }\n\n    /// 自動で mod を取ってくれる整数型です。\n    ///\n    /// 型引数は、トレイト [`Minfo`] を実装している必要があります。\n    ///\n    /// # Examples\n    ///\n    /// [`from_value`] によって、`Mint<Mod>` が作れます。\n    /// 逆に、[`value`] によって、中身がとれます。\n    ///\n    /// ```\n    /// use modint::Mint1000000007;\n    /// type Mint = Mint1000000007;\n    ///\n    /// let x: Mint = Mint::from_value(2);\n    ///\n    /// assert_eq!(x.value(), 2);\n    /// ```\n    ///\n    /// 四則演算ができます。\n    ///\n    /// ```\n    /// use modint::Mint1000000007;\n    /// type Mint = Mint1000000007;\n    ///\n    /// let x: Mint = Mint::from_value(6);\n    /// let y: Mint = Mint::from_value(2);\n    ///\n    /// assert_eq!((x + y).value(), 8);\n    /// assert_eq!((x - y).value(), 4);\n    /// assert_eq!((x * y).value(), 12);\n    /// assert_eq!((x / y).value(), 3);\n    /// ```\n    ///\n    /// [`value`]: #method.value\n    /// [`from_value`]: #method.from_value\n    /// [`Minfo`]:trait.Minfo.html\n\n    #[derive(Clone, Copy, Debug)]\n    pub struct Mint<Mod: Minfo>(Mod::Value);\n\n    impl<Mod: Minfo> Mint<Mod> {\n        #[inline]\n        #[allow(dead_code)]\n        fn is_within_the_range(x: Mod::Value) -> bool {\n            Mod::zero() <= x && x < Mod::modulus()\n        }\n\n        #[inline]\n        #[allow(dead_code)]\n        fn normalize(x: Mod::Value) -> Mod::Value {\n            if Self::is_within_the_range(x) {\n                x\n            } else {\n                let x = x % Mod::modulus();\n                if x < Mod::zero() {\n                    x + Mod::modulus()\n                } else {\n                    x\n                }\n            }\n        }\n\n        /// 0 を構築します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::zero();\n        /// assert_eq!(x.value(), 0);\n        /// ```\n        #[allow(dead_code)]\n        pub fn zero() -> Self {\n            Self(Mod::zero())\n        }\n\n        /// 1 を構築します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::one();\n        /// assert_eq!(x.value(), 1);\n        /// ```\n        #[allow(dead_code)]\n        pub fn one() -> Self {\n            Self(Mod::one())\n        }\n\n        /// mod を取得します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::modulus();\n        /// assert_eq!(x, 998244353);\n        /// ```\n        #[allow(dead_code)]\n        pub fn modulus() -> Mod::Value {\n            Mod::modulus()\n        }\n\n        /// 0 であるときに `true` を返します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::zero();\n        /// assert!(x.is_zero());\n        ///\n        /// let x = Mint::one();\n        /// assert!(!x.is_zero());\n        /// ```\n        #[allow(dead_code)]\n        pub fn is_zero(&self) -> bool {\n            self.value() == Mod::zero()\n        }\n\n        /// 構築します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::from_value(4);\n        /// ```\n        #[allow(dead_code)]\n        pub fn from_value(x: Mod::Value) -> Self {\n            Self(Self::normalize(x))\n        }\n\n        /// 中身を取得します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::from_value(4);\n        /// assert_eq!(x.value(), 4);\n        /// ```\n        #[allow(dead_code)]\n        pub fn value(&self) -> Mod::Value {\n            self.0\n        }\n\n        /// mod 逆元を計算します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::from_value(2);\n        /// assert_eq!(x.inv().value(), 499122177);\n        /// ```\n        #[allow(dead_code)]\n        pub fn inv(&self) -> Self {\n            if self.is_zero() {\n                panic!(\"inv(0)\");\n            }\n            Self(Self::raw_inv(self.value()))\n        }\n\n        /// ユークリッドの互除法を用いて、pow を計算します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// let x = Mint17::from_value(2);\n        /// assert_eq!(x.pow(6).value(), 64 % 17);\n        /// ```\n        #[allow(dead_code)]\n        pub fn pow(&self, b: u64) -> Self {\n            Self(Self::raw_pow(self.value(), b))\n        }\n\n        fn raw_add(x: Mod::Value, y: Mod::Value) -> Mod::Value {\n            let z = x + y;\n            if Mod::modulus() <= z {\n                z - Mod::modulus()\n            } else {\n                z\n            }\n        }\n\n        fn raw_sub(x: Mod::Value, y: Mod::Value) -> Mod::Value {\n            let z = x - y;\n            if z < Mod::zero() {\n                z + Mod::modulus()\n            } else {\n                z\n            }\n        }\n\n        fn raw_neg(x: Mod::Value) -> Mod::Value {\n            if x == Mod::zero() {\n                Mod::zero()\n            } else {\n                Mod::modulus() - x\n            }\n        }\n\n        fn raw_mul(x: Mod::Value, y: Mod::Value) -> Mod::Value {\n            x * y % Mod::modulus()\n        }\n\n        fn raw_div(x: Mod::Value, y: Mod::Value) -> Mod::Value {\n            Self::raw_mul(x, Self::raw_inv(y))\n        }\n\n        #[allow(clippy::many_single_char_names)]\n        fn raw_inv(mut x: Mod::Value) -> Mod::Value {\n            let mut y = Mod::modulus();\n            let mut u = Mod::one();\n            let mut v = Mod::zero();\n            while x != Mod::zero() {\n                let q = y / x;\n                y -= x * q;\n                v -= u * q;\n                std::mem::swap(&mut x, &mut y);\n                std::mem::swap(&mut u, &mut v);\n            }\n            if v < Mod::zero() {\n                v + Mod::modulus()\n            } else {\n                v\n            }\n        }\n\n        fn raw_pow(mut a: Mod::Value, mut b: u64) -> Mod::Value {\n            let mut x = Mod::one();\n            while 0 < b {\n                if b % 2 == 1 {\n                    x = Self::raw_mul(x, a);\n                }\n                a = Self::raw_mul(a, a);\n                b /= 2\n            }\n            x\n        }\n    }\n\n    macro_rules! impl_biop {\n    (\n        $(\n            $biop_trait: ident::$biop_fn: ident,\n            $biop_assign_trait: ident::$biop_assign_fn: ident,\n            $biop_impl: ident;\n        )*\n    ) => {\n        $(\n            impl<Mod: Minfo> std::ops::$biop_trait for Mint<Mod> {\n                type Output = Self;\n                fn $biop_fn(self, rhs: Self) -> Self::Output {\n                    Mint(Self::$biop_impl(self.value(), rhs.value()))\n                }\n            }\n            impl<Mod: Minfo> std::ops::$biop_assign_trait for Mint<Mod>\n            where\n                Self: Copy\n            {\n                fn $biop_assign_fn(&mut self, rhs: Self) {\n                    use std::ops::$biop_trait;\n                    *self = Mint::$biop_fn(*self, rhs)\n                }\n            }\n        )*\n    };\n}\n\n    impl_biop! {\n        Add::add, AddAssign::add_assign, raw_add;\n        Sub::sub, SubAssign::sub_assign, raw_sub;\n        Mul::mul, MulAssign::mul_assign, raw_mul;\n        Div::div, DivAssign::div_assign, raw_div;\n    }\n\n    impl<Mod: Minfo> std::ops::Neg for Mint<Mod> {\n        type Output = Self;\n        fn neg(self) -> Self::Output {\n            Self(Self::raw_neg(self.value()))\n        }\n    }\n\n    impl<Mod: Minfo> std::cmp::PartialEq for Mint<Mod> {\n        /// 中身をそのまま 比較です。\n        /// 構築時に normalize され、それ以降も normalized な状態に保たれますから、\n        /// 結局あまりを比較しているのと同じことになります。\n        ///\n        /// # Example\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// assert_eq!(Mint17::from_value(3), Mint::from_value(-31));\n        /// assert_eq!(Mint17::from_value(3), Mint::from_value(-14));\n        /// assert_eq!(Mint17::from_value(3), Mint::from_value(3));\n        /// assert_eq!(Mint17::from_value(3), Mint::from_value(20));\n        /// assert_eq!(Mint17::from_value(3), Mint::from_value(37));\n        ///\n        /// assert_ne!(Mint17::from_value(3), Mint::from_value(31));\n        /// assert_ne!(Mint17::from_value(3), Mint::from_value(14));\n        /// assert_ne!(Mint17::from_value(3), Mint::from_value(-3));\n        /// assert_ne!(Mint17::from_value(3), Mint::from_value(-20));\n        /// assert_ne!(Mint17::from_value(3), Mint::from_value(-37));\n        /// ```\n        fn eq(&self, other: &Self) -> bool {\n            self.value().eq(&other.value())\n        }\n    }\n    impl<Mod: Minfo> std::cmp::Eq for Mint<Mod> {}\n\n    impl<Mod: Minfo> std::fmt::Display for Mint<Mod> {\n        /// 中身をそのまま Display です。\n        ///\n        /// # Example\n        ///\n        /// ```\n        /// println!(\"{}\", modint::Mint998244353::from_value(42));\n        /// ```\n        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n            write!(f, \"{}\", self.value())\n        }\n    }\n\n    impl<Mod: Minfo> std::iter::Sum<Self> for Mint<Mod> {\n        /// 総和を取ります。\n        ///\n        /// # Example\n        ///\n        /// ```\n        /// use modint::{define_mint, Minfo, Mint};\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        /// assert_eq!(\n        ///     vec![\n        ///         Mint17::from_value(2),\n        ///         Mint17::from_value(4),\n        ///         Mint17::from_value(6),\n        ///         Mint17::from_value(8),\n        ///     ]\n        ///     .into_iter()\n        ///     .sum::<Mint17>(),\n        ///     Mint17::from_value(3)\n        /// );\n        /// ```\n        fn sum<I: Iterator<Item = Self>>(iter: I) -> Self {\n            iter.fold(Mint::zero(), |acc, x| acc + x)\n        }\n    }\n\n    impl<Mod: Minfo> std::iter::Product<Self> for Mint<Mod> {\n        /// 総積を取ります。\n        ///\n        /// # Example\n        ///\n        /// ```\n        /// use modint::{define_mint, Minfo, Mint};\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        /// assert_eq!(\n        ///     vec![\n        ///         Mint17::from_value(1),\n        ///         Mint17::from_value(2),\n        ///         Mint17::from_value(3),\n        ///         Mint17::from_value(4),\n        ///     ]\n        ///     .into_iter()\n        ///     .product::<Mint17>(),\n        ///     Mint17::from_value(7)\n        /// );\n        /// ```\n        fn product<I: Iterator<Item = Self>>(iter: I) -> Self {\n            iter.fold(Mint::one(), |acc, x| acc * x)\n        }\n    }\n\n    /// 階乗とその逆元を前計算するマシーンです。\n    #[allow(dead_code)]\n    pub struct Factorial<Mod: Minfo> {\n        normal: Vec<Mint<Mod>>,\n        inverted: Vec<Mint<Mod>>,\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo> Factorial<Mod>\n    where\n        Mod::Value: std::convert::TryFrom<usize, Error = std::num::TryFromIntError>,\n    {\n        /// サイズを指定して初期化です。\n        /// 最大値は一つ小さくなりますから、注意です。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, Factorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        /// let fact = Factorial::<Minfo17>::new(16);\n        /// ```\n        pub fn new(n: usize) -> Self {\n            use std::convert::TryFrom;\n            let mut normal = vec![Mint::one(); n];\n            for i in 1..n {\n                normal[i] = normal[i - 1] * Mint::from_value(Mod::Value::try_from(i).unwrap());\n            }\n            let mut inverted = vec![Mint::one(); n];\n            inverted[n - 1] = normal[n - 1].inv();\n            for i in (1..n).rev() {\n                inverted[i - 1] = inverted[i] * Mint::from_value(Mod::Value::try_from(i).unwrap());\n            }\n            Self { normal, inverted }\n        }\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo> Factorial<Mod> {\n        /// 階乗の逆元を取得します。\n        ///\n        /// 逆元でなくて普通の階乗は、[`implementations`] をご覧いただけると幸いです。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, Factorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// let fact = Factorial::<Minfo17>::new(17);\n        ///\n        /// for i in 0..17 {\n        ///     assert_eq!(fact[i] * fact.inverted(i), Mint17::one());\n        /// }\n        /// ```\n        ///\n        /// [`implementations`]: #implementations\n        ///\n        pub fn inverted(&self, i: usize) -> Mint<Mod> {\n            self.inverted[i]\n        }\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo, I: std::slice::SliceIndex<[Mint<Mod>]>> std::ops::Index<I> for Factorial<Mod> {\n        type Output = I::Output;\n\n        /// Index でも取ることができます。\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, Factorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// let fact = Factorial::<Minfo17>::new(17);\n        ///\n        /// assert_eq!(fact[0], Mint17::from_value(1));\n        /// assert_eq!(fact[1], Mint17::from_value(1));\n        /// assert_eq!(fact[2], Mint17::from_value(2));\n        /// assert_eq!(fact[3], Mint17::from_value(6));\n        /// assert_eq!(fact[4], Mint17::from_value(24 % 17));\n        /// assert_eq!(fact[5], Mint17::from_value(120 % 17));\n        /// ```\n        #[inline]\n        fn index(&self, index: I) -> &Self::Output {\n            &self.normal[index]\n        }\n    }\n\n    /// 二重階乗とその逆元を前計算するマシーンです。\n    #[allow(dead_code)]\n    pub struct DoubleFactorial<Mod: Minfo> {\n        normal: Vec<Mint<Mod>>,\n        inverted: Vec<Mint<Mod>>,\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo> DoubleFactorial<Mod>\n    where\n        Mod::Value: std::convert::TryFrom<usize, Error = std::num::TryFromIntError>,\n    {\n        /// サイズを指定して初期化です。\n        /// 最大値は一つ小さくなりますから、注意です。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, DoubleFactorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        /// let fact = DoubleFactorial::<Minfo17>::new(16);\n        /// ```\n        pub fn new(n: usize) -> Self {\n            use std::convert::TryFrom;\n            let mut normal = vec![Mint::one(); n];\n            for i in 2..n {\n                normal[i] = normal[i - 2] * Mint::from_value(Mod::Value::try_from(i).unwrap());\n            }\n            let mut inverted = vec![Mint::one(); n];\n            inverted[n - 1] = normal[n - 1].inv();\n            inverted[n - 2] = normal[n - 2].inv();\n            for i in (2..n).rev() {\n                inverted[i - 2] = inverted[i] * Mint::from_value(Mod::Value::try_from(i).unwrap());\n            }\n            Self { normal, inverted }\n        }\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo> DoubleFactorial<Mod> {\n        /// 二重階乗の逆元を取得します。\n        ///\n        /// 逆元でなくて普通の二重階乗は、[`implementations`] をご覧いただけると幸いです。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, DoubleFactorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// let fact = DoubleFactorial::<Minfo17>::new(17);\n        ///\n        /// for i in 0..17 {\n        ///     assert_eq!(fact[i] * fact.inverted(i), Mint17::one());\n        /// }\n        /// ```\n        ///\n        /// [`implementations`]: #implementations\n        ///\n        pub fn inverted(&self, i: usize) -> Mint<Mod> {\n            self.inverted[i]\n        }\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo, I: std::slice::SliceIndex<[Mint<Mod>]>> std::ops::Index<I>\n        for DoubleFactorial<Mod>\n    {\n        type Output = I::Output;\n\n        /// Index でも取ることができます。\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, DoubleFactorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// let fact = DoubleFactorial::<Minfo17>::new(17);\n        ///\n        /// assert_eq!(fact[0], Mint17::from_value(1));\n        /// assert_eq!(fact[1], Mint17::from_value(1));\n        /// assert_eq!(fact[2], Mint17::from_value(2));\n        /// assert_eq!(fact[3], Mint17::from_value(3));\n        /// assert_eq!(fact[4], Mint17::from_value(8));\n        /// assert_eq!(fact[5], Mint17::from_value(15));\n        /// ```\n        #[inline]\n        fn index(&self, index: I) -> &Self::Output {\n            &self.normal[index]\n        }\n    }\n\n    /// Mint 型を定義するためのマクロです。\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use modint::{define_mint, Minfo, Mint};\n    ///\n    /// define_mint! {\n    ///     struct Mint17(Minfo17(17; i64));\n    /// }\n    ///\n    /// let x = Mint17::from_value(1);\n    /// let y = Mint17::from_value(2);\n    /// let z = x / y;\n    /// assert_eq!(z.value(), 9);\n    /// ```\n    #[macro_export]\n    macro_rules! define_mint {\n        (\n        struct $modint: ident ($modinfo: ident ($modvalue: expr; $modty: ty));\n    ) => {\n            #[allow(dead_code)]\n            #[derive(Clone, Copy, Debug)]\n            pub struct $modinfo {}\n            impl Minfo for $modinfo {\n                type Value = $modty;\n                fn modulus() -> Self::Value {\n                    $modvalue\n                }\n                fn zero() -> Self::Value {\n                    0\n                }\n                fn one() -> Self::Value {\n                    1\n                }\n            }\n            type $modint = Mint<$modinfo>;\n        };\n    }\n\n    /// Mod = 1000000007 なる Minfo です。\n    #[allow(dead_code)]\n    #[derive(Clone, Copy, Debug)]\n    pub struct Minfo1000000007 {}\n\n    impl Minfo for Minfo1000000007 {\n        type Value = i64;\n        fn modulus() -> Self::Value {\n            1_000_000_007\n        }\n        fn zero() -> Self::Value {\n            0\n        }\n        fn one() -> Self::Value {\n            1\n        }\n    }\n\n    /// Mod = 1000000007 なる Mint です。\n    #[allow(dead_code)]\n    pub type Mint1000000007 = Mint<Minfo1000000007>;\n\n    /// Mod = 998244353 なる Minfo です。\n    #[allow(dead_code)]\n    #[derive(Clone, Copy, Debug)]\n    pub struct Minfo998244353 {}\n\n    impl Minfo for Minfo998244353 {\n        type Value = i64;\n        fn modulus() -> Self::Value {\n            998_244_353\n        }\n        fn zero() -> Self::Value {\n            0\n        }\n        fn one() -> Self::Value {\n            1\n        }\n    }\n\n    /// Mod = 998244353 なる Mint です。\n    #[allow(dead_code)]\n    pub type Mint998244353 = Mint<Minfo998244353>;\n}\n//}}}\n\ntype Mint = modint::Mint998244353;\n\nfn main() {\n    input!(n: usize, mut s: Chars);\n    s.reverse();\n    let make = |x: Mint| -> Vec<(Mint, Mint)> {\n        let xinv = x.inv();\n        let mut ans = vec![(Mint::one(), Mint::zero()); n + 1];\n        for (i, &c) in s.iter().enumerate() {\n            let (a, b) = ans[i];\n            ans[i + 1] = match c {\n                '+' => (a, b + Mint::one()),\n                '-' => (a, b - Mint::one()),\n                '<' => (a * x, b * x),\n                '>' => (a * xinv, b * xinv),\n                _ => panic!(),\n            }\n        }\n        ans\n    };\n\n    let keys: Vec<_> = (1..6)\n        .map(|i| i * 10_000_000)\n        .map(Mint::from_value)\n        .collect();\n    let seqs: Vec<_> = keys.iter().copied().map(make).collect();\n    let mut hash_map = std::collections::HashMap::<Vec<_>, _>::new();\n    let mut ans = 0;\n    for i in 0..=n {\n        if let Some(x) = hash_map.get(\n            &(0..keys.len())\n                .map(|j| {\n                    let (a, b) = seqs[j][i];\n                    assert!(!a.is_zero());\n                    ((b - seqs[j][n].1) / a).value()\n                })\n                .collect::<Vec<_>>(),\n        ) {\n            ans += x;\n        }\n        *hash_map\n            .entry(\n                (0..keys.len())\n                    .map(|j| {\n                        let (a, b) = seqs[j][i];\n                        (b / a).value()\n                    })\n                    .collect(),\n            )\n            .or_insert(0) += 1;\n    }\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "use proconio::{input, marker::Chars};\n\n// modint{{{\nmod modint {\n    //! [`Mint`] 型を提供します。\n    //!\n    //! [`Mint`]: struct.Mint.html\n\n    /// [`Mint`] の中に入れる数値型が実装していないといけないトレイトをまとめました。\n    ///\n    /// どうやら普通の符号付き整数型ならば大丈夫そうですね。\n    ///\n    /// いかがでしたでしょうか？（真顔）\n    ///\n    /// [`Mint`]: struct.Mint.html\n    pub trait ModValue:\n        std::ops::Add<Output = Self>\n        + std::ops::Sub<Output = Self>\n        + std::ops::Mul<Output = Self>\n        + std::ops::Div<Output = Self>\n        + std::ops::Rem<Output = Self>\n        + std::ops::AddAssign\n        + std::ops::SubAssign\n        + std::ops::MulAssign\n        + std::ops::DivAssign\n        + std::ops::RemAssign\n        + std::ops::Neg\n        + std::cmp::Ord\n        + Clone\n        + Copy\n        + Sized\n        + std::fmt::Debug\n        + std::fmt::Display\n    {\n    }\n\n    impl<\n            Value: std::ops::Add<Output = Self>\n                + std::ops::Sub<Output = Self>\n                + std::ops::Mul<Output = Self>\n                + std::ops::Div<Output = Self>\n                + std::ops::Rem<Output = Self>\n                + std::ops::AddAssign\n                + std::ops::SubAssign\n                + std::ops::MulAssign\n                + std::ops::DivAssign\n                + std::ops::RemAssign\n                + std::ops::Neg\n                + std::cmp::Ord\n                + Clone\n                + Copy\n                + Sized\n                + std::fmt::Debug\n                + std::fmt::Display,\n        > ModValue for Value\n    {\n    }\n\n    /// mod に関数情報を [`Mint`] に伝えるための型引数だッピ！\n    ///\n    /// [`Mint`]: struct.Mint.html\n    pub trait Minfo: Clone + Copy + std::fmt::Debug {\n        /// 中身の型です。\n        type Value: ModValue;\n\n        /// mod の値を返します。\n        fn modulus() -> Self::Value;\n\n        /// 0 を返します。\n        fn zero() -> Self::Value;\n\n        /// 1 を返します。\n        fn one() -> Self::Value;\n    }\n\n    /// 自動で mod を取ってくれる整数型です。\n    ///\n    /// 型引数は、トレイト [`Minfo`] を実装している必要があります。\n    ///\n    /// # Examples\n    ///\n    /// [`from_value`] によって、`Mint<Mod>` が作れます。\n    /// 逆に、[`value`] によって、中身がとれます。\n    ///\n    /// ```\n    /// use modint::Mint1000000007;\n    /// type Mint = Mint1000000007;\n    ///\n    /// let x: Mint = Mint::from_value(2);\n    ///\n    /// assert_eq!(x.value(), 2);\n    /// ```\n    ///\n    /// 四則演算ができます。\n    ///\n    /// ```\n    /// use modint::Mint1000000007;\n    /// type Mint = Mint1000000007;\n    ///\n    /// let x: Mint = Mint::from_value(6);\n    /// let y: Mint = Mint::from_value(2);\n    ///\n    /// assert_eq!((x + y).value(), 8);\n    /// assert_eq!((x - y).value(), 4);\n    /// assert_eq!((x * y).value(), 12);\n    /// assert_eq!((x / y).value(), 3);\n    /// ```\n    ///\n    /// [`value`]: #method.value\n    /// [`from_value`]: #method.from_value\n    /// [`Minfo`]:trait.Minfo.html\n\n    #[derive(Clone, Copy, Debug)]\n    pub struct Mint<Mod: Minfo>(Mod::Value);\n\n    impl<Mod: Minfo> Mint<Mod> {\n        #[inline]\n        #[allow(dead_code)]\n        fn is_within_the_range(x: Mod::Value) -> bool {\n            Mod::zero() <= x && x < Mod::modulus()\n        }\n\n        #[inline]\n        #[allow(dead_code)]\n        fn normalize(x: Mod::Value) -> Mod::Value {\n            if Self::is_within_the_range(x) {\n                x\n            } else {\n                let x = x % Mod::modulus();\n                if x < Mod::zero() {\n                    x + Mod::modulus()\n                } else {\n                    x\n                }\n            }\n        }\n\n        /// 0 を構築します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::zero();\n        /// assert_eq!(x.value(), 0);\n        /// ```\n        #[allow(dead_code)]\n        pub fn zero() -> Self {\n            Self(Mod::zero())\n        }\n\n        /// 1 を構築します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::one();\n        /// assert_eq!(x.value(), 1);\n        /// ```\n        #[allow(dead_code)]\n        pub fn one() -> Self {\n            Self(Mod::one())\n        }\n\n        /// mod を取得します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::modulus();\n        /// assert_eq!(x, 998244353);\n        /// ```\n        #[allow(dead_code)]\n        pub fn modulus() -> Mod::Value {\n            Mod::modulus()\n        }\n\n        /// 0 であるときに `true` を返します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::zero();\n        /// assert!(x.is_zero());\n        ///\n        /// let x = Mint::one();\n        /// assert!(!x.is_zero());\n        /// ```\n        #[allow(dead_code)]\n        pub fn is_zero(&self) -> bool {\n            self.value() == Mod::zero()\n        }\n\n        /// 構築します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::from_value(4);\n        /// ```\n        #[allow(dead_code)]\n        pub fn from_value(x: Mod::Value) -> Self {\n            Self(Self::normalize(x))\n        }\n\n        /// 中身を取得します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::from_value(4);\n        /// assert_eq!(x.value(), 4);\n        /// ```\n        #[allow(dead_code)]\n        pub fn value(&self) -> Mod::Value {\n            self.0\n        }\n\n        /// mod 逆元を計算します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::from_value(2);\n        /// assert_eq!(x.inv().value(), 499122177);\n        /// ```\n        #[allow(dead_code)]\n        pub fn inv(&self) -> Self {\n            if self.is_zero() {\n                panic!(\"inv(0)\");\n            }\n            Self(Self::raw_inv(self.value()))\n        }\n\n        /// ユークリッドの互除法を用いて、pow を計算します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// let x = Mint17::from_value(2);\n        /// assert_eq!(x.pow(6).value(), 64 % 17);\n        /// ```\n        #[allow(dead_code)]\n        pub fn pow(&self, b: u64) -> Self {\n            Self(Self::raw_pow(self.value(), b))\n        }\n\n        fn raw_add(x: Mod::Value, y: Mod::Value) -> Mod::Value {\n            let z = x + y;\n            if Mod::modulus() <= z {\n                z - Mod::modulus()\n            } else {\n                z\n            }\n        }\n\n        fn raw_sub(x: Mod::Value, y: Mod::Value) -> Mod::Value {\n            let z = x - y;\n            if z < Mod::zero() {\n                z + Mod::modulus()\n            } else {\n                z\n            }\n        }\n\n        fn raw_neg(x: Mod::Value) -> Mod::Value {\n            if x == Mod::zero() {\n                Mod::zero()\n            } else {\n                Mod::modulus() - x\n            }\n        }\n\n        fn raw_mul(x: Mod::Value, y: Mod::Value) -> Mod::Value {\n            x * y % Mod::modulus()\n        }\n\n        fn raw_div(x: Mod::Value, y: Mod::Value) -> Mod::Value {\n            Self::raw_mul(x, Self::raw_inv(y))\n        }\n\n        #[allow(clippy::many_single_char_names)]\n        fn raw_inv(mut x: Mod::Value) -> Mod::Value {\n            let mut y = Mod::modulus();\n            let mut u = Mod::one();\n            let mut v = Mod::zero();\n            while x != Mod::zero() {\n                let q = y / x;\n                y -= x * q;\n                v -= u * q;\n                std::mem::swap(&mut x, &mut y);\n                std::mem::swap(&mut u, &mut v);\n            }\n            if v < Mod::zero() {\n                v + Mod::modulus()\n            } else {\n                v\n            }\n        }\n\n        fn raw_pow(mut a: Mod::Value, mut b: u64) -> Mod::Value {\n            let mut x = Mod::one();\n            while 0 < b {\n                if b % 2 == 1 {\n                    x = Self::raw_mul(x, a);\n                }\n                a = Self::raw_mul(a, a);\n                b /= 2\n            }\n            x\n        }\n    }\n\n    macro_rules! impl_biop {\n    (\n        $(\n            $biop_trait: ident::$biop_fn: ident,\n            $biop_assign_trait: ident::$biop_assign_fn: ident,\n            $biop_impl: ident;\n        )*\n    ) => {\n        $(\n            impl<Mod: Minfo> std::ops::$biop_trait for Mint<Mod> {\n                type Output = Self;\n                fn $biop_fn(self, rhs: Self) -> Self::Output {\n                    Mint(Self::$biop_impl(self.value(), rhs.value()))\n                }\n            }\n            impl<Mod: Minfo> std::ops::$biop_assign_trait for Mint<Mod>\n            where\n                Self: Copy\n            {\n                fn $biop_assign_fn(&mut self, rhs: Self) {\n                    use std::ops::$biop_trait;\n                    *self = Mint::$biop_fn(*self, rhs)\n                }\n            }\n        )*\n    };\n}\n\n    impl_biop! {\n        Add::add, AddAssign::add_assign, raw_add;\n        Sub::sub, SubAssign::sub_assign, raw_sub;\n        Mul::mul, MulAssign::mul_assign, raw_mul;\n        Div::div, DivAssign::div_assign, raw_div;\n    }\n\n    impl<Mod: Minfo> std::ops::Neg for Mint<Mod> {\n        type Output = Self;\n        fn neg(self) -> Self::Output {\n            Self(Self::raw_neg(self.value()))\n        }\n    }\n\n    impl<Mod: Minfo> std::cmp::PartialEq for Mint<Mod> {\n        /// 中身をそのまま 比較です。\n        /// 構築時に normalize され、それ以降も normalized な状態に保たれますから、\n        /// 結局あまりを比較しているのと同じことになります。\n        ///\n        /// # Example\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// assert_eq!(Mint17::from_value(3), Mint::from_value(-31));\n        /// assert_eq!(Mint17::from_value(3), Mint::from_value(-14));\n        /// assert_eq!(Mint17::from_value(3), Mint::from_value(3));\n        /// assert_eq!(Mint17::from_value(3), Mint::from_value(20));\n        /// assert_eq!(Mint17::from_value(3), Mint::from_value(37));\n        ///\n        /// assert_ne!(Mint17::from_value(3), Mint::from_value(31));\n        /// assert_ne!(Mint17::from_value(3), Mint::from_value(14));\n        /// assert_ne!(Mint17::from_value(3), Mint::from_value(-3));\n        /// assert_ne!(Mint17::from_value(3), Mint::from_value(-20));\n        /// assert_ne!(Mint17::from_value(3), Mint::from_value(-37));\n        /// ```\n        fn eq(&self, other: &Self) -> bool {\n            self.value().eq(&other.value())\n        }\n    }\n    impl<Mod: Minfo> std::cmp::Eq for Mint<Mod> {}\n\n    impl<Mod: Minfo> std::fmt::Display for Mint<Mod> {\n        /// 中身をそのまま Display です。\n        ///\n        /// # Example\n        ///\n        /// ```\n        /// println!(\"{}\", modint::Mint998244353::from_value(42));\n        /// ```\n        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n            write!(f, \"{}\", self.value())\n        }\n    }\n\n    impl<Mod: Minfo> std::iter::Sum<Self> for Mint<Mod> {\n        /// 総和を取ります。\n        ///\n        /// # Example\n        ///\n        /// ```\n        /// use modint::{define_mint, Minfo, Mint};\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        /// assert_eq!(\n        ///     vec![\n        ///         Mint17::from_value(2),\n        ///         Mint17::from_value(4),\n        ///         Mint17::from_value(6),\n        ///         Mint17::from_value(8),\n        ///     ]\n        ///     .into_iter()\n        ///     .sum::<Mint17>(),\n        ///     Mint17::from_value(3)\n        /// );\n        /// ```\n        fn sum<I: Iterator<Item = Self>>(iter: I) -> Self {\n            iter.fold(Mint::zero(), |acc, x| acc + x)\n        }\n    }\n\n    impl<Mod: Minfo> std::iter::Product<Self> for Mint<Mod> {\n        /// 総積を取ります。\n        ///\n        /// # Example\n        ///\n        /// ```\n        /// use modint::{define_mint, Minfo, Mint};\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        /// assert_eq!(\n        ///     vec![\n        ///         Mint17::from_value(1),\n        ///         Mint17::from_value(2),\n        ///         Mint17::from_value(3),\n        ///         Mint17::from_value(4),\n        ///     ]\n        ///     .into_iter()\n        ///     .product::<Mint17>(),\n        ///     Mint17::from_value(7)\n        /// );\n        /// ```\n        fn product<I: Iterator<Item = Self>>(iter: I) -> Self {\n            iter.fold(Mint::one(), |acc, x| acc * x)\n        }\n    }\n\n    /// 階乗とその逆元を前計算するマシーンです。\n    #[allow(dead_code)]\n    pub struct Factorial<Mod: Minfo> {\n        normal: Vec<Mint<Mod>>,\n        inverted: Vec<Mint<Mod>>,\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo> Factorial<Mod>\n    where\n        Mod::Value: std::convert::TryFrom<usize, Error = std::num::TryFromIntError>,\n    {\n        /// サイズを指定して初期化です。\n        /// 最大値は一つ小さくなりますから、注意です。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, Factorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        /// let fact = Factorial::<Minfo17>::new(16);\n        /// ```\n        pub fn new(n: usize) -> Self {\n            use std::convert::TryFrom;\n            let mut normal = vec![Mint::one(); n];\n            for i in 1..n {\n                normal[i] = normal[i - 1] * Mint::from_value(Mod::Value::try_from(i).unwrap());\n            }\n            let mut inverted = vec![Mint::one(); n];\n            inverted[n - 1] = normal[n - 1].inv();\n            for i in (1..n).rev() {\n                inverted[i - 1] = inverted[i] * Mint::from_value(Mod::Value::try_from(i).unwrap());\n            }\n            Self { normal, inverted }\n        }\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo> Factorial<Mod> {\n        /// 階乗の逆元を取得します。\n        ///\n        /// 逆元でなくて普通の階乗は、[`implementations`] をご覧いただけると幸いです。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, Factorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// let fact = Factorial::<Minfo17>::new(17);\n        ///\n        /// for i in 0..17 {\n        ///     assert_eq!(fact[i] * fact.inverted(i), Mint17::one());\n        /// }\n        /// ```\n        ///\n        /// [`implementations`]: #implementations\n        ///\n        pub fn inverted(&self, i: usize) -> Mint<Mod> {\n            self.inverted[i]\n        }\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo, I: std::slice::SliceIndex<[Mint<Mod>]>> std::ops::Index<I> for Factorial<Mod> {\n        type Output = I::Output;\n\n        /// Index でも取ることができます。\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, Factorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// let fact = Factorial::<Minfo17>::new(17);\n        ///\n        /// assert_eq!(fact[0], Mint17::from_value(1));\n        /// assert_eq!(fact[1], Mint17::from_value(1));\n        /// assert_eq!(fact[2], Mint17::from_value(2));\n        /// assert_eq!(fact[3], Mint17::from_value(6));\n        /// assert_eq!(fact[4], Mint17::from_value(24 % 17));\n        /// assert_eq!(fact[5], Mint17::from_value(120 % 17));\n        /// ```\n        #[inline]\n        fn index(&self, index: I) -> &Self::Output {\n            &self.normal[index]\n        }\n    }\n\n    /// 二重階乗とその逆元を前計算するマシーンです。\n    #[allow(dead_code)]\n    pub struct DoubleFactorial<Mod: Minfo> {\n        normal: Vec<Mint<Mod>>,\n        inverted: Vec<Mint<Mod>>,\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo> DoubleFactorial<Mod>\n    where\n        Mod::Value: std::convert::TryFrom<usize, Error = std::num::TryFromIntError>,\n    {\n        /// サイズを指定して初期化です。\n        /// 最大値は一つ小さくなりますから、注意です。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, DoubleFactorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        /// let fact = DoubleFactorial::<Minfo17>::new(16);\n        /// ```\n        pub fn new(n: usize) -> Self {\n            use std::convert::TryFrom;\n            let mut normal = vec![Mint::one(); n];\n            for i in 2..n {\n                normal[i] = normal[i - 2] * Mint::from_value(Mod::Value::try_from(i).unwrap());\n            }\n            let mut inverted = vec![Mint::one(); n];\n            inverted[n - 1] = normal[n - 1].inv();\n            inverted[n - 2] = normal[n - 2].inv();\n            for i in (2..n).rev() {\n                inverted[i - 2] = inverted[i] * Mint::from_value(Mod::Value::try_from(i).unwrap());\n            }\n            Self { normal, inverted }\n        }\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo> DoubleFactorial<Mod> {\n        /// 二重階乗の逆元を取得します。\n        ///\n        /// 逆元でなくて普通の二重階乗は、[`implementations`] をご覧いただけると幸いです。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, DoubleFactorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// let fact = DoubleFactorial::<Minfo17>::new(17);\n        ///\n        /// for i in 0..17 {\n        ///     assert_eq!(fact[i] * fact.inverted(i), Mint17::one());\n        /// }\n        /// ```\n        ///\n        /// [`implementations`]: #implementations\n        ///\n        pub fn inverted(&self, i: usize) -> Mint<Mod> {\n            self.inverted[i]\n        }\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo, I: std::slice::SliceIndex<[Mint<Mod>]>> std::ops::Index<I>\n        for DoubleFactorial<Mod>\n    {\n        type Output = I::Output;\n\n        /// Index でも取ることができます。\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, DoubleFactorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// let fact = DoubleFactorial::<Minfo17>::new(17);\n        ///\n        /// assert_eq!(fact[0], Mint17::from_value(1));\n        /// assert_eq!(fact[1], Mint17::from_value(1));\n        /// assert_eq!(fact[2], Mint17::from_value(2));\n        /// assert_eq!(fact[3], Mint17::from_value(3));\n        /// assert_eq!(fact[4], Mint17::from_value(8));\n        /// assert_eq!(fact[5], Mint17::from_value(15));\n        /// ```\n        #[inline]\n        fn index(&self, index: I) -> &Self::Output {\n            &self.normal[index]\n        }\n    }\n\n    /// Mint 型を定義するためのマクロです。\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use modint::{define_mint, Minfo, Mint};\n    ///\n    /// define_mint! {\n    ///     struct Mint17(Minfo17(17; i64));\n    /// }\n    ///\n    /// let x = Mint17::from_value(1);\n    /// let y = Mint17::from_value(2);\n    /// let z = x / y;\n    /// assert_eq!(z.value(), 9);\n    /// ```\n    #[macro_export]\n    macro_rules! define_mint {\n        (\n        struct $modint: ident ($modinfo: ident ($modvalue: expr; $modty: ty));\n    ) => {\n            #[allow(dead_code)]\n            #[derive(Clone, Copy, Debug)]\n            pub struct $modinfo {}\n            impl Minfo for $modinfo {\n                type Value = $modty;\n                fn modulus() -> Self::Value {\n                    $modvalue\n                }\n                fn zero() -> Self::Value {\n                    0\n                }\n                fn one() -> Self::Value {\n                    1\n                }\n            }\n            type $modint = Mint<$modinfo>;\n        };\n    }\n\n    /// Mod = 1000000007 なる Minfo です。\n    #[allow(dead_code)]\n    #[derive(Clone, Copy, Debug)]\n    pub struct Minfo1000000007 {}\n\n    impl Minfo for Minfo1000000007 {\n        type Value = i64;\n        fn modulus() -> Self::Value {\n            1_000_000_007\n        }\n        fn zero() -> Self::Value {\n            0\n        }\n        fn one() -> Self::Value {\n            1\n        }\n    }\n\n    /// Mod = 1000000007 なる Mint です。\n    #[allow(dead_code)]\n    pub type Mint1000000007 = Mint<Minfo1000000007>;\n\n    /// Mod = 998244353 なる Minfo です。\n    #[allow(dead_code)]\n    #[derive(Clone, Copy, Debug)]\n    pub struct Minfo998244353 {}\n\n    impl Minfo for Minfo998244353 {\n        type Value = i64;\n        fn modulus() -> Self::Value {\n            998_244_353\n        }\n        fn zero() -> Self::Value {\n            0\n        }\n        fn one() -> Self::Value {\n            1\n        }\n    }\n\n    /// Mod = 998244353 なる Mint です。\n    #[allow(dead_code)]\n    pub type Mint998244353 = Mint<Minfo998244353>;\n}\n//}}}\n\ntype Mint = modint::Mint1000000007;\n\nfn main() {\n    input!(n: usize, mut s: Chars);\n    s.reverse();\n    let make = |x: Mint| -> Vec<(Mint, Mint)> {\n        let mut ans = vec![(Mint::one(), Mint::zero()); n + 1];\n        for (i, &c) in s.iter().enumerate() {\n            let (a, b) = ans[i];\n            ans[i + 1] = match c {\n                '+' => (a, b + Mint::one()),\n                '-' => (a, b - Mint::one()),\n                '<' => (a * x, b * x),\n                '>' => (a / x, b / x),\n                _ => panic!(),\n            }\n        }\n        ans\n    };\n\n    let keys: Vec<_> = (0..6).map(Mint::from_value).collect();\n    let seqs: Vec<_> = keys.iter().copied().map(make).collect();\n    let mut btree_map = std::collections::BTreeMap::<Vec<_>, _>::new();\n    let mut ans = 0;\n    for i in 0..=n {\n        if let Some(x) = btree_map.get(\n            &(0..keys.len())\n                .map(|j| {\n                    let (a, b) = seqs[j][i];\n                    ((b - seqs[j][n].1) / a).value()\n                })\n                .collect::<Vec<_>>(),\n        ) {\n            ans += x;\n        }\n        *btree_map\n            .entry(\n                (0..keys.len())\n                    .map(|j| {\n                        let (a, b) = seqs[j][i];\n                        (b / a).value()\n                    })\n                    .collect(),\n            )\n            .or_insert(0) += 1;\n    }\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::Read;\n#[allow(dead_code)]\nfn getline() -> String {\n    let mut ret = String::new();\n    std::io::stdin().read_line(&mut ret).ok().unwrap();\n    ret\n}\nfn get_word() -> String {\n    let mut stdin = std::io::stdin();\n    let mut u8b: [u8; 1] = [0];\n    loop {\n        let mut buf: Vec<u8> = Vec::with_capacity(16);\n        loop {\n            let res = stdin.read(&mut u8b);\n            if res.unwrap_or(0) == 0 || u8b[0] <= b' ' {\n                break;\n            } else {\n                buf.push(u8b[0]);\n            }\n        }\n        if buf.len() >= 1 {\n            let ret = String::from_utf8(buf).unwrap();\n            return ret;\n        }\n    }\n}\n\n#[allow(dead_code)]\nfn get<T: std::str::FromStr>() -> T { get_word().parse().ok().unwrap() }\n\nconst MOD: i64 = 1_000_000_007;\n\n/// Refers external ::MOD.\n/// Verified by:\nmod mod_int {\n    use ::MOD;\n    use std::ops::*;\n    #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]\n    pub struct ModInt {\n        pub x: i64,\n    }\n    impl ModInt {\n        fn check_integrity(self) {\n            debug_assert!(self.x >= 0);\n            debug_assert!(self.x < MOD);\n        }\n        pub fn new(x: i64) -> Self { ModInt { x: x % MOD } }\n        #[allow(dead_code)]\n        pub fn mul_fast(self, other: Self) -> Self {\n            self.check_integrity();\n            other.check_integrity();\n            Self::new(self.x * other.x % MOD)\n        }\n        #[allow(dead_code)]\n        pub fn mul_slow(self, other: Self) -> Self {\n            // Naive multiplication in order to avoid overflow\n            self.check_integrity();\n            other.check_integrity();\n            let mut sum = 0;\n            let mut cur = self.x;\n            let mut e = other.x;\n            if self.x < other.x {\n                cur = other.x;\n                e = self.x;\n            }\n            while e > 0 {\n                if e % 2 == 1 {\n                    sum += cur;\n                    if sum >= MOD {\n                        sum -= MOD;\n                    }\n                }\n                cur *= 2;\n                if cur >= MOD {\n                    cur -= MOD;\n                }\n                e /= 2;\n            }\n            Self::new(sum)\n        }\n        pub fn pow(self, mut e: i64) -> Self {\n            self.check_integrity();\n            let mut sum = ModInt::new(1);\n            let mut cur = ModInt::new(self.x);\n            while e > 0 {\n                if e % 2 != 0 {\n                    sum = sum * cur;\n                }\n                cur = cur * cur;\n                e /= 2;\n            }\n            sum\n        }\n        pub fn inv(self) -> Self {\n            self.pow(MOD - 2)\n        }\n    }\n    impl Add for ModInt {\n        type Output = Self;\n        fn add(self, other: Self) -> Self {\n            self.check_integrity();\n            other.check_integrity();\n            let mut sum = self.x + other.x;\n            if sum >= MOD {\n                sum -= MOD;\n            }\n            Self::new(sum)\n        }\n    }\n    impl Sub for ModInt {\n        type Output = Self;\n        fn sub(self, other: Self) -> Self {\n            self.check_integrity();\n            other.check_integrity();\n            let mut sum = self.x - other.x;\n            if sum < 0 {\n                sum += MOD;\n            }\n            Self::new(sum)\n        }\n    }\n    impl Mul for ModInt {\n        type Output = Self;\n        fn mul(self, other: Self) -> Self {\n            self.mul_fast(other)\n        }\n    }\n} // mod mod_int\n\n\nfn solve() {\n    use mod_int::*;\n    let n: usize = get();\n    let s: Vec<_> = get_word().chars().collect();\n    const A: usize = 3;\n    let b = [ModInt::new(41), ModInt::new(255), ModInt::new(36)];\n    let mut hsh = vec![vec![ModInt::new(0); n + 1]; A];\n    let mut inv = [ModInt::new(0); A];\n    for i in 0 .. A { inv[i] = b[i].inv(); }\n    let mut pos = vec![0; n + 1];\n    for c in 0 .. A {\n        let mut p = 0;\n        let mut cur = ModInt::new(1);\n        for (i, &ch) in s.iter().enumerate() {\n            let mut tmp = hsh[c][i];\n            match ch {\n                '>' => {\n                    p += 1;\n                    cur = cur * b[c];\n                },\n                '<' => {\n                    p -= 1;\n                    cur = cur * inv[c];\n                },\n                '+' => tmp = tmp + cur,\n                '-' => tmp = tmp - cur,\n                _ => panic!(),\n            }\n            hsh[c][i + 1] = tmp;\n            pos[i + 1] = p;\n        }\n    }\n    let mut meguru = [ModInt::new(0); A];\n    for c in 0 .. A { meguru[c] = hsh[c][n]; }\n    let mut kirika = HashMap::new();\n    kirika.insert(meguru, 1);\n    let mut tot = 0i64;\n    for i in (0 .. n).rev() {\n        let mut cur = [ModInt::new(0); A];\n        for c in 0 .. A { cur[c] = b[c].pow(MOD - 1 + pos[i]); }\n        let mut ken = [ModInt::new(0); A];\n        for c in 0 .. A { ken[c] = cur[c] * meguru[c] + hsh[c][i]; }\n        tot += kirika.get(&ken).cloned().unwrap_or(0);\n        let mut tt = [ModInt::new(0); A];\n        for c in 0 .. A { tt[c] = hsh[c][i]; }\n        *kirika.entry(tt).or_insert(0) += 1;\n    }\n    println!(\"{}\", tot);\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "use proconio::{input, marker::Chars};\n\n// modint{{{\nmod modint {\n    //! [`Mint`] 型を提供します。\n    //!\n    //! [`Mint`]: struct.Mint.html\n\n    /// [`Mint`] の中に入れる数値型が実装していないといけないトレイトをまとめました。\n    ///\n    /// どうやら普通の符号付き整数型ならば大丈夫そうですね。\n    ///\n    /// いかがでしたでしょうか？（真顔）\n    ///\n    /// [`Mint`]: struct.Mint.html\n    pub trait ModValue:\n        std::ops::Add<Output = Self>\n        + std::ops::Sub<Output = Self>\n        + std::ops::Mul<Output = Self>\n        + std::ops::Div<Output = Self>\n        + std::ops::Rem<Output = Self>\n        + std::ops::AddAssign\n        + std::ops::SubAssign\n        + std::ops::MulAssign\n        + std::ops::DivAssign\n        + std::ops::RemAssign\n        + std::ops::Neg\n        + std::cmp::Ord\n        + Clone\n        + Copy\n        + Sized\n        + std::fmt::Debug\n        + std::fmt::Display\n    {\n    }\n\n    impl<\n            Value: std::ops::Add<Output = Self>\n                + std::ops::Sub<Output = Self>\n                + std::ops::Mul<Output = Self>\n                + std::ops::Div<Output = Self>\n                + std::ops::Rem<Output = Self>\n                + std::ops::AddAssign\n                + std::ops::SubAssign\n                + std::ops::MulAssign\n                + std::ops::DivAssign\n                + std::ops::RemAssign\n                + std::ops::Neg\n                + std::cmp::Ord\n                + Clone\n                + Copy\n                + Sized\n                + std::fmt::Debug\n                + std::fmt::Display,\n        > ModValue for Value\n    {\n    }\n\n    /// mod に関数情報を [`Mint`] に伝えるための型引数だッピ！\n    ///\n    /// [`Mint`]: struct.Mint.html\n    pub trait Minfo: Clone + Copy + std::fmt::Debug {\n        /// 中身の型です。\n        type Value: ModValue;\n\n        /// mod の値を返します。\n        fn modulus() -> Self::Value;\n\n        /// 0 を返します。\n        fn zero() -> Self::Value;\n\n        /// 1 を返します。\n        fn one() -> Self::Value;\n    }\n\n    /// 自動で mod を取ってくれる整数型です。\n    ///\n    /// 型引数は、トレイト [`Minfo`] を実装している必要があります。\n    ///\n    /// # Examples\n    ///\n    /// [`from_value`] によって、`Mint<Mod>` が作れます。\n    /// 逆に、[`value`] によって、中身がとれます。\n    ///\n    /// ```\n    /// use modint::Mint1000000007;\n    /// type Mint = Mint1000000007;\n    ///\n    /// let x: Mint = Mint::from_value(2);\n    ///\n    /// assert_eq!(x.value(), 2);\n    /// ```\n    ///\n    /// 四則演算ができます。\n    ///\n    /// ```\n    /// use modint::Mint1000000007;\n    /// type Mint = Mint1000000007;\n    ///\n    /// let x: Mint = Mint::from_value(6);\n    /// let y: Mint = Mint::from_value(2);\n    ///\n    /// assert_eq!((x + y).value(), 8);\n    /// assert_eq!((x - y).value(), 4);\n    /// assert_eq!((x * y).value(), 12);\n    /// assert_eq!((x / y).value(), 3);\n    /// ```\n    ///\n    /// [`value`]: #method.value\n    /// [`from_value`]: #method.from_value\n    /// [`Minfo`]:trait.Minfo.html\n\n    #[derive(Clone, Copy, Debug)]\n    pub struct Mint<Mod: Minfo>(Mod::Value);\n\n    impl<Mod: Minfo> Mint<Mod> {\n        #[inline]\n        #[allow(dead_code)]\n        fn is_within_the_range(x: Mod::Value) -> bool {\n            Mod::zero() <= x && x < Mod::modulus()\n        }\n\n        #[inline]\n        #[allow(dead_code)]\n        fn normalize(x: Mod::Value) -> Mod::Value {\n            if Self::is_within_the_range(x) {\n                x\n            } else {\n                let x = x % Mod::modulus();\n                if x < Mod::zero() {\n                    x + Mod::modulus()\n                } else {\n                    x\n                }\n            }\n        }\n\n        /// 0 を構築します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::zero();\n        /// assert_eq!(x.value(), 0);\n        /// ```\n        #[allow(dead_code)]\n        pub fn zero() -> Self {\n            Self(Mod::zero())\n        }\n\n        /// 1 を構築します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::one();\n        /// assert_eq!(x.value(), 1);\n        /// ```\n        #[allow(dead_code)]\n        pub fn one() -> Self {\n            Self(Mod::one())\n        }\n\n        /// mod を取得します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::modulus();\n        /// assert_eq!(x, 998244353);\n        /// ```\n        #[allow(dead_code)]\n        pub fn modulus() -> Mod::Value {\n            Mod::modulus()\n        }\n\n        /// 0 であるときに `true` を返します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::zero();\n        /// assert!(x.is_zero());\n        ///\n        /// let x = Mint::one();\n        /// assert!(!x.is_zero());\n        /// ```\n        #[allow(dead_code)]\n        pub fn is_zero(&self) -> bool {\n            self.value() == Mod::zero()\n        }\n\n        /// 構築します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::from_value(4);\n        /// ```\n        #[allow(dead_code)]\n        pub fn from_value(x: Mod::Value) -> Self {\n            Self(Self::normalize(x))\n        }\n\n        /// 中身を取得します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::from_value(4);\n        /// assert_eq!(x.value(), 4);\n        /// ```\n        #[allow(dead_code)]\n        pub fn value(&self) -> Mod::Value {\n            self.0\n        }\n\n        /// mod 逆元を計算します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::from_value(2);\n        /// assert_eq!(x.inv().value(), 499122177);\n        /// ```\n        #[allow(dead_code)]\n        pub fn inv(&self) -> Self {\n            if self.is_zero() {\n                panic!(\"inv(0)\");\n            }\n            Self(Self::raw_inv(self.value()))\n        }\n\n        /// ユークリッドの互除法を用いて、pow を計算します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// let x = Mint17::from_value(2);\n        /// assert_eq!(x.pow(6).value(), 64 % 17);\n        /// ```\n        #[allow(dead_code)]\n        pub fn pow(&self, b: u64) -> Self {\n            Self(Self::raw_pow(self.value(), b))\n        }\n\n        fn raw_add(x: Mod::Value, y: Mod::Value) -> Mod::Value {\n            let z = x + y;\n            if Mod::modulus() <= z {\n                z - Mod::modulus()\n            } else {\n                z\n            }\n        }\n\n        fn raw_sub(x: Mod::Value, y: Mod::Value) -> Mod::Value {\n            let z = x - y;\n            if z < Mod::zero() {\n                z + Mod::modulus()\n            } else {\n                z\n            }\n        }\n\n        fn raw_neg(x: Mod::Value) -> Mod::Value {\n            if x == Mod::zero() {\n                Mod::zero()\n            } else {\n                Mod::modulus() - x\n            }\n        }\n\n        fn raw_mul(x: Mod::Value, y: Mod::Value) -> Mod::Value {\n            x * y % Mod::modulus()\n        }\n\n        fn raw_div(x: Mod::Value, y: Mod::Value) -> Mod::Value {\n            Self::raw_mul(x, Self::raw_inv(y))\n        }\n\n        #[allow(clippy::many_single_char_names)]\n        fn raw_inv(mut x: Mod::Value) -> Mod::Value {\n            let mut y = Mod::modulus();\n            let mut u = Mod::one();\n            let mut v = Mod::zero();\n            while x != Mod::zero() {\n                let q = y / x;\n                y -= x * q;\n                v -= u * q;\n                std::mem::swap(&mut x, &mut y);\n                std::mem::swap(&mut u, &mut v);\n            }\n            if v < Mod::zero() {\n                v + Mod::modulus()\n            } else {\n                v\n            }\n        }\n\n        fn raw_pow(mut a: Mod::Value, mut b: u64) -> Mod::Value {\n            let mut x = Mod::one();\n            while 0 < b {\n                if b % 2 == 1 {\n                    x = Self::raw_mul(x, a);\n                }\n                a = Self::raw_mul(a, a);\n                b /= 2\n            }\n            x\n        }\n    }\n\n    macro_rules! impl_biop {\n    (\n        $(\n            $biop_trait: ident::$biop_fn: ident,\n            $biop_assign_trait: ident::$biop_assign_fn: ident,\n            $biop_impl: ident;\n        )*\n    ) => {\n        $(\n            impl<Mod: Minfo> std::ops::$biop_trait for Mint<Mod> {\n                type Output = Self;\n                fn $biop_fn(self, rhs: Self) -> Self::Output {\n                    Mint(Self::$biop_impl(self.value(), rhs.value()))\n                }\n            }\n            impl<Mod: Minfo> std::ops::$biop_assign_trait for Mint<Mod>\n            where\n                Self: Copy\n            {\n                fn $biop_assign_fn(&mut self, rhs: Self) {\n                    use std::ops::$biop_trait;\n                    *self = Mint::$biop_fn(*self, rhs)\n                }\n            }\n        )*\n    };\n}\n\n    impl_biop! {\n        Add::add, AddAssign::add_assign, raw_add;\n        Sub::sub, SubAssign::sub_assign, raw_sub;\n        Mul::mul, MulAssign::mul_assign, raw_mul;\n        Div::div, DivAssign::div_assign, raw_div;\n    }\n\n    impl<Mod: Minfo> std::ops::Neg for Mint<Mod> {\n        type Output = Self;\n        fn neg(self) -> Self::Output {\n            Self(Self::raw_neg(self.value()))\n        }\n    }\n\n    impl<Mod: Minfo> std::cmp::PartialEq for Mint<Mod> {\n        /// 中身をそのまま 比較です。\n        /// 構築時に normalize され、それ以降も normalized な状態に保たれますから、\n        /// 結局あまりを比較しているのと同じことになります。\n        ///\n        /// # Example\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// assert_eq!(Mint17::from_value(3), Mint::from_value(-31));\n        /// assert_eq!(Mint17::from_value(3), Mint::from_value(-14));\n        /// assert_eq!(Mint17::from_value(3), Mint::from_value(3));\n        /// assert_eq!(Mint17::from_value(3), Mint::from_value(20));\n        /// assert_eq!(Mint17::from_value(3), Mint::from_value(37));\n        ///\n        /// assert_ne!(Mint17::from_value(3), Mint::from_value(31));\n        /// assert_ne!(Mint17::from_value(3), Mint::from_value(14));\n        /// assert_ne!(Mint17::from_value(3), Mint::from_value(-3));\n        /// assert_ne!(Mint17::from_value(3), Mint::from_value(-20));\n        /// assert_ne!(Mint17::from_value(3), Mint::from_value(-37));\n        /// ```\n        fn eq(&self, other: &Self) -> bool {\n            self.value().eq(&other.value())\n        }\n    }\n    impl<Mod: Minfo> std::cmp::Eq for Mint<Mod> {}\n\n    impl<Mod: Minfo> std::fmt::Display for Mint<Mod> {\n        /// 中身をそのまま Display です。\n        ///\n        /// # Example\n        ///\n        /// ```\n        /// println!(\"{}\", modint::Mint998244353::from_value(42));\n        /// ```\n        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n            write!(f, \"{}\", self.value())\n        }\n    }\n\n    impl<Mod: Minfo> std::iter::Sum<Self> for Mint<Mod> {\n        /// 総和を取ります。\n        ///\n        /// # Example\n        ///\n        /// ```\n        /// use modint::{define_mint, Minfo, Mint};\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        /// assert_eq!(\n        ///     vec![\n        ///         Mint17::from_value(2),\n        ///         Mint17::from_value(4),\n        ///         Mint17::from_value(6),\n        ///         Mint17::from_value(8),\n        ///     ]\n        ///     .into_iter()\n        ///     .sum::<Mint17>(),\n        ///     Mint17::from_value(3)\n        /// );\n        /// ```\n        fn sum<I: Iterator<Item = Self>>(iter: I) -> Self {\n            iter.fold(Mint::zero(), |acc, x| acc + x)\n        }\n    }\n\n    impl<Mod: Minfo> std::iter::Product<Self> for Mint<Mod> {\n        /// 総積を取ります。\n        ///\n        /// # Example\n        ///\n        /// ```\n        /// use modint::{define_mint, Minfo, Mint};\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        /// assert_eq!(\n        ///     vec![\n        ///         Mint17::from_value(1),\n        ///         Mint17::from_value(2),\n        ///         Mint17::from_value(3),\n        ///         Mint17::from_value(4),\n        ///     ]\n        ///     .into_iter()\n        ///     .product::<Mint17>(),\n        ///     Mint17::from_value(7)\n        /// );\n        /// ```\n        fn product<I: Iterator<Item = Self>>(iter: I) -> Self {\n            iter.fold(Mint::one(), |acc, x| acc * x)\n        }\n    }\n\n    /// 階乗とその逆元を前計算するマシーンです。\n    #[allow(dead_code)]\n    pub struct Factorial<Mod: Minfo> {\n        normal: Vec<Mint<Mod>>,\n        inverted: Vec<Mint<Mod>>,\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo> Factorial<Mod>\n    where\n        Mod::Value: std::convert::TryFrom<usize, Error = std::num::TryFromIntError>,\n    {\n        /// サイズを指定して初期化です。\n        /// 最大値は一つ小さくなりますから、注意です。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, Factorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        /// let fact = Factorial::<Minfo17>::new(16);\n        /// ```\n        pub fn new(n: usize) -> Self {\n            use std::convert::TryFrom;\n            let mut normal = vec![Mint::one(); n];\n            for i in 1..n {\n                normal[i] = normal[i - 1] * Mint::from_value(Mod::Value::try_from(i).unwrap());\n            }\n            let mut inverted = vec![Mint::one(); n];\n            inverted[n - 1] = normal[n - 1].inv();\n            for i in (1..n).rev() {\n                inverted[i - 1] = inverted[i] * Mint::from_value(Mod::Value::try_from(i).unwrap());\n            }\n            Self { normal, inverted }\n        }\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo> Factorial<Mod> {\n        /// 階乗の逆元を取得します。\n        ///\n        /// 逆元でなくて普通の階乗は、[`implementations`] をご覧いただけると幸いです。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, Factorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// let fact = Factorial::<Minfo17>::new(17);\n        ///\n        /// for i in 0..17 {\n        ///     assert_eq!(fact[i] * fact.inverted(i), Mint17::one());\n        /// }\n        /// ```\n        ///\n        /// [`implementations`]: #implementations\n        ///\n        pub fn inverted(&self, i: usize) -> Mint<Mod> {\n            self.inverted[i]\n        }\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo, I: std::slice::SliceIndex<[Mint<Mod>]>> std::ops::Index<I> for Factorial<Mod> {\n        type Output = I::Output;\n\n        /// Index でも取ることができます。\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, Factorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// let fact = Factorial::<Minfo17>::new(17);\n        ///\n        /// assert_eq!(fact[0], Mint17::from_value(1));\n        /// assert_eq!(fact[1], Mint17::from_value(1));\n        /// assert_eq!(fact[2], Mint17::from_value(2));\n        /// assert_eq!(fact[3], Mint17::from_value(6));\n        /// assert_eq!(fact[4], Mint17::from_value(24 % 17));\n        /// assert_eq!(fact[5], Mint17::from_value(120 % 17));\n        /// ```\n        #[inline]\n        fn index(&self, index: I) -> &Self::Output {\n            &self.normal[index]\n        }\n    }\n\n    /// 二重階乗とその逆元を前計算するマシーンです。\n    #[allow(dead_code)]\n    pub struct DoubleFactorial<Mod: Minfo> {\n        normal: Vec<Mint<Mod>>,\n        inverted: Vec<Mint<Mod>>,\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo> DoubleFactorial<Mod>\n    where\n        Mod::Value: std::convert::TryFrom<usize, Error = std::num::TryFromIntError>,\n    {\n        /// サイズを指定して初期化です。\n        /// 最大値は一つ小さくなりますから、注意です。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, DoubleFactorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        /// let fact = DoubleFactorial::<Minfo17>::new(16);\n        /// ```\n        pub fn new(n: usize) -> Self {\n            use std::convert::TryFrom;\n            let mut normal = vec![Mint::one(); n];\n            for i in 2..n {\n                normal[i] = normal[i - 2] * Mint::from_value(Mod::Value::try_from(i).unwrap());\n            }\n            let mut inverted = vec![Mint::one(); n];\n            inverted[n - 1] = normal[n - 1].inv();\n            inverted[n - 2] = normal[n - 2].inv();\n            for i in (2..n).rev() {\n                inverted[i - 2] = inverted[i] * Mint::from_value(Mod::Value::try_from(i).unwrap());\n            }\n            Self { normal, inverted }\n        }\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo> DoubleFactorial<Mod> {\n        /// 二重階乗の逆元を取得します。\n        ///\n        /// 逆元でなくて普通の二重階乗は、[`implementations`] をご覧いただけると幸いです。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, DoubleFactorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// let fact = DoubleFactorial::<Minfo17>::new(17);\n        ///\n        /// for i in 0..17 {\n        ///     assert_eq!(fact[i] * fact.inverted(i), Mint17::one());\n        /// }\n        /// ```\n        ///\n        /// [`implementations`]: #implementations\n        ///\n        pub fn inverted(&self, i: usize) -> Mint<Mod> {\n            self.inverted[i]\n        }\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo, I: std::slice::SliceIndex<[Mint<Mod>]>> std::ops::Index<I>\n        for DoubleFactorial<Mod>\n    {\n        type Output = I::Output;\n\n        /// Index でも取ることができます。\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, DoubleFactorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// let fact = DoubleFactorial::<Minfo17>::new(17);\n        ///\n        /// assert_eq!(fact[0], Mint17::from_value(1));\n        /// assert_eq!(fact[1], Mint17::from_value(1));\n        /// assert_eq!(fact[2], Mint17::from_value(2));\n        /// assert_eq!(fact[3], Mint17::from_value(3));\n        /// assert_eq!(fact[4], Mint17::from_value(8));\n        /// assert_eq!(fact[5], Mint17::from_value(15));\n        /// ```\n        #[inline]\n        fn index(&self, index: I) -> &Self::Output {\n            &self.normal[index]\n        }\n    }\n\n    /// Mint 型を定義するためのマクロです。\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use modint::{define_mint, Minfo, Mint};\n    ///\n    /// define_mint! {\n    ///     struct Mint17(Minfo17(17; i64));\n    /// }\n    ///\n    /// let x = Mint17::from_value(1);\n    /// let y = Mint17::from_value(2);\n    /// let z = x / y;\n    /// assert_eq!(z.value(), 9);\n    /// ```\n    #[macro_export]\n    macro_rules! define_mint {\n        (\n        struct $modint: ident ($modinfo: ident ($modvalue: expr; $modty: ty));\n    ) => {\n            #[allow(dead_code)]\n            #[derive(Clone, Copy, Debug)]\n            pub struct $modinfo {}\n            impl Minfo for $modinfo {\n                type Value = $modty;\n                fn modulus() -> Self::Value {\n                    $modvalue\n                }\n                fn zero() -> Self::Value {\n                    0\n                }\n                fn one() -> Self::Value {\n                    1\n                }\n            }\n            type $modint = Mint<$modinfo>;\n        };\n    }\n\n    /// Mod = 1000000007 なる Minfo です。\n    #[allow(dead_code)]\n    #[derive(Clone, Copy, Debug)]\n    pub struct Minfo1000000007 {}\n\n    impl Minfo for Minfo1000000007 {\n        type Value = i64;\n        fn modulus() -> Self::Value {\n            1_000_000_007\n        }\n        fn zero() -> Self::Value {\n            0\n        }\n        fn one() -> Self::Value {\n            1\n        }\n    }\n\n    /// Mod = 1000000007 なる Mint です。\n    #[allow(dead_code)]\n    pub type Mint1000000007 = Mint<Minfo1000000007>;\n\n    /// Mod = 998244353 なる Minfo です。\n    #[allow(dead_code)]\n    #[derive(Clone, Copy, Debug)]\n    pub struct Minfo998244353 {}\n\n    impl Minfo for Minfo998244353 {\n        type Value = i64;\n        fn modulus() -> Self::Value {\n            998_244_353\n        }\n        fn zero() -> Self::Value {\n            0\n        }\n        fn one() -> Self::Value {\n            1\n        }\n    }\n\n    /// Mod = 998244353 なる Mint です。\n    #[allow(dead_code)]\n    pub type Mint998244353 = Mint<Minfo998244353>;\n}\n//}}}\n\ntype Mint = modint::Mint998244353;\n\nfn main() {\n    input!(n: usize, mut s: Chars);\n    s.reverse();\n    let make = |x: Mint| -> Vec<(Mint, Mint)> {\n        let xinv = x.inv();\n        let mut ans = vec![(Mint::one(), Mint::zero()); n + 1];\n        for (i, &c) in s.iter().enumerate() {\n            let (a, b) = ans[i];\n            ans[i + 1] = match c {\n                '+' => (a, b + Mint::one()),\n                '-' => (a, b - Mint::one()),\n                '<' => (a * x, b * x),\n                '>' => (a * xinv, b * xinv),\n                _ => panic!(),\n            }\n        }\n        ans\n    };\n\n    let keys: Vec<_> = (1..6)\n        .map(|i| i * 10_000_000)\n        .map(Mint::from_value)\n        .collect();\n    let seqs: Vec<_> = keys.iter().copied().map(make).collect();\n    let mut hash_map = std::collections::HashMap::<Vec<_>, _>::new();\n    let mut ans = 0;\n    for i in 0..=n {\n        if let Some(x) = hash_map.get(\n            &(0..keys.len())\n                .map(|j| {\n                    let (a, b) = seqs[j][i];\n                    ((b - seqs[j][n].1) / a).value()\n                })\n                .collect::<Vec<_>>(),\n        ) {\n            ans += x;\n        }\n        *hash_map\n            .entry(\n                (0..keys.len())\n                    .map(|j| {\n                        let (a, b) = seqs[j][i];\n                        (b / a).value()\n                    })\n                    .collect(),\n            )\n            .or_insert(0) += 1;\n    }\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::Read;\n#[allow(dead_code)]\nfn getline() -> String {\n    let mut ret = String::new();\n    std::io::stdin().read_line(&mut ret).ok().unwrap();\n    ret\n}\nfn get_word() -> String {\n    let mut stdin = std::io::stdin();\n    let mut u8b: [u8; 1] = [0];\n    loop {\n        let mut buf: Vec<u8> = Vec::with_capacity(16);\n        loop {\n            let res = stdin.read(&mut u8b);\n            if res.unwrap_or(0) == 0 || u8b[0] <= b' ' {\n                break;\n            } else {\n                buf.push(u8b[0]);\n            }\n        }\n        if buf.len() >= 1 {\n            let ret = String::from_utf8(buf).unwrap();\n            return ret;\n        }\n    }\n}\n\n#[allow(dead_code)]\nfn get<T: std::str::FromStr>() -> T { get_word().parse().ok().unwrap() }\n\nconst MOD: i64 = 1_000_000_009;\n\n/// Refers external ::MOD.\nmod mod_int {\n    use ::MOD;\n    use std::ops::*;\n    #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]\n    pub struct ModInt {\n        pub x: i64,\n    }\n    impl ModInt {\n        pub fn new(x: i64) -> Self { ModInt { x: x % MOD } }\n        #[allow(dead_code)]\n        pub fn mul_fast(self, others: Self) -> Self {\n            Self::new(self.x * others.x % MOD)\n        }\n        pub fn pow(self, mut e: i64) -> Self {\n            let mut sum = ModInt::new(1);\n            let mut cur = ModInt::new(self.x);\n            while e > 0 {\n                if e % 2 != 0 {\n                    sum = sum * cur;\n                }\n                cur = cur * cur;\n                e /= 2;\n            }\n            sum\n        }\n        pub fn inv(self) -> Self {\n            self.pow(MOD - 2)\n        }\n    }\n    impl Add for ModInt {\n        type Output = Self;\n        fn add(self, others: Self) -> Self {\n            let mut sum = self.x + others.x;\n            if sum >= MOD {\n                sum -= MOD;\n            }\n            Self::new(sum)\n        }\n    }\n    impl Sub for ModInt {\n        type Output = Self;\n        fn sub(self, others: Self) -> Self {\n            let mut sum = self.x - others.x;\n            if sum < 0 {\n                sum += MOD;\n            }\n            Self::new(sum)\n        }\n    }\n    impl Mul for ModInt {\n        type Output = Self;\n        fn mul(self, others: Self) -> Self {\n            // Naive multiplication in order to avoid overflow\n            let mut sum = 0;\n            let mut cur = self.x;\n            let mut e = others.x;\n            if self.x < others.x {\n                cur = others.x;\n                e = self.x;\n            }\n            while e > 0 {\n                if e % 2 == 1 {\n                    sum += cur;\n                    if sum >= MOD {\n                        sum -= MOD;\n                    }\n                }\n                cur *= 2;\n                if cur >= MOD {\n                    cur -= MOD;\n                }\n                e /= 2;\n            }\n            Self::new(sum)\n        }\n    }\n} // mod mod_int\n\n\nfn solve() {\n    use mod_int::*;\n    let n: usize = get();\n    let s: Vec<_> = get_word().chars().collect();\n    const A: usize = 3;\n    let b = [ModInt::new(41), ModInt::new(255), ModInt::new(36)];\n    let mut hsh = vec![vec![ModInt::new(0); n + 1]; A];\n    let mut inv = [ModInt::new(0); A];\n    for i in 0 .. A { inv[i] = b[i].inv(); }\n    let mut pos = vec![0; n + 1];\n    for c in 0 .. A {\n        let mut p = 0;\n        let mut cur = ModInt::new(1);\n        for (i, &ch) in s.iter().enumerate() {\n            let mut tmp = hsh[c][i];\n            match ch {\n                '>' => {\n                    p += 1;\n                    cur = cur * b[c];\n                },\n                '<' => {\n                    p -= 1;\n                    cur = cur * inv[c];\n                },\n                '+' => tmp = tmp + cur,\n                '-' => tmp = tmp - cur,\n                _ => panic!(),\n            }\n            hsh[c][i + 1] = tmp;\n            pos[i + 1] = p;\n        }\n    }\n    let mut meguru = [ModInt::new(0); A];\n    for c in 0 .. A { meguru[c] = hsh[c][n]; }\n    let mut kirika = HashMap::new();\n    kirika.insert(meguru, 1);\n    let mut tot = 0;\n    for i in (0 .. n).rev() {\n        let mut cur = [ModInt::new(0); A];\n        for c in 0 .. A { cur[c] = b[c].pow(MOD - 1 + pos[i]); }\n        let mut ken = [ModInt::new(0); A];\n        for c in 0 .. A { ken[c] = cur[c] * meguru[c] + hsh[c][i]; }\n        tot += kirika.get(&ken).cloned().unwrap_or(0);\n        let mut tt = [ModInt::new(0); A];\n        for c in 0 .. A { tt[c] = hsh[c][i]; }\n        *kirika.entry(tt).or_insert(0) += 1;\n    }\n    println!(\"{}\", tot);\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "// use std::cmp;\n// use std::collections::HashMap;\n// use std::collections::HashSet;\n// use std::collections::VecDeque;\nuse std::collections::BTreeMap;\n\n\n// const INF: i64 = 1_000_000_000;\n\nconst MOD: i64 = 1_000_000_009;\n\n\nfn invmod(a: i64, p: i64) -> i64 {\n    if a == 1 {\n        return 1;\n    } else {\n        return (1 - p*invmod(p%a, a)) / a + p;\n    }\n}\n\n\nfn eat(ch: char, tape: &mut Vec<i64>, pos: &mut Vec<i64>, X: &Vec<i64>, Xinv: &Vec<i64>) {\n    match ch {\n        '+' => {\n            for i in 0..4 {\n                tape[i] += pos[i];\n                tape[i] %= MOD;\n            }\n        }\n        '-' => {\n            for i in 0..4 {\n                tape[i] -= pos[i];\n                tape[i] += MOD;\n                tape[i] %= MOD;\n            }\n        }\n        '>' => {\n            for i in 0..4 {\n                pos[i] *= X[i];\n                pos[i] %= MOD;\n            }\n        }\n        '<' => {\n            for i in 0..4 {\n                pos[i] *= Xinv[i];\n                pos[i] %= MOD;\n            }\n        }\n        _ => panic!()\n    }\n}\n\n\n\nfn main() {\n    let cin = stdin();\n    let cin = cin.lock();\n    let mut sc = Scanner::new(cin);\n\n    let X: Vec<i64> = vec![31, 41, 592, 653];\n    let mut Xinv: Vec<i64> = vec![];\n    for i in 0..4 {\n        Xinv.push(invmod(X[i], MOD));\n    }\n    let Xinv = Xinv;\n    //println!(\"{:?}, {:?}\", X, Xinv);\n\n    let n: usize = sc.read();\n    let s: String = sc.read();\n    let s = s.chars().collect::<Vec<_>>();\n    //println!(\"{}, {:?}\", n, s);\n    let mut tape = vec![0, 0, 0, 0];\n    let mut pos = vec![1, 1, 1, 1];\n    for &ch in s.iter() {\n        eat(ch, &mut tape, &mut pos, &X, &Xinv);\n    }\n    let target = tape;\n    //println!(\"{:?}\", target);\n    let mut goals = BTreeMap::new();\n    let mut tape = vec![0, 0, 0, 0];\n    let mut pos = vec![1, 1, 1, 1];\n    let mut ans: i64 = 0;\n    for &ch in s.iter() {\n        {\n            let mut goal: Vec<i64> = vec![];\n            for i in 0..4 {\n                goal.push((tape[i] + pos[i] * target[i]) % MOD);\n            }\n            let cnt = goals.remove(&goal).unwrap_or(0);\n            goals.insert(goal, cnt+1);\n        }\n        eat(ch, &mut tape, &mut pos, &X, &Xinv);\n        ans += *(goals.get(&tape).unwrap_or(&0));\n        //println!(\"{:?}\", goals);\n    }\n    println!(\"{}\", ans);\n}\n\n// thanks, ir5\nuse std::io::{stdin, Read, StdinLock};\nuse std::str::FromStr;\n\nstruct Scanner<'a> {\n    cin: StdinLock<'a>,\n}\n\nimpl<'a> Scanner<'a> {\n    fn new(cin: StdinLock<'a>) -> Scanner<'a> {\n        Scanner { cin: cin }\n    }\n\n    fn read1<T: FromStr>(&mut self) -> Option<T> {\n        let token = self.cin\n            .by_ref()\n            .bytes()\n            .map(|c| c.unwrap() as char)\n            .skip_while(|c| c.is_whitespace())\n            .take_while(|c| !c.is_whitespace())\n            .collect::<String>();\n        token.parse::<T>().ok()\n    }\n\n    fn read<T: FromStr>(&mut self) -> T {\n        self.read1().unwrap()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use proconio::{input, marker::Chars};\n\n// modint{{{\nmod modint {\n    //! [`Mint`] 型を提供します。\n    //!\n    //! [`Mint`]: struct.Mint.html\n\n    /// [`Mint`] の中に入れる数値型が実装していないといけないトレイトをまとめました。\n    ///\n    /// どうやら普通の符号付き整数型ならば大丈夫そうですね。\n    ///\n    /// いかがでしたでしょうか？（真顔）\n    ///\n    /// [`Mint`]: struct.Mint.html\n    pub trait ModValue:\n        std::ops::Add<Output = Self>\n        + std::ops::Sub<Output = Self>\n        + std::ops::Mul<Output = Self>\n        + std::ops::Div<Output = Self>\n        + std::ops::Rem<Output = Self>\n        + std::ops::AddAssign\n        + std::ops::SubAssign\n        + std::ops::MulAssign\n        + std::ops::DivAssign\n        + std::ops::RemAssign\n        + std::ops::Neg\n        + std::cmp::Ord\n        + Clone\n        + Copy\n        + Sized\n        + std::fmt::Debug\n        + std::fmt::Display\n    {\n    }\n\n    impl<\n            Value: std::ops::Add<Output = Self>\n                + std::ops::Sub<Output = Self>\n                + std::ops::Mul<Output = Self>\n                + std::ops::Div<Output = Self>\n                + std::ops::Rem<Output = Self>\n                + std::ops::AddAssign\n                + std::ops::SubAssign\n                + std::ops::MulAssign\n                + std::ops::DivAssign\n                + std::ops::RemAssign\n                + std::ops::Neg\n                + std::cmp::Ord\n                + Clone\n                + Copy\n                + Sized\n                + std::fmt::Debug\n                + std::fmt::Display,\n        > ModValue for Value\n    {\n    }\n\n    /// mod に関数情報を [`Mint`] に伝えるための型引数だッピ！\n    ///\n    /// [`Mint`]: struct.Mint.html\n    pub trait Minfo: Clone + Copy + std::fmt::Debug {\n        /// 中身の型です。\n        type Value: ModValue;\n\n        /// mod の値を返します。\n        fn modulus() -> Self::Value;\n\n        /// 0 を返します。\n        fn zero() -> Self::Value;\n\n        /// 1 を返します。\n        fn one() -> Self::Value;\n    }\n\n    /// 自動で mod を取ってくれる整数型です。\n    ///\n    /// 型引数は、トレイト [`Minfo`] を実装している必要があります。\n    ///\n    /// # Examples\n    ///\n    /// [`from_value`] によって、`Mint<Mod>` が作れます。\n    /// 逆に、[`value`] によって、中身がとれます。\n    ///\n    /// ```\n    /// use modint::Mint1000000007;\n    /// type Mint = Mint1000000007;\n    ///\n    /// let x: Mint = Mint::from_value(2);\n    ///\n    /// assert_eq!(x.value(), 2);\n    /// ```\n    ///\n    /// 四則演算ができます。\n    ///\n    /// ```\n    /// use modint::Mint1000000007;\n    /// type Mint = Mint1000000007;\n    ///\n    /// let x: Mint = Mint::from_value(6);\n    /// let y: Mint = Mint::from_value(2);\n    ///\n    /// assert_eq!((x + y).value(), 8);\n    /// assert_eq!((x - y).value(), 4);\n    /// assert_eq!((x * y).value(), 12);\n    /// assert_eq!((x / y).value(), 3);\n    /// ```\n    ///\n    /// [`value`]: #method.value\n    /// [`from_value`]: #method.from_value\n    /// [`Minfo`]:trait.Minfo.html\n\n    #[derive(Clone, Copy, Debug)]\n    pub struct Mint<Mod: Minfo>(Mod::Value);\n\n    impl<Mod: Minfo> Mint<Mod> {\n        #[inline]\n        #[allow(dead_code)]\n        fn is_within_the_range(x: Mod::Value) -> bool {\n            Mod::zero() <= x && x < Mod::modulus()\n        }\n\n        #[inline]\n        #[allow(dead_code)]\n        fn normalize(x: Mod::Value) -> Mod::Value {\n            if Self::is_within_the_range(x) {\n                x\n            } else {\n                let x = x % Mod::modulus();\n                if x < Mod::zero() {\n                    x + Mod::modulus()\n                } else {\n                    x\n                }\n            }\n        }\n\n        /// 0 を構築します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::zero();\n        /// assert_eq!(x.value(), 0);\n        /// ```\n        #[allow(dead_code)]\n        pub fn zero() -> Self {\n            Self(Mod::zero())\n        }\n\n        /// 1 を構築します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::one();\n        /// assert_eq!(x.value(), 1);\n        /// ```\n        #[allow(dead_code)]\n        pub fn one() -> Self {\n            Self(Mod::one())\n        }\n\n        /// mod を取得します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::modulus();\n        /// assert_eq!(x, 998244353);\n        /// ```\n        #[allow(dead_code)]\n        pub fn modulus() -> Mod::Value {\n            Mod::modulus()\n        }\n\n        /// 0 であるときに `true` を返します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::zero();\n        /// assert!(x.is_zero());\n        ///\n        /// let x = Mint::one();\n        /// assert!(!x.is_zero());\n        /// ```\n        #[allow(dead_code)]\n        pub fn is_zero(&self) -> bool {\n            self.value() == Mod::zero()\n        }\n\n        /// 構築します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::from_value(4);\n        /// ```\n        #[allow(dead_code)]\n        pub fn from_value(x: Mod::Value) -> Self {\n            Self(Self::normalize(x))\n        }\n\n        /// 中身を取得します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::from_value(4);\n        /// assert_eq!(x.value(), 4);\n        /// ```\n        #[allow(dead_code)]\n        pub fn value(&self) -> Mod::Value {\n            self.0\n        }\n\n        /// mod 逆元を計算します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::from_value(2);\n        /// assert_eq!(x.inv().value(), 499122177);\n        /// ```\n        #[allow(dead_code)]\n        pub fn inv(&self) -> Self {\n            if self.is_zero() {\n                panic!(\"inv(0)\");\n            }\n            Self(Self::raw_inv(self.value()))\n        }\n\n        /// ユークリッドの互除法を用いて、pow を計算します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// let x = Mint17::from_value(2);\n        /// assert_eq!(x.pow(6).value(), 64 % 17);\n        /// ```\n        #[allow(dead_code)]\n        pub fn pow(&self, b: u64) -> Self {\n            Self(Self::raw_pow(self.value(), b))\n        }\n\n        fn raw_add(x: Mod::Value, y: Mod::Value) -> Mod::Value {\n            let z = x + y;\n            if Mod::modulus() <= z {\n                z - Mod::modulus()\n            } else {\n                z\n            }\n        }\n\n        fn raw_sub(x: Mod::Value, y: Mod::Value) -> Mod::Value {\n            let z = x - y;\n            if z < Mod::zero() {\n                z + Mod::modulus()\n            } else {\n                z\n            }\n        }\n\n        fn raw_neg(x: Mod::Value) -> Mod::Value {\n            if x == Mod::zero() {\n                Mod::zero()\n            } else {\n                Mod::modulus() - x\n            }\n        }\n\n        fn raw_mul(x: Mod::Value, y: Mod::Value) -> Mod::Value {\n            x * y % Mod::modulus()\n        }\n\n        fn raw_div(x: Mod::Value, y: Mod::Value) -> Mod::Value {\n            Self::raw_mul(x, Self::raw_inv(y))\n        }\n\n        #[allow(clippy::many_single_char_names)]\n        fn raw_inv(mut x: Mod::Value) -> Mod::Value {\n            let mut y = Mod::modulus();\n            let mut u = Mod::one();\n            let mut v = Mod::zero();\n            while x != Mod::zero() {\n                let q = y / x;\n                y -= x * q;\n                v -= u * q;\n                std::mem::swap(&mut x, &mut y);\n                std::mem::swap(&mut u, &mut v);\n            }\n            if v < Mod::zero() {\n                v + Mod::modulus()\n            } else {\n                v\n            }\n        }\n\n        fn raw_pow(mut a: Mod::Value, mut b: u64) -> Mod::Value {\n            let mut x = Mod::one();\n            while 0 < b {\n                if b % 2 == 1 {\n                    x = Self::raw_mul(x, a);\n                }\n                a = Self::raw_mul(a, a);\n                b /= 2\n            }\n            x\n        }\n    }\n\n    macro_rules! impl_biop {\n    (\n        $(\n            $biop_trait: ident::$biop_fn: ident,\n            $biop_assign_trait: ident::$biop_assign_fn: ident,\n            $biop_impl: ident;\n        )*\n    ) => {\n        $(\n            impl<Mod: Minfo> std::ops::$biop_trait for Mint<Mod> {\n                type Output = Self;\n                fn $biop_fn(self, rhs: Self) -> Self::Output {\n                    Mint(Self::$biop_impl(self.value(), rhs.value()))\n                }\n            }\n            impl<Mod: Minfo> std::ops::$biop_assign_trait for Mint<Mod>\n            where\n                Self: Copy\n            {\n                fn $biop_assign_fn(&mut self, rhs: Self) {\n                    use std::ops::$biop_trait;\n                    *self = Mint::$biop_fn(*self, rhs)\n                }\n            }\n        )*\n    };\n}\n\n    impl_biop! {\n        Add::add, AddAssign::add_assign, raw_add;\n        Sub::sub, SubAssign::sub_assign, raw_sub;\n        Mul::mul, MulAssign::mul_assign, raw_mul;\n        Div::div, DivAssign::div_assign, raw_div;\n    }\n\n    impl<Mod: Minfo> std::ops::Neg for Mint<Mod> {\n        type Output = Self;\n        fn neg(self) -> Self::Output {\n            Self(Self::raw_neg(self.value()))\n        }\n    }\n\n    impl<Mod: Minfo> std::cmp::PartialEq for Mint<Mod> {\n        /// 中身をそのまま 比較です。\n        /// 構築時に normalize され、それ以降も normalized な状態に保たれますから、\n        /// 結局あまりを比較しているのと同じことになります。\n        ///\n        /// # Example\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// assert_eq!(Mint17::from_value(3), Mint::from_value(-31));\n        /// assert_eq!(Mint17::from_value(3), Mint::from_value(-14));\n        /// assert_eq!(Mint17::from_value(3), Mint::from_value(3));\n        /// assert_eq!(Mint17::from_value(3), Mint::from_value(20));\n        /// assert_eq!(Mint17::from_value(3), Mint::from_value(37));\n        ///\n        /// assert_ne!(Mint17::from_value(3), Mint::from_value(31));\n        /// assert_ne!(Mint17::from_value(3), Mint::from_value(14));\n        /// assert_ne!(Mint17::from_value(3), Mint::from_value(-3));\n        /// assert_ne!(Mint17::from_value(3), Mint::from_value(-20));\n        /// assert_ne!(Mint17::from_value(3), Mint::from_value(-37));\n        /// ```\n        fn eq(&self, other: &Self) -> bool {\n            self.value().eq(&other.value())\n        }\n    }\n    impl<Mod: Minfo> std::cmp::Eq for Mint<Mod> {}\n\n    impl<Mod: Minfo> std::fmt::Display for Mint<Mod> {\n        /// 中身をそのまま Display です。\n        ///\n        /// # Example\n        ///\n        /// ```\n        /// println!(\"{}\", modint::Mint998244353::from_value(42));\n        /// ```\n        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n            write!(f, \"{}\", self.value())\n        }\n    }\n\n    impl<Mod: Minfo> std::iter::Sum<Self> for Mint<Mod> {\n        /// 総和を取ります。\n        ///\n        /// # Example\n        ///\n        /// ```\n        /// use modint::{define_mint, Minfo, Mint};\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        /// assert_eq!(\n        ///     vec![\n        ///         Mint17::from_value(2),\n        ///         Mint17::from_value(4),\n        ///         Mint17::from_value(6),\n        ///         Mint17::from_value(8),\n        ///     ]\n        ///     .into_iter()\n        ///     .sum::<Mint17>(),\n        ///     Mint17::from_value(3)\n        /// );\n        /// ```\n        fn sum<I: Iterator<Item = Self>>(iter: I) -> Self {\n            iter.fold(Mint::zero(), |acc, x| acc + x)\n        }\n    }\n\n    impl<Mod: Minfo> std::iter::Product<Self> for Mint<Mod> {\n        /// 総積を取ります。\n        ///\n        /// # Example\n        ///\n        /// ```\n        /// use modint::{define_mint, Minfo, Mint};\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        /// assert_eq!(\n        ///     vec![\n        ///         Mint17::from_value(1),\n        ///         Mint17::from_value(2),\n        ///         Mint17::from_value(3),\n        ///         Mint17::from_value(4),\n        ///     ]\n        ///     .into_iter()\n        ///     .product::<Mint17>(),\n        ///     Mint17::from_value(7)\n        /// );\n        /// ```\n        fn product<I: Iterator<Item = Self>>(iter: I) -> Self {\n            iter.fold(Mint::one(), |acc, x| acc * x)\n        }\n    }\n\n    /// 階乗とその逆元を前計算するマシーンです。\n    #[allow(dead_code)]\n    pub struct Factorial<Mod: Minfo> {\n        normal: Vec<Mint<Mod>>,\n        inverted: Vec<Mint<Mod>>,\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo> Factorial<Mod>\n    where\n        Mod::Value: std::convert::TryFrom<usize, Error = std::num::TryFromIntError>,\n    {\n        /// サイズを指定して初期化です。\n        /// 最大値は一つ小さくなりますから、注意です。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, Factorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        /// let fact = Factorial::<Minfo17>::new(16);\n        /// ```\n        pub fn new(n: usize) -> Self {\n            use std::convert::TryFrom;\n            let mut normal = vec![Mint::one(); n];\n            for i in 1..n {\n                normal[i] = normal[i - 1] * Mint::from_value(Mod::Value::try_from(i).unwrap());\n            }\n            let mut inverted = vec![Mint::one(); n];\n            inverted[n - 1] = normal[n - 1].inv();\n            for i in (1..n).rev() {\n                inverted[i - 1] = inverted[i] * Mint::from_value(Mod::Value::try_from(i).unwrap());\n            }\n            Self { normal, inverted }\n        }\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo> Factorial<Mod> {\n        /// 階乗の逆元を取得します。\n        ///\n        /// 逆元でなくて普通の階乗は、[`implementations`] をご覧いただけると幸いです。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, Factorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// let fact = Factorial::<Minfo17>::new(17);\n        ///\n        /// for i in 0..17 {\n        ///     assert_eq!(fact[i] * fact.inverted(i), Mint17::one());\n        /// }\n        /// ```\n        ///\n        /// [`implementations`]: #implementations\n        ///\n        pub fn inverted(&self, i: usize) -> Mint<Mod> {\n            self.inverted[i]\n        }\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo, I: std::slice::SliceIndex<[Mint<Mod>]>> std::ops::Index<I> for Factorial<Mod> {\n        type Output = I::Output;\n\n        /// Index でも取ることができます。\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, Factorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// let fact = Factorial::<Minfo17>::new(17);\n        ///\n        /// assert_eq!(fact[0], Mint17::from_value(1));\n        /// assert_eq!(fact[1], Mint17::from_value(1));\n        /// assert_eq!(fact[2], Mint17::from_value(2));\n        /// assert_eq!(fact[3], Mint17::from_value(6));\n        /// assert_eq!(fact[4], Mint17::from_value(24 % 17));\n        /// assert_eq!(fact[5], Mint17::from_value(120 % 17));\n        /// ```\n        #[inline]\n        fn index(&self, index: I) -> &Self::Output {\n            &self.normal[index]\n        }\n    }\n\n    /// 二重階乗とその逆元を前計算するマシーンです。\n    #[allow(dead_code)]\n    pub struct DoubleFactorial<Mod: Minfo> {\n        normal: Vec<Mint<Mod>>,\n        inverted: Vec<Mint<Mod>>,\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo> DoubleFactorial<Mod>\n    where\n        Mod::Value: std::convert::TryFrom<usize, Error = std::num::TryFromIntError>,\n    {\n        /// サイズを指定して初期化です。\n        /// 最大値は一つ小さくなりますから、注意です。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, DoubleFactorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        /// let fact = DoubleFactorial::<Minfo17>::new(16);\n        /// ```\n        pub fn new(n: usize) -> Self {\n            use std::convert::TryFrom;\n            let mut normal = vec![Mint::one(); n];\n            for i in 2..n {\n                normal[i] = normal[i - 2] * Mint::from_value(Mod::Value::try_from(i).unwrap());\n            }\n            let mut inverted = vec![Mint::one(); n];\n            inverted[n - 1] = normal[n - 1].inv();\n            inverted[n - 2] = normal[n - 2].inv();\n            for i in (2..n).rev() {\n                inverted[i - 2] = inverted[i] * Mint::from_value(Mod::Value::try_from(i).unwrap());\n            }\n            Self { normal, inverted }\n        }\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo> DoubleFactorial<Mod> {\n        /// 二重階乗の逆元を取得します。\n        ///\n        /// 逆元でなくて普通の二重階乗は、[`implementations`] をご覧いただけると幸いです。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, DoubleFactorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// let fact = DoubleFactorial::<Minfo17>::new(17);\n        ///\n        /// for i in 0..17 {\n        ///     assert_eq!(fact[i] * fact.inverted(i), Mint17::one());\n        /// }\n        /// ```\n        ///\n        /// [`implementations`]: #implementations\n        ///\n        pub fn inverted(&self, i: usize) -> Mint<Mod> {\n            self.inverted[i]\n        }\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo, I: std::slice::SliceIndex<[Mint<Mod>]>> std::ops::Index<I>\n        for DoubleFactorial<Mod>\n    {\n        type Output = I::Output;\n\n        /// Index でも取ることができます。\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, DoubleFactorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// let fact = DoubleFactorial::<Minfo17>::new(17);\n        ///\n        /// assert_eq!(fact[0], Mint17::from_value(1));\n        /// assert_eq!(fact[1], Mint17::from_value(1));\n        /// assert_eq!(fact[2], Mint17::from_value(2));\n        /// assert_eq!(fact[3], Mint17::from_value(3));\n        /// assert_eq!(fact[4], Mint17::from_value(8));\n        /// assert_eq!(fact[5], Mint17::from_value(15));\n        /// ```\n        #[inline]\n        fn index(&self, index: I) -> &Self::Output {\n            &self.normal[index]\n        }\n    }\n\n    /// Mint 型を定義するためのマクロです。\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use modint::{define_mint, Minfo, Mint};\n    ///\n    /// define_mint! {\n    ///     struct Mint17(Minfo17(17; i64));\n    /// }\n    ///\n    /// let x = Mint17::from_value(1);\n    /// let y = Mint17::from_value(2);\n    /// let z = x / y;\n    /// assert_eq!(z.value(), 9);\n    /// ```\n    #[macro_export]\n    macro_rules! define_mint {\n        (\n        struct $modint: ident ($modinfo: ident ($modvalue: expr; $modty: ty));\n    ) => {\n            #[allow(dead_code)]\n            #[derive(Clone, Copy, Debug)]\n            pub struct $modinfo {}\n            impl Minfo for $modinfo {\n                type Value = $modty;\n                fn modulus() -> Self::Value {\n                    $modvalue\n                }\n                fn zero() -> Self::Value {\n                    0\n                }\n                fn one() -> Self::Value {\n                    1\n                }\n            }\n            type $modint = Mint<$modinfo>;\n        };\n    }\n\n    /// Mod = 1000000007 なる Minfo です。\n    #[allow(dead_code)]\n    #[derive(Clone, Copy, Debug)]\n    pub struct Minfo1000000007 {}\n\n    impl Minfo for Minfo1000000007 {\n        type Value = i64;\n        fn modulus() -> Self::Value {\n            1_000_000_007\n        }\n        fn zero() -> Self::Value {\n            0\n        }\n        fn one() -> Self::Value {\n            1\n        }\n    }\n\n    /// Mod = 1000000007 なる Mint です。\n    #[allow(dead_code)]\n    pub type Mint1000000007 = Mint<Minfo1000000007>;\n\n    /// Mod = 998244353 なる Minfo です。\n    #[allow(dead_code)]\n    #[derive(Clone, Copy, Debug)]\n    pub struct Minfo998244353 {}\n\n    impl Minfo for Minfo998244353 {\n        type Value = i64;\n        fn modulus() -> Self::Value {\n            998_244_353\n        }\n        fn zero() -> Self::Value {\n            0\n        }\n        fn one() -> Self::Value {\n            1\n        }\n    }\n\n    /// Mod = 998244353 なる Mint です。\n    #[allow(dead_code)]\n    pub type Mint998244353 = Mint<Minfo998244353>;\n}\n//}}}\n\ntype Mint = modint::Mint998244353;\n\nfn main() {\n    input!(n: usize, mut s: Chars);\n    s.reverse();\n    let make = |x: Mint| -> Vec<(Mint, Mint)> {\n        let xinv = x.inv();\n        let mut ans = vec![(Mint::one(), Mint::zero()); n + 1];\n        for (i, &c) in s.iter().enumerate() {\n            let (a, b) = ans[i];\n            ans[i + 1] = match c {\n                '+' => (a, b + Mint::one()),\n                '-' => (a, b - Mint::one()),\n                '<' => (a * x, b * x),\n                '>' => (a * xinv, b * xinv),\n                _ => panic!(),\n            }\n        }\n        ans\n    };\n\n    let keys: Vec<_> = (1..6)\n        .map(|i| i * 10_000_000)\n        .map(Mint::from_value)\n        .collect();\n    let seqs: Vec<_> = keys.iter().copied().map(make).collect();\n    let mut hash_map = std::collections::HashMap::<Vec<_>, _>::new();\n    let mut ans = 0;\n    for i in 0..=n {\n        if let Some(x) = hash_map.get(\n            &(0..keys.len())\n                .map(|j| {\n                    let (a, b) = seqs[j][i];\n                    if a.is_zero() {\n                        None\n                    } else {\n                        Some(((b - seqs[j][n].1) / a).value())\n                    }\n                })\n                .collect::<Vec<_>>(),\n        ) {\n            ans += x;\n        }\n        *hash_map\n            .entry(\n                (0..keys.len())\n                    .map(|j| {\n                        let (a, b) = seqs[j][i];\n                        if a.is_zero() {\n                            None\n                        } else {\n                            Some((b / a).value())\n                        }\n                    })\n                    .collect(),\n            )\n            .or_insert(0) += 1;\n    }\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::collections::HashMap;\nuse std::io::*;\nuse std::str::FromStr;\n\n#[allow(dead_code)]\nfn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let stdin = stdin.lock();\n    let token: String = stdin\n        .bytes()\n        .map(|c| c.expect(\"failed to read char\") as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n    token.parse().ok().expect(\"failed to parse token\")\n}\n\n#[allow(dead_code)]\nstruct XorShift {\n    x: u32,\n    y: u32,\n    z: u32,\n    w: u32,\n}\n#[allow(dead_code)]\nimpl XorShift {\n    fn new() -> XorShift {\n        XorShift {\n            x: 0x34fb2383,\n            y: 0x327328fa,\n            z: 0xabd4b54a,\n            w: 0xa9dba8d1,\n        }\n    }\n    fn seed(s: u32) -> XorShift {\n        let mut rnd = XorShift::new();\n        rnd.w = s;\n        rnd\n    }\n    fn xor128(&mut self) -> u32 {\n        let t = self.x ^ (self.x << 11);\n        self.x = self.y;\n        self.y = self.z;\n        self.z = self.w;\n        self.w = (self.w ^ (self.w >> 19)) ^ (t ^ (t >> 8));\n        self.w\n    }\n    fn next_i32(&mut self, r: i32) -> i32 {\n        (self.xor128() % r as u32) as i32\n    }\n    fn next_i32_lr(&mut self, l: i32, r: i32) -> i32 {\n        self.next_i32(r - l + 1) + l\n    }\n    fn next_i64(&mut self, r: i64) -> i64 {\n        ((((self.xor128() as u64) << 32) + self.xor128() as u64) % r as u64) as i64\n    }\n    fn next_i64_lr(&mut self, l: i64, r: i64) -> i64 {\n        self.next_i64(r - l + 1) + l\n    }\n    fn next_f64(&mut self, r: f64) -> f64 {\n        (self.xor128() as f64) / (0xffffffffu32 as f64) * r\n    }\n    fn next_f64_lr(&mut self, l: f64, r: f64) -> f64 {\n        self.next_f64(r - l) + l\n    }\n}\n\nconst MOD: i64 = 1e+9 as i64 + 7;\n#[allow(dead_code)]\nfn pow_mod(base: i64, power: i64, modulo: i64) -> i64 {\n    let mut base = base;\n    let mut power = power;\n    let mut ans = 1;\n    while power > 0 {\n        if power & 1 == 1 {\n            ans = ans * base % modulo;\n        }\n        power >>= 1;\n        base = base * base % modulo;\n    }\n    ans\n}\n\n#[allow(dead_code)]\nfn inv_mod(a: i64, modulo: i64) -> i64 {\n    pow_mod(a, modulo - 2, modulo)\n}\n\nstruct Solver {\n    n: usize,\n    s: Vec<char>,\n    xs: Vec<i64>,\n    aseq: Vec<Vec<i64>>,\n    bseq: Vec<Vec<i64>>,\n    ba: Vec<HashMap<i64, usize>>,\n}\n\nimpl Solver {\n    fn new(n: usize, s: Vec<char>) -> Solver {\n        let mut rnd = XorShift::new();\n        let mut xs = vec![0; 6];\n        for i in 0..6 {\n            xs[i] = rnd.next_i64(MOD);\n        }\n        let aseq = vec![vec![0; n + 1]; xs.len()];\n        let bseq = vec![vec![0; n + 1]; xs.len()];\n        let ba = vec![HashMap::<i64, usize>::new(); xs.len()];\n        Solver {\n            n: n,\n            s: s,\n            xs: xs,\n            aseq: aseq,\n            bseq: bseq,\n            ba: ba,\n        }\n    }\n    fn init(&mut self) {\n        let n = self.n;\n        for (i, &x) in self.xs.iter().enumerate() {\n            let inv_x = inv_mod(x, MOD);\n            self.aseq[i][n] = 1;\n            self.bseq[i][n] = 0;\n            for j in (0..n).rev() {\n                let c = self.s[j];\n                match c {\n                    '+' => {\n                        self.aseq[i][j] = self.aseq[i][j + 1];\n                        self.bseq[i][j] = (self.bseq[i][j + 1] + 1) % MOD;\n                    }\n                    '-' => {\n                        self.aseq[i][j] = self.aseq[i][j + 1];\n                        self.bseq[i][j] = (self.bseq[i][j + 1] - 1 + MOD) % MOD;\n                    }\n                    '>' => {\n                        self.aseq[i][j] = (self.aseq[i][j + 1] * x) % MOD;\n                        self.bseq[i][j] = (self.bseq[i][j + 1] * x) % MOD;\n                    }\n                    '<' => {\n                        self.aseq[i][j] = (self.aseq[i][j + 1] * inv_x) % MOD;\n                        self.bseq[i][j] = (self.bseq[i][j + 1] * inv_x) % MOD;\n                    }\n                    _ => {\n                        assert!(false);\n                    }\n                }\n            }\n        }\n    }\n    fn solve(&mut self) -> usize {\n        self.init();\n        let mut ans = 0;\n        for i in 0..self.xs.len() {\n            self.ba[i].insert(0, 1);\n        }\n        for i in (0..self.n).rev() {\n            let mut cnt = self.n;\n            for j in 0..self.xs.len() {\n                let mut target = (self.bseq[j][i] - self.bseq[j][0] + MOD) % MOD\n                    * inv_mod(self.aseq[j][i], MOD) % MOD;\n                if let Some(&lcnt) = self.ba[j].get(&target) {\n                    cnt = std::cmp::min(cnt, lcnt);\n                } else {\n                    cnt = 0;\n                }\n                let v = self.bseq[j][i] * inv_mod(self.aseq[j][i], MOD) % MOD;\n                *self.ba[j].entry(v).or_insert(0) += 1;\n            }\n            // println!(\"{} {}\", i, cnt);\n            ans += cnt;\n        }\n        ans\n    }\n}\n\nfn main() {\n    let n = read::<usize>();\n    let s = read::<String>().chars().collect::<Vec<char>>();\n    let mut solver = Solver::new(n, s);\n    let ans = solver.solve();\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "use proconio::{input, marker::Chars};\n\n// modint{{{\nmod modint {\n    //! [`Mint`] 型を提供します。\n    //!\n    //! [`Mint`]: struct.Mint.html\n\n    /// [`Mint`] の中に入れる数値型が実装していないといけないトレイトをまとめました。\n    ///\n    /// どうやら普通の符号付き整数型ならば大丈夫そうですね。\n    ///\n    /// いかがでしたでしょうか？（真顔）\n    ///\n    /// [`Mint`]: struct.Mint.html\n    pub trait ModValue:\n        std::ops::Add<Output = Self>\n        + std::ops::Sub<Output = Self>\n        + std::ops::Mul<Output = Self>\n        + std::ops::Div<Output = Self>\n        + std::ops::Rem<Output = Self>\n        + std::ops::AddAssign\n        + std::ops::SubAssign\n        + std::ops::MulAssign\n        + std::ops::DivAssign\n        + std::ops::RemAssign\n        + std::ops::Neg\n        + std::cmp::Ord\n        + Clone\n        + Copy\n        + Sized\n        + std::fmt::Debug\n        + std::fmt::Display\n    {\n    }\n\n    impl<\n            Value: std::ops::Add<Output = Self>\n                + std::ops::Sub<Output = Self>\n                + std::ops::Mul<Output = Self>\n                + std::ops::Div<Output = Self>\n                + std::ops::Rem<Output = Self>\n                + std::ops::AddAssign\n                + std::ops::SubAssign\n                + std::ops::MulAssign\n                + std::ops::DivAssign\n                + std::ops::RemAssign\n                + std::ops::Neg\n                + std::cmp::Ord\n                + Clone\n                + Copy\n                + Sized\n                + std::fmt::Debug\n                + std::fmt::Display,\n        > ModValue for Value\n    {\n    }\n\n    /// mod に関数情報を [`Mint`] に伝えるための型引数だッピ！\n    ///\n    /// [`Mint`]: struct.Mint.html\n    pub trait Minfo: Clone + Copy + std::fmt::Debug {\n        /// 中身の型です。\n        type Value: ModValue;\n\n        /// mod の値を返します。\n        fn modulus() -> Self::Value;\n\n        /// 0 を返します。\n        fn zero() -> Self::Value;\n\n        /// 1 を返します。\n        fn one() -> Self::Value;\n    }\n\n    /// 自動で mod を取ってくれる整数型です。\n    ///\n    /// 型引数は、トレイト [`Minfo`] を実装している必要があります。\n    ///\n    /// # Examples\n    ///\n    /// [`from_value`] によって、`Mint<Mod>` が作れます。\n    /// 逆に、[`value`] によって、中身がとれます。\n    ///\n    /// ```\n    /// use modint::Mint1000000007;\n    /// type Mint = Mint1000000007;\n    ///\n    /// let x: Mint = Mint::from_value(2);\n    ///\n    /// assert_eq!(x.value(), 2);\n    /// ```\n    ///\n    /// 四則演算ができます。\n    ///\n    /// ```\n    /// use modint::Mint1000000007;\n    /// type Mint = Mint1000000007;\n    ///\n    /// let x: Mint = Mint::from_value(6);\n    /// let y: Mint = Mint::from_value(2);\n    ///\n    /// assert_eq!((x + y).value(), 8);\n    /// assert_eq!((x - y).value(), 4);\n    /// assert_eq!((x * y).value(), 12);\n    /// assert_eq!((x / y).value(), 3);\n    /// ```\n    ///\n    /// [`value`]: #method.value\n    /// [`from_value`]: #method.from_value\n    /// [`Minfo`]:trait.Minfo.html\n\n    #[derive(Clone, Copy, Debug)]\n    pub struct Mint<Mod: Minfo>(Mod::Value);\n\n    impl<Mod: Minfo> Mint<Mod> {\n        #[inline]\n        #[allow(dead_code)]\n        fn is_within_the_range(x: Mod::Value) -> bool {\n            Mod::zero() <= x && x < Mod::modulus()\n        }\n\n        #[inline]\n        #[allow(dead_code)]\n        fn normalize(x: Mod::Value) -> Mod::Value {\n            if Self::is_within_the_range(x) {\n                x\n            } else {\n                let x = x % Mod::modulus();\n                if x < Mod::zero() {\n                    x + Mod::modulus()\n                } else {\n                    x\n                }\n            }\n        }\n\n        /// 0 を構築します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::zero();\n        /// assert_eq!(x.value(), 0);\n        /// ```\n        #[allow(dead_code)]\n        pub fn zero() -> Self {\n            Self(Mod::zero())\n        }\n\n        /// 1 を構築します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::one();\n        /// assert_eq!(x.value(), 1);\n        /// ```\n        #[allow(dead_code)]\n        pub fn one() -> Self {\n            Self(Mod::one())\n        }\n\n        /// mod を取得します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::modulus();\n        /// assert_eq!(x, 998244353);\n        /// ```\n        #[allow(dead_code)]\n        pub fn modulus() -> Mod::Value {\n            Mod::modulus()\n        }\n\n        /// 0 であるときに `true` を返します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::zero();\n        /// assert!(x.is_zero());\n        ///\n        /// let x = Mint::one();\n        /// assert!(!x.is_zero());\n        /// ```\n        #[allow(dead_code)]\n        pub fn is_zero(&self) -> bool {\n            self.value() == Mod::zero()\n        }\n\n        /// 構築します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::from_value(4);\n        /// ```\n        #[allow(dead_code)]\n        pub fn from_value(x: Mod::Value) -> Self {\n            Self(Self::normalize(x))\n        }\n\n        /// 中身を取得します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::from_value(4);\n        /// assert_eq!(x.value(), 4);\n        /// ```\n        #[allow(dead_code)]\n        pub fn value(&self) -> Mod::Value {\n            self.0\n        }\n\n        /// mod 逆元を計算します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::from_value(2);\n        /// assert_eq!(x.inv().value(), 499122177);\n        /// ```\n        #[allow(dead_code)]\n        pub fn inv(&self) -> Self {\n            if self.is_zero() {\n                panic!(\"inv(0)\");\n            }\n            Self(Self::raw_inv(self.value()))\n        }\n\n        /// ユークリッドの互除法を用いて、pow を計算します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// let x = Mint17::from_value(2);\n        /// assert_eq!(x.pow(6).value(), 64 % 17);\n        /// ```\n        #[allow(dead_code)]\n        pub fn pow(&self, b: u64) -> Self {\n            Self(Self::raw_pow(self.value(), b))\n        }\n\n        fn raw_add(x: Mod::Value, y: Mod::Value) -> Mod::Value {\n            let z = x + y;\n            if Mod::modulus() <= z {\n                z - Mod::modulus()\n            } else {\n                z\n            }\n        }\n\n        fn raw_sub(x: Mod::Value, y: Mod::Value) -> Mod::Value {\n            let z = x - y;\n            if z < Mod::zero() {\n                z + Mod::modulus()\n            } else {\n                z\n            }\n        }\n\n        fn raw_neg(x: Mod::Value) -> Mod::Value {\n            if x == Mod::zero() {\n                Mod::zero()\n            } else {\n                Mod::modulus() - x\n            }\n        }\n\n        fn raw_mul(x: Mod::Value, y: Mod::Value) -> Mod::Value {\n            x * y % Mod::modulus()\n        }\n\n        fn raw_div(x: Mod::Value, y: Mod::Value) -> Mod::Value {\n            Self::raw_mul(x, Self::raw_inv(y))\n        }\n\n        #[allow(clippy::many_single_char_names)]\n        fn raw_inv(mut x: Mod::Value) -> Mod::Value {\n            let mut y = Mod::modulus();\n            let mut u = Mod::one();\n            let mut v = Mod::zero();\n            while x != Mod::zero() {\n                let q = y / x;\n                y -= x * q;\n                v -= u * q;\n                std::mem::swap(&mut x, &mut y);\n                std::mem::swap(&mut u, &mut v);\n            }\n            if v < Mod::zero() {\n                v + Mod::modulus()\n            } else {\n                v\n            }\n        }\n\n        fn raw_pow(mut a: Mod::Value, mut b: u64) -> Mod::Value {\n            let mut x = Mod::one();\n            while 0 < b {\n                if b % 2 == 1 {\n                    x = Self::raw_mul(x, a);\n                }\n                a = Self::raw_mul(a, a);\n                b /= 2\n            }\n            x\n        }\n    }\n\n    macro_rules! impl_biop {\n    (\n        $(\n            $biop_trait: ident::$biop_fn: ident,\n            $biop_assign_trait: ident::$biop_assign_fn: ident,\n            $biop_impl: ident;\n        )*\n    ) => {\n        $(\n            impl<Mod: Minfo> std::ops::$biop_trait for Mint<Mod> {\n                type Output = Self;\n                fn $biop_fn(self, rhs: Self) -> Self::Output {\n                    Mint(Self::$biop_impl(self.value(), rhs.value()))\n                }\n            }\n            impl<Mod: Minfo> std::ops::$biop_assign_trait for Mint<Mod>\n            where\n                Self: Copy\n            {\n                fn $biop_assign_fn(&mut self, rhs: Self) {\n                    use std::ops::$biop_trait;\n                    *self = Mint::$biop_fn(*self, rhs)\n                }\n            }\n        )*\n    };\n}\n\n    impl_biop! {\n        Add::add, AddAssign::add_assign, raw_add;\n        Sub::sub, SubAssign::sub_assign, raw_sub;\n        Mul::mul, MulAssign::mul_assign, raw_mul;\n        Div::div, DivAssign::div_assign, raw_div;\n    }\n\n    impl<Mod: Minfo> std::ops::Neg for Mint<Mod> {\n        type Output = Self;\n        fn neg(self) -> Self::Output {\n            Self(Self::raw_neg(self.value()))\n        }\n    }\n\n    impl<Mod: Minfo> std::cmp::PartialEq for Mint<Mod> {\n        /// 中身をそのまま 比較です。\n        /// 構築時に normalize され、それ以降も normalized な状態に保たれますから、\n        /// 結局あまりを比較しているのと同じことになります。\n        ///\n        /// # Example\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// assert_eq!(Mint17::from_value(3), Mint::from_value(-31));\n        /// assert_eq!(Mint17::from_value(3), Mint::from_value(-14));\n        /// assert_eq!(Mint17::from_value(3), Mint::from_value(3));\n        /// assert_eq!(Mint17::from_value(3), Mint::from_value(20));\n        /// assert_eq!(Mint17::from_value(3), Mint::from_value(37));\n        ///\n        /// assert_ne!(Mint17::from_value(3), Mint::from_value(31));\n        /// assert_ne!(Mint17::from_value(3), Mint::from_value(14));\n        /// assert_ne!(Mint17::from_value(3), Mint::from_value(-3));\n        /// assert_ne!(Mint17::from_value(3), Mint::from_value(-20));\n        /// assert_ne!(Mint17::from_value(3), Mint::from_value(-37));\n        /// ```\n        fn eq(&self, other: &Self) -> bool {\n            self.value().eq(&other.value())\n        }\n    }\n    impl<Mod: Minfo> std::cmp::Eq for Mint<Mod> {}\n\n    impl<Mod: Minfo> std::fmt::Display for Mint<Mod> {\n        /// 中身をそのまま Display です。\n        ///\n        /// # Example\n        ///\n        /// ```\n        /// println!(\"{}\", modint::Mint998244353::from_value(42));\n        /// ```\n        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n            write!(f, \"{}\", self.value())\n        }\n    }\n\n    impl<Mod: Minfo> std::iter::Sum<Self> for Mint<Mod> {\n        /// 総和を取ります。\n        ///\n        /// # Example\n        ///\n        /// ```\n        /// use modint::{define_mint, Minfo, Mint};\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        /// assert_eq!(\n        ///     vec![\n        ///         Mint17::from_value(2),\n        ///         Mint17::from_value(4),\n        ///         Mint17::from_value(6),\n        ///         Mint17::from_value(8),\n        ///     ]\n        ///     .into_iter()\n        ///     .sum::<Mint17>(),\n        ///     Mint17::from_value(3)\n        /// );\n        /// ```\n        fn sum<I: Iterator<Item = Self>>(iter: I) -> Self {\n            iter.fold(Mint::zero(), |acc, x| acc + x)\n        }\n    }\n\n    impl<Mod: Minfo> std::iter::Product<Self> for Mint<Mod> {\n        /// 総積を取ります。\n        ///\n        /// # Example\n        ///\n        /// ```\n        /// use modint::{define_mint, Minfo, Mint};\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        /// assert_eq!(\n        ///     vec![\n        ///         Mint17::from_value(1),\n        ///         Mint17::from_value(2),\n        ///         Mint17::from_value(3),\n        ///         Mint17::from_value(4),\n        ///     ]\n        ///     .into_iter()\n        ///     .product::<Mint17>(),\n        ///     Mint17::from_value(7)\n        /// );\n        /// ```\n        fn product<I: Iterator<Item = Self>>(iter: I) -> Self {\n            iter.fold(Mint::one(), |acc, x| acc * x)\n        }\n    }\n\n    /// 階乗とその逆元を前計算するマシーンです。\n    #[allow(dead_code)]\n    pub struct Factorial<Mod: Minfo> {\n        normal: Vec<Mint<Mod>>,\n        inverted: Vec<Mint<Mod>>,\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo> Factorial<Mod>\n    where\n        Mod::Value: std::convert::TryFrom<usize, Error = std::num::TryFromIntError>,\n    {\n        /// サイズを指定して初期化です。\n        /// 最大値は一つ小さくなりますから、注意です。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, Factorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        /// let fact = Factorial::<Minfo17>::new(16);\n        /// ```\n        pub fn new(n: usize) -> Self {\n            use std::convert::TryFrom;\n            let mut normal = vec![Mint::one(); n];\n            for i in 1..n {\n                normal[i] = normal[i - 1] * Mint::from_value(Mod::Value::try_from(i).unwrap());\n            }\n            let mut inverted = vec![Mint::one(); n];\n            inverted[n - 1] = normal[n - 1].inv();\n            for i in (1..n).rev() {\n                inverted[i - 1] = inverted[i] * Mint::from_value(Mod::Value::try_from(i).unwrap());\n            }\n            Self { normal, inverted }\n        }\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo> Factorial<Mod> {\n        /// 階乗の逆元を取得します。\n        ///\n        /// 逆元でなくて普通の階乗は、[`implementations`] をご覧いただけると幸いです。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, Factorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// let fact = Factorial::<Minfo17>::new(17);\n        ///\n        /// for i in 0..17 {\n        ///     assert_eq!(fact[i] * fact.inverted(i), Mint17::one());\n        /// }\n        /// ```\n        ///\n        /// [`implementations`]: #implementations\n        ///\n        pub fn inverted(&self, i: usize) -> Mint<Mod> {\n            self.inverted[i]\n        }\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo, I: std::slice::SliceIndex<[Mint<Mod>]>> std::ops::Index<I> for Factorial<Mod> {\n        type Output = I::Output;\n\n        /// Index でも取ることができます。\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, Factorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// let fact = Factorial::<Minfo17>::new(17);\n        ///\n        /// assert_eq!(fact[0], Mint17::from_value(1));\n        /// assert_eq!(fact[1], Mint17::from_value(1));\n        /// assert_eq!(fact[2], Mint17::from_value(2));\n        /// assert_eq!(fact[3], Mint17::from_value(6));\n        /// assert_eq!(fact[4], Mint17::from_value(24 % 17));\n        /// assert_eq!(fact[5], Mint17::from_value(120 % 17));\n        /// ```\n        #[inline]\n        fn index(&self, index: I) -> &Self::Output {\n            &self.normal[index]\n        }\n    }\n\n    /// 二重階乗とその逆元を前計算するマシーンです。\n    #[allow(dead_code)]\n    pub struct DoubleFactorial<Mod: Minfo> {\n        normal: Vec<Mint<Mod>>,\n        inverted: Vec<Mint<Mod>>,\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo> DoubleFactorial<Mod>\n    where\n        Mod::Value: std::convert::TryFrom<usize, Error = std::num::TryFromIntError>,\n    {\n        /// サイズを指定して初期化です。\n        /// 最大値は一つ小さくなりますから、注意です。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, DoubleFactorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        /// let fact = DoubleFactorial::<Minfo17>::new(16);\n        /// ```\n        pub fn new(n: usize) -> Self {\n            use std::convert::TryFrom;\n            let mut normal = vec![Mint::one(); n];\n            for i in 2..n {\n                normal[i] = normal[i - 2] * Mint::from_value(Mod::Value::try_from(i).unwrap());\n            }\n            let mut inverted = vec![Mint::one(); n];\n            inverted[n - 1] = normal[n - 1].inv();\n            inverted[n - 2] = normal[n - 2].inv();\n            for i in (2..n).rev() {\n                inverted[i - 2] = inverted[i] * Mint::from_value(Mod::Value::try_from(i).unwrap());\n            }\n            Self { normal, inverted }\n        }\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo> DoubleFactorial<Mod> {\n        /// 二重階乗の逆元を取得します。\n        ///\n        /// 逆元でなくて普通の二重階乗は、[`implementations`] をご覧いただけると幸いです。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, DoubleFactorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// let fact = DoubleFactorial::<Minfo17>::new(17);\n        ///\n        /// for i in 0..17 {\n        ///     assert_eq!(fact[i] * fact.inverted(i), Mint17::one());\n        /// }\n        /// ```\n        ///\n        /// [`implementations`]: #implementations\n        ///\n        pub fn inverted(&self, i: usize) -> Mint<Mod> {\n            self.inverted[i]\n        }\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo, I: std::slice::SliceIndex<[Mint<Mod>]>> std::ops::Index<I>\n        for DoubleFactorial<Mod>\n    {\n        type Output = I::Output;\n\n        /// Index でも取ることができます。\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, DoubleFactorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// let fact = DoubleFactorial::<Minfo17>::new(17);\n        ///\n        /// assert_eq!(fact[0], Mint17::from_value(1));\n        /// assert_eq!(fact[1], Mint17::from_value(1));\n        /// assert_eq!(fact[2], Mint17::from_value(2));\n        /// assert_eq!(fact[3], Mint17::from_value(3));\n        /// assert_eq!(fact[4], Mint17::from_value(8));\n        /// assert_eq!(fact[5], Mint17::from_value(15));\n        /// ```\n        #[inline]\n        fn index(&self, index: I) -> &Self::Output {\n            &self.normal[index]\n        }\n    }\n\n    /// Mint 型を定義するためのマクロです。\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use modint::{define_mint, Minfo, Mint};\n    ///\n    /// define_mint! {\n    ///     struct Mint17(Minfo17(17; i64));\n    /// }\n    ///\n    /// let x = Mint17::from_value(1);\n    /// let y = Mint17::from_value(2);\n    /// let z = x / y;\n    /// assert_eq!(z.value(), 9);\n    /// ```\n    #[macro_export]\n    macro_rules! define_mint {\n        (\n        struct $modint: ident ($modinfo: ident ($modvalue: expr; $modty: ty));\n    ) => {\n            #[allow(dead_code)]\n            #[derive(Clone, Copy, Debug)]\n            pub struct $modinfo {}\n            impl Minfo for $modinfo {\n                type Value = $modty;\n                fn modulus() -> Self::Value {\n                    $modvalue\n                }\n                fn zero() -> Self::Value {\n                    0\n                }\n                fn one() -> Self::Value {\n                    1\n                }\n            }\n            type $modint = Mint<$modinfo>;\n        };\n    }\n\n    /// Mod = 1000000007 なる Minfo です。\n    #[allow(dead_code)]\n    #[derive(Clone, Copy, Debug)]\n    pub struct Minfo1000000007 {}\n\n    impl Minfo for Minfo1000000007 {\n        type Value = i64;\n        fn modulus() -> Self::Value {\n            1_000_000_007\n        }\n        fn zero() -> Self::Value {\n            0\n        }\n        fn one() -> Self::Value {\n            1\n        }\n    }\n\n    /// Mod = 1000000007 なる Mint です。\n    #[allow(dead_code)]\n    pub type Mint1000000007 = Mint<Minfo1000000007>;\n\n    /// Mod = 998244353 なる Minfo です。\n    #[allow(dead_code)]\n    #[derive(Clone, Copy, Debug)]\n    pub struct Minfo998244353 {}\n\n    impl Minfo for Minfo998244353 {\n        type Value = i64;\n        fn modulus() -> Self::Value {\n            998_244_353\n        }\n        fn zero() -> Self::Value {\n            0\n        }\n        fn one() -> Self::Value {\n            1\n        }\n    }\n\n    /// Mod = 998244353 なる Mint です。\n    #[allow(dead_code)]\n    pub type Mint998244353 = Mint<Minfo998244353>;\n}\n//}}}\n\ntype Mint = modint::Mint998244353;\n\nfn main() {\n    input!(n: usize, mut s: Chars);\n    s.reverse();\n    let make = |x: Mint| -> Vec<(Mint, Mint)> {\n        let mut ans = vec![(Mint::one(), Mint::zero()); n + 1];\n        for (i, &c) in s.iter().enumerate() {\n            let (a, b) = ans[i];\n            ans[i + 1] = match c {\n                '+' => (a, b + Mint::one()),\n                '-' => (a, b - Mint::one()),\n                '<' => (a * x, b * x),\n                '>' => (a / x, b / x),\n                _ => panic!(),\n            }\n        }\n        ans\n    };\n\n    let keys: Vec<_> = (0..20)\n        .map(|i| i * 10_000_000)\n        .map(Mint::from_value)\n        .collect();\n    let seqs: Vec<_> = keys.iter().copied().map(make).collect();\n    let mut hash_map = std::collections::HashMap::<Vec<_>, _>::new();\n    let mut ans = 0;\n    for i in 0..=n {\n        if let Some(x) = hash_map.get(\n            &(0..keys.len())\n                .map(|j| {\n                    let (a, b) = seqs[j][i];\n                    ((b - seqs[j][n].1) / a).value()\n                })\n                .collect::<Vec<_>>(),\n        ) {\n            ans += x;\n        }\n        *hash_map\n            .entry(\n                (0..keys.len())\n                    .map(|j| {\n                        let (a, b) = seqs[j][i];\n                        (b / a).value()\n                    })\n                    .collect(),\n            )\n            .or_insert(0) += 1;\n    }\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::Read;\n#[allow(dead_code)]\nfn getline() -> String {\n    let mut ret = String::new();\n    std::io::stdin().read_line(&mut ret).ok().unwrap();\n    ret\n}\nfn get_word() -> String {\n    let mut stdin = std::io::stdin();\n    let mut u8b: [u8; 1] = [0];\n    loop {\n        let mut buf: Vec<u8> = Vec::with_capacity(16);\n        loop {\n            let res = stdin.read(&mut u8b);\n            if res.unwrap_or(0) == 0 || u8b[0] <= b' ' {\n                break;\n            } else {\n                buf.push(u8b[0]);\n            }\n        }\n        if buf.len() >= 1 {\n            let ret = String::from_utf8(buf).unwrap();\n            return ret;\n        }\n    }\n}\n\n#[allow(dead_code)]\nfn get<T: std::str::FromStr>() -> T { get_word().parse().ok().unwrap() }\n\nconst MOD: i64 = 1_000_000_007;\n\n/// Refers external ::MOD.\n/// Verified by:\nmod mod_int {\n    use ::MOD;\n    use std::ops::*;\n    #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]\n    pub struct ModInt{pub x: i64}\n    impl ModInt {\n        fn check_integrity(self) {\n            debug_assert!(self.x >= 0);\n            debug_assert!(self.x < MOD);\n        }\n        // x >= 0\n        pub fn new(x: i64) -> Self { ModInt { x: x % MOD } }\n        #[allow(dead_code)]\n        pub fn mul_fast(self, other: Self) -> Self {\n            self.check_integrity();\n            other.check_integrity();\n            Self::new(self.x * other.x % MOD)\n        }\n        #[allow(dead_code)]\n        pub fn mul_slow(self, other: Self) -> Self {\n            // Naive multiplication in order to avoid overflow\n            self.check_integrity();\n            other.check_integrity();\n            let mut sum = ModInt::new(0);\n            let mut cur = self;\n            let mut e = other.x;\n            if self.x < other.x {\n                cur = other;\n                e = self.x;\n            }\n            while e > 0 {\n                if e % 2 == 1 {\n                    sum = sum + cur;\n                }\n                cur = cur + cur;\n                e /= 2;\n            }\n            sum\n        }\n        pub fn pow(self, mut e: i64) -> Self {\n            self.check_integrity();\n            debug_assert!(e >= 0);\n            let mut sum = ModInt::new(1);\n            let mut cur = ModInt::new(self.x);\n            while e > 0 {\n                if e % 2 != 0 {\n                    sum = sum * cur;\n                }\n                cur = cur * cur;\n                e /= 2;\n            }\n            sum\n        }\n        pub fn inv(self) -> Self { self.pow(MOD - 2) }\n    }\n    impl Add for ModInt {\n        type Output = Self;\n        fn add(self, other: Self) -> Self {\n            self.check_integrity();\n            other.check_integrity();\n            let mut sum = self.x + other.x;\n            if sum >= MOD { sum -= MOD; }\n            Self::new(sum)\n        }\n    }\n    impl Sub for ModInt {\n        type Output = Self;\n        fn sub(self, other: Self) -> Self {\n            self.check_integrity();\n            other.check_integrity();\n            let mut sum = self.x - other.x;\n            if sum < 0 { sum += MOD; }\n            Self::new(sum)\n        }\n    }\n    impl Mul for ModInt {\n        type Output = Self;\n        fn mul(self, other: Self) -> Self {\n            self.mul_slow(other)\n        }\n    }\n} // mod mod_int\n\n\nfn solve() {\n    use mod_int::*;\n    let n: usize = get();\n    let s: Vec<_> = get_word().chars().collect();\n    const A: usize = 3;\n    let b = [ModInt::new(41), ModInt::new(255), ModInt::new(36)];\n    let mut hsh = vec![vec![ModInt::new(0); n + 1]; A];\n    let mut inv = [ModInt::new(0); A];\n    for i in 0 .. A { inv[i] = b[i].inv(); }\n    let mut pos = vec![0; n + 1];\n    for c in 0 .. A {\n        let mut p = 0;\n        let mut cur = ModInt::new(1);\n        for (i, &ch) in s.iter().enumerate() {\n            let mut tmp = hsh[c][i];\n            match ch {\n                '>' => {\n                    p += 1;\n                    cur = cur * b[c];\n                },\n                '<' => {\n                    p -= 1;\n                    cur = cur * inv[c];\n                },\n                '+' => tmp = tmp + cur,\n                '-' => tmp = tmp - cur,\n                _ => panic!(),\n            }\n            hsh[c][i + 1] = tmp;\n            pos[i + 1] = p;\n        }\n    }\n    let mut meguru = [ModInt::new(0); A];\n    for c in 0 .. A { meguru[c] = hsh[c][n]; }\n    let mut kirika = HashMap::new();\n    kirika.insert(meguru, 1);\n    let mut tot = 0i64;\n    for i in (0 .. n).rev() {\n        let mut cur = [ModInt::new(0); A];\n        for c in 0 .. A { cur[c] = b[c].pow(MOD - 1 + pos[i]); }\n        let mut ken = [ModInt::new(0); A];\n        for c in 0 .. A { ken[c] = cur[c] * meguru[c] + hsh[c][i]; }\n        tot += kirika.get(&ken).cloned().unwrap_or(0);\n        let mut tt = [ModInt::new(0); A];\n        for c in 0 .. A { tt[c] = hsh[c][i]; }\n        *kirika.entry(tt).or_insert(0) += 1;\n    }\n    println!(\"{}\", tot);\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "use proconio::{input, marker::Chars};\n\n// modint{{{\nmod modint {\n    //! [`Mint`] 型を提供します。\n    //!\n    //! [`Mint`]: struct.Mint.html\n\n    /// [`Mint`] の中に入れる数値型が実装していないといけないトレイトをまとめました。\n    ///\n    /// どうやら普通の符号付き整数型ならば大丈夫そうですね。\n    ///\n    /// いかがでしたでしょうか？（真顔）\n    ///\n    /// [`Mint`]: struct.Mint.html\n    pub trait ModValue:\n        std::ops::Add<Output = Self>\n        + std::ops::Sub<Output = Self>\n        + std::ops::Mul<Output = Self>\n        + std::ops::Div<Output = Self>\n        + std::ops::Rem<Output = Self>\n        + std::ops::AddAssign\n        + std::ops::SubAssign\n        + std::ops::MulAssign\n        + std::ops::DivAssign\n        + std::ops::RemAssign\n        + std::ops::Neg\n        + std::cmp::Ord\n        + Clone\n        + Copy\n        + Sized\n        + std::fmt::Debug\n        + std::fmt::Display\n    {\n    }\n\n    impl<\n            Value: std::ops::Add<Output = Self>\n                + std::ops::Sub<Output = Self>\n                + std::ops::Mul<Output = Self>\n                + std::ops::Div<Output = Self>\n                + std::ops::Rem<Output = Self>\n                + std::ops::AddAssign\n                + std::ops::SubAssign\n                + std::ops::MulAssign\n                + std::ops::DivAssign\n                + std::ops::RemAssign\n                + std::ops::Neg\n                + std::cmp::Ord\n                + Clone\n                + Copy\n                + Sized\n                + std::fmt::Debug\n                + std::fmt::Display,\n        > ModValue for Value\n    {\n    }\n\n    /// mod に関数情報を [`Mint`] に伝えるための型引数だッピ！\n    ///\n    /// [`Mint`]: struct.Mint.html\n    pub trait Minfo: Clone + Copy + std::fmt::Debug {\n        /// 中身の型です。\n        type Value: ModValue;\n\n        /// mod の値を返します。\n        fn modulus() -> Self::Value;\n\n        /// 0 を返します。\n        fn zero() -> Self::Value;\n\n        /// 1 を返します。\n        fn one() -> Self::Value;\n    }\n\n    /// 自動で mod を取ってくれる整数型です。\n    ///\n    /// 型引数は、トレイト [`Minfo`] を実装している必要があります。\n    ///\n    /// # Examples\n    ///\n    /// [`from_value`] によって、`Mint<Mod>` が作れます。\n    /// 逆に、[`value`] によって、中身がとれます。\n    ///\n    /// ```\n    /// use modint::Mint1000000007;\n    /// type Mint = Mint1000000007;\n    ///\n    /// let x: Mint = Mint::from_value(2);\n    ///\n    /// assert_eq!(x.value(), 2);\n    /// ```\n    ///\n    /// 四則演算ができます。\n    ///\n    /// ```\n    /// use modint::Mint1000000007;\n    /// type Mint = Mint1000000007;\n    ///\n    /// let x: Mint = Mint::from_value(6);\n    /// let y: Mint = Mint::from_value(2);\n    ///\n    /// assert_eq!((x + y).value(), 8);\n    /// assert_eq!((x - y).value(), 4);\n    /// assert_eq!((x * y).value(), 12);\n    /// assert_eq!((x / y).value(), 3);\n    /// ```\n    ///\n    /// [`value`]: #method.value\n    /// [`from_value`]: #method.from_value\n    /// [`Minfo`]:trait.Minfo.html\n\n    #[derive(Clone, Copy, Debug)]\n    pub struct Mint<Mod: Minfo>(Mod::Value);\n\n    impl<Mod: Minfo> Mint<Mod> {\n        #[inline]\n        #[allow(dead_code)]\n        fn is_within_the_range(x: Mod::Value) -> bool {\n            Mod::zero() <= x && x < Mod::modulus()\n        }\n\n        #[inline]\n        #[allow(dead_code)]\n        fn normalize(x: Mod::Value) -> Mod::Value {\n            if Self::is_within_the_range(x) {\n                x\n            } else {\n                let x = x % Mod::modulus();\n                if x < Mod::zero() {\n                    x + Mod::modulus()\n                } else {\n                    x\n                }\n            }\n        }\n\n        /// 0 を構築します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::zero();\n        /// assert_eq!(x.value(), 0);\n        /// ```\n        #[allow(dead_code)]\n        pub fn zero() -> Self {\n            Self(Mod::zero())\n        }\n\n        /// 1 を構築します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::one();\n        /// assert_eq!(x.value(), 1);\n        /// ```\n        #[allow(dead_code)]\n        pub fn one() -> Self {\n            Self(Mod::one())\n        }\n\n        /// mod を取得します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::modulus();\n        /// assert_eq!(x, 998244353);\n        /// ```\n        #[allow(dead_code)]\n        pub fn modulus() -> Mod::Value {\n            Mod::modulus()\n        }\n\n        /// 0 であるときに `true` を返します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::zero();\n        /// assert!(x.is_zero());\n        ///\n        /// let x = Mint::one();\n        /// assert!(!x.is_zero());\n        /// ```\n        #[allow(dead_code)]\n        pub fn is_zero(&self) -> bool {\n            self.value() == Mod::zero()\n        }\n\n        /// 構築します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::from_value(4);\n        /// ```\n        #[allow(dead_code)]\n        pub fn from_value(x: Mod::Value) -> Self {\n            Self(Self::normalize(x))\n        }\n\n        /// 中身を取得します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::from_value(4);\n        /// assert_eq!(x.value(), 4);\n        /// ```\n        #[allow(dead_code)]\n        pub fn value(&self) -> Mod::Value {\n            self.0\n        }\n\n        /// mod 逆元を計算します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::from_value(2);\n        /// assert_eq!(x.inv().value(), 499122177);\n        /// ```\n        #[allow(dead_code)]\n        pub fn inv(&self) -> Self {\n            if self.is_zero() {\n                panic!(\"inv(0)\");\n            }\n            Self(Self::raw_inv(self.value()))\n        }\n\n        /// ユークリッドの互除法を用いて、pow を計算します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// let x = Mint17::from_value(2);\n        /// assert_eq!(x.pow(6).value(), 64 % 17);\n        /// ```\n        #[allow(dead_code)]\n        pub fn pow(&self, b: u64) -> Self {\n            Self(Self::raw_pow(self.value(), b))\n        }\n\n        fn raw_add(x: Mod::Value, y: Mod::Value) -> Mod::Value {\n            let z = x + y;\n            if Mod::modulus() <= z {\n                z - Mod::modulus()\n            } else {\n                z\n            }\n        }\n\n        fn raw_sub(x: Mod::Value, y: Mod::Value) -> Mod::Value {\n            let z = x - y;\n            if z < Mod::zero() {\n                z + Mod::modulus()\n            } else {\n                z\n            }\n        }\n\n        fn raw_neg(x: Mod::Value) -> Mod::Value {\n            if x == Mod::zero() {\n                Mod::zero()\n            } else {\n                Mod::modulus() - x\n            }\n        }\n\n        fn raw_mul(x: Mod::Value, y: Mod::Value) -> Mod::Value {\n            x * y % Mod::modulus()\n        }\n\n        fn raw_div(x: Mod::Value, y: Mod::Value) -> Mod::Value {\n            Self::raw_mul(x, Self::raw_inv(y))\n        }\n\n        #[allow(clippy::many_single_char_names)]\n        fn raw_inv(mut x: Mod::Value) -> Mod::Value {\n            let mut y = Mod::modulus();\n            let mut u = Mod::one();\n            let mut v = Mod::zero();\n            while x != Mod::zero() {\n                let q = y / x;\n                y -= x * q;\n                v -= u * q;\n                std::mem::swap(&mut x, &mut y);\n                std::mem::swap(&mut u, &mut v);\n            }\n            if v < Mod::zero() {\n                v + Mod::modulus()\n            } else {\n                v\n            }\n        }\n\n        fn raw_pow(mut a: Mod::Value, mut b: u64) -> Mod::Value {\n            let mut x = Mod::one();\n            while 0 < b {\n                if b % 2 == 1 {\n                    x = Self::raw_mul(x, a);\n                }\n                a = Self::raw_mul(a, a);\n                b /= 2\n            }\n            x\n        }\n    }\n\n    macro_rules! impl_biop {\n    (\n        $(\n            $biop_trait: ident::$biop_fn: ident,\n            $biop_assign_trait: ident::$biop_assign_fn: ident,\n            $biop_impl: ident;\n        )*\n    ) => {\n        $(\n            impl<Mod: Minfo> std::ops::$biop_trait for Mint<Mod> {\n                type Output = Self;\n                fn $biop_fn(self, rhs: Self) -> Self::Output {\n                    Mint(Self::$biop_impl(self.value(), rhs.value()))\n                }\n            }\n            impl<Mod: Minfo> std::ops::$biop_assign_trait for Mint<Mod>\n            where\n                Self: Copy\n            {\n                fn $biop_assign_fn(&mut self, rhs: Self) {\n                    use std::ops::$biop_trait;\n                    *self = Mint::$biop_fn(*self, rhs)\n                }\n            }\n        )*\n    };\n}\n\n    impl_biop! {\n        Add::add, AddAssign::add_assign, raw_add;\n        Sub::sub, SubAssign::sub_assign, raw_sub;\n        Mul::mul, MulAssign::mul_assign, raw_mul;\n        Div::div, DivAssign::div_assign, raw_div;\n    }\n\n    impl<Mod: Minfo> std::ops::Neg for Mint<Mod> {\n        type Output = Self;\n        fn neg(self) -> Self::Output {\n            Self(Self::raw_neg(self.value()))\n        }\n    }\n\n    impl<Mod: Minfo> std::cmp::PartialEq for Mint<Mod> {\n        /// 中身をそのまま 比較です。\n        /// 構築時に normalize され、それ以降も normalized な状態に保たれますから、\n        /// 結局あまりを比較しているのと同じことになります。\n        ///\n        /// # Example\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// assert_eq!(Mint17::from_value(3), Mint::from_value(-31));\n        /// assert_eq!(Mint17::from_value(3), Mint::from_value(-14));\n        /// assert_eq!(Mint17::from_value(3), Mint::from_value(3));\n        /// assert_eq!(Mint17::from_value(3), Mint::from_value(20));\n        /// assert_eq!(Mint17::from_value(3), Mint::from_value(37));\n        ///\n        /// assert_ne!(Mint17::from_value(3), Mint::from_value(31));\n        /// assert_ne!(Mint17::from_value(3), Mint::from_value(14));\n        /// assert_ne!(Mint17::from_value(3), Mint::from_value(-3));\n        /// assert_ne!(Mint17::from_value(3), Mint::from_value(-20));\n        /// assert_ne!(Mint17::from_value(3), Mint::from_value(-37));\n        /// ```\n        fn eq(&self, other: &Self) -> bool {\n            self.value().eq(&other.value())\n        }\n    }\n    impl<Mod: Minfo> std::cmp::Eq for Mint<Mod> {}\n\n    impl<Mod: Minfo> std::fmt::Display for Mint<Mod> {\n        /// 中身をそのまま Display です。\n        ///\n        /// # Example\n        ///\n        /// ```\n        /// println!(\"{}\", modint::Mint998244353::from_value(42));\n        /// ```\n        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n            write!(f, \"{}\", self.value())\n        }\n    }\n\n    impl<Mod: Minfo> std::iter::Sum<Self> for Mint<Mod> {\n        /// 総和を取ります。\n        ///\n        /// # Example\n        ///\n        /// ```\n        /// use modint::{define_mint, Minfo, Mint};\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        /// assert_eq!(\n        ///     vec![\n        ///         Mint17::from_value(2),\n        ///         Mint17::from_value(4),\n        ///         Mint17::from_value(6),\n        ///         Mint17::from_value(8),\n        ///     ]\n        ///     .into_iter()\n        ///     .sum::<Mint17>(),\n        ///     Mint17::from_value(3)\n        /// );\n        /// ```\n        fn sum<I: Iterator<Item = Self>>(iter: I) -> Self {\n            iter.fold(Mint::zero(), |acc, x| acc + x)\n        }\n    }\n\n    impl<Mod: Minfo> std::iter::Product<Self> for Mint<Mod> {\n        /// 総積を取ります。\n        ///\n        /// # Example\n        ///\n        /// ```\n        /// use modint::{define_mint, Minfo, Mint};\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        /// assert_eq!(\n        ///     vec![\n        ///         Mint17::from_value(1),\n        ///         Mint17::from_value(2),\n        ///         Mint17::from_value(3),\n        ///         Mint17::from_value(4),\n        ///     ]\n        ///     .into_iter()\n        ///     .product::<Mint17>(),\n        ///     Mint17::from_value(7)\n        /// );\n        /// ```\n        fn product<I: Iterator<Item = Self>>(iter: I) -> Self {\n            iter.fold(Mint::one(), |acc, x| acc * x)\n        }\n    }\n\n    /// 階乗とその逆元を前計算するマシーンです。\n    #[allow(dead_code)]\n    pub struct Factorial<Mod: Minfo> {\n        normal: Vec<Mint<Mod>>,\n        inverted: Vec<Mint<Mod>>,\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo> Factorial<Mod>\n    where\n        Mod::Value: std::convert::TryFrom<usize, Error = std::num::TryFromIntError>,\n    {\n        /// サイズを指定して初期化です。\n        /// 最大値は一つ小さくなりますから、注意です。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, Factorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        /// let fact = Factorial::<Minfo17>::new(16);\n        /// ```\n        pub fn new(n: usize) -> Self {\n            use std::convert::TryFrom;\n            let mut normal = vec![Mint::one(); n];\n            for i in 1..n {\n                normal[i] = normal[i - 1] * Mint::from_value(Mod::Value::try_from(i).unwrap());\n            }\n            let mut inverted = vec![Mint::one(); n];\n            inverted[n - 1] = normal[n - 1].inv();\n            for i in (1..n).rev() {\n                inverted[i - 1] = inverted[i] * Mint::from_value(Mod::Value::try_from(i).unwrap());\n            }\n            Self { normal, inverted }\n        }\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo> Factorial<Mod> {\n        /// 階乗の逆元を取得します。\n        ///\n        /// 逆元でなくて普通の階乗は、[`implementations`] をご覧いただけると幸いです。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, Factorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// let fact = Factorial::<Minfo17>::new(17);\n        ///\n        /// for i in 0..17 {\n        ///     assert_eq!(fact[i] * fact.inverted(i), Mint17::one());\n        /// }\n        /// ```\n        ///\n        /// [`implementations`]: #implementations\n        ///\n        pub fn inverted(&self, i: usize) -> Mint<Mod> {\n            self.inverted[i]\n        }\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo, I: std::slice::SliceIndex<[Mint<Mod>]>> std::ops::Index<I> for Factorial<Mod> {\n        type Output = I::Output;\n\n        /// Index でも取ることができます。\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, Factorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// let fact = Factorial::<Minfo17>::new(17);\n        ///\n        /// assert_eq!(fact[0], Mint17::from_value(1));\n        /// assert_eq!(fact[1], Mint17::from_value(1));\n        /// assert_eq!(fact[2], Mint17::from_value(2));\n        /// assert_eq!(fact[3], Mint17::from_value(6));\n        /// assert_eq!(fact[4], Mint17::from_value(24 % 17));\n        /// assert_eq!(fact[5], Mint17::from_value(120 % 17));\n        /// ```\n        #[inline]\n        fn index(&self, index: I) -> &Self::Output {\n            &self.normal[index]\n        }\n    }\n\n    /// 二重階乗とその逆元を前計算するマシーンです。\n    #[allow(dead_code)]\n    pub struct DoubleFactorial<Mod: Minfo> {\n        normal: Vec<Mint<Mod>>,\n        inverted: Vec<Mint<Mod>>,\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo> DoubleFactorial<Mod>\n    where\n        Mod::Value: std::convert::TryFrom<usize, Error = std::num::TryFromIntError>,\n    {\n        /// サイズを指定して初期化です。\n        /// 最大値は一つ小さくなりますから、注意です。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, DoubleFactorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        /// let fact = DoubleFactorial::<Minfo17>::new(16);\n        /// ```\n        pub fn new(n: usize) -> Self {\n            use std::convert::TryFrom;\n            let mut normal = vec![Mint::one(); n];\n            for i in 2..n {\n                normal[i] = normal[i - 2] * Mint::from_value(Mod::Value::try_from(i).unwrap());\n            }\n            let mut inverted = vec![Mint::one(); n];\n            inverted[n - 1] = normal[n - 1].inv();\n            inverted[n - 2] = normal[n - 2].inv();\n            for i in (2..n).rev() {\n                inverted[i - 2] = inverted[i] * Mint::from_value(Mod::Value::try_from(i).unwrap());\n            }\n            Self { normal, inverted }\n        }\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo> DoubleFactorial<Mod> {\n        /// 二重階乗の逆元を取得します。\n        ///\n        /// 逆元でなくて普通の二重階乗は、[`implementations`] をご覧いただけると幸いです。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, DoubleFactorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// let fact = DoubleFactorial::<Minfo17>::new(17);\n        ///\n        /// for i in 0..17 {\n        ///     assert_eq!(fact[i] * fact.inverted(i), Mint17::one());\n        /// }\n        /// ```\n        ///\n        /// [`implementations`]: #implementations\n        ///\n        pub fn inverted(&self, i: usize) -> Mint<Mod> {\n            self.inverted[i]\n        }\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo, I: std::slice::SliceIndex<[Mint<Mod>]>> std::ops::Index<I>\n        for DoubleFactorial<Mod>\n    {\n        type Output = I::Output;\n\n        /// Index でも取ることができます。\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, DoubleFactorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// let fact = DoubleFactorial::<Minfo17>::new(17);\n        ///\n        /// assert_eq!(fact[0], Mint17::from_value(1));\n        /// assert_eq!(fact[1], Mint17::from_value(1));\n        /// assert_eq!(fact[2], Mint17::from_value(2));\n        /// assert_eq!(fact[3], Mint17::from_value(3));\n        /// assert_eq!(fact[4], Mint17::from_value(8));\n        /// assert_eq!(fact[5], Mint17::from_value(15));\n        /// ```\n        #[inline]\n        fn index(&self, index: I) -> &Self::Output {\n            &self.normal[index]\n        }\n    }\n\n    /// Mint 型を定義するためのマクロです。\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use modint::{define_mint, Minfo, Mint};\n    ///\n    /// define_mint! {\n    ///     struct Mint17(Minfo17(17; i64));\n    /// }\n    ///\n    /// let x = Mint17::from_value(1);\n    /// let y = Mint17::from_value(2);\n    /// let z = x / y;\n    /// assert_eq!(z.value(), 9);\n    /// ```\n    #[macro_export]\n    macro_rules! define_mint {\n        (\n        struct $modint: ident ($modinfo: ident ($modvalue: expr; $modty: ty));\n    ) => {\n            #[allow(dead_code)]\n            #[derive(Clone, Copy, Debug)]\n            pub struct $modinfo {}\n            impl Minfo for $modinfo {\n                type Value = $modty;\n                fn modulus() -> Self::Value {\n                    $modvalue\n                }\n                fn zero() -> Self::Value {\n                    0\n                }\n                fn one() -> Self::Value {\n                    1\n                }\n            }\n            type $modint = Mint<$modinfo>;\n        };\n    }\n\n    /// Mod = 1000000007 なる Minfo です。\n    #[allow(dead_code)]\n    #[derive(Clone, Copy, Debug)]\n    pub struct Minfo1000000007 {}\n\n    impl Minfo for Minfo1000000007 {\n        type Value = i64;\n        fn modulus() -> Self::Value {\n            1_000_000_007\n        }\n        fn zero() -> Self::Value {\n            0\n        }\n        fn one() -> Self::Value {\n            1\n        }\n    }\n\n    /// Mod = 1000000007 なる Mint です。\n    #[allow(dead_code)]\n    pub type Mint1000000007 = Mint<Minfo1000000007>;\n\n    /// Mod = 998244353 なる Minfo です。\n    #[allow(dead_code)]\n    #[derive(Clone, Copy, Debug)]\n    pub struct Minfo998244353 {}\n\n    impl Minfo for Minfo998244353 {\n        type Value = i64;\n        fn modulus() -> Self::Value {\n            998_244_353\n        }\n        fn zero() -> Self::Value {\n            0\n        }\n        fn one() -> Self::Value {\n            1\n        }\n    }\n\n    /// Mod = 998244353 なる Mint です。\n    #[allow(dead_code)]\n    pub type Mint998244353 = Mint<Minfo998244353>;\n}\n//}}}\n\ntype Mint = modint::Mint1000000007;\n\nfn main() {\n    input!(n: usize, mut s: Chars);\n    s.reverse();\n    let make = |x: Mint| -> Vec<(Mint, Mint)> {\n        let mut ans = vec![(Mint::one(), Mint::zero()); n + 1];\n        for (i, &c) in s.iter().enumerate() {\n            let (a, b) = ans[i];\n            ans[i + 1] = match c {\n                '+' => (a, b + Mint::one()),\n                '-' => (a, b - Mint::one()),\n                '<' => (a * x, b * x),\n                '>' => (a / x, b / x),\n                _ => panic!(),\n            }\n        }\n        ans\n    };\n\n    let keys: Vec<_> = (0..16).map(Mint::from_value).collect();\n    let seqs: Vec<_> = keys.iter().copied().map(make).collect();\n    let mut btree_map = std::collections::BTreeMap::<Vec<_>, _>::new();\n    let mut ans = 0;\n    for i in 0..=n {\n        if let Some(x) = btree_map.get(\n            &(0..keys.len())\n                .map(|j| {\n                    let (a, b) = seqs[j][i];\n                    ((b - seqs[j][n].1) / a).value()\n                })\n                .collect::<Vec<_>>(),\n        ) {\n            ans += x;\n        }\n        *btree_map\n            .entry(\n                (0..keys.len())\n                    .map(|j| {\n                        let (a, b) = seqs[j][i];\n                        (b / a).value()\n                    })\n                    .collect(),\n            )\n            .or_insert(0) += 1;\n    }\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::Read;\n#[allow(dead_code)]\nfn getline() -> String {\n    let mut ret = String::new();\n    std::io::stdin().read_line(&mut ret).ok().unwrap();\n    ret\n}\nfn get_word() -> String {\n    let mut stdin = std::io::stdin();\n    let mut u8b: [u8; 1] = [0];\n    loop {\n        let mut buf: Vec<u8> = Vec::with_capacity(16);\n        loop {\n            let res = stdin.read(&mut u8b);\n            if res.unwrap_or(0) == 0 || u8b[0] <= b' ' {\n                break;\n            } else {\n                buf.push(u8b[0]);\n            }\n        }\n        if buf.len() >= 1 {\n            let ret = String::from_utf8(buf).unwrap();\n            return ret;\n        }\n    }\n}\n\n#[allow(dead_code)]\nfn get<T: std::str::FromStr>() -> T { get_word().parse().ok().unwrap() }\n\nmod mod_int {\n    use std::ops::*;\n    pub trait Mod: Copy + Clone {\n        fn m() -> i64;\n    }\n    #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]\n    pub struct ModInt<M: Mod> { pub x: i64, phantom: ::std::marker::PhantomData<*const M> }\n    impl<M: Mod> ModInt<M> {\n        fn check_integrity(self) {\n            debug_assert!(self.x >= 0);\n            debug_assert!(self.x < M::m());\n        }\n        // x >= 0\n        pub fn new(x: i64) -> Self { ModInt::new_internal(x % M::m()) }\n        fn new_internal(x: i64) -> Self { ModInt { x: x % M::m(), phantom: ::std::marker::PhantomData } }\n        #[allow(dead_code)]\n        pub fn mul_fast(self, other: Self) -> Self {\n            self.check_integrity();\n            other.check_integrity();\n            ModInt::new_internal(self.x * other.x % M::m())\n        }\n        #[allow(dead_code)]\n        pub fn mul_slow(self, other: Self) -> Self {\n            // Naive multiplication in order to avoid overflow\n            self.check_integrity();\n            other.check_integrity();\n            let mut sum = ModInt::new(0);\n            let mut cur = self;\n            let mut e = other.x;\n            if self.x < other.x {\n                cur = other;\n                e = self.x;\n            }\n            while e > 0 {\n                if e % 2 == 1 {\n                    sum = sum + cur;\n                }\n                cur = cur + cur;\n                e /= 2;\n            }\n            sum\n        }\n        pub fn pow(self, mut e: i64) -> Self {\n            self.check_integrity();\n            debug_assert!(e >= 0);\n            let mut sum = ModInt::new(1);\n            let mut cur = ModInt::new(self.x);\n            while e > 0 {\n                if e % 2 != 0 {\n                    sum = sum * cur;\n                }\n                cur = cur * cur;\n                e /= 2;\n            }\n            sum\n        }\n        pub fn inv(self) -> Self { self.pow(M::m() - 2) }\n    }\n    impl<M: Mod> Add for ModInt<M> {\n        type Output = Self;\n        fn add(self, other: Self) -> Self {\n            self.check_integrity();\n            other.check_integrity();\n            let mut sum = self.x + other.x;\n            if sum >= M::m() { sum -= M::m(); }\n            ModInt::new(sum)\n        }\n    }\n    impl<M: Mod> Sub for ModInt<M> {\n        type Output = Self;\n        fn sub(self, other: Self) -> Self {\n            self.check_integrity();\n            other.check_integrity();\n            let mut sum = self.x - other.x;\n            if sum < 0 { sum += M::m(); }\n            ModInt::new(sum)\n        }\n    }\n    impl<M: Mod> Mul for ModInt<M> {\n        type Output = Self;\n        fn mul(self, other: Self) -> Self {\n            self.mul_fast(other)\n        }\n    }\n} // mod mod_int\n\nconst MOD: i64 = 1_000_000_007;\n\n#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\nstruct P {}\nimpl mod_int::Mod for P {\n    fn m() -> i64 { MOD }\n}\ntype ModInt = mod_int::ModInt<P>;\n\n\nfn solve() {\n    //use mod_int::*;\n    let n: usize = get();\n    let s: Vec<_> = get_word().chars().collect();\n    const A: usize = 3;\n    let b = [ModInt::new(41), ModInt::new(255), ModInt::new(36)];\n    let mut hsh = vec![vec![ModInt::new(0); n + 1]; A];\n    let mut inv = [ModInt::new(0); A];\n    for i in 0 .. A { inv[i] = b[i].inv(); }\n    let mut pos = vec![0; n + 1];\n    for c in 0 .. A {\n        let mut p = 0;\n        let mut cur = ModInt::new(1);\n        for (i, &ch) in s.iter().enumerate() {\n            let mut tmp = hsh[c][i];\n            match ch {\n                '>' => {\n                    p += 1;\n                    cur = cur * b[c];\n                },\n                '<' => {\n                    p -= 1;\n                    cur = cur * inv[c];\n                },\n                '+' => tmp = tmp + cur,\n                '-' => tmp = tmp - cur,\n                _ => panic!(),\n            }\n            hsh[c][i + 1] = tmp;\n            pos[i + 1] = p;\n        }\n    }\n    let mut meguru = [ModInt::new(0); A];\n    for c in 0 .. A { meguru[c] = hsh[c][n]; }\n    let mut kirika = HashMap::new();\n    kirika.insert(meguru, 1);\n    let mut tot = 0i64;\n    for i in (0 .. n).rev() {\n        let mut cur = [ModInt::new(0); A];\n        for c in 0 .. A { cur[c] = b[c].pow(MOD - 1 + pos[i]); }\n        let mut ken = [ModInt::new(0); A];\n        for c in 0 .. A { ken[c] = cur[c] * meguru[c] + hsh[c][i]; }\n        tot += kirika.get(&ken).cloned().unwrap_or(0);\n        let mut tt = [ModInt::new(0); A];\n        for c in 0 .. A { tt[c] = hsh[c][i]; }\n        *kirika.entry(tt).or_insert(0) += 1;\n    }\n    println!(\"{}\", tot);\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::Read;\n#[allow(dead_code)]\nfn getline() -> String {\n    let mut ret = String::new();\n    std::io::stdin().read_line(&mut ret).ok().unwrap();\n    ret\n}\nfn get_word() -> String {\n    let mut stdin = std::io::stdin();\n    let mut u8b: [u8; 1] = [0];\n    loop {\n        let mut buf: Vec<u8> = Vec::with_capacity(16);\n        loop {\n            let res = stdin.read(&mut u8b);\n            if res.unwrap_or(0) == 0 || u8b[0] <= b' ' {\n                break;\n            } else {\n                buf.push(u8b[0]);\n            }\n        }\n        if buf.len() >= 1 {\n            let ret = String::from_utf8(buf).unwrap();\n            return ret;\n        }\n    }\n}\n\n#[allow(dead_code)]\nfn get<T: std::str::FromStr>() -> T { get_word().parse().ok().unwrap() }\n\nconst MOD: i64 = 1_000_000_009;\n\n/// Refers external ::MOD.\nmod mod_int {\n    use ::MOD;\n    use std::ops::*;\n    #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]\n    pub struct ModInt {\n        pub x: i64,\n    }\n    impl ModInt {\n        pub fn new(x: i64) -> Self { ModInt { x: x % MOD } }\n        #[allow(dead_code)]\n        pub fn mul_fast(self, others: Self) -> Self {\n            Self::new(self.x * others.x % MOD)\n        }\n        pub fn pow(self, mut e: i64) -> Self {\n            let mut sum = ModInt::new(1);\n            let mut cur = ModInt::new(self.x);\n            while e > 0 {\n                if e % 2 != 0 {\n                    sum = sum * cur;\n                }\n                cur = cur * cur;\n                e /= 2;\n            }\n            sum\n        }\n        pub fn inv(self) -> Self {\n            self.pow(MOD - 2)\n        }\n    }\n    impl Add for ModInt {\n        type Output = Self;\n        fn add(self, others: Self) -> Self {\n            let mut sum = self.x + others.x;\n            if sum >= MOD {\n                sum -= MOD;\n            }\n            Self::new(sum)\n        }\n    }\n    impl Sub for ModInt {\n        type Output = Self;\n        fn sub(self, others: Self) -> Self {\n            let mut sum = self.x - others.x;\n            if sum < 0 {\n                sum += MOD;\n            }\n            Self::new(sum)\n        }\n    }\n    impl Mul for ModInt {\n        type Output = Self;\n        fn mul(self, others: Self) -> Self {\n            self.mul_fast(others)\n        }\n    }\n} // mod mod_int\n\n\nfn solve() {\n    use mod_int::*;\n    let n: usize = get();\n    let s: Vec<_> = get_word().chars().collect();\n    const A: usize = 5;\n    let b = [ModInt::new(41), ModInt::new(255), ModInt::new(36),\n             ModInt::new(17), ModInt::new(101)];\n    let mut hsh = vec![vec![ModInt::new(0); n + 1]; A];\n    let mut inv = [ModInt::new(0); A];\n    for i in 0 .. A { inv[i] = b[i].inv(); }\n    let mut pos = vec![0; n + 1];\n    for c in 0 .. A {\n        let mut p = 0;\n        let mut cur = ModInt::new(1);\n        for (i, &ch) in s.iter().enumerate() {\n            let mut tmp = hsh[c][i];\n            match ch {\n                '>' => {\n                    p += 1;\n                    cur = cur * b[c];\n                },\n                '<' => {\n                    p -= 1;\n                    cur = cur * inv[c];\n                },\n                '+' => tmp = tmp + cur,\n                '-' => tmp = tmp - cur,\n                _ => panic!(),\n            }\n            hsh[c][i + 1] = tmp;\n            pos[i + 1] = p;\n        }\n    }\n    let mut meguru = [ModInt::new(0); A];\n    for c in 0 .. A { meguru[c] = hsh[c][n]; }\n    let mut kirika = HashMap::new();\n    kirika.insert(meguru, 1);\n    let mut tot = 0;\n    for i in (0 .. n).rev() {\n        let mut cur = [ModInt::new(0); A];\n        for c in 0 .. A { cur[c] = b[c].pow(MOD - 1 + pos[i]); }\n        let mut ken = [ModInt::new(0); A];\n        for c in 0 .. A { ken[c] = cur[c] * meguru[c] + hsh[c][i]; }\n        tot += kirika.get(&ken).cloned().unwrap_or(0);\n        let mut tt = [ModInt::new(0); A];\n        for c in 0 .. A { tt[c] = hsh[c][i]; }\n        *kirika.entry(tt).or_insert(0) += 1;\n    }\n    println!(\"{}\", tot);\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::Read;\n#[allow(dead_code)]\nfn getline() -> String {\n    let mut ret = String::new();\n    std::io::stdin().read_line(&mut ret).ok().unwrap();\n    ret\n}\nfn get_word() -> String {\n    let mut stdin = std::io::stdin();\n    let mut u8b: [u8; 1] = [0];\n    loop {\n        let mut buf: Vec<u8> = Vec::with_capacity(16);\n        loop {\n            let res = stdin.read(&mut u8b);\n            if res.unwrap_or(0) == 0 || u8b[0] <= b' ' {\n                break;\n            } else {\n                buf.push(u8b[0]);\n            }\n        }\n        if buf.len() >= 1 {\n            let ret = String::from_utf8(buf).unwrap();\n            return ret;\n        }\n    }\n}\n\n#[allow(dead_code)]\nfn get<T: std::str::FromStr>() -> T { get_word().parse().ok().unwrap() }\n\nconst MOD: i64 = 1_000_000_007;\n\n/// Refers external ::MOD.\nmod mod_int {\n    use ::MOD;\n    use std::ops::*;\n    #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]\n    pub struct ModInt {\n        pub x: i64,\n    }\n    impl ModInt {\n        pub fn new(x: i64) -> Self { ModInt { x: x % MOD } }\n        #[allow(dead_code)]\n        pub fn mul_fast(self, others: Self) -> Self {\n            Self::new(self.x * others.x % MOD)\n        }\n        pub fn pow(self, mut e: i64) -> Self {\n            let mut sum = ModInt::new(1);\n            let mut cur = ModInt::new(self.x);\n            while e > 0 {\n                if e % 2 != 0 {\n                    sum = sum * cur;\n                }\n                cur = cur * cur;\n                e /= 2;\n            }\n            sum\n        }\n        pub fn inv(self) -> Self {\n            self.pow(MOD - 2)\n        }\n    }\n    impl Add for ModInt {\n        type Output = Self;\n        fn add(self, others: Self) -> Self {\n            let mut sum = self.x + others.x;\n            if sum >= MOD {\n                sum -= MOD;\n            }\n            Self::new(sum)\n        }\n    }\n    impl Sub for ModInt {\n        type Output = Self;\n        fn sub(self, others: Self) -> Self {\n            let mut sum = self.x - others.x;\n            if sum < 0 {\n                sum += MOD;\n            }\n            Self::new(sum)\n        }\n    }\n    impl Mul for ModInt {\n        type Output = Self;\n        fn mul(self, others: Self) -> Self {\n            self.mul_fast(others)\n        }\n    }\n} // mod mod_int\n\n\nfn solve() {\n    use mod_int::*;\n    let n: usize = get();\n    let s: Vec<_> = get_word().chars().collect();\n    const A: usize = 5;\n    let b = [ModInt::new(41), ModInt::new(255), ModInt::new(36),\n             ModInt::new(17), ModInt::new(101)];\n    let mut hsh = vec![vec![ModInt::new(0); n + 1]; A];\n    let mut inv = [ModInt::new(0); A];\n    for i in 0 .. A { inv[i] = b[i].inv(); }\n    let mut pos = vec![0; n + 1];\n    for c in 0 .. A {\n        let mut p = 0;\n        let mut cur = ModInt::new(1);\n        for (i, &ch) in s.iter().enumerate() {\n            let mut tmp = hsh[c][i];\n            match ch {\n                '>' => {\n                    p += 1;\n                    cur = cur * b[c];\n                },\n                '<' => {\n                    p -= 1;\n                    cur = cur * inv[c];\n                },\n                '+' => tmp = tmp + cur,\n                '-' => tmp = tmp - cur,\n                _ => panic!(),\n            }\n            hsh[c][i + 1] = tmp;\n            pos[i + 1] = p;\n        }\n    }\n    let mut meguru = [ModInt::new(0); A];\n    for c in 0 .. A { meguru[c] = hsh[c][n]; }\n    let mut kirika = HashMap::new();\n    kirika.insert(meguru, 1);\n    let mut tot = 0;\n    for i in (0 .. n).rev() {\n        let mut cur = [ModInt::new(0); A];\n        for c in 0 .. A { cur[c] = b[c].pow(MOD - 1 + pos[i]); }\n        let mut ken = [ModInt::new(0); A];\n        for c in 0 .. A { ken[c] = cur[c] * meguru[c] + hsh[c][i]; }\n        tot += kirika.get(&ken).cloned().unwrap_or(0);\n        let mut tt = [ModInt::new(0); A];\n        for c in 0 .. A { tt[c] = hsh[c][i]; }\n        *kirika.entry(tt).or_insert(0) += 1;\n    }\n    println!(\"{}\", tot);\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::Read;\n#[allow(dead_code)]\nfn getline() -> String {\n    let mut ret = String::new();\n    std::io::stdin().read_line(&mut ret).ok().unwrap();\n    ret\n}\nfn get_word() -> String {\n    let mut stdin = std::io::stdin();\n    let mut u8b: [u8; 1] = [0];\n    loop {\n        let mut buf: Vec<u8> = Vec::with_capacity(16);\n        loop {\n            let res = stdin.read(&mut u8b);\n            if res.unwrap_or(0) == 0 || u8b[0] <= b' ' {\n                break;\n            } else {\n                buf.push(u8b[0]);\n            }\n        }\n        if buf.len() >= 1 {\n            let ret = String::from_utf8(buf).unwrap();\n            return ret;\n        }\n    }\n}\n\n#[allow(dead_code)]\nfn get<T: std::str::FromStr>() -> T { get_word().parse().ok().unwrap() }\n\nmod mod_int {\n    use std::ops::*;\n    pub trait Mod: Copy + Clone {\n        fn m() -> i64;\n    }\n    #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]\n    pub struct ModInt<M: Mod> { pub x: i64, phantom: ::std::marker::PhantomData<*const M> }\n    impl<M: Mod> ModInt<M> {\n        fn check_integrity(self) {\n            debug_assert!(self.x >= 0);\n            debug_assert!(self.x < M::m());\n        }\n        // x >= 0\n        pub fn new(x: i64) -> Self { ModInt::new_internal(x % M::m()) }\n        fn new_internal(x: i64) -> Self { ModInt { x: x % M::m(), phantom: ::std::marker::PhantomData } }\n        #[allow(dead_code)]\n        pub fn mul_fast(self, other: Self) -> Self {\n            self.check_integrity();\n            other.check_integrity();\n            ModInt::new_internal(self.x * other.x % M::m())\n        }\n        #[allow(dead_code)]\n        pub fn mul_slow(self, other: Self) -> Self {\n            // Naive multiplication in order to avoid overflow\n            self.check_integrity();\n            other.check_integrity();\n            let mut sum = ModInt::new(0);\n            let mut cur = self;\n            let mut e = other.x;\n            if self.x < other.x {\n                cur = other;\n                e = self.x;\n            }\n            while e > 0 {\n                if e % 2 == 1 {\n                    sum = sum + cur;\n                }\n                cur = cur + cur;\n                e /= 2;\n            }\n            sum\n        }\n        pub fn pow(self, mut e: i64) -> Self {\n            self.check_integrity();\n            debug_assert!(e >= 0);\n            let mut sum = ModInt::new(1);\n            let mut cur = ModInt::new(self.x);\n            while e > 0 {\n                if e % 2 != 0 {\n                    sum = sum * cur;\n                }\n                cur = cur * cur;\n                e /= 2;\n            }\n            sum\n        }\n        pub fn inv(self) -> Self { self.pow(M::m() - 2) }\n    }\n    impl<M: Mod> Add for ModInt<M> {\n        type Output = Self;\n        fn add(self, other: Self) -> Self {\n            self.check_integrity();\n            other.check_integrity();\n            let mut sum = self.x + other.x;\n            if sum >= M::m() { sum -= M::m(); }\n            ModInt::new(sum)\n        }\n    }\n    impl<M: Mod> Sub for ModInt<M> {\n        type Output = Self;\n        fn sub(self, other: Self) -> Self {\n            self.check_integrity();\n            other.check_integrity();\n            let mut sum = self.x - other.x;\n            if sum < 0 { sum += M::m(); }\n            ModInt::new(sum)\n        }\n    }\n    impl<M: Mod> Mul for ModInt<M> {\n        type Output = Self;\n        fn mul(self, other: Self) -> Self {\n            self.mul_fast(other)\n        }\n    }\n} // mod mod_int\n\nmacro_rules! define_mod {\n    ($struct_name: ident, $modulo: expr) => {\n        #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n        struct $struct_name {}\n        impl mod_int::Mod for $struct_name { fn m() -> i64 { $modulo } }\n    }\n}\nconst MOD: i64 = 1_000_000_007;\ndefine_mod!(P, MOD);\ntype ModInt = mod_int::ModInt<P>;\n\n\nfn solve() {\n    //use mod_int::*;\n    let n: usize = get();\n    let s: Vec<_> = get_word().chars().collect();\n    const A: usize = 3;\n    let b = [ModInt::new(41), ModInt::new(255), ModInt::new(36)];\n    let mut hsh = vec![vec![ModInt::new(0); n + 1]; A];\n    let mut inv = [ModInt::new(0); A];\n    for i in 0 .. A { inv[i] = b[i].inv(); }\n    let mut pos = vec![0; n + 1];\n    for c in 0 .. A {\n        let mut p = 0;\n        let mut cur = ModInt::new(1);\n        for (i, &ch) in s.iter().enumerate() {\n            let mut tmp = hsh[c][i];\n            match ch {\n                '>' => {\n                    p += 1;\n                    cur = cur * b[c];\n                },\n                '<' => {\n                    p -= 1;\n                    cur = cur * inv[c];\n                },\n                '+' => tmp = tmp + cur,\n                '-' => tmp = tmp - cur,\n                _ => panic!(),\n            }\n            hsh[c][i + 1] = tmp;\n            pos[i + 1] = p;\n        }\n    }\n    let mut meguru = [ModInt::new(0); A];\n    for c in 0 .. A { meguru[c] = hsh[c][n]; }\n    let mut kirika = HashMap::new();\n    kirika.insert(meguru, 1);\n    let mut tot = 0i64;\n    for i in (0 .. n).rev() {\n        let mut cur = [ModInt::new(0); A];\n        for c in 0 .. A { cur[c] = b[c].pow(MOD - 1 + pos[i]); }\n        let mut ken = [ModInt::new(0); A];\n        for c in 0 .. A { ken[c] = cur[c] * meguru[c] + hsh[c][i]; }\n        tot += kirika.get(&ken).cloned().unwrap_or(0);\n        let mut tt = [ModInt::new(0); A];\n        for c in 0 .. A { tt[c] = hsh[c][i]; }\n        *kirika.entry(tt).or_insert(0) += 1;\n    }\n    println!(\"{}\", tot);\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "use proconio::{input, marker::Chars};\n\n// modint{{{\nmod modint {\n    //! [`Mint`] 型を提供します。\n    //!\n    //! [`Mint`]: struct.Mint.html\n\n    /// [`Mint`] の中に入れる数値型が実装していないといけないトレイトをまとめました。\n    ///\n    /// どうやら普通の符号付き整数型ならば大丈夫そうですね。\n    ///\n    /// いかがでしたでしょうか？（真顔）\n    ///\n    /// [`Mint`]: struct.Mint.html\n    pub trait ModValue:\n        std::ops::Add<Output = Self>\n        + std::ops::Sub<Output = Self>\n        + std::ops::Mul<Output = Self>\n        + std::ops::Div<Output = Self>\n        + std::ops::Rem<Output = Self>\n        + std::ops::AddAssign\n        + std::ops::SubAssign\n        + std::ops::MulAssign\n        + std::ops::DivAssign\n        + std::ops::RemAssign\n        + std::ops::Neg\n        + std::cmp::Ord\n        + Clone\n        + Copy\n        + Sized\n        + std::fmt::Debug\n        + std::fmt::Display\n    {\n    }\n\n    impl<\n            Value: std::ops::Add<Output = Self>\n                + std::ops::Sub<Output = Self>\n                + std::ops::Mul<Output = Self>\n                + std::ops::Div<Output = Self>\n                + std::ops::Rem<Output = Self>\n                + std::ops::AddAssign\n                + std::ops::SubAssign\n                + std::ops::MulAssign\n                + std::ops::DivAssign\n                + std::ops::RemAssign\n                + std::ops::Neg\n                + std::cmp::Ord\n                + Clone\n                + Copy\n                + Sized\n                + std::fmt::Debug\n                + std::fmt::Display,\n        > ModValue for Value\n    {\n    }\n\n    /// mod に関数情報を [`Mint`] に伝えるための型引数だッピ！\n    ///\n    /// [`Mint`]: struct.Mint.html\n    pub trait Minfo: Clone + Copy + std::fmt::Debug {\n        /// 中身の型です。\n        type Value: ModValue;\n\n        /// mod の値を返します。\n        fn modulus() -> Self::Value;\n\n        /// 0 を返します。\n        fn zero() -> Self::Value;\n\n        /// 1 を返します。\n        fn one() -> Self::Value;\n    }\n\n    /// 自動で mod を取ってくれる整数型です。\n    ///\n    /// 型引数は、トレイト [`Minfo`] を実装している必要があります。\n    ///\n    /// # Examples\n    ///\n    /// [`from_value`] によって、`Mint<Mod>` が作れます。\n    /// 逆に、[`value`] によって、中身がとれます。\n    ///\n    /// ```\n    /// use modint::Mint1000000007;\n    /// type Mint = Mint1000000007;\n    ///\n    /// let x: Mint = Mint::from_value(2);\n    ///\n    /// assert_eq!(x.value(), 2);\n    /// ```\n    ///\n    /// 四則演算ができます。\n    ///\n    /// ```\n    /// use modint::Mint1000000007;\n    /// type Mint = Mint1000000007;\n    ///\n    /// let x: Mint = Mint::from_value(6);\n    /// let y: Mint = Mint::from_value(2);\n    ///\n    /// assert_eq!((x + y).value(), 8);\n    /// assert_eq!((x - y).value(), 4);\n    /// assert_eq!((x * y).value(), 12);\n    /// assert_eq!((x / y).value(), 3);\n    /// ```\n    ///\n    /// [`value`]: #method.value\n    /// [`from_value`]: #method.from_value\n    /// [`Minfo`]:trait.Minfo.html\n\n    #[derive(Clone, Copy, Debug)]\n    pub struct Mint<Mod: Minfo>(Mod::Value);\n\n    impl<Mod: Minfo> Mint<Mod> {\n        #[inline]\n        #[allow(dead_code)]\n        fn is_within_the_range(x: Mod::Value) -> bool {\n            Mod::zero() <= x && x < Mod::modulus()\n        }\n\n        #[inline]\n        #[allow(dead_code)]\n        fn normalize(x: Mod::Value) -> Mod::Value {\n            if Self::is_within_the_range(x) {\n                x\n            } else {\n                let x = x % Mod::modulus();\n                if x < Mod::zero() {\n                    x + Mod::modulus()\n                } else {\n                    x\n                }\n            }\n        }\n\n        /// 0 を構築します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::zero();\n        /// assert_eq!(x.value(), 0);\n        /// ```\n        #[allow(dead_code)]\n        pub fn zero() -> Self {\n            Self(Mod::zero())\n        }\n\n        /// 1 を構築します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::one();\n        /// assert_eq!(x.value(), 1);\n        /// ```\n        #[allow(dead_code)]\n        pub fn one() -> Self {\n            Self(Mod::one())\n        }\n\n        /// mod を取得します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::modulus();\n        /// assert_eq!(x, 998244353);\n        /// ```\n        #[allow(dead_code)]\n        pub fn modulus() -> Mod::Value {\n            Mod::modulus()\n        }\n\n        /// 0 であるときに `true` を返します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::zero();\n        /// assert!(x.is_zero());\n        ///\n        /// let x = Mint::one();\n        /// assert!(!x.is_zero());\n        /// ```\n        #[allow(dead_code)]\n        pub fn is_zero(&self) -> bool {\n            self.value() == Mod::zero()\n        }\n\n        /// 構築します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::from_value(4);\n        /// ```\n        #[allow(dead_code)]\n        pub fn from_value(x: Mod::Value) -> Self {\n            Self(Self::normalize(x))\n        }\n\n        /// 中身を取得します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::from_value(4);\n        /// assert_eq!(x.value(), 4);\n        /// ```\n        #[allow(dead_code)]\n        pub fn value(&self) -> Mod::Value {\n            self.0\n        }\n\n        /// mod 逆元を計算します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::from_value(2);\n        /// assert_eq!(x.inv().value(), 499122177);\n        /// ```\n        #[allow(dead_code)]\n        pub fn inv(&self) -> Self {\n            if self.is_zero() {\n                panic!(\"inv(0)\");\n            }\n            Self(Self::raw_inv(self.value()))\n        }\n\n        /// ユークリッドの互除法を用いて、pow を計算します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// let x = Mint17::from_value(2);\n        /// assert_eq!(x.pow(6).value(), 64 % 17);\n        /// ```\n        #[allow(dead_code)]\n        pub fn pow(&self, b: u64) -> Self {\n            Self(Self::raw_pow(self.value(), b))\n        }\n\n        fn raw_add(x: Mod::Value, y: Mod::Value) -> Mod::Value {\n            let z = x + y;\n            if Mod::modulus() <= z {\n                z - Mod::modulus()\n            } else {\n                z\n            }\n        }\n\n        fn raw_sub(x: Mod::Value, y: Mod::Value) -> Mod::Value {\n            let z = x - y;\n            if z < Mod::zero() {\n                z + Mod::modulus()\n            } else {\n                z\n            }\n        }\n\n        fn raw_neg(x: Mod::Value) -> Mod::Value {\n            if x == Mod::zero() {\n                Mod::zero()\n            } else {\n                Mod::modulus() - x\n            }\n        }\n\n        fn raw_mul(x: Mod::Value, y: Mod::Value) -> Mod::Value {\n            x * y % Mod::modulus()\n        }\n\n        fn raw_div(x: Mod::Value, y: Mod::Value) -> Mod::Value {\n            Self::raw_mul(x, Self::raw_inv(y))\n        }\n\n        #[allow(clippy::many_single_char_names)]\n        fn raw_inv(mut x: Mod::Value) -> Mod::Value {\n            let mut y = Mod::modulus();\n            let mut u = Mod::one();\n            let mut v = Mod::zero();\n            while x != Mod::zero() {\n                let q = y / x;\n                y -= x * q;\n                v -= u * q;\n                std::mem::swap(&mut x, &mut y);\n                std::mem::swap(&mut u, &mut v);\n            }\n            if v < Mod::zero() {\n                v + Mod::modulus()\n            } else {\n                v\n            }\n        }\n\n        fn raw_pow(mut a: Mod::Value, mut b: u64) -> Mod::Value {\n            let mut x = Mod::one();\n            while 0 < b {\n                if b % 2 == 1 {\n                    x = Self::raw_mul(x, a);\n                }\n                a = Self::raw_mul(a, a);\n                b /= 2\n            }\n            x\n        }\n    }\n\n    macro_rules! impl_biop {\n    (\n        $(\n            $biop_trait: ident::$biop_fn: ident,\n            $biop_assign_trait: ident::$biop_assign_fn: ident,\n            $biop_impl: ident;\n        )*\n    ) => {\n        $(\n            impl<Mod: Minfo> std::ops::$biop_trait for Mint<Mod> {\n                type Output = Self;\n                fn $biop_fn(self, rhs: Self) -> Self::Output {\n                    Mint(Self::$biop_impl(self.value(), rhs.value()))\n                }\n            }\n            impl<Mod: Minfo> std::ops::$biop_assign_trait for Mint<Mod>\n            where\n                Self: Copy\n            {\n                fn $biop_assign_fn(&mut self, rhs: Self) {\n                    use std::ops::$biop_trait;\n                    *self = Mint::$biop_fn(*self, rhs)\n                }\n            }\n        )*\n    };\n}\n\n    impl_biop! {\n        Add::add, AddAssign::add_assign, raw_add;\n        Sub::sub, SubAssign::sub_assign, raw_sub;\n        Mul::mul, MulAssign::mul_assign, raw_mul;\n        Div::div, DivAssign::div_assign, raw_div;\n    }\n\n    impl<Mod: Minfo> std::ops::Neg for Mint<Mod> {\n        type Output = Self;\n        fn neg(self) -> Self::Output {\n            Self(Self::raw_neg(self.value()))\n        }\n    }\n\n    impl<Mod: Minfo> std::cmp::PartialEq for Mint<Mod> {\n        /// 中身をそのまま 比較です。\n        /// 構築時に normalize され、それ以降も normalized な状態に保たれますから、\n        /// 結局あまりを比較しているのと同じことになります。\n        ///\n        /// # Example\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// assert_eq!(Mint17::from_value(3), Mint::from_value(-31));\n        /// assert_eq!(Mint17::from_value(3), Mint::from_value(-14));\n        /// assert_eq!(Mint17::from_value(3), Mint::from_value(3));\n        /// assert_eq!(Mint17::from_value(3), Mint::from_value(20));\n        /// assert_eq!(Mint17::from_value(3), Mint::from_value(37));\n        ///\n        /// assert_ne!(Mint17::from_value(3), Mint::from_value(31));\n        /// assert_ne!(Mint17::from_value(3), Mint::from_value(14));\n        /// assert_ne!(Mint17::from_value(3), Mint::from_value(-3));\n        /// assert_ne!(Mint17::from_value(3), Mint::from_value(-20));\n        /// assert_ne!(Mint17::from_value(3), Mint::from_value(-37));\n        /// ```\n        fn eq(&self, other: &Self) -> bool {\n            self.value().eq(&other.value())\n        }\n    }\n    impl<Mod: Minfo> std::cmp::Eq for Mint<Mod> {}\n\n    impl<Mod: Minfo> std::fmt::Display for Mint<Mod> {\n        /// 中身をそのまま Display です。\n        ///\n        /// # Example\n        ///\n        /// ```\n        /// println!(\"{}\", modint::Mint998244353::from_value(42));\n        /// ```\n        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n            write!(f, \"{}\", self.value())\n        }\n    }\n\n    impl<Mod: Minfo> std::iter::Sum<Self> for Mint<Mod> {\n        /// 総和を取ります。\n        ///\n        /// # Example\n        ///\n        /// ```\n        /// use modint::{define_mint, Minfo, Mint};\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        /// assert_eq!(\n        ///     vec![\n        ///         Mint17::from_value(2),\n        ///         Mint17::from_value(4),\n        ///         Mint17::from_value(6),\n        ///         Mint17::from_value(8),\n        ///     ]\n        ///     .into_iter()\n        ///     .sum::<Mint17>(),\n        ///     Mint17::from_value(3)\n        /// );\n        /// ```\n        fn sum<I: Iterator<Item = Self>>(iter: I) -> Self {\n            iter.fold(Mint::zero(), |acc, x| acc + x)\n        }\n    }\n\n    impl<Mod: Minfo> std::iter::Product<Self> for Mint<Mod> {\n        /// 総積を取ります。\n        ///\n        /// # Example\n        ///\n        /// ```\n        /// use modint::{define_mint, Minfo, Mint};\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        /// assert_eq!(\n        ///     vec![\n        ///         Mint17::from_value(1),\n        ///         Mint17::from_value(2),\n        ///         Mint17::from_value(3),\n        ///         Mint17::from_value(4),\n        ///     ]\n        ///     .into_iter()\n        ///     .product::<Mint17>(),\n        ///     Mint17::from_value(7)\n        /// );\n        /// ```\n        fn product<I: Iterator<Item = Self>>(iter: I) -> Self {\n            iter.fold(Mint::one(), |acc, x| acc * x)\n        }\n    }\n\n    /// 階乗とその逆元を前計算するマシーンです。\n    #[allow(dead_code)]\n    pub struct Factorial<Mod: Minfo> {\n        normal: Vec<Mint<Mod>>,\n        inverted: Vec<Mint<Mod>>,\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo> Factorial<Mod>\n    where\n        Mod::Value: std::convert::TryFrom<usize, Error = std::num::TryFromIntError>,\n    {\n        /// サイズを指定して初期化です。\n        /// 最大値は一つ小さくなりますから、注意です。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, Factorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        /// let fact = Factorial::<Minfo17>::new(16);\n        /// ```\n        pub fn new(n: usize) -> Self {\n            use std::convert::TryFrom;\n            let mut normal = vec![Mint::one(); n];\n            for i in 1..n {\n                normal[i] = normal[i - 1] * Mint::from_value(Mod::Value::try_from(i).unwrap());\n            }\n            let mut inverted = vec![Mint::one(); n];\n            inverted[n - 1] = normal[n - 1].inv();\n            for i in (1..n).rev() {\n                inverted[i - 1] = inverted[i] * Mint::from_value(Mod::Value::try_from(i).unwrap());\n            }\n            Self { normal, inverted }\n        }\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo> Factorial<Mod> {\n        /// 階乗の逆元を取得します。\n        ///\n        /// 逆元でなくて普通の階乗は、[`implementations`] をご覧いただけると幸いです。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, Factorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// let fact = Factorial::<Minfo17>::new(17);\n        ///\n        /// for i in 0..17 {\n        ///     assert_eq!(fact[i] * fact.inverted(i), Mint17::one());\n        /// }\n        /// ```\n        ///\n        /// [`implementations`]: #implementations\n        ///\n        pub fn inverted(&self, i: usize) -> Mint<Mod> {\n            self.inverted[i]\n        }\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo, I: std::slice::SliceIndex<[Mint<Mod>]>> std::ops::Index<I> for Factorial<Mod> {\n        type Output = I::Output;\n\n        /// Index でも取ることができます。\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, Factorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// let fact = Factorial::<Minfo17>::new(17);\n        ///\n        /// assert_eq!(fact[0], Mint17::from_value(1));\n        /// assert_eq!(fact[1], Mint17::from_value(1));\n        /// assert_eq!(fact[2], Mint17::from_value(2));\n        /// assert_eq!(fact[3], Mint17::from_value(6));\n        /// assert_eq!(fact[4], Mint17::from_value(24 % 17));\n        /// assert_eq!(fact[5], Mint17::from_value(120 % 17));\n        /// ```\n        #[inline]\n        fn index(&self, index: I) -> &Self::Output {\n            &self.normal[index]\n        }\n    }\n\n    /// 二重階乗とその逆元を前計算するマシーンです。\n    #[allow(dead_code)]\n    pub struct DoubleFactorial<Mod: Minfo> {\n        normal: Vec<Mint<Mod>>,\n        inverted: Vec<Mint<Mod>>,\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo> DoubleFactorial<Mod>\n    where\n        Mod::Value: std::convert::TryFrom<usize, Error = std::num::TryFromIntError>,\n    {\n        /// サイズを指定して初期化です。\n        /// 最大値は一つ小さくなりますから、注意です。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, DoubleFactorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        /// let fact = DoubleFactorial::<Minfo17>::new(16);\n        /// ```\n        pub fn new(n: usize) -> Self {\n            use std::convert::TryFrom;\n            let mut normal = vec![Mint::one(); n];\n            for i in 2..n {\n                normal[i] = normal[i - 2] * Mint::from_value(Mod::Value::try_from(i).unwrap());\n            }\n            let mut inverted = vec![Mint::one(); n];\n            inverted[n - 1] = normal[n - 1].inv();\n            inverted[n - 2] = normal[n - 2].inv();\n            for i in (2..n).rev() {\n                inverted[i - 2] = inverted[i] * Mint::from_value(Mod::Value::try_from(i).unwrap());\n            }\n            Self { normal, inverted }\n        }\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo> DoubleFactorial<Mod> {\n        /// 二重階乗の逆元を取得します。\n        ///\n        /// 逆元でなくて普通の二重階乗は、[`implementations`] をご覧いただけると幸いです。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, DoubleFactorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// let fact = DoubleFactorial::<Minfo17>::new(17);\n        ///\n        /// for i in 0..17 {\n        ///     assert_eq!(fact[i] * fact.inverted(i), Mint17::one());\n        /// }\n        /// ```\n        ///\n        /// [`implementations`]: #implementations\n        ///\n        pub fn inverted(&self, i: usize) -> Mint<Mod> {\n            self.inverted[i]\n        }\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo, I: std::slice::SliceIndex<[Mint<Mod>]>> std::ops::Index<I>\n        for DoubleFactorial<Mod>\n    {\n        type Output = I::Output;\n\n        /// Index でも取ることができます。\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, DoubleFactorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// let fact = DoubleFactorial::<Minfo17>::new(17);\n        ///\n        /// assert_eq!(fact[0], Mint17::from_value(1));\n        /// assert_eq!(fact[1], Mint17::from_value(1));\n        /// assert_eq!(fact[2], Mint17::from_value(2));\n        /// assert_eq!(fact[3], Mint17::from_value(3));\n        /// assert_eq!(fact[4], Mint17::from_value(8));\n        /// assert_eq!(fact[5], Mint17::from_value(15));\n        /// ```\n        #[inline]\n        fn index(&self, index: I) -> &Self::Output {\n            &self.normal[index]\n        }\n    }\n\n    /// Mint 型を定義するためのマクロです。\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use modint::{define_mint, Minfo, Mint};\n    ///\n    /// define_mint! {\n    ///     struct Mint17(Minfo17(17; i64));\n    /// }\n    ///\n    /// let x = Mint17::from_value(1);\n    /// let y = Mint17::from_value(2);\n    /// let z = x / y;\n    /// assert_eq!(z.value(), 9);\n    /// ```\n    #[macro_export]\n    macro_rules! define_mint {\n        (\n        struct $modint: ident ($modinfo: ident ($modvalue: expr; $modty: ty));\n    ) => {\n            #[allow(dead_code)]\n            #[derive(Clone, Copy, Debug)]\n            pub struct $modinfo {}\n            impl Minfo for $modinfo {\n                type Value = $modty;\n                fn modulus() -> Self::Value {\n                    $modvalue\n                }\n                fn zero() -> Self::Value {\n                    0\n                }\n                fn one() -> Self::Value {\n                    1\n                }\n            }\n            type $modint = Mint<$modinfo>;\n        };\n    }\n\n    /// Mod = 1000000007 なる Minfo です。\n    #[allow(dead_code)]\n    #[derive(Clone, Copy, Debug)]\n    pub struct Minfo1000000007 {}\n\n    impl Minfo for Minfo1000000007 {\n        type Value = i64;\n        fn modulus() -> Self::Value {\n            1_000_000_007\n        }\n        fn zero() -> Self::Value {\n            0\n        }\n        fn one() -> Self::Value {\n            1\n        }\n    }\n\n    /// Mod = 1000000007 なる Mint です。\n    #[allow(dead_code)]\n    pub type Mint1000000007 = Mint<Minfo1000000007>;\n\n    /// Mod = 998244353 なる Minfo です。\n    #[allow(dead_code)]\n    #[derive(Clone, Copy, Debug)]\n    pub struct Minfo998244353 {}\n\n    impl Minfo for Minfo998244353 {\n        type Value = i64;\n        fn modulus() -> Self::Value {\n            998_244_353\n        }\n        fn zero() -> Self::Value {\n            0\n        }\n        fn one() -> Self::Value {\n            1\n        }\n    }\n\n    /// Mod = 998244353 なる Mint です。\n    #[allow(dead_code)]\n    pub type Mint998244353 = Mint<Minfo998244353>;\n}\n//}}}\n\ntype Mint = modint::Mint998244353;\n\nfn main() {\n    input!(n: usize, mut s: Chars);\n    s.reverse();\n    let make = |x: Mint| -> Vec<(Mint, Mint)> {\n        let mut ans = vec![(Mint::one(), Mint::zero()); n + 1];\n        for (i, &c) in s.iter().enumerate() {\n            let (a, b) = ans[i];\n            ans[i + 1] = match c {\n                '+' => (a, b + Mint::one()),\n                '-' => (a, b - Mint::one()),\n                '<' => (a * x, b * x),\n                '>' => (a / x, b / x),\n                _ => panic!(),\n            }\n        }\n        ans\n    };\n\n    let keys: Vec<_> = vec![\n        100_000_000,\n        200_000_000,\n        300_000_000,\n        400_000_000,\n        500_000_000,\n        600_000_000,\n        700_000_000,\n        800_000_000,\n    ]\n    .into_iter()\n    .map(Mint::from_value)\n    .collect();\n    let seqs: Vec<_> = keys.iter().copied().map(make).collect();\n    let mut btree_map = std::collections::BTreeMap::<Vec<_>, _>::new();\n    let mut ans = 0;\n    for i in 0..=n {\n        if let Some(x) = btree_map.get(\n            &(0..keys.len())\n                .map(|j| {\n                    let (a, b) = seqs[j][i];\n                    ((b - seqs[j][n].1) / a).value()\n                })\n                .collect::<Vec<_>>(),\n        ) {\n            ans += x;\n        }\n        *btree_map\n            .entry(\n                (0..keys.len())\n                    .map(|j| {\n                        let (a, b) = seqs[j][i];\n                        (b / a).value()\n                    })\n                    .collect(),\n            )\n            .or_insert(0) += 1;\n    }\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::Read;\n#[allow(dead_code)]\nfn getline() -> String {\n    let mut ret = String::new();\n    std::io::stdin().read_line(&mut ret).ok().unwrap();\n    ret\n}\nfn get_word() -> String {\n    let mut stdin = std::io::stdin();\n    let mut u8b: [u8; 1] = [0];\n    loop {\n        let mut buf: Vec<u8> = Vec::with_capacity(16);\n        loop {\n            let res = stdin.read(&mut u8b);\n            if res.unwrap_or(0) == 0 || u8b[0] <= b' ' {\n                break;\n            } else {\n                buf.push(u8b[0]);\n            }\n        }\n        if buf.len() >= 1 {\n            let ret = String::from_utf8(buf).unwrap();\n            return ret;\n        }\n    }\n}\n\n#[allow(dead_code)]\nfn get<T: std::str::FromStr>() -> T { get_word().parse().ok().unwrap() }\n\nconst MOD: i64 = 1_000_000_007;\n\n/// Refers external ::MOD.\nmod mod_int {\n    use ::MOD;\n    use std::ops::*;\n    #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]\n    pub struct ModInt {\n        pub x: i64,\n    }\n    impl ModInt {\n        pub fn new(x: i64) -> Self { ModInt { x: x % MOD } }\n        #[allow(dead_code)]\n        pub fn mul_fast(self, other: Self) -> Self {\n            assert!(self.x >= 0);\n            assert!(other.x >= 0);\n            Self::new(self.x * other.x % MOD)\n        }\n        pub fn pow(self, mut e: i64) -> Self {\n            assert!(self.x >= 0);\n            assert!(e >= 0);\n            let mut sum = ModInt::new(1);\n            let mut cur = ModInt::new(self.x);\n            while e > 0 {\n                if e % 2 != 0 {\n                    sum = sum * cur;\n                }\n                cur = cur * cur;\n                e /= 2;\n            }\n            sum\n        }\n        pub fn inv(self) -> Self {\n            self.pow(MOD - 2)\n        }\n    }\n    impl Add for ModInt {\n        type Output = Self;\n        fn add(self, other: Self) -> Self {\n            assert!(self.x >= 0);\n            assert!(other.x >= 0);\n            let mut sum = self.x + other.x;\n            if sum >= MOD {\n                sum -= MOD;\n            }\n            Self::new(sum)\n        }\n    }\n    impl Sub for ModInt {\n        type Output = Self;\n        fn sub(self, other: Self) -> Self {\n            assert!(self.x >= 0);\n            assert!(other.x >= 0);\n            let mut sum = self.x - other.x;\n            if sum < 0 {\n                sum += MOD;\n            }\n            Self::new(sum)\n        }\n    }\n    impl Mul for ModInt {\n        type Output = Self;\n        fn mul(self, others: Self) -> Self {\n            self.mul_fast(others)\n        }\n    }\n} // mod mod_int\n\n\nfn solve() {\n    use mod_int::*;\n    let n: usize = get();\n    let s: Vec<_> = get_word().chars().collect();\n    const A: usize = 6;\n    let b = [ModInt::new(41), ModInt::new(255), ModInt::new(36),\n             ModInt::new(17), ModInt::new(101), ModInt::new(1524526)];\n    let mut hsh = vec![vec![ModInt::new(0); n + 1]; A];\n    let mut inv = [ModInt::new(0); A];\n    for i in 0 .. A { inv[i] = b[i].inv(); }\n    let mut pos = vec![0; n + 1];\n    for c in 0 .. A {\n        let mut p = 0;\n        let mut cur = ModInt::new(1);\n        for (i, &ch) in s.iter().enumerate() {\n            let mut tmp = hsh[c][i];\n            match ch {\n                '>' => {\n                    p += 1;\n                    cur = cur * b[c];\n                },\n                '<' => {\n                    p -= 1;\n                    cur = cur * inv[c];\n                },\n                '+' => tmp = tmp + cur,\n                '-' => tmp = tmp - cur,\n                _ => panic!(),\n            }\n            hsh[c][i + 1] = tmp;\n            pos[i + 1] = p;\n        }\n    }\n    let mut meguru = [ModInt::new(0); A];\n    for c in 0 .. A { meguru[c] = hsh[c][n]; }\n    let mut kirika = HashMap::new();\n    kirika.insert(meguru, 1);\n    let mut tot = 0;\n    for i in (0 .. n).rev() {\n        let mut cur = [ModInt::new(0); A];\n        for c in 0 .. A { cur[c] = b[c].pow(MOD - 1 + pos[i]); }\n        let mut ken = [ModInt::new(0); A];\n        for c in 0 .. A { ken[c] = cur[c] * meguru[c] + hsh[c][i]; }\n        tot += kirika.get(&ken).cloned().unwrap_or(0);\n        let mut tt = [ModInt::new(0); A];\n        for c in 0 .. A { tt[c] = hsh[c][i]; }\n        *kirika.entry(tt).or_insert(0) += 1;\n    }\n    println!(\"{}\", tot);\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "use proconio::{input, marker::Chars};\n\n// modint{{{\nmod modint {\n    //! [`Mint`] 型を提供します。\n    //!\n    //! [`Mint`]: struct.Mint.html\n\n    /// [`Mint`] の中に入れる数値型が実装していないといけないトレイトをまとめました。\n    ///\n    /// どうやら普通の符号付き整数型ならば大丈夫そうですね。\n    ///\n    /// いかがでしたでしょうか？（真顔）\n    ///\n    /// [`Mint`]: struct.Mint.html\n    pub trait ModValue:\n        std::ops::Add<Output = Self>\n        + std::ops::Sub<Output = Self>\n        + std::ops::Mul<Output = Self>\n        + std::ops::Div<Output = Self>\n        + std::ops::Rem<Output = Self>\n        + std::ops::AddAssign\n        + std::ops::SubAssign\n        + std::ops::MulAssign\n        + std::ops::DivAssign\n        + std::ops::RemAssign\n        + std::ops::Neg\n        + std::cmp::Ord\n        + Clone\n        + Copy\n        + Sized\n        + std::fmt::Debug\n        + std::fmt::Display\n    {\n    }\n\n    impl<\n            Value: std::ops::Add<Output = Self>\n                + std::ops::Sub<Output = Self>\n                + std::ops::Mul<Output = Self>\n                + std::ops::Div<Output = Self>\n                + std::ops::Rem<Output = Self>\n                + std::ops::AddAssign\n                + std::ops::SubAssign\n                + std::ops::MulAssign\n                + std::ops::DivAssign\n                + std::ops::RemAssign\n                + std::ops::Neg\n                + std::cmp::Ord\n                + Clone\n                + Copy\n                + Sized\n                + std::fmt::Debug\n                + std::fmt::Display,\n        > ModValue for Value\n    {\n    }\n\n    /// mod に関数情報を [`Mint`] に伝えるための型引数だッピ！\n    ///\n    /// [`Mint`]: struct.Mint.html\n    pub trait Minfo: Clone + Copy + std::fmt::Debug {\n        /// 中身の型です。\n        type Value: ModValue;\n\n        /// mod の値を返します。\n        fn modulus() -> Self::Value;\n\n        /// 0 を返します。\n        fn zero() -> Self::Value;\n\n        /// 1 を返します。\n        fn one() -> Self::Value;\n    }\n\n    /// 自動で mod を取ってくれる整数型です。\n    ///\n    /// 型引数は、トレイト [`Minfo`] を実装している必要があります。\n    ///\n    /// # Examples\n    ///\n    /// [`from_value`] によって、`Mint<Mod>` が作れます。\n    /// 逆に、[`value`] によって、中身がとれます。\n    ///\n    /// ```\n    /// use modint::Mint1000000007;\n    /// type Mint = Mint1000000007;\n    ///\n    /// let x: Mint = Mint::from_value(2);\n    ///\n    /// assert_eq!(x.value(), 2);\n    /// ```\n    ///\n    /// 四則演算ができます。\n    ///\n    /// ```\n    /// use modint::Mint1000000007;\n    /// type Mint = Mint1000000007;\n    ///\n    /// let x: Mint = Mint::from_value(6);\n    /// let y: Mint = Mint::from_value(2);\n    ///\n    /// assert_eq!((x + y).value(), 8);\n    /// assert_eq!((x - y).value(), 4);\n    /// assert_eq!((x * y).value(), 12);\n    /// assert_eq!((x / y).value(), 3);\n    /// ```\n    ///\n    /// [`value`]: #method.value\n    /// [`from_value`]: #method.from_value\n    /// [`Minfo`]:trait.Minfo.html\n\n    #[derive(Clone, Copy, Debug)]\n    pub struct Mint<Mod: Minfo>(Mod::Value);\n\n    impl<Mod: Minfo> Mint<Mod> {\n        #[inline]\n        #[allow(dead_code)]\n        fn is_within_the_range(x: Mod::Value) -> bool {\n            Mod::zero() <= x && x < Mod::modulus()\n        }\n\n        #[inline]\n        #[allow(dead_code)]\n        fn normalize(x: Mod::Value) -> Mod::Value {\n            if Self::is_within_the_range(x) {\n                x\n            } else {\n                let x = x % Mod::modulus();\n                if x < Mod::zero() {\n                    x + Mod::modulus()\n                } else {\n                    x\n                }\n            }\n        }\n\n        /// 0 を構築します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::zero();\n        /// assert_eq!(x.value(), 0);\n        /// ```\n        #[allow(dead_code)]\n        pub fn zero() -> Self {\n            Self(Mod::zero())\n        }\n\n        /// 1 を構築します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::one();\n        /// assert_eq!(x.value(), 1);\n        /// ```\n        #[allow(dead_code)]\n        pub fn one() -> Self {\n            Self(Mod::one())\n        }\n\n        /// mod を取得します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::modulus();\n        /// assert_eq!(x, 998244353);\n        /// ```\n        #[allow(dead_code)]\n        pub fn modulus() -> Mod::Value {\n            Mod::modulus()\n        }\n\n        /// 0 であるときに `true` を返します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::zero();\n        /// assert!(x.is_zero());\n        ///\n        /// let x = Mint::one();\n        /// assert!(!x.is_zero());\n        /// ```\n        #[allow(dead_code)]\n        pub fn is_zero(&self) -> bool {\n            self.value() == Mod::zero()\n        }\n\n        /// 構築します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::from_value(4);\n        /// ```\n        #[allow(dead_code)]\n        pub fn from_value(x: Mod::Value) -> Self {\n            Self(Self::normalize(x))\n        }\n\n        /// 中身を取得します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::from_value(4);\n        /// assert_eq!(x.value(), 4);\n        /// ```\n        #[allow(dead_code)]\n        pub fn value(&self) -> Mod::Value {\n            self.0\n        }\n\n        /// mod 逆元を計算します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::Mint998244353;\n        /// type Mint = Mint998244353;\n        ///\n        /// let x = Mint::from_value(2);\n        /// assert_eq!(x.inv().value(), 499122177);\n        /// ```\n        #[allow(dead_code)]\n        pub fn inv(&self) -> Self {\n            if self.is_zero() {\n                panic!(\"inv(0)\");\n            }\n            Self(Self::raw_inv(self.value()))\n        }\n\n        /// ユークリッドの互除法を用いて、pow を計算します。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// let x = Mint17::from_value(2);\n        /// assert_eq!(x.pow(6).value(), 64 % 17);\n        /// ```\n        #[allow(dead_code)]\n        pub fn pow(&self, b: u64) -> Self {\n            Self(Self::raw_pow(self.value(), b))\n        }\n\n        fn raw_add(x: Mod::Value, y: Mod::Value) -> Mod::Value {\n            let z = x + y;\n            if Mod::modulus() <= z {\n                z - Mod::modulus()\n            } else {\n                z\n            }\n        }\n\n        fn raw_sub(x: Mod::Value, y: Mod::Value) -> Mod::Value {\n            let z = x - y;\n            if z < Mod::zero() {\n                z + Mod::modulus()\n            } else {\n                z\n            }\n        }\n\n        fn raw_neg(x: Mod::Value) -> Mod::Value {\n            if x == Mod::zero() {\n                Mod::zero()\n            } else {\n                Mod::modulus() - x\n            }\n        }\n\n        fn raw_mul(x: Mod::Value, y: Mod::Value) -> Mod::Value {\n            x * y % Mod::modulus()\n        }\n\n        fn raw_div(x: Mod::Value, y: Mod::Value) -> Mod::Value {\n            Self::raw_mul(x, Self::raw_inv(y))\n        }\n\n        #[allow(clippy::many_single_char_names)]\n        fn raw_inv(mut x: Mod::Value) -> Mod::Value {\n            let mut y = Mod::modulus();\n            let mut u = Mod::one();\n            let mut v = Mod::zero();\n            while x != Mod::zero() {\n                let q = y / x;\n                y -= x * q;\n                v -= u * q;\n                std::mem::swap(&mut x, &mut y);\n                std::mem::swap(&mut u, &mut v);\n            }\n            Self::normalize(v)\n        }\n\n        fn raw_pow(mut a: Mod::Value, mut b: u64) -> Mod::Value {\n            let mut x = Mod::one();\n            while 0 < b {\n                if b % 2 == 1 {\n                    x = Self::raw_mul(x, a);\n                }\n                a = Self::raw_mul(a, a);\n                b /= 2\n            }\n            x\n        }\n    }\n\n    macro_rules! impl_biop {\n    (\n        $(\n            $biop_trait: ident::$biop_fn: ident,\n            $biop_assign_trait: ident::$biop_assign_fn: ident,\n            $biop_impl: ident;\n        )*\n    ) => {\n        $(\n            impl<Mod: Minfo> std::ops::$biop_trait for Mint<Mod> {\n                type Output = Self;\n                fn $biop_fn(self, rhs: Self) -> Self::Output {\n                    Mint(Self::$biop_impl(self.value(), rhs.value()))\n                }\n            }\n            impl<Mod: Minfo> std::ops::$biop_assign_trait for Mint<Mod>\n            where\n                Self: Copy\n            {\n                fn $biop_assign_fn(&mut self, rhs: Self) {\n                    use std::ops::$biop_trait;\n                    *self = Mint::$biop_fn(*self, rhs)\n                }\n            }\n        )*\n    };\n}\n\n    impl_biop! {\n        Add::add, AddAssign::add_assign, raw_add;\n        Sub::sub, SubAssign::sub_assign, raw_sub;\n        Mul::mul, MulAssign::mul_assign, raw_mul;\n        Div::div, DivAssign::div_assign, raw_div;\n    }\n\n    impl<Mod: Minfo> std::ops::Neg for Mint<Mod> {\n        type Output = Self;\n        fn neg(self) -> Self::Output {\n            Self(Self::raw_neg(self.value()))\n        }\n    }\n\n    impl<Mod: Minfo> std::cmp::PartialEq for Mint<Mod> {\n        /// 中身をそのまま 比較です。\n        /// 構築時に normalize され、それ以降も normalized な状態に保たれますから、\n        /// 結局あまりを比較しているのと同じことになります。\n        ///\n        /// # Example\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// assert_eq!(Mint17::from_value(3), Mint::from_value(-31));\n        /// assert_eq!(Mint17::from_value(3), Mint::from_value(-14));\n        /// assert_eq!(Mint17::from_value(3), Mint::from_value(3));\n        /// assert_eq!(Mint17::from_value(3), Mint::from_value(20));\n        /// assert_eq!(Mint17::from_value(3), Mint::from_value(37));\n        ///\n        /// assert_ne!(Mint17::from_value(3), Mint::from_value(31));\n        /// assert_ne!(Mint17::from_value(3), Mint::from_value(14));\n        /// assert_ne!(Mint17::from_value(3), Mint::from_value(-3));\n        /// assert_ne!(Mint17::from_value(3), Mint::from_value(-20));\n        /// assert_ne!(Mint17::from_value(3), Mint::from_value(-37));\n        /// ```\n        fn eq(&self, other: &Self) -> bool {\n            self.value().eq(&other.value())\n        }\n    }\n    impl<Mod: Minfo> std::cmp::Eq for Mint<Mod> {}\n\n    impl<Mod: Minfo> std::fmt::Display for Mint<Mod> {\n        /// 中身をそのまま Display です。\n        ///\n        /// # Example\n        ///\n        /// ```\n        /// println!(\"{}\", modint::Mint998244353::from_value(42));\n        /// ```\n        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n            write!(f, \"{}\", self.value())\n        }\n    }\n\n    impl<Mod: Minfo> std::iter::Sum<Self> for Mint<Mod> {\n        /// 総和を取ります。\n        ///\n        /// # Example\n        ///\n        /// ```\n        /// use modint::{define_mint, Minfo, Mint};\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        /// assert_eq!(\n        ///     vec![\n        ///         Mint17::from_value(2),\n        ///         Mint17::from_value(4),\n        ///         Mint17::from_value(6),\n        ///         Mint17::from_value(8),\n        ///     ]\n        ///     .into_iter()\n        ///     .sum::<Mint17>(),\n        ///     Mint17::from_value(3)\n        /// );\n        /// ```\n        fn sum<I: Iterator<Item = Self>>(iter: I) -> Self {\n            iter.fold(Mint::zero(), |acc, x| acc + x)\n        }\n    }\n\n    impl<Mod: Minfo> std::iter::Product<Self> for Mint<Mod> {\n        /// 総積を取ります。\n        ///\n        /// # Example\n        ///\n        /// ```\n        /// use modint::{define_mint, Minfo, Mint};\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        /// assert_eq!(\n        ///     vec![\n        ///         Mint17::from_value(1),\n        ///         Mint17::from_value(2),\n        ///         Mint17::from_value(3),\n        ///         Mint17::from_value(4),\n        ///     ]\n        ///     .into_iter()\n        ///     .product::<Mint17>(),\n        ///     Mint17::from_value(7)\n        /// );\n        /// ```\n        fn product<I: Iterator<Item = Self>>(iter: I) -> Self {\n            iter.fold(Mint::one(), |acc, x| acc * x)\n        }\n    }\n\n    /// 階乗とその逆元を前計算するマシーンです。\n    #[allow(dead_code)]\n    pub struct Factorial<Mod: Minfo> {\n        normal: Vec<Mint<Mod>>,\n        inverted: Vec<Mint<Mod>>,\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo> Factorial<Mod>\n    where\n        Mod::Value: std::convert::TryFrom<usize, Error = std::num::TryFromIntError>,\n    {\n        /// サイズを指定して初期化です。\n        /// 最大値は一つ小さくなりますから、注意です。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, Factorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        /// let fact = Factorial::<Minfo17>::new(16);\n        /// ```\n        pub fn new(n: usize) -> Self {\n            use std::convert::TryFrom;\n            let mut normal = vec![Mint::one(); n];\n            for i in 1..n {\n                normal[i] = normal[i - 1] * Mint::from_value(Mod::Value::try_from(i).unwrap());\n            }\n            let mut inverted = vec![Mint::one(); n];\n            inverted[n - 1] = normal[n - 1].inv();\n            for i in (1..n).rev() {\n                inverted[i - 1] = inverted[i] * Mint::from_value(Mod::Value::try_from(i).unwrap());\n            }\n            Self { normal, inverted }\n        }\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo> Factorial<Mod> {\n        /// 階乗の逆元を取得します。\n        ///\n        /// 逆元でなくて普通の階乗は、[`implementations`] をご覧いただけると幸いです。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, Factorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// let fact = Factorial::<Minfo17>::new(17);\n        ///\n        /// for i in 0..17 {\n        ///     assert_eq!(fact[i] * fact.inverted(i), Mint17::one());\n        /// }\n        /// ```\n        ///\n        /// [`implementations`]: #implementations\n        ///\n        pub fn inverted(&self, i: usize) -> Mint<Mod> {\n            self.inverted[i]\n        }\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo, I: std::slice::SliceIndex<[Mint<Mod>]>> std::ops::Index<I> for Factorial<Mod> {\n        type Output = I::Output;\n\n        /// Index でも取ることができます。\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, Factorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// let fact = Factorial::<Minfo17>::new(17);\n        ///\n        /// assert_eq!(fact[0], Mint17::from_value(1));\n        /// assert_eq!(fact[1], Mint17::from_value(1));\n        /// assert_eq!(fact[2], Mint17::from_value(2));\n        /// assert_eq!(fact[3], Mint17::from_value(6));\n        /// assert_eq!(fact[4], Mint17::from_value(24 % 17));\n        /// assert_eq!(fact[5], Mint17::from_value(120 % 17));\n        /// ```\n        #[inline]\n        fn index(&self, index: I) -> &Self::Output {\n            &self.normal[index]\n        }\n    }\n\n    /// 二重階乗とその逆元を前計算するマシーンです。\n    #[allow(dead_code)]\n    pub struct DoubleFactorial<Mod: Minfo> {\n        normal: Vec<Mint<Mod>>,\n        inverted: Vec<Mint<Mod>>,\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo> DoubleFactorial<Mod>\n    where\n        Mod::Value: std::convert::TryFrom<usize, Error = std::num::TryFromIntError>,\n    {\n        /// サイズを指定して初期化です。\n        /// 最大値は一つ小さくなりますから、注意です。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, DoubleFactorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        /// let fact = DoubleFactorial::<Minfo17>::new(16);\n        /// ```\n        pub fn new(n: usize) -> Self {\n            use std::convert::TryFrom;\n            let mut normal = vec![Mint::one(); n];\n            for i in 2..n {\n                normal[i] = normal[i - 2] * Mint::from_value(Mod::Value::try_from(i).unwrap());\n            }\n            let mut inverted = vec![Mint::one(); n];\n            inverted[n - 1] = normal[n - 1].inv();\n            inverted[n - 2] = normal[n - 2].inv();\n            for i in (2..n).rev() {\n                inverted[i - 2] = inverted[i] * Mint::from_value(Mod::Value::try_from(i).unwrap());\n            }\n            Self { normal, inverted }\n        }\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo> DoubleFactorial<Mod> {\n        /// 二重階乗の逆元を取得します。\n        ///\n        /// 逆元でなくて普通の二重階乗は、[`implementations`] をご覧いただけると幸いです。\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, DoubleFactorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// let fact = DoubleFactorial::<Minfo17>::new(17);\n        ///\n        /// for i in 0..17 {\n        ///     assert_eq!(fact[i] * fact.inverted(i), Mint17::one());\n        /// }\n        /// ```\n        ///\n        /// [`implementations`]: #implementations\n        ///\n        pub fn inverted(&self, i: usize) -> Mint<Mod> {\n            self.inverted[i]\n        }\n    }\n\n    #[allow(dead_code)]\n    impl<Mod: Minfo, I: std::slice::SliceIndex<[Mint<Mod>]>> std::ops::Index<I>\n        for DoubleFactorial<Mod>\n    {\n        type Output = I::Output;\n\n        /// Index でも取ることができます。\n        ///\n        /// ```\n        /// use modint::{define_mint, Mint, Minfo, DoubleFactorial};\n        ///\n        /// define_mint! {\n        ///     struct Mint17(Minfo17(17; i16));\n        /// }\n        ///\n        /// let fact = DoubleFactorial::<Minfo17>::new(17);\n        ///\n        /// assert_eq!(fact[0], Mint17::from_value(1));\n        /// assert_eq!(fact[1], Mint17::from_value(1));\n        /// assert_eq!(fact[2], Mint17::from_value(2));\n        /// assert_eq!(fact[3], Mint17::from_value(3));\n        /// assert_eq!(fact[4], Mint17::from_value(8));\n        /// assert_eq!(fact[5], Mint17::from_value(15));\n        /// ```\n        #[inline]\n        fn index(&self, index: I) -> &Self::Output {\n            &self.normal[index]\n        }\n    }\n\n    /// Mint 型を定義するためのマクロです。\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use modint::{define_mint, Minfo, Mint};\n    ///\n    /// define_mint! {\n    ///     struct Mint17(Minfo17(17; i64));\n    /// }\n    ///\n    /// let x = Mint17::from_value(1);\n    /// let y = Mint17::from_value(2);\n    /// let z = x / y;\n    /// assert_eq!(z.value(), 9);\n    /// ```\n    #[macro_export]\n    macro_rules! define_mint {\n        (\n        struct $modint: ident ($modinfo: ident ($modvalue: expr; $modty: ty));\n    ) => {\n            #[allow(dead_code)]\n            #[derive(Clone, Copy, Debug)]\n            pub struct $modinfo {}\n            impl Minfo for $modinfo {\n                type Value = $modty;\n                fn modulus() -> Self::Value {\n                    $modvalue\n                }\n                fn zero() -> Self::Value {\n                    0\n                }\n                fn one() -> Self::Value {\n                    1\n                }\n            }\n            type $modint = Mint<$modinfo>;\n        };\n    }\n\n    /// Mod = 1000000007 なる Minfo です。\n    #[allow(dead_code)]\n    #[derive(Clone, Copy, Debug)]\n    pub struct Minfo1000000007 {}\n\n    impl Minfo for Minfo1000000007 {\n        type Value = i64;\n        fn modulus() -> Self::Value {\n            1_000_000_007\n        }\n        fn zero() -> Self::Value {\n            0\n        }\n        fn one() -> Self::Value {\n            1\n        }\n    }\n\n    /// Mod = 1000000007 なる Mint です。\n    #[allow(dead_code)]\n    pub type Mint1000000007 = Mint<Minfo1000000007>;\n\n    /// Mod = 998244353 なる Minfo です。\n    #[allow(dead_code)]\n    #[derive(Clone, Copy, Debug)]\n    pub struct Minfo998244353 {}\n\n    impl Minfo for Minfo998244353 {\n        type Value = i64;\n        fn modulus() -> Self::Value {\n            998_244_353\n        }\n        fn zero() -> Self::Value {\n            0\n        }\n        fn one() -> Self::Value {\n            1\n        }\n    }\n\n    /// Mod = 998244353 なる Mint です。\n    #[allow(dead_code)]\n    pub type Mint998244353 = Mint<Minfo998244353>;\n}\n//}}}\n\ntype Mint = modint::Mint998244353;\n\nfn main() {\n    input!(n: usize, mut s: Chars);\n    s.reverse();\n    let make = |x: Mint| -> Vec<(Mint, Mint)> {\n        let xinv = x.inv();\n        let mut ans = vec![(Mint::one(), Mint::zero()); n + 1];\n        for (i, &c) in s.iter().enumerate() {\n            let (a, b) = ans[i];\n            ans[i + 1] = match c {\n                '+' => (a, b + Mint::one()),\n                '-' => (a, b - Mint::one()),\n                '<' => (a * x, b * x),\n                '>' => (a * xinv, b * xinv),\n                _ => panic!(),\n            }\n        }\n        ans\n    };\n\n    let keys: Vec<_> = (1..6)\n        .map(|i| i * 10_000_000)\n        .map(Mint::from_value)\n        .collect();\n    let seqs: Vec<_> = keys.iter().copied().map(make).collect();\n    let mut hash_map = std::collections::HashMap::<Vec<_>, _>::new();\n    let mut ans = 0u64;\n    for i in 0..=n {\n        if let Some(x) = hash_map.get(\n            &(0..keys.len())\n                .map(|j| {\n                    let (a, b) = seqs[j][i];\n                    if a.is_zero() {\n                        None\n                    } else {\n                        Some(((b - seqs[j][n].1) / a).value())\n                    }\n                })\n                .collect::<Vec<_>>(),\n        ) {\n            ans += x;\n        }\n        *hash_map\n            .entry(\n                (0..keys.len())\n                    .map(|j| {\n                        let (a, b) = seqs[j][i];\n                        if a.is_zero() {\n                            None\n                        } else {\n                            Some((b / a).value())\n                        }\n                    })\n                    .collect(),\n            )\n            .or_insert(0) += 1;\n    }\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::Read;\n#[allow(dead_code)]\nfn getline() -> String {\n    let mut ret = String::new();\n    std::io::stdin().read_line(&mut ret).ok().unwrap();\n    ret\n}\nfn get_word() -> String {\n    let mut stdin = std::io::stdin();\n    let mut u8b: [u8; 1] = [0];\n    loop {\n        let mut buf: Vec<u8> = Vec::with_capacity(16);\n        loop {\n            let res = stdin.read(&mut u8b);\n            if res.unwrap_or(0) == 0 || u8b[0] <= b' ' {\n                break;\n            } else {\n                buf.push(u8b[0]);\n            }\n        }\n        if buf.len() >= 1 {\n            let ret = String::from_utf8(buf).unwrap();\n            return ret;\n        }\n    }\n}\n\n#[allow(dead_code)]\nfn get<T: std::str::FromStr>() -> T { get_word().parse().ok().unwrap() }\n\nconst MOD: i64 = 1_000_000_009;\n\n/// Refers external ::MOD.\nmod mod_int {\n    use ::MOD;\n    use std::ops::*;\n    #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]\n    pub struct ModInt {\n        pub x: i64,\n    }\n    impl ModInt {\n        pub fn new(x: i64) -> Self { ModInt { x: x % MOD } }\n        #[allow(dead_code)]\n        pub fn mul_fast(self, others: Self) -> Self {\n            Self::new(self.x * others.x % MOD)\n        }\n        pub fn pow(self, mut e: i64) -> Self {\n            let mut sum = ModInt::new(1);\n            let mut cur = ModInt::new(self.x);\n            while e > 0 {\n                if e % 2 != 0 {\n                    sum = sum * cur;\n                }\n                cur = cur * cur;\n                e /= 2;\n            }\n            sum\n        }\n        pub fn inv(self) -> Self {\n            self.pow(MOD - 2)\n        }\n    }\n    impl Add for ModInt {\n        type Output = Self;\n        fn add(self, others: Self) -> Self {\n            let mut sum = self.x + others.x;\n            if sum >= MOD {\n                sum -= MOD;\n            }\n            Self::new(sum)\n        }\n    }\n    impl Sub for ModInt {\n        type Output = Self;\n        fn sub(self, others: Self) -> Self {\n            let mut sum = self.x - others.x;\n            if sum < 0 {\n                sum += MOD;\n            }\n            Self::new(sum)\n        }\n    }\n    impl Mul for ModInt {\n        type Output = Self;\n        fn mul(self, others: Self) -> Self {\n            self.mul_fast(others)\n        }\n    }\n} // mod mod_int\n\n\nfn solve() {\n    use mod_int::*;\n    let n: usize = get();\n    let s: Vec<_> = get_word().chars().collect();\n    const A: usize = 3;\n    let b = [ModInt::new(41), ModInt::new(255), ModInt::new(36)];\n    let mut hsh = vec![vec![ModInt::new(0); n + 1]; A];\n    let mut inv = [ModInt::new(0); A];\n    for i in 0 .. A { inv[i] = b[i].inv(); }\n    let mut pos = vec![0; n + 1];\n    for c in 0 .. A {\n        let mut p = 0;\n        let mut cur = ModInt::new(1);\n        for (i, &ch) in s.iter().enumerate() {\n            let mut tmp = hsh[c][i];\n            match ch {\n                '>' => {\n                    p += 1;\n                    cur = cur * b[c];\n                },\n                '<' => {\n                    p -= 1;\n                    cur = cur * inv[c];\n                },\n                '+' => tmp = tmp + cur,\n                '-' => tmp = tmp - cur,\n                _ => panic!(),\n            }\n            hsh[c][i + 1] = tmp;\n            pos[i + 1] = p;\n        }\n    }\n    let mut meguru = [ModInt::new(0); A];\n    for c in 0 .. A { meguru[c] = hsh[c][n]; }\n    let mut kirika = HashMap::new();\n    kirika.insert(meguru, 1);\n    let mut tot = 0;\n    for i in (0 .. n).rev() {\n        let mut cur = [ModInt::new(0); A];\n        for c in 0 .. A { cur[c] = b[c].pow(MOD - 1 + pos[i]); }\n        let mut ken = [ModInt::new(0); A];\n        for c in 0 .. A { ken[c] = cur[c] * meguru[c] + hsh[c][i]; }\n        tot += kirika.get(&ken).cloned().unwrap_or(0);\n        let mut tt = [ModInt::new(0); A];\n        for c in 0 .. A { tt[c] = hsh[c][i]; }\n        *kirika.entry(tt).or_insert(0) += 1;\n    }\n    println!(\"{}\", tot);\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::Read;\n#[allow(dead_code)]\nfn getline() -> String {\n    let mut ret = String::new();\n    std::io::stdin().read_line(&mut ret).ok().unwrap();\n    ret\n}\nfn get_word() -> String {\n    let mut stdin = std::io::stdin();\n    let mut u8b: [u8; 1] = [0];\n    loop {\n        let mut buf: Vec<u8> = Vec::with_capacity(16);\n        loop {\n            let res = stdin.read(&mut u8b);\n            if res.unwrap_or(0) == 0 || u8b[0] <= b' ' {\n                break;\n            } else {\n                buf.push(u8b[0]);\n            }\n        }\n        if buf.len() >= 1 {\n            let ret = String::from_utf8(buf).unwrap();\n            return ret;\n        }\n    }\n}\n\n#[allow(dead_code)]\nfn get<T: std::str::FromStr>() -> T { get_word().parse().ok().unwrap() }\n\nmod mod_int {\n    use std::ops::*;\n    pub trait Mod: Copy + Clone {\n        fn m() -> i64;\n    }\n    #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]\n    pub struct ModInt<M: Mod> { pub x: i64, phantom: ::std::marker::PhantomData<*const M> }\n    impl<M: Mod> ModInt<M> {\n        fn check_integrity(self) {\n            debug_assert!(self.x >= 0);\n            debug_assert!(self.x < M::m());\n        }\n        // x >= 0\n        pub fn new(x: i64) -> Self { ModInt::new_internal(x % M::m()) }\n        fn new_internal(x: i64) -> Self { ModInt { x: x % M::m(), phantom: ::std::marker::PhantomData } }\n        #[allow(dead_code)]\n        pub fn mul_fast(self, other: Self) -> Self {\n            self.check_integrity();\n            other.check_integrity();\n            ModInt::new_internal(self.x * other.x % M::m())\n        }\n        #[allow(dead_code)]\n        pub fn mul_slow(self, other: Self) -> Self {\n            // Naive multiplication in order to avoid overflow\n            self.check_integrity();\n            other.check_integrity();\n            let mut sum = ModInt::new(0);\n            let mut cur = self;\n            let mut e = other.x;\n            if self.x < other.x {\n                cur = other;\n                e = self.x;\n            }\n            while e > 0 {\n                if e % 2 == 1 {\n                    sum = sum + cur;\n                }\n                cur = cur + cur;\n                e /= 2;\n            }\n            sum\n        }\n        pub fn pow(self, mut e: i64) -> Self {\n            self.check_integrity();\n            debug_assert!(e >= 0);\n            let mut sum = ModInt::new(1);\n            let mut cur = ModInt::new(self.x);\n            while e > 0 {\n                if e % 2 != 0 {\n                    sum = sum * cur;\n                }\n                cur = cur * cur;\n                e /= 2;\n            }\n            sum\n        }\n        pub fn inv(self) -> Self { self.pow(M::m() - 2) }\n    }\n    impl<M: Mod> Add for ModInt<M> {\n        type Output = Self;\n        fn add(self, other: Self) -> Self {\n            self.check_integrity();\n            other.check_integrity();\n            let mut sum = self.x + other.x;\n            if sum >= M::m() { sum -= M::m(); }\n            ModInt::new(sum)\n        }\n    }\n    impl<M: Mod> Sub for ModInt<M> {\n        type Output = Self;\n        fn sub(self, other: Self) -> Self {\n            self.check_integrity();\n            other.check_integrity();\n            let mut sum = self.x - other.x;\n            if sum < 0 { sum += M::m(); }\n            ModInt::new(sum)\n        }\n    }\n    impl<M: Mod> Mul for ModInt<M> {\n        type Output = Self;\n        fn mul(self, other: Self) -> Self {\n            self.mul_fast(other)\n        }\n    }\n} // mod mod_int\n\nmacro_rules! define_mod {\n    ($struct_name: ident, $mod: expr) => {\n        #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n        struct $struct_name {}\n        impl mod_int::Mod for $struct_name { fn m() -> i64 { $mod } }\n    }\n}\nconst MOD: i64 = 1_000_000_007;\ndefine_mod!(P, MOD);\ntype ModInt = mod_int::ModInt<P>;\n\n\nfn solve() {\n    //use mod_int::*;\n    let n: usize = get();\n    let s: Vec<_> = get_word().chars().collect();\n    const A: usize = 3;\n    let b = [ModInt::new(41), ModInt::new(255), ModInt::new(36)];\n    let mut hsh = vec![vec![ModInt::new(0); n + 1]; A];\n    let mut inv = [ModInt::new(0); A];\n    for i in 0 .. A { inv[i] = b[i].inv(); }\n    let mut pos = vec![0; n + 1];\n    for c in 0 .. A {\n        let mut p = 0;\n        let mut cur = ModInt::new(1);\n        for (i, &ch) in s.iter().enumerate() {\n            let mut tmp = hsh[c][i];\n            match ch {\n                '>' => {\n                    p += 1;\n                    cur = cur * b[c];\n                },\n                '<' => {\n                    p -= 1;\n                    cur = cur * inv[c];\n                },\n                '+' => tmp = tmp + cur,\n                '-' => tmp = tmp - cur,\n                _ => panic!(),\n            }\n            hsh[c][i + 1] = tmp;\n            pos[i + 1] = p;\n        }\n    }\n    let mut meguru = [ModInt::new(0); A];\n    for c in 0 .. A { meguru[c] = hsh[c][n]; }\n    let mut kirika = HashMap::new();\n    kirika.insert(meguru, 1);\n    let mut tot = 0i64;\n    for i in (0 .. n).rev() {\n        let mut cur = [ModInt::new(0); A];\n        for c in 0 .. A { cur[c] = b[c].pow(MOD - 1 + pos[i]); }\n        let mut ken = [ModInt::new(0); A];\n        for c in 0 .. A { ken[c] = cur[c] * meguru[c] + hsh[c][i]; }\n        tot += kirika.get(&ken).cloned().unwrap_or(0);\n        let mut tt = [ModInt::new(0); A];\n        for c in 0 .. A { tt[c] = hsh[c][i]; }\n        *kirika.entry(tt).or_insert(0) += 1;\n    }\n    println!(\"{}\", tot);\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  }
]