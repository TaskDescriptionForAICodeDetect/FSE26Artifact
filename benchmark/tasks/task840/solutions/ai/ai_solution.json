[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_N 200005\n\nlong long count_valid_substrings(char* S) {\n    int N = strlen(S);\n    long long count = 0;\n    \n    for (int i = 0; i < N; i++) {\n        long long p = 0, val = 0;\n        int valid = 1;\n        \n        for (int j = i; j < N; j++) {\n            switch (S[j]) {\n                case '+': val++; break;\n                case '-': val--; break;\n                case '>': p++; break;\n                case '<': \n                    if (p == 0) {\n                        valid = 0;\n                    } else {\n                        p--;\n                    }\n                    break;\n            }\n            \n            if (!valid) break;\n            \n            if (p == 0) count++;\n        }\n    }\n    \n    return count;\n}\n\nint main() {\n    char S[MAX_N];\n    scanf(\"%s\", S);\n    \n    printf(\"%lld\\n\", count_valid_substrings(S));\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:05:06"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 200000\n#define HASH_SIZE (1 << 20)\n#define HASH_MASK (HASH_SIZE - 1)\n\ntypedef struct {\n    int key_p;\n    int key_dp;\n    int count;\n} HashEntry;\n\nHashEntry hash[HASH_SIZE];\nint hash_count = 0;\n\nvoid hash_clear() {\n    memset(hash, 0, sizeof(hash));\n    hash_count = 0;\n}\n\nint hash_find(int p, int dp) {\n    int idx = (p * 31 + dp) & HASH_MASK;\n    while (hash[idx].count != 0) {\n        if (hash[idx].key_p == p && hash[idx].key_dp == dp) {\n            return idx;\n        }\n        idx = (idx + 1) & HASH_MASK;\n    }\n    return -1;\n}\n\nvoid hash_insert(int p, int dp) {\n    int idx = (p * 31 + dp) & HASH_MASK;\n    while (hash[idx].count != 0) {\n        if (hash[idx].key_p == p && hash[idx].key_dp == dp) {\n            hash[idx].count++;\n            return;\n        }\n        idx = (idx + 1) & HASH_MASK;\n    }\n    hash[idx].key_p = p;\n    hash[idx].key_dp = dp;\n    hash[idx].count = 1;\n    hash_count++;\n}\n\nint main() {\n    int N;\n    char S[MAX_N + 1];\n    scanf(\"%d\", &N);\n    scanf(\"%s\", S);\n\n    int p = 0, dp = 0;\n    long long result = 0;\n\n    hash_clear();\n    hash_insert(0, 0);\n\n    for (int i = 0; i < N; i++) {\n        char c = S[i];\n        if (c == '+') {\n            dp++;\n        } else if (c == '-') {\n            dp--;\n        } else if (c == '>') {\n            p++;\n        } else if (c == '<') {\n            p--;\n        }\n\n        int idx = hash_find(p, dp);\n        if (idx != -1) {\n            result += hash[idx].count;\n        }\n        hash_insert(p, dp);\n    }\n\n    printf(\"%lld\\n\", result);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:05:29"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint main() {\n    int N;\n    string S;\n    cin >> N >> S;\n    \n    int P = 0;\n    unordered_map<int, int> count;\n    count[0] = 1;\n    long long res = 0;\n    \n    for (char c : S) {\n        if (c == '+') P++;\n        else if (c == '-') P--;\n        else if (c == '>') P += 1e9 + 1;\n        else if (c == '<') P -= 1e9 + 1;\n        res += count[P];\n        count[P]++;\n    }\n    \n    cout << res << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 23:05:39"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        String S = scanner.next();\n        \n        Map<String, Integer> map = new HashMap<>();\n        map.put(\"0,0\", 1);\n        long res = 0;\n        int p = 0;\n        int a = 0;\n        \n        for (int i = 0; i < N; i++) {\n            char c = S.charAt(i);\n            if (c == '+') {\n                a++;\n            } else if (c == '-') {\n                a--;\n            } else if (c == '>') {\n                p++;\n            } else if (c == '<') {\n                p--;\n            }\n            String key = p + \",\" + a;\n            res += map.getOrDefault(key, 0);\n            map.put(key, map.getOrDefault(key, 0) + 1);\n        }\n        \n        System.out.println(res);\n    }\n}",
    "timestamp": "2025-08-05 23:05:49"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class TakahashiSequence {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String S = br.readLine();\n        System.out.println(solve(S));\n    }\n\n    static long solve(String S) {\n        int N = S.length();\n        long count = 0;\n\n        for (int i = 1; i <= N; i++) {\n            for (int j = i; j <= N; j++) {\n                if (isValidSubsequence(S.substring(i-1, j))) {\n                    count++;\n                }\n            }\n        }\n\n        return count;\n    }\n\n    static boolean isValidSubsequence(String subsequence) {\n        long[] A = new long[2 * 1000000000 + 1];\n        long P = 1000000000;\n\n        for (char c : subsequence.toCharArray()) {\n            switch (c) {\n                case '+':\n                    A[P]++;\n                    break;\n                case '-':\n                    A[P]--;\n                    break;\n                case '>':\n                    P++;\n                    break;\n                case '<':\n                    P--;\n                    break;\n            }\n        }\n\n        long[] fullA = new long[2 * 1000000000 + 1];\n        long fullP = 1000000000;\n\n        for (char c : S.toCharArray()) {\n            switch (c) {\n                case '+':\n                    fullA[fullP]++;\n                    break;\n                case '-':\n                    fullA[fullP]--;\n                    break;\n                case '>':\n                    fullP++;\n                    break;\n                case '<':\n                    fullP--;\n                    break;\n            }\n        }\n\n        return Arrays.equals(A, fullA);\n    }\n}",
    "timestamp": "2025-08-05 23:05:56"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n\nusing namespace std;\n\nint main() {\n    string S;\n    cin >> S;\n    int N = S.length();\n    int result = 0;\n\n    for (int i = 1; i <= N; i++) {\n        int P = 0;\n        vector<long long> A(2e9 + 1, 0);\n        \n        for (int j = i - 1; j < N; j++) {\n            if (S[j] == '+') {\n                A[P]++;\n            } else if (S[j] == '-') {\n                A[P]--;\n            } else if (S[j] == '>') {\n                P++;\n            } else if (S[j] == '<') {\n                P--;\n            }\n            \n            bool valid = true;\n            int tempP = 0;\n            vector<long long> tempA(2e9 + 1, 0);\n            \n            for (int k = 0; k < N; k++) {\n                if (S[k] == '+') {\n                    tempA[tempP]++;\n                } else if (S[k] == '-') {\n                    tempA[tempP]--;\n                } else if (S[k] == '>') {\n                    tempP++;\n                } else if (S[k] == '<') {\n                    tempP--;\n                }\n                \n                if (tempA[tempP] != A[tempP]) {\n                    valid = false;\n                    break;\n                }\n            }\n            \n            if (valid) {\n                result++;\n            }\n        }\n    }\n    \n    cout << result << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 23:06:03"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_pairs(S):\n    n = len(S)\n    balance = [0] * (n + 1)\n    left_balance = {}\n    right_balance = {}\n    \n    for i in range(n):\n        balance[i + 1] = balance[i]\n        if S[i] == '+':\n            balance[i + 1] += 1\n        elif S[i] == '-':\n            balance[i + 1] -= 1\n    \n    total_balance = balance[n]\n    \n    count = 0\n    \n    for i in range(n + 1):\n        left_balance[balance[i]] = left_balance.get(balance[i], 0) + 1\n    \n    for i in range(n + 1):\n        left_balance[balance[i]] -= 1\n        if balance[i] not in right_balance:\n            right_balance[balance[i]] = 0\n        \n        count += left_balance.get(balance[i] - total_balance, 0)\n        right_balance[balance[i]] += 1\n    \n    return count\n\n# Example Usage\nS = \"+-<>\"\nprint(count_pairs(S))",
    "timestamp": "2025-08-13 13:35:29"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\nimport java.util.HashMap;\n\npublic class TakahashiMind {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String S = scanner.nextLine();\n        HashMap<Long, Integer> counter = new HashMap<>();\n        \n        long p = 0; // Position indicator\n        counter.put(p, 1);\n        long result = 0;\n        \n        for (char ch : S.toCharArray()) {\n            switch (ch) {\n                case '>':\n                    p++;\n                    break;\n                case '<':\n                    p--;\n                    break;\n                case '+':\n                case '-':\n                    break;\n            }\n            result += counter.getOrDefault(p, 0);\n            counter.put(p, counter.getOrDefault(p, 0) + 1);\n        }\n        \n        System.out.println(result);\n    }\n}",
    "timestamp": "2025-08-13 13:35:32"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAXN 1000000\n\nint main() {\n    char S[MAXN + 1];\n    scanf(\"%s\", S);\n    int N = strlen(S);\n\n    int p_move = 0;\n    int min_p = 0, max_p = 0;\n\n    for (int k = 0; k < N; k++) {\n        if (S[k] == '>') {\n            p_move++;\n        } else if (S[k] == '<') {\n            p_move--;\n        }\n        if (p_move > max_p) max_p = p_move;\n        if (p_move < min_p) min_p = p_move;\n    }\n\n    long long possible_pairs = (long long) N * (N + 1) / 2;\n    long long adjust_pairs = 0;\n\n    int balance = 0;\n    int left_hist[MAXN + 1], right_hist[MAXN + 1];\n    memset(left_hist, 0, sizeof(left_hist));\n    memset(right_hist, 0, sizeof(right_hist));\n\n    for (int k = 0; k < N; k++) {\n        if (S[k] == '+') {\n            balance++;\n        } else if (S[k] == '-') {\n            balance--;\n        }\n\n        if (p_move < 0) {\n            if (balance <= 0 && balance >= p_move) {\n                adjust_pairs++;\n            }\n        } else {\n            if (balance >= 0 && balance <= p_move) {\n                adjust_pairs++;\n            }\n        }\n        \n        if (balance - min_p >= 0 && balance - min_p <= N) left_hist[balance - min_p]++;\n        if (balance - max_p <= N && balance - max_p >= 0) right_hist[balance - max_p]++;\n    }\n\n    for (int k = 0, cur = 0; k <= N; k++) {\n        cur += right_hist[k];\n        if (k <= max_p - min_p) adjust_pairs += cur * left_hist[k];\n    }\n    \n    printf(\"%lld\\n\", possible_pairs - adjust_pairs);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 13:35:37"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve(S) {\n    const n = S.length;\n    let answer = 0;\n    \n    let pCounts = new Map();\n    pCounts.set(0, 1);\n    \n    let P = 0;\n    \n    for (let i = 0; i < n; i++) {\n        let ch = S[i];\n        if (ch === '+') {\n            // Do nothing, sequence value tracking is implicit\n        } else if (ch === '-') {\n            // Do nothing, sequence value tracking is implicit\n        } else if (ch === '>') {\n            P++;\n        } else if (ch === '<') {\n            P--;\n        }\n        \n        if (pCounts.has(P)) {\n            answer += pCounts.get(P);\n            pCounts.set(P, pCounts.get(P) + 1);\n        } else {\n            pCounts.set(P, 1);\n        }\n    }\n    \n    console.log(answer);\n}\n\n// Sample input\nconst S = '++--<>';\nsolve(S);",
    "timestamp": "2025-08-13 13:35:41"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve(S):\n    N = len(S)\n    result = 0\n    \n    for i in range(1, N + 1):\n        for j in range(i, N + 1):\n            # Reset state for each subarray\n            P = 0\n            A = {}\n            \n            # Simulate sequence for the current subarray\n            valid = True\n            for k in range(i - 1, j):\n                if S[k] == '+':\n                    A[P] = A.get(P, 0) + 1\n                elif S[k] == '-':\n                    A[P] = A.get(P, 0) - 1\n                elif S[k] == '>':\n                    P += 1\n                elif S[k] == '<':\n                    P -= 1\n                \n                # Optimization: prune impossible sequences\n                if A.get(P, 0) < 0:\n                    valid = False\n                    break\n            \n            # Check full sequence equivalence\n            full_P = 0\n            full_A = {}\n            for k in range(N):\n                if S[k] == '+':\n                    full_A[full_P] = full_A.get(full_P, 0) + 1\n                elif S[k] == '-':\n                    full_A[full_P] = full_A.get(full_P, 0) - 1\n                elif S[k] == '>':\n                    full_P += 1\n                elif S[k] == '<':\n                    full_P -= 1\n            \n            # Compare final states\n            if valid and A == full_A and P == full_P:\n                result += 1\n    \n    return result\n\n# Read input\nS = input().strip()\nprint(solve(S))",
    "timestamp": "2025-08-13 13:35:48"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function countValidSubstrings(S) {\n    const N = S.length;\n    let count = 0;\n\n    for (let i = 0; i < N; i++) {\n        let P = 0;\n        let A = new Array(2 * 10**9 + 1).fill(0);\n        \n        for (let j = i; j < N; j++) {\n            switch (S[j]) {\n                case '+':\n                    A[P]++;\n                    break;\n                case '-':\n                    A[P]--;\n                    break;\n                case '>':\n                    P++;\n                    break;\n                case '<':\n                    P--;\n                    break;\n            }\n\n            let isValidSubstring = true;\n            let testP = 0;\n            let testA = new Array(2 * 10**9 + 1).fill(0);\n\n            for (let k = 0; k < N; k++) {\n                switch (S[k]) {\n                    case '+':\n                        testA[testP]++;\n                        break;\n                    case '-':\n                        testA[testP]--;\n                        break;\n                    case '>':\n                        testP++;\n                        break;\n                    case '<':\n                        testP--;\n                        break;\n                }\n            }\n\n            for (let k = 0; k < A.length; k++) {\n                if (A[k] !== testA[k]) {\n                    isValidSubstring = false;\n                    break;\n                }\n            }\n\n            if (isValidSubstring) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}",
    "timestamp": "2025-08-13 13:35:54"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "n = int(input())\ns = input().strip()\n\nprefix_sum = [0] * (n + 1)\nprefix_pos = [0] * (n + 1)\ncurrent_sum = 0\ncurrent_pos = 0\n\n# Compute prefix sums and positions\nfor i in range(1, n + 1):\n    c = s[i-1]\n    if c == '+':\n        current_sum += 1\n    elif c == '-':\n        current_sum -= 1\n    elif c == '>':\n        current_pos += 1\n    elif c == '<':\n        current_pos -= 1\n    prefix_sum[i] = current_sum\n    prefix_pos[i] = current_pos\n\ntotal = 0\n\n# We need to find (i,j) where prefix_sum[j] - prefix_sum[i-1] == prefix_sum[n]\n# and prefix_pos[j] - prefix_pos[i-1] == prefix_pos[n]\ntarget_sum = prefix_sum[n]\ntarget_pos = prefix_pos[n]\n\nfrom collections import defaultdict\n\n# We'll use a dictionary to store the count of (prefix_sum[i], prefix_pos[i]) pairs\nsum_pos_count = defaultdict(int)\nsum_pos_count[(0, 0)] = 1  # prefix_sum[0] and prefix_pos[0]\n\nfor j in range(1, n + 1):\n    # The required (sum_i, pos_i) is (sum_j - target_sum, pos_j - target_pos)\n    required_sum = prefix_sum[j] - target_sum\n    required_pos = prefix_pos[j] - target_pos\n    total += sum_pos_count.get((required_sum, required_pos), 0)\n    # Add current (sum_j, pos_j) to the dictionary\n    sum_pos_count[(prefix_sum[j], prefix_pos[j])] += 1\n\nprint(total)",
    "timestamp": "2025-08-13 13:36:07"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const solve = () => {\n    const fs = require('fs');\n    const S = fs.readFileSync('/dev/stdin', 'utf8').trim();\n    const N = S.length;\n    \n    let totalPlus = 0;\n    let totalMinus = 0;\n    let totalRight = 0;\n    let totalLeft = 0;\n    \n    for (const c of S) {\n        if (c === '+') totalPlus++;\n        else if (c === '-') totalMinus++;\n        else if (c === '>') totalRight++;\n        else if (c === '<') totalLeft++;\n    }\n    \n    const netMove = totalRight - totalLeft;\n    const netValue = totalPlus - totalMinus;\n    \n    if (netMove === 0 && netValue === 0) {\n        return N * (N + 1) / 2;\n    }\n    \n    let count = 0;\n    let currentP = 0;\n    let currentValue = 0;\n    const prefixP = [0];\n    const prefixValue = [0];\n    \n    for (let i = 0; i < N; i++) {\n        const c = S[i];\n        if (c === '+') currentValue++;\n        else if (c === '-') currentValue--;\n        else if (c === '>') currentP++;\n        else if (c === '<') currentP--;\n        prefixP.push(currentP);\n        prefixValue.push(currentValue);\n    }\n    \n    const lastP = prefixP[N];\n    const lastValue = prefixValue[N];\n    \n    for (let i = 0; i <= N; i++) {\n        const p_i = prefixP[i];\n        const value_i = prefixValue[i];\n        const targetP = p_i - lastP;\n        const targetValue = value_i - lastValue;\n        \n        let low = i;\n        let high = N;\n        let found = -1;\n        \n        while (low <= high) {\n            const mid = Math.floor((low + high) / 2);\n            const p_mid = prefixP[mid] - p_i;\n            const value_mid = prefixValue[mid] - value_i;\n            \n            if (p_mid === targetP && value_mid === targetValue) {\n                found = mid;\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n        \n        if (found !== -1) {\n            let low2 = found;\n            let high2 = N;\n            let lastFound = found;\n            \n            while (low2 <= high2) {\n                const mid = Math.floor((low2 + high2) / 2);\n                const p_mid = prefixP[mid] - p_i;\n                const value_mid = prefixValue[mid] - value_i;\n                \n                if (p_mid === targetP && value_mid === targetValue) {\n                    lastFound = mid;\n                    low2 = mid + 1;\n                } else {\n                    high2 = mid - 1;\n                }\n            }\n            \n            count += lastFound - found + 1;\n        }\n    }\n    \n    return count;\n};\n\nconsole.log(solve());",
    "timestamp": "2025-08-13 13:36:23"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <string>\n#include <unordered_map>\n\nusing namespace std;\n\nlong long countPairs(const string& S) {\n    int N = S.size();\n    unordered_map<int, unordered_map<int, int>> position_map;\n    position_map[0][0] = 1;\n    int P = 0, A_P = 0;\n    long long count = 0;\n\n    for (int k = 0; k < N; ++k) {\n        switch(S[k]) {\n            case '+': A_P++; break;\n            case '-': A_P--; break;\n            case '>': P++; break;\n            case '<': P--; break;\n        }\n        if (position_map[P].count(A_P)) {\n            count += position_map[P][A_P];\n        }\n        position_map[P][A_P]++;\n    }\n    \n    return count;\n}\n\nint main() {\n    string S;\n    cin >> S;\n    cout << countPairs(S) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 14:40:21"
  }
]