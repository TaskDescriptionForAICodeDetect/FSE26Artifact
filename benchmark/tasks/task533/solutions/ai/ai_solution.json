[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <math.h>\n\nunsigned int hash(char* func, unsigned int* prev_hash) {\n    unsigned int result = 0;\n    \n    if (strlen(func) == 1 && func[0] >= 'a' && func[0] <= 'd') {\n        result = func[0] - 'a';\n    } else if (strchr(func, '+') != NULL) {\n        char* left = strtok(func, \"+\");\n        char* right = strtok(NULL, \"+\");\n        result = prev_hash[atoi(left)] | prev_hash[atoi(right)];\n    } else if (strchr(func, '*') != NULL) {\n        char* left = strtok(func, \"*\");\n        char* right = strtok(NULL, \"*\");\n        result = prev_hash[atoi(left)] & prev_hash[atoi(right)];\n    } else if (strchr(func, '^') != NULL) {\n        char* left = strtok(func, \"^\");\n        char* right = strtok(NULL, \"^\");\n        result = prev_hash[atoi(left)] ^ prev_hash[atoi(right)];\n    }\n    \n    return result;\n}\n\nint main() {\n    char func[100];\n    char password[5];\n    unsigned int prev_hash[4] = {0};\n    \n    while (scanf(\"%s\", func) == 1) {\n        if (strcmp(func, \"end\") == 0) break;\n        \n        scanf(\"%s\", password);\n        \n        if (strlen(func) == 1 && func[0] >= 'a' && func[0] <= 'd') {\n            prev_hash[func[0] - 'a'] = password[func[0] - 'a'] - '0';\n        } else {\n            unsigned int curr_hash = hash(func, prev_hash);\n            int count = 0;\n            \n            for (int p = 0; p < 10000; p++) {\n                char test_pass[5];\n                sprintf(test_pass, \"%04d\", p);\n                \n                unsigned int test_hash[4] = {\n                    test_pass[0] - '0',\n                    test_pass[1] - '0',\n                    test_pass[2] - '0',\n                    test_pass[3] - '0'\n                };\n                \n                unsigned int temp_prev_hash[4];\n                memcpy(temp_prev_hash, test_hash, sizeof(test_hash));\n                \n                char temp_func[100];\n                strcpy(temp_func, func);\n                \n                unsigned int test_result = hash(temp_func, temp_prev_hash);\n                \n                if (test_result == curr_hash) {\n                    count++;\n                }\n            }\n            \n            printf(\"%d\\n\", count);\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:02:52"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint evaluate_hash(char* hash, int p0, int p1, int p2, int p3) {\n    if (strlen(hash) == 1) {\n        switch (hash[0]) {\n            case 'a': return p0;\n            case 'b': return p1;\n            case 'c': return p2;\n            case 'd': return p3;\n            default: return 0;\n        }\n    }\n\n    char op = hash[0];\n    char* left = strtok(hash + 1, \" \");\n    char* right = strtok(NULL, \" \");\n    \n    int left_val = evaluate_hash(left, p0, p1, p2, p3);\n    int right_val = evaluate_hash(right, p0, p1, p2, p3);\n    \n    switch (op) {\n        case '+': return left_val | right_val;\n        case '*': return left_val & right_val;\n        case '^': return left_val ^ right_val;\n        default: return 0;\n    }\n}\n\nint main() {\n    char hash_function[100];\n    char password[5];\n    \n    while (scanf(\"%s\", hash_function) != EOF) {\n        scanf(\"%s\", password);\n        int p0 = password[0] - '0';\n        int p1 = password[1] - '0';\n        int p2 = password[2] - '0';\n        int p3 = password[3] - '0';\n        \n        int target_hash = evaluate_hash(hash_function, p0, p1, p2, p3);\n        int count = 0;\n        \n        for (int a = 0; a < 10; a++) {\n            for (int b = 0; b < 10; b++) {\n                for (int c = 0; c < 10; c++) {\n                    for (int d = 0; d < 10; d++) {\n                        int current_hash = evaluate_hash(hash_function, a, b, c, d);\n                        if (current_hash == target_hash) {\n                            count++;\n                        }\n                    }\n                }\n            }\n        }\n        \n        printf(\"%d\\n\", count);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:03:12"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <stack>\n#include <map>\nusing namespace std;\n\nint evaluate(const string& expr, const vector<int>& p) {\n    stack<int> s;\n    for (char c : expr) {\n        if (c >= 'a' && c <= 'd') {\n            s.push(p[c - 'a']);\n        } else if (c == '+' || c == '*' || c == '^') {\n            int a = s.top(); s.pop();\n            int b = s.top(); s.pop();\n            int res;\n            if (c == '+') res = b | a;\n            else if (c == '*') res = b & a;\n            else if (c == '^') res = b ^ a;\n            s.push(res);\n        }\n    }\n    return s.top();\n}\n\nint count_passwords(const string& expr, int target) {\n    int count = 0;\n    vector<int> p(4);\n    for (p[0] = 0; p[0] <= 9; ++p[0]) {\n        for (p[1] = 0; p[1] <= 9; ++p[1]) {\n            for (p[2] = 0; p[2] <= 9; ++p[2]) {\n                for (p[3] = 0; p[3] <= 9; ++p[3]) {\n                    if (evaluate(expr, p) == target) {\n                        ++count;\n                    }\n                }\n            }\n        }\n    }\n    return count;\n}\n\nint main() {\n    string expr;\n    string password;\n    while (cin >> expr >> password) {\n        vector<int> p(4);\n        for (int i = 0; i < 4; ++i) {\n            p[i] = password[i] - '0';\n        }\n        int target = evaluate(expr, p);\n        cout << count_passwords(expr, target) << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 22:03:32"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class PasswordHash {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        while (scanner.hasNext()) {\n            String hashFunction = scanner.next();\n            String password = scanner.next();\n            int p = Integer.parseInt(password);\n            int[] digits = new int[4];\n            for (int i = 0; i < 4; i++) {\n                digits[3 - i] = p % 10;\n                p /= 10;\n            }\n            int originalHash = computeHash(hashFunction, digits);\n            int count = 0;\n            for (int num = 0; num <= 9999; num++) {\n                int[] currentDigits = new int[4];\n                int temp = num;\n                for (int i = 0; i < 4; i++) {\n                    currentDigits[3 - i] = temp % 10;\n                    temp /= 10;\n                }\n                if (computeHash(hashFunction, currentDigits) == originalHash) {\n                    count++;\n                }\n            }\n            System.out.println(originalHash + \" \" + count);\n        }\n        scanner.close();\n    }\n\n    private static int computeHash(String hashFunction, int[] digits) {\n        if (hashFunction.length() == 1) {\n            char c = hashFunction.charAt(0);\n            return digits[c - 'a'];\n        } else {\n            int leftHash = computeHash(hashFunction.substring(0, 1), digits);\n            int rightHash = computeHash(hashFunction.substring(2), digits);\n            char op = hashFunction.charAt(1);\n            switch (op) {\n                case '+':\n                    return leftHash | rightHash;\n                case '*':\n                    return leftHash & rightHash;\n                case '^':\n                    return leftHash ^ rightHash;\n                default:\n                    return 0;\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-05 22:03:48"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class PasswordHashCalculator {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        while (scanner.hasNext()) {\n            String hashFunction = scanner.next();\n            String password = scanner.next();\n            \n            int result = computeHash(hashFunction, password);\n            int count = countPasswordsWithSameHash(hashFunction, result);\n            \n            System.out.println(count);\n        }\n    }\n    \n    static int computeHash(String hashFunction, String password) {\n        if (hashFunction.length() == 1) {\n            int index = \"abcd\".indexOf(hashFunction);\n            return Character.getNumericValue(password.charAt(index));\n        }\n        \n        String[] parts = hashFunction.split(\"(?=[-+*^])\", 2);\n        int left = computeHash(parts[0], password);\n        int right = computeHash(parts[1].substring(1), password);\n        \n        switch (parts[1].charAt(0)) {\n            case '+': return left | right;\n            case '*': return left & right;\n            case '^': return left ^ right;\n        }\n        \n        return 0;\n    }\n    \n    static int countPasswordsWithSameHash(String hashFunction, int targetHash) {\n        int count = 0;\n        \n        for (int p = 0; p <= 9999; p++) {\n            String password = String.format(\"%04d\", p);\n            if (computeHash(hashFunction, password) == targetHash) {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n}",
    "timestamp": "2025-08-05 22:03:55"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <unordered_set>\n\nusing namespace std;\n\nint hash_function(const string& func, const string& pass) {\n    if (func.length() == 1) {\n        int idx = func[0] - 'a';\n        return pass[idx] - '0';\n    }\n    \n    size_t op_pos = func.find_first_of(\"+*^\");\n    string left = func.substr(0, op_pos);\n    string right = func.substr(op_pos + 1);\n    char op = func[op_pos];\n    \n    int left_val = hash_function(left, pass);\n    int right_val = hash_function(right, pass);\n    \n    if (op == '+') return left_val | right_val;\n    if (op == '*') return left_val & right_val;\n    if (op == '^') return left_val ^ right_val;\n    \n    return -1;\n}\n\nint main() {\n    int T;\n    cin >> T;\n    \n    while (T--) {\n        string func, pass;\n        cin >> func >> pass;\n        \n        unordered_set<int> unique_passes;\n        \n        for (int a = 0; a <= 9; a++) {\n            for (int b = 0; b <= 9; b++) {\n                for (int c = 0; c <= 9; c++) {\n                    for (int d = 0; d <= 9; d++) {\n                        string curr_pass = to_string(a) + to_string(b) + to_string(c) + to_string(d);\n                        int hash_val = hash_function(func, curr_pass);\n                        unique_passes.insert(hash_val);\n                    }\n                }\n            }\n        }\n        \n        int target_hash = hash_function(func, pass);\n        int count = 0;\n        \n        for (int a = 0; a <= 9; a++) {\n            for (int b = 0; b <= 9; b++) {\n                for (int c = 0; c <= 9; c++) {\n                    for (int d = 0; d <= 9; d++) {\n                        string curr_pass = to_string(a) + to_string(b) + to_string(c) + to_string(d);\n                        int hash_val = hash_function(func, curr_pass);\n                        if (hash_val == target_hash) {\n                            count++;\n                        }\n                    }\n                }\n            }\n        }\n        \n        cout << count << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:04:03"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def evaluate_hash_expression(hash_fn, password):\n    value_map = { 'a': int(password[0]), 'b': int(password[1]), \n                  'c': int(password[2]), 'd': int(password[3]) }\n\n    stack = []\n    \n    for token in hash_fn:\n        if token in value_map:\n            stack.append(value_map[token])\n        elif token == '+':\n            b = stack.pop()\n            a = stack.pop()\n            stack.append(a | b)\n        elif token == '*':\n            b = stack.pop()\n            a = stack.pop()\n            stack.append(a & b)\n        elif token == '^':\n            b = stack.pop()\n            a = stack.pop()\n            stack.append(a ^ b)\n    \n    return stack[-1]\n\ndef count_passwords_with_same_hash(hash_fn):\n    target_value = evaluate_hash_expression(hash_fn, '0000')\n    count = 0\n    \n    for i in range(10000):\n        password = str(i).zfill(4)\n        if evaluate_hash_expression(hash_fn, password) == target_value:\n            count += 1\n\n    return count\n\ndef process_input(data):\n    output = []\n    lines = data.strip().splitlines()\n    for i in range(0, len(lines), 2):\n        hash_fn = lines[i].strip()\n        password = lines[i+1].strip()\n        \n        if evaluate_hash_expression(hash_fn, password) == evaluate_hash_expression(hash_fn, '0000'):\n            output.append(count_passwords_with_same_hash(hash_fn))\n        else:\n            output.append(0)\n\n    return output\n\n# Example usage:\n# input_data = \"a+b\\n1234\\nc*d\\n5678\\n\"\n# result = process_input(input_data)",
    "timestamp": "2025-08-13 08:43:28"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class PasswordHashChecker {\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        String input;\n\n        while ((input = reader.readLine()) != null && !input.isEmpty()) {\n            int numDatasets = Integer.parseInt(input);\n            for (int i = 0; i < numDatasets; i++) {\n                String[] parts = reader.readLine().trim().split(\" \");\n                String hashFunction = parts[0];\n                String password = parts[1];\n                int targetHashValue = computeHash(hashFunction, password);\n                int count = countPasswordsWithHash(hashFunction, targetHashValue);\n                System.out.println(count);\n            }\n        }\n    }\n    \n    private static int computeHash(String hashFunction, String password) {\n        // Abstract function to interpret and evaluate the hash function for a given password\n        Stack<Integer> stack = new Stack<>();\n        \n        for (char ch : hashFunction.toCharArray()) {\n            if (ch == 'a' || ch == 'b' || ch == 'c' || ch == 'd') {\n                stack.push(password.charAt(ch - 'a') - '0');\n            } else {\n                int b = stack.pop();\n                int a = stack.pop();\n                \n                switch (ch) {\n                    case '+':\n                        stack.push(a | b);\n                        break;\n                    case '*':\n                        stack.push(a & b);\n                        break;\n                    case '^':\n                        stack.push(a ^ b);\n                        break;\n                }\n            }\n        }\n        \n        return stack.isEmpty() ? 0 : stack.pop();\n    }\n    \n    private static int countPasswordsWithHash(String hashFunction, int targetHashValue) {\n        int count = 0;\n        \n        for (int d1 = 0; d1 <= 9; d1++) {\n            for (int d2 = 0; d2 <= 9; d2++) {\n                for (int d3 = 0; d3 <= 9; d3++) {\n                    for (int d4 = 0; d4 <= 9; d4++) {\n                        String pwd = \"\" + d1 + d2 + d3 + d4;\n                        if (computeHash(hashFunction, pwd) == targetHashValue) {\n                            count++;\n                        }\n                    }\n                }\n            }\n        }\n        \n        return count;\n    }\n}",
    "timestamp": "2025-08-13 08:43:32"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint compute_hash(char *hash_function, int password) {\n    int stack[100];\n    int top = -1;\n    \n    for(int i = 0; i < strlen(hash_function); i++) {\n        if(hash_function[i] >= 'a' && hash_function[i] <= 'd') {\n            int index = hash_function[i] - 'a';\n            stack[++top] = (password / (int)pow(10, 3-index)) % 10;\n        } else {\n            int b = stack[top--];\n            int a = stack[top--];\n            \n            switch(hash_function[i]) {\n                case '+': stack[++top] = a | b; break;\n                case '*': stack[++top] = a & b; break;\n                case '^': stack[++top] = a ^ b; break;\n            }\n        }\n    }\n    \n    return stack[top];\n}\n\nint main() {\n    int dataset_count;\n    scanf(\"%d\", &dataset_count);\n    \n    while(dataset_count--) {\n        char hash_function[101];\n        int given_password;\n        \n        scanf(\"%s%d\", hash_function, &given_password);\n        \n        int target_hash = compute_hash(hash_function, given_password);\n        int matching_passwords = 0;\n        \n        for(int i = 0; i < 10000; i++) {\n            if(compute_hash(hash_function, i) == target_hash) {\n                matching_passwords++;\n            }\n        }\n        \n        printf(\"%d\\n\", matching_passwords);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 08:43:36"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def apply_hash(hash_func, password):\n    stack = []\n    for token in hash_func.split():\n        if len(token) == 1 and token in 'abcd':\n            index = 'abcd'.index(token)\n            stack.append(int(password[index]))\n        elif token in ['+', '*', '^']:\n            b, a = stack.pop(), stack.pop()\n            if token == '+':\n                stack.append(a | b)\n            elif token == '*':\n                stack.append(a & b)\n            elif token == '^':\n                stack.append(a ^ b)\n    return stack[0]\n\ndef count_matching_passwords(hash_func):\n    count = 0\n    target_hash = 0\n    for pwd in range(10000):\n        password = f\"{pwd:04d}\"\n        curr_hash = apply_hash(hash_func, password)\n        if curr_hash == target_hash:\n            count += 1\n    return count\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        hash_func = input().strip()\n        password = input().strip()\n        \n        # Compute password's hash\n        pwd_hash = apply_hash(hash_func, password)\n        \n        # Count matching passwords\n        matching_passwords = count_matching_passwords(hash_func)\n        \n        print(matching_passwords)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 08:43:47"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\n\ndef evaluate_hash(hash_func, password):\n    stack = []\n    for token in hash_func.split():\n        if token in ['a', 'b', 'c', 'd']:\n            idx = ord(token) - ord('a')\n            stack.append(int(password[idx]))\n        elif token in ['+', '*', '^']:\n            if len(stack) < 2:\n                return None\n            b = stack.pop()\n            a = stack.pop()\n            if token == '+':\n                res = a | b\n            elif token == '*':\n                res = a & b\n            elif token == '^':\n                res = a ^ b\n            stack.append(res)\n        else:\n            return None\n    if len(stack) != 1:\n        return None\n    return stack[0]\n\ndef count_same_hash(hash_func, target_hash):\n    count = 0\n    for d1 in range(10):\n        for d2 in range(10):\n            for d3 in range(10):\n                for d4 in range(10):\n                    password = f\"{d1}{d2}{d3}{d4}\"\n                    current_hash = evaluate_hash(hash_func, password)\n                    if current_hash == target_hash:\n                        count += 1\n    return count\n\ndef main():\n    input_lines = [line.strip() for line in sys.stdin if line.strip()]\n    idx = 0\n    while idx < len(input_lines):\n        hash_func = input_lines[idx]\n        password = input_lines[idx + 1]\n        idx += 2\n        target_hash = evaluate_hash(hash_func, password)\n        if target_hash is None:\n            print(\"Invalid hash function or password.\")\n            continue\n        count = count_same_hash(hash_func, target_hash)\n        print(count)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 08:44:03"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint applyOperator(int a, int b, char op) {\n    switch(op) {\n        case '+':\n            return a | b;\n        case '*':\n            return a & b;\n        case '^':\n            return a ^ b;\n        default:\n            return 0;\n    }\n}\n\nint calculateHash(const string& hashFunction, const string& password) {\n    vector<int> stack;\n    \n    for (char c : hashFunction) {\n        if (c >= 'a' && c <= 'd') {\n            stack.push_back(password[c - 'a'] - '0');\n        } else if (c == '+' || c == '*' || c == '^') {\n            if (stack.size() < 2) continue;\n            int b = stack.back(); stack.pop_back();\n            int a = stack.back(); stack.pop_back();\n            stack.push_back(applyOperator(a, b, c));\n        }\n    }\n    \n    return stack.empty() ? 0 : stack.back();\n}\n\nint countMatchingPasswords(const string& hashFunction, int targetHash) {\n    int count = 0;\n    for (int i = 0; i <= 9999; ++i) {\n        string password = to_string(i);\n        while (password.length() < 4) {\n            password = '0' + password;\n        }\n        \n        if (calculateHash(hashFunction, password) == targetHash) {\n            ++count;\n        }\n    }\n    return count;\n}\n\nint main() {\n    string hashFunction, password;\n    while (cin >> hashFunction >> password) {\n        int targetHash = calculateHash(hashFunction, password);\n        int result = countMatchingPasswords(hashFunction, targetHash);\n        cout << result << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 11:47:43"
  }
]