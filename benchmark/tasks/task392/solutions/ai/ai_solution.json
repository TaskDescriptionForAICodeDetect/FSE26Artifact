[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_SIZE 500\n\ntypedef struct {\n    int x, y;\n} Position;\n\nint M, N;\nchar grid[MAX_SIZE][MAX_SIZE + 1]; // +1 for null terminator\nint visited[MAX_SIZE][MAX_SIZE];\nPosition pairs[26][2];\nint pair_count[26] = {0};\n\nint max_score = 0;\n\nvoid find_pairs() {\n    for (int i = 0; i < M; i++) {\n        for (int j = 0; j < N; j++) {\n            char c = grid[i][j];\n            if (c != '.') {\n                int idx = c - 'A';\n                pairs[idx][pair_count[idx]].x = i;\n                pairs[idx][pair_count[idx]].y = j;\n                pair_count[idx]++;\n            }\n        }\n    }\n}\n\nvoid dfs(int score) {\n    if (score > max_score) {\n        max_score = score;\n    }\n\n    for (int c = 0; c < 26; c++) {\n        if (pair_count[c] != 2) continue;\n\n        Position p1 = pairs[c][0];\n        Position p2 = pairs[c][1];\n\n        if (grid[p1.x][p1.y] == '.' || grid[p2.x][p2.y] == '.') continue;\n\n        // Check if the pair can be removed\n        int can_remove = 1;\n        for (int dir = 0; dir < 4; dir++) {\n            int dx = 0, dy = 0;\n            if (dir == 0) dx = -1; // up\n            else if (dir == 1) dx = 1; // down\n            else if (dir == 2) dy = -1; // left\n            else if (dir == 3) dy = 1; // right\n\n            int x = p1.x + dx, y = p1.y + dy;\n            while (x >= 0 && x < M && y >= 0 && y < N) {\n                if (grid[x][y] != '.') {\n                    if (grid[x][y] != c) {\n                        can_remove = 0;\n                    }\n                    break;\n                }\n                x += dx;\n                y += dy;\n            }\n            if (!can_remove) break;\n\n            x = p2.x + dx, y = p2.y + dy;\n            while (x >= 0 && x < M && y >= 0 && y < N) {\n                if (grid[x][y] != '.') {\n                    if (grid[x][y] != c) {\n                        can_remove = 0;\n                    }\n                    break;\n                }\n                x += dx;\n                y += dy;\n            }\n            if (!can_remove) break;\n        }\n\n        if (can_remove) {\n            grid[p1.x][p1.y] = '.';\n            grid[p2.x][p2.y] = '.';\n            dfs(score + 2);\n            grid[p1.x][p1.y] = c + 'A';\n            grid[p2.x][p2.y] = c + 'A';\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &M, &N);\n    for (int i = 0; i < M; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    find_pairs();\n    dfs(0);\n\n    printf(\"%d\\n\", max_score);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:20:42"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int M, N;\n    cin >> M >> N;\n    vector<string> grid(M);\n    for (int i = 0; i < M; ++i) {\n        cin >> grid[i];\n    }\n\n    map<char, vector<pair<int, int>>> color_positions;\n    for (int i = 0; i < M; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if (grid[i][j] != '.') {\n                color_positions[grid[i][j]].emplace_back(i, j);\n            }\n        }\n    }\n\n    int score = 0;\n    for (auto& [color, positions] : color_positions) {\n        if (positions.size() != 2) continue;\n\n        auto [i1, j1] = positions[0];\n        auto [i2, j2] = positions[1];\n\n        bool can_remove = false;\n\n        // Check if they are in the same row and no obstacles between\n        if (i1 == i2) {\n            int min_j = min(j1, j2);\n            int max_j = max(j1, j2);\n            bool blocked = false;\n            for (int j = min_j + 1; j < max_j; ++j) {\n                if (grid[i1][j] != '.') {\n                    blocked = true;\n                    break;\n                }\n            }\n            if (!blocked) {\n                can_remove = true;\n            }\n        }\n\n        // Check if they are in the same column and no obstacles between\n        if (!can_remove && j1 == j2) {\n            int min_i = min(i1, i2);\n            int max_i = max(i1, i2);\n            bool blocked = false;\n            for (int i = min_i + 1; i < max_i; ++i) {\n                if (grid[i][j1] != '.') {\n                    blocked = true;\n                    break;\n                }\n            }\n            if (!blocked) {\n                can_remove = true;\n            }\n        }\n\n        // Check if they can be removed by hitting an empty cell\n        if (!can_remove) {\n            // Check all four directions from i1, j1 and i2, j2\n            // For each empty cell, check if hitting it would focus both tiles\n            // This is too slow for large grids, so we need a smarter approach\n            // Instead, check if there exists a cell (i, j) where:\n            // - It's empty\n            // - The nearest tile above is one of the pair, and the nearest tile below is the other\n            // - Or similar for left and right\n            // This is still O(M*N) per pair, but with M,N up to 500 and 26 letters, it's manageable\n            for (int i = 0; i < M; ++i) {\n                for (int j = 0; j < N; ++j) {\n                    if (grid[i][j] != '.') continue;\n\n                    // Check up and down\n                    pair<int, int> up_tile = {-1, -1};\n                    for (int k = i - 1; k >= 0; --k) {\n                        if (grid[k][j] != '.') {\n                            up_tile = {k, j};\n                            break;\n                        }\n                    }\n                    pair<int, int> down_tile = {-1, -1};\n                    for (int k = i + 1; k < M; ++k) {\n                        if (grid[k][j] != '.') {\n                            down_tile = {k, j};\n                            break;\n                        }\n                    }\n\n                    if ((up_tile == positions[0] && down_tile == positions[1]) ||\n                        (up_tile == positions[1] && down_tile == positions[0])) {\n                        can_remove = true;\n                        break;\n                    }\n\n                    // Check left and right\n                    pair<int, int> left_tile = {-1, -1};\n                    for (int k = j - 1; k >= 0; --k) {\n                        if (grid[i][k] != '.') {\n                            left_tile = {i, k};\n                            break;\n                        }\n                    }\n                    pair<int, int> right_tile = {-1, -1};\n                    for (int k = j + 1; k < N; ++k) {\n                        if (grid[i][k] != '.') {\n                            right_tile = {i, k};\n                            break;\n                        }\n                    }\n\n                    if ((left_tile == positions[0] && right_tile == positions[1]) ||\n                        (left_tile == positions[1] && right_tile == positions[0])) {\n                        can_remove = true;\n                        break;\n                    }\n                }\n                if (can_remove) break;\n            }\n        }\n\n        if (can_remove) {\n            score += 2;\n        }\n    }\n\n    cout << score << '\\n';\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:21:30"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    static class Pair {\n        int r, c;\n        Pair(int r, int c) {\n            this.r = r;\n            this.c = c;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int M = scanner.nextInt();\n        int N = scanner.nextInt();\n        scanner.nextLine();\n        char[][] grid = new char[M][N];\n        Map<Character, List<Pair>> colorMap = new HashMap<>();\n\n        for (int i = 0; i < M; i++) {\n            String line = scanner.nextLine();\n            for (int j = 0; j < N; j++) {\n                grid[i][j] = line.charAt(j);\n                if (grid[i][j] != '.') {\n                    char color = grid[i][j];\n                    colorMap.computeIfAbsent(color, k -> new ArrayList<>()).add(new Pair(i, j));\n                }\n            }\n        }\n\n        int score = 0;\n        for (char color : colorMap.keySet()) {\n            List<Pair> pairs = colorMap.get(color);\n            if (pairs.size() != 2) continue;\n\n            Pair p1 = pairs.get(0);\n            Pair p2 = pairs.get(1);\n            if (p1.r == p2.r || p1.c == p2.c) {\n                score += 2;\n            }\n        }\n\n        System.out.println(score);\n    }\n}",
    "timestamp": "2025-08-05 21:22:17"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class TilesAreColorful {\n    static char[][] grid;\n    static int M, N;\n    static int maxScore;\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        \n        M = Integer.parseInt(st.nextToken());\n        N = Integer.parseInt(st.nextToken());\n        grid = new char[M][N];\n        \n        for (int i = 0; i < M; i++) {\n            String row = br.readLine();\n            for (int j = 0; j < N; j++) {\n                grid[i][j] = row.charAt(j);\n            }\n        }\n        \n        maxScore = 0;\n        for (int i = 0; i < M; i++) {\n            for (int j = 0; j < N; j++) {\n                if (grid[i][j] == '.') {\n                    solve(i, j);\n                }\n            }\n        }\n        \n        System.out.println(maxScore);\n    }\n    \n    static void solve(int hitRow, int hitCol) {\n        Set<int[]> focused = new HashSet<>();\n        \n        // Check upwards\n        for (int r = hitRow - 1; r >= 0; r--) {\n            if (grid[r][hitCol] != '.') {\n                focused.add(new int[]{r, hitCol});\n                break;\n            }\n        }\n        \n        // Check downwards\n        for (int r = hitRow + 1; r < M; r++) {\n            if (grid[r][hitCol] != '.') {\n                focused.add(new int[]{r, hitCol});\n                break;\n            }\n        }\n        \n        // Check left\n        for (int c = hitCol - 1; c >= 0; c--) {\n            if (grid[hitRow][c] != '.') {\n                focused.add(new int[]{hitRow, c});\n                break;\n            }\n        }\n        \n        // Check right\n        for (int c = hitCol + 1; c < N; c++) {\n            if (grid[hitRow][c] != '.') {\n                focused.add(new int[]{hitRow, c});\n                break;\n            }\n        }\n        \n        // Check matching colors and calculate score\n        Map<Character, List<int[]>> colorMap = new HashMap<>();\n        for (int[] tile : focused) {\n            char color = grid[tile[0]][tile[1]];\n            colorMap.computeIfAbsent(color, k -> new ArrayList<>()).add(tile);\n        }\n        \n        int score = 0;\n        for (List<int[]> sameColorTiles : colorMap.values()) {\n            if (sameColorTiles.size() == 2) {\n                score += 2;\n                grid[sameColorTiles.get(0)[0]][sameColorTiles.get(0)[1]] = '.';\n                grid[sameColorTiles.get(1)[0]][sameColorTiles.get(1)[1]] = '.';\n            }\n        }\n        \n        maxScore = Math.max(maxScore, score);\n    }\n}",
    "timestamp": "2025-08-05 21:22:27"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_M 500\n#define MAX_N 500\n\nchar grid[MAX_M][MAX_N + 1];\nint M, N;\nint maxScore;\n\ntypedef struct {\n    int row;\n    int col;\n} Tile;\n\nTile focusedTiles[4];\nint focusedCount;\n\nvoid findTilesInDirection(int row, int col, int dRow, int dCol) {\n    while (row >= 0 && row < M && col >= 0 && col < N) {\n        if (grid[row][col] != '.') {\n            focusedTiles[focusedCount].row = row;\n            focusedTiles[focusedCount].col = col;\n            focusedCount++;\n            return;\n        }\n        row += dRow;\n        col += dCol;\n    }\n}\n\nvoid removeTiles(char color) {\n    for (int i = 0; i < focusedCount; i++) {\n        grid[focusedTiles[i].row][focusedTiles[i].col] = '.';\n    }\n}\n\nvoid backtrack(int score) {\n    maxScore = (score > maxScore) ? score : maxScore;\n\n    for (int row = 0; row < M; row++) {\n        for (int col = 0; col < N; col++) {\n            if (grid[row][col] == '.') {\n                focusedCount = 0;\n                findTilesInDirection(row - 1, col, -1, 0);\n                findTilesInDirection(row + 1, col, 1, 0);\n                findTilesInDirection(row, col - 1, 0, -1);\n                findTilesInDirection(row, col + 1, 0, 1);\n\n                if (focusedCount > 0) {\n                    char colors[4];\n                    int colorCount[4] = {0};\n\n                    for (int i = 0; i < focusedCount; i++) {\n                        colors[i] = grid[focusedTiles[i].row][focusedTiles[i].col];\n                        colorCount[i] = 1;\n                    }\n\n                    for (int i = 0; i < focusedCount; i++) {\n                        for (int j = i + 1; j < focusedCount; j++) {\n                            if (colors[i] == colors[j]) {\n                                char tempGrid[MAX_M][MAX_N + 1];\n                                memcpy(tempGrid, grid, sizeof(grid));\n\n                                removeTiles(colors[i]);\n                                backtrack(score + 2);\n\n                                memcpy(grid, tempGrid, sizeof(grid));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &M, &N);\n    for (int i = 0; i < M; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    maxScore = 0;\n    backtrack(0);\n\n    printf(\"%d\\n\", maxScore);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:22:38"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxScore = 0;\n    vector<vector<char>> grid;\n    int M, N;\n\n    int solve(int m, int n) {\n        grid = vector<vector<char>>(m, vector<char>(n));\n        M = m, N = n;\n\n        // Read input\n        for (int i = 0; i < m; i++) {\n            string row;\n            cin >> row;\n            for (int j = 0; j < n; j++) {\n                grid[i][j] = row[j];\n            }\n        }\n\n        // Try hitting each cell as starting point\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == '.') {\n                    findMaxScore(i, j);\n                }\n            }\n        }\n\n        return maxScore;\n    }\n\n    void findMaxScore(int startRow, int startCol) {\n        vector<vector<char>> tempGrid = grid;\n        int currentScore = hitCell(tempGrid, startRow, startCol);\n        maxScore = max(maxScore, currentScore);\n    }\n\n    int hitCell(vector<vector<char>>& tempGrid, int row, int col) {\n        unordered_map<char, vector<pair<int, int>>> focusedTiles;\n\n        // Up direction\n        for (int r = row - 1; r >= 0; r--) {\n            if (tempGrid[r][col] != '.') {\n                focusedTiles[tempGrid[r][col]].push_back({r, col});\n                break;\n            }\n        }\n\n        // Down direction\n        for (int r = row + 1; r < M; r++) {\n            if (tempGrid[r][col] != '.') {\n                focusedTiles[tempGrid[r][col]].push_back({r, col});\n                break;\n            }\n        }\n\n        // Left direction\n        for (int c = col - 1; c >= 0; c--) {\n            if (tempGrid[row][c] != '.') {\n                focusedTiles[tempGrid[row][c]].push_back({row, c});\n                break;\n            }\n        }\n\n        // Right direction\n        for (int c = col + 1; c < N; c++) {\n            if (tempGrid[row][c] != '.') {\n                focusedTiles[tempGrid[row][c]].push_back({row, c});\n                break;\n            }\n        }\n\n        int score = 0;\n        for (auto& [color, tiles] : focusedTiles) {\n            if (tiles.size() == 2) {\n                for (auto& [r, c] : tiles) {\n                    tempGrid[r][c] = '.';\n                }\n                score += 2;\n            }\n        }\n\n        // If more tiles can be removed, continue recursively\n        int maxSubScore = 0;\n        for (int i = 0; i < M; i++) {\n            for (int j = 0; j < N; j++) {\n                if (tempGrid[i][j] == '.') {\n                    maxSubScore = max(maxSubScore, hitCell(tempGrid, i, j));\n                }\n            }\n        }\n\n        return score + maxSubScore;\n    }\n};\n\nint main() {\n    int m, n;\n    cin >> m >> n;\n\n    Solution solution;\n    cout << solution.solve(m, n) << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:22:53"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_score(grid):\n    M, N = len(grid), len(grid[0])\n    color_positions = {}\n\n    # Collect all positions of each color\n    for r in range(M):\n        for c in range(N):\n            if grid[r][c] != '.':\n                color = grid[r][c]\n                if color not in color_positions:\n                    color_positions[color] = []\n                color_positions[color].append((r, c))\n\n    score = 0\n    \n    # Calculate pairs contribution to the score\n    for positions in color_positions.values():\n        if len(positions) == 2:\n            score += 2\n    \n    return score\n\n# Input reading\nM, N = map(int, input().split())\ngrid = [input().strip() for _ in range(M)]\n\n# Calculate the maximum score\nresult = max_score(grid)\n\n# Output the result\nprint(result)",
    "timestamp": "2025-08-13 06:07:10"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Scanner;\n\npublic class ColorfulTiles {\n\n    static int M, N;\n    static char[][] grid;\n    static boolean[][] visited;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        M = sc.nextInt();\n        N = sc.nextInt();\n        grid = new char[M][N];\n        visited = new boolean[M][N];\n\n        for (int i = 0; i < M; i++) {\n            String line = sc.next();\n            for (int j = 0; j < N; j++) {\n                grid[i][j] = line.charAt(j);\n            }\n        }\n\n        System.out.println(maxScore());\n    }\n\n    private static int maxScore() {\n        HashMap<Character, HashSet<int[]>> tilePositions = new HashMap<>();\n\n        // Store positions of each tile\n        for (int i = 0; i < M; i++) {\n            for (int j = 0; j < N; j++) {\n                if (grid[i][j] != '.') {\n                    tilePositions.putIfAbsent(grid[i][j], new HashSet<>());\n                    tilePositions.get(grid[i][j]).add(new int[]{i, j});\n                }\n            }\n        }\n\n        int score = 0;\n\n        for (char color : tilePositions.keySet()) {\n            HashSet<int[]> positions = tilePositions.get(color);\n\n            if (positions.size() == 2) {\n                int[] p1 = null, p2 = null;\n                boolean first = true;\n\n                for (int[] pos : positions) {\n                    if (first) {\n                        p1 = pos;\n                        first = false;\n                    } else {\n                        p2 = pos;\n                    }\n                }\n\n                if (p1 != null && p2 != null) {\n                    int x1 = p1[0];\n                    int y1 = p1[1];\n                    int x2 = p2[0];\n                    int y2 = p2[1];\n                    if ((straightLineClear(x1, y1, x2, y2))) {\n                        score += 2; // Both tiles can be removed.\n                    }\n                }\n            }\n        }\n\n        return score;\n    }\n\n    private static boolean straightLineClear(int x1, int y1, int x2, int y2) {\n        if (x1 == x2) {\n            // same row, check column range\n            for (int j = Math.min(y1, y2) + 1; j < Math.max(y1, y2); j++) {\n                if (grid[x1][j] != '.') return false;\n            }\n        } else if (y1 == y2) {\n            // same column, check row range\n            for (int i = Math.min(x1, x2) + 1; i < Math.max(x1, x2); i++) {\n                if (grid[i][y1] != '.') return false;\n            }\n        } else {\n            return false;\n        }\n        return true;\n    }\n}",
    "timestamp": "2025-08-13 06:07:18"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX 502\n\nchar grid[MAX][MAX];\nbool visited[MAX][MAX];\nint M, N;\n\nint dx[] = {-1, 1, 0, 0}; // direction vectors for row\nint dy[] = {0, 0, -1, 1}; // direction vectors for column\n\nbool is_in_bounds(int x, int y) {\n    return x >= 0 && x < M && y >= 0 && y < N;\n}\n\nint max_score = 0;\n\nvoid reset_visited() {\n    for (int i = 0; i < M; i++)\n        for (int j = 0; j < N; j++)\n            visited[i][j] = false;\n}\n\nint focus_and_remove(int x, int y) {\n    reset_visited();\n    char focused_colors[4] = {0};\n    int score = 0, idx = 0;\n    \n    for (int d = 0; d < 4; d++) {\n        int nx = x + dx[d], ny = y + dy[d];\n        \n        while (is_in_bounds(nx, ny) && grid[nx][ny] == '.') {\n            nx += dx[d];\n            ny += dy[d];\n        }\n        \n        if (is_in_bounds(nx, ny) && grid[nx][ny] != '.' && !visited[nx][ny]) {\n            focused_colors[idx++] = grid[nx][ny];\n            visited[nx][ny] = true;\n        }\n    }\n    \n    for (int i = 0; i < idx; i++) {\n        for (int j = i + 1; j < idx; j++) {\n            if (focused_colors[i] != 0 && focused_colors[i] == focused_colors[j]) {\n                score += 2;\n                focused_colors[i] = focused_colors[j] = 0;\n            }\n        }\n    }\n    \n    return score;\n}\n\nint main() {\n    scanf(\"%d %d\", &M, &N);\n    \n    for (int i = 0; i < M; i++)\n        scanf(\"%s\", grid[i]);\n    \n    for (int i = 0; i < M; i++) {\n        for (int j = 0; j < N; j++) {\n            if (grid[i][j] == '.') {\n                int score = focus_and_remove(i, j);\n                if (score > max_score)\n                    max_score = score;\n            }\n        }\n    }\n    \n    printf(\"%d\\n\", max_score);\n    return 0;\n}",
    "timestamp": "2025-08-13 06:07:24"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve(M, N, grid):\n    def find_tiles(r, c):\n        focused = set()\n        # Up\n        for nr in range(r-1, -1, -1):\n            if grid[nr][c] != '.':\n                focused.add((nr, c))\n                break\n        \n        # Down\n        for nr in range(r+1, M):\n            if grid[nr][c] != '.':\n                focused.add((nr, c))\n                break\n        \n        # Left\n        for nc in range(c-1, -1, -1):\n            if grid[r][nc] != '.':\n                focused.add((r, nc))\n                break\n        \n        # Right\n        for nc in range(c+1, N):\n            if grid[r][nc] != '.':\n                focused.add((r, nc))\n                break\n        \n        return focused\n    \n    def dfs(grid):\n        max_score = 0\n        for r in range(M):\n            for c in range(N):\n                if grid[r][c] == '.':\n                    focused = find_tiles(r, c)\n                    \n                    if not focused:\n                        continue\n                    \n                    colors = {}\n                    for fr, fc in focused:\n                        color = grid[fr][fc]\n                        colors[color] = colors.get(color, 0) + 1\n                    \n                    curr_score = 0\n                    new_grid = [row[:] for row in grid]\n                    \n                    for color, count in colors.items():\n                        if count % 2 == 0:\n                            curr_score += count\n                            for fr, fc in focused:\n                                if grid[fr][fc] == color:\n                                    new_grid[fr][fc] = '.'\n                    \n                    max_score = max(max_score, curr_score + dfs(new_grid))\n        \n        return max_score\n    \n    return dfs(grid)\n\n# Input processing\nM, N = map(int, input().split())\ngrid = [list(input().strip()) for _ in range(M)]\nprint(solve(M, N, grid))",
    "timestamp": "2025-08-13 06:07:40"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import defaultdict\n\ndef solve():\n    M, N = map(int, sys.stdin.readline().split())\n    grid = [list(sys.stdin.readline().strip()) for _ in range(M)]\n    \n    color_positions = defaultdict(list)\n    for i in range(M):\n        for j in range(N):\n            c = grid[i][j]\n            if c != '.':\n                color_positions[c].append((i, j))\n    \n    score = 0\n    \n    for color in color_positions:\n        if len(color_positions[color]) != 2:\n            continue\n        (i1, j1), (i2, j2) = color_positions[color]\n        # Check if they can be removed by hitting some cell\n        # The hit cell must be in the same row or column between them\n        # Either same row between j1 and j2, or same column between i1 and i2\n        # Check row i1 or i2 between columns\n        # Or column j1 or j2 between rows\n        # We need to find a cell (x,y) such that:\n        # For (x,y), the four directions include both positions of the color\n        # So x must be between i1 and i2 (if same column), or y between j1 and j2 (if same row)\n        # Or x is i1 or i2 and y is between j1 and j2, or y is j1 or j2 and x is between i1 and i2\n        \n        # Check if they are in the same row\n        if i1 == i2:\n            # Any hit in the same row between j1 and j2 will have left and right directions covering both\n            # So any (i1, y) where min(j1,j2) < y < max(j1,j2)\n            # Also, if there's no blocking tiles in between\n            j_min = min(j1, j2)\n            j_max = max(j1, j2)\n            blocked = False\n            for y in range(j_min + 1, j_max):\n                if grid[i1][y] != '.':\n                    blocked = True\n                    break\n            if not blocked:\n                score += 2\n                continue\n        \n        # Check if they are in the same column\n        if j1 == j2:\n            # Any hit in the same column between i1 and i2 will have up and down directions covering both\n            i_min = min(i1, i2)\n            i_max = max(i1, i2)\n            blocked = False\n            for x in range(i_min + 1, i_max):\n                if grid[x][j1] != '.':\n                    blocked = True\n                    break\n            if not blocked:\n                score += 2\n                continue\n        \n        # Check if they can be hit by a cell in a cross pattern\n        # The hit cell (x,y) must have x between i1 and i2, y between j1 and j2\n        # And the four directions must include both positions\n        # So x must be i1 or i2, and y must be the other's j\n        # Or y must be j1 or j2, and x must be the other's i\n        # Or (i1,j2) or (i2,j1) as hit cell\n        # Check (i1, j2)\n        if (i1, j2) != (i1, j1) and (i1, j2) != (i2, j2):\n            x, y = i1, j2\n            # Check up, down, left, right\n            up_tile = None\n            for xi in range(x-1, -1, -1):\n                if grid[xi][y] != '.':\n                    up_tile = grid[xi][y]\n                    break\n            down_tile = None\n            for xi in range(x+1, M):\n                if grid[xi][y] != '.':\n                    down_tile = grid[xi][y]\n                    break\n            left_tile = None\n            for yj in range(y-1, -1, -1):\n                if grid[x][yj] != '.':\n                    left_tile = grid[x][yj]\n                    break\n            right_tile = None\n            for yj in range(y+1, N):\n                if grid[x][yj] != '.':\n                    right_tile = grid[x][yj]\n                    break\n            tiles = set()\n            if up_tile == color:\n                tiles.add(up_tile)\n            if down_tile == color:\n                tiles.add(down_tile)\n            if left_tile == color:\n                tiles.add(left_tile)\n            if right_tile == color:\n                tiles.add(right_tile)\n            if len(tiles) == 2:\n                score += 2\n                continue\n        \n        # Check (i2, j1)\n        if (i2, j1) != (i1, j1) and (i2, j1) != (i2, j2):\n            x, y = i2, j1\n            # Check up, down, left, right\n            up_tile = None\n            for xi in range(x-1, -1, -1):\n                if grid[xi][y] != '.':\n                    up_tile = grid[xi][y]\n                    break\n            down_tile = None\n            for xi in range(x+1, M):\n                if grid[xi][y] != '.':\n                    down_tile = grid[xi][y]\n                    break\n            left_tile = None\n            for yj in range(y-1, -1, -1):\n                if grid[x][yj] != '.':\n                    left_tile = grid[x][yj]\n                    break\n            right_tile = None\n            for yj in range(y+1, N):\n                if grid[x][yj] != '.':\n                    right_tile = grid[x][yj]\n                    break\n            tiles = set()\n            if up_tile == color:\n                tiles.add(up_tile)\n            if down_tile == color:\n                tiles.add(down_tile)\n            if left_tile == color:\n                tiles.add(left_tile)\n            if right_tile == color:\n                tiles.add(right_tile)\n            if len(tiles) == 2:\n                score += 2\n                continue\n    \n    print(score)\n\nsolve()",
    "timestamp": "2025-08-13 06:08:14"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <set>\n\nusing namespace std;\n\n// Function to trace in each direction\nvoid trace(const vector<string>& grid, int row, int col, int& up, int& down, int& left, int& right) {\n    int M = grid.size();\n    int N = grid[0].size();\n    \n    // Upward\n    up = -1;\n    for (int i = row - 1; i >= 0; --i) {\n        if (grid[i][col] != '.') {\n            up = i;\n            break;\n        }\n    }\n\n    // Downward\n    down = -1;\n    for (int i = row + 1; i < M; ++i) {\n        if (grid[i][col] != '.') {\n            down = i;\n            break;\n        }\n    }\n\n    // Leftward\n    left = -1;\n    for (int j = col - 1; j >= 0; --j) {\n        if (grid[row][j] != '.') {\n            left = j;\n            break;\n        }\n    }\n\n    // Rightward\n    right = -1;\n    for (int j = col + 1; j < N; ++j) {\n        if (grid[row][j] != '.') {\n            right = j;\n            break;\n        }\n    }\n}\n\n// Calculate the maximum score\nint calculate_max_score(const vector<string>& grid) {\n    int M = grid.size();\n    int N = grid[0].size();\n    int max_score = 0;\n    \n    // Iterate over all empty cells to try hitting them\n    for (int row = 0; row < M; ++row) {\n        for (int col = 0; col < N; ++col) {\n            if (grid[row][col] == '.') {\n                int up, down, left, right;\n                trace(grid, row, col, up, down, left, right);\n                unordered_map<char, int> count;\n                set<pair<int, char>> checked_positions;\n\n                if (up != -1) {\n                    checked_positions.insert({up, grid[up][col]});\n                    count[grid[up][col]]++;\n                }\n                if (down != -1) {\n                    if (checked_positions.find({down, grid[down][col]}) == checked_positions.end()) {\n                        checked_positions.insert({down, grid[down][col]});\n                        count[grid[down][col]]++;\n                    }\n                }\n                if (left != -1) {\n                    checked_positions.insert({left, grid[row][left]});\n                    count[grid[row][left]]++;\n                }\n                if (right != -1) {\n                    if (checked_positions.find({right, grid[row][right]}) == checked_positions.end()) {\n                        checked_positions.insert({right, grid[row][right]});\n                        count[grid[row][right]]++;\n                    }\n                }\n                \n                int current_score = 0;\n                for (auto& entry : count) {\n                    if (entry.second > 1) {\n                        current_score += entry.second;\n                    }\n                }\n                max_score = max(max_score, current_score);\n            }\n        }\n    }\n    \n    return max_score;\n}\n\nint main() {\n    int M, N;\n    cin >> M >> N;\n    vector<string> grid(M);\n    for (int i = 0; i < M; ++i) {\n        cin >> grid[i];\n    }\n    \n    int max_score = calculate_max_score(grid);\n    cout << max_score << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:30:06"
  }
]