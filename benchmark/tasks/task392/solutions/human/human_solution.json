[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nint main() {\n  int m,n;\n  cin>>m>>n;\n  vector<string> t(m);\n  REP(i,m)cin>>t[i];\n  vector<int> iv,jv;\n  REP(i,m) {\n    bool al = true;\n    REP(j,n) if(t[i][j] != '.') al = false;\n    if(!al){\n      if(i) iv.push_back(i-1);\n      iv.push_back(i);\n      if(i<m-1) iv.push_back(i+1);\n    }\n  }\n  sort(begin(iv),end(iv));\n  iv.erase(unique(begin(iv),end(iv)),end(iv));\n  REP(i,n) {\n    bool al = true;\n    REP(j,m) if(t[j][m] != '.') al = false;\n    if(!al){\n      if(i) jv.push_back(i-1);\n      jv.push_back(i);\n      if(i<n-1) jv.push_back(i+1);\n    }\n  }\n  sort(begin(jv),end(jv));\n  jv.erase(unique(begin(jv),end(jv)),end(jv));\n  if (iv.empty()) {\n    cout << 0 << endl;\n    return 0;\n  }\n  vector<string> ct(iv.size());\n  m = iv.size();\n  n = jv.size();\n  REP(i,m)\n    REP(j,n)\n      ct[i] += t[iv[i]][jv[j]];\n  int score = 0;\n  while(1){\n    set<char> er;\n    REP(i,m)REP(j,n){\n      if (ct[i][j] != '.') continue;\n      map<char, int> s;\n      int di[]={1,0,-1,0};\n      int dj[]={0,1,0,-1};\n      REP(k,4){\n        int l=1;\n        while(1){\n          int ni=i+di[k]*l;\n          int nj=j+dj[k]*l;\n          if(ni<0||nj<0||ni>=m||nj>=n) break;\n          if(ct[ni][nj] != '.'){\n            ++s[ct[ni][nj]];\n            break;\n          }\n          ++l;\n        }\n      }\n      for (auto p:s) {\n        if(p.second == 2) er.insert(p.first);\n      }\n    }\n    score += er.size()*2;\n    if (er.empty()) break;\n    REP(i,m)REP(j,n){\n      if(er.count(ct[i][j]))\n        ct[i][j] = '.';\n    }\n  }\n  cout << score << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cctype>\n#include <vector>\n#include <set>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0 ; i < n ; i++)\n\nstruct Point{\n  int x1, y1, x2, y2;\n};\n\nconst int MAX = 510;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nchar field[MAX][MAX];\nbool found[26];\nPoint alpha[26];\n\nint H, W;\n\nbool canReach(char C, int cx, int cy, int x, int y){\n  if(cx < x){\n    for(int j = x ; j >= cx ; j--){\n      if(field[y][j] != '.' && field[y][j] != C) return false;\n    }\n  }\n  else if(cx > x){\n    for(int j = x ; j <= cx ; j++){\n      if(field[y][j] != '.' && field[y][j] != C) return false;\n    }\n  }\n  \n  if(cy < y){\n    for(int i = y ; i >= cy ; i--){\n      if(field[i][x] != '.' && field[i][x] != C) return false;\n    }\n  }\n  else if(cy > y){\n    for(int i = y ; i <= y ; i++){\n      if(field[i][x] != '.' && field[i][x] != C) return false;\n    }\n  }\n  return true;\n}\n\nbool canReach_x(char C, int x, int y1, int y2){\n  if(y1 > y2) swap(y1, y2);\n  for(int i = y1 ; i <= y2 ; i++){\n    if(field[i][x] != '.' && field[i][x] != C) return false;\n  }\n  return true;\n}\n\nbool canReach_y(char C, int y, int x1, int x2){\n  if(x1 > x2) swap(x1, x2);\n  for(int j = x1 ; j <= x2 ; j++){\n    if(field[y][j] != '.' && field[y][j] != C) return false;\n  }\n  return true;\n}\n\nint main(){\n  while(cin >> H >> W){\n    rep(i, H) cin >> field[i];\n\n    memset(found, 0, sizeof(found));\n    \n    rep(i, H){\n      rep(j, W){\n\tint c = field[i][j]-'A';\n\tif(!found[c]){\n\t  found[c] = true;\n\t  alpha[c].x1 = j, alpha[c].y1 = i;\n\t}\n\telse{\n\t  alpha[c].x2 = j, alpha[c].y2 = i;\n\t}\t\n      }\n    }\n    \n    Point cross[26];\n    rep(i, 26){\n      if(found[i]){\n\tcross[i].x1 = alpha[i].x1, cross[i].y1 = alpha[i].y2;\n\tcross[i].x2 = alpha[i].x2, cross[i].y2 = alpha[i].y1;\n      }\n    }\n    \n    int ans = 0;\n    \n    rep(i, H){\n      rep(j, W){\n\tchar c = field[i][j];\n\trep(k, 4){\n\t  int nx = j+dx[k], ny = i+dy[k];\n\t  if(nx < 0 || nx > W || ny < 0 || ny > H) continue;\n\t  if(field[i][j] == field[ny][nx]) found[field[i][j]-'A'] = false;\n\t}\n      }\n    }\n\t\n    \n    for(; ;){\n      bool flag = false;\n      rep(i, 26){\n\tif(found[i]){\n\t  int x1 = alpha[i].x1, y1 = alpha[i].y1, x2 = alpha[i].x2, y2 = alpha[i].y2;\n\t  \n\t  if(x1 == x2){\n\t    if(canReach_x('A'+i, x1, y1, y2)){\n\t      field[y1][x1] = field[y2][x2] = '.';\n\t      found[i] = false;\n\t      ans += 2;\n\t      flag = true;\n\t    }\n\t  }\n\t  else if(y1 == y2){\n\t    if(canReach_y('A'+i, y1, x1, x2)){\n\t      field[y1][x1] = field[y2][x2] = '.';\n\t      found[i] = false;\n\t      ans += 2;\n\t      flag = true;\n\t    }\n\t  }\t      \t    \t  \t  \n\t  else if((canReach('A'+i, cross[i].x1, cross[i].y1, x1, y1) &&\n\t\t   canReach('A'+i, cross[i].x1, cross[i].y1, x2, y2)) ||\n\t\t  (canReach('A'+i, cross[i].x2, cross[i].y2, x1, y1) &&\n\t\t   canReach('A'+i, cross[i].x2, cross[i].y2, x2, y2))){\n\t    field[y1][x1] = field[y2][x2] = '.';\n\t    found[i] = false;\n\t    ans += 2;\n\t    flag = true;\n\t  }\n\t}\n      }\n      if(!flag) break;\n    }\n    \n    cout << ans << endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\nusing namespace std;\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nmap<int, int> compress(vector<int>& unzip) {\n  map<int, int> zip;\n  for (auto x : unzip) REP(d, 3) zip[x + d - 1] = -1;\n  int idx = 0;\n  unzip = vector<int>();\n  for (auto& p : zip) {\n    unzip.push_back(p.first);\n    p.second = idx;\n    idx++;\n  }\n  return zip;\n}\n\nint main() {\n  int m, n;\n  cin >> m >> n;\n  vector<string> c(m);\n  REP(i, m) cin >> c[i];\n\n////////////////////////////////////////\n  vector<int> xs, ys;\n  vector<char> cs;\n  REP(i, m) REP(j, n) {\n    if (c[i][j] == '.') continue;\n    xs.push_back(i);\n    ys.push_back(j);\n    cs.push_back(c[i][j]);\n  }\n  vector<int> uzx(xs), uzy(ys);\n  auto zx = compress(uzx);\n  auto zy = compress(uzy);\n  m = zx.size();\n  n = zy.size();\n  c = vector<string>(m, string(n, '.'));\n  REP(k, cs.size()) {\n    int x = xs[k];\n    int y = ys[k];\n    c[zx[x]][zy[y]] = cs[k];\n  }\n////////////////////////////////////////\n\n  int ans = 0;\n  while (true) {\n    int sum = 0;\n    REP(i, m) REP(j, n) {\n      if (c[i][j] != '.') continue;\n      vector<int> x(4, i), y(4, j);\n      REP(k, 4) {\n        while (true) {\n          if (c[x[k]][y[k]] != '.') break;\n          int tx = x[k] + dx[k];\n          int ty = y[k] + dy[k];\n          if (tx < 0 || m <= tx || ty < 0 || n <= ty) break;\n          x[k] += dx[k];\n          y[k] += dy[k];\n        }\n      }\n      REP(k, 4) REP(l, 4) {\n        if (k >= l) continue;\n        if (c[x[k]][y[k]] != '.' && c[x[k]][y[k]] == c[x[l]][y[l]]) {\n          sum += 2;\n          c[x[k]][y[k]] = '.';\n          c[x[l]][y[l]] = '.';\n        }\n      }\n    }\n    if (sum == 0) break;\n    ans += sum;\n  }\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// #ifdef DEBUG\n// #define _GLIBCXX_DEBUG\n// #endif\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <valarray>\n#include <map>\n#include <set>\n#include <list>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <complex>\n#include <string>\n#include <sstream>\n\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n\n// these require C++11\n#include <unordered_set>\n#include <unordered_map>\n#include <random>\n#include <thread>\n#include <chrono>\n\nusing namespace std;\n\n#define int long long\n\n#define all(c) c.begin(), c.end()\n#define repeat(i, n) for (int i = 0; i < static_cast<int>(n); i++)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x) \n#endif\n\ntemplate<typename A,typename B>\nostream &operator<<(ostream&os,const pair<A,B>& p){\n    os << \"(\" << p.first << \",\" << p.second << \")\";\n    return os;\n}\n\n// Define a type which holds an unsigned integer value \ntemplate<std::size_t> struct int_{};\ntemplate <class Tuple, size_t Pos>\nstd::ostream& print_tuple(std::ostream& out, const Tuple& t, int_<Pos> ) {\n  out << std::get< std::tuple_size<Tuple>::value-Pos >(t) << ',';\n  return print_tuple(out, t, int_<Pos-1>());\n}\n \ntemplate <class Tuple>\nstd::ostream& print_tuple(std::ostream& out, const Tuple& t, int_<1> ) {\n  return out << std::get<std::tuple_size<Tuple>::value-1>(t);\n}\n \ntemplate <class... Args>\nostream& operator<<(ostream& out, const std::tuple<Args...>& t) {\n  out << '('; \n  print_tuple(out, t, int_<sizeof...(Args)>()); \n  return out << ')';\n}\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &vec) {\n    os << \"[\";\n    for (const auto &v : vec) {\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\n\n\ntypedef complex<double> point;\n\n// template<typename T,std::size_t N>\n// struct _v_traits {using type = std::vector<typename _v_traits<T,N-1>::type>;};\n// template<typename T>\n// struct _v_traits<T,1> {using type = std::vector<T>;};\n// template<typename T,std::size_t N=1>\n// using vec = typename _v_traits<T,N>::type;\n\n\nconst char dot = '.';\ninline int to_index(char c){\n    return c - 'A';\n}\nconst vector<int> dy = {-1,0,1,0};\nconst vector<int> dx = {0,1,0,-1};\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int H,W; cin >> H >> W;\n    vector<string> field(H);\n    for(string& s : field){\n        cin >> s;\n    }\n\n    set<tuple<int,int> > should_press;\n    for(int y=0;y<H;y++){\n        for(int x=0;x<W;x++){\n            vector<int> v(26);\n            for(int i=0;i<4;i++){\n                for(int k=1;k<max(H,W);k++){\n                    int ny = y + k * dy[i],\n                        nx = x + k * dx[i];\n                    if(ny < 0 or ny >= H or nx < 0 or nx >= W) break;\n                    const char here = field[ny][nx];\n                    if(here != dot){\n                        v[to_index(here)]++;\n                        // break;\n                    }\n                }\n            }\n            if(*max_element(all(v)) >= 2){\n                should_press.insert(make_tuple(y,x));\n            }\n        }\n    }\n\n    // dump(should_press);\n    bool cont = true;\n    int ret = 0;\n    while(cont){\n        cont = false;\n        for(auto t : should_press){\n            int y = get<0>(t),\n                x = get<1>(t);\n            if(field[y][x] != dot) continue;\n            vector<tuple<int,int> > tiles;\n            for(int i=0;i<4;i++){\n                for(int k=1;k<max(H,W);k++){\n                    int ny = y + k * dy[i],\n                        nx = x + k * dx[i];\n                    if(ny < 0 or ny >= H or nx < 0 or nx >= W) break;\n                    const char here = field[ny][nx];\n                    if(here != dot){\n                        tiles.emplace_back(ny,nx);\n                        break;\n                    }\n                }\n            }\n            for(int i=0;i<tiles.size();i++){\n                for(int j=i+1;j<tiles.size();j++){\n                    char& ic = field[get<0>(tiles[i])][get<1>(tiles[i])];\n                    char& ij = field[get<0>(tiles[j])][get<1>(tiles[j])];\n                    if(ic == ij){\n                        ic = dot;\n                        ij = dot;\n                        ret+=2;\n                        cont = true;\n                        goto end;\n                    }\n                }\n            }\n        end:{}\n        }\n    }\n    cout << ret << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nvoid solve()\n{\n\tint M, N;\n\twhile(cin >> M >> N)\n\t{\n\t\tqueue<P> Que;\n\t\tvector< vector<char> > Field;\n\t\tField.resize(M);\n\t\tfor(int i = 0; i < M; ++i)\n\t\t{\n\t\t\tField[i].resize(N);\n\t\t}\n\t\tfor(int i = 0; i < M; ++i)\n\t\t{\n\t\t\tfor(int j = 0; j < N; ++j)\n\t\t\t{\n\t\t\t\tcin >> Field[i][j];\n\t\t\t\tif(Field[i][j] == '.')\n\t\t\t\t{\n\t\t\t\t\tQue.push(make_pair<int, int>(i, j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint count = 0;\n\t\twhile(!Que.empty())\n\t\t{\n\t\t\tP up    = make_pair(Que.front().first - 1, Que.front().second);\n\t\t\tP down  = make_pair(Que.front().first + 1, Que.front().second);\n\t\t\tP left  = make_pair(Que.front().first, Que.front().second - 1);\n\t\t\tP right = make_pair(Que.front().first, Que.front().second + 1);\n\t\t\tbool upOK = false;\n\t\t\tbool downOK = false;\n\t\t\tbool leftOK = false;\n\t\t\tbool rightOK = false;\n\t\t\twhile(0 <= up.first && up.first < M)\n\t\t\t{\n\t\t\t\tif(Field[up.first][up.second] == '.')\n\t\t\t\t{\n\t\t\t\t\t--up.first;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tupOK = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(0 <= down.first && down.first < M)\n\t\t\t{\n\t\t\t\tif(Field[down.first][down.second] == '.')\n\t\t\t\t{\n\t\t\t\t\t++down.first;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdownOK = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(0 <= left.second && left.second < N)\n\t\t\t{\n\t\t\t\tif(Field[left.first][left.second] == '.')\n\t\t\t\t{\n\t\t\t\t\t--left.second;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tleftOK = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(0 <= right.second && right.second < N)\n\t\t\t{\n\t\t\t\tif(Field[right.first][right.second] == '.')\n\t\t\t\t{\n\t\t\t\t\t++right.second;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\trightOK = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(upOK && downOK && Field[up.first][up.second] == Field[down.first][down.second] && Field[up.first][up.second] != '.')\n\t\t\t{\n\t\t\t\tcount += 2;\n\t\t\t\tField[up.first][up.second] = '.';\n\t\t\t\tField[down.first][down.second] = '.';\n\t\t\t\tQue.push(make_pair<int, int>(Que.front().first, Que.front().second));\n\t\t\t\tQue.push(make_pair<int, int>(up.first, up.second));\n\t\t\t\tQue.push(make_pair<int, int>(down.first, down.second));\n\t\t\t}\n\t\t\tif(upOK && leftOK && Field[up.first][up.second] == Field[left.first][left.second] && Field[left.first][left.second] != '.')\n\t\t\t{\n\t\t\t\tcount += 2;\n\t\t\t\tField[up.first][up.second] = '.';\n\t\t\t\tField[left.first][left.second] = '.';\n\t\t\t\tQue.push(make_pair<int, int>(Que.front().first, Que.front().second));\n\t\t\t\tQue.push(make_pair<int, int>(up.first, up.second));\n\t\t\t\tQue.push(make_pair<int, int>(left.first, left.second));\n\t\t\t}\n\t\t\tif(upOK && rightOK && Field[up.first][up.second] == Field[right.first][right.second] && Field[right.first][right.second] != '.')\n\t\t\t{\n\t\t\t\tcount += 2;\n\t\t\t\tField[up.first][up.second] = '.';\n\t\t\t\tField[right.first][right.second] = '.';\n\t\t\t\tQue.push(make_pair<int, int>(Que.front().first, Que.front().second));\n\t\t\t\tQue.push(make_pair<int, int>(up.first, up.second));\n\t\t\t\tQue.push(make_pair<int, int>(right.first, right.second));\n\t\t\t}\n\t\t\tif(leftOK && downOK && Field[left.first][left.second] == Field[down.first][down.second] && Field[left.first][left.second] != '.')\n\t\t\t{\n\t\t\t\tcount += 2;\n\t\t\t\tField[left.first][left.second] = '.';\n\t\t\t\tField[down.first][down.second] = '.';\n\t\t\t\tQue.push(make_pair<int, int>(Que.front().first, Que.front().second));\n\t\t\t\tQue.push(make_pair<int, int>(left.first, left.second));\n\t\t\t\tQue.push(make_pair<int, int>(down.first, down.second));\n\t\t\t}\n\t\t\tif(leftOK && rightOK && Field[left.first][left.second] == Field[right.first][right.second] && Field[right.first][right.second] != '.')\n\t\t\t{\n\t\t\t\tcount += 2;\n\t\t\t\tField[left.first][left.second] = '.';\n\t\t\t\tField[right.first][right.second] = '.';\n\t\t\t\tQue.push(make_pair<int, int>(Que.front().first, Que.front().second));\n\t\t\t\tQue.push(make_pair<int, int>(left.first, left.second));\n\t\t\t\tQue.push(make_pair<int, int>(right.first, right.second));\n\t\t\t}\n\t\t\tif(rightOK && downOK && Field[right.first][right.second] == Field[down.first][down.second] && Field[right.first][right.second] != '.')\n\t\t\t{\n\t\t\t\tcount += 2;\n\t\t\t\tField[right.first][right.second] = '.';\n\t\t\t\tField[down.first][down.second] = '.';\n\t\t\t\tQue.push(make_pair<int, int>(Que.front().first, Que.front().second));\n\t\t\t\tQue.push(make_pair<int, int>(right.first, right.second));\n\t\t\t\tQue.push(make_pair<int, int>(down.first, down.second));\n\t\t\t}\n\t\t\tQue.pop();\n\t\t}\n\t\tcout << count << endl;\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nchar a[502][502],X='#',C='.';\nint F(int x,int y)\n{\n\tif(a[y][x]-C)return 0;\n\tchar*p,c[4],t;\n\tint d[]={0,1,0,-1,0},e[4],i,j,r=0;\n\tfor(i=0;i<4;++i)\n\t{\n\t\tfor(j=1;t=a[y+j*d[i]][x+j*d[i+1]],t==C;++j);\n\t\tc[i]=t;\n\t\te[i]=j;\n\t}\n\tfor(i=0;i<3;++i)\n\t{\n\t\tif(c[i]-X && (p=std::find(c+i+1,c+4,c[i]))<c+4)\n\t\t{\n\t\t\ta[y+e[i]*d[i]][x+e[i]*d[i+1]]=C;\n\t\t\tj=p-c;\n\t\t\ta[y+e[j]*d[j]][x+e[j]*d[j+1]]=C;\n\t\t\tr+=2;\n\t\t}\n\t}\n\treturn r;\n}\nint main()\n{\n\tint m,n,x,y,f,r,t;\n\tscanf(\"%d%d\",&m,&n);\n\tfor(y=1;y<=m;++y)scanf(\"%s\",&a[y][1]);\n\tfor(y=0;y<m+2;++y)a[y][0]=a[y][n+1]=X;\n\tfor(r=x=0;x<n+2;++x)a[0][x]=a[m+1][x]=X;\n\tdo\n\t{\n\t\tf=0;\n\t\tfor(y=1;y<=m;++y)for(x=1;x<=n;++x)if(t=F(x,y))f=1,r+=t;\n\t}while(f);\n\tprintf(\"%d\\n\",r);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_W = 501;\nint h, w;\nchar C[MAX_W][MAX_W];\nint dx[4] = {0,0,-1,1};\nint dy[4] = {-1,1,0,0};\nbool memo[MAX_W][MAX_W];\n\nstruct P{\n\tint x, y;\n\tP(int x_, int y_){ x = x_; y = y_; }\n};\n\nbool search(int ax, int ay, int bx, int by){\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tmemo[y][x] = false;\n\t\t}\n\t}\n\tfor(int i=0 ; i < 4 ; i++ ){\n\t\tint mx = ax + dx[i];\n\t\tint my = ay + dy[i];\n\t\twhile( true ){\n\t\t\tif( mx < 0 || my < 0 || w <= mx || h <= my ) break;\n\t\t\tif( C[my][mx] == '.' ){\n\t\t\t\tmemo[my][mx] = true;\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmx += dx[i];\n\t\t\tmy += dy[i];\n\t\t}\n\t}\n\tfor(int i=0 ; i < 4 ; i++ ){\n\t\tint mx = bx + dx[i];\n\t\tint my = by + dy[i];\n\t\twhile( true ){\n\t\t\tif( mx < 0 || my < 0 || w <= mx || h <= my ) break;\n\t\t\tif( memo[my][mx] ){\n\t\t\t\treturn true;\n\t\t\t}else if( C[my][mx] != '.' ){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmx += dx[i];\n\t\t\tmy += dy[i];\n\t\t}\n\t}\n\treturn false;\n}\n\nint solve(){\n\tvector<P> v[26];\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tif( C[y][x] != '.' ){\n\t\t\t\tv[C[y][x]-'A'].push_back(P(x,y));\n\t\t\t}\n\t\t}\n\t}\n\tint res = 0;\n\twhile( true ){\n\t\tbool change = false;\n\t\tfor(int i=0 ; i < 26 ; i++ ){\n\t\t\tif( v[i].size() == 2 ){\n\t\t\t\tif( search(v[i][0].x, v[i][0].y, v[i][1].x, v[i][1].y) ){\n\t\t\t\t\tC[v[i][0].y][v[i][0].x] = '.';\n\t\t\t\t\tC[v[i][1].y][v[i][1].x] = '.';\n\t\t\t\t\tv[i].erase(v[i].begin(),v[i].end());\n\t\t\t\t\tchange = true;\n\t\t\t\t\tres += 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif( !change ) break;\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin >> h >> w;\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tcin >> C[y];\n\t}\n\tcout << solve() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cctype>\n#include <vector>\n#include <set>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0 ; i < n ; i++)\n\nstruct Point{\n  int x1, y1, x2, y2;\n};\n\nconst int MAX = 510;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nchar field[MAX][MAX];\nbool found[26];\nPoint alpha[26];\n\nint H, W;\n\nbool canReach(char C, int cx, int cy, int x, int y){\n  if(cx < x){\n    for(int j = x ; j >= cx ; j--){\n      if(field[y][j] != '.' && field[y][j] != C) return false;\n    }\n  }\n  else if(cx > x){\n    for(int j = x ; j <= cx ; j++){\n      if(field[y][j] != '.' && field[y][j] != C) return false;\n    }\n  }\n  \n  if(cy < y){\n    for(int i = y ; i >= cy ; i--){\n      if(field[i][x] != '.' && field[i][x] != C) return false;\n    }\n  }\n  else if(cy > y){\n    for(int i = y ; i <= y ; i++){\n      if(field[i][x] != '.' && field[i][x] != C) return false;\n    }\n  }\n  return true;\n}\n\nbool canReach_x(char C, int x, int y1, int y2){\n  if(y1 > y2) swap(y1, y2);\n  for(int i = y1 ; i <= y2 ; i++){\n    if(field[i][x] != '.' && field[i][x] != C) return false;\n  }\n  return true;\n}\n\nbool canReach_y(char C, int y, int x1, int x2){\n  if(x1 > x2) swap(x1, x2);\n  for(int j = x1 ; j <= x2 ; j++){\n    if(field[y][j] != '.' && field[y][j] != C) return false;\n  }\n  return true;\n}\n\nvoid output(){\n  rep(i, H){\n    rep(j, W){\n      cout << field[i][j];\n    }\n    cout << endl;\n  }\n  cout << endl;\n}\n\n\nint main(){\n  cin >> H >> W;\n    rep(i, H) cin >> field[i];\n\n    memset(found, 0, sizeof(found));\n    \n    rep(i, H){\n      rep(j, W){\n\tint c = field[i][j]-'A';\n\tif(!found[c]){\n\t  found[c] = true;\n\t  alpha[c].x1 = j, alpha[c].y1 = i;\n\t}\n\telse{\n\t  alpha[c].x2 = j, alpha[c].y2 = i;\n\t}\t\n      }\n    }\n    \n    Point cross[26];\n    rep(i, 26){\n      if(found[i]){\n\tcross[i].x1 = alpha[i].x1, cross[i].y1 = alpha[i].y2;\n\tcross[i].x2 = alpha[i].x2, cross[i].y2 = alpha[i].y1;\n      }\n    }\n    \n    int ans = 0;\n    \n    rep(i, H){\n      rep(j, W){\n\trep(k, 4){\n\t  int nx = j+dx[k], ny = i+dy[k];\n\t  if(nx < 0 || nx > W || ny < 0 || ny > H) continue;\n\t  if(field[i][j] == field[ny][nx]) found[field[i][j]-'A'] = false;\n\t}\n      }\n    }\n\t\n    \n    for(; ;){\n      //output();\n      bool flag = false;\n      rep(i, 26){\n\tif(found[i]){\n\t  int x1 = alpha[i].x1, y1 = alpha[i].y1, x2 = alpha[i].x2, y2 = alpha[i].y2;\n\t  \n\t  if(x1 == x2){\n\t    if(canReach_x('A'+i, x1, y1, y2)){\n\t      field[y1][x1] = field[y2][x2] = '.';\n\t      found[i] = false;\n\t      ans += 2;\n\t      flag = true;\n\t    }\n\t  }\n\t  else if(y1 == y2){\n\t    if(canReach_y('A'+i, y1, x1, x2)){\n\t      field[y1][x1] = field[y2][x2] = '.';\n\t      found[i] = false;\n\t      ans += 2;\n\t      flag = true;\n\t    }\n\t  }\t      \t    \t  \t  \n\t  else if((canReach('A'+i, cross[i].x1, cross[i].y1, x1, y1) &&\n\t\t   canReach('A'+i, cross[i].x1, cross[i].y1, x2, y2)) ||\n\t\t  (canReach('A'+i, cross[i].x2, cross[i].y2, x1, y1) &&\n\t\t   canReach('A'+i, cross[i].x2, cross[i].y2, x2, y2))){\n\t    field[y1][x1] = field[y2][x2] = '.';\n\t    found[i] = false;\n\t    ans += 2;\n\t    flag = true;\n\t  }\n\t}\n      }\n      if(!flag) break;\n    }\n    \n    cout << ans << endl;\n   \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\nint H,W;\nstring s[500];\nint x[26][2],y[26][2];\nint sgn(int x){\n\tif(x>0) return -1;\n\treturn 1;\n}\nint main(){\n\tcin>>H>>W;\n\trep(i,H) cin>>s[i];\n\trep(i,26) rep(j,2) x[i][j]=y[i][j]=-1;\n\trep(i,H) rep(j,W){\n\t\tif(s[i][j]!='.'){\n\t\t\tint c=s[i][j]-'A';\n\t\t\tif(x[c][0]<0) x[c][0]=i,y[c][0]=j;\n\t\t\telse x[c][1]=i,y[c][1]=j;\n\t\t}\n\t}\n\tbool update=true;\n\tint ans=0;\n\twhile(update){\n\t\tupdate=false;\n\t\trep(i,26) if(x[i][0]>=0&&s[x[i][0]][y[i][0]]!='.'){\n\t\t\tif(x[i][0]==x[i][1]){\n\t\t\t\tif(y[i][0]>y[i][1]) swap(y[i][0],y[i][1]);\n\t\t\t\tif(y[i][0]+1==y[i][1]) continue;\n\t\t\t\tbool ok=true;\n\t\t\t\tfor(int yi=y[i][0]+1;yi<y[i][1];yi++) if(s[x[i][0]][yi]!='.') ok=false;\n\t\t\t\tif(ok){\n\t\t\t\t\tupdate=true;\n\t\t\t\t\tans+=2;\n\t\t\t\t\ts[x[i][0]][y[i][0]]='.';\n\t\t\t\t\ts[x[i][1]][y[i][1]]='.';\n\t\t\t\t}\n\t\t\t}else if(y[i][0]==y[i][1]){\n\t\t\t\tif(x[i][0]>x[i][1]) swap(x[i][0],x[i][1]);\n\t\t\t\tif(x[i][0]+1==x[i][1]) continue;\n\t\t\t\tbool ok=true;\n\t\t\t\tfor(int xi=x[i][0]+1;xi<x[i][1];xi++) if(s[xi][y[i][0]]!='.') ok=false;\n\t\t\t\tif(ok){\n\t\t\t\t\tupdate=true;\n\t\t\t\t\tans+=2;\n\t\t\t\t\ts[x[i][0]][y[i][0]]='.';\n\t\t\t\t\ts[x[i][1]][y[i][1]]='.';\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tint xi=x[i][0],yi=y[i][1];\n\t\t\t\tbool ok=true;\n\t\t\t\tfor(;xi!=x[i][1];xi+=sgn(x[i][0]-x[i][1])) if(s[xi][yi]!='.') ok=false;\n\t\t\t\txi=x[i][0];\n\t\t\t\tfor(;yi!=y[i][0];yi+=sgn(y[i][1]-y[i][0])) if(s[xi][yi]!='.') ok=false;\n\t\t\t\tif(ok){\n\t\t\t\t\tupdate=true;\n\t\t\t\t\tans+=2;\n\t\t\t\t\ts[x[i][0]][y[i][0]]='.';\n\t\t\t\t\ts[x[i][1]][y[i][1]]='.';\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tswap(x[i][0],x[i][1]);\n\t\t\t\tswap(y[i][0],y[i][1]);\n\t\t\t\tok=true;\n\t\t\t\tfor(;xi!=x[i][1];xi+=sgn(x[i][0]-x[i][1])) if(s[xi][yi]!='.') ok=false;\n\t\t\t\txi=x[i][0];\n\t\t\t\tfor(;yi!=y[i][0];yi+=sgn(y[i][1]-y[i][0])) if(s[xi][yi]!='.') ok=false;\n\t\t\t\tif(ok){\n\t\t\t\t\tupdate=true;\n\t\t\t\t\tans+=2;\n\t\t\t\t\ts[x[i][0]][y[i][0]]='.';\n\t\t\t\t\ts[x[i][1]][y[i][1]]='.';\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint m,n;\nvector<P> data[30];\nvector<int> xindex;\nvector<int> yindex;\nint fie[180][180];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint pick[4];\nint pickx[4];\nint picky[4];\n\nint main(void){\n\tscanf(\"%d %d\",&n,&m);\n\tfor(int i=0;i<n;i++){\n\t\tstring str;\n\t\tcin >> str;\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(str[j]>='A' && str[j]<='Z'){\n\t\t\t\tdata[str[j]-'A'+1].push_back(P(j,i));\n\t\t\t\tif(j-1>=0)xindex.push_back(j-1);\n\t\t\t\txindex.push_back(j);\n\t\t\t\tif(j+1<m)xindex.push_back(j+1);\n\t\t\t\tif(i-1>=0)yindex.push_back(i-1);\n\t\t\t\tyindex.push_back(i);\n\t\t\t\tif(i+1<n)yindex.push_back(i+1);\n\t\t\t}\n\t\t}\n\t}\n\tsort(xindex.begin(),xindex.end());\n\txindex.erase(unique(xindex.begin(),xindex.end()),xindex.end());\n\tsort(yindex.begin(),yindex.end());\n\tyindex.erase(unique(yindex.begin(),yindex.end()),yindex.end());\n\tfor(int i=1;i<=26;i++){\n\t\tfor(int j=0;j<data[i].size();j++){\n\t\t\tdata[i][j].first=lower_bound(xindex.begin(),xindex.end(),data[i][j].first)-xindex.begin();\n\t\t\tdata[i][j].second=lower_bound(yindex.begin(),yindex.end(),data[i][j].second)-yindex.begin();\n\t\t\tfie[data[i][j].first][data[i][j].second]=i;\n\t\t}\n\t}\n\tbool flag=true;\n\tint score=0;\n\twhile(flag){\n\t\tflag=false;\n\t\tfor(int i=0;i<yindex.size();i++){\n\t\t\tfor(int j=0;j<xindex.size();j++){\n\t\t\t\tif(fie[j][i]==0){\n\t\t\t\t\tmemset(pick,0,sizeof(pick));\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tint x=j,y=i;\n\t\t\t\t\t\twhile(x>=0 && x<xindex.size() && y>=0 && y<yindex.size()){\n\t\t\t\t\t\t\tif(fie[x][y]!=0)break;\n\t\t\t\t\t\t\tx+=dx[k];\n\t\t\t\t\t\t\ty+=dy[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(fie[x][y]!=0){\n\t\t\t\t\t\t\tpick[k]=fie[x][y];\n\t\t\t\t\t\t\tpickx[k]=x;\n\t\t\t\t\t\t\tpicky[k]=y;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tfor(int l=k+1;l<4;l++){\n\t\t\t\t\t\t\tif(pick[k]==pick[l] && pick[k]!=0){\n\t\t\t\t\t\t\t\tscore+=2;\n\t\t\t\t\t\t\t\tfie[pickx[k]][picky[k]]=0;\n\t\t\t\t\t\t\t\tfie[pickx[l]][picky[l]]=0;\n\t\t\t\t\t\t\t\tflag=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",score);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <bitset>\n#include <complex>\n#include <unistd.h>\n#include <cassert>\n#include <cctype>\n#include <random>\n#define _USE_MATH_DEFINES\n#define _GLIBCXX_DEBUG\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> plglg;\ntypedef pair<double, ll> pdlg;\ntypedef tuple<int, int, int> tiii;\ntypedef tuple<ll, ll, ll> tlglglg;\ntypedef tuple<double, double, double> tddd;\ntypedef complex<double> xy_t;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\ndouble pi = 3.141592653589793;\nll mod = 1000000007;\nint intmax = 2147483647;\nint intmin = -2147483648;\nll llmax = 9223372036854775807;\nll llmin = -9223372036854775807;\nint iinf = intmax / 8;\nll inf = llmax / 8;\ndouble eps = 1e-11;\n\nbool bo[510][510];\n\nint main() {\n    int M, N;\n    cin >> M >> N;\n    bool res[26];\n    fill(res, res + 26, false);\n    pii pos[26][2];\n    vector<pii> middle[26][2];\n    for (int i = 0; i < M; i++) {\n        string s;\n        cin >> s;\n        for (int j = 0; j < N; j++) {\n            if (s[j] >= 'A' && s[j] <= 'Z') {\n                bo[i][j] = false;\n                int mk = s[j] - 'A';\n                if (!res[mk]) {\n                    pos[mk][0] = pii(i, j);\n                    res[mk] = true;\n                } else {\n                    pos[mk][1] = pii(i, j);\n                }\n            } else {\n                bo[i][j] = true;\n            }\n        }\n    }\n    int mk[26];\n    for (int i = 0; i < 26; i++) {\n        if (res[i]) {\n            pii pf = pos[i][0];\n            pii ps = pos[i][1];\n            if (pf.first == ps.first) {\n                mk[i] = 1;\n                int lo = min(pf.second, ps.second);\n                int hi = max(pf.second, ps.second);\n                int x = pf.first;\n                if (hi - lo > 1) {\n                    for (int j = lo + 1; j < hi; j++) {\n                        if (!bo[x][j]) {\n                            middle[i][0].push_back(pii(x, j));\n                        }\n                    }\n                } else {\n                    res[i] = false;\n                }\n            } else if (pf.second == ps.second) {\n                mk[i] = 1;\n                int lo = min(pf.first, ps.first);\n                int hi = max(pf.first, ps.first);\n                int y = pf.second;\n                if (hi - lo > 1) {\n                    for (int j = lo + 1; j < hi; j++) {\n                        if (!bo[j][y]) {\n                            middle[i][0].push_back(pii(j, y));\n                        }\n                    }\n                } else {\n                    res[i] = false;\n                }\n            } else {\n                mk[i] = 2;\n                if (!bo[pf.first][ps.second]) {\n                    middle[i][0].push_back(pii(pf.first, ps.second));\n                }\n                int lo = min(pf.first, ps.first);\n                int hi = max(pf.first, ps.first);\n                int y = ps.second;\n                for (int j = lo + 1; j < hi; j++) {\n                    if (!bo[j][y]) {\n                        middle[i][0].push_back(pii(j, y));\n                    }\n                }\n                lo = min(pf.second, ps.second);\n                hi = max(pf.second, ps.second);\n                int x = pf.first;\n                for (int j = lo + 1; j < hi; j++) {\n                    if (!bo[x][j]) {\n                        middle[i][0].push_back(pii(x, j));\n                    }\n                }\n                if (!bo[ps.first][pf.second]) {\n                    middle[i][1].push_back(pii(ps.first, pf.second));\n                }\n                lo = min(pf.first, ps.first);\n                hi = max(pf.first, ps.first);\n                y = pf.second;\n                for (int j = lo + 1; j < hi; j++) {\n                    if (!bo[j][y]) {\n                        middle[i][1].push_back(pii(j, y));\n                    }\n                }\n                lo = min(pf.second, ps.second);\n                hi = max(pf.second, ps.second);\n                x = ps.first;\n                for (int j = lo + 1; j < hi; j++) {\n                    if (!bo[x][j]) {\n                        middle[i][1].push_back(pii(x, j));\n                    }\n                }\n            }\n        }\n    }\n    // for (int i = 0; i < M; i++) {\n    //     for (int j = 0; j < N; j++) {\n    //         cout << bo[i][j];\n    //     }\n    //     cout << endl;\n    // }\n    // for (int i = 0; i < 26; i++) {\n    //     cout << res[i] << endl;\n    //     int len1 = middle[i][0].size();\n    //     for (int j = 0; j < len1; j++) {\n    //         cout << middle[i][0][j].first << \"-\" << middle[i][0][j].second << \" \";\n    //     }\n    //     cout << endl;\n    //     int len2 = middle[i][1].size();\n    //     for (int j = 0; j < len2; j++) {\n    //         cout << middle[i][1][j].first << \"-\" << middle[i][1][j].second << \" \";\n    //     }\n    //     cout << endl;\n    // }\n    ll ans = 0;\n    for (int i = 0; i < 26; i++) {\n        for (int j = 0; j < 26; j++) {\n            if (res[j]) {\n                bool ok = false;\n                if (mk[j] == 1) {\n                    if (middle[j][0].size() == 0) {\n                        ok = true;\n                    }\n                } else {\n                    if (middle[j][0].size() == 0 || middle[j][1].size() == 0) {\n                        ok = true;\n                    }\n                }\n                if (ok) {\n                    //cout << j << endl;\n                    ans += 2;\n                    res[j] = false;\n                    pii q = pos[j][0];\n                    pii qq = pos[j][1];\n                    bo[q.first][q.second] = true;\n                    bo[qq.first][qq.second] = true;\n                    for (int l = 0; l < 26; l++) {\n                        if (res[l]) {\n                            int len2a = middle[l][0].size();\n                            for (int m = 0; m < len2a; m++) {\n                                //cout << m << endl;\n                                if (middle[l][0][m] == q || middle[l][0][m] == qq) {\n                                    middle[l][0].erase(middle[l][0].begin() + m);\n                                    m--;\n                                    len2a--;\n                                }\n                            }\n                            int len2b = middle[l][1].size();\n                            for (int m = 0; m < len2b; m++) {\n                                if (middle[l][1][m] == q || middle[l][1][m] == qq) {\n                                    middle[l][1].erase(middle[l][1].begin() + m);\n                                    m--;\n                                    len2b--;\n                                }\n                            }\n                        }\n                    }\n                    break;\n                }\n            }\n        }\n    }\n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint m,n;\nvector<P> data[30];\nvector<int> xindex;\nvector<int> yindex;\nint field[250][250];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint pickl[4];\nint picklx[4];\nint pickly[4];\n\nint main(void){\n\tscanf(\"%d %d\",&n,&m);\n\tmemset(field,0,sizeof(field));\n\tfor(int i=0;i<n;i++){\n\t\tstring str;\n\t\tcin >> str;\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(str[j]>='A' && str[j]<='Z'){\n\t\t\t\tdata[str[j]-'A'+1].push_back(P(j,i));\n\t\t\t\tif(j-1>=0)xindex.push_back(j-1);\n\t\t\t\txindex.push_back(j);\n\t\t\t\tif(j+1<m)xindex.push_back(j+1);\n\t\t\t\tif(i-1>=0)yindex.push_back(i-1);\n\t\t\t\tyindex.push_back(i);\n\t\t\t\tif(i+1<n)yindex.push_back(i+1);\n\t\t\t}\n\t\t}\n\t}\n\tsort(xindex.begin(),xindex.end());\n\txindex.erase(unique(xindex.begin(),xindex.end()),xindex.end());\n\tsort(yindex.begin(),yindex.end());\n\tyindex.erase(unique(yindex.begin(),yindex.end()),yindex.end());\n\tfor(int i=1;i<=26;i++){\n\t\tfor(int j=0;j<data[i].size();j++){\n\t\t\tdata[i][j].first=lower_bound(xindex.begin(),xindex.end(),data[i][j].first)-xindex.begin();\n\t\t\tdata[i][j].second=lower_bound(yindex.begin(),yindex.end(),data[i][j].second)-yindex.begin();\n\t\t\tfield[data[i][j].first][data[i][j].second]=i;\n\t\t}\n\t}\n\tbool flag=true;\n\tint score=0;\n\twhile(flag){\n\t\tflag=false;\n\t\tfor(int i=0;i<yindex.size();i++){\n\t\t\tfor(int j=0;j<xindex.size();j++){\n\t\t\t\tif(field[j][i]==0){\n\t\t\t\t\tmemset(pickl,0,sizeof(pickl));\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tint xx=j,yy=i;\n\t\t\t\t\t\tint xi=xindex.size(),yi=yindex.size();\n\t\t\t\t\t\twhile(xx>=0 && xx<xi && yy>=0 && yy<yi){\n\t\t\t\t\t\t\tif(field[xx][yy]!=0)break;\n\t\t\t\t\t\t\txx+=dx[k];\n\t\t\t\t\t\t\tyy+=dy[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(field[xx][yy]!=0){\n\t\t\t\t\t\t\tpickl[k]=field[xx][yy];\n\t\t\t\t\t\t\tpicklx[k]=xx;\n\t\t\t\t\t\t\tpickly[k]=yy;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tfor(int l=k+1;l<4;l++){\n\t\t\t\t\t\t\tif(pickl[k]==pickl[l] && pickl[k]!=0){\n\t\t\t\t\t\t\t\tscore+=2;\n\t\t\t\t\t\t\t\tfield[picklx[k]][pickly[k]]=0;\n\t\t\t\t\t\t\t\tfield[picklx[l]][pickly[l]]=0;\n\t\t\t\t\t\t\t\tflag=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",score);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 500;\n\ntypedef pair<int, int> Point;\n\nchar data[N][N];\nint h, w;\nqueue<Point> point;\nint dy[] = {-1, 0, 1, 0};\nint dx[] = {0, 1, 0, -1};\n\nbool check(Point p){\n  if(p.first < 0 || p.first >= h) return false;\n  if(p.second < 0 || p.second >= w) return false;\n  return true;\n}\n\nmain(){\n  cin >> h >> w;\n  for(int i=0;i<h;++i){\n    for(int j=0;j<w;++j){\n      cin >> data[i][j];\n      if(data[i][j] == '.'){\n        point.push(Point(i, j));\n      }\n    }\n  }\n  int ans = 0;\n  while(!point.empty()){\n    Point n = point.front();\n    point.pop();\n    bool f = false;\n    char c[4];\n    Point p[4];\n    for(int i=0;i<4;++i) c[i] = i;\n    for(int i=0;i<4;++i){\n      Point tmp = n;\n      while(check(tmp)){\n        if(data[tmp.first][tmp.second] != '.'){\n          c[i] = data[tmp.first][tmp.second];\n          p[i] = tmp;\n          break;\n        }\n        tmp.first += dy[i];\n        tmp.second += dx[i];\n      }\n    }\n    for(int i=0;i<4;++i){\n      for(int j=i+1;j<4;++j){\n        if(c[i] == c[j]){\n          f = true;\n          ans += 2;\n          data[p[i].first][p[i].second] = '.';\n          data[p[j].first][p[j].second] = '.';\n          point.push(p[i]);\n          point.push(p[j]);\n        }\n      }\n    }\n    if(f) point.push(n);\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\n\nint h,w;\nstring s[600];\nint dy[]={0,1,0,-1};\nint dx[]={1,0,-1,0};\nint sum=0;\n\nbool ng[555][555];\n\nvoid knock(int Y,int X){\n  \n  map<char,vector<P> >M;\n  r(i,4){\n    int y=Y;\n    int x=X;\n\n    while(!isalpha(s[y][x])){\n      y+=dy[i];\n      x+=dx[i];\n      if(y<0||x<0||y>=h||x>=w)break;\n    }\n\n    if(y<0||x<0||y>=h||x>=w)continue;\n    M[s[y][x]].push_back(P(y,x));\n  }\n\n  int TX=0;\n\n  for(auto &e:M){\n    if(e.second.size()!=2)continue;\n    sum+=2;\n    s[e.second[0].first][e.second[0].second] = '.';\n    s[e.second[1].first][e.second[1].second] = '.';\n    TX++;\n  }\n\n  if(!TX)ng[Y][X]=1;\n\n}\n\nsigned main(){\n  cin>>h>>w;\n  r(i,h)cin>>s[i];\n\n  r(tim,26)r(i,h)r(j,w)if(!isalpha(s[i][j])&&!ng[i][j]){\n    knock(i,j);\n  }\n\n  cout<<sum<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\ntemplate<class T> constexpr bool in_range(T y, T x, T H, T W) { return 0<=y&&y<H&&0<=x&&x<W; }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,-1,0,1};\n\nint H, W;\n\nvoid solve(vector<string>& G) {\n\n  int res = 0;\n\n  while(1) {\n    bool ok = 0;\n    rep(i, H) rep(j, W) {\n      if(G[i][j] == '.') {\n        map<char, vector<pair<int, int>>> mp;\n        rep(k, 4) {\n          int y = i, x = j;\n          while(1) {\n            y += dy[k], x += dx[k]; if(!in_range(y, x, H, W)) break;\n            if(G[y][x] != '.') {\n              mp[G[y][x]].emplace_back(y, x);\n              break;\n            }\n          }\n        }\n\n        for(auto && e: mp) {\n          if(e.second.size() > 1) {\n            G[e.second[0].first][e.second[0].second] = '.';\n            G[e.second[1].first][e.second[1].second] = '.';\n            res += 2;\n            ok = 1;\n          }\n        }\n      }\n    }\n    if(!ok) break;\n  }\n  cout << res << endl;\n}\n\nint main() {\n\n  cin >> H >> W;\n  vector<string> G(H);\n  rep(i, H) cin >> G[i];\n\n  rep(i, H) rep(j, W) {\n    rep(k, 2) {\n      if(!in_range(i - dy[k], j - dy[k], H, W)) continue;\n      if(!in_range(i + dy[k], j + dy[k], H, W)) continue;\n      if(isalpha(G[i - dy[k]][j - dx[k]]) && G[i - dy[k]][j - dy[k]] == G[i + dy[k]][j + dy[k]] && G[i][j] == '.') {\n        G[i][j] = '-';\n      }\n    }\n  }\n\n  int k = 0;\n  rep(i, H) {\n    if(G[i] != string(W, '.'))\n      G[k++] = G[i];\n  }\n  H = k;\n\n  string T[501]; rep(i, W) T[i].resize(H);\n  rep(i, W) rep(j, H) {\n    T[i][j] = G[j][i];\n  }\n\n  k = 0;\n  rep(i, W) {\n    if(T[i] != string(H, '.'))\n      T[k++] = T[i];\n  }\n\n  W = k;\n\n  G.clear(); G.resize(H); rep(i, H) G[i] = string(W, '.');\n\n  rep(i, H) rep(j, W)\n    G[i][j] = T[j][i] == '-' ? '.' : T[j][i];\n\n  solve(G);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint di[] = {1, 0, -1, 0};\nint dj[] = {0, -1, 0, 1};\n\nstruct info{\n\n    int i;\n    int j;\n    char color;\n    info(){}\n    info(int i, int j, char c):i(i),j(j),color(c){}\n};\n\nint main(){\n\n    int h, w; cin >> h >> w;\n    vector<vector<char> > a(h, vector<char> (w, '.'));\n    \n    for(int i = 0; i < h; i++){\n        for(int j = 0; j < w; j++){\n            cin >> a[i][j];\n        }\n    }\n\n    int ans = 0;\n\n    while(1){\n        bool flag = false;\n\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                if(a[i][j] != '.') continue;\n\n                //cout << i << \" \" << j << endl;\n\n                vector<info> tyakumoku;\n                for(int ii = i + 1; ii < h; ii++){\n                    if(a[ii][j] != '.'){\n                        tyakumoku.push_back(info(ii, j, a[ii][j]));\n                        break;\n                    }\n                }\n                for(int ii = i - 1; ii >= 0; ii--){\n                    if(a[ii][j] != '.'){\n                        tyakumoku.push_back(info(ii, j, a[ii][j]));\n                        break;\n                    }\n                }\n                for(int jj = j + 1; jj < w; jj++){\n                    if(a[i][jj] != '.'){\n                        tyakumoku.push_back(info(i, jj, a[i][jj]));\n                        break;\n                    }\n                }\n                for(int jj = j - 1; jj >= 0; jj--){\n                    if(a[i][jj] != '.'){\n                        tyakumoku.push_back(info(i, jj, a[i][jj]));\n                        break;\n                    }\n                }\n\n                int T = (int)tyakumoku.size();\n                //cout << i << \" \" << j << endl;\n                //for(int l = 0; l > T; l++) cout << tyakumoku[l].i << \" \" << tyakumoku[l].j << \" \" << tyakumoku[l].color << endl;\n                //cout << endl;\n\n                //cout << T << endl;\n\n                //cout << \"ho\" << endl;\n                for(int ii = 0; ii < T; ii++){\n                    for(int jj = ii + 1; jj < T; jj++){\n                        \n                        if(tyakumoku[ii].color == tyakumoku[jj].color){\n                            //cout << i << \" \" << j << endl;\n                            //cout << tyakumoku[ii].i << \" \" << tyakumoku[ii].j << \" \" << tyakumoku[ii].color << endl;\n                            //cout << tyakumoku[jj].i << \" \" << tyakumoku[jj].j << \" \" << tyakumoku[jj].color << endl;\n                            //cout << \"ok\" << ii << \" \" << jj << endl;\n                            //cout << \"ok\" << endl;\n                            ans += 2;\n                            flag = true;\n                            a[tyakumoku[ii].i][tyakumoku[ii].j] = '.';\n                            a[tyakumoku[jj].i][tyakumoku[jj].j] = '.';\n                            \n                        }\n                    }\n                }\n\n                //cout << \"hoga\" << endl;\n            }\n        }\n\n        \n        //cout << endl;\n        //cout << ans << endl;\n        /*for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                cout << a[i][j] << \" \";\n            }\n            cout << endl;\n        }*/\n        \n\n        if(!flag) break;\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\nusing namespace std;\n\nint M, N;\nchar S[550][550];\nvector<int> Y[256], X[256];\nbool E[256][256];\nbool b[256];\n\nvoid dfs(int v) {\n  if(!b[v]) return;\n  b[v] = false;\n  REP(i, 'A', 'Z' + 1) if(E[v][i]) dfs(i);\n}\n\nint main(void) {\n  cin >> M >> N;\n  REP(i, 0, M) cin >> S[i];\n\n  REP(i, 0, M) REP(j, 0, N) if(S[i][j] != '.') {\n    Y[S[i][j]].push_back(i);\n    X[S[i][j]].push_back(j);\n  }\n\n  REP(i, 0, 256) REP(j, 0, 256) E[i][j] = false;\n\n  REP(i, 'A', 'Z' + 1) {\n    if(Y[i].size() == 0) continue;\n    int x1 = X[i][0], x2 = X[i][1];\n    int y1 = Y[i][0], y2 = Y[i][1];\n    if(x1 == x2) {\n      REP(j, min(y1, y2) + 1, max(y1, y2)) {\n        if(S[y1][j] != '.') E[i][S[j][x1]] = true;\n      }\n    } else if(y1 == y2) {\n      REP(j, min(x1, x2) + 1, max(x1, x2)) {\n        if(S[j][x1] != '.') E[i][S[y1][j]] = true;\n      }\n    } else {\n      if(S[y1][x2] != '.' && S[y1][x2] == S[y2][x1]) E[i][S[y1][x2]] = true;\n    }\n  }\n\n  vector<int> fi;\n  REP(i, 'A', 'Z' + 1) {\n    if(Y[i].size() == 0) continue;\n    int x1 = X[i][0], x2 = X[i][1];\n    int y1 = Y[i][0], y2 = Y[i][1];\n    if(x1 == x2 && abs(y1 - y2) == 1) fi.push_back(i);\n    if(y1 == y2 && abs(x1 - x2) == 1) fi.push_back(i);\n  }\n  REP(i, 'A', 'Z' + 1) REP(j, i + 1, 'Z' + 1) if(i != j) {\n    if(E[i][j] && E[j][i]) {\n      fi.push_back(i);\n      fi.push_back(j);\n    }\n  }\n\n  REP(i, 'A', 'Z' + 1) if(Y[i].size() > 0) b[i] = true;\n  REP(i, 0, fi.size()) dfs(fi[i]);\n\n  int ans = 0;\n  REP(i, 'A', 'Z' + 1) if(b[i]) ans += 2;\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint m,n;\nvector<P> data[30];\nvector<int> xindex;\nvector<int> yindex;\nint field[180][180];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint pickl[4];\nint picklx[4];\nint pickly[4];\n\nint main(void){\n\tscanf(\"%d %d\",&n,&m);\n\tfor(int i=0;i<n;i++){\n\t\tstring str;\n\t\tcin >> str;\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(str[j]>='A' && str[j]<='Z'){\n\t\t\t\tdata[str[j]-'A'+1].push_back(P(j,i));\n\t\t\t\tif(j-1>=0)xindex.push_back(j-1);\n\t\t\t\txindex.push_back(j);\n\t\t\t\tif(j+1<m)xindex.push_back(j+1);\n\t\t\t\tif(i-1>=0)yindex.push_back(i-1);\n\t\t\t\tyindex.push_back(i);\n\t\t\t\tif(i+1<n)yindex.push_back(i+1);\n\t\t\t}\n\t\t}\n\t}\n\tsort(xindex.begin(),xindex.end());\n\txindex.erase(unique(xindex.begin(),xindex.end()),xindex.end());\n\tsort(yindex.begin(),yindex.end());\n\tyindex.erase(unique(yindex.begin(),yindex.end()),yindex.end());\n\tfor(int i=1;i<=26;i++){\n\t\tfor(int j=0;j<data[i].size();j++){\n\t\t\tdata[i][j].first=lower_bound(xindex.begin(),xindex.end(),data[i][j].first)-xindex.begin();\n\t\t\tdata[i][j].second=lower_bound(yindex.begin(),yindex.end(),data[i][j].second)-yindex.begin();\n\t\t\tfield[data[i][j].first][data[i][j].second]=i;\n\t\t}\n\t}\n\tbool flag=true;\n\tint score=0;\n\twhile(flag){\n\t\tflag=false;\n\t\tfor(int i=0;i<yindex.size();i++){\n\t\t\tfor(int j=0;j<xindex.size();j++){\n\t\t\t\tif(field[j][i]==0){\n\t\t\t\t\tmemset(pickl,0,sizeof(pickl));\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tint xx=j,yy=i;\n\t\t\t\t\t\tint xi=xindex.size(),yi=yindex.size();\n\t\t\t\t\t\twhile(xx>=0 && xx<xi && yy>=0 && yy<yi){\n\t\t\t\t\t\t\tif(field[xx][yy]!=0)break;\n\t\t\t\t\t\t\txx+=dx[k];\n\t\t\t\t\t\t\tyy+=dy[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(field[xx][yy]!=0){\n\t\t\t\t\t\t\tpickl[k]=field[xx][yy];\n\t\t\t\t\t\t\tpicklx[k]=xx;\n\t\t\t\t\t\t\tpickly[k]=yy;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tfor(int l=k+1;l<4;l++){\n\t\t\t\t\t\t\tif(pickl[k]==pickl[l] && pickl[k]!=0){\n\t\t\t\t\t\t\t\tscore+=2;\n\t\t\t\t\t\t\t\tfield[picklx[k]][pickly[k]]=0;\n\t\t\t\t\t\t\t\tfield[picklx[l]][pickly[l]]=0;\n\t\t\t\t\t\t\t\tflag=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",score);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define x first\n#define y second\nusing namespace std;\ntypedef pair <int,int> P;\nstring mp[501];\nint m,n,used[30],ans;\nvector <P>  a[30];\n\nint saiki(int);\n\nbool check(int c,int s,int t,int f){\n  int res=1;\n  for(int i=s+1;i<t;i++){\n    if(!f&&mp[i][c]!='.'&&!saiki(mp[i][c]-'A'))res=0;\n    if(f&&mp[c][i]!='.'&&!saiki(mp[c][i]-'A'))res=0;\n  }\n  return res;\n}\n\nint saiki(int ch){\n  int x1=a[ch][0].x,x2=a[ch][1].x;\n  int y1=a[ch][0].y,y2=a[ch][1].y;\n  int res=0;\n  if(used[ch])return 0;\n  used[ch]=1;\n  \n  if(x1==x2&&y2-y1!=1) res=check(x1,y1,y2,0);\n  if(y1==y2&&x2-x1!=1) res=check(y1,x1,x2,1);\n  \n  if(x1!=x2&&y1!=y2) {\n    if(x1<x2){\n      res=check(y1,x1,x2+1,1)&check(x2,y1,y2,0);\n      res|=check(x1,y1,y2+1,0)&check(y2,x1,x2,1);\n    }\n    else{\n      swap(x1,x2);\n      res=check(y1,x1-1,x2,1)&check(x1,y1,y2,0);\n      res|= check(x2,y1,y2,0)&check(y2,x1,x2+1,1);\n      swap(x1,x2);\n    }\n  }\n  \n  if(res) {\n    mp[y1][x1]=mp[y2][x2]='.';\n    a[ch].clear();\n    ans+=2;\n  }\n  return res;\n}\n\nint main(){\n  \n  cin>>m>>n;\n  for(int i=0;i<m;i++)cin>>mp[i];\n  \n  for(int i=0;i<m;i++)\n    for(int j=0;j<n;j++)\n      if(mp[i][j]!='.')a[mp[i][j]-'A'].push_back(P(j,i));\n  \n \n  int f=1;\n  while(f--) \n    for(int i=0;i<30;i++){\n      memset(used,0,sizeof(used));\n      if(a[i].size()) f|=saiki(i);\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n, m;\nchar brd[500][500];\nint cnt = 0;\nvector<P> v[30];\n\nint main(){\n\tcin >> n >> m;\n\trep(i,n) rep(j,m){\n\t\tcin >> brd[i][j];\n\t\tif(brd[i][j] != '.') v[brd[i][j]-'A'].push_back(P(i,j));\n\t}\n\twhile(true){\n\t\tbool end = true;\n\t\trep(i,30){\n\t\t\tif(v[i].size() == 0) continue;\n\t\t\tbool ok1 = true, ok2 = true;\n\t\t\tint xx1 = v[i][0].first,yy1 = v[i][0].second;\n\t\t\tint xx2 = v[i][1].first,yy2 = v[i][1].second;\n\t\t\tint x1 = xx1, y1 = yy1, x2 = xx2, y2 = yy2;\n\t\t\tif(x1 > x2){\n\t\t\t\tswap(x1,x2);\n\t\t\t\tswap(y1,y2);\n\t\t\t}\n\t\t\tif(abs(x2-x1)+abs(y2-y1) == 1) continue;\n\t\t\tif(y1 < y2){\n\t\t\t\tfor(int j = x1; j <= x2; j++){\n\t\t\t\t\tif(brd[j][y1]!='.'&&brd[j][y1]-'A'!=i) ok1 = false;\n\t\t\t\t\tif(brd[j][y2]!='.'&&brd[j][y2]-'A'!=i) ok2 = false;\n\t\t\t\t}\n\t\t\t\tfor(int j = y1; j <= y2; j++){\n\t\t\t\t\tif(brd[x1][j]!='.'&&brd[x1][j]-'A'!=i) ok2 = false;\n\t\t\t\t\tif(brd[x2][j]!='.'&&brd[x2][j]-'A'!=i) ok1 = false;\n\t\t\t\t}\n\t\t\t\tif(ok1 == false && ok2 == false) continue;\n\t\t\t\tcnt += 2;\n\t\t\t\tbrd[xx1][yy1] = '.'; brd[xx2][yy2] = '.';\n\t\t\t\tend = false;\n\t\t\t\tv[i].clear();\n\t\t\t} else{\n\t\t\t\tfor(int j = x1; j <= x2; j++){\n\t\t\t\t\tif(brd[j][y1]!='.'&&brd[j][y1]-'A'!=i) ok1 = false;\n\t\t\t\t\tif(brd[j][y2]!='.'&&brd[j][y2]-'A'!=i) ok2 = false;\n\t\t\t\t}\n\t\t\t\tfor(int j = y1; j <= y2; j++){\n\t\t\t\t\tif(brd[x1][j]!='.'&&brd[x1][j]-'A'!=i) ok1 = false;\n\t\t\t\t\tif(brd[x2][j]!='.'&&brd[x2][j]-'A'!=i) ok2 = false;\n\t\t\t\t}\n\t\t\t\tif(ok1 == false && ok2 == false) continue;\n\t\t\t\tcnt += 2;\n\t\t\t\tbrd[xx1][yy1] = '.'; brd[xx2][yy2] = '.';\n\t\t\t\tend = false;\n\t\t\t\tv[i].clear();\n\t\t\t}\n\t\t}\n\t\tif(end) break;\n\t}\n\tcout << cnt << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define x first\n#define y second\nusing namespace std;\ntypedef pair <int,int> P;\nstring mp[501];\nint m,n,used[30];\nvector <P>  a[30];\n\nint saiki(int);\n\nbool check_x(int y,int x1,int x2){\n  for(int i=x1+1;i<x2;i++)\n    if(mp[y][i]!='.'&&!saiki(mp[y][i]-'A'))return 0;\n  return 1;\n}\n\nbool check_y(int y1,int y2,int x){\n  for(int i=y1+1;i<y2;i++)\n    if(mp[i][x]!='.'&&!saiki(mp[i][x]-'A')) return 0;\n  return 1;\n}\n\n\nint saiki(int ch){  \n  if(ch<0) return 0;\n  int x1=a[ch][0].x,x2=a[ch][1].x;\n  int y1=a[ch][0].y,y2=a[ch][1].y;\n  int res=0;\n  if(used[ch]||mp[y1][x1]=='.')return 0;\n  used[ch]=1;\n  \n  if(x1==x2&&y2-y1!=1) res=check_y(y1,y2,x1);\n  if(y1==y2&&x2-x1!=1) res=check_x(y1,x1,x2);\n  if(x1!=x2&&y1!=y2) {\n    if(x1<x2){\n      res=check_x(y1,x1,x2+1)&check_y(y1,y2,x2);\n      res|=check_y(y1,y2+1,x1)&check_x(y2,x1,x2);\n    }\n    else{\n      swap(x1,x2);\n      res=check_x(y1,x1-1,x2)&check_y(y1,y2,x1);\n      res |=check_y(y1,y2,x2)&check_x(y2,x1,x2+1);\n      swap(x1,x2);\n    }\n  }\n    \n\n  if(res) mp[y1][x1]=mp[y2][x2]='.';\n  used[ch]=0;\n  return res;\n}\n\nint main(){\n\n  cin>>m>>n;\n  for(int i=0;i<m;i++)cin>>mp[i];\n\n  int ans=0;\n  for(int i=0;i<m;i++)\n    for(int j=0;j<n;j++)\n      if(mp[i][j]!='.')a[mp[i][j]-'A'].push_back(P(j,i)),ans++;\n  \n  int flg=1;\n  while(flg){\n    flg=0;\n    for(int i=0;i<30;i++)if(a[i].size() && saiki(i)) a[i].clear(),flg=1;\n  }\n\n  for(int i=0;i<m;i++)\n    for(int j=0;j<n;j++) if(mp[i][j]!='.') ans--;\n\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nusing namespace std;\nint main(void)\n{\n  int m,n;\n  cin >> m >> n;\n  vector<string> fi(m);\n  REP(i,m) cin >> fi[i];\n  int answer=0;\n  REP(i,m) REP(j,n) if(fi[i][j]=='.') --answer;\n  vector<bool> exi(m,false),exj(n,false);\n  REP(i,m) REP(j,n) if(fi[i][j]!='.'){\n    exi[i]=true;\n    exj[j]=true;\n  }\n  bool flag=true;\n  while(flag){\n    REP(i,m){\n      REP(j,n){\n\tif(!exi[i]&&!exj[j]) continue;\n\tif(fi[i][j]!='.') continue;\n\tvector<int> x,y;\n\tfor(int k=i-1;k>=0;--k){\n\t  if(fi[k][j]!='.'){\n\t    x.push_back(k);\n\t    y.push_back(j);\n\t    break;\n\t  }\n\t}\n\tfor(int k=i+1;k<m;++k){\n\t  if(fi[k][j]!='.'){\n\t    x.push_back(k);\n\t    y.push_back(j);\n\t    break;\n\t  }\n\t}\n\tfor(int k=j-1;k>=0;--k){\n\t  if(fi[i][k]!='.'){\n\t    x.push_back(i);\n\t    y.push_back(k);\n\t    break;\n\t  }\n\t}\n\tfor(int k=j+1;k<n;++k){\n\t  if(fi[i][k]!='.'){\n\t    x.push_back(i);\n\t    y.push_back(k);\n\t    break;\n\t  }\n\t}\n\tREP(k,x.size()) REP(l,k){\n\t  if(fi[x[k]][y[k]]==fi[x[l]][y[l]]){\n\t    fi[x[k]][y[k]]='.';\n\t    fi[x[l]][y[l]]='.';\n\t    flag=true;\n\t  }\n\t}\n      }\n    }\n  }\n  REP(i,m) REP(j,n) if(fi[i][j]=='.') ++answer;\n  cout << answer << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint m,n;\nvector<P> data[30];\nvector<int> xindex;\nvector<int> yindex;\nint fie[60][60];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint pick[4];\nint pickx[4];\nint picky[4];\n\nint main(void){\n\tscanf(\"%d %d\",&n,&m);\n\tfor(int i=0;i<n;i++){\n\t\tstring str;\n\t\tcin >> str;\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(str[j]>='A' && str[j]<='Z'){\n\t\t\t\tdata[str[j]-'A'+1].push_back(P(j,i));\n\t\t\t\txindex.push_back(j);\n\t\t\t\tyindex.push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tsort(xindex.begin(),xindex.end());\n\txindex.erase(unique(xindex.begin(),xindex.end()),xindex.end());\n\tyindex.erase(unique(yindex.begin(),yindex.end()),yindex.end());\n\tfor(int i=1;i<=26;i++){\n\t\tfor(int j=0;j<data[i].size();j++){\n\t\t\tdata[i][j].first=lower_bound(xindex.begin(),xindex.end(),data[i][j].first)-xindex.begin();\n\t\t\tdata[i][j].second=lower_bound(yindex.begin(),yindex.end(),data[i][j].second)-yindex.begin();\n\t\t\tfie[data[i][j].first][data[i][j].second]=i;\n\t\t}\n\t}\n\tbool flag=true;\n\tint score=0;\n\twhile(flag){\n\t\tflag=false;\n\t\tfor(int i=0;i<yindex.size();i++){\n\t\t\tfor(int j=0;j<xindex.size();j++){\n\t\t\t\tif(fie[j][i]==0){\n\t\t\t\t\tmemset(pick,0,sizeof(pick));\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tint x=j,y=i;\n\t\t\t\t\t\twhile((x>=0 && x<xindex.size() && y>=0 && y<yindex.size()) && fie[x][y]==0){\n\t\t\t\t\t\t\tx+=dx[k];\n\t\t\t\t\t\t\ty+=dy[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(fie[x][y]!=0){\n\t\t\t\t\t\t\tpick[k]=fie[x][y];\n\t\t\t\t\t\t\tpickx[k]=x;\n\t\t\t\t\t\t\tpicky[k]=y;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tfor(int l=k+1;l<4;l++){\n\t\t\t\t\t\t\tif(pick[k]==pick[l] && pick[k]!=0 && pick[l]!=0){\n\t\t\t\t\t\t\t\tscore+=2;\n\t\t\t\t\t\t\t\tfie[pickx[k]][picky[k]]=0;\n\t\t\t\t\t\t\t\tfie[pickx[l]][picky[l]]=0;\n\t\t\t\t\t\t\t\tpick[k]=0;\n\t\t\t\t\t\t\t\tpick[l]=0;\n\t\t\t\t\t\t\t\tflag=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",score);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n, m;\nchar brd[500][500];\nint cnt = 0;\nvector<P> v[30];\n\nint main(){\n\tcin >> n >> m;\n\trep(i,n) rep(j,m){\n\t\tcin >> brd[i][j];\n\t\tif(brd[i][j] != '.') v[brd[i][j]-'A'].push_back(P(i,j));\n\t}\n\twhile(true){\n\t\tbool end = true;\n\t\trep(i,30){\n\t\t\tif(v[i].size() == 0) continue;\n\t\t\tbool ok1 = true, ok2 = true;\n\t\t\tint xx1 = v[i][0].first,yy1 = v[i][0].second;\n\t\t\tint xx2 = v[i][1].first,yy2 = v[i][1].second;\n\t\t\tint x1 = xx1, y1 = yy1, x2 = xx2, y2 = yy2;\n\t\t\tif(x1 > x2){\n\t\t\t\tswap(x1,x2);\n\t\t\t\tswap(y1,y2);\n\t\t\t}\n\t\t\tif(abs(x2-x1)+abs(y2-y1) == 1) continue;\n\t\t\tif(y1 < y2){\n\t\t\t\tfor(int j = x1; j <= x2; j++){\n\t\t\t\t\tif(brd[j][y1]!='.'&&brd[j][y1]-'A'!=i) ok1 = false;\n\t\t\t\t\tif(brd[j][y2]!='.'&&brd[j][y2]-'A'!=i) ok2 = false;\n\t\t\t\t}\n\t\t\t\tfor(int j = y1; j <= y2; j++){\n\t\t\t\t\tif(brd[x1][j]!='.'&&brd[x1][j]-'A'!=i) ok2 = false;\n\t\t\t\t\tif(brd[x2][j]!='.'&&brd[x2][j]-'A'!=i) ok1 = false;\n\t\t\t\t}\n\t\t\t\tif(ok1 == false && ok2 == false) continue;\n\t\t\t\tcnt += 2;\n\t\t\t\tbrd[xx1][yy1] = '.'; brd[xx2][yy2] = '.';\n\t\t\t\tend = false;\n\t\t\t\tv[i].clear();\n\t\t\t} else{\n\t\t\t\tfor(int j = x1; j <= x2; j++){\n\t\t\t\t\tif(brd[j][y1]!='.'&&brd[j][y1]-'A'!=i) ok1 = false;\n\t\t\t\t\tif(brd[j][y2]!='.'&&brd[j][y2]-'A'!=i) ok2 = false;\n\t\t\t\t}\n\t\t\t\tfor(int j = y2; j <= y1; j++){\n\t\t\t\t\tif(brd[x1][j]!='.'&&brd[x1][j]-'A'!=i) ok2 = false;\n\t\t\t\t\tif(brd[x2][j]!='.'&&brd[x2][j]-'A'!=i) ok1 = false;\n\t\t\t\t}\n\t\t\t\tif(ok1 == false && ok2 == false) continue;\n\t\t\t\tcnt += 2;\n\t\t\t\tbrd[xx1][yy1] = '.'; brd[xx2][yy2] = '.';\n\t\t\t\tend = false;\n\t\t\t\tv[i].clear();\n\t\t\t}\n\t\t}\n\t\tif(end) break;\n\t}\n\tcout << cnt << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nint m, n;\nchar c[500][500];\nvector<P> v[26];\n\nbool check(P a, P b) {\n    char tmp = c[a.fi][a.se];\n    if (a.fi == b.fi) {\n        if (a.se > b.se) swap(a.se, b.se);\n        repl(i, a.se, b.se + 1) {\n            if (c[a.fi][i] != tmp && c[a.fi][i] != '.') return false;\n        }\n    } else {\n        if (a.fi > b.fi) swap(a.fi, b.fi);\n        repl(i, a.fi, b.fi + 1) {\n            if (c[i][a.se] != tmp && c[i][a.se] != '.') return false;\n        }\n    }\n    return true;\n}\n\nint main(){\n    cin.sync_with_stdio(false);\n    cin >> m >> n;\n    rep(i, m)rep(j, n) {\n        cin >> c[i][j];\n        if (c[i][j] != '.') v[c[i][j] - 'A'].pb(P(i, j));\n    }\n\n    bool rem[26] = {};\n    int cnt = 0;\n    rep(i, 26)rep(j, 26)if (v[j].size() > 0 && !rem[j]) {\n        P tmp = P(v[j][0].fi - v[j][1].fi, v[j][0].se - v[j][1].se);\n        if (abs(tmp.fi) + abs(tmp.se) == 1) {\n            rem[j] = true;\n            continue;\n        }\n        tmp = P(v[j][0].fi, v[j][1].se);\n        if (check(v[j][0], tmp) && check(v[j][1], tmp)) {\n            rem[j] = true;\n            c[v[j][0].fi][v[j][0].se] = '.';\n            c[v[j][1].fi][v[j][1].se] = '.';\n            cnt += 2;\n            continue;\n        }\n        tmp = P(v[j][1].fi, v[j][0].se);\n        if (check(v[j][0], tmp) && check(v[j][1], tmp)) {\n            rem[j] = true;\n            c[v[j][0].fi][v[j][0].se] = '.';\n            c[v[j][1].fi][v[j][1].se] = '.';\n            cnt += 2;\n        }\n    }\n    cout << cnt << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<PII> VPII;\n\n#define Y first\n#define X second\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back \n#define ALL(x) (x).begin(),(x).end()\n#define RANGE(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a) { OSS oss; oss << a; return oss.str(); };\n\nconst int INF = 0x3f3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst int DX[]={1,0,-1,0},DY[]={0,-1,0,1};\n\nint H, W;\nVB as;\nmap<char, VPII> poss;\nVS ts;\n\nbool dire(PII a1, PII a2) {\n\tint dx = a1.X - a2.X;\n\tint dy = a1.Y - a2.Y;\n\n\treturn (dx < 0 && dy < 0) ||\n\t\t   (dx > 0 && dy > 0);\n}\n\nbool can_erase(char c0) {\n\tPII a1 = poss[c0][0];\n\tPII a2 = poss[c0][1];\n\n\tif ((abs(a1.X - a2.X) + abs(a1.Y - a2.Y)) == 1) {\n\t\treturn false;\n\t}\n\n\tint min_x = min(a1.X, a2.X);\n\tint max_x = max(a1.X, a2.X);\n\tint min_y = min(a1.Y, a2.Y);\n\tint max_y = max(a1.Y, a2.Y);\n\tbool rev = dire(a1, a2);\n\n\tfor (int i = 0; i < 2; i++) {\n\t\tbool ans = [&]()->bool{\n\t\t\t{\n\t\t\t\tint y = i ? min_y : max_y;\n\t\t\t\tfor (int x = min_x; x <= max_x; x++) {\n\t\t\t\t\tchar c = ts[y][x];\n\t\t\t\t\tif (c == '.') continue;\n\t\t\t\t\tif (c == c0) continue;\n\t\t\t\t\tif (as[c - 'A']) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t{\n\t\t\t\tint x = (!!i ^ rev) ? min_x : max_x;\n\t\t\t\tfor (int y = min_y; y <= max_y; y++) {\n\t\t\t\t\tchar c = ts[y][x];\n\t\t\t\t\tif (c == '.') continue;\n\t\t\t\t\tif (c == c0) continue;\n\t\t\t\t\tif (as[c - 'A']) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}();\n\n\t\tif (ans) return true;\n\t}\n\n\treturn false;\n}\n\nbool erase(char c) {\n\tif (!as[c - 'A']) return false;\n\tif (!can_erase(c)) return false;\n\tas[c - 'A'] = false;\n\n\treturn true;\n}\n\nint main(void) {\n\tcin >> H >> W;\n\tas.resize(26);\n\tts.resize(H);\n\n\tfor (int y = 0; y < H; y++) {\n\t\tcin >> ts[y];\n\t\tfor (int x = 0; x < W; x++) {\n\t\t\tchar c = ts[y][x];\n\t\t\tif (c == '.') continue;\n\n\t\t\tas[c - 'A'] = true;\n\t\t\tposs[c].EB(y, x);\n\t\t}\n\t}\n\n\t//////\n\n\tint cnt = 0;\n\n\tfor (int ti = 0; ti < 26; ti++) {\n\t\tfor (int i = 0; i < 26; i++) {\n\t\t\tchar c = 'A' + i;\n\t\t\tcnt += (erase(c) ? 2 : 0);\n\t\t}\n\t}\n\n\t////\n\n\tcout << cnt << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cctype>\n#include <vector>\n#include <set>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0 ; i < n ; i++)\n\nstruct Point{\n  int x1, y1, x2, y2;\n};\n\nconst int MAX = 510;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nchar field[MAX][MAX];\nbool found[26];\nPoint alpha[26];\n\nint H, W;\n\nbool canReach_x(char C, int x, int y1, int y2){\n  if(y1 > y2) swap(y1, y2);\n  for(int i = y1 ; i <= y2 ; i++){\n    if(field[i][x] != '.' && field[i][x] != C) return false;\n  }\n  return true;\n}\n\nbool canReach_y(char C, int y, int x1, int x2){\n  if(x1 > x2) swap(x1, x2);\n  for(int j = x1 ; j <= x2 ; j++){\n    if(field[y][j] != '.' && field[y][j] != C) return false;\n  }\n  return true;\n}\n\nbool canReach(char C, int cx, int cy, int x, int y){\n  if(cx == x){\n    if(!canReach_x(C, x, cy, y)) return false;\n  }\n  \n  else if(cx < x){\n    for(int j = x ; j >= cx ; j--){\n      if(field[y][j] != '.' && field[y][j] != C) return false;\n    }\n    //cout << \"x1 \" << endl;\n  }\n  \n  else if(cx > x){\n    for(int j = x ; j <= cx ; j++){\n      if(field[y][j] != '.' && field[y][j] != C) return false;\n    }\n    //cout << \"x2 \" << endl;  \n  }\n\n  if(cy == x){\n    if(!canReach_y(C, y, cx, x)) return false;\n  }\n  \n  else if(cy < y){\n    for(int i = y ; i >= cy ; i--){\n      if(field[i][x] != '.' && field[i][x] != C) return false;\n    }\n    //cout << \"y1 \" << endl;  \n  }\n  else if(cy > y){\n    for(int i = y ; i <= y ; i++){\n      if(field[i][x] != '.' && field[i][x] != C) return false;\n    }\n    //cout << \"y2 \" << endl;  \n  }\n\n  return true;\n}\n\nvoid output(){\n  rep(i, H){\n    rep(j, W){\n      cout << field[i][j];\n    }\n    cout << endl;\n  }\n  cout << endl;\n}\n\n\nint main(){\n  while(cin >> H >> W){\n    rep(i, H) cin >> field[i];\n\n    memset(found, 0, sizeof(found));\n    \n    rep(i, H){\n      rep(j, W){\n\tif(isalpha(field[i][j])){\n\t  int c = field[i][j]-'A';\n\t  if(!found[c]){\n\t    found[c] = true;\n\t    alpha[c].x1 = j, alpha[c].y1 = i;\n\t  }\n\t  else{\n\t    alpha[c].x2 = j, alpha[c].y2 = i;\n\t  }\t\n\t}\n      }\n    }\n    \n    Point cross[26];\n    rep(i, 26){\n      if(found[i]){\n\tcross[i].x1 = alpha[i].x1, cross[i].y1 = alpha[i].y2;\n\tcross[i].x2 = alpha[i].x2, cross[i].y2 = alpha[i].y1;\n      }\n    }\n    \n    int ans = 0;\n    \n    rep(i, H){\n      rep(j, W){\n\trep(k, 4){\n\t  int nx = j+dx[k], ny = i+dy[k];\n\t  if(nx < 0 || nx > W || ny < 0 || ny > H) continue;\n\t  if(field[i][j] == field[ny][nx]) found[field[i][j]-'A'] = false;\n\t}\n      }\n    }\n\t\n    \n    for(; ;){\n      //output();\n      bool flag = false;\n      rep(i, 26){\n\tif(found[i]){\n\t  int x1 = alpha[i].x1, y1 = alpha[i].y1, x2 = alpha[i].x2, y2 = alpha[i].y2;\n\t  \n\t  if(x1 == x2){\n\t    if(canReach_x('A'+i, x1, y1, y2)){\n\t      field[y1][x1] = field[y2][x2] = '.';\n\t      found[i] = false;\n\t      ans += 2;\n\t      flag = true;\n\t    }\n\t  }\n\t  else if(y1 == y2){\n\n\t    if(canReach_y('A'+i, y1, x1, x2)){\n\t      field[y1][x1] = field[y2][x2] = '.';\n\t      found[i] = false;\n\t      ans += 2;\n\t      flag = true;\n\t    }\n\t  }\t      \t    \t  \t  \n\t  else if(((canReach('A'+i, cross[i].x1, cross[i].y1, x1, y1) &&\n\t\t    canReach('A'+i, cross[i].x1, cross[i].y1, x2, y2))) ||\n\t\t  ((canReach('A'+i, cross[i].x2, cross[i].y2, x1, y1) &&\n\t\t    canReach('A'+i, cross[i].x2, cross[i].y2, x2, y2)))){\n\t    \n\t    //cout << \"x1, y1 \" << x1 << ' ' << y1 << \", x2, y2 \" << x2 << ' ' << y2 << endl;\n\t    //cout << canReach('A'+i, cross[i].x1, cross[i].y1, x1, y1) << endl;\n\t    //cout << canReach('A'+i, cross[i].x1, cross[i].y1, x2, y2) << endl;\n\t    //cout << canReach('A'+i, cross[i].x2, cross[i].y2, x2, y2) << endl;\n\t    //cout << canReach('A'+i, cross[i].x2, cross[i].y2, x1, y1) << endl;\n\t    //cout << \"c1 \" << cross[i].x1 << ' ' << cross[i].y1 << endl;\n\t    //cout << \"c2 \" << cross[i].x2 << ' ' << cross[i].y2 << endl;\n\t    \n\t    field[y1][x1] = field[y2][x2] = '.';\n\t    found[i] = false;\n\t    ans += 2;\n\t    flag = true;\n\t  }\n\t}\n      }\n      if(!flag) break;\n    }\n    \n    cout << ans << endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint H, W;\nconst int MAX_W = 500;\n\nchar board[MAX_W][MAX_W + 1];\nbool is_remain[26];\n\nstruct point{\n\tint y, x;\n};\n\nvector<point> ps[26];\n\nint dist(point a, point b){\n\treturn abs(a.y - b.y) + abs(a.x - b.x);\n}\n\nint between(int a, int b, int x){\n\treturn min(a, b) <= x && x <= max(a, b);\n}\n\nbool check1(point a, point b, point p){\n\treturn a.x != p.x && !between(a.y, b.y, p.y);\n}\n\nbool check2(point a, point b, point p){\n\treturn a.y != p.y && !between(a.x, b.x, p.x);\n}\n\nbool check3(point a, point b, point p){\n\treturn ( !( a.x == p.x && between(a.y, b.y, p.y) ) )\n\t\t\t&& ( !( b.y == p.y && between(a.x, b.x, p.x) ) );\n}\n\nbool check4(point a, point b, point p){\n\treturn ( !( a.y == p.y && between(a.x, b.x, p.x) ) )\n\t\t\t&& ( !( b.x == p.x && between(a.y, b.y, p.y) ) );\n}\n\n\nint solve(){\n\tint ans = 0;\n\n\tfor(;;){\n\t\tbool update = false;\n\n\t\tfor(int i=0; i<26; i++)if(is_remain[i] && dist(ps[i][0], ps[i][1]) != 1){\n\t\t\tbool ok = false;\n\t\t\tpoint& a = ps[i][0], b = ps[i][1];\n\t\t\t//ツ療アツチツェツッツク\n\t\t\tif(a.x == b.x){\n\t\t\t\tbool ok2 = true;\n\t\t\t\tfor(int j=0; j<26; j++)if(i!=j && is_remain[j]){\n\t\t\t\t\tok2 &= check1(a, b, ps[j][0]);\n\t\t\t\t\tok2 &= check1(a, b, ps[j][1]);\n\t\t\t\t}\n\t\t\t\tok |= ok2;\n\t\t\t}\n\t\t\tif(a.y == b.y){\n\t\t\t\tbool ok2 = true;\n\t\t\t\tfor(int j=0; j<26; j++)if(i!=j && is_remain[j]){\n\t\t\t\t\tok2 &= check2(a, b, ps[j][0]);\n\t\t\t\t\tok2 &= check2(a, b, ps[j][1]);\n\t\t\t\t}\n\t\t\t\tok |= ok2;\n\t\t\t}\n\n\t\t\t//ツ債カツ湘」\n\t\t\t{\n\t\t\t\tbool ok2 = true;\n\t\t\t\tfor(int j=0; j<26; j++)if(i!=j && is_remain[j]){\n\t\t\t\t\tok2 &= check3(a, b, ps[j][0]);\n\t\t\t\t\tok2 &= check3(a, b, ps[j][1]);\n\t\t\t\t}\n\t\t\t\tok |= ok2;\n\t\t\t}\n\t\t\t//ツ右ツ可コ\n\t\t\t{\n\t\t\t\tbool ok2 = true;\n\t\t\t\tfor(int j=0; j<26; j++)if(i!=j && is_remain[j]){\n\t\t\t\t\tok2 &= check4(a, b, ps[j][0]);\n\t\t\t\t\tok2 &= check4(a, b, ps[j][1]);\n\t\t\t\t}\n\t\t\t\tok |= ok2;\n\n\t\t\t}\n\n\t\t\tif(ok){\n\t\t\t\tis_remain[i] = false;\n\t\t\t\tans += 2;\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\n\t\tif(!update){\n\t\t\tbreak;\n\t\t}\n\t}\n\n\n\treturn ans;\n}\n\nint main(){\n\tscanf(\"%d%d\\n\", &H,&W);\n\tfor(int i=0; i<H; i++){\n\t\tscanf(\"%[^\\n]%*c\", board[i]);\n\t}\n\tfor(int i=0; i<H; i++){\n\t\tfor(int j=0; j<W; j++)if(board[i][j] != '.'){\n\t\t\tis_remain[board[i][j] - 'A'] = true;\n\t\t\tps[board[i][j] - 'A'].push_back((point){i, j});\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", solve());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<double,int,double> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nDef inf=sizeof(Def)==sizeof(long long)?2e18:1e9;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint MOD;\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tvs in(n);\n\trep(i,n)cin>>in[i];\n\tint out=0;\n\twhile(1){\n\t\tbool h=false;\n\t\trep(i,n)rep(j,m)if(in[i][j]=='.'){\n\t\t\tvi find(26,-1);\n\t\t\trep(k,4){\n\t\t\t\tint x=i,y=j;\n\t\t\t\twhile(0<=x&&x<n&&0<=y&&y<m&&in[x][y]=='.')x+=dx[k],y+=dy[k];\n\t\t\t\tif(0<=x&&x<n&&0<=y&&y<m){\n\t\t\t\t\tint t=in[x][y]-'A';\n\t\t\t\t\tif(find[t]==-1)find[t]=x*m+y;\n\t\t\t\t\telse{\n\t\t\t\t\t\th=true;\n\t\t\t\t\t\tout+=2;\n\t\t\t\t\t\tin[x][y]='.';\n\t\t\t\t\t\tin[find[t]/m][find[t]%m]='.';\n\t\t\t\t\t\tfind[t]=-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!h)break;\n\t}\n\tcout<<out<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <map>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define LINE() cerr<< \" (L\" << __LINE__ << \")\"\n\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nint main() {\n\t\tint H,W;cin >>H >> W;\n\n\t\tvector<string> board(H);\n\t\tfor(int y=0;y<H;y++){\n\t\t\tcin >> board[y];\n\t\t}\n\n\t\tmap<int,int> xmap,ymap;\n\t\tfor(int y=0;y<H;y++){\n\t\t\tfor(int x=0;x<W;x++){\n\t\t\t\tif(board[y][x]!='.'){\n\t\t\t\t\txmap.insert(make_pair(x,1));\n\t\t\t\t\tif(0<x-1 && x-1 <W)xmap.insert(make_pair(x-1,1));\n\t\t\t\t\tif(0<x+1 && x+1 <W)xmap.insert(make_pair(x+1,1));\n\n\t\t\t\t\tymap.insert(make_pair(y,1));\n\t\t\t\t\tif(0<y-1 && y-1 <H)xmap.insert(make_pair(y-1,1));\n\t\t\t\t\tif(0<y+1 && y+1 <H)xmap.insert(make_pair(y+1,1));\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> xs,ys;\n\t\tfor(auto it=xmap.begin();it!=xmap.end();it++){\n\t\t\txs.push_back(it->first);\n\t\t}\n\t\tfor(auto it=ymap.begin();it!=ymap.end();it++){\n\t\t\tys.push_back(it->first);\n\t\t}\n\t\tsort(xs.begin(),xs.end());\n\t\tsort(ys.begin(),ys.end());\n\n\t\tint h=ys.size(),w=xs.size();\n\t\tint res=0;\n\t\tfor(int c=0;c<30;c++){\n\t\t\tfor(int y=0;y<h;y++)for(int x=0;x<w;x++)if(board[ys[y]][xs[x]]=='.'){\n\t\t\t\tmap<char,vector<pair<int,int>>> ps;\n\t\t\t\tfor(int d=0;d<4;d++){\n\t\t\t\t\tint px=x,py=y;\n\t\t\t\t\twhile( 0<= px && px < w && 0 <=py && py < h  &&   board[ys[py]][xs[px]]=='.'){\n\t\t\t\t\t\tpx+=dx[d];py+=dy[d];\n\t\t\t\t\t}\n\t\t\t\t\tif( 0<= px && px < w && 0 <=py && py < h  && board[ys[py]][xs[px]]!='.'){\n\t\t\t\t\t\tps[board[ys[py]][xs[px]]].push_back(make_pair(py,px));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor(auto it=ps.begin();it!=ps.end();it++){\n\t\t\t\t\tvector<pair<int,int>> vs=it->second;\n\t\t\t\t\tif(it->second.size()==2){\n\t\t\t\t\t\tres+=2;\n\t\t\t\t\t\tboard[ys[vs[0].first]][xs[vs[0].second]]='.';\n\t\t\t\t\t\tboard[ys[vs[1].first]][xs[vs[1].second]]='.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << res <<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nstring grid[500];\nint posy[26][2],posx[26][2];\nint pos[26][2][2];\nbool use[26];\nint n,m;\nint res;\n\nbool cluck(int y,int x,int z){\n  int k;\n  int cnt[26];\n  for(int i=0;i<26;i++)cnt[i] = 0;\n\n  k = 1;\n  while(y+k<n && grid[y+k][x] == '.')k++;\n  if(y+k<n)cnt[grid[y+k][x]-'A']++;\n\n  k = 1;\n  while(x+k<m && grid[y][x+k] == '.')k++;\n  if(x+k<m)cnt[grid[y][x+k]-'A']++;\n\n  k = 1;\n  while(y-k>=0 && grid[y-k][x] == '.')k++;\n  if(y-k>=0)cnt[grid[y-k][x]-'A']++;\n\n  k = 1;\n  while(x-k>=0 && grid[y][x-k] == '.')k++;\n  if(x-k>=0)cnt[grid[y][x-k]-'A']++;\n\n  if(cnt[z]==2){\n    res += 2;\n    grid[posy[z][0]][posx[z][0]] ='.';\n    grid[posy[z][1]][posx[z][1]] ='.';\n    return true; \n  }\n  return false;\n}\n\nint main(){\n  cin >> n >> m;\n  for(int i=0;i<n;i++)cin >> grid[i];\n\n  for(int i=0;i<26;i++){\n    posy[i][0] = -1;\n    posx[i][0] = -1;\n    posy[i][1] = -1;\n    posx[i][1] = -1;\n  }\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<m;j++){\n      if(grid[i][j] != '.'){\n\tif(posy[grid[i][j]-'A'][0]<0){\n\t  posy[grid[i][j]-'A'][0] = i;\n\t  posx[grid[i][j]-'A'][0] = j;\n\t}else{\n\t  posy[grid[i][j]-'A'][1] = i;\n\t  posx[grid[i][j]-'A'][1] = j;\n\t}\n      }\n    }\n  }\n\n  res = 0;\n  while(1){\n    bool f = false;\n    for(int i=0;i<26;i++){\n      if(posy[i][0] == posy[i][1]){\n\tint s = min(posx[i][0],posx[i][1]),g = max(posx[i][0],posx[i][1]);\n\tfor(int j=s+1;j<g;j++){\n\t  if(grid[posy[i][0]][j]=='.')f |= cluck(posy[i][0],j,i);\n\t}\n      }else if(posx[i][0] == posx[i][1]){\n\tint s = min(posy[i][0],posy[i][1]),g = max(posy[i][0],posy[i][1]);\n\tfor(int j=s+1;j<g;j++){\n\t  if(grid[j][posx[i][0]]=='.')f |= cluck(j,posx[i][0],i);\n\t}\n      }else{\n\tif(grid[posy[i][0]][posx[i][1]] == '.')f |= cluck(posy[i][0],posx[i][1],i);\n\tif(grid[posy[i][1]][posx[i][0]] == '.')f |= cluck(posy[i][1],posx[i][0],i);\n      }\n    }\n    if(!f)break;\n  }\n\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\n\nint h, w;\nchar field[1000][1000];\nvector<int> px[30];\nvector<int> py[30];\nvector<pair<int, int> > cand[30];\n\nvoid PrintField() {\n  REP(y, h) {\n    printf(\"%s\\n\", field[y]);\n  }\n}\n\nbool DontHave(int sx, int sy, int ex, int ey) {\n  if (sx == ex && sy == ey) { return false; }\n  if (sx > ex && sy == ey) { swap(sx, ex); }\n  if (sx == ex && sy > ey) { swap(sy, ey); }\n  int dx = 0;\n  int dy = 0;\n  if (sx != ex) { dx++; }\n  else { dy++; }\n  while (sx != ex && sy != ey) {\n    if (field[sy][sx] != '.') { return false; }\n    sx += dx;\n    sy += dy;\n  }\n  return true;\n}\n\nint main() {\n  while (scanf(\"%d %d\", &h, &w) > 0) {\n    REP(i, 30) {\n      cand[i].clear();\n      px[i].clear();\n      py[i].clear();\n    }\n    REP(y, h) {\n      scanf(\"%s\", field[y]);\n    }\n    REP(y, h) {\n      REP(x, w) {\n        if (isupper(field[y][x])) {\n          int c = field[y][x] - 'A';\n          px[c].push_back(x);\n          py[c].push_back(y);\n        }\n      }\n    }\n    REP(i, 30) {\n      if (px[i].size() == 0) { continue; }\n      if (px[i][0] == px[i][1]) {\n        int sy = min(py[i][0], py[i][1]) + 1;\n        cand[i].push_back(make_pair(px[i][0], sy));\n      } else if (py[i][0] == py[i][1]) {\n        int sx = min(px[i][0], px[i][1]) + 1;\n        cand[i].push_back(make_pair(sx, py[i][0]));\n      } else {\n        cand[i].push_back(make_pair(px[i][0], py[i][1]));\n        cand[i].push_back(make_pair(px[i][1], py[i][0]));\n      }\n    }\n\n    int ans = 0;\n    while (true) {\n      bool end = true;\n      REP(i, 30) {\n        if (px[i].size() == 0) { continue; }\n        FORIT(it, cand[i]) {\n          if (field[it->second][it->first] != '.') { continue; }\n          if (DontHave(px[i][0], py[i][0], it->first, it->second) &&\n              DontHave(px[i][1], py[i][1], it->first, it->second)) {\n            field[py[i][0]][px[i][0]] = '.';\n            field[py[i][1]][px[i][1]] = '.';\n            px[i].clear();\n            py[i].clear();\n            cand[i].clear();\n            ans++;\n            end = false;\n            break;\n          }\n        }\n      }\n      if (end) { break; }\n    }\n    //PrintField();\n    printf(\"%d\\n\", ans * 2);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MOD 1000000007\n#define BIG 1000000010\n#define repi(i,x,n) for(int i=x;i<n;i++)\n#define rep(i,n) repi(i,0,n)\n#define repn(i,n) for(int i=n;i>=0;i--)\ntypedef long long int ll;\n\nstruct xy{\n  int x,y;\n};\n\nint main(){\n  int m,n,ans=0;\n  xy point[4];\n  bool b;\n  char clear[2];\n  cin>>m>>n;\n  char mp[501][501];\n  mp[500][500]='.';\n  rep(i,m){\n    rep(j,n) cin>>mp[i][j];\n  }\n  \n  while(1){\n    b=true;\n    rep(i,m){\n      rep(j,n){\n\n\tif(mp[i][j]=='.'){\n\t  rep(k,4){\n\t    point[k].x=point[k].y=500;\n\t  }\n\t  \n\t  repi(k,i,m){\n\t    if(mp[k][j]!='.'){\n\t      point[0].x=k;\n\t      point[0].y=j;\n\t      break;\n\t    }\n\t  }\n\t  repi(k,j,n){\n\t    if(mp[i][k]!='.'){\n\t      point[1].x=i;\n\t      point[1].y=k;\n\t      break;\n\t    }\n\t  }\n\t  repn(k,i){\n\t    if(mp[k][j]!='.'){\n\t      point[2].x=k;\n\t      point[2].y=j;\n\t      break;\n\t    }\n\t  }\n\t  repn(k,j){\n\t    if(mp[i][k]!='.'){\n\t      point[3].x=i;\n\t      point[3].y=k;\n\t      break;\n\t    }\n\t  }\n\n\t  rep(k,4){\n\t    repi(l,k+1,4){\n\t    \n\t      if(mp[point[k].x][point[k].y]==mp[point[l].x][point[l].y]){\n\t\n\t\tif(point[k].x != 500 && point[l].x != 500){\n\t\t  \n\t\t  mp[point[k].x][point[k].y]=mp[point[l].x][point[l].y]='.';\n\t       \n\t\t  ans++;\n\t\t  \n\t\t  point[k].x=point[k].y=point[l].x=point[l].y=500;\n\t\t   \n\t\t  b=false;\n\t\t  //cout<<k<<\" \"<<l<<endl;\n\t\t}\n\t      }\n\t    }\n\n\t  }\n\t}\n      }\n    }\n    if(b) break;\n  }\n  cout<<ans*2<<endl;\t  \n\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define x first\n#define y second\nusing namespace std;\ntypedef pair <int,int> P;\nstring mp[501];\nint m,n,used[30],ans;\nvector <P>  a[30];\n\nint saiki(int);\n\nbool check_x(int y,int x1,int x2){\n  for(int i=x1+1;i<x2;i++)\n    if(mp[y][i]!='.'&&!saiki(mp[y][i]-'A'))return 0;\n  return 1;\n}\n\nbool check_y(int y1,int y2,int x){\n  for(int i=y1+1;i<y2;i++)\n    if(mp[i][x]!='.'&&!saiki(mp[i][x]-'A')) return 0;\n  return 1;\n}\n\n\nint saiki(int ch){\n  int x1=a[ch][0].x,x2=a[ch][1].x;\n  int y1=a[ch][0].y,y2=a[ch][1].y;\n  int res=0;\n  if(used[ch])return 0;\n  used[ch]=1;\n  \n  if(x1==x2&&y2-y1!=1) res=check_y(y1,y2,x1);\n  if(y1==y2&&x2-x1!=1) res=check_x(y1,x1,x2);\n  \n  if(x1!=x2&&y1!=y2) {\n    if(x1<x2){\n      res=check_x(y1,x1,x2+1)&check_y(y1,y2,x2);\n      res|=check_y(y1,y2+1,x1)&check_x(y2,x1,x2);\n    }\n    else{\n      swap(x1,x2);\n     res=check_x(y1,x1-1,x2)&check_y(y1,y2,x1);\n     res|= check_y(y1,y2,x2)&check_x(y2,x1,x2+1);\n      swap(x1,x2);\n    }\n  }\n  \n  if(res) {\n    mp[y1][x1]=mp[y2][x2]='.';\n    a[ch].clear();\n    ans+=2;\n  }\n  return res;\n}\n\nint main(){\n\n  cin>>m>>n;\n  for(int i=0;i<m;i++)cin>>mp[i];\n\n  for(int i=0;i<m;i++)\n    for(int j=0;j<n;j++)\n      if(mp[i][j]!='.')a[mp[i][j]-'A'].push_back(P(j,i));\n  \n  \n  for(int i=0;i<30;i++){\n    memset(used,0,sizeof(used));\n    if(a[i].size()) saiki(i);\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nchar m[505][505];\nint h, w;\n\nconst int dy[16] = { 0,-1, 0, 1, 1,-1, 1,-1, 0,-2, 0, 2};\nconst int dx[16] = { 1, 0,-1, 0, 1, 1,-1,-1, 2, 0,-2, 0};\n\nvector<pair<pair<int, int>,char>> extends(int y, int x){\n    vector<pair<pair<int,int>,char>> ret;\n    rep(i,4){\n        int ny = y, nx = x;\n        while(true){\n            ny += dy[i];\n            nx += dx[i];\n            if(ny < 0 || ny >= h || nx < 0 || nx >= w) break;\n            if(m[ny][nx] != '.'){\n                ret.emplace_back(make_pair(make_pair(ny,nx),m[ny][nx]));\n                break;\n            }\n        }\n    }\n    return ret;\n}\n\nvoid compress(vector<int> &v) {\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\n\nint lb(vector<int> v, int num){\n    return lower_bound(all(v), num) - v.begin();\n}\n\nint main(){\n    cin >> h >> w;\n\n    vector<pair<pair<int, int>,char>> v;\n    vector<int> x,y;\n    rep(i,h){\n        rep(j,w){\n            char c;\n            cin >> c;\n            m[i][j] = c;\n            if(c != '.'){\n                v.emplace_back(make_pair(make_pair(i,j),c));\n                y.emplace_back(i);\n                x.emplace_back(j);\n            }\n        }\n    }\n    //compress(x);\n    //compress(y);\n    //h = y.size();\n    //w = x.size();\n\n    //rep(i,h + 1) rep(j,w + 1) m[i][j] = '.';\n    //rep(i,v.size()){\n    //    int fy = lb(y,v[i].first.first);\n    //    int fx = lb(x,v[i].first.second);\n    //    m[fy][fx] = v[i].second;\n    //}\n    //cout << endl; rep(i,h){ rep(j,w){ cout << m[i][j]; } cout << endl; } cout << endl;\n\n    bool f = true;\n    int cnt = 0;\n    while(f){\n        f = false;\n        rep(i,h){\n            rep(j,w){\n                vector<pair<pair<int, int>,char>> v;\n                if(m[i][j] == '.') v = extends(i,j);\n                rep(i,v.size()){\n                    rep(j,v.size()){\n                        if(i == j) continue;\n                        if(v[i].second == v[j].second){\n                            if(m[ v[i].first.first ][ v[i].first.second ] == '.') continue;\n                            m[ v[i].first.first ][ v[i].first.second ] = '.';\n                            m[ v[j].first.first ][ v[j].first.second ] = '.';\n                            f = true;\n                            cnt++;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    cout << cnt * 2 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#define PII pair<int, int>\n#define REP(i, n) for(int i=0;i<(n);++i)\n#define atoi(x) (x - 'A')\nusing namespace std;\nint H, W;\nvector<vector<char> > map;\nvector<vector<PII > > alp;\nvoid outmap(){\n    REP(y, H){\n        REP(x, W){\n            cout << map[y][x];\n        }\n        cout << endl;\n    }\n}\nbool check(int sy, int sx, int gy, int gx) {\n    if(abs(sy-gy)+abs(sx-gx)==1)return false;\n\tint count = 0;\n\tfor (int x = min(sx, gx); x <= max(sx, gx); ++x) {\n\t\tcount += map[sy][x] != '.';\n\t}\n\tfor (int y = min(sy, gy); y <= max(sy, gy); ++y) {\n\t\tcount += map[y][gx] != '.';\n\t}\n    count -= map[sy][gx] != '.';\n\tif (count == 2)return true;\n\tcount = 0;\n\tfor (int y = min(sy, gy); y <= max(sy, gy); ++y) {\n\t\tcount += map[y][sx] != '.';\n\t}\n\tfor (int x = min(sx, gx); x <= max(sx, gx); ++x) {\n\t\tcount += map[gy][x] != '.';\n\t}\n    count -= map[gy][sx] != '.';\n\tif (count == 2)return true;\n\treturn false;\n}\nint main() {\n\tcin >> H >> W;\n\tmap.resize(H);\n\talp.resize(26);\n\tREP(i, H) {\n\t\tmap[i].resize(W);\n\t\tREP(j, W) {\n\t\t\tcin >> map[i][j];\n\t\t\tif (map[i][j] != '.') {\n\t\t\t\talp[atoi(map[i][j])].push_back(PII(i, j));\n\t\t\t}\n\t\t}\n\t}\n\tbool flag = true;\n\tint ans = 0;\n\twhile (flag) {\n\t\tflag = false;\n\t\tREP(i, 26) {\n\t\t\tif (alp[i].empty())continue;\n\t\t\tif (!check(alp[i][0].first, alp[i][0].second, alp[i][1].first, alp[i][1].second))continue;\n            ans += 2;\n\t\t\tmap[alp[i][0].first][alp[i][0].second] = '.';\n\t\t\tmap[alp[i][1].first][alp[i][1].second] = '.';\n            alp[i].clear();\n            flag = true;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\n\nint h,w;\nstring s[600];\nint dy[]={0,1,0,-1};\nint dx[]={1,0,-1,0};\nint sum=0;\n\nvoid knock(int Y,int X){\n  \n  map<char,vector<P> >M;\n  r(i,4){\n    int y=Y;\n    int x=X;\n\n    while(!isalpha(s[y][x])){\n      y+=dy[i];\n      x+=dx[i];\n      if(y<0||x<0||y>=h||x>=w)break;\n    }\n\n    if(y<0||x<0||y>=h||x>=w)continue;\n    M[s[y][x]].push_back(P(y,x));\n  }\n\n  for(auto &e:M){\n    if(e.second.size()!=2)continue;\n    sum+=2;\n    s[e.second[0].first][e.second[0].second] = '.';\n    s[e.second[1].first][e.second[1].second] = '.';\n  }\n\n}\n\nsigned main(){\n  cin>>h>>w;\n  r(i,h)cin>>s[i];\n\n  r(tim,30)r(i,h)r(j,w)if(!isalpha(s[i][j])){\n    knock(i,j);\n  }\n\n  cout<<sum<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <ctype.h>\n#include <stdlib.h>\n\n\nvoid gstr(char *str){\n\tint i;\n\tfor(i = 0;(str[i] = getchar()) != '\\n';i++);\n\tstr[i] = '\\0';\n}\n\nint main(void){\n\tint i, j, k, l, h, w, dx[4] = {0,1,0,-1}, dy[4] = {-1,0,1,0}, ans = 0;\n\tchar s[500][501], *c[4];\n\tscanf(\"%d%d%*c\",&h,&w);\n\tfor(i = 0;i < h;i++) gstr(s[i]);\n\tfor(i = 0;i < h;i++){\n\t\tfor(j = 0;j < w;j++){\n\t\t\tif(!isupper(s[i][j])){\n\t\t\t\tfor(k = 0;k < 4;k++){\n\t\t\t\t\tfor(l = 0;i + dy[k] * l >=  0 && i + dy[k] * l < h && j + dx[k] * l >= 0 && j + dx[k] * l < w && !isupper(s[i + dy[k] * l][j + dx[k] * l]);l++);\n\t\t\t\t\tif(i + dy[k] * l >= 0 && i + dy[k] * l < h && j + dx[k] * l >= 0 && j + dx[k] * l < w) c[k] = &s[i + dy[k] * l][j + dx[k] * l];\n\t\t\t\t\telse c[k] = NULL;\n\t\t\t\t}\n\t\t\t\tfor(k = 0;k < 3;k++){\n\t\t\t\t\tfor(l = k + 1;l < 4;l++)\n\t\t\t\t\t\tif(c[k] != NULL && c[l] != NULL && k != l && *c[k] == *c[l] && *c[k] != '.') *c[k] = '.',*c[l] = '.',i = -1, ans += 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i == -1) break;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s); sin>>v; return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\nint main(){\n\tint m,n;\n\tcin>>m>>n;\n\tvs f(m);\n\tconst int num_alph='Z'-'A'+1;\n\tvvp pos(num_alph);\n\tREP(i,m){\n\t\tcin>>f[i];\n\t\tREP(j,n){\n\t\t\tif(isalpha(f[i][j])){\n\t\t\t\tpos[f[i][j]-'A'].push_back(make_pair(i,j));\n\t\t\t}\n\t\t}\n\t}\n\tFOR(c,0,num_alph){\n\t\tsort(ALL(pos[c]));\n\t}\n\n\tREP(c,num_alph){\n\t\tif(pos[c].size()){\n\t\t\tif(abs(pos[c][0].first-pos[c][1].first)+abs(pos[c][0].second-pos[c][1].second)<=1){\n\t\t\t\tpos[c].clear();\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tbool changed=true;\n\twhile(changed){\n\t\tchanged=false;\n\t\tFOR(c,0,num_alph){\n\t\t\tif(pos[c].size()==0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbool left_ok=true;\n\t\t\tbool right_ok=true;\n\t\t\tint x_left=pos[c][0].second;\n\t\t\tint x_right=pos[c][1].second;\n\t\t\tif(x_left>x_right)swap(x_left,x_right);\n\t\t\tint y_top=pos[c][0].first;\n\t\t\tint y_bottom=pos[c][1].first;\n\t\t\tFOR(y,y_top,y_bottom+1){\n\t\t\t\tif(f[y][x_left]!='.'&&f[y][x_left]!='A'+c){\n\t\t\t\t\tleft_ok=false;\n\t\t\t\t}\n\t\t\t\tif(f[y][x_right]!='.'&&f[y][x_right]!='A'+c){\n\t\t\t\t\tright_ok=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool top_ok=true;\n\t\t\tbool bottom_ok=true;\n\t\t\tFOR(x,x_left,x_right+1){\n\t\t\t\tif(f[y_top][x]!='.'&&f[y_top][x]!='A'+c){\n\t\t\t\t\ttop_ok=false;\n\t\t\t\t}\n\t\t\t\tif(f[y_bottom][x]!='.'&&f[y_bottom][x]!='A'+c){\n\t\t\t\t\tbottom_ok=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool ok=false;\n\t\t\tif(pos[c][0].second<pos[c][1].second){\n\t\t\t\tok=((top_ok&&right_ok)||(bottom_ok&&left_ok));\n\t\t\t}else{\n\t\t\t\tok=((top_ok&&left_ok)||(bottom_ok&&right_ok));\n\t\t\t}\n\n\t\t\tif(ok){\n\t\t\t\tf[pos[c][0].first][pos[c][0].second]='.';\n\t\t\t\tf[pos[c][1].first][pos[c][1].second]='.';\n\t\t\t\tpos[c].clear();\n\t\t\t\tans+=2;\n\t\t\t\tchanged=true;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cctype>\n#include <vector>\n#include <map>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0 ; i < n ; i++)\n\ntypedef pair<int, int> P;\n\nstruct Point{\n  int x1, y1, x2, y2;\n};\n\nconst int MAX = 510;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nchar field[MAX][MAX];\nbool found[26];\nPoint alpha[26];\nint H, W;\n\nbool checkH(int x1, int x2, int y, char c){\n  if(x1 > x2) swap(x1, x2);\n  for(int j = x1 ; j <= x2 ; j++){\n    if(field[y][j] != '.' && field[y][j] != c) return false;\n  }\n  return true;\n}\n\nbool checkW(int y1, int y2, int x, char c){\n  if(y1 > y2) swap(y1, y2);\n  for(int i = y1 ; i <= y2 ; i++){\n    if(field[i][x] != '.' && field[i][x] != c) return false;\n  }\n  return true;\n}\n\nint main(){\n  while(cin >> H >> W){\n    rep(i, H) cin >> field[i];\n    \n    memset(alpha, 0, sizeof(alpha));\n    memset(found, 0, sizeof(found));\n    \n    rep(i, H){\n      rep(j, W){\n\tif(isalpha(field[i][j])){\n\t  int c = field[i][j]-'A';\n\t  if(!found[c]){\n\t    found[c] = true;\n\t    alpha[c].x1 = j, alpha[c].y1 = i;\n\t  }\n\t  else{\n\t    alpha[c].x2 = j, alpha[c].y2 = i;\n\t  }\n\t}\n      }\n    }\n    \n    Point cross[26];\n    rep(i, 26){\n      if(found[i]){\n\tcross[i].x1 = alpha[i].x1, cross[i].y1 = alpha[i].y2;\n\tcross[i].x2 = alpha[i].x2, cross[i].y2 = alpha[i].y1;\n      }\n    }\n    \n    rep(i, H){\n      rep(j, W){\n\trep(k, 4){\n\t  int nx = j+dx[k], ny = i+dy[k];\n\t  if(nx < 0 || nx > W || ny < 0 || ny > H) continue;\n\t  if(field[i][j] == field[ny][nx]) found[field[i][j]-'A'] = false;\n\t}\n      }\n    }\n    \n    int ans = 0;\n    for(; ;){\n    Start:;\n      bool flag = false;\n      rep(i, 26){\n\tif(found[i]){\t  \n\t  int X1 = cross[i].x1, Y1 = cross[i].y1, X2 = cross[i].x2, Y2 = cross[i].y2;\n\t  int x1 = alpha[i].x1, y1 = alpha[i].y1, x2 = alpha[i].x2, y2 = alpha[i].y2;\n\t  char c = 'A'+i;\n\t  \n\t  if(x1 == x2){\n\t    flag = checkW(y1, y2, x1, c);\n\t  }\n\t  else if(y1 == y2){\n\t    flag = checkH(x1, x2, y1, c);\t    \n\t  }\n\t  else{\n\t    if((checkH(X1, x1, y2, c) && checkW(Y1, y2, x1, c)) ||\n\t       (checkH(X2, x2, y1, c) && checkW(Y2, y1, x2, c))){\n\t      flag = true;\n\t    }\n\t  }\n\t  \n\t  if(flag){\n\t    found[i] = false;\n\t    ans += 2;\n\t    field[y1][x1] = '.', field[y2][x2] = '.';\t    \n\t    goto Start;\n\t  }\n\t  \n\t}\n      }\n      if(!flag) break;\n    }\n    cout << ans << endl;\n  }  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define pii pair<int, int>\nusing namespace std;\n\nint di[] = {-1, 0, 1, 0};\nint dj[] = {0, -1, 0, 1};\nint m, n;\n\nbool check(int ci, int cj) { return ci >= 0 && cj >= 0 && ci < m && cj < n; }\n\nint main() {\n    cin >> m >> n;\n    string s[m];\n    for (int i = 0; i < m; i++) cin >> s[i];\n    int ans = 0;\n    while (true) {\n        int ret = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (s[i][j] == '.') {\n                    pii alp[50];\n                    for (int k = 0; k < 50; k++) alp[k] = pii(-1, -1);\n                    for (int k = 0; k < 4; k++) {\n                        int ci = i, cj = j;\n                        while (check(ci, cj) && s[ci][cj] == '.') {\n                            ci += di[k];\n                            cj += dj[k];\n                        }\n                        if (check(ci, cj)) {\n                            int c = s[ci][cj] - 'A';\n                            if (alp[c].first != -1) {\n                                pii cur = alp[c];\n                                s[ci][cj] = '.';\n                                s[cur.first][cur.second] = '.';\n                                ret += 2;\n                            } else {\n                                alp[c] = pii(ci, cj);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (ret == 0) break;\n        ans += ret;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define pii pair<int, int>\nusing namespace std;\n\nint di[] = {-1, 0, 1, 0};\nint dj[] = {0, -1, 0, 1};\nint m, n;\n\nbool check(int ci, int cj) { return ci >= 0 && cj >= 0 && ci < m && cj < n; }\n\nint main() {\n    cin >> m >> n;\n    string s[m];\n    for (int i = 0; i < m; i++) cin >> s[i];\n    int ans = 0;\n    while (true) {\n        int ret = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (s[i][j] == '.') {\n                    pii alp[50];\n                    for (int k = 0; k < 50; k++) alp[k] = pii(-1, -1);\n                    for (int k = 0; k < 4; k++) {\n                        int ci = i, cj = j;\n                        while (check(ci, cj) && s[ci][cj] == '.') {\n                            ci += di[k];\n                            cj += dj[k];\n                        }\n                        if (check(ci, cj)) {\n                            int c = s[ci][cj] - 'A';\n                            if (alp[c].first != -1) {\n                                pii cur = alp[c];\n                                s[ci][cj] = '.';\n                                s[cur.first][cur.second] = '.';\n                                ret += 2;\n                            } else {\n                                alp[c] = pii(ci, cj);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (ret == 0) break;\n        ans += ret;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cctype>\n#include <vector>\n#include <utility>\nusing namespace std;\n\ntypedef pair<int, int> pii;\nconst int INF = 1 << 28;\nchar board[510][510];\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\nint main() {\n    int H, W; scanf(\"%d%d\", &H, &W);\n    int rest = 0;\n    for(int i=0; i<H; i++) {\n        for(int j=0; j<W; j++) {\n            scanf(\" %c\", &board[i][j]);\n            if(isupper(board[i][j])) rest++;\n        }\n    }\n\n    int ans = 0;\n    while(1) {\n        bool ok = false;\n        pii INIT = make_pair(-INF, -INF);\n        for(int i=0; i<H; i++) {\n            for(int j=0; j<W; j++) {\n                vector<pii> rec(26, INIT);\n                if(isupper(board[i][j])) continue;\n                for(int k=0; k<4; k++) {\n                    int x = i, y = j;\n                    while(1) {\n                        x += dx[k], y += dy[k];\n                        if(x < 0 || x >= H || y < 0 || y >= W) break;\n                        if(isupper(board[x][y])) {\n                            int c = board[x][y] - 'A';\n                            if(rec[c] == INIT) rec[c] = make_pair(x, y);\n                            else {\n                                int u = rec[c].first, v = rec[c].second;\n                                // printf(\"found: (%d, %d) and (%d, %d): %c (%d, %d)\\n\", u, v, x, y, 'A' + c, i, j);\n                                board[u][v] = board[x][y] = '.';\n                                rec[c] = INIT;\n                                ok = true;\n                                ans += 2;\n                            }\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        if(!ok) break;\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Header {{{\n// includes {{{\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <unistd.h>\n#include <vector>\n// }}}\nusing namespace std;\n// consts {{{\nstatic const int INF = 1e9;\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n// }}}\n// typedefs {{{\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<ULL> VULL;\ntypedef vector<VULL> VVULL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef pair<int, int> PII;\ntypedef complex<int> P;\n#define PQ(type) priority_queue<type>\n// priority queue reverse\n#define PQR(type) priority_queue< type, vector<type>, greater<type> >\n// }}}\n// macros & inline functions {{{\n// syntax sugars {{{\n#define FOR(i, b, e) for (typeof(e) i = (b); i < (e); ++i)\n#define FORI(i, b, e) for (typeof(e) i = (b); i <= (e); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define REPI(i, n) FORI(i, 0, n)\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n#define ASSIGN_MAX(var, val) ((var) = max((var), (val)))\n#define ASSIGN_MIN(var, val) ((var) = min((var), (val)))\n// }}}\n// conversion {{{\ninline int toInt(string s) { int v; istringstream sin(s); sin>>v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout<<x; return sout.str(); }\n// }}}\n// array and STL {{{\n#define ARRSIZE(a) ( sizeof(a) / sizeof(a[0]) )\n#define ZERO(a, v) ( assert(v == 0 || v == -1), memset(a, v, sizeof(a)) )\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n#define SIZE(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c, it) for(typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define REACH(c, it) for(typeof((c).rbegin()) it=(c).rbegin(); it!=(c).rend(); ++it)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n// }}}\n// bit manipulation {{{\n// singed integers are not for bitwise operations, specifically arithmetic shifts ('>>', and maybe not good for '<<' too)\n#define IS_UNSIGNED(n) (!numeric_limits<typeof(n)>::is_signed)\n#define BIT(n) (assert(IS_UNSIGNED(n)), assert(n < 64), (1ULL << (n)))\n#define BITOF(n, m) (assert(IS_UNSIGNED(n)), assert(m < 64), ((ULL)(n) >> (m) & 1))\ninline int BITS_COUNT(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int MSB(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c-1; }\ninline int MAKE_MASK(ULL upper, ULL lower) { assert(lower < 64 && upper < 64 && lower <= upper); return (BIT(upper) - 1) ^ (BIT(lower) - 1); }\n// }}}\n// for readable code {{{\n#define EVEN(n) (n % 2 == 0)\n#define ODD(n) (!EVEN(n))\n// }}}\n// debug {{{\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n#define dprt(fmt, ...) if (opt_debug) { fprintf(stderr, fmt, ##__VA_ARGS__); }\n#define darr(a) if (opt_debug) { copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define darr_range(a, f, t) if (opt_debug) { copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define dvec(v) if (opt_debug) { copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define darr2(a) if (opt_debug) { FOR(__i, 0, (arrsz(a))){ darr( (a)[__i] ); } }\n#define WAIT() if (opt_debug) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n#define dump(x) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl; }\n// dump vector elements in [s, e)\n#define dumpv(v, s, e) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #v << \" = \"; FOR(__i, s, e) { cerr << v[__i] << \"\\t\"; } cerr << endl; }\n#define dumpl(x) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #x << endl << (x) << endl; }\n#define dumpf() if (opt_debug) { cerr << __PRETTY_FUNCTION__ << endl; }\n#define where() if (opt_debug) { cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl; }\n#define dumpb(bit, digits) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #bit << \" = \"; for(int __i = digits - 1; __i >= 0; __i--) { cerr << static_cast<bool>(bit & (1 << __i)); if (__i % 4 == 0) { cerr << \" \"; } } cerr << endl; }\n\n// ostreams {{{\n// complex\ntemplate<typename T> ostream& operator<<(ostream& s, const complex<T>& d) {return s << \"(\" << d.real() << \", \" << d.imag() << \")\";}\n\n// pair\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n// vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& d) {\n\tint len = d.size();\n\tREP (i, len) {\n\t\ts << d[i]; if (i < len - 1) s << \"\\t\";\n\t}\n\treturn s;\n}\n\n// 2 dimentional vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector< vector<T> >& d) {\n\tint len = d.size();\n\tREP (i, len) {\n\t\ts << d[i] << endl;\n\t}\n\treturn s;\n}\n\n// map\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const map<T1, T2>& m) {\n\ts << \"{\" << endl;\n\tfor (typeof(m.begin()) itr = m.begin(); itr != m.end(); ++itr) {\n\t\ts << \"\\t\" << (*itr).first << \" : \" << (*itr).second << endl;\n\t}\n\ts << \"}\" << endl;\n\treturn s;\n}\n// }}}\n// }}}\n// }}}\n// time {{{\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\n// }}}\n// string manipulation {{{\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\ninline string join(VS s, string j) { string t; REP(i, s.size()) { t += s[i] + j; } return t; }\n// }}}\n// geometry {{{\n#define Y real()\n#define X imag()\n// }}}\n// 2 dimentional array {{{\nenum { UP, RIGHT, DOWN, LEFT, UP_RIGHT, DOWN_RIGHT, DOWN_LEFT, UP_LEFT };\nP dydx4[4] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1) };\nP dydx8[8] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1), P(-1, 1), P(1, 1), P(1, -1), P(-1, -1) };\nbool in_field(int H, int W, P p) {\n\treturn (0 <= p.Y && p.Y < H) && (0 <= p.X && p.X < W);\n}\n// }}}\n// input and output {{{\ninline void input(string filename) {\n\tfreopen(filename.c_str(), \"r\", stdin);\n}\ninline void output(string filename) {\n\tfreopen(filename.c_str(), \"w\", stdout);\n}\n// }}}\n// }}}\n\n// Header under development {{{\n\nint LCM(int a, int b) {\n\t// FIXME\n\treturn a * b;\n}\n\n// Fraction class {{{\n// ref: http://martin-thoma.com/fractions-in-cpp/\nclass Fraction {\n\tpublic:\n\t\tULL numerator;\n\t\tULL denominator;\n\t\tFraction(ULL _numerator, ULL _denominator) {\n\t\t\tassert(_denominator > 0);\n\t\t\tnumerator = _numerator;\n\t\t\tdenominator = _denominator;\n\t\t};\n\n\t\tFraction operator*(const ULL rhs) {\n\t\t\treturn Fraction(this->numerator * rhs, this->denominator);\n\t\t};\n\n\t\tFraction operator*(const Fraction& rhs) {\n\t\t\treturn Fraction(this->numerator * rhs.numerator, this->denominator * rhs.denominator);\n\t\t}\n\n\t\tFraction operator+(const Fraction& rhs) {\n\t\t\tULL lcm = LCM(this->denominator, rhs.denominator);\n\t\t\tULL numer_lhs = this->numerator * (this->denominator / lcm);\n\t\t\tULL numer_rhs = rhs.numerator * (rhs.numerator / lcm);\n\t\t\treturn Fraction(numer_lhs + numer_rhs, lcm);\n\t\t}\n\n\t\tFraction& operator+=(const Fraction& rhs) {\n\t\t\tFraction result = (*this) + rhs;\n\t\t\tthis->numerator = result.numerator;\n\t\t\tthis->denominator = result.denominator;\n\t\t\treturn *this;\n\t\t}\n};\n\nstd::ostream& operator<<(std::ostream &s, const Fraction &a) {\n\tif (a.denominator == 1) {\n\t\ts << a.numerator;\n\t} else {\n\t\ts << a.numerator << \"/\" << a.denominator;\n\t}\n\treturn s;\n}\n\n// }}}\n\n// }}}\n\nbool opt_debug = false;\n\nint main(int argc, char** argv) {\n\tstd::ios_base::sync_with_stdio(false);\n\t// set options {{{\n\tint __c;\n\twhile ( (__c = getopt(argc, argv, \"d\")) != -1 ) {\n\t\tswitch (__c) {\n\t\t\tcase 'd':\n\t\t\t\topt_debug = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tabort();\n\t\t}\n\t}\n\t// }}}\n\n\t// opt_debug = true;\n\t// input(\"./inputs/2.txt\");\n\t// output(\"./outputs/0.txt\");\n\n\tint H, W; cin >> H >> W;\n\tVVC field(H, VC(W));\n\tULL remaining = 0;\n\tREP (i, H) {\n\t\tREP (j, W) {\n\t\t\tcin >> field[i][j];\n\t\t\tif (field[i][j] != '.') {\n\t\t\t\tremaining |= 1 << (field[i][j] - 'A');\n\t\t\t}\n\t\t}\n\t}\n\n\t// y compression\n\tbool prev_empty = false;\n\tREP (i, H) {\n\t\tbool empty = true;\n\t\tREP (j, W) {\n\t\t\tif (field[i][j] != '.') {\n\t\t\t\tempty = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (prev_empty && empty) {\n\t\t\tfield.erase(field.begin() + i);\n\t\t\tH--;\n\t\t\ti--;\n\t\t}\n\t\tprev_empty = empty;\n\t}\n\n\t// x compression\n\tprev_empty = false;\n\tREP (j, W) {\n\t\tbool empty = true;\n\t\tREP (i, H) {\n\t\t\tif (field[i][j] != '.') {\n\t\t\t\tempty = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tdump(j);\n\t\tdump(prev_empty);\n\t\tdump(empty);\n\t\tif (prev_empty && empty) {\n\t\t\tREP (i, H) {\n\t\t\t\tfield[i].erase(field[i].begin() + j);\n\t\t\t}\n\t\t\tW--;\n\t\t\tj--;\n\t\t}\n\t\tprev_empty = empty;\n\t}\n\n\tint score = 0;\n\twhile (remaining) {\n\t\tbool hit = false;\n\t\tREP (i, H) {\n\t\t\tREP (j, W) {\n\t\t\t\tif (field[i][j] != '.') { continue; }\n\t\t\t\tvector< pair<P, char> > stats;\n\t\t\t\tREP (d, 4) {\n\t\t\t\t\tP cur = P(i, j);\n\t\t\t\t\twhile (in_field(H, W, cur + dydx4[d]) && field[cur.Y][cur.X] == '.') {\n\t\t\t\t\t\tcur += dydx4[d];\n\t\t\t\t\t}\n\t\t\t\t\tif (field[cur.Y][cur.X] != '.') {\n\t\t\t\t\t\tstats.PB(MP(cur, field[cur.Y][cur.X]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tREP (k, stats.size()) {\n\t\t\t\t\tFOR (l, k+1, stats.size()) {\n\t\t\t\t\t\tpair<P, char> a = stats[k], b = stats[l];\n\t\t\t\t\t\tif (a.S == b.S) {\n\t\t\t\t\t\t\thit = true;\n\t\t\t\t\t\t\tscore += 2;\n\t\t\t\t\t\t\tchar c = a.S;\n\t\t\t\t\t\t\tremaining &= ~(1 << (c - 'A'));\n\t\t\t\t\t\t\tfield[a.F.Y][a.F.X] = field[b.F.Y][b.F.X] = '.';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!hit) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcout << score << endl;\n\n\treturn 0;\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst int tx[] = {0,1,1,0};\nconst int ty[] = {0,0,1,1};\n \nstatic const double EPS = 1e-10;\n\nstruct Point {\n  int x;\n  int y;\n  Point(int _x,int _y) : x(_x) , y(_y) {}\n  bool operator ==(const Point& p) const{\n    return (x == p.x && y == p.y);\n  }\n};\n\nint main(){\n  int H,W;\n\n  while(~scanf(\"%d %d\",&H,&W)){\n    char stage[500][500];\n    map<char,vector<Point> > tiles;\n    for(int y=0;y<H;y++){\n      string line;\n      cin >> line;\n      for(int x=0;x<W;x++){\n\tstage[y][x] = line[x];\n\tif(stage[y][x] != '.'){\n\t  tiles[stage[y][x]].push_back(Point(x,y));\n\t}\n      }\n    }\n\n    int erased_count = 0;\n    bool erased[256];\n    memset(erased,false,sizeof(erased));\n    erased['.'] = true;\n\n    for(int round=0;round <= 500*500; round++){\n      for(int target_char = 'A'; target_char <= 'Z'; target_char++){\n\tif(erased[target_char]) continue;\n\tif(tiles.find(target_char) == tiles.end()) continue;\n\t\n\tPoint p1(tiles[target_char][0].x,tiles[target_char][0].y);\n\tPoint p2(tiles[target_char][1].x,tiles[target_char][1].y);\n\n\tbool isok = true;\n\tif(p1.x == p2.x){\n\t  if(abs(p1.y-p2.y) == 1) isok = false;\n\n\t  int x = p1.x;\n\t  for(int y=min(p1.y,p2.y)+1;y<max(p1.y,p2.y);y++){\n\t    if(!erased[stage[y][x]]){\n\t      isok = false;\n\t      break;\n\t    }\n\t  }\n\t}\n\telse if(p1.y==p2.y){\n\t  if(abs(p1.x-p2.x) == 1) isok = false;\n\n\t  int y = p1.y;\n\t  for(int x=min(p1.x,p2.x)+1;x<max(p1.x,p2.x);x++){\n\t    if(!erased[stage[y][x]]){\n\t      isok = false;\n\t      break;\n\t    }\n\t  }\n\t}\n\telse{\n\n\t  vector<Point> medium;\n\t  bool can_found = false;\n\t  for(int i=0;i<tiles[target_char].size();i++){\n\t    for(int j=0;j<tiles[target_char].size();j++){\n\t      Point mid(tiles[target_char][i].x,tiles[target_char][j].y);\n\t      \n\t      if(mid == p1 || mid == p2) continue;\n\t      if(!erased[stage[mid.y][mid.x]]) continue;\n\n\t      //target p1.x,p1.y\n\t      int flag1 = 0;\n\t      for(int x = min(mid.x,p1.x);x <= max(mid.x,p1.x); x++){\n\t\tif(Point(x,p1.y) == p1) continue;\n\t\tif(!erased[stage[mid.y][x]]) flag1 |= 1;\n\t      }\n\n\t      for(int y = min(mid.y,p1.y); y<= max(mid.y,p1.y) ; y++){\n\t\tif(Point(p1.x,y) == p1) continue;\n\t\tif(!erased[stage[y][mid.x]]) flag1 |= (1<<1);\n\t      }\n\n\t      //target x2,y2\n\t      int flag2 = 0;\n\t      for(int x = min(mid.x,p2.x);x <= max(mid.x,p2.x); x++){\n\t\tif(Point(x,p2.y) == p2) continue;\n\t\tif(!erased[stage[mid.y][x]]) flag2 |= 1;\n\t      }\n\n\t      for(int y = min(mid.y,p2.y) ;y <= max(mid.y,p2.y) ; y++){\n\t\tif(Point(p2.x,y) == p2) continue;\n\t\tif(!erased[stage[y][mid.x]]) flag2 |= (1<<1);\n\t      }\n\n\t      if(flag1 == 0 && flag2 == 0){\n\t\tcan_found = true;\n\t      }\n\t    }\n\t  }\n\n\t  if(!can_found){\n\t    isok = false;\n\t  }\n\t}\n\tif(isok){\n\t  erased[target_char] = true;\n\t  erased_count++;\n\t}\n      }\n    }\n    printf(\"%d\\n\",erased_count*2);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i, a, n) for(int i=a; i<n; i++)\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n\nint main()\n{\n\tint M, N;\n\tchar field[501][501];\n\tvector<vector<pair<int, int>>> v(26);\n\tcin >> M >> N;\n\tREP(i, 0, M) REP(j, 0, N) {\n\t\tcin >> field[i][j];\n\t\tif (field[i][j] != '.') {\n\t\t\tv[field[i][j] - 'A'].push_back(MP(i, j));\n\t\t}\n\t}\n\n\tint point = 0;\n\tbool flag = true;\n\twhile (flag) {\n\t\tflag = false;\n\t\t\n\t\tREP(k, 0, 26) {\n\t\t\tif (v[k].size() == 0) continue;\n\t\t\t\n\t\t\tbool del_flag = false;\n\t\t\tint y1 = v[k][0].F, y2 = v[k][1].F;\n\t\t\tint x1 = v[k][0].S, x2 = v[k][1].S;\n\t\t\tint ymin = min(y1, y2), ymax = max(y1, y2);\n\t\t\tint xmin = min(x1, x2), xmax = max(x1, x2);\n\n\t\t\tif (y1 == y2) {\n\t\t\t\tREP(l, xmin + 1, xmax) {\n\t\t\t\t\tif (field[y1][l] == '.') {\n\t\t\t\t\t\tdel_flag = true;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdel_flag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse if (x1 == x2) {\n\t\t\t\tREP(l, ymin + 1, ymax) {\n\t\t\t\t\tif (field[l][x1] == '.') {\n\t\t\t\t\t\tdel_flag = true;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdel_flag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tif (field[ymin][xmin] == '.') {\n\t\t\t\t\tREP(i, ymin, ymax) {\n\t\t\t\t\t\tif (field[i][xmin] != '.') {\n\t\t\t\t\t\t\tdel_flag = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse del_flag = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (del_flag) {\n\t\t\t\t\t\tREP(j, xmin, xmax) {\n\t\t\t\t\t\t\tif (field[ymin][j] != '.') {\n\t\t\t\t\t\t\t\tdel_flag = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse del_flag = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!del_flag && field[ymin][xmax] == '.') {\n\t\t\t\t\tREP(i, ymin, ymax) {\n\t\t\t\t\t\tif (field[i][xmax] != '.') {\n\t\t\t\t\t\t\tdel_flag = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse del_flag = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (del_flag) {\n\t\t\t\t\t\tREP(j, xmin + 1, xmax + 1) {\n\t\t\t\t\t\t\tif (field[ymin][j] != '.') {\n\t\t\t\t\t\t\t\tdel_flag = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse del_flag = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!del_flag && field[ymax][xmin] == '.') {\n\t\t\t\t\tREP(i, ymin + 1, ymax + 1) {\n\t\t\t\t\t\tif (field[i][xmin] != '.') {\n\t\t\t\t\t\t\tdel_flag = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse del_flag = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (del_flag) {\n\t\t\t\t\t\tREP(j, xmin, xmax) {\n\t\t\t\t\t\t\tif (field[ymax][j] != '.') {\n\t\t\t\t\t\t\t\tdel_flag = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse del_flag = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!del_flag && field[ymax][xmax] == '.') {\n\t\t\t\t\tREP(i, ymin + 1, ymax + 1) {\n\t\t\t\t\t\tif (field[i][xmax] != '.') {\n\t\t\t\t\t\t\tdel_flag = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse del_flag = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (del_flag) {\n\t\t\t\t\t\tREP(j, xmin + 1, xmax + 1) {\n\t\t\t\t\t\t\tif (field[ymax][j] != '.') {\n\t\t\t\t\t\t\t\tdel_flag = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse del_flag = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (del_flag) {\n\t\t\t\tfield[y1][x1] = '.';\n\t\t\t\tfield[y2][x2] = '.';\n\t\t\t\tv[k].pop_back();\n\t\t\t\tv[k].pop_back();\n\t\t\t\tpoint += 2;\n\t\t\t\tflag = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << point << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cctype>\n#include <vector>\n#include <set>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0 ; i < n ; i++)\n\nstruct Point{\n  int x1, y1, x2, y2;\n};\n\nconst int MAX = 510;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nchar field[MAX][MAX];\nbool found[26];\nPoint alpha[26];\n\nint H, W;\n\nbool canReach(char C, int cx, int cy, int x, int y){\n  if(cx < x){\n    for(int j = x ; j >= cx ; j--){\n      if(field[y][j] != '.' && field[y][j] != C) return false;\n    }\n  }\n  else if(cx > x){\n    for(int j = x ; j <= cx ; j++){\n      if(field[y][j] != '.' && field[y][j] != C) return false;\n    }\n  }\n  \n  if(cy < y){\n    for(int i = y ; i >= cy ; i--){\n      if(field[i][x] != '.' && field[i][x] != C) return false;\n    }\n  }\n  else if(cy > y){\n    for(int i = y ; i <= y ; i++){\n      if(field[i][x] != '.' && field[i][x] != C) return false;\n    }\n  }\n  return true;\n}\n\nbool canReach_x(char C, int x, int y1, int y2){\n  if(y1 > y2) swap(y1, y2);\n  for(int i = y1 ; i <= y2 ; i++){\n    if(field[i][x] != '.' && field[i][x] != C) return false;\n  }\n  return true;\n}\n\nbool canReach_y(char C, int y, int x1, int x2){\n  if(x1 > x2) swap(x1, x2);\n  for(int j = x1 ; j <= x2 ; j++){\n    if(field[y][j] != '.' && field[y][j] != C) return false;\n  }\n  return true;\n}\n\nvoid output(){\n  rep(i, H){\n    rep(j, W){\n      cout << field[i][j];\n    }\n    cout << endl;\n  }\n  cout << endl;\n}\n\n\nint main(){\n  while(cin >> H >> W){\n    rep(i, H) cin >> field[i];\n\n    memset(found, 0, sizeof(found));\n    \n    rep(i, H){\n      rep(j, W){\n\tif(isalpha(field[i][j])){\n\t  int c = field[i][j]-'A';\n\t  if(!found[c]){\n\t    found[c] = true;\n\t    alpha[c].x1 = j, alpha[c].y1 = i;\n\t  }\n\t  else{\n\t    alpha[c].x2 = j, alpha[c].y2 = i;\n\t  }\t\n\t}\n      }\n    }\n    \n    Point cross[26];\n    rep(i, 26){\n      if(found[i]){\n\tcross[i].x1 = alpha[i].x1, cross[i].y1 = alpha[i].y2;\n\tcross[i].x2 = alpha[i].x2, cross[i].y2 = alpha[i].y1;\n      }\n    }\n    \n    int ans = 0;\n    \n    rep(i, H){\n      rep(j, W){\n\trep(k, 4){\n\t  int nx = j+dx[k], ny = i+dy[k];\n\t  if(nx < 0 || nx > W || ny < 0 || ny > H) continue;\n\t  if(field[i][j] == field[ny][nx]) found[field[i][j]-'A'] = false;\n\t}\n      }\n    }\n\t\n    \n    for(; ;){\n      //output();\n      bool flag = false;\n      rep(i, 26){\n\tif(found[i]){\n\t  int x1 = alpha[i].x1, y1 = alpha[i].y1, x2 = alpha[i].x2, y2 = alpha[i].y2;\n\t  \n\t  if(x1 == x2){\n\t    if(canReach_x('A'+i, x1, y1, y2)){\n\t      field[y1][x1] = field[y2][x2] = '.';\n\t      found[i] = false;\n\t      ans += 2;\n\t      flag = true;\n\t    }\n\t  }\n\t  else if(y1 == y2){\n\t    if(canReach_y('A'+i, y1, x1, x2)){\n\t      field[y1][x1] = field[y2][x2] = '.';\n\t      found[i] = false;\n\t      ans += 2;\n\t      flag = true;\n\t    }\n\t  }\t      \t    \t  \t  \n\t  else if((canReach('A'+i, cross[i].x1, cross[i].y1, x1, y1) &&\n\t\t   canReach('A'+i, cross[i].x1, cross[i].y1, x2, y2)) ||\n\t\t  (canReach('A'+i, cross[i].x2, cross[i].y2, x1, y1) &&\n\t\t   canReach('A'+i, cross[i].x2, cross[i].y2, x2, y2))){\n\t    field[y1][x1] = field[y2][x2] = '.';\n\t    found[i] = false;\n\t    ans += 2;\n\t    flag = true;\n\t  }\n\t}\n      }\n      if(!flag) break;\n    }\n    \n    cout << ans << endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\nusing namespace std;\n\nint M, N, K;\nchar S[550][550];\nint h, w;\nvector<int> y, x;\nvector<char> c;\nchar s[550][550];\nint dd[5] = { 0, 1, 0, -1, 0 };\n\nint compress(vector<int> &a) {\n  vector<int> v;\n\n  REP(i, 0, a.size()) v.push_back(a[i]);\n  sort(v.begin(), v.end());\n  v.erase(unique(v.begin(), v.end()), v.end());\n  REP(i, 0, a.size()) a[i] = find(v.begin(), v.end(), a[i]) - v.begin();\n\n  return (int) v.size();\n}\n\nbool isin(int y, int x) {\n  return 0 <= y && y < h && 0 <= x && x < w;\n}\n\nint main(void) {\n  cin >> M >> N;\n  K = 0;\n  REP(i, 0, M) REP(j, 0, N) {\n    cin >> s[i][j];\n    // if(S[i][j] != '.') {\n    //   y.push_back(i);\n    //   x.push_back(j);\n    //   c.push_back(S[i][j]);\n    //   K++;\n    // }\n  }\n\n  // h = compress(y);\n  // w = compress(x);\n  //\n  // REP(i, 0, h) REP(j, 0, w) s[i][j] = '.';\n  // REP(i, 0, K) s[y[i]][x[i]] = c[i];\n  //\n  // cout << h << \", \" << w << endl;\n\n  h = M;\n  w = N;\n\n  // REP(i, 0, h) {\n  //   REP(j, 0, w) cout << s[i][j];\n  //   cout << endl;\n  // }\n\n  int ans = 0;\n  bool visited[256];\n  REP(i, 0, 256) visited[i] = false;\n  bool f = true;\n  while(f) {\n    f = false;\n    REP(i, 0, h) REP(j, 0, w) {\n      if(s[i][j] == '.' || visited[s[i][j]]) {\n        int cnt[256];\n        REP(k, 0, 256) cnt[k] = 0;\n        REP(k, 0, 4) {\n          int ny = i + dd[k], nx = j + dd[k + 1];\n          while(isin(ny, nx)) {\n            if(s[ny][nx] != '.' && !visited[s[ny][nx]]) {\n              cnt[s[ny][nx]]++;\n              if(cnt[s[ny][nx]] == 2) {\n                visited[s[ny][nx]] = true;\n                ans += 2;\n                f = true;\n              }\n              break;\n            }\n            ny += dd[k];\n            nx += dd[k + 1];\n          }\n        }\n      }\n    }\n  }\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint m,n;\nvector<P> data[30];\nvector<int> xindex;\nvector<int> yindex;\nint fie[180][180];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint pick[4];\nint pickx[4];\nint picky[4];\n\nint main(void){\n\tscanf(\"%d %d\",&n,&m);\n\tfor(int i=0;i<n;i++){\n\t\tstring str;\n\t\tcin >> str;\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(str[j]>='A' && str[j]<='Z'){\n\t\t\t\tdata[str[j]-'A'+1].push_back(P(j,i));\n\t\t\t\tif(j-1>=0)xindex.push_back(j-1);\n\t\t\t\txindex.push_back(j);\n\t\t\t\tif(j+1<m)xindex.push_back(j+1);\n\t\t\t\tif(i-1>=0)yindex.push_back(i-1);\n\t\t\t\tyindex.push_back(i);\n\t\t\t\tif(i+1<n)yindex.push_back(i+1);\n\t\t\t}\n\t\t}\n\t}\n\tsort(xindex.begin(),xindex.end());\n\txindex.erase(unique(xindex.begin(),xindex.end()),xindex.end());\n\tsort(yindex.begin(),yindex.end());\n\tyindex.erase(unique(yindex.begin(),yindex.end()),yindex.end());\n\tfor(int i=1;i<=26;i++){\n\t\tfor(int j=0;j<data[i].size();j++){\n\t\t\tdata[i][j].first=lower_bound(xindex.begin(),xindex.end(),data[i][j].first)-xindex.begin();\n\t\t\tdata[i][j].second=lower_bound(yindex.begin(),yindex.end(),data[i][j].second)-yindex.begin();\n\t\t\tfie[data[i][j].first][data[i][j].second]=i;\n\t\t}\n\t}\n\tbool flag=true;\n\tint score=0;\n\twhile(flag){\n\t\tflag=false;\n\t\tfor(int i=0;i<yindex.size();i++){\n\t\t\tfor(int j=0;j<xindex.size();j++){\n\t\t\t\tif(fie[j][i]==0){\n\t\t\t\t\tmemset(pick,0,sizeof(pick));\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tint x=j,y=i;\n\t\t\t\t\t\twhile(x>=0 && x<xindex.size() && y>=0 && y<yindex.size()){\n\t\t\t\t\t\t\tif(fie[x][y]!=0)break;\n\t\t\t\t\t\t\tx+=dx[k];\n\t\t\t\t\t\t\ty+=dy[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(fie[x][y]!=0){\n\t\t\t\t\t\t\tpick[k]=fie[x][y];\n\t\t\t\t\t\t\tpickx[k]=x;\n\t\t\t\t\t\t\tpicky[k]=y;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tfor(int l=k+1;l<4;l++){\n\t\t\t\t\t\t\tif(pick[k]==pick[l] && pick[k]!=0){\n\t\t\t\t\t\t\t\tscore+=2;\n\t\t\t\t\t\t\t\tfie[pickx[k]][picky[k]]=0;\n\t\t\t\t\t\t\t\tfie[pickx[l]][picky[l]]=0;\n\t\t\t\t\t\t\t\tflag=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",score);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef long double ld;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-10;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nint main()\n{\n\tint n, m;\n\tcin >> n >> m;\n\tvs fld(n);\n\tREP(i, n) cin >> fld[i];\n\tvector<vector<pii>> v(26);\n\tREP(i, n)REP(j, m)\n\t{\n\t\tif (fld[i][j] != '.')\n\t\t{\n\t\t\tv[fld[i][j] - 'A'].emplace_back(i, j);\n\t\t}\n\t}\n\tbool update = true;\n\tint ans = 0;\n\twhile (update)\n\t{\n\t\tupdate = false;\n\t\tREP(i, 26)\n\t\t{\n\t\t\tif (v[i].size() == 0) continue;\n\t\t\tint ax = v[i][0].first, ay = v[i][0].second;\n\t\t\tint bx = v[i][1].first, by = v[i][1].second;\n\t\t\tif (ax == bx)\n\t\t\t{\n\t\t\t\tbool f = true;\n\t\t\t\tif (ay > by) swap(ay, by);\n\t\t\t\tFOR(j, ay + 1, by)\n\t\t\t\t{\n\t\t\t\t\tif (fld[ax][j] != '.') f = false;\n\t\t\t\t}\n\t\t\t\tif (f&&abs(ay-by)>1)\n\t\t\t\t{\n\t\t\t\t\tupdate = true;\n\t\t\t\t\tv[i].clear();\n\t\t\t\t\tans++;\n\t\t\t\t\tfld[ax][ay] = fld[bx][by] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (ay == by)\n\t\t\t{\n\t\t\t\tbool f = true;\n\t\t\t\tif (ax > bx) swap(ax, bx);\n\t\t\t\tFOR(j, ax + 1, bx)\n\t\t\t\t{\n\t\t\t\t\tif (fld[j][ay] != '.') f = false;\n\t\t\t\t}\n\t\t\t\tif (f&&abs(ax - bx)>1)\n\t\t\t\t{\n\t\t\t\t\tupdate = true;\n\t\t\t\t\tv[i].clear();\n\t\t\t\t\tans++;\n\t\t\t\t\tfld[ax][ay] = fld[bx][by] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (ay > by)\n\t\t\t\t{\n\t\t\t\t\tswap(ax, bx), swap(ay, by);\n\t\t\t\t}\n\t\t\t\tif (ax > bx)\n\t\t\t\t{\n\t\t\t\t\tbool f1 = true;\n\t\t\t\t\tFOR(j, ay + 1, by)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (fld[ax][j] != '.') f1 = false;\n\t\t\t\t\t}\n\t\t\t\t\tFOR(j, bx + 1, ax + 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (fld[j][by] != '.') f1 = false;\n\t\t\t\t\t}\n\t\t\t\t\tbool f2 = true;\n\t\t\t\t\tFOR(j, bx, ax)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (fld[j][ay] != '.') f2 = false;\n\t\t\t\t\t}\n\t\t\t\t\tFOR(j, ay, by)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (fld[bx][j] != '.') f2 = false;\n\t\t\t\t\t}\n\t\t\t\t\tif (f1 || f2)\n\t\t\t\t\t{\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\tv[i].clear();\n\t\t\t\t\t\tans++;\n\t\t\t\t\t\tfld[ax][ay] = fld[bx][by] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ax < bx)\n\t\t\t\t{\n\t\t\t\t\tbool f1 = true;\n\t\t\t\t\tFOR(j, ay + 1, by+1)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (fld[ax][j] != '.') f1 = false;\n\t\t\t\t\t}\n\t\t\t\t\tFOR(j, ax, bx)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (fld[j][by] != '.') f1 = false;\n\t\t\t\t\t}\n\t\t\t\t\tbool f2 = true;\n\t\t\t\t\tFOR(j, ax+1, bx)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (fld[j][ay] != '.') f2 = false;\n\t\t\t\t\t}\n\t\t\t\t\tFOR(j, ay, by)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (fld[bx][j] != '.') f2 = false;\n\t\t\t\t\t}\n\t\t\t\t\tif (f1 || f2)\n\t\t\t\t\t{\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\tv[i].clear();\n\t\t\t\t\t\tans++;\n\t\t\t\t\t\tfld[ax][ay] = fld[bx][by] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans * 2 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\nusing namespace std;\n\nint M, N, K;\nchar S[550][550];\nint h, w;\nvector<int> y, x;\nvector<char> c;\nchar s[550][550];\nint dd[5] = { 0, 1, 0, -1, 0 };\n\nint compress(vector<int> &a) {\n  vector<int> v;\n\n  REP(i, 0, a.size()) v.push_back(a[i]);\n  sort(v.begin(), v.end());\n  v.erase(unique(v.begin(), v.end()), v.end());\n  REP(i, 0, a.size()) a[i] = find(v.begin(), v.end(), a[i]) - v.begin();\n\n  return (int) v.size();\n}\n\nbool isin(int y, int x) {\n  return 0 <= y && y < h && 0 <= x && x < w;\n}\n\nint main(void) {\n  cin >> M >> N;\n  K = 0;\n  REP(i, 0, M) REP(j, 0, N) {\n    cin >> S[i][j];\n    if(S[i][j] != '.') {\n      y.push_back(i);\n      x.push_back(j);\n      c.push_back(S[i][j]);\n      K++;\n    }\n  }\n  REP(i, 0, M) REP(j, 0, N) {\n    REP(k, 0, 4) {\n      y.push_back(y[i] + dd[k]);\n      x.push_back(x[i] + dd[k + 1]);\n    }\n  }\n\n  h = compress(y);\n  w = compress(x);\n\n  REP(i, 0, h) REP(j, 0, w) s[i][j] = '.';\n  REP(i, 0, K) s[y[i]][x[i]] = c[i];\n\n  int ans = 0;\n  bool visited[256];\n  REP(i, 0, 256) visited[i] = false;\n  bool f = true;\n  while(f) {\n    f = false;\n    REP(i, 0, h) REP(j, 0, w) {\n      if(s[i][j] == '.' || visited[s[i][j]]) {\n        int cnt[256];\n        REP(k, 0, 256) cnt[k] = 0;\n        REP(k, 0, 4) {\n          int ny = i + dd[k], nx = j + dd[k + 1];\n          while(isin(ny, nx)) {\n            if(s[ny][nx] != '.' && !visited[s[ny][nx]]) {\n              cnt[s[ny][nx]]++;\n              if(cnt[s[ny][nx]] == 2) {\n                visited[s[ny][nx]] = true;\n                ans += 2;\n                f = true;\n              }\n              break;\n            }\n            ny += dd[k];\n            nx += dd[k + 1];\n          }\n        }\n      }\n    }\n  }\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(a) ((int)(a).size())\n#define BIT(x, i) (((x) >> (i)) & 1)\n#define SQ(x) ((x)*(x))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<char> vc;\ntypedef vector<vector<char>> vvc;\n\nconst int dx[] = {-1,0,1,0}, dy[] = {0,1,0,-1};\n\nint H, W;\n\nint main() {\n    cin >> H >> W;\n    vvc field(H, vc(W));\n    vvll state(H, vll(W));\n    REP(y, H) REP(x, W) {\n        cin >> field[y][x];\n    }\n\n    vector<vector<pii>> char2pos(26, vector<pii>(2));\n    vb seen(26);\n    REP(y, H) REP(x, W) {\n        if (field[y][x] != '.') {\n            int c = field[y][x] - 'A';\n            if (seen[c]) {\n                char2pos[c][1] = {x, y};\n                field[y][x] += 0x20;\n            } else {\n                char2pos[c][0] = {x, y};\n                seen[c] = true;\n            }\n        }\n    }\n\n    int score = 0;\n    bool redo;\n    do {\n        redo = false;\n\n        REP(y, H) REP(x, W) {\n            if (field[y][x] != '.') {\n                ll s = 1LL << (field[y][x] - 'A');\n                REP(i, 4) {\n                    int sx = x + dx[i], sy = y + dy[i];\n                    while (0 <= sx && sx < W && 0 <= sy && sy < H &&\n                        field[sy][sx] == '.') {\n                        state[sy][sx] |= s;\n\n                        sx += dx[i];\n                        sy += dy[i];\n                    }\n                }\n            }\n        }\n\n        REP(y, H) REP(x, W) {\n            if (field[y][x] == '.') {\n                REP(c, 27) {\n                    if (seen[c]) {\n                        ll s = (1LL<<c) | (1LL<<(c+0x20));\n                        if ((state[y][x] & s) == s) {\n                            int sx, sy;\n                            sx = char2pos[c][0].first;\n                            sy = char2pos[c][0].second;\n                            field[sy][sx] = '.';\n                            sx = char2pos[c][1].first;\n                            sy = char2pos[c][1].second;\n                            field[sy][sx] = '.';\n                            seen[c] = false;\n                            score += 2;\n                            redo = true;\n                        }\n                    }\n                }\n            }\n        }\n    } while (redo);\n    cout << score << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef pair<int,int> P;\nint res=0;\nint m,n;\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nmap<int,vector<P>> pos;\n\nbool check(vector<string> &s, int sx,int sy){\n    map<int,int> mp;\n    int gx,gy;\n    bool f=false;\n    for(int i=0;i<4;i++){\n        gx=sx,gy=sy;\n        while(true){\n            gx += dx[i]; gy += dy[i];\n            if(gx<0 || m<=gx || gy<0 || n<=gy) break;\n            if(s[gx][gy]=='.') continue;\n            int idx=s[gx][gy]-'A';\n            if(mp[idx]){\n                res+=2;\n                f=true;\n                P p1=pos[idx][0],p2=pos[idx][1];\n                s[p1.first][p1.second]='.';\n                s[p2.first][p2.second]='.';\n            }\n            else mp[idx]++;\n            break;\n        }\n    }\n    return f;\n}\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin>>m>>n;\n    vector<string> s(m);\n    for(int i=0;i<m;i++){\n        cin>>s[i];\n        for(int j=0;j<n;j++){\n            if(s[i][j]=='.') continue;\n            int idx=s[i][j]-'A';\n            pos[idx].push_back(P(i,j));\n        }\n    }\n    while(true){\n        bool f=false;\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                if(s[i][j]!='.') continue;\n                f |= check(s,i,j);\n            }\n        }\n        if(!f) break;\n    }\n    cout<<res<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst int tx[] = {0,1,1,0};\nconst int ty[] = {0,0,1,1};\n \nstatic const double EPS = 1e-10;\n\nstruct Point {\n  int x;\n  int y;\n  Point(int _x,int _y) : x(_x) , y(_y) {}\n  bool operator ==(const Point& p) const{\n    return (x == p.x && y == p.y);\n  }\n};\n\nint main(){\n  int H,W;\n\n  while(~scanf(\"%d %d\",&H,&W)){\n    char stage[500][500];\n    map<char,vector<Point> > tiles;\n    for(int y=0;y<H;y++){\n      string line;\n      cin >> line;\n      for(int x=0;x<W;x++){\n\tstage[y][x] = line[x];\n\tif(stage[y][x] != '.'){\n\t  tiles[stage[y][x]].push_back(Point(x,y));\n\t}\n      }\n    }\n\n    int erased_count = 0;\n    bool erased[256];\n    memset(erased,false,sizeof(erased));\n    erased['.'] = true;\n\n    for(int round=0;round <= 500*500; round++){\n\n      bool update = false;\n      for(int target_char = 'A'; target_char <= 'Z'; target_char++){\n\tif(erased[target_char]) continue;\n\tif(tiles.find(target_char) == tiles.end()) continue;\n\t\n\tPoint p1(tiles[target_char][0].x,tiles[target_char][0].y);\n\tPoint p2(tiles[target_char][1].x,tiles[target_char][1].y);\n\n\tbool isok = true;\n\tif(p1.x == p2.x){\n\t  if(abs(p1.y-p2.y) == 1) isok = false;\n\n\t  int x = p1.x;\n\t  for(int y=min(p1.y,p2.y)+1;y<max(p1.y,p2.y);y++){\n\t    if(!erased[stage[y][x]]){\n\t      isok = false;\n\t      break;\n\t    }\n\t  }\n\t}\n\telse if(p1.y==p2.y){\n\t  if(abs(p1.x-p2.x) == 1) isok = false;\n\n\t  int y = p1.y;\n\t  for(int x=min(p1.x,p2.x)+1;x<max(p1.x,p2.x);x++){\n\t    if(!erased[stage[y][x]]){\n\t      isok = false;\n\t      break;\n\t    }\n\t  }\n\t}\n\telse{\n\n\t  vector<Point> medium;\n\t  bool can_found = false;\n\t  for(int i=0;i<tiles[target_char].size();i++){\n\t    for(int j=0;j<tiles[target_char].size();j++){\n\t      Point mid(tiles[target_char][i].x,tiles[target_char][j].y);\n\t      \n\t      if(mid == p1 || mid == p2) continue;\n\t      if(!erased[stage[mid.y][mid.x]]) continue;\n\n\t      //target p1.x,p1.y\n\t      int flag1 = 0;\n\t      for(int x = min(mid.x,p1.x);x <= max(mid.x,p1.x); x++){\n\t\tif(Point(x,p1.y) == p1) continue;\n\t\tif(!erased[stage[mid.y][x]]) flag1 |= 1;\n\t      }\n\n\t      for(int y = min(mid.y,p1.y); y<= max(mid.y,p1.y) ; y++){\n\t\tif(Point(p1.x,y) == p1) continue;\n\t\tif(!erased[stage[y][mid.x]]) flag1 |= (1<<1);\n\t      }\n\n\t      //target x2,y2\n\t      int flag2 = 0;\n\t      for(int x = min(mid.x,p2.x);x <= max(mid.x,p2.x); x++){\n\t\tif(Point(x,p2.y) == p2) continue;\n\t\tif(!erased[stage[mid.y][x]]) flag2 |= 1;\n\t      }\n\n\t      for(int y = min(mid.y,p2.y) ;y <= max(mid.y,p2.y) ; y++){\n\t\tif(Point(p2.x,y) == p2) continue;\n\t\tif(!erased[stage[y][mid.x]]) flag2 |= (1<<1);\n\t      }\n\n\t      if(flag1 == 0 && flag2 == 0){\n\t\tcan_found = true;\n\t      }\n\t    }\n\t  }\n\n\t  if(!can_found){\n\t    isok = false;\n\t  }\n\t}\n\tif(isok){\n\t  update = true;\n\t  erased[target_char] = true;\n\t  erased_count++;\n\t}\n      }\n\n      if(!update) break;\n    }\n    printf(\"%d\\n\",erased_count*2);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint m,n;\nvector<P> data[30];\nvector<int> xindex;\nvector<int> yindex;\nint field[250][250];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint pickl[4];\nint picklx[4];\nint pickly[4];\n\nint main(void){\n\tscanf(\"%d %d\",&n,&m);\n\tmemset(fie,0,sizeof(fie));\n\tfor(int i=0;i<n;i++){\n\t\tstring str;\n\t\tcin >> str;\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(str[j]>='A' && str[j]<='Z'){\n\t\t\t\tdata[str[j]-'A'+1].push_back(P(j,i));\n\t\t\t\tif(j-1>=0)xindex.push_back(j-1);\n\t\t\t\txindex.push_back(j);\n\t\t\t\tif(j+1<m)xindex.push_back(j+1);\n\t\t\t\tif(i-1>=0)yindex.push_back(i-1);\n\t\t\t\tyindex.push_back(i);\n\t\t\t\tif(i+1<n)yindex.push_back(i+1);\n\t\t\t}\n\t\t}\n\t}\n\tsort(xindex.begin(),xindex.end());\n\txindex.erase(unique(xindex.begin(),xindex.end()),xindex.end());\n\tsort(yindex.begin(),yindex.end());\n\tyindex.erase(unique(yindex.begin(),yindex.end()),yindex.end());\n\tfor(int i=1;i<=26;i++){\n\t\tfor(int j=0;j<data[i].size();j++){\n\t\t\tdata[i][j].first=lower_bound(xindex.begin(),xindex.end(),data[i][j].first)-xindex.begin();\n\t\t\tdata[i][j].second=lower_bound(yindex.begin(),yindex.end(),data[i][j].second)-yindex.begin();\n\t\t\tfield[data[i][j].first][data[i][j].second]=i;\n\t\t}\n\t}\n\tbool flag=true;\n\tint score=0;\n\twhile(flag){\n\t\tflag=false;\n\t\tfor(int i=0;i<yindex.size();i++){\n\t\t\tfor(int j=0;j<xindex.size();j++){\n\t\t\t\tif(field[j][i]==0){\n\t\t\t\t\tmemset(pickl,0,sizeof(pickl));\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tint xx=j,yy=i;\n\t\t\t\t\t\tint xi=xindex.size(),yi=yindex.size();\n\t\t\t\t\t\twhile(xx>=0 && xx<xi && yy>=0 && yy<yi){\n\t\t\t\t\t\t\tif(field[xx][yy]!=0)break;\n\t\t\t\t\t\t\txx+=dx[k];\n\t\t\t\t\t\t\tyy+=dy[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(field[xx][yy]!=0){\n\t\t\t\t\t\t\tpickl[k]=field[xx][yy];\n\t\t\t\t\t\t\tpicklx[k]=xx;\n\t\t\t\t\t\t\tpickly[k]=yy;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tfor(int l=k+1;l<4;l++){\n\t\t\t\t\t\t\tif(pickl[k]==pickl[l] && pickl[k]!=0){\n\t\t\t\t\t\t\t\tscore+=2;\n\t\t\t\t\t\t\t\tfield[picklx[k]][pickly[k]]=0;\n\t\t\t\t\t\t\t\tfield[picklx[l]][pickly[l]]=0;\n\t\t\t\t\t\t\t\tflag=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",score);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max() / 32 * 15 + 208;\n\nint main() {\n    int h, w;\n    cin >> h >> w;\n    array<int, 50> x1s{}, x2s{}, y1s{}, y2s{};\n    for (int i = 0; i < 50; ++i) {\n        x1s[i] = x2s[i] = y1s[i] = y2s[i] = -1;\n    }\n    vector<string> v(h);\n    for (int i = 0; i < h; ++i) {\n        string s;\n        cin >> s;\n        v[i] = s;\n        for (int j = 0; j < w; ++j) {\n            if(isalpha(s[j])){\n                if(!(~x1s[s[j]-'A'])){\n                    y1s[s[j]-'A'] = i; x1s[s[j]-'A'] = j;\n                }else {\n                    y2s[s[j]-'A'] = i; x2s[s[j]-'A'] = j;\n                }\n            }\n        }\n    }\n\n    int ok = 1, ans = 0;\n    while(ok){\n        ok = 0;\n        for (int i = 0; i < 26; ++i) {\n            if(!(~x1s[i])) continue;\n            int x1 = x1s[i], y1 = y1s[i], x2 = x2s[i], y2 = y2s[i];\n            if(x1 != x2 && y1 != y2){\n                int g = 1, gg = 1;\n                for (int j = min(x1, x2); j <= max(x1, x2); ++j) {\n                    if(j != x1) g &= (v[y1][j] == '.');\n                    if(j != x2) gg &= (v[y2][j] == '.');\n                }\n                for (int j = min(y1, y2); j <= max(y1, y2); ++j) {\n                    if(j != y1) gg &= (v[j][x1] == '.');\n                    if(j != y2) g &= (v[j][x2] == '.');\n                }\n                if(g | gg){\n                    ans += 2;\n                    ok = 1;\n                    x1s[i] = -1;\n                    v[y1][x1] = '.', v[y2][x2] = '.';\n                }\n            }else {\n                if(x1 == x2){\n                    int g = 1;\n                    if(abs(y1-y2) == 1) g = 0;\n                    for (int j = min(y1, y2)+1; j <= max(y1, y2)-1; ++j) {\n                        g &= (v[j][x1] == '.');\n                    }\n                    if(g){\n                        ans += 2;\n                        ok = 1;\n                        x1s[i] = -1;\n                        v[y1][x1] = '.', v[y2][x2] = '.';\n                    }\n                }else {\n                    int g = 1;\n                    if(abs(x1-x2) == 1) g = 0;\n                    for (int j = min(x1, x2)+1; j <= max(x1, x2)-1; ++j) {\n                        g &= (v[y1][j] == '.');\n                    }\n                    if(g){\n                        ans += 2;\n                        ok = 1;\n                        x1s[i] = -1;\n                        v[y1][x1] = '.', v[y2][x2] = '.';\n                    }\n                }\n            }\n        }\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint main() {\n\tint m, n;\n\tcin >> m >> n;\n\n\tvector<string> v(m);\n\trep(i, m) cin >> v[i];\n\n\tmap<char, vector<int> > x, y;\n\trep(i, m) {\n\t\trep(j, n) {\n\t\t\tif('A' <= v[i][j] && v[i][j] <= 'Z') {\n\t\t\t\ty[v[i][j]].push_back(i);\n\t\t\t\tx[v[i][j]].push_back(j);\n\t\t\t}\n\t\t}\n\t}\n\n\tset<char> st[30][2];\n\tbool used[30][2];\n\tmemset(used, 0, sizeof(used));\n\n\trep(i, 26) {\n\t\tchar c = 'A' + i;\n\t\tif(x[c].size() == 0) continue;\n\n\t\tif(x[c][0] == x[c][1]) {\n\t\t\tif(abs(y[c][0] - y[c][1]) == 1) continue;\n\t\t\tused[i][0] = true;\n\t\t\tint x1 = x[c][0];\n\t\t\tint y1 = y[c][0], y2 = y[c][1];\n\n\t\t\tREP(j, min(y1, y2) + 1, max(y1, y2)) {\n\t\t\t\tif(v[j][x1] == '.') continue;\n\t\t\t\tst[i][0].insert(v[j][x1]);\n\t\t\t}\n\t\t} else if(y[c][0] == y[c][1]) {\n\t\t\tif(abs(x[c][0] - x[c][1]) == 1) continue;\n\t\t\tused[i][0] = true;\n\t\t\tint y1 = y[c][0];\n\t\t\tint x1 = x[c][0], x2 = x[c][1];\n\t\t\tREP(j, min(x1, x2) + 1, max(x1, x2)) {\n\t\t\t\tif(v[y1][j] == '.') continue;\n\t\t\t\tst[i][0].insert(v[y1][j]);\n\t\t\t}\n\t\t} else {\n\t\t\tused[i][0] = true;\n\t\t\tused[i][1] = true;\n\t\t\tint x1 = x[c][0], x2 = x[c][1];\n\t\t\tint y1 = y[c][0], y2 = y[c][1];\n\n\t\t\tREP(j, min(x1, x2), max(x1, x2) + 1) {\n\t\t\t\tif(v[y1][j] == '.' || v[y1][j] == c) continue;\n\t\t\t\tst[i][0].insert(v[y1][j]);\n\t\t\t}\n\n\t\t\tREP(j, min(y1, y2), max(y1, y2) + 1) {\n\t\t\t\tif(v[j][x2] == '.' || v[j][x2] == c) continue;\n\t\t\t\tst[i][0].insert(v[j][x2]);\n\t\t\t}\n\n\t\t\tREP(j, min(y1, y2), max(y1, y2) + 1) {\n\t\t\t\tif(v[j][x1] == '.' || v[j][x1] == c) continue;\n\t\t\t\tst[i][1].insert(v[j][x1]);\n\t\t\t}\n\n\t\t\tREP(j, min(x1, x2), max(x1, x2) + 1) {\n\t\t\t\tif(v[y2][j] == '.' || v[y2][j] == c) continue;\n\t\t\t\tst[i][1].insert(v[y2][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint sum = 0;\n\twhile(true) {\n\t\tbool flag = true;\n\t\trep(i, 26) {\n\t\t\tchar c = 'A' + i;\n\n\t\t\trep(j, 2) {\n\t\t\t\tif(!used[i][j]) continue;\n\t\t\t\tif(st[i][j].size() == 0) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tused[i][j] = false;\n\t\t\t\t\tused[i][!j] = false;\n\n\t\t\t\t\trep(k, 26) {\n\t\t\t\t\t\trep(l, 2) {\n\t\t\t\t\t\t\tst[k][l].erase(c);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tsum += 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(flag) break;\n\t}\n\n\tcout << sum << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<VV> VVV;\ntypedef vector<vector<int>> Graph;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\nenum { X, Y, CHAR };\ntypedef vector<int> Tile;\n\nint H, W;\nvector<string> s;\n\n// N, E, S, W\nconst int dx[4] = {-1, 0,  1,  0};\nconst int dy[4] = { 0, 1,  0, -1};\n\ninline bool inside(int x, int y) {\n    return 0 <= x && x < H && 0 <= y && y < W;\n}\n\nTile findNearestTile(int x, int y, int k) {\n    if (!inside(x, y) || s[x][y] == '#') return Tile{-1, -1, -1};\n    if (isalpha(s[x][y])) return Tile{x, y, s[x][y] - 'A'};\n    return findNearestTile(x + dx[k], y + dy[k], k);\n}\n\nbool hit(int sx, int sy) {\n    if (s[sx][sy] == '#') return false;\n    if (isalpha(s[sx][sy])) {\n        rep(k, 4) {\n            int nx = sx + dx[k], ny = sy + dy[k];\n            if (!inside(nx, ny)) continue;\n            if (s[sx][sy] == s[nx][ny]) {\n                s[sx][sy] = '.';\n                s[nx][ny] = '.';\n                return true;\n            }\n        }\n        return false;\n    }\n\n    rep(start, 4) {\n        Tile tile1{-1, -1, -1};\n        rep(k, 4) {\n            Tile tile2 = findNearestTile(sx, sy, (k + start) % 4);\n            if (tile2[CHAR] == -1) {\n                continue;\n            } else if (tile1[CHAR] == -1) {\n                tile1 = tile2;\n            } else if (tile1[CHAR] == tile2[CHAR]) {\n                s[tile1[X]][tile1[Y]] = '.';\n                s[tile2[X]][tile2[Y]] = '.';\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nbool search() {\n    rep(i, H) {\n        rep(j, W) {\n            if (hit(i, j)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nbool checkCompress(string line) {\n    for (const auto& c : line) {\n        if (c != '.') return false;\n    }\n    return true;\n}\n\nvoid compress(vector<string> &s) {\n    for (int i = 0; i < s.size(); ) {\n        if (checkCompress(s[i])) {\n            s.erase(s.begin() + i);\n        } else {\n            i++;\n        }\n    }\n}\n\nvoid rot(vector<string> &s) {\n    vector<string> t(s[0].size(), \"\");\n    rep(i, s.size()) rep(j, s[0].size()) {\n        t[j] += s[i][j];\n    }\n    s = t;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    cin >> H >> W;\n    s.resize(H);\n    rep(i, H) cin >> s[i];\n\n    rep(x, H) {\n        rep(y, W) {\n            rep(k, 4) {\n                int nx = x + dx[k], ny = y + dy[k];\n                if (!inside(nx, ny)) continue;\n                if (isalpha(s[x][y]) && s[x][y] == s[nx][ny]) {\n                    s[x][y] = '#';\n                    s[nx][ny] = '#';\n                }\n            }\n        }\n    }\n\n    compress(s);\n    if (s.empty()) {\n        cout << 0 << endl;\n        return 0;\n    }\n    rot(s);\n    compress(s);\n    rot(s);\n\n    H = s.size(), W = s[0].size();\n\n    int ans = 0;\n    while (search()) {\n        ans += 2;\n    }\n\n    cout << ans << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\nconst int NONE = 0;\nconst int VERTICAL = 1;\nconst int HORIZONTAL = 2;\nconst int CORNER = 3;\n\nint main() {\n\tint M, N;\n\tcin >> M >> N;\n\n\tvs field(M);\n\tvvi pos(26, vi(4, -1));\n\tREP(i, M) {\n\t\tcin >> field[i];\n\t\tREP(j, N) {\n\t\t\tif(field[i][j] != '.') {\n\t\t\t\tint k = field[i][j]-'A';\n\t\t\t\tif(pos[k][0] == -1) {\n\t\t\t\t\tpos[k][0] = i;\n\t\t\t\t\tpos[k][1] = j;\n\t\t\t\t} else {\n\t\t\t\t\tpos[k][2] = i;\n\t\t\t\t\tpos[k][3] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvi type(26, CORNER);\n\tREP(i, 26) {\n\t\tif(pos[i][2] == -1) {\n\t\t\ttype[i] = NONE;\n\t\t\tcontinue;\n\t\t}\n\t\tif(abs(pos[i][0]-pos[i][2]+pos[i][1]-pos[i][3]) == 1) {\n\t\t\ttype[i] = NONE;\n\t\t\tcontinue;\n\t\t}\n\t\tif(pos[i][0] == pos[i][2]) {\n\t\t\ttype[i] = VERTICAL;\n\t\t\tcontinue;\n\t\t}\n\t\tif(pos[i][1] == pos[i][3]) {\n\t\t\ttype[i] = HORIZONTAL;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tint ans = 0;\n\tbool updated = true;\n\twhile(updated) {\n\t\tupdated = false;\n\t\tREP(i, 26) {\n\t\t\tif(type[i] == NONE) {\n\t\t\t\n\t\t\t} else if(type[i] == VERTICAL) {\n\t\t\t\tint y = pos[i][0];\n\t\t\t\tFOR(x, min(pos[i][1], pos[i][3])+1, max(pos[i][1], pos[i][3])-1) {\n\t\t\t\t\tif(field[y][x] != '.') {\n\t\t\t\t\t\tgoto next;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans += 2;\n\t\t\t\ttype[i] = NONE;\n\t\t\t\tfield[pos[i][0]][pos[i][1]] = field[pos[i][2]][pos[i][3]] = '.';\n\t\t\t\tupdated = true;\n\t\t\t\tbreak;\n\t\t\t} else if(type[i] ==  HORIZONTAL) {\n\t\t\t\tint x = pos[i][1];\n\t\t\t\tFOR(y, min(pos[i][0], pos[i][2])+1, max(pos[i][0], pos[i][2])-1) {\n\t\t\t\t\tif(field[y][x] != '.') {\n\t\t\t\t\t\tgoto next;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans += 2;\n\t\t\t\ttype[i] = NONE;\n\t\t\t\tfield[pos[i][0]][pos[i][1]] = field[pos[i][2]][pos[i][3]] = '.';\n\t\t\t\tupdated = true;\n\t\t\t\tbreak;\n\t\t\t} else if(type[i] == CORNER) {\n\t\t\t\tint miny = min(pos[i][0], pos[i][2]);\n\t\t\t\tint maxy = max(pos[i][0], pos[i][2]);\n\t\t\t\tint minx = min(pos[i][1], pos[i][3]);\n\t\t\t\tint maxx = max(pos[i][1], pos[i][3]);\n\t\t\t\tbool li1 = false, li2 = false, li3 = false, li4 = false;\n\n\t\t\t\tl1:\n\t\t\t\tFOR(y, miny, maxy) {\n\t\t\t\t\tif(field[y][minx] != '.' && field[y][minx] != 'A'+i) {\n\t\t\t\t\t\tgoto l2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tli1 = true;\n\n\t\t\t\tl2:\n\t\t\t\tFOR(x, minx, maxx) {\n\t\t\t\t\tif(field[maxy][x] != '.' && field[maxy][x] != 'A'+i) {\n\t\t\t\t\t\tgoto l3;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tli2 = true;\n\n\t\t\t\tl3:\n\t\t\t\tFOR(y, miny, maxy) {\n\t\t\t\t\tif(field[y][maxx] != '.' && field[y][maxx] != 'A'+i) {\n\t\t\t\t\t\tgoto li4;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tli3 = true;\n\n\t\t\t\tli4:\n\t\t\t\tFOR(x, minx, maxx) {\n\t\t\t\t\tif(field[miny][x] != '.' && field[miny][x] != 'A'+i) {\n\t\t\t\t\t\tgoto check;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tli4 = true;\n\n\t\t\t\tcheck:\n\t\t\t\tif(pos[i][0] == miny && pos[i][1] == minx) {\n\t\t\t\t\tif((li1&li2) || (li3&li4)) {\n\t\t\t\t\t\tgoto ok;\n\t\t\t\t\t}\n\t\t\t\t} else if(pos[i][2] == miny && pos[i][3] == minx) {\n\t\t\t\t\tif((li1&li2) || (li3&li4)) {\n\t\t\t\t\t\tgoto ok;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif((li1&li4) || (li2&li3)) {\n\t\t\t\t\t\tgoto ok;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgoto next;\n\n\t\t\t\tok:;\n\t\t\t\t\tans += 2;\n\t\t\t\t\ttype[i] = NONE;\n\t\t\t\t\tfield[pos[i][0]][pos[i][1]] = field[pos[i][2]][pos[i][3]] = '.';\n\t\t\t\t\tupdated = true;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnext:;\n\t\t}\n\t\t/*\n\t\tcout << \"----------\" << endl;\n\t\tREP(i, M) {\n\t\t\tcout << field[i] << endl;\n\t\t}\n\t\t*/\n\t}\n\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define int long long\n\nint dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\nbool ok(int x, int y, int w, int h) {\n\treturn x >= 0 && y >= 0 && w > x && h > y;\n}\n\nsigned main() {\n\tint h, w;\n\tcin >> h >> w;\n\tvector<string> s(h);\n\tmap<char, vector<pair<int, int>>> mp;\n\trep(y, h) {\n\t\tcin >> s[y];\n\t\trep(x, w) {\n\t\t\tif (s[y][x] != '.') {\n\t\t\t\tmp[s[y][x]].push_back(make_pair(y, x));\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\twhile (1) {\n\t\tbool end = true;\n\t\tfor (char c = 'A'; c <= 'Z'; c++) {\n\t\t\tif (mp[c].size() == 0)continue;\n\t\t\t[&]() {\n\t\t\t\trep(i, 4)rep(j, 4) {\n\t\t\t\t\tbool rm = false;\n\t\t\t\t\tint iy = mp[c][0].first, ix = mp[c][0].second;\n\t\t\t\t\tint jy = mp[c][1].first, jx = mp[c][1].second;\n\t\t\t\t\tint ay = iy + dy[i], ax = ix + dx[i];\n\t\t\t\t\tint by = jy + dy[j], bx = jx + dx[j];\n\n\t\t\t\t\tset<pair<int, int>> av;\n\t\t\t\t\twhile (ok(ax, ay, w, h)) {\n\t\t\t\t\t\tif (s[ay][ax] == '.') {\n\t\t\t\t\t\t\tav.insert(make_pair(ay, ax));\n\t\t\t\t\t\t\tay += dy[i]; ax += dx[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse break;\n\t\t\t\t\t}\n\t\t\t\t\twhile (ok(bx, by, w, h)) {\n\t\t\t\t\t\tif (s[by][bx] == '.') {\n\t\t\t\t\t\t\tif (av.count(make_pair(by, bx))) {\n\t\t\t\t\t\t\t\trm = true; break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tby += dy[j]; bx += dx[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse break;\n\t\t\t\t\t}\n\t\t\t\t\tif (rm) {\n\t\t\t\t\t\ts[iy][ix] = '.';\n\t\t\t\t\t\ts[jy][jx] = '.';\n\t\t\t\t\t\tmp[c].clear();\n\t\t\t\t\t\tans += 2;\n\t\t\t\t\t\tend = false;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}();\n\t\t}\n\t\tif (end)break;\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nusing namespace std;\nint main(void)\n{\n  int m,n;\n  cin >> m >> n;\n  vector<string> fi(m);\n  REP(i,m) cin >> fi[i];\n  int answer=0;\n  REP(i,m) REP(j,n) if(fi[i][j]=='.') --answer;\n  vector<bool> exi(m,false),exj(n,false);\n  REP(i,m) REP(j,n) if(fi[i][j]!='.'){\n    exi[i]=true;\n    exj[j]=true;\n  }\n  bool flag=true;\n  while(flag){\n    flag=false;\n    REP(i,m){\n      if(!exi[i]) continue;\n      REP(j,n){\n\tif(!exj[j]) continue;\n\tif(fi[i][j]!='.') continue;\n\tvector<int> x,y;\n\tfor(int k=i-1;k>=0;--k){\n\t  if(fi[k][j]!='.'){\n\t    x.push_back(k);\n\t    y.push_back(j);\n\t    break;\n\t  }\n\t}\n\tfor(int k=i+1;k<m;++k){\n\t  if(fi[k][j]!='.'){\n\t    x.push_back(k);\n\t    y.push_back(j);\n\t    break;\n\t  }\n\t}\n\tfor(int k=j-1;k>=0;--k){\n\t  if(fi[i][k]!='.'){\n\t    x.push_back(i);\n\t    y.push_back(k);\n\t    break;\n\t  }\n\t}\n\tfor(int k=j+1;k<n;++k){\n\t  if(fi[i][k]!='.'){\n\t    x.push_back(i);\n\t    y.push_back(k);\n\t    break;\n\t  }\n\t}\n\tREP(k,x.size()) REP(l,k){\n\t  if(fi[x[k]][y[k]]==fi[x[l]][y[l]]){\n\t    fi[x[k]][y[k]]='.';\n\t    fi[x[l]][y[l]]='.';\n\t    flag=true;\n\t  }\n\t}\n      }\n    }\n  }\n  REP(i,m) REP(j,n) if(fi[i][j]=='.') ++answer;\n  cout << answer << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define lp(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, n) lp(i, 0, n)\n#define rlp(i, a, b) for (int i = (int)(b) - 1; i >= (int)(a); i--)\n#define rrep(i, n) rlp(i, 0, n)\n\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n#define all(c) begin(c), end(c)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\ntemplate<typename T>\ninline bool chmin(T &a, T b){\n\tif (a <= b) return false;\n\ta = b; return true;\n}\n\ntemplate<typename T>\ninline bool chmax(T &a, T b){\n\tif (a >= b) return false;\n\ta = b; return true;\n}\n\ntemplate<typename T>\ninline void unique(T &c){\n\tsort(all(c));\n\tc.erase(unique(all(c)), end(c));\n}\n\ntemplate<typename T>\ninline T sq(T a){\n\treturn a * a;\n}\n\ntemplate<typename T>\ninline size_t index_of(vector<T> &c, T x){\n\treturn lower_bound(all(c), x) - begin(c);\n}\n\nint m, n;\nvector<tuple<char, int, int>> v;\nvector<int> zx, zy;\nchar g[60][60];\n\nint main()\n{\n\tcin >> m >> n;\n\trep(i, m) rep(j, n){\n\t\tchar c;\n\t\tcin >> c;\n\t\tif (c != '.'){\n\t\t\tv.eb(c, i, j);\n\t\t\tzx.pb(i); zy.pb(j);\n\t\t}\n\t}\n\tunique(zx); unique(zy);\n\tm = zx.size(); n = zy.size();\n\tmemset(g, '.', sizeof(g));\n\tfor (auto &t : v){\n\t\tchar c; int x, y;\n\t\ttie(c, x, y) = t;\n\t\tg[index_of(zx, x)][index_of(zy, y)] = c;\n\t}\n\tint res = 0;\n\trep(k, 26) rep(x, m) rep(y, n){\n\t\tif (g[x][y] != '.') continue;\n\t\tmap<char, vector<pair<int, int>>> cnt;\n\t\trep(dir, 4){\n\t\t\tint xx = x, yy = y;\n\t\t\twhile (true){\n\t\t\t\txx += dx[dir], yy += dy[dir];\n\t\t\t\tif (xx < 0 || xx >= m || yy < 0 || yy >= n) break;\n\t\t\t\tif (g[xx][yy] != '.'){\n\t\t\t\t\tcnt[g[xx][yy]].eb(xx, yy);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (auto &t : cnt){\n\t\t\tif (t.second.size() < 2) continue;\n\t\t\tfor (auto &p : t.second){\n\t\t\t\tg[p.first][p.second] = '.';\n\t\t\t}\n\t\t\tres += 2;\n\t\t}\n\t}\n\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define x first\n#define y second\nusing namespace std;\ntypedef pair <int,int> P;\nstring mp[501];\nint m,n,used[30];\nvector <P>  a[30];\n\nint saiki(int);\n\nbool check_x(int y,int x1,int x2){\n    for(int i=x1+1;i<x2;i++)\n    if(mp[y][i]!='.'&&!saiki(mp[y][i]-'A'))return 0;\n  return 1;\n}\n\nbool check_y(int y1,int y2,int x){\n    for(int i=y1+1;i<y2;i++)\n    if(mp[i][x]!='.'&&!saiki(mp[i][x]-'A')) return 0;\n    return 1;\n}\n\nvoid out(){\n  //  for(int i=0;i<m;i++)cout<<mp[i]<<endl;\n\n}\n\n\nint saiki(int ch){\n  \n  int x1=a[ch][0].x,x2=a[ch][1].x;\n  int y1=a[ch][0].y,y2=a[ch][1].y;\n  int res=0;\n  if(used[ch]||mp[y1][x1]=='.')return 0;\n  used[ch]=1;\n  \n  if(x1==x2&&y2-y1!=1) res=check_y(y1,y2,x1);\n  if(y1==y2&&x2-x1!=1) res=check_x(y1,x1,x2);\n  if(x1!=x2&&y1!=y2) {\n    if(x1<x2){\n    res=check_x(y1,x1,x2+1)&check_y(y1,y2,x2);\n    res|=check_y(y1,y2+1,x1)&check_x(y2,x1,x2);\n    }\n    else{\n      swap(x1,x2);\n      res=check_x(y1,x1-1,x2)&check_y(y1,y2,x1);\n      res |=check_y(y1,y2,x2)&check_x(y2,x1,x2+1);\n      swap(x1,x2);\n    }\n  }\n    \n\n  if(res) mp[y1][x1]=mp[y2][x2]='.';\n  //  cout<<(char)(ch+'A')<<endl;\n  // out();cout<<endl;\n  used[ch]=0;\n  return res;\n}\n\nint main(){\n\n  cin>>m>>n;\n  for(int i=0;i<m;i++)cin>>mp[i];\n  for(int i=0;i<m;i++) a[i].clear();\n  for(int i=0;i<30;i++) used[i]=0;\n\n  int ans=0;  \n  for(int i=0;i<m;i++)\n    for(int j=0;j<n;j++)\n      if(mp[i][j]!='.')a[mp[i][j]-'A'].push_back(P(j,i)),ans++;\n  \n  int flg=1;\n  while(flg){\n    flg=0;\n    for(int i=0;i<30;i++)if(a[i].size()) flg|=saiki(i);\n}\n  for(int i=0;i<m;i++)\n    for(int j=0;j<n;j++) if(mp[i][j]!='.') ans--;\n\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nint main() {\n  int m,n;\n  cin>>m>>n;\n  vector<string> t(m);\n  REP(i,m)cin>>t[i];\n  vector<int> iv,jv;\n  REP(i,m) {\n    bool al = true;\n    REP(j,n) if(t[i][j] != '.') al = false;\n    if(!al)\n      iv.push_back(i);\n  }\n  REP(i,n) {\n    bool al = true;\n    REP(j,m) if(t[j][m] != '.') al = false;\n    if(!al)\n      jv.push_back(i);\n  }\n  vector<string> ct(iv.size());\n  m = iv.size();\n  n = jv.size();\n  REP(i,m)\n    REP(j,n)\n      ct[i] += t[iv[i]][jv[j]];\n  int score = 0;\n  while(1){\n    set<char> er;\n    REP(i,m)REP(j,n){\n      if (ct[i][j] != '.') continue;\n      map<char, int> s;\n      int di[]={1,0,-1,0};\n      int dj[]={0,1,0,-1};\n      REP(k,4){\n        int l=1;\n        while(1){\n          int ni=i+di[k]*l;\n          int nj=j+dj[k]*l;\n          if(ni<0||nj<0||ni>=m||nj>=n) break;\n          if(ct[ni][nj] != '.'){\n            ++s[ct[ni][nj]];\n            break;\n          }\n          ++l;\n        }\n      }\n      for (auto p:s) {\n        if(p.second == 2) er.insert(p.first);\n      }\n    }\n    score += er.size()*2;\n    if (er.empty()) break;\n    REP(i,m)REP(j,n){\n      if(er.count(ct[i][j]))\n        ct[i][j] = '.';\n    }\n  }\n  cout << score << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define x first\n#define y second\nusing namespace std;\ntypedef pair <int,int> P;\nstring mp[501];\nint m,n,used[30],ans;\nvector <P>  a[30];\n\nint saiki(int);\n\nbool check(int c,int s,int t,int f){\n  int res=1;\n  for(int i=s+1;i<t;i++){\n    if(!f&&mp[i][c]!='.'&&!saiki(mp[i][c]-'A'))res=0;\n    if(f&&mp[c][i]!='.'&&!saiki(mp[c][i]-'A'))res=0;\n  }\n  return res;\n}\n\nint saiki(int ch){\n  int x1=a[ch][0].x,x2=a[ch][1].x;\n  int y1=a[ch][0].y,y2=a[ch][1].y;\n  int res=0;\n  if(used[ch])return 0;\n  used[ch]=1;\n  \n  if(x1==x2&&y2-y1!=1) res=check(x1,y1,y2,0);\n  if(y1==y2&&x2-x1!=1) res=check(y1,x1,x2,1);\n  \n  if(x1!=x2&&y1!=y2) {\n    if(x1<x2){\n      res=check(y1,x1,x2+1,1)&check(x2,y1,y2,0);\n      res|=check(x1,y1,y2+1,0)&check(y2,x1,x2,1);\n    }\n    else{\n      swap(x1,x2);\n      res=check(y1,x1-1,x2,1)&check(x1,y1,y2,0);\n      res|= check(x2,y1,y2,0)&check(y2,x1,x2+1,1);\n      swap(x1,x2);\n    }\n  }\n  \n  if(res) {\n    mp[y1][x1]=mp[y2][x2]='.';\n    a[ch].clear();\n    ans+=2;\n  }\n  return res;\n}\n\nint main(){\n  \n  cin>>m>>n;\n  for(int i=0;i<m;i++)cin>>mp[i];\n  \n  for(int i=0;i<m;i++)\n    for(int j=0;j<n;j++)\n      if(mp[i][j]!='.')a[mp[i][j]-'A'].push_back(P(j,i));\n  \n  \n  for(int i=0;i<30;i++){\n    memset(used,0,sizeof(used));\n    if(a[i].size()) saiki(i);\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nvector<string> s;\nint n, m, ans;\n\nbool isin(int i, int j){\n    return i >= 0 && j >= 0 && i < n && j < m;\n}\n\nvoid poyo(){\n    int pa = ans;\n    REP(i,n) REP(j,m){\n        if (s[i][j] != '.') continue;\n        int si[4], sj[4];\n        char c[] = \"....\";\n        int di[] = {1,0,-1,0}, dj[] = {0,1,0,-1};\n        REP(k,4){\n            int ii = i, jj = j;\n            while (isin(ii,jj)){\n                if (s[ii][jj] != '.'){\n                    c[k] = s[ii][jj];\n                    si[k] = ii;\n                    sj[k] = jj;\n                    break;\n                }\n                ii += di[k];\n                jj += dj[k];\n            }\n        }\n        FOR(k,1,3) REP(l,k){\n            if (c[k] != '.' && c[k] == c[l]){\n                ans += 2;\n                s[si[k]][sj[k]] = '.';\n                s[si[l]][sj[l]] = '.';\n            }\n        }\n    }\n    if (ans != pa) poyo();\n}\n\nint main() {\n    cin >> n >> m;\n    s.resize(n);\n    REP(i,n) cin >> s[i];\n\n    poyo();\n\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nstring grid[500];\nint posy[26][2],posx[26][2];\nint pos[26][2][2];\nbool use[26];\nint n,m;\nint res;\n\nbool cluck(int y,int x){\n  int k;\n  int cnt[26];\n  for(int i=0;i<26;i++)cnt[i] = 0;\n\n  k = 1;\n  while(y+k<n && grid[y+k][x] == '.')k++;\n  if(y+k<n)cnt[grid[y+k][x]-'A']++;\n  \n  k = 1;\n  while(x+k<m && grid[y][x+k] == '.')k++;\n  if(x+k<m)cnt[grid[y][x+k]-'A']++;\n\n  k = 1;\n  while(y-k>=0 && grid[y-k][x] == '.')k++;\n  if(y-k>=0)cnt[grid[y-k][x]-'A']++;\n\n  k = 1;\n  while(x-k>=0 && grid[y][x-k] == '.')k++;\n  if(x-k>=0)cnt[grid[y][x-k]-'A']++;   \n\n  bool f = false;\n  for(int i=0;i<26;i++){\n    if(cnt[i]==2){\n      res += 2;\n      grid[posy[i][0]][posx[i][0]] ='.';\n      grid[posy[i][1]][posx[i][1]] ='.';\n      use[i] = false;\n      f = true;\n    }\n  }\n  return f;\n}\n\nint main(){\n  cin >> n >> m;\n  for(int i=0;i<n;i++)cin >> grid[i];\n\n  for(int i=0;i<26;i++){\n    posy[i][0] = -1;\n    posx[i][0] = -1;\n    posy[i][1] = -1;\n    posx[i][1] = -1;\n    use[i] = false;\n  }\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<m;j++){\n      if(grid[i][j] != '.'){\n\tif(posy[grid[i][j]-'A'][0]<0){\n\t  posy[grid[i][j]-'A'][0] = i;\n\t  posx[grid[i][j]-'A'][0] = j;\n\t  use[grid[i][j]-'A'] = true;\n\t}else{\n\t  posy[grid[i][j]-'A'][1] = i;\n\t  posx[grid[i][j]-'A'][1] = j;\n\t}\n      }\n    }\n  }\n\n  res = 0;\n  while(1){\n    bool f = false;\n    for(int i=0;i<26;i++){\n      if(use[i]){\n\tif(posy[i][0] == posy[i][1]){\n\t  for(int j=posx[i][0]+1;j<posx[i][1];j++){\n\t    if(grid[posy[i][0]][j]=='.')f |= cluck(posy[i][0],j);\n\t  }\n\t}else if(posx[i][0] == posx[i][1]){\n\t  for(int j=posy[i][0]+1;j<posy[i][1];j++){\n\t    if(grid[j][posx[i][0]]=='.')f |= cluck(j,posx[i][0]);\n\t  }\n\t}else{\n\t  if(grid[posy[i][0]][posx[i][1]] == '.')f |= cluck(posy[i][0],posx[i][1]);\n\t  if(grid[posy[i][1]][posx[i][0]] == '.')f |= cluck(posy[i][1],posx[i][0]);\n\t}\n      }\n    }\n    if(!f)break;\n  }\n\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint m,n;\nvector<P> data[30];\nvector<int> xindex;\nvector<int> yindex;\nint fie[60][60];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint pick[4];\nint pickx[4];\nint picky[4];\n\nint main(void){\n\tscanf(\"%d %d\",&n,&m);\n\tfor(int i=0;i<n;i++){\n\t\tstring str;\n\t\tcin >> str;\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(str[j]>='A' && str[j]<='Z'){\n\t\t\t\tdata[str[j]-'A'+1].push_back(P(j,i));\n\t\t\t\txindex.push_back(j);\n\t\t\t\tyindex.push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tsort(xindex.begin(),xindex.end());\n\txindex.erase(unique(xindex.begin(),xindex.end()),xindex.end());\n\tyindex.erase(unique(yindex.begin(),yindex.end()),yindex.end());\n\tfor(int i=1;i<=26;i++){\n\t\tfor(int j=0;j<data[i].size();j++){\n\t\t\tdata[i][j].first=lower_bound(xindex.begin(),xindex.end(),data[i][j].first)-xindex.begin();\n\t\t\tdata[i][j].second=lower_bound(yindex.begin(),yindex.end(),data[i][j].second)-yindex.begin();\n\t\t\tfie[data[i][j].first][data[i][j].second]=i;\n\t\t}\n\t}\n\tbool flag=true;\n\tint score=0;\n\twhile(flag){\n\t\tflag=false;\n\t\tfor(int i=0;i<yindex.size();i++){\n\t\t\tfor(int j=0;j<xindex.size();j++){\n\t\t\t\tif(fie[j][i]==0){\n\t\t\t\t\tmemset(pick,0,sizeof(pick));\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tint x=j,y=i;\n\t\t\t\t\t\twhile((x>=0 && x<xindex.size() && y>=0 && y<yindex.size()) && fie[x][y]==0){\n\t\t\t\t\t\t\tx+=dx[k];\n\t\t\t\t\t\t\ty+=dy[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(fie[x][y]!=0){\n\t\t\t\t\t\t\tpick[k]=fie[x][y];\n\t\t\t\t\t\t\tpickx[k]=x;\n\t\t\t\t\t\t\tpicky[k]=y;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tfor(int l=k+1;l<4;l++){\n\t\t\t\t\t\t\tif(pick[k]==pick[l] && pick[k]!=0){\n\t\t\t\t\t\t\t\tscore+=2;\n\t\t\t\t\t\t\t\tfie[pickx[k]][picky[k]]=0;\n\t\t\t\t\t\t\t\tfie[pickx[l]][picky[l]]=0;\n\t\t\t\t\t\t\t\tflag=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",score);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//35\n#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nstruct P{\n  char c;\n  int x,y;\n  bool operator<(P a)const{\n    if(c!=a.c){\n      return c<a.c;\n    }else{\n      return x<a.x;\n    }\n  }\n};\n\nint main(){\n  int m,n;\n  cin>>m>>n;\n  vector<P> v;\n  for(int i=0;i<m;i++){\n    for(int j=0;j<n;j++){\n      char c;\n      cin>>c;\n      if(c!='.'){\n\tP p={c,j,i};\n\tv.push_back(p);\n      }\n    }\n  }\n  sort(v.begin(),v.end());\n  int s=0;\n  for(;;){\n    int b=s;\n    for(int i=0;i<v.size();i+=2){\n      if(v[i].x==v[i+1].x){\n\tif(abs(v[i].y-v[i+1].y)==1)goto next;\n\tfor(int j=0;j<v.size();j++){\n\t  if(v[j].x==v[i].x&&min(v[i].y,v[i+1].y)<v[j].y&&v[j].y<max(v[i].y,v[i+1].y))goto next;\n\n\t}\n\tv.erase(v.begin()+i,v.begin()+i+2);\n\ts+=2;\n\tbreak;\n      }else if(v[i].y==v[i+1].y){\n\tif(abs(v[i].x-v[i+1].x)==1)goto next;\n\tfor(int j=0;j<v.size();j++){\n\t  if(v[j].y==v[i].y&&min(v[i].x,v[i+1].x)<v[j].x&&v[j].x<max(v[i].x,v[i+1].x))goto next;\n\n\t}\n\tv.erase(v.begin()+i,v.begin()+i+2);\n\ts+=2;\n\tbreak;\n      }else{\n\tbool o[2]={};\n\tfor(int j=0;j<v.size();j++){\n\t  if(v[i].y<v[i+1].y){\n\t    o[0]|=(v[i].y==v[j].y&&v[i].x<v[j].x&&v[j].x<=v[i+1].x)\n\t      ||(v[i+1].x==v[j].x&&v[i].y<=v[j].y&&v[j].y<v[i+1].y);\n\t    o[1]|=(v[i].x==v[j].x&&v[i].y<v[j].y&&v[j].y<=v[i+1].y)\n\t      ||(v[i+1].y==v[j].y&&v[i].x<=v[j].x&&v[j].x<v[i+1].x);\n\t  }else{\n\t    o[0]|=(v[i].y==v[j].y&&v[i].x<v[j].x&&v[j].x<=v[i+1].x)\n\t      ||(v[i+1].x==v[j].x&&v[i+1].y<v[j].y&&v[j].y<=v[i].y);\n\t    o[1]|=(v[i].x==v[j].x&&v[i+1].y<=v[j].y&&v[j].y<v[i].y)\n\t      ||(v[i+1].y==v[j].y&&v[i].x<=v[j].x&&v[j].x<v[i+1].x);\n\t  }\n\t}\n\tif(o[0]&&o[1])goto next;\n\tv.erase(v.begin()+i,v.begin()+i+2);\n\ts+=2;\n\tbreak;\n      }\n    next:\n      ;\n    }\n    if(b==s)break;\n  }\n  cout<<s<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\nchar b[555][555];\nint h,w;\n\nint dfs(){\n\tint res=0;\n\trep(i,h)rep(j,w){\n\t\tif(b[i][j]!='.')continue;\n\t\t//dbg(i);dbg(j);\n\t\tvector<P> tile;\n\t\tvector<P> savt;\n\t\tvector<char> savc;\n\t\tint x1,x2;\n\t\tx1=x2=j;\n\t\tint y1,y2;\n\t\ty1=y2=i;\n\t\tint point=0;\n\t\twhile(x1>=0&&b[i][x1]=='.')x1--;\n\t\tif(x1>=0)tile.pb(P(i,x1));\n\t\twhile(x2<w&&b[i][x2]=='.')x2++;\n\t\tif(x2<w)tile.pb(P(i,x2));\n\t\twhile(y1>=0&&b[y1][j]=='.')y1--;\n\t\tif(y1>=0)tile.pb(P(y1,j));\n\t\twhile(y2<h&&b[y2][j]=='.')y2++;\n\t\tif(y2<h)tile.pb(P(y2,j));\n\t\t//dbg(x1); dbg(x2);dbg(y1);dbg(y2);\n\t\trep(k,tile.size())rep(l,k){\n\t\t\tP t1=tile[k],t2=tile[l];\n\t\t\tif(b[t1.fi][t1.se]!='.'&&b[t1.fi][t1.se]==b[t2.fi][t2.se]){\n\t\t\t\tsavt.pb(t1);\n\t\t\t\tsavt.pb(t2);\n\t\t\t\tsavc.pb(b[t1.fi][t1.se]);\n\t\t\t\tb[t1.fi][t1.se]=b[t2.fi][t2.se]='.';\n\t\t\t\tpoint+=2;\n\t\t\t}\n\t\t}\n\t\tif(point>0)maxch(res,dfs()+point);\n\t\trep(k,savc.size()){\n\t\t\tP t1=savt[k*2],t2=savt[k*2+1];\n\t\t\tb[t1.fi][t1.se]=b[t2.fi][t2.se]=savc[k];\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n\tcin>>h>>w;\n\trep(i,h)cin>>b[i];\n\tint res=dfs();\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n, m; cin >> n >> m;\n  V<string> t(n); for (auto&& e : t) cin >> e;\n  V<string> s;\n  for (int i = 0; i < n; ++i) {\n    if (i + 1 < n and count(begin(t[i]), end(t[i]), '.') + count(begin(t[i + 1]), end(t[i + 1]), '.') == 2 * m) continue;\n    s.push_back(t[i]);\n  }\n  n = s.size();\n  V<> idx;\n  for (int j = 0; j < m; ++j) {\n    bool b = j + 1 < m;\n    if (b) {\n      for (int i = 0; i < n; ++i) if (s[i][j] != '.' or s[i][j + 1] != '.') {\n        b = false;\n        break;\n      }\n    }\n    if (b) continue;\n    idx.push_back(j);\n  }\n  m = idx.size();\n  for (auto&& e : s) {\n    string t;\n    for (int j : idx) t += e[j];\n    e = t;\n  }\n  int res = 0;\n  for (int _ = 0; _ < 26; ++_) {\n    for (int i = 0; i < n; ++i) for (int j = 0; j < m; ++j) if (s[i][j] == '.') {\n      map<char, int> mp;\n      for (int jj = j - 1; jj >= 0; --jj) if (s[i][jj] != '.') {\n        ++mp[s[i][jj]];\n        break;\n      }\n      for (int jj = j + 1; jj < m; ++jj) if (s[i][jj] != '.') {\n        ++mp[s[i][jj]];\n        break;\n      }\n      for (int ii = i - 1; ii >= 0; --ii) if (s[ii][j] != '.') {\n        ++mp[s[ii][j]];\n        break;\n      }\n      for (int ii = i + 1; ii < n; ++ii) if (s[ii][j] != '.') {\n        ++mp[s[ii][j]];\n        break;\n      }\n      set<char> se;\n      for (const auto& e : mp) if (e.second >= 2) {\n        se.insert(e.first);\n      }\n      for (int jj = j - 1; jj >= 0; --jj) if (se.count(s[i][jj])) {\n        s[i][jj] = '.';\n        ++res;\n        break;\n      }\n      for (int jj = j + 1; jj < m; ++jj) if (se.count(s[i][jj])) {\n        s[i][jj] = '.';\n        ++res;\n        break;\n      }\n      for (int ii = i - 1; ii >= 0; --ii) if (se.count(s[ii][j])) {\n        s[ii][j] = '.';\n        ++res;\n        break;\n      }\n      for (int ii = i + 1; ii < n; ++ii) if (se.count(s[ii][j])) {\n        s[ii][j] = '.';\n        ++res;\n        break;\n      }\n    }\n  }\n  cout << res << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint m,n;\nvector<P> dat[100];\nvector<int> xind;\nvector<int> yind;\nint field[280][280];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint pickl[4];\nint picklx[4];\nint pickly[4];\n\nint main(void){\n\tscanf(\"%d %d\",&n,&m);\n\tmemset(field,0,sizeof(field));\n\tfor(int i=0;i<n;i++){\n\t\tstring str;\n\t\tcin >> str;\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(str[j]>='A' && str[j]<='Z'){\n\t\t\t\tdat[str[j]-'A'+1].push_back(P(j,i));\n\t\t\t\tif(j-1>=0)xind.push_back(j-1);\n\t\t\t\txind.push_back(j);\n\t\t\t\tif(j+1<m)xind.push_back(j+1);\n\t\t\t\tif(i-1>=0)yind.push_back(i-1);\n\t\t\t\tyind.push_back(i);\n\t\t\t\tif(i+1<n)yind.push_back(i+1);\n\t\t\t}\n\t\t}\n\t}\n\tsort(xind.begin(),xind.end());\n\txind.erase(unique(xind.begin(),xind.end()),xind.end());\n\tsort(yind.begin(),yind.end());\n\tyind.erase(unique(yind.begin(),yind.end()),yind.end());\n\tfor(int i=1;i<=26;i++){\n\t\tfor(int j=0;j<dat[i].size();j++){\n\t\t\tdat[i][j].first=lower_bound(xind.begin(),xind.end(),dat[i][j].first)-xind.begin();\n\t\t\tdat[i][j].second=lower_bound(yind.begin(),yind.end(),dat[i][j].second)-yind.begin();\n\t\t\tfield[dat[i][j].first][dat[i][j].second]=i;\n\t\t}\n\t}\n\tbool flag=true;\n\tint score2=0;\n\twhile(flag){\n\t\tflag=false;\n\t\tfor(int i=0;i<yind.size();i++){\n\t\t\tfor(int j=0;j<xind.size();j++){\n\t\t\t\tif(field[j][i]==0){\n\t\t\t\t\tmemset(pickl,0,sizeof(pickl));\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tint xx=j,yy=i;\n\t\t\t\t\t\tint xi=xind.size(),yi=yind.size();\n\t\t\t\t\t\twhile(xx>=0 && xx<xi && yy>=0 && yy<yi){\n\t\t\t\t\t\t\tif(field[xx][yy]!=0)break;\n\t\t\t\t\t\t\txx+=dx[k];\n\t\t\t\t\t\t\tyy+=dy[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(field[xx][yy]!=0){\n\t\t\t\t\t\t\tpickl[k]=field[xx][yy];\n\t\t\t\t\t\t\tpicklx[k]=xx;\n\t\t\t\t\t\t\tpickly[k]=yy;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tfor(int l=k+1;l<4;l++){\n\t\t\t\t\t\t\tif(pickl[k]==pickl[l] && pickl[k]!=0){\n\t\t\t\t\t\t\t\tscore2+=2;\n\t\t\t\t\t\t\t\tfield[picklx[k]][pickly[k]]=0;\n\t\t\t\t\t\t\t\tfield[picklx[l]][pickly[l]]=0;\n\t\t\t\t\t\t\t\tflag=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",score2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n\nusing namespace std;\nstatic const double EPS = 1e-8;\ntypedef long long ll;\n\nstruct Range\n{\n    Range() : a(-3){}\n    Range(int a, int b, int c, int d)\n  : a(a), b(b), c(c), d(d){}\n    int a, b, c, d;\n};\nchar grid[512][512];\n\nbool all_empty_x(int y, int l, int u)\n{\n    if (l > u)\n        swap(l, u);\n    for (int x = l; x <= u; ++x)\n        if (grid[y][x] != '.')\n            return false;\n    return true;\n}\nbool all_empty_y(int x, int l, int u)\n{\n    if (l > u)\n        swap(l, u);\n    for (int y = l; y <= u; ++y)\n        if (grid[y][x] != '.')\n            return false;\n    return true;\n}\n\nvector<pair<int, int> > p[26];\nint main()\n{\n    int M, N;\n    scanf(\"%d %d\", &M, &N);\n    for (int i = 0; i < M; ++i)\n        scanf(\"%s\", grid[i]);\n\n    for (int i = 0; i < M; ++i)\n        for (int j = 0; j < N; ++j)\n            if (grid[i][j] != '.')\n                p[grid[i][j]-'A'].push_back(make_pair(j, i));\n\n    Range r[26];\n    for (int i = 0; i < 26; ++i)\n    {\n        if (!p[i].size())\n            continue;\n\n        int x1, y1, x2, y2;\n        x1 = p[i][0].first;\n        y1 = p[i][0].second;\n        x2 = p[i][1].first;\n        y2 = p[i][1].second;\n\n        if (y1 == y2 && abs(x1-x2) != 1)\n            r[i] = Range(-1, y1, min(x1, x2), max(x1, x2));\n        else if (x1 == x2 && abs(y1-y2) != 1)\n            r[i] = Range(-2, x1, min(y1, y2), max(y1, y2));\n        else if (x1 != x2 && y1 != y2)\n            r[i] = Range(x1, y1, x2, y2);\n    }\n\n    int ans = 0;\n    for (bool update = true; update; )\n    {\n        update = false;\n        for (int i = 0; i < 26; ++i)\n        {\n            if (r[i].a == -3)\n                continue;\n\n            if (r[i].a == -1)\n            {\n                if (all_empty_x(r[i].b, r[i].c+1, r[i].d-1))\n                {\n                    r[i].a = -3;\n                    grid[r[i].b][r[i].c] = grid[r[i].b][r[i].d] = '.';\n                    ans += 2;\n                    update = true;\n                }\n            }\n            else if (r[i].a == -2)\n            {\n                if (all_empty_y(r[i].b, r[i].c+1, r[i].d-1))\n                {\n                    r[i].a = -3;\n                    grid[r[i].c][r[i].b] = grid[r[i].d][r[i].b] = '.';\n                    ans += 2;\n                    update = true;\n                }\n            }\n            else if (r[i].a != -3)\n            {\n                int x1, y1, x2, y2;\n                x1 = r[i].a;\n                y1 = r[i].b;\n                x2 = r[i].c;\n                y2 = r[i].d;\n                int x[4], y[4];\n                x[0] = x1;\n                y[0] = y2;\n                x[1] = x2 + (x1 > x2 ? 1 : -1);\n                y[1] = y1 + (y2 > y1 ? 1 : -1);\n                x[2] = x2;\n                y[2] = y1;\n                x[3] = x1 + (x2 > x1 ? 1 : -1);\n                y[3] = y2 + (y1 > y2 ? 1 : -1);\n                if (all_empty_x(y2, x[0], x[1]) && all_empty_y(x1, y[0], y[1])\n                    || all_empty_x(y1, x[2], x[3]) && all_empty_y(x2, y[2], y[3]))\n                {\n                    r[i].a = -3;\n                    grid[y1][x1] = grid[y2][x2] = '.';\n                    ans += 2;\n                    update = true;\n                }\n            }\n        }\n    }\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\ntemplate<class T> constexpr bool in_range(T y, T x, T H, T W) { return 0<=y&&y<H&&0<=x&&x<W; }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,-1,0,1};\n\nint H, W;\n\nvoid solve(vector<string>& G) {\n\n  int res = 0;\n\n  while(1) {\n    bool ok = 0;\n    rep(i, H) rep(j, W) {\n      if(G[i][j] == '.') {\n        map<char, vector<pair<int, int>>> mp;\n        rep(k, 4) {\n          int y = i, x = j;\n          while(1) {\n            y += dy[k], x += dx[k]; if(!in_range(y, x, H, W)) break;\n            if(G[y][x] != '.') {\n              mp[G[y][x]].emplace_back(y, x);\n              break;\n            }\n          }\n        }\n\n        for(auto && e: mp) {\n          if(e.second.size() > 1) {\n            G[e.second[0].first][e.second[0].second] = '.';\n            G[e.second[1].first][e.second[1].second] = '.';\n            res += 2;\n            ok = 1;\n          }\n        }\n      }\n    }\n    if(!ok) break;\n  }\n  cout << res << endl;\n}\n\nint main() {\n\n  cin >> H >> W;\n  vector<string> G(H);\n  rep(i, H) cin >> G[i];\n\n  int k = 0;\n  rep(i, H) {\n    if(G[i] != string(W, '.'))\n      G[k++] = G[i];\n  }\n  H = k;\n\n  string T[501]; rep(i, W) T[i].resize(H);\n  rep(i, W) rep(j, H) {\n    T[i][j] = G[j][i];\n  }\n\n  k = 0;\n  rep(i, W) {\n    if(T[i] != string(H, '.'))\n      T[k++] = T[i];\n  }\n\n  W = k;\n\n  G.clear(); G.resize(H); rep(i, H) G[i] = string(W, '.');\n\n  rep(i, H) rep(j, W)\n    G[i][j] = T[j][i];\n\n  rep(i, H) {\n    cout << G[i] << endl;\n  }\n\n  solve(G);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cctype>\n#include <vector>\n#include <set>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0 ; i < n ; i++)\n\nstruct Point{\n  int x1, y1, x2, y2;\n};\n\nconst int MAX = 510;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nchar field[MAX][MAX];\nbool found[26];\nPoint alpha[26];\n\nint H, W;\n\nbool canReach_x(char C, int x, int y1, int y2){\n  if(y1 > y2) swap(y1, y2);\n  for(int i = y1 ; i <= y2 ; i++){\n    if(field[i][x] != '.' && field[i][x] != C) return false;\n  }\n  return true;\n}\n\nbool canReach_y(char C, int y, int x1, int x2){\n  if(x1 > x2) swap(x1, x2);\n  for(int j = x1 ; j <= x2 ; j++){\n    if(field[y][j] != '.' && field[y][j] != C) return false;\n  }\n  return true;\n}\n\nbool canReach(char C, int cx, int cy, int x, int y){\n  if(cx == x){\n    if(!canReach_x(C, x, cy, y)) return false;\n  }\n  \n  else if(cx < x){\n    for(int j = x ; j >= cx ; j--){\n      if(field[y][j] != '.' && field[y][j] != C) return false;\n    }\n\n  }\n  \n  else if(cx > x){\n    for(int j = x ; j <= cx ; j++){\n      if(field[y][j] != '.' && field[y][j] != C) return false;\n    }\n\n  }\n\n  if(cy == y){\n    if(!canReach_y(C, y, cx, x)) return false;\n  }\n  \n  else if(cy < y){\n    for(int i = y ; i >= cy ; i--){\n      if(field[i][x] != '.' && field[i][x] != C) return false;\n    }\n\n  }\n  else if(cy > y){\n    for(int i = y ; i <= y ; i++){\n      if(field[i][x] != '.' && field[i][x] != C) return false;\n    }\n\n  }\n\n  return true;\n}\n\nvoid output(){\n  rep(i, H){\n    rep(j, W){\n      cout << field[i][j];\n    }\n    cout << endl;\n  }\n  cout << endl;\n}\n\nint main(){\n  while(cin >> H >> W){\n    rep(i, H) cin >> field[i];\n    memset(alpha, 0, sizeof(alpha));\n    memset(found, 0, sizeof(found));\n    \n    rep(i, H){\n      rep(j, W){\n\tif(isalpha(field[i][j])){\n\t  int c = field[i][j]-'A';\n\t  if(!found[c]){\n\t    found[c] = true;\n\t    alpha[c].x1 = j, alpha[c].y1 = i;\n\t  }\n\t  else{\n\t    alpha[c].x2 = j, alpha[c].y2 = i;\n\t  }\t\n\t}\n      }\n    }\n    \n    Point cross[26];\n    rep(i, 26){\n      if(found[i]){\n\tcross[i].x1 = alpha[i].x1, cross[i].y1 = alpha[i].y2;\n\tcross[i].x2 = alpha[i].x2, cross[i].y2 = alpha[i].y1;\n      }\n    }\n    \n    int ans = 0;\n    \n    rep(i, H){\n      rep(j, W){\n\trep(k, 4){\n\t  int nx = j+dx[k], ny = i+dy[k];\n\t  if(nx < 0 || nx > W || ny < 0 || ny > H) continue;\n\t  if(field[i][j] == field[ny][nx]) found[field[i][j]-'A'] = false;\n\t}\n      }\n    }\n\t\n    \n    for(; ;){\n      bool flag = false;\n      rep(i, 26){\n\tif(found[i]){\n\t  int x1 = alpha[i].x1, y1 = alpha[i].y1, x2 = alpha[i].x2, y2 = alpha[i].y2;\n\t  if(((canReach('A'+i, cross[i].x1, cross[i].y1, x1, y1) &&\n\t       canReach('A'+i, cross[i].x1, cross[i].y1, x2, y2))) ||\n\t     ((canReach('A'+i, cross[i].x2, cross[i].y2, x1, y1) &&\n\t       canReach('A'+i, cross[i].x2, cross[i].y2, x2, y2)))){\n\t    \n\t    field[y1][x1] = field[y2][x2] = '.';\n\t    found[i] = false;\n\t    ans += 2;\n\t    flag = true;\n\t    //output();\n\t  }\n\t}\n      }\n      if(!flag) break;\n    }\n    \n    cout << ans << endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mk make_pair\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nstring s[500];\nint h,w,sum=0;\nvector<int>x,y;\nvoid del(int t1,int t2){\n  vector<pair<char,pair<int,int> > >p;\n  for(int i=t1;i<h;i++)if(s[i][t2]!='.'){\n    p.push_back(mk(s[i][t2],mk(i,t2)));\n    break;\n  }\n  for(int i=t1;i>=0;i--)if(s[i][t2]!='.'){\n    p.push_back(mk(s[i][t2],mk(i,t2)));\n    break;\n  }\n  for(int i=t2;i<w;i++)if(s[t1][i]!='.'){\n    p.push_back(mk(s[t1][i],mk(t1,i)));\n    break;\n  }\n  for(int i=t2;i>=0;i--)if(s[t1][i]!='.'){\n    p.push_back(mk(s[t1][i],mk(t1,i)));\n    break;\n  }\n  sort(p.begin(),p.end());\n  if(p.size()>=2){\n    r(i,p.size()-1){\n      if(p[i].first==p[i+1].first){\n        sum++;cout<<p[i].first;\n        s[p[i].second.first][p[i].second.second]='.';\n        s[p[i+1].second.first][p[i+1].second.second]='.';\n      }\n    }\n  }\n}\nint main(){\n  cin>>h>>w;\n  r(i,h)cin>>s[i];\n  r(i,h)r(j,w)if(s[i][j]!='.'){\n      y.push_back(i),x.push_back(j);\n      if(i+1<h)y.push_back(i+1);\n      if(j+1<w)x.push_back(j+1);\n    }\n  r(k,26)r(i,y.size())r(j,x.size())\n    if(s[y[i]][x[j]]=='.')del(y[i],x[j]);\n    //r(i,h)cout<<s[i]<<endl;\n  cout<<sum*2<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n\n#include <iostream>\n#include <algorithm>\n\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <cstring>\n#include <string>\n#include <utility>\n#include <array>\n#include <complex>\n#include <valarray>\n\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n#include<memory>\n\n\nusing namespace std;\n#define int long long\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n//typedef unsigned __int128 HASH;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ull, ull> pullull;\ntypedef pair<ll,int> plli;\ntypedef pair<double,int> pdi;\ntypedef pair<long double, int> pdbi;\ntypedef pair<int,pii> pipii;\ntypedef pair<ll,pll> plpll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<vector<int>> mat;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\nconst ll hmod1 = 999999937;\nconst ll hmod2 = 1000000000 + 9;\nconst int INF = 1<<30;\nconst ll INFLL = 1LL<<62;\nconst long double EPS = 1e-12;\nconst ll mod = 1000000000 + 7;\n//const ll mod = 998244353;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst long double pi = 3.141592653589793;\n\n#define addm(X, Y) (X) = ((X) + ((Y) % mod) + mod) % mod\n#define inside(y, x, h, w) (0 <= (y) && (y) < (h) && 0 <= (x) && (x) < (w)) ? true : false\n\n//debug\n#define DEBUG\n\n#define DUMPOUT cerr\n\n#ifdef DEBUG\n#define dump(...) DUMPOUT<<#__VA_ARGS__<<\" :[\"<<__FUNCTION__<<\":\"<<__LINE__<<\"]\"<<endl; DUMPOUT<<\"    \"; dump_func(__VA_ARGS__)\n#else\n#define dump(...)\n#endif\n\nvoid dump_func() {DUMPOUT << endl;};\n\ntemplate <class Head, class... Tail> void dump_func(Head&& head, Tail&&... tail) {\n    DUMPOUT << head;\n    if (sizeof...(Tail) == 0) DUMPOUT << \" \";\n    else DUMPOUT << \", \";\n    dump_func(std::move(tail)...);\n}\n\n//ostream\ntemplate<typename T> ostream& operator << (ostream& os, vector<T>& vec) {\n    os << \"[\"; for (int i = 0; i<vec.size(); i++) os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \"); os << \"]\";\n    return os;\n}\n\ntemplate<typename T, typename U> ostream& operator << (ostream& os, pair<T, U>& pair_var) {\n    os << \"(\" << pair_var.first << \", \" << pair_var.second << \")\";\n    return os;\n}\n\ntemplate<typename T, typename U> ostream& operator << (ostream& os, map<T, U>& map_var) {\n    os << \"[\";\n    for (auto itr = map_var.begin(); itr != map_var.end(); itr++) {\n        os << \"(\" << itr->first << \", \" << itr->second << \")\"; itr++;  if(itr != map_var.end()) os << \", \"; itr--;\n    }\n    os << \"]\";\n    return os;\n}\n\ntemplate<typename T> ostream& operator << (ostream& os, set<T>& set_var) {\n    os << \"[\";\n    for (auto itr = set_var.begin(); itr != set_var.end(); itr++) {\n        os << *itr; ++itr; if(itr != set_var.end()) os << \", \"; itr--;\n    }\n    os << \"]\";\n    return os;\n}\n\nint m, n;\nchar C[501][501];\nmap<char, vector<pii>> pos;\nvector<vector<pii>> kouho(26);\n\nsigned main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cin >> m >> n;\n  rep(i, m)rep(j, n) {\n    cin >> C[i][j];\n    if (C[i][j] != '.') {\n      pos[C[i][j]].push_back({i, j});\n    }\n  }\n  for (auto p : pos) {\n    char c = p.fi;\n    vector<pii> yx = p.se;\n    int Y1 = yx[0].fi;\n    int X1 = yx[0].se;\n    int Y2 = yx[1].fi;\n    int X2 = yx[1].se;\n    if (Y1 == Y2) {\n       for (int x = min(X1, X2)+1; x < max(X1, X2); x++) {\n         kouho[c - 'A'].push_back({Y1, x});\n       }\n    }\n    else if (X1 == X2) {\n       for (int y = min(Y1, Y2)+1; y < max(Y1, Y2); y++) {\n         kouho[c - 'A'].push_back({y, X1});\n       }\n    }\n    else {\n      kouho[c - 'A'].push_back({min(Y1, Y2), min(X1, X2)});\n      kouho[c - 'A'].push_back({max(Y1, Y2), max(X1, X2)});\n      kouho[c - 'A'].push_back({min(Y1, Y2), max(X1, X2)});\n      kouho[c - 'A'].push_back({max(Y1, Y2), min(X1, X2)});\n    }\n  }\n  int ans = 0;\n  bool check[26] = {};\n  while (true) {\n    bool update = false;\n    rep(i, 26) {\n      if (check[i]) continue;\n      for (auto p : kouho[i]) {\n        int y = p.fi;\n        int x = p.se;\n        if (C[y][x] != '.') continue;\n        int cnt[26] = {};\n        rep2(j, y, m) {\n          if (C[j][x] != '.') {\n            cnt[C[j][x] - 'A']++;\n            break;\n          }\n        }\n        rrep2(j, y, -1) {\n          if (C[j][x] != '.') {\n            cnt[C[j][x] - 'A']++;\n            break;\n          }\n        }\n        rep2(j, x, n) {\n          if (C[y][j] != '.') {\n            cnt[C[y][j] - 'A']++;\n            break;\n          }\n        }\n        rrep2(j, x, -1) {\n          if (C[y][j] != '.') {\n            cnt[C[y][j] - 'A']++;\n            break;\n          }\n        }\n        rep(j, 26) {\n          if (cnt[j] == 2) {\n            //cerr << char(j + 'A') << endl;\n            update = true;\n            ans += 2;\n            check[j] = true;\n            vector<pii> tmppos = pos[char(j + 'A')];\n            for (auto p : tmppos) {\n              C[p.fi][p.se] = '.';\n            }\n            /*\n            rep(i, m) {\n              rep(j, n) cerr << C[i][j];\n              cerr << endl;\n            }\n            */\n          }\n        }\n      }\n    }\n    if (!update) break;\n  }\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint m,n;\nvector<P> data[30];\nvector<int> xindex;\nvector<int> yindex;\nint fie[250][250];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint pick[4];\nint pickx[4];\nint picky[4];\n\nint main(void){\n\tscanf(\"%d %d\",&n,&m);\n\tfor(int i=0;i<n;i++){\n\t\tstring str;\n\t\tcin >> str;\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(str[j]>='A' && str[j]<='Z'){\n\t\t\t\tdata[str[j]-'A'+1].push_back(P(j,i));\n\t\t\t\tif(j-1>=0)xindex.push_back(j-1);\n\t\t\t\txindex.push_back(j);\n\t\t\t\tif(j+1<m)xindex.push_back(j+1);\n\t\t\t\tif(i-1>=0)yindex.push_back(i-1);\n\t\t\t\tyindex.push_back(i);\n\t\t\t\tif(i+1<n)yindex.push_back(i+1);\n\t\t\t}\n\t\t}\n\t}\n\tsort(xindex.begin(),xindex.end());\n\txindex.erase(unique(xindex.begin(),xindex.end()),xindex.end());\n\tsort(yindex.begin(),yindex.end());\n\tyindex.erase(unique(yindex.begin(),yindex.end()),yindex.end());\n\tfor(int i=1;i<=26;i++){\n\t\tfor(int j=0;j<data[i].size();j++){\n\t\t\tdata[i][j].first=lower_bound(xindex.begin(),xindex.end(),data[i][j].first)-xindex.begin();\n\t\t\tdata[i][j].second=lower_bound(yindex.begin(),yindex.end(),data[i][j].second)-yindex.begin();\n\t\t\tfie[data[i][j].first][data[i][j].second]=i;\n\t\t}\n\t}\n\tbool flag=true;\n\tint score=0;\n\twhile(flag){\n\t\tflag=false;\n\t\tfor(int i=0;i<yindex.size();i++){\n\t\t\tfor(int j=0;j<xindex.size();j++){\n\t\t\t\tif(fie[j][i]==0){\n\t\t\t\t\tmemset(pick,0,sizeof(pick));\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tint x=j,y=i;\n\t\t\t\t\t\twhile((x>=0 && x<xindex.size() && y>=0 && y<yindex.size()) && fie[x][y]==0){\n\t\t\t\t\t\t\tx+=dx[k];\n\t\t\t\t\t\t\ty+=dy[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(fie[x][y]!=0){\n\t\t\t\t\t\t\tpick[k]=fie[x][y];\n\t\t\t\t\t\t\tpickx[k]=x;\n\t\t\t\t\t\t\tpicky[k]=y;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tfor(int l=k+1;l<4;l++){\n\t\t\t\t\t\t\tif(pick[k]==pick[l] && pick[k]!=0){\n\t\t\t\t\t\t\t\tscore+=2;\n\t\t\t\t\t\t\t\tfie[pickx[k]][picky[k]]=0;\n\t\t\t\t\t\t\t\tfie[pickx[l]][picky[l]]=0;\n\t\t\t\t\t\t\t\tflag=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",score);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<list>\nusing namespace std;\nint gcd(int a, int b) {\n\tint c = a % b;\n\twhile (c != 0) {\n\t\ta = b;\n\t\tb = c;\n\t\tc = a % b;\n\t}\n\treturn b;\n}\nint main() {\n\tint h, w, ans = 0, i, j, x[33][2], y[33][2], flag, p[33], t;\n\tchar c[555][555];\n\tcin >> h >> w;\n\tfor (i = 0; i < h; i++)\n\t\tcin >> c[i];\n\tfor (i = 0; i < 26; i++)\n\t\tx[i][0] = -1;\n\tfor (i = 0; i < h; i++) {\n\t\tfor (j = 0; j < w; j++) {\n\t\t\tif (c[i][j] != '.') {\n\t\t\t\tif (x[c[i][j] - 'A'][0] == -1) {\n\t\t\t\t\tx[c[i][j] - 'A'][0] = j;\n\t\t\t\t\ty[c[i][j] - 'A'][0] = i;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tx[c[i][j] - 'A'][1] = j;\n\t\t\t\t\ty[c[i][j] - 'A'][1] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 0; i < 26; i++) {\n\t\tif (x[i][0] == -1)\n\t\t\tp[i] = 1;\n\t\telse\n\t\t\tp[i] = 0;\n\t}\n\twhile (1) {\n\t\tflag = 0;\n\t\tfor (i = 0; i < 26; i++) {\n\t\t\tif (p[i] == 0 && c[y[i][0]][x[i][1]] == '.') {\n\t\t\t\tt = 1;\n\t\t\t\tfor (j = min(x[i][0], x[i][1]) + 1; j < max(x[i][0], x[i][1]); j++)\n\t\t\t\t\tif (c[y[i][0]][j] != '.')\n\t\t\t\t\t\tt = 0;\n\t\t\t\tfor (j = min(y[i][0], y[i][1]) + 1; j < max(y[i][0], y[i][1]); j++)\n\t\t\t\t\tif (c[j][x[i][1]] != '.')\n\t\t\t\t\t\tt = 0;\n\t\t\t\tif (t == 1) {\n\t\t\t\t\tans += 2;\n\t\t\t\t\tflag = 1;\n\t\t\t\t\tc[y[i][0]][x[i][0]] = '.';\n\t\t\t\t\tc[y[i][1]][x[i][1]] = '.';\n\t\t\t\t\tp[i]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (p[i] == 0 && c[y[i][1]][x[i][0]] == '.') {\n\t\t\t\tt = 1;\n\t\t\t\tfor (j = min(x[i][0], x[i][1]) + 1; j < max(x[i][0], x[i][1]); j++)\n\t\t\t\t\tif (c[y[i][1]][j] != '.')\n\t\t\t\t\t\tt = 0;\n\t\t\t\tfor (j = min(y[i][0], y[i][1]) + 1; j < max(y[i][0], y[i][1]); j++)\n\t\t\t\t\tif (c[j][x[i][0]] != '.')\n\t\t\t\t\t\tt = 0;\n\t\t\t\tif (t == 1) {\n\t\t\t\t\tans += 2;\n\t\t\t\t\tflag = 1;\n\t\t\t\t\tc[y[i][0]][x[i][0]] = '.';\n\t\t\t\t\tc[y[i][1]][x[i][1]] = '.';\n\t\t\t\t\tp[i]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (p[i] == 0 && x[i][0] == x[i][1]) {\n\t\t\t\tt = 1;\n\t\t\t\tfor (j = min(y[i][0], y[i][1]) + 1; j < max(y[i][0], y[i][1]); j++)\n\t\t\t\t\tif (c[j][x[i][0]] != '.')\n\t\t\t\t\t\tt = 0;\n\t\t\t\tif (t == 1 && abs(y[i][0] - y[i][1]) > 1) {\n\t\t\t\t\tans += 2;\n\t\t\t\t\tflag = 1;\n\t\t\t\t\tc[y[i][0]][x[i][0]] = '.';\n\t\t\t\t\tc[y[i][1]][x[i][1]] = '.';\n\t\t\t\t\tp[i]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (p[i] == 0 && y[i][0] == y[i][1]) {\n\t\t\t\tt = 1;\n\t\t\t\tfor (j = min(x[i][0], x[i][1]) + 1; j < max(x[i][0], x[i][1]); j++)\n\t\t\t\t\tif (c[y[i][0]][j] != '.')\n\t\t\t\t\t\tt = 0;\n\t\t\t\tif (t == 1&&abs(x[i][0]-x[i][1])>1) {\n\t\t\t\t\tans += 2;\n\t\t\t\t\tflag = 1;\n\t\t\t\t\tc[y[i][0]][x[i][0]] = '.';\n\t\t\t\t\tc[y[i][1]][x[i][1]] = '.';\n\t\t\t\t\tp[i]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (flag == 0)\n\t\t\tbreak;\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int H, W; cin >> H >> W;\n  VS vs(H);\n  REP(i,H) cin >> vs[i];\n\n  vector<PII> memo(32, MP(-1,-1));\n  vector<pair<PII,PII>> pos;\n  REP(y,H) REP(x,W){\n\tif(vs[y][x] != '.'){\n\t  int i = vs[y][x] - 'A';\n\t  if(memo[i].first < 0)\n\t\tmemo[i] = MP(x,y);\n\t  else\n\t\tpos.PB(MP(memo[i], MP(x,y)));\n\t}\n  }\n\n  int ans = 0;\n  bool up  = true;\n  while(up){\n\tup = false;\n\n\tfor(int i=0;i<SZ(pos);++i){\n\t  PII p1 = pos[i].first, p2 = pos[i].second;\n\t  if(p1 > p2) swap(p1, p2);\n\t  int mx = min(p1.first, p2.first);\n\t  int Mx = max(p1.first, p2.first);\n\t  int my = min(p1.second, p2.second);\n\t  int My = max(p1.second, p2.second);\n\t  if((mx+1 == Mx && my == My)\n\t\t || (mx == Mx && my+1 == My)) continue;\n\t  \n\t  int ok = 0;\n\t  if(p1.second <= p2.second)\n\t  for(int j=0;j<SZ(pos);++j){\n\t\tif(i == j) continue;\n\t\tPII piis[2] = {pos[j].first, pos[j].second};\n\t\tfor(auto pii:piis){\n\t\t  int x = pii.first, y = pii.second;\n\t\t  if((y == my && mx <= x && x <= Mx)\n\t\t\t || (x == Mx && my <= y && y <= My))\n\t\t\tok |= 1;\n\t\t  if((y == My && mx <= x && x <= Mx)\n\t\t\t || (x == mx && my <= y && y <= My))\n\t\t\tok |= 2;\n\t\t}\n\t  }\n\t  else\n\t  for(int j=0;j<SZ(pos);++j){\n\t\tif(i == j) continue;\n\t\tPII piis[2] = {pos[j].first, pos[j].second};\n\t\tfor(auto pii:piis){\n\t\t  int x = pii.first, y = pii.second;\n\t\t  if((y == my && mx <= x && x <= Mx)\n\t\t\t || (x == mx && my <= y && y <= My))\n\t\t\tok |= 1;\n\t\t  if((y == My && mx <= x && x <= Mx)\n\t\t\t || (x == Mx && my <= y && y <= My))\n\t\t\tok |= 2;\n\t\t}\n\t  }\n\t\t\n\t  if(ok != 3){\n\t\tpos.erase(pos.begin() + i);\n\t\tans += 2;\n\t\tup = true;\n\t\tbreak;\n\t  }\n\t}\n  }\n\n  cout << ans << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<cassert>\nusing namespace std;\n#define REP(i, b, e) for ( int i = b; i < (int)e; i++ )\n#define rep(i, n) REP(i, 0, n)\nstatic const int MAX = 502;\n\nint H, W;\nchar G[MAX][MAX];\n\nbool canGo(int si, int sj, int ti, int tj){\n  int di = ti - si;\n  int dj = tj - sj;\n  if ( abs(di) > 0 ) di /= abs(di);\n  if ( abs(dj) > 0 ) dj /= abs(dj);\n  \n  int pi = si + di;\n  int pj = sj + dj;\n\n  while(1){\n    if ( G[pi][pj] != '.' ) return false;\n    if ( pi == ti && pj == tj ) return true;\n    pi += di;\n    pj += dj;\n  }\n}\n\nint solve(){\n  vector<pair<int, int> > POS[26];\n  bool removed[26];\n  rep(i, 26) removed[i] = false;\n  \n  REP(i, 1, H+1) REP(j, 1, W+1){\n    if ( G[i][j] != '.' ){\n      char ch = G[i][j];\n      POS[ch-'A'].push_back(make_pair(i, j));\n    }\n  }\n  rep(i, 26) assert( POS[i].size() == 2 || POS[i].size() == 0 );\n\n  int score = 0;\n  bool isActivated;\n\n  while(1){\n    isActivated = false;\n    rep(i, 26){\n      if ( removed[i] ) continue;\n      if ( POS[i].size() == 0 ) continue;\n      int i1 = POS[i][0].first;\n      int j1 = POS[i][0].second;\n      int i2 = POS[i][1].first;\n      int j2 = POS[i][1].second;\n\n      bool suc = false;\n      if ( i1 == i2 && j1 != j2 ){\n\tsuc =  (canGo(i1, j1, i1, (j1+j2)/2) && canGo(i2, j2, i1, (j1+j2)/2));\n      } else if ( i1 != i2 && j1 == j2 ){\n\tsuc =  (canGo(i1, j1, (i1+i2)/2, j2) && canGo(i2, j2, (i1+i2)/2, j1));\n      } else {\n\tsuc = (canGo(i1, j1, i1, j2) && canGo(i2, j2, i1, j2) ||\n\t       canGo(i1, j1, i2, j1) && canGo(i2, j2, i2, j1) );\n      }\n\n      if ( suc ){\n\tG[i1][j1] = G[i2][j2] = '.';\n\tremoved[i] = true;\n\tscore += 2;\n\tisActivated = true;\n      }\n    }\n    if ( !isActivated ) break;\n  }\n\n  return score;\n}\n\nmain(){\n  cin >> H >> W;\n  rep(i, H+2) rep(j, W+2) G[i][j] = '#'; // sentinel\n  rep(i, H) rep(j, W) cin >> G[i+1][j+1];\n  cout << solve() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\n\nint M, N;\nstring s[510];\nvector<pii> g[26];\nint ans = 0;\n\nbool check(int y, int x, int dy, int dx, char ch) {\n  if (s[y][x] != '.' && s[y][x] != ch) return false;\n  int ny, nx;\n  ny = y + dy, nx = x;\n  while (true) {\n    if (s[ny][nx] == ch) break;\n    if (s[ny][nx] != '.') return false;\n    ny += dy;\n  }\n  ny = y, nx = x + dx;\n  while (true) {\n    if (s[ny][nx] == ch) break;\n    if (s[ny][nx] != '.') return false;\n    nx += dx;\n  }\n  return true;\n}\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  \n  cin >> M >> N;\n  for (int i = 0; i < M; i++) {\n    cin >> s[i];\n    for (int j = 0; j < N; j++) {\n      if (s[i][j] == '.') continue;\n      g[s[i][j] - 'A'].emplace_back(i, j);\n    }\n  }\n  bool update = true;\n  while (update) {\n    update = false;\n    for (int i = 0; i < 26; i++) {\n      if (g[i].empty()) continue;\n      if (abs(g[i][0].first - g[i][1].first) + abs(g[i][0].second - g[i][1].second) == 1) continue;\n      int sy, sx;\n      int gy, gx;\n      int dy, dx;\n      tie(sy, sx) = make_tuple(g[i][0].first, g[i][1].second);\n      tie(gy, gx) = make_tuple(g[i][1].first, g[i][0].second);\n      dy = gy - sy > 0 ? 1 : gy - sy < 0 ? -1 : 0;\n      dx = gx - sx > 0 ? 1 : gx - sx < 0 ? -1 : 0;\n      if (check(sy, sx, dy, dx, char(i + 'A'))) {\n        for (pii p : g[i]) {\n          s[p.first][p.second] = '.';\n        }\n        ans += 2;\n        g[i].clear();\n        update = true;\n        continue;\n      }\n      tie(sy, sx) = make_tuple(g[i][1].first, g[i][0].second);\n      tie(gy, gx) = make_tuple(g[i][0].first, g[i][1].second);\n      dy = gy - sy > 0 ? 1 : gy - sy < 0 ? -1 : 0;\n      dx = gx - sx > 0 ? 1 : gx - sx < 0 ? -1 : 0;\n      if (check(sy, sx, dy, dx, char(i + 'A'))) {\n        for (pii p : g[i]) {\n          s[p.first][p.second] = '.';\n        }\n        ans += 2;\n        g[i].clear();\n        update = true;\n        continue;\n      }\n    }\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "                                        #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                                #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppa pair<string,int>\n                                        #define ppap pair<int,pa>\n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-12)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\n                                  #define VI vector<int>\n                                        using namespace std;\n                                        \n                                  class pas{\n                                    \tpublic:\n                                    \tint x,y;\n                                    \tpas(int x=0,int y=0):x(x),y(y) {}\n                                    \tpas operator + (pas p) {return pas(x+p.x,y+p.y);}\n                                    \tpas operator - (pas p) {return pas(x-p.x,y-p.y);}\n                                    \tpas operator * (int a) {return pas(x*a,y*a);}\n                                    \tpas operator / (int a) {return pas(x/a,y/a);}\n                                    //\tdouble absv() {return sqrt(norm());}\n                                    \tint norm() {return x*x+y*y;}\n                                    \tbool operator < (const pas &p) const{\n                                   \t\treturn x != p.x ? x<p.x: y<p.y;\n                                   \t}\n                                  //\t\tbool operator < (const pas &p) const{\n                                    //\t\treturn y != p.y ? y<p.y: x<p.x;\n                                    //\t}\n                                    \tbool operator == (const pas &p) const{\n                                    \t\treturn x==p.x && y==p.y;\n                                    \t}\n                                    };\n\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                        \nstruct star{\nSegment se[5];\n};\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(b.p1),(b.p2))&&parareru((a.p2),(a.p1),(b.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n            double segment_len(Segment a){\n            \t\n            \treturn (a.p1-a.p2).absv();\n            }\n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n\t\t\tpair<Point,Point> circle_intersection(Point c1,double r1,Point c2,double r2){\n\t\t\t\tdouble d=(c1-c2).absv();\n\t\t\t\tdouble h=(r1*r1-r2*r2+d*d)/2.0/d;\n\t\t\t\tdouble l=sqrt(r1*r1-h*h);\n\t\t\t//\tcout<<d<<\" \"<<h<<\" \"<<l<<endl;\n\t\t\t\tPoint asi=c1+(c2-c1)*h/((c2-c1).absv());\n\t\t\t\tVector r1r2=(c2-c1)/((c2-c1).absv());\n\t\t\t\tVector sui={r1r2.y,-r1r2.x};\n\t\t\t//\tcout<<sui.x<<\" \"<<sui.y<<endl;\n\t\t\t\tpair<Point,Point> z=mp(asi+sui*l,asi-sui*l);\n\t\t\t\tif(z.first.x>z.second.x) swap(z.first,z.second);\n\t\t\t\treturn z;\n\t\t\t}\n\nint gcd(int x,int y){\n\tif(x<y) return gcd(y,x);\n\tif(x==y) return x;\n\tif(x%y==0) return y;\n\treturn gcd(y,x%y);\n}\n class pa2{\n                                            public:\n                                            int x,y;\n                                            pa2(int x=0,int y=0):x(x),y(y) {}\n                                            pa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            pa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            bool operator < (const pa2 &p) const{\n                                                return x != p.x ? x<p.x: y<p.y;\n                                            }\n\t\t\t\t\t\t\t\t\t\t \t bool operator > (const pa2 &p) const{\n                                                return x != p.x ? x>p.x: y>p.y;\n                                            }\n                                            bool operator == (const pa2 &p) const{\n                                                return abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            }\n                                            bool operator != (const pa2 &p) const{\n                                                return !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            }\n                                                 \n                                         \n                                        };\n\n/*　　　---memo---\nadd_edge(始点,終点,youryou ,コスト)で枝追加\nmin_cost_flow(始点,終点,ryou)でhiyouをintで返す\n*/\nint a[600][600]={0};\nvector<pa> ve[30],ve2[30];\n\nbool ch(pa r1,pa r2){\n\tif(r1.first==r2.first){\n\t\tif(abs(r1.second-r2.second)==1) return false;\n\t\tint r3=min(r1.second,r2.second),r4=max(r1.second,r2.second);\n\t\tbool bo=true;\n\t\tfor(int k=r3+1;k<r4;k++)if(a[r1.first][k]>=0) return false;\n\t\t\n\t\treturn true;\n\t}\n\t\n\tif(r1.second==r2.second){\n\t//\tcout<<\"e\"<<endl;\n\t\tif(abs(r1.first-r2.first)==1) return false;\n\t\tint r3=min(r1.first,r2.first),r4=max(r1.first,r2.first);\n\t\tbool bo=true;\n\t\tfor(int k=r3+1;k<r4;k++)if(a[k][r1.second]>=0) return false;\n\t\t\n\t\treturn true;\n\t}\n\t\n\tif(r1.first>r2.first) swap(r1,r2);\n\tif(r2.second>r1.second){\n\t\tbool bo=true;\n\t\t\n\t\tfor(int k=r1.second+1;k<=r2.second;k++)if(a[r1.first][k]>=0) bo=false;\n\t\tfor(int k=r1.first;k<r2.first;k++)if(a[k][r2.second]>=0)bo=false;\n\t\tif(bo) return true;\n\t\tbo=true;\n\t\t\n\t\tfor(int k=r1.second;k<r2.second;k++)if(a[r2.first][k]>=0) bo=false;\n\t\tfor(int k=r1.first+1;k<=r2.first;k++)if(a[k][r1.second]>=0)bo=false;\n\t\tif(bo) return true;\n\t\treturn false;\n\t}\n\telse{\n\t\tbool bo=true;\n\t\t\n\t\tfor(int k=r1.first-1;k>=r2.first;k--)if(a[k][r1.first]>=0) bo=false;\n\t\tfor(int k=r1.second;k<r2.second;k++)if(a[r2.first][k]>=0)bo=false;\n\t\tif(bo) return true;\n\t\tbo=true;\n\t\t\n\t\tfor(int k=r1.second+1;k<=r2.second;k++)if(a[r1.first][k]>=0) bo=false;\n\t\tfor(int k=r2.first+1;k<=r1.first;k++)if(a[k][r2.second]>=0)bo=false;\n\t\tif(bo) return true;\n\t\treturn false;\n\t\t\n\t}\n}\n\n\n     signed main(){\nint h,w;\n     \tcin>>h>>w;\n     \tfor(int i=0;i<600;i++)for(int j=0;j<600;j++)a[i][j]=-1;\n     \t\n     \tfor(int i=0;i<h;i++){\n     \t\tstring s;\n     \t\tcin>>s;\n     \t\tfor(int j=0;j<w;j++){\n     \t\t\tif(s[j]=='.') continue;\n     \t\t\tve[s[j]-'A'].pb(mp(i,j));\n     \t\t}\n     \t}\n     \tint ans=0;\n     //\t\tcout<<\"r\"<<endl;\n     \tfor(int i=0;i<26;i++){\n     \t\tif(ve[i].size()==0) continue;\n     \t\t\n     \t\t\n     \t\t\n     \t\t\n     \t}\n     //\tcout<<\"r\"<<endl;\n     \tfor(int cn=0;cn<=100;cn++){\n     \t\tfor(int i=0;i<26;i++)if(ve[i].size()>0){\n     \t\t\tif(ch(ve[i][0],ve[i][1])){\n     \t\t\tans++;\n     //\t\t\t\tcout<<i<<endl;\n     \t\t\t\ta[ve[i][0].first][ve[i][0].second]=-1;\n     \t\t\t\ta[ve[i][1].first][ve[i][1].second]=-1;\n     \t\t\t\tve[i].clear();\n     \t\t\t\n     \t\t\t}\n     \t\t\n     \t\t\n     \t\t}\n     \t}\n     \tcout<<2*ans<<endl;\n\n    \n           \treturn 0;\n           }\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\nusing namespace std;\n\nint M, N, K;\nchar S[550][550];\nint h, w;\nvector<int> y, x;\nvector<char> c;\nchar s[100][100];\nint dd[5] = { 0, 1, 0, -1, 0 };\n\nint compress(vector<int> &a) {\n  vector<int> v;\n\n  REP(i, 0, a.size()) v.push_back(a[i]);\n  sort(v.begin(), v.end());\n  v.erase(unique(v.begin(), v.end()), v.end());\n  REP(i, 0, a.size()) a[i] = find(v.begin(), v.end(), a[i]) - v.begin();\n\n  return (int) v.size();\n}\n\nbool isin(int y, int x) {\n  return 0 <= y && y < h && 0 <= x && x < w;\n}\n\nint main(void) {\n  cin >> M >> N;\n  K = 0;\n  REP(i, 0, M) REP(j, 0, N) {\n    cin >> S[i][j];\n    if(S[i][j] != '.') {\n      y.push_back(i);\n      x.push_back(j);\n      c.push_back(S[i][j]);\n      K++;\n    }\n  }\n\n  h = compress(y);\n  w = compress(x);\n\n  REP(i, 0, h) REP(j, 0, w) s[i][j] = '.';\n  REP(i, 0, K) {\n    // cout << y[i] << \", \" << x[i] << \": \" << c[i] << endl;\n    s[y[i]][x[i]] = c[i];\n  }\n\n  // REP(i, 0, h) {\n  //   REP(j, 0, w) cout << s[i][j];\n  //   cout << endl;\n  // }\n\n  int ans = 0;\n  bool visited[256];\n  REP(i, 0, 256) visited[i] = false;\n  bool f = true;\n  while(f) {\n    f = false;\n    REP(i, 0, h) REP(j, 0, w) {\n      if(s[i][j] == '.' || visited[s[i][j]]) {\n        int cnt[256];\n        REP(k, 0, 256) cnt[k] = 0;\n        // cout << i << \", \" << j << endl;\n        REP(k, 0, 4) {\n          int ny = i, nx = j;\n          while(isin(ny, nx)) {\n            // cout << \"  \" << ny << \", \" << nx << \": \" << s[ny][nx] << endl;\n            if(s[ny][nx] != '.' && !visited[s[ny][nx]]) {\n              // cout << s[ny][nx] << endl;\n              cnt[s[ny][nx]]++;\n              if(cnt[s[ny][nx]] == 2) {\n                // cout << \"  vanish: \" << S[ny][nx] << endl;\n                visited[s[ny][nx]] = true;\n                ans += 2;\n                f = true;\n              }\n              break;\n            }\n            ny += dd[k];\n            nx += dd[k + 1];\n          }\n        }\n      }\n    }\n  }\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\nconst int NONE = 0;\nconst int VERTICAL = 1;\nconst int HORIZONTAL = 2;\nconst int CORNER = 3;\n\nint main() {\n\tint M, N;\n\tcin >> M >> N;\n\n\tvs field(M);\n\tvvi pos(26, vi(4, -1));\n\tREP(i, M) {\n\t\tcin >> field[i];\n\t\tREP(j, N) {\n\t\t\tif(field[i][j] != '.') {\n\t\t\t\tint k = field[i][j]-'A';\n\t\t\t\tif(pos[k][0] == -1) {\n\t\t\t\t\tpos[k][0] = i;\n\t\t\t\t\tpos[k][1] = j;\n\t\t\t\t} else {\n\t\t\t\t\tpos[k][2] = i;\n\t\t\t\t\tpos[k][3] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvi type(26, CORNER);\n\tREP(i, 26) {\n\t\tif(pos[i][2] == -1) {\n\t\t\ttype[i] = NONE;\n\t\t\tcontinue;\n\t\t}\n\t\tif(abs(pos[i][0]-pos[i][2]+pos[i][1]-pos[i][3]) == 1) {\n\t\t\ttype[i] = NONE;\n\t\t\tcontinue;\n\t\t}\n\t\tif(pos[i][0] == pos[i][2]) {\n\t\t\ttype[i] = VERTICAL;\n\t\t\tcontinue;\n\t\t}\n\t\tif(pos[i][1] == pos[i][3]) {\n\t\t\ttype[i] = HORIZONTAL;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tint ans = 0;\n\tbool updated = true;\n\twhile(updated) {\n\t\tupdated = false;\n\t\tREP(i, 26) {\n\t\t\tif(type[i] == NONE) {\n\t\t\t\n\t\t\t} else if(type[i] == VERTICAL) {\n\t\t\t\tint y = pos[i][0];\n\t\t\t\tFOR(x, min(pos[i][1], pos[i][3])+1, max(pos[i][1], pos[i][3])-1) {\n\t\t\t\t\tif(field[y][x] == '.') {\n\t\t\t\t\t\tans += 2;\n\t\t\t\t\t\ttype[i] = NONE;\n\t\t\t\t\t\tfield[pos[i][0]][pos[i][1]] = field[pos[i][2]][pos[i][3]] = '.';\n\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if(type[i] ==  HORIZONTAL) {\n\t\t\t\tint x = pos[i][1];\n\t\t\t\tFOR(y, min(pos[i][0], pos[i][2])+1, max(pos[i][0], pos[i][2])-1) {\n\t\t\t\t\tif(field[y][x] == '.') {\n\t\t\t\t\t\tans += 2;\n\t\t\t\t\t\ttype[i] = NONE;\n\t\t\t\t\t\tfield[pos[i][0]][pos[i][1]] = field[pos[i][2]][pos[i][3]] = '.';\n\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if(type[i] == CORNER) {\n\t\t\t\tif(field[pos[i][0]][pos[i][3]] == '.' ||  field[pos[i][2]][pos[i][1]] == '.') {\n\t\t\t\t\tans += 2;\n\t\t\t\t\ttype[i] = NONE;\n\t\t\t\t\tfield[pos[i][0]][pos[i][1]] = field[pos[i][2]][pos[i][3]] = '.';\n\t\t\t\t\tupdated = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) begin(v), end(v)\n#define REV(v) rbegin(v), rend(v)\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint main(){\n\tint n, m;\n\tcin >> n >> m;\n\n\tvector<string> v(n);\n\trep(i, n) cin >> v[i];\n\n\tvector<P> a[26];\n\trep(i, n) rep(j, m){\n\t\tif (v[i][j] != '.') a[v[i][j] - 'A'].push_back(MP(j, i));\n\t}\n\n\tvector<int> bits[26];\n\tint ex[26] = {};\n\n\tauto f_x = [&bits, &v](int x1, int x2, int y, int i, int j){\n\t\tfor (int x = x1; x <= x2; ++x) if (v[y][x] != '.') bits[i][j] |= 1 << v[y][x] - 'A';\n\t\tbits[i][j] &= ~(1 << i);\n\t};\n\tauto f_y = [&bits, &v](int y1, int y2, int x, int i, int j){\n\t\tfor (int y = y1; y <= y2; ++y) if (v[y][x] != '.') bits[i][j] |= 1 << v[y][x] - 'A';\n\t\tbits[i][j] &= ~(1 << i);\n\t};\n\n\trep(i, 26){\n\t\tif (a[i].empty()) continue;\n\t\tex[i] = 1;\n\t\tbits[i].resize(1);\n\n\t\tint t, b, l, r;\n\t\tt = a[i][0].Y;\n\t\tb = a[i][1].Y;\n\t\tl = a[i][0].X;\n\t\tr = a[i][1].X;\n\t\tif (l == r){\n\t\t\tif (t > b) swap(t, b);\n\t\t\tf_y(t, b, l, i, 0);\n\t\t\tif (b - t == 1) bits[i][0] = -1;\n\t\t}\n\t\telse if (a[i][0].Y == a[i][1].Y){\n\t\t\tif (l > r) swap(l, r);\n\t\t\tf_x(l, r, t, i, 0);\n\t\t\tif (r - l == 1) bits[i][0] = -1;\n\t\t}\n\t\telse{\n\t\t\tbits[i].resize(2);\n\t\t\tvector<int> j = { 0, 1, 1, 0 };\n\t\t\tif (a[i][0].X < a[i][1].X){\n\t\t\t\tswap(j[1], j[3]);\n\t\t\t\tswap(l, r);\n\t\t\t}\n\t\t\tf_x(l, r, t, i, j[0]);\n\t\t\tf_y(t, b, l, i, j[1]);\n\t\t\tf_x(l, r, b, i, j[2]);\n\t\t\tf_y(t, b, r, i, j[3]);\n\t\t}\n\t}\n\n\tint cnt = 0;\n\tint state = (1 << 26)-1;\n\twhile (1){\n\t\tbool upd = false;\n\n\t\trep(i, 26){\n\t\t\tif (!ex[i]) continue;\n\t\t\tbool er = false;\n\t\t\tfor(auto x : bits[i]){\n\t\t\t\tif (x&state) continue;\n\t\t\t\ter = true;\n\t\t\t}\n\t\t\tif (er){\n\t\t\t\tex[i] = 0, upd = true, ++cnt;\n\t\t\t\tstate &= ~(1 << i);\n\t\t\t}\n\t\t}\n\n\t\tif (!upd) break;\n\t}\n\tcout << cnt * 2 << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint m,n;\nvector<P> data[30];\nvector<int> xindex;\nvector<int> yindex;\nint fie[250][250];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint pick[4];\nint pickx[4];\nint picky[4];\n\nint main(void){\n\tscanf(\"%d %d\",&n,&m);\n\tfor(int i=0;i<n;i++){\n\t\tstring str;\n\t\tcin >> str;\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(str[j]>='A' && str[j]<='Z'){\n\t\t\t\tdata[str[j]-'A'+1].push_back(P(j,i));\n\t\t\t\txindex.push_back(j-1);\n\t\t\t\txindex.push_back(j);\n\t\t\t\txindex.push_back(j+1);\n\t\t\t\tyindex.push_back(i-1);\n\t\t\t\tyindex.push_back(i);\n\t\t\t\tyindex.push_back(i+1);\n\t\t\t}\n\t\t}\n\t}\n\tsort(xindex.begin(),xindex.end());\n\txindex.erase(unique(xindex.begin(),xindex.end()),xindex.end());\n\tsort(yindex.begin(),yindex.end());\n\tyindex.erase(unique(yindex.begin(),yindex.end()),yindex.end());\n\tfor(int i=1;i<=26;i++){\n\t\tfor(int j=0;j<data[i].size();j++){\n\t\t\tdata[i][j].first=lower_bound(xindex.begin(),xindex.end(),data[i][j].first)-xindex.begin();\n\t\t\tdata[i][j].second=lower_bound(yindex.begin(),yindex.end(),data[i][j].second)-yindex.begin();\n\t\t\tfie[data[i][j].first][data[i][j].second]=i;\n\t\t}\n\t}\n\tbool flag=true;\n\tint score=0;\n\twhile(flag){\n\t\tflag=false;\n\t\tfor(int i=0;i<yindex.size();i++){\n\t\t\tfor(int j=0;j<xindex.size();j++){\n\t\t\t\tif(fie[j][i]==0){\n\t\t\t\t\tmemset(pick,0,sizeof(pick));\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tint x=j,y=i;\n\t\t\t\t\t\twhile((x>=0 && x<xindex.size() && y>=0 && y<yindex.size()) && fie[x][y]==0){\n\t\t\t\t\t\t\tx+=dx[k];\n\t\t\t\t\t\t\ty+=dy[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(fie[x][y]!=0){\n\t\t\t\t\t\t\tpick[k]=fie[x][y];\n\t\t\t\t\t\t\tpickx[k]=x;\n\t\t\t\t\t\t\tpicky[k]=y;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tfor(int l=k+1;l<4;l++){\n\t\t\t\t\t\t\tif(pick[k]==pick[l] && pick[k]!=0){\n\t\t\t\t\t\t\t\tscore+=2;\n\t\t\t\t\t\t\t\tfie[pickx[k]][picky[k]]=0;\n\t\t\t\t\t\t\t\tfie[pickx[l]][picky[l]]=0;\n\t\t\t\t\t\t\t\tflag=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",score);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nint m, n;\nchar c[500][500];\nvector<P> v;\nint dd[] = {-1, 0, 1, 0, -1};\n\nbool range(int y, int x) {\n    return 0 <= y && y < m && 0 <= x && x < n;\n}\n\nint check() {\n    P p;\n    int max = 0;\n    map<char, int> er;\n    rep(i, v.size()) {\n        map<char, int> mp;\n        set<char> s;\n        rep(j, 4) {\n            int ni = v[i].fi + dd[j], nj = v[i].se + dd[j + 1];\n            while(range(ni, nj) && c[ni][nj] == '.') ni += dd[j], nj += dd[j + 1];\n            if (range(ni, nj) && c[ni][nj] != '.') mp[c[ni][nj]]++, s.insert(c[ni][nj]);\n        }\n\n        int cnt = 0;\n        each(itr, s) {\n            if (mp[itr] > 1) cnt += mp[itr];\n        }\n\n        if (max < cnt) {\n            er = mp;\n            max = cnt;\n            p = v[i];\n            if (cnt == 4) break;\n        }\n    }\n\n    if (max > 0) {\n        rep(j, 4) {\n            int ni = p.fi + dd[j], nj = p.se + dd[j + 1];\n            while(range(ni, nj) && c[ni][nj] == '.') ni += dd[j], nj += dd[j + 1];\n            if (range(ni, nj) && c[ni][nj] != '.' && er[c[ni][nj]] > 1) c[ni][nj] = '.', v.pb(P(ni, nj));\n        }\n        return check();\n    } else {\n        return v.size();\n    }\n}\n\nint main(){\n    cin.sync_with_stdio(false);\n    cin >> m >> n;\n    rep(i, m)rep(j, n) {\n        cin >> c[i][j];\n        if (c[i][j] == '.') v.pb(P(i, j));\n    }\n    int cnt = v.size();\n\n    cout << check() - cnt << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint m,n;\nvector<P> dat[30];\nvector<int> xind;\nvector<int> yind;\nint field[190][190];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint pickl[4];\nint picklx[4];\nint pickly[4];\n\nint main(void){\n\tscanf(\"%d %d\",&n,&m);\n\tmemset(field,0,sizeof(field));\n\tfor(int i=0;i<n;i++){\n\t\tstring str;\n\t\tcin >> str;\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(str[j]>='A' && str[j]<='Z'){\n\t\t\t\tdat[str[j]-'A'+1].push_back(P(j,i));\n\t\t\t\tif(j-1>=0)xind.push_back(j-1);\n\t\t\t\txind.push_back(j);\n\t\t\t\tif(j+1<m)xind.push_back(j+1);\n\t\t\t\tif(i-1>=0)yind.push_back(i-1);\n\t\t\t\tyind.push_back(i);\n\t\t\t\tif(i+1<n)yind.push_back(i+1);\n\t\t\t}\n\t\t}\n\t}\n\tsort(xind.begin(),xind.end());\n\txind.erase(unique(xind.begin(),xind.end()),xind.end());\n\tsort(yind.begin(),yind.end());\n\tyind.erase(unique(yind.begin(),yind.end()),yind.end());\n\tfor(int i=1;i<=26;i++){\n\t\tfor(int j=0;j<dat[i].size();j++){\n\t\t\tdat[i][j].first=lower_bound(xind.begin(),xind.end(),dat[i][j].first)-xind.begin();\n\t\t\tdat[i][j].second=lower_bound(yind.begin(),yind.end(),dat[i][j].second)-yind.begin();\n\t\t\tfield[dat[i][j].first][dat[i][j].second]=i;\n\t\t}\n\t}\n\tbool flag=true;\n\tint score2=0;\n\twhile(flag){\n\t\tflag=false;\n\t\tfor(int i=0;i<yind.size();i++){\n\t\t\tfor(int j=0;j<xind.size();j++){\n\t\t\t\tif(field[j][i]==0){\n\t\t\t\t\tmemset(pickl,0,sizeof(pickl));\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tint xx=j,yy=i;\n\t\t\t\t\t\tint xi=xind.size(),yi=yind.size();\n\t\t\t\t\t\twhile(xx>=0 && xx<xi && yy>=0 && yy<yi){\n\t\t\t\t\t\t\tif(field[xx][yy]!=0)break;\n\t\t\t\t\t\t\txx+=dx[k];\n\t\t\t\t\t\t\tyy+=dy[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(field[xx][yy]!=0){\n\t\t\t\t\t\t\tpickl[k]=field[xx][yy];\n\t\t\t\t\t\t\tpicklx[k]=xx;\n\t\t\t\t\t\t\tpickly[k]=yy;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tfor(int l=k+1;l<4;l++){\n\t\t\t\t\t\t\tif(pickl[k]==pickl[l] && pickl[k]!=0){\n\t\t\t\t\t\t\t\tscore2+=2;\n\t\t\t\t\t\t\t\tfield[picklx[k]][pickly[k]]=0;\n\t\t\t\t\t\t\t\tfield[picklx[l]][pickly[l]]=0;\n\t\t\t\t\t\t\t\tflag=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",score2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nint main(){\n  int H, W;\n  while(cin>>H>>W && H){\n    vector<string> grid(H);\n    REP(i, H) cin>>grid[i];\n    bool update = true;\n    int vx[26][2], vy[26][2];\n    memset(vx, -1, sizeof(vx));\n    memset(vy, -1, sizeof(vy));\n    REP(y, H)REP(x, W)if(isalpha(grid[y][x])){\n      int idx = grid[y][x] - 'A';\n      if(vx[idx][0] != -1){\n        vx[idx][1] = x, vy[idx][1] = y;\n      }else{\n        vx[idx][0] = x, vy[idx][0] = y;\n      }\n    }\n    int ans = 0;\n    while(update){\n      update = false;\n      REP(c, 26)if(vx[c][0] != -1){\n        //printf(\"%d %d %d %d\\n\", vx[c][0], vy[c][0], vx[c][1], vy[c][1]);\n        bool ok = true;\n        if(vx[c][0] == vx[c][1] && abs(vy[c][0] - vy[c][1]) <= 1) continue;\n        if(vy[c][0] == vy[c][1] && abs(vx[c][0] - vx[c][1]) <= 1) continue;\n        // x - 0 , y - 1\n        for(int x = min(vx[c][0], vx[c][1]); x <= max(vx[c][0], vx[c][1]); x++) if(grid[vy[c][1]][x] != '.' && grid[vy[c][1]][x] != (c + 'A')) ok = false;\n        for(int y = min(vy[c][0], vy[c][1]); y <= max(vy[c][0], vy[c][1]); y++) if(grid[y][vx[c][0]] != '.' && grid[y][vx[c][0]] != (c + 'A')) ok = false;\n        if(ok) goto GO;\n\n        ok = true;\n        for(int x = min(vx[c][0], vx[c][1]); x <= max(vx[c][0], vx[c][1]); x++) if(grid[vy[c][0]][x] != '.' && grid[vy[c][0]][x] != (c + 'A')) ok = false;\n        for(int y = min(vy[c][0], vy[c][1]); y <= max(vy[c][0], vy[c][1]); y++) if(grid[y][vx[c][1]] != '.' && grid[y][vx[c][1]] != (c + 'A')) ok = false;\n        if(!ok) continue;\n\n      GO:\n        //cout<<(char)(c + 'A')<<endl;\n        grid[vy[c][1]][vx[c][1]] = '.';\n        grid[vy[c][0]][vx[c][0]] = '.';\n        memset(vx[c], -1, sizeof(vx[c]));\n        memset(vy[c], -1, sizeof(vy[c]));\n        ans += 2;\n        update = true;\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef unsigned int uint;\n\nchar C[500][500];\nstruct P { int row, col; };\n\nint idx(char c) {return c - 'A'; };\nbool is_adjacent(P a, P b) { return abs(a.row - b.row) + abs(a.col - b.col) == 1; }\n\nuint between(P a, P b, bool diag) {\n    if (diag) swap(a, b);\n    uint ret = 0;\n    int d1 = (b.row >= a.row) ? 1 : -1;\n    for (int j = a.row; j != b.row + d1; j += d1) {\n        if (C[j][a.col] == '.' || C[j][a.col] == C[a.row][a.col]) continue;\n        ret |= 1LL << idx(C[j][a.col]);\n    }\n    int d2 = (b.col >= a.col) ? 1 : -1;\n    for (int j = a.col; j != b.col + d2; j += d2) {\n        if (C[b.row][j] == '.' || C[b.row][j] == C[a.row][a.col]) continue;\n        ret |= 1LL << idx(C[b.row][j]);\n    }\n    return ret;\n}\n\nint main() {\n    int M, N;\n    cin >> M >> N;\n    vector<P> pos[26];\n    for (int i = 0; i < M; ++i) {\n        for (int j = 0; j < N; ++j) {\n            cin >> C[i][j];\n            if (C[i][j] != '.') { pos[idx(C[i][j])].push_back((P){i, j}); }\n        }\n    }\n\n    uint req[26][2];  // req[i][j] := 文字iを取る前に取っておく必要がある文字の集合\n    for (int i = 0; i < 26; ++i) {\n        if (pos[i].empty() || is_adjacent(pos[i][0], pos[i][1])) {\n            req[i][0] = req[i][1] = -1;\n            continue;\n        }\n        req[i][0] = between(pos[i][0], pos[i][1], false);\n        req[i][1] = between(pos[i][0], pos[i][1], true);\n    }\n\n    uint has = 0;  // 現在持っている文字の集合\n    while (1) {\n        bool update = false;\n        for (int i = 0; i < 26; ++i) {\n            if ((has >> i) & 1) continue;\n            for (int j = 0; j < 2; ++j) {\n                if ((req[i][j] & has) == req[i][j]) {\n                    has |= (1LL << i);\n                    update = true;\n                    break;\n                }\n            }\n        }\n        if ( ! update) break;\n    }\n    cout << __builtin_popcountll(has) * 2 << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\nint H,W;\nstring s[500];\nint x[26][2],y[26][2];\nint sgn(int x){\n\tif(x>0) return -1;\n\treturn 1;\n}\nint main(){\n\tcin>>H>>W;\n\trep(i,H) cin>>s[i];\n\trep(i,26) rep(j,2) x[i][j]=y[i][j]=-1;\n\trep(i,H) rep(j,W){\n\t\tif(s[i][j]!='.'){\n\t\t\tint c=s[i][j]-'A';\n\t\t\tif(x[c][0]<0) x[c][0]=i,y[c][0]=j;\n\t\t\telse x[c][1]=i,y[c][1]=j;\n\t\t}\n\t}\n\tbool update=true;\n\tint ans=0;\n\tbool is[26]={};\n\trep(i,26){\n\t\tis[i]=(x[i][0]>=0);\n\t}\n\twhile(update){\n\t\tupdate=false;\n\t\trep(i,26) if(is[i]){\n\t\t\tif(x[i][0]==x[i][1]){\n\t\t\t\tif(y[i][0]>y[i][1]) swap(y[i][0],y[i][1]);\n\t\t\t\tif(y[i][0]+1==y[i][1]) continue;\n\t\t\t\tbool ok=true;\n\t\t\t\tfor(int yi=y[i][0]+1;yi<y[i][1];yi++) if(s[x[i][0]][yi]!='.') ok=false;\n\t\t\t\tif(ok){\n\t\t\t\t\tupdate=true;\n\t\t\t\t\tans+=2;\n\t\t\t\t\ts[x[i][0]][y[i][0]]='.';\n\t\t\t\t\ts[x[i][1]][y[i][1]]='.';\n\t\t\t\t\tis[i]=0;\n\t\t\t\t}\n\t\t\t}else if(y[i][0]==y[i][1]){\n\t\t\t\tif(x[i][0]>x[i][1]) swap(x[i][0],x[i][1]);\n\t\t\t\tif(x[i][0]+1==x[i][1]) continue;\n\t\t\t\tbool ok=true;\n\t\t\t\tfor(int xi=x[i][0]+1;xi<x[i][1];xi++) if(s[xi][y[i][0]]!='.') ok=false;\n\t\t\t\tif(ok){\n\t\t\t\t\tupdate=true;\n\t\t\t\t\tans+=2;\n\t\t\t\t\ts[x[i][0]][y[i][0]]='.';\n\t\t\t\t\ts[x[i][1]][y[i][1]]='.';\n\t\t\t\t\tis[i]=0;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tint xi=x[i][0],yi=y[i][1];\n\t\t\t\tbool ok=true;\n\t\t\t\tfor(;xi!=x[i][1];xi+=sgn(x[i][0]-x[i][1])) if(s[xi][yi]!='.') ok=false;\n\t\t\t\txi=x[i][0];\n\t\t\t\tfor(;yi!=y[i][0];yi+=sgn(y[i][1]-y[i][0])) if(s[xi][yi]!='.') ok=false;\n\t\t\t\tif(ok){\n\t\t\t\t\tupdate=true;\n\t\t\t\t\tans+=2;\n\t\t\t\t\ts[x[i][0]][y[i][0]]='.';\n\t\t\t\t\ts[x[i][1]][y[i][1]]='.';\n\t\t\t\t\tis[i]=0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tswap(x[i][0],x[i][1]);\n\t\t\t\tswap(y[i][0],y[i][1]);\n\t\t\t\txi=x[i][0],yi=y[i][1];\n\t\t\t\tok=true;\n\t\t\t\tfor(;xi!=x[i][1];xi+=sgn(x[i][0]-x[i][1])) if(s[xi][yi]!='.') ok=false;\n\t\t\t\txi=x[i][0];\n\t\t\t\tfor(;yi!=y[i][0];yi+=sgn(y[i][1]-y[i][0])) if(s[xi][yi]!='.') ok=false;\n\t\t\t\tif(ok){\n\t\t\t\t\tupdate=true;\n\t\t\t\t\tans+=2;\n\t\t\t\t\ts[x[i][0]][y[i][0]]='.';\n\t\t\t\t\ts[x[i][1]][y[i][1]]='.';\n\t\t\t\t\tis[i]=0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cctype>\n#include <vector>\n#include <set>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0 ; i < n ; i++)\n\nstruct Point{\n  int x1, y1, x2, y2;\n};\n\nconst int MAX = 510;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nchar field[MAX][MAX];\nbool found[26];\nPoint alpha[26];\n\nint H, W;\n\nbool canReach_x(char C, int x, int y1, int y2){\n  if(y1 > y2) swap(y1, y2);\n  for(int i = y1+1 ; i < y2 ; i++){\n    if(field[i][x] != '.') return false;\n  }\n  return true;\n}\n\nbool canReach_y(char C, int y, int x1, int x2){\n  if(x1 > x2) swap(x1, x2);\n  for(int j = x1+1 ; j < x2 ; j++){\n    if(field[y][j] != '.') return false;\n  }\n  return true;\n}\n\nbool canReach(char C, int cx, int cy, int x, int y){\n  if(cx == x){\n    if(!canReach_x(C, x, cy, y)) return false;\n  }\n  \n  if(cy == y){\n    if(!canReach_y(C, y, cx, x)) return false;\n  }\n  \n  if(field[cy][cx] != '.' && field[cy][cx] != C) return false;\n  \n  if(cx < x){\n    for(int j = x-1 ; j > cx ; j--){\n      if(field[y][j] != '.') return false;\n    }\n  }\n  \n  if(cx > x){\n    for(int j = x+1 ; j < cx ; j++){\n      if(field[y][j] != '.') return false;\n    }\n  }\n\n  if(cy < y){\n    for(int i = y-1 ; i > cy ; i--){\n      if(field[i][x] != '.') return false;\n    }\n\n  }\n  if(cy > y){\n    for(int i = y+1 ; i < y ; i++){\n      if(field[i][x] != '.') return false;\n    }\n\n  }\n\n  return true;\n}\n\nvoid output(){\n  rep(i, H){\n    rep(j, W){\n      cout << field[i][j];\n    }\n    cout << endl;\n  }\n  cout << endl;\n}\n\nint main(){\n  while(cin >> H >> W){\n    rep(i, H) cin >> field[i];\n    memset(alpha, 0, sizeof(alpha));\n    memset(found, 0, sizeof(found));\n    \n    rep(i, H){\n      rep(j, W){\n\tif(isalpha(field[i][j])){\n\t  int c = field[i][j]-'A';\n\t  if(!found[c]){\n\t    found[c] = true;\n\t    alpha[c].x1 = j, alpha[c].y1 = i;\n\t  }\n\t  else{\n\t    alpha[c].x2 = j, alpha[c].y2 = i;\n\t  }\t\n\t}\n      }\n    }\n    \n    Point cross[26];\n    rep(i, 26){\n      if(found[i]){\n\tcross[i].x1 = alpha[i].x1, cross[i].y1 = alpha[i].y2;\n\tcross[i].x2 = alpha[i].x2, cross[i].y2 = alpha[i].y1;\n      }\n    }\n    \n    int ans = 0;\n    \n    rep(i, H){\n      rep(j, W){\n\trep(k, 4){\n\t  int nx = j+dx[k], ny = i+dy[k];\n\t  if(nx < 0 || nx > W || ny < 0 || ny > H) continue;\n\t  if(field[i][j] == field[ny][nx]) found[field[i][j]-'A'] = false;\n\t}\n      }\n    }\n\t\n    \n    for(; ;){\n      bool flag = false;\n      rep(i, 26){\n\tif(found[i]){\n\t  \n\t  int X1 = cross[i].x1, Y1 = cross[i].y1, X2 = cross[i].x2, Y2 = cross[i].y2;\n\t  int x1 = alpha[i].x1, y1 = alpha[i].y1, x2 = alpha[i].x2, y2 = alpha[i].y2;\n\t  \n\t  //if(isalpha(field[Y1][X1]) || isalpha(field[Y2][X2])) continue;\n\n\t  if(((canReach('A'+i, X1, Y1, x1, y1) &&\n\t       canReach('A'+i, X1, Y1, x2, y2))) ||\n\t     ((canReach('A'+i, X2, Y2, x1, y1) &&\n\t       canReach('A'+i, X2, Y2, x2, y2)))){\n\t    \n\t    field[y1][x1] = field[y2][x2] = '.';\n\t    found[i] = false;\n\t    ans += 2;\n\t    flag = true;\n\t    //output();\n\t  }\n\t}\n      }\n      if(!flag) break;\n    }\n    \n    cout << ans << endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n, m;\nchar brd[500][500];\nint cnt = 0;\nvector<P> v[30];\n\nint main(){\n\tcin >> n >> m;\n\trep(i,n) rep(j,m){\n\t\tcin >> brd[i][j];\n\t\tif(brd[i][j] != '.') v[brd[i][j]-'A'].push_back(P(i,j));\n\t}\n\twhile(true){\n\t\tbool end = true;\n\t\trep(i,30){\n\t\t\tif(v[i].size() == 0) continue;\n\t\t\tbool ok1 = true, ok2 = true;\n\t\t\tint xx1 = v[i][0].first,yy1 = v[i][0].second;\n\t\t\tint xx2 = v[i][1].first,yy2 = v[i][1].second;\n\t\t\tint x1 = xx1, y1 = yy1, x2 = xx2, y2 = yy2;\n\t\t\tif(x1 > x2){\n\t\t\t\tswap(x1,x2);\n\t\t\t\tswap(y1,y2);\n\t\t\t}\n\t\t\tif(abs(x2-x1)+abs(y2-y1) == 1) continue;\n\t\t\tif(y1 < y2){\n\t\t\t\tfor(int j = x1; j <= x2; j++){\n\t\t\t\t\tif(brd[j][y1]!='.'&&brd[j][y1]-'A'!=i) ok1 = false;\n\t\t\t\t\tif(brd[j][y2]!='.'&&brd[j][y2]-'A'!=i) ok2 = false;\n\t\t\t\t}\n\t\t\t\tfor(int j = y2; j <= y1; j++){\n\t\t\t\t\tif(brd[x1][j]!='.'&&brd[x1][j]-'A'!=i) ok2 = false;\n\t\t\t\t\tif(brd[x2][j]!='.'&&brd[x2][j]-'A'!=i) ok1 = false;\n\t\t\t\t}\n\t\t\t\tif(ok1 == false && ok2 == false) continue;\n\t\t\t\tcnt += 2;\n\t\t\t\tbrd[xx1][yy1] = '.'; brd[xx2][yy2] = '.';\n\t\t\t\tend = false;\n\t\t\t\tv[i].clear();\n\t\t\t} else{\n\t\t\t\tfor(int j = x1; j <= x2; j++){\n\t\t\t\t\tif(brd[j][y1]!='.'&&brd[j][y1]-'A'!=i) ok1 = false;\n\t\t\t\t\tif(brd[j][y2]!='.'&&brd[j][y2]-'A'!=i) ok2 = false;\n\t\t\t\t}\n\t\t\t\tfor(int j = y1; j <= y2; j++){\n\t\t\t\t\tif(brd[x1][j]!='.'&&brd[x1][j]-'A'!=i) ok1 = false;\n\t\t\t\t\tif(brd[x2][j]!='.'&&brd[x2][j]-'A'!=i) ok2 = false;\n\t\t\t\t}\n\t\t\t\tif(ok1 == false && ok2 == false) continue;\n\t\t\t\tcnt += 2;\n\t\t\t\tbrd[xx1][yy1] = '.'; brd[xx2][yy2] = '.';\n\t\t\t\tend = false;\n\t\t\t\tv[i].clear();\n\t\t\t}\n\t\t}\n\t\tif(end) break;\n\t}\n\tcout << cnt << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<double,int,double> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nDef inf=sizeof(Def)==sizeof(long long)?2e18:1e9;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint MOD;\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tvs in(n);\n\trep(i,n)cin>>in[i];\n\tvp pos(26,{-1,-1});\n\trep(i,n)rep(j,m)if(in[i][j]!='.'){\n\t\tint t=in[i][j]-'A';\n\t\tif(pos[t].first==-1)pos[t].first=i*m+j;\n\t\telse pos[t].second=i*m+j;\n\t}\n\tint out=0;\n\twhile(1){\n\t\tbool h=false;\n\t\trep(i,26)if(pos[i].first+1){\n\t\t\tbool H=true;\n\t\t\tint xa=pos[i].first/m,ya=pos[i].first%m;\n\t\t\tint xb=pos[i].second/m,yb=pos[i].second%m;\n\t\t\tif(xa==xb&&abs(ya-yb)==1||ya==yb&&abs(xa-xb)==1)continue;\n\t\t\tloop(x,xa,xb+1)loop(y,min(ya,yb),max(ya,yb)+1)if(x==xa||x==xb||y==ya||y==yb){\n\t\t\t\tif(x==xa&&y==ya||x==xb||y==yb);\n\t\t\t\telse if(in[x][y]!='.')H=false;\n\t\t\t}\n\t\t\tif(H){\n\t\t\t\tin[xa][ya]='.';\n\t\t\t\tin[xb][yb]='.';\n\t\t\t\tpos[i].first=-1;\n\t\t\t\tout+=2;\n//\t\t\t\tcout<<xa<<\" \"<<ya<<\" \"<<xb<<\" \"<<yb<<endl;\n//\t\t\t\trep(q,n)cout<<in[q]<<endl;cout<<endl;\n\t\t\t}\n\t\t}\n\t\tif(!h)break;\n\t}\n\tcout<<out<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint m,n;\nchar c[500][500];\n\nint rec(int x, int y){\n  if( x<0 || x>=m ) return 0;\n  if( y<0 || y>=n ) return 0;\n\n  char U='^',D='~', R='>', L='<';\n  char *u, *d, *r, *l;\n  u=&U; d=&D; r=&R; l=&L;\n  for( int i=y;i>=0;i-- ) if( c[x][i]!='.' ){ u=&c[x][i]; break; }\n  for( int i=y;i<n;i++ )  if( c[x][i]!='.' ){ d=&c[x][i]; break; }\n  for( int i=x;i>=0;i-- ) if( c[i][y]!='.' ){ l=&c[i][y]; break; }\n  for( int i=x;i<m;i++ )  if( c[i][y]!='.' ){ r=&c[i][y]; break; }\n\n  int ret=0;\n  if( *u==*d ){\n    *u=*d='.'; ret+=2;\n  }else if( *u==*r ){\n    *u=*r='.'; ret+=2;\n  }else if( *u==*l ){\n    *u=*l='.'; ret+=2;\n  }\n  if( *d==*r && *d!='.' ){\n    *d=*r='.'; ret+=2;\n  }else if( *d==*l && *d!='.' ){\n    *d=*l='.'; ret+=2;\n  }\n\n  if( *r==*l && *r!='.' ){\n    *r=*l='.'; ret+=2;\n  }\n\n  return ret;\n}\n\nint main(){\n  cin >> m >> n;\n  for( int i=0;i<m;i++ )\n    for( int j=0;j<n;j++ )\n      cin >> c[i][j];\n\n  bool f=true;\n  int ans=0;\n  while( f ){\n    f=false;\n    for( int i=0;i<m;i++ )\n      for( int j=0;j<n;j++ )\n\tif( c[i][j]=='.' ){\n\t  int rc = rec(i,j);\n\t  if( rc>0 ){\n\t    ans += rc; f=true;\n\t  }\n\t}\n  }\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<VV> VVV;\ntypedef vector<vector<int>> Graph;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\nenum { X, Y, CHAR };\ntypedef vector<int> Tile;\n\nint H, W;\nvector<string> s;\n\n// N, E, S, W\nconst int dx[4] = {-1, 0,  1,  0};\nconst int dy[4] = { 0, 1,  0, -1};\n\ninline bool inside(int x, int y) {\n    return 0 <= x && x < H && 0 <= y && y < W;\n}\n\nTile findNearestTile(int x, int y, int k) {\n    if (!inside(x, y)) return Tile{-1, -1, -1};\n    if (isalpha(s[x][y])) return Tile{x, y, s[x][y] - 'A'};\n    return findNearestTile(x + dx[k], y + dy[k], k);\n}\n\nbool hit(int sx, int sy) {\n    if (isalpha(s[sx][sy])) {\n        rep(k, 4) {\n            int nx = sx + dx[k], ny = sy + dy[k];\n            if (!inside(nx, ny)) continue;\n            if (s[sx][sy] == s[nx][ny]) {\n                // cerr << \"hey!\" << endl;\n                // cerr << sx << \" \" << sy << \" \" << nx << \" \" << ny << endl;\n                s[sx][sy] = '.';\n                s[nx][ny] = '.';\n                return true;\n            }\n        }\n        return false;\n    }\n\n    // cout << \"hit: \" << sx << \" \" << sy << endl;\n    rep(start, 4) {\n        Tile tile1{-1, -1, -1};\n        rep(k, 4) {\n            // cout << start << \" \" << k << endl;\n            Tile tile2 = findNearestTile(sx, sy, (k + start) % 4);\n            if (tile2[CHAR] == -1) {\n                continue;\n            } else if (tile1[CHAR] == -1) {\n                tile1 = tile2;\n            } else if (tile1[CHAR] == tile2[CHAR]) {\n                // cout << sx << \" \" << sy << endl;\n                // cout << start << \" \" << k << endl;\n                // cout << tile1[X] << \" \" << tile1[Y] << \" \" << tile1[CHAR] << endl;\n                // cout << tile2[X] << \" \" << tile2[Y] << \" \" << tile2[CHAR] << endl;\n                s[tile1[X]][tile1[Y]] = '.';\n                s[tile2[X]][tile2[Y]] = '.';\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nbool search() {\n    rep(i, H) {\n        rep(j, W) {\n            if (hit(i, j)) {\n                // cout << \"hit\" << endl;\n                // cout << i << \" \" << j << endl;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nbool checkCompress(string line) {\n    for (const auto& c : line) {\n        if (c != '.') return false;\n    }\n    return true;\n}\n\nvoid compress(vector<string> &s) {\n    for (int i = 0; i < s.size(); ) {\n        if (checkCompress(s[i])) {\n            s.erase(s.begin() + i);\n        } else {\n            i++;\n        }\n    }\n}\n\nvoid rot(vector<string> &s) {\n    vector<string> t(s[0].size(), \"\");\n    rep(i, s.size()) rep(j, s[0].size()) {\n        t[j] += s[i][j];\n    }\n    s = t;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    cin >> H >> W;\n    s.resize(H);\n    rep(i, H) cin >> s[i];\n\n    rep(x, H) {\n        rep(y, W) {\n            rep(k, 4) {\n                int nx = x + dx[k], ny = y + dy[k];\n                if (!inside(nx, ny)) continue;\n                if (isalpha(s[x][y]) && s[x][y] == s[nx][ny]) {\n                    s[x][y] = '#';\n                    s[nx][ny] = '#';\n                }\n            }\n        }\n    }\n\n    compress(s);\n    // for (auto line : s) cout << line << endl;\n    // cout << endl;\n    rot(s);\n    // for (auto line : s) cout << line << endl;\n    // cout << endl;\n    compress(s);\n    // for (auto line : s) cout << line << endl;\n    // cout << endl;\n    rot(s);\n    // for (auto line : s) cout << line << endl;\n    // cout << endl;\n\n    H = s.size(), W = s[0].size();\n\n    int ans = 0;\n    while (search()) {\n        ans += 2;\n\n        // cout << ans << endl;\n        // rep(i, H) {\n        //     cout << s[i] << endl;\n        // }\n        // cout << endl;\n    }\n\n    cout << ans << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// #define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<VV> VVV;\ntypedef vector<vector<int>> Graph;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\nenum { X, Y, CHAR };\ntypedef vector<int> Tile;\n\nint H, W;\nvector<string> s;\n\n// N, E, S, W\nconst int dx[4] = {-1, 0,  1,  0};\nconst int dy[4] = { 0, 1,  0, -1};\n\ninline bool inside(int x, int y) {\n    return 0 <= x && x < H && 0 <= y && y < W;\n}\n\nTile findNearestTile(int x, int y, int k) {\n    if (!inside(x, y)) return Tile{-1, -1, -1};\n    if (isalpha(s[x][y])) return Tile{x, y, s[x][y] - 'A'};\n    return findNearestTile(x + dx[k], y + dy[k], k);\n}\n\nbool hit(int sx, int sy) {\n    // cout << \"hit: \" << sx << \" \" << sy << endl;\n    rep(start, 4) {\n        Tile tile1{-1, -1, -1};\n        rep(k, 4) {\n            // cout << start << \" \" << k << endl;\n            Tile tile2 = findNearestTile(sx, sy, (k + start) % 4);\n            if (tile2[CHAR] == -1) {\n                continue;\n            } else if (tile1[CHAR] == -1) {\n                tile1 = tile2;\n            } else if (tile1[CHAR] == tile2[CHAR]) {\n                // cout << sx << \" \" << sy << endl;\n                // cout << start << \" \" << k << endl;\n                // cout << tile1[X] << \" \" << tile1[Y] << \" \" << tile1[CHAR] << endl;\n                // cout << tile2[X] << \" \" << tile2[Y] << \" \" << tile2[CHAR] << endl;\n                s[tile1[X]][tile1[Y]] = '.';\n                s[tile2[X]][tile2[Y]] = '.';\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nbool search() {\n    rep(i, H) {\n        rep(j, W) {\n            if (s[i][j] == '.') {\n                if (hit(i, j)) {\n                    // cout << i << \" \" << j << endl;\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    cin >> H >> W;\n    s.resize(H);\n    rep(i, H) cin >> s[i];\n\n    int ans = 0;\n    while (search()) {\n        ans += 2;\n\n        // cout << ans << endl;\n        // rep(i, H) {\n        //     cout << s[i] << endl;\n        // }\n        // cout << endl;\n    }\n\n    cout << ans << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define rep(i, a, b) for (int i = (a); i < ((int)(b)); ++i)\n#define rrep(i, a, b) for (int i = (int)(b) - 1; i >= ((int)(a)); --i)\n#define all(c) c.begin(), c.end()\n#define sz(c) ((int)c.size())\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\n\nvoid dump_impl(string s) {}\ntemplate <class H, class... T>\nvoid dump_impl(string s, H head, T... tail) {\n    int p = 0;\n    rep(i, 0, sz(s)) {\n        char x = s[i];\n        if (x == ',' && p == 0) {\n            cerr << \" = \" << head << \", \";\n            dump_impl(s.substr(i + 1), tail...);\n            return;\n        } else {\n            cerr << x;\n            if (x == '(') p++;\n            if (x == ')') p--;\n        }\n    }\n}\n// #define dump(...) do { cerr << \"\\x1b[33;1m\"; dump_impl(#__VA_ARGS__ \",\", __VA_ARGS__); cerr << \"\\x1b[0m\" << endl; } while (0)\n#define dump(...)\n\nstruct Edge {\n    int src;\n    int dst;\n    int lr;\n};\n\nstruct Node {\n    int deg[2];\n    bool check() {\n        return deg[0] == 0 || deg[1] == 0;\n    }\n};\n\nconst int INF = 1e9;\n\nsigned main() {\n    int H, W;\n    cin >> H >> W;\n    vector<string> S(H);\n    rep(i, 0, H) {\n        cin >> S[i];\n    }\n    \n    vector<Node> node(26);\n    vector<vector<Edge>> g(26);\n    \n    vector<vector<pii>> pos(26);\n\n    vector<int> vis(26, true);\n    rep(r, 0, H) {\n        rep(c, 0, W) {\n            if (S[r][c] != '.') {\n                pos[S[r][c] - 'A'].push_back({r, c});\n                vis[S[r][c] - 'A'] = false;\n            }\n        }\n    }\n\n    rep(i, 0, 26) {\n        if (sz(pos[i]) == 0) continue;\n        assert(sz(pos[i]) == 2);\n        int x1, y1, x2, y2;\n        tie(y1, x1) = pos[i][0];\n        tie(y2, x2) = pos[i][1];\n        if ((abs(x1 - x2) == 1 && y1 == y2) || (abs(y1 - y2) == 1 && x1 == x2)) {\n            vis[i] = true;\n            continue;\n        }\n        \n        if (y1 == y2) {\n            set<int> tmp;\n            rep(x, min(x1, x2) + 1, max(x1, x2)) {\n                if (S[y1][x] != '.') {\n                    tmp.insert(S[y1][x] - 'A');\n                }\n            }\n            for (int x : tmp) {\n                g[x].push_back(Edge{x, i, 0});\n                node[i].deg[0]++;\n                node[i].deg[1] = INF;\n            }\n        } else if (x1 == x2) {\n            set<int> tmp;\n            rep(y, min(y1, y2) + 1, max(y1, y2)) {\n                if (S[y][x1] != '.') {\n                    tmp.insert(S[y][x1] - 'A');\n                }\n            }\n            for (int x : tmp) {\n                g[x].push_back(Edge{x, i, 0});\n                node[i].deg[0]++;\n                node[i].deg[1] = INF;\n            }\n        } else {\n            if (x1 < x2) {\n                {\n                    set<int> tmp;\n                    rep(x, x1 + 1, x2 + 1) {\n                        if (S[y1][x] != '.') {\n                            tmp.insert(S[y1][x] - 'A');\n                        }\n                    }\n                    rep(y, y1, y2) {\n                        if (S[y][x2] != '.') {\n                            tmp.insert(S[y][x2] - 'A');\n                        }\n                    }\n                    for (int x : tmp) {\n                        g[x].push_back(Edge{x, i, 0});\n                        node[i].deg[0]++;\n                    }\n                }\n                {\n                    set<int> tmp;\n                    rep(y, y1 + 1, y2 + 1) {\n                        if (S[y][x1] != '.') {\n                            tmp.insert(S[y][x1] - 'A');\n                        }\n                    }\n                    rep(x, x1, x2) {\n                        if (S[y2][x] != '.') {\n                            tmp.insert(S[y2][x] - 'A');\n                        }\n                    }\n                    for (int x : tmp) {\n                        g[x].push_back(Edge{x, i, 1});\n                        node[i].deg[1]++;\n                    }\n                }\n            } else {\n                {\n                    set<int> tmp;\n                    rrep(x, x2, x1) {\n                        if (S[y1][x] != '.') {\n                            tmp.insert(S[y1][x] - 'A');\n                        }\n                    }\n                    rep(y, y1, y2) {\n                        if (S[y][x2] != '.') {\n                            tmp.insert(S[y][x2] - 'A');\n                        }\n                    }\n                    for (int x : tmp) {\n                        g[x].push_back(Edge{x, i, 0});\n                        node[i].deg[0]++;\n                    }\n                }\n                {\n                    set<int> tmp;\n                    rep(y, y1 + 1, y2 + 1) {\n                        if (S[y][x1] != '.') {\n                            tmp.insert(S[y][x1] - 'A');\n                        }\n                    }\n                    rrep(x, x2 + 1, x1 + 1) {\n                        if (S[y2][x] != '.') {\n                            tmp.insert(S[y2][x] - 'A');\n                        }\n                    }\n                    for (int x : tmp) {\n                        g[x].push_back(Edge{x, i, 1});\n                        node[i].deg[1]++;\n                    }\n                }\n            }\n        }\n    }\n\n\n    dump(vis['T'-'A']);\n\n    int ans = 0;\n    queue<int> q;\n    rep(i, 0, 26) {\n        if (vis[i]) continue;\n        dump(char(i+'A'), node[i].deg[0], node[i].deg[1]);\n        if (node[i].check()) {\n            q.push(i);\n            vis[i] = true;\n            ans += 2;\n            dump(i);\n        }\n    }\n    while (sz(q)) {\n        int x = q.front(); q.pop();\n        for (Edge e : g[x]) {\n            if (vis[e.dst]) continue;\n\n            node[e.dst].deg[e.lr]--;\n            if (node[e.dst].check()) {\n                vis[e.dst] = true;\n                ans += 2;\n                q.push(e.dst);\n            }\n        }\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\n\nconst int MAXH = 503;\nconst int MAXW = 503;\nint H, W;\nchar G[MAXH][MAXW];\nvector<pair<int,int> > pos[26];\nint btween[26][2];\n\nint main() {\n  while(cin >> H >> W && (H|W)) {\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n\tcin >> G[i][j];\n      }\n    }\n\n    for(int i = 0; i < 26; ++i) pos[i].clear();\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n\tif(isalpha(G[i][j])) {\n\t  int k = G[i][j]-'A';\n\t  pos[k].push_back(make_pair(j,i));\n\t  sort(pos[k].begin(), pos[k].end());\n\t}\n      }\n    }\n\n    fill(btween[0], btween[26], 1<<26);\n    for(int k = 0; k < 26; ++k) {\n      if(pos[k].empty()) continue;\n      if(0) {\n      } else if(pos[k][0].first == pos[k][1].first) {\n\tint begin = min(pos[k][0].second, pos[k][1].second);\n\tint end = max(pos[k][0].second, pos[k][1].second);\n\tif(end - begin == 1) continue;\n\tbtween[k][0] = 0;\n\tint j = pos[k][0].first;\n\tfor(int i = begin+1; i < end; ++i) {\n\t  if(isalpha(G[i][j])) btween[k][0] |= ( 1<<(G[i][j]-'A') );\n\t}\n      } else if(pos[k][0].second == pos[k][1].second) {\n\tint begin = min(pos[k][0].first, pos[k][1].first);\n\tint end = max(pos[k][0].first, pos[k][1].first);\n\tif(end - begin == 1) continue;\n\tbtween[k][0] = 0;\n\tint i = pos[k][0].second;\n\tfor(int j = begin+1; j < end; ++j) {\n\t  if(isalpha(G[i][j])) btween[k][0] |= ( 1<<(G[i][j]-'A') );\n\t}\n      } else if(pos[k][0].second < pos[k][1].second) {\n\tbtween[k][0] = btween[k][1] = 0;\n\tfor(int i = pos[k][0].second+1, j = pos[k][0].first;\n\t    i < pos[k][1].second; ++i) {\n\t  if(isalpha(G[i][j])) btween[k][0] |= ( 1<<(G[i][j]-'A') );\n\t}\n\tfor(int i = pos[k][1].second, j = pos[k][0].first;\n\t    j < pos[k][1].first; ++j) {\n\t  if(isalpha(G[i][j])) btween[k][0] |= ( 1<<(G[i][j]-'A') );\n\t}\n\n\tfor(int i = pos[k][0].second, j = pos[k][0].first+1;\n\t    j < pos[k][1].first; ++j) {\n\t  if(isalpha(G[i][j])) btween[k][1] |= ( 1<<(G[i][j]-'A') );\n\t}\n\tfor(int i = pos[k][0].second, j = pos[k][1].first;\n\t    i < pos[k][1].second; ++i) {\n\t  if(isalpha(G[i][j])) btween[k][1] |= ( 1<<(G[i][j]-'A') );\n\t}\n      } else {\n\tbtween[k][0] = btween[k][1] = 0;\n\tfor(int i = pos[k][0].second-1, j = pos[k][0].first;\n\t    i > pos[k][1].second; --i) {\n\t  if(isalpha(G[i][j])) btween[k][0] |= ( 1<<(G[i][j]-'A') );\n\t}\n\tfor(int i = pos[k][1].second, j = pos[k][0].first;\n\t    j < pos[k][1].first; ++j) {\n\t  if(isalpha(G[i][j])) btween[k][0] |= ( 1<<(G[i][j]-'A') );\n\t}\n\n\tfor(int i = pos[k][0].second, j = pos[k][0].first+1;\n\t    j < pos[k][1].first; ++j) {\n\t  if(isalpha(G[i][j])) btween[k][1] |= ( 1<<(G[i][j]-'A') );\n\t}\n\tfor(int i = pos[k][0].second, j = pos[k][1].first;\n\t    i > pos[k][1].second; --i) {\n\t  if(isalpha(G[i][j])) btween[k][1] |= ( 1<<(G[i][j]-'A') );\n\t}\n      }\n    }\n\n    int bit = 0;\n    while(1) {\n      bool flag = false;\n      for(int i = 0; i < 26; ++i) {\n\tif(bit & (1<<i)) continue;\n\tif((btween[i][0] & ~bit) == 0 || (btween[i][1] & ~bit) == 0) {\n\t  bit |= (1<<i);\n\t  flag = true;\n\t  break;\n\t}\n      }\n      if(!flag) break;\n    }\n    cout << __builtin_popcount(bit)*2 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\nchar board[500][500];\nint main() {\n\tint m, n; cin >> m >> n;\n\tvector<int> v;\n\tvector<P> alfloc[26];\n\tint out = 0;\n\trep(i, m) {\n\t\tstring s; cin >> s;\n\t\trep(j, n) {\n\t\t\tboard[i][j] = s[j];\n\t\t\tif (s[j] != '.') {\n\t\t\t\tint x = s[j] - 'A';\n\t\t\t\tif (alfloc[x].size()) {\n\t\t\t\t\talfloc[x].push_back({ i,j });\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tv.push_back(x);\n\t\t\t\t\talfloc[x].push_back({ i,j });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint len = v.size();\n\tvector<int> inter[26][2];\n\tint used[26];\n\tfill(used, used + 26, 1);\n\trep(i, len) {\n\t\tused[v[i]] = 0;\n\t\tint alf = v[i];\n\t\tint sx = alfloc[alf][0].first;\n\t\tint gx = alfloc[alf][1].first;\n\t\tint sy = alfloc[alf][0].second;\n\t\tint gy = alfloc[alf][1].second;\n\t\tif (abs(sx - gx) + abs(sy - gy) == 1) {\n\t\t\tinter[v[i]][0].push_back(v[i]);\n\t\t\tinter[v[i]][1].push_back(v[i]);\n\t\t\tcontinue;\n\t\t}\n\t\tint cnt = 0;\n\t\tif (sx > gx) {\n\t\t\tswap(sx, gx); cnt++;\n\t\t}\n\t\tif (sy > gy) {\n\t\t\tswap(sy, gy); cnt++;\n\t\t}\n\t\tRep1(j, sx, gx) {\n\t\t\tchar x1 = board[j][sy];\n\t\t\tchar x2 = board[j][gy];\n\t\t\tif (x1 != '.'&&x1 - 'A' != v[i]) {\n\t\t\t\tinter[v[i]][0].push_back(x1 - 'A');\n\t\t\t}\n\t\t\tif (x2 != '.'&&x2 - 'A' != v[i]) {\n\t\t\t\tinter[v[i]][1].push_back(x2 - 'A');\n\t\t\t}\n\t\t}\n\t\tRep1(j, sy, gy) {\n\t\t\tchar x1 = board[sx][j];\n\t\t\tchar x2 = board[gx][j];\n\t\t\tif (cnt % 2 == 0) {\n\t\t\t\tif (x1 != '.'&&x1 - 'A' != v[i]) {\n\t\t\t\t\tinter[v[i]][1].push_back(x1 - 'A');\n\t\t\t\t}\n\t\t\t\tif (x2 != '.'&&x2 - 'A' != v[i]) {\n\t\t\t\t\tinter[v[i]][0].push_back(x2 - 'A');\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (x1 != '.'&&x1 - 'A' != v[i]) {\n\t\t\t\t\tinter[v[i]][0].push_back(x1 - 'A');\n\t\t\t\t}\n\t\t\t\tif (x2 != '.'&&x2 - 'A' != v[i]) {\n\t\t\t\t\tinter[v[i]][1].push_back(x2 - 'A');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twhile (true) {\n\t\tbool f = true;\n\t\trep(i, 26) {\n\t\t\tif (used[i])continue;\n\t\t\trep(j, 2) {\n\t\t\t    bool g = true;\n\t\t\t\trep(k, (int)inter[i][j].size()) {\n\t\t\t\t\tif (!used[inter[i][j][k]])g = false;\n\t\t\t\t}\n\t\t\t\tif (g) {\n\t\t\t\t\tf = false;\n\t\t\t\t\tused[i] = 1;\n\t\t\t\t\tout += 2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (f)break;\n\t}\n\tcout << out << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint m, n;\nint ct[26];\npair<int, int> pos[26][2];\n\nchar board[512][512];\nbool done[26];\n\nbool c(pair<int, int> a, pair<int, int> b, char ch)\n{\n\tif (a.first > b.first) swap(a.first, b.first);\n\tif (a.second > b.second) swap(a.second, b.second);\n\t\n\tfor (int i = a.first; i <= b.first; i++){\n\t\tfor (int j = a.second; j <= b.second; j++){\n\t\t\tif (isalpha(board[i][j]) && board[i][j] != ch) return (false);\n\t\t}\n\t}\n\t\n\treturn (true);\n}\n\nint main()\n{\n\tscanf(\"%d %d\", &m, &n);\n\t\n\tfor (int i = 0; i < m; i++){\n\t\tscanf(\"%s\", board[i]);\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (isalpha(board[i][j])) pos[board[i][j] - 'A'][ct[board[i][j] - 'A']++] = make_pair(i, j);\n\t\t}\n\t}\n\t\n\tfor (int t = 0; t < 26; t++){\n\t\tfor (int i = 0; i < 26; i++){\n\t\t\tif (done[i]) continue;\n\t\t\tif (abs(pos[i][0].first - pos[i][1].first) +\n\t\t\t\tabs(pos[i][0].second - pos[i][1].second) <= 1) continue;\n\t\t\t\n\t\t\tpair<int, int> tmp = make_pair(pos[i][0].first, pos[i][1].second);\n\t\t\t\n\t\t\tif (c(pos[i][0], tmp, i + 'A') + c(tmp, pos[i][1], i + 'A') == 2){\n\t\t\t\tdone[i] = true;\n\t\t\t\tboard[pos[i][0].first][pos[i][0].second] = '.';\n\t\t\t\tboard[pos[i][1].first][pos[i][1].second] = '.';\n\t\t\t}\n\t\t\t\n\t\t\ttmp = make_pair(pos[i][1].first, pos[i][0].second);\n\t\t\t\n\t\t\tif (c(pos[i][0], tmp, i + 'A') + c(tmp, pos[i][1], i + 'A') == 2){\n\t\t\t\tdone[i] = true;\n\t\t\t\tboard[pos[i][0].first][pos[i][0].second] = '.';\n\t\t\t\tboard[pos[i][1].first][pos[i][1].second] = '.';\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ret = 0;\n\tfor (int i = 0; i < 26; i++) ret += 2 * done[i];\n\t\n\tprintf(\"%d\\n\", ret);\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst vector<int> dir = { 0, 1, 0, -1 };\nint H, W;\nint main() {\n\tcin >> H >> W;\n\tvector<string> s(H);\n\tvector<int> cx, cy;\n\tfor (int i = 0; i < H; i++) {\n\t\tcin >> s[i];\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (s[i][j] != '.') {\n\t\t\t\tcx.push_back(j);\n\t\t\t\tcy.push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tsort(cx.begin(), cx.end());\n\tcx.erase(unique(cx.begin(), cx.end()), cx.end());\n\tfor (int i = 1; i < cx.size(); i++) {\n\t\tif (cx[i] - cx[i - 1] >= 2) cx.push_back(cx[i - 1] + 1);\n\t}\n\tsort(cx.begin(), cx.end());\n\tsort(cy.begin(), cy.end());\n\tcy.erase(unique(cy.begin(), cy.end()), cy.end());\n\tfor (int i = 1; i < cy.size(); i++) {\n\t\tif (cy[i] - cy[i - 1] >= 2) cy.push_back(cy[i - 1] + 1);\n\t}\n\tsort(cy.begin(), cy.end());\n\tH = cy.size(), W = cx.size();\n\tvector<string> t(H, string(W, '.'));\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (s[cy[i]][cx[j]] != '.') t[i][j] = s[cy[i]][cx[j]];\n\t\t}\n\t}\n\tint ret = 0;\n\twhile (true) {\n\t\tbool flag = false;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (t[i][j] != '.') continue;\n\t\t\t\tvector<vector<pair<int, int> > > d(26);\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tint tx = j, ty = i;\n\t\t\t\t\twhile (0 <= tx && tx < W && 0 <= ty && ty < H) {\n\t\t\t\t\t\tif (t[ty][tx] != '.') {\n\t\t\t\t\t\t\td[t[ty][tx] - 65].push_back(make_pair(tx, ty));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttx += dir[k];\n\t\t\t\t\t\tty += dir[k ^ 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int k = 0; k < 26; k++) {\n\t\t\t\t\tif (d[k].size() == 2) {\n\t\t\t\t\t\tflag = true; ret += 2;\n\t\t\t\t\t\tt[d[k][0].second][d[k][0].first] = '.';\n\t\t\t\t\t\tt[d[k][1].second][d[k][1].first] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!flag) break;\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cctype>\n#include <vector>\n#include <map>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0 ; i < n ; i++)\n\ntypedef pair<int, int> P;\n\nstruct Point{\n  int x, y;\n  Point(int a, int b){\n    x = a, y = b;\n  }\n};\n\nconst int MAX = 510;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nchar field[MAX][MAX];\nbool found[26];\nvector<Point> alpha[26];\nint H, W;\n\nbool checkH(int x1, int x2, int y, char c){\n  if(x1 > x2) swap(x1, x2);\n  for(int j = x1 ; j <= x2 ; j++){\n    if(field[y][j] != '.' && field[y][j] != c) return false;\n  }\n  return true;\n}\n\nbool checkW(int y1, int y2, int x, char c){\n  if(y1 > y2) swap(y1, y2);\n  for(int i = y1 ; i <= y2 ; i++){\n    if(field[i][x] != '.' && field[i][x] != c) return false;\n  }\n  return true;\n}\n\nint main(){\n  while(cin >> H >> W){\n    rep(i, H) cin >> field[i];\n    \n    memset(alpha, 0, sizeof(alpha));\n    memset(found, 0, sizeof(found));\n    \n    rep(i, H){\n      rep(j, W){\n\tif(isalpha(field[i][j])){\n\t  int c = field[i][j]-'A';\n\t  if(!found[c]){\n\t    found[c] = true;\n\t    alpha[c].push_back(Point(j, i));\n\t    //alpha[c].x1 = j, alpha[c].y1 = i;\n\t  }\n\t  else{\n\t    alpha[c].push_back(Point(j, i));\n\t    //alpha[c].x2 = j, alpha[c].y2 = i;\n\t  }\n\t}\n      }\n    }\n    \n    vector<Point> cross[26];\n    rep(i, 26){\n      if(found[i]){\n\tcross[i].push_back(Point(alpha[i][0].x, alpha[i][1].y));\n\tcross[i].push_back(Point(alpha[i][1].x, alpha[i][0].y));\n\t//cross[i].x1 = alpha[i].x1, cross[i].y1 = alpha[i].y2;\n\t//cross[i].x2 = alpha[i].x2, cross[i].y2 = alpha[i].y1;\n      }\n    }\n    \n    rep(i, H){\n      rep(j, W){\n\trep(k, 4){\n\t  int nx = j+dx[k], ny = i+dy[k];\n\t  if(nx < 0 || nx > W || ny < 0 || ny > H) continue;\n\t  if(field[i][j] == field[ny][nx]) found[field[i][j]-'A'] = false;\n\t}\n      }\n    }\n    \n    int ans = 0;\n    for(; ;){\n    Start:;\n      bool flag = false;\n      rep(i, 26){\n\tif(alpha[i].size() == 2 && found[i]){\t  \n\t  int X1 = cross[i][0].x, Y1 = cross[i][0].y, X2 = cross[i][1].x, Y2 = cross[i][1].y;\n\t  int x1 = alpha[i][0].x, y1 = alpha[i][0].y, x2 = alpha[i][1].x, y2 = alpha[i][1].y;\n\t  char c = 'A'+i;\n\t  \n\t  if(x1 == x2){\n\t    flag = checkW(y1, y2, x1, c);\n\t  }\n\t  else if(y1 == y2){\n\t    flag = checkH(x1, x2, y1, c);\t    \n\t  }\n\t  else{\n\t    if(((checkH(X1, x2, Y1, c) && (checkW(Y1, y1, X1, c)))) ||\n\t       ((checkH(X2, x1, Y2, c) && (checkW(Y2, y2, X2, c))))){\n\t      flag = true;\n\t    }\n\t  }\n\t  \n\t  if(flag){\n\t    //cout << c << endl;\n\t    found[i] = false;\n\t    ans += 2;\n\t    field[y1][x1] = '.', field[y2][x2] = '.';\t    \n\t    goto Start;\n\t  }\n\t  \n\t}\n      }\n      if(!flag) break;\n    }\n    cout << ans << endl;\n  }  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint M, N;\nchar c[555][555];\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n\nint beatPanel()\n{\n  int ret = 0;\n  for(int i = 0; i < M; i++) {\n    for(int j = 0; j < N; j++) {\n      if(c[i][j] != '.') continue;\n      vector<P> pos(30, P(-1, -1));\n      for(int k = 0; k < 4; k++) {\n\tint nx = j + dx[k], ny = i + dy[k];\n\twhile(0 <= nx && nx < N && 0 <= ny && ny < M && c[ny][nx] == '.') {\n\t  nx += dx[k], ny += dy[k];\n\t}\n\tif(0 <= nx && nx < N && 0 <= ny && ny < M) {\n\t  int idx = c[ny][nx] - 'A';\n\t  if(pos[idx].first != -1) {\n\t    int px = pos[idx].second, py = pos[idx].first;\n\t    c[ny][nx] = '.';\n\t    c[pos[idx].second][pos[idx].first] = '.';\n\t    ret += 2;\t    \n\t  } else {\n\t    pos[idx] = P(nx, ny);\n\t  }\n\t}\n      }\n    }      \n  }\n  return ret;\n}\n\nint main()\n{\n  cin >> M >> N;\n  for(int i = 0; i < M; i++) {\n    for(int j = 0; j < N; j++) cin >> c[i][j];\n  }\n  int ans = 0;\n  while(int get = beatPanel()) ans += get;\n\n  cout << ans << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n\nusing namespace std;\n\nint n,m;\nchar cmap[600][600];\n\nbool can(int x1, int y1, int x2, int y2) {\n    if(x1 > x2) swap(x1,x2), swap(y1,y2);\n\n    int xd = x2-x1 ? (x2-x1)/abs(x2-x1) : 0;\n    int yd = y2-y1 ? (y2-y1)/abs(y2-y1) : 0;\n\n    if(xd == 0) {\n        if(y1+yd==y2) return false;\n        for(int y=y1+yd; y!=y2; y+=yd)\n            if(cmap[y][x1] != '.')\n                return false;\n        return true;\n    }\n\n    if(yd == 0) {\n        if(x1+1==x2) return false;\n        for(int x=x1+1; x<x2; x++)\n            if(cmap[y1][x] != '.')\n                return false;\n        return true;\n    }\n\n    for(int x=x1+1; x<=x2; x++)\n        if(cmap[y1][x] != '.')\n            goto next;\n    for(int y=y1+yd; y!=y2; y+=yd)\n        if(cmap[y][x2] != '.')\n            goto next;\n    return true;\nnext:\n    for(int y=y1+yd; y!=y2; y+=yd)\n        if(cmap[y][x1] != '.')\n            return false;\n    for(int x=x1; x<x2; x++)\n        if(cmap[y2][x] != '.')\n            return false;\n    return true;\n}\n\nint main(void) {\n    int map['Z'-'A'+1][2][2];\n    memset(map, 0xFF, sizeof(map));\n\n    scanf(\"%d%d\",&m,&n);\n    for(int i=0; i<m; i++) {\n        scanf(\"%s\",cmap[i]);\n    }\n    for(int i=0; i<n; i++)\n        for(int j=0; j<m; j++) {\n            if(cmap[j][i] == '.') continue;\n            if(map[cmap[j][i]-'A'][0][0] == -1)\n                map[cmap[j][i]-'A'][0][0] = i, map[cmap[j][i]-'A'][0][1] = j;\n            else\n                map[cmap[j][i]-'A'][1][0] = i, map[cmap[j][i]-'A'][1][1] = j;\n        }\n\n    int res=0;\n    for(int i=0; i<100; i++)\n        for(char c='A'; c<='Z'; c++) {\n            if(map[c-'A'][0][0] == -1) continue;\n            if(can(map[c-'A'][0][0], map[c-'A'][0][1], map[c-'A'][1][0], map[c-'A'][1][1])) {\n                res+=2;\n                cmap[map[c-'A'][0][1]][map[c-'A'][0][0]] = '.';\n                cmap[map[c-'A'][1][1]][map[c-'A'][1][0]] = '.';\n                map[c-'A'][0][0] = -1;\n            }\n        }\n    printf(\"%d\\n\", res);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint H,W;\ntypedef pair<int,int>P;\n\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\nconst int TYPEX = 1;\nconst int TYPEY = 2;\nconst int ELSE = 3;\n\nclass Data{\npublic:\n  vector<P>pv;\n  bool used,notuse;\n  int type;\n  Data(){pv.clear();used = true;type = 0;notuse = false;};\n  void check(){\n    sort(pv.begin(),pv.end());\n    for(int i = 0 ; i < 4 ; i++){\n      P np = P(pv[0].first + dy[i],pv[0].second + dx[i]);\n      if(!(0 <= np.first && np.first < H && 0 <= np.second && np.second < W))continue;\n      if(pv[1] == np){\n\tnotuse = true;\n\treturn;\n      }\n    }\n    if(pv[0].first == pv[1].first)type = TYPEY;\n    else if(pv[0].second == pv[1].second)type = TYPEX;\n    else type = ELSE;\n  }\n};\n\nData data[26];\n\nvoid init(){\n  for(int i = 0 ; i < 26 ; i++)data[i] = Data();\n}\n\nvoid input(){\n  cin >> H >> W;\n  for(int i = 0 ; i < H ; i++){\n    for(int j = 0 ; j < W ; j++){\n      char c;\n      cin >> c;\n      if(c == '.')continue;\n      data[c-'A'].pv.push_back(P(i,j));\n      data[c-'A'].used = false;\n    }\n  }\n  for(int i = 0 ; i < 26 ; i++){\n    if(!data[i].used)data[i].check();\n  }\n\n  /*\n  for(int i = 0 ; i < 26 ; i++){\n    cout << \"i = \" << (char)(i + 'A') << \" used = \" << data[i].used << endl;\n  }\n  */\n}\n\nint run(int res){\n  for(int i = 0 ; i < 26 ; i++){\n    if(data[i].notuse)continue;\n    if(data[i].used)continue;\n    bool f = false;\n    bool f1,f2;\n    f1 = f2 = false;\n\n    P p0,p1,p2;\n    p0 = data[i].pv[0];\n    p1 = data[i].pv[1];\n\n    \n\n    if(data[i].type == TYPEX){\n      for(int j = 0 ; j < 26 ; j++){\n\tif(f)break;\n\tif(j == i)continue;\n\tif(data[j].used)continue;\n\tfor(int k = 0 ; k < 2 ; k++){\n\n\t  /*\n\t  if(i == 1 && j == 3){\n\t    cout << \"p0.first = \" << p0.first << \" p2.first = \" << p2.first << \n\t      \"p1.first = \" << p1.first << endl;\n\t  }\n\t  */\n\t  p2 = data[j].pv[k];\n\t  if(p0.second != p2.second)continue;\n\t  if(p0.first <= p2.first && p2.first <= p1.first){\n\t    f = true;\n\t    break;\n\t  }\n\t}\n      }\n    }\n    else if(data[i].type == TYPEY){\n      for(int j = 0 ; j < 26 ; j++){\n\tif(f)break;\n\tif(j == i)continue;\n\tif(data[j].used)continue;\n\tfor(int k = 0 ; k < 2 ; k++){\n\t  p2 = data[j].pv[k];\n\t  if(p0.first != p2.first)continue;\n\t  if(p0.second <= p2.second && p2.second <= p1.second){\n\t    f = true;\n\t    break;\n\t  }\n\t}\n      }\n    }\n    else {\n      for(int j = 0 ; j < 26 ; j++){\n\tif(f)break;\n\tif(j == i)continue;\t\n\tif(data[j].used)continue;\n\n\tfor(int k = 0 ; k < 2 ; k++){\n\t  p2 = data[j].pv[k];\n\t  int x1,x2,y1,y2;\n\t  if(p0.first < p1.first){\n\n\t    //cout << \"#\" << endl;\n\n\t    x1 = p0.second;\n\t    y1 = p0.first;\n\t    x2 = p1.second;\n\t    y2 = p1.first;\n\t    \n\t    if(p2.second == x1){\n\t      if(y1 <= p2.first && p2.first <= y2)f1 = true;\n\t    }\n\t    \n\t    if(p2.first == y1){\n\t      if(x1 <= p2.second && p2.second <= x2)f2 = true;\n\t    }\n\t    \n\t    if(p2.second == x2){\n\t      if(y1 <= p2.first && p2.first <= y2)f2 = true;\n\t    }\n\n\t    if(p2.first == y2){\n\t      if(x1 <= p2.second && p2.second <= x2)f1 = true;\n\t    }\n\n\t  }\n\t  else{\n\n\t    x1 = p0.second;\n\t    y1 = p1.first;\n\t    x2 = p1.second;\n\t    y2 = p0.first;\n\n\t    if(p2.second == x1){\n\t      if(y1 <= p2.first && p2.first <= y2)f1 = true;\n\t    }\n\t    \n\t    if(p2.first == y1){\n\t      if(x1 <= p2.second && p2.second <= x2)f1 = true;\n\t    }\n\t    \n\t    if(p2.second == x2){\n\t      if(y1 <= p2.first && p2.first <= y2)f2 = true;\n\t    }\n\n\t    if(p2.first == y2){\n\t      if(x1 <= p2.second && p2.second <= x2)f2 = true;\n\t    }\n\t  }\n\t}\n\tif(f1 && f2){\n\t  f = true;\n\t  break;\n\t}\n      }\n    }\n    if(f)continue;\n    //cout << \"del = \" << (char)(i + 'A') << endl;//\n    data[i].used = true;\n    return run(res+2);\n  }\n  return res;\n}\n\nint main(){\n  init();\n  input();\n  cout << run(0) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nchar field[500][501];\nint ax[26][2], ay[26][2];\n\nbool ok(char a, int bx, int by, int ex, int ey) {\n\tif (bx == ex) {\n\t\tif (by > ey) by ^= ey, ey ^= by, by ^= ey;\n\t\tfor (int y = by; y <= ey; y++)\n\t\t\tif (field[y][bx] != '.' && field[y][bx] != a) return false;\n\t} else /* if (by == ey) */ {\n\t\tif (bx > ex) bx ^= ex, ex ^= bx, bx ^= ex;\n\t\tfor (int x = bx; x <= ex; x++)\n\t\t\tif (field[by][x] != '.' && field[by][x] != a) return false;\n\t}\n\treturn true;\n}\n\nint main() {\n\tint h, w;\n\tint total = 0;\n\tcin >> h >> w;\n\tfor (int i = 0; i < 26; i++)\n\t\tax[i][0] = -1;\n\tfor (int y = 0; y < h; y++) {\n\t\tcin >> field[y];\n\t\tfor (int x = 0; x < w; x++) {\n\t\t\tif (field[y][x] != '.') {\n\t\t\t\tchar a = field[y][x] - 'A';\n\t\t\t\tif (ax[a][0] == -1)\n\t\t\t\t\tax[a][0] = x, ay[a][0] = y, total++;\n\t\t\t\telse\n\t\t\t\t\tax[a][1] = x, ay[a][1] = y;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < 26; i++) {\n\t\tif (ax[i][0] == ax[i][1] && (ay[i][0] == ay[i][1]+1 || ay[i][0]+1 == ay[i][1]))\n\t\t\tax[i][0] = -1;\n\t\telse if (ay[i][0] == ay[i][1] && (ax[i][0] == ax[i][1]+1 || ax[i][0]+1 == ax[i][1]))\n\t\t\tax[i][0] = -1;\n\t}\n\n\tint n = total, now;\n\tdo {\n\t\tnow = n;\n\t\tfor (int i = 0; i < 26; i++) {\n\t\t\tif (ax[i][0] == -1) continue;\n\t\t\tchar a = (char)('A'+i);\n\t\t\tif (\n\t\t\t\t\tok(a, ax[i][0], ay[i][0], ax[i][1], ay[i][0]) &&\n\t\t\t\t\tok(a, ax[i][1], ay[i][0], ax[i][1], ay[i][1])) {\n\t\t\t\tfield[ay[i][0]][ax[i][0]] = field[ay[i][1]][ax[i][1]] = '.';\n\t\t\t\tax[i][0] = -1;\n\t\t\t\tn--;\n\t\t\t} else if (\n\t\t\t\t\tok(a, ax[i][0], ay[i][0], ax[i][0], ay[i][1]) &&\n\t\t\t\t\tok(a, ax[i][0], ay[i][1], ax[i][1], ay[i][1])) {\n\t\t\t\tfield[ay[i][0]][ax[i][0]] = field[ay[i][1]][ax[i][1]] = '.';\n\t\t\t\tax[i][0] = -1;\n\t\t\t\tn--;\n\t\t\t}\n\t\t}\n\t} while (n < now);\n\n\tcout << (2*(total-now)) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint m,n;\nvector<P> data[30];\nvector<int> xindex;\nvector<int> yindex;\nint fie[180][180];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint pickl[4];\nint picklx[4];\nint pickly[4];\n\nint main(void){\n\tscanf(\"%d %d\",&n,&m);\n\tfor(int i=0;i<n;i++){\n\t\tstring str;\n\t\tcin >> str;\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(str[j]>='A' && str[j]<='Z'){\n\t\t\t\tdata[str[j]-'A'+1].push_back(P(j,i));\n\t\t\t\tif(j-1>=0)xindex.push_back(j-1);\n\t\t\t\txindex.push_back(j);\n\t\t\t\tif(j+1<m)xindex.push_back(j+1);\n\t\t\t\tif(i-1>=0)yindex.push_back(i-1);\n\t\t\t\tyindex.push_back(i);\n\t\t\t\tif(i+1<n)yindex.push_back(i+1);\n\t\t\t}\n\t\t}\n\t}\n\tsort(xindex.begin(),xindex.end());\n\txindex.erase(unique(xindex.begin(),xindex.end()),xindex.end());\n\tsort(yindex.begin(),yindex.end());\n\tyindex.erase(unique(yindex.begin(),yindex.end()),yindex.end());\n\tfor(int i=1;i<=26;i++){\n\t\tfor(int j=0;j<data[i].size();j++){\n\t\t\tdata[i][j].first=lower_bound(xindex.begin(),xindex.end(),data[i][j].first)-xindex.begin();\n\t\t\tdata[i][j].second=lower_bound(yindex.begin(),yindex.end(),data[i][j].second)-yindex.begin();\n\t\t\tfie[data[i][j].first][data[i][j].second]=i;\n\t\t}\n\t}\n\tbool flag=true;\n\tint score=0;\n\twhile(flag){\n\t\tflag=false;\n\t\tfor(int i=0;i<yindex.size();i++){\n\t\t\tfor(int j=0;j<xindex.size();j++){\n\t\t\t\tif(fie[j][i]==0){\n\t\t\t\t\tmemset(pickl,0,sizeof(pickl));\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tint x=j,y=i;\n\t\t\t\t\t\twhile(x>=0 && x<xindex.size() && y>=0 && y<yindex.size()){\n\t\t\t\t\t\t\tif(fie[x][y]!=0)break;\n\t\t\t\t\t\t\tx+=dx[k];\n\t\t\t\t\t\t\ty+=dy[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(fie[x][y]!=0){\n\t\t\t\t\t\t\tpickl[k]=fie[x][y];\n\t\t\t\t\t\t\tpicklx[k]=x;\n\t\t\t\t\t\t\tpickly[k]=y;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tfor(int l=k+1;l<4;l++){\n\t\t\t\t\t\t\tif(pickl[k]==pickl[l] && pickl[k]!=0){\n\t\t\t\t\t\t\t\tscore+=2;\n\t\t\t\t\t\t\t\tfie[picklx[k]][pickly[k]]=0;\n\t\t\t\t\t\t\t\tfie[picklx[l]][pickly[l]]=0;\n\t\t\t\t\t\t\t\tflag=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",score);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint m,n;\nvector<P> data[30];\nvector<int> xindex;\nvector<int> yindex;\nint fie[180][180];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint pickl[4];\nint picklx[4];\nint pickly[4];\n\nint main(void){\n\tscanf(\"%d %d\",&n,&m);\n\tfor(int i=0;i<n;i++){\n\t\tstring str;\n\t\tcin >> str;\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(str[j]>='A' && str[j]<='Z'){\n\t\t\t\tdata[str[j]-'A'+1].push_back(P(j,i));\n\t\t\t\tif(j-1>=0)xindex.push_back(j-1);\n\t\t\t\txindex.push_back(j);\n\t\t\t\tif(j+1<m)xindex.push_back(j+1);\n\t\t\t\tif(i-1>=0)yindex.push_back(i-1);\n\t\t\t\tyindex.push_back(i);\n\t\t\t\tif(i+1<n)yindex.push_back(i+1);\n\t\t\t}\n\t\t}\n\t}\n\tsort(xindex.begin(),xindex.end());\n\txindex.erase(unique(xindex.begin(),xindex.end()),xindex.end());\n\tsort(yindex.begin(),yindex.end());\n\tyindex.erase(unique(yindex.begin(),yindex.end()),yindex.end());\n\tfor(int i=1;i<=26;i++){\n\t\tfor(int j=0;j<data[i].size();j++){\n\t\t\tdata[i][j].first=lower_bound(xindex.begin(),xindex.end(),data[i][j].first)-xindex.begin();\n\t\t\tdata[i][j].second=lower_bound(yindex.begin(),yindex.end(),data[i][j].second)-yindex.begin();\n\t\t\tfie[data[i][j].first][data[i][j].second]=i;\n\t\t}\n\t}\n\tbool flag=true;\n\tint score=0;\n\twhile(flag){\n\t\tflag=false;\n\t\tfor(int i=0;i<yindex.size();i++){\n\t\t\tfor(int j=0;j<xindex.size();j++){\n\t\t\t\tif(fie[j][i]==0){\n\t\t\t\t\tmemset(pickl,0,sizeof(pickl));\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tint x=j,y=i;\n\t\t\t\t\t\tint cnt=0;\n\t\t\t\t\t\twhile(x>=0 && x<xindex.size() && y>=0 && y<yindex.size()){\n\t\t\t\t\t\t\tif(fie[x][y]!=0)break;\n\t\t\t\t\t\t\tx+=dx[k];\n\t\t\t\t\t\t\ty+=dy[k];\n\t\t\t\t\t\t\tif(cnt>=1000)return 0;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(fie[x][y]!=0){\n\t\t\t\t\t\t\tpickl[k]=fie[x][y];\n\t\t\t\t\t\t\tpicklx[k]=x;\n\t\t\t\t\t\t\tpickly[k]=y;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tfor(int l=k+1;l<4;l++){\n\t\t\t\t\t\t\tif(pickl[k]==pickl[l] && pickl[k]!=0){\n\t\t\t\t\t\t\t\tscore+=2;\n\t\t\t\t\t\t\t\tfie[picklx[k]][pickly[k]]=0;\n\t\t\t\t\t\t\t\tfie[picklx[l]][pickly[l]]=0;\n\t\t\t\t\t\t\t\tflag=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",score);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\n#include <array>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\n\n\ntypedef long long int ll;\ntypedef double D;      // ??§?¨?????????????double???long double?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\n\n\nconst int INF = (1<<30) - 1;\nconst D EPS = 1e-9;\n\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\nint M, N;\nvector<string> field;\n\nint dh[] = {-1, 1, 0, 0};\nint dw[] = {0, 0, 1, -1};\n\ninline bool in_field(int h, int w){\n    return 0<=h&&h<M && 0<=w&&w<N;\n}\n\nvoid solve(){\n    bool updated = true;\n    int count = 0;\n    while (updated) {\n        updated = false;\n        for(int i=0; i<M; i++){\n            for(int j=0; j<N; j++) if(field[i][j] == '.'){\n                vector<tuple<char, int, int>> colors;\n                \n                for(int d=0; d<4; d++){\n                    int l = 0;\n                    while(in_field(i+dh[d]*l, j+dw[d]*l) && field[i+dh[d]*l][j+dw[d]*l] == '.') l++;\n                    \n                    if(!in_field(i+dh[d]*l, j+dw[d]*l)) continue;\n                    \n                    colors.push_back(tuple<char, int, int>(field[i+dh[d]*l][j+dw[d]*l], i+dh[d]*l, j+dw[d]*l));\n                }\n                \n                for(int i=0; i<colors.size(); i++){\n                    for(int j=1+1; j<colors.size(); j++){\n                        char c1, c2;\n                        int h1, w1, h2, w2;\n                        tie(c1, h1, w1) = colors[i];\n                        tie(c2, h2, w2) = colors[j];\n                        if(c1 == c2){\n                            field[h1][w1] = field[h2][w2] = '.';\n                            count += 2;\n                            updated = true;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    cout << count << endl;\n}\n\n//g++ -std=c++0x -msse4.2 -O3\n//#include <bits/stdc++.h>\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    //cout.precision(16);\n    \n    cin >> M >> N;\n    field = vector<string>(M);\n    for(int i=0; i<M; i++)\n        cin >> field[i];\n    \n    solve();\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_H 500\n#define MAX_W 500\n#define F first\n#define S second\ntypedef pair<int,int> pii;\n\nint H,W;\nchar field[MAX_H][MAX_W];\nvector<pii> v[26];\n\nbool inField(int x,int y){\n    return (0 <= x && x < W && 0 <= y && y < H);\n}\n\nint calc(int x,int y){\n    for(int i = 0 ; i < 26 ; i++){\n        v[i].clear();\n    }\n    const int dx[] = {-1,0,1,0};\n    const int dy[] = {0,-1,0,1};\n    for(int i = 0 ; i < 4 ; i++){\n        int nx = x, ny = y;\n        while(1){\n            nx += dx[i]; ny += dy[i];\n            if(!inField(nx,ny)) break;\n            if(field[ny][nx] != '.'){\n                v[field[ny][nx]-'A'].push_back(pii(nx,ny));\n                break;\n            }\n        }\n    }\n    int res = 0;\n    for(int i = 0 ; i < 26 ; i++){\n        if(v[i].size() == 2){\n            field[v[i][0].S][v[i][0].F] = '.';\n            field[v[i][1].S][v[i][1].F] = '.';\n            res += 2;\n        }\n    }\n    return res;\n}\n\nint main(){\n    cin >> H >> W;\n    for(int i = 0 ; i < H ; i++){\n        for(int j = 0 ; j < W ; j++){\n            cin >> field[i][j];\n        }\n    }\n    int res = 0;\n    bool update = 1;\n    while(update){\n        update = 0;\n        for(int i = 0 ; i < H ; i++){\n            for(int j = 0 ; j < W ; j++){\n                if(field[i][j] != '.') continue;\n                int r = calc(j,i);\n                if(r > 0){\n                    res += r;\n                    update = 1;\n                }\n            }\n        }\n    }\n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P,P> PP;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\nint h,w;\nstring s[555];\n\nint dd[]={-1,0,1,0,-1};\n\nint change(int nh,int nw){\n\tint cnt=0;\n\tvector<char> cs;\n\tvector<P> ps;\n\trep(d,4){\n\t\tint dh=dd[d],dw=dd[d+1];\n\t\tint i=nh,j=nw;\n\t\twhile(i>=0&&i<h&&j>=0&&j<w&&s[i][j]=='.'){\n\t\t\ti+=dh; j+=dw;\n\t\t}\n\t\tif(i>=0&&i<h&&j>=0&&j<w){\n\t\t\tcs.pb(s[i][j]);\n\t\t\tps.pb(P(i,j));\n\t\t}\n\t}\n\trep(k,cs.size())rep(l,k){\n\t\tif(cs[k]!='.'&&cs[k]==cs[l]){\n\t\t\ts[ps[k].fi][ps[k].se]='.';\n\t\t\ts[ps[l].fi][ps[l].se]='.';\n\t\t\tcnt+=2;\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n\tcin>>h>>w;\n\trep(i,h)cin>>s[i];\n\tint res=0;\n\twhile(1){\n\t\tint cnt=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tif(s[i][j]!='.')continue;\n\t\t\tcnt+=change(i,j);\n\t\t}\n\t\tif(cnt==0)break;\n\t\tres+=cnt;\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint count(const vector<string>& grid,int x1,int y1,int x2,int y2)\n{\n\tassert(x1==x2 || y1==y2);\n\tint res=0;\n\tif(x1==x2){\n\t\tif(y1>y2) swap(y1,y2);\n\t\tfor(int y=y1;y<=y2;y++)\n\t\t\tres+=grid[y][x1]!='.';\n\t}\n\telse{\n\t\tif(x1>x2) swap(x1,x2);\n\t\tfor(int x=x1;x<=x2;x++)\n\t\t\tres+=grid[y1][x]!='.';\n\t}\n\treturn res;\n}\n\nbool canerase(const vector<string>& grid,const vector<int>& x,const vector<int>& y)\n{\n\tint x1=x[0],x2=x[1],y1=y[0],y2=y[1];\n\tif(x1==x2 || y1==y2){\n\t\treturn abs(x2-x1)+abs(y2-y1)>=2 && count(grid,x1,y1,x2,y2)==2;\n\t}\n\telse{\n\t\treturn count(grid,x1,y1,x2,y1)+count(grid,x2,y1,x2,y2)==2\n\t\t\t|| count(grid,x1,y1,x1,y2)+count(grid,x1,y2,x2,y2)==2;\n\t}\n}\n\nint main()\n{\n\tfor(int h,w;cin>>h>>w && h|w;){\n\t\tvector<string> grid(h);\n\t\tfor(int i=0;i<h;i++) cin>>grid[i];\n\t\t\n\t\tvector<vector<int>> xs(26),ys(26);\n\t\tfor(int i=0;i<h;i++)\n\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\tif(grid[i][j]!='.'){\n\t\t\t\t\tint k=grid[i][j]-'A';\n\t\t\t\t\txs[k].push_back(j);\n\t\t\t\t\tys[k].push_back(i);\n\t\t\t\t}\n\t\t\n\t\tint res=0;\n\t\tfor(;;){\n\t\t\tbool flg=false;\n\t\t\tfor(int i=0;i<26;i++){\n\t\t\t\tvector<int>& x=xs[i],y=ys[i];\n\t\t\t\tif(x.size() && canerase(grid,x,y)){\n\t\t\t\t\tgrid[y[0]][x[0]]=grid[y[1]][x[1]]='.';\n\t\t\t\t\tx.clear(),y.clear();\n\t\t\t\t\tres+=2;\n\t\t\t\t\tflg=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!flg) break;\n\t\t}\n\t\t\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n\nint H, W;\nint C[500][500];\n\nint count()\n{\n\trep(y, 0, H) rep(x, 0, W)\n\t{\n\t\tif (C[y][x] != '.') continue;\n\n\t\tint c[26];\n\t\trep(i, 0, 26) c[i] = 0;\n\n\t\tif (y != H - 1) rep(yy, y + 1, H) if (C[yy][x] != '.') \n\t\t{\n\t\t\tc[C[yy][x] - 'A']++;\n\t\t\tbreak;\n\t\t}\n\t\tif (y != 0) rrep(yy, y - 1, 0) if (C[yy][x] != '.')\n\t\t{\n\t\t\tc[C[yy][x] - 'A']++;\n\t\t\tbreak;\n\t\t}\n\t\tif (x != W - 1) rep(xx, x + 1, W) if (C[y][xx] != '.')\n\t\t{\n\t\t\tc[C[y][xx] - 'A']++;\n\t\t\tbreak;\n\t\t}\n\t\tif (x != 0) rrep(xx, x - 1, 0) if (C[y][xx] != '.')\n\t\t{\n\t\t\tc[C[y][xx] - 'A']++;\n\t\t\tbreak;\n\t\t}\n\n\t\tint ret = 0;\n\t\trep(i, 0, 26) if (c[i] == 2) ret += 2;\n\t\tif (ret > 0)\n\t\t{\n\t\t\trep(yy, 0, H) rep(xx, 0, W)\n\t\t\t{\n\t\t\t\tint cc = C[yy][xx] - 'A';\n\t\t\t\tif (c[cc] == 2) C[yy][xx] = '.';\n\t\t\t}\n\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint main()\n{\n\tcin >> H >> W;\n\n\trep(y, 0, H)\n\t{\n\t\tstring s; cin >> s;\n\t\trep(x, 0, W) C[y][x] = s[x];\n\t}\n\n\tint ans = 0;\n\twhile (1)\n\t{\n\t\tint d = count();\n\t\tif (!d) break;\n\t\tans += d;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// tsukasa_diary's programing contest code template\n#include <bits/stdc++.h>\nusing namespace std;\n// define\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define for_rev(i,a,b) for(int i=a;i>=b;--i)\n#define allof(a) a.begin(),a.end()\n#define minit(a,b) memset(a,b,sizeof(a))\n#define size_of(a) (int)a.size()\n// typedef\ntypedef long long lint;\ntypedef double Double;\ntypedef pair<int, int> pii;\n//\ntypedef vector< int > Array;\ntypedef vector< Array > Matrix;\ntypedef vector< Double > DArray;\ntypedef vector< DArray > DMatrix;\ntypedef vector< string > SArray;\ntypedef vector< pii > PArray;\n// popcount\ninline int POPCNT(int _x) { return __builtin_popcount(_x); }\ninline int POPCNT(lint _x) { return __builtin_popcountll(_x); }\n// inf\nconst int iINF = 1L << 30;\nconst lint lINF = 1LL << 60;\n// eps\nDouble EPS = 1e-9;\n// in range\ninline bool in_range(int _v, int _mx, int _mi) { return _mi <= _v && _v < _mx; }\ninline bool in_range(Double _v, Double _mi, Double _mx) { return -EPS < _v - _mi && _v - _mx < EPS; }\ninline bool in_range(int _x, int _y, int _W, int _H) { return 0 <= _x && _x < _W && 0 <= _y && _y < _H; }\n// neighbor clockwise\nconst int DX[4] = {0,1,0,-1}, DY[4] = {-1,0,1,0};\nconst int DX_[8] = {0,1,1,1,0,-1,-1,-1}, DY_[8] = {-1,-1,0,1,1,1,0,-1};\n// variable update\ninline void modAdd(int& _a, int _b, int _m) { _a = (_a + _b) % _m; }\ninline void modAdd(lint& _a, lint _b, lint _m) { _a = (_a + _b) % _m; }\ninline void minUpdate(int& _a, int _b) { _a = min(_a, _b); }\ninline void minUpdate(lint& _a, lint _b) { _a = min(_a, _b); }\ninline void maxUpdate(int& _a, int _b) { _a = max(_a, _b); }\ninline void maxUpdate(lint& _a, lint _b) { _a = max(_a, _b); }\n\nint H, W;\nstring grid[555];\n\nstruct Point {\n\tint x, y;\n\tPoint(int _x, int _y) : x(_x), y(_y) {}\n};\n\nvector< vector< Point > > vvp;\n\nbool is_able(int x, int y, int gx, int gy, int d, bool flp) {\n\tif (!in_range(x, y, W, H)) return false;\n\tif (grid[y][x] != '.' && grid[y][x] != grid[gy][gx]) return false;\n\tif (x == gx && y == gy) return true;\n\t\n\tif (is_able(x + DX[d], y + DY[d], gx, gy, d, flp)) return true;\n\tif (flp && is_able(x + DX[(d + 1) % 4], y + DY[(d + 1) % 4], gx, gy, (d + 1) % 4, false)) return true;\n\tif (flp && is_able(x + DX[(d + 3) % 4], y + DY[(d + 3) % 4], gx, gy, (d + 3) % 4, false)) return true;\n\t\n\treturn false;\n}\n\nvoid solve() {\n\tvvp.assign(26, vector< Point >());\n\t\n\tfor_(y,0,H) for_(x,0,W) {\n\t\tif (grid[y][x] != '.') {\n\t\t\tint id = grid[y][x] - 'A';\n\t\t\tvvp[id].push_back(Point(x, y));\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\t\n\tfor_(rep,0,26) {\n\t\tfor_(i,0,26) {\n\t\t\tif (size_of(vvp[i]) == 0) continue;\n\t\t\tPoint p1 = vvp[i][0], p2 = vvp[i][1];\n\t\t\t\n\t\t\tif (p1.x == p2.x && p1.y + 1 == p2.y) continue;\n\t\t\tif (p1.y == p2.y && p1.x + 1 == p2.x) continue;\n\t\t\t\n\t\t\tbool flag = false;\n\t\t\tfor_(d,0,4) flag |= is_able(p1.x, p1.y, p2.x, p2.y, d, true);\n\n\t\t\tif (flag) {\n\t\t\t\tgrid[p1.y][p1.x] = grid[p2.y][p2.x] = '.';\n\t\t\t\tans += 2;\n\t\t\t\tvvp[i].clear();\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n}\n\nint main() {\n\tcin >> H >> W;\n\tfor_(i,0,H) cin >> grid[i];\n\tsolve();\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <cctype>\n#include <cstdlib>\n\n#define N 501\n#define conv(x) (int)(x-'A')\n#define ft first\n#define sd second\n\nusing namespace std;\n\ntypedef pair<int,int> Pa;\n\nstruct P{\n  int x1, x2, y1, y2;\n  P() {}\n  P(int _x1, int _y1, int _x2, int _y2): x1(_x1), y1(_y1), x2(_x2), y2(_y2) {}\n};\n\nint h, w;\nchar a[N][N];\nmap<char, P> mpp;\nvector<char> v1, v2;\n\nint xdir[4] = {0, 1, 0, -1}, ydir[4] = {-1, 0, 1, 0};\nbool dfs(int sx, int sy, int gx, int gy)\n{\n  int dr;\n  char ch = a[sy][sx];\n  if(sx == gx){\n    dr = (sy > gy)? 0 : 2;\n  } else {\n    dr = (sx > gx)? 3 : 1;\n  }\n\n  while(!(sx == gx && sy == gy)){\n    sx += xdir[dr];\n    sy += ydir[dr];\n    if(sx < 0 || sx >= w || sy < 0 || sy >= h) return false;\n    if(isalpha(a[sy][sx]) && ch != a[sy][sx]) return false;\n  }\n\n  return true;\n}\n\nint solve()\n{\n  int t = -1, res = 0;\n\n  while(v1.size() != t){\n    t = v1.size();\n    v2.clear();\n\n    for(int i = 0; i < t; i++){\n      int x1 = mpp[v1[i]].x1, y1 = mpp[v1[i]].y1, x2 = mpp[v1[i]].x2, y2 = mpp[v1[i]].y2;\n      if((dfs(x1, y1, x1, y2) && dfs(x2, y2, x1, y2))\n\t || (dfs(x1, y1, x2, y1) && dfs(x2, y2, x2, y1))){\n\tres += 2;\n\ta[y1][x1] = a[y2][x2] = '.';\n      } else {\n\tv2.push_back(v1[i]);\n      }\n    }\n    v1 = v2;\n  }\n  v1.clear();\n  v2.clear();\n\n  return res;\n}\n\nbool check(int p1, int q1, int p2, int q2)\n{\n  return (abs(p1-p2)+abs(q1-q2) != 1);\n}\n\nint main()\n{\n  bool used[26];\n  while(cin>>h>>w && (h+w)){\n    map<char, vector<Pa> > mp;\n    fill(used, used+26, false);\n\n    for(int i = 0; i < h; i++)\n      for(int j = 0; j < w; j++){\n\tcin >> a[i][j];\n\tif(isalpha(a[i][j])){\n\t  vector<Pa> vec;\n\t  if(used[conv(a[i][j])]) vec = mp[a[i][j]];\n\t  vec.push_back(Pa(i, j));\n\t  mp[a[i][j]] = vec;\n\t  used[conv(a[i][j])] = true;\n\t}\n      }\n\n    for(int i = 0; i < 26; i++){\n      char ch = (char)('A'+i);\n      if(used[i] && check(mp[ch][0].ft, mp[ch][0].sd, mp[ch][1].ft, mp[ch][1].sd)){\n\tmpp[ch] = P(mp[ch][0].sd, mp[ch][0].ft, mp[ch][1].sd, mp[ch][1].ft);\n\tv1.push_back(ch);\n      }\n    }\n\n    cout << solve() << endl;\n    mpp.clear();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <map>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define LINE() cerr<< \" (L\" << __LINE__ << \")\"\n\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nint main() {\n\t\tint H,W;cin >>H >> W;\n\n\t\tvector<string> board(H);\n\t\tfor(int y=0;y<H;y++){\n\t\t\tcin >> board[y];\n\t\t}\n\n\t\tmap<int,int> xmap,ymap;\n\t\tfor(int y=0;y<H;y++){\n\t\t\tfor(int x=0;x<W;x++){\n\t\t\t\tif(board[y][x]!='.'){\n\t\t\t\t\txmap.insert(make_pair(x,1));\n\t\t\t\t\tymap.insert(make_pair(y,1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> xs,ys;\n\t\tfor(auto it=xmap.begin();it!=xmap.end();it++){\n\t\t\txs.push_back(it->first);\n\t\t}\n\t\tfor(auto it=ymap.begin();it!=ymap.end();it++){\n\t\t\tys.push_back(it->first);\n\t\t}\n\t\tsort(xs.begin(),xs.end());\n\t\tsort(ys.begin(),ys.end());\n\n\t\tint h=ys.size(),w=xs.size();\n\t\tint res=0;\n\t\tfor(int c=0;c<30;c++){\n\t\t\tfor(int y=0;y<h;y++)for(int x=0;x<w;x++)if(board[ys[y]][xs[x]]=='.'){\n\t\t\t\tmap<char,vector<pair<int,int>>> ps;\n\t\t\t\tfor(int d=0;d<4;d++){\n\t\t\t\t\tint px=x,py=y;\n\t\t\t\t\twhile( 0<= px && px < w && 0 <=py && py < h  &&   board[ys[py]][xs[px]]=='.'){\n\t\t\t\t\t\tpx+=dx[d];py+=dy[d];\n\t\t\t\t\t}\n\t\t\t\t\tif( 0<= px && px < w && 0 <=py && py < h  && board[ys[py]][xs[px]]!='.'){\n\t\t\t\t\t\tps[board[ys[py]][xs[px]]].push_back(make_pair(py,px));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor(auto it=ps.begin();it!=ps.end();it++){\n\t\t\t\t\tvector<pair<int,int>> vs=it->second;\n\t\t\t\t\tif(it->second.size()==2){\n\t\t\t\t\t\tres+=2;\n\t\t\t\t\t\tboard[ys[vs[0].first]][xs[vs[0].second]]='.';\n\t\t\t\t\t\tboard[ys[vs[1].first]][xs[vs[1].second]]='.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << res <<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nstring grid[500];\nint pos[26][2][2];\nbool use[26];\nint n,m;\nint res;\n\nbool cluck(int y,int x){\n  int k;\n  int cnt[26];\n  for(int i=0;i<26;i++)cnt[i] = 0;\n\n  k = 1;\n  while(y+k<n && grid[y+k][x] == '.')k++;\n  if(y+k<n)cnt[grid[y+k][x]-'A']++;\n\n  k = 1;\n  while(x+k<m && grid[y][x+k] == '.')k++;\n  if(x+k<m)cnt[grid[y][x+k]-'A']++;\n\n  k = 1;\n  while(y-k>=0 && grid[y-k][x] == '.')k++;\n  if(y-k>=0)cnt[grid[y-k][x]-'A']++;\n\n  k = 1;\n  while(x-k>=0 && grid[y][x-k] == '.')k++;\n  if(x-k>=0)cnt[grid[y][x-k]-'A']++;\n\n  bool f = false;\n  for(int i=0;i<26;i++){\n    if(cnt[i]>=2){\n      res += 2;\n      f = true;\n      for(int j=0;j<n;j++){\n\tfor(int k=0;k<m;k++){\n\t  if(grid[j][k] == 'A'+i)grid[j][k] ='.';\n\t}\n      }\n    }\n  }\n  return f;\n}\n\nint main(){\n  cin >> n >> m;\n  for(int i=0;i<n;i++)cin >> grid[i];\n\n  res = 0;\n  while(1){\n    bool f = false;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<m;j++){\n\tif(grid[i][j]=='.')f |= cluck(i,j);\n      }\n    }\n    if(!f)break;\n  }\n\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nusing int64 = int64_t;\n\nconstexpr int64 MOD = 1000000007;\n\nint M, N;\nstring c[500];\n\nint main() {\n    cin >> M >> N;\n    for (int j = 0; j < M; ++j)  {\n        cin >> c[j];\n    }\n\n    int idx[26], px[26][2], py[26][2];\n    fill(idx, idx+26, 0);\n    for (int j = 0; j < M; ++j) for (int k = 0; k < N; ++k) {\n        if (c[j][k] != '.') {\n            int a = c[j][k] - 'A';\n            px[a][idx[a]] = j;\n            py[a][idx[a]] = k;\n            ++idx[a];\n        }\n    }\n\n    int score = 0;\n    bool updated = true;\n    while (updated) {\n        updated = false;\n        for (int a = 0; a < 26; ++a) {\n            if (idx[a] == 0) continue;\n            int x1 = px[a][0], x2 = px[a][1], y1 = py[a][0], y2 = py[a][1];\n            bool ok = true;\n            if (x1 == x2) {\n                ok = false;\n                for (int j = min(y1, y2)+1; j < max(y1, y2); ++j) {\n                    ok = true;\n                    if (c[x1][j] != '.') { ok = false; break; }\n                }\n            } else if (y1 == y2) {\n                ok = false;\n                for (int j = min(x1, x2)+1; j < max(x1, x2); ++j) {\n                    ok = true; if (c[j][y1] != '.') { ok = false; break; }\n                }\n            } else {\n                int xl = min(x1, x2), yl = min(y1, y2), xh = max(x1, x2), yh = max(y1, y2); \n                char ch = a+'A';\n                bool s1 = true, s2 = true, s3 = true, s4 = true;\n                for (int tx = xl; tx <= xh; ++tx) {\n                    if (c[tx][yl] != '.' && c[tx][yl] != ch) { s1 = false; break; }\n                }\n                for (int ty = yl; ty <= yh; ++ty) {\n                    if (c[xl][ty] != '.' && c[xl][ty] != ch) { s2 = false; break; }\n                }\n                for (int tx = xl; tx <= xh; ++tx) {\n                    if (c[tx][yh] != '.' && c[tx][yh] != ch) { s3 = false; break; }\n                }\n                for (int ty = yl; ty <= yh; ++ty) {\n                    if (c[xh][ty] != '.' && c[xh][ty] != ch) { s4 = false; break; }\n                }\n                if ((x2-x1)*(y2-y1) > 0) {\n                    ok = (s1 && s4) || (s2 && s3);\n                } else {\n                    ok = (s1 && s2) || (s3 && s4);\n                }\n            }\n            if (ok) {\n                score += 2;\n                idx[a] = 0;\n                c[x1][y1] = c[x2][y2] = '.';\n                updated = true;\n                continue;\n            }\n        }\n    }\n    cout << score << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cctype>\n#include <cstdlib>\n\nusing namespace std;\n\nstruct Pos {\n    int r, c;\n\n    Pos() {}\n    Pos(int r, int c) : r(r), c(c) {}\n};\n\ninline int toidx(char c) {\n    return c - 'A';\n}\n\ninline int sign(int n) {\n    if(n == 0) return 0;\n    return n < 0 ? -1 : 1;\n}\n\ninline int dist(const Pos &p1, const Pos &p2) {\n    return abs(p1.r-p2.r) + abs(p1.c-p2.c);\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n\n    int R, C;\n    cin >> R >> C;\n\n    vector<string> v;\n    vector<vector<Pos> > pos(26);\n    for(int i = 0; i < R; ++i) {\n        string line;\n        cin >> line;\n\n        for(int j = 0; j < line.size(); ++j) {\n            if(isalpha(line[j])) {\n                pos[toidx(line[j])].push_back(Pos(i, j));\n            }\n        }\n\n        v.push_back(line);\n    }\n\n    int score = 0;\n    vector<int> used(26, 0);\n    while(true) {\n        bool modified = false;\n\n        for(int i = 0; i < pos.size(); ++i) {\n            if(used[i]) continue;\n            if(pos[i].size() == 0) continue;\n\n            const Pos &p1 = pos[i][0];\n            const Pos &p2 = pos[i][1];\n            if(dist(p1, p2) == 1) continue;\n\n            int r1 = p1.r;\n            int c1 = p2.c;\n            bool ok = true;\n            for(int c = c1; c != p1.c; c += sign(p1.c-c)) {\n                if(v[r1][c] != '.' && v[r1][c] != i+'A') ok = false;\n            }\n            for(int r = r1; r != p2.r; r += sign(p2.r-r)) {\n                if(v[r][c1] != '.' && v[r][c1] != i+'A') ok = false;\n            }\n            if(!ok) {\n                int r2 = p2.r;\n                int c2 = p1.c;\n                ok = true;\n                for(int c = c2; c != p2.c; c += sign(p2.c-c)) {\n                    if(v[r2][c] != '.' && v[r2][c] != i+'A') ok = false;\n                }\n                for(int r = r2; r != p1.r; r += sign(p1.r-r)) {\n                    if(v[r][c2] != '.' && v[r][c2] != i+'A') ok = false;\n                }\n            }\n\n            if(ok) {\n                score += 2;\n                v[p1.r][p1.c] = v[p2.r][p2.c] = '.';\n                used[i] = true;\n                modified = true;\n            }\n        }\n\n        if(!modified) break;\n    }\n\n    cout << score << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst vector<int> dir = { 0, 1, 0, -1 };\nint H, W;\nint main() {\n\tcin >> H >> W;\n\tvector<string> s(H);\n\tvector<int> cx, cy;\n\tfor (int i = 0; i < H; i++) {\n\t\tcin >> s[i];\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (s[i][j] != '.') {\n\t\t\t\tcx.push_back(j);\n\t\t\t\tcy.push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tsort(cx.begin(), cx.end());\n\tcx.erase(unique(cx.begin(), cx.end()), cx.end());\n\tsort(cy.begin(), cy.end());\n\tcy.erase(unique(cy.begin(), cy.end()), cy.end());\n\tH = cy.size() * 2 - 1, W = cx.size() * 2 - 1;\n\tvector<string> t(H, string(W, '.'));\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (s[cy[i]][cx[j]] != '.') t[i * 2 + 1][j * 2 + 1] = s[cy[i]][cx[j]];\n\t\t}\n\t}\n\tint ret = 0;\n\twhile (true) {\n\t\tbool flag = false;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (t[i][j] != '.') continue;\n\t\t\t\tvector<vector<pair<int, int> > > d(26);\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tint tx = j, ty = i;\n\t\t\t\t\twhile (0 <= tx && tx < W && 0 <= ty && ty < H) {\n\t\t\t\t\t\tif (t[ty][tx] != '.') {\n\t\t\t\t\t\t\td[t[ty][tx] - 65].push_back(make_pair(tx, ty));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttx += dir[k];\n\t\t\t\t\t\tty += dir[k ^ 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int k = 0; k < 26; k++) {\n\t\t\t\t\tif (d[k].size() == 2) {\n\t\t\t\t\t\tflag = true; ret += 2;\n\t\t\t\t\t\tt[d[k][0].second][d[k][0].first] = '.';\n\t\t\t\t\t\tt[d[k][1].second][d[k][1].first] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!flag) break;\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nconst int dy[] = {-1, 0, 1, 0}, dx[] = {0, -1, 0, 1};\nint h, w;\nint n[512][512][4];\nchar in[512][512];\ninline int next(int y, int x, int d){\n\tif(y < 0 || y >= h || x < 0 || x >= w || n[y][x][d] == -2) return -2;\n\tif(in[y][x] != '.') return n[y][x][d] = y * w + x;\n\tif(n[y][x][d] >= 0 && in[n[y][x][d] / w][n[y][x][d] % w] != '.') return n[y][x][d];\n\treturn n[y][x][d] = next(y + dy[d], x + dx[d], d);\n}\n\nint main(){\n\tcin >> h >> w;\n\trep(i, h) cin >> in[i];\n\tmemset(n, -1, sizeof(n));\n\t\n\tint ans = 0;\n\twhile(1){\n\t\tbool update = 0;\n\t\trep(i, h) rep(j, w) if(in[i][j] == '.'){\n\t\t\trep(d, 4) rep(e, d){\n\t\t\t\tint a = next(i, j, d), b = next(i, j, e);\n\t\t\t\tif(a < 0 || b < 0) continue;\n\t\t\t\tint ay = a / w, ax = a % w;\n\t\t\t\tint by = b / w, bx = b % w;\n\t\t\t\tif(in[ay][ax] != in[by][bx]) continue;\n\t\t\t\tin[ay][ax] = in[by][bx] = '.';\n\t\t\t\tans += 2;\n\t\t\t\tupdate = 1;\n\t\t\t}\n\t\t}\n\t\tif(!update) break;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cctype>\n#include <vector>\n#include <set>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0 ; i < n ; i++)\n\nstruct Point{\n  int x1, y1, x2, y2;\n};\n\nconst int MAX = 510;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nchar field[MAX][MAX];\nbool found[26];\nPoint alpha[26];\n\nint H, W;\n\nbool canReach_x(char C, int x, int y1, int y2){\n  if(y1 > y2) swap(y1, y2);\n  for(int i = y1 ; i <= y2 ; i++){\n    if(field[i][x] != '.' && field[i][x] != C) return false;\n  }\n  return true;\n}\n\nbool canReach_y(char C, int y, int x1, int x2){\n  if(x1 > x2) swap(x1, x2);\n  for(int j = x1 ; j <= x2 ; j++){\n    if(field[y][j] != '.' && field[y][j] != C) return false;\n  }\n  return true;\n}\n\nbool canReach(char C, int cx, int cy, int x, int y){\n  if(cx == x){\n    if(!canReach_x(C, x, cy, y)) return false;\n  }\n  \n  else if(cx < x){\n    for(int j = x ; j >= cx ; j--){\n      if(field[y][j] != '.' && field[y][j] != C) return false;\n    }\n    //cout << \"x1 \" << endl;\n  }\n  \n  else if(cx > x){\n    for(int j = x ; j <= cx ; j++){\n      if(field[y][j] != '.' && field[y][j] != C) return false;\n    }\n    //cout << \"x2 \" << endl;  \n  }\n\n  if(cy == y){\n    if(!canReach_y(C, y, cx, x)) return false;\n  }\n  \n  else if(cy < y){\n    for(int i = y ; i >= cy ; i--){\n      if(field[i][x] != '.' && field[i][x] != C) return false;\n    }\n    //cout << \"y1 \" << endl;  \n  }\n  else if(cy > y){\n    for(int i = y ; i <= y ; i++){\n      if(field[i][x] != '.' && field[i][x] != C) return false;\n    }\n    //cout << \"y2 \" << endl;  \n  }\n\n  return true;\n}\n\nvoid output(){\n  rep(i, H){\n    rep(j, W){\n      cout << field[i][j];\n    }\n    cout << endl;\n  }\n  cout << endl;\n}\n\n\nint main(){\n  while(cin >> H >> W){\n    rep(i, H) cin >> field[i];\n\n    memset(found, 0, sizeof(found));\n    \n    rep(i, H){\n      rep(j, W){\n\tif(isalpha(field[i][j])){\n\t  int c = field[i][j]-'A';\n\t  if(!found[c]){\n\t    found[c] = true;\n\t    alpha[c].x1 = j, alpha[c].y1 = i;\n\t  }\n\t  else{\n\t    alpha[c].x2 = j, alpha[c].y2 = i;\n\t  }\t\n\t}\n      }\n    }\n    \n    Point cross[26];\n    rep(i, 26){\n      if(found[i]){\n\tcross[i].x1 = alpha[i].x1, cross[i].y1 = alpha[i].y2;\n\tcross[i].x2 = alpha[i].x2, cross[i].y2 = alpha[i].y1;\n      }\n    }\n    \n    int ans = 0;\n    \n    rep(i, H){\n      rep(j, W){\n\trep(k, 4){\n\t  int nx = j+dx[k], ny = i+dy[k];\n\t  if(nx < 0 || nx > W || ny < 0 || ny > H) continue;\n\t  if(field[i][j] == field[ny][nx]) found[field[i][j]-'A'] = false;\n\t}\n      }\n    }\n\t\n    \n    for(; ;){\n      //output();\n      bool flag = false;\n      rep(i, 26){\n\tif(found[i]){\n\t  int x1 = alpha[i].x1, y1 = alpha[i].y1, x2 = alpha[i].x2, y2 = alpha[i].y2;\n\t  \n\t  if(x1 == x2){\n\t    if(canReach_x('A'+i, x1, y1, y2)){\n\t      field[y1][x1] = field[y2][x2] = '.';\n\t      found[i] = false;\n\t      ans += 2;\n\t      flag = true;\n\t    }\n\t  }\n\t  else if(y1 == y2){\n\n\t    if(canReach_y('A'+i, y1, x1, x2)){\n\t      field[y1][x1] = field[y2][x2] = '.';\n\t      found[i] = false;\n\t      ans += 2;\n\t      flag = true;\n\t    }\n\t  }\t      \t    \t  \t  \n\t  else if(((canReach('A'+i, cross[i].x1, cross[i].y1, x1, y1) &&\n\t\t    canReach('A'+i, cross[i].x1, cross[i].y1, x2, y2))) ||\n\t\t  ((canReach('A'+i, cross[i].x2, cross[i].y2, x1, y1) &&\n\t\t    canReach('A'+i, cross[i].x2, cross[i].y2, x2, y2)))){\n\t    \n\t    //cout << \"x1, y1 \" << x1 << ' ' << y1 << \", x2, y2 \" << x2 << ' ' << y2 << endl;\n\t    //cout << canReach('A'+i, cross[i].x1, cross[i].y1, x1, y1) << endl;\n\t    //cout << canReach('A'+i, cross[i].x1, cross[i].y1, x2, y2) << endl;\n\t    //cout << canReach('A'+i, cross[i].x2, cross[i].y2, x2, y2) << endl;\n\t    //cout << canReach('A'+i, cross[i].x2, cross[i].y2, x1, y1) << endl;\n\t    //cout << \"c1 \" << cross[i].x1 << ' ' << cross[i].y1 << endl;\n\t    //cout << \"c2 \" << cross[i].x2 << ' ' << cross[i].y2 << endl;\n\t    \n\t    field[y1][x1] = field[y2][x2] = '.';\n\t    found[i] = false;\n\t    ans += 2;\n\t    flag = true;\n\t  }\n\t}\n      }\n      if(!flag) break;\n    }\n    \n    cout << ans << endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cctype>\n#include <vector>\n#include <set>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0 ; i < n ; i++)\n\nstruct Point{\n  int x1, y1, x2, y2;\n};\n\nconst int MAX = 610;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nchar field[MAX][MAX];\nbool found[256];\nPoint alpha[256];\n\nint H, W;\n\nbool canReach(char C, int cx, int cy, int x, int y){\n  if(cx < x){\n    for(int j = x ; j >= cx ; j--){\n      if(field[y][j] != '.' && field[y][j] != C) return false;\n    }\n  }\n  else if(cx > x){\n    for(int j = x ; j <= cx ; j++){\n      if(field[y][j] != '.' && field[y][j] != C) return false;\n    }\n  }\n  \n  if(cy < y){\n    for(int i = y ; i >= cy ; i--){\n      if(field[i][x] != '.' && field[i][x] != C) return false;\n    }\n  }\n  else if(cy > y){\n    for(int i = y ; i <= y ; i++){\n      if(field[i][x] != '.' && field[i][x] != C) return false;\n    }\n  }\n  return true;\n}\n\nbool canReach_x(char C, int x, int y1, int y2){\n  if(y1 > y2) swap(y1, y2);\n  for(int i = y1 ; i <= y2 ; i++){\n    if(field[i][x] != '.' && field[i][x] != C) return false;\n  }\n  return true;\n}\n\nbool canReach_y(char C, int y, int x1, int x2){\n  if(x1 > x2) swap(x1, x2);\n  for(int j = x1 ; j <= x2 ; j++){\n    if(field[y][j] != '.' && field[y][j] != C) return false;\n  }\n  return true;\n}\n\nint main(){\n  while(cin >> H >> W){\n    rep(i, H) cin >> field[i];\n\n    memset(found, 0, sizeof(found));\n    \n    rep(i, H){\n      rep(j, W){\n\tint c = field[i][j]-'A';\n\tif(!found[c]){\n\t  found[c] = true;\n\t  alpha[c].x1 = j, alpha[c].y1 = i;\n\t}\n\telse{\n\t  alpha[c].x2 = j, alpha[c].y2 = i;\n\t}\t\n      }\n    }\n    \n    Point cross[26];\n    rep(i, 26){\n      if(found[i]){\n\tcross[i].x1 = alpha[i].x1, cross[i].y1 = alpha[i].y2;\n\tcross[i].x2 = alpha[i].x2, cross[i].y2 = alpha[i].y1;\n      }\n    }\n    \n    int ans = 0;\n    \n    rep(i, H){\n      rep(j, W){\n\tchar c = field[i][j];\n\trep(k, 4){\n\t  int nx = j+dx[k], ny = i+dy[k];\n\t  if(nx < 0 || nx > W || ny < 0 || ny > H) continue;\n\t  if(field[i][j] == field[ny][nx]) found[field[i][j]-'A'] = false;\n\t}\n      }\n    }\n\t\n    \n    for(; ;){\n      bool flag = false;\n      rep(i, 26){\n\tif(found[i]){\n\t  int x1 = alpha[i].x1, y1 = alpha[i].y1, x2 = alpha[i].x2, y2 = alpha[i].y2;\n\t  \n\t  if(x1 == x2){\n\t    if(canReach_x('A'+i, x1, y1, y2)){\n\t      field[y1][x1] = field[y2][x2] = '.';\n\t      found[i] = false;\n\t      ans += 2;\n\t      flag = true;\n\t    }\n\t  }\n\t  else if(y1 == y2){\n\t    if(canReach_y('A'+i, y1, x1, x2)){\n\t      field[y1][x1] = field[y2][x2] = '.';\n\t      found[i] = false;\n\t      ans += 2;\n\t      flag = true;\n\t    }\n\t  }\t      \t    \t  \t  \n\t  else if((canReach('A'+i, cross[i].x1, cross[i].y1, x1, y1) &&\n\t\t   canReach('A'+i, cross[i].x1, cross[i].y1, x2, y2)) ||\n\t\t  (canReach('A'+i, cross[i].x2, cross[i].y2, x1, y1) &&\n\t\t   canReach('A'+i, cross[i].x2, cross[i].y2, x2, y2))){\n\t    field[y1][x1] = field[y2][x2] = '.';\n\t    found[i] = false;\n\t    ans += 2;\n\t    flag = true;\n\t  }\n\t}\n      }\n      if(!flag) break;\n    }\n    \n    cout << ans << endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cctype>\n#include <vector>\n#include <utility>\nusing namespace std;\n\ntypedef pair<int, int> pii;\nconst int INF = 1 << 28;\nchar board[510][510];\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\nint main() {\n    int H, W; scanf(\"%d%d\", &H, &W);\n    int rest = 0;\n    for(int i=0; i<H; i++) {\n        for(int j=0; j<W; j++) {\n            scanf(\" %c\", &board[i][j]);\n            if(isupper(board[i][j])) rest++;\n        }\n    }\n\n    int ans = 0;\n    while(rest--) {\n        pii INIT = make_pair(-INF, -INF);\n        for(int i=0; i<H; i++) {\n            for(int j=0; j<W; j++) {\n                vector<pii> rec(26, INIT);\n                if(isupper(board[i][j])) continue;\n                for(int k=0; k<4; k++) {\n                    int x = i, y = j;\n                    while(1) {\n                        x += dx[k], y += dy[k];\n                        if(x < 0 || x >= H || y < 0 || y >= W) break;\n                        if(isupper(board[x][y])) {\n                            int c = board[x][y] - 'A';\n                            if(rec[c] == INIT) rec[c] = make_pair(x, y);\n                            else {\n                                int u = rec[c].first, v = rec[c].second;\n                                // printf(\"found: (%d, %d) and (%d, %d): %c (%d, %d)\\n\", u, v, x, y, 'A' + c, i, j);\n                                board[u][v] = board[x][y] = '.';\n                                rec[c] = INIT;\n                                ans += 2;\n                            }\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint solve(void);\nbool canClear(const char target, vector<string>&mp, vector<vector<vector<int>>> &pos);\n\nint main(void) {\n\n//\tFILE *fpin = freopen(\"data.txt\", \"r\", stdin);\n\tcout << solve() << endl;\n\treturn 0;\n\n}\n\nint solve(void) {\n\n\tint N, M;\n\tcin >> M >> N;\n\n\tvector<string> mp(M);\n\tvector< int > isUsed(26, 0);\n\tvector< vector< vector< int > > > pos(2, vector< vector< int > >(2, vector< int >(26, 0)));\n\n\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> mp[i];\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tconst char ch = mp[i][j];\n\t\t\tif (ch != '.') {\n\t\t\t\tint index = ch - 'A';\n\t\t\t\tpos[isUsed[index]][0][index] = i;\n\t\t\t\tpos[isUsed[index]][1][index] = j;\n\t\t\t\tisUsed[index] ++;\n\t\t\t\tif (isUsed[index] == 2) {\n\t\t\t\t\tisUsed[index] = 0;\n\t\t\t\t\tif (pos[0][0][index] == pos[1][0][index] && abs(pos[0][1][index] - pos[1][1][index]) == 1) {\n\t\t\t\t\t\tisUsed[index] = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse if (pos[0][1][index] == pos[1][1][index] && abs(pos[0][0][index] - pos[1][0][index]) == 1) {\n\t\t\t\t\t\tisUsed[index] = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tisUsed[index] = 2;\n\t\t\t\t\t}\n\t\t\t\t\tif (pos[0][1][index] > pos[1][1][index]) {\n\t\t\t\t\t\tswap(pos[0][0][index], pos[1][0][index]);\n\t\t\t\t\t\tswap(pos[0][1][index], pos[1][1][index]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tbool b = true;\n\twhile (b == true) {\n\t\tb = false;\n\t\tfor (int i = 0; i < 26; i++) {\n\t\t\tif (isUsed[i] < 2) { continue; }\n\t\t\tchar ch = 'A' + i;\n\t\t\tb = canClear(ch, mp, pos);\n\t\t\tif (b) {\n\t\t\t\tisUsed[i] = 0;\n\t\t\t\tmp[pos[0][0][i]][pos[0][1][i]] = '.';\n\t\t\t\tmp[pos[1][0][i]][pos[1][1][i]] = '.';\n\t\t\t\tans += 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t}\n\n\t\n\treturn ans;\n}\n\nbool canClear(const char target, vector<string>& mp, vector<vector<vector<int>>>& pos)\n{\n\t\n\tint ind = target - 'A';\n\n\tint d[4][2] = { {0,1},{1,0},{0,-1},{-1,0} };\n\t/*\n\tdir[????????????????????????][1??????????????????2??????????????????] = ???????????????????????????\n\t0->???\n\t1->???\n\t2->???\n\t3->???\n\t*/\n\tint dir[2][2] = { {-1,-1},{-1,-1} };\n\tint start[2][2];\n\n\tfor (int i = 0; i < 2; i++) {\n\t\tstart[i][0] = pos[1-i][0][ind];\n\t\tstart[i][1] = pos[i][1][ind];\n\t}\n\n\tif (start[0][1] == start[1][1]) {\n\t\t//x??§?¨??????????\n\t\tstart[0][0] = (start[0][0] + start[1][0]) / 2;\n\t\tdir[0][0] = 1;\n\t\tdir[0][1] = 3;\n\t}\n\telse if (start[0][0] == start[1][0]) {\n\t\t//y??§?¨??????????\n\t\tstart[0][1] = (start[0][1] + start[1][1]) / 2;\n\t\tdir[0][0] = 0;\n\t\tdir[0][1] = 2;\n\t}\n\telse if (start[0][0] < start[1][0]) {\n\t\t//????????????\n\t\tdir[0][0] = 0;\n\t\tdir[0][1] = 1;\n\t\tdir[1][0] = 2;\n\t\tdir[1][1] = 3;\n\t}\n\telse {\n\t\t//????????????\n\t\tdir[0][0] = 0;\n\t\tdir[0][1] = 3;\n\t\tdir[1][0] = 1;\n\t\tdir[1][1] = 2;\n\t}\n\n\tfor (int i = 0; i < 2; i++) {\n\t\t//????????????????????????\n\t\tint cnt = 0;\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t//???????????????????????????\n\t\t\tif (dir[i][j] < 0) { continue; }\n\t\t\tfor (int t = 0;; t++) {\n\t\t\t\tint x, y;\n\t\t\t\ty = start[i][0] + d[dir[i][j]][0] * t;\n\t\t\t\tx = start[i][1] + d[dir[i][j]][1] * t;\n\t\t\t\tif (y >= 0 && y < mp.size() && x >= 0 && x < mp[y].length()) {\n\t\t\t\t\tif (mp[y][x] == target) {\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t\telse if (mp[y][x] != '.') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cnt == 2) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\n\treturn false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<VV> VVV;\ntypedef vector<vector<int>> Graph;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\nenum { X, Y, CHAR };\ntypedef vector<int> Tile;\n\nint H, W;\nvector<string> s;\n\n// N, E, S, W\nconst int dx[4] = {-1, 0,  1,  0};\nconst int dy[4] = { 0, 1,  0, -1};\n\ninline bool inside(int x, int y) {\n    return 0 <= x && x < H && 0 <= y && y < W;\n}\n\nTile findNearestTile(int x, int y, int k) {\n    if (!inside(x, y) || s[x][y] == '#') return Tile{-1, -1, -1};\n    if (isalpha(s[x][y])) return Tile{x, y, s[x][y] - 'A'};\n    return findNearestTile(x + dx[k], y + dy[k], k);\n}\n\nbool hit(int sx, int sy) {\n    if (s[sx][sy] == '#') return false;\n    if (isalpha(s[sx][sy])) {\n        rep(k, 4) {\n            int nx = sx + dx[k], ny = sy + dy[k];\n            if (!inside(nx, ny)) continue;\n            if (s[sx][sy] == s[nx][ny]) {\n                // cerr << \"hey!\" << endl;\n                // cerr << sx << \" \" << sy << \" \" << nx << \" \" << ny << endl;\n                s[sx][sy] = '.';\n                s[nx][ny] = '.';\n                return true;\n            }\n        }\n        return false;\n    }\n\n    // cout << \"hit: \" << sx << \" \" << sy << endl;\n    rep(start, 4) {\n        Tile tile1{-1, -1, -1};\n        rep(k, 4) {\n            // cout << start << \" \" << k << endl;\n            Tile tile2 = findNearestTile(sx, sy, (k + start) % 4);\n            if (tile2[CHAR] == -1) {\n                continue;\n            } else if (tile1[CHAR] == -1) {\n                tile1 = tile2;\n            } else if (tile1[CHAR] == tile2[CHAR]) {\n                // cout << sx << \" \" << sy << endl;\n                // cout << start << \" \" << k << endl;\n                // cout << tile1[X] << \" \" << tile1[Y] << \" \" << tile1[CHAR] << endl;\n                // cout << tile2[X] << \" \" << tile2[Y] << \" \" << tile2[CHAR] << endl;\n                s[tile1[X]][tile1[Y]] = '.';\n                s[tile2[X]][tile2[Y]] = '.';\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nbool search() {\n    rep(i, H) {\n        rep(j, W) {\n            if (hit(i, j)) {\n                // cout << \"hit\" << endl;\n                // cout << i << \" \" << j << endl;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nbool checkCompress(string line) {\n    for (const auto& c : line) {\n        if (c != '.') return false;\n    }\n    return true;\n}\n\nvoid compress(vector<string> &s) {\n    for (int i = 0; i < s.size(); ) {\n        if (checkCompress(s[i])) {\n            s.erase(s.begin() + i);\n        } else {\n            i++;\n        }\n    }\n}\n\nvoid rot(vector<string> &s) {\n    vector<string> t(s[0].size(), \"\");\n    rep(i, s.size()) rep(j, s[0].size()) {\n        t[j] += s[i][j];\n    }\n    s = t;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    cin >> H >> W;\n    s.resize(H);\n    rep(i, H) cin >> s[i];\n\n    rep(x, H) {\n        rep(y, W) {\n            rep(k, 4) {\n                int nx = x + dx[k], ny = y + dy[k];\n                if (!inside(nx, ny)) continue;\n                if (isalpha(s[x][y]) && s[x][y] == s[nx][ny]) {\n                    s[x][y] = '#';\n                    s[nx][ny] = '#';\n                }\n            }\n        }\n    }\n\n    compress(s);\n    // for (auto line : s) cout << line << endl;\n    // cout << endl;\n\n    if (s.empty()) {\n        cout << 0 << endl;\n        return 0;\n    }\n    rot(s);\n    // // for (auto line : s) cout << line << endl;\n    // // cout << endl;\n    compress(s);\n    // // for (auto line : s) cout << line << endl;\n    // // cout << endl;\n    rot(s);\n    // // for (auto line : s) cout << line << endl;\n    // // cout << endl;\n\n    H = s.size(), W = s[0].size();\n\n    int ans = 0;\n    while (search()) {\n        ans += 2;\n\n        // cout << ans << endl;\n        // rep(i, H) {\n        //     cout << s[i] << endl;\n        // }\n        // cout << endl;\n    }\n\n    cout << ans << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\n\nint h, w;\nchar field[1000][1000];\nvector<int> px[30];\nvector<int> py[30];\nvector<pair<int, int> > cand[30];\n\nvoid PrintField() {\n  REP(y, h) {\n    printf(\"%s\\n\", field[y]);\n  }\n}\n\nbool DontHave(int sx, int sy, int ex, int ey, int c) {\n  if (sx == ex && sy == ey) { return false; }\n  if (sx > ex && sy == ey) { swap(sx, ex); }\n  if (sx == ex && sy > ey) { swap(sy, ey); }\n  int dx = 0;\n  int dy = 0;\n  if (sx != ex) { dx++; }\n  else { dy++; }\n  if (field[sy][sx] == c) { sx += dx; sy += dy; }\n  while (sx != ex || sy != ey) {\n    if (field[sy][sx] != '.') { return false; }\n    sx += dx;\n    sy += dy;\n  }\n  return true;\n}\n\nint main() {\n  while (scanf(\"%d %d\", &h, &w) > 0) {\n    REP(i, 30) {\n      cand[i].clear();\n      px[i].clear();\n      py[i].clear();\n    }\n    REP(y, h) {\n      scanf(\"%s\", field[y]);\n    }\n    REP(y, h) {\n      REP(x, w) {\n        if (isupper(field[y][x])) {\n          int c = field[y][x] - 'A';\n          px[c].push_back(x);\n          py[c].push_back(y);\n        }\n      }\n    }\n    REP(i, 30) {\n      if (px[i].size() == 0) { continue; }\n      if (px[i][0] == px[i][1]) {\n        int sy = min(py[i][0], py[i][1]) + 1;\n        cand[i].push_back(make_pair(px[i][0], sy));\n      } else if (py[i][0] == py[i][1]) {\n        int sx = min(px[i][0], px[i][1]) + 1;\n        cand[i].push_back(make_pair(sx, py[i][0]));\n      } else {\n        cand[i].push_back(make_pair(px[i][0], py[i][1]));\n        cand[i].push_back(make_pair(px[i][1], py[i][0]));\n      }\n    }\n\n    int ans = 0;\n    while (true) {\n      bool end = true;\n      REP(i, 30) {\n        if (px[i].size() == 0) { continue; }\n        FORIT(it, cand[i]) {\n          if (field[it->second][it->first] != '.') { continue; }\n          if (DontHave(px[i][0], py[i][0], it->first, it->second, i + 'A') &&\n              DontHave(px[i][1], py[i][1], it->first, it->second, i + 'A')) {\n            field[py[i][0]][px[i][0]] = '.';\n            field[py[i][1]][px[i][1]] = '.';\n            px[i].clear();\n            py[i].clear();\n            cand[i].clear();\n            ans++;\n            end = false;\n            break;\n          }\n        }\n      }\n      if (end) { break; }\n    }\n    //PrintField();\n    printf(\"%d\\n\", ans * 2);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst int tx[] = {0,1,1,0};\nconst int ty[] = {0,0,1,1};\n \nstatic const double EPS = 1e-10;\n\nstruct Point {\n  int x;\n  int y;\n  Point(int _x,int _y) : x(_x) , y(_y) {}\n};\n\nint main(){\n  int H,W;\n  char stage[500][500];\n\n  map<char,vector<Point> > tiles;\n  while(~scanf(\"%d %d\",&H,&W)){\n    for(int y=0;y<H;y++){\n      string line;\n      cin >> line;\n      for(int x=0;x<W;x++){\n\tstage[y][x] = line[x];\n\tif(stage[y][x] != '.'){\n\t  tiles[stage[y][x]].push_back(Point(x,y));\n\t}\n      }\n    }\n\n    int erased_count = 0;\n    bool erased[256];\n    memset(erased,false,sizeof(erased));\n    erased['.'] = true;\n\n    for(int round=0;round <= 500*500; round++){\n      for(int target_char = 'A'; target_char <= 'Z'; target_char++){\n\tif(erased[target_char]) continue;\n\tif(tiles.find(target_char) == tiles.end()) continue;\n\t\n\tint x1 = tiles[target_char][0].x;\n\tint y1 = tiles[target_char][0].y;\n\n\tint x2 = tiles[target_char][1].x;\n\tint y2 = tiles[target_char][2].y;\n\n\tbool isok = true;\n\tif(x1 == x2){\n\t  int x = x1;\n\t  for(int y=min(y1,y2)+1;y<max(y1,y2);y++){\n\t    if(!erased[stage[y][x]]){\n\t      isok = false;\n\t      break;\n\t    }\n\t  }\n\t}\n\telse if(y1==y2){\n\t  int y = y1;\n\t  for(int x=min(x1,x2)+1;x<max(x1,x2);x++){\n\t    if(!erased[stage[y][x]]){\n\t      isok = false;\n\t      break;\n\t    }\n\t  }\n\t}\n\telse{\n\n\t  vector<Point> medium;\n\t  for(int i=0;i<tiles[target_char].size();i++){\n\t    for(int j=0;j<tiles[target_char].size();j++){\n\t      if(!((x1 == tiles[target_char][i].x && y1 == tiles[target_char][j].y)\n\t\t   || (x2 == tiles[target_char][i].x && y2 == tiles[target_char][j].y))){\n\t\tPoint mid(tiles[target_char][i].x,tiles[target_char][j].y);\n\n\t\t//target x1,y1\n\t\tint flag1 = 0;\n\t\tfor(int x = min(mid.x,x1);x<max(mid.x,x1); x++){\n\t\t  if(!erased[stage[y1][x]]) flag1 |= 1;\n\t\t}\n\n\t\tfor(int y = min(mid.y,y1);y<max(mid.y,y1); y++){\n\t\t  if(!erased[stage[y][x1]]) flag1 |= (1<<1);\n\t\t}\n\n\t\t//target x2,y2\n\t\tint flag2 = 0;\n\t\tfor(int x = min(mid.x,x2);x<max(mid.x,x2); x++){\n\t\t  if(!erased[stage[y2][x]]) flag2 |= 1;\n\t\t}\n\n\t\tfor(int y = min(mid.y,y2);y<max(mid.y,y2); y++){\n\t\t  if(!erased[stage[y][x2]]) flag2 |= (1<<1);\n\t\t}\n\n\t\tif(flag1 == ((1<<2)-1) && flag2 == ((1<<2)-1)){\n\t\t  isok = false;\n\t\t}\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tif(isok){\n\t  erased[target_char] = true;\n\t  erased_count++;\n\t}\n      }\n    }\n\n    printf(\"%d\\n\",erased_count*2);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nint main(){\n  int n;\n \n      string s;\n      int n,m;\n      cin >> n >> m;\n      cerr << n << m << endl;\n      for(int i=0;i<n;i++){\n\tcin >> s;\n\tcerr << s << endl;\n      }\n      cout << \"3\" << endl;\n    \n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 2299.cc: Tiles are Colorful\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_M = 500;\nconst int MAX_N = 500;\n\ntypedef long long ll;\n\nconst int INF = 1 << 30;\nconst ll LINF = 1LL << 60;\n\n/* typedef */\n\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef pair<int,int> pii;\n\n/* global variables */\n\nint flds[MAX_M][MAX_N];\npii ps[26], as[26];\nvi msks[26];\nbool used[26];\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  int m, n;\n  cin >> m >> n;\n\n  for (int i = 0; i < 26; i++) ps[i].first = -1;\n  \n  for (int y = 0; y < m; y++) {\n    string s;\n    cin >> s;\n    for (int x = 0; x < n; x++)\n      flds[y][x] = (s[x] == '.') ? -1 : s[x] - 'A';\n  }\n  \n  for (int y = 0; y < m; y++)\n    for (int x = 0; x < n; x++) {\n      int k = flds[y][x];\n      if (k >= 0) {\n\tif (ps[k].first < 0) ps[k] = pii(x, y);\n\telse {\n\t  int x0 = ps[k].first, y0 = ps[k].second;\n\t  if (x != x0 && y != y0) {\n\t    if (flds[y][x0] < 0 || flds[y0][x] < 0)\n\t      msks[k].push_back(0);\n\t    else {\n\t      msks[k].push_back(1 << flds[y][x0]);\n\t      msks[k].push_back(1 << flds[y0][x]);\n\t    }\n\t  }\n\t  else if (x == x0) {\n\t    if (y0 + 1 < y) {\n\t      int msk0 = 0;\n\t      for (int y1 = y0 + 1; y1 < y; y1++)\n\t\tif (flds[y1][x] >= 0) msk0 |= (1 << flds[y1][x]);\n\t      msks[k].push_back(msk0);\n\t    }\n\t  }\n\t  else {\n\t    if (x0 + 1 < x) {\n\t      int msk0 = 0;\n\t      for (int x1 = x0 + 1; x1 < x; x1++)\n\t\tif (flds[y][x1] >= 0) msk0 |= (1 << flds[y][x1]);\n\t      msks[k].push_back(msk0);\n\t    }\n\t  }\n\t}\n      }\n    }\n\n  int msk = 0;\n  int ans = 0;\n  \n  for (bool changed = true; changed;) {\n    changed = false;\n    for (int i = 0, bi = 1; i < 26; i++, bi <<= 1)\n      if (! used[i] && msks[i].size()) {\n\tfor (int j = 0; j < msks[i].size(); j++)\n\t  if ((msk & msks[i][j]) == msks[i][j]) {\n\t    used[i] = true;\n\t    msk |= bi;\n\t    ans++;\n\t    changed = true;\n\t    break;\n\t  }\n      }\n  }\n\n  printf(\"%d\\n\", ans * 2);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nusing int64 = int64_t;\n\nconstexpr int64 MOD = 1000000007;\n\nint M, N;\nstring c[500];\n\nint main() {\n    cin >> M >> N;\n    for (int j = 0; j < M; ++j)  {\n        cin >> c[j];\n    }\n\n    int idx[26], px[26][2], py[26][2];\n    fill(idx, idx+26, 0);\n    for (int j = 0; j < M; ++j) for (int k = 0; k < N; ++k) {\n        if (c[j][k] != '.') {\n            int a = c[j][k] - 'A';\n            px[a][idx[a]] = j;\n            py[a][idx[a]] = k;\n            ++idx[a];\n        }\n    }\n\n    int score = 0;\n    bool updated = true;\n    while (updated) {\n        updated = false;\n        for (int a = 0; a < 26; ++a) {\n            if (idx[a] == 0) continue;\n            int x1 = px[a][0], x2 = px[a][1], y1 = py[a][0], y2 = py[a][1];\n            bool ok = true;\n            if (x1 == x2) {\n                ok = false;\n                for (int j = min(y1, y2)+1; j < max(y1, y2); ++j) {\n                    ok = true;\n                    if (c[x1][j] != '.') { ok = false; break; }\n                }\n            } else if (y1 == y2) {\n                bool ok = false;\n                for (int j = min(x1, x2)+1; j < max(x1, x2); ++j) {\n                    ok = true; if (c[j][y1] != '.') { ok = false; break; }\n                }\n            } else {\n                int xl = min(x1, x2), yl = min(y1, y2), xh = max(x1, x2), yh = max(y1, y2); \n                char ch = a+'A';\n                bool s1 = true, s2 = true, s3 = true, s4 = true;\n                for (int tx = xl; tx <= xh; ++tx) {\n                    if (c[tx][yl] != '.' && c[tx][yl] != ch) { s1 = false; break; }\n                }\n                for (int ty = yl; ty <= yh; ++ty) {\n                    if (c[xl][ty] != '.' && c[xl][ty] != ch) { s2 = false; break; }\n                }\n                for (int tx = xl; tx <= xh; ++tx) {\n                    if (c[tx][yh] != '.' && c[tx][yh] != ch) { s3 = false; break; }\n                }\n                for (int ty = yl; ty <= yh; ++ty) {\n                    if (c[xh][ty] != '.' && c[xh][ty] != ch) { s4 = false; break; }\n                }\n                if ((x2-x1)*(y2-y1) > 0) {\n                    ok = (s1 && s4) || (s2 && s3);\n                } else {\n                    ok = (s1 && s2) || (s3 && s4);\n                }\n            }\n            if (ok) {\n                score += 2;\n                idx[a] = 0;\n                c[x1][y1] = c[x2][y2] = '.';\n                updated = true;\n                continue;\n            }\n        }\n    }\n    cout << score << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\nconst int inf=1e9;\ntypedef long long ll;\nint M,N;\nstring board[505];\n\nint hit(int hity,int hitx)\n{\n    int ret=0;\n    char up='-',down='-',right='-',left='-';\n    int leftx,rightx,upy,downy;\n    for(int y=hity;y>=0;y--)\n    {\n        if(board[y][hitx]!='.')\n        {\n            up=board[y][hitx];\n            upy=y;\n            break;\n        }\n    }\n    for(int y=hity;y<M;y++)\n    {\n        if(board[y][hitx]!='.')\n        {\n            down=board[y][hitx];\n            downy=y;\n            break;\n        }\n    }\n    for(int x=hitx;x>=0;x--)\n    {\n        if(board[hity][x]!='.')\n        {\n            left=board[hity][x];\n            leftx=x;\n            break;\n        }\n    }\n    for(int x=hitx;x<N;x++)\n    {\n        if(board[hity][x]!='.')\n        {\n            right=board[hity][x];\n            rightx=x;\n            break;\n        }\n    }\n    if(right!='-')\n    {\n        if(right==left) board[hity][rightx]='.',board[hity][leftx]='.',right='-',left='-',ret+=2;\n        else if(right==up) board[hity][rightx]='.',board[upy][hitx]='.',right='-',up='-',ret+=2;\n        else if(right==down) board[hity][rightx]='.',board[downy][hitx]='.',right='-',down='-',ret+=2;\n    }\n    if(left!='-')\n    {\n        if(left==right) board[hity][leftx]='.',board[hity][rightx]='.',left='-',right='-',ret+=2;\n        else if(left==up) board[hity][leftx]='.',board[upy][hitx]='.',left='-',up='-',ret+=2;\n        else if(left==down) board[hity][leftx]='.',board[downy][hitx]='.',left='-',down='-',ret+=2;\n    }\n    if(up!='-')\n    {\n        if(up==right) board[upy][hitx]='.',board[hity][rightx]='.',up='-',right='-',ret+=2;\n        else if(up==left) board[upy][hitx]='.',board[hity][leftx]='.',up='-',left='-',ret+=2;\n        else if(up==down) board[upy][hitx]='.',board[downy][hitx]='.',up='-',down='-',ret+=2;\n    }\n    if(down!='-')\n    {\n        if(down==right) board[downy][hitx]='.',board[hity][rightx]='.',up='-',right='-',ret+=2;\n        else if(down==left) board[downy][hitx]='.',board[hity][leftx]='.',up='-',left='-',ret+=2;\n        else if(down==up) board[upy][hitx]='.',board[downy][hitx]='.',up='-',down='-',ret+=2;\n    }\n    return ret;\n}\n\nint check()\n{\n    int change=0;\n    for(int i=0;i<M;i++)\n    {\n        for(int j=0;j<N;j++)\n        {\n            if(board[i][j]=='.') \n            {\n                change+=hit(i,j);\n            }\n        }\n    }\n    return change;\n}   \n\nint main()\n{\n\twhile(cin >> M >> N && M)\n    {\n        int ans=0;\n        for(int i=0;i<M;i++)\n        {\n            cin >> board[i];\n        }\n        while(1)\n        {\n            int inc=check();\n            ans+=inc;\n            if(inc==0)break;\n        }\n        cout << ans << endl;\n    }\n\t\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint m,n;\nvector<P> data[30];\nvector<int> xindex;\nvector<int> yindex;\nint field[180][180];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint pickl[4];\nint picklx[4];\nint pickly[4];\n\nint main(void){\n\tscanf(\"%d %d\",&n,&m);\n\tfor(int i=0;i<n;i++){\n\t\tstring str;\n\t\tcin >> str;\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(str[j]>='A' && str[j]<='Z'){\n\t\t\t\tdata[str[j]-'A'+1].push_back(P(j,i));\n\t\t\t\tif(j-1>=0)xindex.push_back(j-1);\n\t\t\t\txindex.push_back(j);\n\t\t\t\tif(j+1<m)xindex.push_back(j+1);\n\t\t\t\tif(i-1>=0)yindex.push_back(i-1);\n\t\t\t\tyindex.push_back(i);\n\t\t\t\tif(i+1<n)yindex.push_back(i+1);\n\t\t\t}\n\t\t}\n\t}\n\tsort(xindex.begin(),xindex.end());\n\txindex.erase(unique(xindex.begin(),xindex.end()),xindex.end());\n\tsort(yindex.begin(),yindex.end());\n\tyindex.erase(unique(yindex.begin(),yindex.end()),yindex.end());\n\tfor(int i=1;i<=26;i++){\n\t\tfor(int j=0;j<data[i].size();j++){\n\t\t\tdata[i][j].first=lower_bound(xindex.begin(),xindex.end(),data[i][j].first)-xindex.begin();\n\t\t\tdata[i][j].second=lower_bound(yindex.begin(),yindex.end(),data[i][j].second)-yindex.begin();\n\t\t\tfield[data[i][j].first][data[i][j].second]=i;\n\t\t}\n\t}\n\tbool flag=true;\n\tint score=0;\n\twhile(flag){\n\t\tflag=false;\n\t\tfor(int i=0;i<yindex.size();i++){\n\t\t\tfor(int j=0;j<xindex.size();j++){\n\t\t\t\tif(field[j][i]==0){\n\t\t\t\t\tmemset(pickl,0,sizeof(pickl));\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tint xx=j,yy=i;\n\t\t\t\t\t\tint cnt=0;\n\t\t\t\t\t\twhile(xx>=0 && xx<xindex.size() && yy>=0 && yy<yindex.size()){\n\t\t\t\t\t\t\tif(field[xx][yy]!=0)break;\n\t\t\t\t\t\t\txx+=dx[k];\n\t\t\t\t\t\t\tyy+=dy[k];\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\tif(cnt>=1000)return 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(field[xx][yy]!=0){\n\t\t\t\t\t\t\tpickl[k]=field[xx][yy];\n\t\t\t\t\t\t\tpicklx[k]=xx;\n\t\t\t\t\t\t\tpickly[k]=yy;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tfor(int l=k+1;l<4;l++){\n\t\t\t\t\t\t\tif(pickl[k]==pickl[l] && pickl[k]!=0){\n\t\t\t\t\t\t\t\tscore+=2;\n\t\t\t\t\t\t\t\tfield[picklx[k]][pickly[k]]=0;\n\t\t\t\t\t\t\t\tfield[picklx[l]][pickly[l]]=0;\n\t\t\t\t\t\t\t\tflag=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",score);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int H, W; cin >> H >> W;\n  VS vs(H);\n  REP(i,H) cin >> vs[i];\n\n  vector<PII> memo(32, MP(-1,-1));\n  vector<pair<PII,PII>> pos;\n  REP(y,H) REP(x,W){\n\tif(vs[y][x] != '.'){\n\t  int i = vs[y][x] - 'A';\n\t  if(memo[i].first < 0)\n\t\tmemo[i] = MP(x,y);\n\t  else\n\t\tpos.PB(MP(memo[i], MP(x,y)));\n\t}\n  }\n\n  int ans = 0;\n  bool up  = true;\n  while(up){\n\tup = false;\n\n\tfor(int i=0;i<SZ(pos);++i){\n\t  PII p1 = pos[i].first, p2 = pos[i].second;\n\t  if(p1 > p2) swap(p1,p2);\n\t  if((p1.first+1 == p2.first && p1.second == p2.second)\n\t\t || (p1.first == p2.first && abs(p1.second-p2.second)==1)) continue;\n\t  \n\t  int ok = 0;\n\t  for(int j=0;j<SZ(pos);++j){\n\t\tif(i == j) continue;\n\t\tPII q1 = pos[j].first, q2 = pos[j].second;\n\t\tif((q1.second == p1.second && p1.first <= q1.first && q1.first <= p2.first)\n\t\t   || ((q2.second == p1.second) && p1.first <= q2.first && q2.first <= p2.first)){\n\t\t  ok |= 1;\n\t\t}\n\t\tif((q1.second == p2.second && p1.first <= q1.first && q1.first <= p2.first)\n\t\t   || ((q2.second == p2.second) && p1.first <= q2.first && q2.first <= p2.first)){\n\t\t  ok |= 2;\n\t\t}\n\n\t\tif(p1.first == p2.first){\n\t\t  if((q1.first == p1.first && p1.second <= q1.second && q1.second <= p2.second)\n\t\t\t || (q2.first == p1.first && p1.second <= q2.second && q2.second <= p2.second))\n\t\t\tok = 3;\n\t\t}\n\t  }\n\t  if(ok != 3){\n\t\tpos.erase(pos.begin() + i);\n\t\tans += 2;\n\t\tup = true;\n\t\tbreak;\n\t  }\n\t}\n  }\n\n  cout << ans << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cctype>\n#include <vector>\n#include <map>\n#include <cassert>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0 ; i < n ; i++)\n\ntypedef pair<int, int> P;\n\nstruct Point{\n  int x1, y1, x2, y2;\n};\n\nconst int MAX = 510;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nchar field[MAX][MAX];\nbool found[26];\nPoint alpha[26];\nint H, W;\n\nbool checkH(int x1, int x2, int y, char c){\n  if(x1 > x2) swap(x1, x2);\n  for(int j = x1 ; j <= x2 ; j++){\n    if(field[y][j] != '.' && field[y][j] != c) return false;\n  }\n  return true;\n}\n\nbool checkW(int y1, int y2, int x, char c){\n  if(y1 > y2) swap(y1, y2);\n  for(int i = y1 ; i <= y2 ; i++){\n    if(field[i][x] != '.' && field[i][x] != c) return false;\n  }\n  return true;\n}\n\nint main(){\n  while(cin >> H >> W){\n    rep(i, H) cin >> field[i];\n    \n    memset(alpha, 0, sizeof(alpha));\n    memset(found, 0, sizeof(found));\n    \n    rep(i, H){\n      rep(j, W){\n\tif(isalpha(field[i][j])){\n\t  int c = field[i][j]-'A';\n\t  if(found[c]){\n\t    alpha[c].x2 = j, alpha[c].y2 = i;\n\t  }\n\t  else{\n\t    found[c] = true;\n\t    alpha[c].x1 = j, alpha[c].y1 = i;\n\t  }\n\t}\t\n      }\n    }\n    \n    int cnt[26];\n    memset(cnt, 0, sizeof(cnt));\n    rep(i, H){\n      rep(j, W){\n\tcnt[field[i][j]-'A']++;\n      }\n    }\n    \n    rep(i, 26) assert(cnt[i] % 2 == 0);\n    \n    Point cross[26];\n    rep(i, 26){\n      if(found[i]){\n\t//cross[i].push_back(Point(alpha[i][0].x, alpha[i][1].y));\n\t//cross[i].push_back(Point(alpha[i][1].x, alpha[i][0].y));\n\tcross[i].x1 = alpha[i].x1, cross[i].y1 = alpha[i].y2;\n\tcross[i].x2 = alpha[i].x2, cross[i].y2 = alpha[i].y1;\n      }\n    }\n    \n    rep(i, H){\n      rep(j, W){\n\trep(k, 4){\n\t  int nx = j+dx[k], ny = i+dy[k];\n\t  if(nx < 0 || nx > W || ny < 0 || ny > H) continue;\n\t  if(field[i][j] == field[ny][nx]) found[field[i][j]-'A'] = false;\n\t}\n      }\n    }\n    \n    int ans = 0;\n    for(; ;){\n    Start:;\n      bool flag = false;\n      rep(i, 26){\n\tif(found[i]){\t  \t \n\t  int X1 = cross[i].x1, Y1 = cross[i].y1, X2 = cross[i].x2, Y2 = cross[i].y2;\n\t  int x1 = alpha[i].x1, y1 = alpha[i].y1, x2 = alpha[i].x2, y2 = alpha[i].y2;\n\t  char c = 'A'+i;\n\t  \n\t  if(x1 == x2){\n\t    flag = checkW(y1, y2, x1, c);\n\t  }\n\t  else if(y1 == y2){\n\t    flag = checkH(x1, x2, y1, c);\t    \n\t  }\n\t  else{\n\t    if(((checkH(X1, x2, Y1, c) && (checkW(Y1, y1, X1, c)))) ||\n\t       ((checkH(X2, x1, Y2, c) && (checkW(Y2, y2, X2, c))))){\n\t      flag = true;\n\t    }\n\t  }\n\t  \n\t  if(flag){\n\t    //cout << c << endl;\n\t    found[i] = false;\n\t    ans += 2;\n\t    field[y1][x1] = '.', field[y2][x2] = '.';\t    \n\t    goto Start;\n\t  }\n\t  \n\t}\n      }\n      if(!flag) break;\n    }\n    cout << ans << endl;\n  }  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define LINF (ll)INF*INF\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(int i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\n#define int ll //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vp;\n\nint gcd(int a, int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\nint lcm(int a, int b){\n    return a*b/gcd(a,b);\n}\n\n\nint ans = 0;\nvector<vp> v;\n\nvoid dfs(vi used, vs s, int cnt){\n    ans = max(ans, cnt);\n    rep(i,26)if(used[i] == 0 && v[i].size()){\n        int diff = abs(v[i][0].first - v[i][1].first) + abs(v[i][0].second - v[i][1].second);\n        if(diff <= 1)continue;\n        bool c = true;\n        if(v[i][0].first == v[i][1].first){\n            int x = v[i][0].first;\n            int mi = min(v[i][0].second,v[i][1].second);\n            int ma = max(v[i][0].second,v[i][1].second);\n            loop(y,mi+1,ma){\n                if(s[x][y] != '.')c = false;\n            }\n        }else if(v[i][0].second == v[i][1].second){\n            int y = v[i][0].second;\n            int mi = min(v[i][0].first,v[i][1].first);\n            int ma = max(v[i][0].first,v[i][1].first);\n            loop(x,mi+1,ma){\n                if(s[x][y] != '.')c = false;\n            }\n        }else{\n            bool f = false;\n            int xmi = min(v[i][0].first,v[i][1].first);\n            int xma = max(v[i][0].first,v[i][1].first);\n            int ymi = min(v[i][0].second,v[i][1].second);\n            int yma = max(v[i][0].second,v[i][1].second);\n            rep(z,2){\n                int p = v[i][z].first, q = v[i][!z].second;\n                if(s[p][q] != '.')continue;\n                bool cc = true;\n                loop(y,ymi+1,yma){\n                    if(s[p][y] != '.')cc = false;\n                }\n                loop(x,xmi+1,xma){\n                    if(s[x][q] != '.')cc = false;\n                }\n                if(cc){\n                    f = true;\n                }\n            }\n            if(f == false)c = false;\n        }\n        if(c){\n            used[i]++;\n            rep(j,2)s[v[i][j].first][v[i][j].second] = '.';\n            cnt++;\n        }\n    }\n    if(ans < cnt)dfs(used,s,cnt);\n}\n\nsigned main(void) {\n    int n,m;\n    cin >> n >> m;\n    vs s(n);\n    rep(i,n) cin >> s[i];\n    v = vector<vp> (26);\n    rep(i,n)rep(j,m)if(s[i][j] != '.'){\n        int a = s[i][j] - 'A';\n        v[a].push_back(pii(i,j));\n    }\n    dfs(vi(26,0),s,0);\n    cout << ans*2 << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\n \nconst int MAXH = 503;\nconst int MAXW = 503;\nint H, W;\nchar G[MAXH][MAXW];\nvector<pair<int,int> > pos[26];\nint btween[26][2];\n \nint main() {\n  while(cin >> H >> W && (H|W)) {\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n    cin >> G[i][j];\n      }\n    }\n \n    for(int i = 0; i < 26; ++i) pos[i].clear();\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n    if(isalpha(G[i][j])) {\n      int k = G[i][j]-'A';\n      pos[k].push_back(make_pair(j,i));\n      sort(pos[k].begin(), pos[k].end());\n    }\n      }\n    }\n \n    fill(btween[0], btween[26], 1<<26);\n    for(int k = 0; k < 26; ++k) {\n      if(pos[k].empty()) continue;\n      if(0) {\n      } else if(pos[k][0].first == pos[k][1].first) {\n    int begin = min(pos[k][0].second, pos[k][1].second);\n    int end = max(pos[k][0].second, pos[k][1].second);\n    if(end - begin == 1) continue;\n    btween[k][0] = 0;\n    int j = pos[k][0].first;\n    for(int i = begin+1; i < end; ++i) {\n      if(isalpha(G[i][j])) btween[k][0] |= ( 1<<(G[i][j]-'A') );\n    }\n      } else if(pos[k][0].second == pos[k][1].second) {\n    int begin = min(pos[k][0].first, pos[k][1].first);\n    int end = max(pos[k][0].first, pos[k][1].first);\n    if(end - begin == 1) continue;\n    btween[k][0] = 0;\n    int i = pos[k][0].second;\n    for(int j = begin+1; j < end; ++j) {\n      if(isalpha(G[i][j])) btween[k][0] |= ( 1<<(G[i][j]-'A') );\n    }\n      } else if(pos[k][0].second < pos[k][1].second) {\n    btween[k][0] = btween[k][1] = 0;\n    for(int i = pos[k][0].second+1, j = pos[k][0].first;\n        i < pos[k][1].second; ++i) {\n      if(isalpha(G[i][j])) btween[k][0] |= ( 1<<(G[i][j]-'A') );\n    }\n    for(int i = pos[k][1].second, j = pos[k][0].first;\n        j < pos[k][1].first; ++j) {\n      if(isalpha(G[i][j])) btween[k][0] |= ( 1<<(G[i][j]-'A') );\n    }\n \n    for(int i = pos[k][0].second, j = pos[k][0].first+1;\n        j < pos[k][1].first; ++j) {\n      if(isalpha(G[i][j])) btween[k][1] |= ( 1<<(G[i][j]-'A') );\n    }\n    for(int i = pos[k][0].second, j = pos[k][1].first;\n        i < pos[k][1].second; ++i) {\n      if(isalpha(G[i][j])) btween[k][1] |= ( 1<<(G[i][j]-'A') );\n    }\n      } else {\n    btween[k][0] = btween[k][1] = 0;\n    for(int i = pos[k][0].second-1, j = pos[k][0].first;\n        i > pos[k][1].second; --i) {\n      if(isalpha(G[i][j])) btween[k][0] |= ( 1<<(G[i][j]-'A') );\n    }\n    for(int i = pos[k][1].second, j = pos[k][0].first;\n        j < pos[k][1].first; ++j) {\n      if(isalpha(G[i][j])) btween[k][0] |= ( 1<<(G[i][j]-'A') );\n    }\n \n    for(int i = pos[k][0].second, j = pos[k][0].first+1;\n        j < pos[k][1].first; ++j) {\n      if(isalpha(G[i][j])) btween[k][1] |= ( 1<<(G[i][j]-'A') );\n    }\n    for(int i = pos[k][0].second, j = pos[k][1].first;\n        i > pos[k][1].second; --i) {\n      if(isalpha(G[i][j])) btween[k][1] |= ( 1<<(G[i][j]-'A') );\n    }\n      }\n    }\n \n    int bit = 0;\n    while(1) {\n      bool flag = false;\n      for(int i = 0; i < 26; ++i) {\n    if(bit & (1<<i)) continue;\n    if((btween[i][0] & ~bit) == 0 || (btween[i][1] & ~bit) == 0) {\n      bit |= (1<<i);\n      flag = true;\n      break;\n    }\n      }\n      if(!flag) break;\n    }\n    cout << __builtin_popcount(bit)*2 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n \nusing namespace std;\n \n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define LINF (ll)INF*INF\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(int i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n \n#define int ll //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n \ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vp;\n \nint gcd(int a, int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\nint lcm(int a, int b){\n    return a*b/gcd(a,b);\n}\n \nint n,m;\nint ans = 0;\nvector<vp> v;\n \nvoid dfs(vi used, vs s, int cnt){\n    ans = max(ans, cnt);\n    rep(i,26)if(used[i] == 0 && v[i].size()){\n        int diff = abs(v[i][0].first - v[i][1].first) + abs(v[i][0].second - v[i][1].second);\n        if(diff <= 1)continue;\n        bool c = true;\n        if(v[i][0].first == v[i][1].first){\n            int x = v[i][0].first;\n            int mi = min(v[i][0].second,v[i][1].second);\n            int ma = max(v[i][0].second,v[i][1].second);\n            vi alph(26);\n            loop(y,mi+1,ma){\n                if(s[x][y] != '.')c = false;\n            }\n        }else if(v[i][0].second == v[i][1].second){\n            int y = v[i][0].second;\n            int mi = min(v[i][0].first,v[i][1].first);\n            int ma = max(v[i][0].first,v[i][1].first);\n            vi alph(26);\n            loop(x,mi+1,ma){\n                if(s[x][y] != '.')c = false;\n            }\n        }else{\n            bool f = false;\n            int xmi = min(v[i][0].first,v[i][1].first);\n            int xma = max(v[i][0].first,v[i][1].first);\n            int ymi = min(v[i][0].second,v[i][1].second);\n            int yma = max(v[i][0].second,v[i][1].second);\n            rep(z,2){\n                int p = v[i][z].first, q = v[i][!z].second;\n                if(s[p][q] != '.')continue;\n                bool cc = true;\n                loop(y,ymi+1,yma){\n                    if(s[p][y] != '.')cc = false;\n                }\n                loop(x,xmi+1,xma){\n                    if(s[x][q] != '.')cc = false;\n                }\n                if(cc){\n                    f = true;\n                }\n            }\n            if(f == false)c = false;\n        }\n        if(c){\n            //cout << i << endl;\n            used[i]++;\n            rep(j,2)s[v[i][j].first][v[i][j].second] = '.';\n            cnt++;\n            dfs(used,s,cnt);\nreturn;\n            used[i]--;\n            rep(j,2)s[v[i][j].first][v[i][j].second] = 'A'+i;\n            cnt--;\n        }\n    }\n}\n \nsigned main(void) {\n    cin >> n >> m;\n    vs s(n);\n    rep(i,n) cin >> s[i];\n    v = vector<vp> (26);\n    rep(i,n)rep(j,m)if(s[i][j] != '.'){\n        int a = s[i][j] - 'A';\n        v[a].push_back(pii(i,j));\n    }\n    dfs(vi(26,0),s,0);\n    cout << ans*2 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n\n#define CK(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n#define F first\n#define S second\n#define ll long long;\n\nconst int INF = 1e9;\nconst long long  LLINF = 1e15;\n\nusing namespace std;\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\n\nint H, W;\nstring S[510];\n\nstruct posi{\n  int y;\n  int x;\n  posi(int _y, int _x){\n    y = _y;\n    x = _x;\n  }\n};\n\nvector<pair< char, pair<posi, posi> > > v;\nset<char> st;\n\nbool ck_row(int lx, int rx, int ly, int ry){\n  if(rx-lx == 1 && ly == ry) return false;\n  REP(j,lx+1,rx){\n    if(S[ly][j] != '.'){\n      return false;\n    }\n  }\n  return true;\n}\n\nbool ck_col(int ly, int ry, int lx, int rx){\n  if(ry-ly == 1 && lx == rx) return false;\n  REP(i,ly+1,ry){\n    if(S[i][lx] != '.'){\n      return false;\n    }\n  }\n  return true;\n}\n\nint main() {\n  cin>>H>>W;\n  REP(i,0,H){\n    cin>>S[i];\n  }\n\n  REP(k,0,26){\n    vector<posi> tv;\n    REP(i,0,H){\n      REP(j,0,W){\n        if(S[i][j] == 'A' + k){\n          tv.push_back(posi(i,j));\n        }\n      }\n    }\n    if(tv.size() == 2){\n      v.push_back(make_pair('A'+k, make_pair(tv[0],tv[1])));\n    }\n  }\n\n  int ans = 0;\n  while(1){\n    bool flag = true;\n    REP(k,0,v.size()){\n      if(st.find(v[k].F) != st.end()) continue;\n      /*?¨???????*/\n      if(v[k].S.F.y == v[k].S.S.y){\n        int fixy = v[k].S.F.y;\n        int lx = min(v[k].S.F.x, v[k].S.S.x);\n        int rx = max(v[k].S.F.x, v[k].S.S.x);\n        if(ck_row(lx,rx,fixy,fixy)){\n          S[fixy][lx] = S[fixy][rx] = '.';\n          ans += 2;\n          flag = false;\n          st.insert(v[k].F);\n        }\n      /*?????????*/\n      }else if(v[k].S.F.x == v[k].S.S.x){\n        int fixx = v[k].S.F.x;\n        int ly = min(v[k].S.F.y, v[k].S.S.y);\n        int ry = max(v[k].S.F.y, v[k].S.S.y);\n        if(ck_col(ly,ry,fixx,fixx)){\n          S[ly][fixx] = S[ry][fixx] = '.';\n          ans += 2;\n          flag = false;\n          st.insert(v[k].F);\n        }\n      /*??????*/\n      }else{\n        //v[k].S.F??????????????´??????\n        if(v[k].S.F.x < v[k].S.S.x){\n          //????????????????????????\n          if(S[v[k].S.S.y][v[k].S.F.x] == '.'){\n            if(ck_row(v[k].S.F.x,v[k].S.S.x,v[k].S.S.y,v[k].S.F.y)\n                && ck_col(v[k].S.F.y,v[k].S.S.y,v[k].S.F.x,v[k].S.S.x)){\n              S[v[k].S.F.y][v[k].S.F.x] = S[v[k].S.S.y][v[k].S.S.x] = '.';\n              ans += 2;\n              flag = false;\n              st.insert(v[k].F);\n              continue;\n            }\n          }\n          //????????????????????????\n          if(S[v[k].S.F.y][v[k].S.S.x] == '.'){\n            if(ck_row(v[k].S.F.x,v[k].S.S.x,v[k].S.F.y,v[k].S.S.y)\n                && ck_col(v[k].S.F.y,v[k].S.S.y,v[k].S.S.x,v[k].S.F.x)){\n              S[v[k].S.F.y][v[k].S.F.x] = S[v[k].S.S.y][v[k].S.S.x] = '.';\n              ans += 2;\n              flag = false;\n              st.insert(v[k].F);\n              continue;\n            }\n          }\n        }else{\n          //????????????????????????\n          if(S[v[k].S.F.y][v[k].S.S.x] == '.') {\n            if(ck_row(v[k].S.S.x,v[k].S.F.x,v[k].S.F.y,v[k].S.S.y)\n                && ck_col(v[k].S.F.y,v[k].S.S.y,v[k].S.S.x,v[k].S.F.x)){\n              S[v[k].S.F.y][v[k].S.F.x] = S[v[k].S.S.y][v[k].S.S.x] = '.';\n              ans += 2;\n              flag = false;\n              st.insert(v[k].F);\n              continue;\n            }\n          }\n          //????????????????????????\n          if(S[v[k].S.S.y][v[k].S.F.x] == '.'){\n            if(ck_row(v[k].S.S.x,v[k].S.F.x,v[k].S.S.y,v[k].S.F.y)\n                && ck_col(v[k].S.F.y,v[k].S.S.y,v[k].S.F.x,v[k].S.S.x)){\n              S[v[k].S.F.y][v[k].S.F.x] = S[v[k].S.S.y][v[k].S.S.x] = '.';\n              ans += 2;\n              flag = false;\n              st.insert(v[k].F);\n              continue;\n            }\n          }\n        }\n      }\n    }\n    if(flag) break;\n  }\n\n  cout<<ans<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 501;\n\nint main()\n{\n    int n,m;\n    scanf(\"%d%d\",&n,&m);\n    char c[MAX_N][MAX_N];\n    vector<P> al[26];\n    int res = 0;\n\trep(i,n){\n        char hoge;\n        scanf(\"%c\",&hoge);\n        rep(j,m){\n            scanf(\"%c\",&c[i][j]);\n            if((int)(c[i][j] - 'A') >= 0 && (int)(c[i][j] - 'A') <= 25){\n                al[(int)(c[i][j] - 'A')].push_back(P(i,j));\n            }\n        }\n\t}\n    while(1){\n        bool act = false;\n        rep(i,26){\n            rep(j,al[i].size()){\n                int i1 = al[i][0].first,j1 = al[i][0].second;\n                int i2 = al[i][1].first,j2 = al[i][1].second;\n                if(i1 == i2){\n                    bool flag = false;\n                    if(abs(j1-j2) == 1){\n                        continue;\n                    }\n                    for(int k=min(j1,j2)+1;k<max(j1,j2);k++){\n                        if(c[i1][k] != '.'){\n                            flag = true;\n                            break;\n                        }\n                    }\n                    if(!flag){\n                        c[i1][j1] = '.';\n                        c[i2][j2] = '.';\n                        res += 2;\n                        al[i].clear();\n                        act = true;\n                    }\n                }else if(j1 == j2){\n                    if(abs(i1-i2) == 1){\n                        continue;\n                    }\n                    bool flag = false;\n                    for(int k=min(i1,i2)+1;k<max(i1,i2);k++){\n                        if(c[k][j1] != '.'){\n                            flag = true;\n                            break;\n                        }\n                    }\n                    if(!flag){\n                        c[i1][j1] = '.';\n                        c[i2][j2] = '.';\n                        res += 2;\n                        al[i].clear();\n                        act = true;\n                    }\n                }else{\n                    if(c[i1][j2] == '.' || c[i2][j1] == '.'){\n                        c[i1][j1] = '.';\n                        c[i2][j2] = '.';\n                        res += 2;\n                        al[i].clear();\n                        act = true;\n                    }\n                }\n            }\n        }\n        if(!act){\n            break;\n        }\n    }\n    printf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nint H,W;\n\nstruct Info{\n\tInfo(){\n\t\trow = col = 0;\n\t\texist = false;\n\t}\n\tInfo(int arg_row,int arg_col,bool arg_exist){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\texist = arg_exist;\n\t}\n\n\tvoid set(int arg_row,int arg_col,bool arg_exist){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\texist = arg_exist;\n\t}\n\tint row,col;\n\tbool exist;\n};\n\nint main(){\n\n\tscanf(\"%d %d\",&H,&W);\n\tchar map[H][W+1];\n\n\tInfo info[26][2];\n\tfor(int i = 0; i < 26; i++){\n\t\tfor(int k = 0; k < 2; k++){\n\t\t\tinfo[i][k].exist = false;\n\t\t}\n\t}\n\n\tvector<Info> V_ROW[500],V_COL[500];\n\tint maximum = 0;\n\n\tfor(int i = 0; i < H; i++){\n\t\tscanf(\"%s\",map[i]);\n\t\tfor(int k = 0; k < W; k++){\n\t\t\tswitch(map[i][k]){\n\t\t\tcase '.':\n\t\t\t\tV_ROW[i].push_back(Info(i,k,false));\n\t\t\t\tV_COL[k].push_back(Info(i,k,false));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif(info[map[i][k]-'A'][0].exist == false){\n\t\t\t\t\tinfo[map[i][k]-'A'][0].exist = true;\n\t\t\t\t\tinfo[map[i][k]-'A'][0].set(i,k,true);\n\t\t\t\t\tmaximum++;\n\t\t\t\t}else{\n\t\t\t\t\tinfo[map[i][k]-'A'][1].set(i,k,true);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0,common_row,common_col,small,big;\n\tbool FLG,erasableFLG;\n\n\twhile(true){\n\n\t\tFLG = false;\n\n\t\tfor(int i = 0; i < 26; i++){\n\t\t\tif(info[i][0].exist){\n\t\t\t\tif(info[i][0].row == info[i][1].row){\n\n\t\t\t\t\tcommon_row = info[i][0].row;\n\t\t\t\t\tif(info[i][0].col > info[i][1].col){\n\t\t\t\t\t\tsmall = info[i][1].col;\n\t\t\t\t\t\tbig = info[i][0].col;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsmall = info[i][0].col;\n\t\t\t\t\t\tbig = info[i][1].col;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int a = 0;a < V_ROW[common_row].size();a++){\n\t\t\t\t\t\tif(V_ROW[common_row][a].col > small && V_ROW[common_row][a].col < big){\n\n\t\t\t\t\t\t\terasableFLG = false;\n\n\t\t\t\t\t\t\tfor(int tmp_col = V_ROW[common_row][a].col; tmp_col >= 0 ;tmp_col--){\n\t\t\t\t\t\t\t\tif(map[common_row][tmp_col] != '.'){\n\t\t\t\t\t\t\t\t\tif(map[common_row][tmp_col] == 'A' + i){\n\t\t\t\t\t\t\t\t\t\terasableFLG = true;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!erasableFLG)continue;\n\n\t\t\t\t\t\t\terasableFLG = false;\n\n\t\t\t\t\t\t\tfor(int tmp_col = V_ROW[common_row][a].col; tmp_col <= W-1 ;tmp_col++){\n\t\t\t\t\t\t\t\tif(map[common_row][tmp_col] != '.'){\n\t\t\t\t\t\t\t\t\tif(map[common_row][tmp_col] == 'A' + i){\n\t\t\t\t\t\t\t\t\t\terasableFLG = true;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!erasableFLG)continue;\n\n\t\t\t\t\t\t\tmap[common_row][info[i][0].col] = '.';\n\t\t\t\t\t\t\tmap[common_row][info[i][1].col] = '.';\n\t\t\t\t\t\t\tV_ROW[common_row].push_back(Info(common_row,info[i][0].col,false));\n\t\t\t\t\t\t\tV_ROW[common_row].push_back(Info(common_row,info[i][1].col,false));\n\t\t\t\t\t\t\tV_COL[info[i][0].col].push_back(Info(common_row,info[i][0].col,false));\n\t\t\t\t\t\t\tV_COL[info[i][1].col].push_back(Info(common_row,info[i][1].col,false));\n\t\t\t\t\t\t\tinfo[i][0].exist = false;\n\t\t\t\t\t\t\tans += 2;\n\t\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}else if(info[i][0].col == info[i][1].col){\n\n\t\t\t\t\tcommon_col = info[i][0].col;\n\t\t\t\t\tif(info[i][0].row > info[i][1].row){\n\t\t\t\t\t\tsmall = info[i][1].row;\n\t\t\t\t\t\tbig = info[i][0].row;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsmall = info[i][0].row;\n\t\t\t\t\t\tbig = info[i][1].row;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int a = 0;a < V_COL[common_col].size();a++){\n\n\t\t\t\t\t\tif(V_COL[common_col][a].row > small && V_COL[common_col][a].row < big){\n\n\t\t\t\t\t\t\terasableFLG = false;\n\n\t\t\t\t\t\t\tfor(int tmp_row = V_COL[common_col][a].row; tmp_row >= 0 ;tmp_row--){\n\t\t\t\t\t\t\t\tif(map[tmp_row][common_col] != '.'){\n\t\t\t\t\t\t\t\t\tif(map[tmp_row][common_col] == 'A' + i){\n\t\t\t\t\t\t\t\t\t\terasableFLG = true;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!erasableFLG)continue;\n\n\t\t\t\t\t\t\terasableFLG = false;\n\n\t\t\t\t\t\t\tfor(int tmp_row = V_COL[common_col][a].row; tmp_row <= H-1 ;tmp_row++){\n\t\t\t\t\t\t\t\tif(map[tmp_row][common_col] != '.'){\n\t\t\t\t\t\t\t\t\tif(map[tmp_row][common_col] == 'A' + i){\n\t\t\t\t\t\t\t\t\t\terasableFLG = true;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!erasableFLG)continue;\n\n\t\t\t\t\t\t\tmap[info[i][0].row][common_col] = '.';\n\t\t\t\t\t\t\tmap[info[i][1].row][common_col] = '.';\n\t\t\t\t\t\t\tV_ROW[info[i][0].row].push_back(Info(info[i][0].row,common_col,false));\n\t\t\t\t\t\t\tV_ROW[info[i][1].row].push_back(Info(info[i][1].row,common_col,false));\n\t\t\t\t\t\t\tV_COL[common_col].push_back(Info(info[i][0].row,common_col,false));\n\t\t\t\t\t\t\tV_COL[common_col].push_back(Info(info[i][1].row,common_col,false));\n\t\t\t\t\t\t\tinfo[i][0].exist = false;\n\t\t\t\t\t\t\tans += 2;\n\t\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}else{\n\n\t\t\t\t\tif(map[info[i][0].row][info[i][1].col] == '.'){\n\n\t\t\t\t\t\terasableFLG = false;\n\n\t\t\t\t\t\tif(info[i][0].col > info[i][1].col){\n\n\t\t\t\t\t\t\tfor(int tmp_col = info[i][1].col+1; tmp_col <= W-1; tmp_col++){\n\t\t\t\t\t\t\t\tif(map[info[i][0].row][tmp_col] != '.'){\n\t\t\t\t\t\t\t\t\tif(map[info[i][0].row][tmp_col] == 'A' + i){\n\t\t\t\t\t\t\t\t\t\terasableFLG = true;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}else{\n\n\t\t\t\t\t\t\tfor(int tmp_col = info[i][1].col-1; tmp_col >= 0; tmp_col--){\n\t\t\t\t\t\t\t\tif(map[info[i][0].row][tmp_col] != '.'){\n\t\t\t\t\t\t\t\t\tif(map[info[i][0].row][tmp_col] == 'A' + i){\n\t\t\t\t\t\t\t\t\t\terasableFLG = true;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(erasableFLG){\n\t\t\t\t\t\t\terasableFLG = false;\n\n\t\t\t\t\t\t\tif(info[i][0].row > info[i][1].row){\n\n\t\t\t\t\t\t\t\tfor(int tmp_row = info[i][0].row-1; tmp_row >= 0; tmp_row--){\n\t\t\t\t\t\t\t\t\tif(map[tmp_row][info[i][1].col] != '.'){\n\t\t\t\t\t\t\t\t\t\tif(map[tmp_row][info[i][1].col] == 'A' + i){\n\t\t\t\t\t\t\t\t\t\t\terasableFLG = true;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}else{\n\n\t\t\t\t\t\t\t\tfor(int tmp_row = info[i][0].row+1; tmp_row <= H-1; tmp_row++){\n\t\t\t\t\t\t\t\t\tif(map[tmp_row][info[i][1].col] != '.'){\n\t\t\t\t\t\t\t\t\t\tif(map[tmp_row][info[i][1].col] == 'A' + i){\n\t\t\t\t\t\t\t\t\t\t\terasableFLG = true;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif(erasableFLG){\n\n\t\t\t\t\t\t\t\tmap[info[i][0].row][info[i][0].col] = '.';\n\t\t\t\t\t\t\t\tmap[info[i][1].row][info[i][1].col] = '.';\n\t\t\t\t\t\t\t\tV_ROW[info[i][0].row].push_back(Info(info[i][0].row,info[i][0].col,false));\n\t\t\t\t\t\t\t\tV_ROW[info[i][1].row].push_back(Info(info[i][1].row,info[i][1].col,false));\n\t\t\t\t\t\t\t\tV_COL[info[i][0].col].push_back(Info(info[i][0].row,info[i][0].col,false));\n\t\t\t\t\t\t\t\tV_COL[info[i][1].col].push_back(Info(info[i][1].row,info[i][1].col,false));\n\t\t\t\t\t\t\t\tinfo[i][0].exist = false;\n\t\t\t\t\t\t\t\tans += 2;\n\t\t\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(map[info[i][1].row][info[i][0].col] == '.'){\n\t\t\t\t\t\terasableFLG = false;\n\n\t\t\t\t\t\tif(info[i][1].col > info[i][0].col){\n\n\t\t\t\t\t\t\tfor(int tmp_col = info[i][0].col+1; tmp_col <= W-1; tmp_col++){\n\t\t\t\t\t\t\t\tif(map[info[i][1].row][tmp_col] != '.'){\n\t\t\t\t\t\t\t\t\tif(map[info[i][1].row][tmp_col] == 'A' + i){\n\t\t\t\t\t\t\t\t\t\terasableFLG = true;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!erasableFLG)continue;\n\n\t\t\t\t\t\t}else{\n\n\t\t\t\t\t\t\tfor(int tmp_col = info[i][0].col-1; tmp_col >= 0; tmp_col--){\n\t\t\t\t\t\t\t\tif(map[info[i][1].row][tmp_col] != '.'){\n\t\t\t\t\t\t\t\t\tif(map[info[i][1].row][tmp_col] == 'A' + i){\n\t\t\t\t\t\t\t\t\t\terasableFLG = true;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!erasableFLG)continue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\terasableFLG = false;\n\n\t\t\t\t\t\tif(info[i][1].row > info[i][0].row){\n\n\t\t\t\t\t\t\tfor(int tmp_row = info[i][1].row-1; tmp_row >= 0; tmp_row--){\n\t\t\t\t\t\t\t\tif(map[tmp_row][info[i][0].col] != '.'){\n\t\t\t\t\t\t\t\t\tif(map[tmp_row][info[i][0].col] == 'A' + i){\n\t\t\t\t\t\t\t\t\t\terasableFLG = true;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!erasableFLG)continue;\n\n\t\t\t\t\t\t}else{\n\n\t\t\t\t\t\t\tfor(int tmp_row = info[i][1].row+1; tmp_row <= H-1; tmp_row++){\n\t\t\t\t\t\t\t\tif(map[tmp_row][info[i][0].col] != '.'){\n\t\t\t\t\t\t\t\t\tif(map[tmp_row][info[i][0].col] == 'A' + i){\n\t\t\t\t\t\t\t\t\t\terasableFLG = true;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!erasableFLG)continue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmap[info[i][0].row][info[i][0].col] = '.';\n\t\t\t\t\t\tmap[info[i][1].row][info[i][1].col] = '.';\n\t\t\t\t\t\tV_ROW[info[i][0].row].push_back(Info(info[i][0].row,info[i][0].col,false));\n\t\t\t\t\t\tV_ROW[info[i][1].row].push_back(Info(info[i][1].row,info[i][1].col,false));\n\t\t\t\t\t\tV_COL[info[i][0].col].push_back(Info(info[i][0].row,info[i][0].col,false));\n\t\t\t\t\t\tV_COL[info[i][1].col].push_back(Info(info[i][1].row,info[i][1].col,false));\n\t\t\t\t\t\tinfo[i][0].exist = false;\n\t\t\t\t\t\tans += 2;\n\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(!FLG){\n\t\t\tbreak;\n\t\t}\n\t\tif(ans >= 2*maximum){\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\npii pos[26][2];\nint num[26];\nstring in[510];\n\nint main(void){\n\tint m,n;\n\tcin >> m >> n;\n\trep(i,m) cin >> in[i];\n\trep(i,m)rep(j,n){\n\t\tif(in[i][j]=='.')\n\t\t\tcontinue;\n\t\tint cur=in[i][j]-'A';\n\t\tpos[cur][num[cur]].first=i;\n\t\tpos[cur][num[cur]++].second=j;\n\t}\n\tint ans=0;\n\trep(loop,26)rep(i,26) if(num[i]==2){\n\t\tbool ok=false;\n\t\tif(pos[i][0].first==pos[i][1].first){\n\t\t\tfor(int j=pos[i][0].second+1;j<pos[i][1].second;++j)\n\t\t\t\tif(in[pos[i][0].first][j]=='.')\n\t\t\t\t\tok=true;\n\t\t}else if(pos[i][0].second==pos[i][1].second){\n\t\t\tfor(int j=pos[i][0].first+1;j<pos[i][1].first;++j)\n\t\t\t\tif(in[j][pos[i][0].second]=='.')\n\t\t\t\t\tok=true;\n\t\t}else{\n\t\t\tif(in[pos[i][1].first][pos[i][0].second]=='.'||in[pos[i][0].first][pos[i][1].second]=='.') ok=true;\n\t\t}\n\t\tif(ok){\n\t\t\tin[pos[i][0].first][pos[i][0].second]='.';\n\t\t\tin[pos[i][1].first][pos[i][1].second]='.';\n\t\t\tans+=2,num[i]=0;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\nll h,w;\n\n\nint main(){\n    cin>>h>>w;\n    ll W=w;\n    vector<string> A(h);\n    ll ans=0;\n    for(auto &I:A){cin>>I;}\n    vector<set<pair<ll,char>>> YOKO(h),TATE(w);\n    vector<vector<bool>> cnt(h,vector<bool>(w,false));\n    queue<pll> Q;\n    for(int i=0;i<h;i++){\n        for(int t=0;t<w;t++){\n            if(A[i][t]!='.'){YOKO[i].insert({t,A[i][t]}); TATE[t].insert({i,A[i][t]});}\n            else{cnt[i][t]=true; Q.push({i,t});}\n        }\n    }\n    while(!Q.empty()){\n        pll w=Q.front(); Q.pop();\n        /*\n        cout<<w.F<<\" \"<<w.S<<endl;\n        for(int i=0;i<h;i++){\n            for(int t=0;t<W;t++){\n                cout<<A[i][t];\n            }\n            cout<<endl;\n        }\n        */\n        cnt[w.F][w.S]=false;\n        pair<pll,char> c[4]={{{-1,-1},0},{{-1,-1},0},{{-1,-1},0},{{-1,-1},0}};\n        if(!YOKO[w.F].empty()){\n            auto I=YOKO[w.F].lower_bound({w.S,0});\n            if(I!=YOKO[w.F].end()){c[0]={{w.F,I->F},I->S};}\n            if(I!=YOKO[w.F].begin()){--I; c[1]={{w.F,I->F},I->S};}\n        }\n        if(!TATE[w.S].empty()){\n            auto I=TATE[w.S].lower_bound({w.F,0});\n            if(I!=TATE[w.S].end()){c[2]={{I->F,w.S},I->S};}\n            if(I!=TATE[w.S].begin()){--I; c[3]={{I->F,w.S},I->S};}\n        }\n        vector<pll> erase={w};\n        for(int i=1;i<4;i++){\n            for(int t=0;t<i;t++){\n                if(c[i].S!=0 && c[i].S==c[t].S){\n                    erase.push_back(c[i].F);\n                    erase.push_back(c[t].F);\n                    /*\n                    cout<<c[i].F.F<<\" \"<<c[i].F.S<<\" \"<<c[i].S<<endl;\n                    cout<<c[t].F.F<<\" \"<<c[t].F.S<<\" \"<<c[t].S<<endl;\n                    cout<<endl;\n                     */\n                    c[i].S=0;\n                    c[t].S=0;\n                    ans+=2;\n                }\n            }\n        }\n        if(erase.size()==1){continue;}\n        for(auto &I:erase){\n            YOKO[I.F].erase({I.S,A[I.F][I.S]});\n            TATE[I.S].erase({I.F,A[I.F][I.S]});\n            A[I.F][I.S]='.';\n            for(int t=0;t<W;t++){\n                if(A[I.F][t]=='.' && !cnt[I.F][t]){cnt[I.F][t]=true; Q.push({I.F,t});}\n            }\n            for(int t=0;t<h;t++){\n                if(A[t][I.S]=='.' && !cnt[t][I.S]){cnt[t][I.S]=true; Q.push({t,I.S});}\n            }\n        }\n    }\n    cout<<ans<<endl;\n    \n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint M,N;\nchar C[512][512], c[512][512];\nint dy[]={-1,0,1,0},dx[]={0,-1,0,1};\n\nint del(int y, int x){\n  vector<P>v;\n  rep(d,4){\n    int ny=y+dy[d], nx=x+dx[d];\n    while(ny>=0&&ny<M&&nx>=0&&nx<N&&c[ny][nx]=='.') ny += dy[d], nx += dx[d];\n    if(ny<0||ny>=M||nx<0||nx>=N) continue;\n    v.push_back(P(ny, nx));\n  }\n  int ret = 0;\n  rep(i, v.size()) for(int j=i+1;j<v.size();j++){\n    if(c[v[i].first][v[i].second] != '.' && c[v[i].first][v[i].second] == c[v[j].first][v[j].second]){\n      ret++;\n      c[v[i].first][v[i].second] = c[v[j].first][v[j].second] =  '.';\n    }\n  }\n  return ret;\n}\n\nint main(){\n  scanf(\"%d%d\", &M,&N);\n  rep(i,M) scanf(\"%s\", C[i]);\n  rep(i,M) rep(j,N) c[i][j] = C[i][j];\n  int f = 1;\n  while(f){\n    f = 0;\n    rep(i,M) rep(j,N) if(c[i][j]=='.') f += del(i, j);\n  }\n  int res = 0;\n  rep(i,M) rep(j,N) if(c[i][j]!=C[i][j]) res++;\n  //  rep(i,M) puts(c[i]);\n  printf(\"%d\\n\", res);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N, M;\n\nint main() {\n    cin >> N >> M;\n    vector<string> v(N);\n    for (int i = 0; i < N; i++) cin >> v[i];\n\n    vector<bool> h(N, false), w(M, false);\n    for (int i = 0; i < N; i++)\n        for (int j = 0; j < M; j++)\n            if (v[i][j] != '.') h[i] = true, w[j] = true;\n\n    for (int i = 0; i < N; i++) {\n        if (i > 0 && !h[i] && h[i-1]) {\n            h[i] = true;\n            i++;\n        }\n    }\n    for (int i = 0; i < M; i++) {\n        if (i > 0 && !w[i] && w[i-1]) {\n            w[i] = true;\n            i++;\n        }\n    }\n\n\n    vector<string> V;\n    for (int i = 0, count = 0; i < N; i++) {\n        if (!h[i]) continue;\n        V.push_back(\"\");\n        for (int j = 0; j < M; j++) {\n            if (w[j]) V[V.size() - 1] += v[i][j];\n        }\n    }\n\n    int ans = 0;\n    while (1) {\n        int pre = ans;\n\n        for (int i = 0, H = V.size(); i < H; i++) {\n            for (int j = 0, W = V[i].size(); j < W; j++) {\n                if (V[i][j] != '.') continue;\n                int up = i, down = i, left = j, right = j;\n                while (up >= 0 && V[up][j] == '.') up--;\n                while (down < H && V[down][j] == '.') down++;\n                while (left >= 0 && V[i][left] == '.') left--;\n                while (right < W && V[i][right] == '.') right++;\n\n                string tmp;\n                if (up >= 0) tmp += V[up][j];\n                if (down < H) tmp += V[down][j];\n                if (left >= 0) tmp += V[i][left];\n                if (right < W) tmp += V[i][right];\n\n                string same;\n                for (int k = 0; k < tmp.size(); k++) {\n                    for (int l = k + 1; l < tmp.size(); l++) {\n                        if (tmp[k] == tmp[l]) same += tmp[k];\n                    }\n                }\n\n                if (up >= 0 && same.find(V[up][j]) != string::npos) V[up][j] = '.';\n                if (left >= 0 && same.find(V[i][left]) != string::npos) V[i][left] = '.';\n                if (down < H && same.find(V[down][j]) != string::npos) V[down][j] = '.';\n                if (right < W && same.find(V[i][right]) != string::npos) V[i][right] = '.';\n\n                ans += same.size() * 2;\n            }\n        }\n\n        if (ans == pre) break;\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-9;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nconst int M=26;\nint h,w;\nint x[M][2],y[M][2];\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcin>>h>>w;\n\tfor(int i=0;i<M;i++) for(int j=0;j<2;j++) x[i][j]=y[i][j]=-1;\n\tfor(int i=0;i<h;i++) for(int j=0;j<w;j++){\n\t\tchar c;\n\t\tcin>>c;\n\t\tif(isalpha(c)){\n\t\t\tint id=c-'A';\n\t\t\tif(x[id][0]==-1) x[id][0]=i,y[id][0]=j;\n\t\t\telse x[id][1]=i,y[id][1]=j;\n\t\t}\n\t}\n\tfor(int i=0;i<M;i++) if(x[i][0]>=0){\n\t\tif(x[i][0]>x[i][1]||x[i][0]==x[i][1]&&y[i][0]>y[i][1]){\n\t\t\tswap(x[i][0],x[i][1]);\n\t\t\tswap(y[i][0],y[i][1]);\n\t\t}\n\t}\n\tint res=0;\n\twhile(1){\n\t\tbool B=0;\n\t\tfor(int i=0;i<M;i++) if(x[i][0]>=0){\n\t\t\tif(abs(x[i][0]-x[i][1])+abs(y[i][0]-y[i][1])==1) continue;\n\t\t\tbool b1=1,b2=1;\n\t\t\tfor(int j=0;j<M;j++) for(int k=0;k<2;k++) if(i!=j&&x[j][k]>=0){\n\t\t\t\tif(x[i][0]==x[i][1]){\n\t\t\t\t\tif(x[j][k]==x[i][0]&&y[i][0]<y[j][k]&&y[j][k]<y[i][1]) b1=0,b2=0;\n\t\t\t\t}\n\t\t\t\telse if(y[i][0]==y[i][1]){\n\t\t\t\t\tif(y[j][k]==y[i][0]&&x[i][0]<x[j][k]&&x[j][k]<x[i][1]) b1=0,b2=0;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(x[j][k]==x[i][0]&&(y[i][0]<y[j][k]^y[j][k]>y[i][1])) b1=0;\n\t\t\t\t\tif(y[j][k]==y[i][1]&&x[i][0]<=x[j][k]&&x[j][k]<x[i][1]) b1=0;\n\t\t\t\t\tif(x[j][k]==x[i][1]&&(y[i][0]<y[j][k]^y[j][k]>y[i][1])) b2=0;\n\t\t\t\t\tif(y[j][k]==y[i][0]&&x[i][0]<x[j][k]&&x[j][k]<=x[i][1]) b2=0;\n//\t\t\t\t\tcout<<b1<<' '<<b2<<endl;\n\t\t\t\t}\n\t\t\t}\n//\t\t\tcout<<i<<' '<<b1<<' '<<b2<<endl;\n\t\t\tif(b1||b2){\n//\t\t\t\tcout<<x[i][0]<<' '<<y[i][0]<<' '<<x[i][1]<<' '<<y[i][1]<<endl;\n\t\t\t\tx[i][0]=-1,y[i][0]=-1;\n\t\t\t\tx[i][1]=-1,y[i][1]=-1;\n\t\t\t\tB=1;\n\t\t\t\tres+=2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!B) break;\n\t}\n\tcout<<res<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\nusing namespace std;\nint main(){\n  int n, m;\n  cin >> m >> n;\n  vector<string> C(m);\n  vector< vector<int> > A(26);\n  for(int i = 0; i < m; ++i){\n    cin >> C[i];\n    for(int j = 0; j < n; ++j){\n      if(C[i][j] != '.') A[C[i][j]-'A'].push_back(i*n+j);\n    }\n  }\n  int ans = 0;\n  for(int i = 0; i < 26; ++i){\n    for(int j = 0; j < 26; ++j){\n      if(A[j].empty()) continue;\n      int a = A[j][0]/n, b = A[j][0]%n, c = A[j][1]/n, d = A[j][1]%n;\n      bool f = true;\n      for(int k = min(b,d)+1; k < max(b,d); ++k){\n        if(C[a][k] != '.'){\n          f = false;\n          break;\n        }\n      }\n      for(int k = min(a,c)+1; k < max(a,c); ++k){\n        if(C[k][d] != '.'){\n          f = false;\n          break;\n        }\n      }\n      if((a != c && b != d && C[a][d] != '.') || (a == c && abs(b-d) <= 1) || (b == d && abs(a-c) <= 1)) f = false;\n      if(f){\n        //cout << (char)('A'+j) << endl;\n        C[a][b] = '.';\n        C[c][d] = '.';\n        ans += 2;\n        A[j] = vector<int>(0);\n        continue;\n      }\n      f = true;\n      for(int k = min(b,d)+1; k < max(b,d); ++k){\n        if(C[c][k] != '.'){\n          f = false;\n          break;\n        }\n      }\n      for(int k = min(a,c)+1; k < max(a,c); ++k){\n        if(C[k][b] != '.'){\n          f = false;\n          break;\n        }\n      }\n      if((a != c && b != d && C[c][b] != '.') || (a == c && abs(b-d) <= 1) || (b == d && abs(a-c) <= 1)) f = false;\n      if(f){\n        //cout << (char)('A'+j) << endl;\n        C[a][b] = '.';\n        C[c][d] = '.';\n        ans += 2;\n        A[j] = vector<int>(0);\n        continue;\n      }\n    }\n  }\n  cout << ans << endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <sstream>\n#include <utility>\n#include <set>\n#include <map>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define each(e,c) for(auto&e:c)\n#define iter(i,c) for(auto i(begin(c));i!=end(c);++i)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\ntemplate<class C>string to_string(vector<C> c,string d=\" \"){stringstream s;iter(i,c)s<<*i<<(next(i)==end(c)?\"\":d);return s.str();}\ntemplate<class C>ostream&operator<<(ostream&os,vector<C>const& v){return os<<to_string(v);}\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<(DUMP(),__VA_ARGS__).str()<<\" (at \"<<__LINE__<<\")\"<<endl)\nstruct DUMP:ostringstream{template<class T>DUMP &operator,(const T&t){if(this->tellp())*this<<\", \";*this<<t;return *this;}};\n#else\n#define dump(...)\n#endif\n\ntypedef vector<string> vs;\nint h,w;\nvs g;\ninline bool valid(int x, int y){\n    return 0<=x && 0<=y && x<w && y<h;\n}\n\nint solve(){\n    vector<pii> space;\n    rep(i,h)rep(j,w)if(g[i][j]=='.') space.emplace_back(j,i);\n    int ans = 0;\n    while(1){\n        bool finish = true;\n        for(auto p : space){\n            vector<pii> s['Z'+1];\n            int x,y;\n            tie(x,y)=p;\n            int dx[]={1,0,-1,0};\n            int dy[]={0,1,0,-1};\n            rep(d,4){\n                int cx,cy;\n                tie(cx,cy)=tie(x,y);\n                while(valid(cx+dx[d],cy+dy[d]) && g[cy][cx]=='.'){\n                    cx+=dx[d]; cy+=dy[d];\n                }\n                if(valid(cx,cy) && g[cy][cx]!='.'){\n                    s[g[cy][cx]].emplace_back(cx,cy);\n                }\n            }\n            for(auto & ps : s){\n                if(ps.size()>=2){\n                    for(auto & p : ps){\n                        int x,y;\n                        tie(x,y) = p;\n                        g[y][x] = '.';\n                        ans++;\n                        finish = false;\n                        space.emplace_back(x,y);\n                    }\n                }\n            }\n        }\n        if(finish) break;\n    }\n    return ans;\n}\n\nint main(){\n    while(cin>>h>>w){\n        g.clear();\n        rep(i,h){\n            string s;cin>>s;\n            g.push_back(s);\n        }\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\nchar f[502][502];\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,-1,0,1};\nint n,m;\nbool erase(vector<pair<int,int> > pos){\n    bool reachable[2][502][502];\n    memset(reachable, false, sizeof(reachable));\n    int x,y;\n    \n    for(int i=0;i<2;i++){\n        for(int j=0;j<4;j++){\n            y = pos[i].first;\n            x = pos[i].second;\n            do{\n                y += dy[j];\n                x += dx[j];\n                if(f[y][x] == '.'){\n                    reachable[i][y][x] = true;\n                }else{\n                    break;\n                }\n            }while(f[y][x] == '.');\n        }\n    }\n    for(int i=1;i<=m;i++){\n        for(int j=1;j<=n;j++){\n            if(reachable[0][i][j] && reachable[1][i][j]){\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint main(){\n\n    cin >> m >> n;\n    vector<pair<int,int> > place[26];\n\n    memset(f, -1, sizeof(f));\n    for(int i=1;i<=m;i++){\n        for(int j=1;j<=n;j++){\n            cin >> f[i][j];\n            if(f[i][j] == '.') continue;\n            place[f[i][j] - 'A'].push_back(make_pair(i,j));\n        }\n    }\n\n    int ret=0;\n    bool isended = false;\n    while(!isended){\n        isended = true;\n        for(int i=0;i<26;i++){\n            if((int)place[i].size() != 0){\n                cout << i << endl;\n                if(erase(place[i])){\n                    ret += 2;\n                    isended = false;\n                    f[place[i][0].first][place[i][0].second] = '.';\n                    f[place[i][1].first][place[i][1].second] = '.';\n                    place[i].clear();\n                }\n            }\n        }\n    }\n    cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint m,n;\nvector<P> data[30];\nvector<int> xind;\nvector<int> yind;\nint field[190][190];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint pickl[4];\nint picklx[4];\nint pickly[4];\n\nint main(void){\n\tscanf(\"%d %d\",&n,&m);\n\tmemset(field,0,sizeof(field));\n\tfor(int i=0;i<n;i++){\n\t\tstring str;\n\t\tcin >> str;\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(str[j]>='A' && str[j]<='Z'){\n\t\t\t\tdata[str[j]-'A'+1].push_back(P(j,i));\n\t\t\t\tif(j-1>=0)xind.push_back(j-1);\n\t\t\t\txind.push_back(j);\n\t\t\t\tif(j+1<m)xind.push_back(j+1);\n\t\t\t\tif(i-1>=0)yind.push_back(i-1);\n\t\t\t\tyind.push_back(i);\n\t\t\t\tif(i+1<n)yind.push_back(i+1);\n\t\t\t}\n\t\t}\n\t}\n\tsort(xind.begin(),xind.end());\n\txind.erase(unique(xind.begin(),xind.end()),xind.end());\n\tsort(yind.begin(),yind.end());\n\tyind.erase(unique(yind.begin(),yind.end()),yind.end());\n\tfor(int i=1;i<=26;i++){\n\t\tfor(int j=0;j<data[i].size();j++){\n\t\t\tdata[i][j].first=lower_bound(xind.begin(),xind.end(),data[i][j].first)-xind.begin();\n\t\t\tdata[i][j].second=lower_bound(yind.begin(),yind.end(),data[i][j].second)-yind.begin();\n\t\t\tfield[data[i][j].first][data[i][j].second]=i;\n\t\t}\n\t}\n\tbool flag=true;\n\tint score2=0;\n\twhile(flag){\n\t\tflag=false;\n\t\tfor(int i=0;i<yind.size();i++){\n\t\t\tfor(int j=0;j<xind.size();j++){\n\t\t\t\tif(field[j][i]==0){\n\t\t\t\t\tmemset(pickl,0,sizeof(pickl));\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tint xx=j,yy=i;\n\t\t\t\t\t\tint xi=xind.size(),yi=yind.size();\n\t\t\t\t\t\twhile(xx>=0 && xx<xi && yy>=0 && yy<yi){\n\t\t\t\t\t\t\tif(field[xx][yy]!=0)break;\n\t\t\t\t\t\t\txx+=dx[k];\n\t\t\t\t\t\t\tyy+=dy[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(field[xx][yy]!=0){\n\t\t\t\t\t\t\tpickl[k]=field[xx][yy];\n\t\t\t\t\t\t\tpicklx[k]=xx;\n\t\t\t\t\t\t\tpickly[k]=yy;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tfor(int l=k+1;l<4;l++){\n\t\t\t\t\t\t\tif(pickl[k]==pickl[l] && pickl[k]!=0){\n\t\t\t\t\t\t\t\tscore2+=2;\n\t\t\t\t\t\t\t\tfield[picklx[k]][pickly[k]]=0;\n\t\t\t\t\t\t\t\tfield[picklx[l]][pickly[l]]=0;\n\t\t\t\t\t\t\t\tflag=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",score2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint m,n;\nvector<P> data[30];\nvector<int> xindex;\nvector<int> yindex;\nint field[250][250];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint pickl[4];\nint picklx[4];\nint pickly[4];\n\nint main(void){\n\tscanf(\"%d %d\",&n,&m);\n\tfor(int i=0;i<n;i++){\n\t\tstring str;\n\t\tcin >> str;\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(str[j]>='A' && str[j]<='Z'){\n\t\t\t\tdata[str[j]-'A'+1].push_back(P(j,i));\n\t\t\t\tif(j-1>=0)xindex.push_back(j-1);\n\t\t\t\txindex.push_back(j);\n\t\t\t\tif(j+1<m)xindex.push_back(j+1);\n\t\t\t\tif(i-1>=0)yindex.push_back(i-1);\n\t\t\t\tyindex.push_back(i);\n\t\t\t\tif(i+1<n)yindex.push_back(i+1);\n\t\t\t}\n\t\t}\n\t}\n\tsort(xindex.begin(),xindex.end());\n\txindex.erase(unique(xindex.begin(),xindex.end()),xindex.end());\n\tsort(yindex.begin(),yindex.end());\n\tyindex.erase(unique(yindex.begin(),yindex.end()),yindex.end());\n\tfor(int i=1;i<=26;i++){\n\t\tfor(int j=0;j<data[i].size();j++){\n\t\t\tdata[i][j].first=lower_bound(xindex.begin(),xindex.end(),data[i][j].first)-xindex.begin();\n\t\t\tdata[i][j].second=lower_bound(yindex.begin(),yindex.end(),data[i][j].second)-yindex.begin();\n\t\t\tfield[data[i][j].first][data[i][j].second]=i;\n\t\t}\n\t}\n\tbool flag=true;\n\tint score=0;\n\twhile(flag){\n\t\tflag=false;\n\t\tfor(int i=0;i<yindex.size();i++){\n\t\t\tfor(int j=0;j<xindex.size();j++){\n\t\t\t\tif(field[j][i]==0){\n\t\t\t\t\tmemset(pickl,0,sizeof(pickl));\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tint xx=j,yy=i;\n\t\t\t\t\t\tint xi=xindex.size(),yi=yindex.size();\n\t\t\t\t\t\twhile(xx>=0 && xx<xi && yy>=0 && yy<yi){\n\t\t\t\t\t\t\tif(field[xx][yy]!=0)break;\n\t\t\t\t\t\t\txx+=dx[k];\n\t\t\t\t\t\t\tyy+=dy[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(field[xx][yy]!=0){\n\t\t\t\t\t\t\tpickl[k]=field[xx][yy];\n\t\t\t\t\t\t\tpicklx[k]=xx;\n\t\t\t\t\t\t\tpickly[k]=yy;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tfor(int l=k+1;l<4;l++){\n\t\t\t\t\t\t\tif(pickl[k]==pickl[l] && pickl[k]!=0){\n\t\t\t\t\t\t\t\tscore+=2;\n\t\t\t\t\t\t\t\tfield[picklx[k]][pickly[k]]=0;\n\t\t\t\t\t\t\t\tfield[picklx[l]][pickly[l]]=0;\n\t\t\t\t\t\t\t\tflag=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",score);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint m,n;\nvector<P> dat[100];\nvector<int> xind;\nvector<int> yind;\nint field[190][190];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint pickl[4];\nint picklx[4];\nint pickly[4];\n\nint main(void){\n\tscanf(\"%d %d\",&n,&m);\n\tmemset(field,0,sizeof(field));\n\tfor(int i=0;i<n;i++){\n\t\tstring str;\n\t\tcin >> str;\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(str[j]>='A' && str[j]<='Z'){\n\t\t\t\tdat[str[j]-'A'+1].push_back(P(j,i));\n\t\t\t\tif(j-1>=0)xind.push_back(j-1);\n\t\t\t\txind.push_back(j);\n\t\t\t\tif(j+1<m)xind.push_back(j+1);\n\t\t\t\tif(i-1>=0)yind.push_back(i-1);\n\t\t\t\tyind.push_back(i);\n\t\t\t\tif(i+1<n)yind.push_back(i+1);\n\t\t\t}\n\t\t}\n\t}\n\tsort(xind.begin(),xind.end());\n\txind.erase(unique(xind.begin(),xind.end()),xind.end());\n\tsort(yind.begin(),yind.end());\n\tyind.erase(unique(yind.begin(),yind.end()),yind.end());\n\tfor(int i=1;i<=26;i++){\n\t\tfor(int j=0;j<dat[i].size();j++){\n\t\t\tdat[i][j].first=lower_bound(xind.begin(),xind.end(),dat[i][j].first)-xind.begin();\n\t\t\tdat[i][j].second=lower_bound(yind.begin(),yind.end(),dat[i][j].second)-yind.begin();\n\t\t\tfield[dat[i][j].first][dat[i][j].second]=i;\n\t\t}\n\t}\n\tbool flag=true;\n\tint score2=0;\n\twhile(flag){\n\t\tflag=false;\n\t\tfor(int i=0;i<yind.size();i++){\n\t\t\tfor(int j=0;j<xind.size();j++){\n\t\t\t\tif(field[j][i]==0){\n\t\t\t\t\tmemset(pickl,0,sizeof(pickl));\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tint xx=j,yy=i;\n\t\t\t\t\t\tint xi=xind.size(),yi=yind.size();\n\t\t\t\t\t\twhile(xx>=0 && xx<xi && yy>=0 && yy<yi){\n\t\t\t\t\t\t\tif(field[xx][yy]!=0)break;\n\t\t\t\t\t\t\txx+=dx[k];\n\t\t\t\t\t\t\tyy+=dy[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(field[xx][yy]!=0){\n\t\t\t\t\t\t\tpickl[k]=field[xx][yy];\n\t\t\t\t\t\t\tpicklx[k]=xx;\n\t\t\t\t\t\t\tpickly[k]=yy;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tfor(int l=k+1;l<4;l++){\n\t\t\t\t\t\t\tif(pickl[k]==pickl[l] && pickl[k]!=0){\n\t\t\t\t\t\t\t\tscore2+=2;\n\t\t\t\t\t\t\t\tfield[picklx[k]][pickly[k]]=0;\n\t\t\t\t\t\t\t\tfield[picklx[l]][pickly[l]]=0;\n\t\t\t\t\t\t\t\tflag=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",score2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nint main(){\n \n      string s;\n      int n,m;\n      cin >> n >> m;\n      cerr << n << m << endl;\n      for(int i=0;i<n;i++){\n\tcin >> s;\n\tcerr << s << endl;\n      }\n      cout << \"3\" << endl;\n    \n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>=0 ? a/b : (a+1)/b-1;\n}\ntemplate<class T> T div_ceil(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>0 ? (a-1)/b+1 : a/b;\n}\n\nconstexpr lint mod = 1000000007;\nconstexpr lint INF = mod * mod;\nconstexpr int MAX = 100010;\n\nint h, w;\nchar c[510][510];\n\nint main(){\n    scanf(\"%d%d\", &h, &w);\n    rep(i, h)rep(j, w) scanf(\" %c\", &c[i][j]);\n    set<pii> S;\n    int ans = 0;\n    while(true){\n        bool flag = false;\n        rep(x, h)rep(y, w)if(c[x][y] == '.' && S.find({x, y}) == S.end()){\n            vector<pii> v;\n            for(int i=x-1; i>=0; --i)if(c[i][y] != '.'){\n                v.emplace_back(i, y);\n                break;\n            }\n            for(int i=x+1; i<h; ++i)if(c[i][y] != '.'){\n                v.emplace_back(i, y);\n                break;\n            }\n            for(int j=y-1; j>=0; --j)if(c[x][j] != '.'){\n                v.emplace_back(x, j);\n                break;\n            }\n            for(int j=y+1; j<w; ++j)if(c[x][j] != '.'){\n                v.emplace_back(x, j);\n                break;\n            }\n            if(v.size() <= 1){\n                S.emplace(x, y);\n                continue;\n            }\n            int cnt = 0;\n            rep(i, v.size()){\n                auto p = v[i];\n                For(j, i+1, v.size()){\n                    auto q = v[j];\n                    if(c[p.fi][p.se] == c[q.fi][q.se] && c[p.fi][p.se] != '.'){\n                        cnt += 2;\n                        c[p.fi][p.se] = c[q.fi][q.se] = '.';\n                        flag = true;\n                    }\n                }\n            }\n            ans += cnt;\n        }\n        if(!flag) break;\n    }\n    printf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-6)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i, n) rep (i, n)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define min3(a,b,c) min((a),min((b),(c)))\n#define min4(a,b,c,d) min((a),min3((b),(c),(d)))\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) memset((a),0,sizeof(a))\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\ntemplate<typename T,typename U> ostream& operator<< (ostream& out, const pair<T,U>& val){return out << \"(\" << val.F << \", \" << val.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& out, const vector<T>& val){out << \"{\";rep(i,SZ(val)) out << (i?\", \":\"\") << val[i];return out << \"}\";}\ntypedef double FP;\ntypedef complex<FP> pt;\ntypedef pt P;\ntypedef pair<pt,pt> line;\nFP dot(P a,P b){return real(conj(a)*b);}\nFP crs(P a,P b){return imag(conj(a)*b);}\nP ortho(P a){return conj(P(imag(a),real(a)));}\nP ortho(line a){return ortho(a.S-a.F);}\nP crspt(P a,P b,P c,P d){b-=a,d-=c;return a+b*crs(d,c-a)/crs(d,b);}\nP crspt(line a,line b){return crspt(a.F,a.S,b.F,b.S);}\nbool onl(P a1,P a2,P b){return abs(b-a1)+abs(b-a2)<abs(a1-a2)+EPS;}\nbool onl(line a,P b){return onl(a.F,a.S,b);}\nbool iscrs(line a,line b){P c=crspt(a,b);return onl(a,c)&&onl(b,c);}\nvoid pkuassert(bool t){t=1/t;};\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nenum{TOP,BTM,LFT,RGT,FRT,BCK};\nint dxdy2ce[]={RGT,FRT,LFT,BCK};\ntemplate<class T> T shift(T a,int b,int c,int d,int e){\n  __typeof(a[0])t=a[b];\n  a[b]=a[c];a[c]=a[d];a[d]=a[e];a[e]=t;return a;}\ntemplate<class T> T rgt(T a){return shift(a,TOP,LFT,BTM,RGT);}\ntemplate<class T> T lft(T a){return shift(a,TOP,RGT,BTM,LFT);}\ntemplate<class T> T frt(T a){return shift(a,TOP,BCK,BTM,FRT);}\ntemplate<class T> T bck(T a){return shift(a,TOP,FRT,BTM,BCK);}\nline mkl(P a,P v){return line(a,a+v);}\nFP lpdist(line a,P b){return abs(b-crspt(a,mkl(b,ortho(a))));}\nFP spdist(line a,P b){\n  P c(crspt(a,mkl(b,ortho(a))));\n  return onl(a,c)?abs(b-c):min(abs(a.F-b),abs(a.S-b));\n}\nFP ssdist(line a,line b){\n  return\n    min4(spdist(a,b.F),spdist(a,b.S),\n         spdist(b,a.F),spdist(b,a.S));\n}\n\n\n\nstring in[500];\nint m,n;\nbool inr(int nx,int ny,int xx,int xy,int x,int y){\n  if(nx>xx) swap(nx,xx);\n  if(ny>xy) swap(ny,xy);\n  return nx<=x && x<=xx && ny<=y && y<=xy;\n}\n\nint main(int argc, char *argv[])\n{\n  cin >> m >> n;\n  rep(i,m)\n    cin >> in[i];\n\n  vector<pair<PI,char> > app,ne;\n  rep(i,m)rep(j,n) if(in[i][j]!='.') \n    app.pb(mp(mp(i,j),in[i][j]));\n  int ans = 0;\n  while(true){\n    bool end=true;\n    ne.clear();\n    rep(i,SZ(app))rep(j,i){\n      bool ok=true;\n      if(app[i].S!=app[j].S) continue;\n\n      int minx=min(app[i].F.F,app[j].F.F);\n      int maxx=max(app[i].F.F,app[j].F.F);\n      int miny=min(app[i].F.S,app[j].F.S);\n      int maxy=max(app[i].F.S,app[j].F.S);\n      \n      if(app[i].F.F==app[j].F.F){\n        if(abs(app[i].F.S-app[j].F.S)==1) ok=false;\n        rep(k,SZ(app))\n          if(app[k].F.F==app[i].F.F &&\n             miny<app[k].F.S && app[k].F.S<maxy) ok=false;\n      }else if(app[i].F.S==app[j].F.S){\n        if(abs(app[i].F.F-app[j].F.F)==1) ok=false;\n        rep(k,SZ(app))\n          if(app[k].F.S==app[i].F.S &&\n             minx<app[k].F.F && app[k].F.F<maxx) ok=false;\n      }else{\n        PI p[]={\n          mp(minx,miny),mp(minx,maxy),\n          mp(maxx,miny),mp(maxx,maxy),\n        };\n        ok=false;\n        rep(k,4){\n          bool tok=false;\n          if(p[k]==app[i].F || p[k]==app[j].F) continue;\n          rep(l,SZ(app)){\n            if(app[l]==app[i] || app[l]==app[j]) continue;\n            tok|=inr(app[i].F.F,app[i].F.S,p[k].F,p[k].S,app[l].F.F,app[l].F.S);\n            tok|=inr(app[j].F.F,app[j].F.S,p[k].F,p[k].S,app[l].F.F,app[l].F.S);\n          }\n          if(tok) continue;\n          ok=true;\n          break;\n        }\n      }\n      \n      if(!ok){\n        ne.pb(app[i]);\n        ne.pb(app[j]);\n      }else{\n        end=false;\n        ++ans;\n      }\n    }\n    if(end) break;\n    app=ne;\n  }\n  \n\n  cout << ans*2 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 501;\n\nint main()\n{\n    int n,m;\n    scanf(\"%d%d\",&n,&m);\n    char c[MAX_N][MAX_N];\n    vector<P> al[26];\n    int res = 0;\n\trep(i,n){\n        char hoge;\n        scanf(\"%c\",&hoge);\n        rep(j,m){\n            scanf(\"%c\",&c[i][j]);\n            if((int)(c[i][j] - 'A') >= 0 && (int)(c[i][j] - 'A') <= 25){\n                al[(int)(c[i][j] - 'A')].push_back(P(i,j));\n            }\n        }\n\t}\n    while(1){\n        bool act = false;\n        rep(i,26){\n            if(al[i].size() > 0){\n                int i1 = al[i][0].first,j1 = al[i][0].second;\n                int i2 = al[i][1].first,j2 = al[i][1].second;\n                if(i1 == i2){\n                    bool flag = false;\n                    if(abs(j1-j2) == 1){\n                        continue;\n                    }\n                    for(int k=min(j1,j2)+1;k<max(j1,j2);k++){\n                        if(c[i1][k] != '.'){\n                            flag = true;\n                            break;\n                        }\n                    }\n                    if(!flag){\n                        c[i1][j1] = '.';\n                        c[i2][j2] = '.';\n                        res += 2;\n                        al[i].clear();\n                        act = true;\n                    }\n                }else if(j1 == j2){\n                    if(abs(i1-i2) == 1){\n                        continue;\n                    }\n                    bool flag = false;\n                    for(int k=min(i1,i2)+1;k<max(i1,i2);k++){\n                        if(c[k][j1] != '.'){\n                            flag = true;\n                            break;\n                        }\n                    }\n                    if(!flag){\n                        c[i1][j1] = '.';\n                        c[i2][j2] = '.';\n                        res += 2;\n                        al[i].clear();\n                        act = true;\n                    }\n                }else{\n                    int mi = min(i1,i2),ni = max(i1,i2);\n                    int mj = min(j1,j2),nj = max(j1,j2);\n                    if((i1-i2)*(j1-j2) > 0){\n                        bool flag = false;\n                        for(int k = mi;k<=ni;k++){\n                            if(c[k][mj] != '.' && c[k][mj] != (char)('A' + i)){\n                                flag = true;\n                                break;\n                            }\n                        }\n                        if(!flag){\n                            for(int k = mj;k<=nj;k++){\n                                if(c[ni][k] != '.' && c[ni][k] != (char)('A' + i)){\n                                    flag = true;\n                                    break;\n                                }\n                            }\n                        }\n                        if(!flag){\n                            c[i1][j1] = '.';\n                            c[i2][j2] = '.';\n                            res += 2;\n                            al[i].clear();\n                            act = true;\n                            continue;\n                        }\n                        flag = false;\n                        for(int k = mi;k<=ni;k++){\n                            if(c[k][nj] != '.' && c[k][nj] != (char)('A' + i)){\n                                flag = true;\n                                break;\n                            }\n                        }\n                        if(!flag){\n                            for(int k = mj;k<=nj;k++){\n                                if(c[mi][k] != '.' && c[mi][k] != (char)('A' + i)){\n                                    flag = true;\n                                    break;\n                                }\n                            }\n                        }\n                        if(!flag){\n                            c[i1][j1] = '.';\n                            c[i2][j2] = '.';\n                            res += 2;\n                            al[i].clear();\n                            act = true;\n                        }\n                    }else{\n                        bool flag = false;\n                        for(int k = mi;k<=ni;k++){\n                            if(c[k][mj] != '.' && c[k][mj] != (char)('A' + i)){\n                                flag = true;\n                                break;\n                            }\n                        }\n                        if(!flag){\n                            for(int k = mj;k<=nj;k++){\n                                if(c[mi][k] != '.' && c[mi][k] != (char)('A' + i)){\n                                    flag = true;\n                                    break;\n                                }\n                            }\n                        }\n                        if(!flag){\n                            c[i1][j1] = '.';\n                            c[i2][j2] = '.';\n                            res += 2;\n                            al[i].clear();\n                            act = true;\n                            continue;\n                        }\n                        flag = false;\n                        for(int k = mi;k<=ni;k++){\n                            if(c[k][nj] != '.' && c[k][nj] != (char)('A' + i)){\n                                flag = true;\n                                break;\n                            }\n                        }\n                        if(!flag){\n                            for(int k = mj;k<=nj;k++){\n                                if(c[ni][k] != '.' && c[ni][k] != (char)('A' + i)){\n                                    flag = true;\n                                    break;\n                                }\n                            }\n                        }\n                        if(!flag){\n                            c[i1][j1] = '.';\n                            c[i2][j2] = '.';\n                            res += 2;\n                            al[i].clear();\n                            act = true;\n                        }\n                    }\n                }\n            }\n        }\n        if(!act){\n            break;\n        }\n    }\n    printf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\nusing namespace std;\n\nint M, N, K;\nchar S[550][550];\nvector<int> y, x;\nvector<char> c;\nint dd[5] = { 0, 1, 0, -1, 0 };\n\nbool isin(int y, int x) {\n  return 0 <= y && y < M && 0 <= x && x < N;\n}\n\nint main(void) {\n  cin >> M >> N;\n  K = 0;\n  REP(i, 0, M) REP(j, 0, N) cin >> S[i][j];\n\n  int ans = 0;\n  bool visited[256];\n  REP(i, 0, 256) visited[i] = false;\n  bool f = true;\n  while(f) {\n    f = false;\n    REP(i, 0, M) REP(j, 0, N) {\n      if(S[i][j] == '.' || visited[S[i][j]]) {\n        int cnt[256];\n        REP(k, 0, 256) cnt[k] = 0;\n        REP(k, 0, 4) {\n          int ny = i + dd[k], nx = j + dd[k + 1];\n          while(isin(ny, nx)) {\n            if(S[ny][nx] != '.' && !visited[S[ny][nx]]) {\n              cnt[S[ny][nx]]++;\n              if(cnt[S[ny][nx]] == 2) {\n                visited[S[ny][nx]] = true;\n                ans += 2;\n                f = true;\n              }\n              break;\n            }\n            ny += dd[k];\n            nx += dd[k + 1];\n          }\n        }\n      }\n    }\n  }\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<stdlib.h>\n#include<map>\nusing namespace std;\ntypedef pair<int,int> P;\n#define Y first\n#define X second\nint main(){\n  int m,n;\n  cin >> m >> n;\n  string st[600];\n  int i,j,k;\n  for(i=0;i<m;i++) cin >> st[i];\n  bool alp[26]={};\n  vector<P> v[26];\n  P p;\n  for(i=0;i<m;i++){\n    for(j=0;j<n;j++){\n      if(st[i][j]!='.') {\n\talp[st[i][j]-'A']=true;\n\tp.Y=i;p.X=j;\n\tv[st[i][j]-'A'].push_back(p);\n      }\n    }\n  }\n  //cout << \"x\" << endl;\n  bool f=true,e;\n  int ans=0;\n  while(f){\n    f=false;\n    for(k=0;k<26;k++){\n      if(!alp[k]) continue;\n      if(v[k][0].X==v[k][1].X){\n\tif(abs(v[k][0].Y-v[k][1].Y)<2) continue;\n\te=true;\n\tfor(i=min(v[k][0].Y,v[k][1].Y)+1;i<max(v[k][0].Y,v[k][1].Y);i++){\n\t  if(st[i][v[k][0].X]!='.') e=false;\n\t}\n\tif(e){\n\t  st[v[k][0].Y][v[k][0].X]='.';\n\t  st[v[k][1].Y][v[k][1].X]='.';\n\t  alp[k]=false;\n\t  ans++;f=true;\n\t  break;\n\t}\n      }else if(v[k][0].Y==v[k][1].Y){\n\tif(abs(v[k][0].X-v[k][1].X)<2) continue;\n\te=true;\n\tfor(i=min(v[k][0].X,v[k][1].X)+1;i<max(v[k][0].X,v[k][1].X);i++){\n\t  if(st[v[k][0].Y][i]!='.') e=false;\n\t}\n\tif(e){\n\t  st[v[k][0].Y][v[k][0].X]='.';\n\t  st[v[k][1].Y][v[k][1].X]='.';\n\t  alp[k]=false;\n\t  ans++;f=true;\n\t  break;\n\t}\n      }else if((v[k][0].X-v[k][1].X)*(v[k][0].Y-v[k][1].Y)>0){\n\tif(v[k][0].X>v[k][1].X) swap(v[k][0],v[k][1]);\n\te=true;\n\tfor(i=v[k][0].X+1;i<v[k][1].X;i++){\n\t  if(st[v[k][0].Y][i]!='.') e=false;\n\t}\n\tfor(i=v[k][0].Y+1;i<v[k][1].Y;i++){\n\t  if(st[i][v[k][1].X]!='.') e=false;\n\t}\n\tif(e){\n\t  st[v[k][0].Y][v[k][0].X]='.';\n\t  st[v[k][1].Y][v[k][1].X]='.';\n\t  alp[k]=false;\n\t  ans++;f=true;\n\t  break;\n\t}\n\te=true;\n\tfor(i=v[k][0].Y+1;i<v[k][1].Y;i++){\n\t  if(st[i][v[k][0].X]!='.') e=false;\n\t}\n\tfor(i=v[k][0].X+1;i<v[k][1].X;i++){\n\t  if(st[v[k][1].Y][i]!='.') e=false;\n\t}\n\tif(e){\n\t  st[v[k][0].Y][v[k][0].X]='.';\n\t  st[v[k][1].Y][v[k][1].X]='.';\n\t  alp[k]=false;\n\t  ans++;f=true;\n\t  break;\n\t}\n      }else{\n\tif(v[k][0].X>v[k][1].X) swap(v[k][0],v[k][1]);\n\te=true;\n\tfor(i=v[k][0].X+1;i<v[k][1].X;i++){\n\t  if(st[v[k][0].Y][i]!='.') e=false;\n\t}\n\tfor(i=v[k][0].Y-1;i>v[k][1].Y;i--){\n\t  if(st[i][v[k][1].X]!='.') e=false;\n\t}\n\tif(e){\n\t  st[v[k][0].Y][v[k][0].X]='.';\n\t  st[v[k][1].Y][v[k][1].X]='.';\n\t  alp[k]=false;\n\t  ans++;f=true;\n\t  break;\n\t}\n\te=true;\n\tfor(i=v[k][0].Y-1;i>v[k][1].Y;i--){\n\t  if(st[i][v[k][0].X]!='.') e=false;\n\t}\n\tfor(i=v[k][0].X+1;i<v[k][1].X;i++){\n\t  if(st[v[k][1].Y][i]!='.') e=false;\n\t}\n\tif(e){\n\t  st[v[k][0].Y][v[k][0].X]='.';\n\t  st[v[k][1].Y][v[k][1].X]='.';\n\t  alp[k]=false;\n\t  ans++;f=true;\n\t  break;\n\t}\n      }\n    }\n    //for(i=0;i<m;i++) cout << st[i] << endl; cout << endl;\n  }\n  //for(i=0;i<m;i++) cout << st[i] << endl;\n  cout << ans*2 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <string.h>\n\n\nvoid gstr(char *str){\n\tint i;\n\tfor(i = 0;(str[i] = getchar()) != '\\n';i++);\n\tstr[i] = '\\0';\n}\n\nint main(void){\n\tint i, j, k, l, m, n, h, w, dx[4] = {0,1,0,-1}, dy[4] = {-1,0,1,0}, ans = 0, f[20][20];\n\tchar s[500][501], *c[4];\n\tscanf(\"%d%d%*c\",&h,&w);\n\tfor(i = 0;i < h;i++) gstr(s[i]);\n\tmemset(f,0,sizeof(f));\n\tfor(i = 0;i < h;i++){\n\t\tfor(j = 0;j < w;j++){\n\t\t\tif(isupper(s[i][j])){\n\t\t\t\tfor(k = 0;k < 4;k++){\n\t\t\t\t\tfor(l = 1;i + dy[k] * l >=  0 && i + dy[k] * l < h && j + dx[k] * l >= 0 && j + dx[k] * l < w && !isupper(s[i + dy[k] * l][j + dx[k] * l]);l++)\n\t\t\t\t\t\tf[i + dy[k] * l][j + dx[k] * l]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(i = 0;i < h;i++){\n\t\tfor(j = 0;j < w;j++){\n\t\t\tif(!isupper(s[i][j]) && f[i][j] >= 2){\n\t\t\t\tfor(k = 0;k < 4;k++){\n\t\t\t\t\tfor(l = 0;i + dy[k] * l >=  0 && i + dy[k] * l < h && j + dx[k] * l >= 0 && j + dx[k] * l < w && !isupper(s[i + dy[k] * l][j + dx[k] * l]);l++);\n\t\t\t\t\tif(i + dy[k] * l >= 0 && i + dy[k] * l < h && j + dx[k] * l >= 0 && j + dx[k] * l < w) c[k] = &s[i + dy[k] * l][j + dx[k] * l];\n\t\t\t\t\telse c[k] = NULL;\n\t\t\t\t}\n\t\t\t\tfor(k = 0;k < 3;k++){\n\t\t\t\t\tfor(l = k + 1;l < 4;l++)\n\t\t\t\t\t\tif(c[k] != NULL && c[l] != NULL && k != l && *c[k] == *c[l] && *c[k] != '.') *c[k] = '.',*c[l] = '.',i = -1, ans += 2;\n\t\t\t\t}\n\t\t\t\tif(i == -1){\n\t\t\t\t\tmemset(f,0,sizeof(f));\n\t\t\t\t\tfor(k = 0;k < h;k++){\n\t\t\t\t\t\tfor(l = 0;l < w;l++){\n\t\t\t\t\t\t\tif(isupper(s[k][l])){\n\t\t\t\t\t\t\t\tfor(m = 0;m < 4;m++){\n\t\t\t\t\t\t\t\t\tfor(n = 1;k + dy[m] * n >= 0 && k + dy[m] * n < h && l + dx[m] * n >= 0 && l + dx[m] * n < w && !isdigit(s[k + dy[m] * n][l + dx[m] * n]);n++){\n\t\t\t\t\t\t\t\t\t\tf[k + dy[m] * n][l + dx[m] * n]++;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i == -1) break;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mk make_pair\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nstring s[500];\nint h,w,sum=0;\nvector<int>x,y;\nvoid del(int t1,int t2){\n  vector<pair<char,pair<int,int> > >p;\n  for(int i=t1;i<h;i++)if(s[i][t2]!='.'){\n    p.push_back(mk(s[i][t2],mk(i,t2)));\n    break;\n  }\n  for(int i=t1;i>=0;i--)if(s[i][t2]!='.'){\n    p.push_back(mk(s[i][t2],mk(i,t2)));\n    break;\n  }\n  for(int i=t2;i<w;i++)if(s[t1][i]!='.'){\n    p.push_back(mk(s[t1][i],mk(t1,i)));\n    break;\n  }\n  for(int i=t2;i>=0;i--)if(s[t1][i]!='.'){\n    p.push_back(mk(s[t1][i],mk(t1,i)));\n    break;\n  }\n  sort(p.begin(),p.end());\n  if(p.size()>=2){\n    r(i,p.size()-1){\n      if(p[i].first==p[i+1].first){\n        sum++;\n        s[p[i].second.first][p[i].second.second]='.';\n        s[p[i+1].second.first][p[i+1].second.second]='.';\n      }\n    }\n  }\n}\nint main(){\n  cin>>h>>w;\n  r(i,h)cin>>s[i];\n  r(i,h)r(j,w)if(s[i][j]!='.'){\n      y.push_back(i),x.push_back(j);\n      if(i+1<h)y.push_back(i+1);\n      if(j+1<w)x.push_back(j+1);\n    }\n  r(k,4)r(i,y.size())r(j,x.size())\n    if(s[y[i]][x[j]]=='.')del(y[i],x[j]);\n  cout<<sum*2<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <ctime>\nusing namespace std;\n#define loop(i,a,b) for(int i=(a); i<int(b); i++)\n#define rep(i,b) loop(i,0,b)\n\nint main(){\n    clock_t begin = clock();\n    int c = 0;\n    while(clock() - begin < CLOCKS_PER_SEC*2){\n        c++;\n    }\n    cout << c << endl;\n    loop(i,1,10)loop(j,1,10){\n        printf(\"%dx%d=%d\\n\",i,j,i*j);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n#define X first\n#define Y second\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nint N, M;\n\nstring m[501];\nvector<pii> place[26];\nvector<int> stock[26];\nmain(){\n\tcin >> M >> N;\n\tREP(i, M){\n\t\tcin >> m[i];\n\t\tREP(j, N){\n\t\t\tif(m[i][j] != '.') place[m[i][j]-'A'].emplace_back(j, i);\n\t\t}\n\t}\n\tREP(i, 26){\n\t\tif(place[i].empty()) continue;\n\t\tpii a = place[i][0];\n\t\tpii b = place[i][1];\n\t\tif(a > b) swap(a, b);\n\t\tif(a.X == b.X){\n\t\t\tif(a.Y+1 == b.Y) continue;\n\t\t\tint st = 0;\n\t\t\tfor(int y=a.Y+1;y<b.Y;y++) if(m[y][a.X] != '.') st |= 1 << (m[y][a.X]-'A');\n\t\t\tstock[i].push_back(st);\n\t\t}else if(a.Y == b.Y){\n\t\t\tif(a.X+1 == b.X) continue;\n\t\t\tint st = 0;\n\t\t\tfor(int x=a.X+1;x<b.X;x++) if(m[a.Y][x] != '.') st |= 1 << (m[a.Y][x]-'A');\n\t\t\tstock[i].push_back(st);\n\t\t}else{\n\t\t\tint st = 0;\n\t\t\tfor(int x=a.X;x<=b.X;x++) if(m[a.Y][x] != '.' && m[a.Y][x] != 'A'+i) st |= 1 << (m[a.Y][x]-'A');\n\t\t\tfor(int y=min(a.Y, b.Y);y<=max(a.Y, b.Y);y++) if(m[y][b.X] != '.' && m[y][b.X] != 'A'+i) st |= 1 << (m[y][b.X]-'A');\n\t\t\tstock[i].push_back(st);\n\t\t\t\n\t\t\tst = 0;\n\t\t\tfor(int x=a.X;x<=b.X;x++) if(m[b.Y][x] != '.' && m[b.Y][x] != 'A'+i) st |= 1 << (m[b.Y][x]-'A');\n\t\t\tfor(int y=min(a.Y, b.Y);y<=max(a.Y, b.Y);y++) if(m[y][a.X] != '.' && m[y][a.X] != 'A'+i) st |= 1 << (m[y][a.X]-'A');\n\t\t\tstock[i].push_back(st);\n\t\t}\n\t}\n\tint rest = (1<<26) -1;\n\tint ans = 0;\n\tREP(k, 26)REP(i, 26){\n\t\tREP(j, stock[i].size()){\n\t\t\tif((rest & stock[i][j]) == 0){\n\t\t\t\tans += 2;\n\t\t\t\trest ^= 1<<i;\n\t\t\t\tstock[i].clear();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\nusing namespace std;\n\nint M, N, K;\nchar S[550][550];\nint dd[5] = { 0, 1, 0, -1, 0 };\n\nbool isin(int y, int x) {\n  return 0 <= y && y < M && 0 <= x && x < N;\n}\n\nint main(void) {\n  cin >> M >> N;\n  K = 0;\n  REP(i, 0, M) REP(j, 0, N) cin >> S[i][j];\n\n  int ans = 0;\n  bool visited[256];\n  REP(i, 0, 256) visited[i] = false;\n  bool f = true;\n  while(f) {\n    f = false;\n    REP(i, 0, M) REP(j, 0, N) {\n      if(S[i][j] == '.' || visited[S[i][j]]) {\n        int cnt[256];\n        REP(k, 0, 256) cnt[k] = 0;\n        REP(k, 0, 4) {\n          int ny = i + dd[k], nx = j + dd[k + 1];\n          while(isin(ny, nx)) {\n            if(S[ny][nx] != '.' && !visited[S[ny][nx]]) {\n              cnt[S[ny][nx]]++;\n              if(cnt[S[ny][nx]] == 2) {\n                visited[S[ny][nx]] = true;\n                ans += 2;\n                f = true;\n              }\n              break;\n            }\n            ny += dd[k];\n            nx += dd[k + 1];\n          }\n        }\n      }\n    }\n  }\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint m,n;\nvector<P> data[30];\nvector<int> xind;\nvector<int> yind;\nint field[190][190];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint pickl[4];\nint picklx[4];\nint pickly[4];\n\nint main(void){\n\tscanf(\"%d %d\",&n,&m);\n\tmemset(field,0,sizeof(field));\n\tfor(int i=0;i<n;i++){\n\t\tstring str;\n\t\tcin >> str;\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(str[j]>='A' && str[j]<='Z'){\n\t\t\t\tdata[str[j]-'A'+1].push_back(P(j,i));\n\t\t\t\tif(j-1>=0)xind.push_back(j-1);\n\t\t\t\txind.push_back(j);\n\t\t\t\tif(j+1<m)xind.push_back(j+1);\n\t\t\t\tif(i-1>=0)yind.push_back(i-1);\n\t\t\t\tyind.push_back(i);\n\t\t\t\tif(i+1<n)yind.push_back(i+1);\n\t\t\t}\n\t\t}\n\t}\n\tsort(xind.begin(),xind.end());\n\txind.erase(unique(xind.begin(),xind.end()),xind.end());\n\tsort(yind.begin(),yind.end());\n\tyind.erase(unique(yind.begin(),yind.end()),yind.end());\n\tfor(int i=1;i<=26;i++){\n\t\tfor(int j=0;j<data[i].size();j++){\n\t\t\tdata[i][j].first=lower_bound(xind.begin(),xind.end(),data[i][j].first)-xind.begin();\n\t\t\tdata[i][j].second=lower_bound(yind.begin(),yind.end(),data[i][j].second)-yind.begin();\n\t\t\tfield[data[i][j].first][data[i][j].second]=i;\n\t\t}\n\t}\n\tbool flag=true;\n\tint score2=0;\n\twhile(flag){\n\t\tflag=false;\n\t\tfor(int i=0;i<yind.size();i++){\n\t\t\tfor(int j=0;j<xind.size();j++){\n\t\t\t\tif(field[j][i]==0){\n\t\t\t\t\tmemset(pickl,0,sizeof(pickl));\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tint xx=j,yy=i;\n\t\t\t\t\t\tint xi=xind.size(),yi=yind.size();\n\t\t\t\t\t\twhile(xx>=0 && xx<xi && yy>=0 && yy<yi){\n\t\t\t\t\t\t\tif(field[xx][yy]!=0)break;\n\t\t\t\t\t\t\txx+=dx[k];\n\t\t\t\t\t\t\tyy+=dy[k];\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(field[xx][yy]!=0){\n\t\t\t\t\t\t\tpickl[k]=field[xx][yy];\n\t\t\t\t\t\t\tpicklx[k]=xx;\n\t\t\t\t\t\t\tpickly[k]=yy;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tfor(int l=k+1;l<4;l++){\n\t\t\t\t\t\t\tif(pickl[k]==pickl[l] && pickl[k]!=0){\n\t\t\t\t\t\t\t\tscore2+=2;\n\t\t\t\t\t\t\t\tfield[picklx[k]][pickly[k]]=0;\n\t\t\t\t\t\t\t\tfield[picklx[l]][pickly[l]]=0;\n\t\t\t\t\t\t\t\tflag=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",score2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <map>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define LINE() cerr<< \" (L\" << __LINE__ << \")\"\n\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nint main() {\n\t\tint H,W;cin >>H >> W;\n\n\t\tvector<string> board(H);\n\t\tfor(int y=0;y<H;y++){\n\t\t\tcin >> board[y];\n\t\t}\n\n\t\tmap<int,int> xmap,ymap;\n\t\tfor(int y=0;y<H;y++){\n\t\t\tfor(int x=0;x<W;x++){\n\t\t\t\tif(board[y][x]!='.'){\n\t\t\t\t\txmap.insert(make_pair(x,1));\n\t\t\t\t\tymap.insert(make_pair(y,1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> xs,ys;\n\t\tfor(auto it=xmap.begin();it!=xmap.end();it++){\n\t\t\txs.push_back(it->first);\n\t\t}\n\t\tfor(auto it=ymap.begin();it!=ymap.end();it++){\n\t\t\tys.push_back(it->first);\n\t\t}\n\t\tsort(xs.begin(),xs.end());\n\t\tsort(ys.begin(),ys.end());\n\n\t\tint h=ys.size(),w=xs.size();\n\t\tint res=0;\n\t\tfor(int c=0;c<300;c++){\n\t\t\tfor(int y=0;y<h;y++)for(int x=0;x<w;x++)if(board[ys[y]][xs[x]]=='.'){\n\t\t\t\tmap<char,vector<pair<int,int>>> ps;\n\t\t\t\tfor(int d=0;d<4;d++){\n\t\t\t\t\tint px=x,py=y;\n\t\t\t\t\twhile( 0<= px && px < w && 0 <=py && py < h  &&   board[ys[py]][xs[px]]=='.'){\n\t\t\t\t\t\tpx+=dx[d];py+=dy[d];\n\t\t\t\t\t}\n\t\t\t\t\tif( 0<= px && px < w && 0 <=py && py < h  && board[ys[py]][xs[px]]!='.'){\n\t\t\t\t\t\tps[board[ys[py]][xs[px]]].push_back(make_pair(py,px));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor(auto it=ps.begin();it!=ps.end();it++){\n\t\t\t\t\tvector<pair<int,int>> vs=it->second;\n\t\t\t\t\tif(it->second.size()==2){\n\t\t\t\t\t\tres+=2;\n\t\t\t\t\t\tboard[ys[vs[0].first]][xs[vs[0].second]]='.';\n\t\t\t\t\t\tboard[ys[vs[1].first]][xs[vs[1].second]]='.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << res <<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define MAX 1000\nchar t[MAX][MAX];\nbool f[26];\nint h,w;\nvector<int> Y[26],X[26];\n\nbool calc(int ay,int ax,int by,int bx){\n  if(ay>by)swap(ay,by);\n  if(ax>bx)swap(ax,bx);\n  for(int i=ay;i<=by;i++)\n    for(int j=ax;j<=bx;j++)\n      if(t[i][j]!='.')return false;\n  return true;\n}\n\nbool check(int id){\n  int ay=Y[id][0];\n  int ax=X[id][0];\n  int by=Y[id][1];\n  int bx=X[id][1];\n\n  if(abs(ay-by)+abs(ax-bx)==1)return false;\n  \n  t[ay][ax]='.';\n  t[by][bx]='.';\n  \n  if(calc(ay,ax,ay,bx)&&\n     calc(ay,bx,by,bx)&&\n     t[ay][bx]=='.'){\n    f[id]=false;\n    return true;\n  }\n  \n  if(calc(ay,ax,by,ax)&&\n     calc(by,ax,by,bx)&&\n     t[by][ax]=='.'){\n    f[id]=false;\n    return true;\n  }\n  \n  t[ay][ax]='A'+id;\n  t[by][bx]='A'+id;\n  return false;\n}\n\nint main(){\n  cin>>h>>w;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      cin>>t[i][j];\n      if(t[i][j]=='.')continue;\n      int id=t[i][j]-'A';\n      Y[id].push_back(i);\n      X[id].push_back(j);\n      f[id]=true;\n    }\n  }\n    \n  int ans=0,cnt;\n  while(1){\n    cnt=0;\n    for(int i=0;i<26;i++){\n      if(!f[i])continue;\n      if(check(i))cnt+=2;\n    }\n    if(cnt==0)break;\n    ans+=cnt;\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<map>\nusing namespace std;\nchar str[600][600];\nint r[30][2];\nint c[30][2];\nvector<int>w[30];\nmap<int,int>m;\nint solve(int a){\n\tif(m.count(a))return m[a];\n\tint ret=__builtin_popcount(a);\n\tfor(int i=0;i<26;i++)if(a&(1<<i)){\n\t\tfor(int j=0;j<w[i].size();j++){\n\t\t\tif(!(a&w[i][j])){\n\t\t\t\tret=min(ret,solve(a-(1<<i)));\n\t\t\t}\n\t\t}\n\t}\n\treturn m[a]=ret;\n}\nint main(){\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<a;i++)scanf(\"%s\",str[i]);\n\tfor(int i=0;i<26;i++)r[i][0]=r[i][1]=-1;\n\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\tif(str[i][j]!='.'){\n\t\t\tif(!~r[str[i][j]-'A'][0]){\n\t\t\t\tr[str[i][j]-'A'][0]=i;\n\t\t\t\tc[str[i][j]-'A'][0]=j;\n\t\t\t}else{\n\t\t\t\tr[str[i][j]-'A'][1]=i;\n\t\t\t\tc[str[i][j]-'A'][1]=j;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<26;i++){\n\t\tif(!~r[i][0])continue;\n\t\tif(r[i][0]==r[i][1]){\n\t\t\tif(c[i][0]+1<c[i][1]){\n\t\t\t\tint key=0;\n\t\t\t\tfor(int j=0;j<26;j++){\n\t\t\t\t\tif(r[i][0]==r[j][0]&&c[i][0]<c[j][0]&&c[j][0]<c[i][1])key|=(1<<j);\n\t\t\t\t\tif(r[i][0]==r[j][1]&&c[i][0]<c[j][1]&&c[j][1]<c[i][1])key|=(1<<j);\n\t\t\t\t}\n\t\t\t\tw[i].push_back(key);\n\t\t\t}\n\t\t}else if(c[i][0]==c[i][1]){\n\t\t\tif(r[i][0]+1<r[i][1]){\n\t\t\t\tint key=0;\n\t\t\t\tfor(int j=0;j<26;j++){\n\t\t\t\t\tif(c[i][0]==c[j][0]&&r[i][0]<r[j][0]&&r[j][0]<r[i][1])key|=(1<<j);\n\t\t\t\t\tif(c[i][0]==c[j][0]&&r[i][0]<r[j][1]&&r[j][1]<r[i][1])key|=(1<<j);\n\t\t\t\t}\n\t\t\t\tw[i].push_back(key);\n\t\t\t}\n\t\t}else{\n\t\t\tint key=0;\n\t\t\tfor(int j=0;j<26;j++){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tif(r[i][0]==r[j][0]&&min(c[i][0],c[i][1])<=c[j][0]&&c[j][0]<=max(c[i][0],c[i][1]))key|=(1<<j);\n\t\t\t\tif(c[i][1]==c[j][0]&&r[i][0]<=r[j][0]&&r[j][0]<=r[i][1])key|=(1<<j);\n\t\t\t\tif(r[i][0]==r[j][1]&&min(c[i][0],c[i][1])<=c[j][1]&&c[j][1]<=max(c[i][0],c[i][1]))key|=(1<<j);\n\t\t\t\tif(c[i][1]==c[j][1]&&r[i][0]<=r[j][1]&&r[j][1]<=r[i][1])key|=(1<<j);\n\t\t\t}\n\t\t\tw[i].push_back(key);\n\t\t\tkey=0;\n\t\t\tfor(int j=0;j<26;j++){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tif(r[i][1]==r[j][0]&&min(c[i][0],c[i][1])<=c[j][0]&&c[j][0]<=max(c[i][0],c[i][1]))key|=(1<<j);\n\t\t\t\tif(c[i][0]==c[j][0]&&r[i][0]<=r[j][0]&&r[j][0]<=r[i][1])key|=(1<<j);\n\t\t\t\tif(r[i][1]==r[j][1]&&min(c[i][0],c[i][1])<=c[j][1]&&c[j][1]<=max(c[i][0],c[i][1]))key|=(1<<j);\n\t\t\t\tif(c[i][0]==c[j][1]&&r[i][0]<=r[j][1]&&r[j][1]<=r[i][1])key|=(1<<j);\n\t\t\t}\n\t\t\tw[i].push_back(key);\n\t\t}\n\t}\n\t/*for(int i=0;i<26;i++){\n\t\tprintf(\"%c: \",'A'+i);\n\t\tfor(int j=0;j<w[i].size();j++)printf(\"%d \",w[i][j]);\n\t\tprintf(\"\\n\");\n\t}*/\n\tint st=0;\n\tint ret=0;\n\tfor(int i=0;i<26;i++){\n\t\tif(!~r[i][0])continue;\n\t\tret++;\n\t\tbool ok=false;\n\t\tfor(int j=0;j<w[i].size();j++)if(!w[i][j])ok=true;\n\t\tif(!ok)st+=(1<<i);\n\t}\n\tprintf(\"%d\\n\",ret*2-solve(st)*2);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint m,n;\nvector<P> data[30];\nvector<int> xindex;\nvector<int> yindex;\nint field[190][190];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint pickl[4];\nint picklx[4];\nint pickly[4];\n\nint main(void){\n\tscanf(\"%d %d\",&n,&m);\n\tmemset(field,0,sizeof(field));\n\tfor(int i=0;i<n;i++){\n\t\tstring str;\n\t\tcin >> str;\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(str[j]>='A' && str[j]<='Z'){\n\t\t\t\tdata[str[j]-'A'+1].push_back(P(j,i));\n\t\t\t\tif(j-1>=0)xindex.push_back(j-1);\n\t\t\t\txindex.push_back(j);\n\t\t\t\tif(j+1<m)xindex.push_back(j+1);\n\t\t\t\tif(i-1>=0)yindex.push_back(i-1);\n\t\t\t\tyindex.push_back(i);\n\t\t\t\tif(i+1<n)yindex.push_back(i+1);\n\t\t\t}\n\t\t}\n\t}\n\tsort(xindex.begin(),xindex.end());\n\txindex.erase(unique(xindex.begin(),xindex.end()),xindex.end());\n\tsort(yindex.begin(),yindex.end());\n\tyindex.erase(unique(yindex.begin(),yindex.end()),yindex.end());\n\tfor(int i=1;i<=26;i++){\n\t\tfor(int j=0;j<data[i].size();j++){\n\t\t\tdata[i][j].first=lower_bound(xindex.begin(),xindex.end(),data[i][j].first)-xindex.begin();\n\t\t\tdata[i][j].second=lower_bound(yindex.begin(),yindex.end(),data[i][j].second)-yindex.begin();\n\t\t\tfield[data[i][j].first][data[i][j].second]=i;\n\t\t}\n\t}\n\tbool flag=true;\n\tint score=0;\n\twhile(flag){\n\t\tflag=false;\n\t\tfor(int i=0;i<yindex.size();i++){\n\t\t\tfor(int j=0;j<xindex.size();j++){\n\t\t\t\tif(field[j][i]==0){\n\t\t\t\t\tmemset(pickl,0,sizeof(pickl));\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tint xx=j,yy=i;\n\t\t\t\t\t\tint xi=xindex.size(),yi=yindex.size();\n\t\t\t\t\t\tint cnt=0;\n\t\t\t\t\t\twhile(xx>=0 && xx<xi && yy>=0 && yy<yi){\n\t\t\t\t\t\t\tif(field[xx][yy]!=0)break;\n\t\t\t\t\t\t\txx+=dx[k];\n\t\t\t\t\t\t\tyy+=dy[k];\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\tif(cnt>=190)break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(field[xx][yy]!=0){\n\t\t\t\t\t\t\tpickl[k]=field[xx][yy];\n\t\t\t\t\t\t\tpicklx[k]=xx;\n\t\t\t\t\t\t\tpickly[k]=yy;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tfor(int l=k+1;l<4;l++){\n\t\t\t\t\t\t\tif(pickl[k]==pickl[l] && pickl[k]!=0){\n\t\t\t\t\t\t\t\tscore+=2;\n\t\t\t\t\t\t\t\tfield[picklx[k]][pickly[k]]=0;\n\t\t\t\t\t\t\t\tfield[picklx[l]][pickly[l]]=0;\n\t\t\t\t\t\t\t\tflag=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",score);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\nusing namespace std;\n\nint M, N;\nchar S[550][550];\nvector<int> Y[256], X[256];\nbool E[256][256];\nbool b[256];\n\nvoid dfs(int v) {\n  if(!b[v]) return;\n  b[v] = false;\n  REP(i, 'A', 'Z' + 1) if(E[v][i]) dfs(i);\n}\n\nint main(void) {\n  cin >> M >> N;\n  REP(i, 0, M) cin >> S[i];\n\n  REP(i, 0, M) REP(j, 0, N) if(S[i][j] != '.') {\n    Y[S[i][j]].push_back(i);\n    X[S[i][j]].push_back(j);\n  }\n\n  REP(i, 0, 256) REP(j, 0, 256) E[i][j] = false;\n\n  REP(i, 'A', 'Z' + 1) {\n    if(Y[i].size() == 0) continue;\n    int x1 = X[i][0], x2 = X[i][1];\n    int y1 = Y[i][0], y2 = Y[i][1];\n    if(x1 == x2) {\n      REP(j, min(y1, y2) + 1, max(y1, y2)) {\n        if(S[y1][j] != '.') E[i][S[j][x1]] = true;\n      }\n    } else if(y1 == y2) {\n      REP(j, min(x1, x2) + 1, max(x1, x2)) {\n        if(S[j][x1] != '.') E[i][S[y1][j]] = true;\n      }\n    } else {\n      if(S[y1][x2] != '.' && S[y1][x2] == S[y2][x1]) E[i][S[y1][x2]] = true;\n    }\n  }\n\n  vector<int> fi;\n  REP(i, 'A', 'Z' + 1) {\n    if(Y[i].size() == 0) continue;\n    int x1 = X[i][0], x2 = X[i][1];\n    int y1 = Y[i][0], y2 = Y[i][1];\n    if(x1 == x2 && abs(y1 - y2) == 1) fi.push_back(i);\n    if(y1 == y2 && abs(x1 - x2) == 1) fi.push_back(i);\n  }\n  REP(i, 'A', 'Z' + 1) REP(j, i + 1, 'Z' + 1) if(i != j) {\n    if(E[i][j] && E[j][i]) {\n      fi.push_back(i);\n      fi.push_back(j);\n    }\n  }\n\n  REP(i, 'A', 'Z' + 1) if(Y[i].size() > 0) b[i] = true;\n  REP(i, 0, fi.size()) dfs(fi[i]);\n\n  int ans = 0;\n  REP(i, 'A', 'Z' + 1) if(b[i]) ans += 2;\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main(){\n  int n, m;\n  cin >> m >> n;\n  vector<string> C(m);\n  vector< vector<int> > A(26);\n  for(int i = 0; i < m; ++i){\n    cin >> C[i];\n    for(int j = 0; j < n; ++j){\n      if(C[i][j] != '.') A[C[i][j]-'A'].push_back(i*n+j);\n    }\n  }\n  int ans = 0;\n  for(int i = 0; i < 26; ++i){\n    for(int j = 0; j < 26; ++j){\n      if(A[j].empty()) continue;\n      int a = A[j][0]/n, b = A[j][0]%n, c = A[j][1]/n, d = A[j][1]%n;\n      if(a == c){\n        for(int k = min(b,d); k < max(b,d); ++k){\n          if(C[a][k] == '.'){\n            //cout << (char)('A'+j) << endl;\n            C[a][b] = '.';\n            C[c][d] = '.';\n            ans += 2;\n            A[j] = vector<int>(0);\n            break;\n          }\n        }\n      }else if(b == d){\n        for(int k = min(a,c); k < max(a,c); ++k){\n          if(C[k][b] == '.'){\n            //cout << (char)('A'+j) << endl;\n            C[a][b] = '.';\n            C[c][d] = '.';\n            ans += 2;\n            A[j] = vector<int>(0);\n            break;\n          }\n        }\n      }else if(C[a][d] == '.' || C[c][b] == '.'){\n        //cout << (char)('A'+j) << endl;\n        C[a][b] = '.';\n        C[c][d] = '.';\n        ans += 2;\n        A[j] = vector<int>(0);\n      }\n    }\n  }\n  cout << ans << endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <sstream>\n#include <utility>\n#include <set>\n#include <map>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define each(e,c) for(auto&e:c)\n#define iter(i,c) for(auto i(begin(c));i!=end(c);++i)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\ntemplate<class C>string to_string(vector<C> c,string d=\" \"){stringstream s;iter(i,c)s<<*i<<(next(i)==end(c)?\"\":d);return s.str();}\ntemplate<class C>ostream&operator<<(ostream&os,vector<C>const& v){return os<<to_string(v);}\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<(DUMP(),__VA_ARGS__).str()<<\" (at \"<<__LINE__<<\")\"<<endl)\nstruct DUMP:ostringstream{template<class T>DUMP &operator,(const T&t){if(this->tellp())*this<<\", \";*this<<t;return *this;}};\n#else\n#define dump(...)\n#endif\n\ntypedef vector<string> vs;\nint h,w;\nvs g;\nbool valid(int x, int y){\n    return 0<=x && 0<=y && x<w && y<h;\n}\n\nint solve(){\n    vector<pii> space;\n    rep(i,h)rep(j,w)if(g[i][j]=='.') space.emplace_back(j,i);\n    int ans = 0;\n    while(1){\n        bool finish = true;\n        for(auto p : space){\n            map<char,vector<pii>> s;\n            int x,y;\n            tie(x,y)=p;\n            int dx[]={1,0,-1,0};\n            int dy[]={0,1,0,-1};\n            rep(d,4){\n                int cx,cy;\n                tie(cx,cy)=tie(x,y);\n                while(valid(cx+dx[d],cy+dy[d]) && g[cy][cx]=='.'){\n                    cx+=dx[d]; cy+=dy[d];\n                }\n                if(valid(cx,cy) && g[cy][cx]!='.'){\n                    s[g[cy][cx]].emplace_back(cx,cy);\n                }\n            }\n            for(auto & ps : s){\n                if(ps.second.size()>=2){\n                    for(auto & p : ps.second){\n                        int x,y;\n                        tie(x,y) = p;\n                        g[y][x] = '.';\n                        ans++;\n                        finish = false;\n                        space.emplace_back(x,y);\n                    }\n                }\n            }\n        }\n        if(finish) break;\n    }\n    return ans;\n}\n\nint main(){\n    while(cin>>h>>w){\n        g.clear();\n        rep(i,h){\n            string s;cin>>s;\n            g.push_back(s);\n        }\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nint main(){\n    int n,m;\n    cin>>n>>m;\n    vector<string> f(n);\n    for(int i=0;i<n;i++) cin>>f[i];\n        \n    int res=0;\n    bool update=true;\n    while(update){\n        update=false;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<m;j++){\n                if(f[i][j]=='.'){\n                    map<char,int> cnt;\n                    for(int k=i+1;k<n;k++){\n                        if(f[k][j]!='.'){\n                            cnt[f[k][j]]++;\n                            break;\n                        }\n                    }\n                    for(int k=i-1;k>=0;k--){\n                        if(f[k][j]!='.'){\n                            cnt[f[k][j]]++;\n                            break;\n                        }\n                    }\n                    for(int k=j+1;k<m;k++){\n                        if(f[i][k]!='.'){\n                            cnt[f[i][k]]++;\n                            break;\n                        }\n                    }\n                    for(int k=j-1;k>=0;k--){\n                        if(f[i][k]!='.'){\n                            cnt[f[i][k]]++;\n                            break;\n                        }\n                    }\n                    for(auto &e:cnt){\n                        if(e.second==2){\n                            update=true;\n                            res+=2;\n                            for(int k=0;k<n;k++){\n                                if(f[k][j]==e.first) f[k][j]='.';\n                            }\n                            for(int k=0;k<m;k++){\n                                if(f[i][k]==e.first) f[i][k]='.';\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    cout<<res<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<cassert>\n#include<cstdlib>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int N = 500;\nchar m[N][N+1];\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\n\nbool cango(int r,int c,int y,int x,int ty,int tx){\n  rep(i,4){\n    int ddx=x+dx[i],ddy=y+dy[i];\n    while(ddy != -1 && ddx != -1 && ddy != r && ddx != c){\n      if (m[ddy][ddx] != '.')break;\n      if (ddy == ty && ddx == tx)return true;\n      ddx+=dx[i];\n      ddy+=dy[i];\n    }\n  }\n  return false;\n}\n\nbool erase(int r,int c,int y1,int x1,int y2,int x2){\n  vector<int> tx,ty;\n  if (y1 == y2){\n    tx.push_back(x1 < x2?x1+1:x2+1);\n    ty.push_back(y1);\n  }else if (x1 == x2){\n    tx.push_back(x1);\n    ty.push_back(y1 < y2?y1+1:y2+1);\n  }else {\n    tx.push_back(x1);\n    ty.push_back(y2);\n    tx.push_back(x2);\n    ty.push_back(y1);\n  }\n  bool isok=false;\n  rep(i,(int)tx.size()){\n    if (cango(r,c,y1,x1,ty[i],tx[i]) && cango(r,c,y2,x2,ty[i],tx[i])){isok=true;break;}\n  }\n  if (isok)m[y1][x1]=m[y2][x2]='.';\n  return isok;\n}\n\nint main(){\n  int r,c;\n  while(cin>>r>>c){\n    rep(i,r)cin>>m[i];\n    vector<pii> in[26];\n    rep(i,r){\n      rep(j,c){\n\tif (!isalpha(m[i][j]))continue;\n\tin[m[i][j]-'A'].push_back(make_pair(i,j));\n      }\n    }\n    int ans=0;\n    while(true){\n      bool iserased=false;\n      rep(i,26){\n\tif (in[i].size() == 0)continue;\n\tif (abs(in[i][0].first-in[i][1].first)+abs(in[i][0].second-in[i][1].second) == 1)in[i].clear();\n\tif (erase(r,c,in[i][0].first,in[i][0].second,in[i][1].first,in[i][1].second))ans+=2,iserased=true,in[i].clear();\n      }\n      if (!iserased)break;\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\n#include <array>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\n\n\ntypedef long long int ll;\ntypedef double D;      // ??§?¨?????????????double???long double?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\n\n\nconst int INF = (1<<30) - 1;\nconst D EPS = 1e-9;\n\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\nint M, N;\nvector<string> field;\n\nint dh[] = {-1, 1, 0, 0};\nint dw[] = {0, 0, 1, -1};\n\ninline bool in_field(int h, int w){\n    return 0<=h&&h<M && 0<=w&&w<N;\n}\n\nvoid solve(){\n    bool updated = true;\n    int count = 0;\n    while (updated) {\n        updated = false;\n        for(int i=0; i<M; i++){\n            for(int j=0; j<N; j++) if(field[i][j] == '.'){\n                vector<tuple<char, int, int>> colors;\n                \n                for(int d=0; d<4; d++){\n                    int l = 0;\n                    while(in_field(i+dh[d]*l, j+dw[d]*l) && field[i+dh[d]*l][j+dw[d]*l] == '.') l++;\n                    \n                    if(!in_field(i+dh[d]*l, j+dw[d]*l)) continue;\n                    \n                    colors.push_back({field[i+dh[d]*l][j+dw[d]*l], i+dh[d]*l, j+dw[d]*l});\n                }\n                \n                for(int i=0; i<colors.size(); i++){\n                    for(int j=i+1; j<colors.size(); j++){\n                        char c1, c2;\n                        int h1, w1, h2, w2;\n                        tie(c1, h1, w1) = colors[i];\n                        tie(c2, h2, w2) = colors[j];\n                        if(c1 == c2){\n                            field[h1][w1] = field[h2][w2] = '.';\n                            count += 2;\n                            updated = true;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    cout << count << endl;\n}\n\n//g++ -std=c++0x -msse4.2 -O3\n//#include <bits/stdc++.h>\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    //cout.precision(16);\n    \n    cin >> M >> N;\n    field = vector<string>(M);\n    for(int i=0; i<M; i++)\n        cin >> field[i];\n    \n    solve();\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<math.h>\n#include<map>\nusing namespace std;\ntypedef pair<int,int> P;\n#define Y first\n#define X second\nint main(){\n  int m,n;\n  cin >> m >> n;\n  string st[600];\n  int i,j,k;\n  for(i=0;i<m;i++) cin >> st[i];\n  bool alp[26]={};\n  vector<P> v[26];\n  P p;\n  for(i=0;i<m;i++){\n    for(j=0;j<n;j++){\n      if(st[i][j]!='.') {\n\talp[st[i][j]-'A']=true;\n\tp.Y=i;p.X=j;\n\tv[st[i][j]-'A'].push_back(p);\n      }\n    }\n  }\n  //cout << \"x\" << endl;\n  bool f=true,e;\n  int ans=0;\n  while(f){\n    f=false;\n    for(k=0;k<26;k++){\n      if(!alp[k]) continue;\n      if(v[k][0].X==v[k][1].X){\n\tif(abs(v[k][0].Y-v[k][1].Y)<2) continue;\n\te=true;\n\tfor(i=min(v[k][0].Y,v[k][1].Y)+1;i<max(v[k][0].Y,v[k][1].Y);i++){\n\t  if(st[i][v[k][0].X]!='.') e=false;\n\t}\n\tif(e){\n\t  st[v[k][0].Y][v[k][0].X]='.';\n\t  st[v[k][1].Y][v[k][1].X]='.';\n\t  alp[k]=false;\n\t  ans++;f=true;\n\t  break;\n\t}\n      }else if(v[k][0].Y==v[k][1].Y){\n\tif(abs(v[k][0].X-v[k][1].X)<2) continue;\n\te=true;\n\tfor(i=min(v[k][0].X,v[k][1].X)+1;i<max(v[k][0].X,v[k][1].X);i++){\n\t  if(st[v[k][0].Y][i]!='.') e=false;\n\t}\n\tif(e){\n\t  st[v[k][0].Y][v[k][0].X]='.';\n\t  st[v[k][1].Y][v[k][1].X]='.';\n\t  alp[k]=false;\n\t  ans++;f=true;\n\t  break;\n\t}\n      }else if((v[k][0].X-v[k][1].X)*(v[k][0].Y-v[k][1].Y)>0){\n\tif(v[k][0].X>v[k][1].X) swap(v[k][0],v[k][1]);\n\te=true;\n\tfor(i=v[k][0].X+1;i<v[k][1].X;i++){\n\t  if(st[v[k][0].Y][i]!='.') e=false;\n\t}\n\tfor(i=v[k][0].Y+1;i<v[k][1].Y;i++){\n\t  if(st[i][v[k][1].X]!='.') e=false;\n\t}\n\tif(e){\n\t  st[v[k][0].Y][v[k][0].X]='.';\n\t  st[v[k][1].Y][v[k][1].X]='.';\n\t  alp[k]=false;\n\t  ans++;f=true;\n\t  break;\n\t}\n\te=true;\n\tfor(i=v[k][0].Y+1;i<v[k][1].Y;i++){\n\t  if(st[i][v[k][0].X]!='.') e=false;\n\t}\n\tfor(i=v[k][0].X+1;i<v[k][1].X;i++){\n\t  if(st[v[k][1].Y][i]!='.') e=false;\n\t}\n\tif(e){\n\t  st[v[k][0].Y][v[k][0].X]='.';\n\t  st[v[k][1].Y][v[k][1].X]='.';\n\t  alp[k]=false;\n\t  ans++;f=true;\n\t  break;\n\t}\n      }else{\n\tif(v[k][0].X>v[k][1].X) swap(v[k][0],v[k][1]);\n\te=true;\n\tfor(i=v[k][0].X+1;i<v[k][1].X;i++){\n\t  if(st[v[k][0].Y][i]!='.') e=false;\n\t}\n\tfor(i=v[k][0].Y-1;i>v[k][1].Y;i--){\n\t  if(st[i][v[k][1].X]!='.') e=false;\n\t}\n\tif(e){\n\t  st[v[k][0].Y][v[k][0].X]='.';\n\t  st[v[k][1].Y][v[k][1].X]='.';\n\t  alp[k]=false;\n\t  ans++;f=true;\n\t  break;\n\t}\n\te=true;\n\tfor(i=v[k][0].Y-1;i>v[k][1].Y;i--){\n\t  if(st[i][v[k][0].X]!='.') e=false;\n\t}\n\tfor(i=v[k][0].X+1;i<v[k][1].X;i++){\n\t  if(st[v[k][1].Y][i]!='.') e=false;\n\t}\n\tif(e){\n\t  st[v[k][0].Y][v[k][0].X]='.';\n\t  st[v[k][1].Y][v[k][1].X]='.';\n\t  alp[k]=false;\n\t  ans++;f=true;\n\t  break;\n\t}\n      }\n    }\n    //for(i=0;i<m;i++) cout << st[i] << endl; cout << endl;\n  }\n  //for(i=0;i<m;i++) cout << st[i] << endl;\n  cout << ans*2 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\nstring mps[501];\npair<int,int> tile1[26];\npair<int,int> tile2[26];\nint m,n;\n\nbool inter(int i,int j,int k) {\n    if(j == k && i != j) return false;\n    if(j > k) swap(j,k);\n\n    return (j <= i) && (i <= k);\n}\n\nint iabs(int i) {\n    if(i < 0) return -i;\n    return i;\n}\n\nbool ok(int idx,int x1,int y1,int x2,int y2) {\n    // adj\n    if(x1 == x2 && iabs(y1-y2) == 1) return false;\n    if(y1 == y2 && iabs(x1-x2) == 1) return false;\n\n    for(int i=0; i<26; ++i) {\n        if(tile1[i].first == -1 || i == idx) continue;\n        if(x1 == x2) {\n            if(tile1[i].second == x1 && inter(tile1[i].first,y1,y2)) return false;\n            if(tile2[i].second == x1 && inter(tile2[i].first,y1,y2)) return false;\n        }else if(y1 == y2) {\n            if(tile1[i].first == y1 && inter(tile1[i].second,x1,x2)) return false;\n            if(tile2[i].first == y1 && inter(tile2[i].second,x1,x2)) return false;\n        }\n    }\n\n    bool is1 = false,is2 = false;\n    for(int i=0; i<26; ++i) {\n        if(tile1[i].first == -1 || i == idx) continue;\n        if(tile1[i].first == y1 && inter(tile1[i].second,x1,x2)) is1 = true;\n        if(tile1[i].first == y2 && inter(tile1[i].second,x1,x2)) is2 = true;\n        if(tile2[i].first == y1 && inter(tile2[i].second,x1,x2)) is1 = true;\n        if(tile2[i].first == y2 && inter(tile2[i].second,x1,x2)) is2 = true;\n\n        if(tile1[i].second == x1 && inter(tile1[i].first,y1,y2)) is2 = true;\n        if(tile1[i].second == x2 && inter(tile1[i].first,y1,y2)) is1 = true;\n        if(tile2[i].second == x1 && inter(tile1[i].first,y1,y2)) is2 = true;\n        if(tile2[i].second == x2 && inter(tile1[i].first,y1,y2)) is1 = true;\n    }\n\n    if(is1 && is2) return false;\n\n    return true;\n}\n\nint main() {\n    cin>>m>>n;\n    for(int i=0; i<m; ++i) cin>>mps[i];\n\n    for(int i=0; i<26; ++i)\n        tile1[i] = tile2[i] = make_pair(-1,-1);\n\n    for(int i=0; i<m; ++i) {\n        for(int j=0; j<n; ++j) {\n            if(mps[i][j] != '.') {\n                if(tile1[mps[i][j]-'A'].first == -1) tile1[mps[i][j]-'A'] = make_pair(i,j);\n                else tile2[mps[i][j]-'A'] = make_pair(i,j);\n            }\n        }\n    }\n\n    int ans = 0;\n    while(true) {\n        bool update = false;\n\n        for(int i=0; i<26; ++i) {\n            if(tile1[i].first == -1) continue;\n            int x1 = tile1[i].second,y1 = tile1[i].first;\n            int x2 = tile2[i].second,y2 = tile2[i].first;\n            if(ok(i,x1,y1,x2,y2)) {\n                tile1[i] = make_pair(-1,-1);\n                tile2[i] = make_pair(-1,-1);\n                ans += 2;\n                update = true;\n            }\n\n        // for(int i=0; i<m; ++i) {\n        //     for(int j=0; j<n; ++j) {\n        //         if(mps[i][j] == '.') cout<<\".\";\n        //         else if(tile1[mps[i][j]-'A'].first == -1) cout<<\".\";\n        //         else cout<<mps[i][j];\n        //     }\n        //     cout<<endl;\n        // }\n        }\n\n        if(!update) break;\n\n\n    }\n\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nint main(){\n\tint dy[] = {0, 0, 1, -1};\n\tint dx[] = {1, -1, 0, 0};\n\n\tint h, w;\n\tcin >> h >> w;\n\n\tvector<string> grid(h);\n\tfor(int i=0; i<h; ++i)\n\t\tcin >> grid[i];\n\n\tstring s = string(w, '.');\n\tfor(int i=1; i<h-1; ++i){\n\t\tif(grid[i-1] == s && grid[i] == s){\n\t\t\tgrid.erase(grid.begin() + i);\n\t\t\t-- i;\n\t\t\t-- h;\n\t\t}\n\t}\n\n\tint ret = 0;\n\tfor(;;){\n\t\tbool ok = true;\n\t\tfor(int i=0; i<h; ++i){\n\t\t\tfor(int j=0; j<w; ++j){\n\t\t\t\tif(grid[i][j] != '.')\n\t\t\t\t\tcontinue;\n\n\t\t\t\tmap<char, pair<int, int> > m;\n\n\t\t\t\tfor(int k=0; k<4; ++k){\n\t\t\t\t\tint y = i;\n\t\t\t\t\tint x = j;\n\t\t\t\t\twhile(y >= 0 && y < h && x >= 0 && x < w && grid[y][x] == '.'){\n\t\t\t\t\t\ty += dy[k];\n\t\t\t\t\t\tx += dx[k];\n\t\t\t\t\t}\n\t\t\t\t\tif(y >= 0 && y < h && x >= 0 && x < w){\n\t\t\t\t\t\tchar c = grid[y][x];\n\t\t\t\t\t\tif(m.find(c) != m.end()){\n\t\t\t\t\t\t\tgrid[y][x] = '.';\n\t\t\t\t\t\t\tgrid[m[c].first][m[c].second] = '.';\n\t\t\t\t\t\t\tret += 2;\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tm[c] = make_pair(y, x);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ok)\n\t\t\tbreak;\n\t}\n\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\nusing namespace std;\n\nint W,H;\n\nvector<string> V;\n\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\n\nint res;\ntypedef pair<int,int> Cor;\n\nbool in(int y,int x){\n\treturn !(y<0 || x<0 || y>=H || x>=W);\n}\nvector<vector<Cor> >Al(26);\n\nvoid print(){\n\tcout<<endl;\n\tfor(int y=0;y<H;y++){\n\t\tfor(int x=0;x<W;x++)\n\t\t\tcout<<V[y][x];\n\t\tcout<<endl;\n\t}\n}\n\n\nbool kesu(int k){\n\tvector<vector<bool> > Check(H,vector<bool>(W,false));\n\tint y1=Al[k][0].first,x1=Al[k][0].second;\n\tint y2=Al[k][1].first,x2=Al[k][1].second;\n\n\tfor(int r=0;r<4;r++){\n\t\tint y=y1+dy[r],x=x1+dx[r];\n\t\twhile(in(y,x) && V[y][x]=='.'){Check[y][x]=true; y+=dy[r];x+=dx[r];}\n\t}\n\n\tfor(int r=0;r<4;r++){\n\t\tint y=y2+dy[r],x=x2+dx[r];\n\t\twhile(in(y,x) && V[y][x]=='.'){\n\t\t\tif(Check[y][x]){res++;V[y1][x1]=V[y2][x2]='.';return true;}\n\t\t\tCheck[y][x]=true; y+=dy[r];x+=dx[r];\n\t\t}\n\t}\n\treturn false;\n}\n\nvoid solve(){\n\tres=0;\n\tV.clear();\n\tAl.clear();\n\tAl.resize(26);\n\tfor(int i=0;i<H;i++){\n\t\tstring s;\n\t\tcin>>s;\n\t\tV.push_back(s);\n\t}\n\n\tvector<bool> ex(26,false);\n\t\n\tfor(int y=0;y<H;y++){\n\t\tfor(int x=0;x<W;x++){\n\t\t\tif(V[y][x]!='.'){\n\t\t\t\tint c=V[y][x]-'A';\n\t\t\t\tex[c]=true;\n\t\t\t\tAl[c].push_back(make_pair(y,x));\n\t\t\t}\n\t\t}\n\t}\n\n\tbool update=true;\n\twhile(update){\n\t\tupdate=false;\n\t\tfor(int k=0;k<26;k++){\n\t\t\tif(!ex[k]) continue;\n\t\t\tbool kekka=kesu(k);\n\t\t\tex[k]=!kekka;\n\t\t\tupdate=(update || kekka);\n\t\t}\n\t}\n\tcout<<res*2<<endl;\n}\n\nint main()\n{\n\twhile(cin>>H>>W){\n\t\tif(H==0) break;\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nusing P = pair<int, int>;\n\nint main() {\n    int m, n;\n    cin >> m >> n;\n    vector<string> tile(m);\n    vector<vector<P>> v(26);\n    for(int i=0; i<m; ++i) {\n        cin >> tile[i];\n        for(int j=0; j<n; ++j) {\n            if(tile[i][j] != '.') {\n                v[tile[i][j]-'A'].push_back(P{j, i});\n            }\n        }\n    }\n    int ans = 0;\n    while(true) {\n        v.erase(remove_if(v.begin(), v.end(), [](auto const& vv) {\n            return vv.empty();\n        }), v.end());\n        bool update = false;\n        for(auto& x : v) {\n            P p1 = x[0], p2 = x[1];\n            if(p1.first == p2.first) {\n                bool ok = (min(p1.second, p2.second)+1 != max(p1.second, p2.second));\n                for(int i=min(p1.second, p2.second)+1; i<max(p1.second, p2.second); ++i) {\n                    if(tile[i][p1.first] != '.') {\n                        ok = false;\n                        break;\n                    }\n                }\n                if(ok) {\n                    tile[p1.second][p1.first] = tile[p2.second][p2.first] = '.';\n                    x.clear();\n                    update = true;\n                    ans += 2;\n                }\n            } else if(p1.second == p2.second) {\n                bool ok = (min(p1.first, p2.first) + 1 != max(p1.first, p2.first));\n                for(int i=min(p1.first, p2.first)+1; i<max(p1.first, p2.first); ++i) {\n                    if(tile[p1.second][i] != '.') {\n                        ok = false;\n                        break;\n                    }\n                }\n                if(ok) {\n                    tile[p1.second][p1.first] = tile[p2.second][p2.first] = '.';\n                    x.clear();\n                    update = true;\n                    ans += 2;\n                }\n            } else {\n                int x1 = p1.first, y1 = p2.second;\n                int x2 = p2.first, y2 = p1.second;\n                bool ok = true;\n                for(int i=(x1 < x2 ? x1 : x2+1); i<=(x1 < x2 ? x2-1 : x1); ++i) {\n                    if(tile[y1][i] != '.') {\n                        ok = false;\n                        break;\n                    }\n                }\n                for(int i=(y1 < y2 ? y1 : y2+1); i<=(y1 < y2 ? y2-1 : y1); ++i) {\n                    if(tile[i][x1] != '.') {\n                        ok = false;\n                        break;\n                    }\n                }\n                if(ok) {\n                    tile[p1.second][p1.first] = tile[p2.second][p2.first] = '.';\n                    ans += 2;\n                    update = true;\n                    x.clear();\n                    continue;\n                }\n\n                ok = true;\n                for(int i=(x2 < x1 ? x2 : x1+1); i<=(x2 < x1 ? x1-1 : x2); ++i) {\n                    if(tile[y2][i] != '.') {\n                        ok = false;\n                        break;\n                    }\n                }\n                for(int i=(y2 < y1 ? y2 : y1+1); i<=(y2 < y1 ? y1-1 : y2); ++i) {\n                    if(tile[i][x2] != '.') {\n                        ok = false;\n                        break;\n                    }\n                }\n                if(ok) {\n                    tile[p1.second][p1.first] = tile[p2.second][p2.first] = '.';\n                    ans += 2;\n                    update = true;\n                    x.clear();\n                    continue;\n                }\n            }\n        }\n        if(!update) {\n            break;\n        }\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef long double ld;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-10;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nint main()\n{\n\tint n, m;\n\tcin >> n >> m;\n\tvs fld(n);\n\tREP(i, n) cin >> fld[i];\n\tvector<vector<pii>> v(26);\n\tREP(i, n)REP(j, m)\n\t{\n\t\tif (fld[i][j] != '.')\n\t\t{\n\t\t\tv[fld[i][j] - 'A'].emplace_back(i, j);\n\t\t}\n\t}\n\tbool update = true;\n\tint ans = 0;\n\twhile (update)\n\t{\n\t\tupdate = false;\n\t\tREP(i, 26)\n\t\t{\n\t\t\tif (v[i].size() == 0) continue;\n\t\t\tint ax = v[i][0].first, ay = v[i][0].second;\n\t\t\tint bx = v[i][1].first, by = v[i][1].second;\n\t\t\tif (ax == bx)\n\t\t\t{\n\t\t\t\tbool f = true;\n\t\t\t\tif (ay > by) swap(ay, by);\n\t\t\t\tFOR(j, ay + 1, by)\n\t\t\t\t{\n\t\t\t\t\tif (fld[ax][j] != '.') f = false;\n\t\t\t\t}\n\t\t\t\tif (f&&abs(ay-by)>1)\n\t\t\t\t{\n\t\t\t\t\tupdate = true;\n\t\t\t\t\tv[i].clear();\n\t\t\t\t\tans++;\n\t\t\t\t\tfld[ax][ay] = fld[bx][by] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (ay == by)\n\t\t\t{\n\t\t\t\tbool f = true;\n\t\t\t\tif (ax > bx) swap(ax, bx);\n\t\t\t\tFOR(j, ay + 1, by)\n\t\t\t\t{\n\t\t\t\t\tif (fld[j][ay] != '.') f = false;\n\t\t\t\t}\n\t\t\t\tif (f&&abs(ax - bx)>1)\n\t\t\t\t{\n\t\t\t\t\tupdate = true;\n\t\t\t\t\tv[i].clear();\n\t\t\t\t\tans++;\n\t\t\t\t\tfld[ax][ay] = fld[bx][by] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (ay > by)\n\t\t\t\t{\n\t\t\t\t\tswap(ax, bx), swap(ay, by);\n\t\t\t\t}\n\t\t\t\tif (ax > bx)\n\t\t\t\t{\n\t\t\t\t\tbool f1 = true;\n\t\t\t\t\tFOR(j, ay + 1, by)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (fld[ax][j] != '.') f1 = false;\n\t\t\t\t\t}\n\t\t\t\t\tFOR(j, bx + 1, ax + 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (fld[j][by] != '.') f1 = false;\n\t\t\t\t\t}\n\t\t\t\t\tbool f2 = true;\n\t\t\t\t\tFOR(j, bx, ax)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (fld[j][ay] != '.') f2 = false;\n\t\t\t\t\t}\n\t\t\t\t\tFOR(j, ay, by)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (fld[bx][j] != '.') f2 = false;\n\t\t\t\t\t}\n\t\t\t\t\tif (f1 || f2)\n\t\t\t\t\t{\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\tv[i].clear();\n\t\t\t\t\t\tans++;\n\t\t\t\t\t\tfld[ax][ay] = fld[bx][by] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ax < bx)\n\t\t\t\t{\n\t\t\t\t\tbool f1 = true;\n\t\t\t\t\tFOR(j, ay + 1, by+1)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (fld[ax][j] != '.') f1 = false;\n\t\t\t\t\t}\n\t\t\t\t\tFOR(j, ax, bx)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (fld[j][by] != '.') f1 = false;\n\t\t\t\t\t}\n\t\t\t\t\tbool f2 = true;\n\t\t\t\t\tFOR(j, ax+1, bx)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (fld[j][ay] != '.') f2 = false;\n\t\t\t\t\t}\n\t\t\t\t\tFOR(j, ay, by)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (fld[bx][j] != '.') f2 = false;\n\t\t\t\t\t}\n\t\t\t\t\tif (f1 || f2)\n\t\t\t\t\t{\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\tv[i].clear();\n\t\t\t\t\t\tans++;\n\t\t\t\t\t\tfld[ax][ay] = fld[bx][by] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans * 2 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\nconst int NONE = 0;\nconst int VERTICAL = 1;\nconst int HORIZONTAL = 2;\nconst int CORNER = 3;\n\nint main() {\n\tint M, N;\n\tcin >> M >> N;\n\n\tvs field(M);\n\tvvi pos(26, vi(4, -1));\n\tREP(i, M) {\n\t\tcin >> field[i];\n\t\tREP(j, N) {\n\t\t\tif(field[i][j] != '.') {\n\t\t\t\tint k = field[i][j]-'A';\n\t\t\t\tif(pos[k][0] == -1) {\n\t\t\t\t\tpos[k][0] = i;\n\t\t\t\t\tpos[k][1] = j;\n\t\t\t\t} else {\n\t\t\t\t\tpos[k][2] = i;\n\t\t\t\t\tpos[k][3] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvi type(26, CORNER);\n\tREP(i, 26) {\n\t\tif(pos[i][2] == -1) {\n\t\t\ttype[i] = NONE;\n\t\t\tcontinue;\n\t\t}\n\t\tif(abs(pos[i][0]-pos[i][2]+pos[i][1]-pos[i][3]) == 1) {\n\t\t\ttype[i] = NONE;\n\t\t\tcontinue;\n\t\t}\n\t\tif(pos[i][0] == pos[i][2]) {\n\t\t\ttype[i] = VERTICAL;\n\t\t\tcontinue;\n\t\t}\n\t\tif(pos[i][1] == pos[i][3]) {\n\t\t\ttype[i] = HORIZONTAL;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tint ans = 0;\n\tbool updated = true;\n\twhile(updated) {\n\t\tupdated = false;\n\t\tREP(i, 26) {\n\t\t\tif(type[i] == NONE) {\n\t\t\t\n\t\t\t} else if(type[i] == VERTICAL) {\n\t\t\t\tint y = pos[i][0];\n\t\t\t\tFOR(x, min(pos[i][1], pos[i][3])+1, max(pos[i][1], pos[i][3])-1) {\n\t\t\t\t\tif(field[y][x] != '.') {\n\t\t\t\t\t\tgoto next;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans += 2;\n\t\t\t\ttype[i] = NONE;\n\t\t\t\tfield[pos[i][0]][pos[i][1]] = field[pos[i][2]][pos[i][3]] = '.';\n\t\t\t\tupdated = true;\n\t\t\t} else if(type[i] ==  HORIZONTAL) {\n\t\t\t\tint x = pos[i][1];\n\t\t\t\tFOR(y, min(pos[i][0], pos[i][2])+1, max(pos[i][0], pos[i][2])-1) {\n\t\t\t\t\tif(field[y][x] != '.') {\n\t\t\t\t\t\tgoto next;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans += 2;\n\t\t\t\ttype[i] = NONE;\n\t\t\t\tfield[pos[i][0]][pos[i][1]] = field[pos[i][2]][pos[i][3]] = '.';\n\t\t\t\tupdated = true;\n\t\t\t} else if(type[i] == CORNER) {\n\t\t\t\tif(field[pos[i][0]][pos[i][3]] == '.' ||  field[pos[i][2]][pos[i][1]] == '.') {\n\t\t\t\t\tans += 2;\n\t\t\t\t\ttype[i] = NONE;\n\t\t\t\t\tfield[pos[i][0]][pos[i][1]] = field[pos[i][2]][pos[i][3]] = '.';\n\t\t\t\t\tupdated = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnext:;\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nint main(){\n  int N, M;\n  cin >> N >> M;\n  vector<string> field(N);\n  REP(i, N) cin >> field[i];\n  \n  vector<int> rows;\n  vector<int> cols;\n  \n  REP(i, N)REP(j, M){\n    if(isalpha(field[i][j])){\n      rows.push_back(i);\n      cols.push_back(j);\n    }\n  }\n\n  sort(ALL(rows));\n  sort(ALL(cols));\n  rows.erase(unique(ALL(rows)), rows.end());\n  cols.erase(unique(ALL(cols)), cols.end());\n\n  vector<string> board(rows.size(), string(cols.size(), '.'));\n  REP(i, N)REP(j, M){\n    if(isalpha(field[i][j])){\n      int r = lower_bound(ALL(rows), i) - rows.begin();\n      int c = lower_bound(ALL(cols), j) - cols.begin();\n      board[r][c] = field[i][j];\n    }\n  }\n  N = rows.size();\n  M = cols.size();\n  \n  int res = 0;\n  int dx[4] = {0, -1, 0, 1};\n  int dy[4] = {1, 0, -1, 0};\n  bool update = true;\n  while(update){\n    update = false;\n    \n    REP(i, N)REP(j, M){\n      if(board[i][j] == '.'){\n        vector<int> t_row;\n        vector<int> t_col;\n        \n        REP(k, 4){\n          int i2 = i + dx[k];\n          int j2 = j + dy[k];\n          while(0 <= i2 && i2 < N && 0 <= j2 && j2 < M && board[i2][j2] == '.'){\n            i2 += dx[k];\n            j2 += dy[k];\n          }\n          if(0 <= i2 && i2 < N && 0 <= j2 && j2 < M){\n            t_row.push_back(i2);\n            t_col.push_back(j2);\n          }\n        }\n        \n        vector<int> c(26, 0);\n        REP(k, 26){\n          int c = 0;\n          REP(l, t_row.size()){\n            if(board[t_row[l]][t_col[l]] == 'A' + k) c++;\n          }\n          if(c == 2){\n            res += 2;\n            update = true;\n            REP(l, t_row.size()){\n              if(board[t_row[l]][t_col[l]] == 'A' + k){\n                board[t_row[l]][t_col[l]] = '.';\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  cout << res << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\nusing namespace std;\n\nint M, N, K;\nchar S[550][550];\nvector<int> y, x;\nvector<char> c;\nchar s[550][550];\nint dd[5] = { 0, 1, 0, -1, 0 };\n\nint compress(vector<int> &a) {\n  vector<int> v;\n\n  REP(i, 0, a.size()) v.push_back(a[i]);\n  sort(v.begin(), v.end());\n  v.erase(unique(v.begin(), v.end()), v.end());\n  REP(i, 0, a.size()) a[i] = find(v.begin(), v.end(), a[i]) - v.begin();\n\n  return (int) v.size();\n}\n\nbool isin(int y, int x) {\n  return 0 <= y && y < M && 0 <= x && x < N;\n}\n\nint main(void) {\n  cin >> M >> N;\n  K = 0;\n  REP(i, 0, M) REP(j, 0, N) {\n    cin >> S[i][j];\n    if(S[i][j] != '.') {\n      y.push_back(i);\n      x.push_back(j);\n      c.push_back(S[i][j]);\n      K++;\n    }\n  }\n  REP(i, 0, M) REP(j, 0, N) REP(k, 0, 4) if(isin(y[i] + dd[i], x[k] + dd[k + 1])) {\n    y.push_back(y[i] + dd[k]);\n    x.push_back(x[i] + dd[k + 1]);\n  }\n\n  M = compress(y);\n  N = compress(x);\n\n  REP(i, 0, M) REP(j, 0, N) s[i][j] = '.';\n  REP(i, 0, K) s[y[i]][x[i]] = c[i];\n\n  int ans = 0;\n  bool visited[256];\n  REP(i, 0, 256) visited[i] = false;\n  bool f = true;\n  while(f) {\n    f = false;\n    REP(i, 0, M) REP(j, 0, N) {\n      if(s[i][j] == '.' || visited[s[i][j]]) {\n        int cnt[256];\n        REP(k, 0, 256) cnt[k] = 0;\n        REP(k, 0, 4) {\n          int ny = i + dd[k], nx = j + dd[k + 1];\n          while(isin(ny, nx)) {\n            if(s[ny][nx] != '.' && !visited[s[ny][nx]]) {\n              cnt[s[ny][nx]]++;\n              if(cnt[s[ny][nx]] == 2) {\n                visited[s[ny][nx]] = true;\n                ans += 2;\n                f = true;\n              }\n              break;\n            }\n            ny += dd[k];\n            nx += dd[k + 1];\n          }\n        }\n      }\n    }\n  }\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mk make_pair\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nstring s[500];\nint h,w,sum=0;\nvector<int>x,y;\nvoid del(int t1,int t2){\n  vector<pair<char,pair<int,int> > >p;\n  for(int i=t1;i<h;i++)if(s[i][t2]!='.'){\n    p.push_back(mk(s[i][t2],mk(i,t2)));\n    break;\n  }\n  for(int i=t1;i>=0;i--)if(s[i][t2]!='.'){\n    p.push_back(mk(s[i][t2],mk(i,t2)));\n    break;\n  }\n  for(int i=t2;i<w;i++)if(s[t1][i]!='.'){\n    p.push_back(mk(s[t1][i],mk(t1,i)));\n    break;\n  }\n  for(int i=t2;i>=0;i--)if(s[t1][i]!='.'){\n    p.push_back(mk(s[t1][i],mk(t1,i)));\n    break;\n  }\n  sort(p.begin(),p.end());\n  if(p.size()>=2){\n    r(i,p.size()-1){\n      if(p[i].first==p[i+1].first){\n        sum++;\n        s[p[i].second.first][p[i].second.second]='.';\n        s[p[i+1].second.first][p[i+1].second.second]='.';\n      }\n    }\n  }\n}\nint main(){\n  cin>>h>>w;\n  r(i,h)cin>>s[i];\n  r(i,h)r(j,w)if(s[i][j]!='.'){\n      y.push_back(i),x.push_back(j);\n      if(i+1<h)y.push_back(i+1);\n      if(j+1<w)x.push_back(j+1);\n    }\n  r(k,7)r(i,y.size())r(j,x.size())\n    if(s[y[i]][x[j]]=='.')del(y[i],x[j]);\n  cout<<sum*2<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <tuple>\n\nint main() {\n  size_t M, N;\n  scanf(\"%zu %zu\", &M, &N);\n\n  std::vector<std::string> C(M);\n  std::vector<std::vector<std::pair<size_t, size_t>>> pos(26);\n  int alph = 1 << 27;\n  for (size_t i = 0; i < M; ++i) {\n    char buf[512];\n    scanf(\"%s\", buf);\n    C[i] = buf;\n    for (size_t j = 0; j < N; ++j) {\n      if (C[i][j] != '.') {\n        int a = C[i][j] - 'A';\n        pos[a].emplace_back(i, j);\n        alph |= 1 << a;\n      }\n    }\n  }\n\n  std::vector<std::vector<int>> flags(26);\n  for (size_t k = 0; k < 26; ++k) {\n    if (pos[k].empty()) {\n      flags[k] = {1 << 27};\n      continue;\n    }\n    size_t imax, imin, jmax, jmin;\n    std::tie(imin, imax) = std::minmax(pos[k][0].first, pos[k][1].first);\n    std::tie(jmin, jmax) = std::minmax(pos[k][0].second, pos[k][1].second);\n    size_t di = imax - imin;\n    size_t dj = jmax - jmin;\n\n    if (di + dj == 1) {\n      flags[k] = {1 << 27};\n      continue;\n    }\n\n    if (imax == imin) {\n      int f = 0;\n      for (size_t j = jmin+1; j < jmax; ++j) {\n        if (C[imin][j] != '.')\n          f |= 1 << (C[imin][j] - 'A');\n      }\n      flags[k].push_back(f);\n    } else if (jmax == jmin) {\n      int f = 0;\n      for (size_t i = imin+1; i < imax; ++i) {\n        if (C[i][jmin] != '.')\n          f |= 1 << (C[i][jmin] - 'A');\n      }\n      flags[k].push_back(f);\n    } else {\n      int f0 = 0;\n      int f1 = 0;\n      int f2 = 0;\n      int f3 = 0;\n\n      for (size_t j = jmin+1; j < jmax; ++j) {\n        if (C[imin][j] != '.') f0 |= 1 << (C[imin][j] - 'A');\n        if (C[imax][j] != '.') f1 |= 1 << (C[imax][j] - 'A');\n      }\n      for (size_t i = imin+1; i < imax; ++i) {\n        if (C[i][jmin] != '.') f2 |= 1 << (C[i][jmin] - 'A');\n        if (C[i][jmax] != '.') f3 |= 1 << (C[i][jmax] - 'A');\n      }\n\n      if (pos[k][0].second < pos[k][1].second) {\n        flags[k] = {f0|f3, f1|f2};\n        if (C[imin][jmax] != '.') flags[k][0] |= 1 << (C[imin][jmax] - 'A');\n        if (C[imax][jmin] != '.') flags[k][1] |= 1 << (C[imax][jmin] - 'A');\n      } else {\n        flags[k] = {f0|f2, f1|f3};\n        if (C[imin][jmin] != '.') flags[k][0] |= 1 << (C[imin][jmin] - 'A');\n        if (C[imax][jmax] != '.') flags[k][1] |= 1 << (C[imax][jmax] - 'A');\n      }\n    }\n  }\n\n  // for (int i = 0; i < 26; ++i) {\n  //   for (auto& fs: flags[i]) {\n  //     fprintf(stderr, \"%c:\", 'A'+i);\n  //     for (int j = 0; j < 26; ++j) {\n  //       if (fs >> j & 1)\n  //         fprintf(stderr, \" %c\", 'A'+j);\n  //     }\n  //     fprintf(stderr, \"\\n\");\n  //   }\n  // }\n\n  int res = 0;\n  for (int i = 0; i < 26; ++i) {\n    for (int j = 0; j < 26; ++j) {\n      if (!(alph >> j & 1)) continue;\n      for (int rm: flags[j]) {\n        if (rm & alph) continue;\n        alph ^= 1 << j;\n        // fprintf(stderr, \"Removed %c\\n\", 'A'+j);\n        res += 2;\n        flags[j].clear();\n        break;\n      }\n    }\n  }\n\n  printf(\"%d\\n\", res);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define SZ(x) (int)(x.size())\n#define REP(i, n) for(int i=0;i<(n);++i)\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RREP(i, n) for(int i=(int)(n)-1;i>=0;--i)\n#define RFOR(i, a, b) for(int i=(int)(b)-1;i>=(a);--i)\n#define ALL(a) a.begin(),a.end()\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define DEBUG(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<< endl;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\nconst double eps = 1e-8;\nconst ll MOD = 1000000007;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\ntemplate <typename T1, typename T2>\nbool chmax(T1 &a, const T2 &b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate <typename T1, typename T2>\nbool chmin(T1 &a, const T2 &b) {\n    if (a > b) { a = b; return true; }\n    return false;\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> &p) {\n    os << p.first << \":\" << p.second;\n    return os;\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const map<T1, T2> &mp) {\n    os << \"{\";\n    int a = 0;\n    for (auto &tp : mp) {\n        if (a) os << \", \"; a = 1;\n        os << tp;\n    }\n    return os << \"}\";\n}\ntemplate<typename T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n\n    int M, N; cin >> M >> N;\n    vector<string> C(M);\n    REP(i, M) {\n        cin >> C[i];\n    }\n\n    int ans = 0;\n    for (bool updated = true; updated;) {\n        updated = false;\n        REP(c, 26) {\n            vector<P> ps;\n            REP(i, M) REP(j, N) if (C[i][j] == c + 'A') ps.emplace_back(i, j);\n            if (ps.size() == 0) continue;\n            int si, sj, ti, tj;\n            tie(si, sj) = ps[0], tie(ti, tj) = ps[1];\n\n            bool valid = true;\n            if (si == ti) {\n                if (abs(sj - tj) == 1) valid = false;\n                FOR(j, min(sj, tj)+1, max(sj, tj)) {\n                    if (C[si][j] != '.') valid = false;\n                }\n            }\n            else if (sj == tj) {\n                if (abs(si - ti) == 1) valid = false;\n                FOR(i, min(si, ti)+1, max(si, ti)) {\n                    if (C[i][sj] != '.') valid = false;\n                }\n            }\n            else {\n                valid = false;\n                {\n                    bool v = true;\n                    if (C[si][tj] != '.') v = false;\n                    FOR(i, min(si, ti) + 1, max(si, ti)) {\n                        if (C[i][tj] != '.') v = false;\n                    }\n                    FOR(j, min(sj, tj) + 1, max(sj, tj)) {\n                        if (C[si][j] != '.') v = false;\n                    }\n                    if (v) valid = true;\n                }\n                {\n                    bool v = true;\n                    if (C[ti][sj] != '.') v = false;\n                    FOR(i, min(si, ti) + 1, max(si, ti)) {\n                        if (C[i][sj] != '.') v = false;\n                    }\n                    FOR(j, min(sj, tj) + 1, max(sj, tj)) {\n                        if (C[ti][j] != '.') v = false;\n                    }\n                    if (v) valid = true;\n                }\n            }\n            if (valid) {\n                C[si][sj] = C[ti][tj] = '.';\n                updated = true;\n                ans += 2;\n                break;\n            }\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> dy = {1, 0, -1, 0};\nvector<int> dx = {0, 1, 0, -1};\nint main(){\n  int M, N;\n  cin >> M >> N;\n  vector<vector<char>> C(M + 2, vector<char>(N + 2, '#'));\n  for (int i = 1; i <= M; i++){\n    for (int j = 1; j <= N; j++){\n      cin >> C[i][j];\n    }\n  }\n  vector<vector<pair<int, int>>> P(26);\n  for (int i = 1; i <= M; i++){\n    for (int j = 1; j <= N; j++){\n      if (C[i][j] != '.'){\n        P[C[i][j] - 'A'].push_back(make_pair(i, j));\n      }\n    }\n  }\n  vector<pair<int, int>> S;\n  for (int i = 0; i < 26; i++){\n    if (!P[i].empty()){\n      int y1 = P[i][0].first;\n      int x1 = P[i][0].second;\n      int y2 = P[i][1].first;\n      int x2 = P[i][1].second;\n      if (y1 == y2){\n        if (abs(x2 - x1) >= 2){\n          S.push_back(make_pair(y1, (x1 + x2) / 2));\n        }\n      } else if (x1 == x2){\n        if (abs(y2 - y1) >= 2){\n          S.push_back(make_pair((y1 + y2) / 2, x1));\n        }\n      } else {\n        S.push_back(make_pair(y1, x2));\n        S.push_back(make_pair(y2, x1));\n      }\n    }\n  }\n  vector<bool> c(26, true);\n  for (int i = 0; i < 26; i++){\n    if (P[i].empty()){\n      c[i] = false;\n    }\n  }\n  int ans = 0;\n  for (int i = 0; i < 26; i++){\n    int cnt = S.size();\n    for (int j = 0; j < cnt; j++){\n      if (C[S[j].first][S[j].second] == '.'){\n        vector<int> cnt2(26, 0);\n        for (int k = 0; k < 4; k++){\n          int y = S[j].first;\n          int x = S[j].second;\n          while (C[y][x] == '.'){\n            y += dy[k];\n            x += dx[k];\n          }\n          if (C[y][x] != '#'){\n            cnt2[C[y][x] - 'A']++;\n          }\n        }\n        for (int k = 0; k < 26; k++){\n          if (cnt2[k] == 2){\n            c[k] = false;\n            ans += 2;\n            for (int l = 0; l < 2; l++){\n              C[P[k][l].first][P[k][l].second] = '.';\n            }\n          }\n        }\n      }\n    }\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint M, N;\n\tcin >> M >> N;\n\tvector<string> C(M);\n\tvector<vector<pair<int, int>>> pos(26);\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> C[i];\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (C[i][j] != '.') {\n\t\t\t\tpos[C[i][j] - 'A'].emplace_back(i, j);\n\t\t\t}\n\t\t}\n\t}\n\tint res = 0;\n\twhile (true) {\n\t\tint val = -1;\n\t\tfor (int i = 0; i < 26; i++) if (!pos[i].empty()) {\n\t\t\tint x0 = pos[i][0].first, x1 = pos[i][1].first, y0 = pos[i][0].second, y1 = pos[i][1].second;\n\t\t\tif (x0 == x1) {\n\t\t\t\tif (y0 > y1) swap(y0, y1);\n\t\t\t\tbool ok = y1 - y0 > 1;\n\t\t\t\tfor (int j = y0 + 1; j < y1; j++) {\n\t\t\t\t\tif (C[x0][j] != '.') {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok) {\n\t\t\t\t\tval = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (y0 == y1) {\n\t\t\t\tif (x0 > x1) swap(x0, x1);\n\t\t\t\tbool ok = x1 - x0 > 1;\n\t\t\t\tfor (int j = x0 + 1; j < x1; j++) {\n\t\t\t\t\tif (C[j][y0] != '.') {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok) {\n\t\t\t\t\tval = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbool ok = true;\n\t\t\t\tfor (int j = min(x0, x1) + 1; j < max(x0, x1); j++) {\n\t\t\t\t\tif (C[j][y0] != '.') {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (C[x1][y0] != '.') ok = false;\n\t\t\t\tfor (int j = min(y0, y1) + 1; j < max(y0, y1); j++) {\n\t\t\t\t\tif (C[x1][j] != '.') {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok) {\n\t\t\t\t\tval = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tok = true;\n\t\t\t\tfor (int j = min(y0, y1) + 1; j < max(y0, y1); j++) {\n\t\t\t\t\tif (C[x0][j] != '.') {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (C[x0][y1] != '.') ok = false;\n\t\t\t\tfor (int j = min(x0, x1) + 1; j < max(x0, x1); j++) {\n\t\t\t\t\tif (C[j][y1] != '.') {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok) {\n\t\t\t\t\tval = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (val == -1) break;\n\t\tres += 2;\n\t\tfor (auto p : pos[val]) {\n\t\t\tC[p.first][p.second] = '.';\n\t\t}\n\t\tpos[val].clear();\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\ntypedef pair<int, int>P;\nchar mp[500][500];\nvector<P>pos[26];\nint flg[26];\nint ue[26][2];\n\nint main(){\n    int H, W;\n    cin >> H >> W;\n    for(int y = 0; y < H; y++){\n        for(int x = 0; x < W; x++){\n            cin >> mp[y][x];\n            if(mp[y][x] != '.'){\n                flg[mp[y][x] - 'A'] = 1;\n                pos[mp[y][x] - 'A'].push_back(P(x, y));\n            }\n        }\n    }\n    for(int i = 0; i < 26; i++){\n        if(flg[i] == 0)continue;\n        if(abs(pos[i][0].first - pos[i][1].first) + abs(pos[i][0].second - pos[i][1].second) == 1){\n            flg[i] = 0;\n            continue;\n        }\n        int x2 = pos[i][1].first;\n        int y2 = pos[i][1].second;\n        int x = pos[i][0].first;\n        int y = pos[i][0].second;\n        while(x != x2){\n            if(x < x2)x++;\n            else if(x > x2)x--;\n            if(mp[y][x] != '.' && mp[y][x] != 'A' + i){\n                ue[i][0] |= (1 << (mp[y][x] - 'A'));\n            }\n        }\n        while(y != y2){\n            if(y < y2)y++;\n            else if(y > y2)y--;\n            if(mp[y][x] != '.' && mp[y][x] != 'A' + i){\n                ue[i][0] |= (1 << (mp[y][x] - 'A'));\n            }\n        }\n        x = pos[i][0].first;\n        y = pos[i][0].second;\n        while(y != y2){\n            if(y < y2)y++;\n            else if(y > y2)y--;\n            if(mp[y][x] != '.' && mp[y][x] != 'A' + i){\n                ue[i][1] |= (1 << (mp[y][x] - 'A'));\n            }\n        }\n        while(x != x2){\n            if(x < x2)x++;\n            else if(x > x2)x--;\n            if(mp[y][x] != '.' && mp[y][x] != 'A' + i){\n                ue[i][1] |= (1 << (mp[y][x] - 'A'));\n            }\n        }\n    }\n    int ans = 0;\n    int state = 0;\n    for(int f = 1; f;){\n        f = 0;\n        for(int i = 0; i < 26; i++){\n            for(int j = 0; j < 2; j++){\n                if(flg[i] == 0)continue;\n                if(state & (1 << i))continue;\n                if((state & (ue[i][j])) == ue[i][j]){\n                    ans+=2;\n                    state |= (1 << i);\n                    f = 1;\n                }\n            }\n        }    \n    }\n\n\n    cout << ans << endl;\n\n    \n    return 0;    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mk make_pair\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nstring s[500];\nint h,w,sum=0;\nvector<int>x,y;\nvoid del(int t1,int t2){\n  vector<pair<char,pair<int,int> > >p;\n  for(int i=t1;i<h;i++)if(s[i][t2]!='.'){\n    p.push_back(mk(s[i][t2],mk(i,t2)));\n    break;\n  }\n  for(int i=t1;i>=0;i--)if(s[i][t2]!='.'){\n    p.push_back(mk(s[i][t2],mk(i,t2)));\n    break;\n  }\n  for(int i=t2;i<w;i++)if(s[t1][i]!='.'){\n    p.push_back(mk(s[t1][i],mk(t1,i)));\n    break;\n  }\n  for(int i=t2;i>=0;i--)if(s[t1][i]!='.'){\n    p.push_back(mk(s[t1][i],mk(t1,i)));\n    break;\n  }\n  sort(p.begin(),p.end());\n  if(p.size()>=2){\n    r(i,p.size()-1){\n      if(p[i].first==p[i+1].first){\n        sum++;\n        s[p[i].second.first][p[i].second.second]='.';\n        s[p[i+1].second.first][p[i+1].second.second]='.';\n      }\n    }\n  }\n}\nint main(){\n  cin>>h>>w;\n  r(i,h)cin>>s[i];\n  r(i,h)r(j,w)if(s[i][j]!='.'){\n      y.push_back(i),x.push_back(j);\n      if(i+1<h)y.push_back(i+1);\n    }\n  r(k,26)r(i,y.size())r(j,x.size())\n    if(s[y[i]][x[j]]=='.')del(y[i],x[j]);\n  cout<<sum*2<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<stdlib.h>\n#include<map>\nusing namespace std;\ntypedef pair<int,int> P;\n#define Y first\n#define X second\nint main(){\n  int m,n;\n  cin >> m >> n;\n  string st[600];\n  int i,j,k;\n  for(i=0;i<m;i++) cin >> st[i];\n  bool alp[26]={};\n  vector<P> v[26];\n  P p;\n  for(i=0;i<m;i++){\n    for(j=0;j<n;j++){\n      if(st[i][j]!='.') {\n\talp[st[i][j]-'A']=true;\n\tp.Y=i;p.X=j;\n\tv[st[i][j]-'A'].push_back(p);\n      }\n    }\n  }\n  //cout << \"x\" << endl;\n  bool f=true,e;\n  int ans=0;\n  while(f){\n    f=false;\n    for(k=0;k<26;k++){\n      if(!alp[k]) continue;\n      if(v[k][0].X==v[k][1].X){\n\tif(abs(v[k][0].Y-v[k][1].Y)<2) continue;\n\te=true;\n\tfor(i=min(v[k][0].Y,v[k][1].Y)+1;i<max(v[k][0].Y,v[k][1].Y);i++){\n\t  if(st[i][v[k][0].X]!='.') e=false;\n\t}\n\tif(e){\n\t  st[v[k][0].Y][v[k][0].X]='.';\n\t  st[v[k][1].Y][v[k][1].X]='.';\n\t  alp[k]=false;\n\t  ans++;f=true;\n\t  break;\n\t}\n      }else if(v[k][0].Y==v[k][1].Y){\n\tif(abs(v[k][0].X-v[k][1].X)<2) continue;\n\te=true;\n\tfor(i=min(v[k][0].X,v[k][1].X)+1;i<max(v[k][0].X,v[k][1].X);i++){\n\t  if(st[v[k][0].Y][i]!='.') e=false;\n\t}\n\tif(e){\n\t  st[v[k][0].Y][v[k][0].X]='.';\n\t  st[v[k][1].Y][v[k][1].X]='.';\n\t  alp[k]=false;\n\t  ans++;f=true;\n\t  break;\n\t}\n      }else if((v[k][0].X-v[k][1].X)*(v[k][0].Y-v[k][1].Y)>0){\n\tif(v[k][0].X>v[k][1].X) swap(v[k][0],v[k][1]);\n\te=true;\n\tfor(i=v[k][0].X+1;i<=v[k][1].X;i++){\n\t  if(st[v[k][0].Y][i]!='.') e=false;\n\t}\n\tfor(i=v[k][0].Y;i<v[k][1].Y;i++){\n\t  if(st[i][v[k][1].X]!='.') e=false;\n\t}\n\tif(e){\n\t  st[v[k][0].Y][v[k][0].X]='.';\n\t  st[v[k][1].Y][v[k][1].X]='.';\n\t  alp[k]=false;\n\t  ans++;f=true;\n\t  break;\n\t}\n\te=true;\n\tfor(i=v[k][0].Y+1;i<=v[k][1].Y;i++){\n\t  if(st[i][v[k][0].X]!='.') e=false;\n\t}\n\tfor(i=v[k][0].X;i<v[k][1].X;i++){\n\t  if(st[v[k][1].Y][i]!='.') e=false;\n\t}\n\tif(e){\n\t  st[v[k][0].Y][v[k][0].X]='.';\n\t  st[v[k][1].Y][v[k][1].X]='.';\n\t  alp[k]=false;\n\t  ans++;f=true;\n\t  break;\n\t}\n      }else{\n\tif(v[k][0].X>v[k][1].X) swap(v[k][0],v[k][1]);\n\te=true;\n\tfor(i=v[k][0].X+1;i<=v[k][1].X;i++){\n\t  if(st[v[k][0].Y][i]!='.') e=false;\n\t}\n\tfor(i=v[k][0].Y;i>v[k][1].Y;i--){\n\t  if(st[i][v[k][1].X]!='.') e=false;\n\t}\n\tif(e){\n\t  st[v[k][0].Y][v[k][0].X]='.';\n\t  st[v[k][1].Y][v[k][1].X]='.';\n\t  alp[k]=false;\n\t  ans++;f=true;\n\t  break;\n\t}\n\te=true;\n\tfor(i=v[k][0].Y-1;i>=v[k][1].Y;i--){\n\t  if(st[i][v[k][0].X]!='.') e=false;\n\t}\n\tfor(i=v[k][0].X;i<v[k][1].X;i++){\n\t  if(st[v[k][1].Y][i]!='.') e=false;\n\t}\n\tif(e){\n\t  st[v[k][0].Y][v[k][0].X]='.';\n\t  st[v[k][1].Y][v[k][1].X]='.';\n\t  alp[k]=false;\n\t  ans++;f=true;\n\t  break;\n\t}\n      }\n    }\n    //for(i=0;i<m;i++) cout << st[i] << endl; cout << endl;\n  }\n  //for(i=0;i<m;i++) cout << st[i] << endl;\n  cout << ans*2 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <tuple>\n#include <algorithm>\nusing namespace std;\nusing T=tuple<int,int,char>;\nint main(){\n    int M,N;\n    cin>>M>>N;\n    vector<T> V;\n    for(int i=0;i<M;i++){\n        for(int j=0;j<N;j++){\n            char c;\n            cin>>c;\n            if(c!='.'){\n                V.emplace_back(j,i,c);\n            }\n        }\n    }\n    if(V.empty()){\n        cout<<0<<endl;\n        return 0;\n    }\n    vector<int> X,Y;\n    for(auto t:V){\n        int x,y;\n        tie(x,y,ignore)=t;\n        X.emplace_back(x);\n        Y.emplace_back(y);\n        sort(X.begin(), X.end());\n        sort(Y.begin(), Y.end());\n    }\n    X.erase(unique(X.begin(), X.end()),X.end());\n    vector<int> XX;\n    XX.push_back(X[0]);\n    for(int i=1;i<X.size();i++){\n        if(X[i-1]+1!=X[i]){\n            XX.push_back(X[i-1]+1);\n        }\n        XX.push_back(X[i]);\n    }\n    swap(X,XX);\n    Y.erase(unique(Y.begin(), Y.end()),Y.end());\n    vector<int> YY;\n    YY.push_back(Y[0]);\n    for(int i=1;i<Y.size();i++){\n        if(Y[i-1]+1!=Y[i]){\n            YY.push_back(Y[i-1]+1);\n        }\n        YY.push_back(Y[i]);\n    }\n    swap(Y,YY);\n    int x_max=X.size()-1;\n    int y_max=Y.size()-1;\n    char board[Y.size()][X.size()];//y,x\n    for(int i=0;i<=y_max;i++){\n        for(int j=0;j<=x_max;j++){\n            board[i][j]='.';\n        }\n    }\n    for(auto &t:V){\n        int x,y; char c;\n        tie(x,y,c)=t;\n        x=lower_bound(X.begin(), X.end(),x)-X.begin();\n        y=lower_bound(Y.begin(), Y.end(),y)-Y.begin();\n        board[y][x]=c;\n    }\n    /*\n    for(int i=0;i<=y_max;i++){\n        for(int j=0;j<=x_max;j++){\n            cout<<board[i][j];\n        }\n        cout<<endl;\n    }*/\n    bool updated=true;\n    int ans=0;\n    while(updated){\n        updated=false;\n        for(int y=0;y<=y_max;y++){\n            for(int x=0;x<=x_max;x++){\n                if(board[y][x]!='.') continue;\n                char up='u',down='d',left='l',right='r';\n                int upd,downd,leftd,rightd;\n                for(int d=1;x+d<=x_max;d++){\n                    if(board[y][x+d]!='.'){\n                        right=board[y][x+d];\n                        rightd=d;\n                        break;\n                    }\n                }\n                for(int d=-1;0<=x+d;d--){\n                    if(board[y][x+d]!='.'){\n                        left=board[y][x+d];\n                        leftd=d;\n                        break;\n                    }\n                }\n                for(int d=1;y+d<=y_max;d++){\n                    if(board[y+d][x]!='.'){\n                        down=board[y+d][x];\n                        downd=d;\n                        break;\n                    }\n                }\n                for(int d=-1;0<=y+d;d--){\n                    if(board[y+d][x]!='.'){\n                        up=board[y+d][x];\n                        upd=d;\n                        break;\n                    }\n                }\n                if(up==down){\n                    board[y+upd][x]=board[y+downd][x]='.';\n                    ans+=2;\n                    updated=true;\n                }\n                if(up==left){\n                    board[y+upd][x]=board[y][x+leftd]='.';\n                    ans+=2;\n                    updated=true;\n                }\n                if(up==right){\n                    board[y+upd][x]=board[y][x+rightd]='.';\n                    ans+=2;\n                    updated=true;\n                }\n                if(down==left){\n                    board[y+downd][x]=board[y][x+leftd]='.';\n                    ans+=2;\n                    updated=true;\n                }\n                if(down==right){\n                    board[y+downd][x]=board[y][x+rightd]='.';\n                    ans+=2;\n                    updated=true;\n                }\n                if(left==right){\n                    board[y][x+leftd]=board[y][x+rightd]='.';\n                    ans+=2;\n                    updated=true;\n                }\n            }\n        }\n    }\n    cout<<ans<<endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<ll(n);++i)\n#define RREP(i,n) for(ll i=ll(n)-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<ll(n);++i)\n#define RFOR(i,m,n) for(ll i=ll(n)-1;i>=ll(m);--i)\n#define ALL(v) (v).begin(),(v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconstexpr int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconstexpr int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vvi = vector<vi>;\nusing vvl = vector<vl>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\ntemplate <class T> bool chmin(T& a, const T& b) { if (a > b) { a = b; return true; } return false; }\ntemplate <class T> bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; } return false; }\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n, m;\n\tcin >> n >> m;\n\tvector<string> v(n);\n\tREP(i, n)cin >> v[i];\n\tvector <vector<pii>> pos(26);\n\tREP(i, n)REP(j, m) {\n\t\tif (isalpha(v[i][j])) {\n\t\t\tpos[v[i][j] - 'A'].push_back({ i,j });\n\t\t}\n\t}\n\n\tvi b(26, 0);\n\tauto f = [&](int x, int y) {\n\t\treturn v[x][y] != '.' && b[v[x][y] - 'A'] == 0;\n\t};\n\tint cnt = 0;\n\twhile (1) {\n\t\tbool updated = false;\n\t\tREP(i, 26) {\n\t\t\tif (b[i] || pos[i].empty())continue;\n\t\t\tint x1 = pos[i][0].first, y1 = pos[i][0].second,\n\t\t\t\tx2 = pos[i][1].first, y2 = pos[i][1].second;\n\t\t\tbool ok = true;\n\t\t\tif (x1 == x2) {\n\t\t\t\tif (abs(y1 - y2) == 1)continue;\n\n\t\t\t\tFOR(i, min(y1, y2) + 1, max(y1, y2)) {\n\t\t\t\t\tif (f(x1, i))ok = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (y1 == y2) {\n\t\t\t\tif (abs(x1 - x2) == 1)continue;\n\t\t\t\tFOR(i, min(x1, x2) + 1, max(x1, x2)) {\n\t\t\t\t\tif (f(i, y1))ok = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (x1 > x2) {\n\t\t\t\t\tswap(x1, x2);\n\t\t\t\t\tswap(y1, y2);\n\t\t\t\t}\n\t\t\t\tok = false;\n\t\t\t\tbool flag = true;\n\t\t\t\tFOR(i, x1 + 1, x2) {\n\t\t\t\t\tif (f(i, y1))flag = false;\n\t\t\t\t}\n\t\t\t\tFOR(i, min(y1, y2) + 1, max(y1, y2)) {\n\t\t\t\t\tif (f(x2, i))flag = false;\n\t\t\t\t}\n\t\t\t\tif (f(x2, y1))flag = false;\n\t\t\t\tif (flag)ok = true;\n\t\t\t\tflag = true;\n\t\t\t\tFOR(i, x1 + 1, x2) {\n\t\t\t\t\tif (f(i, y2))flag = false;\n\t\t\t\t}\n\t\t\t\tFOR(i, min(y1, y2) + 1, max(y1, y2)) {\n\t\t\t\t\tif (f(x1, i))flag = false;\n\t\t\t\t}\n\t\t\t\tif (f(x1, y2))flag = false;\n\t\t\t\tif (flag)ok = true;\n\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tupdated = true;\n\t\t\t\tb[i] = 1;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tif (!updated)break;\n\n\t}\n\tcout << 2 * cnt << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst vector<int> dir = { 0, 1, 0, -1 };\nint H, W;\nint main() {\n\tcin >> H >> W;\n\tvector<string> s(H);\n\tvector<int> cx, cy;\n\tfor (int i = 0; i < H; i++) {\n\t\tcin >> s[i];\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (s[i][j] != '.') {\n\t\t\t\tcx.push_back(j);\n\t\t\t\tcy.push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tsort(cx.begin(), cx.end());\n\tcx.erase(unique(cx.begin(), cx.end()), cx.end());\n\tint rx = cx.size();\n\tfor (int i = 1; i < rx; i++) {\n\t\tif (cx[i] - cx[i - 1] >= 2) cx.push_back(cx[i - 1] + 1);\n\t}\n\tsort(cx.begin(), cx.end());\n\tsort(cy.begin(), cy.end());\n\tcy.erase(unique(cy.begin(), cy.end()), cy.end());\n\tint ry = cy.size();\n\tfor (int i = 1; i < ry; i++) {\n\t\tif (cy[i] - cy[i - 1] >= 2) cy.push_back(cy[i - 1] + 1);\n\t}\n\tsort(cy.begin(), cy.end());\n\tH = cy.size(), W = cx.size();\n\tvector<string> t(H, string(W, '.'));\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (s[cy[i]][cx[j]] != '.') t[i][j] = s[cy[i]][cx[j]];\n\t\t}\n\t}\n\tint ret = 0;\n\twhile (true) {\n\t\tbool flag = false;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (t[i][j] != '.') continue;\n\t\t\t\tvector<vector<pair<int, int> > > d(26);\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tint tx = j, ty = i;\n\t\t\t\t\twhile (0 <= tx && tx < W && 0 <= ty && ty < H) {\n\t\t\t\t\t\tif (t[ty][tx] != '.') {\n\t\t\t\t\t\t\td[t[ty][tx] - 65].push_back(make_pair(tx, ty));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttx += dir[k];\n\t\t\t\t\t\tty += dir[k ^ 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int k = 0; k < 26; k++) {\n\t\t\t\t\tif (d[k].size() == 2) {\n\t\t\t\t\t\tflag = true; ret += 2;\n\t\t\t\t\t\tt[d[k][0].second][d[k][0].first] = '.';\n\t\t\t\t\t\tt[d[k][1].second][d[k][1].first] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!flag) break;\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<VV> VVV;\ntypedef vector<vector<int>> Graph;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\nenum { X, Y, CHAR };\ntypedef vector<int> Tile;\n\nint H, W;\nvector<string> s;\n\n// N, E, S, W\nconst int dx[4] = {-1, 0,  1,  0};\nconst int dy[4] = { 0, 1,  0, -1};\n\ninline bool inside(int x, int y) {\n    return 0 <= x && x < H && 0 <= y && y < W;\n}\n\nTile findNearestTile(int x, int y, int k) {\n    if (!inside(x, y)) return Tile{-1, -1, -1};\n    if (isalpha(s[x][y])) return Tile{x, y, s[x][y] - 'A'};\n    return findNearestTile(x + dx[k], y + dy[k], k);\n}\n\nbool hit(int sx, int sy) {\n    if (isalpha(s[sx][sy])) {\n        rep(k, 4) {\n            int nx = sx + dx[k], ny = sy + dy[k];\n            if (!inside(nx, ny)) continue;\n            if (s[sx][sy] == s[nx][ny]) {\n                // cerr << \"hey!\" << endl;\n                // cerr << sx << \" \" << sy << \" \" << nx << \" \" << ny << endl;\n                s[sx][sy] = '.';\n                s[nx][ny] = '.';\n                return true;\n            }\n        }\n        return false;\n    }\n\n    // cout << \"hit: \" << sx << \" \" << sy << endl;\n    rep(start, 4) {\n        Tile tile1{-1, -1, -1};\n        rep(k, 4) {\n            // cout << start << \" \" << k << endl;\n            Tile tile2 = findNearestTile(sx, sy, (k + start) % 4);\n            if (tile2[CHAR] == -1) {\n                continue;\n            } else if (tile1[CHAR] == -1) {\n                tile1 = tile2;\n            } else if (tile1[CHAR] == tile2[CHAR]) {\n                // cout << sx << \" \" << sy << endl;\n                // cout << start << \" \" << k << endl;\n                // cout << tile1[X] << \" \" << tile1[Y] << \" \" << tile1[CHAR] << endl;\n                // cout << tile2[X] << \" \" << tile2[Y] << \" \" << tile2[CHAR] << endl;\n                s[tile1[X]][tile1[Y]] = '.';\n                s[tile2[X]][tile2[Y]] = '.';\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nbool search() {\n    rep(i, H) {\n        rep(j, W) {\n            if (hit(i, j)) {\n                // cout << \"hit\" << endl;\n                // cout << i << \" \" << j << endl;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nbool checkCompress(string line) {\n    for (const auto& c : line) {\n        if (c != '.') return false;\n    }\n    return true;\n}\n\nvoid compress(vector<string> &s) {\n    for (int i = 0; i < s.size(); ) {\n        if (checkCompress(s[i])) {\n            s.erase(s.begin() + i);\n        } else {\n            i++;\n        }\n    }\n}\n\nvoid rot(vector<string> &s) {\n    vector<string> t(s[0].size(), \"\");\n    rep(i, s.size()) rep(j, s[0].size()) {\n        t[j] += s[i][j];\n    }\n    s = t;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    cin >> H >> W;\n    s.resize(H);\n    rep(i, H) cin >> s[i];\n\n    rep(x, H) {\n        rep(y, W) {\n            rep(k, 4) {\n                int nx = x + dx[k], ny = y + dy[k];\n                if (!inside(nx, ny)) continue;\n                if (isalpha(s[x][y]) && s[x][y] == s[nx][ny]) {\n                    s[x][y] = '#';\n                    s[nx][ny] = '#';\n                }\n            }\n        }\n    }\n\n    compress(s);\n    // for (auto line : s) cout << line << endl;\n    // cout << endl;\n\n    if (s.empty()) {\n        cout << 0 << endl;\n        return 0;\n    }\n    rot(s);\n    // // for (auto line : s) cout << line << endl;\n    // // cout << endl;\n    compress(s);\n    // // for (auto line : s) cout << line << endl;\n    // // cout << endl;\n    rot(s);\n    // // for (auto line : s) cout << line << endl;\n    // // cout << endl;\n\n    H = s.size(), W = s[0].size();\n\n    int ans = 0;\n    while (search()) {\n        ans += 2;\n\n        // cout << ans << endl;\n        // rep(i, H) {\n        //     cout << s[i] << endl;\n        // }\n        // cout << endl;\n    }\n\n    cout << ans << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\nstring mps[501];\npair<int,int> tile1[26];\npair<int,int> tile2[26];\nint m,n;\n\nbool inter(int i,int j,int k) {\n    if(j == k && i != j) return false;\n    if(j > k) swap(j,k);\n\n    return (j <= i) && (i <= k);\n}\n\nint iabs(int i) {\n    if(i < 0) return -i;\n    return i;\n}\n\nbool ok(int idx,int x1,int y1,int x2,int y2) {\n    // adj\n    if(x1 == x2 && iabs(y1-y2) == 1) return false;\n    if(y1 == y2 && iabs(x1-x2) == 1) return false;\n\n    for(int i=0; i<26; ++i) {\n        if(tile1[i].first == -1 || i == idx) continue;\n        if(x1 == x2) {\n            if(tile1[i].second == x1 && inter(tile1[i].first,y1,y2)) return false;\n            if(tile2[i].second == x1 && inter(tile2[i].first,y1,y2)) return false;\n        }else if(y1 == y2) {\n            if(tile1[i].first == y1 && inter(tile1[i].second,x1,x2)) return false;\n            if(tile2[i].first == y1 && inter(tile2[i].second,x1,x2)) return false;\n        }\n    }\n\n    bool is1 = false,is2 = false;\n    for(int i=0; i<26; ++i) {\n        if(tile1[i].first == -1 || i == idx) continue;\n        if(tile1[i].first == y1 && inter(tile1[i].second,x1,x2)) is1 = true;\n        if(tile1[i].first == y2 && inter(tile1[i].second,x1,x2)) is2 = true;\n        if(tile2[i].first == y1 && inter(tile2[i].second,x1,x2)) is1 = true;\n        if(tile2[i].first == y2 && inter(tile2[i].second,x1,x2)) is2 = true;\n    }\n\n    if(is1 && is2) return false;\n\n    return true;\n}\n\nint main() {\n    cin>>m>>n;\n    for(int i=0; i<m; ++i) cin>>mps[i];\n\n    for(int i=0; i<26; ++i)\n        tile1[i] = tile2[i] = make_pair(-1,-1);\n\n    for(int i=0; i<m; ++i) {\n        for(int j=0; j<n; ++j) {\n            if(mps[i][j] != '.') {\n                if(tile1[mps[i][j]-'A'].first == -1) tile1[mps[i][j]-'A'] = make_pair(i,j);\n                else tile2[mps[i][j]-'A'] = make_pair(i,j);\n            }\n        }\n    }\n\n    int ans = 0;\n    while(true) {\n        bool update = false;\n\n        for(int i=0; i<26; ++i) {\n            if(tile1[i].first == -1) continue;\n            int x1 = tile1[i].second,y1 = tile1[i].first;\n            int x2 = tile2[i].second,y2 = tile2[i].first;\n            if(ok(i,x1,y1,x2,y2)) {\n                tile1[i] = make_pair(-1,-1);\n                tile2[i] = make_pair(-1,-1);\n                ans += 2;\n                update = true;\n            }\n\n        // for(int i=0; i<m; ++i) {\n        //     for(int j=0; j<n; ++j) {\n        //         if(mps[i][j] == '.') cout<<\".\";\n        //         else if(tile1[mps[i][j]-'A'].first == -1) cout<<\".\";\n        //         else cout<<mps[i][j];\n        //     }\n        //     cout<<endl;\n        // }\n        }\n\n        if(!update) break;\n\n\n    }\n\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main(){\n  int n, m;\n  cin >> m >> n;\n  vector<string> C(m);\n  vector< vector<int> > A(26);\n  for(int i = 0; i < m; ++i){\n    cin >> C[i];\n    for(int j = 0; j < n; ++j){\n      if(C[i][j] != '.') A[C[i][j]-'A'].push_back(i*n+j);\n    }\n  }\n  int ans = 0;\n  for(int i = 0; i < 26; ++i){\n    for(int j = 0; j < 26; ++j){\n      if(A[j].empty()) continue;\n      int a = A[j][0]/n, b = A[j][0]%n, c = A[j][1]/n, d = A[j][1]%n;\n      bool f = true;\n      for(int k = min(b,d)+1; k < max(b,d); ++k){\n        if(C[a][k] != '.'){\n          f = false;\n          break;\n        }\n      }\n      for(int k = min(a,c)+1; k < max(a,c); ++k){\n        if(C[k][d] != '.'){\n          f = false;\n          break;\n        }\n      }\n      if((a != c && b != d && C[a][d] != '.') || (a == c && abs(b-d) <= 1) || (b == d && abs(a-c) <= 1)) f = false;\n      if(f){\n        //cout << (char)('A'+j) << endl;\n        C[a][b] = '.';\n        C[c][d] = '.';\n        ans += 2;\n        A[j] = vector<int>(0);\n        continue;\n      }\n      f = true;\n      for(int k = min(b,d)+1; k < max(b,d); ++k){\n        if(C[c][k] != '.'){\n          f = false;\n          break;\n        }\n      }\n      for(int k = min(a,c)+1; k < max(a,c); ++k){\n        if(C[k][b] != '.'){\n          f = false;\n          break;\n        }\n      }\n      if((a != c && b != d && C[c][b] != '.') || (a == c && abs(b-d) <= 1) || (b == d && abs(a-c) <= 1)) f = false;\n      if(f){\n        //cout << (char)('A'+j) << endl;\n        C[a][b] = '.';\n        C[c][d] = '.';\n        ans += 2;\n        A[j] = vector<int>(0);\n        continue;\n      }\n    }\n  }\n  cout << ans << endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nchar m[505][505];\nint h, w;\n\nconst int dy[16] = { 0,-1, 0, 1, 1,-1, 1,-1, 0,-2, 0, 2};\nconst int dx[16] = { 1, 0,-1, 0, 1, 1,-1,-1, 2, 0,-2, 0};\n\nvector<pair<pair<int, int>,char>> extends(int y, int x){\n    vector<pair<pair<int,int>,char>> ret;\n    rep(i,4){\n        int ny = y, nx = x;\n        while(true){\n            ny += dy[i];\n            nx += dx[i];\n            if(ny < 0 || ny >= h || nx < 0 || nx >= w) break;\n            if(m[ny][nx] != '.'){\n                ret.emplace_back(make_pair(make_pair(ny,nx),m[ny][nx]));\n                break;\n            }\n        }\n    }\n    return ret;\n}\n\nvoid compress(vector<int> &v) {\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\n\nint lb(vector<int> v, int num){\n    return lower_bound(all(v), num) - v.begin();\n}\n\nint main(){\n    cin >> h >> w;\n\n    vector<pair<pair<int, int>,char>> v;\n    vector<int> x,y;\n    rep(i,h){\n        rep(j,w){\n            char c;\n            cin >> c;\n            if(c != '.'){\n                v.emplace_back(make_pair(make_pair(i,j),c));\n                y.emplace_back(i);\n                x.emplace_back(j);\n            }\n        }\n    }\n    compress(x);\n    compress(y);\n    h = y.size();\n    w = x.size();\n\n    rep(i,h + 1) rep(j,w + 1) m[i][j] = '.';\n    rep(i,v.size()){\n        int fy = lb(y,v[i].first.first);\n        int fx = lb(x,v[i].first.second);\n        m[fy][fx] = v[i].second;\n    }\n    //cout << endl; rep(i,h){ rep(j,w){ cout << m[i][j]; } cout << endl; } cout << endl;\n\n    bool f = true;\n    int cnt = 0;\n    while(f){\n        f = false;\n        rep(i,h){\n            rep(j,w){\n                vector<pair<pair<int, int>,char>> v;\n                if(m[i][j] == '.') v = extends(i,j);\n                rep(i,v.size()){\n                    rep(j,v.size()){\n                        if(i == j) continue;\n                        if(v[i].second == v[j].second){\n                            if(m[ v[i].first.first ][ v[i].first.second ] == '.') continue;\n                            m[ v[i].first.first ][ v[i].first.second ] = '.';\n                            m[ v[j].first.first ][ v[j].first.second ] = '.';\n                            f = true;\n                            cnt++;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    cout << cnt * 2 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cctype>\n#include <cstdlib>\n\nusing namespace std;\n\nstruct Pos {\n    int r, c;\n\n    Pos() {}\n    Pos(int r, int c) : r(r), c(c) {}\n};\n\ninline int toidx(char c) {\n    return c - 'A';\n}\n\ninline int sign(int n) {\n    if(n == 0) return 0;\n    return n < 0 ? -1 : 1;\n}\n\ninline int dist(const Pos &p1, const Pos &p2) {\n    return abs(p1.r-p2.r) + abs(p1.c-p2.c);\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n\n    int R, C;\n    cin >> R >> C;\n\n    vector<string> v;\n    vector<vector<Pos> > pos(26);\n    for(int i = 0; i < R; ++i) {\n        string line;\n        cin >> line;\n\n        for(int j = 0; j < line.size(); ++j) {\n            if(isalpha(line[j])) {\n                pos[toidx(line[j])].push_back(Pos(i, j));\n            }\n        }\n\n        v.push_back(line);\n    }\n\n    int score = 0;\n    vector<int> used(26, 0);\n    while(true) {\n        bool modified = false;\n\n        for(int i = 0; i < pos.size(); ++i) {\n            if(used[i]) continue;\n            if(pos[i].size() == 0) continue;\n\n            const Pos &p1 = pos[i][0];\n            const Pos &p2 = pos[i][1];\n            if(dist(p1, p2) == 1) continue;\n\n            int r1 = p1.r;\n            int c1 = p2.c;\n            bool ok = true;\n            for(int c = c1; c != p1.c; c += sign(p1.c-c)) {\n                if(v[r1][c] != '.' && v[r1][c] != i+'A') ok = false;\n            }\n            for(int r = r1; r != p2.r; r += sign(p2.r-r)) {\n                if(v[r][c1] != '.' && v[r][c1] != i+'A') ok = false;\n            }\n            if(!ok) {\n                int r2 = p2.r;\n                int c2 = p1.c;\n                ok = true;\n                for(int c = c2; c != p2.c; c += sign(p2.c-c)) {\n                    if(v[r2][c] != '.' && v[r2][c] != i+'A') ok = false;\n                }\n                for(int r = r2; r != p1.r; r += sign(p1.r-r)) {\n                    if(v[r][c2] != '.' && v[r][c2] != i+'A') ok = false;\n                }\n            }\n\n            if(ok) {\n                score += 2;\n                v[p1.r][p1.c] = v[p2.r][p2.c] = '.';\n                used[i] = true;\n                modified = true;\n            }\n        }\n\n        if(!modified) break;\n    }\n\n    cout << score << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nusing namespace std;\nint main(void)\n{\n  int m,n;\n  cin >> m >> n;\n  vector<string> fi(m);\n  REP(i,m) cin >> fi[i];\n  int answer=0;\n  REP(i,m) REP(j,n) if(fi[i][j]=='.') --answer;\n  vector<pair<int,int> > pos[256];\n  REP(i,m) REP(j,n) if(fi[i][j]!='.'){\n    pos[fi[i][j]].push_back(make_pair(i,j));\n  }\n  bool flag=true;\n  while(flag){\n    flag=false;\n    FOR(i,'A','Z'+1){\n      if(pos[i].size()<2) continue;\n      int x0,x1,y0,y1;\n      x0=pos[i][0].first;\n      y0=pos[i][0].second;\n      x1=pos[i][1].first;\n      y1=pos[i][1].second;\n      if(x0==x1){\n\tif(abs(y0-y1)>1){\n\t  bool er=true;\n\t  if(y0>y1) swap(y0,y1);\n\t  FOR(j,y0+1,y1) if(fi[x0][j]!='.') er=false;\n\t  if(er){\n\t    fi[x0][y0]='.';\n\t    fi[x1][y1]='.';\n\t    flag=true;\n\t    pos[i].clear();\n\t  }\n\t}\n      }else if(y0==y1){\n\tif(abs(x0-x1)>1){\n\t  bool er=true;\n\t  if(x0>x1) swap(x0,x1);\n\t  FOR(j,x0+1,x1) if(fi[j][y0]!='.') er=false;\n\t  if(er){\n\t    fi[x0][y0]='.';\n\t    fi[x1][y1]='.';\n\t    flag=true;\n\t    pos[i].clear();\n\t  }\n\t}\n      }else if((x0-x1)*(y0-y1)>0){\n\tbool er0=true,er1=true;\n\tif(x0>x1){\n\t  swap(x0,x1);\n\t  swap(y0,y1);\n\t}\n\tFOR(j,x0+1,x1+1) if(fi[j][y0]!='.') er0=false;\n\tFOR(j,y0+1,y1) if(fi[x1][j]!='.') er0=false;\n\tFOR(j,y0+1,y1+1) if(fi[x0][j]!='.') er1=false;\n\tFOR(j,x0+1,x1) if(fi[j][y1]!='.') er1=false;\n\tif(er0||er1){\n\t  fi[x0][y0]='.';\n\t  fi[x1][y1]='.';\n\t  flag=true;\n\t  pos[i].clear();\n\t}\n      }else if((x0-x1)*(y0-y1)<0){\n\tbool er0=true,er1=true;\n\tif(x0>x1){\n\t  swap(x0,x1);\n\t  swap(y0,y1);\n\t}\n\tFOR(j,x0+1,x1+1) if(fi[j][y0]!='.') er0=false;\n\tFOR(j,y1+1,y0) if(fi[x1][j]!='.') er0=false;\n\tFOR(j,y1,y0) if(fi[x0][j]!='.') er1=false;\n\tFOR(j,x0+1,x1) if(fi[j][y1]!='.') er1=false;\n\tif(er0||er1){\n\t  fi[x0][y0]='.';\n\t  fi[x1][y1]='.';\n\t  flag=true;\n\t  pos[i].clear();\n\t}\n      }\n    }\n  }\n  REP(i,m) REP(j,n) if(fi[i][j]=='.') ++answer;\n  cout << answer << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\nusing namespace std;\n\nint M, N, K;\nchar S[550][550];\nint h, w;\nvector<int> y, x;\nvector<char> c;\nchar s[100][100];\nint dd[5] = { 0, 1, 0, -1, 0 };\n\nint compress(vector<int> &a) {\n  vector<int> v;\n\n  REP(i, 0, a.size()) v.push_back(a[i]);\n  sort(v.begin(), v.end());\n  v.erase(unique(v.begin(), v.end()), v.end());\n  REP(i, 0, a.size()) a[i] = find(v.begin(), v.end(), a[i]) - v.begin();\n\n  return (int) v.size();\n}\n\nbool isin(int y, int x) {\n  return 0 <= y && y < h && 0 <= x && x < w;\n}\n\nint main(void) {\n  cin >> M >> N;\n  K = 0;\n  REP(i, 0, M) REP(j, 0, N) {\n    cin >> S[i][j];\n    if(S[i][j] != '.') {\n      y.push_back(i);\n      x.push_back(j);\n      c.push_back(S[i][j]);\n      K++;\n    }\n  }\n\n  h = compress(y);\n  w = compress(x);\n\n  REP(i, 0, h) REP(j, 0, w) s[i][j] = '.';\n  REP(i, 0, K) {\n    // cout << y[i] << \", \" << x[i] << \": \" << c[i] << endl;\n    s[y[i]][x[i]] = c[i];\n  }\n\n  // REP(i, 0, h) {\n  //   REP(j, 0, w) cout << s[i][j];\n  //   cout << endl;\n  // }\n\n  int ans = 0;\n  bool visited[256];\n  REP(i, 0, 256) visited[i] = false;\n  bool f = true;\n  while(f) {\n    f = false;\n    REP(i, 0, h) REP(j, 0, w) {\n      if(s[i][j] == '.' || visited[S[i][j]]) {\n        int cnt[256];\n        REP(k, 0, 256) cnt[k] = 0;\n        // cout << i << \", \" << j << endl;\n        REP(k, 0, 4) {\n          int ny = i, nx = j;\n          while(isin(ny, nx)) {\n            // cout << \"  \" << ny << \", \" << nx << \": \" << s[ny][nx] << endl;\n            if(s[ny][nx] != '.' && !visited[S[ny][nx]]) {\n              // cout << s[ny][nx] << endl;\n              cnt[s[ny][nx]]++;\n              if(cnt[s[ny][nx]] == 2) {\n                // cout << \"  vanish: \" << S[ny][nx] << endl;\n                visited[S[ny][nx]] = true;\n                ans += 2;\n                f = true;\n              }\n              break;\n            }\n            ny += dd[k];\n            nx += dd[k + 1];\n          }\n        }\n      }\n    }\n  }\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\n#include <array>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\n\n\ntypedef long long int ll;\ntypedef double D;      // ??§?¨?????????????double???long double?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\n\n\nconst int INF = (1<<30) - 1;\nconst D EPS = 1e-9;\n\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\nint M, N;\nvector<string> field;\n\nint dh[] = {-1, 1, 0, 0};\nint dw[] = {0, 0, 1, -1};\n\ninline bool in_field(int h, int w){\n    return 0<=h&&h<M && 0<=w&&w<N;\n}\n\nvoid solve(){\n    bool updated = true;\n    int count = 0;\n    while (updated) {\n        updated = false;\n        for(int i=0; i<M; i++){\n            for(int j=0; j<N; j++) if(field[i][j] == '.'){\n                vector<tuple<char, int, int>> colors;\n                \n                for(int d=0; d<4; d++){\n                    int l = 0;\n                    while(in_field(i+dh[d]*l, j+dw[d]*l) && field[i+dh[d]*l][j+dw[d]*l] == '.') l++;\n                    \n                    if(!in_field(i+dh[d]*l, j+dw[d]*l)) continue;\n                    \n                    colors.push_back(tuple<char, int, int>(field[i+dh[d]*l][j+dw[d]*l], i+dh[d]*l, j+dw[d]*l));\n                }\n                \n                for(int i=0; i<colors.size(); i++){\n                    for(int j=i+1; j<colors.size(); j++){\n                        char c1, c2;\n                        int h1, w1, h2, w2;\n                        tie(c1, h1, w1) = colors[i];\n                        tie(c2, h2, w2) = colors[j];\n                        if(c1 == c2){\n                            field[h1][w1] = field[h2][w2] = '.';\n                            count += 2;\n                            updated = true;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    cout << count << endl;\n}\n\n//g++ -std=c++0x -msse4.2 -O3\n//#include <bits/stdc++.h>\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    //cout.precision(16);\n    \n    cin >> M >> N;\n    field = vector<string>(M);\n    for(int i=0; i<M; i++)\n        cin >> field[i];\n    \n    solve();\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define x first\n#define y second\nusing namespace std;\ntypedef pair <int,int> P;\nstring mp[501];\nint m,n,used[30],ans;\nvector <P>  a[30];\n\nint saiki(int);\n\nbool check(int c,int s,int t,int f){\n  int res=1;\n  for(int i=s+1;i<t;i++){\n    if(!f&&mp[i][c]!='.'&&!saiki(mp[i][c]-'A'))res=0;\n    if(f&&mp[c][i]!='.'&&!saiki(mp[c][i]-'A'))res=0;\n  }\n  return res;\n}\n\nint saiki(int ch){\n  int x1=a[ch][0].x,x2=a[ch][1].x;\n  int y1=a[ch][0].y,y2=a[ch][1].y;\n  int res=0;\n  if(used[ch])return 0;\n  used[ch]=1;\n  \n  if(x1==x2&&y2-y1!=1) res=check(x1,y1,y2,0);\n  if(y1==y2&&x2-x1!=1) res=check(y1,x1,x2,1);\n  \n  if(x1!=x2&&y1!=y2) {\n    if(x1<x2){\n      res=check(y1,x1,x2+1,1)&check(x2,y1,y2,0);\n      res|=check(x1,y1,y2+1,0)&check(y2,x1,x2,1);\n    }\n    else{\n      swap(x1,x2);\n      res=check(y1,x1-1,x2,1)&check(x1,y1,y2,0);\n      res|= check(x2,y1,y2,0)&check(y2,x1,x2+1,1);\n      swap(x1,x2);\n    }\n  }\n  \n  if(res) {\n    mp[y1][x1]=mp[y2][x2]='.';\n    a[ch].clear();\n    ans+=2;\n  }\n  return res;\n}\n\nint main(){\n  \n  cin>>m>>n;\n  for(int i=0;i<m;i++)cin>>mp[i];\n  \n  for(int i=0;i<m;i++)\n    for(int j=0;j<n;j++)\n      if(mp[i][j]!='.')a[mp[i][j]-'A'].push_back(P(j,i));\n  \n \n  int f=1;\n  while(f--) \n    for(int i=0;i<30;i++){\n      if(a[i].size()) f|=saiki(i);\n      used[i]=0;\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <vector>\nusing namespace std;\ntypedef pair<int,int> P;\nint M,N;\nset<int> row[510],col[510];\nchar C[510][510];\nint main(){\n    cin >> M >> N;\n    for(int i=1;i<=M;i++){\n        for(int j=1;j<=N;j++){\n            cin >> C[i][j];\n            if(C[i][j]!='.'){\n                row[i].insert(j);\n                col[j].insert(i);\n            }\n        }\n    }\n    int ans = 0;\n    bool ok = true;\n    while(true){\n        bool update = false;\n        for(int i=1;i<=M;i++){\n            for(int j=1;j<=N;j++){\n                if(C[i][j]!='.') continue;\n                vector<P> v;\n                set<int>::iterator rit = row[i].upper_bound(j);\n                set<int>::iterator cit = col[j].upper_bound(i);\n                if(rit!=row[i].end()) v.push_back({i,*rit});\n                if(rit!=row[i].begin()){\n                    rit--;\n                    v.push_back({i,*rit});\n                }\n                if(cit!=col[j].end()) v.push_back({*cit,j});\n                if(cit!=col[j].begin()){\n                    cit--;\n                    v.push_back({*cit,j});\n                }\n                for(auto x:v){\n                    for(auto y:v){\n                        if(x==y) continue;\n                        if(C[x.first][x.second]!='.' && C[x.first][x.second]==C[y.first][y.second]){\n                            ans += 2;\n                            C[x.first][x.second] = '.';\n                            C[y.first][y.second] = '.';\n                            row[x.first].erase(x.second);\n                            col[x.second].erase(x.first);\n                            row[y.first].erase(y.second);\n                            col[y.second].erase(y.first);\n                            update = true;\n                        }\n                    }\n                }\n            }\n        }\n        if(!update) break;\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define lp(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, n) lp(i, 0, n)\n#define rlp(i, a, b) for (int i = (int)(b) - 1; i >= (int)(a); i--)\n#define rrep(i, n) rlp(i, 0, n)\n\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n#define all(c) begin(c), end(c)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\ntemplate<typename T>\ninline bool chmin(T &a, T b){\n\tif (a <= b) return false;\n\ta = b; return true;\n}\n\ntemplate<typename T>\ninline bool chmax(T &a, T b){\n\tif (a >= b) return false;\n\ta = b; return true;\n}\n\ntemplate<typename T>\ninline void unique(T &c){\n\tsort(all(c));\n\tc.erase(unique(all(c)), end(c));\n}\n\ntemplate<typename T>\ninline T sq(T a){\n\treturn a * a;\n}\n\ntemplate<typename T>\ninline size_t index_of(vector<T> &c, T x){\n\treturn lower_bound(all(c), x) - begin(c);\n}\n\nint m, n;\nvector<tuple<char, int, int>> v;\nvector<int> zx, zy;\nchar g[160][160];\n\nint main()\n{\n\tcin >> m >> n;\n\trep(i, m) rep(j, n){\n\t\tchar c;\n\t\tcin >> c;\n\t\tif (c != '.'){\n\t\t\tv.eb(c, i, j);\n\t\t\tlp(k, -1, 2){\n\t\t\t\tzx.pb(i + k); zy.pb(j + k);\n\t\t\t}\n\t\t}\n\t}\n\tunique(zx); unique(zy);\n\tm = zx.size(); n = zy.size();\n\tmemset(g, '.', sizeof(g));\n\tfor (auto &t : v){\n\t\tchar c; int x, y;\n\t\ttie(c, x, y) = t;\n\t\tg[index_of(zx, x)][index_of(zy, y)] = c;\n\t}\n\tint res = 0;\n\trep(k, 26) rep(x, m) rep(y, n){\n\t\tif (g[x][y] != '.') continue;\n\t\tmap<char, vector<pair<int, int>>> cnt;\n\t\trep(dir, 4){\n\t\t\tint xx = x, yy = y;\n\t\t\twhile (true){\n\t\t\t\txx += dx[dir], yy += dy[dir];\n\t\t\t\tif (xx < 0 || xx >= m || yy < 0 || yy >= n) break;\n\t\t\t\tif (g[xx][yy] != '.'){\n\t\t\t\t\tcnt[g[xx][yy]].eb(xx, yy);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (auto &t : cnt){\n\t\t\tif (t.second.size() < 2) continue;\n\t\t\tfor (auto &p : t.second){\n\t\t\t\tg[p.first][p.second] = '.';\n\t\t\t}\n\t\t\tres += 2;\n\t\t}\n\t}\n\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <map>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define LINE() cerr<< \" (L\" << __LINE__ << \")\"\n\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nint main() {\n\t\tint H,W;cin >>H >> W;\n\n\t\tvector<string> board(H);\n\t\tfor(int y=0;y<H;y++){\n\t\t\tcin >> board[y];\n\t\t}\n\n\t\tmap<int,int> xmap,ymap;\n\t\tfor(int y=0;y<H;y++){\n\t\t\tfor(int x=0;x<W;x++){\n\t\t\t\tif(board[y][x]!='.'){\n\t\t\t\t\txmap.insert(make_pair(x,1));\n\t\t\t\t\tif(0<x-1 && x-1 <W)xmap.insert(make_pair(x-1,1));\n\t\t\t\t\tif(0<x+1 && x+1 <W)xmap.insert(make_pair(x+1,1));\n\n\t\t\t\t\tymap.insert(make_pair(y,1));\n\t\t\t\t\tif(0<y-1 && y-1 <H)ymap.insert(make_pair(y-1,1));\n\t\t\t\t\tif(0<y+1 && y+1 <H)ymap.insert(make_pair(y+1,1));\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> xs,ys;\n\t\tfor(auto it=xmap.begin();it!=xmap.end();it++){\n\t\t\txs.push_back(it->first);\n\t\t}\n\t\tfor(auto it=ymap.begin();it!=ymap.end();it++){\n\t\t\tys.push_back(it->first);\n\t\t}\n\t\tsort(xs.begin(),xs.end());\n\t\tsort(ys.begin(),ys.end());\n\n\t\tint h=ys.size(),w=xs.size();\n\t\tint res=0;\n\t\tfor(int c=0;c<30;c++){\n\t\t\tfor(int y=0;y<h;y++)for(int x=0;x<w;x++)if(board[ys[y]][xs[x]]=='.'){\n\t\t\t\tmap<char,vector<pair<int,int>>> ps;\n\t\t\t\tfor(int d=0;d<4;d++){\n\t\t\t\t\tint px=x,py=y;\n\t\t\t\t\twhile( 0<= px && px < w && 0 <=py && py < h  &&   board[ys[py]][xs[px]]=='.'){\n\t\t\t\t\t\tpx+=dx[d];py+=dy[d];\n\t\t\t\t\t}\n\t\t\t\t\tif( 0<= px && px < w && 0 <=py && py < h  && board[ys[py]][xs[px]]!='.'){\n\t\t\t\t\t\tps[board[ys[py]][xs[px]]].push_back(make_pair(py,px));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor(auto it=ps.begin();it!=ps.end();it++){\n\t\t\t\t\tvector<pair<int,int>> vs=it->second;\n\t\t\t\t\tif(it->second.size()==2){\n\t\t\t\t\t\tres+=2;\n\t\t\t\t\t\tboard[ys[vs[0].first]][xs[vs[0].second]]='.';\n\t\t\t\t\t\tboard[ys[vs[1].first]][xs[vs[1].second]]='.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << res <<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <complex>\n#include <cstdlib>\n#include <iostream>\n#include <queue>\n#include <utility>\n#include <vector>\nusing namespace std;\n\ntypedef complex<int> point;\n#define X real()\n#define Y imag()\n\nconstexpr int MAX_SIZE = 500;\nstring board[MAX_SIZE];\n\nbool operator<(const point& a, const point& b) {\n\treturn a.X != b.X ? a.X < b.X : a.Y < b.Y;\n}\n\ninline int dist2(const point& a, const point& b) {\n\tconst int diffX = a.X - b.X;\n\tconst int diffY = a.Y - b.Y;\n\treturn diffX * diffX + diffY * diffY;\n}\n\ninline double dist(const point& a, const point& b) {\n\treturn sqrt(dist2(a, b));\n}\n\nint calc(const point& start, const point& to) {\n\tconst point d = (to - start) / static_cast<int>(dist(to, start));\n\tint res = 0;\n\tpoint current = start;\n\n\twhile(current != to) {\n\t\tif(board[current.Y][current.X] != '.') res |= (1 << (board[current.Y][current.X] - 'A'));\n\t\tcurrent += d;\n\t}\n\n\treturn res;\n}\n\nvoid update(queue<int>& que, vector<pair<int, int>>& can_erase, int value) {\n\tvalue = ~value;\n\n\tfor(int i = 0; i < static_cast<int>(can_erase.size());) {\n\t\tcan_erase[i].first &= value;\n\t\tif(can_erase[i].first == 0) {\n\t\t\tque.push(can_erase[i].second);\n\t\t\tcan_erase.erase(can_erase.begin() + i);\n\t\t}\n\t\telse {\n\t\t\t++i;\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint h, w;\n\tcin >> h >> w;\n\n\tfor(int i = 0; i < h; ++i) {\n\t\tcin >> board[i];\n\t}\n\n\tvector<vector<point>> tiles(26);\n\tfor(int i = 0; i < h; ++i) {\n\t\tfor(int j = 0; j < w; ++j) {\n\t\t\tif(board[i][j] != '.') {\n\t\t\t\ttiles[board[i][j] - 'A'].emplace_back(j, i);\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<bool> used(26, true);\n\tvector<pair<int, int>> can_erase;\n\n\tfor(int i = 0; i < 26; ++i) {\n\t\tif(tiles[i].size() == 0 || dist2(tiles[i][0], tiles[i][1]) == 1) continue;\n\n\t\tused[i] = false;\n\t\tif(tiles[i][1] < tiles[i][0]) swap(tiles[i][0], tiles[i][1]);\n\n\t\tif(tiles[i][0].X == tiles[i][1].X) {\n\t\t\tcan_erase.emplace_back(calc(tiles[i][0] + point(0, 1), tiles[i][1]), i);\n\t\t}\n\t\telse if(tiles[i][0].Y == tiles[i][1].Y) {\n\t\t\tcan_erase.emplace_back(calc(tiles[i][0] + point(1, 0), tiles[i][1]), i);\n\t\t}\n\t\telse {\n\t\t\tpoint start(tiles[i][0].X, tiles[i][1].Y);\n\t\t\tcan_erase.emplace_back(calc(start, tiles[i][0]) | calc(start, tiles[i][1]), i);\n\n\t\t\tstart = point(tiles[i][1].X, tiles[i][0].Y);\n\t\t\tcan_erase.emplace_back(calc(start, tiles[i][0]) | calc(start, tiles[i][1]), i);\n\t\t}\n\t}\n\n\tqueue<int> que;\n\tupdate(que, can_erase, 0);\n\n\tint ans = 0;\n\twhile(!que.empty()) {\n\t\tint color = que.front();\n\t\tque.pop();\n\n\t\tif(used[color]) continue;\n\t\tused[color] = true;\n\t\t++ans;\n\n\t\tupdate(que, can_erase, (1 << color));\n\t}\n\n\tcout << ans * 2 << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nint main(){\n\tint dy[] = {0, 0, 1, -1};\n\tint dx[] = {1, -1, 0, 0};\n\n\tint h, w;\n\tcin >> h >> w;\n\n\tvector<string> grid(h);\n\tfor(int i=0; i<h; ++i)\n\t\tcin >> grid[i];\n\n\tstring s = string(w, '.');\n\tfor(int i=1; i<h-1; ++i){\n\t\tif(grid[i-1] == s && grid[i] == s && grid[i+1] == s){\n\t\t\tgrid.erase(grid.begin() + i);\n\t\t\t-- i;\n\t\t\t-- h;\n\t\t}\n\t}\n\n\tint ret = 0;\n\tfor(;;){\n\t\tbool ok = true;\n\t\tfor(int i=0; i<h; ++i){\n\t\t\tfor(int j=0; j<w; ++j){\n\t\t\t\tif(grid[i][j] != '.')\n\t\t\t\t\tcontinue;\n\n\t\t\t\tmap<char, pair<int, int> > m;\n\n\t\t\t\tfor(int k=0; k<4; ++k){\n\t\t\t\t\tint y = i;\n\t\t\t\t\tint x = j;\n\t\t\t\t\twhile(y >= 0 && y < h && x >= 0 && x < w && grid[y][x] == '.'){\n\t\t\t\t\t\ty += dy[k];\n\t\t\t\t\t\tx += dx[k];\n\t\t\t\t\t}\n\t\t\t\t\tif(y >= 0 && y < h && x >= 0 && x < w){\n\t\t\t\t\t\tchar c = grid[y][x];\n\t\t\t\t\t\tif(m.find(c) != m.end()){\n\t\t\t\t\t\t\tgrid[y][x] = '.';\n\t\t\t\t\t\t\tgrid[m[c].first][m[c].second] = '.';\n\t\t\t\t\t\t\tret += 2;\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tm[c] = make_pair(y, x);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ok)\n\t\t\tbreak;\n\t}\n\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nint main() {\n  int m,n;\n  cin>>m>>n;\n  vector<string> t(m);\n  REP(i,m)cin>>t[i];\n  vector<int> iv,jv;\n  REP(i,m) {\n    bool al = true;\n    REP(j,n) if(t[i][j] != '.') al = false;\n    if(!al){\n      if(i) iv.push_back(i-1);\n      iv.push_back(i);\n      if(i<m-1) iv.push_back(i+1);\n    }\n  }\n  sort(begin(iv),end(iv));\n  iv.erase(unique(begin(iv),end(iv)),end(iv));\n  REP(i,n) {\n    bool al = true;\n    REP(j,m) if(t[j][i] != '.') al = false;\n    if(!al){\n      if(i) jv.push_back(i-1);\n      jv.push_back(i);\n      if(i<n-1) jv.push_back(i+1);\n    }\n  }\n  sort(begin(jv),end(jv));\n  jv.erase(unique(begin(jv),end(jv)),end(jv));\n  if (iv.empty()) {\n    cout << 0 << endl;\n    return 0;\n  }\n  vector<string> ct(iv.size());\n  m = iv.size();\n  n = jv.size();\n  REP(i,m)\n    REP(j,n)\n      ct[i] += t[iv[i]][jv[j]];\n  int score = 0;\n  while(1){\n    set<char> er;\n    REP(i,m)REP(j,n){\n      if (ct[i][j] != '.') continue;\n      map<char, int> s;\n      int di[]={1,0,-1,0};\n      int dj[]={0,1,0,-1};\n      REP(k,4){\n        int l=1;\n        while(1){\n          int ni=i+di[k]*l;\n          int nj=j+dj[k]*l;\n          if(ni<0||nj<0||ni>=m||nj>=n) break;\n          if(ct[ni][nj] != '.'){\n            ++s[ct[ni][nj]];\n            break;\n          }\n          ++l;\n        }\n      }\n      for (auto p:s) {\n        if(p.second == 2) er.insert(p.first);\n      }\n    }\n    score += er.size()*2;\n    if (er.empty()) break;\n    REP(i,m)REP(j,n){\n      if(er.count(ct[i][j]))\n        ct[i][j] = '.';\n    }\n  }\n  cout << score << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nstring grid[500];\nint posy[26][2],posx[26][2];\nint pos[26][2][2];\nbool use[26];\nint n,m;\nint res;\n\nbool cluck(int y,int x){\n  int k;\n  int cnt[26];\n  for(int i=0;i<26;i++)cnt[i] = 0;\n\n  k = 1;\n  while(y+k<n && grid[y+k][x] == '.')k++;\n  if(y+k<n)cnt[grid[y+k][x]-'A']++;\n\n  k = 1;\n  while(x+k<m && grid[y][x+k] == '.')k++;\n  if(x+k<m)cnt[grid[y][x+k]-'A']++;\n\n  k = 1;\n  while(y-k>=0 && grid[y-k][x] == '.')k++;\n  if(y-k>=0)cnt[grid[y-k][x]-'A']++;\n\n  k = 1;\n  while(x-k>=0 && grid[y][x-k] == '.')k++;\n  if(x-k>=0)cnt[grid[y][x-k]-'A']++;\n\n  bool f = false;\n  for(int i=0;i<26;i++){\n    if(cnt[i]==2){\n      res += 2;\n      grid[posy[i][0]][posx[i][0]] ='.';\n      grid[posy[i][1]][posx[i][1]] ='.';\n      use[i] = false;\n      f = true;\n    }\n  }\n\n  return f;\n}\n\nint main(){\n  cin >> n >> m;\n  for(int i=0;i<n;i++)cin >> grid[i];\n\n  for(int i=0;i<26;i++){\n    posy[i][0] = -1;\n    posx[i][0] = -1;\n    posy[i][1] = -1;\n    posx[i][1] = -1;\n    use[i] = false;\n  }\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<m;j++){\n      if(grid[i][j] != '.'){\n\tif(posy[grid[i][j]-'A'][0]<0){\n\t  posy[grid[i][j]-'A'][0] = i;\n\t  posx[grid[i][j]-'A'][0] = j;\n\t  use[grid[i][j]-'A'] = true;\n\t}else{\n\t  posy[grid[i][j]-'A'][1] = i;\n\t  posx[grid[i][j]-'A'][1] = j;\n\t}\n      }\n    }\n  }\n\n  res = 0;\n  while(1){\n    bool f = false;\n    for(int i=0;i<26;i++){\n      if(use[i]){\n\tif(posy[i][0] == posy[i][1]){\n\t  int s = min(posx[i][0],posx[i][1]),g = max(posx[i][0],posx[i][1]);\n\t  for(int j=s+1;j<g;j++){\n\t    if(grid[posy[i][0]][j]=='.')f |= cluck(posy[i][0],j);\n\t  }\n\t}else if(posx[i][0] == posx[i][1]){\n\t  int s = min(posy[i][0],posy[i][1]),g = max(posy[i][0],posy[i][1]);\n\t  for(int j=s+1;j<g;j++){\n\t    if(grid[j][posx[i][0]]=='.')f |= cluck(j,posx[i][0]);\n\t  }\n\t}else{\n\t  if(grid[posy[i][0]][posx[i][1]] == '.')f |= cluck(posy[i][0],posx[i][1]);\n\t  if(grid[posy[i][1]][posx[i][0]] == '.')f |= cluck(posy[i][1],posx[i][0]);\n\t}\n      }\n    }\n    if(!f)break;\n  }\n\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mk make_pair\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nstring s[500];\nint h,w,sum=0;\nvector<int>x,y;\nvoid del(int t1,int t2){\n  vector<pair<char,pair<int,int> > >p;\n  for(int i=t1;i<h;i++)if(s[i][t2]!='.'){\n    p.push_back(mk(s[i][t2],mk(i,t2)));\n    break;\n  }\n  for(int i=t1;i>=0;i--)if(s[i][t2]!='.'){\n    p.push_back(mk(s[i][t2],mk(i,t2)));\n    break;\n  }\n  for(int i=t2;i<w;i++)if(s[t1][i]!='.'){\n    p.push_back(mk(s[t1][i],mk(t1,i)));\n    break;\n  }\n  for(int i=t2;i>=0;i--)if(s[t1][i]!='.'){\n    p.push_back(mk(s[t1][i],mk(t1,i)));\n    break;\n  }\n  sort(p.begin(),p.end());\n  if(p.size()>=2){\n    r(i,p.size()-1){\n      if(p[i].first==p[i+1].first){\n        sum++;\n        s[p[i].second.first][p[i].second.second]='.';\n        s[p[i+1].second.first][p[i+1].second.second]='.';\n      }\n    }\n  }\n}\nint main(){\n  cin>>h>>w;\n  r(i,h)cin>>s[i];\n  r(i,h)r(j,w)if(s[i][j]!='.')\n      y.push_back(i),x.push_back(j);\n  r(k,26)r(i,y.size())r(j,x.size())\n    if(s[y[i]][x[j]]=='.')del(y[i],x[j]);\n  cout<<sum*2<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint m,n;\nvector<P> data[30];\nvector<int> xindex;\nvector<int> yindex;\nint field[190][190];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint pickl[4];\nint picklx[4];\nint pickly[4];\n\nint main(void){\n\tscanf(\"%d %d\",&n,&m);\n\tmemset(field,0,sizeof(field));\n\tfor(int i=0;i<n;i++){\n\t\tstring str;\n\t\tcin >> str;\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(str[j]>='A' && str[j]<='Z'){\n\t\t\t\tdata[str[j]-'A'+1].push_back(P(j,i));\n\t\t\t\tif(j-1>=0)xindex.push_back(j-1);\n\t\t\t\txindex.push_back(j);\n\t\t\t\tif(j+1<m)xindex.push_back(j+1);\n\t\t\t\tif(i-1>=0)yindex.push_back(i-1);\n\t\t\t\tyindex.push_back(i);\n\t\t\t\tif(i+1<n)yindex.push_back(i+1);\n\t\t\t}\n\t\t}\n\t}\n\tsort(xindex.begin(),xindex.end());\n\txindex.erase(unique(xindex.begin(),xindex.end()),xindex.end());\n\tsort(yindex.begin(),yindex.end());\n\tyindex.erase(unique(yindex.begin(),yindex.end()),yindex.end());\n\tfor(int i=1;i<=26;i++){\n\t\tfor(int j=0;j<data[i].size();j++){\n\t\t\tdata[i][j].first=lower_bound(xindex.begin(),xindex.end(),data[i][j].first)-xindex.begin();\n\t\t\tdata[i][j].second=lower_bound(yindex.begin(),yindex.end(),data[i][j].second)-yindex.begin();\n\t\t\tfield[data[i][j].first][data[i][j].second]=i;\n\t\t}\n\t}\n\tbool flag=true;\n\tint score2=0;\n\twhile(flag){\n\t\tflag=false;\n\t\tfor(int i=0;i<yindex.size();i++){\n\t\t\tfor(int j=0;j<xindex.size();j++){\n\t\t\t\tif(field[j][i]==0){\n\t\t\t\t\tmemset(pickl,0,sizeof(pickl));\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tint xx=j,yy=i;\n\t\t\t\t\t\tint xi=xindex.size(),yi=yindex.size();\n\t\t\t\t\t\tint cnt=0;\n\t\t\t\t\t\twhile(xx>=0 && xx<xi && yy>=0 && yy<yi){\n\t\t\t\t\t\t\tif(field[xx][yy]!=0)break;\n\t\t\t\t\t\t\txx+=dx[k];\n\t\t\t\t\t\t\tyy+=dy[k];\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\tif(cnt>=190)break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(field[xx][yy]!=0){\n\t\t\t\t\t\t\tpickl[k]=field[xx][yy];\n\t\t\t\t\t\t\tpicklx[k]=xx;\n\t\t\t\t\t\t\tpickly[k]=yy;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tfor(int l=k+1;l<4;l++){\n\t\t\t\t\t\t\tif(pickl[k]==pickl[l] && pickl[k]!=0){\n\t\t\t\t\t\t\t\tscore2+=2;\n\t\t\t\t\t\t\t\tfield[picklx[k]][pickly[k]]=0;\n\t\t\t\t\t\t\t\tfield[picklx[l]][pickly[l]]=0;\n\t\t\t\t\t\t\t\tflag=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",score2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst vector<int> dir = { 0, 1, 0, -1 };\nint H, W;\nint main() {\n\tcin >> H >> W;\n\tvector<string> s(H);\n\tvector<int> cx, cy;\n\tfor (int i = 0; i < H; i++) {\n\t\tcin >> s[i];\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (s[i][j] != '.') {\n\t\t\t\tcx.push_back(j);\n\t\t\t\tcy.push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tsort(cx.begin(), cx.end());\n\tcx.erase(unique(cx.begin(), cx.end()), cx.end());\n\tsort(cy.begin(), cy.end());\n\tcy.erase(unique(cy.begin(), cy.end()), cy.end());\n\tH = cy.size() * 2 - 1, W = cx.size() * 2 - 1;\n\tvector<string> t(H, string(W, '.'));\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (s[cy[i]][cx[j]] != '.') t[i * 2][j * 2] = s[cy[i]][cx[j]];\n\t\t}\n\t}\n\tint ret = 0;\n\twhile (true) {\n\t\tbool flag = false;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (t[i][j] != '.') continue;\n\t\t\t\tvector<vector<pair<int, int> > > d(26);\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tint tx = j, ty = i;\n\t\t\t\t\twhile (0 <= tx && tx < W && 0 <= ty && ty < H) {\n\t\t\t\t\t\tif (t[ty][tx] != '.') {\n\t\t\t\t\t\t\td[t[ty][tx] - 65].push_back(make_pair(tx, ty));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttx += dir[k];\n\t\t\t\t\t\tty += dir[k ^ 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int k = 0; k < 26; k++) {\n\t\t\t\t\tif (d[k].size() == 2) {\n\t\t\t\t\t\tflag = true; ret += 2;\n\t\t\t\t\t\tt[d[k][0].second][d[k][0].first] = '.';\n\t\t\t\t\t\tt[d[k][1].second][d[k][1].first] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!flag) break;\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst vector<int> dir = { 0, 1, 0, -1 };\nint H, W;\nint main() {\n\tcin >> H >> W;\n\tvector<string> s(H);\n\tvector<int> cx, cy;\n\tfor (int i = 0; i < H; i++) {\n\t\tcin >> s[i];\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (s[i][j] != '.') {\n\t\t\t\tcx.push_back(j);\n\t\t\t\tcy.push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tsort(cx.begin(), cx.end());\n\tcx.erase(unique(cx.begin(), cx.end()), cx.end());\n\tsort(cy.begin(), cy.end());\n\tcy.erase(unique(cy.begin(), cy.end()), cy.end());\n\tH = cy.size(), W = cx.size();\n\tvector<string> t(H, string(W, '.'));\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (s[cy[i]][cx[j]] != '.') t[i][j] = s[cy[i]][cx[j]];\n\t\t}\n\t}\n\tint ret = 0;\n\twhile (true) {\n\t\tbool flag = false;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (t[i][j] != '.') continue;\n\t\t\t\tvector<vector<pair<int, int> > > d(26);\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tint tx = j, ty = i;\n\t\t\t\t\twhile (0 <= tx && tx < W && 0 <= ty && ty < H) {\n\t\t\t\t\t\tif (t[ty][tx] != '.') {\n\t\t\t\t\t\t\td[t[ty][tx] - 65].push_back(make_pair(tx, ty));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttx += dir[k];\n\t\t\t\t\t\tty += dir[k ^ 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int k = 0; k < 26; k++) {\n\t\t\t\t\tif (d[k].size() == 2) {\n\t\t\t\t\t\tflag = true; ret += 2;\n\t\t\t\t\t\tt[d[k][0].second][d[k][0].first] = '.';\n\t\t\t\t\t\tt[d[k][1].second][d[k][1].first] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!flag) break;\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int H, W; cin >> H >> W;\n  VS vs(H);\n  REP(i,H) cin >> vs[i];\n\n  vector<PII> memo(32, MP(-1,-1));\n  vector<pair<PII,PII>> pos;\n  REP(y,H) REP(x,W){\n\tif(vs[y][x] != '.'){\n\t  int i = vs[y][x] - 'A';\n\t  if(memo[i].first < 0)\n\t\tmemo[i] = MP(x,y);\n\t  else\n\t\tpos.PB(MP(memo[i], MP(x,y)));\n\t}\n  }\n\n  int ans = 0;\n  bool up  = true;\n  while(up){\n\tup = false;\n\n\tfor(int i=0;i<SZ(pos);++i){\n\t  PII p1 = pos[i].first, p2 = pos[i].second;\n\t  if(p1 > p2) swap(p1,p2);\n\t  if((p1.first+1 == p2.first && p1.second == p2.second)\n\t\t || (p1.first == p2.first && abs(p1.second-p2.second)==1)) continue;\n\t  \n\t  bool ok = true;\n\t  for(int j=0;j<SZ(pos);++j){\n\t\tif(i == j) continue;\n\t\tPII q1 = pos[j].first, q2 = pos[j].second;\n\t\tif(((q1.second == p1.second || q1.second == p2.second) && p1.first <= q1.first && q1.first <= p2.first)\n\t\t   && ((q2.second == p1.second || q2.second == p2.second) && p1.first <= q2.first && q2.first <= p2.first)){\n\t\t  ok = false;\n\t\t  break;\n\t\t}\n\t  }\n\t  if(ok){\n\t\tpos.erase(pos.begin() + i);\n\t\tans += 2;\n\t\tup = true;\n\t\tbreak;\n\t  }\n\t}\n  }\n\n  cout << ans << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\nusing namespace std;\n\nint M, N, K;\nchar S[550][550];\nint h, w;\nvector<int> y, x;\nvector<char> c;\nchar s[100][100];\nint dd[5] = { 0, 1, 0, -1, 0 };\n\nint compress(vector<int> &a) {\n  vector<int> v;\n\n  REP(i, 0, a.size()) v.push_back(a[i]);\n  sort(v.begin(), v.end());\n  v.erase(unique(v.begin(), v.end()), v.end());\n  REP(i, 0, a.size()) a[i] = find(v.begin(), v.end(), a[i]) - v.begin();\n\n  return (int) v.size();\n}\n\nbool isin(int y, int x) {\n  return 0 <= y && y < h && 0 <= x && x < w;\n}\n\nint main(void) {\n  cin >> M >> N;\n  K = 0;\n  REP(i, 0, M) REP(j, 0, N) {\n    cin >> S[i][j];\n    if(S[i][j] != '.') {\n      y.push_back(i);\n      x.push_back(j);\n      c.push_back(S[i][j]);\n      K++;\n    }\n  }\n\n  h = compress(y);\n  w = compress(x);\n\n  REP(i, 0, h) REP(j, 0, w) s[i][j] = '.';\n  REP(i, 0, K) {\n    // cout << y[i] << \", \" << x[i] << \": \" << c[i] << endl;\n    s[y[i]][x[i]] = c[i];\n  }\n\n  // REP(i, 0, h) {\n  //   REP(j, 0, w) cout << s[i][j];\n  //   cout << endl;\n  // }\n\n  int ans = 0;\n  bool visited[256];\n  REP(i, 0, 256) visited[i] = false;\n  bool f = true;\n  while(f) {\n    f = false;\n    REP(i, 0, h) REP(j, 0, w) {\n      if(s[i][j] == '.' || visited[s[i][j]]) {\n        int cnt[256];\n        REP(k, 0, 256) cnt[k] = 0;\n        // cout << i << \", \" << j << endl;\n        REP(k, 0, 4) {\n          int ny = i + dd[k], nx = j + dd[k + 1];\n          while(isin(ny, nx)) {\n            // cout << \"  \" << ny << \", \" << nx << \": \" << s[ny][nx] << endl;\n            if(s[ny][nx] != '.' && !visited[s[ny][nx]]) {\n              // cout << s[ny][nx] << endl;\n              cnt[s[ny][nx]]++;\n              if(cnt[s[ny][nx]] == 2) {\n                // cout << \"  vanish: \" << S[ny][nx] << endl;\n                visited[s[ny][nx]] = true;\n                ans += 2;\n                f = true;\n              }\n              break;\n            }\n            ny += dd[k];\n            nx += dd[k + 1];\n          }\n        }\n      }\n    }\n  }\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<tuple>\nusing namespace std;\nchar x[500][500]; int H, W;\nint dx[4] = { 1,0,-1,0 }, dy[4] = { 0,1,0,-1 };\nint main() {\n\tcin >> H >> W;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++)cin >> x[i][j];\n\t}\n\tint CNT = 0;\n\twhile (true) {\n\t\tint cnt = 0;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (x[i][j] != '.')continue;\n\t\t\t\tvector<tuple<char, int, int>>vec;\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tint cx = i, cy = j;\n\t\t\t\t\twhile (cx >= 0 && cx < H && cy >= 0 && cy < W) {\n\t\t\t\t\t\tif (x[cx][cy] != '.') { vec.push_back(make_tuple(x[cx][cy], cx, cy)); break; }\n\t\t\t\t\t\tcx += dx[k]; cy += dy[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int k = 0; k < vec.size(); k++) {\n\t\t\t\t\tfor (int l = k + 1; l < vec.size(); l++) {\n\t\t\t\t\t\tif (get<0>(vec[k]) == get<0>(vec[l])) {\n\t\t\t\t\t\t\tx[get<1>(vec[k])][get<2>(vec[k])] = '.'; cnt++;\n\t\t\t\t\t\t\tx[get<1>(vec[l])][get<2>(vec[l])] = '.'; CNT += 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cnt == 0)break;\n\t}\n\tcout << CNT << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<iomanip>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\n#define int long long\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define INF ((long long)1e18)\n#define MOD ((int)1e9+7)\n#define endl \"\\n\"\n\n#define yn(f) ((f)?\"Yes\":\"No\")\n#define YN(f) ((f)?\"YES\":\"NO\")\n\n#define MAX\n#define NUM 26\n\n#define p1 first\n#define p2 second\n#define y1 first.first\n#define y2 second.first\n#define x1 first.second\n#define x2 second.second\n\nbool check(vector<string> &C, pair<pair<int,int>,pair<int,int>> &p){\n\tif(p.p1 == p.p2) return false;\n\telse if(p.x1 == p.x2) {\n\t\tif(p.y2-p.y1 <= 1) return false;\n\t\tfor(int i = p.y1+1; i < p.y2; i++) if(C[i][p.x1] != '.') return false;\n\t\treturn true;\n\t} else if(p.y1 == p.y2){\n\t\tif(p.x2-p.x1 <= 1) return false;\n\t\tfor(int i = p.x1+1; i < p.x2; i++) if(C[p.y1][i] != '.') return false;\n\t\treturn true;\n\t} else if(p.x1 < p.x2){\n\t\tbool flag = true;\n\t\tfor(int i = p.y1+1; i <= p.y2; i++) if(C[i][p.x1] != '.') flag = false;\n\t\tfor(int i = p.x1+1; i <  p.x2; i++) if(C[p.y2][i] != '.') flag = false;\n\t\tif(flag) return true;\n\t\t\n\t\tfor(int i = p.x1+1; i <=  p.x2; i++) if(C[p.y1][i] != '.') return false;\n\t\tfor(int i = p.y1+1; i < p.y2; i++) if(C[i][p.x2] != '.')   return false;\n\t\t\n\t\treturn true;\n\t} else {\n\t\tbool flag = true;\n\t\tfor(int i = p.y1+1; i <= p.y2; i++) if(C[i][p.x1] != '.') flag = false;\n\t\tfor(int i = p.x2+1; i <  p.x1; i++) if(C[p.y2][i] != '.') flag = false;\n\t\tif(flag) return true;\n\t\t\n\t\tfor(int i = p.x2; i <  p.x1; i++) if(C[p.y1][i] != '.') return false;\n\t\tfor(int i = p.y1+1; i < p.y2; i++) if(C[i][p.x2] != '.')   return false;\n\t\t\n\t\treturn true;\n\t}\n}\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout<<fixed<<setprecision(10);\n\tint ans = 0;\n\tint M, N;\n\tbool hoge[NUM] = {};\n\tvector<string> C;\n\tpair<pair<int,int>,pair<int,int>> point[NUM];\n\t\n\tcin>>M>>N;\n\t\n\tC.resize(M);\n\t\n\tfor(int i = 0; i < M; i++){\n\t\tcin>>C[i];\n\t\tfor(int j = 0; j < N; j++){\n\t\t\tif(C[i][j] != '.'){\n\t\t\t\t// cout<<i<<\" \"<<j<<\" \"<<C[i][j]<<endl;\n\t\t\t\thoge[C[i][j] - 'A'] = true;\n\t\t\t\tif(point[C[i][j] - 'A'].second.first == -1){\n\t\t\t\t\tpoint[C[i][j] - 'A'].second.first  = i;\n\t\t\t\t\tpoint[C[i][j] - 'A'].second.second = j;\n\t\t\t\t} else {\n\t\t\t\t\tpoint[C[i][j] - 'A'].first.first  = i;\n\t\t\t\t\tpoint[C[i][j] - 'A'].first.second = j;\n\t\t\t\t\tpoint[C[i][j] - 'A'].second.first = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < NUM; i++){\n\t\tif(!hoge[i]) continue;\n\t\tif(point[i].p1 > point[i].p2) swap(point[i].p1, point[i].p2);\n\t\t// cout<<i<<\" \"<<point[i].y1<<\" \"<<point[i].x1<<\"  \"<<point[i].y2<<\" \"<<point[i].x2<<endl;\n\t}\n\t\n\twhile(true){\n\t\tbool flag = false;\n\t\tfor(int i = 0; i < NUM; i++){\n\t\t\tif(!hoge[i]) continue;\n\t\t\tif(check(C,point[i])){\n\t\t\t\tflag = true;\n\t\t\t\thoge[i] = false;\n\t\t\t\tC[point[i].y1][point[i].x1] = '.';\n\t\t\t\tC[point[i].y2][point[i].x2] = '.';\n\t\t\t\tans += 2;\n\t\t\t}\n\t\t}\n\t\tif(!flag) break;\n\t}\n\t\n\tcout<<ans<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nint main() {\n  int m,n;\n  cin>>m>>n;\n  vector<string> t(m);\n  REP(i,m)cin>>t[i];\n  vector<int> iv,jv;\n  REP(i,m) {\n    bool al = true;\n    REP(j,n) if(t[i][j] != '.') al = false;\n    if(!al){\n      if(i) iv.push_back(i-1);\n      iv.push_back(i);\n      if(i<m-1) iv.push_back(i+1);\n    }\n  }\n  iv.erase(unique(begin(iv),end(iv)),end(iv));\n  REP(i,n) {\n    bool al = true;\n    REP(j,m) if(t[j][m] != '.') al = false;\n    if(!al){\n      if(i) jv.push_back(i-1);\n      jv.push_back(i);\n      if(i<n-1) jv.push_back(i+1);\n    }\n  }\n  jv.erase(unique(begin(jv),end(jv)),end(jv));\n  if (iv.empty()) {\n    cout << 0 << endl;\n    return 0;\n  }\n  vector<string> ct(iv.size());\n  m = iv.size();\n  n = jv.size();\n  REP(i,m)\n    REP(j,n)\n      ct[i] += t[iv[i]][jv[j]];\n  int score = 0;\n  while(1){\n    set<char> er;\n    REP(i,m)REP(j,n){\n      if (ct[i][j] != '.') continue;\n      map<char, int> s;\n      int di[]={1,0,-1,0};\n      int dj[]={0,1,0,-1};\n      REP(k,4){\n        int l=1;\n        while(1){\n          int ni=i+di[k]*l;\n          int nj=j+dj[k]*l;\n          if(ni<0||nj<0||ni>=m||nj>=n) break;\n          if(ct[ni][nj] != '.'){\n            ++s[ct[ni][nj]];\n            break;\n          }\n          ++l;\n        }\n      }\n      for (auto p:s) {\n        if(p.second == 2) er.insert(p.first);\n      }\n    }\n    score += er.size()*2;\n    if (er.empty()) break;\n    REP(i,m)REP(j,n){\n      if(er.count(ct[i][j]))\n        ct[i][j] = '.';\n    }\n  }\n  cout << score << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tint h,w;\n\tcin >> h >> w;\n\tvector<vector<char> > map(h, vector<char>(w));\n\tvector<vector<pair<int,int> > > place(26);\n\tvector<int> exist(26, false);\n\tfor(int i=0; i<h; i++){\n\t\tfor(int j=0; j<w; j++){\n\t\t\tcin >> map[i][j];\n\t\t\tif(map[i][j]!='.'){\n\t\t\t\tplace[map[i][j]-'A'].push_back(make_pair(i,j));\n\t\t\t\texist[map[i][j]-'A'] = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbool nochange = false;\n\tint score = 0;\n\twhile(!nochange){\n\t\tnochange = true;\n\t\tfor(int i=0; i<='Z'-'A'; i++){\n\t\t\tif(!exist[i]) continue;\n\t\t\tint x1 = place[i][0].first, y1 = place[i][0].second;\n\t\t\tint x2 = place[i][1].first, y2 = place[i][1].second;\n\t\t\tbool success = true;\n\t\t\tbool tap = false;\n\t\t\tif(x1 == x2){\n\t\t\t\tfor(int j=min(y1,y2)+1; j<max(y1,y2); j++){\n\t\t\t\t\tif(map[x1][j]=='.'){\n\t\t\t\t\t\ttap=true;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsuccess = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if(y1 == y2){\n\t\t\t\tfor(int j=min(x1,x2)+1; j<max(x1,x2); j++){\n\t\t\t\t\tif(map[j][y1]=='.'){\n\t\t\t\t\t\ttap=true;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsuccess = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\ttap = true;\n\t\t\t\tfor(int j=min(y1,y2)+1; j<max(y1,y2); j++){\n\t\t\t\t\tif(map[x1][j]!='.'){\n\t\t\t\t\t\tsuccess = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j=min(x1,x2)+1; j<max(x1,x2); j++){\n\t\t\t\t\tif(map[j][y2]!='.'){\n\t\t\t\t\t\tsuccess = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(map[x1][y2]!='.'){\n\t\t\t\t\tsuccess = false;\n\t\t\t\t}\n\t\t\t\tif(!success){\n\t\t\t\t\tsuccess = true;\n\t\t\t\t\tfor(int j=min(y1,y2)+1; j<max(y1,y2); j++){\n\t\t\t\t\t\tif(map[x2][j]!='.'){\n\t\t\t\t\t\t\tsuccess = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int j=min(x1,x2)+1; j<max(x1,x2); j++){\n\t\t\t\t\t\tif(map[j][y1]!='.'){\n\t\t\t\t\t\t\tsuccess = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(map[x2][y1]!='.'){\n\t\t\t\t\t\tsuccess = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(success && tap){\n\t\t\t\tscore += 2;\n\t\t\t\tmap[x1][y1] = map[x2][y2] = '.';\n\t\t\t\texist[i] = false;\n\t\t\t\tnochange = false;\n\t\t\t}\n\t\t}\n\t}\n\tcout << score << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nint main(){\n  int n;\n \n      string s;\n      int n,m;\n      while(cin >> n >> m){\n      cerr << n << m << endl;\n      for(int i=0;i<n;i++){\n\tcin >> s;\n\tcerr << s << endl;\n      }\n      cout << \"3\" << endl;\n\t    }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nint H,W;\n\nstruct Info{\n\tInfo(){\n\t\trow = col = 0;\n\t\texist = false;\n\t}\n\tInfo(int arg_row,int arg_col,bool arg_exist){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\texist = arg_exist;\n\t}\n\n\tvoid set(int arg_row,int arg_col,bool arg_exist){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\texist = arg_exist;\n\t}\n\tint row,col;\n\tbool exist;\n};\n\nint main(){\n\n\tscanf(\"%d %d\",&H,&W);\n\tchar map[H][W+1];\n\n\tInfo info[26][2];\n\tfor(int i = 0; i < 26; i++){\n\t\tfor(int k = 0; k < 2; k++){\n\t\t\tinfo[i][k].exist = false;\n\t\t}\n\t}\n\n\tvector<Info> V_ROW[500],V_COL[500];\n\tint maximum = 0;\n\n\tfor(int i = 0; i < H; i++){\n\t\tscanf(\"%s\",map[i]);\n\t\tfor(int k = 0; k < W; k++){\n\t\t\tswitch(map[i][k]){\n\t\t\tcase '.':\n\t\t\t\tV_ROW[i].push_back(Info(i,k,false));\n\t\t\t\tV_COL[i].push_back(Info(i,k,false));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif(info[map[i][k]-'A'][0].exist == false){\n\t\t\t\t\tinfo[map[i][k]-'A'][0].exist = true;\n\t\t\t\t\tinfo[map[i][k]-'A'][0].set(i,k,true);\n\t\t\t\t\tmaximum++;\n\t\t\t\t}else{\n\t\t\t\t\tinfo[map[i][k]-'A'][1].set(i,k,true);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0,common_row,common_col,small,big;\n\tbool FLG,erasableFLG;\n\n\twhile(true){\n\n\t\tFLG = false;\n\n\t\tfor(int i = 0; i < 26; i++){\n\t\t\tif(info[i][0].exist){\n\t\t\t\tif(info[i][0].row == info[i][1].row){\n\n\t\t\t\t\tcommon_row = info[i][0].row;\n\t\t\t\t\tif(info[i][0].col > info[i][1].col){\n\t\t\t\t\t\tsmall = info[i][1].col;\n\t\t\t\t\t\tbig = info[i][0].col;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsmall = info[i][0].col;\n\t\t\t\t\t\tbig = info[i][1].col;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int a = 0;a < V_ROW[common_row].size();a++){\n\t\t\t\t\t\tif(V_ROW[common_row][a].col > small && V_ROW[common_row][a].col < big){\n\n\t\t\t\t\t\t\terasableFLG = false;\n\n\t\t\t\t\t\t\tfor(int tmp_col = V_ROW[common_row][a].col; tmp_col >= 0 ;tmp_col--){\n\t\t\t\t\t\t\t\tif(map[common_row][tmp_col] != '.'){\n\t\t\t\t\t\t\t\t\tif(map[common_row][tmp_col] == 'A' + i){\n\t\t\t\t\t\t\t\t\t\terasableFLG = true;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!erasableFLG)continue;\n\n\t\t\t\t\t\t\terasableFLG = false;\n\n\t\t\t\t\t\t\tfor(int tmp_col = V_ROW[common_row][a].col; tmp_col <= W-1 ;tmp_col++){\n\t\t\t\t\t\t\t\tif(map[common_row][tmp_col] != '.'){\n\t\t\t\t\t\t\t\t\tif(map[common_row][tmp_col] == 'A' + i){\n\t\t\t\t\t\t\t\t\t\terasableFLG = true;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!erasableFLG)continue;\n\n\t\t\t\t\t\t\tmap[common_row][info[i][0].col] = '.';\n\t\t\t\t\t\t\tmap[common_row][info[i][1].col] = '.';\n\t\t\t\t\t\t\tV_ROW[common_row].push_back(Info(common_row,info[i][0].col,false));\n\t\t\t\t\t\t\tV_ROW[common_row].push_back(Info(common_row,info[i][1].col,false));\n\t\t\t\t\t\t\tV_COL[info[i][0].col].push_back(Info(common_row,info[i][0].col,false));\n\t\t\t\t\t\t\tV_COL[info[i][1].col].push_back(Info(common_row,info[i][1].col,false));\n\t\t\t\t\t\t\tinfo[i][0].exist = false;\n\t\t\t\t\t\t\tans += 2;\n\t\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}else if(info[i][0].col == info[i][1].col){ //info[i][0].col == info[i][1].col\n\n\t\t\t\t\tcommon_col = info[i][0].col;\n\t\t\t\t\tif(info[i][0].row > info[i][1].row){\n\t\t\t\t\t\tsmall = info[i][1].row;\n\t\t\t\t\t\tbig = info[i][0].row;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsmall = info[i][0].row;\n\t\t\t\t\t\tbig = info[i][1].row;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int a = 0;a < V_COL[common_col].size();a++){\n\t\t\t\t\t\tif(V_COL[common_col][a].row > small && V_COL[common_col][a].row < big){\n\n\t\t\t\t\t\t\terasableFLG = false;\n\n\t\t\t\t\t\t\tfor(int tmp_row = V_COL[common_col][a].row; tmp_row >= 0 ;tmp_row--){\n\t\t\t\t\t\t\t\tif(map[tmp_row][common_col] != '.'){\n\t\t\t\t\t\t\t\t\tif(map[tmp_row][common_col] == 'A' + i){\n\t\t\t\t\t\t\t\t\t\terasableFLG = true;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!erasableFLG)continue;\n\n\t\t\t\t\t\t\terasableFLG = false;\n\n\t\t\t\t\t\t\tfor(int tmp_row = V_COL[common_col][a].row; tmp_row <= H-1 ;tmp_row++){\n\t\t\t\t\t\t\t\tif(map[tmp_row][common_col] != '.'){\n\t\t\t\t\t\t\t\t\tif(map[tmp_row][common_col] == 'A' + i){\n\t\t\t\t\t\t\t\t\t\terasableFLG = true;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!erasableFLG)continue;\n\n\t\t\t\t\t\t\tmap[info[i][0].row][common_col] = '.';\n\t\t\t\t\t\t\tmap[info[i][1].row][common_col] = '.';\n\t\t\t\t\t\t\tV_ROW[info[i][0].row].push_back(Info(info[i][0].row,common_col,false));\n\t\t\t\t\t\t\tV_ROW[info[i][1].row].push_back(Info(info[i][1].row,common_col,false));\n\t\t\t\t\t\t\tV_COL[common_col].push_back(Info(info[i][0].row,common_col,false));\n\t\t\t\t\t\t\tV_COL[common_col].push_back(Info(info[i][1].row,common_col,false));\n\t\t\t\t\t\t\tinfo[i][0].exist = false;\n\t\t\t\t\t\t\tans += 2;\n\t\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}else{\n\n\t\t\t\t\tif(map[info[i][0].row][info[i][1].col] == '.'){\n\n\t\t\t\t\t\terasableFLG = false;\n\n\t\t\t\t\t\tif(info[i][0].col > info[i][1].col){\n\n\t\t\t\t\t\t\tfor(int tmp_col = info[i][1].col+1; tmp_col <= W-1; tmp_col++){\n\t\t\t\t\t\t\t\tif(map[info[i][0].row][tmp_col] != '.'){\n\t\t\t\t\t\t\t\t\tif(map[info[i][0].row][tmp_col] == 'A' + i){\n\t\t\t\t\t\t\t\t\t\terasableFLG = true;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!erasableFLG)continue;\n\n\t\t\t\t\t\t}else{\n\n\t\t\t\t\t\t\tfor(int tmp_col = info[i][1].col-1; tmp_col >= 0; tmp_col--){\n\t\t\t\t\t\t\t\tif(map[info[i][0].row][tmp_col] != '.'){\n\t\t\t\t\t\t\t\t\tif(map[info[i][0].row][tmp_col] == 'A' + i){\n\t\t\t\t\t\t\t\t\t\terasableFLG = true;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!erasableFLG)continue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\terasableFLG = false;\n\n\t\t\t\t\t\tif(info[i][0].row > info[i][1].row){\n\n\t\t\t\t\t\t\tfor(int tmp_row = info[i][0].row-1; tmp_row >= 0; tmp_row--){\n\t\t\t\t\t\t\t\tif(map[tmp_row][info[i][1].col] != '.'){\n\t\t\t\t\t\t\t\t\tif(map[tmp_row][info[i][1].col] == 'A' + i){\n\t\t\t\t\t\t\t\t\t\terasableFLG = true;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!erasableFLG)continue;\n\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tfor(int tmp_row = info[i][0].row+1; tmp_row <= H-1; tmp_row++){\n\t\t\t\t\t\t\t\tif(map[tmp_row][info[i][1].col] != '.'){\n\t\t\t\t\t\t\t\t\tif(map[tmp_row][info[i][1].col] == 'A' + i){\n\t\t\t\t\t\t\t\t\t\terasableFLG = true;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!erasableFLG)continue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmap[info[i][0].row][info[i][0].col] = '.';\n\t\t\t\t\t\tmap[info[i][1].row][info[i][1].col] = '.';\n\t\t\t\t\t\tV_ROW[info[i][0].row].push_back(Info(info[i][0].row,info[i][0].col,false));\n\t\t\t\t\t\tV_ROW[info[i][1].row].push_back(Info(info[i][1].row,info[i][1].col,false));\n\t\t\t\t\t\tV_COL[info[i][0].col].push_back(Info(info[i][0].row,info[i][0].col,false));\n\t\t\t\t\t\tV_COL[info[i][1].col].push_back(Info(info[i][1].row,info[i][1].col,false));\n\t\t\t\t\t\tinfo[i][0].exist = false;\n\t\t\t\t\t\tans += 2;\n\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t}else if(map[info[i][1].row][info[i][0].col] == '.'){\n\t\t\t\t\t\terasableFLG = false;\n\n\t\t\t\t\t\tif(info[i][1].col > info[i][0].col){\n\n\t\t\t\t\t\t\tfor(int tmp_col = info[i][0].col+1; tmp_col <= W-1; tmp_col++){\n\t\t\t\t\t\t\t\tif(map[info[i][1].row][tmp_col] != '.'){\n\t\t\t\t\t\t\t\t\tif(map[info[i][1].row][tmp_col] == 'A' + i){\n\t\t\t\t\t\t\t\t\t\terasableFLG = true;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!erasableFLG)continue;\n\n\t\t\t\t\t\t}else{\n\n\t\t\t\t\t\t\tfor(int tmp_col = info[i][0].col-1; tmp_col >= 0; tmp_col--){\n\t\t\t\t\t\t\t\tif(map[info[i][1].row][tmp_col] != '.'){\n\t\t\t\t\t\t\t\t\tif(map[info[i][1].row][tmp_col] == 'A' + i){\n\t\t\t\t\t\t\t\t\t\terasableFLG = true;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!erasableFLG)continue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\terasableFLG = false;\n\n\t\t\t\t\t\tif(info[i][1].row > info[i][0].row){\n\n\t\t\t\t\t\t\tfor(int tmp_row = info[i][1].row-1; tmp_row >= 0; tmp_row--){\n\t\t\t\t\t\t\t\tif(map[tmp_row][info[i][0].col] != '.'){\n\t\t\t\t\t\t\t\t\tif(map[tmp_row][info[i][0].col] == 'A' + i){\n\t\t\t\t\t\t\t\t\t\terasableFLG = true;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!erasableFLG)continue;\n\n\t\t\t\t\t\t}else{\n\n\t\t\t\t\t\t\tfor(int tmp_row = info[i][1].row+1; tmp_row <= H-1; tmp_row++){\n\t\t\t\t\t\t\t\tif(map[tmp_row][info[i][0].col] != '.'){\n\t\t\t\t\t\t\t\t\tif(map[tmp_row][info[i][0].col] == 'A' + i){\n\t\t\t\t\t\t\t\t\t\terasableFLG = true;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!erasableFLG)continue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//?¶???????\n\t\t\t\t\t\tmap[info[i][0].row][info[i][0].col] = '.';\n\t\t\t\t\t\tmap[info[i][1].row][info[i][1].col] = '.';\n\t\t\t\t\t\tV_ROW[info[i][0].row].push_back(Info(info[i][0].row,info[i][0].col,false));\n\t\t\t\t\t\tV_ROW[info[i][1].row].push_back(Info(info[i][1].row,info[i][1].col,false));\n\t\t\t\t\t\tV_COL[info[i][0].col].push_back(Info(info[i][0].row,info[i][0].col,false));\n\t\t\t\t\t\tV_COL[info[i][1].col].push_back(Info(info[i][1].row,info[i][1].col,false));\n\t\t\t\t\t\tinfo[i][0].exist = false;\n\t\t\t\t\t\tans += 2;\n\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(!FLG)break;\n\t\tif(ans >= 2*maximum)break;\n\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<double,int,double> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nDef inf=sizeof(Def)==sizeof(long long)?2e18:1e9;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint MOD;\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tvs in(n);\n\trep(i,n)cin>>in[i];\n\tint out=0;\n\twhile(1){\n\t\tbool h=false;\n\t\trep(i,n)rep(j,m)if(in[i][j]=='.'){\n\t\t\tvi find(26,-1);\n\t\t\trep(k,4){\n\t\t\t\tint x=i,y=j;\n\t\t\t\twhile(0<=x&&x<n&&0<=y&&y<m&&in[x][y]=='.')x+=dx[k],y+=dy[k];\n\t\t\t\tif(0<=x&&x<n&&0<=y&&y<m){\n\t\t\t\t\tint t=in[x][y]-'A';\n\t\t\t\t\tif(find[t]==-1)find[t]=x*m+y;\n\t\t\t\t\telse{\n\t\t\t\t\t\th=true;\n\t\t\t\t\t\tout+=2;\n\t\t\t\t\t\tin[x][y]='.';\n\t\t\t\t\t\tin[find[t]/m][find[t]%m]='.';\n\t\t\t\t\t\tfind[t]=-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!h)break;\n\t}\n\tcout<<out<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<class Tuple, unsigned Index>\nvoid print_tuple(ostream& os, const Tuple& t) {}\n\ntemplate<class Tuple, unsigned Index, class Type, class... Types>\nvoid print_tuple(ostream& os, const Tuple& t) {\n\tif(Index > 0) os << \", \";\n\tos << get<Index>(t);\n\tprint_tuple<Tuple, Index + 1, Types...>(os, t);\n}\n\ntemplate<class... Types>\nostream& operator<<(ostream& os, const tuple<Types...>& t) {\n\tos << '(';\n\tprint_tuple<tuple<Types...>, 0, Types...>(os, t);\n\treturn os << ')';\n}\n\ntemplate<class Iterator>\nostream& dump_range(ostream&, Iterator, const Iterator&);\n\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T> c) {\n\treturn dump_range(os, c.cbegin(), c.cend());\n}\n\ntemplate<class Iterator>\nostream& dump_range(ostream& os, Iterator first, const Iterator& last) {\n\tos << '[';\n\tfor(int i = 0; first != last; ++i, ++first) {\n\t\tif(i) os << \", \";\n\t\tos << *first;\n\t}\n\treturn os << ']';\n}\n\ntypedef complex<int> point;\n#define X real()\n#define Y imag()\n\nbool operator<(const point& a, const point& b) {\n\treturn a.X != b.X ? a.X < b.X : a.Y < b.Y;\n}\n\ninline int dist2(const point& a, const point& b) {\n\tconst int diffX = a.X - b.X;\n\tconst int diffY = a.Y - b.Y;\n\treturn diffX * diffX + diffY * diffY;\n}\n\ninline double dist(const point& a, const point& b) {\n\treturn sqrt(dist2(a, b));\n}\n\nint calc(const vector<string>& board, point start, point to) {\n\tpoint d = (to - start) / static_cast<int>(dist(to, start));\n\tint res = 0;\n\tpoint current = start;\n\n\twhile(current != to) {\n\t\tif(board[current.Y][current.X] != '.') res |= (1 << (board[current.Y][current.X] - 'A'));\n\t\tcurrent += d;\n\t}\n\n\treturn res;\n}\n\nvoid update(queue<int>& que, vector<pair<int, int>>& can_erase, int value) {\n\tvalue = ~value;\n\n\tfor(int i = 0; i < static_cast<int>(can_erase.size());) {\n\t\tcan_erase[i].first &= value;\n\t\tif(can_erase[i].first == 0) {\n\t\t\tque.push(can_erase[i].second);\n\t\t\tcan_erase.erase(can_erase.begin() + i);\n\t\t}\n\t\telse {\n\t\t\t++i;\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint h, w;\n\tcin >> h >> w;\n\n\tvector<string> board(h);\n\tfor(int i = 0; i < h; ++i) {\n\t\tcin >> board[i];\n\t}\n\n\tvector<vector<point>> tiles(26);\n\tfor(int i = 0; i < h; ++i) {\n\t\tfor(int j = 0; j < w; ++j) {\n\t\t\tif(board[i][j] != '.') {\n\t\t\t\ttiles[board[i][j] - 'A'].emplace_back(j, i);\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<bool> used(26, true);\n\tvector<pair<int, int>> can_erase;\n\n\tfor(int i = 0; i < 26; ++i) {\n\t\tif(tiles[i].size() == 0 || dist2(tiles[i][0], tiles[i][1]) == 1.0) continue;\n\n\t\tused[i] = false;\n\t\tif(tiles[i][1] < tiles[i][0]) swap(tiles[i][0], tiles[i][1]);\n\n\t\tif(tiles[i][0].X == tiles[i][1].X) {\n\t\t\tcan_erase.emplace_back(calc(board, tiles[i][0] + point(0, 1), tiles[i][1]), i);\n\t\t}\n\t\telse if(tiles[i][0].Y == tiles[i][1].Y) {\n\t\t\tcan_erase.emplace_back(calc(board, tiles[i][0] + point(1, 0), tiles[i][1]), i);\n\t\t}\n\t\telse {\n\t\t\tpoint start(tiles[i][0].X, tiles[i][1].Y);\n\t\t\tint obstacle = calc(board, start, tiles[i][0]);\n\t\t\tobstacle |= calc(board, start, tiles[i][1]);\n\t\t\tcan_erase.emplace_back(obstacle, i);\n\n\t\t\tstart = point(tiles[i][1].X, tiles[i][0].Y);\n\t\t\tobstacle = calc(board, start, tiles[i][0]);\n\t\t\tobstacle |= calc(board, start, tiles[i][1]);\n\t\t\tcan_erase.emplace_back(obstacle, i);\n\t\t}\n\t}\n\n\tqueue<int> que;\n\tupdate(que, can_erase, 0);\n\n\tint ans = 0;\n\twhile(!que.empty()) {\n\t\tint color = que.front();\n\t\tque.pop();\n\n\t\tif(used[color]) continue;\n\t\tused[color] = true;\n\t\t++ans;\n\n\t\tupdate(que, can_erase, (1 << color));\n\t}\n\n\tcout << ans * 2 << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nconst int INF = 1 << 30;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nclass Point\n{\npublic:\n  int x, y;\n  Point()\n    :x(INF), y(INF) {}\n};\n\nint main()\n{\n  int M, N;\n  while (cin >> M >> N) {\n    vector<string> C(M);\n    for (int i = 0; i < M; ++i)\n      cin >> C[i];\n\n    vector<pair<set<char>, set<char> > > depends(26);\n\n    for (char tar = 'A'; tar <= 'Z'; ++tar) {\n      Point p1, p2;\n      for (int y = 0; y < M; ++y) {\n\tfor (int x = 0; x < N; ++x) {\n\t  if (C[y][x] == tar) {\n\t    if (p1.x == INF && p1.y == INF) {\n\t      p1.x = x;\n\t      p1.y = y;\n\t    } else {\n\t      p2.x = x;\n\t      p2.y = y;\n\t    }\n\t  }\n\t}\n      }\n   \n      if ((p1.x == INF && p1.y == INF) ||\n\t  (p1.x == p2.x && abs(p1.y-p2.y) == 1) ||\n\t  (p1.y == p2.y && abs(p1.x-p2.x) == 1)) {\n\tdepends[tar-'A'].first.insert('#');\n\tdepends[tar-'A'].second .insert('#');\n\tcontinue;\n      }\n\n      \n      set<char> c1, c2;\n      \n      for (int x = min(p1.x, p2.x); x <= max(p1.x, p2.x); ++x) {\n\tc1.insert(C[p1.y][x]);\n\tc2.insert(C[p2.y][x]);\n      }\n      for (int y = p1.y; y <= p2.y; ++y) {\n\tif (p1.x < p2.x) {\n\t  c1.insert(C[y][p2.x]);\n\t  c2.insert(C[y][p1.x]);\n\t} else {\n\t  c1.insert(C[y][p2.x]);\n\t  c2.insert(C[y][p1.x]);\n\t}\n      }\n\n      c1.erase(c1.find(tar));\n      c2.erase(c2.find(tar));\n\n      depends[tar-'A'].first  = c1;\n      depends[tar-'A'].second = c2;\n    }\n\n    \n    vector<char> root;\n    for (unsigned int i = 0; i < depends.size(); ++i) {\n      if ((depends[i].first.size() == 1 && depends[i].first.find('.') != depends[i].first.end()) || \n\t  (depends[i].second.size() == 1 && depends[i].second.find('.') != depends[i].second.end())) {\n\troot.push_back(static_cast<char>(i + 'A'));\n\tdepends[i].first.clear();\n\tdepends[i].second.clear();\n\tdepends[i].first.insert('#');\n\tdepends[i].second.insert('#');\n      }\n    }\n    \n    int ans = 0;\n    while (!root.empty()) {\n      ans += 2;\n      char front = root.front();\n      root.erase(root.begin());\n\n      for (unsigned int i = 0; i < depends.size(); ++i) {\n\tif (depends[i].first.find(front) != depends[i].first.end())\n\t  depends[i].first.erase((depends[i].first.find(front)));\n\tif (depends[i].second.find(front) != depends[i].second.end())\n\t  depends[i].second.erase((depends[i].second.find(front)));\n\tif ((depends[i].first.empty() || depends[i].first.size() == 1 && depends[i].first.find('.') != depends[i].first.end()) || \n\t    (depends[i].second.empty() || depends[i].second.size() == 1 && depends[i].second.find('.') != depends[i].second.end())) {\n\t  root.push_back(static_cast<char>(i + 'A'));\n\t  depends[i].first.clear();\n\t  depends[i].second.clear();\n\t  depends[i].first.insert('#');\n\t  depends[i].second.insert('#');\n\t}\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing i64 = long long;\nconst i64 MOD = 1e9+7;\nconst i64 INF = 1e18+7;\n\n\ntemplate <typename T>\nbool chmin(T& x, T y){\n    if(x > y){\n        x = y;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool chmax(T& x, T y){\n    if(x < y){\n        x = y;\n        return true;\n    }\n    return false;\n}\n\n\nbool solve(){\n    int h, w;\n    cin >> h >> w;\n    vector<string> s(h);\n    for(auto& x : s)\n        cin >> x;\n    vector<vector<pair<int,int>>> v(26);\n    for(int i = 0; i < h; ++i)\n        for(int j = 0; j < w; ++j){\n            if(s[i][j] != '.'){\n                v[s[i][j] - 'A'].emplace_back(i, j);\n            }\n        }\n\n    auto check = [&](int i){\n        int sx = min(v[i][0].first, v[i][1].first);\n        int sy = min(v[i][0].second, v[i][1].second);\n        int ex = max(v[i][0].first, v[i][1].first);\n        int ey = max(v[i][0].second, v[i][1].second);\n        if(abs(sx - ex) + abs(sy - ey) == 1)\n            return false;\n        if(sx == ex){\n            bool fl = true;\n            for(int y = sy + 1; y < ey; ++y)\n                if(s[sx][y] != '.'){\n                    fl = false;\n                    break;\n                }\n            if(fl)\n                return true;\n        }\n        else if(sy == ey){\n            bool fl = true;\n            for(int x = sx + 1; x < ex; ++x)\n                if(s[x][sy] != '.'){\n                    fl = false;\n                    break;\n                }\n            if(fl)\n                return true;\n        }\n        else if(min(v[i][0], v[i][1]) == make_pair(sx, sy)){\n            bool fl = true;\n            for(int x = sx + 1; x <= ex; ++x)\n                if(s[x][sy] != '.'){\n                    fl = false;\n                    break;\n                }\n            for(int y = sy + 1; y < ey; ++y)\n                if(s[ex][y] != '.'){\n                    fl = false;\n                    break;\n                }\n            if(fl)\n                return true;\n            fl = true;\n            for(int x = sx; x < ex; ++x)\n                if(s[x][ey] != '.'){\n                    fl = false;\n                    break;\n                }\n            for(int y = sy + 1; y < ey; ++y)\n                if(s[sx][y] != '.'){\n                    fl = false;\n                    break;\n                }\n            if(fl)\n                return true;\n        }\n        else{\n            bool fl = true;\n            for(int x = sx + 1; x < ex; ++x)\n                if(s[x][sy] != '.'){\n                    fl = false;\n                    break;\n                }\n            for(int y = sy; y < ey; ++y)\n                if(s[sx][y] != '.'){\n                    fl = false;\n                    break;\n                }\n            if(fl)\n                return true;\n            fl = true;\n            for(int x = sx + 1; x <= ex; ++x)\n                if(s[x][ey] != '.'){\n                    fl = false;\n                    break;\n                }\n            for(int y = sy + 1; y < ey; ++y)\n                if(s[ex][y] != '.'){\n                    fl = false;\n                    break;\n                }\n            if(fl)\n                return true;\n        }\n        return false;\n    };\n\n    bool fl = true;\n    int ans = 0;\n    while(fl){\n        fl = false;\n        for(int i = 0; i < 26; ++i)\n            if(!v[i].empty()){\n                if(check(i)){\n                    fl = true;\n                    for(auto& p : v[i])\n                        s[p.first][p.second] = '.';\n                    v[i].clear();\n                    ans += 2;\n                    break;\n                }\n            }\n\n        /*\n        for(auto& x : s)\n            cout << x << endl;\n        cout << endl;\n         */\n    }\n    cout << ans << endl;\n\n    return false;\n}\n\n\nsigned main(){\n    while(solve());\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint m,n;\nvector<P> data[30];\nvector<int> xindex;\nvector<int> yindex;\nint fie[180][180];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint pickl[4];\nint picklx[4];\nint pickly[4];\n\nint main(void){\n\tscanf(\"%d %d\",&n,&m);\n\tfor(int i=0;i<n;i++){\n\t\tstring str;\n\t\tcin >> str;\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(str[j]>='A' && str[j]<='Z'){\n\t\t\t\tdata[str[j]-'A'+1].push_back(P(j,i));\n\t\t\t\tif(j-1>=0)xindex.push_back(j-1);\n\t\t\t\txindex.push_back(j);\n\t\t\t\tif(j+1<m)xindex.push_back(j+1);\n\t\t\t\tif(i-1>=0)yindex.push_back(i-1);\n\t\t\t\tyindex.push_back(i);\n\t\t\t\tif(i+1<n)yindex.push_back(i+1);\n\t\t\t}\n\t\t}\n\t}\n\tsort(xindex.begin(),xindex.end());\n\txindex.erase(unique(xindex.begin(),xindex.end()),xindex.end());\n\tsort(yindex.begin(),yindex.end());\n\tyindex.erase(unique(yindex.begin(),yindex.end()),yindex.end());\n\tfor(int i=1;i<=26;i++){\n\t\tfor(int j=0;j<data[i].size();j++){\n\t\t\tdata[i][j].first=lower_bound(xindex.begin(),xindex.end(),data[i][j].first)-xindex.begin();\n\t\t\tdata[i][j].second=lower_bound(yindex.begin(),yindex.end(),data[i][j].second)-yindex.begin();\n\t\t\tfie[data[i][j].first][data[i][j].second]=i;\n\t\t}\n\t}\n\tbool flag=true;\n\tint score=0;\n\twhile(flag){\n\t\tflag=false;\n\t\tfor(int i=0;i<yindex.size();i++){\n\t\t\tfor(int j=0;j<xindex.size();j++){\n\t\t\t\tif(fie[j][i]==0){\n\t\t\t\t\tmemset(pickl,0,sizeof(pickl));\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tint xx=j,yy=i;\n\t\t\t\t\t\twhile(xx>=0 && xx<xindex.size() && yy>=0 && yy<yindex.size()){\n\t\t\t\t\t\t\tif(fie[xx][yy]!=0)break;\n\t\t\t\t\t\t\txx+=dx[k];\n\t\t\t\t\t\t\tyy+=dy[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(fie[xx][yy]!=0){\n\t\t\t\t\t\t\tpickl[k]=fie[xx][yy];\n\t\t\t\t\t\t\tpicklx[k]=xx;\n\t\t\t\t\t\t\tpickly[k]=yy;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tfor(int l=k+1;l<4;l++){\n\t\t\t\t\t\t\tif(pickl[k]==pickl[l] && pickl[k]!=0){\n\t\t\t\t\t\t\t\tscore+=2;\n\t\t\t\t\t\t\t\tfie[picklx[k]][pickly[k]]=0;\n\t\t\t\t\t\t\t\tfie[picklx[l]][pickly[l]]=0;\n\t\t\t\t\t\t\t\tflag=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",score);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #ifdef DEBUG\n// #define _GLIBCXX_DEBUG\n// #endif\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <valarray>\n#include <map>\n#include <set>\n#include <list>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <complex>\n#include <string>\n#include <sstream>\n\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n\n// these require C++11\n#include <unordered_set>\n#include <unordered_map>\n#include <random>\n#include <thread>\n#include <chrono>\n\nusing namespace std;\n\n#define int long long\n\n#define all(c) c.begin(), c.end()\n#define repeat(i, n) for (int i = 0; i < static_cast<int>(n); i++)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x) \n#endif\n\ntemplate<typename A,typename B>\nostream &operator<<(ostream&os,const pair<A,B>& p){\n    os << \"(\" << p.first << \",\" << p.second << \")\";\n    return os;\n}\n\n// Define a type which holds an unsigned integer value \ntemplate<std::size_t> struct int_{};\ntemplate <class Tuple, size_t Pos>\nstd::ostream& print_tuple(std::ostream& out, const Tuple& t, int_<Pos> ) {\n  out << std::get< std::tuple_size<Tuple>::value-Pos >(t) << ',';\n  return print_tuple(out, t, int_<Pos-1>());\n}\n \ntemplate <class Tuple>\nstd::ostream& print_tuple(std::ostream& out, const Tuple& t, int_<1> ) {\n  return out << std::get<std::tuple_size<Tuple>::value-1>(t);\n}\n \ntemplate <class... Args>\nostream& operator<<(ostream& out, const std::tuple<Args...>& t) {\n  out << '('; \n  print_tuple(out, t, int_<sizeof...(Args)>()); \n  return out << ')';\n}\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &vec) {\n    os << \"[\";\n    for (const auto &v : vec) {\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\n\n\ntypedef complex<double> point;\n\n// template<typename T,std::size_t N>\n// struct _v_traits {using type = std::vector<typename _v_traits<T,N-1>::type>;};\n// template<typename T>\n// struct _v_traits<T,1> {using type = std::vector<T>;};\n// template<typename T,std::size_t N=1>\n// using vec = typename _v_traits<T,N>::type;\n\n\nconst char dot = '.';\ninline int to_index(char c){\n    return c - 'A';\n}\nconst vector<int> dy = {-1,0,1,0};\nconst vector<int> dx = {0,1,0,-1};\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int H,W; cin >> H >> W;\n    vector<string> field(H);\n    for(string& s : field){\n        cin >> s;\n    }\n\n    set<tuple<int,int> > should_press;\n    for(int y=0;y<H;y++){\n        for(int x=0;x<W;x++){\n            vector<int> v(26);\n            for(int i=0;i<4;i++){\n                for(int k=1;k<max(H,W);k++){\n                    int ny = y + k * dy[i],\n                        nx = x + k * dx[i];\n                    if(ny < 0 or ny >= H or nx < 0 or nx >= W) break;\n                    const char here = field[ny][nx];\n                    if(here != dot){\n                        v[to_index(here)]++;\n                        // break;\n                    }\n                }\n            }\n            if(*max_element(all(v)) >= 2){\n                should_press.insert(make_tuple(y,x));\n            }\n        }\n    }\n\n    // dump(should_press);\n    bool cont = true;\n    int ret = 0;\n    while(cont){\n        cont = false;\n        for(auto t : should_press){\n            int y = get<0>(t),\n                x = get<1>(t);\n            if(field[y][x] != dot) continue;\n            vector<tuple<int,int> > tiles;\n            for(int i=0;i<4;i++){\n                for(int k=1;k<max(H,W);k++){\n                    int ny = y + k * dy[i],\n                        nx = x + k * dx[i];\n                    if(ny < 0 or ny >= H or nx < 0 or nx >= W) break;\n                    const char here = field[ny][nx];\n                    if(here != dot){\n                        tiles.emplace_back(ny,nx);\n                        break;\n                    }\n                }\n            }\n            for(int i=0;i<tiles.size();i++){\n                for(int j=i+1;j<tiles.size();j++){\n                    char& ic = field[get<0>(tiles[i])][get<1>(tiles[i])];\n                    char& ij = field[get<0>(tiles[j])][get<1>(tiles[j])];\n                    if(ic == ij){\n                        ic = dot;\n                        ij = dot;\n                        ret+=2;\n                        cont = true;\n                        goto end;\n                    }\n                }\n            }\n        end:{}\n        }\n    }\n    for(string s : field){\n        cerr << s << endl;\n    }\n    cout << ret << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <utility>\n\nusing namespace std;\ntypedef pair<int, int> pii;\n\nint evaluate(int x, int y, int width, int height, const vector<string> &field){\n\tint score = 0;\n\tint count[26] = { 0 };\n\tif(field[y][x] != '.'){ return 0; }\n\tfor(int i = x - 1; i >= 0; --i){\n\t\tif(field[y][i] != '.'){\n\t\t\t++count[field[y][i] - 'A'];\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i = x + 1; i < width; ++i){\n\t\tif(field[y][i] != '.'){\n\t\t\t++count[field[y][i] - 'A'];\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i = y - 1; i >= 0; --i){\n\t\tif(field[i][x] != '.'){\n\t\t\t++count[field[i][x] - 'A'];\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i = y + 1; i < height; ++i){\n\t\tif(field[i][x] != '.'){\n\t\t\t++count[field[i][x] - 'A'];\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i = 0; i < 26; ++i){\n\t\tif(count[i] == 2){ score += 2; }\n\t}\n\treturn score;\n}\n\nint main(){\n\tint m, n;\n\tcin >> m >> n;\n\tvector<string> field(m);\n\tfor(int i = 0; i < m; ++i){ cin >> field[i]; }\n\tvector< vector<pii> > pos(26);\n\tfor(int i = 0; i < m; ++i){\n\t\tfor(int j = 0; j < n; ++j){\n\t\t\tif(field[i][j] == '.'){ continue; }\n\t\t\tpos[field[i][j] - 'A'].push_back(pii(i, j));\n\t\t}\n\t}\n\tint answer = 0;\n\twhile(true){\n\t\tbool modified = false;\n\t\tpii hit;\n\t\tfor(int i = 0; i < 26 && !modified; ++i){\n\t\t\tif(pos[i].empty()){ continue; }\n\t\t\tpii p0 = pos[i][0], p1 = pos[i][1];\n\t\t\tif(p0.first == p1.first){\n\t\t\t\tint minx = min(p0.second, p1.second), maxx = max(p0.second, p1.second);\n\t\t\t\tfor(int x = minx + 1; x < maxx; ++x){\n\t\t\t\t\tif(evaluate(x, p0.first, n, m, field) > 0){\n\t\t\t\t\t\tmodified = true;\n\t\t\t\t\t\thit = pii(p0.first, x);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if(p0.second == p1.second){\n\t\t\t\tint miny = min(p0.first, p1.first), maxy = max(p0.first, p1.first);\n\t\t\t\tfor(int y = miny + 1; y < maxy; ++y){\n\t\t\t\t\tif(evaluate(p0.second, y, n, m, field) > 0){\n\t\t\t\t\t\tmodified = true;\n\t\t\t\t\t\thit = pii(y, p0.second);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(evaluate(p0.second, p1.first, n, m, field) > 0){\n\t\t\t\t\tmodified = true;\n\t\t\t\t\thit = pii(p1.first, p0.second);\n\t\t\t\t}\n\t\t\t\tif(evaluate(p1.second, p0.first, n, m, field) > 0){\n\t\t\t\t\tmodified = true;\n\t\t\t\t\thit = pii(p0.first, p1.second);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!modified){ break; }\n\t\tint count[26] = { 0 };\n\t\tfor(int i = hit.second - 1; i >= 0; --i){\n\t\t\tif(field[hit.first][i] != '.'){\n\t\t\t\t++count[field[hit.first][i] - 'A'];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int i = hit.second + 1; i < n; ++i){\n\t\t\tif(field[hit.first][i] != '.'){\n\t\t\t\t++count[field[hit.first][i] - 'A'];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int i = hit.first - 1; i >= 0; --i){\n\t\t\tif(field[i][hit.second] != '.'){\n\t\t\t\t++count[field[i][hit.second] - 'A'];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int i = hit.first + 1; i < m; ++i){\n\t\t\tif(field[i][hit.second] != '.'){\n\t\t\t\t++count[field[i][hit.second] - 'A'];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tfor(int j = 0; j < n; ++j){\n\t\t\t\tif(field[i][j] == '.'){ continue; }\n\t\t\t\tif(count[field[i][j] - 'A'] >= 2){\n\t\t\t\t\tpos[field[i][j] - 'A'].clear();\n\t\t\t\t\tfield[i][j] = '.';\n\t\t\t\t\t++answer;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << answer << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2299&lang=jp\nusing namespace std;\n\nint dx[4] = { 1,0,-1,0 };\nint dy[4] = { 0,-1,0,1 };\n\nvector<int> search(int m, int n, vector<vector<char>>& C,int key) {\n\tvector<int> dir;\n\tvector<vector<int>> alp(26);\n\tfor (int i = 0; i < 4;i++) {\n\t\tfor (int k = 1;k < key;k++) {\n\t\t\tint im = m + k*dx[i];\n\t\t\tint in = n + k*dy[i];\n\t\t\tif (C[im][in] == '#')break;\n\t\t\tif (C[im][in] != '.') {\n\t\t\t\talp[C[im][in] - 'A'].push_back(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < 26;i++) {\n\t\tif (alp[i].size() < 2)continue;\n\t\tfor (int j = 0; j < (int)alp[i].size();j++) {\n\t\t\tdir.push_back(alp[i][j]);\n\t\t}\n\t}\n\treturn dir;\n}\n\nvoid del(int m, int n, vector<vector<char>>& C, int key, int dir) {\n\tfor (int k = 1;k < key;k++) {\n\t\tint im = m + k*dx[dir];\n\t\tint in = n + k*dy[dir];\n\t\tif (C[im][in] == '#')break;\n\t\tif (C[im][in] != '.') {\n\t\t\tC[im][in] = '.';\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint M, N; cin >> M >> N;\n\tvector<vector<char>> C(M+2, vector<char>(N+2, '#'));\n\tfor (int i = 1; i <= M;i++) for (int j = 1; j <= N;j++) cin >> C[i][j];\n\n\tint ans = 0;\n\tint key = max(N, M);\n\twhile (true) {\n\t\tbool f = false;\n\t\tfor (int i = 1;i <= M;i++) {\n\t\t\tfor (int j = 1;j <= N;j++) {\n\t\t\t\tif (C[i][j] == '.') {\n\t\t\t\t\tauto Dir = search(i, j, C, key);\n\t\t\t\t\tfor (int k = 0; k < (int)Dir.size();k++) {\n\t\t\t\t\t\tif(!f)f = true;\n\t\t\t\t\t\tans++;\n\t\t\t\t\t\tdel(i, j, C, key, Dir[k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!f)break;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_W = 500;\nint h, w;\nchar C[MAX_W][MAX_W];\nint dx[4] = {0,0,-1,1};\nint dy[4] = {-1,1,0,0};\nbool memo[MAX_W][MAX_W];\n\nstruct P{\n\tint x, y;\n\tP(int x_, int y_){ x = x_; y = y_; }\n};\n\nbool search(int ax, int ay, int bx, int by){\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tmemo[y][x] = false;\n\t\t}\n\t}\n\tfor(int i=0 ; i < 4 ; i++ ){\n\t\tint mx = ax + dx[i];\n\t\tint my = ay + dy[i];\n\t\twhile( true ){\n\t\t\tif( mx < 0 || my < 0 || w <= mx || h <= my ) break;\n\t\t\tif( C[my][mx] == '.' ){\n\t\t\t\tmemo[my][mx] = true;\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmx += dx[i];\n\t\t\tmy += dy[i];\n\t\t}\n\t}\n\tfor(int i=0 ; i < 4 ; i++ ){\n\t\tint mx = bx + dx[i];\n\t\tint my = by + dy[i];\n\t\twhile( true ){\n\t\t\tif( mx < 0 || my < 0 || w <= mx || h <= my ) break;\n\t\t\tif( memo[my][mx] ){\n\t\t\t\treturn true;\n\t\t\t}else if( C[my][mx] != '.' ){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmx += dx[i];\n\t\t\tmy += dy[i];\n\t\t}\n\t}\n\treturn false;\n}\n\nint solve(){\n\tvector<P> v[26];\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tif( C[y][x] != '.' ){\n\t\t\t\tv[C[y][x]-'A'].push_back(P(x,y));\n\t\t\t}\n\t\t}\n\t}\n\tint res = 0;\n\tbool flag = true;\n\twhile( flag ){\n\t\tflag = false;\n\t\tfor(int i=0 ; i < 26 ; i++ ){\n\t\t\tif( v[i].size() == 0 ) continue;\n\t\t\tif( search(v[i][0].x, v[i][0].y, v[i][1].x, v[i][1].y) ){\n\t\t\t\tC[v[i][0].y][v[i][0].x] = '.';\n\t\t\t\tC[v[i][1].y][v[i][1].x] = '.';\n\t\t\t\tv[i].clear();\n\t\t\t\tflag = true;\n\t\t\t\tres += 2;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin >> h >> w;\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tcin >> C[y];\n\t}\n\tcout << solve() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define x first\n#define y second\nusing namespace std;\ntypedef pair <int,int> P;\nstring mp[501];\nint m,n,used[30];\nvector <P>  a[30];\n\nint saiki(int);\n\nbool check_x(int y,int x1,int x2){\n  for(int i=x1+1;i<x2;i++)\n    if(mp[y][i]!='.'&&!saiki(mp[y][i]-'A'))return 0;\n  return 1;\n}\n\nbool check_y(int y1,int y2,int x){\n  for(int i=y1+1;i<y2;i++)\n    if(mp[i][x]!='.'&&!saiki(mp[i][x]-'A')) return 0;\n  return 1;\n}\n\n\nint saiki(int ch){  \n  int x1=a[ch][0].x,x2=a[ch][1].x;\n  int y1=a[ch][0].y,y2=a[ch][1].y;\n  int res=0;\n  if(used[ch])return 0;\n  used[ch]=1;\n  \n  if(x1==x2&&y2-y1!=1) res=check_y(y1,y2,x1);\n  if(y1==y2&&x2-x1!=1) res=check_x(y1,x1,x2);\n\n  if(x1!=x2&&y1!=y2) {\n    if(x1<x2){\n      res=check_x(y1,x1,x2+1)&check_y(y1,y2,x2);\n      res|=check_y(y1,y2+1,x1)&check_x(y2,x1,x2);\n    }\n    else{\n      swap(x1,x2);\n      res=check_x(y1,x1-1,x2)&check_y(y1,y2,x1);\n      res |=check_y(y1,y2,x2)&check_x(y2,x1,x2+1);\n      swap(x1,x2);\n    }\n  }\n    \n\n  if(res) mp[y1][x1]=mp[y2][x2]='.',a[ch].clear();\n  used[ch]=0;\n  return res;\n}\n\nint main(){\n\n  cin>>m>>n;\n  for(int i=0;i<m;i++)cin>>mp[i];\n\n  int ans=0;\n  for(int i=0;i<m;i++)\n    for(int j=0;j<n;j++)\n      if(mp[i][j]!='.')a[mp[i][j]-'A'].push_back(P(j,i)),ans++;\n  \n  \n  for(int i=0;i<30;i++)if(a[i].size()) saiki(i);\n  \n  for(int i=0;i<m;i++)\n    for(int j=0;j<n;j++) if(mp[i][j]!='.') ans--;\n\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint H,W;\ntypedef pair<int,int>P;\n\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\nconst int TYPEX = 1;\nconst int TYPEY = 2;\nconst int ELSE = 3;\n\nclass Data{\npublic:\n  vector<P>pv;\n  bool used,notuse;\n  int type;\n  Data(){pv.clear();used = true;type = 0;notuse = false;};\n  void check(){\n    sort(pv.begin(),pv.end());\n    for(int i = 0 ; i < 4 ; i++){\n      P np = P(pv[0].first + dy[i],pv[0].second + dx[i]);\n      if(!(0 <= np.first && np.first < H && 0 <= np.second && np.second < W))continue;\n      if(pv[1] == np){\n\tnotuse = true;\n\treturn;\n      }\n    }\n    if(pv[0].first == pv[1].first)type = TYPEY;\n    else if(pv[0].second == pv[1].second)type = TYPEX;\n    else type = ELSE;\n  }\n};\n\nData data[26];\n\nvoid init(){\n  for(int i = 0 ; i < 26 ; i++)data[i] = Data();\n}\n\nvoid input(){\n  cin >> H >> W;\n  for(int i = 0 ; i < H ; i++){\n    for(int j = 0 ; j < W ; j++){\n      char c;\n      cin >> c;\n      if(c == '.')continue;\n      data[c-'A'].pv.push_back(P(i,j));\n      data[c-'A'].used = false;\n    }\n  }\n  for(int i = 0 ; i < 26 ; i++){\n    if(!data[i].used)data[i].check();\n  }\n\n  /*\n  for(int i = 0 ; i < 26 ; i++){\n    cout << \"i = \" << (char)(i + 'A') << \" used = \" << data[i].used << endl;\n  }\n  */\n}\n\nint run(int res){\n  for(int i = 0 ; i < 26 ; i++){\n    if(data[i].notuse)continue;\n    if(data[i].used)continue;\n    bool f = false;\n    P p0,p1,p2;\n    p0 = data[i].pv[0];\n    p1 = data[i].pv[1];\n\n    if(data[i].type == TYPEX){\n      for(int j = 0 ; j < 26 ; j++){\n\tif(f)break;\n\tif(j == i)continue;\n\tif(data[j].used)continue;\n\tfor(int k = 0 ; k < 2 ; k++){\n\n\t  /*\n\t  if(i == 1 && j == 3){\n\t    cout << \"p0.first = \" << p0.first << \" p2.first = \" << p2.first << \n\t      \"p1.first = \" << p1.first << endl;\n\t  }\n\t  */\n\t  p2 = data[j].pv[k];\n\t  if(p0.second != p2.second)continue;\n\t  if(p0.first <= p2.first && p2.first <= p1.first){\n\t    f = true;\n\t    break;\n\t  }\n\t}\n      }\n    }\n    else if(data[i].type == TYPEY){\n      for(int j = 0 ; j < 26 ; j++){\n\tif(f)break;\n\tif(j == i)continue;\n\tif(data[j].used)continue;\n\tfor(int k = 0 ; k < 2 ; k++){\n\t  p2 = data[j].pv[k];\n\t  if(p0.first != p2.first)continue;\n\t  if(p0.second <= p2.second && p2.second <= p1.second){\n\t    f = true;\n\t    break;\n\t  }\n\t}\n      }\n    }\n    else {\n      for(int j = 0 ; j < 26 ; j++){\n\tif(f)break;\n\tif(j == i)continue;\n\tbool f1,f2;\n\tf1 = f2 = false;\n\tif(data[j].used)continue;\n\n\tfor(int k = 0 ; k < 2 ; k++){\n\t  p2 = data[j].pv[k];\n\t  int x1,x2,y1,y2;\n\t  if(p0.first < p1.first){\n\t    x1 = p0.second;\n\t    y1 = p0.first;\n\t    x2 = p1.second;\n\t    y2 = p1.first;\n\t    \n\t    if(p2.second == x1){\n\t      if(y1 <= p2.first && p2.first <= y2)f1 = true;\n\t    }\n\t    \n\t    if(p2.first == y1){\n\t      if(x1 <= p2.second && p2.second <= x2)f2 = true;\n\t    }\n\t    \n\t    if(p2.second == x2){\n\t      if(y1 <= p2.first && p2.first <= y2)f2 = true;\n\t    }\n\n\t    if(p2.first == y2){\n\t      if(x1 <= p2.second && p2.second <= x2)f1 = true;\n\t    }\n\n\t  }\n\t  else{\n\t    x1 = p0.second;\n\t    y1 = p1.first;\n\t    x2 = p1.second;\n\t    y2 = p0.first;\n\n\t    if(p2.second == x1){\n\t      if(y1 <= p2.first && p2.first <= y2)f1 = true;\n\t    }\n\t    \n\t    if(p2.first == y1){\n\t      if(x1 <= p2.second && p2.second <= x2)f1 = true;\n\t    }\n\t    \n\t    if(p2.second == x2){\n\t      if(y1 <= p2.first && p2.first <= y2)f2 = true;\n\t    }\n\n\t    if(p2.first == y2){\n\t      if(x1 <= p2.second && p2.second <= x2)f2 = true;\n\t    }\n\t  }\n\t}\n\tif(f1 && f2){\n\t  f = true;\n\t  break;\n\t}\n      }\n    }\n    if(f)continue;\n    //cout << \"del = \" << (char)(i + 'A') << endl;//\n    data[i].used = true;\n    return run(res+2);\n  }\n  return res;\n}\n\nint main(){\n  init();\n  input();\n  cout << run(0) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\nconst int NONE = 0;\nconst int VERTICAL = 1;\nconst int HORIZONTAL = 2;\nconst int CORNER = 3;\n\nint main() {\n\tint M, N;\n\tcin >> M >> N;\n\n\tvs field(M);\n\tvvi pos(26, vi(4, -1));\n\tREP(i, M) {\n\t\tcin >> field[i];\n\t\tREP(j, N) {\n\t\t\tif(field[i][j] != '.') {\n\t\t\t\tint k = field[i][j]-'A';\n\t\t\t\tif(pos[k][0] == -1) {\n\t\t\t\t\tpos[k][0] = i;\n\t\t\t\t\tpos[k][1] = j;\n\t\t\t\t} else {\n\t\t\t\t\tpos[k][2] = i;\n\t\t\t\t\tpos[k][3] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvi type(26, CORNER);\n\tREP(i, 26) {\n\t\tif(pos[i][2] == -1) {\n\t\t\ttype[i] = NONE;\n\t\t\tcontinue;\n\t\t}\n\t\tif(abs(pos[i][0]-pos[i][2])+abs(pos[i][1]-pos[i][3]) == 1) {\n\t\t\ttype[i] = NONE;\n\t\t\tcontinue;\n\t\t}\n\t\tif(pos[i][0] == pos[i][2]) {\n\t\t\ttype[i] = VERTICAL;\n\t\t\tcontinue;\n\t\t}\n\t\tif(pos[i][1] == pos[i][3]) {\n\t\t\ttype[i] = HORIZONTAL;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tint ans = 0;\n\tbool updated = true;\n\twhile(updated) {\n\t\tupdated = false;\n\t\tREP(i, 26) {\n\t\t\tif(type[i] == NONE) {\n\t\t\t\n\t\t\t} else if(type[i] == VERTICAL) {\n\t\t\t\tint y = pos[i][0];\n\t\t\t\tFOR(x, min(pos[i][1], pos[i][3])+1, max(pos[i][1], pos[i][3])-1) {\n\t\t\t\t\tif(field[y][x] != '.') {\n\t\t\t\t\t\tgoto next;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans += 2;\n\t\t\t\ttype[i] = NONE;\n\t\t\t\tfield[pos[i][0]][pos[i][1]] = field[pos[i][2]][pos[i][3]] = '.';\n\t\t\t\tupdated = true;\n\t\t\t\tbreak;\n\t\t\t} else if(type[i] ==  HORIZONTAL) {\n\t\t\t\tint x = pos[i][1];\n\t\t\t\tFOR(y, min(pos[i][0], pos[i][2])+1, max(pos[i][0], pos[i][2])-1) {\n\t\t\t\t\tif(field[y][x] != '.') {\n\t\t\t\t\t\tgoto next;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans += 2;\n\t\t\t\ttype[i] = NONE;\n\t\t\t\tfield[pos[i][0]][pos[i][1]] = field[pos[i][2]][pos[i][3]] = '.';\n\t\t\t\tupdated = true;\n\t\t\t\tbreak;\n\t\t\t} else if(type[i] == CORNER) {\n\t\t\t\tint miny = min(pos[i][0], pos[i][2]);\n\t\t\t\tint maxy = max(pos[i][0], pos[i][2]);\n\t\t\t\tint minx = min(pos[i][1], pos[i][3]);\n\t\t\t\tint maxx = max(pos[i][1], pos[i][3]);\n\t\t\t\tbool li1 = false, li2 = false, li3 = false, li4 = false;\n\n\t\t\t\tl1:\n\t\t\t\tFOR(y, miny, maxy) {\n\t\t\t\t\tif(field[y][minx] != '.' && field[y][minx] != 'A'+i) {\n\t\t\t\t\t\tgoto l2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tli1 = true;\n\n\t\t\t\tl2:\n\t\t\t\tFOR(x, minx, maxx) {\n\t\t\t\t\tif(field[maxy][x] != '.' && field[maxy][x] != 'A'+i) {\n\t\t\t\t\t\tgoto l3;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tli2 = true;\n\n\t\t\t\tl3:\n\t\t\t\tFOR(y, miny, maxy) {\n\t\t\t\t\tif(field[y][maxx] != '.' && field[y][maxx] != 'A'+i) {\n\t\t\t\t\t\tgoto li4;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tli3 = true;\n\n\t\t\t\tli4:\n\t\t\t\tFOR(x, minx, maxx) {\n\t\t\t\t\tif(field[miny][x] != '.' && field[miny][x] != 'A'+i) {\n\t\t\t\t\t\tgoto check;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tli4 = true;\n\n\t\t\t\tcheck:\n\t\t\t\tif(pos[i][0] == miny && pos[i][1] == minx) {\n\t\t\t\t\tif((li1&li2) || (li3&li4)) {\n\t\t\t\t\t\tgoto ok;\n\t\t\t\t\t}\n\t\t\t\t} else if(pos[i][2] == miny && pos[i][3] == minx) {\n\t\t\t\t\tif((li1&li2) || (li3&li4)) {\n\t\t\t\t\t\tgoto ok;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif((li1&li4) || (li2&li3)) {\n\t\t\t\t\t\tgoto ok;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgoto next;\n\n\t\t\t\tok:;\n\t\t\t\t\tans += 2;\n\t\t\t\t\ttype[i] = NONE;\n\t\t\t\t\tfield[pos[i][0]][pos[i][1]] = field[pos[i][2]][pos[i][3]] = '.';\n\t\t\t\t\tupdated = true;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnext:;\n\t\t}\n\t\t/*\n\t\tcout << \"----------\" << endl;\n\t\tREP(i, M) {\n\t\t\tcout << field[i] << endl;\n\t\t}\n\t\t*/\n\t}\n\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mk make_pair\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nstring s[500];\nint h,w,sum=0;\nvector<int>x,y;\nvoid del(int t1,int t2){\n  vector<pair<char,pair<int,int> > >p;\n  for(int i=t1;i<h;i++)if(s[i][t2]!='.'){\n    p.push_back(mk(s[i][t2],mk(i,t2)));\n    break;\n  }\n  for(int i=t1;i>=0;i--)if(s[i][t2]!='.'){\n    p.push_back(mk(s[i][t2],mk(i,t2)));\n    break;\n  }\n  for(int i=t2;i<w;i++)if(s[t1][i]!='.'){\n    p.push_back(mk(s[t1][i],mk(t1,i)));\n    break;\n  }\n  for(int i=t2;i>=0;i--)if(s[t1][i]!='.'){\n    p.push_back(mk(s[t1][i],mk(t1,i)));\n    break;\n  }\n  sort(p.begin(),p.end());\n  if(p.size()>=2){\n    r(i,p.size()-1){\n      if(p[i].first==p[i+1].first){\n        sum++;\n        s[p[i].second.first][p[i].second.second]='.';\n        s[p[i+1].second.first][p[i+1].second.second]='.';\n      }\n    }\n  }\n}\nint main(){\n  cin>>h>>w;\n  r(i,h)cin>>s[i];\n  r(i,h)r(j,w)if(s[i][j]!='.'){\n      y.push_back(i),x.push_back(j);\n      if(i+1<h)y.push_back(i+1);\n      if(j+1<w)x.push_back(j+1);\n    }\n  r(k,10)r(i,y.size())r(j,x.size())\n    if(s[y[i]][x[j]]=='.')del(y[i],x[j]);\n  cout<<sum*2<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-11L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n\n#define MOD 998244353LL\n#define seg_size 262144 * 4LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nunsigned long xor128() {\n\tstatic unsigned long x = 123456789, y = 362436069, z = 521288629, w = time(NULL);\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\nvoid init() {\n\tiostream::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n}\n\n#define int ll\n\nint grid[1000][1000];\nint cnt[27][500][500] = {};\n\nvoid solve(){\n\tint n, m;\n\tcin >> n >> m;\n\tREP(i, n) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tREP(q, m) {\n\t\t\tif (s[q] != '.') {\n\t\t\t\tgrid[i][q] = s[q] - 'A' + 1;\n\t\t\t}\n\t\t}\n\t}\n\tint erased = 1;\n\tint ans = 0;\n\twhile (erased != 0) {\n\t\tREP(i, 27) {\n\t\t\tREP(q, n) {\n\t\t\t\tREP(j, m) {\n\t\t\t\t\tcnt[i][q][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\terased = 0;\n\t\tconst int dx[4] = { 1,-1,0,0 };\n\t\tREP(i, n) {\n\t\t\tREP(q, m) {\n\t\t\t\tif (grid[i][q] == '.') continue;\n\t\t\t\tREP(t, 4) {\n\t\t\t\t\tfor (int j = 1; j <= 500;++j) {\n\t\t\t\t\t\tint x = i + dx[t] * j;\n\t\t\t\t\t\tint y = q + dx[3 - t] * j;\n\t\t\t\t\t\tif (x >= 0 && x < n && y >= 0 && y < m) {\n\t\t\t\t\t\t\tif (grid[x][y] == 0) {\n\t\t\t\t\t\t\t\tcnt[grid[i][q]][x][y]++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(i, n) {\n\t\t\tREP(q, m) {\n\t\t\t\tfor (int j = 1; j < 27; ++j) {\n\t\t\t\t\tif (cnt[j][i][q] == 2) {\n\t\t\t\t\t\terased |= (1 << j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(i, n) {\n\t\t\tREP(q, m) {\n\t\t\t\tif ((1 << grid[i][q]) & erased) {\n\t\t\t\t\tans++;\n\t\t\t\t\tgrid[i][q] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//cout << erased << endl;\n\t}\n\tcout << ans << endl;\n}\n\n#undef int\n\nint main() {\n\tinit();\n\tsolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 501;\n\nint main()\n{\n    int n,m;\n    scanf(\"%d%d\",&n,&m);\n    char c[MAX_N][MAX_N];\n    vector<P> al[26];\n    int res = 0;\n\trep(i,n){\n        char hoge;\n        scanf(\"%c\",&hoge);\n        rep(j,m){\n            scanf(\"%c\",&c[i][j]);\n            if((int)(c[i][j] - 'A') >= 0 && (int)(c[i][j] - 'A') <= 25){\n                al[(int)(c[i][j] - 'A')].push_back(P(i,j));\n            }\n        }\n\t}\n    while(1){\n        bool act = false;\n        rep(i,26){\n            rep(j,al[i].size()){\n                int i1 = al[i][0].first,j1 = al[i][0].second;\n                int i2 = al[i][1].first,j2 = al[i][1].second;\n                if(i1 == i2){\n                    bool flag = false;\n                    for(int k=min(j1,j2)+1;k<max(j1,j2);k++){\n                        if(c[i1][k] != '.'){\n                            flag = true;\n                            break;\n                        }\n                    }\n                    if(!flag){\n                        c[i1][j1] = '.';\n                        c[i2][j2] = '.';\n                        res += 2;\n                        al[i].clear();\n                        act = true;\n                    }\n                }else if(j1 == j2){\n                    bool flag = false;\n                    for(int k=min(i1,i2)+1;k<max(i1,i2);k++){\n                        if(c[k][j1] != '.'){\n                            flag = true;\n                            break;\n                        }\n                    }\n                    if(!flag){\n                        c[i1][j1] = '.';\n                        c[i2][j2] = '.';\n                        res += 2;\n                        al[i].clear();\n                        act = true;\n                    }\n                }else{\n                    if(c[i1][j2] == '.' || c[i2][j1] == '.'){\n                        c[i1][j1] = '.';\n                        c[i2][j2] = '.';\n                        res += 2;\n                        al[i].clear();\n                        act = true;\n                    }\n                }\n            }\n        }\n        if(!act){\n            break;\n        }\n    }\n    printf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nvoid solve()\n{\n\tint M, N;\n\tcin >> M >> N;\n\tqueue<P> Que;\n\tvector< vector<char> > Field(M, vector<char>(N));\n\tfor(int i = 0; i < M; ++i)\n\t{\n\t\tfor(int j = 0; j < N; ++j)\n\t\t{\n\t\t\tcin >> Field[i][j];\n\t\t\tif(Field[i][j] == '.')\n\t\t\t{\n\t\t\t\tQue.push(make_pair<int, int>(i, j));\n\t\t\t}\n\t\t}\n\t}\n\tint count = 0;\n\twhile(!Que.empty())\n\t{\n\t\tP up    = make_pair(Que.front().first - 1, Que.front().second);\n\t\tP down  = make_pair(Que.front().first + 1, Que.front().second);\n\t\tP left  = make_pair(Que.front().first, Que.front().second - 1);\n\t\tP right = make_pair(Que.front().first, Que.front().second + 1);\n\t\tbool upOK = false;\n\t\tbool downOK = false;\n\t\tbool leftOK = false;\n\t\tbool rightOK = false;\n\t\twhile(0 <= up.first && up.first < M)\n\t\t{\n\t\t\tif(Field[up.first][up.second] == '.')\n\t\t\t{\n\t\t\t\t--up.first;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tupOK = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\twhile(0 <= down.first && down.first < M)\n\t\t{\n\t\t\tif(Field[down.first][down.second] == '.')\n\t\t\t{\n\t\t\t\t++down.first;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdownOK = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\twhile(0 <= left.second && left.second < N)\n\t\t{\n\t\t\tif(Field[left.first][left.second] == '.')\n\t\t\t{\n\t\t\t\t--left.second;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tleftOK = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\twhile(0 <= right.second && right.second < N)\n\t\t{\n\t\t\tif(Field[right.first][right.second] == '.')\n\t\t\t{\n\t\t\t\t++right.second;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\trightOK = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(upOK && downOK && Field[up.first][up.second] == Field[down.first][down.second] && Field[up.first][up.second] != '.')\n\t\t{\n\t\t\tcount += 2;\n\t\t\tField[up.first][up.second] = '.';\n\t\t\tField[down.first][down.second] = '.';\n\t\t\tQue.push(make_pair<int, int>(Que.front().first, Que.front().second));\n\t\t\tQue.push(make_pair<int, int>(up.first, up.second));\n\t\t\tQue.push(make_pair<int, int>(down.first, down.second));\n\t\t}\n\t\tif(upOK && leftOK && Field[up.first][up.second] == Field[left.first][left.second] && Field[left.first][left.second] != '.')\n\t\t{\n\t\t\tcount += 2;\n\t\t\tField[up.first][up.second] = '.';\n\t\t\tField[left.first][left.second] = '.';\n\t\t\tQue.push(make_pair<int, int>(Que.front().first, Que.front().second));\n\t\t\tQue.push(make_pair<int, int>(up.first, up.second));\n\t\t\tQue.push(make_pair<int, int>(left.first, left.second));\n\t\t}\n\t\tif(upOK && rightOK && Field[up.first][up.second] == Field[right.first][right.second] && Field[right.first][right.second] != '.')\n\t\t{\n\t\t\tcount += 2;\n\t\t\tField[up.first][up.second] = '.';\n\t\t\tField[right.first][right.second] = '.';\n\t\t\tQue.push(make_pair<int, int>(Que.front().first, Que.front().second));\n\t\t\tQue.push(make_pair<int, int>(up.first, up.second));\n\t\t\tQue.push(make_pair<int, int>(right.first, right.second));\n\t\t}\n\t\tif(leftOK && downOK && Field[left.first][left.second] == Field[down.first][down.second] && Field[left.first][left.second] != '.')\n\t\t{\n\t\t\tcount += 2;\n\t\t\tField[left.first][left.second] = '.';\n\t\t\tField[down.first][down.second] = '.';\n\t\t\tQue.push(make_pair<int, int>(Que.front().first, Que.front().second));\n\t\t\tQue.push(make_pair<int, int>(left.first, left.second));\n\t\t\tQue.push(make_pair<int, int>(down.first, down.second));\n\t\t}\n\t\tif(leftOK && rightOK && Field[left.first][left.second] == Field[right.first][right.second] && Field[right.first][right.second] != '.')\n\t\t{\n\t\t\tcount += 2;\n\t\t\tField[left.first][left.second] = '.';\n\t\t\tField[right.first][right.second] = '.';\n\t\t\tQue.push(make_pair<int, int>(Que.front().first, Que.front().second));\n\t\t\tQue.push(make_pair<int, int>(left.first, left.second));\n\t\t\tQue.push(make_pair<int, int>(right.first, right.second));\n\t\t}\n\t\tif(rightOK && downOK && Field[right.first][right.second] == Field[down.first][down.second] && Field[right.first][right.second] != '.')\n\t\t{\n\t\t\tcount += 2;\n\t\t\tField[right.first][right.second] = '.';\n\t\t\tField[down.first][down.second] = '.';\n\t\t\tQue.push(make_pair<int, int>(Que.front().first, Que.front().second));\n\t\t\tQue.push(make_pair<int, int>(right.first, right.second));\n\t\t\tQue.push(make_pair<int, int>(down.first, down.second));\n\t\t}\n\t\tQue.pop();\n\t}\n\tcout << count << endl;\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cctype>\n#include <vector>\n#include <set>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0 ; i < n ; i++)\n\nstruct Point{\n  int x1, y1, x2, y2;\n};\n\nconst int MAX = 510;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nchar field[MAX][MAX];\nbool found[26];\nPoint alpha[26];\n\nint H, W;\n\nbool canReach(char C, int cx, int cy, int x, int y){\n  if(cx < x){\n    for(int j = x ; j >= cx ; j--){\n      if(field[y][j] != '.' && field[y][j] != C) return false;\n    }\n  }\n  else if(cx > x){\n    for(int j = x ; j <= cx ; j++){\n      if(field[y][j] != '.' && field[y][j] != C) return false;\n    }\n  }\n  \n  if(cy < y){\n    for(int i = y ; i >= cy ; i--){\n      if(field[i][x] != '.' && field[i][x] != C) return false;\n    }\n  }\n  else if(cy > y){\n    for(int i = y ; i <= y ; i++){\n      if(field[i][x] != '.' && field[i][x] != C) return false;\n    }\n  }\n  return true;\n}\n\nbool canReach_x(char C, int x, int y1, int y2){\n  if(y1 > y2) swap(y1, y2);\n  for(int i = y1 ; i <= y2 ; i++){\n    if(field[i][x] != '.' && field[i][x] != C) return false;\n  }\n  return true;\n}\n\nbool canReach_y(char C, int y, int x1, int x2){\n  if(x1 > x2) swap(x1, x2);\n  for(int j = x1 ; j <= x2 ; j++){\n    if(field[y][j] != '.' && field[y][j] != C) return false;\n  }\n  return true;\n}\n\nvoid output(){\n  rep(i, H){\n    rep(j, W){\n      cout << field[i][j];\n    }\n    cout << endl;\n  }\n  cout << endl;\n}\n\n\nint main(){\n  while(cin >> H >> W){\n    rep(i, H) cin >> field[i];\n\n    memset(found, 0, sizeof(found));\n    \n    rep(i, H){\n      rep(j, W){\n\tint c = field[i][j]-'A';\n\tif(!found[c]){\n\t  found[c] = true;\n\t  alpha[c].x1 = j, alpha[c].y1 = i;\n\t}\n\telse{\n\t  alpha[c].x2 = j, alpha[c].y2 = i;\n\t}\t\n      }\n    }\n    \n    Point cross[26];\n    rep(i, 26){\n      if(found[i]){\n\tcross[i].x1 = alpha[i].x1, cross[i].y1 = alpha[i].y2;\n\tcross[i].x2 = alpha[i].x2, cross[i].y2 = alpha[i].y1;\n      }\n    }\n    \n    int ans = 0;\n    \n    rep(i, H){\n      rep(j, W){\n\trep(k, 4){\n\t  int nx = j+dx[k], ny = i+dy[k];\n\t  if(nx < 0 || nx > W || ny < 0 || ny > H) continue;\n\t  if(field[i][j] == field[ny][nx]) found[field[i][j]-'A'] = false;\n\t}\n      }\n    }\n\t\n    \n    for(; ;){\n      //output();\n      bool flag = false;\n      rep(i, 26){\n\tif(found[i]){\n\t  int x1 = alpha[i].x1, y1 = alpha[i].y1, x2 = alpha[i].x2, y2 = alpha[i].y2;\n\t  \n\t  if(x1 == x2){\n\t    if(canReach_x('A'+i, x1, y1, y2)){\n\t      field[y1][x1] = field[y2][x2] = '.';\n\t      found[i] = false;\n\t      ans += 2;\n\t      flag = true;\n\t    }\n\t  }\n\t  else if(y1 == y2){\n\t    if(canReach_y('A'+i, y1, x1, x2)){\n\t      field[y1][x1] = field[y2][x2] = '.';\n\t      found[i] = false;\n\t      ans += 2;\n\t      flag = true;\n\t    }\n\t  }\t      \t    \t  \t  \n\t  else if((canReach('A'+i, cross[i].x1, cross[i].y1, x1, y1) &&\n\t\t   canReach('A'+i, cross[i].x1, cross[i].y1, x2, y2)) ||\n\t\t  (canReach('A'+i, cross[i].x2, cross[i].y2, x1, y1) &&\n\t\t   canReach('A'+i, cross[i].x2, cross[i].y2, x2, y2))){\n\t    field[y1][x1] = field[y2][x2] = '.';\n\t    found[i] = false;\n\t    ans += 2;\n\t    flag = true;\n\t  }\n\t}\n      }\n      if(!flag) break;\n    }\n    \n    cout << ans << endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 2299.cc: Tiles are Colorful\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_M = 500;\nconst int MAX_N = 500;\n\ntypedef long long ll;\n\nconst int INF = 1 << 30;\nconst ll LINF = 1LL << 60;\n\n/* typedef */\n\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef pair<int,int> pii;\n\n/* global variables */\n\nint flds[MAX_M][MAX_N];\npii ps[26], as[26];\nvi msks[26];\nbool used[26];\n\n/* subroutines */\n\nstring b2s(int bits) {\n  string s;\n  for (int i = 0, bi = 1; i < 26; i++, bi <<= 1)\n    if (bits & bi) s += (char)('A' + i);\n  return (s.empty() ? \".\" : s);\n}\n\n/* main */\n\nint main() {\n  int m, n;\n  cin >> m >> n;\n\n  for (int i = 0; i < 26; i++) ps[i].first = -1;\n  \n  for (int y = 0; y < m; y++) {\n    string s;\n    cin >> s;\n    for (int x = 0; x < n; x++)\n      flds[y][x] = (s[x] == '.') ? -1 : s[x] - 'A';\n  }\n  \n  for (int y = 0; y < m; y++)\n    for (int x = 0; x < n; x++) {\n      int k = flds[y][x];\n      if (k < 0) continue;\n\n      if (ps[k].first < 0) {\n\tps[k] = pii(x, y);\n\tcontinue;\n      }\n\n      int x0 = ps[k].first, y0 = ps[k].second;\n      if (x != x0 && y != y0) {\n\tint msk0 = 0, msk1 = 0;\n\tint dx = (x > x0) ? 1 : -1;\n\n\tfor (int x1 = x; x1 != x0; x1 -= dx)\n\t  if (flds[y0][x1] >= 0) msk0 |= (1 << flds[y0][x1]);\n\tfor (int y1 = y0; y1 != y; y1++)\n\t  if (flds[y1][x] >= 0) msk0 |= (1 << flds[y1][x]);\n\n\tfor (int x1 = x0; x1 != x; x1 += dx)\n\t  if (flds[y][x1] >= 0) msk1 |= (1 << flds[y][x1]);\n\tfor (int y1 = y; y1 != y0; y1--)\n\t  if (flds[y1][x0] >= 0) msk1 |= (1 << flds[y1][x0]);\n\n\tif (msk0 == msk1)\n\t  msks[k].push_back(msk0);\n\telse {\n\t  msks[k].push_back(msk0);\n\t  msks[k].push_back(msk1);\n\t}\n      }\n      else if (x == x0) {\n\tif (y0 + 1 < y) {\n\t  int msk0 = 0;\n\t  for (int y1 = y0 + 1; y1 < y; y1++)\n\t    if (flds[y1][x] >= 0) msk0 |= (1 << flds[y1][x]);\n\t  msks[k].push_back(msk0);\n\t}\n      }\n      else {\n\tif (x0 + 1 < x) {\n\t  int msk0 = 0;\n\t  for (int x1 = x0 + 1; x1 < x; x1++)\n\t    if (flds[y][x1] >= 0) msk0 |= (1 << flds[y][x1]);\n\t  msks[k].push_back(msk0);\n\t}\n      }\n    }\n\n  if (false) {\n    for (int i = 0; i < 26; i++)\n      if (msks[i].size()) {\n\tprintf(\"%c:(%lu)\", 'A' + i, msks[i].size());\n\tfor (int j = 0; j < msks[i].size(); j++)\n\t  cout << ' ' << b2s(msks[i][j]);\n\tputchar('\\n');\n      }\n  }\n  \n  int msk = 0;\n  int ans = 0;\n  \n  for (bool changed = true; changed;) {\n    changed = false;\n    for (int i = 0, bi = 1; i < 26; i++, bi <<= 1)\n      if (! used[i] && msks[i].size()) {\n\tfor (int j = 0; j < msks[i].size(); j++)\n\t  if ((msk & msks[i][j]) == msks[i][j]) {\n\t    used[i] = true;\n\t    msk |= bi;\n\t    ans++;\n\t    changed = true;\n\t    break;\n\t  }\n      }\n  }\n\n  printf(\"%d\\n\", ans * 2);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <queue>\n#include <map>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> que;\nconst int INF = 1<<30;\nconst int MOD = 1e9 + 7;\nconst int dy[] = {1, 0, -1, 0};\nconst int dx[] = {0, 1, 0, -1};\nint h, w, ans;\nvector<string> table;\nbool isOut(int y, int x)\n{\n    if(y < 0 or x < 0 or y >= h or x >= w) return true;\n    return false;\n}\nvoid dfs(int score)\n{\n    ans = max(ans, score);\n    for(int i = 0; i < h; i++)\n    {\n        for(int j = 0; j < w; j++)\n        {\n            if(table[i][j] != '.') continue;\n            map<char, vector<P>> mp;\n            for(int k = 0; k < 4; k++)\n            {\n                int ny = i, nx = j;\n                while(true)\n                {\n                    ny += dy[k];\n                    nx += dx[k];\n                    if(isOut(ny, nx)) break;\n                    if(table[ny][nx] != '.')\n                    {\n                        mp[table[ny][nx]].push_back(make_pair(ny, nx));\n                        break;\n                    }\n                }\n            }\n            vector<P> v;\n            for(auto x : mp)\n            {\n                if(x.second.size() >= 2) for(int k = 0; k < x.second.size(); k++) v.push_back(x.second[k]);\n            }\n            if(v.size() > 0)\n            {\n                vector<char> tmp;\n                for(int k = 0; k < v.size(); k++)\n                {\n                    P p = v[k];\n                    tmp.push_back(table[p.first][p.second]);\n                    table[p.first][p.second] = '.';\n                }\n                dfs(score + v.size());\n                for(int k = 0; k < v.size(); k++)\n                {\n                    P p = v[k];\n                    table[p.first][p.second] = tmp[k];\n                }\n            }\n        }\n    }\n}\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> h >> w;\n    table.resize(h);\n    for(int i = 0; i < h; i++) cin >> table[i];\n    dfs(0);\n    cout << ans << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<map>\nusing namespace std;\nchar str[600][600];\nint r[30][2];\nint c[30][2];\nvector<int>w[30];\nmap<int,int>m;\nint solve(int a){\n\tif(m.count(a))return m[a];\n\tint ret=__builtin_popcount(a);\n\tfor(int i=0;i<26;i++)if(a&(1<<i)){\n\t\tfor(int j=0;j<w[i].size();j++){\n\t\t\tif(!(a&w[i][j])){\n\t\t\t\tret=min(ret,solve(a-(1<<i)));\n\t\t\t}\n\t\t}\n\t}\n\treturn m[a]=ret;\n}\nint main(){\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<a;i++)scanf(\"%s\",str[i]);\n\tfor(int i=0;i<26;i++)r[i][0]=r[i][1]=-1;\n\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\tif(str[i][j]!='.'){\n\t\t\tif(!~r[str[i][j]-'A'][0]){\n\t\t\t\tr[str[i][j]-'A'][0]=i;\n\t\t\t\tc[str[i][j]-'A'][0]=j;\n\t\t\t}else{\n\t\t\t\tr[str[i][j]-'A'][1]=i;\n\t\t\t\tc[str[i][j]-'A'][1]=j;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<26;i++){\n\t\tif(!~r[i][0])continue;\n\t\tif(r[i][0]==r[i][1]){\n\t\t\tif(c[i][0]+1<c[i][1]){\n\t\t\t\tint key=0;\n\t\t\t\tfor(int j=0;j<26;j++){\n\t\t\t\t\tif(r[i][0]==r[j][0]&&c[i][0]<c[j][0]&&c[j][0]<c[i][1])key|=(1<<j);\n\t\t\t\t\tif(r[i][0]==r[j][1]&&c[i][0]<c[j][1]&&c[j][1]<c[i][1])key|=(1<<j);\n\t\t\t\t}\n\t\t\t\tw[i].push_back(key);\n\t\t\t}\n\t\t}else if(c[i][0]==c[i][1]){\n\t\t\tif(r[i][0]+1<r[i][1]){\n\t\t\t\tint key=0;\n\t\t\t\tfor(int j=0;j<26;j++){\n\t\t\t\t\tif(c[i][0]==c[j][0]&&r[i][0]<r[j][0]&&r[j][0]<r[i][1])key|=(1<<j);\n\t\t\t\t\tif(c[i][0]==c[j][1]&&r[i][0]<r[j][1]&&r[j][1]<r[i][1])key|=(1<<j);\n\t\t\t\t}\n\t\t\t\tw[i].push_back(key);\n\t\t\t}\n\t\t}else{\n\t\t\tint key=0;\n\t\t\tfor(int j=0;j<26;j++){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tif(r[i][0]==r[j][0]&&min(c[i][0],c[i][1])<=c[j][0]&&c[j][0]<=max(c[i][0],c[i][1]))key|=(1<<j);\n\t\t\t\tif(c[i][1]==c[j][0]&&r[i][0]<=r[j][0]&&r[j][0]<=r[i][1])key|=(1<<j);\n\t\t\t\tif(r[i][0]==r[j][1]&&min(c[i][0],c[i][1])<=c[j][1]&&c[j][1]<=max(c[i][0],c[i][1]))key|=(1<<j);\n\t\t\t\tif(c[i][1]==c[j][1]&&r[i][0]<=r[j][1]&&r[j][1]<=r[i][1])key|=(1<<j);\n\t\t\t}\n\t\t\tw[i].push_back(key);\n\t\t\tkey=0;\n\t\t\tfor(int j=0;j<26;j++){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tif(r[i][1]==r[j][0]&&min(c[i][0],c[i][1])<=c[j][0]&&c[j][0]<=max(c[i][0],c[i][1]))key|=(1<<j);\n\t\t\t\tif(c[i][0]==c[j][0]&&r[i][0]<=r[j][0]&&r[j][0]<=r[i][1])key|=(1<<j);\n\t\t\t\tif(r[i][1]==r[j][1]&&min(c[i][0],c[i][1])<=c[j][1]&&c[j][1]<=max(c[i][0],c[i][1]))key|=(1<<j);\n\t\t\t\tif(c[i][0]==c[j][1]&&r[i][0]<=r[j][1]&&r[j][1]<=r[i][1])key|=(1<<j);\n\t\t\t}\n\t\t\tw[i].push_back(key);\n\t\t}\n\t}\n\tint st=0;\n\tint ret=0;\n\tfor(int i=0;i<26;i++){\n\t\tif(!~r[i][0])continue;\n\t\tret++;\n\t\tbool ok=false;\n\t\tfor(int j=0;j<w[i].size();j++)if(!w[i][j])ok=true;\n\t\tif(!ok)st+=(1<<i);\n\t}\n\tprintf(\"%d\\n\",ret*2-solve(st)*2);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cctype>\n#include <vector>\n#include <map>\n#include <cassert>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0 ; i < n ; i++)\n\ntypedef pair<int, int> P;\n\nstruct Point{\n  int x1, y1, x2, y2;\n};\n\nconst int MAX = 510;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nchar field[MAX][MAX];\nbool found[26];\nPoint alpha[26];\nint H, W;\n\nbool checkH(int x1, int x2, int y, char c){\n  if(x1 > x2) swap(x1, x2);\n  for(int j = x1 ; j <= x2 ; j++){\n    if(field[y][j] != '.' && field[y][j] != c) return false;\n  }\n  return true;\n}\n\nbool checkW(int y1, int y2, int x, char c){\n  if(y1 > y2) swap(y1, y2);\n  for(int i = y1 ; i <= y2 ; i++){\n    if(field[i][x] != '.' && field[i][x] != c) return false;\n  }\n  return true;\n}\n\nint main(){\n  while(cin >> H >> W){\n    rep(i, H) cin >> field[i];\n    \n    memset(alpha, 0, sizeof(alpha));\n    memset(found, 0, sizeof(found));\n    \n    rep(i, H){\n      rep(j, W){\n\tif(isalpha(field[i][j])){\n\t  int c = field[i][j]-'A';\n\t  if(found[c]){\n\t    alpha[c].x2 = j, alpha[c].y2 = i;\n\t  }\n\t  else{\n\t    found[c] = true;\n\t    alpha[c].x1 = j, alpha[c].y1 = i;\n\t  }\n\t}\t\n      }\n    }\n    \n    Point cross[26];\n    rep(i, 26){\n      if(found[i]){\n\t//cross[i].push_back(Point(alpha[i][0].x, alpha[i][1].y));\n\t//cross[i].push_back(Point(alpha[i][1].x, alpha[i][0].y));\n\tcross[i].x1 = alpha[i].x1, cross[i].y1 = alpha[i].y2;\n\tcross[i].x2 = alpha[i].x2, cross[i].y2 = alpha[i].y1;\n      }\n    }\n    \n    rep(i, H){\n      rep(j, W){\n\trep(k, 4){\n\t  int nx = j+dx[k], ny = i+dy[k];\n\t  if(nx < 0 || nx > W || ny < 0 || ny > H) continue;\n\t  if(field[i][j] == field[ny][nx]) found[field[i][j]-'A'] = false;\n\t}\n      }\n    }\n    \n    int ans = 0;\n    for(; ;){\n    Start:;\n      bool flag = false;\n      rep(i, 26){\n\tif(found[i]){\t  \t \n\t  int X1 = cross[i].x1, Y1 = cross[i].y1, X2 = cross[i].x2, Y2 = cross[i].y2;\n\t  int x1 = alpha[i].x1, y1 = alpha[i].y1, x2 = alpha[i].x2, y2 = alpha[i].y2;\n\t  char c = 'A'+i;\n\t  \n\t  if(x1 == x2){\n\t    flag = checkW(y1, y2, x1, c);\n\t  }\n\t  else if(y1 == y2){\n\t    flag = checkH(x1, x2, y1, c);\t    \n\t  }\n\t  else{\n\t    if(((checkH(X1, x2, Y1, c) && (checkW(Y1, y1, X1, c)))) ||\n\t       ((checkH(X2, x1, Y2, c) && (checkW(Y2, y2, X2, c))))){\n\t      flag = true;\n\t    }\n\t  }\n\t  \n\t  if(flag){\n\t    //cout << c << endl;\n\t    found[i] = false;\n\t    ans += 2;\n\t    field[y1][x1] = '.', field[y2][x2] = '.';\t    \n\t    goto Start;\n\t  }\n\t  \n\t}\n      }\n      if(!flag) break;\n    }\n    cout << ans << endl;\n  }  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint m,n;\nvector<P> data[30];\nvector<int> xindex;\nvector<int> yindex;\nint fie[250][250];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint pick[4];\nint pickx[4];\nint picky[4];\n\nint main(void){\n\tscanf(\"%d %d\",&n,&m);\n\tfor(int i=0;i<n;i++){\n\t\tstring str;\n\t\tcin >> str;\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(str[j]>='A' && str[j]<='Z'){\n\t\t\t\tdata[str[j]-'A'+1].push_back(P(j,i));\n\t\t\t\tif(j-1>=0)xindex.push_back(j-1);\n\t\t\t\txindex.push_back(j);\n\t\t\t\tif(j+1<m)xindex.push_back(j+1);\n\t\t\t\tif(i-1>=0)yindex.push_back(i-1);\n\t\t\t\tyindex.push_back(i);\n\t\t\t\tif(i+1<n)yindex.push_back(i+1);\n\t\t\t}\n\t\t}\n\t}\n\tsort(xindex.begin(),xindex.end());\n\txindex.erase(unique(xindex.begin(),xindex.end()),xindex.end());\n\tsort(yindex.begin(),yindex.end());\n\tyindex.erase(unique(yindex.begin(),yindex.end()),yindex.end());\n\tfor(int i=1;i<=26;i++){\n\t\tfor(int j=0;j<data[i].size();j++){\n\t\t\tdata[i][j].first=lower_bound(xindex.begin(),xindex.end(),data[i][j].first)-xindex.begin();\n\t\t\tdata[i][j].second=lower_bound(yindex.begin(),yindex.end(),data[i][j].second)-yindex.begin();\n\t\t\tfie[data[i][j].first][data[i][j].second]=i;\n\t\t}\n\t}\n\tbool flag=true;\n\tint score=0;\n\twhile(flag){\n\t\tflag=false;\n\t\tfor(int i=0;i<yindex.size();i++){\n\t\t\tfor(int j=0;j<xindex.size();j++){\n\t\t\t\tif(fie[j][i]==0){\n\t\t\t\t\tmemset(pick,0,sizeof(pick));\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tint x=j,y=i;\n\t\t\t\t\t\twhile((x>=0 && x<xindex.size() && y>=0 && y<yindex.size()) && fie[x][y]==0){\n\t\t\t\t\t\t\tx+=dx[k];\n\t\t\t\t\t\t\ty+=dy[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(fie[x][y]!=0){\n\t\t\t\t\t\t\tpick[k]=fie[x][y];\n\t\t\t\t\t\t\tpickx[k]=x;\n\t\t\t\t\t\t\tpicky[k]=y;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tfor(int l=k+1;l<4;l++){\n\t\t\t\t\t\t\tif(pick[k]==pick[l] && pick[k]!=0){\n\t\t\t\t\t\t\t\tscore+=2;\n\t\t\t\t\t\t\t\tfie[pickx[k]][picky[k]]=0;\n\t\t\t\t\t\t\t\tfie[pickx[l]][picky[l]]=0;\n\t\t\t\t\t\t\t\tflag=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",score);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//typedef\n//-------------------------#include <bits/stdc++.h>\n \nconst double pi = 3.141592653589793238462643383279;\n \n \nusing namespace std;\n \n//conversion\n//------------------------------------------\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\ninline int readInt() { int x; scanf(\"%d\", &x); return x; }\n \n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long long, long long> PLL;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n \n \n//container util\n \n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SQ(a) ((a)*(a))\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n \n \n//repetition\n//------------------------------------------\n#define FOR(i,s,n) for(int i=s;i<(int)n;++i)\n#define REP(i,n) FOR(i,0,n)\n#define MOD 1000000007\n \n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n \ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\nconst double EPS = 1E-8;\n \n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n \nclass UnionFind {\npublic:\n    vector <int> par; \n    vector <int> siz; \n\n    UnionFind(int sz_): par(sz_), siz(sz_, 1) {\n        for (ll i = 0; i < sz_; ++i) par[i] = i;\n    }\n    void init(int sz_) {\n        par.resize(sz_);\n        siz.assign(sz_, 1LL);\n        for (ll i = 0; i < sz_; ++i) par[i] = i;\n    }\n \n    int root(int x) { \n        while (par[x] != x) {\n            x = par[x] = par[par[x]];\n        }\n        return x;\n    }\n \n    bool merge(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) return false;\n        if (siz[x] < siz[y]) swap(x, y);\n        siz[x] += siz[y];\n        par[y] = x;\n        return true;\n    }\n \n    bool issame(int x, int y) { \n        return root(x) == root(y);\n    }\n \n    int size(int x) { \n        return siz[root(x)];\n    }\n};\n \n \nll modPow(ll x, ll n, ll mod = MOD){\n    ll res = 1;\n    while(n){\n        if(n&1) res = (res * x)%mod;\n \n        res %= mod;\n        x = x * x %mod;\n        n >>= 1;\n    }\n    return res;\n}\n \n#define SIEVE_SIZE 5000000+10\nbool sieve[SIEVE_SIZE];\nvoid makeSieve(){\n    for(int i=0; i<SIEVE_SIZE; ++i) sieve[i] = true;\n    sieve[0] = sieve[1] = false;\n    for(int i=2; i*i<SIEVE_SIZE; ++i) if(sieve[i]) for(int j=2; i*j<SIEVE_SIZE; ++j) sieve[i*j] = false;\n}\n \nbool isprime(ll n){\n    if(n == 0 || n == 1) return false;\n    for(ll i=2; i*i<=n; ++i) if(n%i==0) return false;\n    return true;\n}\n \nconst int MAX = 2000010;\nlong long fac[MAX], finv[MAX], inv[MAX];\n \n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n \n// 二項係数計算\nlong long COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n \nlong long extGCD(long long a, long long b, long long &x, long long &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    long long d = extGCD(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\n// 負の数にも対応した mod (a = -11 とかでも OK) \ninline long long mod(long long a, long long m) {\n    return (a % m + m) % m;\n}\n \n// 逆元計算 (ここでは a と m が互いに素であることが必要)\nlong long modinv(long long a, long long m) {\n    long long x, y;\n    extGCD(a, m, x, y);\n    return mod(x, m); // 気持ち的には x % m だが、x が負かもしれないので\n}\nll GCD(ll a, ll b){\n    \n    if(b == 0) return a;\n    return GCD(b, a%b);\n}\n\ntypedef vector<ll> vec;\ntypedef vector<vec> mat;\n\nmat mul(mat &A, mat &B) {\n    mat C(A.size(), vec((int)B[0].size()));\n    for(int i=0; i<A.size(); ++i){\n        for(int k=0; k<B.size(); ++k){\n            for(int j=0; j<B[0].size(); ++j){\n                C[i][j] = (C[i][j] + A[i][k] * B[k][j] %MOD) % MOD;\n            }\n        }\n    }\n    return C;\n}\nmat matPow(mat A, ll n) {\n    mat B(A.size(), vec((int)A.size()));\n \n    for(int i=0; i<A.size(); ++i){\n        B[i][i] = 1;\n    }\n \n    while(n > 0) {\n        if(n & 1) B = mul(B, A);\n        A = mul(A, A);\n        n >>= 1;\n    }\n    return B;\n}\n\nmap<ll,ll> prime_factor(ll n) {\n  map<ll,ll> res;\n  for(ll i=2; i*i <= n; i++) {\n      while(n%i == 0) {\n          res[i]++;\n          n /= i;\n      }\n  }\n\n  if(n != 1) res[n] = 1;\n  return res;\n}\n\nstruct Node {\n    int mi, mx;\n    Node(int mi, int mx) : mi(mi), mx(mx) {}\n    Node(){}\n} seg[1<<23];\n\nvoid update(int i, int x){\n    i += (1<<22)-1;\n    seg[i].mi = seg[i].mx = x;\n\n    while(i > 0){\n        i = (i-1)/2;\n        seg[i].mi = min(seg[i*2+1].mi, seg[i*2+2].mi);\n        seg[i].mx = max(seg[i*2+1].mx, seg[i*2+2].mx);\n    }\n}\n\nNode query(int a, int b, int k=0, int l=0, int r = (1<<22)){\n    if(r <= a || b <= l) return Node(INT_MAX, -INT_MAX);\n    if(a <= l && r <= b) return seg[k];\n    else{\n        Node vl = query(a, b, k*2+1, l, (l+r)/2);\n        Node vr = query(a, b, k*2+2, (l+r)/2, r);\n\n        return Node(min(vl.mi, vr.mi), max(vl.mx, vr.mx));\n    }\n}\n\nbool erased[510][510];\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(12);\n    \n    \n    int H, W; cin >> H >> W;\n    vector<pair<int, char>> h[510], w[510];\n    vector<string> f;\n    REP(i,H){\n        string s; cin >> s;\n        f.push_back(s);\n    }\n\n    \n\n    int ans = 0;\n    bool update = true;\n    while(update){\n        update = false;\n        vector<pair<int, char>> h[510], w[510];\n        REP(i,H){\n            h[i].push_back({-1, '0'});\n            REP(j,W){\n                if(f[i][j] != '.'){\n                    //横方向に文字を見ていく\n                    h[i].push_back({j, f[i][j]});\n                }\n            }\n\n            h[i].push_back({INT_MAX, '0'});\n        }\n\n        REP(j,W){\n            w[j].push_back({-1, '0'});\n            REP(i,H){\n                if(f[i][j] != '.'){\n                    //縦方向に文字を見ていく\n                    w[j].push_back({i, f[i][j]});\n                }\n            }\n\n            w[j].push_back({INT_MAX, '0'});\n        }\n\n        memset(erased, false, sizeof(erased));\n\n        for(int i=0; i<H; i++){\n            for(int j=0; j<W; j++){\n                if(f[i][j] == '.'){\n                    //左右上下の文字を取得\n\n                    //横方向\n                    auto itr1 = lower_bound(all(h[i]), make_pair(j, '0'));\n                    \n                    //縦方向\n                    auto itr2 = lower_bound(all(w[j]), make_pair(i, '0'));\n\n                    pair<int, char> up,left,right,down;\n                    right = *(itr1);\n                    down = *(itr2);\n\n                    itr1--;\n                    itr2--;\n                    \n                    left = *(itr1);\n                    up = *(itr2);\n                    \n                    \n                    if(up.second != '0'){\n                        if(up.second == left.second){\n                            erased[up.first][j]=true;\n                            erased[i][left.first]=true;\n                        }\n                        if(up.second == right.second){\n                            erased[up.first][j]=true;\n                            erased[i][right.first]=true;\n                        }\n                        if(up.second == down.second){\n                            erased[up.first][j]=true;\n                            erased[down.first][j]=true;\n                        }\n                    }\n                    if(left.second != '0'){\n                        if(left.second == right.second){\n                            erased[i][left.first]=true;\n                            erased[i][right.first]=true;\n                        }\n                        if(left.second == down.second){\n                            erased[down.first][j]=true;\n                            erased[i][left.first]=true;\n                        }\n                    }\n                    if(right.second != '0'){\n                        if(right.second == down.second){\n                            erased[down.first][j]=true;\n                            erased[i][right.first]=true;\n                        }\n                    }\n                }\n            }\n        }\n\n        for(int i=0; i<H; i++){\n            for(int j=0; j<W; j++){\n                if(erased[i][j]){\n                    ans++;\n                    f[i][j] = '.';\n                    update = true;\n                }\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<list>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<cmath>\n#include<cstring>\nusing namespace std;\nchar a[500][500];\nint fn(int x[],int y){\n  int i;\n  for(i=min(x[0],x[1])+1;i<max(x[0],x[1]);++i){\n    if(a[y][i]!='.')\n      break;\n  }\n  if(i<max(x[0],x[1]))\n    return 0;\n  else\n    return 1;\n}\nint fn(int x,int y[]){\n  int i;\n  for(i=min(y[0],y[1])+1;i<max(y[0],y[1]);++i){\n    if(a[i][x]!='.')\n      break;\n  }\n  if(i<max(y[0],y[1]))\n    return 0;\n  else\n    return 1;\n}\nint main(){\n  int i,j;\n  int h,w;\n  while(cin>>h>>w){\n    int x[26][2],y[26][2];\n    memset(x,-1,sizeof(x));    \n    for(i=0;i<h;++i){\n      for(j=0;j<w;++j){\n\tcin>>a[i][j];\n\tif(a[i][j]!='.'){\n\t  if(x[a[i][j]-'A'][0]<0){\n\t    x[a[i][j]-'A'][0]=j;\n\t    y[a[i][j]-'A'][0]=i;\n\t  }else{\n\t    x[a[i][j]-'A'][1]=j;\n\t    y[a[i][j]-'A'][1]=i;\n\t  }\n\t}\n      }\n    }\n    int b;\n    int sm=0;\n    do{\n      b=0;\n      for(i=0;i<26;++i){\n\tif(x[i][0]>=0){\n\t  if(0){\n\t  }else if(abs(x[i][0]-x[i][1])+abs(y[i][0]-y[i][1])==1){\n\t  }else if(x[i][0]==x[i][1]){\n\t    if(fn(x[i][0],y[i])){\n\t      a[y[i][0]][x[i][0]]=a[y[i][1]][x[i][1]]='.';\n\t      x[i][0]=-1;\n\t      ++sm;\n\t      b=1;\n\t    }\n\t  }else if(y[i][0]==y[i][1]){\n\t    if(fn(x[i],y[i][0])){\n\t      a[y[i][0]][x[i][0]]=a[y[i][1]][x[i][1]]='.';\n\t      x[i][0]=-1;\n\t      ++sm;\n\t      b=1;\n\t    }\n\t  }else{\n\t    if(a[y[i][1]][x[i][0]]=='.'){\n\t      if(fn(x[i],y[i][1])){\n\t\tif(fn(x[i][0],y[i])){\n\t\t  a[y[i][0]][x[i][0]]=a[y[i][1]][x[i][1]]='.';\n\t\t  x[i][0]=-1;\n\t\t  ++sm;\n\t\t  b=1;\n\t\t  continue;\n\t\t}\n\t      }\n\t    }\n\t    if(a[y[i][0]][x[i][1]]=='.'){\n\t      if(fn(x[i],y[i][0])){\n\t\tif(fn(x[i][1],y[i])){\n\t\t  a[y[i][0]][x[i][0]]=a[y[i][1]][x[i][1]]='.';\n\t\t  x[i][0]=-1;\n\t\t  ++sm;\n\t\t  b=1;\n\t\t  continue;\n\t\t}\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }while(b);\n    cout<<sm*2<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nint M, N;\nchar f[512][512];\n\nbool click(int x, int y, char target) {\n    if(f[x][y]!='.') return false;\n    int tx[4], ty[4];\n    rep(d, 4) {\n        tx[d] = x, ty[d] = y;\n        while(f[tx[d]][ty[d]]=='.') {\n            tx[d] += dx[d];\n            ty[d] += dy[d];\n        }\n    }\n    rep(i, 4) if(f[tx[i]][ty[i]]==target) {\n        rep(j, i) if(f[tx[j]][ty[j]]==target) {\n            f[tx[i]][ty[i]] = f[tx[j]][ty[j]] = '.';\n            return true;\n        }\n    }\n    return false;\n}\n\nint xof[32][2], yof[32][2];\n\nint main() {\n    scanf(\"%d%d\", &M, &N);\n    memset(f, '#', sizeof(f));\n    rep(i, M) rep(j, N) scanf(\" %c\", f[i+1]+j+1);\n    memset(xof, -1, sizeof(xof));\n    memset(yof, -1, sizeof(yof));\n    rep(i, M) rep(j, N) if(f[i+1][j+1]!='.') {\n        const int ix = f[i+1][j+1]-'A';\n        if(xof[ix][0]==-1) xof[ix][0]=i+1, yof[ix][0]=j+1;\n        else xof[ix][1]=i+1, yof[ix][1]=j+1;\n    }\n    bool nothing = false;\n    int ans = 0;\n    while(!nothing) {\n        nothing = true;\n        rep(i, 32) if(xof[i][0]!=-1) {\n            bool hit = false;\n            if(xof[i][0]==xof[i][1]) {\n                hit = click(xof[i][0], (yof[i][0]+yof[i][1])/2, i+'A');\n            }\n            else if(yof[i][0]==yof[i][1]) {\n                hit = click((xof[i][0]+xof[i][1])/2, yof[i][0], i+'A');\n            }\n            else {\n                hit |= click(xof[i][0], yof[i][1], i+'A');\n                hit |= click(xof[i][1], yof[i][0], i+'A');\n            }\n            if(hit) {\n                nothing = false;\n                xof[i][0] = -1;\n                ans += 2;\n            }\n        }\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Enjoy your stay.\n\n#include <bits/stdc++.h>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(auto it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define mt make_tuple\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\ntypedef stringstream sst;\ntypedef vector<ll> vi;\n\nint M,N;\nchar c[555][555];\nint y[33][2],x[33][2],num[33];\nint del[33];\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\tcin>>M>>N;\n\trep(i,M)cin>>c[i];\n\tvi ys,xs;\n\tmemset(y,-1,sizeof(y));\n\trep(i,M)rep(j,N){\n\t\tif(isupper(c[i][j])){\n\t\t\tint col = c[i][j] - 'A';\n\t\t\ty[col][num[col]] = i;\n\t\t\tx[col][num[col]] = j;\n\t\t\tnum[col]++;\n\t\t\trep2(d,-1,2){\n\t\t\t\tys.pb(i+d);\n\t\t\t\txs.pb(j+d);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\twhile(1){\n\t\tint flag = 0;\n\t\t//rep(yi,sz(ys))rep(xi,sz(xs)){\n\t\trep(Y,M)rep(X,N){\n\t\t\t//int Y = ys[yi], X = xs[xi];\n\t\t\tif(Y<0 || M<=Y || X<0 || N<=X)continue;\n\t\t\tint ok = 1;\n\t\t\trep(i,26)if(!del[i] && (Y == y[i][0] && X == x[i][0]\n\t\t\t\t|| Y == y[i][1] && X == x[i][1]))ok=0;\n\t\t\tif(!ok)continue;\n\n\t\t\tint left = -INF, right = INF, up = -INF, down = INF;\n\t\t\tint l=-1,r=-2,u=-3,d=-4;\n\t\t\trep(i,26)if(y[i][0] != -1 && !del[i])rep(j,2){\n\t\t\t\tif(y[i][j] == Y){\n\t\t\t\t\tif(x[i][j] < X && x[i][j] > left){\n\t\t\t\t\t\tleft = x[i][j];\n\t\t\t\t\t\tl = i;\n\t\t\t\t\t}\n\t\t\t\t\tif(x[i][j] > X && x[i][j] < right){\n\t\t\t\t\t\tright = x[i][j];\n\t\t\t\t\t\tr = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(x[i][j] == X){\n\t\t\t\t\tif(y[i][j] < Y && y[i][j] > up){\n\t\t\t\t\t\tup = y[i][j];\n\t\t\t\t\t\tu = i;\n\t\t\t\t\t}\n\t\t\t\t\tif(y[i][j] > Y && y[i][j] < down){\n\t\t\t\t\t\tdown = y[i][j];\n\t\t\t\t\t\td = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint focus[4] = {l,r,u,d};\n\t\t\trep(i,4)rep2(j,i+1,4)if(focus[i] == focus[j]){\n\t\t\t\tans += 2;\n\t\t\t\tdel[focus[i]] = 1;\n\t\t\t\tflag = 1;\n\t\t\t\t//cout<<(char)(focus[i]+'A')<<endl;\n\t\t\t}\n\t\t}\n\t\tif(!flag)break;\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "// Enjoy your stay.\n\n#include <bits/stdc++.h>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(auto it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define mt make_tuple\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\ntypedef stringstream sst;\ntypedef vector<ll> vi;\n\nint M,N;\nchar c[555][555];\nint y[33][2],x[33][2],num[33];\nint del[33];\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\tcin>>M>>N;\n\trep(i,M)cin>>c[i];\n\tvi ys,xs;\n\tmemset(y,-1,sizeof(y));\n\trep(i,M)rep(j,N){\n\t\tif(isupper(c[i][j])){\n\t\t\tint col = c[i][j] - 'A';\n\t\t\ty[col][num[col]] = i;\n\t\t\tx[col][num[col]] = j;\n\t\t\tnum[col]++;\n\t\t\trep2(d,-1,2){\n\t\t\t\tys.pb(i+d);\n\t\t\t\txs.pb(j+d);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\twhile(1){\n\t\tint flag = 0;\n\t\trep(yi,sz(ys))rep(xi,sz(xs)){\n\t\t\tint Y = ys[yi], X = xs[xi];\n\t\t\tif(Y<0 || M<=Y || X<0 || N<=X)continue;\n\t\t\tint ok = 1;\n\t\t\trep(i,26)if(!del[i] && (Y == y[i][0] && X == x[i][0]\n\t\t\t\t|| Y == y[i][1] && X == x[i][1]))ok=0;\n\t\t\tif(!ok)continue;\n\n\t\t\tint left = -INF, right = INF, up = -INF, down = INF;\n\t\t\tint l=-1,r=-2,u=-3,d=-4;\n\t\t\trep(i,26)if(y[i][0] != -1 && !del[i])rep(j,2){\n\t\t\t\tif(y[i][j] == Y){\n\t\t\t\t\tif(x[i][j] < X && x[i][j] > left){\n\t\t\t\t\t\tleft = x[i][j];\n\t\t\t\t\t\tl = i;\n\t\t\t\t\t}\n\t\t\t\t\tif(x[i][j] > X && x[i][j] < right){\n\t\t\t\t\t\tright = x[i][j];\n\t\t\t\t\t\tr = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(x[i][j] == X){\n\t\t\t\t\tif(y[i][j] < Y && y[i][j] > up){\n\t\t\t\t\t\tup = y[i][j];\n\t\t\t\t\t\tu = i;\n\t\t\t\t\t}\n\t\t\t\t\tif(y[i][j] > Y && y[i][j] < down){\n\t\t\t\t\t\tdown = y[i][j];\n\t\t\t\t\t\td = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint focus[4] = {l,r,u,d};\n\t\t\trep(i,4)rep2(j,i+1,4)if(focus[i] == focus[j]){\n\t\t\t\tans += 2;\n\t\t\t\tdel[focus[i]] = 1;\n\t\t\t\tflag = 1;\n\t\t\t\t//cout<<(char)(focus[i]+'A')<<endl;\n\t\t\t}\n\t\t}\n\t\tif(!flag)break;\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) begin(v), end(v)\n#define REV(v) rbegin(v), rend(v)\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint main(){\n\tint n, m;\n\tcin >> n >> m;\n\n\tvector<string> v(n);\n\trep(i, n) cin >> v[i];\n\n\tvector<P> a[26];\n\trep(i, n) rep(j, m){\n\t\tif (v[i][j] != '.') a[v[i][j] - 'A'].push_back(MP(j, i));\n\t}\n\n\tvector<int> bits[26];\n\tint ex[26] = {};\n\n\tauto f_x = [&bits, &v](int x1, int x2, int y, int i, int j){\n\t\tfor (int x = x1; x <= x2; ++x) if (v[y][x] != '.') bits[i][j] |= 1 << v[y][x] - 'A';\n\t\tbits[i][j] &= ~(1 << i);\n\t};\n\tauto f_y = [&bits, &v](int y1, int y2, int x, int i, int j){\n\t\tfor (int y = y1; y <= y2; ++y) if (v[y][x] != '.') bits[i][j] |= 1 << v[y][x] - 'A';\n\t\tbits[i][j] &= ~(1 << i);\n\t};\n\n\trep(i, 26){\n\t\tif (a[i].empty()) continue;\n\t\tex[i] = 1;\n\t\tbits[i].resize(1);\n\n\t\tint t, b, l, r;\n\t\tt = a[i][0].Y;\n\t\tb = a[i][1].Y;\n\t\tl = a[i][0].X;\n\t\tr = a[i][1].X;\n\t\tif (l == r){\n\t\t\tif (t > b) swap(t, b);\n\t\t\tf_y(t, b, l, i, 0);\n\t\t\tif (b - t == 1) bits[i][0] = -1;\n\t\t}\n\t\telse if (t == b){\n\t\t\tif (l > r) swap(l, r);\n\t\t\tf_x(l, r, t, i, 0);\n\t\t\tif (r - l == 1) bits[i][0] = -1;\n\t\t}\n\t\telse{\n\t\t\tbits[i].resize(2);\n\t\t\tvector<int> j = { 0, 1, 1, 0 };\n\t\t\tif (l > r){\n\t\t\t\tswap(j[1], j[3]);\n\t\t\t\tswap(l, r);\n\t\t\t}\n\t\t\tf_x(l, r, t, i, j[0]);\n\t\t\tf_y(t, b, l, i, j[1]);\n\t\t\tf_x(l, r, b, i, j[2]);\n\t\t\tf_y(t, b, r, i, j[3]);\n\t\t}\n\t}\n\n\tint cnt = 0;\n\tint state = (1 << 26)-1;\n\twhile (1){\n\t\tbool upd = false;\n\n\t\trep(i, 26){\n\t\t\tif (!ex[i]) continue;\n\t\t\tbool er = false;\n\t\t\tfor(auto x : bits[i]){\n\t\t\t\tif (x&state) continue;\n\t\t\t\ter = true;\n\t\t\t}\n\t\t\tif (er){\n\t\t\t\tex[i] = 0, upd = true, ++cnt;\n\t\t\t\tstate &= ~(1 << i);\n\t\t\t}\n\t\t}\n\n\t\tif (!upd) break;\n\t}\n\tcout << cnt * 2 << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define x first\n#define y second\nusing namespace std;\ntypedef pair <int,int> P;\nstring mp[501];\nint m,n,used[30],ans;\nvector <P>  a[30];\n\nint saiki(int);\n\nbool check_x(int y,int x1,int x2){\n  for(int i=x1+1;i<x2;i++)\n    if(mp[y][i]!='.'&&!saiki(mp[y][i]-'A'))return 0;\n  return 1;\n}\n\nbool check_y(int y1,int y2,int x){\n  for(int i=y1+1;i<y2;i++)\n    if(mp[i][x]!='.'&&!saiki(mp[i][x]-'A')) return 0;\n  return 1;\n}\n\n\nint saiki(int ch){  \n  int x1=a[ch][0].x,x2=a[ch][1].x;\n  int y1=a[ch][0].y,y2=a[ch][1].y;\n  int res=0;\n  if(used[ch])return 0;\n  used[ch]=1;\n  \n  if(x1==x2&&y2-y1!=1) res=check_y(y1,y2,x1);\n  if(y1==y2&&x2-x1!=1) res=check_x(y1,x1,x2);\n\n  if(x1!=x2&&y1!=y2) {\n    if(x1<x2){\n      res=check_x(y1,x1,x2+1)&check_y(y1,y2,x2);\n      res|=check_y(y1,y2+1,x1)&check_x(y2,x1,x2);\n    }\n    else{\n      swap(x1,x2);\n      res=check_x(y1,x1-1,x2)&check_y(y1,y2,x1);\n      res |=check_y(y1,y2,x2)&check_x(y2,x1,x2+1);\n      swap(x1,x2);\n    }\n  }\n    \n\n  used[ch]=0;\n  if(res) {\n    mp[y1][x1]=mp[y2][x2]='.';\n    a[ch].clear();\n    ans+=2;\n    used[ch]=1;\n  }\n\n  return res;\n}\n\nint main(){\n\n  cin>>m>>n;\n  for(int i=0;i<m;i++)cin>>mp[i];\n\n  for(int i=0;i<m;i++)\n    for(int j=0;j<n;j++)\n      if(mp[i][j]!='.')a[mp[i][j]-'A'].push_back(P(j,i));\n  \n  \n  for(int i=0;i<30;i++)if(a[i].size()) saiki(i);\n  \n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\n\nint h,w;\nstring s[600];\nint dy[]={0,1,0,-1};\nint dx[]={1,0,-1,0};\nint sum=0;\n\nbool ng[555][555];\n\nvoid knock(int Y,int X){\n  \n  map<char,vector<P> >M;\n  r(i,4){\n    int y=Y;\n    int x=X;\n\n    while(!isalpha(s[y][x])){\n      y+=dy[i];\n      x+=dx[i];\n      if(y<0||x<0||y>=h||x>=w)break;\n    }\n\n    if(y<0||x<0||y>=h||x>=w)continue;\n    M[s[y][x]].push_back(P(y,x));\n  }\n\n  int TX=0;\n  for(auto &e:M){\n    if(e.second.size()!=2)continue;\n    sum+=2;\n    s[e.second[0].first][e.second[0].second] = '.';\n    s[e.second[1].first][e.second[1].second] = '.';\n    TX++;\n  }\n\n  if(!M.size())ng[Y][X]=1;\n\n}\n\nsigned main(){\n  cin>>h>>w;\n  r(i,h)cin>>s[i];\n\n  r(tim,26)r(i,h)r(j,w)if(!isalpha(s[i][j])&&!ng[i][j]){\n    knock(i,j);\n  }\n\n  cout<<sum<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\n\nchar field[501][501];\n// wèµ½ê©çãº¶EÌ}XÉÅÉ»êéL\nvoid solve(){\n    int h,w;\n    cin>>h>>w;\n    for(int i = 0; i < h; i++)\n        for(int j = 0; j < w; j++)\n            cin>>field[i][j];\n    const int dy[]={-1,0,0,1};\n    const int dx[]={0,1,-1,0};\n    bool update=true;\n    int score=0;\n    while(update){\n        update=false;\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                if(field[i][j]=='.'){\n                    map<char,vector<pair<int,int> > > m; \n                    // eûüÖTõ\n                    for(int k = 0; k < 4; k++){\n                        int x = j + dx[k];\n                        int y = i + dy[k];\n                        while(1){\n                            if(!(x>=0&&y>=0&&y<h&&x<w))\n                                break;\n                            if(field[y][x]!='.'){\n                                m[field[y][x]].push_back(make_pair(y,x));\n                                break;\n                            }\n                            x+=dx[k];y+=dy[k];\n                        }\n                    }\n                    // ñÂÈãÌÀWªüÁÄ¢éêª êÎAí\n                    for(map<char,vector<pair<int,int> > >::iterator it = m.begin();it!=m.end();it++){\n                        if(it->second.size()>=2){\n                            update=true;\n                            for(int k = 0; k < it->second.size(); k++){\n                                field[it->second[k].first][it->second[k].second]='.';\n                                score++;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    cout<<score<<endl;\n}\nint main(){\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n\nint dx[4] = { -1,0,1,0 };\nint dy[4] = { 0,1,0,-1 };\nint H, W;\nint check(vector<vector<int>>&field, int y, int x) {\n\tvector<int>colors;\n\tvector<int>xs;\n\tvector<int>ys;\n\tfor (int i = 0; i < 4; ++i) {\n\t\tint ny(y), nx(x);\n\t\twhile (1) {\n\t\t\tny += dy[i]; nx += dx[i];\n\t\t\tif (ny < 0 || ny >= H || nx < 0 || nx >= W)break;\n\t\t\tif (field[ny][nx]) {\n\t\t\t\tcolors.push_back(field[ny][nx]);\n\t\t\t\txs.push_back(nx);\n\t\t\t\tys.push_back(ny);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tint score = 0;\n\tfor (int i = 0; i < colors.size(); ++i) {\n\t\tfor (int j = i + 1; j < colors.size(); ++j) {\n\t\t\tif (colors[i] == colors[j]) {\n\t\t\t\tif (colors[i] != 0) {\n\t\t\t\t\tfield[ys[i]][xs[i]] = 0;\n\t\t\t\t\tfield[ys[j]][xs[j]] = 0;\n\t\t\t\t\tscore += 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn score;\n}\n\nint main() {\ncin >> H >> W;\n\tvector<vector<int>>field(H,vector<int>(W));\n\tfor (int i = 0; i < W; ++i) {\n\t\t\n\t}\n\tfor (int i = 0; i < H; ++i) {\n\t\tstring st; cin >> st;\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tif (st[j] != '.') {\n\t\t\t\tfield[i][j] = st[j] - 'A' + 1;\n\t\t\t}\n\t\t}\n\t}\n\tbool flag = true;\n\tint score = 0;\n\twhile (flag) {\n\t\tflag = false;\n\t\tint plusscore = 0;\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tif (!field[y][x]) {\n\t\t\t\t\tplusscore+=check(field, y, x);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (plusscore) {\n\t\t\tflag = true;\n\t\t\tscore += plusscore;\n\t\t}\n\t}\n\tcout << score << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef pair<int,int> point;\ntypedef pair<char,point> P;\nstring ban[500];\nint n,m;\nvector<point> v;//このターンで消すブロックの座標\nset<int> gyou;//前のターンで消した行\nset<int> retsu;//前のターンで消した列\nint dx[4]={1,0,-1,0};\nint dy[4]={0,-1,0,1};\n//座標としてban[x][y]を選んだときに消せる座標をvに追加する\nvoid checkAndErase(int x,int y)\n{\n\tif(ban[x][y]!='.')\n\t\treturn;\n\tvector<P> ret;\n\t//4方向調べる\n\tfor(int i=0;i<4;i++)\n\t{\n\t\tint nx=x;\n\t\tint ny=y;\n\t\tbool f=false;\n\t\twhile(nx>=0 && nx<m && ny>=0 && ny<n)\n\t\t{\n\t\t\tif(ban[nx][ny]!='.')\n\t\t\t{\n\t\t\t\tf=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnx+=dx[i];\n\t\t\tny+=dy[i];\n\t\t}\n\t\tif(f)\n\t\t\tret.push_back(P(ban[nx][ny],point(nx,ny)));\n\t}\n\tsort(ret.begin(),ret.end());\n\t//同じ文字が含まれているか確認する\n\tfor(int i=1;i<ret.size();i++)\n\t{\n\t\tif(ret[i].first==ret[i-1].first)\n\t\t{\n\t\t\tv.push_back(ret[i].second);\n\t\t\tv.push_back(ret[i-1].second);\n\t\t}\n\t}\n\treturn;\n}\n\nint main()\n{\n\tcin>>m>>n;\n\tint ans=0;\n\tfor(int i=0;i<m;i++)\n\t\tcin>>ban[i];\n\tfor(int i=0;i<500;i++)\n\t\tgyou.insert(i);\n\tdo{\n\t\tv.clear();\n\t\t//全座標の点の部分を調べる\n\t\tfor(int i=0;i<m;i++)\n\t\t{\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tif(!(gyou.count(i)==1 || retsu.count(j)==1))\n\t\t\t\t\tcontinue;\n\t\t\t\tcheckAndErase(i,j);\n\t\t\t}\n\t\t}\n\t\t//重複を取り除いて消す\n\t\tif(v.size()==0)\n\t\t\tbreak;\n\t\tgyou.clear();\n\t\tretsu.clear();\n\t\tsort(v.begin(),v.end());\n\t\tv.erase(unique(v.begin(),v.end()),v.end());\n\t\tfor(int i=0;i<v.size();i++)\n\t\t{\n\t\t\tans++;\n\t\t\tban[v[i].first][v[i].second]='.';\n\t\t\tgyou.insert(v[i].first);\n\t\t\tretsu.insert(v[i].second);\n\t\t}\n\t}while(1);\n\tcout<<ans<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int h,w;\n  cin>>h>>w;\n  vector<string> st(h);\n  for(Int i=0;i<h;i++) cin>>st[i];\n  \n  using P = pair<Int, Int>;\n  vector<vector<P> > G(26);\n  for(Int i=0;i<h;i++){\n    for(Int j=0;j<w;j++){\n      if(st[i][j]=='.') continue;\n      G[st[i][j]-'A'].emplace_back(i,j);\n    }\n  }\n  \n  Int ans=0;\n  for(Int t=0;t<26;t++){\n    for(Int i=0;i<26;i++){\n      if(G[i].empty()) continue;\n      Int a,b,c,d;\n      tie(a,b)=G[i][0];\n      tie(c,d)=G[i][1];\n      if(st[a][b]=='.') continue;\n\n      assert(a<=c);\n      if(a==c){\n        assert(b<d);\n        if(b+1==d) continue;\n        Int flg=1;\n        for(Int k=b+1;k<d;k++)\n          flg&=st[a][k]=='.';\n        if(!flg) continue;\n        ans++;\n        st[a][b]=st[c][d]='.';\n        continue;\n      }\n      \n      if(b==d){\n        assert(a!=c);\n        if(a+1==c) continue;\n        Int flg=1;\n        for(Int k=a+1;k<c;k++)\n          flg&=st[k][b]=='.';\n        if(!flg) continue;\n        ans++;\n        st[a][b]=st[c][d]='.';\n        continue;\n      }\n      \n      if(b<d){\n        {\n          Int flg=1;\n          for(Int k=b+1;k<=d;k++)\n            flg&=st[a][k]=='.';\n          for(Int k=a;k<c;k++)\n            flg&=st[k][d]=='.';\n          \n          if(flg){\n            ans++;\n            st[a][b]=st[c][d]='.';\n            continue;\n          }\n        }\n        \n        {\n          Int flg=1;\n          for(Int k=a+1;k<=c;k++)\n            flg&=st[k][b]=='.';\n          for(Int k=b;k<d;k++)\n            flg&=st[c][k]=='.';\n          \n          if(flg){\n            ans++;\n            st[a][b]=st[c][d]='.';\n            continue;\n          }\n        }        \n      }else{\n\n        {\n          Int flg=1;\n          for(Int k=d;k<b;k++)\n            flg&=st[a][k]=='.';\n          for(Int k=a;k<c;k++)\n            flg&=st[k][d]=='.';\n          \n          if(flg){\n            ans++;\n            st[a][b]=st[c][d]='.';\n            continue;\n          }\n        }\n        \n        {\n          Int flg=1;\n          for(Int k=a+1;k<=c;k++)\n            flg&=st[k][b]=='.';\n          for(Int k=d+1;k<=b;k++)\n            flg&=st[c][k]=='.';\n          \n          if(flg){\n            ans++;\n            st[a][b]=st[c][d]='.';\n            continue;\n          }\n        }        \n      }\n    }\n  }\n  \n  ans*=2;\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <string.h>\n\n\nvoid gstr(char *str){\n\tint i;\n\tfor(i = 0;(str[i] = getchar()) != '\\n';i++);\n\tstr[i] = '\\0';\n}\n\nint main(void){\n\tint i, j, k, l, m, n, h, w, dx[4] = {0,1,0,-1}, dy[4] = {-1,0,1,0}, ans = 0, f[500][500];\n\tchar s[500][501], *c[4];\n\tscanf(\"%d%d%*c\",&h,&w);\n\tfor(i = 0;i < h;i++) gstr(s[i]);\n\tmemset(f,0,sizeof(f));\n\tfor(i = 0;i < h;i++){\n\t\tfor(j = 0;j < w;j++){\n\t\t\tif(isupper(s[i][j])){\n\t\t\t\tfor(k = 0;k < 4;k++){\n\t\t\t\t\tfor(l = 1;i + dy[k] * l >=  0 && i + dy[k] * l < h && j + dx[k] * l >= 0 && j + dx[k] * l < w && !isupper(s[i + dy[k] * l][j + dx[k] * l]);l++)\n\t\t\t\t\t\tf[i + dy[k] * l][j + dx[k] * l]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(i = 0;i < h;i++){\n\t\tfor(j = 0;j < w;j++){\n\t\t\tif(!isupper(s[i][j]) && f[i][j] >= 2){\n\t\t\t\tfor(k = 0;k < 4;k++){\n\t\t\t\t\tfor(l = 0;i + dy[k] * l >=  0 && i + dy[k] * l < h && j + dx[k] * l >= 0 && j + dx[k] * l < w && !isupper(s[i + dy[k] * l][j + dx[k] * l]);l++);\n\t\t\t\t\tif(i + dy[k] * l >= 0 && i + dy[k] * l < h && j + dx[k] * l >= 0 && j + dx[k] * l < w) c[k] = &s[i + dy[k] * l][j + dx[k] * l];\n\t\t\t\t\telse c[k] = NULL;\n\t\t\t\t}\n\t\t\t\tfor(k = 0;k < 3;k++){\n\t\t\t\t\tfor(l = k + 1;l < 4;l++)\n\t\t\t\t\t\tif(c[k] != NULL && c[l] != NULL && k != l && *c[k] == *c[l] && *c[k] != '.') *c[k] = '.',*c[l] = '.',i = -1, ans += 2;\n\t\t\t\t}\n\t\t\t\tif(i == -1){\n\t\t\t\t\tmemset(f,0,sizeof(f));\n\t\t\t\t\tfor(k = 0;k < h;k++){\n\t\t\t\t\t\tfor(l = 0;l < w;l++){\n\t\t\t\t\t\t\tif(isupper(s[k][l])){\n\t\t\t\t\t\t\t\tfor(m = 0;m < 4;m++){\n\t\t\t\t\t\t\t\t\tfor(n = 1;k + dy[m] * n >= 0 && k + dy[m] * n < h && l + dx[m] * n >= 0 && l + dx[m] * n < w && !isdigit(s[k + dy[m] * n][l + dx[m] * n]);n++){\n\t\t\t\t\t\t\t\t\t\tf[k + dy[m] * n][l + dx[m] * n]++;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i == -1) break;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef pair<int,int> P;\nint res=0;\nint m,n;\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nmap<int,vector<P>> pos;\n\nbool check(vector<string> &s, int sx,int sy){\n    map<int,int> mp;\n    int gx,gy;\n    bool f=false;\n    for(int i=0;i<4;i++){\n        gx=sx,gy=sy;\n        while(true){\n            gx += dx[i]; gy += dy[i];\n            if(gx<0 || m<=gx || gy<0 || n<=gy) break;\n            if(s[gx][gy]=='.') continue;\n            int idx=s[gx][gy]-'A';\n            if(mp[idx]){\n                res+=2;\n                f=true;\n                P p1=pos[idx][0],p2=pos[idx][1];\n                s[p1.first][p1.second]='.';\n                s[p2.first][p2.second]='.';\n            }\n            else mp[idx]++;\n            break;\n        }\n    }\n    return f;\n}\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin>>m>>n;\n    vector<string> s(m);\n    for(int i=0;i<m;i++){\n        cin>>s[i];\n        for(int j=0;j<n;j++){\n            if(s[i][j]=='.') continue;\n            int idx=s[i][j]-'A';\n            pos[idx].push_back(P(i,j));\n        }\n    }\n    while(true){\n        bool f=false;\n        for(int i=0;i<m;i++){\n            if(f) break;\n            for(int j=0;j<n;j++){\n                if(f) break;\n                if(s[i][j]!='.') continue;\n                f |= check(s,i,j);\n            }\n        }\n        if(!f) break;\n    }\n    cout<<res<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e16;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n\nll m,n;\nvector<string> vs;\nll dx[] = {0,1,0,-1};\nll dy[] = {1,0,-1,0};\n\nbool in(ll cy,ll cx){\n    return cy >= 0 && cy < m && cx >= 0 && cx < n;\n}\n\nchar get(ll cy,ll cx,ll dir){\n    ll ny = cy,nx = cx;\n    while(in(ny,nx)){\n        if(vs[ny][nx] != '.')return vs[ny][nx];\n        ny += dy[dir];\n        nx += dx[dir];\n    }\n    return '#';\n}\n\nvoid erase(ll cy,ll cx,ll dir,char c){\n    ll ny = cy,nx = cx;\n    while(in(ny,nx)){\n        if(vs[ny][nx] == c){\n            vs[ny][nx] = '.';\n            return;\n        }\n        ny += dy[dir];\n        nx += dx[dir];\n    }\n}\n\nll solve(ll cy,ll cx){\n    map<char,ll> m;\n    rep(i,4)m[get(cy,cx,i)]++;\n    ll res = 0;\n    rep(i,26){\n        if(m[(char)('A'+i)] == 2){\n            rep(j,4)erase(cy,cx,j,(char)('A'+i));\n            res += 2;\n        }\n    }\n    return res;\n}\n\n\n\nint main(){\n    cin >> m >> n;\n    vs.resize(m);\n    rep(i,m)cin >> vs[i];\n    bool iserase = true;\n    ll ans = 0;\n    while(iserase){\n        iserase = false;\n        rep(i,m){\n            rep(j,n){\n                if(vs[i][j] != '.')continue;\n                ll num = solve(i,j);\n                if(num != 0){\n                    ans += num;\n                    iserase = true;\n                }\n            }\n        }\n        // rep(i,m){\n        //     rep(j,n)cout << vs[i][j] << \" \";\n        //     cout << endl;\n        // }\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// >>> TEMPLATES\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\n#define int ll\n#define double ld\n#define rep(i,n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i,n) for (int i = 1; i <= (int)(n); i++)\n#define repR(i,n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rep1R(i,n) for (int i = (int)(n); i >= 1; i--)\n#define loop(i,a,B) for (int i = a; i B; i++)\n#define loopR(i,a,B) for (int i = a; i B; i--)\n#define all(x) (x).begin(), (x).end()\n#define allR(x) (x).rbegin(), (x).rend()\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\ntemplate <class Int> auto constexpr inf = numeric_limits<Int>::max()/2-1;\nauto constexpr INF32 = inf<int32_t>;\nauto constexpr INF64 = inf<int64_t>;\nauto constexpr INF   = inf<int>;\n#ifdef LOCAL\n#include \"debug.hpp\"\n#else\n#define dump(...) (void)(0)\n#define say(x) (void)(0)\n#define debug if (0)\n#endif\ntemplate <class T> using pque_max = priority_queue<T>;\ntemplate <class T> using pque_min = priority_queue<T, vector<T>, greater<T> >;\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nostream& operator<<(ostream& os, T const& v) { bool f = true; for (auto const& x : v) os << (f ? \"\" : \" \") << x, f = false; return os; }\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nistream& operator>>(istream& is, T &v) { for (auto& x : v) is >> x; return is; }\ntemplate <class T, class S> ostream& operator<<(ostream& os, pair<T,S> const& p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\ntemplate <class T, class S> istream& operator>>(istream& is, pair<T,S>& p) { return is >> p.first >> p.second; }\nstruct IOSetup { IOSetup() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); } } iosetup;\ntemplate <class F> struct FixPoint : private F {\n    constexpr FixPoint(F&& f) : F(forward<F>(f)) {}\n    template <class... T> constexpr auto operator()(T&&... x) const { return F::operator()(*this, forward<T>(x)...); }\n};\nstruct MakeFixPoint {\n    template <class F> constexpr auto operator|(F&& f) const { return FixPoint<F>(forward<F>(f)); }\n};\n#define MFP MakeFixPoint()|\n#define def(name, ...) auto name = MFP [&](auto &&name, __VA_ARGS__)\ntemplate <class T, size_t d> struct vec_impl {\n    using type = vector<typename vec_impl<T,d-1>::type>;\n    template <class... U> static type make_v(size_t n, U&&... x) { return type(n, vec_impl<T,d-1>::make_v(forward<U>(x)...)); }\n};\ntemplate <class T> struct vec_impl<T,0> { using type = T; static type make_v(T const& x = {}) { return x; } };\ntemplate <class T, size_t d = 1> using vec = typename vec_impl<T,d>::type;\ntemplate <class T, size_t d = 1, class... Args> auto make_v(Args&&... args) { return vec_impl<T,d>::make_v(forward<Args>(args)...); }\ntemplate <class T> void quit(T const& x) { cout << x << endl; exit(0); }\ntemplate <class T, class U> constexpr bool chmin(T& x, U const& y) { if (x > y) { x = y; return true; } return false; }\ntemplate <class T, class U> constexpr bool chmax(T& x, U const& y) { if (x < y) { x = y; return true; } return false; }\ntemplate <class It> constexpr auto sumof(It b, It e) { return accumulate(b,e,typename iterator_traits<It>::value_type{}); }\ntemplate <class T> int sz(T const& x) { return x.size(); }\ntemplate <class C, class T> int lbd(C const& v, T const& x) {\n    return lower_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class T> int ubd(C const& v, T const& x) {\n    return upper_bound(v.begin(), v.end(), x)-v.begin();\n}\nconst int dx[] = { 1,0,-1,0 };\nconst int dy[] = { 0,1,0,-1 };\nconstexpr int popcnt(ll x) { return __builtin_popcountll(x); }\ntemplate <class Int> struct Random {\n    mt19937_64 mt{random_device{}()};\n    //mt19937_64 mt{(unsigned)time(0)};\n    Int a,b; // [a,b]\n    Random(Int a, Int b) : a(a), b(b) {}\n    Int operator()() { return uniform_int_distribution<Int>(a,b)(mt); }\n};\ntemplate <class Int> Int rand(Int a, Int b) { // [a,b]\n    static mt19937_64 mt{random_device{}()};\n    return uniform_int_distribution<Int>(a,b)(mt);\n}\n// <<<\n\nint32_t main() {\n    int n,m; cin >> n >> m;\n    vector<string> s(n); cin >> s;\n\n    vector<vector<pair<int,int>>> pos(26);\n    rep (i,n) rep (j,m) if (isalpha(s[i][j])) {\n        pos[s[i][j]-'A'].eb(i,j);\n    }\n\n    auto check = [&](int x1, int y1, int x2, int y2) {\n        if (x1 == x2) {\n            bool ok = true;\n            loop (j,min(y1,y2)+1,<max(y1,y2)) if (s[x1][j] != '.') ok = false;\n            if (ok) return true;\n        }\n        if (y1 == y2) {\n            bool ok = true;\n            loop (i,min(x1,x2)+1,<max(x1,x2)) if (s[i][y1] != '.') ok = false;\n            if (ok) return true;\n        }\n        return false;\n    };\n\n    int ans = 0;\n    while (true) {\n        bool update = false;\n        rep (c,26) if (pos[c].size()) {\n            assert(sz(pos[c]) == 2);\n            int x1,y1; tie(x1,y1) = pos[c][0];\n            int x2,y2; tie(x2,y2) = pos[c][1];\n\n            if (abs(x1-x2) + abs(y1-y2) == 1) {\n                pos[c].clear();\n                continue;\n            }\n\n            bool ok = false;\n            ok |= check(x1,y1,x2,y2);\n            ok |= check(x1,y1,x1,y2) && s[x1][y2] == '.' && check(x1,y2,x2,y2);\n            ok |= check(x1,y1,x2,y1) && s[x2][y1] == '.' && check(x2,y1,x2,y2);\n            if (ok) {\n                pos[c].clear();\n                s[x1][y1] = s[x2][y2] = '.';\n                dump(char(c+'A'),x1,y1,x2,y2);\n                update = true;\n                ans += 2;\n                break;\n            }\n        }\n        if (not update) break;\n    }\n    cout << ans << endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst vector<int> dir = { 0, 1, 0, -1 };\nint H, W;\nint main() {\n\tcin >> H >> W;\n\tvector<string> s(H);\n\tvector<int> cx, cy;\n\tfor (int i = 0; i < H; i++) {\n\t\tcin >> s[i];\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (s[i][j] != '.') {\n\t\t\t\tcx.push_back(j);\n\t\t\t\tcy.push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tsort(cx.begin(), cx.end());\n\tcx.erase(unique(cx.begin(), cx.end()), cx.end());\n\tfor (int i = 1; i < cx.size(); i++) {\n\t\tif (cx[i] - cx[i - 1] >= 2) cx.push_back(cx[i - 1] + 1);\n\t}\n\tsort(cx.begin(), cx.end());\n\tsort(cy.begin(), cy.end());\n\tcy.erase(unique(cy.begin(), cy.end()), cy.end());\n\tfor (int i = 1; i < cy.size(); i++) {\n\t\tif (cy[i] - cy[i - 1] >= 2) cy.push_back(cy[i - 1] + 1);\n\t}\n\tH = cy.size(), W = cx.size();\n\tvector<string> t(H, string(W, '.'));\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (s[cy[i]][cx[j]] != '.') t[i][j] = s[cy[i]][cx[j]];\n\t\t}\n\t}\n\tint ret = 0;\n\twhile (true) {\n\t\tbool flag = false;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (t[i][j] != '.') continue;\n\t\t\t\tvector<vector<pair<int, int> > > d(26);\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tint tx = j, ty = i;\n\t\t\t\t\twhile (0 <= tx && tx < W && 0 <= ty && ty < H) {\n\t\t\t\t\t\tif (t[ty][tx] != '.') {\n\t\t\t\t\t\t\td[t[ty][tx] - 65].push_back(make_pair(tx, ty));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttx += dir[k];\n\t\t\t\t\t\tty += dir[k ^ 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int k = 0; k < 26; k++) {\n\t\t\t\t\tif (d[k].size() == 2) {\n\t\t\t\t\t\tflag = true; ret += 2;\n\t\t\t\t\t\tt[d[k][0].second][d[k][0].first] = '.';\n\t\t\t\t\t\tt[d[k][1].second][d[k][1].first] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!flag) break;\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <sstream>\n#include <utility>\n#include <set>\n#include <map>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define each(e,c) for(auto&e:c)\n#define iter(i,c) for(auto i(begin(c));i!=end(c);++i)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\ntemplate<class C>string to_string(vector<C> c,string d=\" \"){stringstream s;iter(i,c)s<<*i<<(next(i)==end(c)?\"\":d);return s.str();}\ntemplate<class C>ostream&operator<<(ostream&os,vector<C>const& v){return os<<to_string(v);}\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<(DUMP(),__VA_ARGS__).str()<<\" (at \"<<__LINE__<<\")\"<<endl)\nstruct DUMP:ostringstream{template<class T>DUMP &operator,(const T&t){if(this->tellp())*this<<\", \";*this<<t;return *this;}};\n#else\n#define dump(...)\n#endif\n\ntypedef vector<string> vs;\nint h,w;\nvs g;\ninline bool valid(int x, int y){\n    return 0<=x && 0<=y && x<w && y<h;\n}\n\nbool bad[512][512];\nint solve(){\n    vector<pii> space;\n    rep(i,h)rep(j,w)if(g[i][j]=='.') space.emplace_back(j,i), bad[i][j]=false;\n    int ans = 0;\n    while(1){\n        bool finish = true;\n        for(auto p : space){\n            vector<pii> s['Z'+1];\n            int x,y;\n            tie(x,y)=p;\n            if(bad[y][x]) continue;\n            int dx[]={1,0,-1,0};\n            int dy[]={0,1,0,-1};\n            int b=0;\n            rep(d,4){\n                int cx,cy;\n                tie(cx,cy)=tie(x,y);\n                while(valid(cx+dx[d],cy+dy[d]) && g[cy][cx]=='.'){\n                    cx+=dx[d]; cy+=dy[d];\n                }\n                if(valid(cx,cy)){\n                    if(g[cy][cx]!='.') s[g[cy][cx]].emplace_back(cx,cy);\n                } else b++;\n            }\n            if(b==4){\n                bad[y][x] = true;\n                continue;\n            }\n            for(char c='A';c<='Z';c++){\n                auto& ps = s[c];\n                if(ps.size()>=2){\n                    for(auto & p : ps){\n                        int x,y;\n                        tie(x,y) = p;\n                        g[y][x] = '.';\n                        ans++;\n                        finish = false;\n                        space.emplace_back(x,y);\n                    }\n                }\n            }\n        }\n        if(finish) break;\n    }\n    return ans;\n}\n\nint main(){\n    while(cin>>h>>w){\n        g.clear();\n        rep(i,h){\n            string s;cin>>s;\n            g.push_back(s);\n        }\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\ntemplate<class T> constexpr bool in_range(T y, T x, T H, T W) { return 0<=y&&y<H&&0<=x&&x<W; }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,-1,0,1};\n\nint H, W;\n\nvoid solve(vector<string>& G) {\n\n  int res = 0;\n\n  while(1) {\n    bool ok = 0;\n    rep(i, H) rep(j, W) {\n      if(G[i][j] == '.') {\n        map<char, vector<pair<int, int>>> mp;\n        rep(k, 4) {\n          int y = i, x = j;\n          while(1) {\n            y += dy[k], x += dx[k]; if(!in_range(y, x, H, W)) break;\n            if(G[y][x] != '.') {\n              mp[G[y][x]].emplace_back(y, x);\n              break;\n            }\n          }\n        }\n\n        for(auto && e: mp) {\n          if(e.second.size() > 1) {\n            G[e.second[0].first][e.second[0].second] = '.';\n            G[e.second[1].first][e.second[1].second] = '.';\n            res += 2;\n            ok = 1;\n          }\n        }\n      }\n    }\n    if(!ok) break;\n  }\n  cout << res << endl;\n}\n\nint main() {\n\n  cin >> H >> W;\n  vector<string> G(H);\n  rep(i, H) cin >> G[i];\n\n  rep(i, H) rep(j, W) {\n    if(isalpha(G[i][j])) {\n      rep(k, 4) {\n        int ni = i + dy[k], nj = j + dx[k];\n        if(!in_range(ni, nj, H, W)) continue;\n        if(G[ni][nj] == '.') G[ni][nj] = '-';\n      }\n    }\n  }\n\n  int k = 0;\n  rep(i, H) {\n    if(G[i] != string(W, '.'))\n      G[k++] = G[i];\n  }\n  H = k;\n\n  vector<string> T(W); rep(i, W) T[i].resize(H);\n  rep(i, W) rep(j, H) {\n    T[i][j] = G[j][i];\n  }\n\n  k = 0;\n  rep(i, W) {\n    if(T[i] != string(H, '.'))\n      T[k++] = T[i];\n  }\n\n  W = k;\n\n  G.clear(); G.resize(H); rep(i, H) G[i] = string(W, '.');\n\n  rep(i, H) rep(j, W)\n    G[i][j] = T[j][i] == '-' ? '.' : T[j][i];\n\n//  rep(i, H) cout << G[i] << endl;\n\n  solve(G);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nint main(){\n  \n \n      string s;\n      int n,m;\n      while(cin >> n >> m){\n      cerr << n << m << endl;\n      for(int i=0;i<n;i++){\n\tcin >> s;\n\tcerr << s << endl;\n      }\n      cout << \"3\" << endl;\n\t    }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <queue>\n#include <map>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> que;\nconst int INF = 1<<30;\nconst int MOD = 1e9 + 7;\nconst int dy[] = {1, 0, -1, 0};\nconst int dx[] = {0, 1, 0, -1};\nint h, w, ans;\nvector<string> table;\nbool inRange(int y, int x)\n{\n    if(y < 0 or x < 0 or y >= h or x >= w) return false;\n    return true;\n}\nint solve()\n{\n    int res = 0;\n    bool flag;\n    while(true)\n    {\n        flag = false;\n        for(int i = 0; i < h; i++)\n        {\n            for(int j = 0; j < w; j++)\n            {\n                if(table[i][j] != '.') continue;\n                map<char, vector<P>> mp;\n                for(int k = 0; k < 4; k++)\n                {\n                    int ny = i + dy[k], nx = j + dx[k];\n                    while(inRange(ny, nx))\n                    {\n                        if(table[ny][nx] != '.')\n                        {\n                            mp[table[ny][nx]].push_back(make_pair(ny, nx));\n                            break;\n                        }\n                        ny += dy[k];\n                        nx += dx[k];\n                    }\n                }\n                for(auto x : mp)\n                {\n                    if(x.second.size() == 2)\n                    {\n                        flag = true;\n                        for(int k = 0; k < x.second.size(); k++)\n                        {\n                            P p = x.second[k];\n                            table[p.first][p.second] = '.';\n                        }\n                        res += x.second.size();\n                    }\n                }\n            }\n        }\n        if(flag == false) break;\n    }\n    return res;\n}\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> h >> w;\n    table.resize(h);\n    for(int i = 0; i < h; i++) cin >> table[i];\n    cout << solve() << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define X second\n#define Y first\n#define A 26\n#define N 500\nusing namespace std;\ntypedef pair<int,int> P;\nvector<P> v[A];\nstring s[N];\nint m,n,ans;\nbool used[A],erased[A];\n/*. a\nb   d\n  c .\n    \n  a .\nb   d\n. c*/\nbool func(int x){\n  if(!v[x].size()) return false;\n  if(used[x]) return false;\n  used[x]=true;\n  int y1=v[x][0].Y,x1=v[x][0].X,y2=v[x][1].Y,x2=v[x][1].X;\n  int f=0,fa=1,fb=1,fc=1,fd=1;\n  if(x1>x2) swap(x1,x2),f=1;\n  for(int i=x1;i<=x2;i++){\n    char c=s[y1][i];\n    int nx=c-'A';\n    if(nx==x) continue;\n    if(c!='.'&&!erased[nx]&&!func(nx)) fa=0;\n  }\n  for(int i=y1;i<=y2;i++){\n    char c=s[i][x1];\n    int nx=c-'A';\n    if(nx==x) continue;\n    if(c!='.'&&!erased[nx]&&!func(nx)) fb=0;\n  }\n  for(int i=x1;i<=x2;i++){\n    char c=s[y2][i];\n    int nx=c-'A';\n    if(nx==x) continue;\n    if(c!='.'&&!erased[nx]&&!func(nx)) fc=0;\n  }\n  for(int i=y1;i<=y2;i++){\n    char c=s[i][x2];\n    int nx=c-'A';\n    if(nx==x) continue;\n    if(c!='.'&&!erased[nx]&&!func(nx)) fd=0;\n  }\n  if(!f) f=(fa&fd)|(fb&fc);\n  else f=(fa&fb)|(fc&fd);\n  if((y1==y2&&x1+1==x2)||(x1==x2&&y1+1==y2)) f=0;\n  if(!f) return false;\n  erased[x]=true;\n  return true;\n}\n\nint main(){\n  cin>>m>>n;\n  for(int i=0;i<m;i++) cin>>s[i];\n  for(int i=0;i<m;i++)\n    for(int j=0;j<n;j++)\n      if(s[i][j]!='.') v[s[i][j]-'A'].push_back(P(i,j));\n  for(int i=0;i<A;i++){\n    for(int j=0;j<A;j++) used[j]=false;\n    func(i);\n  }\n  for(int i=0;i<A;i++) ans+=erased[i]*2;\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mk make_pair\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nstring s[500];\nint h,w,sum=0;\nvector<int>x,y;\nvoid del(int t1,int t2){\n  vector<pair<char,pair<int,int> > >p;\n  for(int i=t1;i<h;i++)if(s[i][t2]!='.'){\n    p.push_back(mk(s[i][t2],mk(i,t2)));\n    break;\n  }\n  for(int i=t1;i>=0;i--)if(s[i][t2]!='.'){\n    p.push_back(mk(s[i][t2],mk(i,t2)));\n    break;\n  }\n  for(int i=t2;i<w;i++)if(s[t1][i]!='.'){\n    p.push_back(mk(s[t1][i],mk(t1,i)));\n    break;\n  }\n  for(int i=t2;i>=0;i--)if(s[t1][i]!='.'){\n    p.push_back(mk(s[t1][i],mk(t1,i)));\n    break;\n  }\n  sort(p.begin(),p.end());\n  if(p.size()>=2){\n    r(i,p.size()-1){\n      if(p[i].first==p[i+1].first){\n        sum++;\n        s[p[i].second.first][p[i].second.second]='.';\n        s[p[i+1].second.first][p[i+1].second.second]='.';\n      }\n    }\n  }\n}\nint main(){\n  cin>>h>>w;\n  r(i,h)cin>>s[i];\n  r(i,h)r(j,w)if(s[i][j]!='.'){\n      y.push_back(i),x.push_back(j);\n      if(i+1<h)y.push_back(i+1);\n      if(j+1<w)x.push_back(j+1);\n    }\n  r(k,3)r(i,y.size())r(j,x.size())\n    if(s[y[i]][x[j]]=='.')del(y[i],x[j]);\n  cout<<sum*2<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<cassert>\n#include<cstdlib>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int N = 500;\nchar m[N][N+1];\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\n\nbool cango(int r,int c,int y,int x,int ty,int tx){\n  rep(i,4){\n    int tmpx=x,tmpy=y;\n    int ddx=dx[i],ddy=dy[i];\n    x+=ddx;\n    y+=ddy;\n    while(y != -1 && x != -1 && y != r && x != c){\n      if (m[y][x] != '.')break;\n      if (y == ty && x == tx)return true;\n      x+=ddx;\n      y+=ddy;\n    }\n    x=tmpx;\n    y=tmpy;\n  }\n  return false;\n}\n\nbool erase(int r,int c,int y1,int x1,int y2,int x2){\n  vector<int> tx,ty;\n  if (y1 == y2){\n    tx.push_back(x1 < x2?x1+1:x2+1);\n    ty.push_back(y1);\n  }else if (x1 == x2){\n    tx.push_back(x1);\n    ty.push_back(y1 < y2?y1+1:y2+1);\n  }else {\n    tx.push_back(x1);\n    ty.push_back(y2);\n\n    tx.push_back(x2);\n    ty.push_back(y1);\n  }\n  bool isok=false;\n  rep(i,(int)tx.size()){\n    //cout <<\"target \" << m[y1][x1] <<\" \" << ty[i] <<\" \" << tx[i] <<\" : \"  << y1 <<\" \" <<x1 <<\" \" << y2 <<\" \" << x2 << endl;\n    if (cango(r,c,y1,x1,ty[i],tx[i]) && \n\tcango(r,c,y2,x2,ty[i],tx[i])){isok=true;break;}\n  }\n  if (isok)m[y1][x1]=m[y2][x2]='.';\n  return isok;\n}\n\nmain(){\n  int r,c;\n  while(cin>>r>>c){\n    rep(i,r)cin>>m[i];\n    vector<pii> in[26];\n    rep(i,r){\n      rep(j,c){\n\tif (!isalpha(m[i][j]))continue;\n\tin[m[i][j]-'A'].push_back(make_pair(i,j));\n      }\n    }\n    rep(i,26){\n      if (in[i].size() == 0)continue;\n      if (abs(in[i][0].first-in[i][1].first)+abs(in[i][0].second-in[i][1].second) == 1)in[i].clear();\n    }\n    int ans=0;\n    while(true){\n      bool iserased=false;\n      rep(i,26){\n\tif (in[i].size() == 0)continue;\n\tif (erase(r,c,in[i][0].first,in[i][0].second,in[i][1].first,in[i][1].second))ans+=2,iserased=true,in[i].clear();\n      }\n      /*\n      cout <<\"dbg\" << endl;\n      rep(i,r){\n\trep(j,c)cout << m[i][j] <<\" \";\n\tcout << endl;\n      }\n      cout <<\"dbgend\" << endl;\n      */\n      if (!iserased)break;\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nint main(){\n  int N, M;\n  cin >> N >> M;\n  vector<string> field(N);\n  REP(i, N) cin >> field[i];\n  \n  vector<int> rows;\n  vector<int> cols;\n  \n  REP(i, N)REP(j, M)if(isalpha(field[i][j])){\n    REP(k, 3){\n      rows.push_back(i+k-1);\n      cols.push_back(j+k-1);\n    }\n  }\n\n  sort(ALL(rows));\n  sort(ALL(cols));\n  rows.erase(unique(ALL(rows)), rows.end());\n  cols.erase(unique(ALL(cols)), cols.end());\n  \n  vector<string> board(rows.size(), string(cols.size(), '.'));\n  \n  REP(i, N)REP(j, M)if(isalpha(field[i][j])){\n    int r = lower_bound(ALL(rows), i) - rows.begin();\n    int c = lower_bound(ALL(cols), j) - cols.begin();\n    board[r][c] = field[i][j];\n  }\n  \n  N = rows.size();\n  M = cols.size();\n  \n  int res = 0;\n  int dr[4] = {0, -1, 0, 1};\n  int dc[4] = {1, 0, -1, 0};\n  bool update = true;\n  \n  while(update){\n    update = false;\n    \n    REP(r, N)REP(c, M)if(board[r][c] == '.'){\n      vector<int> t_row;\n      vector<int> t_col;\n      REP(i, 4){\n        int r2 = r + dr[i];\n        int c2 = c + dc[i];\n        while(0 <= r2 && r2 < N && 0 <= c2 && c2 < M && board[r2][c2] == '.'){\n          r2 += dr[i];\n          c2 += dc[i];\n        }\n        \n        if(0 <= r2 && r2 < N && 0 <= c2 && c2 < M){\n          t_row.push_back(r2);\n          t_col.push_back(c2);\n        }\n        \n        REP(i, 26){\n          int c = 0;\n          REP(j, t_row.size()) if(board[t_row[j]][t_col[j]] == 'A' + i) c++;\n          if(c >= 2){\n            update = true;\n            res += c;\n            REP(j, t_row.size()){\n              char &tile = board[t_row[j]][t_col[j]];\n              if(tile == 'A' + i) tile = '.';\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  cout << res << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define REP(i,n,N) for(int i=(n);i<(int)(N);i++)\n#define p(s) cout<<(s)<<endl;\n#define F first\n#define S second\nusing namespace std;\n\nstring s[501];\nbool tacX(int x1,int x2,int y,char c){\n    for(int x=x1;x<=x2;x++) if(s[y][x]!='.' && s[y][x]!=c) return false;\n    return true;\n}\n\nbool tacY(int y1,int y2,int x,char c){\n    for(int y=y1;y<=y2;y++) if(s[y][x]!='.' && s[y][x]!=c) return false;\n    return true;\n}\nint main(){\n\tint M,N;\n\tcin>>M>>N;\n\tvector<pair<int,int>> vc[30];\n\tREP(i,0,M){\n\t\tcin>>s[i];\n\t\tREP(j,0,N){\n\t\t\tif(s[i][j]!='.') vc[s[i][j]-'A'].push_back({j,i});\n\t\t}\n\t}\n\tint ans=0;\n\twhile(1){\n\t\tbool change=false;\n\t\tREP(i,0,'Z'-'A'+1){\n\t\t\tif(vc[i].size()!=2) continue;\n\t\t\tpair<int,int> a=vc[i][0],b=vc[i][1];\n\t\t\tbool ok=false;\n\t\t\tif(a.F!=b.F&&a.S!=b.S){\n\t\t\t\tif((tacX(min(a.F,b.F),max(a.F,b.F),a.S,'A'+i)\n\t\t\t\t&& tacY(a.S,b.S,b.F,'A'+i))\n\t\t\t\t|| (tacX(min(a.F,b.F),max(a.F,b.F),b.S,'A'+i)\n\t\t\t\t&& tacY(a.S,b.S,a.F,'A'+i))) ok=true;\n\t\t\t}\n\t\t\telse if(a.S==b.S&&b.F-a.F>1&& tacX(a.F,b.F,a.S,'A'+i)) ok=true;\n\t\t\telse if(a.F==b.F&&b.S-a.S>1&&tacY(a.S,b.S,a.F,'A'+i)) ok=true;\n\t\t\tif(ok){\n\t\t\t\ts[a.S][a.F]=s[b.S][b.F]='.';\n\t\t\t\tp(\"\");\n\t\t\t\tvc[i].clear();\n\t\t\t\tans+=2;\n\t\t\t\tchange=true;\n\t\t\t}\n\t\t}\n\t\tif(!change) break;\n\t}\n\tp(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint M,N;\nchar C[511][511];\nint xa[26],ya[26];\nint xb[26],yb[26];\n\nbool check(int x1,int y1,int x2,int y2 ){\n  assert( x2 == x1 || y1 == y2 );\n  if( x1 > x2 ) swap(x1,x2);\n  if( y1 > y2 ) swap(y1,y2);\n  if( x1 == x2 ){\n    for(int y=y1+1;y<y2;y++){\n      if( C[x1][y] != '.' ) return false;\n    }\n  } else if( y1 == y2 ){\n    for(int x=x1+1;x<x2;x++){\n      if( C[x][y1] != '.' ) return false;\n    }\n  }\n  return true;\n}\n\nbool check2(int x1,int y1,int x2,int y2 ){\n  assert( x2 == x1 || y1 == y2 );\n  if( x1 > x2 ) swap(x1,x2);\n  if( y1 > y2 ) swap(y1,y2);\n  if( x1 == x2 ){\n    for(int y=y1+1;y<y2;y++){\n      if( C[x1][y] == '.' ) return true;\n    }\n  } else if( y1 == y2 ){\n    for(int x=x1+1;x<x2;x++){\n      if( C[x][y1] == '.' ) return true;\n    }\n  }\n  return false;\n}\nvoid view(){\n  cout <<\"view\" << endl;\n  for(int i=0;i<M;i++)\n    {\n      for(int j=0;j<N;j++) cout << C[j][i] ;\n      cout << endl;\n    }\n}\n\n\n\nint main(){\n  cin >> M >> N;\n  memset( xa, -1,sizeof(xa) );\n  memset( xb, -1,sizeof(xb) );\n  memset( ya, -1,sizeof(ya) );\n  memset( yb, -1,sizeof(yb) );\n  for(int i=0;i<M;i++){\n    for(int j=0;j<N;j++){\n      cin >> C[j][i];\n      if( C[j][i] != '.' ){\n        int id = (int)(C[j][i] - 'A');\n        if( xa[id] == -1 ) {\n          xa[id] = j; ya[id] = i;\n        } else {\n          xb[id] = j; yb[id] = i;\n        }\n      }\n    }\n  }\n\n  bool flag;\n  int res = 0;\n  do{\n    flag = false;\n    for(int i=0;i<26;i++){\n      if( xa[i]==-1 ) continue;\n      if( xa[i] == xb[i] || ya[i] == yb[i] ) {\n        if( check(xa[i],ya[i],xb[i],yb[i]) && check2(xa[i],ya[i],xb[i],yb[i]) ){\n          res+=2; \n          C[xa[i]][ya[i]]='.';\n          C[xb[i]][yb[i]]='.';\n          xa[i] = ya[i] = -1;\n          flag = true;\n        }\n      } else {\n        if( (check(xa[i],yb[i],xb[i],yb[i]) && check(xa[i],yb[i],xa[i],ya[i]) && C[xa[i]][yb[i]] == '.') ||\n            (check(xb[i],ya[i],xa[i],ya[i]) && check(xb[i],ya[i],xb[i],yb[i]) && C[xb[i]][ya[i]] == '.') ){\n          res+=2;\n          C[xa[i]][ya[i]]='.';\n          C[xb[i]][yb[i]]='.';\n          xa[i] = ya[i] = -1;\n          flag = true;\n        }\n      }\n    }\n    // view();\n  } while( flag );\n\n  cout << res << endl;  \n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nvector<int>a[26];\nint n,m;\nstring s[500];\nvector<pair<int,int> >g[26];\nmain()\n{\n\tcin>>n>>m;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>s[i];\n\t\tfor(int j=0;j<s[i].size();j++)\n\t\t{\n\t\t\tif(s[i][j]>64)g[s[i][j]-65].push_back(make_pair(i,j));\n\t\t}\n\t}\n\tfor(int i=0;i<26;i++)\n\t{\n\t\tif(g[i].size()==0)continue;\n\t\tint x1,x2,y1,y2;\n\t\tx1=g[i][0].first,y1=g[i][0].second,x2=g[i][1].first,y2=g[i][1].second;\n\t\tif(x1==x2)\n\t\t{\n\t\t\tif(y2-y1>1)\n\t\t\t{\n\t\t\t\tint x=0;\n\t\t\t\tfor(int j=y1+1;j<y2;j++)if(s[x1][j]>64)x|=1<<s[x1][j]-65;\n\t\t\t\ta[i].push_back(x);\n\t\t\t}\n\t\t}\n\t\telse if(y1==y2)\n\t\t{\n\t\t\tif(x2-x1>1)\n\t\t\t{\n\t\t\t\tint x=0;\n\t\t\t\tfor(int j=x1+1;j<x2;j++)if(s[j][y1]>64)x|=1<<s[j][y1]-65;\n\t\t\t\ta[i].push_back(x);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint x=0,y=0;\n\t\t\tif(y1<y2)\n\t\t\t{\n\t\t\t\tfor(int j=y1+1;j<=y2;j++)\n\t\t\t\t{\n\t\t\t\t\tif(s[x1][j]>64)x|=1<<s[x1][j]-65;\n\t\t\t\t\tif(s[x2][j-1]>64)y|=1<<s[x2][j-1]-65;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(int j=y2;j<y1;j++)\n\t\t\t\t{\n\t\t\t\t\tif(s[x1][j]>64)x|=1<<s[x1][j]-65;\n\t\t\t\t\tif(s[x2][j+1]>64)y|=1<<s[x2][j+1]-65;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=x1+1;j<x2;j++)\n\t\t\t{\n\t\t\t\tif(s[j][y2]>64)x|=1<<s[j][y2]-65;\n\t\t\t\tif(s[j][y1]>64)y|=1<<s[j][y1]-65;\n\t\t\t}\n\t\t\ta[i].push_back(x);\n\t\t\ta[i].push_back(y);\n\t\t}\n\t}\n\tint cnt=0;\n\tfor(int count=26;count--;)\n\t{\n\t\tfor(int i=0;i<26;i++)\n\t\t{\n\t\t\tbool flag=0;\n\t\t\tfor(int j=0;j<a[i].size();j++)flag|=!a[i][j];\n\t\t\tif(flag)\n\t\t\t{\n\t\t\t\ta[i].clear();\n\t\t\t\tcnt+=2;\n\t\t\t\tint x=~(1<<i);\n\t\t\t\tfor(int j=0;j<26;j++)\n\t\t\t\t{\n\t\t\t\t\tfor(int&e:a[j])e&=x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<cnt<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nstruct info {\n\tbool samexy;\n\tset<char> alpha1;\n\tset<char> alpha2;\n};\n\nint main() {\n\tint h, w;\n\tcin >> h >> w;\n\tvector<string> cell(h);\n\tvector<info> alf(26);\n\tREP(i, h)\n\t\tcin >> cell[i];\n\tREP(k, 26) {\n\t\tint x = -1;\n\t\tint y = -1;\n\t\tREP(i, h)\n\t\t\tREP(j, w) {\n\t\t\tif (cell[i][j] == 'A' + k) {\n\t\t\t\tif (x == -1) {\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (x == j || y == i)\n\t\t\t\t\t\talf[k].samexy = true;\n\t\t\t\t\telse\n\t\t\t\t\t\talf[k].samexy = false;\n\t\t\t\t\tif (alf[k].samexy) {\n\t\t\t\t\t\tif (x == j) {\n\t\t\t\t\t\t\tREP(l, abs(y - i) - 1)\n\t\t\t\t\t\t\t\talf[k].alpha1.insert(cell[y + 1 + l][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tREP(l, abs(x - j) - 1)\n\t\t\t\t\t\t\t\talf[k].alpha1.insert(cell[i][x + 1 + l]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (x < j&&y < i) {\n\t\t\t\t\t\t\tREP(l, abs(x - j) - 1)\n\t\t\t\t\t\t\t\talf[k].alpha1.insert(cell[y][x + l + 1]);\n\t\t\t\t\t\t\talf[k].alpha1.insert(cell[y][j]);\n\t\t\t\t\t\t\tREP(l, abs(y - i) - 1)\n\t\t\t\t\t\t\t\talf[k].alpha1.insert(cell[y + 1 + l][j]);\n\t\t\t\t\t\t\tREP(l, abs(y - i) - 1)\n\t\t\t\t\t\t\t\talf[k].alpha2.insert(cell[y + 1 + l][x]);\n\t\t\t\t\t\t\talf[k].alpha2.insert(cell[i][x]);\n\t\t\t\t\t\t\tREP(l, abs(x - j) - 1)\n\t\t\t\t\t\t\t\talf[k].alpha2.insert(cell[i][x + l + 1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tREP(l, abs(x - j) - 1)\n\t\t\t\t\t\t\t\talf[k].alpha1.insert(cell[y][j + l + 1]);\n\t\t\t\t\t\t\talf[k].alpha1.insert(cell[y][j]);\n\t\t\t\t\t\t\tREP(l, abs(y - i) - 1)\n\t\t\t\t\t\t\t\talf[k].alpha1.insert(cell[y + 1 + l][j]);\n\t\t\t\t\t\t\tREP(l, abs(y - i) - 1)\n\t\t\t\t\t\t\t\talf[k].alpha2.insert(cell[y + 1 + l][x]);\n\t\t\t\t\t\t\talf[k].alpha2.insert(cell[i][x]);\n\t\t\t\t\t\t\tREP(l, abs(x - j) - 1)\n\t\t\t\t\t\t\t\talf[k].alpha2.insert(cell[i][j + l + 1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tbool change = false;\n\tint ans = 0;\n\tbool used[26] = { false};\n\tdo {\n\t\tchange = false;\n\t\tREP(i, 26) {\n\t\t\tif(!used[i])\n\t\t\tif (alf[i].samexy) {\n\t\t\t\tif (!alf[i].alpha1.empty() && alf[i].alpha1.size() == 1 && EXIST(alf[i].alpha1, '.')) {\n\t\t\t\t\tans++;\n\t\t\t\t\tused[i] = true;\n\t\t\t\t\tchange = true;\n\t\t\t\t\tREP(j,26)\n\t\t\t\t\t\tif (!used[j]) {\n\t\t\t\t\t\t\tif (alf[j].samexy) {\n\t\t\t\t\t\t\t\tif (!alf[j].alpha1.empty()&&EXIST(alf[j].alpha1,'A'+i)){\n\t\t\t\t\t\t\t\t\talf[j].alpha1.erase('A' + i);\n\t\t\t\t\t\t\t\t\talf[j].alpha1.insert('.');\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tif (!alf[j].alpha1.empty() && EXIST(alf[j].alpha1, 'A' + i)) {\n\t\t\t\t\t\t\t\t\talf[j].alpha1.erase('A' + i);\n\t\t\t\t\t\t\t\t\talf[j].alpha1.insert('.');\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (!alf[j].alpha2.empty() && EXIST(alf[j].alpha2, 'A' + i)) {\n\t\t\t\t\t\t\t\t\talf[j].alpha2.erase('A' + i);\n\t\t\t\t\t\t\t\t\talf[j].alpha2.insert('.');\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif (!alf[i].alpha1.empty() && alf[i].alpha1.size() == 1 && EXIST(alf[i].alpha1, '.')) {\n\t\t\t\t\tans++;\n\t\t\t\t\tused[i] = true;\n\t\t\t\t\tchange = true;\n\t\t\t\t\tREP(j, 26)\n\t\t\t\t\t\tif (!used[j]) {\n\t\t\t\t\t\t\tif (alf[j].samexy) {\n\t\t\t\t\t\t\t\tif (!alf[j].alpha1.empty() && EXIST(alf[j].alpha1, 'A' + i)) {\n\t\t\t\t\t\t\t\t\talf[j].alpha1.erase('A' + i);\n\t\t\t\t\t\t\t\t\talf[j].alpha1.insert('.');\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (!alf[j].alpha1.empty() && EXIST(alf[j].alpha1, 'A' + i)) {\n\t\t\t\t\t\t\t\t\talf[j].alpha1.erase('A' + i);\n\t\t\t\t\t\t\t\t\talf[j].alpha1.insert('.');\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (!alf[j].alpha2.empty() && EXIST(alf[j].alpha2, 'A' + i)) {\n\t\t\t\t\t\t\t\t\talf[j].alpha2.erase('A' + i);\n\t\t\t\t\t\t\t\t\talf[j].alpha2.insert('.');\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (used[i])continue;\n\t\t\t\tif (!alf[i].alpha2.empty() && alf[i].alpha2.size() == 1 && EXIST(alf[i].alpha2, '.')) {\n\t\t\t\t\tans++;\n\t\t\t\t\tused[i] = true;\n\t\t\t\t\tchange = true;\n\t\t\t\t\tREP(j, 26)\n\t\t\t\t\t\tif (!used[j]) {\n\t\t\t\t\t\t\tif (alf[j].samexy) {\n\t\t\t\t\t\t\t\tif (!alf[j].alpha1.empty() && EXIST(alf[j].alpha1, 'A' + i)) {\n\t\t\t\t\t\t\t\t\talf[j].alpha1.erase('A' + i);\n\t\t\t\t\t\t\t\t\talf[j].alpha1.insert('.');\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (!alf[j].alpha1.empty() && EXIST(alf[j].alpha1, 'A' + i)) {\n\t\t\t\t\t\t\t\t\talf[j].alpha1.erase('A' + i);\n\t\t\t\t\t\t\t\t\talf[j].alpha1.insert('.');\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (!alf[j].alpha2.empty() && EXIST(alf[j].alpha2, 'A' + i)) {\n\t\t\t\t\t\t\t\t\talf[j].alpha2.erase('A' + i);\n\t\t\t\t\t\t\t\t\talf[j].alpha2.insert('.');\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} while (change);\n\tcout << ans * 2 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint m,n;\nvector<P> data[30];\nvector<int> xindex;\nvector<int> yindex;\nint field[180][180];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint pickl[4];\nint picklx[4];\nint pickly[4];\n\nint main(void){\n\tscanf(\"%d %d\",&n,&m);\n\tfor(int i=0;i<n;i++){\n\t\tstring str;\n\t\tcin >> str;\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(str[j]>='A' && str[j]<='Z'){\n\t\t\t\tdata[str[j]-'A'+1].push_back(P(j,i));\n\t\t\t\tif(j-1>=0)xindex.push_back(j-1);\n\t\t\t\txindex.push_back(j);\n\t\t\t\tif(j+1<m)xindex.push_back(j+1);\n\t\t\t\tif(i-1>=0)yindex.push_back(i-1);\n\t\t\t\tyindex.push_back(i);\n\t\t\t\tif(i+1<n)yindex.push_back(i+1);\n\t\t\t}\n\t\t}\n\t}\n\tsort(xindex.begin(),xindex.end());\n\txindex.erase(unique(xindex.begin(),xindex.end()),xindex.end());\n\tsort(yindex.begin(),yindex.end());\n\tyindex.erase(unique(yindex.begin(),yindex.end()),yindex.end());\n\tfor(int i=1;i<=26;i++){\n\t\tfor(int j=0;j<data[i].size();j++){\n\t\t\tdata[i][j].first=lower_bound(xindex.begin(),xindex.end(),data[i][j].first)-xindex.begin();\n\t\t\tdata[i][j].second=lower_bound(yindex.begin(),yindex.end(),data[i][j].second)-yindex.begin();\n\t\t\tfield[data[i][j].first][data[i][j].second]=i;\n\t\t}\n\t}\n\tbool flag=true;\n\tint score=0;\n\twhile(flag){\n\t\tflag=false;\n\t\tfor(int i=0;i<yindex.size();i++){\n\t\t\tfor(int j=0;j<xindex.size();j++){\n\t\t\t\tif(field[j][i]==0){\n\t\t\t\t\tmemset(pickl,0,sizeof(pickl));\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tint xx=j,yy=i;\n\t\t\t\t\t\tint xi=xindex.size(),yi=yindex.size();\n\t\t\t\t\t\twhile(xx>=0 && xx<xi && yy>=0 && yy<yi){\n\t\t\t\t\t\t\tif(field[xx][yy]!=0)break;\n\t\t\t\t\t\t\txx+=dx[k];\n\t\t\t\t\t\t\tyy+=dy[k];\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(field[xx][yy]!=0){\n\t\t\t\t\t\t\tpickl[k]=field[xx][yy];\n\t\t\t\t\t\t\tpicklx[k]=xx;\n\t\t\t\t\t\t\tpickly[k]=yy;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tfor(int l=k+1;l<4;l++){\n\t\t\t\t\t\t\tif(pickl[k]==pickl[l] && pickl[k]!=0){\n\t\t\t\t\t\t\t\tscore+=2;\n\t\t\t\t\t\t\t\tfield[picklx[k]][pickly[k]]=0;\n\t\t\t\t\t\t\t\tfield[picklx[l]][pickly[l]]=0;\n\t\t\t\t\t\t\t\tflag=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",score);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst int tx[] = {0,1,1,0};\nconst int ty[] = {0,0,1,1};\n \nstatic const double EPS = 1e-10;\n\nstruct Point {\n  int x;\n  int y;\n  Point(int _x,int _y) : x(_x) , y(_y) {}\n};\n\nint main(){\n  int H,W;\n  char stage[500][500];\n\n  map<char,vector<Point> > tiles;\n  while(~scanf(\"%d %d\",&H,&W)){\n    for(int y=0;y<H;y++){\n      string line;\n      cin >> line;\n      for(int x=0;x<W;x++){\n\tstage[y][x] = line[x];\n\tif(stage[y][x] != '.'){\n\t  tiles[stage[y][x]].push_back(Point(x,y));\n\t}\n      }\n    }\n\n    int erased_count = 0;\n    bool erased[256];\n    memset(erased,false,sizeof(erased));\n    erased['.'] = true;\n\n    for(int round=0;round <= 500*500; round++){\n      for(int target_char = 'A'; target_char <= 'Z'; target_char++){\n\tif(erased[target_char]) continue;\n\tif(tiles.find(target_char) == tiles.end()) continue;\n\t\n\tint x1 = tiles[target_char][0].x;\n\tint y1 = tiles[target_char][0].y;\n\n\tint x2 = tiles[target_char][1].x;\n\tint y2 = tiles[target_char][1].y;\n\n\tbool isok = true;\n\tif(x1 == x2){\n\t  if(abs(y1-y2) == 1) isok = false;\n\n\t  int x = x1;\n\t  for(int y=min(y1,y2)+1;y<max(y1,y2);y++){\n\t    if(!erased[stage[y][x]]){\n\t      isok = false;\n\t      break;\n\t    }\n\t  }\n\t}\n\telse if(y1==y2){\n\t  if(abs(x1-x2) == 1) isok = false;\n\n\t  int y = y1;\n\t  for(int x=min(x1,x2)+1;x<max(x1,x2);x++){\n\t    if(!erased[stage[y][x]]){\n\t      isok = false;\n\t      break;\n\t    }\n\t  }\n\t}\n\telse{\n\n\t  vector<Point> medium;\n\t  int wrong_count = 0;\n\t  for(int i=0;i<tiles[target_char].size();i++){\n\t    for(int j=0;j<tiles[target_char].size();j++){\n\t      if(!((x1 == tiles[target_char][i].x && y1 == tiles[target_char][j].y)\n\t\t   || (x2 == tiles[target_char][i].x && y2 == tiles[target_char][j].y))){\n\t\tPoint mid(tiles[target_char][i].x,tiles[target_char][j].y);\n\n\t\t//target x1,y1\n\t\tint flag1 = 0;\n\t\tfor(int x = min(mid.x,x1);x<max(mid.x,x1); x++){\n\t\t  if(!erased[stage[y1][x]]) flag1 |= 1;\n\t\t}\n\n\t\tfor(int y = min(mid.y,y1);y<max(mid.y,y1); y++){\n\t\t  if(!erased[stage[y][x1]]) flag1 |= (1<<1);\n\t\t}\n\n\t\t//target x2,y2\n\t\tint flag2 = 0;\n\t\tfor(int x = min(mid.x,x2);x<max(mid.x,x2); x++){\n\t\t  if(!erased[stage[y2][x]]) flag2 |= 1;\n\t\t}\n\n\t\tfor(int y = min(mid.y,y2);y<max(mid.y,y2); y++){\n\t\t  if(!erased[stage[y][x2]]) flag2 |= (1<<1);\n\t\t}\n\n\t\tif(flag1 == ((1<<2)-1) && flag2 == ((1<<2)-1)){\n\t\t  wrong_count++;\n\t\t}\n\t      }\n\t    }\n\n\t    if(wrong_count == 2){\n\t      isok = false;\n\t    }\n\t  }\n\t}\n\t\n\tif(isok){\n\t  erased[target_char] = true;\n\t  erased_count++;\n\t}\n      }\n    }\n\n    printf(\"%d\\n\",erased_count*2);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nstring grid[500];\nint posy[26][2],posx[26][2];\nint pos[26][2][2];\nbool use[26];\nint n,m;\nint res;\n\nbool cluck(int y,int x){\n  int k;\n  int cnt[26];\n  for(int i=0;i<26;i++)cnt[i] = 0;\n\n  k = 1;\n  while(y+k<n && grid[y+k][x] == '.')k++;\n  if(y+k<n)cnt[grid[y+k][x]-'A']++;\n\n  k = 1;\n  while(x+k<m && grid[y][x+k] == '.')k++;\n  if(x+k<m)cnt[grid[y][x+k]-'A']++;\n\n  k = 1;\n  while(y-k>=0 && grid[y-k][x] == '.')k++;\n  if(y-k>=0)cnt[grid[y-k][x]-'A']++;\n\n  k = 1;\n  while(x-k>=0 && grid[y][x-k] == '.')k++;\n  if(x-k>=0)cnt[grid[y][x-k]-'A']++;\n\n  bool f = false;\n  for(int i=0;i<26;i++){\n    if(cnt[i]>=2){\n      res += 2;\n      f = true;\n      for(int j=0;j<n;j++){\n\tfor(int k=0;k<m;k++){\n\t  if(grid[j][k] == 'A'+i)grid[j][k] ='.';\n\t}\n      }\n    }\n  }\n  return f;\n}\n\nint main(){\n  cin >> n >> m;\n  for(int i=0;i<n;i++)cin >> grid[i];\n\n  for(int i=0;i<26;i++){\n    posy[i][0] = -1;\n    posx[i][0] = -1;\n    posy[i][1] = -1;\n    posx[i][1] = -1;\n  }\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<m;j++){\n      if(grid[i][j] != '.'){\n\tif(posy[grid[i][j]-'A'][0]<0){\n\t  posy[grid[i][j]-'A'][0] = i;\n\t  posx[grid[i][j]-'A'][0] = j;\n\t}else{\n\t  posy[grid[i][j]-'A'][1] = i;\n\t  posx[grid[i][j]-'A'][1] = j;\n\t}\n      }\n    }\n  }\n\n  res = 0;\n  while(1){\n    bool f = false;\n    for(int i=0;i<26;i++){\n      if(posy[i][0] == posy[i][1]){\n\tint s = min(posx[i][0],posx[i][1]),g = max(posx[i][0],posx[i][1]);\n\tfor(int j=s+1;j<g;j++){\n\t  if(grid[posy[i][0]][j]=='.')f |= cluck(posy[i][0],j);\n\t}\n      }else if(posx[i][0] == posx[i][1]){\n\tint s = min(posy[i][0],posy[i][1]),g = max(posy[i][0],posy[i][1]);\n\tfor(int j=s+1;j<g;j++){\n\t  if(grid[j][posx[i][0]]=='.')f |= cluck(j,posx[i][0]);\n\t}\n      }else{\n\tif(grid[posy[i][0]][posx[i][1]] == '.')f |= cluck(posy[i][0],posx[i][1]);\n\tif(grid[posy[i][1]][posx[i][0]] == '.')f |= cluck(posy[i][1],posx[i][0]);\n      }\n    }\n    if(!f)break;\n  }\n\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_H 500\n#define MAX_W 500\n#define F first\n#define S second\ntypedef pair<int,int> pii;\n\nint H,W;\nchar field[MAX_H][MAX_W];\nvector<pii> v[26];\n\nbool inField(int x,int y){\n    return (0 <= x && x < W && 0 <= y && y < H);\n}\n\nint calc(int x,int y){\n    for(int i = 0 ; i < 26 ; i++){\n        v[i].clear();\n    }\n    const int dx[] = {-1,0,1,0};\n    const int dy[] = {0,-1,0,1};\n    for(int i = 0 ; i < 4 ; i++){\n        int nx = x, ny = y;\n        while(1){\n            nx += dx[i]; ny += dy[i];\n            if(!inField(nx,ny)) break;\n            if(field[ny][nx] != '.'){\n                v[field[ny][nx]-'A'].push_back(pii(nx,ny));\n                break;\n            }\n        }\n    }\n    int res = 0;\n    for(int i = 0 ; i < 26 ; i++){\n        if(v[i].size() == 2){\n            field[v[i][0].S][v[i][0].F] = '.';\n            field[v[i][1].S][v[i][1].F] = '.';\n            res += 2;\n        }\n    }\n    return res;\n}\n\nint main(){\n    cin >> H >> W;\n    for(int i = 0 ; i < H ; i++){\n        for(int j = 0 ; j < W ; j++){\n            cin >> field[i][j];\n        }\n    }\n    int res = 0;\n    bool update = 1;\n    while(update){\n        update = 0;\n        for(int i = 0 ; i < H ; i++){\n            for(int j = 0 ; j < W ; j++){\n                if(field[i][j] != '.') continue;\n                int r = calc(j,i);\n                if(r > 0){\n                    res += r;\n                    update = 1;\n                }\n            }\n        }\n    }\n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint H,W;\ntypedef pair<int,int>P;\n\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\nconst int TYPEX = 1;\nconst int TYPEY = 2;\nconst int ELSE = 3;\n\nclass Data{\npublic:\n  vector<P>pv;\n  bool used;\n  int type;\n  Data(){pv.clear();used = true;type = 0;};\n  void check(){\n    sort(pv.begin(),pv.end());\n    for(int i = 0 ; i < 4 ; i++){\n      P np = P(pv[0].first + dy[i],pv[0].second + dx[i]);\n      if(!(0 <= np.first && np.first < H && 0 <= np.second && np.second < W))continue;\n      if(pv[1] == np){\n\tused = true;\n\treturn;\n      }\n    }\n    if(pv[0].first == pv[1].first)type = TYPEY;\n    else if(pv[0].second == pv[1].second)type = TYPEX;\n    else type = ELSE;\n  }\n};\n\nData data[26];\n\nvoid init(){\n  for(int i = 0 ; i < 26 ; i++)data[i] = Data();\n}\n\nvoid input(){\n  cin >> H >> W;\n  for(int i = 0 ; i < H ; i++){\n    for(int j = 0 ; j < W ; j++){\n      char c;\n      cin >> c;\n      if(c == '.')continue;\n      data[c-'A'].pv.push_back(P(i,j));\n      data[c-'A'].used = false;\n    }\n  }\n  for(int i = 0 ; i < 26 ; i++){\n    if(!data[i].used)data[i].check();\n  }\n  /*\n  for(int i = 0 ; i < 26 ; i++){\n    cout << \"i = \" << i << \" used = \" << data[i].used << endl;\n  }\n  */\n}\n\nint run(int res){\n  for(int i = 0 ; i < 26 ; i++){\n    if(data[i].used)continue;\n    bool f = false;\n    P p0,p1,p2;\n    p0 = data[i].pv[0];\n    p1 = data[i].pv[1];\n\n    if(data[i].type == TYPEX){\n      for(int j = 0 ; j < 26 ; j++){\n\tif(f)break;\n\tif(j == i)continue;\n\tif(data[j].used)continue;\n\tfor(int k = 0 ; k < 2 ; k++){\n\t  p2 = data[j].pv[k];\n\t  if(p0.second != p2.second)continue;\n\t  if(p0.first < p2.first && p2.first < p1.first){\n\t    f = true;\n\t    break;\n\t  }\n\t}\n      }\n    }\n    else if(data[i].type == TYPEY){\n      for(int j = 0 ; j < 26 ; j++){\n\tif(f)break;\n\tif(j == i)continue;\n\tif(data[j].used)continue;\n\tfor(int k = 0 ; k < 2 ; k++){\n\t  p2 = data[j].pv[k];\n\t  if(p0.first != p2.first)continue;\n\t  if(p0.second < p2.second && p2.second < p1.second){\n\t    f = true;\n\t    break;\n\t  }\n\t}\n      }\n    }\n    else {\n      for(int j = 0 ; j < 26 ; j++){\n\tif(f)break;\n\tif(j == i)continue;\n\tbool f1,f2;\n\tf1 = f2 = false;\n\tif(data[j].used)continue;\n\n\tfor(int k = 0 ; k < 2 ; k++){\n\t  p2 = data[j].pv[k];\n\t  int x1,x2,y1,y2;\n\t  if(p0.first < p1.first){\n\t    x1 = p0.second;\n\t    y1 = p0.first;\n\t    x2 = p1.second;\n\t    y2 = p1.first;\n\t    \n\t    if(p2.second == x1){\n\t      if(y1 <= p2.first && p2.first <= y2)f1 = true;\n\t    }\n\t    \n\t    if(p2.first == y1){\n\t      if(x1 <= p2.second && p2.second <= x2)f2 = true;\n\t    }\n\t    \n\t    if(p2.second == x2){\n\t      if(y1 <= p2.first && p2.first <= y2)f2 = true;\n\t    }\n\n\t    if(p2.first == y2){\n\t      if(x1 <= p2.second && p2.second <= x2)f1 = true;\n\t    }\n\n\t  }\n\t  else{\n\t    x1 = p0.second;\n\t    y1 = p1.first;\n\t    x2 = p1.second;\n\t    y2 = p0.first;\n\n\t    if(p2.second == x1){\n\t      if(y1 <= p2.first && p2.first <= y2)f1 = true;\n\t    }\n\t    \n\t    if(p2.first == y1){\n\t      if(x1 <= p2.second && p2.second <= x2)f1 = true;\n\t    }\n\t    \n\t    if(p2.second == x2){\n\t      if(y1 <= p2.first && p2.first <= y2)f2 = true;\n\t    }\n\n\t    if(p2.first == y2){\n\t      if(x1 <= p2.second && p2.second <= x2)f2 = true;\n\t    }\n\t  }\n\t}\n\tif(f1 && f2){\n\t  f = true;\n\t  break;\n\t}\n      }\n    }\n    if(f)continue;\n    //cout << \"del = \" << (char)(i + 'A') << endl;//\n    data[i].used = true;\n    return run(res+2);\n  }\n  return res;\n}\n\nint main(){\n  init();\n  input();\n  cout << run(0) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <tuple>\n#include <algorithm>\nusing namespace std;\nusing T=tuple<int,int,char>;\nint main(){\n    int M,N;\n    cin>>M>>N;\n    vector<T> V;\n    for(int i=0;i<M;i++){\n        for(int j=0;j<N;j++){\n            char c;\n            cin>>c;\n            if(c!='.'){\n                V.emplace_back(j,i,c);\n            }\n        }\n    }\n    vector<int> X,Y;\n    for(auto t:V){\n        int x,y;\n        tie(x,y,ignore)=t;\n        X.emplace_back(x);\n        Y.emplace_back(y);\n        sort(X.begin(), X.end());\n        sort(Y.begin(), Y.end());\n    }\n    X.erase(unique(X.begin(), X.end()),X.end());\n    vector<int> XX;\n    XX.push_back(X[0]);\n    for(int i=1;i<X.size();i++){\n        if(X[i-1]+1!=X[i]){\n            XX.push_back(X[i-1]+1);\n        }\n        XX.push_back(X[i]);\n    }\n    swap(X,XX);\n    Y.erase(unique(Y.begin(), Y.end()),Y.end());\n    vector<int> YY;\n    YY.push_back(Y[0]);\n    for(int i=1;i<Y.size();i++){\n        if(Y[i-1]+1!=Y[i]){\n            YY.push_back(Y[i-1]+1);\n        }\n        YY.push_back(Y[i]);\n    }\n    swap(Y,YY);\n    int x_max=X.size()-1;\n    int y_max=Y.size()-1;\n    char board[Y.size()][X.size()];//y,x\n    for(int i=0;i<=y_max;i++){\n        for(int j=0;j<=x_max;j++){\n            board[i][j]='.';\n        }\n    }\n    for(auto &t:V){\n        int x,y; char c;\n        tie(x,y,c)=t;\n        x=lower_bound(X.begin(), X.end(),x)-X.begin();\n        y=lower_bound(Y.begin(), Y.end(),y)-Y.begin();\n        board[y][x]=c;\n    }\n    /*\n    for(int i=0;i<=y_max;i++){\n        for(int j=0;j<=x_max;j++){\n            cout<<board[i][j];\n        }\n        cout<<endl;\n    }*/\n    bool updated=true;\n    int ans=0;\n    while(updated){\n        updated=false;\n        for(int y=0;y<=y_max;y++){\n            for(int x=0;x<=x_max;x++){\n                if(board[y][x]!='.') continue;\n                char up='u',down='d',left='l',right='r';\n                int upd,downd,leftd,rightd;\n                for(int d=1;x+d<=x_max;d++){\n                    if(board[y][x+d]!='.'){\n                        right=board[y][x+d];\n                        rightd=d;\n                        break;\n                    }\n                }\n                for(int d=-1;0<=x+d;d--){\n                    if(board[y][x+d]!='.'){\n                        left=board[y][x+d];\n                        leftd=d;\n                        break;\n                    }\n                }\n                for(int d=1;y+d<=y_max;d++){\n                    if(board[y+d][x]!='.'){\n                        down=board[y+d][x];\n                        downd=d;\n                        break;\n                    }\n                }\n                for(int d=-1;0<=y+d;d--){\n                    if(board[y+d][x]!='.'){\n                        up=board[y+d][x];\n                        upd=d;\n                        break;\n                    }\n                }\n                if(up==down){\n                    board[y+upd][x]=board[y+downd][x]='.';\n                    ans+=2;\n                    updated=true;\n                }\n                if(up==left){\n                    board[y+upd][x]=board[y][x+leftd]='.';\n                    ans+=2;\n                    updated=true;\n                }\n                if(up==right){\n                    board[y+upd][x]=board[y][x+rightd]='.';\n                    ans+=2;\n                    updated=true;\n                }\n                if(down==left){\n                    board[y+downd][x]=board[y][x+leftd]='.';\n                    ans+=2;\n                    updated=true;\n                }\n                if(down==right){\n                    board[y+downd][x]=board[y][x+rightd]='.';\n                    ans+=2;\n                    updated=true;\n                }\n                if(left==right){\n                    board[y][x+leftd]=board[y][x+rightd]='.';\n                    ans+=2;\n                    updated=true;\n                }\n            }\n        }\n    }\n    cout<<ans<<endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\nchar f[502][502];\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,-1,0,1};\nint n,m;\nbool erase(vector<pair<int,int> > pos){\n    bool reachable[2][502][502];\n    memset(reachable, false, sizeof(reachable));\n    int x,y;\n    \n    for(int i=0;i<2;i++){\n        for(int j=0;j<4;j++){\n            y = pos[i].first;\n            x = pos[i].second;\n            do{\n                y += dy[j];\n                x += dx[j];\n                if(f[y][x] == '.'){\n                    reachable[i][y][x] = true;\n                }else{\n                    break;\n                }\n            }while(f[y][x] == '.');\n        }\n    }\n    for(int i=1;i<=m;i++){\n        for(int j=1;j<=n;j++){\n            if(reachable[0][i][j] && reachable[1][i][j]){\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint main(){\n\n    cin >> m >> n;\n    vector<pair<int,int> > place[26];\n\n    memset(f, -1, sizeof(f));\n    for(int i=1;i<=m;i++){\n        for(int j=1;j<=n;j++){\n            cin >> f[i][j];\n            if(f[i][j] == '.') continue;\n            place[f[i][j] - 'A'].push_back(make_pair(i,j));\n        }\n    }\n\n    int ret=0;\n    bool isended = false;\n    while(!isended){\n        isended = true;\n        for(int i=0;i<26;i++){\n            if((int)place[i].size() != 0){\n                if(erase(place[i])){\n                    ret += 2;\n                    isended = false;\n                    f[place[i][0].first][place[i][0].second] = '.';\n                    f[place[i][1].first][place[i][1].second] = '.';\n                    place[i].clear();\n                }\n            }\n        }\n    }\n    cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n#define F first\n#define S second\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nint dx[] = { 1, 0,-1, 0};\nint dy[] = { 0, 1, 0,-1};\n\nint main(void){\n    for(int w, h, res; cin >> h >> w; cout << res << endl){\n        res = 0;\n\n        map<char, vector<pii> > m;\n\n        vs field(h);\n        rep(y, h){\n            cin >> field[y];\n            rep(x, w) if(field[y][x] != '.') m[field[y][x]].pb(mp(y, x));\n        }\n\n        bool end = false;\n        while(!end){\n            end = true;\n\n            rep(y, h){\n                rep(x, w){\n                    if(field[y][x] != '.') continue;\n\n                    set<char> s;\n\n                    rep(i, 4){\n                        range(k, 1, 1000){\n                            pii next = mp(y + k * dy[i], x + k * dx[i]);\n                            if(next.F < 0 || h <= next.F || next.S < 0 || w <= next.S) break;\n\n                            char c = field[next.F][next.S];\n                            if(c != '.'){\n                                if(!s.insert(c).S){\n                                    rep(j, 2) field[m[c][j].F][m[c][j].S] = '.';\n                                    res += 2;\n                                    end = false;\n                                }\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cctype>\n#include <vector>\n#include <map>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0 ; i < n ; i++)\n\ntypedef pair<int, int> P;\n\nstruct Point{\n  int x1, y1, x2, y2;\n};\n\nconst int MAX = 510;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nchar field[MAX][MAX];\nbool found[26];\nPoint alpha[26];\nint H, W;\n\nbool checkH(int x1, int x2, int y, char c){\n  if(x1 > x2) swap(x1, x2);\n  for(int j = x1 ; j <= x2 ; j++){\n    if(field[y][j] != '.' && field[y][j] != c) return false;\n  }\n  return true;\n}\n\nbool checkW(int y1, int y2, int x, char c){\n  if(y1 > y2) swap(y1, y2);\n  for(int i = y1 ; i <= y2 ; i++){\n    if(field[i][x] != '.' && field[i][x] != c) return false;\n  }\n  return true;\n}\n\nint main(){\n  while(cin >> H >> W){\n    rep(i, H) cin >> field[i];\n    \n    memset(alpha, 0, sizeof(alpha));\n    memset(found, 0, sizeof(found));\n    \n    rep(i, H){\n      rep(j, W){\n\tif(isalpha(field[i][j])){\n\t  int c = field[i][j]-'A';\n\t  if(!found[c]){\n\t    found[c] = true;\n\t    alpha[c].x1 = j, alpha[c].y1 = i;\n\t  }\n\t  else{\n\t    alpha[c].x2 = j, alpha[c].y2 = i;\n\t  }\n\t}\n      }\n    }\n    \n    Point cross[26];\n    rep(i, 26){\n      if(found[i]){\n\tcross[i].x1 = alpha[i].x1, cross[i].y1 = alpha[i].y2;\n\tcross[i].x2 = alpha[i].x2, cross[i].y2 = alpha[i].y1;\n      }\n    }\n    \n    rep(i, H){\n      rep(j, W){\n\trep(k, 4){\n\t  int nx = j+dx[k], ny = i+dy[k];\n\t  if(nx < 0 || nx > W || ny < 0 || ny > H) continue;\n\t  if(field[i][j] == field[ny][nx]) found[field[i][j]-'A'] = false;\n\t}\n      }\n    }\n    \n    int ans = 0;\n    for(; ;){\n    Start:;\n      bool flag = false;\n      rep(i, 26){\n\tif(found[i]){\t  \n\t  int X1 = cross[i].x1, Y1 = cross[i].y1, X2 = cross[i].x2, Y2 = cross[i].y2;\n\t  int x1 = alpha[i].x1, y1 = alpha[i].y1, x2 = alpha[i].x2, y2 = alpha[i].y2;\n\t  char c = 'A'+i;\n\t  \n\t  if(x1 == x2){\n\t    flag = checkW(y1, y2, x1, c);\n\t  }\n\t  else if(y1 == y2){\n\t    flag = checkH(x1, x2, y1, c);\t    \n\t  }\n\t  else{\n\t    if(((checkH(X1, x2, Y1, c) && (checkW(Y1, y1, X1, c)))) ||\n\t       ((checkH(X2, x1, Y2, c) && (checkW(Y2, y2, X2, c))))){\n\t      flag = true;\n\t    }\n\t  }\n\t  \n\t  if(flag){\n\t    //cout << c << endl;\n\t    found[i] = false;\n\t    ans += 2;\n\t    field[y1][x1] = '.', field[y2][x2] = '.';\t    \n\t    goto Start;\n\t  }\n\t  \n\t}\n      }\n      if(!flag) break;\n    }\n    cout << ans << endl;\n  }  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\nusing namespace std;\ntypedef pair<int, int> P;\n\nint h, w;\nchar c[510][510];\nint d[510][510][26];\n\nint main(){\n    cin >> h >> w;\n    rep(i, 0, h){\n        rep(j, 0, w){\n            cin >> c[i][j];\n        }\n    }\n    int ans = 0;\n    for(int t = 0;; t++){\n        bool f = false;\n        char er;\n        memset(d, 0, sizeof(d));\n        rep(i, 0, h){\n            rep(j, 0, w){\n                if(c[i][j] == '.') continue;\n                for(int k = j + 1; k < w; k++){\n                    if(c[i][k] == '.') d[i][k][c[i][j] - 'A']++;\n                    else break;\n                }\n                for(int k = j - 1; j >= 0; k--){\n                    if(c[i][k] == '.') d[i][k][c[i][j] - 'A']++;\n                    else break;\n                }\n                for(int k = i + 1; k < h; k++){\n                    if(c[k][j] == '.') d[k][j][c[i][j] - 'A']++;\n                    else break;\n                }\n                for(int k = i - 1; k >= 0; k--){\n                    if(c[k][j] == '.') d[k][j][c[i][j] - 'A']++;\n                    else break;\n                }\n            }\n        }\n        rep(i, 0, h){\n            rep(j, 0, w){\n                rep(k, 0, 26){\n                    if(d[i][j][k] == 2){\n                        f = true;\n                        er = 'A' + k;\n                        ans += 2;\n                        j = w; i = h; break;\n                    }\n                }\n            }\n        }\n        if(!f) break;\n        rep(i, 0, h){\n            rep(j, 0, w){\n                if(c[i][j] == er){\n                    c[i][j] = '.';\n                }\n            }\n        }\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\nstring mps[501];\npair<int,int> tile1[26];\npair<int,int> tile2[26];\nint m,n;\n\nbool inter(int i,int j,int k) {\n    if(j == k && i != j) return false;\n    if(j > k) swap(j,k);\n\n    return (j <= i) && (i <= k);\n}\n\nint iabs(int i) {\n    if(i < 0) return -i;\n    return i;\n}\n\nbool ok(int idx,int x1,int y1,int x2,int y2) {\n    // adj\n    if(x1 == x2 && iabs(y1-y2) == 1) return false;\n    if(y1 == y2 && iabs(x1-x2) == 1) return false;\n\n    for(int i=0; i<26; ++i) {\n        if(tile1[i].first == -1 || i == idx) continue;\n        if(x1 == x2) {\n            if(tile1[i].second == x1 && inter(tile1[i].first,y1,y2)) {\n                if(tile2[i].second == x1 && inter(tile2[i].first,y1,y2)) return false;\n            }\n        }else if(y1 == y2) {\n            if(tile1[i].first == y1 && inter(tile1[i].second,x1,x2)) {\n                if(tile2[i].first == y1 && inter(tile2[i].second,x1,x2)) return false;\n            }\n        }\n    }\n\n    bool is1 = false,is2 = false;\n    for(int i=0; i<26; ++i) {\n        if(tile1[i].first == -1 || i == idx) continue;\n        if(tile1[i].first == y1 && inter(tile1[i].second,x1,x2)) is1 = true;\n        if(tile1[i].first == y2 && inter(tile1[i].second,x1,x2)) is2 = true;\n        if(tile2[i].first == y1 && inter(tile2[i].second,x1,x2)) is1 = true;\n        if(tile2[i].first == y2 && inter(tile2[i].second,x1,x2)) is2 = true;\n    }\n\n    if(is1 && is2) return false;\n\n    return true;\n}\n\nint main() {\n    cin>>m>>n;\n    for(int i=0; i<m; ++i) cin>>mps[i];\n\n    for(int i=0; i<26; ++i)\n        tile1[i] = tile2[i] = make_pair(-1,-1);\n\n    for(int i=0; i<m; ++i) {\n        for(int j=0; j<n; ++j) {\n            if(mps[i][j] != '.') {\n                if(tile1[mps[i][j]-'A'].first == -1) tile1[mps[i][j]-'A'] = make_pair(i,j);\n                else tile2[mps[i][j]-'A'] = make_pair(i,j);\n            }\n        }\n    }\n\n    int ans = 0;\n    while(true) {\n        bool update = false;\n\n        for(int i=0; i<26; ++i) {\n            if(tile1[i].first == -1) continue;\n            int x1 = tile1[i].second,y1 = tile1[i].first;\n            int x2 = tile2[i].second,y2 = tile2[i].first;\n            if(ok(i,x1,y1,x2,y2)) {\n                tile1[i] = make_pair(-1,-1);\n                tile2[i] = make_pair(-1,-1);\n                ans += 2;\n                update = true;\n            }\n\n        // for(int i=0; i<m; ++i) {\n        //     for(int j=0; j<n; ++j) {\n        //         if(mps[i][j] == '.') cout<<\".\";\n        //         else if(tile1[mps[i][j]-'A'].first == -1) cout<<\".\";\n        //         else cout<<mps[i][j];\n        //     }\n        //     cout<<endl;\n        // }\n        }\n\n        if(!update) break;\n\n\n    }\n\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nchar m[505][505];\nint h, w;\n\nconst int dy[16] = { 0,-1, 0, 1, 1,-1, 1,-1, 0,-2, 0, 2};\nconst int dx[16] = { 1, 0,-1, 0, 1, 1,-1,-1, 2, 0,-2, 0};\n\nvector<pair<pair<int, int>,char>> extends(int y, int x){\n    vector<pair<pair<int,int>,char>> ret;\n    rep(i,4){\n        int ny = y, nx = x;\n        while(true){\n            ny += dy[i];\n            nx += dx[i];\n            if(ny < 0 || ny >= h || nx < 0 || nx >= w) break;\n            if(m[ny][nx] != '.'){\n                ret.emplace_back(make_pair(make_pair(ny,nx),m[ny][nx]));\n                break;\n            }\n        }\n    }\n    return ret;\n}\n\nvoid compress(vector<int> &v) {\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\n\nint lb(vector<int> v, int num){\n    return lower_bound(all(v), num) - v.begin();\n}\n\nint main(){\n    cin >> h >> w;\n\n    vector<pair<pair<int, int>,char>> v;\n    vector<int> x,y;\n    rep(i,h){\n        rep(j,w){\n            char c;\n            cin >> c;\n            if(c != '.'){\n                v.emplace_back(make_pair(make_pair(i,j),c));\n                y.emplace_back(i);\n                x.emplace_back(j);\n            }\n        }\n    }\n    compress(x);\n    compress(y);\n    h = y.size();\n    w = x.size();\n\n    rep(i,h) rep(j,w) m[i][j] = '.';\n    rep(i,v.size()){\n        int fy = lb(y,v[i].first.first);\n        int fx = lb(x,v[i].first.second);\n        m[fy][fx] = v[i].second;\n    }\n    //cout << endl; rep(i,h){ rep(j,w){ cout << m[i][j]; } cout << endl; } cout << endl;\n\n    bool f = true;\n    int cnt = 0;\n    while(f){\n        f = false;\n        rep(i,h){\n            rep(j,w){\n                vector<pair<pair<int, int>,char>> v;\n                if(m[i][j] == '.') v = extends(i,j);\n                rep(i,v.size()){\n                    rep(j,v.size()){\n                        if(i == j) continue;\n                        if(v[i].second == v[j].second){\n                            m[ v[i].first.first ][ v[i].first.second ] = '.';\n                            f = true;\n                            cnt++;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    cout << cnt * 1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define x first\n#define y second\nusing namespace std;\ntypedef pair <int,int> P;\nstring mp[501];\nint m,n,used[30];\nvector <P>  a[30];\n\nint saiki(int);\n\nbool check_x(int y,int x1,int x2){\n  for(int i=x1+1;i<x2;i++)\n    if(mp[y][i]!='.'&&!saiki(mp[y][i]-'A'))return 0;\n  return 1;\n}\n\nbool check_y(int y1,int y2,int x){\n  for(int i=y1+1;i<y2;i++)\n    if(mp[i][x]!='.'&&!saiki(mp[i][x]-'A')) return 0;\n  return 1;\n}\n\n\nint saiki(int ch){  \n  int x1=a[ch][0].x,x2=a[ch][1].x;\n  int y1=a[ch][0].y,y2=a[ch][1].y;\n  int res=0;\n  if(used[ch])return 0;\n  used[ch]=1;\n  \n  if(x1==x2&&y2-y1!=1) res=check_y(y1,y2,x1);\n  if(y1==y2&&x2-x1!=1) res=check_x(y1,x1,x2);\n\n  if(x1!=x2&&y1!=y2) {\n    if(x1<x2){\n      res=check_x(y1,x1,x2+1)&check_y(y1,y2,x2);\n      res|=check_y(y1,y2+1,x1)&check_x(y2,x1,x2);\n    }\n    else{\n      swap(x1,x2);\n      res=check_x(y1,x1-1,x2)&check_y(y1,y2,x1);\n      res |=check_y(y1,y2,x2)&check_x(y2,x1,x2+1);\n      swap(x1,x2);\n    }\n  }\n    \n\n  if(res) mp[y1][x1]=mp[y2][x2]='.',a[ch].clear();\n  used[ch]=0;\n  return res;\n}\n\nint main(){\n\n  cin>>m>>n;\n  for(int i=0;i<m;i++)cin>>mp[i];\n\n  int ans=0;\n  for(int i=0;i<m;i++)\n    for(int j=0;j<n;j++)\n      if(mp[i][j]!='.')a[mp[i][j]-'A'].push_back(P(j,i)),ans++;\n  \n  int flg=1;\n  //  while(flg--)\n    for(int i=0;i<30;i++)if(a[i].size() && saiki(i))flg=1;\n  \n\n  for(int i=0;i<m;i++)\n    for(int j=0;j<n;j++) if(mp[i][j]!='.') ans--;\n\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<VV> VVV;\ntypedef vector<vector<int>> Graph;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\nenum { X, Y, CHAR };\ntypedef vector<int> Tile;\n\nint H, W;\nvector<string> s;\n\n// N, E, S, W\nconst int dx[4] = {-1, 0,  1,  0};\nconst int dy[4] = { 0, 1,  0, -1};\n\ninline bool inside(int x, int y) {\n    return 0 <= x && x < H && 0 <= y && y < W;\n}\n\nTile findNearestTile(int x, int y, int k) {\n    if (!inside(x, y) || s[x][y] == '#') return Tile{-1, -1, -1};\n    if (isalpha(s[x][y])) return Tile{x, y, s[x][y] - 'A'};\n    return findNearestTile(x + dx[k], y + dy[k], k);\n}\n\nbool hit(int sx, int sy) {\n    if (s[sx][sy] == '#') return false;\n    if (isalpha(s[sx][sy])) {\n        rep(k, 4) {\n            int nx = sx + dx[k], ny = sy + dy[k];\n            if (!inside(nx, ny)) continue;\n            if (s[sx][sy] == s[nx][ny]) {\n                // cerr << \"hey!\" << endl;\n                // cerr << sx << \" \" << sy << \" \" << nx << \" \" << ny << endl;\n                // s[sx][sy] = '.';\n                // s[nx][ny] = '.';\n                return true;\n            }\n        }\n        return false;\n    }\n\n    // cout << \"hit: \" << sx << \" \" << sy << endl;\n    rep(start, 4) {\n        Tile tile1{-1, -1, -1};\n        rep(k, 4) {\n            // cout << start << \" \" << k << endl;\n            Tile tile2 = findNearestTile(sx, sy, (k + start) % 4);\n            if (tile2[CHAR] == -1) {\n                continue;\n            } else if (tile1[CHAR] == -1) {\n                tile1 = tile2;\n            } else if (tile1[CHAR] == tile2[CHAR]) {\n                // cout << sx << \" \" << sy << endl;\n                // cout << start << \" \" << k << endl;\n                // cout << tile1[X] << \" \" << tile1[Y] << \" \" << tile1[CHAR] << endl;\n                // cout << tile2[X] << \" \" << tile2[Y] << \" \" << tile2[CHAR] << endl;\n                s[tile1[X]][tile1[Y]] = '.';\n                s[tile2[X]][tile2[Y]] = '.';\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nbool search() {\n    rep(i, H) {\n        rep(j, W) {\n            if (hit(i, j)) {\n                // cout << \"hit\" << endl;\n                // cout << i << \" \" << j << endl;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nbool checkCompress(string line) {\n    for (const auto& c : line) {\n        if (c != '.') return false;\n    }\n    return true;\n}\n\nvoid compress(vector<string> &s) {\n    for (int i = 0; i < s.size(); ) {\n        if (checkCompress(s[i])) {\n            s.erase(s.begin() + i);\n        } else {\n            i++;\n        }\n    }\n}\n\nvoid rot(vector<string> &s) {\n    vector<string> t(s[0].size(), \"\");\n    rep(i, s.size()) rep(j, s[0].size()) {\n        t[j] += s[i][j];\n    }\n    s = t;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    cin >> H >> W;\n    s.resize(H);\n    rep(i, H) cin >> s[i];\n\n    rep(x, H) {\n        rep(y, W) {\n            rep(k, 4) {\n                int nx = x + dx[k], ny = y + dy[k];\n                if (!inside(nx, ny)) continue;\n                if (isalpha(s[x][y]) && s[x][y] == s[nx][ny]) {\n                    s[x][y] = '#';\n                    s[nx][ny] = '#';\n                }\n            }\n        }\n    }\n\n    compress(s);\n    // for (auto line : s) cout << line << endl;\n    // cout << endl;\n\n    if (s.empty()) {\n        cout << 0 << endl;\n        return 0;\n    }\n    rot(s);\n    // // for (auto line : s) cout << line << endl;\n    // // cout << endl;\n    compress(s);\n    // // for (auto line : s) cout << line << endl;\n    // // cout << endl;\n    rot(s);\n    // // for (auto line : s) cout << line << endl;\n    // // cout << endl;\n\n    H = s.size(), W = s[0].size();\n\n    int ans = 0;\n    while (search()) {\n        ans += 2;\n\n        // cout << ans << endl;\n        // rep(i, H) {\n        //     cout << s[i] << endl;\n        // }\n        // cout << endl;\n    }\n\n    cout << ans << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=2020,MAX=5005;\nconst ll INF=1LL<<62;\n\nvector<int> dh={0,1,0,-1},dw={1,0,-1,0};\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int H,W;cin>>H>>W;\n    \n    vector<string> S(H);\n    for(int i=0;i<H;i++) cin>>S[i];\n    \n    vector<pair<int,int>> use;\n    \n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            if(S[i][j]!='.'){\n                for(int k=0;k<H;k++) use.push_back({k,j});\n                for(int k=0;k<W;k++) use.push_back({i,k});\n            }\n        }\n    }\n    int ans=0;\n    \n    for(int t=0;t<26;t++){\n        bool ok=false;\n        for(pair<int,int> p:use){\n            int a=p.first,b=p.second;\n            \n            if(S[a][b]!='.') continue;\n            \n            vector<pair<int,int>> goal(4,{-3,-3});\n            \n            for(int k=0;k<4;k++){\n                int hnow=a,wnow=b;\n                \n                while(hnow>=0&&hnow<H&&wnow>=0&&wnow<W){\n                    if(S[hnow][wnow]!='.'){\n                        goal[k]={hnow,wnow};\n                        break;\n                    }\n                    hnow+=dh[k];\n                    wnow+=dw[k];\n                }\n            }\n            \n            for(int i=0;i<4;i++){\n                if(goal[i].first==-3) continue;\n                for(int j=0;j<4;j++){\n                    if(goal[j].first==-3) continue;\n                    if(i==j) continue;\n                    if(S[goal[i].first][goal[i].second]==S[goal[j].first][goal[j].second]&&S[goal[i].first][goal[i].second]!='.'){\n                        ans+=2;\n                        S[goal[i].first][goal[i].second]='.';\n                        S[goal[j].first][goal[j].second]='.';\n                        goal[i].first=-3;\n                        goal[j].first=-3;\n                        \n                        ok=true;\n                        \n                        break;\n                    }\n                }\n            }\n        }\n        if(!ok) break;\n    }\n    \n    cout<<ans<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\nusing namespace std;\n\nint W,H;\n\nvector<string> V;\n\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\n\nbool in(int y,int x){\n\treturn !(y<0 || x<0 || y>=H || x>=W);\n}\nint res;\n\nbool kesu(int y,int x){\n\tif(V[y][x]!='.') return false;\n\tfor(int r1=0;r1<4;r1++){\n\t\tfor(int r2=r1+1;r2<4;r2++){\n\t\t\tint ny1=y,nx1=x;\n\t\t\twhile(V[ny1][nx1]=='.'){ny1+=dy[r1];nx1+=dx[r1];if(!in(ny1,nx1)) break;}\n\t\t\tif(!in(ny1,nx1)) continue;\n\n\t\t\tint ny2=y,nx2=x;\n\t\t\twhile(V[ny2][nx2]=='.'){ny2+=dy[r2];nx2+=dx[r2];if(!in(ny2,nx2)) break;}\n\t\t\tif(!in(ny2,nx2)) continue;\n\n\t\t\tif(V[ny1][nx1]==V[ny2][nx2]){\n\t\t\t\tres++;\n\t\t\t\tV[ny1][nx1]=V[ny2][nx2]='.';\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nvoid solve(){\n\tres=0;\n\tV.clear();\n\tfor(int i=0;i<H;i++){\n\t\tstring s;\n\t\tcin>>s;\n\t\tV.push_back(s);\n\t}\n\n\tbool update=true;\n\twhile(update){\n\t\tupdate=false;\n\t\tfor(int y=0;y<H;y++)\n\t\t\tfor(int x=0;x<W;x++)\n\t\t\t\tupdate=(kesu(y,x)|| update);\n\t}\n\n\n\tcout<<res*2<<endl;\n}\n\nint main()\n{\n\twhile(cin>>H>>W){\n\t\tif(H==0) break;\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mk make_pair\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nstring s[500];\nint h,w,sum=0;\nvector<int>x,y;\nvoid del(int t1,int t2){\n  vector<pair<char,pair<int,int> > >p;\n  for(int i=t1;i<h;i++)if(s[i][t2]!='.'){\n    p.push_back(mk(s[i][t2],mk(i,t2)));\n    break;\n  }\n  for(int i=t1;i>=0;i--)if(s[i][t2]!='.'){\n    p.push_back(mk(s[i][t2],mk(i,t2)));\n    break;\n  }\n  for(int i=t2;i<w;i++)if(s[t1][i]!='.'){\n    p.push_back(mk(s[t1][i],mk(t1,i)));\n    break;\n  }\n  for(int i=t2;i>=0;i--)if(s[t1][i]!='.'){\n    p.push_back(mk(s[t1][i],mk(t1,i)));\n    break;\n  }\n  sort(p.begin(),p.end());\n  if(p.size()>=2){\n    r(i,p.size()-1){\n      if(p[i].first==p[i+1].first){\n        sum++;\n        s[p[i].second.first][p[i].second.second]='.';\n        s[p[i+1].second.first][p[i+1].second.second]='.';\n      }\n    }\n  }\n}\nint main(){\n  cin>>h>>w;\n  r(i,h)cin>>s[i];\n  r(i,h)r(j,w)if(s[i][j]!='.'){\n      y.push_back(i),x.push_back(j);\n      if(i+1<h)y.push_back(i+1);\n      if(j+1<w)x.push_back(j+1);\n    }\n  r(k,5)r(i,y.size())r(j,x.size())\n    if(s[y[i]][x[j]]=='.')del(y[i],x[j]);\n  cout<<sum*2<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<cassert>\n#include<cstdlib>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int N = 500;\nchar m[N][N+1];\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\n\nbool cango(int r,int c,int y,int x,int ty,int tx){\n  rep(i,4){\n    int ddx=x+dx[i],ddy=y+dy[i];\n    while(ddy != -1 && ddx != -1 && ddy != r && ddx != c){\n      if (m[ddy][ddx] != '.')break;\n      if (ddy == ty && ddx == tx)return true;\n      ddx+=dx[i];\n      ddy+=dy[i];\n    }\n  }\n  return false;\n}\n\nbool erase(int r,int c,int y1,int x1,int y2,int x2){\n  vector<int> tx,ty;\n  if (y1 == y2){\n    tx.push_back(x1 < x2?x1+1:x2+1);\n    ty.push_back(y1);\n  }else if (x1 == x2){\n    tx.push_back(x1);\n    ty.push_back(y1 < y2?y1+1:y2+1);\n  }else {\n    tx.push_back(x1);\n    ty.push_back(y2);\n    tx.push_back(x2);\n    ty.push_back(y1);\n  }\n  bool isok=false;\n  rep(i,(int)tx.size()){\n    if (cango(r,c,y1,x1,ty[i],tx[i]) && \n\tcango(r,c,y2,x2,ty[i],tx[i])){isok=true;break;}\n  }\n  if (isok)m[y1][x1]=m[y2][x2]='.';\n  return isok;\n}\n\nmain(){\n  int r,c;\n  while(cin>>r>>c){\n    rep(i,r)cin>>m[i];\n    vector<pii> in[26];\n    rep(i,r){\n      rep(j,c){\n\tif (!isalpha(m[i][j]))continue;\n\tin[m[i][j]-'A'].push_back(make_pair(i,j));\n      }\n    }\n    int ans=0;\n    while(true){\n      bool iserased=false;\n      rep(i,26){\n\tif (in[i].size() == 0)continue;\n\tif (abs(in[i][0].first-in[i][1].first)+abs(in[i][0].second-in[i][1].second) == 1)in[i].clear();\n\tif (erase(r,c,in[i][0].first,in[i][0].second,in[i][1].first,in[i][1].second))ans+=2,iserased=true,in[i].clear();\n      }\n      if (!iserased)break;\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-12;\n\n//int N, M, K, T, H, W, L, R;\nlong long int N, M, K, T, H, W, L, R;\n\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> H >> W;\n\tvector<string>s(H);\n\tfor (auto &i : s)cin >> i;\n\tvector<int>xnum(W);\n\tvector<int>ynum(H);\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (s[i][j] != '.') {\n\t\t\t\txnum[j]++;\n\t\t\t\tynum[i]++;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int loop = 0; loop < 26; loop++) {\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (!ynum[i] && !xnum[j])continue;\n\t\t\t\tif (s[i][j] != '.')continue;\n\t\t\t\tint ay, ax, by, bx, cy, cx, dy, dx;\n\t\t\t\tay = by = cy = dy = i, ax = bx = cx = dx = j;\n\t\t\t\twhile (ay >= 0 && s[ay][ax] == '.') ay--;\n\t\t\t\twhile (by < H&&s[by][bx] == '.')by++;\n\t\t\t\twhile (cx >= 0 && s[cy][cx] == '.')cx--;\n\t\t\t\twhile (dx < W && s[dy][dx] == '.')dx++;\n\t\t\t\tif (ay >= 0 && by < H&&s[ay][ax] == s[by][bx]&&s[ay][ax]!='.') {\n\t\t\t\t\tynum[ay]--;\n\t\t\t\t\tynum[by]--;\n\t\t\t\t\txnum[ax]--;\n\t\t\t\t\txnum[bx]--;\n\t\t\t\t\ts[ay][ax] = s[by][bx] = '.';\n\t\t\t\t\tans += 2;\n\t\t\t\t}\n\t\t\t\tif (ay >= 0 && cx >= 0 && s[ay][ax] == s[cy][cx] && s[ay][ax] != '.') {\n\t\t\t\t\tynum[ay]--;\n\t\t\t\t\tynum[cy]--;\n\t\t\t\t\txnum[ax]--;\n\t\t\t\t\txnum[cx]--;\n\t\t\t\t\ts[ay][ax] = s[cy][cx] = '.';\n\t\t\t\t\tans += 2;\n\t\t\t\t}\n\t\t\t\tif (ay >= 0 && dx < W && s[ay][ax] == s[dy][dx] && s[ay][ax] != '.') {\n\t\t\t\t\tynum[ay]--;\n\t\t\t\t\tynum[dy]--;\n\t\t\t\t\txnum[ax]--;\n\t\t\t\t\txnum[dx]--;\n\t\t\t\t\ts[ay][ax] = s[dy][dx] = '.';\n\t\t\t\t\tans += 2;\n\t\t\t\t}\n\t\t\t\tif (by < H && cx >= 0 && s[by][bx] == s[cy][cx] && s[by][bx] != '.') {\n\t\t\t\t\tynum[by]--;\n\t\t\t\t\tynum[cy]--;\n\t\t\t\t\txnum[bx]--;\n\t\t\t\t\txnum[cx]--;\n\t\t\t\t\ts[by][bx] = s[cy][cx] = '.';\n\t\t\t\t\tans += 2;\n\t\t\t\t}\n\t\t\t\tif (by < H && dx < W && s[by][bx] == s[dy][dx] && s[by][bx] != '.') {\n\t\t\t\t\tynum[by]--;\n\t\t\t\t\tynum[dy]--;\n\t\t\t\t\txnum[bx]--;\n\t\t\t\t\txnum[dx]--;\n\t\t\t\t\ts[by][bx] = s[dy][dx] = '.';\n\t\t\t\t\tans += 2;\n\t\t\t\t}\n\t\t\t\tif (cx >= 0 && dx < W && s[cy][cx] == s[dy][dx] && s[cy][cx] != '.') {\n\t\t\t\t\tynum[cy]--;\n\t\t\t\t\tynum[dy]--;\n\t\t\t\t\txnum[cx]--;\n\t\t\t\t\txnum[dx]--;\n\t\t\t\t\ts[cy][cx] = s[dy][dx] = '.';\n\t\t\t\t\tans += 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\nusing namespace std;\n\nint M, N, K;\nchar S[550][550];\nint dd[5] = { 0, 1, 0, -1, 0 };\n\nbool isin(int y, int x) {\n  return 0 <= y && y < M && 0 <= x && x < N;\n}\n\nint main(void) {\n  cin >> M >> N;\n  K = 0;\n  REP(i, 0, M) REP(j, 0, N) cin >> S[i][j];\n\n  int ans = 0;\n  bool visited[256];\n  REP(i, 0, 256) visited[i] = false;\n  bool f = true;\n  while(f) {\n    f = false;\n    REP(i, 0, M) REP(j, 0, N) {\n      if(S[i][j] == '.' || visited[S[i][j]]) {\n        int cnt[256];\n        REP(k, 0, 256) cnt[k] = 0;\n        REP(k, 0, 4) {\n          int ny = i + dd[k], nx = j + dd[k + 1];\n          while(isin(ny, nx)) {\n            if(S[ny][nx] != '.' && !visited[S[ny][nx]]) {\n              cnt[S[ny][nx]]++;\n              if(cnt[S[ny][nx]] == 2) {\n                visited[S[ny][nx]] = true;\n                ans += 2;\n                f = true;\n              }\n              break;\n            }\n            ny += dd[k];\n            nx += dd[k + 1];\n          }\n        }\n      }\n    }\n  }\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define x first\n#define y second\nusing namespace std;\ntypedef pair <int,int> P;\nstring mp[501];\nint m,n,used[30];\nvector <P>  a[30];\n\nint saiki(int);\n\nbool check_x(int y,int x1,int x2){\n  for(int i=x1+1;i<x2;i++)\n    if(mp[y][i]!='.'&&!saiki(mp[y][i]-'A'))return 0;\n  return 1;\n}\n\nbool check_y(int y1,int y2,int x){\n  for(int i=y1+1;i<y2;i++)\n    if(mp[i][x]!='.'&&!saiki(mp[i][x]-'A')) return 0;\n  return 1;\n}\n\n\nint saiki(int ch){  \n  int x1=a[ch][0].x,x2=a[ch][1].x;\n  int y1=a[ch][0].y,y2=a[ch][1].y;\n  int res=0;\n  if(used[ch])return 0;\n  used[ch]=1;\n  \n  if(x1==x2&&y2-y1!=1) res=check_y(y1,y2,x1);\n  if(y1==y2&&x2-x1!=1) res=check_x(y1,x1,x2);\n\n  if(x1!=x2&&y1!=y2) {\n    if(x1<x2){\n      res=check_x(y1,x1,x2+1)&check_y(y1,y2,x2);\n      res|=check_y(y1,y2+1,x1)&check_x(y2,x1,x2);\n    }\n    else{\n      swap(x1,x2);\n      res=check_x(y1,x1-1,x2)&check_y(y1,y2,x1);\n      res |=check_y(y1,y2,x2)&check_x(y2,x1,x2+1);\n      swap(x1,x2);\n    }\n  }\n    \n\n  if(res) mp[y1][x1]=mp[y2][x2]='.',a[ch].clear();\n  used[ch]=0;\n  return res;\n}\n\nint main(){\n\n  cin>>m>>n;\n  for(int i=0;i<m;i++)cin>>mp[i];\n\n  int ans=0;\n  for(int i=0;i<m;i++)\n    for(int j=0;j<n;j++)\n      if(mp[i][j]!='.')a[mp[i][j]-'A'].push_back(P(j,i)),ans++;\n  \n  int flg=1;\n  while(flg){\n    flg=0;\n    for(int i=0;i<30;i++)if(a[i].size() && saiki(i)) flg=1;\n  }\n\n  for(int i=0;i<m;i++)\n    for(int j=0;j<n;j++) if(mp[i][j]!='.') ans--;\n\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <cstring>\n#include <queue>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define rev(i,n) for(int i=(int)n-1;i>=0;i--)\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n\n#define delete(a,n) a.erase(remove(all(a),n),a.end())\ntemplate<typename T, typename S> vector<T>& operator<<(vector<T>& a, S b) { a.push_back(b); return a; }\ntemplate<typename T> void operator>>(vector<T>& a, int b) {while(b--)if(!a.empty())a.pop_back();}\nbool isprime(int n){ if(n<2)return false;  for(int i=2;i*i<=n;i++)if(n%i==0)return false;  return true;} \nll b_pow(ll x,ll n){return n ? n==1 ? x: b_pow(x,n>>1)*b_pow(x,(n>>1)+(n&1)) : 1;}\nstring itos(int n){stringstream ss;ss << n;return ss.str();}\n\n//long longÉ«ðÂ¯Ä\nint main(){\n\tint w,h;\n\tcin >> h >> w;\n\tvector< pair<int,int> > v[26];\n\trep(i,h){\n\t\trep(j,w){\n\t\t\tchar c; cin >> c;\n\t\t\tif(c != '.') v[c-'A'].push_back(mp(j,i));\n\t\t}\n\t}\n\tvector<int> x_c,y_c;\n\trep(i,26)rep(j,v[i].size()) x_c.push_back(v[i][j].first) , x_c.push_back(v[i][j].first-1), x_c.push_back(v[i][j].first+1);\n\trep(i,26)rep(j,v[i].size()) y_c.push_back(v[i][j].second), y_c.push_back(v[i][j].second-1), y_c.push_back(v[i][j].second+1);\n\tsort(all(x_c)); x_c.erase( unique(all(x_c)) , x_c.end());\n\tsort(all(y_c)); y_c.erase( unique(all(y_c)) , y_c.end());\n\trep(i,26){\n\t\trep(j,v[i].size()){\n\t\t\tv[i][j].first  = lower_bound(all(x_c),v[i][j].first)  - x_c.begin();\n\t\t\tv[i][j].second = lower_bound(all(y_c),v[i][j].second) - y_c.begin();\n\t\t}\n\t}\n\tw = x_c.size();\n\th = y_c.size();\n\tset< pair<int,int> > ex_x[200] , ex_y[200];\n\trep(i,200){\n\t\tex_x[i].insert(mp(-1000,-1));\n\t\tex_x[i].insert(mp(1000,-1));\n\t\tex_y[i].insert(mp(-1000,-1));\n\t\tex_y[i].insert(mp(1000,-1));\n\t}\n\tchar b[200][200]={0};\n\trep(i,26){\n\t\trep(j,v[i].size()){\n\t\t\tint x = v[i][j].first;\n\t\t\tint y = v[i][j].second;\n\t\t\tb[y][x] = 'A'+i;\n\t\t\tex_x[y].insert(mp(x,i));\n\t\t\tex_y[x].insert(mp(y,i));\n\t\t}\n\t}\n\t\n\tint answer = 0;\n\trep(___,60){\n\t\trep(i,h)rep(j,w){\n\t\t\tif(b[i][j] == 0){\n\t\t\t\tset< pair<int,int> >::iterator it[4];\n\t\t\t\tit[0] = ex_x[i].lower_bound(mp(j,0)); it[0]--;\n\t\t\t\tit[1] = ex_x[i].lower_bound(mp(j,0));\n\t\t\t\tit[2] = ex_y[j].lower_bound(mp(i,0)); it[2]--;\n\t\t\t\tit[3] = ex_y[j].lower_bound(mp(i,0));\n\t\t\t\tvector< pair<int,int> > remover[26];\n\t\t\t\trep(A,4){\n\t\t\t\t\tif(it[A]->second != -1){\n\t\t\t\t\t\tif(A < 2){\n\t\t\t\t\t\t\tremover[it[A]->second].push_back(mp(it[A]->first,i));\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tremover[it[A]->second].push_back(mp(j,it[A]->first));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trep(A,26){\n\t\t\t\t\tif(remover[A].size() == 2){\n\t\t\t\t\t\trep(B,2){\n\t\t\t\t\t\t\tint x = remover[A][B].first;\n\t\t\t\t\t\t\tint y = remover[A][B].second;\n\t\t\t\t\t\t\tex_x[y].erase(mp(x,A));\n\t\t\t\t\t\t\tex_y[x].erase(mp(y,A));\n\t\t\t\t\t\t\tb[y][x] = 0;\n\t\t\t\t\t\t\tanswer ++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << answer << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nstring grid[500];\nint posy[26][2],posx[26][2];\nint pos[26][2][2];\nbool use[26];\nint n,m;\nint res;\n\nbool cluck(int y,int x,int z){\n  int k;\n  int cnt[26];\n  for(int i=0;i<26;i++)cnt[i] = 0;\n\n  k = 1;\n  while(y+k<n && grid[y+k][x] == '.')k++;\n  if(y+k<n)cnt[grid[y+k][x]-'A']++;\n\n  k = 1;\n  while(x+k<m && grid[y][x+k] == '.')k++;\n  if(x+k<m)cnt[grid[y][x+k]-'A']++;\n\n  k = 1;\n  while(y-k>=0 && grid[y-k][x] == '.')k++;\n  if(y-k>=0)cnt[grid[y-k][x]-'A']++;\n\n  k = 1;\n  while(x-k>=0 && grid[y][x-k] == '.')k++;\n  if(x-k>=0)cnt[grid[y][x-k]-'A']++;\n\n  if(cnt[z]==2){\n    res += 2;\n    grid[posy[z][0]][posx[z][0]] ='.';\n    grid[posy[z][1]][posx[z][1]] ='.';\n    return true; \n  }\n  return false;\n}\n\nint main(){\n  cin >> n >> m;\n  for(int i=0;i<n;i++)cin >> grid[i];\n\n  for(int i=0;i<26;i++){\n    posy[i][0] = -1;\n    posx[i][0] = -1;\n    posy[i][1] = -1;\n    posx[i][1] = -1;\n    use[i] = false;\n  }\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<m;j++){\n      if(grid[i][j] != '.'){\n\tif(posy[grid[i][j]-'A'][0]<0){\n\t  posy[grid[i][j]-'A'][0] = i;\n\t  posx[grid[i][j]-'A'][0] = j;\n\t  use[grid[i][j]-'A'] = true;\n\t}else{\n\t  posy[grid[i][j]-'A'][1] = i;\n\t  posx[grid[i][j]-'A'][1] = j;\n\t}\n      }\n    }\n  }\n\n  res = 0;\n  while(1){\n    bool exit = false;\n    for(int i=0;i<26;i++){\n      if(use[i]){\n\tbool f = false;\n\tif(posy[i][0] == posy[i][1]){\n\t  int s = min(posx[i][0],posx[i][1]),g = max(posx[i][0],posx[i][1]);\n\t  for(int j=s+1;j<g;j++){\n\t    if(grid[posy[i][0]][j]=='.')f |= cluck(posy[i][0],j,i);\n\t  }\n\t}else if(posx[i][0] == posx[i][1]){\n\t  int s = min(posy[i][0],posy[i][1]),g = max(posy[i][0],posy[i][1]);\n\t  for(int j=s+1;j<g;j++){\n\t    if(grid[j][posx[i][0]]=='.')f |= cluck(j,posx[i][0],i);\n\t  }\n\t}else{\n\t  if(grid[posy[i][0]][posx[i][1]] == '.')f |= cluck(posy[i][0],posx[i][1],i);\n\t  if(grid[posy[i][1]][posx[i][0]] == '.')f |= cluck(posy[i][1],posx[i][0],i);\n\t}\n\tif(f)use[i] = false;\n\texit |= f;\n      }\n    }\n    if(!exit)break;\n  }\n\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<map>\n#include<set>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<queue>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef vector<int> vint;\n\n#define mp make_pair\n#define pb push_back\n\n#define repp(i,a,b) for(int i=(int)(a);i<=(int)(b);++i)\n#define rep(i,n) repp(i,0,(n)-1)\n\nint in(){int a; scanf(\"%d\",&a); return a;}\n\nstring c[510];\n\nint main(){\n\tint m,n,i,j;\n\tcin>>m>>n;\n\tfor(j=0;j<m;j++){\n\t\tcin>>c[j];\n//cout<<c[j]<<endl;\n\t}\n\tbool update=true;\n\tint result=0;\n\twhile(update){\n\t\tupdate=false;\n\t\tfor(j=0;j<m;j++){\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\tif(c[j][i]!='.')continue;\n\t\t\t\tchar r=0,l=0,d=0,u=0;\n\t\t\t\tint k;\n\t\t\t\tfor(k=1;i+k<n&&c[j][i+k]=='.';k++);\n\t\t\t\tif(i+k<n)r=c[j][i+k];\n\t\t\t\tfor(k=1;i-k>=0&&c[j][i-k]=='.';k++);\n\t\t\t\tif(i-k>=0)l=c[j][i-k];\n\t\t\t\tfor(k=1;j+k<m&&c[j+k][i]=='.';k++);\n\t\t\t\tif(j+k<m)d=c[j+k][i];\n\t\t\t\tfor(k=1;j-k>=0&&c[j-k][i]=='.';k++);\n\t\t\t\tif(j-k>=0)u=c[j-k][i];\n//cout<<(int)r<<\" \"<<(int)l<<\" \"<<(int)d<<\" \"<<(int)u<<endl;\n//cout<<(char)46<<endl;\n\t\t\t\tif(r==l&&r!=0){\n\t\t\t\t\tfor(k=1;c[j][i+k]=='.'&&i+k<n;k++);\n\t\t\t\t\tc[j][i+k]='.';\n\t\t\t\t\tfor(k=1;c[j][i-k]=='.'&&i-k>=0;k++);\n\t\t\t\t\tc[j][i-k]='.';\n\t\t\t\t\tresult+=2;\n\t\t\t\t\tupdate=true;\n\t\t\t\t}\n\t\t\t\tif(r==d&&r!=0){\n\t\t\t\t\tfor(k=1;c[j][i+k]=='.'&&i+k<n;k++);\n\t\t\t\t\tc[j][i+k]='.';\n\t\t\t\t\tfor(k=1;c[j+k][i]=='.'&&j+k<m;k++);\n\t\t\t\t\tc[j+k][i]='.';\n\t\t\t\t\tresult+=2;\n\t\t\t\t\tupdate=true;\n\t\t\t\t}\n\t\t\t\tif(r==u&&r!=0){\n\t\t\t\t\tfor(k=1;c[j][i+k]=='.'&&i+k<n;k++);\n\t\t\t\t\tc[j][i+k]='.';\n\t\t\t\t\tfor(k=1;c[j-k][i]=='.'&&j-k>=0;k++);\n\t\t\t\t\tc[j-k][i]='.';\n\t\t\t\t\tresult+=2;\n\t\t\t\t\tupdate=true;\n\t\t\t\t}\n\t\t\t\tif(l==d&&l!=0){\n\t\t\t\t\tfor(k=1;c[j][i-k]=='.'&&i-k>=0;k++);\n\t\t\t\t\tc[j][i-k]='.';\n\t\t\t\t\tfor(k=1;c[j+k][i]=='.'&&j+k<m;k++);\n\t\t\t\t\tc[j+k][i]='.';\n\t\t\t\t\tresult+=2;\n\t\t\t\t\tupdate=true;\n\t\t\t\t}\n\t\t\t\tif(l==u&&l!=0){\n\t\t\t\t\tfor(k=1;c[j][i-k]=='.'&&i-k>=0;k++);\n\t\t\t\t\tc[j][i-k]='.';\n\t\t\t\t\tfor(k=1;c[j-k][i]=='.'&&j-k>=0;k++);\n\t\t\t\t\tc[j-k][i]='.';\n\t\t\t\t\tresult+=2;\n\t\t\t\t\tupdate=true;\n\t\t\t\t}\n\t\t\t\tif(d==u&&d!=0){\n\t\t\t\t\tfor(k=1;c[j+k][i]=='.'&&j+k<m;k++);\n\t\t\t\t\tc[j+k][i]='.';\n\t\t\t\t\tfor(k=1;c[j-k][i]=='.'&&j-k>=0;k++);\n\t\t\t\t\tc[j-k][i]='.';\n\t\t\t\t\tresult+=2;\n\t\t\t\t\tupdate=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<result<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\nusing namespace std;\n\nchar field[505][505];\n\ntypedef vector<vector<int> > Graph;\n\nint search(int x, int y, int lx, int ly)\n{\n\tint res = 0;\n\tfor(int i=y; i<=ly; i++) \n\tfor(int j=x; j<=lx; j++) {\n\t\tif(field[i][j] == '.') continue;\n\t\tint a = field[i][j] - 'A';\n\t\tres |= (1<<a);\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\tint M,N;\n\twhile(cin >> N >> M) {\n\n\t\tvector<vector<pair<int, int> > > pos(26);\n\t\tfor(int i=0; i<N; i++)\n\t\t\tcin >> field[i];\n\n\t\tfor(int i=0; i<N; i++) \n\t\tfor(int j=0; j<M; j++) {\n\t\t\tif(field[i][j] == '.') continue;\n\t\t\tint a = field[i][j] - 'A';\n\t\t\tpos[a].push_back(make_pair(j,i));\n\t\t}\n\n\t\tGraph graph(26);\n\t\tfor(int i=0; i<26; i++) {\n\t\t\tif(pos[i].size() == 0) continue;\n\n\t\t\tint x = pos[i][0].first;\n\t\t\tint y = pos[i][0].second;\n\n\t\t\tint a = pos[i][1].first;\n\t\t\tint b = pos[i][1].second;\n\n\t\t\tif(x == a) {\n\t\t\t\tif(y > b) swap(y, b);\n\t\t\t\tif(b - y == 1) continue;\n\n\t\t\t\tint hoge = search(x, y+1, a, b-1);\n\t\t\t\tgraph[i].push_back(hoge);\n\n\t\t\t}\n\t\t\telse if(y == b) {\n\t\t\t\tif(x > a) swap(x, a);\n\t\t\t\tif(a - x == 1) continue;\n\n\t\t\t\tint hoge = search(x+1, y, a-1, b);\n\t\t\t\tgraph[i].push_back(hoge);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint l = min(x, a);\n\t\t\t\tint r = min(y, b);\n\n\t\t\t\tint c = max(x, a);\n\t\t\t\tint d = max(y, b);\n\t\t\t\t// /\n\n\t\t\t\tif( l != x) {\n\t\t\t\t\tint hoge = 0;\n\t\t\t\t\thoge |= search(l, r, c-1, r);\n\t\t\t\t\thoge |= search(l, r, l, d-1);\n\n\t\t\t\t\tgraph[i].push_back(hoge);\n\n\t\t\t\t\thoge = 0;\n\t\t\t\t\thoge |= search(l+1, d, c, d);\n\t\t\t\t\thoge |= search(c, r+1, c, d);\n\n\t\t\t\t\tgraph[i].push_back(hoge);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint hoge = 0;\n\t\t\t\t\thoge |= search(l+1, r, c, r);\n\t\t\t\t\thoge |= search(c, r, c, d-1);\n\n\t\t\t\t\tgraph[i].push_back(hoge);\n\n\t\t\t\t\thoge = 0;\n\t\t\t\t\thoge |= search(l, d, c-1, d);\n\t\t\t\t\thoge |= search(l, r+1, l, d);\n\n\t\t\t\t\tgraph[i].push_back(hoge);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint piyo = 0, res = 0;\n\t\tfor(int i=0; i<26; i++) \n\t\tfor(int j=0; j<26; j++) \n\t\tfor(int k=0; k<graph[j].size(); k++) {\n\t\t\tif((piyo & graph[j][k]) == graph[j][k]) {\n\t\t\t\tif((piyo >> j & 1) == 0) {\n\t\t\t\t\tpiyo |= (1<<j);\n\t\t\t\t\tres++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << res * 2 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_W = 500;\nint h, w;\nchar C[MAX_W][MAX_W];\nint dx[4] = {0,0,-1,1};\nint dy[4] = {-1,1,0,0};\nbool memo[MAX_W][MAX_W];\n\nstruct P{\n\tint x, y;\n\tP(int x_, int y_){ x = x_; y = y_; }\n};\n\nbool search(int ax, int ay, int bx, int by){\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tmemo[y][x] = false;\n\t\t}\n\t}\n\tfor(int i=0 ; i < 4 ; i++ ){\n\t\tint mx = ax + dx[i];\n\t\tint my = ay + dy[i];\n\t\twhile( true ){\n\t\t\tif( mx < 0 || my < 0 || w <= mx || h <= my ) break;\n\t\t\tif( C[my][mx] == '.' ){\n\t\t\t\tmemo[my][mx] = true;\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmx += dx[i];\n\t\t\tmy += dy[i];\n\t\t}\n\t}\n\tfor(int i=0 ; i < 4 ; i++ ){\n\t\tint mx = bx + dx[i];\n\t\tint my = by + dy[i];\n\t\twhile( true ){\n\t\t\tif( mx < 0 || my < 0 || w <= mx || h <= my ) break;\n\t\t\tif( memo[my][mx] ){\n\t\t\t\treturn true;\n\t\t\t}else if( C[my][mx] != '.' ){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmx += dx[i];\n\t\t\tmy += dy[i];\n\t\t}\n\t}\n\treturn false;\n}\n\nint solve(){\n\tvector<P> v[26];\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tif( C[y][x] != '.' ){\n\t\t\t\tv[C[y][x]-'A'].push_back(P(x,y));\n\t\t\t}\n\t\t}\n\t}\n\tint res = 0;\n\tbool flag = true;\n\twhile( flag ){\n\t\tflag = false;\n\t\tfor(int i=0 ; i < 26 ; i++ ){\n\t\t\tif( v[i].size() == 0 ) continue;\n\t\t\tif( search(v[i][0].x, v[i][0].y, v[i][1].x, v[i][1].y) ){\n\t\t\t\tC[v[i][0].y][v[i][0].x] = '.';\n\t\t\t\tC[v[i][1].y][v[i][1].x] = '.';\n\t\t\t\tv[i].clear();\n\t\t\t\tflag = true;\n\t\t\t\tres += 2;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin >> h >> w;\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tcin >> C[y];\n\t}\n\tcout << solve() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <tuple>\nusing namespace std;\nusing T=tuple<int,int,char>;\nint main(){\n    int M,N;\n    cin>>M>>N;\n    vector<T> V;\n    for(int i=0;i<M;i++){\n        for(int j=0;j<N;j++){\n            char c;\n            cin>>c;\n            if(c!='.'){\n                V.emplace_back(j,i,c);\n            }\n        }\n    }\n    vector<int> X,Y;\n    for(auto t:V){\n        int x,y;\n        tie(x,y,ignore)=t;\n        X.emplace_back(x);\n        Y.emplace_back(y);\n        sort(X.begin(), X.end());\n        sort(Y.begin(), Y.end());\n    }\n    X.erase(unique(X.begin(), X.end()),X.end());\n    vector<int> XX;\n    XX.push_back(X[0]);\n    for(int i=1;i<X.size();i++){\n        if(X[i-1]+1!=X[i]){\n            XX.push_back(X[i-1]+1);\n        }\n        XX.push_back(X[i]);\n    }\n    swap(X,XX);\n    Y.erase(unique(Y.begin(), Y.end()),Y.end());\n    vector<int> YY;\n    YY.push_back(Y[0]);\n    for(int i=1;i<Y.size();i++){\n        if(Y[i-1]+1!=Y[i]){\n            YY.push_back(Y[i-1]+1);\n        }\n        YY.push_back(Y[i]);\n    }\n    swap(Y,YY);\n    int x_max=X.size()-1;\n    int y_max=Y.size()-1;\n    char board[Y.size()][X.size()];//y,x\n    for(int i=0;i<=y_max;i++){\n        for(int j=0;j<=x_max;j++){\n            board[i][j]='.';\n        }\n    }\n    for(auto &t:V){\n        int x,y; char c;\n        tie(x,y,c)=t;\n        x=lower_bound(X.begin(), X.end(),x)-X.begin();\n        y=lower_bound(Y.begin(), Y.end(),y)-Y.begin();\n        board[y][x]=c;\n    }\n    /*\n    for(int i=0;i<=y_max;i++){\n        for(int j=0;j<=x_max;j++){\n            cout<<board[i][j];\n        }\n        cout<<endl;\n    }*/\n    bool updated=true;\n    int ans=0;\n    while(updated){\n        updated=false;\n        for(int y=0;y<=y_max;y++){\n            for(int x=0;x<=x_max;x++){\n                if(board[y][x]!='.') continue;\n                char up='u',down='d',left='l',right='r';\n                int upd,downd,leftd,rightd;\n                for(int d=1;x+d<=x_max;d++){\n                    if(board[y][x+d]!='.'){\n                        right=board[y][x+d];\n                        rightd=d;\n                        break;\n                    }\n                }\n                for(int d=-1;0<=x+d;d--){\n                    if(board[y][x+d]!='.'){\n                        left=board[y][x+d];\n                        leftd=d;\n                        break;\n                    }\n                }\n                for(int d=1;y+d<=y_max;d++){\n                    if(board[y+d][x]!='.'){\n                        down=board[y+d][x];\n                        downd=d;\n                        break;\n                    }\n                }\n                for(int d=-1;0<=y+d;d--){\n                    if(board[y+d][x]!='.'){\n                        up=board[y+d][x];\n                        upd=d;\n                        break;\n                    }\n                }\n                if(up==down){\n                    board[y+upd][x]=board[y+downd][x]='.';\n                    ans+=2;\n                    updated=true;\n                }\n                if(up==left){\n                    board[y+upd][x]=board[y][x+leftd]='.';\n                    ans+=2;\n                    updated=true;\n                }\n                if(up==right){\n                    board[y+upd][x]=board[y][x+rightd]='.';\n                    ans+=2;\n                    updated=true;\n                }\n                if(down==left){\n                    board[y+downd][x]=board[y][x+leftd]='.';\n                    ans+=2;\n                    updated=true;\n                }\n                if(down==right){\n                    board[y+downd][x]=board[y][x+rightd]='.';\n                    ans+=2;\n                    updated=true;\n                }\n                if(left==right){\n                    board[y][x+leftd]=board[y][x+rightd]='.';\n                    ans+=2;\n                    updated=true;\n                }\n            }\n        }\n    }\n    cout<<ans<<endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint m,n;\nvector<P> dat[100];\nvector<int> xind;\nvector<int> yind;\nint field[280][280];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint pickl[4];\nint picklx[4];\nint pickly[4];\n\nint main(void){\n\tscanf(\"%d %d\",&n,&m);\n\tmemset(field,0,sizeof(field));\n\tfor(int i=0;i<n;i++){\n\t\tstring str;\n\t\tcin >> str;\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(str[j]>='A' && str[j]<='Z'){\n\t\t\t\tdat[str[j]-'A'+1].push_back(P(j,i));\n\t\t\t\tif(j-1>=0)xind.push_back(j-1);\n\t\t\t\txind.push_back(j);\n\t\t\t\tif(j+1<m)xind.push_back(j+1);\n\t\t\t\tif(i-1>=0)yind.push_back(i-1);\n\t\t\t\tyind.push_back(i);\n\t\t\t\tif(i+1<n)yind.push_back(i+1);\n\t\t\t}\n\t\t}\n\t}\n\tsort(xind.begin(),xind.end());\n\txind.erase(unique(xind.begin(),xind.end()),xind.end());\n\tsort(yind.begin(),yind.end());\n\tyind.erase(unique(yind.begin(),yind.end()),yind.end());\n\tfor(int i=1;i<=26;i++){\n\t\tfor(int j=0;j<dat[i].size();j++){\n\t\t\tdat[i][j].first=lower_bound(xind.begin(),xind.end(),dat[i][j].first)-xind.begin();\n\t\t\tdat[i][j].second=lower_bound(yind.begin(),yind.end(),dat[i][j].second)-yind.begin();\n\t\t\tfield[dat[i][j].first][dat[i][j].second]=i;\n\t\t}\n\t}\n\tbool flag=true;\n\tint score2=0;\n\twhile(flag){\n\t\tflag=false;\n\t\tfor(int i=0;i<yind.size();i++){\n\t\t\tfor(int j=0;j<xind.size();j++){\n\t\t\t\tif(field[j][i]==0){\n\t\t\t\t\tmemset(pickl,0,sizeof(pickl));\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tint xx=j,yy=i;\n\t\t\t\t\t\tint xi=xind.size(),yi=yind.size();\n\t\t\t\t\t\twhile(xx>=0 && xx<=xi && yy>=0 && yy<=yi){\n\t\t\t\t\t\t\tif(field[xx][yy]!=0)break;\n\t\t\t\t\t\t\txx+=dx[k];\n\t\t\t\t\t\t\tyy+=dy[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(field[xx][yy]!=0){\n\t\t\t\t\t\t\tpickl[k]=field[xx][yy];\n\t\t\t\t\t\t\tpicklx[k]=xx;\n\t\t\t\t\t\t\tpickly[k]=yy;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tfor(int l=k+1;l<4;l++){\n\t\t\t\t\t\t\tif(pickl[k]==pickl[l] && pickl[k]!=0){\n\t\t\t\t\t\t\t\tscore2+=2;\n\t\t\t\t\t\t\t\tfield[picklx[k]][pickly[k]]=0;\n\t\t\t\t\t\t\t\tfield[picklx[l]][pickly[l]]=0;\n\t\t\t\t\t\t\t\tflag=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",score2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\nstring mps[501];\npair<int,int> tile1[26];\npair<int,int> tile2[26];\nint m,n;\n\nbool inter(int i,int j,int k) {\n    if(j == k && i != j) return false;\n    if(j > k) swap(j,k);\n\n    return (j <= i) && (i <= k);\n}\n\nbool ok(int idx,int x1,int y1,int x2,int y2) {\n    // adj\n    if(x1 == x2 && abs(y1-y2) == 1) return false;\n    if(y1 == y2 && abs(x1-x2) == 1) return false;\n\n    for(int i=0; i<26; ++i) {\n        if(tile1[i].first == -1 || i == idx) continue;\n        if(x1 == x2) {\n            if(tile1[i].second == x1 && inter(tile1[i].first,y1,y2)) {\n                if(tile2[i].second == x1 && inter(tile2[i].first,y1,y2)) return false;\n            }\n        }else if(y1 == y2) {\n            if(tile1[i].first == y1 && inter(tile1[i].second,x1,x2)) {\n                if(tile2[i].first == y1 && inter(tile2[i].second,x1,x2)) return false;\n            }\n        }\n    }\n\n    bool is1 = false,is2 = false;\n    for(int i=0; i<26; ++i) {\n        if(tile1[i].first == -1 || i == idx) continue;\n        if(tile1[i].first == y1 && inter(tile1[i].second,x1,x2)) is1 = true;\n        if(tile1[i].first == y2 && inter(tile1[i].second,x1,x2)) is2 = true;\n        if(tile2[i].first == y1 && inter(tile2[i].second,x1,x2)) is1 = true;\n        if(tile2[i].first == y2 && inter(tile2[i].second,x1,x2)) is2 = true;\n    }\n\n    if(is1 && is2) return false;\n\n    return true;\n}\n\nint main() {\n    cin>>m>>n;\n    for(int i=0; i<m; ++i) cin>>mps[i];\n\n    for(int i=0; i<26; ++i)\n        tile1[i] = tile2[i] = make_pair(-1,-1);\n\n    for(int i=0; i<m; ++i) {\n        for(int j=0; j<n; ++j) {\n            if(mps[i][j] != '.') {\n                if(tile1[mps[i][j]-'A'].first == -1) tile1[mps[i][j]-'A'] = make_pair(i,j);\n                else tile2[mps[i][j]-'A'] = make_pair(i,j);\n            }\n        }\n    }\n\n    int ans = 0;\n    while(true) {\n        bool update = false;\n\n        for(int i=0; i<26; ++i) {\n            if(tile1[i].first == -1) continue;\n            int x1 = tile1[i].second,y1 = tile1[i].first;\n            int x2 = tile2[i].second,y2 = tile2[i].first;\n            if(ok(i,x1,y1,x2,y2)) {\n                tile1[i] = make_pair(-1,-1);\n                tile2[i] = make_pair(-1,-1);\n                ans += 2;\n                update = true;\n            }\n\n        // for(int i=0; i<m; ++i) {\n        //     for(int j=0; j<n; ++j) {\n        //         if(mps[i][j] == '.') cout<<\".\";\n        //         else if(tile1[mps[i][j]-'A'].first == -1) cout<<\".\";\n        //         else cout<<mps[i][j];\n        //     }\n        //     cout<<endl;\n        // }\n        }\n\n        if(!update) break;\n\n\n    }\n\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nusing lint = long long;\nusing ldouble = long double;\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector<string> S(N);\n    for (auto& s : S) cin >> s;\n\n    int ans = 0;\n    bool update = true;\n    while (update) {\n        update = false;\n        for (int cx = 0; cx < N; ++cx) {\n            for (int cy = 0; cy < M; ++cy) {\n                if (S[cx][cy] != '.') continue;\n\n                string app;\n                for (int x = cx; x >= 0; --x) {\n                    if (S[x][cy] != '.') {\n                        app.push_back(S[x][cy]);\n                        break;\n                    }\n                }\n                for (int x = cx; x < N; ++x) {\n                    if (S[x][cy] != '.') {\n                        app.push_back(S[x][cy]);\n                        break;\n                    }\n                }\n                for (int y = cy; y >= 0; --y) {\n                    if (S[cx][y] != '.') {\n                        app.push_back(S[cx][y]);\n                        break;\n                    }\n                }\n                for (int y = cy; y < M; ++y) {\n                    if (S[cx][y] != '.') {\n                        app.push_back(S[cx][y]);\n                        break;\n                    }\n                }\n\n                sort(app.begin(), app.end());\n                if (app.empty()) continue;\n\n                for (int i = 0; i < app.size() - 1; ++i) {\n                    if (app[i] == app[i + 1]) {\n                        for (int x = 0; x < N; ++x) {\n                            replace(S[x].begin(), S[x].end(), app[i], '.');\n                        }\n                        ans += 2;\n                        update = true;\n                    }\n                }\n            }\n        }\n    }\n\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<deque>\n#include<queue>\n#include<string>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include <cctype>\n#include <climits>\nusing namespace std;\n#define REP(i,a,n) for(int i = a ; i < n ; i++)\n#define rep(i,n) REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\n#define INF P(INT_MAX,INT_MAX)\n\nint dx[] = {0,1,0,-1};\nint dy[] = {-1,0,1,0};\n\nint h,w;\nchar t[502][502];\nchar t2[502][502];\n\nP getPlace(int x,int y,int dir){\n  for(;0<=x && x<w && 0<=y && y<h;x+=dx[dir],y+=dy[dir]){\n    if(isalpha(t[y][x])){\n      return P(x,y);\n    }\n  }\n  return INF;\n}\n\nbool attack(int x,int y){\n  if(t[y][x] != '.'){\n    return false;\n  }\n\n  vector<P> v;\n  P tmp = getPlace(x,y,0);\n  if(tmp != INF) v.push_back(tmp);\n  tmp = getPlace(x,y,1);\n  if(tmp != INF) v.push_back(tmp);\n  tmp = getPlace(x,y,2);\n  if(tmp != INF) v.push_back(tmp);\n  tmp = getPlace(x,y,3);\n  if(tmp != INF) v.push_back(tmp);\n\n  rep(i,v.size()){\n    REP(j,i+1,v.size()){\n      int x1 = v[i].first;\n      int y1 = v[i].second;\n      int x2 = v[j].first;\n      int y2 = v[j].second;\n\n      if(t[y1][x1] == t[y2][x2]){\n        t[y1][x1] = t[y2][x2] = '.';\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nvoid solve(){\n  int res = 0;\n\n  while(1){\n    bool tmp = false;\n    rep(i,h){\n      rep(j,w){\n        bool flg = attack(j,i);\n        if(flg){\n          res += 2;\n          tmp = true;\n          break;\n        }\n      }\n      if(tmp) break;\n    }\n\n    if(!tmp){\n      cout<<res<<endl;\n      return;\n    }\n  }\n}\n\nint main(){\n  while(scanf(\"%d%d\",&h,&w) != EOF){\n    string del;\n    rep(i,w)del+=\".\";\n    bool f = false;\n    int count = 0;\n    rep(i,h){\n      string s;\n      cin>>s;\n      if(del == s){\n        if(f){\n          count++;\n          continue;\n        }\n        f = true;\n      }else{\n        f = false;\n      }\n      rep(j,w){\n        t2[i-count][j] = s[j];\n      }\n    }\n    f = false;\n    h -= count;\n    del = \"\";\n    count=0;\n    rep(i,h){\n      del+=\".\";\n    }\n    rep(i,w){\n      string s;\n      rep(j,h){\n        s += t2[j][i];\n      }\n      if(s == del){\n        if(f){\n          count++;\n          continue;\n        }\n        f = true;\n      }\n      else{\n        f = false;\n      }\n      rep(j,h){\n        t[j][i-count] = s[j];\n      }\n    }\n\n    w -= count;\n\n    /*\n    rep(i,h){\n      rep(j,w){\n        cout<<t[i][j]<<\" \";\n      }\n      cout<<endl;\n    }\n    */\n\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint H,W;\nchar fld[510][510];\nbool ex[26];\nint x[26],y[26],xx[26],yy[26];\nvector<int>vec[26][2];\nsigned main(){\n    cin>>H>>W;\n    rep(i,H)cin>>fld[i];\n\n    rep(i,H)rep(j,W){\n        if(fld[i][j]=='.')continue;\n        int t=fld[i][j]-'A';\n        if(!ex[t]){\n            ex[t]=true;\n            x[t]=j;y[t]=i;\n        }\n        else{\n            xx[t]=j;yy[t]=i;\n        }\n    }\n\n    rep(i,26){\n        if(!ex[i])continue;\n        if((x[i]==xx[i]&&abs(y[i]-yy[i])==1)||(y[i]==yy[i]&&abs(x[i]-xx[i])==1)){\n            vec[i][0].pb(i);vec[i][1].pb(i);\n            continue;\n        }\n        for(int j=min(y[i],yy[i]);j<=max(y[i],yy[i]);j++){\n            if(fld[j][x[i]]!='.'&&fld[j][x[i]]!='A'+i)vec[i][0].pb(fld[j][x[i]]-'A');\n            if(fld[j][xx[i]]!='.'&&fld[j][xx[i]]!='A'+i)vec[i][1].pb(fld[j][xx[i]]-'A');\n        }\n        for(int j=min(x[i],xx[i]);j<=max(x[i],xx[i]);j++){\n            if(fld[yy[i]][j]!='.'&&fld[yy[i]][j]!='A'+i)vec[i][0].pb(fld[yy[i]][j]-'A');\n            if(fld[y[i]][j]!='.'&&fld[y[i]][j]!='A'+i)vec[i][1].pb(fld[y[i]][j]-'A');\n        }\n    }\n\n    rep(i,26){\n        rep(j,2){\n            sort(all(vec[i][j]));\n            vec[i][j].erase(unique(all(vec[i][j])),vec[i][j].end());\n        }\n    }\n    int ans=0;\n    while(true){\n        bool update=false;\n        rep(i,26){\n            if(!ex[i])continue;\n            rep(j,2){\n                bool ok=true;\n                for(auto k:vec[i][j]){\n                    if(ex[k])ok=false;\n                }\n                if(!ok)continue;\n                ans++;\n                ex[i]=false;\n                update=true;\n                break;\n            }\n        }\n        if(!update)break;\n    }\n    cout<<ans*2<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nint main(){\n  int H, W;\n  while(cin>>H>>W && H){\n    vector<string> grid(H);\n    REP(i, H) cin>>grid[i];\n    bool update = true;\n    int vx[26][2], vy[26][2];\n    memset(vx, -1, sizeof(vx));\n    memset(vy, -1, sizeof(vy));\n    REP(y, H)REP(x, W)if(isalpha(grid[y][x])){\n      int idx = grid[y][x] - 'A';\n      if(vx[idx][0] != -1){\n        vx[idx][1] = x, vy[idx][1] = y;\n      }else{\n        vx[idx][0] = x, vy[idx][0] = y;\n      }\n    }\n    int ans = 0;\n    while(update){\n      update = false;\n      REP(c, 26)if(vx[c][0] != -1){\n        //printf(\"%d %d %d %d\\n\", vx[c][0], vy[c][0], vx[c][1], vy[c][1]);\n        bool ok = true;\n        // x - 0 , y - 1\n        for(int x = min(vx[c][0], vx[c][1]); x <= max(vx[c][0], vx[c][1]); x++) if(grid[vy[c][1]][x] != '.' && grid[vy[c][1]][x] != (c + 'A')) ok = false;\n        for(int y = min(vy[c][0], vy[c][1]); y <= max(vy[c][0], vy[c][1]); y++) if(grid[y][vx[c][0]] != '.' && grid[y][vx[c][0]] != (c + 'A')) ok = false;\n        if(ok) goto GO;\n\n        ok = true;\n        for(int x = min(vx[c][0], vx[c][1]); x <= max(vx[c][0], vx[c][1]); x++) if(grid[vy[c][0]][x] != '.' && grid[vy[c][0]][x] != (c + 'A')) ok = false;\n        for(int y = min(vy[c][0], vy[c][1]); y <= max(vy[c][0], vy[c][1]); y++) if(grid[y][vx[c][1]] != '.' && grid[y][vx[c][1]] != (c + 'A')) ok = false;\n        if(!ok) continue;\n\n      GO:\n        //cout<<(char)(c + 'A')<<endl;\n        grid[vy[c][1]][vx[c][1]] = '.';\n        grid[vy[c][0]][vx[c][0]] = '.';\n        memset(vx[c], -1, sizeof(vx[c]));\n        memset(vy[c], -1, sizeof(vy[c]));\n        ans += 2;\n        update = true;\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cctype>\n#include <vector>\n#include <map>\n#include <cassert>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0 ; i < n ; i++)\n\ntypedef pair<int, int> P;\n\nstruct Point{\n  int x1, y1, x2, y2;\n};\n\nconst int MAX = 510;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nchar field[MAX][MAX];\nbool found[26];\nPoint alpha[26];\nint H, W;\n\nbool checkH(int x1, int x2, int y, char c){\n  if(x1 > x2) swap(x1, x2);\n  for(int j = x1 ; j <= x2 ; j++){\n    if(field[y][j] != '.' && field[y][j] != c) return false;\n  }\n  return true;\n}\n\nbool checkW(int y1, int y2, int x, char c){\n  if(y1 > y2) swap(y1, y2);\n  for(int i = y1 ; i <= y2 ; i++){\n    if(field[i][x] != '.' && field[i][x] != c) return false;\n  }\n  return true;\n}\n\nint main(){\n  while(cin >> H >> W){\n    rep(i, H) cin >> field[i];\n    \n    memset(alpha, 0, sizeof(alpha));\n    memset(found, 0, sizeof(found));\n    \n    rep(i, H){\n      rep(j, W){\n\tif(isalpha(field[i][j])){\n\t  int c = field[i][j]-'A';\n\t  if(!found[c]){\n\t    found[c] = true;\n\t    //alpha[c].push_back(Point(j, i));\n\t    alpha[c].x1 = j, alpha[c].y1 = i;\n\t  }\n\t  else{\n\t    //alpha[c].push_back(Point(j, i));\n\t    alpha[c].x2 = j, alpha[c].y2 = i;\n\t  }\n\t}\n      }\n    }\n    \n    Point cross[26];\n    rep(i, 26){\n      if(found[i]){\n\t//cross[i].push_back(Point(alpha[i][0].x, alpha[i][1].y));\n\t//cross[i].push_back(Point(alpha[i][1].x, alpha[i][0].y));\n\tcross[i].x1 = alpha[i].x1, cross[i].y1 = alpha[i].y2;\n\tcross[i].x2 = alpha[i].x2, cross[i].y2 = alpha[i].y1;\n      }\n    }\n    \n    rep(i, H){\n      rep(j, W){\n\trep(k, 4){\n\t  int nx = j+dx[k], ny = i+dy[k];\n\t  if(nx < 0 || nx > W || ny < 0 || ny > H) continue;\n\t  if(field[i][j] == field[ny][nx]) found[field[i][j]-'A'] = false;\n\t}\n      }\n    }\n    \n    int ans = 0;\n    for(; ;){\n    Start:;\n      bool flag = false;\n      rep(i, 26){\n\tif(found[i]){\t  \t \n\t  int X1 = cross[i].x1, Y1 = cross[i].y1, X2 = cross[i].x2, Y2 = cross[i].y2;\n\t  int x1 = alpha[i].x1, y1 = alpha[i].y1, x2 = alpha[i].x2, y2 = alpha[i].y2;\n\t  char c = 'A'+i;\n\t  \n\t  if(x1 == x2){\n\t    flag = checkW(y1, y2, x1, c);\n\t  }\n\t  else if(y1 == y2){\n\t    flag = checkH(x1, x2, y1, c);\t    \n\t  }\n\t  else{\n\t    if(((checkH(X1, x2, Y1, c) && (checkW(Y1, y1, X1, c)))) ||\n\t       ((checkH(X2, x1, Y2, c) && (checkW(Y2, y2, X2, c))))){\n\t      flag = true;\n\t    }\n\t  }\n\t  \n\t  if(flag){\n\t    //cout << c << endl;\n\t    found[i] = false;\n\t    ans += 2;\n\t    field[y1][x1] = '.', field[y2][x2] = '.';\t    \n\t    goto Start;\n\t  }\n\t  \n\t}\n      }\n      if(!flag) break;\n    }\n    cout << ans << endl;\n  }  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <map>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define LINE() cerr<< \" (L\" << __LINE__ << \")\"\n\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nint main() {\n\t\tint H,W;cin >>H >> W;\n\n\t\tvector<string> board(H);\n\t\tfor(int y=0;y<H;y++){\n\t\t\tcin >> board[y];\n\t\t}\n\n\t\tmap<int,int> xmap,ymap;\n\t\tfor(int y=0;y<H;y++){\n\t\t\tfor(int x=0;x<W;x++){\n\t\t\t\tif(board[y][x]!='.'){\n\t\t\t\t\txmap.insert(make_pair(x,1));\n\t\t\t\t\tif(0<x-1 && x-1 <W)xmap.insert(make_pair(x-1,1));\n\t\t\t\t\tif(0<x+1 && x+1 <W)xmap.insert(make_pair(x+1,1));\n\n\t\t\t\t\tymap.insert(make_pair(y,1));\n\t\t\t\t\tif(0<y-1 && y-1 <W)xmap.insert(make_pair(y-1,1));\n\t\t\t\t\tif(0<y+1 && y+1 <W)xmap.insert(make_pair(y+1,1));\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> xs,ys;\n\t\tfor(auto it=xmap.begin();it!=xmap.end();it++){\n\t\t\txs.push_back(it->first);\n\t\t}\n\t\tfor(auto it=ymap.begin();it!=ymap.end();it++){\n\t\t\tys.push_back(it->first);\n\t\t}\n\t\tsort(xs.begin(),xs.end());\n\t\tsort(ys.begin(),ys.end());\n\n\t\tint h=ys.size(),w=xs.size();\n\t\tint res=0;\n\t\tfor(int c=0;c<30;c++){\n\t\t\tfor(int y=0;y<h;y++)for(int x=0;x<w;x++)if(board[ys[y]][xs[x]]=='.'){\n\t\t\t\tmap<char,vector<pair<int,int>>> ps;\n\t\t\t\tfor(int d=0;d<4;d++){\n\t\t\t\t\tint px=x,py=y;\n\t\t\t\t\twhile( 0<= px && px < w && 0 <=py && py < h  &&   board[ys[py]][xs[px]]=='.'){\n\t\t\t\t\t\tpx+=dx[d];py+=dy[d];\n\t\t\t\t\t}\n\t\t\t\t\tif( 0<= px && px < w && 0 <=py && py < h  && board[ys[py]][xs[px]]!='.'){\n\t\t\t\t\t\tps[board[ys[py]][xs[px]]].push_back(make_pair(py,px));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor(auto it=ps.begin();it!=ps.end();it++){\n\t\t\t\t\tvector<pair<int,int>> vs=it->second;\n\t\t\t\t\tif(it->second.size()==2){\n\t\t\t\t\t\tres+=2;\n\t\t\t\t\t\tboard[ys[vs[0].first]][xs[vs[0].second]]='.';\n\t\t\t\t\t\tboard[ys[vs[1].first]][xs[vs[1].second]]='.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << res <<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint m,n;\nvector<P> dat[100];\nvector<int> xind;\nvector<int> yind;\nint field[280][280];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint pickl[4];\nint picklx[4];\nint pickly[4];\n\nint main(void){\n\tscanf(\"%d %d\",&n,&m);\n\tmemset(field,0,sizeof(field));\n\tfor(int i=0;i<n;i++){\n\t\tstring str;\n\t\tcin >> str;\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(str[j]>='A' && str[j]<='Z'){\n\t\t\t\tdat[str[j]-'A'+1].push_back(P(j,i));\n\t\t\t\tif(j-1>=0)xind.push_back(j-1);\n\t\t\t\txind.push_back(j);\n\t\t\t\tif(j+1<m)xind.push_back(j+1);\n\t\t\t\tif(i-1>=0)yind.push_back(i-1);\n\t\t\t\tyind.push_back(i);\n\t\t\t\tif(i+1<n)yind.push_back(i+1);\n\t\t\t}\n\t\t}\n\t}\n\tsort(xind.begin(),xind.end());\n\txind.erase(unique(xind.begin(),xind.end()),xind.end());\n\tsort(yind.begin(),yind.end());\n\tyind.erase(unique(yind.begin(),yind.end()),yind.end());\n\tfor(int i=1;i<=26;i++){\n\t\tfor(int j=0;j<dat[i].size();j++){\n\t\t\tdat[i][j].first=lower_bound(xind.begin(),xind.end(),dat[i][j].first)-xind.begin();\n\t\t\tdat[i][j].second=lower_bound(yind.begin(),yind.end(),dat[i][j].second)-yind.begin();\n\t\t\tfield[dat[i][j].first][dat[i][j].second]=i;\n\t\t}\n\t}\n\tbool flag=true;\n\tint score2=0;\n\twhile(flag){\n\t\tflag=false;\n\t\tfor(int i=0;i<yind.size();i++){\n\t\t\tfor(int j=0;j<xind.size();j++){\n\t\t\t\tif(field[j][i]==0){\n\t\t\t\t\tmemset(pickl,0,sizeof(pickl));\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tint xx=j,yy=i;\n\t\t\t\t\t\tint xi=xind.size(),yi=yind.size();\n\t\t\t\t\t\twhile(xx>=0 && xx<=xi && yy>=0 && yy<=yi){\n\t\t\t\t\t\t\tif(field[xx][yy]!=0){\n\t\t\t\t\t\t\t\tpickl[k]=field[xx][yy];\n\t\t\t\t\t\t\t\tpicklx[k]=xx;\n\t\t\t\t\t\t\t\tpickly[k]=yy;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\txx+=dx[k];\n\t\t\t\t\t\t\tyy+=dy[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tfor(int l=k+1;l<4;l++){\n\t\t\t\t\t\t\tif(pickl[k]==pickl[l] && pickl[k]!=0){\n\t\t\t\t\t\t\t\tscore2+=2;\n\t\t\t\t\t\t\t\tfield[picklx[k]][pickly[k]]=0;\n\t\t\t\t\t\t\t\tfield[picklx[l]][pickly[l]]=0;\n\t\t\t\t\t\t\t\tflag=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",score2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cctype>\n#include <vector>\n#include <set>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0 ; i < n ; i++)\n\nstruct Point{\n  int x1, y1, x2, y2;\n};\n\nconst int MAX = 510;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nchar field[MAX][MAX];\nbool found[26];\nPoint alpha[26];\n\nint H, W;\n\nbool canReach_x(char C, int x, int y1, int y2){\n  if(y1 > y2) swap(y1, y2);\n  for(int i = y1 ; i <= y2 ; i++){\n    if(field[i][x] != '.' && field[i][x] != C) return false;\n  }\n  return true;\n}\n\nbool canReach_y(char C, int y, int x1, int x2){\n  if(x1 > x2) swap(x1, x2);\n  for(int j = x1 ; j <= x2 ; j++){\n    if(field[y][j] != '.' && field[y][j] != C) return false;\n  }\n  return true;\n}\n\nbool canReach(char C, int cx, int cy, int x, int y){\n  if(cx == x){\n    if(!canReach_x(C, x, cy, y)) return false;\n  }\n  \n  else if(cx < x){\n    for(int j = x ; j >= cx ; j--){\n      if(field[y][j] != '.' && field[y][j] != C) return false;\n    }\n\n  }\n  \n  else if(cx > x){\n    for(int j = x ; j <= cx ; j++){\n      if(field[y][j] != '.' && field[y][j] != C) return false;\n    }\n\n  }\n\n  if(cy == y){\n    if(!canReach_y(C, y, cx, x)) return false;\n  }\n  \n  else if(cy < y){\n    for(int i = y ; i >= cy ; i--){\n      if(field[i][x] != '.' && field[i][x] != C) return false;\n    }\n\n  }\n  else if(cy > y){\n    for(int i = y ; i <= y ; i++){\n      if(field[i][x] != '.' && field[i][x] != C) return false;\n    }\n\n  }\n\n  return true;\n}\n\nint main(){\n  while(cin >> H >> W){\n    rep(i, H) cin >> field[i];\n    memset(alpha, 0, sizeof(alpha));\n    memset(found, 0, sizeof(found));\n    \n    rep(i, H){\n      rep(j, W){\n\tif(isalpha(field[i][j])){\n\t  int c = field[i][j]-'A';\n\t  if(!found[c]){\n\t    found[c] = true;\n\t    alpha[c].x1 = j, alpha[c].y1 = i;\n\t  }\n\t  else{\n\t    alpha[c].x2 = j, alpha[c].y2 = i;\n\t  }\t\n\t}\n      }\n    }\n    \n    Point cross[26];\n    rep(i, 26){\n      if(found[i]){\n\tcross[i].x1 = alpha[i].x1, cross[i].y1 = alpha[i].y2;\n\tcross[i].x2 = alpha[i].x2, cross[i].y2 = alpha[i].y1;\n      }\n    }\n    \n    int ans = 0;\n    \n    rep(i, H){\n      rep(j, W){\n\trep(k, 4){\n\t  int nx = j+dx[k], ny = i+dy[k];\n\t  if(nx < 0 || nx > W || ny < 0 || ny > H) continue;\n\t  if(field[i][j] == field[ny][nx]) found[field[i][j]-'A'] = false;\n\t}\n      }\n    }\n\t\n    \n    for(; ;){\n      bool flag = false;\n      rep(i, 26){\n\tif(found[i]){\n\t  int x1 = alpha[i].x1, y1 = alpha[i].y1, x2 = alpha[i].x2, y2 = alpha[i].y2;\n\t  \n\t  if(x1 == x2){\n\t    if(canReach_x('A'+i, x1, y1, y2)){\n\t      field[y1][x1] = field[y2][x2] = '.';\n\t      found[i] = false;\n\t      ans += 2;\n\t      flag = true;\n\t    }\n\t  }\n\t  else if(y1 == y2){\n\t    if(canReach_y('A'+i, y1, x1, x2)){\n\t      field[y1][x1] = field[y2][x2] = '.';\n\t      found[i] = false;\n\t      ans += 2;\n\t      flag = true;\n\t    }\n\t  }\t      \t    \t  \t  \n\t  else if(((canReach('A'+i, cross[i].x1, cross[i].y1, x1, y1) &&\n\t\t    canReach('A'+i, cross[i].x1, cross[i].y1, x2, y2))) ||\n\t\t  ((canReach('A'+i, cross[i].x2, cross[i].y2, x1, y1) &&\n\t\t    canReach('A'+i, cross[i].x2, cross[i].y2, x2, y2)))){\n\t    \n\t    field[y1][x1] = field[y2][x2] = '.';\n\t    found[i] = false;\n\t    ans += 2;\n\t    flag = true;\n\t  }\n\t}\n      }\n      if(!flag) break;\n    }\n    \n    cout << ans << endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define x first\n#define y second\nusing namespace std;\ntypedef pair <int,int> P;\nstring mp[501];\nint m,n,used[30];\nvector <P>  a[30];\n\nint saiki(int);\n\nbool check_x(int y,int x1,int x2){\n    for(int i=x1+1;i<x2;i++)\n    if(mp[y][i]!='.'&&!saiki(mp[y][i]-'A'))return 0;\n  return 1;\n}\n\nbool check_y(int y1,int y2,int x){\n    for(int i=y1+1;i<y2;i++)\n    if(mp[i][x]!='.'&&!saiki(mp[i][x]-'A')) return 0;\n    return 1;\n}\n\nvoid out(){\n  //  for(int i=0;i<m;i++)cout<<mp[i]<<endl;\n\n}\n\n\nint saiki(int ch){  \n  int x1=a[ch][0].x,x2=a[ch][1].x;\n  int y1=a[ch][0].y,y2=a[ch][1].y;\n  int res=0;\n  if(used[ch]||mp[y1][x1]=='.')return 0;\n  used[ch]=1;\n  \n  if(x1==x2&&y2-y1!=1) res=check_y(y1,y2,x1);\n  if(y1==y2&&x2-x1!=1) res=check_x(y1,x1,x2);\n  if(x1!=x2&&y1!=y2) {\n    if(x1<x2){\n    res=check_x(y1,x1,x2+1)&check_y(y1,y2,x2);\n    res|=check_y(y1,y2+1,x1)&check_x(y2,x1,x2);\n    }\n    else{\n      swap(x1,x2);\n      res=check_x(y1,x1-1,x2)&check_y(y1,y2,x1);\n      res |=check_y(y1,y2,x2)&check_x(y2,x1,x2+1);\n      swap(x1,x2);\n    }\n  }\n    \n\n  if(res) mp[y1][x1]=mp[y2][x2]='.';\n  used[ch]=0;\n  return res;\n}\n\nint main(){\n\n  cin>>m>>n;\n  for(int i=0;i<m;i++)cin>>mp[i];\n  for(int i=0;i<m;i++) a[i].clear();\n  for(int i=0;i<30;i++) used[i]=0;\n  \n  int ans=0;  \n  for(int i=0;i<m;i++)\n    for(int j=0;j<n;j++)\n      if(mp[i][j]!='.')a[mp[i][j]-'A'].push_back(P(j,i)),ans++;\n  \n  int flg=1;\n  while(flg){\n    flg=0;\n    for(int i=0;i<30;i++)if(a[i].size() && saiki(i)) a[i].clear(),flg=1;\n}\n  for(int i=0;i<m;i++)\n    for(int j=0;j<n;j++) if(mp[i][j]!='.') ans--;\n\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\nusing namespace std;\n\nint M, N;\nchar S[550][550];\nvector<int> Y[256], X[256];\nbool E[256][256];\nbool b[256];\n\nvoid dfs(int v) {\n  if(!b[v]) return;\n  b[v] = false;\n  REP(i, 'A', 'Z' + 1) if(E[v][i]) dfs(i);\n}\n\nint main(void) {\n  cin >> M >> N;\n  REP(i, 0, M) cin >> S[i];\n\n  REP(i, 0, M) REP(j, 0, N) if(S[i][j] != '.') {\n    Y[S[i][j]].push_back(i);\n    X[S[i][j]].push_back(j);\n  }\n\n  REP(i, 0, 256) REP(j, 0, 256) E[i][j] = false;\n\n  REP(i, 'A', 'Z' + 1) {\n    if(Y[i].size() == 0) continue;\n    int x1 = X[i][0], x2 = X[i][1];\n    int y1 = Y[i][0], y2 = Y[i][1];\n    if(x1 == x2) {\n      REP(j, min(x1, x2), max(x1, x2) + 1) {\n        if(S[y1][j] != '.') E[i][S[y1][j]] = true;\n      }\n    } else if(Y[i][0] == Y[i][1]) {\n      REP(j, min(y1, y2), max(y1, y2) + 1) {\n        if(S[j][x1] != '.') E[i][S[j][x1]] = true;\n      }\n    } else {\n      if(S[y1][x2] != '.' && S[y1][x2] == S[y2][x1]) E[i][S[y1][x2]] = true;\n    }\n  }\n\n  vector<int> fi;\n  REP(i, 'A', 'Z' + 1) {\n    if(Y[i].size() == 0) continue;\n    int x1 = X[i][0], x2 = X[i][1];\n    int y1 = Y[i][0], y2 = Y[i][1];\n    if(x1 == x2 && abs(y1 - y2) == 1) fi.push_back(i);\n    if(y1 == y2 && abs(x1 - x2) == 1) fi.push_back(i);\n  }\n  REP(i, 'A', 'Z' + 1) REP(j, i + 1, 'Z' + 1) if(i != j) {\n    if(E[i][j] && E[j][i]) {\n      fi.push_back(i);\n      fi.push_back(j);\n    }\n  }\n\n  REP(i, 'A', 'Z' + 1) if(Y[i].size() > 0) b[i] = true;\n  REP(i, 0, fi.size()) dfs(fi[i]);\n\n  int ans = 0;\n  REP(i, 'A', 'Z' + 1) if(b[i]) ans += 2;\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mk make_pair\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nstring s[500];\nint h,w,sum=0;\nvector<int>x,y;\nvoid del(int t1,int t2){\n  vector<pair<char,pair<int,int> > >p;\n  for(int i=t1;i<h;i++)if(s[i][t2]!='.'){\n    p.push_back(mk(s[i][t2],mk(i,t2)));\n    break;\n  }\n  for(int i=t1;i>=0;i--)if(s[i][t2]!='.'){\n    p.push_back(mk(s[i][t2],mk(i,t2)));\n    break;\n  }\n  for(int i=t2;i<w;i++)if(s[t1][i]!='.'){\n    p.push_back(mk(s[t1][i],mk(t1,i)));\n    break;\n  }\n  for(int i=t2;i>=0;i--)if(s[t1][i]!='.'){\n    p.push_back(mk(s[t1][i],mk(t1,i)));\n    break;\n  }\n  sort(p.begin(),p.end());\n  if(p.size()>=2){\n    r(i,p.size()-1){\n      if(p[i].first==p[i+1].first){\n        sum++;\n        s[p[i].second.first][p[i].second.second]='.';\n        s[p[i+1].second.first][p[i+1].second.second]='.';\n      }\n    }\n  }\n}\nint main(){\n  cin>>h>>w;\n  r(i,h)cin>>s[i];\n  r(i,h)r(j,w)if(s[i][j]!='.'){\n      y.push_back(i),x.push_back(j);\n      if(i+1<h)y.push_back(i+1);\n      if(j+1<w)x.push_back(j+1);\n    }\n  r(k,26)r(i,y.size())r(j,x.size())\n    if(s[y[i]][x[j]]=='.')del(y[i],x[j]);\n  cout<<sum*2<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nstruct P{ int x,y; };\n\nchar g[500][501];\n\nbool checkH(int x1,int x2,int y,char c){\n\tfor(int x=x1;x<=x2;x++) if(g[y][x]!='.' && g[y][x]!=c) return false;\n\treturn true;\n}\n\nbool checkV(int y1,int y2,int x,char c){\n\tfor(int y=y1;y<=y2;y++) if(g[y][x]!='.' && g[y][x]!=c) return false;\n\treturn true;\n}\n\nint main(){\n\tint m,n; scanf(\"%d%d\",&m,&n);\n\tvector<P> pos[26];\n\trep(i,m){\n\t\tscanf(\"%s\",g[i]);\n\t\trep(j,n) if(g[i][j]!='.') {\n\t\t\t pos[g[i][j]-'A'].push_back((P){j,i});\n\t\t}\n\t}\n\n\tint ans=0;\n\twhile(1){\n\t\tbool change=false;\n\n\t\trep(i,26) if(pos[i].size()==2) {\n\t\t\tP p=pos[i][0],q=pos[i][1];\n\n\t\t\tbool ok=false;\n\t\t\tif(p.x!=q.x && p.y!=q.y){\n\t\t\t\tif(checkH(min(p.x,q.x),max(p.x,q.x),p.y,'A'+i)\n\t\t\t\t&& checkV(min(p.y,q.y),max(p.y,q.y),q.x,'A'+i)\n\t\t\t\t|| checkH(min(p.x,q.x),max(p.x,q.x),q.y,'A'+i)\n\t\t\t\t&& checkV(min(p.y,q.y),max(p.y,q.y),p.x,'A'+i)) ok=true;\n\t\t\t}\n\t\t\telse if(p.y==q.y){\n\t\t\t\tint mn=min(p.x,q.x),mx=max(p.x,q.x);\n\t\t\t\tif(mx-mn>1 && checkH(mn,mx,p.y,'A'+i)) ok=true;\n\t\t\t}\n\t\t\telse{ // p.x==q.x\n\t\t\t\tint mn=min(p.y,q.y),mx=max(p.y,q.y);\n\t\t\t\tif(mx-mn>1 && checkV(mn,mx,p.x,'A'+i)) ok=true;\n\t\t\t}\n\n\t\t\tif(ok){\n\t\t\t\tg[p.y][p.x]=g[q.y][q.x]='.';\n\t\t\t\tpos[i].erase(pos[i].begin(),pos[i].end());\n\t\t\t\tans+=2;\n\t\t\t\tchange=true;\n\t\t\t}\n\t\t}\n\n\t\tif(!change) break;\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<VV> VVV;\ntypedef vector<vector<int>> Graph;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\nenum { X, Y, CHAR };\ntypedef vector<int> Tile;\n\nint H, W;\nvector<string> s;\n\n// N, E, S, W\nconst int dx[4] = {-1, 0,  1,  0};\nconst int dy[4] = { 0, 1,  0, -1};\n\ninline bool inside(int x, int y) {\n    return 0 <= x && x < H && 0 <= y && y < W;\n}\n\nTile findNearestTile(int x, int y, int k) {\n    if (!inside(x, y)) return Tile{-1, -1, -1};\n    if (isalpha(s[x][y])) return Tile{x, y, s[x][y] - 'A'};\n    return findNearestTile(x + dx[k], y + dy[k], k);\n}\n\nbool hit(int sx, int sy) {\n    if (s[sx][sy] == '#') return false;\n    if (isalpha(s[sx][sy])) {\n        rep(k, 4) {\n            int nx = sx + dx[k], ny = sy + dy[k];\n            if (!inside(nx, ny)) continue;\n            if (s[sx][sy] == s[nx][ny]) {\n                // cerr << \"hey!\" << endl;\n                // cerr << sx << \" \" << sy << \" \" << nx << \" \" << ny << endl;\n                s[sx][sy] = '.';\n                s[nx][ny] = '.';\n                return true;\n            }\n        }\n        return false;\n    }\n\n    // cout << \"hit: \" << sx << \" \" << sy << endl;\n    rep(start, 4) {\n        Tile tile1{-1, -1, -1};\n        rep(k, 4) {\n            // cout << start << \" \" << k << endl;\n            Tile tile2 = findNearestTile(sx, sy, (k + start) % 4);\n            if (tile2[CHAR] == -1) {\n                continue;\n            } else if (tile1[CHAR] == -1) {\n                tile1 = tile2;\n            } else if (tile1[CHAR] == tile2[CHAR]) {\n                // cout << sx << \" \" << sy << endl;\n                // cout << start << \" \" << k << endl;\n                // cout << tile1[X] << \" \" << tile1[Y] << \" \" << tile1[CHAR] << endl;\n                // cout << tile2[X] << \" \" << tile2[Y] << \" \" << tile2[CHAR] << endl;\n                s[tile1[X]][tile1[Y]] = '.';\n                s[tile2[X]][tile2[Y]] = '.';\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nbool search() {\n    rep(i, H) {\n        rep(j, W) {\n            if (hit(i, j)) {\n                // cout << \"hit\" << endl;\n                // cout << i << \" \" << j << endl;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nbool checkCompress(string line) {\n    for (const auto& c : line) {\n        if (c != '.') return false;\n    }\n    return true;\n}\n\nvoid compress(vector<string> &s) {\n    for (int i = 0; i < s.size(); ) {\n        if (checkCompress(s[i])) {\n            s.erase(s.begin() + i);\n        } else {\n            i++;\n        }\n    }\n}\n\nvoid rot(vector<string> &s) {\n    vector<string> t(s[0].size(), \"\");\n    rep(i, s.size()) rep(j, s[0].size()) {\n        t[j] += s[i][j];\n    }\n    s = t;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    cin >> H >> W;\n    s.resize(H);\n    rep(i, H) cin >> s[i];\n\n    rep(x, H) {\n        rep(y, W) {\n            rep(k, 4) {\n                int nx = x + dx[k], ny = y + dy[k];\n                if (!inside(nx, ny)) continue;\n                if (isalpha(s[x][y]) && s[x][y] == s[nx][ny]) {\n                    s[x][y] = '#';\n                    s[nx][ny] = '#';\n                }\n            }\n        }\n    }\n\n    compress(s);\n    // for (auto line : s) cout << line << endl;\n    // cout << endl;\n\n    if (s.empty()) {\n        cout << 0 << endl;\n        return 0;\n    }\n    rot(s);\n    // // for (auto line : s) cout << line << endl;\n    // // cout << endl;\n    compress(s);\n    // // for (auto line : s) cout << line << endl;\n    // // cout << endl;\n    rot(s);\n    // // for (auto line : s) cout << line << endl;\n    // // cout << endl;\n\n    H = s.size(), W = s[0].size();\n\n    int ans = 0;\n    while (search()) {\n        ans += 2;\n\n        // cout << ans << endl;\n        // rep(i, H) {\n        //     cout << s[i] << endl;\n        // }\n        // cout << endl;\n    }\n\n    cout << ans << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nint H,W;\n\nstruct Info{\n\tInfo(){\n\t\trow = col = 0;\n\t\texist = false;\n\t}\n\tInfo(int arg_row,int arg_col,bool arg_exist){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\texist = arg_exist;\n\t}\n\n\tvoid set(int arg_row,int arg_col,bool arg_exist){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\texist = arg_exist;\n\t}\n\tint row,col;\n\tbool exist;\n};\n\nint main(){\n\n\tscanf(\"%d %d\",&H,&W);\n\tchar map[H][W+1];\n\n\tInfo info[26][2];\n\tfor(int i = 0; i < 26; i++){\n\t\tfor(int k = 0; k < 2; k++){\n\t\t\tinfo[i][k].exist = false;\n\t\t}\n\t}\n\n\tvector<Info> V_ROW[500],V_COL[500];\n\tint maximum = 0;\n\n\tfor(int i = 0; i < H; i++){\n\t\tscanf(\"%s\",map[i]);\n\t\tfor(int k = 0; k < W; k++){\n\t\t\tswitch(map[i][k]){\n\t\t\tcase '.':\n\t\t\t\tV_ROW[i].push_back(Info(i,k,false));\n\t\t\t\tV_COL[i].push_back(Info(i,k,false));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif(info[map[i][k]-'A'][0].exist == false){\n\t\t\t\t\tinfo[map[i][k]-'A'][0].exist = true;\n\t\t\t\t\tinfo[map[i][k]-'A'][0].set(i,k,true);\n\t\t\t\t\tmaximum++;\n\t\t\t\t}else{\n\t\t\t\t\tinfo[map[i][k]-'A'][1].set(i,k,true);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0,common_row,common_col,small,big;\n\tbool FLG,erasableFLG;\n\n\twhile(true){\n\n\t\tFLG = false;\n\n\t\tfor(int i = 0; i < 26; i++){\n\t\t\tif(info[i][0].exist){\n\t\t\t\tif(info[i][0].row == info[i][1].row){\n\n\t\t\t\t\tcommon_row = info[i][0].row;\n\t\t\t\t\tif(info[i][0].col > info[i][1].col){\n\t\t\t\t\t\tsmall = info[i][1].col;\n\t\t\t\t\t\tbig = info[i][0].col;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsmall = info[i][0].col;\n\t\t\t\t\t\tbig = info[i][1].col;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int a = 0;a < V_ROW[common_row].size();a++){\n\t\t\t\t\t\tif(V_ROW[common_row][a].col > small && V_ROW[common_row][a].col < big){\n\n\t\t\t\t\t\t\terasableFLG = false;\n\n\t\t\t\t\t\t\tfor(int tmp_col = V_ROW[common_row][a].col; tmp_col >= 0 ;tmp_col--){\n\t\t\t\t\t\t\t\tif(map[common_row][tmp_col] != '.'){\n\t\t\t\t\t\t\t\t\tif(map[common_row][tmp_col] == 'A' + i){\n\t\t\t\t\t\t\t\t\t\terasableFLG = true;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!erasableFLG)continue;\n\n\t\t\t\t\t\t\terasableFLG = false;\n\n\t\t\t\t\t\t\tfor(int tmp_col = V_ROW[common_row][a].col; tmp_col <= W-1 ;tmp_col++){\n\t\t\t\t\t\t\t\tif(map[common_row][tmp_col] != '.'){\n\t\t\t\t\t\t\t\t\tif(map[common_row][tmp_col] == 'A' + i){\n\t\t\t\t\t\t\t\t\t\terasableFLG = true;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!erasableFLG)continue;\n\n\t\t\t\t\t\t\tmap[common_row][info[i][0].col] = '.';\n\t\t\t\t\t\t\tmap[common_row][info[i][1].col] = '.';\n\t\t\t\t\t\t\tV_ROW[common_row].push_back(Info(common_row,info[i][0].col,false));\n\t\t\t\t\t\t\tV_ROW[common_row].push_back(Info(common_row,info[i][1].col,false));\n\t\t\t\t\t\t\tV_COL[info[i][0].col].push_back(Info(common_row,info[i][0].col,false));\n\t\t\t\t\t\t\tV_COL[info[i][1].col].push_back(Info(common_row,info[i][1].col,false));\n\t\t\t\t\t\t\tinfo[i][0].exist = false;\n\t\t\t\t\t\t\tans += 2;\n\t\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}else if(info[i][0].col == info[i][1].col){\n\n\t\t\t\t\tcommon_col = info[i][0].col;\n\t\t\t\t\tif(info[i][0].row > info[i][1].row){\n\t\t\t\t\t\tsmall = info[i][1].row;\n\t\t\t\t\t\tbig = info[i][0].row;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsmall = info[i][0].row;\n\t\t\t\t\t\tbig = info[i][1].row;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int a = 0;a < V_COL[common_col].size();a++){\n\t\t\t\t\t\tif(V_COL[common_col][a].row > small && V_COL[common_col][a].row < big){\n\n\t\t\t\t\t\t\terasableFLG = false;\n\n\t\t\t\t\t\t\tfor(int tmp_row = V_COL[common_col][a].row; tmp_row >= 0 ;tmp_row--){\n\t\t\t\t\t\t\t\tif(map[tmp_row][common_col] != '.'){\n\t\t\t\t\t\t\t\t\tif(map[tmp_row][common_col] == 'A' + i){\n\t\t\t\t\t\t\t\t\t\terasableFLG = true;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!erasableFLG)continue;\n\n\t\t\t\t\t\t\terasableFLG = false;\n\n\t\t\t\t\t\t\tfor(int tmp_row = V_COL[common_col][a].row; tmp_row <= H-1 ;tmp_row++){\n\t\t\t\t\t\t\t\tif(map[tmp_row][common_col] != '.'){\n\t\t\t\t\t\t\t\t\tif(map[tmp_row][common_col] == 'A' + i){\n\t\t\t\t\t\t\t\t\t\terasableFLG = true;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!erasableFLG)continue;\n\n\t\t\t\t\t\t\tmap[info[i][0].row][common_col] = '.';\n\t\t\t\t\t\t\tmap[info[i][1].row][common_col] = '.';\n\t\t\t\t\t\t\tV_ROW[info[i][0].row].push_back(Info(info[i][0].row,common_col,false));\n\t\t\t\t\t\t\tV_ROW[info[i][1].row].push_back(Info(info[i][1].row,common_col,false));\n\t\t\t\t\t\t\tV_COL[common_col].push_back(Info(info[i][0].row,common_col,false));\n\t\t\t\t\t\t\tV_COL[common_col].push_back(Info(info[i][1].row,common_col,false));\n\t\t\t\t\t\t\tinfo[i][0].exist = false;\n\t\t\t\t\t\t\tans += 2;\n\t\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}else{\n\n\t\t\t\t\tif(map[info[i][0].row][info[i][1].col] == '.'){\n\n\t\t\t\t\t\terasableFLG = false;\n\n\t\t\t\t\t\tif(info[i][0].col > info[i][1].col){\n\n\t\t\t\t\t\t\tfor(int tmp_col = info[i][1].col+1; tmp_col <= W-1; tmp_col++){\n\t\t\t\t\t\t\t\tif(map[info[i][0].row][tmp_col] != '.'){\n\t\t\t\t\t\t\t\t\tif(map[info[i][0].row][tmp_col] == 'A' + i){\n\t\t\t\t\t\t\t\t\t\terasableFLG = true;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}else{\n\n\t\t\t\t\t\t\tfor(int tmp_col = info[i][1].col-1; tmp_col >= 0; tmp_col--){\n\t\t\t\t\t\t\t\tif(map[info[i][0].row][tmp_col] != '.'){\n\t\t\t\t\t\t\t\t\tif(map[info[i][0].row][tmp_col] == 'A' + i){\n\t\t\t\t\t\t\t\t\t\terasableFLG = true;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(erasableFLG){\n\t\t\t\t\t\t\terasableFLG = false;\n\n\t\t\t\t\t\t\tif(info[i][0].row > info[i][1].row){\n\n\t\t\t\t\t\t\t\tfor(int tmp_row = info[i][0].row-1; tmp_row >= 0; tmp_row--){\n\t\t\t\t\t\t\t\t\tif(map[tmp_row][info[i][1].col] != '.'){\n\t\t\t\t\t\t\t\t\t\tif(map[tmp_row][info[i][1].col] == 'A' + i){\n\t\t\t\t\t\t\t\t\t\t\terasableFLG = true;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}else{\n\n\t\t\t\t\t\t\t\tfor(int tmp_row = info[i][0].row+1; tmp_row <= H-1; tmp_row++){\n\t\t\t\t\t\t\t\t\tif(map[tmp_row][info[i][1].col] != '.'){\n\t\t\t\t\t\t\t\t\t\tif(map[tmp_row][info[i][1].col] == 'A' + i){\n\t\t\t\t\t\t\t\t\t\t\terasableFLG = true;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif(erasableFLG){\n\n\t\t\t\t\t\t\t\tmap[info[i][0].row][info[i][0].col] = '.';\n\t\t\t\t\t\t\t\tmap[info[i][1].row][info[i][1].col] = '.';\n\t\t\t\t\t\t\t\tV_ROW[info[i][0].row].push_back(Info(info[i][0].row,info[i][0].col,false));\n\t\t\t\t\t\t\t\tV_ROW[info[i][1].row].push_back(Info(info[i][1].row,info[i][1].col,false));\n\t\t\t\t\t\t\t\tV_COL[info[i][0].col].push_back(Info(info[i][0].row,info[i][0].col,false));\n\t\t\t\t\t\t\t\tV_COL[info[i][1].col].push_back(Info(info[i][1].row,info[i][1].col,false));\n\t\t\t\t\t\t\t\tinfo[i][0].exist = false;\n\t\t\t\t\t\t\t\tans += 2;\n\t\t\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(map[info[i][1].row][info[i][0].col] == '.'){\n\t\t\t\t\t\terasableFLG = false;\n\n\t\t\t\t\t\tif(info[i][1].col > info[i][0].col){\n\n\t\t\t\t\t\t\tfor(int tmp_col = info[i][0].col+1; tmp_col <= W-1; tmp_col++){\n\t\t\t\t\t\t\t\tif(map[info[i][1].row][tmp_col] != '.'){\n\t\t\t\t\t\t\t\t\tif(map[info[i][1].row][tmp_col] == 'A' + i){\n\t\t\t\t\t\t\t\t\t\terasableFLG = true;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!erasableFLG)continue;\n\n\t\t\t\t\t\t}else{\n\n\t\t\t\t\t\t\tfor(int tmp_col = info[i][0].col-1; tmp_col >= 0; tmp_col--){\n\t\t\t\t\t\t\t\tif(map[info[i][1].row][tmp_col] != '.'){\n\t\t\t\t\t\t\t\t\tif(map[info[i][1].row][tmp_col] == 'A' + i){\n\t\t\t\t\t\t\t\t\t\terasableFLG = true;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!erasableFLG)continue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\terasableFLG = false;\n\n\t\t\t\t\t\tif(info[i][1].row > info[i][0].row){\n\n\t\t\t\t\t\t\tfor(int tmp_row = info[i][1].row-1; tmp_row >= 0; tmp_row--){\n\t\t\t\t\t\t\t\tif(map[tmp_row][info[i][0].col] != '.'){\n\t\t\t\t\t\t\t\t\tif(map[tmp_row][info[i][0].col] == 'A' + i){\n\t\t\t\t\t\t\t\t\t\terasableFLG = true;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!erasableFLG)continue;\n\n\t\t\t\t\t\t}else{\n\n\t\t\t\t\t\t\tfor(int tmp_row = info[i][1].row+1; tmp_row <= H-1; tmp_row++){\n\t\t\t\t\t\t\t\tif(map[tmp_row][info[i][0].col] != '.'){\n\t\t\t\t\t\t\t\t\tif(map[tmp_row][info[i][0].col] == 'A' + i){\n\t\t\t\t\t\t\t\t\t\terasableFLG = true;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!erasableFLG)continue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmap[info[i][0].row][info[i][0].col] = '.';\n\t\t\t\t\t\tmap[info[i][1].row][info[i][1].col] = '.';\n\t\t\t\t\t\tV_ROW[info[i][0].row].push_back(Info(info[i][0].row,info[i][0].col,false));\n\t\t\t\t\t\tV_ROW[info[i][1].row].push_back(Info(info[i][1].row,info[i][1].col,false));\n\t\t\t\t\t\tV_COL[info[i][0].col].push_back(Info(info[i][0].row,info[i][0].col,false));\n\t\t\t\t\t\tV_COL[info[i][1].col].push_back(Info(info[i][1].row,info[i][1].col,false));\n\t\t\t\t\t\tinfo[i][0].exist = false;\n\t\t\t\t\t\tans += 2;\n\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(!FLG){\n\t\t\tbreak;\n\t\t}\n\t\tif(ans >= 2*maximum){\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vpii = vector<pii>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\nint dx[] = { 0,1,0,-1 };\nint dy[] = { 1,0,-1,0 };\nint main() {\n    int m, n;\n    cin >> m >> n;\n    vector<string> map(m);\n    for (auto &a : map)cin >> a;\n    bool f = 1;\n    int score = 0;\n    while (f) {\n        f = 0;\n        rep(i, m)rep(j, n) {\n            if (map[i][j] != '.')continue;\n            vector<pair<char,string::iterator>> buf;\n            rep(k, 4) {\n                int x = j, y = i;\n                while (x >= 0 && x < n&&y>=0 && y < m&&map[y][x] == '.')x += dx[k], y += dy[k];\n                if (x >= 0 && x < n&&y>=0 && y < m)buf.push_back(make_pair(map[y][x],map[y].begin()+x));\n            }\n            sort(ALL(buf), [](pair<char, string::iterator> a, pair<char, string::iterator> b) {return a.first < b.first; });\n            if (buf.size() < 2)continue;\n            rep1(i, buf.size()-1) {\n                if (buf[i].first == buf[i - 1].first) {\n                    *(buf[i].second) = *(buf[i - 1].second) = '.';\n                    score += 2;\n                    f = 1;\n                }\n            }\n        }\n    }\n    cout << score << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nstring s[505];\nint v;\nVI g[30];\nbool used[30];\nvector<int> ans;\n\nvoid dfs(int u) {\n  if(used[u]) return;\n  used[u] = true;\n  for(auto& i: g[u]) dfs(i);\n  // 帰りがけ順で追加\n  ans.push_back(u);\n}\n\nvoid tsort() {\n  for(int i=0; i<v; ++i) dfs(i);\n  reverse(ans.begin(), ans.end());\n}\n\nsigned main(void)\n{\n  int h, w;\n  cin >> h >> w;\n  REP(i, h) cin >> s[i];\n\n  vector<PII> p[30];\n  REP(i, h) REP(j, w) {\n    if(s[i][j] != '.') p[s[i][j]-'A'].PB({i, j});\n  }\n\n  int ret = 0;\n  bool update = true;\n  while(update) {\n    update = false;\n    REP(i, 26) {\n      if(p[i].size() == 0) continue;\n      int l = min(p[i][0].second, p[i][1].second),\n          r = max(p[i][0].second, p[i][1].second);\n      int u = min(p[i][0].first, p[i][1].first),\n          d = max(p[i][0].first, p[i][1].first);\n      // cout << char(i+'A') << \" \" << l << \" \" << r << \" \" << u << \" \" << d << endl;\n      if((l+1==r && u==d) || (l==r && u+1==d)) continue;\n\n      if((l == p[i][0].second && u == p[i][0].first) || (l == p[i][1].second && u == p[i][1].first)) {\n        // cout << \"a\" << endl;\n        bool flag = true;\n        FOR(y, u+1, d) if(s[y][l] != '.') flag = false;\n        FOR(x, l, r) if(s[d][x] != '.') flag = false;\n        if(flag) {\n          s[p[i][0].first][p[i][0].second] = '.';\n          s[p[i][1].first][p[i][1].second] = '.';\n          p[i].clear();\n          ret += 2;\n          update = true;\n          continue;\n        }\n\n        flag = true;\n        FOR(y, u, d) if(s[y][r] != '.') flag = false;\n        FOR(x, l+1, r) if(s[u][x] != '.') flag = false;\n        if(flag) {\n          s[p[i][0].first][p[i][0].second] = '.';\n          s[p[i][1].first][p[i][1].second] = '.';\n          p[i].clear();\n          ret += 2;\n          update = true;\n        }\n      } else {\n        // cout << \"b\" << endl;\n        bool flag = true;\n        FOR(y, u+1, d) if(s[y][l] != '.') flag = false;\n        FOR(x, l, r) if(s[u][x] != '.') flag = false;\n        if(flag) {\n          s[p[i][0].first][p[i][0].second] = '.';\n          s[p[i][1].first][p[i][1].second] = '.';\n          p[i].clear();\n          ret += 2;\n          update = true;\n          continue;\n        }\n\n        flag = true;\n        FOR(y, u+1, d+1) if(s[y][r] != '.') flag = false;\n        FOR(x, l+1, r) if(s[d][x] != '.') flag = false;\n        if(flag) {\n          s[p[i][0].first][p[i][0].second] = '.';\n          s[p[i][1].first][p[i][1].second] = '.';\n          p[i].clear();\n          ret += 2;\n          update = true;\n        }\n      }\n    }\n    // REP(y, h) cout << s[y] << endl;\n    // cout << endl;\n  }\n  cout << ret << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "                                        #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                                #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppa pair<string,int>\n                                        #define ppap pair<int,pa>\n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-12)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\n                                  #define VI vector<int>\n                                        using namespace std;\n                                        \n                                  class pas{\n                                    \tpublic:\n                                    \tint x,y;\n                                    \tpas(int x=0,int y=0):x(x),y(y) {}\n                                    \tpas operator + (pas p) {return pas(x+p.x,y+p.y);}\n                                    \tpas operator - (pas p) {return pas(x-p.x,y-p.y);}\n                                    \tpas operator * (int a) {return pas(x*a,y*a);}\n                                    \tpas operator / (int a) {return pas(x/a,y/a);}\n                                    //\tdouble absv() {return sqrt(norm());}\n                                    \tint norm() {return x*x+y*y;}\n                                    \tbool operator < (const pas &p) const{\n                                   \t\treturn x != p.x ? x<p.x: y<p.y;\n                                   \t}\n                                  //\t\tbool operator < (const pas &p) const{\n                                    //\t\treturn y != p.y ? y<p.y: x<p.x;\n                                    //\t}\n                                    \tbool operator == (const pas &p) const{\n                                    \t\treturn x==p.x && y==p.y;\n                                    \t}\n                                    };\n\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                        \nstruct star{\nSegment se[5];\n};\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(b.p1),(b.p2))&&parareru((a.p2),(a.p1),(b.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n            double segment_len(Segment a){\n            \t\n            \treturn (a.p1-a.p2).absv();\n            }\n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n\t\t\tpair<Point,Point> circle_intersection(Point c1,double r1,Point c2,double r2){\n\t\t\t\tdouble d=(c1-c2).absv();\n\t\t\t\tdouble h=(r1*r1-r2*r2+d*d)/2.0/d;\n\t\t\t\tdouble l=sqrt(r1*r1-h*h);\n\t\t\t//\tcout<<d<<\" \"<<h<<\" \"<<l<<endl;\n\t\t\t\tPoint asi=c1+(c2-c1)*h/((c2-c1).absv());\n\t\t\t\tVector r1r2=(c2-c1)/((c2-c1).absv());\n\t\t\t\tVector sui={r1r2.y,-r1r2.x};\n\t\t\t//\tcout<<sui.x<<\" \"<<sui.y<<endl;\n\t\t\t\tpair<Point,Point> z=mp(asi+sui*l,asi-sui*l);\n\t\t\t\tif(z.first.x>z.second.x) swap(z.first,z.second);\n\t\t\t\treturn z;\n\t\t\t}\n\nint gcd(int x,int y){\n\tif(x<y) return gcd(y,x);\n\tif(x==y) return x;\n\tif(x%y==0) return y;\n\treturn gcd(y,x%y);\n}\n class pa2{\n                                            public:\n                                            int x,y;\n                                            pa2(int x=0,int y=0):x(x),y(y) {}\n                                            pa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            pa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            bool operator < (const pa2 &p) const{\n                                                return x != p.x ? x<p.x: y<p.y;\n                                            }\n\t\t\t\t\t\t\t\t\t\t \t bool operator > (const pa2 &p) const{\n                                                return x != p.x ? x>p.x: y>p.y;\n                                            }\n                                            bool operator == (const pa2 &p) const{\n                                                return abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            }\n                                            bool operator != (const pa2 &p) const{\n                                                return !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            }\n                                                 \n                                         \n                                        };\n\n/*　　　---memo---\nadd_edge(始点,終点,youryou ,コスト)で枝追加\nmin_cost_flow(始点,終点,ryou)でhiyouをintで返す\n*/\nint a[600][600]={0};\nvector<pa> ve[30],ve2[30];\n\nbool ch(pa r1,pa r2){\n\tif(r1.first==r2.first){\n\t\tif(abs(r1.second-r2.second)==1) return false;\n\t\tint r3=min(r1.second,r2.second),r4=max(r1.second,r2.second);\n\t\tbool bo=true;\n\t\tfor(int k=r3+1;k<r4;k++)if(a[r1.first][k]>=0) return false;\n\t\t\n\t\treturn true;\n\t}\n\t\n\tif(r1.second==r2.second){\n\t//\tcout<<\"e\"<<endl;\n\t\tif(abs(r1.first-r2.first)==1) return false;\n\t\tint r3=min(r1.first,r2.first),r4=max(r1.first,r2.first);\n\t\tbool bo=true;\n\t\tfor(int k=r3+1;k<r4;k++)if(a[k][r1.second]>=0) return false;\n\t\t\n\t\treturn true;\n\t}\n\t\n\tif(r1.second>r2.second) swap(r1,r2);\n\tif(r2.first>r1.first){\n\t\tbool bo=true;\n\t\t\n\t\tfor(int k=r1.second+1;k<=r2.second;k++)if(a[r1.first][k]>=0) bo=false;\n\t\tfor(int k=r1.first;k<r2.first;k++)if(a[k][r2.second]>=0)bo=false;\n\t\tif(bo) return true;\n\t\tbo=true;\n\t\t\n\t\tfor(int k=r1.second;k<r2.second;k++)if(a[r2.first][k]>=0) bo=false;\n\t\tfor(int k=r1.first+1;k<=r2.first;k++)if(a[k][r1.second]>=0)bo=false;\n\t\tif(bo) return true;\n\t\treturn false;\n\t}\n\telse{\n\t\tbool bo=true;\n\t\t\n\t\tfor(int k=r1.first-1;k>=r2.first;k--)if(a[k][r1.second]>=0) bo=false;\n\t\tfor(int k=r1.second;k<r2.second;k++)if(a[r2.first][k]>=0)bo=false;\n\t\tif(bo) return true;\n\t\tbo=true;\n\t\t\n\t\tfor(int k=r1.second+1;k<=r2.second;k++)if(a[r1.first][k]>=0) bo=false;\n\t\tfor(int k=r2.first+1;k<=r1.first;k++)if(a[k][r2.second]>=0)bo=false;\n\t\tif(bo) return true;\n\t\treturn false;\n\t\t\n\t}\n}\n\n\n     signed main(){\nint h,w;\n     \tcin>>h>>w;\n     \tfor(int i=0;i<600;i++)for(int j=0;j<600;j++)a[i][j]=-1;\n     \t\n     \tfor(int i=0;i<h;i++){\n     \t\tstring s;\n     \t\tcin>>s;\n     \t\tfor(int j=0;j<w;j++){\n     \t\t\tif(s[j]=='.') continue;\n     \t\t\ta[i][j]=1;\n     \t\t\tve[s[j]-'A'].pb(mp(i,j));\n     \t\t}\n     \t}\n     \tint ans=0;\n     //\t\tcout<<\"r\"<<endl;\n     \tfor(int i=0;i<26;i++){\n     \t\tif(ve[i].size()==0) continue;\n     \t\t\n     \t\t\n     \t\t\n     \t\t\n     \t}\n     //\tcout<<\"r\"<<endl;\n     \tfor(int cn=0;cn<=100;cn++){\n     \t\tfor(int i=0;i<26;i++)if(ve[i].size()>0){\n     \t\t\tif(ch(ve[i][0],ve[i][1])){\n     \t\t\tans++;\n     //\t\t\t\tcout<<i<<endl;\n     \t\t\t\ta[ve[i][0].first][ve[i][0].second]=-1;\n     \t\t\t\ta[ve[i][1].first][ve[i][1].second]=-1;\n     \t\t\t\tve[i].clear();\n     \t\t\t\t\n     \t\t\t//\tfor(int k=0;k<h;k++){\n     \t\t\t//\t\tfor(int l=0;l<w;l++)cout<<a[k][l]<<\" \";\n     \t\t\t//\t\tcout<<endl;\n     \t\t\t//\t}\n     \t\t\t\n     \t\t\t}\n     \t\t\n     \t\t\n     \t\t}\n     \t}\n     \tcout<<2*ans<<endl;\n\n    \n           \treturn 0;\n           }\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define X second\n#define Y first\n#define A 26\n#define N 500\nusing namespace std;\ntypedef pair<int,int> P;\nvector<P> v[A];\nstring s[N];\nint m,n,ans;\nbool used[A],erased[A];\n\nbool func(int x){\n  if(!v[x].size()) return false;\n  if(used[x]) return false;\n  used[x]=true;\n  int y1=v[x][0].Y,x1=v[x][0].X,y2=v[x][1].Y,x2=v[x][1].X;\n  int f=0,fa=1,fb=1,fc=1,fd=1;\n  if(x1>x2) swap(x1,x2),f=1;\n  for(int i=x1;i<=x2;i++){\n    char c=s[y1][i];\n    int nx=c-'A';\n    if(nx==x) continue;\n    if(c!='.'&&!erased[nx]&&!func(nx)) fa=0;\n  }\n  for(int i=y1;i<=y2;i++){\n    char c=s[i][x1];\n    int nx=c-'A';\n    if(nx==x) continue;\n    if(c!='.'&&!erased[nx]&&!func(nx)) fb=0;\n  }\n  for(int i=x1;i<=x2;i++){\n    char c=s[y2][i];\n    int nx=c-'A';\n    if(nx==x) continue;\n    if(c!='.'&&!erased[nx]&&!func(nx)) fc=0;\n  }\n  for(int i=y1;i<=y2;i++){\n    char c=s[i][x2];\n    int nx=c-'A';\n    if(nx==x) continue;\n    if(c!='.'&&!erased[nx]&&!func(nx)) fd=0;\n  }\n  if(!f) f=(fa&fd)|(fb&fc);\n  else f=(fa&fb)|(fc&fd);\n  if((y1==y2&&x1+1==x2)||(x1==x2&&y1+1==y2)) f=0;\n  if(!f) return false;\n  erased[x]=true;\n  return true;\n}\n\nint main(){\n  cin>>m>>n;\n  for(int i=0;i<m;i++) cin>>s[i];\n  for(int i=0;i<m;i++)\n    for(int j=0;j<n;j++)\n      if(s[i][j]!='.') v[s[i][j]-'A'].push_back(P(i,j));\n  for(int i=0;i<A;i++){\n    for(int j=0;j<A;j++) used[j]=false;\n    func(i);\n  }\n  for(int i=0;i<A;i++) ans+=erased[i]*2;\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint m,n;\nvector<P> data[30];\nvector<int> xindex;\nvector<int> yindex;\nint fie[180][180];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint pick[4];\nint pickx[4];\nint picky[4];\n\nint main(void){\n\tscanf(\"%d %d\",&n,&m);\n\tfor(int i=0;i<n;i++){\n\t\tstring str;\n\t\tcin >> str;\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(str[j]>='A' && str[j]<='Z'){\n\t\t\t\tdata[str[j]-'A'+1].push_back(P(j,i));\n\t\t\t\txindex.push_back(j-1);\n\t\t\t\txindex.push_back(j);\n\t\t\t\txindex.push_back(j+1);\n\t\t\t\tyindex.push_back(i-1);\n\t\t\t\tyindex.push_back(i);\n\t\t\t\tyindex.push_back(i+1);\n\t\t\t}\n\t\t}\n\t}\n\tsort(xindex.begin(),xindex.end());\n\txindex.erase(unique(xindex.begin(),xindex.end()),xindex.end());\n\tsort(yindex.begin(),yindex.end());\n\tyindex.erase(unique(yindex.begin(),yindex.end()),yindex.end());\n\tfor(int i=1;i<=26;i++){\n\t\tfor(int j=0;j<data[i].size();j++){\n\t\t\tdata[i][j].first=lower_bound(xindex.begin(),xindex.end(),data[i][j].first)-xindex.begin();\n\t\t\tdata[i][j].second=lower_bound(yindex.begin(),yindex.end(),data[i][j].second)-yindex.begin();\n\t\t\tfie[data[i][j].first][data[i][j].second]=i;\n\t\t}\n\t}\n\tbool flag=true;\n\tint score=0;\n\twhile(flag){\n\t\tflag=false;\n\t\tfor(int i=0;i<yindex.size();i++){\n\t\t\tfor(int j=0;j<xindex.size();j++){\n\t\t\t\tif(fie[j][i]==0){\n\t\t\t\t\tmemset(pick,0,sizeof(pick));\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tint x=j,y=i;\n\t\t\t\t\t\twhile((x>=0 && x<xindex.size() && y>=0 && y<yindex.size()) && fie[x][y]==0){\n\t\t\t\t\t\t\tx+=dx[k];\n\t\t\t\t\t\t\ty+=dy[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(fie[x][y]!=0){\n\t\t\t\t\t\t\tpick[k]=fie[x][y];\n\t\t\t\t\t\t\tpickx[k]=x;\n\t\t\t\t\t\t\tpicky[k]=y;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tfor(int l=k+1;l<4;l++){\n\t\t\t\t\t\t\tif(pick[k]==pick[l] && pick[k]!=0){\n\t\t\t\t\t\t\t\tscore+=2;\n\t\t\t\t\t\t\t\tfie[pickx[k]][picky[k]]=0;\n\t\t\t\t\t\t\t\tfie[pickx[l]][picky[l]]=0;\n\t\t\t\t\t\t\t\tflag=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",score);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 500;\n\ntypedef pair<int, int> P;\ntypedef pair<P, P> Point;\n\nint h, w;\nchar data[N][N];\nPoint pos[26];\nbool used[26];\nint dy[] = {-1, 0, 1, 0};\nint dx[] = {0, 1, 0, -1};\n\nbool check(P p){\n  if(p.first < 0 || p.first >= h) return false;\n  if(p.second < 0 || p.second >= w) return false;\n  return true;\n}\n     \nbool check(char c, P s, P t, int d){\n  P n = s;\n  n.first += dy[d];\n  n.second += dx[d];\n  bool f = false;\n  while(check(n)){\n    if(data[n.first][n.second] == '.'){\n      f = true;\n    }else if(data[n.first][n.second] != c){\n      f = false;\n      break;\n    }\n    if(n == t) break;\n    n.first += dy[d];\n    n.second += dx[d];\n  }\n  return f;\n}\n\nbool erase(char c){\n  P a = pos[c-'A'].first;\n  P b = pos[c-'A'].second;\n  P s = a, t = b;\n  int d;\n  bool f = false;\n  if(a.first == b.first){\n    if(a.second < b.second) d = 1;\n    else d = 3;\n    if(check(c, s, t, d)) f = true;\n  }else if(a.second == b.second){\n    if(a.first < b.first) d = 2;\n    else d = 0;\n    if(check(c, s, t, d)) f = true;\n  }else{\n    if(data[a.first][b.second] == '.'){\n      s = a;\n      t = P(a.first, b.second);\n      if(a.second < b.second) d = 1;\n      else d = 3;\n      bool f1 = check(c, s, t, d);\n      s = b;\n      if(a.first < b.first) d = 0;\n      else d = 2;\n      bool f2 = check(c, s, t, d);\n      if(f1 && f2) f = true;\n    }\n    if(data[b.first][a.second] == '.'){\n      s = b;\n      t = P(b.first, a.second);\n      if(a.second < b.second) d = 3;\n      else d = 1;\n      bool f1 = check(c, s, t, d);\n      s = a;\n      if(a.first < b.first) d = 2;\n      else d = 0;\n      bool f2 = check(c, s, t, d);\n      if(f1 && f2) f = true;\n    }\n  }\n  if(f){\n    used[c-'A'] = false;\n    data[a.first][a.second] = '.';\n    data[b.first][b.second] = '.';\n  }\n  return f;\n}\n\nmain(){\n  cin >> h >> w;\n  for(int i=0;i<h;++i){\n    for(int j=0;j<w;++j){\n      cin >> data[i][j];\n      if(data[i][j] != '.'){\n        if(used[data[i][j]-'A']){\n          pos[data[i][j]-'A'].second = P(i, j);\n        }else{\n          pos[data[i][j]-'A'].first = P(i, j);\n          used[data[i][j]-'A'] = true;\n        }\n      }\n    }\n  }\n  bool f = true;\n  int ans = 0;\n  while(f){\n    f = false;\n    for(int i=0;i<26;i++){\n      if(used[i]){\n        if(erase(i+'A')){\n          f = true;\n          ans += 2;\n        }\n      }\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vpii = vector<pii>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\nint dx[] = { 0,1,0,-1 };\nint dy[] = { 1,0,-1,0 };\nint main() {\n\tint m, n;\n\tcin >> m >> n;\n\tvector<string> map(m);\n\tfor (auto &a : map)cin >> a;\n\tbool f = 1;\n\tint score = 0;\n\twhile (f) {\n\t\tf = 0;\n\t\trep(i, m)rep(j, n) {\n\t\t\tif (map[i][j] != '.')continue;\n\t\t\tvector<pair<char,string::iterator>> buf;\n\t\t\trep(k, 4) {\n\t\t\t\tint x = j, y = i;\n\t\t\t\twhile (x >= 0 && x < n&&y>=0 && y < m&&map[y][x] == '.')x += dx[k], y += dy[k];\n\t\t\t\tif (x >= 0 && x < n&&y>=0 && y < m)buf.push_back(make_pair(map[y][x],map[y].begin()+x));\n\t\t\t}\n\t\t\tsort(ALL(buf), [](pair<char, string::iterator> a, pair<char, string::iterator> b) {return a.first < b.first; });\n\t\t\tif (buf.size() < 2)continue;\n\t\t\trep1(i, buf.size()-1) {\n\t\t\t\tif (buf[i].first == buf[i - 1].first) {\n\t\t\t\t\t*(buf[i].second) = *(buf[i - 1].second) = '.';\n\t\t\t\t\tscore += 2;\n\t\t\t\t\tf = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << score << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <sstream>\n#include <utility>\n#include <set>\n#include <map>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define each(e,c) for(auto&e:c)\n#define iter(i,c) for(auto i(begin(c));i!=end(c);++i)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\ntemplate<class C>string to_string(vector<C> c,string d=\" \"){stringstream s;iter(i,c)s<<*i<<(next(i)==end(c)?\"\":d);return s.str();}\ntemplate<class C>ostream&operator<<(ostream&os,vector<C>const& v){return os<<to_string(v);}\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<(DUMP(),__VA_ARGS__).str()<<\" (at \"<<__LINE__<<\")\"<<endl)\nstruct DUMP:ostringstream{template<class T>DUMP &operator,(const T&t){if(this->tellp())*this<<\", \";*this<<t;return *this;}};\n#else\n#define dump(...)\n#endif\n\ntypedef vector<string> vs;\nint h,w;\nvs g;\ninline bool valid(int x, int y){\n    return 0<=x && 0<=y && x<w && y<h;\n}\n\nint solve(){\n    vector<pii> space;\n    rep(i,h)rep(j,w)if(g[i][j]=='.') space.emplace_back(j,i);\n    int ans = 0;\n    while(1){\n        bool finish = true;\n        for(auto p : space){\n            vector<pii> s['Z'+1];\n            int x,y;\n            tie(x,y)=p;\n            int dx[]={1,0,-1,0};\n            int dy[]={0,1,0,-1};\n            rep(d,4){\n                int cx,cy;\n                tie(cx,cy)=tie(x,y);\n                while(valid(cx+dx[d],cy+dy[d]) && g[cy][cx]=='.'){\n                    cx+=dx[d]; cy+=dy[d];\n                }\n                if(valid(cx,cy) && g[cy][cx]!='.'){\n                    s[g[cy][cx]].emplace_back(cx,cy);\n                }\n            }\n            for(char c='A';c<='Z';c++){\n                auto& ps = s[c];\n                if(ps.size()>=2){\n                    for(auto & p : ps){\n                        int x,y;\n                        tie(x,y) = p;\n                        g[y][x] = '.';\n                        ans++;\n                        finish = false;\n                        space.emplace_back(x,y);\n                    }\n                }\n            }\n        }\n        if(finish) break;\n    }\n    return ans;\n}\n\nint main(){\n    while(cin>>h>>w){\n        g.clear();\n        rep(i,h){\n            string s;cin>>s;\n            g.push_back(s);\n        }\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \ntemplate<typename T1, typename T2> istream& operator>>(istream& is, pair<T1,T2>& a){ return is >> a.first >> a.second; }\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& os, pair<T1,T2>& a){ return os << a.first << \" \"<<a.second; }\ntemplate<typename T> istream& operator>>(istream& is, vector< T >& vc){ for(int i = 0; i < vc.size(); i++) is >> vc[i]; return is; }\ntemplate<typename T> ostream& operator<<(ostream& os, vector< T >& vc){ for(int i = 0; i < vc.size(); i++) os << vc[i] << endl; return os; }\n \n#define ForEach(it,c) for(__typeof (c).begin() it = (c).begin(); it != (c).end(); it++)\n#define ALL(v) (v).begin(), (v).end()\n#define UNQ(s) { sort(ALL(s)); (s).erase( unique( ALL(s)), (s).end());}\n#define fr first\n#define sc second\n \ntypedef pair< int , int > Pi;\ntypedef pair< int , Pi > Pii;\n \ntypedef long long int64;\nconst int INF = 1 << 28;\n\nint N, M;\nchar mas[500][500];\nint countx[500], county[500];\n\n\nbool counter(int x, int y){\n  vector< Pi > points;\n  if(countx[x] != 0){\n    for(int i = y - 1; i >= 0; i--){\n      if(mas[i][x] != '.'){\n        points.push_back( Pi( x, i));\n        break;\n      }\n    }\n    for(int i = y + 1; i < M; i++){\n      if(mas[i][x] != '.'){\n        points.push_back( Pi( x, i));\n        break;\n      }\n    }\n  }\n  if(county[y] != 0){\n    for(int i = x - 1; i >= 0; i--){\n      if(mas[y][i] != '.'){\n        points.push_back( Pi( i, y));\n        break;\n      }\n    }\n    \n    for(int i = x + 1; i < N; i++){\n      if(mas[y][i] != '.'){\n        points.push_back( Pi( i, y));\n        break;\n      }\n    }\n  }\n\n  for(int i = 0; i < points.size(); i++){\n    for(int j = i + 1; j < points.size(); j++){\n      Pi& p1 = points[i], p2 = points[j];\n      if(mas[p1.second][p1.first] == mas[p2.second][p2.first]){\n        mas[p1.second][p1.first] = mas[p2.second][p2.first] = '.';\n        county[p1.second]--, county[p2.second]--;\n        countx[p1.first]--, countx[p2.first]--;\n        return(true);\n      }\n    }\n  }\n  return(false);\n}\n\nint solve(){\n  for(int i = 0; i < M; i++){\n    for(int j = 0; j < N; j++){\n      if(county[i] + countx[j] < 2) continue;\n      if(mas[i][j] == '.' && counter( j, i)) return(2 + solve());\n    }\n  }\n  return(0);\n}\n\nint main(){\n\n  cin >> M >> N;\n  for(int i = 0; i < M; i++){\n    for(int j = 0; j < N; j++){\n      cin >> mas[i][j];\n    }\n  }\n  for(int i = 0; i < M; i++){\n    for(int j = 0; j < N; j++){\n      county[i] += mas[i][j] != '.';\n      countx[j] += mas[i][j] != '.';\n    }\n  }\n  cout << solve() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\n\nint h,w;\nstring s[600];\nint dy[]={0,1,0,-1};\nint dx[]={1,0,-1,0};\nint sum=0;\n\nvoid knock(int Y,int X){\n  \n  map<char,vector<P> >M;\n  r(i,4){\n    int y=Y;\n    int x=X;\n\n    while(!isalpha(s[y][x])){\n      y+=dy[i];\n      x+=dx[i];\n      if(y<0||x<0||y>=h||x>=w)break;\n    }\n\n    if(y<0||x<0||y>=h||x>=w)continue;\n    M[s[y][x]].push_back(P(y,x));\n  }\n\n  for(auto &e:M){\n    if(e.second.size()!=2)continue;\n    sum+=2;\n    s[e.second[0].first][e.second[0].second] = '.';\n    s[e.second[1].first][e.second[1].second] = '.';\n  }\n\n}\n\nsigned main(){\n  cin>>h>>w;\n  r(i,h)cin>>s[i];\n\n  r(tim,30)r(i,h)r(j,w)if(!isalpha(s[i][j])){\n    knock(i,j);\n  }\n\n  cout<<sum<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nint main(){\n  int N, M;\n  cin >> N >> M;\n  vector<string> field(N);\n  REP(i, N) cin >> field[i];\n  \n  vector<int> rows;\n  vector<int> cols;\n  \n  REP(i, N)REP(j, M)if(isalpha(field[i][j])){\n    rows.push_back(i);\n    cols.push_back(j);\n  }\n\n  sort(ALL(rows));\n  sort(ALL(cols));\n  rows.erase(unique(ALL(rows)), rows.end());\n  cols.erase(unique(ALL(cols)), cols.end());\n  \n  vector<string> board(rows.size(), string(cols.size(), '.'));\n  \n  REP(i, N)REP(j, M)if(isalpha(field[i][j])){\n    int r = lower_bound(ALL(rows), i) - rows.begin();\n    int c = lower_bound(ALL(cols), j) - cols.begin();\n    board[r][c] = field[i][j];\n  }\n  \n  N = rows.size();\n  M = cols.size();\n  \n  int res = 0;\n  int dr[4] = {0, -1, 0, 1};\n  int dc[4] = {1, 0, -1, 0};\n  bool update = true;\n  \n  while(update){\n    update = false;\n    \n    REP(r, N)REP(c, M)if(board[r][c] == '.'){\n      vector<int> t_row;\n      vector<int> t_col;\n      REP(i, 4){\n        int r2 = r + dr[i];\n        int c2 = c + dc[i];\n        while(0 <= r2 && r2 < N && 0 <= c2 && c2 < M && board[r2][c2] == '.'){\n          r2 += dr[i];\n          c2 += dc[i];\n        }\n        \n        if(0 <= r2 && r2 < N && 0 <= c2 && c2 < M){\n          t_row.push_back(r2);\n          t_col.push_back(c2);\n        }\n        \n        REP(i, 26){\n          int c = 0;\n          REP(j, t_row.size()) if(board[t_row[j]][t_col[j]] == 'A' + i) c++;\n          if(c >= 2){\n            update = true;\n            res += c;\n            REP(j, t_row.size()){\n              char &tile = board[t_row[j]][t_col[j]];\n              if(tile == 'A' + i) tile = '.';\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  cout << res << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, -1, 0, 1};\n\nint main() {\n\tint M, N; cin >> M >> N;\n\tvector<string> C(M);\n\tfor (int y = 0; y < M; y++)\n\t\tcin >> C[y];\n\tint cnt = 0;\n\tfor (;;) {\n\t\tbool flag = false;\n\t\tfor (int y = 0; y < M; y++)\n\t\t\tfor (int x = 0; x < N; x++) {\n\t\t\t\tif (C[y][x] != '.') continue;\n\t\t\t\tvector<int> a(26);\n\t\t\t\tfor (int k = 0; k < 4; k++)\n\t\t\t\t\tfor (int _x = x, _y = y; _x >= 0 && _x < N && _y >= 0 && _y < M; _x += dx[k], _y += dy[k]) {\n\t\t\t\t\t\tchar c = C[_y][_x];\n\t\t\t\t\t\tif (c != '.') {\n\t\t\t\t\t\t\ta[c - 'A']++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tfor (char c = 'A'; c <= 'Z'; c++) {\n\t\t\t\t\tif (a[c - 'A'] < 2) continue;\n\t\t\t\t\tcnt += 2;\n\t\t\t\t\tflag = true;\n\t\t\t\t\tfor (int y = 0; y < M; y++)\n\t\t\t\t\t\tfor (int x = 0; x < N; x++)\n\t\t\t\t\t\t\tif (C[y][x] == c)\n\t\t\t\t\t\t\t\tC[y][x] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\tif (!flag) break;\n\t}\n\tcout << cnt << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\ntypedef pair<int,int> pi;\n\nint main()\n{\n    int m,n;\n    cin >>m >>n;\n    vector<string> c(m);\n    rep(i,m) cin >>c[i];\n\n    vector<pi> t[26];\n    rep(i,m)rep(j,n)\n    {\n        if(c[i][j]!='.') t[c[i][j]-'A'].pb(pi(i,j));\n    }\n\n    int exist[26]={0};\n    rep(i,26) if(t[i].size()>0) exist[i]=1;\n\n    int ans=0;\n\n    while(1)\n    {\n        bool erased=false;\n        rep(i,26)\n        {\n            if(!exist[i]) continue;\n\n            pi p=t[i][0], q=t[i][1];\n\n            // ???????????????????£? (1or2??????)\n            vector<pi> quake;\n            if(p.fi==q.fi)\n            {\n                int l=min(p.se,q.se)+1, r=max(p.se,q.se)-1;\n                for(int j=l; j<=r; ++j)\n                {\n                    if(c[p.fi][j]=='.')\n                    {\n                        quake.pb(pi(p.fi,j));\n                        break;\n                    }\n                }\n            }\n            else if(p.se==q.se)\n            {\n                int l=min(p.fi,q.fi)+1, r=max(p.fi,q.fi)-1;\n                for(int j=l; j<=r; ++j)\n                {\n                    if(c[j][p.se]=='.')\n                    {\n                        quake.pb(pi(j,p.se));\n                        break;\n                    }\n                }\n            }\n            else\n            {\n                if(c[p.fi][q.se]=='.') quake.pb(pi(p.fi,q.se));\n                if(c[q.fi][p.se]=='.') quake.pb(pi(q.fi,p.se));\n            }\n\n            // ???????????????\n            int dx[4]={1,-1,0,0}, dy[4]={0,0,1,-1};\n            #define IN(x,y) (0<=x && x<n && 0<=y && y<m)\n            for(const auto &P:quake)\n            {\n                string touch=\"....\";\n                rep(j,4)\n                {\n                    for(int k=1; k<=max(n,m); ++k)\n                    {\n                        int nx=P.se+k*dx[j], ny=P.fi+k*dy[j];\n                        if(!IN(nx,ny)) break;\n\n                        if(c[ny][nx]!='.')\n                        {\n                            touch[j]=c[ny][nx];\n                            break;\n                        }\n                    }\n                }\n                int ct=0;\n                rep(j,4) if(touch[j]=='A'+i) ++ct;\n                if(ct==2)\n                {\n                    exist[i]=0;\n                    c[p.fi][p.se]='.';\n                    c[q.fi][q.se]='.';\n                    erased=true;\n                    break;\n                }\n            }\n\n            if(erased) break;\n        }\n\n        if(!erased) break;\n        ans+=2;\n    }\n\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define lp(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, n) lp(i, 0, n)\n#define rlp(i, a, b) for (int i = (int)(b) - 1; i >= (int)(a); i--)\n#define rrep(i, n) rlp(i, 0, n)\n\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n#define all(c) begin(c), end(c)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\ntemplate<typename T>\ninline bool chmin(T &a, T b){\n\tif (a <= b) return false;\n\ta = b; return true;\n}\n\ntemplate<typename T>\ninline bool chmax(T &a, T b){\n\tif (a >= b) return false;\n\ta = b; return true;\n}\n\ntemplate<typename T>\ninline void unique(T &c){\n\tsort(all(c));\n\tc.erase(unique(all(c)), end(c));\n}\n\ntemplate<typename T>\ninline T sq(T a){\n\treturn a * a;\n}\n\ntemplate<typename T>\ninline size_t index_of(vector<T> &c, T x){\n\treturn lower_bound(all(c), x) - begin(c);\n}\n\nint m, n;\nvector<tuple<char, int, int>> v;\nvector<int> zx, zy;\nchar g[128][128];\n\nint main()\n{\n\tcin >> m >> n;\n\trep(i, m) rep(j, n){\n\t\tchar c;\n\t\tcin >> c;\n\t\tif (c != '.'){\n\t\t\tv.eb(c, i, j);\n\t\t\tlp(k, -1, 2){\n\t\t\t\tzx.pb(i + k); zy.pb(j + k);\n\t\t\t}\n\t\t}\n\t}\n\tunique(zx); unique(zy);\n\tm = zx.size(); n = zy.size();\n\tmemset(g, '.', sizeof(g));\n\tfor (auto &t : v){\n\t\tchar c; int x, y;\n\t\ttie(c, x, y) = t;\n\t\tg[index_of(zx, x)][index_of(zy, y)] = c;\n\t}\n\tint res = 0;\n\trep(k, 26) rep(x, m) rep(y, n){\n\t\tif (g[x][y] != '.') continue;\n\t\tmap<char, vector<pair<int, int>>> cnt;\n\t\trep(dir, 4){\n\t\t\tint xx = x, yy = y;\n\t\t\twhile (true){\n\t\t\t\txx += dx[dir], yy += dy[dir];\n\t\t\t\tif (xx < 0 || xx >= m || yy < 0 || yy >= n) break;\n\t\t\t\tif (g[xx][yy] != '.'){\n\t\t\t\t\tcnt[g[xx][yy]].eb(xx, yy);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (auto &t : cnt){\n\t\t\tif (t.second.size() < 2) continue;\n\t\t\tfor (auto &p : t.second){\n\t\t\t\tg[p.first][p.second] = '.';\n\t\t\t}\n\t\t\tres += 2;\n\t\t}\n\t}\n\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <iostream>\n#include <cstdio>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\nchar b[512][512];\nint w, h;\nchar memo[4][500][500];\n\n#define LEFT (0)\n#define RIGHT (1)\n#define DOWN (2)\n#define UP (3)\n\nint dx[] = {-1, 1, 0, 0};\nint dy[] = {0, 0, 1, -1};\n\n\nchar iter(int y, int x, int d){\n  if(y >= h) return '.';\n  if(x >= w) return '.';\n  if(y <  0) return '.';\n  if(x <  0) return '.';\n\n  if(memo[d][y][x]) return memo[d][y][x];\n  if(b[y][x] != '.') return b[y][x];\n\n  return memo[d][y][x] = iter(y + dy[d], x + dx[d], d);\n}\nvoid update(int y, int x, int d){\n  if(memo[d][y][x] == 0 && b[y][x] == '.')\n    memo[d][y][x] = iter(y + dy[d], x + dx[d], d);\n}\n\nvoid debug(){\n  REP(i,h) puts(b[i]); puts(\"\");\n}\n\nint main(){\n  scanf(\"%d%d\", &h, &w);\n\n  REP(i, h) scanf(\"%s\", b[i]);\n  \n  REP(d, 4) REP(i, h) REP(j, w) if(b[i][j] == '.'){\n    if(memo[d][i][j] == 0){\n      update(i, j, d);\n    }\n  }\n\n  int ans = 0;\n  bool ok = true;\n\n  while(ok){\n    ok = false;\n\n    REP(i,h) REP(j,w) if(b[i][j] == '.'){\n      set<int> deld;\n      \n      REP(d, 4){\n\tfor(int e = d + 1; e < 4; e++){\n\t  if(memo[d][i][j] != '.' && memo[d][i][j] == memo[e][i][j]){\n\t    deld.insert(e);\n\t    deld.insert(d);\n\t  }\n\t}\n      }\n      \n      if(deld.size()){\n\t//printf(\"%d %d : %c %c %c %c\\n\", i, j, memo[0][i][j], memo[1][i][j], memo[2][i][j], memo[3][i][j]);\n\tok = true;\n\tFOR(it, deld){\n\t  int y = i;\n\t  int x = j;\n\t  int d = *it;\n\n\t  while(true){\n\t    if(b[y][x] != '.'){\n\t      b[y][x] = '.';\n\t      break;\n\t    }\n\t    y += dy[d];\n\t    x += dx[d];\n\t    if(y >= h) break;\n\t    if(x >= w) break;\n\t    if(y <  0) break;\n\t    if(x <  0) break;\n\t  }\n\t}\n\n\tREP(d,4){\n\t  REP(y,h) REP(x,w)\n\t    memo[d][y][x] = 0;\n\n\t  REP(y,h) REP(x,w)\n\t    update(y,x,d);\n\t}\n\n\tans += deld.size();\n\n\t// debug();\n      }\n    }\n\n  }\n\n  printf(\"%d\\n\", ans);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #ifdef DEBUG\n// #define _GLIBCXX_DEBUG\n// #endif\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <valarray>\n#include <map>\n#include <set>\n#include <list>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <complex>\n#include <string>\n#include <sstream>\n\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n\n// these require C++11\n#include <unordered_set>\n#include <unordered_map>\n#include <random>\n#include <thread>\n#include <chrono>\n\nusing namespace std;\n\n#define int long long\n\n#define all(c) c.begin(), c.end()\n#define repeat(i, n) for (int i = 0; i < static_cast<int>(n); i++)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x) \n#endif\n\ntemplate<typename A,typename B>\nostream &operator<<(ostream&os,const pair<A,B>& p){\n    os << \"(\" << p.first << \",\" << p.second << \")\";\n    return os;\n}\n\n// Define a type which holds an unsigned integer value \ntemplate<std::size_t> struct int_{};\ntemplate <class Tuple, size_t Pos>\nstd::ostream& print_tuple(std::ostream& out, const Tuple& t, int_<Pos> ) {\n  out << std::get< std::tuple_size<Tuple>::value-Pos >(t) << ',';\n  return print_tuple(out, t, int_<Pos-1>());\n}\n \ntemplate <class Tuple>\nstd::ostream& print_tuple(std::ostream& out, const Tuple& t, int_<1> ) {\n  return out << std::get<std::tuple_size<Tuple>::value-1>(t);\n}\n \ntemplate <class... Args>\nostream& operator<<(ostream& out, const std::tuple<Args...>& t) {\n  out << '('; \n  print_tuple(out, t, int_<sizeof...(Args)>()); \n  return out << ')';\n}\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &vec) {\n    os << \"[\";\n    for (const auto &v : vec) {\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\n\n\ntypedef complex<double> point;\n\n// template<typename T,std::size_t N>\n// struct _v_traits {using type = std::vector<typename _v_traits<T,N-1>::type>;};\n// template<typename T>\n// struct _v_traits<T,1> {using type = std::vector<T>;};\n// template<typename T,std::size_t N=1>\n// using vec = typename _v_traits<T,N>::type;\n\n\nconst char dot = '.';\ninline int to_index(char c){\n    return c - 'A';\n}\nconst vector<int> dy = {-1,0,1,0};\nconst vector<int> dx = {0,1,0,-1};\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int H,W; cin >> H >> W;\n    vector<string> field(H);\n    for(string& s : field){\n        cin >> s;\n    }\n\n    set<tuple<int,int> > should_press;\n    for(int y=0;y<H;y++){\n        for(int x=0;x<W;x++){\n            vector<int> v(26);\n            for(int i=0;i<4;i++){\n                for(int k=1;k<max(H,W);k++){\n                    int ny = y + k * dy[i],\n                        nx = x + k * dx[i];\n                    if(ny < 0 or ny >= H or nx < 0 or nx >= W) break;\n                    const char here = field[ny][nx];\n                    if(here != dot){\n                        v[to_index(here)]++;\n                        // break;\n                    }\n                }\n            }\n            if(*max_element(all(v)) >= 2){\n                should_press.emplace(y,x);\n            }\n        }\n    }\n\n    // dump(should_press);\n    bool cont = true;\n    int ret = 0;\n    while(cont){\n        cont = false;\n        for(auto t : should_press){\n            int y = get<0>(t),\n                x = get<1>(t);\n            if(field[y][x] != dot) continue;\n            vector<tuple<int,int> > tiles;\n            for(int i=0;i<4;i++){\n                for(int k=1;k<max(H,W);k++){\n                    int ny = y + k * dy[i],\n                        nx = x + k * dx[i];\n                    if(ny < 0 or ny >= H or nx < 0 or nx >= W) break;\n                    const char here = field[ny][nx];\n                    if(here != dot){\n                        tiles.emplace_back(ny,nx);\n                        break;\n                    }\n                }\n            }\n            for(int i=0;i<tiles.size();i++){\n                for(int j=i+1;j<tiles.size();j++){\n                    char& ic = field[get<0>(tiles[i])][get<1>(tiles[i])];\n                    char& ij = field[get<0>(tiles[j])][get<1>(tiles[j])];\n                    if(ic == ij){\n                        ic = dot;\n                        ij = dot;\n                        ret+=2;\n                        cont = true;\n                        goto end;\n                    }\n                }\n            }\n        end:{}\n        }\n    }\n    for(string s : field){\n        cerr << s << endl;\n    }\n    cout << ret << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nint N,M,x[4]={1,0,-1,0},y[4]={0,1,0,-1};\nchar P[501][501];\nvector<pair<char,int> > V;\n\nint beat(int a,int b)\n{\n  int c,d;\n  V.clear();\n  for(int k=0;k<4;k++){\n    c=a+x[k],d=b+y[k];\n    while(1){\n      if(c<0 || d<0 || c>=M || d>=N)break;\n      if(P[c][d]!='.'){\n\tV.push_back(make_pair(P[c][d],k));\n\tbreak;\n      }\n      c+=x[k],d+=y[k];\n    }\n  }\n  int sum=0;\n  for(int i=0;i<V.size();i++){\n    for(int j=i+1;j<V.size();j++){\n      if(V[j].first==V[i].first){\n        sum+=2;\n\tc=a+x[V[j].second],d=b+y[V[j].second];\n        while(1){\n          if(P[c][d]==V[j].first){\n\t    P[c][d]='.';\n\t    break;\n\t  }\n\t  c+=x[V[j].second],d+=y[V[j].second];\n\t}\n\tc=a+x[V[i].second],d=b+y[V[i].second];\n        while(1){\n          if(P[c][d]==V[i].first){\n\t    P[c][d]='.';\n\t    break;\n\t  }\n\t  c+=x[V[i].second],d+=y[V[i].second];\n\t}\n      }\n    }\n  }       \n  return sum;\n}\n\nint main()\n{\n  int ans=0,sum;\n  cin>>M>>N;\n  for(int i=0;i<M;i++){\n    for(int j=0;j<N;j++)cin>>P[i][j];\n  }\n  while(1){\n    sum=0;\n    for(int i=0;i<M;i++){\n      for(int j=0;j<N;j++){\n\tif(P[i][j]=='.')sum+=beat(i,j);\n      }\n    }\n    if(sum==0)break;\n    ans+=sum;\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define REP(i,n,N) for(int i=(n);i<(int)(N);i++)\n#define p(s) cout<<(s)<<endl;\n#define F first\n#define S second\nusing namespace std;\n\nstring s[501];\nbool tacX(int x1,int x2,int y,char c){\n    for(int x=x1;x<=x2;x++) if(s[y][x]!='.' && s[y][x]!=c) return false;\n    return true;\n}\n\nbool tacY(int y1,int y2,int x,char c){\n    for(int y=y1;y<=y2;y++) if(s[y][x]!='.' && s[y][x]!=c) return false;\n    return true;\n}\nint main(){\n\tint M,N;\n\tcin>>M>>N;\n\tvector<pair<int,int>> vc[30];\n\tREP(i,0,M){\n\t\tcin>>s[i];\n\t\tREP(j,0,N){\n\t\t\tif(s[i][j]!='.') vc[s[i][j]-'A'].push_back({j,i});\n\t\t}\n\t}\n\tint ans=0;\n\twhile(1){\n\t\tbool change=false;\n\t\tREP(i,0,'Z'-'A'+1){\n\t\t\tif(vc[i].size()!=2) continue;\n\t\t\tpair<int,int> a=vc[i][0],b=vc[i][1];\n\t\t\tbool ok=false;\n\t\t\tif(a.F!=b.F&&a.S!=b.S){\n\t\t\t\tif((tacX(min(a.F,b.F),max(a.F,b.F),a.S,'A'+i)\n\t\t\t\t&& tacY(a.S,b.S,b.F,'A'+i))\n\t\t\t\t|| (tacX(min(a.F,b.F),max(a.F,b.F),b.S,'A'+i)\n\t\t\t\t&& tacY(a.S,b.S,a.F,'A'+i))) ok=true;\n\t\t\t}\n\t\t\telse if(a.S==b.S&&b.F-a.F>1&& tacX(a.F,b.F,a.S,'A'+i)) ok=true;\n\t\t\telse if(a.F==b.F&&b.S-a.S>1&&tacY(a.S,b.S,a.F,'A'+i)) ok=true;\n\t\t\tif(ok){\n\t\t\t\ts[a.S][a.F]=s[b.S][b.F]='.';\n\t\t\t\tvc[i].clear();\n\t\t\t\tans+=2;\n\t\t\t\tchange=true;\n\t\t\t}\n\t\t}\n\t\tif(!change) break;\n\t}\n\tp(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint num;\nvector<pii> v[26];\nchar ba[500][500];\nint m,n;\n\nbool solve() {\n    for (int i=0; i<26; ++i) {\n        if (v[i].size()) {\n            pii a = v[i][0], b = v[i][1];\n            //printf(\"%d,%d %d,%d\\n\",a.first,a.second,b.first,b.second);\n            if (a.first == b.first)  {\n                bool f = 0;\n                for (int x=min(a.second, b.second)+1; x<=max(a.second, b.second)-1; ++x) {\n                    if (ba[a.first][x] !='.') {\n                        f = 0;\n                        break;\n                    }\n                    f = 1;\n                }\n                if (f) {\n                    ba[a.first][a.second] = '.';\n                    ba[b.first][b.second] = '.';\n                    v[i].clear();\n                    return 1;\n                }\n            } else if (a.second == b.second) {\n                bool f = 0;\n                for (int y=min(a.first, b.first)+1; y<=max(a.first, b.first)-1; ++y) {\n                    if (ba[y][b.second] !='.') {\n                        f = 0;\n                        break;\n                    }\n                    f = 1;\n                }\n\n                if (f) {\n                    ba[a.first][a.second] = '.';\n                    ba[b.first][b.second] = '.';\n                    v[i].clear();\n                    return 1;\n                }\n            } else {\n                //a.first, b.second\n                bool f = 1;\n                for (int y=min(a.first, b.first)+1; y<=max(a.first, b.first)-1; ++y) {\n                    //cout << \"y=\" << y << \" \" << b.second << endl;\n                    if (ba[y][b.second] !='.') {\n                        f = 0;\n                        break;\n                    }\n                }\n                // cout << f <<\" ;\" << endl;\n                if (f && ba[a.first][b.second] == '.') {\n                    \n                    for (int x=min(a.second, b.second)+1; x<=max(a.second, b.second)-1; ++x) {\n                        if (ba[a.first][x] !='.') {\n                            f = 0;\n                            break;\n                        }\n                    }\n                    if (f) {\n                        //cout << \"aaaaa\" << endl;\n                        ba[a.first][a.second] = '.';\n                        ba[b.first][b.second] = '.';\n                        v[i].clear();\n                        return 1;\n                    }\n                }\n                f = 1;\n                \n                for (int y=min(a.first, b.first)+1; y<=max(a.first, b.first)-1; ++y) {\n                    if (ba[y][a.second] !='.') {\n                        f = 0;\n                        break;\n                    }\n                }\n                if (f && ba[b.first][a.second] == '.') {\n              \n                    for (int x=min(a.second, b.second)+1; x<=max(a.second, b.second)-1; ++x) {\n                        if (ba[b.first][x] !='.') {\n                            f = 0;\n                            break;\n                        }\n                    }\n                    if (f) {\n                        ba[a.first][a.second] = '.';\n                        ba[b.first][b.second] = '.';\n                        v[i].clear();\n                        return 1;\n                    }\n                }\n            }\n        }\n    }\n    return 0;\n}\n\nint main() {\n    cin >> m >> n;\n    set<char> se;\n    for (int i=0; i<m; ++i) {\n        for (int j=0; j<n; ++j) {\n            cin >> ba[i][j];\n            if (ba[i][j] != '.') {\n                v[ba[i][j]-'A'].push_back(pii(i,j));\n                se.insert(ba[i][j]);\n            }\n        }\n    }\n    num = se.size();\n    \n    int ans = 0;\n    while(solve()) {\n        ans+=2;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <queue>\n#include <map>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> que;\nconst int INF = 1<<30;\nconst int MOD = 1e9 + 7;\nconst int dy[] = {1, 0, -1, 0};\nconst int dx[] = {0, 1, 0, -1};\nint h, w, ans;\nvector<string> table;\nbool inRange(int y, int x)\n{\n    if(y < 0 or x < 0 or y >= h or x >= w) return false;\n    return true;\n}\nint solve()\n{\n    int res = 0;\n    bool flag;\n    while(true)\n    {\n        flag = false;\n        for(int i = 0; i < h; i++)\n        {\n            for(int j = 0; j < w; j++)\n            {\n                if(table[i][j] != '.') continue;\n                map<char, vector<P>> mp;\n                for(int k = 0; k < 4; k++)\n                {\n                    int ny = i + dy[k], nx = j + dx[k];\n                    while(inRange(ny, nx))\n                    {\n                        if(table[ny][nx] != '.')\n                        {\n                            mp[table[ny][nx]].push_back(make_pair(ny, nx));\n                            break;\n                        }\n                        ny += dy[k];\n                        nx += dx[k];\n                    }\n                }\n                for(auto x : mp)\n                {\n                    if(x.second.size() == 2)\n                    {\n                        flag = true;\n                        for(int k = 0; k < x.second.size(); k++)\n                        {\n                            P p = x.second[k];\n                            table[p.first][p.second] = '.';\n                        }\n                        res += x.second.size();\n                    }\n                }\n            }\n        }\n        if(flag == false) break;\n    }\n    return res;\n}\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> h >> w;\n    table.resize(h);\n    for(int i = 0; i < h; i++) cin >> table[i];\n    cout << solve() << endl;\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint H,W;\ntypedef pair<int,int>P;\n\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\nconst int TYPEX = 1;\nconst int TYPEY = 2;\nconst int ELSE = 3;\n\nclass Data{\npublic:\n  vector<P>pv;\n  bool used,notuse;\n  int type;\n  Data(){pv.clear();used = true;type = 0;notuse = false;};\n  void check(){\n    sort(pv.begin(),pv.end());\n    for(int i = 0 ; i < 4 ; i++){\n      P np = P(pv[0].first + dy[i],pv[0].second + dx[i]);\n      if(!(0 <= np.first && np.first < H && 0 <= np.second && np.second < W))continue;\n      if(pv[1] == np){\n\tnotuse = true;\n\treturn;\n      }\n    }\n    if(pv[0].first == pv[1].first)type = TYPEY;\n    else if(pv[0].second == pv[1].second)type = TYPEX;\n    else type = ELSE;\n  }\n};\n\nData data[26];\n\nvoid init(){\n  for(int i = 0 ; i < 26 ; i++)data[i] = Data();\n}\n\nvoid input(){\n  cin >> H >> W;\n  for(int i = 0 ; i < H ; i++){\n    for(int j = 0 ; j < W ; j++){\n      char c;\n      cin >> c;\n      if(c == '.')continue;\n      data[c-'A'].pv.push_back(P(i,j));\n      data[c-'A'].used = false;\n    }\n  }\n  for(int i = 0 ; i < 26 ; i++){\n    if(!data[i].used)data[i].check();\n  }\n\n  /*\n  for(int i = 0 ; i < 26 ; i++){\n    cout << \"i = \" << (char)(i + 'A') << \" used = \" << data[i].used << endl;\n    if(data[i].used)continue;\n    cout << \"p0 = \" << data[i].pv[0].first << ' ' << data[i].pv[0].second \n\t << \"p1 = \" << data[i].pv[1].first << ' ' << data[i].pv[1].second << endl;\n  }\n  */\n}\n\nint run(int res){\n  for(int i = 0 ; i < 26 ; i++){\n    if(data[i].notuse)continue;\n    if(data[i].used)continue;\n    bool f = false;\n    bool f1,f2;\n    f1 = f2 = false;\n\n    P p0,p1,p2;\n    p0 = data[i].pv[0];\n    p1 = data[i].pv[1];\n\n    \n\n    if(data[i].type == TYPEX){\n      for(int j = 0 ; j < 26 ; j++){\n\tif(f)break;\n\tif(j == i)continue;\n\tif(data[j].used)continue;\n\tfor(int k = 0 ; k < 2 ; k++){\n\n\t  /*\n\t  if(i == 1 && j == 3){\n\t    cout << \"p0.first = \" << p0.first << \" p2.first = \" << p2.first << \n\t      \"p1.first = \" << p1.first << endl;\n\t  }\n\t  */\n\t  p2 = data[j].pv[k];\n\t  if(p0.second != p2.second)continue;\n\t  if(p0.first <= p2.first && p2.first <= p1.first){\n\t    f = true;\n\t    break;\n\t  }\n\t}\n      }\n    }\n    else if(data[i].type == TYPEY){\n      for(int j = 0 ; j < 26 ; j++){\n\tif(f)break;\n\tif(j == i)continue;\n\tif(data[j].used)continue;\n\tfor(int k = 0 ; k < 2 ; k++){\n\t  p2 = data[j].pv[k];\n\t  if(p0.first != p2.first)continue;\n\t  if(p0.second <= p2.second && p2.second <= p1.second){\n\t    f = true;\n\t    break;\n\t  }\n\t}\n      }\n    }\n    else {\n      for(int j = 0 ; j < 26 ; j++){\n\tif(f)break;\n\tif(j == i)continue;\t\n\tif(data[j].used)continue;\n\n\tfor(int k = 0 ; k < 2 ; k++){\n\t  p2 = data[j].pv[k];\n\t  int x1,x2,y1,y2;\n\t  if(p0.second < p1.second){\n\t    \n\t    /*\n\t    cout << (char)(i + 'A') << endl;\n\t    cout << \"p0.first = \" << p0.first << ' ' << \" p1.first = \" << p1.first << endl;\n\t    */\n\n\t    x1 = p0.second;\n\t    y1 = p0.first;\n\t    x2 = p1.second;\n\t    y2 = p1.first;\n\t    \n\t    if(p2.second == x1){\n\t      if(y1 <= p2.first && p2.first <= y2)f1 = true;\n\t    }\n\t    \n\t    if(p2.first == y1){\n\t      if(x1 <= p2.second && p2.second <= x2)f2 = true;\n\t    }\n\t    \n\t    if(p2.second == x2){\n\t      if(y1 <= p2.first && p2.first <= y2)f2 = true;\n\t    }\n\n\t    if(p2.first == y2){\n\t      if(x1 <= p2.second && p2.second <= x2)f1 = true;\n\t    }\n\n\t  }\n\t  else{\n\n\t    //cout << (char)(i + 'A') << endl;\n\t    //cout << \"p0.first = \" << p0.first << ' ' << \" p1.first = \" << p1.first << endl;\n\n\t    x1 = p1.second;\n\t    y1 = p0.first;\n\t    x2 = p0.second;\n\t    y2 = p1.first;\n\n\t    if(p2.second == x1){\n\t      if(y1 <= p2.first && p2.first <= y2)f1 = true;\n\t    }\n\t    \n\t    if(p2.first == y1){\n\t      if(x1 <= p2.second && p2.second <= x2)f1 = true;\n\t    }\n\t    \n\t    if(p2.second == x2){\n\t      if(y1 <= p2.first && p2.first <= y2)f2 = true;\n\t    }\n\n\t    if(p2.first == y2){\n\t      if(x1 <= p2.second && p2.second <= x2)f2 = true;\n\t    }\n\t  }\n\t}\n      }\n\n      if(f1 && f2){\n\tf = true;\n      }\n    }\n    if(f)continue;\n    //cout << \"del = \" << (char)(i + 'A') << endl;//\n    data[i].used = true;\n    return run(res+2);\n  }\n  return res;\n}\n\nint main(){\n  init();\n  input();\n  cout << run(0) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint m,n;\nvector<P> data[30];\nvector<int> xindex;\nvector<int> yindex;\nint fie[60][60];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint pick[4];\nint pickx[4];\nint picky[4];\n\nint main(void){\n\tscanf(\"%d %d\",&n,&m);\n\tfor(int i=0;i<n;i++){\n\t\tstring str;\n\t\tcin >> str;\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(str[j]>='A' && str[j]<='Z'){\n\t\t\t\tdata[str[j]-'A'+1].push_back(P(j,i));\n\t\t\t\txindex.push_back(j);\n\t\t\t\tyindex.push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tsort(xindex.begin(),xindex.end());\n\txindex.erase(unique(xindex.begin(),xindex.end()),xindex.end());\n\tsort(yindex.begin(),yindex.end());\n\tyindex.erase(unique(yindex.begin(),yindex.end()),yindex.end());\n\tfor(int i=1;i<=26;i++){\n\t\tfor(int j=0;j<data[i].size();j++){\n\t\t\tdata[i][j].first=lower_bound(xindex.begin(),xindex.end(),data[i][j].first)-xindex.begin();\n\t\t\tdata[i][j].second=lower_bound(yindex.begin(),yindex.end(),data[i][j].second)-yindex.begin();\n\t\t\tfie[data[i][j].first][data[i][j].second]=i;\n\t\t}\n\t}\n\tbool flag=true;\n\tint score=0;\n\twhile(flag){\n\t\tflag=false;\n\t\tfor(int i=0;i<yindex.size();i++){\n\t\t\tfor(int j=0;j<xindex.size();j++){\n\t\t\t\tif(fie[j][i]==0){\n\t\t\t\t\tmemset(pick,0,sizeof(pick));\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tint x=j,y=i;\n\t\t\t\t\t\twhile((x>=0 && x<xindex.size() && y>=0 && y<yindex.size()) && fie[x][y]==0){\n\t\t\t\t\t\t\tx+=dx[k];\n\t\t\t\t\t\t\ty+=dy[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(fie[x][y]!=0){\n\t\t\t\t\t\t\tpick[k]=fie[x][y];\n\t\t\t\t\t\t\tpickx[k]=x;\n\t\t\t\t\t\t\tpicky[k]=y;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tfor(int l=k+1;l<4;l++){\n\t\t\t\t\t\t\tif(pick[k]==pick[l] && pick[k]!=0){\n\t\t\t\t\t\t\t\tscore+=2;\n\t\t\t\t\t\t\t\tfie[pickx[k]][picky[k]]=0;\n\t\t\t\t\t\t\t\tfie[pickx[l]][picky[l]]=0;\n\t\t\t\t\t\t\t\tflag=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",score);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_H 500\n#define MAX_W 500\n#define F first\n#define S second\ntypedef pair<int,int> pii;\n\nint H,W;\nchar field[MAX_H][MAX_W];\nvector<pii> v[26];\n\nbool inField(int x,int y){\n    return (0 <= x && x < W && 0 <= y && y < H);\n}\n\nint calc(int x,int y){\n    for(int i = 0 ; i < 26 ; i++){\n        v[i].clear();\n    }\n    const int dx[] = {-1,0,1,0};\n    const int dy[] = {0,-1,0,1};\n    for(int i = 0 ; i < 4 ; i++){\n        int nx = x, ny = y;\n        while(1){\n            nx += dx[i]; ny += dy[i];\n            if(!inField(nx,ny)) break;\n            if(field[ny][nx] != '.'){\n                v[field[ny][nx]-'A'].push_back(pii(nx,ny));\n                break;\n            }\n        }\n    }\n    int res = 0;\n    for(int i = 0 ; i < 26 ; i++){\n        if(v[i].size() == 2){\n            field[v[i][0].S][v[i][0].F] = '.';\n            field[v[i][1].S][v[i][1].F] = '.';\n            res += 2;\n        }\n    }\n    return res;\n}\n\nint main(){\n    cin >> H >> W;\n    for(int i = 0 ; i < H ; i++){\n        for(int j = 0 ; j < W ; j++){\n            cin >> field[i][j];\n        }\n    }\n    int res = 0;\n    bool update = 1;\n    while(update){\n        update = 0;\n        for(int i = 0 ; i < H ; i++){\n            for(int j = 0 ; j < W ; j++){\n                if(field[i][j] != '.') continue;\n                int r = calc(j,i);\n                if(r > 0){\n                    res += r;\n                    update = 1;\n                    goto next;\n                }\n            }\n        }\n    next:;\n    }\n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\npii pos[26][2];\nint num[26];\nstring in[510];\n\nint main(void){\n\tint m,n;\n\tcin >> m >> n;\n\trep(i,m) cin >> in[i];\n\trep(i,m)rep(j,n){\n\t\tif(in[i][j]=='.')\n\t\t\tcontinue;\n\t\tint cur=in[i][j]-'A';\n\t\tpos[cur][num[cur]].first=i;\n\t\tpos[cur][num[cur]++].second=j;\n\t}\n\tint ans=0;\n\trep(loop,26*26)rep(i,26) if(num[i]==2){\n\t\tbool ok=false;\n\t\tif(pos[i][0].first==pos[i][1].first){\n\t\t\tok=(pos[i][0].second+1!=pos[i][1].second);\n\t\t\tfor(int j=pos[i][0].second+1;j<pos[i][1].second;++j)\n\t\t\t\tif(in[pos[i][0].first][j]!='.')\n\t\t\t\t\tok=false;\n\t\t}else if(pos[i][0].second==pos[i][1].second){\n\t\t\tok=(pos[i][0].first+1!=pos[i][1].first);\n\t\t\tfor(int j=pos[i][0].first+1;j<pos[i][1].first;++j)\n\t\t\t\tif(in[j][pos[i][0].second]!='.')\n\t\t\t\t\tok=false;\n\t\t}else{\n\t\t\tif(in[pos[i][1].first][pos[i][0].second]=='.'){\n\t\t\t\tok=true;\n\t\t\t\tfor(int j=min(pos[i][0].first,pos[i][1].first)+1;j<max(pos[i][0].first,pos[i][1].first);++j)\n\t\t\t\t\tif(in[j][pos[i][0].second]!='.')\n\t\t\t\t\t\tok=false;\n\t\t\t\tfor(int j=min(pos[i][0].second,pos[i][1].second)+1;j<max(pos[i][0].second,pos[i][1].second);++j)\n\t\t\t\t\tif(in[pos[i][1].first][j]!='.')\n\t\t\t\t\t\tok=false;\n\t\t\t}\n\t\t\tif(!ok&&in[pos[i][0].first][pos[i][1].second]=='.'){\n\t\t\tok=true;\n\t\t\tfor(int j=min(pos[i][0].first,pos[i][1].first)+1;j<max(pos[i][0].first,pos[i][1].first);++j)\n\t\t\t\tif(in[j][pos[i][1].second]!='.')\n\t\t\t\t\tok=false;\n\t\t\tfor(int j=min(pos[i][0].second,pos[i][1].second)+1;j<max(pos[i][0].second,pos[i][1].second);++j)\n\t\t\t\tif(in[pos[i][0].first][j]!='.')\n\t\t\t\t\tok=false;\n\t\t\t}\n\t\t}\n\n\t\tif(ok){\n\t\t\tin[pos[i][0].first][pos[i][0].second]='.';\n\t\t\tin[pos[i][1].first][pos[i][1].second]='.';\n\t\t\tans+=2,num[i]=0;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\nstring mps[501];\npair<int,int> tile1[26];\npair<int,int> tile2[26];\nint m,n;\n\nbool inter(int i,int j,int k) {\n    if(j == k && i != j) return false;\n    if(j > k) swap(j,k);\n\n    return (j <= i) && (i <= k);\n}\n\nint iabs(int i) {\n    if(i < 0) return -i;\n    return i;\n}\n\nbool is_o(pair<int,int> tile,int x1,int y1,int x2,int y2) {\n    bool is1 = false,is2 = false;\n    if(tile.first == y1 && inter(tile.second,x1,x2)) is1 = true;\n    if(tile.second == x2 && inter(tile.first,y1,y2)) is1 = true;\n\n    return is1;\n}\n\nbool is_s(pair<int,int> tile,int x1,int y1,int x2,int y2) {\n    bool is2 = false;\n\n    if(tile.first == y2 && inter(tile.second,x1,x2)) is2 = true;\n    if(tile.second == x1 && inter(tile.first,y1,y2)) is2 = true;\n    return is2;\n}\n\nbool ok(int idx,int x1,int y1,int x2,int y2) {\n    // adj\n    if(x1 == x2 && iabs(y1-y2) == 1) return false;\n    if(y1 == y2 && iabs(x1-x2) == 1) return false;\n\n    for(int i=0; i<26; ++i) {\n        if(tile1[i].first == -1 || i == idx) continue;\n        if(x1 == x2) {\n            if(tile1[i].second == x1 && inter(tile1[i].first,y1,y2)) return false;\n            if(tile2[i].second == x1 && inter(tile2[i].first,y1,y2)) return false;\n        }else if(y1 == y2) {\n            if(tile1[i].first == y1 && inter(tile1[i].second,x1,x2)) return false;\n            if(tile2[i].first == y1 && inter(tile2[i].second,x1,x2)) return false;\n        }\n    }\n\n    if(y1 > y2) {\n        swap(y1,y2);\n        swap(x1,x2);\n    }\n\n    bool is1 = false,is2 = false;\n    for(int i=0; i<26; ++i) {\n        if(tile1[i].first == -1 || i == idx) continue;\n        if(is_o(tile1[i],x1,y1,x2,y2)) is1 = true;\n        if(is_s(tile1[i],x1,y1,x2,y2)) is2 = true;\n        if(is_o(tile2[i],x1,y1,x2,y2)) is1 = true;\n        if(is_s(tile2[i],x1,y1,x2,y2)) is2 = true;\n    }\n\n    if(is1 && is2) return false;\n\n    return true;\n}\n\nint main() {\n    cin>>m>>n;\n    for(int i=0; i<m; ++i) cin>>mps[i];\n\n    for(int i=0; i<26; ++i)\n        tile1[i] = tile2[i] = make_pair(-1,-1);\n\n    for(int i=0; i<m; ++i) {\n        for(int j=0; j<n; ++j) {\n            if(mps[i][j] != '.') {\n                if(tile1[mps[i][j]-'A'].first == -1) tile1[mps[i][j]-'A'] = make_pair(i,j);\n                else tile2[mps[i][j]-'A'] = make_pair(i,j);\n            }\n        }\n    }\n\n    int ans = 0;\n    while(true) {\n        bool update = false;\n\n        for(int i=0; i<26; ++i) {\n            if(tile1[i].first == -1) continue;\n            int x1 = tile1[i].second,y1 = tile1[i].first;\n            int x2 = tile2[i].second,y2 = tile2[i].first;\n            if(ok(i,x1,y1,x2,y2)) {\n                tile1[i] = make_pair(-1,-1);\n                tile2[i] = make_pair(-1,-1);\n                ans += 2;\n                update = true;\n            }\n\n        // for(int i=0; i<m; ++i) {\n        //     for(int j=0; j<n; ++j) {\n        //         if(mps[i][j] == '.') cout<<\".\";\n        //         else if(tile1[mps[i][j]-'A'].first == -1) cout<<\".\";\n        //         else cout<<mps[i][j];\n        //     }\n        //     cout<<endl;\n        // }\n        }\n\n        if(!update) break;\n\n\n    }\n\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct data {\n  int x1, x2, y1, y2;\n};\n\nbool operator<(const data &l, const data &r) {\n  if(l.x1 != r.x1) return l.x1 < r.x1;\n  if(l.x2 != r.x2) return l.x2 < r.x2;\n  if(l.y1 != r.y1) return l.y1 < r.y1;\n  return l.y2 < r.y2;\n}\n\nlong long m, n;\nvector<string> c;\nmap<char, data> mp;\nset<char> st;\n\nlong long solve();\nbool ch(data now);\nbool checkx(int x, int d, int u);\nbool checky(int y, int l, int r);\n\nint main() {\n  cin >> m >> n;\n  c.resize(m);\n  for(int i = 0; i < m; ++i) cin >> c[i];\n  cout << solve() << endl;\n  return 0;\n}\n\nlong long solve() {\n  int ans = 0;\n  for(int i = 0; i < m; ++i)\n    for(int j = 0; j < n; ++j)\n      if(c[i][j] != '.') {\n        if(mp.find(c[i][j]) != mp.end()) {\n          mp[c[i][j]].x2 = i;\n          mp[c[i][j]].y2 = j;\n        }\n        else {\n          mp[c[i][j]].x1 = i;\n          mp[c[i][j]].y1 = j;\n        }\n      }\n  for(int T = 0; T < 30; ++T) {\n    for(auto nowmp : mp)\n      if(st.find(nowmp.first) == st.end()) {\n        data now = nowmp.second;\n        if(ch(now)) {\n          c[now.x1][now.y1] = c[now.x2][now.y2] = '.';\n          ans += 2;\n          st.insert(nowmp.first);\n        }\n      }\n  }\n  return ans;\n}\n\nbool ch(data now) {\n  if(now.x1 == now.x2)\n    return checkx(now.x1, min(now.y1, now.y2),\n                  max(now.y1, now.y2));\n  else if(now.y1 == now.y2) {\n    return checky(now.y1, min(now.x1, now.x2),\n                  max(now.x1, now.x2));\n  }\n  else {\n    if((min(now.y1, now.y2) + 1 == max(now.y1, now.y2) ||\n        checkx(now.x1, min(now.y1, now.y2),\n               max(now.y1, now.y2))) &&\n       (min(now.x1, now.x2) + 1 == max(now.x1, now.x2) ||\n        checky(now.y2, min(now.x1, now.x2),\n               max(now.x1, now.x2))) &&\n       c[now.x1][now.y2] == '.')\n      return 1;\n    return (min(now.y1, now.y2) + 1 ==\n                max(now.y1, now.y2) ||\n            checkx(now.x2, min(now.y1, now.y2),\n                   max(now.y1, now.y2))) &&\n           (min(now.x1, now.x2) + 1 ==\n                max(now.x1, now.x2) ||\n            checky(now.y1, min(now.x1, now.x2),\n                   max(now.x1, now.x2))) &&\n           c[now.x2][now.y1] == '.';\n  }\n}\n\nbool checkx(int x, int d, int u) {\n  bool res = 0;\n  for(int i = d + 1; i < u; ++i) {\n    if(i == d + 1) res = 1;\n    if(c[x][i] != '.') res = 0;\n  }\n  return res;\n}\nbool checky(int y, int l, int r) {\n  bool res = 0;\n  for(int i = l + 1; i < r; ++i) {\n    if(i == l + 1) res = 1;\n    if(c[i][y] != '.') res = 0;\n  }\n  return res;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst vector<int> dir = { 0, 1, 0, -1 };\nint H, W;\nint main() {\n\tcin >> H >> W;\n\tvector<string> s(H);\n\tvector<int> cx, cy;\n\tfor (int i = 0; i < H; i++) {\n\t\tcin >> s[i];\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (s[i][j] != '.') {\n\t\t\t\tcx.push_back(j);\n\t\t\t\tcy.push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tsort(cx.begin(), cx.end());\n\tcx.erase(unique(cx.begin(), cx.end()), cx.end());\n\tsort(cy.begin(), cy.end());\n\tcy.erase(unique(cy.begin(), cy.end()), cy.end());\n\tH = cy.size() * 2 - 1, W = cx.size() * 2 - 1;\n\tvector<string> t(H, string(W, '.'));\n\tfor (int i = 0; i < H / 2; i++) {\n\t\tfor (int j = 0; j < W / 2; j++) {\n\t\t\tif (s[cy[i]][cx[j]] != '.') t[i * 2][j * 2] = s[cy[i]][cx[j]];\n\t\t}\n\t}\n\tint ret = 0;\n\twhile (true) {\n\t\tbool flag = false;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (t[i][j] != '.') continue;\n\t\t\t\tvector<vector<pair<int, int> > > d(26);\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tint tx = j, ty = i;\n\t\t\t\t\twhile (0 <= tx && tx < W && 0 <= ty && ty < H) {\n\t\t\t\t\t\tif (t[ty][tx] != '.') {\n\t\t\t\t\t\t\td[t[ty][tx] - 65].push_back(make_pair(tx, ty));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttx += dir[k];\n\t\t\t\t\t\tty += dir[k ^ 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int k = 0; k < 26; k++) {\n\t\t\t\t\tif (d[k].size() == 2) {\n\t\t\t\t\t\tflag = true; ret += 2;\n\t\t\t\t\t\tt[d[k][0].second][d[k][0].first] = '.';\n\t\t\t\t\t\tt[d[k][1].second][d[k][1].first] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!flag) break;\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define x first\n#define y second\nusing namespace std;\ntypedef pair <int,int> P;\nstring mp[501];\nint m,n,used[26],ans;\nvector <P>  a[26];\n\nint saiki(int);\n\nbool check(int c,int s,int t,int f){\n  int res=1;\n  for(int i=s+1;i<t;i++){\n    if(!f&&mp[i][c]!='.'&&!saiki(mp[i][c]-'A'))res=0;\n    if(f&&mp[c][i]!='.'&&!saiki(mp[c][i]-'A'))res=0;\n  }\n  return res;\n}\n\nint saiki(int ch){\n  int x1=a[ch][0].x,x2=a[ch][1].x;\n  int y1=a[ch][0].y,y2=a[ch][1].y;\n  int res=0;\n  if(used[ch])return 0;\n  used[ch]=1;\n  \n  if(x1==x2&&y2-y1!=1) res=check(x1,y1,y2,0);\n  if(y1==y2&&x2-x1!=1) res=check(y1,x1,x2,1);\n  \n  if(x1!=x2&&y1!=y2) {\n    if(x1<x2){\n      res=check(y1,x1,x2+1,1)&check(x2,y1,y2,0);\n      res|=check(x1,y1,y2+1,0)&check(y2,x1,x2,1);\n    }\n    else{\n      swap(x1,x2);\n      res=check(y1,x1-1,x2,1)&check(x1,y1,y2,0);\n      res|= check(x2,y1,y2,0)&check(y2,x1,x2+1,1);\n      swap(x1,x2);\n    }\n  }\n  \n  if(res) {\n    mp[y1][x1]=mp[y2][x2]='.';\n    a[ch].clear();\n    ans+=2;\n  }\n  return res;\n}\n\nint main(){\n  \n  cin>>m>>n;\n  for(int i=0;i<m;i++)cin>>mp[i];\n  \n  for(int i=0;i<m;i++)\n    for(int j=0;j<n;j++)\n      if(mp[i][j]!='.')a[mp[i][j]-'A'].push_back(P(j,i));\n  \n \n  int f=1;\n  while(f--) \n    for(int i=0;i<26;i++){\n       memset(used,0,sizeof(used));\n      if(a[i].size()) f|=saiki(i);\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<cassert>\n#include<cstdlib>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int N = 500;\nchar m[N][N+1];\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\n\nbool cango(int r,int c,int y,int x,int ty,int tx){\n  rep(i,4){\n    int ddx=x+dx[i],ddy=y+dy[i];\n    while(ddy != -1 && ddx != -1 && ddy != r && ddx != c){\n      if (m[ddy][ddx] != '.')break;\n      if (ddy == ty && ddx == tx)return true;\n      ddx+=dx[i];\n      ddy+=dy[i];\n    }\n  }\n  return false;\n}\n\nbool erase(int r,int c,int y1,int x1,int y2,int x2){\n  vector<int> tx,ty;\n  if (y1 == y2){\n    tx.push_back(x1 < x2?x1+1:x2+1);\n    ty.push_back(y1);\n  }else if (x1 == x2){\n    tx.push_back(x1);\n    ty.push_back(y1 < y2?y1+1:y2+1);\n  }else {\n    tx.push_back(x1);\n    ty.push_back(y2);\n    tx.push_back(x2);\n    ty.push_back(y1);\n  }\n  bool isok=false;\n  rep(i,(int)tx.size()){\n    if (cango(r,c,y1,x1,ty[i],tx[i]) && \n\tcango(r,c,y2,x2,ty[i],tx[i])){isok=true;break;}\n  }\n  if (isok)m[y1][x1]=m[y2][x2]='.';\n  return isok;\n}\n\nmain(){\n  int r,c;\n  while(cin>>r>>c){\n    rep(i,r)cin>>m[i];\n    vector<pii> in[26];\n    rep(i,r){\n      rep(j,c){\n\tif (!isalpha(m[i][j]))continue;\n\tin[m[i][j]-'A'].push_back(make_pair(i,j));\n      }\n    }\n    rep(i,26){\n      if (in[i].size() == 0)continue;\n      if (abs(in[i][0].first-in[i][1].first)+abs(in[i][0].second-in[i][1].second) == 1)in[i].clear();\n    }\n    int ans=0;\n    while(true){\n      bool iserased=false;\n      rep(i,26){\n\tif (in[i].size() == 0)continue;\n\tif (erase(r,c,in[i][0].first,in[i][0].second,in[i][1].first,in[i][1].second))ans+=2,iserased=true,in[i].clear();\n      }\n      if (!iserased)break;\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\n\nstring field[505];\nint ans = 0;\nint H, W;\nint Left[505][505];\nint Right[505][505];\nint Up[505][505];\nint Down[505][505];\n\nvector<i_i> g(int h, int w) {\n    vector<i_i> ret;\n    while(Up[h][w] > 0) {\n        if(field[Up[h][w]][w] != '.') {\n            ret.push_back({Up[h][w], w});\n            break;\n        }\n        Up[h][w]--;\n    }\n    while(Down[h][w] <= H) {\n        if(field[Down[h][w]][w] != '.') {\n            ret.push_back({Down[h][w], w});\n            break;\n        }\n        Down[h][w]++;\n    }\n    while(Left[h][w] > 0) {\n        if(field[h][Left[h][w]] != '.') {\n            ret.push_back({h, Left[h][w]});\n            break;\n        }\n        Left[h][w]--;\n    }\n    while(Right[h][w] <= W) {\n        if(field[h][Right[h][w]] != '.') {\n            ret.push_back({h, Right[h][w]});\n            break;\n        }\n        Right[h][w]++;\n    }\n    return ret;\n}\nbool f() {\n    for(int h = 1; h <= H; h++) {\n        for(int w = 1; w <= W; w++) {\n            if(field[h][w] != '.') continue;\n            vector<i_i> ret = g(h, w);\n            for(int i = 0; i < ret.size(); i++) {\n                for(int j = i + 1; j < ret.size(); j++) {\n                    if(field[ret[i].first][ret[i].second] == field[ret[j].first][ret[j].second]) {\n                        field[ret[i].first][ret[i].second] = '.';\n                        field[ret[j].first][ret[j].second] = '.';\n                        ans += 2;\n                        return true;\n                    }\n                }\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> H >> W;\n    for(int h = 1; h <= H; h++) {\n        cin >> field[h];\n        field[h] = \"#\" + field[h];\n    }\n    for(int h = 1; h <= H; h++) {\n        for(int w = 1; w <= W; w++) {\n            Left[h][w] = w-1;\n            Right[h][w] = w+1;\n            Up[h][w] = h-1;\n            Down[h][w] = h+1;\n        }\n    }\n    while(true) {\n        if(!f()) break;\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cctype>\n#include <vector>\n#include <map>\n#include <cassert>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0 ; i < n ; i++)\n\ntypedef pair<int, int> P;\n\nstruct Point{\n  int x, y;\n  Point(int a, int b){\n    x = a, y = b;\n  }\n};\n\nconst int MAX = 510;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nchar field[MAX][MAX];\nbool found[26];\nvector<Point> alpha[26];\nint H, W;\n\nbool checkH(int x1, int x2, int y, char c){\n  if(x1 > x2) swap(x1, x2);\n  for(int j = x1 ; j <= x2 ; j++){\n    if(field[y][j] != '.' && field[y][j] != c) return false;\n  }\n  return true;\n}\n\nbool checkW(int y1, int y2, int x, char c){\n  if(y1 > y2) swap(y1, y2);\n  for(int i = y1 ; i <= y2 ; i++){\n    if(field[i][x] != '.' && field[i][x] != c) return false;\n  }\n  return true;\n}\n\nint main(){\n  while(cin >> H >> W){\n    rep(i, H) cin >> field[i];\n    \n    memset(alpha, 0, sizeof(alpha));\n    memset(found, 0, sizeof(found));\n    \n    rep(i, H){\n      rep(j, W){\n\tif(isalpha(field[i][j])){\n\t  int c = field[i][j]-'A';\n\t  if(!found[c]){\n\t    found[c] = true;\n\t    alpha[c].push_back(Point(j, i));\n\t    //alpha[c].x1 = j, alpha[c].y1 = i;\n\t  }\n\t  else{\n\t    alpha[c].push_back(Point(j, i));\n\t    //alpha[c].x2 = j, alpha[c].y2 = i;\n\t  }\n\t}\n      }\n    }\n    \n    vector<Point> cross[26];\n    rep(i, 26){\n      if(found[i]){\n\tcross[i].push_back(Point(alpha[i][0].x, alpha[i][1].y));\n\tcross[i].push_back(Point(alpha[i][1].x, alpha[i][0].y));\n\t//cross[i].x1 = alpha[i].x1, cross[i].y1 = alpha[i].y2;\n\t//cross[i].x2 = alpha[i].x2, cross[i].y2 = alpha[i].y1;\n      }\n    }\n    \n    rep(i, 26){\n      assert(alpha[i].size() == 2 || alpha[i].size() == 0);\n    }\n    \n    rep(i, H){\n      rep(j, W){\n\trep(k, 4){\n\t  int nx = j+dx[k], ny = i+dy[k];\n\t  if(nx < 0 || nx > W || ny < 0 || ny > H) continue;\n\t  if(field[i][j] == field[ny][nx]) found[field[i][j]-'A'] = false;\n\t}\n      }\n    }\n    \n    int ans = 0;\n    for(; ;){\n    Start:;\n      bool flag = false;\n      rep(i, 26){\n\tif(found[i]){\t  \n\t  int X1 = cross[i][0].x, Y1 = cross[i][0].y, X2 = cross[i][1].x, Y2 = cross[i][1].y;\n\t  int x1 = alpha[i][0].x, y1 = alpha[i][0].y, x2 = alpha[i][1].x, y2 = alpha[i][1].y;\n\t  char c = 'A'+i;\n\t  \n\t  if(x1 == x2){\n\t    flag = checkW(y1, y2, x1, c);\n\t  }\n\t  else if(y1 == y2){\n\t    flag = checkH(x1, x2, y1, c);\t    \n\t  }\n\t  else{\n\t    if(((checkH(X1, x2, Y1, c) && (checkW(Y1, y1, X1, c)))) ||\n\t       ((checkH(X2, x1, Y2, c) && (checkW(Y2, y2, X2, c))))){\n\t      flag = true;\n\t    }\n\t  }\n\t  \n\t  if(flag){\n\t    //cout << c << endl;\n\t    found[i] = false;\n\t    ans += 2;\n\t    field[y1][x1] = '.', field[y2][x2] = '.';\t    \n\t    goto Start;\n\t  }\n\t  \n\t}\n      }\n      if(!flag) break;\n    }\n    cout << ans << endl;\n  }  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\npii pos[26][2];\nint num[26];\nstring in[510];\n\nint main(void){\n\tint m,n;\n\tcin >> m >> n;\n\trep(i,m) cin >> in[i];\n\trep(i,m)rep(j,n){\n\t\tif(in[i][j]=='.')\n\t\t\tcontinue;\n\t\tint cur=in[i][j]-'A';\n\t\tpos[cur][num[cur]].first=i;\n\t\tpos[cur][num[cur]++].second=j;\n\t}\n\tint ans=0;\n\trep(loop,26)rep(i,26) if(num[i]==2){\n\t\tbool ok=false;\n\t\tif(pos[i][0].first==pos[i][1].first){\n\t\t\tok=true;\n\t\t\tfor(int j=pos[i][0].second+1;j<pos[i][1].second;++j)\n\t\t\t\tif(in[pos[i][0].first][j]!='.')\n\t\t\t\t\tok=false;\n\t\t}else if(pos[i][0].second==pos[i][1].second){\n\t\t\tok=true;\n\t\t\tfor(int j=pos[i][0].first+1;j<pos[i][1].first;++j)\n\t\t\t\tif(in[j][pos[i][0].second]!='.')\n\t\t\t\t\tok=false;\n\t\t}else if(in[pos[i][1].first][pos[i][0].second]=='.'){\n\t\t\tok=true;\n\t\t\tfor(int j=min(pos[i][0].first,pos[i][1].first)+1;j<max(pos[i][0].first,pos[i][1].first);++j)\n\t\t\t\tif(in[j][pos[i][0].second]!='.')\n\t\t\t\t\tok=false;\n\t\t\tfor(int j=min(pos[i][0].second,pos[i][1].second)+1;j<max(pos[i][0].second,pos[i][1].second);++j)\n\t\t\t\tif(in[pos[i][1].first][j]!='.')\n\t\t\t\t\tok=false;\n\t\t}else if(in[pos[i][0].first][pos[i][1].second]=='.'){\n\t\t\tok=true;\n\t\t\tfor(int j=min(pos[i][0].first,pos[i][1].first)+1;j<max(pos[i][0].first,pos[i][1].first);++j)\n\t\t\t\tif(in[j][pos[i][1].second]!='.')\n\t\t\t\t\tok=false;\n\t\t\tfor(int j=min(pos[i][0].second,pos[i][1].second)+1;j<max(pos[i][0].second,pos[i][1].second);++j)\n\t\t\t\tif(in[pos[i][0].first][j]!='.')\n\t\t\t\t\tok=false;\n\t\t}\n\n\t\tif(ok){\n\t\t\tin[pos[i][0].first][pos[i][0].second]='.';\n\t\t\tin[pos[i][1].first][pos[i][1].second]='.';\n\t\t\tans+=2,num[i]=0;\n\t\t}\n\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main(){\n  int n, m;\n  cin >> m >> n;\n  vector<string> C(m);\n  vector< vector<int> > A(26);\n  for(int i = 0; i < m; ++i){\n    cin >> C[i];\n    for(int j = 0; j < n; ++j){\n      if(C[i][j] != '.') A[C[i][j]-'A'].push_back(i*n+j);\n    }\n  }\n  int ans = 0;\n  for(int i = 0; i < 26; ++i){\n    for(int j = 0; j < 26; ++j){\n      if(A[j].empty()) continue;\n      int a = A[j][0]/n, b = A[j][0]%n, c = A[j][1]/n, d = A[j][1]%n;\n      bool f = true;\n      for(int k = min(b,d)+1; k < max(b,d); ++k){\n        if(C[a][k] != '.'){\n          f = false;\n          break;\n        }\n      }\n      for(int k = min(a,c)+1; k < max(a,c); ++k){\n        if(C[k][d] != '.'){\n          f = false;\n          break;\n        }\n      }\n      if(a != c && b != d && C[a][d] != '.') f = false;\n      if(f){\n        //cout << (char)('A'+j) << endl;\n        C[a][b] = '.';\n        C[c][d] = '.';\n        ans += 2;\n        A[j] = vector<int>(0);\n        continue;\n      }\n      f = true;\n      for(int k = min(b,d)+1; k < max(b,d); ++k){\n        if(C[c][k] != '.'){\n          f = false;\n          break;\n        }\n      }\n      for(int k = min(a,c)+1; k < max(a,c); ++k){\n        if(C[k][b] != '.'){\n          f = false;\n          break;\n        }\n      }\n      if(a != c && b != d && C[c][b] != '.') f = false;\n      if(f){\n        //cout << (char)('A'+j) << endl;\n        C[a][b] = '.';\n        C[c][d] = '.';\n        ans += 2;\n        A[j] = vector<int>(0);\n        continue;\n      }\n    }\n  }\n  cout << ans << endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N, M;\n\nint main() {\n    cin >> N >> M;\n    vector<string> v(N);\n    for (int i = 0; i < N; i++) cin >> v[i];\n\n    vector<bool> h(N, false), w(M, false);\n    for (int i = 0; i < N; i++)\n        for (int j = 0; j < M; j++)\n            if (v[i][j] != '.') h[i] = true, w[j] = true;\n\n    vector<string> V;\n    for (int i = 0, count = 0; i < N; i++) {\n        if (!h[i]) continue;\n        V.push_back(\"\");\n        for (int j = 0; j < M; j++) {\n            if (w[j]) V[V.size() - 1] += v[i][j];\n        }\n    }\n\n    int ans = 0;\n    while (1) {\n        int pre = ans;\n\n        for (int i = 0, H = V.size(); i < H; i++) {\n            for (int j = 0, W = V[i].size(); j < W; j++) {\n                if (V[i][j] != '.') continue;\n                int up = i, down = i, left = j, right = j;\n                while (up >= 0 && V[up][j] == '.') up--;\n                while (down < H && V[down][j] == '.') down++;\n                while (left >= 0 && V[i][left] == '.') left--;\n                while (right < W && V[i][right] == '.') right++;\n\n                string tmp;\n                if (up >= 0) tmp += V[up][j];\n                if (down < H) tmp += V[down][j];\n                if (left >= 0) tmp += V[i][left];\n                if (right < W) tmp += V[i][right];\n\n                string same;\n                for (int k = 0; k < tmp.size(); k++) {\n                    for (int l = k + 1; l < tmp.size(); l++) {\n                        if (tmp[k] == tmp[l]) same += tmp[k];\n                    }\n                }\n\n                if (up >= 0 && same.find(V[up][j]) != string::npos) V[up][j] = '.';\n                if (left >= 0 && same.find(V[i][left]) != string::npos) V[i][left] = '.';\n                if (down < H && same.find(V[down][j]) != string::npos) V[down][j] = '.';\n                if (right < W && same.find(V[i][right]) != string::npos) V[i][right] = '.';\n\n                ans += same.size() * 2;\n            }\n        }\n\n        if (ans == pre) break;\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define ll long long\n#define rep(i,l,r)for(ll i=(l);i<(r);i++)\n\nchar s[510][510];\nint ss[30][2];\n\nint main(){\n\tint h,w;\n\tscanf(\"%d%d\",&h,&w);\n\trep(i,0,h)scanf(\" %s\",s[i]);\n\trep(c,0,26)ss[c][0]=ss[c][1]=-1;\n\t\n\trep(c,0,26){\n\t\tint x1=-1,x2,y1,y2;\n\t\trep(i,0,h)rep(j,0,w)if(s[i][j]=='A'+c){\n\t\t\tif(x1==-1){\n\t\t\t\tx1=i;\n\t\t\t\ty1=j;\n\t\t\t}else{\n\t\t\t\tx2=i;\n\t\t\t\ty2=j;\n\t\t\t}\n\t\t}\n\t\tif(x1!=-1){\n\t\t\t//間にある文字を求める\n\t\t\tif(x1==x2){\n\t\t\t\tif(abs(y1-y2)!=1){\n\t\t\t\t\tss[c][0]=0;\n\t\t\t\t\trep(j,y1+1,y2)if(s[x1][j]!='.')ss[c][0]|=1LL<<(s[x1][j]-'A');\n\t\t\t\t}\n\t\t\t}else if(y1==y2){\n\t\t\t\tif(abs(x1-x2)!=1){\n\t\t\t\t\tss[c][0]=0;\n\t\t\t\t\trep(i,x1+1,x2)if(s[i][y1]!='.')ss[c][0]|=1LL<<(s[i][y1]-'A');\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tss[c][0]=ss[c][1]=0;\n\t\t\t\tif(y1<y2){\n\t\t\t\t\t//左上から右下\n\t\t\t\t\trep(i,x1+1,x2+1)if(s[i][y1]!='.')ss[c][0]|=1LL<<(s[i][y1]-'A');\n\t\t\t\t\trep(j,y1+1,y2  )if(s[x2][j]!='.')ss[c][0]|=1LL<<(s[x2][j]-'A');\n\t\t\t\t\trep(j,y1+1,y2+1)if(s[x1][j]!='.')ss[c][1]|=1LL<<(s[x1][j]-'A');\n\t\t\t\t\trep(i,x1+1,x2  )if(s[i][y2]!='.')ss[c][1]|=1LL<<(s[i][y2]-'A');\n\t\t\t\t}else{\n\t\t\t\t\t//右上から左下\n\t\t\t\t\trep(i,x1+1,x2+1)if(s[i][y1]!='.')ss[c][0]|=1LL<<(s[i][y1]-'A');\n\t\t\t\t\trep(j,y2+1,y1  )if(s[x2][j]!='.')ss[c][0]|=1LL<<(s[x2][j]-'A');\n\t\t\t\t\trep(j,y2+1,y1  )if(s[x1][j]!='.')ss[c][1]|=1LL<<(s[x1][j]-'A');\n\t\t\t\t\trep(i,x1  ,x2  )if(s[i][y2]!='.')ss[c][1]|=1LL<<(s[i][y2]-'A');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\tint flag=1;\n\tint ans=0;\n\twhile(flag){\n//\trep(i,0,26)printf(\"%c %d %d\\n\",'A'+i,ss[i][0],ss[i][1]);\n\t\tflag=0;\n\t\trep(c,0,26)if(ss[c][0]==0||ss[c][1]==0){\n\t\t\tflag=1;\n\t\t\tans+=2;\n\t\t\tss[c][0]=ss[c][1]=-1;\n\t\t\trep(i,0,26)rep(k,0,2)if(ss[i][k]!=-1)ss[i][k]&=~(1LL<<c);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\t\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint Y[]={0,1,0,-1};\nint X[]={1,0,-1,0};\nint main(){\n  int h,w,x[30][3],y[30][3],i,j,k,l,ny,nx,p=0,r[30]={0};\n  char s[510][510]={0};\n  scanf(\"%d %d\",&h,&w);\n  for(i=1;i<=h;i++){\n    for(j=1;j<=w;j++){\n      scanf(\" %c\",&s[i][j]);\n      if(s[i][j]-'.'){\n\tp=s[i][j]-'A';\n\ty[p][r[p]  ]=i;\n\tx[p][r[p]++]=j;\n      }\n    }\n  }\n  p=0;\n  FRONT:;\n  for(i=0;i<26;i++){\n    if(r[i]==0)continue;\n    int d[30][30]={0};\n    for(l=0;l<2;l++){\n      for(j=0;j<4;j++){\n\tfor(k=1;1;k++){\n\t  ny=Y[j]*k+y[i][l];\n\t  nx=X[j]*k+x[i][l];\n\t  if(s[ny][nx]-'.')break;\n\t  d[ny][nx]++;\n\t  if(d[ny][nx]==2){\n\t    s[y[i][0]][x[i][0]]=s[y[i][1]][x[i][1]]='.';\n\t    p+=2;\n\t    r[i]=0;\n\t    goto FRONT;\n\t  }\n\t}\n      }\n    }\n  }\n  printf(\"%d\\n\",p);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2299:   Tiles are Colorful\n// 2017.12.10\n\n#include <stdio.h>\n#include <string.h>\n\nint m, n, k;\nchar map[501][503];\nint mv[4][2] = {{-1,0},{1,0},{0,1},{0,-1}};\nint rpos[26], cpos[26];\nint sr[501], sc[501];\n\nint calc()\n{\n\tint r, c, i, r2, c2, a, ans = 0;\n\tfor (r = 0; r < m; r++) for (c = 0; c < n; c++) \n\t\tif ((sr[c] + sc[r]) && map[r][c] == '.' ) {\n\t\t\tmemset(rpos, -1, sizeof(rpos));\n\n\t\t    for (i = 0; i < 4; i++) {\n\t\t\t\tif (!sr[c]) { if (i < 2) continue; }\n\t\t\t\tif (!sc[r]) { if (i > 2) continue; }\n\n\t\t\t\tr2 = r, c2 = c;\n\t\t\t\twhile (1) {\n\t\t\t\t\tr2 += mv[i][0], c2 += mv[i][1];\n\t\t\t\t\tif (r2 < 0 || r2 >= m || c2 < 0 || c2 >= n) break;\n\t\t\t\t\tif (map[r2][c2] == '.') continue;\n\n\t                a = map[r2][c2]-'A';\n\t\t\t\t\tif (rpos[a] >= 0) {\n\t                    map[r2][c2] = '.', sr[c2]--, sc[r2]--;\n\t\t\t\t\t\tr2 = rpos[a], c2 = cpos[a];\n\t                    map[r2][c2] = '.', sr[c2]--, sc[r2]--;\n\t                    ans += 2, k -= 2;\n\t\t\t\t\t\tif (!k) return ans;\n\t\t\t\t\t} else rpos[a] = r2, cpos[a] = c2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n            }\n        }\n\n\treturn ans;\n}\n\nint main()\n{\n\tint r, c, t, k, ans;\n\tchar buf[10];\n\n    fgets(buf, 10, stdin);\n\tsscanf(buf, \"%d%d\", &m, &n);\n\tfor (k = 0, r = 0; r < m; r++) {\n\t\tfgets(map[r], 503, stdin);\n\t\tfor (c = 0; c < n; c++) {\n\t\t\tif (map[r][c] != '.') k++, sr[c]++, sc[r]++;\n\t\t}\n\t}\n\tans = 0;\n\tdo t = calc(), ans += t;\n\twhile (t && k);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2299:   Tiles are Colorful\n// 2017.12.10\n\n#include <stdio.h>\n#include <string.h>\n\nint m, n;\nchar map[501][503];\nint mv[4][2] = {{-1,0},{1,0},{0,1},{0,-1}};\nint rpos['Z'+1], cpos['Z'+1];\nint sr[501], sc[501];\n\nint calc()\n{\n\tint r, c, i, r2, c2, a, ans = 0;\n\tfor (r = 0; r < m; r++) for (c = 0; c < n; c++) \n\t\tif ((sr[c] + sc[r]) && map[r][c] == '.' ) {\n\t\t\tmemset(rpos, -1, sizeof(rpos));\n\n\t\t    for (i = 0; i < 4; i++) {\n\t\t\t\tif (!sr[c]) { if (i < 2) continue; }\n\t\t\t\tif (!sc[r]) { if (i > 2) continue; }\n\n\t\t\t\tr2 = r, c2 = c;\n\t\t\t\twhile (1) {\n\t\t\t\t\tr2 += mv[i][0], c2 += mv[i][1];\n\t\t\t\t\tif (r2 < 0 || r2 >= m || c2 < 0 || c2 >= n) break;\n\t\t\t\t\tif (map[r2][c2] == '.') continue;\n\n\t                a = map[r2][c2];\n\t\t\t\t\tif (rpos[a] >= 0) {\n\t                    map[r2][c2] = '.', sr[c2]--, sc[r2]--;\n\t\t\t\t\t\tr2 = rpos[a], c2 = cpos[a];\n\t                    map[r2][c2] = '.', sr[c2]--, sc[r2]--;\n\t                    ans += 2;\n\t\t\t\t\t} else rpos[a] = r2, cpos[a] = c2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n            }\n        }\n\n\treturn ans;\n}\n\nint main()\n{\n\tint r, c, t, ans;\n\tchar buf[10];\n\n    fgets(buf, 10, stdin);\n\tsscanf(buf, \"%d%d\", &m, &n);\n\tfor (r = 0; r < m; r++) {\n\t\tfgets(map[r], 503, stdin);\n\t\tfor (c = 0; c < n; c++) {\n\t\t\tif (map[r][c] != '.') sr[c]++, sc[r]++;\n\t\t}\n\t}\n\tans = 0; while (t = calc()) ans += t;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2299:   Tiles are Colorful\n// 2017.12.10\n\n#include <stdio.h>\n#include <string.h>\n\nint m, n;\nchar map[501][503];\nint mv[4][2] = {{-1,0},{1,0},{0,1},{0,-1}};\nint rpos['Z'+1], cpos['Z'+1];\nint sr[501], sc[501];\n\nint calc()\n{\n\tint r, c, i, r2, c2, a, ans = 0;\n\tfor (r = 0; r < m; r++) for (c = 0; c < n; c++) \n\t\tif ((sr[c] + sc[r]) && map[r][c] == '.' ) {\n\t\t\tmemset(rpos, -1, sizeof(rpos));\n\n\t\t    for (i = 0; i < 4; i++) {\n\t\t\t\tif (!sr[c]) { if (i < 2) continue; }\n\t\t\t\tif (!sc[r]) { if (i > 2) continue; }\n\n\t\t\t\tr2 = r, c2 = c;\n\t\t\t\twhile (1) {\n\t\t\t\t\tr2 += mv[i][0], c2 += mv[i][1];\n\t\t\t\t\tif (r2 < 0 || r2 >= m || c2 < 0 || c2 >= n) break;\n\t\t\t\t\tif (map[r2][c2] == '.') continue;\n\n\t                a = map[r2][c2];\n\t\t\t\t\tif (rpos[a] >= 0) {\n\t                    map[r2][c2] = '.', sr[c2]--, sc[r2]--;\n\t\t\t\t\t\tr2 = rpos[a], c2 = cpos[a];\n\t                    map[r2][c2] = '.', sr[c2]--, sc[r2]--;\n\t                    ans += 2;\n\t\t\t\t\t} else rpos[a] = r2, cpos[a] = c2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n            }\n        }\n\n\treturn ans;\n}\n\nint main()\n{\n\tint r, c, t, k, ans;\n\tchar buf[10];\n\n    fgets(buf, 10, stdin);\n\tsscanf(buf, \"%d%d\", &m, &n);\n\tfor (k = 0, r = 0; r < m; r++) {\n\t\tfgets(map[r], 503, stdin);\n\t\tfor (c = 0; c < n; c++) {\n\t\t\tif (map[r][c] != '.') k++, sr[c]++, sc[r]++;\n\t\t}\n\t}\n\tans = 0;\n\twhile (1) {\n\t\tif (!(t = calc())) break;\n\t\tans += t, k -= t;\n\t\tif (!k) break;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint Y[]={0,1,0,-1};\nint X[]={1,0,-1,0};\nint main(){\n  int h,w,x[30][3],y[30][3],i,j,k,l,ny,nx,p=0,r[30]={0};\n  char s[510][510]={0};\n  scanf(\"%d %d\",&h,&w);\n  for(i=1;i<=h;i++){\n    for(j=1;j<=w;j++){\n      scanf(\" %c\",&s[i][j]);\n      if(s[i][j]-'.'){\n\tp=s[i][j]-'A';\n\ty[p][r[p]  ]=i;\n\tx[p][r[p]++]=j;\n      }\n    }\n  }\n  p=0;\n  FRONT:;\n  for(i=0;i<26;i++){\n    if(r[i]==0)continue;\n    int d[510][510]={0};\n    for(l=0;l<2;l++){\n      for(j=0;j<4;j++){\n\tfor(k=1;1;k++){\n\t  ny=Y[j]*k+y[i][l];\n\t  nx=X[j]*k+x[i][l];\n\t  if(s[ny][nx]-'.')break;\n\t  d[ny][nx]++;\n\t  if(d[ny][nx]==2){\n\t    s[y[i][0]][x[i][0]]=s[y[i][1]][x[i][1]]='.';\n\t    p+=2;\n\t    r[i]=0;\n\t    goto FRONT;\n\t  }\n\t}\n      }\n    }\n  }\n  printf(\"%d\\n\",p);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint Y[]={0,1,0,-1};\nint X[]={1,0,-1,0};\nint main(){\n  int i,j,k,l,h,w,ans=0,r[30]={0};\n  int y[30][2],x[30][2],t[30]={0};\n  char d[510][510]={0};\n  scanf(\"%d %d\",&h,&w);\n  for(i=1;i<=h;i++){\n    for(j=1;j<=w;j++){\n      scanf(\" %c\",&d[i][j]);\n      if(d[i][j]-'.'){\n\tk=d[i][j]-'A';\n\ty[k][r[k]  ]=i;\n\tx[k][r[k]++]=j;\n\tt[k]=1;\n      }\n    }\n  }\n  for(i=0;i<26;i++){\n  FRONT:\n    if(t[i]==0)continue;\n    int f[510][510]={0};\n    for(j=0;j<2;j++){\n      for(k=0;k<4;k++){\n\tfor(l=1;d[y[i][j]+Y[k]*l][x[i][j]+X[k]*l]=='.';l++){\n\t  f[y[i][j]+Y[k]*l][x[i][j]+X[k]*l]++;\n\t  if(f[y[i][j]+Y[k]*l][x[i][j]+X[k]*l]==2){\n\t    ans+=2;\n\t    d[y[i][0]][x[i][0]]=d[y[i][1]][x[i][1]]='.';\n\t    i=t[i]=0;\n\t    goto FRONT;\n\t  }\n\t}\n      }\n    }\n  }\n  printf(\"%d\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2299:   Tiles are Colorful\n// 2017.12.10\n\n#include <stdio.h>\n#include <string.h>\n\nint m, n;\nchar map[501][503];\nint mv[4][2] = {{-1,0},{0,1},{1,0},{0,-1}};\nint rpos['Z'+1], cpos['Z'+1];\nint sr[501], sc[501];\n\nint calc()\n{\n\tint r, c, i, r2, c2, a, ans = 0;\n\tfor (r = 0; r < m; r++) for (c = 0; c < n; c++) \n\t\tif ((sr[c] + sc[r]) && map[r][c] == '.' ) {\n\t\t\tmemset(rpos, -1, sizeof(rpos));\n\n\t\t    for (i = 0; i < 4; i++) {\n\t\t\t\tr2 = r, c2 = c;\n\t\t\t\twhile (1) {\n\t\t\t\t\tr2 += mv[i][0], c2 += mv[i][1];\n\t\t\t\t\tif (r2 < 0 || r2 >= m || c2 < 0 || c2 >= n) break;\n\t\t\t\t\tif (map[r2][c2] == '.') continue;\n\n\t                a = map[r2][c2];\n\t\t\t\t\tif (rpos[a] >= 0) {\n\t                    map[r2][c2] = '.', sr[c2]--, sc[r2]--;\n\t\t\t\t\t\tr2 = rpos[a], c2 = cpos[a];\n\t                    map[r2][c2] = '.', sr[c2]--, sc[r2]--;\n\t                    ans += 2;\n\t\t\t\t\t} else rpos[a] = r2, cpos[a] = c2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n            }\n        }\n\n\treturn ans;\n}\n\nint main()\n{\n\tint r, c, t, ans;\n\tchar buf[10];\n\n    fgets(buf, 10, stdin);\n\tsscanf(buf, \"%d%d\", &m, &n);\n\tfor (r = 0; r < m; r++) {\n\t\tfgets(map[r], 503, stdin);\n\t\tfor (c = 0; c < n; c++) {\n\t\t\tif (map[r][c] != '.') sr[c]++, sc[r]++;\n\t\t}\n\t}\n\tans = 0; while (t = calc()) ans += t;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\nint M,N,i,j,k,l,nc,nr,S,t,c,mv[5]={0,1,0,-1,0};\nchar C[505][505],*p[4];\n\nint main()\n{\n\tscanf(\"%d%d\\n\",&M,&N);\n\tfor(i=1;i<=M;i++)gets(C[i]+1);\n\tfor(S=0;;)\n\t{\n\t\tfor(i=1,c=0;i<=M;i++)\n\t\t\tfor(j=1;j<=N;j++)\n\t\t\t\tif(C[i][j]=='.')\n\t\t\t\t{\n\t\t\t\t\tfor(k=0;k<4;k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(nc=i,nr=j;C[nc][nr]=='.';nc+=mv[k],nr+=mv[k+1]);\n\t\t\t\t\t\tp[k]=&C[nc][nr];\n\t\t\t\t\t}\n\t\t\t\t\tfor(k=0;k<4;k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(l=k+1,t=0;l<4;l++)\n\t\t\t\t\t\t\tif(*p[k]&&*p[k]!='.'&&(*p[k]==*p[l]))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt++;*p[l]='.';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tif(t)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tc=1;\n\t\t\t\t\t\t\tS+=t+1;*p[k]='.';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\tif(c==0)break;\n\t}\n\tprintf(\"%d\\n\",S);\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\tnew Main().run();\n\t}\n\t\n\tScanner scanner = new Scanner(System.in);\n\tint m;\n\tint[][][] tile = new int[26][2][2];\n\tboolean[][] cantGet =new boolean[26][2];\n\tint score = 0;\n\t\n\tvoid run() {\n\t\t\n\t\tm = scanner.nextInt();\n\t\tscanner.nextInt();\n\t\t\n\t\tfor (int color = 0; color < 26; color ++) {\n\t\t\t\n\t\t\ttile[color][0][0] = -1;\n\t\t\tcantGet[color][0] = false;\n\t\t\tcantGet[color][1] = false;\n\t\t}\n\t\t\n\t\tfor (int y = 0; y < m; y ++) {\n\t\t\t\n\t\t\tchar[] line = scanner.next().toCharArray();\n\t\t\t\n\t\t\tfor (int x = 0; x < line.length; x ++) {\n\t\t\t\t\n\t\t\t\tif(line[x] != '.') {\n\t\t\t\t\t\n\t\t\t\t\tint color = line[x] - 'A';\n\t\t\t\t\tint index = (tile[color][0][0] == -1) ? 0: 1;\n\t\t\t\t\ttile[color][index][0] = x;\n\t\t\t\t\ttile[color][index][1] = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int color = 0; color < 26; color ++) {\n\t\t\t\n\t\t\tif (tile[color][0][0] != -1) {\n\t\t\t\t\n\t\t\t\ttryGet(color);\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(score * 2);\n\t}\n\t\n\tboolean tryGet(int color) {\n\t\t\n\t\tif (! cantGet[color][0]) {\n\t\t\t\n\t\t\tif ((tile[color][0][0] == tile[color][1][0]\n\t\t\t\t\t&& Math.abs(tile[color][0][1] - tile[color][1][1]) == 1)\n\t\t\t\t\t|| (tile[color][0][1] == tile[color][1][1]\n\t\t\t\t\t&& Math.abs(tile[color][0][0] - tile[color][1][0]) == 1)) {\n\t\t\t\t\n\t\t\t\tcantGet[color][0] = true;\n\t\t\t\tcantGet[color][1] = true;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tcantGet[color][0] = true;\n\t\t\tif((isEmpty(color, 1, tile[color][0][0], tile[color][0][1], tile[color][1][1])\n\t\t\t\t\t&& isEmpty(color, 0, tile[color][1][1], tile[color][0][0], tile[color][1][0]))) {\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif (tile[color][0][0] != -1) {\n\t\t\t\t\t\n\t\t\t\t\ttile[color][0][0] = -1;\n\t\t\t\t\tscore ++;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (! cantGet[color][1]) {\n\t\t\t\n\t\t\tcantGet[color][1] = true;\n\t\t\tif ((isEmpty(color, 1, tile[color][1][0], tile[color][0][1], tile[color][1][1])\n\t\t\t\t\t&& isEmpty(color, 0, tile[color][0][1], tile[color][0][0], tile[color][1][0]))) {\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif (tile[color][0][0] != -1) {\n\t\t\t\t\t\n\t\t\t\t\ttile[color][0][0] = -1;\n\t\t\t\t\tscore ++;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcantGet[color][0] = false;\n\t\t\tcantGet[color][1] = false;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tboolean isEmpty(int skip,int axis, int point, int start, int end) {\n\t\t\n\t\t\n\t\tif (start == end) {\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tif (start > end) {\n\t\t\t\n\t\t\tint swap = start;\n\t\t\tstart = end;\n\t\t\tend = swap;\n\t\t}\n\t\t\n\t\tfor (int color = 0; color < 26; color ++) {\n\t\t\t\n\t\t\tif (color == skip\n\t\t\t\t\t|| tile[color][0][0] == -1) {\n\t\t\t\t\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int index = 0; index < 2; index ++) {\n\t\t\t\t\n\t\t\t\tif (tile[color][index][1 - axis] == point\n\t\t\t\t\t\t&& tile[color][index][axis] >= start\n\t\t\t\t\t\t&& tile[color][index][axis] <= end\n\t\t\t\t\t\t&& !tryGet(color)) {\n\t\t\t\t\t\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\tnew Main().run();\n\t}\n\t\n\tScanner scanner = new Scanner(System.in);\n\tint m;\n\tint[][][] tile = new int[26][2][2];\n\tboolean[][] cantGet =new boolean[26][2];\n\tint score = 0;\n\t\n\tvoid run() {\n\t\t\n\t\tm = scanner.nextInt();\n\t\tscanner.nextInt();\n\t\t\n\t\tfor (int color = 0; color < 26; color ++) {\n\t\t\t\n\t\t\ttile[color][0][0] = -1;\n\t\t\tcantGet[color][0] = false;\n\t\t\tcantGet[color][1] = false;\n\t\t}\n\t\t\n\t\tfor (int y = 0; y < m; y ++) {\n\t\t\t\n\t\t\tchar[] line = scanner.next().toCharArray();\n\t\t\t\n\t\t\tfor (int x = 0; x < line.length; x ++) {\n\t\t\t\t\n\t\t\t\tif(line[x] != '.') {\n\t\t\t\t\t\n\t\t\t\t\tint color = line[x] - 'A';\n\t\t\t\t\tint index = (tile[color][0][0] == -1) ? 0: 1;\n\t\t\t\t\ttile[color][index][0] = x;\n\t\t\t\t\ttile[color][index][1] = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int color = 0; color < 26; color ++) {\n\t\t\t\n\t\t\tif (tile[color][0][0] != -1) {\n\t\t\t\t\n\t\t\t\ttryGet(color);\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(score * 2);\n\t}\n\t\n\tboolean tryGet(int color) {\n\t\t\n\t\tif (! cantGet[color][0]) {\n\t\t\t\n\t\t\tif ((tile[color][0][0] == tile[color][1][0]\n\t\t\t\t\t&& Math.abs(tile[color][0][1] - tile[color][1][1]) == 1)\n\t\t\t\t\t|| (tile[color][0][1] == tile[color][1][1]\n\t\t\t\t\t&& Math.abs(tile[color][0][0] - tile[color][1][0]) == 1)) {\n\t\t\t\t\n\t\t\t\tcantGet[color][0] = true;\n\t\t\t\tcantGet[color][1] = true;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tcantGet[color][0] = true;\n\t\t\tif((isEmpty(color, 1, tile[color][0][0], tile[color][0][1], tile[color][1][1])\n\t\t\t\t\t&& isEmpty(color, 0, tile[color][1][1], tile[color][0][0], tile[color][1][0]))) {\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif (tile[color][0][0] == -1) {\n\t\t\t\t\t\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\ttile[color][0][0] = -1;\n\t\t\t\tscore ++;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcantGet[color][0] = false;\n\t\t}\n\t\t\n\t\tif (! cantGet[color][1]) {\n\t\t\t\n\t\t\tcantGet[color][1] = true;\n\t\t\tif ((isEmpty(color, 1, tile[color][1][0], tile[color][0][1], tile[color][1][1])\n\t\t\t\t\t&& isEmpty(color, 0, tile[color][0][1], tile[color][0][0], tile[color][1][0]))) {\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif (tile[color][0][0] == -1) {\n\t\t\t\t\t\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\ttile[color][0][0] = -1;\n\t\t\t\tscore ++;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcantGet[color][1] = false;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tboolean isEmpty(int skip,int axis, int point, int start, int end) {\n\t\t\n\t\t\n\t\tif (start == end) {\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tif (start > end) {\n\t\t\t\n\t\t\tint swap = start;\n\t\t\tstart = end;\n\t\t\tend = swap;\n\t\t}\n\t\t\n\t\tfor (int color = 0; color < 26; color ++) {\n\t\t\t\n\t\t\tif (color == skip\n\t\t\t\t\t|| tile[color][0][0] == -1) {\n\t\t\t\t\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int index = 0; index < 2; index ++) {\n\t\t\t\t\n\t\t\t\tif (tile[color][index][1 - axis] == point\n\t\t\t\t\t\t&& tile[color][index][axis] >= start\n\t\t\t\t\t\t&& tile[color][index][axis] <= end\n\t\t\t\t\t\t&& !tryGet(color)) {\n\t\t\t\t\t\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\nimport java.awt.Point;\n\nclass Main{\n    \n    private static final int[] dx = {0,1,0,-1};\n    private static final int[] dy = {1,0,-1,0};\n    \n    static class Pox\n    {\n\tpublic int x,y;\n\tpublic char extraterrestrial;\n\t\n\tPox()\n\t{\n\t    x = y = -1;\n\t    extraterrestrial = 'a';\n\t}\n\t\n\tPox(char c,int a,int b)\n\t{\n\t    x = a;\n\t    y = b;\n\t    extraterrestrial = c;\n\t}\n\n    }\n    \n    \n    \n    static class PP\n    {\n\tPoint p1,p2;\n\t\n\tPP()\n\t{\n\t    p1 = new Point(-1,-1);\n\t    p2 = new Point(-1,-1);\n\t}\n\t\n\tPP(Point a,Point b)\n\t{\n\t    p1 = a;\n\t    p2 = b;\n\t}\n\t\n    }\n    \n    \n    public static void main(String args[])throws IOException\n    {\n\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tint M,N;\n\n\tString line;\n\twhile((line = in.readLine()) != null)\n\t    {\n\t\t\n\t\t\n\t\tM = Integer.parseInt(line.substring(0,line.indexOf(\" \")));\n\t\tN = Integer.parseInt(line.substring(line.indexOf(\" \") + 1));\n\t\t\n\t\tLinkedList<Pox> list = new LinkedList<Pox>();//アルファベットの座標\n\t\tLinkedList<Pox> M_list = new LinkedList<Pox>();//中継地点\n\t\tHashMap<Character,PP> map = new HashMap<Character,PP>();\n\t\tchar[][] cmap = new char[M][N];\n\t\t\n\t\t\n\t\tfor(int i=0;i<M;i++)\n\t\t    {\n\t\t\tline = in.readLine();\n\t\t\tfor(int j=0;j<N;j++)\n\t\t\t    {\n\t\t\t\t\n\t\t\t\tcmap[i][j] = line.charAt(j);\t\t\n\t\t\t\t\n\t\t\t\tif(line.charAt(j) != '.')\n\t\t\t\t    {\n\t\t\t\t\tlist.add(new Pox(line.charAt(j),j,i));\n\t\t\t\t\tif(!map.containsKey(line.charAt(j)))\n\t\t\t\t\t    {\n\t\t\t\t\t\tmap.put(line.charAt(j),new PP(new Point(j,i),new Point(-1,-1)));\n\t\t\t\t\t    }\n\t\t\t\t\telse\n\t\t\t\t\t    {\n\t\t\t\t\t\tint x,y,xx,yy;\n\t\t\t\t\t\tx = j;\n\t\t\t\t\t\ty = i;\n\t\t\t\t\t\txx = map.get(line.charAt(j)).p1.x;\n\t\t\t\t\t\tyy = map.get(line.charAt(j)).p1.y;\n\t\t\t\t\t\tmap.put(line.charAt(j),new PP(new Point(xx,yy),new Point(j,i)));\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(!(x == xx || y == yy))\n\t\t\t\t\t\t    {\n\t\t\t\t\t\t\tM_list.add(new Pox(line.charAt(j),x,yy));\n\t\t\t\t\t\t\tM_list.add(new Pox(line.charAt(j),xx,y));\n\t\t\t\t\t\t    }\n\t\t\t\t\t    }\n\t\t\t\t    } \n\t\t\t    }\n\t\t    }\n\t\t\n\n\t\tboolean[] used = new boolean[28];\t\n\t\tfor(int i=0;i<28;i++)\n\t\t    {\n\t\t\tused[i] = false;\n\t\t    }\n\t\t\n\t\tboolean finish = false;\n\t\tint cnt = 0;\n\t\twhile(!finish)\n\t\t    {\n\t\t\tfinish = true;\n\t\t\t\n\t\t\tfor(int i=0;i<list.size();i++)\n\t\t\t    {\n\t\t\t\tif(used[list.get(i).extraterrestrial - 'A'])\n\t\t\t\t    continue;\n\t\t\t\t\n\t\t\t\tint x,y,xx,yy;\n\t\t\t\tchar c = list.get(i).extraterrestrial;\n\t\t\t\tx = map.get(c).p1.x;\n\t\t\t\ty = map.get(c).p1.y;\n\t\t\t\txx = map.get(c).p2.x;\n\t\t\t\tyy = map.get(c).p2.y;\n\t\t\t\t\n\t\t\t\tint hx,hxx;\n\t\t\t\tint hy,hyy;\n\t\t\t\t\n\t\t\t\thx = Math.min(x,xx);\n\t\t\t\thxx = Math.max(x,xx);\n\t\t\t\t\n\t\t\t\thy = Math.min(y,yy);\n\t\t\t\thyy = Math.max(y,yy);\n\t\t\t\t\n\t\t\t\tif(!(x == xx || y == yy))\n\t\t\t\t    continue;\n\t\t\t\t\n\t\t\t\tboolean ok = true;\n\t\t\t\tfor(int j=0;j<list.size();j++)\n\t\t\t\t    {\n\t\t\t\t\tif(list.get(j).extraterrestrial == c)\n\t\t\t\t\t    continue;\n\t\t\t\t\t\n\t\t\t\t\tif(used[list.get(j).extraterrestrial-'A'])\n\t\t\t\t\t    continue;\n\t\t\t\t\t\n\t\t\t\t\tint list_x,list_y;\n\t\t\t\t\tlist_x = list.get(j).x;\n\t\t\t\t\tlist_y = list.get(j).y;\n\t\t\t\t\t\n\t\t\t\t\tif(x == xx)\n\t\t\t\t\t    {\n\t\t\t\t\t\tif(x == list_x)\n\t\t\t\t\t\t    {\n\t\t\t\t\t\t\tif(hy < list_y && list_y < hyy)\n\t\t\t\t\t\t\t    {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t    }\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t    {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t    }\n\t\t\t\t\t\t    }\n\t\t\t\t\t\telse\n\t\t\t\t\t\t    {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t    }\n\t\t\t\t\t    }\n\t\t\t\t\telse if(y == yy)\n\t\t\t\t\t    {\n\t\t\t\t\t\tif(y == list_y)\n\t\t\t\t\t\t    {\n\t\t\t\t\t\t\tif(hx < list_x && list_x < hxx)\n\t\t\t\t\t\t\t    {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t    }\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t    {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t    }\n\t\t\t\t\t\t    }\n\t\t\t\t\t\telse\n\t\t\t\t\t\t    {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t    }\n\n\t\t\t\t\t    }\n\t\t\t\t\n\n\t\t\t\t    }\n\n\t\t\t\tif(ok)\n\t\t\t\t    {\n\n\t\t\t\t\tint xp,yp;\n\t\t\t\t\txp = list.get(i).x;\n\t\t\t\t\typ = list.get(i).y;\n\n\t\t\t\t\tboolean NoWay = false;\t\t\t\t\n\n\t\t\t\t\tfor(int j=0;j<4;j++)\n\t\t\t\t\t    {\n\t\t\t\t\t\tint nx = xp + dx[j],ny = yp + dy[j];\n\t\t\t\t\t\tif(!(0<= nx && nx <N && 0<= ny && ny <M ))\n\t\t\t\t\t\t    continue;\n\n\t\t\t\t\t\tif(cmap[ny][nx] == list.get(i).extraterrestrial)\n\t\t\t\t\t\t    {\n\t\t\t\t\t\t\tNoWay = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t    }\n\t\t\t\t\t    }\n\n\t\t\t\t\tif(NoWay)\n\t\t\t\t\t    continue;\n\n\t\t\t\t\tcnt += 2;\n\t\t\t\t\tused[list.get(i).extraterrestrial-'A'] = true;\n\t\t\t\t\tfinish = false;\n\t\t\t\t    }\n\n\t\t\t    }\n\n\n\n\t\t\tfor(int i=0; i<M_list.size();i++)\n\t\t\t    {\n\t\t\t\tif(used[M_list.get(i).extraterrestrial-'A'])\n\t\t\t\t    continue;\n\n\t\t\t\tint mx,my,x1,y1,x2,y2;\n\n\t\t\t\tmx = M_list.get(i).x;\n\t\t\t\tmy = M_list.get(i).y;\n\n\t\t\t\tif(cmap[my][mx] != '.')\n\t\t\t\t    {\n\t\t\t\t\tif(!used[cmap[my][mx]-'A'])\n\t\t\t\t\t    {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t    }\n\t\t\t\t    }\n\n\t\t\n\t\t\t\tPoint pp = map.get(M_list.get(i).extraterrestrial).p1;\n\t\t\t\tPoint ppp = map.get(M_list.get(i).extraterrestrial).p2;\n\n\t\t\t\tx1 = pp.x;\n\t\t\t\ty1 = pp.y;\n\n\t\t\t\tx2 = ppp.x;\n\t\t\t\ty2 = ppp.y;\n\n\n\t\t\t\tif(x2 == -1 && y2 == -1)\n\t\t\t\t    continue;\n\n\n\t\t\t\tint hx,hy,hxx,hyy;\n\n\t\t\t\thx = Math.min(mx,x1);\n\t\t\t\thxx = Math.max(mx,x1);\n\t\t\t\thy = Math.min(my,y1);\t\t\t\n\t\t\t\thyy = Math.max(my,y1);\n\n\n\t\t\n\t\t      \n\n\t\t\t\tboolean ok = true;\n\t\t\t\tfor(int j=0;j<list.size();j++)\n\t\t\t\t    {\t\t\t\t    \n\t\t       \n\t\t\t\t\tif(used[list.get(j).extraterrestrial-'A'])\n\t\t\t\t\t    {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t    }\n\n\t\t\t\t\tif(list.get(j).extraterrestrial == M_list.get(i).extraterrestrial)\n\t\t\t\t\t    {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t    }\n\n\t\t\t\t\tint lx,ly;\n\t\t\t\t\tlx = list.get(j).x;\n\t\t\t\t\tly = list.get(j).y;\n\n\t\t\n\t\t\t\t\tif(mx == x1)\n\t\t\t\t\t    {\n\t\t\t\t\t\tif(mx != lx)\n\t\t\t\t\t\t    continue;\n\n\t\t\t\t\t\tif(hy < ly && ly < hyy)\n\t\t\t\t\t\t    {\n\t\t\t\t\t\t\tif(!used[cmap[ly][lx]-'A'])\n\t\t\t\t\t\t\t    {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t    }\n\t\t\t\t\t\t    }\n\t\t\t\t\t\telse\n\t\t\t\t\t\t    {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t    }\n\t\t\t\t\t    }\n\t\t\t\t\telse if(my == y1)\n\t\t\t\t\t    {\n\t\t\t\t\t\n\t\t\t\t\t\tif(my != ly)\n\t\t\t\t\t\t    continue;\n\t\t\t\t\t\tif(hx < lx && lx < hxx)\n\t\t\t\t\t\t    {\n\t\t\t\t\t\t\tif(!used[cmap[ly][lx]-'A'])\n\t\t\t\t\t\t\t    {    \n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t    }\n\t\t\t\t\t\t    }\n\t\t\t\t\t\telse\n\t\t\t\t\t\t    {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t    }\n\t\t\t\t\t    }\n\n\t\t\t\t    }\n\n\t\t\t\tif(!ok)\n\t\t\t\t    {\n\t\t\t\t\tcontinue;\n\t\t\t\t    }\n\n\t\t\n\t\t\t\tboolean ok2 = true;\n\t\t\t\thx = Math.min(mx,x2);\n\t\t\t\thxx = Math.max(mx,x2);\n\t\t\t\thy = Math.min(my,y2);\n\t\t\t\thyy = Math.max(my,y2);\n\n\t\t\t\tfor(int j=0;j<list.size();j++)\n\t\t\t\t    {\n\t\t\t\t\tif(used[list.get(j).extraterrestrial-'A'])\n\t\t\t\t\t    continue;\n\n\t\t\t\t\tif(list.get(j).extraterrestrial == M_list.get(i).extraterrestrial)\n\t\t\t\t\t    continue;\n\n\t\t\t\t\tint lx,ly;\n\t\t\t\t\tlx = list.get(j).x;\n\t\t\t\t\tly = list.get(j).y;\n\n\t\t       \n\t\t\t\t\tif(mx == x2)\n\t\t\t\t\t    {\n\n\t\t\t\t\t\tif(mx != lx)\n\t\t\t\t\t\t    {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t    }\n\t\t\t\t\t\n\t\t\t\t\t\tif(hy < ly && ly < hyy)\n\t\t\t\t\t\t    {\n\t\t\t\t\t\t\tif(!used[cmap[ly][lx]-'A'])\n\t\t\t\t\t\t\t    {\n\t\t\t\t\t\t\t\tok2 = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t    }\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t    continue;\n\t\t\t\t\t\t    }\n\t\t\t\t\t\telse\n\t\t\t\t\t\t    {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t    }\n\t\t\t\t\t    }\n\t\t\t\t\telse if(my == y2)\n\t\t\t\t\t    {\n\t\t\t\t\t\tif(my != ly)\n\t\t\t\t\t\t    {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t    }\n\n\t\t\t\t\t\tif(hx < lx && lx < hxx)\n\t\t\t\t\t\t    {\n\t\t\t\t\t\t\tif(!used[cmap[ly][lx]-'A'])\n\t\t\t\t\t\t\t    {\n\t\t\t\t\t\t\t\tok2 = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t    }\n\t\t\t\t\t\t\telse \n\t\t\t\t\t\t\t    continue;\n\t\t\t\t\t\t    }\n\t\t\t\t\t\telse\n\t\t\t\t\t\t    {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t    }\n\t\t\t\t\t    }\n\n\t\t\t\t    }\n\n\t\t\t\tif(ok && ok2)\n\t\t\t\t    {\n\t\t\t\t\tcnt+=2;\n\t\t\t\t\tfinish = false;\n\t\t\t\t\tused[M_list.get(i).extraterrestrial-'A'] = true;\n\t\t\t\t    }\n\n\n\t\t\t    }\n\n\n\t\t    }\n\n\t\tSystem.out.println(cnt);\n\t\n\t    }\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\n\n\nclass Main {\n\tstatic int[] vy = {1,0,-1,0};\n\tstatic int[] vx = {0,1,0,-1};\n\tstatic long mod = 1000000007;\n\tpublic static void main(String[] args) {\t\n\t\tFastScanner sc = new FastScanner();\n\t\t//Scanner sc = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint M = sc.nextInt();\n\t\tint N = sc.nextInt();\n\t\tchar[][] map = new char[M][];\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tmap[i] = sc.next().toCharArray();\n\t\t}\n\t\t\n\t\t\n\t\tint sum = 0;\n\t\tboolean ok = true;\n\t\tIN:while(ok) {\n\t\t\tint[][][] count = new int[M][N][26];\n\t\t\tfor(int i = 0; i < M; i++) {\n\t\t\t\tfor(int j = 0; j < N; j++) {\n\t\t\t\t\tif(map[i][j] != '.') continue;\n\t\t\t\t\tfor(int k = 0; k < 4; k++) {\n\t\t\t\t\t\tfor(int l = 0; ; l++) {\n\t\t\t\t\t\t\tint tx = j + vx[k] * l;\n\t\t\t\t\t\t\tint ty = i + vy[k] * l;\n\t\t\t\t\t\t\tif(tx < 0 || ty < 0 || tx >= N || ty >= M) break;\n\t\t\t\t\t\t\tif(map[ty][tx] == '.') continue;\n\t\t\t\t\t\t\tcount[i][j][map[ty][tx] - 'A']++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tok = false;\n\t\t\tfor(int i = 0; i < M; i++) {\n\t\t\t\tfor(int j = 0; j < N; j++) {\n\t\t\t\t\tfor(int k = 0; k < 26; k++) {\n\t\t\t\t\t\tif(count[i][j][k] == 2) {\n\t\t\t\t\t\t\tcount[i][j][k] = 0;\n\t\t\t\t\t\t\tsum += 2;\n\t\t\t\t\t\t\tfor(int l = 0; l < 4; l++) {\n\t\t\t\t\t\t\t\tfor(int m = 0; ; m++) {\n\t\t\t\t\t\t\t\t\tint tx = j + vx[l] * m;\n\t\t\t\t\t\t\t\t\tint ty = i + vy[l] * m;\n\t\t\t\t\t\t\t\t\tif(tx < 0 || ty < 0 || tx >= N || ty >= M) break;\n\t\t\t\t\t\t\t\t\tif(map[ty][tx] == '.') continue;\n\t\t\t\t\t\t\t\t\tif(map[ty][tx] != (char)('A' + k)) break;\n\t\t\t\t\t\t\t\t\tmap[ty][tx] = '.';\n\t\t\t\t\t\t\t\t\tok = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue IN;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(sum);\n\t}\n\t\n\tstatic class FastScanner {\n\t    private final InputStream in = System.in;\n\t    private final byte[] buffer = new byte[1024];\n\t    private int ptr = 0;\n\t    private int buflen = 0;\n\t    private boolean hasNextByte() {\n\t        if (ptr < buflen) {\n\t            return true;\n\t        }else{\n\t            ptr = 0;\n\t            try {\n\t                buflen = in.read(buffer);\n\t            } catch (IOException e) {\n\t                e.printStackTrace();\n\t            }\n\t            if (buflen <= 0) {\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\t    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\t    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n\t    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n\t    public String next() {\n\t        if (!hasNext()) throw new NoSuchElementException();\n\t        StringBuilder sb = new StringBuilder();\n\t        int b = readByte();\n\t        while(isPrintableChar(b)) {\n\t            sb.appendCodePoint(b);\n\t            b = readByte();\n\t        }\n\t        return sb.toString();\n\t    }\n\t    public long nextLong() {\n\t        if (!hasNext()) throw new NoSuchElementException();\n\t        long n = 0;\n\t        boolean minus = false;\n\t        int b = readByte();\n\t        if (b == '-') {\n\t            minus = true;\n\t            b = readByte();\n\t        }\n\t        if (b < '0' || '9' < b) {\n\t            throw new NumberFormatException();\n\t        }\n\t        while(true){\n\t            if ('0' <= b && b <= '9') {\n\t                n *= 10;\n\t                n += b - '0';\n\t            }else if(b == -1 || !isPrintableChar(b)){\n\t                return minus ? -n : n;\n\t            }else{\n\t                throw new NumberFormatException();\n\t            }\n\t            b = readByte();\n\t        }\n\t    }\n\t    public int nextInt() {\n\t        if (!hasNext()) throw new NoSuchElementException();\n\t        int n = 0;\n\t        boolean minus = false;\n\t        int b = readByte();\n\t        if (b == '-') {\n\t            minus = true;\n\t            b = readByte();\n\t        }\n\t        if (b < '0' || '9' < b) {\n\t            throw new NumberFormatException();\n\t        }\n\t        while(true){\n\t            if ('0' <= b && b <= '9') {\n\t                n *= 10;\n\t                n += b - '0';\n\t            }else if(b == -1 || !isPrintableChar(b)){\n\t                return minus ? -n : n;\n\t            }else{\n\t                throw new NumberFormatException();\n\t            }\n\t            b = readByte();\n\t        }\n\t    }\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tpublic void run() {\n\t\tint n = in.nextInt(), m = in.nextInt();\n\t\t\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tmap[i] = in.next().toCharArray();\n\t\t}\n\t\t\n\t\tint[] X1 = new int[26];\n\t\tint[] Y1 = new int[26];\n\t\tint[] X2 = new int[26];\n\t\tint[] Y2 = new int[26];\n\t\tfor (int c = 'A'; c <= 'Z'; c++) {\n\t\t\tint x1 = -1, y1 = -1, x2 = -1, y2 = -1;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tif (map[i][j] == c) {\n\t\t\t\t\t\tif (x1 == -1 && y1 == -1) {\n\t\t\t\t\t\t\tx1 = j; y1 = i;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tx2 = j; y2 = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (x1 != -1 && Math.abs(x1 - x2) + Math.abs(y1 - y2) != 1) {\n\t\t\t\tif (x1 > x2) {\n\t\t\t\t\tint t = x1;\n\t\t\t\t\tx1 = x2;\n\t\t\t\t\tx2 = t;\n\t\t\t\t\tt = y1;\n\t\t\t\t\ty1 = y2;\n\t\t\t\t\ty2 = t;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tX1[c - 'A'] = x1;\n\t\t\t\tX2[c - 'A'] = x2;\n\t\t\t\tY1[c - 'A'] = y1;\n\t\t\t\tY2[c - 'A'] = y2;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint res = 0;\n\t\tboolean more = true;\n\t\twhile (more) {\n\t\t\tmore = false;\n\t\t\tfor (int cc = 'A'; cc <= 'Z'; cc++) {\n\t\t\t\tint c = cc - 'A';\n\t\t\t\tif (X1[c] == 0 && Y1[c] == 0 && X2[c] == 0 && Y2[c] == 0) continue;\n\t\t\t\t\n\t\t\t\tboolean ok1 = true, ok2 = true;\n\t\t\t\tif (Y1[c] < Y2[c]) {\n\t\t\t\t\tfor (int y = Y1[c]; y <= Y2[c]; y++) {\n\t\t\t\t\t\tif (map[y][X1[c]] != '.' && map[y][X1[c]] - 'A' != c) ok1 = false;\n\t\t\t\t\t\tif (map[y][X2[c]] != '.' && map[y][X2[c]] - 'A' != c) ok2 = false;\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tfor (int x = X1[c]; x <= X2[c]; x++) {\n\t\t\t\t\t\tif (map[Y1[c]][x] != '.' && map[Y1[c]][x] - 'A' != c) ok2 = false;\n\t\t\t\t\t\tif (map[Y2[c]][x] != '.' && map[Y2[c]][x] - 'A' != c) ok1 = false;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (int y = Y2[c]; y <= Y1[c]; y++) {\n\t\t\t\t\t\tif (map[y][X1[c]] != '.' && map[y][X1[c]] - 'A' != c) ok1 = false;\n\t\t\t\t\t\tif (map[y][X2[c]] != '.' && map[y][X2[c]] - 'A' != c) ok2 = false;\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tfor (int x = X1[c]; x <= X2[c]; x++) {\n\t\t\t\t\t\tif (map[Y1[c]][x] != '.' && map[Y1[c]][x] - 'A' != c) ok2 = false;\n\t\t\t\t\t\tif (map[Y2[c]][x] != '.' && map[Y2[c]][x] - 'A' != c) ok1 = false;\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif (ok1 || ok2) {\n\t\t\t\t\tmap[Y1[c]][X1[c]] = '.';\n\t\t\t\t\tmap[Y2[c]][X2[c]] = '.';\n\t\t\t\t\tX1[c] = Y1[c] = X2[c] = Y2[c] = 0;\n\t\t\t\t\tmore = true;\n\t\t\t\t\tres += 2;\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t}\n\t\tSystem.out.println(res);\n\t\t\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\t\tint h = sc.nextInt();\n\t\tint w = sc.nextInt();\n\n\t\tchar map[][] = new char[h][];\n\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tmap[i] = sc.next().toCharArray();\n\t\t}\n\n\t\tint mask[][] = new int[h][w];\n\t\tint max = 0;\n\n\t\tint y[] = new int[h];\n\t\tint t[] = new int[w];\n\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (map[i][j] == '.') {\n\t\t\t\t\tmask[i][j] = 0;\n\t\t\t\t} else {\n\t\t\t\t\tmask[i][j] = 1 << (map[i][j] - 'A');\n\t\t\t\t\tmax = Math.max(map[i][j] - 'A', max);\n\t\t\t\t}\n\t\t\t\ty[i] |= mask[i][j];\n\t\t\t\tt[j] |= mask[i][j];\n\t\t\t}\n\t\t}\n\t\tmax += 1;\n\t\tboolean dp[] = new boolean[1 << max];\n\t\tdp[0] = true;\n\t\tint n = max;\n\t\tint mk = 0;\n\n\t\tint nnt[] = new int[n];\n\t\tint nnt2[] = new int[n];\n\t\tint nny[] = new int[n];\n\t\tint nny2[] = new int[n];\n\n\t\tint memo[] = new int[n];\n\t\tArrays.fill(memo, -1);\n\t\tint memo2[] = new int[n];\n\t\tArrays.fill(memo, -1);\n\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tint shj = 1 << j;\n\n\t\t\tint nt = -1;\n\t\t\tint nt2 = -1;\n\t\t\tint ny = -1;\n\t\t\tint ny2 = -1;\n\t\t\tfor (int ii = 0; ii < h; ii++) {\n\t\t\t\tif ((y[ii] & shj) != 0) {\n\t\t\t\t\tif (nt == -1) {\n\t\t\t\t\t\tnt = ii;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnt2 = ii;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int ii = 0; ii < w; ii++) {\n\t\t\t\tif ((t[ii] & shj) != 0) {\n\t\t\t\t\tif (ny == -1) {\n\t\t\t\t\t\tny = ii;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tny2 = ii;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (nt2 == -1) {\n\t\t\t\tnt2 = nt;\n\t\t\t}\n\t\t\tif (ny2 == -1) {\n\t\t\t\tny2 = ny;\n\t\t\t}\n\n\t\t\tif ((nt & ny) == -1) {\n\t\t\t\tnnt[j] = nt;\n\t\t\t\tnnt2[j] = nt2;\n\t\t\t\tnny[j] = ny;\n\t\t\t\tnny2[j] = ny2;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (mask[nt][ny] == shj) {\n\t\t\t\tint temp = ny2;\n\t\t\t\tny2 = ny;\n\t\t\t\tny = temp;\n\t\t\t}\n\n\t\t\tnnt[j] = nt;\n\t\t\tnnt2[j] = nt2;\n\t\t\tnny[j] = ny;\n\t\t\tnny2[j] = ny2;\n\n\t\t\tint tf = 0;\n\t\t\tint tf2 = 0;\n\t\t\tfor (int ii = Math.min(nt, nt2); ii <= Math.max(nt, nt2); ii++) {\n\t\t\t\ttf |= mask[ii][ny];\n\t\t\t\ttf2 |= mask[ii][ny2];\n\t\t\t}\n\n\t\t\tint yf = 0;\n\t\t\tint yf2 = 0;\n\t\t\tfor (int ii = Math.min(ny, ny2); ii <= Math.max(ny, ny2); ii++) {\n\t\t\t\tyf |= mask[nt][ii];\n\t\t\t\tyf2 |= mask[nt2][ii];\n\n\t\t\t}\n\n\t\t\tmemo[j] = tf | yf;\n\t\t\tmemo2[j] = tf2 | yf2;\n\n\t\t}\n\n\t\tint i = 0;\n\t\tfor (;;) {\n\t\t\tint previ = i;\t\t\t\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tint shj = 1 << j;\n\t\t\t\tif (dp[i | shj]) {\n\t\t\t\t\t// System.out.println(\"here\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint nt = nnt[j];\n\t\t\t\tint nt2 = nnt2[j];\n\t\t\t\tint ny = nny[j];\n\t\t\t\tint ny2 = nny2[j];\n\n\t\t\t\tif ((nt & ny) == -1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (Math.abs(nt - nt2) + Math.abs(ny2 - ny) < 2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (((~(i | shj)) & (memo[j])) == 0\n\t\t\t\t\t\t|| ((~(i | shj)) & (memo2[j])) == 0) {\n\t\t\t\t\tdp[i | shj] = true;\n\t\t\t\t\ti |= shj;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i==previ){\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(Integer.bitCount(i)*2);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\tnew Main().run();\n\t\treturn;\n\t}\n\t\n\tScanner scanner = new Scanner(System.in);\n\tint m;\n\tint[][][] tile = new int[26][2][2];\n\tboolean[] cantGet =new boolean[26];\n\tint score = 0;\n\t\n\tvoid run() {\n\t\t\n\t\tm = scanner.nextInt();\n\t\tscanner.nextInt();\n\t\t\n\t\tfor (int color = 0; color < 26; color ++) {\n\t\t\t\n\t\t\ttile[color][0][0] = -1;\n\t\t\tcantGet[color] = true;\n\t\t}\n\t\t\n\t\tfor (int y = 0; y < m; y ++) {\n\t\t\t\n\t\t\tchar[] line = scanner.next().toCharArray();\n\t\t\t\n\t\t\tfor (int x = 0; x < line.length; x ++) {\n\t\t\t\t\n\t\t\t\tif(line[x] != '.') {\n\t\t\t\t\t\n\t\t\t\t\tint color = line[x] - 'A';\n\t\t\t\t\tcantGet[color] = false;\n\t\t\t\t\tint index = (tile[color][0][0] == -1) ? 0: 1;\n\t\t\t\t\ttile[color][index][0] = x;\n\t\t\t\t\ttile[color][index][1] = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint preScore;\n\t\tdo {\n\t\t\t\n\t\t\tpreScore = score;\n\t\t\t\n\t\t\tfor (int color = 0; color < 26; color ++) {\n\t\t\t\t\n\t\t\t\ttryGet(color);\n\t\t\t}\n\t\t\t\n\t\t} while(preScore != score);\n\t\t\n\t\tSystem.out.println(score * 2);\n\t}\n\t\n\tvoid tryGet(int color) {\n\t\t\n\t\tif (cantGet[color]) {\n\t\t\t\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif ((tile[color][0][0] == tile[color][1][0]\n\t\t\t\t&& Math.abs(tile[color][0][1] - tile[color][1][1]) == 1)\n\t\t\t\t|| (tile[color][0][1] == tile[color][1][1]\n\t\t\t\t&& Math.abs(tile[color][0][0] - tile[color][1][0]) == 1)) {\n\t\t\t\t\n\t\t\tcantGet[color] = true;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif((isEmpty(color, 1, tile[color][0][0], tile[color][0][1], tile[color][1][1])\n\t\t\t\t&& isEmpty(color, 0, tile[color][1][1], tile[color][0][0], tile[color][1][0]))\n\t\t\t\t|| (isEmpty(color, 1, tile[color][1][0], tile[color][0][1], tile[color][1][1])\n\t\t\t\t\t\t&& isEmpty(color, 0, tile[color][0][1], tile[color][0][0], tile[color][1][0]))) {\n\t\t\t\n\t\t\tget(color);\n\t\t}\n\t}\n\t\n\tboolean isEmpty(int skip,int axis, int point, int start, int end) {\n\t\t\n\t\t\n\t\tif (start == end) {\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tif (start > end) {\n\t\t\t\n\t\t\tint swap = start;\n\t\t\tstart = end;\n\t\t\tend = swap;\n\t\t}\n\t\t\n\t\tfor (int color = 0; color < 26; color ++) {\n\t\t\t\n\t\t\tif (color == skip\n\t\t\t\t\t|| tile[color][0][0] == -1) {\n\t\t\t\t\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int index = 0; index < 2; index ++) {\n\t\t\t\t\n\t\t\t\tif (tile[color][index][1 - axis] == point\n\t\t\t\t\t\t&& tile[color][index][axis] >= start\n\t\t\t\t\t\t&& tile[color][index][axis] <= end) {\n\t\t\t\t\t\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tvoid get(int color) {\n\t\t\n\t\ttile[color][0][0] = -1;\n\t\tscore ++;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\t\tint h = sc.nextInt();\n\t\tint w = sc.nextInt();\n\n\t\tchar map[][] = new char[h][];\n\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tmap[i] = sc.next().toCharArray();\n\t\t}\n\n\t\tint mask[][] = new int[h][w];\n\t\tint max = 0;\n\n\t\tint y[] = new int[h];\n\t\tint t[] = new int[w];\n\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (map[i][j] == '.') {\n\t\t\t\t\tmask[i][j] = 0;\n\t\t\t\t} else {\n\t\t\t\t\tmask[i][j] = 1 << (map[i][j] - 'A');\n\t\t\t\t\tmax = Math.max(map[i][j] - 'A', max);\n\t\t\t\t}\n\t\t\t\ty[i] |= mask[i][j];\n\t\t\t\tt[j] |= mask[i][j];\n\t\t\t}\n\t\t}\n\t\tmax += 1;\n\t\tboolean dp[] = new boolean[1 << max];\n\t\tdp[0] = true;\n\t\tint n = max;\n\t\tint mk = 0;\n\n\t\tint nnt[] = new int[n];\n\t\tint nnt2[] = new int[n];\n\t\tint nny[] = new int[n];\n\t\tint nny2[] = new int[n];\n\n\t\tint memo[] = new int[n];\n\t\tArrays.fill(memo, -1);\n\t\tint memo2[] = new int[n];\n\t\tArrays.fill(memo, -1);\n\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tint shj = 1 << j;\n\n\t\t\tint nt = -1;\n\t\t\tint nt2 = -1;\n\t\t\tint ny = -1;\n\t\t\tint ny2 = -1;\n\t\t\tfor (int ii = 0; ii < h; ii++) {\n\t\t\t\tif ((y[ii] & shj) != 0) {\n\t\t\t\t\tif (nt == -1) {\n\t\t\t\t\t\tnt = ii;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnt2 = ii;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int ii = 0; ii < w; ii++) {\n\t\t\t\tif ((t[ii] & shj) != 0) {\n\t\t\t\t\tif (ny == -1) {\n\t\t\t\t\t\tny = ii;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tny2 = ii;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (nt2 == -1) {\n\t\t\t\tnt2 = nt;\n\t\t\t}\n\t\t\tif (ny2 == -1) {\n\t\t\t\tny2 = ny;\n\t\t\t}\n\n\t\t\tif ((nt & ny) == -1) {\n\t\t\t\tnnt[j] = nt;\n\t\t\t\tnnt2[j] = nt2;\n\t\t\t\tnny[j] = ny;\n\t\t\t\tnny2[j] = ny2;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (mask[nt][ny] == shj) {\n\t\t\t\tint temp = ny2;\n\t\t\t\tny2 = ny;\n\t\t\t\tny = temp;\n\t\t\t}\n\n\t\t\tnnt[j] = nt;\n\t\t\tnnt2[j] = nt2;\n\t\t\tnny[j] = ny;\n\t\t\tnny2[j] = ny2;\n\n\t\t\tint tf = 0;\n\t\t\tint tf2 = 0;\n\t\t\tfor (int ii = Math.min(nt, nt2); ii <= Math.max(nt, nt2); ii++) {\n\t\t\t\ttf |= mask[ii][ny];\n\t\t\t\ttf2 |= mask[ii][ny2];\n\t\t\t}\n\n\t\t\tint yf = 0;\n\t\t\tint yf2 = 0;\n\t\t\tfor (int ii = Math.min(ny, ny2); ii <= Math.max(ny, ny2); ii++) {\n\t\t\t\tyf |= mask[nt][ii];\n\t\t\t\tyf2 |= mask[nt2][ii];\n\n\t\t\t}\n\n\t\t\tmemo[j] = tf | yf;\n\t\t\tmemo2[j] = tf2 | yf2;\n\n\t\t}\n\t\t/*\n\t\t * System.out.println(nnt['Z'-'A']+\" \"+nnt2['Z'-'A']);\n\t\t * System.out.println(nny['Z'-'A']+\" \"+nny2['Z'-'A']);\n\t\t * System.out.println(\"-----------------\");\n\t\t * System.out.println(nnt['U'-'A']+\" \"+nnt2['U'-'A']);\n\t\t * System.out.println(nny['U'-'A']+\" \"+nny2['U'-'A']);\n\t\t * System.out.println(\"-----------------\");\n\t\t */\n\n\t\tfor (int i = 0; i < 1 << n; i++) {\n\t\t\tif (!dp[i]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Integer.bitCount(i) > mk+1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tint shj = 1 << j;\n\t\t\t\tif (dp[i | shj]) {\n\t\t\t\t\t// System.out.println(\"here\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint nt = nnt[j];\n\t\t\t\tint nt2 = nnt2[j];\n\t\t\t\tint ny = nny[j];\n\t\t\t\tint ny2 = nny2[j];\n\n\t\t\t\tif ((nt & ny) == -1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (Math.abs(nt - nt2) + Math.abs(ny2 - ny) < 2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (((~(i | shj)) & (memo[j])) == 0\n\t\t\t\t\t\t|| ((~(i | shj)) & (memo2[j])) == 0) {\n\t\t\t\t\tdp[i | shj] = true;\n\t\t\t\t\tmk = Math.max(Integer.bitCount(i | shj), mk);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(mk * 2);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tpublic void run() {\n\t\tint n = in.nextInt(), m = in.nextInt();\n\t\t\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tmap[i] = in.next().toCharArray();\n\t\t}\n\t\t\n\t\tint[] X1 = new int[26];\n\t\tint[] Y1 = new int[26];\n\t\tint[] X2 = new int[26];\n\t\tint[] Y2 = new int[26];\n\t\tfor (int c = 'A'; c <= 'Z'; c++) {\n\t\t\tint x1 = -1, y1 = -1, x2 = -1, y2 = -1;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tif (map[i][j] == c) {\n\t\t\t\t\t\tif (x1 == -1 && y1 == -1) {\n\t\t\t\t\t\t\tx1 = j; y1 = i;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tx2 = j; y2 = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (x1 != -1 && Math.abs(x1 - x2) + Math.abs(y1 - y2) != 1) {\n\t\t\t\tif (x1 > x2) {\n\t\t\t\t\tint t = x1;\n\t\t\t\t\tx1 = x2;\n\t\t\t\t\tx2 = t;\n\t\t\t\t\tt = y1;\n\t\t\t\t\ty1 = y2;\n\t\t\t\t\ty2 = t;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tX1[c - 'A'] = x1;\n\t\t\t\tX2[c - 'A'] = x2;\n\t\t\t\tY1[c - 'A'] = y1;\n\t\t\t\tY2[c - 'A'] = y2;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint res = 0;\n\t\tboolean more = true;\n\t\twhile (more) {\n\t\t\tmore = false;\n\t\t\tfor (int cc = 'A'; cc <= 'Z'; cc++) {\n\t\t\t\tint c = cc - 'A';\n\t\t\t\tif (X1[c] == 0 && Y1[c] == 0 && X2[c] == 0 && Y2[c] == 0) continue;\n\t\t\t\t\n\t\t\t\tboolean ok1 = true, ok2 = true;\n\t\t\t\tif (Y1[c] < Y2[c]) {\n\t\t\t\t\tfor (int y = Y1[c]; y <= Y2[c]; y++) {\n\t\t\t\t\t\tif (map[y][X1[c]] != '.' && map[y][X1[c]] - 'A' != c) ok1 = false;\n\t\t\t\t\t\tif (map[y][X2[c]] != '.' && map[y][X2[c]] - 'A' != c) ok2 = false;\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tfor (int x = X1[c]; x <= X2[c]; x++) {\n\t\t\t\t\t\tif (map[Y1[c]][x] != '.' && map[Y1[c]][x] - 'A' != c) ok2 = false;\n\t\t\t\t\t\tif (map[Y2[c]][x] != '.' && map[Y2[c]][x] - 'A' != c) ok1 = false;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (int y = Y1[c]; y <= Y2[c]; y++) {\n\t\t\t\t\t\tif (map[y][X1[c]] != '.' && map[y][X1[c]] - 'A' != c) ok1 = false;\n\t\t\t\t\t\tif (map[y][X2[c]] != '.' && map[y][X2[c]] - 'A' != c) ok2 = false;\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tfor (int x = X1[c]; x <= X2[c]; x++) {\n\t\t\t\t\t\tif (map[Y1[c]][x] != '.' && map[Y1[c]][x] - 'A' != c) ok1 = false;\n\t\t\t\t\t\tif (map[Y2[c]][x] != '.' && map[Y2[c]][x] - 'A' != c) ok2 = false;\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (ok1 || ok2) {\n\t\t\t\t\tmap[Y1[c]][X1[c]] = '.';\n\t\t\t\t\tmap[Y2[c]][X2[c]] = '.';\n\t\t\t\t\tX1[c] = Y1[c] = X2[c] = Y2[c] = 0;\n\t\t\t\t\tmore = true;\n\t\t\t\t\tres += 2;\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t}\n\t\tSystem.out.println(res);\n\t\t\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\nimport java.awt.Point;\n\nclass Main{\n\n    private static final int[] dx = {0,1,0,-1};\n    private static final int[] dy = {1,0,-1,0};\n\n    static class Pox\n    {\n\tpublic int x,y;\n\tpublic char extraterrestrial;\n\n\tPox()\n\t{\n\t    x = y = -1;\n\t    extraterrestrial = 'a';\n\t}\n\n\tPox(char c,int a,int b)\n\t{\n\t    x = a;\n\t    y = b;\n\t    extraterrestrial = c;\n\t}\n\n    }\n\n       \n\n    static class PP\n    {\n\tPoint p1,p2;\n\n\tPP()\n\t{\n\t    p1 = new Point(-1,-1);\n\t    p2 = new Point(-1,-1);\n\t}\n\n\tPP(Point a,Point b)\n\t{\n\t    p1 = a;\n\t    p2 = b;\n\t}\n\n    }\n\n\n      public static void main(String args[])throws IOException\n    {\n\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tint M,N;\n\tString line = in.readLine();\n\tM = Integer.parseInt(line.substring(0,line.indexOf(\" \")));\n\tN = Integer.parseInt(line.substring(line.indexOf(\" \") + 1));\n\n\tLinkedList<Pox> list = new LinkedList<Pox>();//アルファベットの座標\n\tLinkedList<Pox> M_list = new LinkedList<Pox>();//中継地点\n\tHashMap<Character,PP> map = new HashMap<Character,PP>();\n\tchar[][] cmap = new char[M][N];\n\n\n\tfor(int i=0;i<M;i++)\n\t    {\n\t\tline = in.readLine();\n\t\tfor(int j=0;j<N;j++)\n\t\t    {\n\n\t\t\tcmap[i][j] = line.charAt(j);\t\t\n\n\t\t\tif(line.charAt(j) != '.')\n\t\t\t    {\n\t\t\t\tlist.add(new Pox(line.charAt(j),j,i));\n\t\t\t\tif(!map.containsKey(line.charAt(j)))\n\t\t\t\t    {\n\t\t\t\t\tmap.put(line.charAt(j),new PP(new Point(j,i),new Point(-1,-1)));\n\t\t\t\t    }\n\t\t\t\telse\n\t\t\t\t    {\n\t\t\t\t\tint x,y,xx,yy;\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t\txx = map.get(line.charAt(j)).p1.x;\n\t\t\t\t\tyy = map.get(line.charAt(j)).p1.y;\n\t\t\t\t\tmap.put(line.charAt(j),new PP(new Point(xx,yy),new Point(j,i)));\n\n\t\t\t\t\tif(!(x == xx || y == yy))\n\t\t\t\t\t    {\n\t\t\t\t\t\tM_list.add(new Pox(line.charAt(j),x,yy));\n\t\t\t\t\t\tM_list.add(new Pox(line.charAt(j),xx,y));\n\t\t\t\t\t    }\n\t\t\t\t    }\n\t\t\t    } \n\t\t    }\n\t    }\n\n\t/*\n\tfor(int i=0;i<M_list.size();i++)\n\t    {\n\t\tSystem.out.println(\"debug : \" + M_list.get(i).extraterrestrial);\n\t    }\n\t*/\n\n\tboolean[] used = new boolean[28];\t\n\tfor(int i=0;i<28;i++)\n\t    {\n\t\tused[i] = false;\n\t    }\n\n\tboolean finish = false;\n\tint cnt = 0;\n\twhile(!finish)\n\t    {\n\t\tfinish = true;\n\n\t\tfor(int i=0;i<list.size();i++)\n\t\t    {\n\t\t\tif(used[list.get(i).extraterrestrial - 'A'])\n\t\t\t    continue;\n\n\t\t\tint x,y,xx,yy;\n\t\t\tchar c = list.get(i).extraterrestrial;\n\t\t\tx = map.get(c).p1.x;\n\t\t\ty = map.get(c).p1.y;\n\t\t\txx = map.get(c).p2.x;\n\t\t\tyy = map.get(c).p2.y;\n\n\t\t\tint hx,hxx;\n\t\t\tint hy,hyy;\n\n\t\t\thx = Math.min(x,xx);\n\t\t\thxx = Math.max(x,xx);\n\n\t\t\thy = Math.min(y,yy);\n\t\t\thyy = Math.max(y,yy);\n\n\t\t\tif(!(x == xx || y == yy))\n\t\t\t    continue;\n\n\t\t\tboolean ok = true;\n\t\t\tfor(int j=0;j<list.size();j++)\n\t\t\t    {\n\t\t\t\tif(list.get(j).extraterrestrial == c)\n\t\t\t\t    continue;\n\n\t\t\t\tif(used[list.get(j).extraterrestrial-'A'])\n\t\t\t\t    continue;\n\n\t\t\t\tint list_x,list_y;\n\t\t\t\tlist_x = list.get(j).x;\n\t\t\t\tlist_y = list.get(j).y;\n\n\t\t\t\tif(x == xx)\n\t\t\t\t    {\n\t\t\t\t\tif(x == list_x)\n\t\t\t\t\t    {\n\t\t\t\t\t\tif(hy < list_y && list_y < hyy)\n\t\t\t\t\t\t    {\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t    }\n\t\t\t\t\t\telse\n\t\t\t\t\t\t    {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t    }\n\t\t\t\t\t    }\n\t\t\t\t\telse\n\t\t\t\t\t    {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t    }\n\t\t\t\t    }\n\t\t\t\telse if(y == yy)\n\t\t\t\t    {\n\t\t\t\t\tif(y == list_y)\n\t\t\t\t\t    {\n\t\t\t\t\t\tif(hx < list_x && list_x < hxx)\n\t\t\t\t\t\t    {\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t    }\n\t\t\t\t\t\telse\n\t\t\t\t\t\t    {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t    }\n\t\t\t\t\t    }\n\t\t\t\t\telse\n\t\t\t\t\t    {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t    }\n\n\t\t\t\t    }\n\t\t\t\t\n\n\t\t\t    }\n\n\t\t\tif(ok)\n\t\t\t    {\n\n\t\t\t\tint xp,yp;\n\t\t\t\txp = list.get(i).x;\n\t\t\t\typ = list.get(i).y;\n\t\t\t\tfor(int j=0;j<4;j++)\n\t\t\t\t    {\n\t\t\t\t\tint nx = xp + dx[j],ny = yp + dy[j];\n\t\t\t\t\tif(!(0<= nx && nx <N && 0<= ny && ny <M ))\n\t\t\t\t\t    continue;\n\n\t\t\t\t\tif(cmap[ny][nx] == list.get(i).extraterrestrial)\n\t\t\t\t\t    {\n\t\t\t\t\t\tused[list.get(i).extraterrestrial-'A'] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t    }\n\t\t\t\t    }\n\n\t\t\t\tif(used[list.get(i).extraterrestrial-'A'])\n\t\t\t\t    continue;\n\n\t\t\t\t//System.out.println(\"OK: \" + list.get(i).extraterrestrial);\n\t\t\t\tcnt += 2;\n\t\t\t\tused[list.get(i).extraterrestrial-'A'] = true;\n\t\t\t\tfinish = false;\n\t\t\t    }\n\n\t\t    }\n\n\n\n\t\tfor(int i=0; i<M_list.size();i++)\n\t\t    {\n\t\t\tif(used[M_list.get(i).extraterrestrial-'A'])\n\t\t\t    continue;\n\n\t\t\t//System.out.println(\"GO! -> \" + M_list.get(i).extraterrestrial);\n\n\t\t\tint mx,my,x1,y1,x2,y2;\n\n\t\t\tmx = M_list.get(i).x;\n\t\t\tmy = M_list.get(i).y;\n\n\t\t\t//System.out.println(\"the coordinates : \" + mx + \",\" + my );\n\t\t\t\n\t\t\tif(cmap[my][mx] != '.')\n\t\t\t    {\n\t\t\t\tif(!used[cmap[my][mx]-'A'])\n\t\t\t\t    {\n\t\t\t\t\tcontinue;\n\t\t\t\t    }\n\t\t\t    }\n\n\t\t\n\t\t\tPoint pp = map.get(M_list.get(i).extraterrestrial).p1;\n\t\t\tPoint ppp = map.get(M_list.get(i).extraterrestrial).p2;\n\n\t\t\tx1 = pp.x;\n\t\t\ty1 = pp.y;\n\n\t\t\tx2 = ppp.x;\n\t\t\ty2 = ppp.y;\n\n\n\t\t\tint hx,hy,hxx,hyy;\n\n\t\t\thx = Math.min(mx,x1);\n\t\t\thxx = Math.max(mx,x1);\n\t\t\thy = Math.min(my,y1);\t\t\t\n\t\t\thyy = Math.max(my,y1);\n\n\n\t\t\n\t\t      \n\n\t\t\tboolean ok = true;\n\t\t\tfor(int j=0;j<list.size();j++)\n\t\t\t    {\t\t\t\t    \n\n\n\t\t\t\tif(used[list.get(j).extraterrestrial-'A'])\n\t\t\t\t    {\n\t\t\t\t\tcontinue;\n\t\t\t\t    }\n\n\t\t\t\tif(list.get(j).extraterrestrial == M_list.get(i).extraterrestrial)\n\t\t\t\t    {\n\t\t\t\t\tcontinue;\n\t\t\t\t    }\n\n\t\t\t\tint lx,ly;\n\t\t\t\tlx = list.get(j).x;\n\t\t\t\tly = list.get(j).y;\n\n\t\t\n\t\t    \n\t\t\t\n\n\n\t\t\t\tif(mx == x1)\n\t\t\t\t    {\n\t\t\t\t\tif(mx != lx)\n\t\t\t\t\t    continue;\n\n\t\t\t\t\tif(hy < ly && ly < hyy)\n\t\t\t\t\t    {\n\t\t\t\t\t\tif(!used[cmap[ly][lx]-'A'])\n\t\t\t\t\t\t    {\n\t\t\t\t\t\t\t//System.out.println(\"MISS! p3 \" + M_list.get(i).extraterrestrial);\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t    }\n\t\t\t\t\t    }\n\t\t\t\t\telse\n\t\t\t\t\t    {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t    }\n\t\t\t\t    }\n\t\t\t\telse if(my == y1)\n\t\t\t\t    {\n\t\t\t\t\tif(my != ly)\n\t\t\t\t\t    continue;\n\t\t\t\t\tif(hx < lx && lx < hxx)\n\t\t\t\t\t    {\n\t\t\t\t\t\tif(!used[cmap[ly][lx]-'A'])\n\t\t\t\t\t\t    {    \n\t\t\t\t\t\t\t//System.out.println(\"MISS! p4 \" + M_list.get(i).extraterrestrial );\n\t\t\t\t\t\t\t//System.out.println(\"p4 : \" + cmap[ly][lx] + \" : \" + lx + \",\" + ly);\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t    }\n\t\t\t\t\t    }\n\t\t\t\t\telse\n\t\t\t\t\t    {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t    }\n\t\t\t\t    }\n\n\t\t\t    }\n\n\t\t\tif(!ok)\n\t\t\t    {\n\t\t\t\tcontinue;\n\t\t\t    }\n\n\t\t\t//System.out.println(\"2 PASSED! \" + M_list.get(i).extraterrestrial);\n\n\n\t\t\tboolean ok2 = true;\n\t\t\thx = Math.min(mx,x2);\n\t\t\thxx = Math.max(mx,x2);\n\t\t\thy = Math.min(my,y2);\n\t\t\thyy = Math.max(my,y2);\n\n\t\t\tfor(int j=0;j<list.size();j++)\n\t\t\t    {\n\t\t\t\tif(used[list.get(j).extraterrestrial-'A'])\n\t\t\t\t    continue;\n\n\t\t\t\tif(list.get(j).extraterrestrial == M_list.get(i).extraterrestrial)\n\t\t\t\t    continue;\n\n\t\t\t\tint lx,ly;\n\t\t\t\tlx = list.get(j).x;\n\t\t\t\tly = list.get(j).y;\n\n\t\t\t\tif(cmap[ly][lx] != '.')\n\t\t\t\t    {\n\t\t\t\t\tif(!used[cmap[ly][lx]-'A'])\n\t\t\t\t\t    {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t    }\n\t\t\t\t    }\n\n\n\t\t\t\tif(mx == x2)\n\t\t\t\t    {\n\t\t\t\t\tif(mx != lx)\n\t\t\t\t\t    continue;\n\t\t\t\t\t\n\t\t\t\t\tif(hy < ly && ly < hyy)\n\t\t\t\t\t    {\n\t\t\t\t\t\tif(!used[cmap[ly][lx]-'A'])\n\t\t\t\t\t\t    {\n\t\t\t\t\t\t\tok2 = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t    }\n\t\t\t\t\t\telse\n\t\t\t\t\t\t    continue;\n\t\t\t\t\t    }\n\t\t\t\t\telse\n\t\t\t\t\t    {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t    }\n\t\t\t\t    }\n\t\t\t\telse if(my == y2)\n\t\t\t\t    {\n\t\t\t\t\tif(my != ly)\n\t\t\t\t\t    continue;\n\n\t\t\t\t\tif(hx < lx && lx < hxx)\n\t\t\t\t\t    {\n\t\t\t\t\t\tif(!used[cmap[ly][lx]-'A'])\n\t\t\t\t\t\t    {\n\t\t\t\t\t\t\tok2 = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t    }\n\t\t\t\t\t\telse \n\t\t\t\t\t\t    continue;\n\t\t\t\t\t    }\n\t\t\t\t\telse\n\t\t\t\t\t    {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t    }\n\t\t\t\t    }\n\n\t\t\t    }\n\n\t\t\t//System.out.println(\"3 PASSED! \" + M_list.get(i).extraterrestrial);\n\n\n\t\t\tif(ok && ok2)\n\t\t\t    {\n\n\t\t\t\t//System.out.println(\"OK: \" + M_list.get(i).extraterrestrial);\n\t\t\t\tcnt+=2;\n\t\t\t\tfinish = false;\n\t\t\t\tused[M_list.get(i).extraterrestrial-'A'] = true;\n\t\t\t    }\n\n\n\t\t    }\n\n\n\t    }\n\n\tSystem.out.println(cnt);\n\t\n    }\n    \n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\nimport java.awt.Point;\n\nclass Main{\n\n    private static final int[] dx = {0,1,0,-1};\n    private static final int[] dy = {1,0,-1,0};\n\n    static class Pox\n    {\n\tpublic int x,y;\n\tpublic char extraterrestrial;\n\n\tPox()\n\t{\n\t    x = y = -1;\n\t    extraterrestrial = 'a';\n\t}\n\n\tPox(char c,int a,int b)\n\t{\n\t    x = a;\n\t    y = b;\n\t    extraterrestrial = c;\n\t}\n\n    }\n\n       \n\n    static class PP\n    {\n\tPoint p1,p2;\n\n\tPP()\n\t{\n\t    p1 = new Point(-1,-1);\n\t    p2 = new Point(-1,-1);\n\t}\n\n\tPP(Point a,Point b)\n\t{\n\t    p1 = a;\n\t    p2 = b;\n\t}\n\n    }\n\n\n      public static void main(String args[])throws IOException\n    {\n\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tint M,N;\n\n\tString line;\n\twhile((line = in.readLine()) != null)\n\t    {\n\n\t\n\tM = Integer.parseInt(line.substring(0,line.indexOf(\" \")));\n\tN = Integer.parseInt(line.substring(line.indexOf(\" \") + 1));\n\n\tLinkedList<Pox> list = new LinkedList<Pox>();//アルファベットの座標\n\tLinkedList<Pox> M_list = new LinkedList<Pox>();//中継地点\n\tHashMap<Character,PP> map = new HashMap<Character,PP>();\n\tchar[][] cmap = new char[M][N];\n\n\n\tfor(int i=0;i<M;i++)\n\t    {\n\t\tline = in.readLine();\n\t\tfor(int j=0;j<N;j++)\n\t\t    {\n\n\t\t\tcmap[i][j] = line.charAt(j);\t\t\n\n\t\t\tif(line.charAt(j) != '.')\n\t\t\t    {\n\t\t\t\tlist.add(new Pox(line.charAt(j),j,i));\n\t\t\t\tif(!map.containsKey(line.charAt(j)))\n\t\t\t\t    {\n\t\t\t\t\tmap.put(line.charAt(j),new PP(new Point(j,i),new Point(-1,-1)));\n\t\t\t\t    }\n\t\t\t\telse\n\t\t\t\t    {\n\t\t\t\t\tint x,y,xx,yy;\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t\txx = map.get(line.charAt(j)).p1.x;\n\t\t\t\t\tyy = map.get(line.charAt(j)).p1.y;\n\t\t\t\t\tmap.put(line.charAt(j),new PP(new Point(xx,yy),new Point(j,i)));\n\n\t\t\t\t\tif(!(x == xx || y == yy))\n\t\t\t\t\t    {\n\t\t\t\t\t\tM_list.add(new Pox(line.charAt(j),x,yy));\n\t\t\t\t\t\tM_list.add(new Pox(line.charAt(j),xx,y));\n\t\t\t\t\t    }\n\t\t\t\t    }\n\t\t\t    } \n\t\t    }\n\t    }\n\n\t/*\n\tfor(int i=0;i<M_list.size();i++)\n\t    {\n\t\tSystem.out.println(\"debug : \" + M_list.get(i).extraterrestrial);\n\t    }\n\t*/\n\n\tboolean[] used = new boolean[28];\t\n\tfor(int i=0;i<28;i++)\n\t    {\n\t\tused[i] = false;\n\t    }\n\n\tboolean finish = false;\n\tint cnt = 0;\n\twhile(!finish)\n\t    {\n\t\tfinish = true;\n\n\t\tfor(int i=0;i<list.size();i++)\n\t\t    {\n\t\t\tif(used[list.get(i).extraterrestrial - 'A'])\n\t\t\t    continue;\n\n\t\t\tint x,y,xx,yy;\n\t\t\tchar c = list.get(i).extraterrestrial;\n\t\t\tx = map.get(c).p1.x;\n\t\t\ty = map.get(c).p1.y;\n\t\t\txx = map.get(c).p2.x;\n\t\t\tyy = map.get(c).p2.y;\n\n\t\t\tint hx,hxx;\n\t\t\tint hy,hyy;\n\n\t\t\thx = Math.min(x,xx);\n\t\t\thxx = Math.max(x,xx);\n\n\t\t\thy = Math.min(y,yy);\n\t\t\thyy = Math.max(y,yy);\n\n\t\t\tif(!(x == xx || y == yy))\n\t\t\t    continue;\n\n\t\t\tboolean ok = true;\n\t\t\tfor(int j=0;j<list.size();j++)\n\t\t\t    {\n\t\t\t\tif(list.get(j).extraterrestrial == c)\n\t\t\t\t    continue;\n\n\t\t\t\tif(used[list.get(j).extraterrestrial-'A'])\n\t\t\t\t    continue;\n\n\t\t\t\tint list_x,list_y;\n\t\t\t\tlist_x = list.get(j).x;\n\t\t\t\tlist_y = list.get(j).y;\n\n\t\t\t\tif(x == xx)\n\t\t\t\t    {\n\t\t\t\t\tif(x == list_x)\n\t\t\t\t\t    {\n\t\t\t\t\t\tif(hy < list_y && list_y < hyy)\n\t\t\t\t\t\t    {\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t    }\n\t\t\t\t\t\telse\n\t\t\t\t\t\t    {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t    }\n\t\t\t\t\t    }\n\t\t\t\t\telse\n\t\t\t\t\t    {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t    }\n\t\t\t\t    }\n\t\t\t\telse if(y == yy)\n\t\t\t\t    {\n\t\t\t\t\tif(y == list_y)\n\t\t\t\t\t    {\n\t\t\t\t\t\tif(hx < list_x && list_x < hxx)\n\t\t\t\t\t\t    {\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t    }\n\t\t\t\t\t\telse\n\t\t\t\t\t\t    {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t    }\n\t\t\t\t\t    }\n\t\t\t\t\telse\n\t\t\t\t\t    {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t    }\n\n\t\t\t\t    }\n\t\t\t\t\n\n\t\t\t    }\n\n\t\t\tif(ok)\n\t\t\t    {\n\n\t\t\t\tint xp,yp;\n\t\t\t\txp = list.get(i).x;\n\t\t\t\typ = list.get(i).y;\n\n\t\t\t\tboolean NoWay = false;\t\t\t\t\n\n\t\t\t\tfor(int j=0;j<4;j++)\n\t\t\t\t    {\n\t\t\t\t\tint nx = xp + dx[j],ny = yp + dy[j];\n\t\t\t\t\tif(!(0<= nx && nx <N && 0<= ny && ny <M ))\n\t\t\t\t\t    continue;\n\n\t\t\t\t\tif(cmap[ny][nx] == list.get(i).extraterrestrial)\n\t\t\t\t\t    {\n\t\t\t\t\t\tNoWay = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t    }\n\t\t\t\t    }\n\n\t\t\t\tif(NoWay)\n\t\t\t\t    continue;\n\n\t\t\t\t//System.out.println(\"OK: \" + list.get(i).extraterrestrial);\n\t\t\t\tcnt += 2;\n\t\t\t\tused[list.get(i).extraterrestrial-'A'] = true;\n\t\t\t\tfinish = false;\n\t\t\t    }\n\n\t\t    }\n\n\n\n\t\tfor(int i=0; i<M_list.size();i++)\n\t\t    {\n\t\t\tif(used[M_list.get(i).extraterrestrial-'A'])\n\t\t\t    continue;\n\n\t\t\t//System.out.println(\"GO! -> \" + M_list.get(i).extraterrestrial);\n\n\t\t\tint mx,my,x1,y1,x2,y2;\n\n\t\t\tmx = M_list.get(i).x;\n\t\t\tmy = M_list.get(i).y;\n\n\t\t\t//System.out.println(\"the coordinates : \" + mx + \",\" + my );\n\t\t\t\n\t\t\tif(cmap[my][mx] != '.')\n\t\t\t    {\n\t\t\t\tif(!used[cmap[my][mx]-'A'])\n\t\t\t\t    {\n\t\t\t\t\tcontinue;\n\t\t\t\t    }\n\t\t\t    }\n\n\t\t\n\t\t\tPoint pp = map.get(M_list.get(i).extraterrestrial).p1;\n\t\t\tPoint ppp = map.get(M_list.get(i).extraterrestrial).p2;\n\n\t\t\tx1 = pp.x;\n\t\t\ty1 = pp.y;\n\n\t\t\tx2 = ppp.x;\n\t\t\ty2 = ppp.y;\n\n\n\t\t\tint hx,hy,hxx,hyy;\n\n\t\t\thx = Math.min(mx,x1);\n\t\t\thxx = Math.max(mx,x1);\n\t\t\thy = Math.min(my,y1);\t\t\t\n\t\t\thyy = Math.max(my,y1);\n\n\n\t\t\n\t\t      \n\n\t\t\tboolean ok = true;\n\t\t\tfor(int j=0;j<list.size();j++)\n\t\t\t    {\t\t\t\t    \n\n\n\t\t\t\tif(used[list.get(j).extraterrestrial-'A'])\n\t\t\t\t    {\n\t\t\t\t\tcontinue;\n\t\t\t\t    }\n\n\t\t\t\tif(list.get(j).extraterrestrial == M_list.get(i).extraterrestrial)\n\t\t\t\t    {\n\t\t\t\t\tcontinue;\n\t\t\t\t    }\n\n\t\t\t\tint lx,ly;\n\t\t\t\tlx = list.get(j).x;\n\t\t\t\tly = list.get(j).y;\n\n\t\t\n\t\t    \n\t\t\t\n\n\n\t\t\t\tif(mx == x1)\n\t\t\t\t    {\n\t\t\t\t\tif(mx != lx)\n\t\t\t\t\t    continue;\n\n\t\t\t\t\tif(hy < ly && ly < hyy)\n\t\t\t\t\t    {\n\t\t\t\t\t\tif(!used[cmap[ly][lx]-'A'])\n\t\t\t\t\t\t    {\n\t\t\t\t\t\t\t//System.out.println(\"MISS! p3 \" + M_list.get(i).extraterrestrial);\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t    }\n\t\t\t\t\t    }\n\t\t\t\t\telse\n\t\t\t\t\t    {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t    }\n\t\t\t\t    }\n\t\t\t\telse if(my == y1)\n\t\t\t\t    {\n\t\t\t\t\tif(my != ly)\n\t\t\t\t\t    continue;\n\t\t\t\t\tif(hx < lx && lx < hxx)\n\t\t\t\t\t    {\n\t\t\t\t\t\tif(!used[cmap[ly][lx]-'A'])\n\t\t\t\t\t\t    {    \n\t\t\t\t\t\t\t//System.out.println(\"MISS! p4 \" + M_list.get(i).extraterrestrial );\n\t\t\t\t\t\t\t//System.out.println(\"p4 : \" + cmap[ly][lx] + \" : \" + lx + \",\" + ly);\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t    }\n\t\t\t\t\t    }\n\t\t\t\t\telse\n\t\t\t\t\t    {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t    }\n\t\t\t\t    }\n\n\t\t\t    }\n\n\t\t\tif(!ok)\n\t\t\t    {\n\t\t\t\tcontinue;\n\t\t\t    }\n\n\t\t\t//System.out.println(\"2 PASSED! \" + M_list.get(i).extraterrestrial);\n\n\n\t\t\tboolean ok2 = true;\n\t\t\thx = Math.min(mx,x2);\n\t\t\thxx = Math.max(mx,x2);\n\t\t\thy = Math.min(my,y2);\n\t\t\thyy = Math.max(my,y2);\n\n\t\t\tfor(int j=0;j<list.size();j++)\n\t\t\t    {\n\t\t\t\tif(used[list.get(j).extraterrestrial-'A'])\n\t\t\t\t    continue;\n\n\t\t\t\tif(list.get(j).extraterrestrial == M_list.get(i).extraterrestrial)\n\t\t\t\t    continue;\n\n\t\t\t\tint lx,ly;\n\t\t\t\tlx = list.get(j).x;\n\t\t\t\tly = list.get(j).y;\n\n\t\t\t\tif(cmap[ly][lx] != '.')\n\t\t\t\t    {\n\t\t\t\t\tif(!used[cmap[ly][lx]-'A'])\n\t\t\t\t\t    {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t    }\n\t\t\t\t    }\n\n\n\t\t\t\tif(mx == x2)\n\t\t\t\t    {\n\t\t\t\t\tif(mx != lx)\n\t\t\t\t\t    continue;\n\t\t\t\t\t\n\t\t\t\t\tif(hy < ly && ly < hyy)\n\t\t\t\t\t    {\n\t\t\t\t\t\tif(!used[cmap[ly][lx]-'A'])\n\t\t\t\t\t\t    {\n\t\t\t\t\t\t\tok2 = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t    }\n\t\t\t\t\t\telse\n\t\t\t\t\t\t    continue;\n\t\t\t\t\t    }\n\t\t\t\t\telse\n\t\t\t\t\t    {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t    }\n\t\t\t\t    }\n\t\t\t\telse if(my == y2)\n\t\t\t\t    {\n\t\t\t\t\tif(my != ly)\n\t\t\t\t\t    continue;\n\n\t\t\t\t\tif(hx < lx && lx < hxx)\n\t\t\t\t\t    {\n\t\t\t\t\t\tif(!used[cmap[ly][lx]-'A'])\n\t\t\t\t\t\t    {\n\t\t\t\t\t\t\tok2 = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t    }\n\t\t\t\t\t\telse \n\t\t\t\t\t\t    continue;\n\t\t\t\t\t    }\n\t\t\t\t\telse\n\t\t\t\t\t    {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t    }\n\t\t\t\t    }\n\n\t\t\t    }\n\n\t\t\t//System.out.println(\"3 PASSED! \" + M_list.get(i).extraterrestrial);\n\n\n\t\t\tif(ok && ok2)\n\t\t\t    {\n\n\t\t\t\t//System.out.println(\"OK: \" + M_list.get(i).extraterrestrial);\n\t\t\t\tcnt+=2;\n\t\t\t\tfinish = false;\n\t\t\t\tused[M_list.get(i).extraterrestrial-'A'] = true;\n\t\t\t    }\n\n\n\t\t    }\n\n\n\t    }\n\n\tSystem.out.println(cnt);\n\t\n    }\n\n\n\t\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Deque;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\tnew Main().run();\n\t}\n\t\n\tScanner scanner = new Scanner(System.in);\n\tint m;\n\tint[][][] tile = new int[26][2][2];\n\tDeque<Integer> que = new ArrayDeque<Integer>();\n\tboolean[] cantGet =new boolean[26];\n\tboolean[] check =new boolean[26];\n\tint score = 0;\n\t\n\tvoid run() {\n\t\t\n\t\tm = scanner.nextInt();\n\t\tscanner.nextInt();\n\t\t\n\t\tfor (int color = 0; color < tile.length; color ++) {\n\t\t\t\n\t\t\ttile[color][0][0] = -1;\n\t\t\tcantGet[color] = false;\n\t\t\tcheck[color] = false;\n\t\t}\n\t\t\n\t\tfor (int y = 0; y < m; y ++) {\n\t\t\t\n\t\t\tchar[] line = scanner.next().toCharArray();\n\t\t\t\n\t\t\tfor (int x = 0; x < line.length; x ++) {\n\t\t\t\t\n\t\t\t\tif(line[x] != '.') {\n\t\t\t\t\t\n\t\t\t\t\tint color = line[x] - 'A';\n\t\t\t\t\tint index = (tile[color][0][0] == -1) ? 0: 1;\n\t\t\t\t\ttile[color][index][0] = x;\n\t\t\t\t\ttile[color][index][1] = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong s = System.currentTimeMillis();\n\t\tfor (int color = 0; color < tile.length; color ++) {\n\t\t\t\n\t\t\tif (tile[color][0][0] != -1\n\t\t\t\t\t&& ! tryGet(color) && ! que.isEmpty()) {\n\t\t\t\t\n\t\t\t\tbfs();\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(System.currentTimeMillis()-s);\n\t\t\n\t\tSystem.out.println(score * 2);\n\t}\n\t\n\tCollection<Integer> old = new ArrayList<Integer>(que);\n\t\n\tvoid bfs() {\n\t\t\n\t\tdo {\n\t\t\t\n\t\t\told.clear();\n\t\t\told.addAll(que);\n\t\t\tint color;\n\t\t\tint last = que.getLast();\n\t\t\tdo {\n\t\t\t\t\n\t\t\t\tcolor = que.remove();\n\t\t\t\ttryGet(color);\n\t\t\t\t\n\t\t\t} while (color != last);\n\t\t\t\n\t\t} while (! que.isEmpty() && ! old.containsAll(que));\n\t\t\n\t\tif (! que.isEmpty()) {\n\t\t\t\n\t\t\tfor (int color : que) {\n\t\t\t\t\n\t\t\t\tcantGet[color] = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tboolean tryGet(int color) {\n\t\t\n\t\tif (cantGet[color]) {\n\t\t\t\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (! check[color]) {\n\t\t\t\n\t\t\tcheck[color] = true;\n\t\t\tif ((tile[color][0][0] == tile[color][1][0]\n\t\t\t\t\t&& Math.abs(tile[color][0][1] - tile[color][1][1]) == 1)\n\t\t\t\t\t|| (tile[color][0][1] == tile[color][1][1]\n\t\t\t\t\t&& Math.abs(tile[color][0][0] - tile[color][1][0]) == 1)) {\n\t\t\t\t\n\t\t\t\tcantGet[color] = true;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif((isEmpty(color, 1, tile[color][0][0], tile[color][0][1], tile[color][1][1])\n\t\t\t\t\t&& isEmpty(color, 0, tile[color][1][1], tile[color][0][0], tile[color][1][0]))\n\t\t\t\t|| (isEmpty(color, 1, tile[color][1][0], tile[color][0][1], tile[color][1][1])\n\t\t\t\t\t&& isEmpty(color, 0, tile[color][0][1], tile[color][0][0], tile[color][1][0]))) {\n\t\t\t\n\t\t\ttile[color][0][0] = -1;\n\t\t\tscore ++;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tque.add(color);\n\t\treturn false;\n\t}\n\t\n\tboolean isEmpty(int skip,int axis, int point, int start, int end) {\n\t\t\n\t\tif (start == end) {\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tif (start > end) {\n\t\t\t\n\t\t\tint swap = start;\n\t\t\tstart = end;\n\t\t\tend = swap;\n\t\t}\n\t\t\n\t\tboolean isEmpty = true;\n\t\tfor (int color = 0; color < tile.length; color ++) {\n\t\t\t\n\t\t\tif (color == skip\n\t\t\t\t\t|| tile[color][0][0] == -1) {\n\t\t\t\t\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int index = 0; index < tile[0].length; index ++) {\n\t\t\t\t\n\t\t\t\tif (tile[color][index][1 - axis] == point\n\t\t\t\t\t\t&& tile[color][index][axis] >= start\n\t\t\t\t\t\t&& tile[color][index][axis] <= end) {\n\t\t\t\t\t\n\t\t\t\t\tisEmpty = false;\n\t\t\t\t\tif (! que.contains(color)\n\t\t\t\t\t\t\t&& ! cantGet[color]) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tque.add(color);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn isEmpty;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Deque;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\tnew Main().run();\n\t}\n\t\n\tScanner scanner = new Scanner(System.in);\n\tint m;\n\tint[][][] tile = new int[26][2][2];\n\tDeque<Integer> que = new ArrayDeque<Integer>();\n\tboolean[] cantGet =new boolean[26];\n\tboolean[] check =new boolean[26];\n\tint score = 0;\n\t\n\tvoid run() {\n\t\t\n\t\tm = scanner.nextInt();\n\t\tscanner.nextInt();\n\t\t\n\t\tfor (int color = 0; color < tile.length; color ++) {\n\t\t\t\n\t\t\ttile[color][0][0] = -1;\n\t\t\tcantGet[color] = false;\n\t\t\tcheck[color] = false;\n\t\t}\n\t\t\n\t\tfor (int y = 0; y < m; y ++) {\n\t\t\t\n\t\t\tchar[] line = scanner.next().toCharArray();\n\t\t\t\n\t\t\tfor (int x = 0; x < line.length; x ++) {\n\t\t\t\t\n\t\t\t\tif(line[x] != '.') {\n\t\t\t\t\t\n\t\t\t\t\tint color = line[x] - 'A';\n\t\t\t\t\tint index = (tile[color][0][0] == -1) ? 0: 1;\n\t\t\t\t\ttile[color][index][0] = x;\n\t\t\t\t\ttile[color][index][1] = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int color = 0; color < tile.length; color ++) {\n\t\t\t\n\t\t\tif (tile[color][0][0] != -1\n\t\t\t\t\t&& ! tryGet(color) && ! que.isEmpty()) {\n\t\t\t\t\n\t\t\t\tbfs();\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(score * 2);\n\t}\n\t\n\tCollection<Integer> old = new ArrayList<Integer>(que);\n\t\n\tvoid bfs() {\n\t\t\n\t\tdo {\n\t\t\t\n\t\t\told.clear();\n\t\t\told.addAll(que);\n\t\t\tint color;\n\t\t\tint last = que.getLast();\n\t\t\tdo {\n\t\t\t\t\n\t\t\t\tcolor = que.remove();\n\t\t\t\ttryGet(color);\n\t\t\t\t\n\t\t\t} while (color != last);\n\t\t\t\n\t\t} while (! que.isEmpty() && ! old.containsAll(que));\n\t\t\n\t\tif (! que.isEmpty()) {\n\t\t\t\n\t\t\tfor (int color : que) {\n\t\t\t\t\n\t\t\t\tcantGet[color] = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tboolean tryGet(int color) {\n\t\t\n\t\tif (cantGet[color]) {\n\t\t\t\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (! check[color]) {\n\t\t\t\n\t\t\tcheck[color] = true;\n\t\t\tif ((tile[color][0][0] == tile[color][1][0]\n\t\t\t\t\t&& Math.abs(tile[color][0][1] - tile[color][1][1]) == 1)\n\t\t\t\t\t|| (tile[color][0][1] == tile[color][1][1]\n\t\t\t\t\t&& Math.abs(tile[color][0][0] - tile[color][1][0]) == 1)) {\n\t\t\t\t\n\t\t\t\tcantGet[color] = true;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif((isEmpty(color, 1, tile[color][0][0], tile[color][0][1], tile[color][1][1])\n\t\t\t\t\t&& isEmpty(color, 0, tile[color][1][1], tile[color][0][0], tile[color][1][0]))\n\t\t\t\t|| (isEmpty(color, 1, tile[color][1][0], tile[color][0][1], tile[color][1][1])\n\t\t\t\t\t&& isEmpty(color, 0, tile[color][0][1], tile[color][0][0], tile[color][1][0]))) {\n\t\t\t\n\t\t\ttile[color][0][0] = -1;\n\t\t\tscore ++;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tque.add(color);\n\t\treturn false;\n\t}\n\t\n\tboolean isEmpty(int skip,int axis, int point, int start, int end) {\n\t\t\n\t\tif (start == end) {\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tif (start > end) {\n\t\t\t\n\t\t\tint swap = start;\n\t\t\tstart = end;\n\t\t\tend = swap;\n\t\t}\n\t\t\n\t\tboolean isEmpty = true;\n\t\tfor (int color = 0; color < tile.length; color ++) {\n\t\t\t\n\t\t\tif (color == skip\n\t\t\t\t\t|| tile[color][0][0] == -1) {\n\t\t\t\t\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int index = 0; index < tile[0].length; index ++) {\n\t\t\t\t\n\t\t\t\tif (tile[color][index][1 - axis] == point\n\t\t\t\t\t\t&& tile[color][index][axis] >= start\n\t\t\t\t\t\t&& tile[color][index][axis] <= end) {\n\t\t\t\t\t\n\t\t\t\t\tisEmpty = false;\n\t\t\t\t\tif (! que.contains(color)\n\t\t\t\t\t\t\t&& ! cantGet[color]) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tque.add(color);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn isEmpty;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tint n, m;\n\tchar[][] map;\n\tboolean[][] removed;\n\tint ans;\n\tint type='Z'-'A'+1;\n\tLinkedList<P> pList;\n\n\tvoid run(){\n\t\tn=sc.nextInt();\n\t\tm=sc.nextInt();\n\t\tmap=new char[n][];\n\t\tfor(int j=0; j<n; j++){\n\t\t\tmap[j]=sc.next().toCharArray();\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tLinkedList<P>[] lists=new LinkedList[type];\n\t\tfor(int i=0; i<type; i++){\n\t\t\tlists[i]=new LinkedList<P>();\n\t\t}\n\t\tfor(int j=0; j<n; j++){\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tif(map[j][i]!='.'){\n\t\t\t\t\tlists[map[j][i]-'A'].add(new P(i, j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tpList=new LinkedList<P>();\n\t\tfor(int i=0; i<type; i++){\n\t\t\tif(lists[i].size()==2){\n\t\t\t\tP p1=lists[i].get(0);\n\t\t\t\tP p2=lists[i].get(1);\n\t\t\t\tif(p1.x==p2.x){\n\t\t\t\t\tfor(int y=min(p1.y, p2.y)+1; y<max(p1.y, p2.y); y++){\n\t\t\t\t\t\tpList.add(new P(p1.x, y));\n\t\t\t\t\t}\n\t\t\t\t}else if(p1.y==p2.y){\n\t\t\t\t\tfor(int x=min(p1.x, p2.x)+1; x<max(p1.x, p2.x); x++){\n\t\t\t\t\t\tpList.add(new P(x, p1.y));\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tpList.add(new P(p1.x, p2.y));\n\t\t\t\t\tpList.add(new P(p2.x, p1.y));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint[] dx={0, 0, -1, 1};\n\t\tint[] dy={-1, 1, 0, 0};\n\n\t\tans=0;\n\t\tremoved=new boolean[n][m];\n\t\tfor(;;){\n\t\t\tint s=0;\n\t\t\tfor(P p : pList){\n\t\t\t\tif(map[p.y][p.x]=='.'||removed[p.y][p.x]){}else{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tP[] ps=new P[4];\n\t\t\t\tfor(int k=0; k<4; k++){\n\t\t\t\t\tps[k]=get(p.x, p.y, dx[k], dy[k]);\n\t\t\t\t}\n\t\t\t\tfor(int j=0; j<4; j++){\n\t\t\t\t\tfor(int i=j+1; i<4; i++){\n\t\t\t\t\t\tif(ps[i]!=null&&ps[j]!=null\n\t\t\t\t\t\t\t\t&&map[ps[i].y][ps[i].x]==map[ps[j].y][ps[j].x]){\n\t\t\t\t\t\t\tremoved[ps[i].y][ps[i].x]=true;\n\t\t\t\t\t\t\tremoved[ps[j].y][ps[j].x]=true;\n\t\t\t\t\t\t\ts+=2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans+=s;\n\t\t\tif(s==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprintln(ans+\"\");\n\t}\n\n\tP get(int x, int y, int dx, int dy){\n\t\tfor(x+=dx, y+=dy; x>=0&&x<m&&y>=0&&y<n; x+=dx, y+=dy){\n\t\t\tif(!removed[y][x]&&map[y][x]!='.'){\n\t\t\t\treturn new P(x, y);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tclass P{\n\t\tint x, y;\n\n\t\tP(int x, int y){\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString(){\n\t\t\treturn \"(\"+x+\",\"+y+\")\";\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\t\tint h = sc.nextInt();\n\t\tint w = sc.nextInt();\n\n\t\tchar map[][] = new char[h][];\n\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tmap[i] = sc.next().toCharArray();\n\t\t}\n\n\t\tint mask[][] = new int[h][w];\n\t\tint max = 0;\n\n\t\tint y[] = new int[h];\n\t\tint t[] = new int[w];\n\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (map[i][j] == '.') {\n\t\t\t\t\tmask[i][j] = 0;\n\t\t\t\t} else {\n\t\t\t\t\tmask[i][j] = 1 << (map[i][j] - 'A');\n\t\t\t\t\tmax = Math.max(map[i][j] - 'A', max);\n\t\t\t\t}\n\t\t\t\ty[i] |= mask[i][j];\n\t\t\t\tt[j] |= mask[i][j];\n\t\t\t}\n\t\t}\n\t\tmax += 1;\n\t\tboolean dp[] = new boolean[1 << max];\n\t\tdp[0] = true;\n\t\tint n = max;\n\t\tint mk = 0;\n\n\t\tint nnt[] = new int[n];\n\t\tint nnt2[] = new int[n];\n\t\tint nny[] = new int[n];\n\t\tint nny2[] = new int[n];\n\t\t\n\t\tint memo[] = new int[n];\n\t\tArrays.fill(memo, -1);\n\t\tint memo2[] = new int[n];\n\t\tArrays.fill(memo, -1);\n\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tint shj = 1 << j;\n\n\t\t\tint nt = -1;\n\t\t\tint nt2 = -1;\n\t\t\tint ny = -1;\n\t\t\tint ny2 = -1;\n\t\t\tfor (int ii = 0; ii < h; ii++) {\n\t\t\t\tif ((y[ii] & shj) != 0) {\n\t\t\t\t\tif (nt == -1) {\n\t\t\t\t\t\tnt = ii;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnt2 = ii;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int ii = 0; ii < w; ii++) {\n\t\t\t\tif ((t[ii] & shj) != 0) {\n\t\t\t\t\tif (ny == -1) {\n\t\t\t\t\t\tny = ii;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tny2 = ii;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (nt2 == -1) {\n\t\t\t\tnt2 = nt;\n\t\t\t}\n\t\t\tif (ny2 == -1) {\n\t\t\t\tny2 = ny;\n\t\t\t}\n\n\t\t\tif ((nt & ny) == -1) {\n\t\t\t\tnnt[j] = nt;\n\t\t\t\tnnt2[j] = nt2;\n\t\t\t\tnny[j] = ny;\n\t\t\t\tnny2[j] = ny2;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (mask[nt][ny] == shj) {\n\t\t\t\tint temp = ny2;\n\t\t\t\tny2 = ny;\n\t\t\t\tny = temp;\n\t\t\t}\n\n\t\t\tnnt[j] = nt;\n\t\t\tnnt2[j] = nt2;\n\t\t\tnny[j] = ny;\n\t\t\tnny2[j] = ny2;\n\n\t\t\tint tf = 0;\n\t\t\tint tf2 = 0;\n\t\t\tfor (int ii = Math.min(nt, nt2); ii <= Math.max(nt, nt2); ii++) {\n\t\t\t\ttf |= mask[ii][ny];\n\t\t\t\ttf2 |= mask[ii][ny2];\n\t\t\t}\n\n\t\t\tint yf = 0;\n\t\t\tint yf2 = 0;\n\t\t\tfor (int ii = Math.min(ny, ny2); ii <= Math.max(ny, ny2); ii++) {\n\t\t\t\tyf |= mask[nt][ii];\n\t\t\t\tyf2 |= mask[nt2][ii];\n\n\t\t\t}\n\n\t\t\tmemo[j] = tf | yf;\n\t\t\tmemo2[j] = tf2 | yf2;\n\n\t\t}\n\t\t/*\n\t\t * System.out.println(nnt['Z'-'A']+\" \"+nnt2['Z'-'A']);\n\t\t * System.out.println(nny['Z'-'A']+\" \"+nny2['Z'-'A']);\n\t\t * System.out.println(\"-----------------\");\n\t\t * System.out.println(nnt['U'-'A']+\" \"+nnt2['U'-'A']);\n\t\t * System.out.println(nny['U'-'A']+\" \"+nny2['U'-'A']);\n\t\t * System.out.println(\"-----------------\");\n\t\t */\n\n\t\tfor (int i = 0; i < 1 << n; i++) {\n\t\t\tif (!dp[i]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tint shj = 1 << j;\n\t\t\t\tif ((i & shj) != 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint nt = nnt[j];\n\t\t\t\tint nt2 = nnt2[j];\n\t\t\t\tint ny = nny[j];\n\t\t\t\tint ny2 = nny2[j];\n\n\t\t\t\tif ((nt & ny) == -1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (Math.abs(nt - nt2) + Math.abs(ny2 - ny) < 2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tboolean ok = true;\n\n\t\t\t\tif (((~(i | shj)) & (memo[j])) == 0\n\t\t\t\t\t\t|| ((~(i | shj)) & (memo2[j])) == 0) {\n\t\t\t\t\tok = true;\n\t\t\t\t} else {\n\t\t\t\t\tok = false;\n\t\t\t\t}\n\n\t\t\t\tif (ok) {\n//\t\t\t\t\t System.out.println(i + \" \" + Integer.bitCount(i) + \" \" +\n//\t\t\t\t\t (char) (j + 'A'));\n\t\t\t\t\t dp[i|shj]=true;\n\t\t\t\t\t mk = Math.max(Integer.bitCount(i|shj), mk);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(mk * 2);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Tiles are Colorful\npublic class Main{\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint h = sc.nextInt();\n\t\tint w = sc.nextInt();\n\t\tchar[][] map = new char[h][w];\n\t\tfor(int i=0;i<h;i++)map[i] = sc.next().toCharArray();\n\t\tboolean[] exist = new boolean[26];\n\t\tint[] num = new int[26];\n\t\tint[][][] pos = new int[26][2][2];\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(map[i][j]=='.')continue;\n\t\t\t\tint id = map[i][j]-'A';\n\t\t\t\texist[id] = true;\n\t\t\t\tpos[id][num[id]][0] = i;\n\t\t\t\tpos[id][num[id]][1] = j;\n\t\t\t\tnum[id]++;\n\t\t\t}\n\t\t}\n\t\tlong[][] cond = new long[26][2];\n\t\tfor(int i=0;i<26;i++){\n\t\t\tif(!exist[i])continue;\n\t\t\tif(pos[i][0][0]==pos[i][1][0]){\n\t\t\t\tcond[i][1] = -1;\n\t\t\t\tif(Math.abs(pos[i][0][1]-pos[i][1][1])==1)cond[i][0] = -1;\n\t\t\t\telse{\n\t\t\t\t\tlong s = 0;\n\t\t\t\t\tfor(int j=pos[i][0][1]+1;j<pos[i][1][1];j++){\n\t\t\t\t\t\tchar ch = map[pos[i][0][0]][j];\n\t\t\t\t\t\tif(ch=='.')continue;\n\t\t\t\t\t\ts |= 1<<((int)(ch-'A'));\n\t\t\t\t\t}\n\t\t\t\t\tcond[i][0] = s;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(pos[i][0][1]==pos[i][1][1]){\n\t\t\t\tcond[i][1] = -1;\n\t\t\t\tif(pos[i][0][0]+1==pos[i][1][0]){\n\t\t\t\t\tcond[i][0] = -1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlong s = 0;\n\t\t\t\tfor(int j=pos[i][0][0]+1;j<pos[i][1][0];j++){\n\t\t\t\t\tchar ch = map[j][pos[i][0][1]];\n\t\t\t\t\tif(ch=='.')continue;\n\t\t\t\t\ts |= 1<<((int)(ch-'A'));\n\t\t\t\t}\n\t\t\t\tcond[i][0] = s;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(pos[i][0][1]<pos[i][1][1]){\n\t\t\t\t\tint ri = pos[i][0][0];\n\t\t\t\t\tint rj = pos[i][1][1];\n\t\t\t\t\tint li = pos[i][1][0];\n\t\t\t\t\tint lj = pos[i][0][1];\n\t\t\t\t\tlong s = 0;\n\t\t\t\t\tfor(int j=lj+1;j<=rj;j++){\n\t\t\t\t\t\tchar ch = map[ri][j];\n\t\t\t\t\t\tif(ch=='.')continue;\n\t\t\t\t\t\ts |= 1<<((int)(ch-'A'));\n\t\t\t\t\t}\n\t\t\t\t\tfor(int j=ri;j<li;j++){\n\t\t\t\t\t\tchar ch = map[j][rj];\n\t\t\t\t\t\tif(ch=='.')continue;\n\t\t\t\t\t\ts |= 1<<((int)(ch-'A'));\n\t\t\t\t\t}\n\t\t\t\t\tcond[i][0] = s;\n\t\t\t\t\ts = 0;\n\t\t\t\t\tfor(int j=ri+1;j<=li;j++){\n\t\t\t\t\t\tchar ch = map[j][lj];\n\t\t\t\t\t\tif(ch=='.')continue;\n\t\t\t\t\t\ts |= 1<<((int)(ch-'A'));\n\t\t\t\t\t}\n\t\t\t\t\tfor(int j=lj+1;j<rj;j++){\n\t\t\t\t\t\tchar ch = map[li][j];\n\t\t\t\t\t\tif(ch=='.')continue;\n\t\t\t\t\t\ts |= 1<<((int)(ch-'A'));\n\t\t\t\t\t}\n\t\t\t\t\tcond[i][1] = s;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint li = pos[i][1][0];\n\t\t\t\t\tint lj = pos[i][1][1];\n\t\t\t\t\tint ri = pos[i][0][0];\n\t\t\t\t\tint rj = pos[i][0][1];\n\t\t\t\t\tlong s = 0;\n\t\t\t\t\tfor(int j=lj;j<rj;j++){\n\t\t\t\t\t\tchar ch = map[ri][j];\n\t\t\t\t\t\tif(ch=='.')continue;\n\t\t\t\t\t\ts |= 1<<((int)(ch-'A'));\n\t\t\t\t\t}\n\t\t\t\t\tfor(int j=ri;j<li;j++){\n\t\t\t\t\t\tchar ch = map[j][lj];\n\t\t\t\t\t\tif(ch=='.')continue;\n\t\t\t\t\t\ts |= 1<<((int)(ch-'A'));\n\t\t\t\t\t}\n\t\t\t\t\tcond[i][0] = s;\n\t\t\t\t\ts = 0;\n\t\t\t\t\tfor(int j=ri+1;j<=li;j++){\n\t\t\t\t\t\tchar ch = map[j][rj];\n\t\t\t\t\t\tif(ch=='.')continue;\n\t\t\t\t\t\ts |= 1<<((int)(ch-'A'));\n\t\t\t\t\t}\n\t\t\t\t\tfor(int j=lj+1;j<=rj;j++){\n\t\t\t\t\t\tchar ch = map[li][j];\n\t\t\t\t\t\tif(ch=='.')continue;\n\t\t\t\t\t\ts |= 1<<((int)(ch-'A'));\n\t\t\t\t\t}\n\t\t\t\t\tcond[i][1] = s;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint c = 0;\n\t\tboolean update = true;\n\t\tlong s = 0;\n\t\twhile(update){\n\t\t\tupdate = false;\n\t\t\tfor(int i=0;i<26;i++){\n\t\t\t\tif(!exist[i])continue;\n\t\t\t\tif(cond[i][0]!=-1&&((s&cond[i][0])==cond[i][0]) || cond[i][1]!=-1&&((s&cond[i][1])==cond[i][1])){\n\t\t\t\t\texist[i] = false;\n\t\t\t\t\tc++;\n\t\t\t\t\ts|=1<<i;\n\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(c*2);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\n\n\nclass Main {\n\tstatic int[] vy = {1,0,-1,0};\n\tstatic int[] vx = {0,1,0,-1};\n\tstatic long mod = 1000000007;\n\tpublic static void main(String[] args) {\t\n\t\tFastScanner sc = new FastScanner();\n\t\t//Scanner sc = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint M = sc.nextInt();\n\t\tint N = sc.nextInt();\n\t\tchar[][] map = new char[M][];\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tmap[i] = sc.next().toCharArray();\n\t\t}\n\t\t\n\t\t\n\t\tint sum = 0;\n\t\tboolean ok = true;\n\t\twhile(ok) {\n\t\t\tok = false;\n\t\t\tfor(int i = 0; i < M; i++) {\n\t\t\t\tfor(int j = 0; j < N; j++) {\n\t\t\t\t\tif(map[i][j] != '.') continue;\n\t\t\t\t\tint[] count = new int[26];\n\t\t\t\t\tfor(int k = 0; k < 4; k++) {\n\t\t\t\t\t\tfor(int l = 0; ; l++) {\n\t\t\t\t\t\t\tint tx = j + vx[k] * l;\n\t\t\t\t\t\t\tint ty = i + vy[k] * l;\n\t\t\t\t\t\t\tif(tx < 0 || ty < 0 || tx >= N || ty >= M) break;\n\t\t\t\t\t\t\tif(map[ty][tx] == '.') continue;\n\t\t\t\t\t\t\tcount[map[ty][tx] - 'A']++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int kk = 0; kk < 26; kk++) {\n\t\t\t\t\t\tif(count[kk] == 2) {\n\t\t\t\t\t\t\tfor(int k = 0; k < 4; k++) {\n\t\t\t\t\t\t\t\tfor(int l = 0; ; l++) {\n\t\t\t\t\t\t\t\t\tint tx = j + vx[k] * l;\n\t\t\t\t\t\t\t\t\tint ty = i + vy[k] * l;\n\t\t\t\t\t\t\t\t\tif(tx < 0 || ty < 0 || tx >= N || ty >= M) break;\n\t\t\t\t\t\t\t\t\tif(map[ty][tx] == '.') continue;\n\t\t\t\t\t\t\t\t\tif(map[ty][tx] - 'A' != kk) break;\n\t\t\t\t\t\t\t\t\tmap[ty][tx] = '.';\n\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsum += 2;\n\t\t\t\t\t\t\tok = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tSystem.out.println(sum);\n\t}\n\t\n\tstatic class FastScanner {\n\t    private final InputStream in = System.in;\n\t    private final byte[] buffer = new byte[1024];\n\t    private int ptr = 0;\n\t    private int buflen = 0;\n\t    private boolean hasNextByte() {\n\t        if (ptr < buflen) {\n\t            return true;\n\t        }else{\n\t            ptr = 0;\n\t            try {\n\t                buflen = in.read(buffer);\n\t            } catch (IOException e) {\n\t                e.printStackTrace();\n\t            }\n\t            if (buflen <= 0) {\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\t    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\t    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n\t    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n\t    public String next() {\n\t        if (!hasNext()) throw new NoSuchElementException();\n\t        StringBuilder sb = new StringBuilder();\n\t        int b = readByte();\n\t        while(isPrintableChar(b)) {\n\t            sb.appendCodePoint(b);\n\t            b = readByte();\n\t        }\n\t        return sb.toString();\n\t    }\n\t    public long nextLong() {\n\t        if (!hasNext()) throw new NoSuchElementException();\n\t        long n = 0;\n\t        boolean minus = false;\n\t        int b = readByte();\n\t        if (b == '-') {\n\t            minus = true;\n\t            b = readByte();\n\t        }\n\t        if (b < '0' || '9' < b) {\n\t            throw new NumberFormatException();\n\t        }\n\t        while(true){\n\t            if ('0' <= b && b <= '9') {\n\t                n *= 10;\n\t                n += b - '0';\n\t            }else if(b == -1 || !isPrintableChar(b)){\n\t                return minus ? -n : n;\n\t            }else{\n\t                throw new NumberFormatException();\n\t            }\n\t            b = readByte();\n\t        }\n\t    }\n\t    public int nextInt() {\n\t        if (!hasNext()) throw new NoSuchElementException();\n\t        int n = 0;\n\t        boolean minus = false;\n\t        int b = readByte();\n\t        if (b == '-') {\n\t            minus = true;\n\t            b = readByte();\n\t        }\n\t        if (b < '0' || '9' < b) {\n\t            throw new NumberFormatException();\n\t        }\n\t        while(true){\n\t            if ('0' <= b && b <= '9') {\n\t                n *= 10;\n\t                n += b - '0';\n\t            }else if(b == -1 || !isPrintableChar(b)){\n\t                return minus ? -n : n;\n\t            }else{\n\t                throw new NumberFormatException();\n\t            }\n\t            b = readByte();\n\t        }\n\t    }\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\t\tint h = sc.nextInt();\n\t\tint w = sc.nextInt();\n\n\t\tchar map[][] = new char[h][];\n\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tmap[i] = sc.next().toCharArray();\n\t\t}\n\n\t\tint mask[][] = new int[h][w];\n\t\tint max = 0;\n\n\t\tint y[] = new int[h];\n\t\tint t[] = new int[w];\n\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (map[i][j] == '.') {\n\t\t\t\t\tmask[i][j] = 0;\n\t\t\t\t} else {\n\t\t\t\t\tmask[i][j] = 1 << (map[i][j] - 'A');\n\t\t\t\t\tmax = Math.max(map[i][j] - 'A', max);\n\t\t\t\t}\n\t\t\t\ty[i] |= mask[i][j];\n\t\t\t\tt[j] |= mask[i][j];\n\t\t\t}\n\t\t}\n\t\tmax += 1;\n\t\tboolean dp[] = new boolean[1 << max];\n\t\tdp[0] = true;\n\t\tint n = max;\n\t\tint mk = 0;\n\n\t\tint nnt[] = new int[n];\n\t\tint nnt2[] = new int[n];\n\t\tint nny[] = new int[n];\n\t\tint nny2[] = new int[n];\n\t\t\n\t\tint memo[] = new int[n];\n\t\tArrays.fill(memo, -1);\n\t\tint memo2[] = new int[n];\n\t\tArrays.fill(memo, -1);\n\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tint shj = 1 << j;\n\n\t\t\tint nt = -1;\n\t\t\tint nt2 = -1;\n\t\t\tint ny = -1;\n\t\t\tint ny2 = -1;\n\t\t\tfor (int ii = 0; ii < h; ii++) {\n\t\t\t\tif ((y[ii] & shj) != 0) {\n\t\t\t\t\tif (nt == -1) {\n\t\t\t\t\t\tnt = ii;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnt2 = ii;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int ii = 0; ii < w; ii++) {\n\t\t\t\tif ((t[ii] & shj) != 0) {\n\t\t\t\t\tif (ny == -1) {\n\t\t\t\t\t\tny = ii;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tny2 = ii;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (nt2 == -1) {\n\t\t\t\tnt2 = nt;\n\t\t\t}\n\t\t\tif (ny2 == -1) {\n\t\t\t\tny2 = ny;\n\t\t\t}\n\n\t\t\tif ((nt & ny) == -1) {\n\t\t\t\tnnt[j] = nt;\n\t\t\t\tnnt2[j] = nt2;\n\t\t\t\tnny[j] = ny;\n\t\t\t\tnny2[j] = ny2;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (mask[nt][ny] == shj) {\n\t\t\t\tint temp = ny2;\n\t\t\t\tny2 = ny;\n\t\t\t\tny = temp;\n\t\t\t}\n\n\t\t\tnnt[j] = nt;\n\t\t\tnnt2[j] = nt2;\n\t\t\tnny[j] = ny;\n\t\t\tnny2[j] = ny2;\n\n\t\t\tint tf = 0;\n\t\t\tint tf2 = 0;\n\t\t\tfor (int ii = Math.min(nt, nt2); ii <= Math.max(nt, nt2); ii++) {\n\t\t\t\ttf |= mask[ii][ny];\n\t\t\t\ttf2 |= mask[ii][ny2];\n\t\t\t}\n\n\t\t\tint yf = 0;\n\t\t\tint yf2 = 0;\n\t\t\tfor (int ii = Math.min(ny, ny2); ii <= Math.max(ny, ny2); ii++) {\n\t\t\t\tyf |= mask[nt][ii];\n\t\t\t\tyf2 |= mask[nt2][ii];\n\n\t\t\t}\n\n\t\t\tmemo[j] = tf | yf;\n\t\t\tmemo2[j] = tf2 | yf2;\n\n\t\t}\n\t\t/*\n\t\t * System.out.println(nnt['Z'-'A']+\" \"+nnt2['Z'-'A']);\n\t\t * System.out.println(nny['Z'-'A']+\" \"+nny2['Z'-'A']);\n\t\t * System.out.println(\"-----------------\");\n\t\t * System.out.println(nnt['U'-'A']+\" \"+nnt2['U'-'A']);\n\t\t * System.out.println(nny['U'-'A']+\" \"+nny2['U'-'A']);\n\t\t * System.out.println(\"-----------------\");\n\t\t */\n\n\t\tfor (int i = 0; i < 1 << n; i++) {\n\t\t\tif (!dp[i]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tint shj = 1 << j;\n\t\t\t\tif(dp[i|shj]){\n//\t\t\t\t\tSystem.out.println(\"here\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint nt = nnt[j];\n\t\t\t\tint nt2 = nnt2[j];\n\t\t\t\tint ny = nny[j];\n\t\t\t\tint ny2 = nny2[j];\n\n\t\t\t\tif ((nt & ny) == -1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (Math.abs(nt - nt2) + Math.abs(ny2 - ny) < 2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tboolean ok = true;\n\n\t\t\t\tif (((~(i | shj)) & (memo[j])) == 0\n\t\t\t\t\t\t|| ((~(i | shj)) & (memo2[j])) == 0) {\n\t\t\t\t\tok = true;\n\t\t\t\t} else {\n\t\t\t\t\tok = false;\n\t\t\t\t}\n\n\t\t\t\tif (ok) {\n//\t\t\t\t\t System.out.println(i + \" \" + Integer.bitCount(i) + \" \" +\n//\t\t\t\t\t (char) (j + 'A'));\n\t\t\t\t\t dp[i|shj]=true;\n\t\t\t\t\t mk = Math.max(Integer.bitCount(i|shj), mk);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(mk * 2);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\tnew CopyOfMain().run();\n\t\treturn;\n\t}\n\t\n\tScanner scanner = new Scanner(System.in);\n\tint m;\n\tint[][][] tile = new int[26][2][2];\n\tboolean[] cantGet =new boolean[26];\n\tint score = 0;\n\t\n\tvoid run() {\n\t\t\n\t\tm = scanner.nextInt();\n\t\tscanner.nextInt();\n\t\t\n\t\tfor (int color = 0; color < 26; color ++) {\n\t\t\t\n\t\t\ttile[color][0][0] = -1;\n\t\t\tcantGet[color] = true;\n\t\t}\n\t\t\n\t\tfor (int y = 0; y < m; y ++) {\n\t\t\t\n\t\t\tchar[] line = scanner.next().toCharArray();\n\t\t\t\n\t\t\tfor (int x = 0; x < line.length; x ++) {\n\t\t\t\t\n\t\t\t\tif(line[x] != '.') {\n\t\t\t\t\t\n\t\t\t\t\tint color = line[x] - 'A';\n\t\t\t\t\tcantGet[color] = false;\n\t\t\t\t\tint index = (tile[color][0][0] == -1) ? 0: 1;\n\t\t\t\t\ttile[color][index][0] = x;\n\t\t\t\t\ttile[color][index][1] = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint preScore;\n\t\tdo {\n\t\t\t\n\t\t\tpreScore = score;\n\t\t\t\n\t\t\tfor (int color = 0; color < 26; color ++) {\n\t\t\t\t\n\t\t\t\ttryGet(color);\n\t\t\t}\n\t\t\t\n\t\t} while(preScore != score);\n\t\t\n\t\tSystem.out.println(score * 2);\n\t}\n\t\n\tvoid tryGet(int color) {\n\t\t\n\t\tif (cantGet[color]) {\n\t\t\t\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif ((tile[color][0][0] == tile[color][1][0]\n\t\t\t\t&& Math.abs(tile[color][0][1] - tile[color][1][1]) == 1)\n\t\t\t\t|| (tile[color][0][1] == tile[color][1][1]\n\t\t\t\t&& Math.abs(tile[color][0][0] - tile[color][1][0]) == 1)) {\n\t\t\t\t\n\t\t\tcantGet[color] = true;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif((isEmpty(color, 1, tile[color][0][0], tile[color][0][1], tile[color][1][1])\n\t\t\t\t&& isEmpty(color, 0, tile[color][1][1], tile[color][0][0], tile[color][1][0]))\n\t\t\t\t|| (isEmpty(color, 1, tile[color][1][0], tile[color][0][1], tile[color][1][1])\n\t\t\t\t\t\t&& isEmpty(color, 0, tile[color][0][1], tile[color][0][0], tile[color][1][0]))) {\n\t\t\t\n\t\t\tget(color);\n\t\t}\n\t}\n\t\n\tboolean isEmpty(int skip,int axis, int point, int start, int end) {\n\t\t\n\t\t\n\t\tif (start == end) {\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tif (start > end) {\n\t\t\t\n\t\t\tint swap = start;\n\t\t\tstart = end;\n\t\t\tend = swap;\n\t\t}\n\t\t\n\t\tfor (int color = 0; color < 26; color ++) {\n\t\t\t\n\t\t\tif (color == skip\n\t\t\t\t\t|| tile[color][0][0] == -1) {\n\t\t\t\t\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int index = 0; index < 2; index ++) {\n\t\t\t\t\n\t\t\t\tif (tile[color][index][1 - axis] == point\n\t\t\t\t\t\t&& tile[color][index][axis] >= start\n\t\t\t\t\t\t&& tile[color][index][axis] <= end) {\n\t\t\t\t\t\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tvoid get(int color) {\n\t\t\n\t\ttile[color][0][0] = -1;\n\t\tscore ++;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\nimport java.awt.Point;\n\nclass Main{\n\n    private static final int[] dx = {0,1,0,-1};\n    private static final int[] dy = {1,0,-1,0};\n\n    static class Pox\n    {\n\tpublic int x,y;\n\tpublic char extraterrestrial;\n\n\tPox()\n\t{\n\t    x = y = -1;\n\t    extraterrestrial = 'a';\n\t}\n\n\tPox(char c,int a,int b)\n\t{\n\t    x = a;\n\t    y = b;\n\t    extraterrestrial = c;\n\t}\n\n    }\n\n       \n\n    static class PP\n    {\n\tPoint p1,p2;\n\n\tPP()\n\t{\n\t    p1 = new Point(-1,-1);\n\t    p2 = new Point(-1,-1);\n\t}\n\n\tPP(Point a,Point b)\n\t{\n\t    p1 = a;\n\t    p2 = b;\n\t}\n\n    }\n\n\n      public static void main(String args[])throws IOException\n    {\n\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tint M,N;\n\n\tString line;\n\twhile((line = in.readLine()) != null)\n\t    {\n\n\t\n\tM = Integer.parseInt(line.substring(0,line.indexOf(\" \")));\n\tN = Integer.parseInt(line.substring(line.indexOf(\" \") + 1));\n\n\tLinkedList<Pox> list = new LinkedList<Pox>();//アルファベットの座標\n\tLinkedList<Pox> M_list = new LinkedList<Pox>();//中継地点\n\tHashMap<Character,PP> map = new HashMap<Character,PP>();\n\tchar[][] cmap = new char[M][N];\n\n\n\tfor(int i=0;i<M;i++)\n\t    {\n\t\tline = in.readLine();\n\t\tfor(int j=0;j<N;j++)\n\t\t    {\n\n\t\t\tcmap[i][j] = line.charAt(j);\t\t\n\n\t\t\tif(line.charAt(j) != '.')\n\t\t\t    {\n\t\t\t\tlist.add(new Pox(line.charAt(j),j,i));\n\t\t\t\tif(!map.containsKey(line.charAt(j)))\n\t\t\t\t    {\n\t\t\t\t\tmap.put(line.charAt(j),new PP(new Point(j,i),new Point(-1,-1)));\n\t\t\t\t    }\n\t\t\t\telse\n\t\t\t\t    {\n\t\t\t\t\tint x,y,xx,yy;\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t\txx = map.get(line.charAt(j)).p1.x;\n\t\t\t\t\tyy = map.get(line.charAt(j)).p1.y;\n\t\t\t\t\tmap.put(line.charAt(j),new PP(new Point(xx,yy),new Point(j,i)));\n\n\t\t\t\t\tif(!(x == xx || y == yy))\n\t\t\t\t\t    {\n\t\t\t\t\t\tM_list.add(new Pox(line.charAt(j),x,yy));\n\t\t\t\t\t\tM_list.add(new Pox(line.charAt(j),xx,y));\n\t\t\t\t\t    }\n\t\t\t\t    }\n\t\t\t    } \n\t\t    }\n\t    }\n\n\n\n\n\n\n\n\t/*\n\tfor(int i=0;i<M_list.size();i++)\n\t    {\n\t\tSystem.out.println(\"debug : \" + M_list.get(i).extraterrestrial);\n\t    }\n\t*/\n\n\tboolean[] used = new boolean[28];\t\n\tfor(int i=0;i<28;i++)\n\t    {\n\t\tused[i] = false;\n\t    }\n\n\tboolean finish = false;\n\tint cnt = 0;\n\twhile(!finish)\n\t    {\n\t\tfinish = true;\n\n\t\tfor(int i=0;i<list.size();i++)\n\t\t    {\n\t\t\tif(used[list.get(i).extraterrestrial - 'A'])\n\t\t\t    continue;\n\n\t\t\tint x,y,xx,yy;\n\t\t\tchar c = list.get(i).extraterrestrial;\n\t\t\tx = map.get(c).p1.x;\n\t\t\ty = map.get(c).p1.y;\n\t\t\txx = map.get(c).p2.x;\n\t\t\tyy = map.get(c).p2.y;\n\n\t\t\tint hx,hxx;\n\t\t\tint hy,hyy;\n\n\t\t\thx = Math.min(x,xx);\n\t\t\thxx = Math.max(x,xx);\n\n\t\t\thy = Math.min(y,yy);\n\t\t\thyy = Math.max(y,yy);\n\n\t\t\tif(!(x == xx || y == yy))\n\t\t\t    continue;\n\n\t\t\tboolean ok = true;\n\t\t\tfor(int j=0;j<list.size();j++)\n\t\t\t    {\n\t\t\t\tif(list.get(j).extraterrestrial == c)\n\t\t\t\t    continue;\n\n\t\t\t\tif(used[list.get(j).extraterrestrial-'A'])\n\t\t\t\t    continue;\n\n\t\t\t\tint list_x,list_y;\n\t\t\t\tlist_x = list.get(j).x;\n\t\t\t\tlist_y = list.get(j).y;\n\n\t\t\t\tif(x == xx)\n\t\t\t\t    {\n\t\t\t\t\tif(x == list_x)\n\t\t\t\t\t    {\n\t\t\t\t\t\tif(hy < list_y && list_y < hyy)\n\t\t\t\t\t\t    {\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t    }\n\t\t\t\t\t\telse\n\t\t\t\t\t\t    {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t    }\n\t\t\t\t\t    }\n\t\t\t\t\telse\n\t\t\t\t\t    {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t    }\n\t\t\t\t    }\n\t\t\t\telse if(y == yy)\n\t\t\t\t    {\n\t\t\t\t\tif(y == list_y)\n\t\t\t\t\t    {\n\t\t\t\t\t\tif(hx < list_x && list_x < hxx)\n\t\t\t\t\t\t    {\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t    }\n\t\t\t\t\t\telse\n\t\t\t\t\t\t    {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t    }\n\t\t\t\t\t    }\n\t\t\t\t\telse\n\t\t\t\t\t    {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t    }\n\n\t\t\t\t    }\n\t\t\t\t\n\n\t\t\t    }\n\n\t\t\tif(ok)\n\t\t\t    {\n\n\t\t\t\tint xp,yp;\n\t\t\t\txp = list.get(i).x;\n\t\t\t\typ = list.get(i).y;\n\n\t\t\t\tboolean NoWay = false;\t\t\t\t\n\n\t\t\t\tfor(int j=0;j<4;j++)\n\t\t\t\t    {\n\t\t\t\t\tint nx = xp + dx[j],ny = yp + dy[j];\n\t\t\t\t\tif(!(0<= nx && nx <N && 0<= ny && ny <M ))\n\t\t\t\t\t    continue;\n\n\t\t\t\t\tif(cmap[ny][nx] == list.get(i).extraterrestrial)\n\t\t\t\t\t    {\n\t\t\t\t\t\tNoWay = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t    }\n\t\t\t\t    }\n\n\t\t\t\tif(NoWay)\n\t\t\t\t    continue;\n\n\t\t\t\t//System.out.println(\"OK P1 : \" + list.get(i).extraterrestrial);\n\t\t\t\tcnt += 2;\n\t\t\t\tused[list.get(i).extraterrestrial-'A'] = true;\n\t\t\t\tfinish = false;\n\t\t\t    }\n\n\t\t    }\n\n\n\n\t\tfor(int i=0; i<M_list.size();i++)\n\t\t    {\n\t\t\tif(used[M_list.get(i).extraterrestrial-'A'])\n\t\t\t    continue;\n\n\t\t\t//\tSystem.out.println(\"GO! -> \" + M_list.get(i).extraterrestrial);\n\n\t\t\tint mx,my,x1,y1,x2,y2;\n\n\t\t\tmx = M_list.get(i).x;\n\t\t\tmy = M_list.get(i).y;\n\n\t\t\t//System.out.println(\"the coordinates : \" + mx + \",\" + my );\n\t\t\t\n\t\t\tif(cmap[my][mx] != '.')\n\t\t\t    {\n\t\t\t\tif(!used[cmap[my][mx]-'A'])\n\t\t\t\t    {\n\t\t\t\t\tcontinue;\n\t\t\t\t    }\n\t\t\t    }\n\n\t\t\n\t\t\tPoint pp = map.get(M_list.get(i).extraterrestrial).p1;\n\t\t\tPoint ppp = map.get(M_list.get(i).extraterrestrial).p2;\n\n\t\t\tx1 = pp.x;\n\t\t\ty1 = pp.y;\n\n\t\t\tx2 = ppp.x;\n\t\t\ty2 = ppp.y;\n\n\n\t\t\t//System.out.println(\"x1y1 : \" + x1 + \",\" + y1 + \" x2y2 : \" + x2 + \",\" + y2);\n\n\t\t\tif(x2 == -1 && y2 == -1)\n\t\t\t    continue;\n\n\n\t\t\tint hx,hy,hxx,hyy;\n\n\t\t\thx = Math.min(mx,x1);\n\t\t\thxx = Math.max(mx,x1);\n\t\t\thy = Math.min(my,y1);\t\t\t\n\t\t\thyy = Math.max(my,y1);\n\n\n\t\t\n\t\t      \n\n\t\t\tboolean ok = true;\n\t\t\tfor(int j=0;j<list.size();j++)\n\t\t\t    {\t\t\t\t    \n\t\t       \n\t\t\t\tif(used[list.get(j).extraterrestrial-'A'])\n\t\t\t\t    {\n\t\t\t\t\tcontinue;\n\t\t\t\t    }\n\n\t\t\t\tif(list.get(j).extraterrestrial == M_list.get(i).extraterrestrial)\n\t\t\t\t    {\n\t\t\t\t\tcontinue;\n\t\t\t\t    }\n\n\t\t\t\tint lx,ly;\n\t\t\t\tlx = list.get(j).x;\n\t\t\t\tly = list.get(j).y;\n\n\t\t\n\t\t    \n\t\t\t\n\t\t\t\t//System.out.println(\"all information : mxy \" + mx + \",\" + my + \" lxy \" + lx + \",\" + ly);\n\n\t\t\t\tif(mx == x1)\n\t\t\t\t    {\n\t\t\t\t\tif(mx != lx)\n\t\t\t\t\t    continue;\n\n\t\t\t\t\tif(hy < ly && ly < hyy)\n\t\t\t\t\t    {\n\t\t\t\t\t\tif(!used[cmap[ly][lx]-'A'])\n\t\t\t\t\t\t    {\n\t\t\t\t\t\t\t//System.out.println(\"MISS! p3 \" + M_list.get(i).extraterrestrial);\n\t\t\t\t\t\t\t//System.out.println(\"p4 : \" + cmap[ly][lx] + \" : \" + lx + \",\" + ly);\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t    }\n\t\t\t\t\t    }\n\t\t\t\t\telse\n\t\t\t\t\t    {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t    }\n\t\t\t\t    }\n\t\t\t\telse if(my == y1)\n\t\t\t\t    {\n\t\t\t\t\t\n\t\t\t\t\tif(my != ly)\n\t\t\t\t\t    continue;\n\t\t\t\t\tif(hx < lx && lx < hxx)\n\t\t\t\t\t    {\n\t\t\t\t\t\tif(!used[cmap[ly][lx]-'A'])\n\t\t\t\t\t\t    {    \n\t\t\t\t\t\t\t//System.out.println(\"MISS! p4 \" + M_list.get(i).extraterrestrial );\n\t\t\t\t\t\t\t//System.out.println(\"p4 : \" + cmap[ly][lx] + \" : \" + lx + \",\" + ly);\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t    }\n\t\t\t\t\t    }\n\t\t\t\t\telse\n\t\t\t\t\t    {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t    }\n\t\t\t\t    }\n\n\t\t\t    }\n\n\t\t\tif(!ok)\n\t\t\t    {\n\t\t\t\tcontinue;\n\t\t\t    }\n\n\t\t\t//\tSystem.out.println(\"2 PASSED! \" + M_list.get(i).extraterrestrial);\n\n\n\t\t\tboolean ok2 = true;\n\t\t\thx = Math.min(mx,x2);\n\t\t\thxx = Math.max(mx,x2);\n\t\t\thy = Math.min(my,y2);\n\t\t\thyy = Math.max(my,y2);\n\n\t\t\tfor(int j=0;j<list.size();j++)\n\t\t\t    {\n\t\t\t\tif(used[list.get(j).extraterrestrial-'A'])\n\t\t\t\t    continue;\n\n\t\t\t\tif(list.get(j).extraterrestrial == M_list.get(i).extraterrestrial)\n\t\t\t\t    continue;\n\n\t\t\t\tint lx,ly;\n\t\t\t\tlx = list.get(j).x;\n\t\t\t\tly = list.get(j).y;\n\n\t\t\t\t//System.out.println(\"OK? mxy : \" + mx + \",\" + my + \" lxy : \" + lx + \",\" + ly + \" x2 : \" + x2 +\",\"+y2 );\n\n\t\t\t\t/*\n\t\t\t\tif(cmap[ly][lx] != '.')\n\t\t\t\t    {\n\t\t\t\t\tif(!used[cmap[ly][lx]-'A'])\n\t\t\t\t\t    {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t    }\n\t\t\t\t    }\n\t\t\t\t*/\n\n\t\t\t\tif(mx == x2)\n\t\t\t\t    {\n\n\t\t\t\t\t//System.out.println(\"here\");\n\t\t\t\t\tif(mx != lx)\n\t\t\t\t\t    {\n\t\t\t\t\t\t//System.out.println(\"MISS X : lxy \" + lx + \",\" + ly );\n\t\t\t\t\t    continue;\n\t\t\t\t\t    }\n\t\t\t\t\t\n\t\t\t\t\tif(hy < ly && ly < hyy)\n\t\t\t\t\t    {\n\t\t\t\t\t\tif(!used[cmap[ly][lx]-'A'])\n\t\t\t\t\t\t    {\n\t\t\t\t\t\t       \n\t\t\t\t\t\t\t//System.out.println(\"MISS X : lxy \" + lx + \",\" + ly );\n\t\t\t\t\t\t\tok2 = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t    }\n\t\t\t\t\t\telse\n\t\t\t\t\t\t    continue;\n\t\t\t\t\t    }\n\t\t\t\t\telse\n\t\t\t\t\t    {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t    }\n\t\t\t\t    }\n\t\t\t\telse if(my == y2)\n\t\t\t\t    {\n\t\t\t\t\t//System.out.println(\"herere\");\n\t\t\t\t\tif(my != ly)\n\t\t\t\t\t    {\n\t\t\t\t\t\t//System.out.println(\"OUT! \" + lx + \",\" + ly );\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t    }\n\n\t\t\t\t\tif(hx < lx && lx < hxx)\n\t\t\t\t\t    {\n\t\t\t\t\t\tif(!used[cmap[ly][lx]-'A'])\n\t\t\t\t\t\t    {\n\t\t\t\t\t\t\t//System.out.println(\"MISS X : lxy \" + lx + \",\" + ly );\n\t\t\t\t\t\t\tok2 = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t    }\n\t\t\t\t\t\telse \n\t\t\t\t\t\t    continue;\n\t\t\t\t\t    }\n\t\t\t\t\telse\n\t\t\t\t\t    {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t    }\n\t\t\t\t    }\n\n\t\t\t    }\n\n\t\t\t//System.out.println(\"3 PASSED! \" + M_list.get(i).extraterrestrial);\n\n\n\t\t\tif(ok && ok2)\n\t\t\t    {\n\n\t\t\t\t//System.out.println(\"OK P2 : \" + M_list.get(i).extraterrestrial);\n\t\t\t\tcnt+=2;\n\t\t\t\tfinish = false;\n\t\t\t\tused[M_list.get(i).extraterrestrial-'A'] = true;\n\t\t\t    }\n\n\n\t\t    }\n\n\n\t    }\n\n\tSystem.out.println(cnt);\n\t\n    }\n\n\n\t\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static final int MAX = 500;\n\n\tpublic static boolean is_ok(int x, int y, int w, int h) {\n\t\tif (x < 0 || x >= w || y < 0 || y >= h) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tboolean[] places = new boolean[26];\n\t\tint[][] x_pos = new int[26][2];\n\t\tint[][] y_pos = new int[26][2];\n\n\t\tfinal int M = sc.nextInt();\n\t\tfinal int N = sc.nextInt();\n\n\t\tboolean[][] is_placed = new boolean[M][N];\n\t\t\n\t\tArrays.fill(places, false);\n\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tchar[] input = sc.next().toCharArray();\n\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tif ('A' <= input[j] && input[j] <= 'Z') {\n\t\t\t\t\tis_placed[i][j] = true;\n\n\t\t\t\t\tint count = places[input[j] - 'A'] ? 1 : 0;\n\t\t\t\t\tplaces[input[j] - 'A'] = true;\n\t\t\t\t\tx_pos[input[j] - 'A'][count] = j;\n\t\t\t\t\ty_pos[input[j] - 'A'][count] = i;\n\t\t\t\t} else {\n\t\t\t\t\tis_placed[i][j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint score = 0;\n\t\twhile (true) {\n\t\t\tboolean updated = false;\n\n\t\t\tfor (int mozi = 0; mozi < 26; mozi++) {\n\t\t\t\tif (!places[mozi]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint fst_min_x = x_pos[mozi][0];\n\t\t\t\tint fst_max_x = x_pos[mozi][0];\n\t\t\t\tint fst_min_y = y_pos[mozi][0];\n\t\t\t\tint fst_max_y = y_pos[mozi][0];\n\t\t\t\tint snd_min_x = x_pos[mozi][1];\n\t\t\t\tint snd_max_x = x_pos[mozi][1];\n\t\t\t\tint snd_min_y = y_pos[mozi][1];\n\t\t\t\tint snd_max_y = y_pos[mozi][1];\n\n\t\t\t\tfor (int x = x_pos[mozi][0] - 1;; x--) {\n\t\t\t\t\tif (!is_ok(x, y_pos[mozi][0], N, M)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (is_placed[y_pos[mozi][0]][x]) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tfst_min_x = x;\n\t\t\t\t}\n\t\t\t\tfor (int x = x_pos[mozi][0] + 1;; x++) {\n\t\t\t\t\tif (!is_ok(x, y_pos[mozi][0], N, M)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (is_placed[y_pos[mozi][0]][x]) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tfst_max_x = x;\n\t\t\t\t}\n\t\t\t\tfor (int y = y_pos[mozi][0] - 1;; y--) {\n\t\t\t\t\tif (!is_ok(x_pos[mozi][0], y, N, M)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (is_placed[y][x_pos[mozi][0]]) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tfst_min_y = y;\n\t\t\t\t}\n\t\t\t\tfor (int y = y_pos[mozi][0] + 1;; y++) {\n\t\t\t\t\tif (!is_ok(x_pos[mozi][0], y, N, M)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (is_placed[y][x_pos[mozi][0]]) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tfst_max_y = y;\n\t\t\t\t}\n\n\t\t\t\tfor (int x = x_pos[mozi][1] - 1;; x--) {\n\t\t\t\t\tif (!is_ok(x, y_pos[mozi][1], N, M)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (is_placed[y_pos[mozi][1]][x]) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tsnd_min_x = x;\n\t\t\t\t}\n\t\t\t\tfor (int x = x_pos[mozi][1] + 1;; x++) {\n\t\t\t\t\tif (!is_ok(x, y_pos[mozi][1], N, M)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (is_placed[y_pos[mozi][1]][x]) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tsnd_max_x = x;\n\t\t\t\t}\n\t\t\t\tfor (int y = y_pos[mozi][1] - 1;; y--) {\n\t\t\t\t\tif (!is_ok(x_pos[mozi][1], y, N, M)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (is_placed[y][x_pos[mozi][1]]) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tsnd_min_y = y;\n\t\t\t\t}\n\t\t\t\tfor (int y = y_pos[mozi][1] + 1;; y++) {\n\t\t\t\t\tif (!is_ok(x_pos[mozi][1], y, N, M)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (is_placed[y][x_pos[mozi][1]]) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tsnd_max_y = y;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//System.out.println((char)(mozi + 'A') + \"  \" + x_pos[mozi][0] + \" \" + y_pos[mozi][0] + \" \" + x_pos[mozi][1] + \" \" + y_pos[mozi][1]);\n\t\t\t\t//System.out.println((char)(mozi + 'A') + \"1 \" + fst_min_x + \" \" + fst_max_x + \" \"+ fst_min_y + \" \" + fst_max_y);\n\t\t\t\t//System.out.println((char)(mozi + 'A') + \"2 \" + snd_min_x + \" \" + snd_max_x + \" \"+ snd_min_y + \" \" + snd_max_y);\n\t\t\t\t\n\t\t\t\tboolean flag = false;\n\t\t\t\tflag |= (fst_max_y >= y_pos[mozi][1]\n\t\t\t\t\t\t&& x_pos[mozi][0] <= x_pos[mozi][1] && x_pos[mozi][0] >= snd_min_x);\n\t\t\t\tflag |= (fst_max_y >= y_pos[mozi][1]\n\t\t\t\t\t\t&& x_pos[mozi][0] >= x_pos[mozi][1] && x_pos[mozi][0] <= snd_max_x);\n\n\t\t\t\tflag |= (snd_min_y <= y_pos[mozi][0]\n\t\t\t\t\t\t&& x_pos[mozi][0] <= x_pos[mozi][1] && x_pos[mozi][1] <= fst_max_x);\n\t\t\t\tflag |= (snd_min_y <= y_pos[mozi][0]\n\t\t\t\t\t\t&& x_pos[mozi][0] >= x_pos[mozi][1] && x_pos[mozi][1] >= fst_min_x);\n\t\t\t\tflag |= (x_pos[mozi][0] == x_pos[mozi][1] && fst_max_y >= snd_min_y);\n\t\t\t\tflag |= (y_pos[mozi][0] == y_pos[mozi][1] && x_pos[mozi][0] <= x_pos[mozi][1] && fst_max_x >= snd_min_x);\n\t\t\t\tflag |= (y_pos[mozi][0] == y_pos[mozi][1] && x_pos[mozi][0] >= x_pos[mozi][1] && fst_min_x <= snd_max_x);\n\n\t\t\t\tif (flag) {\n\t\t\t\t\tscore += 2;\n\t\t\t\t\tis_placed[y_pos[mozi][0]][x_pos[mozi][0]] = false;\n\t\t\t\t\tis_placed[y_pos[mozi][1]][x_pos[mozi][1]] = false;\n\n\t\t\t\t\tplaces[mozi] = false;\n\n\t\t\t\t\tupdated = true;\n\t\t\t\t\t//System.out.println(\"erase \" + (char)(mozi + 'A'));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!updated) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(score);\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Deque;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\tnew Main().run();\n\t}\n\t\n\tScanner scanner = new Scanner(System.in);\n\tint m;\n\tint[][][] tile = new int[26][2][2];\n\tDeque<Integer> que = new ArrayDeque<Integer>();\n\tboolean[] cantGet =new boolean[26];\n\tboolean[] check =new boolean[26];\n\tint score = 0;\n\t\n\tvoid run() {\n\t\t\n\t\tm = scanner.nextInt();\n\t\tscanner.nextInt();\n\t\t\n\t\tfor (int color = 0; color < tile.length; color ++) {\n\t\t\t\n\t\t\ttile[color][0][0] = -1;\n\t\t\tcantGet[color] = false;\n\t\t\tcheck[color] = false;\n\t\t}\n\t\t\n\t\tfor (int y = 0; y < m; y ++) {\n\t\t\t\n\t\t\tchar[] line = scanner.next().toCharArray();\n\t\t\t\n\t\t\tfor (int x = 0; x < line.length; x ++) {\n\t\t\t\t\n\t\t\t\tif(line[x] != '.') {\n\t\t\t\t\t\n\t\t\t\t\tint color = line[x] - 'A';\n\t\t\t\t\tint index = (tile[color][0][0] == -1) ? 0: 1;\n\t\t\t\t\ttile[color][index][0] = x;\n\t\t\t\t\ttile[color][index][1] = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int color = 0; color < tile.length; color ++) {\n\t\t\t\n\t\t\tif (tile[color][0][0] != -1\n\t\t\t\t\t&& ! tryGet(color) && ! que.isEmpty()) {\n\t\t\t\t\n\t\t\t\tbfs();\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(score * 2);\n\t}\n\t\n\tCollection<Integer> old = new ArrayList<Integer>(que);\n\t\n\tvoid bfs() {\n\t\t\n\t\tdo {\n\t\t\t\n\t\t\told.clear();\n\t\t\told.addAll(que);\n\t\t\tint color;\n\t\t\tint last = que.getLast();\n\t\t\tdo {\n\t\t\t\t\n\t\t\t\tcolor = que.remove();\n\t\t\t\ttryGet(color);\n\t\t\t\t\n\t\t\t} while (color != last);\n\t\t\t\n\t\t} while (! que.isEmpty() && ! old.containsAll(que));\n\t}\n\t\n\tboolean tryGet(int color) {\n\t\t\n\t\tif (cantGet[color]) {\n\t\t\t\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (! check[color]) {\n\t\t\t\n\t\t\tcheck[color] = true;\n\t\t\tif ((tile[color][0][0] == tile[color][1][0]\n\t\t\t\t\t&& Math.abs(tile[color][0][1] - tile[color][1][1]) == 1)\n\t\t\t\t\t|| (tile[color][0][1] == tile[color][1][1]\n\t\t\t\t\t&& Math.abs(tile[color][0][0] - tile[color][1][0]) == 1)) {\n\t\t\t\t\n\t\t\t\tcantGet[color] = true;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif((isEmpty(color, 1, tile[color][0][0], tile[color][0][1], tile[color][1][1])\n\t\t\t\t\t&& isEmpty(color, 0, tile[color][1][1], tile[color][0][0], tile[color][1][0]))\n\t\t\t\t|| (isEmpty(color, 1, tile[color][1][0], tile[color][0][1], tile[color][1][1])\n\t\t\t\t\t&& isEmpty(color, 0, tile[color][0][1], tile[color][0][0], tile[color][1][0]))) {\n\t\t\t\n\t\t\ttile[color][0][0] = -1;\n\t\t\tscore ++;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tque.add(color);\n\t\treturn false;\n\t}\n\t\n\tboolean isEmpty(int skip,int axis, int point, int start, int end) {\n\t\t\n\t\tif (start == end) {\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tif (start > end) {\n\t\t\t\n\t\t\tint swap = start;\n\t\t\tstart = end;\n\t\t\tend = swap;\n\t\t}\n\t\t\n\t\tboolean isEmpty = true;\n\t\tfor (int color = 0; color < tile.length; color ++) {\n\t\t\t\n\t\t\tif (color == skip\n\t\t\t\t\t|| tile[color][0][0] == -1) {\n\t\t\t\t\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int index = 0; index < tile[0].length; index ++) {\n\t\t\t\t\n\t\t\t\tif (tile[color][index][1 - axis] == point\n\t\t\t\t\t\t&& tile[color][index][axis] >= start\n\t\t\t\t\t\t&& tile[color][index][axis] <= end) {\n\t\t\t\t\t\n\t\t\t\t\tisEmpty = false;\n\t\t\t\t\tif (! que.contains(color)\n\t\t\t\t\t\t\t&& ! cantGet[color]) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tque.add(color);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn isEmpty;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic char[][] f;;\n\n\tpublic static void main(String[] arg) {\n\t\tint M = sc.nextInt();\n\t\tint N = sc.nextInt();\n\t\tf = new char[M][N];\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tf[i] = sc.next().toCharArray();\n\t\t}\n\t\tint[][] r = new int[26][2];\n\t\tint[][] c = new int[26][2];\n\t\tfor (int i = 0; i < 26; ++i) {\n\t\t\tr[i][0] = r[i][1] = c[i][0] = c[i][1] = -1;\n\t\t}\n\t\tboolean[] used = new boolean[26];\n\t\tArrays.fill(used, true);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tif (f[i][j] == '.') continue;\n\t\t\t\tint ch = f[i][j] - 'A';\n\t\t\t\tused[ch] = false;\n\t\t\t\tif (r[ch][0] >= 0) {\n\t\t\t\t\tr[ch][1] = i;\n\t\t\t\t\tc[ch][1] = j;\n\t\t\t\t} else {\n\t\t\t\t\tr[ch][0] = i;\n\t\t\t\t\tc[ch][0] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < 26; ++i) {\n\t\t\tfor (int j = 0; j < 26; ++j) {\n\t\t\t\tif (used[j]) continue;\n\t\t\t\tif (remove(r[j][0], c[j][0], r[j][1], c[j][1])) {\n\t\t\t\t\tans += 2;\n\t\t\t\t\tused[j] = true;\n\t\t\t\t\tf[r[j][0]][c[j][0]] = '.';\n\t\t\t\t\tf[r[j][1]][c[j][1]] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\tstatic boolean remove(int r1, int c1, int r2, int c2) {\n\t\tif (r1 == r2) {\n\t\t\tif (Math.abs(c1 - c2) <= 1) return false;\n\t\t\tfor (int i = Math.min(c1, c2) + 1; i < Math.max(c1, c2); ++i) {\n\t\t\t\tif (f[r1][i] != '.') return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t} else if (c1 == c2) {\n\t\t\tif (Math.abs(r1 - r2) <= 1) return false;\n\t\t\tfor (int i = Math.min(r1, r2) + 1; i < Math.max(r1, r2); ++i) {\n\t\t\t\tif (f[i][c1] != '.') return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\tif (r1 > r2) {\n\t\t\t\tint tmp = r1;\n\t\t\t\tr1 = r2;\n\t\t\t\tr2 = tmp;\n\t\t\t\ttmp = c1;\n\t\t\t\tc1 = c2;\n\t\t\t\tc2 = tmp;\n\t\t\t}\n\t\t\t{\n\t\t\t\tboolean ok = true;\n\t\t\t\tfor (int i = r1 + 1; i <= r2; ++i) {\n\t\t\t\t\tif (f[i][c1] != '.') {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint move = c1 < c2 ? 1 : -1;\n\t\t\t\tfor (int i = c1; i != c2; i += move) {\n\t\t\t\t\tif (f[r2][i] != '.') {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok) return true;\n\t\t\t}\n\t\t\t{\n\t\t\t\tboolean ok = true;\n\t\t\t\tfor (int i = r2 - 1; i >= r1; --i) {\n\t\t\t\t\tif (f[i][c2] != '.') {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint move = c1 < c2 ? -1 : 1;\n\t\t\t\tfor (int i = c2; i != c1; i += move) {\n\t\t\t\t\tif (f[r1][i] != '.') {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok) return true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tchar [][] data;\n\tint w,h;\n\tint [] vx = {0,1,0,-1};\n\tint [] vy = {1,0,-1,0};\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\tdata = new char[h][w];\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tdata[i] = sc.next().toCharArray();\n\t\t\t}\n\t\t\tint sum = 0;\n\t\t\tfor(int k = 0; k < 26; k++){\n\t\t\t\tint prev = sum;\n\t\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\t\tif(data[i][j] == '.'){\n\t\t\t\t\t\t\tsum += erase(i,j);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(prev == sum){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n\n\tprivate int erase(int y, int x) {\n\t\tchar [] panel = new char[4];\n\t\tArrays.fill(panel, '*');\n\t\tint [][] pos = new int[4][2];\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tint xx = x + vx[i];\n\t\t\tint yy = y + vy[i];\n\t\t\twhile(true){\n\t\t\t\tif(! isOK(xx,yy)) break;\n\t\t\t\tif(data[yy][xx] != '.'){\n\t\t\t\t\tpanel[i] = data[yy][xx];\n\t\t\t\t\tpos[i][0] = xx;\n\t\t\t\t\tpos[i][1] = yy;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\txx = xx + vx[i];\n\t\t\t\tyy = yy + vy[i];\n\t\t\t}\n\t\t}\n\t\tint count = 0;\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tif(panel[i] == '*') continue;\n\t\t\tfor(int j = i + 1; j < 4; j++){\n\t\t\t\tif(i == j) continue;\n\t\t\t\t\n\t\t\t\tif(panel[i] == panel[j]){\n\t\t\t\t\tdata[pos[i][1]][pos[i][0]] = '.';\n\t\t\t\t\tdata[pos[j][1]][pos[j][0]] = '.';\n\t\t\t\t\tcount+= 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\n\tprivate boolean isOK(int xx, int yy) {\n\t\tif(0 <= xx && xx < w && 0 <= yy && yy < h){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate void debug(Object... o) {\n\t\tSystem.out.println(\"debug = \" + Arrays.deepToString(o));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\nimport java.awt.Point;\n\nclass Main{\n\n    private static final int[] dx = {0,1,0,-1};\n    private static final int[] dy = {1,0,-1,0};\n\n    static class Pox\n    {\n\tpublic int x,y;\n\tpublic char extraterrestrial;\n\n\tPox()\n\t{\n\t    x = y = -1;\n\t    extraterrestrial = 'a';\n\t}\n\n\tPox(char c,int a,int b)\n\t{\n\t    x = a;\n\t    y = b;\n\t    extraterrestrial = c;\n\t}\n\n    }\n\n       \n\n    static class PP\n    {\n\tPoint p1,p2;\n\n\tPP()\n\t{\n\t    p1 = new Point(-1,-1);\n\t    p2 = new Point(-1,-1);\n\t}\n\n\tPP(Point a,Point b)\n\t{\n\t    p1 = a;\n\t    p2 = b;\n\t}\n\n    }\n\n\n      public static void main(String args[])throws IOException\n    {\n\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tint M,N;\n\n\tString line;\n\twhile((line = in.readLine()) != null)\n\t    {\n\n\t\n\tM = Integer.parseInt(line.substring(0,line.indexOf(\" \")));\n\tN = Integer.parseInt(line.substring(line.indexOf(\" \") + 1));\n\n\tLinkedList<Pox> list = new LinkedList<Pox>();//アルファベットの座標\n\tLinkedList<Pox> M_list = new LinkedList<Pox>();//中継地点\n\tHashMap<Character,PP> map = new HashMap<Character,PP>();\n\tchar[][] cmap = new char[M][N];\n\n\n\tfor(int i=0;i<M;i++)\n\t    {\n\t\tline = in.readLine();\n\t\tfor(int j=0;j<N;j++)\n\t\t    {\n\n\t\t\tcmap[i][j] = line.charAt(j);\t\t\n\n\t\t\tif(line.charAt(j) != '.')\n\t\t\t    {\n\t\t\t\tlist.add(new Pox(line.charAt(j),j,i));\n\t\t\t\tif(!map.containsKey(line.charAt(j)))\n\t\t\t\t    {\n\t\t\t\t\tmap.put(line.charAt(j),new PP(new Point(j,i),new Point(-1,-1)));\n\t\t\t\t    }\n\t\t\t\telse\n\t\t\t\t    {\n\t\t\t\t\tint x,y,xx,yy;\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t\txx = map.get(line.charAt(j)).p1.x;\n\t\t\t\t\tyy = map.get(line.charAt(j)).p1.y;\n\t\t\t\t\tmap.put(line.charAt(j),new PP(new Point(xx,yy),new Point(j,i)));\n\n\t\t\t\t\tif(!(x == xx || y == yy))\n\t\t\t\t\t    {\n\t\t\t\t\t\tM_list.add(new Pox(line.charAt(j),x,yy));\n\t\t\t\t\t\tM_list.add(new Pox(line.charAt(j),xx,y));\n\t\t\t\t\t    }\n\t\t\t\t    }\n\t\t\t    } \n\t\t    }\n\t    }\n\n\t/*\n\tfor(int i=0;i<M_list.size();i++)\n\t    {\n\t\tSystem.out.println(\"debug : \" + M_list.get(i).extraterrestrial);\n\t    }\n\t*/\n\n\tboolean[] used = new boolean[28];\t\n\tfor(int i=0;i<28;i++)\n\t    {\n\t\tused[i] = false;\n\t    }\n\n\tboolean finish = false;\n\tint cnt = 0;\n\twhile(!finish)\n\t    {\n\t\tfinish = true;\n\n\t\tfor(int i=0;i<list.size();i++)\n\t\t    {\n\t\t\tif(used[list.get(i).extraterrestrial - 'A'])\n\t\t\t    continue;\n\n\t\t\tint x,y,xx,yy;\n\t\t\tchar c = list.get(i).extraterrestrial;\n\t\t\tx = map.get(c).p1.x;\n\t\t\ty = map.get(c).p1.y;\n\t\t\txx = map.get(c).p2.x;\n\t\t\tyy = map.get(c).p2.y;\n\n\t\t\tint hx,hxx;\n\t\t\tint hy,hyy;\n\n\t\t\thx = Math.min(x,xx);\n\t\t\thxx = Math.max(x,xx);\n\n\t\t\thy = Math.min(y,yy);\n\t\t\thyy = Math.max(y,yy);\n\n\t\t\tif(!(x == xx || y == yy))\n\t\t\t    continue;\n\n\t\t\tboolean ok = true;\n\t\t\tfor(int j=0;j<list.size();j++)\n\t\t\t    {\n\t\t\t\tif(list.get(j).extraterrestrial == c)\n\t\t\t\t    continue;\n\n\t\t\t\tif(used[list.get(j).extraterrestrial-'A'])\n\t\t\t\t    continue;\n\n\t\t\t\tint list_x,list_y;\n\t\t\t\tlist_x = list.get(j).x;\n\t\t\t\tlist_y = list.get(j).y;\n\n\t\t\t\tif(x == xx)\n\t\t\t\t    {\n\t\t\t\t\tif(x == list_x)\n\t\t\t\t\t    {\n\t\t\t\t\t\tif(hy < list_y && list_y < hyy)\n\t\t\t\t\t\t    {\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t    }\n\t\t\t\t\t\telse\n\t\t\t\t\t\t    {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t    }\n\t\t\t\t\t    }\n\t\t\t\t\telse\n\t\t\t\t\t    {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t    }\n\t\t\t\t    }\n\t\t\t\telse if(y == yy)\n\t\t\t\t    {\n\t\t\t\t\tif(y == list_y)\n\t\t\t\t\t    {\n\t\t\t\t\t\tif(hx < list_x && list_x < hxx)\n\t\t\t\t\t\t    {\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t    }\n\t\t\t\t\t\telse\n\t\t\t\t\t\t    {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t    }\n\t\t\t\t\t    }\n\t\t\t\t\telse\n\t\t\t\t\t    {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t    }\n\n\t\t\t\t    }\n\t\t\t\t\n\n\t\t\t    }\n\n\t\t\tif(ok)\n\t\t\t    {\n\n\t\t\t\tint xp,yp;\n\t\t\t\txp = list.get(i).x;\n\t\t\t\typ = list.get(i).y;\n\t\t\t\tfor(int j=0;j<4;j++)\n\t\t\t\t    {\n\t\t\t\t\tint nx = xp + dx[j],ny = yp + dy[j];\n\t\t\t\t\tif(!(0<= nx && nx <N && 0<= ny && ny <M ))\n\t\t\t\t\t    continue;\n\n\t\t\t\t\tif(cmap[ny][nx] == list.get(i).extraterrestrial)\n\t\t\t\t\t    {\n\t\t\t\t\t\tused[list.get(i).extraterrestrial-'A'] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t    }\n\t\t\t\t    }\n\n\t\t\t\tif(used[list.get(i).extraterrestrial-'A'])\n\t\t\t\t    continue;\n\n\t\t\t\t//System.out.println(\"OK: \" + list.get(i).extraterrestrial);\n\t\t\t\tcnt += 2;\n\t\t\t\tused[list.get(i).extraterrestrial-'A'] = true;\n\t\t\t\tfinish = false;\n\t\t\t    }\n\n\t\t    }\n\n\n\n\t\tfor(int i=0; i<M_list.size();i++)\n\t\t    {\n\t\t\tif(used[M_list.get(i).extraterrestrial-'A'])\n\t\t\t    continue;\n\n\t\t\t//System.out.println(\"GO! -> \" + M_list.get(i).extraterrestrial);\n\n\t\t\tint mx,my,x1,y1,x2,y2;\n\n\t\t\tmx = M_list.get(i).x;\n\t\t\tmy = M_list.get(i).y;\n\n\t\t\t//System.out.println(\"the coordinates : \" + mx + \",\" + my );\n\t\t\t\n\t\t\tif(cmap[my][mx] != '.')\n\t\t\t    {\n\t\t\t\tif(!used[cmap[my][mx]-'A'])\n\t\t\t\t    {\n\t\t\t\t\tcontinue;\n\t\t\t\t    }\n\t\t\t    }\n\n\t\t\n\t\t\tPoint pp = map.get(M_list.get(i).extraterrestrial).p1;\n\t\t\tPoint ppp = map.get(M_list.get(i).extraterrestrial).p2;\n\n\t\t\tx1 = pp.x;\n\t\t\ty1 = pp.y;\n\n\t\t\tx2 = ppp.x;\n\t\t\ty2 = ppp.y;\n\n\n\t\t\tint hx,hy,hxx,hyy;\n\n\t\t\thx = Math.min(mx,x1);\n\t\t\thxx = Math.max(mx,x1);\n\t\t\thy = Math.min(my,y1);\t\t\t\n\t\t\thyy = Math.max(my,y1);\n\n\n\t\t\n\t\t      \n\n\t\t\tboolean ok = true;\n\t\t\tfor(int j=0;j<list.size();j++)\n\t\t\t    {\t\t\t\t    \n\n\n\t\t\t\tif(used[list.get(j).extraterrestrial-'A'])\n\t\t\t\t    {\n\t\t\t\t\tcontinue;\n\t\t\t\t    }\n\n\t\t\t\tif(list.get(j).extraterrestrial == M_list.get(i).extraterrestrial)\n\t\t\t\t    {\n\t\t\t\t\tcontinue;\n\t\t\t\t    }\n\n\t\t\t\tint lx,ly;\n\t\t\t\tlx = list.get(j).x;\n\t\t\t\tly = list.get(j).y;\n\n\t\t\n\t\t    \n\t\t\t\n\n\n\t\t\t\tif(mx == x1)\n\t\t\t\t    {\n\t\t\t\t\tif(mx != lx)\n\t\t\t\t\t    continue;\n\n\t\t\t\t\tif(hy < ly && ly < hyy)\n\t\t\t\t\t    {\n\t\t\t\t\t\tif(!used[cmap[ly][lx]-'A'])\n\t\t\t\t\t\t    {\n\t\t\t\t\t\t\t//System.out.println(\"MISS! p3 \" + M_list.get(i).extraterrestrial);\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t    }\n\t\t\t\t\t    }\n\t\t\t\t\telse\n\t\t\t\t\t    {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t    }\n\t\t\t\t    }\n\t\t\t\telse if(my == y1)\n\t\t\t\t    {\n\t\t\t\t\tif(my != ly)\n\t\t\t\t\t    continue;\n\t\t\t\t\tif(hx < lx && lx < hxx)\n\t\t\t\t\t    {\n\t\t\t\t\t\tif(!used[cmap[ly][lx]-'A'])\n\t\t\t\t\t\t    {    \n\t\t\t\t\t\t\t//System.out.println(\"MISS! p4 \" + M_list.get(i).extraterrestrial );\n\t\t\t\t\t\t\t//System.out.println(\"p4 : \" + cmap[ly][lx] + \" : \" + lx + \",\" + ly);\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t    }\n\t\t\t\t\t    }\n\t\t\t\t\telse\n\t\t\t\t\t    {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t    }\n\t\t\t\t    }\n\n\t\t\t    }\n\n\t\t\tif(!ok)\n\t\t\t    {\n\t\t\t\tcontinue;\n\t\t\t    }\n\n\t\t\t//System.out.println(\"2 PASSED! \" + M_list.get(i).extraterrestrial);\n\n\n\t\t\tboolean ok2 = true;\n\t\t\thx = Math.min(mx,x2);\n\t\t\thxx = Math.max(mx,x2);\n\t\t\thy = Math.min(my,y2);\n\t\t\thyy = Math.max(my,y2);\n\n\t\t\tfor(int j=0;j<list.size();j++)\n\t\t\t    {\n\t\t\t\tif(used[list.get(j).extraterrestrial-'A'])\n\t\t\t\t    continue;\n\n\t\t\t\tif(list.get(j).extraterrestrial == M_list.get(i).extraterrestrial)\n\t\t\t\t    continue;\n\n\t\t\t\tint lx,ly;\n\t\t\t\tlx = list.get(j).x;\n\t\t\t\tly = list.get(j).y;\n\n\t\t\t\tif(cmap[ly][lx] != '.')\n\t\t\t\t    {\n\t\t\t\t\tif(!used[cmap[ly][lx]-'A'])\n\t\t\t\t\t    {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t    }\n\t\t\t\t    }\n\n\n\t\t\t\tif(mx == x2)\n\t\t\t\t    {\n\t\t\t\t\tif(mx != lx)\n\t\t\t\t\t    continue;\n\t\t\t\t\t\n\t\t\t\t\tif(hy < ly && ly < hyy)\n\t\t\t\t\t    {\n\t\t\t\t\t\tif(!used[cmap[ly][lx]-'A'])\n\t\t\t\t\t\t    {\n\t\t\t\t\t\t\tok2 = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t    }\n\t\t\t\t\t\telse\n\t\t\t\t\t\t    continue;\n\t\t\t\t\t    }\n\t\t\t\t\telse\n\t\t\t\t\t    {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t    }\n\t\t\t\t    }\n\t\t\t\telse if(my == y2)\n\t\t\t\t    {\n\t\t\t\t\tif(my != ly)\n\t\t\t\t\t    continue;\n\n\t\t\t\t\tif(hx < lx && lx < hxx)\n\t\t\t\t\t    {\n\t\t\t\t\t\tif(!used[cmap[ly][lx]-'A'])\n\t\t\t\t\t\t    {\n\t\t\t\t\t\t\tok2 = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t    }\n\t\t\t\t\t\telse \n\t\t\t\t\t\t    continue;\n\t\t\t\t\t    }\n\t\t\t\t\telse\n\t\t\t\t\t    {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t    }\n\t\t\t\t    }\n\n\t\t\t    }\n\n\t\t\t//System.out.println(\"3 PASSED! \" + M_list.get(i).extraterrestrial);\n\n\n\t\t\tif(ok && ok2)\n\t\t\t    {\n\n\t\t\t\t//System.out.println(\"OK: \" + M_list.get(i).extraterrestrial);\n\t\t\t\tcnt+=2;\n\t\t\t\tfinish = false;\n\t\t\t\tused[M_list.get(i).extraterrestrial-'A'] = true;\n\t\t\t    }\n\n\n\t\t    }\n\n\n\t    }\n\n\tSystem.out.println(cnt);\n\t\n    }\n\n\n\t\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\tprivate static final int[][] dir = { { 0, 1 }, { 0, -1 }, { 1, 0 }, { -1, 0 } };\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint M = sc.nextInt();\n\t\tint N = sc.nextInt();\n\t\tchar[][] map = new char[M][];\n\t\tfor (int i = 0; i < map.length; i++) {\n\t\t\tmap[i] = sc.next().toCharArray();\n\t\t}\n\t\tsc.close();\n\n\t\tint point = 0;\n\t\twhile (true) {\n\t\t\tint begin = point;\n\t\t\tfor (int i = 0; i < map.length; i++) {\n\t\t\t\tfor (int j = 0; j < map[i].length; j++) {\n\t\t\t\t\tif (map[i][j] != '.') {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tPriorityQueue<Tile> tiles = new PriorityQueue<Tile>();\n\n\t\t\t\t\tfor (int k = 0; k < dir.length; k++) {\n\t\t\t\t\t\tint l = 1;\n\t\t\t\t\t\tint ti = i + dir[k][0] * l;\n\t\t\t\t\t\tint tj = j + dir[k][1] * l;\n\t\t\t\t\t\twhile (ti >= 0 && ti < M && tj >= 0 && tj < N) {\n\t\t\t\t\t\t\tif (map[ti][tj] != '.') {\n\t\t\t\t\t\t\t\tchar c = map[ti][tj];\n\t\t\t\t\t\t\t\ttiles.add(new Tile(ti, tj, c));\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tl++;\n\t\t\t\t\t\t\tti = i + dir[k][0] * l;\n\t\t\t\t\t\t\ttj = j + dir[k][1] * l;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\twhile (tiles.size() > 1) {\n\t\t\t\t\t\tTile t1 = tiles.poll();\n\t\t\t\t\t\tTile t2 = tiles.poll();\n\t\t\t\t\t\tif (t1.color != t2.color) {\n\t\t\t\t\t\t\ttiles.add(t2);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmap[t1.i][t1.j] = '.';\n\t\t\t\t\t\tmap[t2.i][t2.j] = '.';\n\t\t\t\t\t\tpoint++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (point == begin) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(point * 2);\n\n\t}\n}\n\nclass Tile implements Comparable<Tile> {\n\tint i, j;\n\tchar color;\n\n\tpublic Tile(int i, int j, char color) {\n\t\tthis.i = i;\n\t\tthis.j = j;\n\t\tthis.color = color;\n\t}\n\n\tpublic int compareTo(Tile o) {\n\t\treturn this.color - o.color;\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class P\n{\n    public int x { get; set; }\n    public int y { get; set; }\n}\n\npublic class hello\n{\n    public static int h, w;\n    public static void Main()\n    {\n        string[] line = Console.ReadLine().Trim().Split(' ');\n        h = int.Parse(line[0]);\n        w = int.Parse(line[1]);\n        var map = new int[h, w];\n        var ps = new List<P>[26];\n        for (int i = 0; i < 26; i++) ps[i] = new List<P>();\n        for (int i = 0; i < h; i++)\n        {\n            var s = Console.ReadLine().Trim();\n            for (int j = 0; j < w; j++)\n            {\n                if (s[j] == '.') map[i, j] = -1;\n                else\n                {\n                    var t = s[j] - 'A';\n                    map[i, j] = t;\n                    ps[t].Add(new P { x = i, y = j });\n                }\n            }\n        }\n        var d0 = new List<int>[26];\n        var d1 = new List<int>[26];\n        for (int i = 0; i < 26; i++)\n        {\n            d0[i] = new List<int>();\n            d1[i] = new List<int>();\n        }\n        var root1 = new bool[26];\n        makeList(map, ps, d0, d1, root1);\n        getAns(ps, d0, d1, root1);\n    }\n    static void getAns(List<P>[] ps, List<int>[] d0, List<int>[] d1, bool[] root1)\n    {\n        var res = 0;\n        var fin = new bool[26];\n        while (true)\n        {\n            var rf = false;\n            for (int i = 0; i < 26; i++)\n            {\n                if (ps[i].Count() == 2 && !fin[i])\n                {\n                    if ((root1[i] && d0[i].Count() == 0) |\n                            (!root1[i]) && (d0[i].Count() == 0 | d1[i].Count() == 0))\n                    {\n                        res += 2;\n                        rf = true;\n                        fin[i] = true;\n                        for (int j = 0; j < 26; j++)\n                        {\n                            d0[j].Remove(i);\n                            if (!root1[j]) d1[j].Remove(i);\n                        }\n                    }\n                }\n            }\n            if (!rf) break;\n        }\n        Console.WriteLine(res);\n    }\n    static void makeList(int[,] map, List<P>[] ps, List<int>[] d0, List<int>[] d1, bool[] root1)\n    {\n        for (int i = 0; i < 26; i++)\n        {\n            if (ps[i].Count() == 2)\n            {\n                var x0 = ps[i][0].x;\n                var y0 = ps[i][0].y;\n                var x1 = ps[i][1].x;\n                var y1 = ps[i][1].y;\n\n                if (x0 == x1)\n                {\n                    root1[i] = true;\n                    if (y1 - y0 == 1) d0[i].Add(30);\n                    else\n                    {\n                        for (int j = y0 + 1; j < y1; j++)\n                        {\n                            var te = map[x0, j];\n                            if (te >= 0) d0[i].Add(te);\n                        }\n                    }\n                }\n                else if (y0 == y1)\n                {\n                    root1[i] = true;\n                    if (x1 - x0 == 1) d0[i].Add(30);\n                    else\n                    {\n                        for (int j = x0 + 1; j < x1; j++)\n                        {\n                            var te = map[j, y0];\n                            if (te >= 0) d0[i].Add(te);\n                        }\n                    }\n                }\n                else\n                {\n                    if (y1 > y0)\n                    {\n                        for (int j = y0 + 1; j <= y1; j++)\n                        {\n                            var te = map[x0, j];\n                            if (te >= 0) d0[i].Add(te);\n                        }\n                        for (int j = x0 + 1; j < x1; j++)\n                        {\n                            var te = map[j, y1];\n                            if (te >= 0) d0[i].Add(te);\n                        }\n                        for (int j = x0 + 1; j <= x1; j++)\n                        {\n                            var te = map[j, y0];\n                            if (te >= 0) d1[i].Add(te);\n                        }\n                        for (int j = y0 + 1; j < y1; j++)\n                        {\n                            var te = map[x1, j];\n                            if (te >= 0) d1[i].Add(te);\n                        }\n                    }\n                    else\n                    {\n                        for (int j = y1; j < y0; j++)\n                        {\n                            var te = map[x0, j];\n                            if (te >= 0) d0[i].Add(te);\n                        }\n                        for (int j = x0 + 1; j < x1; j++)\n                        {\n                            var te = map[j, y1];\n                            if (te >= 0) d0[i].Add(te);\n                        }\n                        for (int j = y1 + 1; j <= y0; j++)\n                        {\n                            var te = map[x1, j];\n                            if (te >= 0) d1[i].Add(te);\n                        }\n                        for (int j = x0 + 1; j < x1; j++)\n                        {\n                            var te = map[j, y0];\n                            if (te >= 0) d1[i].Add(te);\n                        }\n                    }\n                }\n            }\n        }\n        for (int i = 0; i < 26; i++)\n        {\n            d0[i] = d0[i].Distinct().ToList();\n            if (!root1[i]) d1[i] = d1[i].Distinct().ToList();\n        }\n    }\n}\n\n"
  },
  {
    "language": "JavaScript",
    "code": "function syukusyou(yx){\n   var cnt=0;\n   yx=yx.filter(v=>{\n      var flag = v.every(val=> val==\".\");\n      if(!flag){\n         cnt=0;\n         return true;\n      }else if(flag && cnt==0){\n         cnt++;\n         return true;\n      }else {\n         return false;\n      }\n   });\n   return yx;\n}\n\nfunction kaiten(yx){\n   return  yx[0].map((a, i) => yx.map(b => b[i]));\n}\n\nfunction saikiY(y,x,d){\n   if(yx[y][x] != \".\")return yx[y][x];\n   else if(y+d!=-1 && y+d!=h)return saikiY(y+d,x,d);\n   else return \".\";\n}\n\nfunction saikiX(y,x,d){\n   if(yx[y][x]!=\".\")return yx[y][x];\n   else if(x+d!=-1 && x+d!=w)return saikiX(y,x+d,d);\n   else return \".\";\n}\n\nfunction kesu(y,x){\n   var arr= [saikiY(y,x,1),saikiY(y,x,-1),saikiX(y,x,1),saikiX(y,x,-1)];\n   var a = arr.filter(function (x, i, self) {\n      if(x==\".\")return false;\n      return self.indexOf(x) === i && i !== self.lastIndexOf(x);\n   });\n   a.forEach(v=> replaceFn(y,x,v));\n   return a.length*2;\n}\n\nfunction replaceFn(y,x,s){\n   for(var i=0;i<h;i++){\n      if(yx[i][x]==s)yx[i][x]=\".\";\n   }\n   for(var i=0;i<w;i++){\n      if(yx[y][i]==s)yx[y][i]=\".\";\n   }\n}\n\nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr=input.trim().split(\"\\n\");\nvar yx = arr.slice(1).map(v=> v.split(\"\"));\nyx=syukusyou(yx);\nyx=kaiten(yx);\nyx=syukusyou(yx);\nvar h=yx.length;\nvar w=yx[0].length;\nvar sum=0;\nwhile(true){\n   var flag=false;\n   yx.forEach((ary,y)=>{\n      ary.forEach((v,x)=>{\n         if(v==\".\"){\n            var add = kesu(y,x);\n            if(add != 0)flag=true;\n            sum += add;\n         }\n      });\n   });\n   if(!flag)break;\n}\nconsole.log(sum);\n"
  },
  {
    "language": "Ruby",
    "code": "h, w = gets.split.map(&:to_i)\na = (1..h).map { gets.chomp.split(\"\") }\npos = {}\na.each.with_index do |row, i|\n  row.each.with_index do |c, j|\n    if c =~ /\\w/\n      (pos[c] ||= []) << i\n      pos[c] << j\n    end\n  end\nend\n\ndef paths(y1, x1, y2, x2)\n  return [Range.new(*[y1, y2].sort).map {|y| [y, x1] }] if x1 == x2\n  return [Range.new(*[x1, x2].sort).map {|x| [y1, x] }] if y1 == y2\n  return [\n    (Range.new(*[x1, x2].sort).map {|x| [y1, x] } + Range.new(*[y1, y2].sort).map {|y| [y, x2] }),\n    (Range.new(*[y1, y2].sort).map {|y| [y, x1] } + Range.new(*[x1, x2].sort).map {|x| [y2, x] })\n  ]\nend\n\nanswer = pos.size * 2\nloop do\n  erase = false\n\n  pos.each do |c, coor|\n    y1, x1, y2, x2 = coor\n    paths = paths(y1, x1, y2, x2)\n    if paths.any? {|path| (path - [[y1, x1], [y2, x2]]).size > 0 && path.all? {|y, x| [y, x] == [y1, x1] || [y, x] == [y2, x2] || a[y][x] == ?. } }\n      erase = true\n      pos.delete(c)\n      a[y1][x1] = ?.\n      a[y2][x2] = ?.\n      break\n    end\n  end\n  break if !erase\nend\nanswer -= pos.size * 2\np answer\n\n"
  },
  {
    "language": "Ruby",
    "code": "class Point\n  attr_accessor :x, :y\n  def initialize(i = 0, j = 0)\n    @y = i\n    @x = j\n  end\n  def ==(p)\n    @y == p.y && @x == p.x\n  end\n  def +(add)\n    Point.new(@y + add.y, @x + add.x)\n  end\n  def -(sub)\n    Point.new(@y - sub.y, @x - sub.x)\n  end\n  def distance(p)\n    (@y - p.y)**2 + (@x - p.x)**2\n  end\nend\n\ndef check(tile, p1, p2)\n  add = Point.new\n  add.y = ((p1.y < p2.y) ? 1 : -1) if p1.x == p2.x\n  add.x = ((p1.x < p2.x) ? 1 : -1) if p1.y == p2.y\n  now = p1.dup + add\n  return false if now == p2\n  while now != p2 do\n    return false if tile[now.y][now.x] != \".\"\n    now += add\n  end\n  return true\nend\n\ndef delete!(tile, p1, p2)\n  if p1.x == p2.x || p1.y == p2.y\n    if check(tile, p1, p2)\n      tile[p1.y][p1.x] = tile[p2.y][p2.x] = \".\"\n      return true\n    end\n    return false\n  end\n\n  2.times do\n    p1, p2 = p2, p1\n    q = Point.new(p1.y, p2.x)\n    next if tile[q.y][q.x] != \".\"\n    next if q.distance(p1) != 1 && !check(tile, q, p1)\n    next if q.distance(p2) != 1 && !check(tile, q, p2)\n    tile[p1.y][p1.x] = tile[p2.y][p2.x] = \".\"\n    return true\n  end\n  return false\nend\n\nH, W = gets.split.map(&:to_i)\ntile = Array.new\nH.times do\n  tile.push(gets.chop.chars)\nend\n\npoint = Hash.new {|h, k| h[k] = Array.new}\nfor i in 0...H do\n  for j in 0...W do\n    next if tile[i][j] == \".\"\n    point[tile[i][j]].push(Point.new(i,j))\n  end\nend\n\nanswer = 0\n26.times do\n  point.each do |key, p|\n    if delete!(tile, p[0], p[1])\n      answer += 2\n      point.delete(key)\n    end\n  end\nend\np answer"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nstruct P {\n    int y, x;\n}\n\nvoid main() {\n    int H, W;\n    scanf(\"%d %d\\n\", &H, &W);\n    auto F = cast(char[][])(new string[H]);\n    foreach (ref L; F) L = cast(char[])readln.chomp;\n\n    auto X = new P[][26];\n    foreach (i; 0 .. H) {\n        foreach (j; 0 .. W) {\n            if (F[i][j] == '.') continue;\n            X[ F[i][j] - 'A' ] ~= P(i, j);\n        }\n    }\n    //foreach (i; 0 .. 26) writeln(cast(char)('A' + i), \" \", X[i]);\n\n    bool check(P a, P b, int dy, int dx) {\n        //writeln(a, \" -> \", b, [dy, dx]);\n        a.y += dy;\n        a.x += dx;\n        while (a != b) {\n            if (F[a.y][a.x].isUpper) return false;\n            a.y += dy;\n            a.x += dx;\n            //writeln(a);\n        }\n        return true;\n    }\n\n    int Ans = 0;\n    auto used = new bool[26];\n    foreach (t; 0 .. 26) {\n        foreach (i; 0 .. 26) {\n            if (X[i].empty) continue;\n            if (used[i]) continue;\n            auto a = X[i][0], b = X[i][1];\n            int y = b.y - a.y,\n                x = b.x - a.x;\n            if (y == 0) {\n                if (abs(x) == 1) continue;\n                if (check(a, b, 0, x / abs(x))) {\n                    F[a.y][a.x] = '.';\n                    F[b.y][b.x] = '.';\n                    Ans += 2;\n                    used[i] = true;\n                }\n            } else if (x == 0) {\n                if (abs(y) == 1) continue;\n                if (check(a, b, y / abs(y), 0)) {\n                    F[a.y][a.x] = '.';\n                    F[b.y][b.x] = '.';\n                    Ans += 2;\n                    used[i] = true;\n                }\n            } else {\n                auto p = P(a.y, b.x),\n                     q = P(b.y, a.x);\n                if ( (F[p.y][p.x] == '.' && \n                            check(a, p, 0, x / abs(x)) && \n                            check(p, b, y / abs(y), 0)) ||\n                     (F[q.y][q.x] == '.' &&\n                            check(a, q, y / abs(y), 0) && \n                            check(q, b, 0, x / abs(x))) ) {\n                    F[a.y][a.x] = '.';\n                    F[b.y][b.x] = '.';\n                    Ans += 2;\n                    used[i] = true;\n                }\n            }\n        }\n    }\n    writeln(Ans);\n}"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    m,n = LI()\n    a = [[c for c in S()] for _ in range(m)]\n    ad = collections.defaultdict(list)\n    for i in range(m):\n        for j in range(n):\n            if a[i][j] != '.':\n                ad[a[i][j]].append((i,j))\n    ps = set(map(tuple,ad.values()))\n    f = True\n    r = 0\n    while f:\n        f = False\n        for pa,pb in list(ps):\n            i1,j1 = pa\n            i2,j2 = pb\n            if i1 == i2 and abs(j1-j2) > 1:\n                ff = True\n                for j in range(min(j1,j2)+1,max(j1,j2)):\n                    if a[i1][j] != '.':\n                        ff = False\n                        break\n                if ff:\n                    f = True\n                    a[i1][j1] = '.'\n                    a[i2][j2] = '.'\n                    ps.remove((pa,pb))\n                    r += 2\n            elif j1 == j2 and abs(i1-i2) > 1:\n                ff = True\n                for i in range(min(i1,i2)+1,max(i1,i2)):\n                    if a[i][j1] != '.':\n                        ff = False\n                        break\n                if ff:\n                    f = True\n                    a[i1][j1] = '.'\n                    a[i2][j2] = '.'\n                    ps.remove((pa,pb))\n                    r += 2\n            else:\n                i,j = i1,j2\n                ff = a[i][j] == '.'\n                for j3 in range(min(j,j2)+1,max(j,j2)):\n                    if a[i][j3] != '.':\n                        ff = False\n                        break\n                for i3 in range(min(i,i2)+1,max(i,i2)):\n                    if a[i3][j] != '.':\n                        ff = False\n                        break\n                if ff:\n                    f = True\n                    a[i1][j1] = '.'\n                    a[i2][j2] = '.'\n                    ps.remove((pa,pb))\n                    r += 2\n                    continue\n                i,j = i2,j1\n                ff = a[i][j] == '.'\n                for j3 in range(min(j,j1)+1,max(j,j1)):\n                    if a[i][j3] != '.':\n                        ff = False\n                        break\n                for i3 in range(min(i,i1)+1,max(i,i1)):\n                    if a[i3][j] != '.':\n                        ff = False\n                        break\n                if ff:\n                    f = True\n                    a[i1][j1] = '.'\n                    a[i2][j2] = '.'\n                    ps.remove((pa,pb))\n                    r += 2\n\n    return r\n\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "h, w = map(int, input().split())\nmp = [input() for _ in range(h)]\n\npoints = {}\nfor y in range(h):\n  for x in range(w):\n    c = mp[y][x]\n    if c != \".\":\n      if c not in points:\n        points[c] = [(x, y)]\n      else:\n        points[c].append((x, y))\n\nkeys = []\npreventer = {}\nfor c, ps in points.items():\n  keys.append(c)\n  p1, p2 = ps\n  x1, y1 = p1\n  x2, y2 = p2\n  if x1 == x2:\n    s = set()\n    for y in range(y1 + 1, y2):\n      s.add(mp[y][x1])\n    preventer[c] = [s]\n    continue\n\n  if y1 == y2:\n    s = set()\n    for x in range(x1 + 1, x2):\n      s.add(mp[y1][x])\n    preventer[c] = [s]\n    continue\n\n  s1 = set()\n  s2 = set()\n  if x1 < x2:\n    for x in range(x1 + 1, x2):\n      s1.add(mp[y1][x])\n    for y in range(y1, y2):\n      s1.add(mp[y][x2])\n    for x in range(x1, x2):\n      s2.add(mp[y2][x])\n    for y in range(y1 + 1, y2):\n      s2.add(mp[y][x1])\n\n  else:\n    for x in range(x2, x1):\n      s1.add(mp[y1][x])\n    for y in range(y1 + 1, y2):\n      s1.add(mp[y][x2])\n    for x in range(x2 + 1, x1):\n      s2.add(mp[y2][x])\n    for y in range(y1 + 1, y2 + 1):\n      s2.add(mp[y][x1])\n  preventer[c] = [s1, s2]\n\nremoval = {\".\":True}\nfor key in keys:\n  removal[key] = False\nans = 0\nwhile True:\n  remove_lst = []\n  for key in keys:\n    for s in preventer[key]:\n      if not s:\n        break\n      \n      for c in s:\n        if not removal[c]:\n          break\n      else:\n        removal[key] = True\n        remove_lst.append(key)\n        ans += 2\n        break\n  \n  if not remove_lst:\n    break\n\n  for rem in remove_lst:\n    keys.remove(rem)\n\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    m,n = LI()\n    a = [[c for c in S()] for _ in range(m)]\n    ad = collections.defaultdict(list)\n    for i in range(m):\n        for j in range(n):\n            if a[i][j] != '.':\n                ad[a[i][j]].append((i,j))\n    ps = set(map(tuple,ad.values()))\n    f = True\n    r = 0\n    while f:\n        f = False\n        for pa,pb in list(ps):\n            i1,j1 = pa\n            i2,j2 = pb\n            if i1 == i2:\n                ff = True\n                for j in range(min(j1,j2)+1,max(j1,j2)):\n                    if a[i1][j] != '.':\n                        ff = False\n                        break\n                if ff:\n                    f = True\n                    a[i1][j1] = '.'\n                    a[i2][j2] = '.'\n                    ps.remove((pa,pb))\n                    r += 2\n            elif j1 == j2:\n                ff = True\n                for i in range(min(i1,i2)+1,max(i1,i2)):\n                    if a[i][j1] != '.':\n                        ff = False\n                        break\n                if ff:\n                    f = True\n                    a[i1][j1] = '.'\n                    a[i2][j2] = '.'\n                    ps.remove((pa,pb))\n                    r += 2\n            else:\n                i,j = i1,j2\n                ff = True\n                for j3 in range(min(j,j2)+1,max(j,j2)):\n                    if a[i][j3] != '.':\n                        ff = False\n                        break\n                for i3 in range(min(i,i2)+1,max(i,i2)):\n                    if a[i3][j] != '.':\n                        ff = False\n                        break\n                if ff:\n                    f = True\n                    a[i1][j1] = '.'\n                    a[i2][j2] = '.'\n                    ps.remove((pa,pb))\n                    r += 2\n                    continue\n                i,j = i2,j1\n                ff = True\n                for j3 in range(min(j,j1)+1,max(j,j1)):\n                    if a[i][j3] != '.':\n                        ff = False\n                        break\n                for i3 in range(min(i,i1)+1,max(i,i1)):\n                    if a[i3][j] != '.':\n                        ff = False\n                        break\n                if ff:\n                    f = True\n                    a[i1][j1] = '.'\n                    a[i2][j2] = '.'\n                    ps.remove((pa,pb))\n                    r += 2\n\n    return r\n\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    m,n = LI()\n    a = [[c for c in S()] for _ in range(m)]\n    ad = collections.defaultdict(list)\n    for i in range(m):\n        for j in range(n):\n            if a[i][j] != '.':\n                ad[a[i][j]].append((i,j))\n    ps = set(map(tuple,ad.values()))\n    f = True\n    r = 0\n    while f:\n        f = False\n        for pa,pb in list(ps):\n            i1,j1 = pa\n            i2,j2 = pb\n            if i1 == i2:\n                ff = abs(j1-j2) > 1\n                for j in range(min(j1,j2)+1,max(j1,j2)):\n                    if a[i1][j] != '.':\n                        ff = False\n                        break\n                if ff:\n                    f = True\n                    a[i1][j1] = '.'\n                    a[i2][j2] = '.'\n                    ps.remove((pa,pb))\n                    r += 2\n            elif j1 == j2:\n                ff = abs(i1-i2) > 1\n                for i in range(min(i1,i2)+1,max(i1,i2)):\n                    if a[i][j1] != '.':\n                        ff = False\n                        break\n                if ff:\n                    f = True\n                    a[i1][j1] = '.'\n                    a[i2][j2] = '.'\n                    ps.remove((pa,pb))\n                    r += 2\n            else:\n                i,j = i1,j2\n                ff = a[i][j] == '.'\n                for j3 in range(min(j,j1)+1,max(j,j1)):\n                    if a[i][j3] != '.':\n                        ff = False\n                        break\n                for i3 in range(min(i,i2)+1,max(i,i2)):\n                    if a[i3][j] != '.':\n                        ff = False\n                        break\n                if ff:\n                    f = True\n                    a[i1][j1] = '.'\n                    a[i2][j2] = '.'\n                    ps.remove((pa,pb))\n                    r += 2\n                    continue\n\n                i,j = i2,j1\n                ff = a[i][j] == '.'\n                for j3 in range(min(j,j2)+1,max(j,j2)):\n                    if a[i][j3] != '.':\n                        ff = False\n                        break\n                for i3 in range(min(i,i1)+1,max(i,i1)):\n                    if a[i3][j] != '.':\n                        ff = False\n                        break\n                if ff:\n                    f = True\n                    a[i1][j1] = '.'\n                    a[i2][j2] = '.'\n                    ps.remove((pa,pb))\n                    r += 2\n\n    return r\n\n\n\nprint(main())\n\n"
  }
]