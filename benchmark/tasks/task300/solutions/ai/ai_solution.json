[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define SIZE 5\n\ntypedef struct {\n    int type;\n    int score;\n} Block;\n\nBlock grid[SIZE][SIZE];\nint max_score = 0;\nint bonus = 1;\n\nvoid init_grid() {\n    for (int i = 0; i < SIZE; i++) {\n        for (int j = 0; j < SIZE; j++) {\n            grid[i][j].type = rand() % 5 + 1;\n            grid[i][j].score = rand() % 10 + 1;\n        }\n    }\n}\n\nvoid print_grid() {\n    for (int i = 0; i < SIZE; i++) {\n        for (int j = 0; j < SIZE; j++) {\n            printf(\"%d(%d) \", grid[i][j].type, grid[i][j].score);\n        }\n        printf(\"\\n\");\n    }\n}\n\nbool is_valid(int x, int y) {\n    return x >= 0 && x < SIZE && y >= 0 && y < SIZE;\n}\n\nvoid swap_blocks(int x1, int y1, int x2, int y2) {\n    Block temp = grid[x1][y1];\n    grid[x1][y1] = grid[x2][y2];\n    grid[x2][y2] = temp;\n}\n\nbool check_matches() {\n    bool marked[SIZE][SIZE] = {false};\n    bool found = false;\n\n    for (int i = 0; i < SIZE; i++) {\n        for (int j = 0; j < SIZE; j++) {\n            if (grid[i][j].type == 0) continue;\n\n            int count = 1;\n            for (int k = j + 1; k < SIZE && grid[i][k].type == grid[i][j].type; k++) {\n                count++;\n            }\n            if (count >= 3) {\n                found = true;\n                for (int k = j; k < j + count; k++) {\n                    marked[i][k] = true;\n                }\n            }\n\n            count = 1;\n            for (int k = i + 1; k < SIZE && grid[k][j].type == grid[i][j].type; k++) {\n                count++;\n            }\n            if (count >= 3) {\n                found = true;\n                for (int k = i; k < i + count; k++) {\n                    marked[k][j] = true;\n                }\n            }\n        }\n    }\n\n    if (found) {\n        for (int i = 0; i < SIZE; i++) {\n            for (int j = 0; j < SIZE; j++) {\n                if (marked[i][j]) {\n                    max_score += grid[i][j].score * bonus;\n                    grid[i][j].type = 0;\n                }\n            }\n        }\n    }\n\n    return found;\n}\n\nvoid apply_gravity() {\n    for (int j = 0; j < SIZE; j++) {\n        int write_idx = SIZE - 1;\n        for (int i = SIZE - 1; i >= 0; i--) {\n            if (grid[i][j].type != 0) {\n                grid[write_idx][j] = grid[i][j];\n                write_idx--;\n            }\n        }\n        while (write_idx >= 0) {\n            grid[write_idx][j].type = rand() % 5 + 1;\n            grid[write_idx][j].score = rand() % 10 + 1;\n            write_idx--;\n        }\n    }\n}\n\nvoid play(int x, int y, int moves_left) {\n    if (moves_left == 0) {\n        return;\n    }\n\n    int dx[] = {-1, 1, 0, 0};\n    int dy[] = {0, 0, -1, 1};\n\n    for (int dir = 0; dir < 4; dir++) {\n        int nx = x + dx[dir];\n        int ny = y + dy[dir];\n\n        if (is_valid(nx, ny)) {\n            swap_blocks(x, y, nx, ny);\n\n            bool changed;\n            do {\n                changed = check_matches();\n                if (changed) {\n                    apply_gravity();\n                    bonus++;\n                }\n            } while (changed);\n\n            play(nx, ny, moves_left - 1);\n\n            do {\n                changed = check_matches();\n                if (changed) {\n                    apply_gravity();\n                    bonus++;\n                }\n            } while (changed);\n\n            swap_blocks(x, y, nx, ny);\n            bonus = 1;\n        }\n    }\n}\n\nint main() {\n    init_grid();\n    printf(\"Initial grid:\\n\");\n    print_grid();\n\n    for (int i = 0; i < SIZE; i++) {\n        for (int j = 0; j < SIZE; j++) {\n            play(i, j, 5);\n        }\n    }\n\n    printf(\"Maximum score: %d\\n\", max_score);\n    return 0;\n}",
    "timestamp": "2025-08-05 20:59:24"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nconst int GRID_SIZE = 5;\nvector<vector<int>> grid(GRID_SIZE, vector<int>(GRID_SIZE));\nvector<int> blockScores = {1, 2, 3, 4, 5}; // Assuming block types are 0-4\n\nstruct State {\n    vector<vector<int>> grid;\n    int score;\n    int bonus;\n};\n\nint maxScore = 0;\n\nbool hasMatches(const vector<vector<int>>& g) {\n    for (int i = 0; i < GRID_SIZE; ++i) {\n        for (int j = 0; j < GRID_SIZE; ++j) {\n            if (i + 2 < GRID_SIZE && g[i][j] == g[i+1][j] && g[i][j] == g[i+2][j]) return true;\n            if (j + 2 < GRID_SIZE && g[i][j] == g[i][j+1] && g[i][j] == g[i][j+2]) return true;\n        }\n    }\n    return false;\n}\n\nvoid removeMatches(vector<vector<int>>& g, int& score, int bonus) {\n    vector<vector<bool>> toRemove(GRID_SIZE, vector<bool>(GRID_SIZE, false));\n    for (int i = 0; i < GRID_SIZE; ++i) {\n        for (int j = 0; j < GRID_SIZE; ++j) {\n            if (i + 2 < GRID_SIZE && g[i][j] == g[i+1][j] && g[i][j] == g[i+2][j]) {\n                toRemove[i][j] = toRemove[i+1][j] = toRemove[i+2][j] = true;\n            }\n            if (j + 2 < GRID_SIZE && g[i][j] == g[i][j+1] && g[i][j] == g[i][j+2]) {\n                toRemove[i][j] = toRemove[i][j+1] = toRemove[i][j+2] = true;\n            }\n        }\n    }\n\n    for (int i = 0; i < GRID_SIZE; ++i) {\n        for (int j = 0; j < GRID_SIZE; ++j) {\n            if (toRemove[i][j]) {\n                score += blockScores[g[i][j]] * bonus;\n                g[i][j] = -1;\n            }\n        }\n    }\n}\n\nvoid applyGravity(vector<vector<int>>& g) {\n    for (int j = 0; j < GRID_SIZE; ++j) {\n        queue<int> blocks;\n        for (int i = GRID_SIZE - 1; i >= 0; --i) {\n            if (g[i][j] != -1) {\n                blocks.push(g[i][j]);\n            }\n        }\n        for (int i = GRID_SIZE - 1; i >= 0; --i) {\n            if (!blocks.empty()) {\n                g[i][j] = blocks.front();\n                blocks.pop();\n            } else {\n                g[i][j] = -1;\n            }\n        }\n    }\n}\n\nvoid refillGrid(vector<vector<int>>& g) {\n    for (int i = 0; i < GRID_SIZE; ++i) {\n        for (int j = 0; j < GRID_SIZE; ++j) {\n            if (g[i][j] == -1) {\n                g[i][j] = rand() % 5;\n            }\n        }\n    }\n}\n\nvoid processMatches(State& state) {\n    while (hasMatches(state.grid)) {\n        removeMatches(state.grid, state.score, state.bonus);\n        applyGravity(state.grid);\n        refillGrid(state.grid);\n        state.bonus++;\n    }\n}\n\nvoid dfs(State state, int movesLeft) {\n    if (movesLeft == 0) {\n        maxScore = max(maxScore, state.score);\n        return;\n    }\n\n    for (int i = 0; i < GRID_SIZE; ++i) {\n        for (int j = 0; j < GRID_SIZE; ++j) {\n            const int dx[] = {-1, 1, 0, 0};\n            const int dy[] = {0, 0, -1, 1};\n            for (int d = 0; d < 4; ++d) {\n                int ni = i + dx[d];\n                int nj = j + dy[d];\n                if (ni >= 0 && ni < GRID_SIZE && nj >= 0 && nj < GRID_SIZE) {\n                    State newState = state;\n                    swap(newState.grid[i][j], newState.grid[ni][nj]);\n                    processMatches(newState);\n                    dfs(newState, movesLeft - 1);\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    // Initialize grid\n    for (int i = 0; i < GRID_SIZE; ++i) {\n        for (int j = 0; j < GRID_SIZE; ++j) {\n            cin >> grid[i][j];\n        }\n    }\n\n    int n;\n    cin >> n;\n\n    State initialState;\n    initialState.grid = grid;\n    initialState.score = 0;\n    initialState.bonus = 1;\n\n    dfs(initialState, n);\n    cout << maxScore << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:00:13"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class SmartphoneGame {\n    private static final int[][] DIRECTIONS = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    private int maxScore = 0;\n\n    public int getMaxScore(int[][] grid, int[] blockScores, int n) {\n        dfs(grid, blockScores, n, 0, 1);\n        return maxScore;\n    }\n\n    private void dfs(int[][] grid, int[] blockScores, int movesLeft, int currentScore, int bonus) {\n        if (movesLeft == 0) {\n            maxScore = Math.max(maxScore, currentScore);\n            return;\n        }\n\n        for (int i = 0; i < 5; i++) {\n            for (int j = 0; j < 5; j++) {\n                for (int[] dir : DIRECTIONS) {\n                    int ni = i + dir[0];\n                    int nj = j + dir[1];\n                    if (ni >= 0 && ni < 5 && nj >= 0 && nj < 5) {\n                        int[][] newGrid = copyGrid(grid);\n                        swap(newGrid, i, j, ni, nj);\n                        int score = currentScore;\n                        int newBonus = bonus;\n                        boolean hasMatches;\n                        do {\n                            hasMatches = false;\n                            List<int[]> matches = findMatches(newGrid);\n                            if (!matches.isEmpty()) {\n                                hasMatches = true;\n                                score += removeBlocks(newGrid, matches, blockScores, newBonus);\n                                newBonus++;\n                                applyGravity(newGrid);\n                            }\n                        } while (hasMatches);\n                        dfs(newGrid, blockScores, movesLeft - 1, score, newBonus);\n                    }\n                }\n            }\n        }\n    }\n\n    private int[][] copyGrid(int[][] grid) {\n        int[][] newGrid = new int[5][5];\n        for (int i = 0; i < 5; i++) {\n            System.arraycopy(grid[i], 0, newGrid[i], 0, 5);\n        }\n        return newGrid;\n    }\n\n    private void swap(int[][] grid, int i1, int j1, int i2, int j2) {\n        int temp = grid[i1][j1];\n        grid[i1][j1] = grid[i2][j2];\n        grid[i2][j2] = temp;\n    }\n\n    private List<int[]> findMatches(int[][] grid) {\n        List<int[]> matches = new ArrayList<>();\n        boolean[][] marked = new boolean[5][5];\n\n        for (int i = 0; i < 5; i++) {\n            for (int j = 0; j < 5; j++) {\n                if (grid[i][j] == -1) continue;\n                if (j + 2 < 5 && grid[i][j] == grid[i][j + 1] && grid[i][j] == grid[i][j + 2]) {\n                    for (int k = j; k < 5 && grid[i][k] == grid[i][j]; k++) {\n                        if (!marked[i][k]) {\n                            matches.add(new int[]{i, k});\n                            marked[i][k] = true;\n                        }\n                    }\n                }\n                if (i + 2 < 5 && grid[i][j] == grid[i + 1][j] && grid[i][j] == grid[i + 2][j]) {\n                    for (int k = i; k < 5 && grid[k][j] == grid[i][j]; k++) {\n                        if (!marked[k][j]) {\n                            matches.add(new int[]{k, j});\n                            marked[k][j] = true;\n                        }\n                    }\n                }\n            }\n        }\n        return matches;\n    }\n\n    private int removeBlocks(int[][] grid, List<int[]> matches, int[] blockScores, int bonus) {\n        int score = 0;\n        for (int[] pos : matches) {\n            int blockType = grid[pos[0]][pos[1]];\n            score += blockScores[blockType] * bonus;\n            grid[pos[0]][pos[1]] = -1;\n        }\n        return score;\n    }\n\n    private void applyGravity(int[][] grid) {\n        for (int j = 0; j < 5; j++) {\n            int emptyRow = 4;\n            for (int i = 4; i >= 0; i--) {\n                if (grid[i][j] != -1) {\n                    grid[emptyRow][j] = grid[i][j];\n                    if (emptyRow != i) {\n                        grid[i][j] = -1;\n                    }\n                    emptyRow--;\n                }\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:01:19"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class BlockGame {\n    private static final int GRID_SIZE = 5;\n    private static final int[] DX = {0, 0, 1, -1};\n    private static final int[] DY = {1, -1, 0, 0};\n\n    public static int maxScore(int[][] grid) {\n        return solve(grid, 0);\n    }\n\n    private static int solve(int[][] grid, int currentScore) {\n        int maxScore = currentScore;\n        int[][] copy = deepCopy(grid);\n\n        for (int x = 0; x < GRID_SIZE; x++) {\n            for (int y = 0; y < GRID_SIZE; y++) {\n                for (int dir = 0; dir < 4; dir++) {\n                    int nx = x + DX[dir];\n                    int ny = y + DY[dir];\n\n                    if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {\n                        swap(copy, x, y, nx, ny);\n                        int bonusScore = 1;\n                        int scoreAfterMove = processChains(copy, bonusScore);\n                        maxScore = Math.max(maxScore, solve(copy, currentScore + scoreAfterMove));\n                        swap(copy, x, y, nx, ny);\n                    }\n                }\n            }\n        }\n        return maxScore;\n    }\n\n    private static int processChains(int[][] grid, int bonusScore) {\n        int totalScore = 0;\n        boolean[][] removed = new boolean[GRID_SIZE][GRID_SIZE];\n\n        while (true) {\n            boolean chainFound = checkAndMarkChains(grid, removed);\n            if (!chainFound) break;\n\n            totalScore += removeChains(grid, removed, bonusScore);\n            fallBlocks(grid);\n            bonusScore++;\n        }\n\n        return totalScore;\n    }\n\n    private static boolean checkAndMarkChains(int[][] grid, boolean[][] removed) {\n        boolean chainFound = false;\n        for (int x = 0; x < GRID_SIZE; x++) {\n            for (int y = 0; y < GRID_SIZE; y++) {\n                if (grid[x][y] != 0) {\n                    chainFound |= checkHorizontalChain(grid, x, y, removed);\n                    chainFound |= checkVerticalChain(grid, x, y, removed);\n                }\n            }\n        }\n        return chainFound;\n    }\n\n    private static boolean checkHorizontalChain(int[][] grid, int x, int y, boolean[][] removed) {\n        int val = grid[x][y];\n        int count = 1;\n        int left = y - 1, right = y + 1;\n\n        while (left >= 0 && grid[x][left] == val) {\n            count++;\n            left--;\n        }\n        while (right < GRID_SIZE && grid[x][right] == val) {\n            count++;\n            right++;\n        }\n\n        if (count >= 3) {\n            removed[x][y] = true;\n            for (int i = left + 1; i < right; i++) {\n                removed[x][i] = true;\n            }\n            return true;\n        }\n        return false;\n    }\n\n    private static boolean checkVerticalChain(int[][] grid, int x, int y, boolean[][] removed) {\n        int val = grid[x][y];\n        int count = 1;\n        int up = x - 1, down = x + 1;\n\n        while (up >= 0 && grid[up][y] == val) {\n            count++;\n            up--;\n        }\n        while (down < GRID_SIZE && grid[down][y] == val) {\n            count++;\n            down++;\n        }\n\n        if (count >= 3) {\n            removed[x][y] = true;\n            for (int i = up + 1; i < down; i++) {\n                removed[i][y] = true;\n            }\n            return true;\n        }\n        return false;\n    }\n\n    private static int removeChains(int[][] grid, boolean[][] removed, int bonusScore) {\n        int totalScore = 0;\n        for (int x = 0; x < GRID_SIZE; x++) {\n            for (int y = 0; y < GRID_SIZE; y++) {\n                if (removed[x][y]) {\n                    totalScore += grid[x][y] * bonusScore;\n                    grid[x][y] = 0;\n                }\n            }\n        }\n        return totalScore;\n    }\n\n    private static void fallBlocks(int[][] grid) {\n        for (int y = 0; y < GRID_SIZE; y++) {\n            int[] column = new int[GRID_SIZE];\n            int index = GRID_SIZE - 1;\n\n            for (int x = GRID_SIZE - 1; x >= 0; x--) {\n                if (grid[x][y] != 0) {\n                    column[index--] = grid[x][y];\n                }\n            }\n\n            for (int x = GRID_SIZE - 1; x >= 0; x--) {\n                grid[x][y] = column[x];\n            }\n        }\n    }\n\n    private static void swap(int[][] grid, int x1, int y1, int x2, int y2) {\n        int temp = grid[x1][y1];\n        grid[x1][y1] = grid[x2][y2];\n        grid[x2][y2] = temp;\n    }\n\n    private static int[][] deepCopy(int[][] original) {\n        int[][] copy = new int[GRID_SIZE][GRID_SIZE];\n        for (int x = 0; x < GRID_SIZE; x++) {\n            copy[x] = Arrays.copyOf(original[x], GRID_SIZE);\n        }\n        return copy;\n    }\n}",
    "timestamp": "2025-08-05 21:01:36"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#define GRID_SIZE 5\n#define DIRECTIONS 4\n\ntypedef struct {\n    int grid[GRID_SIZE][GRID_SIZE];\n    int scores[GRID_SIZE];\n} GameState;\n\nint dx[DIRECTIONS] = {0, 0, -1, 1};\nint dy[DIRECTIONS] = {-1, 1, 0, 0};\n\nint isValidMove(int x, int y) {\n    return x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE;\n}\n\nvoid fallBlocks(GameState* state) {\n    for (int col = 0; col < GRID_SIZE; col++) {\n        int bottom = GRID_SIZE - 1;\n        for (int row = GRID_SIZE - 1; row >= 0; row--) {\n            if (state->grid[row][col] != 0) {\n                state->grid[bottom][col] = state->grid[row][col];\n                if (bottom != row) {\n                    state->grid[row][col] = 0;\n                }\n                bottom--;\n            }\n        }\n        while (bottom >= 0) {\n            state->grid[bottom][col] = 0;\n            bottom--;\n        }\n    }\n}\n\nint checkAndRemoveAlignments(GameState* state, int* bonus) {\n    int removed[GRID_SIZE][GRID_SIZE] = {0};\n    int totalScore = 0;\n\n    // Check horizontal alignments\n    for (int row = 0; row < GRID_SIZE; row++) {\n        for (int col = 0; col <= GRID_SIZE - 3; col++) {\n            int blockType = state->grid[row][col];\n            if (blockType == 0) continue;\n            \n            if (blockType == state->grid[row][col+1] && blockType == state->grid[row][col+2]) {\n                for (int k = col; k < col + 3; k++) {\n                    removed[row][k] = 1;\n                }\n            }\n        }\n    }\n\n    // Check vertical alignments\n    for (int col = 0; col < GRID_SIZE; col++) {\n        for (int row = 0; row <= GRID_SIZE - 3; row++) {\n            int blockType = state->grid[row][col];\n            if (blockType == 0) continue;\n            \n            if (blockType == state->grid[row+1][col] && blockType == state->grid[row+2][col]) {\n                for (int k = row; k < row + 3; k++) {\n                    removed[k][col] = 1;\n                }\n            }\n        }\n    }\n\n    // Remove blocks and calculate score\n    for (int row = 0; row < GRID_SIZE; row++) {\n        for (int col = 0; col < GRID_SIZE; col++) {\n            if (removed[row][col]) {\n                totalScore += state->scores[state->grid[row][col] - 1] * (*bonus);\n                state->grid[row][col] = 0;\n            }\n        }\n    }\n\n    if (totalScore > 0) {\n        (*bonus)++;\n        fallBlocks(state);\n        totalScore += checkAndRemoveAlignments(state, bonus);\n    }\n\n    return totalScore;\n}\n\nint solve(GameState* state) {\n    int maxScore = 0;\n\n    for (int startRow = 0; startRow < GRID_SIZE; startRow++) {\n        for (int startCol = 0; startCol < GRID_SIZE; startCol++) {\n            for (int numMoves = 1; numMoves <= GRID_SIZE; numMoves++) {\n                for (int dir = 0; dir < DIRECTIONS; dir++) {\n                    GameState tempState = *state;\n                    int currentRow = startRow;\n                    int currentCol = startCol;\n                    int moved = 0;\n\n                    while (moved < numMoves && isValidMove(currentRow + dy[dir], currentCol + dx[dir])) {\n                        int newRow = currentRow + dy[dir];\n                        int newCol = currentCol + dx[dir];\n\n                        // Swap blocks\n                        int temp = tempState.grid[currentRow][currentCol];\n                        tempState.grid[currentRow][currentCol] = tempState.grid[newRow][newCol];\n                        tempState.grid[newRow][newCol] = temp;\n\n                        int bonus = 1;\n                        int score = checkAndRemoveAlignments(&tempState, &bonus);\n                        maxScore = (score > maxScore) ? score : maxScore;\n\n                        currentRow = newRow;\n                        currentCol = newCol;\n                        moved++;\n                    }\n                }\n            }\n        }\n    }\n\n    return maxScore;\n}\n\nint main() {\n    GameState state;\n    for (int i = 0; i < GRID_SIZE; i++) {\n        for (int j = 0; j < GRID_SIZE; j++) {\n            scanf(\"%d\", &state.grid[i][j]);\n        }\n    }\n\n    for (int i = 0; i < GRID_SIZE; i++) {\n        scanf(\"%d\", &state.scores[i]);\n    }\n\n    printf(\"%d\\n\", solve(&state));\n    return 0;\n}",
    "timestamp": "2025-08-05 21:01:54"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nclass BlockGame {\nprivate:\n    vector<vector<int>> grid;\n    vector<int> blockScores;\n    int maxScore;\n\n    bool checkAlignment(vector<vector<int>>& board) {\n        vector<vector<bool>> removed(5, vector<bool>(5, false));\n        bool hasAlignment = false;\n\n        // Check horizontal alignment\n        for (int r = 0; r < 5; r++) {\n            for (int c = 0; c < 3; c++) {\n                if (board[r][c] != 0 && board[r][c] == board[r][c+1] && board[r][c] == board[r][c+2]) {\n                    removed[r][c] = removed[r][c+1] = removed[r][c+2] = true;\n                    hasAlignment = true;\n                }\n            }\n        }\n\n        // Check vertical alignment\n        for (int c = 0; c < 5; c++) {\n            for (int r = 0; r < 3; r++) {\n                if (board[r][c] != 0 && board[r][c] == board[r+1][c] && board[r][c] == board[r+2][c]) {\n                    removed[r][c] = removed[r+1][c] = removed[r+2][c] = true;\n                    hasAlignment = true;\n                }\n            }\n        }\n\n        // Remove aligned blocks\n        if (hasAlignment) {\n            for (int r = 0; r < 5; r++) {\n                for (int c = 0; c < 5; c++) {\n                    if (removed[r][c]) board[r][c] = 0;\n                }\n            }\n        }\n\n        return hasAlignment;\n    }\n\n    void fallBlocks(vector<vector<int>>& board) {\n        for (int c = 0; c < 5; c++) {\n            vector<int> column;\n            for (int r = 4; r >= 0; r--) {\n                if (board[r][c] != 0) {\n                    column.push_back(board[r][c]);\n                }\n            }\n            \n            while (column.size() < 5) column.push_back(0);\n            \n            for (int r = 0; r < 5; r++) {\n                board[4-r][c] = column[r];\n            }\n        }\n    }\n\n    int calculateScore(vector<vector<int>>& board, int bonusScore) {\n        int score = 0;\n        for (int r = 0; r < 5; r++) {\n            for (int c = 0; c < 5; c++) {\n                if (board[r][c] != 0) {\n                    score += blockScores[board[r][c]-1] * bonusScore;\n                }\n            }\n        }\n        return score;\n    }\n\n    void solve(vector<vector<int>> board, int bonusScore, int currentScore) {\n        maxScore = max(maxScore, currentScore);\n\n        for (int r = 0; r < 5; r++) {\n            for (int c = 0; c < 5; c++) {\n                if (board[r][c] == 0) continue;\n\n                // Try moving in 4 directions\n                vector<pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n                for (auto [dr, dc] : directions) {\n                    int nr = r + dr, nc = c + dc;\n                    if (nr < 0 || nr >= 5 || nc < 0 || nc >= 5) continue;\n\n                    // Swap blocks\n                    vector<vector<int>> newBoard = board;\n                    swap(newBoard[r][c], newBoard[nr][nc]);\n\n                    int currBonusScore = bonusScore;\n                    bool hasAlignment = checkAlignment(newBoard);\n\n                    while (hasAlignment) {\n                        fallBlocks(newBoard);\n                        currBonusScore++;\n                        hasAlignment = checkAlignment(newBoard);\n                    }\n\n                    int newScore = calculateScore(newBoard, currBonusScore);\n                    solve(newBoard, currBonusScore, currentScore + newScore);\n                }\n            }\n        }\n    }\n\npublic:\n    int findMaxScore(vector<vector<int>> initialGrid, vector<int> scores) {\n        grid = initialGrid;\n        blockScores = scores;\n        maxScore = 0;\n        solve(grid, 1, 0);\n        return maxScore;\n    }\n};\n\nint main() {\n    vector<vector<int>> grid = {\n        {1, 2, 3, 4, 5},\n        {5, 4, 3, 2, 1},\n        {1, 2, 3, 4, 5},\n        {5, 4, 3, 2, 1},\n        {1, 2, 3, 4, 5}\n    };\n    vector<int> scores = {10, 20, 30, 40, 50};\n\n    BlockGame game;\n    cout << game.findMaxScore(grid, scores) << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:02:10"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from itertools import product\nimport copy\n\ndef get_score_and_update_grid(grid, bonus):\n    score = 0\n    while True:\n        remove = set()\n        # Check horizontal alignment\n        for r in range(5):\n            for c in range(3):\n                if grid[r][c] and grid[r][c] == grid[r][c+1] == grid[r][c+2]:\n                    remove.update({(r, c), (r, c+1), (r, c+2)})\n        # Check vertical alignment\n        for c in range(5):\n            for r in range(3):\n                if grid[r][c] and grid[r][c] == grid[r+1][c] == grid[r+2][c]:\n                    remove.update({(r, c), (r+1, c), (r+2, c)})\n        # Calculate score and remove blocks\n        if not remove:\n            break\n        for r, c in remove:\n            score += grid[r][c][1] * bonus  # grid[r][c][1] is the block score\n            grid[r][c] = None\n        # Fall down blocks\n        for c in range(5):\n            fill_row = 4\n            for r in range(4, -1, -1):\n                if grid[r][c]:\n                    grid[fill_row][c] = grid[r][c]\n                    fill_row -= 1\n            for r in range(fill_row, -1, -1):\n                grid[r][c] = None\n        bonus += 1\n    return score, bonus\n\ndef max_score(grid, n):\n    max_score = 0\n    original_grid = copy.deepcopy(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    for r, c in product(range(5), repeat=2):\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < 5 and 0 <= nc < 5:\n                # Try making a swap\n                grid[r][c], grid[nr][nc] = grid[nr][nc], grid[r][c]\n                for moves in range(n):\n                    new_grid = copy.deepcopy(grid)\n                    score, _ = get_score_and_update_grid(new_grid, 1)\n                    max_score = max(max_score, score)\n                # Swap back\n                grid[r][c], grid[nr][nc] = grid[nr][nc], grid[r][c]\n    \n    return max_score\n\n# The input grid should be a 5x5 list of lists, where each element is a tuple (block_type, block_score)\n# Example grid: grid = [[(1, 10), (2, 20), (3, 30), (4, 40), (5, 50)], ...]\n# max_score(grid, n) can be called to find the solution",
    "timestamp": "2025-08-13 04:25:19"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Arrays;\n\npublic class BlockGame {\n    private static final int GRID_SIZE = 5;\n    private static final int TYPES_OF_BLOCKS = 5;\n    private int[][] grid;\n    private int bonusScore;\n    private boolean[][] visited;\n\n    public BlockGame(int[][] grid) {\n        this.grid = grid;\n        this.bonusScore = 1;\n        this.visited = new boolean[GRID_SIZE][GRID_SIZE];\n    }\n\n    public int getMaxScore(int moves) {\n        int maxScore = 0;\n        for (int i = 0; i < GRID_SIZE; i++) {\n            for (int j = 0; j < GRID_SIZE; j++) {\n                maxScore = Math.max(maxScore, dfs(i, j, moves));\n            }\n        }\n        return maxScore;\n    }\n\n    private int dfs(int x, int y, int moves) {\n        if (moves == 0) {\n            return calculateScore();\n        }\n\n        int maxScore = calculateScore();\n        int originalType = grid[x][y];\n\n        for (int[] direction : new int[][] {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}) {\n            int nx = x + direction[0], ny = y + direction[1];\n            if (nx < 0 || nx >= GRID_SIZE || ny < 0 || ny >= GRID_SIZE) continue;\n\n            // Swap blocks\n            swap(x, y, nx, ny);\n            maxScore = Math.max(maxScore, dfs(nx, ny, moves - 1));\n            // Swap back\n            swap(x, y, nx, ny);\n        }\n        return maxScore;\n    }\n\n    private void swap(int x1, int y1, int x2, int y2) {\n        int temp = grid[x1][y1];\n        grid[x1][y1] = grid[x2][y2];\n        grid[x2][y2] = temp;\n    }\n\n    private int calculateScore() {\n        int totalScore = 0;\n        boolean repeat;\n\n        do {\n            repeat = false;\n            for (boolean[] row : visited) {\n                Arrays.fill(row, false);\n            }\n\n            // Check for horizontal and vertical alignment\n            for (int i = 0; i < GRID_SIZE; i++) {\n                for (int j = 0; j < GRID_SIZE; j++) {\n                    if (grid[i][j] != 0 && !visited[i][j]) {\n                        int horizontalCount = 1, verticalCount = 1;\n                        int k = j + 1;\n                        while (k < GRID_SIZE && grid[i][k] == grid[i][j]) {\n                            horizontalCount++;\n                            k++;\n                        }\n                        if (horizontalCount >= 3) {\n                            totalScore += horizontalCount * grid[i][j] * bonusScore;\n                            for (k = j; k < j + horizontalCount; k++) {\n                                grid[i][k] = 0;\n                                visited[i][k] = true;\n                            }\n                            repeat = true;\n                        }\n\n                        k = i + 1;\n                        while (k < GRID_SIZE && grid[k][j] == grid[i][j]) {\n                            verticalCount++;\n                            k++;\n                        }\n                        if (verticalCount >= 3) {\n                            totalScore += verticalCount * grid[i][j] * bonusScore;\n                            for (k = i; k < i + verticalCount; k++) {\n                                grid[k][j] = 0;\n                                visited[k][j] = true;\n                            }\n                            repeat = true;\n                        }\n                    }\n                }\n            }\n\n            if (repeat) {\n                bonusScore++;\n                // Gravity effect\n                for (int j = 0; j < GRID_SIZE; j++) {\n                    int emptyRow = GRID_SIZE - 1;\n                    for (int i = GRID_SIZE - 1; i >= 0; i--) {\n                        if (grid[i][j] != 0) {\n                            grid[emptyRow][j] = grid[i][j];\n                            if (emptyRow != i) grid[i][j] = 0;\n                            emptyRow--;\n                        }\n                    }\n                }\n            }\n        } while (repeat);\n\n        return totalScore;\n    }\n\n    public static void main(String[] args) {\n        int[][] initialGrid = {\n            {1, 2, 3, 4, 5},\n            {5, 4, 3, 2, 1},\n            {2, 3, 4, 5, 1},\n            {1, 5, 3, 3, 2},\n            {4, 1, 1, 4, 5}\n        };\n        BlockGame blockGame = new BlockGame(initialGrid);\n        System.out.println(\"Max Score: \" + blockGame.getMaxScore(3));\n    }\n}",
    "timestamp": "2025-08-13 04:25:30"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define GRID_SIZE 5\n#define TYPE_COUNT 5\n\ntypedef struct {\n    int type;\n    int score;\n} Block;\n\ntypedef struct {\n    int x, y;\n} Position;\n\nint directions[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n\nBlock grid[GRID_SIZE][GRID_SIZE];\nint visited[GRID_SIZE][GRID_SIZE];\nint maxScore = 0;\n\nvoid copyGrid(Block dest[GRID_SIZE][GRID_SIZE], Block src[GRID_SIZE][GRID_SIZE]) {\n    memcpy(dest, src, sizeof(Block) * GRID_SIZE * GRID_SIZE);\n}\n\nvoid resetVisited() {\n    memset(visited, 0, sizeof(int) * GRID_SIZE * GRID_SIZE);\n}\n\nbool isValid(int x, int y) {\n    return x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE;\n}\n\nint clearAlignedBlocks(Block grid[GRID_SIZE][GRID_SIZE], int bonusScore) {\n    int score = 0;\n    bool anyCleared = false;\n    memset(visited, 0, sizeof(visited));\n\n    // Check horizontally and vertically\n    for (int i = 0; i < GRID_SIZE; i++) {\n        for (int j = 0; j < GRID_SIZE; j++) {\n            if (!visited[i][j]) {\n                int type = grid[i][j].type;\n                int start = j;\n                while (j < GRID_SIZE && grid[i][j].type == type) j++;\n                if (j - start >= 3) {\n                    anyCleared = true;\n                    for (int k = start; k < j; k++) {\n                        score += grid[i][k].score * bonusScore;\n                        visited[i][k] = 1;\n                        grid[i][k].type = -1;\n                    }\n                }\n                j--;\n            }\n        }\n    }\n\n    for (int j = 0; j < GRID_SIZE; j++) {\n        for (int i = 0; i < GRID_SIZE; i++) {\n            if (!visited[i][j]) {\n                int type = grid[i][j].type;\n                int start = i;\n                while (i < GRID_SIZE && grid[i][j].type == type) i++;\n                if (i - start >= 3) {\n                    anyCleared = true;\n                    for (int k = start; k < i; k++) {\n                        score += grid[k][j].score * bonusScore;\n                        visited[k][j] = 1;\n                        grid[k][j].type = -1;\n                    }\n                }\n                i--;\n            }\n        }\n    }\n\n    if (!anyCleared) return 0;\n\n    for (int j = 0; j < GRID_SIZE; j++) {\n        int writeIndex = GRID_SIZE - 1;\n        for (int i = GRID_SIZE - 1; i >= 0; i--) {\n            if (grid[i][j].type != -1) {\n                grid[writeIndex][j] = grid[i][j];\n                writeIndex--;\n            }\n        }\n        for (int i = writeIndex; i >= 0; i--) {\n            grid[i][j].type = -1;\n        }\n    }\n\n    return score + clearAlignedBlocks(grid, bonusScore + 1);\n}\n\nvoid dfs(Block currentGrid[GRID_SIZE][GRID_SIZE], int x, int y, int moves, int bonusScore, int currentScore) {\n    maxScore = currentScore > maxScore ? currentScore : maxScore;\n\n    if (moves == 0) return;\n\n    Block newGrid[GRID_SIZE][GRID_SIZE];\n    for (int d = 0; d < 4; d++) {\n        int nx = x + directions[d][0];\n        int ny = y + directions[d][1];\n\n        if (isValid(nx, ny)) {\n            copyGrid(newGrid, currentGrid);\n            Block temp = newGrid[x][y];\n            newGrid[x][y] = newGrid[nx][ny];\n            newGrid[nx][ny] = temp;\n\n            int scoreGained = clearAlignedBlocks(newGrid, bonusScore);\n            if (scoreGained > 0) {\n                dfs(newGrid, nx, ny, moves - 1, 1, currentScore + scoreGained);\n            } else {\n                dfs(newGrid, nx, ny, moves - 1, bonusScore, currentScore);\n            }\n        }\n    }\n}\n\nint main() {\n    // Initialize the grid with Block types and scores\n    for (int i = 0; i < GRID_SIZE; i++) {\n        for (int j = 0; j < GRID_SIZE; j++) {\n            scanf(\"%d %d\", &grid[i][j].type, &grid[i][j].score);\n        }\n    }\n\n    int n; // Number of possible moves\n    scanf(\"%d\", &n);\n    \n    // Try every block as a starting move\n    for (int i = 0; i < GRID_SIZE; i++) {\n        for (int j = 0; j < GRID_SIZE; j++) {\n            dfs(grid, i, j, n, 1, 0);\n        }\n    }\n\n    printf(\"%d\\n\", maxScore);\n    return 0;\n}",
    "timestamp": "2025-08-13 04:25:45"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from typing import List, Tuple\nimport copy\n\ndef solve_block_game(grid: List[List[int]], scores: List[int], max_moves: int) -> int:\n    def is_valid(x: int, y: int) -> bool:\n        return 0 <= x < 5 and 0 <= y < 5\n\n    def check_alignments(current_grid: List[List[int]]) -> List[Tuple[int, int]]:\n        to_remove = set()\n        for x in range(5):\n            for y in range(5):\n                if current_grid[x][y] == 0:\n                    continue\n                # Check horizontal\n                if y <= 2 and current_grid[x][y] == current_grid[x][y+1] == current_grid[x][y+2]:\n                    to_remove.update([(x,y), (x,y+1), (x,y+2)])\n                # Check vertical\n                if x <= 2 and current_grid[x][y] == current_grid[x+1][y] == current_grid[x+2][y]:\n                    to_remove.update([(x,y), (x+1,y), (x+2,y)])\n        return list(to_remove)\n\n    def fall_blocks(current_grid: List[List[int]]) -> List[List[int]]:\n        for y in range(5):\n            column = [current_grid[x][y] for x in range(4, -1, -1) if current_grid[x][y] != 0]\n            for x in range(4, -1, -1):\n                current_grid[x][y] = column.pop(0) if column else 0\n        return current_grid\n\n    def max_score_recursive(current_grid: List[List[int]], bonus: int, moves_left: int) -> int:\n        max_score = 0\n        for x in range(5):\n            for y in range(5):\n                if current_grid[x][y] == 0:\n                    continue\n                \n                for dx, dy in [(0,1), (0,-1), (1,0), (-1,0)]:\n                    grid_copy = copy.deepcopy(current_grid)\n                    total_score = 0\n                    curr_bonus = bonus\n                    \n                    for _ in range(moves_left):\n                        nx, ny = x + dx, y + dy\n                        if not is_valid(nx, ny):\n                            break\n                        \n                        # Swap blocks\n                        grid_copy[x][y], grid_copy[nx][ny] = grid_copy[nx][ny], grid_copy[x][y]\n                        \n                        # Check for alignments\n                        removals = check_alignments(grid_copy)\n                        if not removals:\n                            # Revert swap if no alignments\n                            grid_copy[x][y], grid_copy[nx][ny] = grid_copy[nx][ny], grid_copy[x][y]\n                            break\n                        \n                        # Remove blocks and calculate score\n                        for rx, ry in removals:\n                            total_score += scores[grid_copy[rx][ry]-1] * curr_bonus\n                            grid_copy[rx][ry] = 0\n                        \n                        # Fall blocks\n                        grid_copy = fall_blocks(grid_copy)\n                        \n                        # Continue checking for new alignments\n                        while True:\n                            removals = check_alignments(grid_copy)\n                            if not removals:\n                                break\n                            for rx, ry in removals:\n                                total_score += scores[grid_copy[rx][ry]-1] * curr_bonus\n                                grid_copy[rx][ry] = 0\n                            grid_copy = fall_blocks(grid_copy)\n                        \n                        curr_bonus += 1\n                        x, y = nx, ny\n                    \n                    max_score = max(max_score, total_score)\n        \n        return max_score\n\n    return max_score_recursive(grid, 1, max_moves)",
    "timestamp": "2025-08-13 04:26:11"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_score(grid, n):\n    max_score = 0\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    def copy_grid(g):\n        return [row[:] for row in g]\n    \n    def find_matches(g):\n        matches = set()\n        # Check horizontal matches\n        for i in range(5):\n            for j in range(3):\n                if g[i][j] == g[i][j+1] == g[i][j+2]:\n                    matches.add((i, j))\n                    matches.add((i, j+1))\n                    matches.add((i, j+2))\n        # Check vertical matches\n        for i in range(3):\n            for j in range(5):\n                if g[i][j] == g[i+1][j] == g[i+2][j]:\n                    matches.add((i, j))\n                    matches.add((i+1, j))\n                    matches.add((i+2, j))\n        return matches\n    \n    def remove_and_fall(g, bonus):\n        nonlocal max_score\n        while True:\n            matches = find_matches(g)\n            if not matches:\n                break\n            # Calculate score\n            score_increment = 0\n            for i, j in matches:\n                score_increment += g[i][j] * bonus\n            max_score += score_increment\n            # Remove matched blocks\n            for i, j in matches:\n                g[i][j] = 0\n            # Let blocks fall\n            for j in range(5):\n                # Collect non-zero blocks in the column\n                column = [g[i][j] for i in range(5) if g[i][j] != 0]\n                # Fill the column from bottom\n                for i in range(5 - len(column)):\n                    g[i][j] = 0\n                for i in range(5 - len(column), 5):\n                    g[i][j] = column[i - (5 - len(column))]\n        return g\n    \n    def dfs(current_grid, moves_left, bonus):\n        nonlocal max_score\n        if moves_left == 0:\n            return\n        for i in range(5):\n            for j in range(5):\n                for di, dj in directions:\n                    ni, nj = i + di, j + dj\n                    if 0 <= ni < 5 and 0 <= nj < 5:\n                        new_grid = copy_grid(current_grid)\n                        # Swap blocks\n                        new_grid[i][j], new_grid[ni][nj] = new_grid[ni][nj], new_grid[i][j]\n                        temp_grid = copy_grid(new_grid)\n                        # Process matches and falls\n                        temp_grid = remove_and_fall(temp_grid, bonus)\n                        # Increase bonus if any matches occurred\n                        new_bonus = bonus + 1 if temp_grid != new_grid else bonus\n                        # Recurse\n                        dfs(temp_grid, moves_left - 1, new_bonus)\n    \n    initial_grid = copy_grid(grid)\n    remove_and_fall(initial_grid, 1)\n    dfs(initial_grid, n, 1)\n    return max_score",
    "timestamp": "2025-08-13 04:26:40"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int GRID_SIZE = 5;\nconst vector<vector<int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\nstruct Block {\n    int type;\n    int score;\n};\n\nint getScore(vector<vector<Block>>& grid, int bonus) {\n    int score = 0;\n    vector<vector<bool>> marked(GRID_SIZE, vector<bool>(GRID_SIZE, false));\n    \n    // Check horizontal matches\n    for (int i = 0; i < GRID_SIZE; ++i) {\n        for (int j = 0; j < GRID_SIZE - 2; ++j) {\n            if (grid[i][j].type == grid[i][j+1].type && grid[i][j].type == grid[i][j+2].type && grid[i][j].type != 0) {\n                int type = grid[i][j].type;\n                for (int k = j; k < GRID_SIZE && grid[i][k].type == type; ++k) {\n                    marked[i][k] = true;\n                }\n            }\n        }\n    }\n\n    // Check vertical matches\n    for (int j = 0; j < GRID_SIZE; ++j) {\n        for (int i = 0; i < GRID_SIZE - 2; ++i) {\n            if (grid[i][j].type == grid[i+1][j].type && grid[i][j].type == grid[i+2][j].type && grid[i][j].type != 0) {\n                int type = grid[i][j].type;\n                for (int k = i; k < GRID_SIZE && grid[k][j].type == type; ++k) {\n                    marked[k][j] = true;\n                }\n            }\n        }\n    }\n\n    // Calculate score and remove marked blocks\n    for (int i = 0; i < GRID_SIZE; ++i) {\n        for (int j = 0; j < GRID_SIZE; ++j) {\n            if (marked[i][j]) {\n                score += grid[i][j].score * bonus;\n                grid[i][j].type = 0;\n            }\n        }\n    }\n\n    // Drop blocks\n    for (int j = 0; j < GRID_SIZE; ++j) {\n        int emptyRow = GRID_SIZE - 1;\n        for (int i = GRID_SIZE - 1; i >= 0; --i) {\n            if (grid[i][j].type != 0) {\n                swap(grid[i][j], grid[emptyRow][j]);\n                --emptyRow;\n            }\n        }\n    }\n\n    return score;\n}\n\nint dfs(vector<vector<Block>>& grid, int n, int bonus) {\n    int maxScore = getScore(grid, bonus);\n    bonus++;\n    vector<vector<Block>> tempGrid = grid;\n\n    for (int i = 0; i < GRID_SIZE; ++i) {\n        for (int j = 0; j < GRID_SIZE; ++j) {\n            for (const auto& dir : directions) {\n                int ni = i + dir[0], nj = j + dir[1];\n                if (ni >= 0 && ni < GRID_SIZE && nj >= 0 && nj < GRID_SIZE) {\n                    swap(grid[i][j], grid[ni][nj]);\n                    int currentScore = getScore(grid, bonus);\n                    if (currentScore > 0) {\n                        currentScore += dfs(grid, n - 1, bonus);\n                    }\n                    maxScore = max(maxScore, currentScore);\n                    grid = tempGrid;\n                }\n            }\n        }\n    }\n\n    return maxScore;\n}\n\nint main() {\n    vector<vector<Block>> grid(GRID_SIZE, vector<Block>(GRID_SIZE));\n    // Input the grid\n    for (int i = 0; i < GRID_SIZE; ++i) {\n        for (int j = 0; j < GRID_SIZE; ++j) {\n            cin >> grid[i][j].type >> grid[i][j].score;\n        }\n    }\n    \n    int n;\n    cin >> n;\n    \n    cout << dfs(grid, n, 1) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:19:37"
  }
]