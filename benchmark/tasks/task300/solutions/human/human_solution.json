[
  {
    "language": "C++",
    "code": "#include <vector>\n#include <set>\n#include <iostream>\n#include <cstdio>\n#include <queue>\nusing namespace std;\n\nusing vector2D = vector< vector<int> >;\nconst int B = 5;\nint N;\n\nint dx[] = {1, -1, 0, 0};\nint dy[] = {0, 0, 1, -1};\n\nstruct State {\n  vector2D board;\n  int x, y;\n};\n\nvector<int> score;\nlong long int solve(vector2D board) {\n  long long int ret = 0, bonus = 1;\n  for(; ; bonus++) {\n    bool update = false;\n    vector2D checked(B, vector<int>(B));\n    \n    for(int i=0; i<B; i++) {\n      for(int j=0; j<B; j++) {\n        // empty\n        if(board[i][j] == 0) continue;\n\n        vector<int> dirs = {2, 0};\n        for(auto k : dirs) {\n          // right or down\n          int cons = 0;\n          int nx = i, ny = j;\n          while(nx < B && ny < B) {\n            if(board[nx][ny] != board[i][j]) break;\n            cons++;\n            nx += dx[k], ny += dy[k];\n          }\n          if(cons >= 3) {\n            update = true;\n            nx = i, ny = j;\n            while(nx < B && ny < B) {\n              if(board[nx][ny] != board[i][j]) break;\n              checked[nx][ny] = 1;\n              nx += dx[k], ny += dy[k];\n            }\n          }\n        }\n      }\n    }\n    // printf(\"bonus = %lld, update = %d\\n\", bonus, update);\n    if(!update) break;\n\n    for(int i=0; i<B; i++) {\n      for(int j=0; j<B; j++) {\n        // empty or no change\n        if(board[i][j] == 0 || checked[i][j] == false) continue;\n\n        int col = board[i][j] - 1;\n        board[i][j] = 0;\n        ret += bonus * score[col];\n      }\n    }\n\n    // blockfall\n    for(int i=B-1; i>=0; i--) {\n      for(int j=0; j<B; j++) {\n        int row = i;\n        for(; row < B-1 && board[row+1][j] == 0; row++) {\n          swap(board[row][j], board[row+1][j]);\n        }\n      }\n    }\n  }\n  \n  return ret;\n}\n\nint main() {\n  while(cin >> N, N >= 0) {\n    vector2D board(B, vector<int>(B));\n    for(int i=0; i<B; i++) {\n      for(int j=0; j<B; j++) {\n        cin >> board[i][j];\n      }\n    }\n    score.clear();\n    for(int i=0; i<5; i++) {\n      int val; cin >> val;\n      score.push_back(val);\n    }\n\n    queue<State> que;\n    for(int i=0; i<B; i++) {\n      for(int j=0; j<B; j++) {\n        que.push(State{board, i, j});\n      }\n    }\n\n    // printf(\"enumerate begin\\n\");\n    for(int i=0; i<N; i++) {\n      queue<State> nxt;\n      while(que.size()) {\n        State cur = que.front(); que.pop();\n        vector2D board = cur.board;\n        int x = cur.x, y = cur.y;\n\n        for(int k=0; k<4; k++) {\n          int nx = x + dx[k], ny = y + dy[k];\n          if(nx < 0 || nx >= B || ny < 0 || ny >= B) continue;\n          swap(board[x][y], board[nx][ny]);\n          nxt.push(State{board, nx, ny});\n          swap(board[x][y], board[nx][ny]);\n        }\n      }\n      swap(nxt, que);\n    }\n    // printf(\"enumerate end\\n\");\n\n    set<vector2D> cand;\n    while(que.size()) {\n      cand.insert(que.front().board); que.pop();\n    }\n\n    long long int ans = 0;\n    for(auto b : cand) {\n      ans = max(ans, solve(b));\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector<int> Vec;\ntypedef vector<Vec> Mat;\n\nMat a(5, Vec(5));\nint score[5];\n\nconst int dx[] = {-1, +0, +1, +0};\nconst int dy[] = {+0, -1, +0, +1};\n\nbool inField(int x, int y)\n{\n    return (0 <= x && x < 5 && 0 <= y && y < 5);\n}\n\nint erase(Mat &m, int bp)\n{\n    bool e[5][5] = {{}};\n    for (int i = 0; i < 5; i++) {\n        for (int j = 0; j < 5; j++) {                        \n            if (m[i][j] == 0) {\n                continue;\n            }\n            int cnt[2] = {1, 1};\n            for (int k = 0; k < 4; k++) {\n                int ni = i + dy[k];\n                int nj = j + dx[k];\n                while (inField(ni, nj) &&\n                       m[i][j] == m[ni][nj]) {\n                    ni += dy[k];\n                    nj += dx[k];\n                    ++cnt[k&1];\n                }\n            }\n            if (cnt[0] >= 3 || cnt[1] >= 3) {\n                e[i][j] = 1;\n            }\n        }\n    }\n    int point = 0;\n    for (int i = 0; i < 5; i++) {\n        for (int j = 0; j < 5; j++) {\n            if (e[i][j]) {\n                point += score[m[i][j]-1] * bp;\n                m[i][j] = 0;\n            }\n        }\n    }\n    return point;\n}\n\nvoid fall(Mat &m)\n{\n    for (int j = 4; j >= 1; j--) {\n        for (int i = 4; i >= 1; i--) {\n            if (m[i][j] == 0) {                \n                for (int k = i-1; k >= 0; k--) {\n                    if (m[k][j] != 0) {\n                        swap(m[i][j], m[k][j]);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}\n\nint calc(Mat &m, int bp)\n{\n    int point = erase(m, bp);\n    fall(m);\n    return point;\n}\n\nint get_point()\n{\n    Mat b = a;\n    int point = 0, bp = 1;\n    bool update = 1;\n    \n    while (update) {\n        update = 0;        \n        Mat nb = b;\n        point += calc(nb, bp);\n        if (b != nb) {\n            update = 1;\n            bp++;\n            b = nb;\n        }\n    }\n    return point;\n}\n\nint dfs(int y, int x, int n)    \n{\n    int point = get_point();\n    if (n > 0) {\n        for (int i = 0; i < 4; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (inField(nx, ny)) {\n                swap(a[ny][nx], a[y][x]);\n                point = max(point, dfs(ny, nx, n-1));\n                swap(a[ny][nx], a[y][x]);\n            }        \n        }\n    }\n    return point;\n}\n\nint main()\n{\n    int n;\n    while (cin >> n, n != -1) {\n        for (int i = 0; i < 5; i++) {\n            for (int j = 0; j < 5; j++) {\n                cin >> a[i][j];\n            }\n        }\n    \n        for (int i = 0; i < 5; i++) {\n            cin >> score[i];\n        }\n\n        int max_point = 0;\n        for (int i = 0; i < 5; i++) {\n            for (int j = 0; j < 5; j++) {\n                max_point = max(max_point, dfs(i, j, n));\n            }\n        }   \n        cout << max_point << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EMPTY 0\n\nusing namespace std;\n\nconst int IINF = INT_MAX;\n\nint n,a[5][5],tmp[5][5],score[5],maxi;\nint dx[] = {0,1,0,-1}; // ???,???,?????????\nint dy[] = {1,0,-1,0};\nbool used[5][5];\n\ninline bool isValid(int x,int y) { return 0 <= x && x < 5 && 0 <= y && y < 5; }\n\nvoid update(){\n\n  rep(i,5) rep(j,5) tmp[i][j] = a[i][j];\n  int point = 0, phase = 0;\n  bool update = true;\n  while( update ){\n    ++phase;\n    update = false;\n    memset(used,false,sizeof(used));\n    rep(y,5){\n      rep(x,5){\n        if( used[y][x] || a[y][x] == EMPTY ) continue;\n        rep(i,2) {\n          int cnt = 0;\n          int cx = x, cy = y, color = a[cy][cx];\n          while( isValid(cx,cy) && a[cy][cx] == color ) {\n            ++cnt, cx += dx[i], cy += dy[i];\n          }\n          if( cnt >= 3 ) {\n            update = true;\n            cx = x, cy = y;\n            while( isValid(cx,cy) && a[cy][cx] == color ) {\n              used[cy][cx] = true;\n              ++cnt, cx += dx[i], cy += dy[i];\n            } \n          }\n        }\n      }\n    }\n    int sum = 0;\n    rep(y,5) rep(x,5) if( used[y][x] ) {\n      assert( 1 <= a[y][x] && a[y][x] <= 5 );\n      sum += score[a[y][x]-1] * phase;\n      a[y][x] = EMPTY;\n    }\n    point += sum;\n    rep(x,5){\n      for(int y=4;y>=0;y--) if( a[y][x] != EMPTY ) {\n          int cx = x + dx[0], cy = y + dy[0];\n          while( isValid(cx,cy) && a[cy][cx] == EMPTY ){\n            swap(a[cy][cx],a[cy+dy[2]][cx+dx[2]]);\n            cx += dx[0], cy += dy[0];\n          }          \n      }\n    }\n  }\n  maxi = max(maxi,point);\n  rep(i,5) rep(j,5) a[i][j] = tmp[i][j];\n}\n\nvoid dfs(int cx,int cy,int prev,int depth){\n  update();\n  if( depth >= n ) return;\n\n  rep(i,4) if( ( i + 2 ) % 4 != prev ) {\n    int nx = cx + dx[i], ny = cy + dy[i];\n    if( !isValid(nx,ny) ) continue;\n    swap(a[ny][nx],a[cy][cx]);\n    dfs(nx,ny,i,depth+1);\n    swap(a[ny][nx],a[cy][cx]);\n  }\n}\n\nvoid compute(){\n  maxi = -IINF;\n  rep(i,5) rep(j,5) dfs(j,i,-1,0);\n  cout << maxi << endl;\n}\n\nint main(){\n  while( cin >> n, n != -1 ){\n    rep(i,5) rep(j,5) cin >> a[i][j];\n    rep(i,5) cin >> score[i];\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nconst int n=5,dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\nint a[n][n],d[n],m,ans;\nbool check(int x,int y){return x>=0&&x<n&&y>=0&&y<n;}\n\nvoid solve() {\n  int b[n][n];\n  rep(i,n)rep(j,n)b[j][n-i-1]=a[i][j];\n  int c=1,e=0;\n  while(1) {\n    bool f=0,u[n][n];\n    memset(u,0,sizeof(u));\n    rep(i,n)rep(j,n) {\n      if(!b[i][j]) continue;\n      for(int k=2;k<4;k++) {\n        int x=i,y=j,z=b[i][j],t=1;\n        while(1) {\n          x+=dx[k],y+=dy[k];\n          if(!check(x,y)||z!=b[x][y])break;\n          t++;\n        }\n        if(t>=3) {\n          f=1,x=i,y=j,u[x][y]=1;\n          while(1) {\n            x+=dx[k],y+=dy[k];\n            if(!check(x,y)||z!=b[x][y])break;\n            u[x][y]=1;\n          }\n        }\n      }\n    }\n    if(!f) break;\n    rep(i,n){\n      rep(j,n){\n        if(!u[i][j])continue;\n        e+=d[b[i][j]-1]*c;\n        b[i][j]=0;\n      }\n      fill(remove(b[i],b[i]+n,0),b[i]+n,0);\n    }\n    c++;\n  }\n  ans=max(ans,e);\n}\n\nvoid dfs(int nx,int ny,int k) {\n  if(k>m) return;\n  solve();\n  rep(i,4){\n    int x=nx+dx[i],y=ny+dy[i];\n    if(!check(x,y)) continue;\n    swap(a[x][y],a[nx][ny]);\n    dfs(x,y,k+1);\n    swap(a[x][y],a[nx][ny]);\n  }\n}   \n\nint main() {\n  while(cin>>m&&m!=-1) {\n    rep(i,n)rep(j,n)cin>>a[i][j];\n    rep(i,n)cin>>d[i];\n    ans=0;\n    rep(i,n)rep(j,n)dfs(i,j,0);\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector<int> Vec;\ntypedef vector<Vec> Mat;\n\nMat a(5, Vec(5));\nint score[5];\n\nconst int dx[] = {-1, +0, +1, +0};\nconst int dy[] = {+0, -1, +0, +1};\n\nbool inField(int x, int y)\n{\n    return (0 <= x && x < 5 && 0 <= y && y < 5);\n}\n\nint erase(Mat &m)\n{\n    bool e[5][5] = {{}};\n    for (int i = 0; i < 5; i++) {\n        for (int j = 0; j < 5; j++) {                        \n            if (m[i][j] == 0) {\n                continue;\n            }\n            int cnt[2] = {1, 1};\n            for (int k = 0; k < 4; k++) {\n                int ni = i + dy[k];\n                int nj = j + dx[k];\n                while (inField(ni, nj) &&\n                       m[i][j] == m[ni][nj]) {\n                    ni += dy[k];\n                    nj += dx[k];\n                    ++cnt[k&1];\n                }\n            }\n            if (cnt[0] >= 3 || cnt[1] >= 3) {\n                e[i][j] = 1;\n            }\n        }\n    }\n    int point = 0;\n    for (int i = 0; i < 5; i++) {\n        for (int j = 0; j < 5; j++) {\n            if (e[i][j]) {\n                point += score[m[i][j]-1];\n                m[i][j] = 0;\n            }\n        }\n    }\n    return point;\n}\n\nvoid fall(Mat &m)\n{\n    for (int j = 0; j < 5; j++) {\n        for (int i = 4; i >= 1; i--) {\n            if (m[i][j] == 0) {                \n                for (int k = i-1; k >= 0; k--) {\n                    if (m[k][j] != 0) {\n                        swap(m[i][j], m[k][j]);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}\n\nint get_point()\n{\n    Mat b = a;\n    int point = 0, bp = 1;\n    bool update = 1;\n    \n    while (update) {\n        update = 0;        \n        Mat nb = b;\n        point += erase(nb) * bp++;\n        fall(nb);\n        if (nb != b) {        \n            update = 1;\n            b = nb;\n        }\n    }\n    return point;\n}\n\nint dfs(int y, int x, int n, int p)    \n{\n    int point = get_point();\n    if (n > 0) {\n        for (int i = 0; i < 4; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (inField(nx, ny) && (p == -1 || (p + 2) % 4 != i)) {\n                swap(a[ny][nx], a[y][x]);\n                point = max(point, dfs(ny, nx, n-1, i));\n                swap(a[ny][nx], a[y][x]);\n            }        \n        }\n    }\n    return point;\n}\n\nint main()\n{\n    int n;\n    while (cin >> n, n != -1) {\n        for (int i = 0; i < 5; i++) {\n            for (int j = 0; j < 5; j++) {\n                cin >> a[i][j];\n            }\n        }\n    \n        for (int i = 0; i < 5; i++) {\n            cin >> score[i];\n        }\n\n        int max_point = 0;\n        for (int i = 0; i < 5; i++) {\n            for (int j = 0; j < 5; j++) {\n                max_point = max(max_point, dfs(i, j, n, -1));\n            }\n        }   \n        cout << max_point << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\nint n,score[5],result,r0,bonus;\nvector <vector<int> > a(5,vector<int>(5)),check(5,vector<int>(5));\n\nbool in(int y,int x){\n  if(-1<y&&y<5 && -1<x&&x<5) return 1;\n  else return 0;\n}\n\nbool sc(){\n  vector <vector<int> > t0(5,vector<int>(5,0));\n  for(int i=0;i<5;i++){\n    int j=0;\n    for(;j<5;){\n      int pj=j;\n      for(;j+1<5&&check[i][j]==check[i][j+1];) j++;\n      if(j+1-pj>=3) for(;pj<=j;pj++) t0[i][pj]=1;\n      j++;\n    }\n  }\n  for(int j=0;j<5;j++){\n    int i=0;\n    for(;i<5;){\n      int pi=i;\n      for(;i+1<5&&check[i][j]==check[i+1][j];) i++;\n      if(i+1-pi>=3) for(;pi<=i;pi++) t0[pi][j]=1;\n      i++;\n    }\n  }\n  int flag=0;\n  for(int i=0;i<5;i++) for(int j=0;j<5;j++){\n      if(t0[i][j]&&check[i][j]){\n\tr0+=t0[i][j]*bonus*score[check[i][j]-1];\n\tcheck[i][j]=0,flag++;\n      }\n    }\n  \n  for(int j=0;j<5;j++){\n    int ni=5;\n    for(int i=4;i>-1;i--){\n      if(check[i][j]) check[--ni][j]=check[i][j];\n    }\n    for(int i=0;i<ni;i++) check[i][j]=0;\n  }\n  // cout<<r0<<endl;\n  \n  return flag;\n\n}\n\nvoid dfs(int sw,int y,int x,int d){\n\n  //  cout<<sw<<\" \"<<y<<\" \"<<x<<\" \"<<d<<endl;\n  \n  if(sw>n) return;\n  check=a;\n  r0=0;\n  bonus=1;\n  while(sc()) bonus++; \n  result=max(result,r0);\n  \n  for(int k=0;k<4;k++){\n    if(~d&&(d+2)%4==k) continue;\n    int ny=y+dy[k],nx=x+dx[k];\n    if(!in(ny,nx)) continue;\n\n    swap(a[y][x],a[ny][nx]);\n    dfs(sw+1,ny,nx,k);\n    swap(a[y][x],a[ny][nx]);\n  }\n  \n}\n\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n\n  for(;cin>>n;){\n    if(n==-1) break;\n    result=0;\n    for(int i=0;i<5;i++) for(int j=0;j<5;j++) cin>>a[i][j];\n    for(int i=0;i<5;i++) cin>>score[i];\n    \n    for(int i=0;i<5;i++) for(int j=0;j<5;j++) dfs(0,i,j,-1);\n    \n    cout<<result<<endl;\n  }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint cost[6];\nbool used[5][5], flag;\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\n\nbool can(int y,int x) {\n\tif(0 <= y && y < 5 && 0 <= x && x < 5) return true;\n\treturn false;\n}\n\nll del(vector<vector<int> > &v, ll bonus) {\n\tmemset(used, 0, sizeof(used));\n\trep(i, 5) {\n\t\trep(j, 5) {\n\t\t\tif(v[i][j] == 0) continue;\n\n\t\t\tint a = i;\n\t\t\twhile(a + 1 <= 4 && v[a+1][j] == v[i][j]) {\n\t\t\t\ta++;\n\t\t\t}\n\n\t\t\tint b = i;\n\t\t\twhile(b - 1 >= 0 && v[b-1][j] == v[i][j]) {\n\t\t\t\tb--;\n\t\t\t}\n\n\t\t\tint c = j;\n\t\t\twhile(c + 1 <= 4 && v[i][c+1] == v[i][j]) {\n\t\t\t\tc++;\n\t\t\t}\n\n\t\t\tint d = j;\n\t\t\twhile(d - 1 >= 0 && v[i][d-1] == v[i][j]) {\n\t\t\t\td--;\n\t\t\t}\n\n\t\t\tif(a - b + 1 >= 3 || c - d + 1 >= 3) used[i][j] = true;\n\t\t}\n\t}\n\n\tll ret = 0;\n\trep(i, 5) {\n\t\trep(j, 5) {\n\t\t\tif(used[i][j]) {\n\t\t\t\tret += bonus * cost[v[i][j]];\n\t\t\t\tflag = true;\n\t\t\t\tv[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nvoid mov(vector<vector<int> > &v) {\n\tfor(int i = 4; i >= 0; i--) {\n\t\trep(j, 5) {\n\t\t\tint y = i;\n\t\t\twhile(y + 1 <= 4 && v[y + 1][j] == 0) {\n\t\t\t\tswap(v[y][j], v[y+1][j]);\n\t\t\t\ty++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint n;\nll ans = 0;\n\nset<vector<vector<int> > > res;\n\nvoid dfs(int cnt, int y, int x, vector<vector<int> > v) {\n\tres.insert(v);\n\n\tif(cnt == n) {\n\t\treturn;\n\t}\n\n\trep(i, 4) {\n\t\tint ny = y + dy[i];\n\t\tint nx = x + dx[i];\n\n\t\tif(can(ny, nx)) {\n\t\t\tswap(v[y][x], v[ny][nx]);\n\t\t\tdfs(cnt + 1, ny, nx, v);\n\t\t\tswap(v[y][x], v[ny][nx]);\n\t\t}\n\t}\n}\n\nint main() {\n\twhile(cin >> n && n != -1) {\n\t\tans = 0;\n\t\tres.clear();\n\n\t\tvector<vector<int> > v(5, vector<int>(5));\n\t\trep(i, 5) rep(j, 5) cin >> v[i][j];\n\t\trep(i, 5) cin >> cost[i+1];\n\n\t\trep(i, 5) {\n\t\t\trep(j, 5) {\n\t\t\t\tdfs(0, i, j, v);\n\t\t\t}\n\t\t}\n\n\t\tset<vector<vector<int> > >::iterator ite;\n\t\tfor(ite = res.begin(); ite != res.end(); ite++) {\n\n\t\t\tll bonus = 1, sum = 0;\n\t\t\tvector<vector<int> > t = *ite;\n\n\t\t\twhile(true) {\n\t\t\t\tflag = false;\n\t\t\t\tsum += del(t, bonus);\n\n\t\t\t\tif(flag) {\n\t\t\t\t\tmov(t);\n\t\t\t\t\tbonus++;\n\n\t\t\t\t} else break;\n\t\t\t}\n\n\t\t\t// cout << \"----- : \" << sum << endl;\n\t\t\t// rep(i, 5) {\n\t\t\t// \trep(j, 5) {\n\t\t\t// \t\tcout << t[i][j] << \" \";\n\t\t\t// \t}\n\t\t\t// \tcout << endl;\n\t\t\t// }\n\t\t\tans = max(ans, sum);\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <set>\n#include <iostream>\n#include <cstdio>\n#include <queue>\nusing namespace std;\n\nusing vector2D = vector< vector<int> >;\nconst int B = 5;\nint N;\n\nint dx[] = {1, -1, 0, 0};\nint dy[] = {0, 0, 1, -1};\n\nstruct State {\n  vector2D board;\n  int x, y;\n};\n\nvector<int> score;\nlong long int solve(vector2D board) {\n  long long int ret = 0, bonus = 1;\n  for(; ; bonus++) {\n    bool update = false;\n    vector2D checked(B, vector<int>(B));\n    \n    for(int i=0; i<B; i++) {\n      for(int j=0; j<B; j++) {\n        // empty\n        if(board[i][j] == 0) continue;\n\n        vector<int> dirs = {2, 0};\n        for(auto k : dirs) {\n          // right or down\n          int cons = 0;\n          int nx = i, ny = j;\n          while(nx < B && ny < B) {\n            if(board[nx][ny] != board[i][j]) break;\n            cons++;\n            nx += dx[k], ny += dy[k];\n          }\n          if(cons >= 3) {\n            update = true;\n            nx = i, ny = j;\n            while(nx < B && ny < B) {\n              if(board[nx][ny] != board[i][j]) break;\n              checked[nx][ny] = 1;\n              nx += dx[k], ny += dy[k];\n            }\n          }\n        }\n      }\n    }\n    // printf(\"bonus = %lld, update = %d\\n\", bonus, update);\n    if(!update) break;\n\n    for(int i=0; i<B; i++) {\n      for(int j=0; j<B; j++) {\n        // empty or no change\n        if(board[i][j] == 0 || checked[i][j] == false) continue;\n\n        int col = board[i][j] - 1;\n        board[i][j] = 0;\n        ret += bonus * score[col];\n      }\n    }\n\n    // blockfall\n    for(int i=B-1; i>=0; i--) {\n      for(int j=0; j<B; j++) {\n        int row = i;\n        for(; row < B-1 && board[row+1][j] == 0; row++) {\n          swap(board[row][j], board[row+1][j]);\n        }\n      }\n    }\n  }\n  \n  return ret;\n}\n\nint main() {\n  while(cin >> N, N >= 0) {\n    vector2D board(B, vector<int>(B));\n    for(int i=0; i<B; i++) {\n      for(int j=0; j<B; j++) {\n        cin >> board[i][j];\n      }\n    }\n    score.clear();\n    for(int i=0; i<B; i++) {\n      int val; cin >> val;\n      score.push_back(val);\n    }\n\n    set<vector2D> cand;\n    cand.insert(board);\n    queue<State> que;\n    for(int i=0; i<B; i++) {\n      for(int j=0; j<B; j++) {\n        que.push(State{board, i, j});\n      }\n    }\n\n    // printf(\"enumerate begin\\n\");\n    for(int i=0; i<N; i++) {\n      queue<State> nxt;\n      while(que.size()) {\n        State cur = que.front(); que.pop();\n        vector2D board = cur.board;\n        int x = cur.x, y = cur.y;\n\n        for(int k=0; k<4; k++) {\n          int nx = x + dx[k], ny = y + dy[k];\n          if(nx < 0 || nx >= B || ny < 0 || ny >= B) continue;\n          swap(board[x][y], board[nx][ny]);\n          nxt.push(State{board, nx, ny});\n          cand.insert(board);\n          swap(board[x][y], board[nx][ny]);\n        }\n      }\n      swap(nxt, que);\n    }\n    // printf(\"enumerate end\\n\");\n\n    long long int ans = 0;\n    for(auto b : cand) {\n      ans = max(ans, solve(b));\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<int, bool>P;\n\nint s[5], dx[]{ 1,-1,0,0, }, dy[]{ 0,0,1,-1 };\nvector<vector<int> >a(5, vector<int>(5));\nint Max;\nvoid dfs(int x, int y, int c) {\n\tif (c == 0) {\n\t\tvector<vector<P> >b(5, vector<P>(5));\n\t\trep(i, 5)rep(j, 5)b[i][j].first = a[i][j];\n\t\tbool update = true;\n\t\tint p = 0;\n\t\tfor (int v = 1; update; v++) {\n\t\t\tupdate = false;\n\t\t\trep(i, 5) {\n\t\t\t\tint back = 0, cnt = 0;\n\t\t\t\trep(j, b[i].size()) {\n\t\t\t\t\tif (back != b[i][j].first) {\n\t\t\t\t\t\tif (cnt >= 3) {\n\t\t\t\t\t\t\tfor (int k = 1; k <= cnt; k++)\n\t\t\t\t\t\t\t\tb[i][j - k].second = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcnt = 0;\n\t\t\t\t\t}\n\t\t\t\t\tback = b[i][j].first; cnt++;\n\t\t\t\t}\n\t\t\t\tif (cnt >= 3) {\n\t\t\t\t\tfor (int k = 1; k <= cnt; k++)\n\t\t\t\t\t\tb[i][b[i].size() - k].second = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i, 5) {\n\t\t\t\tint back = 0, cnt = 0;\n\t\t\t\trep(j, 5) {\n\t\t\t\t\tif (b[j].size() <= i || back != b[j][i].first) {\n\t\t\t\t\t\tif (cnt >= 3) {\n\t\t\t\t\t\t\tfor (int k = 1; k <= cnt; k++)\n\t\t\t\t\t\t\t\tb[j - k][i].second = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcnt = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (i < b[j].size()) {\n\t\t\t\t\t\tback = b[j][i].first; cnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (cnt >= 3) {\n\t\t\t\t\tfor (int k = 1; k <= cnt; k++)b[5 - k][i].second = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i, 5)rep(j, b[i].size()) {\n\t\t\t\tif (b[i][j].second == 1) {\n\t\t\t\t\tp += v*s[b[i][j].first];\n\t\t\t\t\tb[i].erase(b[i].begin() + j); update = true; j--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tMax = max(Max, p);\n\t\treturn;\n\t}\n\trep(i, 4) {\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tif (0 <= nx&&nx < 5 && 0 <= ny&&ny < 5) {\n\t\t\tswap(a[x][y], a[nx][ny]);\n\t\t\tdfs(nx, ny, c - 1);\n\t\t\tswap(a[x][y], a[nx][ny]);\n\t\t}\n\t}\n}\nint main() {\n\tint n;\n\twhile (scanf(\"%d\", &n), ~n) {\n\t\tMax = 0;\n\t\trep(i, 5)rep(j, 5)scanf(\"%d\", &a[j][i]), a[j][i]--;\n\t\trep(i, 5)reverse(a[i].begin(), a[i].end());\n\t\trep(i, 5)scanf(\"%d\", &s[i]);\n\t\trep(i, 5)rep(j, 5)dfs(i, j, n);\n\t\tprintf(\"%d\\n\", Max);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n\nint N;\nint field[6][6];\nint ss[6];\n\nll calc(){\n  ll sum=0;\n  int nowField[6][6]={};\n  for(int i=0;i<5;i++)\n    for(int j=0;j<5;j++)\n      nowField[i][j]=field[i][j];\n  int bonus=1;\n  while(1){\n    bool isDel=false;\n    int nxtField[5][5]={};\n    // 現在のfieldにならんでいるものをすべて消す\n    for(int i=0;i<5;i++){\n      for(int j=0;j<5;j++){\n        if(nowField[i][j]==-1)continue;\n        // 横\n        {\n          int now=nowField[i][j];\n          int cnt=0;\n          for(int k=j;k<5;k++){\n            if(now==nowField[i][k])cnt++;\n            else break;\n          }\n          if(cnt>=3){\n            isDel=true;\n            for(int k=j;k<5;k++){\n              if(now==nowField[i][k])nxtField[i][k]=-1;\n              else break;\n            }\n          }\n        }\n        // 縦\n        {\n          int now=nowField[i][j];\n          int cnt=0;\n          for(int k=i;k<5;k++){\n            if(now==nowField[k][j])cnt++;\n            else break;\n          }\n          if(cnt>=3){\n            isDel=true;\n            for(int k=i;k<5;k++){\n              if(now==nowField[k][j])nxtField[k][j]=-1;\n              else break;\n            }\n          }\n        }\n      }\n    }\n    for(int i=0;i<5;i++)\n      for(int j=0;j<5;j++)\n        if(nxtField[i][j]==-1)\n          sum+=ss[nowField[i][j]]*bonus;\n    for(int i=0;i<5;i++)\n      for(int j=0;j<5;j++)\n        if(nxtField[i][j]==-1)\n          nowField[i][j]=-1;\n    memset(nxtField,-1,sizeof(nxtField));\n    // 消した後、落とす動作を行う\n    for(int j=0;j<5;j++){\n      int lis[5];\n      memset(lis,-1,sizeof(lis));\n      int cnt=0;\n      for(int i=4;i>=0;i--)\n        if(nowField[i][j]!=-1)\n          lis[cnt++]=nowField[i][j];\n      for(int i=0;i<cnt;i++)\n        nxtField[4-i][j]=lis[i];\n    }\n    for(int i=0;i<5;i++)\n      for(int j=0;j<5;j++)\n        nowField[i][j]=nxtField[i][j];\n    if(!isDel)break;\n    bonus++;\n  }\n  return sum;\n}\n\nvoid dfs(int depth,int cy,int cx,ll &res){\n  if(depth==N)res=max(res,calc());\n  else{\n    const int dy[]={-1,0,0,1};\n    const int dx[]={0,-1,1,0};\n    for(int i=0;i<4;i++){\n      int ny=dy[i]+cy;\n      int nx=dx[i]+cx;\n      if(ny>=0&&nx>=0&&ny<5&&nx<5){\n        swap(field[ny][nx],field[cy][cx]);\n        dfs(depth+1,ny,nx,res);\n        swap(field[ny][nx],field[cy][cx]);\n      }\n    }\n  }\n}\n\nint main(){\n\n  while(cin>>N&&N!=-1){\n    for(int i=0;i<5;i++)\n      for(int j=0;j<5;j++)\n        cin>>field[i][j],field[i][j]--;\n    for(int i=0;i<5;i++)\n      cin>>ss[i];\n    ll res=0;\n    for(int i=0;i<5;i++)\n      for(int j=0;j<5;j++)\n        dfs(0,i,j,res);\n    cout<<res<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <iterator>\n#include <bitset>\n#include <random>\n#include <assert.h>\n#include <unordered_map>\n#include <array>\n#include <ctime>\n\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define X first\n#define Y second\n#define MP make_pair\n#define umap unordered_map\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> P;\ntypedef unsigned int uint;\n\nconst int N = 5;\n\nint score[N];\n\npair<int, vector<vector<int>>> check(vector<vector<int>> v){\n\tauto nxt = v;\n\trep(i, N) rep(j, N){\n\t\tint c = v[i][j];\n\t\tif (0 < i && i < N - 1 && v[i - 1][j] == c && c == v[i + 1][j]){\n\t\t\tfor (int k = -1; k <= 1; ++k) nxt[i + k][j] = 0;\n\t\t}\n\t\tif (0 < j && j < N - 1 && v[i][j - 1] == c && c == v[i][j + 1]){\n\t\t\tfor (int k = -1; k <= 1; ++k) nxt[i][j + k] = 0;\n\t\t}\n\t}\n\tint cnt = 0;\n\trep(i, N) rep(j, N) if (!nxt[i][j] && v[i][j]) cnt += score[v[i][j]-1];\n\n\treturn MP(cnt, nxt);\n}\n\nvoid down(vector<vector<int>> &v){\n\tfor (int i = N - 2; i >= 0; --i) rep(j, N){\n\t\tint k = i;\n\t\twhile (++k < N) if (!v[k][j]) swap(v[k][j], v[k - 1][j]);\n\t}\n}\n\nint simulate(vector<vector<int>> v){\n\tint res = 0, bonus = 1, x;\n\trep(i, 8){\n\t\ttie(x, v) = check(v);\n\t\tres += bonus++*x;\n\t\tdown(v);\n\t}\n\treturn res;\n}\n\nint dx[] = { 0, 1, 0, -1 };\nint dy[] = { 1, 0, -1, 0 };\nint dfs(int i, int j, int n, vector<vector<int>> &v){\n\tint res = simulate(v);\n\tif (n == 0) return res;\n\trep(d, 4){\n\t\tint ni = i + dx[d], nj = j + dy[d];\n\t\tif (ni < 0 || ni >= N || nj < 0 || nj >= N) continue;\n\t\tswap(v[i][j], v[ni][nj]);\n\t\tres = max(res, dfs(ni, nj, n - 1, v));\n\t\tswap(v[i][j], v[ni][nj]);\n\t}\n\treturn res;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\n\tauto v = vector<vector<int>>(N, vector<int>(N));\n\n\tint n;\n\twhile (cin >> n, ~n){\n\t\trep(i, N) rep(j, N) cin >> v[i][j];\n\t\trep(i, N) cin >> score[i];\n\t\tint ans = 0;\n\t\trep(i, N) rep(j, N) ans = max(ans, dfs(i, j, n, v));\n\t\tcout << ans << endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint b[6][6];\nint c[6];\nint n;\nint t[6][6];\nint v[6][6];\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint f[6][6];\nint calc(){\n\tint ret=0;\n\tint s=1;\n\tfor(int i=0;i<5;i++)for(int j=0;j<5;j++)v[i][j]=t[i][j];\n\tbool chg=false;\n\tdo{\n\t\tchg=false;\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<5;j++)f[i][j]=0;\n\t\tfor(int i=0;i<5;i++){\n\t\t\tint now=0;\n\t\t\tint val=-1;\n\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\tif(val!=v[i][j]){\n\t\t\t\t\tif(now>=3&&val){\n\t\t\t\t\t\tchg=true;\n\t\t\t\t\t\tfor(int k=j-now;k<j;k++)f[i][k]=1;\n\t\t\t\t\t}\n\t\t\t\t\tnow=1;val=v[i][j];\n\t\t\t\t}else now++;\n\t\t\t}\n\t\t\tif(now>=3&&val){\n\t\t\t\tchg=true;\n\t\t\t\tfor(int k=5-now;k<5;k++)f[i][k]=1;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<5;i++){\n\t\t\tint now=0;\n\t\t\tint val=-1;\n\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\tif(val!=v[j][i]){\n\t\t\t\t\tif(now>=3&&val){\n\t\t\t\t\t\tchg=true;\n\t\t\t\t\t\tfor(int k=j-now;k<j;k++)f[k][i]=1;\n\t\t\t\t\t}\n\t\t\t\t\tnow=1;val=v[j][i];\n\t\t\t\t}else now++;\n\t\t\t}\n\t\t\tif(now>=3&&val){\n\t\t\t\tchg=true;\n\t\t\t\tfor(int k=5-now;k<5;k++)f[k][i]=1;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<5;j++){\n\t\t\tif(f[i][j]){ret+=s*c[v[i][j]];v[i][j]=0;}\n\t\t}\n\t\tfor(int i=0;i<5;i++){\n\t\t\tint at=4;\n\t\t\tfor(int j=4;j>=0;j--){\n\t\t\t\tif(v[j][i])v[at--][i]=v[j][i];\n\t\t\t}\n\t\t\tfor(int j=0;j<=at;j++)v[j][i]=0;\n\t\t}\n\t//\tfor(int i=0;i<5;i++){\n\t//\t\tfor(int j=0;j<5;j++)printf(\"%d \",v[i][j]);printf(\"\\n\");\n\t//\t}\n\t\ts++;\n\t}while(chg);\n\treturn ret;\n}\nint solve(int a,int b,int c){\n\tif(c==n){\n\t\treturn calc();\n\t}\n\tint ret=0;\n\tfor(int i=0;i<4;i++){\n\t\tif(0<=a+dx[i]&&a+dx[i]<5&&0<=b+dy[i]&&b+dy[i]<5){\n\t\t\tswap(t[a][b],t[a+dx[i]][b+dy[i]]);\n\t\t\tret=max(ret,solve(a+dx[i],b+dy[i],c+1));\n\t\t\tswap(t[a][b],t[a+dx[i]][b+dy[i]]);\n\t\t}\n\t}\n\treturn ret;\n}\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),~a){\n\t\tn=a;\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<5;j++)scanf(\"%d\",&b[i][j]);\n\t\tfor(int i=0;i<5;i++)scanf(\"%d\",c+i+1);\n\t\tint ret=0;\n\t\tfor(int i=0;i<5;i++){\n\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\tfor(int k=0;k<5;k++)for(int l=0;l<5;l++){\n\t\t\t\t\tt[k][l]=b[k][l];\n\t\t\t\t}\n\t\t\t\tret=max(ret,solve(i,j,0));\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define double long double\nusing namespace std;\nconst int N = 100010;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\nostream& operator<<(ostream& o,P p){\n  return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\ntemplate<class T> istream& operator>>(istream& i,vector<T> &a){for(auto &t:a)cin>>t;return i;}\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\ntemplate<class T> void prArr(T a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\n\nint dx[] = {0,0,1,-1};\nint dy[] = {1,-1,0,0};\nvector<int> score;\n\nint calcScore(const vector<vector<int> > &mp, int bonus){\n  \n  auto okw=[&](int i,int j){\n    if(j + 2 >= 5) return false;\n    if(mp[i][j] == -1) return false;\n    return mp[i][j] == mp[i][j+1] && mp[i][j] == mp[i][j+2];\n  };\n  \n  auto okh=[&](int i,int j){\n    if(i + 2 >= 5) return false;\n    if(mp[i][j] == -1) return false;\n    return mp[i][j] == mp[i+1][j] && mp[i][j] == mp[i+2][j];\n  };\n  \n  int flag = 0;\n  vector<vector<int> > res = mp;\n  for(int i=0;i<5;i++)\n    for(int j=0;j<5;j++){\n      if(okw(i,j)) res[i][j] = res[i][j+1] = res[i][j+2] = -2;\n      if(okh(i,j)) res[i][j] = res[i+1][j] = res[i+2][j] = -2;\n    }\n  \n  int block = 0;\n  for(int i=0;i<5;i++)\n    for(int j=0;j<5;j++)\n      if(res[i][j] == -2){\n\tassert(mp[i][j] >= 0);\n\tflag = 1;\n\tres[i][j] = -1;\n\tblock += score[mp[i][j] - 1];\n      }\n  \n  for(int j=0;j<5;j++)\n    for(int k=0;k<5;k++)\n      for(int i = 0; i < 5-1; i++)\n\tif(res[i][j] == -1) swap(res[i][j],res[i+1][j]);\n\n  int ans = bonus * block;\n  // if(bonus == 2) cout<<\"2=\"<<ans<<endl;\n  if(flag) ans += calcScore(res,bonus+1);\n  return ans;\n}\n\nint dfs(int i,int j,int n,vector<vector<int> > mp){\n  \n  \n  if(n == 0) return calcScore(mp,1);\n  \n\n  int res = calcScore(mp,1);\n  for(int k=0;k<4;k++){\n    int ni = i + dy[k];\n    int nj = j + dx[k];\n    if(ni < 0 || nj < 0 || ni >= 5 || nj >= 5) continue;\n    swap(mp[i][j], mp[ni][nj]);\n    res = max(res,dfs(ni,nj,n-1,mp));\n    swap(mp[i][j], mp[ni][nj]);\n  }\n  return res;\n}\n\nsigned main(){\n  while(1){\n    int n;\n    cin>>n;\n    if(n == -1) break;\n    vector<vector<int> > A(5,vector<int>(5));\n    for(int i=0;i<5;i++)\n      for(int j=0;j<5;j++) cin>>A[4-i][j];\n\n    score.clear();\n    score.resize(5);\n    for(int i=0;i<5;i++) cin>>score[i];\n    \n    int ans = -INF;\n    for(int i=0;i<5;i++)\n      for(int j=0;j<5;j++) Max(ans,dfs(i,j,n,A));\n    \n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmax(T& a, T b) { if(b > a) a = b; }\n\nconst int EMPTY = 5;\n\nconst int dx[4] = {0, 0, -1, 1};\nconst int dy[4] = {-1, 1, 0, 0};\n\nint n;\nint field[5][5];\nint score[6];\n\nint calc() {\n\tint res = 0;\n\tvector<vector<int> > cur(5, vector<int>(5));\n\tfor(int i = 0; i < 5; ++i)\n\t\tfor(int j = 0; j < 5; ++j)\n\t\t\tcur[i][j] = field[i][j];\n\n\tfor(int bonus = 1;; ++bonus) {\n\t\tbool end = true;\n\t\tvector<vector<int> > next(cur);\n\n\t\tfor(int i = 0; i < 5; ++i)\n\t\t\tfor(int j = 1; j <= 3; ++j) if(cur[i][j] != EMPTY)\n\t\t\t\tif(cur[i][j - 1] == cur[i][j] && cur[i][j + 1] == cur[i][j]) {\n\t\t\t\t\tnext[i][j - 1] = next[i][j] = next[i][j + 1] = EMPTY;\n\t\t\t\t\tend = false;\n\t\t\t\t}\n\n\t\tfor(int i = 1; i <= 3; ++i)\n\t\t\tfor(int j = 0; j < 5; ++j) if(cur[i][j] != EMPTY)\n\t\t\t\tif(cur[i - 1][j] == cur[i][j] && cur[i + 1][j] == cur[i][j]) {\n\t\t\t\t\tnext[i - 1][j] = next[i][j] = next[i + 1][j] = EMPTY;\n\t\t\t\t\tend = false;\n\t\t\t\t}\n\n\t\tfor(int i = 0; i < 5; ++i)\n\t\t\tfor(int j = 0; j < 5; ++j)\n\t\t\t\tif(next[i][j] == EMPTY)\n\t\t\t\t\tres += score[cur[i][j]] * bonus;\n\n\t\tfor(int i = 1; i < 5; ++i)\n\t\t\tfor(int j = 0; j < 5; ++j)\n\t\t\t\tif(next[i][j] == EMPTY)\n\t\t\t\t\tfor(int k = i; k >= 1 && next[k - 1][j] != EMPTY; --k)\n\t\t\t\t\t\tswap(next[k][j], next[k - 1][j]);\n\n\t\tif(end)\n\t\t\treturn res;\n\n\t\tcur.swap(next);\n\t}\n}\n\nint move(int y, int x, int cnt = 0) {\n\tif(cnt == n)\n\t\treturn calc();\n\n\tint res = calc();\n\tfor(int i = 0; i < 4; ++i) {\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\n\t\tif(nx < 0 || ny < 0 || nx >= 5 || ny >= 5)\n\t\t\tcontinue;\n\n\t\tswap(field[y][x], field[ny][nx]);\n\t\tchmax(res, move(ny, nx, cnt + 1));\n\t\tswap(field[y][x], field[ny][nx]);\n\t}\n\n\treturn res;\n}\n\nint main() {\n\tcin.tie(false);\n\tios::sync_with_stdio(false);\n\n\tfor(; cin >> n, n >= 0;) {\n\t\tfor(int i = 0; i < 5; ++i) {\n\t\t\tfor(int j = 0; j < 5; ++j) {\n\t\t\t\tcin >> field[i][j];\n\t\t\t\t--field[i][j];\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < 5; ++i)\n\t\t\tcin >> score[i];\n\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < 5; ++i)\n\t\t\tfor(int j = 0; j < 5; ++j)\n\t\t\t\tchmax(ans, move(i, j));\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<int, bool>P;\n\nint s[5], dx[]{ 1,-1,0,0, }, dy[]{ 0,0,1,-1 };\nvector<vector<int>>a(5, vector<int>(5));\nint Max;\nvoid dfs(int x, int y, int c) {\n\tif (c == 0) {\n\t\tvector<vector<P>>b(5, vector<P>(5));\n\t\trep(i, 5)rep(j, 5)b[i][j].first = a[i][j];\n\t\tbool update = true;\n\t\tint p = 0;\n\t\tfor (int v = 1; update; v++) {\n\t\t\tupdate = false;\n\t\t\trep(i, 5) {\n\t\t\t\tint back = 0, cnt = 0;\n\t\t\t\trep(j, b[i].size()) {\n\t\t\t\t\tif (back != b[i][j].first) {\n\t\t\t\t\t\tif (cnt >= 3) {\n\t\t\t\t\t\t\tfor (int k = 1; k <= cnt; k++)\n\t\t\t\t\t\t\t\tb[i][j - k].second = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcnt = 0;\n\t\t\t\t\t}\n\t\t\t\t\tback = b[i][j].first; cnt++;\n\t\t\t\t}\n\t\t\t\tif (cnt >= 3) {\n\t\t\t\t\tfor (int k = 1; k <= cnt; k++)\n\t\t\t\t\t\tb[i][b[i].size() - k].second = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i, 5) {\n\t\t\t\tint back = 0, cnt = 0;\n\t\t\t\trep(j, 5) {\n\t\t\t\t\tif (b[j].size() <= i || back != b[j][i].first) {\n\t\t\t\t\t\tif (cnt >= 3) {\n\t\t\t\t\t\t\tfor (int k = 1; k <= cnt; k++)\n\t\t\t\t\t\t\t\tb[j - k][i].second = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcnt = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (i < b[j].size()) {\n\t\t\t\t\t\tback = b[j][i].first; cnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (cnt >= 3) {\n\t\t\t\t\tfor (int k = 1; k <= cnt; k++)b[5 - k][i].second = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i, 5)rep(j, b[i].size()) {\n\t\t\t\tif (b[i][j].second == 1) {\n\t\t\t\t\tp += v*s[b[i][j].first];\n\t\t\t\t\tb[i].erase(b[i].begin() + j); update = true; j--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tMax = max(Max, p);\n\t\treturn;\n\t}\n\trep(i, 4) {\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tif (0 <= nx&&nx < 5 && 0 <= ny&&ny < 5) {\n\t\t\tswap(a[x][y], a[nx][ny]);\n\t\t\tdfs(nx, ny, c - 1);\n\t\t\tswap(a[x][y], a[nx][ny]);\n\t\t}\n\t}\n}\nint main() {\n\tint n;\n\twhile (scanf(\"%d\", &n), ~n) {\n\t\tMax = 0;\n\t\trep(i, 5)rep(j, 5)scanf(\"%d\", &a[j][i]), a[j][i]--;\n\t\trep(i, 5)reverse(a[i].begin(), a[i].end());\n\t\trep(i, 5)scanf(\"%d\", &s[i]);\n\t\trep(i, 5)rep(j, 5) {\n\t\t\tdfs(i, j, n);\n\t\t}\n\t\tprintf(\"%d\\n\", Max);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstruct State { int x[5][5]; };\nint n, b[6];\npair<State, int>del(State S) {\n\tbool used[5][5]; for (int i = 0; i < 25; i++)used[i / 5][i % 5] = false;\n\tfor (int i = 0; i < 5; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tif (S.x[i][j] == S.x[i][j + 1] && S.x[i][j] == S.x[i][j + 2] && S.x[i][j] >= 1) {\n\t\t\t\tfor (int k = j; k < j + 3; k++)used[i][k] = true;\n\t\t\t}\n\t\t\tif (S.x[j][i] == S.x[j + 1][i] && S.x[j][i] == S.x[j + 2][i] && S.x[j][i] >= 1) {\n\t\t\t\tfor (int k = j; k < j + 3; k++)used[k][i] = true;\n\t\t\t}\n\t\t}\n\t}\n\tint cnt = 0, u = 0;\n\tfor (int i = 0; i < 5; i++) {\n\t\tfor (int j = 0; j < 5; j++) { if (used[i][j] == true) { cnt += b[S.x[i][j]]; S.x[i][j] = 0; u++; } }\n\t}\n\tif (u == 0)cnt = -1;\n\tfor (int i = 0; i < 5; i++) {\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tfor (int k = 0; k < 5; k++) {\n\t\t\t\tif (S.x[j][k] >= 1 && S.x[j + 1][k] == 0)swap(S.x[j][k], S.x[j + 1][k]);\n\t\t\t}\n\t\t}\n\t}\n\treturn make_pair(S, cnt);\n}\nint dfs(State S, int depth, int cx, int cy) {\n\tif (depth == n) {\n\t\tint d = 1, c = 0;\n\t\twhile (true) {\n\t\t\tpair<State, int>G = del(S);\n\t\t\tif (G.second == -1)return c;\n\t\t\tc += d*G.second; S = G.first; d++;\n\t\t}\n\t}\n\tint dx[4] = { 1,0,-1,0 }, dy[4] = { 0,1,0,-1 }, maxn = 0;\n\tfor (int i = 0; i < 4; i++) {\n\t\tint ex = cx + dx[i], ey = cy + dy[i];\n\t\tif (ex < 0 || ex >= 5 || ey < 0 || ey >= 5)continue;\n\t\tState T = S; swap(T.x[ex][ey], T.x[cx][cy]);\n\t\tmaxn = max(maxn, dfs(T, depth + 1, ex, ey));\n\t}\n\treturn maxn;\n}\nint main() {\n\twhile (true) {\n\t\tcin >> n; if (n == -1)break; State V;\n\t\tfor (int i = 0; i < 25; i++)cin >> V.x[i / 5][i % 5];\n\t\tfor (int i = 1; i <= 5; i++)cin >> b[i];\n\t\tint ret = 0; for (int i = 0; i < 25; i++) { for (int j = 0; j <= n; j++)ret = max(ret, dfs(V, j, i / 5, i % 5)); }\n\t\tcout << ret << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,-1,0,1};\ntemplate<class T> constexpr bool in_range(T y, T x, T H, T W) { return 0<=y&&y<H&&0<=x&&x<W; }\n\nint N;\nint score[6];\n\nvoid drop(vector<vector<int>>& a) {\n  rep(j, 5) {\n    deque<int> d;\n    rep(i, 5) {\n      if(a[i][j] != -1) {\n        d.push_back(a[i][j]);\n      }\n    }\n\n    int dsize = d.size();\n    for(int i=4; i>=0 && !d.empty(); i--) {\n      a[i][j] = d.back();\n      d.pop_back();\n    }\n    rep(i, 5-dsize) {\n      a[i][j] = -1;\n    }\n  }\n}\n\nint dist(vector<vector<int>> const& a, int num, int i, int j, int dy, int dx, int sum = 0) {\n  i += dy, j += dx;\n  if(!in_range(i, j, 5, 5)) return sum;\n  if(a[i][j] != num) return sum;\n  return dist(a, num, i, j, dy, dx, sum + 1);\n}\n\nint simulate(vector<vector<int>>& a) {\n  int ret = 0;\n  int bonus = 1;\n\n  while(1) {\n    set<int> used;\n    rep(i, 5) rep(j, 5) {\n      if(a[i][j] == -1) continue;\n      int movel = dist(a, a[i][j], i, j, 0, -1);\n      int mover = dist(a, a[i][j], i, j, 0, +1);\n      int movet = dist(a, a[i][j], i, j, -1, 0);\n      int moveb = dist(a, a[i][j], i, j, +1, 0);\n      if(mover - movel + 1 >= 3) {\n        REP(x, j - movel, j + mover + 1) {\n          assert(a[i][x] != -1);\n          assert(a[i][x] == a[i][j]);\n          used.insert(i*5+x);\n        }\n      }\n      if(moveb - movet + 1 >= 3) {\n        REP(y, i - movet, i + moveb + 1) {\n          assert(a[y][j] != -1);\n          assert(a[y][j] == a[i][j]);\n          used.insert(y*5+j);\n        }\n      }\n    }\n\n    for(auto && e: used) {\n      ret += score[a[e/5][e%5]] * bonus;\n      a[e/5][e%5] = -1;\n    }\n\n    bonus ++;\n    if(!used.size()) break;\n    drop(a);\n  }\n\n  return ret;\n}\n\n\n\nint dfs(vector<vector<int>> a, int y, int x, int idx = 0) {\n  auto aa = a;\n  int ret = simulate(a);\n  if(idx < N) {\n    rep(k, 4) {\n      int ny = y + dy[k], nx = x + dx[k];\n      if(!in_range(ny, nx, 5, 5)) continue;\n      a = aa;\n      swap(a[y][x], a[ny][nx]);\n      maximize(ret, dfs(a, ny, nx, idx + 1));\n    }\n  }\n  return ret;\n}\n\nint solve(vector<vector<int>>& a) {\n  int ret = 0;\n  rep(i, 5) rep(j, 5)  {\n    maximize(ret, dfs(a, i, j));\n  }\n  return ret;\n}\n\nint main() {\n\n  for(; cin >> N && N >= 0;) {\n    vector<vector<int>> a(5, vector<int>(5));\n    rep(i, 5) rep(j, 5) cin >> a[i][j];\n    rep(i, 5) cin >> score[i+1];\n    cout << solve(a) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector<int> Vec;\ntypedef vector<Vec> Mat;\n\nMat a(5, Vec(5));\nint score[5];\n\nconst int dx[] = {-1, +0, +1, +0};\nconst int dy[] = {+0, -1, +0, +1};\n\nbool inField(int x, int y)\n{\n    return (0 <= x && x < 5 && 0 <= y && y < 5);\n}\n\nint erase(Mat &m, int bp)\n{\n    bool e[5][5] = {{}};\n    for (int i = 0; i < 5; i++) {\n        for (int j = 0; j < 5; j++) {                        \n            if (m[i][j] == 0) {\n                continue;\n            }\n            int cnt[2] = {1, 1};\n            for (int k = 0; k < 4; k++) {\n                int ni = i + dy[k];\n                int nj = j + dx[k];\n                while (inField(ni, nj) &&\n                       m[i][j] == m[ni][nj]) {\n                    ni += dy[k];\n                    nj += dx[k];\n                    ++cnt[k&1];\n                }\n            }\n            if (cnt[0] >= 3 || cnt[1] >= 3) {\n                e[i][j] = 1;\n            }\n        }\n    }\n    int point = 0;\n    for (int i = 0; i < 5; i++) {\n        for (int j = 0; j < 5; j++) {\n            if (e[i][j]) {\n                point += score[m[i][j]-1] * bp;\n                m[i][j] = 0;\n            }\n        }\n    }\n    return point;\n}\n\nvoid fall(Mat &m)\n{\n    for (int j = 0; j < 5; j++) {\n        for (int i = 4; i >= 1; i--) {\n            if (m[i][j] == 0) {                \n                for (int k = i-1; k >= 0; k--) {\n                    if (m[k][j] != 0) {\n                        swap(m[i][j], m[k][j]);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}\n\nint calc(Mat &m, int bp)\n{\n    int point = erase(m, bp);\n    fall(m);\n    return point;\n}\n\nint get_point()\n{\n    Mat b = a;\n    int point = 0, bp = 1;\n    bool update = 1;\n    \n    while (update) {\n        update = 0;        \n        Mat nb = b;\n        int p = calc(nb, bp++);\n        if (p > 0) {\n            point += p;\n            update = 1;\n            b = nb;\n        }\n    }\n    return point;\n}\n\nint dfs(int y, int x, int n)    \n{\n    int point = get_point();\n    if (n > 0) {\n        for (int i = 0; i < 4; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (inField(nx, ny)) {\n                swap(a[ny][nx], a[y][x]);\n                point = max(point, dfs(ny, nx, n-1));\n                swap(a[ny][nx], a[y][x]);\n            }        \n        }\n    }\n    return point;\n}\n\nint main()\n{\n    int n;\n    while (cin >> n, n != -1) {\n        for (int i = 0; i < 5; i++) {\n            for (int j = 0; j < 5; j++) {\n                cin >> a[i][j];\n            }\n        }\n    \n        for (int i = 0; i < 5; i++) {\n            cin >> score[i];\n        }\n\n        int max_point = 0;\n        for (int i = 0; i < 5; i++) {\n            for (int j = 0; j < 5; j++) {\n                max_point = max(max_point, dfs(i, j, n));\n            }\n        }   \n        cout << max_point << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nint n;\nint a[5][5];\nint s[5];\nint dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n\nint check(int d){\n  bool dis[5][5],f = false;\n  rep(i,5)rep(j,5)dis[i][j] = false;\n\n  rep(i,5)rep(j,5){\n    if(a[i][j] == 0)continue;\n\n    rep(k,2){\n      int sy = i, sx = j;\n      int c = 0;\n      while(sy>=0 && sx>=0 && sy<=4 && sx<=4 && a[sy][sx] == a[i][j]){\n\tc++; sy += dy[k]; sx += dx[k];\n      }\n      if(c>=3){\n\trep(l,c)dis[i+l*dy[k]][j+l*dx[k]] = true;\n\tf = true;\n      }\n    }\n  }\n  if(!f)return 0;\n\n  int res = 0;\n  rep(i,5)rep(j,5){\n    if(dis[i][j]){\n      res += d*s[a[i][j]-1];\n      a[i][j] = 0;\n    }\n  }\n\n  rep(i,5){\n    for(int j=4;j>=0;j--){\n      if(a[j][i] != 0){\n\tfor(int k=1;k<=4-j;k++){\n\t  if(a[j+k][i]==0)swap(a[j+k][i],a[j+k-1][i]);\n\t}\n      }\n    }\n  }\n  return res + check(d+1);\n}\n\nint move(int y,int x,int d){\n  int tmp[5][5];\n  rep(i,5)rep(j,5)tmp[i][j] = a[i][j];\n  int res = check(1);\n  rep(i,5)rep(j,5)a[i][j] = tmp[i][j];\n  if(d==n)return res;\n\n  rep(k,4){\n    int sy = y+dy[k], sx = x+dx[k];\n    if(sy<0 || sy>4 || sx<0 || sy>4)continue;\n    swap(a[y][x],a[sy][sx]);\n    res = max(res,move(sy,sx,d+1));\n    swap(a[y][x],a[sy][sx]);\n  }\n  return res;\n}     \n\nint solve(){\n  int res = 0;\n  rep(i,5)rep(j,5)res = max(res,move(i,j,0));\n  return res;\n}\n\nint main(){\n  while(cin >> n,n>=0){\n    rep(i,5)rep(j,5)cin >> a[i][j];\n    rep(i,5)cin >> s[i];\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,-1,0,1};\ntemplate<class T> constexpr bool in_range(T y, T x, T H, T W) { return 0<=y&&y<H&&0<=x&&x<W; }\n\nint N;\nint a[5][5];\nint score[6];\n\nvoid drop() {\n  rep(j, 5) {\n    deque<int> d;\n    rep(i, 5) {\n      if(a[i][j] != -1) {\n        d.push_back(a[i][j]);\n      }\n    }\n\n    int dsize = d.size();\n    for(int i=4; i>=0 && !d.empty(); i--) {\n      a[i][j] = d.back();\n      d.pop_back();\n    }\n    rep(i, 5-dsize) {\n      a[i][j] = -1;\n    }\n  }\n}\n\nint dist(int num, int i, int j, int dy, int dx, int sum = 0) {\n  i += dy, j += dx;\n  if(!in_range(i, j, 5, 5)) return sum;\n  if(a[i][j] != num) return sum;\n  return dist(num, i, j, dy, dx, sum + 1);\n}\n\nint simulate() {\n  int ret = 0;\n  int bonus = 1;\n\n  while(1) {\n    set<int> used;\n    rep(i, 5) rep(j, 5) {\n      if(a[i][j] == -1) continue;\n      int movel = dist(a[i][j], i, j, 0, -1);\n      int mover = dist(a[i][j], i, j, 0, +1);\n      int movet = dist(a[i][j], i, j, -1, 0);\n      int moveb = dist(a[i][j], i, j, +1, 0);\n      if(mover - movel + 1 >= 3) {\n        REP(x, j - movel, j + mover + 1) {\n          assert(a[i][x] != -1);\n          assert(a[i][x] == a[i][j]);\n          used.insert(i*5+x);\n        }\n      }\n      if(moveb - movet + 1 >= 3) {\n        REP(y, i - movet, i + moveb + 1) {\n          assert(a[y][j] != -1);\n          assert(a[y][j] == a[i][j]);\n          used.insert(y*5+j);\n        }\n      }\n    }\n\n    for(auto && e: used) {\n      ret += score[a[e/5][e%5]] * bonus;\n      a[e/5][e%5] = -1;\n    }\n\n    bonus ++;\n    if(!used.size()) break;\n    drop();\n  }\n\n  return ret;\n}\n\n\n\nint dfs(int y, int x, int idx = 0) {\n  int aa[5][5]; rep(i, 5) rep(j, 5) aa[i][j] = a[i][j];\n  int ret = simulate();\n  if(idx < N) {\n    rep(k, 4) {\n      int ny = y + dy[k], nx = x + dx[k];\n      if(!in_range(ny, nx, 5, 5)) continue;\n      rep(i, 5) rep(j, 5) a[i][j] = aa[i][j];\n      swap(a[y][x], a[ny][nx]);\n      maximize(ret, dfs(ny, nx, idx + 1));\n    }\n  }\n  rep(i, 5) rep(j, 5) a[i][j] = aa[i][j];\n  return ret;\n}\n\nint solve() {\n  int ret = 0;\n  rep(i, 5) rep(j, 5)  {\n    maximize(ret, dfs(i, j));\n  }\n  return ret;\n}\n\nint main() {\n\n  for(; cin >> N && N >= 0;) {\n    rep(i, 5) rep(j, 5) cin >> a[i][j];\n    rep(i, 5) cin >> score[i+1];\n    cout << solve() << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define double long double\nusing namespace std;\nconst int N = 100010;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\nostream& operator<<(ostream& o,P p){\n  return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\ntemplate<class T> istream& operator>>(istream& i,vector<T> &a){for(auto &t:a)cin>>t;return i;}\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\ntemplate<class T> void prArr(T a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\n\nint dx[] = {0,0,1,-1};\nint dy[] = {1,-1,0,0};\nvector<int> score;\n\nint calcScore(const vector<vector<int> > &mp, int bonus){\n  \n  auto okw=[&](int i,int j){\n    if(j + 2 >= 5) return false;\n    if(mp[i][j] == -1) return false;\n    return mp[i][j] == mp[i][j+1] && mp[i][j] == mp[i][j+2];\n  };\n  \n  auto okh=[&](int i,int j){\n    if(i + 2 >= 5) return false;\n    if(mp[i][j] == -1) return false;\n    return mp[i][j] == mp[i+1][j] && mp[i][j] == mp[i+2][j];\n  };\n  \n  int flag = 0;\n  vector<vector<int> > res = mp;\n  for(int i=0;i<5;i++)\n    for(int j=0;j<5;j++){\n      if(okw(i,j)) res[i][j] = res[i][j+1] = res[i][j+2] = -2;\n      if(okh(i,j)) res[i][j] = res[i+1][j] = res[i+2][j] = -2;\n    }\n  \n  int block = 0;\n  for(int i=0;i<5;i++)\n    for(int j=0;j<5;j++)\n      if(res[i][j] == -2){\n\tassert(mp[i][j] >= 0);\n\tflag = 1;\n\tres[i][j] = -1;\n\tblock += score[mp[i][j] - 1];\n      }\n  \n  for(int j=0;j<5;j++)\n    for(int k=0;k<5;k++)\n      for(int i = 0; i < 5-1; i++)\n\tif(res[i][j] == -1) swap(res[i][j],res[i+1][j]);\n\n  int ans = bonus * block;\n  // if(bonus == 2) cout<<\"2=\"<<ans<<endl;\n  if(flag) ans += calcScore(res,bonus+1);\n  return ans;\n}\n\nint dfs(int i,int j,int n,vector<vector<int> > mp){\n  \n  \n  if(n == 0) return calcScore(mp,1);\n  \n\n  int res = calcScore(mp,1);\n  for(int k=0;k<4;k++){\n    int ni = i + dy[k];\n    int nj = j + dx[k];\n    if(ni < 0 || nj < 0 || ni >= 5 || nj >= 5) continue;\n    swap(mp[i][j], mp[ni][nj]);\n    res = max(res,dfs(ni,nj,n-1,mp));\n    swap(mp[i][j], mp[ni][nj]);\n  }\n  return res;\n}\n\nsigned main(){\n  while(1){\n    int n;\n    cin>>n;\n    if(n == -1) break;\n    vector<vector<int> > A(5,vector<int>(5));\n    for(int i=0;i<5;i++)\n      for(int j=0;j<5;j++) cin>>A[4-i][j];\n\n    score.clear();\n    score.resize(5);\n    for(int i=0;i<5;i++) cin>>score[i];\n    \n    int ans = -INF;\n    for(int i=0;i<5;i++)\n      for(int j=0;j<5;j++) Max(ans,dfs(i,j,n,A));\n    \n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n\nint N;\nint field[6][6];\nint ss[6];\n\nll calc(){\n  ll sum=0;\n  int nowField[6][6]={};\n  for(int i=0;i<5;i++)\n    for(int j=0;j<5;j++)\n      nowField[i][j]=field[i][j];\n  int bonus=1;\n  while(1){\n    bool isDel=false;\n    int nxtField[5][5]={};\n    // テァツ渉セテ・ツ慊ィテ」ツ?ョfieldテ」ツ?ォテ」ツ?ェテ」ツつ嘉」ツつ禿」ツ?ァテ」ツ??」ツつ凝」ツつづ」ツ?ョテ」ツつ津」ツ?凖」ツ?ケテ」ツ?ヲテヲツカツ暗」ツ??\n    for(int i=0;i<5;i++){\n      for(int j=0;j<5;j++){\n        if(nowField[i][j]==-1)continue;\n        // テヲツィツェ\n        {\n          int now=nowField[i][j];\n          int cnt=0;\n          for(int k=j;k<5;k++){\n            if(now==nowField[i][k])cnt++;\n            else break;\n          }\n          if(cnt>=3){\n            isDel=true;\n            for(int k=j;k<5;k++){\n              if(now==nowField[i][k])nxtField[i][k]=-1;\n              else break;\n            }\n          }\n        }\n        // テァツクツヲ\n        {\n          int now=nowField[i][j];\n          int cnt=0;\n          for(int k=i;k<5;k++){\n            if(now==nowField[k][j])cnt++;\n            else break;\n          }\n          if(cnt>=3){\n            isDel=true;\n            for(int k=i;k<5;k++){\n              if(now==nowField[k][j]){\n                nxtField[k][j]=-1;\n              }\n              else break;\n            }\n          }\n        }\n      }\n    }\n    for(int i=0;i<5;i++)\n      for(int j=0;j<5;j++)\n        if(nxtField[i][j]==-1)\n          sum+=ss[nowField[i][j]]*bonus;\n    for(int i=0;i<5;i++)\n      for(int j=0;j<5;j++)\n        if(nxtField[i][j]==-1)\n          nowField[i][j]=-1;\n    memset(nxtField,-1,sizeof(nxtField));\n    // テヲツカツ暗」ツ?療」ツ?淌・ツセツ古」ツ??ィツ青ステ」ツ?ィテ」ツ?凖・ツ仰陛、ツスツ愿」ツつ津ィツ。ツ古」ツ??\n    for(int j=0;j<5;j++){\n      int lis[5];\n      memset(lis,-1,sizeof(lis));\n      int cnt=0;\n      for(int i=4;i>=0;i--)\n        if(nowField[i][j]!=-1)\n          lis[cnt++]=nowField[i][j];\n      for(int i=0;i<cnt;i++)\n        nxtField[4-i][j]=lis[i];\n    }\n    for(int i=0;i<5;i++)\n      for(int j=0;j<5;j++)\n        nowField[i][j]=nxtField[i][j];\n    if(!isDel)break;\n    bonus++;\n  }\n  if(sum==2724){\n    cout<<bonus<<endl;\n    for(int i=0;i<5;i++){\n      for(int j=0;j<5;j++){\n        printf(\"%2d\",field[i][j]+1);\n      }\n      cout<<endl;\n    }\n    cout<<endl;\n    for(int i=0;i<5;i++){\n      for(int j=0;j<5;j++){\n        printf(\"%2d\",nowField[i][j]+1);\n      }\n      cout<<endl;\n    }\n    \n  }\n  return sum;\n}\n\nvoid dfs(int depth,int cy,int cx,ll &res){\n  if(depth==N)res=max(res,calc());\n  else{\n    const int dy[]={-1,0,0,1};\n    const int dx[]={0,-1,1,0};\n    for(int i=0;i<4;i++){\n      int ny=dy[i]+cy;\n      int nx=dx[i]+cx;\n      if(ny>=0&&nx>=0&&ny<5&&nx<5){\n        swap(field[ny][nx],field[cy][cx]);\n        dfs(depth+1,ny,nx,res);\n        swap(field[ny][nx],field[cy][cx]);\n      }\n    }\n  }\n}\n\nint main(){\n\n  while(cin>>N&&N!=-1){\n    for(int i=0;i<5;i++)\n      for(int j=0;j<5;j++)\n        cin>>field[i][j],field[i][j]--;\n    for(int i=0;i<5;i++)\n      cin>>ss[i];\n    ll res=0;\n    //cout<<N<<endl;\n    for(int i=0;i<5;i++)\n      for(int j=0;j<5;j++)\n        dfs(0,i,j,res);\n    cout<<res<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint score[6];\n\nint ans = 0;\n\nvoid fallBlock(int mas[5][5])\n{\n  for(int i = 4; i > 0; i--){\n    for(int j = 0; j < 5; j++){\n      if(mas[i][j] == 0){\n\tswap(mas[i-1][j], mas[i][j]);\n      }\n    }\n  }\n\n  return;\n}\n\nint getPoint(int mas[5][5])\n{\n  int point = 0;\n  \n  for(int i = 0; i < 3; i++){\n    for(int j = 0; j < 5; j++){\n      if(abs(mas[i][j]) == abs(mas[i+1][j]) &&\n\t abs(mas[i][j]) == abs(mas[i+2][j])){\n\tmas[i][j] = mas[i+1][j] = mas[i+2][j] = -abs(mas[i][j]);\n      }\n    }\n  }\n  for(int i = 0; i < 5; i++){\n    for(int j = 0; j < 3; j++){\n      if(abs(mas[i][j]) == abs(mas[i][j+1]) &&\n\t abs(mas[i][j]) == abs(mas[i][j+2])){\n\tmas[i][j] = mas[i][j+1] = mas[i][j+2] = -abs(mas[i][j]);\n      }\n    }\n  }\n  \n  for(int i = 0; i < 5; i++){\n    for(int j = 0; j < 5; j++){\n      point += (mas[i][j] < 0) * score[-mas[i][j]];\n      mas[i][j] = 0;\n    }\n  }\n\n  fallBlock(mas);\n\n  return point;\n}\n\nvoid dfs(int y, int x, int n, int mas[5][5])\n{\n  static int dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n  int p = 0;\n  \n  if(n > 0){\n    for(int i = 0; i < 4; i++){\n      int nx = x + dx[i], ny = y + dy[i];\n      if(n > 0 && 0 <= nx && nx < 5 && 0 <= ny && ny < 5){\n\tint tmp[5][5];\n\tfor(int k = 0; k < 5; k++){\n\t  for(int l = 0; l < 5; l++) tmp[k][l] = mas[k][l];\n\t}\n\tswap(tmp[y][x], tmp[ny][nx]);\n\tdfs(ny, nx, n-1, tmp);\n      }\n    }\n  }\n  \n  for(int bonus = 1, get = getPoint(mas); get > 0; bonus++, get = getPoint(mas))\n    p += get * bonus;\n  ans = max(ans, p);\n\n  return;\n}\n\nint main()\n{\n  int n;\n  int mas[5][5];\n  \n  while(cin >> n, n != -1){\n    ans = 0;\n    for(int i = 0; i < 5; i++){\n      for(int j = 0; j < 5; j++) cin >> mas[i][j];\n    }\n    for(int i = 1; i <= 5; i++) cin >> score[i];\n    \n    for(int i = 0; i < 5; i++){\n      for(int j = 0; j < 5; j++){\n\tint tmp[5][5];\n\tfor(int k = 0; k < 5; k++){\n\t  for(int l = 0; l < 5; l++) tmp[k][l] = mas[k][l];\n\t}\n\tdfs(i, j, n, tmp);\n      }\n    }\n    \n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nint n;\nint a[5][5];\nint s[5];\nint dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n\nint check(int d){\n  bool dis[5][5],f = false;\n  rep(i,5)rep(j,5)dis[i][j] = false;\n\n  rep(i,5)rep(j,5){\n    if(a[i][j] == 0)continue;\n\n    rep(k,2){\n      int sy = i, sx = j;\n      int c = 0;\n      while(sy>=0 && sx>=0 && sy<=4 && sx<=4 && a[sy][sx] == a[i][j]){\n\tc++; sy += dy[k]; sx += dx[k];\n      }\n      if(c<3)continue;\n\n      f = true;\n      sy = i; sx = j;\n      while(sy>=0 && sx>=0 && sy<=4 && sx<=4 && a[sy][sx] == a[i][j]){\n\tdis[sy][sx] = true;\n\tsy += dy[k]; sx += dx[k];\n      }\n    }\n  }\n  if(!f)return 0;\n\n  int res = 0;\n  rep(i,5)rep(j,5){\n    if(dis[i][j]){\n      res += d*s[a[i][j]-1];\n      a[i][j] = 0;\n    }\n  }\n\n  rep(i,5){\n    for(int j=4;j>=0;j--){\n      if(a[j][i] != 0){\n\tfor(int k=1;k<=4-j;k++){\n\t  if(a[j+k][i]==0)swap(a[j+k][i],a[j+k-1][i]);\n\t}\n      }\n    }\n  }\n  return res + check(d+1);\n}\n\nint move(int y,int x,int d){\n  int tmp[5][5];\n  rep(i,5)rep(j,5)tmp[i][j] = a[i][j];\n  int res = check(1);\n  rep(i,5)rep(j,5)a[i][j] = tmp[i][j];\n  if(d==n)return res;\n\n  rep(k,4){\n    int sy = y+dy[k], sx = x+dx[k];\n    if(sy<0 || sy>4 || sx<0 || sy>4)continue;\n    swap(a[y][x],a[sy][sx]);\n    res = max(res,move(sy,sx,d+1));\n    swap(a[y][x],a[sy][sx]);\n  }\n  return res;\n}     \n\nint solve(){\n  int res = 0;\n  rep(i,5)rep(j,5)res = max(res,move(i,j,0));\n  return res;\n}\n\nint main(){\n  while(cin >> n,n>=0){\n    rep(i,5)rep(j,5)cin >> a[i][j];\n    rep(i,5)cin >> s[i];\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n\nint N;\nint field[6][6];\nint ss[6];\n\nll calc(){\n  ll sum=0;\n  int nowField[6][6]={};\n  for(int i=0;i<5;i++)\n    for(int j=0;j<5;j++)\n      nowField[i][j]=field[i][j];\n  int bonus=1;\n  while(1){\n    bool isDel=false;\n    int nxtField[5][5]={};\n    // テァツ渉セテ・ツ慊ィテ」ツ?ョfieldテ」ツ?ォテ」ツ?ェテ」ツつ嘉」ツつ禿」ツ?ァテ」ツ??」ツつ凝」ツつづ」ツ?ョテ」ツつ津」ツ?凖」ツ?ケテ」ツ?ヲテヲツカツ暗」ツ??\n    for(int i=0;i<5;i++){\n      for(int j=0;j<5;j++){\n        if(nowField[i][j]==-1)continue;\n        // テヲツィツェ\n        {\n          int now=nowField[i][j];\n          int cnt=0;\n          for(int k=j;k<5;k++){\n            if(now==nowField[i][k])cnt++;\n            else break;\n          }\n          if(cnt>=3){\n            isDel=true;\n            for(int k=j;k<5;k++){\n              if(now==nowField[i][k])nxtField[i][k]=-1;\n              else break;\n            }\n          }\n        }\n        // テァツクツヲ\n        {\n          int now=nowField[i][j];\n          int cnt=0;\n          for(int k=i;k<5;k++){\n            if(now==nowField[k][j])cnt++;\n            else break;\n          }\n          if(cnt>=3){\n            isDel=true;\n            for(int k=i;k<5;k++){\n              if(now==nowField[k][j]){\n                nxtField[k][j]=-1;\n              }\n              else break;\n            }\n          }\n        }\n      }\n    }\n    for(int i=0;i<5;i++)\n      for(int j=0;j<5;j++)\n        if(nxtField[i][j]==-1)\n          sum+=ss[nowField[i][j]]*bonus;\n    for(int i=0;i<5;i++)\n      for(int j=0;j<5;j++)\n        if(nxtField[i][j]==-1)\n          nowField[i][j]=-1;\n    memset(nxtField,-1,sizeof(nxtField));\n    // テヲツカツ暗」ツ?療」ツ?淌・ツセツ古」ツ??ィツ青ステ」ツ?ィテ」ツ?凖・ツ仰陛、ツスツ愿」ツつ津ィツ。ツ古」ツ??\n    for(int j=0;j<5;j++){\n      int lis[5];\n      memset(lis,-1,sizeof(lis));\n      int cnt=0;\n      for(int i=4;i>=0;i--)\n        if(nowField[i][j]!=-1)\n          lis[cnt++]=nowField[i][j];\n      for(int i=0;i<cnt;i++)\n        nxtField[4-i][j]=lis[i];\n    }\n    for(int i=0;i<5;i++)\n      for(int j=0;j<5;j++)\n        nowField[i][j]=nxtField[i][j];\n    if(!isDel)break;\n    bonus++;\n  }\n  // if(sum==2724){\n  //   cout<<bonus<<endl;\n  //   for(int i=0;i<5;i++){\n  //     for(int j=0;j<5;j++){\n  //       printf(\"%2d\",field[i][j]+1);\n  //     }\n  //     cout<<endl;\n  //   }\n  //   cout<<endl;\n  //   for(int i=0;i<5;i++){\n  //     for(int j=0;j<5;j++){\n  //       printf(\"%2d\",nowField[i][j]+1);\n  //     }\n  //     cout<<endl;\n  //   }\n  //}\n  return sum;\n}\n\nvoid dfs(int depth,int cy,int cx,ll &res){\n  if(depth==N)res=max(res,calc());\n  else{\n    const int dy[]={-1,0,0,1};\n    const int dx[]={0,-1,1,0};\n    for(int i=0;i<4;i++){\n      int ny=dy[i]+cy;\n      int nx=dx[i]+cx;\n      if(ny>=0&&nx>=0&&ny<5&&nx<5){\n        swap(field[ny][nx],field[cy][cx]);\n        dfs(depth+1,ny,nx,res);\n        swap(field[ny][nx],field[cy][cx]);\n      }\n    }\n  }\n}\n\nint main(){\n\n  while(cin>>N&&N!=-1){\n    for(int i=0;i<5;i++)\n      for(int j=0;j<5;j++)\n        cin>>field[i][j],field[i][j]--;\n    for(int i=0;i<5;i++)\n      cin>>ss[i];\n    ll res=0;\n    //cout<<N<<endl;\n    for(int i=0;i<5;i++)\n      for(int j=0;j<5;j++)\n        dfs(0,i,j,res);\n    cout<<res<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tint table[5][5],rest;\n};\n\nint N,ans;\nint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0},score[6];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= 4 && col >= 0 && col <= 4)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nint calc(int table[5][5]){\n\n\tint ret = 0;\n\n\tint work[5][5],delete_num[6];\n\tbool delete_table[5][5];\n\n\tfor(int row = 0; row < 5; row++){\n\t\tfor(int  col = 0; col < 5; col++)work[row][col] = table[row][col];\n\t}\n\n\tint bonus = 1,delete_sum,tmp,count,tmp_row,tmp_col;\n\n\twhile(true){\n\n\t\tdelete_sum = 0;\n\t\tfor(int i = 1; i <= 5; i++)delete_num[i] = 0;\n\n\t\tfor(int row = 0; row < 5; row++){\n\t\t\tfor(int col = 0; col < 5; col++)delete_table[row][col] = false;\n\t\t}\n\n\t\tfor(int row = 0; row <= 4; row++){\n\t\t\tfor(int col = 0; col <= 2; col++){\n\t\t\t\tif(delete_table[row][col] == true || work[row][col] == 0)continue;\n\n\t\t\t\ttmp_col = col;\n\t\t\t\tfor(count = 0; tmp_col <= 4 && work[row][col] == work[row][tmp_col]; count++,tmp_col++);\n\t\t\t\tif(count >= 3){\n\t\t\t\t\tfor(int i = 0; i < count; i++){\n\t\t\t\t\t\tdelete_table[row][col+i] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int col = 0; col <= 4; col++){\n\t\t\tfor(int row = 0; row <= 2; row++){\n\t\t\t\tif(delete_table[row][col] == true || work[row][col] == 0)continue;\n\n\t\t\t\ttmp_row = row;\n\t\t\t\tfor(count = 0; tmp_row <= 4 && work[row][col] == work[tmp_row][col]; count++,tmp_row++);\n\t\t\t\tif(count >= 3){\n\t\t\t\t\tfor(int i = 0; i < count; i++){\n\t\t\t\t\t\tdelete_table[row+i][col] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int row = 0; row < 5; row++){\n\t\t\tfor(int col = 0; col < 5; col++){\n\t\t\t\tif(delete_table[row][col]){\n\t\t\t\t\tdelete_num[work[row][col]]++;\n\t\t\t\t\tdelete_sum++;\n\t\t\t\t\twork[row][col] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int col = 0; col < 5; col++){\n\t\t\tfor(int row = 4; row >= 1; row--){\n\t\t\t\tif(work[row][col] == 0){\n\t\t\t\t\tfor(tmp = row-1; tmp >= 0; tmp--){\n\t\t\t\t\t\tif(work[tmp][col] != 0)break;\n\t\t\t\t\t}\n\t\t\t\t\tif(tmp == -1)break;\n\n\t\t\t\t\twork[row][col] = work[tmp][col];\n\t\t\t\t\twork[tmp][col] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(delete_sum == 0)break;\n\n\t\tfor(int i = 1; i <= 5; i++){\n\t\t\tret += delete_num[i]*score[i]*bonus;\n\t\t}\n\n\t\tbonus++;\n\t}\n\n\treturn ret;\n}\n\n\nvoid recursive(Info info,int row,int col){\n\n\tans = max(ans,calc(info.table));\n\n\tif(info.rest == 0)return;\n\n\tint adj_row,adj_col;\n\tfor(int i = 0; i < 4; i++){\n\t\tadj_row = row+diff_row[i];\n\t\tadj_col = col+diff_col[i];\n\n\t\tif(!rangeCheck(adj_row,adj_col))continue;\n\n\t\tInfo new_info;\n\t\tfor(int row = 0; row < 5; row++){\n\t\t\tfor(int col = 0; col < 5; col++)new_info.table[row][col] = info.table[row][col];\n\t\t}\n\t\tswap(new_info.table[adj_row][adj_col],new_info.table[row][col]);\n\t\tnew_info.rest = info.rest-1;\n\t\trecursive(new_info,adj_row,adj_col);\n\t}\n}\n\n\nvoid func(){\n\n\tInfo first;\n\tfor(int row = 0; row < 5; row++){\n\t\tfor(int col = 0; col < 5; col++)scanf(\"%d\",&first.table[row][col]);\n\t}\n\n\tfor(int i = 1; i <= 5; i++)scanf(\"%d\",&score[i]);\n\n\tfirst.rest = N;\n\n\tans = 0;\n\n\tfor(int row = 0; row < 5; row++){\n\t\tfor(int col = 0; col < 5; col++)recursive(first,row,col);\n\t}\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == -1)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,-1,0,1};\ntemplate<class T> constexpr bool in_range(T y, T x, T H, T W) { return 0<=y&&y<H&&0<=x&&x<W; }\n\nint N;\nint a[5][5];\nint b[5][5];\nint score[6];\n\nvoid drop() {\n  rep(j, 5) {\n    deque<int> d;\n    rep(i, 5) {\n      if(a[i][j] != -1) {\n        d.push_back(a[i][j]);\n      }\n    }\n\n    int dsize = d.size();\n    for(int i=4; i>=0 && !d.empty(); i--) {\n      a[i][j] = d.back();\n      d.pop_back();\n    }\n    rep(i, 5-dsize) {\n      a[i][j] = -1;\n    }\n  }\n}\n\nint dist(int num, int i, int j, int dy, int dx, int sum = 0) {\n  i += dy, j += dx;\n  if(!in_range(i, j, 5, 5)) return sum;\n  if(a[i][j] != num) return sum;\n  return dist(num, i, j, dy, dx, sum + 1);\n}\n\nint simulate() {\n  int ret = 0;\n  int bonus = 1;\n\n  while(1) {\n    set<int> used;\n    rep(i, 5) rep(j, 5) {\n      if(a[i][j] == -1) continue;\n      int movel = dist(a[i][j], i, j, 0, -1);\n      int mover = dist(a[i][j], i, j, 0, +1);\n      int movet = dist(a[i][j], i, j, -1, 0);\n      int moveb = dist(a[i][j], i, j, +1, 0);\n      if(mover - movel + 1 >= 3) {\n        REP(x, j - movel, j + mover + 1) {\n          assert(a[i][x] != -1);\n          assert(a[i][x] == a[i][j]);\n          used.insert(i*5+x);\n        }\n      }\n      if(moveb - movet + 1 >= 3) {\n        REP(y, i - movet, i + moveb + 1) {\n          assert(a[y][j] != -1);\n          assert(a[y][j] == a[i][j]);\n          used.insert(y*5+j);\n        }\n      }\n    }\n\n    for(auto && e: used) {\n      ret += score[a[e/5][e%5]] * bonus;\n      a[e/5][e%5] = -1;\n    }\n\n    bonus ++;\n    if(!used.size()) break;\n    drop();\n  }\n\n  return ret;\n}\n\n\n\nint dfs(int y, int x, int idx = 0) {\n  int aa[5][5]; rep(i, 5) rep(j, 5) aa[i][j] = a[i][j];\n  int ret = simulate();\n  if(idx < N) {\n    rep(k, 4) {\n      int ny = y + dy[k], nx = x + dx[k];\n      if(!in_range(ny, nx, 5, 5)) continue;\n      rep(i, 5) rep(j, 5) a[i][j] = aa[i][j];\n      swap(a[y][x], a[ny][nx]);\n      maximize(ret, dfs(ny, nx, idx + 1));\n    }\n  }\n  return ret;\n}\n\nint solve() {\n  int ret = 0;\n  rep(i, 5) rep(j, 5)  {\n    rep(i, 5) rep(j, 5) a[i][j] = b[i][j];\n    maximize(ret, dfs(i, j));\n  }\n  return ret;\n}\n\nint main() {\n\n  for(; cin >> N && N >= 0;) {\n    rep(i, 5) rep(j, 5) cin >> b[i][j], a[i][j] = b[i][j];\n    rep(i, 5) cin >> score[i+1];\n    cout << solve() << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nclass Field {\nprivate:\n  int _stage[5][5];\n  bool _marked[5][5];\n  int _score[6];\n  int compute_block_score(){\n    int res = 0;\n    for(int y = 0; y < 5; y++){\n      for(int x = 0; x < 5; x++){\n        if(_marked[y][x]) {\n          res += _score[_stage[y][x]];\n        }\n      }\n    }\n    return res;\n  }\npublic:\n  Field(int stage[5][5],int score[6]){\n    memcpy(_stage,stage,sizeof(int)*5*5);\n    memcpy(_score,score,sizeof(int)*6);\n    memset(_marked,false,sizeof(_marked));\n  }\n  bool mark(){\n    bool has_mark = false;\n    memset(_marked,false,sizeof(_marked));\n    for(int y = 0; y < 5; y++){\n      for(int x = 0; x < 5; x++){\n        //horizontal\n        int h_count = 1;\n        for(int dx = x; dx + 1 < 5; dx++){\n          if(_stage[y][dx] != 0\n             && _stage[y][dx] == _stage[y][dx+1]) h_count++;\n          else{\n            break;\n          }\n        }\n        if(h_count >= 3){\n          has_mark = true;\n          for(int dx = x; dx < 5; dx++){\n            if(h_count-- <= 0) break;\n            _marked[y][dx] = true;\n          }\n        }\n\n        //vertical\n        int v_count = 1;\n        for(int dy = y; dy + 1 < 5; dy++){\n          if(_stage[dy][x] != 0 \n             && _stage[dy][x] == _stage[dy + 1][x]) v_count++;\n          else{\n            break;\n          }\n        }\n        if(v_count >= 3){\n          has_mark = true;\n          for(int dy = y; dy < 5; dy++){\n            if(v_count-- <= 0) break;\n            _marked[dy][x] = true;\n          }\n        }\n      }\n    }\n\n    return has_mark;\n  }\n\n  void erase(){\n    int next[5][5] = {};\n    for(int x = 0; x < 5; x++){\n      int pos = 4;\n      for(int y = 4; y >= 0; y--){\n        if(_marked[y][x]) continue;\n        next[pos--][x] = _stage[y][x];\n      }\n    }\n    memcpy(_stage,next,sizeof(int)*5*5);\n  }\n\n  int compute_score(){\n    int bonus = 1;\n    int sum = 0;\n    while(mark()){\n      sum += compute_block_score() * bonus;\n      erase();\n      bonus++;\n    }\n    return sum;\n  }\n\n  void disp(){\n    for(int y = 0; y < 5; y++){\n      for(int x = 0; x < 5; x++){\n        printf(\"%d \",_stage[y][x]);\n      }\n      printf(\"\\n\");\n    }\n    printf(\"\\n\");\n\n    for(int y = 0; y < 5; y++){\n      for(int x = 0; x < 5; x++){\n        printf(\"%s\",_marked[y][x] ? \"o\" : \"x\");\n      }\n      printf(\"\\n\");\n    }\n    printf(\"\\n\");\n  }\n};\n\nint stage[5][5];\nint score[6];\n\nint dfs(int sx,int sy,int count){\n  if(count <= 0) return 0;\n\n  int res = 0;\n  for(int i = 0; i < 4; i++){\n    int dx = tx[i] + sx;\n    int dy = ty[i] + sy;\n    if(dx < 0 || dx >= 5 || dy < 0 || dy >= 5) continue;\n    swap(stage[dy][dx],stage[sy][sx]);\n    res = max(res,Field(stage,score).compute_score());\n    res = max(res,dfs(dx,dy,count-1));\n    swap(stage[dy][dx],stage[sy][sx]);\n  }\n  return res;\n}\n  \nint main(){\n  int move_limit;\n  while(~scanf(\"%d\",&move_limit)){\n    if(move_limit == -1) break;\n\n    for(int y = 0; y < 5; y++){\n      for(int x = 0; x < 5; x++){\n        scanf(\"%d\",&stage[y][x]);\n      }\n    }\n\n    for(int i = 1; i <= 5; i++){\n      scanf(\"%d\",&score[i]);\n    }\n\n    int res = 0;\n\n    if(move_limit == 0){\n      res = Field(stage,score).compute_score();\n    }\n    else{\n      for(int y = 0; y < 5; y++){\n        for(int x = 0; x < 5; x++){\n          res = max(res,dfs(x,y,move_limit));\n        }\n      }\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<int, bool>P;\n\nint s[5], dx[]{ 1,-1,0,0, }, dy[]{ 0,0,1,-1 };\nvector<vector<int>>a(5, vector<int>(5));\nint Max;\nvoid dfs(int x, int y, int c) {\n\tif (c == 0) {\n\t\tvector<vector<P>>b(5, vector<P>(5));\n\t\trep(i, 5)rep(j, 5)b[i][j].first = a[i][j];\n\t\tbool update = true;\n\t\tint p = 0;\n\t\tfor (int v = 1; update; v++) {\n\t\t\tupdate = false;\n\t\t\trep(i, 5) {\n\t\t\t\tint back = 0, cnt = 0;\n\t\t\t\trep(j, b[i].size()) {\n\t\t\t\t\tif (back != b[i][j].first) {\n\t\t\t\t\t\tif (cnt >= 3) {\n\t\t\t\t\t\t\tfor (int k = 1; k <= cnt; k++)\n\t\t\t\t\t\t\t\tb[i][j - k].second = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcnt = 0;\n\t\t\t\t\t}\n\t\t\t\t\tback = b[i][j].first; cnt++;\n\t\t\t\t}\n\t\t\t\tif (cnt >= 3) {\n\t\t\t\t\tfor (int k = 1; k <= cnt; k++)\n\t\t\t\t\t\tb[i][b[i].size() - k].second = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i, 5) {\n\t\t\t\tint back = 0, cnt = 0;\n\t\t\t\trep(j, 5) {\n\t\t\t\t\tif (b[j].size() <= i || back != b[j][i].first) {\n\t\t\t\t\t\tif (cnt >= 3) {\n\t\t\t\t\t\t\tfor (int k = 1; k <= cnt; k++)\n\t\t\t\t\t\t\t\tb[j - k][i].second = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcnt = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (i < b[j].size()) {\n\t\t\t\t\t\tback = b[j][i].first; cnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (cnt >= 3) {\n\t\t\t\t\tfor (int k = 1; k <= cnt; k++)b[5 - k][i].second = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i, 5)rep(j, b[i].size()) {\n\t\t\t\tif (b[i][j].second == 1) {\n\t\t\t\t\tp += v*s[b[i][j].first];\n\t\t\t\t\tb[i].erase(b[i].begin() + j); update = true; j--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tMax = max(Max, p);\n\t\treturn;\n\t}\n\trep(i, 4) {\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tif (0 <= nx&&nx < 5 && 0 <= ny&&ny < 5) {\n\t\t\tswap(a[x][y], a[nx][ny]);\n\t\t\tdfs(nx, ny, c - 1);\n\t\t\tswap(a[x][y], a[nx][ny]);\n\t\t}\n\t}\n}\nint main() {\n\tint n;\n\twhile (scanf(\"%d\", &n), ~n) {\n\t\tMax = 0;\n\t\trep(i, 5)rep(j, 5)scanf(\"%d\", &a[j][i]), a[j][i]--;\n\t\trep(i, 5)reverse(a[i].begin(), a[i].end());\n\t\trep(i, 5)scanf(\"%d\", &s[i]);\n\t\trep(i, 5)rep(j, 5)dfs(i, j, n);\n\t\tprintf(\"%d\\n\", Max);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nint n;\nint a[5][5];\nint s[5];\nint dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n\nint check(void){\n  int res = 0;\n  for(int d=1;;d++){\n    bool dis[5][5],f = false;\n    rep(i,5)rep(j,5)dis[i][j] = false;\n    \n    rep(i,5)rep(j,5){\n      if(a[i][j] == 0)continue;\n      \n      rep(k,2){\n\tint sy = i, sx = j;\n\tint c = 0;\n\twhile(sy>=0 && sx>=0 && sy<=4 && sx<=4 && a[sy][sx] == a[i][j]){\n\t  c++; sy += dy[k]; sx += dx[k];\n\t}\n\tif(c<3)continue;\n\t\n\tf = true;\n\tsy = i; sx = j;\n\twhile(sy>=0 && sx>=0 && sy<=4 && sx<=4 && a[sy][sx] == a[i][j]){\n\t  dis[sy][sx] = true;\n\t  sy += dy[k]; sx += dx[k];\n\t}\n      }\n    }\n    if(!f)return res;\n\n    rep(i,5)rep(j,5){\n      if(dis[i][j]){\n\tres += d*s[a[i][j]-1];\n\ta[i][j] = 0;\n      }\n    }\n    \n    rep(i,5){\n      for(int j=4;j>=0;j--){\n\tif(a[j][i] != 0){\n\t  for(int k=1;k<=4-j;k++){\n\t    if(a[j+k][i]==0)swap(a[j+k][i],a[j+k-1][i]);\n\t  }\n\t}\n      }\n    }\n  }\n}\n\nint move(int y,int x,int d){\n  int tmp[5][5];\n  rep(i,5)rep(j,5)tmp[i][j] = a[i][j];\n  int res = check();\n  rep(i,5)rep(j,5)a[i][j] = tmp[i][j];\n  if(d==n)return res;\n\n  rep(k,4){\n    int sy = y+dy[k], sx = x+dx[k];\n    if(sy<0 || sy>4 || sx<0 || sy>4)continue;\n    swap(a[y][x],a[sy][sx]);\n    res = max(res,move(sy,sx,d+1));\n    swap(a[y][x],a[sy][sx]);\n  }\n  return res;\n}     \n\nint solve(){\n  int res = 0;\n  rep(i,5)rep(j,5)res = max(res,move(i,j,0));\n  return res;\n}\n\nint main(){\n  while(cin >> n,n>=0){\n    rep(i,5)rep(j,5)cin >> a[i][j];\n    rep(i,5)cin >> s[i];\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n\nint N;\nint field[6][6];\nint ss[6];\n\nll calc(){\n  ll sum=0;\n  int nowField[6][6]={};\n  for(int i=0;i<5;i++)\n    for(int j=0;j<5;j++)\n      nowField[i][j]=field[i][j];\n  int bonus=1;\n  while(1){\n    bool isDel=false;\n    int nxtField[5][5]={};\n    // テァツ渉セテ・ツ慊ィテ」ツ?ョfieldテ」ツ?ォテ」ツ?ェテ」ツつ嘉」ツつ禿」ツ?ァテ」ツ??」ツつ凝」ツつづ」ツ?ョテ」ツつ津」ツ?凖」ツ?ケテ」ツ?ヲテヲツカツ暗」ツ??\n    for(int i=0;i<5;i++){\n      for(int j=0;j<5;j++){\n        if(nowField[i][j]==-1)continue;\n        // テヲツィツェ\n        {\n          int now=nowField[i][j];\n          int cnt=0;\n          for(int k=j;k<5;k++){\n            if(now==nowField[i][k])cnt++;\n            else break;\n          }\n          if(cnt>=3){\n            isDel=true;\n            for(int k=j;k<5;k++){\n              if(now==nowField[i][k])nxtField[i][k]=-1;\n              else break;\n            }\n          }\n        }\n        // テァツクツヲ\n        {\n          int now=nowField[i][j];\n          int cnt=0;\n          for(int k=i;k<5;k++){\n            if(now==nowField[k][j])cnt++;\n            else break;\n          }\n          if(cnt>=3){\n            isDel=true;\n            for(int k=i;k<5;k++){\n              if(now==nowField[k][j])nxtField[k][j]=-1;\n              else break;\n            }\n          }\n        }\n      }\n    }\n    for(int i=0;i<5;i++)\n      for(int j=0;j<5;j++)\n        if(nxtField[i][j]==-1)\n          sum+=ss[nowField[i][j]]*bonus;\n    for(int i=0;i<5;i++)\n      for(int j=0;j<5;j++)\n        if(nxtField[i][j]==-1)\n          nowField[i][j]=-1;\n    memset(nxtField,-1,sizeof(nxtField));\n    // テヲツカツ暗」ツ?療」ツ?淌・ツセツ古」ツ??ィツ青ステ」ツ?ィテ」ツ?凖・ツ仰陛、ツスツ愿」ツつ津ィツ。ツ古」ツ??\n    for(int j=0;j<5;j++){\n      int lis[5];\n      memset(lis,-1,sizeof(lis));\n      int cnt=0;\n      for(int i=4;i>=0;i--)\n        if(nowField[i][j]!=-1)\n          lis[cnt++]=nowField[i][j];\n      for(int i=0;i<cnt;i++)\n        nxtField[4-i][j]=lis[i];\n    }\n    for(int i=0;i<5;i++)\n      for(int j=0;j<5;j++)\n        nowField[i][j]=nxtField[i][j];\n    if(!isDel)break;\n    bonus++;\n  }\n  return sum;\n}\n\nvoid dfs(int depth,int cy,int cx,ll &res){\n  res=max(res,calc());\n  if(depth!=N){\n    const int dy[]={-1,0,0,1};\n    const int dx[]={0,-1,1,0};\n    for(int i=0;i<4;i++){\n      int ny=dy[i]+cy;\n      int nx=dx[i]+cx;\n      if(ny>=0&&nx>=0&&ny<5&&nx<5){\n        swap(field[ny][nx],field[cy][cx]);\n        dfs(depth+1,ny,nx,res);\n        swap(field[ny][nx],field[cy][cx]);\n      }\n    }\n  }\n}\n\nint main(){\n\n  while(cin>>N&&N!=-1){\n    for(int i=0;i<5;i++)\n      for(int j=0;j<5;j++)\n        cin>>field[i][j],field[i][j]--;\n    for(int i=0;i<5;i++)\n      cin>>ss[i];\n    ll res=0;\n    for(int i=0;i<5;i++)\n      for(int j=0;j<5;j++)\n        dfs(0,i,j,res);\n    cout<<res<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector<int> Vec;\ntypedef vector<Vec> Mat;\n\nMat a(5, Vec(5));\nint score[5];\n\nconst int dx[] = {-1, +0, +1, +0};\nconst int dy[] = {+0, -1, +0, +1};\n\nbool inField(int x, int y)\n{\n    return (0 <= x && x < 5 && 0 <= y && y < 5);\n}\n\nint erase(Mat &m)\n{\n    bool e[5][5] = {{}};\n    for (int i = 0; i < 5; i++) {\n        for (int j = 0; j < 5; j++) {                        \n            if (m[i][j] == 0) {\n                continue;\n            }\n            int cnt[2] = {};\n            for (int k = 0; k < 4; k++) {\n                int ni = i + dy[k];\n                int nj = j + dx[k];\n                while (inField(ni, nj) &&\n                       m[i][j] == m[ni][nj]) {\n                    ni += dy[k];\n                    nj += dx[k];\n                    ++cnt[k&1];\n                }\n            }\n            if (cnt[0] >= 2 || cnt[1] >= 2) {\n                e[i][j] = 1;\n            }\n        }\n    }\n    int point = 0;\n    for (int i = 0; i < 5; i++) {\n        for (int j = 0; j < 5; j++) {\n            if (e[i][j]) {\n                point += score[m[i][j]-1];\n                m[i][j] = 0;\n            }\n        }\n    }\n    return point;\n}\n\nvoid fall(Mat &m)\n{\n    for (int i = 4; i >= 1; i--) {\n        for (int j = 4; j >= 1; j--) {\n            if (m[i][j] == 0) {\n                for (int k = i-1; k >= 0; k--) {\n                    if (m[k][j] != 0) {\n                        m[i][j] = m[k][j];\n                        m[k][j] = 0;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}\n\nint calc(Mat &m, int bp)\n{\n    int point = erase(m) * bp;\n    fall(m);\n    return point;\n}\n\nint get_point()\n{\n    Mat b = a;\n    int point = 0, bp = 1;\n    bool update = 1;\n    \n    while (update) {\n        update = 0;        \n        Mat nb = b;\n        point += calc(nb, bp);\n        if (b != nb) {\n            update = 1;\n            bp++;\n            b = nb;\n        }\n    }\n    return point;\n}\n\nint dfs(int y, int x, int n)    \n{\n    int point = get_point();\n    if (n > 0) {\n        for (int i = 0; i < 4; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (inField(nx, ny)) {\n                swap(a[ny][nx], a[y][x]);\n                point = max(point, dfs(ny, nx, n-1));\n                swap(a[ny][nx], a[y][x]);\n            }        \n        }\n    }\n    return point;\n}\n\nint main()\n{\n    int n;\n    while (cin >> n, n != -1) {\n        for (int i = 0; i < 5; i++) {\n            for (int j = 0; j < 5; j++) {\n                cin >> a[i][j];\n            }\n        }\n    \n        for (int i = 0; i < 5; i++) {\n            cin >> score[i];\n        }\n\n        int max_point = 0;\n        for (int i = 0; i < 5; i++) {\n            for (int j = 0; j < 5; j++) {\n                max_point = max(max_point, dfs(i, j, n));\n            }\n        }   \n        cout << max_point << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nint n;\nint a[5][5];\nint s[5];\nint dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n\nint check(int d){\n  bool dis[5][5],f = false;\n  rep(i,5)rep(j,5)dis[i][j] = false;\n\n  rep(i,5)rep(j,5){\n    if(a[i][j] == 0)continue;\n\n    rep(k,2){\n      int sy = i, sx = j;\n      int c = 0;\n      while(sy>=0 && sx>=0 && sy<=4 && sx<=4 && a[sy][sx] == a[i][j]){\n\tc++; sy += dy[k]; sx += dx[k];\n      }\n      if(c>=3){\n\trep(l,c)dis[i+l*dy[k]][j+l*dx[k]] = true;\n\tf = true;\n      }\n    }\n  }\n  if(!f)return 0;\n\n  int res = 0;\n  rep(i,5)rep(j,5){\n    if(dis[i][j]){\n      res += d*s[a[i][j]-1];\n      a[i][j] = 0;\n    }\n  }\n\n  rep(i,5){\n    for(int j=4;j>=0;j--){\n      if(a[j][i] != 0){\n\tfor(int k=1;k<=4-j;k++){\n\t  if(a[j+k][i]==0)swap(a[j+k][i],a[j+k-1][i]);\n\t}\n      }\n    }\n  }\n  return res + check(d+1);\n}\n\nint move(int y,int x,int d){\n  int tmp[5][5];\n  rep(i,5)rep(j,5)tmp[i][j] = a[i][j];\n  int res = check(1);\n  rep(i,5)rep(j,5)a[i][j] = tmp[i][j];\n  if(d==n)return res;\n\n  rep(k,4){\n    int sy = y+dy[k], sx = x+dx[k];\n    if(sy<0 || sy>4 || sx<0 || sy>4)continue;\n    swap(a[y][x],a[sy][sx]);\n    res = max(res,move(sy,sx,d+1));\n    swap(a[y][x],a[sy][sx]);\n  }\n  return res;\n}     \n\nint solve(){\n  int res = 0;\n  rep(i,5)rep(j,5)res = max(res,move(i,j,0));\n  return res;\n}\n\nint main(){\n  while(cin >> n,n>=0){\n    rep(i,5)rep(j,5)cin >> a[i][j];\n    rep(i,5)cin >> s[i];\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,-1,0,1};\ntemplate<class T> constexpr bool in_range(T y, T x, T H, T W) { return 0<=y&&y<H&&0<=x&&x<W; }\n\nint N;\nint a[5][5];\nint score[6];\n\nvoid drop() {\n  rep(j, 5) {\n    deque<int> d;\n    rep(i, 5) {\n      if(a[i][j] != -1) {\n        d.push_back(a[i][j]);\n      }\n    }\n\n    int dsize = d.size();\n    for(int i=4; i>=0 && !d.empty(); i--) {\n      a[i][j] = d.back();\n      d.pop_back();\n    }\n    rep(i, 5-dsize) {\n      a[i][j] = -1;\n    }\n  }\n}\n\nint dist(int num, int i, int j, int dy, int dx, int sum = 0) {\n  i += dy, j += dx;\n  if(!in_range(i, j, 5, 5)) return sum;\n  if(a[i][j] != num) return sum;\n  return dist(num, i, j, dy, dx, sum + 1);\n}\n\nint simulate() {\n  int ret = 0;\n  int bonus = 1;\n\n  while(1) {\n    set<int> used;\n    rep(i, 5) rep(j, 5) {\n      if(a[i][j] == -1) continue;\n      int movel = dist(a[i][j], i, j, 0, -1);\n      int mover = dist(a[i][j], i, j, 0, +1);\n      int movet = dist(a[i][j], i, j, -1, 0);\n      int moveb = dist(a[i][j], i, j, +1, 0);\n      if(mover - movel + 1 >= 3) {\n        REP(x, j - movel, j + mover + 1) {\n          assert(a[i][x] != -1);\n          assert(a[i][x] == a[i][j]);\n          used.insert(i*5+x);\n        }\n      }\n      if(moveb - movet + 1 >= 3) {\n        REP(y, i - movet, i + moveb + 1) {\n          assert(a[y][j] != -1);\n          assert(a[y][j] == a[i][j]);\n          used.insert(y*5+j);\n        }\n      }\n    }\n\n    for(auto && e: used) {\n      ret += score[a[e/5][e%5]] * bonus;\n      a[e/5][e%5] = -1;\n    }\n\n    bonus ++;\n    if(!used.size()) break;\n    drop();\n  }\n\n  return ret;\n}\n\n\n\nint dfs(int y, int x, int idx = 0) {\n  int aa[5][5]; rep(i, 5) rep(j, 5) aa[i][j] = a[i][j];\n  int ret = simulate();\n  if(idx < N) {\n    rep(k, 4) {\n      int ny = y + dy[k], nx = x + dx[k];\n      if(!in_range(ny, nx, 5, 5)) continue;\n      rep(i, 5) rep(j, 5) a[i][j] = aa[i][j];\n      swap(a[y][x], a[ny][nx]);\n      maximize(ret, dfs(ny, nx, idx + 1));\n    }\n  }\n  return ret;\n}\n\nint solve() {\n  int ret = 0;\n  rep(i, 5) rep(j, 5)  {\n    maximize(ret, dfs(i, j));\n  }\n  return ret;\n}\n\nint main() {\n\n  for(; cin >> N && N >= 0;) {\n    rep(i, 5) rep(j, 5) cin >> a[i][j];\n    rep(i, 5) cin >> score[i+1];\n    cout << solve() << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, ans, point[5];\n\nvoid sim(vector<vector<int> > A){\n  \n  int sum = 0, x = 1, update = 1;\n  \n  int used[5][5];\n  \n  while(update){\n    \n    update = 0;\n    \n    memset( used, 0, sizeof(used) );\n    \n    for(int i=0;i<5;i++){\n      \n      for(int j=1;j<4;j++){\n\t\n\tif( A[i][j] == 0 ) continue;\n\t\n\tif( A[i][j-1] == A[i][j] && A[i][j] == A[i][j+1] ){\n\t  used[i][j-1] = 1;\n\t  used[i][j] = 1;\n\t  used[i][j+1] = 1;\n\t}\n\t\t\n      }\n\n    }\n\n    for(int i=1;i<4;i++){\n\n      for(int j=0;j<5;j++){\n\t\n\tif( A[i][j] == 0 ) continue;\n\t\n    \tif( A[i-1][j] == A[i][j] && A[i][j] == A[i+1][j] ){\n\t  used[i-1][j] = 1;\n\t  used[i][j] = 1;\n\t  used[i+1][j] = 1;\n\t}\n\t\n      }\n      \n    }\n\n    int cnt[5] = {};\n    \n    for(int i=0;i<5;i++){\n      \n      for(int j=0;j<5;j++){\n\t\n\tif( used[i][j] ){\n\t  cnt[A[i][j]-1]++;\n\t  A[i][j] = 0;\n\t  update = 1;\n\t}\n\t\n      }\n      \n    }\n    /*    \n    for(int i=0;i<5;i++){\n      for(int j=0;j<5;j++) cout<<A[i][j]<<' ';\n      cout<<endl;\n    }\n    */\n    \n    int update2 = 1;\n\n    while(update2){\n      \n      update2 = 0;\n      \n      for(int i=0;i<5;i++){\n\t\n\tfor(int j=4;j>=1;j--){\n\t  \n\t  if( A[j][i] == 0 && A[j-1][i] != 0 ){\n\t    \n\t    swap( A[j][i], A[j-1][i] );\n\t    \n\t    update2 = 1;\n\t    \n\t  }\n\t  \n\t}\n\t\n      }\n\n    }\n       \n    for(int i=0;i<5;i++){\n      sum += x * cnt[i] * point[i];\n    }\n    \n    x++;\n    \n  }\n  \n  ans = max( ans, sum );\n  \n}\n\nint dy[4] = {-1,0,1,0};\nint dx[4] = {0,1,0,-1};\n\nvoid dfs(int y, int x, vector<vector<int> > A, int cnt){\n  \n  if( n < cnt ) return;\n  \n  sim(A);\n  \n  for(int i=0;i<4;i++){\n    \n    int ny = y + dy[i], nx = x + dx[i];\n\n    if( ny < 0 || nx < 0 || 5 <= ny || 5 <= nx ) continue;\n    \n    swap( A[y][x], A[ny][nx] );\n    \n    dfs( ny, nx, A, cnt + 1 );\n\n    swap( A[y][x], A[ny][nx] );\n      \n  }\n  \n}\n\nint main(){\n  \n  while(1){\n    \n    cin>>n;\n    \n    if( n == -1 ) break;\n    \n    vector<vector<int> > A( 5, vector<int>(5) );\n    \n    for(int i=0;i<5;i++)\n      for(int j=0;j<5;j++) cin>>A[i][j];\n    \n    for(int i=0;i<5;i++) cin>>point[i];\n    \n    ans = 0;\n    \n    for(int i=0;i<5;i++){\n      \n      for(int j=0;j<5;j++){\n\t\n\tdfs( i, j, A, 0 );\n\t\n      }\n      \n    }\n    \n    cout << ans << endl;\n    \n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector<int> Vec;\ntypedef vector<Vec> Mat;\n\nMat a(5, Vec(5));\nint score[5];\n\nconst int dx[] = {-1, +0, +1, +0};\nconst int dy[] = {+0, -1, +0, +1};\n\nbool inField(int x, int y)\n{\n    return (0 <= x && x < 5 && 0 <= y && y < 5);\n}\n\nint erase(Mat &m)\n{\n    bool e[5][5] = {{}};\n    for (int i = 0; i < 5; i++) {\n        for (int j = 0; j < 5; j++) {                        \n            if (m[i][j] == 0) {\n                continue;\n            }\n            int cnt[2] = {1, 1};\n            for (int k = 0; k < 4; k++) {\n                int ni = i + dy[k];\n                int nj = j + dx[k];\n                while (inField(ni, nj) &&\n                       m[i][j] == m[ni][nj]) {\n                    ni += dy[k];\n                    nj += dx[k];\n                    ++cnt[k&1];\n                }\n            }\n            if (cnt[0] >= 3 || cnt[1] >= 3) {\n                e[i][j] = 1;\n            }\n        }\n    }\n    int point = 0;\n    for (int i = 0; i < 5; i++) {\n        for (int j = 0; j < 5; j++) {\n            if (e[i][j]) {\n                point += score[m[i][j]-1];\n                m[i][j] = 0;\n            }\n        }\n    }\n    return point;\n}\n\nvoid fall(Mat &m)\n{\n    for (int j = 0; j < 5; j++) {\n        for (int i = 4; i >= 1; i--) {\n            if (m[i][j] == 0) {                \n                for (int k = i-1; k >= 0; k--) {\n                    if (m[k][j] != 0) {\n                        swap(m[i][j], m[k][j]);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}\n\nint calc(Mat &m, int bp)\n{\n    int point = erase(m) * bp;\n    fall(m);\n    return point;\n}\n\nint get_point()\n{\n    Mat b = a;\n    int point = 0, bp = 1;\n    bool update = 1;\n    \n    while (update) {\n        update = 0;        \n        Mat nb = b;\n        point += calc(nb, bp++);;\n        if (nb != b) {\n        \n            update = 1;\n            b = nb;\n        }\n    }\n    return point;\n}\n\nint dfs(int y, int x, int n)    \n{\n    int point = get_point();\n    if (n > 0) {\n        for (int i = 0; i < 4; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (inField(nx, ny)) {\n                swap(a[ny][nx], a[y][x]);\n                point = max(point, dfs(ny, nx, n-1));\n                swap(a[ny][nx], a[y][x]);\n            }        \n        }\n    }\n    return point;\n}\n\nint main()\n{\n    int n;\n    while (cin >> n, n != -1) {\n        for (int i = 0; i < 5; i++) {\n            for (int j = 0; j < 5; j++) {\n                cin >> a[i][j];\n            }\n        }\n    \n        for (int i = 0; i < 5; i++) {\n            cin >> score[i];\n        }\n\n        int max_point = 0;\n        for (int i = 0; i < 5; i++) {\n            for (int j = 0; j < 5; j++) {\n                max_point = max(max_point, dfs(i, j, n));\n            }\n        }   \n        cout << max_point << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\nusing namespace std;\n\ntypedef vector<vector<int> > mat;\n\nvoid show(const mat &t){\n  cout << \"--\\n\";\n  for(int i = 0; i < 5; i++){\n    for(int j = 0; j < 5; j++){\n      printf(\"%3d\", t[i][j]);\n    }\n    cout << endl;\n  }\n}\n\nint sc[5];\nint ans;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint delBlock(mat &t, int bonus){\n  mat t_tmp = t;\n\n  for(int i = 0; i < 5; i++){\n    for(int j = 0; j < 5; j++){\n      if(t[i][j] == -1) continue;\n\n      for(int k = 0; k < 2; k++){\n        int cnt = 0;\n        int nx = j;\n        int ny = i;\n\n        while(nx < 5 && ny < 5 && t[ny][nx] == t[i][j]){\n          cnt++;\n          nx += dx[k];\n          ny += dy[k];\n        }\n\n        if(cnt < 3) continue;\n\n        nx = j;\n        ny = i;\n\n        while(nx < 5 && ny < 5 && t[ny][nx] == t[i][j]){\n          t_tmp[ny][nx] = -1;\n          nx += dx[k];\n          ny += dy[k];\n        }\n      }\n    }\n  }\n\n  bool flg = false;\n  int res = 0;\n\n  for(int i = 0; i < 5; i++){\n    for(int j = 0; j < 5; j++){\n      if(t[i][j] != -1 && t_tmp[i][j] == -1){\n        flg = true;\n        res += sc[t[i][j] - 1] * bonus;\n      }\n    }\n  }\n\n  t = t_tmp;\n\n  return flg ? res : -1;\n}\n\nvoid dropBlock(mat &t){\n  for(int i = 3; i >= 0; i--){\n    for(int j = 0; j < 5; j++){\n      if(t[i][j] == -1) continue;\n\n      int ni;\n      for(ni = i + 1; ni < 5 && t[ni][j] == -1; ni++);\n      ni--;\n      swap(t[ni][j], t[i][j]);\n    }\n  }\n}\n\nvoid dfs(int rem, mat t, int x, int y){\n  mat nt = t;\n  int bonus = 1;\n  int score = 0;\n\n  while(true){\n    int tmp = delBlock(nt, bonus);\n    if(tmp == -1) break;\n    score += tmp;\n    dropBlock(nt);\n    bonus++;\n  }\n\n  ans = max(ans, score);\n  if(rem == 0) return;\n\n  for(int i = 0; i < 4; i++){\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n    if(nx < 0 || 5 <= nx || ny < 0 || 5 <= ny) continue;\n\n    nt = t;\n    swap(nt[y][x], nt[ny][nx]);\n    dfs(rem - 1, nt, nx, ny);\n  }\n}\n\nvoid solve(mat t, int n){\n  ans = -1;\n\n  for(int i = 0; i < 5; i++){\n    for(int j = 0; j < 5; j++){\n      dfs(n, t, j, i);\n    }\n  }\n\n  cout << ans << endl;\n}\n\nint main(){\n  int n;\n\n  while(cin >> n, n != -1){\n    mat t;\n\n    for(int i = 0; i < 5; i++){\n      t.push_back(vector<int>());\n\n      for(int j = 0; j < 5; j++){\n        int x;\n        cin >> x;\n        t[i].push_back(x);\n      }\n    }\n\n    for(int i = 0; i < 5; i++){\n      cin >> sc[i];\n    }\n\n    solve(t, n);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nstatic const int N = 5;\nstatic const int di[4] = {0, -1, 0, 1};\nstatic const int dj[4] = {1, 0, -1, 0};\n\nint G[N][N], T[N][N], F[N][N];\nint P[N];\nint maxs = 0;\n\nvoid update(){\n  for ( int i = 0; i < N; i++ )\n    for ( int j = 0; j < N; j++ ) T[i][j] = G[i][j];\n  \n  int bs = 1;\n  int score = 0;\n  bool updated = false;\n  while(true){\n    updated = false;\n    for ( int i = 0; i < N; i++ )\n      for ( int j = 0; j < N; j++ ) F[i][j] = 0;\n    for ( int i = 0; i < N; i++ ){\n      for ( int j = 0; j < N-2; j++ ) {\n\tif ( T[i][j] == 0 ) continue;\n\tif ( T[i][j] == T[i][j+1] && T[i][j+1] == T[i][j+2]) {\n\t  F[i][j] = F[i][j+1] = F[i][j+2] = 1;\n\t  updated = true;\n\t}\n      }\n    }\n    for ( int i = 0; i < N-2; i++ ){\n      for ( int j = 0; j < N; j++ ) {\n\tif ( T[i][j] == 0 ) continue;\n\tif ( T[i][j] == T[i+1][j] && T[i+1][j] == T[i+2][j]) {\n\t  F[i][j] = F[i+1][j] = F[i+2][j] = 1;\n\t  updated = true;\n\t}\n      }\n    }\n    \n    for ( int i = 0; i < N; i++ ){\n      for ( int j = 0; j < N; j++ ) {\n\tif ( F[i][j] == 1 ) {\n\t  score += bs*P[T[i][j]-1];\n\t  T[i][j] = 0;\n\t}\n      }\n    }\n    \n    for ( int j = 0; j < N; j++ ){\n      for ( int i = N-1; i >= 1; i-- ){\n\tif ( T[i][j] > 0 ) continue;\n\tint p = i-1;\n\twhile( p > 0 && T[p][j] == 0 ) p--;\n\tT[i][j] = T[p][j];\n\tT[p][j] = 0;\n\tif ( p == 0 ) break;\n      }\n    }\n    \n    bs++;\n    if ( !updated ) break;\n  }\n  \n  maxs = max(maxs, score);\n}\n\nvoid dfs(int ci, int cj, int n){\n  update();\n  if ( n == 0 ) return;\n  \n  for ( int r = 0; r < 4; r++ ){\n    int ni = ci + di[r];\n    int nj = cj + dj[r];\n    if ( ni < 0 || nj < 0 || ni >= N || nj >= N ) continue;\n    swap(G[ci][cj], G[ni][nj]);\n    dfs(ni, nj, n-1);\n    swap(G[ci][cj], G[ni][nj]);\n  }\n}\n\nmain(){\n  while(true){\n    int n; cin >> n;\n    if ( n == -1 ) break;\n    for ( int i = 0; i < N; i++ )\n      for ( int j = 0; j < N; j++ )\n\tcin >> G[i][j];\n    for ( int i = 0; i < N; i++ )\n      cin >> P[i];\n    maxs = 0;\n    for ( int i = 0; i < N; i++ )\n      for ( int j = 0; j < N; j++ )\n\tdfs(i, j, n);\n    cout << maxs << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\nint n,ans;\nint a[5][5],b[6];\nint c[5][5];\n\n\nint check(){\n  int res=0;\n  for(int i=0;i<5;i++)\n    for(int j=0;j<5;j++)\n      c[i][j]=a[i][j];\n  for(int cnt=1;;cnt++){\n    bool flg[5][5]={};\n    for(int i=0;i<5;i++){\n      for(int j=0;j<5;j++){\n        if(c[i][j]==0)continue;\n        if(i+2<5&&c[i][j]==c[i+1][j]&&c[i][j]==c[i+2][j])\n          flg[i][j]=flg[i+1][j]=flg[i+2][j]=true;\n        if(j+2<5&&c[i][j]==c[i][j+1]&&c[i][j]==c[i][j+2])\n          flg[i][j]=flg[i][j+1]=flg[i][j+2]=true;\n      }\n    }\n    bool f=true;\n    for(int i=0;i<5;i++){\n      for(int j=0;j<5;j++){\n        if(!flg[i][j])continue;\n        res+=(b[c[i][j]]*cnt);\n        c[i][j]=0;\n        f=false;\n      }\n    }\n    if(f)break;\n    for(int j=0;j<5;j++){\n      int k=4;\n      for(int i=4;i>=0;i--)if(c[i][j])c[k--][j]=c[i][j];\n      for(int i=k;i>=0;i--)c[i][j]=0;\n    }\n  }\n  return res;\n}\n\nvoid dfs(int y,int x,int d,int prev){\n  ans=max(ans,check());\n  if(d==n)return;\n  for(int i=0;i<4;i++){\n    if((i+2)%4==prev)continue;\n    int ny=y+dy[i];\n    int nx=x+dx[i];\n    if(ny<0||nx<0)continue;\n    if(ny>4||nx>4)continue;\n    swap(a[ny][nx],a[y][x]);\n    dfs(ny,nx,d+1,i);\n    swap(a[ny][nx],a[y][x]);\n  }\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==-1)break;\n    for(int i=0;i<5;i++)\n      for(int j=0;j<5;j++)\n        cin>>a[i][j];\n    for(int i=1;i<=5;i++)cin>>b[i];\n    ans=0;\n    for(int i=0;i<5;i++)\n      for(int j=0;j<5;j++)\n        dfs(i,j,0,-1);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<int, bool>P;\n \nint s[5], dx[]{ 1,-1,0,0, }, dy[]{ 0,0,1,-1 };\nvector<vector<int>>a(5, vector<int>(5));\nint Max,n;\nvoid dfs(int x, int y, int c) {\n\tif(c==0||n%2!=0){\n    vector<vector<P>>b(5, vector<P>(5));\n    rep(i, 5)rep(j, 5)b[i][j].first = a[i][j];\n    bool update = true;\n    int p = 0;\n    for (int v = 1; update; v++) {\n        update = false;\n        rep(i, 5) {\n            int back = 0, cnt = 0;\n            rep(j, b[i].size()) {\n                if (back != b[i][j].first) {\n                    if (cnt >= 3) {\n                        for (int k = 1; k <= cnt; k++)\n                            b[i][j - k].second = 1;\n                    }\n                    cnt = 0;\n                }\n                back = b[i][j].first; cnt++;\n            }\n            if (cnt >= 3) {\n                for (int k = 1; k <= cnt; k++)\n                    b[i][b[i].size() - k].second = 1;\n            }\n        }\n        rep(i, 5) {\n            int back = 0, cnt = 0;\n            rep(j, 5) {\n                if (b[j].size() <= i || back != b[j][i].first) {\n                    if (cnt >= 3) {\n                        for (int k = 1; k <= cnt; k++)\n                            b[j - k][i].second = 1;\n                    }\n                    cnt = 0;\n                }\n                if (i < b[j].size()) {\n                    back = b[j][i].first; cnt++;\n                }\n            }\n            if (cnt >= 3) {\n                for (int k = 1; k <= cnt; k++)b[5 - k][i].second = 1;\n            }\n        }\n        rep(i, 5)rep(j, b[i].size()) {\n            if (b[i][j].second == 1) {\n                p += v*s[b[i][j].first];\n                b[i].erase(b[i].begin() + j); update = true; j--;\n            }\n        }\n    }\n    Max = max(Max, p);}\n    if (c == 0)return;\n    rep(i, 4) {\n        int nx = x + dx[i], ny = y + dy[i];\n        if (0 <= nx&&nx < 5 && 0 <= ny&&ny < 5) {\n            swap(a[x][y], a[nx][ny]);\n            dfs(nx, ny, c - 1);\n            swap(a[x][y], a[nx][ny]);\n        }\n    }\n}\nint main() {\n    while (scanf(\"%d\", &n), ~n) {\n        Max = 0;\n        rep(i, 5)rep(j, 5)scanf(\"%d\", &a[j][i]), a[j][i]--;\n        rep(i, 5)reverse(a[i].begin(), a[i].end());\n        rep(i, 5)scanf(\"%d\", &s[i]);\n        rep(i, 5)rep(j, 5)dfs(i, j, n);\n        printf(\"%d\\n\", Max);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector<int> Vec;\ntypedef vector<Vec> Mat;\n\nMat a(5, Vec(5));\nint score[5];\n\nconst int dx[] = {-1, +0, +1, +0};\nconst int dy[] = {+0, -1, +0, +1};\n\nbool inField(int x, int y)\n{\n    return (0 <= x && x < 5 && 0 <= y && y < 5);\n}\n\nint erase(Mat &m)\n{\n    bool e[5][5] = {{}};\n    for (int i = 0; i < 5; i++) {\n        for (int j = 0; j < 5; j++) {                        \n            if (m[i][j] == 0) {\n                continue;\n            }\n            int cnt[2] = {1, 1};\n            for (int k = 0; k < 4; k++) {\n                int ni = i + dy[k];\n                int nj = j + dx[k];\n                while (inField(ni, nj) &&\n                       m[i][j] == m[ni][nj]) {\n                    ni += dy[k];\n                    nj += dx[k];\n                    ++cnt[k&1];\n                }\n            }\n            if (cnt[0] >= 3 || cnt[1] >= 3) {\n                e[i][j] = 1;\n            }\n        }\n    }\n    int point = 0;\n    for (int i = 0; i < 5; i++) {\n        for (int j = 0; j < 5; j++) {\n            if (e[i][j]) {\n                point += score[m[i][j]-1];\n                m[i][j] = 0;\n            }\n        }\n    }\n    return point;\n}\n\nvoid fall(Mat &m)\n{\n    for (int j = 4; j >= 1; j--) {\n        for (int i = 4; i >= 1; i--) {\n            if (m[i][j] == 0) {                \n                for (int k = i-1; k >= 0; k--) {\n                    if (m[k][j] != 0) {\n                        swap(m[i][j], m[k][j]);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}\n\nint calc(Mat &m, int bp)\n{\n    int point = erase(m) * bp;\n    fall(m);\n    return point;\n}\n\nint get_point()\n{\n    Mat b = a;\n    int point = 0, bp = 1;\n    bool update = 1;\n    \n    while (update) {\n        update = 0;        \n        Mat nb = b;\n        point += calc(nb, bp);\n        if (b != nb) {\n            update = 1;\n            bp++;\n            b = nb;\n        }\n    }\n    return point;\n}\n\nint dfs(int y, int x, int n)    \n{\n    int point = get_point();\n    if (n > 0) {\n        for (int i = 0; i < 4; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (inField(nx, ny)) {\n                swap(a[ny][nx], a[y][x]);\n                point = max(point, dfs(ny, nx, n-1));\n                swap(a[ny][nx], a[y][x]);\n            }        \n        }\n    }\n    return point;\n}\n\nint main()\n{\n    int n;\n    while (cin >> n, n != -1) {\n        for (int i = 0; i < 5; i++) {\n            for (int j = 0; j < 5; j++) {\n                cin >> a[i][j];\n            }\n        }\n    \n        for (int i = 0; i < 5; i++) {\n            cin >> score[i];\n        }\n\n        int max_point = 0;\n        for (int i = 0; i < 5; i++) {\n            for (int j = 0; j < 5; j++) {\n                max_point = max(max_point, dfs(i, j, n));\n            }\n        }   \n        cout << max_point << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint b[6][6];\nint c[6];\nint n;\nint t[6][6];\nint v[6][6];\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint f[6][6];\nint calc(){\n\tint ret=0;\n\tint s=1;\n\tfor(int i=0;i<5;i++)for(int j=0;j<5;j++)v[i][j]=t[i][j];\n\tbool chg=false;\n\tdo{\n\t\tchg=false;\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<5;j++)f[i][j]=0;\n\t\tfor(int i=0;i<5;i++){\n\t\t\tint now=0;\n\t\t\tint val=-1;\n\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\tif(val!=v[i][j]){\n\t\t\t\t\tif(now>=3&&val){\n\t\t\t\t\t\tchg=true;\n\t\t\t\t\t\tfor(int k=j-now;k<j;k++)f[i][k]=1;\n\t\t\t\t\t}\n\t\t\t\t\tnow=1;val=v[i][j];\n\t\t\t\t}else now++;\n\t\t\t}\n\t\t\tif(now>=3&&val){\n\t\t\t\tchg=true;\n\t\t\t\tfor(int k=5-now;k<5;k++)f[i][k]=1;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<5;i++){\n\t\t\tint now=0;\n\t\t\tint val=-1;\n\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\tif(val!=v[j][i]){\n\t\t\t\t\tif(now>=3&&val){\n\t\t\t\t\t\tchg=true;\n\t\t\t\t\t\tfor(int k=j-now;k<j;k++)f[k][i]=1;\n\t\t\t\t\t}\n\t\t\t\t\tnow=1;val=v[j][i];\n\t\t\t\t}else now++;\n\t\t\t}\n\t\t\tif(now>=3&&val){\n\t\t\t\tchg=true;\n\t\t\t\tfor(int k=5-now;k<5;k++)f[k][i]=1;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<5;j++){\n\t\t\tif(f[i][j]){ret+=s*c[v[i][j]];v[i][j]=0;}\n\t\t}\n\t\tfor(int i=0;i<5;i++){\n\t\t\tint at=4;\n\t\t\tfor(int j=4;j>=0;j--){\n\t\t\t\tif(v[j][i])v[at--][i]=v[j][i];\n\t\t\t}\n\t\t\tfor(int j=0;j<=at;j++)v[j][i]=0;\n\t\t}\n\t\ts++;\n\t}while(chg);\n\treturn ret;\n}\nint solve(int a,int b,int c){\n\tif(c==n){\n\t\treturn calc();\n\t}\n\tint ret=calc();\n\tfor(int i=0;i<4;i++){\n\t\tif(0<=a+dx[i]&&a+dx[i]<5&&0<=b+dy[i]&&b+dy[i]<5){\n\t\t\tswap(t[a][b],t[a+dx[i]][b+dy[i]]);\n\t\t\tret=max(ret,solve(a+dx[i],b+dy[i],c+1));\n\t\t\tswap(t[a][b],t[a+dx[i]][b+dy[i]]);\n\t\t}\n\t}\n\treturn ret;\n}\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),~a){\n\t\tn=a;\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<5;j++)scanf(\"%d\",&b[i][j]);\n\t\tfor(int i=0;i<5;i++)scanf(\"%d\",c+i+1);\n\t\tint ret=0;\n\t\tfor(int i=0;i<5;i++){\n\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\tfor(int k=0;k<5;k++)for(int l=0;l<5;l++){\n\t\t\t\t\tt[k][l]=b[k][l];\n\t\t\t\t}\n\t\t\t\tret=max(ret,solve(i,j,0));\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EMPTY 0\n\nusing namespace std;\n\ntypedef long long ll;\nll LLINF = LLONG_MAX;\n\nint n,a[5][5],tmp[5][5];\nll score[5],maxi;\nint dx[] = {0,1,0,-1}; // ???,???,?????????\nint dy[] = {1,0,-1,0};\nbool used[5][5];\n\ninline bool isValid(int x,int y) { return 0 <= x && x < 5 && 0 <= y && y < 5; }\n\nvoid update(){\n\n  rep(i,5) rep(j,5) tmp[i][j] = a[i][j];\n  ll point = 0, phase = 0;\n  bool update = true;\n  while( update ){\n    ++phase;\n    update = false;\n    memset(used,false,sizeof(used));\n    rep(y,5){\n      rep(x,5){\n        if(  a[y][x] == EMPTY ) continue;\n        rep(i,2) {\n          int cnt = 0;\n          int cx = x, cy = y, color = a[cy][cx];\n          while( isValid(cx,cy) && a[cy][cx] == color ) {\n            ++cnt, cx += dx[i], cy += dy[i];\n          }\n          if( cnt >= 3 ) {\n            update = true;\n            cx = x, cy = y;\n            while( isValid(cx,cy) && a[cy][cx] == color ) {\n              used[cy][cx] = true;\n              ++cnt, cx += dx[i], cy += dy[i];\n            } \n          }\n        }\n      }\n    }\n    ll sum = 0;\n    rep(y,5) rep(x,5) if( used[y][x] ) {\n      assert( 1 <= a[y][x] && a[y][x] <= 5 );\n      sum += score[a[y][x]-1] * phase;\n      a[y][x] = EMPTY;\n    }\n    point += sum;\n    rep(x,5){\n      for(int y=4;y>=0;y--) if( a[y][x] != EMPTY ) {\n          int cx = x + dx[0], cy = y + dy[0];\n          while( isValid(cx,cy) && a[cy][cx] == EMPTY ){\n            swap(a[cy][cx],a[cy+dy[2]][cx+dx[2]]);\n            cx += dx[0], cy += dy[0];\n          }          \n      }\n    }\n  }\n  maxi = max(maxi,point);\n  rep(i,5) rep(j,5) a[i][j] = tmp[i][j];\n}\n\nvoid dfs(int cx,int cy,int prev,int depth){\n  update();\n  if( depth >= n ) return;\n\n  rep(i,4) if( ( i + 2 ) % 4 != prev ) {\n    int nx = cx + dx[i], ny = cy + dy[i];\n    if( !isValid(nx,ny) ) continue;\n    swap(a[ny][nx],a[cy][cx]);\n    dfs(nx,ny,i,depth+1);\n    swap(a[ny][nx],a[cy][cx]);\n  }\n}\n\nvoid compute(){\n  maxi = -LLINF;\n  rep(i,5) rep(j,5) dfs(j,i,-1,0);\n  cout << maxi << endl;\n}\n\nint main(){\n  while( cin >> n, n != -1 ){\n    rep(i,5) rep(j,5) cin >> a[i][j];\n    rep(i,5) cin >> score[i];\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n//// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\n\nvector<int>ss(5);\nvoid  fall(vector<vector<int>>&field) {\n\tfor (int t = 0; t < 5; ++t) {\n\t\tfor (int y = 4; y > 0; --y) {\n\t\t\tfor (int x = 0; x < 5; ++x) {\n\t\t\t\tif (field[y][x] == 0 && field[y - 1][x]) {\n\t\t\t\t\tswap(field[y][x], field[y - 1][x]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint getscore(vector<vector<int>>field) {\n\tint bonus = 1;\n\tint ans = 0;\n\tint num = 10;\n\twhile (num--) {\n\n\t\tvector<vector<int>>del(5, vector<int>(5));\n\t\t{\n\t\t\tfor (int x = 0; x < 5; ++x) {\n\t\t\t\tfor (int u = 0; u < 3; ++u) {\n\t\t\t\t\tint c = field[u][x];\n\t\t\t\t\tif (!c)continue;\n\t\t\t\t\tint num = 0;\n\t\t\t\t\tfor (int y = u; y < 5; ++y) {\n\t\t\t\t\t\tif (field[y][x] == c) {\n\t\t\t\t\t\t\tnum++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (num >= 3) {\n\t\t\t\t\t\tfor (int y = u; y < u + num; ++y) {\n\t\t\t\t\t\t\tdel[y][x] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int y = 0; y < 5; ++y) {\n\t\t\t\tfor (int l = 0; l < 3; ++l) {\n\t\t\t\t\tint c = field[y][l];\n\t\t\t\t\tif (!c)continue;\n\t\t\t\t\tint num = 0;\n\t\t\t\t\tfor (int x = l; x < 5; ++x) {\n\t\t\t\t\t\tif (field[y][x] == c) {\n\t\t\t\t\t\t\tnum++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (num >= 3) {\n\t\t\t\t\t\tfor (int x = l; x < l + num; ++x) {\n\t\t\t\t\t\t\tdel[y][x] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int y = 0; y < 5; ++y) {\n\t\t\tfor (int x = 0; x < 5; ++x) {\n\t\t\t\tif (del[y][x]) {\n\t\t\t\t\tans += ss[field[y][x]-1] * bonus;\n\t\t\t\t\tfield[y][x] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfall(field);\n\n\t\tbonus++;\n\t}\n\treturn ans;\n}\nint dx[4] = { -1,0,1,0 };\nint dy[4] = { 0,1,0,-1 };\nint solve(vector<vector<int>>field, int rest,int x,int y) {\n\tint ans = getscore(field);\n\tif (rest) {\n\t\tfor (int way = 0; way < 4; ++way) {\n\t\t\tint nx = x + dx[way];\n\t\t\tint ny = y + dy[way];\n\t\t\tif (nx >= 0 && nx < 5 && ny >= 0 && ny < 5) {\n\t\t\t\tswap(field[y][x], field[ny][nx]);\n\t\t\t\tans = max(ans, solve(field, rest - 1, nx, ny));\n\t\t\t\tswap(field[y][x], field[ny][nx]);\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main() {\n\twhile (1) {\n\t\tint N; cin >> N;\n\t\tif (N == -1)break;\n\t\tvector<vector<int>>field(5, vector<int>(5));\n\t\tfor (int i = 0; i < 5; ++i) {\n\t\t\tfor (int j = 0; j < 5; ++j) {\n\t\t\t\tint a; cin >> a; field[i][j] = a;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 5; ++i) {\n\t\t\tcin >> ss[i];\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < 5; ++i) {\n\t\t\tfor (int j = 0; j < 5; ++j) {\n\t\t\t\tans = max(ans, solve(field, N, i, j));\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<int, int>P;\n\nint s[5], dx[]{ 1,-1,0,0, }, dy[]{ 0,0,1,-1 };\nvector<vector<int>>a(5, vector<int>(5));\nint Max;\nvoid dfs(int x, int y, int c) {\n\tif (c == 0) {\n\t\tvector<vector<P>>b(5, vector<P>(5));\n\t\trep(i, 5)rep(j, 5)b[i][j].first = a[i][j];\n\t\tbool update = true;\n\t\tint p = 0;\n\t\tfor (int v = 1; update; v++) {\n\t\t\tupdate = false;\n\t\t\trep(i, 5) {\n\t\t\t\tint back = 0, cnt = 0;\n\t\t\t\trep(j, b[i].size()) {\n\t\t\t\t\tif (back != b[i][j].first) {\n\t\t\t\t\t\tif (cnt >= 3) {\n\t\t\t\t\t\t\tfor (int k = 1; k <= cnt; k++)\n\t\t\t\t\t\t\t\tb[i][j - k].second = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcnt = 0;\n\t\t\t\t\t}\n\t\t\t\t\tback = b[i][j].first; cnt++;\n\t\t\t\t}\n\t\t\t\tif (cnt >= 3) {\n\t\t\t\t\tfor (int k = 1; k <= cnt; k++)\n\t\t\t\t\t\tb[i][b[i].size() - k].second = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i, 5) {\n\t\t\t\tint back = 0, cnt = 0;\n\t\t\t\trep(j, 5) {\n\t\t\t\t\tif (b[j].size() <= i || back != b[j][i].first) {\n\t\t\t\t\t\tif (cnt >= 3) {\n\t\t\t\t\t\t\tfor (int k = 1; k <= cnt; k++)\n\t\t\t\t\t\t\t\tb[j - k][i].second = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcnt = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (i < b[j].size()) {\n\t\t\t\t\t\tback = b[j][i].first; cnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (cnt >= 3) {\n\t\t\t\t\tfor (int k = 1; k <= cnt; k++)b[5 - k][i].second = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i, 5)rep(j, b[i].size()) {\n\t\t\t\tif (b[i][j].second == 1) {\n\t\t\t\t\tp += v*s[b[i][j].first];\n\t\t\t\t\tb[i].erase(b[i].begin() + j); update = true; j--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tMax = max(Max, p);\n\t\treturn;\n\t}\n\trep(i, 4) {\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tif (0 <= nx&&nx < 5 && 0 <= ny&&ny < 5) {\n\t\t\tswap(a[x][y], a[nx][ny]);\n\t\t\tdfs(nx, ny, c - 1);\n\t\t\tswap(a[x][y], a[nx][ny]);\n\t\t}\n\t}\n}\nint main() {\n\tint n;\n\twhile (scanf(\"%d\", &n), ~n) {\n\t\tMax = 0;\n\t\trep(i, 5)rep(j, 5)scanf(\"%d\", &a[j][i]), a[j][i]--;\n\t\trep(i, 5)reverse(a[i].begin(), a[i].end());\n\t\trep(i, 5)scanf(\"%d\", &s[i]);\n\t\trep(i, 5)rep(j, 5) {\n\t\t\tdfs(i, j, n);\n\t\t}\n\t\tprintf(\"%d\\n\", Max);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint score[6];\n\nint ans = 0;\n\nvoid fallBlock(int mas[5][5])\n{\n  for(int i = 4; i > 0; i--){\n    for(int j = 0; j < 5; j++){\n      if(mas[i][j] == 0){\n\tswap(mas[i-1][j], mas[i][j]);\n      }\n    }\n  }\n\n  return;\n}\nvoid fallBlock(int mas[5][5])\n{\n  for(int i = 4; i > 0; i--){\n    for(int j = 0; j < 5; j++){\n      if(mas[i][j] == 0){\n\tswap(mas[i-1][j], mas[i][j]);\n      }\n    }\n  }\n\n  return;\n}\n\nint getPoint(int mas[5][5])\n{\n  int point = 0;\n  \n  for(int i = 0; i < 3; i++){\n    for(int j = 0; j < 5; j++){\n      if(abs(mas[i][j]) == abs(mas[i+1][j]) &&\n\t abs(mas[i][j]) == abs(mas[i+2][j])){\n\tmas[i][j] = mas[i+1][j] = mas[i+2][j] = -abs(mas[i][j]);\n      }\n    }\n  }\n  for(int i = 0; i < 5; i++){\n    for(int j = 0; j < 3; j++){\n      if(abs(mas[i][j]) == abs(mas[i][j+1]) &&\n\t abs(mas[i][j]) == abs(mas[i][j+2])){\n\tmas[i][j] = mas[i][j+1] = mas[i][j+2] = -abs(mas[i][j]);\n      }\n    }\n  }\n  \n  for(int i = 0; i < 5; i++){\n    for(int j = 0; j < 5; j++){\n      point += (mas[i][j] < 0) * score[-mas[i][j]];\n      mas[i][j] = 0;\n    }\n  }\n\n  fallBlock(mas);\n\n  return point;\n}\n\nvoid dfs(int y, int x, int n, int mas[5][5])\n{\n  static int dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n  int p = 0;\n  \n  if(n > 0){\n    for(int i = 0; i < 4; i++){\n      int nx = x + dx[i], ny = y + dy[i];\n      if(n > 0 && 0 <= nx && nx < 5 && 0 <= ny && ny < 5){\n\tint tmp[5][5];\n\tfor(int k = 0; k < 5; k++){\n\t  for(int l = 0; l < 5; l++) tmp[k][l] = mas[k][l];\n\t}\n\tswap(tmp[y][x], tmp[ny][nx]);\n\tdfs(ny, nx, n-1, tmp);\n      }\n    }\n  }\n  \n  for(int bonus = 1, get = getPoint(mas); get > 0; bonus++, get = getPoint(mas))\n    p += get * bonus;\n  ans = max(ans, p);\n\n  return;\n}\n\nint main()\n{\n  int n;\n  int mas[5][5];\n  \n  while(cin >> n, n != -1){\n    ans = 0;\n    for(int i = 0; i < 5; i++){\n      for(int j = 0; j < 5; j++) cin >> mas[i][j];\n    }\n    for(int i = 1; i <= 5; i++) cin >> score[i];\n    \n    for(int i = 0; i < 5; i++){\n      for(int j = 0; j < 5; j++){\n\tint tmp[5][5];\n\tfor(int k = 0; k < 5; k++){\n\t  for(int l = 0; l < 5; l++) tmp[k][l] = mas[k][l];\n\t}\n\tdfs(i, j, n, tmp);\n      }\n    }\n    \n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<int, bool>P;\n\nint s[5], dx[]{ 1,-1,0,0, }, dy[]{ 0,0,1,-1 };\nvector<vector<int>>a(5, vector<int>(5));\nint Max;\nvoid dfs(int x, int y, int c) {\n\tif (c == 0) {\n\t\tvector<vector<P>>b(5, vector<P>(5));\n\t\trep(i, 5)rep(j, 5)b[i][j].first = a[i][j];\n\t\tbool update = true;\n\t\tint p = 0;\n\t\tfor (int v = 1; update; v++) {\n\t\t\tupdate = false;\n\t\t\trep(i, 5) {\n\t\t\t\tint back = -1, cnt = 0;\n\t\t\t\trep(j, b[i].size()) {\n\t\t\t\t\tif (back != b[i][j].first) {\n\t\t\t\t\t\tif (cnt >= 3) {\n\t\t\t\t\t\t\tfor (int k = 1; k <= cnt; k++)\n\t\t\t\t\t\t\t\tb[i][j - k].second = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcnt = 0;\n\t\t\t\t\t}\n\t\t\t\t\tback = b[i][j].first; cnt++;\n\t\t\t\t}\n\t\t\t\tif (cnt >= 3) {\n\t\t\t\t\tfor (int k = 1; k <= cnt; k++)\n\t\t\t\t\t\tb[i][b[i].size() - k].second = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i, 5) {\n\t\t\t\tint back = -1, cnt = 0;\n\t\t\t\trep(j, 5) {\n\t\t\t\t\tif (b[j].size() <= i || back != b[j][i].first) {\n\t\t\t\t\t\tif (cnt >= 3) {\n\t\t\t\t\t\t\tfor (int k = 1; k <= cnt; k++)\n\t\t\t\t\t\t\t\tb[j - k][i].second = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcnt = 0;\n\t\t\t\t\t}\n\t\t\t\t\tback = -1;\n\t\t\t\t\tif (i < b[j].size()) {\n\t\t\t\t\t\tback = b[j][i].first; cnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (cnt >= 3) {\n\t\t\t\t\tfor (int k = 1; k <= cnt; k++)b[5 - k][i].second = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i, 5)rep(j, b[i].size()) {\n\t\t\t\tif (b[i][j].second == 1) {\n\t\t\t\t\tp += v*s[b[i][j].first];\n\t\t\t\t\tb[i].erase(b[i].begin() + j); update = true; j--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tMax = max(Max, p);\n\t\treturn;\n\t}\n\trep(i, 4) {\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tif (0 <= nx&&nx < 5 && 0 <= ny&&ny < 5) {\n\t\t\tswap(a[x][y], a[nx][ny]);\n\t\t\tdfs(nx, ny, c - 1);\n\t\t\tswap(a[x][y], a[nx][ny]);\n\t\t}\n\t}\n}\nint main() {\n\tint n;\n\twhile (scanf(\"%d\", &n), ~n) {\n\t\tMax = 0;\n\t\trep(i, 5)rep(j, 5)scanf(\"%d\", &a[j][i]), a[j][i]--;\n\t\trep(i, 5)reverse(a[i].begin(), a[i].end());\n\t\trep(i, 5)scanf(\"%d\", &s[i]);\n\t\trep(i, 5)rep(j, 5)dfs(i, j, n);\n\t\tprintf(\"%d\\n\", Max);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nint n;\nint a[5][5];\nint s[5];\nint dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n\nint check(void){\n  int res = 0;\n  for(int d=1;;d++){\n    bool dis[5][5] = {0},f = false;\n    rep(i,5)rep(j,5){\n      if(a[i][j] == 0)continue;\n      \n      rep(k,2){\n\tint sy = i, sx = j;\n\tint c = 0;\n\twhile(sy>=0 && sx>=0 && sy<=4 && sx<=4 && a[sy][sx] == a[i][j]){\n\t  c++; sy += dy[k]; sx += dx[k];\n\t}\n\tif(c<3)continue;\n\t\n\tf = true;\n\tsy = i; sx = j;\n\twhile(sy>=0 && sx>=0 && sy<=4 && sx<=4 && a[sy][sx] == a[i][j]){\n\t  dis[sy][sx] = true;\n\t  sy += dy[k]; sx += dx[k];\n\t}\n      }\n    }\n    if(!f)return res;\n\n    rep(i,5)rep(j,5){\n      if(dis[i][j]){\n\tres += d*s[a[i][j]-1];\n\ta[i][j] = 0;\n      }\n    }\n    \n    rep(i,5){\n      for(int j=4;j>=0;j--){\n\tif(a[j][i] != 0){\n\t  for(int k=1;k<=4-j;k++){\n\t    if(a[j+k][i]==0)swap(a[j+k][i],a[j+k-1][i]);\n\t  }\n\t}\n      }\n    }\n  }\n}\n\nint move(int y,int x,int d){\n  int tmp[5][5];\n  rep(i,5)rep(j,5)tmp[i][j] = a[i][j];\n  int res = check();\n  rep(i,5)rep(j,5)a[i][j] = tmp[i][j];\n  if(d==n)return res;\n\n  rep(k,4){\n    int sy = y+dy[k], sx = x+dx[k];\n    if(sy<0 || sy>4 || sx<0 || sx>4)continue;\n    swap(a[y][x],a[sy][sx]);\n    res = max(res,move(sy,sx,d+1));\n    swap(a[y][x],a[sy][sx]);\n  }\n  return res;\n}     \n\nint solve(){\n  int res = 0;\n  rep(i,5)rep(j,5)res = max(res,move(i,j,0));\n  return res;\n}\n\nint main(){\n  while(cin >> n,n>=0){\n    rep(i,5)rep(j,5)cin >> a[i][j];\n    rep(i,5)cin >> s[i];\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector<int> Vec;\ntypedef vector<Vec> Mat;\n\nMat a(5, Vec(5));\nint score[5];\n\nconst int dx[] = {-1, +0, +1, +0};\nconst int dy[] = {+0, -1, +0, +1};\n\nbool inField(int x, int y)\n{\n    return (0 <= x && x < 5 && 0 <= y && y < 5);\n}\n\nint erase(Mat &m)\n{\n    bool e[5][5] = {{}};\n    for (int i = 0; i < 5; i++) {\n        for (int j = 0; j < 5; j++) {                        \n            if (m[i][j] == 0) {\n                continue;\n            }\n            int cnt[2] = {1, 1};\n            for (int k = 0; k < 4; k++) {\n                int ni = i + dy[k];\n                int nj = j + dx[k];\n                while (inField(ni, nj) &&\n                       m[i][j] == m[ni][nj]) {\n                    ni += dy[k];\n                    nj += dx[k];\n                    ++cnt[k&1];\n                }\n            }\n            if (cnt[0] >= 3 || cnt[1] >= 3) {\n                e[i][j] = 1;\n            }\n        }\n    }\n    int point = 0;\n    for (int i = 0; i < 5; i++) {\n        for (int j = 0; j < 5; j++) {\n            if (e[i][j]) {\n                point += score[m[i][j]-1];\n                m[i][j] = 0;\n            }\n        }\n    }\n    return point;\n}\n\nvoid fall(Mat &m)\n{\n    for (int j = 0; j < 5; j++) {\n        for (int i = 4; i >= 1; i--) {\n            if (m[i][j] == 0) {                \n                for (int k = i-1; k >= 0; k--) {\n                    if (m[k][j] != 0) {\n                        swap(m[i][j], m[k][j]);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}\n\nint calc(Mat &m, int bp)\n{\n    int point = erase(m) * bp;\n    fall(m);\n    return point;\n}\n\nint get_point()\n{\n    Mat b = a;\n    int point = 0, bp = 1;\n    bool update = 1;\n    \n    while (update) {\n        update = 0;        \n        Mat nb = b;\n        point += calc(nb, bp);\n        if (nb != b) {        \n            update = 1;\n            b = nb;\n            bp++;\n        }\n    }\n    return point;\n}\n\nint dfs(int y, int x, int n)    \n{\n    int point = get_point();\n    if (n > 0) {\n        for (int i = 0; i < 4; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (inField(nx, ny)) {\n                swap(a[ny][nx], a[y][x]);\n                point = max(point, dfs(ny, nx, n-1));\n                swap(a[ny][nx], a[y][x]);\n            }        \n        }\n    }\n    return point;\n}\n\nint main()\n{\n    int n;\n    while (cin >> n, n != -1) {\n        for (int i = 0; i < 5; i++) {\n            for (int j = 0; j < 5; j++) {\n                cin >> a[i][j];\n            }\n        }\n    \n        for (int i = 0; i < 5; i++) {\n            cin >> score[i];\n        }\n\n        int max_point = 0;\n        for (int i = 0; i < 5; i++) {\n            for (int j = 0; j < 5; j++) {\n                max_point = max(max_point, dfs(i, j, n));\n            }\n        }   \n        cout << max_point << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\nusing namespace std;\ntypedef long long LL;\nint N;\nconst int W = 5;\nconst int H = 5;\nconst int M = 5;\nint a[5][5];\nint score[5];\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nbool valid(int x) {\n    return 0 <= x && x < 5;\n}\n\nint eval() {\n    int b[5][5];\n    memcpy(b, a, sizeof(a));\n    int bonus = 0;\n    int ans = 0;\n    while(true) {\n        bool update = false;\n        bool remove[5][5] = {};\n        REP(y, H) for(int sx = 0; sx + 2 < W; sx++) {\n            if(b[y][sx] == b[y][sx+1] && b[y][sx] == b[y][sx+2]) {\n                if(b[y][sx] != 0) {\n                    REP(xd, 3) remove[y][sx+xd] = true;\n                }\n            }\n        }\n        REP(x, W) for(int sy = 0; sy + 2 < H; sy++) {\n            if(b[sy][x] == b[sy+1][x] && b[sy][x] == b[sy+2][x]) {\n                if(b[sy][x] != 0) {\n                    REP(yd, 3) remove[sy+yd][x] = true;\n                }\n            }\n        }\n        REP(y, H) REP(x, W) if(remove[y][x]) {\n            assert(b[y][x] != 0);\n            ans += score[b[y][x]-1] * (bonus + 1);\n\n            b[y][x] = 0;\n            update = true;\n        }\n        int c[5][5] = {};\n        REP(x, 5) for(int y = 4, cy = 4; y >= 0; y--) {\n            if(b[y][x] != 0) {\n                c[cy--][x] = b[y][x];\n            }\n        }\n        memcpy(b, c, sizeof(b));\n\n        if(!update) break;\n        bonus += 1;\n    }\n    return ans;\n}\n\nint dfs(int x, int y, int k) {\n    int res = eval();\n    if(k == N) return res;\n    REP(r, 4) {\n        int nx = x + dx[r];\n        int ny = y + dy[r];\n        if(valid(nx) && valid(ny)) {\n            swap(a[y][x], a[ny][nx]);\n            res = max(res, dfs(nx, ny, k+1));\n            swap(a[y][x], a[ny][nx]);\n        }\n    }\n    return res;\n}\n\nint main(){\n    while(cin >> N && N != -1) {\n        REP(y, H) REP(x, W) cin >> a[y][x];\n        REP(i, M) cin >> score[i];\n\n        int ans = INT_MIN;\n        REP(sy, H) REP(sx, W) {\n            ans = max(ans, dfs(sx, sy, 0));\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<int, bool>P;\n\nint s[5], dx[]{ 1,-1,0,0, }, dy[]{ 0,0,1,-1 };\nvector<vector<int>>a(5, vector<int>(5));\nint Max;\nvoid dfs(int x, int y, int c) {\n\tif (c == 0) {\n\t\tvector<vector<P>>b(5, vector<P>(5));\n\t\trep(i, 5)rep(j, 5)b[i][j].first = a[i][j];\n\t\tbool update = true;\n\t\tint p = 0;\n\t\tfor (int v = 1; update; v++) {\n\t\t\tupdate = false;\n\t\t\trep(i, 5) {\n\t\t\t\tint back = 0, cnt = 0;\n\t\t\t\trep(j, b[i].size()) {\n\t\t\t\t\tif (back != b[i][j].first) {\n\t\t\t\t\t\tif (cnt >= 3) {\n\t\t\t\t\t\t\tfor (int k = 1; k <= cnt; k++)\n\t\t\t\t\t\t\t\tb[i][j - k].second = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcnt = 0;\n\t\t\t\t\t}\n\t\t\t\t\tback = b[i][j].first; cnt++;\n\t\t\t\t}\n\t\t\t\tif (cnt >= 3) {\n\t\t\t\t\tfor (int k = 1; k <= cnt; k++)\n\t\t\t\t\t\tb[i][b[i].size() - k].second = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i, 5) {\n\t\t\t\tint back = 0, cnt = 0;\n\t\t\t\trep(j, 5) {\n\t\t\t\t\tif (b[j].size() <= i || back != b[j][i].first) {\n\t\t\t\t\t\tif (cnt >= 3) {\n\t\t\t\t\t\t\tfor (int k = 1; k <= cnt; k++)\n\t\t\t\t\t\t\t\tb[j - k][i].second = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcnt = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (i < b[j].size()) {\n\t\t\t\t\t\tback = b[j][i].first; cnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (cnt >= 3) {\n\t\t\t\t\tfor (int k = 1; k <= cnt; k++)b[5 - k][i].second = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i, 5)rep(j, b[i].size()) {\n\t\t\t\tif (b[i][j].second == 1) {\n\t\t\t\t\tp += v*s[b[i][j].first];\n\t\t\t\t\tb[i].erase(b[i].begin() + j); update = true; j--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tMax = max(Max, p);\n\t\treturn;\n\t}\n\trep(i, 4) {\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tif (0 <= nx&&nx < 5 && 0 <= ny&&ny < 5) {\n\t\t\tswap(a[x][y], a[nx][ny]);\n\t\t\tdfs(nx, ny, c - 1);\n\t\t\tswap(a[x][y], a[nx][ny]);\n\t\t}\n\t}\n}\nsigned main() {\n\tint n;\n\twhile (scanf(\"%lld\", &n), ~n) {\n\t\tMax = 0;\n\t\trep(i, 5)rep(j, 5)scanf(\"%lld\", &a[j][i]), a[j][i]--;\n\t\trep(i, 5)reverse(a[i].begin(), a[i].end());\n\t\trep(i, 5)scanf(\"%lld\", &s[i]);\n\t\trep(i, 5)rep(j, 5)dfs(i, j, n);\n\t\tprintf(\"%lld\\n\", Max);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstruct State { int x[5][5]; };\nint n, b[6];\npair<State, int>del(State S) {\n\tbool used[5][5]; for (int i = 0; i < 25; i++)used[i / 5][i % 5] = false;\n\tfor (int i = 0; i < 5; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tif (S.x[i][j] == S.x[i][j + 1] && S.x[i][j] == S.x[i][j + 2] && S.x[i][j] >= 1) {\n\t\t\t\tfor (int k = j; k < j + 3; k++)used[i][k] = true;\n\t\t\t}\n\t\t\tif (S.x[j][i] == S.x[j + 1][i] && S.x[j][i] == S.x[j + 2][i] && S.x[j][i] >= 1) {\n\t\t\t\tfor (int k = j; k < j + 3; k++)used[k][i] = true;\n\t\t\t}\n\t\t}\n\t}\n\tint cnt = 0, u = 0;\n\tfor (int i = 0; i < 5; i++) {\n\t\tfor (int j = 0; j < 5; j++) { if (used[i][j] == true) { cnt += b[S.x[i][j]]; S.x[i][j] = 0; u++; } }\n\t}\n\tif (u == 0)cnt = -1;\n\tfor (int i = 0; i < 5; i++) {\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tfor (int k = 0; k < 5; k++) {\n\t\t\t\tif (S.x[j][k] >= 1 && S.x[j + 1][k] == 0)swap(S.x[j][k], S.x[j + 1][k]);\n\t\t\t}\n\t\t}\n\t}\n\treturn make_pair(S, cnt);\n}\nint dfs(State S, int depth, int cx, int cy) {\n\tif (depth == n) {\n\t\tint d = 1, c = 0;\n\t\tState V1 = S;\n\t\twhile (true) {\n\t\t\tpair<State, int>G = del(S);\n\t\t\tif (c == 69) {\n\t\t\t\tfor (int i = 0; i < 5; i++) {\n\t\t\t\t\tfor (int j = 0; j < 5; j++) {\n\t\t\t\t\t\tcout << V1.x[i][j] << ' ';\n\t\t\t\t\t}\n\t\t\t\t\tcout << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (G.second == -1)return c;\n\t\t\tc += d*G.second; S = G.first; d++;\n\t\t}\n\t}\n\tint dx[4] = { 1,0,-1,0 }, dy[4] = { 0,1,0,-1 }, maxn = 0;\n\tfor (int i = 0; i < 4; i++) {\n\t\tint ex = cx + dx[i], ey = cy + dy[i];\n\t\tif (ex < 0 || ex >= 5 || ey < 0 || ey >= 5)continue;\n\t\tState T = S; swap(T.x[ex][ey], T.x[cx][cy]);\n\t\tmaxn = max(maxn, dfs(T, depth + 1, ex, ey));\n\t}\n\treturn maxn;\n}\nint main() {\n\twhile (true) {\n\t\tcin >> n; if (n == -1)break; State V;\n\t\tfor (int i = 0; i < 25; i++)cin >> V.x[i / 5][i % 5];\n\t\tfor (int i = 1; i <= 5; i++)cin >> b[i];\n\t\tint ret = 0; for (int i = 0; i < 25; i++) { for (int j = 0; j <= n; j++)ret = max(ret, dfs(V, j, i / 5, i % 5)); }\n\t\tcout << ret << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nint N;\nint score[5];\nvoid output(int a[5][5]){\n  REP(i, 5){\n    REP(j, 5) printf(\"%d \", a[i][j]);\n    printf(\"\\n\");\n  }\n}\nint point(int a[5][5]){\n  int bonus = 1;\n  int res = 0;\n  while(true){\n    bool del[5][5] = {};\n    bool update = false;\n    REP(y, 5) for(int i = 2; i < 5; i++) {\n      if(a[y][i-2] == a[y][i-1] && a[y][i-1] == a[y][i] && a[y][i] != 0){\n        del[y][i-2] = del[y][i-1] = del[y][i] = true;\n        update = true;\n      }\n    }\n    REP(x, 5) for(int i = 2; i < 5; i++) {\n      if(a[i-2][x] == a[i-1][x] && a[i-1][x] == a[i][x] && a[i][x] != 0){\n        del[i-2][x] = del[i-1][x] = del[i][x] = true;\n        update = true;\n      }\n    }\n    if(!update) break;\n    REP(y, 5)REP(x, 5) if(del[y][x]){\n      res += score[a[y][x] - 1] * bonus;\n      a[y][x] = 0;\n    }\n    //output(a);\n    //printf(\"v\\n\");\n    REP(x, 5){\n      queue<int> que;\n      for(int y = 4; y >= 0; y--)if(a[y][x] != 0){\n        que.push(a[y][x]);\n      }\n      for(int y = 4; y >= 0; y--){\n        if(que.empty()){\n          a[y][x] = 0;\n        }else{\n          a[y][x] = que.front();\n          que.pop();\n        }\n      }\n    }\n    //output(a);\n    //printf(\"\\n\\n\");\n    bonus += 1;\n  }\n  return res;\n}\nint dfs(int a[5][5], int k, int x, int y){\n  int res = 0;\n  int tmp[5][5];\n  REP(i, 5)REP(j, 5) tmp[i][j] = a[i][j];\n  res = point(tmp);\n  if(k == N) return res;\n  REP(r, 4){\n    int nx = x + dx[r];\n    int ny = y + dy[r];\n    if(valid(nx, ny, 5, 5)){\n      swap(a[y][x], a[ny][nx]);\n      res = max(res, dfs(a, k + 1, nx, ny));\n      swap(a[y][x], a[ny][nx]);\n    }\n  }\n  return res;\n}\nint main(){\n  while(cin >> N && N != -1){\n    int a[5][5];\n    REP(i, 5)REP(j, 5) cin >> a[i][j];\n    REP(i, 5) cin >> score[i];\n    int ans = 0;\n    REP(y, 5)REP(x, 5) ans = max(ans, dfs(a, 0, x, y));\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nint n;\nint a[5][5];\nint s[5];\nint dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n\nint check(void){\n  int res = 0;\n  for(int d=1;;d++){\n    bool dis[5][5],f = false;\n    rep(i,5)rep(j,5)dis[i][j] = false;\n    \n    rep(i,5)rep(j,5){\n      if(a[i][j] == 0)continue;\n      \n      rep(k,2){\n\tint sy = i, sx = j;\n\tint c = 0;\n\twhile(sy>=0 && sx>=0 && sy<=4 && sx<=4 && a[sy][sx] == a[i][j]){\n\t  c++; sy += dy[k]; sx += dx[k];\n\t}\n\tif(c<3)continue;\n\t\n\tf = true;\n\tsy = i; sx = j;\n\twhile(sy>=0 && sx>=0 && sy<=4 && sx<=4 && a[sy][sx] == a[i][j]){\n\t  dis[sy][sx] = true;\n\t  sy += dy[k]; sx += dx[k];\n\t}\n      }\n    }\n    if(!f)return res;\n\n    rep(i,5)rep(j,5){\n      if(dis[i][j]){\n\tres += d*s[a[i][j]-1];\n\ta[i][j] = 0;\n      }\n    }\n    \n    rep(i,5){\n      for(int j=4;j>=0;j--){\n\tif(a[j][i] != 0){\n\t  for(int k=1;k<=4-j;k++){\n\t    if(a[j+k][i]==0)swap(a[j+k][i],a[j+k-1][i]);\n\t  }\n\t}\n      }\n    }\n  }\n}\n\nint move(int y,int x,int d){\n  int tmp[5][5];\n  rep(i,5)rep(j,5)tmp[i][j] = a[i][j];\n  int res = check();\n  rep(i,5)rep(j,5)a[i][j] = tmp[i][j];\n  if(d==n)return res;\n\n  rep(k,4){\n    int sy = y+dy[k], sx = x+dx[k];\n    if(sy<0 || sy>4 || sx<0 || sx>4)continue;\n    swap(a[y][x],a[sy][sx]);\n    res = max(res,move(sy,sx,d+1));\n    swap(a[y][x],a[sy][sx]);\n  }\n  return res;\n}     \n\nint solve(){\n  int res = 0;\n  rep(i,5)rep(j,5)res = max(res,move(i,j,0));\n  return res;\n}\n\nint main(){\n  while(cin >> n,n>=0){\n    rep(i,5)rep(j,5)cin >> a[i][j];\n    rep(i,5)cin >> s[i];\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include <cstring>\n#include <iostream>\n#include<cmath>\n#include<cstdio>\n#include<set>\n#include<map>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<stack>\n#include <complex>\n#include <cassert>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> PII;\n#define REP(i,n) for (int i=0; i<(int)(n); ++i)\n#define FOR(i,c) for (__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(),(c).end();\n\n#define MP make_pair\nint dy[] = {-1,0,1,0};\nint dx[] = {0,1,0,-1};\n\nint score[5];\nbool kieru[5][5];\n\nint rensa(vector<vector<int> > field) {\n  bool update = 1;\n  int bonus = 1;\n  int res = 0;\n  while(update) {\n    update = 0;\n    memset(kieru,0,sizeof(kieru));\n\n    REP(y,5) {\n      REP(x,5) {\n        int c = field[y][x];\n        if (c == -1) continue;\n        if (x+3<=5) {\n          bool f = 1;\n          for (int xx=x; xx<x+3; ++xx) {\n            if (field[y][xx] != c) f = 0;\n          }\n          if (f) {\n            for (int xx=x; xx<x+3; ++xx)\n              kieru[y][xx] = 1;\n          }\n        }\n        if (y+3<=5) {\n          bool f = 1;\n          for (int yy=y; yy<y+3; ++yy) {\n            if (field[yy][x] != c) f = 0;\n          }\n          if (f) {\n            for (int yy=y; yy<y+3; ++yy)\n              kieru[yy][x] = 1;\n          }\n        }\n      }\n    }\n    int tmp = 0;\n    REP(y,5) REP(x,5) if (kieru[y][x])  {\n      update = 1;\n      tmp += score[field[y][x]];\n      field[y][x] = -1;\n    }\n    res += tmp * bonus;\n    bonus++;\n    REP(x,5) {\n      for (int y=3; y>=0; --y) {\n        int yy = y+1;\n        while(yy<5&&field[yy][x]==-1) {\n          swap(field[yy-1][x],field[yy][x]);\n          yy++;\n        }\n      }\n    }\n    // REP(y,5) {\n    //   REP(x,5) cout << field[y][x] << \" \";\n    //   cout << endl;\n    // }\n  }\n  return res;\n}\n\nint ans;\nint n;\n\nvoid go(int nest, int y, int x, vector<vector<int> > field) {\n  int tmp = rensa(field);\n  ans = max(ans, tmp);\n  if (nest >=n) return;\n  REP(d,4) {\n    int yy = y+dy[d];\n    int xx = x+dx[d];\n    if (yy<0||yy>=5||xx<0||xx>=5) continue;\n    vector<vector<int> > next(field);\n    swap(next[y][x], next[yy][xx]);\n    go(nest+1, yy, xx, next);\n  }\n}\n\nvoid solve() {\n  vector<vector<int> > field(5,vector<int>(5,0));\n  \n  for(int i=0; i<5; i++) {\n    for(int j=0; j<5; j++) {\n      cin>>field[i][j];\n      field[i][j]--;\n    }\n  }\n  for(int i=0; i<5; i++)\n    cin>>score[i];\n  REP(y,5) {\n    REP(x,5) {\n      go(0,y,x,field);\n    }\n  }\n}\n\n\nint main() {\n    while(1) {\n      cin>>n;\n      if(n==-1)\n        break;\n      ans = 0;\n      solve();\n      cout << ans << endl;\n    }\n    return 0;\n  \n  }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector<int> Vec;\ntypedef vector<Vec> Mat;\n\nMat a(5, Vec(5));\nint score[5];\n\nconst int dx[] = {-1, +0, +1, +0};\nconst int dy[] = {+0, -1, +0, +1};\n\nbool inField(int x, int y)\n{\n    return (0 <= x && x < 5 && 0 <= y && y < 5);\n}\n\nbool up;\n\nint erase(Mat &m)\n{\n    bool e[5][5] = {{}};\n    for (int i = 0; i < 5; i++) {\n        for (int j = 0; j < 5; j++) {                        \n            if (m[i][j] == 0) {\n                continue;\n            }\n            int cnt[2] = {1, 1};\n            for (int k = 0; k < 4; k++) {\n                int ni = i + dy[k];\n                int nj = j + dx[k];\n                while (inField(ni, nj) &&\n                       m[i][j] == m[ni][nj]) {\n                    ni += dy[k];\n                    nj += dx[k];\n                    ++cnt[k&1];\n                }\n            }\n            if (cnt[0] >= 3 || cnt[1] >= 3) {\n                e[i][j] = 1;\n            }\n        }\n    }\n    int point = 0;\n    for (int i = 0; i < 5; i++) {\n        for (int j = 0; j < 5; j++) {\n            if (e[i][j]) {\n                up = 1;\n                point += score[m[i][j]-1];\n                m[i][j] = 0;\n            }\n        }\n    }\n    return point;\n}\n\nvoid fall(Mat &m)\n{\n    for (int j = 0; j < 5; j++) {\n        for (int i = 4; i >= 1; i--) {\n            if (m[i][j] == 0) {                \n                for (int k = i-1; k >= 0; k--) {\n                    if (m[k][j] != 0) {\n                        swap(m[i][j], m[k][j]);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}\n\nint calc(Mat &m, int bp)\n{\n    int point = erase(m) * bp;\n    fall(m);\n    return point;\n}\n\nint get_point()\n{\n    Mat b = a;\n    int point = 0, bp = 1;\n    bool update = 1;\n    \n    while (update) {\n        update = 0;        \n        Mat nb = b;\n        up = 0;\n        int p = calc(nb, bp++);\n        if (up) {\n            point += p;\n            update = 1;\n            b = nb;\n        }\n    }\n    return point;\n}\n\nint dfs(int y, int x, int n)    \n{\n    int point = get_point();\n    if (n > 0) {\n        for (int i = 0; i < 4; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (inField(nx, ny)) {\n                swap(a[ny][nx], a[y][x]);\n                point = max(point, dfs(ny, nx, n-1));\n                swap(a[ny][nx], a[y][x]);\n            }        \n        }\n    }\n    return point;\n}\n\nint main()\n{\n    int n;\n    while (cin >> n, n != -1) {\n        for (int i = 0; i < 5; i++) {\n            for (int j = 0; j < 5; j++) {\n                cin >> a[i][j];\n            }\n        }\n    \n        for (int i = 0; i < 5; i++) {\n            cin >> score[i];\n        }\n\n        int max_point = 0;\n        for (int i = 0; i < 5; i++) {\n            for (int j = 0; j < 5; j++) {\n                max_point = max(max_point, dfs(i, j, n));\n            }\n        }   \n        cout << max_point << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <iterator>\n#include <bitset>\n#include <random>\n#include <assert.h>\n#include <unordered_map>\n#include <array>\n#include <ctime>\n\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define X first\n#define Y second\n#define MP make_pair\n#define umap unordered_map\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> P;\ntypedef unsigned int uint;\n\nconst int N = 5;\n\nint score[N];\n\npair<int, vector<vector<int>>> check(vector<vector<int>> v){\n\tauto nxt = v;\n\trep(i, N) rep(j, N){\n\t\tint c = v[i][j];\n\t\tif (0 < i && i < N - 1 && v[i - 1][j] == c && c == v[i + 1][j]){\n\t\t\tfor (int k = -1; k <= 1; ++k) nxt[i + k][j] = 0;\n\t\t}\n\t\tif (0 < j && j < N - 1 && v[i][j - 1] == c && c == v[i][j + 1]){\n\t\t\tfor (int k = -1; k <= 1; ++k) nxt[i][j + k] = 0;\n\t\t}\n\t}\n\tint cnt = 0;\n\trep(i, N) rep(j, N) if (!nxt[i][j] && v[i][j]) cnt += score[v[i][j]-1];\n\n\treturn MP(cnt, nxt);\n}\n\nvoid down(vector<vector<int>> &v){\n\tfor (int i = N - 2; i >= 0; --i) rep(j, N){\n\t\tint k = i;\n\t\twhile (++k < N) if (!v[k][j]) swap(v[k][j], v[k - 1][j]);\n\t}\n}\n\nint simulate(vector<vector<int>> v){\n\tint res = 0, bonus = 1, x;\n\twhile (1){\n\t\ttie(x, v) = check(v);\n\t\tif (!x) return res;\n\t\tres += bonus++*x;\n\t\tdown(v);\n\t}\n}\n\nint dx[] = { 0, 1, 0, -1 };\nint dy[] = { 1, 0, -1, 0 };\nint dfs(int i, int j, int n, vector<vector<int>> &v){\n\tint res = simulate(v);\n\tif (n == 0) return res;\n\trep(d, 4){\n\t\tint ni = i + dx[d], nj = j + dy[d];\n\t\tif (ni < 0 || ni >= N || nj < 0 || nj >= N) continue;\n\t\tswap(v[i][j], v[ni][nj]);\n\t\tres = max(res, dfs(ni, nj, n - 1, v));\n\t\tswap(v[i][j], v[ni][nj]);\n\t}\n\treturn res;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\n\tauto v = vector<vector<int>>(N, vector<int>(N));\n\n\tint n;\n\twhile (cin >> n, ~n){\n\t\trep(i, N) rep(j, N) cin >> v[i][j];\n\t\trep(i, N) cin >> score[i];\n\t\tint ans = 0;\n\t\trep(i, N) rep(j, N) ans = max(ans, dfs(i, j, n, v));\n\t\tcout << ans << endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector<int> Vec;\ntypedef vector<Vec> Mat;\n\nMat a(5, Vec(5));\nint score[5];\n\nconst int dx[] = {-1, +0, +1, +0};\nconst int dy[] = {+0, -1, +0, +1};\n\nbool inField(int x, int y)\n{\n    return (0 <= x && x < 5 && 0 <= y && y < 5);\n}\n\nbool up;\n\nint erase(Mat &m)\n{\n    bool e[5][5] = {{}};\n    for (int i = 0; i < 5; i++) {\n        for (int j = 0; j < 5; j++) {                        \n            if (m[i][j] == 0) {\n                continue;\n            }\n            int cnt[2] = {1, 1};\n            for (int k = 0; k < 4; k++) {\n                int ni = i + dy[k];\n                int nj = j + dx[k];\n                while (inField(ni, nj) &&\n                       m[i][j] == m[ni][nj]) {\n                    ni += dy[k];\n                    nj += dx[k];\n                    ++cnt[k&1];\n                }\n            }\n            if (cnt[0] >= 3 || cnt[1] >= 3) {\n                e[i][j] = 1;\n            }\n        }\n    }\n    int point = 0;\n    for (int i = 0; i < 5; i++) {\n        for (int j = 0; j < 5; j++) {\n            if (e[i][j]) {\n                up = 1;\n                point += score[m[i][j]-1];\n                m[i][j] = 0;\n            }\n        }\n    }\n    return point;\n}\n\nvoid fall(Mat &m)\n{\n    for (int j = 0; j < 5; j++) {\n        for (int i = 4; i >= 1; i--) {\n            if (m[i][j] == 0) {                \n                for (int k = i-1; k >= 0; k--) {\n                    if (m[k][j] != 0) {\n                        swap(m[i][j], m[k][j]);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}\n\nint calc(Mat &m, int bp)\n{\n    int point = erase(m) * bp;\n    fall(m);\n    return point;\n}\n\nint get_point()\n{\n    Mat b = a;\n    int point = 0, bp = 1;\n    bool update = 1;\n    \n    while (update) {\n        update = 0;        \n        Mat nb = b;\n        up = 0;\n        int p = calc(nb, bp++);\n        if (nb != b) {\n            point += p;\n            update = 1;\n            b = nb;\n        }\n    }\n    return point;\n}\n\nint dfs(int y, int x, int n)    \n{\n    int point = get_point();\n    if (n > 0) {\n        for (int i = 0; i < 4; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (inField(nx, ny)) {\n                swap(a[ny][nx], a[y][x]);\n                point = max(point, dfs(ny, nx, n-1));\n                swap(a[ny][nx], a[y][x]);\n            }        \n        }\n    }\n    return point;\n}\n\nint main()\n{\n    int n;\n    while (cin >> n, n != -1) {\n        for (int i = 0; i < 5; i++) {\n            for (int j = 0; j < 5; j++) {\n                cin >> a[i][j];\n            }\n        }\n    \n        for (int i = 0; i < 5; i++) {\n            cin >> score[i];\n        }\n\n        int max_point = 0;\n        for (int i = 0; i < 5; i++) {\n            for (int j = 0; j < 5; j++) {\n                max_point = max(max_point, dfs(i, j, n));\n            }\n        }   \n        cout << max_point << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n\n#include <queue>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#include <set>\n#include <cstdio>\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\nusing namespace std;\n\nint ob[5][5];\nint s[5];\n\nint simulate(int b[5][5]){\n  int bornus = 1;\n  int ret = 0;\n\n  bool flag = true;\n  while(flag){\n    flag = false;\n    int del[5][5] = {{0}};\n\n    REP(i,5) REP(j,5){\n      if(b[i][j] != -1){\n        if(i + 2 < 5 && b[i][j] == b[i + 1][j] && b[i][j] == b[i + 2][j]){\n          del[i][j] = del[i + 1][j] = del[i + 2][j] = 1;\n          flag = true;\n        }\n        if(j + 2 < 5 && b[i][j] == b[i][j + 1] && b[i][j] == b[i][j + 2]){\n          del[i][j] = del[i][j + 1] = del[i][j + 2] = 1;\n          flag = true;\n        }\n      }\n    }\n\n    REP(i,5) REP(j,5) if(del[i][j]){\n      ret += bornus * s[b[i][j]];\n      b[i][j] = -1;\n    }\n\n    REP(k,4){\n      REP(i,4){\n        REP(j,5) if(b[i + 1][j] == -1){\n          swap(b[i][j], b[i + 1][j]);\n        }\n      }\n    }\n\n    bornus++;\n  }\n\n  return ret;\n}\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint main(){\n  while(int nn = getInt() + 1){\n    const int n = nn - 1;\n\n    REP(i,5) REP(j,5)\n      ob[i][j] = getInt() - 1;\n    REP(i,5) s[i] = getInt();\n\n    int ans = 0;\n\n    {\n      int bb[5][5];\n      REP(i,5) REP(j,5)\n        bb[i][j] = ob[i][j];\n      ans = max(ans, simulate(bb));\n    }\n\n    REP(x,5) REP(y,5){\n      REP(ss, 1 << (2 * n)){\n        int sss = ss;\n        int bb[5][5];\n        int xx = x;\n        int yy = y;\n\n        REP(i,5) REP(j,5)\n          bb[i][j] = ob[i][j];\n\n        REP(i,n){\n          const int ns = sss % 4; sss /= 4;\n          const int xxx = xx + _dx[ns];\n          const int yyy = yy + _dy[ns];\n\n          if(!ISIN(xxx, yyy, 5, 5)) break;\n\n          swap(bb[yyy][xxx], bb[yy][xx]);\n\n          int bbb[5][5];\n          REP(ii,5) REP(jj,5) bbb[ii][jj] = bb[ii][jj];\n          ans = max(ans, simulate(bbb));\n\n          xx = xxx; yy = yyy;\n        }\n      }\n    }\n\n    printf(\"%d\\n\", ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nint n;\nint a[5][5];\nint s[5];\nint dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n\nint check(int d){\n  bool dis[5][5],f = false;\n  rep(i,5)rep(j,5)dis[i][j] = false;\n\n  rep(i,5)rep(j,5){\n    if(a[i][j] == 0)continue;\n\n    rep(k,2){\n      int sy = i, sx = j;\n      int c = 0;\n      while(sy>=0 && sx>=0 && sy<=4 && sx<=4 && a[sy][sx] == a[i][j]){\n\tc++; sy += dy[k]; sx += dx[k];\n      }\n      if(c>=3){\n\trep(l,c)dis[i+l*dy[k]][j+l*dx[k]] = true;\n\tf = true;\n      }\n    }\n  }\n  if(!f)return 0;\n\n  int res = 0;\n  rep(i,5)rep(j,5){\n    if(dis[i][j]){\n      if(!a[i][j])cerr << \"azu\" << endl;\n      res += d*s[a[i][j]-1];\n      a[i][j] = 0;\n    }\n  }\n\n\n  rep(i,5){\n    rep(j,5){\n      if(a[4-j][i] != 0){\n\tint p = 0;\n\twhile(4-j+p+1<5 && a[4-j+p+1][i]==0){\n\t  swap(a[4-j+p+1][i],a[4-j+p][i]); p++;\n\t}\n      }\n    }\n  }\n  return res + check(d+1);\n}\n\nint move(int y,int x,int d){\n  int tmp[5][5];\n  rep(i,5)rep(j,5)tmp[i][j] = a[i][j];\n  int res = check(1);\n  rep(i,5)rep(j,5)a[i][j] = tmp[i][j];\n  if(d==n)return res;\n\n  rep(k,4){\n    int sy = y+dy[k], sx = x+dx[k];\n    if(sy<0 || sy>4 || sx<0 || sy>4)continue;\n    swap(a[y][x],a[sy][sx]);\n    res = max(res,move(sy,sx,d+1));\n    swap(a[y][x],a[sy][sx]);\n  }\n  return res;\n}     \n\nint solve(){\n  int res = 0;\n  rep(i,5)rep(j,5)res = max(res,move(i,j,0));\n  return res;\n}\n\nint main(){\n  while(cin >> n,n>=0){\n    rep(i,5)rep(j,5)cin >> a[i][j];\n    rep(i,5)cin >> s[i];\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,-1,0,1};\ntemplate<class T> constexpr bool in_range(T y, T x, T H, T W) { return 0<=y&&y<H&&0<=x&&x<W; }\n\nint N;\nint a[5][5];\nint b[5][5];\nll score[6];\n\nvoid drop() {\n  rep(j, 5) {\n    deque<int> d;\n    rep(i, 5) {\n      if(a[i][j] != -1) {\n        d.push_back(a[i][j]);\n      }\n    }\n\n    int dsize = d.size();\n    for(int i=4; i>=0 && !d.empty(); i--) {\n      a[i][j] = d.back();\n      d.pop_back();\n    }\n    rep(i, 5-dsize) {\n      a[i][j] = -1;\n    }\n  }\n}\n\nint dist(int num, int i, int j, int dy, int dx, int sum = 0) {\n  i += dy, j += dx;\n  if(!in_range(i, j, 5, 5)) return sum;\n  if(a[i][j] != num) return sum;\n  return dist(num, i, j, dy, dx, sum + 1);\n}\n\nll simulate() {\n  ll ret = 0;\n  int bonus = 1;\n\n  while(1) {\n    set<int> used;\n    rep(i, 5) rep(j, 5) {\n      if(a[i][j] == -1) continue;\n      int movel = dist(a[i][j], i, j, 0, -1);\n      int mover = dist(a[i][j], i, j, 0, +1);\n      int movet = dist(a[i][j], i, j, -1, 0);\n      int moveb = dist(a[i][j], i, j, +1, 0);\n      if(mover - movel + 1 >= 3) {\n        REP(x, j - movel, j + mover + 1) {\n          assert(a[i][x] != -1);\n          assert(a[i][x] == a[i][j]);\n          used.insert(i*5+x);\n        }\n      }\n      if(moveb - movet + 1 >= 3) {\n        REP(y, i - movet, i + moveb + 1) {\n          assert(a[y][j] != -1);\n          assert(a[y][j] == a[i][j]);\n          used.insert(y*5+j);\n        }\n      }\n    }\n\n    #if 1\n    for(auto && e: used) {\n      ret += score[a[e/5][e%5]] * bonus;\n      a[e/5][e%5] = -1;\n    }\n    #else\n    if(used.size()) {\n  rep(i, 5) {\n    rep(j, 5) {\n      printf(\"%3d\", a[i][j]);\n    }\n    cout << endl;\n  }\n  cout << endl;\n\n    for(auto && e: used) {\n      ret += score[a[e/5][e%5]] * bonus;\n      a[e/5][e%5] = -1;\n    }\n\n  rep(i, 5) {\n    rep(j, 5) {\n      printf(\"%3d\", a[i][j]);\n    }\n    cout << endl;\n  }\n  cout << endl;\n}\n  #endif\n\n\n    bonus ++;\n    if(!used.size()) break;\n    drop();\n\n  #if 0\n  rep(i, 5) {\n    rep(j, 5) {\n      printf(\"%3d\", a[i][j]);\n    }\n    cout << endl;\n  }\n  cout << endl;\n  cout << \"---------------\" << endl;\n  #endif\n  }\n\n  return ret;\n}\n\n\n\nll dfs(int y, int x, int idx = 0) {\n  int aa[5][5]; rep(i, 5) rep(j, 5) aa[i][j] = a[i][j];\n  ll ret = simulate();\n  if(idx < N) {\n    rep(k, 4) {\n      int ny = y + dy[k], nx = x + dx[k];\n      if(!in_range(ny, nx, 5, 5)) continue;\n      rep(i, 5) rep(j, 5) a[i][j] = aa[i][j];\n      swap(a[y][x], a[ny][nx]);\n      maximize(ret, dfs(ny, nx, idx + 1));\n    }\n  }\n  return ret;\n}\n\nll solve() {\n  ll ret = 0;\n  rep(i, 5) rep(j, 5)  {\n    rep(i, 5) rep(j, 5) a[i][j] = b[i][j];\n    maximize(ret, dfs(i, j));\n  }\n  return ret;\n}\n\nint main() {\n\n  for(; cin >> N && N >= 0;) {\n    rep(i, 5) rep(j, 5) cin >> b[i][j], a[i][j] = b[i][j];\n    rep(i, 5) cin >> score[i+1];\n    cout << solve() << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<int, bool>P;\n\nint s[5], dx[]{ 1,-1,0,0, }, dy[]{ 0,0,1,-1 };\nvector<vector<int>>a(5, vector<int>(5));\nint Max;\nvoid dfs(int x, int y, int c) {\n\tvector<vector<P>>b(5, vector<P>(5));\n\trep(i, 5)rep(j, 5)b[i][j].first = a[i][j];\n\tbool update = true;\n\tint p = 0;\n\tfor (int v = 1; update; v++) {\n\t\tupdate = false;\n\t\trep(i, 5) {\n\t\t\tint back = 0, cnt = 0;\n\t\t\trep(j, b[i].size()) {\n\t\t\t\tif (back != b[i][j].first) {\n\t\t\t\t\tif (cnt >= 3) {\n\t\t\t\t\t\tfor (int k = 1; k <= cnt; k++)\n\t\t\t\t\t\t\tb[i][j - k].second = 1;\n\t\t\t\t\t}\n\t\t\t\t\tcnt = 0;\n\t\t\t\t}\n\t\t\t\tback = b[i][j].first; cnt++;\n\t\t\t}\n\t\t\tif (cnt >= 3) {\n\t\t\t\tfor (int k = 1; k <= cnt; k++)\n\t\t\t\t\tb[i][b[i].size() - k].second = 1;\n\t\t\t}\n\t\t}\n\t\trep(i, 5) {\n\t\t\tint back = 0, cnt = 0;\n\t\t\trep(j, 5) {\n\t\t\t\tif (b[j].size() <= i || back != b[j][i].first) {\n\t\t\t\t\tif (cnt >= 3) {\n\t\t\t\t\t\tfor (int k = 1; k <= cnt; k++)\n\t\t\t\t\t\t\tb[j - k][i].second = 1;\n\t\t\t\t\t}\n\t\t\t\t\tcnt = 0;\n\t\t\t\t}\n\t\t\t\tif (i < b[j].size()) {\n\t\t\t\t\tback = b[j][i].first; cnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cnt >= 3) {\n\t\t\t\tfor (int k = 1; k <= cnt; k++)b[5 - k][i].second = 1;\n\t\t\t}\n\t\t}\n\t\trep(i, 5)rep(j, b[i].size()) {\n\t\t\tif (b[i][j].second == 1) {\n\t\t\t\tp += v*s[b[i][j].first];\n\t\t\t\tb[i].erase(b[i].begin() + j); update = true; j--;\n\t\t\t}\n\t\t}\n\t}\n\tMax = max(Max, p);\n\tif (c == 0)return;\n\trep(i, 4) {\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tif (0 <= nx&&nx < 5 && 0 <= ny&&ny < 5) {\n\t\t\tswap(a[x][y], a[nx][ny]);\n\t\t\tdfs(nx, ny, c - 1);\n\t\t\tswap(a[x][y], a[nx][ny]);\n\t\t}\n\t}\n}\nint main() {\n\tint n;\n\twhile (scanf(\"%d\", &n), ~n) {\n\t\tMax = 0;\n\t\trep(i, 5)rep(j, 5)scanf(\"%d\", &a[j][i]), a[j][i]--;\n\t\trep(i, 5)reverse(a[i].begin(), a[i].end());\n\t\trep(i, 5)scanf(\"%d\", &s[i]);\n\t\trep(i, 5)rep(j, 5)dfs(i, j, n);\n\t\tprintf(\"%d\\n\", Max);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EMPTY 0\n\nusing namespace std;\n\ntypedef long long ll;\nll LLINF = LLONG_MAX;\n\nint n,a[5][5],tmp[5][5];\nll score[5],maxi;\nint dx[] = {0,1,0,-1}; // ???,???,?????????\nint dy[] = {1,0,-1,0};\nbool used[5][5];\n\ninline bool isValid(int x,int y) { return 0 <= x && x < 5 && 0 <= y && y < 5; }\n\nvoid update(){\n\n  rep(i,5) rep(j,5) tmp[i][j] = a[i][j];\n  ll point = 0, phase = 0;\n  bool update = true;\n  while( update ){\n    ++phase;\n    update = false;\n    memset(used,false,sizeof(used));\n    rep(y,5){\n      rep(x,5){\n        if( used[y][x] || a[y][x] == EMPTY ) continue;\n        rep(i,2) {\n          int cnt = 0;\n          int cx = x, cy = y, color = a[cy][cx];\n          while( isValid(cx,cy) && a[cy][cx] == color ) {\n            ++cnt, cx += dx[i], cy += dy[i];\n          }\n          if( cnt >= 3 ) {\n            update = true;\n            cx = x, cy = y;\n            while( isValid(cx,cy) && a[cy][cx] == color ) {\n              used[cy][cx] = true;\n              ++cnt, cx += dx[i], cy += dy[i];\n            } \n          }\n        }\n      }\n    }\n    ll sum = 0;\n    rep(y,5) rep(x,5) if( used[y][x] ) {\n      assert( 1 <= a[y][x] && a[y][x] <= 5 );\n      sum += score[a[y][x]-1] * phase;\n      a[y][x] = EMPTY;\n    }\n    point += sum;\n    rep(x,5){\n      for(int y=4;y>=0;y--) if( a[y][x] != EMPTY ) {\n          int cx = x + dx[0], cy = y + dy[0];\n          while( isValid(cx,cy) && a[cy][cx] == EMPTY ){\n            swap(a[cy][cx],a[cy+dy[2]][cx+dx[2]]);\n            cx += dx[0], cy += dy[0];\n          }          \n      }\n    }\n  }\n  maxi = max(maxi,point);\n  rep(i,5) rep(j,5) a[i][j] = tmp[i][j];\n}\n\nvoid dfs(int cx,int cy,int prev,int depth){\n  update();\n  if( depth >= n ) return;\n\n  rep(i,4) if( ( i + 2 ) % 4 != prev ) {\n    int nx = cx + dx[i], ny = cy + dy[i];\n    if( !isValid(nx,ny) ) continue;\n    swap(a[ny][nx],a[cy][cx]);\n    dfs(nx,ny,i,depth+1);\n    swap(a[ny][nx],a[cy][cx]);\n  }\n}\n\nvoid compute(){\n  maxi = -LLINF;\n  rep(i,5) rep(j,5) dfs(j,i,-1,0);\n  cout << maxi << endl;\n}\n\nint main(){\n  while( cin >> n, n != -1 ){\n    rep(i,5) rep(j,5) cin >> a[i][j];\n    rep(i,5) cin >> score[i];\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstruct State { int x[5][5]; };\nint n, b[6];\npair<State, int>del(State S) {\n\tbool used[5][5]; for (int i = 0; i < 25; i++)used[i / 5][i % 5] = false;\n\tfor (int i = 0; i < 5; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tif (S.x[i][j] == S.x[i][j + 1] && S.x[i][j] == S.x[i][j + 2] && S.x[i][j] >= 1) {\n\t\t\t\tfor (int k = j; k < j + 3; k++)used[i][k] = true;\n\t\t\t}\n\t\t\tif (S.x[j][i] == S.x[j + 1][i] && S.x[j][i] == S.x[j + 2][i] && S.x[j][i] >= 1) {\n\t\t\t\tfor (int k = j; k < j + 3; k++)used[k][i] = true;\n\t\t\t}\n\t\t}\n\t}\n\tint cnt = 0, u = 0;\n\tfor (int i = 0; i < 5; i++) {\n\t\tfor (int j = 0; j < 5; j++) { if (used[i][j] == true) { cnt += b[S.x[i][j]]; S.x[i][j] = 0; u++; } }\n\t}\n\tif (u == 0)cnt = -1;\n\tfor (int i = 0; i < 5; i++) {\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tfor (int k = 0; k < 5; k++) {\n\t\t\t\tif (S.x[j][k] >= 1 && S.x[j + 1][k] == 0)swap(S.x[j][k], S.x[j + 1][k]);\n\t\t\t}\n\t\t}\n\t}\n\treturn make_pair(S, cnt);\n}\nint dfs(State S, int depth, int cx, int cy) {\n\tif (depth == n) {\n\t\tint d = 1, c = 0;\n\t\twhile (true) {\n\t\t\tpair<State, int>G = del(S);\n\t\t\tif (G.second == -1)return c;\n\t\t\tc += d*G.second; S = G.first; d++;\n\t\t}\n\t}\n\tint dx[4] = { 1,0,-1,0 }, dy[4] = { 0,1,0,-1 }, maxn = 0;\n\tfor (int i = 0; i < 4; i++) {\n\t\tint ex = cx + dx[i], ey = cy + dy[i];\n\t\tif (ex < 0 || ex >= 5 || ey < 0 || ey >= 5)continue;\n\t\tState T = S; swap(T.x[ex][ey], T.x[cx][cy]);\n\t\tmaxn = max(maxn, dfs(T, depth + 1, ex, ey));\n\t}\n\treturn maxn;\n}\nint main() {\n\twhile (true) {\n\t\tcin >> n; if (n == -1)break; State V;\n\t\tfor (int i = 0; i < 25; i++)cin >> V.x[i / 5][i % 5];\n\t\tfor (int i = 1; i <= 5; i++)cin >> b[i];\n\t\tint ret = 0; for (int i = 0; i < 25; i++)ret = max(ret, dfs(V, 0, i / 5, i % 5));\n\t\tcout << ret << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\n#include <functional>\nusing namespace std;\n\nint dy[] = {1, 0, -1, 0};\nint dx[] = {0, -1, 0, 1};\n\nvector<int> score(5);\n\nint calculateScore(vector<vector<int> > a)\n{\n    int bonus = 1;\n    int ret = 0;\n\n    for(;;){\n        vector<vector<bool> > check(5, vector<bool>(5, false));\n        for(int y=0; y<5; ++y){\n            for(int x=0; x<3; ++x){\n                if(a[y][x] != -1 && a[y][x] == a[y][x+1] && a[y][x] == a[y][x+2])\n                    check[y][x] = check[y][x+1] = check[y][x+2] = true;\n            }\n        }\n        for(int y=0; y<3; ++y){\n            for(int x=0; x<5; ++x){\n                if(a[y][x] != -1 && a[y][x] == a[y+1][x] && a[y][x] == a[y+2][x])\n                    check[y][x] = check[y+1][x] = check[y+2][x] = true;\n            }\n        }\n\n        bool stop = true;\n        for(int y=0; y<5; ++y){\n            for(int x=0; x<5; ++x){\n                if(check[y][x]){\n                    ret += bonus * score[a[y][x]];\n                    a[y][x] = -1;\n                    stop = false;\n                }\n            }\n        }\n        if(stop)\n            return ret;\n\n        for(int x=0; x<5; ++x){\n            int y2 = 4;\n            for(int y=4; y>=0; --y){\n                if(a[y][x] != -1){\n                    swap(a[y][x], a[y2][x]);\n                    -- y2;\n                }\n            }\n        }\n\n        ++ bonus;\n    }\n}\n\nint solve(int n, vector<vector<int> >& a, int y, int x, int prev)\n{\n    int ret = calculateScore(a);\n    if(n == 0)\n        return ret;\n\n    for(int i=0; i<4; ++i){\n        if(i == prev)\n            continue;\n\n        int y2 = y + dy[i];\n        int x2 = x + dx[i];\n        if(y2 < 0 || y2 > 4 || x2 < 0 || x2 > 4)\n            continue;\n\n        swap(a[y][x], a[y2][x2]);\n        ret = max(ret, solve(n-1, a, y2, x2, i^2));\n        swap(a[y][x], a[y2][x2]);\n    }\n\n    return ret;\n}\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == -1)\n            return 0;\n\n        vector<vector<int> > a(5, vector<int>(5));\n        for(int y=0; y<5; ++y){\n            for(int x=0; x<5; ++x){\n                cin >> a[y][x];\n                -- a[y][x];\n            }\n        }\n\n        for(int i=0; i<5; ++i)\n            cin >> score[i];\n\n        int ret = 0;\n        for(int y=0; y<5; ++y){\n            for(int x=0; x<5; ++x){\n                ret = max(ret, solve(n, a, y, x, -1));\n            }\n        }\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint mp[5][5],a[5][5];\nint n,score[5],ans;\nint dx[]={0,0,-1,1},dy[]={1,-1,0,0};\n\n\nint mark(int x,int y,int dep,int i){\n  int res=dep;\n  int nx=x+dx[i],ny=y+dy[i];\n  if(dep>=3)mp[y][x]=-1;\n  if(nx<0||ny<0||nx>=5||ny>=5||a[ny][nx]!=a[y][x])return res;\n  res=mark(nx,ny,dep+1,i);\n  if(3<=res) mp[y][x]=-1;\n  return res;\n}\n\nvoid erase(){\n  int f=1;\n  while(f){\n    f=0;\n    for(int i=1;i<5;i++)\n      for(int j=0;j<5;j++)\n\tif(mp[i][j]==-1&&mp[i-1][j]!=-1)f=1, swap(mp[i][j],mp[i-1][j]);\n  }\n}\n\n\nint cal(){\n  int tmp[5][5];\n  for(int i=0;i<5;i++)for(int j=0;j<5;j++)tmp[i][j]=mp[i][j];\n  int b=1,res=0;\n\n  while(1){\n    int cnt=0,f=1;\n    for(int i=0;i<5;i++)\n      for(int j=0;j<5;j++) a[i][j]=mp[i][j]; \n\n    for(int i=0;i<5;i++)\n      for(int j=0;j<5;j++)\n\tfor(int k=0;k<4&&a[i][j]!=-1;k++)\n\t  if(mark(j,i,1,k)>=3)mp[i][j]=-1,f=0;\n\t\n    int used[5]={};\n    for(int i=0;i<5;i++)\n      for(int j=0;j<5;j++)used[a[i][j]-1]+=a[i][j]!=mp[i][j];\n   \n    for(int i=0;i<5;i++) res+=used[i]*score[i]*b;\n    b++;\n    erase();\n    if(f)break;\n  }\n  for(int i=0;i<5;i++)\n    for(int j=0;j<5;j++) mp[i][j]=tmp[i][j];\n  return res;\n}\n\nvoid saiki(int x,int y,int dep){\n  ans=max(ans,cal());\n  if(dep==n)return ;  \n  for(int i=0;i<4;i++){\n    int nx=x+dx[i],ny=y+dy[i];\n    if(nx<0||ny<0||nx>=5||ny>=5)continue;\n    swap(mp[y][x],mp[ny][nx]);\n    saiki(nx,ny,dep+1);\n    swap(mp[y][x],mp[ny][nx]);\n  }\n}\n\nint main(){\n\n  while(1){\n    cin>>n;\n    if(n==-1)break;\n    for(int i=0;i<5;i++)for(int j=0;j<5;j++) cin>>mp[i][j];\n    for(int i=0;i<5;i++)cin>>score[i];\n    ans=0;\n    for(int i=0;i<5;i++)\n      for(int j=0;j<5;j++)saiki(i,j,0);\n\n    cout << ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector<int> Vec;\ntypedef vector<Vec> Mat;\n\nMat a(5, Vec(5));\nint score[5];\n\nconst int dx[] = {-1, +0, +1, +0};\nconst int dy[] = {+0, -1, +0, +1};\n\nbool inField(int x, int y)\n{\n    return (0 <= x && x < 5 && 0 <= y && y < 5);\n}\n\nbool up;\n\nint erase(Mat &m, int bp)\n{\n    bool e[5][5] = {{}};\n    for (int i = 0; i < 5; i++) {\n        for (int j = 0; j < 5; j++) {                        \n            if (m[i][j] == 0) {\n                continue;\n            }\n            int cnt[2] = {1, 1};\n            for (int k = 0; k < 4; k++) {\n                int ni = i + dy[k];\n                int nj = j + dx[k];\n                while (inField(ni, nj) &&\n                       m[i][j] == m[ni][nj]) {\n                    ni += dy[k];\n                    nj += dx[k];\n                    ++cnt[k&1];\n                }\n            }\n            if (cnt[0] >= 3 || cnt[1] >= 3) {\n                e[i][j] = 1;\n            }\n        }\n    }\n    int point = 0;\n    for (int i = 0; i < 5; i++) {\n        for (int j = 0; j < 5; j++) {\n            if (e[i][j]) {\n                up = 1;\n                point += score[m[i][j]-1] * bp;\n                m[i][j] = 0;\n            }\n        }\n    }\n    return point;\n}\n\nvoid fall(Mat &m)\n{\n    for (int j = 0; j < 5; j++) {\n        for (int i = 4; i >= 1; i--) {\n            if (m[i][j] == 0) {                \n                for (int k = i-1; k >= 0; k--) {\n                    if (m[k][j] != 0) {\n                        swap(m[i][j], m[k][j]);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}\n\nint calc(Mat &m, int bp)\n{\n    int point = erase(m, bp);\n    fall(m);\n    return point;\n}\n\nint get_point()\n{\n    Mat b = a;\n    int point = 0, bp = 1;\n    bool update = 1;\n    \n    while (update) {\n        update = 0;        \n        Mat nb = b;\n        up = 0;\n        int p = calc(nb, bp++);\n        if (up) {\n            point += p;\n            update = 1;\n            b = nb;\n        }\n    }\n    return point;\n}\n\nint dfs(int y, int x, int n)    \n{\n    int point = get_point();\n    if (n > 0) {\n        for (int i = 0; i < 4; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (inField(nx, ny)) {\n                swap(a[ny][nx], a[y][x]);\n                point = max(point, dfs(ny, nx, n-1));\n                swap(a[ny][nx], a[y][x]);\n            }        \n        }\n    }\n    return point;\n}\n\nint main()\n{\n    int n;\n    while (cin >> n, n != -1) {\n        for (int i = 0; i < 5; i++) {\n            for (int j = 0; j < 5; j++) {\n                cin >> a[i][j];\n            }\n        }\n    \n        for (int i = 0; i < 5; i++) {\n            cin >> score[i];\n        }\n\n        int max_point = 0;\n        for (int i = 0; i < 5; i++) {\n            for (int j = 0; j < 5; j++) {\n                max_point = max(max_point, dfs(i, j, n));\n            }\n        }   \n        cout << max_point << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int H = 5, W = 5;\nint GetID(int x, int y) { return y * W + x; }\nconst int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, -1, 0, 1};\n\nint n, a[25], score[6];\n\nbool fall(int b[]) {\n\tbool ret = false;\n\tfor (int x=0; x<5; ++x) {\n\t\tfor (int y=3; y>=0; --y) {\n\t\t\tif (b[GetID(x, y)] != -1) {\n\t\t\t\tint cy = y;\n\t\t\t\twhile (cy < 4 && b[GetID(x, cy+1)] == -1) {\n\t\t\t\t\tret = true;\n\t\t\t\t\tswap(b[GetID(x, cy)], b[GetID(x, cy+1)]);\n\t\t\t\t\t++cy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint vanish(int b[], int bonus) {\n\tbool flag[25];\n\tmemset(flag, false, sizeof(flag));\n\tfor (int y=0; y<5; ++y) for (int x=0; x<5; ++x) {\n\t\tif (y > 0 && y < 4 && b[GetID(x, y-1)] == b[GetID(x, y)] && b[GetID(x, y)] == b[GetID(x, y+1)]) {\n\t\t\tflag[GetID(x, y-1)] = flag[GetID(x, y)] = flag[GetID(x, y+1)] = true;\n\t\t}\n\t\tif (x > 0 && x < 4 && b[GetID(x-1, y)] == b[GetID(x, y)] && b[GetID(x, y)] == b[GetID(x+1, y)]) {\n\t\t\tflag[GetID(x-1, y)] = flag[GetID(x, y)] = flag[GetID(x+1, y)] = true;\n\t\t}\n\t}\n\t\n\tint ret = 0;\n\tfor (int y=0; y<5; ++y) for (int x=0; x<5; ++x) {\n\t\tif (flag[GetID(x, y)]) {\n\t\t\tret += score[b[GetID(x, y)]] * bonus;\n\t\t\tb[GetID(x, y)] = -1;\n\t\t}\n\t}\n\treturn ret;\n}\n\nvoid print(int b[]) {\n\tfor (int y=0; y<5; ++y) for (int x=0; x<5; ++x) cerr << b[GetID(x,y)] << (x<4 ? \" \" : \"\\n\");\n\tcerr << \"-----\" << endl;\n}\n\nint calcScore() {\n\tint b[25], ret = 0, bonus = 1;\n\tfor (int i=0; i<25; ++i) b[i] = a[i];\n\tdo {\n\t\tret += vanish(b, bonus);\n\t\t++bonus;\n\t\t//print(b);\n\t} while (fall(b));\n\treturn ret;\n}\n\nint rec(int x, int y) {\n\tif (n == 0) return calcScore();\n\tint ret = calcScore();\n\tfor (int d=0; d<4; ++d) {\n\t\tint nx = x + dx[d], ny = y + dy[d];\n\t\tif (nx < 0 || nx >= 5 || ny < 0 || ny >= 5) continue;\n\t\t--n;\n\t\tswap(a[GetID(x, y)], a[GetID(nx, ny)]);\n\t\tret = max(ret, rec(nx, ny));\n\t\t++n;\n\t\tswap(a[GetID(x, y)], a[GetID(nx, ny)]);\n\t}\n\treturn ret;\n}\n\nint main() {\n\twhile (cin >> n, n != -1) {\n\t\tfor (int y=0; y<5; ++y) for (int x=0; x<5; ++x) cin >> a[GetID(x, y)];\n\t\tfor (int i=0; i<5; ++i) cin >> score[i+1];\n\t\tint ans = 0;\n\t\tfor (int y=0; y<5; ++y) for (int x=0; x<5; ++x) ans = max(ans, rec(x, y));\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nint n;\nint a[5][5];\nint s[5];\nint dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n\nint check(int d){\n  bool dis[5][5],f = false;\n  rep(i,5)rep(j,5)dis[i][j] = false;\n\n  rep(i,5)rep(j,5){\n    if(a[i][j] == 0)continue;\n\n    rep(k,2){\n      int sy = i, sx = j;\n      int c = 0;\n      while(sy>=0 && sx>=0 && sy<=4 && sx<=4 && a[sy][sx] == a[i][j]){\n\tc++; sy += dy[k]; sx += dx[k];\n      }\n      if(c>=3){\n\trep(l,c)dis[i+l*dy[k]][j+l*dx[k]] = true;\n\tf = true;\n      }\n    }\n  }\n  if(!f)return 0;\n\n  int res = 0;\n  rep(i,5)rep(j,5){\n    if(dis[i][j]){\n      res += d*s[a[i][j]-1];\n      a[i][j] = 0;\n    }\n  }\n\n\n  rep(i,5){\n    rep(j,5){\n      if(a[4-j][i] != 0){\n\tint p = 0;\n\twhile(4-j+p+1<5 && a[4-j+p+1][i]==0){\n\t  swap(a[4-j+p+1][i],a[4-j+p][i]); p++;\n\t}\n      }\n    }\n  }\n  return res + check(d+1);\n}\n\nint move(int y,int x,int d){\n  int tmp[5][5];\n  rep(i,5)rep(j,5)tmp[i][j] = a[i][j];\n  int res = check(1);\n  rep(i,5)rep(j,5)a[i][j] = tmp[i][j];\n  if(d==n)return res;\n\n  rep(k,4){\n    int sy = y+dy[k], sx = x+dx[k];\n    if(sy<0 || sy>4 || sx<0 || sy>4)continue;\n    swap(a[y][x],a[sy][sx]);\n    res = max(res,move(sy,sx,d+1));\n    swap(a[y][x],a[sy][sx]);\n  }\n  return res;\n}     \n\nint solve(){\n  int res = 0;\n  rep(i,5)rep(j,5)res = max(res,move(i,j,0));\n  return res;\n}\n\nint main(){\n  while(cin >> n,n>=0){\n    rep(i,5)rep(j,5)cin >> a[i][j];\n    rep(i,5)cin >> s[i];\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n\nint N;\nint field[6][6];\nint ss[6];\n\nll calc(){\n  ll sum=0;\n  int nowField[6][6]={};\n  for(int i=0;i<5;i++)\n    for(int j=0;j<5;j++)\n      nowField[i][j]=field[i][j];\n  int bonus=1;\n  while(1){\n    bool isDel=false;\n    int nxtField[5][5]={};\n    // テァツ渉セテ・ツ慊ィテ」ツ?ョfieldテ」ツ?ォテ」ツ?ェテ」ツつ嘉」ツつ禿」ツ?ァテ」ツ??」ツつ凝」ツつづ」ツ?ョテ」ツつ津」ツ?凖」ツ?ケテ」ツ?ヲテヲツカツ暗」ツ??\n    for(int i=0;i<5;i++){\n      for(int j=0;j<5;j++){\n        if(nowField[i][j]==-1)continue;\n        // テヲツィツェ\n        {\n          int now=nowField[i][j];\n          int cnt=0;\n          for(int k=j;k<5;k++){\n            if(now==nowField[i][k])cnt++;\n            else break;\n          }\n          if(cnt>=3){\n            isDel=true;\n            for(int k=j;k<5;k++){\n              if(now==nowField[i][k])nxtField[i][k]=-1;\n              else break;\n            }\n          }\n        }\n        // テァツクツヲ\n        {\n          int now=nowField[i][j];\n          int cnt=0;\n          for(int k=i;k<5;k++){\n            if(now==nowField[k][j])cnt++;\n            else break;\n          }\n          if(cnt>=3){\n            isDel=true;\n            for(int k=i;k<5;k++){\n              if(now==nowField[k][j]){\n                nxtField[k][j]=-1;\n              }\n              else break;\n            }\n          }\n        }\n      }\n    }\n    for(int i=0;i<5;i++)\n      for(int j=0;j<5;j++)\n        if(nxtField[i][j]==-1)\n          sum+=ss[nowField[i][j]]*bonus;\n    for(int i=0;i<5;i++)\n      for(int j=0;j<5;j++)\n        if(nxtField[i][j]==-1)\n          nowField[i][j]=-1;\n    memset(nxtField,-1,sizeof(nxtField));\n    // テヲツカツ暗」ツ?療」ツ?淌・ツセツ古」ツ??ィツ青ステ」ツ?ィテ」ツ?凖・ツ仰陛、ツスツ愿」ツつ津ィツ。ツ古」ツ??\n    for(int j=0;j<5;j++){\n      int lis[5];\n      memset(lis,-1,sizeof(lis));\n      int cnt=0;\n      for(int i=4;i>=0;i--)\n        if(nowField[i][j]!=-1)\n          lis[cnt++]=nowField[i][j];\n      for(int i=0;i<cnt;i++)\n        nxtField[4-i][j]=lis[i];\n    }\n    for(int i=0;i<5;i++)\n      for(int j=0;j<5;j++)\n        nowField[i][j]=nxtField[i][j];\n    if(!isDel)break;\n    bonus++;\n  }\n  // if(sum==2724){\n  //   cout<<bonus<<endl;\n  //   for(int i=0;i<5;i++){\n  //     for(int j=0;j<5;j++){\n  //       printf(\"%2d\",field[i][j]+1);\n  //     }\n  //     cout<<endl;\n  //   }\n  //   cout<<endl;\n  //   for(int i=0;i<5;i++){\n  //     for(int j=0;j<5;j++){\n  //       printf(\"%2d\",nowField[i][j]+1);\n  //     }\n  //     cout<<endl;\n  //   }\n  }\n  return sum;\n}\n\nvoid dfs(int depth,int cy,int cx,ll &res){\n  if(depth==N)res=max(res,calc());\n  else{\n    const int dy[]={-1,0,0,1};\n    const int dx[]={0,-1,1,0};\n    for(int i=0;i<4;i++){\n      int ny=dy[i]+cy;\n      int nx=dx[i]+cx;\n      if(ny>=0&&nx>=0&&ny<5&&nx<5){\n        swap(field[ny][nx],field[cy][cx]);\n        dfs(depth+1,ny,nx,res);\n        swap(field[ny][nx],field[cy][cx]);\n      }\n    }\n  }\n}\n\nint main(){\n\n  while(cin>>N&&N!=-1){\n    for(int i=0;i<5;i++)\n      for(int j=0;j<5;j++)\n        cin>>field[i][j],field[i][j]--;\n    for(int i=0;i<5;i++)\n      cin>>ss[i];\n    ll res=0;\n    //cout<<N<<endl;\n    for(int i=0;i<5;i++)\n      for(int j=0;j<5;j++)\n        dfs(0,i,j,res);\n    cout<<res<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector<int> Vec;\ntypedef vector<Vec> Mat;\n\nMat a(5, Vec(5));\nint score[5];\n\nconst int dx[] = {-1, +0, +1, +0};\nconst int dy[] = {+0, -1, +0, +1};\n\nbool inField(int x, int y)\n{\n    return (0 <= x && x < 5 && 0 <= y && y < 5);\n}\n\nint erase(Mat &m)\n{\n    bool e[5][5] = {{}};\n    for (int i = 0; i < 5; i++) {\n        for (int j = 0; j < 5; j++) {                        \n            if (m[i][j] == 0) {\n                continue;\n            }\n            int cnt[2] = {1, 1};\n            for (int k = 0; k < 4; k++) {\n                int ni = i + dy[k];\n                int nj = j + dx[k];\n                while (inField(ni, nj) &&\n                       m[i][j] == m[ni][nj]) {\n                    ni += dy[k];\n                    nj += dx[k];\n                    ++cnt[k&1];\n                }\n            }\n            if (cnt[0] >= 3 || cnt[1] >= 3) {\n                e[i][j] = 1;\n            }\n        }\n    }\n    int point = 0;\n    for (int i = 0; i < 5; i++) {\n        for (int j = 0; j < 5; j++) {\n            if (e[i][j]) {\n                point += score[m[i][j]-1];\n                m[i][j] = 0;\n            }\n        }\n    }\n    return point;\n}\n\nvoid fall(Mat &m)\n{\n    for (int j = 0; j < 5; j++) {\n        for (int i = 4; i >= 1; i--) {\n            if (m[i][j] == 0) {                \n                for (int k = i-1; k >= 0; k--) {\n                    if (m[k][j] != 0) {\n                        swap(m[i][j], m[k][j]);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}\n\nint get_point()\n{\n    Mat b = a;\n    int point = 0, bp = 1;\n    bool update = 1;\n    \n    while (update) {\n        update = 0;        \n        Mat nb = b;\n        point += erase(nb) * bp++;\n        fall(nb);\n        if (nb != b) {        \n            update = 1;\n            b = nb;\n        }\n    }\n    return point;\n}\n\nint dfs(int y, int x, int n, int p)    \n{\n    int point = get_point();\n    if (n > 0) {\n        for (int i = 0; i < 4; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (inField(nx, ny) && (p == -1 || (p + 2) % 4 != i)) {\n                swap(a[ny][nx], a[y][x]);\n                point = max(point, dfs(ny, nx, n-1, i));\n                swap(a[ny][nx], a[y][x]);\n            }        \n        }\n    }\n    return point;\n}\n\nint main()\n{\n    int n;\n    while (cin >> n, n != -1) {\n        for (int i = 0; i < 5; i++) {\n            for (int j = 0; j < 5; j++) {\n                cin >> a[i][j];\n            }\n        }\n    \n        for (int i = 0; i < 5; i++) {\n            cin >> score[i];\n        }\n\n        int max_point = 0;\n        for (int i = 0; i < 5; i++) {\n            for (int j = 0; j < 5; j++) {\n                max_point = max(max_point, dfs(i, j, n, -1));\n            }\n        }   \n        cout << max_point << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nint a[7][7], b[7][7], c[7][7];\nbool ers[7][7];\nint s[6];\nint ans;\nint dy[] = {0, -1, 0, 1};\nint dx[] = {-1, 0, 1, 0};\n\nvoid calc(){\n\tmemcpy(b, a, sizeof a);\n\tbool update = true;\n\tint sum = 0;\n\tint bns = 1;\n\twhile(update){\n\t\tupdate = false;\n\t\tmemset(ers, 0, sizeof ers);\n\n\t\tfor(int i = 1; i <= 5; ++i)\n\t\tfor(int j = 1; j <= 5; ++j){\n\t\t\tint t = b[i][j];\n\t\t\tif(t == 0){ continue; }\n\n\t\t\tif(b[i+1][j] == t && b[i+2][j] == t){\n\t\t\t\ters[i][j] = ers[i+1][j] = ers[i+2][j] = true;\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t\tif(b[i][j+1] == t && b[i][j+2] == t){\n\t\t\t\ters[i][j] = ers[i][j+1] = ers[i][j+2] = true;\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 1; i <= 5; ++i)\n\t\tfor(int j = 1; j <= 5; ++j){\n\t\t\tif(ers[i][j]){\n\t\t\t\tsum += s[b[i][j]] * bns;\n\t\t\t\tc[i][j] = 0;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tc[i][j] = b[i][j];\n\t\t\t}\n\t\t}\n\n\t\tmemset(b, 0, sizeof b);\n\t\tfor(int x = 1; x <= 5; ++x){\n\t\t\tint t = 5;\n\t\t\tfor(int y = 5; y >= 1; --y){\n\t\t\t\twhile(t > 0 && c[t][x] == 0){ --t; }\n\t\t\t\tb[y][x] = c[t][x];\n\t\t\t\tt = max(t - 1, 0);\n\t\t\t}\n\t\t}\n\t\t++bns;\n\t}\n\t\n\tans = max(ans, sum);\n}\n\nvoid dfs(int n, int y, int x){\n\tcalc();\n\tif(n > 0){\n\t\tfor(int i = 0; i < 4; ++i){\n\t\t\tint ny = y + dy[i], nx = x + dx[i];\n\t\t\tif(a[ny][nx] != 0){\n\t\t\t\tswap(a[y][x], a[ny][nx]);\n\t\t\t\tdfs(n - 1, ny, nx);\n\t\t\t\tswap(a[y][x], a[ny][nx]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint n;\n\twhile(scanf(\"%d\", &n), n >= 0){\n\t\tfor(int i = 1; i <= 5; ++i)\n\t\tfor(int j = 1; j <= 5; ++j){\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t\tfor(int i = 1; i <= 5; ++i){\n\t\t\tscanf(\"%d\", &s[i]);\n\t\t}\n\n\t\tans = 0;\n\t\tfor(int i = 1; i <= 5; ++i)\n\t\tfor(int j = 1; j <= 5; ++j){\n\t\t\tdfs(n, i, j);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <array>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <tuple>\n#include <bitset>\n#include <memory>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <climits>\n#include <cfloat>\n\ntypedef std::array<std::array<char, 5>, 5> State;\nstruct Coordinate {\n\tint x, y;\n\tCoordinate operator+(const Coordinate a) const {\n\t\treturn { x + a.x, y + a.y };\n\t}\n};\n\nconstexpr std::array<Coordinate, 4> neighbor = { Coordinate{1, 0}, Coordinate{-1,0}, Coordinate{0,1}, Coordinate{0,-1} };\nvoid drop(State& state) {\n\tfor (auto j = 0; j < 5; ++j) {\n\t\tint count = 0;\n\t\tfor (auto i = 4; i >= 0; --i) {\n\t\t\tif (state[i][j] == -1) ++count;\n\t\t\telse if (count != 0) {\n\t\t\t\tstate[i + count][j] = state[i][j];\n\t\t\t\tstate[i][j] = -1;\n\t\t\t}\n\t\t}\n\t}\n}\nstd::array<char, 5> erase_block(State & state) {\n\tstd::stack<Coordinate> horizontal, vertical;\n\tfor (auto i = 0; i < 5; ++i) {\n\t\tfor (auto j = 0; j < 3; ++j) {\n\t\t\tif (state[i][j] != -1) {\n\t\t\t\tauto is_seq{ true };\n\t\t\t\tfor (auto c = 1; c < 3; ++c) {\n\t\t\t\t\tif (state[i][j] != state[i][j + c]) is_seq = false;\n\t\t\t\t}\n\t\t\t\tif (is_seq) horizontal.push({ j, i });\n\t\t\t}\n\t\t\tif (state[j][i] != -1) {\n\t\t\t\tauto is_seq{ true };\n\t\t\t\tfor (auto c = 1; c < 3; ++c) {\n\t\t\t\t\tif (state[j][i] != state[j + c][i]) is_seq = false;\n\t\t\t\t}\n\t\t\t\tif (is_seq) vertical.push({ i, j });\n\t\t\t}\n\t\t}\n\t}\n\tstd::array<char, 5> result{ 0,0,0,0,0 };\n\twhile (!horizontal.empty()) {\n\t\tauto top = horizontal.top(); horizontal.pop();\n\t\tfor (auto c = 0; c < 3; ++c) {\n\t\t\tif (state[top.y][top.x + c] != -1) result[state[top.y][top.x + c] - 1]++;\n\t\t\tstate[top.y][top.x + c] = -1;\n\t\t}\n\t}\n\twhile (!vertical.empty()) {\n\t\tauto top = vertical.top(); vertical.pop();\n\t\tfor (auto c = 0; c < 3; ++c) {\n\t\t\tif (state[top.y + c][top.x] != -1) result[state[top.y + c][top.x] - 1]++;\n\t\t\tstate[top.y + c][top.x] = -1;\n\t\t}\n\t}\n\treturn result;\n}\nbool is_valid(Coordinate position, int order, const int length) {\n\tauto next = position;\n\tfor (auto i = 0; i < length; ++i) {\n\t\tnext = next + neighbor[order % 4];\n\t\tif (next.y < 0 || next.y >= 5 || next.x < 0 || next.x >= 5) return false;\n\t\torder /= 4;\n\t}\n\treturn true;\n}\nState swap(const State& state, Coordinate position, int order, const int length) {\n\tauto copy = state;\n\tfor (auto i = 0; i < length; ++i) {\n\t\tauto next = position + neighbor[order % 4];\n\t\tauto temp = copy[position.y][position.x];\n\t\tcopy[position.y][position.x] = copy[next.y][next.x];\n\t\tcopy[next.y][next.x] = temp;\n\t\tposition = next;\n\t\torder /= 4;\n\t}\n\treturn copy;\n}\n\nint main() {\n\twhile (true) {\n\t\tint n; std::cin >> n; if (n == -1) break;\n\t\tState state; for (auto& line : state) for (auto& a : line) {\n\t\t\tstd::cin >> a;\n\t\t\ta -= '0';\n\t\t}\n\t\tstd::array<int, 5> score; for (auto& s : score) std::cin >> s;\n\t\tint max_score = 0;\n\t\tfor (auto length = 0; length <= n; ++length) {\n\t\t\tfor (auto order = 0; order < (1 << (length * 2)); ++order) {\n\t\t\t\tfor (auto y = 0; y < 5; ++y) for (auto x = 0; x < 5; ++x) if (is_valid({ x, y }, order, length)) {\n\t\t\t\t\tauto s = swap(state, { x, y }, order, length);\n\t\t\t\t\tint sum_score{ 0 };\n\t\t\t\t\tint bonus{ 1 };\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\tauto erased = erase_block(s);\n\t\t\t\t\t\tif (std::count(erased.begin(), erased.end(), 0) == 5) break;\n\t\t\t\t\t\tfor (auto i = 0; i < 5; ++i) {\n\t\t\t\t\t\t\tsum_score += score[i] * erased[i] * bonus;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t++bonus;\n\t\t\t\t\t\tdrop(s);\n\t\t\t\t\t}\n\t\t\t\t\tmax_score = std::max(max_score, sum_score);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstd::cout << max_score << std::endl;\n\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 5;\nconst int G = 5;\nconst int GG = G * G;\nconst int SEQ = 3;\n\nconst int dxs[] = {1, 0, -1, 0};\nconst int dys[] = {0, 1, 0, -1};\n\n/* typedef */\n\ntypedef set<int> si;\n\n/* global variables */\n\nint n;\nint scs[G];\nint maxsum = 0;\n\n/* classes */\n\nstruct Game {\n  int gs[GG];\n  \n  Game() {}\n\n  int move(int pos, int d) {\n    int x = (pos % G) + dxs[d], y = (pos / G) + dys[d];\n    int pos1 = -1;\n    if (x >= 0 && x < G && y >= 0 && y < G) {\n      pos1 = y * G + x;\n      gswap(pos, pos1);\n    }\n    //printf(\"gmove(%d,%d)->%d\\n\", pos, d, pos1);\n    return pos1;\n  }\n\n  void gswap(int pos0, int pos1) {\n    //printf(\"gswap(%d,%d)\\n\", pos0, pos1);\n    int tmp = gs[pos0]; gs[pos0] = gs[pos1]; gs[pos1] = tmp;\n  }\n\n  int calc() {\n    //puts(\"calc() in\");\n    int sum = 0;\n    static int cgs[GG];\n\n    copy(gs, gs + GG, cgs);\n\n    for (int bn = 1;; bn++) {\n      si vset;\n      for (int pos0 = 0; pos0 < GG; pos0 += G)\n\tfor (int d = 0; d < G;) {\n\t  int g0 = cgs[pos0 + d];\n\t  if (g0 < 0) {\n\t    d++;\n\t    continue;\n\t  }\n\t  int d1;\n\t  for (d1 = d + 1; d1 < G && cgs[pos0 + d1] == g0; d1++);\n\t  if (d1 - d >= SEQ)\n\t    for (; d < d1; d++) vset.insert(pos0 + d);\n\t  else d = d1;\n\t}\n      for (int pos0 = 0; pos0 < G; pos0++)\n\tfor (int d = 0; d < GG;) {\n\t  int g0 = cgs[pos0 + d];\n\t  if (g0 < 0) {\n\t    d += G;\n\t    continue;\n\t  }\n\t  int d1;\n\t  for (d1 = d + G; d1 < GG && cgs[pos0 + d1] == g0; d1 += G);\n\t  if (d1 - d >= SEQ * G)\n\t    for (; d < d1; d += G) vset.insert(pos0 + d);\n\t  else d = d1;\n\t}\n\n      if (vset.size() == 0) break;\n      \n      for (si::iterator sit = vset.begin(); sit != vset.end(); sit++) {\n\t//printf(\"%d \", *sit);\n\tsum += scs[cgs[*sit]] * bn, cgs[*sit] = -1;\n      }\n      //putchar('\\n');\n      \n      for (int pos0 = G * (G - 1); pos0 < GG; pos0++) {\n\tint pos1, pos2;\n\tfor (pos1 = pos2 = pos0; pos2 >= 0; pos2 -= G)\n\t  if (cgs[pos2] >= 0) {\n\t    cgs[pos1] = cgs[pos2];\n\t    pos1 -= G;\n\t  }\n\tfor (; pos1 >= 0; pos1 -= G) cgs[pos1] = -1;\n      }\n\n      //print(cgs);\n    }\n    \n    //puts(\"calc() out\");\n    return sum;\n  }\n\n  void print(const int *gs0) {\n    for (int pos = 0; pos < GG; pos++) {\n      printf(\"%2d\", gs0[pos]);\n      if ((pos + 1) % G == 0) putchar('\\n');\n    }\n    putchar('\\n');\n  }\n};\n\n/* subroutines */\n\nvoid rec(int k, int prv, int pos, Game g) {\n  //printf(\"k=%d,prv=%d,pos=%d\\n\", k, prv, pos);\n  //g.print(g.gs);\n  \n  for (int d = 0; d < 4; d++) {\n    //printf(\"  k=%d,d=%d\\n\", k,d);\n    int pos0 = g.move(pos, d);\n    if (pos0 >= 0) {\n      //printf(\"  pos0=%d\\n\", pos0);\n      if (pos0 != prv) {\n\tint sum = g.calc();\n\tif (maxsum < sum) maxsum = sum;\n\t\n\tif (k < n) rec(k + 1, pos, pos0, g);\n      }\n\n      //printf(\"  k=%d,prv=%d,pos=%d\\n\", k, prv, pos);\n      //printf(\"  2:gswap(%d,%d)\\n\", pos, pos0);\n      g.gswap(pos, pos0);\n    }\n  }\n}\n\nint check(Game g) {\n  maxsum = 0;\n\n  int sum = g.calc();\n  if (maxsum < sum) maxsum = sum;\n\n  if (n > 0)\n    for (int pos = 0; pos < GG; pos++) rec(1, -1, pos, g);\n\n  return maxsum;\n}\n\n/* main */\n\nint main() {\n  for (;;) {\n    cin >> n;\n    if (n < 0) break;\n\n    Game g;\n\n    for (int pos = 0; pos < GG; pos++) cin >> g.gs[pos], g.gs[pos]--;\n    for (int i = 0; i < G; i++) cin >> scs[i];\n    //for (int i = 0; i < G; i++) printf(\"%d \", scs[i]); putchar('\\n');\n    \n    cout << check(g) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nconst int dir[4][2]={{0,1},{0,-1},{-1,0},{1,0}};\n\nint syoukyo(int banmen[5][5],int scorelist[5]) {\n\tint score=0;\n\tint kesuflag[5][5]={0};\n\tint kietaflag=0;\n\tint i,j,k;\n\tfor(i=0;i<5;i++) {\n\t\tfor(j=0;j<3;j++) {\n\t\t\tif(banmen[i][j]==banmen[i][j+1] && banmen[i][j+1]==banmen[i][j+2]) {\n\t\t\t\tkesuflag[i][j]=kesuflag[i][j+1]=kesuflag[i][j+2]=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=0;i<3;i++) {\n\t\tfor(j=0;j<5;j++) {\n\t\t\tif(banmen[i][j]==banmen[i+1][j] && banmen[i+1][j]==banmen[i+2][j]) {\n\t\t\t\tkesuflag[i][j]=kesuflag[i+1][j]=kesuflag[i+2][j]=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=0;i<5;i++) {\n\t\tfor(j=0;j<5;j++) {\n\t\t\tif(kesuflag[i][j] && banmen[i][j]>0) {\n\t\t\t\tscore+=scorelist[banmen[i][j]-1];\n\t\t\t\tbanmen[i][j]=0;\n\t\t\t\tkietaflag=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=3;i>=0;i--) {\n\t\tfor(j=0;j<5;j++) {\n\t\t\tif(banmen[i+1][j]==0) {\n\t\t\t\tfor(k=i+1;k<5 && banmen[k][j]==0;k++);\n\t\t\t\tbanmen[k-1][j]=banmen[i][j];\n\t\t\t\tbanmen[i][j]=0;\n\t\t\t}\n\t\t}\n\t}\n\treturn kietaflag?score:-1;\n}\n\nint getscore(int banmen[5][5],int scorelist[5]) {\n\tint bonus;\n\tint scoresum=0;\n\tint nowscore;\n\tfor(bonus=1;(nowscore=syoukyo(banmen,scorelist))>=0;bonus++) {\n\t\tscoresum+=nowscore*bonus;\n\t}\n\treturn scoresum;\n}\n\nint main(void) {\n\tint n;\n\tint banmen[5][5];\n\tint banmen2[5][5];\n\tint scorelist[5];\n\tint i,j,x,y,idounum;\n\tint maxscore,nowscore;\n\twhile(scanf(\"%d\",&n)==1 && n>=0) {\n\t\tfor(i=0;i<5;i++) {\n\t\t\tfor(j=0;j<5;j++)scanf(\"%d\",&banmen[i][j]);\n\t\t}\n\t\tfor(i=0;i<5;i++)scanf(\"%d\",&scorelist[i]);\n\t\tmemcpy(banmen2,banmen,sizeof(banmen));\n\t\tmaxscore=getscore(banmen2,scorelist);\n\t\tfor(idounum=1;idounum<=n;idounum++) {\n\t\t\tfor(i=0;i<1<<(idounum*2);i++) {\n\t\t\t\tfor(y=0;y<5;y++) {\n\t\t\t\t\tfor(x=0;x<5;x++) {\n\t\t\t\t\t\tint nx=x,ny=y;\n\t\t\t\t\t\tint error=0;\n\t\t\t\t\t\tmemcpy(banmen2,banmen,sizeof(banmen));\n\t\t\t\t\t\tfor(j=0;j<idounum;j++) {\n\t\t\t\t\t\t\tint mid=(i>>(j*2))&3;\n\t\t\t\t\t\t\tint temp;\n\t\t\t\t\t\t\tif(nx+dir[mid][0]<0 || nx+dir[mid][0]>=5 ||\n\t\t\t\t\t\t\t\tny+dir[mid][1]<0 || ny+dir[mid][1]>=5){error=1;break;}\n\t\t\t\t\t\t\ttemp=banmen2[ny][nx];\n\t\t\t\t\t\t\tbanmen2[ny][nx]=banmen2[ny+dir[mid][1]][nx+dir[mid][0]];\n\t\t\t\t\t\t\tbanmen2[ny+dir[mid][1]][nx+dir[mid][0]]=temp;\n\t\t\t\t\t\t\tnx+=dir[mid][0];\n\t\t\t\t\t\t\tny+=dir[mid][1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(error)continue;\n\t\t\t\t\t\tnowscore=getscore(banmen2,scorelist);\n\t\t\t\t\t\tif(nowscore>maxscore)maxscore=nowscore;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",maxscore);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.ListIterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Main {\n\tpublic static final int SIZE = 5;\n\n\tpublic static final int[][] move_dir = new int[][] { { 0, 1 }, { 0, -1 },\n\t\t\t{ 1, 0 }, { -1, 0 } };\n\n\tpublic static boolean is_ok(int x, int y, int size) {\n\t\tif (x < 0 || x >= size || y < 0 || y >= size) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tpublic static void fall(char[][] map) {\n\t\tfor (int x = 0; x < 5; x++) {\n\t\t\twhile (true) {\n\t\t\t\tboolean found = false;\n\n\t\t\t\tfor (int y = 4; y >= 1; y--) {\n\t\t\t\t\tif (map[y][x] == 0 && map[y - 1][x] != 0) {\n\t\t\t\t\t\tfound = true;\n\n\t\t\t\t\t\tmap[y][x] = map[y - 1][x];\n\t\t\t\t\t\tmap[y - 1][x] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!found) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static int erase(char[][] map, int[] score){\n\t\tboolean[][] delete = new boolean[5][5];\n\t\t\n\t\tint cur = 0;\n\t\tint bonus = 1;\n\t\twhile(true){\n\t\t\tboolean updated = false;\n\t\t\t\n\t\t\tfor (int y = 0; y < 5; y++) {\n\t\t\t\tfor (int x = 0; x < 5; x++) {\n\t\t\t\t\tif(map[y][x] == 0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// x\n\t\t\t\t\tint x_len = 1;\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\tif (!is_ok(x + x_len, y, 5)) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if (map[y][x] == map[y][x + x_len]) {\n\t\t\t\t\t\t\tx_len++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (x_len >= 3) {\n\t\t\t\t\t\tfor (int add = 0; add < x_len; add++) {\n\t\t\t\t\t\t\tdelete[y][x + add] = true;\n\t\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tint y_len = 1;\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\tif (!is_ok(x, y + y_len, 5)) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if (map[y][x] == map[y + y_len][x]) {\n\t\t\t\t\t\t\ty_len++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (y_len >= 3) {\n\t\t\t\t\t\tfor (int add = 0; add < y_len; add++) {\n\t\t\t\t\t\t\tdelete[y + add][x] = true;\n\t\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tif(!updated){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int y = 0; y < 5; y++){\n\t\t\t\tfor(int x = 0; x < 5; x++){\n\t\t\t\t\tif(!delete[y][x]){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tcur += score[map[y][x] - 1] * bonus;\n\t\t\t\t\t//System.out.println(cur);\n\t\t\t\t\t\n\t\t\t\t\tmap[y][x] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//disp(map);\n\t\t\t\n\t\t\tfall(map);\n\t\t\t\n\t\t\t//disp(map);\n\t\t\t\n\t\t\tfor(int y = 0; y < 5; y++){\n\t\t\t\tfor(int x = 0; x < 5; x++){\n\t\t\t\t\tdelete[y][x] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tbonus++;\n\t\t}\n\t\t\n\t\treturn cur;\n\t}\n\t\n\tpublic static void disp(char[][] map){\n\t\tfor(int y = 0; y < 5; y++){\n\t\t\tfor(int x = 0; x < 5; x++){\n\t\t\t\tSystem.out.print((int)(map[y][x]) + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println(\"-----------\");\n\t}\n\t\n\tpublic static char[][] copy(char[][] map){\n\t\tchar[][] tmp = new char[5][5];\n\t\t\n\t\tfor(int y = 0; y < 5; y++){\n\t\t\tfor(int x = 0; x < 5; x++){\n\t\t\t\ttmp[y][x] = map[y][x];\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn tmp;\n\t}\n\t\n\tpublic static int dfs(int deep, final int n, char[][] map, int[] score, int x, int y,\n\t\t\tint prev_x, int prev_y) {\n\t\tif (deep == n) {\n\t\t\treturn erase(copy(map), score);\n\t\t} else {\n\t\t\tint max = erase(copy(map), score);\n\n\t\t\tfor (int[] dir : move_dir) {\n\t\t\t\tfinal int nx = x + dir[0];\n\t\t\t\tfinal int ny = y + dir[1];\n\n\t\t\t\tif (!is_ok(nx, ny, 5)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (nx == prev_x && ny == prev_y) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tchar swap = map[y][x];\n\t\t\t\tmap[y][x] = map[ny][nx];\n\t\t\t\tmap[ny][nx] = swap;\n\n\t\t\t\tmax = Math.max(max, dfs(deep + 1, n, map, score, nx, ny, x, y));\n\n\t\t\t\tswap = map[y][x];\n\t\t\t\tmap[y][x] = map[ny][nx];\n\t\t\t\tmap[ny][nx] = swap;\n\t\t\t}\n\n\t\t\treturn max;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tfinal int n = sc.nextInt();\n\n\t\t\tif (n < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchar[][] map = new char[5][5];\n\t\t\tfor (int i = 0; i < 5; i++) {\n\t\t\t\tfor (int j = 0; j < 5; j++) {\n\t\t\t\t\tmap[i][j] = (char) (sc.nextInt());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint[] score = new int[5];\n\t\t\tfor (int i = 0; i < 5; i++) {\n\t\t\t\tscore[i] = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tint max = Integer.MIN_VALUE;\n\t\t\tfor(int y = 0; y < 5; y++){\n\t\t\t\tfor(int x = 0; x < 5; x++){\n\t\t\t\t\tmax = Math.max(max, dfs(0, n, map, score, x, y, -1, -1));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tint m, n=5;\n\tint[][] a;\n\tint[] score;\n\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tm=sc.nextInt();\n\t\t\tif(m==-1){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ta=new int[n][n];\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\ta[j][i]=sc.nextInt()-1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tscore=new int[n];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tscore[i]=sc.nextInt();\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve(){\n\t\tmax=0;\n\t\tfor(int j=0; j<n; j++){\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\trec(i, j, 0);\n\t\t\t}\n\t\t}\n\t\tprintln(max+\"\");\n\t}\n\n\tint max;\n\n\tvoid rec(int x, int y, int depth){\n\t\tif(depth>m){\n\t\t\treturn;\n\t\t}\n\t\teval();\n\t\tint[] dx={0, 0, -1, 1};\n\t\tint[] dy={-1, 1, 0, 0};\n\t\tfor(int i=0; i<4; i++){\n\t\t\tint x2=x+dx[i], y2=y+dy[i];\n\t\t\tif(x2>=0&&x2<n&&y2>=0&&y2<n){\n\t\t\t\tint t=a[y][x];\n\t\t\t\ta[y][x]=a[y2][x2];\n\t\t\t\ta[y2][x2]=t;\n\t\t\t\trec(x2, y2, depth+1);\n\t\t\t\tt=a[y][x];\n\t\t\t\ta[y][x]=a[y2][x2];\n\t\t\t\ta[y2][x2]=t;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid eval(){\n\t\tint[][] b=new int[n][n];\n\t\tfor(int j=0; j<n; j++){\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tb[j][i]=a[j][i];\n\t\t\t}\n\t\t}\n\t\tint tot=0;\n\t\tfor(int bonus=1;; bonus++){\n\t\t\tboolean[][] clear=new boolean[n][n];\n\t\t\tfor(int y=0; y<n; y++){\n\t\t\t\tfor(int x=0; x<n; x++){\n\t\t\t\t\tif(b[y][x]==-1){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(y+2<n&&b[y][x]==b[y+1][x]&&b[y+1][x]==b[y+2][x]){\n\t\t\t\t\t\tclear[y][x]=clear[y+1][x]=clear[y+2][x]=true;\n\t\t\t\t\t}\n\t\t\t\t\tif(x+2<n&&b[y][x]==b[y][x+1]&&b[y][x+1]==b[y][x+2]){\n\t\t\t\t\t\tclear[y][x]=clear[y][x+1]=clear[y][x+2]=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint block=0;\n\t\t\tboolean updated=false;\n\t\t\tfor(int y=0; y<n; y++){\n\t\t\t\tfor(int x=0; x<n; x++){\n\t\t\t\t\tif(clear[y][x]){\n\t\t\t\t\t\tblock+=score[b[y][x]];\n\t\t\t\t\t\tb[y][x]=-1;\n\t\t\t\t\t\tupdated=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int x=0; x<n; x++){\n\t\t\t\tfor(int y=n-1; y>=0; y--){\n\t\t\t\t\tif(b[y][x]!=-1){\n\t\t\t\t\t\tfor(int j=y+1; j<n&&b[j][x]==-1; j++){\n\t\t\t\t\t\t\tint t=b[j-1][x];\n\t\t\t\t\t\t\tb[j-1][x]=b[j][x];\n\t\t\t\t\t\t\tb[j][x]=t;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ttot+=block*bonus;\n\t\t\tif(!updated){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmax=max(max, tot);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Python",
    "code": "import itertools\nfrom collections import defaultdict, deque\nfrom copy import deepcopy\nml = [[0,1],[0,-1],[-1,0],[1,0]]\ndef main(n):\n    def move(fi,mli,y,x):\n        f = deepcopy(fi)\n        for mi in mli:\n            mx,my = ml[mi]\n            mx += x\n            my += y\n            if 0 <= mx <= 4 and 0 <= my <= 4:\n                f[y][x], f[my][mx] = f[my][mx], f[y][x]\n                x, y = mx, my\n            else:\n                return False\n        return f\n\n    def d(b):\n        a = 0\n        de = []\n        for y in range(5):\n            for x in range(5):\n                if c[y][x]:\n                    val = c[y][x]\n                    if y == 4 or y == 0:\n                        if x == 4 or x == 0:\n                            continue\n                        if c[y][x+1] == c[y][x-1] == c[y][x]:\n                            de.append((y,x, 0))\n                    else:\n                        if x == 4 or x == 0:\n                            if c[y+1][x] == c[y-1][x] == c[y][x]:\n                                de.append((y,x, 1))\n                            continue\n                        else:\n                            if c[y][x+1] == c[y][x-1] == c[y][x]:\n                                de.append((y,x, 0))\n                            if c[y+1][x] == c[y-1][x] == c[y][x]:\n                                de.append((y,x, 1))\n        for y,x,di in de:\n            for i in range(3):\n                if di:\n                    if c[y+i-1][x]:\n                        a += score[c[y+i-1][x]-1] * b\n                        c[y+i-1][x] = 0\n                else:\n                    if c[y][x-1+i]:\n                        a += score[c[y][x-1+i]-1] * b\n                        c[y][x-1+i] = 0\n        if fall():\n            a += d(b+1)\n        return a\n\n    def fall():\n        f = False\n        for x in range(5):\n            for y in range(3,-1,-1):\n                if c[y][x] and c[y+1][x] == 0:\n                    for yi in range(y+1,5):\n                        if c[yi][x] == 0:\n                             continue\n                        yi -= 1\n                        break\n                    c[yi][x],c[y][x] = c[y][x],c[yi][x]\n                    f = True\n        return f\n\n    ans = 0\n    field = [list(map(int, input().split())) for i in range(5)]\n    score = list(map(int, input().split()))\n    for i in range(n+1):\n        mlis = list(itertools.product(range(4),repeat = i))\n        for mli in mlis:\n            for y in range(5):\n                for x in range(5):\n                    c = move(field, mli, y, x)\n                    if c:\n                        ans = max(ans,d(1))\n    print(ans)\n\nwhile 1:\n    n = int(input())\n    if n == -1:\n        break\n    main(n)\n\n"
  },
  {
    "language": "Python",
    "code": "def main():\n    while True:\n        n = int(input())\n        if n == -1:\n            break\n        mp = [list(map(int, input().split())) for _ in range(5)]\n        scores = list(map(int, input().split()))\n    \n        vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    \n    \n        def simulate():\n            use_mp = [[mp[y][x] for x in range(5)] for y in range(5)]\n            bonus = 1\n            score = 0\n            while True:\n                delete_set = set()\n                for y in range(5):\n                    for length in range(5, 2, -1):\n                        for left in range(5 - length + 1):\n                            if use_mp[y][left] == 0:continue\n                            if all([use_mp[y][left] == num for num in use_mp[y][left:left+length]]):\n                                for add in range(length):\n                                    delete_set.add((left + add, y))\n    \n                for x in range(5):\n                    for length in range(5, 2, -1):\n                        for top in range(5 - length + 1):\n                            if use_mp[top][x] == 0:continue\n                            if all([use_mp[top][x] == num for num in [use_mp[y][x] for y in range(top, top + length)]]):\n                                for add in range(length):\n                                    delete_set.add((x, top + add))\n    \n                if not delete_set:\n                    break\n    \n                for x, y in delete_set:\n                    score += scores[use_mp[y][x] - 1] * bonus\n                    use_mp[y][x] = 0\n    \n                for x in range(5):\n                    line = [use_mp[y][x] for y in range(5) if use_mp[y][x] != 0]\n                    line = [0] * (5 - len(line)) + line\n                    for y in range(5):\n                        use_mp[y][x] = line[y]\n    \n                bonus += 1\n    \n            return score\n    \n        def search(x, y, n):\n            ret = simulate()\n            if n == 0:return ret\n            for dx, dy in vec:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < 5 and 0 <= ny < 5:\n                    mp[y][x], mp[ny][nx] = mp[ny][nx], mp[y][x]\n                    ret = max(ret, search(nx, ny, n - 1))\n                    mp[y][x], mp[ny][nx] = mp[ny][nx], mp[y][x]\n            return ret\n    \n    \n        ans = 0\n        for y in range(5):\n            for x in range(5):\n                ans = max(ans, search(x, y, n))\n    \n        print(ans)\n    \nmain()\n"
  }
]