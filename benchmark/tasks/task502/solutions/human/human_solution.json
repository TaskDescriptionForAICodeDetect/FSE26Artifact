[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vvi = vector<vector<int>>;\nusing vvl = vector<vector<ll>>;\n\ndouble eps = 0.00001;\nusing p2 = complex<double>;\n// x: real\n// y: imag\n\ndouble det(p2 v1, p2 v2) {\n  return v1.real() * v2.imag() - v1.imag() * v2.real();\n}\ndouble dot(p2 v1, p2 v2) {\n  return v1.real() * v2.real() + v1.imag() * v2.imag();\n}\nbool same(double x, double y) { return fabs(x - y) < eps; }\ndouble dist2(p2 l1, p2 l2) { return dot(l1 - l2, l1 - l2); }\n\nauto p2comp = [](const p2 &l, const p2 &r) {\n  if (fabs(l.real() - r.real()) > eps)\n    return l.real() < r.real();\n  return l.imag() < r.imag();\n};\nstruct Line {\n  p2 st, ed;\n  Line(p2 st, p2 ed) : st(st), ed(ed) {}\n  Line(double x1, double y1, double x2, double y2)\n      : st(p2(x1, y1)), ed(p2(x2, y2)) {}\n  Line(p2 st, double x, double y) : st(st), ed(p2(x, y)) {}\n  Line(double x, double y, p2 ed) : st(p2(x, y)), ed(ed) {}\n  double dist() { return sqrt(dist2(st, ed)); }\n  bool isPalla(Line l) { return fabs(det(ed - st, l.ed - l.st)) < eps; }\n  double x() { return ed.real() - st.real(); }\n  double y() { return ed.imag() - st.imag(); }\n};\n\n// l1.st + (l1.st - l1.ed) * r.first = l2.st + (l2.st - l2.ed) * r.second\n// 方程式を満たす(r.first, r.second)を返す\n// l1.isPalla(l2) => (nan, nan)\npair<double, double> interP(Line l1, Line l2) {\n  double a = l1.x();\n  double b = -l2.x();\n  double c = l1.y();\n  double d = -l2.y();\n  double inv = 1. / (a * d - c * b);\n  double e1 = -l1.st.real() + l2.st.real();\n  double e2 = -l1.st.imag() + l2.st.imag();\n  return make_pair((d * e1 - b * e2) * inv, (-c * e1 + a * e2) * inv);\n}\n\nbool intersec(Line l1, Line l2) {\n  if (l1.isPalla(l2))\n    return false;\n  auto r = interP(l1, l2);\n  return eps < r.first && r.first < 1. - eps && eps < r.second &&\n         r.second < 1. - eps;\n}\n\nstruct Poly {\n  vector<p2> ps;\n  Poly(vector<p2> ps) : ps(ps) {}\n  bool include(p2 p) {\n    vector<double> b;\n    for (int i = 0; i < ps.size(); i++) {\n      b.push_back(det(p, ps[i] - ps[(i + 1) % ps.size()]));\n    }\n    bool allPlus = true, allMinus = true;\n    for (auto &x : b) {\n      if (x > eps)\n        allMinus = false;\n      if (x < -eps)\n        allPlus = false;\n    }\n    return allMinus || allPlus;\n  }\n  bool intersecl(Line l) {\n    for (int i = 0; i < ps.size(); i++) {\n      if (intersec(l, Line(ps[i], ps[(i + 1) % ps.size()])))\n        return true;\n    }\n    return false;\n  }\n};\n\nstruct Circle {\n  p2 p;\n  double r;\n  Circle(p2 p, double r) : p(p), r(r) {}\n  bool include(p2 l) { return dist2(p, l) < r * r + eps; }\n\n  // 円同士の交点\n  // 存在すれば2つ\n  vector<p2> intersec(Circle c) {\n    p2 d = c.p - p;\n    double dist = dot(d, d);\n    double a = (dist + r * r - c.r * c.r) / 2.;\n    double D = dist * r * r - a * a;\n    if (D < eps)\n      return vector<p2>();\n    double Dsqrt = sqrt(D);\n    vector<p2> ps;\n    ps.emplace_back((a * d.real() + d.imag() * Dsqrt) / dist + p.real(),\n                    (a * d.imag() - d.real() * Dsqrt) / dist + p.imag());\n    ps.emplace_back((a * d.real() - d.imag() * Dsqrt) / dist + p.real(),\n                    (a * d.imag() + d.real() * Dsqrt) / dist + p.imag());\n    return ps;\n  }\n};\n\n// 逆時計回り\nstruct ConX {\n  vector<p2> ps;\n  // graham scan\n  // ref: プログラミングコンテストチャレンジブック p233\n  ConX(vector<p2> v) {\n    sort(v.begin(), v.end(), p2comp);\n\n    int k = 0, n = v.size();\n    ps.resize(n * 2);\n    for (int i = 0; i < n; i++) {\n      while (k > 1 && det(ps[k - 1] - ps[k - 2], v[i] - ps[k - 1]) < eps)\n        k--;\n      ps[k++] = v[i];\n    }\n    for (int i = n - 2, t = k; i >= 0; i--) {\n      while (k > t && det(ps[k - 1] - ps[k - 2], v[i] - ps[k - 1]) < eps)\n        k--;\n      ps[k++] = v[i];\n    }\n    ps.resize(k - 1);\n  }\n  size_t size() { return ps.size(); }\n};\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  int n, m;\n  cin >> n >> m;\n  vector<Poly> pol;\n  for (int i = 0; i < n; i++) {\n    vector<p2> ps;\n    int size;\n    cin >> size;\n    for (int j = 0; j < size; j++) {\n      double x, y;\n      cin >> x >> y;\n      ps.emplace_back(x, y);\n    }\n    pol.emplace_back(ps);\n  }\n  vector<p2> hum;\n  for (int i = 0; i < m; i++) {\n    double x, y;\n    cin >> x >> y;\n    hum.emplace_back(x, y);\n  }\n  if (n == 0) {\n    cout << m << endl;\n    return 0;\n  }\n  vector<Line> ls;\n  for (auto &h : hum) {\n    for (auto &po : pol) {\n      for (auto &p : po.ps) {\n        ls.emplace_back(h, p);\n      }\n    }\n  }\n  vector<p2> may;\n  for (int i = 0; i < ls.size(); i++)\n    for (int j = i + 1; j < ls.size(); j++)\n      if (!ls[i].isPalla(ls[j])) {\n        auto r = interP(ls[i], ls[j]);\n        may.push_back(ls[i].st + r.first * p2(ls[i].x(), ls[i].y()));\n      }\n  int ans = 0;\n  for (auto &p : may) {\n    int score = m;\n    for (auto &h : hum) {\n      Line l(p, h);\n      for (auto &po : pol) {\n        if (po.intersecl(l)) {\n          score--;\n          break;\n        }\n      }\n    }\n    ans = max(ans, score);\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(_v) for(auto _x:_v){cout<<_x<<\" \";}cout<<endl\n#define printVS(vs) for(auto x : vs){cout << x << endl;}\n#define printVV(_vv) for(auto _v:_vv){for(auto _x:_v){cout<<_x<<\" \";}cout<<endl;}\n#define printP(p) cout << p.first << \" \" << p.second << endl\n#define printVP(vp) for(auto p : vp) printP(p);\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<Pii> vp;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\ntypedef complex<double> P;\ntypedef vector<P> G;\n#define here(g, i) g[i]\n#define next(g, i) g[(i + 1) % g.size()]\n#define prev(g, i) g[(i - 1 + g.size()) % g.size()]\nconst double EPS = 1e-10;\nconst double INF = 1e12;\nconst double PI = acos(-1);\n\nstruct L {\n    P a, b, v;\n    L(){}\n    L(P _a, P _b) : a(_a), b(_b), v(b - a) {}\n    L(double _ax, double _ay, double _bx, double _by) : L(P(_ax, _ay), P(_bx, _by)) {}\n};\n\ndouble cross(P a, P b) {\n    return imag(conj(a) * b);\n}\n\ndouble dot(P a, P b) {\n    return real(conj(a) * b);\n}\n\nint ccw(P p0, P p1, P p2) {\n    if (cross(p1 - p0, p2 - p0) > 0) return +1; // counter-clockwise\n    if (cross(p1 - p0, p2 - p0) < 0) return -1; // clockwise\n    if (dot(p1 - p0, p2 - p0) < 0) return +2;   // online_back\n    if (dot(p0 - p1, p2 - p1) < 0) return -2;   // online_front\n    return 0;                                   // on_segment\n}\n\n// !! ???????????????????????¨?????? \"<\" !!\nbool intersectSS(L l1, L l2) {\n    return (ccw(l1.a, l1.b, l2.a) * ccw(l1.a, l1.b, l2.b) < 0 &&\n            ccw(l2.a, l2.b, l1.a) * ccw(l2.a, l2.b, l1.b) < 0);\n}\n\nP crosspointSS(L l1, L l2) {\n    assert(intersectSS(l1, l2));\n    double d1 = abs(cross(l2.v, l1.a - l2.a));\n    double d2 = abs(cross(l2.v, l1.b - l2.a));\n    double t = d1 / (d1 + d2);\n    return l1.a + t * l1.v;\n}\n\nbool intersectLL(L l1, L l2) {\n    return cross(l1.v, l2.v) != 0;\n}\n\nP crosspointLL(L l1, L l2) {\n    return l1.a + l1.v * cross(l2.v, l2.a - l1.a) / cross(l2.v, l1.v);\n}\n\nbool intersectSG(L l, G g) {\n    int n = g.size();\n    rep(i, n) {\n        if (intersectSS(l, L(here(g, i), next(g, i)))) {\n            return true;\n        }\n    }\n    return false;\n}\n\nP readP() {\n    double x, y;\n    cin >> x >> y;\n    return P(x, y);\n}\n\nG readG() {\n    int n;\n    cin >> n;\n    G g(n);\n    rep(i, n) g[i] = readP();\n    return g;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n, m;\n    cin >> n >> m;\n    vector<G> g(n);\n    rep(i, n) g[i] = readG();\n    vector<P> p(m);\n    rep(i, m) p[i] = readP();\n\n    if (m == 1) {\n        cout << 1 << endl;\n        return 0;\n    }\n\n    int ans = 0;\n    rep(i1, m) {\n        P p1 = p[i1];\n        rep(j1, n) {\n            rep(k1, g[j1].size()) {\n                P q1 = g[j1][k1];\n                rep2(i2, i1 + 1, m) {\n                    P p2 = p[i2];\n                    rep(j2, n) {\n                        rep(k2, g[j2].size()) {\n                            P q2 = g[j2][k2];\n                            // Line!!!!\n                            if (!intersectLL(L(p1, q1), L(p2, q2))) {\n                                continue;\n                            }\n                            P c = crosspointLL(L(p1, q1), L(p2, q2));\n                            int cnt = 0;\n                            rep(i3, m) {\n                                cnt += [&](L l) {\n                                    rep(j, n) {\n                                        // Segment!!!!\n                                        if (intersectSG(l, g[j])) return false;\n                                    }\n                                    return true;\n                                }(L(c, p[i3]));\n                            }\n                            ans = max(ans, cnt);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; ++i)\nusing namespace std;\n\nusing R = long double;\nconst R EPS = 1e-10;\nint sgn(const R &x) {return (x > EPS) - (x < -EPS);}\nusing P = complex<R>;\nconst P O = P(0, 0);\nusing L = struct {P s, t;};\nusing VP = vector<P>;\n\nauto & operator >>(istream& is, P &p) {R x, y; is >> x >> y; p =P(x,y); return is;}\n\ninline R dot(P o, P a, P b) {return real(conj(a - o) * (b - o));}\ninline R det(P o, P a, P b) {return imag(conj(a - o) * (b - o));}\ninline int sdot(P o, P a, P b) {return sgn(dot(o, a, b));}\ninline int sdet(P o, P a, P b) {return sgn(det(o, a, b));}\n\nbool iss(L a, L b) {\n\tint sa = sdet(a.s, a.t, b.s) * sdet(a.s, a.t, b.t);\n\tint sb = sdet(b.s, b.t, a.s) * sdet(b.s, b.t, a.t);\n\treturn max(sa, sb) < 0;\n}\n\nP cross(L a, L b) {\n\tR u = det(a.s, b.s, b.t) / det(O, a.t - a.s, b.t - b.s);\n\treturn (1 - u) * a.s + u * a.t;\n}\n\nbool in_polygon(const VP &pol, const P &p) {\n\tconst int n = pol.size();\n\tint res = 0;\n\trep(i, n) {\n\t\tP a = pol[i], b = pol[(i + 1) % n];\n\t\tbool f = sgn(imag(p - a)) >= 0, s = sgn(imag(p - b)) < 0;\n\t\tif (sgn(imag(b - a))*sdet(a, b, p) == 1 and f == s) res += 2 * f - 1;\n\t}\n\treturn res > 0;\n}\n\nint main(void) {\n\tint n, m;\n\tcin >> n >> m;\n\tVP pol[20];\n\n\trep(i, n) {\n\t\tint l;\n\t\tcin >> l;\n\t\tpol[i] = VP(l);\n\t\trep(j, l) cin >> pol[i][j];\n\t}\n\n\tVP cand(m);\n\trep(i, m) cin >> cand[i];\n\n\tvector<L> lines;\n\trep(i, m) rep(j, n) for (auto &p : pol[j]) lines.push_back(L{cand[i], p});\n\n\tconst int k = lines.size();\n\n\tvector<P> points;\n\trep(j, k)rep(i, k) points.push_back(cross(lines[i], lines[j]));\n\n\tvector<L> obj;\n\trep(i, n) {\n\t\tconst int l = pol[i].size();\n\t\trep(j, l) obj.push_back(L{pol[i][j], pol[i][(j + 1) % l]});\n\t}\n\n\tint ans = 0;\n\tfor (auto &tar : points) {\n\t\tint cur = 0;\n\n\t\trep(i, m) {\n\t\t\tL seg = L{tar, cand[i]};\n\t\t\tbool ok = true;\n\t\t\tfor (auto &seg2 : obj) if (iss(seg, seg2)) ok = false;\n\t\t\tif (ok) cur++;\n\t\t}\n\n\t\tans = max(ans, cur);\n\t}\n\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-8, pi = acos(-1.0);\n\n#define EQ(a,b) (abs((a)-(b))<eps)\n\nld dot (P a, P b) { return real(conj(a) * b); }\nld cross (P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n  bool operator<(const P &lhs, const P &rhs) {\n    return lhs.real() == rhs.real() ? lhs.imag() < rhs.imag()\n                                    : lhs.real() < rhs.real();\n  }\n}\n\nstruct L{ P a, b; };\nstruct C { P p; ld r; };\n\n// counter clockwise\nint ccw (P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > eps) return 1;   // counter clockwise\n  if (cross(b, c) < -eps) return -1; // clockwise\n  if (dot(b, c) < 0) return 2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line\n  return 0;                          // a--c--b on line\n}\n\nbool isis_ss(L s, L t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n         ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_sp(L s, P p) {\n  return abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n  ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + t * (l.a - l.b);\n}\n\nld dist_sp(L s, P p) {\n  P r = proj(s, p);\n  if (isis_sp(s, r)) return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\n\nP is_ll(L s, L t){\n  P sv = s.b - s.a, tv = t.b - t.a;\n  return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool crs(L s, L t) {\n  return isis_ss(s, t) && dist_sp(s, t.a) > eps && dist_sp(s, t.b) > eps && dist_sp(t, s.a) > eps && dist_sp(t, s.b) > eps;\n}\n\nint main() {\n  int n,m;\n  cin>>n>>m;\n  vector<VP> polys;\n  REP(i,n) {\n    int l;\n    cin>>l;\n    VP vp;\n    REP(j,l) {\n      int x,y;\n      cin>>x>>y;\n      vp.emplace_back(x,y);\n    }\n    polys.push_back(vp);\n  }\n  VP r;\n  REP(i,m) {\n    int x,y;\n    cin>>x>>y;\n    r.emplace_back(x,y);\n  }\n  vector<L> vl;\n  REP(i,n)REP(j,polys[i].size())REP(k,m) {\n    vl.push_back({polys[i][j], r[k]});\n  }\n  int l=vl.size();\n  VP cand;\n  REP(i,l)REP(j,i) {\n    cand.push_back(is_ll(vl[i], vl[j]));\n  }\n  int res = 0;\n  for(auto p : cand) {\n    int cnt = 0;\n    REP(i,m) {\n      L s={p,r[i]};\n      bool ok = true;\n      for(auto poly : polys) {\n        int v = poly.size();\n        REP(j,v) {\n          L e={poly[j],poly[(j+1)%v]};\n          if (crs(s,e)) ok = false;\n        }\n      }\n      if (ok) ++cnt;\n    }\n    res = max(res, cnt);\n  }\n  cout << res << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// #include \"../dump.hpp\"\n// #include \"../dump/plot.hpp\"\n\n#define rep(i,n) for(int i=0,i##_cond=(n);i<i##_cond;++i)\n#define FOR(i,a,b) for(int i=(a),i##_cond=(b);i<i##_cond;++i)\n#define all(a) (a).begin(),(a).end()\ntemplate<class T>bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\n\nconst double EPS = 1e-8;\nusing P =  complex<double>;\nnamespace std{\n  bool operator <(const P &a, const P &b){ // 辞書順\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n  bool operator ==(const P &a, const P &b){\n    return abs(a-b) < EPS;\n  }\n  bool isnan(const P&p){\n    return isnan(p.real()) or isnan(p.imag());\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nusing G = vector<P>;\n\nP crosspoint(const L &l, const L &m){\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0];\n  if (abs(A) < EPS) return P(nan(\"\"),nan(\"\"));\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nint ccw(P a, P b, P c){\n  b -= a; c -= a;\n  if(cross(b, c) > 0)   return +1;       // 反時計周り\n  if(cross(b, c) < 0)   return -1;       // 時計回り\n  if(dot(b, c) < 0)     return +2;       // c--a--b の順に一直線\n  if(norm(b) < norm(c)) return -2;       // a--b--c の順に一直線, a==bも含む\n  return 0;                              // a--c--b の順に一直線, b==cも含む\n}\n\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\nbool intersectSS(const L &s, const L &t) {\n  if(ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n     ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0) return true;\n  // 端点が乗っている場合\n  if(intersectSP(s,t[0]) or intersectSP(s,t[1]) or\n     intersectSP(t,s[0]) or intersectSP(t,s[1])) return true;\n  return false;\n}\nbool intersectGS(const G &g, const L &s){\n  vector<P> ps;\n  int n = g.size();\n  rep(i, n){\n    L tmps(g[i], g[(i+1)%n]);\n    if(intersectSS(tmps, s)){\n      P tmpp = crosspoint(tmps, s);\n      if(not isnan(tmpp))\n\tps.push_back(tmpp);\n    }\n  }\n  sort(all(ps));\n  ps.erase(unique(all(ps)), ps.end());\n  if(ps.size() >= 2) return true;\n  else return false; // 接する場合もNO \n}\n\nbool gp_contains(const G& g, const P& p){\n  double sum = 0.0;\n  int n = g.size();\n  for(int i = 0; i < n; i++){\n    int j = (i+1)%n;\n    if(intersectSP(L(g[i], g[j]-g[i]), p))\n      return true;\n    sum += arg((g[j]-p)/(g[i]-p));\n  }\n  return (abs(sum) > 1);\n}\n\nint main(){\n  // input\n  int n, m; cin >> n >> m;\n  vector<G> gs(n);\n  rep(i,n){\n    int l; cin >> l;\n    rep(j,l){\n      double x, y; cin >> x >> y;\n      gs[i].push_back(P(x,y));\n    }\n  }\n  vector<P> ps(m);\n  rep(i,m){\n    double x, y; cin >> x >> y;\n    ps[i] = P(x,y);\n  }\n\n  // 候補を列挙\n  vector<vector<L>> canl(m);\n  rep(i,m)\n    for(auto g : gs)\n      for(auto gp : g)\n\tcanl[i].push_back(L(ps[i],gp));\n  vector<P> canp;\n  rep(i,m) FOR(j,i+1,m){\n    for(auto l1 : canl[i])\n      for(auto l2 : canl[j]){\n\tP tmp = crosspoint(l1, l2);\n\tif(isnan(tmp)) continue;\n\tbool f = true;\n\tfor(auto g : gs) if(gp_contains(g, tmp)) f = false;\n\tif(f) canp.push_back(tmp);\n      }\n  }\n  \n  // 候補を確認\n  int ans = 1;\n  for(auto can : canp){\n    int tmp = 0;\n    for(auto p : ps){\n      L tmpl(can, p);\n      bool f = true;\n      for(auto g : gs)\n\tif(intersectGS(g, tmpl)) f = false;\n      if(f){\n\ttmp++;\n      }\n    }\n    chmax(ans, tmp);\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define fs first\n#define sc second\n#define pb push_back\n#define sz size()\n#define all(a) (a).begin(),(a).end()\n \nusing namespace std;\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\ntypedef vector<P> Poly;\n \nconst D EPS = 1e-8;\nconst D PI = acos(-1);\n \ninline D dot(P x, P y){return real(conj(x)*y);}\n \ninline D cross(P x, P y){return imag(conj(x)*y);}\n \n//for line(segment)\ninline int ccw(P a,P b,P c){\n  b -= a;c -= a;\n  if (cross(b,c)>EPS) return 1;   //counter clockwise\n  if (cross(b,c)<-EPS) return -1; //clockwise\n  if (dot(b, c)<-EPS) return 2;   //c--a--b on line\n  if (abs(b)+EPS<abs(c)) return -2;   //a--b--c on line\n  return 0;                       //on segment\n}\n \ninline bool para(L a,L b){return abs(cross(a.fs-a.sc,b.fs-b.sc))<EPS;}\n \ninline P line_cp(L a,L b){\n  return a.fs+(a.sc-a.fs)*cross(b.sc-b.fs,b.fs-a.fs)/cross(b.sc-b.fs,a.sc-a.fs);\n}\n \ninline bool is_cp(L a,L b){\n  if(ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0)\n    if(ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0)return true;\n  return false;\n}\n \nint main(){\n  int n,m;\n  cin >> n >> m;\n \n  vector<Poly> vp(n);\n  rep(i,n){\n    int l; cin >> l;\n    rep(j,l){\n      int x,y; cin >> x >> y;\n      vp[i].push_back( P(x,y) );\n    }\n  }\n \n  vector<P> h(m);\n  vector<L> vl;\n  rep(i,m){\n    int x,y; cin >> x >> y;\n    h[i] = P(x,y);\n \n    rep(j,n){\n      for(auto x : vp[j]) vl.push_back( L(h[i], x) );\n    }\n  }\n \n  vector<P> can;\n  rep(i,m) can.push_back( h[i] );\n  rep(i,vl.size()){\n    rep(j,i){\n      if( para(vl[i], vl[j]) ) continue;\n      can.push_back( line_cp(vl[i], vl[j]) );\n    }\n  }\n \n  int ans = 0;\n  for(auto x : can){\n    int tmp = 0;\n    rep(i,m){\n      if( EQ(h[i], x) ) tmp++;\n      else{\n\tbool ok = true;\n\tL see = L(h[i],x);\n\trep(j,n){\n\t  rep(k,vp[j].size()){\n\t    L edge = L(vp[j][k], vp[j][(k+1)%vp[j].size()]);\n\t    if( is_cp(see, edge) ){\n\t      P cp = line_cp(see, edge);\n\t      if( !EQ(cp, edge.first) && !EQ(cp, edge.second) && !EQ(cp, x) && !EQ(cp, h[i]) ) ok = false;\n\t    }\n\t    if(!ok) break;\n\t  }\n\t  if(!ok) break;\n\t}\n\tif(ok) tmp++;\n      }\n    }\n    ans = max(ans, tmp);\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\ntypedef complex<double> pt;\n\ntypedef vector<P> poly;\nconst double EPS = 1e-7;\n#define x real()\n#define y imag()\n\nint n,m;\nint L[15]; pt p[15][20];\npt h[15];\nvector<pair<pt,pt> >LL;\nbool eq(double a,double b){\n  return (-EPS < a-b && b-a < EPS);\n}\ndouble dot(pt a,pt b){\n\treturn (conj(a)*b).x;\n}\ndouble cross(pt a,pt b){\n\treturn (conj(a)*b).y;\n}\npt crossPoint(pt a,pt b,pt c,pt d){\n\tdouble A = cross(b-a,d-c);\n\tdouble B = cross(b-a,b-c);\n\tif( fabs(A) < EPS && fabs(B) < EPS ) return c;\n\telse if(fabs(A) >= EPS ) return c+B/A*(d-c);\n\telse pt(1e9,1e9);\n}\nint ccw(pt a,pt b,pt c){\n\tb -= a; c -= a;\n\tif(cross(b,c) > EPS) return 1; // counter clockwise\n\tif(cross(b,c) < -EPS) return -1; // clockwise\n\tif(dot(b,c) < -EPS) return 2; //c-a-b\n\tif(norm(b) < norm(c)) return -2; //a-b-c\n\treturn 0; //a-c-b\n}\nbool intersect(pt a,pt b,pt c,pt d){\n\treturn (ccw(a,b,c)*ccw(a,b,d) <= 0 && ccw(c,d,a)*ccw(c,d,b) <= 0);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&L[i]);\n\t\tfor(int j=0;j<L[i];j++){\n\t\t\tdouble s,t;\n\t\t\tscanf(\"%lf%lf\",&s,&t); p[i][j] = pt(s,t);\n\t\t}\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tdouble s,t; scanf(\"%lf%lf\",&s,&t); h[i] = pt(s,t);\n\t}\n\t//human_vertex path\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<L[i];j++){\n\t\t\tfor(int k=0;k<m;k++){\n\t\t\t\tLL.pb(mp(p[i][j],h[k]));\n\t\t\t}\n\t\t}\n\t}\n\tvector<pt>C;\n\tfor(int i=0;i<LL.size();i++){\n\t\tfor(int j=i+1;j<LL.size();j++){\n\t\t\tpt cand = crossPoint(LL[i].fi,LL[i].sc,LL[j].fi,LL[j].sc);\n\t\t\t//cout << cand.x << \" \" << cand.y << endl;\n\t\t\tif(cand.x > 1e8) continue;\n\t\t\tif(abs(ccw(LL[i].fi,LL[i].sc,cand))%2!=0) continue;\n\t\t\tif(abs(ccw(LL[j].fi,LL[j].sc,cand))%2!=0) continue;//cout << \"K\" << endl;\n\t\t//\tcout << cand.x << \" \" << cand.y << endl;\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tfor(int l=0;l<L[k];l++){\n\t\t\t\t\tif(ccw(p[k][l],p[k][(l+1)%L[k]],cand) == 1){\n\t\t\t\t\t\t//in polygon\n\t\t\t\t\t\tgoto ok;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t//\tcout << cand.x << \" \" << cand.y << endl;\n\t\t\tok:; C.pb(cand);\n\t\t}\n\t}\n\tint ret = 0;\n\tfor(int i=0;i<C.size();i++){\n\t\tint num = 0;\n\t\tfor(int j=0;j<m;j++){\n\t\t\t//candidate_human path\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tfor(int l=0;l<L[k];l++){\n\t\t\t\t\tif(!intersect(C[i],h[j],p[k][l],p[k][(l+1)%L[k]])){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tpt cr = crossPoint(C[i],h[j],p[k][l],p[k][(l+1)%L[k]]);\n\t\t\t\t\t\tif(abs(p[k][l]-cr) < EPS) continue;\n\t\t\t\t\t\tif(abs(p[k][(l+1)%L[k]]-cr) < EPS) continue;\n\t\t\t\t\t}\n\t\t\t\t\tgoto fail;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnum++; fail:;\n\t\t}\n\t\tret = max(ret,num);\n\t}\n\tcout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\ntypedef complex<double> pt;\n\ntypedef vector<P> poly;\nconst double EPS = 1e-9;\n#define x real()\n#define y imag()\n\nint n,m;\nint L[15]; pt p[15][20];\npt h[15];\nvector<pair<pt,pt> >LL;\nbool eq(double a,double b){\n  return (-EPS < a-b && b-a < EPS);\n}\ndouble dot(pt a,pt b){\n\treturn (conj(a)*b).x;\n}\ndouble cross(pt a,pt b){\n\treturn (conj(a)*b).y;\n}\npt crossPoint(pt a,pt b,pt c,pt d){\n\tdouble A = cross(b-a,d-c);\n\tdouble B = cross(b-a,b-c);\n\tif( fabs(A) < EPS && fabs(B) < EPS ) return c;\n\telse if(fabs(A) >= EPS ) return c+B/A*(d-c);\n\telse pt(1e9,1e9);\n}\nint ccw(pt a,pt b,pt c){\n\tb -= a; c -= a;\n\tif(cross(b,c) > EPS) return 1; // counter clockwise\n\tif(cross(b,c) < -EPS) return -1; // clockwise\n\tif(dot(b,c) < -EPS) return 2; //c-a-b\n\tif(norm(b) < norm(c)) return -2; //a-b-c\n\treturn 0; //a-c-b\n}\nbool intersect(pt a,pt b,pt c,pt d){\n\treturn (ccw(a,b,c)*ccw(a,b,d) <= 0 && ccw(c,d,a)*ccw(c,d,b) <= 0);\n}\nbool on_segment(pair<pt,pt> a,pt p){\n  return eq(abs(a.first-a.second)-abs(a.first-p)-abs(a.second-p),0);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&L[i]);\n\t\tfor(int j=0;j<L[i];j++){\n\t\t\tdouble s,t;\n\t\t\tscanf(\"%lf%lf\",&s,&t); p[i][j] = pt(s,t);\n\t\t}\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tdouble s,t; scanf(\"%lf%lf\",&s,&t); h[i] = pt(s,t);\n\t}\n\t//human_vertex path\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<L[i];j++){\n\t\t\tfor(int k=0;k<m;k++){\n\t\t\t\tLL.pb(mp(p[i][j],h[k]));\n\t\t\t}\n\t\t}\n\t}\n\tvector<pt>C;\n\tfor(int i=0;i<LL.size();i++){\n\t\tfor(int j=i+1;j<LL.size();j++){\n\t\t\tpt cand = crossPoint(LL[i].fi,LL[i].sc,LL[j].fi,LL[j].sc);\n\t\t\t//cout << cand.x << \" \" << cand.y << endl;\n\t\t\tif(cand.x > 1e8) continue;\n\t\t\tif(abs(ccw(LL[i].fi,LL[i].sc,cand))%2!=0) continue;\n\t\t\tif(abs(ccw(LL[j].fi,LL[j].sc,cand))%2!=0) continue;//cout << \"K\" << endl;\n\t\t\t//cout << cand.x << \" \" << cand.y << endl;\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tfor(int l=0;l<L[k];l++){\n\t\t\t\t\tif(ccw(p[k][l],p[k][(l+1)%L[k]],cand) != 1){\n\t\t\t\t\t\t//in polygon\n\t\t\t\t\t\tgoto ok;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << cand.x << \" \" << cand.y << endl;\n\t\t\tok:; C.pb(cand); //cout << cand.x << \" \" << cand.y << endl;\n\t\t}\n\t}\n\tint ret = 1;\n\tfor(int i=0;i<C.size();i++){\n\t\tint num = 0;\n\t\tfor(int j=0;j<m;j++){\n\t\t\t//candidate_human path\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tfor(int l=0;l<L[k];l++){\n\t\t\t\t\tif(!intersect(C[i],h[j],p[k][l],p[k][(l+1)%L[k]])){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tpt cr = crossPoint(C[i],h[j],p[k][l],p[k][(l+1)%L[k]]);\n\t\t\t\t\t\tif(abs(p[k][l]-cr) < EPS) continue;\n\t\t\t\t\t\tif(abs(p[k][(l+1)%L[k]]-cr) < EPS) continue;\n\t\t\t\t\t\tif(abs(C[i]-cr) < EPS) continue;\n\t\t\t\t\t\tif(abs(h[j]-cr) < EPS) continue;\n\t\t\t\t\t}\n\t\t\t\t\tgoto fail;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnum++; fail:;\n\t\t}\n\t\tret = max(ret,num);\n\t}\n\tcout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; ++i)\nusing namespace std;\n\nusing R = long double;\nconst R EPS = 1e-10;\nint sgn(const R &x) {return (x > EPS) - (x < -EPS);}\nusing P = complex<R>;\nconst P O = P(0, 0);\nusing L = struct {P s, t;};\nusing VP = vector<P>;\n\nauto & operator >>(istream& is, P &p) {R x, y; is >> x >> y; p =P(x,y); return is;}\n\ninline R dot(P o, P a, P b) {return real(conj(a - o) * (b - o));}\ninline R det(P o, P a, P b) {return imag(conj(a - o) * (b - o));}\ninline int sdot(P o, P a, P b) {return sgn(dot(o, a, b));}\ninline int sdet(P o, P a, P b) {return sgn(det(o, a, b));}\n\nbool iss(L a, L b) {\n\tint sa = sdet(a.s, a.t, b.s) * sdet(a.s, a.t, b.t);\n\tint sb = sdet(b.s, b.t, a.s) * sdet(b.s, b.t, a.t);\n\treturn max(sa, sb) < 0;\n}\n\nP cross(L a, L b) {\n\tR u = det(a.s, b.s, b.t) / det(O, a.t - a.s, b.t - b.s);\n\treturn (1 - u) * a.s + u * a.t;\n}\n\nbool in_polygon(const VP &pol, const P &p) {\n\tconst int n = pol.size();\n\tint res = 0;\n\trep(i, n) {\n\t\tP a = pol[i], b = pol[(i + 1) % n];\n\t\tbool f = sgn(imag(p - a)) >= 0, s = sgn(imag(p - b)) < 0;\n\t\tif (sgn(imag(b - a))*sdet(a, b, p) == 1 and f == s) res += 2 * f - 1;\n\t}\n\treturn res > 0;\n}\n\nint main(void) {\n\tint n, m;\n\tcin >> n >> m;\n\tVP pol[20];\n\n\trep(i, n) {\n\t\tint l;\n\t\tcin >> l;\n\t\tpol[i] = VP(l);\n\t\trep(j, l) cin >> pol[i][j];\n\t}\n\n\tVP cand(m);\n\trep(i, m) cin >> cand[i];\n\n\tvector<L> lines;\n\trep(i, m) rep(j, n) for (auto &p : pol[j]) lines.push_back(L{cand[i], p});\n\n\tconst int k = lines.size();\n\n\tvector<P> points;\n\trep(j, k)rep(i, k) points.push_back(cross(lines[i], lines[j]));\n\n\tvector<L> obj;\n\trep(i, n) {\n\t\tconst int l = pol[i].size();\n\t\trep(j, l) obj.push_back(L{pol[i][j], pol[i][(j + 1) % l]});\n\t}\n\n\tint ans = 0;\n\tfor (auto &tar : points) {\n\t\tif(isnan(real(tar)) or isnan(imag(tar))) continue; \n\t\trep(i, n) if (in_polygon(pol[i], tar)) continue;\n\n\t\tint cur = 0;\n\n\t\trep(i, m) {\n\t\t\tL seg = L{tar, cand[i]};\n\t\t\tbool ok = true;\n\t\t\tfor (auto &seg2 : obj) if (iss(seg, seg2)) ok = false;\n\t\t\tif (ok) cur++;\n\t\t}\n\n\t\tans = max(ans, cur);\n\t}\n\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef complex<double> C;\ntypedef pair<int,int>P;\n\nconst double PI = 4*atan(1.0);\n\nnamespace std\n{\n    bool operator < (const C a, const C b) {\n        return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n    }\n}\n\nstruct L : public vector<C>\n{\n    L(const C a, const C b) {\n        push_back(a); push_back(b);\n    }\n};\n\nbool eq(double a,double b)\n{\n  return (-EPS<a-b&&a-b<EPS);\n}\n\nbool eq(C c1,C c2)\n{\n  return (eq(c1.real(),c2.real()) && eq(c1.imag(),c2.imag()));\n}\n\n//?????¶??????sqrt\ndouble Sqrt(double x)\n{\n    if(x<0) return 0;\n    else    return sqrt(x);\n}\n\n//??£??????\nC normalize(C c)\n{\n    return c / abs(c);\n}\n\n//?§????(rad)\ndouble getarg(C a,C b){\n    return arg(b*conj(a));\n}\n\n//??????\ndouble cross(const C a, const C b)\n{\n    return imag(conj(a)*b);\n}\n//??????\ndouble dot(const C a, const C b)\n{\n    return real(conj(a)*b);\n}\n\nint ccw(C a, C b, C c)\n{\n    b -= a; c -= a;\n    if(cross(b, c) > 0)   return +1;       // counter clockwise\n    if(cross(b, c) < 0)   return -1;       // clockwise\n    if(dot(b, c) < 0)     return +2;       // c--a--b on line\n    if(norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;\n}\n//??´???????????????????????????(????????´??????True)\nbool intersectLL(const L &l, const L &m)\n{\n    return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;\n}\n//??´?????¨?????????????????????(????????±??????????????¨??????)\nbool intersectLS(const L &l, const L &s)\n{\n    return cross(l[1]-l[0], s[0]-l[0]) * cross(l[1]-l[0], s[1]-l[0]) < EPS;\n}\n//??´?????¨????????????(??±???)??????\nbool intersectLP(const L &l, const C p)\n{\n    return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\n//??????????????????????????????(????????±??????????????¨??????)\nbool intersectSS(const L &s, const L &t)\n{\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) < 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) < 0;\n}\n//????????¨????????????(??±???)??????\nbool intersectSP(const L &s, const C p)\n{\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;\n}\n//???p?????´???l???????°???±\nC projection(const L &l, const C p)\n{\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\n//???p?????´???l????????¨??????????§°?§????\nC reflection(const L &l, const C p)\n{\n    return p + (projection(l, p) - p)*2.0;\n}\n//?????¨??´???????????¢\ndouble distanceLP(const L &l, const C p)\n{\n    return abs(p - projection(l, p));\n}\n//??´?????¨??´???????????¢\ndouble distanceLL(const L &l, const L &m)\n{\n    return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n//??´?????¨??????????????¢\ndouble distanceLS(const L &l, const L &s)\n{\n    if (intersectLS(l, s)) return 0;\n    return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\n//????????¨???????????¢\ndouble distanceSP(const L &s, const C p)\n{\n    const C r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n}\n//????????¨??????????????¢\ndouble distanceSS(const L &s, const L &t)\n{\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n//??´???????????????????????????\nC crosspointLL(const L &l, const L &m)\n{\n    double A = cross(l[1] - l[0], m[1] - m[0]);\n    double B = cross(l[1] - l[0], l[1] - m[0]);\n    //????????´????????¨???\n    if(abs(A) < EPS && abs(B) < EPS){\n        return m[0];\n    }\n    return m[0] + B / A * (m[1] - m[0]);\n}\n//?????¨??´????????????\ndouble gettime(C c1,C c2)\n{\n  return (dot(c1,c2) < 0 ? -1.0 : 1.0 ) * abs(c2) / abs(c1);\n}\n//?????¨??´????????????\nvector<C> crosspointCL(C c1,double r1,L l)\n{\n    C a=l[0], b=l[1];\n    vector<C> res;\n    C base=b-a,  target=projection(L(a,b),c1);\n    double length=abs(base), h=abs(c1-target);\n    base/=length;\n    if(r1+EPS<h)    return res;\n    double w=Sqrt(r1*r1-h*h);\n    double LL=gettime(normalize(b-a),target-a)-w,RR=LL+w*2.0;\n    res.push_back(a+base*LL);\n    if(eq(LL,RR))   return res;\n    res.push_back(a+base*RR);\n    return res;\n}\n//?????¨???????????????\nvector<C> crosspointCS(C c1,double r1,L s)\n{\n    vector<C> tmp=crosspointCL(c1,r1,s);\n    vector<C> res;\n    rep(i,tmp.size()){\n        if(eq(abs(s[1]-s[0]),abs(s[0]-tmp[i])+abs(s[1]-tmp[i]))){\n            res.push_back(tmp[i]);\n        }\n    }\n    return res;\n}\n//?????????????????????\nL crosspointCC(const C c1, const double r1, const C c2, const double r2)\n{\n  C a = conj(c2-c1), b = (r2*r2-r1*r1-(c2-c1)*conj(c2-c1)), c = r1*r1*(c2-c1);\n  C d = b*b-4.0*a*c;\n  C z1 = (-b+sqrt(d))/(2.0*a)+c1, z2 = (-b-sqrt(d))/(2.0*a)+c1;\n  return L(z1, z2);\n}\n//?????¨????§???¢?????±?????¨????????¢???\ndouble getarea(C c1,double r1,C a,C b)\n{\n    C va=c1-a,vb=c1-b;\n    double A=abs(va),B=abs(vb);\n    double f=cross(va,vb),d=distanceSP(L(a,b),c1),res=0;\n    if(eq(f,0.0))   return 0;\n    if(A < r1+EPS && B < r1+EPS)    return f*0.5;\n    if(d>r1-EPS)    return r1*r1*M_PI*getarg(va,vb)/(2.0*M_PI);\n    vector<C> u=crosspointCS(c1,r1,L(a,b));\n    u.insert(u.begin(),a),u.push_back(b);\n    for(int i=0;i+1<(int)u.size();i++){\n        res+=getarea(c1,r1,u[i],u[i+1]);\n    }\n    return res;\n}\ndouble getcrossarea(vector<C> t,C c1,double r1)\n{\n    int n=t.size();\n    if(n<3) return 0;\n    double res=0;\n    rep(i,n){\n      C a=t[i], b=t[(i+1)%n];\n      res += getarea(c1,r1,a,b);\n    }\n    return res;\n}\n//??????????±???????\nvector<C> convex_full(vector<C> ps)\n{\n    int n = ps.size(), k = 0;\n    sort(ps.begin(), ps.end());\n    vector<C> ch(2*n);\n    for (int i = 0; i < n; ch[k++] = ps[i++]){\n        while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) k--;\n    }\n    for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]){\n        while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) k--;\n    }\n    ch.resize(k-1);\n    return ch;\n}\n//?????§??????\nbool isconvex(const vector<C> &ps)\n{\n    rep(i,ps.size()){\n        if (ccw(ps[(i+ps.size()-1) % ps.size()],ps[i],ps[(i+1) % ps.size()])) return false;\n    }\n    return true;\n}\n//????§???¢?????¢???\ndouble area(const vector<C> &ps)\n{\n    double A = 0;\n    rep(i,ps.size()){\n        A += cross(ps[i],ps[(i+1) % ps.size()]);\n    }\n    return A / 2.0;\n}\n//???????§???¢?????´?????§???????????????????????´????????¢\nvector<C> convex_cut(const vector<C> &ps, const L &l)\n{\n    vector<C> Q;\n    rep(i,ps.size()){\n        C A = ps[i], B = ps[(i+1)%ps.size()];\n        if (ccw(l[0], l[1], A) != -1) Q.push_back(A);\n        if (ccw(l[0], l[1], A)*ccw(l[0], l[1], B) < 0)\n            Q.push_back(crosspointLL(L(A, B),l));\n    }\n    return Q;\n}\n//??????????§???¢???????????????????????????(0??????????????????,1?????????,2???????????????)\nint contains(const vector<C>& ps, const C p)\n{\n    bool flag = false;\n    rep(i,ps.size()) {\n        C a = ps[i] - p, b = ps[(i+1)%ps.size()] - p;\n        if (imag(a) > imag(b)) swap(a, b);\n        if (imag(a) <= 0 && 0 < imag(b)){\n            if (cross(a, b) < 0) flag = !flag;\n        }\n        if (cross(a, b) == 0 && dot(a, b) <= 0) return 1;\n  }\n  return flag ? 2 : 0;\n}\n//???????§???¢?????????\nvector<C> convex_intersection(vector<C>& ps,vector<C>& qs)\n{\n\tvector<C> rs;\n\tint a = ps.size(),b = qs.size();\n\trep(i,a){\n        if(contains(qs,ps[i])){\n            rs.push_back(ps[i]);\n        }\n    }\n\trep(i,b){\n        if(contains(ps,qs[i])){\n            rs.push_back(qs[i]);\n        }\n    }\n    rep(i,a){\n        rep(j,b){\n            L l1(ps[i],ps[(i+1)%a]),l2(qs[j],qs[(j+1)%b]);\n\t\t    if(intersectSS(l1,l2)){\n                rs.push_back(crosspointLL(l1,l2));\n            }\n        }\n\t}\n\tsort(rs.begin(),rs.end());\n\trs.erase(unique(all(rs)),rs.end());\n\tif(rs.size() <= 1){\n        return rs;\n    }\n\treturn convex_full(rs);\n}\n//???????§???¢?????´???????±???????(?????£????????????)\n//maxi,maxj?????????????????¨??????\ndouble convex_diameter(const vector<C> &ps)\n{\n    const int n = ps.size();\n    int is = 0, js = 0;\n    for (int i = 1; i < n; ++i) {\n        if (imag(ps[i]) > imag(ps[is])) is = i;\n        if (imag(ps[i]) < imag(ps[js])) js = i;\n    }\n    double maxd = abs(ps[is]-ps[js]);\n    int i, maxi, j, maxj;\n    i = maxi = is;\n    j = maxj = js;\n    do{\n        if (cross(ps[(i+1)%ps.size()]-ps[i],ps[(j+1)%ps.size()]-ps[j]) >= 0) j = (j+1) % n;\n        else i = (i+1) % n;\n        if (abs(ps[i]-ps[j]) > maxd) {\n            maxd = abs(ps[i]-ps[j]);\n            maxi = i; maxj = j;\n        }\n    } while (i != is || j != js);\n    return maxd;\n}\n\nbool compyx(C c1,C c2)\n{\n    return c1.imag() != c2.imag() ? c1.imag() < c2.imag() : c1.real() < c2.real();\n}\n\n//????????????????±???????\ndouble closest_pair(C *a, int n)\n{\n    if(n<=1) return INF;\n    int m=n/2;\n    double x=a[m].real();\n    double d=min(closest_pair(a,m),closest_pair(a+m,n-m));\n    inplace_merge(a,a+m,a+n,compyx);\n    vector<C> b;\n    rep(i,n){\n        if(abs(x-a[i].real())>=d) continue;\n        rep(j,b.size()){\n            C dp=a[i]-b[b.size()-1-j];\n            if(dp.imag()>=d) break;\n            d=min(d,abs(dp));\n        }\n        b.push_back(a[i]);\n    }\n    return d;\n}\ndouble compute_shortest(C *a,int n)\n{\n    sort(a,a+n);\n    return closest_pair(a,n);\n}\n//2??????????????¢????????????(????????????2??????????????±?????\\????????°)\nint getstateCC(C c1,double r1,C c2,double r2)\n{\n    double d=abs(c1-c2);\n    if(d>r1+r2+EPS)return 4;\n    if(d>r1+r2-EPS)return 3;\n    if(d>abs(r1-r2)+EPS)return 2;\n    if(d>abs(r1-r2)-EPS)return 1;\n    return 0;\n}\n//?????????????????\\???????????????????????\\???\nC gettangentCP_(C c1,double r1,C p,int flg){\n    C base=c1-p;\n    double w=Sqrt(norm(base)-r1*r1);\n    C s=p+base*C(w,r1 * flg)/norm(base)*w;\n    return s;\n}\n//????????????????????\\???\nvector<L> gettangentCP(C c1,double r1,C p){\n    vector<L> res;\n    C s=gettangentCP_(c1,r1,p,1);\n    C t=gettangentCP_(c1,r1,p,-1);\n    //??????????????¨??????????????´???\n    if(eq(s,t)){\n        res.push_back(L(s,s+(c1-p)*C(0,1)));\n    }else{\n        res.push_back(L(p,s));\n        res.push_back(L(p,t));\n    }\n    return res;\n}\n\n//2????????±????????\\???????±???????\nL getintangent(C c1,double r1,C c2,double r2,double flg)\n{\n    C base=c2-c1;\n    double w=r1+r2;\n    double h=Sqrt(norm(base)-w*w);\n    C k=base*C(w,h*flg)/norm(base);\n    return L(c1+k*r1,c2-k*r2);\n}\n//2????????±????????\\???????±???????\nL getouttangent(C c1,double r1,C c2,double r2,double flg)\n{\n    C base=c2-c1;\n    double h=r2-r1;\n    double w=Sqrt(norm(base)-h*h);\n    C k=base*C(w,h*flg)/norm(base)*C(0,flg);\n    return L(c1+k*r1,c2+k*r2);\n}\n//2????????±?????\\???????±???????(?????´??????????????????????????????????????\\???)\nvector<L> gettangentCC(C c1,double r1,C c2,double r2)\n{\n    vector<L> res;\n    double d=abs(c1-c2);\n    if(d>r1+r2+EPS)  res.push_back(getintangent(c1,r1,c2,r2,1));\n    if(d>r1+r2-EPS)  res.push_back(getintangent(c1,r1,c2,r2,-1));\n    if(d>abs(r1-r2)+EPS)    res.push_back(getouttangent(c1,r1,c2,r2,1));\n    if(d>abs(r1-r2)-EPS)    res.push_back(getouttangent(c1,r1,c2,r2,-1));\n    return res;\n}\n\nint main()\n{\n    int n,m;\n    cin >> n >> m;\n    vector<vector<C> > poly(n);\n    rep(i,n){\n        int sz;\n        cin >> sz;\n        rep(j,sz){\n            int u,v;\n            cin >> u >> v;\n            poly[i].pb(C(u,v));\n        }\n    }\n    vector<C> cand(m);\n    rep(i,m){\n        int u,v;\n        cin >> u >> v;\n        cand[i] = C(u,v);\n    }\n    if(m == 1){\n        cout << \"1\\n\";\n        return 0;\n    }\n    if(n == 0){\n        cout << m << endl;\n        return 0;\n    }\n    vector<vector<L> > ln(m);\n    rep(i,m){\n        rep(j,n){\n            rep(k,len(poly[j])){\n                ln[i].push_back(L(cand[i],poly[j][k]));\n            }\n        }\n    }\n    vector<C> point;\n    rep(i,m){\n        rep(j,len(ln[i])){\n            srep(k,i+1,m){\n                rep(l,len(ln[k])){\n                    if(intersectLL(ln[i][j],ln[k][l])){\n                        point.pb(crosspointLL(ln[i][j],ln[k][l]));\n                    }\n                }\n            }\n        }\n    }\n    int mx = 0;\n    rep(i,len(point)){\n        int res = 0;\n        rep(j,m){\n            bool flag = true;\n            rep(k,n){\n                rep(l,len(poly[k])){\n                    if(intersectSS(L(point[i],cand[j]),L(poly[k][l],poly[k][(l+1)%len(poly[k])]))){\n                        flag = false;\n                        break;\n                    }\n                }\n                if(!flag){\n                    break;\n                }\n            }\n            if(flag){\n                res++;\n            }\n        }\n        cmx(mx,res);\n    }\n    cout << mx << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nstruct Point { long double px, py; };\nstruct Line { Point p1, p2; };\nPoint Minus(const Point&a, const Point&b) { return{ a.px - b.px,a.py - b.py }; }\nPoint Plus(const Point&a, const Point&b) { return{ a.px + b.px,a.py + b.py }; }\nPoint Times(const Point&a, const long double&b) { return{ a.px *b,a.py *b }; }\nlong double norm(const Point& a) { return a.px * a.px + a.py * a.py; }\nlong double abs(const Point& a) { return sqrtl(norm(a)); }\nlong double arg(const Point& a) { return atan2l(a.py, a.px); }\nlong double dot(const Point& a, const Point& b) { return a.px * b.px + a.py * b.py; }\nlong double crs(const Point& a, const Point& b) { return a.px * b.py - a.py * b.px; }\nint ccw(const Point& p0, const Point& p1, const Point& p2) {\n\tPoint a = Minus(p1, p0), b = Minus(p2, p0);\n\tif (crs(a, b) > 1e-10) return 1;\n\tif (crs(a, b) < -1e-10) return -1;\n\tif (dot(a, b) < -1e-10) return 2;\n\tif (norm(a) < norm(b)) return -2;\n\treturn 0;\n}\nbool its(const Point& p1, const Point& p2, const Point& p3, const Point& p4) {\n\treturn (ccw(p1, p2, p3) * ccw(p1, p2, p4) < 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) < 0);\n}\nPoint crp(Line a, Line b) {\n\tlong double d1 = abs(crs(Minus(a.p2, a.p1), Minus(b.p2, b.p1)));\n\tlong double d2 = abs(crs(Minus(a.p2, a.p1), Minus(a.p2, b.p1)));\n\treturn Plus(b.p1, Times(Minus(b.p2, b.p1), d2 / d1));\n}\nint n, m; vector<Point>x[10]; Point z[10];\nvector<Point>po;\nvector<Line>L, LNS;\nint main() {\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; i++) {\n\t\tint M; cin >> M;\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tPoint w; cin >> w.px >> w.py; x[i].push_back(w); po.push_back(w);\n\t\t}\n\t\tfor (int j = 0; j < M; j++)LNS.push_back(Line{ x[i][j],x[i][(j + 1) % M] });\n\t}\n\tint R = po.size();\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> z[i].px >> z[i].py;\n\t}\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < R; j++) {\n\t\t\tif (po[j].px == z[i].px && po[j].py == z[i].py)continue;\n\t\t\tL.push_back(Line{ po[j],z[i] });\n\t\t\tL.push_back(Line{ Point{ po[j].px + 1e-4,po[j].py },z[i] });\n\t\t\tL.push_back(Line{ Point{ po[j].px - 1e-4,po[j].py },z[i] });\n\t\t\tL.push_back(Line{ Point{ po[j].px,po[j].py + 1e-4 },z[i] });\n\t\t\tL.push_back(Line{ Point{ po[j].px,po[j].py - 1e-4 },z[i] });\n\t\t}\n\t}\n\tfor (int i = 0; i < po.size(); i++) {\n\t\tfor (int j = i + 1; j < po.size(); j++) {\n\t\t\tif (po[j].px == po[i].px && po[j].py == po[i].py)continue;\n\t\t\tL.push_back(Line{ po[i],po[j] });\n\t\t}\n\t}\n\tfor (int i = 0; i < LNS.size(); i++) {\n\t\tL.push_back(LNS[i]);\n\t}\n\tint maxn = 0;\n\tfor (int i = 0; i < L.size(); i++) {\n\t\tfor (int j = i + 1; j < L.size(); j++) {\n\t\t\tPoint WW = crp(L[i], L[j]);\n\t\t\tlong double L1 = (L[i].p1.px - L[i].p2.px) / (L[i].p1.py - L[i].p2.py); if (fabs(L1) >= 1e9)L1 = 1e9;\n\t\t\tlong double L2 = (L[j].p1.px - L[j].p2.px) / (L[j].p1.py - L[j].p2.py); if (fabs(L2) >= 1e9)L2 = 1e9;\n\t\t\tif (L1 == L2)continue;\n\t\t\tint cnt = 0;\n\t\t\tfor (int k = 0; k < m; k++) {\n\t\t\t\tif (WW.px == z[k].px && WW.py == z[k].py)continue;\n\t\t\t\tLine LN = Line{ WW,z[k] };\n\t\t\t\tint flag = 1;\n\t\t\t\tfor (int l = 0; l < LNS.size(); l++) {\n\t\t\t\t\tif (its(LN.p1, LN.p2, LNS[l].p1, LNS[l].p2) == true) {\n\t\t\t\t\t\tflag = 0; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flag == 1) {\n\t\t\t\t\tcnt += flag;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmaxn = max(maxn, cnt);\n\t\t}\n\t}\n\tcout << maxn << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nconstexpr double EPS = (1e-10);\n\nstruct Point {\n    double x, y;\n\n    Point() {}\n    Point(double x, double y) : x{x}, y{y} {}\n\n    Point operator + (const Point& p) const\n    {\n        return Point(x + p.x, y + p.y);\n    }\n    \n    Point operator - (const Point& p) const\n    {\n        return Point(x - p.x, y - p.y);\n    }\n    \n    Point operator * (const double& k) const\n    {\n        return Point(x * k, y * k);\n    }\n};\n\ndouble dot(const Point& a, const Point& b)\n{\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(const Point& a, const Point& b)\n{\n    return a.x * b.y - b.x * a.y;\n}\n\ndouble norm(const Point& p){\n    return dot(p, p);\n}\n\ndouble abs(const Point& p)\n{\n    return sqrt(norm(p));\n}\n\nconstexpr int COUNTER_CLOCKWISE = +1;\nconstexpr int CLOCKWISE         = -1;\nconstexpr int ONLINE_BACK       = +2;\nconstexpr int ONLINE_FRONT      = -2;\nconstexpr int ON_SEGMENT        = +0;\nusing Vector = Point;\n\nint ccw(const Point& p0, const Point& p1, const Point& p2)\n{\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if (cross(a, b) > EPS)  return COUNTER_CLOCKWISE;\n    if (cross(a, b) < -EPS) return CLOCKWISE;\n    if (dot(a, b) < -EPS)   return ONLINE_BACK; \n    if (norm(a) < norm(b))  return ONLINE_FRONT;\n    return ON_SEGMENT;                         \n}\n\nstruct Segment {\n    Point s, t;\n    Segment() {}\n    Segment(const Point& s, const Point& t) : s{s}, t{t} {}\n};\n\nbool isIntersectSS(const Segment& a, const Segment& b)\n{\n    Point s[2] = {a.s, a.t}, t[2] = {b.s, b.t};\n    return (ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) < 0 &&\n            ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) < 0);\n}\n\nusing Line = Segment;\n\nbool isIntersectLL(const Line& a, const Line& b)\n{\n    return (abs(cross(a.t - a.s, b.t - b.s)) > EPS || \n            abs(cross(a.t - a.s, b.t - b.s)) < EPS);  \n}\n\nPoint crosspointLL(const Line& a, const Line& b)\n{\n    using Vector = Point;\n    Vector va = a.t - a.s, vb = b.t - b.s;\n    double d = cross(vb, va);\n    if (abs(d) < EPS) return b.s;\n    return a.s + va * cross(vb, b.t - a.s) * (1.0 / d);\n}\n\nusing Polygon = vector<Point>;\n#define curr(G, i) (G[i % G.size()])\n#define next(G, i) (G[(i + 1) % G.size()])\n\nint get_score(const Point& cp, const vector<Point>& per,\n              const vector<Polygon>& pgs)\n{\n    int score = 0;\n    for (const auto& p : per) {\n        Segment s1{p, cp};\n        bool con = 0;\n        for (const auto& pg : pgs) {\n            for (int i = 0; i < (int)pg.size(); i++) {\n                Segment s2{curr(pg, i), next(pg, i)};\n                if (isIntersectSS(s1, s2)) {\n                    con = 1;\n                }\n            }\n        }\n        if (!con) score++;\n    }\n    return score;\n}\n\nint get_num(int m1, int m2, const vector<Point>& per,\n            int n1, int n2, const vector<Polygon>& pgs)\n{\n    int max_num = 0;\n    for (const auto& p1 : pgs[n1]) {\n        for (const auto& p2 : pgs[n2]) {\n            Line l1{per[m1], p1}, l2{per[m2], p2};\n            if (!isIntersectLL(l1, l2)) continue;\n            auto cp = crosspointLL(l1, l2);\n\n            max_num = max(max_num, get_score(cp, per, pgs));            \n        }\n    }\n    return max_num;\n}\n\nint solve(const vector<Polygon>& pgs, const vector<Point>& per)\n{\n    int res = 1;\n    int N = pgs.size(), M = per.size();\n    for (int i = 0; i < M; i++) {\n        for (int j = i + 1; j < M; j++) {\n            for (int k = 0; k < N; k++) {\n                for (int l = k; l < N; l++) {\n                    res = max(res, get_num(i, j, per, k, l, pgs));\n                }\n            }\n        }\n    }\n    return res;\n}\n\nint main()\n{\n    int N, M;\n    cin >> N >> M;\n    vector<Polygon> pgs(N);\n    for (int i = 0; i < N; i++) {\n        int L;\n        cin >> L;\n        pgs[i].resize(L);\n        for (int j = 0; j < L; j++) {\n            cin >> pgs[i][j].x >> pgs[i][j].y;\n        }\n    }\n\n    vector<Point> per(M);\n    for (int i = 0; i < M; i++) {\n        cin >> per[i].x >> per[i].y;\n    }\n    cout << solve(pgs, per) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef ___Geometry_Library\n#define ___Geometry_Library\n\n// ------ Includes ------ //\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <algorithm>\n\n// ------ Defines ------ //\ntypedef long double GType;\ntypedef std::complex<GType> Point;\ntypedef std::pair<Point, Point> Segment;\n\n// ------ Constants ------ //\nconst GType EPS = 1.0e-10L;\n\n// ------ Functions Level 1 ------ //\nGType dot(const Point& p1, const Point& p2) {\n\treturn (std::conj(p1) * p2).real();\n}\nGType cross(const Point& p1, const Point& p2) {\n\treturn (std::conj(p1) * p2).imag();\n}\nint ccw(const Point& p1, const Point& p2, const Point& p3) {\n\tPoint v1 = p2 - p1, v2 = p3 - p1;\n\tif (cross(v1, v2) > EPS) return +1;\n\tif (cross(v1, v2) < -EPS) return -1;\n\tif (dot(v1, v2) < -EPS) return +2;\n\tif (std::norm(v1) < std::norm(v2)) return -2;\n\treturn 0;\n}\n\n// ------ Functions Level 2 ------ //\nbool intersect(const Segment& s1, const Point& p1, bool segflag) {\n\tif (!segflag) return std::abs(cross(s1.second - p1, s1.first - p1)) < EPS;\n\treturn (std::abs(s1.first - p1) + std::abs(s1.second - p1) - std::abs(s1.second - s1.first)) < EPS;\n}\nbool intersect(const Segment& s1, const Segment& s2, bool segflag) {\n\tif (!segflag) return cross(s1.second - s1.first, s2.first - s1.first) * cross(s1.second - s1.first, s2.second - s1.first) < EPS;\n\treturn (ccw(s1.first, s1.second, s2.first) * ccw(s1.first, s1.second, s2.second) < 0 && ccw(s2.first, s2.second, s1.first) * ccw(s2.first, s2.second, s1.second) < 0);\n}\nPoint crosspoint(const Segment& s1, const Segment& s2) {\n\tGType r1 = cross(s1.second - s1.first, s2.second - s2.first);\n\tGType r2 = cross(s1.second - s1.first, s1.second - s2.first);\n\tif (std::abs(r1) < EPS && std::abs(r2) < EPS) return s2.first;\n\treturn s2.first + r2 / r1 * (s2.second - s2.first);\n}\n\n#endif\n\n#include <vector>\n#include <iostream>\nusing namespace std;\nint N, M, r, x, y; vector<vector<Point> > v1; vector<Point> v2, v3;\nint main() {\n\tcin >> N >> M;\n\tv1.resize(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> r;\n\t\tfor (int j = 0; j < r; j++) {\n\t\t\tcin >> x >> y;\n\t\t\tv1[i].push_back(Point(x, y));\n\t\t}\n\t\tv3.insert(v3.end(), v1[i].begin(), v1[i].end());\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> x >> y;\n\t\tv2.push_back(Point(x, y));\n\t}\n\tint ret = 1;\n\tfor (int i1 = 0; i1 < M; i1++) {\n\t\tfor (int j1 = 0; j1 < v3.size(); j1++) {\n\t\t\tfor (int i2 = i1 + 1; i2 < M; i2++) {\n\t\t\t\tfor (int j2 = j1 + 1; j2 < v3.size(); j2++) {\n\t\t\t\t\tif (abs(cross(v2[i1] - v3[j1], v2[i2] - v3[j2])) > EPS) {\n\t\t\t\t\t\tPoint p1 = crosspoint(make_pair(v2[i1], v3[j1]), make_pair(v2[i2], v3[j2]));\n\t\t\t\t\t\tint res = 0;\n\t\t\t\t\t\tfor (int k = 0; k < M; k++) {\n\t\t\t\t\t\t\tbool ok = true;\n\t\t\t\t\t\t\tfor (int l1 = 0; l1 < N; l1++) {\n\t\t\t\t\t\t\t\tfor (int l2 = 0; l2 < v1[l1].size(); l2++) {\n\t\t\t\t\t\t\t\t\tif (intersect(make_pair(p1, v2[k]), make_pair(v1[l1][l2], v1[l1][(l2 + 1) % v1[l1].size()]), true)) ok = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (ok) res++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tret = max(ret, res);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < v3.size(); i++) {\n\t\tint res = 0;\n\t\tfor (int k = 0; k < M; k++) {\n\t\t\tbool ok = true;\n\t\t\tfor (int l1 = 0; l1 < N; l1++) {\n\t\t\t\tfor (int l2 = 0; l2 < v1[l1].size(); l2++) {\n\t\t\t\t\tPoint p2 = v1[l1][l2], p3 = v1[l1][(l2 + 1) % v1[l1].size()];\n\t\t\t\t\tif (v3[i] == p2 || v3[i] == p3) continue;\n\t\t\t\t\tif (intersect(make_pair(v3[i], v2[k]), make_pair(p2, p3), true)) ok = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ok) res++;\n\t\t}\n\t\tret = max(ret, res);\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define PI 3.141592653589793238\n \n// COUNTER CLOCKWISE\nstatic const int CCW_COUNTER_CLOCKWISE = 1;\nstatic const int CCW_CLOCKWISE = -1;\nstatic const int CCW_ONLINE_BACK = 2;\nstatic const int CCW_ONLINE_FRONT = -2;\nstatic const int CCW_ON_SEGMENT = 0;\n\n//Intercsect Circle & Circle\nstatic const int ICC_SEPERATE = 4;\nstatic const int ICC_CIRCUMSCRIBE = 3;\nstatic const int ICC_INTERSECT = 2;\nstatic const int ICC_INSCRIBE = 1;\nstatic const int ICC_CONTAIN = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator+(Point p) {return Point(x+p.x,y+p.y);}\n  Point operator-(Point p) {return Point(x-p.x,y-p.y);}\n  Point operator*(double k){return Point(x*k,y*k);}\n  Point operator/(double k){return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n    //grid-point only\n    //return !equals(x,p.x)?x<p.x:!equals(y,p.y)?y<p.y:0;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n  }\n};\n\nistream &operator >> (istream &is,Point &p){\n  is>>p.x>>p.y;\n  return is;\n}\n\nostream &operator << (ostream &os,Point p){\n  os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y;\n  return os;\n}\n\nbool sort_x(Point a,Point b){\n  return a.x!=b.x?a.x<b.x:a.y<b.y;\n}\n\nbool sort_y(Point a,Point b){\n  return a.y!=b.y?a.y<b.y:a.x<b.x;\n}\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nistream &operator >> (istream &is,Segment &s){\n  is>>s.p1>>s.p2;\n  return is;\n}\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(){}\n  Circle(Point c,double r):c(c),r(r){}\n};\n\nistream &operator >> (istream &is,Circle &c){\n  is>>c.c>>c.r;\n  return is;\n}\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\nint ccw(Point p0,Point p1,Point p2);\nbool intersectSS(Point p1,Point p2,Point p3,Point p4);\nbool intersectSS(Segment s1,Segment s2);\nint intersectCC(Circle c1,Circle c2);\nbool intersectSC(Segment s,Circle c);\ndouble getDistanceLP(Line l,Point p);\ndouble getDistanceSP(Segment s,Point p);\ndouble getDistanceSS(Segment s1,Segment s2);\nPoint getCrossPointSS(Segment s1,Segment s2);\nPoint getCrossPointLL(Line l1,Line l2);\nPolygon getCrossPointCL(Circle c,Line l);\nPolygon getCrossPointCC(Circle c1,Circle c2);\nint contains(Polygon g,Point p);\nPolygon andrewScan(Polygon s);\nPolygon convex_hull(Polygon ps);\ndouble diameter(Polygon s);\nbool isConvex(Polygon p);\ndouble area(Polygon s);\nPolygon convexCut(Polygon p,Line l);\nLine bisector(Point p1,Point p2);\nVector translate(Vector v,double theta);\nvector<Line> corner(Line l1,Line l2);\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return CCW_COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CCW_CLOCKWISE;\n  if(dot(a,b) < -EPS) return CCW_ONLINE_BACK;\n  if(a.norm()<b.norm()) return CCW_ONLINE_FRONT;\n  return CCW_ON_SEGMENT;\n}\n// changed\nbool intersectSS(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) < 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) < 0 );\n}\n\nbool intersectSS(Segment s1,Segment s2){\n  return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nint intersectCC(Circle c1,Circle c2){\n  if(c1.r<c2.r) swap(c1,c2);\n  double d=abs(c1.c-c2.c);\n  double r=c1.r+c2.r;\n  if(equals(d,r)) return ICC_CIRCUMSCRIBE;\n  if(d>r) return ICC_SEPERATE;\n  if(equals(d+c2.r,c1.r)) return ICC_INSCRIBE;\n  if(d+c2.r<c1.r) return ICC_CONTAIN;\n  return ICC_INTERSECT;\n}\n\nbool intersectSC(Segment s,Circle c){\n  double d=getDistanceSP(s,c.c);\n  return d<=c.r;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistanceSS(Segment s1,Segment s2){\n  if(intersectSS(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPointSS(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon getCrossPointCL(Circle c,Line l){\n  Polygon p(2);\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  p[0]=pr+e*base;\n  p[1]=pr-e*base;\n  return p;\n}\n\nPolygon getCrossPointCC(Circle c1,Circle c2){\n  Polygon p(2);\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  p[0]=c1.c+polar(c1.r,t+a);\n  p[1]=c1.c+polar(c1.r,t-a);\n  return p;\n}\n\n// IN:2 ON:1 OUT:0\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\nPolygon convex_hull(Polygon ps){\n  int n=ps.size();\n  sort(ps.begin(),ps.end(),sort_y);\n  int k=0;\n  Polygon qs(n*2);\n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\ndouble diameter(Polygon s){\n  Polygon p=s;\n  int n=p.size();\n  if(n==2) return abs(p[0]-p[1]);\n  int i=0,j=0;\n  for(int k=0;k<n;k++){\n    if(p[i]<p[k]) i=k;\n    if(!(p[j]<p[k])) j=k;\n  }\n  double res=0;\n  int si=i,sj=j;\n  while(i!=sj||j!=si){\n    res=max(res,abs(p[i]-p[j]));\n    if(cross(p[(i+1)%n]-p[i],p[(j+1)%n]-p[j])<0.0){\n      i=(i+1)%n;\n    }else{\n      j=(j+1)%n;\n    }\n  }\n  return res;\n}\n\nbool isConvex(Polygon p){\n  bool f=1;\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    int t=ccw(p[(i+n-1)%n],p[i],p[(i+1)%n]);\n    f&=t!=CCW_CLOCKWISE;\n  }\n  return f;\n}\n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  Polygon p=getCrossPointCC(c1,c2);\n  if(cross(p2-p1,p[0]-p1)>0) swap(p[0],p[1]);\n  return Line(p[0],p[1]);\n}\n\nVector translate(Vector v,double theta){\n  Vector res;\n  res.x=cos(theta)*v.x-sin(theta)*v.y;\n  res.y=sin(theta)*v.x+cos(theta)*v.y;\n  return res;\n}\n\nvector<Line> corner(Line l1,Line l2){\n  vector<Line> res;\n  if(isParallel(l1,l2)){\n    double d=getDistanceLP(l1,l2.p1)/2.0;\n    Vector v1=l1.p2-l1.p1;\n    v1=v1/v1.abs()*d;\n    Point p=l2.p1+translate(v1,90.0*(PI/180.0));\n    double d1=getDistanceLP(l1,p);\n    double d2=getDistanceLP(l2,p);\n    if(abs(d1-d2)>d){\n      p=l2.p1+translate(v1,-90.0*(PI/180.0));\n    }\n    res.push_back(Line(p,p+v1));\n  }else{\n    Point p=getCrossPointLL(l1,l2);\n    Vector v1=l1.p2-l1.p1,v2=l2.p2-l2.p1;\n    v1=v1/v1.abs();\n    v2=v2/v2.abs();\n    res.push_back(Line(p,p+(v1+v2)));\n    res.push_back(Line(p,p+translate(v1+v2,90.0*(PI/180.0))));\n  }\n  return res;\n}\n\nPolygon tangent(Circle c1,Point p2){\n  Circle c2=Circle(p2,sqrt(norm(c1.c-p2)-c1.r*c1.r));\n  Polygon p=getCrossPointCC(c1,c2);\n  sort(p.begin(),p.end());\n  return p;\n}\n\nbool intersectPS(Polygon p,Segment l){\n  int n=p.size();\n  for(int i=0;i<n;i++)\n    if(intersectSS(Segment(p[i],p[(i+1)%n]),l)) return 1;\n  return 0;\n}\n\nsigned main(){\n  int n,m;\n  cin>>n>>m;\n  vector<Polygon> vp(n);\n  for(int i=0;i<n;i++){\n    int l;\n    cin>>l;\n    vp[i]=Polygon(l);\n    for(int j=0;j<l;j++) cin>>vp[i][j];\n  }\n  Polygon p(m);\n  for(int i=0;i<m;i++) cin>>p[i];\n  //puts(\"\");\n  vector<Line> vl;\n  for(int i=0;i<m;i++)\n    for(int j=0;j<n;j++)\n      for(auto q:vp[j])\n\tvl.push_back(Line(p[i],q));\n\n  //return 0;\n  \n  int ans=0;\n  for(int i=0;i<(int)vl.size();i++){\n    for(int j=0;j<i;j++){\n      int tmp=0;\n      if(isParallel(vl[i],vl[j])) continue;\n      Point c=getCrossPointLL(vl[i],vl[j]);\n      for(int k=0;k<m;k++){\n\tSegment s=Segment(c,p[k]);\n\tint f=1;\n\tfor(int l=0;l<n;l++)\n\t  if(intersectPS(vp[l],s)) f=0;\n\ttmp+=f;\n      }\n      ans=max(ans,tmp);\n      \n      if(0){\n\tcout<<i<<\" \"<<vl[i].p1<<\":\"<<vl[i].p2<<endl;\n\tcout<<j<<\" \"<<vl[j].p1<<\":\"<<vl[j].p2<<endl;\n\tcout<<c<<endl;\n\tcout<<\"tmp:\"<<tmp<<endl;\n      }\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ndouble eps = 0.0000001;\nstruct P {\n  double x, y;\n};\nstruct L {\n  P p1, p2;\n  double x() { return p2.x - p1.x; }\n  double y() { return p2.y - p1.y; }\n};\ndouble prod(L l1, L l2) { return l1.x() * l2.y() - l1.y() * l2.x(); }\npair<double, double> interP(L l1, L l2) {\n  double a = l1.x();\n  double b = -l2.x();\n  double c = l1.y();\n  double d = -l2.y();\n  double inv = 1. / (a * d - c * b);\n  double e1 = -l1.p1.x + l2.p1.x;\n  double e2 = -l1.p1.y + l2.p1.y;\n  return make_pair((d * e1 - b * e2) * inv, (-c * e1 + a * e2) * inv);\n}\nbool intersect(L l1, L l2) {\n  if (fabs(prod(l1, l2)) < eps) {\n    return false;\n  }\n  auto p = interP(l1, l2);\n  return eps < p.first && p.first < 1 - eps && eps < p.second &&\n         p.second < 1 - eps;\n}\nint main() {\n\n  int n, m;\n  cin >> n >> m;\n  vector<vector<P>> p(n);\n  for (int i = 0; i < n; i++) {\n    int l;\n    cin >> l;\n    for (int j = 0; j < l; j++) {\n      double x, y;\n      cin >> x >> y;\n      p[i].push_back(P{x, y});\n    }\n  }\n  vector<P> hum(m);\n  for (int i = 0; i < m; i++) {\n    cin >> hum[i].x >> hum[i].y;\n  }\n  vector<L> line;\n  for (int i = 0; i < m; i++) {\n    for (auto &poly : p) {\n      for (int j = 0; j < poly.size(); j++) {\n        line.push_back(L{hum[i], poly[j]});\n      }\n    }\n  }\n  vector<P> ps;\n  for (int i = 0; i < line.size(); i++)\n    for (int j = i + 1; j < line.size(); j++) {\n      if (fabs(prod(line[i], line[j])) < eps)\n        continue;\n      auto rs = interP(line[i], line[j]);\n      ps.push_back(P{line[i].p1.x + line[i].x() * rs.first,\n                     line[i].p1.y + line[i].y() * rs.second});\n    }\n\n  if (n == 0) {\n    cout << m << endl;\n    return 0;\n  }\n  if (m == 1) {\n    cout << 1 << endl;\n    return 0;\n  }\n\n  int ans = 0;\n  for (int i = 0; i < ps.size(); i++) {\n    int score = m;\n    for (int j = 0; j < m; j++) {\n      L l1{ps[i], hum[j]};\n      bool ng = false;\n\n      for (auto &poly : p) {\n        for (int k = 0; k < poly.size(); k++) {\n          P p1 = poly[k];\n          P p2 = poly[(k + 1) % poly.size()];\n          L l2{p1, p2};\n          if (intersect(l1, l2)) {\n            ng = true;\n          }\n        }\n      }\n\n      if (ng) {\n        score--;\n      }\n    }\n    ans = max(ans, score);\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\n \ndouble dot(P a,P b){\n  return real(b*conj(a));\n}\n \ndouble cross(P a,P b){\n  return imag(b*conj(a));\n}\n \ndouble eps = 1e-8;\n \nP crossPoint(L l,L m){\n  double A = cross(l.second-l.first,m.second-m.first);\n  double B = cross(l.second-l.first,l.second-m.first);\n  if( fabs(A) < eps && fabs(B) < eps ) return m.first;\n  else if(fabs(A) >= eps ) return m.first+B/A*(m.second-m.first);\n  else P(0,0);\n}\n \nbool eq(double a,double b){\n  return (-eps<a-b&&a-b<eps);\n}\n \nbool eq(P a,P b){\n  return eq( abs(b-a) , 0 );\n}\n \nbool onSegment(L a,P p){\n  return eq( abs(a.first-a.second) , abs(a.first-p)+abs(a.second-p) );\n}\n \n \nbool isParallel(L a,L b){\n  if( abs(cross(a.first-a.second,b.first-b.second)) < eps ) return true;\n  return false;\n}\n \nint n,m;\nvector<P> G[100];\nvector<P> t;\nvector<L> u;\n \nint check(P a,bool debug=false){\n \n \n \n  int cnt=0;\n  for(int i=0;i<m;i++){\n    L v=L(a,t[i]);\n    bool flg=true;\n    for(int j=0;j<n;j++){\n      int size=G[j].size();\n      for(int k=0;k<size;k++){\n        L w=L(G[j][k],G[j][(k+1)%size]);\n        if(isParallel(v,w))continue;\n        P p=crossPoint(v,w);\n \n        if(eq(w.first,p))continue;\n        if(eq(w.second,p))continue;\n        if(eq(v.first,p))continue;\n        if(eq(v.second,p))continue;\n        if(!onSegment(w,p))continue;\n\t\n        if(onSegment(v,p)){\n          flg=false;\n        }\n      }\n    }\n    if(flg)cnt++;\n  }\n  return cnt;\n}\n \nint solve(){\n \n  if(n==0)return m;\n  int res=0;\n  for(int i=0;i<(int)u.size();i++){\n    for(int j=0;j<i;j++){\n      L a=u[i];\n      L b=u[j];\n \n      P target=crossPoint(a,b);\n \n      if( isParallel(a,b) ) continue;\n      res=max(res,check(target));\n    }\n  }\n  return res;\n}\n \nint main(){\n  cin>>n>>m;\n  for(int i=0;i<n;i++){\n    double x,y;\n    int L;\n    cin>>L;\n    G[i].resize(L);\n    for(int j=0;j<L;j++){\n      cin>>x>>y;\n      G[i][j]=P(x,y);\n    }\n  }\n  for(int i=0;i<m;i++){\n    double x,y;\n    cin>>x>>y;\n    t.push_back(P(x,y));\n  }\n  for(int i=0;i<m;i++){\n    for(int j=0;j<n;j++){\n      for(int k=0;k<(int)G[j].size();k++){\n        u.push_back(L(t[i],G[j][k]));\n      }\n    }\n  }\n \n  cout<<solve()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <iostream>\n#include <cassert>\n#include <complex>\n\nusing namespace std;\ntypedef long long ll;\n\nconst double eps = 1e-8;\n\ntypedef complex<double> P;\n\ndouble dot(P a, P b){\n  return (a * conj(b)).real();\n}\n\ndouble cross(P a, P b){\n  return (conj(a) * b).imag();\n}\n\nint ccw(P a, P b, P c){\n  if(cross(b-a, c-a) > eps) return 1;\n  if(cross(b-a, c-a) < -eps) return -1;\n  if(dot(b-a, c-a) < -eps) return -2;\n  if(dot(a-b, c-b) < -eps) return 2;\n  return 0;\n}\n\nbool isIntersectedLL(P a1, P a2, P b1, P b2){\n  return abs(cross(a1-a2, b1-b2)) > eps;\n}\n\nbool isIntersectedSS(P a1, P a2, P b1, P b2){\n  int a = ccw(b1, b2, a1);\n  int b = ccw(b1, b2, a2);\n  int c = ccw(a1, a2, b1);\n  int d = ccw(a1, a2, b2);\n\n  return a*b < 0 && c*d < 0;\n}\n\n\nP getCrosspointLL(P a1, P a2, P b1, P b2){\n  P a = a2 - a1;\n  P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\nP p[10];\nint l[10];\nP pol[10][20];\n\nint main(){\n  int n, m;\n  int x, y;\n\n  scanf(\"%d%d\", &n, &m);\n  \n  vector<P> vec, vec2;\n\n  for(int i=0;i<n;i++){\n    scanf(\"%d\", l+i);\n    for(int j=0;j<l[i];j++){\n      scanf(\"%d%d\", &x, &y);\n      pol[i][j] = P(x,y);\n      vec.push_back(pol[i][j]);\n      vec2.push_back(pol[i][j]);\n    }\n  }\n\n  for(int i=0;i<m;i++){\n    scanf(\"%d%d\", &x, &y);\n    p[i] = P(x, y);\n    //vec.push_back(p[i]);\n  }\n\n\n\n  for(int i=0;i<m;i++){\n    for(int j=i+1;j<m;j++){\n      for(int t=0;t<vec2.size();t++){\n        for(int q=0;q<vec2.size();q++){\n          if(isIntersectedLL(p[i], vec2[t], p[j], vec2[q])){\n            vec.push_back(getCrosspointLL(p[i], vec2[t], p[j], vec2[q]));\n          }\n        }\n      }\n    }\n  }\n\n  int ans = 0;\n  \n  for(int i=0;i<vec.size();i++){\n    int counter = 0;\n    \n    for(int j=0;j<m;j++){\n      bool flag = true;\n      for(int k=0;k<n;k++){\n        for(int t=0;t<l[k];t++){\n          flag &= !isIntersectedSS(pol[k][t], pol[k][(t+1)%l[k]], p[j], vec[i]);\n        }\n      }\n      counter += flag;\n    }\n\n    ans = max(ans, counter);\n  }\n\n  cout << ans << endl;\n  \n  return 0;  \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n\nusing Real = long double;\nusing Point = std::complex<Real>;\nusing Segment = std::pair<Point, Point>;\nusing Polygon = std::vector<Point>;\n\nbool operator<(const Point& a, const Point& b) {\n    return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n}\n\nstd::istream& operator>>(std::istream& is, Point& p) {\n    Real x, y;\n    is >> x >> y;\n    p = Point(x, y);\n    return is;\n}\n\nconst Real EPS = 1e-10;\nconst Point origin(0, 0);\n\n// 宇宙船演算子\ninline int compare(Real a, Real b) {\n    if (std::abs(a - b) < EPS) return 0;\n    return a - b > 0 ? 1 : -1;\n}\n\ninline Real dist(Point a, Point b) {\n    return std::abs(a - b);\n}\n\ninline Real length(Segment s) {\n    return dist(s.first, s.second);\n}\n\n// inner product\ninline Real dot(Point x, Point y) {\n    return std::real(std::conj(x) * (y));\n}\n\n// outer product\ninline Real cross(Point x, Point y) {\n    return std::imag(std::conj(x) * (y));\n}\n\n// lに対するpの位置\n// 0: on segment\n// 1: counter clockwise  -1: clockwise\n// 2: online front       -2: online back\nint side(Segment s, Point p) {\n    Real c = cross(s.second - s.first, p - s.first);\n    if (compare(c, 0) != 0) return compare(c, 0);\n\n    Real d = dot(s.second - s.first, p - s.first);\n    if (compare(d, 0) < 0) return -2;\n\n    return (compare(length(Segment(s.first, p)), length(s)) > 0 ? 2 : 0);\n}\n\n// 平行判定\ninline bool isparallel(Segment s1, Segment s2) {\n    return compare(cross(s1.second - s1.first, s2.second - s2.first), 0) == 0;\n}\n\n// 線分の交差判定\n// bound: 線分の端点を含むか\ninline bool intersect(Segment s1, Segment s2, bool bound) {\n    return (side(s1, s2.first) * side(s1, s2.second) < bound) &&\n           (side(s2, s1.first) * side(s2, s1.second) < bound);\n}\n\n// 線分の交点\nPoint intersection(Segment s1, Segment s2) {\n    Real c1 = cross(s2.second - s2.first, s1.second - s1.first);\n    Real c2 = cross(s2.second - s2.first, s1.first - s2.first);\n    return s1.first + (s1.second - s1.first) * (-c2 / c1);\n}\n\n\nusing namespace std;\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    vector<Polygon> gs(N);\n    for (auto& g : gs) {\n        int L;\n        cin >> L;\n        g.resize(L);\n        for (auto& p : g) cin >> p;\n    }\n\n    vector<Point> people(M);\n    for (auto& p : people) cin >> p;\n\n    // 有権者と障害物の頂点を結ぶ直線を列挙\n    vector<Segment> segs;\n    for (auto p : people) {\n        for (auto& g : gs) {\n            for (auto q : g) {\n                segs.emplace_back(p, q);\n            }\n        }\n    }\n\n    // 上で列挙した直線同士の交点を列挙\n    vector<Point> stand;\n    for (int i = 0; i < segs.size(); ++i) {\n        for (int j = i + 1; j < segs.size(); ++j) {\n            if (!isparallel(segs[i], segs[j])) {\n                stand.push_back(intersection(segs[i], segs[j]));\n            }\n        }\n    }\n\n    int ans = 0;\n    for (auto p : stand) {\n        int cnt = 0;\n\n        for (auto q : people) {\n            Segment s(p, q);\n            bool judge = true;\n            for (auto& g : gs) {\n                for (int i = 0; i < g.size(); ++i) {\n                    // 多角形の辺と線分が端点を除いて交差するか？\n                    if (intersect(s, Segment(g[i], g[(i + 1) % g.size()]), false)) judge = false;\n                }\n            }\n            if (judge) ++cnt;\n        }\n\n        ans = max(ans, cnt);\n    }\n\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nstruct Point { long double px, py; };\nstruct Line { Point p1, p2; };\nPoint Minus(const Point&a, const Point&b) { return{ a.px - b.px,a.py - b.py }; }\nPoint Plus(const Point&a, const Point&b) { return{ a.px + b.px,a.py + b.py }; }\nPoint Times(const Point&a, const long double&b) { return{ a.px *b,a.py *b }; }\nlong double norm(const Point& a) { return a.px * a.px + a.py * a.py; }\nlong double abs(const Point& a) { return sqrtl(norm(a)); }\nlong double arg(const Point& a) { return atan2l(a.py, a.px); }\nlong double dot(const Point& a, const Point& b) { return a.px * b.px + a.py * b.py; }\nlong double crs(const Point& a, const Point& b) { return a.px * b.py - a.py * b.px; }\nint ccw(const Point& p0, const Point& p1, const Point& p2) {\n\tPoint a = Minus(p1, p0), b = Minus(p2, p0);\n\tif (crs(a, b) > 1e-10) return 1;\n\tif (crs(a, b) < -1e-10) return -1;\n\tif (dot(a, b) < -1e-10) return 2;\n\tif (norm(a) < norm(b)) return -2;\n\treturn 0;\n}\nbool its(const Point& p1, const Point& p2, const Point& p3, const Point& p4) {\n\treturn (ccw(p1, p2, p3) * ccw(p1, p2, p4) < 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) < 0);\n}\nPoint crp(Line a, Line b) {\n\tlong double d1 = abs(crs(Minus(a.p2, a.p1), Minus(b.p2, b.p1)));\n\tlong double d2 = abs(crs(Minus(a.p2, a.p1), Minus(a.p2, b.p1)));\n\treturn Plus(b.p1, Times(Minus(b.p2, b.p1), d2 / d1));\n}\nint n, m; vector<Point>x[10]; Point z[10];\nvector<Point>po;\nvector<Line>L, LNS;\nint main() {\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; i++) {\n\t\tint M; cin >> M;\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tPoint w; cin >> w.px >> w.py; x[i].push_back(w); po.push_back(w);\n\t\t}\n\t\tfor (int j = 0; j < M; j++)LNS.push_back(Line{ x[i][j],x[i][(j + 1) % M] });\n\t}\n\tint R = po.size();\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> z[i].px >> z[i].py;\n\t}\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < R; j++) {\n\t\t\tif (po[j].px == z[i].px && po[j].py == z[i].py)continue;\n\t\t\tL.push_back(Line{ po[j],z[i] });\n\t\t\tL.push_back(Line{ Point{ po[j].px + 1e-4,po[j].py },z[i] });\n\t\t\tL.push_back(Line{ Point{ po[j].px - 1e-4,po[j].py },z[i] });\n\t\t\tL.push_back(Line{ Point{ po[j].px,po[j].py + 1e-4 },z[i] });\n\t\t\tL.push_back(Line{ Point{ po[j].px,po[j].py - 1e-4 },z[i] });\n\t\t}\n\t}\n\tfor (int i = 0; i < po.size(); i++) {\n\t\tfor (int j = i + 1; j < po.size(); j++) {\n\t\t\tif (po[j].px == po[i].px && po[j].py == po[i].py)continue;\n\t\t\tL.push_back(Line{ po[i],po[j] });\n\t\t}\n\t}\n\tfor (int i = 0; i < LNS.size(); i++) {\n\t\tL.push_back(LNS[i]);\n\t}\n\tint maxn = 0;\n\tfor (int i = 0; i < L.size(); i++) {\n\t\tfor (int j = i + 1; j < L.size(); j++) {\n\t\t\tPoint WW = crp(L[i], L[j]);\n\t\t\tif (fabs(WW.px) >= 1e9 || fabs(WW.py) >= 1e9)continue;\n\t\t\tlong double L1 = (L[i].p1.px - L[i].p2.px) / (L[i].p1.py - L[i].p2.py); if (fabs(L1) >= 1e9)L1 = 1e9;\n\t\t\tlong double L2 = (L[j].p1.px - L[j].p2.px) / (L[j].p1.py - L[j].p2.py); if (fabs(L2) >= 1e9)L2 = 1e9;\n\t\t\tif (L1 == L2)continue;\n\t\t\tint cnt = 0;\n\t\t\tfor (int k = 0; k < m; k++) {\n\t\t\t\tif (WW.px == z[k].px && WW.py == z[k].py)continue;\n\t\t\t\tLine LN = Line{ WW,z[k] };\n\t\t\t\tint flag = 1;\n\t\t\t\tfor (int l = 0; l < LNS.size(); l++) {\n\t\t\t\t\tif (ccw(LNS[l].p1, LNS[l].p2, WW) == 0) { flag = 0; break; }\n\t\t\t\t\tif (its(LN.p1, LN.p2, LNS[l].p1, LNS[l].p2) == true) {\n\t\t\t\t\t\tflag = 0; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flag == 1) {\n\t\t\t\t\tcnt += flag;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmaxn = max(maxn, cnt);\n\t\t}\n\t}\n\tcout << maxn << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\ntypedef complex<double> pt;\n\ntypedef vector<P> poly;\nconst double EPS = 1e-7;\n#define x real()\n#define y imag()\n\nint n,m;\nint L[15]; pt p[15][20];\npt h[15];\nvector<pair<pt,pt> >LL;\nbool eq(double a,double b){\n  return (-EPS < a-b && b-a < EPS);\n}\ndouble dot(pt a,pt b){\n\treturn (conj(a)*b).x;\n}\ndouble cross(pt a,pt b){\n\treturn (conj(a)*b).y;\n}\npt crossPoint(pt a,pt b,pt c,pt d){\n\tdouble A = cross(b-a,d-c);\n\tdouble B = cross(b-a,b-c);\n\tif( fabs(A) < EPS && fabs(B) < EPS ) return c;\n\telse if(fabs(A) >= EPS ) return c+B/A*(d-c);\n\telse pt(1e9,1e9);\n}\nint ccw(pt a,pt b,pt c){\n\tb -= a; c -= a;\n\tif(cross(b,c) > EPS) return 1; // counter clockwise\n\tif(cross(b,c) < -EPS) return -1; // clockwise\n\tif(dot(b,c) < -EPS) return 2; //c-a-b\n\tif(norm(b) < norm(c)) return -2; //a-b-c\n\treturn 0; //a-c-b\n}\nbool intersect(pt a,pt b,pt c,pt d){\n\treturn (ccw(a,b,c)*ccw(a,b,d) <= 0 && ccw(c,d,a)*ccw(c,d,b) <= 0);\n}\nbool on_segment(pair<pt,pt> a,pt p){\n  return eq(abs(a.first-a.second)-abs(a.first-p)-abs(a.second-p),0);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&L[i]);\n\t\tfor(int j=0;j<L[i];j++){\n\t\t\tdouble s,t;\n\t\t\tscanf(\"%lf%lf\",&s,&t); p[i][j] = pt(s,t);\n\t\t}\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tdouble s,t; scanf(\"%lf%lf\",&s,&t); h[i] = pt(s,t);\n\t}\n\t//human_vertex path\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<L[i];j++){\n\t\t\tfor(int k=0;k<m;k++){\n\t\t\t\tLL.pb(mp(p[i][j],h[k]));\n\t\t\t}\n\t\t}\n\t}\n\tvector<pt>C;\n\tfor(int i=0;i<LL.size();i++){\n\t\tfor(int j=i+1;j<LL.size();j++){\n\t\t\tpt cand = crossPoint(LL[i].fi,LL[i].sc,LL[j].fi,LL[j].sc);\n\t\t\t//cout << cand.x << \" \" << cand.y << endl;\n\t\t\tif(cand.x > 1e8) continue;\n\t\t\tif(abs(ccw(LL[i].fi,LL[i].sc,cand))%2!=0) continue;\n\t\t\tif(abs(ccw(LL[j].fi,LL[j].sc,cand))%2!=0) continue;//cout << \"K\" << endl;\n\t\t\t//cout << cand.x << \" \" << cand.y << endl;\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tfor(int l=0;l<L[k];l++){\n\t\t\t\t\tif(ccw(p[k][l],p[k][(l+1)%L[k]],cand) != 1){\n\t\t\t\t\t\t//in polygon\n\t\t\t\t\t\tgoto ok;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << cand.x << \" \" << cand.y << endl;\n\t\t\tok:; C.pb(cand); //cout << cand.x << \" \" << cand.y << endl;\n\t\t}\n\t}\n\tint ret = 1;\n\tfor(int i=0;i<C.size();i++){\n\t\tint num = 0;\n\t\tfor(int j=0;j<m;j++){\n\t\t\t//candidate_human path\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tfor(int l=0;l<L[k];l++){\n\t\t\t\t\tif(!intersect(C[i],h[j],p[k][l],p[k][(l+1)%L[k]])){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tpt cr = crossPoint(C[i],h[j],p[k][l],p[k][(l+1)%L[k]]);\n\t\t\t\t\t\tif(abs(p[k][l]-cr) < EPS) continue;\n\t\t\t\t\t\tif(abs(p[k][(l+1)%L[k]]-cr) < EPS) continue;\n\t\t\t\t\t\tif(on_segment(mp(p[k][l],p[k][(l+1)%L[k]]),cr)) continue;\n\t\t\t\t\t}\n\t\t\t\t\tgoto fail;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnum++; fail:;\n\t\t}\n\t\tret = max(ret,num);\n\t}\n\tcout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n \n#define EPS (1e-8)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n \n \nusing namespace std;\n \n \nclass Point{\npublic:\n  double x,y;\n \n  Point(double x = 0,double y = 0): x(x),y(y){}\n \n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n \n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n \n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n \n};\n \nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n \n};\n \ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n \nostream& operator << (ostream& os,const Point& a){ os << \"(\" << a.x << \",\" << a.y << \")\"; }\n \nostream& operator << (ostream& os,const Segment& a){ os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n \ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n \ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n \ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n \ndouble abs(Point a){ return sqrt(norm(a)); }\n \n//rad ????§???????????????¢?????§?????????????????¨\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n \n// ??????????????¢????????????\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n \n// a => prev, b => cur, c=> next\n// prev ?????? cur ????????£??? next ????????????????§????????±???????\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n \n \nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n \n \n \n \nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n \nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n \ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n \ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n \nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n \n    assert(vec[1] == vec[2]); //???????????°??????????????????\n    return vec[1];\n    //return m.p1;\n  }\n  if(abs(A) < EPS){\n    assert(false);\n  }\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n \n \n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r) { return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x); }\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r) { return fabs(cross3p(p,q,r)) < EPS; }\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r){\n  return cross3p(p,q,r) > 0; //can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r){\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n \nbool isConvex(vector<Point> p) {\n  int sz = (int)p.size();\n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft) return false;\n  return true;\n}\n \n \ndouble angle(Point a,Point b,Point c) {\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n \n//????§???¢poly?????????????????????????????????p????????¨??????????????????????????????  \nbool inPolygon(Polygon poly,Point p){\n  if((int)poly.size() == 0)return false;\n  rep(i,(int)poly.size()) if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++) {\n    if( equals(cross(poly[i]-p,poly[(i+1)%poly.size()]-p),0.0) ) continue; // ????????????????????¨angle???nan?????????sum???nan??????????????¬\n    if( cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0 ) sum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n    else                                                 sum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n  }\n  // ?????????????????????????????????????????¨?????????????????§??\\????????????????????? \n  const double eps = 1e-5;\n  return (fabs(sum - 2*M_PI) < eps || fabs(sum + 2*M_PI) < eps);\n}  \n \n \nbool LT(double a,double b) { return !equals(a,b) && a < b; }\nPoint vir;\nbool comp_vir(Point a,Point b) {\n  return LT(abs(vir-a),abs(vir-b));\n}\nbool inPolygon(const Polygon &poly,Segment seg){\n  vector<Point> vp;\n  vp.push_back(seg.p1);\n  vp.push_back(seg.p2);\n  rep(i,(int)poly.size()) {\n    Segment edge = Segment(poly[i],poly[(i+1)%(int)poly.size()]);\n    if( equals(cross(seg.p1-seg.p2,edge.p1-edge.p2),0.0) ) {\n      if( onSegment(seg.p1,seg.p2,edge.p1) ) vp.push_back(edge.p1);\n      if( onSegment(seg.p1,seg.p2,edge.p2) ) vp.push_back(edge.p2);\n    } else {\n      if( intersectSS(seg,edge) ) vp.push_back(crosspoint(seg,edge));\n    }\n  }\n  //cout << \"seg = \" << seg << endl;\n  vir = seg.p1;\n  sort(vp.begin(),vp.end(),comp_vir);\n  vp.erase(unique(vp.begin(),vp.end()),vp.end());\n \n \n  rep(i,(int)vp.size()-1) {\n    Point middle_point = ( vp[i] + vp[i+1] ) / 2.0;\n    //if( !inPolygon(poly,middle_point) ) return false;\n    if( inPolygon(poly,middle_point) )  {\n      //cout << \"cross!! \" << middle_point << endl;\n      return true;\n    }\n  }\n  return false;  \n}\n \n/// <----------\n \n \n#define MAX_N 6\n#define MAX_M 11\nint N,M,L[MAX_N];\nPolygon polies[MAX_N];\nPoint person[MAX_M];\n \nvector<Point> getCandidates() {\n  vector<Point> ret;\n  rep(i,M) ret.push_back(person[i]);\n \n  vector<Line> lines;\n  rep(i,M) {\n    Point he = person[i];\n    rep(j,N) {\n      rep(k,L[j]) {\n\t//if( equals(cross(he.x-polies[j][k].x,he.y-polies[j][k].y),0) ) continue;\n\tlines.push_back(Line(he,polies[j][k]));\n      }\n    }\n  }\n \n  rep(i,(int)lines.size()) REP(j,i+1,(int)lines.size()) {\n    Line l1 = lines[i];\n    Line l2 = lines[j];\n    if( equals(cross(l1.p2-l1.p1,l2.p2-l2.p1),0) ) continue;\n    ret.push_back(crosspoint(l1,l2));\n  }\n \n  return ret;\n}\n \n \n \nvector<Polygon> vpoly;\nbool isVis(Point s, Point t) {\n  Segment seg = Segment(s,t);\n  rep(i,N) {\n    if( inPolygon(vpoly[i],seg) ) {\n      return false;\n    }\n  }\n  return true;\n  /*\n  vector<Point> ps;\n  ps.push_back(s);\n  ps.push_back(t);\n  rep(i,N) {\n    rep(j,L[i]) {\n      if( intersectSS(seg,Segment(polies[i][j],polies[i][(j+1)%L[i]])) ) {\n\tPoint cp = crosspoint(seg,Segment(polies[i][j],polies[i][(j+1)%L[i]]));\n\tps.push_back(cp);\n      }\n    }\n  }\n \n  vir = s;\n  sort(ps.begin(),ps.end(),comp_vir);\n  ps.erase(unique(ps.begin(),ps.end()),ps.end());\n  rep(i,(int)ps.size()-1) {\n    Point mp = ( ps[i] + ps[i+1] ) * 0.5;\n    if( inPolygon() )\n  }\n  */\n  return true;\n}\n \nvoid compute() {\n  vector<Point> cand = getCandidates();\n  int maxi = 1;\n  \n  //cand.clear();\n  //cand.push_back(Point(5,20)); //<<<<<<<\n  \n  sort(cand.begin(),cand.end());\n  cand.erase(unique(cand.begin(),cand.end()),cand.end());\n \n  rep(i,(int)cand.size()) {\n    int tmp = 0;\n    rep(j,M) {\n      //cout << cand[i] <<\" \" << person[j] << \" \" << isVis(cand[i],person[j]) << \" :: \" << endl; \n      if( isVis(cand[i],person[j]) ) {\n\t++tmp;\n      }\n    }\n    //cout << cand[i] << \" : \" << tmp << endl;\n    maxi = max(maxi,tmp);\n  }\n  cout << maxi << endl;\n}\n \nint main() {\n  cin >> N >> M;\n  rep(i,N) {\n    cin >> L[i];\n    polies[i] = vector<Point>(L[i]);\n    rep(j,L[i]) {\n      cin >> polies[i][j].x >> polies[i][j].y;\n    }\n    vpoly.push_back(polies[i]);\n  }\n  rep(i,M) {\n    cin >> person[i].x >> person[i].y;\n  }\n \n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n\nstruct Point{\n\tPoint(double arg_x,double arg_y){\n\t\tx = arg_x;\n\t\ty = arg_y;\n\t}\n\n\tPoint(){\n\t\tx = y = 0.0;\n\t}\n\n\tPoint operator + (Point p){ return Point(x+p.x,y+p.y); }\n\tPoint operator - (Point p){ return Point(x-p.x,y-p.y);}\n\tPoint operator * (double a){ return Point(a*x,a*y); }\n\tPoint operator / (double a){ return Point(x/a,y/a); }\n\n\tdouble abs(){ return sqrt(norm()); }\n\tdouble norm(){ return x*x + y*y; }\n\n\tbool operator<(const Point &p) const{\n\t\treturn x != p.x? x < p.x: y < p.y;\n\t}\n\n\tbool operator == (const Point &p) const{\n\t\treturn fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n\t}\n\n\tdouble x,y;\n};\n\nstruct Line{\npublic:\n\tPoint p[2];\n\tLine(Point p1,Point p2){\n\t\tp[0] = p1;\n\t\tp[1] = p2;\n\t}\n\tLine(){\n\n\t}\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nint num_polygon,num_human;\nvector<Point> HUMAN,CANDIDATE;\nvector<Line> LINE;\nvector<Polygon> POLYGON;\n\n//交点を求める関数\nPoint calc_Cross_Point(double x1,double x2,double x3,double x4,double y1,double y2,double y3,double y4){\n\tPoint ret;\n\tret.x = ((x2-x1)*(y3*(x4-x3)+x3*(y3-y4))-(x4-x3)*(y1*(x2-x1)+x1*(y1-y2)))/((y2-y1)*(x4-x3)-(y4-y3)*(x2-x1));\n\tif(x1 != x2){\n\t\tret.y = ((y2-y1)*ret.x+y1*(x2-x1)+x1*(y1-y2))/(x2-x1);\n\t}else{\n\t\tret.y = ((y4-y3)*ret.x+y3*(x4-x3)+x3*(y3-y4))/(x4-x3);\n\t}\n\treturn ret;\n}\n\n//インタフェース関数\nPoint calc_Cross_Point(Point a,Point b,Point c,Point d){\n\treturn calc_Cross_Point(a.x,b.x,c.x,d.x,a.y,b.y,c.y,d.y);\n}\n\nint func(double x1,double y1,double x2, double y2, double xp, double yp){\n\tdouble naiseki,norm1,norm2,gaiseki;\n\tnorm1 = sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));\n\tnorm2 = sqrt((xp-x1)*(xp-x1)+(yp-y1)*(yp-y1));\n\tnaiseki = (xp-x1)*(x2-x1)+(yp-y1)*(y2-y1);\n\tgaiseki = (x2-x1)*(yp-y1)-(xp-x1)*(y2-y1);\n\tif(gaiseki > EPS){\n\t\treturn 1;\n\t}else if(gaiseki < -EPS){\n\t\treturn -1;\n\t}\n\tif(naiseki < -EPS){\n\t\treturn 2;\n\t}\n\n\tif(norm1 < norm2){\n\t\treturn -2;\n\t}\n\treturn 0;\n}\n\nbool is_Cross(Line a,Line b){\n\n\tif(func(a.p[0].x,a.p[0].y,a.p[1].x,a.p[1].y,b.p[0].x,b.p[0].y)*\n\t\t\tfunc(a.p[0].x,a.p[0].y,a.p[1].x,a.p[1].y,b.p[1].x,b.p[1].y) <= 0 &&\n\t\t\tfunc(b.p[0].x,b.p[0].y,b.p[1].x,b.p[1].y,a.p[0].x,a.p[0].y)*\n\t\t\tfunc(b.p[0].x,b.p[0].y,b.p[1].x,b.p[1].y,a.p[1].x,a.p[1].y) <= 0){\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n\nint main(){\n\n\tscanf(\"%d %d\",&num_polygon,&num_human);\n\n\tint num;\n\n\tfor(int i = 0; i < num_polygon; i++){\n\n\t\tPolygon polygon;\n\n\t\tscanf(\"%d\",&num);\n\n\t\tfor(int k = 0; k < num; k++){\n\n\t\t\tPoint tmp_point;\n\n\t\t\tscanf(\"%lf %lf\",&tmp_point.x,&tmp_point.y);\n\t\t\tpolygon.push_back(tmp_point);\n\t\t}\n\t\tPOLYGON.push_back(polygon);\n\t}\n\n\tfor(int i = 0; i < num_human; i++){\n\n\t\tPoint tmp_point;\n\n\t\tscanf(\"%lf %lf\",&tmp_point.x,&tmp_point.y);\n\n\t\tHUMAN.push_back(tmp_point);\n\t}\n\n\t//各有権者と、ポリゴンの頂点を結ぶ線分を求める\n\tfor(int i = 0; i < num_human; i++){ //10\n\t\tfor(int k = 0; k < num_polygon; k++){ //5\n\t\t\tfor(int a = 0; a < POLYGON[k].size(); a++){ //15\n\n\t\t\t\tLine tmp_line;\n\n\t\t\t\ttmp_line.p[0] = HUMAN[i];\n\t\t\t\ttmp_line.p[1] = Point(HUMAN[i].x+100*(POLYGON[k][a].x-HUMAN[i].x),\n\t\t\t\t\t\t\t\tHUMAN[i].y+100*(POLYGON[k][a].y-HUMAN[i].y)); //線分をポリゴン方向に伸ばす\n\n\t\t\t\tLINE.push_back(tmp_line);\n\t\t\t}\n\t\t}\n\t}\n\n\n\t//候補となる点を列挙する\n\tfor(int i = 0; i < LINE.size()-1; i++){\n\t\tfor(int k = i+1; k < LINE.size(); k++){\n\t\t\tif(!is_Cross(LINE[i],LINE[k]))continue;\n\n\t\t\tCANDIDATE.push_back(calc_Cross_Point(LINE[i].p[0],LINE[i].p[1],LINE[k].p[0],LINE[k].p[1]));\n\t\t}\n\t}\n\n\t//候補点にX氏がいるとして、最大値を求める\n\tint ans = 0,tmp_num;\n\n\tfor(int i = 0; i < CANDIDATE.size(); i++){\n\n\t\ttmp_num = 0;\n\n\t\t//X氏とその人の間に、ポリゴンがない有権者の数を数える\n\t\tfor(int k = 0; k < num_human; k++){\n\n\t\t\tbool FLG = true;\n\n\t\t\tLine tmp_line;\n\t\t\ttmp_line.p[0] = HUMAN[k];\n\t\t\ttmp_line.p[1] = CANDIDATE[i]; //★伸ばさない★\n\n\t\t\tfor(int a = 0; a < num_polygon; a++){\n\t\t\t\tfor(int b = 0; b < POLYGON[a].size(); b++){\n\n\t\t\t\t\tLine adj_line;\n\n\t\t\t\t\tadj_line.p[0] = POLYGON[a][b];\n\t\t\t\t\tadj_line.p[1] = POLYGON[a][(b+1)%POLYGON[a].size()];\n\n\t\t\t\t\tif(!is_Cross(tmp_line,adj_line))continue;\n\n\t\t\t\t\tPoint cross_point = calc_Cross_Point(tmp_line.p[0],tmp_line.p[1],adj_line.p[0],adj_line.p[1]);\n\n\t\t\t\t\tif(cross_point == adj_line.p[0] || cross_point == adj_line.p[1]){\n\n\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t}else{\n\n\t\t\t\t\t\tif(cross_point == CANDIDATE[i])continue;\n\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tif(!FLG)break;\n\t\t\t}\n\n\t\t\tif(FLG){\n\t\t\t\ttmp_num++;\n\t\t\t}\n\t\t}\n\n\t\tans = max(ans,tmp_num);\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; ++i)\nusing namespace std;\n\nusing R = long double;\nconst R EPS = 1e-10;\nint sgn(const R &x) {return (x > EPS) - (x < -EPS);}\nusing P = complex<R>;\nconst P O = P(0, 0);\nusing L = struct {P s, t;};\nusing VP = vector<P>;\n\nauto & operator >>(istream& is, P &p) {R x, y; is >> x >> y; p =P(x,y); return is;}\n\ninline R dot(P o, P a, P b) {return real(conj(a - o) * (b - o));}\ninline R det(P o, P a, P b) {return imag(conj(a - o) * (b - o));}\ninline int sdot(P o, P a, P b) {return sgn(dot(o, a, b));}\ninline int sdet(P o, P a, P b) {return sgn(det(o, a, b));}\n\nbool iss(L a, L b) {\n\tint sa = sdet(a.s, a.t, b.s) * sdet(a.s, a.t, b.t);\n\tint sb = sdet(b.s, b.t, a.s) * sdet(b.s, b.t, a.t);\n\treturn max(sa, sb) < 0;\n}\n\nP cross(L a, L b) {\n\tR u = det(a.s, b.s, b.t) / det(O, a.t - a.s, b.t - b.s);\n\treturn (1 - u) * a.s + u * a.t;\n}\n\nbool in_polygon(const VP &pol, const P &p) {\n\tconst int n = pol.size();\n\tint res = 0;\n\trep(i, n) {\n\t\tP a = pol[i], b = pol[(i + 1) % n];\n\t\tbool f = sgn(imag(p - a)) >= 0, s = sgn(imag(p - b)) < 0;\n\t\tif (sgn(imag(b - a))*sdet(a, b, p) == 1 and f == s) res += 2 * f - 1;\n\t}\n\treturn res > 0;\n}\n\nint main(void) {\n\tint n, m;\n\tcin >> n >> m;\n\tVP pol[20];\n\n\trep(i, n) {\n\t\tint l;\n\t\tcin >> l;\n\t\tpol[i] = VP(l);\n\t\trep(j, l) cin >> pol[i][j];\n\t}\n\n\tVP cand(m);\n\trep(i, m) cin >> cand[i];\n\n\tvector<L> lines;\n\trep(i, m) rep(j, n) for (auto &p : pol[j]) lines.push_back(L{cand[i], p});\n\n\tconst int k = lines.size();\n\n\tvector<P> points;\n\trep(j, k)rep(i, k) points.push_back(cross(lines[i], lines[j]));\n\n\tvector<L> obj;\n\trep(i, n) {\n\t\tconst int l = pol[i].size();\n\t\trep(j, l) obj.push_back(L{pol[i][j], pol[i][(j + 1) % l]});\n\t}\n\n\tint ans = 0;\n\tfor (auto &tar : points) {\n\t\trep(i, n) if (in_polygon(pol[i], tar)) continue;\n\n\t\tint cur = 0;\n\n\t\trep(i, m) {\n\t\t\tL seg = L{tar, cand[i]};\n\t\t\tbool ok = true;\n\t\t\tfor (auto &seg2 : obj) if (iss(seg, seg2)) ok = false;\n\t\t\tif (ok) cur++;\n\t\t}\n\n\t\tans = max(ans, cur);\n\t}\n\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1<<29\n#define linf 1e18\n#define eps (1e-6)\n#define mod 1000000007\n#define pi M_PI\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nbool isParallel(Segment s,Segment t){\n  return equals(cross(s.p1-s.p2,t.p1-t.p2),0.0);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return 1;\n  if(cross(a,b)<-eps)return -1;\n  if(dot(a,b)<-eps)return 2;\n  if(a.norm()<b.norm())return -2;\n  return 0;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 &&\n          ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nPoint getCrossPointLL(Line a,Line b){\n  double A=cross(a.p2-a.p1,b.p2-b.p1);\n  double B=cross(a.p2-a.p1,a.p2-b.p1);\n  if(abs(A)<eps || abs(B)<eps)return b.p1;\n  return b.p1+(b.p2-b.p1)*(B/A);\n}\n\nint n,m,l;\nvector<Polygon> polygons;\nvector<Point> vp;\nvector<Segment> vs[20];\n\nvector<Line> getS(int a,int b){\n  Point p=vp[a];\n  Polygon P=polygons[b];\n  vector<Line> res;\n  FOR(i,0,P.size()){\n    int count=0;\n    FOR(j,0,P.size())count+=ccw(p,P[i],P[j]);\n    if(abs(count)==P.size()-1)res.pb(Line(p,P[i]));\n  }\n  return res;\n}\n\nvector<Point> getP(int a,int b){\n  vector<Point> res;\n  FOR(i,0,vs[a].size()){\n    FOR(j,0,vs[b].size()){\n      if(isParallel(vs[a][i],vs[b][j]))continue;\n      res.pb(getCrossPointLL(vs[a][i],vs[b][j]));\n    }\n  }\n  return res;\n}\n\nint check(Segment s){\n  FOR(i,0,n){\n    Polygon P=polygons[i];\n    int size=P.size();\n    FOR(j,0,size){\n      Point a=P[j],b=P[(j+1)%size];\n      if(ccw(s.p1,s.p2,a)==0 || ccw(s.p1,s.p2,b)==0)continue;\n      if(ccw(a,b,s.p1)==0 || ccw(a,b,s.p2)==0)continue;\n      if(intersect(s,Segment(a,b)))return 0;\n    }\n  }\n  return 1;\n}\n\nint solve(){\n  FOR(i,0,m){\n    FOR(j,0,n){\n      vector<Segment> tmp=getS(i,j);\n      FOR(k,0,tmp.size())vs[i].pb(tmp[k]);\n    }\n  }\n  vector<Point> ev;\n  FOR(i,0,m){\n    FOR(j,0,m){\n      vector<Point> res=getP(i,j);\n      FOR(k,0,res.size())ev.push_back(res[k]);\n    }\n  }\n  int ans=1;\n  FOR(i,0,ev.size()){\n    int count=0;\n    FOR(j,0,m)count+=check(Segment(ev[i],vp[j]));\n    ans=max(ans,count);\n  }\n  return ans;\n}\n\nint main()\n{\n  cin>>n>>m;\n  FOR(i,0,n){\n    cin>>l;\n    Polygon p;\n    FOR(j,0,l){\n      int x,y;\n      cin>>x>>y;\n      p.pb(Point(x,y));\n    }\n    polygons.pb(p);\n  }\n  FOR(i,0,m){\n    int x,y;\n    cin>>x>>y;\n    vp.pb(Point(x,y));\n  }\n  cout<<solve()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1<<29\n#define linf 1e18\n#define eps (1e-6)\n#define mod 1000000007\n#define pi M_PI\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nbool isParallel(Segment s,Segment t){\n  return equals(cross(s.p1-s.p2,t.p1-t.p2),0.0);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return 1;\n  if(cross(a,b)<-eps)return -1;\n  if(dot(a,b)<-eps)return 2;\n  if(a.norm()<b.norm())return -2;\n  return 0;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 &&\n          ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nPoint getCrossPointLL(Line a,Line b){\n  double A=cross(a.p2-a.p1,b.p2-b.p1);\n  double B=cross(a.p2-a.p1,a.p2-b.p1);\n  if(abs(A)<eps || abs(B)<eps)return b.p1;\n  return b.p1+(b.p2-b.p1)*(B/A);\n}\n\nint n,m,l;\nvector<Polygon> polygons;\nvector<Point> vp;\nvector<Segment> vs[20];\n\nvector<Line> getS(int a,int b){\n  Point p=vp[a];\n  Polygon P=polygons[b];\n  vector<Line> res;\n  FOR(i,0,P.size()){\n    int count=0;\n    FOR(j,0,P.size())count+=ccw(p,P[i],P[j]);\n    if(abs(count)==P.size()-1)res.pb(Line(p,P[i]));\n  }\n  return res;\n}\n\nvector<Point> getP(int a,int b){\n  vector<Point> res;\n  FOR(i,0,vs[a].size()){\n    FOR(j,0,vs[b].size()){\n      if(isParallel(vs[a][i],vs[b][j]))continue;\n      res.pb(getCrossPointLL(vs[a][i],vs[b][j]));\n    }\n  }\n  return res;\n}\n\nint check(Segment s){\n  FOR(i,0,n){\n    Polygon P=polygons[i];\n    int size=P.size();\n    FOR(j,0,size){\n      Point a=P[j],b=P[(j+1)%size];\n      if(ccw(s.p1,s.p2,a)==0 || ccw(s.p1,s.p2,b)==0)continue;\n      if(ccw(a,b,s.p1)==0 || ccw(a,b,s.p2)==0)continue;\n      if(intersect(s,Segment(a,b)))return 0;\n    }\n  }\n  return 1;\n}\n\nint solve(){\n  FOR(i,0,m){\n    FOR(j,0,n){\n      vector<Segment> tmp=getS(i,j);\n      FOR(k,0,tmp.size())vs[i].pb(tmp[k]);\n    }\n  }\n  vector<Point> ev;\n  FOR(i,0,m){\n    FOR(j,0,m){\n      vector<Point> res=getP(i,j);\n      FOR(k,0,res.size())ev.push_back(res[k]);\n    }\n  }\n  int ans=1;\n  FOR(i,0,ev.size()){\n    int count=0;\n    FOR(j,0,m)count+=check(Segment(ev[i],vp[j]));\n    ans=max(ans,count);\n  }\n  return ans;\n}\n\nint main()\n{\n  cin>>n>>m;\n  FOR(i,0,n){\n    cin>>l;\n    Polygon p;\n    FOR(j,0,l){\n      int x,y;\n      cin>>x>>y;\n      p.pb(Point(x,y));\n    }\n    polygons.pb(p);\n  }\n  FOR(i,0,m){\n    int x,y;\n    cin>>x>>y;\n    vp.pb(Point(x,y));\n  }\n  cout<<solve()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; ++i)\nusing namespace std;\n\nusing R = long double;\nconst R EPS = 1e-10;\nint sgn(const R &x) {return (x > EPS) - (x < -EPS);}\nusing P = complex<R>;\nconst P O = P(0, 0);\nusing L = struct {P s, t;};\nusing VP = vector<P>;\n\nauto & operator >>(istream& is, P &p) {R x, y; is >> x >> y; p =P(x,y); return is;}\n\ninline R dot(P o, P a, P b) {return real(conj(a - o) * (b - o));}\ninline R det(P o, P a, P b) {return imag(conj(a - o) * (b - o));}\ninline int sdot(P o, P a, P b) {return sgn(dot(o, a, b));}\ninline int sdet(P o, P a, P b) {return sgn(det(o, a, b));}\n\nbool parallel(L a,L b){return sdet(O,a.t-a.s,b.t-b.s)==0;}\n\nbool iss(L a, L b) {\n\tint sa = sdet(a.s, a.t, b.s) * sdet(a.s, a.t, b.t);\n\tint sb = sdet(b.s, b.t, a.s) * sdet(b.s, b.t, a.t);\n\treturn max(sa, sb) < 0;\n}\n\nP cross(L a, L b) {\n\tR u = det(a.s, b.s, b.t) / det(O, a.t - a.s, b.t - b.s);\n\treturn (1 - u) * a.s + u * a.t;\n}\n\nbool in_polygon(const VP &pol, const P &p) {\n\tconst int n = pol.size();\n\tint res = 0;\n\trep(i, n) {\n\t\tP a = pol[i], b = pol[(i + 1) % n];\n\t\tbool f = sgn(imag(p - a)) >= 0, s = sgn(imag(p - b)) < 0;\n\t\tif (sgn(imag(b - a))*sdet(a, b, p) == 1 and f == s) res += 2 * f - 1;\n\t}\n\treturn res > 0;\n}\n\nint main(void) {\n\tint n, m;\n\tcin >> n >> m;\n\tVP pol[20];\n\n\trep(i, n) {\n\t\tint l;\n\t\tcin >> l;\n\t\tpol[i] = VP(l);\n\t\trep(j, l) cin >> pol[i][j];\n\t}\n\n\tVP cand(m);\n\trep(i, m) cin >> cand[i];\n\n\tvector<L> lines;\n\trep(i, m) rep(j, n) for (auto &p : pol[j]) lines.push_back(L{cand[i], p});\n\n\tconst int k = lines.size();\n\n\tvector<P> points;\n\trep(j, k)rep(i, k) if(!parallel(lines[i],lines[j])) points.push_back(cross(lines[i], lines[j]));\n\n\tvector<L> obj;\n\trep(i, n) {\n\t\tconst int l = pol[i].size();\n\t\trep(j, l) obj.push_back(L{pol[i][j], pol[i][(j + 1) % l]});\n\t}\n\n\tint ans = 0;\n\tfor (auto &tar : points) {\n\t\trep(i, n) if (in_polygon(pol[i], tar)) continue;\n\n\t\tint cur = 0;\n\n\t\trep(i, m) {\n\t\t\tL seg = L{tar, cand[i]};\n\t\t\tbool ok = true;\n\t\t\tfor (auto &seg2 : obj) if (iss(seg, seg2)) ok = false;\n\t\t\tif (ok) cur++;\n\t\t}\n\n\t\tans = max(ans, cur);\n\t}\n\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \nusing namespace std;\n \nconst double EPS = 1e-8, PI = acos(-1);\n \ninline bool eq(double a, double b)\n{\n  return abs(b - a) < EPS;\n}\n \n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\nenum { OUT, ON, IN };\nnamespace Geometory\n{\n  struct Point\n  {\n    double x, y;\n \n    Point()\n    {\n    };\n \n    Point(double x, double y) : x(x), y(y)\n    {\n    };\n \n    Point operator+(const Point& b) const\n    {\n      return Point(x + b.x, y + b.y);\n    }\n \n    Point operator-(const Point& b) const\n    {\n      return Point(x - b.x, y - b.y);\n    }\n \n    Point operator*(const double b) const\n    {\n      return Point(x * b, y * b);\n    }\n \n    Point operator*(const Point& b) const\n    {\n      return Point(x * b.x - y * b.y, x * b.y + y * b.x);\n    }\n \n    Point operator/(const double b) const\n    {\n      return Point(x / b, y / b);\n    }\n \n    bool operator<(const Point& b) const\n    {\n      return x != b.x ? x < b.x : y < b.y;\n    }\n \n    bool operator==(const Point& b) const\n    {\n      return eq(x, b.x) && eq(y, b.y);\n    }\n \n    double norm()\n    {\n      return x * x + y * y;\n    }\n \n    double arg()\n    {\n      return atan2(x, y);\n    }\n \n    double abs()\n    {\n      return sqrt(norm());\n    }\n \n    Point rotate(double theta)\n    {\n      return Point(cos(theta) * x - sin(theta) * y, sin(theta) * x + cos(theta) * y);\n    }\n \n    Point rotate90()\n    {\n      return Point(-y, x);\n    }\n \n    friend ostream& operator<<(ostream& os, Point& p)\n    {\n      return os << \"(\" << p.x << \",\" << p.y << \")\";\n    }\n \n    friend istream& operator>>(istream& is, Point& a)\n    {\n      return is >> a.x >> a.y;\n    }\n  };\n \n  struct Line\n  {\n    Point a, b;\n \n    Line()\n    {\n    };\n \n    Line(Point a, Point b) : a(a), b(b)\n    {\n    };\n \n    friend ostream& operator<<(ostream& os, Line& p)\n    {\n      return os << \"(\" << p.a.x << \",\" << p.a.y << \") to (\" << p.b.x << \",\" << p.b.y << \")\";\n    }\n \n    friend istream& operator>>(istream& is, Line& a)\n    {\n      return is >> a.a.x >> a.a.y >> a.b.x >> a.b.y;\n    }\n  };\n \n  struct Segment\n  {\n    Point a, b;\n \n    Segment()\n    {\n    };\n \n    Segment(Point a, Point b) : a(a), b(b)\n    {\n    };\n \n    friend ostream& operator<<(ostream& os, Segment& p)\n    {\n      return os << \"(\" << p.a.x << \",\" << p.a.y << \") to (\" << p.b.x << \",\" << p.b.y << \")\";\n    }\n \n    friend istream& operator>>(istream& is, Segment& a)\n    {\n      return is >> a.a.x >> a.a.y >> a.b.x >> a.b.y;\n    }\n  };\n \n  typedef vector< Point > Polygon;\n  typedef vector< Segment > Segments;\n  typedef vector< Line > Lines;\n  typedef pair< Point, Point > PointPoint;\n \n  double cross(const Point& a, const Point& b)\n  {\n    return a.x * b.y - a.y * b.x;\n  }\n \n  double dot(const Point& a, const Point& b)\n  {\n    return a.x * b.x + a.y * b.y;\n  }\n \n  int ccw(const Point& a, Point b, Point c)\n  {\n    b = b - a, c = c - a;\n    if(cross(b, c) > EPS) return +1;  // a ??? b ???§ ????????¨??????????????????? c\n    if(cross(b, c) < -EPS) return -1; // a ??? b ???§ ?????¨??????????????????? c\n    if(dot(b, c) < 0) return +2;  // c -- a -- b???§??????´??????\n    if(b.norm() < c.norm()) return -2; // a -- b -- c???§??????´??????\n    return 0;  // a -- c -- b???§??????´??????\n  }\n \n  Point Projection(const Line& l, const Point& p)\n  {\n    double t = dot(p - l.a, l.a - l.b) / (l.a - l.b).norm();\n    return l.a + (l.a - l.b) * t;\n  }\n \n  Point Projection(const Segment& l, const Point& p)\n  {\n    double t = dot(p - l.a, l.a - l.b) / (l.a - l.b).norm();\n    return l.a + (l.a - l.b) * t;\n  }\n \n  Point Reflection(const Line& l, const Point& p)\n  {\n    return p + (Projection(l, p) - p) * 2.0;\n  }\n \n  double Distance(const Line& l, const Point& p)\n  { //OK\n    return (p - Projection(l, p)).abs();\n  }\n \n  bool Intersect(const Line& l, const Line& m)\n  {\n    return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n  }\n \n  bool Intersect(const Line& l, const Segment& s)\n  {\n    return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n  }\n \n  bool Intersect(const Line& l, const Point& p)\n  {\n    return abs(ccw(l.a, l.b, p)) != -1;\n  }\n \n  bool Intersect(const Segment& s, const Segment& t)\n  {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n  }\n \n  bool Intersect(const Segment& s, const Point& p)\n  {\n    return ccw(s.a, s.b, p) == 0;\n  }\n \n  Point Crosspoint(const Segment& l, const Segment& m)\n  { //OK\n    double A = cross(l.b - l.a, m.b - m.a);\n    double B = cross(l.b - l.a, l.b - m.a);\n    if(abs(A) < EPS && abs(B) < EPS) return m.a; // same line\n    return m.a + (m.b - m.a) * B / A;\n  }\n \n  Point Crosspoint(const Line& l, const Line& m)\n  { //OK\n    double A = cross(l.b - l.a, m.b - m.a);\n    double B = cross(l.b - l.a, l.b - m.a);\n    if(abs(A) < EPS && abs(B) < EPS) return m.a;\n    return m.a + (m.b - m.a) * B / A;\n  }\n};\n \nint main()\n{\n  int N, M;\n \n  cin >> N >> M;\n \n  vector< Geometory::Polygon > polygons(N);\n  for(int i = 0; i < N; i++) {\n    int L;\n    cin >> L;\n    polygons[i].resize(L);\n    for(int j = 0; j < L; j++) {\n      cin >> polygons[i][j];\n    }\n  }\n \n  vector< Geometory::Point > points(M);\n  for(int i = 0; i < M; i++) {\n    cin >> points[i];\n  }\n \n  vector< Geometory::Line > lines;\n  for(int i = 0; i < M; ++i) {\n    for(int j = 0; j < N; ++j) {\n      for(int l = 0; l < polygons[j].size(); ++l) {\n        lines.emplace_back(Geometory::Line(points[i], polygons[j][l]));\n      }\n    }\n  }\n \n  int ret = 1;\n  for(int i = 0; i < lines.size(); ++i) {\n    for(int j = 0; j < i; ++j) {\n      if(Geometory::Intersect(lines[i], lines[j])) {\n        auto pp = Geometory::Crosspoint(lines[i], lines[j]);\n        int cost = 0;\n        for(int m = 0; m < M; m++) {\n          auto seg = Geometory::Segment(pp, points[m]);\n          bool iscross = false;\n          for(int n = 0; n < N; n++) {\n            for(int o = 0; o < polygons[n].size(); o++) {\n              if(Geometory::Intersect(Geometory::Segment(curr(polygons[n], o), next(polygons[n], o)), seg)) {\n                auto qq = Geometory::Crosspoint(Geometory::Segment(curr(polygons[n], o), next(polygons[n], o)), seg);\n                if(curr(polygons[n], o) == qq) continue;\n                if(next(polygons[n], o) == qq) continue;\n                if(seg.a == qq || seg.b == qq) continue;\n                iscross = true;\n              }\n            }\n          }\n          cost += iscross ^ 1;\n        }\n        ret = max(ret, cost);\n      }\n    }\n  }\n \n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\n  \ndouble dot(P a,P b){\n  return real(b*conj(a));\n}\n  \ndouble cross(P a,P b){\n  return imag(b*conj(a));\n}\n  \ndouble eps = 1e-8;\n  \nP crossPoint(L l,L m){\n  double A = cross(l.second-l.first,m.second-m.first);\n  double B = cross(l.second-l.first,l.second-m.first);\n  if( fabs(A) < eps && fabs(B) < eps ) return m.first;\n  else if(fabs(A) >= eps ) return m.first+B/A*(m.second-m.first);\n  else P(0,0);\n}\n  \nbool eq(double a,double b){\n  return (-eps<a-b&&a-b<eps);\n}\n  \nbool eq(P a,P b){\n  return eq( abs(b-a) , 0 );\n}\n  \nbool onSegment(L a,P p){\n  return eq( abs(a.first-a.second) , abs(a.first-p)+abs(a.second-p) );\n}\n  \n  \nbool isParallel(L a,L b){\n  if( abs(cross(a.first-a.second,b.first-b.second)) < eps ) return true;\n  return false;\n}\n  \nint n,m;\nvector<P> G[100];\nvector<P> t;\nvector<L> u;\n  \nint check(P a,bool debug=false){\n  \n  \n  \n  int cnt=0;\n  for(int i=0;i<m;i++){\n    L v=L(a,t[i]);\n    bool flg=true;\n    for(int j=0;j<n;j++){\n      int size=G[j].size();\n      for(int k=0;k<size;k++){\n        L w=L(G[j][k],G[j][(k+1)%size]);\n        if(isParallel(v,w))continue;\n        P p=crossPoint(v,w);\n  \n        if(eq(w.first,p))continue;\n        if(eq(w.second,p))continue;\n        if(eq(v.first,p))continue;\n        if(eq(v.second,p))continue;\n        if(!onSegment(w,p))continue;\n     \n        if(onSegment(v,p)){\n          flg=false;\n        }\n      }\n    }\n    if(flg)cnt++;\n  }\n  return cnt;\n}\n  \nint solve(){\n  \n  if(n==0)return m;\n  int res=0;\n  for(int i=0;i<(int)u.size();i++){\n    for(int j=0;j<i;j++){\n      L a=u[i];\n      L b=u[j];\n  \n      P target=crossPoint(a,b);\n  \n      if( isParallel(a,b) ) continue;\n      res=max(res,check(target));\n    }\n  }\n  return res;\n}\n  \nint main(){\n  cin>>n>>m;\n  for(int i=0;i<n;i++){\n    double x,y;\n    int L;\n    cin>>L;\n    G[i].resize(L);\n    for(int j=0;j<L;j++){\n      cin>>x>>y;\n      G[i][j]=P(x,y);\n    }\n  }\n  for(int i=0;i<m;i++){\n    double x,y;\n    cin>>x>>y;\n    t.push_back(P(x,y));\n  }\n  for(int i=0;i<m;i++){\n    for(int j=0;j<n;j++){\n      for(int k=0;k<(int)G[j].size();k++){\n        u.push_back(L(t[i],G[j][k]));\n      }\n    }\n  }\n  \n  cout<<solve()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ndouble eps = 0.00001;\nstruct P {\n  double x, y;\n};\nstruct L {\n  P p1, p2;\n  double x() { return p2.x - p1.x; }\n  double y() { return p2.y - p1.y; }\n};\ndouble prod(L l1, L l2) { return l1.x() * l2.y() - l1.y() * l2.x(); }\npair<double, double> interP(L l1, L l2) {\n  double a = l1.x();\n  double b = -l2.x();\n  double c = l1.y();\n  double d = -l2.y();\n  double inv = 1. / (a * d - c * b);\n  double e1 = -l1.p1.x + l2.p1.x;\n  double e2 = -l1.p1.y + l2.p1.y;\n  return make_pair((d * e1 - b * e2) * inv, (-c * e1 + a * e2) * inv);\n}\nbool intersect(L l1, L l2) {\n  if (prod(l1, l2) == 0) {\n    return false;\n  }\n  auto p = interP(l1, l2);\n  return eps < p.first && p.first < 1 - eps && eps < p.second &&\n         p.second < 1 - eps;\n}\nint main() {\n\n  int n, m;\n  cin >> n >> m;\n  vector<vector<P>> p(n);\n  for (int i = 0; i < n; i++) {\n    int l;\n    cin >> l;\n    for (int j = 0; j < l; j++) {\n      double x, y;\n      cin >> x >> y;\n      p[i].push_back(P{x, y});\n    }\n  }\n  vector<P> hum(m);\n  for (int i = 0; i < m; i++) {\n    cin >> hum[i].x >> hum[i].y;\n  }\n  vector<L> line;\n  for (int i = 0; i < m; i++) {\n    for (auto &poly : p) {\n      for (int j = 0; j < poly.size(); j++) {\n        double x = hum[i].x + (poly[j].x - hum[i].x) * 10000;\n        double y = hum[i].y + (poly[j].y - hum[i].y) * 10000;\n        line.push_back(L{hum[i], P{x, y}});\n      }\n    }\n  }\n  vector<P> ps;\n  for (int i = 0; i < line.size(); i++)\n    for (int j = i + 1; j < line.size(); j++) {\n      if (intersect(line[i], line[j])) {\n        auto rs = interP(line[i], line[j]);\n        if (rs.first < 0 || rs.second < 0)\n          continue;\n        ps.push_back(P{line[i].p1.x + line[i].x() * rs.first,\n                       line[i].p1.y + line[i].y() * rs.second});\n      }\n    }\n\n  if (n == 0) {\n    cout << m << endl;\n    return 0;\n  }\n  if (m == 1) {\n    cout << 1 << endl;\n    return 0;\n  }\n\n  int ans = 0;\n  for (int i = 0; i < ps.size(); i++) {\n    int score = m;\n    for (int j = 0; j < m; j++) {\n      L l1{ps[i], hum[j]};\n      bool ng = false;\n\n      for (auto &poly : p) {\n        for (int k = 0; k < poly.size(); k++) {\n          P p1 = poly[k];\n          P p2 = poly[(k + 1) % poly.size()];\n          L l2{p1, p2};\n          if (intersect(l1, l2)) {\n            ng = true;\n          }\n        }\n      }\n\n      if (ng) {\n        score--;\n      }\n    }\n    ans = max(ans, score);\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef complex<double> C;\ntypedef pair<int,int>P;\n\nconst double PI = 4*atan(1.0);\n\nnamespace std\n{\n    bool operator < (const C a, const C b) {\n        return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n    }\n}\n\nstruct L : public vector<C>\n{\n    L(const C a, const C b) {\n        push_back(a); push_back(b);\n    }\n};\n\nbool eq(double a,double b)\n{\n  return (-EPS<a-b&&a-b<EPS);\n}\n\nbool eq(C c1,C c2)\n{\n  return (eq(c1.real(),c2.real()) && eq(c1.imag(),c2.imag()));\n}\n\n//?????¶??????sqrt\ndouble Sqrt(double x)\n{\n    if(x<0) return 0;\n    else    return sqrt(x);\n}\n\n//??£??????\nC normalize(C c)\n{\n    return c / abs(c);\n}\n\n//?§????(rad)\ndouble getarg(C a,C b){\n    return arg(b*conj(a));\n}\n\n//??????\ndouble cross(const C a, const C b)\n{\n    return imag(conj(a)*b);\n}\n//??????\ndouble dot(const C a, const C b)\n{\n    return real(conj(a)*b);\n}\n\nint ccw(C a, C b, C c)\n{\n    b -= a; c -= a;\n    if(cross(b, c) > 0)   return +1;       // counter clockwise\n    if(cross(b, c) < 0)   return -1;       // clockwise\n    if(dot(b, c) < 0)     return +2;       // c--a--b on line\n    if(norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;\n}\n//??´???????????????????????????(????????´??????True)\nbool intersectLL(const L &l, const L &m)\n{\n    return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;\n}\n//??´?????¨?????????????????????(????????±??????????????¨??????)\nbool intersectLS(const L &l, const L &s)\n{\n    return cross(l[1]-l[0], s[0]-l[0]) * cross(l[1]-l[0], s[1]-l[0]) < EPS;\n}\n//??´?????¨????????????(??±???)??????\nbool intersectLP(const L &l, const C p)\n{\n    return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\n//??????????????????????????????(????????±??????????????¨??????)\nbool intersectSS(const L &s, const L &t)\n{\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) < 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) < 0;\n}\n//????????¨????????????(??±???)??????\nbool intersectSP(const L &s, const C p)\n{\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;\n}\n//???p?????´???l???????°???±\nC projection(const L &l, const C p)\n{\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\n//???p?????´???l????????¨??????????§°?§????\nC reflection(const L &l, const C p)\n{\n    return p + (projection(l, p) - p)*2.0;\n}\n//?????¨??´???????????¢\ndouble distanceLP(const L &l, const C p)\n{\n    return abs(p - projection(l, p));\n}\n//??´?????¨??´???????????¢\ndouble distanceLL(const L &l, const L &m)\n{\n    return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n//??´?????¨??????????????¢\ndouble distanceLS(const L &l, const L &s)\n{\n    if (intersectLS(l, s)) return 0;\n    return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\n//????????¨???????????¢\ndouble distanceSP(const L &s, const C p)\n{\n    const C r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n}\n//????????¨??????????????¢\ndouble distanceSS(const L &s, const L &t)\n{\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n//??´???????????????????????????\nC crosspointLL(const L &l, const L &m)\n{\n    double A = cross(l[1] - l[0], m[1] - m[0]);\n    double B = cross(l[1] - l[0], l[1] - m[0]);\n    //????????´????????¨???\n    if(abs(A) < EPS && abs(B) < EPS){\n        return m[0];\n    }\n    return m[0] + B / A * (m[1] - m[0]);\n}\n//?????¨??´????????????\ndouble gettime(C c1,C c2)\n{\n  return (dot(c1,c2) < 0 ? -1.0 : 1.0 ) * abs(c2) / abs(c1);\n}\n//?????¨??´????????????\nvector<C> crosspointCL(C c1,double r1,L l)\n{\n    C a=l[0], b=l[1];\n    vector<C> res;\n    C base=b-a,  target=projection(L(a,b),c1);\n    double length=abs(base), h=abs(c1-target);\n    base/=length;\n    if(r1+EPS<h)    return res;\n    double w=Sqrt(r1*r1-h*h);\n    double LL=gettime(normalize(b-a),target-a)-w,RR=LL+w*2.0;\n    res.push_back(a+base*LL);\n    if(eq(LL,RR))   return res;\n    res.push_back(a+base*RR);\n    return res;\n}\n//?????¨???????????????\nvector<C> crosspointCS(C c1,double r1,L s)\n{\n    vector<C> tmp=crosspointCL(c1,r1,s);\n    vector<C> res;\n    rep(i,tmp.size()){\n        if(eq(abs(s[1]-s[0]),abs(s[0]-tmp[i])+abs(s[1]-tmp[i]))){\n            res.push_back(tmp[i]);\n        }\n    }\n    return res;\n}\n//?????????????????????\nL crosspointCC(const C c1, const double r1, const C c2, const double r2)\n{\n  C a = conj(c2-c1), b = (r2*r2-r1*r1-(c2-c1)*conj(c2-c1)), c = r1*r1*(c2-c1);\n  C d = b*b-4.0*a*c;\n  C z1 = (-b+sqrt(d))/(2.0*a)+c1, z2 = (-b-sqrt(d))/(2.0*a)+c1;\n  return L(z1, z2);\n}\n//?????¨????§???¢?????±?????¨????????¢???\ndouble getarea(C c1,double r1,C a,C b)\n{\n    C va=c1-a,vb=c1-b;\n    double A=abs(va),B=abs(vb);\n    double f=cross(va,vb),d=distanceSP(L(a,b),c1),res=0;\n    if(eq(f,0.0))   return 0;\n    if(A < r1+EPS && B < r1+EPS)    return f*0.5;\n    if(d>r1-EPS)    return r1*r1*M_PI*getarg(va,vb)/(2.0*M_PI);\n    vector<C> u=crosspointCS(c1,r1,L(a,b));\n    u.insert(u.begin(),a),u.push_back(b);\n    for(int i=0;i+1<(int)u.size();i++){\n        res+=getarea(c1,r1,u[i],u[i+1]);\n    }\n    return res;\n}\ndouble getcrossarea(vector<C> t,C c1,double r1)\n{\n    int n=t.size();\n    if(n<3) return 0;\n    double res=0;\n    rep(i,n){\n      C a=t[i], b=t[(i+1)%n];\n      res += getarea(c1,r1,a,b);\n    }\n    return res;\n}\n//??????????±???????\nvector<C> convex_full(vector<C> ps)\n{\n    int n = ps.size(), k = 0;\n    sort(ps.begin(), ps.end());\n    vector<C> ch(2*n);\n    for (int i = 0; i < n; ch[k++] = ps[i++]){\n        while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) k--;\n    }\n    for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]){\n        while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) k--;\n    }\n    ch.resize(k-1);\n    return ch;\n}\n//?????§??????\nbool isconvex(const vector<C> &ps)\n{\n    rep(i,ps.size()){\n        if (ccw(ps[(i+ps.size()-1) % ps.size()],ps[i],ps[(i+1) % ps.size()])) return false;\n    }\n    return true;\n}\n//????§???¢?????¢???\ndouble area(const vector<C> &ps)\n{\n    double A = 0;\n    rep(i,ps.size()){\n        A += cross(ps[i],ps[(i+1) % ps.size()]);\n    }\n    return A / 2.0;\n}\n//???????§???¢?????´?????§???????????????????????´????????¢\nvector<C> convex_cut(const vector<C> &ps, const L &l)\n{\n    vector<C> Q;\n    rep(i,ps.size()){\n        C A = ps[i], B = ps[(i+1)%ps.size()];\n        if (ccw(l[0], l[1], A) != -1) Q.push_back(A);\n        if (ccw(l[0], l[1], A)*ccw(l[0], l[1], B) < 0)\n            Q.push_back(crosspointLL(L(A, B),l));\n    }\n    return Q;\n}\n//??????????§???¢???????????????????????????(0??????????????????,1?????????,2???????????????)\nint contains(const vector<C>& ps, const C p)\n{\n    bool flag = false;\n    rep(i,ps.size()) {\n        C a = ps[i] - p, b = ps[(i+1)%ps.size()] - p;\n        if (imag(a) > imag(b)) swap(a, b);\n        if (imag(a) <= 0 && 0 < imag(b)){\n            if (cross(a, b) < 0) flag = !flag;\n        }\n        if (cross(a, b) == 0 && dot(a, b) <= 0) return 1;\n  }\n  return flag ? 2 : 0;\n}\n//???????§???¢?????????\nvector<C> convex_intersection(vector<C>& ps,vector<C>& qs)\n{\n\tvector<C> rs;\n\tint a = ps.size(),b = qs.size();\n\trep(i,a){\n        if(contains(qs,ps[i])){\n            rs.push_back(ps[i]);\n        }\n    }\n\trep(i,b){\n        if(contains(ps,qs[i])){\n            rs.push_back(qs[i]);\n        }\n    }\n    rep(i,a){\n        rep(j,b){\n            L l1(ps[i],ps[(i+1)%a]),l2(qs[j],qs[(j+1)%b]);\n\t\t    if(intersectSS(l1,l2)){\n                rs.push_back(crosspointLL(l1,l2));\n            }\n        }\n\t}\n\tsort(rs.begin(),rs.end());\n\trs.erase(unique(all(rs)),rs.end());\n\tif(rs.size() <= 1){\n        return rs;\n    }\n\treturn convex_full(rs);\n}\n//???????§???¢?????´???????±???????(?????£????????????)\n//maxi,maxj?????????????????¨??????\ndouble convex_diameter(const vector<C> &ps)\n{\n    const int n = ps.size();\n    int is = 0, js = 0;\n    for (int i = 1; i < n; ++i) {\n        if (imag(ps[i]) > imag(ps[is])) is = i;\n        if (imag(ps[i]) < imag(ps[js])) js = i;\n    }\n    double maxd = abs(ps[is]-ps[js]);\n    int i, maxi, j, maxj;\n    i = maxi = is;\n    j = maxj = js;\n    do{\n        if (cross(ps[(i+1)%ps.size()]-ps[i],ps[(j+1)%ps.size()]-ps[j]) >= 0) j = (j+1) % n;\n        else i = (i+1) % n;\n        if (abs(ps[i]-ps[j]) > maxd) {\n            maxd = abs(ps[i]-ps[j]);\n            maxi = i; maxj = j;\n        }\n    } while (i != is || j != js);\n    return maxd;\n}\n\nbool compyx(C c1,C c2)\n{\n    return c1.imag() != c2.imag() ? c1.imag() < c2.imag() : c1.real() < c2.real();\n}\n\n//????????????????±???????\ndouble closest_pair(C *a, int n)\n{\n    if(n<=1) return INF;\n    int m=n/2;\n    double x=a[m].real();\n    double d=min(closest_pair(a,m),closest_pair(a+m,n-m));\n    inplace_merge(a,a+m,a+n,compyx);\n    vector<C> b;\n    rep(i,n){\n        if(abs(x-a[i].real())>=d) continue;\n        rep(j,b.size()){\n            C dp=a[i]-b[b.size()-1-j];\n            if(dp.imag()>=d) break;\n            d=min(d,abs(dp));\n        }\n        b.push_back(a[i]);\n    }\n    return d;\n}\ndouble compute_shortest(C *a,int n)\n{\n    sort(a,a+n);\n    return closest_pair(a,n);\n}\n//2??????????????¢????????????(????????????2??????????????±?????\\????????°)\nint getstateCC(C c1,double r1,C c2,double r2)\n{\n    double d=abs(c1-c2);\n    if(d>r1+r2+EPS)return 4;\n    if(d>r1+r2-EPS)return 3;\n    if(d>abs(r1-r2)+EPS)return 2;\n    if(d>abs(r1-r2)-EPS)return 1;\n    return 0;\n}\n//?????????????????\\???????????????????????\\???\nC gettangentCP_(C c1,double r1,C p,int flg){\n    C base=c1-p;\n    double w=Sqrt(norm(base)-r1*r1);\n    C s=p+base*C(w,r1 * flg)/norm(base)*w;\n    return s;\n}\n//????????????????????\\???\nvector<L> gettangentCP(C c1,double r1,C p){\n    vector<L> res;\n    C s=gettangentCP_(c1,r1,p,1);\n    C t=gettangentCP_(c1,r1,p,-1);\n    //??????????????¨??????????????´???\n    if(eq(s,t)){\n        res.push_back(L(s,s+(c1-p)*C(0,1)));\n    }else{\n        res.push_back(L(p,s));\n        res.push_back(L(p,t));\n    }\n    return res;\n}\n\n//2????????±????????\\???????±???????\nL getintangent(C c1,double r1,C c2,double r2,double flg)\n{\n    C base=c2-c1;\n    double w=r1+r2;\n    double h=Sqrt(norm(base)-w*w);\n    C k=base*C(w,h*flg)/norm(base);\n    return L(c1+k*r1,c2-k*r2);\n}\n//2????????±????????\\???????±???????\nL getouttangent(C c1,double r1,C c2,double r2,double flg)\n{\n    C base=c2-c1;\n    double h=r2-r1;\n    double w=Sqrt(norm(base)-h*h);\n    C k=base*C(w,h*flg)/norm(base)*C(0,flg);\n    return L(c1+k*r1,c2+k*r2);\n}\n//2????????±?????\\???????±???????(?????´??????????????????????????????????????\\???)\nvector<L> gettangentCC(C c1,double r1,C c2,double r2)\n{\n    vector<L> res;\n    double d=abs(c1-c2);\n    if(d>r1+r2+EPS)  res.push_back(getintangent(c1,r1,c2,r2,1));\n    if(d>r1+r2-EPS)  res.push_back(getintangent(c1,r1,c2,r2,-1));\n    if(d>abs(r1-r2)+EPS)    res.push_back(getouttangent(c1,r1,c2,r2,1));\n    if(d>abs(r1-r2)-EPS)    res.push_back(getouttangent(c1,r1,c2,r2,-1));\n    return res;\n}\n\nint main()\n{\n    int n,m;\n    cin >> n >> m;\n    vector<vector<C> > poly(n);\n    rep(i,n){\n        int sz;\n        cin >> sz;\n        rep(j,sz){\n            int u,v;\n            cin >> u >> v;\n            poly[i].pb(C(u,v));\n        }\n    }\n    vector<C> cand(m);\n    rep(i,m){\n        int u,v;\n        cin >> u >> v;\n        cand[i] = C(u,v);\n    }\n    vector<vector<L> > ln(m);\n    rep(i,m){\n        rep(j,n){\n            rep(k,len(poly[j])){\n                ln[i].push_back(L(cand[i],poly[j][k]));\n            }\n        }\n    }\n    vector<C> point;\n    rep(i,m){\n        rep(j,len(ln[i])){\n            srep(k,i+1,m){\n                rep(l,len(ln[k])){\n                    if(intersectLL(ln[i][j],ln[k][l])){\n                        point.pb(crosspointLL(ln[i][j],ln[k][l]));\n                    }\n                }\n            }\n        }\n    }\n    int mx = 0;\n    rep(i,len(point)){\n        int res = 0;\n        rep(j,m){\n            bool flag = true;\n            rep(k,n){\n                rep(l,len(poly[k])){\n                    if(intersectSS(L(point[i],cand[j]),L(poly[k][l],poly[k][(l+1)%len(poly[k])]))){\n                        flag = false;\n                        break;\n                    }\n                }\n                if(!flag){\n                    break;\n                }\n            }\n            if(flag){\n                res++;\n            }\n        }\n        cmx(mx,res);\n    }\n    cout << mx << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <cassert>\n\nusing namespace std;\n\n#define X real()\n#define Y imag()\n#define at(i) ((*this)[i])\n#define SELF (*this)\n    enum {TRUE = 1, FALSE = 0, BORDER = -1};\n    typedef int BOOL;\n    typedef long double R;\n    const R INF = 1e8;\n    R EPS = 1e-12;\n    const R PI = 3.1415926535897932384626;\n    inline int sig(const R &x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n    inline BOOL less(const R &x, const R &y) {return sig(x-y) ? x < y : BORDER;}\n\n    typedef complex<R> P;\ninline R norm(const P &p){return p.X*p.X+p.Y*p.Y;}\ninline R inp(const P& a, const P& b){return (conj(a)*b).X;}\ninline R outp(const P& a, const P& b){return (conj(a)*b).Y;}\ninline P unit(const P& p){return p/abs(p);}\ninline P proj(const P &s, const P &t){return t*inp(s, t)/norm(t);}\ninline int ccw(const P &s, const P &t, const P &p, int adv=0){\n    int res = sig(outp(t-s, p-s));\n    if(res || !adv) return res;\n    if(sig(inp(t-s, p-s)) < 0) return -2; // p-s-t\n    if(sig(inp(s-t, p-t)) < 0) return 2; // s-t-p\n    return 0; // s-p-t\n}\nstruct L : public vector<P>{ // line\n    L(const P &p1, const P &p2){this->push_back(p1);this->push_back(p2);}\n    L(){}\n    P dir()const {return at(1) - at(0);}\n    BOOL online(const P &p)const {return !sig(outp(p-at(0), dir()));}\n};\nstruct S : public L{ // segment\n    S(const P &p1, const P &p2):L(p1, p2){}\n    S(){}\n    BOOL online(const P &p)const {\n        if(!sig(norm(p - at(0))) || !sig(norm(p - at(1)))) return BORDER;\n        // 座標の二乗とEPS の差が大きすぎないように注意\n        return !sig(outp(p-at(0), dir())) && inp(p-at(0), dir()) > EPS && inp(p-at(1), -dir()) > -EPS;\n//return !sig(abs(at(0)-p) + abs(at(1) - p) - abs(at(0) - at(1)));\n    }\n};\n\n// 交差判定\nBOOL intersect(const S &s, const S &t){\n    const int p = ccw(t[0], t[1], s[0], 1) * ccw(t[0], t[1], s[1], 1);\n    const int q = ccw(s[0], s[1], t[0], 1) * ccw(s[0], s[1], t[1], 1);\n    return (p>0||q>0) ? FALSE : (!p||!q) ? BORDER : TRUE;\n}\n\ninline P crosspoint(const L &l, const L &m, bool& sat){\n        sat = true;\n       R A = outp(l.dir(), m.dir()), B = outp(l.dir(), l[1] - m[0]);\n       if(!sig(abs(A)) && !sig(abs(B))) return m[0]; // same line\n       //if(abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n       if(abs(A) < EPS){\n           sat = false;\n           return {};\n       }\n       return m[0] + B / A * (m[1] - m[0]);\n} \n#undef SELF\n#undef at\n\n\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define reps(i,a,n) for(int i = (a); i < (n); ++i)\n\nvector<S> G;\nvector<P> A;\n\nint main(){\n    int n,m;\n    cin >> n >> m;\n    \n    rep(i, n){\n        int l;\n        cin >> l;\n        vector<P> z;\n        rep(i, l){\n            int x,y;\n            cin >>x >> y;\n            z.emplace_back(x, y);\n        }\n        rep(i, l){\n            G.emplace_back(z[i], z[(i+1)%l]);\n        }\n    }\n    {\n        vector<P> z;\n        z.emplace_back(-10000000, -10000000);\n        z.emplace_back(-10000000,  10000000);\n        z.emplace_back( 10000000,  10000000);\n        z.emplace_back( 10000000, -10000000);\n        G.emplace_back(z[0], z[1]);\n        G.emplace_back(z[1], z[2]);\n        G.emplace_back(z[2], z[3]);\n        G.emplace_back(z[3], z[0]);\n    }\n\n    rep(i, m){\n        int x,y;\n        cin >> x >> y;\n        A.emplace_back(x, y);\n    }\n    int ans = 1;\n    rep(i, m){\n        rep(j, G.size()){\n            L LI(A[i], G[j][0]);\n            reps(k, i+1, m){\n                reps(l, j+1, G.size()){\n                    L NE(A[k], G[l][0]);\n                    // cout << \"$\" << LI[0] << LI[1] << \"  \" << NE[0] << NE[1] << endl;\n                    bool sat;\n                    P p = crosspoint(LI, NE, sat);\n                    if(!sat) continue;\n                    int an = 0;\n                    rep(a, m){\n                        S aa(A[a], p);\n                        bool ok = true;\n                        rep(b, G.size()){\n                            auto r = intersect(aa, G[b]);\n                            if(r == TRUE){\n                                ok = false;\n                                break;\n                            }\n                        }\n                        if(ok) ++an;\n                    }\n                    ans = max(ans, an);\n                }\n            }\n        }\n    }\n    cout << ans << endl;\n\n\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ndouble eps = 0.0000001;\nstruct P {\n  double x, y;\n};\nstruct L {\n  P p1, p2;\n  double x() { return p2.x - p1.x; }\n  double y() { return p2.y - p1.y; }\n};\ndouble prod(L l1, L l2) { return l1.x() * l2.y() - l1.y() * l2.x(); }\npair<double, double> interP(L l1, L l2) {\n  double a = l1.x();\n  double b = -l2.x();\n  double c = l1.y();\n  double d = -l2.y();\n  double inv = 1. / (a * d - c * b);\n  double e1 = -l1.p1.x + l2.p1.x;\n  double e2 = -l1.p1.y + l2.p1.y;\n  return make_pair((d * e1 - b * e2) * inv, (-c * e1 + a * e2) * inv);\n}\nbool intersect(L l1, L l2) {\n  if (prod(l1, l2) == 0) {\n    return false;\n  }\n  auto p = interP(l1, l2);\n  return eps < p.first && p.first < 1 - eps && eps < p.second &&\n         p.second < 1 - eps;\n}\nint main() {\n\n  int n, m;\n  cin >> n >> m;\n  vector<vector<P>> p(n);\n  for (int i = 0; i < n; i++) {\n    int l;\n    cin >> l;\n    for (int j = 0; j < l; j++) {\n      double x, y;\n      cin >> x >> y;\n      p[i].push_back(P{x, y});\n    }\n  }\n  vector<P> hum(m);\n  for (int i = 0; i < m; i++) {\n    cin >> hum[i].x >> hum[i].y;\n  }\n  vector<L> line;\n  for (int i = 0; i < m; i++) {\n    for (auto &poly : p) {\n      for (int j = 0; j < poly.size(); j++) {\n        double x = hum[i].x + (poly[j].x - hum[i].x) * 10000;\n        double y = hum[i].y + (poly[j].y - hum[i].y) * 10000;\n        line.push_back(L{hum[i], P{x, y}});\n      }\n    }\n  }\n  vector<P> ps;\n  for (int i = 0; i < line.size(); i++)\n    for (int j = i + 1; j < line.size(); j++) {\n      if (intersect(line[i], line[j])) {\n        auto rs = interP(line[i], line[j]);\n        if (rs.first < 0 || rs.second < 0)\n          continue;\n        ps.push_back(P{line[i].p1.x + line[i].x() * rs.first,\n                       line[i].p1.y + line[i].y() * rs.second});\n      }\n    }\n\n  if (n == 0) {\n    cout << m << endl;\n    return 0;\n  }\n  if (m == 1) {\n    cout << 1 << endl;\n    return 0;\n  }\n\n  int ans = 0;\n  for (int i = 0; i < ps.size(); i++) {\n    int score = m;\n    for (int j = 0; j < m; j++) {\n      L l1{ps[i], hum[j]};\n      bool ng = false;\n\n      for (auto &poly : p) {\n        for (int k = 0; k < poly.size(); k++) {\n          P p1 = poly[k];\n          P p2 = poly[(k + 1) % poly.size()];\n          L l2{p1, p2};\n          if (intersect(l1, l2)) {\n            ng = true;\n          }\n        }\n      }\n\n      if (ng) {\n        score--;\n      }\n    }\n    ans = max(ans, score);\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(_v) for(auto _x:_v){cout<<_x<<\" \";}cout<<endl\n#define printVS(vs) for(auto x : vs){cout << x << endl;}\n#define printVV(_vv) for(auto _v:_vv){for(auto _x:_v){cout<<_x<<\" \";}cout<<endl;}\n#define printP(p) cout << p.first << \" \" << p.second << endl\n#define printVP(vp) for(auto p : vp) printP(p);\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<Pii> vp;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\ntypedef complex<double> P;\ntypedef vector<P> G;\n#define here(g, i) g[i]\n#define next(g, i) g[(i + 1) % g.size()]\n#define prev(g, i) g[(i - 1 + g.size()) % g.size()]\nconst double EPS = 1e-10;\nconst double INF = 1e12;\nconst double PI = acos(-1);\n\nstruct L {\n    P a, b, v;\n    L(){}\n    L(P _a, P _b) : a(_a), b(_b), v(b - a) {}\n    L(double _ax, double _ay, double _bx, double _by) : L(P(_ax, _ay), P(_bx, _by)) {}\n};\n\ndouble cross(P a, P b) {\n    return imag(conj(a) * b);\n}\n\ndouble dot(P a, P b) {\n    return real(conj(a) * b);\n}\n\nint ccw(P p0, P p1, P p2) {\n    if (cross(p1 - p0, p2 - p0) > 0) return +1; // counter-clockwise\n    if (cross(p1 - p0, p2 - p0) < 0) return -1; // clockwise\n    if (dot(p1 - p0, p2 - p0) < 0) return +2;   // online_back\n    if (dot(p0 - p1, p2 - p1) < 0) return -2;   // online_front\n    return 0;                                   // on_segment\n}\n\n// !! ???????????????????????¨?????? \"<\" !!\nbool intersectSS(L l1, L l2) {\n    return (ccw(l1.a, l1.b, l2.a) * ccw(l1.a, l1.b, l2.b) < 0 &&\n            ccw(l2.a, l2.b, l1.a) * ccw(l2.a, l2.b, l1.b) < 0);\n}\n\nP crosspointSS(L l1, L l2) {\n    assert(intersectSS(l1, l2));\n    double d1 = abs(cross(l2.v, l1.a - l2.a));\n    double d2 = abs(cross(l2.v, l1.b - l2.a));\n    double t = d1 / (d1 + d2);\n    return l1.a + t * l1.v;\n}\n\nbool intersectLL(L l1, L l2) {\n    return cross(l1.v, l2.v) != 0;\n}\n\nP crosspointLL(L l1, L l2) {\n    return l1.a + l1.v * cross(l2.v, l2.a - l1.a) / cross(l2.v, l1.v);\n}\n\nbool intersectSG(L l, G g) {\n    int n = g.size();\n    rep(i, n) {\n        if (intersectSS(l, L(here(g, i), next(g, i)))) {\n            return true;\n        }\n    }\n    return false;\n}\n\nP readP() {\n    double x, y;\n    cin >> x >> y;\n    return P(x, y);\n}\n\nG readG() {\n    int n;\n    cin >> n;\n    G g(n);\n    rep(i, n) g[i] = readP();\n    return g;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n, m;\n    cin >> n >> m;\n    vector<G> g(n);\n    rep(i, n) g[i] = readG();\n    vector<P> p(m);\n    rep(i, m) p[i] = readP();\n\n    if (m == 1) {\n        cout << 1 << endl;\n        return 0;\n    }\n\n    int ans = 0;\n    rep(i1, m) {\n        P p1 = p[i1];\n        rep(j1, n) {\n            rep(k1, g[j1].size()) {\n                P q1 = g[j1][k1];\n                rep2(i2, i1 + 1, m) {\n                    P p2 = p[i2];\n                    rep(j2, n) {\n                        rep(k2, g[j2].size()) {\n                            P q2 = g[j2][k2];\n                            // Line!!!!\n                            if (!intersectLL(L(p1, q1), L(p2, q2))) {\n                                continue;\n                            }\n                            P c = crosspointLL(L(p1, q1), L(p2, q2));\n                            int cnt = 0;\n                            rep(i3, m) {\n                                cnt += [&](L l) {\n                                    rep(j, n) {\n                                        // Segment!!!!\n                                        if (intersectSG(l, g[j])) return false;\n                                    }\n                                    return true;\n                                }(L(c, p[i3]));\n                            }\n                            ans = max(ans, cnt);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ld = long double;\nusing point = complex<ld>;\nusing polygon = vector<point>;\n\nconstexpr ld eps = 1e-8;\nconstexpr ld pi = acos(-1.0);\n\nlong double dot(point a, point b) {\n    return std::real(std::conj(a) * b);\n}\n\nlong double cross(point a, point b) {\n    return std::imag(std::conj(a) * b);\n}\n\nint ccw(point a, point b, point c) {\n    b -= a; c -= a;\n    if(cross(b, c) > eps)           return 1;  // a -> b -> c : counterclockwise\n    if(cross(b, c) < -eps)          return -1; // a -> b -> c : clockwise\n    if(dot(b, c) < 0)               return 2;  // c -> a -> b : line\n    if(std::norm(b) < std::norm(c)) return -2; // a -> b -> c : line\n    return 0;                                  // a -> c -> b : line\n}\n\nstruct segment {\n    segment() : a(0, 0), b(0, 0) {}\n    segment(point a, point b) : a(a), b(b) {}\n    point a, b;\n};\n\nstruct line {\n    line() : a(0, 0), b(0, 0) {}\n    line(point a, point b) : a(a), b(b) {}\n    line(segment s) : a(s.a), b(s.b) {}\n    point a, b;\n};\n\nbool isis_sp(segment s, point p) {\n    return (std::abs(s.a - p) + std::abs(s.b - p) - std::abs(s.b - s.a) < eps);\n}\n\nbool isis_ll(line l, line m) {\n    return !(abs(cross(l.b - l.a, m.b - m.a)) < eps);\n}\n\nbool isis_ls(line l, segment s) {\n    return (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_ss(segment s, segment t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0\n        && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\npoint is_ll(line s, line t) {\n    point sv = s.b - s.a, tv = t.b - t.a;\n    assert(cross(sv, tv) != 0);\n    return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 0 -> on, 1 -> in, 2 -> out\nint is_in_polygon(polygon const& poly, point p) {\n    int N = poly.size();\n    ld sum = 0;\n    for(int i=0; i<N; ++i) {\n        point p1 = poly[i], p2 = poly[(i+1)%N];\n        if(isis_sp(segment(p1, p2), p)) {\n            return 0;\n        }\n        sum += arg((p2 - p) / (p1 - p));\n    }\n    return std::abs(sum) < pi / 2 ? 2 : 1;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<polygon> polys(n);\n    for(int i = 0; i < n; ++i) {\n        int l; cin >> l;\n        for(int j = 0; j < l; ++j) {\n            ld x, y;\n            cin >> x >> y;\n            polys[i].emplace_back(x, y);\n        }\n    }\n    vector<ld> x(m), y(m);\n    for(int i = 0; i < m; ++i) {\n        cin >> x[i] >> y[i];\n    }\n\n    vector<line> ls;\n    vector<point> cand;\n    for(int i = 0; i < m; ++i) {\n        for(auto& poly : polys) {\n            for(auto& p : poly) {\n                cand.push_back(p);\n                ls.emplace_back(point(x[i], y[i]), p);\n            }\n        }\n    }\n\n    for(int i = 0; i < (int)ls.size(); ++i) {\n        for(int j = i + 1; j < (int)ls.size(); ++j) {\n            if(isis_ll(ls[i], ls[j])) {\n                auto p = is_ll(ls[i], ls[j]);\n                bool ok = true;\n                for(auto& poly : polys) {\n                    ok &= is_in_polygon(poly, p) != 1;\n                }\n                if(ok) {\n                    cand.emplace_back(is_ll(ls[i], ls[j]));\n                }\n            }\n        }\n    }\n\n    int ans = 0;\n    for(auto& p : cand) {\n        int t = 0;\n        for(int i = 0; i < m; ++i) {\n            segment s1(point(x[i], y[i]), p);\n            if(abs(s1.a - p) < eps) continue; // ok\n            bool ok = true;\n            for(auto& poly : polys) {\n                const int sz = poly.size();\n                vector<point> cp;\n                for(int j = 0; j < sz; ++j) {\n                    segment s2(poly[j], poly[(j + 1) % sz]);\n                    if(isis_ss(s1, s2)) {\n                        //if(n == 1 && m == 2) {\n                        //    cout << \"s-to-s: \" << s1.a << ' ' << s1.b << endl;\n                        //}\n                        cp.push_back(is_ll(line(s1), line(s2)));\n                    }\n                }\n                sort(begin(cp), end(cp),\n                     [](auto const& p1, auto const& p2) {\n                         return real(p1) < real(p2) || (real(p1) <= real(p2) && imag(p1) < imag(p2));\n                     });\n                {\n                    vector<point> cp2;\n                    for(int i = 0; i < (int)cp.size(); ++i) {\n                        if(cp2.empty() || abs(cp2.back() - cp[i]) > eps) cp2.push_back(cp[i]);\n                    }\n                    cp = move(cp2);\n                }\n                if(cp.size() >= 2u && abs(cp[0] - cp[1]) >= eps) {\n                    //if(n == 1 && m == 2) {\n                    //    cout << \"segment: \" << point(x[i], y[i]) << ' ' << p << endl;\n                    //    cout << \"coll: \" << cp[0] << ' ' << cp[1] << endl;\n                    //}\n                    ok = false;\n                }\n            }\n            t += ok;\n        }\n        ans = max(ans, t);\n    }\n\n    cout << ans << endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*include*/\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<complex>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define rp(a) while(a--)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst double inf=1e8;\nusing namespace std;\n#define shosu(x) fixed<<setprecision(x)\ntypedef complex<double> P;\ntypedef vector<P> G;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn a.real()==b.real()&&a.imag()==b.imag();\n\t}\n}\nP pin(){\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) < 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) < 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n/*bool intersectCS(C c,const L &l){\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.r < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}*/\nint intersectCS(C c,L l){\n\tif(norm(projection(l,c.c)-c.c)-c.r*c.r>EPS)return 0;\n\tconst double d1=abs(c.c-l[0]),d2=abs(c.c-l[1]);\n\tif(d1<c.r+EPS&&d2<c.r+EPS)return 0;\n\tif(d1<c.r-EPS&&d2>c.r+EPS||d1>c.r+EPS&&d2<c.r-EPS)return 1;\n\tconst P h=projection(l,c.c);\n\tif(dot(l[0]-h,l[1]-h)<0)return 2;\n\treturn 0;\n}\nP crosspointSS(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\nL crosspointCL(C c,L l){\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble t=sqrt(c.r*c.r-norm(pr-c.c));\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}\nL crosspointCS(C c,L l){\n\tif(intersectCS(c,l)==2)return crosspointCL(c,l);\n\tL ret=crosspointCL(c,l);\n\tif(dot(l[0]-ret[0],l[1]-ret[0])<0)ret[1]=ret[0];\n\telse ret[0]=ret[1];\n\treturn ret;\n}\nL crosspointCC(C a,C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint inconvex(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<EPS&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(abs(cross(a,b))<EPS&&dot(a,b)<EPS)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nP turn2(P p,double t){\n\treturn p*exp(P(.0,t));\n}\nvector<L> tangentCC(C a,C b){\n\tif(a.r<b.r)swap(a,b);\n\tdouble d=abs(a.c-b.c);\n\tvector<L>l;\n\tif(d<EPS)return l;\n\tif(a.r+b.r<d-EPS){//hanareteiru\n\t\tdouble t=acos((a.r+b.r)/d);\n\t\tt=t*180/PI;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t),b.c+turn(b.r/d*(a.c-b.c),t)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t),b.c+turn(b.r/d*(a.c-b.c),-t)));\n\t}else if(a.r+b.r<d+EPS){//kuttuiteiru soto\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\tif(abs(a.r-b.r)<d-EPS){//majiwatteiru\n\t\tdouble t1=acos((a.r-b.r)/d);\n\t\tt1=t1*180/PI;\n\t\tdouble t2=180-t1;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t1),b.c+turn(b.r/d*(a.c-b.c),-t2)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t1),b.c+turn(b.r/d*(a.c-b.c),t2)));\n\t}else if(abs(a.r-b.r)<d+EPS){//kuttuiteiru uti\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\treturn l;\n}\nvoid printL(const L &out){\n\tprintf(\"%2.0f %2.0f %2.0f %2.0f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n\tP p=pin();\n\tdouble r;\n\tcin>>r;\n\treturn C(p,r);\n}\nbool para(L a,L b){\n\treturn (abs(cross(a[1]-a[0],b[1]-b[0]))<EPS);\n}\ndouble min(double a,double b){return a<b?a:b;}\ndouble max(double a,double b){return a>b?a:b;}\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tvector<G>g(n);\n\trep(i,n){\n\t\tint l;\n\t\tcin>>l;\n\t\trep(j,l){\n\t\t\tP p=pin();\n\t\t\tg[i].pb(p);\n\t\t}\n\t}\n\tG in(m);\n\trep(i,m)in[i]=pin();\n\tvector<L>line;\n\trep(i,m)rep(j,n)rep(k,g[j].size())line.pb(L(in[i],g[j][k]));\n\tint N=line.size();\n\tint out=0;\n\trep(i,N)loop(j,i+1,N){\n\t\tif(para(line[i],line[j]))continue;\n\t\tP p=crosspointLL(line[i],line[j]);\n\t\tint co=0;\n\t\trep(k,m){\n\t\t\tbool h=true;\n\t\t\tL lin(in[k],p);\n\t\t\trep(l,n)rep(q,g[l].size())\n\t\t\t\tif(intersectSS(lin,L(g[l][q],g[l][(q+1)%g[l].size()])))h=false;\n\t\t\tco+=h;\n\t\t}\n\t\tout=max(out,co);\n\t}\n\tcout<<out<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ndouble eps = 0.0000001;\nstruct P {\n  double x, y;\n};\nstruct L {\n  P p1, p2;\n  double x() { return p2.x - p1.x; }\n  double y() { return p2.y - p1.y; }\n};\ndouble prod(L l1, L l2) { return l1.x() * l2.y() - l1.y() * l2.x(); }\npair<double, double> interP(L l1, L l2) {\n  double a = l1.x();\n  double b = -l2.x();\n  double c = l1.y();\n  double d = -l2.y();\n  double inv = 1. / (a * d - c * b);\n  double e1 = -l1.p1.x + l2.p1.x;\n  double e2 = -l1.p1.y + l2.p1.y;\n  return make_pair((d * e1 - b * e2) * inv, (-c * e1 + a * e2) * inv);\n}\nbool intersect(L l1, L l2) {\n  if (prod(l1, l2) == 0) {\n    return false;\n  }\n  auto p = interP(l1, l2);\n  return eps < p.first && p.first < 1 - eps && eps < p.second &&\n         p.second < 1 - eps;\n}\nint main() {\n\n  int n, m;\n  cin >> n >> m;\n  vector<vector<P>> p(n);\n  for (int i = 0; i < n; i++) {\n    int l;\n    cin >> l;\n    for (int j = 0; j < l; j++) {\n      double x, y;\n      cin >> x >> y;\n      p[i].push_back(P{x, y});\n    }\n  }\n  vector<P> hum(m);\n  for (int i = 0; i < m; i++) {\n    cin >> hum[i].x >> hum[i].y;\n  }\n  vector<L> line;\n  for (int i = 0; i < m; i++) {\n    for (auto &poly : p) {\n      for (int j = 0; j < poly.size(); j++) {\n        double x = hum[i].x + (poly[j].x - hum[i].x) * 10000;\n        double y = hum[i].y + (poly[j].y - hum[i].y) * 10000;\n        line.push_back(L{hum[i], P{x, y}});\n      }\n    }\n  }\n  vector<P> ps;\n  for (int i = 0; i < line.size(); i++)\n    for (int j = i + 1; j < line.size(); j++) {\n      if (intersect(line[i], line[j])) {\n        auto rs = interP(line[i], line[j]);\n        ps.push_back(P{line[i].p1.x + line[i].x() * rs.first,\n                       line[i].p1.y + line[i].y() * rs.second});\n      }\n    }\n\n  if (n == 0) {\n    cout << m << endl;\n    return 0;\n  }\n  if (m == 1) {\n    cout << 1 << endl;\n    return 0;\n  }\n\n  int ans = 0;\n  for (int i = 0; i < ps.size(); i++) {\n    int score = m;\n    for (int j = 0; j < m; j++) {\n      L l1{ps[i], hum[j]};\n      bool ng = false;\n\n      for (auto &poly : p) {\n        for (int k = 0; k < poly.size(); k++) {\n          P p1 = poly[k];\n          P p2 = poly[(k + 1) % poly.size()];\n          L l2{p1, p2};\n          if (intersect(l1, l2)) {\n            ng = true;\n          }\n        }\n      }\n\n      if (ng) {\n        score--;\n      }\n    }\n    ans = max(ans, score);\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ndouble eps = 0.00001;\nstruct P {\n  double x, y;\n};\nstruct L {\n  P p1, p2;\n  double x() { return p2.x - p1.x; }\n  double y() { return p2.y - p1.y; }\n};\ndouble prod(L l1, L l2) { return l1.x() * l2.y() - l1.y() * l2.x(); }\npair<double, double> interP(L l1, L l2) {\n  double a = l1.x();\n  double b = -l2.x();\n  double c = l1.y();\n  double d = -l2.y();\n  double inv = 1. / (a * d - c * b);\n  double e1 = -l1.p1.x + l2.p1.x;\n  double e2 = -l1.p1.y + l2.p1.y;\n  return make_pair((d * e1 - b * e2) * inv, (-c * e1 + a * e2) * inv);\n}\nbool intersect(L l1, L l2) {\n  if (prod(l1, l2) == 0) {\n    return false;\n  }\n  auto p = interP(l1, l2);\n  return eps < p.first && p.first < 1 - eps && eps < p.second &&\n         p.second < 1 - eps;\n}\nint main() {\n\n  int n, m;\n  cin >> n >> m;\n  vector<vector<P>> p(n);\n  for (int i = 0; i < n; i++) {\n    int l;\n    cin >> l;\n    for (int j = 0; j < l; j++) {\n      double x, y;\n      cin >> x >> y;\n      p[i].push_back(P{x, y});\n    }\n  }\n  vector<P> hum(m);\n  for (int i = 0; i < m; i++) {\n    cin >> hum[i].x >> hum[i].y;\n  }\n  vector<L> line;\n  for (int i = 0; i < m; i++) {\n    for (auto &poly : p) {\n      for (int j = 0; j < poly.size(); j++) {\n        double x = hum[i].x + (poly[j].x - hum[i].x) * 10000;\n        double y = hum[i].y + (poly[j].y - hum[i].y) * 10000;\n        line.push_back(L{hum[i], P{x, y}});\n      }\n    }\n  }\n  vector<P> ps;\n  for (int i = 0; i < line.size(); i++)\n    for (int j = i + 1; j < line.size(); j++) {\n      if (intersect(line[i], line[j])) {\n        auto rs = interP(line[i], line[j]);\n        if (rs.first < 0 || rs.second < 0)\n          continue;\n        ps.push_back(P{line[i].p1.x + line[i].x() * rs.first,\n                       line[i].p1.y + line[i].y() * rs.second});\n      }\n    }\n\n  if (n == 0) {\n    cout << m << endl;\n    return 0;\n  }\n  if (m == 1) {\n    cout << 1 << endl;\n    return 0;\n  }\n\n  int ans = 0;\n  for (int i = 0; i < ps.size(); i++) {\n    int score = m;\n    for (int j = 0; j < m; j++) {\n      L l1{ps[i], hum[j]};\n      bool ng = false;\n\n      for (auto &poly : p) {\n        for (int k = 0; k < poly.size(); k++) {\n          P p1 = poly[k];\n          P p2 = poly[(k + 1) % poly.size()];\n          L l2{p1, p2};\n          if (intersect(l1, l2)) {\n            ng = true;\n          }\n        }\n      }\n\n      if (ng) {\n        score--;\n      }\n    }\n    ans = max(ans, score);\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\ntypedef complex<double> pt;\n\ntypedef vector<P> poly;\nconst double EPS = 1e-7;\n#define x real()\n#define y imag()\n\nint n,m;\nint L[15]; pt p[15][20];\npt h[15];\nvector<pair<pt,pt> >LL;\nbool eq(double a,double b){\n  return (-EPS < a-b && b-a < EPS);\n}\ndouble dot(pt a,pt b){\n\treturn (conj(a)*b).x;\n}\ndouble cross(pt a,pt b){\n\treturn (conj(a)*b).y;\n}\npt crossPoint(pt a,pt b,pt c,pt d){\n\tdouble A = cross(b-a,d-c);\n\tdouble B = cross(b-a,b-c);\n\tif( fabs(A) < EPS && fabs(B) < EPS ) return c;\n\telse if(fabs(A) >= EPS ) return c+B/A*(d-c);\n\telse pt(1e9,1e9);\n}\nint ccw(pt a,pt b,pt c){\n\tb -= a; c -= a;\n\tif(cross(b,c) > EPS) return 1; // counter clockwise\n\tif(cross(b,c) < -EPS) return -1; // clockwise\n\tif(dot(b,c) < -EPS) return 2; //c-a-b\n\tif(norm(b) < norm(c)) return -2; //a-b-c\n\treturn 0; //a-c-b\n}\nbool intersect(pt a,pt b,pt c,pt d){\n\treturn (ccw(a,b,c)*ccw(a,b,d) <= 0 && ccw(c,d,a)*ccw(c,d,b) <= 0);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&L[i]);\n\t\tfor(int j=0;j<L[i];j++){\n\t\t\tdouble s,t;\n\t\t\tscanf(\"%lf%lf\",&s,&t); p[i][j] = pt(s,t);\n\t\t}\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tdouble s,t; scanf(\"%lf%lf\",&s,&t); h[i] = pt(s,t);\n\t}\n\t//human_vertex path\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<L[i];j++){\n\t\t\tfor(int k=0;k<m;k++){\n\t\t\t\tLL.pb(mp(p[i][j],h[k]));\n\t\t\t}\n\t\t}\n\t}\n\tvector<pt>C;\n\tfor(int i=0;i<LL.size();i++){\n\t\tfor(int j=i+1;j<LL.size();j++){\n\t\t\tpt cand = crossPoint(LL[i].fi,LL[i].sc,LL[j].fi,LL[j].sc);\n\t\t\t//cout << cand.x << \" \" << cand.y << endl;\n\t\t\tif(cand.x > 1e8) continue;\n\t\t\tif(abs(ccw(LL[i].fi,LL[i].sc,cand))%2!=0) continue;\n\t\t\tif(abs(ccw(LL[j].fi,LL[j].sc,cand))%2!=0) continue;//cout << \"K\" << endl;\n\t\t//\tcout << cand.x << \" \" << cand.y << endl;\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tfor(int l=0;l<L[k];l++){\n\t\t\t\t\tif(ccw(p[k][l],p[k][(l+1)%L[k]],cand) == 1){\n\t\t\t\t\t\t//in polygon\n\t\t\t\t\t\tgoto ok;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t//\tcout << cand.x << \" \" << cand.y << endl;\n\t\t\tok:; C.pb(cand);\n\t\t}\n\t}\n\tint ret = 1;\n\tfor(int i=0;i<C.size();i++){\n\t\tint num = 0;\n\t\tfor(int j=0;j<m;j++){\n\t\t\t//candidate_human path\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tfor(int l=0;l<L[k];l++){\n\t\t\t\t\tif(!intersect(C[i],h[j],p[k][l],p[k][(l+1)%L[k]])){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tpt cr = crossPoint(C[i],h[j],p[k][l],p[k][(l+1)%L[k]]);\n\t\t\t\t\t\tif(abs(p[k][l]-cr) < EPS) continue;\n\t\t\t\t\t\tif(abs(p[k][(l+1)%L[k]]-cr) < EPS) continue;\n\t\t\t\t\t}\n\t\t\t\t\tgoto fail;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnum++; fail:;\n\t\t}\n\t\tret = max(ret,num);\n\t}\n\tcout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef ___Geometry_Library\n#define ___Geometry_Library\n??\n// ------ Includes ------ //\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <algorithm>\n??\n// ------ Defines ------ //\ntypedef long double GType;\ntypedef std::complex<GType> Point;\ntypedef std::pair<Point, Point> Segment;\n??\n// ------ Constants ------ //\nconst GType EPS = 1.0e-10L;\n??\n// ------ Functions Level 1 ------ //\nGType dot(const Point& p1, const Point& p2) {\n\treturn (std::conj(p1) * p2).real();\n}\nGType cross(const Point& p1, const Point& p2) {\n\treturn (std::conj(p1) * p2).imag();\n}\nint ccw(const Point& p1, const Point& p2, const Point& p3) {\n\tPoint v1 = p2 - p1, v2 = p3 - p1;\n\tif (cross(v1, v2) > EPS) return +1;\n\tif (cross(v1, v2) < -EPS) return -1;\n\tif (dot(v1, v2) < -EPS) return +2;\n\tif (std::norm(v1) < std::norm(v2)) return -2;\n\treturn 0;\n}\n??\n// ------ Functions Level 2 ------ //\nbool intersect(const Segment& s1, const Point& p1, bool segflag) {\n\tif (!segflag) return std::abs(cross(s1.second - p1, s1.first - p1)) < EPS;\n\treturn (std::abs(s1.first - p1) + std::abs(s1.second - p1) - std::abs(s1.second - s1.first)) < EPS;\n}\nbool intersect(const Segment& s1, const Segment& s2, bool segflag) {\n\tif (!segflag) return cross(s1.second - s1.first, s2.first - s1.first) * cross(s1.second - s1.first, s2.second - s1.first) < EPS;\n\treturn (ccw(s1.first, s1.second, s2.first) * ccw(s1.first, s1.second, s2.second) < 0 && ccw(s2.first, s2.second, s1.first) * ccw(s2.first, s2.second, s1.second) < 0);\n}\nPoint crosspoint(const Segment& s1, const Segment& s2) {\n\tGType r1 = cross(s1.second - s1.first, s2.second - s2.first);\n\tGType r2 = cross(s1.second - s1.first, s1.second - s2.first);\n\tif (std::abs(r1) < EPS && std::abs(r2) < EPS) return s2.first;\n\treturn s2.first + r2 / r1 * (s2.second - s2.first);\n}\n??\n#endif\n??\n#include <vector>\n#include <iostream>\nusing namespace std;\nint N, M, r, x, y; vector<vector<Point> > v1; vector<Point> v2, v3;\nint main() {\n\tcin >> N >> M;\n\tv1.resize(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> r;\n\t\tfor (int j = 0; j < r; j++) {\n\t\t\tcin >> x >> y;\n\t\t\tv1[i].push_back(Point(x, y));\n\t\t}\n\t\tv3.insert(v3.end(), v1[i].begin(), v1[i].end());\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> x >> y;\n\t\tv2.push_back(Point(x, y));\n\t}\n\tint ret = 1;\n\tfor (int i1 = 0; i1 < M; i1++) {\n\t\tfor (int j1 = 0; j1 < v3.size(); j1++) {\n\t\t\tfor (int i2 = i1 + 1; i2 < M; i2++) {\n\t\t\t\tfor (int j2 = j1 + 1; j2 < v3.size(); j2++) {\n\t\t\t\t\tif (abs(cross(v2[i1] - v3[j1], v2[i2] - v3[j2])) > EPS) {\n\t\t\t\t\t\tPoint p1 = crosspoint(make_pair(v2[i1], v3[j1]), make_pair(v2[i2], v3[j2]));\n\t\t\t\t\t\tint res = 0;\n\t\t\t\t\t\tfor (int k = 0; k < M; k++) {\n\t\t\t\t\t\t\tbool ok = true;\n\t\t\t\t\t\t\tfor (int l1 = 0; l1 < N; l1++) {\n\t\t\t\t\t\t\t\tfor (int l2 = 0; l2 < v1[l1].size(); l2++) {\n\t\t\t\t\t\t\t\t\tif (intersect(make_pair(p1, v2[k]), make_pair(v1[l1][l2], v1[l1][(l2 + 1) % v1[l1].size()]), true)) ok = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (ok) res++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tret = max(ret, res);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < v3.size(); i++) {\n\t\tint res = 0;\n\t\tfor (int k = 0; k < M; k++) {\n\t\t\tbool ok = true;\n\t\t\tfor (int l1 = 0; l1 < N; l1++) {\n\t\t\t\tfor (int l2 = 0; l2 < v1[l1].size(); l2++) {\n\t\t\t\t\tPoint p2 = v1[l1][l2], p3 = v1[l1][(l2 + 1) % v1[l1].size()];\n\t\t\t\t\tif (v3[i] == p2 || v3[i] == p3) continue;\n\t\t\t\t\tif (intersect(make_pair(v3[i], v2[k]), make_pair(p2, p3), true)) ok = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ok) res++;\n\t\t}\n\t\tret = max(ret, res);\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ndouble eps = 0.0000001;\nstruct P {\n  double x, y;\n};\nstruct L {\n  P p1, p2;\n  double x() { return p2.x - p1.x; }\n  double y() { return p2.y - p1.y; }\n};\ndouble prod(L l1, L l2) { return l1.x() * l2.y() - l1.y() * l2.x(); }\npair<double, double> interP(L l1, L l2) {\n  double a = l1.x();\n  double b = -l2.x();\n  double c = l1.y();\n  double d = -l2.y();\n  double inv = 1. / (a * d - c * b);\n  double e1 = -l1.p1.x + l2.p1.x;\n  double e2 = -l1.p1.y + l2.p1.y;\n  return make_pair((d * e1 - b * e2) * inv, (-c * e1 + a * e2) * inv);\n}\nbool intersect(L l1, L l2) {\n  if (fabs(prod(l1, l2)) < eps) {\n    return false;\n  }\n  auto p = interP(l1, l2);\n  return eps < p.first && p.first < 1 - eps && eps < p.second &&\n         p.second < 1 - eps;\n}\nint main() {\n\n  int n, m;\n  cin >> n >> m;\n  vector<vector<P>> p(n);\n  for (int i = 0; i < n; i++) {\n    int l;\n    cin >> l;\n    for (int j = 0; j < l; j++) {\n      double x, y;\n      cin >> x >> y;\n      p[i].push_back(P{x, y});\n    }\n  }\n  vector<P> hum(m);\n  for (int i = 0; i < m; i++) {\n    cin >> hum[i].x >> hum[i].y;\n  }\n  vector<L> line;\n  for (int i = 0; i < m; i++) {\n    for (auto &poly : p) {\n      for (int j = 0; j < poly.size(); j++) {\n        line.push_back(L{hum[i], poly[j]});\n      }\n    }\n  }\n  vector<P> ps;\n  for (int i = 0; i < line.size(); i++)\n    for (int j = i + 1; j < line.size(); j++) {\n      if (fabs(prod(line[i], line[j])) < eps)\n        continue;\n      auto rs = interP(line[i], line[j]);\n      ps.push_back(P{line[i].p1.x + line[i].x() * rs.first,\n                     line[i].p1.y + line[i].y() * rs.first});\n    }\n\n  if (n == 0) {\n    cout << m << endl;\n    return 0;\n  }\n  if (m == 1) {\n    cout << 1 << endl;\n    return 0;\n  }\n\n  int ans = 0;\n  for (int i = 0; i < ps.size(); i++) {\n    int score = m;\n    for (int j = 0; j < m; j++) {\n      L l1{ps[i], hum[j]};\n      bool ng = false;\n\n      for (auto &poly : p) {\n        for (int k = 0; k < poly.size(); k++) {\n          P p1 = poly[k];\n          P p2 = poly[(k + 1) % poly.size()];\n          L l2{p1, p2};\n          if (intersect(l1, l2)) {\n            ng = true;\n          }\n        }\n      }\n\n      if (ng) {\n        score--;\n      }\n    }\n    ans = max(ans, score);\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nclass Point {\npublic:\n\tlong double px, py;\n\tPoint() : px(0), py(0) {};\n\tPoint(long double px_, long double py_) : px(px_), py(py_) {};\n\tbool operator==(const Point& p) const { return px == p.px && py == p.py; }\n\tbool operator!=(const Point& p) const { return px != p.px || py != p.py; }\n\tbool operator<(const Point& p) const { return px < p.px ? true : (px == p.px && py < p.py); }\n\tbool operator>(const Point& p) const { return px > p.px ? true : (px == p.px && py > p.py); }\n\tbool operator<=(const Point& p) const { return !(Point(px, py) > p); }\n\tbool operator>=(const Point& p) const { return !(Point(px, py) < p); }\n\tPoint operator+(const Point& p) const { return Point(px + p.px, py + p.py); }\n\tPoint operator-(const Point& p) const { return Point(px - p.px, py - p.py); }\n\tPoint operator/(long double d) const { return Point(px / d, py / d); }\n\tfriend Point operator*(const Point p, long double d) { return Point(p.px * d, p.py * d); }\n\tfriend Point operator*(long double d, const Point& p) { return p * d; }\n\tPoint& operator+=(const Point& p1) { px += p1.px, py += p1.py; return *this; }\n\tPoint& operator-=(const Point& p1) { px -= p1.px, py -= p1.py; return *this; }\n\tPoint& operator*=(long double d) { px *= d, py *= d; return *this; }\n\tPoint& operator/=(long double d) { px /= d, py /= d; return *this; }\n};\nstruct Line { Point p1, p2; };\nlong double norm(const Point& a) { return a.px * a.px + a.py * a.py; }\nlong double abs(const Point& a) { return sqrtl(norm(a)); }\nlong double dot(const Point& a, const Point& b) { return a.px * b.px + a.py * b.py; }\nlong double crs(const Point& a, const Point& b) { return a.px * b.py - a.py * b.px; }\nint ccw(const Point& p0, const Point& p1, const Point& p2) {\n\tPoint a = p1 - p0, b = p2 - p0;\n\tif (crs(a, b) > 1e-10) return 1;\n\tif (crs(a, b) < -1e-10) return -1;\n\tif (dot(a, b) < -1e-10) return 2;\n\tif (norm(a) < norm(b)) return -2;\n\treturn 0;\n}\nbool its(const Point& p1, const Point& p2, const Point& p3, const Point& p4) {\n\treturn (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nPoint crp(Line a, Line b) {\n\tPoint c = b.p2 - b.p1;\n\tlong double d1 = abs(crs(c, a.p1 - b.p1));\n\tlong double d2 = abs(crs(c, a.p2 - b.p1));\n\treturn a.p1 + (a.p2 - a.p1) * (d1 / (d1 + d2));\n}\nint n, m; vector<Point>x[10]; Point z[10];\nvector<Point>po;\nvector<Line>L, LNS;\nint main() {\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; i++) {\n\t\tint M; cin >> M;\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tPoint w; cin >> w.px >> w.py; x[i].push_back(w); po.push_back(w);\n\t\t}\n\t\tfor (int j = 0; j < M; j++)LNS.push_back(Line{ x[i][j],x[i][(j + 1) % M] });\n\t}\n\tint R = po.size();\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> z[i].px >> z[i].py;\n\t}\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < R; j++) {\n\t\t\tif (po[j].px == z[i].px && po[j].py == z[i].py)continue;\n\t\t\tL.push_back(Line{ po[j],z[i] });\n\t\t\tL.push_back(Line{ Point{ po[j].px + 1e-4,po[j].py },z[i] });\n\t\t\tL.push_back(Line{ Point{ po[j].px - 1e-4,po[j].py },z[i] });\n\t\t\tL.push_back(Line{ Point{ po[j].px,po[j].py + 1e-4 },z[i] });\n\t\t\tL.push_back(Line{ Point{ po[j].px,po[j].py - 1e-4 },z[i] });\n\t\t}\n\t}\n\tfor (int i = 0; i < po.size(); i++) {\n\t\tfor (int j = i + 1; j < po.size(); j++) {\n\t\t\tif (po[j].px == po[i].px && po[j].py == po[i].py)continue;\n\t\t\tL.push_back(Line{ po[i],po[j] });\n\t\t}\n\t}\n\tfor (int i = 0; i < LNS.size(); i++) {\n\t\tL.push_back(LNS[i]);\n\t}\n\tint maxn = 0;\n\tfor (int i = 0; i < L.size(); i++) {\n\t\tfor (int j = i + 1; j < L.size(); j++) {\n\t\t\tPoint WW = crp(L[i], L[j]);\n\t\t\tif (fabs(WW.px) >= 1e9 || fabs(WW.py) >= 1e9)continue;\n\t\t\t/*if (i == 0 && j == 60) {\n\t\t\t\tWW.px += 0.0l;\n\t\t\t}*/\n\t\t\tlong double L1 = (L[i].p1.px - L[i].p2.px) / (L[i].p1.py - L[i].p2.py); if (fabs(L1) >= 1e9)L1 = 1e9;\n\t\t\tlong double L2 = (L[j].p1.px - L[j].p2.px) / (L[j].p1.py - L[j].p2.py); if (fabs(L2) >= 1e9)L2 = 1e9;\n\t\t\tif (L1 == L2)continue;\n\t\t\tint cnt = 0;\n\t\t\tfor (int k = 0; k < m; k++) {\n\t\t\t\tif (WW.px == z[k].px && WW.py == z[k].py)continue;\n\t\t\t\tLine LN = Line{ WW,z[k] };\n\t\t\t\tint flag = 1;\n\t\t\t\tfor (int l = 0; l < LNS.size(); l++) {\n\t\t\t\t\tif (ccw(LNS[l].p1, LNS[l].p2, WW) == 0) { flag = 0; break; }\n\t\t\t\t\tif (its(LN.p1, LN.p2, LNS[l].p1, LNS[l].p2) == true) {\n\t\t\t\t\t\tflag = 0; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flag == 1) {\n\t\t\t\t\tcnt += flag;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*if (cnt == 3) {\n\t\t\t\tcout << WW.px << ' ' << WW.py << endl;\n\t\t\t}*/\n\t\t\tmaxn = max(maxn, cnt);\n\t\t}\n\t}\n\tcout << maxn << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <array>\nusing namespace std;\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nconst double PI = acos(-1);\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n#define X real()\n#define Y imag()\n\ntypedef complex<double> P;\ntypedef vector<P> VP;\nstruct L : array<P, 2>{\n    L(const P& a, const P& b){ at(0)=a; at(1)=b; }\n    L(){}\n};\n\nnamespace std{\n    bool operator < (const P& a, const P& b){\n        return !EQ(a.X,b.X) ? a.X<b.X : a.Y+EPS<b.Y;\n    }\n    bool operator == (const P& a, const P& b){\n        return abs(a-b) < EPS;\n    }\n}\n\ndouble dot(P a, P b){\n    return (conj(a)*b).X;\n}\ndouble cross(P a, P b){\n    return (conj(a)*b).Y;\n}\nint ccw(P a, P b, P c){\n    b -= a;\n    c -= a;\n    if(cross(b,c) > EPS) return +1; //ccw\n    if(cross(b,c) < -EPS) return -1; //cw\n    if(dot(b,c) < -EPS) return +2; //c-a-b\n    if(abs(c)-abs(b) > EPS) return -2; //a-b-c\n    return 0; //a-c-b\n}\n\nbool intersectSS(const L& a, const L& b){\n    return ( ccw(a[0],a[1],b[0]) *ccw(a[0],a[1],b[1]) <= 0 ) &&\n        ( ccw(b[0],b[1],a[0]) *ccw(b[0],b[1],a[1]) <= 0 );\n}\nbool intersectSP(const L& s, const P &p){\n    return abs(cross(s[0]-p, s[1]-p))<EPS  && dot(s[0]-p, s[1]-p)<EPS;\n}\n\nbool isParallel(const P &a, const P &b){\n    return abs(cross(a,b)) < EPS;\n}\nbool isParallel(const L &a, const L &b){\n    return isParallel(a[1]-a[0], b[1]-b[0]);\n}\n\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1]-l[0], m[1]-m[0]);\n  double B = cross(l[1]-l[0], l[1]-m[0]);\n  return m[0] + B/A *(m[1]-m[0]);\n}\n\nint in_poly(const P &p, const VP &poly){\n    int n = poly.size();\n    int ret = -1;\n    for(int i=0; i<n; i++){\n        P a = poly[i]-p;\n        P b = poly[(i+1)%n]-p;\n        if(a.Y > b.Y) swap(a,b);\n        if(intersectSP(L(a,b), P(0,0))) return 0;\n        if(a.Y<=0 && b.Y>0 && cross(a,b)<0) ret = -ret;\n    }\n    return ret;\n}\n\nbool isVisible(const L &l, const VP &poly){\n    int n = poly.size();\n    VP cp;\n    cp.push_back(l[0]);\n    cp.push_back(l[1]);\n    for(int i=0; i<n; i++){\n        L edge(poly[i], poly[(i+1)%n]);\n        if(!isParallel(l, edge) && intersectSS(l, edge)){\n            cp.push_back(crosspointLL(l, edge));\n        }\n    }\n    sort(cp.begin(), cp.end());\n    cp.erase(unique(cp.begin(), cp.end()), cp.end());\n    \n    bool ret = true;\n    for(int i=0; i<(int)cp.size()-1; i++){\n        if(in_poly((cp[i]+cp[i+1])/2.0, poly) > 0){\n            ret = false;\n            break;\n        }\n    }\n    return ret;\n}\n\nint main(){\n    int n,m;\n    cin >> n >> m;\n    vector<VP> poly(n);\n    for(int i=0; i<n; i++){\n        int l;\n        cin >> l;\n        poly[i].resize(l);\n        for(int j=0; j<l; j++){\n            double x,y;\n            cin >> x >> y;\n            poly[i][j] = P(x, y);\n        }\n    }\n    VP man(m);\n    for(int i=0; i<m; i++){\n        double x,y;\n        cin >> x >> y;\n        man[i] = P(x, y);\n    }\n\n    vector<L> ray;\n    for(P p: man){\n        for(VP &po: poly){\n            for(P v: po){\n                ray.push_back(L(p, v));\n            }\n        }\n    }\n    VP cand;\n    for(int i=0; i<(int)ray.size(); i++){\n        for(int j=i+1; j<(int)ray.size(); j++){\n            if(!isParallel(ray[i], ray[j])){\n                cand.push_back(crosspointLL(ray[i], ray[j]));\n            }\n        }\n    }\n\n    int ans = 0;\n    for(int i=0; i<(int)cand.size(); i++){\n        int sub = 0;\n        for(int j=0; j<m; j++){\n            bool canlook = true;\n            L ray(cand[i], man[j]);\n            for(int k=0; k<(int)poly.size(); k++){\n                if(!isVisible(ray, poly[k])){\n                    canlook = false;\n                    break;\n                }\n            }\n            if(canlook) sub++;\n        }\n        ans = max(ans, sub);\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n/* 基本要素 */\ntypedef complex<double> Point;\ntypedef pair<Point, Point> Line;\ntypedef vector<Point> VP;\nconst double PI = acos(-1);\nconst double EPS = 1e-8; // 許容誤差^2\nconst double INF = 1e9;\n#define X real()\n#define Y imag()\n// #define LE(n,m) ((n) < (m) + EPS)\n#define LE(n,m) ((n) - (m) < EPS)\n// #define GE(n,m) ((n) + EPS > (m))\n#define GE(n,m) (EPS > (m) - (n))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n// 頂点の順序（sortやmax_elementに必要）\nnamespace std {\n  bool operator<(const Point a, const Point b) {\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\n// 内積　dot(a,b) = |a||b|cosθ\ndouble dot(Point a, Point b) {\n  return a.X*b.X + a.Y*b.Y;\n}\n\n// 外積　cross(a,b) = |a||b|sinθ\ndouble cross(Point a, Point b) {\n  return a.X*b.Y - a.Y*b.X;\n}\n\n// 点の進行方向\n// !!! 誤差に注意 !!! (掛け算したものとかなり小さいものを比べているので)\nint ccw(Point a, Point b, Point c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n\n// 直線と点\nbool isecLP(Point a1, Point a2, Point b) {\n  return abs(ccw(a1, a2, b)) != 1;\n  // return EQ(cross(a2-a1, b-a1), 0); と等価\n}\n\n// 直線と直線\nbool isecLL(Point a1, Point a2, Point b1, Point b2) {\n  return !isecLP(a2-a1, b2-b1, 0) || isecLP(a1, b1, b2);\n}\n\n// 直線と線分\nbool isecLS(Point a1, Point a2, Point b1, Point b2) {\n  return cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS;\n}\n\n// 線分と線分\nbool isecSS(Point a1, Point a2, Point b1, Point b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n  ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n\n// 2直線の交点\nPoint crosspointLL(Point a1, Point a2, Point b1, Point b2) {\n  double d1 = cross(b2-b1, b1-a1);\n  double d2 = cross(b2-b1, a2-a1);\n  if (EQ(d1, 0) && EQ(d2, 0)) return a1;  // same line\n  assert(!EQ(d2, 0)); // 交点がない\n  return a1 + d1/d2 * (a2-a1);\n}\n\n// 多角形の内部判定\n// 点が領域内部なら1、境界上なら2、外部なら0を返す\nint inPolygon(const VP& ps, Point p) {\n  int n = ps.size();\n  bool in = false;\n  rep (i, n) {\n    Point a = ps[i] - p;\n    Point b = ps[(i + 1) % n] - p;\n    if (EQ(cross(a,b), 0) && LE(dot(a,b), 0)) return 2;\n    if (a.Y > b.Y) swap(a,b);\n    if ((a.Y*b.Y < 0 || (a.Y*b.Y < EPS && b.Y > EPS)) && LE(cross(a, b), 0)) in = !in;\n  }\n  return in;\n}\n\nPoint READ_P(){\n    int x,y;\n    cin >>x >>y;\n    return Point(x,y);\n}\n\nint main(){\n    int n,m;\n    cin >>n >>m;\n\n    vector<VP> obj(n);\n    rep(i,n){\n        int L;\n        cin >>L;\n        rep(j,L) obj[i].pb(READ_P());\n    }\n\n    VP tg(m);\n    rep(i,m) tg[i] = READ_P();\n\n    VP cand;\n    rep(i,n)for(Point p:obj[i]) cand.pb(p);\n\n    rep(i,n)rep(ii,obj[i].size())rep(j,n)rep(jj,obj[j].size()){\n        if(i==j && ii==jj) continue;\n        Point p = obj[i][ii], q = obj[j][jj];\n\n        rep(a,m)rep(b,m)if(a != b){\n            Point pp = tg[a], qq = tg[b];\n            if(isecLL(p,pp,q,qq)) cand.pb(crosspointLL(p,pp,q,qq));\n        }\n    }\n\n    auto inner = [&](Point q){\n        rep(i,n)if(inPolygon(obj[i],q)==1) return true;\n        return false;\n    };\n\n    int ans = 1;\n    for(Point p:cand){\n        if(inner(p)) continue;\n\n        int tmp = 0;\n        rep(i,m){\n            VP cps;\n            rep(j,n){\n                int L = obj[j].size();\n                rep(k,L){\n                    Point pp = obj[j][k], qq = obj[j][(k+1)%L];\n                    if(isecSS(p,tg[i],pp,qq)) cps.pb(crosspointLL(p,tg[i],pp,qq));\n                }\n            }\n            sort(all(cps));\n\n            int ok = 1;\n            int SZ = cps.size();\n            rep(j,SZ-1){\n                Point mid = (cps[j]+cps[j+1])*0.5;\n                if(inner(mid)) ok = 0;\n            }\n            tmp += ok;\n        }\n\n        ans = max(ans, tmp);\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\n \ntypedef double D;\nconst D EPS = 1e-8;\nstruct P {\n  D x, y;\n  P() {}\n  P(D x_, D y_) : x(x_), y(y_) {}\n};\nstruct L {\n  P a, b;\n  L() {}\n  L(P a_, P b_) : a(a_), b(b_) {}\n};\n \nint sgn(D a, D b) {\n  if(a < b - EPS) return -1;\n  if(a > b + EPS) return +1;\n  return 0;\n}\n \nP operator *(P a, D b) { return P(a.x * b, a.y * b); }\nP operator +(P a, P b) { return P(a.x + b.x, a.y + b.y); }\nP operator -(P a, P b) { return P(a.x - b.x, a.y - b.y); }\nP operator /(P a, D b) { return P(a.x / b, a.y / b); }\nD outp(P a, P b) { return a.x * b.y - a.y * b.x; }\nD inp(P a, P b) { return a.x*b.x + a.y*b.y; }\nD abs(P p) { return sqrt(inp(p, p)); }\nP vec(P st, P en) { return en - st; }\n \nint ccw(P a, P b, P c) {\n  b = vec(a, b);\n  c = vec(a, c);\n  if(sgn(outp(b, c), 0.0) > 0) return +1;\n  if(sgn(outp(b, c), 0.0) < 0) return -1;\n  if(sgn(inp(b, c), 0.0) < 0) return +2;\n  if(sgn(abs(b), abs(c)) < 0) return -2;\n  return 0;\n}\n \nbool iSS(L s, L t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) < 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) < 0;\n}\n \nP cLL(L l, L m) {\n  D d = outp(vec(m.a, m.b), vec(l.a, l.b));\n  return l.a + vec(l.a, l.b) * outp(vec(m.a, m.b), vec(l.a, m.b)) / d;\n}\n \ntypedef vector<P> Poly;\n \nbool is_intersect_poly_segment(const Poly &p, const L &s) {\n  REP(i,p.size()) {\n    L l(p[i], p[(i + 1) % p.size()]);\n    // if(s.a.x == 10 && s.a.y == 100) {\n    //   cerr << \"l = (\" << l.a.x << \",\" << l.a.y << \"), (\" << l.b.x << \",\" << l.b.y << \")\" << endl;\n    //   cerr << \"s = (\" << s.a.x << \",\" << s.a.y << \"), (\" << s.b.x << \",\" << s.b.y << \")\" << endl;\n    //   DEBUG(iSS(l, s));\n    // }\n    if(iSS(l, s)) return true;\n  }\n  return false;\n}\n \nbool isParallel(L m, L l) {\n  D d = outp(vec(m.a, m.b), vec(l.a, l.b));\n  return sgn(d, 0.0) == 0;\n}\n \nsigned main() {\n  ios::sync_with_stdio(false);\n  int N, M; cin >> N >> M;\n  vector<Poly> PS;\n  REP(i,N) {\n    int L; cin >> L;\n    Poly p;\n    REP(j,L) {\n      int x, y; cin >> x >> y;\n      p.emplace_back(x, y);\n    }\n    PS.push_back(p);\n  }\n  vector<P> V;\n  REP(i,M) {\n    int x, y; cin >> x >> y;\n    V.emplace_back(x, y);\n  }\n  int ans = 1;\n  // O(M^2 + N * 15 * M * N)\n  REP(i,M) {\n    for(int j = i + 1; j < M; ++j) {\n      REP(k,N) REP(l,PS[k].size()) {\n        REP(k2,N) REP(l2,PS[k2].size()) {\n          L a(V[i], PS[k][l]), b(V[j], PS[k2][l2]);\n          if(isParallel(a, b)) continue;\n          P cross_point = cLL(a, b);\n          // cerr << \"cross_point = (\" << cross_point.x << \",\" << cross_point.y << \")\" << endl;\n          int cnt = 0;\n          REP(m,M) {\n            L line(cross_point, V[m]);\n            bool valid = true;\n            REP(n,N) {\n              // if(cross_point.x == 10 && cross_point.y == 100) {\n              //   DEBUG(n);\n              //   DEBUG(is_intersect_poly_segment(PS[n], line));\n              // }\n              if(is_intersect_poly_segment(PS[n], line)) valid = false;\n            }\n            if(valid) cnt++;\n          }\n          ans = max(ans, cnt);\n          // if(cnt == 2) {\n          //   cerr << \"cross_point = (\" << cross_point.x << \",\" << cross_point.y << \")\" << endl;\n          // }\n        }\n      }\n    }\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst double EPS = 1e-8, PI = acos(-1);\n\ninline bool eq(double a, double b)\n{\n  return abs(b - a) < EPS;\n}\n\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\nenum { OUT, ON, IN };\nnamespace Geometory\n{\n  struct Point\n  {\n    double x, y;\n\n    Point()\n    {\n    };\n\n    Point(double x, double y) : x(x), y(y)\n    {\n    };\n\n    Point operator+(const Point& b) const\n    {\n      return Point(x + b.x, y + b.y);\n    }\n\n    Point operator-(const Point& b) const\n    {\n      return Point(x - b.x, y - b.y);\n    }\n\n    Point operator*(const double b) const\n    {\n      return Point(x * b, y * b);\n    }\n\n    Point operator*(const Point& b) const\n    {\n      return Point(x * b.x - y * b.y, x * b.y + y * b.x);\n    }\n\n    Point operator/(const double b) const\n    {\n      return Point(x / b, y / b);\n    }\n\n    bool operator<(const Point& b) const\n    {\n      return x != b.x ? x < b.x : y < b.y;\n    }\n\n    bool operator==(const Point& b) const\n    {\n      return eq(x, b.x) && eq(y, b.y);\n    }\n\n    double norm()\n    {\n      return x * x + y * y;\n    }\n\n    double arg()\n    {\n      return atan2(x, y);\n    }\n\n    double abs()\n    {\n      return sqrt(norm());\n    }\n\n    Point rotate(double theta)\n    {\n      return Point(cos(theta) * x - sin(theta) * y, sin(theta) * x + cos(theta) * y);\n    }\n\n    Point rotate90()\n    {\n      return Point(-y, x);\n    }\n\n    friend ostream& operator<<(ostream& os, Point& p)\n    {\n      return os << \"(\" << p.x << \",\" << p.y << \")\";\n    }\n\n    friend istream& operator>>(istream& is, Point& a)\n    {\n      return is >> a.x >> a.y;\n    }\n  };\n\n  struct Line\n  {\n    Point a, b;\n\n    Line()\n    {\n    };\n\n    Line(Point a, Point b) : a(a), b(b)\n    {\n    };\n\n    friend ostream& operator<<(ostream& os, Line& p)\n    {\n      return os << \"(\" << p.a.x << \",\" << p.a.y << \") to (\" << p.b.x << \",\" << p.b.y << \")\";\n    }\n\n    friend istream& operator>>(istream& is, Line& a)\n    {\n      return is >> a.a.x >> a.a.y >> a.b.x >> a.b.y;\n    }\n  };\n\n  struct Segment\n  {\n    Point a, b;\n\n    Segment()\n    {\n    };\n\n    Segment(Point a, Point b) : a(a), b(b)\n    {\n    };\n\n    friend ostream& operator<<(ostream& os, Segment& p)\n    {\n      return os << \"(\" << p.a.x << \",\" << p.a.y << \") to (\" << p.b.x << \",\" << p.b.y << \")\";\n    }\n\n    friend istream& operator>>(istream& is, Segment& a)\n    {\n      return is >> a.a.x >> a.a.y >> a.b.x >> a.b.y;\n    }\n  };\n\n  typedef vector< Point > Polygon;\n  typedef vector< Segment > Segments;\n  typedef vector< Line > Lines;\n  typedef pair< Point, Point > PointPoint;\n\n  double cross(const Point& a, const Point& b)\n  {\n    return a.x * b.y - a.y * b.x;\n  }\n\n  double dot(const Point& a, const Point& b)\n  {\n    return a.x * b.x + a.y * b.y;\n  }\n\n  int ccw(const Point& a, Point b, Point c)\n  {\n    b = b - a, c = c - a;\n    if(cross(b, c) > EPS) return +1;  // a ??? b ??§ ???????¨??????????????????? c\n    if(cross(b, c) < -EPS) return -1; // a ??? b ??§ ????¨??????????????????? c\n    if(dot(b, c) < 0) return +2;  // c -- a -- b??§?????´??????\n    if(b.norm() < c.norm()) return -2; // a -- b -- c??§?????´??????\n    return 0;  // a -- c -- b??§?????´??????\n  }\n\n  Point Projection(const Line& l, const Point& p)\n  {\n    double t = dot(p - l.a, l.a - l.b) / (l.a - l.b).norm();\n    return l.a + (l.a - l.b) * t;\n  }\n\n  Point Projection(const Segment& l, const Point& p)\n  {\n    double t = dot(p - l.a, l.a - l.b) / (l.a - l.b).norm();\n    return l.a + (l.a - l.b) * t;\n  }\n\n  Point Reflection(const Line& l, const Point& p)\n  {\n    return p + (Projection(l, p) - p) * 2.0;\n  }\n\n  double Distance(const Line& l, const Point& p)\n  { //OK\n    return (p - Projection(l, p)).abs();\n  }\n\n  bool Intersect(const Line& l, const Line& m)\n  {\n    return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n  }\n\n  bool Intersect(const Line& l, const Segment& s)\n  {\n    return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n  }\n\n  bool Intersect(const Line& l, const Point& p)\n  {\n    return abs(ccw(l.a, l.b, p)) != -1;\n  }\n\n  bool Intersect(const Segment& s, const Segment& t)\n  {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n  }\n\n  bool Intersect(const Segment& s, const Point& p)\n  {\n    return ccw(s.a, s.b, p) == 0;\n  }\n\n  Point Crosspoint(const Segment& l, const Segment& m)\n  { //OK\n    double A = cross(l.b - l.a, m.b - m.a);\n    double B = cross(l.b - l.a, l.b - m.a);\n    if(abs(A) < EPS && abs(B) < EPS) return m.a; // same line\n    return m.a + (m.b - m.a) * B / A;\n  }\n\n  Point Crosspoint(const Line& l, const Line& m)\n  { //OK\n    double A = cross(l.b - l.a, m.b - m.a);\n    double B = cross(l.b - l.a, l.b - m.a);\n    if(abs(A) < EPS && abs(B) < EPS) return m.a;\n    return m.a + (m.b - m.a) * B / A;\n  }\n};\n\nint main()\n{\n  int N, M;\n\n  cin >> N >> M;\n\n  vector< Geometory::Polygon > polygons(N);\n  for(int i = 0; i < N; i++) {\n    int L;\n    cin >> L;\n    polygons[i].resize(L);\n    for(int j = 0; j < L; j++) {\n      cin >> polygons[i][j];\n    }\n  }\n\n  vector< Geometory::Point > points(M);\n  for(int i = 0; i < M; i++) {\n    cin >> points[i];\n  }\n\n  vector< Geometory::Line > lines;\n  for(int i = 0; i < M; ++i) {\n    for(int j = 0; j < N; ++j) {\n      for(int l = 0; l < polygons[j].size(); ++l) {\n        lines.emplace_back(Geometory::Line(points[i], polygons[j][l]));\n      }\n    }\n  }\n\n  int ret = 1;\n  for(int i = 0; i < lines.size(); ++i) {\n    for(int j = 0; j < i; ++j) {\n      if(Geometory::Intersect(lines[i], lines[j])) {\n        auto pp = Geometory::Crosspoint(lines[i], lines[j]);\n        int cost = 0;\n        for(int m = 0; m < M; m++) {\n          auto seg = Geometory::Segment(pp, points[m]);\n          bool iscross = false;\n          for(int n = 0; n < N; n++) {\n            for(int o = 0; o < polygons[n].size(); o++) {\n              if(Geometory::Intersect(Geometory::Segment(curr(polygons[n], o), next(polygons[n], o)), seg)) {\n                auto qq = Geometory::Crosspoint(Geometory::Segment(curr(polygons[n], o), next(polygons[n], o)), seg);\n                if(curr(polygons[n], o) == qq) continue;\n                if(next(polygons[n], o) == qq) continue;\n                if(seg.a == qq || seg.b == qq) continue;\n                iscross = true;\n              }\n            }\n          }\n          cost += iscross ^ 1;\n        }\n        ret = max(ret, cost);\n      }\n    }\n  }\n\n  cout << ret << endl;\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.container;\nimport std.conv;\nimport std.math;\nimport std.numeric;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nvoid log(A...)(A arg) {\n    stderr.writeln(arg);\n}\nint size(T)(in T s) {\n    return cast(int)s.length;\n}\n\nimmutable real EPS = 1e-7;\n\nstruct Point {\n    real x, y;\n    Point opBinary(string op)(in Point p) const if (op == \"+\" || op == \"-\") {\n        return Point(mixin(\"x\" ~ op ~ \"p.x\"), mixin(\"y\" ~ op ~ \"p.y\"));\n    }\n    Point opBinary(string op)(real k) const if (op == \"*\" || op == \"/\") {\n        return Point(mixin(\"x\" ~ op ~ \"k\"), mixin(\"y\" ~ op ~ \"k\"));\n    }\n};\nreal dot(in Point a, in Point b) { return a.x * b.x + a.y * b.y; }\nreal cross(in Point a, in Point b) { return a.x * b.y - a.y * b.x; }\nreal norm(in Point a) { return sqrt(dot(a, a)); }\nPoint rot90(in Point p) { return Point(-p.y, p.x); }\nreal angle(in Point a) { return atan2(a.y, a.x); }\n\nint ccw(Point a, Point b, Point c){\n    b = b - a; c = c - a;\n    if (cross(b, c) > EPS) return +1; \n    if (cross(b, c) < -EPS) return -1;\n    if (dot(b, c) < 0) return +2;     \n    if (norm(b) < norm(c)) return -2; \n    return 0;                         \n}\n\nstruct Segment {\n    Point a, b;\n};\nbool intersects(in Segment s, in Segment t) {\n    // endpoint exclusive\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) < 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) < 0;\n}\n\nstruct Line {\n    Point a, b;\n};\nbool contains(in Line l, in Point p) { return ccw(l.a, l.b, p) % 2 == 0; }\nbool parallel(in Line s, in Line t) { return abs(cross(s.b - s.a, t.b - t.a)) < EPS; }\nbool orthogonal(in Line s, in Line t) { return abs(dot(s.b - s.a, t.b - t.a)) < EPS; }\nbool equals(in Line s, in Line t) { return parallel(s, t) && contains(s, t.a); }\nPoint crosspoint(in Line s, in Line t) {\n    real d = cross(t.b - t.a, s.b - s.a);\n    assert(abs(d) >= EPS);\n    return s.a + (s.b - s.a) * cross(t.b - t.a, t.b - s.a) / d;\n}\n\nvoid main() {\n    int N, M; readf(\"%s %s\\n\", &N, &M);\n    Point[][] P = new Point[][N];\n    foreach (i; 0 .. N) {\n        int L; readf(\"%s\\n\", &L);\n        P[i] = new Point[L];\n        foreach (ref p; P[i]) {\n            readf(\"%s %s\\n\", &p.x, &p.y);\n        }\n    }\n    Point[] X = new Point[M];\n    foreach (ref p; X) {\n        readf(\"%s %s\\n\", &p.x, &p.y);\n    }\n\n    //log(X);\n\n    Line[] ls;\n    foreach (x; X) {\n        foreach (ps; P) {\n            foreach (p; ps) {\n                ls ~= Line(x, p);\n            }\n        }\n    }\n    //log(ls);\n    Point[] cands;\n    foreach (i, l; ls) {\n        foreach (j, m; ls[i + 1 .. $]) {\n            if (parallel(l, m)) continue;\n            cands ~= crosspoint(l, m);\n        }\n    }\n\n    int count(in Point z) { // how many voters can see the candidate standing at z\n        int ans = 0;\n        foreach (x; X) {\n            auto s = Segment(z, x);\n            foreach (ps; P) {\n                int N = ps.size;\n                foreach (i; 0 .. N) {\n                    auto t = Segment(ps[i], ps[(i + 1) % N]);\n                    if (s.intersects(t)) goto next; // voter at x cannot see the candidate\n                }\n            }\n            ans++;\n            next:;\n        }\n        return ans;\n    }\n    int ans = 0;\n    foreach (z; cands) {\n        ans = max(ans, count(z));\n    }\n    writeln(ans);\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.container;\nimport std.conv;\nimport std.math;\nimport std.numeric;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nvoid log(A...)(A arg) {\n    stderr.writeln(arg);\n}\nint size(T)(in T s) {\n    return cast(int)s.length;\n}\n\nimmutable real EPS = 1e-7;\n\nstruct Point {\n    real x, y;\n    Point opBinary(string op)(in Point p) const if (op == \"+\" || op == \"-\") {\n        return Point(mixin(\"x\" ~ op ~ \"p.x\"), mixin(\"y\" ~ op ~ \"p.y\"));\n    }\n    Point opBinary(string op)(real k) const if (op == \"*\" || op == \"/\") {\n        return Point(mixin(\"x\" ~ op ~ \"k\"), mixin(\"y\" ~ op ~ \"k\"));\n    }\n};\nreal dot(in Point a, in Point b) { return a.x * b.x + a.y * b.y; }\nreal cross(in Point a, in Point b) { return a.x * b.y - a.y * b.x; }\nreal norm(in Point a) { return sqrt(dot(a, a)); }\nPoint rot90(in Point p) { return Point(-p.y, p.x); } // ?????´????????\\?±???§??????90?????????????????¢ \nreal angle(in Point a) { return atan2(a.y, a.x); } // x????????§??????????????¨??\\?±???§????????´???????§?????§??¢?????????????????¢???????????§????????????a???????????±?????????\nint ccw(Point a, Point b, Point c){\n    b = b - a; c = c - a;\n    if (cross(b, c) > EPS) return +1;      // a,b,c???????¬????????????´????????\\?????§???    if (cross(b, c) < -EPS) return -1;     // a,b,c???????¬???????????????¨??\\?????§???    if (dot(b, c) < 0) return +2;          // c--a--b ??¶??´??±???    if (norm(b) < norm(c)) return -2;      // a--b--c ??¶??´??±???    return 0;                              // a--c--b ??¶??´??±???}\n\nstruct Segment {\n    Point a, b;\n};\nbool intersects(in Segment s, in Segment t) {\n    // endpoint exclusive\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) < 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) < 0;\n}\n\nstruct Line {\n    Point a, b;\n};\nbool contains(in Line l, in Point p) { return ccw(l.a, l.b, p) % 2 == 0; }\nbool parallel(in Line s, in Line t) { return abs(cross(s.b - s.a, t.b - t.a)) < EPS; }\nbool orthogonal(in Line s, in Line t) { return abs(dot(s.b - s.a, t.b - t.a)) < EPS; }\nbool equals(in Line s, in Line t) { return parallel(s, t) && contains(s, t.a); }\nPoint crosspoint(in Line s, in Line t) {\n    real d = cross(t.b - t.a, s.b - s.a);\n    assert(abs(d) >= EPS);\n    return s.a + (s.b - s.a) * cross(t.b - t.a, t.b - s.a) / d;\n}\n\nvoid main() {\n    int N, M; readf(\"%s %s\\n\", &N, &M);\n    Point[][] P = new Point[][N];\n    foreach (i; 0 .. N) {\n        int L; readf(\"%s\\n\", &L);\n        P[i] = new Point[L];\n        foreach (ref p; P[i]) {\n            readf(\"%s %s\\n\", &p.x, &p.y);\n        }\n    }\n    Point[] X = new Point[M];\n    foreach (ref p; X) {\n        readf(\"%s %s\\n\", &p.x, &p.y);\n    }\n\n    //log(X);\n\n    Line[] ls;\n    foreach (x; X) {\n        foreach (ps; P) {\n            foreach (p; ps) {\n                ls ~= Line(x, p);\n            }\n        }\n    }\n    //log(ls);\n    Point[] cands;\n    foreach (i, l; ls) {\n        foreach (j, m; ls[i + 1 .. $]) {\n            if (parallel(l, m)) continue;\n            cands ~= crosspoint(l, m);\n        }\n    }\n\n    int count(in Point z) { // how many voters can see the candidate standing at z\n        int ans = 0;\n        foreach (x; X) {\n            auto s = Segment(z, x);\n            foreach (ps; P) {\n                int N = ps.size;\n                foreach (i; 0 .. N) {\n                    auto t = Segment(ps[i], ps[(i + 1) % N]);\n                    if (s.intersects(t)) goto next; // voter at x cannot see the candidate\n                }\n            }\n            ans++;\n            next:;\n        }\n        return ans;\n    }\n    int ans = 0;\n    foreach (z; cands) {\n        ans = max(ans, count(z));\n    }\n    writeln(ans);\n}"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\ndef cross3(p0, p1, q0):\n    return (p1[0] - p0[0])*(q0[1] - p0[1]) - (p1[1] - p0[1])*(q0[0] - p0[0])\ndef cross_point(p0, p1, q0, q1):\n    x0, y0 = p0; x1, y1 = p1\n    x2, y2 = q0; x3, y3 = q1\n    dx0 = x1 - x0\n    dy0 = y1 - y0\n    dx1 = x3 - x2\n    dy1 = y3 - y2\n\n    s = (y0-y2)*dx1 - (x0-x2)*dy1\n    sm = dx0*dy1 - dy0*dx1\n    if sm < 0:\n        return -(x0*sm + s*dx0), -(y0*sm + s*dy0), -sm\n    return x0*sm + s*dx0, y0*sm + s*dy0, sm\ndef solve():\n    N, M = map(int, readline().split())\n    PSS = []\n    for i in range(N):\n        L = int(readline())\n        PS = [list(map(int, readline().split())) for i in range(L)]\n        PSS.append(PS)\n    QS = [list(map(int, readline().split())) for i in range(M)]\n    LS = []\n    for PS in PSS:\n        for x0, y0 in PS:\n            for x1, y1 in QS:\n                LS.append(((x0, y0), (x1, y1)))\n    def check(p, q, r):\n        p0 = (p, q)\n        res = 0\n        PSS1 = [[(x*r, y*r) for x, y in PS] for PS in PSS]\n        for x1, y1 in QS:\n            x1 *= r; y1 *= r\n            q0 = (x1, y1)\n            for PS in PSS1:\n                l = len(PS)\n                for i in range(l):\n                    p1 = PS[i-1]; q1 = PS[i]\n                    C0 = cross3(p0, q0, p1)\n                    C1 = cross3(p0, q0, q1)\n                    D0 = cross3(p1, q1, p0)\n                    D1 = cross3(p1, q1, q0)\n                    if C0 * C1 < 0 and D0 * D1 < 0:\n                        break\n                else:\n                    continue\n                break\n            else:\n                res += 1\n        return res\n\n    ans = 0\n    K = len(LS)\n    for i in range(K):\n        p0, p1 = LS[i]\n        for j in range(i):\n            q0, q1 = LS[j]\n            p, q, r = cross_point(p0, p1, q0, q1)\n            if r == 0:\n                continue\n            ans = max(ans, check(p, q, r))\n    write(\"%d\\n\" % ans)\nsolve()\n"
  }
]