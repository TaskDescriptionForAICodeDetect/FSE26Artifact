[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n\n#define MAX_N 100\n#define MAX_M 1000\n#define MAX_VERTICES 100\n\ntypedef struct {\n    double x, y;\n} Point;\n\ntypedef struct {\n    Point vertices[MAX_VERTICES];\n    int vertexCount;\n} Polygon;\n\nPoint voters[MAX_M];\nPolygon obstacles[MAX_N];\nint numObstacles, numVoters;\n\nbool lineIntersectsPolygon(Point start, Point end, Polygon poly) {\n    for (int i = 0; i < poly.vertexCount; i++) {\n        Point curr = poly.vertices[i];\n        Point next = poly.vertices[(i + 1) % poly.vertexCount];\n        \n        if (doLineSegmentsIntersect(start, end, curr, next))\n            return true;\n    }\n    return false;\n}\n\nbool canSeeVoter(Point candidate, Point voter) {\n    for (int i = 0; i < numObstacles; i++) {\n        if (lineIntersectsPolygon(candidate, voter, obstacles[i]))\n            return false;\n    }\n    return true;\n}\n\nint countVisibleVoters(Point candidate) {\n    int visibleCount = 0;\n    for (int i = 0; i < numVoters; i++) {\n        if (canSeeVoter(candidate, voters[i]))\n            visibleCount++;\n    }\n    return visibleCount;\n}\n\nPoint findBestLocation() {\n    Point bestLocation = {0, 0};\n    int maxVisibleVoters = 0;\n\n    // Brute force search through potential locations\n    for (double x = -1000; x <= 1000; x += 10) {\n        for (double y = -1000; y <= 1000; y += 10) {\n            Point candidate = {x, y};\n            int visibleVoters = countVisibleVoters(candidate);\n            \n            if (visibleVoters > maxVisibleVoters) {\n                maxVisibleVoters = visibleVoters;\n                bestLocation = candidate;\n            }\n        }\n    }\n\n    return bestLocation;\n}\n\nint main() {\n    // Input obstacles and voters\n    scanf(\"%d %d\", &numObstacles, &numVoters);\n\n    // Read obstacles\n    for (int i = 0; i < numObstacles; i++) {\n        scanf(\"%d\", &obstacles[i].vertexCount);\n        for (int j = 0; j < obstacles[i].vertexCount; j++) {\n            scanf(\"%lf %lf\", &obstacles[i].vertices[j].x, &obstacles[i].vertices[j].y);\n        }\n    }\n\n    // Read voters\n    for (int i = 0; i < numVoters; i++) {\n        scanf(\"%lf %lf\", &voters[i].x, &voters[i].y);\n    }\n\n    Point bestLocation = findBestLocation();\n    int maxVisibleVoters = countVisibleVoters(bestLocation);\n\n    printf(\"Best Location: (%.2f, %.2f)\\n\", bestLocation.x, bestLocation.y);\n    printf(\"Maximum Visible Voters: %d\\n\", maxVisibleVoters);\n\n    return 0;\n}\n\n// Helper function for line segment intersection (not fully implemented)\nbool doLineSegmentsIntersect(Point p1, Point p2, Point p3, Point p4) {\n    // Implement line segment intersection logic here\n    return false;\n}",
    "timestamp": "2025-08-05 21:56:15"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <stdbool.h>\n\ntypedef struct {\n    double x, y;\n} Point;\n\ntypedef struct {\n    int n;\n    Point *vertices;\n} Polygon;\n\ntypedef struct {\n    int m;\n    Point *points;\n} Voters;\n\nint max_voters = 0;\n\ndouble cross_product(Point a, Point b, Point c) {\n    return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n}\n\nbool on_segment(Point a, Point b, Point c) {\n    return (c.x >= fmin(a.x, b.x) && c.x <= fmax(a.x, b.x)) &&\n           (c.y >= fmin(a.y, b.y) && c.y <= fmax(a.y, b.y));\n}\n\nbool segments_intersect(Point p1, Point p2, Point p3, Point p4) {\n    double d1 = cross_product(p3, p4, p1);\n    double d2 = cross_product(p3, p4, p2);\n    double d3 = cross_product(p1, p2, p3);\n    double d4 = cross_product(p1, p2, p4);\n\n    if (((d1 > 0 && d2 < 0) || (d1 < 0 && d2 > 0)) &&\n        ((d3 > 0 && d4 < 0) || (d3 < 0 && d4 > 0))) {\n        return true;\n    }\n\n    if (d1 == 0 && on_segment(p3, p4, p1)) return true;\n    if (d2 == 0 && on_segment(p3, p4, p2)) return true;\n    if (d3 == 0 && on_segment(p1, p2, p3)) return true;\n    if (d4 == 0 && on_segment(p1, p2, p4)) return true;\n\n    return false;\n}\n\nbool point_in_polygon(Point p, Polygon poly) {\n    bool inside = false;\n    for (int i = 0, j = poly.n - 1; i < poly.n; j = i++) {\n        if (((poly.vertices[i].y > p.y) != (poly.vertices[j].y > p.y)) &&\n            (p.x < (poly.vertices[j].x - poly.vertices[i].x) * (p.y - poly.vertices[i].y) / \n                   (poly.vertices[j].y - poly.vertices[i].y) + poly.vertices[i].x)) {\n            inside = !inside;\n        }\n    }\n    return inside;\n}\n\nbool is_visible(Point x, Point voter, Polygon *obstacles, int N) {\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < obstacles[i].n; j++) {\n            int k = (j + 1) % obstacles[i].n;\n            if (segments_intersect(x, voter, obstacles[i].vertices[j], obstacles[i].vertices[k])) {\n                return false;\n            }\n        }\n        if (point_in_polygon(voter, obstacles[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid count_visible(Point x, Voters voters, Polygon *obstacles, int N) {\n    int count = 0;\n    for (int i = 0; i < voters.m; i++) {\n        if (is_visible(x, voters.points[i], obstacles, N)) {\n            count++;\n        }\n    }\n    if (count > max_voters) {\n        max_voters = count;\n    }\n}\n\nvoid try_points(Point *points, int num_points, Voters voters, Polygon *obstacles, int N) {\n    for (int i = 0; i < num_points; i++) {\n        count_visible(points[i], voters, obstacles, N);\n    }\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    Polygon *obstacles = malloc(N * sizeof(Polygon));\n    for (int i = 0; i < N; i++) {\n        int K;\n        scanf(\"%d\", &K);\n        obstacles[i].n = K;\n        obstacles[i].vertices = malloc(K * sizeof(Point));\n        for (int j = 0; j < K; j++) {\n            scanf(\"%lf %lf\", &obstacles[i].vertices[j].x, &obstacles[i].vertices[j].y);\n        }\n    }\n\n    Voters voters;\n    voters.m = M;\n    voters.points = malloc(M * sizeof(Point));\n    for (int i = 0; i < M; i++) {\n        scanf(\"%lf %lf\", &voters.points[i].x, &voters.points[i].y);\n    }\n\n    max_voters = 0;\n    try_points(voters.points, M, voters, obstacles, N);\n\n    printf(\"%d\\n\", max_voters);\n\n    for (int i = 0; i < N; i++) {\n        free(obstacles[i].vertices);\n    }\n    free(obstacles);\n    free(voters.points);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:57:02"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <limits>\n\nusing namespace std;\n\nconst double EPS = 1e-8;\n\nstruct Point {\n    double x, y;\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n};\n\ntypedef vector<Point> Polygon;\n\nint ccw(const Point &a, const Point &b, const Point &c) {\n    double cross = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n    if (abs(cross) < EPS) return 0;\n    return cross > 0 ? 1 : -1;\n}\n\nbool onSegment(const Point &p, const Point &a, const Point &b) {\n    if (abs(ccw(p, a, b)) != 0) return false;\n    return min(a.x, b.x) - EPS <= p.x && p.x <= max(a.x, b.x) + EPS &&\n           min(a.y, b.y) - EPS <= p.y && p.y <= max(a.y, b.y) + EPS;\n}\n\nbool segmentsIntersect(const Point &a1, const Point &a2, const Point &b1, const Point &b2) {\n    int ccw1 = ccw(a1, a2, b1);\n    int ccw2 = ccw(a1, a2, b2);\n    int ccw3 = ccw(b1, b2, a1);\n    int ccw4 = ccw(b1, b2, a2);\n\n    if ((ccw1 * ccw2 < 0) && (ccw3 * ccw4 < 0)) return true;\n    if (onSegment(a1, b1, b2) || onSegment(a2, b1, b2) ||\n        onSegment(b1, a1, a2) || onSegment(b2, a1, a2))\n        return true;\n    return false;\n}\n\nbool isPointInsidePolygon(const Point &p, const Polygon &poly) {\n    int n = poly.size();\n    if (n < 3) return false;\n\n    Point far(1e9, p.y + 1);\n    int cnt = 0;\n    for (int i = 0; i < n; ++i) {\n        int j = (i + 1) % n;\n        if (onSegment(p, poly[i], poly[j])) return true;\n        if (segmentsIntersect(p, far, poly[i], poly[j])) cnt++;\n    }\n    return cnt % 2 == 1;\n}\n\nbool isVisible(const Point &x, const Point &voter, const vector<Polygon> &obstacles) {\n    for (const Polygon &poly : obstacles) {\n        if (isPointInsidePolygon(voter, poly) || isPointInsidePolygon(x, poly))\n            return false;\n        for (int i = 0; i < poly.size(); ++i) {\n            int j = (i + 1) % poly.size();\n            if (segmentsIntersect(x, voter, poly[i], poly[j]))\n                return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    vector<Polygon> obstacles(N);\n    for (int i = 0; i < N; ++i) {\n        int K;\n        cin >> K;\n        obstacles[i].resize(K);\n        for (int j = 0; j < K; ++j) {\n            cin >> obstacles[i][j].x >> obstacles[i][j].y;\n        }\n    }\n\n    vector<Point> voters(M);\n    for (int i = 0; i < M; ++i) {\n        cin >> voters[i].x >> voters[i].y;\n    }\n\n    int max_visible = 0;\n    for (const Point &x : voters) {\n        int visible = 0;\n        for (const Point &v : voters) {\n            if (isVisible(x, v, obstacles)) {\n                visible++;\n            }\n        }\n        if (visible > max_visible) {\n            max_visible = visible;\n        }\n    }\n\n    cout << max_visible << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:58:03"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.awt.geom.Path2D;\nimport java.awt.geom.Point2D;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class ElectionSpeechLocation {\n\n    static class Point {\n        double x, y;\n        Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    static class Polygon {\n        List<Point> points;\n        Polygon(List<Point> points) {\n            this.points = points;\n        }\n    }\n\n    public static boolean isLineIntersectingPolygon(Point p1, Point p2, Polygon polygon) {\n        Line2D line = new Line2D.Double(p1.x, p1.y, p2.x, p2.y);\n        Path2D path = new Path2D.Double();\n        Point first = polygon.points.get(0);\n        path.moveTo(first.x, first.y);\n        for (int i = 1; i < polygon.points.size(); i++) {\n            Point p = polygon.points.get(i);\n            path.lineTo(p.x, p.y);\n        }\n        path.closePath();\n\n        if (path.contains(p1.x, p1.y) || path.contains(p2.x, p2.y)) {\n            return true;\n        }\n\n        for (int i = 0; i < polygon.points.size(); i++) {\n            Point a = polygon.points.get(i);\n            Point b = polygon.points.get((i + 1) % polygon.points.size());\n            Line2D polyEdge = new Line2D.Double(a.x, a.y, b.x, b.y);\n            if (line.intersectsLine(polyEdge)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static int maxVisibleVoters(Point[] voters, Polygon[] obstacles, Point speechPoint) {\n        int maxCount = 0;\n        for (Point voter : voters) {\n            boolean visible = true;\n            for (Polygon obstacle : obstacles) {\n                if (isLineIntersectingPolygon(speechPoint, voter, obstacle)) {\n                    visible = false;\n                    break;\n                }\n            }\n            if (visible) {\n                maxCount++;\n            }\n        }\n        return maxCount;\n    }\n\n    public static int findBestLocation(Point[] voters, Polygon[] obstacles, List<Point> candidatePoints) {\n        int maxVoters = 0;\n        for (Point candidate : candidatePoints) {\n            int current = maxVisibleVoters(voters, obstacles, candidate);\n            if (current > maxVoters) {\n                maxVoters = current;\n            }\n        }\n        return maxVoters;\n    }\n\n    public static void main(String[] args) {\n        // Example usage\n        Point[] voters = {\n            new Point(1, 1),\n            new Point(3, 3),\n            new Point(5, 5)\n        };\n\n        List<Point> obstacle1Points = new ArrayList<>();\n        obstacle1Points.add(new Point(2, 2));\n        obstacle1Points.add(new Point(2, 4));\n        obstacle1Points.add(new Point(4, 4));\n        obstacle1Points.add(new Point(4, 2));\n        Polygon[] obstacles = {\n            new Polygon(obstacle1Points)\n        };\n\n        List<Point> candidatePoints = new ArrayList<>();\n        candidatePoints.add(new Point(0, 0));\n        candidatePoints.add(new Point(6, 6));\n        candidatePoints.add(new Point(3, 0));\n\n        int result = findBestLocation(voters, obstacles, candidatePoints);\n        System.out.println(result);\n    }\n}",
    "timestamp": "2025-08-05 21:58:34"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\n\nclass StreetSpeechOptimizer {\n    static class Point {\n        double x, y;\n        Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    static class Polygon {\n        Point[] vertices;\n        Polygon(Point[] vertices) {\n            this.vertices = vertices;\n        }\n    }\n\n    static boolean lineIntersectsPolygon(Point start, Point end, Polygon polygon) {\n        Line2D line = new Line2D.Double(start.x, start.y, end.x, end.y);\n        for (int i = 0; i < polygon.vertices.length; i++) {\n            Point curr = polygon.vertices[i];\n            Point next = polygon.vertices[(i + 1) % polygon.vertices.length];\n            Line2D polygonEdge = new Line2D.Double(curr.x, curr.y, next.x, next.y);\n            if (line.intersectsLine(polygonEdge)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    static int maxVisibleVoters(Point[] voters, Polygon[] obstacles) {\n        int maxVisible = 0;\n        for (Point candidate : voters) {\n            int visibleCount = 0;\n            for (Point voter : voters) {\n                boolean visible = true;\n                for (Polygon obstacle : obstacles) {\n                    if (lineIntersectsPolygon(candidate, voter, obstacle)) {\n                        visible = false;\n                        break;\n                    }\n                }\n                if (visible) {\n                    visibleCount++;\n                }\n            }\n            maxVisible = Math.max(maxVisible, visibleCount);\n        }\n        return maxVisible;\n    }\n\n    public static void main(String[] args) {\n        Point[] voters = {\n            new Point(1, 2),\n            new Point(3, 4),\n            new Point(5, 6)\n        };\n\n        Polygon[] obstacles = {\n            new Polygon(new Point[]{\n                new Point(0, 0),\n                new Point(2, 0),\n                new Point(2, 2),\n                new Point(0, 2)\n            })\n        };\n\n        int result = maxVisibleVoters(voters, obstacles);\n        System.out.println(\"Maximum visible voters: \" + result);\n    }\n}",
    "timestamp": "2025-08-05 21:58:42"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <iomanip>\n#include <limits>\n\nconst double EPS = 1e-9;\n\nstruct Point {\n    double x, y;\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n    \n    Point operator-(const Point& p) const {\n        return Point(x - p.x, y - p.y);\n    }\n};\n\nstruct Line {\n    Point p1, p2;\n    Line(Point p1, Point p2) : p1(p1), p2(p2) {}\n};\n\nstruct Polygon {\n    std::vector<Point> vertices;\n};\n\ndouble cross_product(const Point& a, const Point& b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nbool is_point_inside_polygon(const Point& p, const Polygon& poly) {\n    int n = poly.vertices.size();\n    bool inside = false;\n    \n    for (int i = 0, j = n - 1; i < n; j = i++) {\n        if (((poly.vertices[i].y > p.y) != (poly.vertices[j].y > p.y)) &&\n            (p.x < (poly.vertices[j].x - poly.vertices[i].x) * (p.y - poly.vertices[i].y) /\n             (poly.vertices[j].y - poly.vertices[i].y) + poly.vertices[i].x)) {\n            inside = !inside;\n        }\n    }\n    \n    return inside;\n}\n\nbool line_intersects_polygon(const Line& line, const Polygon& poly) {\n    int n = poly.vertices.size();\n    \n    for (int i = 0; i < n; i++) {\n        Line polyLine(poly.vertices[i], poly.vertices[(i + 1) % n]);\n        \n        Point a = line.p1, b = line.p2;\n        Point c = polyLine.p1, d = polyLine.p2;\n        \n        double a1 = cross_product(b - a, c - a);\n        double a2 = cross_product(b - a, d - a);\n        double a3 = cross_product(d - c, a - c);\n        double a4 = cross_product(d - c, b - c);\n        \n        if (((a1 > 0 && a2 < 0) || (a1 < 0 && a2 > 0)) &&\n            ((a3 > 0 && a4 < 0) || (a3 < 0 && a4 > 0))) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n\nint count_visible_voters(const Point& position, const std::vector<Point>& voters, const std::vector<Polygon>& obstacles) {\n    int visible_count = 0;\n    \n    for (const Point& voter : voters) {\n        Line line(position, voter);\n        bool is_visible = true;\n        \n        for (const Polygon& obstacle : obstacles) {\n            if (line_intersects_polygon(line, obstacle)) {\n                is_visible = false;\n                break;\n            }\n        }\n        \n        if (is_visible) {\n            visible_count++;\n        }\n    }\n    \n    return visible_count;\n}\n\nint main() {\n    int N, M;\n    std::cin >> N >> M;\n    \n    std::vector<Polygon> obstacles(N);\n    for (int i = 0; i < N; i++) {\n        int k;\n        std::cin >> k;\n        obstacles[i].vertices.resize(k);\n        \n        for (int j = 0; j < k; j++) {\n            std::cin >> obstacles[i].vertices[j].x >> obstacles[i].vertices[j].y;\n        }\n    }\n    \n    std::vector<Point> voters(M);\n    for (int i = 0; i < M; i++) {\n        std::cin >> voters[i].x >> voters[i].y;\n    }\n    \n    int max_visible_voters = 0;\n    Point best_position;\n    \n    for (const Point& voter : voters) {\n        int visible_count = count_visible_voters(voter, voters, obstacles);\n        \n        if (visible_count > max_visible_voters) {\n            max_visible_voters = visible_count;\n            best_position = voter;\n        }\n    }\n    \n    std::cout << max_visible_voters << std::endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:58:56"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from shapely.geometry import Point, Polygon, LineString\nimport itertools\n\ndef max_visible_voters(obstacles, voters):\n    max_count = 0\n    best_location = None\n\n    # Generate candidate locations by using voters' positions\n    candidate_locations = [voter for voter in voters]\n\n    for loc in candidate_locations:\n        count = 0\n        for voter in voters:\n            if loc == voter:\n                count += 1\n                continue\n            line = LineString([loc, voter])\n            visible = True\n            for obstacle in obstacles:\n                if line.intersects(obstacle):\n                    visible = False\n                    break\n            if visible:\n                count += 1\n        if count > max_count:\n            max_count = count\n            best_location = loc\n\n    return best_location, max_count\n\n# Example usage:\nobstacles = [Polygon([(0, 0), (2, 0), (2, 2), (0, 2)]), \n             Polygon([(3, 3), (5, 3), (5, 5), (3, 5)])]\nvoters = [Point(1, 3), Point(4, 1), Point(6, 6), Point(5, 5)]\n\nbest_location, max_count = max_visible_voters(obstacles, voters)\nprint(f\"Best location: {best_location}, Visible voters: {max_count}\")",
    "timestamp": "2025-08-13 08:11:51"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.awt.*;\nimport java.awt.geom.*;\nimport java.util.*;\n\npublic class ElectionSpeech {\n\n    public static void main(String[] args) {\n        // Example input variables, replace these with actual data\n        List<Polygon> obstacles = new ArrayList<>();\n        List<Point> voters = new ArrayList<>();\n\n        // Call the function with input data\n        Point optimalLocation = findOptimalLocation(obstacles, voters);\n        System.out.println(\"Optimal Location: \" + optimalLocation);\n    }\n\n    public static Point findOptimalLocation(List<Polygon> obstacles, List<Point> voters) {\n        int maxVisible = 0;\n        Point bestLocation = null;\n        \n        for (Point voter : voters) {\n            int countVisible = countVisibleVoters(voter, obstacles, voters);\n            if (countVisible > maxVisible) {\n                maxVisible = countVisible;\n                bestLocation = voter;\n            }\n        }\n        \n        System.out.println(\"Maximum number of visible voters: \" + maxVisible);\n        return bestLocation;\n    }\n\n    private static int countVisibleVoters(Point position, List<Polygon> obstacles, List<Point> voters) {\n        int count = 0;\n        \n        for (Point voter : voters) {\n            if (isVisible(position, voter, obstacles)) {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n\n    private static boolean isVisible(Point source, Point destination, List<Polygon> obstacles) {\n        Line2D line = new Line2D.Double(source, destination);\n        \n        for (Polygon obstacle : obstacles) {\n            if (linesIntersectPolygon(line, obstacle)) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n\n    private static boolean linesIntersectPolygon(Line2D line, Polygon polygon) {\n        int nPoints = polygon.npoints;\n        for (int i = 0; i < nPoints; i++) {\n            int next = (i + 1) % nPoints;\n            Line2D edge = new Line2D.Double(\n                    polygon.xpoints[i], polygon.ypoints[i],\n                    polygon.xpoints[next], polygon.ypoints[next]);\n            if (line.intersectsLine(edge)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}",
    "timestamp": "2025-08-13 08:11:58"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n\n#define MAX_VOTERS 100\n#define MAX_VERTICES 20\n#define MAX_OBSTACLES 50\n\ntypedef struct {\n    double x, y;\n} Point;\n\ntypedef struct {\n    int vertex_count;\n    Point vertices[MAX_VERTICES];\n} Polygon;\n\nint is_point_inside_polygon(Point point, Polygon poly) {\n    int i, j, c = 0;\n    for (i = 0, j = poly.vertex_count-1; i < poly.vertex_count; j = i++) {\n        if (((poly.vertices[i].y > point.y) != (poly.vertices[j].y > point.y)) &&\n            (point.x < (poly.vertices[j].x - poly.vertices[i].x) * (point.y - poly.vertices[i].y) / \n            (poly.vertices[j].y - poly.vertices[i].y) + poly.vertices[i].x)) {\n            c = !c;\n        }\n    }\n    return c;\n}\n\nint is_visible(Point candidate, Point voter, Polygon obstacles[], int obstacle_count) {\n    for (int i = 0; i < obstacle_count; i++) {\n        for (int j = 0; j < obstacles[i].vertex_count; j++) {\n            Point a = obstacles[i].vertices[j];\n            Point b = obstacles[i].vertices[(j + 1) % obstacles[i].vertex_count];\n            double denom = (b.y - a.y) * (voter.x - candidate.x) - (b.x - a.x) * (voter.y - candidate.y);\n            if (denom == 0) continue; // parallel lines\n            double ua = ((b.x - a.x) * (candidate.y - a.y) - (b.y - a.y) * (candidate.x - a.x)) / denom;\n            double ub = ((voter.x - candidate.x) * (candidate.y - a.y) - (voter.y - candidate.y) * (candidate.x - a.x)) / denom;\n            if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) return 0; // intersection\n        }\n    }\n    return 1;\n}\n\nint visible_voters(Point candidate, Point voters[], int voter_count, Polygon obstacles[], int obstacle_count) {\n    int visible_count = 0;\n    for (int i = 0; i < voter_count; i++) {\n        if (is_visible(candidate, voters[i], obstacles, obstacle_count)) {\n            visible_count++;\n        }\n    }\n    return visible_count;\n}\n\nint main() {\n    int m, n, i, j, k, max_vis = 0;\n    Point voters[MAX_VOTERS];\n    Polygon obstacles[MAX_OBSTACLES];\n\n    // Assume proper input reading code here for voters and obstacles\n    // scanf pattern for reading voters and obstacles omitted for brevity\n\n    for (i = 0; i < voter_count; i++) {\n        for (j = i + 1; j < voter_count; j++) {\n            Point mid_point;\n            mid_point.x = (voters[i].x + voters[j].x) / 2;\n            mid_point.y = (voters[i].y + voters[j].y) / 2;\n\n            int visible = visible_voters(mid_point, voters, voter_count, obstacles, obstacle_count);\n            if (visible > max_vis) {\n                max_vis = visible;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", max_vis);\n    return 0;\n}",
    "timestamp": "2025-08-13 08:12:09"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from typing import List, Tuple\nimport math\n\ndef is_point_inside_polygon(point: Tuple[float, float], polygon: List[Tuple[float, float]]) -> bool:\n    x, y = point\n    inside = False\n    n = len(polygon)\n    j = n - 1\n\n    for i in range(n):\n        xi, yi = polygon[i]\n        xj, yj = polygon[j]\n\n        intersect = ((yi > y) != (yj > y)) and (x < (xj - xi) * (y - yi) / (yj - yi) + xi)\n        if intersect:\n            inside = not inside\n        j = i\n\n    return inside\n\ndef line_intersects_polygon(start: Tuple[float, float], end: Tuple[float, float], polygon: List[Tuple[float, float]]) -> bool:\n    def ccw(a: Tuple[float, float], b: Tuple[float, float], c: Tuple[float, float]) -> bool:\n        return (c[1] - a[1]) * (b[0] - a[0]) > (b[1] - a[1]) * (c[0] - a[0])\n\n    def intersect(a: Tuple[float, float], b: Tuple[float, float], c: Tuple[float, float], d: Tuple[float, float]) -> bool:\n        return ccw(a, c, d) != ccw(b, c, d) and ccw(a, b, c) != ccw(a, b, d)\n\n    n = len(polygon)\n    for i in range(n):\n        if intersect(start, end, polygon[i], polygon[(i + 1) % n]):\n            return True\n    return False\n\ndef count_visible_voters(position: Tuple[float, float], voters: List[Tuple[float, float]], obstacles: List[List[Tuple[float, float]]]) -> int:\n    visible_count = 0\n    for voter in voters:\n        is_visible = True\n        for obstacle in obstacles:\n            if line_intersects_polygon(position, voter, obstacle):\n                is_visible = False\n                break\n        if is_visible:\n            visible_count += 1\n    return visible_count\n\ndef find_max_visible_voters(voters: List[Tuple[float, float]], obstacles: List[List[Tuple[float, float]]]) -> Tuple[Tuple[float, float], int]:\n    max_visible = 0\n    best_position = None\n\n    # Consider voter positions as potential locations\n    for position in voters:\n        visible_count = count_visible_voters(position, voters, obstacles)\n        if visible_count > max_visible:\n            max_visible = visible_count\n            best_position = position\n\n    return best_position, max_visible\n\n# Example usage\ndef main():\n    voters = [(1, 2), (3, 4), (5, 6), (7, 8)]\n    obstacles = [\n        [(0, 0), (2, 0), (2, 2), (0, 2)],\n        [(4, 4), (6, 4), (6, 6), (4, 6)]\n    ]\n\n    best_location, max_voters = find_max_visible_voters(voters, obstacles)\n    print(f\"Best location: {best_location}\")\n    print(f\"Maximum visible voters: {max_voters}\")\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 08:12:32"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\n\ndef readints():\n    return list(map(int, input().split()))\n\ndef cross(o, a, b):\n    return (a[0]-o[0])*(b[1]-o[1]) - (a[1]-o[1])*(b[0]-o[0])\n\ndef segments_intersect(a1, a2, b1, b2):\n    c1 = cross(a1, a2, b1)\n    c2 = cross(a1, a2, b2)\n    c3 = cross(b1, b2, a1)\n    c4 = cross(b1, b2, a2)\n    \n    if ((c1 > 0 and c2 < 0) or (c1 < 0 and c2 > 0)) and ((c3 > 0 and c4 < 0) or (c3 < 0 and c4 > 0)):\n        return True\n    if c1 == 0 and on_segment(a1, a2, b1):\n        return True\n    if c2 == 0 and on_segment(a1, a2, b2):\n        return True\n    if c3 == 0 and on_segment(b1, b2, a1):\n        return True\n    if c4 == 0 and on_segment(b1, b2, a2):\n        return True\n    return False\n\ndef on_segment(a, b, c):\n    return min(a[0], b[0]) <= c[0] <= max(a[0], b[0]) and min(a[1], b[1]) <= c[1] <= max(a[1], b[1])\n\ndef point_in_polygon(p, poly):\n    x, y = p\n    n = len(poly)\n    inside = False\n    for i in range(n):\n        j = (i + 1) % n\n        xi, yi = poly[i]\n        xj, yj = poly[j]\n        if ((yi > y) != (yj > y)) and (x < (xj - xi) * (y - yi) / (yj - yi) + xi):\n            inside = not inside\n    return inside\n\ndef main():\n    N, M = readints()\n    obstacles = []\n    for _ in range(N):\n        C = readints()[0]\n        polygon = []\n        for _ in range(C):\n            x, y = readints()\n            polygon.append((x, y))\n        obstacles.append(polygon)\n    \n    voters = []\n    for _ in range(M):\n        x, y = readints()\n        voters.append((x, y))\n    \n    max_voters = 0\n    \n    for i in range(M):\n        x_candidate = voters[i][0]\n        y_candidate = voters[i][1]\n        count = 0\n        \n        for j in range(M):\n            x_voter, y_voter = voters[j]\n            visible = True\n            \n            for poly in obstacles:\n                if point_in_polygon((x_candidate, y_candidate), poly) or point_in_polygon((x_voter, y_voter), poly):\n                    visible = False\n                    break\n                \n                n = len(poly)\n                for k in range(n):\n                    l = (k + 1) % n\n                    a1 = poly[k]\n                    a2 = poly[l]\n                    if segments_intersect((x_candidate, y_candidate), (x_voter, y_voter), a1, a2):\n                        visible = False\n                        break\n                if not visible:\n                    break\n            \n            if visible:\n                count += 1\n        \n        if count > max_voters:\n            max_voters = count\n    \n    print(max_voters)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 08:12:58"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cmath>\n\nusing namespace std;\n\nstruct Point {\n    double x, y;\n};\n\nstruct Polygon {\n    vector<Point> vertices;\n};\n\nbool onSegment(Point p, Point q, Point r) {\n    return q.x <= max(p.x, r.x) && q.x >= min(p.x, r.x) &&\n           q.y <= max(p.y, r.y) && q.y >= min(p.y, r.y);\n}\n\nint orientation(Point p, Point q, Point r) {\n    double val = (q.y - p.y) * (r.x - q.x) - \n                 (q.x - p.x) * (r.y - q.y);\n    if (val == 0) return 0;\n    return (val > 0)? 1: 2;\n}\n\nbool doIntersect(Point p1, Point q1, Point p2, Point q2) {\n    int o1 = orientation(p1, q1, p2);\n    int o2 = orientation(p1, q1, q2);\n    int o3 = orientation(p2, q2, p1);\n    int o4 = orientation(p2, q2, q1);\n\n    if (o1 != o2 && o3 != o4) return true;\n\n    if (o1 == 0 && onSegment(p1, p2, q1)) return true;\n    if (o2 == 0 && onSegment(p1, q2, q1)) return true;\n    if (o3 == 0 && onSegment(p2, p1, q2)) return true;\n    if (o4 == 0 && onSegment(p2, q1, q2)) return true;\n\n    return false;\n}\n\nbool isVisible(Point X, Point V, const vector<Polygon>& obstacles) {\n    for (const auto& poly : obstacles) {\n        int n = poly.vertices.size();\n        for (int i = 0; i < n; ++i) {\n            Point p1 = poly.vertices[i];\n            Point p2 = poly.vertices[(i + 1) % n];\n            if (doIntersect(X, V, p1, p2)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    \n    vector<Polygon> obstacles(N);\n    for (int i = 0; i < N; ++i) {\n        int K;\n        cin >> K;\n        obstacles[i].vertices.resize(K);\n        for (int j = 0; j < K; ++j) {\n            cin >> obstacles[i].vertices[j].x >> obstacles[i].vertices[j].y;\n        }\n    }\n\n    vector<Point> voters(M);\n    for (int i = 0; i < M; ++i) {\n        cin >> voters[i].x >> voters[i].y;\n    }\n\n    double maxX = 0, maxY = 0;\n    int maxVisibleVoters = 0;\n\n    for (const auto& v1 : voters) {\n        int visibleCount = 0;\n        for (const auto& v2 : voters) {\n            if (isVisible(v1, v2, obstacles)) {\n                visibleCount++;\n            }\n        }\n        if (visibleCount > maxVisibleVoters) {\n            maxVisibleVoters = visibleCount;\n            maxX = v1.x;\n            maxY = v1.y;\n        }\n    }\n\n    cout << \"Best location: (\" << maxX << \", \" << maxY << \")\\n\";\n    cout << \"Max visible voters: \" << maxVisibleVoters << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:43:55"
  }
]