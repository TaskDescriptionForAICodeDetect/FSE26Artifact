[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MOD 1000000007\n\nint main() {\n    int N, K;\n    scanf(\"%d %d\", &N, &K);\n    \n    long long dp[101][101] = {0};\n    \n    for (int i = 1; i <= N; i++) {\n        dp[1][i] = 1;\n    }\n    \n    for (int len = 2; len <= K; len++) {\n        for (int last = 1; last <= N; last++) {\n            for (int prev = 1; prev <= N; prev++) {\n                if (last * prev <= N) {\n                    dp[len][last] = (dp[len][last] + dp[len-1][prev]) % MOD;\n                }\n            }\n        }\n    }\n    \n    long long total = 0;\n    for (int i = 1; i <= N; i++) {\n        total = (total + dp[K][i]) % MOD;\n    }\n    \n    printf(\"%lld\\n\", total);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:47:17"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MOD 1000000007\n\nint main() {\n    int N, K;\n    scanf(\"%d %d\", &N, &K);\n    \n    // Precompute the list of valid next elements for each a_i\n    int max_a = N;\n    int *valid_next = (int *)malloc((max_a + 1) * sizeof(int));\n    memset(valid_next, 0, (max_a + 1) * sizeof(int));\n    \n    for (int a = 1; a <= max_a; ++a) {\n        int count = 0;\n        for (int b = 1; b <= max_a; ++b) {\n            if (a * b <= N) {\n                count++;\n            }\n        }\n        valid_next[a] = count;\n    }\n    \n    // DP table: dp[k][a] = number of sequences of length k ending with a\n    int **dp = (int **)malloc((K + 1) * sizeof(int *));\n    for (int i = 0; i <= K; ++i) {\n        dp[i] = (int *)malloc((max_a + 1) * sizeof(int));\n        memset(dp[i], 0, (max_a + 1) * sizeof(int));\n    }\n    \n    // Base case: sequences of length 1\n    for (int a = 1; a <= max_a; ++a) {\n        dp[1][a] = 1;\n    }\n    \n    for (int k = 2; k <= K; ++k) {\n        for (int a = 1; a <= max_a; ++a) {\n            dp[k][a] = 0;\n            for (int b = 1; b <= max_a; ++b) {\n                if (a * b <= N) {\n                    dp[k][a] = (dp[k][a] + dp[k-1][b]) % MOD;\n                }\n            }\n        }\n    }\n    \n    int result = 0;\n    for (int a = 1; a <= max_a; ++a) {\n        result = (result + dp[K][a]) % MOD;\n    }\n    \n    printf(\"%d\\n\", result);\n    \n    // Free memory\n    for (int i = 0; i <= K; ++i) {\n        free(dp[i]);\n    }\n    free(dp);\n    free(valid_next);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:47:40"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int N, K;\n    cin >> N >> K;\n\n    vector<vector<int>> dp(K, vector<int>(N + 1, 0));\n    for (int i = 1; i <= N; ++i) {\n        dp[0][i] = 1;\n    }\n\n    for (int k = 1; k < K; ++k) {\n        vector<int> prefix(N + 1, 0);\n        for (int i = 1; i <= N; ++i) {\n            prefix[i] = (prefix[i - 1] + dp[k - 1][i]) % MOD;\n        }\n        for (int i = 1; i <= N; ++i) {\n            int max_j = N / i;\n            if (max_j > N) max_j = N;\n            dp[k][i] = prefix[max_j];\n        }\n    }\n\n    int result = 0;\n    for (int i = 1; i <= N; ++i) {\n        result = (result + dp[K - 1][i]) % MOD;\n    }\n    cout << result << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:47:53"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Solution {\n    static final int MOD = 1000000007;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int K = scanner.nextInt();\n        scanner.close();\n\n        // Precompute the list of possible next elements for each current element\n        Map<Integer, List<Integer>> adj = new HashMap<>();\n        for (int a = 1; a <= N; a++) {\n            List<Integer> nextList = new ArrayList<>();\n            for (int b = 1; b <= N; b++) {\n                if (a * b <= N) {\n                    nextList.add(b);\n                }\n            }\n            adj.put(a, nextList);\n        }\n\n        // DP table: dp[k][a] = number of sequences of length k ending with a\n        int[][] dp = new int[K + 1][N + 1];\n        for (int a = 1; a <= N; a++) {\n            dp[1][a] = 1;\n        }\n\n        for (int k = 2; k <= K; k++) {\n            for (int a = 1; a <= N; a++) {\n                for (int b : adj.get(a)) {\n                    dp[k][b] = (dp[k][b] + dp[k - 1][a]) % MOD;\n                }\n            }\n        }\n\n        int result = 0;\n        for (int a = 1; a <= N; a++) {\n            result = (result + dp[K][a]) % MOD;\n        }\n        System.out.println(result);\n    }\n}",
    "timestamp": "2025-08-05 22:48:07"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "class Solution {\n    private static final int MOD = 1_000_000_007;\n\n    public int countSequence(int N, int K) {\n        int[][] dp = new int[K + 1][N + 1];\n        \n        // Initialize base case\n        for (int j = 1; j <= N; j++) {\n            dp[1][j] = 1;\n        }\n        \n        // Build dynamic programming table\n        for (int i = 2; i <= K; i++) {\n            for (int j = 1; j <= N; j++) {\n                for (int prev = 1; prev <= N; prev++) {\n                    if (prev * j <= N) {\n                        dp[i][j] = (dp[i][j] + dp[i-1][prev]) % MOD;\n                    }\n                }\n            }\n        }\n        \n        // Sum up all valid sequences of length K\n        int result = 0;\n        for (int j = 1; j <= N; j++) {\n            result = (result + dp[K][j]) % MOD;\n        }\n        \n        return result;\n    }\n}",
    "timestamp": "2025-08-05 22:48:12"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "class Solution {\npublic:\n    int numOfSequence(int N, int K) {\n        const int MOD = 1e9 + 7;\n        vector<vector<int>> dp(K + 1, vector<int>(N + 1, 0));\n        \n        // Initialize base case\n        for (int j = 1; j <= N; j++) {\n            dp[1][j] = 1;\n        }\n        \n        // Dynamic programming\n        for (int i = 2; i <= K; i++) {\n            for (int j = 1; j <= N; j++) {\n                for (int k = 1; k <= N; k++) {\n                    if ((long long)j * k <= N) {\n                        dp[i][j] = (dp[i][j] + dp[i-1][k]) % MOD;\n                    }\n                }\n            }\n        }\n        \n        // Sum all possible last elements\n        int result = 0;\n        for (int j = 1; j <= N; j++) {\n            result = (result + dp[K][j]) % MOD;\n        }\n        \n        return result;\n    }\n};",
    "timestamp": "2025-08-05 22:48:17"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "MOD = 10**9 + 7\n\ndef count_sequences(K, N):\n    dp = [1] * (N + 1)\n    for _ in range(1, K):\n        new_dp = [0] * (N + 1)\n        for i in range(1, N + 1):\n            for j in range(1, N + 1):\n                if i * j <= N:\n                    new_dp[i] = (new_dp[i] + dp[j]) % MOD\n        dp = new_dp\n    return sum(dp) % MOD\n\n# Example usage:\nK = 3\nN = 12\nprint(count_sequences(K, N))",
    "timestamp": "2025-08-13 12:35:22"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class SequenceCounter {\n    private static final int MOD = 1000000007;\n\n    public static long countSequences(int K, int N) {\n        long[][] dp = new long[K + 1][N + 1];\n        Arrays.fill(dp[1], 1);\n\n        for (int i = 2; i <= K; i++) {\n            for (int j = 1; j <= N; j++) {\n                for (int k = 1; k * j <= N; k++) {\n                    dp[i][j] += dp[i - 1][k];\n                    dp[i][j] %= MOD;\n                }\n            }\n        }\n\n        long result = 0;\n        for (int i = 1; i <= N; i++) {\n            result += dp[K][i];\n            result %= MOD;\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int K = scanner.nextInt();\n        int N = scanner.nextInt();\n        scanner.close();\n\n        System.out.println(countSequences(K, N));\n    }\n}",
    "timestamp": "2025-08-13 12:35:24"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MOD 1000000007\n\nint countSequences(int K, int N) {\n    int dp[K+1][N+1];\n    for (int i = 0; i <= K; ++i)\n        for (int j = 0; j <= N; ++j)\n            dp[i][j] = 0;\n    \n    for (int i = 1; i <= N; ++i)\n        dp[1][i] = 1;\n\n    for (int len = 2; len <= K; ++len) {\n        for (int current = 1; current <= N; ++current) {\n            for (int prev = 1; prev <= N; ++prev) {\n                if (currrent * prev <= N) {\n                    dp[len][current] = (dp[len][current] + dp[len - 1][prev]) % MOD;\n                }\n            }\n        }\n    }\n\n    int result = 0;\n    for (int i = 1; i <= N; ++i) {\n        result = (result + dp[K][i]) % MOD;\n    }\n    \n    return result;\n}\n\nint main() {\n    int K, N;\n    scanf(\"%d %d\", &K, &N);\n    printf(\"%d\\n\", countSequences(K, N));\n    return 0;\n}",
    "timestamp": "2025-08-13 12:35:28"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function countSequences(K, N) {\n    const MOD = 1e9 + 7;\n    const dp = Array.from({ length: K }, () => []);\n  \n    for (let i = 1; i * i <= N; i++) {\n        dp[0][i] = 1;\n    }\n\n    for (let k = 1; k < K; k++) {\n        for (let i = 1; i <= N; i++) {\n            dp[k][i] = 0;\n            for (let j = 1; j <= N; j++) {\n                if (i * j <= N) {\n                    dp[k][i] = (dp[k][i] + dp[k - 1][j]) % MOD;\n                }\n            }\n        }\n    }\n\n    let result = 0;\n    for (let i = 1; i <= N; i++) {\n        result = (result + dp[K - 1][i]) % MOD;\n    }\n\n    return result;\n}",
    "timestamp": "2025-08-13 12:35:33"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_sequences(K, N):\n    MOD = 10**9 + 7\n    \n    # Initialize DP table\n    dp = [[0] * (N+1) for _ in range(K+1)]\n    \n    # Base case: sequences of length 1\n    for j in range(1, N+1):\n        dp[1][j] = 1\n    \n    # Build sequences\n    for length in range(2, K+1):\n        for last in range(1, N+1):\n            for prev in range(1, N+1):\n                if last * prev <= N:\n                    dp[length][last] = (dp[length][last] + dp[length-1][prev]) % MOD\n    \n    # Sum all valid sequences of length K\n    result = sum(dp[K][j] for j in range(1, N+1)) % MOD\n    \n    return result",
    "timestamp": "2025-08-13 12:35:38"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function countSequences(K, N) {\n    const MOD = 1e9 + 7;\n    const dp = Array.from({ length: K }, () => Array(N + 1).fill(0));\n\n    // Initial state: all numbers from 1 to N can start a sequence\n    for (let j = 1; j <= N; j++) {\n        dp[0][j] = 1;\n    }\n\n    // Build the DP table\n    for (let i = 1; i < K; i++) {\n        for (let curr = 1; curr <= N; curr++) {\n            for (let prev = 1; prev <= N; prev++) {\n                if (curr * prev <= N) {\n                    dp[i][curr] = (dp[i][curr] + dp[i-1][prev]) % MOD;\n                }\n            }\n        }\n    }\n\n    // Sum all possible last elements\n    let result = 0;\n    for (let j = 1; j <= N; j++) {\n        result = (result + dp[K-1][j]) % MOD;\n    }\n\n    return result;\n}",
    "timestamp": "2025-08-13 12:35:49"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "MOD = 10**9 + 7\n\ndef solve():\n    N, K = map(int, input().split())\n    \n    # Precompute the list of possible a_i values (1..N)\n    max_a = N\n    # For each a_i, find the list of possible a_{i+1} such that a_i * a_{i+1} <= N\n    # We can represent this as for each x, the count of y where y <= floor(N/x)\n    # So for each x, the number of valid next elements is floor(N/x)\n    \n    # We will use dynamic programming where dp[k][x] is the number of sequences of length k ending with x\n    # Initialize dp[1][x] = 1 for all x from 1 to N\n    # Then dp[k][x] = sum_{y where x*y <= N} dp[k-1][y]\n    \n    # To optimize, we can represent dp[k] as a list where dp_prev[x] is the count for sequences ending with x\n    dp_prev = [0] * (N + 2)\n    for x in range(1, N + 1):\n        dp_prev[x] = 1\n    \n    for _ in range(2, K + 1):\n        dp_next = [0] * (N + 2)\n        # Precompute prefix sums of dp_prev for efficient range queries\n        prefix = [0] * (N + 2)\n        for x in range(1, N + 1):\n            prefix[x] = (prefix[x - 1] + dp_prev[x]) % MOD\n        \n        for x in range(1, N + 1):\n            max_y = N // x\n            if max_y > N:\n                max_y = N\n            # The valid y's are 1..max_y\n            dp_next[x] = prefix[max_y]\n        \n        dp_prev = dp_next\n    \n    total = sum(dp_prev) % MOD\n    print(total)\n\nsolve()",
    "timestamp": "2025-08-13 12:36:00"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const MOD = 1e9 + 7;\n\nfunction solve(N, K) {\n    // Precompute the list of possible next elements for each x\n    const adj = {};\n    for (let x = 1; x <= N; x++) {\n        adj[x] = [];\n        for (let y = 1; y <= N; y++) {\n            if (x * y <= N) {\n                adj[x].push(y);\n            }\n        }\n    }\n\n    // Initialize DP table\n    let dp = {};\n    for (let x = 1; x <= N; x++) {\n        dp[x] = 1;\n    }\n\n    for (let step = 2; step <= K; step++) {\n        let newDp = {};\n        for (let x = 1; x <= N; x++) {\n            newDp[x] = 0;\n        }\n        for (let x = 1; x <= N; x++) {\n            for (const y of adj[x]) {\n                newDp[y] = (newDp[y] + dp[x]) % MOD;\n            }\n        }\n        dp = newDp;\n    }\n\n    let result = 0;\n    for (let x = 1; x <= N; x++) {\n        result = (result + dp[x]) % MOD;\n    }\n    return result;\n}\n\n// Example usage:\n// console.log(solve(10, 2)); // Replace with actual input",
    "timestamp": "2025-08-13 12:36:08"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int K, N;\n    cin >> K >> N;\n\n    vector<vector<int>> dp(K + 1, vector<int>(N + 1, 0));\n\n    for (int i = 1; i <= N; i++) {\n        dp[1][i] = 1; // There is one sequence of length 1 for each number 1, 2, ..., N\n    }\n\n    for (int len = 2; len <= K; len++) {\n        for (int x = 1; x <= N; x++) {\n            for (int y = 1; y * x <= N; y++) {\n                dp[len][x] = (dp[len][x] + dp[len - 1][y]) % MOD;\n            }\n        }\n    }\n\n    int result = 0;\n    for (int x = 1; x <= N; x++) {\n        result = (result + dp[K][x]) % MOD;\n    }\n\n    cout << result << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 14:35:26"
  }
]